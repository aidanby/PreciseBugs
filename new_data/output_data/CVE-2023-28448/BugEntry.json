{"buggy_code": ["// Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n//! Serialization support for primitive data types.\n#![allow(clippy::float_cmp)]\n\nuse self::super::{VersionMap, Versionize, VersionizeError, VersionizeResult};\nuse vmm_sys_util::fam::{FamStruct, FamStructWrapper};\n\n/// Maximum allowed string len in bytes (16KB).\n/// Calling `serialize()` or `deserialiaze()` will fail beyond this limit.\npub const MAX_STRING_LEN: usize = 16384;\n/// Maximum allowed vec size in bytes (10MB).\n/// Calling `serialize()` or `deserialiaze()` will fail beyond this limit.\npub const MAX_VEC_SIZE: usize = 10_485_760;\n\n/// A macro that implements the Versionize trait for primitive types using the\n/// serde bincode backed.\nmacro_rules! impl_versionize {\n    ($ty:ident) => {\n        impl Versionize for $ty {\n            #[inline]\n            fn serialize<W: std::io::Write>(\n                &self,\n                writer: &mut W,\n                _version_map: &VersionMap,\n                _version: u16,\n            ) -> VersionizeResult<()> {\n                bincode::serialize_into(writer, &self)\n                    .map_err(|ref err| VersionizeError::Serialize(format!(\"{:?}\", err)))?;\n                Ok(())\n            }\n\n            #[inline]\n            fn deserialize<R: std::io::Read>(\n                mut reader: &mut R,\n                _version_map: &VersionMap,\n                _version: u16,\n            ) -> VersionizeResult<Self>\n            where\n                Self: Sized,\n            {\n                bincode::deserialize_from(&mut reader)\n                    .map_err(|ref err| VersionizeError::Deserialize(format!(\"{:?}\", err)))\n            }\n\n            // Not used.\n            fn version() -> u16 {\n                1\n            }\n        }\n    };\n}\n\nimpl_versionize!(bool);\nimpl_versionize!(isize);\nimpl_versionize!(i8);\nimpl_versionize!(i16);\nimpl_versionize!(i32);\nimpl_versionize!(i64);\nimpl_versionize!(i128);\nimpl_versionize!(usize);\nimpl_versionize!(u8);\nimpl_versionize!(u16);\nimpl_versionize!(u32);\nimpl_versionize!(u64);\nimpl_versionize!(u128);\nimpl_versionize!(f32);\nimpl_versionize!(f64);\nimpl_versionize!(char);\n\nimpl Versionize for String {\n    #[inline]\n    fn serialize<W: std::io::Write>(\n        &self,\n        writer: &mut W,\n        version_map: &VersionMap,\n        app_version: u16,\n    ) -> VersionizeResult<()> {\n        // It is better to fail early at serialization time.\n        if self.len() > MAX_STRING_LEN {\n            return Err(VersionizeError::StringLength(self.len()));\n        }\n\n        self.len().serialize(writer, version_map, app_version)?;\n        writer\n            .write_all(self.as_bytes())\n            .map_err(|e| VersionizeError::Io(e.raw_os_error().unwrap_or(0)))?;\n        Ok(())\n    }\n\n    #[inline]\n    fn deserialize<R: std::io::Read>(\n        mut reader: &mut R,\n        version_map: &VersionMap,\n        app_version: u16,\n    ) -> VersionizeResult<Self> {\n        let len = usize::deserialize(&mut reader, version_map, app_version)?;\n        // Even if we fail in serialize, we still need to enforce this on the hot path\n        // in case the len is corrupted.\n        if len > MAX_STRING_LEN {\n            return Err(VersionizeError::StringLength(len));\n        }\n\n        let mut v = vec![0u8; len];\n        reader\n            .read_exact(v.as_mut_slice())\n            .map_err(|e| VersionizeError::Io(e.raw_os_error().unwrap_or(0)))?;\n        String::from_utf8(v)\n            .map_err(|err| VersionizeError::Deserialize(format!(\"Utf8 error: {:?}\", err)))\n    }\n\n    // Not used yet.\n    fn version() -> u16 {\n        1\n    }\n}\n\nmacro_rules! impl_versionize_array_with_size {\n    ($ty:literal) => {\n        impl<T> Versionize for [T; $ty]\n        where\n            T: Copy + Default + Versionize,\n        {\n            #[inline]\n            fn serialize<W: std::io::Write>(\n                &self,\n                writer: &mut W,\n                version_map: &VersionMap,\n                app_version: u16,\n            ) -> VersionizeResult<()> {\n                for element in self {\n                    element.serialize(writer, version_map, app_version)?;\n                }\n\n                Ok(())\n            }\n\n            #[inline]\n            fn deserialize<R: std::io::Read>(\n                reader: &mut R,\n                version_map: &VersionMap,\n                app_version: u16,\n            ) -> VersionizeResult<Self> {\n                let mut array = [T::default(); $ty];\n                for i in 0..$ty {\n                    array[i] = T::deserialize(reader, version_map, app_version)?;\n                }\n                Ok(array)\n            }\n\n            // Not used yet.\n            fn version() -> u16 {\n                1\n            }\n        }\n    };\n}\n\n// Conventionally, traits are available for primitive arrays only up to size 32\n// until the const generics feature is implemented.\n// [https://doc.rust-lang.org/std/primitive.array.html]\n// [https://github.com/rust-lang/rust/issues/44580]\nmacro_rules! impl_versionize_arrays {\n    ($($N:literal)+) => {\n        $(\n            impl_versionize_array_with_size!($N);\n        )+\n    }\n}\n\nimpl_versionize_arrays! {\n    1  2  3  4  5  6  7  8  9 10\n   11 12 13 14 15 16 17 18 19 20\n   21 22 23 24 25 26 27 28 29 30\n   31 32\n}\n\nimpl<T> Versionize for Box<T>\nwhere\n    T: Versionize,\n{\n    #[inline]\n    fn serialize<W: std::io::Write>(\n        &self,\n        writer: &mut W,\n        version_map: &VersionMap,\n        app_version: u16,\n    ) -> VersionizeResult<()> {\n        self.as_ref().serialize(writer, version_map, app_version)\n    }\n\n    #[inline]\n    fn deserialize<R: std::io::Read>(\n        reader: &mut R,\n        version_map: &VersionMap,\n        app_version: u16,\n    ) -> VersionizeResult<Self> {\n        Ok(Box::new(T::deserialize(reader, version_map, app_version)?))\n    }\n\n    // Not used yet.\n    fn version() -> u16 {\n        1\n    }\n}\n\nimpl<T> Versionize for std::num::Wrapping<T>\nwhere\n    T: Versionize,\n{\n    #[inline]\n    fn serialize<W: std::io::Write>(\n        &self,\n        writer: &mut W,\n        version_map: &VersionMap,\n        app_version: u16,\n    ) -> VersionizeResult<()> {\n        self.0.serialize(writer, version_map, app_version)\n    }\n\n    #[inline]\n    fn deserialize<R: std::io::Read>(\n        reader: &mut R,\n        version_map: &VersionMap,\n        app_version: u16,\n    ) -> VersionizeResult<Self> {\n        Ok(std::num::Wrapping(T::deserialize(\n            reader,\n            version_map,\n            app_version,\n        )?))\n    }\n\n    // Not used yet.\n    fn version() -> u16 {\n        1\n    }\n}\n\nimpl<T> Versionize for Option<T>\nwhere\n    T: Versionize,\n{\n    #[inline]\n    fn serialize<W: std::io::Write>(\n        &self,\n        writer: &mut W,\n        version_map: &VersionMap,\n        app_version: u16,\n    ) -> VersionizeResult<()> {\n        // Serialize an Option just like bincode does: u8, T.\n        match self {\n            Some(value) => {\n                1u8.serialize(writer, version_map, app_version)?;\n                value.serialize(writer, version_map, app_version)\n            }\n            None => 0u8.serialize(writer, version_map, app_version),\n        }\n    }\n\n    #[inline]\n    fn deserialize<R: std::io::Read>(\n        reader: &mut R,\n        version_map: &VersionMap,\n        app_version: u16,\n    ) -> VersionizeResult<Self> {\n        let option = u8::deserialize(reader, version_map, app_version)?;\n        match option {\n            0u8 => Ok(None),\n            1u8 => Ok(Some(T::deserialize(reader, version_map, app_version)?)),\n            value => Err(VersionizeError::Deserialize(format!(\n                \"Invalid option value {}\",\n                value\n            ))),\n        }\n    }\n\n    // Not used yet.\n    fn version() -> u16 {\n        1\n    }\n}\n\nimpl<T> Versionize for Vec<T>\nwhere\n    T: Versionize,\n{\n    #[inline]\n    fn serialize<W: std::io::Write>(\n        &self,\n        mut writer: &mut W,\n        version_map: &VersionMap,\n        app_version: u16,\n    ) -> VersionizeResult<()> {\n        if self.len() > MAX_VEC_SIZE / std::mem::size_of::<T>() {\n            return Err(VersionizeError::VecLength(self.len()));\n        }\n        // Serialize in the same fashion as bincode:\n        // Write len.\n        bincode::serialize_into(&mut writer, &self.len())\n            .map_err(|ref err| VersionizeError::Serialize(format!(\"{:?}\", err)))?;\n        // Walk the vec and write each element.\n        for element in self {\n            element.serialize(writer, version_map, app_version)?;\n        }\n        Ok(())\n    }\n\n    #[inline]\n    fn deserialize<R: std::io::Read>(\n        mut reader: &mut R,\n        version_map: &VersionMap,\n        app_version: u16,\n    ) -> VersionizeResult<Self> {\n        let mut v = Vec::new();\n        let len: usize = bincode::deserialize_from(&mut reader)\n            .map_err(|ref err| VersionizeError::Deserialize(format!(\"{:?}\", err)))?;\n\n        if len > MAX_VEC_SIZE / std::mem::size_of::<T>() {\n            return Err(VersionizeError::VecLength(len));\n        }\n\n        for _ in 0..len {\n            let element: T = T::deserialize(reader, version_map, app_version)\n                .map_err(|ref err| VersionizeError::Deserialize(format!(\"{:?}\", err)))?;\n            v.push(element);\n        }\n        Ok(v)\n    }\n\n    // Not used yet.\n    fn version() -> u16 {\n        1\n    }\n}\n\n// Implement versioning for FAM structures by using the FamStructWrapper interface.\nimpl<T: Default + FamStruct + Versionize> Versionize for FamStructWrapper<T>\nwhere\n    <T as FamStruct>::Entry: Versionize,\n    T: std::fmt::Debug,\n{\n    #[inline]\n    fn serialize<W: std::io::Write>(\n        &self,\n        mut writer: &mut W,\n        version_map: &VersionMap,\n        app_version: u16,\n    ) -> VersionizeResult<()> {\n        // Write the fixed size header.\n        self.as_fam_struct_ref()\n            .serialize(&mut writer, version_map, app_version)?;\n        // Write the array.\n        self.as_slice()\n            .to_vec()\n            .serialize(&mut writer, version_map, app_version)?;\n\n        Ok(())\n    }\n\n    #[inline]\n    fn deserialize<R: std::io::Read>(\n        reader: &mut R,\n        version_map: &VersionMap,\n        app_version: u16,\n    ) -> VersionizeResult<Self> {\n        let header = T::deserialize(reader, version_map, app_version)\n            .map_err(|ref err| VersionizeError::Deserialize(format!(\"{:?}\", err)))?;\n        let entries: Vec<<T as FamStruct>::Entry> =\n            Vec::deserialize(reader, version_map, app_version)\n                .map_err(|ref err| VersionizeError::Deserialize(format!(\"{:?}\", err)))?;\n        // Construct the object from the array items.\n        // Header(T) fields will be initialized by Default trait impl.\n        let mut object = FamStructWrapper::from_entries(&entries)\n            .map_err(|ref err| VersionizeError::Deserialize(format!(\"{:?}\", err)))?;\n        // Update Default T with the deserialized header.\n        *object.as_mut_fam_struct() = header;\n        Ok(object)\n    }\n\n    // Not used.\n    fn version() -> u16 {\n        1\n    }\n}\n\n// Manual implementation for tuple of 2 elems.\nimpl<T: Versionize, U: Versionize> Versionize for (T, U) {\n    #[inline]\n    fn serialize<W: std::io::Write>(\n        &self,\n        writer: &mut W,\n        version_map: &VersionMap,\n        app_version: u16,\n    ) -> VersionizeResult<()> {\n        self.0.serialize(writer, version_map, app_version)?;\n        self.1.serialize(writer, version_map, app_version)?;\n        Ok(())\n    }\n\n    #[inline]\n    fn deserialize<R: std::io::Read>(\n        reader: &mut R,\n        version_map: &VersionMap,\n        app_version: u16,\n    ) -> VersionizeResult<Self> {\n        Ok((\n            T::deserialize(reader, version_map, app_version)?,\n            U::deserialize(reader, version_map, app_version)?,\n        ))\n    }\n\n    // Not used yet.\n    fn version() -> u16 {\n        1\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    #![allow(clippy::undocumented_unsafe_blocks)]\n\n    use super::*;\n    use super::{VersionMap, Versionize, VersionizeResult};\n\n    // Generate primitive tests using this macro.\n    macro_rules! primitive_int_test {\n        ($ty:ident, $fn_name:ident) => {\n            #[test]\n            fn $fn_name() {\n                let vm = VersionMap::new();\n                let mut snapshot_mem = vec![0u8; 64];\n\n                let store: $ty = std::$ty::MAX;\n                store\n                    .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n                    .unwrap();\n                let restore =\n                    <$ty as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1).unwrap();\n\n                assert_eq!(store, restore);\n            }\n        };\n    }\n\n    primitive_int_test!(usize, test_ser_de_usize);\n    primitive_int_test!(isize, test_ser_de_isize);\n    primitive_int_test!(u8, test_ser_de_u8);\n    primitive_int_test!(u16, test_ser_de_u16);\n    primitive_int_test!(u32, test_ser_de_u32);\n    primitive_int_test!(u64, test_ser_de_u64);\n    primitive_int_test!(u128, test_ser_de_u128);\n    primitive_int_test!(i8, test_ser_de_i8);\n    primitive_int_test!(i16, test_ser_de_i16);\n    primitive_int_test!(i32, test_ser_de_i32);\n    primitive_int_test!(i64, test_ser_de_i64);\n    primitive_int_test!(i128, test_ser_de_i128);\n    primitive_int_test!(f32, test_ser_de_f32);\n    primitive_int_test!(f64, test_ser_de_f64);\n    primitive_int_test!(char, test_ser_de_char);\n\n    #[test]\n    fn test_corrupted_string_len() {\n        let vm = VersionMap::new();\n        let mut buffer = vec![0u8; 1024];\n\n        let string = String::from(\"Test string1\");\n        string\n            .serialize(&mut buffer.as_mut_slice(), &vm, 1)\n            .unwrap();\n\n        // Test corrupt length field.\n        assert_eq!(\n            <String as Versionize>::deserialize(\n                &mut buffer.as_slice().split_first().unwrap().1,\n                &vm,\n                1\n            )\n            .unwrap_err(),\n            VersionizeError::StringLength(6052837899185946624)\n        );\n\n        // Test incomplete string.\n        assert_eq!(\n            <String as Versionize>::deserialize(&mut buffer.as_slice().split_at(6).0, &vm, 1)\n                .unwrap_err(),\n            VersionizeError::Deserialize(\n                \"Io(Error { kind: UnexpectedEof, message: \\\"failed to fill whole buffer\\\" })\"\n                    .to_owned()\n            )\n        );\n\n        // Test NULL string len.\n        buffer[0] = 0;\n        assert_eq!(\n            <String as Versionize>::deserialize(&mut buffer.as_slice(), &vm, 1).unwrap(),\n            String::new()\n        );\n    }\n\n    #[test]\n    fn test_corrupted_vec_len() {\n        let vm = VersionMap::new();\n        let mut buffer = vec![0u8; 1024];\n\n        let mut string = String::from(\"Test string1\");\n        let vec = unsafe { string.as_mut_vec() };\n        vec.serialize(&mut buffer.as_mut_slice(), &vm, 1).unwrap();\n\n        // Test corrupt length field.\n        assert_eq!(\n            <Vec<u8> as Versionize>::deserialize(\n                &mut buffer.as_slice().split_first().unwrap().1,\n                &vm,\n                1\n            )\n            .unwrap_err(),\n            VersionizeError::VecLength(6052837899185946624)\n        );\n\n        // Test incomplete Vec.\n        assert_eq!(\n            <Vec<u8> as Versionize>::deserialize(&mut buffer.as_slice().split_at(6).0, &vm, 1)\n                .unwrap_err(),\n            VersionizeError::Deserialize(\n                \"Io(Error { kind: UnexpectedEof, message: \\\"failed to fill whole buffer\\\" })\"\n                    .to_owned()\n            )\n        );\n\n        // Test NULL Vec len.\n        buffer[0] = 0;\n        assert_eq!(\n            <Vec<u8> as Versionize>::deserialize(&mut buffer.as_slice(), &vm, 1).unwrap(),\n            Vec::new()\n        );\n    }\n\n    #[test]\n    fn test_ser_de_u32_tuple() {\n        let vm = VersionMap::new();\n        let mut snapshot_mem = vec![0u8; 64];\n\n        let store: (u32, u32) = (std::u32::MIN, std::u32::MAX);\n        store\n            .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n            .unwrap();\n        let restore =\n            <(u32, u32) as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1).unwrap();\n\n        assert_eq!(store, restore);\n    }\n\n    #[derive(Debug, serde_derive::Deserialize, PartialEq, serde_derive::Serialize, Versionize)]\n    enum CompatibleEnum {\n        A,\n        B(String),\n        C(u64, u64, char),\n    }\n\n    #[derive(Debug, serde_derive::Deserialize, PartialEq, serde_derive::Serialize, Versionize)]\n    struct TestCompatibility {\n        _string: String,\n        _array: [u8; 32],\n        _u8: u8,\n        _u16: u16,\n        _u32: u32,\n        _u64: u64,\n        _u128: u128,\n        _i8: i8,\n        _i16: i16,\n        _i32: i32,\n        _i64: i64,\n        _i128: i128,\n        _f32: f32,\n        _f64: f64,\n        _usize: usize,\n        _isize: isize,\n        _vec: Vec<u64>,\n        _option: Option<bool>,\n        _enums: Vec<CompatibleEnum>,\n        #[allow(clippy::box_collection)] // we want to test boxes explicitly\n        _box: Box<String>,\n    }\n\n    #[test]\n    fn test_bincode_deserialize_from_versionize() {\n        let mut snapshot_mem = vec![0u8; 4096];\n        let vm = VersionMap::new();\n\n        let test_struct = TestCompatibility {\n            _string: \"String\".to_owned(),\n            _array: [128u8; 32],\n            _u8: 1,\n            _u16: 32000,\n            _u32: 0x1234_5678,\n            _u64: 0x1234_5678_9875_4321,\n            _u128: 0x1234_5678_1234_5678_1234_5678_1234_5678,\n            _i8: -1,\n            _i16: -32000,\n            _i32: -0x1234_5678,\n            _i64: -0x1234_5678_9875_4321,\n            _i128: -0x1234_5678_9098_7654_3212_3456_7890_9876,\n            _usize: 0x1234_5678_9875_4321,\n            _isize: -0x1234_5678_9875_4321,\n            _f32: 0.123,\n            _f64: 0.123_456_789_000_000,\n            _vec: vec![33; 32],\n            _option: Some(true),\n            _enums: vec![\n                CompatibleEnum::A,\n                CompatibleEnum::B(\"abcd\".to_owned()),\n                CompatibleEnum::C(1, 2, 'a'),\n            ],\n            _box: Box::new(\"Box\".to_owned()),\n        };\n\n        Versionize::serialize(&test_struct, &mut snapshot_mem.as_mut_slice(), &vm, 1).unwrap();\n\n        let restored_state: TestCompatibility =\n            bincode::deserialize_from(snapshot_mem.as_slice()).unwrap();\n        assert_eq!(test_struct, restored_state);\n    }\n\n    #[test]\n    fn test_bincode_serialize_to_versionize() {\n        let mut snapshot_mem = vec![0u8; 4096];\n        let vm = VersionMap::new();\n\n        let test_struct = TestCompatibility {\n            _string: \"String\".to_owned(),\n            _array: [128u8; 32],\n            _u8: 1,\n            _u16: 32000,\n            _u32: 0x1234_5678,\n            _u64: 0x1234_5678_9875_4321,\n            _u128: 0x1234_1234_1234_1234_1234_1234_1234_1234,\n            _i8: -1,\n            _i16: -32000,\n            _i32: -0x1234_5678,\n            _i64: -0x1234_5678_9875_4321,\n            _i128: -0x1234_1234_1234_1234_1234_1234_1234_1234,\n            _usize: 0x1234_5678_9875_4321,\n            _isize: -0x1234_5678_9875_4321,\n            _f32: 0.123,\n            _f64: 0.123_456_789_000_000,\n            _vec: vec![33; 32],\n            _option: Some(true),\n            _enums: vec![\n                CompatibleEnum::A,\n                CompatibleEnum::B(\"abcd\".to_owned()),\n                CompatibleEnum::C(1, 2, 'a'),\n            ],\n            _box: Box::new(\"Box\".to_owned()),\n        };\n\n        bincode::serialize_into(snapshot_mem.as_mut_slice(), &test_struct).unwrap();\n\n        let restored_state: TestCompatibility =\n            Versionize::deserialize(&mut snapshot_mem.as_slice(), &vm, 1).unwrap();\n        assert_eq!(test_struct, restored_state);\n    }\n\n    #[test]\n    fn test_ser_de_bool() {\n        let vm = VersionMap::new();\n        let mut snapshot_mem = vec![0u8; 64];\n\n        let store = true;\n        store\n            .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n            .unwrap();\n        let restore =\n            <bool as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1).unwrap();\n\n        assert_eq!(store, restore);\n    }\n\n    #[test]\n    fn test_ser_de_string() {\n        let vm = VersionMap::new();\n        let mut snapshot_mem = vec![0u8; 64];\n\n        let store = String::from(\"test string\");\n        store\n            .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n            .unwrap();\n        let restore =\n            <String as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1).unwrap();\n\n        assert_eq!(store, restore);\n    }\n\n    #[test]\n    fn test_ser_de_vec() {\n        let vm = VersionMap::new();\n        let mut snapshot_mem = vec![0u8; 64];\n\n        let store = vec![\n            \"test 1\".to_owned(),\n            \"test 2\".to_owned(),\n            \"test 3\".to_owned(),\n        ];\n\n        store\n            .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n            .unwrap();\n        let restore =\n            <Vec<String> as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1).unwrap();\n\n        assert_eq!(store, restore);\n    }\n\n    #[test]\n    fn test_ser_de_option() {\n        let vm = VersionMap::new();\n        let mut snapshot_mem = vec![0u8; 64];\n        let mut store = Some(\"test\".to_owned());\n\n        store\n            .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n            .unwrap();\n        let mut restore =\n            <Option<String> as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1)\n                .unwrap();\n        assert_eq!(store, restore);\n\n        // Check that ser_de also works for `None` variant.\n        store = None;\n        store\n            .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n            .unwrap();\n        restore = <Option<String> as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1)\n            .unwrap();\n        assert_eq!(store, restore);\n\n        store = Some(\"test\".to_owned());\n        store\n            .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n            .unwrap();\n        // Corrupt `snapshot_mem` by changing the most significant bit to a value different than 0 or 1.\n        snapshot_mem[0] = 2;\n        let restore_err =\n            <Option<String> as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1)\n                .unwrap_err();\n        assert_eq!(\n            restore_err,\n            VersionizeError::Deserialize(\"Invalid option value 2\".to_string())\n        );\n        // Corrupt `snapshot_mem` by changing the most significant bit from 1 (`Some(type)`) to 0 (`None`).\n        snapshot_mem[0] = 0;\n        restore = <Option<String> as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1)\n            .unwrap();\n        assert_ne!(store, restore);\n    }\n\n    #[test]\n    fn test_ser_de_box() {\n        let vm = VersionMap::new();\n        let mut snapshot_mem = vec![0u8; 64];\n\n        let store = Box::new(\"test\".to_owned());\n\n        store\n            .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n            .unwrap();\n        let restore =\n            <Box<String> as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1).unwrap();\n\n        assert_eq!(store, restore);\n    }\n\n    #[test]\n    fn test_ser_de_wrapping() {\n        let vm = VersionMap::new();\n        let mut snapshot_mem = vec![0u8; 64];\n\n        let store = std::num::Wrapping(1337u32);\n\n        store\n            .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n            .unwrap();\n        let restore = <std::num::Wrapping<u32> as Versionize>::deserialize(\n            &mut snapshot_mem.as_slice(),\n            &vm,\n            1,\n        )\n        .unwrap();\n\n        assert_eq!(store, restore);\n    }\n\n    #[test]\n    fn test_vec_limit() {\n        // We need extra 8 bytes for vector len.\n        let mut snapshot_mem = vec![0u8; MAX_VEC_SIZE + 8];\n        let err = vec![123u8; MAX_VEC_SIZE + 1]\n            .serialize(&mut snapshot_mem.as_mut_slice(), &VersionMap::new(), 1)\n            .unwrap_err();\n        assert_eq!(err, VersionizeError::VecLength(MAX_VEC_SIZE + 1));\n        assert_eq!(\n            format!(\"{}\", err),\n            \"Vec of length 10485761 exceeded maximum size of 10485760 bytes\"\n        );\n    }\n\n    #[test]\n    fn test_string_limit() {\n        // We need extra 8 bytes for string len.\n        let mut snapshot_mem = vec![0u8; MAX_STRING_LEN + 8];\n        let err = String::from_utf8(vec![123u8; MAX_STRING_LEN + 1])\n            .unwrap()\n            .serialize(&mut snapshot_mem.as_mut_slice(), &VersionMap::new(), 1)\n            .unwrap_err();\n        assert_eq!(err, VersionizeError::StringLength(MAX_STRING_LEN + 1));\n        assert_eq!(\n            format!(\"{}\", err),\n            \"String length exceeded 16385 > 16384 bytes\"\n        );\n    }\n}\n", "// Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\n#![allow(clippy::missing_safety_doc)]\n\nextern crate versionize;\nextern crate versionize_derive;\nextern crate vmm_sys_util;\n\nuse std::fmt::{Debug, Formatter, Result};\nuse std::num::Wrapping;\n\nuse vmm_sys_util::fam::{FamStruct, FamStructWrapper};\nuse vmm_sys_util::generate_fam_struct_impl;\n\nuse versionize::{VersionMap, Versionize, VersionizeError, VersionizeResult};\nuse versionize_derive::Versionize;\n\n#[derive(Debug, PartialEq, Versionize, Eq)]\npub enum TestState {\n    Zero,\n    One(u32),\n    #[version(start = 2, default_fn = \"default_state_two\")]\n    Two(u64),\n}\n\nimpl TestState {\n    fn default_state_two(&self, target_version: u16) -> VersionizeResult<TestState> {\n        match target_version {\n            1 => Ok(TestState::One(2)),\n            i => Err(VersionizeError::Serialize(format!(\n                \"Unknown target version: {}\",\n                i\n            ))),\n        }\n    }\n}\n\n#[test]\nfn test_hardcoded_struct_deserialization() {\n    // We are testing representation compatibility between versions, at the `versionize`\n    // crate level, by checking that only the newly added/removed fields changes between\n    // versions are reflected in the hardcoded snapshot.\n\n    #[rustfmt::skip]\n    let v1_hardcoded_snapshot: &[u8] = &[\n        // usize field (8 bytes), u16 field (2 bytes) +\n        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,\n        // u64 (8 bytes), i8 (1 byte), i32 (4 bytes) +\n        0xCD, 0xAB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x20, 0x00, 0x00, 0x00,\n        // f32 (4 bytes), f64 (8 bytes), char (1 bytes) +\n        0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x50, 0x40, 0x61,\n        // String len (8 bytes) +\n        0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        // actual String (11 bytes in our case) +\n        0x73, 0x6F, 0x6D, 0x65, 0x5F, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67,\n        // enum variant number (4 bytes) + value of that variant (in this case it is\n        // of u32 type -> 4 bytes) +\n        0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,\n        // Option variant (1 byte) + value of variant (u8 -> 1 byte) +\n        0x01, 0x81,\n        // Box: String len (8 bytes) + actual String (17 bytes in this case).\n        0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x73, 0x6F, 0x6D, 0x65, 0x5F,\n        0x6F, 0x74, 0x68, 0x65, 0x72, 0x5F, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67,\n    ];\n\n    // At version 2 isize (8 bytes), i64 (8 bytes) and bool (1 byte) fields will be also\n    // present. At v2 there is also a new variant available for enum, so we can store that in\n    // memory and it occupies 4 more bytes than the one stored at v1.\n    #[rustfmt::skip]\n    let v2_hardcoded_snapshot: &[u8] = &[\n        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        // New isize field.\n        0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x04, 0x00,\n        0xCD, 0xAB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x20, 0x00, 0x00, 0x00,\n        // New i64 field.\n        0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x50, 0x40, 0x61,\n        // New bool field.\n        0x01,\n        0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x73, 0x6F, 0x6D, 0x65, 0x5F, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67,\n        // New available enum variant.\n        0x02, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x01, 0x81,\n        0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x73, 0x6F, 0x6D, 0x65, 0x5F,\n        0x6F, 0x74, 0x68, 0x65, 0x72, 0x5F, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67,\n    ];\n\n    // At version 3, u64 and i64 disappear (16 bytes) and Vec (8 + 4 = 12 bytes) and Wrapping\n    // (4 bytes) fields are available.\n    #[rustfmt::skip]\n    let v3_hardcoded_snapshot: &[u8] = &[\n        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x04, 0x00,\n        0xFF, 0x20, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x50, 0x40, 0x61,\n        0x01,\n        0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x73, 0x6F, 0x6D, 0x65, 0x5F, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67,\n        0x02, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x01, 0x81,\n        // Vec len (8 bytes) + actual Vec (4 bytes).\n        0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x61, 0x61, 0x61, 0x61,\n        0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x73, 0x6F, 0x6D, 0x65, 0x5F,\n        0x6F, 0x74, 0x68, 0x65, 0x72, 0x5F, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67,\n        // Wrapping over an u32 (4 bytes).\n        0xFF, 0x00, 0x00, 0x00,\n    ];\n\n    // At version 4, isize and Vec disappear (20 bytes): 0x6F - 0x14 = 0x5B.\n    #[rustfmt::skip]\n    let v4_hardcoded_snapshot: &[u8] = &[\n        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x04, 0x00,\n        0xFF, 0x20, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x50, 0x40, 0x61,\n        0x01,\n        0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x73, 0x6F, 0x6D, 0x65, 0x5F, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67,\n        0x02, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x01, 0x81,\n        0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x73, 0x6F, 0x6D, 0x65, 0x5F,\n        0x6F, 0x74, 0x68, 0x65, 0x72, 0x5F, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67,\n        0xFF, 0x00, 0x00, 0x00,\n    ];\n\n    #[derive(Debug, PartialEq, Versionize)]\n    pub struct TestStruct {\n        usize_1: usize,\n        #[version(start = 2, end = 4, default_fn = \"default_isize\")]\n        isize_1: isize,\n        u16_1: u16,\n        #[version(end = 3, default_fn = \"default_u64\")]\n        u64_1: u64,\n        i8_1: i8,\n        #[version(start = 2, end = 2)]\n        i16_1: i16,\n        i32_1: i32,\n        #[version(start = 2, end = 3, default_fn = \"default_i64\")]\n        i64_1: i64,\n        f32_1: f32,\n        f64_1: f64,\n        char_1: char,\n        #[version(start = 2, default_fn = \"default_bool\")]\n        bool_1: bool,\n        string_1: String,\n        enum_1: TestState,\n        option_1: Option<u8>,\n        #[version(start = 3, end = 4, default_fn = \"default_vec\")]\n        vec_1: Vec<char>,\n        #[allow(clippy::box_collection)] // we want to explicitly test Box\n        box_1: Box<String>,\n        #[version(start = 3)]\n        wrapping_1: Wrapping<u32>,\n    }\n\n    impl TestStruct {\n        fn default_isize(_source_version: u16) -> isize {\n            12isize\n        }\n\n        fn default_u64(_source_version: u16) -> u64 {\n            0x0Du64\n        }\n\n        fn default_i64(_source_version: u16) -> i64 {\n            0x0Ei64\n        }\n\n        fn default_bool(_source_version: u16) -> bool {\n            false\n        }\n\n        fn default_vec(_source_version: u16) -> Vec<char> {\n            vec!['v'; 8]\n        }\n    }\n\n    let mut vm = VersionMap::new();\n    vm.new_version()\n        .set_type_version(TestStruct::type_id(), 2)\n        .set_type_version(TestState::type_id(), 2)\n        .new_version()\n        .set_type_version(TestStruct::type_id(), 3)\n        .new_version()\n        .set_type_version(TestStruct::type_id(), 4);\n\n    let mut snapshot_blob = v1_hardcoded_snapshot;\n\n    let mut restored_state =\n        <TestStruct as Versionize>::deserialize(&mut snapshot_blob, &vm, 1).unwrap();\n\n    // We expect isize, i16, i64, bool, Vec and Wrapping fields to have the default values at v1.\n    let mut expected_state = TestStruct {\n        usize_1: 1,\n        isize_1: 12,\n        u16_1: 4,\n        u64_1: 0xABCDu64,\n        i8_1: -1,\n        i16_1: 0,\n        i32_1: 32,\n        i64_1: 0x0Ei64,\n        f32_1: 0.5,\n        f64_1: 64.5,\n        char_1: 'a',\n        bool_1: false,\n        string_1: \"some_string\".to_owned(),\n        enum_1: TestState::One(2),\n        option_1: Some(129),\n        vec_1: vec!['v'; 8],\n        box_1: Box::new(\"some_other_string\".to_owned()),\n        wrapping_1: Wrapping(0u32),\n    };\n    assert_eq!(restored_state, expected_state);\n\n    snapshot_blob = v2_hardcoded_snapshot;\n\n    restored_state = <TestStruct as Versionize>::deserialize(&mut snapshot_blob, &vm, 2).unwrap();\n\n    // We expect only i16, Vec and Wrapping fields to have the default values at v2.\n    expected_state = TestStruct {\n        usize_1: 1,\n        isize_1: 2,\n        u16_1: 4,\n        u64_1: 0xABCDu64,\n        i8_1: -1,\n        i16_1: 0,\n        i32_1: 32,\n        i64_1: 0xFFFFi64,\n        f32_1: 0.5,\n        f64_1: 64.5,\n        char_1: 'a',\n        bool_1: true,\n        string_1: \"some_string\".to_owned(),\n        enum_1: TestState::Two(14),\n        option_1: Some(129),\n        vec_1: vec!['v'; 8],\n        box_1: Box::new(\"some_other_string\".to_owned()),\n        wrapping_1: Wrapping(0u32),\n    };\n    assert_eq!(restored_state, expected_state);\n\n    snapshot_blob = v3_hardcoded_snapshot;\n\n    restored_state = <TestStruct as Versionize>::deserialize(&mut snapshot_blob, &vm, 3).unwrap();\n\n    // We expect u64, i16 and i64 fields to have the default values at v3.\n    expected_state = TestStruct {\n        usize_1: 1,\n        isize_1: 2,\n        u16_1: 4,\n        u64_1: 0x0Du64,\n        i8_1: -1,\n        i16_1: 0,\n        i32_1: 32,\n        i64_1: 0x0Ei64,\n        f32_1: 0.5,\n        f64_1: 64.5,\n        char_1: 'a',\n        bool_1: true,\n        string_1: \"some_string\".to_owned(),\n        enum_1: TestState::Two(14),\n        option_1: Some(129),\n        vec_1: vec!['a'; 4],\n        box_1: Box::new(\"some_other_string\".to_owned()),\n        wrapping_1: Wrapping(255u32),\n    };\n    assert_eq!(restored_state, expected_state);\n\n    snapshot_blob = v4_hardcoded_snapshot;\n\n    restored_state = <TestStruct as Versionize>::deserialize(&mut snapshot_blob, &vm, 4).unwrap();\n\n    // We expect isize, u64, i16, i64 and Vec fields to have the default values at v4.\n    expected_state = TestStruct {\n        usize_1: 1,\n        isize_1: 12,\n        u16_1: 4,\n        u64_1: 0x0Du64,\n        i8_1: -1,\n        i16_1: 0,\n        i32_1: 32,\n        i64_1: 0x0Ei64,\n        f32_1: 0.5,\n        f64_1: 64.5,\n        char_1: 'a',\n        bool_1: true,\n        string_1: \"some_string\".to_owned(),\n        enum_1: TestState::Two(14),\n        option_1: Some(129),\n        vec_1: vec!['v'; 8],\n        box_1: Box::new(\"some_other_string\".to_owned()),\n        wrapping_1: Wrapping(255u32),\n    };\n    assert_eq!(restored_state, expected_state);\n}\n\n#[test]\nfn test_hardcoded_enum_deserialization() {\n    // We are testing separately also hardcoded snapshot deserialization for enums\n    // as these have a different behavior in terms of serialization/deserialization.\n    #[rustfmt::skip]\n    let v1_hardcoded_snapshot: &[u8] = &[\n        // Variant number (4 bytes), the first variant lacks a value.\n        0x00, 0x00, 0x00, 0x00,\n    ];\n\n    #[rustfmt::skip]\n    let v2_hardcoded_snapshot: &[u8] = &[\n        0x00, 0x00, 0x00, 0x00,\n    ];\n\n    #[rustfmt::skip]\n    let unexpected_v1_hardcoded_snapshot: &[u8] = &[\n        // Second variant (4 bytes) + value of that variant (8 bytes).\n        0x02, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    ];\n\n    #[rustfmt::skip]\n    let invalid_v1_hardcoded_snapshot: &[u8] = &[\n        // Invalid enum variant number.\n        0x03, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    ];\n\n    let mut vm = VersionMap::new();\n    vm.new_version().set_type_version(TestState::type_id(), 2);\n\n    let mut snapshot_blob = v1_hardcoded_snapshot;\n\n    let mut restored_state =\n        <TestState as Versionize>::deserialize(&mut snapshot_blob, &vm, 1).unwrap();\n    assert_eq!(restored_state, TestState::Zero);\n\n    snapshot_blob = v2_hardcoded_snapshot;\n\n    restored_state = <TestState as Versionize>::deserialize(&mut snapshot_blob, &vm, 2).unwrap();\n    assert_eq!(restored_state, TestState::Zero);\n\n    snapshot_blob = unexpected_v1_hardcoded_snapshot;\n\n    // Versioned deserialization is not implemented for enums, so even though we do not have\n    // `Two` state available at version 2, restoring the data won't fail :(.\n    // TODO: This must be fixed.\n    restored_state = <TestState as Versionize>::deserialize(&mut snapshot_blob, &vm, 1).unwrap();\n    assert_eq!(restored_state, TestState::Two(5));\n\n    // This snapshot contains a non-existent enum variant.\n    snapshot_blob = invalid_v1_hardcoded_snapshot;\n\n    assert_eq!(\n        <TestState as Versionize>::deserialize(&mut snapshot_blob, &vm, 1).unwrap_err(),\n        VersionizeError::Deserialize(\"Unknown variant_index 3\".to_owned())\n    );\n}\n\n#[derive(Debug, PartialEq, Eq, Versionize)]\npub struct A {\n    a: u32,\n    #[version(start = 1, end = 2)]\n    b: Option<TestState>,\n    #[version(start = 2, default_fn = \"default_c\")]\n    c: String,\n}\n\n#[derive(Debug, PartialEq, Eq, Versionize)]\npub struct X {\n    x: bool,\n    a_1: A,\n    #[version(end = 3, default_fn = \"default_y\")]\n    y: Box<usize>,\n    #[version(start = 3, default_fn = \"default_z\")]\n    z: Vec<u8>,\n}\n\nimpl A {\n    fn default_c(_source_version: u16) -> String {\n        \"some_string\".to_owned()\n    }\n}\n\nimpl X {\n    fn default_y(_source_version: u16) -> Box<usize> {\n        Box::from(4)\n    }\n\n    fn default_z(_source_version: u16) -> Vec<u8> {\n        vec![16, 4]\n    }\n}\n\n#[test]\nfn test_nested_structs_deserialization() {\n    #[rustfmt::skip]\n    let v1_hardcoded_snapshot: &[u8] = &[\n        // Bool field (1 byte) from X, `a` field from A (4 bytes) +\n        0x00, 0x10, 0x00, 0x00, 0x00,\n        // `b` field from A: Option type (1 byte), inner enum variant number (4 bytes) +\n        // + value of that variant (4 bytes) +\n        0x01, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,\n        // `y` field from A (8 bytes).\n        0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    ];\n\n    #[rustfmt::skip]\n    let v2_hardcoded_snapshot: &[u8] = &[\n        // Bool field (1 byte) from X, `a` field from A (4 bytes) +\n        0x00, 0x10, 0x00, 0x00, 0x00,\n        // `c` field from X: String len (8 bytes) + actual String;\n        // the Option field is not available at v2.\n        0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x72, 0x61, 0x6E, 0x64, 0x6F, 0x6D,\n        // `y` field from A (8 bytes).\n        0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    ];\n\n    #[rustfmt::skip]\n    let v3_hardcoded_snapshot: &[u8] = &[\n        0x00, 0x10, 0x00, 0x00, 0x00,\n        0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x72, 0x61, 0x6E, 0x64, 0x6F, 0x6D,\n        // `z` field from A (8 bytes).\n        0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18,\n    ];\n\n    let mut vm = VersionMap::new();\n    vm.new_version()\n        .set_type_version(A::type_id(), 2)\n        .set_type_version(X::type_id(), 2)\n        .set_type_version(TestState::type_id(), 2)\n        .new_version()\n        .set_type_version(X::type_id(), 3);\n\n    let mut snapshot_blob = v1_hardcoded_snapshot;\n\n    let mut restored_state = <X as Versionize>::deserialize(&mut snapshot_blob, &vm, 1).unwrap();\n    // We expect `z` and `c` fields to have the default values.\n    let mut expected_state = X {\n        x: false,\n        a_1: A {\n            a: 16u32,\n            b: Some(TestState::One(4)),\n            c: \"some_string\".to_owned(),\n        },\n        y: Box::from(2),\n        z: vec![16, 4],\n    };\n    assert_eq!(restored_state, expected_state);\n\n    snapshot_blob = v2_hardcoded_snapshot;\n\n    restored_state = <X as Versionize>::deserialize(&mut snapshot_blob, &vm, 2).unwrap();\n\n    // We expect `b` and `z` fields to have the default values.\n    expected_state = X {\n        x: false,\n        a_1: A {\n            a: 16u32,\n            b: None,\n            c: \"random\".to_owned(),\n        },\n        y: Box::from(2),\n        z: vec![16, 4],\n    };\n    assert_eq!(restored_state, expected_state);\n\n    snapshot_blob = v3_hardcoded_snapshot;\n\n    restored_state = <X as Versionize>::deserialize(&mut snapshot_blob, &vm, 3).unwrap();\n\n    // We expect `b` and `y` fields to have the default values.\n    expected_state = X {\n        x: false,\n        a_1: A {\n            a: 16u32,\n            b: None,\n            c: \"random\".to_owned(),\n        },\n        y: Box::from(4),\n        z: vec![24; 4],\n    };\n    assert_eq!(restored_state, expected_state);\n}\n\npub const SIZE: usize = 10;\n\npub mod dummy_mod {\n    pub const SIZE: usize = 20;\n}\n\n#[test]\nfn test_versionize_struct_with_array() {\n    #[derive(Debug, PartialEq, Versionize)]\n    struct TestStruct {\n        a: [u32; SIZE],\n        b: [u8; dummy_mod::SIZE],\n        c: Option<[i16; SIZE]>,\n    }\n\n    let test_struct = TestStruct {\n        a: [1; SIZE],\n        b: [2; dummy_mod::SIZE],\n        c: Some([3; SIZE]),\n    };\n\n    let mut mem = vec![0; 4096];\n    let version_map = VersionMap::new();\n\n    test_struct\n        .serialize(&mut mem.as_mut_slice(), &version_map, 1)\n        .unwrap();\n    let restored_test_struct =\n        TestStruct::deserialize(&mut mem.as_slice(), &version_map, 1).unwrap();\n\n    assert_eq!(restored_test_struct, test_struct);\n}\n\n#[derive(Clone, Debug, PartialEq, Eq, Versionize)]\npub enum DeviceStatus {\n    Inactive,\n    Active,\n    #[version(start = 2, default_fn = \"default_is_activating\")]\n    IsActivating(u32),\n}\n\nimpl Default for DeviceStatus {\n    fn default() -> Self {\n        Self::Inactive\n    }\n}\n\n#[derive(Clone, Debug, PartialEq, Eq, Versionize)]\npub enum OperationSupported {\n    Add,\n    Remove,\n    RemoveAndAdd(bool),\n    #[version(start = 2, default_fn = \"default_update\")]\n    Update(String),\n}\n\nimpl Default for OperationSupported {\n    fn default() -> Self {\n        Self::Add\n    }\n}\n\nimpl DeviceStatus {\n    fn default_is_activating(&self, target_version: u16) -> VersionizeResult<DeviceStatus> {\n        match target_version {\n            1 => Ok(DeviceStatus::Inactive),\n            i => Err(VersionizeError::Serialize(format!(\n                \"Unknown target version: {}\",\n                i\n            ))),\n        }\n    }\n}\n\nimpl OperationSupported {\n    fn default_update(&self, target_version: u16) -> VersionizeResult<OperationSupported> {\n        match target_version {\n            1 => Ok(OperationSupported::RemoveAndAdd(true)),\n            i => Err(VersionizeError::Serialize(format!(\n                \"Unknown target version: {}\",\n                i\n            ))),\n        }\n    }\n}\n\n#[derive(Clone, Debug, PartialEq, Eq, Versionize)]\npub struct Device {\n    name: String,\n    id: Wrapping<u32>,\n    #[version(start = 2, ser_fn = \"ser_is_activated\")]\n    is_activated: bool,\n    some_params: Vec<String>,\n    #[version(\n        start = 2,\n        default_fn = \"default_ops\",\n        ser_fn = \"ser_ops\",\n        de_fn = \"de_ops\"\n    )]\n    operations: Vec<OperationSupported>,\n    status: DeviceStatus,\n    #[version(\n        start = 2,\n        default_fn = \"default_queues_limit\",\n        ser_fn = \"ser_queues_limit\"\n    )]\n    no_queues_limit: usize,\n    queues: Vec<u8>,\n    features: u32,\n    #[version(start = 3, ser_fn = \"ser_extra\", de_fn = \"de_extra\")]\n    extra_features: u64,\n}\n\nimpl Device {\n    fn default_ops(_target_version: u16) -> Vec<OperationSupported> {\n        vec![OperationSupported::Add, OperationSupported::Remove]\n    }\n\n    fn default_queues_limit(_target_version: u16) -> usize {\n        2\n    }\n\n    fn ser_ops(&mut self, target_version: u16) -> VersionizeResult<()> {\n        // Fail if semantic serialization is called for a version >= 2.\n        assert!(target_version < 2);\n        self.features |= 1;\n        Ok(())\n    }\n\n    fn de_ops(&mut self, target_version: u16) -> VersionizeResult<()> {\n        // Fail if semantic deserialization is called for a version >= 2.\n        assert!(target_version < 2);\n        if self.some_params.contains(&\"active\".to_owned()) {\n            self.status = DeviceStatus::Active;\n        }\n        Ok(())\n    }\n\n    fn ser_queues_limit(&mut self, target_version: u16) -> VersionizeResult<()> {\n        // Fail if semantic serialization is called for a version >= 2.\n        assert!(target_version < 2);\n        if self.queues.len() > 2 {\n            return Err(VersionizeError::Semantic(\"Too many queues.\".to_owned()));\n        }\n        Ok(())\n    }\n\n    fn ser_is_activated(&mut self, target_version: u16) -> VersionizeResult<()> {\n        // Fail if semantic serialization is called for a version >= 2.\n        assert!(target_version < 2);\n        self.some_params.push(\"active\".to_owned());\n        self.some_params.retain(|x| x.clone() != *\"inactive\");\n        Ok(())\n    }\n\n    fn ser_extra(&mut self, target_version: u16) -> VersionizeResult<()> {\n        // Fail if semantic serialization is called for the latest version.\n        assert!(target_version < 3);\n        self.some_params.push(\"extra_features\".to_owned());\n        Ok(())\n    }\n\n    fn de_extra(&mut self, target_version: u16) -> VersionizeResult<()> {\n        // Fail if semantic deserialization is called for the latest version.\n        assert!(target_version < 3);\n        if self.queues.len() > self.no_queues_limit {\n            return Err(VersionizeError::Semantic(\"Too many queues.\".to_owned()));\n        }\n        self.features |= 1u32 << 31;\n        Ok(())\n    }\n}\n\n#[test]\nfn test_versionize_struct_with_enums() {\n    let mut vm = VersionMap::new();\n    vm.new_version()\n        .set_type_version(Device::type_id(), 2)\n        .set_type_version(DeviceStatus::type_id(), 2)\n        .new_version()\n        .set_type_version(Device::type_id(), 3)\n        .set_type_version(OperationSupported::type_id(), 2);\n\n    let mut state = Device {\n        name: \"block\".to_owned(),\n        id: Wrapping(1u32),\n        is_activated: true,\n        some_params: vec![\"inactive\".to_owned()],\n        operations: vec![\n            OperationSupported::Add,\n            OperationSupported::Update(\"random\".to_owned()),\n        ],\n        status: DeviceStatus::Inactive,\n        no_queues_limit: 3,\n        queues: vec![1u8, 2u8],\n        features: 6u32,\n        extra_features: 0u64,\n    };\n\n    let mut snapshot_mem = vec![0u8; 1024];\n\n    // Serialize as v1.\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n        .unwrap();\n    let mut restored_state =\n        <Device as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1).unwrap();\n\n    // At v1, all of the semantic functions should be called.\n    // `operations` and `no_queues_limit` will take the default values (set by `default_fn`s),\n    // `features` will be modified by `ser_ops` and `de_extra`, `status` will be changed to\n    // `Active` by `de_ops`, `is_activated` will take the default bool value, `some_params`\n    // will be also modified and the other fields will take the original values.\n    let mut expected_state = Device {\n        name: \"block\".to_owned(),\n        id: Wrapping(1u32),\n        is_activated: false,\n        some_params: vec![\"active\".to_owned(), \"extra_features\".to_owned()],\n        operations: vec![OperationSupported::Add, OperationSupported::Remove],\n        status: DeviceStatus::Active,\n        no_queues_limit: 2,\n        queues: vec![1u8, 2u8],\n        features: 0x8000_0007u32,\n        extra_features: 0u64,\n    };\n    assert_eq!(expected_state, restored_state);\n\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 2)\n        .unwrap();\n    restored_state =\n        <Device as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 2).unwrap();\n\n    // At v2, we expect that only the semantic functions from `extra_features` to be called,\n    // this means that `features` and `some_params` will take different values than the ones\n    // at v1. `status` won't be modified anymore, `is_activated` and `no_queues_limit` will\n    // take this time the original values. `operations` field will contain only the first\n    // original element, the second one will be modified by `default_update` because at v2,\n    // `Update` is not available.\n    expected_state = Device {\n        name: \"block\".to_owned(),\n        id: Wrapping(1u32),\n        is_activated: true,\n        some_params: vec![\"inactive\".to_owned(), \"extra_features\".to_owned()],\n        operations: vec![\n            OperationSupported::Add,\n            OperationSupported::RemoveAndAdd(true),\n        ],\n        status: DeviceStatus::Inactive,\n        no_queues_limit: 3,\n        queues: vec![1u8, 2u8],\n        features: 0x8000_0006u32,\n        extra_features: 0u64,\n    };\n    assert_eq!(expected_state, restored_state);\n\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 3)\n        .unwrap();\n    restored_state =\n        <Device as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 3).unwrap();\n\n    // At v3, `Update` variant is available, so it will be deserialized to its original value.\n    // We expect no semantic function to be called, so `features` and `some_params` will also\n    // take the original values.\n    expected_state = Device {\n        name: \"block\".to_owned(),\n        id: Wrapping(1u32),\n        is_activated: true,\n        some_params: vec![\"inactive\".to_owned()],\n        operations: vec![\n            OperationSupported::Add,\n            OperationSupported::Update(\"random\".to_owned()),\n        ],\n        status: DeviceStatus::Inactive,\n        no_queues_limit: 3,\n        queues: vec![1u8, 2u8],\n        features: 6u32,\n        extra_features: 0u64,\n    };\n    assert_eq!(expected_state, restored_state);\n\n    // Test semantic errors.\n    state.queues = vec![1u8, 2u8, 3u8, 4u8];\n    assert_eq!(\n        state\n            .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n            .unwrap_err(),\n        VersionizeError::Semantic(\"Too many queues.\".to_owned())\n    );\n\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 2)\n        .unwrap();\n    assert_eq!(\n        <Device as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 2).unwrap_err(),\n        VersionizeError::Semantic(\"Too many queues.\".to_owned())\n    );\n}\n\n#[derive(Clone, Debug, PartialEq, Eq, Versionize)]\npub enum State {\n    Zero,\n    One(bool),\n    #[version(start = 2, default_fn = \"default_state_two\")]\n    Two(Vec<u8>),\n    #[version(start = 2, default_fn = \"default_state_three\")]\n    Three(String),\n    #[version(start = 3, default_fn = \"default_state_four\")]\n    Four(Option<u64>),\n}\n\nimpl Default for State {\n    fn default() -> Self {\n        Self::One(false)\n    }\n}\n\nimpl State {\n    fn default_state_two(&self, target_version: u16) -> VersionizeResult<State> {\n        match target_version {\n            1 => Ok(State::One(true)),\n            i => Err(VersionizeError::Serialize(format!(\n                \"Unknown target version: {}\",\n                i\n            ))),\n        }\n    }\n\n    fn default_state_three(&self, target_version: u16) -> VersionizeResult<State> {\n        match target_version {\n            1 => Ok(State::One(false)),\n            i => Err(VersionizeError::Serialize(format!(\n                \"Unknown target version: {}\",\n                i\n            ))),\n        }\n    }\n\n    fn default_state_four(&self, target_version: u16) -> VersionizeResult<State> {\n        match target_version {\n            2 => Ok(State::Three(\"abc\".to_owned())),\n            1 => Ok(State::Zero),\n            i => Err(VersionizeError::Serialize(format!(\n                \"Unknown target version: {}\",\n                i\n            ))),\n        }\n    }\n}\n\n#[test]\nfn test_versionize_enum() {\n    let mut vm = VersionMap::new();\n    vm.new_version()\n        .set_type_version(State::type_id(), 2)\n        .new_version()\n        .set_type_version(State::type_id(), 3);\n\n    let mut snapshot_mem = vec![0u8; 1024];\n\n    // First we test that serializing and deserializing an enum variant available at the\n    // target version results in the same variant.\n    let mut state = State::One(true);\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n        .unwrap();\n    let mut restored_state =\n        <State as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1).unwrap();\n    assert_eq!(state, restored_state);\n\n    // Now we test `default_fn`s for serialization of enum variants that don't exist in\n    // previous versions.\n    state = State::Four(Some(0x1234_5678_8765_4321u64));\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n        .unwrap();\n    restored_state =\n        <State as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1).unwrap();\n    assert_eq!(restored_state, State::Zero);\n\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 2)\n        .unwrap();\n    restored_state =\n        <State as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 2).unwrap();\n    assert_eq!(restored_state, State::Three(\"abc\".to_owned()));\n\n    state = State::Three(\"some_string\".to_owned());\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n        .unwrap();\n    restored_state =\n        <State as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 2).unwrap();\n    assert_eq!(restored_state, State::One(false));\n}\n\n#[derive(Clone, Debug, PartialEq, Versionize)]\npub struct S {\n    a: f64,\n    b: i64,\n}\n\n#[derive(Clone, Debug, PartialEq, Versionize)]\npub struct Test {\n    usize_1: usize,\n    #[version(start = 2, end = 3, ser_fn = \"ser_isize\", de_fn = \"de_isize\")]\n    isize_1: isize,\n    #[version(start = 2)]\n    u8_1: u8,\n    #[version(end = 4, default_fn = \"default_vec\")]\n    vec_1: Vec<u16>,\n    #[version(start = 3)]\n    wrapping_1: Wrapping<u32>,\n    #[version(\n        end = 3,\n        default_fn = \"default_u64\",\n        ser_fn = \"ser_u64\",\n        de_fn = \"de_u64\"\n    )]\n    u64_1: u64,\n    #[version(start = 2, ser_fn = \"ser_bool\")]\n    bool_1: bool,\n    enum_1: State,\n    i8_1: i8,\n    i16_1: i16,\n    #[version(start = 3, end = 4)]\n    i32_1: i32,\n    #[version(start = 2, default_fn = \"default_box\", de_fn = \"de_box\")]\n    box_1: Box<S>,\n    #[version(start = 2, end = 3, default_fn = \"default_f32\")]\n    f32_1: f32,\n    char_1: char,\n    #[version(\n        end = 3,\n        default_fn = \"default_option\",\n        ser_fn = \"ser_option\",\n        de_fn = \"de_option\"\n    )]\n    option_1: Option<String>,\n}\n\nimpl Test {\n    fn default_vec(_target_version: u16) -> Vec<u16> {\n        vec![0x0102u16; 4]\n    }\n\n    fn default_u64(_target_version: u16) -> u64 {\n        0x0102_0102_0102_0102u64\n    }\n\n    fn default_f32(_target_version: u16) -> f32 {\n        0.5\n    }\n\n    fn default_box(_target_version: u16) -> Box<S> {\n        Box::new(S { a: 1.5, b: 2 })\n    }\n\n    fn default_option(_target_version: u16) -> Option<String> {\n        Some(\"something\".to_owned())\n    }\n\n    fn ser_isize(&mut self, target_version: u16) -> VersionizeResult<()> {\n        assert_ne!(target_version, 2);\n        self.vec_1.push(0x0304u16);\n        if self.i8_1 == -1 {\n            return Err(VersionizeError::Semantic(\n                \"Unexpected value for `i8` field.\".to_owned(),\n            ));\n        }\n        Ok(())\n    }\n    fn ser_u64(&mut self, target_version: u16) -> VersionizeResult<()> {\n        assert!(target_version >= 3);\n        self.vec_1.pop();\n        if self.u8_1 == 4 {\n            self.bool_1 = false;\n        }\n        Ok(())\n    }\n\n    fn ser_bool(&mut self, target_version: u16) -> VersionizeResult<()> {\n        assert!(target_version < 2);\n        self.vec_1.push(0x0506u16);\n        self.vec_1.push(0x0708u16);\n        Ok(())\n    }\n\n    fn ser_option(&mut self, target_version: u16) -> VersionizeResult<()> {\n        assert!(target_version >= 3);\n        self.u8_1 += 2;\n        if self.vec_1.len() == 10 {\n            return Err(VersionizeError::Semantic(\"Vec is full.\".to_owned()));\n        }\n        Ok(())\n    }\n\n    fn de_isize(&mut self, target_version: u16) -> VersionizeResult<()> {\n        assert_ne!(target_version, 2);\n        self.u8_1 += 3;\n        Ok(())\n    }\n\n    fn de_u64(&mut self, target_version: u16) -> VersionizeResult<()> {\n        assert!(target_version >= 3);\n        self.vec_1.push(0x0101u16);\n        Ok(())\n    }\n\n    fn de_box(&mut self, target_version: u16) -> VersionizeResult<()> {\n        assert!(target_version < 2);\n        self.option_1 = Some(\"box_change\".to_owned());\n        if self.vec_1.len() == 3 {\n            return Err(VersionizeError::Semantic(\n                \"Vec len is too small.\".to_owned(),\n            ));\n        }\n        Ok(())\n    }\n\n    fn de_option(&mut self, target_version: u16) -> VersionizeResult<()> {\n        assert!(target_version >= 3);\n        self.enum_1 = State::Two(vec![1; 4]);\n        Ok(())\n    }\n}\n\n#[test]\nfn test_versionize_struct() {\n    let mut vm = VersionMap::new();\n    vm.new_version()\n        .set_type_version(Test::type_id(), 2)\n        .set_type_version(State::type_id(), 2)\n        .new_version()\n        .set_type_version(Test::type_id(), 3)\n        .set_type_version(State::type_id(), 3);\n\n    let mut state = Test {\n        usize_1: 0x0102_0304_0506_0708usize,\n        isize_1: -0x1122_3344_5566_7788isize,\n        u8_1: 4,\n        vec_1: vec![0x1122u16; 5],\n        wrapping_1: Wrapping(4u32),\n        u64_1: 0x0102_0304_0506_0708u64,\n        bool_1: false,\n        enum_1: State::Four(Some(0x0102_0304_0506_0708u64)),\n        i8_1: 8,\n        i16_1: -12,\n        i32_1: -0x1234_5678,\n        box_1: Box::new(S { a: 4.5, b: 4 }),\n        f32_1: 1.25,\n        char_1: 'c',\n        option_1: None,\n    };\n\n    let mut snapshot_mem = vec![0u8; 1024];\n\n    // Serialize as v1.\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n        .unwrap();\n    let mut restored_state =\n        <Test as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1).unwrap();\n\n    let mut expected_state = Test {\n        // usize field exists at all versions, will take the original value.\n        usize_1: 0x0102_0304_0506_0708usize,\n        // isize field will take the default value as it is not available at v1.\n        isize_1: 0isize,\n        // u8 field doesn't exist at v1, it wll take the default value and then it will be\n        // modified by `de_isize`: 0 + 3 = 3.\n        u8_1: 3,\n        // Vec field will be modified by the semantic fns of the fields that don't exist\n        // at v1: `isize_1`, `bool_1`; there will be 3 new elements added in it.\n        vec_1: vec![\n            0x1122u16, 0x1122u16, 0x1122u16, 0x1122u16, 0x1122u16, 0x0304u16, 0x0506u16, 0x0708u16,\n        ],\n        // We expect here to have the default value.\n        wrapping_1: Wrapping(0u32),\n        // We expect here to have the original value.\n        u64_1: 0x0102_0304_0506_0708u64,\n        // We expect here to have the default value.\n        bool_1: false,\n        // This will take the default value for state `Four` and v1.\n        enum_1: State::Zero,\n        // i8, i16 fields take the original values.\n        i8_1: 8,\n        i16_1: -12,\n        // i32 field takes the default value.\n        i32_1: 0,\n        // Box and f32 fields will take the default values set by `default_fn`s.\n        box_1: Box::new(S { a: 1.5, b: 2 }),\n        f32_1: 0.5,\n        // We expect this field to take the original value.\n        char_1: 'c',\n        // This field will be modified by `de_box`.\n        option_1: Some(\"box_change\".to_owned()),\n    };\n    assert_eq!(expected_state, restored_state);\n\n    // Serialize as v2.\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 2)\n        .unwrap();\n    restored_state =\n        <Test as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 2).unwrap();\n\n    // At v2 isize, u8, bool, box and f32 fields will be available, their semantic fns won't\n    // be called.\n    expected_state = Test {\n        usize_1: 0x0102_0304_0506_0708usize,\n        isize_1: -0x1122_3344_5566_7788isize,\n        u8_1: 4,\n        // This should take the original value this time.\n        vec_1: vec![0x1122u16, 0x1122u16, 0x1122u16, 0x1122u16, 0x1122u16],\n        wrapping_1: Wrapping(0u32),\n        u64_1: 0x0102_0304_0506_0708u64,\n        bool_1: false,\n        // This will take the default value for state `Four` and v2.\n        enum_1: State::Three(\"abc\".to_owned()),\n        i8_1: 8,\n        i16_1: -12,\n        i32_1: 0,\n        box_1: Box::new(S { a: 4.5, b: 4 }),\n        f32_1: 1.25,\n        char_1: 'c',\n        option_1: None,\n    };\n    assert_eq!(expected_state, restored_state);\n\n    // Serialize as v3.\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 3)\n        .unwrap();\n    restored_state =\n        <Test as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 3).unwrap();\n\n    expected_state = Test {\n        usize_1: 0x0102_0304_0506_0708usize,\n        isize_1: 0isize,\n        // This field will be modified by `de_isize` and `ser_option`: 4 + 2 + 3 = 9.\n        u8_1: 9,\n        // Vec field will be modified by `ser_isize` (add one elem), `ser_u64` (remove one elem)\n        // and `de_64` (add one elem).\n        vec_1: vec![\n            0x1122u16, 0x1122u16, 0x1122u16, 0x1122u16, 0x1122u16, 0x0101u16,\n        ],\n        wrapping_1: Wrapping(4u32),\n        u64_1: 0x0102_0102_0102_0102u64,\n        bool_1: false,\n        enum_1: State::Two(vec![1; 4]),\n        i8_1: 8,\n        i16_1: -12,\n        i32_1: -0x1234_5678,\n        box_1: Box::new(S { a: 4.5, b: 4 }),\n        f32_1: 0.5,\n        char_1: 'c',\n        // We expect this field to take the default value set by its `default_fn`.\n        option_1: Some(\"something\".to_owned()),\n    };\n    assert_eq!(expected_state, restored_state);\n\n    // Test semantic errors.\n    state.vec_1 = Vec::new();\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n        .unwrap();\n    assert_eq!(\n        <Test as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1).unwrap_err(),\n        VersionizeError::Semantic(\"Vec len is too small.\".to_owned())\n    );\n\n    state.vec_1 = vec![0x1122u16; 10];\n    assert_eq!(\n        state\n            .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 3)\n            .unwrap_err(),\n        VersionizeError::Semantic(\"Vec is full.\".to_owned())\n    );\n\n    state.i8_1 = -1;\n    assert_eq!(\n        state\n            .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n            .unwrap_err(),\n        VersionizeError::Semantic(\"Unexpected value for `i8` field.\".to_owned())\n    );\n    state.i8_1 = 0;\n\n    // Test serialize and deserialize errors.\n    snapshot_mem = vec![0u8; 8];\n    // Serializing `state` will fail due to the small size of `snapshot_mem`.\n    assert_eq!(\n        state\n            .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n            .unwrap_err(),\n        VersionizeError::Serialize(\n            \"Io(Error { kind: WriteZero, message: \\\"failed to write whole buffer\\\" })\".to_owned()\n        )\n    );\n    snapshot_mem = vec![0u8; 256];\n\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n        .unwrap();\n    snapshot_mem.truncate(10);\n    // Deserialization will fail if we don't use the whole `snapshot_mem` resulted from\n    // serialization.\n    assert_eq!(\n        <Test as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1).unwrap_err(),\n        VersionizeError::Deserialize(\n            \"Io(Error { kind: UnexpectedEof, message: \\\"failed to fill whole buffer\\\" })\"\n                .to_owned()\n        )\n    );\n}\n\n#[repr(C)]\n#[derive(Debug, Default, Versionize)]\nstruct Message {\n    pub len: u32,\n    #[version(end = 4)]\n    pub padding: u32,\n    pub value: u32,\n    #[version(start = 2, default_fn = \"default_extra_value\")]\n    pub extra_value: u16,\n    #[version(start = 3, end = 4, default_fn = \"default_status\")]\n    pub status: Wrapping<bool>,\n    pub entries: __IncompleteArrayField<u32>,\n}\n\nimpl Message {\n    fn default_extra_value(_source_version: u16) -> u16 {\n        4\n    }\n\n    fn default_status(_source_version: u16) -> Wrapping<bool> {\n        Wrapping(false)\n    }\n}\n\n#[repr(C)]\n#[derive(Debug, Default, Versionize)]\nstruct Message2 {\n    pub len: u32,\n    #[version(end = 4)]\n    pub padding: u32,\n    pub value: u32,\n    #[version(start = 2, default_fn = \"default_extra_value\")]\n    pub extra_value: u16,\n    #[version(start = 3, end = 4, default_fn = \"default_status\")]\n    pub status: Wrapping<bool>,\n    pub entries: __IncompleteArrayField<u32>,\n}\n\nimpl Message2 {\n    fn default_extra_value(_source_version: u16) -> u16 {\n        4\n    }\n\n    fn default_status(_source_version: u16) -> Wrapping<bool> {\n        Wrapping(false)\n    }\n}\n\ngenerate_fam_struct_impl!(Message, u32, entries, u32, len, 100);\n// Duplicated structure used but with max_len 1 - for negative testing.\ngenerate_fam_struct_impl!(Message2, u32, entries, u32, len, 1);\n\n#[repr(C)]\n#[derive(Default)]\npub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);\n\nimpl<T> __IncompleteArrayField<T> {\n    #[inline]\n    pub fn new() -> Self {\n        __IncompleteArrayField(::std::marker::PhantomData, [])\n    }\n    #[inline]\n    pub unsafe fn as_ptr(&self) -> *const T {\n        self as *const __IncompleteArrayField<T> as *const T\n    }\n    #[inline]\n    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {\n        self as *mut __IncompleteArrayField<T> as *mut T\n    }\n    #[inline]\n    pub unsafe fn as_slice(&self, len: usize) -> &[T] {\n        ::std::slice::from_raw_parts(self.as_ptr(), len)\n    }\n    #[inline]\n    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {\n        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)\n    }\n}\n\nimpl<T> Debug for __IncompleteArrayField<T> {\n    fn fmt(&self, fmt: &mut Formatter<'_>) -> Result {\n        fmt.write_str(\"__IncompleteArrayField\")\n    }\n}\n\nimpl<T> ::std::clone::Clone for __IncompleteArrayField<T> {\n    #[inline]\n    fn clone(&self) -> Self {\n        Self::new()\n    }\n}\n\nimpl<T> Versionize for __IncompleteArrayField<T> {\n    #[inline]\n    fn serialize<W: std::io::Write>(\n        &self,\n        _writer: &mut W,\n        _version_map: &VersionMap,\n        _app_version: u16,\n    ) -> VersionizeResult<()> {\n        Ok(())\n    }\n\n    #[inline]\n    fn deserialize<R: std::io::Read>(\n        _reader: &mut R,\n        _version_map: &VersionMap,\n        _app_version: u16,\n    ) -> VersionizeResult<Self> {\n        Ok(Self::new())\n    }\n\n    // Not used.\n    fn version() -> u16 {\n        1\n    }\n}\n\ntype MessageFamStructWrapper = FamStructWrapper<Message>;\ntype Message2FamStructWrapper = FamStructWrapper<Message2>;\n\n#[test]\nfn test_versionize_famstructwrapper() {\n    let mut vm = VersionMap::new();\n    vm.new_version()\n        .set_type_version(Message::type_id(), 2)\n        .new_version()\n        .set_type_version(Message::type_id(), 3)\n        .new_version()\n        .set_type_version(Message::type_id(), 4);\n\n    let mut state = MessageFamStructWrapper::new(0).unwrap();\n    state.as_mut_fam_struct().padding = 8;\n    state.as_mut_fam_struct().extra_value = 16;\n    state.as_mut_fam_struct().status = Wrapping(true);\n\n    state.push(1).unwrap();\n    state.push(2).unwrap();\n\n    let mut snapshot_mem = vec![0u8; 256];\n\n    // Serialize as v1.\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n        .unwrap();\n    let mut restored_state =\n        <MessageFamStructWrapper as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1)\n            .unwrap();\n\n    let mut original_values = state.as_slice();\n    let mut restored_values = restored_state.as_slice();\n    assert_eq!(original_values, restored_values);\n    assert_eq!(\n        restored_values.len(),\n        state.as_fam_struct_ref().len as usize\n    );\n\n    assert_eq!(\n        state.as_fam_struct_ref().padding,\n        restored_state.as_fam_struct_ref().padding\n    );\n    // `extra_value` and `status` should take the default values set by their corresponding `default_fn`s.\n    assert_eq!(4, restored_state.as_fam_struct_ref().extra_value);\n    assert_eq!(Wrapping(false), restored_state.as_fam_struct_ref().status);\n\n    // Serialize as v2.\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 2)\n        .unwrap();\n    restored_state =\n        <MessageFamStructWrapper as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 2)\n            .unwrap();\n\n    original_values = state.as_slice();\n    restored_values = restored_state.as_slice();\n    assert_eq!(original_values, restored_values);\n\n    assert_eq!(\n        state.as_fam_struct_ref().padding,\n        restored_state.as_fam_struct_ref().padding\n    );\n    // `extra_value` is available at v2, so it will take its original value.\n    assert_eq!(\n        state.as_fam_struct_ref().extra_value,\n        restored_state.as_fam_struct_ref().extra_value\n    );\n    assert_eq!(Wrapping(false), restored_state.as_fam_struct_ref().status);\n\n    // Serialize as v3.\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 3)\n        .unwrap();\n    restored_state =\n        <MessageFamStructWrapper as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 3)\n            .unwrap();\n\n    assert_eq!(\n        state.as_fam_struct_ref().padding,\n        restored_state.as_fam_struct_ref().padding\n    );\n    assert_eq!(\n        state.as_fam_struct_ref().extra_value,\n        restored_state.as_fam_struct_ref().extra_value\n    );\n    // At v3, `status` field exists, so it will take its original value.\n    assert_eq!(Wrapping(true), restored_state.as_fam_struct_ref().status);\n\n    // Serialize as v4.\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 4)\n        .unwrap();\n    restored_state =\n        <MessageFamStructWrapper as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 4)\n            .unwrap();\n\n    // At v4, `padding` field will take the default u32 value.\n    assert_eq!(0, restored_state.as_fam_struct_ref().padding);\n    assert_eq!(\n        state.as_fam_struct_ref().extra_value,\n        restored_state.as_fam_struct_ref().extra_value\n    );\n    // `status` is not available anymore, so it will take the default value.\n    assert_eq!(Wrapping(false), restored_state.as_fam_struct_ref().status);\n\n    snapshot_mem = vec![0u8; 16];\n\n    assert_eq!(\n        state\n            .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n            .unwrap_err(),\n        VersionizeError::Serialize(\n            \"Io(Error { kind: WriteZero, message: \\\"failed to write whole buffer\\\" })\".to_owned()\n        )\n    );\n}\n\n#[derive(Versionize)]\npub struct FamStructTest {\n    some_u8: u8,\n    message_box: Box<MessageFamStructWrapper>,\n    #[version(start = 2, default_fn = \"default_option\", de_fn = \"de_option\")]\n    some_option: Option<S>,\n    #[version(start = 3)]\n    some_string: String,\n    #[version(end = 3, default_fn = \"default_message\", de_fn = \"de_message\")]\n    messages: Vec<MessageFamStructWrapper>,\n}\n\nimpl FamStructTest {\n    fn default_message(_target_version: u16) -> Vec<MessageFamStructWrapper> {\n        let mut f = MessageFamStructWrapper::new(0).unwrap();\n        f.as_mut_fam_struct().padding = 1;\n        f.as_mut_fam_struct().extra_value = 2;\n\n        f.push(10).unwrap();\n        f.push(20).unwrap();\n\n        vec![f]\n    }\n\n    fn default_option(_target_version: u16) -> Option<S> {\n        Some(S { a: 0.5, b: 0 })\n    }\n\n    fn de_message(&mut self, target_version: u16) -> VersionizeResult<()> {\n        // Fail if semantic deserialization is called for v2.\n        assert_ne!(target_version, 2);\n        self.some_option = None;\n        self.some_string = \"some_new_string\".to_owned();\n        Ok(())\n    }\n\n    fn de_option(&mut self, target_version: u16) -> VersionizeResult<()> {\n        // Fail if semantic deserialization is called for a version >= 2.\n        assert!(target_version < 2);\n\n        let mut f = MessageFamStructWrapper::new(0).unwrap();\n        f.as_mut_fam_struct().padding = 3;\n        f.as_mut_fam_struct().extra_value = 4;\n\n        f.push(10).unwrap();\n        f.push(20).unwrap();\n\n        self.messages.push(f);\n        Ok(())\n    }\n}\n\n#[test]\nfn test_versionize_struct_with_famstructs() {\n    let mut vm = VersionMap::new();\n    vm.new_version()\n        .set_type_version(FamStructTest::type_id(), 2)\n        .set_type_version(Message::type_id(), 2)\n        .new_version()\n        .set_type_version(FamStructTest::type_id(), 3)\n        .set_type_version(Message::type_id(), 3);\n\n    let mut snapshot_mem = vec![0u8; 1024];\n\n    let mut f = MessageFamStructWrapper::new(0).unwrap();\n    f.as_mut_fam_struct().padding = 5;\n    f.as_mut_fam_struct().extra_value = 6;\n    f.push(10).unwrap();\n\n    let mut f2 = MessageFamStructWrapper::new(0).unwrap();\n    f2.as_mut_fam_struct().padding = 7;\n    f2.as_mut_fam_struct().extra_value = 8;\n    f2.push(20).unwrap();\n\n    let state = FamStructTest {\n        some_u8: 1,\n        messages: vec![f],\n        some_string: \"some_string\".to_owned(),\n        message_box: Box::new(f2),\n        some_option: None,\n    };\n\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n        .unwrap();\n    let mut restored_state =\n        <FamStructTest as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1).unwrap();\n\n    // At version 1, we expect `de_option` and `de_message` to be called.\n    // `some_string` and `some_option` will take the default values.\n    assert_eq!(restored_state.some_string, String::default());\n    assert_eq!(restored_state.some_option, Some(S { a: 0.5, b: 0 }));\n    let messages = restored_state.messages;\n\n    // We expect to have 2 elements in the messages Vec (the one with which it was initialized and\n    // the one inserted by `de_option`).\n    assert_eq!(messages.len(), 2);\n    for message in messages.iter() {\n        assert_eq!(message.as_fam_struct_ref().extra_value, 4);\n        assert_eq!(message.as_fam_struct_ref().status, Wrapping(false));\n    }\n    assert_eq!(messages[0].as_fam_struct_ref().padding, 5);\n    assert_eq!(messages[1].as_fam_struct_ref().padding, 3);\n\n    // Serialize as v2.\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 2)\n        .unwrap();\n    restored_state =\n        <FamStructTest as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 2).unwrap();\n\n    assert_eq!(restored_state.some_string, String::default());\n    // `some_option` is available at v2, so it will take the original value.\n    assert_eq!(restored_state.some_option, None);\n    let messages = restored_state.messages;\n    // We expect to have only one element in `messages` as `de_option` shouldn't be called\n    // this time.\n    assert_eq!(messages.len(), 1);\n\n    // Serialize as v3.\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 3)\n        .unwrap();\n    restored_state =\n        <FamStructTest as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 3).unwrap();\n\n    // `some_string` is also available at v3.\n    assert_eq!(restored_state.some_string, \"some_new_string\".to_owned());\n    assert_eq!(restored_state.some_option, None);\n    let messages = restored_state.messages;\n    // `messages` field is not available anymore at v3, it will take the default value,\n    // set by the corresponding `default_fn`.\n    assert_eq!(messages.len(), 1);\n    assert_eq!(messages[0].as_fam_struct_ref().padding, 1);\n}\n\n#[derive(Clone, Versionize)]\npub struct SomeStruct {\n    message: MessageFamStructWrapper,\n    #[version(start = 2, ser_fn = \"ser_u16\")]\n    some_u16: u16,\n}\n\nimpl SomeStruct {\n    fn ser_u16(&mut self, target_version: u16) -> VersionizeResult<()> {\n        // Fail if semantic serialization is called for the latest version.\n        assert!(target_version < 2);\n        self.message.as_mut_fam_struct().padding += 2;\n\n        Ok(())\n    }\n}\n\n#[derive(Clone, Versionize)]\npub struct SomeStruct2 {\n    message: Message2FamStructWrapper,\n    #[version(start = 2, ser_fn = \"ser_u16\")]\n    some_u16: u16,\n}\n\nimpl SomeStruct2 {\n    fn ser_u16(&mut self, target_version: u16) -> VersionizeResult<()> {\n        // Fail if semantic serialization is called for the latest version.\n        assert!(target_version < 2);\n        self.message.as_mut_fam_struct().padding += 2;\n\n        Ok(())\n    }\n}\n\n// `Clone` issue fixed: https://github.com/rust-vmm/vmm-sys-util/issues/85.\n// We are keeping this as regression test.\n#[test]\nfn test_famstructwrapper_clone() {\n    // Test that having a `FamStructWrapper<T>` in a structure that implements\n    // Clone will result in keeping with their original values, only the number\n    // of entries and the entries array when serializing.\n    let mut vm = VersionMap::new();\n    vm.new_version().set_type_version(SomeStruct::type_id(), 2);\n\n    let mut f = MessageFamStructWrapper::new(0).unwrap();\n    f.as_mut_fam_struct().padding = 8;\n\n    f.push(1).unwrap();\n    f.push(2).unwrap();\n\n    let state = SomeStruct {\n        message: f,\n        some_u16: 2,\n    };\n\n    let mut snapshot_mem = vec![0u8; 128];\n\n    // Serialize as v1.\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n        .unwrap();\n    let mut restored_state =\n        <SomeStruct as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1).unwrap();\n\n    // Negative scenario - FamStruct versionize impl fails due to SizeLimitExceeded.\n    assert!(\n        <SomeStruct2 as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1).is_err()\n    );\n\n    let original_values = state.message.as_slice();\n    let restored_values = restored_state.message.as_slice();\n\n    assert_ne!(\n        state.message.as_fam_struct_ref().padding,\n        restored_state.message.as_fam_struct_ref().padding\n    );\n    assert_eq!(original_values, restored_values);\n    // `padding` field will have its value serialized (8), and then it will be incremented with 2\n    // by `ser_u16`.\n    assert_eq!(10, restored_state.message.as_fam_struct_ref().padding);\n\n    // Serialize as v2.\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 2)\n        .unwrap();\n    restored_state =\n        <SomeStruct as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 2).unwrap();\n\n    // Padding is correctly preserved and ser_u16 is not called - it would fail due to ser_u16\n    // assert anyways, but we double that check here.\n    assert_eq!(\n        state.message.as_fam_struct_ref().padding,\n        restored_state.message.as_fam_struct_ref().padding\n    );\n    // `padding` field will have its value preserved (8). `ser_u16` won't be called at v2.\n    assert_eq!(8, restored_state.message.as_fam_struct_ref().padding);\n}\n"], "fixing_code": ["// Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n//! Serialization support for primitive data types.\n#![allow(clippy::float_cmp)]\n\nuse self::super::{VersionMap, Versionize, VersionizeError, VersionizeResult};\nuse vmm_sys_util::fam::{FamStruct, FamStructWrapper};\n\n/// Maximum allowed string len in bytes (16KB).\n/// Calling `serialize()` or `deserialiaze()` will fail beyond this limit.\npub const MAX_STRING_LEN: usize = 16384;\n/// Maximum allowed vec size in bytes (10MB).\n/// Calling `serialize()` or `deserialiaze()` will fail beyond this limit.\npub const MAX_VEC_SIZE: usize = 10_485_760;\n\n/// A macro that implements the Versionize trait for primitive types using the\n/// serde bincode backed.\nmacro_rules! impl_versionize {\n    ($ty:ident) => {\n        impl Versionize for $ty {\n            #[inline]\n            fn serialize<W: std::io::Write>(\n                &self,\n                writer: &mut W,\n                _version_map: &VersionMap,\n                _version: u16,\n            ) -> VersionizeResult<()> {\n                bincode::serialize_into(writer, &self)\n                    .map_err(|ref err| VersionizeError::Serialize(format!(\"{:?}\", err)))?;\n                Ok(())\n            }\n\n            #[inline]\n            fn deserialize<R: std::io::Read>(\n                mut reader: &mut R,\n                _version_map: &VersionMap,\n                _version: u16,\n            ) -> VersionizeResult<Self>\n            where\n                Self: Sized,\n            {\n                bincode::deserialize_from(&mut reader)\n                    .map_err(|ref err| VersionizeError::Deserialize(format!(\"{:?}\", err)))\n            }\n\n            // Not used.\n            fn version() -> u16 {\n                1\n            }\n        }\n    };\n}\n\nimpl_versionize!(bool);\nimpl_versionize!(isize);\nimpl_versionize!(i8);\nimpl_versionize!(i16);\nimpl_versionize!(i32);\nimpl_versionize!(i64);\nimpl_versionize!(i128);\nimpl_versionize!(usize);\nimpl_versionize!(u8);\nimpl_versionize!(u16);\nimpl_versionize!(u32);\nimpl_versionize!(u64);\nimpl_versionize!(u128);\nimpl_versionize!(f32);\nimpl_versionize!(f64);\nimpl_versionize!(char);\n\nimpl Versionize for String {\n    #[inline]\n    fn serialize<W: std::io::Write>(\n        &self,\n        writer: &mut W,\n        version_map: &VersionMap,\n        app_version: u16,\n    ) -> VersionizeResult<()> {\n        // It is better to fail early at serialization time.\n        if self.len() > MAX_STRING_LEN {\n            return Err(VersionizeError::StringLength(self.len()));\n        }\n\n        self.len().serialize(writer, version_map, app_version)?;\n        writer\n            .write_all(self.as_bytes())\n            .map_err(|e| VersionizeError::Io(e.raw_os_error().unwrap_or(0)))?;\n        Ok(())\n    }\n\n    #[inline]\n    fn deserialize<R: std::io::Read>(\n        mut reader: &mut R,\n        version_map: &VersionMap,\n        app_version: u16,\n    ) -> VersionizeResult<Self> {\n        let len = usize::deserialize(&mut reader, version_map, app_version)?;\n        // Even if we fail in serialize, we still need to enforce this on the hot path\n        // in case the len is corrupted.\n        if len > MAX_STRING_LEN {\n            return Err(VersionizeError::StringLength(len));\n        }\n\n        let mut v = vec![0u8; len];\n        reader\n            .read_exact(v.as_mut_slice())\n            .map_err(|e| VersionizeError::Io(e.raw_os_error().unwrap_or(0)))?;\n        String::from_utf8(v)\n            .map_err(|err| VersionizeError::Deserialize(format!(\"Utf8 error: {:?}\", err)))\n    }\n\n    // Not used yet.\n    fn version() -> u16 {\n        1\n    }\n}\n\nmacro_rules! impl_versionize_array_with_size {\n    ($ty:literal) => {\n        impl<T> Versionize for [T; $ty]\n        where\n            T: Copy + Default + Versionize,\n        {\n            #[inline]\n            fn serialize<W: std::io::Write>(\n                &self,\n                writer: &mut W,\n                version_map: &VersionMap,\n                app_version: u16,\n            ) -> VersionizeResult<()> {\n                for element in self {\n                    element.serialize(writer, version_map, app_version)?;\n                }\n\n                Ok(())\n            }\n\n            #[inline]\n            fn deserialize<R: std::io::Read>(\n                reader: &mut R,\n                version_map: &VersionMap,\n                app_version: u16,\n            ) -> VersionizeResult<Self> {\n                let mut array = [T::default(); $ty];\n                for i in 0..$ty {\n                    array[i] = T::deserialize(reader, version_map, app_version)?;\n                }\n                Ok(array)\n            }\n\n            // Not used yet.\n            fn version() -> u16 {\n                1\n            }\n        }\n    };\n}\n\n// Conventionally, traits are available for primitive arrays only up to size 32\n// until the const generics feature is implemented.\n// [https://doc.rust-lang.org/std/primitive.array.html]\n// [https://github.com/rust-lang/rust/issues/44580]\nmacro_rules! impl_versionize_arrays {\n    ($($N:literal)+) => {\n        $(\n            impl_versionize_array_with_size!($N);\n        )+\n    }\n}\n\nimpl_versionize_arrays! {\n    1  2  3  4  5  6  7  8  9 10\n   11 12 13 14 15 16 17 18 19 20\n   21 22 23 24 25 26 27 28 29 30\n   31 32\n}\n\nimpl<T> Versionize for Box<T>\nwhere\n    T: Versionize,\n{\n    #[inline]\n    fn serialize<W: std::io::Write>(\n        &self,\n        writer: &mut W,\n        version_map: &VersionMap,\n        app_version: u16,\n    ) -> VersionizeResult<()> {\n        self.as_ref().serialize(writer, version_map, app_version)\n    }\n\n    #[inline]\n    fn deserialize<R: std::io::Read>(\n        reader: &mut R,\n        version_map: &VersionMap,\n        app_version: u16,\n    ) -> VersionizeResult<Self> {\n        Ok(Box::new(T::deserialize(reader, version_map, app_version)?))\n    }\n\n    // Not used yet.\n    fn version() -> u16 {\n        1\n    }\n}\n\nimpl<T> Versionize for std::num::Wrapping<T>\nwhere\n    T: Versionize,\n{\n    #[inline]\n    fn serialize<W: std::io::Write>(\n        &self,\n        writer: &mut W,\n        version_map: &VersionMap,\n        app_version: u16,\n    ) -> VersionizeResult<()> {\n        self.0.serialize(writer, version_map, app_version)\n    }\n\n    #[inline]\n    fn deserialize<R: std::io::Read>(\n        reader: &mut R,\n        version_map: &VersionMap,\n        app_version: u16,\n    ) -> VersionizeResult<Self> {\n        Ok(std::num::Wrapping(T::deserialize(\n            reader,\n            version_map,\n            app_version,\n        )?))\n    }\n\n    // Not used yet.\n    fn version() -> u16 {\n        1\n    }\n}\n\nimpl<T> Versionize for Option<T>\nwhere\n    T: Versionize,\n{\n    #[inline]\n    fn serialize<W: std::io::Write>(\n        &self,\n        writer: &mut W,\n        version_map: &VersionMap,\n        app_version: u16,\n    ) -> VersionizeResult<()> {\n        // Serialize an Option just like bincode does: u8, T.\n        match self {\n            Some(value) => {\n                1u8.serialize(writer, version_map, app_version)?;\n                value.serialize(writer, version_map, app_version)\n            }\n            None => 0u8.serialize(writer, version_map, app_version),\n        }\n    }\n\n    #[inline]\n    fn deserialize<R: std::io::Read>(\n        reader: &mut R,\n        version_map: &VersionMap,\n        app_version: u16,\n    ) -> VersionizeResult<Self> {\n        let option = u8::deserialize(reader, version_map, app_version)?;\n        match option {\n            0u8 => Ok(None),\n            1u8 => Ok(Some(T::deserialize(reader, version_map, app_version)?)),\n            value => Err(VersionizeError::Deserialize(format!(\n                \"Invalid option value {}\",\n                value\n            ))),\n        }\n    }\n\n    // Not used yet.\n    fn version() -> u16 {\n        1\n    }\n}\n\nimpl<T> Versionize for Vec<T>\nwhere\n    T: Versionize,\n{\n    #[inline]\n    fn serialize<W: std::io::Write>(\n        &self,\n        mut writer: &mut W,\n        version_map: &VersionMap,\n        app_version: u16,\n    ) -> VersionizeResult<()> {\n        if self.len() > MAX_VEC_SIZE / std::mem::size_of::<T>() {\n            return Err(VersionizeError::VecLength(self.len()));\n        }\n        // Serialize in the same fashion as bincode:\n        // Write len.\n        bincode::serialize_into(&mut writer, &self.len())\n            .map_err(|ref err| VersionizeError::Serialize(format!(\"{:?}\", err)))?;\n        // Walk the vec and write each element.\n        for element in self {\n            element.serialize(writer, version_map, app_version)?;\n        }\n        Ok(())\n    }\n\n    #[inline]\n    fn deserialize<R: std::io::Read>(\n        mut reader: &mut R,\n        version_map: &VersionMap,\n        app_version: u16,\n    ) -> VersionizeResult<Self> {\n        let mut v = Vec::new();\n        let len: usize = bincode::deserialize_from(&mut reader)\n            .map_err(|ref err| VersionizeError::Deserialize(format!(\"{:?}\", err)))?;\n\n        if len > MAX_VEC_SIZE / std::mem::size_of::<T>() {\n            return Err(VersionizeError::VecLength(len));\n        }\n\n        for _ in 0..len {\n            let element: T = T::deserialize(reader, version_map, app_version)\n                .map_err(|ref err| VersionizeError::Deserialize(format!(\"{:?}\", err)))?;\n            v.push(element);\n        }\n        Ok(v)\n    }\n\n    // Not used yet.\n    fn version() -> u16 {\n        1\n    }\n}\n\n// Implement versioning for FAM structures by using the FamStructWrapper interface.\nimpl<T: Default + FamStruct + Versionize> Versionize for FamStructWrapper<T>\nwhere\n    <T as FamStruct>::Entry: Versionize,\n    T: std::fmt::Debug,\n{\n    #[inline]\n    fn serialize<W: std::io::Write>(\n        &self,\n        mut writer: &mut W,\n        version_map: &VersionMap,\n        app_version: u16,\n    ) -> VersionizeResult<()> {\n        // Write the fixed size header.\n        self.as_fam_struct_ref()\n            .serialize(&mut writer, version_map, app_version)?;\n        // Write the array.\n        self.as_slice()\n            .to_vec()\n            .serialize(&mut writer, version_map, app_version)?;\n\n        Ok(())\n    }\n\n    #[inline]\n    fn deserialize<R: std::io::Read>(\n        reader: &mut R,\n        version_map: &VersionMap,\n        app_version: u16,\n    ) -> VersionizeResult<Self> {\n        let header = T::deserialize(reader, version_map, app_version)\n            .map_err(|ref err| VersionizeError::Deserialize(format!(\"{:?}\", err)))?;\n        let entries: Vec<<T as FamStruct>::Entry> =\n            Vec::deserialize(reader, version_map, app_version)\n                .map_err(|ref err| VersionizeError::Deserialize(format!(\"{:?}\", err)))?;\n\n        if header.len() != entries.len() {\n            let msg = format!(\n                \"Mismatch between length of FAM specified in FamStruct header ({}) \\\n                and actual size of FAM ({})\",\n                header.len(),\n                entries.len()\n            );\n\n            return Err(VersionizeError::Deserialize(msg));\n        }\n\n        // Construct the object from the array items.\n        // Header(T) fields will be initialized by Default trait impl.\n        let mut object = FamStructWrapper::from_entries(&entries)\n            .map_err(|ref err| VersionizeError::Deserialize(format!(\"{:?}\", err)))?;\n        // Update Default T with the deserialized header.\n        *object.as_mut_fam_struct() = header;\n        Ok(object)\n    }\n\n    // Not used.\n    fn version() -> u16 {\n        1\n    }\n}\n\n// Manual implementation for tuple of 2 elems.\nimpl<T: Versionize, U: Versionize> Versionize for (T, U) {\n    #[inline]\n    fn serialize<W: std::io::Write>(\n        &self,\n        writer: &mut W,\n        version_map: &VersionMap,\n        app_version: u16,\n    ) -> VersionizeResult<()> {\n        self.0.serialize(writer, version_map, app_version)?;\n        self.1.serialize(writer, version_map, app_version)?;\n        Ok(())\n    }\n\n    #[inline]\n    fn deserialize<R: std::io::Read>(\n        reader: &mut R,\n        version_map: &VersionMap,\n        app_version: u16,\n    ) -> VersionizeResult<Self> {\n        Ok((\n            T::deserialize(reader, version_map, app_version)?,\n            U::deserialize(reader, version_map, app_version)?,\n        ))\n    }\n\n    // Not used yet.\n    fn version() -> u16 {\n        1\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    #![allow(clippy::undocumented_unsafe_blocks)]\n\n    use super::*;\n    use super::{VersionMap, Versionize, VersionizeResult};\n\n    // Generate primitive tests using this macro.\n    macro_rules! primitive_int_test {\n        ($ty:ident, $fn_name:ident) => {\n            #[test]\n            fn $fn_name() {\n                let vm = VersionMap::new();\n                let mut snapshot_mem = vec![0u8; 64];\n\n                let store: $ty = std::$ty::MAX;\n                store\n                    .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n                    .unwrap();\n                let restore =\n                    <$ty as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1).unwrap();\n\n                assert_eq!(store, restore);\n            }\n        };\n    }\n\n    primitive_int_test!(usize, test_ser_de_usize);\n    primitive_int_test!(isize, test_ser_de_isize);\n    primitive_int_test!(u8, test_ser_de_u8);\n    primitive_int_test!(u16, test_ser_de_u16);\n    primitive_int_test!(u32, test_ser_de_u32);\n    primitive_int_test!(u64, test_ser_de_u64);\n    primitive_int_test!(u128, test_ser_de_u128);\n    primitive_int_test!(i8, test_ser_de_i8);\n    primitive_int_test!(i16, test_ser_de_i16);\n    primitive_int_test!(i32, test_ser_de_i32);\n    primitive_int_test!(i64, test_ser_de_i64);\n    primitive_int_test!(i128, test_ser_de_i128);\n    primitive_int_test!(f32, test_ser_de_f32);\n    primitive_int_test!(f64, test_ser_de_f64);\n    primitive_int_test!(char, test_ser_de_char);\n\n    #[test]\n    fn test_corrupted_string_len() {\n        let vm = VersionMap::new();\n        let mut buffer = vec![0u8; 1024];\n\n        let string = String::from(\"Test string1\");\n        string\n            .serialize(&mut buffer.as_mut_slice(), &vm, 1)\n            .unwrap();\n\n        // Test corrupt length field.\n        assert_eq!(\n            <String as Versionize>::deserialize(\n                &mut buffer.as_slice().split_first().unwrap().1,\n                &vm,\n                1\n            )\n            .unwrap_err(),\n            VersionizeError::StringLength(6052837899185946624)\n        );\n\n        // Test incomplete string.\n        assert_eq!(\n            <String as Versionize>::deserialize(&mut buffer.as_slice().split_at(6).0, &vm, 1)\n                .unwrap_err(),\n            VersionizeError::Deserialize(\n                \"Io(Error { kind: UnexpectedEof, message: \\\"failed to fill whole buffer\\\" })\"\n                    .to_owned()\n            )\n        );\n\n        // Test NULL string len.\n        buffer[0] = 0;\n        assert_eq!(\n            <String as Versionize>::deserialize(&mut buffer.as_slice(), &vm, 1).unwrap(),\n            String::new()\n        );\n    }\n\n    #[test]\n    fn test_corrupted_vec_len() {\n        let vm = VersionMap::new();\n        let mut buffer = vec![0u8; 1024];\n\n        let mut string = String::from(\"Test string1\");\n        let vec = unsafe { string.as_mut_vec() };\n        vec.serialize(&mut buffer.as_mut_slice(), &vm, 1).unwrap();\n\n        // Test corrupt length field.\n        assert_eq!(\n            <Vec<u8> as Versionize>::deserialize(\n                &mut buffer.as_slice().split_first().unwrap().1,\n                &vm,\n                1\n            )\n            .unwrap_err(),\n            VersionizeError::VecLength(6052837899185946624)\n        );\n\n        // Test incomplete Vec.\n        assert_eq!(\n            <Vec<u8> as Versionize>::deserialize(&mut buffer.as_slice().split_at(6).0, &vm, 1)\n                .unwrap_err(),\n            VersionizeError::Deserialize(\n                \"Io(Error { kind: UnexpectedEof, message: \\\"failed to fill whole buffer\\\" })\"\n                    .to_owned()\n            )\n        );\n\n        // Test NULL Vec len.\n        buffer[0] = 0;\n        assert_eq!(\n            <Vec<u8> as Versionize>::deserialize(&mut buffer.as_slice(), &vm, 1).unwrap(),\n            Vec::new()\n        );\n    }\n\n    #[test]\n    fn test_ser_de_u32_tuple() {\n        let vm = VersionMap::new();\n        let mut snapshot_mem = vec![0u8; 64];\n\n        let store: (u32, u32) = (std::u32::MIN, std::u32::MAX);\n        store\n            .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n            .unwrap();\n        let restore =\n            <(u32, u32) as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1).unwrap();\n\n        assert_eq!(store, restore);\n    }\n\n    #[derive(Debug, serde_derive::Deserialize, PartialEq, serde_derive::Serialize, Versionize)]\n    enum CompatibleEnum {\n        A,\n        B(String),\n        C(u64, u64, char),\n    }\n\n    #[derive(Debug, serde_derive::Deserialize, PartialEq, serde_derive::Serialize, Versionize)]\n    struct TestCompatibility {\n        _string: String,\n        _array: [u8; 32],\n        _u8: u8,\n        _u16: u16,\n        _u32: u32,\n        _u64: u64,\n        _u128: u128,\n        _i8: i8,\n        _i16: i16,\n        _i32: i32,\n        _i64: i64,\n        _i128: i128,\n        _f32: f32,\n        _f64: f64,\n        _usize: usize,\n        _isize: isize,\n        _vec: Vec<u64>,\n        _option: Option<bool>,\n        _enums: Vec<CompatibleEnum>,\n        #[allow(clippy::box_collection)] // we want to test boxes explicitly\n        _box: Box<String>,\n    }\n\n    #[test]\n    fn test_bincode_deserialize_from_versionize() {\n        let mut snapshot_mem = vec![0u8; 4096];\n        let vm = VersionMap::new();\n\n        let test_struct = TestCompatibility {\n            _string: \"String\".to_owned(),\n            _array: [128u8; 32],\n            _u8: 1,\n            _u16: 32000,\n            _u32: 0x1234_5678,\n            _u64: 0x1234_5678_9875_4321,\n            _u128: 0x1234_5678_1234_5678_1234_5678_1234_5678,\n            _i8: -1,\n            _i16: -32000,\n            _i32: -0x1234_5678,\n            _i64: -0x1234_5678_9875_4321,\n            _i128: -0x1234_5678_9098_7654_3212_3456_7890_9876,\n            _usize: 0x1234_5678_9875_4321,\n            _isize: -0x1234_5678_9875_4321,\n            _f32: 0.123,\n            _f64: 0.123_456_789_000_000,\n            _vec: vec![33; 32],\n            _option: Some(true),\n            _enums: vec![\n                CompatibleEnum::A,\n                CompatibleEnum::B(\"abcd\".to_owned()),\n                CompatibleEnum::C(1, 2, 'a'),\n            ],\n            _box: Box::new(\"Box\".to_owned()),\n        };\n\n        Versionize::serialize(&test_struct, &mut snapshot_mem.as_mut_slice(), &vm, 1).unwrap();\n\n        let restored_state: TestCompatibility =\n            bincode::deserialize_from(snapshot_mem.as_slice()).unwrap();\n        assert_eq!(test_struct, restored_state);\n    }\n\n    #[test]\n    fn test_bincode_serialize_to_versionize() {\n        let mut snapshot_mem = vec![0u8; 4096];\n        let vm = VersionMap::new();\n\n        let test_struct = TestCompatibility {\n            _string: \"String\".to_owned(),\n            _array: [128u8; 32],\n            _u8: 1,\n            _u16: 32000,\n            _u32: 0x1234_5678,\n            _u64: 0x1234_5678_9875_4321,\n            _u128: 0x1234_1234_1234_1234_1234_1234_1234_1234,\n            _i8: -1,\n            _i16: -32000,\n            _i32: -0x1234_5678,\n            _i64: -0x1234_5678_9875_4321,\n            _i128: -0x1234_1234_1234_1234_1234_1234_1234_1234,\n            _usize: 0x1234_5678_9875_4321,\n            _isize: -0x1234_5678_9875_4321,\n            _f32: 0.123,\n            _f64: 0.123_456_789_000_000,\n            _vec: vec![33; 32],\n            _option: Some(true),\n            _enums: vec![\n                CompatibleEnum::A,\n                CompatibleEnum::B(\"abcd\".to_owned()),\n                CompatibleEnum::C(1, 2, 'a'),\n            ],\n            _box: Box::new(\"Box\".to_owned()),\n        };\n\n        bincode::serialize_into(snapshot_mem.as_mut_slice(), &test_struct).unwrap();\n\n        let restored_state: TestCompatibility =\n            Versionize::deserialize(&mut snapshot_mem.as_slice(), &vm, 1).unwrap();\n        assert_eq!(test_struct, restored_state);\n    }\n\n    #[test]\n    fn test_ser_de_bool() {\n        let vm = VersionMap::new();\n        let mut snapshot_mem = vec![0u8; 64];\n\n        let store = true;\n        store\n            .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n            .unwrap();\n        let restore =\n            <bool as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1).unwrap();\n\n        assert_eq!(store, restore);\n    }\n\n    #[test]\n    fn test_ser_de_string() {\n        let vm = VersionMap::new();\n        let mut snapshot_mem = vec![0u8; 64];\n\n        let store = String::from(\"test string\");\n        store\n            .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n            .unwrap();\n        let restore =\n            <String as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1).unwrap();\n\n        assert_eq!(store, restore);\n    }\n\n    #[test]\n    fn test_ser_de_vec() {\n        let vm = VersionMap::new();\n        let mut snapshot_mem = vec![0u8; 64];\n\n        let store = vec![\n            \"test 1\".to_owned(),\n            \"test 2\".to_owned(),\n            \"test 3\".to_owned(),\n        ];\n\n        store\n            .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n            .unwrap();\n        let restore =\n            <Vec<String> as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1).unwrap();\n\n        assert_eq!(store, restore);\n    }\n\n    #[test]\n    fn test_ser_de_option() {\n        let vm = VersionMap::new();\n        let mut snapshot_mem = vec![0u8; 64];\n        let mut store = Some(\"test\".to_owned());\n\n        store\n            .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n            .unwrap();\n        let mut restore =\n            <Option<String> as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1)\n                .unwrap();\n        assert_eq!(store, restore);\n\n        // Check that ser_de also works for `None` variant.\n        store = None;\n        store\n            .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n            .unwrap();\n        restore = <Option<String> as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1)\n            .unwrap();\n        assert_eq!(store, restore);\n\n        store = Some(\"test\".to_owned());\n        store\n            .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n            .unwrap();\n        // Corrupt `snapshot_mem` by changing the most significant bit to a value different than 0 or 1.\n        snapshot_mem[0] = 2;\n        let restore_err =\n            <Option<String> as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1)\n                .unwrap_err();\n        assert_eq!(\n            restore_err,\n            VersionizeError::Deserialize(\"Invalid option value 2\".to_string())\n        );\n        // Corrupt `snapshot_mem` by changing the most significant bit from 1 (`Some(type)`) to 0 (`None`).\n        snapshot_mem[0] = 0;\n        restore = <Option<String> as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1)\n            .unwrap();\n        assert_ne!(store, restore);\n    }\n\n    #[test]\n    fn test_ser_de_box() {\n        let vm = VersionMap::new();\n        let mut snapshot_mem = vec![0u8; 64];\n\n        let store = Box::new(\"test\".to_owned());\n\n        store\n            .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n            .unwrap();\n        let restore =\n            <Box<String> as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1).unwrap();\n\n        assert_eq!(store, restore);\n    }\n\n    #[test]\n    fn test_ser_de_wrapping() {\n        let vm = VersionMap::new();\n        let mut snapshot_mem = vec![0u8; 64];\n\n        let store = std::num::Wrapping(1337u32);\n\n        store\n            .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n            .unwrap();\n        let restore = <std::num::Wrapping<u32> as Versionize>::deserialize(\n            &mut snapshot_mem.as_slice(),\n            &vm,\n            1,\n        )\n        .unwrap();\n\n        assert_eq!(store, restore);\n    }\n\n    #[test]\n    fn test_vec_limit() {\n        // We need extra 8 bytes for vector len.\n        let mut snapshot_mem = vec![0u8; MAX_VEC_SIZE + 8];\n        let err = vec![123u8; MAX_VEC_SIZE + 1]\n            .serialize(&mut snapshot_mem.as_mut_slice(), &VersionMap::new(), 1)\n            .unwrap_err();\n        assert_eq!(err, VersionizeError::VecLength(MAX_VEC_SIZE + 1));\n        assert_eq!(\n            format!(\"{}\", err),\n            \"Vec of length 10485761 exceeded maximum size of 10485760 bytes\"\n        );\n    }\n\n    #[test]\n    fn test_string_limit() {\n        // We need extra 8 bytes for string len.\n        let mut snapshot_mem = vec![0u8; MAX_STRING_LEN + 8];\n        let err = String::from_utf8(vec![123u8; MAX_STRING_LEN + 1])\n            .unwrap()\n            .serialize(&mut snapshot_mem.as_mut_slice(), &VersionMap::new(), 1)\n            .unwrap_err();\n        assert_eq!(err, VersionizeError::StringLength(MAX_STRING_LEN + 1));\n        assert_eq!(\n            format!(\"{}\", err),\n            \"String length exceeded 16385 > 16384 bytes\"\n        );\n    }\n}\n", "// Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\n#![allow(clippy::missing_safety_doc)]\n\nextern crate versionize;\nextern crate versionize_derive;\nextern crate vmm_sys_util;\n\nuse std::fmt::{Debug, Formatter, Result};\nuse std::num::Wrapping;\n\nuse vmm_sys_util::fam::{FamStruct, FamStructWrapper};\nuse vmm_sys_util::generate_fam_struct_impl;\n\nuse versionize::{VersionMap, Versionize, VersionizeError, VersionizeResult};\nuse versionize_derive::Versionize;\n\n#[derive(Debug, PartialEq, Versionize, Eq)]\npub enum TestState {\n    Zero,\n    One(u32),\n    #[version(start = 2, default_fn = \"default_state_two\")]\n    Two(u64),\n}\n\nimpl TestState {\n    fn default_state_two(&self, target_version: u16) -> VersionizeResult<TestState> {\n        match target_version {\n            1 => Ok(TestState::One(2)),\n            i => Err(VersionizeError::Serialize(format!(\n                \"Unknown target version: {}\",\n                i\n            ))),\n        }\n    }\n}\n\n#[test]\nfn test_hardcoded_struct_deserialization() {\n    // We are testing representation compatibility between versions, at the `versionize`\n    // crate level, by checking that only the newly added/removed fields changes between\n    // versions are reflected in the hardcoded snapshot.\n\n    #[rustfmt::skip]\n    let v1_hardcoded_snapshot: &[u8] = &[\n        // usize field (8 bytes), u16 field (2 bytes) +\n        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,\n        // u64 (8 bytes), i8 (1 byte), i32 (4 bytes) +\n        0xCD, 0xAB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x20, 0x00, 0x00, 0x00,\n        // f32 (4 bytes), f64 (8 bytes), char (1 bytes) +\n        0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x50, 0x40, 0x61,\n        // String len (8 bytes) +\n        0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        // actual String (11 bytes in our case) +\n        0x73, 0x6F, 0x6D, 0x65, 0x5F, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67,\n        // enum variant number (4 bytes) + value of that variant (in this case it is\n        // of u32 type -> 4 bytes) +\n        0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,\n        // Option variant (1 byte) + value of variant (u8 -> 1 byte) +\n        0x01, 0x81,\n        // Box: String len (8 bytes) + actual String (17 bytes in this case).\n        0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x73, 0x6F, 0x6D, 0x65, 0x5F,\n        0x6F, 0x74, 0x68, 0x65, 0x72, 0x5F, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67,\n    ];\n\n    // At version 2 isize (8 bytes), i64 (8 bytes) and bool (1 byte) fields will be also\n    // present. At v2 there is also a new variant available for enum, so we can store that in\n    // memory and it occupies 4 more bytes than the one stored at v1.\n    #[rustfmt::skip]\n    let v2_hardcoded_snapshot: &[u8] = &[\n        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        // New isize field.\n        0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x04, 0x00,\n        0xCD, 0xAB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x20, 0x00, 0x00, 0x00,\n        // New i64 field.\n        0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x50, 0x40, 0x61,\n        // New bool field.\n        0x01,\n        0x0B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x73, 0x6F, 0x6D, 0x65, 0x5F, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67,\n        // New available enum variant.\n        0x02, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x01, 0x81,\n        0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x73, 0x6F, 0x6D, 0x65, 0x5F,\n        0x6F, 0x74, 0x68, 0x65, 0x72, 0x5F, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67,\n    ];\n\n    // At version 3, u64 and i64 disappear (16 bytes) and Vec (8 + 4 = 12 bytes) and Wrapping\n    // (4 bytes) fields are available.\n    #[rustfmt::skip]\n    let v3_hardcoded_snapshot: &[u8] = &[\n        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x04, 0x00,\n        0xFF, 0x20, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x50, 0x40, 0x61,\n        0x01,\n        0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x73, 0x6F, 0x6D, 0x65, 0x5F, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67,\n        0x02, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x01, 0x81,\n        // Vec len (8 bytes) + actual Vec (4 bytes).\n        0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x61, 0x61, 0x61, 0x61,\n        0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x73, 0x6F, 0x6D, 0x65, 0x5F,\n        0x6F, 0x74, 0x68, 0x65, 0x72, 0x5F, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67,\n        // Wrapping over an u32 (4 bytes).\n        0xFF, 0x00, 0x00, 0x00,\n    ];\n\n    // At version 4, isize and Vec disappear (20 bytes): 0x6F - 0x14 = 0x5B.\n    #[rustfmt::skip]\n    let v4_hardcoded_snapshot: &[u8] = &[\n        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x04, 0x00,\n        0xFF, 0x20, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x50, 0x40, 0x61,\n        0x01,\n        0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x73, 0x6F, 0x6D, 0x65, 0x5F, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67,\n        0x02, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x01, 0x81,\n        0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x73, 0x6F, 0x6D, 0x65, 0x5F,\n        0x6F, 0x74, 0x68, 0x65, 0x72, 0x5F, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67,\n        0xFF, 0x00, 0x00, 0x00,\n    ];\n\n    #[derive(Debug, PartialEq, Versionize)]\n    pub struct TestStruct {\n        usize_1: usize,\n        #[version(start = 2, end = 4, default_fn = \"default_isize\")]\n        isize_1: isize,\n        u16_1: u16,\n        #[version(end = 3, default_fn = \"default_u64\")]\n        u64_1: u64,\n        i8_1: i8,\n        #[version(start = 2, end = 2)]\n        i16_1: i16,\n        i32_1: i32,\n        #[version(start = 2, end = 3, default_fn = \"default_i64\")]\n        i64_1: i64,\n        f32_1: f32,\n        f64_1: f64,\n        char_1: char,\n        #[version(start = 2, default_fn = \"default_bool\")]\n        bool_1: bool,\n        string_1: String,\n        enum_1: TestState,\n        option_1: Option<u8>,\n        #[version(start = 3, end = 4, default_fn = \"default_vec\")]\n        vec_1: Vec<char>,\n        #[allow(clippy::box_collection)] // we want to explicitly test Box\n        box_1: Box<String>,\n        #[version(start = 3)]\n        wrapping_1: Wrapping<u32>,\n    }\n\n    impl TestStruct {\n        fn default_isize(_source_version: u16) -> isize {\n            12isize\n        }\n\n        fn default_u64(_source_version: u16) -> u64 {\n            0x0Du64\n        }\n\n        fn default_i64(_source_version: u16) -> i64 {\n            0x0Ei64\n        }\n\n        fn default_bool(_source_version: u16) -> bool {\n            false\n        }\n\n        fn default_vec(_source_version: u16) -> Vec<char> {\n            vec!['v'; 8]\n        }\n    }\n\n    let mut vm = VersionMap::new();\n    vm.new_version()\n        .set_type_version(TestStruct::type_id(), 2)\n        .set_type_version(TestState::type_id(), 2)\n        .new_version()\n        .set_type_version(TestStruct::type_id(), 3)\n        .new_version()\n        .set_type_version(TestStruct::type_id(), 4);\n\n    let mut snapshot_blob = v1_hardcoded_snapshot;\n\n    let mut restored_state =\n        <TestStruct as Versionize>::deserialize(&mut snapshot_blob, &vm, 1).unwrap();\n\n    // We expect isize, i16, i64, bool, Vec and Wrapping fields to have the default values at v1.\n    let mut expected_state = TestStruct {\n        usize_1: 1,\n        isize_1: 12,\n        u16_1: 4,\n        u64_1: 0xABCDu64,\n        i8_1: -1,\n        i16_1: 0,\n        i32_1: 32,\n        i64_1: 0x0Ei64,\n        f32_1: 0.5,\n        f64_1: 64.5,\n        char_1: 'a',\n        bool_1: false,\n        string_1: \"some_string\".to_owned(),\n        enum_1: TestState::One(2),\n        option_1: Some(129),\n        vec_1: vec!['v'; 8],\n        box_1: Box::new(\"some_other_string\".to_owned()),\n        wrapping_1: Wrapping(0u32),\n    };\n    assert_eq!(restored_state, expected_state);\n\n    snapshot_blob = v2_hardcoded_snapshot;\n\n    restored_state = <TestStruct as Versionize>::deserialize(&mut snapshot_blob, &vm, 2).unwrap();\n\n    // We expect only i16, Vec and Wrapping fields to have the default values at v2.\n    expected_state = TestStruct {\n        usize_1: 1,\n        isize_1: 2,\n        u16_1: 4,\n        u64_1: 0xABCDu64,\n        i8_1: -1,\n        i16_1: 0,\n        i32_1: 32,\n        i64_1: 0xFFFFi64,\n        f32_1: 0.5,\n        f64_1: 64.5,\n        char_1: 'a',\n        bool_1: true,\n        string_1: \"some_string\".to_owned(),\n        enum_1: TestState::Two(14),\n        option_1: Some(129),\n        vec_1: vec!['v'; 8],\n        box_1: Box::new(\"some_other_string\".to_owned()),\n        wrapping_1: Wrapping(0u32),\n    };\n    assert_eq!(restored_state, expected_state);\n\n    snapshot_blob = v3_hardcoded_snapshot;\n\n    restored_state = <TestStruct as Versionize>::deserialize(&mut snapshot_blob, &vm, 3).unwrap();\n\n    // We expect u64, i16 and i64 fields to have the default values at v3.\n    expected_state = TestStruct {\n        usize_1: 1,\n        isize_1: 2,\n        u16_1: 4,\n        u64_1: 0x0Du64,\n        i8_1: -1,\n        i16_1: 0,\n        i32_1: 32,\n        i64_1: 0x0Ei64,\n        f32_1: 0.5,\n        f64_1: 64.5,\n        char_1: 'a',\n        bool_1: true,\n        string_1: \"some_string\".to_owned(),\n        enum_1: TestState::Two(14),\n        option_1: Some(129),\n        vec_1: vec!['a'; 4],\n        box_1: Box::new(\"some_other_string\".to_owned()),\n        wrapping_1: Wrapping(255u32),\n    };\n    assert_eq!(restored_state, expected_state);\n\n    snapshot_blob = v4_hardcoded_snapshot;\n\n    restored_state = <TestStruct as Versionize>::deserialize(&mut snapshot_blob, &vm, 4).unwrap();\n\n    // We expect isize, u64, i16, i64 and Vec fields to have the default values at v4.\n    expected_state = TestStruct {\n        usize_1: 1,\n        isize_1: 12,\n        u16_1: 4,\n        u64_1: 0x0Du64,\n        i8_1: -1,\n        i16_1: 0,\n        i32_1: 32,\n        i64_1: 0x0Ei64,\n        f32_1: 0.5,\n        f64_1: 64.5,\n        char_1: 'a',\n        bool_1: true,\n        string_1: \"some_string\".to_owned(),\n        enum_1: TestState::Two(14),\n        option_1: Some(129),\n        vec_1: vec!['v'; 8],\n        box_1: Box::new(\"some_other_string\".to_owned()),\n        wrapping_1: Wrapping(255u32),\n    };\n    assert_eq!(restored_state, expected_state);\n}\n\n#[test]\nfn test_hardcoded_enum_deserialization() {\n    // We are testing separately also hardcoded snapshot deserialization for enums\n    // as these have a different behavior in terms of serialization/deserialization.\n    #[rustfmt::skip]\n    let v1_hardcoded_snapshot: &[u8] = &[\n        // Variant number (4 bytes), the first variant lacks a value.\n        0x00, 0x00, 0x00, 0x00,\n    ];\n\n    #[rustfmt::skip]\n    let v2_hardcoded_snapshot: &[u8] = &[\n        0x00, 0x00, 0x00, 0x00,\n    ];\n\n    #[rustfmt::skip]\n    let unexpected_v1_hardcoded_snapshot: &[u8] = &[\n        // Second variant (4 bytes) + value of that variant (8 bytes).\n        0x02, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    ];\n\n    #[rustfmt::skip]\n    let invalid_v1_hardcoded_snapshot: &[u8] = &[\n        // Invalid enum variant number.\n        0x03, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    ];\n\n    let mut vm = VersionMap::new();\n    vm.new_version().set_type_version(TestState::type_id(), 2);\n\n    let mut snapshot_blob = v1_hardcoded_snapshot;\n\n    let mut restored_state =\n        <TestState as Versionize>::deserialize(&mut snapshot_blob, &vm, 1).unwrap();\n    assert_eq!(restored_state, TestState::Zero);\n\n    snapshot_blob = v2_hardcoded_snapshot;\n\n    restored_state = <TestState as Versionize>::deserialize(&mut snapshot_blob, &vm, 2).unwrap();\n    assert_eq!(restored_state, TestState::Zero);\n\n    snapshot_blob = unexpected_v1_hardcoded_snapshot;\n\n    // Versioned deserialization is not implemented for enums, so even though we do not have\n    // `Two` state available at version 2, restoring the data won't fail :(.\n    // TODO: This must be fixed.\n    restored_state = <TestState as Versionize>::deserialize(&mut snapshot_blob, &vm, 1).unwrap();\n    assert_eq!(restored_state, TestState::Two(5));\n\n    // This snapshot contains a non-existent enum variant.\n    snapshot_blob = invalid_v1_hardcoded_snapshot;\n\n    assert_eq!(\n        <TestState as Versionize>::deserialize(&mut snapshot_blob, &vm, 1).unwrap_err(),\n        VersionizeError::Deserialize(\"Unknown variant_index 3\".to_owned())\n    );\n}\n\n#[derive(Debug, PartialEq, Eq, Versionize)]\npub struct A {\n    a: u32,\n    #[version(start = 1, end = 2)]\n    b: Option<TestState>,\n    #[version(start = 2, default_fn = \"default_c\")]\n    c: String,\n}\n\n#[derive(Debug, PartialEq, Eq, Versionize)]\npub struct X {\n    x: bool,\n    a_1: A,\n    #[version(end = 3, default_fn = \"default_y\")]\n    y: Box<usize>,\n    #[version(start = 3, default_fn = \"default_z\")]\n    z: Vec<u8>,\n}\n\nimpl A {\n    fn default_c(_source_version: u16) -> String {\n        \"some_string\".to_owned()\n    }\n}\n\nimpl X {\n    fn default_y(_source_version: u16) -> Box<usize> {\n        Box::from(4)\n    }\n\n    fn default_z(_source_version: u16) -> Vec<u8> {\n        vec![16, 4]\n    }\n}\n\n#[test]\nfn test_nested_structs_deserialization() {\n    #[rustfmt::skip]\n    let v1_hardcoded_snapshot: &[u8] = &[\n        // Bool field (1 byte) from X, `a` field from A (4 bytes) +\n        0x00, 0x10, 0x00, 0x00, 0x00,\n        // `b` field from A: Option type (1 byte), inner enum variant number (4 bytes) +\n        // + value of that variant (4 bytes) +\n        0x01, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,\n        // `y` field from A (8 bytes).\n        0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    ];\n\n    #[rustfmt::skip]\n    let v2_hardcoded_snapshot: &[u8] = &[\n        // Bool field (1 byte) from X, `a` field from A (4 bytes) +\n        0x00, 0x10, 0x00, 0x00, 0x00,\n        // `c` field from X: String len (8 bytes) + actual String;\n        // the Option field is not available at v2.\n        0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x72, 0x61, 0x6E, 0x64, 0x6F, 0x6D,\n        // `y` field from A (8 bytes).\n        0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    ];\n\n    #[rustfmt::skip]\n    let v3_hardcoded_snapshot: &[u8] = &[\n        0x00, 0x10, 0x00, 0x00, 0x00,\n        0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x72, 0x61, 0x6E, 0x64, 0x6F, 0x6D,\n        // `z` field from A (8 bytes).\n        0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18,\n    ];\n\n    let mut vm = VersionMap::new();\n    vm.new_version()\n        .set_type_version(A::type_id(), 2)\n        .set_type_version(X::type_id(), 2)\n        .set_type_version(TestState::type_id(), 2)\n        .new_version()\n        .set_type_version(X::type_id(), 3);\n\n    let mut snapshot_blob = v1_hardcoded_snapshot;\n\n    let mut restored_state = <X as Versionize>::deserialize(&mut snapshot_blob, &vm, 1).unwrap();\n    // We expect `z` and `c` fields to have the default values.\n    let mut expected_state = X {\n        x: false,\n        a_1: A {\n            a: 16u32,\n            b: Some(TestState::One(4)),\n            c: \"some_string\".to_owned(),\n        },\n        y: Box::from(2),\n        z: vec![16, 4],\n    };\n    assert_eq!(restored_state, expected_state);\n\n    snapshot_blob = v2_hardcoded_snapshot;\n\n    restored_state = <X as Versionize>::deserialize(&mut snapshot_blob, &vm, 2).unwrap();\n\n    // We expect `b` and `z` fields to have the default values.\n    expected_state = X {\n        x: false,\n        a_1: A {\n            a: 16u32,\n            b: None,\n            c: \"random\".to_owned(),\n        },\n        y: Box::from(2),\n        z: vec![16, 4],\n    };\n    assert_eq!(restored_state, expected_state);\n\n    snapshot_blob = v3_hardcoded_snapshot;\n\n    restored_state = <X as Versionize>::deserialize(&mut snapshot_blob, &vm, 3).unwrap();\n\n    // We expect `b` and `y` fields to have the default values.\n    expected_state = X {\n        x: false,\n        a_1: A {\n            a: 16u32,\n            b: None,\n            c: \"random\".to_owned(),\n        },\n        y: Box::from(4),\n        z: vec![24; 4],\n    };\n    assert_eq!(restored_state, expected_state);\n}\n\npub const SIZE: usize = 10;\n\npub mod dummy_mod {\n    pub const SIZE: usize = 20;\n}\n\n#[test]\nfn test_versionize_struct_with_array() {\n    #[derive(Debug, PartialEq, Versionize)]\n    struct TestStruct {\n        a: [u32; SIZE],\n        b: [u8; dummy_mod::SIZE],\n        c: Option<[i16; SIZE]>,\n    }\n\n    let test_struct = TestStruct {\n        a: [1; SIZE],\n        b: [2; dummy_mod::SIZE],\n        c: Some([3; SIZE]),\n    };\n\n    let mut mem = vec![0; 4096];\n    let version_map = VersionMap::new();\n\n    test_struct\n        .serialize(&mut mem.as_mut_slice(), &version_map, 1)\n        .unwrap();\n    let restored_test_struct =\n        TestStruct::deserialize(&mut mem.as_slice(), &version_map, 1).unwrap();\n\n    assert_eq!(restored_test_struct, test_struct);\n}\n\n#[derive(Clone, Debug, PartialEq, Eq, Versionize)]\npub enum DeviceStatus {\n    Inactive,\n    Active,\n    #[version(start = 2, default_fn = \"default_is_activating\")]\n    IsActivating(u32),\n}\n\nimpl Default for DeviceStatus {\n    fn default() -> Self {\n        Self::Inactive\n    }\n}\n\n#[derive(Clone, Debug, PartialEq, Eq, Versionize)]\npub enum OperationSupported {\n    Add,\n    Remove,\n    RemoveAndAdd(bool),\n    #[version(start = 2, default_fn = \"default_update\")]\n    Update(String),\n}\n\nimpl Default for OperationSupported {\n    fn default() -> Self {\n        Self::Add\n    }\n}\n\nimpl DeviceStatus {\n    fn default_is_activating(&self, target_version: u16) -> VersionizeResult<DeviceStatus> {\n        match target_version {\n            1 => Ok(DeviceStatus::Inactive),\n            i => Err(VersionizeError::Serialize(format!(\n                \"Unknown target version: {}\",\n                i\n            ))),\n        }\n    }\n}\n\nimpl OperationSupported {\n    fn default_update(&self, target_version: u16) -> VersionizeResult<OperationSupported> {\n        match target_version {\n            1 => Ok(OperationSupported::RemoveAndAdd(true)),\n            i => Err(VersionizeError::Serialize(format!(\n                \"Unknown target version: {}\",\n                i\n            ))),\n        }\n    }\n}\n\n#[derive(Clone, Debug, PartialEq, Eq, Versionize)]\npub struct Device {\n    name: String,\n    id: Wrapping<u32>,\n    #[version(start = 2, ser_fn = \"ser_is_activated\")]\n    is_activated: bool,\n    some_params: Vec<String>,\n    #[version(\n        start = 2,\n        default_fn = \"default_ops\",\n        ser_fn = \"ser_ops\",\n        de_fn = \"de_ops\"\n    )]\n    operations: Vec<OperationSupported>,\n    status: DeviceStatus,\n    #[version(\n        start = 2,\n        default_fn = \"default_queues_limit\",\n        ser_fn = \"ser_queues_limit\"\n    )]\n    no_queues_limit: usize,\n    queues: Vec<u8>,\n    features: u32,\n    #[version(start = 3, ser_fn = \"ser_extra\", de_fn = \"de_extra\")]\n    extra_features: u64,\n}\n\nimpl Device {\n    fn default_ops(_target_version: u16) -> Vec<OperationSupported> {\n        vec![OperationSupported::Add, OperationSupported::Remove]\n    }\n\n    fn default_queues_limit(_target_version: u16) -> usize {\n        2\n    }\n\n    fn ser_ops(&mut self, target_version: u16) -> VersionizeResult<()> {\n        // Fail if semantic serialization is called for a version >= 2.\n        assert!(target_version < 2);\n        self.features |= 1;\n        Ok(())\n    }\n\n    fn de_ops(&mut self, target_version: u16) -> VersionizeResult<()> {\n        // Fail if semantic deserialization is called for a version >= 2.\n        assert!(target_version < 2);\n        if self.some_params.contains(&\"active\".to_owned()) {\n            self.status = DeviceStatus::Active;\n        }\n        Ok(())\n    }\n\n    fn ser_queues_limit(&mut self, target_version: u16) -> VersionizeResult<()> {\n        // Fail if semantic serialization is called for a version >= 2.\n        assert!(target_version < 2);\n        if self.queues.len() > 2 {\n            return Err(VersionizeError::Semantic(\"Too many queues.\".to_owned()));\n        }\n        Ok(())\n    }\n\n    fn ser_is_activated(&mut self, target_version: u16) -> VersionizeResult<()> {\n        // Fail if semantic serialization is called for a version >= 2.\n        assert!(target_version < 2);\n        self.some_params.push(\"active\".to_owned());\n        self.some_params.retain(|x| x.clone() != *\"inactive\");\n        Ok(())\n    }\n\n    fn ser_extra(&mut self, target_version: u16) -> VersionizeResult<()> {\n        // Fail if semantic serialization is called for the latest version.\n        assert!(target_version < 3);\n        self.some_params.push(\"extra_features\".to_owned());\n        Ok(())\n    }\n\n    fn de_extra(&mut self, target_version: u16) -> VersionizeResult<()> {\n        // Fail if semantic deserialization is called for the latest version.\n        assert!(target_version < 3);\n        if self.queues.len() > self.no_queues_limit {\n            return Err(VersionizeError::Semantic(\"Too many queues.\".to_owned()));\n        }\n        self.features |= 1u32 << 31;\n        Ok(())\n    }\n}\n\n#[test]\nfn test_versionize_struct_with_enums() {\n    let mut vm = VersionMap::new();\n    vm.new_version()\n        .set_type_version(Device::type_id(), 2)\n        .set_type_version(DeviceStatus::type_id(), 2)\n        .new_version()\n        .set_type_version(Device::type_id(), 3)\n        .set_type_version(OperationSupported::type_id(), 2);\n\n    let mut state = Device {\n        name: \"block\".to_owned(),\n        id: Wrapping(1u32),\n        is_activated: true,\n        some_params: vec![\"inactive\".to_owned()],\n        operations: vec![\n            OperationSupported::Add,\n            OperationSupported::Update(\"random\".to_owned()),\n        ],\n        status: DeviceStatus::Inactive,\n        no_queues_limit: 3,\n        queues: vec![1u8, 2u8],\n        features: 6u32,\n        extra_features: 0u64,\n    };\n\n    let mut snapshot_mem = vec![0u8; 1024];\n\n    // Serialize as v1.\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n        .unwrap();\n    let mut restored_state =\n        <Device as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1).unwrap();\n\n    // At v1, all of the semantic functions should be called.\n    // `operations` and `no_queues_limit` will take the default values (set by `default_fn`s),\n    // `features` will be modified by `ser_ops` and `de_extra`, `status` will be changed to\n    // `Active` by `de_ops`, `is_activated` will take the default bool value, `some_params`\n    // will be also modified and the other fields will take the original values.\n    let mut expected_state = Device {\n        name: \"block\".to_owned(),\n        id: Wrapping(1u32),\n        is_activated: false,\n        some_params: vec![\"active\".to_owned(), \"extra_features\".to_owned()],\n        operations: vec![OperationSupported::Add, OperationSupported::Remove],\n        status: DeviceStatus::Active,\n        no_queues_limit: 2,\n        queues: vec![1u8, 2u8],\n        features: 0x8000_0007u32,\n        extra_features: 0u64,\n    };\n    assert_eq!(expected_state, restored_state);\n\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 2)\n        .unwrap();\n    restored_state =\n        <Device as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 2).unwrap();\n\n    // At v2, we expect that only the semantic functions from `extra_features` to be called,\n    // this means that `features` and `some_params` will take different values than the ones\n    // at v1. `status` won't be modified anymore, `is_activated` and `no_queues_limit` will\n    // take this time the original values. `operations` field will contain only the first\n    // original element, the second one will be modified by `default_update` because at v2,\n    // `Update` is not available.\n    expected_state = Device {\n        name: \"block\".to_owned(),\n        id: Wrapping(1u32),\n        is_activated: true,\n        some_params: vec![\"inactive\".to_owned(), \"extra_features\".to_owned()],\n        operations: vec![\n            OperationSupported::Add,\n            OperationSupported::RemoveAndAdd(true),\n        ],\n        status: DeviceStatus::Inactive,\n        no_queues_limit: 3,\n        queues: vec![1u8, 2u8],\n        features: 0x8000_0006u32,\n        extra_features: 0u64,\n    };\n    assert_eq!(expected_state, restored_state);\n\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 3)\n        .unwrap();\n    restored_state =\n        <Device as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 3).unwrap();\n\n    // At v3, `Update` variant is available, so it will be deserialized to its original value.\n    // We expect no semantic function to be called, so `features` and `some_params` will also\n    // take the original values.\n    expected_state = Device {\n        name: \"block\".to_owned(),\n        id: Wrapping(1u32),\n        is_activated: true,\n        some_params: vec![\"inactive\".to_owned()],\n        operations: vec![\n            OperationSupported::Add,\n            OperationSupported::Update(\"random\".to_owned()),\n        ],\n        status: DeviceStatus::Inactive,\n        no_queues_limit: 3,\n        queues: vec![1u8, 2u8],\n        features: 6u32,\n        extra_features: 0u64,\n    };\n    assert_eq!(expected_state, restored_state);\n\n    // Test semantic errors.\n    state.queues = vec![1u8, 2u8, 3u8, 4u8];\n    assert_eq!(\n        state\n            .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n            .unwrap_err(),\n        VersionizeError::Semantic(\"Too many queues.\".to_owned())\n    );\n\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 2)\n        .unwrap();\n    assert_eq!(\n        <Device as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 2).unwrap_err(),\n        VersionizeError::Semantic(\"Too many queues.\".to_owned())\n    );\n}\n\n#[derive(Clone, Debug, PartialEq, Eq, Versionize)]\npub enum State {\n    Zero,\n    One(bool),\n    #[version(start = 2, default_fn = \"default_state_two\")]\n    Two(Vec<u8>),\n    #[version(start = 2, default_fn = \"default_state_three\")]\n    Three(String),\n    #[version(start = 3, default_fn = \"default_state_four\")]\n    Four(Option<u64>),\n}\n\nimpl Default for State {\n    fn default() -> Self {\n        Self::One(false)\n    }\n}\n\nimpl State {\n    fn default_state_two(&self, target_version: u16) -> VersionizeResult<State> {\n        match target_version {\n            1 => Ok(State::One(true)),\n            i => Err(VersionizeError::Serialize(format!(\n                \"Unknown target version: {}\",\n                i\n            ))),\n        }\n    }\n\n    fn default_state_three(&self, target_version: u16) -> VersionizeResult<State> {\n        match target_version {\n            1 => Ok(State::One(false)),\n            i => Err(VersionizeError::Serialize(format!(\n                \"Unknown target version: {}\",\n                i\n            ))),\n        }\n    }\n\n    fn default_state_four(&self, target_version: u16) -> VersionizeResult<State> {\n        match target_version {\n            2 => Ok(State::Three(\"abc\".to_owned())),\n            1 => Ok(State::Zero),\n            i => Err(VersionizeError::Serialize(format!(\n                \"Unknown target version: {}\",\n                i\n            ))),\n        }\n    }\n}\n\n#[test]\nfn test_versionize_enum() {\n    let mut vm = VersionMap::new();\n    vm.new_version()\n        .set_type_version(State::type_id(), 2)\n        .new_version()\n        .set_type_version(State::type_id(), 3);\n\n    let mut snapshot_mem = vec![0u8; 1024];\n\n    // First we test that serializing and deserializing an enum variant available at the\n    // target version results in the same variant.\n    let mut state = State::One(true);\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n        .unwrap();\n    let mut restored_state =\n        <State as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1).unwrap();\n    assert_eq!(state, restored_state);\n\n    // Now we test `default_fn`s for serialization of enum variants that don't exist in\n    // previous versions.\n    state = State::Four(Some(0x1234_5678_8765_4321u64));\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n        .unwrap();\n    restored_state =\n        <State as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1).unwrap();\n    assert_eq!(restored_state, State::Zero);\n\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 2)\n        .unwrap();\n    restored_state =\n        <State as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 2).unwrap();\n    assert_eq!(restored_state, State::Three(\"abc\".to_owned()));\n\n    state = State::Three(\"some_string\".to_owned());\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n        .unwrap();\n    restored_state =\n        <State as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 2).unwrap();\n    assert_eq!(restored_state, State::One(false));\n}\n\n#[derive(Clone, Debug, PartialEq, Versionize)]\npub struct S {\n    a: f64,\n    b: i64,\n}\n\n#[derive(Clone, Debug, PartialEq, Versionize)]\npub struct Test {\n    usize_1: usize,\n    #[version(start = 2, end = 3, ser_fn = \"ser_isize\", de_fn = \"de_isize\")]\n    isize_1: isize,\n    #[version(start = 2)]\n    u8_1: u8,\n    #[version(end = 4, default_fn = \"default_vec\")]\n    vec_1: Vec<u16>,\n    #[version(start = 3)]\n    wrapping_1: Wrapping<u32>,\n    #[version(\n        end = 3,\n        default_fn = \"default_u64\",\n        ser_fn = \"ser_u64\",\n        de_fn = \"de_u64\"\n    )]\n    u64_1: u64,\n    #[version(start = 2, ser_fn = \"ser_bool\")]\n    bool_1: bool,\n    enum_1: State,\n    i8_1: i8,\n    i16_1: i16,\n    #[version(start = 3, end = 4)]\n    i32_1: i32,\n    #[version(start = 2, default_fn = \"default_box\", de_fn = \"de_box\")]\n    box_1: Box<S>,\n    #[version(start = 2, end = 3, default_fn = \"default_f32\")]\n    f32_1: f32,\n    char_1: char,\n    #[version(\n        end = 3,\n        default_fn = \"default_option\",\n        ser_fn = \"ser_option\",\n        de_fn = \"de_option\"\n    )]\n    option_1: Option<String>,\n}\n\nimpl Test {\n    fn default_vec(_target_version: u16) -> Vec<u16> {\n        vec![0x0102u16; 4]\n    }\n\n    fn default_u64(_target_version: u16) -> u64 {\n        0x0102_0102_0102_0102u64\n    }\n\n    fn default_f32(_target_version: u16) -> f32 {\n        0.5\n    }\n\n    fn default_box(_target_version: u16) -> Box<S> {\n        Box::new(S { a: 1.5, b: 2 })\n    }\n\n    fn default_option(_target_version: u16) -> Option<String> {\n        Some(\"something\".to_owned())\n    }\n\n    fn ser_isize(&mut self, target_version: u16) -> VersionizeResult<()> {\n        assert_ne!(target_version, 2);\n        self.vec_1.push(0x0304u16);\n        if self.i8_1 == -1 {\n            return Err(VersionizeError::Semantic(\n                \"Unexpected value for `i8` field.\".to_owned(),\n            ));\n        }\n        Ok(())\n    }\n    fn ser_u64(&mut self, target_version: u16) -> VersionizeResult<()> {\n        assert!(target_version >= 3);\n        self.vec_1.pop();\n        if self.u8_1 == 4 {\n            self.bool_1 = false;\n        }\n        Ok(())\n    }\n\n    fn ser_bool(&mut self, target_version: u16) -> VersionizeResult<()> {\n        assert!(target_version < 2);\n        self.vec_1.push(0x0506u16);\n        self.vec_1.push(0x0708u16);\n        Ok(())\n    }\n\n    fn ser_option(&mut self, target_version: u16) -> VersionizeResult<()> {\n        assert!(target_version >= 3);\n        self.u8_1 += 2;\n        if self.vec_1.len() == 10 {\n            return Err(VersionizeError::Semantic(\"Vec is full.\".to_owned()));\n        }\n        Ok(())\n    }\n\n    fn de_isize(&mut self, target_version: u16) -> VersionizeResult<()> {\n        assert_ne!(target_version, 2);\n        self.u8_1 += 3;\n        Ok(())\n    }\n\n    fn de_u64(&mut self, target_version: u16) -> VersionizeResult<()> {\n        assert!(target_version >= 3);\n        self.vec_1.push(0x0101u16);\n        Ok(())\n    }\n\n    fn de_box(&mut self, target_version: u16) -> VersionizeResult<()> {\n        assert!(target_version < 2);\n        self.option_1 = Some(\"box_change\".to_owned());\n        if self.vec_1.len() == 3 {\n            return Err(VersionizeError::Semantic(\n                \"Vec len is too small.\".to_owned(),\n            ));\n        }\n        Ok(())\n    }\n\n    fn de_option(&mut self, target_version: u16) -> VersionizeResult<()> {\n        assert!(target_version >= 3);\n        self.enum_1 = State::Two(vec![1; 4]);\n        Ok(())\n    }\n}\n\n#[test]\nfn test_versionize_struct() {\n    let mut vm = VersionMap::new();\n    vm.new_version()\n        .set_type_version(Test::type_id(), 2)\n        .set_type_version(State::type_id(), 2)\n        .new_version()\n        .set_type_version(Test::type_id(), 3)\n        .set_type_version(State::type_id(), 3);\n\n    let mut state = Test {\n        usize_1: 0x0102_0304_0506_0708usize,\n        isize_1: -0x1122_3344_5566_7788isize,\n        u8_1: 4,\n        vec_1: vec![0x1122u16; 5],\n        wrapping_1: Wrapping(4u32),\n        u64_1: 0x0102_0304_0506_0708u64,\n        bool_1: false,\n        enum_1: State::Four(Some(0x0102_0304_0506_0708u64)),\n        i8_1: 8,\n        i16_1: -12,\n        i32_1: -0x1234_5678,\n        box_1: Box::new(S { a: 4.5, b: 4 }),\n        f32_1: 1.25,\n        char_1: 'c',\n        option_1: None,\n    };\n\n    let mut snapshot_mem = vec![0u8; 1024];\n\n    // Serialize as v1.\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n        .unwrap();\n    let mut restored_state =\n        <Test as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1).unwrap();\n\n    let mut expected_state = Test {\n        // usize field exists at all versions, will take the original value.\n        usize_1: 0x0102_0304_0506_0708usize,\n        // isize field will take the default value as it is not available at v1.\n        isize_1: 0isize,\n        // u8 field doesn't exist at v1, it wll take the default value and then it will be\n        // modified by `de_isize`: 0 + 3 = 3.\n        u8_1: 3,\n        // Vec field will be modified by the semantic fns of the fields that don't exist\n        // at v1: `isize_1`, `bool_1`; there will be 3 new elements added in it.\n        vec_1: vec![\n            0x1122u16, 0x1122u16, 0x1122u16, 0x1122u16, 0x1122u16, 0x0304u16, 0x0506u16, 0x0708u16,\n        ],\n        // We expect here to have the default value.\n        wrapping_1: Wrapping(0u32),\n        // We expect here to have the original value.\n        u64_1: 0x0102_0304_0506_0708u64,\n        // We expect here to have the default value.\n        bool_1: false,\n        // This will take the default value for state `Four` and v1.\n        enum_1: State::Zero,\n        // i8, i16 fields take the original values.\n        i8_1: 8,\n        i16_1: -12,\n        // i32 field takes the default value.\n        i32_1: 0,\n        // Box and f32 fields will take the default values set by `default_fn`s.\n        box_1: Box::new(S { a: 1.5, b: 2 }),\n        f32_1: 0.5,\n        // We expect this field to take the original value.\n        char_1: 'c',\n        // This field will be modified by `de_box`.\n        option_1: Some(\"box_change\".to_owned()),\n    };\n    assert_eq!(expected_state, restored_state);\n\n    // Serialize as v2.\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 2)\n        .unwrap();\n    restored_state =\n        <Test as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 2).unwrap();\n\n    // At v2 isize, u8, bool, box and f32 fields will be available, their semantic fns won't\n    // be called.\n    expected_state = Test {\n        usize_1: 0x0102_0304_0506_0708usize,\n        isize_1: -0x1122_3344_5566_7788isize,\n        u8_1: 4,\n        // This should take the original value this time.\n        vec_1: vec![0x1122u16, 0x1122u16, 0x1122u16, 0x1122u16, 0x1122u16],\n        wrapping_1: Wrapping(0u32),\n        u64_1: 0x0102_0304_0506_0708u64,\n        bool_1: false,\n        // This will take the default value for state `Four` and v2.\n        enum_1: State::Three(\"abc\".to_owned()),\n        i8_1: 8,\n        i16_1: -12,\n        i32_1: 0,\n        box_1: Box::new(S { a: 4.5, b: 4 }),\n        f32_1: 1.25,\n        char_1: 'c',\n        option_1: None,\n    };\n    assert_eq!(expected_state, restored_state);\n\n    // Serialize as v3.\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 3)\n        .unwrap();\n    restored_state =\n        <Test as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 3).unwrap();\n\n    expected_state = Test {\n        usize_1: 0x0102_0304_0506_0708usize,\n        isize_1: 0isize,\n        // This field will be modified by `de_isize` and `ser_option`: 4 + 2 + 3 = 9.\n        u8_1: 9,\n        // Vec field will be modified by `ser_isize` (add one elem), `ser_u64` (remove one elem)\n        // and `de_64` (add one elem).\n        vec_1: vec![\n            0x1122u16, 0x1122u16, 0x1122u16, 0x1122u16, 0x1122u16, 0x0101u16,\n        ],\n        wrapping_1: Wrapping(4u32),\n        u64_1: 0x0102_0102_0102_0102u64,\n        bool_1: false,\n        enum_1: State::Two(vec![1; 4]),\n        i8_1: 8,\n        i16_1: -12,\n        i32_1: -0x1234_5678,\n        box_1: Box::new(S { a: 4.5, b: 4 }),\n        f32_1: 0.5,\n        char_1: 'c',\n        // We expect this field to take the default value set by its `default_fn`.\n        option_1: Some(\"something\".to_owned()),\n    };\n    assert_eq!(expected_state, restored_state);\n\n    // Test semantic errors.\n    state.vec_1 = Vec::new();\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n        .unwrap();\n    assert_eq!(\n        <Test as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1).unwrap_err(),\n        VersionizeError::Semantic(\"Vec len is too small.\".to_owned())\n    );\n\n    state.vec_1 = vec![0x1122u16; 10];\n    assert_eq!(\n        state\n            .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 3)\n            .unwrap_err(),\n        VersionizeError::Semantic(\"Vec is full.\".to_owned())\n    );\n\n    state.i8_1 = -1;\n    assert_eq!(\n        state\n            .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n            .unwrap_err(),\n        VersionizeError::Semantic(\"Unexpected value for `i8` field.\".to_owned())\n    );\n    state.i8_1 = 0;\n\n    // Test serialize and deserialize errors.\n    snapshot_mem = vec![0u8; 8];\n    // Serializing `state` will fail due to the small size of `snapshot_mem`.\n    assert_eq!(\n        state\n            .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n            .unwrap_err(),\n        VersionizeError::Serialize(\n            \"Io(Error { kind: WriteZero, message: \\\"failed to write whole buffer\\\" })\".to_owned()\n        )\n    );\n    snapshot_mem = vec![0u8; 256];\n\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n        .unwrap();\n    snapshot_mem.truncate(10);\n    // Deserialization will fail if we don't use the whole `snapshot_mem` resulted from\n    // serialization.\n    assert_eq!(\n        <Test as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1).unwrap_err(),\n        VersionizeError::Deserialize(\n            \"Io(Error { kind: UnexpectedEof, message: \\\"failed to fill whole buffer\\\" })\"\n                .to_owned()\n        )\n    );\n}\n\n#[repr(C)]\n#[derive(Debug, Default, Versionize)]\nstruct Message {\n    pub len: u32,\n    #[version(end = 4)]\n    pub padding: u32,\n    pub value: u32,\n    #[version(start = 2, default_fn = \"default_extra_value\")]\n    pub extra_value: u16,\n    #[version(start = 3, end = 4, default_fn = \"default_status\")]\n    pub status: Wrapping<bool>,\n    pub entries: __IncompleteArrayField<u32>,\n}\n\nimpl Message {\n    fn default_extra_value(_source_version: u16) -> u16 {\n        4\n    }\n\n    fn default_status(_source_version: u16) -> Wrapping<bool> {\n        Wrapping(false)\n    }\n}\n\n#[repr(C)]\n#[derive(Debug, Default, Versionize)]\nstruct Message2 {\n    pub len: u32,\n    #[version(end = 4)]\n    pub padding: u32,\n    pub value: u32,\n    #[version(start = 2, default_fn = \"default_extra_value\")]\n    pub extra_value: u16,\n    #[version(start = 3, end = 4, default_fn = \"default_status\")]\n    pub status: Wrapping<bool>,\n    pub entries: __IncompleteArrayField<u32>,\n}\n\nimpl Message2 {\n    fn default_extra_value(_source_version: u16) -> u16 {\n        4\n    }\n\n    fn default_status(_source_version: u16) -> Wrapping<bool> {\n        Wrapping(false)\n    }\n}\n\ngenerate_fam_struct_impl!(Message, u32, entries, u32, len, 100);\n// Duplicated structure used but with max_len 1 - for negative testing.\ngenerate_fam_struct_impl!(Message2, u32, entries, u32, len, 1);\n\n#[repr(C)]\n#[derive(Default)]\npub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);\n\nimpl<T> __IncompleteArrayField<T> {\n    #[inline]\n    pub fn new() -> Self {\n        __IncompleteArrayField(::std::marker::PhantomData, [])\n    }\n    #[inline]\n    pub unsafe fn as_ptr(&self) -> *const T {\n        self as *const __IncompleteArrayField<T> as *const T\n    }\n    #[inline]\n    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {\n        self as *mut __IncompleteArrayField<T> as *mut T\n    }\n    #[inline]\n    pub unsafe fn as_slice(&self, len: usize) -> &[T] {\n        ::std::slice::from_raw_parts(self.as_ptr(), len)\n    }\n    #[inline]\n    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {\n        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)\n    }\n}\n\nimpl<T> Debug for __IncompleteArrayField<T> {\n    fn fmt(&self, fmt: &mut Formatter<'_>) -> Result {\n        fmt.write_str(\"__IncompleteArrayField\")\n    }\n}\n\nimpl<T> ::std::clone::Clone for __IncompleteArrayField<T> {\n    #[inline]\n    fn clone(&self) -> Self {\n        Self::new()\n    }\n}\n\nimpl<T> Versionize for __IncompleteArrayField<T> {\n    #[inline]\n    fn serialize<W: std::io::Write>(\n        &self,\n        _writer: &mut W,\n        _version_map: &VersionMap,\n        _app_version: u16,\n    ) -> VersionizeResult<()> {\n        Ok(())\n    }\n\n    #[inline]\n    fn deserialize<R: std::io::Read>(\n        _reader: &mut R,\n        _version_map: &VersionMap,\n        _app_version: u16,\n    ) -> VersionizeResult<Self> {\n        Ok(Self::new())\n    }\n\n    // Not used.\n    fn version() -> u16 {\n        1\n    }\n}\n\ntype MessageFamStructWrapper = FamStructWrapper<Message>;\ntype Message2FamStructWrapper = FamStructWrapper<Message2>;\n\n#[test]\nfn test_deserialize_famstructwrapper_invalid_len() {\n    let mut vm = VersionMap::new();\n    vm.new_version()\n        .set_type_version(Message::type_id(), 2)\n        .new_version()\n        .set_type_version(Message::type_id(), 3)\n        .new_version()\n        .set_type_version(Message::type_id(), 4);\n\n    // Create FamStructWrapper with len 2\n    let state = MessageFamStructWrapper::new(0).unwrap();\n    let mut buffer = [0; 256];\n\n    state.serialize(&mut buffer.as_mut_slice(), &vm, 2).unwrap();\n\n    // the `len` field of the header is the first serialized field.\n    // Let's corrupt it by making it bigger than the actual number of serialized elements\n    buffer[0] = 255;\n\n    assert_eq!(\n        MessageFamStructWrapper::deserialize(&mut buffer.as_slice(), &vm, 2).unwrap_err(),\n        VersionizeError::Deserialize(\"Mismatch between length of FAM specified in FamStruct header (255) and actual size of FAM (0)\".to_string())\n    );\n}\n\n#[test]\nfn test_versionize_famstructwrapper() {\n    let mut vm = VersionMap::new();\n    vm.new_version()\n        .set_type_version(Message::type_id(), 2)\n        .new_version()\n        .set_type_version(Message::type_id(), 3)\n        .new_version()\n        .set_type_version(Message::type_id(), 4);\n\n    let mut state = MessageFamStructWrapper::new(0).unwrap();\n    state.as_mut_fam_struct().padding = 8;\n    state.as_mut_fam_struct().extra_value = 16;\n    state.as_mut_fam_struct().status = Wrapping(true);\n\n    state.push(1).unwrap();\n    state.push(2).unwrap();\n\n    let mut snapshot_mem = vec![0u8; 256];\n\n    // Serialize as v1.\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n        .unwrap();\n    let mut restored_state =\n        <MessageFamStructWrapper as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1)\n            .unwrap();\n\n    let mut original_values = state.as_slice();\n    let mut restored_values = restored_state.as_slice();\n    assert_eq!(original_values, restored_values);\n    assert_eq!(\n        restored_values.len(),\n        state.as_fam_struct_ref().len as usize\n    );\n\n    assert_eq!(\n        state.as_fam_struct_ref().padding,\n        restored_state.as_fam_struct_ref().padding\n    );\n    // `extra_value` and `status` should take the default values set by their corresponding `default_fn`s.\n    assert_eq!(4, restored_state.as_fam_struct_ref().extra_value);\n    assert_eq!(Wrapping(false), restored_state.as_fam_struct_ref().status);\n\n    // Serialize as v2.\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 2)\n        .unwrap();\n    restored_state =\n        <MessageFamStructWrapper as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 2)\n            .unwrap();\n\n    original_values = state.as_slice();\n    restored_values = restored_state.as_slice();\n    assert_eq!(original_values, restored_values);\n\n    assert_eq!(\n        state.as_fam_struct_ref().padding,\n        restored_state.as_fam_struct_ref().padding\n    );\n    // `extra_value` is available at v2, so it will take its original value.\n    assert_eq!(\n        state.as_fam_struct_ref().extra_value,\n        restored_state.as_fam_struct_ref().extra_value\n    );\n    assert_eq!(Wrapping(false), restored_state.as_fam_struct_ref().status);\n\n    // Serialize as v3.\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 3)\n        .unwrap();\n    restored_state =\n        <MessageFamStructWrapper as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 3)\n            .unwrap();\n\n    assert_eq!(\n        state.as_fam_struct_ref().padding,\n        restored_state.as_fam_struct_ref().padding\n    );\n    assert_eq!(\n        state.as_fam_struct_ref().extra_value,\n        restored_state.as_fam_struct_ref().extra_value\n    );\n    // At v3, `status` field exists, so it will take its original value.\n    assert_eq!(Wrapping(true), restored_state.as_fam_struct_ref().status);\n\n    // Serialize as v4.\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 4)\n        .unwrap();\n    restored_state =\n        <MessageFamStructWrapper as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 4)\n            .unwrap();\n\n    // At v4, `padding` field will take the default u32 value.\n    assert_eq!(0, restored_state.as_fam_struct_ref().padding);\n    assert_eq!(\n        state.as_fam_struct_ref().extra_value,\n        restored_state.as_fam_struct_ref().extra_value\n    );\n    // `status` is not available anymore, so it will take the default value.\n    assert_eq!(Wrapping(false), restored_state.as_fam_struct_ref().status);\n\n    snapshot_mem = vec![0u8; 16];\n\n    assert_eq!(\n        state\n            .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n            .unwrap_err(),\n        VersionizeError::Serialize(\n            \"Io(Error { kind: WriteZero, message: \\\"failed to write whole buffer\\\" })\".to_owned()\n        )\n    );\n}\n\n#[derive(Versionize)]\npub struct FamStructTest {\n    some_u8: u8,\n    message_box: Box<MessageFamStructWrapper>,\n    #[version(start = 2, default_fn = \"default_option\", de_fn = \"de_option\")]\n    some_option: Option<S>,\n    #[version(start = 3)]\n    some_string: String,\n    #[version(end = 3, default_fn = \"default_message\", de_fn = \"de_message\")]\n    messages: Vec<MessageFamStructWrapper>,\n}\n\nimpl FamStructTest {\n    fn default_message(_target_version: u16) -> Vec<MessageFamStructWrapper> {\n        let mut f = MessageFamStructWrapper::new(0).unwrap();\n        f.as_mut_fam_struct().padding = 1;\n        f.as_mut_fam_struct().extra_value = 2;\n\n        f.push(10).unwrap();\n        f.push(20).unwrap();\n\n        vec![f]\n    }\n\n    fn default_option(_target_version: u16) -> Option<S> {\n        Some(S { a: 0.5, b: 0 })\n    }\n\n    fn de_message(&mut self, target_version: u16) -> VersionizeResult<()> {\n        // Fail if semantic deserialization is called for v2.\n        assert_ne!(target_version, 2);\n        self.some_option = None;\n        self.some_string = \"some_new_string\".to_owned();\n        Ok(())\n    }\n\n    fn de_option(&mut self, target_version: u16) -> VersionizeResult<()> {\n        // Fail if semantic deserialization is called for a version >= 2.\n        assert!(target_version < 2);\n\n        let mut f = MessageFamStructWrapper::new(0).unwrap();\n        f.as_mut_fam_struct().padding = 3;\n        f.as_mut_fam_struct().extra_value = 4;\n\n        f.push(10).unwrap();\n        f.push(20).unwrap();\n\n        self.messages.push(f);\n        Ok(())\n    }\n}\n\n#[test]\nfn test_versionize_struct_with_famstructs() {\n    let mut vm = VersionMap::new();\n    vm.new_version()\n        .set_type_version(FamStructTest::type_id(), 2)\n        .set_type_version(Message::type_id(), 2)\n        .new_version()\n        .set_type_version(FamStructTest::type_id(), 3)\n        .set_type_version(Message::type_id(), 3);\n\n    let mut snapshot_mem = vec![0u8; 1024];\n\n    let mut f = MessageFamStructWrapper::new(0).unwrap();\n    f.as_mut_fam_struct().padding = 5;\n    f.as_mut_fam_struct().extra_value = 6;\n    f.push(10).unwrap();\n\n    let mut f2 = MessageFamStructWrapper::new(0).unwrap();\n    f2.as_mut_fam_struct().padding = 7;\n    f2.as_mut_fam_struct().extra_value = 8;\n    f2.push(20).unwrap();\n\n    let state = FamStructTest {\n        some_u8: 1,\n        messages: vec![f],\n        some_string: \"some_string\".to_owned(),\n        message_box: Box::new(f2),\n        some_option: None,\n    };\n\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n        .unwrap();\n    let mut restored_state =\n        <FamStructTest as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1).unwrap();\n\n    // At version 1, we expect `de_option` and `de_message` to be called.\n    // `some_string` and `some_option` will take the default values.\n    assert_eq!(restored_state.some_string, String::default());\n    assert_eq!(restored_state.some_option, Some(S { a: 0.5, b: 0 }));\n    let messages = restored_state.messages;\n\n    // We expect to have 2 elements in the messages Vec (the one with which it was initialized and\n    // the one inserted by `de_option`).\n    assert_eq!(messages.len(), 2);\n    for message in messages.iter() {\n        assert_eq!(message.as_fam_struct_ref().extra_value, 4);\n        assert_eq!(message.as_fam_struct_ref().status, Wrapping(false));\n    }\n    assert_eq!(messages[0].as_fam_struct_ref().padding, 5);\n    assert_eq!(messages[1].as_fam_struct_ref().padding, 3);\n\n    // Serialize as v2.\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 2)\n        .unwrap();\n    restored_state =\n        <FamStructTest as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 2).unwrap();\n\n    assert_eq!(restored_state.some_string, String::default());\n    // `some_option` is available at v2, so it will take the original value.\n    assert_eq!(restored_state.some_option, None);\n    let messages = restored_state.messages;\n    // We expect to have only one element in `messages` as `de_option` shouldn't be called\n    // this time.\n    assert_eq!(messages.len(), 1);\n\n    // Serialize as v3.\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 3)\n        .unwrap();\n    restored_state =\n        <FamStructTest as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 3).unwrap();\n\n    // `some_string` is also available at v3.\n    assert_eq!(restored_state.some_string, \"some_new_string\".to_owned());\n    assert_eq!(restored_state.some_option, None);\n    let messages = restored_state.messages;\n    // `messages` field is not available anymore at v3, it will take the default value,\n    // set by the corresponding `default_fn`.\n    assert_eq!(messages.len(), 1);\n    assert_eq!(messages[0].as_fam_struct_ref().padding, 1);\n}\n\n#[derive(Clone, Versionize)]\npub struct SomeStruct {\n    message: MessageFamStructWrapper,\n    #[version(start = 2, ser_fn = \"ser_u16\")]\n    some_u16: u16,\n}\n\nimpl SomeStruct {\n    fn ser_u16(&mut self, target_version: u16) -> VersionizeResult<()> {\n        // Fail if semantic serialization is called for the latest version.\n        assert!(target_version < 2);\n        self.message.as_mut_fam_struct().padding += 2;\n\n        Ok(())\n    }\n}\n\n#[derive(Clone, Versionize)]\npub struct SomeStruct2 {\n    message: Message2FamStructWrapper,\n    #[version(start = 2, ser_fn = \"ser_u16\")]\n    some_u16: u16,\n}\n\nimpl SomeStruct2 {\n    fn ser_u16(&mut self, target_version: u16) -> VersionizeResult<()> {\n        // Fail if semantic serialization is called for the latest version.\n        assert!(target_version < 2);\n        self.message.as_mut_fam_struct().padding += 2;\n\n        Ok(())\n    }\n}\n\n// `Clone` issue fixed: https://github.com/rust-vmm/vmm-sys-util/issues/85.\n// We are keeping this as regression test.\n#[test]\nfn test_famstructwrapper_clone() {\n    // Test that having a `FamStructWrapper<T>` in a structure that implements\n    // Clone will result in keeping with their original values, only the number\n    // of entries and the entries array when serializing.\n    let mut vm = VersionMap::new();\n    vm.new_version().set_type_version(SomeStruct::type_id(), 2);\n\n    let mut f = MessageFamStructWrapper::new(0).unwrap();\n    f.as_mut_fam_struct().padding = 8;\n\n    f.push(1).unwrap();\n    f.push(2).unwrap();\n\n    let state = SomeStruct {\n        message: f,\n        some_u16: 2,\n    };\n\n    let mut snapshot_mem = vec![0u8; 128];\n\n    // Serialize as v1.\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 1)\n        .unwrap();\n    let mut restored_state =\n        <SomeStruct as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1).unwrap();\n\n    // Negative scenario - FamStruct versionize impl fails due to SizeLimitExceeded.\n    assert!(\n        <SomeStruct2 as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 1).is_err()\n    );\n\n    let original_values = state.message.as_slice();\n    let restored_values = restored_state.message.as_slice();\n\n    assert_ne!(\n        state.message.as_fam_struct_ref().padding,\n        restored_state.message.as_fam_struct_ref().padding\n    );\n    assert_eq!(original_values, restored_values);\n    // `padding` field will have its value serialized (8), and then it will be incremented with 2\n    // by `ser_u16`.\n    assert_eq!(10, restored_state.message.as_fam_struct_ref().padding);\n\n    // Serialize as v2.\n    state\n        .serialize(&mut snapshot_mem.as_mut_slice(), &vm, 2)\n        .unwrap();\n    restored_state =\n        <SomeStruct as Versionize>::deserialize(&mut snapshot_mem.as_slice(), &vm, 2).unwrap();\n\n    // Padding is correctly preserved and ser_u16 is not called - it would fail due to ser_u16\n    // assert anyways, but we double that check here.\n    assert_eq!(\n        state.message.as_fam_struct_ref().padding,\n        restored_state.message.as_fam_struct_ref().padding\n    );\n    // `padding` field will have its value preserved (8). `ser_u16` won't be called at v2.\n    assert_eq!(8, restored_state.message.as_fam_struct_ref().padding);\n}\n"], "filenames": ["src/primitives.rs", "tests/test.rs"], "buggy_code_start_loc": [371, 1326], "buggy_code_end_loc": [371, 1326], "fixing_code_start_loc": [372, 1327], "fixing_code_end_loc": [384, 1353], "type": "CWE-125", "message": "Versionize is a framework for version tolerant serializion/deserialization of Rust data structures, designed for usecases that need fast deserialization times and minimal size overhead. An issue was discovered in the \u2018Versionize::deserialize\u2019 implementation provided by the \u2018versionize\u2019 crate for \u2018vmm_sys_utils::fam::FamStructWrapper', which can lead to out of bounds memory accesses. The impact started with version 0.1.1. The issue was corrected in version 0.1.10 by inserting a check that verifies, for any deserialized header, the lengths of compared flexible arrays are equal and aborting deserialization otherwise.", "other": {"cve": {"id": "CVE-2023-28448", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-24T20:15:15.613", "lastModified": "2023-03-31T14:23:30.577", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Versionize is a framework for version tolerant serializion/deserialization of Rust data structures, designed for usecases that need fast deserialization times and minimal size overhead. An issue was discovered in the \u2018Versionize::deserialize\u2019 implementation provided by the \u2018versionize\u2019 crate for \u2018vmm_sys_utils::fam::FamStructWrapper', which can lead to out of bounds memory accesses. The impact started with version 0.1.1. The issue was corrected in version 0.1.10 by inserting a check that verifies, for any deserialized header, the lengths of compared flexible arrays are equal and aborting deserialization otherwise."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:C/C:N/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.7, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 2.7}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:versionize_project:versionize:*:*:*:*:*:rust:*:*", "versionStartIncluding": "0.1.1", "versionEndExcluding": "0.1.10", "matchCriteriaId": "16F37684-4478-44B1-A067-78576CCD0E71"}]}]}], "references": [{"url": "https://github.com/firecracker-microvm/versionize/commit/a57a051ba006cfa3b41a0532f484df759e008d47", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/firecracker-microvm/versionize/pull/53", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/firecracker-microvm/versionize/security/advisories/GHSA-8vxc-r5wp-vgvc", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/firecracker-microvm/versionize/commit/a57a051ba006cfa3b41a0532f484df759e008d47"}}