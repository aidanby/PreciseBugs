{"buggy_code": ["/* Request a key from userspace\n *\n * Copyright (C) 2004-2007 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n *\n * See Documentation/security/keys/request-key.rst\n */\n\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kmod.h>\n#include <linux/err.h>\n#include <linux/keyctl.h>\n#include <linux/slab.h>\n#include \"internal.h\"\n\n#define key_negative_timeout\t60\t/* default timeout on a negative key's existence */\n\n/**\n * complete_request_key - Complete the construction of a key.\n * @cons: The key construction record.\n * @error: The success or failute of the construction.\n *\n * Complete the attempt to construct a key.  The key will be negated\n * if an error is indicated.  The authorisation key will be revoked\n * unconditionally.\n */\nvoid complete_request_key(struct key_construction *cons, int error)\n{\n\tkenter(\"{%d,%d},%d\", cons->key->serial, cons->authkey->serial, error);\n\n\tif (error < 0)\n\t\tkey_negate_and_link(cons->key, key_negative_timeout, NULL,\n\t\t\t\t    cons->authkey);\n\telse\n\t\tkey_revoke(cons->authkey);\n\n\tkey_put(cons->key);\n\tkey_put(cons->authkey);\n\tkfree(cons);\n}\nEXPORT_SYMBOL(complete_request_key);\n\n/*\n * Initialise a usermode helper that is going to have a specific session\n * keyring.\n *\n * This is called in context of freshly forked kthread before kernel_execve(),\n * so we can simply install the desired session_keyring at this point.\n */\nstatic int umh_keys_init(struct subprocess_info *info, struct cred *cred)\n{\n\tstruct key *keyring = info->data;\n\n\treturn install_session_keyring_to_cred(cred, keyring);\n}\n\n/*\n * Clean up a usermode helper with session keyring.\n */\nstatic void umh_keys_cleanup(struct subprocess_info *info)\n{\n\tstruct key *keyring = info->data;\n\tkey_put(keyring);\n}\n\n/*\n * Call a usermode helper with a specific session keyring.\n */\nstatic int call_usermodehelper_keys(const char *path, char **argv, char **envp,\n\t\t\t\t\tstruct key *session_keyring, int wait)\n{\n\tstruct subprocess_info *info;\n\n\tinfo = call_usermodehelper_setup(path, argv, envp, GFP_KERNEL,\n\t\t\t\t\t  umh_keys_init, umh_keys_cleanup,\n\t\t\t\t\t  session_keyring);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tkey_get(session_keyring);\n\treturn call_usermodehelper_exec(info, wait);\n}\n\n/*\n * Request userspace finish the construction of a key\n * - execute \"/sbin/request-key <op> <key> <uid> <gid> <keyring> <keyring> <keyring>\"\n */\nstatic int call_sbin_request_key(struct key_construction *cons,\n\t\t\t\t const char *op,\n\t\t\t\t void *aux)\n{\n\tstatic char const request_key[] = \"/sbin/request-key\";\n\tconst struct cred *cred = current_cred();\n\tkey_serial_t prkey, sskey;\n\tstruct key *key = cons->key, *authkey = cons->authkey, *keyring,\n\t\t*session;\n\tchar *argv[9], *envp[3], uid_str[12], gid_str[12];\n\tchar key_str[12], keyring_str[3][12];\n\tchar desc[20];\n\tint ret, i;\n\n\tkenter(\"{%d},{%d},%s\", key->serial, authkey->serial, op);\n\n\tret = install_user_keyrings();\n\tif (ret < 0)\n\t\tgoto error_alloc;\n\n\t/* allocate a new session keyring */\n\tsprintf(desc, \"_req.%u\", key->serial);\n\n\tcred = get_current_cred();\n\tkeyring = keyring_alloc(desc, cred->fsuid, cred->fsgid, cred,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN, NULL, NULL);\n\tput_cred(cred);\n\tif (IS_ERR(keyring)) {\n\t\tret = PTR_ERR(keyring);\n\t\tgoto error_alloc;\n\t}\n\n\t/* attach the auth key to the session keyring */\n\tret = key_link(keyring, authkey);\n\tif (ret < 0)\n\t\tgoto error_link;\n\n\t/* record the UID and GID */\n\tsprintf(uid_str, \"%d\", from_kuid(&init_user_ns, cred->fsuid));\n\tsprintf(gid_str, \"%d\", from_kgid(&init_user_ns, cred->fsgid));\n\n\t/* we say which key is under construction */\n\tsprintf(key_str, \"%d\", key->serial);\n\n\t/* we specify the process's default keyrings */\n\tsprintf(keyring_str[0], \"%d\",\n\t\tcred->thread_keyring ? cred->thread_keyring->serial : 0);\n\n\tprkey = 0;\n\tif (cred->process_keyring)\n\t\tprkey = cred->process_keyring->serial;\n\tsprintf(keyring_str[1], \"%d\", prkey);\n\n\trcu_read_lock();\n\tsession = rcu_dereference(cred->session_keyring);\n\tif (!session)\n\t\tsession = cred->user->session_keyring;\n\tsskey = session->serial;\n\trcu_read_unlock();\n\n\tsprintf(keyring_str[2], \"%d\", sskey);\n\n\t/* set up a minimal environment */\n\ti = 0;\n\tenvp[i++] = \"HOME=/\";\n\tenvp[i++] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[i] = NULL;\n\n\t/* set up the argument list */\n\ti = 0;\n\targv[i++] = (char *)request_key;\n\targv[i++] = (char *) op;\n\targv[i++] = key_str;\n\targv[i++] = uid_str;\n\targv[i++] = gid_str;\n\targv[i++] = keyring_str[0];\n\targv[i++] = keyring_str[1];\n\targv[i++] = keyring_str[2];\n\targv[i] = NULL;\n\n\t/* do it */\n\tret = call_usermodehelper_keys(request_key, argv, envp, keyring,\n\t\t\t\t       UMH_WAIT_PROC);\n\tkdebug(\"usermode -> 0x%x\", ret);\n\tif (ret >= 0) {\n\t\t/* ret is the exit/wait code */\n\t\tif (test_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags) ||\n\t\t    key_validate(key) < 0)\n\t\t\tret = -ENOKEY;\n\t\telse\n\t\t\t/* ignore any errors from userspace if the key was\n\t\t\t * instantiated */\n\t\t\tret = 0;\n\t}\n\nerror_link:\n\tkey_put(keyring);\n\nerror_alloc:\n\tcomplete_request_key(cons, ret);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n\n/*\n * Call out to userspace for key construction.\n *\n * Program failure is ignored in favour of key status.\n */\nstatic int construct_key(struct key *key, const void *callout_info,\n\t\t\t size_t callout_len, void *aux,\n\t\t\t struct key *dest_keyring)\n{\n\tstruct key_construction *cons;\n\trequest_key_actor_t actor;\n\tstruct key *authkey;\n\tint ret;\n\n\tkenter(\"%d,%p,%zu,%p\", key->serial, callout_info, callout_len, aux);\n\n\tcons = kmalloc(sizeof(*cons), GFP_KERNEL);\n\tif (!cons)\n\t\treturn -ENOMEM;\n\n\t/* allocate an authorisation key */\n\tauthkey = request_key_auth_new(key, callout_info, callout_len,\n\t\t\t\t       dest_keyring);\n\tif (IS_ERR(authkey)) {\n\t\tkfree(cons);\n\t\tret = PTR_ERR(authkey);\n\t\tauthkey = NULL;\n\t} else {\n\t\tcons->authkey = key_get(authkey);\n\t\tcons->key = key_get(key);\n\n\t\t/* make the call */\n\t\tactor = call_sbin_request_key;\n\t\tif (key->type->request_key)\n\t\t\tactor = key->type->request_key;\n\n\t\tret = actor(cons, \"create\", aux);\n\n\t\t/* check that the actor called complete_request_key() prior to\n\t\t * returning an error */\n\t\tWARN_ON(ret < 0 &&\n\t\t\t!test_bit(KEY_FLAG_REVOKED, &authkey->flags));\n\t\tkey_put(authkey);\n\t}\n\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n\n/*\n * Get the appropriate destination keyring for the request.\n *\n * The keyring selected is returned with an extra reference upon it which the\n * caller must release.\n */\nstatic void construct_get_dest_keyring(struct key **_dest_keyring)\n{\n\tstruct request_key_auth *rka;\n\tconst struct cred *cred = current_cred();\n\tstruct key *dest_keyring = *_dest_keyring, *authkey;\n\n\tkenter(\"%p\", dest_keyring);\n\n\t/* find the appropriate keyring */\n\tif (dest_keyring) {\n\t\t/* the caller supplied one */\n\t\tkey_get(dest_keyring);\n\t} else {\n\t\t/* use a default keyring; falling through the cases until we\n\t\t * find one that we actually have */\n\t\tswitch (cred->jit_keyring) {\n\t\tcase KEY_REQKEY_DEFL_DEFAULT:\n\t\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\t\tif (cred->request_key_auth) {\n\t\t\t\tauthkey = cred->request_key_auth;\n\t\t\t\tdown_read(&authkey->sem);\n\t\t\t\trka = authkey->payload.data[0];\n\t\t\t\tif (!test_bit(KEY_FLAG_REVOKED,\n\t\t\t\t\t      &authkey->flags))\n\t\t\t\t\tdest_keyring =\n\t\t\t\t\t\tkey_get(rka->dest_keyring);\n\t\t\t\tup_read(&authkey->sem);\n\t\t\t\tif (dest_keyring)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\t\tdest_keyring = key_get(cred->thread_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\t\tdest_keyring = key_get(cred->process_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\t\t\trcu_read_lock();\n\t\t\tdest_keyring = key_get(\n\t\t\t\trcu_dereference(cred->session_keyring));\n\t\t\trcu_read_unlock();\n\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\t\t\tdest_keyring =\n\t\t\t\tkey_get(cred->user->session_keyring);\n\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\t\t\tdest_keyring = key_get(cred->user->uid_keyring);\n\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\t}\n\n\t*_dest_keyring = dest_keyring;\n\tkleave(\" [dk %d]\", key_serial(dest_keyring));\n\treturn;\n}\n\n/*\n * Allocate a new key in under-construction state and attempt to link it in to\n * the requested keyring.\n *\n * May return a key that's already under construction instead if there was a\n * race between two thread calling request_key().\n */\nstatic int construct_alloc_key(struct keyring_search_context *ctx,\n\t\t\t       struct key *dest_keyring,\n\t\t\t       unsigned long flags,\n\t\t\t       struct key_user *user,\n\t\t\t       struct key **_key)\n{\n\tstruct assoc_array_edit *edit;\n\tstruct key *key;\n\tkey_perm_t perm;\n\tkey_ref_t key_ref;\n\tint ret;\n\n\tkenter(\"%s,%s,,,\",\n\t       ctx->index_key.type->name, ctx->index_key.description);\n\n\t*_key = NULL;\n\tmutex_lock(&user->cons_lock);\n\n\tperm = KEY_POS_VIEW | KEY_POS_SEARCH | KEY_POS_LINK | KEY_POS_SETATTR;\n\tperm |= KEY_USR_VIEW;\n\tif (ctx->index_key.type->read)\n\t\tperm |= KEY_POS_READ;\n\tif (ctx->index_key.type == &key_type_keyring ||\n\t    ctx->index_key.type->update)\n\t\tperm |= KEY_POS_WRITE;\n\n\tkey = key_alloc(ctx->index_key.type, ctx->index_key.description,\n\t\t\tctx->cred->fsuid, ctx->cred->fsgid, ctx->cred,\n\t\t\tperm, flags, NULL);\n\tif (IS_ERR(key))\n\t\tgoto alloc_failed;\n\n\tset_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags);\n\n\tif (dest_keyring) {\n\t\tret = __key_link_begin(dest_keyring, &ctx->index_key, &edit);\n\t\tif (ret < 0)\n\t\t\tgoto link_prealloc_failed;\n\t}\n\n\t/* attach the key to the destination keyring under lock, but we do need\n\t * to do another check just in case someone beat us to it whilst we\n\t * waited for locks */\n\tmutex_lock(&key_construction_mutex);\n\n\tkey_ref = search_process_keyrings(ctx);\n\tif (!IS_ERR(key_ref))\n\t\tgoto key_already_present;\n\n\tif (dest_keyring)\n\t\t__key_link(key, &edit);\n\n\tmutex_unlock(&key_construction_mutex);\n\tif (dest_keyring)\n\t\t__key_link_end(dest_keyring, &ctx->index_key, edit);\n\tmutex_unlock(&user->cons_lock);\n\t*_key = key;\n\tkleave(\" = 0 [%d]\", key_serial(key));\n\treturn 0;\n\n\t/* the key is now present - we tell the caller that we found it by\n\t * returning -EINPROGRESS  */\nkey_already_present:\n\tkey_put(key);\n\tmutex_unlock(&key_construction_mutex);\n\tkey = key_ref_to_ptr(key_ref);\n\tif (dest_keyring) {\n\t\tret = __key_link_check_live_key(dest_keyring, key);\n\t\tif (ret == 0)\n\t\t\t__key_link(key, &edit);\n\t\t__key_link_end(dest_keyring, &ctx->index_key, edit);\n\t\tif (ret < 0)\n\t\t\tgoto link_check_failed;\n\t}\n\tmutex_unlock(&user->cons_lock);\n\t*_key = key;\n\tkleave(\" = -EINPROGRESS [%d]\", key_serial(key));\n\treturn -EINPROGRESS;\n\nlink_check_failed:\n\tmutex_unlock(&user->cons_lock);\n\tkey_put(key);\n\tkleave(\" = %d [linkcheck]\", ret);\n\treturn ret;\n\nlink_prealloc_failed:\n\tmutex_unlock(&user->cons_lock);\n\tkey_put(key);\n\tkleave(\" = %d [prelink]\", ret);\n\treturn ret;\n\nalloc_failed:\n\tmutex_unlock(&user->cons_lock);\n\tkleave(\" = %ld\", PTR_ERR(key));\n\treturn PTR_ERR(key);\n}\n\n/*\n * Commence key construction.\n */\nstatic struct key *construct_key_and_link(struct keyring_search_context *ctx,\n\t\t\t\t\t  const char *callout_info,\n\t\t\t\t\t  size_t callout_len,\n\t\t\t\t\t  void *aux,\n\t\t\t\t\t  struct key *dest_keyring,\n\t\t\t\t\t  unsigned long flags)\n{\n\tstruct key_user *user;\n\tstruct key *key;\n\tint ret;\n\n\tkenter(\"\");\n\n\tif (ctx->index_key.type == &key_type_keyring)\n\t\treturn ERR_PTR(-EPERM);\n\n\tuser = key_user_lookup(current_fsuid());\n\tif (!user)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tconstruct_get_dest_keyring(&dest_keyring);\n\n\tret = construct_alloc_key(ctx, dest_keyring, flags, user, &key);\n\tkey_user_put(user);\n\n\tif (ret == 0) {\n\t\tret = construct_key(key, callout_info, callout_len, aux,\n\t\t\t\t    dest_keyring);\n\t\tif (ret < 0) {\n\t\t\tkdebug(\"cons failed\");\n\t\t\tgoto construction_failed;\n\t\t}\n\t} else if (ret == -EINPROGRESS) {\n\t\tret = 0;\n\t} else {\n\t\tgoto couldnt_alloc_key;\n\t}\n\n\tkey_put(dest_keyring);\n\tkleave(\" = key %d\", key_serial(key));\n\treturn key;\n\nconstruction_failed:\n\tkey_negate_and_link(key, key_negative_timeout, NULL, NULL);\n\tkey_put(key);\ncouldnt_alloc_key:\n\tkey_put(dest_keyring);\n\tkleave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}\n\n/**\n * request_key_and_link - Request a key and cache it in a keyring.\n * @type: The type of key we want.\n * @description: The searchable description of the key.\n * @callout_info: The data to pass to the instantiation upcall (or NULL).\n * @callout_len: The length of callout_info.\n * @aux: Auxiliary data for the upcall.\n * @dest_keyring: Where to cache the key.\n * @flags: Flags to key_alloc().\n *\n * A key matching the specified criteria is searched for in the process's\n * keyrings and returned with its usage count incremented if found.  Otherwise,\n * if callout_info is not NULL, a key will be allocated and some service\n * (probably in userspace) will be asked to instantiate it.\n *\n * If successfully found or created, the key will be linked to the destination\n * keyring if one is provided.\n *\n * Returns a pointer to the key if successful; -EACCES, -ENOKEY, -EKEYREVOKED\n * or -EKEYEXPIRED if an inaccessible, negative, revoked or expired key was\n * found; -ENOKEY if no key was found and no @callout_info was given; -EDQUOT\n * if insufficient key quota was available to create a new key; or -ENOMEM if\n * insufficient memory was available.\n *\n * If the returned key was created, then it may still be under construction,\n * and wait_for_key_construction() should be used to wait for that to complete.\n */\nstruct key *request_key_and_link(struct key_type *type,\n\t\t\t\t const char *description,\n\t\t\t\t const void *callout_info,\n\t\t\t\t size_t callout_len,\n\t\t\t\t void *aux,\n\t\t\t\t struct key *dest_keyring,\n\t\t\t\t unsigned long flags)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= (KEYRING_SEARCH_DO_STATE_CHECK |\n\t\t\t\t\t   KEYRING_SEARCH_SKIP_EXPIRED),\n\t};\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tint ret;\n\n\tkenter(\"%s,%s,%p,%zu,%p,%p,%lx\",\n\t       ctx.index_key.type->name, ctx.index_key.description,\n\t       callout_info, callout_len, aux, dest_keyring, flags);\n\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0) {\n\t\t\tkey = ERR_PTR(ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* search all the process keyrings for a key */\n\tkey_ref = search_process_keyrings(&ctx);\n\n\tif (!IS_ERR(key_ref)) {\n\t\tkey = key_ref_to_ptr(key_ref);\n\t\tif (dest_keyring) {\n\t\t\tret = key_link(dest_keyring, key);\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_put(key);\n\t\t\t\tkey = ERR_PTR(ret);\n\t\t\t\tgoto error_free;\n\t\t\t}\n\t\t}\n\t} else if (PTR_ERR(key_ref) != -EAGAIN) {\n\t\tkey = ERR_CAST(key_ref);\n\t} else  {\n\t\t/* the search failed, but the keyrings were searchable, so we\n\t\t * should consult userspace if we can */\n\t\tkey = ERR_PTR(-ENOKEY);\n\t\tif (!callout_info)\n\t\t\tgoto error_free;\n\n\t\tkey = construct_key_and_link(&ctx, callout_info, callout_len,\n\t\t\t\t\t     aux, dest_keyring, flags);\n\t}\n\nerror_free:\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\nerror:\n\tkleave(\" = %p\", key);\n\treturn key;\n}\n\n/**\n * wait_for_key_construction - Wait for construction of a key to complete\n * @key: The key being waited for.\n * @intr: Whether to wait interruptibly.\n *\n * Wait for a key to finish being constructed.\n *\n * Returns 0 if successful; -ERESTARTSYS if the wait was interrupted; -ENOKEY\n * if the key was negated; or -EKEYREVOKED or -EKEYEXPIRED if the key was\n * revoked or expired.\n */\nint wait_for_key_construction(struct key *key, bool intr)\n{\n\tint ret;\n\n\tret = wait_on_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT,\n\t\t\t  intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);\n\tif (ret)\n\t\treturn -ERESTARTSYS;\n\tret = key_read_state(key);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn key_validate(key);\n}\nEXPORT_SYMBOL(wait_for_key_construction);\n\n/**\n * request_key - Request a key and wait for construction\n * @type: Type of key.\n * @description: The searchable description of the key.\n * @callout_info: The data to pass to the instantiation upcall (or NULL).\n *\n * As for request_key_and_link() except that it does not add the returned key\n * to a keyring if found, new keys are always allocated in the user's quota,\n * the callout_info must be a NUL-terminated string and no auxiliary data can\n * be passed.\n *\n * Furthermore, it then works as wait_for_key_construction() to wait for the\n * completion of keys undergoing construction with a non-interruptible wait.\n */\nstruct key *request_key(struct key_type *type,\n\t\t\tconst char *description,\n\t\t\tconst char *callout_info)\n{\n\tstruct key *key;\n\tsize_t callout_len = 0;\n\tint ret;\n\n\tif (callout_info)\n\t\tcallout_len = strlen(callout_info);\n\tkey = request_key_and_link(type, description, callout_info, callout_len,\n\t\t\t\t   NULL, NULL, KEY_ALLOC_IN_QUOTA);\n\tif (!IS_ERR(key)) {\n\t\tret = wait_for_key_construction(key, false);\n\t\tif (ret < 0) {\n\t\t\tkey_put(key);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\treturn key;\n}\nEXPORT_SYMBOL(request_key);\n\n/**\n * request_key_with_auxdata - Request a key with auxiliary data for the upcaller\n * @type: The type of key we want.\n * @description: The searchable description of the key.\n * @callout_info: The data to pass to the instantiation upcall (or NULL).\n * @callout_len: The length of callout_info.\n * @aux: Auxiliary data for the upcall.\n *\n * As for request_key_and_link() except that it does not add the returned key\n * to a keyring if found and new keys are always allocated in the user's quota.\n *\n * Furthermore, it then works as wait_for_key_construction() to wait for the\n * completion of keys undergoing construction with a non-interruptible wait.\n */\nstruct key *request_key_with_auxdata(struct key_type *type,\n\t\t\t\t     const char *description,\n\t\t\t\t     const void *callout_info,\n\t\t\t\t     size_t callout_len,\n\t\t\t\t     void *aux)\n{\n\tstruct key *key;\n\tint ret;\n\n\tkey = request_key_and_link(type, description, callout_info, callout_len,\n\t\t\t\t   aux, NULL, KEY_ALLOC_IN_QUOTA);\n\tif (!IS_ERR(key)) {\n\t\tret = wait_for_key_construction(key, false);\n\t\tif (ret < 0) {\n\t\t\tkey_put(key);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\treturn key;\n}\nEXPORT_SYMBOL(request_key_with_auxdata);\n\n/*\n * request_key_async - Request a key (allow async construction)\n * @type: Type of key.\n * @description: The searchable description of the key.\n * @callout_info: The data to pass to the instantiation upcall (or NULL).\n * @callout_len: The length of callout_info.\n *\n * As for request_key_and_link() except that it does not add the returned key\n * to a keyring if found, new keys are always allocated in the user's quota and\n * no auxiliary data can be passed.\n *\n * The caller should call wait_for_key_construction() to wait for the\n * completion of the returned key if it is still undergoing construction.\n */\nstruct key *request_key_async(struct key_type *type,\n\t\t\t      const char *description,\n\t\t\t      const void *callout_info,\n\t\t\t      size_t callout_len)\n{\n\treturn request_key_and_link(type, description, callout_info,\n\t\t\t\t    callout_len, NULL, NULL,\n\t\t\t\t    KEY_ALLOC_IN_QUOTA);\n}\nEXPORT_SYMBOL(request_key_async);\n\n/*\n * request a key with auxiliary data for the upcaller (allow async construction)\n * @type: Type of key.\n * @description: The searchable description of the key.\n * @callout_info: The data to pass to the instantiation upcall (or NULL).\n * @callout_len: The length of callout_info.\n * @aux: Auxiliary data for the upcall.\n *\n * As for request_key_and_link() except that it does not add the returned key\n * to a keyring if found and new keys are always allocated in the user's quota.\n *\n * The caller should call wait_for_key_construction() to wait for the\n * completion of the returned key if it is still undergoing construction.\n */\nstruct key *request_key_async_with_auxdata(struct key_type *type,\n\t\t\t\t\t   const char *description,\n\t\t\t\t\t   const void *callout_info,\n\t\t\t\t\t   size_t callout_len,\n\t\t\t\t\t   void *aux)\n{\n\treturn request_key_and_link(type, description, callout_info,\n\t\t\t\t    callout_len, aux, NULL, KEY_ALLOC_IN_QUOTA);\n}\nEXPORT_SYMBOL(request_key_async_with_auxdata);\n"], "fixing_code": ["/* Request a key from userspace\n *\n * Copyright (C) 2004-2007 Red Hat, Inc. All Rights Reserved.\n * Written by David Howells (dhowells@redhat.com)\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n *\n * See Documentation/security/keys/request-key.rst\n */\n\n#include <linux/module.h>\n#include <linux/sched.h>\n#include <linux/kmod.h>\n#include <linux/err.h>\n#include <linux/keyctl.h>\n#include <linux/slab.h>\n#include \"internal.h\"\n\n#define key_negative_timeout\t60\t/* default timeout on a negative key's existence */\n\n/**\n * complete_request_key - Complete the construction of a key.\n * @cons: The key construction record.\n * @error: The success or failute of the construction.\n *\n * Complete the attempt to construct a key.  The key will be negated\n * if an error is indicated.  The authorisation key will be revoked\n * unconditionally.\n */\nvoid complete_request_key(struct key_construction *cons, int error)\n{\n\tkenter(\"{%d,%d},%d\", cons->key->serial, cons->authkey->serial, error);\n\n\tif (error < 0)\n\t\tkey_negate_and_link(cons->key, key_negative_timeout, NULL,\n\t\t\t\t    cons->authkey);\n\telse\n\t\tkey_revoke(cons->authkey);\n\n\tkey_put(cons->key);\n\tkey_put(cons->authkey);\n\tkfree(cons);\n}\nEXPORT_SYMBOL(complete_request_key);\n\n/*\n * Initialise a usermode helper that is going to have a specific session\n * keyring.\n *\n * This is called in context of freshly forked kthread before kernel_execve(),\n * so we can simply install the desired session_keyring at this point.\n */\nstatic int umh_keys_init(struct subprocess_info *info, struct cred *cred)\n{\n\tstruct key *keyring = info->data;\n\n\treturn install_session_keyring_to_cred(cred, keyring);\n}\n\n/*\n * Clean up a usermode helper with session keyring.\n */\nstatic void umh_keys_cleanup(struct subprocess_info *info)\n{\n\tstruct key *keyring = info->data;\n\tkey_put(keyring);\n}\n\n/*\n * Call a usermode helper with a specific session keyring.\n */\nstatic int call_usermodehelper_keys(const char *path, char **argv, char **envp,\n\t\t\t\t\tstruct key *session_keyring, int wait)\n{\n\tstruct subprocess_info *info;\n\n\tinfo = call_usermodehelper_setup(path, argv, envp, GFP_KERNEL,\n\t\t\t\t\t  umh_keys_init, umh_keys_cleanup,\n\t\t\t\t\t  session_keyring);\n\tif (!info)\n\t\treturn -ENOMEM;\n\n\tkey_get(session_keyring);\n\treturn call_usermodehelper_exec(info, wait);\n}\n\n/*\n * Request userspace finish the construction of a key\n * - execute \"/sbin/request-key <op> <key> <uid> <gid> <keyring> <keyring> <keyring>\"\n */\nstatic int call_sbin_request_key(struct key_construction *cons,\n\t\t\t\t const char *op,\n\t\t\t\t void *aux)\n{\n\tstatic char const request_key[] = \"/sbin/request-key\";\n\tconst struct cred *cred = current_cred();\n\tkey_serial_t prkey, sskey;\n\tstruct key *key = cons->key, *authkey = cons->authkey, *keyring,\n\t\t*session;\n\tchar *argv[9], *envp[3], uid_str[12], gid_str[12];\n\tchar key_str[12], keyring_str[3][12];\n\tchar desc[20];\n\tint ret, i;\n\n\tkenter(\"{%d},{%d},%s\", key->serial, authkey->serial, op);\n\n\tret = install_user_keyrings();\n\tif (ret < 0)\n\t\tgoto error_alloc;\n\n\t/* allocate a new session keyring */\n\tsprintf(desc, \"_req.%u\", key->serial);\n\n\tcred = get_current_cred();\n\tkeyring = keyring_alloc(desc, cred->fsuid, cred->fsgid, cred,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW | KEY_USR_READ,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN, NULL, NULL);\n\tput_cred(cred);\n\tif (IS_ERR(keyring)) {\n\t\tret = PTR_ERR(keyring);\n\t\tgoto error_alloc;\n\t}\n\n\t/* attach the auth key to the session keyring */\n\tret = key_link(keyring, authkey);\n\tif (ret < 0)\n\t\tgoto error_link;\n\n\t/* record the UID and GID */\n\tsprintf(uid_str, \"%d\", from_kuid(&init_user_ns, cred->fsuid));\n\tsprintf(gid_str, \"%d\", from_kgid(&init_user_ns, cred->fsgid));\n\n\t/* we say which key is under construction */\n\tsprintf(key_str, \"%d\", key->serial);\n\n\t/* we specify the process's default keyrings */\n\tsprintf(keyring_str[0], \"%d\",\n\t\tcred->thread_keyring ? cred->thread_keyring->serial : 0);\n\n\tprkey = 0;\n\tif (cred->process_keyring)\n\t\tprkey = cred->process_keyring->serial;\n\tsprintf(keyring_str[1], \"%d\", prkey);\n\n\trcu_read_lock();\n\tsession = rcu_dereference(cred->session_keyring);\n\tif (!session)\n\t\tsession = cred->user->session_keyring;\n\tsskey = session->serial;\n\trcu_read_unlock();\n\n\tsprintf(keyring_str[2], \"%d\", sskey);\n\n\t/* set up a minimal environment */\n\ti = 0;\n\tenvp[i++] = \"HOME=/\";\n\tenvp[i++] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[i] = NULL;\n\n\t/* set up the argument list */\n\ti = 0;\n\targv[i++] = (char *)request_key;\n\targv[i++] = (char *) op;\n\targv[i++] = key_str;\n\targv[i++] = uid_str;\n\targv[i++] = gid_str;\n\targv[i++] = keyring_str[0];\n\targv[i++] = keyring_str[1];\n\targv[i++] = keyring_str[2];\n\targv[i] = NULL;\n\n\t/* do it */\n\tret = call_usermodehelper_keys(request_key, argv, envp, keyring,\n\t\t\t\t       UMH_WAIT_PROC);\n\tkdebug(\"usermode -> 0x%x\", ret);\n\tif (ret >= 0) {\n\t\t/* ret is the exit/wait code */\n\t\tif (test_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags) ||\n\t\t    key_validate(key) < 0)\n\t\t\tret = -ENOKEY;\n\t\telse\n\t\t\t/* ignore any errors from userspace if the key was\n\t\t\t * instantiated */\n\t\t\tret = 0;\n\t}\n\nerror_link:\n\tkey_put(keyring);\n\nerror_alloc:\n\tcomplete_request_key(cons, ret);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n\n/*\n * Call out to userspace for key construction.\n *\n * Program failure is ignored in favour of key status.\n */\nstatic int construct_key(struct key *key, const void *callout_info,\n\t\t\t size_t callout_len, void *aux,\n\t\t\t struct key *dest_keyring)\n{\n\tstruct key_construction *cons;\n\trequest_key_actor_t actor;\n\tstruct key *authkey;\n\tint ret;\n\n\tkenter(\"%d,%p,%zu,%p\", key->serial, callout_info, callout_len, aux);\n\n\tcons = kmalloc(sizeof(*cons), GFP_KERNEL);\n\tif (!cons)\n\t\treturn -ENOMEM;\n\n\t/* allocate an authorisation key */\n\tauthkey = request_key_auth_new(key, callout_info, callout_len,\n\t\t\t\t       dest_keyring);\n\tif (IS_ERR(authkey)) {\n\t\tkfree(cons);\n\t\tret = PTR_ERR(authkey);\n\t\tauthkey = NULL;\n\t} else {\n\t\tcons->authkey = key_get(authkey);\n\t\tcons->key = key_get(key);\n\n\t\t/* make the call */\n\t\tactor = call_sbin_request_key;\n\t\tif (key->type->request_key)\n\t\t\tactor = key->type->request_key;\n\n\t\tret = actor(cons, \"create\", aux);\n\n\t\t/* check that the actor called complete_request_key() prior to\n\t\t * returning an error */\n\t\tWARN_ON(ret < 0 &&\n\t\t\t!test_bit(KEY_FLAG_REVOKED, &authkey->flags));\n\t\tkey_put(authkey);\n\t}\n\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}\n\n/*\n * Get the appropriate destination keyring for the request.\n *\n * The keyring selected is returned with an extra reference upon it which the\n * caller must release.\n */\nstatic int construct_get_dest_keyring(struct key **_dest_keyring)\n{\n\tstruct request_key_auth *rka;\n\tconst struct cred *cred = current_cred();\n\tstruct key *dest_keyring = *_dest_keyring, *authkey;\n\tint ret;\n\n\tkenter(\"%p\", dest_keyring);\n\n\t/* find the appropriate keyring */\n\tif (dest_keyring) {\n\t\t/* the caller supplied one */\n\t\tkey_get(dest_keyring);\n\t} else {\n\t\tbool do_perm_check = true;\n\n\t\t/* use a default keyring; falling through the cases until we\n\t\t * find one that we actually have */\n\t\tswitch (cred->jit_keyring) {\n\t\tcase KEY_REQKEY_DEFL_DEFAULT:\n\t\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\t\tif (cred->request_key_auth) {\n\t\t\t\tauthkey = cred->request_key_auth;\n\t\t\t\tdown_read(&authkey->sem);\n\t\t\t\trka = authkey->payload.data[0];\n\t\t\t\tif (!test_bit(KEY_FLAG_REVOKED,\n\t\t\t\t\t      &authkey->flags))\n\t\t\t\t\tdest_keyring =\n\t\t\t\t\t\tkey_get(rka->dest_keyring);\n\t\t\t\tup_read(&authkey->sem);\n\t\t\t\tif (dest_keyring) {\n\t\t\t\t\tdo_perm_check = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\t\tdest_keyring = key_get(cred->thread_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\t\tdest_keyring = key_get(cred->process_keyring);\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\t\t\trcu_read_lock();\n\t\t\tdest_keyring = key_get(\n\t\t\t\trcu_dereference(cred->session_keyring));\n\t\t\trcu_read_unlock();\n\n\t\t\tif (dest_keyring)\n\t\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\t\t\tdest_keyring =\n\t\t\t\tkey_get(cred->user->session_keyring);\n\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\t\t\tdest_keyring = key_get(cred->user->uid_keyring);\n\t\t\tbreak;\n\n\t\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n\t\tdefault:\n\t\t\tBUG();\n\t\t}\n\n\t\t/*\n\t\t * Require Write permission on the keyring.  This is essential\n\t\t * because the default keyring may be the session keyring, and\n\t\t * joining a keyring only requires Search permission.\n\t\t *\n\t\t * However, this check is skipped for the \"requestor keyring\" so\n\t\t * that /sbin/request-key can itself use request_key() to add\n\t\t * keys to the original requestor's destination keyring.\n\t\t */\n\t\tif (dest_keyring && do_perm_check) {\n\t\t\tret = key_permission(make_key_ref(dest_keyring, 1),\n\t\t\t\t\t     KEY_NEED_WRITE);\n\t\t\tif (ret) {\n\t\t\t\tkey_put(dest_keyring);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t}\n\n\t*_dest_keyring = dest_keyring;\n\tkleave(\" [dk %d]\", key_serial(dest_keyring));\n\treturn 0;\n}\n\n/*\n * Allocate a new key in under-construction state and attempt to link it in to\n * the requested keyring.\n *\n * May return a key that's already under construction instead if there was a\n * race between two thread calling request_key().\n */\nstatic int construct_alloc_key(struct keyring_search_context *ctx,\n\t\t\t       struct key *dest_keyring,\n\t\t\t       unsigned long flags,\n\t\t\t       struct key_user *user,\n\t\t\t       struct key **_key)\n{\n\tstruct assoc_array_edit *edit;\n\tstruct key *key;\n\tkey_perm_t perm;\n\tkey_ref_t key_ref;\n\tint ret;\n\n\tkenter(\"%s,%s,,,\",\n\t       ctx->index_key.type->name, ctx->index_key.description);\n\n\t*_key = NULL;\n\tmutex_lock(&user->cons_lock);\n\n\tperm = KEY_POS_VIEW | KEY_POS_SEARCH | KEY_POS_LINK | KEY_POS_SETATTR;\n\tperm |= KEY_USR_VIEW;\n\tif (ctx->index_key.type->read)\n\t\tperm |= KEY_POS_READ;\n\tif (ctx->index_key.type == &key_type_keyring ||\n\t    ctx->index_key.type->update)\n\t\tperm |= KEY_POS_WRITE;\n\n\tkey = key_alloc(ctx->index_key.type, ctx->index_key.description,\n\t\t\tctx->cred->fsuid, ctx->cred->fsgid, ctx->cred,\n\t\t\tperm, flags, NULL);\n\tif (IS_ERR(key))\n\t\tgoto alloc_failed;\n\n\tset_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags);\n\n\tif (dest_keyring) {\n\t\tret = __key_link_begin(dest_keyring, &ctx->index_key, &edit);\n\t\tif (ret < 0)\n\t\t\tgoto link_prealloc_failed;\n\t}\n\n\t/* attach the key to the destination keyring under lock, but we do need\n\t * to do another check just in case someone beat us to it whilst we\n\t * waited for locks */\n\tmutex_lock(&key_construction_mutex);\n\n\tkey_ref = search_process_keyrings(ctx);\n\tif (!IS_ERR(key_ref))\n\t\tgoto key_already_present;\n\n\tif (dest_keyring)\n\t\t__key_link(key, &edit);\n\n\tmutex_unlock(&key_construction_mutex);\n\tif (dest_keyring)\n\t\t__key_link_end(dest_keyring, &ctx->index_key, edit);\n\tmutex_unlock(&user->cons_lock);\n\t*_key = key;\n\tkleave(\" = 0 [%d]\", key_serial(key));\n\treturn 0;\n\n\t/* the key is now present - we tell the caller that we found it by\n\t * returning -EINPROGRESS  */\nkey_already_present:\n\tkey_put(key);\n\tmutex_unlock(&key_construction_mutex);\n\tkey = key_ref_to_ptr(key_ref);\n\tif (dest_keyring) {\n\t\tret = __key_link_check_live_key(dest_keyring, key);\n\t\tif (ret == 0)\n\t\t\t__key_link(key, &edit);\n\t\t__key_link_end(dest_keyring, &ctx->index_key, edit);\n\t\tif (ret < 0)\n\t\t\tgoto link_check_failed;\n\t}\n\tmutex_unlock(&user->cons_lock);\n\t*_key = key;\n\tkleave(\" = -EINPROGRESS [%d]\", key_serial(key));\n\treturn -EINPROGRESS;\n\nlink_check_failed:\n\tmutex_unlock(&user->cons_lock);\n\tkey_put(key);\n\tkleave(\" = %d [linkcheck]\", ret);\n\treturn ret;\n\nlink_prealloc_failed:\n\tmutex_unlock(&user->cons_lock);\n\tkey_put(key);\n\tkleave(\" = %d [prelink]\", ret);\n\treturn ret;\n\nalloc_failed:\n\tmutex_unlock(&user->cons_lock);\n\tkleave(\" = %ld\", PTR_ERR(key));\n\treturn PTR_ERR(key);\n}\n\n/*\n * Commence key construction.\n */\nstatic struct key *construct_key_and_link(struct keyring_search_context *ctx,\n\t\t\t\t\t  const char *callout_info,\n\t\t\t\t\t  size_t callout_len,\n\t\t\t\t\t  void *aux,\n\t\t\t\t\t  struct key *dest_keyring,\n\t\t\t\t\t  unsigned long flags)\n{\n\tstruct key_user *user;\n\tstruct key *key;\n\tint ret;\n\n\tkenter(\"\");\n\n\tif (ctx->index_key.type == &key_type_keyring)\n\t\treturn ERR_PTR(-EPERM);\n\n\tret = construct_get_dest_keyring(&dest_keyring);\n\tif (ret)\n\t\tgoto error;\n\n\tuser = key_user_lookup(current_fsuid());\n\tif (!user) {\n\t\tret = -ENOMEM;\n\t\tgoto error_put_dest_keyring;\n\t}\n\n\tret = construct_alloc_key(ctx, dest_keyring, flags, user, &key);\n\tkey_user_put(user);\n\n\tif (ret == 0) {\n\t\tret = construct_key(key, callout_info, callout_len, aux,\n\t\t\t\t    dest_keyring);\n\t\tif (ret < 0) {\n\t\t\tkdebug(\"cons failed\");\n\t\t\tgoto construction_failed;\n\t\t}\n\t} else if (ret == -EINPROGRESS) {\n\t\tret = 0;\n\t} else {\n\t\tgoto error_put_dest_keyring;\n\t}\n\n\tkey_put(dest_keyring);\n\tkleave(\" = key %d\", key_serial(key));\n\treturn key;\n\nconstruction_failed:\n\tkey_negate_and_link(key, key_negative_timeout, NULL, NULL);\n\tkey_put(key);\nerror_put_dest_keyring:\n\tkey_put(dest_keyring);\nerror:\n\tkleave(\" = %d\", ret);\n\treturn ERR_PTR(ret);\n}\n\n/**\n * request_key_and_link - Request a key and cache it in a keyring.\n * @type: The type of key we want.\n * @description: The searchable description of the key.\n * @callout_info: The data to pass to the instantiation upcall (or NULL).\n * @callout_len: The length of callout_info.\n * @aux: Auxiliary data for the upcall.\n * @dest_keyring: Where to cache the key.\n * @flags: Flags to key_alloc().\n *\n * A key matching the specified criteria is searched for in the process's\n * keyrings and returned with its usage count incremented if found.  Otherwise,\n * if callout_info is not NULL, a key will be allocated and some service\n * (probably in userspace) will be asked to instantiate it.\n *\n * If successfully found or created, the key will be linked to the destination\n * keyring if one is provided.\n *\n * Returns a pointer to the key if successful; -EACCES, -ENOKEY, -EKEYREVOKED\n * or -EKEYEXPIRED if an inaccessible, negative, revoked or expired key was\n * found; -ENOKEY if no key was found and no @callout_info was given; -EDQUOT\n * if insufficient key quota was available to create a new key; or -ENOMEM if\n * insufficient memory was available.\n *\n * If the returned key was created, then it may still be under construction,\n * and wait_for_key_construction() should be used to wait for that to complete.\n */\nstruct key *request_key_and_link(struct key_type *type,\n\t\t\t\t const char *description,\n\t\t\t\t const void *callout_info,\n\t\t\t\t size_t callout_len,\n\t\t\t\t void *aux,\n\t\t\t\t struct key *dest_keyring,\n\t\t\t\t unsigned long flags)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= (KEYRING_SEARCH_DO_STATE_CHECK |\n\t\t\t\t\t   KEYRING_SEARCH_SKIP_EXPIRED),\n\t};\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tint ret;\n\n\tkenter(\"%s,%s,%p,%zu,%p,%p,%lx\",\n\t       ctx.index_key.type->name, ctx.index_key.description,\n\t       callout_info, callout_len, aux, dest_keyring, flags);\n\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0) {\n\t\t\tkey = ERR_PTR(ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\t/* search all the process keyrings for a key */\n\tkey_ref = search_process_keyrings(&ctx);\n\n\tif (!IS_ERR(key_ref)) {\n\t\tkey = key_ref_to_ptr(key_ref);\n\t\tif (dest_keyring) {\n\t\t\tret = key_link(dest_keyring, key);\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_put(key);\n\t\t\t\tkey = ERR_PTR(ret);\n\t\t\t\tgoto error_free;\n\t\t\t}\n\t\t}\n\t} else if (PTR_ERR(key_ref) != -EAGAIN) {\n\t\tkey = ERR_CAST(key_ref);\n\t} else  {\n\t\t/* the search failed, but the keyrings were searchable, so we\n\t\t * should consult userspace if we can */\n\t\tkey = ERR_PTR(-ENOKEY);\n\t\tif (!callout_info)\n\t\t\tgoto error_free;\n\n\t\tkey = construct_key_and_link(&ctx, callout_info, callout_len,\n\t\t\t\t\t     aux, dest_keyring, flags);\n\t}\n\nerror_free:\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\nerror:\n\tkleave(\" = %p\", key);\n\treturn key;\n}\n\n/**\n * wait_for_key_construction - Wait for construction of a key to complete\n * @key: The key being waited for.\n * @intr: Whether to wait interruptibly.\n *\n * Wait for a key to finish being constructed.\n *\n * Returns 0 if successful; -ERESTARTSYS if the wait was interrupted; -ENOKEY\n * if the key was negated; or -EKEYREVOKED or -EKEYEXPIRED if the key was\n * revoked or expired.\n */\nint wait_for_key_construction(struct key *key, bool intr)\n{\n\tint ret;\n\n\tret = wait_on_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT,\n\t\t\t  intr ? TASK_INTERRUPTIBLE : TASK_UNINTERRUPTIBLE);\n\tif (ret)\n\t\treturn -ERESTARTSYS;\n\tret = key_read_state(key);\n\tif (ret < 0)\n\t\treturn ret;\n\treturn key_validate(key);\n}\nEXPORT_SYMBOL(wait_for_key_construction);\n\n/**\n * request_key - Request a key and wait for construction\n * @type: Type of key.\n * @description: The searchable description of the key.\n * @callout_info: The data to pass to the instantiation upcall (or NULL).\n *\n * As for request_key_and_link() except that it does not add the returned key\n * to a keyring if found, new keys are always allocated in the user's quota,\n * the callout_info must be a NUL-terminated string and no auxiliary data can\n * be passed.\n *\n * Furthermore, it then works as wait_for_key_construction() to wait for the\n * completion of keys undergoing construction with a non-interruptible wait.\n */\nstruct key *request_key(struct key_type *type,\n\t\t\tconst char *description,\n\t\t\tconst char *callout_info)\n{\n\tstruct key *key;\n\tsize_t callout_len = 0;\n\tint ret;\n\n\tif (callout_info)\n\t\tcallout_len = strlen(callout_info);\n\tkey = request_key_and_link(type, description, callout_info, callout_len,\n\t\t\t\t   NULL, NULL, KEY_ALLOC_IN_QUOTA);\n\tif (!IS_ERR(key)) {\n\t\tret = wait_for_key_construction(key, false);\n\t\tif (ret < 0) {\n\t\t\tkey_put(key);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\treturn key;\n}\nEXPORT_SYMBOL(request_key);\n\n/**\n * request_key_with_auxdata - Request a key with auxiliary data for the upcaller\n * @type: The type of key we want.\n * @description: The searchable description of the key.\n * @callout_info: The data to pass to the instantiation upcall (or NULL).\n * @callout_len: The length of callout_info.\n * @aux: Auxiliary data for the upcall.\n *\n * As for request_key_and_link() except that it does not add the returned key\n * to a keyring if found and new keys are always allocated in the user's quota.\n *\n * Furthermore, it then works as wait_for_key_construction() to wait for the\n * completion of keys undergoing construction with a non-interruptible wait.\n */\nstruct key *request_key_with_auxdata(struct key_type *type,\n\t\t\t\t     const char *description,\n\t\t\t\t     const void *callout_info,\n\t\t\t\t     size_t callout_len,\n\t\t\t\t     void *aux)\n{\n\tstruct key *key;\n\tint ret;\n\n\tkey = request_key_and_link(type, description, callout_info, callout_len,\n\t\t\t\t   aux, NULL, KEY_ALLOC_IN_QUOTA);\n\tif (!IS_ERR(key)) {\n\t\tret = wait_for_key_construction(key, false);\n\t\tif (ret < 0) {\n\t\t\tkey_put(key);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\treturn key;\n}\nEXPORT_SYMBOL(request_key_with_auxdata);\n\n/*\n * request_key_async - Request a key (allow async construction)\n * @type: Type of key.\n * @description: The searchable description of the key.\n * @callout_info: The data to pass to the instantiation upcall (or NULL).\n * @callout_len: The length of callout_info.\n *\n * As for request_key_and_link() except that it does not add the returned key\n * to a keyring if found, new keys are always allocated in the user's quota and\n * no auxiliary data can be passed.\n *\n * The caller should call wait_for_key_construction() to wait for the\n * completion of the returned key if it is still undergoing construction.\n */\nstruct key *request_key_async(struct key_type *type,\n\t\t\t      const char *description,\n\t\t\t      const void *callout_info,\n\t\t\t      size_t callout_len)\n{\n\treturn request_key_and_link(type, description, callout_info,\n\t\t\t\t    callout_len, NULL, NULL,\n\t\t\t\t    KEY_ALLOC_IN_QUOTA);\n}\nEXPORT_SYMBOL(request_key_async);\n\n/*\n * request a key with auxiliary data for the upcaller (allow async construction)\n * @type: Type of key.\n * @description: The searchable description of the key.\n * @callout_info: The data to pass to the instantiation upcall (or NULL).\n * @callout_len: The length of callout_info.\n * @aux: Auxiliary data for the upcall.\n *\n * As for request_key_and_link() except that it does not add the returned key\n * to a keyring if found and new keys are always allocated in the user's quota.\n *\n * The caller should call wait_for_key_construction() to wait for the\n * completion of the returned key if it is still undergoing construction.\n */\nstruct key *request_key_async_with_auxdata(struct key_type *type,\n\t\t\t\t\t   const char *description,\n\t\t\t\t\t   const void *callout_info,\n\t\t\t\t\t   size_t callout_len,\n\t\t\t\t\t   void *aux)\n{\n\treturn request_key_and_link(type, description, callout_info,\n\t\t\t\t    callout_len, aux, NULL, KEY_ALLOC_IN_QUOTA);\n}\nEXPORT_SYMBOL(request_key_async_with_auxdata);\n"], "filenames": ["security/keys/request_key.c"], "buggy_code_start_loc": [254], "buggy_code_end_loc": [477], "fixing_code_start_loc": [254], "fixing_code_end_loc": [506], "type": "CWE-862", "message": "The KEYS subsystem in the Linux kernel before 4.14.6 omitted an access-control check when adding a key to the current task's \"default request-key keyring\" via the request_key() system call, allowing a local user to use a sequence of crafted system calls to add keys to a keyring with only Search permission (not Write permission) to that keyring, related to construct_get_dest_keyring() in security/keys/request_key.c.", "other": {"cve": {"id": "CVE-2017-17807", "sourceIdentifier": "cve@mitre.org", "published": "2017-12-20T23:29:00.423", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The KEYS subsystem in the Linux kernel before 4.14.6 omitted an access-control check when adding a key to the current task's \"default request-key keyring\" via the request_key() system call, allowing a local user to use a sequence of crafted system calls to add keys to a keyring with only Search permission (not Write permission) to that keyring, related to construct_get_dest_keyring() in security/keys/request_key.c."}, {"lang": "es", "value": "El subsistema KEYS en el kernel de Linux en versiones anteriores a la 4.14.6 omit\u00eda una comprobaci\u00f3n de control de acceso cuando se agregaba una clave al \"llavero de acceso por defecto\" de la tarea actual mediante la llamada al sistema request_key(), permitiendo a un usuario local utilizar una secuencia de llamadas de sistema manipuladas para a\u00f1adir claves a un llavero solo con permiso de b\u00fasqueda (no de escritura) a ese llavero. Esto est\u00e1 relacionado con construct_get_dest_keyring() en security/keys/request_key.c."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.3, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-862"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.14.6", "matchCriteriaId": "4A92C99D-2B24-49B6-AFB9-2C47AFC49D0F"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=4dca6ea1d9432052afb06baf2e3ae78188a4410b", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "http://www.securityfocus.com/bid/102301", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/4dca6ea1d9432052afb06baf2e3ae78188a4410b", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/01/msg00004.html", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3617-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3617-2/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3617-3/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3619-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3619-2/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3620-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3620-2/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3632-1/", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2017/dsa-4073", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4082", "source": "cve@mitre.org"}, {"url": "https://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.14.6", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Mailing List", "Release Notes"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/4dca6ea1d9432052afb06baf2e3ae78188a4410b"}}