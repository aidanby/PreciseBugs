{"buggy_code": ["/*\n * The MIT License\n * \n * Copyright (c) 2004-2010, Sun Microsystems, Inc., Kohsuke Kawaguchi,\n * Yahoo! Inc., Stephen Connolly, Tom Huybrechts, Alan Harder, Manufacture\n * Francaise des Pneumatiques Michelin, Romain Seguy\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson;\n\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\nimport hudson.cli.CLICommand;\nimport hudson.console.ConsoleAnnotationDescriptor;\nimport hudson.console.ConsoleAnnotatorFactory;\nimport hudson.model.*;\nimport hudson.model.ParameterDefinition.ParameterDescriptor;\nimport hudson.search.SearchableModelObject;\nimport hudson.security.AccessControlled;\nimport hudson.security.AuthorizationStrategy;\nimport hudson.security.GlobalSecurityConfiguration;\nimport hudson.security.Permission;\nimport hudson.security.SecurityRealm;\nimport hudson.security.captcha.CaptchaSupport;\nimport hudson.security.csrf.CrumbIssuer;\nimport hudson.slaves.Cloud;\nimport hudson.slaves.ComputerLauncher;\nimport hudson.slaves.NodeProperty;\nimport hudson.slaves.NodePropertyDescriptor;\nimport hudson.slaves.RetentionStrategy;\nimport hudson.tasks.BuildStepDescriptor;\nimport hudson.tasks.BuildWrapper;\nimport hudson.tasks.BuildWrappers;\nimport hudson.tasks.Builder;\nimport hudson.tasks.Publisher;\nimport hudson.tasks.UserAvatarResolver;\nimport hudson.util.Area;\nimport hudson.util.Iterators;\nimport hudson.scm.SCM;\nimport hudson.scm.SCMDescriptor;\nimport hudson.util.Secret;\nimport hudson.views.MyViewsTabBar;\nimport hudson.views.ViewsTabBar;\nimport hudson.widgets.RenderOnDemandClosure;\nimport jenkins.model.GlobalConfiguration;\nimport jenkins.model.GlobalConfigurationCategory;\nimport jenkins.model.GlobalConfigurationCategory.Unclassified;\nimport jenkins.model.Jenkins;\nimport jenkins.model.ModelObjectWithContextMenu;\nimport org.acegisecurity.providers.anonymous.AnonymousAuthenticationToken;\nimport org.apache.commons.jelly.JellyContext;\nimport org.apache.commons.jelly.JellyTagException;\nimport org.apache.commons.jelly.Script;\nimport org.apache.commons.jelly.XMLOutput;\nimport org.apache.commons.jexl.parser.ASTSizeFunction;\nimport org.apache.commons.jexl.util.Introspector;\nimport org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;\nimport org.jvnet.tiger_types.Types;\nimport org.kohsuke.stapler.Ancestor;\nimport org.kohsuke.stapler.Stapler;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\nimport org.kohsuke.stapler.jelly.InternationalizedStringExpression.RawHtmlArgument;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.management.LockInfo;\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.MonitorInfo;\nimport java.lang.management.ThreadInfo;\nimport java.lang.management.ThreadMXBean;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.ParameterizedType;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.net.URLDecoder;\nimport java.text.DecimalFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.ConcurrentModificationException;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.Date;\nimport java.util.logging.Level;\nimport java.util.logging.LogManager;\nimport java.util.logging.LogRecord;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport java.util.regex.Pattern;\nimport org.apache.commons.lang.StringUtils;\n\n/**\n * Utility functions used in views.\n *\n * <p>\n * An instance of this class is created for each request and made accessible\n * from view pages via the variable 'h' (h stands for Hudson.)\n *\n * @author Kohsuke Kawaguchi\n */\npublic class Functions {\n    private static volatile int globalIota = 0;\n    private int iota;\n\n    public Functions() {\n        iota = globalIota;\n        // concurrent requests can use the same ID --- we are just trying to\n        // prevent the same user from seeing the same ID repeatedly.\n        globalIota+=1000;\n    }\n\n    /**\n     * Generates an unique ID.\n     */\n    public String generateId() {\n        return \"id\"+iota++;\n    }\n\n    public static boolean isModel(Object o) {\n        return o instanceof ModelObject;\n    }\n\n    public static boolean isModelWithContextMenu(Object o) {\n        return o instanceof ModelObjectWithContextMenu;\n    }\n\n    public static String xsDate(Calendar cal) {\n        return Util.XS_DATETIME_FORMATTER.format(cal.getTime());\n    }\n\n    public static String rfc822Date(Calendar cal) {\n        return Util.RFC822_DATETIME_FORMATTER.format(cal.getTime());\n    }\n    \n    public static void initPageVariables(JellyContext context) {\n        String rootURL = Stapler.getCurrentRequest().getContextPath();\n\n        Functions h = new Functions();\n        context.setVariable(\"h\", h);\n\n\n        // The path starts with a \"/\" character but does not end with a \"/\" character.\n        context.setVariable(\"rootURL\", rootURL);\n\n        /*\n            load static resources from the path dedicated to a specific version.\n            This \"/static/VERSION/abc/def.ghi\" path is interpreted by stapler to be\n            the same thing as \"/abc/def.ghi\", but this avoids the stale cache\n            problem when the user upgrades to new Jenkins. Stapler also sets a long\n            future expiration dates for such static resources.\n\n            see https://wiki.jenkins-ci.org/display/JENKINS/Hyperlinks+in+HTML\n         */\n        context.setVariable(\"resURL\",rootURL+getResourcePath());\n        context.setVariable(\"imagesURL\",rootURL+getResourcePath()+\"/images\");\n    }\n\n    /**\n     * Given {@code c=MyList (extends ArrayList<Foo>), base=List}, compute the parameterization of 'base'\n     * that's assignable from 'c' (in this case {@code List<Foo>}), and return its n-th type parameter\n     * (n=0 would return {@code Foo}).\n     *\n     * <p>\n     * This method is useful for doing type arithmetic.\n     *\n     * @throws AssertionError\n     *      if c' is not parameterized.\n     */\n    public static <B> Class getTypeParameter(Class<? extends B> c, Class<B> base, int n) {\n        Type parameterization = Types.getBaseClass(c,base);\n        if (parameterization instanceof ParameterizedType) {\n            ParameterizedType pt = (ParameterizedType) parameterization;\n            return Types.erasure(Types.getTypeArgument(pt,n));\n        } else {\n            throw new AssertionError(c+\" doesn't properly parameterize \"+base);\n        }\n    }\n\n    public JDK.DescriptorImpl getJDKDescriptor() {\n        return Jenkins.getInstance().getDescriptorByType(JDK.DescriptorImpl.class);\n    }\n\n    /**\n     * Prints the integer as a string that represents difference,\n     * like \"-5\", \"+/-0\", \"+3\".\n     */\n    public static String getDiffString(int i) {\n        if(i==0)    return \"\\u00B10\";   // +/-0\n        String s = Integer.toString(i);\n        if(i>0)     return \"+\"+s;\n        else        return s;\n    }\n\n    /**\n     * {@link #getDiffString(int)} that doesn't show anything for +/-0\n     */\n    public static String getDiffString2(int i) {\n        if(i==0)    return \"\";\n        String s = Integer.toString(i);\n        if(i>0)     return \"+\"+s;\n        else        return s;\n    }\n\n    /**\n     * {@link #getDiffString2(int)} that puts the result into prefix and suffix\n     * if there's something to print\n     */\n    public static String getDiffString2(String prefix, int i, String suffix) {\n        if(i==0)    return \"\";\n        String s = Integer.toString(i);\n        if(i>0)     return prefix+\"+\"+s+suffix;\n        else        return prefix+s+suffix;\n    }\n\n    /**\n     * Adds the proper suffix.\n     */\n    public static String addSuffix(int n, String singular, String plural) {\n        StringBuilder buf = new StringBuilder();\n        buf.append(n).append(' ');\n        if(n==1)\n            buf.append(singular);\n        else\n            buf.append(plural);\n        return buf.toString();\n    }\n\n    public static RunUrl decompose(StaplerRequest req) {\n        List<Ancestor> ancestors = req.getAncestors();\n\n        // find the first and last Run instances\n        Ancestor f=null,l=null;\n        for (Ancestor anc : ancestors) {\n            if(anc.getObject() instanceof Run) {\n                if(f==null) f=anc;\n                l=anc;\n            }\n        }\n        if(l==null) return null;    // there was no Run object\n\n        String head = f.getPrev().getUrl()+'/';\n        String base = l.getUrl();\n\n        String reqUri = req.getOriginalRequestURI();\n        // Find \"rest\" or URI by removing N path components.\n        // Not using reqUri.substring(f.getUrl().length()) to avoid mismatches due to\n        // url-encoding or extra slashes.  Former may occur in Tomcat (despite the spec saying\n        // this string is not decoded, Tomcat apparently decodes this string. You see ' '\n        // instead of '%20', which is what the browser has sent), latter may occur in some\n        // proxy or URL-rewriting setups where extra slashes are inadvertently added.\n        String furl = f.getUrl();\n        int slashCount = 0;\n        // Count components in ancestor URL\n        for (int i = furl.indexOf('/'); i >= 0; i = furl.indexOf('/', i + 1)) slashCount++;\n        // Remove that many from request URL, ignoring extra slashes\n        String rest = reqUri.replaceFirst(\"(?:/+[^/]*){\" + slashCount + \"}\", \"\");\n\n        return new RunUrl( (Run) f.getObject(), head, base, rest);\n    }\n\n    /**\n     * If we know the user's screen resolution, return it. Otherwise null.\n     * @since 1.213\n     */\n    public static Area getScreenResolution() {\n        Cookie res = Functions.getCookie(Stapler.getCurrentRequest(),\"screenResolution\");\n        if(res!=null)\n            return Area.parse(res.getValue());\n        return null;\n    }\n\n    /**\n     * URL decomposed for easier computation of relevant URLs.\n     *\n     * <p>\n     * The decomposed URL will be of the form:\n     * <pre>\n     * aaaaaa/524/bbbbb/cccc\n     * -head-| N |---rest---\n     * ----- base -----|\n     * </pre>\n     *\n     * <p>\n     * The head portion is the part of the URL from the {@link jenkins.model.Jenkins}\n     * object to the first {@link Run} subtype. When \"next/prev build\"\n     * is chosen, this part remains intact.\n     *\n     * <p>\n     * The <tt>524</tt> is the path from {@link Job} to {@link Run}.\n     *\n     * <p>\n     * The <tt>bbb</tt> portion is the path after that till the last\n     * {@link Run} subtype. The <tt>ccc</tt> portion is the part\n     * after that.\n     */\n    public static final class RunUrl {\n        private final String head, base, rest;\n        private final Run run;\n\n\n        public RunUrl(Run run, String head, String base, String rest) {\n            this.run = run;\n            this.head = head;\n            this.base = base;\n            this.rest = rest;\n        }\n\n        public String getBaseUrl() {\n            return base;\n        }\n\n        /**\n         * Returns the same page in the next build.\n         */\n        public String getNextBuildUrl() {\n            return getUrl(run.getNextBuild());\n        }\n\n        /**\n         * Returns the same page in the previous build.\n         */\n        public String getPreviousBuildUrl() {\n            return getUrl(run.getPreviousBuild());\n        }\n\n        private String getUrl(Run n) {\n            if(n ==null)\n                return null;\n            else {\n                return head+n.getNumber()+rest;\n            }\n        }\n    }\n\n    public static Node.Mode[] getNodeModes() {\n        return Node.Mode.values();\n    }\n\n    public static String getProjectListString(List<Project> projects) {\n        return Items.toNameList(projects);\n    }\n\n    /**\n     * @deprecated as of 1.294\n     *      JEXL now supports the real ternary operator \"x?y:z\", so this work around\n     *      is no longer necessary.\n     */\n    public static Object ifThenElse(boolean cond, Object thenValue, Object elseValue) {\n        return cond ? thenValue : elseValue;\n    }\n\n    public static String appendIfNotNull(String text, String suffix, String nullText) {\n        return text == null ? nullText : text + suffix;\n    }\n\n    public static Map getSystemProperties() {\n        return new TreeMap<Object,Object>(System.getProperties());\n    }\n\n    public static Map getEnvVars() {\n        return new TreeMap<String,String>(EnvVars.masterEnvVars);\n    }\n\n    public static boolean isWindows() {\n        return File.pathSeparatorChar==';';\n    }\n\n    public static List<LogRecord> getLogRecords() {\n        return Jenkins.logRecords;\n    }\n\n    public static String printLogRecord(LogRecord r) {\n        return formatter.format(r);\n    }\n\n    public static Cookie getCookie(HttpServletRequest req,String name) {\n        Cookie[] cookies = req.getCookies();\n        if(cookies!=null) {\n            for (Cookie cookie : cookies) {\n                if(cookie.getName().equals(name)) {\n                    return cookie;\n                }\n            }\n        }\n        return null;\n    }\n\n    public static String getCookie(HttpServletRequest req,String name, String defaultValue) {\n        Cookie c = getCookie(req, name);\n        if(c==null || c.getValue()==null) return defaultValue;\n        return c.getValue();\n    }\n\n    /**\n     * Gets the suffix to use for YUI JavaScript.\n     */\n    public static String getYuiSuffix() {\n        return DEBUG_YUI ? \"debug\" : \"min\";\n    }\n\n    /**\n     * Set to true if you need to use the debug version of YUI.\n     */\n    public static boolean DEBUG_YUI = Boolean.getBoolean(\"debug.YUI\");\n\n    /**\n     * Creates a sub map by using the given range (both ends inclusive).\n     */\n    public static <V> SortedMap<Integer,V> filter(SortedMap<Integer,V> map, String from, String to) {\n        if(from==null && to==null)      return map;\n        if(to==null)\n            return map.headMap(Integer.parseInt(from)-1);\n        if(from==null)\n            return map.tailMap(Integer.parseInt(to));\n\n        return map.subMap(Integer.parseInt(to),Integer.parseInt(from)-1);\n    }\n\n    private static final SimpleFormatter formatter = new SimpleFormatter();\n\n    /**\n     * Used by <tt>layout.jelly</tt> to control the auto refresh behavior.\n     *\n     * @param noAutoRefresh\n     *      On certain pages, like a page with forms, will have annoying interference\n     *      with auto refresh. On those pages, disable auto-refresh.\n     */\n    public static void configureAutoRefresh(HttpServletRequest request, HttpServletResponse response, boolean noAutoRefresh) {\n        if(noAutoRefresh)\n            return;\n\n        String param = request.getParameter(\"auto_refresh\");\n        boolean refresh = isAutoRefresh(request);\n        if (param != null) {\n            refresh = Boolean.parseBoolean(param);\n            Cookie c = new Cookie(\"hudson_auto_refresh\", Boolean.toString(refresh));\n            // Need to set path or it will not stick from e.g. a project page to the dashboard.\n            // Using request.getContextPath() might work but it seems simpler to just use the hudson_ prefix\n            // to avoid conflicts with any other web apps that might be on the same machine.\n            c.setPath(\"/\");\n            c.setMaxAge(60*60*24*30); // persist it roughly for a month\n            response.addCookie(c);\n        }\n        if (refresh) {\n            response.addHeader(\"Refresh\", System.getProperty(\"hudson.Functions.autoRefreshSeconds\", \"10\"));\n        }\n    }\n\n    public static boolean isAutoRefresh(HttpServletRequest request) {\n        String param = request.getParameter(\"auto_refresh\");\n        if (param != null) {\n            return Boolean.parseBoolean(param);\n        }\n        Cookie[] cookies = request.getCookies();\n        if(cookies==null)\n            return false; // when API design messes it up, we all suffer\n\n        for (Cookie c : cookies) {\n            if (c.getName().equals(\"hudson_auto_refresh\")) {\n                return Boolean.parseBoolean(c.getValue());\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Finds the given object in the ancestor list and returns its URL.\n     * This is used to determine the \"current\" URL assigned to the given object,\n     * so that one can compute relative URLs from it.\n     */\n    public static String getNearestAncestorUrl(StaplerRequest req,Object it) {\n        List list = req.getAncestors();\n        for( int i=list.size()-1; i>=0; i-- ) {\n            Ancestor anc = (Ancestor) list.get(i);\n            if(anc.getObject()==it)\n                return anc.getUrl();\n        }\n        return null;\n    }\n\n    /**\n     * Finds the inner-most {@link SearchableModelObject} in scope.\n     */\n    public static String getSearchURL() {\n        List list = Stapler.getCurrentRequest().getAncestors();\n        for( int i=list.size()-1; i>=0; i-- ) {\n            Ancestor anc = (Ancestor) list.get(i);\n            if(anc.getObject() instanceof SearchableModelObject)\n                return anc.getUrl()+\"/search/\";\n        }\n        return null;\n    }\n\n    public static String appendSpaceIfNotNull(String n) {\n        if(n==null) return null;\n        else        return n+' ';\n    }\n\n    /**\n     * One nbsp per 10 pixels in given size, which may be a plain number or \"NxN\"\n     * (like an iconSize).  Useful in a sortable table heading.\n     */\n    public static String nbspIndent(String size) {\n        int i = size.indexOf('x');\n        i = Integer.parseInt(i > 0 ? size.substring(0, i) : size) / 10;\n        StringBuilder buf = new StringBuilder(30);\n        for (int j = 0; j < i; j++)\n            buf.append(\"&nbsp;\");\n        return buf.toString();\n    }\n\n    public static String getWin32ErrorMessage(IOException e) {\n        return Util.getWin32ErrorMessage(e);\n    }\n\n    public static boolean isMultiline(String s) {\n        if(s==null)     return false;\n        return s.indexOf('\\r')>=0 || s.indexOf('\\n')>=0;\n    }\n\n    public static String encode(String s) {\n        return Util.encode(s);\n    }\n\n    public static String escape(String s) {\n        return Util.escape(s);\n    }\n\n    public static String xmlEscape(String s) {\n        return Util.xmlEscape(s);\n    }\n\n    public static String xmlUnescape(String s) {\n        return s.replace(\"&lt;\",\"<\").replace(\"&gt;\",\">\").replace(\"&amp;\",\"&\");\n    }\n\n    public static String htmlAttributeEscape(String text) {\n        StringBuilder buf = new StringBuilder(text.length()+64);\n        for( int i=0; i<text.length(); i++ ) {\n            char ch = text.charAt(i);\n            if(ch=='<')\n                buf.append(\"&lt;\");\n            else\n            if(ch=='>')\n                buf.append(\"&gt;\");\n            else\n            if(ch=='&')\n                buf.append(\"&amp;\");\n            else\n            if(ch=='\"')\n                buf.append(\"&quot;\");\n            else\n            if(ch=='\\'')\n                buf.append(\"&#39;\");\n            else\n                buf.append(ch);\n        }\n        return buf.toString();\n    }\n\n    public static void checkPermission(Permission permission) throws IOException, ServletException {\n        checkPermission(Jenkins.getInstance(),permission);\n    }\n\n    public static void checkPermission(AccessControlled object, Permission permission) throws IOException, ServletException {\n        if (permission != null) {\n            object.checkPermission(permission);\n        }\n    }\n\n    /**\n     * This version is so that the 'checkPermission' on <tt>layout.jelly</tt>\n     * degrades gracefully if \"it\" is not an {@link AccessControlled} object.\n     * Otherwise it will perform no check and that problem is hard to notice.\n     */\n    public static void checkPermission(Object object, Permission permission) throws IOException, ServletException {\n        if (permission == null)\n            return;\n        \n        if (object instanceof AccessControlled)\n            checkPermission((AccessControlled) object,permission);\n        else {\n            List<Ancestor> ancs = Stapler.getCurrentRequest().getAncestors();\n            for(Ancestor anc : Iterators.reverse(ancs)) {\n                Object o = anc.getObject();\n                if (o instanceof AccessControlled) {\n                    checkPermission((AccessControlled) o,permission);\n                    return;\n                }\n            }\n            checkPermission(Jenkins.getInstance(),permission);\n        }\n    }\n\n    /**\n     * Returns true if the current user has the given permission.\n     *\n     * @param permission\n     *      If null, returns true. This defaulting is convenient in making the use of this method terse.\n     */\n    public static boolean hasPermission(Permission permission) throws IOException, ServletException {\n        return hasPermission(Jenkins.getInstance(),permission);\n    }\n\n    /**\n     * This version is so that the 'hasPermission' can degrade gracefully\n     * if \"it\" is not an {@link AccessControlled} object.\n     */\n    public static boolean hasPermission(Object object, Permission permission) throws IOException, ServletException {\n        if (permission == null)\n            return true;\n        if (object instanceof AccessControlled)\n            return ((AccessControlled)object).hasPermission(permission);\n        else {\n            List<Ancestor> ancs = Stapler.getCurrentRequest().getAncestors();\n            for(Ancestor anc : Iterators.reverse(ancs)) {\n                Object o = anc.getObject();\n                if (o instanceof AccessControlled) {\n                    return ((AccessControlled)o).hasPermission(permission);\n                }\n            }\n            return Jenkins.getInstance().hasPermission(permission);\n        }\n    }\n\n    public static void adminCheck(StaplerRequest req, StaplerResponse rsp, Object required, Permission permission) throws IOException, ServletException {\n        // this is legacy --- all views should be eventually converted to\n        // the permission based model.\n        if(required!=null && !Hudson.adminCheck(req, rsp)) {\n            // check failed. commit the FORBIDDEN response, then abort.\n            rsp.setStatus(HttpServletResponse.SC_FORBIDDEN);\n            rsp.getOutputStream().close();\n            throw new ServletException(\"Unauthorized access\");\n        }\n\n        // make sure the user owns the necessary permission to access this page.\n        if(permission!=null)\n            checkPermission(permission);\n    }\n\n    /**\n     * Infers the hudson installation URL from the given request.\n     */\n    public static String inferHudsonURL(StaplerRequest req) {\n        String rootUrl = Jenkins.getInstance().getRootUrl();\n        if(rootUrl !=null)\n            // prefer the one explicitly configured, to work with load-balancer, frontend, etc.\n            return rootUrl;\n        StringBuilder buf = new StringBuilder();\n        buf.append(req.getScheme()).append(\"://\");\n        buf.append(req.getServerName());\n        if(! (req.getScheme().equals(\"http\") && req.getLocalPort()==80 || req.getScheme().equals(\"https\") && req.getLocalPort()==443))\n            buf.append(':').append(req.getLocalPort());\n        buf.append(req.getContextPath()).append('/');\n        return buf.toString();\n    }\n\n    /**\n     * Returns the link to be displayed in the footer of the UI.\n     */\n    public static String getFooterURL() {\n        if(footerURL == null) {\n            footerURL = System.getProperty(\"hudson.footerURL\");\n            if(StringUtils.isBlank(footerURL)) {\n                footerURL = \"http://jenkins-ci.org/\";\n            }\n        }\n        return footerURL;\n    }\n    private static String footerURL = null;\n\n    public static List<JobPropertyDescriptor> getJobPropertyDescriptors(Class<? extends Job> clazz) {\n        return JobPropertyDescriptor.getPropertyDescriptors(clazz);\n    }\n\n    public static List<Descriptor<BuildWrapper>> getBuildWrapperDescriptors(AbstractProject<?,?> project) {\n        return BuildWrappers.getFor(project);\n    }\n\n    public static List<Descriptor<SecurityRealm>> getSecurityRealmDescriptors() {\n        return SecurityRealm.all();\n    }\n\n    public static List<Descriptor<AuthorizationStrategy>> getAuthorizationStrategyDescriptors() {\n        return AuthorizationStrategy.all();\n    }\n\n    public static List<Descriptor<Builder>> getBuilderDescriptors(AbstractProject<?,?> project) {\n        return BuildStepDescriptor.filter(Builder.all(), project.getClass());\n    }\n\n    public static List<Descriptor<Publisher>> getPublisherDescriptors(AbstractProject<?,?> project) {\n        return BuildStepDescriptor.filter(Publisher.all(), project.getClass());\n    }\n\n    public static List<SCMDescriptor<?>> getSCMDescriptors(AbstractProject<?,?> project) {\n        return SCM._for(project);\n    }\n\n    public static List<Descriptor<ComputerLauncher>> getComputerLauncherDescriptors() {\n        return Jenkins.getInstance().<ComputerLauncher,Descriptor<ComputerLauncher>>getDescriptorList(ComputerLauncher.class);\n    }\n\n    public static List<Descriptor<RetentionStrategy<?>>> getRetentionStrategyDescriptors() {\n        return RetentionStrategy.all();\n    }\n\n    public static List<ParameterDescriptor> getParameterDescriptors() {\n        return ParameterDefinition.all();\n    }\n\n    public static List<Descriptor<CaptchaSupport>> getCaptchaSupportDescriptors() {\n        return CaptchaSupport.all();\n    }\n\n    public static List<Descriptor<ViewsTabBar>> getViewsTabBarDescriptors() {\n        return ViewsTabBar.all();\n    }\n\n    public static List<Descriptor<MyViewsTabBar>> getMyViewsTabBarDescriptors() {\n        return MyViewsTabBar.all();\n    }\n\n    public static List<NodePropertyDescriptor> getNodePropertyDescriptors(Class<? extends Node> clazz) {\n        List<NodePropertyDescriptor> result = new ArrayList<NodePropertyDescriptor>();\n        Collection<NodePropertyDescriptor> list = (Collection) Jenkins.getInstance().getDescriptorList(NodeProperty.class);\n        for (NodePropertyDescriptor npd : list) {\n            if (npd.isApplicable(clazz)) {\n                result.add(npd);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Gets all the descriptors sorted by their inheritance tree of {@link Describable}\n     * so that descriptors of similar types come nearby.\n     *\n     * <p>\n     * We sort them by {@link Extension#ordinal()} but only for {@link GlobalConfiguration}s,\n     * as the value is normally used to compare similar kinds of extensions, and we needed\n     * {@link GlobalConfiguration}s to be able to position themselves in a layer above.\n     * This however creates some asymmetry between regular {@link Descriptor}s and {@link GlobalConfiguration}s.\n     * Perhaps it is better to introduce another annotation element? But then,\n     * extensions shouldn't normally concern themselves about ordering too much, and the only reason\n     * we needed this for {@link GlobalConfiguration}s are for backward compatibility.\n     *\n     * @param predicate\n     *      Filter the descriptors based on {@link GlobalConfigurationCategory}\n     * @since 1.494\n     */\n    public static Collection<Descriptor> getSortedDescriptorsForGlobalConfig(Predicate<GlobalConfigurationCategory> predicate) {\n        ExtensionList<Descriptor> exts = Jenkins.getInstance().getExtensionList(Descriptor.class);\n        List<Tag> r = new ArrayList<Tag>(exts.size());\n\n        for (ExtensionComponent<Descriptor> c : exts.getComponents()) {\n            Descriptor d = c.getInstance();\n            if (d.getGlobalConfigPage()==null)  continue;\n\n            if (d instanceof GlobalConfiguration) {\n                if (predicate.apply(((GlobalConfiguration)d).getCategory()))\n                    r.add(new Tag(c.ordinal(), d));\n            } else {\n                if (predicate.apply(GlobalConfigurationCategory.get(Unclassified.class)))\n                    r.add(new Tag(0, d));\n            }\n        }\n        Collections.sort(r);\n\n        List<Descriptor> answer = new ArrayList<Descriptor>(r.size());\n        for (Tag d : r) answer.add(d.d);\n\n        return DescriptorVisibilityFilter.apply(Jenkins.getInstance(),answer);\n    }\n\n    /**\n     * Like {@link #getSortedDescriptorsForGlobalConfig(Predicate)} but with a constant truth predicate, to include all descriptors.\n     */\n    public static Collection<Descriptor> getSortedDescriptorsForGlobalConfig() {\n        return getSortedDescriptorsForGlobalConfig(Predicates.<GlobalConfigurationCategory>alwaysTrue());\n    }\n\n    /**\n     * @deprecated This is rather meaningless.\n     */\n    @Deprecated\n    public static Collection<Descriptor> getSortedDescriptorsForGlobalConfigNoSecurity() {\n        return getSortedDescriptorsForGlobalConfig(Predicates.not(GlobalSecurityConfiguration.FILTER));\n    }\n\n    /**\n     * Like {@link #getSortedDescriptorsForGlobalConfig(Predicate)} but for unclassified descriptors only.\n     * @since 1.506\n     */\n    public static Collection<Descriptor> getSortedDescriptorsForGlobalConfigUnclassified() {\n        return getSortedDescriptorsForGlobalConfig(new Predicate<GlobalConfigurationCategory>() {\n            public boolean apply(GlobalConfigurationCategory cat) {\n                return cat instanceof GlobalConfigurationCategory.Unclassified;\n            }\n        });\n    }\n    \n    private static class Tag implements Comparable<Tag> {\n        double ordinal;\n        String hierarchy;\n        Descriptor d;\n\n        Tag(double ordinal, Descriptor d) {\n            this.ordinal = ordinal;\n            this.d = d;\n            this.hierarchy = buildSuperclassHierarchy(d.clazz, new StringBuilder()).toString();\n        }\n\n        private StringBuilder buildSuperclassHierarchy(Class c, StringBuilder buf) {\n            Class sc = c.getSuperclass();\n            if (sc!=null)   buildSuperclassHierarchy(sc,buf).append(':');\n            return buf.append(c.getName());\n        }\n\n        public int compareTo(Tag that) {\n            int r = Double.compare(this.ordinal, that.ordinal);\n            if (r!=0)   return -r; // descending for ordinal\n            return this.hierarchy.compareTo(that.hierarchy);\n        }\n    }\n    /**\n     * Computes the path to the icon of the given action\n     * from the context path.\n     */\n    public static String getIconFilePath(Action a) {\n        String name = a.getIconFileName();\n        if (name==null)     return null;\n        if (name.startsWith(\"/\"))\n            return name.substring(1);\n        else\n            return \"images/24x24/\"+name;\n    }\n\n    /**\n     * Works like JSTL build-in size(x) function,\n     * but handle null gracefully.\n     */\n    public static int size2(Object o) throws Exception {\n        if(o==null) return 0;\n        return ASTSizeFunction.sizeOf(o,Introspector.getUberspect());\n    }\n\n    /**\n     * Computes the relative path from the current page to the given item.\n     */\n    public static String getRelativeLinkTo(Item p) {\n        Map<Object,String> ancestors = new HashMap<Object,String>();\n        View view=null;\n\n        StaplerRequest request = Stapler.getCurrentRequest();\n        for( Ancestor a : request.getAncestors() ) {\n            ancestors.put(a.getObject(),a.getRelativePath());\n            if(a.getObject() instanceof View)\n                view = (View) a.getObject();\n        }\n\n        String path = ancestors.get(p);\n        if(path!=null)  return path;\n\n        Item i=p;\n        String url = \"\";\n        while(true) {\n            ItemGroup ig = i.getParent();\n            url = i.getShortUrl()+url;\n\n            if(ig== Jenkins.getInstance()) {\n                assert i instanceof TopLevelItem;\n                if(view!=null && view.contains((TopLevelItem)i)) {\n                    // if p and the current page belongs to the same view, then return a relative path\n                    return ancestors.get(view)+'/'+url;\n                } else {\n                    // otherwise return a path from the root Hudson\n                    return request.getContextPath()+'/'+p.getUrl();\n                }\n            }\n\n            path = ancestors.get(ig);\n            if(path!=null)  return path+'/'+url;\n\n            assert ig instanceof Item; // if not, ig must have been the Hudson instance\n            i = (Item) ig;\n        }\n    }\n\n    public static Map<Thread,StackTraceElement[]> dumpAllThreads() {\n        Map<Thread,StackTraceElement[]> sorted = new TreeMap<Thread,StackTraceElement[]>(new ThreadSorter());\n        sorted.putAll(Thread.getAllStackTraces());\n        return sorted;\n    }\n\n    @IgnoreJRERequirement\n    public static ThreadInfo[] getThreadInfos() {\n        ThreadMXBean mbean = ManagementFactory.getThreadMXBean();\n        return mbean.dumpAllThreads(mbean.isObjectMonitorUsageSupported(),mbean.isSynchronizerUsageSupported());\n    }\n\n    public static ThreadGroupMap sortThreadsAndGetGroupMap(ThreadInfo[] list) {\n        ThreadGroupMap sorter = new ThreadGroupMap();\n        Arrays.sort(list, sorter);\n        return sorter;\n    }\n\n    // Common code for sorting Threads/ThreadInfos by ThreadGroup\n    private static class ThreadSorterBase {\n        protected Map<Long,String> map = new HashMap<Long,String>();\n\n        private ThreadSorterBase() {\n            ThreadGroup tg = Thread.currentThread().getThreadGroup();\n            while (tg.getParent() != null) tg = tg.getParent();\n            Thread[] threads = new Thread[tg.activeCount()*2];\n            int threadsLen = tg.enumerate(threads, true);\n            for (int i = 0; i < threadsLen; i++)\n                map.put(threads[i].getId(), threads[i].getThreadGroup().getName());\n        }\n\n        protected int compare(long idA, long idB) {\n            String tga = map.get(idA), tgb = map.get(idB);\n            int result = (tga!=null?-1:0) + (tgb!=null?1:0);  // Will be non-zero if only one is null\n            if (result==0 && tga!=null)\n                result = tga.compareToIgnoreCase(tgb);\n            return result;\n        }\n    }\n\n    public static class ThreadGroupMap extends ThreadSorterBase implements Comparator<ThreadInfo> {\n\n        /**\n         * @return ThreadGroup name or null if unknown\n         */\n        public String getThreadGroup(ThreadInfo ti) {\n            return map.get(ti.getThreadId());\n        }\n\n        public int compare(ThreadInfo a, ThreadInfo b) {\n            int result = compare(a.getThreadId(), b.getThreadId());\n            if (result == 0)\n                result = a.getThreadName().compareToIgnoreCase(b.getThreadName());\n            return result;\n        }\n    }\n\n    private static class ThreadSorter extends ThreadSorterBase implements Comparator<Thread> {\n\n        public int compare(Thread a, Thread b) {\n            int result = compare(a.getId(), b.getId());\n            if (result == 0)\n                result = a.getName().compareToIgnoreCase(b.getName());\n            return result;\n        }\n    }\n\n    /**\n     * Are we running on JRE6 or above?\n     */\n    @IgnoreJRERequirement\n    public static boolean isMustangOrAbove() {\n        try {\n            System.console();\n            return true;\n        } catch(LinkageError e) {\n            return false;\n        }\n    }\n\n    // ThreadInfo.toString() truncates the stack trace by first 8, so needed my own version\n    @IgnoreJRERequirement\n    public static String dumpThreadInfo(ThreadInfo ti, ThreadGroupMap map) {\n        String grp = map.getThreadGroup(ti);\n        StringBuilder sb = new StringBuilder(\"\\\"\" + ti.getThreadName() + \"\\\"\" +\n                                             \" Id=\" + ti.getThreadId() + \" Group=\" +\n                                             (grp != null ? grp : \"?\") + \" \" +\n                                             ti.getThreadState());\n        if (ti.getLockName() != null) {\n            sb.append(\" on \" + ti.getLockName());\n        }\n        if (ti.getLockOwnerName() != null) {\n            sb.append(\" owned by \\\"\" + ti.getLockOwnerName() +\n                      \"\\\" Id=\" + ti.getLockOwnerId());\n        }\n        if (ti.isSuspended()) {\n            sb.append(\" (suspended)\");\n        }\n        if (ti.isInNative()) {\n            sb.append(\" (in native)\");\n        }\n        sb.append('\\n');\n        StackTraceElement[] stackTrace = ti.getStackTrace();\n        for (int i=0; i < stackTrace.length; i++) {\n            StackTraceElement ste = stackTrace[i];\n            sb.append(\"\\tat \" + ste.toString());\n            sb.append('\\n');\n            if (i == 0 && ti.getLockInfo() != null) {\n                Thread.State ts = ti.getThreadState();\n                switch (ts) {\n                    case BLOCKED:\n                        sb.append(\"\\t-  blocked on \" + ti.getLockInfo());\n                        sb.append('\\n');\n                        break;\n                    case WAITING:\n                        sb.append(\"\\t-  waiting on \" + ti.getLockInfo());\n                        sb.append('\\n');\n                        break;\n                    case TIMED_WAITING:\n                        sb.append(\"\\t-  waiting on \" + ti.getLockInfo());\n                        sb.append('\\n');\n                        break;\n                    default:\n                }\n            }\n\n            for (MonitorInfo mi : ti.getLockedMonitors()) {\n                if (mi.getLockedStackDepth() == i) {\n                    sb.append(\"\\t-  locked \" + mi);\n                    sb.append('\\n');\n                }\n            }\n       }\n\n       LockInfo[] locks = ti.getLockedSynchronizers();\n       if (locks.length > 0) {\n           sb.append(\"\\n\\tNumber of locked synchronizers = \" + locks.length);\n           sb.append('\\n');\n           for (LockInfo li : locks) {\n               sb.append(\"\\t- \" + li);\n               sb.append('\\n');\n           }\n       }\n       sb.append('\\n');\n       return sb.toString();\n    }\n\n    public static <T> Collection<T> emptyList() {\n        return Collections.emptyList();\n    }\n\n    public static String jsStringEscape(String s) {\n        StringBuilder buf = new StringBuilder();\n        for( int i=0; i<s.length(); i++ ) {\n            char ch = s.charAt(i);\n            switch(ch) {\n            case '\\'':\n                buf.append(\"\\\\'\");\n                break;\n            case '\\\\':\n                buf.append(\"\\\\\\\\\");\n                break;\n            case '\"':\n                buf.append(\"\\\\\\\"\");\n                break;\n            default:\n                buf.append(ch);\n            }\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Converts \"abc\" to \"Abc\".\n     */\n    public static String capitalize(String s) {\n        if(s==null || s.length()==0) return s;\n        return Character.toUpperCase(s.charAt(0))+s.substring(1);\n    }\n\n    public static String getVersion() {\n        return Jenkins.VERSION;\n    }\n\n    /**\n     * Resoruce path prefix.\n     */\n    public static String getResourcePath() {\n        return Jenkins.RESOURCE_PATH;\n    }\n\n    public static String getViewResource(Object it, String path) {\n        Class clazz = it.getClass();\n\n        if(it instanceof Class)\n            clazz = (Class)it;\n        if(it instanceof Descriptor)\n            clazz = ((Descriptor)it).clazz;\n\n        StringBuilder buf = new StringBuilder(Stapler.getCurrentRequest().getContextPath());\n        buf.append(Jenkins.VIEW_RESOURCE_PATH).append('/');\n        buf.append(clazz.getName().replace('.','/').replace('$','/'));\n        buf.append('/').append(path);\n\n        return buf.toString();\n    }\n\n    public static boolean hasView(Object it, String path) throws IOException {\n        if(it==null)    return false;\n        return Stapler.getCurrentRequest().getView(it,path)!=null;\n    }\n\n    /**\n     * Can be used to check a checkbox by default.\n     * Used from views like {@code h.defaultToTrue(scm.useUpdate)}.\n     * The expression will evaluate to true if scm is null.\n     */\n    public static boolean defaultToTrue(Boolean b) {\n        if(b==null) return true;\n        return b;\n    }\n\n    /**\n     * If the value exists, return that value. Otherwise return the default value.\n     * <p>\n     * Starting 1.294, JEXL supports the elvis operator \"x?:y\" that supercedes this.\n     *\n     * @since 1.150\n     */\n    public static <T> T defaulted(T value, T defaultValue) {\n        return value!=null ? value : defaultValue;\n    }\n\n    public static String printThrowable(Throwable t) {\n        StringWriter sw = new StringWriter();\n        t.printStackTrace(new PrintWriter(sw));\n        return sw.toString();\n    }\n\n    /**\n     * Counts the number of rows needed for textarea to fit the content.\n     * Minimum 5 rows.\n     */\n    public static int determineRows(String s) {\n        if(s==null)     return 5;\n        return Math.max(5,LINE_END.split(s).length);\n    }\n\n    /**\n     * Converts the Hudson build status to CruiseControl build status,\n     * which is either Success, Failure, Exception, or Unknown.\n     */\n    public static String toCCStatus(Item i) {\n        if (i instanceof Job) {\n            Job j = (Job) i;\n            switch (j.getIconColor().noAnime()) {\n            case ABORTED:\n            case RED:\n            case YELLOW:\n                return \"Failure\";\n            case BLUE:\n                return \"Success\";\n            case DISABLED:\n            case GREY:\n                return \"Unknown\";\n            }\n        }\n        return \"Unknown\";\n    }\n\n    private static final Pattern LINE_END = Pattern.compile(\"\\r?\\n\");\n\n    /**\n     * Checks if the current user is anonymous.\n     */\n    public static boolean isAnonymous() {\n        return Jenkins.getAuthentication() instanceof AnonymousAuthenticationToken;\n    }\n\n    /**\n     * When called from within JEXL expression evaluation,\n     * this method returns the current {@link JellyContext} used\n     * to evaluate the script.\n     *\n     * @since 1.164\n     */\n    public static JellyContext getCurrentJellyContext() {\n        JellyContext context = ExpressionFactory2.CURRENT_CONTEXT.get();\n        assert context!=null;\n        return context;\n    }\n\n    /**\n     * Evaluate a Jelly script and return output as a String.\n     *\n     * @since 1.267\n     */\n    public static String runScript(Script script) throws JellyTagException {\n        StringWriter out = new StringWriter();\n        script.run(getCurrentJellyContext(), XMLOutput.createXMLOutput(out));\n        return out.toString();\n    }\n\n    /**\n     * Returns a sub-list if the given list is bigger than the specified 'maxSize'\n     */\n    public static <T> List<T> subList(List<T> base, int maxSize) {\n        if(maxSize<base.size())\n            return base.subList(0,maxSize);\n        else\n            return base;\n    }\n\n    /**\n     * Combine path components via '/' while handling leading/trailing '/' to avoid duplicates.\n     */\n    public static String joinPath(String... components) {\n        StringBuilder buf = new StringBuilder();\n        for (String s : components) {\n            if (s.length()==0)  continue;\n\n            if (buf.length()>0) {\n                if (buf.charAt(buf.length()-1)!='/')\n                    buf.append('/');\n                if (s.charAt(0)=='/')   s=s.substring(1);\n            }\n            buf.append(s);\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Computes the hyperlink to actions, to handle the situation when the {@link Action#getUrlName()}\n     * returns absolute URL.\n     */\n    public static String getActionUrl(String itUrl,Action action) {\n        String urlName = action.getUrlName();\n        if(urlName==null)   return null;    // to avoid NPE and fail to render the whole page\n        try {\n            if (new URI(urlName).isAbsolute()) {\n                return urlName;\n            }\n        } catch (URISyntaxException x) {\n            Logger.getLogger(Functions.class.getName()).log(Level.WARNING, \"Failed to parse URL for {0}: {1}\", new Object[] {action, x});\n            return null;\n        }\n        if(urlName.startsWith(\"/\"))\n            return joinPath(Stapler.getCurrentRequest().getContextPath(),urlName);\n        else\n            // relative URL name\n            return joinPath(Stapler.getCurrentRequest().getContextPath()+'/'+itUrl,urlName);\n    }\n\n    /**\n     * Escapes the character unsafe for e-mail address.\n     * See http://en.wikipedia.org/wiki/E-mail_address for the details,\n     * but here the vocabulary is even more restricted.\n     */\n    public static String toEmailSafeString(String projectName) {\n        // TODO: escape non-ASCII characters\n        StringBuilder buf = new StringBuilder(projectName.length());\n        for( int i=0; i<projectName.length(); i++ ) {\n            char ch = projectName.charAt(i);\n            if(('a'<=ch && ch<='z')\n            || ('z'<=ch && ch<='Z')\n            || ('0'<=ch && ch<='9')\n            || \"-_.\".indexOf(ch)>=0)\n                buf.append(ch);\n            else\n                buf.append('_');    // escape\n        }\n        return projectName;\n    }\n\n    public String getSystemProperty(String key) {\n        return System.getProperty(key);\n    }\n\n    /**\n     * Obtains the host name of the Hudson server that clients can use to talk back to.\n     * <p>\n     * This is primarily used in <tt>slave-agent.jnlp.jelly</tt> to specify the destination\n     * that the slaves talk to.\n     */\n    public String getServerName() {\n        // Try to infer this from the configured root URL.\n        // This makes it work correctly when Hudson runs behind a reverse proxy.\n        String url = Jenkins.getInstance().getRootUrl();\n        try {\n            if(url!=null) {\n                String host = new URL(url).getHost();\n                if(host!=null)\n                    return host;\n            }\n        } catch (MalformedURLException e) {\n            // fall back to HTTP request\n        }\n        return Stapler.getCurrentRequest().getServerName();\n    }\n\n    /**\n     * Determines the form validation check URL. See textbox.jelly\n     */\n    public String getCheckUrl(String userDefined, Object descriptor, String field) {\n        if(userDefined!=null || field==null)   return userDefined;\n        if (descriptor instanceof Descriptor) {\n            Descriptor d = (Descriptor) descriptor;\n            return d.getCheckUrl(field);\n        }\n        return null;\n    }\n\n    /**\n     * If the given href link is matching the current page, return true.\n     *\n     * Used in <tt>task.jelly</tt> to decide if the page should be highlighted.\n     */\n    public boolean hyperlinkMatchesCurrentPage(String href) throws UnsupportedEncodingException {\n        String url = Stapler.getCurrentRequest().getRequestURL().toString();\n        if (href == null || href.length() <= 1) return \".\".equals(href) && url.endsWith(\"/\");\n        url = URLDecoder.decode(url,\"UTF-8\");\n        href = URLDecoder.decode(href,\"UTF-8\");\n        if (url.endsWith(\"/\")) url = url.substring(0, url.length() - 1);\n        if (href.endsWith(\"/\")) href = href.substring(0, href.length() - 1);\n\n        return url.endsWith(href);\n    }\n\n    public <T> List<T> singletonList(T t) {\n        return Collections.singletonList(t);\n    }\n\n    /**\n     * Gets all the {@link PageDecorator}s.\n     */\n    public static List<PageDecorator> getPageDecorators() {\n        // this method may be called to render start up errors, at which point Hudson doesn't exist yet. see HUDSON-3608 \n        if(Jenkins.getInstance()==null)  return Collections.emptyList();\n        return PageDecorator.all();\n    }\n    \n    public static List<Descriptor<Cloud>> getCloudDescriptors() {\n        return Cloud.all();\n    }\n\n    /**\n     * Prepend a prefix only when there's the specified body.\n     */\n    public String prepend(String prefix, String body) {\n        if(body!=null && body.length()>0)\n            return prefix+body;\n        return body;\n    }\n\n    public static List<Descriptor<CrumbIssuer>> getCrumbIssuerDescriptors() {\n        return CrumbIssuer.all();\n    }\n\n    public static String getCrumb(StaplerRequest req) {\n        Jenkins h = Jenkins.getInstance();\n        CrumbIssuer issuer = h != null ? h.getCrumbIssuer() : null;\n        return issuer != null ? issuer.getCrumb(req) : \"\";\n    }\n\n    public static String getCrumbRequestField() {\n        Jenkins h = Jenkins.getInstance();\n        CrumbIssuer issuer = h != null ? h.getCrumbIssuer() : null;\n        return issuer != null ? issuer.getDescriptor().getCrumbRequestField() : \"\";\n    }\n\n    public static Date getCurrentTime() {\n        return new Date();\n    }\n\n    public static Locale getCurrentLocale() {\n        Locale locale=null;\n        StaplerRequest req = Stapler.getCurrentRequest();\n        if(req!=null)\n            locale = req.getLocale();\n        if(locale==null)\n            locale = Locale.getDefault();\n        return locale;\n    }\n\n    /**\n     * Generate a series of &lt;script> tags to include <tt>script.js</tt>\n     * from {@link ConsoleAnnotatorFactory}s and {@link ConsoleAnnotationDescriptor}s.\n     */\n    public static String generateConsoleAnnotationScriptAndStylesheet() {\n        String cp = Stapler.getCurrentRequest().getContextPath();\n        StringBuilder buf = new StringBuilder();\n        for (ConsoleAnnotatorFactory f : ConsoleAnnotatorFactory.all()) {\n            String path = cp + \"/extensionList/\" + ConsoleAnnotatorFactory.class.getName() + \"/\" + f.getClass().getName();\n            if (f.hasScript())\n                buf.append(\"<script src='\"+path+\"/script.js'></script>\");\n            if (f.hasStylesheet())\n                buf.append(\"<link rel='stylesheet' type='text/css' href='\"+path+\"/style.css' />\");\n        }\n        for (ConsoleAnnotationDescriptor d : ConsoleAnnotationDescriptor.all()) {\n            String path = cp+\"/descriptor/\"+d.clazz.getName();\n            if (d.hasScript())\n                buf.append(\"<script src='\"+path+\"/script.js'></script>\");\n            if (d.hasStylesheet())\n                buf.append(\"<link rel='stylesheet' type='text/css' href='\"+path+\"/style.css' />\");\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Work around for bug 6935026.\n     */\n    public List<String> getLoggerNames() {\n        while (true) {\n            try {\n                List<String> r = new ArrayList<String>();\n                Enumeration<String> e = LogManager.getLogManager().getLoggerNames();\n                while (e.hasMoreElements())\n                    r.add(e.nextElement());\n                return r;\n            } catch (ConcurrentModificationException e) {\n                // retry\n            }\n        }\n    }\n\n    /**\n     * Used by &lt;f:password/> so that we send an encrypted value to the client.\n     */\n    public String getPasswordValue(Object o) {\n        if (o==null)    return null;\n        if (o instanceof Secret)    return ((Secret)o).getEncryptedValue();\n        return o.toString();\n    }\n\n    public List filterDescriptors(Object context, Iterable descriptors) {\n        return DescriptorVisibilityFilter.apply(context,descriptors);\n    }\n    \n    /**\n     * Returns true if we are running unit tests.\n     */\n    public static boolean getIsUnitTest() {\n        return Main.isUnitTest;\n    }\n\n    /**\n     * Returns {@code true} if the {@link Run#ARTIFACTS} permission is enabled,\n     * {@code false} otherwise.\n     *\n     * <p>When the {@link Run#ARTIFACTS} permission is not turned on using the\n     * {@code hudson.security.ArtifactsPermission} system property, this\n     * permission must not be considered to be set to {@code false} for every\n     * user. It must rather be like if the permission doesn't exist at all\n     * (which means that every user has to have an access to the artifacts but\n     * the permission can't be configured in the security screen). Got it?</p>\n     */\n    public static boolean isArtifactsPermissionEnabled() {\n        return Boolean.getBoolean(\"hudson.security.ArtifactsPermission\");\n    }\n\n    /**\n     * Returns {@code true} if the {@link Item#WIPEOUT} permission is enabled,\n     * {@code false} otherwise.\n     *\n     * <p>The \"Wipe Out Workspace\" action available on jobs is controlled by the\n     * {@link Item#BUILD} permission. For some specific projects, however, it is\n     * not acceptable to let users have this possibility, even it they can\n     * trigger builds. As such, when enabling the {@code hudson.security.WipeOutPermission}\n     * system property, a new \"WipeOut\" permission will allow to have greater\n     * control on the \"Wipe Out Workspace\" action.</p>\n     */\n    public static boolean isWipeOutPermissionEnabled() {\n        return Boolean.getBoolean(\"hudson.security.WipeOutPermission\");\n    }\n\n    public static String createRenderOnDemandProxy(JellyContext context, String attributesToCapture) {\n        return Stapler.getCurrentRequest().createJavaScriptProxy(new RenderOnDemandClosure(context,attributesToCapture));\n    }\n\n    public static String getCurrentDescriptorByNameUrl() {\n        return Descriptor.getCurrentDescriptorByNameUrl();\n    }\n    \n    public static String setCurrentDescriptorByNameUrl(String value) {\n        String o = getCurrentDescriptorByNameUrl();\n        Stapler.getCurrentRequest().setAttribute(\"currentDescriptorByNameUrl\", value);\n\n        return o;\n    }\n\n    public static void restoreCurrentDescriptorByNameUrl(String old) {\n        Stapler.getCurrentRequest().setAttribute(\"currentDescriptorByNameUrl\", old);\n    }\n\n    public static List<String> getRequestHeaders(String name) {\n        List<String> r = new ArrayList<String>();\n        Enumeration e = Stapler.getCurrentRequest().getHeaders(name);\n        while (e.hasMoreElements()) {\n            r.add(e.nextElement().toString());\n        }\n        return r;\n    }\n\n    /**\n     * Used for arguments to internationalized expressions to avoid escape\n     */\n    public static Object rawHtml(Object o) {\n        return o==null ? null : new RawHtmlArgument(o);\n    }\n\n    public static ArrayList<CLICommand> getCLICommands() {\n        ArrayList<CLICommand> all = new ArrayList<CLICommand>(CLICommand.all());\n        Collections.sort(all, new Comparator<CLICommand>() {\n            public int compare(CLICommand cliCommand, CLICommand cliCommand1) {\n                return cliCommand.getName().compareTo(cliCommand1.getName());\n            }\n        });\n        return all;\n    }\n\n    /**\n     * Returns an avatar image URL for the specified user and preferred image size\n     * @param user the user\n     * @param avatarSize the preferred size of the avatar image\n     * @return a URL string\n     * @since 1.433\n     */\n    public static String getAvatar(User user, String avatarSize) {\n        return UserAvatarResolver.resolve(user, avatarSize);\n    }\n\n    /**\n     * @deprecated as of 1.451\n     *      Use {@link #getAvatar}\n     */\n    public String getUserAvatar(User user, String avatarSize) {\n        return getAvatar(user,avatarSize);\n    }\n    \n    \n    /**\n     * Returns human readable information about file size\n     * \n     * @param file size in bytes\n     * @return file size in appropriate unit\n     */\n    public static String humanReadableByteSize(long size){\n        String measure = \"B\";\n        if(size < 1024){\n            return size + \" \" + measure;\n        }\n        Double number = new Double(size);\n        if(number>=1024){\n            number = number/1024;\n            measure = \"KB\";\n            if(number>=1024){\n                number = number/1024;\n                measure = \"MB\";\n                if(number>=1024){\n                    number=number/1024;\n                    measure = \"GB\";\n                }\n            }\n        }\n        DecimalFormat format = new DecimalFormat(\"#0.00\");\n        return format.format(number) + \" \" + measure;\n    }\n}\n", "/*\n * The MIT License\n * \n * Copyright (c) 2004-2011, Sun Microsystems, Inc., Kohsuke Kawaguchi, Tom Huybrechts,\n * Yahoo!, Inc.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.model;\n\nimport com.thoughtworks.xstream.converters.ConversionException;\nimport com.thoughtworks.xstream.io.StreamException;\nimport com.thoughtworks.xstream.io.xml.XppDriver;\nimport hudson.DescriptorExtensionList;\nimport hudson.ExtensionPoint;\nimport hudson.Functions;\nimport hudson.Indenter;\nimport hudson.Util;\nimport hudson.model.Descriptor.FormException;\nimport hudson.model.labels.LabelAtomPropertyDescriptor;\nimport hudson.scm.ChangeLogSet;\nimport hudson.scm.ChangeLogSet.Entry;\nimport hudson.search.CollectionSearchIndex;\nimport hudson.search.SearchIndexBuilder;\nimport hudson.security.ACL;\nimport hudson.security.AccessControlled;\nimport hudson.security.Permission;\nimport hudson.security.PermissionGroup;\nimport hudson.security.PermissionScope;\nimport hudson.tasks.UserAvatarResolver;\nimport hudson.util.AlternativeUiTextProvider;\nimport hudson.util.AlternativeUiTextProvider.Message;\nimport hudson.util.DescribableList;\nimport hudson.util.DescriptorList;\nimport hudson.util.FormApply;\nimport hudson.util.IOException2;\nimport hudson.util.RunList;\nimport hudson.util.XStream2;\nimport hudson.views.ListViewColumn;\nimport hudson.widgets.Widget;\nimport jenkins.model.Jenkins;\nimport jenkins.util.ProgressiveRendering;\nimport net.sf.json.JSON;\nimport net.sf.json.JSONArray;\nimport net.sf.json.JSONObject;\nimport org.kohsuke.stapler.HttpResponse;\nimport org.kohsuke.stapler.HttpResponses;\nimport org.kohsuke.stapler.Stapler;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\nimport org.kohsuke.stapler.WebMethod;\nimport org.kohsuke.stapler.export.Exported;\nimport org.kohsuke.stapler.export.ExportedBean;\nimport org.kohsuke.stapler.interceptor.RequirePOST;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.StringWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;\nimport static jenkins.model.Jenkins.*;\nimport org.kohsuke.accmod.Restricted;\nimport org.kohsuke.accmod.restrictions.NoExternalUse;\n\n/**\n * Encapsulates the rendering of the list of {@link TopLevelItem}s\n * that {@link Jenkins} owns.\n *\n * <p>\n * This is an extension point in Hudson, allowing different kind of\n * rendering to be added as plugins.\n *\n * <h2>Note for implementors</h2>\n * <ul>\n * <li>\n * {@link View} subtypes need the <tt>newViewDetail.jelly</tt> page,\n * which is included in the \"new view\" page. This page should have some\n * description of what the view is about. \n * </ul>\n *\n * @author Kohsuke Kawaguchi\n * @see ViewDescriptor\n * @see ViewGroup\n */\n@ExportedBean\npublic abstract class View extends AbstractModelObject implements AccessControlled, Describable<View>, ExtensionPoint, Saveable {\n\n    /**\n     * Container of this view. Set right after the construction\n     * and never change thereafter.\n     */\n    protected /*final*/ ViewGroup owner;\n\n    /**\n     * Name of this view.\n     */\n    protected String name;\n\n    /**\n     * Message displayed in the view page.\n     */\n    protected String description;\n    \n    /**\n     * If true, only show relevant executors\n     */\n    protected boolean filterExecutors;\n\n    /**\n     * If true, only show relevant queue items\n     */\n    protected boolean filterQueue;\n    \n    protected transient List<Action> transientActions;\n\n    /**\n     * List of {@link ViewProperty}s configured for this view.\n     * @since 1.406\n     */\n    private volatile DescribableList<ViewProperty,ViewPropertyDescriptor> properties = new PropertyList(this);\n\n    protected View(String name) {\n        this.name = name;\n    }\n\n    protected View(String name, ViewGroup owner) {\n        this.name = name;\n        this.owner = owner;\n    }\n\n    /**\n     * Gets all the items in this collection in a read-only view.\n     */\n    @Exported(name=\"jobs\")\n    public abstract Collection<TopLevelItem> getItems();\n\n    /**\n     * Gets the {@link TopLevelItem} of the given name.\n     */\n    public TopLevelItem getItem(String name) {\n        return getOwnerItemGroup().getItem(name);\n    }\n\n    /**\n     * Alias for {@link #getItem(String)}. This is the one used in the URL binding.\n     */\n    public final TopLevelItem getJob(String name) {\n        return getItem(name);\n    }\n\n    /**\n     * Checks if the job is in this collection.\n     */\n    public abstract boolean contains(TopLevelItem item);\n\n    /**\n     * Gets the name of all this collection.\n     *\n     * @see #rename(String)\n     */\n    @Exported(visibility=2,name=\"name\")\n    public String getViewName() {\n        return name;\n    }\n\n    /**\n     * Renames this view.\n     */\n    public void rename(String newName) throws Failure, FormException {\n        if(name.equals(newName))    return; // noop\n        checkGoodName(newName);\n        if(owner.getView(newName)!=null)\n            throw new FormException(Messages.Hudson_ViewAlreadyExists(newName),\"name\");\n        String oldName = name;\n        name = newName;\n        owner.onViewRenamed(this,oldName,newName);\n    }\n\n    /**\n     * Gets the {@link ViewGroup} that this view belongs to.\n     */\n    public ViewGroup getOwner() {\n        return owner;\n    }\n\n    /**\n     * Backward-compatible way of getting {@code getOwner().getItemGroup()}\n     */\n    public ItemGroup<? extends TopLevelItem> getOwnerItemGroup() {\n        try {\n            return _getOwnerItemGroup();\n        } catch (AbstractMethodError e) {\n            return Hudson.getInstance();\n        }\n    }\n\n    /**\n     * A pointless function to work around what appears to be a HotSpot problem. See JENKINS-5756 and bug 6933067\n     * on BugParade for more details.\n     */\n    private ItemGroup<? extends TopLevelItem> _getOwnerItemGroup() {\n        return owner.getItemGroup();\n    }\n\n    public View getOwnerPrimaryView() {\n        try {\n            return _getOwnerPrimaryView();\n        } catch (AbstractMethodError e) {\n            return null;\n        }\n    }\n\n    private View _getOwnerPrimaryView() {\n        return owner.getPrimaryView();\n    }\n\n    public List<Action> getOwnerViewActions() {\n        try {\n            return _getOwnerViewActions();\n        } catch (AbstractMethodError e) {\n            return Hudson.getInstance().getActions();\n        }\n    }\n\n    private List<Action> _getOwnerViewActions() {\n        return owner.getViewActions();\n    }\n\n    /**\n     * Message displayed in the top page. Can be null. Includes HTML.\n     */\n    @Exported\n    public String getDescription() {\n        return description;\n    }\n    \n    /**\n     * Gets the view properties configured for this view.\n     * @since 1.406\n     */\n    public DescribableList<ViewProperty,ViewPropertyDescriptor> getProperties() {\n        // readResolve was the best place to do this, but for compatibility reasons,\n        // this class can no longer have readResolve() (the mechanism itself isn't suitable for class hierarchy)\n        // see JENKINS-9431\n        //\n        // until we have that, putting this logic here.\n        synchronized (PropertyList.class) {\n            if (properties == null) {\n                properties = new PropertyList(this);\n            } else {\n                properties.setOwner(this);\n            }\n            return properties;\n        }\n    }\n\n    /**\n     * Returns all the {@link LabelAtomPropertyDescriptor}s that can be potentially configured\n     * on this label.\n     */\n    public List<ViewPropertyDescriptor> getApplicablePropertyDescriptors() {\n        List<ViewPropertyDescriptor> r = new ArrayList<ViewPropertyDescriptor>();\n        for (ViewPropertyDescriptor pd : ViewProperty.all()) {\n            if (pd.isEnabledFor(this))\n                r.add(pd);\n        }\n        return r;\n    }\n\n    public void save() throws IOException {\n        // persistence is a part of the owner\n        // due to initialization timing issue, it can be null when this method is called\n        if (owner != null) {\n            owner.save();\n        }\n    }\n\n    /**\n     * List of all {@link ViewProperty}s exposed primarily for the remoting API.\n     * @since 1.406\n     */\n    @Exported(name=\"property\",inline=true)\n    public List<ViewProperty> getAllProperties() {\n        return getProperties().toList();\n    }\n\n    public ViewDescriptor getDescriptor() {\n        return (ViewDescriptor) Jenkins.getInstance().getDescriptorOrDie(getClass());\n    }\n\n    public String getDisplayName() {\n        return getViewName();\n    }\n\n    public String getNewPronoun() {\n        return AlternativeUiTextProvider.get(NEW_PRONOUN, this, Messages.AbstractItem_Pronoun());\n    }\n\n    /**\n     * By default, return true to render the \"Edit view\" link on the page.\n     * This method is really just for the default \"All\" view to hide the edit link\n     * so that the default Hudson top page remains the same as before 1.316.\n     *\n     * @since 1.316\n     */\n    public boolean isEditable() {\n        return true;\n    }\n    \n    /**\n     * If true, only show relevant executors\n     */\n    public boolean isFilterExecutors() {\n        return filterExecutors;\n    }\n    \n    /**\n     * If true, only show relevant queue items\n     */\n    public boolean isFilterQueue() {\n        return filterQueue;\n    }\n\n    /**\n     * Gets the {@link Widget}s registered on this object.\n     *\n     * <p>\n     * For now, this just returns the widgets registered to Hudson.\n     */\n    public List<Widget> getWidgets() {\n        return Collections.unmodifiableList(Jenkins.getInstance().getWidgets());\n    }\n\n    /**\n     * If this view uses &lt;t:projectView> for rendering, this method returns columns to be displayed.\n     */\n    public Iterable<? extends ListViewColumn> getColumns() {\n        return ListViewColumn.createDefaultInitialColumnList();\n    }\n\n    /**\n     * If this view uses &lt;t:projectView> for rendering, this method returns the indenter used\n     * to indent each row.\n     */\n    public Indenter getIndenter() {\n        return null;\n    }\n\n    /**\n     * If true, this is a view that renders the top page of Hudson.\n     */\n    public boolean isDefault() {\n        return getOwnerPrimaryView()==this;\n    }\n    \n    public List<Computer> getComputers() {\n        Computer[] computers = Jenkins.getInstance().getComputers();\n\n        if (!isFilterExecutors()) {\n            return Arrays.asList(computers);\n        }\n\n        List<Computer> result = new ArrayList<Computer>();\n\n        HashSet<Label> labels = new HashSet<Label>();\n        for (Item item : getItems()) {\n            if (item instanceof AbstractProject<?, ?>) {\n                labels.addAll(((AbstractProject<?, ?>) item).getRelevantLabels());\n            }\n        }\n\n        for (Computer c : computers) {\n            Node n = c.getNode();\n            if (n != null) {\n                if (labels.contains(null) && n.getMode() == Mode.NORMAL || !isDisjoint(n.getAssignedLabels(), labels)) {\n                    result.add(c);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    private boolean isDisjoint(Collection c1, Collection c2) {\n        for (Object o : c1)\n            if (c2.contains(o))\n                return false;\n        return true;\n    }\n\n    private List<Queue.Item> filterQueue(List<Queue.Item> base) {\n        if (!isFilterQueue()) {\n            return base;\n        }\n\n        Collection<TopLevelItem> items = getItems();\n        List<Queue.Item> result = new ArrayList<Queue.Item>();\n        for (Queue.Item qi : base) {\n            if (items.contains(qi.task)) {\n                result.add(qi);\n            } else\n            if (qi.task instanceof AbstractProject<?, ?>) {\n                AbstractProject<?,?> project = (AbstractProject<?, ?>) qi.task;\n                if (items.contains(project.getRootProject())) {\n                    result.add(qi);\n                }\n            }\n        }\n        return result;\n    }\n\n    public List<Queue.Item> getQueueItems() {\n        return filterQueue(Arrays.asList(Jenkins.getInstance().getQueue().getItems()));\n    }\n\n    public List<Queue.Item> getApproximateQueueItemsQuickly() {\n        return filterQueue(Jenkins.getInstance().getQueue().getApproximateItemsQuickly());\n    }\n\n    /**\n     * Returns the path relative to the context root.\n     *\n     * Doesn't start with '/' but ends with '/' (except returns\n     * empty string when this is the default view).\n     */\n    public String getUrl() {\n        return isDefault() ? (owner!=null ? owner.getUrl() : \"\") : getViewUrl();\n    }\n\n    /**\n     * Same as {@link #getUrl()} except this returns a view/{name} path\n     * even for the default view.\n     */\n    public String getViewUrl() {\n        return (owner!=null ? owner.getUrl() : \"\") + \"view/\" + Util.rawEncode(getViewName()) + '/';\n    }\n\n    public String getSearchUrl() {\n        return getUrl();\n    }\n\n    /**\n     * Returns the transient {@link Action}s associated with the top page.\n     *\n     * <p>\n     * If views don't want to show top-level actions, this method\n     * can be overridden to return different objects.\n     *\n     * @see Jenkins#getActions()\n     */\n    public List<Action> getActions() {\n    \tList<Action> result = new ArrayList<Action>();\n    \tresult.addAll(getOwnerViewActions());\n    \tsynchronized (this) {\n    \t\tif (transientActions == null) {\n                updateTransientActions();\n    \t\t}\n    \t\tresult.addAll(transientActions);\n    \t}\n    \treturn result;\n    }\n    \n    public synchronized void updateTransientActions() {\n        transientActions = TransientViewActionFactory.createAllFor(this); \n    }\n    \n    public Object getDynamic(String token) {\n        for (Action a : getActions()) {\n            String url = a.getUrlName();\n            if (url==null)  continue;\n            if(a.getUrlName().equals(token))\n                return a;\n        }\n        return null;\n    }\n\n    /**\n     * Gets the absolute URL of this view.\n     */\n    @Exported(visibility=2,name=\"url\")\n    public String getAbsoluteUrl() {\n        return Jenkins.getInstance().getRootUrl()+getUrl();\n    }\n\n    public Api getApi() {\n        return new Api(this);\n    }\n\n    /**\n     * Returns the page to redirect the user to, after the view is created.\n     *\n     * The returned string is appended to \"/view/foobar/\", so for example\n     * to direct the user to the top page of the view, return \"\", etc.\n     */\n    public String getPostConstructLandingPage() {\n        return \"configure\";\n    }\n\n    /**\n     * Returns the {@link ACL} for this object.\n     */\n    public ACL getACL() {\n        return Jenkins.getInstance().getAuthorizationStrategy().getACL(this);\n    }\n\n    public void checkPermission(Permission p) {\n        getACL().checkPermission(p);\n    }\n\n    public boolean hasPermission(Permission p) {\n        return getACL().hasPermission(p);\n    }\n\n    /**\n     * Called when a job name is changed or deleted.\n     *\n     * <p>\n     * If this view contains this job, it should update the view membership so that\n     * the renamed job will remain in the view, and the deleted job is removed.\n     *\n     * @param item\n     *      The item whose name is being changed.\n     * @param oldName\n     *      Old name of the item. Always non-null.\n     * @param newName\n     *      New name of the item, if the item is renamed. Or null, if the item is removed.\n     */\n    public abstract void onJobRenamed(Item item, String oldName, String newName);\n\n    @ExportedBean(defaultVisibility=2)\n    public static final class UserInfo implements Comparable<UserInfo> {\n        private final User user;\n        /**\n         * When did this user made a last commit on any of our projects? Can be null.\n         */\n        private Calendar lastChange;\n        /**\n         * Which project did this user commit? Can be null.\n         */\n        private AbstractProject project;\n\n        /** @see UserAvatarResolver */\n        String avatar;\n\n        UserInfo(User user, AbstractProject p, Calendar lastChange) {\n            this.user = user;\n            this.project = p;\n            this.lastChange = lastChange;\n        }\n\n        @Exported\n        public User getUser() {\n            return user;\n        }\n\n        @Exported\n        public Calendar getLastChange() {\n            return lastChange;\n        }\n\n        @Exported\n        public AbstractProject getProject() {\n            return project;\n        }\n\n        /**\n         * Returns a human-readable string representation of when this user was last active.\n         */\n        public String getLastChangeTimeString() {\n            if(lastChange==null)    return \"N/A\";\n            long duration = new GregorianCalendar().getTimeInMillis()- ordinal();\n            return Util.getTimeSpanString(duration);\n        }\n\n        public String getTimeSortKey() {\n            if(lastChange==null)    return \"-\";\n            return Util.XS_DATETIME_FORMATTER.format(lastChange.getTime());\n        }\n\n        public int compareTo(UserInfo that) {\n            long rhs = that.ordinal();\n            long lhs = this.ordinal();\n            if(rhs>lhs) return 1;\n            if(rhs<lhs) return -1;\n            return 0;\n        }\n\n        private long ordinal() {\n            if(lastChange==null)    return 0;\n            return lastChange.getTimeInMillis();\n        }\n    }\n\n    /**\n     * Does this {@link View} has any associated user information recorded?\n     * @deprecated Potentially very expensive call; do not use from Jelly views.\n     */\n    public boolean hasPeople() {\n        return People.isApplicable(getItems());\n    }\n\n    /**\n     * Gets the users that show up in the changelog of this job collection.\n     */\n    public People getPeople() {\n        return new People(this);\n    }\n\n    /**\n     * @since 1.484\n     */\n    public AsynchPeople getAsynchPeople() {\n        return new AsynchPeople(this);\n    }\n\n    @ExportedBean\n    public static final class People  {\n        @Exported\n        public final List<UserInfo> users;\n\n        public final ModelObject parent;\n\n        public People(Jenkins parent) {\n            this.parent = parent;\n            // for Hudson, really load all users\n            Map<User,UserInfo> users = getUserInfo(parent.getItems());\n            User unknown = User.getUnknown();\n            for (User u : User.getAll()) {\n                if(u==unknown)  continue;   // skip the special 'unknown' user\n                if(!users.containsKey(u))\n                    users.put(u,new UserInfo(u,null,null));\n            }\n            this.users = toList(users);\n        }\n\n        public People(View parent) {\n            this.parent = parent;\n            this.users = toList(getUserInfo(parent.getItems()));\n        }\n\n        private Map<User,UserInfo> getUserInfo(Collection<? extends Item> items) {\n            Map<User,UserInfo> users = new HashMap<User,UserInfo>();\n            for (Item item : items) {\n                for (Job job : item.getAllJobs()) {\n                    if (job instanceof AbstractProject) {\n                        AbstractProject<?,?> p = (AbstractProject) job;\n                        for (AbstractBuild<?,?> build : p.getBuilds()) {\n                            for (Entry entry : build.getChangeSet()) {\n                                User user = entry.getAuthor();\n\n                                UserInfo info = users.get(user);\n                                if(info==null)\n                                    users.put(user,new UserInfo(user,p,build.getTimestamp()));\n                                else\n                                if(info.getLastChange().before(build.getTimestamp())) {\n                                    info.project = p;\n                                    info.lastChange = build.getTimestamp();\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            return users;\n        }\n\n        private List<UserInfo> toList(Map<User,UserInfo> users) {\n            ArrayList<UserInfo> list = new ArrayList<UserInfo>();\n            list.addAll(users.values());\n            Collections.sort(list);\n            return Collections.unmodifiableList(list);\n        }\n\n        public Api getApi() {\n            return new Api(this);\n        }\n\n        /**\n         * @deprecated Potentially very expensive call; do not use from Jelly views.\n         */\n        public static boolean isApplicable(Collection<? extends Item> items) {\n            for (Item item : items) {\n                for (Job job : item.getAllJobs()) {\n                    if (job instanceof AbstractProject) {\n                        AbstractProject<?,?> p = (AbstractProject) job;\n                        for (AbstractBuild<?,?> build : p.getBuilds()) {\n                            for (Entry entry : build.getChangeSet()) {\n                                User user = entry.getAuthor();\n                                if(user!=null)\n                                    return true;\n                            }\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n    }\n\n    /**\n     * Variant of {@link People} which can be displayed progressively, since it may be slow.\n     * @since 1.484\n     */\n    public static final class AsynchPeople extends ProgressiveRendering { // JENKINS-15206\n\n        private final Collection<TopLevelItem> items;\n        private final User unknown;\n        private final Map<User,UserInfo> users = new HashMap<User,UserInfo>();\n        private final Set<User> modified = new HashSet<User>();\n        private final String iconSize;\n        public final ModelObject parent;\n\n        /** @see Jenkins#getAsynchPeople} */\n        public AsynchPeople(Jenkins parent) {\n            this.parent = parent;\n            items = parent.getItems();\n            unknown = User.getUnknown();\n        }\n\n        /** @see View#getAsynchPeople */\n        public AsynchPeople(View parent) {\n            this.parent = parent;\n            items = parent.getItems();\n            unknown = null;\n        }\n\n        {\n            StaplerRequest req = Stapler.getCurrentRequest();\n            iconSize = req != null ? Functions.getCookie(req, \"iconSize\", \"32x32\") : \"32x32\";\n        }\n\n        @Override protected void compute() throws Exception {\n            int itemCount = 0;\n            for (Item item : items) {\n                for (Job<?,?> job : item.getAllJobs()) {\n                    if (job instanceof AbstractProject) {\n                        AbstractProject<?,?> p = (AbstractProject) job;\n                        RunList<? extends AbstractBuild<?,?>> builds = p.getBuilds();\n                        int buildCount = 0;\n                        for (AbstractBuild<?,?> build : builds) {\n                            if (canceled()) {\n                                return;\n                            }\n                            for (ChangeLogSet.Entry entry : build.getChangeSet()) {\n                                User user = entry.getAuthor();\n                                UserInfo info = users.get(user);\n                                if (info == null) {\n                                    UserInfo userInfo = new UserInfo(user, p, build.getTimestamp());\n                                    userInfo.avatar = UserAvatarResolver.resolve(user, iconSize);\n                                    synchronized (this) {\n                                        users.put(user, userInfo);\n                                        modified.add(user);\n                                    }\n                                } else if (info.getLastChange().before(build.getTimestamp())) {\n                                    synchronized (this) {\n                                        info.project = p;\n                                        info.lastChange = build.getTimestamp();\n                                        modified.add(user);\n                                    }\n                                }\n                            }\n                            // XXX consider also adding the user of the UserCause when applicable\n                            buildCount++;\n                            progress((itemCount + 1.0 * buildCount / builds.size()) / (items.size() + 1));\n                        }\n                    }\n                }\n                itemCount++;\n                progress(1.0 * itemCount / (items.size() + /* handling User.getAll */1));\n            }\n            if (unknown != null) {\n                if (canceled()) {\n                    return;\n                }\n                for (User u : User.getAll()) { // XXX nice to have a method to iterate these lazily\n                    if (u == unknown) {\n                        continue;\n                    }\n                    if (!users.containsKey(u)) {\n                        UserInfo userInfo = new UserInfo(u, null, null);\n                        userInfo.avatar = UserAvatarResolver.resolve(u, iconSize);\n                        synchronized (this) {\n                            users.put(u, userInfo);\n                            modified.add(u);\n                        }\n                    }\n                }\n            }\n        }\n\n        @Override protected synchronized JSON data() {\n            JSONArray r = new JSONArray();\n            for (User u : modified) {\n                UserInfo i = users.get(u);\n                JSONObject entry = new JSONObject().\n                        accumulate(\"id\", u.getId()).\n                        accumulate(\"fullName\", u.getFullName()).\n                        accumulate(\"url\", u.getUrl()).\n                        accumulate(\"avatar\", i.avatar).\n                        accumulate(\"timeSortKey\", i.getTimeSortKey()).\n                        accumulate(\"lastChangeTimeString\", i.getLastChangeTimeString());\n                AbstractProject<?,?> p = i.getProject();\n                if (p != null) {\n                    entry.accumulate(\"projectUrl\", p.getUrl()).accumulate(\"projectFullDisplayName\", p.getFullDisplayName());\n                }\n                r.add(entry);\n            }\n            modified.clear();\n            return r;\n        }\n\n        public Api getApi() {\n            return new Api(new People());\n        }\n\n        /** JENKINS-16397 workaround */\n        @Restricted(NoExternalUse.class)\n        @ExportedBean\n        public final class People {\n\n            private View.People people;\n\n            @Exported public synchronized List<UserInfo> getUsers() {\n                if (people == null) {\n                    people = parent instanceof Jenkins ? new View.People((Jenkins) parent) : new View.People((View) parent);\n                }\n                return people.users;\n            }\n        }\n\n    }\n\n    void addDisplayNamesToSearchIndex(SearchIndexBuilder sib, Collection<TopLevelItem> items) {\n        for(TopLevelItem item : items) {\n            \n            if(LOGGER.isLoggable(Level.FINE)) {\n                LOGGER.fine((String.format(\"Adding url=%s,displayName=%s\",\n                            item.getSearchUrl(), item.getDisplayName())));\n            }\n            sib.add(item.getSearchUrl(), item.getDisplayName());\n        }        \n    }\n    \n    @Override\n    public SearchIndexBuilder makeSearchIndex() {\n        SearchIndexBuilder sib = super.makeSearchIndex();\n        sib.add(new CollectionSearchIndex<TopLevelItem>() {// for jobs in the view\n                protected TopLevelItem get(String key) { return getItem(key); }\n                protected Collection<TopLevelItem> all() { return getItems(); }                \n                @Override\n                protected String getName(TopLevelItem o) {\n                    // return the name instead of the display for suggestion searching\n                    return o.getName();\n                }\n            });\n        \n        // add the display name for each item in the search index\n        addDisplayNamesToSearchIndex(sib, getItems());\n\n        return sib;\n    }\n\n    /**\n     * Accepts the new description.\n     */\n    public synchronized void doSubmitDescription( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        checkPermission(CONFIGURE);\n\n        description = req.getParameter(\"description\");\n        save();\n        rsp.sendRedirect(\".\");  // go to the top page\n    }\n\n    /**\n     * Accepts submission from the configuration page.\n     *\n     * Subtypes should override the {@link #submit(StaplerRequest)} method.\n     */\n    @RequirePOST\n    public final synchronized void doConfigSubmit( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException, FormException {\n        checkPermission(CONFIGURE);\n\n        submit(req);\n\n        description = Util.nullify(req.getParameter(\"description\"));\n        filterExecutors = req.getParameter(\"filterExecutors\") != null;\n        filterQueue = req.getParameter(\"filterQueue\") != null;\n\n        rename(req.getParameter(\"name\"));\n\n        getProperties().rebuild(req, req.getSubmittedForm(), getApplicablePropertyDescriptors());\n        updateTransientActions();  \n\n        save();\n\n        FormApply.success(\"../\"+name).generateResponse(req,rsp,this);\n    }\n\n    /**\n     * Handles the configuration submission.\n     *\n     * Load view-specific properties here.\n     */\n    protected abstract void submit(StaplerRequest req) throws IOException, ServletException, FormException;\n\n    /**\n     * Deletes this view.\n     */\n    @RequirePOST\n    public synchronized void doDoDelete(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        checkPermission(DELETE);\n\n        owner.deleteView(this);\n\n        rsp.sendRedirect2(req.getContextPath()+\"/\" + owner.getUrl());\n    }\n\n\n    /**\n     * Creates a new {@link Item} in this collection.\n     *\n     * <p>\n     * This method should call {@link ModifiableItemGroup#doCreateItem(StaplerRequest, StaplerResponse)}\n     * and then add the newly created item to this view.\n     * \n     * @return\n     *      null if fails.\n     */\n    public abstract Item doCreateItem( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException;\n\n    public void doRssAll( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        rss(req, rsp, \" all builds\", getBuilds());\n    }\n\n    public void doRssFailed( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        rss(req, rsp, \" failed builds\", getBuilds().failureOnly());\n    }\n    \n    public RunList getBuilds() {\n        return new RunList(this);\n    }\n    \n    public BuildTimelineWidget getTimeline() {\n        return new BuildTimelineWidget(getBuilds());\n    }\n\n    private void rss(StaplerRequest req, StaplerResponse rsp, String suffix, RunList runs) throws IOException, ServletException {\n        RSS.forwardToRss(getDisplayName()+ suffix, getUrl(),\n            runs.newBuilds(), Run.FEED_ADAPTER, req, rsp );\n    }\n\n    public void doRssLatest( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        List<Run> lastBuilds = new ArrayList<Run>();\n        for (TopLevelItem item : getItems()) {\n            if (item instanceof Job) {\n                Job job = (Job) item;\n                Run lb = job.getLastBuild();\n                if(lb!=null)    lastBuilds.add(lb);\n            }\n        }\n        RSS.forwardToRss(getDisplayName()+\" last builds only\", getUrl(),\n            lastBuilds, Run.FEED_ADAPTER_LATEST, req, rsp );\n    }\n\n    /**\n     * Accepts <tt>config.xml</tt> submission, as well as serve it.\n     */\n    @WebMethod(name = \"config.xml\")\n    public HttpResponse doConfigDotXml(StaplerRequest req) throws IOException {\n        if (req.getMethod().equals(\"GET\")) {\n            // read\n            checkPermission(READ);\n            return new HttpResponse() {\n                public void generateResponse(StaplerRequest req, StaplerResponse rsp, Object node) throws IOException, ServletException {\n                    rsp.setContentType(\"application/xml\");\n                    // pity we don't have a handy way to clone Jenkins.XSTREAM to temp add the omit Field\n                    XStream2 xStream2 = new XStream2();\n                    xStream2.omitField(View.class, \"owner\");\n                    xStream2.toXMLUTF8(this,  rsp.getOutputStream());\n                }\n            };\n        }\n        if (req.getMethod().equals(\"POST\")) {\n            // submission\n            updateByXml((Source)new StreamSource(req.getReader()));\n            return HttpResponses.ok();\n        }\n\n        // huh?\n        return HttpResponses.error(SC_BAD_REQUEST, \"Unexpected request method \" + req.getMethod());\n    }\n\n    /**\n     * Updates Job by its XML definition.\n     */\n    public void updateByXml(Source source) throws IOException {\n        checkPermission(CONFIGURE);\n        StringWriter out = new StringWriter();\n        try {\n            // this allows us to use UTF-8 for storing data,\n            // plus it checks any well-formedness issue in the submitted\n            // data\n            Transformer t = TransformerFactory.newInstance()\n                    .newTransformer();\n            t.transform(source,\n                    new StreamResult(out));\n            out.close();\n        } catch (TransformerException e) {\n            throw new IOException2(\"Failed to persist configuration.xml\", e);\n        }\n\n        // try to reflect the changes by reloading\n        InputStream in = new BufferedInputStream(new ByteArrayInputStream(out.toString().getBytes(\"UTF-8\")));\n        try {\n            Jenkins.XSTREAM.unmarshal(new XppDriver().createReader(in), this);\n        } catch (StreamException e) {\n            throw new IOException2(\"Unable to read\",e);\n        } catch(ConversionException e) {\n            throw new IOException2(\"Unable to read\",e);\n        } catch(Error e) {// mostly reflection errors\n            throw new IOException2(\"Unable to read\",e);\n        } finally {\n            in.close();\n        }\n    }\n\n\n    /**\n     * A list of available view types.\n     * @deprecated as of 1.286\n     *      Use {@link #all()} for read access, and use {@link Extension} for registration.\n     */\n    public static final DescriptorList<View> LIST = new DescriptorList<View>(View.class);\n\n    /**\n     * Returns all the registered {@link ViewDescriptor}s.\n     */\n    public static DescriptorExtensionList<View,ViewDescriptor> all() {\n        return Jenkins.getInstance().<View,ViewDescriptor>getDescriptorList(View.class);\n    }\n\n    public static List<ViewDescriptor> allInstantiable() {\n        List<ViewDescriptor> r = new ArrayList<ViewDescriptor>();\n        for (ViewDescriptor d : all())\n            if(d.isInstantiable())\n                r.add(d);\n        return r;\n    }\n\n    public static final Comparator<View> SORTER = new Comparator<View>() {\n        public int compare(View lhs, View rhs) {\n            return lhs.getViewName().compareTo(rhs.getViewName());\n        }\n    };\n\n    public static final PermissionGroup PERMISSIONS = new PermissionGroup(View.class,Messages._View_Permissions_Title());\n    /**\n     * Permission to create new views.\n     */\n    public static final Permission CREATE = new Permission(PERMISSIONS,\"Create\", Messages._View_CreatePermission_Description(), Permission.CREATE, PermissionScope.ITEM_GROUP);\n    public static final Permission DELETE = new Permission(PERMISSIONS,\"Delete\", Messages._View_DeletePermission_Description(), Permission.DELETE, PermissionScope.ITEM_GROUP);\n    public static final Permission CONFIGURE = new Permission(PERMISSIONS,\"Configure\", Messages._View_ConfigurePermission_Description(), Permission.CONFIGURE, PermissionScope.ITEM_GROUP);\n    public static final Permission READ = new Permission(PERMISSIONS,\"Read\", Messages._View_ReadPermission_Description(), Permission.READ, PermissionScope.ITEM_GROUP);\n\n    // to simplify access from Jelly\n    public static Permission getItemCreatePermission() {\n        return Item.CREATE;\n    }\n    \n    public static View create(StaplerRequest req, StaplerResponse rsp, ViewGroup owner)\n            throws FormException, IOException, ServletException {\n        String requestContentType = req.getContentType();\n        if(requestContentType==null)\n            throw new Failure(\"No Content-Type header set\");\n\n        boolean isXmlSubmission = requestContentType.startsWith(\"application/xml\") || requestContentType.startsWith(\"text/xml\");\n\n        String name = req.getParameter(\"name\");\n        checkGoodName(name);\n        if(owner.getView(name)!=null)\n            throw new FormException(Messages.Hudson_ViewAlreadyExists(name),\"name\");\n\n        String mode = req.getParameter(\"mode\");\n        if (mode==null || mode.length()==0) {\n            if(isXmlSubmission) {\n                View v;\n                v = createViewFromXML(name, req.getInputStream());\n                v.owner = owner;\n                rsp.setStatus(HttpServletResponse.SC_OK);\n                return v;\n            } else\n                throw new FormException(Messages.View_MissingMode(),\"mode\");\n        }\n\n        // create a view\n        View v = all().findByName(mode).newInstance(req,req.getSubmittedForm());\n        v.owner = owner;\n\n        // redirect to the config screen\n        rsp.sendRedirect2(req.getContextPath()+'/'+v.getUrl()+v.getPostConstructLandingPage());\n\n        return v;\n    }\n\n    public static View createViewFromXML(String name, InputStream xml) throws IOException {\n        InputStream in = new BufferedInputStream(xml);\n        try {\n            View v = (View) Jenkins.XSTREAM.fromXML(in);\n            v.name = name;\n            return v;\n        } catch(StreamException e) {\n            throw new IOException2(\"Unable to read\",e);\n        } catch(ConversionException e) {\n            throw new IOException2(\"Unable to read\",e);\n        } catch(Error e) {// mostly reflection errors\n            throw new IOException2(\"Unable to read\",e);\n        } finally {\n            in.close();\n        }\n    }\n\n    public static class PropertyList extends DescribableList<ViewProperty,ViewPropertyDescriptor> {\n        private PropertyList(View owner) {\n            super(owner);\n        }\n\n        public PropertyList() {// needed for XStream deserialization\n        }\n\n        public View getOwner() {\n            return (View)owner;\n        }\n\n        @Override\n        protected void onModified() throws IOException {\n            for (ViewProperty p : this)\n                p.setView(getOwner());\n        }\n    }\n\n    /**\n     * \"Job\" in \"New Job\". When a view is used in a context that restricts the child type,\n     * It might be useful to override this.\n     */\n    public static final Message<View> NEW_PRONOUN = new Message<View>();\n\n    private final static Logger LOGGER = Logger.getLogger(View.class.getName());\n}\n", "/*\n * The MIT License\n *\n * Copyright (c) 2004-2011, Sun Microsystems, Inc., Kohsuke Kawaguchi,\n * Erik Ramfelt, Koichi Fujikawa, Red Hat, Inc., Seiji Sogabe,\n * Stephen Connolly, Tom Huybrechts, Yahoo! Inc., Alan Harder, CloudBees, Inc.,\n * Yahoo!, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage jenkins.model;\n\nimport com.google.common.collect.Lists;\nimport com.google.inject.Injector;\nimport hudson.ExtensionComponent;\nimport hudson.ExtensionFinder;\nimport hudson.model.LoadStatistics;\nimport hudson.model.Messages;\nimport hudson.model.Node;\nimport hudson.model.AbstractCIBase;\nimport hudson.model.AbstractProject;\nimport hudson.model.Action;\nimport hudson.model.AdministrativeMonitor;\nimport hudson.model.AllView;\nimport hudson.model.Api;\nimport hudson.model.Computer;\nimport hudson.model.ComputerSet;\nimport hudson.model.DependencyGraph;\nimport hudson.model.Describable;\nimport hudson.model.Descriptor;\nimport hudson.model.DescriptorByNameOwner;\nimport hudson.model.DirectoryBrowserSupport;\nimport hudson.model.Failure;\nimport hudson.model.Fingerprint;\nimport hudson.model.FingerprintCleanupThread;\nimport hudson.model.FingerprintMap;\nimport hudson.model.FullDuplexHttpChannel;\nimport hudson.model.Hudson;\nimport hudson.model.Item;\nimport hudson.model.ItemGroup;\nimport hudson.model.ItemGroupMixIn;\nimport hudson.model.Items;\nimport hudson.model.JDK;\nimport hudson.model.Job;\nimport hudson.model.JobPropertyDescriptor;\nimport hudson.model.Label;\nimport hudson.model.ListView;\nimport hudson.model.LoadBalancer;\nimport hudson.model.ManagementLink;\nimport hudson.model.NoFingerprintMatch;\nimport hudson.model.OverallLoadStatistics;\nimport hudson.model.Project;\nimport hudson.model.RestartListener;\nimport hudson.model.RootAction;\nimport hudson.model.Slave;\nimport hudson.model.TaskListener;\nimport hudson.model.TopLevelItem;\nimport hudson.model.TopLevelItemDescriptor;\nimport hudson.model.UnprotectedRootAction;\nimport hudson.model.UpdateCenter;\nimport hudson.model.User;\nimport hudson.model.View;\nimport hudson.model.ViewGroup;\nimport hudson.model.ViewGroupMixIn;\nimport hudson.model.Descriptor.FormException;\nimport hudson.model.labels.LabelAtom;\nimport hudson.model.listeners.ItemListener;\nimport hudson.model.listeners.SCMListener;\nimport hudson.model.listeners.SaveableListener;\nimport hudson.model.Queue;\nimport hudson.model.WorkspaceCleanupThread;\n\nimport antlr.ANTLRException;\nimport com.google.common.collect.ImmutableMap;\nimport com.thoughtworks.xstream.XStream;\nimport hudson.BulkChange;\nimport hudson.DNSMultiCast;\nimport hudson.DescriptorExtensionList;\nimport hudson.Extension;\nimport hudson.ExtensionList;\nimport hudson.ExtensionPoint;\nimport hudson.FilePath;\nimport hudson.Functions;\nimport hudson.Launcher;\nimport hudson.Launcher.LocalLauncher;\nimport hudson.LocalPluginManager;\nimport hudson.Lookup;\nimport hudson.markup.MarkupFormatter;\nimport hudson.Plugin;\nimport hudson.PluginManager;\nimport hudson.PluginWrapper;\nimport hudson.ProxyConfiguration;\nimport hudson.TcpSlaveAgentListener;\nimport hudson.UDPBroadcastThread;\nimport hudson.Util;\nimport static hudson.Util.fixEmpty;\nimport static hudson.Util.fixNull;\nimport hudson.WebAppMain;\nimport hudson.XmlFile;\nimport hudson.cli.CLICommand;\nimport hudson.cli.CliEntryPoint;\nimport hudson.cli.CliManagerImpl;\nimport hudson.cli.declarative.CLIMethod;\nimport hudson.cli.declarative.CLIResolver;\nimport hudson.init.InitMilestone;\nimport hudson.init.InitStrategy;\nimport hudson.lifecycle.Lifecycle;\nimport hudson.logging.LogRecorderManager;\nimport hudson.lifecycle.RestartNotSupportedException;\nimport hudson.markup.RawHtmlMarkupFormatter;\nimport hudson.remoting.Channel;\nimport hudson.remoting.LocalChannel;\nimport hudson.remoting.VirtualChannel;\nimport hudson.scm.RepositoryBrowser;\nimport hudson.scm.SCM;\nimport hudson.search.CollectionSearchIndex;\nimport hudson.search.SearchIndexBuilder;\nimport hudson.search.SearchItem;\nimport hudson.security.ACL;\nimport hudson.security.AccessControlled;\nimport hudson.security.AuthorizationStrategy;\nimport hudson.security.FederatedLoginService;\nimport hudson.security.FullControlOnceLoggedInAuthorizationStrategy;\nimport hudson.security.HudsonFilter;\nimport hudson.security.LegacyAuthorizationStrategy;\nimport hudson.security.LegacySecurityRealm;\nimport hudson.security.Permission;\nimport hudson.security.PermissionGroup;\nimport hudson.security.PermissionScope;\nimport hudson.security.SecurityMode;\nimport hudson.security.SecurityRealm;\nimport hudson.security.csrf.CrumbIssuer;\nimport hudson.slaves.Cloud;\nimport hudson.slaves.ComputerListener;\nimport hudson.slaves.DumbSlave;\nimport hudson.slaves.EphemeralNode;\nimport hudson.slaves.NodeDescriptor;\nimport hudson.slaves.NodeList;\nimport hudson.slaves.NodeProperty;\nimport hudson.slaves.NodePropertyDescriptor;\nimport hudson.slaves.NodeProvisioner;\nimport hudson.slaves.OfflineCause;\nimport hudson.slaves.RetentionStrategy;\nimport hudson.tasks.BuildWrapper;\nimport hudson.tasks.Builder;\nimport hudson.tasks.Publisher;\nimport hudson.triggers.SafeTimerTask;\nimport hudson.triggers.Trigger;\nimport hudson.triggers.TriggerDescriptor;\nimport hudson.util.AdministrativeError;\nimport hudson.util.CaseInsensitiveComparator;\nimport hudson.util.ClockDifference;\nimport hudson.util.CopyOnWriteList;\nimport hudson.util.CopyOnWriteMap;\nimport hudson.util.DaemonThreadFactory;\nimport hudson.util.DescribableList;\nimport hudson.util.FormApply;\nimport hudson.util.FormValidation;\nimport hudson.util.Futures;\nimport hudson.util.HudsonIsLoading;\nimport hudson.util.HudsonIsRestarting;\nimport hudson.util.Iterators;\nimport hudson.util.JenkinsReloadFailed;\nimport hudson.util.Memoizer;\nimport hudson.util.MultipartFormDataParser;\nimport hudson.util.RemotingDiagnostics;\nimport hudson.util.RemotingDiagnostics.HeapDump;\nimport hudson.util.StreamTaskListener;\nimport hudson.util.TextFile;\nimport hudson.util.TimeUnit2;\nimport hudson.util.VersionNumber;\nimport hudson.util.XStream2;\nimport hudson.views.DefaultMyViewsTabBar;\nimport hudson.views.DefaultViewsTabBar;\nimport hudson.views.MyViewsTabBar;\nimport hudson.views.ViewsTabBar;\nimport hudson.widgets.Widget;\nimport jenkins.ExtensionComponentSet;\nimport jenkins.ExtensionRefreshException;\nimport jenkins.InitReactorRunner;\nimport jenkins.model.ProjectNamingStrategy.DefaultProjectNamingStrategy;\nimport jenkins.security.ConfidentialKey;\nimport jenkins.security.ConfidentialStore;\nimport jenkins.slaves.WorkspaceLocator;\nimport jenkins.util.io.FileBoolean;\nimport net.sf.json.JSONObject;\nimport org.acegisecurity.AccessDeniedException;\nimport org.acegisecurity.AcegiSecurityException;\nimport org.acegisecurity.Authentication;\nimport org.acegisecurity.GrantedAuthority;\nimport org.acegisecurity.GrantedAuthorityImpl;\nimport org.acegisecurity.context.SecurityContextHolder;\nimport org.acegisecurity.providers.anonymous.AnonymousAuthenticationToken;\nimport org.acegisecurity.ui.AbstractProcessingFilter;\nimport org.apache.commons.jelly.JellyException;\nimport org.apache.commons.jelly.Script;\nimport org.apache.commons.logging.LogFactory;\nimport org.jvnet.hudson.reactor.Executable;\nimport org.jvnet.hudson.reactor.ReactorException;\nimport org.jvnet.hudson.reactor.Task;\nimport org.jvnet.hudson.reactor.TaskBuilder;\nimport org.jvnet.hudson.reactor.TaskGraphBuilder;\nimport org.jvnet.hudson.reactor.Reactor;\nimport org.jvnet.hudson.reactor.TaskGraphBuilder.Handle;\nimport org.kohsuke.accmod.Restricted;\nimport org.kohsuke.accmod.restrictions.NoExternalUse;\nimport org.kohsuke.args4j.Argument;\nimport org.kohsuke.args4j.Option;\nimport org.kohsuke.stapler.Ancestor;\nimport org.kohsuke.stapler.HttpRedirect;\nimport org.kohsuke.stapler.HttpResponse;\nimport org.kohsuke.stapler.HttpResponses;\nimport org.kohsuke.stapler.MetaClass;\nimport org.kohsuke.stapler.QueryParameter;\nimport org.kohsuke.stapler.Stapler;\nimport org.kohsuke.stapler.StaplerFallback;\nimport org.kohsuke.stapler.StaplerProxy;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\nimport org.kohsuke.stapler.WebApp;\nimport org.kohsuke.stapler.export.Exported;\nimport org.kohsuke.stapler.export.ExportedBean;\nimport org.kohsuke.stapler.framework.adjunct.AdjunctManager;\nimport org.kohsuke.stapler.interceptor.RequirePOST;\nimport org.kohsuke.stapler.jelly.JellyClassLoaderTearOff;\nimport org.kohsuke.stapler.jelly.JellyRequestDispatcher;\nimport org.xml.sax.InputSource;\n\nimport javax.crypto.SecretKey;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletResponse;\n\nimport static hudson.init.InitMilestone.*;\nimport hudson.security.BasicAuthenticationFilter;\nimport static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;\nimport static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\nimport java.io.File;\nimport java.io.FileFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.net.BindException;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.security.SecureRandom;\nimport java.text.Collator;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport java.util.Timer;\nimport java.util.TreeSet;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.logging.Level;\nimport static java.util.logging.Level.SEVERE;\nimport java.util.logging.LogRecord;\nimport java.util.logging.Logger;\nimport java.util.regex.Pattern;\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\n/**\n * Root object of the system.\n *\n * @author Kohsuke Kawaguchi\n */\n@ExportedBean\npublic class Jenkins extends AbstractCIBase implements ModifiableTopLevelItemGroup, StaplerProxy, StaplerFallback, ViewGroup, AccessControlled, DescriptorByNameOwner, ModelObjectWithContextMenu {\n    private transient final Queue queue;\n\n    /**\n     * Stores various objects scoped to {@link Jenkins}.\n     */\n    public transient final Lookup lookup = new Lookup();\n\n    /**\n     * We update this field to the current version of Hudson whenever we save {@code config.xml}.\n     * This can be used to detect when an upgrade happens from one version to next.\n     *\n     * <p>\n     * Since this field is introduced starting 1.301, \"1.0\" is used to represent every version\n     * up to 1.300. This value may also include non-standard versions like \"1.301-SNAPSHOT\" or\n     * \"?\", etc., so parsing needs to be done with a care.\n     *\n     * @since 1.301\n     */\n    // this field needs to be at the very top so that other components can look at this value even during unmarshalling\n    private String version = \"1.0\";\n\n    /**\n     * Number of executors of the master node.\n     */\n    private int numExecutors = 2;\n\n    /**\n     * Job allocation strategy.\n     */\n    private Mode mode = Mode.NORMAL;\n\n    /**\n     * False to enable anyone to do anything.\n     * Left as a field so that we can still read old data that uses this flag.\n     *\n     * @see #authorizationStrategy\n     * @see #securityRealm\n     */\n    private Boolean useSecurity;\n\n    /**\n     * Controls how the\n     * <a href=\"http://en.wikipedia.org/wiki/Authorization\">authorization</a>\n     * is handled in Hudson.\n     * <p>\n     * This ultimately controls who has access to what.\n     *\n     * Never null.\n     */\n    private volatile AuthorizationStrategy authorizationStrategy = AuthorizationStrategy.UNSECURED;\n\n    /**\n     * Controls a part of the\n     * <a href=\"http://en.wikipedia.org/wiki/Authentication\">authentication</a>\n     * handling in Hudson.\n     * <p>\n     * Intuitively, this corresponds to the user database.\n     *\n     * See {@link HudsonFilter} for the concrete authentication protocol.\n     *\n     * Never null. Always use {@link #setSecurityRealm(SecurityRealm)} to\n     * update this field.\n     *\n     * @see #getSecurity()\n     * @see #setSecurityRealm(SecurityRealm)\n     */\n    private volatile SecurityRealm securityRealm = SecurityRealm.NO_AUTHENTICATION;\n    \n    /**\n     * The project naming strategy defines/restricts the names which can be given to a project/job. e.g. does the name have to follow a naming convention?\n     */\n    private ProjectNamingStrategy projectNamingStrategy = DefaultProjectNamingStrategy.DEFAULT_NAMING_STRATEGY;\n\n    /**\n     * Root directory for the workspaces.\n     * This value will be variable-expanded as per {@link #expandVariablesForDirectory}.\n     * @see #getWorkspaceFor(TopLevelItem)\n     */\n    private String workspaceDir = \"${ITEM_ROOTDIR}/\"+WORKSPACE_DIRNAME;\n\n    /**\n     * Root directory for the builds.\n     * This value will be variable-expanded as per {@link #expandVariablesForDirectory}.\n     * @see #getBuildDirFor(Job)\n     */\n    private String buildsDir = \"${ITEM_ROOTDIR}/builds\";\n\n    /**\n     * Message displayed in the top page.\n     */\n    private String systemMessage;\n\n    private MarkupFormatter markupFormatter;\n\n    /**\n     * Root directory of the system.\n     */\n    public transient final File root;\n\n    /**\n     * Where are we in the initialization?\n     */\n    private transient volatile InitMilestone initLevel = InitMilestone.STARTED;\n\n    /**\n     * All {@link Item}s keyed by their {@link Item#getName() name}s.\n     */\n    /*package*/ transient final Map<String,TopLevelItem> items = new CopyOnWriteMap.Tree<String,TopLevelItem>(CaseInsensitiveComparator.INSTANCE);\n\n    /**\n     * The sole instance.\n     */\n    private static Jenkins theInstance;\n\n    private transient volatile boolean isQuietingDown;\n    private transient volatile boolean terminating;\n\n    private List<JDK> jdks = new ArrayList<JDK>();\n\n    private transient volatile DependencyGraph dependencyGraph;\n\n    /**\n     * Currently active Views tab bar.\n     */\n    private volatile ViewsTabBar viewsTabBar = new DefaultViewsTabBar();\n\n    /**\n     * Currently active My Views tab bar.\n     */\n    private volatile MyViewsTabBar myViewsTabBar = new DefaultMyViewsTabBar();\n\n    /**\n     * All {@link ExtensionList} keyed by their {@link ExtensionList#extensionType}.\n     */\n    private transient final Memoizer<Class,ExtensionList> extensionLists = new Memoizer<Class,ExtensionList>() {\n        public ExtensionList compute(Class key) {\n            return ExtensionList.create(Jenkins.this,key);\n        }\n    };\n\n    /**\n     * All {@link DescriptorExtensionList} keyed by their {@link DescriptorExtensionList#describableType}.\n     */\n    private transient final Memoizer<Class,DescriptorExtensionList> descriptorLists = new Memoizer<Class,DescriptorExtensionList>() {\n        public DescriptorExtensionList compute(Class key) {\n            return DescriptorExtensionList.createDescriptorList(Jenkins.this,key);\n        }\n    };\n\n    /**\n     * {@link Computer}s in this Hudson system. Read-only.\n     */\n    protected transient final Map<Node,Computer> computers = new CopyOnWriteMap.Hash<Node,Computer>();\n\n    /**\n     * Active {@link Cloud}s.\n     */\n    public final Hudson.CloudList clouds = new Hudson.CloudList(this);\n\n    public static class CloudList extends DescribableList<Cloud,Descriptor<Cloud>> {\n        public CloudList(Jenkins h) {\n            super(h);\n        }\n\n        public CloudList() {// needed for XStream deserialization\n        }\n\n        public Cloud getByName(String name) {\n            for (Cloud c : this)\n                if (c.name.equals(name))\n                    return c;\n            return null;\n        }\n\n        @Override\n        protected void onModified() throws IOException {\n            super.onModified();\n            Jenkins.getInstance().trimLabels();\n        }\n    }\n\n    /**\n     * Set of installed cluster nodes.\n     * <p>\n     * We use this field with copy-on-write semantics.\n     * This field has mutable list (to keep the serialization look clean),\n     * but it shall never be modified. Only new completely populated slave\n     * list can be set here.\n     * <p>\n     * The field name should be really {@code nodes}, but again the backward compatibility\n     * prevents us from renaming.\n     */\n    protected volatile NodeList slaves;\n\n    /**\n     * Quiet period.\n     *\n     * This is {@link Integer} so that we can initialize it to '5' for upgrading users.\n     */\n    /*package*/ Integer quietPeriod;\n\n    /**\n     * Global default for {@link AbstractProject#getScmCheckoutRetryCount()}\n     */\n    /*package*/ int scmCheckoutRetryCount;\n\n    /**\n     * {@link View}s.\n     */\n    private final CopyOnWriteArrayList<View> views = new CopyOnWriteArrayList<View>();\n\n    /**\n     * Name of the primary view.\n     * <p>\n     * Start with null, so that we can upgrade pre-1.269 data well.\n     * @since 1.269\n     */\n    private volatile String primaryView;\n\n    private transient final ViewGroupMixIn viewGroupMixIn = new ViewGroupMixIn(this) {\n        protected List<View> views() { return views; }\n        protected String primaryView() { return primaryView; }\n        protected void primaryView(String name) { primaryView=name; }\n    };\n\n\n    private transient final FingerprintMap fingerprintMap = new FingerprintMap();\n\n    /**\n     * Loaded plugins.\n     */\n    public transient final PluginManager pluginManager;\n\n    public transient volatile TcpSlaveAgentListener tcpSlaveAgentListener;\n\n    private transient UDPBroadcastThread udpBroadcastThread;\n\n    private transient DNSMultiCast dnsMultiCast;\n\n    /**\n     * List of registered {@link SCMListener}s.\n     */\n    private transient final CopyOnWriteList<SCMListener> scmListeners = new CopyOnWriteList<SCMListener>();\n\n    /**\n     * TCP slave agent port.\n     * 0 for random, -1 to disable.\n     */\n    private int slaveAgentPort =0;\n\n    /**\n     * Whitespace-separated labels assigned to the master as a {@link Node}.\n     */\n    private String label=\"\";\n\n    /**\n     * {@link hudson.security.csrf.CrumbIssuer}\n     */\n    private volatile CrumbIssuer crumbIssuer;\n\n    /**\n     * All labels known to Jenkins. This allows us to reuse the same label instances\n     * as much as possible, even though that's not a strict requirement.\n     */\n    private transient final ConcurrentHashMap<String,Label> labels = new ConcurrentHashMap<String,Label>();\n\n    /**\n     * Load statistics of the entire system.\n     *\n     * This includes every executor and every job in the system.\n     */\n    @Exported\n    public transient final OverallLoadStatistics overallLoad = new OverallLoadStatistics();\n\n    /**\n     * Load statistics of the free roaming jobs and slaves.\n     * \n     * This includes all executors on {@link Mode#NORMAL} nodes and jobs that do not have any assigned nodes.\n     *\n     * @since 1.467\n     */\n    @Exported\n    public transient final LoadStatistics unlabeledLoad = new UnlabeledLoadStatistics();\n\n    /**\n     * {@link NodeProvisioner} that reacts to {@link #unlabeledLoad}.\n     * @since 1.467\n     */\n    public transient final NodeProvisioner unlabeledNodeProvisioner = new NodeProvisioner(null,unlabeledLoad);\n\n    /**\n     * @deprecated as of 1.467\n     *      Use {@link #unlabeledNodeProvisioner}.\n     *      This was broken because it was tracking all the executors in the system, but it was only tracking\n     *      free-roaming jobs in the queue. So {@link Cloud} fails to launch nodes when you have some exclusive\n     *      slaves and free-roaming jobs in the queue.\n     */\n    @Restricted(NoExternalUse.class)\n    public transient final NodeProvisioner overallNodeProvisioner = unlabeledNodeProvisioner;\n\n\n    public transient final ServletContext servletContext;\n\n    /**\n     * Transient action list. Useful for adding navigation items to the navigation bar\n     * on the left.\n     */\n    private transient final List<Action> actions = new CopyOnWriteArrayList<Action>();\n\n    /**\n     * List of master node properties\n     */\n    private DescribableList<NodeProperty<?>,NodePropertyDescriptor> nodeProperties = new DescribableList<NodeProperty<?>,NodePropertyDescriptor>(this);\n\n    /**\n     * List of global properties\n     */\n    private DescribableList<NodeProperty<?>,NodePropertyDescriptor> globalNodeProperties = new DescribableList<NodeProperty<?>,NodePropertyDescriptor>(this);\n\n    /**\n     * {@link AdministrativeMonitor}s installed on this system.\n     *\n     * @see AdministrativeMonitor\n     */\n    public transient final List<AdministrativeMonitor> administrativeMonitors = getExtensionList(AdministrativeMonitor.class);\n\n    /**\n     * Widgets on Hudson.\n     */\n    private transient final List<Widget> widgets = getExtensionList(Widget.class);\n\n    /**\n     * {@link AdjunctManager}\n     */\n    private transient final AdjunctManager adjuncts;\n\n    /**\n     * Code that handles {@link ItemGroup} work.\n     */\n    private transient final ItemGroupMixIn itemGroupMixIn = new ItemGroupMixIn(this,this) {\n        @Override\n        protected void add(TopLevelItem item) {\n            items.put(item.getName(),item);\n        }\n\n        @Override\n        protected File getRootDirFor(String name) {\n            return Jenkins.this.getRootDirFor(name);\n        }\n\n        /**\n         * Send the browser to the config page.\n         * use View to trim view/{default-view} from URL if possible\n         */\n        @Override\n        protected String redirectAfterCreateItem(StaplerRequest req, TopLevelItem result) throws IOException {\n            String redirect = result.getUrl()+\"configure\";\n            List<Ancestor> ancestors = req.getAncestors();\n            for (int i = ancestors.size() - 1; i >= 0; i--) {\n                Object o = ancestors.get(i).getObject();\n                if (o instanceof View) {\n                    redirect = req.getContextPath() + '/' + ((View)o).getUrl() + redirect;\n                    break;\n                }\n            }\n            return redirect;\n        }\n    };\n\n\n    /**\n     * Hook for a test harness to intercept Jenkins.getInstance()\n     *\n     * Do not use in the production code as the signature may change.\n     */\n    public interface JenkinsHolder {\n        Jenkins getInstance();\n    }\n\n    static JenkinsHolder HOLDER = new JenkinsHolder() {\n        public Jenkins getInstance() {\n            return theInstance;\n        }\n    };\n\n    @CLIResolver\n    public static Jenkins getInstance() {\n        return HOLDER.getInstance();\n    }\n\n    /**\n     * Secret key generated once and used for a long time, beyond\n     * container start/stop. Persisted outside <tt>config.xml</tt> to avoid\n     * accidental exposure.\n     */\n    private transient final String secretKey;\n\n    private transient final UpdateCenter updateCenter = new UpdateCenter();\n\n    /**\n     * True if the user opted out from the statistics tracking. We'll never send anything if this is true.\n     */\n    private Boolean noUsageStatistics;\n\n    /**\n     * HTTP proxy configuration.\n     */\n    public transient volatile ProxyConfiguration proxy;\n\n    /**\n     * Bound to \"/log\".\n     */\n    private transient final LogRecorderManager log = new LogRecorderManager();\n\n    protected Jenkins(File root, ServletContext context) throws IOException, InterruptedException, ReactorException {\n        this(root,context,null);\n    }\n\n    /**\n     * @param pluginManager\n     *      If non-null, use existing plugin manager.  create a new one.\n     */\n    @edu.umd.cs.findbugs.annotations.SuppressWarnings({\n        \"SC_START_IN_CTOR\", // bug in FindBugs. It flags UDPBroadcastThread.start() call but that's for another class\n        \"ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD\" // Trigger.timer\n    })\n    protected Jenkins(File root, ServletContext context, PluginManager pluginManager) throws IOException, InterruptedException, ReactorException {\n        long start = System.currentTimeMillis();\n        \n    \t// As Jenkins is starting, grant this process full control\n        ACL.impersonate(ACL.SYSTEM);\n        try {\n            this.root = root;\n            this.servletContext = context;\n            computeVersion(context);\n            if(theInstance!=null)\n                throw new IllegalStateException(\"second instance\");\n            theInstance = this;\n\n            if (!new File(root,\"jobs\").exists()) {\n                // if this is a fresh install, use more modern default layout that's consistent with slaves\n                workspaceDir = \"${JENKINS_HOME}/workspace/${ITEM_FULLNAME}\";\n            }\n\n            // doing this early allows InitStrategy to set environment upfront\n            final InitStrategy is = InitStrategy.get(Thread.currentThread().getContextClassLoader());\n\n            Trigger.timer = new Timer(\"Jenkins cron thread\");\n            queue = new Queue(LoadBalancer.CONSISTENT_HASH);\n\n            try {\n                dependencyGraph = DependencyGraph.EMPTY;\n            } catch (InternalError e) {\n                if(e.getMessage().contains(\"window server\")) {\n                    throw new Error(\"Looks like the server runs without X. Please specify -Djava.awt.headless=true as JVM option\",e);\n                }\n                throw e;\n            }\n\n            // get or create the secret\n            TextFile secretFile = new TextFile(new File(getRootDir(),\"secret.key\"));\n            if(secretFile.exists()) {\n                secretKey = secretFile.readTrim();\n            } else {\n                SecureRandom sr = new SecureRandom();\n                byte[] random = new byte[32];\n                sr.nextBytes(random);\n                secretKey = Util.toHexString(random);\n                secretFile.write(secretKey);\n\n                // this marker indicates that the secret.key is generated by the version of Jenkins post SECURITY-49.\n                // this indicates that there's no need to rewrite secrets on disk\n                new FileBoolean(new File(root,\"secret.key.not-so-secret\")).on();\n            }\n\n            try {\n                proxy = ProxyConfiguration.load();\n            } catch (IOException e) {\n                LOGGER.log(SEVERE, \"Failed to load proxy configuration\", e);\n            }\n\n            if (pluginManager==null)\n                pluginManager = new LocalPluginManager(this);\n            this.pluginManager = pluginManager;\n            // JSON binding needs to be able to see all the classes from all the plugins\n            WebApp.get(servletContext).setClassLoader(pluginManager.uberClassLoader);\n\n            adjuncts = new AdjunctManager(servletContext, pluginManager.uberClassLoader,\"adjuncts/\"+SESSION_HASH, TimeUnit2.DAYS.toMillis(365));\n\n            // initialization consists of ...\n            executeReactor( is,\n                    pluginManager.initTasks(is),    // loading and preparing plugins\n                    loadTasks(),                    // load jobs\n                    InitMilestone.ordering()        // forced ordering among key milestones\n            );\n\n            if(KILL_AFTER_LOAD)\n                System.exit(0);\n\n            if(slaveAgentPort!=-1) {\n                try {\n                    tcpSlaveAgentListener = new TcpSlaveAgentListener(slaveAgentPort);\n                } catch (BindException e) {\n                    new AdministrativeError(getClass().getName()+\".tcpBind\",\n                            \"Failed to listen to incoming slave connection\",\n                            \"Failed to listen to incoming slave connection. <a href='configure'>Change the port number</a> to solve the problem.\",e);\n                }\n            } else\n                tcpSlaveAgentListener = null;\n\n            try {\n                udpBroadcastThread = new UDPBroadcastThread(this);\n                udpBroadcastThread.start();\n            } catch (IOException e) {\n                LOGGER.log(Level.WARNING, \"Failed to broadcast over UDP\",e);\n            }\n            dnsMultiCast = new DNSMultiCast(this);\n\n            Timer timer = Trigger.timer;\n            if (timer != null) {\n                timer.scheduleAtFixedRate(new SafeTimerTask() {\n                    @Override\n                    protected void doRun() throws Exception {\n                        trimLabels();\n                    }\n                }, TimeUnit2.MINUTES.toMillis(5), TimeUnit2.MINUTES.toMillis(5));\n            }\n\n            updateComputerList();\n\n            {// master is online now\n                Computer c = toComputer();\n                if(c!=null)\n                    for (ComputerListener cl : ComputerListener.all())\n                        cl.onOnline(c,StreamTaskListener.fromStdout());\n            }\n\n            for (ItemListener l : ItemListener.all()) {\n                long itemListenerStart = System.currentTimeMillis();\n                l.onLoaded();\n                if (LOG_STARTUP_PERFORMANCE)\n                    LOGGER.info(String.format(\"Took %dms for item listener %s startup\",\n                            System.currentTimeMillis()-itemListenerStart,l.getClass().getName()));\n            }\n            \n            if (LOG_STARTUP_PERFORMANCE)\n                LOGGER.info(String.format(\"Took %dms for complete Jenkins startup\",\n                        System.currentTimeMillis()-start));\n        } finally {\n            SecurityContextHolder.clearContext();\n        }\n    }\n\n    /**\n     * Executes a reactor.\n     *\n     * @param is\n     *      If non-null, this can be consulted for ignoring some tasks. Only used during the initialization of Hudson.\n     */\n    private void executeReactor(final InitStrategy is, TaskBuilder... builders) throws IOException, InterruptedException, ReactorException {\n        Reactor reactor = new Reactor(builders) {\n            /**\n             * Sets the thread name to the task for better diagnostics.\n             */\n            @Override\n            protected void runTask(Task task) throws Exception {\n                if (is!=null && is.skipInitTask(task))  return;\n\n                ACL.impersonate(ACL.SYSTEM); // full access in the initialization thread\n                String taskName = task.getDisplayName();\n\n                Thread t = Thread.currentThread();\n                String name = t.getName();\n                if (taskName !=null)\n                    t.setName(taskName);\n                try {\n                    long start = System.currentTimeMillis();\n                    super.runTask(task);\n                    if(LOG_STARTUP_PERFORMANCE)\n                        LOGGER.info(String.format(\"Took %dms for %s by %s\",\n                                System.currentTimeMillis()-start, taskName, name));\n                } finally {\n                    t.setName(name);\n                    SecurityContextHolder.clearContext();\n                }\n            }\n        };\n\n        new InitReactorRunner() {\n            @Override\n            protected void onInitMilestoneAttained(InitMilestone milestone) {\n                initLevel = milestone;\n            }\n        }.run(reactor);\n    }\n\n\n    public TcpSlaveAgentListener getTcpSlaveAgentListener() {\n        return tcpSlaveAgentListener;\n    }\n\n    /**\n     * Makes {@link AdjunctManager} URL-bound.\n     * The dummy parameter allows us to use different URLs for the same adjunct,\n     * for proper cache handling.\n     */\n    public AdjunctManager getAdjuncts(String dummy) {\n        return adjuncts;\n    }\n\n    @Exported\n    public int getSlaveAgentPort() {\n        return slaveAgentPort;\n    }\n\n    /**\n     * @param port\n     *      0 to indicate random available TCP port. -1 to disable this service.\n     */\n    public void setSlaveAgentPort(int port) throws IOException {\n        this.slaveAgentPort = port;\n\n        // relaunch the agent\n        if(tcpSlaveAgentListener==null) {\n            if(slaveAgentPort!=-1)\n                tcpSlaveAgentListener = new TcpSlaveAgentListener(slaveAgentPort);\n        } else {\n            if(tcpSlaveAgentListener.configuredPort!=slaveAgentPort) {\n                tcpSlaveAgentListener.shutdown();\n                tcpSlaveAgentListener = null;\n                if(slaveAgentPort!=-1)\n                    tcpSlaveAgentListener = new TcpSlaveAgentListener(slaveAgentPort);\n            }\n        }\n    }\n\n    public void setNodeName(String name) {\n        throw new UnsupportedOperationException(); // not allowed\n    }\n\n    public String getNodeDescription() {\n        return Messages.Hudson_NodeDescription();\n    }\n\n    @Exported\n    public String getDescription() {\n        return systemMessage;\n    }\n\n    public PluginManager getPluginManager() {\n        return pluginManager;\n    }\n\n    public UpdateCenter getUpdateCenter() {\n        return updateCenter;\n    }\n\n    public boolean isUsageStatisticsCollected() {\n        return noUsageStatistics==null || !noUsageStatistics;\n    }\n\n    public void setNoUsageStatistics(Boolean noUsageStatistics) throws IOException {\n        this.noUsageStatistics = noUsageStatistics;\n        save();\n    }\n\n    public View.People getPeople() {\n        return new View.People(this);\n    }\n\n    /**\n     * @since 1.484\n     */\n    public View.AsynchPeople getAsynchPeople() {\n        return new View.AsynchPeople(this);\n    }\n\n    /**\n     * Does this {@link View} has any associated user information recorded?\n     * @deprecated Potentially very expensive call; do not use from Jelly views.\n     */\n    public boolean hasPeople() {\n        return View.People.isApplicable(items.values());\n    }\n\n    public Api getApi() {\n        return new Api(this);\n    }\n\n    /**\n     * Returns a secret key that survives across container start/stop.\n     * <p>\n     * This value is useful for implementing some of the security features.\n     *\n     * @deprecated\n     *      Due to the past security advisory, this value should not be used any more to protect sensitive information.\n     *      See {@link ConfidentialStore} and {@link ConfidentialKey} for how to store secrets.\n     */\n    public String getSecretKey() {\n        return secretKey;\n    }\n\n    /**\n     * Gets {@linkplain #getSecretKey() the secret key} as a key for AES-128.\n     * @since 1.308\n     * @deprecated\n     *       See {@link #getSecretKey()}.\n     */\n    public SecretKey getSecretKeyAsAES128() {\n        return Util.toAes128Key(secretKey);\n    }\n\n    /**\n     * Returns the unique identifier of this Jenkins that has been historically used to identify\n     * this Jenkins to the outside world.\n     *\n     * <p>\n     * This form of identifier is weak in that it can be impersonated by others. See\n     * https://wiki.jenkins-ci.org/display/JENKINS/Instance+Identity for more modern form of instance ID\n     * that can be challenged and verified.\n     *\n     * @since 1.498\n     */\n    @SuppressWarnings(\"deprecation\")\n    public String getLegacyInstanceId() {\n        return Util.getDigestOf(getSecretKey());\n    }\n\n    /**\n     * Gets the SCM descriptor by name. Primarily used for making them web-visible.\n     */\n    public Descriptor<SCM> getScm(String shortClassName) {\n        return findDescriptor(shortClassName,SCM.all());\n    }\n\n    /**\n     * Gets the repository browser descriptor by name. Primarily used for making them web-visible.\n     */\n    public Descriptor<RepositoryBrowser<?>> getRepositoryBrowser(String shortClassName) {\n        return findDescriptor(shortClassName,RepositoryBrowser.all());\n    }\n\n    /**\n     * Gets the builder descriptor by name. Primarily used for making them web-visible.\n     */\n    public Descriptor<Builder> getBuilder(String shortClassName) {\n        return findDescriptor(shortClassName, Builder.all());\n    }\n\n    /**\n     * Gets the build wrapper descriptor by name. Primarily used for making them web-visible.\n     */\n    public Descriptor<BuildWrapper> getBuildWrapper(String shortClassName) {\n        return findDescriptor(shortClassName, BuildWrapper.all());\n    }\n\n    /**\n     * Gets the publisher descriptor by name. Primarily used for making them web-visible.\n     */\n    public Descriptor<Publisher> getPublisher(String shortClassName) {\n        return findDescriptor(shortClassName, Publisher.all());\n    }\n\n    /**\n     * Gets the trigger descriptor by name. Primarily used for making them web-visible.\n     */\n    public TriggerDescriptor getTrigger(String shortClassName) {\n        return (TriggerDescriptor) findDescriptor(shortClassName, Trigger.all());\n    }\n\n    /**\n     * Gets the retention strategy descriptor by name. Primarily used for making them web-visible.\n     */\n    public Descriptor<RetentionStrategy<?>> getRetentionStrategy(String shortClassName) {\n        return findDescriptor(shortClassName, RetentionStrategy.all());\n    }\n\n    /**\n     * Gets the {@link JobPropertyDescriptor} by name. Primarily used for making them web-visible.\n     */\n    public JobPropertyDescriptor getJobProperty(String shortClassName) {\n        // combining these two lines triggers javac bug. See issue #610.\n        Descriptor d = findDescriptor(shortClassName, JobPropertyDescriptor.all());\n        return (JobPropertyDescriptor) d;\n    }\n\n    /**\n     * @deprecated\n     *      UI method. Not meant to be used programatically.\n     */\n    public ComputerSet getComputer() {\n        return new ComputerSet();\n    }\n\n    /**\n     * Exposes {@link Descriptor} by its name to URL.\n     *\n     * After doing all the {@code getXXX(shortClassName)} methods, I finally realized that\n     * this just doesn't scale.\n     *\n     * @param id\n     *      Either {@link Descriptor#getId()} (recommended) or the short name of a {@link Describable} subtype (for compatibility)\n     * @throws IllegalArgumentException if a short name was passed which matches multiple IDs (fail fast)\n     */\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // too late to fix\n    public Descriptor getDescriptor(String id) {\n        // legacy descriptors that are reigstered manually doesn't show up in getExtensionList, so check them explicitly.\n        Iterable<Descriptor> descriptors = Iterators.sequence(getExtensionList(Descriptor.class), DescriptorExtensionList.listLegacyInstances());\n        for (Descriptor d : descriptors) {\n            if (d.getId().equals(id)) {\n                return d;\n            }\n        }\n        Descriptor candidate = null;\n        for (Descriptor d : descriptors) {\n            String name = d.getId();\n            if (name.substring(name.lastIndexOf('.') + 1).equals(id)) {\n                if (candidate == null) {\n                    candidate = d;\n                } else {\n                    throw new IllegalArgumentException(id + \" is ambiguous; matches both \" + name + \" and \" + candidate.getId());\n                }\n            }\n        }\n        return candidate;\n    }\n\n    /**\n     * Alias for {@link #getDescriptor(String)}.\n     */\n    public Descriptor getDescriptorByName(String id) {\n        return getDescriptor(id);\n    }\n\n    /**\n     * Gets the {@link Descriptor} that corresponds to the given {@link Describable} type.\n     * <p>\n     * If you have an instance of {@code type} and call {@link Describable#getDescriptor()},\n     * you'll get the same instance that this method returns.\n     */\n    public Descriptor getDescriptor(Class<? extends Describable> type) {\n        for( Descriptor d : getExtensionList(Descriptor.class) )\n            if(d.clazz==type)\n                return d;\n        return null;\n    }\n\n    /**\n     * Works just like {@link #getDescriptor(Class)} but don't take no for an answer.\n     *\n     * @throws AssertionError\n     *      If the descriptor is missing.\n     * @since 1.326\n     */\n    public Descriptor getDescriptorOrDie(Class<? extends Describable> type) {\n        Descriptor d = getDescriptor(type);\n        if (d==null)\n            throw new AssertionError(type+\" is missing its descriptor\");\n        return d;\n    }\n\n    /**\n     * Gets the {@link Descriptor} instance in the current Hudson by its type.\n     */\n    public <T extends Descriptor> T getDescriptorByType(Class<T> type) {\n        for( Descriptor d : getExtensionList(Descriptor.class) )\n            if(d.getClass()==type)\n                return type.cast(d);\n        return null;\n    }\n\n    /**\n     * Gets the {@link SecurityRealm} descriptors by name. Primarily used for making them web-visible.\n     */\n    public Descriptor<SecurityRealm> getSecurityRealms(String shortClassName) {\n        return findDescriptor(shortClassName,SecurityRealm.all());\n    }\n\n    /**\n     * Finds a descriptor that has the specified name.\n     */\n    private <T extends Describable<T>>\n    Descriptor<T> findDescriptor(String shortClassName, Collection<? extends Descriptor<T>> descriptors) {\n        String name = '.'+shortClassName;\n        for (Descriptor<T> d : descriptors) {\n            if(d.clazz.getName().endsWith(name))\n                return d;\n        }\n        return null;\n    }\n\n    protected void updateComputerList() throws IOException {\n        updateComputerList(AUTOMATIC_SLAVE_LAUNCH);\n    }\n\n    /**\n     * Gets all the installed {@link SCMListener}s.\n     */\n    public CopyOnWriteList<SCMListener> getSCMListeners() {\n        return scmListeners;\n    }\n\n    /**\n     * Gets the plugin object from its short name.\n     *\n     * <p>\n     * This allows URL <tt>hudson/plugin/ID</tt> to be served by the views\n     * of the plugin class.\n     */\n    public Plugin getPlugin(String shortName) {\n        PluginWrapper p = pluginManager.getPlugin(shortName);\n        if(p==null)     return null;\n        return p.getPlugin();\n    }\n\n    /**\n     * Gets the plugin object from its class.\n     *\n     * <p>\n     * This allows easy storage of plugin information in the plugin singleton without\n     * every plugin reimplementing the singleton pattern.\n     *\n     * @param clazz The plugin class (beware class-loader fun, this will probably only work\n     * from within the jpi that defines the plugin class, it may or may not work in other cases)\n     *\n     * @return The plugin instance.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <P extends Plugin> P getPlugin(Class<P> clazz) {\n        PluginWrapper p = pluginManager.getPlugin(clazz);\n        if(p==null)     return null;\n        return (P) p.getPlugin();\n    }\n\n    /**\n     * Gets the plugin objects from their super-class.\n     *\n     * @param clazz The plugin class (beware class-loader fun)\n     *\n     * @return The plugin instances.\n     */\n    public <P extends Plugin> List<P> getPlugins(Class<P> clazz) {\n        List<P> result = new ArrayList<P>();\n        for (PluginWrapper w: pluginManager.getPlugins(clazz)) {\n            result.add((P)w.getPlugin());\n        }\n        return Collections.unmodifiableList(result);\n    }\n\n    /**\n     * Synonym for {@link #getDescription}.\n     */\n    public String getSystemMessage() {\n        return systemMessage;\n    }\n\n    /**\n     * Gets the markup formatter used in the system.\n     *\n     * @return\n     *      never null.\n     * @since 1.391\n     */\n    public MarkupFormatter getMarkupFormatter() {\n        return markupFormatter!=null ? markupFormatter : RawHtmlMarkupFormatter.INSTANCE;\n    }\n\n    /**\n     * Sets the markup formatter used in the system globally.\n     *\n     * @since 1.391\n     */\n    public void setMarkupFormatter(MarkupFormatter f) {\n        this.markupFormatter = f;\n    }\n\n    /**\n     * Sets the system message.\n     */\n    public void setSystemMessage(String message) throws IOException {\n        this.systemMessage = message;\n        save();\n    }\n\n    public FederatedLoginService getFederatedLoginService(String name) {\n        for (FederatedLoginService fls : FederatedLoginService.all()) {\n            if (fls.getUrlName().equals(name))\n                return fls;\n        }\n        return null;\n    }\n\n    public List<FederatedLoginService> getFederatedLoginServices() {\n        return FederatedLoginService.all();\n    }\n\n    public Launcher createLauncher(TaskListener listener) {\n        return new LocalLauncher(listener).decorateFor(this);\n    }\n\n\n    public String getFullName() {\n        return \"\";\n    }\n\n    public String getFullDisplayName() {\n        return \"\";\n    }\n\n    /**\n     * Returns the transient {@link Action}s associated with the top page.\n     *\n     * <p>\n     * Adding {@link Action} is primarily useful for plugins to contribute\n     * an item to the navigation bar of the top page. See existing {@link Action}\n     * implementation for it affects the GUI.\n     *\n     * <p>\n     * To register an {@link Action}, implement {@link RootAction} extension point, or write code like\n     * {@code Hudson.getInstance().getActions().add(...)}.\n     *\n     * @return\n     *      Live list where the changes can be made. Can be empty but never null.\n     * @since 1.172\n     */\n    public List<Action> getActions() {\n        return actions;\n    }\n\n    /**\n     * Gets just the immediate children of {@link Jenkins}.\n     *\n     * @see #getAllItems(Class)\n     */\n    @Exported(name=\"jobs\")\n    public List<TopLevelItem> getItems() {\n\t\tif (authorizationStrategy instanceof AuthorizationStrategy.Unsecured ||\n\t\t\tauthorizationStrategy instanceof FullControlOnceLoggedInAuthorizationStrategy) {\n\t\t\treturn new ArrayList(items.values());\n\t\t}\n\n        List<TopLevelItem> viewableItems = new ArrayList<TopLevelItem>();\n        for (TopLevelItem item : items.values()) {\n            if (item.hasPermission(Item.READ))\n                viewableItems.add(item);\n        }\n\t\t\n        return viewableItems;\n    }\n\n    /**\n     * Returns the read-only view of all the {@link TopLevelItem}s keyed by their names.\n     * <p>\n     * This method is efficient, as it doesn't involve any copying.\n     *\n     * @since 1.296\n     */\n    public Map<String,TopLevelItem> getItemMap() {\n        return Collections.unmodifiableMap(items);\n    }\n\n    /**\n     * Gets just the immediate children of {@link Jenkins} but of the given type.\n     */\n    public <T> List<T> getItems(Class<T> type) {\n        List<T> r = new ArrayList<T>();\n        for (TopLevelItem i : getItems())\n            if (type.isInstance(i))\n                 r.add(type.cast(i));\n        return r;\n    }\n\n    /**\n     * Gets all the {@link Item}s recursively in the {@link ItemGroup} tree\n     * and filter them by the given type.\n     */\n    public <T extends Item> List<T> getAllItems(Class<T> type) {\n        List<T> r = new ArrayList<T>();\n\n        Stack<ItemGroup> q = new Stack<ItemGroup>();\n        q.push(this);\n\n        while(!q.isEmpty()) {\n            ItemGroup<?> parent = q.pop();\n            for (Item i : parent.getItems()) {\n                if(type.isInstance(i)) {\n                    if (i.hasPermission(Item.READ))\n                        r.add(type.cast(i));\n                }\n                if(i instanceof ItemGroup)\n                    q.push((ItemGroup)i);\n            }\n        }\n\n        return r;\n    }\n\n    /**\n     * Gets all the items recursively.\n     *\n     * @since 1.402\n     */\n    public List<Item> getAllItems() {\n        return getAllItems(Item.class);\n    }\n\n    /**\n     * Gets a list of simple top-level projects.\n     * @deprecated This method will ignore Maven and matrix projects, as well as projects inside containers such as folders.\n     * You may prefer to call {@link #getAllItems(Class)} on {@link AbstractProject},\n     * perhaps also using {@link Util#createSubList} to consider only {@link TopLevelItem}s.\n     * (That will also consider the caller's permissions.)\n     * If you really want to get just {@link Project}s at top level, ignoring permissions,\n     * you can filter the values from {@link #getItemMap} using {@link Util#createSubList}.\n     */\n    @Deprecated\n    public List<Project> getProjects() {\n        return Util.createSubList(items.values(),Project.class);\n    }\n\n    /**\n     * Gets the names of all the {@link Job}s.\n     */\n    public Collection<String> getJobNames() {\n        List<String> names = new ArrayList<String>();\n        for (Job j : getAllItems(Job.class))\n            names.add(j.getFullName());\n        return names;\n    }\n\n    public List<Action> getViewActions() {\n        return getActions();\n    }\n\n    /**\n     * Gets the names of all the {@link TopLevelItem}s.\n     */\n    public Collection<String> getTopLevelItemNames() {\n        List<String> names = new ArrayList<String>();\n        for (TopLevelItem j : items.values())\n            names.add(j.getName());\n        return names;\n    }\n\n    public View getView(String name) {\n        return viewGroupMixIn.getView(name);\n    }\n\n    /**\n     * Gets the read-only list of all {@link View}s.\n     */\n    @Exported\n    public Collection<View> getViews() {\n        return viewGroupMixIn.getViews();\n    }\n\n    public void addView(View v) throws IOException {\n        viewGroupMixIn.addView(v);\n    }\n\n    public boolean canDelete(View view) {\n        return viewGroupMixIn.canDelete(view);\n    }\n\n    public synchronized void deleteView(View view) throws IOException {\n        viewGroupMixIn.deleteView(view);\n    }\n\n    public void onViewRenamed(View view, String oldName, String newName) {\n        viewGroupMixIn.onViewRenamed(view,oldName,newName);\n    }\n\n    /**\n     * Returns the primary {@link View} that renders the top-page of Hudson.\n     */\n    @Exported\n    public View getPrimaryView() {\n        return viewGroupMixIn.getPrimaryView();\n     }\n\n    public void setPrimaryView(View v) {\n        this.primaryView = v.getViewName();\n    }\n\n    public ViewsTabBar getViewsTabBar() {\n        return viewsTabBar;\n    }\n\n    public void setViewsTabBar(ViewsTabBar viewsTabBar) {\n        this.viewsTabBar = viewsTabBar;\n    }\n\n    public Jenkins getItemGroup() {\n        return this;\n   }\n\n    public MyViewsTabBar getMyViewsTabBar() {\n        return myViewsTabBar;\n    }\n\n    public void setMyViewsTabBar(MyViewsTabBar myViewsTabBar) {\n        this.myViewsTabBar = myViewsTabBar;\n    }\n\n    /**\n     * Returns true if the current running Jenkins is upgraded from a version earlier than the specified version.\n     *\n     * <p>\n     * This method continues to return true until the system configuration is saved, at which point\n     * {@link #version} will be overwritten and Hudson forgets the upgrade history.\n     *\n     * <p>\n     * To handle SNAPSHOTS correctly, pass in \"1.N.*\" to test if it's upgrading from the version\n     * equal or younger than N. So say if you implement a feature in 1.301 and you want to check\n     * if the installation upgraded from pre-1.301, pass in \"1.300.*\"\n     *\n     * @since 1.301\n     */\n    public boolean isUpgradedFromBefore(VersionNumber v) {\n        try {\n            return new VersionNumber(version).isOlderThan(v);\n        } catch (IllegalArgumentException e) {\n            // fail to parse this version number\n            return false;\n        }\n    }\n\n    /**\n     * Gets the read-only list of all {@link Computer}s.\n     */\n    public Computer[] getComputers() {\n        Computer[] r = computers.values().toArray(new Computer[computers.size()]);\n        Arrays.sort(r,new Comparator<Computer>() {\n            final Collator collator = Collator.getInstance();\n            public int compare(Computer lhs, Computer rhs) {\n                if(lhs.getNode()==Jenkins.this)  return -1;\n                if(rhs.getNode()==Jenkins.this)  return 1;\n                return collator.compare(lhs.getDisplayName(), rhs.getDisplayName());\n            }\n        });\n        return r;\n    }\n\n    @CLIResolver\n    public Computer getComputer(@Argument(required=true,metaVar=\"NAME\",usage=\"Node name\") String name) {\n        if(name.equals(\"(master)\"))\n            name = \"\";\n\n        for (Computer c : computers.values()) {\n            if(c.getName().equals(name))\n                return c;\n        }\n        return null;\n    }\n\n    /**\n     * Gets the label that exists on this system by the name.\n     *\n     * @return null if name is null.\n     * @see Label#parseExpression(String) (String)\n     */\n    public Label getLabel(String expr) {\n        if(expr==null)  return null;\n        expr = hudson.util.QuotedStringTokenizer.unquote(expr);\n        while(true) {\n            Label l = labels.get(expr);\n            if(l!=null)\n                return l;\n\n            // non-existent\n            try {\n                labels.putIfAbsent(expr,Label.parseExpression(expr));\n            } catch (ANTLRException e) {\n                // laxly accept it as a single label atom for backward compatibility\n                return getLabelAtom(expr);\n            }\n        }\n    }\n\n    /**\n     * Returns the label atom of the given name.\n     * @return non-null iff name is non-null\n     */\n    public @Nullable LabelAtom getLabelAtom(@CheckForNull String name) {\n        if (name==null)  return null;\n\n        while(true) {\n            Label l = labels.get(name);\n            if(l!=null)\n                return (LabelAtom)l;\n\n            // non-existent\n            LabelAtom la = new LabelAtom(name);\n            if (labels.putIfAbsent(name, la)==null)\n                la.load();\n        }\n    }\n\n    /**\n     * Gets all the active labels in the current system.\n     */\n    public Set<Label> getLabels() {\n        Set<Label> r = new TreeSet<Label>();\n        for (Label l : labels.values()) {\n            if(!l.isEmpty())\n                r.add(l);\n        }\n        return r;\n    }\n\n    public Set<LabelAtom> getLabelAtoms() {\n        Set<LabelAtom> r = new TreeSet<LabelAtom>();\n        for (Label l : labels.values()) {\n            if(!l.isEmpty() && l instanceof LabelAtom)\n                r.add((LabelAtom)l);\n        }\n        return r;\n    }\n\n    public Queue getQueue() {\n        return queue;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return Messages.Hudson_DisplayName();\n    }\n\n    public List<JDK> getJDKs() {\n        if(jdks==null)\n            jdks = new ArrayList<JDK>();\n        return jdks;\n    }\n\n    /**\n     * Gets the JDK installation of the given name, or returns null.\n     */\n    public JDK getJDK(String name) {\n        if(name==null) {\n            // if only one JDK is configured, \"default JDK\" should mean that JDK.\n            List<JDK> jdks = getJDKs();\n            if(jdks.size()==1)  return jdks.get(0);\n            return null;\n        }\n        for (JDK j : getJDKs()) {\n            if(j.getName().equals(name))\n                return j;\n        }\n        return null;\n    }\n\n\n\n    /**\n     * Gets the slave node of the give name, hooked under this Hudson.\n     */\n    public @CheckForNull Node getNode(String name) {\n        return slaves.getNode(name);\n    }\n\n    /**\n     * Gets a {@link Cloud} by {@link Cloud#name its name}, or null.\n     */\n    public Cloud getCloud(String name) {\n        return clouds.getByName(name);\n    }\n\n    protected Map<Node,Computer> getComputerMap() {\n        return computers;\n    }\n\n    /**\n     * Returns all {@link Node}s in the system, excluding {@link Jenkins} instance itself which\n     * represents the master.\n     */\n    public List<Node> getNodes() {\n        return slaves;\n    }\n\n    /**\n     * Adds one more {@link Node} to Hudson.\n     */\n    public synchronized void addNode(Node n) throws IOException {\n        if(n==null)     throw new IllegalArgumentException();\n        ArrayList<Node> nl = new ArrayList<Node>(this.slaves);\n        if(!nl.contains(n)) // defensive check\n            nl.add(n);\n        setNodes(nl);\n    }\n\n    /**\n     * Removes a {@link Node} from Hudson.\n     */\n    public synchronized void removeNode(@Nonnull Node n) throws IOException {\n        Computer c = n.toComputer();\n        if (c!=null)\n            c.disconnect(OfflineCause.create(Messages._Hudson_NodeBeingRemoved()));\n\n        ArrayList<Node> nl = new ArrayList<Node>(this.slaves);\n        nl.remove(n);\n        setNodes(nl);\n    }\n\n    public void setNodes(List<? extends Node> nodes) throws IOException {\n        this.slaves = new NodeList(nodes);\n        updateComputerList();\n        trimLabels();\n        save();\n    }\n\n    public DescribableList<NodeProperty<?>, NodePropertyDescriptor> getNodeProperties() {\n    \treturn nodeProperties;\n    }\n\n    public DescribableList<NodeProperty<?>, NodePropertyDescriptor> getGlobalNodeProperties() {\n    \treturn globalNodeProperties;\n    }\n\n    /**\n     * Resets all labels and remove invalid ones.\n     *\n     * This should be called when the assumptions behind label cache computation changes,\n     * but we also call this periodically to self-heal any data out-of-sync issue.\n     */\n    private void trimLabels() {\n        for (Iterator<Label> itr = labels.values().iterator(); itr.hasNext();) {\n            Label l = itr.next();\n            resetLabel(l);\n            if(l.isEmpty())\n                itr.remove();\n        }\n    }\n\n    /**\n     * Binds {@link AdministrativeMonitor}s to URL.\n     */\n    public AdministrativeMonitor getAdministrativeMonitor(String id) {\n        for (AdministrativeMonitor m : administrativeMonitors)\n            if(m.id.equals(id))\n                return m;\n        return null;\n    }\n\n    public NodeDescriptor getDescriptor() {\n        return DescriptorImpl.INSTANCE;\n    }\n\n    public static final class DescriptorImpl extends NodeDescriptor {\n        @Extension\n        public static final DescriptorImpl INSTANCE = new DescriptorImpl();\n\n        public String getDisplayName() {\n            return \"\";\n        }\n\n        @Override\n        public boolean isInstantiable() {\n            return false;\n        }\n\n        public FormValidation doCheckNumExecutors(@QueryParameter String value) {\n            return FormValidation.validateNonNegativeInteger(value);\n        }\n\n        public FormValidation doCheckRawBuildsDir(@QueryParameter String value) {\n            if (!value.contains(\"${\")) {\n                File d = new File(value);\n                if (!d.isDirectory() && (d.getParentFile() == null || !d.getParentFile().canWrite())) {\n                    return FormValidation.error(value + \" does not exist and probably cannot be created\");\n                }\n                // XXX failure to use either ITEM_* variable might be an error too?\n            }\n            return FormValidation.ok(); // XXX assumes it will be OK after substitution, but can we be sure?\n        }\n\n        // to route /descriptor/FQCN/xxx to getDescriptor(FQCN).xxx\n        public Object getDynamic(String token) {\n            return Jenkins.getInstance().getDescriptor(token);\n        }\n    }\n\n    /**\n     * Gets the system default quiet period.\n     */\n    public int getQuietPeriod() {\n        return quietPeriod!=null ? quietPeriod : 5;\n    }\n\n    /**\n     * Sets the global quiet period.\n     *\n     * @param quietPeriod\n     *      null to the default value.\n     */\n    public void setQuietPeriod(Integer quietPeriod) throws IOException {\n        this.quietPeriod = quietPeriod;\n        save();\n    }\n\n    /**\n     * Gets the global SCM check out retry count.\n     */\n    public int getScmCheckoutRetryCount() {\n        return scmCheckoutRetryCount;\n    }\n\n    public void setScmCheckoutRetryCount(int scmCheckoutRetryCount) throws IOException {\n        this.scmCheckoutRetryCount = scmCheckoutRetryCount;\n        save();\n    }\n\n    @Override\n    public String getSearchUrl() {\n        return \"\";\n    }\n\n    @Override\n    public SearchIndexBuilder makeSearchIndex() {\n        return super.makeSearchIndex()\n            .add(\"configure\", \"config\",\"configure\")\n            .add(\"manage\")\n            .add(\"log\")\n            .add(new CollectionSearchIndex<TopLevelItem>() {\n                protected SearchItem get(String key) { return getItem(key); }\n                protected Collection<TopLevelItem> all() { return getItems(); }\n            })\n            .add(getPrimaryView().makeSearchIndex())\n            .add(new CollectionSearchIndex() {// for computers\n                protected Computer get(String key) { return getComputer(key); }\n                protected Collection<Computer> all() { return computers.values(); }\n            })\n            .add(new CollectionSearchIndex() {// for users\n                protected User get(String key) { return User.get(key,false); }\n                protected Collection<User> all() { return User.getAll(); }\n            })\n            .add(new CollectionSearchIndex() {// for views\n                protected View get(String key) { return getView(key); }\n                protected Collection<View> all() { return views; }\n            });\n    }\n\n    public String getUrlChildPrefix() {\n        return \"job\";\n    }\n\n    /**\n     * Gets the absolute URL of Jenkins,\n     * such as \"http://localhost/jenkins/\".\n     *\n     * <p>\n     * This method first tries to use the manually configured value, then\n     * fall back to {@link StaplerRequest#getRootPath()}.\n     * It is done in this order so that it can work correctly even in the face\n     * of a reverse proxy.\n     *\n     * @return\n     *      This method returns null if this parameter is not configured by the user.\n     *      The caller must gracefully deal with this situation.\n     *      The returned URL will always have the trailing '/'.\n     * @since 1.66\n     * @see Descriptor#getCheckUrl(String)\n     * @see #getRootUrlFromRequest()\n     * @see <a href=\"https://wiki.jenkins-ci.org/display/JENKINS/Hyperlinks+in+HTML\">Hyperlinks in HTML</a>\n     */\n    public String getRootUrl() {\n        String url = JenkinsLocationConfiguration.get().getUrl();\n        if(url!=null) {\n            return Util.ensureEndsWith(url,\"/\");\n        }\n        StaplerRequest req = Stapler.getCurrentRequest();\n        if(req!=null)\n            return getRootUrlFromRequest();\n        return null;\n    }\n\n    /**\n     * Is Jenkins running in HTTPS?\n     *\n     * Note that we can't really trust {@link StaplerRequest#isSecure()} because HTTPS might be terminated\n     * in the reverse proxy.\n     */\n    public boolean isRootUrlSecure() {\n        String url = getRootUrl();\n        return url!=null && url.startsWith(\"https\");\n    }\n\n    /**\n     * Gets the absolute URL of Hudson top page, such as \"http://localhost/hudson/\".\n     *\n     * <p>\n     * Unlike {@link #getRootUrl()}, which uses the manually configured value,\n     * this one uses the current request to reconstruct the URL. The benefit is\n     * that this is immune to the configuration mistake (users often fail to set the root URL\n     * correctly, especially when a migration is involved), but the downside\n     * is that unless you are processing a request, this method doesn't work.\n     *\n     * Please note that this will not work in all cases if Jenkins is running behind a\n     * reverse proxy (e.g. when user has switched off ProxyPreserveHost, which is\n     * default setup or the actual url uses https) and you should use getRootUrl if\n     * you want to be sure you reflect user setup.\n     * See https://wiki.jenkins-ci.org/display/JENKINS/Running+Jenkins+behind+Apache\n     *\n     * @since 1.263\n     */\n    public String getRootUrlFromRequest() {\n        StaplerRequest req = Stapler.getCurrentRequest();\n        StringBuilder buf = new StringBuilder();\n        buf.append(req.getScheme()+\"://\");\n        buf.append(req.getServerName());\n        if(req.getServerPort()!=80)\n            buf.append(':').append(req.getServerPort());\n        buf.append(req.getContextPath()).append('/');\n        return buf.toString();\n    }\n\n    public File getRootDir() {\n        return root;\n    }\n\n    public FilePath getWorkspaceFor(TopLevelItem item) {\n        for (WorkspaceLocator l : WorkspaceLocator.all()) {\n            FilePath workspace = l.locate(item, this);\n            if (workspace != null) {\n                return workspace;\n            }\n        }\n \n        return new FilePath(expandVariablesForDirectory(workspaceDir, item));\n    }\n\n    public File getBuildDirFor(Job job) {\n        return expandVariablesForDirectory(buildsDir, job);\n    }\n\n    private File expandVariablesForDirectory(String base, Item item) {\n        return new File(Util.replaceMacro(base, ImmutableMap.of(\n                \"JENKINS_HOME\", getRootDir().getPath(),\n                \"ITEM_ROOTDIR\", item.getRootDir().getPath(),\n                \"ITEM_FULLNAME\", item.getFullName(),   // legacy, deprecated\n                \"ITEM_FULL_NAME\", item.getFullName().replace(':','$')))); // safe, see JENKINS-12251\n    }\n    \n    public String getRawWorkspaceDir() {\n        return workspaceDir;\n    }\n\n    public String getRawBuildsDir() {\n        return buildsDir;\n    }\n\n    public FilePath getRootPath() {\n        return new FilePath(getRootDir());\n    }\n\n    @Override\n    public FilePath createPath(String absolutePath) {\n        return new FilePath((VirtualChannel)null,absolutePath);\n    }\n\n    public ClockDifference getClockDifference() {\n        return ClockDifference.ZERO;\n    }\n\n    /**\n     * For binding {@link LogRecorderManager} to \"/log\".\n     * Everything below here is admin-only, so do the check here.\n     */\n    public LogRecorderManager getLog() {\n        checkPermission(ADMINISTER);\n        return log;\n    }\n\n    /**\n     * A convenience method to check if there's some security\n     * restrictions in place.\n     */\n    @Exported\n    public boolean isUseSecurity() {\n        return securityRealm!=SecurityRealm.NO_AUTHENTICATION || authorizationStrategy!=AuthorizationStrategy.UNSECURED;\n    }\n    \n    public boolean isUseProjectNamingStrategy(){\n        return projectNamingStrategy != DefaultProjectNamingStrategy.DEFAULT_NAMING_STRATEGY;\n    }\n\n    /**\n     * If true, all the POST requests to Hudson would have to have crumb in it to protect\n     * Hudson from CSRF vulnerabilities.\n     */\n    @Exported\n    public boolean isUseCrumbs() {\n        return crumbIssuer!=null;\n    }\n\n    /**\n     * Returns the constant that captures the three basic security modes\n     * in Hudson.\n     */\n    public SecurityMode getSecurity() {\n        // fix the variable so that this code works under concurrent modification to securityRealm.\n        SecurityRealm realm = securityRealm;\n\n        if(realm==SecurityRealm.NO_AUTHENTICATION)\n            return SecurityMode.UNSECURED;\n        if(realm instanceof LegacySecurityRealm)\n            return SecurityMode.LEGACY;\n        return SecurityMode.SECURED;\n    }\n\n    /**\n     * @return\n     *      never null.\n     */\n    public SecurityRealm getSecurityRealm() {\n        return securityRealm;\n    }\n\n    public void setSecurityRealm(SecurityRealm securityRealm) {\n        if(securityRealm==null)\n            securityRealm= SecurityRealm.NO_AUTHENTICATION;\n        this.useSecurity = true;\n        this.securityRealm = securityRealm;\n        // reset the filters and proxies for the new SecurityRealm\n        try {\n            HudsonFilter filter = HudsonFilter.get(servletContext);\n            if (filter == null) {\n                // Fix for #3069: This filter is not necessarily initialized before the servlets.\n                // when HudsonFilter does come back, it'll initialize itself.\n                LOGGER.fine(\"HudsonFilter has not yet been initialized: Can't perform security setup for now\");\n            } else {\n                LOGGER.fine(\"HudsonFilter has been previously initialized: Setting security up\");\n                filter.reset(securityRealm);\n                LOGGER.fine(\"Security is now fully set up\");\n            }\n        } catch (ServletException e) {\n            // for binary compatibility, this method cannot throw a checked exception\n            throw new AcegiSecurityException(\"Failed to configure filter\",e) {};\n        }\n    }\n\n    public void setAuthorizationStrategy(AuthorizationStrategy a) {\n        if (a == null)\n            a = AuthorizationStrategy.UNSECURED;\n        useSecurity = true;\n        authorizationStrategy = a;\n    }\n\n    public void disableSecurity() {\n        useSecurity = null;\n        setSecurityRealm(SecurityRealm.NO_AUTHENTICATION);\n        authorizationStrategy = AuthorizationStrategy.UNSECURED;\n        markupFormatter = null;\n    }\n\n    public void setProjectNamingStrategy(ProjectNamingStrategy ns) {\n        if(ns == null){\n            ns = DefaultProjectNamingStrategy.DEFAULT_NAMING_STRATEGY;\n        }\n        projectNamingStrategy = ns;\n    }\n    \n    public Lifecycle getLifecycle() {\n        return Lifecycle.get();\n    }\n\n    /**\n     * Gets the dependency injection container that hosts all the extension implementations and other\n     * components in Jenkins.\n     *\n     * @since 1.GUICE\n     */\n    public Injector getInjector() {\n        return lookup(Injector.class);\n    }\n\n    /**\n     * Returns {@link ExtensionList} that retains the discovered instances for the given extension type.\n     *\n     * @param extensionType\n     *      The base type that represents the extension point. Normally {@link ExtensionPoint} subtype\n     *      but that's not a hard requirement.\n     * @return\n     *      Can be an empty list but never null.\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public <T> ExtensionList<T> getExtensionList(Class<T> extensionType) {\n        return extensionLists.get(extensionType);\n    }\n\n    /**\n     * Used to bind {@link ExtensionList}s to URLs.\n     *\n     * @since 1.349\n     */\n    public ExtensionList getExtensionList(String extensionType) throws ClassNotFoundException {\n        return getExtensionList(pluginManager.uberClassLoader.loadClass(extensionType));\n    }\n\n    /**\n     * Returns {@link ExtensionList} that retains the discovered {@link Descriptor} instances for the given\n     * kind of {@link Describable}.\n     *\n     * @return\n     *      Can be an empty list but never null.\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public <T extends Describable<T>,D extends Descriptor<T>> DescriptorExtensionList<T,D> getDescriptorList(Class<T> type) {\n        return descriptorLists.get(type);\n    }\n\n    /**\n     * Refresh {@link ExtensionList}s by adding all the newly discovered extensions.\n     *\n     * Exposed only for {@link PluginManager#dynamicLoad(File)}.\n     */\n    public void refreshExtensions() throws ExtensionRefreshException {\n        ExtensionList<ExtensionFinder> finders = getExtensionList(ExtensionFinder.class);\n        for (ExtensionFinder ef : finders) {\n            if (!ef.isRefreshable())\n                throw new ExtensionRefreshException(ef+\" doesn't support refresh\");\n        }\n\n        List<ExtensionComponentSet> fragments = Lists.newArrayList();\n        for (ExtensionFinder ef : finders) {\n            fragments.add(ef.refresh());\n        }\n        ExtensionComponentSet delta = ExtensionComponentSet.union(fragments).filtered();\n\n        // if we find a new ExtensionFinder, we need it to list up all the extension points as well\n        List<ExtensionComponent<ExtensionFinder>> newFinders = Lists.newArrayList(delta.find(ExtensionFinder.class));\n        while (!newFinders.isEmpty()) {\n            ExtensionFinder f = newFinders.remove(newFinders.size()-1).getInstance();\n\n            ExtensionComponentSet ecs = ExtensionComponentSet.allOf(f).filtered();\n            newFinders.addAll(ecs.find(ExtensionFinder.class));\n            delta = ExtensionComponentSet.union(delta, ecs);\n        }\n\n        for (ExtensionList el : extensionLists.values()) {\n            el.refresh(delta);\n        }\n        for (ExtensionList el : descriptorLists.values()) {\n            el.refresh(delta);\n        }\n\n        // TODO: we need some generalization here so that extension points can be notified when a refresh happens?\n        for (ExtensionComponent<RootAction> ea : delta.find(RootAction.class)) {\n            Action a = ea.getInstance();\n            if (!actions.contains(a)) actions.add(a);\n        }\n    }\n\n    /**\n     * Returns the root {@link ACL}.\n     *\n     * @see AuthorizationStrategy#getRootACL()\n     */\n    @Override\n    public ACL getACL() {\n        return authorizationStrategy.getRootACL();\n    }\n\n    /**\n     * @return\n     *      never null.\n     */\n    public AuthorizationStrategy getAuthorizationStrategy() {\n        return authorizationStrategy;\n    }\n    \n    /**\n     * The strategy used to check the project names.\n     * @return never <code>null</code>\n     */\n    public ProjectNamingStrategy getProjectNamingStrategy() {\n        return projectNamingStrategy == null ? ProjectNamingStrategy.DEFAULT_NAMING_STRATEGY : projectNamingStrategy;\n    }\n\n    /**\n     * Returns true if Hudson is quieting down.\n     * <p>\n     * No further jobs will be executed unless it\n     * can be finished while other current pending builds\n     * are still in progress.\n     */\n    @Exported\n    public boolean isQuietingDown() {\n        return isQuietingDown;\n    }\n\n    /**\n     * Returns true if the container initiated the termination of the web application.\n     */\n    public boolean isTerminating() {\n        return terminating;\n    }\n\n    /**\n     * Gets the initialization milestone that we've already reached.\n     *\n     * @return\n     *      {@link InitMilestone#STARTED} even if the initialization hasn't been started, so that this method\n     *      never returns null.\n     */\n    public InitMilestone getInitLevel() {\n        return initLevel;\n    }\n\n    public void setNumExecutors(int n) throws IOException {\n        this.numExecutors = n;\n        save();\n    }\n\n\n\n    /**\n     * {@inheritDoc}.\n     *\n     * Note that the look up is case-insensitive.\n     */\n    public TopLevelItem getItem(String name) {\n        if (name==null)    return null;\n    \tTopLevelItem item = items.get(name);\n        if (item==null)\n            return null;\n        if (!item.hasPermission(Item.READ)) {\n            if (item.hasPermission(Item.DISCOVER)) {\n                throw new AccessDeniedException(\"Please login to access job \" + name);\n            }\n            return null;\n        }\n        return item;\n    }\n\n    /**\n     * Gets the item by its path name from the given context\n     *\n     * <h2>Path Names</h2>\n     * <p>\n     * If the name starts from '/', like \"/foo/bar/zot\", then it's interpreted as absolute.\n     * Otherwise, the name should be something like \"foo/bar\" and it's interpreted like\n     * relative path name in the file system is, against the given context.\n     *\n     * @param context\n     *      null is interpreted as {@link Jenkins}. Base 'directory' of the interpretation.\n     * @since 1.406\n     */\n    public Item getItem(String pathName, ItemGroup context) {\n        if (context==null)  context = this;\n        if (pathName==null) return null;\n\n        if (pathName.startsWith(\"/\"))   // absolute\n            return getItemByFullName(pathName);\n\n        Object/*Item|ItemGroup*/ ctx = context;\n\n        StringTokenizer tokens = new StringTokenizer(pathName,\"/\");\n        while (tokens.hasMoreTokens()) {\n            String s = tokens.nextToken();\n            if (s.equals(\"..\")) {\n                if (ctx instanceof Item) {\n                    ctx = ((Item)ctx).getParent();\n                    continue;\n                }\n\n                ctx=null;    // can't go up further\n                break;\n            }\n            if (s.equals(\".\")) {\n                continue;\n            }\n\n            if (ctx instanceof ItemGroup) {\n                ItemGroup g = (ItemGroup) ctx;\n                Item i = g.getItem(s);\n                if (i==null || !i.hasPermission(Item.READ)) { // XXX consider DISCOVER\n                    ctx=null;    // can't go up further\n                    break;\n                }\n                ctx=i;\n            } else {\n                return null;\n            }\n        }\n\n        if (ctx instanceof Item)\n            return (Item)ctx;\n\n        // fall back to the classic interpretation\n        return getItemByFullName(pathName);\n    }\n\n    public final Item getItem(String pathName, Item context) {\n        return getItem(pathName,context!=null?context.getParent():null);\n    }\n\n    public final <T extends Item> T getItem(String pathName, ItemGroup context, Class<T> type) {\n        Item r = getItem(pathName, context);\n        if (type.isInstance(r))\n            return type.cast(r);\n        return null;\n    }\n\n    public final <T extends Item> T getItem(String pathName, Item context, Class<T> type) {\n        return getItem(pathName,context!=null?context.getParent():null,type);\n    }\n\n    public File getRootDirFor(TopLevelItem child) {\n        return getRootDirFor(child.getName());\n    }\n\n    private File getRootDirFor(String name) {\n        return new File(new File(getRootDir(),\"jobs\"), name);\n    }\n\n    /**\n     * Gets the {@link Item} object by its full name.\n     * Full names are like path names, where each name of {@link Item} is\n     * combined by '/'.\n     *\n     * @return\n     *      null if either such {@link Item} doesn't exist under the given full name,\n     *      or it exists but it's no an instance of the given type.\n     */\n    public @CheckForNull <T extends Item> T getItemByFullName(String fullName, Class<T> type) {\n        StringTokenizer tokens = new StringTokenizer(fullName,\"/\");\n        ItemGroup parent = this;\n\n        if(!tokens.hasMoreTokens()) return null;    // for example, empty full name.\n\n        while(true) {\n            Item item = parent.getItem(tokens.nextToken());\n            if(!tokens.hasMoreTokens()) {\n                if(type.isInstance(item))\n                    return type.cast(item);\n                else\n                    return null;\n            }\n\n            if(!(item instanceof ItemGroup))\n                return null;    // this item can't have any children\n\n            if (!item.hasPermission(Item.READ))\n                return null; // XXX consider DISCOVER\n\n            parent = (ItemGroup) item;\n        }\n    }\n\n    public @CheckForNull Item getItemByFullName(String fullName) {\n        return getItemByFullName(fullName,Item.class);\n    }\n\n    /**\n     * Gets the user of the given name.\n     *\n     * @return the user of the given name, if that person exists or the invoker {@link #hasPermission} on {@link #ADMINISTER}; else null\n     * @see User#get(String,boolean)\n     */\n    public @CheckForNull User getUser(String name) {\n        return User.get(name,hasPermission(ADMINISTER));\n    }\n\n    public synchronized TopLevelItem createProject( TopLevelItemDescriptor type, String name ) throws IOException {\n        return createProject(type, name, true);\n    }\n\n    public synchronized TopLevelItem createProject( TopLevelItemDescriptor type, String name, boolean notify ) throws IOException {\n        return itemGroupMixIn.createProject(type,name,notify);\n    }\n\n    /**\n     * Overwrites the existing item by new one.\n     *\n     * <p>\n     * This is a short cut for deleting an existing job and adding a new one.\n     */\n    public synchronized void putItem(TopLevelItem item) throws IOException, InterruptedException {\n        String name = item.getName();\n        TopLevelItem old = items.get(name);\n        if (old ==item)  return; // noop\n\n        checkPermission(Item.CREATE);\n        if (old!=null)\n            old.delete();\n        items.put(name,item);\n        ItemListener.fireOnCreated(item);\n    }\n\n    /**\n     * Creates a new job.\n     *\n     * <p>\n     * This version infers the descriptor from the type of the top-level item.\n     *\n     * @throws IllegalArgumentException\n     *      if the project of the given name already exists.\n     */\n    public synchronized <T extends TopLevelItem> T createProject( Class<T> type, String name ) throws IOException {\n        return type.cast(createProject((TopLevelItemDescriptor)getDescriptor(type),name));\n    }\n\n    /**\n     * Called by {@link Job#renameTo(String)} to update relevant data structure.\n     * assumed to be synchronized on Hudson by the caller.\n     */\n    public void onRenamed(TopLevelItem job, String oldName, String newName) throws IOException {\n        items.remove(oldName);\n        items.put(newName,job);\n\n        for (View v : views)\n            v.onJobRenamed(job, oldName, newName);\n        save();\n    }\n\n    /**\n     * Called in response to {@link Job#doDoDelete(StaplerRequest, StaplerResponse)}\n     */\n    public void onDeleted(TopLevelItem item) throws IOException {\n        for (ItemListener l : ItemListener.all())\n            l.onDeleted(item);\n\n        items.remove(item.getName());\n        for (View v : views)\n            v.onJobRenamed(item, item.getName(), null);\n        save();\n    }\n\n    public FingerprintMap getFingerprintMap() {\n        return fingerprintMap;\n    }\n\n    // if no finger print matches, display \"not found page\".\n    public Object getFingerprint( String md5sum ) throws IOException {\n        Fingerprint r = fingerprintMap.get(md5sum);\n        if(r==null)     return new NoFingerprintMatch(md5sum);\n        else            return r;\n    }\n\n    /**\n     * Gets a {@link Fingerprint} object if it exists.\n     * Otherwise null.\n     */\n    public Fingerprint _getFingerprint( String md5sum ) throws IOException {\n        return fingerprintMap.get(md5sum);\n    }\n\n    /**\n     * The file we save our configuration.\n     */\n    private XmlFile getConfigFile() {\n        return new XmlFile(XSTREAM, new File(root,\"config.xml\"));\n    }\n\n    public int getNumExecutors() {\n        return numExecutors;\n    }\n\n    public Mode getMode() {\n        return mode;\n    }\n\n    public void setMode(Mode m) throws IOException {\n        this.mode = m;\n        save();\n    }\n\n    public String getLabelString() {\n        return fixNull(label).trim();\n    }\n\n    @Override\n    public void setLabelString(String label) throws IOException {\n        this.label = label;\n        save();\n    }\n\n    @Override\n    public LabelAtom getSelfLabel() {\n        return getLabelAtom(\"master\");\n    }\n\n    public Computer createComputer() {\n        return new Hudson.MasterComputer();\n    }\n\n    private synchronized TaskBuilder loadTasks() throws IOException {\n        File projectsDir = new File(root,\"jobs\");\n        if(!projectsDir.getCanonicalFile().isDirectory() && !projectsDir.mkdirs()) {\n            if(projectsDir.exists())\n                throw new IOException(projectsDir+\" is not a directory\");\n            throw new IOException(\"Unable to create \"+projectsDir+\"\\nPermission issue? Please create this directory manually.\");\n        }\n        File[] subdirs = projectsDir.listFiles(new FileFilter() {\n            public boolean accept(File child) {\n                return child.isDirectory() && Items.getConfigFile(child).exists();\n            }\n        });\n\n        final Set<String> loadedNames = Collections.synchronizedSet(new HashSet<String>());\n\n        TaskGraphBuilder g = new TaskGraphBuilder();\n        Handle loadHudson = g.requires(EXTENSIONS_AUGMENTED).attains(JOB_LOADED).add(\"Loading global config\", new Executable() {\n            public void run(Reactor session) throws Exception {\n                // JENKINS-8043: some slaves (eg. swarm slaves) are not saved into the config file\n                // and will get overwritten when reloading. Make a backup copy now, and re-add them later\n                NodeList oldSlaves = slaves;\n                \n                XmlFile cfg = getConfigFile();\n                if (cfg.exists()) {\n                    // reset some data that may not exist in the disk file\n                    // so that we can take a proper compensation action later.\n                    primaryView = null;\n                    views.clear();\n\n                    // load from disk\n                    cfg.unmarshal(Jenkins.this);\n                }\n\n                // if we are loading old data that doesn't have this field\n                if (slaves == null) slaves = new NodeList();\n\n                clouds.setOwner(Jenkins.this);\n\n                // JENKINS-8043: re-add the slaves which were not saved into the config file\n                // and are now missing, but still connected.\n                if (oldSlaves != null) {\n                    ArrayList<Node> newSlaves = new ArrayList<Node>(slaves);\n                    for (Node n: oldSlaves) {\n                        if (n instanceof EphemeralNode) {\n                            if(!newSlaves.contains(n)) {\n                                newSlaves.add(n);\n                            }\n                        }\n                    }\n                    setNodes(newSlaves);\n                }\n            }\n        });\n\n        for (final File subdir : subdirs) {\n            g.requires(loadHudson).attains(JOB_LOADED).notFatal().add(\"Loading job \"+subdir.getName(),new Executable() {\n                public void run(Reactor session) throws Exception {\n                    TopLevelItem item = (TopLevelItem) Items.load(Jenkins.this, subdir);\n                    items.put(item.getName(), item);\n                    loadedNames.add(item.getName());\n                }\n            });\n        }\n\n        g.requires(JOB_LOADED).add(\"Cleaning up old builds\",new Executable() {\n            public void run(Reactor reactor) throws Exception {\n                // anything we didn't load from disk, throw them away.\n                // doing this after loading from disk allows newly loaded items\n                // to inspect what already existed in memory (in case of reloading)\n\n                // retainAll doesn't work well because of CopyOnWriteMap implementation, so remove one by one\n                // hopefully there shouldn't be too many of them.\n                for (String name : items.keySet()) {\n                    if (!loadedNames.contains(name))\n                        items.remove(name);\n                }\n            }\n        });\n\n        g.requires(JOB_LOADED).add(\"Finalizing set up\",new Executable() {\n            public void run(Reactor session) throws Exception {\n                rebuildDependencyGraph();\n\n                {// recompute label objects - populates the labels mapping.\n                    for (Node slave : slaves)\n                        // Note that not all labels are visible until the slaves have connected.\n                        slave.getAssignedLabels();\n                    getAssignedLabels();\n                }\n\n                // initialize views by inserting the default view if necessary\n                // this is both for clean Hudson and for backward compatibility.\n                if(views.size()==0 || primaryView==null) {\n                    View v = new AllView(Messages.Hudson_ViewName());\n                    setViewOwner(v);\n                    views.add(0,v);\n                    primaryView = v.getViewName();\n                }\n\n                // read in old data that doesn't have the security field set\n                if(authorizationStrategy==null) {\n                    if(useSecurity==null || !useSecurity)\n                        authorizationStrategy = AuthorizationStrategy.UNSECURED;\n                    else\n                        authorizationStrategy = new LegacyAuthorizationStrategy();\n                }\n                if(securityRealm==null) {\n                    if(useSecurity==null || !useSecurity)\n                        setSecurityRealm(SecurityRealm.NO_AUTHENTICATION);\n                    else\n                        setSecurityRealm(new LegacySecurityRealm());\n                } else {\n                    // force the set to proxy\n                    setSecurityRealm(securityRealm);\n                }\n\n                if(useSecurity!=null && !useSecurity) {\n                    // forced reset to the unsecure mode.\n                    // this works as an escape hatch for people who locked themselves out.\n                    authorizationStrategy = AuthorizationStrategy.UNSECURED;\n                    setSecurityRealm(SecurityRealm.NO_AUTHENTICATION);\n                }\n\n                // Initialize the filter with the crumb issuer\n                setCrumbIssuer(crumbIssuer);\n\n                // auto register root actions\n                for (Action a : getExtensionList(RootAction.class))\n                    if (!actions.contains(a)) actions.add(a);\n            }\n        });\n\n        return g;\n    }\n\n    /**\n     * Save the settings to a file.\n     */\n    public synchronized void save() throws IOException {\n        if(BulkChange.contains(this))   return;\n        getConfigFile().write(this);\n        SaveableListener.fireOnChange(this, getConfigFile());\n    }\n\n\n    /**\n     * Called to shut down the system.\n     */\n    @edu.umd.cs.findbugs.annotations.SuppressWarnings(\"ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD\")\n    public void cleanUp() {\n        for (ItemListener l : ItemListener.all())\n            l.onBeforeShutdown();\n\n        Set<Future<?>> pending = new HashSet<Future<?>>();\n        terminating = true;\n        for( Computer c : computers.values() ) {\n            c.interrupt();\n            killComputer(c);\n            pending.add(c.disconnect(null));\n        }\n        if(udpBroadcastThread!=null)\n            udpBroadcastThread.shutdown();\n        if(dnsMultiCast!=null)\n            dnsMultiCast.close();\n        interruptReloadThread();\n        Timer timer = Trigger.timer;\n        if (timer != null) {\n            timer.cancel();\n        }\n        // TODO: how to wait for the completion of the last job?\n        Trigger.timer = null;\n        if(tcpSlaveAgentListener!=null)\n            tcpSlaveAgentListener.shutdown();\n\n        if(pluginManager!=null) // be defensive. there could be some ugly timing related issues\n            pluginManager.stop();\n\n        if(getRootDir().exists())\n            // if we are aborting because we failed to create JENKINS_HOME,\n            // don't try to save. Issue #536\n            getQueue().save();\n\n        threadPoolForLoad.shutdown();\n        for (Future<?> f : pending)\n            try {\n                f.get(10, TimeUnit.SECONDS);    // if clean up operation didn't complete in time, we fail the test\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                break;  // someone wants us to die now. quick!\n            } catch (ExecutionException e) {\n                LOGGER.log(Level.WARNING, \"Failed to shut down properly\",e);\n            } catch (TimeoutException e) {\n                LOGGER.log(Level.WARNING, \"Failed to shut down properly\",e);\n            }\n\n        LogFactory.releaseAll();\n\n        theInstance = null;\n    }\n\n    public Object getDynamic(String token) {\n        for (Action a : getActions()) {\n            String url = a.getUrlName();\n            if (url==null)  continue;\n            if (url.equals(token) || url.equals('/' + token))\n                return a;\n        }\n        for (Action a : getManagementLinks())\n            if(a.getUrlName().equals(token))\n                return a;\n        return null;\n    }\n\n\n//\n//\n// actions\n//\n//\n    /**\n     * Accepts submission from the configuration page.\n     */\n    public synchronized void doConfigSubmit( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException, FormException {\n        BulkChange bc = new BulkChange(this);\n        try {\n            checkPermission(ADMINISTER);\n\n            JSONObject json = req.getSubmittedForm();\n\n            workspaceDir = json.getString(\"rawWorkspaceDir\");\n            buildsDir = json.getString(\"rawBuildsDir\");\n\n            systemMessage = Util.nullify(req.getParameter(\"system_message\"));\n\n            jdks.clear();\n            jdks.addAll(req.bindJSONToList(JDK.class,json.get(\"jdks\")));\n\n            boolean result = true;\n            for (Descriptor<?> d : Functions.getSortedDescriptorsForGlobalConfigUnclassified())\n                result &= configureDescriptor(req,json,d);\n\n            version = VERSION;\n\n            save();\n            updateComputerList();\n            if(result)\n                FormApply.success(req.getContextPath()+'/').generateResponse(req, rsp, null);\n            else\n                FormApply.success(\"configure\").generateResponse(req, rsp, null);    // back to config\n        } finally {\n            bc.commit();\n        }\n    }\n\n    /**\n     * Gets the {@link CrumbIssuer} currently in use.\n     *\n     * @return null if none is in use.\n     */\n    public CrumbIssuer getCrumbIssuer() {\n        return crumbIssuer;\n    }\n\n    public void setCrumbIssuer(CrumbIssuer issuer) {\n        crumbIssuer = issuer;\n    }\n\n    public synchronized void doTestPost( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        rsp.sendRedirect(\"foo\");\n    }\n\n    private boolean configureDescriptor(StaplerRequest req, JSONObject json, Descriptor<?> d) throws FormException {\n        // collapse the structure to remain backward compatible with the JSON structure before 1.\n        String name = d.getJsonSafeClassName();\n        JSONObject js = json.has(name) ? json.getJSONObject(name) : new JSONObject(); // if it doesn't have the property, the method returns invalid null object.\n        json.putAll(js);\n        return d.configure(req, js);\n    }\n\n    /**\n     * Accepts submission from the node configuration page.\n     */\n    public synchronized void doConfigExecutorsSubmit( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException, FormException {\n        checkPermission(ADMINISTER);\n\n        BulkChange bc = new BulkChange(this);\n        try {\n            JSONObject json = req.getSubmittedForm();\n\n            MasterBuildConfiguration mbc = MasterBuildConfiguration.all().get(MasterBuildConfiguration.class);\n            if (mbc!=null)\n                mbc.configure(req,json);\n\n            getNodeProperties().rebuild(req, json.optJSONObject(\"nodeProperties\"), NodeProperty.all());\n        } finally {\n            bc.commit();\n        }\n\n        rsp.sendRedirect(req.getContextPath()+'/'+toComputer().getUrl());  // back to the computer page\n    }\n\n    /**\n     * Accepts the new description.\n     */\n    public synchronized void doSubmitDescription( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        getPrimaryView().doSubmitDescription(req, rsp);\n    }\n\n    public synchronized HttpRedirect doQuietDown() throws IOException {\n        try {\n            return doQuietDown(false,0);\n        } catch (InterruptedException e) {\n            throw new AssertionError(); // impossible\n        }\n    }\n\n    @CLIMethod(name=\"quiet-down\")\n    public HttpRedirect doQuietDown(\n            @Option(name=\"-block\",usage=\"Block until the system really quiets down and no builds are running\") @QueryParameter boolean block,\n            @Option(name=\"-timeout\",usage=\"If non-zero, only block up to the specified number of milliseconds\") @QueryParameter int timeout) throws InterruptedException, IOException {\n        synchronized (this) {\n            checkPermission(ADMINISTER);\n            isQuietingDown = true;\n        }\n        if (block) {\n            if (timeout > 0) timeout += System.currentTimeMillis();\n            while (isQuietingDown\n                   && (timeout <= 0 || System.currentTimeMillis() < timeout)\n                   && !RestartListener.isAllReady()) {\n                Thread.sleep(1000);\n            }\n        }\n        return new HttpRedirect(\".\");\n    }\n\n    @CLIMethod(name=\"cancel-quiet-down\")\n    public synchronized HttpRedirect doCancelQuietDown() {\n        checkPermission(ADMINISTER);\n        isQuietingDown = false;\n        getQueue().scheduleMaintenance();\n        return new HttpRedirect(\".\");\n    }\n\n    /**\n     * Backward compatibility. Redirect to the thread dump.\n     */\n    public void doClassicThreadDump(StaplerResponse rsp) throws IOException, ServletException {\n        rsp.sendRedirect2(\"threadDump\");\n    }\n\n    /**\n     * Obtains the thread dump of all slaves (including the master.)\n     *\n     * <p>\n     * Since this is for diagnostics, it has a built-in precautionary measure against hang slaves.\n     */\n    public Map<String,Map<String,String>> getAllThreadDumps() throws IOException, InterruptedException {\n        checkPermission(ADMINISTER);\n\n        // issue the requests all at once\n        Map<String,Future<Map<String,String>>> future = new HashMap<String, Future<Map<String, String>>>();\n\n        for (Computer c : getComputers()) {\n            try {\n                future.put(c.getName(), RemotingDiagnostics.getThreadDumpAsync(c.getChannel()));\n            } catch(Exception e) {\n                LOGGER.info(\"Failed to get thread dump for node \" + c.getName() + \": \" + e.getMessage());\n            }\n        }\n\t\tif (toComputer() == null) {\n\t\t\tfuture.put(\"master\", RemotingDiagnostics.getThreadDumpAsync(MasterComputer.localChannel));\n\t\t}\n\n        // if the result isn't available in 5 sec, ignore that.\n        // this is a precaution against hang nodes\n        long endTime = System.currentTimeMillis() + 5000;\n\n        Map<String,Map<String,String>> r = new HashMap<String, Map<String, String>>();\n        for (Entry<String, Future<Map<String, String>>> e : future.entrySet()) {\n            try {\n                r.put(e.getKey(), e.getValue().get(endTime-System.currentTimeMillis(), TimeUnit.MILLISECONDS));\n            } catch (Exception x) {\n                StringWriter sw = new StringWriter();\n                x.printStackTrace(new PrintWriter(sw,true));\n                r.put(e.getKey(), Collections.singletonMap(\"Failed to retrieve thread dump\",sw.toString()));\n            }\n        }\n        return r;\n    }\n\n    public synchronized TopLevelItem doCreateItem( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        return itemGroupMixIn.createTopLevelItem(req, rsp);\n    }\n\n    /**\n     * @since 1.319\n     */\n    public TopLevelItem createProjectFromXML(String name, InputStream xml) throws IOException {\n        return itemGroupMixIn.createProjectFromXML(name, xml);\n    }\n\n\n    @SuppressWarnings({\"unchecked\"})\n    public <T extends TopLevelItem> T copy(T src, String name) throws IOException {\n        return itemGroupMixIn.copy(src, name);\n    }\n\n    // a little more convenient overloading that assumes the caller gives us the right type\n    // (or else it will fail with ClassCastException)\n    public <T extends AbstractProject<?,?>> T copy(T src, String name) throws IOException {\n        return (T)copy((TopLevelItem)src,name);\n    }\n\n    public synchronized void doCreateView( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException, FormException {\n        checkPermission(View.CREATE);\n        addView(View.create(req,rsp, this));\n    }\n\n    /**\n     * Check if the given name is suitable as a name\n     * for job, view, etc.\n     *\n     * @throws Failure\n     *      if the given name is not good\n     */\n    public static void checkGoodName(String name) throws Failure {\n        if(name==null || name.length()==0)\n            throw new Failure(Messages.Hudson_NoName());\n\n        if(\"..\".equals(name.trim())) \n            throw new Failure(Messages.Jenkins_NotAllowedName(\"..\"));\n        for( int i=0; i<name.length(); i++ ) {\n            char ch = name.charAt(i);\n            if(Character.isISOControl(ch)) {\n                throw new Failure(Messages.Hudson_ControlCodeNotAllowed(toPrintableName(name)));\n            }\n            if(\"?*/\\\\%!@#$^&|<>[]:;\".indexOf(ch)!=-1)\n                throw new Failure(Messages.Hudson_UnsafeChar(ch));\n        }\n\n        // looks good\n    }\n\n    /**\n     * Makes sure that the given name is good as a job name.\n     * @return trimmed name if valid; throws Failure if not\n     */\n    private String checkJobName(String name) throws Failure {\n        checkGoodName(name);\n        name = name.trim();\n        projectNamingStrategy.checkName(name);\n        if(getItem(name)!=null)\n            throw new Failure(Messages.Hudson_JobAlreadyExists(name));\n        // looks good\n        return name;\n    }\n\n    private static String toPrintableName(String name) {\n        StringBuilder printableName = new StringBuilder();\n        for( int i=0; i<name.length(); i++ ) {\n            char ch = name.charAt(i);\n            if(Character.isISOControl(ch))\n                printableName.append(\"\\\\u\").append((int)ch).append(';');\n            else\n                printableName.append(ch);\n        }\n        return printableName.toString();\n    }\n\n    /**\n     * Checks if the user was successfully authenticated.\n     *\n     * @see BasicAuthenticationFilter\n     */\n    public void doSecured( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        if(req.getUserPrincipal()==null) {\n            // authentication must have failed\n            rsp.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\n            return;\n        }\n\n        // the user is now authenticated, so send him back to the target\n        String path = req.getContextPath()+req.getOriginalRestOfPath();\n        String q = req.getQueryString();\n        if(q!=null)\n            path += '?'+q;\n\n        rsp.sendRedirect2(path);\n    }\n\n    /**\n     * Called once the user logs in. Just forward to the top page.\n     */\n    public void doLoginEntry( StaplerRequest req, StaplerResponse rsp ) throws IOException {\n        if(req.getUserPrincipal()==null) {\n            rsp.sendRedirect2(\"noPrincipal\");\n            return;\n        }\n\n        String from = req.getParameter(\"from\");\n        if(from!=null && from.startsWith(\"/\") && !from.equals(\"/loginError\")) {\n            rsp.sendRedirect2(from);    // I'm bit uncomfortable letting users redircted to other sites, make sure the URL falls into this domain\n            return;\n        }\n\n        String url = AbstractProcessingFilter.obtainFullRequestUrl(req);\n        if(url!=null) {\n            // if the login redirect is initiated by Acegi\n            // this should send the user back to where s/he was from.\n            rsp.sendRedirect2(url);\n            return;\n        }\n\n        rsp.sendRedirect2(\".\");\n    }\n\n    /**\n     * Logs out the user.\n     */\n    public void doLogout( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        securityRealm.doLogout(req, rsp);\n    }\n\n    /**\n     * Serves jar files for JNLP slave agents.\n     */\n    public Slave.JnlpJar getJnlpJars(String fileName) {\n        return new Slave.JnlpJar(fileName);\n    }\n\n    public Slave.JnlpJar doJnlpJars(StaplerRequest req) {\n        return new Slave.JnlpJar(req.getRestOfPath().substring(1));\n    }\n\n    /**\n     * Reloads the configuration.\n     */\n    @CLIMethod(name=\"reload-configuration\")\n    public synchronized HttpResponse doReload() throws IOException {\n        checkPermission(ADMINISTER);\n\n        // engage \"loading ...\" UI and then run the actual task in a separate thread\n        servletContext.setAttribute(\"app\", new HudsonIsLoading());\n\n        new Thread(\"Jenkins config reload thread\") {\n            @Override\n            public void run() {\n                try {\n                    ACL.impersonate(ACL.SYSTEM);\n                    reload();\n                } catch (Exception e) {\n                    LOGGER.log(SEVERE,\"Failed to reload Jenkins config\",e);\n                    WebApp.get(servletContext).setApp(new JenkinsReloadFailed(e));\n                }\n            }\n        }.start();\n\n        return HttpResponses.redirectViaContextPath(\"/\");\n    }\n\n    /**\n     * Reloads the configuration synchronously.\n     */\n    public void reload() throws IOException, InterruptedException, ReactorException {\n        executeReactor(null, loadTasks());\n        User.reload();\n        servletContext.setAttribute(\"app\", this);\n    }\n\n    /**\n     * Do a finger-print check.\n     */\n    public void doDoFingerprintCheck( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        // Parse the request\n        MultipartFormDataParser p = new MultipartFormDataParser(req);\n        if(isUseCrumbs() && !getCrumbIssuer().validateCrumb(req, p)) {\n            rsp.sendError(HttpServletResponse.SC_FORBIDDEN,\"No crumb found\");\n        }\n        try {\n            rsp.sendRedirect2(req.getContextPath()+\"/fingerprint/\"+\n                Util.getDigestOf(p.getFileItem(\"name\").getInputStream())+'/');\n        } finally {\n            p.cleanUp();\n        }\n    }\n\n    /**\n     * For debugging. Expose URL to perform GC.\n     */\n    @edu.umd.cs.findbugs.annotations.SuppressWarnings(\"DM_GC\")\n    public void doGc(StaplerResponse rsp) throws IOException {\n        checkPermission(Jenkins.ADMINISTER);\n        System.gc();\n        rsp.setStatus(HttpServletResponse.SC_OK);\n        rsp.setContentType(\"text/plain\");\n        rsp.getWriter().println(\"GCed\");\n    }\n\n    /**\n     * End point that intentionally throws an exception to test the error behaviour.\n     */\n    public void doException() {\n        throw new RuntimeException();\n    }\n\n    public ContextMenu doContextMenu(StaplerRequest request, StaplerResponse response) throws IOException, JellyException {\n        ContextMenu menu = new ContextMenu().from(this, request, response);\n        for (MenuItem i : menu.items) {\n            if (i.url.equals(request.getContextPath() + \"/manage\")) {\n                // add \"Manage Jenkins\" subitems\n                i.subMenu = new ContextMenu().from(this, request, response, \"manage\");\n            }\n        }\n        return menu;\n    }\n\n    /**\n     * Obtains the heap dump.\n     */\n    public HeapDump getHeapDump() throws IOException {\n        return new HeapDump(this,MasterComputer.localChannel);\n    }\n\n    /**\n     * Simulates OutOfMemoryError.\n     * Useful to make sure OutOfMemoryHeapDump setting.\n     */\n    public void doSimulateOutOfMemory() throws IOException {\n        checkPermission(ADMINISTER);\n\n        System.out.println(\"Creating artificial OutOfMemoryError situation\");\n        List<Object> args = new ArrayList<Object>();\n        while (true)\n            args.add(new byte[1024*1024]);\n    }\n\n    private transient final Map<UUID,FullDuplexHttpChannel> duplexChannels = new HashMap<UUID, FullDuplexHttpChannel>();\n\n    /**\n     * Handles HTTP requests for duplex channels for CLI.\n     */\n    public void doCli(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException, InterruptedException {\n        if (!\"POST\".equals(req.getMethod())) {\n            // for GET request, serve _cli.jelly, assuming this is a browser\n            checkPermission(READ);\n            req.getView(this,\"_cli.jelly\").forward(req,rsp);\n            return;\n        }\n\n        // do not require any permission to establish a CLI connection\n        // the actual authentication for the connecting Channel is done by CLICommand\n\n        UUID uuid = UUID.fromString(req.getHeader(\"Session\"));\n        rsp.setHeader(\"Hudson-Duplex\",\"\"); // set the header so that the client would know\n\n        FullDuplexHttpChannel server;\n        if(req.getHeader(\"Side\").equals(\"download\")) {\n            duplexChannels.put(uuid,server=new FullDuplexHttpChannel(uuid, !hasPermission(ADMINISTER)) {\n                protected void main(Channel channel) throws IOException, InterruptedException {\n                    // capture the identity given by the transport, since this can be useful for SecurityRealm.createCliAuthenticator()\n                    channel.setProperty(CLICommand.TRANSPORT_AUTHENTICATION,getAuthentication());\n                    channel.setProperty(CliEntryPoint.class.getName(),new CliManagerImpl(channel));\n                }\n            });\n            try {\n                server.download(req,rsp);\n            } finally {\n                duplexChannels.remove(uuid);\n            }\n        } else {\n            duplexChannels.get(uuid).upload(req,rsp);\n        }\n    }\n\n    /**\n     * Binds /userContent/... to $JENKINS_HOME/userContent.\n     */\n    public DirectoryBrowserSupport doUserContent() {\n        return new DirectoryBrowserSupport(this,getRootPath().child(\"userContent\"),\"User content\",\"folder.png\",true);\n    }\n\n    /**\n     * Perform a restart of Hudson, if we can.\n     *\n     * This first replaces \"app\" to {@link HudsonIsRestarting}\n     */\n    @CLIMethod(name=\"restart\")\n    public void doRestart(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException, RestartNotSupportedException {\n        checkPermission(ADMINISTER);\n        if (req != null && req.getMethod().equals(\"GET\")) {\n            req.getView(this,\"_restart.jelly\").forward(req,rsp);\n            return;\n        }\n\n        restart();\n\n        if (rsp != null) // null for CLI\n            rsp.sendRedirect2(\".\");\n    }\n\n    /**\n     * Queues up a restart of Hudson for when there are no builds running, if we can.\n     *\n     * This first replaces \"app\" to {@link HudsonIsRestarting}\n     *\n     * @since 1.332\n     */\n    @CLIMethod(name=\"safe-restart\")\n    public HttpResponse doSafeRestart(StaplerRequest req) throws IOException, ServletException, RestartNotSupportedException {\n        checkPermission(ADMINISTER);\n        if (req != null && req.getMethod().equals(\"GET\"))\n            return HttpResponses.forwardToView(this,\"_safeRestart.jelly\");\n\n        safeRestart();\n\n        return HttpResponses.redirectToDot();\n    }\n\n    /**\n     * Performs a restart.\n     */\n    public void restart() throws RestartNotSupportedException {\n        final Lifecycle lifecycle = Lifecycle.get();\n        lifecycle.verifyRestartable(); // verify that Hudson is restartable\n        servletContext.setAttribute(\"app\", new HudsonIsRestarting());\n\n        new Thread(\"restart thread\") {\n            final String exitUser = getAuthentication().getName();\n            @Override\n            public void run() {\n                try {\n                    ACL.impersonate(ACL.SYSTEM);\n\n                    // give some time for the browser to load the \"reloading\" page\n                    Thread.sleep(5000);\n                    LOGGER.severe(String.format(\"Restarting VM as requested by %s\",exitUser));\n                    for (RestartListener listener : RestartListener.all())\n                        listener.onRestart();\n                    lifecycle.restart();\n                } catch (InterruptedException e) {\n                    LOGGER.log(Level.WARNING, \"Failed to restart Hudson\",e);\n                } catch (IOException e) {\n                    LOGGER.log(Level.WARNING, \"Failed to restart Hudson\",e);\n                }\n            }\n        }.start();\n    }\n\n    /**\n     * Queues up a restart to be performed once there are no builds currently running.\n     * @since 1.332\n     */\n    public void safeRestart() throws RestartNotSupportedException {\n        final Lifecycle lifecycle = Lifecycle.get();\n        lifecycle.verifyRestartable(); // verify that Hudson is restartable\n        // Quiet down so that we won't launch new builds.\n        isQuietingDown = true;\n\n        new Thread(\"safe-restart thread\") {\n            final String exitUser = getAuthentication().getName();\n            @Override\n            public void run() {\n                try {\n                    ACL.impersonate(ACL.SYSTEM);\n\n                    // Wait 'til we have no active executors.\n                    doQuietDown(true, 0);\n\n                    // Make sure isQuietingDown is still true.\n                    if (isQuietingDown) {\n                        servletContext.setAttribute(\"app\",new HudsonIsRestarting());\n                        // give some time for the browser to load the \"reloading\" page\n                        LOGGER.info(\"Restart in 10 seconds\");\n                        Thread.sleep(10000);\n                        LOGGER.severe(String.format(\"Restarting VM as requested by %s\",exitUser));\n                        for (RestartListener listener : RestartListener.all())\n                            listener.onRestart();\n                        lifecycle.restart();\n                    } else {\n                        LOGGER.info(\"Safe-restart mode cancelled\");\n                    }\n                } catch (InterruptedException e) {\n                    LOGGER.log(Level.WARNING, \"Failed to restart Hudson\",e);\n                } catch (IOException e) {\n                    LOGGER.log(Level.WARNING, \"Failed to restart Hudson\",e);\n                }\n            }\n        }.start();\n    }\n\n    /**\n     * Shutdown the system.\n     * @since 1.161\n     */\n    @CLIMethod(name=\"shutdown\")\n    public void doExit( StaplerRequest req, StaplerResponse rsp ) throws IOException {\n        checkPermission(ADMINISTER);\n        LOGGER.severe(String.format(\"Shutting down VM as requested by %s from %s\",\n                getAuthentication().getName(), req!=null?req.getRemoteAddr():\"???\"));\n        if (rsp!=null) {\n            rsp.setStatus(HttpServletResponse.SC_OK);\n            rsp.setContentType(\"text/plain\");\n            PrintWriter w = rsp.getWriter();\n            w.println(\"Shutting down\");\n            w.close();\n        }\n\n        System.exit(0);\n    }\n\n\n    /**\n     * Shutdown the system safely.\n     * @since 1.332\n     */\n    @CLIMethod(name=\"safe-shutdown\")\n    public HttpResponse doSafeExit(StaplerRequest req) throws IOException {\n        checkPermission(ADMINISTER);\n        isQuietingDown = true;\n        final String exitUser = getAuthentication().getName();\n        final String exitAddr = req!=null ? req.getRemoteAddr() : \"unknown\";\n        new Thread(\"safe-exit thread\") {\n            @Override\n            public void run() {\n                try {\n                    ACL.impersonate(ACL.SYSTEM);\n                    LOGGER.severe(String.format(\"Shutting down VM as requested by %s from %s\",\n                                                exitUser, exitAddr));\n                    // Wait 'til we have no active executors.\n                    while (isQuietingDown\n                           && (overallLoad.computeTotalExecutors() > overallLoad.computeIdleExecutors())) {\n                        Thread.sleep(5000);\n                    }\n                    // Make sure isQuietingDown is still true.\n                    if (isQuietingDown) {\n                        cleanUp();\n                        System.exit(0);\n                    }\n                } catch (InterruptedException e) {\n                    LOGGER.log(Level.WARNING, \"Failed to shutdown Hudson\",e);\n                }\n            }\n        }.start();\n\n        return HttpResponses.plainText(\"Shutting down as soon as all jobs are complete\");\n    }\n\n    /**\n     * Gets the {@link Authentication} object that represents the user\n     * associated with the current request.\n     */\n    public static Authentication getAuthentication() {\n        Authentication a = SecurityContextHolder.getContext().getAuthentication();\n        // on Tomcat while serving the login page, this is null despite the fact\n        // that we have filters. Looking at the stack trace, Tomcat doesn't seem to\n        // run the request through filters when this is the login request.\n        // see http://www.nabble.com/Matrix-authorization-problem-tp14602081p14886312.html\n        if(a==null)\n            a = ANONYMOUS;\n        return a;\n    }\n\n    /**\n     * For system diagnostics.\n     * Run arbitrary Groovy script.\n     */\n    public void doScript(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        doScript(req, rsp, req.getView(this, \"_script.jelly\"));\n    }\n\n    /**\n     * Run arbitrary Groovy script and return result as plain text.\n     */\n    public void doScriptText(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        doScript(req, rsp, req.getView(this, \"_scriptText.jelly\"));\n    }\n\n    private void doScript(StaplerRequest req, StaplerResponse rsp, RequestDispatcher view) throws IOException, ServletException {\n        // ability to run arbitrary script is dangerous\n        checkPermission(RUN_SCRIPTS);\n\n        String text = req.getParameter(\"script\");\n        if (text != null) {\n            try {\n                req.setAttribute(\"output\",\n                        RemotingDiagnostics.executeGroovy(text, MasterComputer.localChannel));\n            } catch (InterruptedException e) {\n                throw new ServletException(e);\n            }\n        }\n\n        view.forward(req, rsp);\n    }\n\n    /**\n     * Evaluates the Jelly script submitted by the client.\n     *\n     * This is useful for system administration as well as unit testing.\n     */\n    @RequirePOST\n    public void doEval(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        checkPermission(ADMINISTER);\n\n        try {\n            MetaClass mc = WebApp.getCurrent().getMetaClass(getClass());\n            Script script = mc.classLoader.loadTearOff(JellyClassLoaderTearOff.class).createContext().compileScript(new InputSource(req.getReader()));\n            new JellyRequestDispatcher(this,script).forward(req,rsp);\n        } catch (JellyException e) {\n            throw new ServletException(e);\n        }\n    }\n\n    /**\n     * Sign up for the user account.\n     */\n    public void doSignup( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        req.getView(getSecurityRealm(), \"signup.jelly\").forward(req, rsp);\n    }\n\n    /**\n     * Changes the icon size by changing the cookie\n     */\n    public void doIconSize( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        String qs = req.getQueryString();\n        if(qs==null || !ICON_SIZE.matcher(qs).matches())\n            throw new ServletException();\n        Cookie cookie = new Cookie(\"iconSize\", qs);\n        cookie.setMaxAge(/* ~4 mo. */9999999); // #762\n        rsp.addCookie(cookie);\n        String ref = req.getHeader(\"Referer\");\n        if(ref==null)   ref=\".\";\n        rsp.sendRedirect2(ref);\n    }\n\n    public void doFingerprintCleanup(StaplerResponse rsp) throws IOException {\n        FingerprintCleanupThread.invoke();\n        rsp.setStatus(HttpServletResponse.SC_OK);\n        rsp.setContentType(\"text/plain\");\n        rsp.getWriter().println(\"Invoked\");\n    }\n\n    public void doWorkspaceCleanup(StaplerResponse rsp) throws IOException {\n        WorkspaceCleanupThread.invoke();\n        rsp.setStatus(HttpServletResponse.SC_OK);\n        rsp.setContentType(\"text/plain\");\n        rsp.getWriter().println(\"Invoked\");\n    }\n\n    /**\n     * If the user chose the default JDK, make sure we got 'java' in PATH.\n     */\n    public FormValidation doDefaultJDKCheck(StaplerRequest request, @QueryParameter String value) {\n        if(!value.equals(\"(Default)\"))\n            // assume the user configured named ones properly in system config ---\n            // or else system config should have reported form field validation errors.\n            return FormValidation.ok();\n\n        // default JDK selected. Does such java really exist?\n        if(JDK.isDefaultJDKValid(Jenkins.this))\n            return FormValidation.ok();\n        else\n            return FormValidation.errorWithMarkup(Messages.Hudson_NoJavaInPath(request.getContextPath()));\n    }\n\n    /**\n     * Makes sure that the given name is good as a job name.\n     */\n    public FormValidation doCheckJobName(@QueryParameter String value) {\n        // this method can be used to check if a file exists anywhere in the file system,\n        // so it should be protected.\n        checkPermission(Item.CREATE);\n\n        if(fixEmpty(value)==null)\n            return FormValidation.ok();\n\n        try {\n            checkJobName(value);\n            return FormValidation.ok();\n        } catch (Failure e) {\n            return FormValidation.error(e.getMessage());\n        }\n    }\n\n    /**\n     * Checks if a top-level view with the given name exists.\n     */\n    public FormValidation doViewExistsCheck(@QueryParameter String value) {\n        checkPermission(View.CREATE);\n\n        String view = fixEmpty(value);\n        if(view==null) return FormValidation.ok();\n\n        if(getView(view)==null)\n            return FormValidation.ok();\n        else\n            return FormValidation.error(Messages.Hudson_ViewAlreadyExists(view));\n    }\n\n    /**\n     * Serves static resources placed along with Jelly view files.\n     * <p>\n     * This method can serve a lot of files, so care needs to be taken\n     * to make this method secure. It's not clear to me what's the best\n     * strategy here, though the current implementation is based on\n     * file extensions.\n     */\n    public void doResources(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        String path = req.getRestOfPath();\n        // cut off the \"...\" portion of /resources/.../path/to/file\n        // as this is only used to make path unique (which in turn\n        // allows us to set a long expiration date\n        path = path.substring(path.indexOf('/',1)+1);\n\n        int idx = path.lastIndexOf('.');\n        String extension = path.substring(idx+1);\n        if(ALLOWED_RESOURCE_EXTENSIONS.contains(extension)) {\n            URL url = pluginManager.uberClassLoader.getResource(path);\n            if(url!=null) {\n                long expires = MetaClass.NO_CACHE ? 0 : 365L * 24 * 60 * 60 * 1000; /*1 year*/\n                rsp.serveFile(req,url,expires);\n                return;\n            }\n        }\n        rsp.sendError(HttpServletResponse.SC_NOT_FOUND);\n    }\n\n    /**\n     * Extension list that {@link #doResources(StaplerRequest, StaplerResponse)} can serve.\n     * This set is mutable to allow plugins to add additional extensions.\n     */\n    public static final Set<String> ALLOWED_RESOURCE_EXTENSIONS = new HashSet<String>(Arrays.asList(\n        \"js|css|jpeg|jpg|png|gif|html|htm\".split(\"\\\\|\")\n    ));\n\n    /**\n     * Checks if container uses UTF-8 to decode URLs. See\n     * http://wiki.jenkins-ci.org/display/JENKINS/Tomcat#Tomcat-i18n\n     */\n    public FormValidation doCheckURIEncoding(StaplerRequest request) throws IOException {\n        // expected is non-ASCII String\n        final String expected = \"\\u57f7\\u4e8b\";\n        final String value = fixEmpty(request.getParameter(\"value\"));\n        if (!expected.equals(value))\n            return FormValidation.warningWithMarkup(Messages.Hudson_NotUsesUTF8ToDecodeURL());\n        return FormValidation.ok();\n    }\n\n    /**\n     * Does not check when system default encoding is \"ISO-8859-1\".\n     */\n    public static boolean isCheckURIEncodingEnabled() {\n        return !\"ISO-8859-1\".equalsIgnoreCase(System.getProperty(\"file.encoding\"));\n    }\n\n    /**\n     * Rebuilds the dependency map.\n     */\n    public void rebuildDependencyGraph() {\n        DependencyGraph graph = new DependencyGraph();\n        graph.build();\n        // volatile acts a as a memory barrier here and therefore guarantees \n        // that graph is fully build, before it's visible to other threads\n        dependencyGraph = graph;\n    }\n\n    public DependencyGraph getDependencyGraph() {\n        return dependencyGraph;\n    }\n\n    // for Jelly\n    public List<ManagementLink> getManagementLinks() {\n        return ManagementLink.all();\n    }\n\n    /**\n     * Exposes the current user to <tt>/me</tt> URL.\n     */\n    public User getMe() {\n        User u = User.current();\n        if (u == null)\n            throw new AccessDeniedException(\"/me is not available when not logged in\");\n        return u;\n    }\n\n    /**\n     * Gets the {@link Widget}s registered on this object.\n     *\n     * <p>\n     * Plugins who wish to contribute boxes on the side panel can add widgets\n     * by {@code getWidgets().add(new MyWidget())} from {@link Plugin#start()}.\n     */\n    public List<Widget> getWidgets() {\n        return widgets;\n    }\n\n    public Object getTarget() {\n        try {\n            checkPermission(READ);\n        } catch (AccessDeniedException e) {\n            String rest = Stapler.getCurrentRequest().getRestOfPath();\n            if(rest.startsWith(\"/login\")\n            || rest.startsWith(\"/logout\")\n            || rest.startsWith(\"/accessDenied\")\n            || rest.startsWith(\"/adjuncts/\")\n            || rest.startsWith(\"/signup\")\n            || rest.startsWith(\"/tcpSlaveAgentListener\")\n            // XXX SlaveComputer.doSlaveAgentJnlp; there should be an annotation to request unprotected access\n            || rest.matches(\"/computer/[^/]+/slave-agent[.]jnlp\") && \"true\".equals(Stapler.getCurrentRequest().getParameter(\"encrypt\"))\n            || rest.startsWith(\"/cli\")\n            || rest.startsWith(\"/federatedLoginService/\")\n            || rest.startsWith(\"/securityRealm\"))\n                return this;    // URLs that are always visible without READ permission\n\n            for (String name : getUnprotectedRootActions()) {\n                if (rest.startsWith(\"/\" + name + \"/\") || rest.equals(\"/\" + name)) {\n                    return this;\n                }\n            }\n\n            throw e;\n        }\n        return this;\n    }\n\n    /**\n     * Gets a list of unprotected root actions.\n     * These URL prefixes should be exempted from access control checks by container-managed security.\n     * Ideally would be synchronized with {@link #getTarget}.\n     * @return a list of {@linkplain Action#getUrlName URL names}\n     * @since 1.495\n     */\n    public Collection<String> getUnprotectedRootActions() {\n        Set<String> names = new TreeSet<String>();\n        names.add(\"jnlpJars\"); // XXX cleaner to refactor doJnlpJars into a URA\n        // XXX consider caching (expiring cache when actions changes)\n        for (Action a : getActions()) {\n            if (a instanceof UnprotectedRootAction) {\n                names.add(a.getUrlName());\n            }\n        }\n        return names;\n    }\n\n    /**\n     * Fallback to the primary view.\n     */\n    public View getStaplerFallback() {\n        return getPrimaryView();\n    }\n\n    /**\n     * This method checks all existing jobs to see if displayName is \n     * unique. It does not check the displayName against the displayName of the\n     * job that the user is configuring though to prevent a validation warning \n     * if the user sets the displayName to what it currently is.\n     * @param displayName\n     * @param currentJobName\n     * @return\n     */\n    boolean isDisplayNameUnique(String displayName, String currentJobName) {\n        Collection<TopLevelItem> itemCollection = items.values();\n        \n        // if there are a lot of projects, we'll have to store their \n        // display names in a HashSet or something for a quick check\n        for(TopLevelItem item : itemCollection) {\n            if(item.getName().equals(currentJobName)) {\n                // we won't compare the candidate displayName against the current\n                // item. This is to prevent an validation warning if the user \n                // sets the displayName to what the existing display name is\n                continue;\n            }\n            else if(displayName.equals(item.getDisplayName())) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    /**\n     * True if there is no item in Jenkins that has this name\n     * @param name The name to test\n     * @param currentJobName The name of the job that the user is configuring\n     * @return\n     */\n    boolean isNameUnique(String name, String currentJobName) {\n        Item item = getItem(name);\n        \n        if(null==item) {\n            // the candidate name didn't return any items so the name is unique\n            return true;\n        }\n        else if(item.getName().equals(currentJobName)) {\n            // the candidate name returned an item, but the item is the item\n            // that the user is configuring so this is ok\n            return true;\n        } \n        else {\n            // the candidate name returned an item, so it is not unique\n            return false;\n        }\n    }\n    \n    /**\n     * Checks to see if the candidate displayName collides with any \n     * existing display names or project names\n     * @param displayName The display name to test\n     * @param jobName The name of the job the user is configuring\n     * @return\n     */\n    public FormValidation doCheckDisplayName(@QueryParameter String displayName, \n            @QueryParameter String jobName) {\n        displayName = displayName.trim();\n        \n        if(LOGGER.isLoggable(Level.FINE)) {\n            LOGGER.log(Level.FINE, \"Current job name is \" + jobName);\n        }\n        \n        if(!isNameUnique(displayName, jobName)) {\n            return FormValidation.warning(Messages.Jenkins_CheckDisplayName_NameNotUniqueWarning(displayName));\n        }\n        else if(!isDisplayNameUnique(displayName, jobName)){\n            return FormValidation.warning(Messages.Jenkins_CheckDisplayName_DisplayNameNotUniqueWarning(displayName));\n        }\n        else {\n            return FormValidation.ok();\n        }\n    }\n    \n    public static class MasterComputer extends Computer {\n        protected MasterComputer() {\n            super(Jenkins.getInstance());\n        }\n\n        /**\n         * Returns \"\" to match with {@link Jenkins#getNodeName()}.\n         */\n        @Override\n        public String getName() {\n            return \"\";\n        }\n\n        @Override\n        public boolean isConnecting() {\n            return false;\n        }\n\n        @Override\n        public String getDisplayName() {\n            return Messages.Hudson_Computer_DisplayName();\n        }\n\n        @Override\n        public String getCaption() {\n            return Messages.Hudson_Computer_Caption();\n        }\n\n        @Override\n        public String getUrl() {\n            return \"computer/(master)/\";\n        }\n\n        public RetentionStrategy getRetentionStrategy() {\n            return RetentionStrategy.NOOP;\n        }\n\n        /**\n         * Report an error.\n         */\n        @Override\n        public HttpResponse doDoDelete() throws IOException {\n            throw HttpResponses.status(SC_BAD_REQUEST);\n        }\n\n        @Override\n        public void doConfigSubmit(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException, FormException {\n            Jenkins.getInstance().doConfigExecutorsSubmit(req, rsp);\n        }\n\n        @Override\n        public boolean hasPermission(Permission permission) {\n            // no one should be allowed to delete the master.\n            // this hides the \"delete\" link from the /computer/(master) page.\n            if(permission==Computer.DELETE)\n                return false;\n            // Configuration of master node requires ADMINISTER permission\n            return super.hasPermission(permission==Computer.CONFIGURE ? Jenkins.ADMINISTER : permission);\n        }\n\n        @Override\n        public VirtualChannel getChannel() {\n            return localChannel;\n        }\n\n        @Override\n        public Charset getDefaultCharset() {\n            return Charset.defaultCharset();\n        }\n\n        public List<LogRecord> getLogRecords() throws IOException, InterruptedException {\n            return logRecords;\n        }\n\n        public void doLaunchSlaveAgent(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n            // this computer never returns null from channel, so\n            // this method shall never be invoked.\n            rsp.sendError(SC_NOT_FOUND);\n        }\n\n        protected Future<?> _connect(boolean forceReconnect) {\n            return Futures.precomputed(null);\n        }\n\n        /**\n         * {@link LocalChannel} instance that can be used to execute programs locally.\n         */\n        public static final LocalChannel localChannel = new LocalChannel(threadPoolForRemoting);\n    }\n\n    /**\n     * Shortcut for {@code Hudson.getInstance().lookup.get(type)}\n     */\n    public static <T> T lookup(Class<T> type) {\n        return Jenkins.getInstance().lookup.get(type);\n    }\n\n    /**\n     * Live view of recent {@link LogRecord}s produced by Hudson.\n     */\n    public static List<LogRecord> logRecords = Collections.emptyList(); // initialized to dummy value to avoid NPE\n\n    /**\n     * Thread-safe reusable {@link XStream}.\n     */\n    public static final XStream XSTREAM = new XStream2();\n\n    /**\n     * Alias to {@link #XSTREAM} so that one can access additional methods on {@link XStream2} more easily.\n     */\n    public static final XStream2 XSTREAM2 = (XStream2)XSTREAM;\n\n    private static final int TWICE_CPU_NUM = Math.max(4, Runtime.getRuntime().availableProcessors() * 2);\n\n    /**\n     * Thread pool used to load configuration in parallel, to improve the start up time.\n     * <p>\n     * The idea here is to overlap the CPU and I/O, so we want more threads than CPU numbers.\n     */\n    /*package*/ transient final ExecutorService threadPoolForLoad = new ThreadPoolExecutor(\n        TWICE_CPU_NUM, TWICE_CPU_NUM,\n        5L, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new DaemonThreadFactory());\n\n\n    private static void computeVersion(ServletContext context) {\n        // set the version\n        Properties props = new Properties();\n        try {\n            InputStream is = Jenkins.class.getResourceAsStream(\"jenkins-version.properties\");\n            if(is!=null)\n                props.load(is);\n        } catch (IOException e) {\n            e.printStackTrace(); // if the version properties is missing, that's OK.\n        }\n        String ver = props.getProperty(\"version\");\n        if(ver==null)   ver=\"?\";\n        VERSION = ver;\n        context.setAttribute(\"version\",ver);\n\n        VERSION_HASH = Util.getDigestOf(ver).substring(0, 8);\n        SESSION_HASH = Util.getDigestOf(ver+System.currentTimeMillis()).substring(0, 8);\n\n        if(ver.equals(\"?\") || Boolean.getBoolean(\"hudson.script.noCache\"))\n            RESOURCE_PATH = \"\";\n        else\n            RESOURCE_PATH = \"/static/\"+SESSION_HASH;\n\n        VIEW_RESOURCE_PATH = \"/resources/\"+ SESSION_HASH;\n    }\n\n    /**\n     * Version number of this Hudson.\n     */\n    public static String VERSION=\"?\";\n\n    /**\n     * Parses {@link #VERSION} into {@link VersionNumber}, or null if it's not parseable as a version number\n     * (such as when Hudson is run with \"mvn hudson-dev:run\")\n     */\n    public static VersionNumber getVersion() {\n        try {\n            return new VersionNumber(VERSION);\n        } catch (NumberFormatException e) {\n            try {\n                // for non-released version of Hudson, this looks like \"1.345 (private-foobar), so try to approximate.\n                int idx = VERSION.indexOf(' ');\n                if (idx>0)\n                    return new VersionNumber(VERSION.substring(0,idx));\n            } catch (NumberFormatException _) {\n                // fall through\n            }\n\n            // totally unparseable\n            return null;\n        } catch (IllegalArgumentException e) {\n            // totally unparseable\n            return null;\n        }\n    }\n\n    /**\n     * Hash of {@link #VERSION}.\n     */\n    public static String VERSION_HASH;\n\n    /**\n     * Unique random token that identifies the current session.\n     * Used to make {@link #RESOURCE_PATH} unique so that we can set long \"Expires\" header.\n     * \n     * We used to use {@link #VERSION_HASH}, but making this session local allows us to\n     * reuse the same {@link #RESOURCE_PATH} for static resources in plugins.\n     */\n    public static String SESSION_HASH;\n\n    /**\n     * Prefix to static resources like images and javascripts in the war file.\n     * Either \"\" or strings like \"/static/VERSION\", which avoids Hudson to pick up\n     * stale cache when the user upgrades to a different version.\n     * <p>\n     * Value computed in {@link WebAppMain}.\n     */\n    public static String RESOURCE_PATH = \"\";\n\n    /**\n     * Prefix to resources alongside view scripts.\n     * Strings like \"/resources/VERSION\", which avoids Hudson to pick up\n     * stale cache when the user upgrades to a different version.\n     * <p>\n     * Value computed in {@link WebAppMain}.\n     */\n    public static String VIEW_RESOURCE_PATH = \"/resources/TBD\";\n\n    public static boolean PARALLEL_LOAD = Configuration.getBooleanConfigParameter(\"parallelLoad\", true);\n    public static boolean KILL_AFTER_LOAD = Configuration.getBooleanConfigParameter(\"killAfterLoad\", false);\n    /**\n     * Enabled by default as of 1.337. Will keep it for a while just in case we have some serious problems.\n     */\n    public static boolean FLYWEIGHT_SUPPORT = Configuration.getBooleanConfigParameter(\"flyweightSupport\", true);\n\n    /**\n     * Tentative switch to activate the concurrent build behavior.\n     * When we merge this back to the trunk, this allows us to keep\n     * this feature hidden for a while until we iron out the kinks.\n     * @see AbstractProject#isConcurrentBuild()\n     * @deprecated as of 1.464\n     *      This flag will have no effect.\n     */\n    @Restricted(NoExternalUse.class)\n    public static boolean CONCURRENT_BUILD = true;\n\n    /**\n     * Switch to enable people to use a shorter workspace name.\n     */\n    private static final String WORKSPACE_DIRNAME = Configuration.getStringConfigParameter(\"workspaceDirName\", \"workspace\");\n\n    /**\n     * Automatically try to launch a slave when Jenkins is initialized or a new slave is created.\n     */\n    public static boolean AUTOMATIC_SLAVE_LAUNCH = true;\n\n    private static final Logger LOGGER = Logger.getLogger(Jenkins.class.getName());\n\n    private static final Pattern ICON_SIZE = Pattern.compile(\"\\\\d+x\\\\d+\");\n\n    public static final PermissionGroup PERMISSIONS = Permission.HUDSON_PERMISSIONS;\n    public static final Permission ADMINISTER = Permission.HUDSON_ADMINISTER;\n    public static final Permission READ = new Permission(PERMISSIONS,\"Read\",Messages._Hudson_ReadPermission_Description(),Permission.READ,PermissionScope.JENKINS);\n    public static final Permission RUN_SCRIPTS = new Permission(PERMISSIONS, \"RunScripts\", Messages._Hudson_RunScriptsPermission_Description(),ADMINISTER,PermissionScope.JENKINS);\n\n    /**\n     * {@link Authentication} object that represents the anonymous user.\n     * Because Acegi creates its own {@link AnonymousAuthenticationToken} instances, the code must not\n     * expect the singleton semantics. This is just a convenient instance.\n     *\n     * @since 1.343\n     */\n    public static final Authentication ANONYMOUS = new AnonymousAuthenticationToken(\n            \"anonymous\",\"anonymous\",new GrantedAuthority[]{new GrantedAuthorityImpl(\"anonymous\")});\n\n    static {\n        XSTREAM.alias(\"jenkins\",Jenkins.class);\n        XSTREAM.alias(\"slave\", DumbSlave.class);\n        XSTREAM.alias(\"jdk\",JDK.class);\n        // for backward compatibility with <1.75, recognize the tag name \"view\" as well.\n        XSTREAM.alias(\"view\", ListView.class);\n        XSTREAM.alias(\"listView\", ListView.class);\n        // this seems to be necessary to force registration of converter early enough\n        Mode.class.getEnumConstants();\n\n        // double check that initialization order didn't do any harm\n        assert PERMISSIONS!=null;\n        assert ADMINISTER!=null;\n    }\n\n}\n", "<!--\nThe MIT License\n\nCopyright (c) 2004-2009, Sun Microsystems, Inc., Kohsuke Kawaguchi\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n-->\n\n<!--\n  read icon size from a cookie and set it up\n-->\n<?jelly escape-by-default='true'?>\n<j:jelly xmlns:j=\"jelly:core\" xmlns:x=\"jelly:xml\" xmlns:st=\"jelly:stapler\" xmlns:d=\"jelly:define\" xmlns:l=\"/lib/layout\" xmlns:t=\"/lib/hudson\" xmlns:f=\"/lib/form\">\n  <j:set scope=\"parent\" var=\"iconSize\" value=\"${h.getCookie(request,'iconSize','32x32')}\" />\n  <!--\n    balls look smaller than their actual size,\n    so we try not to make the secondary icons look bigger than the icon.\n    we want the user's eyes to go to balls, not the clock.\n  -->\n  <j:set scope=\"parent\" var=\"subIconSize\" value=\"${iconSize=='32x32'?'24x24':iconSize}\"/>\n</j:jelly>"], "fixing_code": ["/*\n * The MIT License\n * \n * Copyright (c) 2004-2010, Sun Microsystems, Inc., Kohsuke Kawaguchi,\n * Yahoo! Inc., Stephen Connolly, Tom Huybrechts, Alan Harder, Manufacture\n * Francaise des Pneumatiques Michelin, Romain Seguy\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson;\n\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\nimport hudson.cli.CLICommand;\nimport hudson.console.ConsoleAnnotationDescriptor;\nimport hudson.console.ConsoleAnnotatorFactory;\nimport hudson.model.*;\nimport hudson.model.ParameterDefinition.ParameterDescriptor;\nimport hudson.search.SearchableModelObject;\nimport hudson.security.AccessControlled;\nimport hudson.security.AuthorizationStrategy;\nimport hudson.security.GlobalSecurityConfiguration;\nimport hudson.security.Permission;\nimport hudson.security.SecurityRealm;\nimport hudson.security.captcha.CaptchaSupport;\nimport hudson.security.csrf.CrumbIssuer;\nimport hudson.slaves.Cloud;\nimport hudson.slaves.ComputerLauncher;\nimport hudson.slaves.NodeProperty;\nimport hudson.slaves.NodePropertyDescriptor;\nimport hudson.slaves.RetentionStrategy;\nimport hudson.tasks.BuildStepDescriptor;\nimport hudson.tasks.BuildWrapper;\nimport hudson.tasks.BuildWrappers;\nimport hudson.tasks.Builder;\nimport hudson.tasks.Publisher;\nimport hudson.tasks.UserAvatarResolver;\nimport hudson.util.Area;\nimport hudson.util.Iterators;\nimport hudson.scm.SCM;\nimport hudson.scm.SCMDescriptor;\nimport hudson.util.Secret;\nimport hudson.views.MyViewsTabBar;\nimport hudson.views.ViewsTabBar;\nimport hudson.widgets.RenderOnDemandClosure;\nimport jenkins.model.GlobalConfiguration;\nimport jenkins.model.GlobalConfigurationCategory;\nimport jenkins.model.GlobalConfigurationCategory.Unclassified;\nimport jenkins.model.Jenkins;\nimport jenkins.model.ModelObjectWithContextMenu;\nimport org.acegisecurity.providers.anonymous.AnonymousAuthenticationToken;\nimport org.apache.commons.jelly.JellyContext;\nimport org.apache.commons.jelly.JellyTagException;\nimport org.apache.commons.jelly.Script;\nimport org.apache.commons.jelly.XMLOutput;\nimport org.apache.commons.jexl.parser.ASTSizeFunction;\nimport org.apache.commons.jexl.util.Introspector;\nimport org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement;\nimport org.jvnet.tiger_types.Types;\nimport org.kohsuke.stapler.Ancestor;\nimport org.kohsuke.stapler.Stapler;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\nimport org.kohsuke.stapler.jelly.InternationalizedStringExpression.RawHtmlArgument;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.management.LockInfo;\nimport java.lang.management.ManagementFactory;\nimport java.lang.management.MonitorInfo;\nimport java.lang.management.ThreadInfo;\nimport java.lang.management.ThreadMXBean;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.ParameterizedType;\nimport java.net.MalformedURLException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.net.URLDecoder;\nimport java.text.DecimalFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.ConcurrentModificationException;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\nimport java.util.Date;\nimport java.util.logging.Level;\nimport java.util.logging.LogManager;\nimport java.util.logging.LogRecord;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\nimport java.util.regex.Pattern;\nimport org.apache.commons.lang.StringUtils;\nimport org.kohsuke.accmod.Restricted;\nimport org.kohsuke.accmod.restrictions.NoExternalUse;\n\n/**\n * Utility functions used in views.\n *\n * <p>\n * An instance of this class is created for each request and made accessible\n * from view pages via the variable 'h' (h stands for Hudson.)\n *\n * @author Kohsuke Kawaguchi\n */\npublic class Functions {\n    private static volatile int globalIota = 0;\n    private int iota;\n\n    public Functions() {\n        iota = globalIota;\n        // concurrent requests can use the same ID --- we are just trying to\n        // prevent the same user from seeing the same ID repeatedly.\n        globalIota+=1000;\n    }\n\n    /**\n     * Generates an unique ID.\n     */\n    public String generateId() {\n        return \"id\"+iota++;\n    }\n\n    public static boolean isModel(Object o) {\n        return o instanceof ModelObject;\n    }\n\n    public static boolean isModelWithContextMenu(Object o) {\n        return o instanceof ModelObjectWithContextMenu;\n    }\n\n    public static String xsDate(Calendar cal) {\n        return Util.XS_DATETIME_FORMATTER.format(cal.getTime());\n    }\n\n    public static String rfc822Date(Calendar cal) {\n        return Util.RFC822_DATETIME_FORMATTER.format(cal.getTime());\n    }\n    \n    public static void initPageVariables(JellyContext context) {\n        String rootURL = Stapler.getCurrentRequest().getContextPath();\n\n        Functions h = new Functions();\n        context.setVariable(\"h\", h);\n\n\n        // The path starts with a \"/\" character but does not end with a \"/\" character.\n        context.setVariable(\"rootURL\", rootURL);\n\n        /*\n            load static resources from the path dedicated to a specific version.\n            This \"/static/VERSION/abc/def.ghi\" path is interpreted by stapler to be\n            the same thing as \"/abc/def.ghi\", but this avoids the stale cache\n            problem when the user upgrades to new Jenkins. Stapler also sets a long\n            future expiration dates for such static resources.\n\n            see https://wiki.jenkins-ci.org/display/JENKINS/Hyperlinks+in+HTML\n         */\n        context.setVariable(\"resURL\",rootURL+getResourcePath());\n        context.setVariable(\"imagesURL\",rootURL+getResourcePath()+\"/images\");\n    }\n\n    /**\n     * Given {@code c=MyList (extends ArrayList<Foo>), base=List}, compute the parameterization of 'base'\n     * that's assignable from 'c' (in this case {@code List<Foo>}), and return its n-th type parameter\n     * (n=0 would return {@code Foo}).\n     *\n     * <p>\n     * This method is useful for doing type arithmetic.\n     *\n     * @throws AssertionError\n     *      if c' is not parameterized.\n     */\n    public static <B> Class getTypeParameter(Class<? extends B> c, Class<B> base, int n) {\n        Type parameterization = Types.getBaseClass(c,base);\n        if (parameterization instanceof ParameterizedType) {\n            ParameterizedType pt = (ParameterizedType) parameterization;\n            return Types.erasure(Types.getTypeArgument(pt,n));\n        } else {\n            throw new AssertionError(c+\" doesn't properly parameterize \"+base);\n        }\n    }\n\n    public JDK.DescriptorImpl getJDKDescriptor() {\n        return Jenkins.getInstance().getDescriptorByType(JDK.DescriptorImpl.class);\n    }\n\n    /**\n     * Prints the integer as a string that represents difference,\n     * like \"-5\", \"+/-0\", \"+3\".\n     */\n    public static String getDiffString(int i) {\n        if(i==0)    return \"\\u00B10\";   // +/-0\n        String s = Integer.toString(i);\n        if(i>0)     return \"+\"+s;\n        else        return s;\n    }\n\n    /**\n     * {@link #getDiffString(int)} that doesn't show anything for +/-0\n     */\n    public static String getDiffString2(int i) {\n        if(i==0)    return \"\";\n        String s = Integer.toString(i);\n        if(i>0)     return \"+\"+s;\n        else        return s;\n    }\n\n    /**\n     * {@link #getDiffString2(int)} that puts the result into prefix and suffix\n     * if there's something to print\n     */\n    public static String getDiffString2(String prefix, int i, String suffix) {\n        if(i==0)    return \"\";\n        String s = Integer.toString(i);\n        if(i>0)     return prefix+\"+\"+s+suffix;\n        else        return prefix+s+suffix;\n    }\n\n    /**\n     * Adds the proper suffix.\n     */\n    public static String addSuffix(int n, String singular, String plural) {\n        StringBuilder buf = new StringBuilder();\n        buf.append(n).append(' ');\n        if(n==1)\n            buf.append(singular);\n        else\n            buf.append(plural);\n        return buf.toString();\n    }\n\n    public static RunUrl decompose(StaplerRequest req) {\n        List<Ancestor> ancestors = req.getAncestors();\n\n        // find the first and last Run instances\n        Ancestor f=null,l=null;\n        for (Ancestor anc : ancestors) {\n            if(anc.getObject() instanceof Run) {\n                if(f==null) f=anc;\n                l=anc;\n            }\n        }\n        if(l==null) return null;    // there was no Run object\n\n        String head = f.getPrev().getUrl()+'/';\n        String base = l.getUrl();\n\n        String reqUri = req.getOriginalRequestURI();\n        // Find \"rest\" or URI by removing N path components.\n        // Not using reqUri.substring(f.getUrl().length()) to avoid mismatches due to\n        // url-encoding or extra slashes.  Former may occur in Tomcat (despite the spec saying\n        // this string is not decoded, Tomcat apparently decodes this string. You see ' '\n        // instead of '%20', which is what the browser has sent), latter may occur in some\n        // proxy or URL-rewriting setups where extra slashes are inadvertently added.\n        String furl = f.getUrl();\n        int slashCount = 0;\n        // Count components in ancestor URL\n        for (int i = furl.indexOf('/'); i >= 0; i = furl.indexOf('/', i + 1)) slashCount++;\n        // Remove that many from request URL, ignoring extra slashes\n        String rest = reqUri.replaceFirst(\"(?:/+[^/]*){\" + slashCount + \"}\", \"\");\n\n        return new RunUrl( (Run) f.getObject(), head, base, rest);\n    }\n\n    /**\n     * If we know the user's screen resolution, return it. Otherwise null.\n     * @since 1.213\n     */\n    public static Area getScreenResolution() {\n        Cookie res = Functions.getCookie(Stapler.getCurrentRequest(),\"screenResolution\");\n        if(res!=null)\n            return Area.parse(res.getValue());\n        return null;\n    }\n\n    /**\n     * URL decomposed for easier computation of relevant URLs.\n     *\n     * <p>\n     * The decomposed URL will be of the form:\n     * <pre>\n     * aaaaaa/524/bbbbb/cccc\n     * -head-| N |---rest---\n     * ----- base -----|\n     * </pre>\n     *\n     * <p>\n     * The head portion is the part of the URL from the {@link jenkins.model.Jenkins}\n     * object to the first {@link Run} subtype. When \"next/prev build\"\n     * is chosen, this part remains intact.\n     *\n     * <p>\n     * The <tt>524</tt> is the path from {@link Job} to {@link Run}.\n     *\n     * <p>\n     * The <tt>bbb</tt> portion is the path after that till the last\n     * {@link Run} subtype. The <tt>ccc</tt> portion is the part\n     * after that.\n     */\n    public static final class RunUrl {\n        private final String head, base, rest;\n        private final Run run;\n\n\n        public RunUrl(Run run, String head, String base, String rest) {\n            this.run = run;\n            this.head = head;\n            this.base = base;\n            this.rest = rest;\n        }\n\n        public String getBaseUrl() {\n            return base;\n        }\n\n        /**\n         * Returns the same page in the next build.\n         */\n        public String getNextBuildUrl() {\n            return getUrl(run.getNextBuild());\n        }\n\n        /**\n         * Returns the same page in the previous build.\n         */\n        public String getPreviousBuildUrl() {\n            return getUrl(run.getPreviousBuild());\n        }\n\n        private String getUrl(Run n) {\n            if(n ==null)\n                return null;\n            else {\n                return head+n.getNumber()+rest;\n            }\n        }\n    }\n\n    public static Node.Mode[] getNodeModes() {\n        return Node.Mode.values();\n    }\n\n    public static String getProjectListString(List<Project> projects) {\n        return Items.toNameList(projects);\n    }\n\n    /**\n     * @deprecated as of 1.294\n     *      JEXL now supports the real ternary operator \"x?y:z\", so this work around\n     *      is no longer necessary.\n     */\n    public static Object ifThenElse(boolean cond, Object thenValue, Object elseValue) {\n        return cond ? thenValue : elseValue;\n    }\n\n    public static String appendIfNotNull(String text, String suffix, String nullText) {\n        return text == null ? nullText : text + suffix;\n    }\n\n    public static Map getSystemProperties() {\n        return new TreeMap<Object,Object>(System.getProperties());\n    }\n\n    public static Map getEnvVars() {\n        return new TreeMap<String,String>(EnvVars.masterEnvVars);\n    }\n\n    public static boolean isWindows() {\n        return File.pathSeparatorChar==';';\n    }\n\n    public static List<LogRecord> getLogRecords() {\n        return Jenkins.logRecords;\n    }\n\n    public static String printLogRecord(LogRecord r) {\n        return formatter.format(r);\n    }\n\n    public static Cookie getCookie(HttpServletRequest req,String name) {\n        Cookie[] cookies = req.getCookies();\n        if(cookies!=null) {\n            for (Cookie cookie : cookies) {\n                if(cookie.getName().equals(name)) {\n                    return cookie;\n                }\n            }\n        }\n        return null;\n    }\n\n    public static String getCookie(HttpServletRequest req,String name, String defaultValue) {\n        Cookie c = getCookie(req, name);\n        if(c==null || c.getValue()==null) return defaultValue;\n        return c.getValue();\n    }\n\n    private static final Pattern ICON_SIZE = Pattern.compile(\"\\\\d+x\\\\d+\");\n    @Restricted(NoExternalUse.class)\n    public static String validateIconSize(String iconSize) throws SecurityException {\n        if (!ICON_SIZE.matcher(iconSize).matches()) {\n            throw new SecurityException(\"invalid iconSize\");\n        }\n        return iconSize;\n    }\n\n    /**\n     * Gets the suffix to use for YUI JavaScript.\n     */\n    public static String getYuiSuffix() {\n        return DEBUG_YUI ? \"debug\" : \"min\";\n    }\n\n    /**\n     * Set to true if you need to use the debug version of YUI.\n     */\n    public static boolean DEBUG_YUI = Boolean.getBoolean(\"debug.YUI\");\n\n    /**\n     * Creates a sub map by using the given range (both ends inclusive).\n     */\n    public static <V> SortedMap<Integer,V> filter(SortedMap<Integer,V> map, String from, String to) {\n        if(from==null && to==null)      return map;\n        if(to==null)\n            return map.headMap(Integer.parseInt(from)-1);\n        if(from==null)\n            return map.tailMap(Integer.parseInt(to));\n\n        return map.subMap(Integer.parseInt(to),Integer.parseInt(from)-1);\n    }\n\n    private static final SimpleFormatter formatter = new SimpleFormatter();\n\n    /**\n     * Used by <tt>layout.jelly</tt> to control the auto refresh behavior.\n     *\n     * @param noAutoRefresh\n     *      On certain pages, like a page with forms, will have annoying interference\n     *      with auto refresh. On those pages, disable auto-refresh.\n     */\n    public static void configureAutoRefresh(HttpServletRequest request, HttpServletResponse response, boolean noAutoRefresh) {\n        if(noAutoRefresh)\n            return;\n\n        String param = request.getParameter(\"auto_refresh\");\n        boolean refresh = isAutoRefresh(request);\n        if (param != null) {\n            refresh = Boolean.parseBoolean(param);\n            Cookie c = new Cookie(\"hudson_auto_refresh\", Boolean.toString(refresh));\n            // Need to set path or it will not stick from e.g. a project page to the dashboard.\n            // Using request.getContextPath() might work but it seems simpler to just use the hudson_ prefix\n            // to avoid conflicts with any other web apps that might be on the same machine.\n            c.setPath(\"/\");\n            c.setMaxAge(60*60*24*30); // persist it roughly for a month\n            response.addCookie(c);\n        }\n        if (refresh) {\n            response.addHeader(\"Refresh\", System.getProperty(\"hudson.Functions.autoRefreshSeconds\", \"10\"));\n        }\n    }\n\n    public static boolean isAutoRefresh(HttpServletRequest request) {\n        String param = request.getParameter(\"auto_refresh\");\n        if (param != null) {\n            return Boolean.parseBoolean(param);\n        }\n        Cookie[] cookies = request.getCookies();\n        if(cookies==null)\n            return false; // when API design messes it up, we all suffer\n\n        for (Cookie c : cookies) {\n            if (c.getName().equals(\"hudson_auto_refresh\")) {\n                return Boolean.parseBoolean(c.getValue());\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Finds the given object in the ancestor list and returns its URL.\n     * This is used to determine the \"current\" URL assigned to the given object,\n     * so that one can compute relative URLs from it.\n     */\n    public static String getNearestAncestorUrl(StaplerRequest req,Object it) {\n        List list = req.getAncestors();\n        for( int i=list.size()-1; i>=0; i-- ) {\n            Ancestor anc = (Ancestor) list.get(i);\n            if(anc.getObject()==it)\n                return anc.getUrl();\n        }\n        return null;\n    }\n\n    /**\n     * Finds the inner-most {@link SearchableModelObject} in scope.\n     */\n    public static String getSearchURL() {\n        List list = Stapler.getCurrentRequest().getAncestors();\n        for( int i=list.size()-1; i>=0; i-- ) {\n            Ancestor anc = (Ancestor) list.get(i);\n            if(anc.getObject() instanceof SearchableModelObject)\n                return anc.getUrl()+\"/search/\";\n        }\n        return null;\n    }\n\n    public static String appendSpaceIfNotNull(String n) {\n        if(n==null) return null;\n        else        return n+' ';\n    }\n\n    /**\n     * One nbsp per 10 pixels in given size, which may be a plain number or \"NxN\"\n     * (like an iconSize).  Useful in a sortable table heading.\n     */\n    public static String nbspIndent(String size) {\n        int i = size.indexOf('x');\n        i = Integer.parseInt(i > 0 ? size.substring(0, i) : size) / 10;\n        StringBuilder buf = new StringBuilder(30);\n        for (int j = 0; j < i; j++)\n            buf.append(\"&nbsp;\");\n        return buf.toString();\n    }\n\n    public static String getWin32ErrorMessage(IOException e) {\n        return Util.getWin32ErrorMessage(e);\n    }\n\n    public static boolean isMultiline(String s) {\n        if(s==null)     return false;\n        return s.indexOf('\\r')>=0 || s.indexOf('\\n')>=0;\n    }\n\n    public static String encode(String s) {\n        return Util.encode(s);\n    }\n\n    public static String escape(String s) {\n        return Util.escape(s);\n    }\n\n    public static String xmlEscape(String s) {\n        return Util.xmlEscape(s);\n    }\n\n    public static String xmlUnescape(String s) {\n        return s.replace(\"&lt;\",\"<\").replace(\"&gt;\",\">\").replace(\"&amp;\",\"&\");\n    }\n\n    public static String htmlAttributeEscape(String text) {\n        StringBuilder buf = new StringBuilder(text.length()+64);\n        for( int i=0; i<text.length(); i++ ) {\n            char ch = text.charAt(i);\n            if(ch=='<')\n                buf.append(\"&lt;\");\n            else\n            if(ch=='>')\n                buf.append(\"&gt;\");\n            else\n            if(ch=='&')\n                buf.append(\"&amp;\");\n            else\n            if(ch=='\"')\n                buf.append(\"&quot;\");\n            else\n            if(ch=='\\'')\n                buf.append(\"&#39;\");\n            else\n                buf.append(ch);\n        }\n        return buf.toString();\n    }\n\n    public static void checkPermission(Permission permission) throws IOException, ServletException {\n        checkPermission(Jenkins.getInstance(),permission);\n    }\n\n    public static void checkPermission(AccessControlled object, Permission permission) throws IOException, ServletException {\n        if (permission != null) {\n            object.checkPermission(permission);\n        }\n    }\n\n    /**\n     * This version is so that the 'checkPermission' on <tt>layout.jelly</tt>\n     * degrades gracefully if \"it\" is not an {@link AccessControlled} object.\n     * Otherwise it will perform no check and that problem is hard to notice.\n     */\n    public static void checkPermission(Object object, Permission permission) throws IOException, ServletException {\n        if (permission == null)\n            return;\n        \n        if (object instanceof AccessControlled)\n            checkPermission((AccessControlled) object,permission);\n        else {\n            List<Ancestor> ancs = Stapler.getCurrentRequest().getAncestors();\n            for(Ancestor anc : Iterators.reverse(ancs)) {\n                Object o = anc.getObject();\n                if (o instanceof AccessControlled) {\n                    checkPermission((AccessControlled) o,permission);\n                    return;\n                }\n            }\n            checkPermission(Jenkins.getInstance(),permission);\n        }\n    }\n\n    /**\n     * Returns true if the current user has the given permission.\n     *\n     * @param permission\n     *      If null, returns true. This defaulting is convenient in making the use of this method terse.\n     */\n    public static boolean hasPermission(Permission permission) throws IOException, ServletException {\n        return hasPermission(Jenkins.getInstance(),permission);\n    }\n\n    /**\n     * This version is so that the 'hasPermission' can degrade gracefully\n     * if \"it\" is not an {@link AccessControlled} object.\n     */\n    public static boolean hasPermission(Object object, Permission permission) throws IOException, ServletException {\n        if (permission == null)\n            return true;\n        if (object instanceof AccessControlled)\n            return ((AccessControlled)object).hasPermission(permission);\n        else {\n            List<Ancestor> ancs = Stapler.getCurrentRequest().getAncestors();\n            for(Ancestor anc : Iterators.reverse(ancs)) {\n                Object o = anc.getObject();\n                if (o instanceof AccessControlled) {\n                    return ((AccessControlled)o).hasPermission(permission);\n                }\n            }\n            return Jenkins.getInstance().hasPermission(permission);\n        }\n    }\n\n    public static void adminCheck(StaplerRequest req, StaplerResponse rsp, Object required, Permission permission) throws IOException, ServletException {\n        // this is legacy --- all views should be eventually converted to\n        // the permission based model.\n        if(required!=null && !Hudson.adminCheck(req, rsp)) {\n            // check failed. commit the FORBIDDEN response, then abort.\n            rsp.setStatus(HttpServletResponse.SC_FORBIDDEN);\n            rsp.getOutputStream().close();\n            throw new ServletException(\"Unauthorized access\");\n        }\n\n        // make sure the user owns the necessary permission to access this page.\n        if(permission!=null)\n            checkPermission(permission);\n    }\n\n    /**\n     * Infers the hudson installation URL from the given request.\n     */\n    public static String inferHudsonURL(StaplerRequest req) {\n        String rootUrl = Jenkins.getInstance().getRootUrl();\n        if(rootUrl !=null)\n            // prefer the one explicitly configured, to work with load-balancer, frontend, etc.\n            return rootUrl;\n        StringBuilder buf = new StringBuilder();\n        buf.append(req.getScheme()).append(\"://\");\n        buf.append(req.getServerName());\n        if(! (req.getScheme().equals(\"http\") && req.getLocalPort()==80 || req.getScheme().equals(\"https\") && req.getLocalPort()==443))\n            buf.append(':').append(req.getLocalPort());\n        buf.append(req.getContextPath()).append('/');\n        return buf.toString();\n    }\n\n    /**\n     * Returns the link to be displayed in the footer of the UI.\n     */\n    public static String getFooterURL() {\n        if(footerURL == null) {\n            footerURL = System.getProperty(\"hudson.footerURL\");\n            if(StringUtils.isBlank(footerURL)) {\n                footerURL = \"http://jenkins-ci.org/\";\n            }\n        }\n        return footerURL;\n    }\n    private static String footerURL = null;\n\n    public static List<JobPropertyDescriptor> getJobPropertyDescriptors(Class<? extends Job> clazz) {\n        return JobPropertyDescriptor.getPropertyDescriptors(clazz);\n    }\n\n    public static List<Descriptor<BuildWrapper>> getBuildWrapperDescriptors(AbstractProject<?,?> project) {\n        return BuildWrappers.getFor(project);\n    }\n\n    public static List<Descriptor<SecurityRealm>> getSecurityRealmDescriptors() {\n        return SecurityRealm.all();\n    }\n\n    public static List<Descriptor<AuthorizationStrategy>> getAuthorizationStrategyDescriptors() {\n        return AuthorizationStrategy.all();\n    }\n\n    public static List<Descriptor<Builder>> getBuilderDescriptors(AbstractProject<?,?> project) {\n        return BuildStepDescriptor.filter(Builder.all(), project.getClass());\n    }\n\n    public static List<Descriptor<Publisher>> getPublisherDescriptors(AbstractProject<?,?> project) {\n        return BuildStepDescriptor.filter(Publisher.all(), project.getClass());\n    }\n\n    public static List<SCMDescriptor<?>> getSCMDescriptors(AbstractProject<?,?> project) {\n        return SCM._for(project);\n    }\n\n    public static List<Descriptor<ComputerLauncher>> getComputerLauncherDescriptors() {\n        return Jenkins.getInstance().<ComputerLauncher,Descriptor<ComputerLauncher>>getDescriptorList(ComputerLauncher.class);\n    }\n\n    public static List<Descriptor<RetentionStrategy<?>>> getRetentionStrategyDescriptors() {\n        return RetentionStrategy.all();\n    }\n\n    public static List<ParameterDescriptor> getParameterDescriptors() {\n        return ParameterDefinition.all();\n    }\n\n    public static List<Descriptor<CaptchaSupport>> getCaptchaSupportDescriptors() {\n        return CaptchaSupport.all();\n    }\n\n    public static List<Descriptor<ViewsTabBar>> getViewsTabBarDescriptors() {\n        return ViewsTabBar.all();\n    }\n\n    public static List<Descriptor<MyViewsTabBar>> getMyViewsTabBarDescriptors() {\n        return MyViewsTabBar.all();\n    }\n\n    public static List<NodePropertyDescriptor> getNodePropertyDescriptors(Class<? extends Node> clazz) {\n        List<NodePropertyDescriptor> result = new ArrayList<NodePropertyDescriptor>();\n        Collection<NodePropertyDescriptor> list = (Collection) Jenkins.getInstance().getDescriptorList(NodeProperty.class);\n        for (NodePropertyDescriptor npd : list) {\n            if (npd.isApplicable(clazz)) {\n                result.add(npd);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Gets all the descriptors sorted by their inheritance tree of {@link Describable}\n     * so that descriptors of similar types come nearby.\n     *\n     * <p>\n     * We sort them by {@link Extension#ordinal()} but only for {@link GlobalConfiguration}s,\n     * as the value is normally used to compare similar kinds of extensions, and we needed\n     * {@link GlobalConfiguration}s to be able to position themselves in a layer above.\n     * This however creates some asymmetry between regular {@link Descriptor}s and {@link GlobalConfiguration}s.\n     * Perhaps it is better to introduce another annotation element? But then,\n     * extensions shouldn't normally concern themselves about ordering too much, and the only reason\n     * we needed this for {@link GlobalConfiguration}s are for backward compatibility.\n     *\n     * @param predicate\n     *      Filter the descriptors based on {@link GlobalConfigurationCategory}\n     * @since 1.494\n     */\n    public static Collection<Descriptor> getSortedDescriptorsForGlobalConfig(Predicate<GlobalConfigurationCategory> predicate) {\n        ExtensionList<Descriptor> exts = Jenkins.getInstance().getExtensionList(Descriptor.class);\n        List<Tag> r = new ArrayList<Tag>(exts.size());\n\n        for (ExtensionComponent<Descriptor> c : exts.getComponents()) {\n            Descriptor d = c.getInstance();\n            if (d.getGlobalConfigPage()==null)  continue;\n\n            if (d instanceof GlobalConfiguration) {\n                if (predicate.apply(((GlobalConfiguration)d).getCategory()))\n                    r.add(new Tag(c.ordinal(), d));\n            } else {\n                if (predicate.apply(GlobalConfigurationCategory.get(Unclassified.class)))\n                    r.add(new Tag(0, d));\n            }\n        }\n        Collections.sort(r);\n\n        List<Descriptor> answer = new ArrayList<Descriptor>(r.size());\n        for (Tag d : r) answer.add(d.d);\n\n        return DescriptorVisibilityFilter.apply(Jenkins.getInstance(),answer);\n    }\n\n    /**\n     * Like {@link #getSortedDescriptorsForGlobalConfig(Predicate)} but with a constant truth predicate, to include all descriptors.\n     */\n    public static Collection<Descriptor> getSortedDescriptorsForGlobalConfig() {\n        return getSortedDescriptorsForGlobalConfig(Predicates.<GlobalConfigurationCategory>alwaysTrue());\n    }\n\n    /**\n     * @deprecated This is rather meaningless.\n     */\n    @Deprecated\n    public static Collection<Descriptor> getSortedDescriptorsForGlobalConfigNoSecurity() {\n        return getSortedDescriptorsForGlobalConfig(Predicates.not(GlobalSecurityConfiguration.FILTER));\n    }\n\n    /**\n     * Like {@link #getSortedDescriptorsForGlobalConfig(Predicate)} but for unclassified descriptors only.\n     * @since 1.506\n     */\n    public static Collection<Descriptor> getSortedDescriptorsForGlobalConfigUnclassified() {\n        return getSortedDescriptorsForGlobalConfig(new Predicate<GlobalConfigurationCategory>() {\n            public boolean apply(GlobalConfigurationCategory cat) {\n                return cat instanceof GlobalConfigurationCategory.Unclassified;\n            }\n        });\n    }\n    \n    private static class Tag implements Comparable<Tag> {\n        double ordinal;\n        String hierarchy;\n        Descriptor d;\n\n        Tag(double ordinal, Descriptor d) {\n            this.ordinal = ordinal;\n            this.d = d;\n            this.hierarchy = buildSuperclassHierarchy(d.clazz, new StringBuilder()).toString();\n        }\n\n        private StringBuilder buildSuperclassHierarchy(Class c, StringBuilder buf) {\n            Class sc = c.getSuperclass();\n            if (sc!=null)   buildSuperclassHierarchy(sc,buf).append(':');\n            return buf.append(c.getName());\n        }\n\n        public int compareTo(Tag that) {\n            int r = Double.compare(this.ordinal, that.ordinal);\n            if (r!=0)   return -r; // descending for ordinal\n            return this.hierarchy.compareTo(that.hierarchy);\n        }\n    }\n    /**\n     * Computes the path to the icon of the given action\n     * from the context path.\n     */\n    public static String getIconFilePath(Action a) {\n        String name = a.getIconFileName();\n        if (name==null)     return null;\n        if (name.startsWith(\"/\"))\n            return name.substring(1);\n        else\n            return \"images/24x24/\"+name;\n    }\n\n    /**\n     * Works like JSTL build-in size(x) function,\n     * but handle null gracefully.\n     */\n    public static int size2(Object o) throws Exception {\n        if(o==null) return 0;\n        return ASTSizeFunction.sizeOf(o,Introspector.getUberspect());\n    }\n\n    /**\n     * Computes the relative path from the current page to the given item.\n     */\n    public static String getRelativeLinkTo(Item p) {\n        Map<Object,String> ancestors = new HashMap<Object,String>();\n        View view=null;\n\n        StaplerRequest request = Stapler.getCurrentRequest();\n        for( Ancestor a : request.getAncestors() ) {\n            ancestors.put(a.getObject(),a.getRelativePath());\n            if(a.getObject() instanceof View)\n                view = (View) a.getObject();\n        }\n\n        String path = ancestors.get(p);\n        if(path!=null)  return path;\n\n        Item i=p;\n        String url = \"\";\n        while(true) {\n            ItemGroup ig = i.getParent();\n            url = i.getShortUrl()+url;\n\n            if(ig== Jenkins.getInstance()) {\n                assert i instanceof TopLevelItem;\n                if(view!=null && view.contains((TopLevelItem)i)) {\n                    // if p and the current page belongs to the same view, then return a relative path\n                    return ancestors.get(view)+'/'+url;\n                } else {\n                    // otherwise return a path from the root Hudson\n                    return request.getContextPath()+'/'+p.getUrl();\n                }\n            }\n\n            path = ancestors.get(ig);\n            if(path!=null)  return path+'/'+url;\n\n            assert ig instanceof Item; // if not, ig must have been the Hudson instance\n            i = (Item) ig;\n        }\n    }\n\n    public static Map<Thread,StackTraceElement[]> dumpAllThreads() {\n        Map<Thread,StackTraceElement[]> sorted = new TreeMap<Thread,StackTraceElement[]>(new ThreadSorter());\n        sorted.putAll(Thread.getAllStackTraces());\n        return sorted;\n    }\n\n    @IgnoreJRERequirement\n    public static ThreadInfo[] getThreadInfos() {\n        ThreadMXBean mbean = ManagementFactory.getThreadMXBean();\n        return mbean.dumpAllThreads(mbean.isObjectMonitorUsageSupported(),mbean.isSynchronizerUsageSupported());\n    }\n\n    public static ThreadGroupMap sortThreadsAndGetGroupMap(ThreadInfo[] list) {\n        ThreadGroupMap sorter = new ThreadGroupMap();\n        Arrays.sort(list, sorter);\n        return sorter;\n    }\n\n    // Common code for sorting Threads/ThreadInfos by ThreadGroup\n    private static class ThreadSorterBase {\n        protected Map<Long,String> map = new HashMap<Long,String>();\n\n        private ThreadSorterBase() {\n            ThreadGroup tg = Thread.currentThread().getThreadGroup();\n            while (tg.getParent() != null) tg = tg.getParent();\n            Thread[] threads = new Thread[tg.activeCount()*2];\n            int threadsLen = tg.enumerate(threads, true);\n            for (int i = 0; i < threadsLen; i++)\n                map.put(threads[i].getId(), threads[i].getThreadGroup().getName());\n        }\n\n        protected int compare(long idA, long idB) {\n            String tga = map.get(idA), tgb = map.get(idB);\n            int result = (tga!=null?-1:0) + (tgb!=null?1:0);  // Will be non-zero if only one is null\n            if (result==0 && tga!=null)\n                result = tga.compareToIgnoreCase(tgb);\n            return result;\n        }\n    }\n\n    public static class ThreadGroupMap extends ThreadSorterBase implements Comparator<ThreadInfo> {\n\n        /**\n         * @return ThreadGroup name or null if unknown\n         */\n        public String getThreadGroup(ThreadInfo ti) {\n            return map.get(ti.getThreadId());\n        }\n\n        public int compare(ThreadInfo a, ThreadInfo b) {\n            int result = compare(a.getThreadId(), b.getThreadId());\n            if (result == 0)\n                result = a.getThreadName().compareToIgnoreCase(b.getThreadName());\n            return result;\n        }\n    }\n\n    private static class ThreadSorter extends ThreadSorterBase implements Comparator<Thread> {\n\n        public int compare(Thread a, Thread b) {\n            int result = compare(a.getId(), b.getId());\n            if (result == 0)\n                result = a.getName().compareToIgnoreCase(b.getName());\n            return result;\n        }\n    }\n\n    /**\n     * Are we running on JRE6 or above?\n     */\n    @IgnoreJRERequirement\n    public static boolean isMustangOrAbove() {\n        try {\n            System.console();\n            return true;\n        } catch(LinkageError e) {\n            return false;\n        }\n    }\n\n    // ThreadInfo.toString() truncates the stack trace by first 8, so needed my own version\n    @IgnoreJRERequirement\n    public static String dumpThreadInfo(ThreadInfo ti, ThreadGroupMap map) {\n        String grp = map.getThreadGroup(ti);\n        StringBuilder sb = new StringBuilder(\"\\\"\" + ti.getThreadName() + \"\\\"\" +\n                                             \" Id=\" + ti.getThreadId() + \" Group=\" +\n                                             (grp != null ? grp : \"?\") + \" \" +\n                                             ti.getThreadState());\n        if (ti.getLockName() != null) {\n            sb.append(\" on \" + ti.getLockName());\n        }\n        if (ti.getLockOwnerName() != null) {\n            sb.append(\" owned by \\\"\" + ti.getLockOwnerName() +\n                      \"\\\" Id=\" + ti.getLockOwnerId());\n        }\n        if (ti.isSuspended()) {\n            sb.append(\" (suspended)\");\n        }\n        if (ti.isInNative()) {\n            sb.append(\" (in native)\");\n        }\n        sb.append('\\n');\n        StackTraceElement[] stackTrace = ti.getStackTrace();\n        for (int i=0; i < stackTrace.length; i++) {\n            StackTraceElement ste = stackTrace[i];\n            sb.append(\"\\tat \" + ste.toString());\n            sb.append('\\n');\n            if (i == 0 && ti.getLockInfo() != null) {\n                Thread.State ts = ti.getThreadState();\n                switch (ts) {\n                    case BLOCKED:\n                        sb.append(\"\\t-  blocked on \" + ti.getLockInfo());\n                        sb.append('\\n');\n                        break;\n                    case WAITING:\n                        sb.append(\"\\t-  waiting on \" + ti.getLockInfo());\n                        sb.append('\\n');\n                        break;\n                    case TIMED_WAITING:\n                        sb.append(\"\\t-  waiting on \" + ti.getLockInfo());\n                        sb.append('\\n');\n                        break;\n                    default:\n                }\n            }\n\n            for (MonitorInfo mi : ti.getLockedMonitors()) {\n                if (mi.getLockedStackDepth() == i) {\n                    sb.append(\"\\t-  locked \" + mi);\n                    sb.append('\\n');\n                }\n            }\n       }\n\n       LockInfo[] locks = ti.getLockedSynchronizers();\n       if (locks.length > 0) {\n           sb.append(\"\\n\\tNumber of locked synchronizers = \" + locks.length);\n           sb.append('\\n');\n           for (LockInfo li : locks) {\n               sb.append(\"\\t- \" + li);\n               sb.append('\\n');\n           }\n       }\n       sb.append('\\n');\n       return sb.toString();\n    }\n\n    public static <T> Collection<T> emptyList() {\n        return Collections.emptyList();\n    }\n\n    public static String jsStringEscape(String s) {\n        StringBuilder buf = new StringBuilder();\n        for( int i=0; i<s.length(); i++ ) {\n            char ch = s.charAt(i);\n            switch(ch) {\n            case '\\'':\n                buf.append(\"\\\\'\");\n                break;\n            case '\\\\':\n                buf.append(\"\\\\\\\\\");\n                break;\n            case '\"':\n                buf.append(\"\\\\\\\"\");\n                break;\n            default:\n                buf.append(ch);\n            }\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Converts \"abc\" to \"Abc\".\n     */\n    public static String capitalize(String s) {\n        if(s==null || s.length()==0) return s;\n        return Character.toUpperCase(s.charAt(0))+s.substring(1);\n    }\n\n    public static String getVersion() {\n        return Jenkins.VERSION;\n    }\n\n    /**\n     * Resoruce path prefix.\n     */\n    public static String getResourcePath() {\n        return Jenkins.RESOURCE_PATH;\n    }\n\n    public static String getViewResource(Object it, String path) {\n        Class clazz = it.getClass();\n\n        if(it instanceof Class)\n            clazz = (Class)it;\n        if(it instanceof Descriptor)\n            clazz = ((Descriptor)it).clazz;\n\n        StringBuilder buf = new StringBuilder(Stapler.getCurrentRequest().getContextPath());\n        buf.append(Jenkins.VIEW_RESOURCE_PATH).append('/');\n        buf.append(clazz.getName().replace('.','/').replace('$','/'));\n        buf.append('/').append(path);\n\n        return buf.toString();\n    }\n\n    public static boolean hasView(Object it, String path) throws IOException {\n        if(it==null)    return false;\n        return Stapler.getCurrentRequest().getView(it,path)!=null;\n    }\n\n    /**\n     * Can be used to check a checkbox by default.\n     * Used from views like {@code h.defaultToTrue(scm.useUpdate)}.\n     * The expression will evaluate to true if scm is null.\n     */\n    public static boolean defaultToTrue(Boolean b) {\n        if(b==null) return true;\n        return b;\n    }\n\n    /**\n     * If the value exists, return that value. Otherwise return the default value.\n     * <p>\n     * Starting 1.294, JEXL supports the elvis operator \"x?:y\" that supercedes this.\n     *\n     * @since 1.150\n     */\n    public static <T> T defaulted(T value, T defaultValue) {\n        return value!=null ? value : defaultValue;\n    }\n\n    public static String printThrowable(Throwable t) {\n        StringWriter sw = new StringWriter();\n        t.printStackTrace(new PrintWriter(sw));\n        return sw.toString();\n    }\n\n    /**\n     * Counts the number of rows needed for textarea to fit the content.\n     * Minimum 5 rows.\n     */\n    public static int determineRows(String s) {\n        if(s==null)     return 5;\n        return Math.max(5,LINE_END.split(s).length);\n    }\n\n    /**\n     * Converts the Hudson build status to CruiseControl build status,\n     * which is either Success, Failure, Exception, or Unknown.\n     */\n    public static String toCCStatus(Item i) {\n        if (i instanceof Job) {\n            Job j = (Job) i;\n            switch (j.getIconColor().noAnime()) {\n            case ABORTED:\n            case RED:\n            case YELLOW:\n                return \"Failure\";\n            case BLUE:\n                return \"Success\";\n            case DISABLED:\n            case GREY:\n                return \"Unknown\";\n            }\n        }\n        return \"Unknown\";\n    }\n\n    private static final Pattern LINE_END = Pattern.compile(\"\\r?\\n\");\n\n    /**\n     * Checks if the current user is anonymous.\n     */\n    public static boolean isAnonymous() {\n        return Jenkins.getAuthentication() instanceof AnonymousAuthenticationToken;\n    }\n\n    /**\n     * When called from within JEXL expression evaluation,\n     * this method returns the current {@link JellyContext} used\n     * to evaluate the script.\n     *\n     * @since 1.164\n     */\n    public static JellyContext getCurrentJellyContext() {\n        JellyContext context = ExpressionFactory2.CURRENT_CONTEXT.get();\n        assert context!=null;\n        return context;\n    }\n\n    /**\n     * Evaluate a Jelly script and return output as a String.\n     *\n     * @since 1.267\n     */\n    public static String runScript(Script script) throws JellyTagException {\n        StringWriter out = new StringWriter();\n        script.run(getCurrentJellyContext(), XMLOutput.createXMLOutput(out));\n        return out.toString();\n    }\n\n    /**\n     * Returns a sub-list if the given list is bigger than the specified 'maxSize'\n     */\n    public static <T> List<T> subList(List<T> base, int maxSize) {\n        if(maxSize<base.size())\n            return base.subList(0,maxSize);\n        else\n            return base;\n    }\n\n    /**\n     * Combine path components via '/' while handling leading/trailing '/' to avoid duplicates.\n     */\n    public static String joinPath(String... components) {\n        StringBuilder buf = new StringBuilder();\n        for (String s : components) {\n            if (s.length()==0)  continue;\n\n            if (buf.length()>0) {\n                if (buf.charAt(buf.length()-1)!='/')\n                    buf.append('/');\n                if (s.charAt(0)=='/')   s=s.substring(1);\n            }\n            buf.append(s);\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Computes the hyperlink to actions, to handle the situation when the {@link Action#getUrlName()}\n     * returns absolute URL.\n     */\n    public static String getActionUrl(String itUrl,Action action) {\n        String urlName = action.getUrlName();\n        if(urlName==null)   return null;    // to avoid NPE and fail to render the whole page\n        try {\n            if (new URI(urlName).isAbsolute()) {\n                return urlName;\n            }\n        } catch (URISyntaxException x) {\n            Logger.getLogger(Functions.class.getName()).log(Level.WARNING, \"Failed to parse URL for {0}: {1}\", new Object[] {action, x});\n            return null;\n        }\n        if(urlName.startsWith(\"/\"))\n            return joinPath(Stapler.getCurrentRequest().getContextPath(),urlName);\n        else\n            // relative URL name\n            return joinPath(Stapler.getCurrentRequest().getContextPath()+'/'+itUrl,urlName);\n    }\n\n    /**\n     * Escapes the character unsafe for e-mail address.\n     * See http://en.wikipedia.org/wiki/E-mail_address for the details,\n     * but here the vocabulary is even more restricted.\n     */\n    public static String toEmailSafeString(String projectName) {\n        // TODO: escape non-ASCII characters\n        StringBuilder buf = new StringBuilder(projectName.length());\n        for( int i=0; i<projectName.length(); i++ ) {\n            char ch = projectName.charAt(i);\n            if(('a'<=ch && ch<='z')\n            || ('z'<=ch && ch<='Z')\n            || ('0'<=ch && ch<='9')\n            || \"-_.\".indexOf(ch)>=0)\n                buf.append(ch);\n            else\n                buf.append('_');    // escape\n        }\n        return projectName;\n    }\n\n    public String getSystemProperty(String key) {\n        return System.getProperty(key);\n    }\n\n    /**\n     * Obtains the host name of the Hudson server that clients can use to talk back to.\n     * <p>\n     * This is primarily used in <tt>slave-agent.jnlp.jelly</tt> to specify the destination\n     * that the slaves talk to.\n     */\n    public String getServerName() {\n        // Try to infer this from the configured root URL.\n        // This makes it work correctly when Hudson runs behind a reverse proxy.\n        String url = Jenkins.getInstance().getRootUrl();\n        try {\n            if(url!=null) {\n                String host = new URL(url).getHost();\n                if(host!=null)\n                    return host;\n            }\n        } catch (MalformedURLException e) {\n            // fall back to HTTP request\n        }\n        return Stapler.getCurrentRequest().getServerName();\n    }\n\n    /**\n     * Determines the form validation check URL. See textbox.jelly\n     */\n    public String getCheckUrl(String userDefined, Object descriptor, String field) {\n        if(userDefined!=null || field==null)   return userDefined;\n        if (descriptor instanceof Descriptor) {\n            Descriptor d = (Descriptor) descriptor;\n            return d.getCheckUrl(field);\n        }\n        return null;\n    }\n\n    /**\n     * If the given href link is matching the current page, return true.\n     *\n     * Used in <tt>task.jelly</tt> to decide if the page should be highlighted.\n     */\n    public boolean hyperlinkMatchesCurrentPage(String href) throws UnsupportedEncodingException {\n        String url = Stapler.getCurrentRequest().getRequestURL().toString();\n        if (href == null || href.length() <= 1) return \".\".equals(href) && url.endsWith(\"/\");\n        url = URLDecoder.decode(url,\"UTF-8\");\n        href = URLDecoder.decode(href,\"UTF-8\");\n        if (url.endsWith(\"/\")) url = url.substring(0, url.length() - 1);\n        if (href.endsWith(\"/\")) href = href.substring(0, href.length() - 1);\n\n        return url.endsWith(href);\n    }\n\n    public <T> List<T> singletonList(T t) {\n        return Collections.singletonList(t);\n    }\n\n    /**\n     * Gets all the {@link PageDecorator}s.\n     */\n    public static List<PageDecorator> getPageDecorators() {\n        // this method may be called to render start up errors, at which point Hudson doesn't exist yet. see HUDSON-3608 \n        if(Jenkins.getInstance()==null)  return Collections.emptyList();\n        return PageDecorator.all();\n    }\n    \n    public static List<Descriptor<Cloud>> getCloudDescriptors() {\n        return Cloud.all();\n    }\n\n    /**\n     * Prepend a prefix only when there's the specified body.\n     */\n    public String prepend(String prefix, String body) {\n        if(body!=null && body.length()>0)\n            return prefix+body;\n        return body;\n    }\n\n    public static List<Descriptor<CrumbIssuer>> getCrumbIssuerDescriptors() {\n        return CrumbIssuer.all();\n    }\n\n    public static String getCrumb(StaplerRequest req) {\n        Jenkins h = Jenkins.getInstance();\n        CrumbIssuer issuer = h != null ? h.getCrumbIssuer() : null;\n        return issuer != null ? issuer.getCrumb(req) : \"\";\n    }\n\n    public static String getCrumbRequestField() {\n        Jenkins h = Jenkins.getInstance();\n        CrumbIssuer issuer = h != null ? h.getCrumbIssuer() : null;\n        return issuer != null ? issuer.getDescriptor().getCrumbRequestField() : \"\";\n    }\n\n    public static Date getCurrentTime() {\n        return new Date();\n    }\n\n    public static Locale getCurrentLocale() {\n        Locale locale=null;\n        StaplerRequest req = Stapler.getCurrentRequest();\n        if(req!=null)\n            locale = req.getLocale();\n        if(locale==null)\n            locale = Locale.getDefault();\n        return locale;\n    }\n\n    /**\n     * Generate a series of &lt;script> tags to include <tt>script.js</tt>\n     * from {@link ConsoleAnnotatorFactory}s and {@link ConsoleAnnotationDescriptor}s.\n     */\n    public static String generateConsoleAnnotationScriptAndStylesheet() {\n        String cp = Stapler.getCurrentRequest().getContextPath();\n        StringBuilder buf = new StringBuilder();\n        for (ConsoleAnnotatorFactory f : ConsoleAnnotatorFactory.all()) {\n            String path = cp + \"/extensionList/\" + ConsoleAnnotatorFactory.class.getName() + \"/\" + f.getClass().getName();\n            if (f.hasScript())\n                buf.append(\"<script src='\"+path+\"/script.js'></script>\");\n            if (f.hasStylesheet())\n                buf.append(\"<link rel='stylesheet' type='text/css' href='\"+path+\"/style.css' />\");\n        }\n        for (ConsoleAnnotationDescriptor d : ConsoleAnnotationDescriptor.all()) {\n            String path = cp+\"/descriptor/\"+d.clazz.getName();\n            if (d.hasScript())\n                buf.append(\"<script src='\"+path+\"/script.js'></script>\");\n            if (d.hasStylesheet())\n                buf.append(\"<link rel='stylesheet' type='text/css' href='\"+path+\"/style.css' />\");\n        }\n        return buf.toString();\n    }\n\n    /**\n     * Work around for bug 6935026.\n     */\n    public List<String> getLoggerNames() {\n        while (true) {\n            try {\n                List<String> r = new ArrayList<String>();\n                Enumeration<String> e = LogManager.getLogManager().getLoggerNames();\n                while (e.hasMoreElements())\n                    r.add(e.nextElement());\n                return r;\n            } catch (ConcurrentModificationException e) {\n                // retry\n            }\n        }\n    }\n\n    /**\n     * Used by &lt;f:password/> so that we send an encrypted value to the client.\n     */\n    public String getPasswordValue(Object o) {\n        if (o==null)    return null;\n        if (o instanceof Secret)    return ((Secret)o).getEncryptedValue();\n        return o.toString();\n    }\n\n    public List filterDescriptors(Object context, Iterable descriptors) {\n        return DescriptorVisibilityFilter.apply(context,descriptors);\n    }\n    \n    /**\n     * Returns true if we are running unit tests.\n     */\n    public static boolean getIsUnitTest() {\n        return Main.isUnitTest;\n    }\n\n    /**\n     * Returns {@code true} if the {@link Run#ARTIFACTS} permission is enabled,\n     * {@code false} otherwise.\n     *\n     * <p>When the {@link Run#ARTIFACTS} permission is not turned on using the\n     * {@code hudson.security.ArtifactsPermission} system property, this\n     * permission must not be considered to be set to {@code false} for every\n     * user. It must rather be like if the permission doesn't exist at all\n     * (which means that every user has to have an access to the artifacts but\n     * the permission can't be configured in the security screen). Got it?</p>\n     */\n    public static boolean isArtifactsPermissionEnabled() {\n        return Boolean.getBoolean(\"hudson.security.ArtifactsPermission\");\n    }\n\n    /**\n     * Returns {@code true} if the {@link Item#WIPEOUT} permission is enabled,\n     * {@code false} otherwise.\n     *\n     * <p>The \"Wipe Out Workspace\" action available on jobs is controlled by the\n     * {@link Item#BUILD} permission. For some specific projects, however, it is\n     * not acceptable to let users have this possibility, even it they can\n     * trigger builds. As such, when enabling the {@code hudson.security.WipeOutPermission}\n     * system property, a new \"WipeOut\" permission will allow to have greater\n     * control on the \"Wipe Out Workspace\" action.</p>\n     */\n    public static boolean isWipeOutPermissionEnabled() {\n        return Boolean.getBoolean(\"hudson.security.WipeOutPermission\");\n    }\n\n    public static String createRenderOnDemandProxy(JellyContext context, String attributesToCapture) {\n        return Stapler.getCurrentRequest().createJavaScriptProxy(new RenderOnDemandClosure(context,attributesToCapture));\n    }\n\n    public static String getCurrentDescriptorByNameUrl() {\n        return Descriptor.getCurrentDescriptorByNameUrl();\n    }\n    \n    public static String setCurrentDescriptorByNameUrl(String value) {\n        String o = getCurrentDescriptorByNameUrl();\n        Stapler.getCurrentRequest().setAttribute(\"currentDescriptorByNameUrl\", value);\n\n        return o;\n    }\n\n    public static void restoreCurrentDescriptorByNameUrl(String old) {\n        Stapler.getCurrentRequest().setAttribute(\"currentDescriptorByNameUrl\", old);\n    }\n\n    public static List<String> getRequestHeaders(String name) {\n        List<String> r = new ArrayList<String>();\n        Enumeration e = Stapler.getCurrentRequest().getHeaders(name);\n        while (e.hasMoreElements()) {\n            r.add(e.nextElement().toString());\n        }\n        return r;\n    }\n\n    /**\n     * Used for arguments to internationalized expressions to avoid escape\n     */\n    public static Object rawHtml(Object o) {\n        return o==null ? null : new RawHtmlArgument(o);\n    }\n\n    public static ArrayList<CLICommand> getCLICommands() {\n        ArrayList<CLICommand> all = new ArrayList<CLICommand>(CLICommand.all());\n        Collections.sort(all, new Comparator<CLICommand>() {\n            public int compare(CLICommand cliCommand, CLICommand cliCommand1) {\n                return cliCommand.getName().compareTo(cliCommand1.getName());\n            }\n        });\n        return all;\n    }\n\n    /**\n     * Returns an avatar image URL for the specified user and preferred image size\n     * @param user the user\n     * @param avatarSize the preferred size of the avatar image\n     * @return a URL string\n     * @since 1.433\n     */\n    public static String getAvatar(User user, String avatarSize) {\n        return UserAvatarResolver.resolve(user, avatarSize);\n    }\n\n    /**\n     * @deprecated as of 1.451\n     *      Use {@link #getAvatar}\n     */\n    public String getUserAvatar(User user, String avatarSize) {\n        return getAvatar(user,avatarSize);\n    }\n    \n    \n    /**\n     * Returns human readable information about file size\n     * \n     * @param file size in bytes\n     * @return file size in appropriate unit\n     */\n    public static String humanReadableByteSize(long size){\n        String measure = \"B\";\n        if(size < 1024){\n            return size + \" \" + measure;\n        }\n        Double number = new Double(size);\n        if(number>=1024){\n            number = number/1024;\n            measure = \"KB\";\n            if(number>=1024){\n                number = number/1024;\n                measure = \"MB\";\n                if(number>=1024){\n                    number=number/1024;\n                    measure = \"GB\";\n                }\n            }\n        }\n        DecimalFormat format = new DecimalFormat(\"#0.00\");\n        return format.format(number) + \" \" + measure;\n    }\n}\n", "/*\n * The MIT License\n * \n * Copyright (c) 2004-2011, Sun Microsystems, Inc., Kohsuke Kawaguchi, Tom Huybrechts,\n * Yahoo!, Inc.\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.model;\n\nimport com.thoughtworks.xstream.converters.ConversionException;\nimport com.thoughtworks.xstream.io.StreamException;\nimport com.thoughtworks.xstream.io.xml.XppDriver;\nimport hudson.DescriptorExtensionList;\nimport hudson.ExtensionPoint;\nimport hudson.Functions;\nimport hudson.Indenter;\nimport hudson.Util;\nimport hudson.model.Descriptor.FormException;\nimport hudson.model.labels.LabelAtomPropertyDescriptor;\nimport hudson.scm.ChangeLogSet;\nimport hudson.scm.ChangeLogSet.Entry;\nimport hudson.search.CollectionSearchIndex;\nimport hudson.search.SearchIndexBuilder;\nimport hudson.security.ACL;\nimport hudson.security.AccessControlled;\nimport hudson.security.Permission;\nimport hudson.security.PermissionGroup;\nimport hudson.security.PermissionScope;\nimport hudson.tasks.UserAvatarResolver;\nimport hudson.util.AlternativeUiTextProvider;\nimport hudson.util.AlternativeUiTextProvider.Message;\nimport hudson.util.DescribableList;\nimport hudson.util.DescriptorList;\nimport hudson.util.FormApply;\nimport hudson.util.IOException2;\nimport hudson.util.RunList;\nimport hudson.util.XStream2;\nimport hudson.views.ListViewColumn;\nimport hudson.widgets.Widget;\nimport jenkins.model.Jenkins;\nimport jenkins.util.ProgressiveRendering;\nimport net.sf.json.JSON;\nimport net.sf.json.JSONArray;\nimport net.sf.json.JSONObject;\nimport org.kohsuke.stapler.HttpResponse;\nimport org.kohsuke.stapler.HttpResponses;\nimport org.kohsuke.stapler.Stapler;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\nimport org.kohsuke.stapler.WebMethod;\nimport org.kohsuke.stapler.export.Exported;\nimport org.kohsuke.stapler.export.ExportedBean;\nimport org.kohsuke.stapler.interceptor.RequirePOST;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.StringWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;\nimport static jenkins.model.Jenkins.*;\nimport org.kohsuke.accmod.Restricted;\nimport org.kohsuke.accmod.restrictions.NoExternalUse;\n\n/**\n * Encapsulates the rendering of the list of {@link TopLevelItem}s\n * that {@link Jenkins} owns.\n *\n * <p>\n * This is an extension point in Hudson, allowing different kind of\n * rendering to be added as plugins.\n *\n * <h2>Note for implementors</h2>\n * <ul>\n * <li>\n * {@link View} subtypes need the <tt>newViewDetail.jelly</tt> page,\n * which is included in the \"new view\" page. This page should have some\n * description of what the view is about. \n * </ul>\n *\n * @author Kohsuke Kawaguchi\n * @see ViewDescriptor\n * @see ViewGroup\n */\n@ExportedBean\npublic abstract class View extends AbstractModelObject implements AccessControlled, Describable<View>, ExtensionPoint, Saveable {\n\n    /**\n     * Container of this view. Set right after the construction\n     * and never change thereafter.\n     */\n    protected /*final*/ ViewGroup owner;\n\n    /**\n     * Name of this view.\n     */\n    protected String name;\n\n    /**\n     * Message displayed in the view page.\n     */\n    protected String description;\n    \n    /**\n     * If true, only show relevant executors\n     */\n    protected boolean filterExecutors;\n\n    /**\n     * If true, only show relevant queue items\n     */\n    protected boolean filterQueue;\n    \n    protected transient List<Action> transientActions;\n\n    /**\n     * List of {@link ViewProperty}s configured for this view.\n     * @since 1.406\n     */\n    private volatile DescribableList<ViewProperty,ViewPropertyDescriptor> properties = new PropertyList(this);\n\n    protected View(String name) {\n        this.name = name;\n    }\n\n    protected View(String name, ViewGroup owner) {\n        this.name = name;\n        this.owner = owner;\n    }\n\n    /**\n     * Gets all the items in this collection in a read-only view.\n     */\n    @Exported(name=\"jobs\")\n    public abstract Collection<TopLevelItem> getItems();\n\n    /**\n     * Gets the {@link TopLevelItem} of the given name.\n     */\n    public TopLevelItem getItem(String name) {\n        return getOwnerItemGroup().getItem(name);\n    }\n\n    /**\n     * Alias for {@link #getItem(String)}. This is the one used in the URL binding.\n     */\n    public final TopLevelItem getJob(String name) {\n        return getItem(name);\n    }\n\n    /**\n     * Checks if the job is in this collection.\n     */\n    public abstract boolean contains(TopLevelItem item);\n\n    /**\n     * Gets the name of all this collection.\n     *\n     * @see #rename(String)\n     */\n    @Exported(visibility=2,name=\"name\")\n    public String getViewName() {\n        return name;\n    }\n\n    /**\n     * Renames this view.\n     */\n    public void rename(String newName) throws Failure, FormException {\n        if(name.equals(newName))    return; // noop\n        checkGoodName(newName);\n        if(owner.getView(newName)!=null)\n            throw new FormException(Messages.Hudson_ViewAlreadyExists(newName),\"name\");\n        String oldName = name;\n        name = newName;\n        owner.onViewRenamed(this,oldName,newName);\n    }\n\n    /**\n     * Gets the {@link ViewGroup} that this view belongs to.\n     */\n    public ViewGroup getOwner() {\n        return owner;\n    }\n\n    /**\n     * Backward-compatible way of getting {@code getOwner().getItemGroup()}\n     */\n    public ItemGroup<? extends TopLevelItem> getOwnerItemGroup() {\n        try {\n            return _getOwnerItemGroup();\n        } catch (AbstractMethodError e) {\n            return Hudson.getInstance();\n        }\n    }\n\n    /**\n     * A pointless function to work around what appears to be a HotSpot problem. See JENKINS-5756 and bug 6933067\n     * on BugParade for more details.\n     */\n    private ItemGroup<? extends TopLevelItem> _getOwnerItemGroup() {\n        return owner.getItemGroup();\n    }\n\n    public View getOwnerPrimaryView() {\n        try {\n            return _getOwnerPrimaryView();\n        } catch (AbstractMethodError e) {\n            return null;\n        }\n    }\n\n    private View _getOwnerPrimaryView() {\n        return owner.getPrimaryView();\n    }\n\n    public List<Action> getOwnerViewActions() {\n        try {\n            return _getOwnerViewActions();\n        } catch (AbstractMethodError e) {\n            return Hudson.getInstance().getActions();\n        }\n    }\n\n    private List<Action> _getOwnerViewActions() {\n        return owner.getViewActions();\n    }\n\n    /**\n     * Message displayed in the top page. Can be null. Includes HTML.\n     */\n    @Exported\n    public String getDescription() {\n        return description;\n    }\n    \n    /**\n     * Gets the view properties configured for this view.\n     * @since 1.406\n     */\n    public DescribableList<ViewProperty,ViewPropertyDescriptor> getProperties() {\n        // readResolve was the best place to do this, but for compatibility reasons,\n        // this class can no longer have readResolve() (the mechanism itself isn't suitable for class hierarchy)\n        // see JENKINS-9431\n        //\n        // until we have that, putting this logic here.\n        synchronized (PropertyList.class) {\n            if (properties == null) {\n                properties = new PropertyList(this);\n            } else {\n                properties.setOwner(this);\n            }\n            return properties;\n        }\n    }\n\n    /**\n     * Returns all the {@link LabelAtomPropertyDescriptor}s that can be potentially configured\n     * on this label.\n     */\n    public List<ViewPropertyDescriptor> getApplicablePropertyDescriptors() {\n        List<ViewPropertyDescriptor> r = new ArrayList<ViewPropertyDescriptor>();\n        for (ViewPropertyDescriptor pd : ViewProperty.all()) {\n            if (pd.isEnabledFor(this))\n                r.add(pd);\n        }\n        return r;\n    }\n\n    public void save() throws IOException {\n        // persistence is a part of the owner\n        // due to initialization timing issue, it can be null when this method is called\n        if (owner != null) {\n            owner.save();\n        }\n    }\n\n    /**\n     * List of all {@link ViewProperty}s exposed primarily for the remoting API.\n     * @since 1.406\n     */\n    @Exported(name=\"property\",inline=true)\n    public List<ViewProperty> getAllProperties() {\n        return getProperties().toList();\n    }\n\n    public ViewDescriptor getDescriptor() {\n        return (ViewDescriptor) Jenkins.getInstance().getDescriptorOrDie(getClass());\n    }\n\n    public String getDisplayName() {\n        return getViewName();\n    }\n\n    public String getNewPronoun() {\n        return AlternativeUiTextProvider.get(NEW_PRONOUN, this, Messages.AbstractItem_Pronoun());\n    }\n\n    /**\n     * By default, return true to render the \"Edit view\" link on the page.\n     * This method is really just for the default \"All\" view to hide the edit link\n     * so that the default Hudson top page remains the same as before 1.316.\n     *\n     * @since 1.316\n     */\n    public boolean isEditable() {\n        return true;\n    }\n    \n    /**\n     * If true, only show relevant executors\n     */\n    public boolean isFilterExecutors() {\n        return filterExecutors;\n    }\n    \n    /**\n     * If true, only show relevant queue items\n     */\n    public boolean isFilterQueue() {\n        return filterQueue;\n    }\n\n    /**\n     * Gets the {@link Widget}s registered on this object.\n     *\n     * <p>\n     * For now, this just returns the widgets registered to Hudson.\n     */\n    public List<Widget> getWidgets() {\n        return Collections.unmodifiableList(Jenkins.getInstance().getWidgets());\n    }\n\n    /**\n     * If this view uses &lt;t:projectView> for rendering, this method returns columns to be displayed.\n     */\n    public Iterable<? extends ListViewColumn> getColumns() {\n        return ListViewColumn.createDefaultInitialColumnList();\n    }\n\n    /**\n     * If this view uses &lt;t:projectView> for rendering, this method returns the indenter used\n     * to indent each row.\n     */\n    public Indenter getIndenter() {\n        return null;\n    }\n\n    /**\n     * If true, this is a view that renders the top page of Hudson.\n     */\n    public boolean isDefault() {\n        return getOwnerPrimaryView()==this;\n    }\n    \n    public List<Computer> getComputers() {\n        Computer[] computers = Jenkins.getInstance().getComputers();\n\n        if (!isFilterExecutors()) {\n            return Arrays.asList(computers);\n        }\n\n        List<Computer> result = new ArrayList<Computer>();\n\n        HashSet<Label> labels = new HashSet<Label>();\n        for (Item item : getItems()) {\n            if (item instanceof AbstractProject<?, ?>) {\n                labels.addAll(((AbstractProject<?, ?>) item).getRelevantLabels());\n            }\n        }\n\n        for (Computer c : computers) {\n            Node n = c.getNode();\n            if (n != null) {\n                if (labels.contains(null) && n.getMode() == Mode.NORMAL || !isDisjoint(n.getAssignedLabels(), labels)) {\n                    result.add(c);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    private boolean isDisjoint(Collection c1, Collection c2) {\n        for (Object o : c1)\n            if (c2.contains(o))\n                return false;\n        return true;\n    }\n\n    private List<Queue.Item> filterQueue(List<Queue.Item> base) {\n        if (!isFilterQueue()) {\n            return base;\n        }\n\n        Collection<TopLevelItem> items = getItems();\n        List<Queue.Item> result = new ArrayList<Queue.Item>();\n        for (Queue.Item qi : base) {\n            if (items.contains(qi.task)) {\n                result.add(qi);\n            } else\n            if (qi.task instanceof AbstractProject<?, ?>) {\n                AbstractProject<?,?> project = (AbstractProject<?, ?>) qi.task;\n                if (items.contains(project.getRootProject())) {\n                    result.add(qi);\n                }\n            }\n        }\n        return result;\n    }\n\n    public List<Queue.Item> getQueueItems() {\n        return filterQueue(Arrays.asList(Jenkins.getInstance().getQueue().getItems()));\n    }\n\n    public List<Queue.Item> getApproximateQueueItemsQuickly() {\n        return filterQueue(Jenkins.getInstance().getQueue().getApproximateItemsQuickly());\n    }\n\n    /**\n     * Returns the path relative to the context root.\n     *\n     * Doesn't start with '/' but ends with '/' (except returns\n     * empty string when this is the default view).\n     */\n    public String getUrl() {\n        return isDefault() ? (owner!=null ? owner.getUrl() : \"\") : getViewUrl();\n    }\n\n    /**\n     * Same as {@link #getUrl()} except this returns a view/{name} path\n     * even for the default view.\n     */\n    public String getViewUrl() {\n        return (owner!=null ? owner.getUrl() : \"\") + \"view/\" + Util.rawEncode(getViewName()) + '/';\n    }\n\n    public String getSearchUrl() {\n        return getUrl();\n    }\n\n    /**\n     * Returns the transient {@link Action}s associated with the top page.\n     *\n     * <p>\n     * If views don't want to show top-level actions, this method\n     * can be overridden to return different objects.\n     *\n     * @see Jenkins#getActions()\n     */\n    public List<Action> getActions() {\n    \tList<Action> result = new ArrayList<Action>();\n    \tresult.addAll(getOwnerViewActions());\n    \tsynchronized (this) {\n    \t\tif (transientActions == null) {\n                updateTransientActions();\n    \t\t}\n    \t\tresult.addAll(transientActions);\n    \t}\n    \treturn result;\n    }\n    \n    public synchronized void updateTransientActions() {\n        transientActions = TransientViewActionFactory.createAllFor(this); \n    }\n    \n    public Object getDynamic(String token) {\n        for (Action a : getActions()) {\n            String url = a.getUrlName();\n            if (url==null)  continue;\n            if(a.getUrlName().equals(token))\n                return a;\n        }\n        return null;\n    }\n\n    /**\n     * Gets the absolute URL of this view.\n     */\n    @Exported(visibility=2,name=\"url\")\n    public String getAbsoluteUrl() {\n        return Jenkins.getInstance().getRootUrl()+getUrl();\n    }\n\n    public Api getApi() {\n        return new Api(this);\n    }\n\n    /**\n     * Returns the page to redirect the user to, after the view is created.\n     *\n     * The returned string is appended to \"/view/foobar/\", so for example\n     * to direct the user to the top page of the view, return \"\", etc.\n     */\n    public String getPostConstructLandingPage() {\n        return \"configure\";\n    }\n\n    /**\n     * Returns the {@link ACL} for this object.\n     */\n    public ACL getACL() {\n        return Jenkins.getInstance().getAuthorizationStrategy().getACL(this);\n    }\n\n    public void checkPermission(Permission p) {\n        getACL().checkPermission(p);\n    }\n\n    public boolean hasPermission(Permission p) {\n        return getACL().hasPermission(p);\n    }\n\n    /**\n     * Called when a job name is changed or deleted.\n     *\n     * <p>\n     * If this view contains this job, it should update the view membership so that\n     * the renamed job will remain in the view, and the deleted job is removed.\n     *\n     * @param item\n     *      The item whose name is being changed.\n     * @param oldName\n     *      Old name of the item. Always non-null.\n     * @param newName\n     *      New name of the item, if the item is renamed. Or null, if the item is removed.\n     */\n    public abstract void onJobRenamed(Item item, String oldName, String newName);\n\n    @ExportedBean(defaultVisibility=2)\n    public static final class UserInfo implements Comparable<UserInfo> {\n        private final User user;\n        /**\n         * When did this user made a last commit on any of our projects? Can be null.\n         */\n        private Calendar lastChange;\n        /**\n         * Which project did this user commit? Can be null.\n         */\n        private AbstractProject project;\n\n        /** @see UserAvatarResolver */\n        String avatar;\n\n        UserInfo(User user, AbstractProject p, Calendar lastChange) {\n            this.user = user;\n            this.project = p;\n            this.lastChange = lastChange;\n        }\n\n        @Exported\n        public User getUser() {\n            return user;\n        }\n\n        @Exported\n        public Calendar getLastChange() {\n            return lastChange;\n        }\n\n        @Exported\n        public AbstractProject getProject() {\n            return project;\n        }\n\n        /**\n         * Returns a human-readable string representation of when this user was last active.\n         */\n        public String getLastChangeTimeString() {\n            if(lastChange==null)    return \"N/A\";\n            long duration = new GregorianCalendar().getTimeInMillis()- ordinal();\n            return Util.getTimeSpanString(duration);\n        }\n\n        public String getTimeSortKey() {\n            if(lastChange==null)    return \"-\";\n            return Util.XS_DATETIME_FORMATTER.format(lastChange.getTime());\n        }\n\n        public int compareTo(UserInfo that) {\n            long rhs = that.ordinal();\n            long lhs = this.ordinal();\n            if(rhs>lhs) return 1;\n            if(rhs<lhs) return -1;\n            return 0;\n        }\n\n        private long ordinal() {\n            if(lastChange==null)    return 0;\n            return lastChange.getTimeInMillis();\n        }\n    }\n\n    /**\n     * Does this {@link View} has any associated user information recorded?\n     * @deprecated Potentially very expensive call; do not use from Jelly views.\n     */\n    public boolean hasPeople() {\n        return People.isApplicable(getItems());\n    }\n\n    /**\n     * Gets the users that show up in the changelog of this job collection.\n     */\n    public People getPeople() {\n        return new People(this);\n    }\n\n    /**\n     * @since 1.484\n     */\n    public AsynchPeople getAsynchPeople() {\n        return new AsynchPeople(this);\n    }\n\n    @ExportedBean\n    public static final class People  {\n        @Exported\n        public final List<UserInfo> users;\n\n        public final ModelObject parent;\n\n        public People(Jenkins parent) {\n            this.parent = parent;\n            // for Hudson, really load all users\n            Map<User,UserInfo> users = getUserInfo(parent.getItems());\n            User unknown = User.getUnknown();\n            for (User u : User.getAll()) {\n                if(u==unknown)  continue;   // skip the special 'unknown' user\n                if(!users.containsKey(u))\n                    users.put(u,new UserInfo(u,null,null));\n            }\n            this.users = toList(users);\n        }\n\n        public People(View parent) {\n            this.parent = parent;\n            this.users = toList(getUserInfo(parent.getItems()));\n        }\n\n        private Map<User,UserInfo> getUserInfo(Collection<? extends Item> items) {\n            Map<User,UserInfo> users = new HashMap<User,UserInfo>();\n            for (Item item : items) {\n                for (Job job : item.getAllJobs()) {\n                    if (job instanceof AbstractProject) {\n                        AbstractProject<?,?> p = (AbstractProject) job;\n                        for (AbstractBuild<?,?> build : p.getBuilds()) {\n                            for (Entry entry : build.getChangeSet()) {\n                                User user = entry.getAuthor();\n\n                                UserInfo info = users.get(user);\n                                if(info==null)\n                                    users.put(user,new UserInfo(user,p,build.getTimestamp()));\n                                else\n                                if(info.getLastChange().before(build.getTimestamp())) {\n                                    info.project = p;\n                                    info.lastChange = build.getTimestamp();\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            return users;\n        }\n\n        private List<UserInfo> toList(Map<User,UserInfo> users) {\n            ArrayList<UserInfo> list = new ArrayList<UserInfo>();\n            list.addAll(users.values());\n            Collections.sort(list);\n            return Collections.unmodifiableList(list);\n        }\n\n        public Api getApi() {\n            return new Api(this);\n        }\n\n        /**\n         * @deprecated Potentially very expensive call; do not use from Jelly views.\n         */\n        public static boolean isApplicable(Collection<? extends Item> items) {\n            for (Item item : items) {\n                for (Job job : item.getAllJobs()) {\n                    if (job instanceof AbstractProject) {\n                        AbstractProject<?,?> p = (AbstractProject) job;\n                        for (AbstractBuild<?,?> build : p.getBuilds()) {\n                            for (Entry entry : build.getChangeSet()) {\n                                User user = entry.getAuthor();\n                                if(user!=null)\n                                    return true;\n                            }\n                        }\n                    }\n                }\n            }\n            return false;\n        }\n    }\n\n    /**\n     * Variant of {@link People} which can be displayed progressively, since it may be slow.\n     * @since 1.484\n     */\n    public static final class AsynchPeople extends ProgressiveRendering { // JENKINS-15206\n\n        private final Collection<TopLevelItem> items;\n        private final User unknown;\n        private final Map<User,UserInfo> users = new HashMap<User,UserInfo>();\n        private final Set<User> modified = new HashSet<User>();\n        private final String iconSize;\n        public final ModelObject parent;\n\n        /** @see Jenkins#getAsynchPeople} */\n        public AsynchPeople(Jenkins parent) {\n            this.parent = parent;\n            items = parent.getItems();\n            unknown = User.getUnknown();\n        }\n\n        /** @see View#getAsynchPeople */\n        public AsynchPeople(View parent) {\n            this.parent = parent;\n            items = parent.getItems();\n            unknown = null;\n        }\n\n        {\n            StaplerRequest req = Stapler.getCurrentRequest();\n            iconSize = req != null ? Functions.validateIconSize(Functions.getCookie(req, \"iconSize\", \"32x32\")) : \"32x32\";\n        }\n\n        @Override protected void compute() throws Exception {\n            int itemCount = 0;\n            for (Item item : items) {\n                for (Job<?,?> job : item.getAllJobs()) {\n                    if (job instanceof AbstractProject) {\n                        AbstractProject<?,?> p = (AbstractProject) job;\n                        RunList<? extends AbstractBuild<?,?>> builds = p.getBuilds();\n                        int buildCount = 0;\n                        for (AbstractBuild<?,?> build : builds) {\n                            if (canceled()) {\n                                return;\n                            }\n                            for (ChangeLogSet.Entry entry : build.getChangeSet()) {\n                                User user = entry.getAuthor();\n                                UserInfo info = users.get(user);\n                                if (info == null) {\n                                    UserInfo userInfo = new UserInfo(user, p, build.getTimestamp());\n                                    userInfo.avatar = UserAvatarResolver.resolve(user, iconSize);\n                                    synchronized (this) {\n                                        users.put(user, userInfo);\n                                        modified.add(user);\n                                    }\n                                } else if (info.getLastChange().before(build.getTimestamp())) {\n                                    synchronized (this) {\n                                        info.project = p;\n                                        info.lastChange = build.getTimestamp();\n                                        modified.add(user);\n                                    }\n                                }\n                            }\n                            // XXX consider also adding the user of the UserCause when applicable\n                            buildCount++;\n                            progress((itemCount + 1.0 * buildCount / builds.size()) / (items.size() + 1));\n                        }\n                    }\n                }\n                itemCount++;\n                progress(1.0 * itemCount / (items.size() + /* handling User.getAll */1));\n            }\n            if (unknown != null) {\n                if (canceled()) {\n                    return;\n                }\n                for (User u : User.getAll()) { // XXX nice to have a method to iterate these lazily\n                    if (u == unknown) {\n                        continue;\n                    }\n                    if (!users.containsKey(u)) {\n                        UserInfo userInfo = new UserInfo(u, null, null);\n                        userInfo.avatar = UserAvatarResolver.resolve(u, iconSize);\n                        synchronized (this) {\n                            users.put(u, userInfo);\n                            modified.add(u);\n                        }\n                    }\n                }\n            }\n        }\n\n        @Override protected synchronized JSON data() {\n            JSONArray r = new JSONArray();\n            for (User u : modified) {\n                UserInfo i = users.get(u);\n                JSONObject entry = new JSONObject().\n                        accumulate(\"id\", u.getId()).\n                        accumulate(\"fullName\", u.getFullName()).\n                        accumulate(\"url\", u.getUrl()).\n                        accumulate(\"avatar\", i.avatar).\n                        accumulate(\"timeSortKey\", i.getTimeSortKey()).\n                        accumulate(\"lastChangeTimeString\", i.getLastChangeTimeString());\n                AbstractProject<?,?> p = i.getProject();\n                if (p != null) {\n                    entry.accumulate(\"projectUrl\", p.getUrl()).accumulate(\"projectFullDisplayName\", p.getFullDisplayName());\n                }\n                r.add(entry);\n            }\n            modified.clear();\n            return r;\n        }\n\n        public Api getApi() {\n            return new Api(new People());\n        }\n\n        /** JENKINS-16397 workaround */\n        @Restricted(NoExternalUse.class)\n        @ExportedBean\n        public final class People {\n\n            private View.People people;\n\n            @Exported public synchronized List<UserInfo> getUsers() {\n                if (people == null) {\n                    people = parent instanceof Jenkins ? new View.People((Jenkins) parent) : new View.People((View) parent);\n                }\n                return people.users;\n            }\n        }\n\n    }\n\n    void addDisplayNamesToSearchIndex(SearchIndexBuilder sib, Collection<TopLevelItem> items) {\n        for(TopLevelItem item : items) {\n            \n            if(LOGGER.isLoggable(Level.FINE)) {\n                LOGGER.fine((String.format(\"Adding url=%s,displayName=%s\",\n                            item.getSearchUrl(), item.getDisplayName())));\n            }\n            sib.add(item.getSearchUrl(), item.getDisplayName());\n        }        \n    }\n    \n    @Override\n    public SearchIndexBuilder makeSearchIndex() {\n        SearchIndexBuilder sib = super.makeSearchIndex();\n        sib.add(new CollectionSearchIndex<TopLevelItem>() {// for jobs in the view\n                protected TopLevelItem get(String key) { return getItem(key); }\n                protected Collection<TopLevelItem> all() { return getItems(); }                \n                @Override\n                protected String getName(TopLevelItem o) {\n                    // return the name instead of the display for suggestion searching\n                    return o.getName();\n                }\n            });\n        \n        // add the display name for each item in the search index\n        addDisplayNamesToSearchIndex(sib, getItems());\n\n        return sib;\n    }\n\n    /**\n     * Accepts the new description.\n     */\n    public synchronized void doSubmitDescription( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        checkPermission(CONFIGURE);\n\n        description = req.getParameter(\"description\");\n        save();\n        rsp.sendRedirect(\".\");  // go to the top page\n    }\n\n    /**\n     * Accepts submission from the configuration page.\n     *\n     * Subtypes should override the {@link #submit(StaplerRequest)} method.\n     */\n    @RequirePOST\n    public final synchronized void doConfigSubmit( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException, FormException {\n        checkPermission(CONFIGURE);\n\n        submit(req);\n\n        description = Util.nullify(req.getParameter(\"description\"));\n        filterExecutors = req.getParameter(\"filterExecutors\") != null;\n        filterQueue = req.getParameter(\"filterQueue\") != null;\n\n        rename(req.getParameter(\"name\"));\n\n        getProperties().rebuild(req, req.getSubmittedForm(), getApplicablePropertyDescriptors());\n        updateTransientActions();  \n\n        save();\n\n        FormApply.success(\"../\"+name).generateResponse(req,rsp,this);\n    }\n\n    /**\n     * Handles the configuration submission.\n     *\n     * Load view-specific properties here.\n     */\n    protected abstract void submit(StaplerRequest req) throws IOException, ServletException, FormException;\n\n    /**\n     * Deletes this view.\n     */\n    @RequirePOST\n    public synchronized void doDoDelete(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        checkPermission(DELETE);\n\n        owner.deleteView(this);\n\n        rsp.sendRedirect2(req.getContextPath()+\"/\" + owner.getUrl());\n    }\n\n\n    /**\n     * Creates a new {@link Item} in this collection.\n     *\n     * <p>\n     * This method should call {@link ModifiableItemGroup#doCreateItem(StaplerRequest, StaplerResponse)}\n     * and then add the newly created item to this view.\n     * \n     * @return\n     *      null if fails.\n     */\n    public abstract Item doCreateItem( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException;\n\n    public void doRssAll( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        rss(req, rsp, \" all builds\", getBuilds());\n    }\n\n    public void doRssFailed( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        rss(req, rsp, \" failed builds\", getBuilds().failureOnly());\n    }\n    \n    public RunList getBuilds() {\n        return new RunList(this);\n    }\n    \n    public BuildTimelineWidget getTimeline() {\n        return new BuildTimelineWidget(getBuilds());\n    }\n\n    private void rss(StaplerRequest req, StaplerResponse rsp, String suffix, RunList runs) throws IOException, ServletException {\n        RSS.forwardToRss(getDisplayName()+ suffix, getUrl(),\n            runs.newBuilds(), Run.FEED_ADAPTER, req, rsp );\n    }\n\n    public void doRssLatest( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        List<Run> lastBuilds = new ArrayList<Run>();\n        for (TopLevelItem item : getItems()) {\n            if (item instanceof Job) {\n                Job job = (Job) item;\n                Run lb = job.getLastBuild();\n                if(lb!=null)    lastBuilds.add(lb);\n            }\n        }\n        RSS.forwardToRss(getDisplayName()+\" last builds only\", getUrl(),\n            lastBuilds, Run.FEED_ADAPTER_LATEST, req, rsp );\n    }\n\n    /**\n     * Accepts <tt>config.xml</tt> submission, as well as serve it.\n     */\n    @WebMethod(name = \"config.xml\")\n    public HttpResponse doConfigDotXml(StaplerRequest req) throws IOException {\n        if (req.getMethod().equals(\"GET\")) {\n            // read\n            checkPermission(READ);\n            return new HttpResponse() {\n                public void generateResponse(StaplerRequest req, StaplerResponse rsp, Object node) throws IOException, ServletException {\n                    rsp.setContentType(\"application/xml\");\n                    // pity we don't have a handy way to clone Jenkins.XSTREAM to temp add the omit Field\n                    XStream2 xStream2 = new XStream2();\n                    xStream2.omitField(View.class, \"owner\");\n                    xStream2.toXMLUTF8(this,  rsp.getOutputStream());\n                }\n            };\n        }\n        if (req.getMethod().equals(\"POST\")) {\n            // submission\n            updateByXml((Source)new StreamSource(req.getReader()));\n            return HttpResponses.ok();\n        }\n\n        // huh?\n        return HttpResponses.error(SC_BAD_REQUEST, \"Unexpected request method \" + req.getMethod());\n    }\n\n    /**\n     * Updates Job by its XML definition.\n     */\n    public void updateByXml(Source source) throws IOException {\n        checkPermission(CONFIGURE);\n        StringWriter out = new StringWriter();\n        try {\n            // this allows us to use UTF-8 for storing data,\n            // plus it checks any well-formedness issue in the submitted\n            // data\n            Transformer t = TransformerFactory.newInstance()\n                    .newTransformer();\n            t.transform(source,\n                    new StreamResult(out));\n            out.close();\n        } catch (TransformerException e) {\n            throw new IOException2(\"Failed to persist configuration.xml\", e);\n        }\n\n        // try to reflect the changes by reloading\n        InputStream in = new BufferedInputStream(new ByteArrayInputStream(out.toString().getBytes(\"UTF-8\")));\n        try {\n            Jenkins.XSTREAM.unmarshal(new XppDriver().createReader(in), this);\n        } catch (StreamException e) {\n            throw new IOException2(\"Unable to read\",e);\n        } catch(ConversionException e) {\n            throw new IOException2(\"Unable to read\",e);\n        } catch(Error e) {// mostly reflection errors\n            throw new IOException2(\"Unable to read\",e);\n        } finally {\n            in.close();\n        }\n    }\n\n\n    /**\n     * A list of available view types.\n     * @deprecated as of 1.286\n     *      Use {@link #all()} for read access, and use {@link Extension} for registration.\n     */\n    public static final DescriptorList<View> LIST = new DescriptorList<View>(View.class);\n\n    /**\n     * Returns all the registered {@link ViewDescriptor}s.\n     */\n    public static DescriptorExtensionList<View,ViewDescriptor> all() {\n        return Jenkins.getInstance().<View,ViewDescriptor>getDescriptorList(View.class);\n    }\n\n    public static List<ViewDescriptor> allInstantiable() {\n        List<ViewDescriptor> r = new ArrayList<ViewDescriptor>();\n        for (ViewDescriptor d : all())\n            if(d.isInstantiable())\n                r.add(d);\n        return r;\n    }\n\n    public static final Comparator<View> SORTER = new Comparator<View>() {\n        public int compare(View lhs, View rhs) {\n            return lhs.getViewName().compareTo(rhs.getViewName());\n        }\n    };\n\n    public static final PermissionGroup PERMISSIONS = new PermissionGroup(View.class,Messages._View_Permissions_Title());\n    /**\n     * Permission to create new views.\n     */\n    public static final Permission CREATE = new Permission(PERMISSIONS,\"Create\", Messages._View_CreatePermission_Description(), Permission.CREATE, PermissionScope.ITEM_GROUP);\n    public static final Permission DELETE = new Permission(PERMISSIONS,\"Delete\", Messages._View_DeletePermission_Description(), Permission.DELETE, PermissionScope.ITEM_GROUP);\n    public static final Permission CONFIGURE = new Permission(PERMISSIONS,\"Configure\", Messages._View_ConfigurePermission_Description(), Permission.CONFIGURE, PermissionScope.ITEM_GROUP);\n    public static final Permission READ = new Permission(PERMISSIONS,\"Read\", Messages._View_ReadPermission_Description(), Permission.READ, PermissionScope.ITEM_GROUP);\n\n    // to simplify access from Jelly\n    public static Permission getItemCreatePermission() {\n        return Item.CREATE;\n    }\n    \n    public static View create(StaplerRequest req, StaplerResponse rsp, ViewGroup owner)\n            throws FormException, IOException, ServletException {\n        String requestContentType = req.getContentType();\n        if(requestContentType==null)\n            throw new Failure(\"No Content-Type header set\");\n\n        boolean isXmlSubmission = requestContentType.startsWith(\"application/xml\") || requestContentType.startsWith(\"text/xml\");\n\n        String name = req.getParameter(\"name\");\n        checkGoodName(name);\n        if(owner.getView(name)!=null)\n            throw new FormException(Messages.Hudson_ViewAlreadyExists(name),\"name\");\n\n        String mode = req.getParameter(\"mode\");\n        if (mode==null || mode.length()==0) {\n            if(isXmlSubmission) {\n                View v;\n                v = createViewFromXML(name, req.getInputStream());\n                v.owner = owner;\n                rsp.setStatus(HttpServletResponse.SC_OK);\n                return v;\n            } else\n                throw new FormException(Messages.View_MissingMode(),\"mode\");\n        }\n\n        // create a view\n        View v = all().findByName(mode).newInstance(req,req.getSubmittedForm());\n        v.owner = owner;\n\n        // redirect to the config screen\n        rsp.sendRedirect2(req.getContextPath()+'/'+v.getUrl()+v.getPostConstructLandingPage());\n\n        return v;\n    }\n\n    public static View createViewFromXML(String name, InputStream xml) throws IOException {\n        InputStream in = new BufferedInputStream(xml);\n        try {\n            View v = (View) Jenkins.XSTREAM.fromXML(in);\n            v.name = name;\n            return v;\n        } catch(StreamException e) {\n            throw new IOException2(\"Unable to read\",e);\n        } catch(ConversionException e) {\n            throw new IOException2(\"Unable to read\",e);\n        } catch(Error e) {// mostly reflection errors\n            throw new IOException2(\"Unable to read\",e);\n        } finally {\n            in.close();\n        }\n    }\n\n    public static class PropertyList extends DescribableList<ViewProperty,ViewPropertyDescriptor> {\n        private PropertyList(View owner) {\n            super(owner);\n        }\n\n        public PropertyList() {// needed for XStream deserialization\n        }\n\n        public View getOwner() {\n            return (View)owner;\n        }\n\n        @Override\n        protected void onModified() throws IOException {\n            for (ViewProperty p : this)\n                p.setView(getOwner());\n        }\n    }\n\n    /**\n     * \"Job\" in \"New Job\". When a view is used in a context that restricts the child type,\n     * It might be useful to override this.\n     */\n    public static final Message<View> NEW_PRONOUN = new Message<View>();\n\n    private final static Logger LOGGER = Logger.getLogger(View.class.getName());\n}\n", "/*\n * The MIT License\n *\n * Copyright (c) 2004-2011, Sun Microsystems, Inc., Kohsuke Kawaguchi,\n * Erik Ramfelt, Koichi Fujikawa, Red Hat, Inc., Seiji Sogabe,\n * Stephen Connolly, Tom Huybrechts, Yahoo! Inc., Alan Harder, CloudBees, Inc.,\n * Yahoo!, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage jenkins.model;\n\nimport com.google.common.collect.Lists;\nimport com.google.inject.Injector;\nimport hudson.ExtensionComponent;\nimport hudson.ExtensionFinder;\nimport hudson.model.LoadStatistics;\nimport hudson.model.Messages;\nimport hudson.model.Node;\nimport hudson.model.AbstractCIBase;\nimport hudson.model.AbstractProject;\nimport hudson.model.Action;\nimport hudson.model.AdministrativeMonitor;\nimport hudson.model.AllView;\nimport hudson.model.Api;\nimport hudson.model.Computer;\nimport hudson.model.ComputerSet;\nimport hudson.model.DependencyGraph;\nimport hudson.model.Describable;\nimport hudson.model.Descriptor;\nimport hudson.model.DescriptorByNameOwner;\nimport hudson.model.DirectoryBrowserSupport;\nimport hudson.model.Failure;\nimport hudson.model.Fingerprint;\nimport hudson.model.FingerprintCleanupThread;\nimport hudson.model.FingerprintMap;\nimport hudson.model.FullDuplexHttpChannel;\nimport hudson.model.Hudson;\nimport hudson.model.Item;\nimport hudson.model.ItemGroup;\nimport hudson.model.ItemGroupMixIn;\nimport hudson.model.Items;\nimport hudson.model.JDK;\nimport hudson.model.Job;\nimport hudson.model.JobPropertyDescriptor;\nimport hudson.model.Label;\nimport hudson.model.ListView;\nimport hudson.model.LoadBalancer;\nimport hudson.model.ManagementLink;\nimport hudson.model.NoFingerprintMatch;\nimport hudson.model.OverallLoadStatistics;\nimport hudson.model.Project;\nimport hudson.model.RestartListener;\nimport hudson.model.RootAction;\nimport hudson.model.Slave;\nimport hudson.model.TaskListener;\nimport hudson.model.TopLevelItem;\nimport hudson.model.TopLevelItemDescriptor;\nimport hudson.model.UnprotectedRootAction;\nimport hudson.model.UpdateCenter;\nimport hudson.model.User;\nimport hudson.model.View;\nimport hudson.model.ViewGroup;\nimport hudson.model.ViewGroupMixIn;\nimport hudson.model.Descriptor.FormException;\nimport hudson.model.labels.LabelAtom;\nimport hudson.model.listeners.ItemListener;\nimport hudson.model.listeners.SCMListener;\nimport hudson.model.listeners.SaveableListener;\nimport hudson.model.Queue;\nimport hudson.model.WorkspaceCleanupThread;\n\nimport antlr.ANTLRException;\nimport com.google.common.collect.ImmutableMap;\nimport com.thoughtworks.xstream.XStream;\nimport hudson.BulkChange;\nimport hudson.DNSMultiCast;\nimport hudson.DescriptorExtensionList;\nimport hudson.Extension;\nimport hudson.ExtensionList;\nimport hudson.ExtensionPoint;\nimport hudson.FilePath;\nimport hudson.Functions;\nimport hudson.Launcher;\nimport hudson.Launcher.LocalLauncher;\nimport hudson.LocalPluginManager;\nimport hudson.Lookup;\nimport hudson.markup.MarkupFormatter;\nimport hudson.Plugin;\nimport hudson.PluginManager;\nimport hudson.PluginWrapper;\nimport hudson.ProxyConfiguration;\nimport hudson.TcpSlaveAgentListener;\nimport hudson.UDPBroadcastThread;\nimport hudson.Util;\nimport static hudson.Util.fixEmpty;\nimport static hudson.Util.fixNull;\nimport hudson.WebAppMain;\nimport hudson.XmlFile;\nimport hudson.cli.CLICommand;\nimport hudson.cli.CliEntryPoint;\nimport hudson.cli.CliManagerImpl;\nimport hudson.cli.declarative.CLIMethod;\nimport hudson.cli.declarative.CLIResolver;\nimport hudson.init.InitMilestone;\nimport hudson.init.InitStrategy;\nimport hudson.lifecycle.Lifecycle;\nimport hudson.logging.LogRecorderManager;\nimport hudson.lifecycle.RestartNotSupportedException;\nimport hudson.markup.RawHtmlMarkupFormatter;\nimport hudson.remoting.Channel;\nimport hudson.remoting.LocalChannel;\nimport hudson.remoting.VirtualChannel;\nimport hudson.scm.RepositoryBrowser;\nimport hudson.scm.SCM;\nimport hudson.search.CollectionSearchIndex;\nimport hudson.search.SearchIndexBuilder;\nimport hudson.search.SearchItem;\nimport hudson.security.ACL;\nimport hudson.security.AccessControlled;\nimport hudson.security.AuthorizationStrategy;\nimport hudson.security.FederatedLoginService;\nimport hudson.security.FullControlOnceLoggedInAuthorizationStrategy;\nimport hudson.security.HudsonFilter;\nimport hudson.security.LegacyAuthorizationStrategy;\nimport hudson.security.LegacySecurityRealm;\nimport hudson.security.Permission;\nimport hudson.security.PermissionGroup;\nimport hudson.security.PermissionScope;\nimport hudson.security.SecurityMode;\nimport hudson.security.SecurityRealm;\nimport hudson.security.csrf.CrumbIssuer;\nimport hudson.slaves.Cloud;\nimport hudson.slaves.ComputerListener;\nimport hudson.slaves.DumbSlave;\nimport hudson.slaves.EphemeralNode;\nimport hudson.slaves.NodeDescriptor;\nimport hudson.slaves.NodeList;\nimport hudson.slaves.NodeProperty;\nimport hudson.slaves.NodePropertyDescriptor;\nimport hudson.slaves.NodeProvisioner;\nimport hudson.slaves.OfflineCause;\nimport hudson.slaves.RetentionStrategy;\nimport hudson.tasks.BuildWrapper;\nimport hudson.tasks.Builder;\nimport hudson.tasks.Publisher;\nimport hudson.triggers.SafeTimerTask;\nimport hudson.triggers.Trigger;\nimport hudson.triggers.TriggerDescriptor;\nimport hudson.util.AdministrativeError;\nimport hudson.util.CaseInsensitiveComparator;\nimport hudson.util.ClockDifference;\nimport hudson.util.CopyOnWriteList;\nimport hudson.util.CopyOnWriteMap;\nimport hudson.util.DaemonThreadFactory;\nimport hudson.util.DescribableList;\nimport hudson.util.FormApply;\nimport hudson.util.FormValidation;\nimport hudson.util.Futures;\nimport hudson.util.HudsonIsLoading;\nimport hudson.util.HudsonIsRestarting;\nimport hudson.util.Iterators;\nimport hudson.util.JenkinsReloadFailed;\nimport hudson.util.Memoizer;\nimport hudson.util.MultipartFormDataParser;\nimport hudson.util.RemotingDiagnostics;\nimport hudson.util.RemotingDiagnostics.HeapDump;\nimport hudson.util.StreamTaskListener;\nimport hudson.util.TextFile;\nimport hudson.util.TimeUnit2;\nimport hudson.util.VersionNumber;\nimport hudson.util.XStream2;\nimport hudson.views.DefaultMyViewsTabBar;\nimport hudson.views.DefaultViewsTabBar;\nimport hudson.views.MyViewsTabBar;\nimport hudson.views.ViewsTabBar;\nimport hudson.widgets.Widget;\nimport jenkins.ExtensionComponentSet;\nimport jenkins.ExtensionRefreshException;\nimport jenkins.InitReactorRunner;\nimport jenkins.model.ProjectNamingStrategy.DefaultProjectNamingStrategy;\nimport jenkins.security.ConfidentialKey;\nimport jenkins.security.ConfidentialStore;\nimport jenkins.slaves.WorkspaceLocator;\nimport jenkins.util.io.FileBoolean;\nimport net.sf.json.JSONObject;\nimport org.acegisecurity.AccessDeniedException;\nimport org.acegisecurity.AcegiSecurityException;\nimport org.acegisecurity.Authentication;\nimport org.acegisecurity.GrantedAuthority;\nimport org.acegisecurity.GrantedAuthorityImpl;\nimport org.acegisecurity.context.SecurityContextHolder;\nimport org.acegisecurity.providers.anonymous.AnonymousAuthenticationToken;\nimport org.acegisecurity.ui.AbstractProcessingFilter;\nimport org.apache.commons.jelly.JellyException;\nimport org.apache.commons.jelly.Script;\nimport org.apache.commons.logging.LogFactory;\nimport org.jvnet.hudson.reactor.Executable;\nimport org.jvnet.hudson.reactor.ReactorException;\nimport org.jvnet.hudson.reactor.Task;\nimport org.jvnet.hudson.reactor.TaskBuilder;\nimport org.jvnet.hudson.reactor.TaskGraphBuilder;\nimport org.jvnet.hudson.reactor.Reactor;\nimport org.jvnet.hudson.reactor.TaskGraphBuilder.Handle;\nimport org.kohsuke.accmod.Restricted;\nimport org.kohsuke.accmod.restrictions.NoExternalUse;\nimport org.kohsuke.args4j.Argument;\nimport org.kohsuke.args4j.Option;\nimport org.kohsuke.stapler.Ancestor;\nimport org.kohsuke.stapler.HttpRedirect;\nimport org.kohsuke.stapler.HttpResponse;\nimport org.kohsuke.stapler.HttpResponses;\nimport org.kohsuke.stapler.MetaClass;\nimport org.kohsuke.stapler.QueryParameter;\nimport org.kohsuke.stapler.Stapler;\nimport org.kohsuke.stapler.StaplerFallback;\nimport org.kohsuke.stapler.StaplerProxy;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\nimport org.kohsuke.stapler.WebApp;\nimport org.kohsuke.stapler.export.Exported;\nimport org.kohsuke.stapler.export.ExportedBean;\nimport org.kohsuke.stapler.framework.adjunct.AdjunctManager;\nimport org.kohsuke.stapler.interceptor.RequirePOST;\nimport org.kohsuke.stapler.jelly.JellyClassLoaderTearOff;\nimport org.kohsuke.stapler.jelly.JellyRequestDispatcher;\nimport org.xml.sax.InputSource;\n\nimport javax.crypto.SecretKey;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletResponse;\n\nimport static hudson.init.InitMilestone.*;\nimport hudson.security.BasicAuthenticationFilter;\nimport static javax.servlet.http.HttpServletResponse.SC_BAD_REQUEST;\nimport static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\nimport java.io.File;\nimport java.io.FileFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.net.BindException;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.security.SecureRandom;\nimport java.text.Collator;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport java.util.Timer;\nimport java.util.TreeSet;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.logging.Level;\nimport static java.util.logging.Level.SEVERE;\nimport java.util.logging.LogRecord;\nimport java.util.logging.Logger;\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\n/**\n * Root object of the system.\n *\n * @author Kohsuke Kawaguchi\n */\n@ExportedBean\npublic class Jenkins extends AbstractCIBase implements ModifiableTopLevelItemGroup, StaplerProxy, StaplerFallback, ViewGroup, AccessControlled, DescriptorByNameOwner, ModelObjectWithContextMenu {\n    private transient final Queue queue;\n\n    /**\n     * Stores various objects scoped to {@link Jenkins}.\n     */\n    public transient final Lookup lookup = new Lookup();\n\n    /**\n     * We update this field to the current version of Hudson whenever we save {@code config.xml}.\n     * This can be used to detect when an upgrade happens from one version to next.\n     *\n     * <p>\n     * Since this field is introduced starting 1.301, \"1.0\" is used to represent every version\n     * up to 1.300. This value may also include non-standard versions like \"1.301-SNAPSHOT\" or\n     * \"?\", etc., so parsing needs to be done with a care.\n     *\n     * @since 1.301\n     */\n    // this field needs to be at the very top so that other components can look at this value even during unmarshalling\n    private String version = \"1.0\";\n\n    /**\n     * Number of executors of the master node.\n     */\n    private int numExecutors = 2;\n\n    /**\n     * Job allocation strategy.\n     */\n    private Mode mode = Mode.NORMAL;\n\n    /**\n     * False to enable anyone to do anything.\n     * Left as a field so that we can still read old data that uses this flag.\n     *\n     * @see #authorizationStrategy\n     * @see #securityRealm\n     */\n    private Boolean useSecurity;\n\n    /**\n     * Controls how the\n     * <a href=\"http://en.wikipedia.org/wiki/Authorization\">authorization</a>\n     * is handled in Hudson.\n     * <p>\n     * This ultimately controls who has access to what.\n     *\n     * Never null.\n     */\n    private volatile AuthorizationStrategy authorizationStrategy = AuthorizationStrategy.UNSECURED;\n\n    /**\n     * Controls a part of the\n     * <a href=\"http://en.wikipedia.org/wiki/Authentication\">authentication</a>\n     * handling in Hudson.\n     * <p>\n     * Intuitively, this corresponds to the user database.\n     *\n     * See {@link HudsonFilter} for the concrete authentication protocol.\n     *\n     * Never null. Always use {@link #setSecurityRealm(SecurityRealm)} to\n     * update this field.\n     *\n     * @see #getSecurity()\n     * @see #setSecurityRealm(SecurityRealm)\n     */\n    private volatile SecurityRealm securityRealm = SecurityRealm.NO_AUTHENTICATION;\n    \n    /**\n     * The project naming strategy defines/restricts the names which can be given to a project/job. e.g. does the name have to follow a naming convention?\n     */\n    private ProjectNamingStrategy projectNamingStrategy = DefaultProjectNamingStrategy.DEFAULT_NAMING_STRATEGY;\n\n    /**\n     * Root directory for the workspaces.\n     * This value will be variable-expanded as per {@link #expandVariablesForDirectory}.\n     * @see #getWorkspaceFor(TopLevelItem)\n     */\n    private String workspaceDir = \"${ITEM_ROOTDIR}/\"+WORKSPACE_DIRNAME;\n\n    /**\n     * Root directory for the builds.\n     * This value will be variable-expanded as per {@link #expandVariablesForDirectory}.\n     * @see #getBuildDirFor(Job)\n     */\n    private String buildsDir = \"${ITEM_ROOTDIR}/builds\";\n\n    /**\n     * Message displayed in the top page.\n     */\n    private String systemMessage;\n\n    private MarkupFormatter markupFormatter;\n\n    /**\n     * Root directory of the system.\n     */\n    public transient final File root;\n\n    /**\n     * Where are we in the initialization?\n     */\n    private transient volatile InitMilestone initLevel = InitMilestone.STARTED;\n\n    /**\n     * All {@link Item}s keyed by their {@link Item#getName() name}s.\n     */\n    /*package*/ transient final Map<String,TopLevelItem> items = new CopyOnWriteMap.Tree<String,TopLevelItem>(CaseInsensitiveComparator.INSTANCE);\n\n    /**\n     * The sole instance.\n     */\n    private static Jenkins theInstance;\n\n    private transient volatile boolean isQuietingDown;\n    private transient volatile boolean terminating;\n\n    private List<JDK> jdks = new ArrayList<JDK>();\n\n    private transient volatile DependencyGraph dependencyGraph;\n\n    /**\n     * Currently active Views tab bar.\n     */\n    private volatile ViewsTabBar viewsTabBar = new DefaultViewsTabBar();\n\n    /**\n     * Currently active My Views tab bar.\n     */\n    private volatile MyViewsTabBar myViewsTabBar = new DefaultMyViewsTabBar();\n\n    /**\n     * All {@link ExtensionList} keyed by their {@link ExtensionList#extensionType}.\n     */\n    private transient final Memoizer<Class,ExtensionList> extensionLists = new Memoizer<Class,ExtensionList>() {\n        public ExtensionList compute(Class key) {\n            return ExtensionList.create(Jenkins.this,key);\n        }\n    };\n\n    /**\n     * All {@link DescriptorExtensionList} keyed by their {@link DescriptorExtensionList#describableType}.\n     */\n    private transient final Memoizer<Class,DescriptorExtensionList> descriptorLists = new Memoizer<Class,DescriptorExtensionList>() {\n        public DescriptorExtensionList compute(Class key) {\n            return DescriptorExtensionList.createDescriptorList(Jenkins.this,key);\n        }\n    };\n\n    /**\n     * {@link Computer}s in this Hudson system. Read-only.\n     */\n    protected transient final Map<Node,Computer> computers = new CopyOnWriteMap.Hash<Node,Computer>();\n\n    /**\n     * Active {@link Cloud}s.\n     */\n    public final Hudson.CloudList clouds = new Hudson.CloudList(this);\n\n    public static class CloudList extends DescribableList<Cloud,Descriptor<Cloud>> {\n        public CloudList(Jenkins h) {\n            super(h);\n        }\n\n        public CloudList() {// needed for XStream deserialization\n        }\n\n        public Cloud getByName(String name) {\n            for (Cloud c : this)\n                if (c.name.equals(name))\n                    return c;\n            return null;\n        }\n\n        @Override\n        protected void onModified() throws IOException {\n            super.onModified();\n            Jenkins.getInstance().trimLabels();\n        }\n    }\n\n    /**\n     * Set of installed cluster nodes.\n     * <p>\n     * We use this field with copy-on-write semantics.\n     * This field has mutable list (to keep the serialization look clean),\n     * but it shall never be modified. Only new completely populated slave\n     * list can be set here.\n     * <p>\n     * The field name should be really {@code nodes}, but again the backward compatibility\n     * prevents us from renaming.\n     */\n    protected volatile NodeList slaves;\n\n    /**\n     * Quiet period.\n     *\n     * This is {@link Integer} so that we can initialize it to '5' for upgrading users.\n     */\n    /*package*/ Integer quietPeriod;\n\n    /**\n     * Global default for {@link AbstractProject#getScmCheckoutRetryCount()}\n     */\n    /*package*/ int scmCheckoutRetryCount;\n\n    /**\n     * {@link View}s.\n     */\n    private final CopyOnWriteArrayList<View> views = new CopyOnWriteArrayList<View>();\n\n    /**\n     * Name of the primary view.\n     * <p>\n     * Start with null, so that we can upgrade pre-1.269 data well.\n     * @since 1.269\n     */\n    private volatile String primaryView;\n\n    private transient final ViewGroupMixIn viewGroupMixIn = new ViewGroupMixIn(this) {\n        protected List<View> views() { return views; }\n        protected String primaryView() { return primaryView; }\n        protected void primaryView(String name) { primaryView=name; }\n    };\n\n\n    private transient final FingerprintMap fingerprintMap = new FingerprintMap();\n\n    /**\n     * Loaded plugins.\n     */\n    public transient final PluginManager pluginManager;\n\n    public transient volatile TcpSlaveAgentListener tcpSlaveAgentListener;\n\n    private transient UDPBroadcastThread udpBroadcastThread;\n\n    private transient DNSMultiCast dnsMultiCast;\n\n    /**\n     * List of registered {@link SCMListener}s.\n     */\n    private transient final CopyOnWriteList<SCMListener> scmListeners = new CopyOnWriteList<SCMListener>();\n\n    /**\n     * TCP slave agent port.\n     * 0 for random, -1 to disable.\n     */\n    private int slaveAgentPort =0;\n\n    /**\n     * Whitespace-separated labels assigned to the master as a {@link Node}.\n     */\n    private String label=\"\";\n\n    /**\n     * {@link hudson.security.csrf.CrumbIssuer}\n     */\n    private volatile CrumbIssuer crumbIssuer;\n\n    /**\n     * All labels known to Jenkins. This allows us to reuse the same label instances\n     * as much as possible, even though that's not a strict requirement.\n     */\n    private transient final ConcurrentHashMap<String,Label> labels = new ConcurrentHashMap<String,Label>();\n\n    /**\n     * Load statistics of the entire system.\n     *\n     * This includes every executor and every job in the system.\n     */\n    @Exported\n    public transient final OverallLoadStatistics overallLoad = new OverallLoadStatistics();\n\n    /**\n     * Load statistics of the free roaming jobs and slaves.\n     * \n     * This includes all executors on {@link Mode#NORMAL} nodes and jobs that do not have any assigned nodes.\n     *\n     * @since 1.467\n     */\n    @Exported\n    public transient final LoadStatistics unlabeledLoad = new UnlabeledLoadStatistics();\n\n    /**\n     * {@link NodeProvisioner} that reacts to {@link #unlabeledLoad}.\n     * @since 1.467\n     */\n    public transient final NodeProvisioner unlabeledNodeProvisioner = new NodeProvisioner(null,unlabeledLoad);\n\n    /**\n     * @deprecated as of 1.467\n     *      Use {@link #unlabeledNodeProvisioner}.\n     *      This was broken because it was tracking all the executors in the system, but it was only tracking\n     *      free-roaming jobs in the queue. So {@link Cloud} fails to launch nodes when you have some exclusive\n     *      slaves and free-roaming jobs in the queue.\n     */\n    @Restricted(NoExternalUse.class)\n    public transient final NodeProvisioner overallNodeProvisioner = unlabeledNodeProvisioner;\n\n\n    public transient final ServletContext servletContext;\n\n    /**\n     * Transient action list. Useful for adding navigation items to the navigation bar\n     * on the left.\n     */\n    private transient final List<Action> actions = new CopyOnWriteArrayList<Action>();\n\n    /**\n     * List of master node properties\n     */\n    private DescribableList<NodeProperty<?>,NodePropertyDescriptor> nodeProperties = new DescribableList<NodeProperty<?>,NodePropertyDescriptor>(this);\n\n    /**\n     * List of global properties\n     */\n    private DescribableList<NodeProperty<?>,NodePropertyDescriptor> globalNodeProperties = new DescribableList<NodeProperty<?>,NodePropertyDescriptor>(this);\n\n    /**\n     * {@link AdministrativeMonitor}s installed on this system.\n     *\n     * @see AdministrativeMonitor\n     */\n    public transient final List<AdministrativeMonitor> administrativeMonitors = getExtensionList(AdministrativeMonitor.class);\n\n    /**\n     * Widgets on Hudson.\n     */\n    private transient final List<Widget> widgets = getExtensionList(Widget.class);\n\n    /**\n     * {@link AdjunctManager}\n     */\n    private transient final AdjunctManager adjuncts;\n\n    /**\n     * Code that handles {@link ItemGroup} work.\n     */\n    private transient final ItemGroupMixIn itemGroupMixIn = new ItemGroupMixIn(this,this) {\n        @Override\n        protected void add(TopLevelItem item) {\n            items.put(item.getName(),item);\n        }\n\n        @Override\n        protected File getRootDirFor(String name) {\n            return Jenkins.this.getRootDirFor(name);\n        }\n\n        /**\n         * Send the browser to the config page.\n         * use View to trim view/{default-view} from URL if possible\n         */\n        @Override\n        protected String redirectAfterCreateItem(StaplerRequest req, TopLevelItem result) throws IOException {\n            String redirect = result.getUrl()+\"configure\";\n            List<Ancestor> ancestors = req.getAncestors();\n            for (int i = ancestors.size() - 1; i >= 0; i--) {\n                Object o = ancestors.get(i).getObject();\n                if (o instanceof View) {\n                    redirect = req.getContextPath() + '/' + ((View)o).getUrl() + redirect;\n                    break;\n                }\n            }\n            return redirect;\n        }\n    };\n\n\n    /**\n     * Hook for a test harness to intercept Jenkins.getInstance()\n     *\n     * Do not use in the production code as the signature may change.\n     */\n    public interface JenkinsHolder {\n        Jenkins getInstance();\n    }\n\n    static JenkinsHolder HOLDER = new JenkinsHolder() {\n        public Jenkins getInstance() {\n            return theInstance;\n        }\n    };\n\n    @CLIResolver\n    public static Jenkins getInstance() {\n        return HOLDER.getInstance();\n    }\n\n    /**\n     * Secret key generated once and used for a long time, beyond\n     * container start/stop. Persisted outside <tt>config.xml</tt> to avoid\n     * accidental exposure.\n     */\n    private transient final String secretKey;\n\n    private transient final UpdateCenter updateCenter = new UpdateCenter();\n\n    /**\n     * True if the user opted out from the statistics tracking. We'll never send anything if this is true.\n     */\n    private Boolean noUsageStatistics;\n\n    /**\n     * HTTP proxy configuration.\n     */\n    public transient volatile ProxyConfiguration proxy;\n\n    /**\n     * Bound to \"/log\".\n     */\n    private transient final LogRecorderManager log = new LogRecorderManager();\n\n    protected Jenkins(File root, ServletContext context) throws IOException, InterruptedException, ReactorException {\n        this(root,context,null);\n    }\n\n    /**\n     * @param pluginManager\n     *      If non-null, use existing plugin manager.  create a new one.\n     */\n    @edu.umd.cs.findbugs.annotations.SuppressWarnings({\n        \"SC_START_IN_CTOR\", // bug in FindBugs. It flags UDPBroadcastThread.start() call but that's for another class\n        \"ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD\" // Trigger.timer\n    })\n    protected Jenkins(File root, ServletContext context, PluginManager pluginManager) throws IOException, InterruptedException, ReactorException {\n        long start = System.currentTimeMillis();\n        \n    \t// As Jenkins is starting, grant this process full control\n        ACL.impersonate(ACL.SYSTEM);\n        try {\n            this.root = root;\n            this.servletContext = context;\n            computeVersion(context);\n            if(theInstance!=null)\n                throw new IllegalStateException(\"second instance\");\n            theInstance = this;\n\n            if (!new File(root,\"jobs\").exists()) {\n                // if this is a fresh install, use more modern default layout that's consistent with slaves\n                workspaceDir = \"${JENKINS_HOME}/workspace/${ITEM_FULLNAME}\";\n            }\n\n            // doing this early allows InitStrategy to set environment upfront\n            final InitStrategy is = InitStrategy.get(Thread.currentThread().getContextClassLoader());\n\n            Trigger.timer = new Timer(\"Jenkins cron thread\");\n            queue = new Queue(LoadBalancer.CONSISTENT_HASH);\n\n            try {\n                dependencyGraph = DependencyGraph.EMPTY;\n            } catch (InternalError e) {\n                if(e.getMessage().contains(\"window server\")) {\n                    throw new Error(\"Looks like the server runs without X. Please specify -Djava.awt.headless=true as JVM option\",e);\n                }\n                throw e;\n            }\n\n            // get or create the secret\n            TextFile secretFile = new TextFile(new File(getRootDir(),\"secret.key\"));\n            if(secretFile.exists()) {\n                secretKey = secretFile.readTrim();\n            } else {\n                SecureRandom sr = new SecureRandom();\n                byte[] random = new byte[32];\n                sr.nextBytes(random);\n                secretKey = Util.toHexString(random);\n                secretFile.write(secretKey);\n\n                // this marker indicates that the secret.key is generated by the version of Jenkins post SECURITY-49.\n                // this indicates that there's no need to rewrite secrets on disk\n                new FileBoolean(new File(root,\"secret.key.not-so-secret\")).on();\n            }\n\n            try {\n                proxy = ProxyConfiguration.load();\n            } catch (IOException e) {\n                LOGGER.log(SEVERE, \"Failed to load proxy configuration\", e);\n            }\n\n            if (pluginManager==null)\n                pluginManager = new LocalPluginManager(this);\n            this.pluginManager = pluginManager;\n            // JSON binding needs to be able to see all the classes from all the plugins\n            WebApp.get(servletContext).setClassLoader(pluginManager.uberClassLoader);\n\n            adjuncts = new AdjunctManager(servletContext, pluginManager.uberClassLoader,\"adjuncts/\"+SESSION_HASH, TimeUnit2.DAYS.toMillis(365));\n\n            // initialization consists of ...\n            executeReactor( is,\n                    pluginManager.initTasks(is),    // loading and preparing plugins\n                    loadTasks(),                    // load jobs\n                    InitMilestone.ordering()        // forced ordering among key milestones\n            );\n\n            if(KILL_AFTER_LOAD)\n                System.exit(0);\n\n            if(slaveAgentPort!=-1) {\n                try {\n                    tcpSlaveAgentListener = new TcpSlaveAgentListener(slaveAgentPort);\n                } catch (BindException e) {\n                    new AdministrativeError(getClass().getName()+\".tcpBind\",\n                            \"Failed to listen to incoming slave connection\",\n                            \"Failed to listen to incoming slave connection. <a href='configure'>Change the port number</a> to solve the problem.\",e);\n                }\n            } else\n                tcpSlaveAgentListener = null;\n\n            try {\n                udpBroadcastThread = new UDPBroadcastThread(this);\n                udpBroadcastThread.start();\n            } catch (IOException e) {\n                LOGGER.log(Level.WARNING, \"Failed to broadcast over UDP\",e);\n            }\n            dnsMultiCast = new DNSMultiCast(this);\n\n            Timer timer = Trigger.timer;\n            if (timer != null) {\n                timer.scheduleAtFixedRate(new SafeTimerTask() {\n                    @Override\n                    protected void doRun() throws Exception {\n                        trimLabels();\n                    }\n                }, TimeUnit2.MINUTES.toMillis(5), TimeUnit2.MINUTES.toMillis(5));\n            }\n\n            updateComputerList();\n\n            {// master is online now\n                Computer c = toComputer();\n                if(c!=null)\n                    for (ComputerListener cl : ComputerListener.all())\n                        cl.onOnline(c,StreamTaskListener.fromStdout());\n            }\n\n            for (ItemListener l : ItemListener.all()) {\n                long itemListenerStart = System.currentTimeMillis();\n                l.onLoaded();\n                if (LOG_STARTUP_PERFORMANCE)\n                    LOGGER.info(String.format(\"Took %dms for item listener %s startup\",\n                            System.currentTimeMillis()-itemListenerStart,l.getClass().getName()));\n            }\n            \n            if (LOG_STARTUP_PERFORMANCE)\n                LOGGER.info(String.format(\"Took %dms for complete Jenkins startup\",\n                        System.currentTimeMillis()-start));\n        } finally {\n            SecurityContextHolder.clearContext();\n        }\n    }\n\n    /**\n     * Executes a reactor.\n     *\n     * @param is\n     *      If non-null, this can be consulted for ignoring some tasks. Only used during the initialization of Hudson.\n     */\n    private void executeReactor(final InitStrategy is, TaskBuilder... builders) throws IOException, InterruptedException, ReactorException {\n        Reactor reactor = new Reactor(builders) {\n            /**\n             * Sets the thread name to the task for better diagnostics.\n             */\n            @Override\n            protected void runTask(Task task) throws Exception {\n                if (is!=null && is.skipInitTask(task))  return;\n\n                ACL.impersonate(ACL.SYSTEM); // full access in the initialization thread\n                String taskName = task.getDisplayName();\n\n                Thread t = Thread.currentThread();\n                String name = t.getName();\n                if (taskName !=null)\n                    t.setName(taskName);\n                try {\n                    long start = System.currentTimeMillis();\n                    super.runTask(task);\n                    if(LOG_STARTUP_PERFORMANCE)\n                        LOGGER.info(String.format(\"Took %dms for %s by %s\",\n                                System.currentTimeMillis()-start, taskName, name));\n                } finally {\n                    t.setName(name);\n                    SecurityContextHolder.clearContext();\n                }\n            }\n        };\n\n        new InitReactorRunner() {\n            @Override\n            protected void onInitMilestoneAttained(InitMilestone milestone) {\n                initLevel = milestone;\n            }\n        }.run(reactor);\n    }\n\n\n    public TcpSlaveAgentListener getTcpSlaveAgentListener() {\n        return tcpSlaveAgentListener;\n    }\n\n    /**\n     * Makes {@link AdjunctManager} URL-bound.\n     * The dummy parameter allows us to use different URLs for the same adjunct,\n     * for proper cache handling.\n     */\n    public AdjunctManager getAdjuncts(String dummy) {\n        return adjuncts;\n    }\n\n    @Exported\n    public int getSlaveAgentPort() {\n        return slaveAgentPort;\n    }\n\n    /**\n     * @param port\n     *      0 to indicate random available TCP port. -1 to disable this service.\n     */\n    public void setSlaveAgentPort(int port) throws IOException {\n        this.slaveAgentPort = port;\n\n        // relaunch the agent\n        if(tcpSlaveAgentListener==null) {\n            if(slaveAgentPort!=-1)\n                tcpSlaveAgentListener = new TcpSlaveAgentListener(slaveAgentPort);\n        } else {\n            if(tcpSlaveAgentListener.configuredPort!=slaveAgentPort) {\n                tcpSlaveAgentListener.shutdown();\n                tcpSlaveAgentListener = null;\n                if(slaveAgentPort!=-1)\n                    tcpSlaveAgentListener = new TcpSlaveAgentListener(slaveAgentPort);\n            }\n        }\n    }\n\n    public void setNodeName(String name) {\n        throw new UnsupportedOperationException(); // not allowed\n    }\n\n    public String getNodeDescription() {\n        return Messages.Hudson_NodeDescription();\n    }\n\n    @Exported\n    public String getDescription() {\n        return systemMessage;\n    }\n\n    public PluginManager getPluginManager() {\n        return pluginManager;\n    }\n\n    public UpdateCenter getUpdateCenter() {\n        return updateCenter;\n    }\n\n    public boolean isUsageStatisticsCollected() {\n        return noUsageStatistics==null || !noUsageStatistics;\n    }\n\n    public void setNoUsageStatistics(Boolean noUsageStatistics) throws IOException {\n        this.noUsageStatistics = noUsageStatistics;\n        save();\n    }\n\n    public View.People getPeople() {\n        return new View.People(this);\n    }\n\n    /**\n     * @since 1.484\n     */\n    public View.AsynchPeople getAsynchPeople() {\n        return new View.AsynchPeople(this);\n    }\n\n    /**\n     * Does this {@link View} has any associated user information recorded?\n     * @deprecated Potentially very expensive call; do not use from Jelly views.\n     */\n    public boolean hasPeople() {\n        return View.People.isApplicable(items.values());\n    }\n\n    public Api getApi() {\n        return new Api(this);\n    }\n\n    /**\n     * Returns a secret key that survives across container start/stop.\n     * <p>\n     * This value is useful for implementing some of the security features.\n     *\n     * @deprecated\n     *      Due to the past security advisory, this value should not be used any more to protect sensitive information.\n     *      See {@link ConfidentialStore} and {@link ConfidentialKey} for how to store secrets.\n     */\n    public String getSecretKey() {\n        return secretKey;\n    }\n\n    /**\n     * Gets {@linkplain #getSecretKey() the secret key} as a key for AES-128.\n     * @since 1.308\n     * @deprecated\n     *       See {@link #getSecretKey()}.\n     */\n    public SecretKey getSecretKeyAsAES128() {\n        return Util.toAes128Key(secretKey);\n    }\n\n    /**\n     * Returns the unique identifier of this Jenkins that has been historically used to identify\n     * this Jenkins to the outside world.\n     *\n     * <p>\n     * This form of identifier is weak in that it can be impersonated by others. See\n     * https://wiki.jenkins-ci.org/display/JENKINS/Instance+Identity for more modern form of instance ID\n     * that can be challenged and verified.\n     *\n     * @since 1.498\n     */\n    @SuppressWarnings(\"deprecation\")\n    public String getLegacyInstanceId() {\n        return Util.getDigestOf(getSecretKey());\n    }\n\n    /**\n     * Gets the SCM descriptor by name. Primarily used for making them web-visible.\n     */\n    public Descriptor<SCM> getScm(String shortClassName) {\n        return findDescriptor(shortClassName,SCM.all());\n    }\n\n    /**\n     * Gets the repository browser descriptor by name. Primarily used for making them web-visible.\n     */\n    public Descriptor<RepositoryBrowser<?>> getRepositoryBrowser(String shortClassName) {\n        return findDescriptor(shortClassName,RepositoryBrowser.all());\n    }\n\n    /**\n     * Gets the builder descriptor by name. Primarily used for making them web-visible.\n     */\n    public Descriptor<Builder> getBuilder(String shortClassName) {\n        return findDescriptor(shortClassName, Builder.all());\n    }\n\n    /**\n     * Gets the build wrapper descriptor by name. Primarily used for making them web-visible.\n     */\n    public Descriptor<BuildWrapper> getBuildWrapper(String shortClassName) {\n        return findDescriptor(shortClassName, BuildWrapper.all());\n    }\n\n    /**\n     * Gets the publisher descriptor by name. Primarily used for making them web-visible.\n     */\n    public Descriptor<Publisher> getPublisher(String shortClassName) {\n        return findDescriptor(shortClassName, Publisher.all());\n    }\n\n    /**\n     * Gets the trigger descriptor by name. Primarily used for making them web-visible.\n     */\n    public TriggerDescriptor getTrigger(String shortClassName) {\n        return (TriggerDescriptor) findDescriptor(shortClassName, Trigger.all());\n    }\n\n    /**\n     * Gets the retention strategy descriptor by name. Primarily used for making them web-visible.\n     */\n    public Descriptor<RetentionStrategy<?>> getRetentionStrategy(String shortClassName) {\n        return findDescriptor(shortClassName, RetentionStrategy.all());\n    }\n\n    /**\n     * Gets the {@link JobPropertyDescriptor} by name. Primarily used for making them web-visible.\n     */\n    public JobPropertyDescriptor getJobProperty(String shortClassName) {\n        // combining these two lines triggers javac bug. See issue #610.\n        Descriptor d = findDescriptor(shortClassName, JobPropertyDescriptor.all());\n        return (JobPropertyDescriptor) d;\n    }\n\n    /**\n     * @deprecated\n     *      UI method. Not meant to be used programatically.\n     */\n    public ComputerSet getComputer() {\n        return new ComputerSet();\n    }\n\n    /**\n     * Exposes {@link Descriptor} by its name to URL.\n     *\n     * After doing all the {@code getXXX(shortClassName)} methods, I finally realized that\n     * this just doesn't scale.\n     *\n     * @param id\n     *      Either {@link Descriptor#getId()} (recommended) or the short name of a {@link Describable} subtype (for compatibility)\n     * @throws IllegalArgumentException if a short name was passed which matches multiple IDs (fail fast)\n     */\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // too late to fix\n    public Descriptor getDescriptor(String id) {\n        // legacy descriptors that are reigstered manually doesn't show up in getExtensionList, so check them explicitly.\n        Iterable<Descriptor> descriptors = Iterators.sequence(getExtensionList(Descriptor.class), DescriptorExtensionList.listLegacyInstances());\n        for (Descriptor d : descriptors) {\n            if (d.getId().equals(id)) {\n                return d;\n            }\n        }\n        Descriptor candidate = null;\n        for (Descriptor d : descriptors) {\n            String name = d.getId();\n            if (name.substring(name.lastIndexOf('.') + 1).equals(id)) {\n                if (candidate == null) {\n                    candidate = d;\n                } else {\n                    throw new IllegalArgumentException(id + \" is ambiguous; matches both \" + name + \" and \" + candidate.getId());\n                }\n            }\n        }\n        return candidate;\n    }\n\n    /**\n     * Alias for {@link #getDescriptor(String)}.\n     */\n    public Descriptor getDescriptorByName(String id) {\n        return getDescriptor(id);\n    }\n\n    /**\n     * Gets the {@link Descriptor} that corresponds to the given {@link Describable} type.\n     * <p>\n     * If you have an instance of {@code type} and call {@link Describable#getDescriptor()},\n     * you'll get the same instance that this method returns.\n     */\n    public Descriptor getDescriptor(Class<? extends Describable> type) {\n        for( Descriptor d : getExtensionList(Descriptor.class) )\n            if(d.clazz==type)\n                return d;\n        return null;\n    }\n\n    /**\n     * Works just like {@link #getDescriptor(Class)} but don't take no for an answer.\n     *\n     * @throws AssertionError\n     *      If the descriptor is missing.\n     * @since 1.326\n     */\n    public Descriptor getDescriptorOrDie(Class<? extends Describable> type) {\n        Descriptor d = getDescriptor(type);\n        if (d==null)\n            throw new AssertionError(type+\" is missing its descriptor\");\n        return d;\n    }\n\n    /**\n     * Gets the {@link Descriptor} instance in the current Hudson by its type.\n     */\n    public <T extends Descriptor> T getDescriptorByType(Class<T> type) {\n        for( Descriptor d : getExtensionList(Descriptor.class) )\n            if(d.getClass()==type)\n                return type.cast(d);\n        return null;\n    }\n\n    /**\n     * Gets the {@link SecurityRealm} descriptors by name. Primarily used for making them web-visible.\n     */\n    public Descriptor<SecurityRealm> getSecurityRealms(String shortClassName) {\n        return findDescriptor(shortClassName,SecurityRealm.all());\n    }\n\n    /**\n     * Finds a descriptor that has the specified name.\n     */\n    private <T extends Describable<T>>\n    Descriptor<T> findDescriptor(String shortClassName, Collection<? extends Descriptor<T>> descriptors) {\n        String name = '.'+shortClassName;\n        for (Descriptor<T> d : descriptors) {\n            if(d.clazz.getName().endsWith(name))\n                return d;\n        }\n        return null;\n    }\n\n    protected void updateComputerList() throws IOException {\n        updateComputerList(AUTOMATIC_SLAVE_LAUNCH);\n    }\n\n    /**\n     * Gets all the installed {@link SCMListener}s.\n     */\n    public CopyOnWriteList<SCMListener> getSCMListeners() {\n        return scmListeners;\n    }\n\n    /**\n     * Gets the plugin object from its short name.\n     *\n     * <p>\n     * This allows URL <tt>hudson/plugin/ID</tt> to be served by the views\n     * of the plugin class.\n     */\n    public Plugin getPlugin(String shortName) {\n        PluginWrapper p = pluginManager.getPlugin(shortName);\n        if(p==null)     return null;\n        return p.getPlugin();\n    }\n\n    /**\n     * Gets the plugin object from its class.\n     *\n     * <p>\n     * This allows easy storage of plugin information in the plugin singleton without\n     * every plugin reimplementing the singleton pattern.\n     *\n     * @param clazz The plugin class (beware class-loader fun, this will probably only work\n     * from within the jpi that defines the plugin class, it may or may not work in other cases)\n     *\n     * @return The plugin instance.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <P extends Plugin> P getPlugin(Class<P> clazz) {\n        PluginWrapper p = pluginManager.getPlugin(clazz);\n        if(p==null)     return null;\n        return (P) p.getPlugin();\n    }\n\n    /**\n     * Gets the plugin objects from their super-class.\n     *\n     * @param clazz The plugin class (beware class-loader fun)\n     *\n     * @return The plugin instances.\n     */\n    public <P extends Plugin> List<P> getPlugins(Class<P> clazz) {\n        List<P> result = new ArrayList<P>();\n        for (PluginWrapper w: pluginManager.getPlugins(clazz)) {\n            result.add((P)w.getPlugin());\n        }\n        return Collections.unmodifiableList(result);\n    }\n\n    /**\n     * Synonym for {@link #getDescription}.\n     */\n    public String getSystemMessage() {\n        return systemMessage;\n    }\n\n    /**\n     * Gets the markup formatter used in the system.\n     *\n     * @return\n     *      never null.\n     * @since 1.391\n     */\n    public MarkupFormatter getMarkupFormatter() {\n        return markupFormatter!=null ? markupFormatter : RawHtmlMarkupFormatter.INSTANCE;\n    }\n\n    /**\n     * Sets the markup formatter used in the system globally.\n     *\n     * @since 1.391\n     */\n    public void setMarkupFormatter(MarkupFormatter f) {\n        this.markupFormatter = f;\n    }\n\n    /**\n     * Sets the system message.\n     */\n    public void setSystemMessage(String message) throws IOException {\n        this.systemMessage = message;\n        save();\n    }\n\n    public FederatedLoginService getFederatedLoginService(String name) {\n        for (FederatedLoginService fls : FederatedLoginService.all()) {\n            if (fls.getUrlName().equals(name))\n                return fls;\n        }\n        return null;\n    }\n\n    public List<FederatedLoginService> getFederatedLoginServices() {\n        return FederatedLoginService.all();\n    }\n\n    public Launcher createLauncher(TaskListener listener) {\n        return new LocalLauncher(listener).decorateFor(this);\n    }\n\n\n    public String getFullName() {\n        return \"\";\n    }\n\n    public String getFullDisplayName() {\n        return \"\";\n    }\n\n    /**\n     * Returns the transient {@link Action}s associated with the top page.\n     *\n     * <p>\n     * Adding {@link Action} is primarily useful for plugins to contribute\n     * an item to the navigation bar of the top page. See existing {@link Action}\n     * implementation for it affects the GUI.\n     *\n     * <p>\n     * To register an {@link Action}, implement {@link RootAction} extension point, or write code like\n     * {@code Hudson.getInstance().getActions().add(...)}.\n     *\n     * @return\n     *      Live list where the changes can be made. Can be empty but never null.\n     * @since 1.172\n     */\n    public List<Action> getActions() {\n        return actions;\n    }\n\n    /**\n     * Gets just the immediate children of {@link Jenkins}.\n     *\n     * @see #getAllItems(Class)\n     */\n    @Exported(name=\"jobs\")\n    public List<TopLevelItem> getItems() {\n\t\tif (authorizationStrategy instanceof AuthorizationStrategy.Unsecured ||\n\t\t\tauthorizationStrategy instanceof FullControlOnceLoggedInAuthorizationStrategy) {\n\t\t\treturn new ArrayList(items.values());\n\t\t}\n\n        List<TopLevelItem> viewableItems = new ArrayList<TopLevelItem>();\n        for (TopLevelItem item : items.values()) {\n            if (item.hasPermission(Item.READ))\n                viewableItems.add(item);\n        }\n\t\t\n        return viewableItems;\n    }\n\n    /**\n     * Returns the read-only view of all the {@link TopLevelItem}s keyed by their names.\n     * <p>\n     * This method is efficient, as it doesn't involve any copying.\n     *\n     * @since 1.296\n     */\n    public Map<String,TopLevelItem> getItemMap() {\n        return Collections.unmodifiableMap(items);\n    }\n\n    /**\n     * Gets just the immediate children of {@link Jenkins} but of the given type.\n     */\n    public <T> List<T> getItems(Class<T> type) {\n        List<T> r = new ArrayList<T>();\n        for (TopLevelItem i : getItems())\n            if (type.isInstance(i))\n                 r.add(type.cast(i));\n        return r;\n    }\n\n    /**\n     * Gets all the {@link Item}s recursively in the {@link ItemGroup} tree\n     * and filter them by the given type.\n     */\n    public <T extends Item> List<T> getAllItems(Class<T> type) {\n        List<T> r = new ArrayList<T>();\n\n        Stack<ItemGroup> q = new Stack<ItemGroup>();\n        q.push(this);\n\n        while(!q.isEmpty()) {\n            ItemGroup<?> parent = q.pop();\n            for (Item i : parent.getItems()) {\n                if(type.isInstance(i)) {\n                    if (i.hasPermission(Item.READ))\n                        r.add(type.cast(i));\n                }\n                if(i instanceof ItemGroup)\n                    q.push((ItemGroup)i);\n            }\n        }\n\n        return r;\n    }\n\n    /**\n     * Gets all the items recursively.\n     *\n     * @since 1.402\n     */\n    public List<Item> getAllItems() {\n        return getAllItems(Item.class);\n    }\n\n    /**\n     * Gets a list of simple top-level projects.\n     * @deprecated This method will ignore Maven and matrix projects, as well as projects inside containers such as folders.\n     * You may prefer to call {@link #getAllItems(Class)} on {@link AbstractProject},\n     * perhaps also using {@link Util#createSubList} to consider only {@link TopLevelItem}s.\n     * (That will also consider the caller's permissions.)\n     * If you really want to get just {@link Project}s at top level, ignoring permissions,\n     * you can filter the values from {@link #getItemMap} using {@link Util#createSubList}.\n     */\n    @Deprecated\n    public List<Project> getProjects() {\n        return Util.createSubList(items.values(),Project.class);\n    }\n\n    /**\n     * Gets the names of all the {@link Job}s.\n     */\n    public Collection<String> getJobNames() {\n        List<String> names = new ArrayList<String>();\n        for (Job j : getAllItems(Job.class))\n            names.add(j.getFullName());\n        return names;\n    }\n\n    public List<Action> getViewActions() {\n        return getActions();\n    }\n\n    /**\n     * Gets the names of all the {@link TopLevelItem}s.\n     */\n    public Collection<String> getTopLevelItemNames() {\n        List<String> names = new ArrayList<String>();\n        for (TopLevelItem j : items.values())\n            names.add(j.getName());\n        return names;\n    }\n\n    public View getView(String name) {\n        return viewGroupMixIn.getView(name);\n    }\n\n    /**\n     * Gets the read-only list of all {@link View}s.\n     */\n    @Exported\n    public Collection<View> getViews() {\n        return viewGroupMixIn.getViews();\n    }\n\n    public void addView(View v) throws IOException {\n        viewGroupMixIn.addView(v);\n    }\n\n    public boolean canDelete(View view) {\n        return viewGroupMixIn.canDelete(view);\n    }\n\n    public synchronized void deleteView(View view) throws IOException {\n        viewGroupMixIn.deleteView(view);\n    }\n\n    public void onViewRenamed(View view, String oldName, String newName) {\n        viewGroupMixIn.onViewRenamed(view,oldName,newName);\n    }\n\n    /**\n     * Returns the primary {@link View} that renders the top-page of Hudson.\n     */\n    @Exported\n    public View getPrimaryView() {\n        return viewGroupMixIn.getPrimaryView();\n     }\n\n    public void setPrimaryView(View v) {\n        this.primaryView = v.getViewName();\n    }\n\n    public ViewsTabBar getViewsTabBar() {\n        return viewsTabBar;\n    }\n\n    public void setViewsTabBar(ViewsTabBar viewsTabBar) {\n        this.viewsTabBar = viewsTabBar;\n    }\n\n    public Jenkins getItemGroup() {\n        return this;\n   }\n\n    public MyViewsTabBar getMyViewsTabBar() {\n        return myViewsTabBar;\n    }\n\n    public void setMyViewsTabBar(MyViewsTabBar myViewsTabBar) {\n        this.myViewsTabBar = myViewsTabBar;\n    }\n\n    /**\n     * Returns true if the current running Jenkins is upgraded from a version earlier than the specified version.\n     *\n     * <p>\n     * This method continues to return true until the system configuration is saved, at which point\n     * {@link #version} will be overwritten and Hudson forgets the upgrade history.\n     *\n     * <p>\n     * To handle SNAPSHOTS correctly, pass in \"1.N.*\" to test if it's upgrading from the version\n     * equal or younger than N. So say if you implement a feature in 1.301 and you want to check\n     * if the installation upgraded from pre-1.301, pass in \"1.300.*\"\n     *\n     * @since 1.301\n     */\n    public boolean isUpgradedFromBefore(VersionNumber v) {\n        try {\n            return new VersionNumber(version).isOlderThan(v);\n        } catch (IllegalArgumentException e) {\n            // fail to parse this version number\n            return false;\n        }\n    }\n\n    /**\n     * Gets the read-only list of all {@link Computer}s.\n     */\n    public Computer[] getComputers() {\n        Computer[] r = computers.values().toArray(new Computer[computers.size()]);\n        Arrays.sort(r,new Comparator<Computer>() {\n            final Collator collator = Collator.getInstance();\n            public int compare(Computer lhs, Computer rhs) {\n                if(lhs.getNode()==Jenkins.this)  return -1;\n                if(rhs.getNode()==Jenkins.this)  return 1;\n                return collator.compare(lhs.getDisplayName(), rhs.getDisplayName());\n            }\n        });\n        return r;\n    }\n\n    @CLIResolver\n    public Computer getComputer(@Argument(required=true,metaVar=\"NAME\",usage=\"Node name\") String name) {\n        if(name.equals(\"(master)\"))\n            name = \"\";\n\n        for (Computer c : computers.values()) {\n            if(c.getName().equals(name))\n                return c;\n        }\n        return null;\n    }\n\n    /**\n     * Gets the label that exists on this system by the name.\n     *\n     * @return null if name is null.\n     * @see Label#parseExpression(String) (String)\n     */\n    public Label getLabel(String expr) {\n        if(expr==null)  return null;\n        expr = hudson.util.QuotedStringTokenizer.unquote(expr);\n        while(true) {\n            Label l = labels.get(expr);\n            if(l!=null)\n                return l;\n\n            // non-existent\n            try {\n                labels.putIfAbsent(expr,Label.parseExpression(expr));\n            } catch (ANTLRException e) {\n                // laxly accept it as a single label atom for backward compatibility\n                return getLabelAtom(expr);\n            }\n        }\n    }\n\n    /**\n     * Returns the label atom of the given name.\n     * @return non-null iff name is non-null\n     */\n    public @Nullable LabelAtom getLabelAtom(@CheckForNull String name) {\n        if (name==null)  return null;\n\n        while(true) {\n            Label l = labels.get(name);\n            if(l!=null)\n                return (LabelAtom)l;\n\n            // non-existent\n            LabelAtom la = new LabelAtom(name);\n            if (labels.putIfAbsent(name, la)==null)\n                la.load();\n        }\n    }\n\n    /**\n     * Gets all the active labels in the current system.\n     */\n    public Set<Label> getLabels() {\n        Set<Label> r = new TreeSet<Label>();\n        for (Label l : labels.values()) {\n            if(!l.isEmpty())\n                r.add(l);\n        }\n        return r;\n    }\n\n    public Set<LabelAtom> getLabelAtoms() {\n        Set<LabelAtom> r = new TreeSet<LabelAtom>();\n        for (Label l : labels.values()) {\n            if(!l.isEmpty() && l instanceof LabelAtom)\n                r.add((LabelAtom)l);\n        }\n        return r;\n    }\n\n    public Queue getQueue() {\n        return queue;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return Messages.Hudson_DisplayName();\n    }\n\n    public List<JDK> getJDKs() {\n        if(jdks==null)\n            jdks = new ArrayList<JDK>();\n        return jdks;\n    }\n\n    /**\n     * Gets the JDK installation of the given name, or returns null.\n     */\n    public JDK getJDK(String name) {\n        if(name==null) {\n            // if only one JDK is configured, \"default JDK\" should mean that JDK.\n            List<JDK> jdks = getJDKs();\n            if(jdks.size()==1)  return jdks.get(0);\n            return null;\n        }\n        for (JDK j : getJDKs()) {\n            if(j.getName().equals(name))\n                return j;\n        }\n        return null;\n    }\n\n\n\n    /**\n     * Gets the slave node of the give name, hooked under this Hudson.\n     */\n    public @CheckForNull Node getNode(String name) {\n        return slaves.getNode(name);\n    }\n\n    /**\n     * Gets a {@link Cloud} by {@link Cloud#name its name}, or null.\n     */\n    public Cloud getCloud(String name) {\n        return clouds.getByName(name);\n    }\n\n    protected Map<Node,Computer> getComputerMap() {\n        return computers;\n    }\n\n    /**\n     * Returns all {@link Node}s in the system, excluding {@link Jenkins} instance itself which\n     * represents the master.\n     */\n    public List<Node> getNodes() {\n        return slaves;\n    }\n\n    /**\n     * Adds one more {@link Node} to Hudson.\n     */\n    public synchronized void addNode(Node n) throws IOException {\n        if(n==null)     throw new IllegalArgumentException();\n        ArrayList<Node> nl = new ArrayList<Node>(this.slaves);\n        if(!nl.contains(n)) // defensive check\n            nl.add(n);\n        setNodes(nl);\n    }\n\n    /**\n     * Removes a {@link Node} from Hudson.\n     */\n    public synchronized void removeNode(@Nonnull Node n) throws IOException {\n        Computer c = n.toComputer();\n        if (c!=null)\n            c.disconnect(OfflineCause.create(Messages._Hudson_NodeBeingRemoved()));\n\n        ArrayList<Node> nl = new ArrayList<Node>(this.slaves);\n        nl.remove(n);\n        setNodes(nl);\n    }\n\n    public void setNodes(List<? extends Node> nodes) throws IOException {\n        this.slaves = new NodeList(nodes);\n        updateComputerList();\n        trimLabels();\n        save();\n    }\n\n    public DescribableList<NodeProperty<?>, NodePropertyDescriptor> getNodeProperties() {\n    \treturn nodeProperties;\n    }\n\n    public DescribableList<NodeProperty<?>, NodePropertyDescriptor> getGlobalNodeProperties() {\n    \treturn globalNodeProperties;\n    }\n\n    /**\n     * Resets all labels and remove invalid ones.\n     *\n     * This should be called when the assumptions behind label cache computation changes,\n     * but we also call this periodically to self-heal any data out-of-sync issue.\n     */\n    private void trimLabels() {\n        for (Iterator<Label> itr = labels.values().iterator(); itr.hasNext();) {\n            Label l = itr.next();\n            resetLabel(l);\n            if(l.isEmpty())\n                itr.remove();\n        }\n    }\n\n    /**\n     * Binds {@link AdministrativeMonitor}s to URL.\n     */\n    public AdministrativeMonitor getAdministrativeMonitor(String id) {\n        for (AdministrativeMonitor m : administrativeMonitors)\n            if(m.id.equals(id))\n                return m;\n        return null;\n    }\n\n    public NodeDescriptor getDescriptor() {\n        return DescriptorImpl.INSTANCE;\n    }\n\n    public static final class DescriptorImpl extends NodeDescriptor {\n        @Extension\n        public static final DescriptorImpl INSTANCE = new DescriptorImpl();\n\n        public String getDisplayName() {\n            return \"\";\n        }\n\n        @Override\n        public boolean isInstantiable() {\n            return false;\n        }\n\n        public FormValidation doCheckNumExecutors(@QueryParameter String value) {\n            return FormValidation.validateNonNegativeInteger(value);\n        }\n\n        public FormValidation doCheckRawBuildsDir(@QueryParameter String value) {\n            if (!value.contains(\"${\")) {\n                File d = new File(value);\n                if (!d.isDirectory() && (d.getParentFile() == null || !d.getParentFile().canWrite())) {\n                    return FormValidation.error(value + \" does not exist and probably cannot be created\");\n                }\n                // XXX failure to use either ITEM_* variable might be an error too?\n            }\n            return FormValidation.ok(); // XXX assumes it will be OK after substitution, but can we be sure?\n        }\n\n        // to route /descriptor/FQCN/xxx to getDescriptor(FQCN).xxx\n        public Object getDynamic(String token) {\n            return Jenkins.getInstance().getDescriptor(token);\n        }\n    }\n\n    /**\n     * Gets the system default quiet period.\n     */\n    public int getQuietPeriod() {\n        return quietPeriod!=null ? quietPeriod : 5;\n    }\n\n    /**\n     * Sets the global quiet period.\n     *\n     * @param quietPeriod\n     *      null to the default value.\n     */\n    public void setQuietPeriod(Integer quietPeriod) throws IOException {\n        this.quietPeriod = quietPeriod;\n        save();\n    }\n\n    /**\n     * Gets the global SCM check out retry count.\n     */\n    public int getScmCheckoutRetryCount() {\n        return scmCheckoutRetryCount;\n    }\n\n    public void setScmCheckoutRetryCount(int scmCheckoutRetryCount) throws IOException {\n        this.scmCheckoutRetryCount = scmCheckoutRetryCount;\n        save();\n    }\n\n    @Override\n    public String getSearchUrl() {\n        return \"\";\n    }\n\n    @Override\n    public SearchIndexBuilder makeSearchIndex() {\n        return super.makeSearchIndex()\n            .add(\"configure\", \"config\",\"configure\")\n            .add(\"manage\")\n            .add(\"log\")\n            .add(new CollectionSearchIndex<TopLevelItem>() {\n                protected SearchItem get(String key) { return getItem(key); }\n                protected Collection<TopLevelItem> all() { return getItems(); }\n            })\n            .add(getPrimaryView().makeSearchIndex())\n            .add(new CollectionSearchIndex() {// for computers\n                protected Computer get(String key) { return getComputer(key); }\n                protected Collection<Computer> all() { return computers.values(); }\n            })\n            .add(new CollectionSearchIndex() {// for users\n                protected User get(String key) { return User.get(key,false); }\n                protected Collection<User> all() { return User.getAll(); }\n            })\n            .add(new CollectionSearchIndex() {// for views\n                protected View get(String key) { return getView(key); }\n                protected Collection<View> all() { return views; }\n            });\n    }\n\n    public String getUrlChildPrefix() {\n        return \"job\";\n    }\n\n    /**\n     * Gets the absolute URL of Jenkins,\n     * such as \"http://localhost/jenkins/\".\n     *\n     * <p>\n     * This method first tries to use the manually configured value, then\n     * fall back to {@link StaplerRequest#getRootPath()}.\n     * It is done in this order so that it can work correctly even in the face\n     * of a reverse proxy.\n     *\n     * @return\n     *      This method returns null if this parameter is not configured by the user.\n     *      The caller must gracefully deal with this situation.\n     *      The returned URL will always have the trailing '/'.\n     * @since 1.66\n     * @see Descriptor#getCheckUrl(String)\n     * @see #getRootUrlFromRequest()\n     * @see <a href=\"https://wiki.jenkins-ci.org/display/JENKINS/Hyperlinks+in+HTML\">Hyperlinks in HTML</a>\n     */\n    public String getRootUrl() {\n        String url = JenkinsLocationConfiguration.get().getUrl();\n        if(url!=null) {\n            return Util.ensureEndsWith(url,\"/\");\n        }\n        StaplerRequest req = Stapler.getCurrentRequest();\n        if(req!=null)\n            return getRootUrlFromRequest();\n        return null;\n    }\n\n    /**\n     * Is Jenkins running in HTTPS?\n     *\n     * Note that we can't really trust {@link StaplerRequest#isSecure()} because HTTPS might be terminated\n     * in the reverse proxy.\n     */\n    public boolean isRootUrlSecure() {\n        String url = getRootUrl();\n        return url!=null && url.startsWith(\"https\");\n    }\n\n    /**\n     * Gets the absolute URL of Hudson top page, such as \"http://localhost/hudson/\".\n     *\n     * <p>\n     * Unlike {@link #getRootUrl()}, which uses the manually configured value,\n     * this one uses the current request to reconstruct the URL. The benefit is\n     * that this is immune to the configuration mistake (users often fail to set the root URL\n     * correctly, especially when a migration is involved), but the downside\n     * is that unless you are processing a request, this method doesn't work.\n     *\n     * Please note that this will not work in all cases if Jenkins is running behind a\n     * reverse proxy (e.g. when user has switched off ProxyPreserveHost, which is\n     * default setup or the actual url uses https) and you should use getRootUrl if\n     * you want to be sure you reflect user setup.\n     * See https://wiki.jenkins-ci.org/display/JENKINS/Running+Jenkins+behind+Apache\n     *\n     * @since 1.263\n     */\n    public String getRootUrlFromRequest() {\n        StaplerRequest req = Stapler.getCurrentRequest();\n        StringBuilder buf = new StringBuilder();\n        buf.append(req.getScheme()+\"://\");\n        buf.append(req.getServerName());\n        if(req.getServerPort()!=80)\n            buf.append(':').append(req.getServerPort());\n        buf.append(req.getContextPath()).append('/');\n        return buf.toString();\n    }\n\n    public File getRootDir() {\n        return root;\n    }\n\n    public FilePath getWorkspaceFor(TopLevelItem item) {\n        for (WorkspaceLocator l : WorkspaceLocator.all()) {\n            FilePath workspace = l.locate(item, this);\n            if (workspace != null) {\n                return workspace;\n            }\n        }\n \n        return new FilePath(expandVariablesForDirectory(workspaceDir, item));\n    }\n\n    public File getBuildDirFor(Job job) {\n        return expandVariablesForDirectory(buildsDir, job);\n    }\n\n    private File expandVariablesForDirectory(String base, Item item) {\n        return new File(Util.replaceMacro(base, ImmutableMap.of(\n                \"JENKINS_HOME\", getRootDir().getPath(),\n                \"ITEM_ROOTDIR\", item.getRootDir().getPath(),\n                \"ITEM_FULLNAME\", item.getFullName(),   // legacy, deprecated\n                \"ITEM_FULL_NAME\", item.getFullName().replace(':','$')))); // safe, see JENKINS-12251\n    }\n    \n    public String getRawWorkspaceDir() {\n        return workspaceDir;\n    }\n\n    public String getRawBuildsDir() {\n        return buildsDir;\n    }\n\n    public FilePath getRootPath() {\n        return new FilePath(getRootDir());\n    }\n\n    @Override\n    public FilePath createPath(String absolutePath) {\n        return new FilePath((VirtualChannel)null,absolutePath);\n    }\n\n    public ClockDifference getClockDifference() {\n        return ClockDifference.ZERO;\n    }\n\n    /**\n     * For binding {@link LogRecorderManager} to \"/log\".\n     * Everything below here is admin-only, so do the check here.\n     */\n    public LogRecorderManager getLog() {\n        checkPermission(ADMINISTER);\n        return log;\n    }\n\n    /**\n     * A convenience method to check if there's some security\n     * restrictions in place.\n     */\n    @Exported\n    public boolean isUseSecurity() {\n        return securityRealm!=SecurityRealm.NO_AUTHENTICATION || authorizationStrategy!=AuthorizationStrategy.UNSECURED;\n    }\n    \n    public boolean isUseProjectNamingStrategy(){\n        return projectNamingStrategy != DefaultProjectNamingStrategy.DEFAULT_NAMING_STRATEGY;\n    }\n\n    /**\n     * If true, all the POST requests to Hudson would have to have crumb in it to protect\n     * Hudson from CSRF vulnerabilities.\n     */\n    @Exported\n    public boolean isUseCrumbs() {\n        return crumbIssuer!=null;\n    }\n\n    /**\n     * Returns the constant that captures the three basic security modes\n     * in Hudson.\n     */\n    public SecurityMode getSecurity() {\n        // fix the variable so that this code works under concurrent modification to securityRealm.\n        SecurityRealm realm = securityRealm;\n\n        if(realm==SecurityRealm.NO_AUTHENTICATION)\n            return SecurityMode.UNSECURED;\n        if(realm instanceof LegacySecurityRealm)\n            return SecurityMode.LEGACY;\n        return SecurityMode.SECURED;\n    }\n\n    /**\n     * @return\n     *      never null.\n     */\n    public SecurityRealm getSecurityRealm() {\n        return securityRealm;\n    }\n\n    public void setSecurityRealm(SecurityRealm securityRealm) {\n        if(securityRealm==null)\n            securityRealm= SecurityRealm.NO_AUTHENTICATION;\n        this.useSecurity = true;\n        this.securityRealm = securityRealm;\n        // reset the filters and proxies for the new SecurityRealm\n        try {\n            HudsonFilter filter = HudsonFilter.get(servletContext);\n            if (filter == null) {\n                // Fix for #3069: This filter is not necessarily initialized before the servlets.\n                // when HudsonFilter does come back, it'll initialize itself.\n                LOGGER.fine(\"HudsonFilter has not yet been initialized: Can't perform security setup for now\");\n            } else {\n                LOGGER.fine(\"HudsonFilter has been previously initialized: Setting security up\");\n                filter.reset(securityRealm);\n                LOGGER.fine(\"Security is now fully set up\");\n            }\n        } catch (ServletException e) {\n            // for binary compatibility, this method cannot throw a checked exception\n            throw new AcegiSecurityException(\"Failed to configure filter\",e) {};\n        }\n    }\n\n    public void setAuthorizationStrategy(AuthorizationStrategy a) {\n        if (a == null)\n            a = AuthorizationStrategy.UNSECURED;\n        useSecurity = true;\n        authorizationStrategy = a;\n    }\n\n    public void disableSecurity() {\n        useSecurity = null;\n        setSecurityRealm(SecurityRealm.NO_AUTHENTICATION);\n        authorizationStrategy = AuthorizationStrategy.UNSECURED;\n        markupFormatter = null;\n    }\n\n    public void setProjectNamingStrategy(ProjectNamingStrategy ns) {\n        if(ns == null){\n            ns = DefaultProjectNamingStrategy.DEFAULT_NAMING_STRATEGY;\n        }\n        projectNamingStrategy = ns;\n    }\n    \n    public Lifecycle getLifecycle() {\n        return Lifecycle.get();\n    }\n\n    /**\n     * Gets the dependency injection container that hosts all the extension implementations and other\n     * components in Jenkins.\n     *\n     * @since 1.GUICE\n     */\n    public Injector getInjector() {\n        return lookup(Injector.class);\n    }\n\n    /**\n     * Returns {@link ExtensionList} that retains the discovered instances for the given extension type.\n     *\n     * @param extensionType\n     *      The base type that represents the extension point. Normally {@link ExtensionPoint} subtype\n     *      but that's not a hard requirement.\n     * @return\n     *      Can be an empty list but never null.\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public <T> ExtensionList<T> getExtensionList(Class<T> extensionType) {\n        return extensionLists.get(extensionType);\n    }\n\n    /**\n     * Used to bind {@link ExtensionList}s to URLs.\n     *\n     * @since 1.349\n     */\n    public ExtensionList getExtensionList(String extensionType) throws ClassNotFoundException {\n        return getExtensionList(pluginManager.uberClassLoader.loadClass(extensionType));\n    }\n\n    /**\n     * Returns {@link ExtensionList} that retains the discovered {@link Descriptor} instances for the given\n     * kind of {@link Describable}.\n     *\n     * @return\n     *      Can be an empty list but never null.\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public <T extends Describable<T>,D extends Descriptor<T>> DescriptorExtensionList<T,D> getDescriptorList(Class<T> type) {\n        return descriptorLists.get(type);\n    }\n\n    /**\n     * Refresh {@link ExtensionList}s by adding all the newly discovered extensions.\n     *\n     * Exposed only for {@link PluginManager#dynamicLoad(File)}.\n     */\n    public void refreshExtensions() throws ExtensionRefreshException {\n        ExtensionList<ExtensionFinder> finders = getExtensionList(ExtensionFinder.class);\n        for (ExtensionFinder ef : finders) {\n            if (!ef.isRefreshable())\n                throw new ExtensionRefreshException(ef+\" doesn't support refresh\");\n        }\n\n        List<ExtensionComponentSet> fragments = Lists.newArrayList();\n        for (ExtensionFinder ef : finders) {\n            fragments.add(ef.refresh());\n        }\n        ExtensionComponentSet delta = ExtensionComponentSet.union(fragments).filtered();\n\n        // if we find a new ExtensionFinder, we need it to list up all the extension points as well\n        List<ExtensionComponent<ExtensionFinder>> newFinders = Lists.newArrayList(delta.find(ExtensionFinder.class));\n        while (!newFinders.isEmpty()) {\n            ExtensionFinder f = newFinders.remove(newFinders.size()-1).getInstance();\n\n            ExtensionComponentSet ecs = ExtensionComponentSet.allOf(f).filtered();\n            newFinders.addAll(ecs.find(ExtensionFinder.class));\n            delta = ExtensionComponentSet.union(delta, ecs);\n        }\n\n        for (ExtensionList el : extensionLists.values()) {\n            el.refresh(delta);\n        }\n        for (ExtensionList el : descriptorLists.values()) {\n            el.refresh(delta);\n        }\n\n        // TODO: we need some generalization here so that extension points can be notified when a refresh happens?\n        for (ExtensionComponent<RootAction> ea : delta.find(RootAction.class)) {\n            Action a = ea.getInstance();\n            if (!actions.contains(a)) actions.add(a);\n        }\n    }\n\n    /**\n     * Returns the root {@link ACL}.\n     *\n     * @see AuthorizationStrategy#getRootACL()\n     */\n    @Override\n    public ACL getACL() {\n        return authorizationStrategy.getRootACL();\n    }\n\n    /**\n     * @return\n     *      never null.\n     */\n    public AuthorizationStrategy getAuthorizationStrategy() {\n        return authorizationStrategy;\n    }\n    \n    /**\n     * The strategy used to check the project names.\n     * @return never <code>null</code>\n     */\n    public ProjectNamingStrategy getProjectNamingStrategy() {\n        return projectNamingStrategy == null ? ProjectNamingStrategy.DEFAULT_NAMING_STRATEGY : projectNamingStrategy;\n    }\n\n    /**\n     * Returns true if Hudson is quieting down.\n     * <p>\n     * No further jobs will be executed unless it\n     * can be finished while other current pending builds\n     * are still in progress.\n     */\n    @Exported\n    public boolean isQuietingDown() {\n        return isQuietingDown;\n    }\n\n    /**\n     * Returns true if the container initiated the termination of the web application.\n     */\n    public boolean isTerminating() {\n        return terminating;\n    }\n\n    /**\n     * Gets the initialization milestone that we've already reached.\n     *\n     * @return\n     *      {@link InitMilestone#STARTED} even if the initialization hasn't been started, so that this method\n     *      never returns null.\n     */\n    public InitMilestone getInitLevel() {\n        return initLevel;\n    }\n\n    public void setNumExecutors(int n) throws IOException {\n        this.numExecutors = n;\n        save();\n    }\n\n\n\n    /**\n     * {@inheritDoc}.\n     *\n     * Note that the look up is case-insensitive.\n     */\n    public TopLevelItem getItem(String name) {\n        if (name==null)    return null;\n    \tTopLevelItem item = items.get(name);\n        if (item==null)\n            return null;\n        if (!item.hasPermission(Item.READ)) {\n            if (item.hasPermission(Item.DISCOVER)) {\n                throw new AccessDeniedException(\"Please login to access job \" + name);\n            }\n            return null;\n        }\n        return item;\n    }\n\n    /**\n     * Gets the item by its path name from the given context\n     *\n     * <h2>Path Names</h2>\n     * <p>\n     * If the name starts from '/', like \"/foo/bar/zot\", then it's interpreted as absolute.\n     * Otherwise, the name should be something like \"foo/bar\" and it's interpreted like\n     * relative path name in the file system is, against the given context.\n     *\n     * @param context\n     *      null is interpreted as {@link Jenkins}. Base 'directory' of the interpretation.\n     * @since 1.406\n     */\n    public Item getItem(String pathName, ItemGroup context) {\n        if (context==null)  context = this;\n        if (pathName==null) return null;\n\n        if (pathName.startsWith(\"/\"))   // absolute\n            return getItemByFullName(pathName);\n\n        Object/*Item|ItemGroup*/ ctx = context;\n\n        StringTokenizer tokens = new StringTokenizer(pathName,\"/\");\n        while (tokens.hasMoreTokens()) {\n            String s = tokens.nextToken();\n            if (s.equals(\"..\")) {\n                if (ctx instanceof Item) {\n                    ctx = ((Item)ctx).getParent();\n                    continue;\n                }\n\n                ctx=null;    // can't go up further\n                break;\n            }\n            if (s.equals(\".\")) {\n                continue;\n            }\n\n            if (ctx instanceof ItemGroup) {\n                ItemGroup g = (ItemGroup) ctx;\n                Item i = g.getItem(s);\n                if (i==null || !i.hasPermission(Item.READ)) { // XXX consider DISCOVER\n                    ctx=null;    // can't go up further\n                    break;\n                }\n                ctx=i;\n            } else {\n                return null;\n            }\n        }\n\n        if (ctx instanceof Item)\n            return (Item)ctx;\n\n        // fall back to the classic interpretation\n        return getItemByFullName(pathName);\n    }\n\n    public final Item getItem(String pathName, Item context) {\n        return getItem(pathName,context!=null?context.getParent():null);\n    }\n\n    public final <T extends Item> T getItem(String pathName, ItemGroup context, Class<T> type) {\n        Item r = getItem(pathName, context);\n        if (type.isInstance(r))\n            return type.cast(r);\n        return null;\n    }\n\n    public final <T extends Item> T getItem(String pathName, Item context, Class<T> type) {\n        return getItem(pathName,context!=null?context.getParent():null,type);\n    }\n\n    public File getRootDirFor(TopLevelItem child) {\n        return getRootDirFor(child.getName());\n    }\n\n    private File getRootDirFor(String name) {\n        return new File(new File(getRootDir(),\"jobs\"), name);\n    }\n\n    /**\n     * Gets the {@link Item} object by its full name.\n     * Full names are like path names, where each name of {@link Item} is\n     * combined by '/'.\n     *\n     * @return\n     *      null if either such {@link Item} doesn't exist under the given full name,\n     *      or it exists but it's no an instance of the given type.\n     */\n    public @CheckForNull <T extends Item> T getItemByFullName(String fullName, Class<T> type) {\n        StringTokenizer tokens = new StringTokenizer(fullName,\"/\");\n        ItemGroup parent = this;\n\n        if(!tokens.hasMoreTokens()) return null;    // for example, empty full name.\n\n        while(true) {\n            Item item = parent.getItem(tokens.nextToken());\n            if(!tokens.hasMoreTokens()) {\n                if(type.isInstance(item))\n                    return type.cast(item);\n                else\n                    return null;\n            }\n\n            if(!(item instanceof ItemGroup))\n                return null;    // this item can't have any children\n\n            if (!item.hasPermission(Item.READ))\n                return null; // XXX consider DISCOVER\n\n            parent = (ItemGroup) item;\n        }\n    }\n\n    public @CheckForNull Item getItemByFullName(String fullName) {\n        return getItemByFullName(fullName,Item.class);\n    }\n\n    /**\n     * Gets the user of the given name.\n     *\n     * @return the user of the given name, if that person exists or the invoker {@link #hasPermission} on {@link #ADMINISTER}; else null\n     * @see User#get(String,boolean)\n     */\n    public @CheckForNull User getUser(String name) {\n        return User.get(name,hasPermission(ADMINISTER));\n    }\n\n    public synchronized TopLevelItem createProject( TopLevelItemDescriptor type, String name ) throws IOException {\n        return createProject(type, name, true);\n    }\n\n    public synchronized TopLevelItem createProject( TopLevelItemDescriptor type, String name, boolean notify ) throws IOException {\n        return itemGroupMixIn.createProject(type,name,notify);\n    }\n\n    /**\n     * Overwrites the existing item by new one.\n     *\n     * <p>\n     * This is a short cut for deleting an existing job and adding a new one.\n     */\n    public synchronized void putItem(TopLevelItem item) throws IOException, InterruptedException {\n        String name = item.getName();\n        TopLevelItem old = items.get(name);\n        if (old ==item)  return; // noop\n\n        checkPermission(Item.CREATE);\n        if (old!=null)\n            old.delete();\n        items.put(name,item);\n        ItemListener.fireOnCreated(item);\n    }\n\n    /**\n     * Creates a new job.\n     *\n     * <p>\n     * This version infers the descriptor from the type of the top-level item.\n     *\n     * @throws IllegalArgumentException\n     *      if the project of the given name already exists.\n     */\n    public synchronized <T extends TopLevelItem> T createProject( Class<T> type, String name ) throws IOException {\n        return type.cast(createProject((TopLevelItemDescriptor)getDescriptor(type),name));\n    }\n\n    /**\n     * Called by {@link Job#renameTo(String)} to update relevant data structure.\n     * assumed to be synchronized on Hudson by the caller.\n     */\n    public void onRenamed(TopLevelItem job, String oldName, String newName) throws IOException {\n        items.remove(oldName);\n        items.put(newName,job);\n\n        for (View v : views)\n            v.onJobRenamed(job, oldName, newName);\n        save();\n    }\n\n    /**\n     * Called in response to {@link Job#doDoDelete(StaplerRequest, StaplerResponse)}\n     */\n    public void onDeleted(TopLevelItem item) throws IOException {\n        for (ItemListener l : ItemListener.all())\n            l.onDeleted(item);\n\n        items.remove(item.getName());\n        for (View v : views)\n            v.onJobRenamed(item, item.getName(), null);\n        save();\n    }\n\n    public FingerprintMap getFingerprintMap() {\n        return fingerprintMap;\n    }\n\n    // if no finger print matches, display \"not found page\".\n    public Object getFingerprint( String md5sum ) throws IOException {\n        Fingerprint r = fingerprintMap.get(md5sum);\n        if(r==null)     return new NoFingerprintMatch(md5sum);\n        else            return r;\n    }\n\n    /**\n     * Gets a {@link Fingerprint} object if it exists.\n     * Otherwise null.\n     */\n    public Fingerprint _getFingerprint( String md5sum ) throws IOException {\n        return fingerprintMap.get(md5sum);\n    }\n\n    /**\n     * The file we save our configuration.\n     */\n    private XmlFile getConfigFile() {\n        return new XmlFile(XSTREAM, new File(root,\"config.xml\"));\n    }\n\n    public int getNumExecutors() {\n        return numExecutors;\n    }\n\n    public Mode getMode() {\n        return mode;\n    }\n\n    public void setMode(Mode m) throws IOException {\n        this.mode = m;\n        save();\n    }\n\n    public String getLabelString() {\n        return fixNull(label).trim();\n    }\n\n    @Override\n    public void setLabelString(String label) throws IOException {\n        this.label = label;\n        save();\n    }\n\n    @Override\n    public LabelAtom getSelfLabel() {\n        return getLabelAtom(\"master\");\n    }\n\n    public Computer createComputer() {\n        return new Hudson.MasterComputer();\n    }\n\n    private synchronized TaskBuilder loadTasks() throws IOException {\n        File projectsDir = new File(root,\"jobs\");\n        if(!projectsDir.getCanonicalFile().isDirectory() && !projectsDir.mkdirs()) {\n            if(projectsDir.exists())\n                throw new IOException(projectsDir+\" is not a directory\");\n            throw new IOException(\"Unable to create \"+projectsDir+\"\\nPermission issue? Please create this directory manually.\");\n        }\n        File[] subdirs = projectsDir.listFiles(new FileFilter() {\n            public boolean accept(File child) {\n                return child.isDirectory() && Items.getConfigFile(child).exists();\n            }\n        });\n\n        final Set<String> loadedNames = Collections.synchronizedSet(new HashSet<String>());\n\n        TaskGraphBuilder g = new TaskGraphBuilder();\n        Handle loadHudson = g.requires(EXTENSIONS_AUGMENTED).attains(JOB_LOADED).add(\"Loading global config\", new Executable() {\n            public void run(Reactor session) throws Exception {\n                // JENKINS-8043: some slaves (eg. swarm slaves) are not saved into the config file\n                // and will get overwritten when reloading. Make a backup copy now, and re-add them later\n                NodeList oldSlaves = slaves;\n                \n                XmlFile cfg = getConfigFile();\n                if (cfg.exists()) {\n                    // reset some data that may not exist in the disk file\n                    // so that we can take a proper compensation action later.\n                    primaryView = null;\n                    views.clear();\n\n                    // load from disk\n                    cfg.unmarshal(Jenkins.this);\n                }\n\n                // if we are loading old data that doesn't have this field\n                if (slaves == null) slaves = new NodeList();\n\n                clouds.setOwner(Jenkins.this);\n\n                // JENKINS-8043: re-add the slaves which were not saved into the config file\n                // and are now missing, but still connected.\n                if (oldSlaves != null) {\n                    ArrayList<Node> newSlaves = new ArrayList<Node>(slaves);\n                    for (Node n: oldSlaves) {\n                        if (n instanceof EphemeralNode) {\n                            if(!newSlaves.contains(n)) {\n                                newSlaves.add(n);\n                            }\n                        }\n                    }\n                    setNodes(newSlaves);\n                }\n            }\n        });\n\n        for (final File subdir : subdirs) {\n            g.requires(loadHudson).attains(JOB_LOADED).notFatal().add(\"Loading job \"+subdir.getName(),new Executable() {\n                public void run(Reactor session) throws Exception {\n                    TopLevelItem item = (TopLevelItem) Items.load(Jenkins.this, subdir);\n                    items.put(item.getName(), item);\n                    loadedNames.add(item.getName());\n                }\n            });\n        }\n\n        g.requires(JOB_LOADED).add(\"Cleaning up old builds\",new Executable() {\n            public void run(Reactor reactor) throws Exception {\n                // anything we didn't load from disk, throw them away.\n                // doing this after loading from disk allows newly loaded items\n                // to inspect what already existed in memory (in case of reloading)\n\n                // retainAll doesn't work well because of CopyOnWriteMap implementation, so remove one by one\n                // hopefully there shouldn't be too many of them.\n                for (String name : items.keySet()) {\n                    if (!loadedNames.contains(name))\n                        items.remove(name);\n                }\n            }\n        });\n\n        g.requires(JOB_LOADED).add(\"Finalizing set up\",new Executable() {\n            public void run(Reactor session) throws Exception {\n                rebuildDependencyGraph();\n\n                {// recompute label objects - populates the labels mapping.\n                    for (Node slave : slaves)\n                        // Note that not all labels are visible until the slaves have connected.\n                        slave.getAssignedLabels();\n                    getAssignedLabels();\n                }\n\n                // initialize views by inserting the default view if necessary\n                // this is both for clean Hudson and for backward compatibility.\n                if(views.size()==0 || primaryView==null) {\n                    View v = new AllView(Messages.Hudson_ViewName());\n                    setViewOwner(v);\n                    views.add(0,v);\n                    primaryView = v.getViewName();\n                }\n\n                // read in old data that doesn't have the security field set\n                if(authorizationStrategy==null) {\n                    if(useSecurity==null || !useSecurity)\n                        authorizationStrategy = AuthorizationStrategy.UNSECURED;\n                    else\n                        authorizationStrategy = new LegacyAuthorizationStrategy();\n                }\n                if(securityRealm==null) {\n                    if(useSecurity==null || !useSecurity)\n                        setSecurityRealm(SecurityRealm.NO_AUTHENTICATION);\n                    else\n                        setSecurityRealm(new LegacySecurityRealm());\n                } else {\n                    // force the set to proxy\n                    setSecurityRealm(securityRealm);\n                }\n\n                if(useSecurity!=null && !useSecurity) {\n                    // forced reset to the unsecure mode.\n                    // this works as an escape hatch for people who locked themselves out.\n                    authorizationStrategy = AuthorizationStrategy.UNSECURED;\n                    setSecurityRealm(SecurityRealm.NO_AUTHENTICATION);\n                }\n\n                // Initialize the filter with the crumb issuer\n                setCrumbIssuer(crumbIssuer);\n\n                // auto register root actions\n                for (Action a : getExtensionList(RootAction.class))\n                    if (!actions.contains(a)) actions.add(a);\n            }\n        });\n\n        return g;\n    }\n\n    /**\n     * Save the settings to a file.\n     */\n    public synchronized void save() throws IOException {\n        if(BulkChange.contains(this))   return;\n        getConfigFile().write(this);\n        SaveableListener.fireOnChange(this, getConfigFile());\n    }\n\n\n    /**\n     * Called to shut down the system.\n     */\n    @edu.umd.cs.findbugs.annotations.SuppressWarnings(\"ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD\")\n    public void cleanUp() {\n        for (ItemListener l : ItemListener.all())\n            l.onBeforeShutdown();\n\n        Set<Future<?>> pending = new HashSet<Future<?>>();\n        terminating = true;\n        for( Computer c : computers.values() ) {\n            c.interrupt();\n            killComputer(c);\n            pending.add(c.disconnect(null));\n        }\n        if(udpBroadcastThread!=null)\n            udpBroadcastThread.shutdown();\n        if(dnsMultiCast!=null)\n            dnsMultiCast.close();\n        interruptReloadThread();\n        Timer timer = Trigger.timer;\n        if (timer != null) {\n            timer.cancel();\n        }\n        // TODO: how to wait for the completion of the last job?\n        Trigger.timer = null;\n        if(tcpSlaveAgentListener!=null)\n            tcpSlaveAgentListener.shutdown();\n\n        if(pluginManager!=null) // be defensive. there could be some ugly timing related issues\n            pluginManager.stop();\n\n        if(getRootDir().exists())\n            // if we are aborting because we failed to create JENKINS_HOME,\n            // don't try to save. Issue #536\n            getQueue().save();\n\n        threadPoolForLoad.shutdown();\n        for (Future<?> f : pending)\n            try {\n                f.get(10, TimeUnit.SECONDS);    // if clean up operation didn't complete in time, we fail the test\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                break;  // someone wants us to die now. quick!\n            } catch (ExecutionException e) {\n                LOGGER.log(Level.WARNING, \"Failed to shut down properly\",e);\n            } catch (TimeoutException e) {\n                LOGGER.log(Level.WARNING, \"Failed to shut down properly\",e);\n            }\n\n        LogFactory.releaseAll();\n\n        theInstance = null;\n    }\n\n    public Object getDynamic(String token) {\n        for (Action a : getActions()) {\n            String url = a.getUrlName();\n            if (url==null)  continue;\n            if (url.equals(token) || url.equals('/' + token))\n                return a;\n        }\n        for (Action a : getManagementLinks())\n            if(a.getUrlName().equals(token))\n                return a;\n        return null;\n    }\n\n\n//\n//\n// actions\n//\n//\n    /**\n     * Accepts submission from the configuration page.\n     */\n    public synchronized void doConfigSubmit( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException, FormException {\n        BulkChange bc = new BulkChange(this);\n        try {\n            checkPermission(ADMINISTER);\n\n            JSONObject json = req.getSubmittedForm();\n\n            workspaceDir = json.getString(\"rawWorkspaceDir\");\n            buildsDir = json.getString(\"rawBuildsDir\");\n\n            systemMessage = Util.nullify(req.getParameter(\"system_message\"));\n\n            jdks.clear();\n            jdks.addAll(req.bindJSONToList(JDK.class,json.get(\"jdks\")));\n\n            boolean result = true;\n            for (Descriptor<?> d : Functions.getSortedDescriptorsForGlobalConfigUnclassified())\n                result &= configureDescriptor(req,json,d);\n\n            version = VERSION;\n\n            save();\n            updateComputerList();\n            if(result)\n                FormApply.success(req.getContextPath()+'/').generateResponse(req, rsp, null);\n            else\n                FormApply.success(\"configure\").generateResponse(req, rsp, null);    // back to config\n        } finally {\n            bc.commit();\n        }\n    }\n\n    /**\n     * Gets the {@link CrumbIssuer} currently in use.\n     *\n     * @return null if none is in use.\n     */\n    public CrumbIssuer getCrumbIssuer() {\n        return crumbIssuer;\n    }\n\n    public void setCrumbIssuer(CrumbIssuer issuer) {\n        crumbIssuer = issuer;\n    }\n\n    public synchronized void doTestPost( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        rsp.sendRedirect(\"foo\");\n    }\n\n    private boolean configureDescriptor(StaplerRequest req, JSONObject json, Descriptor<?> d) throws FormException {\n        // collapse the structure to remain backward compatible with the JSON structure before 1.\n        String name = d.getJsonSafeClassName();\n        JSONObject js = json.has(name) ? json.getJSONObject(name) : new JSONObject(); // if it doesn't have the property, the method returns invalid null object.\n        json.putAll(js);\n        return d.configure(req, js);\n    }\n\n    /**\n     * Accepts submission from the node configuration page.\n     */\n    public synchronized void doConfigExecutorsSubmit( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException, FormException {\n        checkPermission(ADMINISTER);\n\n        BulkChange bc = new BulkChange(this);\n        try {\n            JSONObject json = req.getSubmittedForm();\n\n            MasterBuildConfiguration mbc = MasterBuildConfiguration.all().get(MasterBuildConfiguration.class);\n            if (mbc!=null)\n                mbc.configure(req,json);\n\n            getNodeProperties().rebuild(req, json.optJSONObject(\"nodeProperties\"), NodeProperty.all());\n        } finally {\n            bc.commit();\n        }\n\n        rsp.sendRedirect(req.getContextPath()+'/'+toComputer().getUrl());  // back to the computer page\n    }\n\n    /**\n     * Accepts the new description.\n     */\n    public synchronized void doSubmitDescription( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        getPrimaryView().doSubmitDescription(req, rsp);\n    }\n\n    public synchronized HttpRedirect doQuietDown() throws IOException {\n        try {\n            return doQuietDown(false,0);\n        } catch (InterruptedException e) {\n            throw new AssertionError(); // impossible\n        }\n    }\n\n    @CLIMethod(name=\"quiet-down\")\n    public HttpRedirect doQuietDown(\n            @Option(name=\"-block\",usage=\"Block until the system really quiets down and no builds are running\") @QueryParameter boolean block,\n            @Option(name=\"-timeout\",usage=\"If non-zero, only block up to the specified number of milliseconds\") @QueryParameter int timeout) throws InterruptedException, IOException {\n        synchronized (this) {\n            checkPermission(ADMINISTER);\n            isQuietingDown = true;\n        }\n        if (block) {\n            if (timeout > 0) timeout += System.currentTimeMillis();\n            while (isQuietingDown\n                   && (timeout <= 0 || System.currentTimeMillis() < timeout)\n                   && !RestartListener.isAllReady()) {\n                Thread.sleep(1000);\n            }\n        }\n        return new HttpRedirect(\".\");\n    }\n\n    @CLIMethod(name=\"cancel-quiet-down\")\n    public synchronized HttpRedirect doCancelQuietDown() {\n        checkPermission(ADMINISTER);\n        isQuietingDown = false;\n        getQueue().scheduleMaintenance();\n        return new HttpRedirect(\".\");\n    }\n\n    /**\n     * Backward compatibility. Redirect to the thread dump.\n     */\n    public void doClassicThreadDump(StaplerResponse rsp) throws IOException, ServletException {\n        rsp.sendRedirect2(\"threadDump\");\n    }\n\n    /**\n     * Obtains the thread dump of all slaves (including the master.)\n     *\n     * <p>\n     * Since this is for diagnostics, it has a built-in precautionary measure against hang slaves.\n     */\n    public Map<String,Map<String,String>> getAllThreadDumps() throws IOException, InterruptedException {\n        checkPermission(ADMINISTER);\n\n        // issue the requests all at once\n        Map<String,Future<Map<String,String>>> future = new HashMap<String, Future<Map<String, String>>>();\n\n        for (Computer c : getComputers()) {\n            try {\n                future.put(c.getName(), RemotingDiagnostics.getThreadDumpAsync(c.getChannel()));\n            } catch(Exception e) {\n                LOGGER.info(\"Failed to get thread dump for node \" + c.getName() + \": \" + e.getMessage());\n            }\n        }\n\t\tif (toComputer() == null) {\n\t\t\tfuture.put(\"master\", RemotingDiagnostics.getThreadDumpAsync(MasterComputer.localChannel));\n\t\t}\n\n        // if the result isn't available in 5 sec, ignore that.\n        // this is a precaution against hang nodes\n        long endTime = System.currentTimeMillis() + 5000;\n\n        Map<String,Map<String,String>> r = new HashMap<String, Map<String, String>>();\n        for (Entry<String, Future<Map<String, String>>> e : future.entrySet()) {\n            try {\n                r.put(e.getKey(), e.getValue().get(endTime-System.currentTimeMillis(), TimeUnit.MILLISECONDS));\n            } catch (Exception x) {\n                StringWriter sw = new StringWriter();\n                x.printStackTrace(new PrintWriter(sw,true));\n                r.put(e.getKey(), Collections.singletonMap(\"Failed to retrieve thread dump\",sw.toString()));\n            }\n        }\n        return r;\n    }\n\n    public synchronized TopLevelItem doCreateItem( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        return itemGroupMixIn.createTopLevelItem(req, rsp);\n    }\n\n    /**\n     * @since 1.319\n     */\n    public TopLevelItem createProjectFromXML(String name, InputStream xml) throws IOException {\n        return itemGroupMixIn.createProjectFromXML(name, xml);\n    }\n\n\n    @SuppressWarnings({\"unchecked\"})\n    public <T extends TopLevelItem> T copy(T src, String name) throws IOException {\n        return itemGroupMixIn.copy(src, name);\n    }\n\n    // a little more convenient overloading that assumes the caller gives us the right type\n    // (or else it will fail with ClassCastException)\n    public <T extends AbstractProject<?,?>> T copy(T src, String name) throws IOException {\n        return (T)copy((TopLevelItem)src,name);\n    }\n\n    public synchronized void doCreateView( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException, FormException {\n        checkPermission(View.CREATE);\n        addView(View.create(req,rsp, this));\n    }\n\n    /**\n     * Check if the given name is suitable as a name\n     * for job, view, etc.\n     *\n     * @throws Failure\n     *      if the given name is not good\n     */\n    public static void checkGoodName(String name) throws Failure {\n        if(name==null || name.length()==0)\n            throw new Failure(Messages.Hudson_NoName());\n\n        if(\"..\".equals(name.trim())) \n            throw new Failure(Messages.Jenkins_NotAllowedName(\"..\"));\n        for( int i=0; i<name.length(); i++ ) {\n            char ch = name.charAt(i);\n            if(Character.isISOControl(ch)) {\n                throw new Failure(Messages.Hudson_ControlCodeNotAllowed(toPrintableName(name)));\n            }\n            if(\"?*/\\\\%!@#$^&|<>[]:;\".indexOf(ch)!=-1)\n                throw new Failure(Messages.Hudson_UnsafeChar(ch));\n        }\n\n        // looks good\n    }\n\n    /**\n     * Makes sure that the given name is good as a job name.\n     * @return trimmed name if valid; throws Failure if not\n     */\n    private String checkJobName(String name) throws Failure {\n        checkGoodName(name);\n        name = name.trim();\n        projectNamingStrategy.checkName(name);\n        if(getItem(name)!=null)\n            throw new Failure(Messages.Hudson_JobAlreadyExists(name));\n        // looks good\n        return name;\n    }\n\n    private static String toPrintableName(String name) {\n        StringBuilder printableName = new StringBuilder();\n        for( int i=0; i<name.length(); i++ ) {\n            char ch = name.charAt(i);\n            if(Character.isISOControl(ch))\n                printableName.append(\"\\\\u\").append((int)ch).append(';');\n            else\n                printableName.append(ch);\n        }\n        return printableName.toString();\n    }\n\n    /**\n     * Checks if the user was successfully authenticated.\n     *\n     * @see BasicAuthenticationFilter\n     */\n    public void doSecured( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        if(req.getUserPrincipal()==null) {\n            // authentication must have failed\n            rsp.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\n            return;\n        }\n\n        // the user is now authenticated, so send him back to the target\n        String path = req.getContextPath()+req.getOriginalRestOfPath();\n        String q = req.getQueryString();\n        if(q!=null)\n            path += '?'+q;\n\n        rsp.sendRedirect2(path);\n    }\n\n    /**\n     * Called once the user logs in. Just forward to the top page.\n     */\n    public void doLoginEntry( StaplerRequest req, StaplerResponse rsp ) throws IOException {\n        if(req.getUserPrincipal()==null) {\n            rsp.sendRedirect2(\"noPrincipal\");\n            return;\n        }\n\n        String from = req.getParameter(\"from\");\n        if(from!=null && from.startsWith(\"/\") && !from.equals(\"/loginError\")) {\n            rsp.sendRedirect2(from);    // I'm bit uncomfortable letting users redircted to other sites, make sure the URL falls into this domain\n            return;\n        }\n\n        String url = AbstractProcessingFilter.obtainFullRequestUrl(req);\n        if(url!=null) {\n            // if the login redirect is initiated by Acegi\n            // this should send the user back to where s/he was from.\n            rsp.sendRedirect2(url);\n            return;\n        }\n\n        rsp.sendRedirect2(\".\");\n    }\n\n    /**\n     * Logs out the user.\n     */\n    public void doLogout( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        securityRealm.doLogout(req, rsp);\n    }\n\n    /**\n     * Serves jar files for JNLP slave agents.\n     */\n    public Slave.JnlpJar getJnlpJars(String fileName) {\n        return new Slave.JnlpJar(fileName);\n    }\n\n    public Slave.JnlpJar doJnlpJars(StaplerRequest req) {\n        return new Slave.JnlpJar(req.getRestOfPath().substring(1));\n    }\n\n    /**\n     * Reloads the configuration.\n     */\n    @CLIMethod(name=\"reload-configuration\")\n    public synchronized HttpResponse doReload() throws IOException {\n        checkPermission(ADMINISTER);\n\n        // engage \"loading ...\" UI and then run the actual task in a separate thread\n        servletContext.setAttribute(\"app\", new HudsonIsLoading());\n\n        new Thread(\"Jenkins config reload thread\") {\n            @Override\n            public void run() {\n                try {\n                    ACL.impersonate(ACL.SYSTEM);\n                    reload();\n                } catch (Exception e) {\n                    LOGGER.log(SEVERE,\"Failed to reload Jenkins config\",e);\n                    WebApp.get(servletContext).setApp(new JenkinsReloadFailed(e));\n                }\n            }\n        }.start();\n\n        return HttpResponses.redirectViaContextPath(\"/\");\n    }\n\n    /**\n     * Reloads the configuration synchronously.\n     */\n    public void reload() throws IOException, InterruptedException, ReactorException {\n        executeReactor(null, loadTasks());\n        User.reload();\n        servletContext.setAttribute(\"app\", this);\n    }\n\n    /**\n     * Do a finger-print check.\n     */\n    public void doDoFingerprintCheck( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        // Parse the request\n        MultipartFormDataParser p = new MultipartFormDataParser(req);\n        if(isUseCrumbs() && !getCrumbIssuer().validateCrumb(req, p)) {\n            rsp.sendError(HttpServletResponse.SC_FORBIDDEN,\"No crumb found\");\n        }\n        try {\n            rsp.sendRedirect2(req.getContextPath()+\"/fingerprint/\"+\n                Util.getDigestOf(p.getFileItem(\"name\").getInputStream())+'/');\n        } finally {\n            p.cleanUp();\n        }\n    }\n\n    /**\n     * For debugging. Expose URL to perform GC.\n     */\n    @edu.umd.cs.findbugs.annotations.SuppressWarnings(\"DM_GC\")\n    public void doGc(StaplerResponse rsp) throws IOException {\n        checkPermission(Jenkins.ADMINISTER);\n        System.gc();\n        rsp.setStatus(HttpServletResponse.SC_OK);\n        rsp.setContentType(\"text/plain\");\n        rsp.getWriter().println(\"GCed\");\n    }\n\n    /**\n     * End point that intentionally throws an exception to test the error behaviour.\n     */\n    public void doException() {\n        throw new RuntimeException();\n    }\n\n    public ContextMenu doContextMenu(StaplerRequest request, StaplerResponse response) throws IOException, JellyException {\n        ContextMenu menu = new ContextMenu().from(this, request, response);\n        for (MenuItem i : menu.items) {\n            if (i.url.equals(request.getContextPath() + \"/manage\")) {\n                // add \"Manage Jenkins\" subitems\n                i.subMenu = new ContextMenu().from(this, request, response, \"manage\");\n            }\n        }\n        return menu;\n    }\n\n    /**\n     * Obtains the heap dump.\n     */\n    public HeapDump getHeapDump() throws IOException {\n        return new HeapDump(this,MasterComputer.localChannel);\n    }\n\n    /**\n     * Simulates OutOfMemoryError.\n     * Useful to make sure OutOfMemoryHeapDump setting.\n     */\n    public void doSimulateOutOfMemory() throws IOException {\n        checkPermission(ADMINISTER);\n\n        System.out.println(\"Creating artificial OutOfMemoryError situation\");\n        List<Object> args = new ArrayList<Object>();\n        while (true)\n            args.add(new byte[1024*1024]);\n    }\n\n    private transient final Map<UUID,FullDuplexHttpChannel> duplexChannels = new HashMap<UUID, FullDuplexHttpChannel>();\n\n    /**\n     * Handles HTTP requests for duplex channels for CLI.\n     */\n    public void doCli(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException, InterruptedException {\n        if (!\"POST\".equals(req.getMethod())) {\n            // for GET request, serve _cli.jelly, assuming this is a browser\n            checkPermission(READ);\n            req.getView(this,\"_cli.jelly\").forward(req,rsp);\n            return;\n        }\n\n        // do not require any permission to establish a CLI connection\n        // the actual authentication for the connecting Channel is done by CLICommand\n\n        UUID uuid = UUID.fromString(req.getHeader(\"Session\"));\n        rsp.setHeader(\"Hudson-Duplex\",\"\"); // set the header so that the client would know\n\n        FullDuplexHttpChannel server;\n        if(req.getHeader(\"Side\").equals(\"download\")) {\n            duplexChannels.put(uuid,server=new FullDuplexHttpChannel(uuid, !hasPermission(ADMINISTER)) {\n                protected void main(Channel channel) throws IOException, InterruptedException {\n                    // capture the identity given by the transport, since this can be useful for SecurityRealm.createCliAuthenticator()\n                    channel.setProperty(CLICommand.TRANSPORT_AUTHENTICATION,getAuthentication());\n                    channel.setProperty(CliEntryPoint.class.getName(),new CliManagerImpl(channel));\n                }\n            });\n            try {\n                server.download(req,rsp);\n            } finally {\n                duplexChannels.remove(uuid);\n            }\n        } else {\n            duplexChannels.get(uuid).upload(req,rsp);\n        }\n    }\n\n    /**\n     * Binds /userContent/... to $JENKINS_HOME/userContent.\n     */\n    public DirectoryBrowserSupport doUserContent() {\n        return new DirectoryBrowserSupport(this,getRootPath().child(\"userContent\"),\"User content\",\"folder.png\",true);\n    }\n\n    /**\n     * Perform a restart of Hudson, if we can.\n     *\n     * This first replaces \"app\" to {@link HudsonIsRestarting}\n     */\n    @CLIMethod(name=\"restart\")\n    public void doRestart(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException, RestartNotSupportedException {\n        checkPermission(ADMINISTER);\n        if (req != null && req.getMethod().equals(\"GET\")) {\n            req.getView(this,\"_restart.jelly\").forward(req,rsp);\n            return;\n        }\n\n        restart();\n\n        if (rsp != null) // null for CLI\n            rsp.sendRedirect2(\".\");\n    }\n\n    /**\n     * Queues up a restart of Hudson for when there are no builds running, if we can.\n     *\n     * This first replaces \"app\" to {@link HudsonIsRestarting}\n     *\n     * @since 1.332\n     */\n    @CLIMethod(name=\"safe-restart\")\n    public HttpResponse doSafeRestart(StaplerRequest req) throws IOException, ServletException, RestartNotSupportedException {\n        checkPermission(ADMINISTER);\n        if (req != null && req.getMethod().equals(\"GET\"))\n            return HttpResponses.forwardToView(this,\"_safeRestart.jelly\");\n\n        safeRestart();\n\n        return HttpResponses.redirectToDot();\n    }\n\n    /**\n     * Performs a restart.\n     */\n    public void restart() throws RestartNotSupportedException {\n        final Lifecycle lifecycle = Lifecycle.get();\n        lifecycle.verifyRestartable(); // verify that Hudson is restartable\n        servletContext.setAttribute(\"app\", new HudsonIsRestarting());\n\n        new Thread(\"restart thread\") {\n            final String exitUser = getAuthentication().getName();\n            @Override\n            public void run() {\n                try {\n                    ACL.impersonate(ACL.SYSTEM);\n\n                    // give some time for the browser to load the \"reloading\" page\n                    Thread.sleep(5000);\n                    LOGGER.severe(String.format(\"Restarting VM as requested by %s\",exitUser));\n                    for (RestartListener listener : RestartListener.all())\n                        listener.onRestart();\n                    lifecycle.restart();\n                } catch (InterruptedException e) {\n                    LOGGER.log(Level.WARNING, \"Failed to restart Hudson\",e);\n                } catch (IOException e) {\n                    LOGGER.log(Level.WARNING, \"Failed to restart Hudson\",e);\n                }\n            }\n        }.start();\n    }\n\n    /**\n     * Queues up a restart to be performed once there are no builds currently running.\n     * @since 1.332\n     */\n    public void safeRestart() throws RestartNotSupportedException {\n        final Lifecycle lifecycle = Lifecycle.get();\n        lifecycle.verifyRestartable(); // verify that Hudson is restartable\n        // Quiet down so that we won't launch new builds.\n        isQuietingDown = true;\n\n        new Thread(\"safe-restart thread\") {\n            final String exitUser = getAuthentication().getName();\n            @Override\n            public void run() {\n                try {\n                    ACL.impersonate(ACL.SYSTEM);\n\n                    // Wait 'til we have no active executors.\n                    doQuietDown(true, 0);\n\n                    // Make sure isQuietingDown is still true.\n                    if (isQuietingDown) {\n                        servletContext.setAttribute(\"app\",new HudsonIsRestarting());\n                        // give some time for the browser to load the \"reloading\" page\n                        LOGGER.info(\"Restart in 10 seconds\");\n                        Thread.sleep(10000);\n                        LOGGER.severe(String.format(\"Restarting VM as requested by %s\",exitUser));\n                        for (RestartListener listener : RestartListener.all())\n                            listener.onRestart();\n                        lifecycle.restart();\n                    } else {\n                        LOGGER.info(\"Safe-restart mode cancelled\");\n                    }\n                } catch (InterruptedException e) {\n                    LOGGER.log(Level.WARNING, \"Failed to restart Hudson\",e);\n                } catch (IOException e) {\n                    LOGGER.log(Level.WARNING, \"Failed to restart Hudson\",e);\n                }\n            }\n        }.start();\n    }\n\n    /**\n     * Shutdown the system.\n     * @since 1.161\n     */\n    @CLIMethod(name=\"shutdown\")\n    public void doExit( StaplerRequest req, StaplerResponse rsp ) throws IOException {\n        checkPermission(ADMINISTER);\n        LOGGER.severe(String.format(\"Shutting down VM as requested by %s from %s\",\n                getAuthentication().getName(), req!=null?req.getRemoteAddr():\"???\"));\n        if (rsp!=null) {\n            rsp.setStatus(HttpServletResponse.SC_OK);\n            rsp.setContentType(\"text/plain\");\n            PrintWriter w = rsp.getWriter();\n            w.println(\"Shutting down\");\n            w.close();\n        }\n\n        System.exit(0);\n    }\n\n\n    /**\n     * Shutdown the system safely.\n     * @since 1.332\n     */\n    @CLIMethod(name=\"safe-shutdown\")\n    public HttpResponse doSafeExit(StaplerRequest req) throws IOException {\n        checkPermission(ADMINISTER);\n        isQuietingDown = true;\n        final String exitUser = getAuthentication().getName();\n        final String exitAddr = req!=null ? req.getRemoteAddr() : \"unknown\";\n        new Thread(\"safe-exit thread\") {\n            @Override\n            public void run() {\n                try {\n                    ACL.impersonate(ACL.SYSTEM);\n                    LOGGER.severe(String.format(\"Shutting down VM as requested by %s from %s\",\n                                                exitUser, exitAddr));\n                    // Wait 'til we have no active executors.\n                    while (isQuietingDown\n                           && (overallLoad.computeTotalExecutors() > overallLoad.computeIdleExecutors())) {\n                        Thread.sleep(5000);\n                    }\n                    // Make sure isQuietingDown is still true.\n                    if (isQuietingDown) {\n                        cleanUp();\n                        System.exit(0);\n                    }\n                } catch (InterruptedException e) {\n                    LOGGER.log(Level.WARNING, \"Failed to shutdown Hudson\",e);\n                }\n            }\n        }.start();\n\n        return HttpResponses.plainText(\"Shutting down as soon as all jobs are complete\");\n    }\n\n    /**\n     * Gets the {@link Authentication} object that represents the user\n     * associated with the current request.\n     */\n    public static Authentication getAuthentication() {\n        Authentication a = SecurityContextHolder.getContext().getAuthentication();\n        // on Tomcat while serving the login page, this is null despite the fact\n        // that we have filters. Looking at the stack trace, Tomcat doesn't seem to\n        // run the request through filters when this is the login request.\n        // see http://www.nabble.com/Matrix-authorization-problem-tp14602081p14886312.html\n        if(a==null)\n            a = ANONYMOUS;\n        return a;\n    }\n\n    /**\n     * For system diagnostics.\n     * Run arbitrary Groovy script.\n     */\n    public void doScript(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        doScript(req, rsp, req.getView(this, \"_script.jelly\"));\n    }\n\n    /**\n     * Run arbitrary Groovy script and return result as plain text.\n     */\n    public void doScriptText(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        doScript(req, rsp, req.getView(this, \"_scriptText.jelly\"));\n    }\n\n    private void doScript(StaplerRequest req, StaplerResponse rsp, RequestDispatcher view) throws IOException, ServletException {\n        // ability to run arbitrary script is dangerous\n        checkPermission(RUN_SCRIPTS);\n\n        String text = req.getParameter(\"script\");\n        if (text != null) {\n            try {\n                req.setAttribute(\"output\",\n                        RemotingDiagnostics.executeGroovy(text, MasterComputer.localChannel));\n            } catch (InterruptedException e) {\n                throw new ServletException(e);\n            }\n        }\n\n        view.forward(req, rsp);\n    }\n\n    /**\n     * Evaluates the Jelly script submitted by the client.\n     *\n     * This is useful for system administration as well as unit testing.\n     */\n    @RequirePOST\n    public void doEval(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        checkPermission(ADMINISTER);\n\n        try {\n            MetaClass mc = WebApp.getCurrent().getMetaClass(getClass());\n            Script script = mc.classLoader.loadTearOff(JellyClassLoaderTearOff.class).createContext().compileScript(new InputSource(req.getReader()));\n            new JellyRequestDispatcher(this,script).forward(req,rsp);\n        } catch (JellyException e) {\n            throw new ServletException(e);\n        }\n    }\n\n    /**\n     * Sign up for the user account.\n     */\n    public void doSignup( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        req.getView(getSecurityRealm(), \"signup.jelly\").forward(req, rsp);\n    }\n\n    /**\n     * Changes the icon size by changing the cookie\n     */\n    public void doIconSize( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        String qs = req.getQueryString();\n        if(qs==null)\n            throw new ServletException();\n        Cookie cookie = new Cookie(\"iconSize\", Functions.validateIconSize(qs));\n        cookie.setMaxAge(/* ~4 mo. */9999999); // #762\n        rsp.addCookie(cookie);\n        String ref = req.getHeader(\"Referer\");\n        if(ref==null)   ref=\".\";\n        rsp.sendRedirect2(ref);\n    }\n\n    public void doFingerprintCleanup(StaplerResponse rsp) throws IOException {\n        FingerprintCleanupThread.invoke();\n        rsp.setStatus(HttpServletResponse.SC_OK);\n        rsp.setContentType(\"text/plain\");\n        rsp.getWriter().println(\"Invoked\");\n    }\n\n    public void doWorkspaceCleanup(StaplerResponse rsp) throws IOException {\n        WorkspaceCleanupThread.invoke();\n        rsp.setStatus(HttpServletResponse.SC_OK);\n        rsp.setContentType(\"text/plain\");\n        rsp.getWriter().println(\"Invoked\");\n    }\n\n    /**\n     * If the user chose the default JDK, make sure we got 'java' in PATH.\n     */\n    public FormValidation doDefaultJDKCheck(StaplerRequest request, @QueryParameter String value) {\n        if(!value.equals(\"(Default)\"))\n            // assume the user configured named ones properly in system config ---\n            // or else system config should have reported form field validation errors.\n            return FormValidation.ok();\n\n        // default JDK selected. Does such java really exist?\n        if(JDK.isDefaultJDKValid(Jenkins.this))\n            return FormValidation.ok();\n        else\n            return FormValidation.errorWithMarkup(Messages.Hudson_NoJavaInPath(request.getContextPath()));\n    }\n\n    /**\n     * Makes sure that the given name is good as a job name.\n     */\n    public FormValidation doCheckJobName(@QueryParameter String value) {\n        // this method can be used to check if a file exists anywhere in the file system,\n        // so it should be protected.\n        checkPermission(Item.CREATE);\n\n        if(fixEmpty(value)==null)\n            return FormValidation.ok();\n\n        try {\n            checkJobName(value);\n            return FormValidation.ok();\n        } catch (Failure e) {\n            return FormValidation.error(e.getMessage());\n        }\n    }\n\n    /**\n     * Checks if a top-level view with the given name exists.\n     */\n    public FormValidation doViewExistsCheck(@QueryParameter String value) {\n        checkPermission(View.CREATE);\n\n        String view = fixEmpty(value);\n        if(view==null) return FormValidation.ok();\n\n        if(getView(view)==null)\n            return FormValidation.ok();\n        else\n            return FormValidation.error(Messages.Hudson_ViewAlreadyExists(view));\n    }\n\n    /**\n     * Serves static resources placed along with Jelly view files.\n     * <p>\n     * This method can serve a lot of files, so care needs to be taken\n     * to make this method secure. It's not clear to me what's the best\n     * strategy here, though the current implementation is based on\n     * file extensions.\n     */\n    public void doResources(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        String path = req.getRestOfPath();\n        // cut off the \"...\" portion of /resources/.../path/to/file\n        // as this is only used to make path unique (which in turn\n        // allows us to set a long expiration date\n        path = path.substring(path.indexOf('/',1)+1);\n\n        int idx = path.lastIndexOf('.');\n        String extension = path.substring(idx+1);\n        if(ALLOWED_RESOURCE_EXTENSIONS.contains(extension)) {\n            URL url = pluginManager.uberClassLoader.getResource(path);\n            if(url!=null) {\n                long expires = MetaClass.NO_CACHE ? 0 : 365L * 24 * 60 * 60 * 1000; /*1 year*/\n                rsp.serveFile(req,url,expires);\n                return;\n            }\n        }\n        rsp.sendError(HttpServletResponse.SC_NOT_FOUND);\n    }\n\n    /**\n     * Extension list that {@link #doResources(StaplerRequest, StaplerResponse)} can serve.\n     * This set is mutable to allow plugins to add additional extensions.\n     */\n    public static final Set<String> ALLOWED_RESOURCE_EXTENSIONS = new HashSet<String>(Arrays.asList(\n        \"js|css|jpeg|jpg|png|gif|html|htm\".split(\"\\\\|\")\n    ));\n\n    /**\n     * Checks if container uses UTF-8 to decode URLs. See\n     * http://wiki.jenkins-ci.org/display/JENKINS/Tomcat#Tomcat-i18n\n     */\n    public FormValidation doCheckURIEncoding(StaplerRequest request) throws IOException {\n        // expected is non-ASCII String\n        final String expected = \"\\u57f7\\u4e8b\";\n        final String value = fixEmpty(request.getParameter(\"value\"));\n        if (!expected.equals(value))\n            return FormValidation.warningWithMarkup(Messages.Hudson_NotUsesUTF8ToDecodeURL());\n        return FormValidation.ok();\n    }\n\n    /**\n     * Does not check when system default encoding is \"ISO-8859-1\".\n     */\n    public static boolean isCheckURIEncodingEnabled() {\n        return !\"ISO-8859-1\".equalsIgnoreCase(System.getProperty(\"file.encoding\"));\n    }\n\n    /**\n     * Rebuilds the dependency map.\n     */\n    public void rebuildDependencyGraph() {\n        DependencyGraph graph = new DependencyGraph();\n        graph.build();\n        // volatile acts a as a memory barrier here and therefore guarantees \n        // that graph is fully build, before it's visible to other threads\n        dependencyGraph = graph;\n    }\n\n    public DependencyGraph getDependencyGraph() {\n        return dependencyGraph;\n    }\n\n    // for Jelly\n    public List<ManagementLink> getManagementLinks() {\n        return ManagementLink.all();\n    }\n\n    /**\n     * Exposes the current user to <tt>/me</tt> URL.\n     */\n    public User getMe() {\n        User u = User.current();\n        if (u == null)\n            throw new AccessDeniedException(\"/me is not available when not logged in\");\n        return u;\n    }\n\n    /**\n     * Gets the {@link Widget}s registered on this object.\n     *\n     * <p>\n     * Plugins who wish to contribute boxes on the side panel can add widgets\n     * by {@code getWidgets().add(new MyWidget())} from {@link Plugin#start()}.\n     */\n    public List<Widget> getWidgets() {\n        return widgets;\n    }\n\n    public Object getTarget() {\n        try {\n            checkPermission(READ);\n        } catch (AccessDeniedException e) {\n            String rest = Stapler.getCurrentRequest().getRestOfPath();\n            if(rest.startsWith(\"/login\")\n            || rest.startsWith(\"/logout\")\n            || rest.startsWith(\"/accessDenied\")\n            || rest.startsWith(\"/adjuncts/\")\n            || rest.startsWith(\"/signup\")\n            || rest.startsWith(\"/tcpSlaveAgentListener\")\n            // XXX SlaveComputer.doSlaveAgentJnlp; there should be an annotation to request unprotected access\n            || rest.matches(\"/computer/[^/]+/slave-agent[.]jnlp\") && \"true\".equals(Stapler.getCurrentRequest().getParameter(\"encrypt\"))\n            || rest.startsWith(\"/cli\")\n            || rest.startsWith(\"/federatedLoginService/\")\n            || rest.startsWith(\"/securityRealm\"))\n                return this;    // URLs that are always visible without READ permission\n\n            for (String name : getUnprotectedRootActions()) {\n                if (rest.startsWith(\"/\" + name + \"/\") || rest.equals(\"/\" + name)) {\n                    return this;\n                }\n            }\n\n            throw e;\n        }\n        return this;\n    }\n\n    /**\n     * Gets a list of unprotected root actions.\n     * These URL prefixes should be exempted from access control checks by container-managed security.\n     * Ideally would be synchronized with {@link #getTarget}.\n     * @return a list of {@linkplain Action#getUrlName URL names}\n     * @since 1.495\n     */\n    public Collection<String> getUnprotectedRootActions() {\n        Set<String> names = new TreeSet<String>();\n        names.add(\"jnlpJars\"); // XXX cleaner to refactor doJnlpJars into a URA\n        // XXX consider caching (expiring cache when actions changes)\n        for (Action a : getActions()) {\n            if (a instanceof UnprotectedRootAction) {\n                names.add(a.getUrlName());\n            }\n        }\n        return names;\n    }\n\n    /**\n     * Fallback to the primary view.\n     */\n    public View getStaplerFallback() {\n        return getPrimaryView();\n    }\n\n    /**\n     * This method checks all existing jobs to see if displayName is \n     * unique. It does not check the displayName against the displayName of the\n     * job that the user is configuring though to prevent a validation warning \n     * if the user sets the displayName to what it currently is.\n     * @param displayName\n     * @param currentJobName\n     * @return\n     */\n    boolean isDisplayNameUnique(String displayName, String currentJobName) {\n        Collection<TopLevelItem> itemCollection = items.values();\n        \n        // if there are a lot of projects, we'll have to store their \n        // display names in a HashSet or something for a quick check\n        for(TopLevelItem item : itemCollection) {\n            if(item.getName().equals(currentJobName)) {\n                // we won't compare the candidate displayName against the current\n                // item. This is to prevent an validation warning if the user \n                // sets the displayName to what the existing display name is\n                continue;\n            }\n            else if(displayName.equals(item.getDisplayName())) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    /**\n     * True if there is no item in Jenkins that has this name\n     * @param name The name to test\n     * @param currentJobName The name of the job that the user is configuring\n     * @return\n     */\n    boolean isNameUnique(String name, String currentJobName) {\n        Item item = getItem(name);\n        \n        if(null==item) {\n            // the candidate name didn't return any items so the name is unique\n            return true;\n        }\n        else if(item.getName().equals(currentJobName)) {\n            // the candidate name returned an item, but the item is the item\n            // that the user is configuring so this is ok\n            return true;\n        } \n        else {\n            // the candidate name returned an item, so it is not unique\n            return false;\n        }\n    }\n    \n    /**\n     * Checks to see if the candidate displayName collides with any \n     * existing display names or project names\n     * @param displayName The display name to test\n     * @param jobName The name of the job the user is configuring\n     * @return\n     */\n    public FormValidation doCheckDisplayName(@QueryParameter String displayName, \n            @QueryParameter String jobName) {\n        displayName = displayName.trim();\n        \n        if(LOGGER.isLoggable(Level.FINE)) {\n            LOGGER.log(Level.FINE, \"Current job name is \" + jobName);\n        }\n        \n        if(!isNameUnique(displayName, jobName)) {\n            return FormValidation.warning(Messages.Jenkins_CheckDisplayName_NameNotUniqueWarning(displayName));\n        }\n        else if(!isDisplayNameUnique(displayName, jobName)){\n            return FormValidation.warning(Messages.Jenkins_CheckDisplayName_DisplayNameNotUniqueWarning(displayName));\n        }\n        else {\n            return FormValidation.ok();\n        }\n    }\n    \n    public static class MasterComputer extends Computer {\n        protected MasterComputer() {\n            super(Jenkins.getInstance());\n        }\n\n        /**\n         * Returns \"\" to match with {@link Jenkins#getNodeName()}.\n         */\n        @Override\n        public String getName() {\n            return \"\";\n        }\n\n        @Override\n        public boolean isConnecting() {\n            return false;\n        }\n\n        @Override\n        public String getDisplayName() {\n            return Messages.Hudson_Computer_DisplayName();\n        }\n\n        @Override\n        public String getCaption() {\n            return Messages.Hudson_Computer_Caption();\n        }\n\n        @Override\n        public String getUrl() {\n            return \"computer/(master)/\";\n        }\n\n        public RetentionStrategy getRetentionStrategy() {\n            return RetentionStrategy.NOOP;\n        }\n\n        /**\n         * Report an error.\n         */\n        @Override\n        public HttpResponse doDoDelete() throws IOException {\n            throw HttpResponses.status(SC_BAD_REQUEST);\n        }\n\n        @Override\n        public void doConfigSubmit(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException, FormException {\n            Jenkins.getInstance().doConfigExecutorsSubmit(req, rsp);\n        }\n\n        @Override\n        public boolean hasPermission(Permission permission) {\n            // no one should be allowed to delete the master.\n            // this hides the \"delete\" link from the /computer/(master) page.\n            if(permission==Computer.DELETE)\n                return false;\n            // Configuration of master node requires ADMINISTER permission\n            return super.hasPermission(permission==Computer.CONFIGURE ? Jenkins.ADMINISTER : permission);\n        }\n\n        @Override\n        public VirtualChannel getChannel() {\n            return localChannel;\n        }\n\n        @Override\n        public Charset getDefaultCharset() {\n            return Charset.defaultCharset();\n        }\n\n        public List<LogRecord> getLogRecords() throws IOException, InterruptedException {\n            return logRecords;\n        }\n\n        public void doLaunchSlaveAgent(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n            // this computer never returns null from channel, so\n            // this method shall never be invoked.\n            rsp.sendError(SC_NOT_FOUND);\n        }\n\n        protected Future<?> _connect(boolean forceReconnect) {\n            return Futures.precomputed(null);\n        }\n\n        /**\n         * {@link LocalChannel} instance that can be used to execute programs locally.\n         */\n        public static final LocalChannel localChannel = new LocalChannel(threadPoolForRemoting);\n    }\n\n    /**\n     * Shortcut for {@code Hudson.getInstance().lookup.get(type)}\n     */\n    public static <T> T lookup(Class<T> type) {\n        return Jenkins.getInstance().lookup.get(type);\n    }\n\n    /**\n     * Live view of recent {@link LogRecord}s produced by Hudson.\n     */\n    public static List<LogRecord> logRecords = Collections.emptyList(); // initialized to dummy value to avoid NPE\n\n    /**\n     * Thread-safe reusable {@link XStream}.\n     */\n    public static final XStream XSTREAM = new XStream2();\n\n    /**\n     * Alias to {@link #XSTREAM} so that one can access additional methods on {@link XStream2} more easily.\n     */\n    public static final XStream2 XSTREAM2 = (XStream2)XSTREAM;\n\n    private static final int TWICE_CPU_NUM = Math.max(4, Runtime.getRuntime().availableProcessors() * 2);\n\n    /**\n     * Thread pool used to load configuration in parallel, to improve the start up time.\n     * <p>\n     * The idea here is to overlap the CPU and I/O, so we want more threads than CPU numbers.\n     */\n    /*package*/ transient final ExecutorService threadPoolForLoad = new ThreadPoolExecutor(\n        TWICE_CPU_NUM, TWICE_CPU_NUM,\n        5L, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new DaemonThreadFactory());\n\n\n    private static void computeVersion(ServletContext context) {\n        // set the version\n        Properties props = new Properties();\n        try {\n            InputStream is = Jenkins.class.getResourceAsStream(\"jenkins-version.properties\");\n            if(is!=null)\n                props.load(is);\n        } catch (IOException e) {\n            e.printStackTrace(); // if the version properties is missing, that's OK.\n        }\n        String ver = props.getProperty(\"version\");\n        if(ver==null)   ver=\"?\";\n        VERSION = ver;\n        context.setAttribute(\"version\",ver);\n\n        VERSION_HASH = Util.getDigestOf(ver).substring(0, 8);\n        SESSION_HASH = Util.getDigestOf(ver+System.currentTimeMillis()).substring(0, 8);\n\n        if(ver.equals(\"?\") || Boolean.getBoolean(\"hudson.script.noCache\"))\n            RESOURCE_PATH = \"\";\n        else\n            RESOURCE_PATH = \"/static/\"+SESSION_HASH;\n\n        VIEW_RESOURCE_PATH = \"/resources/\"+ SESSION_HASH;\n    }\n\n    /**\n     * Version number of this Hudson.\n     */\n    public static String VERSION=\"?\";\n\n    /**\n     * Parses {@link #VERSION} into {@link VersionNumber}, or null if it's not parseable as a version number\n     * (such as when Hudson is run with \"mvn hudson-dev:run\")\n     */\n    public static VersionNumber getVersion() {\n        try {\n            return new VersionNumber(VERSION);\n        } catch (NumberFormatException e) {\n            try {\n                // for non-released version of Hudson, this looks like \"1.345 (private-foobar), so try to approximate.\n                int idx = VERSION.indexOf(' ');\n                if (idx>0)\n                    return new VersionNumber(VERSION.substring(0,idx));\n            } catch (NumberFormatException _) {\n                // fall through\n            }\n\n            // totally unparseable\n            return null;\n        } catch (IllegalArgumentException e) {\n            // totally unparseable\n            return null;\n        }\n    }\n\n    /**\n     * Hash of {@link #VERSION}.\n     */\n    public static String VERSION_HASH;\n\n    /**\n     * Unique random token that identifies the current session.\n     * Used to make {@link #RESOURCE_PATH} unique so that we can set long \"Expires\" header.\n     * \n     * We used to use {@link #VERSION_HASH}, but making this session local allows us to\n     * reuse the same {@link #RESOURCE_PATH} for static resources in plugins.\n     */\n    public static String SESSION_HASH;\n\n    /**\n     * Prefix to static resources like images and javascripts in the war file.\n     * Either \"\" or strings like \"/static/VERSION\", which avoids Hudson to pick up\n     * stale cache when the user upgrades to a different version.\n     * <p>\n     * Value computed in {@link WebAppMain}.\n     */\n    public static String RESOURCE_PATH = \"\";\n\n    /**\n     * Prefix to resources alongside view scripts.\n     * Strings like \"/resources/VERSION\", which avoids Hudson to pick up\n     * stale cache when the user upgrades to a different version.\n     * <p>\n     * Value computed in {@link WebAppMain}.\n     */\n    public static String VIEW_RESOURCE_PATH = \"/resources/TBD\";\n\n    public static boolean PARALLEL_LOAD = Configuration.getBooleanConfigParameter(\"parallelLoad\", true);\n    public static boolean KILL_AFTER_LOAD = Configuration.getBooleanConfigParameter(\"killAfterLoad\", false);\n    /**\n     * Enabled by default as of 1.337. Will keep it for a while just in case we have some serious problems.\n     */\n    public static boolean FLYWEIGHT_SUPPORT = Configuration.getBooleanConfigParameter(\"flyweightSupport\", true);\n\n    /**\n     * Tentative switch to activate the concurrent build behavior.\n     * When we merge this back to the trunk, this allows us to keep\n     * this feature hidden for a while until we iron out the kinks.\n     * @see AbstractProject#isConcurrentBuild()\n     * @deprecated as of 1.464\n     *      This flag will have no effect.\n     */\n    @Restricted(NoExternalUse.class)\n    public static boolean CONCURRENT_BUILD = true;\n\n    /**\n     * Switch to enable people to use a shorter workspace name.\n     */\n    private static final String WORKSPACE_DIRNAME = Configuration.getStringConfigParameter(\"workspaceDirName\", \"workspace\");\n\n    /**\n     * Automatically try to launch a slave when Jenkins is initialized or a new slave is created.\n     */\n    public static boolean AUTOMATIC_SLAVE_LAUNCH = true;\n\n    private static final Logger LOGGER = Logger.getLogger(Jenkins.class.getName());\n\n    public static final PermissionGroup PERMISSIONS = Permission.HUDSON_PERMISSIONS;\n    public static final Permission ADMINISTER = Permission.HUDSON_ADMINISTER;\n    public static final Permission READ = new Permission(PERMISSIONS,\"Read\",Messages._Hudson_ReadPermission_Description(),Permission.READ,PermissionScope.JENKINS);\n    public static final Permission RUN_SCRIPTS = new Permission(PERMISSIONS, \"RunScripts\", Messages._Hudson_RunScriptsPermission_Description(),ADMINISTER,PermissionScope.JENKINS);\n\n    /**\n     * {@link Authentication} object that represents the anonymous user.\n     * Because Acegi creates its own {@link AnonymousAuthenticationToken} instances, the code must not\n     * expect the singleton semantics. This is just a convenient instance.\n     *\n     * @since 1.343\n     */\n    public static final Authentication ANONYMOUS = new AnonymousAuthenticationToken(\n            \"anonymous\",\"anonymous\",new GrantedAuthority[]{new GrantedAuthorityImpl(\"anonymous\")});\n\n    static {\n        XSTREAM.alias(\"jenkins\",Jenkins.class);\n        XSTREAM.alias(\"slave\", DumbSlave.class);\n        XSTREAM.alias(\"jdk\",JDK.class);\n        // for backward compatibility with <1.75, recognize the tag name \"view\" as well.\n        XSTREAM.alias(\"view\", ListView.class);\n        XSTREAM.alias(\"listView\", ListView.class);\n        // this seems to be necessary to force registration of converter early enough\n        Mode.class.getEnumConstants();\n\n        // double check that initialization order didn't do any harm\n        assert PERMISSIONS!=null;\n        assert ADMINISTER!=null;\n    }\n\n}\n", "<!--\nThe MIT License\n\nCopyright (c) 2004-2009, Sun Microsystems, Inc., Kohsuke Kawaguchi\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n-->\n\n<!--\n  read icon size from a cookie and set it up\n-->\n<?jelly escape-by-default='true'?>\n<j:jelly xmlns:j=\"jelly:core\" xmlns:x=\"jelly:xml\" xmlns:st=\"jelly:stapler\" xmlns:d=\"jelly:define\" xmlns:l=\"/lib/layout\" xmlns:t=\"/lib/hudson\" xmlns:f=\"/lib/form\">\n  <j:set scope=\"parent\" var=\"iconSize\" value=\"${h.validateIconSize(h.getCookie(request,'iconSize','32x32'))}\" />\n  <!--\n    balls look smaller than their actual size,\n    so we try not to make the secondary icons look bigger than the icon.\n    we want the user's eyes to go to balls, not the clock.\n  -->\n  <j:set scope=\"parent\" var=\"subIconSize\" value=\"${iconSize=='32x32'?'24x24':iconSize}\"/>\n</j:jelly>"], "filenames": ["core/src/main/java/hudson/Functions.java", "core/src/main/java/hudson/model/View.java", "core/src/main/java/jenkins/model/Jenkins.java", "core/src/main/resources/lib/hudson/setIconSize.jelly"], "buggy_code_start_loc": [125, 769, 298, 30], "buggy_code_end_loc": [426, 770, 3969, 31], "fixing_code_start_loc": [126, 769, 297, 30], "fixing_code_end_loc": [438, 770, 3965, 31], "type": "CWE-79", "message": "Cross-site scripting (XSS) vulnerability in Jenkins before 1.551 and LTS before 1.532.2 allows remote attackers to inject arbitrary web script or HTML via the iconSize cookie.", "other": {"cve": {"id": "CVE-2014-2065", "sourceIdentifier": "security@debian.org", "published": "2014-10-17T15:55:05.790", "lastModified": "2016-06-13T23:39:15.623", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Cross-site scripting (XSS) vulnerability in Jenkins before 1.551 and LTS before 1.532.2 allows remote attackers to inject arbitrary web script or HTML via the iconSize cookie."}, {"lang": "es", "value": "Vulnerabilidad de XSS en Jenkins en versiones anteriores a 1.551 y LTS en versiones anteriores a 1.532.2 permite a atacantes remotos inyectar secuencias de comandos web o HTML arbitrarios a trav\u00e9s de la cookie iconSize."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jenkins:jenkins:*:*:*:*:lts:*:*:*", "versionEndIncluding": "1.532.1", "matchCriteriaId": "F5EDE52E-F7BE-457D-8E56-F24800F02241"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jenkins:jenkins:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.550", "matchCriteriaId": "07E4FEB5-A7D9-49FE-839A-0D650CC19C42"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2014/02/21/2", "source": "security@debian.org"}, {"url": "https://github.com/jenkinsci/jenkins/commit/a0b00508eeb74d7033dc4100eb382df4e8fa72e7", "source": "security@debian.org", "tags": ["Patch"]}, {"url": "https://wiki.jenkins-ci.org/display/SECURITY/Jenkins+Security+Advisory+2014-02-14", "source": "security@debian.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/jenkinsci/jenkins/commit/a0b00508eeb74d7033dc4100eb382df4e8fa72e7"}}