{"buggy_code": ["/*\n * USB hub driver.\n *\n * (C) Copyright 1999 Linus Torvalds\n * (C) Copyright 1999 Johannes Erdfelt\n * (C) Copyright 1999 Gregory P. Smith\n * (C) Copyright 2001 Brad Hards (bhards@bigpond.net.au)\n *\n */\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/ioctl.h>\n#include <linux/usb.h>\n#include <linux/usbdevice_fs.h>\n#include <linux/usb/hcd.h>\n#include <linux/usb/otg.h>\n#include <linux/usb/quirks.h>\n#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/random.h>\n#include <linux/pm_qos.h>\n\n#include <asm/uaccess.h>\n#include <asm/byteorder.h>\n\n#include \"hub.h\"\n#include \"otg_whitelist.h\"\n\n#define USB_VENDOR_GENESYS_LOGIC\t\t0x05e3\n#define HUB_QUIRK_CHECK_PORT_AUTOSUSPEND\t0x01\n\n/* Protect struct usb_device->state and ->children members\n * Note: Both are also protected by ->dev.sem, except that ->state can\n * change to USB_STATE_NOTATTACHED even when the semaphore isn't held. */\nstatic DEFINE_SPINLOCK(device_state_lock);\n\n/* workqueue to process hub events */\nstatic struct workqueue_struct *hub_wq;\nstatic void hub_event(struct work_struct *work);\n\n/* synchronize hub-port add/remove and peering operations */\nDEFINE_MUTEX(usb_port_peer_mutex);\n\n/* cycle leds on hubs that aren't blinking for attention */\nstatic bool blinkenlights = 0;\nmodule_param(blinkenlights, bool, S_IRUGO);\nMODULE_PARM_DESC(blinkenlights, \"true to cycle leds on hubs\");\n\n/*\n * Device SATA8000 FW1.0 from DATAST0R Technology Corp requires about\n * 10 seconds to send reply for the initial 64-byte descriptor request.\n */\n/* define initial 64-byte descriptor request timeout in milliseconds */\nstatic int initial_descriptor_timeout = USB_CTRL_GET_TIMEOUT;\nmodule_param(initial_descriptor_timeout, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(initial_descriptor_timeout,\n\t\t\"initial 64-byte descriptor request timeout in milliseconds \"\n\t\t\"(default 5000 - 5.0 seconds)\");\n\n/*\n * As of 2.6.10 we introduce a new USB device initialization scheme which\n * closely resembles the way Windows works.  Hopefully it will be compatible\n * with a wider range of devices than the old scheme.  However some previously\n * working devices may start giving rise to \"device not accepting address\"\n * errors; if that happens the user can try the old scheme by adjusting the\n * following module parameters.\n *\n * For maximum flexibility there are two boolean parameters to control the\n * hub driver's behavior.  On the first initialization attempt, if the\n * \"old_scheme_first\" parameter is set then the old scheme will be used,\n * otherwise the new scheme is used.  If that fails and \"use_both_schemes\"\n * is set, then the driver will make another attempt, using the other scheme.\n */\nstatic bool old_scheme_first = 0;\nmodule_param(old_scheme_first, bool, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(old_scheme_first,\n\t\t \"start with the old device initialization scheme\");\n\nstatic bool use_both_schemes = 1;\nmodule_param(use_both_schemes, bool, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(use_both_schemes,\n\t\t\"try the other device initialization scheme if the \"\n\t\t\"first one fails\");\n\n/* Mutual exclusion for EHCI CF initialization.  This interferes with\n * port reset on some companion controllers.\n */\nDECLARE_RWSEM(ehci_cf_port_reset_rwsem);\nEXPORT_SYMBOL_GPL(ehci_cf_port_reset_rwsem);\n\n#define HUB_DEBOUNCE_TIMEOUT\t2000\n#define HUB_DEBOUNCE_STEP\t  25\n#define HUB_DEBOUNCE_STABLE\t 100\n\nstatic void hub_release(struct kref *kref);\nstatic int usb_reset_and_verify_device(struct usb_device *udev);\n\nstatic inline char *portspeed(struct usb_hub *hub, int portstatus)\n{\n\tif (hub_is_superspeed(hub->hdev))\n\t\treturn \"5.0 Gb/s\";\n\tif (portstatus & USB_PORT_STAT_HIGH_SPEED)\n\t\treturn \"480 Mb/s\";\n\telse if (portstatus & USB_PORT_STAT_LOW_SPEED)\n\t\treturn \"1.5 Mb/s\";\n\telse\n\t\treturn \"12 Mb/s\";\n}\n\n/* Note that hdev or one of its children must be locked! */\nstruct usb_hub *usb_hub_to_struct_hub(struct usb_device *hdev)\n{\n\tif (!hdev || !hdev->actconfig || !hdev->maxchild)\n\t\treturn NULL;\n\treturn usb_get_intfdata(hdev->actconfig->interface[0]);\n}\n\nint usb_device_supports_lpm(struct usb_device *udev)\n{\n\t/* Some devices have trouble with LPM */\n\tif (udev->quirks & USB_QUIRK_NO_LPM)\n\t\treturn 0;\n\n\t/* USB 2.1 (and greater) devices indicate LPM support through\n\t * their USB 2.0 Extended Capabilities BOS descriptor.\n\t */\n\tif (udev->speed == USB_SPEED_HIGH || udev->speed == USB_SPEED_FULL) {\n\t\tif (udev->bos->ext_cap &&\n\t\t\t(USB_LPM_SUPPORT &\n\t\t\t le32_to_cpu(udev->bos->ext_cap->bmAttributes)))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * According to the USB 3.0 spec, all USB 3.0 devices must support LPM.\n\t * However, there are some that don't, and they set the U1/U2 exit\n\t * latencies to zero.\n\t */\n\tif (!udev->bos->ss_cap) {\n\t\tdev_info(&udev->dev, \"No LPM exit latency info found, disabling LPM.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (udev->bos->ss_cap->bU1devExitLat == 0 &&\n\t\t\tudev->bos->ss_cap->bU2DevExitLat == 0) {\n\t\tif (udev->parent)\n\t\t\tdev_info(&udev->dev, \"LPM exit latency is zeroed, disabling LPM.\\n\");\n\t\telse\n\t\t\tdev_info(&udev->dev, \"We don't know the algorithms for LPM for this host, disabling LPM.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!udev->parent || udev->parent->lpm_capable)\n\t\treturn 1;\n\treturn 0;\n}\n\n/*\n * Set the Maximum Exit Latency (MEL) for the host to initiate a transition from\n * either U1 or U2.\n */\nstatic void usb_set_lpm_mel(struct usb_device *udev,\n\t\tstruct usb3_lpm_parameters *udev_lpm_params,\n\t\tunsigned int udev_exit_latency,\n\t\tstruct usb_hub *hub,\n\t\tstruct usb3_lpm_parameters *hub_lpm_params,\n\t\tunsigned int hub_exit_latency)\n{\n\tunsigned int total_mel;\n\tunsigned int device_mel;\n\tunsigned int hub_mel;\n\n\t/*\n\t * Calculate the time it takes to transition all links from the roothub\n\t * to the parent hub into U0.  The parent hub must then decode the\n\t * packet (hub header decode latency) to figure out which port it was\n\t * bound for.\n\t *\n\t * The Hub Header decode latency is expressed in 0.1us intervals (0x1\n\t * means 0.1us).  Multiply that by 100 to get nanoseconds.\n\t */\n\ttotal_mel = hub_lpm_params->mel +\n\t\t(hub->descriptor->u.ss.bHubHdrDecLat * 100);\n\n\t/*\n\t * How long will it take to transition the downstream hub's port into\n\t * U0?  The greater of either the hub exit latency or the device exit\n\t * latency.\n\t *\n\t * The BOS U1/U2 exit latencies are expressed in 1us intervals.\n\t * Multiply that by 1000 to get nanoseconds.\n\t */\n\tdevice_mel = udev_exit_latency * 1000;\n\thub_mel = hub_exit_latency * 1000;\n\tif (device_mel > hub_mel)\n\t\ttotal_mel += device_mel;\n\telse\n\t\ttotal_mel += hub_mel;\n\n\tudev_lpm_params->mel = total_mel;\n}\n\n/*\n * Set the maximum Device to Host Exit Latency (PEL) for the device to initiate\n * a transition from either U1 or U2.\n */\nstatic void usb_set_lpm_pel(struct usb_device *udev,\n\t\tstruct usb3_lpm_parameters *udev_lpm_params,\n\t\tunsigned int udev_exit_latency,\n\t\tstruct usb_hub *hub,\n\t\tstruct usb3_lpm_parameters *hub_lpm_params,\n\t\tunsigned int hub_exit_latency,\n\t\tunsigned int port_to_port_exit_latency)\n{\n\tunsigned int first_link_pel;\n\tunsigned int hub_pel;\n\n\t/*\n\t * First, the device sends an LFPS to transition the link between the\n\t * device and the parent hub into U0.  The exit latency is the bigger of\n\t * the device exit latency or the hub exit latency.\n\t */\n\tif (udev_exit_latency > hub_exit_latency)\n\t\tfirst_link_pel = udev_exit_latency * 1000;\n\telse\n\t\tfirst_link_pel = hub_exit_latency * 1000;\n\n\t/*\n\t * When the hub starts to receive the LFPS, there is a slight delay for\n\t * it to figure out that one of the ports is sending an LFPS.  Then it\n\t * will forward the LFPS to its upstream link.  The exit latency is the\n\t * delay, plus the PEL that we calculated for this hub.\n\t */\n\thub_pel = port_to_port_exit_latency * 1000 + hub_lpm_params->pel;\n\n\t/*\n\t * According to figure C-7 in the USB 3.0 spec, the PEL for this device\n\t * is the greater of the two exit latencies.\n\t */\n\tif (first_link_pel > hub_pel)\n\t\tudev_lpm_params->pel = first_link_pel;\n\telse\n\t\tudev_lpm_params->pel = hub_pel;\n}\n\n/*\n * Set the System Exit Latency (SEL) to indicate the total worst-case time from\n * when a device initiates a transition to U0, until when it will receive the\n * first packet from the host controller.\n *\n * Section C.1.5.1 describes the four components to this:\n *  - t1: device PEL\n *  - t2: time for the ERDY to make it from the device to the host.\n *  - t3: a host-specific delay to process the ERDY.\n *  - t4: time for the packet to make it from the host to the device.\n *\n * t3 is specific to both the xHCI host and the platform the host is integrated\n * into.  The Intel HW folks have said it's negligible, FIXME if a different\n * vendor says otherwise.\n */\nstatic void usb_set_lpm_sel(struct usb_device *udev,\n\t\tstruct usb3_lpm_parameters *udev_lpm_params)\n{\n\tstruct usb_device *parent;\n\tunsigned int num_hubs;\n\tunsigned int total_sel;\n\n\t/* t1 = device PEL */\n\ttotal_sel = udev_lpm_params->pel;\n\t/* How many external hubs are in between the device & the root port. */\n\tfor (parent = udev->parent, num_hubs = 0; parent->parent;\n\t\t\tparent = parent->parent)\n\t\tnum_hubs++;\n\t/* t2 = 2.1us + 250ns * (num_hubs - 1) */\n\tif (num_hubs > 0)\n\t\ttotal_sel += 2100 + 250 * (num_hubs - 1);\n\n\t/* t4 = 250ns * num_hubs */\n\ttotal_sel += 250 * num_hubs;\n\n\tudev_lpm_params->sel = total_sel;\n}\n\nstatic void usb_set_lpm_parameters(struct usb_device *udev)\n{\n\tstruct usb_hub *hub;\n\tunsigned int port_to_port_delay;\n\tunsigned int udev_u1_del;\n\tunsigned int udev_u2_del;\n\tunsigned int hub_u1_del;\n\tunsigned int hub_u2_del;\n\n\tif (!udev->lpm_capable || udev->speed != USB_SPEED_SUPER)\n\t\treturn;\n\n\thub = usb_hub_to_struct_hub(udev->parent);\n\t/* It doesn't take time to transition the roothub into U0, since it\n\t * doesn't have an upstream link.\n\t */\n\tif (!hub)\n\t\treturn;\n\n\tudev_u1_del = udev->bos->ss_cap->bU1devExitLat;\n\tudev_u2_del = le16_to_cpu(udev->bos->ss_cap->bU2DevExitLat);\n\thub_u1_del = udev->parent->bos->ss_cap->bU1devExitLat;\n\thub_u2_del = le16_to_cpu(udev->parent->bos->ss_cap->bU2DevExitLat);\n\n\tusb_set_lpm_mel(udev, &udev->u1_params, udev_u1_del,\n\t\t\thub, &udev->parent->u1_params, hub_u1_del);\n\n\tusb_set_lpm_mel(udev, &udev->u2_params, udev_u2_del,\n\t\t\thub, &udev->parent->u2_params, hub_u2_del);\n\n\t/*\n\t * Appendix C, section C.2.2.2, says that there is a slight delay from\n\t * when the parent hub notices the downstream port is trying to\n\t * transition to U0 to when the hub initiates a U0 transition on its\n\t * upstream port.  The section says the delays are tPort2PortU1EL and\n\t * tPort2PortU2EL, but it doesn't define what they are.\n\t *\n\t * The hub chapter, sections 10.4.2.4 and 10.4.2.5 seem to be talking\n\t * about the same delays.  Use the maximum delay calculations from those\n\t * sections.  For U1, it's tHubPort2PortExitLat, which is 1us max.  For\n\t * U2, it's tHubPort2PortExitLat + U2DevExitLat - U1DevExitLat.  I\n\t * assume the device exit latencies they are talking about are the hub\n\t * exit latencies.\n\t *\n\t * What do we do if the U2 exit latency is less than the U1 exit\n\t * latency?  It's possible, although not likely...\n\t */\n\tport_to_port_delay = 1;\n\n\tusb_set_lpm_pel(udev, &udev->u1_params, udev_u1_del,\n\t\t\thub, &udev->parent->u1_params, hub_u1_del,\n\t\t\tport_to_port_delay);\n\n\tif (hub_u2_del > hub_u1_del)\n\t\tport_to_port_delay = 1 + hub_u2_del - hub_u1_del;\n\telse\n\t\tport_to_port_delay = 1 + hub_u1_del;\n\n\tusb_set_lpm_pel(udev, &udev->u2_params, udev_u2_del,\n\t\t\thub, &udev->parent->u2_params, hub_u2_del,\n\t\t\tport_to_port_delay);\n\n\t/* Now that we've got PEL, calculate SEL. */\n\tusb_set_lpm_sel(udev, &udev->u1_params);\n\tusb_set_lpm_sel(udev, &udev->u2_params);\n}\n\n/* USB 2.0 spec Section 11.24.4.5 */\nstatic int get_hub_descriptor(struct usb_device *hdev, void *data)\n{\n\tint i, ret, size;\n\tunsigned dtype;\n\n\tif (hub_is_superspeed(hdev)) {\n\t\tdtype = USB_DT_SS_HUB;\n\t\tsize = USB_DT_SS_HUB_SIZE;\n\t} else {\n\t\tdtype = USB_DT_HUB;\n\t\tsize = sizeof(struct usb_hub_descriptor);\n\t}\n\n\tfor (i = 0; i < 3; i++) {\n\t\tret = usb_control_msg(hdev, usb_rcvctrlpipe(hdev, 0),\n\t\t\tUSB_REQ_GET_DESCRIPTOR, USB_DIR_IN | USB_RT_HUB,\n\t\t\tdtype << 8, 0, data, size,\n\t\t\tUSB_CTRL_GET_TIMEOUT);\n\t\tif (ret >= (USB_DT_HUB_NONVAR_SIZE + 2))\n\t\t\treturn ret;\n\t}\n\treturn -EINVAL;\n}\n\n/*\n * USB 2.0 spec Section 11.24.2.1\n */\nstatic int clear_hub_feature(struct usb_device *hdev, int feature)\n{\n\treturn usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\n\t\tUSB_REQ_CLEAR_FEATURE, USB_RT_HUB, feature, 0, NULL, 0, 1000);\n}\n\n/*\n * USB 2.0 spec Section 11.24.2.2\n */\nint usb_clear_port_feature(struct usb_device *hdev, int port1, int feature)\n{\n\treturn usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\n\t\tUSB_REQ_CLEAR_FEATURE, USB_RT_PORT, feature, port1,\n\t\tNULL, 0, 1000);\n}\n\n/*\n * USB 2.0 spec Section 11.24.2.13\n */\nstatic int set_port_feature(struct usb_device *hdev, int port1, int feature)\n{\n\treturn usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\n\t\tUSB_REQ_SET_FEATURE, USB_RT_PORT, feature, port1,\n\t\tNULL, 0, 1000);\n}\n\nstatic char *to_led_name(int selector)\n{\n\tswitch (selector) {\n\tcase HUB_LED_AMBER:\n\t\treturn \"amber\";\n\tcase HUB_LED_GREEN:\n\t\treturn \"green\";\n\tcase HUB_LED_OFF:\n\t\treturn \"off\";\n\tcase HUB_LED_AUTO:\n\t\treturn \"auto\";\n\tdefault:\n\t\treturn \"??\";\n\t}\n}\n\n/*\n * USB 2.0 spec Section 11.24.2.7.1.10 and table 11-7\n * for info about using port indicators\n */\nstatic void set_port_led(struct usb_hub *hub, int port1, int selector)\n{\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tint status;\n\n\tstatus = set_port_feature(hub->hdev, (selector << 8) | port1,\n\t\t\tUSB_PORT_FEAT_INDICATOR);\n\tdev_dbg(&port_dev->dev, \"indicator %s status %d\\n\",\n\t\tto_led_name(selector), status);\n}\n\n#define\tLED_CYCLE_PERIOD\t((2*HZ)/3)\n\nstatic void led_work(struct work_struct *work)\n{\n\tstruct usb_hub\t\t*hub =\n\t\tcontainer_of(work, struct usb_hub, leds.work);\n\tstruct usb_device\t*hdev = hub->hdev;\n\tunsigned\t\ti;\n\tunsigned\t\tchanged = 0;\n\tint\t\t\tcursor = -1;\n\n\tif (hdev->state != USB_STATE_CONFIGURED || hub->quiescing)\n\t\treturn;\n\n\tfor (i = 0; i < hdev->maxchild; i++) {\n\t\tunsigned\tselector, mode;\n\n\t\t/* 30%-50% duty cycle */\n\n\t\tswitch (hub->indicator[i]) {\n\t\t/* cycle marker */\n\t\tcase INDICATOR_CYCLE:\n\t\t\tcursor = i;\n\t\t\tselector = HUB_LED_AUTO;\n\t\t\tmode = INDICATOR_AUTO;\n\t\t\tbreak;\n\t\t/* blinking green = sw attention */\n\t\tcase INDICATOR_GREEN_BLINK:\n\t\t\tselector = HUB_LED_GREEN;\n\t\t\tmode = INDICATOR_GREEN_BLINK_OFF;\n\t\t\tbreak;\n\t\tcase INDICATOR_GREEN_BLINK_OFF:\n\t\t\tselector = HUB_LED_OFF;\n\t\t\tmode = INDICATOR_GREEN_BLINK;\n\t\t\tbreak;\n\t\t/* blinking amber = hw attention */\n\t\tcase INDICATOR_AMBER_BLINK:\n\t\t\tselector = HUB_LED_AMBER;\n\t\t\tmode = INDICATOR_AMBER_BLINK_OFF;\n\t\t\tbreak;\n\t\tcase INDICATOR_AMBER_BLINK_OFF:\n\t\t\tselector = HUB_LED_OFF;\n\t\t\tmode = INDICATOR_AMBER_BLINK;\n\t\t\tbreak;\n\t\t/* blink green/amber = reserved */\n\t\tcase INDICATOR_ALT_BLINK:\n\t\t\tselector = HUB_LED_GREEN;\n\t\t\tmode = INDICATOR_ALT_BLINK_OFF;\n\t\t\tbreak;\n\t\tcase INDICATOR_ALT_BLINK_OFF:\n\t\t\tselector = HUB_LED_AMBER;\n\t\t\tmode = INDICATOR_ALT_BLINK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\tif (selector != HUB_LED_AUTO)\n\t\t\tchanged = 1;\n\t\tset_port_led(hub, i + 1, selector);\n\t\thub->indicator[i] = mode;\n\t}\n\tif (!changed && blinkenlights) {\n\t\tcursor++;\n\t\tcursor %= hdev->maxchild;\n\t\tset_port_led(hub, cursor + 1, HUB_LED_GREEN);\n\t\thub->indicator[cursor] = INDICATOR_CYCLE;\n\t\tchanged++;\n\t}\n\tif (changed)\n\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t&hub->leds, LED_CYCLE_PERIOD);\n}\n\n/* use a short timeout for hub/port status fetches */\n#define\tUSB_STS_TIMEOUT\t\t1000\n#define\tUSB_STS_RETRIES\t\t5\n\n/*\n * USB 2.0 spec Section 11.24.2.6\n */\nstatic int get_hub_status(struct usb_device *hdev,\n\t\tstruct usb_hub_status *data)\n{\n\tint i, status = -ETIMEDOUT;\n\n\tfor (i = 0; i < USB_STS_RETRIES &&\n\t\t\t(status == -ETIMEDOUT || status == -EPIPE); i++) {\n\t\tstatus = usb_control_msg(hdev, usb_rcvctrlpipe(hdev, 0),\n\t\t\tUSB_REQ_GET_STATUS, USB_DIR_IN | USB_RT_HUB, 0, 0,\n\t\t\tdata, sizeof(*data), USB_STS_TIMEOUT);\n\t}\n\treturn status;\n}\n\n/*\n * USB 2.0 spec Section 11.24.2.7\n */\nstatic int get_port_status(struct usb_device *hdev, int port1,\n\t\tstruct usb_port_status *data)\n{\n\tint i, status = -ETIMEDOUT;\n\n\tfor (i = 0; i < USB_STS_RETRIES &&\n\t\t\t(status == -ETIMEDOUT || status == -EPIPE); i++) {\n\t\tstatus = usb_control_msg(hdev, usb_rcvctrlpipe(hdev, 0),\n\t\t\tUSB_REQ_GET_STATUS, USB_DIR_IN | USB_RT_PORT, 0, port1,\n\t\t\tdata, sizeof(*data), USB_STS_TIMEOUT);\n\t}\n\treturn status;\n}\n\nstatic int hub_port_status(struct usb_hub *hub, int port1,\n\t\tu16 *status, u16 *change)\n{\n\tint ret;\n\n\tmutex_lock(&hub->status_mutex);\n\tret = get_port_status(hub->hdev, port1, &hub->status->port);\n\tif (ret < 4) {\n\t\tif (ret != -ENODEV)\n\t\t\tdev_err(hub->intfdev,\n\t\t\t\t\"%s failed (err = %d)\\n\", __func__, ret);\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t} else {\n\t\t*status = le16_to_cpu(hub->status->port.wPortStatus);\n\t\t*change = le16_to_cpu(hub->status->port.wPortChange);\n\n\t\tret = 0;\n\t}\n\tmutex_unlock(&hub->status_mutex);\n\treturn ret;\n}\n\nstatic void kick_hub_wq(struct usb_hub *hub)\n{\n\tstruct usb_interface *intf;\n\n\tif (hub->disconnected || work_pending(&hub->events))\n\t\treturn;\n\n\t/*\n\t * Suppress autosuspend until the event is proceed.\n\t *\n\t * Be careful and make sure that the symmetric operation is\n\t * always called. We are here only when there is no pending\n\t * work for this hub. Therefore put the interface either when\n\t * the new work is called or when it is canceled.\n\t */\n\tintf = to_usb_interface(hub->intfdev);\n\tusb_autopm_get_interface_no_resume(intf);\n\tkref_get(&hub->kref);\n\n\tif (queue_work(hub_wq, &hub->events))\n\t\treturn;\n\n\t/* the work has already been scheduled */\n\tusb_autopm_put_interface_async(intf);\n\tkref_put(&hub->kref, hub_release);\n}\n\nvoid usb_kick_hub_wq(struct usb_device *hdev)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\n\tif (hub)\n\t\tkick_hub_wq(hub);\n}\n\n/*\n * Let the USB core know that a USB 3.0 device has sent a Function Wake Device\n * Notification, which indicates it had initiated remote wakeup.\n *\n * USB 3.0 hubs do not report the port link state change from U3 to U0 when the\n * device initiates resume, so the USB core will not receive notice of the\n * resume through the normal hub interrupt URB.\n */\nvoid usb_wakeup_notification(struct usb_device *hdev,\n\t\tunsigned int portnum)\n{\n\tstruct usb_hub *hub;\n\n\tif (!hdev)\n\t\treturn;\n\n\thub = usb_hub_to_struct_hub(hdev);\n\tif (hub) {\n\t\tset_bit(portnum, hub->wakeup_bits);\n\t\tkick_hub_wq(hub);\n\t}\n}\nEXPORT_SYMBOL_GPL(usb_wakeup_notification);\n\n/* completion function, fires on port status changes and various faults */\nstatic void hub_irq(struct urb *urb)\n{\n\tstruct usb_hub *hub = urb->context;\n\tint status = urb->status;\n\tunsigned i;\n\tunsigned long bits;\n\n\tswitch (status) {\n\tcase -ENOENT:\t\t/* synchronous unlink */\n\tcase -ECONNRESET:\t/* async unlink */\n\tcase -ESHUTDOWN:\t/* hardware going away */\n\t\treturn;\n\n\tdefault:\t\t/* presumably an error */\n\t\t/* Cause a hub reset after 10 consecutive errors */\n\t\tdev_dbg(hub->intfdev, \"transfer --> %d\\n\", status);\n\t\tif ((++hub->nerrors < 10) || hub->error)\n\t\t\tgoto resubmit;\n\t\thub->error = status;\n\t\t/* FALL THROUGH */\n\n\t/* let hub_wq handle things */\n\tcase 0:\t\t\t/* we got data:  port status changed */\n\t\tbits = 0;\n\t\tfor (i = 0; i < urb->actual_length; ++i)\n\t\t\tbits |= ((unsigned long) ((*hub->buffer)[i]))\n\t\t\t\t\t<< (i*8);\n\t\thub->event_bits[0] = bits;\n\t\tbreak;\n\t}\n\n\thub->nerrors = 0;\n\n\t/* Something happened, let hub_wq figure it out */\n\tkick_hub_wq(hub);\n\nresubmit:\n\tif (hub->quiescing)\n\t\treturn;\n\n\tstatus = usb_submit_urb(hub->urb, GFP_ATOMIC);\n\tif (status != 0 && status != -ENODEV && status != -EPERM)\n\t\tdev_err(hub->intfdev, \"resubmit --> %d\\n\", status);\n}\n\n/* USB 2.0 spec Section 11.24.2.3 */\nstatic inline int\nhub_clear_tt_buffer(struct usb_device *hdev, u16 devinfo, u16 tt)\n{\n\t/* Need to clear both directions for control ep */\n\tif (((devinfo >> 11) & USB_ENDPOINT_XFERTYPE_MASK) ==\n\t\t\tUSB_ENDPOINT_XFER_CONTROL) {\n\t\tint status = usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\n\t\t\t\tHUB_CLEAR_TT_BUFFER, USB_RT_PORT,\n\t\t\t\tdevinfo ^ 0x8000, tt, NULL, 0, 1000);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\treturn usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\n\t\t\t       HUB_CLEAR_TT_BUFFER, USB_RT_PORT, devinfo,\n\t\t\t       tt, NULL, 0, 1000);\n}\n\n/*\n * enumeration blocks hub_wq for a long time. we use keventd instead, since\n * long blocking there is the exception, not the rule.  accordingly, HCDs\n * talking to TTs must queue control transfers (not just bulk and iso), so\n * both can talk to the same hub concurrently.\n */\nstatic void hub_tt_work(struct work_struct *work)\n{\n\tstruct usb_hub\t\t*hub =\n\t\tcontainer_of(work, struct usb_hub, tt.clear_work);\n\tunsigned long\t\tflags;\n\n\tspin_lock_irqsave(&hub->tt.lock, flags);\n\twhile (!list_empty(&hub->tt.clear_list)) {\n\t\tstruct list_head\t*next;\n\t\tstruct usb_tt_clear\t*clear;\n\t\tstruct usb_device\t*hdev = hub->hdev;\n\t\tconst struct hc_driver\t*drv;\n\t\tint\t\t\tstatus;\n\n\t\tnext = hub->tt.clear_list.next;\n\t\tclear = list_entry(next, struct usb_tt_clear, clear_list);\n\t\tlist_del(&clear->clear_list);\n\n\t\t/* drop lock so HCD can concurrently report other TT errors */\n\t\tspin_unlock_irqrestore(&hub->tt.lock, flags);\n\t\tstatus = hub_clear_tt_buffer(hdev, clear->devinfo, clear->tt);\n\t\tif (status && status != -ENODEV)\n\t\t\tdev_err(&hdev->dev,\n\t\t\t\t\"clear tt %d (%04x) error %d\\n\",\n\t\t\t\tclear->tt, clear->devinfo, status);\n\n\t\t/* Tell the HCD, even if the operation failed */\n\t\tdrv = clear->hcd->driver;\n\t\tif (drv->clear_tt_buffer_complete)\n\t\t\t(drv->clear_tt_buffer_complete)(clear->hcd, clear->ep);\n\n\t\tkfree(clear);\n\t\tspin_lock_irqsave(&hub->tt.lock, flags);\n\t}\n\tspin_unlock_irqrestore(&hub->tt.lock, flags);\n}\n\n/**\n * usb_hub_set_port_power - control hub port's power state\n * @hdev: USB device belonging to the usb hub\n * @hub: target hub\n * @port1: port index\n * @set: expected status\n *\n * call this function to control port's power via setting or\n * clearing the port's PORT_POWER feature.\n *\n * Return: 0 if successful. A negative error code otherwise.\n */\nint usb_hub_set_port_power(struct usb_device *hdev, struct usb_hub *hub,\n\t\t\t   int port1, bool set)\n{\n\tint ret;\n\n\tif (set)\n\t\tret = set_port_feature(hdev, port1, USB_PORT_FEAT_POWER);\n\telse\n\t\tret = usb_clear_port_feature(hdev, port1, USB_PORT_FEAT_POWER);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (set)\n\t\tset_bit(port1, hub->power_bits);\n\telse\n\t\tclear_bit(port1, hub->power_bits);\n\treturn 0;\n}\n\n/**\n * usb_hub_clear_tt_buffer - clear control/bulk TT state in high speed hub\n * @urb: an URB associated with the failed or incomplete split transaction\n *\n * High speed HCDs use this to tell the hub driver that some split control or\n * bulk transaction failed in a way that requires clearing internal state of\n * a transaction translator.  This is normally detected (and reported) from\n * interrupt context.\n *\n * It may not be possible for that hub to handle additional full (or low)\n * speed transactions until that state is fully cleared out.\n *\n * Return: 0 if successful. A negative error code otherwise.\n */\nint usb_hub_clear_tt_buffer(struct urb *urb)\n{\n\tstruct usb_device\t*udev = urb->dev;\n\tint\t\t\tpipe = urb->pipe;\n\tstruct usb_tt\t\t*tt = udev->tt;\n\tunsigned long\t\tflags;\n\tstruct usb_tt_clear\t*clear;\n\n\t/* we've got to cope with an arbitrary number of pending TT clears,\n\t * since each TT has \"at least two\" buffers that can need it (and\n\t * there can be many TTs per hub).  even if they're uncommon.\n\t */\n\tclear = kmalloc(sizeof *clear, GFP_ATOMIC);\n\tif (clear == NULL) {\n\t\tdev_err(&udev->dev, \"can't save CLEAR_TT_BUFFER state\\n\");\n\t\t/* FIXME recover somehow ... RESET_TT? */\n\t\treturn -ENOMEM;\n\t}\n\n\t/* info that CLEAR_TT_BUFFER needs */\n\tclear->tt = tt->multi ? udev->ttport : 1;\n\tclear->devinfo = usb_pipeendpoint (pipe);\n\tclear->devinfo |= udev->devnum << 4;\n\tclear->devinfo |= usb_pipecontrol(pipe)\n\t\t\t? (USB_ENDPOINT_XFER_CONTROL << 11)\n\t\t\t: (USB_ENDPOINT_XFER_BULK << 11);\n\tif (usb_pipein(pipe))\n\t\tclear->devinfo |= 1 << 15;\n\n\t/* info for completion callback */\n\tclear->hcd = bus_to_hcd(udev->bus);\n\tclear->ep = urb->ep;\n\n\t/* tell keventd to clear state for this TT */\n\tspin_lock_irqsave(&tt->lock, flags);\n\tlist_add_tail(&clear->clear_list, &tt->clear_list);\n\tschedule_work(&tt->clear_work);\n\tspin_unlock_irqrestore(&tt->lock, flags);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_hub_clear_tt_buffer);\n\nstatic void hub_power_on(struct usb_hub *hub, bool do_delay)\n{\n\tint port1;\n\n\t/* Enable power on each port.  Some hubs have reserved values\n\t * of LPSM (> 2) in their descriptors, even though they are\n\t * USB 2.0 hubs.  Some hubs do not implement port-power switching\n\t * but only emulate it.  In all cases, the ports won't work\n\t * unless we send these messages to the hub.\n\t */\n\tif (hub_is_port_power_switchable(hub))\n\t\tdev_dbg(hub->intfdev, \"enabling power on all ports\\n\");\n\telse\n\t\tdev_dbg(hub->intfdev, \"trying to enable port power on \"\n\t\t\t\t\"non-switchable hub\\n\");\n\tfor (port1 = 1; port1 <= hub->hdev->maxchild; port1++)\n\t\tif (test_bit(port1, hub->power_bits))\n\t\t\tset_port_feature(hub->hdev, port1, USB_PORT_FEAT_POWER);\n\t\telse\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\t\tUSB_PORT_FEAT_POWER);\n\tif (do_delay)\n\t\tmsleep(hub_power_on_good_delay(hub));\n}\n\nstatic int hub_hub_status(struct usb_hub *hub,\n\t\tu16 *status, u16 *change)\n{\n\tint ret;\n\n\tmutex_lock(&hub->status_mutex);\n\tret = get_hub_status(hub->hdev, &hub->status->hub);\n\tif (ret < 0) {\n\t\tif (ret != -ENODEV)\n\t\t\tdev_err(hub->intfdev,\n\t\t\t\t\"%s failed (err = %d)\\n\", __func__, ret);\n\t} else {\n\t\t*status = le16_to_cpu(hub->status->hub.wHubStatus);\n\t\t*change = le16_to_cpu(hub->status->hub.wHubChange);\n\t\tret = 0;\n\t}\n\tmutex_unlock(&hub->status_mutex);\n\treturn ret;\n}\n\nstatic int hub_set_port_link_state(struct usb_hub *hub, int port1,\n\t\t\tunsigned int link_status)\n{\n\treturn set_port_feature(hub->hdev,\n\t\t\tport1 | (link_status << 3),\n\t\t\tUSB_PORT_FEAT_LINK_STATE);\n}\n\n/*\n * If USB 3.0 ports are placed into the Disabled state, they will no longer\n * detect any device connects or disconnects.  This is generally not what the\n * USB core wants, since it expects a disabled port to produce a port status\n * change event when a new device connects.\n *\n * Instead, set the link state to Disabled, wait for the link to settle into\n * that state, clear any change bits, and then put the port into the RxDetect\n * state.\n */\nstatic int hub_usb3_port_disable(struct usb_hub *hub, int port1)\n{\n\tint ret;\n\tint total_time;\n\tu16 portchange, portstatus;\n\n\tif (!hub_is_superspeed(hub->hdev))\n\t\treturn -EINVAL;\n\n\tret = hub_port_status(hub, port1, &portstatus, &portchange);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/*\n\t * USB controller Advanced Micro Devices, Inc. [AMD] FCH USB XHCI\n\t * Controller [1022:7814] will have spurious result making the following\n\t * usb 3.0 device hotplugging route to the 2.0 root hub and recognized\n\t * as high-speed device if we set the usb 3.0 port link state to\n\t * Disabled. Since it's already in USB_SS_PORT_LS_RX_DETECT state, we\n\t * check the state here to avoid the bug.\n\t */\n\tif ((portstatus & USB_PORT_STAT_LINK_STATE) ==\n\t\t\t\tUSB_SS_PORT_LS_RX_DETECT) {\n\t\tdev_dbg(&hub->ports[port1 - 1]->dev,\n\t\t\t \"Not disabling port; link state is RxDetect\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hub_set_port_link_state(hub, port1, USB_SS_PORT_LS_SS_DISABLED);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Wait for the link to enter the disabled state. */\n\tfor (total_time = 0; ; total_time += HUB_DEBOUNCE_STEP) {\n\t\tret = hub_port_status(hub, port1, &portstatus, &portchange);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif ((portstatus & USB_PORT_STAT_LINK_STATE) ==\n\t\t\t\tUSB_SS_PORT_LS_SS_DISABLED)\n\t\t\tbreak;\n\t\tif (total_time >= HUB_DEBOUNCE_TIMEOUT)\n\t\t\tbreak;\n\t\tmsleep(HUB_DEBOUNCE_STEP);\n\t}\n\tif (total_time >= HUB_DEBOUNCE_TIMEOUT)\n\t\tdev_warn(&hub->ports[port1 - 1]->dev,\n\t\t\t\t\"Could not disable after %d ms\\n\", total_time);\n\n\treturn hub_set_port_link_state(hub, port1, USB_SS_PORT_LS_RX_DETECT);\n}\n\nstatic int hub_port_disable(struct usb_hub *hub, int port1, int set_state)\n{\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tstruct usb_device *hdev = hub->hdev;\n\tint ret = 0;\n\n\tif (port_dev->child && set_state)\n\t\tusb_set_device_state(port_dev->child, USB_STATE_NOTATTACHED);\n\tif (!hub->error) {\n\t\tif (hub_is_superspeed(hub->hdev))\n\t\t\tret = hub_usb3_port_disable(hub, port1);\n\t\telse\n\t\t\tret = usb_clear_port_feature(hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_ENABLE);\n\t}\n\tif (ret && ret != -ENODEV)\n\t\tdev_err(&port_dev->dev, \"cannot disable (err = %d)\\n\", ret);\n\treturn ret;\n}\n\n/*\n * Disable a port and mark a logical connect-change event, so that some\n * time later hub_wq will disconnect() any existing usb_device on the port\n * and will re-enumerate if there actually is a device attached.\n */\nstatic void hub_port_logical_disconnect(struct usb_hub *hub, int port1)\n{\n\tdev_dbg(&hub->ports[port1 - 1]->dev, \"logical disconnect\\n\");\n\thub_port_disable(hub, port1, 1);\n\n\t/* FIXME let caller ask to power down the port:\n\t *  - some devices won't enumerate without a VBUS power cycle\n\t *  - SRP saves power that way\n\t *  - ... new call, TBD ...\n\t * That's easy if this hub can switch power per-port, and\n\t * hub_wq reactivates the port later (timer, SRP, etc).\n\t * Powerdown must be optional, because of reset/DFU.\n\t */\n\n\tset_bit(port1, hub->change_bits);\n\tkick_hub_wq(hub);\n}\n\n/**\n * usb_remove_device - disable a device's port on its parent hub\n * @udev: device to be disabled and removed\n * Context: @udev locked, must be able to sleep.\n *\n * After @udev's port has been disabled, hub_wq is notified and it will\n * see that the device has been disconnected.  When the device is\n * physically unplugged and something is plugged in, the events will\n * be received and processed normally.\n *\n * Return: 0 if successful. A negative error code otherwise.\n */\nint usb_remove_device(struct usb_device *udev)\n{\n\tstruct usb_hub *hub;\n\tstruct usb_interface *intf;\n\n\tif (!udev->parent)\t/* Can't remove a root hub */\n\t\treturn -EINVAL;\n\thub = usb_hub_to_struct_hub(udev->parent);\n\tintf = to_usb_interface(hub->intfdev);\n\n\tusb_autopm_get_interface(intf);\n\tset_bit(udev->portnum, hub->removed_bits);\n\thub_port_logical_disconnect(hub, udev->portnum);\n\tusb_autopm_put_interface(intf);\n\treturn 0;\n}\n\nenum hub_activation_type {\n\tHUB_INIT, HUB_INIT2, HUB_INIT3,\t\t/* INITs must come first */\n\tHUB_POST_RESET, HUB_RESUME, HUB_RESET_RESUME,\n};\n\nstatic void hub_init_func2(struct work_struct *ws);\nstatic void hub_init_func3(struct work_struct *ws);\n\nstatic void hub_activate(struct usb_hub *hub, enum hub_activation_type type)\n{\n\tstruct usb_device *hdev = hub->hdev;\n\tstruct usb_hcd *hcd;\n\tint ret;\n\tint port1;\n\tint status;\n\tbool need_debounce_delay = false;\n\tunsigned delay;\n\n\t/* Continue a partial initialization */\n\tif (type == HUB_INIT2)\n\t\tgoto init2;\n\tif (type == HUB_INIT3)\n\t\tgoto init3;\n\n\t/* The superspeed hub except for root hub has to use Hub Depth\n\t * value as an offset into the route string to locate the bits\n\t * it uses to determine the downstream port number. So hub driver\n\t * should send a set hub depth request to superspeed hub after\n\t * the superspeed hub is set configuration in initialization or\n\t * reset procedure.\n\t *\n\t * After a resume, port power should still be on.\n\t * For any other type of activation, turn it on.\n\t */\n\tif (type != HUB_RESUME) {\n\t\tif (hdev->parent && hub_is_superspeed(hdev)) {\n\t\t\tret = usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\n\t\t\t\t\tHUB_SET_DEPTH, USB_RT_HUB,\n\t\t\t\t\thdev->level - 1, 0, NULL, 0,\n\t\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_err(hub->intfdev,\n\t\t\t\t\t\t\"set hub depth failed\\n\");\n\t\t}\n\n\t\t/* Speed up system boot by using a delayed_work for the\n\t\t * hub's initial power-up delays.  This is pretty awkward\n\t\t * and the implementation looks like a home-brewed sort of\n\t\t * setjmp/longjmp, but it saves at least 100 ms for each\n\t\t * root hub (assuming usbcore is compiled into the kernel\n\t\t * rather than as a module).  It adds up.\n\t\t *\n\t\t * This can't be done for HUB_RESUME or HUB_RESET_RESUME\n\t\t * because for those activation types the ports have to be\n\t\t * operational when we return.  In theory this could be done\n\t\t * for HUB_POST_RESET, but it's easier not to.\n\t\t */\n\t\tif (type == HUB_INIT) {\n\t\t\tdelay = hub_power_on_good_delay(hub);\n\n\t\t\thub_power_on(hub, false);\n\t\t\tINIT_DELAYED_WORK(&hub->init_work, hub_init_func2);\n\t\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t\t&hub->init_work,\n\t\t\t\t\tmsecs_to_jiffies(delay));\n\n\t\t\t/* Suppress autosuspend until init is done */\n\t\t\tusb_autopm_get_interface_no_resume(\n\t\t\t\t\tto_usb_interface(hub->intfdev));\n\t\t\treturn;\t\t/* Continues at init2: below */\n\t\t} else if (type == HUB_RESET_RESUME) {\n\t\t\t/* The internal host controller state for the hub device\n\t\t\t * may be gone after a host power loss on system resume.\n\t\t\t * Update the device's info so the HW knows it's a hub.\n\t\t\t */\n\t\t\thcd = bus_to_hcd(hdev->bus);\n\t\t\tif (hcd->driver->update_hub_device) {\n\t\t\t\tret = hcd->driver->update_hub_device(hcd, hdev,\n\t\t\t\t\t\t&hub->tt, GFP_NOIO);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tdev_err(hub->intfdev, \"Host not \"\n\t\t\t\t\t\t\t\"accepting hub info \"\n\t\t\t\t\t\t\t\"update.\\n\");\n\t\t\t\t\tdev_err(hub->intfdev, \"LS/FS devices \"\n\t\t\t\t\t\t\t\"and hubs may not work \"\n\t\t\t\t\t\t\t\"under this hub\\n.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\thub_power_on(hub, true);\n\t\t} else {\n\t\t\thub_power_on(hub, true);\n\t\t}\n\t}\n init2:\n\n\t/*\n\t * Check each port and set hub->change_bits to let hub_wq know\n\t * which ports need attention.\n\t */\n\tfor (port1 = 1; port1 <= hdev->maxchild; ++port1) {\n\t\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\t\tstruct usb_device *udev = port_dev->child;\n\t\tu16 portstatus, portchange;\n\n\t\tportstatus = portchange = 0;\n\t\tstatus = hub_port_status(hub, port1, &portstatus, &portchange);\n\t\tif (udev || (portstatus & USB_PORT_STAT_CONNECTION))\n\t\t\tdev_dbg(&port_dev->dev, \"status %04x change %04x\\n\",\n\t\t\t\t\tportstatus, portchange);\n\n\t\t/*\n\t\t * After anything other than HUB_RESUME (i.e., initialization\n\t\t * or any sort of reset), every port should be disabled.\n\t\t * Unconnected ports should likewise be disabled (paranoia),\n\t\t * and so should ports for which we have no usb_device.\n\t\t */\n\t\tif ((portstatus & USB_PORT_STAT_ENABLE) && (\n\t\t\t\ttype != HUB_RESUME ||\n\t\t\t\t!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t\t!udev ||\n\t\t\t\tudev->state == USB_STATE_NOTATTACHED)) {\n\t\t\t/*\n\t\t\t * USB3 protocol ports will automatically transition\n\t\t\t * to Enabled state when detect an USB3.0 device attach.\n\t\t\t * Do not disable USB3 protocol ports, just pretend\n\t\t\t * power was lost\n\t\t\t */\n\t\t\tportstatus &= ~USB_PORT_STAT_ENABLE;\n\t\t\tif (!hub_is_superspeed(hdev))\n\t\t\t\tusb_clear_port_feature(hdev, port1,\n\t\t\t\t\t\t   USB_PORT_FEAT_ENABLE);\n\t\t}\n\n\t\t/* Clear status-change flags; we'll debounce later */\n\t\tif (portchange & USB_PORT_STAT_C_CONNECTION) {\n\t\t\tneed_debounce_delay = true;\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_CONNECTION);\n\t\t}\n\t\tif (portchange & USB_PORT_STAT_C_ENABLE) {\n\t\t\tneed_debounce_delay = true;\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_ENABLE);\n\t\t}\n\t\tif (portchange & USB_PORT_STAT_C_RESET) {\n\t\t\tneed_debounce_delay = true;\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_RESET);\n\t\t}\n\t\tif ((portchange & USB_PORT_STAT_C_BH_RESET) &&\n\t\t\t\thub_is_superspeed(hub->hdev)) {\n\t\t\tneed_debounce_delay = true;\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_BH_PORT_RESET);\n\t\t}\n\t\t/* We can forget about a \"removed\" device when there's a\n\t\t * physical disconnect or the connect status changes.\n\t\t */\n\t\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t\t(portchange & USB_PORT_STAT_C_CONNECTION))\n\t\t\tclear_bit(port1, hub->removed_bits);\n\n\t\tif (!udev || udev->state == USB_STATE_NOTATTACHED) {\n\t\t\t/* Tell hub_wq to disconnect the device or\n\t\t\t * check for a new connection\n\t\t\t */\n\t\t\tif (udev || (portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t    (portstatus & USB_PORT_STAT_OVERCURRENT))\n\t\t\t\tset_bit(port1, hub->change_bits);\n\n\t\t} else if (portstatus & USB_PORT_STAT_ENABLE) {\n\t\t\tbool port_resumed = (portstatus &\n\t\t\t\t\tUSB_PORT_STAT_LINK_STATE) ==\n\t\t\t\tUSB_SS_PORT_LS_U0;\n\t\t\t/* The power session apparently survived the resume.\n\t\t\t * If there was an overcurrent or suspend change\n\t\t\t * (i.e., remote wakeup request), have hub_wq\n\t\t\t * take care of it.  Look at the port link state\n\t\t\t * for USB 3.0 hubs, since they don't have a suspend\n\t\t\t * change bit, and they don't set the port link change\n\t\t\t * bit on device-initiated resume.\n\t\t\t */\n\t\t\tif (portchange || (hub_is_superspeed(hub->hdev) &&\n\t\t\t\t\t\tport_resumed))\n\t\t\t\tset_bit(port1, hub->change_bits);\n\n\t\t} else if (udev->persist_enabled) {\n#ifdef CONFIG_PM\n\t\t\tudev->reset_resume = 1;\n#endif\n\t\t\t/* Don't set the change_bits when the device\n\t\t\t * was powered off.\n\t\t\t */\n\t\t\tif (test_bit(port1, hub->power_bits))\n\t\t\t\tset_bit(port1, hub->change_bits);\n\n\t\t} else {\n\t\t\t/* The power session is gone; tell hub_wq */\n\t\t\tusb_set_device_state(udev, USB_STATE_NOTATTACHED);\n\t\t\tset_bit(port1, hub->change_bits);\n\t\t}\n\t}\n\n\t/* If no port-status-change flags were set, we don't need any\n\t * debouncing.  If flags were set we can try to debounce the\n\t * ports all at once right now, instead of letting hub_wq do them\n\t * one at a time later on.\n\t *\n\t * If any port-status changes do occur during this delay, hub_wq\n\t * will see them later and handle them normally.\n\t */\n\tif (need_debounce_delay) {\n\t\tdelay = HUB_DEBOUNCE_STABLE;\n\n\t\t/* Don't do a long sleep inside a workqueue routine */\n\t\tif (type == HUB_INIT2) {\n\t\t\tINIT_DELAYED_WORK(&hub->init_work, hub_init_func3);\n\t\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t\t&hub->init_work,\n\t\t\t\t\tmsecs_to_jiffies(delay));\n\t\t\treturn;\t\t/* Continues at init3: below */\n\t\t} else {\n\t\t\tmsleep(delay);\n\t\t}\n\t}\n init3:\n\thub->quiescing = 0;\n\n\tstatus = usb_submit_urb(hub->urb, GFP_NOIO);\n\tif (status < 0)\n\t\tdev_err(hub->intfdev, \"activate --> %d\\n\", status);\n\tif (hub->has_indicators && blinkenlights)\n\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t&hub->leds, LED_CYCLE_PERIOD);\n\n\t/* Scan all ports that need attention */\n\tkick_hub_wq(hub);\n\n\t/* Allow autosuspend if it was suppressed */\n\tif (type <= HUB_INIT3)\n\t\tusb_autopm_put_interface_async(to_usb_interface(hub->intfdev));\n}\n\n/* Implement the continuations for the delays above */\nstatic void hub_init_func2(struct work_struct *ws)\n{\n\tstruct usb_hub *hub = container_of(ws, struct usb_hub, init_work.work);\n\n\thub_activate(hub, HUB_INIT2);\n}\n\nstatic void hub_init_func3(struct work_struct *ws)\n{\n\tstruct usb_hub *hub = container_of(ws, struct usb_hub, init_work.work);\n\n\thub_activate(hub, HUB_INIT3);\n}\n\nenum hub_quiescing_type {\n\tHUB_DISCONNECT, HUB_PRE_RESET, HUB_SUSPEND\n};\n\nstatic void hub_quiesce(struct usb_hub *hub, enum hub_quiescing_type type)\n{\n\tstruct usb_device *hdev = hub->hdev;\n\tint i;\n\n\tcancel_delayed_work_sync(&hub->init_work);\n\n\t/* hub_wq and related activity won't re-trigger */\n\thub->quiescing = 1;\n\n\tif (type != HUB_SUSPEND) {\n\t\t/* Disconnect all the children */\n\t\tfor (i = 0; i < hdev->maxchild; ++i) {\n\t\t\tif (hub->ports[i]->child)\n\t\t\t\tusb_disconnect(&hub->ports[i]->child);\n\t\t}\n\t}\n\n\t/* Stop hub_wq and related activity */\n\tusb_kill_urb(hub->urb);\n\tif (hub->has_indicators)\n\t\tcancel_delayed_work_sync(&hub->leds);\n\tif (hub->tt.hub)\n\t\tflush_work(&hub->tt.clear_work);\n}\n\nstatic void hub_pm_barrier_for_all_ports(struct usb_hub *hub)\n{\n\tint i;\n\n\tfor (i = 0; i < hub->hdev->maxchild; ++i)\n\t\tpm_runtime_barrier(&hub->ports[i]->dev);\n}\n\n/* caller has locked the hub device */\nstatic int hub_pre_reset(struct usb_interface *intf)\n{\n\tstruct usb_hub *hub = usb_get_intfdata(intf);\n\n\thub_quiesce(hub, HUB_PRE_RESET);\n\thub->in_reset = 1;\n\thub_pm_barrier_for_all_ports(hub);\n\treturn 0;\n}\n\n/* caller has locked the hub device */\nstatic int hub_post_reset(struct usb_interface *intf)\n{\n\tstruct usb_hub *hub = usb_get_intfdata(intf);\n\n\thub->in_reset = 0;\n\thub_pm_barrier_for_all_ports(hub);\n\thub_activate(hub, HUB_POST_RESET);\n\treturn 0;\n}\n\nstatic int hub_configure(struct usb_hub *hub,\n\tstruct usb_endpoint_descriptor *endpoint)\n{\n\tstruct usb_hcd *hcd;\n\tstruct usb_device *hdev = hub->hdev;\n\tstruct device *hub_dev = hub->intfdev;\n\tu16 hubstatus, hubchange;\n\tu16 wHubCharacteristics;\n\tunsigned int pipe;\n\tint maxp, ret, i;\n\tchar *message = \"out of memory\";\n\tunsigned unit_load;\n\tunsigned full_load;\n\tunsigned maxchild;\n\n\thub->buffer = kmalloc(sizeof(*hub->buffer), GFP_KERNEL);\n\tif (!hub->buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\thub->status = kmalloc(sizeof(*hub->status), GFP_KERNEL);\n\tif (!hub->status) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tmutex_init(&hub->status_mutex);\n\n\thub->descriptor = kmalloc(sizeof(*hub->descriptor), GFP_KERNEL);\n\tif (!hub->descriptor) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\t/* Request the entire hub descriptor.\n\t * hub->descriptor can handle USB_MAXCHILDREN ports,\n\t * but the hub can/will return fewer bytes here.\n\t */\n\tret = get_hub_descriptor(hdev, hub->descriptor);\n\tif (ret < 0) {\n\t\tmessage = \"can't read hub descriptor\";\n\t\tgoto fail;\n\t} else if (hub->descriptor->bNbrPorts > USB_MAXCHILDREN) {\n\t\tmessage = \"hub has too many ports!\";\n\t\tret = -ENODEV;\n\t\tgoto fail;\n\t} else if (hub->descriptor->bNbrPorts == 0) {\n\t\tmessage = \"hub doesn't have any ports!\";\n\t\tret = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\tmaxchild = hub->descriptor->bNbrPorts;\n\tdev_info(hub_dev, \"%d port%s detected\\n\", maxchild,\n\t\t\t(maxchild == 1) ? \"\" : \"s\");\n\n\thub->ports = kzalloc(maxchild * sizeof(struct usb_port *), GFP_KERNEL);\n\tif (!hub->ports) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\twHubCharacteristics = le16_to_cpu(hub->descriptor->wHubCharacteristics);\n\tif (hub_is_superspeed(hdev)) {\n\t\tunit_load = 150;\n\t\tfull_load = 900;\n\t} else {\n\t\tunit_load = 100;\n\t\tfull_load = 500;\n\t}\n\n\t/* FIXME for USB 3.0, skip for now */\n\tif ((wHubCharacteristics & HUB_CHAR_COMPOUND) &&\n\t\t\t!(hub_is_superspeed(hdev))) {\n\t\tchar\tportstr[USB_MAXCHILDREN + 1];\n\n\t\tfor (i = 0; i < maxchild; i++)\n\t\t\tportstr[i] = hub->descriptor->u.hs.DeviceRemovable\n\t\t\t\t    [((i + 1) / 8)] & (1 << ((i + 1) % 8))\n\t\t\t\t? 'F' : 'R';\n\t\tportstr[maxchild] = 0;\n\t\tdev_dbg(hub_dev, \"compound device; port removable status: %s\\n\", portstr);\n\t} else\n\t\tdev_dbg(hub_dev, \"standalone hub\\n\");\n\n\tswitch (wHubCharacteristics & HUB_CHAR_LPSM) {\n\tcase HUB_CHAR_COMMON_LPSM:\n\t\tdev_dbg(hub_dev, \"ganged power switching\\n\");\n\t\tbreak;\n\tcase HUB_CHAR_INDV_PORT_LPSM:\n\t\tdev_dbg(hub_dev, \"individual port power switching\\n\");\n\t\tbreak;\n\tcase HUB_CHAR_NO_LPSM:\n\tcase HUB_CHAR_LPSM:\n\t\tdev_dbg(hub_dev, \"no power switching (usb 1.0)\\n\");\n\t\tbreak;\n\t}\n\n\tswitch (wHubCharacteristics & HUB_CHAR_OCPM) {\n\tcase HUB_CHAR_COMMON_OCPM:\n\t\tdev_dbg(hub_dev, \"global over-current protection\\n\");\n\t\tbreak;\n\tcase HUB_CHAR_INDV_PORT_OCPM:\n\t\tdev_dbg(hub_dev, \"individual port over-current protection\\n\");\n\t\tbreak;\n\tcase HUB_CHAR_NO_OCPM:\n\tcase HUB_CHAR_OCPM:\n\t\tdev_dbg(hub_dev, \"no over-current protection\\n\");\n\t\tbreak;\n\t}\n\n\tspin_lock_init(&hub->tt.lock);\n\tINIT_LIST_HEAD(&hub->tt.clear_list);\n\tINIT_WORK(&hub->tt.clear_work, hub_tt_work);\n\tswitch (hdev->descriptor.bDeviceProtocol) {\n\tcase USB_HUB_PR_FS:\n\t\tbreak;\n\tcase USB_HUB_PR_HS_SINGLE_TT:\n\t\tdev_dbg(hub_dev, \"Single TT\\n\");\n\t\thub->tt.hub = hdev;\n\t\tbreak;\n\tcase USB_HUB_PR_HS_MULTI_TT:\n\t\tret = usb_set_interface(hdev, 0, 1);\n\t\tif (ret == 0) {\n\t\t\tdev_dbg(hub_dev, \"TT per port\\n\");\n\t\t\thub->tt.multi = 1;\n\t\t} else\n\t\t\tdev_err(hub_dev, \"Using single TT (err %d)\\n\",\n\t\t\t\tret);\n\t\thub->tt.hub = hdev;\n\t\tbreak;\n\tcase USB_HUB_PR_SS:\n\t\t/* USB 3.0 hubs don't have a TT */\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(hub_dev, \"Unrecognized hub protocol %d\\n\",\n\t\t\thdev->descriptor.bDeviceProtocol);\n\t\tbreak;\n\t}\n\n\t/* Note 8 FS bit times == (8 bits / 12000000 bps) ~= 666ns */\n\tswitch (wHubCharacteristics & HUB_CHAR_TTTT) {\n\tcase HUB_TTTT_8_BITS:\n\t\tif (hdev->descriptor.bDeviceProtocol != 0) {\n\t\t\thub->tt.think_time = 666;\n\t\t\tdev_dbg(hub_dev, \"TT requires at most %d \"\n\t\t\t\t\t\"FS bit times (%d ns)\\n\",\n\t\t\t\t8, hub->tt.think_time);\n\t\t}\n\t\tbreak;\n\tcase HUB_TTTT_16_BITS:\n\t\thub->tt.think_time = 666 * 2;\n\t\tdev_dbg(hub_dev, \"TT requires at most %d \"\n\t\t\t\t\"FS bit times (%d ns)\\n\",\n\t\t\t16, hub->tt.think_time);\n\t\tbreak;\n\tcase HUB_TTTT_24_BITS:\n\t\thub->tt.think_time = 666 * 3;\n\t\tdev_dbg(hub_dev, \"TT requires at most %d \"\n\t\t\t\t\"FS bit times (%d ns)\\n\",\n\t\t\t24, hub->tt.think_time);\n\t\tbreak;\n\tcase HUB_TTTT_32_BITS:\n\t\thub->tt.think_time = 666 * 4;\n\t\tdev_dbg(hub_dev, \"TT requires at most %d \"\n\t\t\t\t\"FS bit times (%d ns)\\n\",\n\t\t\t32, hub->tt.think_time);\n\t\tbreak;\n\t}\n\n\t/* probe() zeroes hub->indicator[] */\n\tif (wHubCharacteristics & HUB_CHAR_PORTIND) {\n\t\thub->has_indicators = 1;\n\t\tdev_dbg(hub_dev, \"Port indicators are supported\\n\");\n\t}\n\n\tdev_dbg(hub_dev, \"power on to power good time: %dms\\n\",\n\t\thub->descriptor->bPwrOn2PwrGood * 2);\n\n\t/* power budgeting mostly matters with bus-powered hubs,\n\t * and battery-powered root hubs (may provide just 8 mA).\n\t */\n\tret = usb_get_status(hdev, USB_RECIP_DEVICE, 0, &hubstatus);\n\tif (ret) {\n\t\tmessage = \"can't get hub status\";\n\t\tgoto fail;\n\t}\n\thcd = bus_to_hcd(hdev->bus);\n\tif (hdev == hdev->bus->root_hub) {\n\t\tif (hcd->power_budget > 0)\n\t\t\thdev->bus_mA = hcd->power_budget;\n\t\telse\n\t\t\thdev->bus_mA = full_load * maxchild;\n\t\tif (hdev->bus_mA >= full_load)\n\t\t\thub->mA_per_port = full_load;\n\t\telse {\n\t\t\thub->mA_per_port = hdev->bus_mA;\n\t\t\thub->limited_power = 1;\n\t\t}\n\t} else if ((hubstatus & (1 << USB_DEVICE_SELF_POWERED)) == 0) {\n\t\tint remaining = hdev->bus_mA -\n\t\t\thub->descriptor->bHubContrCurrent;\n\n\t\tdev_dbg(hub_dev, \"hub controller current requirement: %dmA\\n\",\n\t\t\thub->descriptor->bHubContrCurrent);\n\t\thub->limited_power = 1;\n\n\t\tif (remaining < maxchild * unit_load)\n\t\t\tdev_warn(hub_dev,\n\t\t\t\t\t\"insufficient power available \"\n\t\t\t\t\t\"to use all downstream ports\\n\");\n\t\thub->mA_per_port = unit_load;\t/* 7.2.1 */\n\n\t} else {\t/* Self-powered external hub */\n\t\t/* FIXME: What about battery-powered external hubs that\n\t\t * provide less current per port? */\n\t\thub->mA_per_port = full_load;\n\t}\n\tif (hub->mA_per_port < full_load)\n\t\tdev_dbg(hub_dev, \"%umA bus power budget for each child\\n\",\n\t\t\t\thub->mA_per_port);\n\n\tret = hub_hub_status(hub, &hubstatus, &hubchange);\n\tif (ret < 0) {\n\t\tmessage = \"can't get hub status\";\n\t\tgoto fail;\n\t}\n\n\t/* local power status reports aren't always correct */\n\tif (hdev->actconfig->desc.bmAttributes & USB_CONFIG_ATT_SELFPOWER)\n\t\tdev_dbg(hub_dev, \"local power source is %s\\n\",\n\t\t\t(hubstatus & HUB_STATUS_LOCAL_POWER)\n\t\t\t? \"lost (inactive)\" : \"good\");\n\n\tif ((wHubCharacteristics & HUB_CHAR_OCPM) == 0)\n\t\tdev_dbg(hub_dev, \"%sover-current condition exists\\n\",\n\t\t\t(hubstatus & HUB_STATUS_OVERCURRENT) ? \"\" : \"no \");\n\n\t/* set up the interrupt endpoint\n\t * We use the EP's maxpacket size instead of (PORTS+1+7)/8\n\t * bytes as USB2.0[11.12.3] says because some hubs are known\n\t * to send more data (and thus cause overflow). For root hubs,\n\t * maxpktsize is defined in hcd.c's fake endpoint descriptors\n\t * to be big enough for at least USB_MAXCHILDREN ports. */\n\tpipe = usb_rcvintpipe(hdev, endpoint->bEndpointAddress);\n\tmaxp = usb_maxpacket(hdev, pipe, usb_pipeout(pipe));\n\n\tif (maxp > sizeof(*hub->buffer))\n\t\tmaxp = sizeof(*hub->buffer);\n\n\thub->urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!hub->urb) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tusb_fill_int_urb(hub->urb, hdev, pipe, *hub->buffer, maxp, hub_irq,\n\t\thub, endpoint->bInterval);\n\n\t/* maybe cycle the hub leds */\n\tif (hub->has_indicators && blinkenlights)\n\t\thub->indicator[0] = INDICATOR_CYCLE;\n\n\tmutex_lock(&usb_port_peer_mutex);\n\tfor (i = 0; i < maxchild; i++) {\n\t\tret = usb_hub_create_port_device(hub, i + 1);\n\t\tif (ret < 0) {\n\t\t\tdev_err(hub->intfdev,\n\t\t\t\t\"couldn't create port%d device.\\n\", i + 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\thdev->maxchild = i;\n\tfor (i = 0; i < hdev->maxchild; i++) {\n\t\tstruct usb_port *port_dev = hub->ports[i];\n\n\t\tpm_runtime_put(&port_dev->dev);\n\t}\n\n\tmutex_unlock(&usb_port_peer_mutex);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\t/* Update the HCD's internal representation of this hub before hub_wq\n\t * starts getting port status changes for devices under the hub.\n\t */\n\tif (hcd->driver->update_hub_device) {\n\t\tret = hcd->driver->update_hub_device(hcd, hdev,\n\t\t\t\t&hub->tt, GFP_KERNEL);\n\t\tif (ret < 0) {\n\t\t\tmessage = \"can't update HCD hub info\";\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tusb_hub_adjust_deviceremovable(hdev, hub->descriptor);\n\n\thub_activate(hub, HUB_INIT);\n\treturn 0;\n\nfail:\n\tdev_err(hub_dev, \"config failed, %s (err %d)\\n\",\n\t\t\tmessage, ret);\n\t/* hub_disconnect() frees urb and descriptor */\n\treturn ret;\n}\n\nstatic void hub_release(struct kref *kref)\n{\n\tstruct usb_hub *hub = container_of(kref, struct usb_hub, kref);\n\n\tusb_put_dev(hub->hdev);\n\tusb_put_intf(to_usb_interface(hub->intfdev));\n\tkfree(hub);\n}\n\nstatic unsigned highspeed_hubs;\n\nstatic void hub_disconnect(struct usb_interface *intf)\n{\n\tstruct usb_hub *hub = usb_get_intfdata(intf);\n\tstruct usb_device *hdev = interface_to_usbdev(intf);\n\tint port1;\n\n\t/*\n\t * Stop adding new hub events. We do not want to block here and thus\n\t * will not try to remove any pending work item.\n\t */\n\thub->disconnected = 1;\n\n\t/* Disconnect all children and quiesce the hub */\n\thub->error = 0;\n\thub_quiesce(hub, HUB_DISCONNECT);\n\n\tmutex_lock(&usb_port_peer_mutex);\n\n\t/* Avoid races with recursively_mark_NOTATTACHED() */\n\tspin_lock_irq(&device_state_lock);\n\tport1 = hdev->maxchild;\n\thdev->maxchild = 0;\n\tusb_set_intfdata(intf, NULL);\n\tspin_unlock_irq(&device_state_lock);\n\n\tfor (; port1 > 0; --port1)\n\t\tusb_hub_remove_port_device(hub, port1);\n\n\tmutex_unlock(&usb_port_peer_mutex);\n\n\tif (hub->hdev->speed == USB_SPEED_HIGH)\n\t\thighspeed_hubs--;\n\n\tusb_free_urb(hub->urb);\n\tkfree(hub->ports);\n\tkfree(hub->descriptor);\n\tkfree(hub->status);\n\tkfree(hub->buffer);\n\n\tpm_suspend_ignore_children(&intf->dev, false);\n\tkref_put(&hub->kref, hub_release);\n}\n\nstatic int hub_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct usb_host_interface *desc;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tstruct usb_device *hdev;\n\tstruct usb_hub *hub;\n\n\tdesc = intf->cur_altsetting;\n\thdev = interface_to_usbdev(intf);\n\n\t/*\n\t * Set default autosuspend delay as 0 to speedup bus suspend,\n\t * based on the below considerations:\n\t *\n\t * - Unlike other drivers, the hub driver does not rely on the\n\t *   autosuspend delay to provide enough time to handle a wakeup\n\t *   event, and the submitted status URB is just to check future\n\t *   change on hub downstream ports, so it is safe to do it.\n\t *\n\t * - The patch might cause one or more auto supend/resume for\n\t *   below very rare devices when they are plugged into hub\n\t *   first time:\n\t *\n\t *   \tdevices having trouble initializing, and disconnect\n\t *   \tthemselves from the bus and then reconnect a second\n\t *   \tor so later\n\t *\n\t *   \tdevices just for downloading firmware, and disconnects\n\t *   \tthemselves after completing it\n\t *\n\t *   For these quite rare devices, their drivers may change the\n\t *   autosuspend delay of their parent hub in the probe() to one\n\t *   appropriate value to avoid the subtle problem if someone\n\t *   does care it.\n\t *\n\t * - The patch may cause one or more auto suspend/resume on\n\t *   hub during running 'lsusb', but it is probably too\n\t *   infrequent to worry about.\n\t *\n\t * - Change autosuspend delay of hub can avoid unnecessary auto\n\t *   suspend timer for hub, also may decrease power consumption\n\t *   of USB bus.\n\t *\n\t * - If user has indicated to prevent autosuspend by passing\n\t *   usbcore.autosuspend = -1 then keep autosuspend disabled.\n\t */\n#ifdef CONFIG_PM\n\tif (hdev->dev.power.autosuspend_delay >= 0)\n\t\tpm_runtime_set_autosuspend_delay(&hdev->dev, 0);\n#endif\n\n\t/*\n\t * Hubs have proper suspend/resume support, except for root hubs\n\t * where the controller driver doesn't have bus_suspend and\n\t * bus_resume methods.\n\t */\n\tif (hdev->parent) {\t\t/* normal device */\n\t\tusb_enable_autosuspend(hdev);\n\t} else {\t\t\t/* root hub */\n\t\tconst struct hc_driver *drv = bus_to_hcd(hdev->bus)->driver;\n\n\t\tif (drv->bus_suspend && drv->bus_resume)\n\t\t\tusb_enable_autosuspend(hdev);\n\t}\n\n\tif (hdev->level == MAX_TOPO_LEVEL) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"Unsupported bus topology: hub nested too deep\\n\");\n\t\treturn -E2BIG;\n\t}\n\n#ifdef\tCONFIG_USB_OTG_BLACKLIST_HUB\n\tif (hdev->parent) {\n\t\tdev_warn(&intf->dev, \"ignoring external hub\\n\");\n\t\treturn -ENODEV;\n\t}\n#endif\n\n\t/* Some hubs have a subclass of 1, which AFAICT according to the */\n\t/*  specs is not defined, but it works */\n\tif ((desc->desc.bInterfaceSubClass != 0) &&\n\t    (desc->desc.bInterfaceSubClass != 1)) {\ndescriptor_error:\n\t\tdev_err(&intf->dev, \"bad descriptor, ignoring hub\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* Multiple endpoints? What kind of mutant ninja-hub is this? */\n\tif (desc->desc.bNumEndpoints != 1)\n\t\tgoto descriptor_error;\n\n\tendpoint = &desc->endpoint[0].desc;\n\n\t/* If it's not an interrupt in endpoint, we'd better punt! */\n\tif (!usb_endpoint_is_int_in(endpoint))\n\t\tgoto descriptor_error;\n\n\t/* We found a hub */\n\tdev_info(&intf->dev, \"USB hub found\\n\");\n\n\thub = kzalloc(sizeof(*hub), GFP_KERNEL);\n\tif (!hub) {\n\t\tdev_dbg(&intf->dev, \"couldn't kmalloc hub struct\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tkref_init(&hub->kref);\n\thub->intfdev = &intf->dev;\n\thub->hdev = hdev;\n\tINIT_DELAYED_WORK(&hub->leds, led_work);\n\tINIT_DELAYED_WORK(&hub->init_work, NULL);\n\tINIT_WORK(&hub->events, hub_event);\n\tusb_get_intf(intf);\n\tusb_get_dev(hdev);\n\n\tusb_set_intfdata(intf, hub);\n\tintf->needs_remote_wakeup = 1;\n\tpm_suspend_ignore_children(&intf->dev, true);\n\n\tif (hdev->speed == USB_SPEED_HIGH)\n\t\thighspeed_hubs++;\n\n\tif (id->driver_info & HUB_QUIRK_CHECK_PORT_AUTOSUSPEND)\n\t\thub->quirk_check_port_auto_suspend = 1;\n\n\tif (hub_configure(hub, endpoint) >= 0)\n\t\treturn 0;\n\n\thub_disconnect(intf);\n\treturn -ENODEV;\n}\n\nstatic int\nhub_ioctl(struct usb_interface *intf, unsigned int code, void *user_data)\n{\n\tstruct usb_device *hdev = interface_to_usbdev(intf);\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\n\t/* assert ifno == 0 (part of hub spec) */\n\tswitch (code) {\n\tcase USBDEVFS_HUB_PORTINFO: {\n\t\tstruct usbdevfs_hub_portinfo *info = user_data;\n\t\tint i;\n\n\t\tspin_lock_irq(&device_state_lock);\n\t\tif (hdev->devnum <= 0)\n\t\t\tinfo->nports = 0;\n\t\telse {\n\t\t\tinfo->nports = hdev->maxchild;\n\t\t\tfor (i = 0; i < info->nports; i++) {\n\t\t\t\tif (hub->ports[i]->child == NULL)\n\t\t\t\t\tinfo->port[i] = 0;\n\t\t\t\telse\n\t\t\t\t\tinfo->port[i] =\n\t\t\t\t\t\thub->ports[i]->child->devnum;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irq(&device_state_lock);\n\n\t\treturn info->nports + 1;\n\t\t}\n\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n}\n\n/*\n * Allow user programs to claim ports on a hub.  When a device is attached\n * to one of these \"claimed\" ports, the program will \"own\" the device.\n */\nstatic int find_port_owner(struct usb_device *hdev, unsigned port1,\n\t\tstruct usb_dev_state ***ppowner)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\n\tif (hdev->state == USB_STATE_NOTATTACHED)\n\t\treturn -ENODEV;\n\tif (port1 == 0 || port1 > hdev->maxchild)\n\t\treturn -EINVAL;\n\n\t/* Devices not managed by the hub driver\n\t * will always have maxchild equal to 0.\n\t */\n\t*ppowner = &(hub->ports[port1 - 1]->port_owner);\n\treturn 0;\n}\n\n/* In the following three functions, the caller must hold hdev's lock */\nint usb_hub_claim_port(struct usb_device *hdev, unsigned port1,\n\t\t       struct usb_dev_state *owner)\n{\n\tint rc;\n\tstruct usb_dev_state **powner;\n\n\trc = find_port_owner(hdev, port1, &powner);\n\tif (rc)\n\t\treturn rc;\n\tif (*powner)\n\t\treturn -EBUSY;\n\t*powner = owner;\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(usb_hub_claim_port);\n\nint usb_hub_release_port(struct usb_device *hdev, unsigned port1,\n\t\t\t struct usb_dev_state *owner)\n{\n\tint rc;\n\tstruct usb_dev_state **powner;\n\n\trc = find_port_owner(hdev, port1, &powner);\n\tif (rc)\n\t\treturn rc;\n\tif (*powner != owner)\n\t\treturn -ENOENT;\n\t*powner = NULL;\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(usb_hub_release_port);\n\nvoid usb_hub_release_all_ports(struct usb_device *hdev, struct usb_dev_state *owner)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\tint n;\n\n\tfor (n = 0; n < hdev->maxchild; n++) {\n\t\tif (hub->ports[n]->port_owner == owner)\n\t\t\thub->ports[n]->port_owner = NULL;\n\t}\n\n}\n\n/* The caller must hold udev's lock */\nbool usb_device_is_owned(struct usb_device *udev)\n{\n\tstruct usb_hub *hub;\n\n\tif (udev->state == USB_STATE_NOTATTACHED || !udev->parent)\n\t\treturn false;\n\thub = usb_hub_to_struct_hub(udev->parent);\n\treturn !!hub->ports[udev->portnum - 1]->port_owner;\n}\n\nstatic void recursively_mark_NOTATTACHED(struct usb_device *udev)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(udev);\n\tint i;\n\n\tfor (i = 0; i < udev->maxchild; ++i) {\n\t\tif (hub->ports[i]->child)\n\t\t\trecursively_mark_NOTATTACHED(hub->ports[i]->child);\n\t}\n\tif (udev->state == USB_STATE_SUSPENDED)\n\t\tudev->active_duration -= jiffies;\n\tudev->state = USB_STATE_NOTATTACHED;\n}\n\n/**\n * usb_set_device_state - change a device's current state (usbcore, hcds)\n * @udev: pointer to device whose state should be changed\n * @new_state: new state value to be stored\n *\n * udev->state is _not_ fully protected by the device lock.  Although\n * most transitions are made only while holding the lock, the state can\n * can change to USB_STATE_NOTATTACHED at almost any time.  This\n * is so that devices can be marked as disconnected as soon as possible,\n * without having to wait for any semaphores to be released.  As a result,\n * all changes to any device's state must be protected by the\n * device_state_lock spinlock.\n *\n * Once a device has been added to the device tree, all changes to its state\n * should be made using this routine.  The state should _not_ be set directly.\n *\n * If udev->state is already USB_STATE_NOTATTACHED then no change is made.\n * Otherwise udev->state is set to new_state, and if new_state is\n * USB_STATE_NOTATTACHED then all of udev's descendants' states are also set\n * to USB_STATE_NOTATTACHED.\n */\nvoid usb_set_device_state(struct usb_device *udev,\n\t\tenum usb_device_state new_state)\n{\n\tunsigned long flags;\n\tint wakeup = -1;\n\n\tspin_lock_irqsave(&device_state_lock, flags);\n\tif (udev->state == USB_STATE_NOTATTACHED)\n\t\t;\t/* do nothing */\n\telse if (new_state != USB_STATE_NOTATTACHED) {\n\n\t\t/* root hub wakeup capabilities are managed out-of-band\n\t\t * and may involve silicon errata ... ignore them here.\n\t\t */\n\t\tif (udev->parent) {\n\t\t\tif (udev->state == USB_STATE_SUSPENDED\n\t\t\t\t\t|| new_state == USB_STATE_SUSPENDED)\n\t\t\t\t;\t/* No change to wakeup settings */\n\t\t\telse if (new_state == USB_STATE_CONFIGURED)\n\t\t\t\twakeup = (udev->quirks &\n\t\t\t\t\tUSB_QUIRK_IGNORE_REMOTE_WAKEUP) ? 0 :\n\t\t\t\t\tudev->actconfig->desc.bmAttributes &\n\t\t\t\t\tUSB_CONFIG_ATT_WAKEUP;\n\t\t\telse\n\t\t\t\twakeup = 0;\n\t\t}\n\t\tif (udev->state == USB_STATE_SUSPENDED &&\n\t\t\tnew_state != USB_STATE_SUSPENDED)\n\t\t\tudev->active_duration -= jiffies;\n\t\telse if (new_state == USB_STATE_SUSPENDED &&\n\t\t\t\tudev->state != USB_STATE_SUSPENDED)\n\t\t\tudev->active_duration += jiffies;\n\t\tudev->state = new_state;\n\t} else\n\t\trecursively_mark_NOTATTACHED(udev);\n\tspin_unlock_irqrestore(&device_state_lock, flags);\n\tif (wakeup >= 0)\n\t\tdevice_set_wakeup_capable(&udev->dev, wakeup);\n}\nEXPORT_SYMBOL_GPL(usb_set_device_state);\n\n/*\n * Choose a device number.\n *\n * Device numbers are used as filenames in usbfs.  On USB-1.1 and\n * USB-2.0 buses they are also used as device addresses, however on\n * USB-3.0 buses the address is assigned by the controller hardware\n * and it usually is not the same as the device number.\n *\n * WUSB devices are simple: they have no hubs behind, so the mapping\n * device <-> virtual port number becomes 1:1. Why? to simplify the\n * life of the device connection logic in\n * drivers/usb/wusbcore/devconnect.c. When we do the initial secret\n * handshake we need to assign a temporary address in the unauthorized\n * space. For simplicity we use the first virtual port number found to\n * be free [drivers/usb/wusbcore/devconnect.c:wusbhc_devconnect_ack()]\n * and that becomes it's address [X < 128] or its unauthorized address\n * [X | 0x80].\n *\n * We add 1 as an offset to the one-based USB-stack port number\n * (zero-based wusb virtual port index) for two reasons: (a) dev addr\n * 0 is reserved by USB for default address; (b) Linux's USB stack\n * uses always #1 for the root hub of the controller. So USB stack's\n * port #1, which is wusb virtual-port #0 has address #2.\n *\n * Devices connected under xHCI are not as simple.  The host controller\n * supports virtualization, so the hardware assigns device addresses and\n * the HCD must setup data structures before issuing a set address\n * command to the hardware.\n */\nstatic void choose_devnum(struct usb_device *udev)\n{\n\tint\t\tdevnum;\n\tstruct usb_bus\t*bus = udev->bus;\n\n\t/* be safe when more hub events are proceed in parallel */\n\tmutex_lock(&bus->usb_address0_mutex);\n\tif (udev->wusb) {\n\t\tdevnum = udev->portnum + 1;\n\t\tBUG_ON(test_bit(devnum, bus->devmap.devicemap));\n\t} else {\n\t\t/* Try to allocate the next devnum beginning at\n\t\t * bus->devnum_next. */\n\t\tdevnum = find_next_zero_bit(bus->devmap.devicemap, 128,\n\t\t\t\t\t    bus->devnum_next);\n\t\tif (devnum >= 128)\n\t\t\tdevnum = find_next_zero_bit(bus->devmap.devicemap,\n\t\t\t\t\t\t    128, 1);\n\t\tbus->devnum_next = (devnum >= 127 ? 1 : devnum + 1);\n\t}\n\tif (devnum < 128) {\n\t\tset_bit(devnum, bus->devmap.devicemap);\n\t\tudev->devnum = devnum;\n\t}\n\tmutex_unlock(&bus->usb_address0_mutex);\n}\n\nstatic void release_devnum(struct usb_device *udev)\n{\n\tif (udev->devnum > 0) {\n\t\tclear_bit(udev->devnum, udev->bus->devmap.devicemap);\n\t\tudev->devnum = -1;\n\t}\n}\n\nstatic void update_devnum(struct usb_device *udev, int devnum)\n{\n\t/* The address for a WUSB device is managed by wusbcore. */\n\tif (!udev->wusb)\n\t\tudev->devnum = devnum;\n}\n\nstatic void hub_free_dev(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\t/* Root hubs aren't real devices, so don't free HCD resources */\n\tif (hcd->driver->free_dev && udev->parent)\n\t\thcd->driver->free_dev(hcd, udev);\n}\n\nstatic void hub_disconnect_children(struct usb_device *udev)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(udev);\n\tint i;\n\n\t/* Free up all the children before we remove this device */\n\tfor (i = 0; i < udev->maxchild; i++) {\n\t\tif (hub->ports[i]->child)\n\t\t\tusb_disconnect(&hub->ports[i]->child);\n\t}\n}\n\n/**\n * usb_disconnect - disconnect a device (usbcore-internal)\n * @pdev: pointer to device being disconnected\n * Context: !in_interrupt ()\n *\n * Something got disconnected. Get rid of it and all of its children.\n *\n * If *pdev is a normal device then the parent hub must already be locked.\n * If *pdev is a root hub then the caller must hold the usb_bus_list_lock,\n * which protects the set of root hubs as well as the list of buses.\n *\n * Only hub drivers (including virtual root hub drivers for host\n * controllers) should ever call this.\n *\n * This call is synchronous, and may not be used in an interrupt context.\n */\nvoid usb_disconnect(struct usb_device **pdev)\n{\n\tstruct usb_port *port_dev = NULL;\n\tstruct usb_device *udev = *pdev;\n\tstruct usb_hub *hub = NULL;\n\tint port1 = 1;\n\n\t/* mark the device as inactive, so any further urb submissions for\n\t * this device (and any of its children) will fail immediately.\n\t * this quiesces everything except pending urbs.\n\t */\n\tusb_set_device_state(udev, USB_STATE_NOTATTACHED);\n\tdev_info(&udev->dev, \"USB disconnect, device number %d\\n\",\n\t\t\tudev->devnum);\n\n\tusb_lock_device(udev);\n\n\thub_disconnect_children(udev);\n\n\t/* deallocate hcd/hardware state ... nuking all pending urbs and\n\t * cleaning up all state associated with the current configuration\n\t * so that the hardware is now fully quiesced.\n\t */\n\tdev_dbg(&udev->dev, \"unregistering device\\n\");\n\tusb_disable_device(udev, 0);\n\tusb_hcd_synchronize_unlinks(udev);\n\n\tif (udev->parent) {\n\t\tport1 = udev->portnum;\n\t\thub = usb_hub_to_struct_hub(udev->parent);\n\t\tport_dev = hub->ports[port1 - 1];\n\n\t\tsysfs_remove_link(&udev->dev.kobj, \"port\");\n\t\tsysfs_remove_link(&port_dev->dev.kobj, \"device\");\n\n\t\t/*\n\t\t * As usb_port_runtime_resume() de-references udev, make\n\t\t * sure no resumes occur during removal\n\t\t */\n\t\tif (!test_and_set_bit(port1, hub->child_usage_bits))\n\t\t\tpm_runtime_get_sync(&port_dev->dev);\n\t}\n\n\tusb_remove_ep_devs(&udev->ep0);\n\tusb_unlock_device(udev);\n\n\t/* Unregister the device.  The device driver is responsible\n\t * for de-configuring the device and invoking the remove-device\n\t * notifier chain (used by usbfs and possibly others).\n\t */\n\tdevice_del(&udev->dev);\n\n\t/* Free the device number and delete the parent's children[]\n\t * (or root_hub) pointer.\n\t */\n\trelease_devnum(udev);\n\n\t/* Avoid races with recursively_mark_NOTATTACHED() */\n\tspin_lock_irq(&device_state_lock);\n\t*pdev = NULL;\n\tspin_unlock_irq(&device_state_lock);\n\n\tif (port_dev && test_and_clear_bit(port1, hub->child_usage_bits))\n\t\tpm_runtime_put(&port_dev->dev);\n\n\thub_free_dev(udev);\n\n\tput_device(&udev->dev);\n}\n\n#ifdef CONFIG_USB_ANNOUNCE_NEW_DEVICES\nstatic void show_string(struct usb_device *udev, char *id, char *string)\n{\n\tif (!string)\n\t\treturn;\n\tdev_info(&udev->dev, \"%s: %s\\n\", id, string);\n}\n\nstatic void announce_device(struct usb_device *udev)\n{\n\tdev_info(&udev->dev, \"New USB device found, idVendor=%04x, idProduct=%04x\\n\",\n\t\tle16_to_cpu(udev->descriptor.idVendor),\n\t\tle16_to_cpu(udev->descriptor.idProduct));\n\tdev_info(&udev->dev,\n\t\t\"New USB device strings: Mfr=%d, Product=%d, SerialNumber=%d\\n\",\n\t\tudev->descriptor.iManufacturer,\n\t\tudev->descriptor.iProduct,\n\t\tudev->descriptor.iSerialNumber);\n\tshow_string(udev, \"Product\", udev->product);\n\tshow_string(udev, \"Manufacturer\", udev->manufacturer);\n\tshow_string(udev, \"SerialNumber\", udev->serial);\n}\n#else\nstatic inline void announce_device(struct usb_device *udev) { }\n#endif\n\n\n/**\n * usb_enumerate_device_otg - FIXME (usbcore-internal)\n * @udev: newly addressed device (in ADDRESS state)\n *\n * Finish enumeration for On-The-Go devices\n *\n * Return: 0 if successful. A negative error code otherwise.\n */\nstatic int usb_enumerate_device_otg(struct usb_device *udev)\n{\n\tint err = 0;\n\n#ifdef\tCONFIG_USB_OTG\n\t/*\n\t * OTG-aware devices on OTG-capable root hubs may be able to use SRP,\n\t * to wake us after we've powered off VBUS; and HNP, switching roles\n\t * \"host\" to \"peripheral\".  The OTG descriptor helps figure this out.\n\t */\n\tif (!udev->bus->is_b_host\n\t\t\t&& udev->config\n\t\t\t&& udev->parent == udev->bus->root_hub) {\n\t\tstruct usb_otg_descriptor\t*desc = NULL;\n\t\tstruct usb_bus\t\t\t*bus = udev->bus;\n\t\tunsigned\t\t\tport1 = udev->portnum;\n\n\t\t/* descriptor may appear anywhere in config */\n\t\terr = __usb_get_extra_descriptor(udev->rawdescriptors[0],\n\t\t\t\tle16_to_cpu(udev->config[0].desc.wTotalLength),\n\t\t\t\tUSB_DT_OTG, (void **) &desc);\n\t\tif (err || !(desc->bmAttributes & USB_OTG_HNP))\n\t\t\treturn 0;\n\n\t\tdev_info(&udev->dev, \"Dual-Role OTG device on %sHNP port\\n\",\n\t\t\t\t\t(port1 == bus->otg_port) ? \"\" : \"non-\");\n\n\t\t/* enable HNP before suspend, it's simpler */\n\t\tif (port1 == bus->otg_port) {\n\t\t\tbus->b_hnp_enable = 1;\n\t\t\terr = usb_control_msg(udev,\n\t\t\t\tusb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, 0,\n\t\t\t\tUSB_DEVICE_B_HNP_ENABLE,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t\tif (err < 0) {\n\t\t\t\t/*\n\t\t\t\t * OTG MESSAGE: report errors here,\n\t\t\t\t * customize to match your product.\n\t\t\t\t */\n\t\t\t\tdev_err(&udev->dev, \"can't set HNP mode: %d\\n\",\n\t\t\t\t\t\t\t\t\terr);\n\t\t\t\tbus->b_hnp_enable = 0;\n\t\t\t}\n\t\t} else if (desc->bLength == sizeof\n\t\t\t\t(struct usb_otg_descriptor)) {\n\t\t\t/* Set a_alt_hnp_support for legacy otg device */\n\t\t\terr = usb_control_msg(udev,\n\t\t\t\tusb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, 0,\n\t\t\t\tUSB_DEVICE_A_ALT_HNP_SUPPORT,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t\tif (err < 0)\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"set a_alt_hnp_support failed: %d\\n\",\n\t\t\t\t\terr);\n\t\t}\n\t}\n#endif\n\treturn err;\n}\n\n\n/**\n * usb_enumerate_device - Read device configs/intfs/otg (usbcore-internal)\n * @udev: newly addressed device (in ADDRESS state)\n *\n * This is only called by usb_new_device() and usb_authorize_device()\n * and FIXME -- all comments that apply to them apply here wrt to\n * environment.\n *\n * If the device is WUSB and not authorized, we don't attempt to read\n * the string descriptors, as they will be errored out by the device\n * until it has been authorized.\n *\n * Return: 0 if successful. A negative error code otherwise.\n */\nstatic int usb_enumerate_device(struct usb_device *udev)\n{\n\tint err;\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\tif (udev->config == NULL) {\n\t\terr = usb_get_configuration(udev);\n\t\tif (err < 0) {\n\t\t\tif (err != -ENODEV)\n\t\t\t\tdev_err(&udev->dev, \"can't read configurations, error %d\\n\",\n\t\t\t\t\t\terr);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t/* read the standard strings and cache them if present */\n\tudev->product = usb_cache_string(udev, udev->descriptor.iProduct);\n\tudev->manufacturer = usb_cache_string(udev,\n\t\t\t\t\t      udev->descriptor.iManufacturer);\n\tudev->serial = usb_cache_string(udev, udev->descriptor.iSerialNumber);\n\n\terr = usb_enumerate_device_otg(udev);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (IS_ENABLED(CONFIG_USB_OTG_WHITELIST) && hcd->tpl_support &&\n\t\t!is_targeted(udev)) {\n\t\t/* Maybe it can talk to us, though we can't talk to it.\n\t\t * (Includes HNP test device.)\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_USB_OTG) && (udev->bus->b_hnp_enable\n\t\t\t|| udev->bus->is_b_host)) {\n\t\t\terr = usb_port_suspend(udev, PMSG_AUTO_SUSPEND);\n\t\t\tif (err < 0)\n\t\t\t\tdev_dbg(&udev->dev, \"HNP fail, %d\\n\", err);\n\t\t}\n\t\treturn -ENOTSUPP;\n\t}\n\n\tusb_detect_interface_quirks(udev);\n\n\treturn 0;\n}\n\nstatic void set_usb_port_removable(struct usb_device *udev)\n{\n\tstruct usb_device *hdev = udev->parent;\n\tstruct usb_hub *hub;\n\tu8 port = udev->portnum;\n\tu16 wHubCharacteristics;\n\tbool removable = true;\n\n\tif (!hdev)\n\t\treturn;\n\n\thub = usb_hub_to_struct_hub(udev->parent);\n\n\t/*\n\t * If the platform firmware has provided information about a port,\n\t * use that to determine whether it's removable.\n\t */\n\tswitch (hub->ports[udev->portnum - 1]->connect_type) {\n\tcase USB_PORT_CONNECT_TYPE_HOT_PLUG:\n\t\tudev->removable = USB_DEVICE_REMOVABLE;\n\t\treturn;\n\tcase USB_PORT_CONNECT_TYPE_HARD_WIRED:\n\tcase USB_PORT_NOT_USED:\n\t\tudev->removable = USB_DEVICE_FIXED;\n\t\treturn;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/*\n\t * Otherwise, check whether the hub knows whether a port is removable\n\t * or not\n\t */\n\twHubCharacteristics = le16_to_cpu(hub->descriptor->wHubCharacteristics);\n\n\tif (!(wHubCharacteristics & HUB_CHAR_COMPOUND))\n\t\treturn;\n\n\tif (hub_is_superspeed(hdev)) {\n\t\tif (le16_to_cpu(hub->descriptor->u.ss.DeviceRemovable)\n\t\t\t\t& (1 << port))\n\t\t\tremovable = false;\n\t} else {\n\t\tif (hub->descriptor->u.hs.DeviceRemovable[port / 8] & (1 << (port % 8)))\n\t\t\tremovable = false;\n\t}\n\n\tif (removable)\n\t\tudev->removable = USB_DEVICE_REMOVABLE;\n\telse\n\t\tudev->removable = USB_DEVICE_FIXED;\n\n}\n\n/**\n * usb_new_device - perform initial device setup (usbcore-internal)\n * @udev: newly addressed device (in ADDRESS state)\n *\n * This is called with devices which have been detected but not fully\n * enumerated.  The device descriptor is available, but not descriptors\n * for any device configuration.  The caller must have locked either\n * the parent hub (if udev is a normal device) or else the\n * usb_bus_list_lock (if udev is a root hub).  The parent's pointer to\n * udev has already been installed, but udev is not yet visible through\n * sysfs or other filesystem code.\n *\n * This call is synchronous, and may not be used in an interrupt context.\n *\n * Only the hub driver or root-hub registrar should ever call this.\n *\n * Return: Whether the device is configured properly or not. Zero if the\n * interface was registered with the driver core; else a negative errno\n * value.\n *\n */\nint usb_new_device(struct usb_device *udev)\n{\n\tint err;\n\n\tif (udev->parent) {\n\t\t/* Initialize non-root-hub device wakeup to disabled;\n\t\t * device (un)configuration controls wakeup capable\n\t\t * sysfs power/wakeup controls wakeup enabled/disabled\n\t\t */\n\t\tdevice_init_wakeup(&udev->dev, 0);\n\t}\n\n\t/* Tell the runtime-PM framework the device is active */\n\tpm_runtime_set_active(&udev->dev);\n\tpm_runtime_get_noresume(&udev->dev);\n\tpm_runtime_use_autosuspend(&udev->dev);\n\tpm_runtime_enable(&udev->dev);\n\n\t/* By default, forbid autosuspend for all devices.  It will be\n\t * allowed for hubs during binding.\n\t */\n\tusb_disable_autosuspend(udev);\n\n\terr = usb_enumerate_device(udev);\t/* Read descriptors */\n\tif (err < 0)\n\t\tgoto fail;\n\tdev_dbg(&udev->dev, \"udev %d, busnum %d, minor = %d\\n\",\n\t\t\tudev->devnum, udev->bus->busnum,\n\t\t\t(((udev->bus->busnum-1) * 128) + (udev->devnum-1)));\n\t/* export the usbdev device-node for libusb */\n\tudev->dev.devt = MKDEV(USB_DEVICE_MAJOR,\n\t\t\t(((udev->bus->busnum-1) * 128) + (udev->devnum-1)));\n\n\t/* Tell the world! */\n\tannounce_device(udev);\n\n\tif (udev->serial)\n\t\tadd_device_randomness(udev->serial, strlen(udev->serial));\n\tif (udev->product)\n\t\tadd_device_randomness(udev->product, strlen(udev->product));\n\tif (udev->manufacturer)\n\t\tadd_device_randomness(udev->manufacturer,\n\t\t\t\t      strlen(udev->manufacturer));\n\n\tdevice_enable_async_suspend(&udev->dev);\n\n\t/* check whether the hub or firmware marks this port as non-removable */\n\tif (udev->parent)\n\t\tset_usb_port_removable(udev);\n\n\t/* Register the device.  The device driver is responsible\n\t * for configuring the device and invoking the add-device\n\t * notifier chain (used by usbfs and possibly others).\n\t */\n\terr = device_add(&udev->dev);\n\tif (err) {\n\t\tdev_err(&udev->dev, \"can't device_add, error %d\\n\", err);\n\t\tgoto fail;\n\t}\n\n\t/* Create link files between child device and usb port device. */\n\tif (udev->parent) {\n\t\tstruct usb_hub *hub = usb_hub_to_struct_hub(udev->parent);\n\t\tint port1 = udev->portnum;\n\t\tstruct usb_port\t*port_dev = hub->ports[port1 - 1];\n\n\t\terr = sysfs_create_link(&udev->dev.kobj,\n\t\t\t\t&port_dev->dev.kobj, \"port\");\n\t\tif (err)\n\t\t\tgoto fail;\n\n\t\terr = sysfs_create_link(&port_dev->dev.kobj,\n\t\t\t\t&udev->dev.kobj, \"device\");\n\t\tif (err) {\n\t\t\tsysfs_remove_link(&udev->dev.kobj, \"port\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (!test_and_set_bit(port1, hub->child_usage_bits))\n\t\t\tpm_runtime_get_sync(&port_dev->dev);\n\t}\n\n\t(void) usb_create_ep_devs(&udev->dev, &udev->ep0, udev);\n\tusb_mark_last_busy(udev);\n\tpm_runtime_put_sync_autosuspend(&udev->dev);\n\treturn err;\n\nfail:\n\tusb_set_device_state(udev, USB_STATE_NOTATTACHED);\n\tpm_runtime_disable(&udev->dev);\n\tpm_runtime_set_suspended(&udev->dev);\n\treturn err;\n}\n\n\n/**\n * usb_deauthorize_device - deauthorize a device (usbcore-internal)\n * @usb_dev: USB device\n *\n * Move the USB device to a very basic state where interfaces are disabled\n * and the device is in fact unconfigured and unusable.\n *\n * We share a lock (that we have) with device_del(), so we need to\n * defer its call.\n *\n * Return: 0.\n */\nint usb_deauthorize_device(struct usb_device *usb_dev)\n{\n\tusb_lock_device(usb_dev);\n\tif (usb_dev->authorized == 0)\n\t\tgoto out_unauthorized;\n\n\tusb_dev->authorized = 0;\n\tusb_set_configuration(usb_dev, -1);\n\nout_unauthorized:\n\tusb_unlock_device(usb_dev);\n\treturn 0;\n}\n\n\nint usb_authorize_device(struct usb_device *usb_dev)\n{\n\tint result = 0, c;\n\n\tusb_lock_device(usb_dev);\n\tif (usb_dev->authorized == 1)\n\t\tgoto out_authorized;\n\n\tresult = usb_autoresume_device(usb_dev);\n\tif (result < 0) {\n\t\tdev_err(&usb_dev->dev,\n\t\t\t\"can't autoresume for authorization: %d\\n\", result);\n\t\tgoto error_autoresume;\n\t}\n\n\tif (usb_dev->wusb) {\n\t\tresult = usb_get_device_descriptor(usb_dev, sizeof(usb_dev->descriptor));\n\t\tif (result < 0) {\n\t\t\tdev_err(&usb_dev->dev, \"can't re-read device descriptor for \"\n\t\t\t\t\"authorization: %d\\n\", result);\n\t\t\tgoto error_device_descriptor;\n\t\t}\n\t}\n\n\tusb_dev->authorized = 1;\n\t/* Choose and set the configuration.  This registers the interfaces\n\t * with the driver core and lets interface drivers bind to them.\n\t */\n\tc = usb_choose_configuration(usb_dev);\n\tif (c >= 0) {\n\t\tresult = usb_set_configuration(usb_dev, c);\n\t\tif (result) {\n\t\t\tdev_err(&usb_dev->dev,\n\t\t\t\t\"can't set config #%d, error %d\\n\", c, result);\n\t\t\t/* This need not be fatal.  The user can try to\n\t\t\t * set other configurations. */\n\t\t}\n\t}\n\tdev_info(&usb_dev->dev, \"authorized to connect\\n\");\n\nerror_device_descriptor:\n\tusb_autosuspend_device(usb_dev);\nerror_autoresume:\nout_authorized:\n\tusb_unlock_device(usb_dev);\t/* complements locktree */\n\treturn result;\n}\n\n\n/* Returns 1 if @hub is a WUSB root hub, 0 otherwise */\nstatic unsigned hub_is_wusb(struct usb_hub *hub)\n{\n\tstruct usb_hcd *hcd;\n\tif (hub->hdev->parent != NULL)  /* not a root hub? */\n\t\treturn 0;\n\thcd = container_of(hub->hdev->bus, struct usb_hcd, self);\n\treturn hcd->wireless;\n}\n\n\n#define PORT_RESET_TRIES\t5\n#define SET_ADDRESS_TRIES\t2\n#define GET_DESCRIPTOR_TRIES\t2\n#define SET_CONFIG_TRIES\t(2 * (use_both_schemes + 1))\n#define USE_NEW_SCHEME(i)\t((i) / 2 == (int)old_scheme_first)\n\n#define HUB_ROOT_RESET_TIME\t50\t/* times are in msec */\n#define HUB_SHORT_RESET_TIME\t10\n#define HUB_BH_RESET_TIME\t50\n#define HUB_LONG_RESET_TIME\t200\n#define HUB_RESET_TIMEOUT\t800\n\n/*\n * \"New scheme\" enumeration causes an extra state transition to be\n * exposed to an xhci host and causes USB3 devices to receive control\n * commands in the default state.  This has been seen to cause\n * enumeration failures, so disable this enumeration scheme for USB3\n * devices.\n */\nstatic bool use_new_scheme(struct usb_device *udev, int retry)\n{\n\tif (udev->speed == USB_SPEED_SUPER)\n\t\treturn false;\n\n\treturn USE_NEW_SCHEME(retry);\n}\n\n/* Is a USB 3.0 port in the Inactive or Compliance Mode state?\n * Port worm reset is required to recover\n */\nstatic bool hub_port_warm_reset_required(struct usb_hub *hub, int port1,\n\t\tu16 portstatus)\n{\n\tu16 link_state;\n\n\tif (!hub_is_superspeed(hub->hdev))\n\t\treturn false;\n\n\tif (test_bit(port1, hub->warm_reset_bits))\n\t\treturn true;\n\n\tlink_state = portstatus & USB_PORT_STAT_LINK_STATE;\n\treturn link_state == USB_SS_PORT_LS_SS_INACTIVE\n\t\t|| link_state == USB_SS_PORT_LS_COMP_MOD;\n}\n\nstatic int hub_port_wait_reset(struct usb_hub *hub, int port1,\n\t\t\tstruct usb_device *udev, unsigned int delay, bool warm)\n{\n\tint delay_time, ret;\n\tu16 portstatus;\n\tu16 portchange;\n\n\tfor (delay_time = 0;\n\t\t\tdelay_time < HUB_RESET_TIMEOUT;\n\t\t\tdelay_time += delay) {\n\t\t/* wait to give the device a chance to reset */\n\t\tmsleep(delay);\n\n\t\t/* read and decode port status */\n\t\tret = hub_port_status(hub, port1, &portstatus, &portchange);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t/* The port state is unknown until the reset completes. */\n\t\tif (!(portstatus & USB_PORT_STAT_RESET))\n\t\t\tbreak;\n\n\t\t/* switch to the long delay after two short delay failures */\n\t\tif (delay_time >= 2 * HUB_SHORT_RESET_TIME)\n\t\t\tdelay = HUB_LONG_RESET_TIME;\n\n\t\tdev_dbg(&hub->ports[port1 - 1]->dev,\n\t\t\t\t\"not %sreset yet, waiting %dms\\n\",\n\t\t\t\twarm ? \"warm \" : \"\", delay);\n\t}\n\n\tif ((portstatus & USB_PORT_STAT_RESET))\n\t\treturn -EBUSY;\n\n\tif (hub_port_warm_reset_required(hub, port1, portstatus))\n\t\treturn -ENOTCONN;\n\n\t/* Device went away? */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION))\n\t\treturn -ENOTCONN;\n\n\t/* bomb out completely if the connection bounced.  A USB 3.0\n\t * connection may bounce if multiple warm resets were issued,\n\t * but the device may have successfully re-connected. Ignore it.\n\t */\n\tif (!hub_is_superspeed(hub->hdev) &&\n\t\t\t(portchange & USB_PORT_STAT_C_CONNECTION))\n\t\treturn -ENOTCONN;\n\n\tif (!(portstatus & USB_PORT_STAT_ENABLE))\n\t\treturn -EBUSY;\n\n\tif (!udev)\n\t\treturn 0;\n\n\tif (hub_is_wusb(hub))\n\t\tudev->speed = USB_SPEED_WIRELESS;\n\telse if (hub_is_superspeed(hub->hdev))\n\t\tudev->speed = USB_SPEED_SUPER;\n\telse if (portstatus & USB_PORT_STAT_HIGH_SPEED)\n\t\tudev->speed = USB_SPEED_HIGH;\n\telse if (portstatus & USB_PORT_STAT_LOW_SPEED)\n\t\tudev->speed = USB_SPEED_LOW;\n\telse\n\t\tudev->speed = USB_SPEED_FULL;\n\treturn 0;\n}\n\n/* Handle port reset and port warm(BH) reset (for USB3 protocol ports) */\nstatic int hub_port_reset(struct usb_hub *hub, int port1,\n\t\t\tstruct usb_device *udev, unsigned int delay, bool warm)\n{\n\tint i, status;\n\tu16 portchange, portstatus;\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\n\tif (!hub_is_superspeed(hub->hdev)) {\n\t\tif (warm) {\n\t\t\tdev_err(hub->intfdev, \"only USB3 hub support \"\n\t\t\t\t\t\t\"warm reset\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/* Block EHCI CF initialization during the port reset.\n\t\t * Some companion controllers don't like it when they mix.\n\t\t */\n\t\tdown_read(&ehci_cf_port_reset_rwsem);\n\t} else if (!warm) {\n\t\t/*\n\t\t * If the caller hasn't explicitly requested a warm reset,\n\t\t * double check and see if one is needed.\n\t\t */\n\t\tif (hub_port_status(hub, port1, &portstatus, &portchange) == 0)\n\t\t\tif (hub_port_warm_reset_required(hub, port1,\n\t\t\t\t\t\t\tportstatus))\n\t\t\t\twarm = true;\n\t}\n\tclear_bit(port1, hub->warm_reset_bits);\n\n\t/* Reset the port */\n\tfor (i = 0; i < PORT_RESET_TRIES; i++) {\n\t\tstatus = set_port_feature(hub->hdev, port1, (warm ?\n\t\t\t\t\tUSB_PORT_FEAT_BH_PORT_RESET :\n\t\t\t\t\tUSB_PORT_FEAT_RESET));\n\t\tif (status == -ENODEV) {\n\t\t\t;\t/* The hub is gone */\n\t\t} else if (status) {\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"cannot %sreset (err = %d)\\n\",\n\t\t\t\t\twarm ? \"warm \" : \"\", status);\n\t\t} else {\n\t\t\tstatus = hub_port_wait_reset(hub, port1, udev, delay,\n\t\t\t\t\t\t\t\twarm);\n\t\t\tif (status && status != -ENOTCONN && status != -ENODEV)\n\t\t\t\tdev_dbg(hub->intfdev,\n\t\t\t\t\t\t\"port_wait_reset: err = %d\\n\",\n\t\t\t\t\t\tstatus);\n\t\t}\n\n\t\t/* Check for disconnect or reset */\n\t\tif (status == 0 || status == -ENOTCONN || status == -ENODEV) {\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_RESET);\n\n\t\t\tif (!hub_is_superspeed(hub->hdev))\n\t\t\t\tgoto done;\n\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_BH_PORT_RESET);\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_PORT_LINK_STATE);\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_CONNECTION);\n\n\t\t\t/*\n\t\t\t * If a USB 3.0 device migrates from reset to an error\n\t\t\t * state, re-issue the warm reset.\n\t\t\t */\n\t\t\tif (hub_port_status(hub, port1,\n\t\t\t\t\t&portstatus, &portchange) < 0)\n\t\t\t\tgoto done;\n\n\t\t\tif (!hub_port_warm_reset_required(hub, port1,\n\t\t\t\t\tportstatus))\n\t\t\t\tgoto done;\n\n\t\t\t/*\n\t\t\t * If the port is in SS.Inactive or Compliance Mode, the\n\t\t\t * hot or warm reset failed.  Try another warm reset.\n\t\t\t */\n\t\t\tif (!warm) {\n\t\t\t\tdev_dbg(&port_dev->dev,\n\t\t\t\t\t\t\"hot reset failed, warm reset\\n\");\n\t\t\t\twarm = true;\n\t\t\t}\n\t\t}\n\n\t\tdev_dbg(&port_dev->dev,\n\t\t\t\t\"not enabled, trying %sreset again...\\n\",\n\t\t\t\twarm ? \"warm \" : \"\");\n\t\tdelay = HUB_LONG_RESET_TIME;\n\t}\n\n\tdev_err(&port_dev->dev, \"Cannot enable. Maybe the USB cable is bad?\\n\");\n\ndone:\n\tif (status == 0) {\n\t\t/* TRSTRCY = 10 ms; plus some extra */\n\t\tmsleep(10 + 40);\n\t\tif (udev) {\n\t\t\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\t\t\tupdate_devnum(udev, 0);\n\t\t\t/* The xHC may think the device is already reset,\n\t\t\t * so ignore the status.\n\t\t\t */\n\t\t\tif (hcd->driver->reset_device)\n\t\t\t\thcd->driver->reset_device(hcd, udev);\n\n\t\t\tusb_set_device_state(udev, USB_STATE_DEFAULT);\n\t\t}\n\t} else {\n\t\tif (udev)\n\t\t\tusb_set_device_state(udev, USB_STATE_NOTATTACHED);\n\t}\n\n\tif (!hub_is_superspeed(hub->hdev))\n\t\tup_read(&ehci_cf_port_reset_rwsem);\n\n\treturn status;\n}\n\n/* Check if a port is power on */\nstatic int port_is_power_on(struct usb_hub *hub, unsigned portstatus)\n{\n\tint ret = 0;\n\n\tif (hub_is_superspeed(hub->hdev)) {\n\t\tif (portstatus & USB_SS_PORT_STAT_POWER)\n\t\t\tret = 1;\n\t} else {\n\t\tif (portstatus & USB_PORT_STAT_POWER)\n\t\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n\nstatic void usb_lock_port(struct usb_port *port_dev)\n\t\t__acquires(&port_dev->status_lock)\n{\n\tmutex_lock(&port_dev->status_lock);\n\t__acquire(&port_dev->status_lock);\n}\n\nstatic void usb_unlock_port(struct usb_port *port_dev)\n\t\t__releases(&port_dev->status_lock)\n{\n\tmutex_unlock(&port_dev->status_lock);\n\t__release(&port_dev->status_lock);\n}\n\n#ifdef\tCONFIG_PM\n\n/* Check if a port is suspended(USB2.0 port) or in U3 state(USB3.0 port) */\nstatic int port_is_suspended(struct usb_hub *hub, unsigned portstatus)\n{\n\tint ret = 0;\n\n\tif (hub_is_superspeed(hub->hdev)) {\n\t\tif ((portstatus & USB_PORT_STAT_LINK_STATE)\n\t\t\t\t== USB_SS_PORT_LS_U3)\n\t\t\tret = 1;\n\t} else {\n\t\tif (portstatus & USB_PORT_STAT_SUSPEND)\n\t\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n\n/* Determine whether the device on a port is ready for a normal resume,\n * is ready for a reset-resume, or should be disconnected.\n */\nstatic int check_port_resume_type(struct usb_device *udev,\n\t\tstruct usb_hub *hub, int port1,\n\t\tint status, u16 portchange, u16 portstatus)\n{\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tint retries = 3;\n\n retry:\n\t/* Is a warm reset needed to recover the connection? */\n\tif (status == 0 && udev->reset_resume\n\t\t&& hub_port_warm_reset_required(hub, port1, portstatus)) {\n\t\t/* pass */;\n\t}\n\t/* Is the device still present? */\n\telse if (status || port_is_suspended(hub, portstatus) ||\n\t\t\t!port_is_power_on(hub, portstatus)) {\n\t\tif (status >= 0)\n\t\t\tstatus = -ENODEV;\n\t} else if (!(portstatus & USB_PORT_STAT_CONNECTION)) {\n\t\tif (retries--) {\n\t\t\tusleep_range(200, 300);\n\t\t\tstatus = hub_port_status(hub, port1, &portstatus,\n\t\t\t\t\t\t\t     &portchange);\n\t\t\tgoto retry;\n\t\t}\n\t\tstatus = -ENODEV;\n\t}\n\n\t/* Can't do a normal resume if the port isn't enabled,\n\t * so try a reset-resume instead.\n\t */\n\telse if (!(portstatus & USB_PORT_STAT_ENABLE) && !udev->reset_resume) {\n\t\tif (udev->persist_enabled)\n\t\t\tudev->reset_resume = 1;\n\t\telse\n\t\t\tstatus = -ENODEV;\n\t}\n\n\tif (status) {\n\t\tdev_dbg(&port_dev->dev, \"status %04x.%04x after resume, %d\\n\",\n\t\t\t\tportchange, portstatus, status);\n\t} else if (udev->reset_resume) {\n\n\t\t/* Late port handoff can set status-change bits */\n\t\tif (portchange & USB_PORT_STAT_C_CONNECTION)\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_CONNECTION);\n\t\tif (portchange & USB_PORT_STAT_C_ENABLE)\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_ENABLE);\n\t}\n\n\treturn status;\n}\n\nint usb_disable_ltm(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\t/* Check if the roothub and device supports LTM. */\n\tif (!usb_device_supports_ltm(hcd->self.root_hub) ||\n\t\t\t!usb_device_supports_ltm(udev))\n\t\treturn 0;\n\n\t/* Clear Feature LTM Enable can only be sent if the device is\n\t * configured.\n\t */\n\tif (!udev->actconfig)\n\t\treturn 0;\n\n\treturn usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_CLEAR_FEATURE, USB_RECIP_DEVICE,\n\t\t\tUSB_DEVICE_LTM_ENABLE, 0, NULL, 0,\n\t\t\tUSB_CTRL_SET_TIMEOUT);\n}\nEXPORT_SYMBOL_GPL(usb_disable_ltm);\n\nvoid usb_enable_ltm(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\t/* Check if the roothub and device supports LTM. */\n\tif (!usb_device_supports_ltm(hcd->self.root_hub) ||\n\t\t\t!usb_device_supports_ltm(udev))\n\t\treturn;\n\n\t/* Set Feature LTM Enable can only be sent if the device is\n\t * configured.\n\t */\n\tif (!udev->actconfig)\n\t\treturn;\n\n\tusb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_FEATURE, USB_RECIP_DEVICE,\n\t\t\tUSB_DEVICE_LTM_ENABLE, 0, NULL, 0,\n\t\t\tUSB_CTRL_SET_TIMEOUT);\n}\nEXPORT_SYMBOL_GPL(usb_enable_ltm);\n\n/*\n * usb_enable_remote_wakeup - enable remote wakeup for a device\n * @udev: target device\n *\n * For USB-2 devices: Set the device's remote wakeup feature.\n *\n * For USB-3 devices: Assume there's only one function on the device and\n * enable remote wake for the first interface.  FIXME if the interface\n * association descriptor shows there's more than one function.\n */\nstatic int usb_enable_remote_wakeup(struct usb_device *udev)\n{\n\tif (udev->speed < USB_SPEED_SUPER)\n\t\treturn usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, USB_RECIP_DEVICE,\n\t\t\t\tUSB_DEVICE_REMOTE_WAKEUP, 0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\telse\n\t\treturn usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, USB_RECIP_INTERFACE,\n\t\t\t\tUSB_INTRF_FUNC_SUSPEND,\n\t\t\t\tUSB_INTRF_FUNC_SUSPEND_RW |\n\t\t\t\t\tUSB_INTRF_FUNC_SUSPEND_LP,\n\t\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n}\n\n/*\n * usb_disable_remote_wakeup - disable remote wakeup for a device\n * @udev: target device\n *\n * For USB-2 devices: Clear the device's remote wakeup feature.\n *\n * For USB-3 devices: Assume there's only one function on the device and\n * disable remote wake for the first interface.  FIXME if the interface\n * association descriptor shows there's more than one function.\n */\nstatic int usb_disable_remote_wakeup(struct usb_device *udev)\n{\n\tif (udev->speed < USB_SPEED_SUPER)\n\t\treturn usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_CLEAR_FEATURE, USB_RECIP_DEVICE,\n\t\t\t\tUSB_DEVICE_REMOTE_WAKEUP, 0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\telse\n\t\treturn usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_CLEAR_FEATURE, USB_RECIP_INTERFACE,\n\t\t\t\tUSB_INTRF_FUNC_SUSPEND,\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n}\n\n/* Count of wakeup-enabled devices at or below udev */\nstatic unsigned wakeup_enabled_descendants(struct usb_device *udev)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(udev);\n\n\treturn udev->do_remote_wakeup +\n\t\t\t(hub ? hub->wakeup_enabled_descendants : 0);\n}\n\n/*\n * usb_port_suspend - suspend a usb device's upstream port\n * @udev: device that's no longer in active use, not a root hub\n * Context: must be able to sleep; device not locked; pm locks held\n *\n * Suspends a USB device that isn't in active use, conserving power.\n * Devices may wake out of a suspend, if anything important happens,\n * using the remote wakeup mechanism.  They may also be taken out of\n * suspend by the host, using usb_port_resume().  It's also routine\n * to disconnect devices while they are suspended.\n *\n * This only affects the USB hardware for a device; its interfaces\n * (and, for hubs, child devices) must already have been suspended.\n *\n * Selective port suspend reduces power; most suspended devices draw\n * less than 500 uA.  It's also used in OTG, along with remote wakeup.\n * All devices below the suspended port are also suspended.\n *\n * Devices leave suspend state when the host wakes them up.  Some devices\n * also support \"remote wakeup\", where the device can activate the USB\n * tree above them to deliver data, such as a keypress or packet.  In\n * some cases, this wakes the USB host.\n *\n * Suspending OTG devices may trigger HNP, if that's been enabled\n * between a pair of dual-role devices.  That will change roles, such\n * as from A-Host to A-Peripheral or from B-Host back to B-Peripheral.\n *\n * Devices on USB hub ports have only one \"suspend\" state, corresponding\n * to ACPI D2, \"may cause the device to lose some context\".\n * State transitions include:\n *\n *   - suspend, resume ... when the VBUS power link stays live\n *   - suspend, disconnect ... VBUS lost\n *\n * Once VBUS drop breaks the circuit, the port it's using has to go through\n * normal re-enumeration procedures, starting with enabling VBUS power.\n * Other than re-initializing the hub (plug/unplug, except for root hubs),\n * Linux (2.6) currently has NO mechanisms to initiate that:  no hub_wq\n * timer, no SRP, no requests through sysfs.\n *\n * If Runtime PM isn't enabled or used, non-SuperSpeed devices may not get\n * suspended until their bus goes into global suspend (i.e., the root\n * hub is suspended).  Nevertheless, we change @udev->state to\n * USB_STATE_SUSPENDED as this is the device's \"logical\" state.  The actual\n * upstream port setting is stored in @udev->port_is_suspended.\n *\n * Returns 0 on success, else negative errno.\n */\nint usb_port_suspend(struct usb_device *udev, pm_message_t msg)\n{\n\tstruct usb_hub\t*hub = usb_hub_to_struct_hub(udev->parent);\n\tstruct usb_port *port_dev = hub->ports[udev->portnum - 1];\n\tint\t\tport1 = udev->portnum;\n\tint\t\tstatus;\n\tbool\t\treally_suspend = true;\n\n\tusb_lock_port(port_dev);\n\n\t/* enable remote wakeup when appropriate; this lets the device\n\t * wake up the upstream hub (including maybe the root hub).\n\t *\n\t * NOTE:  OTG devices may issue remote wakeup (or SRP) even when\n\t * we don't explicitly enable it here.\n\t */\n\tif (udev->do_remote_wakeup) {\n\t\tstatus = usb_enable_remote_wakeup(udev);\n\t\tif (status) {\n\t\t\tdev_dbg(&udev->dev, \"won't remote wakeup, status %d\\n\",\n\t\t\t\t\tstatus);\n\t\t\t/* bail if autosuspend is requested */\n\t\t\tif (PMSG_IS_AUTO(msg))\n\t\t\t\tgoto err_wakeup;\n\t\t}\n\t}\n\n\t/* disable USB2 hardware LPM */\n\tif (udev->usb2_hw_lpm_enabled == 1)\n\t\tusb_set_usb2_hardware_lpm(udev, 0);\n\n\tif (usb_disable_ltm(udev)) {\n\t\tdev_err(&udev->dev, \"Failed to disable LTM before suspend\\n.\");\n\t\tstatus = -ENOMEM;\n\t\tif (PMSG_IS_AUTO(msg))\n\t\t\tgoto err_ltm;\n\t}\n\tif (usb_unlocked_disable_lpm(udev)) {\n\t\tdev_err(&udev->dev, \"Failed to disable LPM before suspend\\n.\");\n\t\tstatus = -ENOMEM;\n\t\tif (PMSG_IS_AUTO(msg))\n\t\t\tgoto err_lpm3;\n\t}\n\n\t/* see 7.1.7.6 */\n\tif (hub_is_superspeed(hub->hdev))\n\t\tstatus = hub_set_port_link_state(hub, port1, USB_SS_PORT_LS_U3);\n\n\t/*\n\t * For system suspend, we do not need to enable the suspend feature\n\t * on individual USB-2 ports.  The devices will automatically go\n\t * into suspend a few ms after the root hub stops sending packets.\n\t * The USB 2.0 spec calls this \"global suspend\".\n\t *\n\t * However, many USB hubs have a bug: They don't relay wakeup requests\n\t * from a downstream port if the port's suspend feature isn't on.\n\t * Therefore we will turn on the suspend feature if udev or any of its\n\t * descendants is enabled for remote wakeup.\n\t */\n\telse if (PMSG_IS_AUTO(msg) || wakeup_enabled_descendants(udev) > 0)\n\t\tstatus = set_port_feature(hub->hdev, port1,\n\t\t\t\tUSB_PORT_FEAT_SUSPEND);\n\telse {\n\t\treally_suspend = false;\n\t\tstatus = 0;\n\t}\n\tif (status) {\n\t\tdev_dbg(&port_dev->dev, \"can't suspend, status %d\\n\", status);\n\n\t\t/* Try to enable USB3 LPM and LTM again */\n\t\tusb_unlocked_enable_lpm(udev);\n err_lpm3:\n\t\tusb_enable_ltm(udev);\n err_ltm:\n\t\t/* Try to enable USB2 hardware LPM again */\n\t\tif (udev->usb2_hw_lpm_capable == 1)\n\t\t\tusb_set_usb2_hardware_lpm(udev, 1);\n\n\t\tif (udev->do_remote_wakeup)\n\t\t\t(void) usb_disable_remote_wakeup(udev);\n err_wakeup:\n\n\t\t/* System sleep transitions should never fail */\n\t\tif (!PMSG_IS_AUTO(msg))\n\t\t\tstatus = 0;\n\t} else {\n\t\tdev_dbg(&udev->dev, \"usb %ssuspend, wakeup %d\\n\",\n\t\t\t\t(PMSG_IS_AUTO(msg) ? \"auto-\" : \"\"),\n\t\t\t\tudev->do_remote_wakeup);\n\t\tif (really_suspend) {\n\t\t\tudev->port_is_suspended = 1;\n\n\t\t\t/* device has up to 10 msec to fully suspend */\n\t\t\tmsleep(10);\n\t\t}\n\t\tusb_set_device_state(udev, USB_STATE_SUSPENDED);\n\t}\n\n\tif (status == 0 && !udev->do_remote_wakeup && udev->persist_enabled\n\t\t\t&& test_and_clear_bit(port1, hub->child_usage_bits))\n\t\tpm_runtime_put_sync(&port_dev->dev);\n\n\tusb_mark_last_busy(hub->hdev);\n\n\tusb_unlock_port(port_dev);\n\treturn status;\n}\n\n/*\n * If the USB \"suspend\" state is in use (rather than \"global suspend\"),\n * many devices will be individually taken out of suspend state using\n * special \"resume\" signaling.  This routine kicks in shortly after\n * hardware resume signaling is finished, either because of selective\n * resume (by host) or remote wakeup (by device) ... now see what changed\n * in the tree that's rooted at this device.\n *\n * If @udev->reset_resume is set then the device is reset before the\n * status check is done.\n */\nstatic int finish_port_resume(struct usb_device *udev)\n{\n\tint\tstatus = 0;\n\tu16\tdevstatus = 0;\n\n\t/* caller owns the udev device lock */\n\tdev_dbg(&udev->dev, \"%s\\n\",\n\t\tudev->reset_resume ? \"finish reset-resume\" : \"finish resume\");\n\n\t/* usb ch9 identifies four variants of SUSPENDED, based on what\n\t * state the device resumes to.  Linux currently won't see the\n\t * first two on the host side; they'd be inside hub_port_init()\n\t * during many timeouts, but hub_wq can't suspend until later.\n\t */\n\tusb_set_device_state(udev, udev->actconfig\n\t\t\t? USB_STATE_CONFIGURED\n\t\t\t: USB_STATE_ADDRESS);\n\n\t/* 10.5.4.5 says not to reset a suspended port if the attached\n\t * device is enabled for remote wakeup.  Hence the reset\n\t * operation is carried out here, after the port has been\n\t * resumed.\n\t */\n\tif (udev->reset_resume) {\n\t\t/*\n\t\t * If the device morphs or switches modes when it is reset,\n\t\t * we don't want to perform a reset-resume.  We'll fail the\n\t\t * resume, which will cause a logical disconnect, and then\n\t\t * the device will be rediscovered.\n\t\t */\n retry_reset_resume:\n\t\tif (udev->quirks & USB_QUIRK_RESET)\n\t\t\tstatus = -ENODEV;\n\t\telse\n\t\t\tstatus = usb_reset_and_verify_device(udev);\n\t}\n\n\t/* 10.5.4.5 says be sure devices in the tree are still there.\n\t * For now let's assume the device didn't go crazy on resume,\n\t * and device drivers will know about any resume quirks.\n\t */\n\tif (status == 0) {\n\t\tdevstatus = 0;\n\t\tstatus = usb_get_status(udev, USB_RECIP_DEVICE, 0, &devstatus);\n\n\t\t/* If a normal resume failed, try doing a reset-resume */\n\t\tif (status && !udev->reset_resume && udev->persist_enabled) {\n\t\t\tdev_dbg(&udev->dev, \"retry with reset-resume\\n\");\n\t\t\tudev->reset_resume = 1;\n\t\t\tgoto retry_reset_resume;\n\t\t}\n\t}\n\n\tif (status) {\n\t\tdev_dbg(&udev->dev, \"gone after usb resume? status %d\\n\",\n\t\t\t\tstatus);\n\t/*\n\t * There are a few quirky devices which violate the standard\n\t * by claiming to have remote wakeup enabled after a reset,\n\t * which crash if the feature is cleared, hence check for\n\t * udev->reset_resume\n\t */\n\t} else if (udev->actconfig && !udev->reset_resume) {\n\t\tif (udev->speed < USB_SPEED_SUPER) {\n\t\t\tif (devstatus & (1 << USB_DEVICE_REMOTE_WAKEUP))\n\t\t\t\tstatus = usb_disable_remote_wakeup(udev);\n\t\t} else {\n\t\t\tstatus = usb_get_status(udev, USB_RECIP_INTERFACE, 0,\n\t\t\t\t\t&devstatus);\n\t\t\tif (!status && devstatus & (USB_INTRF_STAT_FUNC_RW_CAP\n\t\t\t\t\t| USB_INTRF_STAT_FUNC_RW))\n\t\t\t\tstatus = usb_disable_remote_wakeup(udev);\n\t\t}\n\n\t\tif (status)\n\t\t\tdev_dbg(&udev->dev,\n\t\t\t\t\"disable remote wakeup, status %d\\n\",\n\t\t\t\tstatus);\n\t\tstatus = 0;\n\t}\n\treturn status;\n}\n\n/*\n * There are some SS USB devices which take longer time for link training.\n * XHCI specs 4.19.4 says that when Link training is successful, port\n * sets CSC bit to 1. So if SW reads port status before successful link\n * training, then it will not find device to be present.\n * USB Analyzer log with such buggy devices show that in some cases\n * device switch on the RX termination after long delay of host enabling\n * the VBUS. In few other cases it has been seen that device fails to\n * negotiate link training in first attempt. It has been\n * reported till now that few devices take as long as 2000 ms to train\n * the link after host enabling its VBUS and termination. Following\n * routine implements a 2000 ms timeout for link training. If in a case\n * link trains before timeout, loop will exit earlier.\n *\n * FIXME: If a device was connected before suspend, but was removed\n * while system was asleep, then the loop in the following routine will\n * only exit at timeout.\n *\n * This routine should only be called when persist is enabled for a SS\n * device.\n */\nstatic int wait_for_ss_port_enable(struct usb_device *udev,\n\t\tstruct usb_hub *hub, int *port1,\n\t\tu16 *portchange, u16 *portstatus)\n{\n\tint status = 0, delay_ms = 0;\n\n\twhile (delay_ms < 2000) {\n\t\tif (status || *portstatus & USB_PORT_STAT_CONNECTION)\n\t\t\tbreak;\n\t\tmsleep(20);\n\t\tdelay_ms += 20;\n\t\tstatus = hub_port_status(hub, *port1, portstatus, portchange);\n\t}\n\treturn status;\n}\n\n/*\n * usb_port_resume - re-activate a suspended usb device's upstream port\n * @udev: device to re-activate, not a root hub\n * Context: must be able to sleep; device not locked; pm locks held\n *\n * This will re-activate the suspended device, increasing power usage\n * while letting drivers communicate again with its endpoints.\n * USB resume explicitly guarantees that the power session between\n * the host and the device is the same as it was when the device\n * suspended.\n *\n * If @udev->reset_resume is set then this routine won't check that the\n * port is still enabled.  Furthermore, finish_port_resume() above will\n * reset @udev.  The end result is that a broken power session can be\n * recovered and @udev will appear to persist across a loss of VBUS power.\n *\n * For example, if a host controller doesn't maintain VBUS suspend current\n * during a system sleep or is reset when the system wakes up, all the USB\n * power sessions below it will be broken.  This is especially troublesome\n * for mass-storage devices containing mounted filesystems, since the\n * device will appear to have disconnected and all the memory mappings\n * to it will be lost.  Using the USB_PERSIST facility, the device can be\n * made to appear as if it had not disconnected.\n *\n * This facility can be dangerous.  Although usb_reset_and_verify_device() makes\n * every effort to insure that the same device is present after the\n * reset as before, it cannot provide a 100% guarantee.  Furthermore it's\n * quite possible for a device to remain unaltered but its media to be\n * changed.  If the user replaces a flash memory card while the system is\n * asleep, he will have only himself to blame when the filesystem on the\n * new card is corrupted and the system crashes.\n *\n * Returns 0 on success, else negative errno.\n */\nint usb_port_resume(struct usb_device *udev, pm_message_t msg)\n{\n\tstruct usb_hub\t*hub = usb_hub_to_struct_hub(udev->parent);\n\tstruct usb_port *port_dev = hub->ports[udev->portnum  - 1];\n\tint\t\tport1 = udev->portnum;\n\tint\t\tstatus;\n\tu16\t\tportchange, portstatus;\n\n\tif (!test_and_set_bit(port1, hub->child_usage_bits)) {\n\t\tstatus = pm_runtime_get_sync(&port_dev->dev);\n\t\tif (status < 0) {\n\t\t\tdev_dbg(&udev->dev, \"can't resume usb port, status %d\\n\",\n\t\t\t\t\tstatus);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tusb_lock_port(port_dev);\n\n\t/* Skip the initial Clear-Suspend step for a remote wakeup */\n\tstatus = hub_port_status(hub, port1, &portstatus, &portchange);\n\tif (status == 0 && !port_is_suspended(hub, portstatus))\n\t\tgoto SuspendCleared;\n\n\t/* see 7.1.7.7; affects power usage, but not budgeting */\n\tif (hub_is_superspeed(hub->hdev))\n\t\tstatus = hub_set_port_link_state(hub, port1, USB_SS_PORT_LS_U0);\n\telse\n\t\tstatus = usb_clear_port_feature(hub->hdev,\n\t\t\t\tport1, USB_PORT_FEAT_SUSPEND);\n\tif (status) {\n\t\tdev_dbg(&port_dev->dev, \"can't resume, status %d\\n\", status);\n\t} else {\n\t\t/* drive resume for USB_RESUME_TIMEOUT msec */\n\t\tdev_dbg(&udev->dev, \"usb %sresume\\n\",\n\t\t\t\t(PMSG_IS_AUTO(msg) ? \"auto-\" : \"\"));\n\t\tmsleep(USB_RESUME_TIMEOUT);\n\n\t\t/* Virtual root hubs can trigger on GET_PORT_STATUS to\n\t\t * stop resume signaling.  Then finish the resume\n\t\t * sequence.\n\t\t */\n\t\tstatus = hub_port_status(hub, port1, &portstatus, &portchange);\n\n\t\t/* TRSMRCY = 10 msec */\n\t\tmsleep(10);\n\t}\n\n SuspendCleared:\n\tif (status == 0) {\n\t\tudev->port_is_suspended = 0;\n\t\tif (hub_is_superspeed(hub->hdev)) {\n\t\t\tif (portchange & USB_PORT_STAT_C_LINK_STATE)\n\t\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_PORT_LINK_STATE);\n\t\t} else {\n\t\t\tif (portchange & USB_PORT_STAT_C_SUSPEND)\n\t\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\t\tUSB_PORT_FEAT_C_SUSPEND);\n\t\t}\n\t}\n\n\tif (udev->persist_enabled && hub_is_superspeed(hub->hdev))\n\t\tstatus = wait_for_ss_port_enable(udev, hub, &port1, &portchange,\n\t\t\t\t&portstatus);\n\n\tstatus = check_port_resume_type(udev,\n\t\t\thub, port1, status, portchange, portstatus);\n\tif (status == 0)\n\t\tstatus = finish_port_resume(udev);\n\tif (status < 0) {\n\t\tdev_dbg(&udev->dev, \"can't resume, status %d\\n\", status);\n\t\thub_port_logical_disconnect(hub, port1);\n\t} else  {\n\t\t/* Try to enable USB2 hardware LPM */\n\t\tif (udev->usb2_hw_lpm_capable == 1)\n\t\t\tusb_set_usb2_hardware_lpm(udev, 1);\n\n\t\t/* Try to enable USB3 LTM and LPM */\n\t\tusb_enable_ltm(udev);\n\t\tusb_unlocked_enable_lpm(udev);\n\t}\n\n\tusb_unlock_port(port_dev);\n\n\treturn status;\n}\n\nint usb_remote_wakeup(struct usb_device *udev)\n{\n\tint\tstatus = 0;\n\n\tusb_lock_device(udev);\n\tif (udev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"usb %sresume\\n\", \"wakeup-\");\n\t\tstatus = usb_autoresume_device(udev);\n\t\tif (status == 0) {\n\t\t\t/* Let the drivers do their thing, then... */\n\t\t\tusb_autosuspend_device(udev);\n\t\t}\n\t}\n\tusb_unlock_device(udev);\n\treturn status;\n}\n\n/* Returns 1 if there was a remote wakeup and a connect status change. */\nstatic int hub_handle_remote_wakeup(struct usb_hub *hub, unsigned int port,\n\t\tu16 portstatus, u16 portchange)\n\t\t__must_hold(&port_dev->status_lock)\n{\n\tstruct usb_port *port_dev = hub->ports[port - 1];\n\tstruct usb_device *hdev;\n\tstruct usb_device *udev;\n\tint connect_change = 0;\n\tint ret;\n\n\thdev = hub->hdev;\n\tudev = port_dev->child;\n\tif (!hub_is_superspeed(hdev)) {\n\t\tif (!(portchange & USB_PORT_STAT_C_SUSPEND))\n\t\t\treturn 0;\n\t\tusb_clear_port_feature(hdev, port, USB_PORT_FEAT_C_SUSPEND);\n\t} else {\n\t\tif (!udev || udev->state != USB_STATE_SUSPENDED ||\n\t\t\t\t (portstatus & USB_PORT_STAT_LINK_STATE) !=\n\t\t\t\t USB_SS_PORT_LS_U0)\n\t\t\treturn 0;\n\t}\n\n\tif (udev) {\n\t\t/* TRSMRCY = 10 msec */\n\t\tmsleep(10);\n\n\t\tusb_unlock_port(port_dev);\n\t\tret = usb_remote_wakeup(udev);\n\t\tusb_lock_port(port_dev);\n\t\tif (ret < 0)\n\t\t\tconnect_change = 1;\n\t} else {\n\t\tret = -ENODEV;\n\t\thub_port_disable(hub, port, 1);\n\t}\n\tdev_dbg(&port_dev->dev, \"resume, status %d\\n\", ret);\n\treturn connect_change;\n}\n\nstatic int check_ports_changed(struct usb_hub *hub)\n{\n\tint port1;\n\n\tfor (port1 = 1; port1 <= hub->hdev->maxchild; ++port1) {\n\t\tu16 portstatus, portchange;\n\t\tint status;\n\n\t\tstatus = hub_port_status(hub, port1, &portstatus, &portchange);\n\t\tif (!status && portchange)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int hub_suspend(struct usb_interface *intf, pm_message_t msg)\n{\n\tstruct usb_hub\t\t*hub = usb_get_intfdata(intf);\n\tstruct usb_device\t*hdev = hub->hdev;\n\tunsigned\t\tport1;\n\tint\t\t\tstatus;\n\n\t/*\n\t * Warn if children aren't already suspended.\n\t * Also, add up the number of wakeup-enabled descendants.\n\t */\n\thub->wakeup_enabled_descendants = 0;\n\tfor (port1 = 1; port1 <= hdev->maxchild; port1++) {\n\t\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\t\tstruct usb_device *udev = port_dev->child;\n\n\t\tif (udev && udev->can_submit) {\n\t\t\tdev_warn(&port_dev->dev, \"device %s not suspended yet\\n\",\n\t\t\t\t\tdev_name(&udev->dev));\n\t\t\tif (PMSG_IS_AUTO(msg))\n\t\t\t\treturn -EBUSY;\n\t\t}\n\t\tif (udev)\n\t\t\thub->wakeup_enabled_descendants +=\n\t\t\t\t\twakeup_enabled_descendants(udev);\n\t}\n\n\tif (hdev->do_remote_wakeup && hub->quirk_check_port_auto_suspend) {\n\t\t/* check if there are changes pending on hub ports */\n\t\tif (check_ports_changed(hub)) {\n\t\t\tif (PMSG_IS_AUTO(msg))\n\t\t\t\treturn -EBUSY;\n\t\t\tpm_wakeup_event(&hdev->dev, 2000);\n\t\t}\n\t}\n\n\tif (hub_is_superspeed(hdev) && hdev->do_remote_wakeup) {\n\t\t/* Enable hub to send remote wakeup for all ports. */\n\t\tfor (port1 = 1; port1 <= hdev->maxchild; port1++) {\n\t\t\tstatus = set_port_feature(hdev,\n\t\t\t\t\tport1 |\n\t\t\t\t\tUSB_PORT_FEAT_REMOTE_WAKE_CONNECT |\n\t\t\t\t\tUSB_PORT_FEAT_REMOTE_WAKE_DISCONNECT |\n\t\t\t\t\tUSB_PORT_FEAT_REMOTE_WAKE_OVER_CURRENT,\n\t\t\t\t\tUSB_PORT_FEAT_REMOTE_WAKE_MASK);\n\t\t}\n\t}\n\n\tdev_dbg(&intf->dev, \"%s\\n\", __func__);\n\n\t/* stop hub_wq and related activity */\n\thub_quiesce(hub, HUB_SUSPEND);\n\treturn 0;\n}\n\nstatic int hub_resume(struct usb_interface *intf)\n{\n\tstruct usb_hub *hub = usb_get_intfdata(intf);\n\n\tdev_dbg(&intf->dev, \"%s\\n\", __func__);\n\thub_activate(hub, HUB_RESUME);\n\treturn 0;\n}\n\nstatic int hub_reset_resume(struct usb_interface *intf)\n{\n\tstruct usb_hub *hub = usb_get_intfdata(intf);\n\n\tdev_dbg(&intf->dev, \"%s\\n\", __func__);\n\thub_activate(hub, HUB_RESET_RESUME);\n\treturn 0;\n}\n\n/**\n * usb_root_hub_lost_power - called by HCD if the root hub lost Vbus power\n * @rhdev: struct usb_device for the root hub\n *\n * The USB host controller driver calls this function when its root hub\n * is resumed and Vbus power has been interrupted or the controller\n * has been reset.  The routine marks @rhdev as having lost power.\n * When the hub driver is resumed it will take notice and carry out\n * power-session recovery for all the \"USB-PERSIST\"-enabled child devices;\n * the others will be disconnected.\n */\nvoid usb_root_hub_lost_power(struct usb_device *rhdev)\n{\n\tdev_warn(&rhdev->dev, \"root hub lost power or was reset\\n\");\n\trhdev->reset_resume = 1;\n}\nEXPORT_SYMBOL_GPL(usb_root_hub_lost_power);\n\nstatic const char * const usb3_lpm_names[]  = {\n\t\"U0\",\n\t\"U1\",\n\t\"U2\",\n\t\"U3\",\n};\n\n/*\n * Send a Set SEL control transfer to the device, prior to enabling\n * device-initiated U1 or U2.  This lets the device know the exit latencies from\n * the time the device initiates a U1 or U2 exit, to the time it will receive a\n * packet from the host.\n *\n * This function will fail if the SEL or PEL values for udev are greater than\n * the maximum allowed values for the link state to be enabled.\n */\nstatic int usb_req_set_sel(struct usb_device *udev, enum usb3_link_state state)\n{\n\tstruct usb_set_sel_req *sel_values;\n\tunsigned long long u1_sel;\n\tunsigned long long u1_pel;\n\tunsigned long long u2_sel;\n\tunsigned long long u2_pel;\n\tint ret;\n\n\tif (udev->state != USB_STATE_CONFIGURED)\n\t\treturn 0;\n\n\t/* Convert SEL and PEL stored in ns to us */\n\tu1_sel = DIV_ROUND_UP(udev->u1_params.sel, 1000);\n\tu1_pel = DIV_ROUND_UP(udev->u1_params.pel, 1000);\n\tu2_sel = DIV_ROUND_UP(udev->u2_params.sel, 1000);\n\tu2_pel = DIV_ROUND_UP(udev->u2_params.pel, 1000);\n\n\t/*\n\t * Make sure that the calculated SEL and PEL values for the link\n\t * state we're enabling aren't bigger than the max SEL/PEL\n\t * value that will fit in the SET SEL control transfer.\n\t * Otherwise the device would get an incorrect idea of the exit\n\t * latency for the link state, and could start a device-initiated\n\t * U1/U2 when the exit latencies are too high.\n\t */\n\tif ((state == USB3_LPM_U1 &&\n\t\t\t\t(u1_sel > USB3_LPM_MAX_U1_SEL_PEL ||\n\t\t\t\t u1_pel > USB3_LPM_MAX_U1_SEL_PEL)) ||\n\t\t\t(state == USB3_LPM_U2 &&\n\t\t\t (u2_sel > USB3_LPM_MAX_U2_SEL_PEL ||\n\t\t\t  u2_pel > USB3_LPM_MAX_U2_SEL_PEL))) {\n\t\tdev_dbg(&udev->dev, \"Device-initiated %s disabled due to long SEL %llu us or PEL %llu us\\n\",\n\t\t\t\tusb3_lpm_names[state], u1_sel, u1_pel);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * If we're enabling device-initiated LPM for one link state,\n\t * but the other link state has a too high SEL or PEL value,\n\t * just set those values to the max in the Set SEL request.\n\t */\n\tif (u1_sel > USB3_LPM_MAX_U1_SEL_PEL)\n\t\tu1_sel = USB3_LPM_MAX_U1_SEL_PEL;\n\n\tif (u1_pel > USB3_LPM_MAX_U1_SEL_PEL)\n\t\tu1_pel = USB3_LPM_MAX_U1_SEL_PEL;\n\n\tif (u2_sel > USB3_LPM_MAX_U2_SEL_PEL)\n\t\tu2_sel = USB3_LPM_MAX_U2_SEL_PEL;\n\n\tif (u2_pel > USB3_LPM_MAX_U2_SEL_PEL)\n\t\tu2_pel = USB3_LPM_MAX_U2_SEL_PEL;\n\n\t/*\n\t * usb_enable_lpm() can be called as part of a failed device reset,\n\t * which may be initiated by an error path of a mass storage driver.\n\t * Therefore, use GFP_NOIO.\n\t */\n\tsel_values = kmalloc(sizeof *(sel_values), GFP_NOIO);\n\tif (!sel_values)\n\t\treturn -ENOMEM;\n\n\tsel_values->u1_sel = u1_sel;\n\tsel_values->u1_pel = u1_pel;\n\tsel_values->u2_sel = cpu_to_le16(u2_sel);\n\tsel_values->u2_pel = cpu_to_le16(u2_pel);\n\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_SEL,\n\t\t\tUSB_RECIP_DEVICE,\n\t\t\t0, 0,\n\t\t\tsel_values, sizeof *(sel_values),\n\t\t\tUSB_CTRL_SET_TIMEOUT);\n\tkfree(sel_values);\n\treturn ret;\n}\n\n/*\n * Enable or disable device-initiated U1 or U2 transitions.\n */\nstatic int usb_set_device_initiated_lpm(struct usb_device *udev,\n\t\tenum usb3_link_state state, bool enable)\n{\n\tint ret;\n\tint feature;\n\n\tswitch (state) {\n\tcase USB3_LPM_U1:\n\t\tfeature = USB_DEVICE_U1_ENABLE;\n\t\tbreak;\n\tcase USB3_LPM_U2:\n\t\tfeature = USB_DEVICE_U2_ENABLE;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&udev->dev, \"%s: Can't %s non-U1 or U2 state.\\n\",\n\t\t\t\t__func__, enable ? \"enable\" : \"disable\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (udev->state != USB_STATE_CONFIGURED) {\n\t\tdev_dbg(&udev->dev, \"%s: Can't %s %s state \"\n\t\t\t\t\"for unconfigured device.\\n\",\n\t\t\t\t__func__, enable ? \"enable\" : \"disable\",\n\t\t\t\tusb3_lpm_names[state]);\n\t\treturn 0;\n\t}\n\n\tif (enable) {\n\t\t/*\n\t\t * Now send the control transfer to enable device-initiated LPM\n\t\t * for either U1 or U2.\n\t\t */\n\t\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE,\n\t\t\t\tUSB_RECIP_DEVICE,\n\t\t\t\tfeature,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t} else {\n\t\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_CLEAR_FEATURE,\n\t\t\t\tUSB_RECIP_DEVICE,\n\t\t\t\tfeature,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t}\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev, \"%s of device-initiated %s failed.\\n\",\n\t\t\t\tenable ? \"Enable\" : \"Disable\",\n\t\t\t\tusb3_lpm_names[state]);\n\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}\n\nstatic int usb_set_lpm_timeout(struct usb_device *udev,\n\t\tenum usb3_link_state state, int timeout)\n{\n\tint ret;\n\tint feature;\n\n\tswitch (state) {\n\tcase USB3_LPM_U1:\n\t\tfeature = USB_PORT_FEAT_U1_TIMEOUT;\n\t\tbreak;\n\tcase USB3_LPM_U2:\n\t\tfeature = USB_PORT_FEAT_U2_TIMEOUT;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&udev->dev, \"%s: Can't set timeout for non-U1 or U2 state.\\n\",\n\t\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (state == USB3_LPM_U1 && timeout > USB3_LPM_U1_MAX_TIMEOUT &&\n\t\t\ttimeout != USB3_LPM_DEVICE_INITIATED) {\n\t\tdev_warn(&udev->dev, \"Failed to set %s timeout to 0x%x, \"\n\t\t\t\t\"which is a reserved value.\\n\",\n\t\t\t\tusb3_lpm_names[state], timeout);\n\t\treturn -EINVAL;\n\t}\n\n\tret = set_port_feature(udev->parent,\n\t\t\tUSB_PORT_LPM_TIMEOUT(timeout) | udev->portnum,\n\t\t\tfeature);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev, \"Failed to set %s timeout to 0x%x,\"\n\t\t\t\t\"error code %i\\n\", usb3_lpm_names[state],\n\t\t\t\ttimeout, ret);\n\t\treturn -EBUSY;\n\t}\n\tif (state == USB3_LPM_U1)\n\t\tudev->u1_params.timeout = timeout;\n\telse\n\t\tudev->u2_params.timeout = timeout;\n\treturn 0;\n}\n\n/*\n * Enable the hub-initiated U1/U2 idle timeouts, and enable device-initiated\n * U1/U2 entry.\n *\n * We will attempt to enable U1 or U2, but there are no guarantees that the\n * control transfers to set the hub timeout or enable device-initiated U1/U2\n * will be successful.\n *\n * If we cannot set the parent hub U1/U2 timeout, we attempt to let the xHCI\n * driver know about it.  If that call fails, it should be harmless, and just\n * take up more slightly more bus bandwidth for unnecessary U1/U2 exit latency.\n */\nstatic void usb_enable_link_state(struct usb_hcd *hcd, struct usb_device *udev,\n\t\tenum usb3_link_state state)\n{\n\tint timeout, ret;\n\t__u8 u1_mel = udev->bos->ss_cap->bU1devExitLat;\n\t__le16 u2_mel = udev->bos->ss_cap->bU2DevExitLat;\n\n\t/* If the device says it doesn't have *any* exit latency to come out of\n\t * U1 or U2, it's probably lying.  Assume it doesn't implement that link\n\t * state.\n\t */\n\tif ((state == USB3_LPM_U1 && u1_mel == 0) ||\n\t\t\t(state == USB3_LPM_U2 && u2_mel == 0))\n\t\treturn;\n\n\t/*\n\t * First, let the device know about the exit latencies\n\t * associated with the link state we're about to enable.\n\t */\n\tret = usb_req_set_sel(udev, state);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev, \"Set SEL for device-initiated %s failed.\\n\",\n\t\t\t\tusb3_lpm_names[state]);\n\t\treturn;\n\t}\n\n\t/* We allow the host controller to set the U1/U2 timeout internally\n\t * first, so that it can change its schedule to account for the\n\t * additional latency to send data to a device in a lower power\n\t * link state.\n\t */\n\ttimeout = hcd->driver->enable_usb3_lpm_timeout(hcd, udev, state);\n\n\t/* xHCI host controller doesn't want to enable this LPM state. */\n\tif (timeout == 0)\n\t\treturn;\n\n\tif (timeout < 0) {\n\t\tdev_warn(&udev->dev, \"Could not enable %s link state, \"\n\t\t\t\t\"xHCI error %i.\\n\", usb3_lpm_names[state],\n\t\t\t\ttimeout);\n\t\treturn;\n\t}\n\n\tif (usb_set_lpm_timeout(udev, state, timeout))\n\t\t/* If we can't set the parent hub U1/U2 timeout,\n\t\t * device-initiated LPM won't be allowed either, so let the xHCI\n\t\t * host know that this link state won't be enabled.\n\t\t */\n\t\thcd->driver->disable_usb3_lpm_timeout(hcd, udev, state);\n\n\t/* Only a configured device will accept the Set Feature U1/U2_ENABLE */\n\telse if (udev->actconfig)\n\t\tusb_set_device_initiated_lpm(udev, state, true);\n\n}\n\n/*\n * Disable the hub-initiated U1/U2 idle timeouts, and disable device-initiated\n * U1/U2 entry.\n *\n * If this function returns -EBUSY, the parent hub will still allow U1/U2 entry.\n * If zero is returned, the parent will not allow the link to go into U1/U2.\n *\n * If zero is returned, device-initiated U1/U2 entry may still be enabled, but\n * it won't have an effect on the bus link state because the parent hub will\n * still disallow device-initiated U1/U2 entry.\n *\n * If zero is returned, the xHCI host controller may still think U1/U2 entry is\n * possible.  The result will be slightly more bus bandwidth will be taken up\n * (to account for U1/U2 exit latency), but it should be harmless.\n */\nstatic int usb_disable_link_state(struct usb_hcd *hcd, struct usb_device *udev,\n\t\tenum usb3_link_state state)\n{\n\tswitch (state) {\n\tcase USB3_LPM_U1:\n\tcase USB3_LPM_U2:\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&udev->dev, \"%s: Can't disable non-U1 or U2 state.\\n\",\n\t\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (usb_set_lpm_timeout(udev, state, 0))\n\t\treturn -EBUSY;\n\n\tusb_set_device_initiated_lpm(udev, state, false);\n\n\tif (hcd->driver->disable_usb3_lpm_timeout(hcd, udev, state))\n\t\tdev_warn(&udev->dev, \"Could not disable xHCI %s timeout, \"\n\t\t\t\t\"bus schedule bandwidth may be impacted.\\n\",\n\t\t\t\tusb3_lpm_names[state]);\n\treturn 0;\n}\n\n/*\n * Disable hub-initiated and device-initiated U1 and U2 entry.\n * Caller must own the bandwidth_mutex.\n *\n * This will call usb_enable_lpm() on failure, which will decrement\n * lpm_disable_count, and will re-enable LPM if lpm_disable_count reaches zero.\n */\nint usb_disable_lpm(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd;\n\n\tif (!udev || !udev->parent ||\n\t\t\tudev->speed != USB_SPEED_SUPER ||\n\t\t\t!udev->lpm_capable ||\n\t\t\tudev->state < USB_STATE_DEFAULT)\n\t\treturn 0;\n\n\thcd = bus_to_hcd(udev->bus);\n\tif (!hcd || !hcd->driver->disable_usb3_lpm_timeout)\n\t\treturn 0;\n\n\tudev->lpm_disable_count++;\n\tif ((udev->u1_params.timeout == 0 && udev->u2_params.timeout == 0))\n\t\treturn 0;\n\n\t/* If LPM is enabled, attempt to disable it. */\n\tif (usb_disable_link_state(hcd, udev, USB3_LPM_U1))\n\t\tgoto enable_lpm;\n\tif (usb_disable_link_state(hcd, udev, USB3_LPM_U2))\n\t\tgoto enable_lpm;\n\n\tudev->usb3_lpm_enabled = 0;\n\n\treturn 0;\n\nenable_lpm:\n\tusb_enable_lpm(udev);\n\treturn -EBUSY;\n}\nEXPORT_SYMBOL_GPL(usb_disable_lpm);\n\n/* Grab the bandwidth_mutex before calling usb_disable_lpm() */\nint usb_unlocked_disable_lpm(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\tint ret;\n\n\tif (!hcd)\n\t\treturn -EINVAL;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_disable_lpm(udev);\n\tmutex_unlock(hcd->bandwidth_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_unlocked_disable_lpm);\n\n/*\n * Attempt to enable device-initiated and hub-initiated U1 and U2 entry.  The\n * xHCI host policy may prevent U1 or U2 from being enabled.\n *\n * Other callers may have disabled link PM, so U1 and U2 entry will be disabled\n * until the lpm_disable_count drops to zero.  Caller must own the\n * bandwidth_mutex.\n */\nvoid usb_enable_lpm(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd;\n\n\tif (!udev || !udev->parent ||\n\t\t\tudev->speed != USB_SPEED_SUPER ||\n\t\t\t!udev->lpm_capable ||\n\t\t\tudev->state < USB_STATE_DEFAULT)\n\t\treturn;\n\n\tudev->lpm_disable_count--;\n\thcd = bus_to_hcd(udev->bus);\n\t/* Double check that we can both enable and disable LPM.\n\t * Device must be configured to accept set feature U1/U2 timeout.\n\t */\n\tif (!hcd || !hcd->driver->enable_usb3_lpm_timeout ||\n\t\t\t!hcd->driver->disable_usb3_lpm_timeout)\n\t\treturn;\n\n\tif (udev->lpm_disable_count > 0)\n\t\treturn;\n\n\tusb_enable_link_state(hcd, udev, USB3_LPM_U1);\n\tusb_enable_link_state(hcd, udev, USB3_LPM_U2);\n\n\tudev->usb3_lpm_enabled = 1;\n}\nEXPORT_SYMBOL_GPL(usb_enable_lpm);\n\n/* Grab the bandwidth_mutex before calling usb_enable_lpm() */\nvoid usb_unlocked_enable_lpm(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\tif (!hcd)\n\t\treturn;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tusb_enable_lpm(udev);\n\tmutex_unlock(hcd->bandwidth_mutex);\n}\nEXPORT_SYMBOL_GPL(usb_unlocked_enable_lpm);\n\n\n#else\t/* CONFIG_PM */\n\n#define hub_suspend\t\tNULL\n#define hub_resume\t\tNULL\n#define hub_reset_resume\tNULL\n\nint usb_disable_lpm(struct usb_device *udev)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_disable_lpm);\n\nvoid usb_enable_lpm(struct usb_device *udev) { }\nEXPORT_SYMBOL_GPL(usb_enable_lpm);\n\nint usb_unlocked_disable_lpm(struct usb_device *udev)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_unlocked_disable_lpm);\n\nvoid usb_unlocked_enable_lpm(struct usb_device *udev) { }\nEXPORT_SYMBOL_GPL(usb_unlocked_enable_lpm);\n\nint usb_disable_ltm(struct usb_device *udev)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_disable_ltm);\n\nvoid usb_enable_ltm(struct usb_device *udev) { }\nEXPORT_SYMBOL_GPL(usb_enable_ltm);\n\nstatic int hub_handle_remote_wakeup(struct usb_hub *hub, unsigned int port,\n\t\tu16 portstatus, u16 portchange)\n{\n\treturn 0;\n}\n\n#endif\t/* CONFIG_PM */\n\n\n/* USB 2.0 spec, 7.1.7.3 / fig 7-29:\n *\n * Between connect detection and reset signaling there must be a delay\n * of 100ms at least for debounce and power-settling.  The corresponding\n * timer shall restart whenever the downstream port detects a disconnect.\n *\n * Apparently there are some bluetooth and irda-dongles and a number of\n * low-speed devices for which this debounce period may last over a second.\n * Not covered by the spec - but easy to deal with.\n *\n * This implementation uses a 1500ms total debounce timeout; if the\n * connection isn't stable by then it returns -ETIMEDOUT.  It checks\n * every 25ms for transient disconnects.  When the port status has been\n * unchanged for 100ms it returns the port status.\n */\nint hub_port_debounce(struct usb_hub *hub, int port1, bool must_be_connected)\n{\n\tint ret;\n\tu16 portchange, portstatus;\n\tunsigned connection = 0xffff;\n\tint total_time, stable_time = 0;\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\n\tfor (total_time = 0; ; total_time += HUB_DEBOUNCE_STEP) {\n\t\tret = hub_port_status(hub, port1, &portstatus, &portchange);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (!(portchange & USB_PORT_STAT_C_CONNECTION) &&\n\t\t     (portstatus & USB_PORT_STAT_CONNECTION) == connection) {\n\t\t\tif (!must_be_connected ||\n\t\t\t     (connection == USB_PORT_STAT_CONNECTION))\n\t\t\t\tstable_time += HUB_DEBOUNCE_STEP;\n\t\t\tif (stable_time >= HUB_DEBOUNCE_STABLE)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tstable_time = 0;\n\t\t\tconnection = portstatus & USB_PORT_STAT_CONNECTION;\n\t\t}\n\n\t\tif (portchange & USB_PORT_STAT_C_CONNECTION) {\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_CONNECTION);\n\t\t}\n\n\t\tif (total_time >= HUB_DEBOUNCE_TIMEOUT)\n\t\t\tbreak;\n\t\tmsleep(HUB_DEBOUNCE_STEP);\n\t}\n\n\tdev_dbg(&port_dev->dev, \"debounce total %dms stable %dms status 0x%x\\n\",\n\t\t\ttotal_time, stable_time, portstatus);\n\n\tif (stable_time < HUB_DEBOUNCE_STABLE)\n\t\treturn -ETIMEDOUT;\n\treturn portstatus;\n}\n\nvoid usb_ep0_reinit(struct usb_device *udev)\n{\n\tusb_disable_endpoint(udev, 0 + USB_DIR_IN, true);\n\tusb_disable_endpoint(udev, 0 + USB_DIR_OUT, true);\n\tusb_enable_endpoint(udev, &udev->ep0, true);\n}\nEXPORT_SYMBOL_GPL(usb_ep0_reinit);\n\n#define usb_sndaddr0pipe()\t(PIPE_CONTROL << 30)\n#define usb_rcvaddr0pipe()\t((PIPE_CONTROL << 30) | USB_DIR_IN)\n\nstatic int hub_set_address(struct usb_device *udev, int devnum)\n{\n\tint retval;\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\t/*\n\t * The host controller will choose the device address,\n\t * instead of the core having chosen it earlier\n\t */\n\tif (!hcd->driver->address_device && devnum <= 1)\n\t\treturn -EINVAL;\n\tif (udev->state == USB_STATE_ADDRESS)\n\t\treturn 0;\n\tif (udev->state != USB_STATE_DEFAULT)\n\t\treturn -EINVAL;\n\tif (hcd->driver->address_device)\n\t\tretval = hcd->driver->address_device(hcd, udev);\n\telse\n\t\tretval = usb_control_msg(udev, usb_sndaddr0pipe(),\n\t\t\t\tUSB_REQ_SET_ADDRESS, 0, devnum, 0,\n\t\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (retval == 0) {\n\t\tupdate_devnum(udev, devnum);\n\t\t/* Device now using proper address. */\n\t\tusb_set_device_state(udev, USB_STATE_ADDRESS);\n\t\tusb_ep0_reinit(udev);\n\t}\n\treturn retval;\n}\n\n/*\n * There are reports of USB 3.0 devices that say they support USB 2.0 Link PM\n * when they're plugged into a USB 2.0 port, but they don't work when LPM is\n * enabled.\n *\n * Only enable USB 2.0 Link PM if the port is internal (hardwired), or the\n * device says it supports the new USB 2.0 Link PM errata by setting the BESL\n * support bit in the BOS descriptor.\n */\nstatic void hub_set_initial_usb2_lpm_policy(struct usb_device *udev)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(udev->parent);\n\tint connect_type = USB_PORT_CONNECT_TYPE_UNKNOWN;\n\n\tif (!udev->usb2_hw_lpm_capable)\n\t\treturn;\n\n\tif (hub)\n\t\tconnect_type = hub->ports[udev->portnum - 1]->connect_type;\n\n\tif ((udev->bos->ext_cap->bmAttributes & cpu_to_le32(USB_BESL_SUPPORT)) ||\n\t\t\tconnect_type == USB_PORT_CONNECT_TYPE_HARD_WIRED) {\n\t\tudev->usb2_hw_lpm_allowed = 1;\n\t\tusb_set_usb2_hardware_lpm(udev, 1);\n\t}\n}\n\nstatic int hub_enable_device(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\tif (!hcd->driver->enable_device)\n\t\treturn 0;\n\tif (udev->state == USB_STATE_ADDRESS)\n\t\treturn 0;\n\tif (udev->state != USB_STATE_DEFAULT)\n\t\treturn -EINVAL;\n\n\treturn hcd->driver->enable_device(hcd, udev);\n}\n\n/* Reset device, (re)assign address, get device descriptor.\n * Device connection must be stable, no more debouncing needed.\n * Returns device in USB_STATE_ADDRESS, except on error.\n *\n * If this is called for an already-existing device (as part of\n * usb_reset_and_verify_device), the caller must own the device lock and\n * the port lock.  For a newly detected device that is not accessible\n * through any global pointers, it's not necessary to lock the device,\n * but it is still necessary to lock the port.\n */\nstatic int\nhub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,\n\t\tint retry_counter)\n{\n\tstruct usb_device\t*hdev = hub->hdev;\n\tstruct usb_hcd\t\t*hcd = bus_to_hcd(hdev->bus);\n\tint\t\t\ti, j, retval;\n\tunsigned\t\tdelay = HUB_SHORT_RESET_TIME;\n\tenum usb_device_speed\toldspeed = udev->speed;\n\tconst char\t\t*speed;\n\tint\t\t\tdevnum = udev->devnum;\n\n\t/* root hub ports have a slightly longer reset period\n\t * (from USB 2.0 spec, section 7.1.7.5)\n\t */\n\tif (!hdev->parent) {\n\t\tdelay = HUB_ROOT_RESET_TIME;\n\t\tif (port1 == hdev->bus->otg_port)\n\t\t\thdev->bus->b_hnp_enable = 0;\n\t}\n\n\t/* Some low speed devices have problems with the quick delay, so */\n\t/*  be a bit pessimistic with those devices. RHbug #23670 */\n\tif (oldspeed == USB_SPEED_LOW)\n\t\tdelay = HUB_LONG_RESET_TIME;\n\n\tmutex_lock(&hdev->bus->usb_address0_mutex);\n\n\t/* Reset the device; full speed may morph to high speed */\n\t/* FIXME a USB 2.0 device may morph into SuperSpeed on reset. */\n\tretval = hub_port_reset(hub, port1, udev, delay, false);\n\tif (retval < 0)\t\t/* error or disconnect */\n\t\tgoto fail;\n\t/* success, speed is known */\n\n\tretval = -ENODEV;\n\n\tif (oldspeed != USB_SPEED_UNKNOWN && oldspeed != udev->speed) {\n\t\tdev_dbg(&udev->dev, \"device reset changed speed!\\n\");\n\t\tgoto fail;\n\t}\n\toldspeed = udev->speed;\n\n\t/* USB 2.0 section 5.5.3 talks about ep0 maxpacket ...\n\t * it's fixed size except for full speed devices.\n\t * For Wireless USB devices, ep0 max packet is always 512 (tho\n\t * reported as 0xff in the device descriptor). WUSB1.0[4.8.1].\n\t */\n\tswitch (udev->speed) {\n\tcase USB_SPEED_SUPER:\n\tcase USB_SPEED_WIRELESS:\t/* fixed at 512 */\n\t\tudev->ep0.desc.wMaxPacketSize = cpu_to_le16(512);\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\t\t/* fixed at 64 */\n\t\tudev->ep0.desc.wMaxPacketSize = cpu_to_le16(64);\n\t\tbreak;\n\tcase USB_SPEED_FULL:\t\t/* 8, 16, 32, or 64 */\n\t\t/* to determine the ep0 maxpacket size, try to read\n\t\t * the device descriptor to get bMaxPacketSize0 and\n\t\t * then correct our initial guess.\n\t\t */\n\t\tudev->ep0.desc.wMaxPacketSize = cpu_to_le16(64);\n\t\tbreak;\n\tcase USB_SPEED_LOW:\t\t/* fixed at 8 */\n\t\tudev->ep0.desc.wMaxPacketSize = cpu_to_le16(8);\n\t\tbreak;\n\tdefault:\n\t\tgoto fail;\n\t}\n\n\tif (udev->speed == USB_SPEED_WIRELESS)\n\t\tspeed = \"variable speed Wireless\";\n\telse\n\t\tspeed = usb_speed_string(udev->speed);\n\n\tif (udev->speed != USB_SPEED_SUPER)\n\t\tdev_info(&udev->dev,\n\t\t\t\t\"%s %s USB device number %d using %s\\n\",\n\t\t\t\t(udev->config) ? \"reset\" : \"new\", speed,\n\t\t\t\tdevnum, udev->bus->controller->driver->name);\n\n\t/* Set up TT records, if needed  */\n\tif (hdev->tt) {\n\t\tudev->tt = hdev->tt;\n\t\tudev->ttport = hdev->ttport;\n\t} else if (udev->speed != USB_SPEED_HIGH\n\t\t\t&& hdev->speed == USB_SPEED_HIGH) {\n\t\tif (!hub->tt.hub) {\n\t\t\tdev_err(&udev->dev, \"parent hub has no TT\\n\");\n\t\t\tretval = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\tudev->tt = &hub->tt;\n\t\tudev->ttport = port1;\n\t}\n\n\t/* Why interleave GET_DESCRIPTOR and SET_ADDRESS this way?\n\t * Because device hardware and firmware is sometimes buggy in\n\t * this area, and this is how Linux has done it for ages.\n\t * Change it cautiously.\n\t *\n\t * NOTE:  If use_new_scheme() is true we will start by issuing\n\t * a 64-byte GET_DESCRIPTOR request.  This is what Windows does,\n\t * so it may help with some non-standards-compliant devices.\n\t * Otherwise we start with SET_ADDRESS and then try to read the\n\t * first 8 bytes of the device descriptor to get the ep0 maxpacket\n\t * value.\n\t */\n\tfor (i = 0; i < GET_DESCRIPTOR_TRIES; (++i, msleep(100))) {\n\t\tbool did_new_scheme = false;\n\n\t\tif (use_new_scheme(udev, retry_counter)) {\n\t\t\tstruct usb_device_descriptor *buf;\n\t\t\tint r = 0;\n\n\t\t\tdid_new_scheme = true;\n\t\t\tretval = hub_enable_device(udev);\n\t\t\tif (retval < 0) {\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"hub failed to enable device, error %d\\n\",\n\t\t\t\t\tretval);\n\t\t\t\tgoto fail;\n\t\t\t}\n\n#define GET_DESCRIPTOR_BUFSIZE\t64\n\t\t\tbuf = kmalloc(GET_DESCRIPTOR_BUFSIZE, GFP_NOIO);\n\t\t\tif (!buf) {\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Retry on all errors; some devices are flakey.\n\t\t\t * 255 is for WUSB devices, we actually need to use\n\t\t\t * 512 (WUSB1.0[4.8.1]).\n\t\t\t */\n\t\t\tfor (j = 0; j < 3; ++j) {\n\t\t\t\tbuf->bMaxPacketSize0 = 0;\n\t\t\t\tr = usb_control_msg(udev, usb_rcvaddr0pipe(),\n\t\t\t\t\tUSB_REQ_GET_DESCRIPTOR, USB_DIR_IN,\n\t\t\t\t\tUSB_DT_DEVICE << 8, 0,\n\t\t\t\t\tbuf, GET_DESCRIPTOR_BUFSIZE,\n\t\t\t\t\tinitial_descriptor_timeout);\n\t\t\t\tswitch (buf->bMaxPacketSize0) {\n\t\t\t\tcase 8: case 16: case 32: case 64: case 255:\n\t\t\t\t\tif (buf->bDescriptorType ==\n\t\t\t\t\t\t\tUSB_DT_DEVICE) {\n\t\t\t\t\t\tr = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/* FALL THROUGH */\n\t\t\t\tdefault:\n\t\t\t\t\tif (r == 0)\n\t\t\t\t\t\tr = -EPROTO;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (r == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tudev->descriptor.bMaxPacketSize0 =\n\t\t\t\t\tbuf->bMaxPacketSize0;\n\t\t\tkfree(buf);\n\n\t\t\tretval = hub_port_reset(hub, port1, udev, delay, false);\n\t\t\tif (retval < 0)\t\t/* error or disconnect */\n\t\t\t\tgoto fail;\n\t\t\tif (oldspeed != udev->speed) {\n\t\t\t\tdev_dbg(&udev->dev,\n\t\t\t\t\t\"device reset changed speed!\\n\");\n\t\t\t\tretval = -ENODEV;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tif (r) {\n\t\t\t\tif (r != -ENODEV)\n\t\t\t\t\tdev_err(&udev->dev, \"device descriptor read/64, error %d\\n\",\n\t\t\t\t\t\t\tr);\n\t\t\t\tretval = -EMSGSIZE;\n\t\t\t\tcontinue;\n\t\t\t}\n#undef GET_DESCRIPTOR_BUFSIZE\n\t\t}\n\n\t\t/*\n\t\t * If device is WUSB, we already assigned an\n\t\t * unauthorized address in the Connect Ack sequence;\n\t\t * authorization will assign the final address.\n\t\t */\n\t\tif (udev->wusb == 0) {\n\t\t\tfor (j = 0; j < SET_ADDRESS_TRIES; ++j) {\n\t\t\t\tretval = hub_set_address(udev, devnum);\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tbreak;\n\t\t\t\tmsleep(200);\n\t\t\t}\n\t\t\tif (retval < 0) {\n\t\t\t\tif (retval != -ENODEV)\n\t\t\t\t\tdev_err(&udev->dev, \"device not accepting address %d, error %d\\n\",\n\t\t\t\t\t\t\tdevnum, retval);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tif (udev->speed == USB_SPEED_SUPER) {\n\t\t\t\tdevnum = udev->devnum;\n\t\t\t\tdev_info(&udev->dev,\n\t\t\t\t\t\t\"%s SuperSpeed USB device number %d using %s\\n\",\n\t\t\t\t\t\t(udev->config) ? \"reset\" : \"new\",\n\t\t\t\t\t\tdevnum, udev->bus->controller->driver->name);\n\t\t\t}\n\n\t\t\t/* cope with hardware quirkiness:\n\t\t\t *  - let SET_ADDRESS settle, some device hardware wants it\n\t\t\t *  - read ep0 maxpacket even for high and low speed,\n\t\t\t */\n\t\t\tmsleep(10);\n\t\t\t/* use_new_scheme() checks the speed which may have\n\t\t\t * changed since the initial look so we cache the result\n\t\t\t * in did_new_scheme\n\t\t\t */\n\t\t\tif (did_new_scheme)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tretval = usb_get_device_descriptor(udev, 8);\n\t\tif (retval < 8) {\n\t\t\tif (retval != -ENODEV)\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"device descriptor read/8, error %d\\n\",\n\t\t\t\t\tretval);\n\t\t\tif (retval >= 0)\n\t\t\t\tretval = -EMSGSIZE;\n\t\t} else {\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (retval)\n\t\tgoto fail;\n\n\t/*\n\t * Some superspeed devices have finished the link training process\n\t * and attached to a superspeed hub port, but the device descriptor\n\t * got from those devices show they aren't superspeed devices. Warm\n\t * reset the port attached by the devices can fix them.\n\t */\n\tif ((udev->speed == USB_SPEED_SUPER) &&\n\t\t\t(le16_to_cpu(udev->descriptor.bcdUSB) < 0x0300)) {\n\t\tdev_err(&udev->dev, \"got a wrong device descriptor, \"\n\t\t\t\t\"warm reset device\\n\");\n\t\thub_port_reset(hub, port1, udev,\n\t\t\t\tHUB_BH_RESET_TIME, true);\n\t\tretval = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tif (udev->descriptor.bMaxPacketSize0 == 0xff ||\n\t\t\tudev->speed == USB_SPEED_SUPER)\n\t\ti = 512;\n\telse\n\t\ti = udev->descriptor.bMaxPacketSize0;\n\tif (usb_endpoint_maxp(&udev->ep0.desc) != i) {\n\t\tif (udev->speed == USB_SPEED_LOW ||\n\t\t\t\t!(i == 8 || i == 16 || i == 32 || i == 64)) {\n\t\t\tdev_err(&udev->dev, \"Invalid ep0 maxpacket: %d\\n\", i);\n\t\t\tretval = -EMSGSIZE;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (udev->speed == USB_SPEED_FULL)\n\t\t\tdev_dbg(&udev->dev, \"ep0 maxpacket = %d\\n\", i);\n\t\telse\n\t\t\tdev_warn(&udev->dev, \"Using ep0 maxpacket: %d\\n\", i);\n\t\tudev->ep0.desc.wMaxPacketSize = cpu_to_le16(i);\n\t\tusb_ep0_reinit(udev);\n\t}\n\n\tretval = usb_get_device_descriptor(udev, USB_DT_DEVICE_SIZE);\n\tif (retval < (signed)sizeof(udev->descriptor)) {\n\t\tif (retval != -ENODEV)\n\t\t\tdev_err(&udev->dev, \"device descriptor read/all, error %d\\n\",\n\t\t\t\t\tretval);\n\t\tif (retval >= 0)\n\t\t\tretval = -ENOMSG;\n\t\tgoto fail;\n\t}\n\n\tusb_detect_quirks(udev);\n\n\tif (udev->wusb == 0 && le16_to_cpu(udev->descriptor.bcdUSB) >= 0x0201) {\n\t\tretval = usb_get_bos_descriptor(udev);\n\t\tif (!retval) {\n\t\t\tudev->lpm_capable = usb_device_supports_lpm(udev);\n\t\t\tusb_set_lpm_parameters(udev);\n\t\t}\n\t}\n\n\tretval = 0;\n\t/* notify HCD that we have a device connected and addressed */\n\tif (hcd->driver->update_device)\n\t\thcd->driver->update_device(hcd, udev);\n\thub_set_initial_usb2_lpm_policy(udev);\nfail:\n\tif (retval) {\n\t\thub_port_disable(hub, port1, 0);\n\t\tupdate_devnum(udev, devnum);\t/* for disconnect processing */\n\t}\n\tmutex_unlock(&hdev->bus->usb_address0_mutex);\n\treturn retval;\n}\n\nstatic void\ncheck_highspeed(struct usb_hub *hub, struct usb_device *udev, int port1)\n{\n\tstruct usb_qualifier_descriptor\t*qual;\n\tint\t\t\t\tstatus;\n\n\tif (udev->quirks & USB_QUIRK_DEVICE_QUALIFIER)\n\t\treturn;\n\n\tqual = kmalloc(sizeof *qual, GFP_KERNEL);\n\tif (qual == NULL)\n\t\treturn;\n\n\tstatus = usb_get_descriptor(udev, USB_DT_DEVICE_QUALIFIER, 0,\n\t\t\tqual, sizeof *qual);\n\tif (status == sizeof *qual) {\n\t\tdev_info(&udev->dev, \"not running at top speed; \"\n\t\t\t\"connect to a high speed hub\\n\");\n\t\t/* hub LEDs are probably harder to miss than syslog */\n\t\tif (hub->has_indicators) {\n\t\t\thub->indicator[port1-1] = INDICATOR_GREEN_BLINK;\n\t\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t\t&hub->leds, 0);\n\t\t}\n\t}\n\tkfree(qual);\n}\n\nstatic unsigned\nhub_power_remaining(struct usb_hub *hub)\n{\n\tstruct usb_device *hdev = hub->hdev;\n\tint remaining;\n\tint port1;\n\n\tif (!hub->limited_power)\n\t\treturn 0;\n\n\tremaining = hdev->bus_mA - hub->descriptor->bHubContrCurrent;\n\tfor (port1 = 1; port1 <= hdev->maxchild; ++port1) {\n\t\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\t\tstruct usb_device *udev = port_dev->child;\n\t\tunsigned unit_load;\n\t\tint delta;\n\n\t\tif (!udev)\n\t\t\tcontinue;\n\t\tif (hub_is_superspeed(udev))\n\t\t\tunit_load = 150;\n\t\telse\n\t\t\tunit_load = 100;\n\n\t\t/*\n\t\t * Unconfigured devices may not use more than one unit load,\n\t\t * or 8mA for OTG ports\n\t\t */\n\t\tif (udev->actconfig)\n\t\t\tdelta = usb_get_max_power(udev, udev->actconfig);\n\t\telse if (port1 != udev->bus->otg_port || hdev->parent)\n\t\t\tdelta = unit_load;\n\t\telse\n\t\t\tdelta = 8;\n\t\tif (delta > hub->mA_per_port)\n\t\t\tdev_warn(&port_dev->dev, \"%dmA is over %umA budget!\\n\",\n\t\t\t\t\tdelta, hub->mA_per_port);\n\t\tremaining -= delta;\n\t}\n\tif (remaining < 0) {\n\t\tdev_warn(hub->intfdev, \"%dmA over power budget!\\n\",\n\t\t\t-remaining);\n\t\tremaining = 0;\n\t}\n\treturn remaining;\n}\n\nstatic void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,\n\t\tu16 portchange)\n{\n\tint status, i;\n\tunsigned unit_load;\n\tstruct usb_device *hdev = hub->hdev;\n\tstruct usb_hcd *hcd = bus_to_hcd(hdev->bus);\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tstruct usb_device *udev = port_dev->child;\n\tstatic int unreliable_port = -1;\n\n\t/* Disconnect any existing devices under this port */\n\tif (udev) {\n\t\tif (hcd->usb_phy && !hdev->parent)\n\t\t\tusb_phy_notify_disconnect(hcd->usb_phy, udev->speed);\n\t\tusb_disconnect(&port_dev->child);\n\t}\n\n\t/* We can forget about a \"removed\" device when there's a physical\n\t * disconnect or the connect status changes.\n\t */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t(portchange & USB_PORT_STAT_C_CONNECTION))\n\t\tclear_bit(port1, hub->removed_bits);\n\n\tif (portchange & (USB_PORT_STAT_C_CONNECTION |\n\t\t\t\tUSB_PORT_STAT_C_ENABLE)) {\n\t\tstatus = hub_port_debounce_be_stable(hub, port1);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENODEV &&\n\t\t\t\tport1 != unreliable_port &&\n\t\t\t\tprintk_ratelimit())\n\t\t\t\tdev_err(&port_dev->dev, \"connect-debounce failed\\n\");\n\t\t\tportstatus &= ~USB_PORT_STAT_CONNECTION;\n\t\t\tunreliable_port = port1;\n\t\t} else {\n\t\t\tportstatus = status;\n\t\t}\n\t}\n\n\t/* Return now if debouncing failed or nothing is connected or\n\t * the device was \"removed\".\n\t */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\ttest_bit(port1, hub->removed_bits)) {\n\n\t\t/*\n\t\t * maybe switch power back on (e.g. root hub was reset)\n\t\t * but only if the port isn't owned by someone else.\n\t\t */\n\t\tif (hub_is_port_power_switchable(hub)\n\t\t\t\t&& !port_is_power_on(hub, portstatus)\n\t\t\t\t&& !port_dev->port_owner)\n\t\t\tset_port_feature(hdev, port1, USB_PORT_FEAT_POWER);\n\n\t\tif (portstatus & USB_PORT_STAT_ENABLE)\n\t\t\tgoto done;\n\t\treturn;\n\t}\n\tif (hub_is_superspeed(hub->hdev))\n\t\tunit_load = 150;\n\telse\n\t\tunit_load = 100;\n\n\tstatus = 0;\n\tfor (i = 0; i < SET_CONFIG_TRIES; i++) {\n\n\t\t/* reallocate for each attempt, since references\n\t\t * to the previous one can escape in various ways\n\t\t */\n\t\tudev = usb_alloc_dev(hdev, hdev->bus, port1);\n\t\tif (!udev) {\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"couldn't allocate usb_device\\n\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tusb_set_device_state(udev, USB_STATE_POWERED);\n\t\tudev->bus_mA = hub->mA_per_port;\n\t\tudev->level = hdev->level + 1;\n\t\tudev->wusb = hub_is_wusb(hub);\n\n\t\t/* Only USB 3.0 devices are connected to SuperSpeed hubs. */\n\t\tif (hub_is_superspeed(hub->hdev))\n\t\t\tudev->speed = USB_SPEED_SUPER;\n\t\telse\n\t\t\tudev->speed = USB_SPEED_UNKNOWN;\n\n\t\tchoose_devnum(udev);\n\t\tif (udev->devnum <= 0) {\n\t\t\tstatus = -ENOTCONN;\t/* Don't retry */\n\t\t\tgoto loop;\n\t\t}\n\n\t\t/* reset (non-USB 3.0 devices) and get descriptor */\n\t\tusb_lock_port(port_dev);\n\t\tstatus = hub_port_init(hub, udev, port1, i);\n\t\tusb_unlock_port(port_dev);\n\t\tif (status < 0)\n\t\t\tgoto loop;\n\n\t\tif (udev->quirks & USB_QUIRK_DELAY_INIT)\n\t\t\tmsleep(1000);\n\n\t\t/* consecutive bus-powered hubs aren't reliable; they can\n\t\t * violate the voltage drop budget.  if the new child has\n\t\t * a \"powered\" LED, users should notice we didn't enable it\n\t\t * (without reading syslog), even without per-port LEDs\n\t\t * on the parent.\n\t\t */\n\t\tif (udev->descriptor.bDeviceClass == USB_CLASS_HUB\n\t\t\t\t&& udev->bus_mA <= unit_load) {\n\t\t\tu16\tdevstat;\n\n\t\t\tstatus = usb_get_status(udev, USB_RECIP_DEVICE, 0,\n\t\t\t\t\t&devstat);\n\t\t\tif (status) {\n\t\t\t\tdev_dbg(&udev->dev, \"get status %d ?\\n\", status);\n\t\t\t\tgoto loop_disable;\n\t\t\t}\n\t\t\tif ((devstat & (1 << USB_DEVICE_SELF_POWERED)) == 0) {\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"can't connect bus-powered hub \"\n\t\t\t\t\t\"to this port\\n\");\n\t\t\t\tif (hub->has_indicators) {\n\t\t\t\t\thub->indicator[port1-1] =\n\t\t\t\t\t\tINDICATOR_AMBER_BLINK;\n\t\t\t\t\tqueue_delayed_work(\n\t\t\t\t\t\tsystem_power_efficient_wq,\n\t\t\t\t\t\t&hub->leds, 0);\n\t\t\t\t}\n\t\t\t\tstatus = -ENOTCONN;\t/* Don't retry */\n\t\t\t\tgoto loop_disable;\n\t\t\t}\n\t\t}\n\n\t\t/* check for devices running slower than they could */\n\t\tif (le16_to_cpu(udev->descriptor.bcdUSB) >= 0x0200\n\t\t\t\t&& udev->speed == USB_SPEED_FULL\n\t\t\t\t&& highspeed_hubs != 0)\n\t\t\tcheck_highspeed(hub, udev, port1);\n\n\t\t/* Store the parent's children[] pointer.  At this point\n\t\t * udev becomes globally accessible, although presumably\n\t\t * no one will look at it until hdev is unlocked.\n\t\t */\n\t\tstatus = 0;\n\n\t\tmutex_lock(&usb_port_peer_mutex);\n\n\t\t/* We mustn't add new devices if the parent hub has\n\t\t * been disconnected; we would race with the\n\t\t * recursively_mark_NOTATTACHED() routine.\n\t\t */\n\t\tspin_lock_irq(&device_state_lock);\n\t\tif (hdev->state == USB_STATE_NOTATTACHED)\n\t\t\tstatus = -ENOTCONN;\n\t\telse\n\t\t\tport_dev->child = udev;\n\t\tspin_unlock_irq(&device_state_lock);\n\t\tmutex_unlock(&usb_port_peer_mutex);\n\n\t\t/* Run it through the hoops (find a driver, etc) */\n\t\tif (!status) {\n\t\t\tstatus = usb_new_device(udev);\n\t\t\tif (status) {\n\t\t\t\tmutex_lock(&usb_port_peer_mutex);\n\t\t\t\tspin_lock_irq(&device_state_lock);\n\t\t\t\tport_dev->child = NULL;\n\t\t\t\tspin_unlock_irq(&device_state_lock);\n\t\t\t\tmutex_unlock(&usb_port_peer_mutex);\n\t\t\t} else {\n\t\t\t\tif (hcd->usb_phy && !hdev->parent)\n\t\t\t\t\tusb_phy_notify_connect(hcd->usb_phy,\n\t\t\t\t\t\t\tudev->speed);\n\t\t\t}\n\t\t}\n\n\t\tif (status)\n\t\t\tgoto loop_disable;\n\n\t\tstatus = hub_power_remaining(hub);\n\t\tif (status)\n\t\t\tdev_dbg(hub->intfdev, \"%dmA power budget left\\n\", status);\n\n\t\treturn;\n\nloop_disable:\n\t\thub_port_disable(hub, port1, 1);\nloop:\n\t\tusb_ep0_reinit(udev);\n\t\trelease_devnum(udev);\n\t\thub_free_dev(udev);\n\t\tusb_put_dev(udev);\n\t\tif ((status == -ENOTCONN) || (status == -ENOTSUPP))\n\t\t\tbreak;\n\t}\n\tif (hub->hdev->parent ||\n\t\t\t!hcd->driver->port_handed_over ||\n\t\t\t!(hcd->driver->port_handed_over)(hcd, port1)) {\n\t\tif (status != -ENOTCONN && status != -ENODEV)\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"unable to enumerate USB device\\n\");\n\t}\n\ndone:\n\thub_port_disable(hub, port1, 1);\n\tif (hcd->driver->relinquish_port && !hub->hdev->parent)\n\t\thcd->driver->relinquish_port(hcd, port1);\n\n}\n\n/* Handle physical or logical connection change events.\n * This routine is called when:\n *\ta port connection-change occurs;\n *\ta port enable-change occurs (often caused by EMI);\n *\tusb_reset_and_verify_device() encounters changed descriptors (as from\n *\t\ta firmware download)\n * caller already locked the hub\n */\nstatic void hub_port_connect_change(struct usb_hub *hub, int port1,\n\t\t\t\t\tu16 portstatus, u16 portchange)\n\t\t__must_hold(&port_dev->status_lock)\n{\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tstruct usb_device *udev = port_dev->child;\n\tint status = -ENODEV;\n\n\tdev_dbg(&port_dev->dev, \"status %04x, change %04x, %s\\n\", portstatus,\n\t\t\tportchange, portspeed(hub, portstatus));\n\n\tif (hub->has_indicators) {\n\t\tset_port_led(hub, port1, HUB_LED_AUTO);\n\t\thub->indicator[port1-1] = INDICATOR_AUTO;\n\t}\n\n#ifdef\tCONFIG_USB_OTG\n\t/* during HNP, don't repeat the debounce */\n\tif (hub->hdev->bus->is_b_host)\n\t\tportchange &= ~(USB_PORT_STAT_C_CONNECTION |\n\t\t\t\tUSB_PORT_STAT_C_ENABLE);\n#endif\n\n\t/* Try to resuscitate an existing device */\n\tif ((portstatus & USB_PORT_STAT_CONNECTION) && udev &&\n\t\t\tudev->state != USB_STATE_NOTATTACHED) {\n\t\tif (portstatus & USB_PORT_STAT_ENABLE) {\n\t\t\tstatus = 0;\t\t/* Nothing to do */\n#ifdef CONFIG_PM\n\t\t} else if (udev->state == USB_STATE_SUSPENDED &&\n\t\t\t\tudev->persist_enabled) {\n\t\t\t/* For a suspended device, treat this as a\n\t\t\t * remote wakeup event.\n\t\t\t */\n\t\t\tusb_unlock_port(port_dev);\n\t\t\tstatus = usb_remote_wakeup(udev);\n\t\t\tusb_lock_port(port_dev);\n#endif\n\t\t} else {\n\t\t\t/* Don't resuscitate */;\n\t\t}\n\t}\n\tclear_bit(port1, hub->change_bits);\n\n\t/* successfully revalidated the connection */\n\tif (status == 0)\n\t\treturn;\n\n\tusb_unlock_port(port_dev);\n\thub_port_connect(hub, port1, portstatus, portchange);\n\tusb_lock_port(port_dev);\n}\n\nstatic void port_event(struct usb_hub *hub, int port1)\n\t\t__must_hold(&port_dev->status_lock)\n{\n\tint connect_change;\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tstruct usb_device *udev = port_dev->child;\n\tstruct usb_device *hdev = hub->hdev;\n\tu16 portstatus, portchange;\n\n\tconnect_change = test_bit(port1, hub->change_bits);\n\tclear_bit(port1, hub->event_bits);\n\tclear_bit(port1, hub->wakeup_bits);\n\n\tif (hub_port_status(hub, port1, &portstatus, &portchange) < 0)\n\t\treturn;\n\n\tif (portchange & USB_PORT_STAT_C_CONNECTION) {\n\t\tusb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_CONNECTION);\n\t\tconnect_change = 1;\n\t}\n\n\tif (portchange & USB_PORT_STAT_C_ENABLE) {\n\t\tif (!connect_change)\n\t\t\tdev_dbg(&port_dev->dev, \"enable change, status %08x\\n\",\n\t\t\t\t\tportstatus);\n\t\tusb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_ENABLE);\n\n\t\t/*\n\t\t * EM interference sometimes causes badly shielded USB devices\n\t\t * to be shutdown by the hub, this hack enables them again.\n\t\t * Works at least with mouse driver.\n\t\t */\n\t\tif (!(portstatus & USB_PORT_STAT_ENABLE)\n\t\t    && !connect_change && udev) {\n\t\t\tdev_err(&port_dev->dev, \"disabled by hub (EMI?), re-enabling...\\n\");\n\t\t\tconnect_change = 1;\n\t\t}\n\t}\n\n\tif (portchange & USB_PORT_STAT_C_OVERCURRENT) {\n\t\tu16 status = 0, unused;\n\n\t\tdev_dbg(&port_dev->dev, \"over-current change\\n\");\n\t\tusb_clear_port_feature(hdev, port1,\n\t\t\t\tUSB_PORT_FEAT_C_OVER_CURRENT);\n\t\tmsleep(100);\t/* Cool down */\n\t\thub_power_on(hub, true);\n\t\thub_port_status(hub, port1, &status, &unused);\n\t\tif (status & USB_PORT_STAT_OVERCURRENT)\n\t\t\tdev_err(&port_dev->dev, \"over-current condition\\n\");\n\t}\n\n\tif (portchange & USB_PORT_STAT_C_RESET) {\n\t\tdev_dbg(&port_dev->dev, \"reset change\\n\");\n\t\tusb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_RESET);\n\t}\n\tif ((portchange & USB_PORT_STAT_C_BH_RESET)\n\t    && hub_is_superspeed(hdev)) {\n\t\tdev_dbg(&port_dev->dev, \"warm reset change\\n\");\n\t\tusb_clear_port_feature(hdev, port1,\n\t\t\t\tUSB_PORT_FEAT_C_BH_PORT_RESET);\n\t}\n\tif (portchange & USB_PORT_STAT_C_LINK_STATE) {\n\t\tdev_dbg(&port_dev->dev, \"link state change\\n\");\n\t\tusb_clear_port_feature(hdev, port1,\n\t\t\t\tUSB_PORT_FEAT_C_PORT_LINK_STATE);\n\t}\n\tif (portchange & USB_PORT_STAT_C_CONFIG_ERROR) {\n\t\tdev_warn(&port_dev->dev, \"config error\\n\");\n\t\tusb_clear_port_feature(hdev, port1,\n\t\t\t\tUSB_PORT_FEAT_C_PORT_CONFIG_ERROR);\n\t}\n\n\t/* skip port actions that require the port to be powered on */\n\tif (!pm_runtime_active(&port_dev->dev))\n\t\treturn;\n\n\tif (hub_handle_remote_wakeup(hub, port1, portstatus, portchange))\n\t\tconnect_change = 1;\n\n\t/*\n\t * Warm reset a USB3 protocol port if it's in\n\t * SS.Inactive state.\n\t */\n\tif (hub_port_warm_reset_required(hub, port1, portstatus)) {\n\t\tdev_dbg(&port_dev->dev, \"do warm reset\\n\");\n\t\tif (!udev || !(portstatus & USB_PORT_STAT_CONNECTION)\n\t\t\t\t|| udev->state == USB_STATE_NOTATTACHED) {\n\t\t\tif (hub_port_reset(hub, port1, NULL,\n\t\t\t\t\tHUB_BH_RESET_TIME, true) < 0)\n\t\t\t\thub_port_disable(hub, port1, 1);\n\t\t} else {\n\t\t\tusb_unlock_port(port_dev);\n\t\t\tusb_lock_device(udev);\n\t\t\tusb_reset_device(udev);\n\t\t\tusb_unlock_device(udev);\n\t\t\tusb_lock_port(port_dev);\n\t\t\tconnect_change = 0;\n\t\t}\n\t}\n\n\tif (connect_change)\n\t\thub_port_connect_change(hub, port1, portstatus, portchange);\n}\n\nstatic void hub_event(struct work_struct *work)\n{\n\tstruct usb_device *hdev;\n\tstruct usb_interface *intf;\n\tstruct usb_hub *hub;\n\tstruct device *hub_dev;\n\tu16 hubstatus;\n\tu16 hubchange;\n\tint i, ret;\n\n\thub = container_of(work, struct usb_hub, events);\n\thdev = hub->hdev;\n\thub_dev = hub->intfdev;\n\tintf = to_usb_interface(hub_dev);\n\n\tdev_dbg(hub_dev, \"state %d ports %d chg %04x evt %04x\\n\",\n\t\t\thdev->state, hdev->maxchild,\n\t\t\t/* NOTE: expects max 15 ports... */\n\t\t\t(u16) hub->change_bits[0],\n\t\t\t(u16) hub->event_bits[0]);\n\n\t/* Lock the device, then check to see if we were\n\t * disconnected while waiting for the lock to succeed. */\n\tusb_lock_device(hdev);\n\tif (unlikely(hub->disconnected))\n\t\tgoto out_hdev_lock;\n\n\t/* If the hub has died, clean up after it */\n\tif (hdev->state == USB_STATE_NOTATTACHED) {\n\t\thub->error = -ENODEV;\n\t\thub_quiesce(hub, HUB_DISCONNECT);\n\t\tgoto out_hdev_lock;\n\t}\n\n\t/* Autoresume */\n\tret = usb_autopm_get_interface(intf);\n\tif (ret) {\n\t\tdev_dbg(hub_dev, \"Can't autoresume: %d\\n\", ret);\n\t\tgoto out_hdev_lock;\n\t}\n\n\t/* If this is an inactive hub, do nothing */\n\tif (hub->quiescing)\n\t\tgoto out_autopm;\n\n\tif (hub->error) {\n\t\tdev_dbg(hub_dev, \"resetting for error %d\\n\", hub->error);\n\n\t\tret = usb_reset_device(hdev);\n\t\tif (ret) {\n\t\t\tdev_dbg(hub_dev, \"error resetting hub: %d\\n\", ret);\n\t\t\tgoto out_autopm;\n\t\t}\n\n\t\thub->nerrors = 0;\n\t\thub->error = 0;\n\t}\n\n\t/* deal with port status changes */\n\tfor (i = 1; i <= hdev->maxchild; i++) {\n\t\tstruct usb_port *port_dev = hub->ports[i - 1];\n\n\t\tif (test_bit(i, hub->event_bits)\n\t\t\t\t|| test_bit(i, hub->change_bits)\n\t\t\t\t|| test_bit(i, hub->wakeup_bits)) {\n\t\t\t/*\n\t\t\t * The get_noresume and barrier ensure that if\n\t\t\t * the port was in the process of resuming, we\n\t\t\t * flush that work and keep the port active for\n\t\t\t * the duration of the port_event().  However,\n\t\t\t * if the port is runtime pm suspended\n\t\t\t * (powered-off), we leave it in that state, run\n\t\t\t * an abbreviated port_event(), and move on.\n\t\t\t */\n\t\t\tpm_runtime_get_noresume(&port_dev->dev);\n\t\t\tpm_runtime_barrier(&port_dev->dev);\n\t\t\tusb_lock_port(port_dev);\n\t\t\tport_event(hub, i);\n\t\t\tusb_unlock_port(port_dev);\n\t\t\tpm_runtime_put_sync(&port_dev->dev);\n\t\t}\n\t}\n\n\t/* deal with hub status changes */\n\tif (test_and_clear_bit(0, hub->event_bits) == 0)\n\t\t;\t/* do nothing */\n\telse if (hub_hub_status(hub, &hubstatus, &hubchange) < 0)\n\t\tdev_err(hub_dev, \"get_hub_status failed\\n\");\n\telse {\n\t\tif (hubchange & HUB_CHANGE_LOCAL_POWER) {\n\t\t\tdev_dbg(hub_dev, \"power change\\n\");\n\t\t\tclear_hub_feature(hdev, C_HUB_LOCAL_POWER);\n\t\t\tif (hubstatus & HUB_STATUS_LOCAL_POWER)\n\t\t\t\t/* FIXME: Is this always true? */\n\t\t\t\thub->limited_power = 1;\n\t\t\telse\n\t\t\t\thub->limited_power = 0;\n\t\t}\n\t\tif (hubchange & HUB_CHANGE_OVERCURRENT) {\n\t\t\tu16 status = 0;\n\t\t\tu16 unused;\n\n\t\t\tdev_dbg(hub_dev, \"over-current change\\n\");\n\t\t\tclear_hub_feature(hdev, C_HUB_OVER_CURRENT);\n\t\t\tmsleep(500);\t/* Cool down */\n\t\t\thub_power_on(hub, true);\n\t\t\thub_hub_status(hub, &status, &unused);\n\t\t\tif (status & HUB_STATUS_OVERCURRENT)\n\t\t\t\tdev_err(hub_dev, \"over-current condition\\n\");\n\t\t}\n\t}\n\nout_autopm:\n\t/* Balance the usb_autopm_get_interface() above */\n\tusb_autopm_put_interface_no_suspend(intf);\nout_hdev_lock:\n\tusb_unlock_device(hdev);\n\n\t/* Balance the stuff in kick_hub_wq() and allow autosuspend */\n\tusb_autopm_put_interface(intf);\n\tkref_put(&hub->kref, hub_release);\n}\n\nstatic const struct usb_device_id hub_id_table[] = {\n    { .match_flags = USB_DEVICE_ID_MATCH_VENDOR\n\t\t\t| USB_DEVICE_ID_MATCH_INT_CLASS,\n      .idVendor = USB_VENDOR_GENESYS_LOGIC,\n      .bInterfaceClass = USB_CLASS_HUB,\n      .driver_info = HUB_QUIRK_CHECK_PORT_AUTOSUSPEND},\n    { .match_flags = USB_DEVICE_ID_MATCH_DEV_CLASS,\n      .bDeviceClass = USB_CLASS_HUB},\n    { .match_flags = USB_DEVICE_ID_MATCH_INT_CLASS,\n      .bInterfaceClass = USB_CLASS_HUB},\n    { }\t\t\t\t\t\t/* Terminating entry */\n};\n\nMODULE_DEVICE_TABLE(usb, hub_id_table);\n\nstatic struct usb_driver hub_driver = {\n\t.name =\t\t\"hub\",\n\t.probe =\thub_probe,\n\t.disconnect =\thub_disconnect,\n\t.suspend =\thub_suspend,\n\t.resume =\thub_resume,\n\t.reset_resume =\thub_reset_resume,\n\t.pre_reset =\thub_pre_reset,\n\t.post_reset =\thub_post_reset,\n\t.unlocked_ioctl = hub_ioctl,\n\t.id_table =\thub_id_table,\n\t.supports_autosuspend =\t1,\n};\n\nint usb_hub_init(void)\n{\n\tif (usb_register(&hub_driver) < 0) {\n\t\tprintk(KERN_ERR \"%s: can't register hub driver\\n\",\n\t\t\tusbcore_name);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * The workqueue needs to be freezable to avoid interfering with\n\t * USB-PERSIST port handover. Otherwise it might see that a full-speed\n\t * device was gone before the EHCI controller had handed its port\n\t * over to the companion full-speed controller.\n\t */\n\thub_wq = alloc_workqueue(\"usb_hub_wq\", WQ_FREEZABLE, 0);\n\tif (hub_wq)\n\t\treturn 0;\n\n\t/* Fall through if kernel_thread failed */\n\tusb_deregister(&hub_driver);\n\tpr_err(\"%s: can't allocate workqueue for usb hub\\n\", usbcore_name);\n\n\treturn -1;\n}\n\nvoid usb_hub_cleanup(void)\n{\n\tdestroy_workqueue(hub_wq);\n\n\t/*\n\t * Hub resources are freed for us by usb_deregister. It calls\n\t * usb_driver_purge on every device which in turn calls that\n\t * devices disconnect function if it is using this driver.\n\t * The hub_disconnect function takes care of releasing the\n\t * individual hub resources. -greg\n\t */\n\tusb_deregister(&hub_driver);\n} /* usb_hub_cleanup() */\n\nstatic int descriptors_changed(struct usb_device *udev,\n\t\tstruct usb_device_descriptor *old_device_descriptor,\n\t\tstruct usb_host_bos *old_bos)\n{\n\tint\t\tchanged = 0;\n\tunsigned\tindex;\n\tunsigned\tserial_len = 0;\n\tunsigned\tlen;\n\tunsigned\told_length;\n\tint\t\tlength;\n\tchar\t\t*buf;\n\n\tif (memcmp(&udev->descriptor, old_device_descriptor,\n\t\t\tsizeof(*old_device_descriptor)) != 0)\n\t\treturn 1;\n\n\tif ((old_bos && !udev->bos) || (!old_bos && udev->bos))\n\t\treturn 1;\n\tif (udev->bos) {\n\t\tlen = le16_to_cpu(udev->bos->desc->wTotalLength);\n\t\tif (len != le16_to_cpu(old_bos->desc->wTotalLength))\n\t\t\treturn 1;\n\t\tif (memcmp(udev->bos->desc, old_bos->desc, len))\n\t\t\treturn 1;\n\t}\n\n\t/* Since the idVendor, idProduct, and bcdDevice values in the\n\t * device descriptor haven't changed, we will assume the\n\t * Manufacturer and Product strings haven't changed either.\n\t * But the SerialNumber string could be different (e.g., a\n\t * different flash card of the same brand).\n\t */\n\tif (udev->serial)\n\t\tserial_len = strlen(udev->serial) + 1;\n\n\tlen = serial_len;\n\tfor (index = 0; index < udev->descriptor.bNumConfigurations; index++) {\n\t\told_length = le16_to_cpu(udev->config[index].desc.wTotalLength);\n\t\tlen = max(len, old_length);\n\t}\n\n\tbuf = kmalloc(len, GFP_NOIO);\n\tif (buf == NULL) {\n\t\tdev_err(&udev->dev, \"no mem to re-read configs after reset\\n\");\n\t\t/* assume the worst */\n\t\treturn 1;\n\t}\n\tfor (index = 0; index < udev->descriptor.bNumConfigurations; index++) {\n\t\told_length = le16_to_cpu(udev->config[index].desc.wTotalLength);\n\t\tlength = usb_get_descriptor(udev, USB_DT_CONFIG, index, buf,\n\t\t\t\told_length);\n\t\tif (length != old_length) {\n\t\t\tdev_dbg(&udev->dev, \"config index %d, error %d\\n\",\n\t\t\t\t\tindex, length);\n\t\t\tchanged = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (memcmp(buf, udev->rawdescriptors[index], old_length)\n\t\t\t\t!= 0) {\n\t\t\tdev_dbg(&udev->dev, \"config index %d changed (#%d)\\n\",\n\t\t\t\tindex,\n\t\t\t\t((struct usb_config_descriptor *) buf)->\n\t\t\t\t\tbConfigurationValue);\n\t\t\tchanged = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!changed && serial_len) {\n\t\tlength = usb_string(udev, udev->descriptor.iSerialNumber,\n\t\t\t\tbuf, serial_len);\n\t\tif (length + 1 != serial_len) {\n\t\t\tdev_dbg(&udev->dev, \"serial string error %d\\n\",\n\t\t\t\t\tlength);\n\t\t\tchanged = 1;\n\t\t} else if (memcmp(buf, udev->serial, length) != 0) {\n\t\t\tdev_dbg(&udev->dev, \"serial string changed\\n\");\n\t\t\tchanged = 1;\n\t\t}\n\t}\n\n\tkfree(buf);\n\treturn changed;\n}\n\n/**\n * usb_reset_and_verify_device - perform a USB port reset to reinitialize a device\n * @udev: device to reset (not in SUSPENDED or NOTATTACHED state)\n *\n * WARNING - don't use this routine to reset a composite device\n * (one with multiple interfaces owned by separate drivers)!\n * Use usb_reset_device() instead.\n *\n * Do a port reset, reassign the device's address, and establish its\n * former operating configuration.  If the reset fails, or the device's\n * descriptors change from their values before the reset, or the original\n * configuration and altsettings cannot be restored, a flag will be set\n * telling hub_wq to pretend the device has been disconnected and then\n * re-connected.  All drivers will be unbound, and the device will be\n * re-enumerated and probed all over again.\n *\n * Return: 0 if the reset succeeded, -ENODEV if the device has been\n * flagged for logical disconnection, or some other negative error code\n * if the reset wasn't even attempted.\n *\n * Note:\n * The caller must own the device lock and the port lock, the latter is\n * taken by usb_reset_device().  For example, it's safe to use\n * usb_reset_device() from a driver probe() routine after downloading\n * new firmware.  For calls that might not occur during probe(), drivers\n * should lock the device using usb_lock_device_for_reset().\n *\n * Locking exception: This routine may also be called from within an\n * autoresume handler.  Such usage won't conflict with other tasks\n * holding the device lock because these tasks should always call\n * usb_autopm_resume_device(), thereby preventing any unwanted\n * autoresume.  The autoresume handler is expected to have already\n * acquired the port lock before calling this routine.\n */\nstatic int usb_reset_and_verify_device(struct usb_device *udev)\n{\n\tstruct usb_device\t\t*parent_hdev = udev->parent;\n\tstruct usb_hub\t\t\t*parent_hub;\n\tstruct usb_hcd\t\t\t*hcd = bus_to_hcd(udev->bus);\n\tstruct usb_device_descriptor\tdescriptor = udev->descriptor;\n\tstruct usb_host_bos\t\t*bos;\n\tint\t\t\t\ti, j, ret = 0;\n\tint\t\t\t\tport1 = udev->portnum;\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!parent_hdev)\n\t\treturn -EISDIR;\n\n\tparent_hub = usb_hub_to_struct_hub(parent_hdev);\n\n\t/* Disable USB2 hardware LPM.\n\t * It will be re-enabled by the enumeration process.\n\t */\n\tif (udev->usb2_hw_lpm_enabled == 1)\n\t\tusb_set_usb2_hardware_lpm(udev, 0);\n\n\t/* Disable LPM and LTM while we reset the device and reinstall the alt\n\t * settings.  Device-initiated LPM settings, and system exit latency\n\t * settings are cleared when the device is reset, so we have to set\n\t * them up again.\n\t */\n\tret = usb_unlocked_disable_lpm(udev);\n\tif (ret) {\n\t\tdev_err(&udev->dev, \"%s Failed to disable LPM\\n.\", __func__);\n\t\tgoto re_enumerate_no_bos;\n\t}\n\tret = usb_disable_ltm(udev);\n\tif (ret) {\n\t\tdev_err(&udev->dev, \"%s Failed to disable LTM\\n.\",\n\t\t\t\t__func__);\n\t\tgoto re_enumerate_no_bos;\n\t}\n\n\tbos = udev->bos;\n\tudev->bos = NULL;\n\n\tfor (i = 0; i < SET_CONFIG_TRIES; ++i) {\n\n\t\t/* ep0 maxpacket size may change; let the HCD know about it.\n\t\t * Other endpoints will be handled by re-enumeration. */\n\t\tusb_ep0_reinit(udev);\n\t\tret = hub_port_init(parent_hub, udev, port1, i);\n\t\tif (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)\n\t\t\tbreak;\n\t}\n\n\tif (ret < 0)\n\t\tgoto re_enumerate;\n\n\t/* Device might have changed firmware (DFU or similar) */\n\tif (descriptors_changed(udev, &descriptor, bos)) {\n\t\tdev_info(&udev->dev, \"device firmware changed\\n\");\n\t\tudev->descriptor = descriptor;\t/* for disconnect() calls */\n\t\tgoto re_enumerate;\n\t}\n\n\t/* Restore the device's previous configuration */\n\tif (!udev->actconfig)\n\t\tgoto done;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_hcd_alloc_bandwidth(udev, udev->actconfig, NULL, NULL);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\t\"Busted HC?  Not enough HCD resources for \"\n\t\t\t\t\"old configuration.\\n\");\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION, 0,\n\t\t\tudev->actconfig->desc.bConfigurationValue, 0,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"can't restore configuration #%d (error=%d)\\n\",\n\t\t\tudev->actconfig->desc.bConfigurationValue, ret);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\tusb_set_device_state(udev, USB_STATE_CONFIGURED);\n\n\t/* Put interfaces back into the same altsettings as before.\n\t * Don't bother to send the Set-Interface request for interfaces\n\t * that were already in altsetting 0; besides being unnecessary,\n\t * many devices can't handle it.  Instead just reset the host-side\n\t * endpoint state.\n\t */\n\tfor (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {\n\t\tstruct usb_host_config *config = udev->actconfig;\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_interface_descriptor *desc;\n\n\t\tdesc = &intf->cur_altsetting->desc;\n\t\tif (desc->bAlternateSetting == 0) {\n\t\t\tusb_disable_interface(udev, intf, true);\n\t\t\tusb_enable_interface(udev, intf, true);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/* Let the bandwidth allocation function know that this\n\t\t\t * device has been reset, and it will have to use\n\t\t\t * alternate setting 0 as the current alternate setting.\n\t\t\t */\n\t\t\tintf->resetting_device = 1;\n\t\t\tret = usb_set_interface(udev, desc->bInterfaceNumber,\n\t\t\t\t\tdesc->bAlternateSetting);\n\t\t\tintf->resetting_device = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(&udev->dev, \"failed to restore interface %d \"\n\t\t\t\t\"altsetting %d (error=%d)\\n\",\n\t\t\t\tdesc->bInterfaceNumber,\n\t\t\t\tdesc->bAlternateSetting,\n\t\t\t\tret);\n\t\t\tgoto re_enumerate;\n\t\t}\n\t\t/* Resetting also frees any allocated streams */\n\t\tfor (j = 0; j < intf->cur_altsetting->desc.bNumEndpoints; j++)\n\t\t\tintf->cur_altsetting->endpoint[j].streams = 0;\n\t}\n\ndone:\n\t/* Now that the alt settings are re-installed, enable LTM and LPM. */\n\tusb_set_usb2_hardware_lpm(udev, 1);\n\tusb_unlocked_enable_lpm(udev);\n\tusb_enable_ltm(udev);\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\treturn 0;\n\nre_enumerate:\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\nre_enumerate_no_bos:\n\t/* LPM state doesn't matter when we're about to destroy the device. */\n\thub_port_logical_disconnect(parent_hub, port1);\n\treturn -ENODEV;\n}\n\n/**\n * usb_reset_device - warn interface drivers and perform a USB port reset\n * @udev: device to reset (not in SUSPENDED or NOTATTACHED state)\n *\n * Warns all drivers bound to registered interfaces (using their pre_reset\n * method), performs the port reset, and then lets the drivers know that\n * the reset is over (using their post_reset method).\n *\n * Return: The same as for usb_reset_and_verify_device().\n *\n * Note:\n * The caller must own the device lock.  For example, it's safe to use\n * this from a driver probe() routine after downloading new firmware.\n * For calls that might not occur during probe(), drivers should lock\n * the device using usb_lock_device_for_reset().\n *\n * If an interface is currently being probed or disconnected, we assume\n * its driver knows how to handle resets.  For all other interfaces,\n * if the driver doesn't have pre_reset and post_reset methods then\n * we attempt to unbind it and rebind afterward.\n */\nint usb_reset_device(struct usb_device *udev)\n{\n\tint ret;\n\tint i;\n\tunsigned int noio_flag;\n\tstruct usb_port *port_dev;\n\tstruct usb_host_config *config = udev->actconfig;\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(udev->parent);\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!udev->parent) {\n\t\t/* this requires hcd-specific logic; see ohci_restart() */\n\t\tdev_dbg(&udev->dev, \"%s for root hub!\\n\", __func__);\n\t\treturn -EISDIR;\n\t}\n\n\tport_dev = hub->ports[udev->portnum - 1];\n\n\t/*\n\t * Don't allocate memory with GFP_KERNEL in current\n\t * context to avoid possible deadlock if usb mass\n\t * storage interface or usbnet interface(iSCSI case)\n\t * is included in current configuration. The easist\n\t * approach is to do it for every device reset,\n\t * because the device 'memalloc_noio' flag may have\n\t * not been set before reseting the usb device.\n\t */\n\tnoio_flag = memalloc_noio_save();\n\n\t/* Prevent autosuspend during the reset */\n\tusb_autoresume_device(udev);\n\n\tif (config) {\n\t\tfor (i = 0; i < config->desc.bNumInterfaces; ++i) {\n\t\t\tstruct usb_interface *cintf = config->interface[i];\n\t\t\tstruct usb_driver *drv;\n\t\t\tint unbind = 0;\n\n\t\t\tif (cintf->dev.driver) {\n\t\t\t\tdrv = to_usb_driver(cintf->dev.driver);\n\t\t\t\tif (drv->pre_reset && drv->post_reset)\n\t\t\t\t\tunbind = (drv->pre_reset)(cintf);\n\t\t\t\telse if (cintf->condition ==\n\t\t\t\t\t\tUSB_INTERFACE_BOUND)\n\t\t\t\t\tunbind = 1;\n\t\t\t\tif (unbind)\n\t\t\t\t\tusb_forced_unbind_intf(cintf);\n\t\t\t}\n\t\t}\n\t}\n\n\tusb_lock_port(port_dev);\n\tret = usb_reset_and_verify_device(udev);\n\tusb_unlock_port(port_dev);\n\n\tif (config) {\n\t\tfor (i = config->desc.bNumInterfaces - 1; i >= 0; --i) {\n\t\t\tstruct usb_interface *cintf = config->interface[i];\n\t\t\tstruct usb_driver *drv;\n\t\t\tint rebind = cintf->needs_binding;\n\n\t\t\tif (!rebind && cintf->dev.driver) {\n\t\t\t\tdrv = to_usb_driver(cintf->dev.driver);\n\t\t\t\tif (drv->post_reset)\n\t\t\t\t\trebind = (drv->post_reset)(cintf);\n\t\t\t\telse if (cintf->condition ==\n\t\t\t\t\t\tUSB_INTERFACE_BOUND)\n\t\t\t\t\trebind = 1;\n\t\t\t\tif (rebind)\n\t\t\t\t\tcintf->needs_binding = 1;\n\t\t\t}\n\t\t}\n\t\tusb_unbind_and_rebind_marked_interfaces(udev);\n\t}\n\n\tusb_autosuspend_device(udev);\n\tmemalloc_noio_restore(noio_flag);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_reset_device);\n\n\n/**\n * usb_queue_reset_device - Reset a USB device from an atomic context\n * @iface: USB interface belonging to the device to reset\n *\n * This function can be used to reset a USB device from an atomic\n * context, where usb_reset_device() won't work (as it blocks).\n *\n * Doing a reset via this method is functionally equivalent to calling\n * usb_reset_device(), except for the fact that it is delayed to a\n * workqueue. This means that any drivers bound to other interfaces\n * might be unbound, as well as users from usbfs in user space.\n *\n * Corner cases:\n *\n * - Scheduling two resets at the same time from two different drivers\n *   attached to two different interfaces of the same device is\n *   possible; depending on how the driver attached to each interface\n *   handles ->pre_reset(), the second reset might happen or not.\n *\n * - If the reset is delayed so long that the interface is unbound from\n *   its driver, the reset will be skipped.\n *\n * - This function can be called during .probe().  It can also be called\n *   during .disconnect(), but doing so is pointless because the reset\n *   will not occur.  If you really want to reset the device during\n *   .disconnect(), call usb_reset_device() directly -- but watch out\n *   for nested unbinding issues!\n */\nvoid usb_queue_reset_device(struct usb_interface *iface)\n{\n\tif (schedule_work(&iface->reset_ws))\n\t\tusb_get_intf(iface);\n}\nEXPORT_SYMBOL_GPL(usb_queue_reset_device);\n\n/**\n * usb_hub_find_child - Get the pointer of child device\n * attached to the port which is specified by @port1.\n * @hdev: USB device belonging to the usb hub\n * @port1: port num to indicate which port the child device\n *\tis attached to.\n *\n * USB drivers call this function to get hub's child device\n * pointer.\n *\n * Return: %NULL if input param is invalid and\n * child's usb_device pointer if non-NULL.\n */\nstruct usb_device *usb_hub_find_child(struct usb_device *hdev,\n\t\tint port1)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\n\tif (port1 < 1 || port1 > hdev->maxchild)\n\t\treturn NULL;\n\treturn hub->ports[port1 - 1]->child;\n}\nEXPORT_SYMBOL_GPL(usb_hub_find_child);\n\nvoid usb_hub_adjust_deviceremovable(struct usb_device *hdev,\n\t\tstruct usb_hub_descriptor *desc)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\tenum usb_port_connect_type connect_type;\n\tint i;\n\n\tif (!hub)\n\t\treturn;\n\n\tif (!hub_is_superspeed(hdev)) {\n\t\tfor (i = 1; i <= hdev->maxchild; i++) {\n\t\t\tstruct usb_port *port_dev = hub->ports[i - 1];\n\n\t\t\tconnect_type = port_dev->connect_type;\n\t\t\tif (connect_type == USB_PORT_CONNECT_TYPE_HARD_WIRED) {\n\t\t\t\tu8 mask = 1 << (i%8);\n\n\t\t\t\tif (!(desc->u.hs.DeviceRemovable[i/8] & mask)) {\n\t\t\t\t\tdev_dbg(&port_dev->dev, \"DeviceRemovable is changed to 1 according to platform information.\\n\");\n\t\t\t\t\tdesc->u.hs.DeviceRemovable[i/8]\t|= mask;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tu16 port_removable = le16_to_cpu(desc->u.ss.DeviceRemovable);\n\n\t\tfor (i = 1; i <= hdev->maxchild; i++) {\n\t\t\tstruct usb_port *port_dev = hub->ports[i - 1];\n\n\t\t\tconnect_type = port_dev->connect_type;\n\t\t\tif (connect_type == USB_PORT_CONNECT_TYPE_HARD_WIRED) {\n\t\t\t\tu16 mask = 1 << i;\n\n\t\t\t\tif (!(port_removable & mask)) {\n\t\t\t\t\tdev_dbg(&port_dev->dev, \"DeviceRemovable is changed to 1 according to platform information.\\n\");\n\t\t\t\t\tport_removable |= mask;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdesc->u.ss.DeviceRemovable = cpu_to_le16(port_removable);\n\t}\n}\n\n#ifdef CONFIG_ACPI\n/**\n * usb_get_hub_port_acpi_handle - Get the usb port's acpi handle\n * @hdev: USB device belonging to the usb hub\n * @port1: port num of the port\n *\n * Return: Port's acpi handle if successful, %NULL if params are\n * invalid.\n */\nacpi_handle usb_get_hub_port_acpi_handle(struct usb_device *hdev,\n\tint port1)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\n\tif (!hub)\n\t\treturn NULL;\n\n\treturn ACPI_HANDLE(&hub->ports[port1 - 1]->dev);\n}\n#endif\n"], "fixing_code": ["/*\n * USB hub driver.\n *\n * (C) Copyright 1999 Linus Torvalds\n * (C) Copyright 1999 Johannes Erdfelt\n * (C) Copyright 1999 Gregory P. Smith\n * (C) Copyright 2001 Brad Hards (bhards@bigpond.net.au)\n *\n */\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/sched.h>\n#include <linux/list.h>\n#include <linux/slab.h>\n#include <linux/ioctl.h>\n#include <linux/usb.h>\n#include <linux/usbdevice_fs.h>\n#include <linux/usb/hcd.h>\n#include <linux/usb/otg.h>\n#include <linux/usb/quirks.h>\n#include <linux/workqueue.h>\n#include <linux/mutex.h>\n#include <linux/random.h>\n#include <linux/pm_qos.h>\n\n#include <asm/uaccess.h>\n#include <asm/byteorder.h>\n\n#include \"hub.h\"\n#include \"otg_whitelist.h\"\n\n#define USB_VENDOR_GENESYS_LOGIC\t\t0x05e3\n#define HUB_QUIRK_CHECK_PORT_AUTOSUSPEND\t0x01\n\n/* Protect struct usb_device->state and ->children members\n * Note: Both are also protected by ->dev.sem, except that ->state can\n * change to USB_STATE_NOTATTACHED even when the semaphore isn't held. */\nstatic DEFINE_SPINLOCK(device_state_lock);\n\n/* workqueue to process hub events */\nstatic struct workqueue_struct *hub_wq;\nstatic void hub_event(struct work_struct *work);\n\n/* synchronize hub-port add/remove and peering operations */\nDEFINE_MUTEX(usb_port_peer_mutex);\n\n/* cycle leds on hubs that aren't blinking for attention */\nstatic bool blinkenlights = 0;\nmodule_param(blinkenlights, bool, S_IRUGO);\nMODULE_PARM_DESC(blinkenlights, \"true to cycle leds on hubs\");\n\n/*\n * Device SATA8000 FW1.0 from DATAST0R Technology Corp requires about\n * 10 seconds to send reply for the initial 64-byte descriptor request.\n */\n/* define initial 64-byte descriptor request timeout in milliseconds */\nstatic int initial_descriptor_timeout = USB_CTRL_GET_TIMEOUT;\nmodule_param(initial_descriptor_timeout, int, S_IRUGO|S_IWUSR);\nMODULE_PARM_DESC(initial_descriptor_timeout,\n\t\t\"initial 64-byte descriptor request timeout in milliseconds \"\n\t\t\"(default 5000 - 5.0 seconds)\");\n\n/*\n * As of 2.6.10 we introduce a new USB device initialization scheme which\n * closely resembles the way Windows works.  Hopefully it will be compatible\n * with a wider range of devices than the old scheme.  However some previously\n * working devices may start giving rise to \"device not accepting address\"\n * errors; if that happens the user can try the old scheme by adjusting the\n * following module parameters.\n *\n * For maximum flexibility there are two boolean parameters to control the\n * hub driver's behavior.  On the first initialization attempt, if the\n * \"old_scheme_first\" parameter is set then the old scheme will be used,\n * otherwise the new scheme is used.  If that fails and \"use_both_schemes\"\n * is set, then the driver will make another attempt, using the other scheme.\n */\nstatic bool old_scheme_first = 0;\nmodule_param(old_scheme_first, bool, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(old_scheme_first,\n\t\t \"start with the old device initialization scheme\");\n\nstatic bool use_both_schemes = 1;\nmodule_param(use_both_schemes, bool, S_IRUGO | S_IWUSR);\nMODULE_PARM_DESC(use_both_schemes,\n\t\t\"try the other device initialization scheme if the \"\n\t\t\"first one fails\");\n\n/* Mutual exclusion for EHCI CF initialization.  This interferes with\n * port reset on some companion controllers.\n */\nDECLARE_RWSEM(ehci_cf_port_reset_rwsem);\nEXPORT_SYMBOL_GPL(ehci_cf_port_reset_rwsem);\n\n#define HUB_DEBOUNCE_TIMEOUT\t2000\n#define HUB_DEBOUNCE_STEP\t  25\n#define HUB_DEBOUNCE_STABLE\t 100\n\nstatic void hub_release(struct kref *kref);\nstatic int usb_reset_and_verify_device(struct usb_device *udev);\n\nstatic inline char *portspeed(struct usb_hub *hub, int portstatus)\n{\n\tif (hub_is_superspeed(hub->hdev))\n\t\treturn \"5.0 Gb/s\";\n\tif (portstatus & USB_PORT_STAT_HIGH_SPEED)\n\t\treturn \"480 Mb/s\";\n\telse if (portstatus & USB_PORT_STAT_LOW_SPEED)\n\t\treturn \"1.5 Mb/s\";\n\telse\n\t\treturn \"12 Mb/s\";\n}\n\n/* Note that hdev or one of its children must be locked! */\nstruct usb_hub *usb_hub_to_struct_hub(struct usb_device *hdev)\n{\n\tif (!hdev || !hdev->actconfig || !hdev->maxchild)\n\t\treturn NULL;\n\treturn usb_get_intfdata(hdev->actconfig->interface[0]);\n}\n\nint usb_device_supports_lpm(struct usb_device *udev)\n{\n\t/* Some devices have trouble with LPM */\n\tif (udev->quirks & USB_QUIRK_NO_LPM)\n\t\treturn 0;\n\n\t/* USB 2.1 (and greater) devices indicate LPM support through\n\t * their USB 2.0 Extended Capabilities BOS descriptor.\n\t */\n\tif (udev->speed == USB_SPEED_HIGH || udev->speed == USB_SPEED_FULL) {\n\t\tif (udev->bos->ext_cap &&\n\t\t\t(USB_LPM_SUPPORT &\n\t\t\t le32_to_cpu(udev->bos->ext_cap->bmAttributes)))\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * According to the USB 3.0 spec, all USB 3.0 devices must support LPM.\n\t * However, there are some that don't, and they set the U1/U2 exit\n\t * latencies to zero.\n\t */\n\tif (!udev->bos->ss_cap) {\n\t\tdev_info(&udev->dev, \"No LPM exit latency info found, disabling LPM.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (udev->bos->ss_cap->bU1devExitLat == 0 &&\n\t\t\tudev->bos->ss_cap->bU2DevExitLat == 0) {\n\t\tif (udev->parent)\n\t\t\tdev_info(&udev->dev, \"LPM exit latency is zeroed, disabling LPM.\\n\");\n\t\telse\n\t\t\tdev_info(&udev->dev, \"We don't know the algorithms for LPM for this host, disabling LPM.\\n\");\n\t\treturn 0;\n\t}\n\n\tif (!udev->parent || udev->parent->lpm_capable)\n\t\treturn 1;\n\treturn 0;\n}\n\n/*\n * Set the Maximum Exit Latency (MEL) for the host to initiate a transition from\n * either U1 or U2.\n */\nstatic void usb_set_lpm_mel(struct usb_device *udev,\n\t\tstruct usb3_lpm_parameters *udev_lpm_params,\n\t\tunsigned int udev_exit_latency,\n\t\tstruct usb_hub *hub,\n\t\tstruct usb3_lpm_parameters *hub_lpm_params,\n\t\tunsigned int hub_exit_latency)\n{\n\tunsigned int total_mel;\n\tunsigned int device_mel;\n\tunsigned int hub_mel;\n\n\t/*\n\t * Calculate the time it takes to transition all links from the roothub\n\t * to the parent hub into U0.  The parent hub must then decode the\n\t * packet (hub header decode latency) to figure out which port it was\n\t * bound for.\n\t *\n\t * The Hub Header decode latency is expressed in 0.1us intervals (0x1\n\t * means 0.1us).  Multiply that by 100 to get nanoseconds.\n\t */\n\ttotal_mel = hub_lpm_params->mel +\n\t\t(hub->descriptor->u.ss.bHubHdrDecLat * 100);\n\n\t/*\n\t * How long will it take to transition the downstream hub's port into\n\t * U0?  The greater of either the hub exit latency or the device exit\n\t * latency.\n\t *\n\t * The BOS U1/U2 exit latencies are expressed in 1us intervals.\n\t * Multiply that by 1000 to get nanoseconds.\n\t */\n\tdevice_mel = udev_exit_latency * 1000;\n\thub_mel = hub_exit_latency * 1000;\n\tif (device_mel > hub_mel)\n\t\ttotal_mel += device_mel;\n\telse\n\t\ttotal_mel += hub_mel;\n\n\tudev_lpm_params->mel = total_mel;\n}\n\n/*\n * Set the maximum Device to Host Exit Latency (PEL) for the device to initiate\n * a transition from either U1 or U2.\n */\nstatic void usb_set_lpm_pel(struct usb_device *udev,\n\t\tstruct usb3_lpm_parameters *udev_lpm_params,\n\t\tunsigned int udev_exit_latency,\n\t\tstruct usb_hub *hub,\n\t\tstruct usb3_lpm_parameters *hub_lpm_params,\n\t\tunsigned int hub_exit_latency,\n\t\tunsigned int port_to_port_exit_latency)\n{\n\tunsigned int first_link_pel;\n\tunsigned int hub_pel;\n\n\t/*\n\t * First, the device sends an LFPS to transition the link between the\n\t * device and the parent hub into U0.  The exit latency is the bigger of\n\t * the device exit latency or the hub exit latency.\n\t */\n\tif (udev_exit_latency > hub_exit_latency)\n\t\tfirst_link_pel = udev_exit_latency * 1000;\n\telse\n\t\tfirst_link_pel = hub_exit_latency * 1000;\n\n\t/*\n\t * When the hub starts to receive the LFPS, there is a slight delay for\n\t * it to figure out that one of the ports is sending an LFPS.  Then it\n\t * will forward the LFPS to its upstream link.  The exit latency is the\n\t * delay, plus the PEL that we calculated for this hub.\n\t */\n\thub_pel = port_to_port_exit_latency * 1000 + hub_lpm_params->pel;\n\n\t/*\n\t * According to figure C-7 in the USB 3.0 spec, the PEL for this device\n\t * is the greater of the two exit latencies.\n\t */\n\tif (first_link_pel > hub_pel)\n\t\tudev_lpm_params->pel = first_link_pel;\n\telse\n\t\tudev_lpm_params->pel = hub_pel;\n}\n\n/*\n * Set the System Exit Latency (SEL) to indicate the total worst-case time from\n * when a device initiates a transition to U0, until when it will receive the\n * first packet from the host controller.\n *\n * Section C.1.5.1 describes the four components to this:\n *  - t1: device PEL\n *  - t2: time for the ERDY to make it from the device to the host.\n *  - t3: a host-specific delay to process the ERDY.\n *  - t4: time for the packet to make it from the host to the device.\n *\n * t3 is specific to both the xHCI host and the platform the host is integrated\n * into.  The Intel HW folks have said it's negligible, FIXME if a different\n * vendor says otherwise.\n */\nstatic void usb_set_lpm_sel(struct usb_device *udev,\n\t\tstruct usb3_lpm_parameters *udev_lpm_params)\n{\n\tstruct usb_device *parent;\n\tunsigned int num_hubs;\n\tunsigned int total_sel;\n\n\t/* t1 = device PEL */\n\ttotal_sel = udev_lpm_params->pel;\n\t/* How many external hubs are in between the device & the root port. */\n\tfor (parent = udev->parent, num_hubs = 0; parent->parent;\n\t\t\tparent = parent->parent)\n\t\tnum_hubs++;\n\t/* t2 = 2.1us + 250ns * (num_hubs - 1) */\n\tif (num_hubs > 0)\n\t\ttotal_sel += 2100 + 250 * (num_hubs - 1);\n\n\t/* t4 = 250ns * num_hubs */\n\ttotal_sel += 250 * num_hubs;\n\n\tudev_lpm_params->sel = total_sel;\n}\n\nstatic void usb_set_lpm_parameters(struct usb_device *udev)\n{\n\tstruct usb_hub *hub;\n\tunsigned int port_to_port_delay;\n\tunsigned int udev_u1_del;\n\tunsigned int udev_u2_del;\n\tunsigned int hub_u1_del;\n\tunsigned int hub_u2_del;\n\n\tif (!udev->lpm_capable || udev->speed != USB_SPEED_SUPER)\n\t\treturn;\n\n\thub = usb_hub_to_struct_hub(udev->parent);\n\t/* It doesn't take time to transition the roothub into U0, since it\n\t * doesn't have an upstream link.\n\t */\n\tif (!hub)\n\t\treturn;\n\n\tudev_u1_del = udev->bos->ss_cap->bU1devExitLat;\n\tudev_u2_del = le16_to_cpu(udev->bos->ss_cap->bU2DevExitLat);\n\thub_u1_del = udev->parent->bos->ss_cap->bU1devExitLat;\n\thub_u2_del = le16_to_cpu(udev->parent->bos->ss_cap->bU2DevExitLat);\n\n\tusb_set_lpm_mel(udev, &udev->u1_params, udev_u1_del,\n\t\t\thub, &udev->parent->u1_params, hub_u1_del);\n\n\tusb_set_lpm_mel(udev, &udev->u2_params, udev_u2_del,\n\t\t\thub, &udev->parent->u2_params, hub_u2_del);\n\n\t/*\n\t * Appendix C, section C.2.2.2, says that there is a slight delay from\n\t * when the parent hub notices the downstream port is trying to\n\t * transition to U0 to when the hub initiates a U0 transition on its\n\t * upstream port.  The section says the delays are tPort2PortU1EL and\n\t * tPort2PortU2EL, but it doesn't define what they are.\n\t *\n\t * The hub chapter, sections 10.4.2.4 and 10.4.2.5 seem to be talking\n\t * about the same delays.  Use the maximum delay calculations from those\n\t * sections.  For U1, it's tHubPort2PortExitLat, which is 1us max.  For\n\t * U2, it's tHubPort2PortExitLat + U2DevExitLat - U1DevExitLat.  I\n\t * assume the device exit latencies they are talking about are the hub\n\t * exit latencies.\n\t *\n\t * What do we do if the U2 exit latency is less than the U1 exit\n\t * latency?  It's possible, although not likely...\n\t */\n\tport_to_port_delay = 1;\n\n\tusb_set_lpm_pel(udev, &udev->u1_params, udev_u1_del,\n\t\t\thub, &udev->parent->u1_params, hub_u1_del,\n\t\t\tport_to_port_delay);\n\n\tif (hub_u2_del > hub_u1_del)\n\t\tport_to_port_delay = 1 + hub_u2_del - hub_u1_del;\n\telse\n\t\tport_to_port_delay = 1 + hub_u1_del;\n\n\tusb_set_lpm_pel(udev, &udev->u2_params, udev_u2_del,\n\t\t\thub, &udev->parent->u2_params, hub_u2_del,\n\t\t\tport_to_port_delay);\n\n\t/* Now that we've got PEL, calculate SEL. */\n\tusb_set_lpm_sel(udev, &udev->u1_params);\n\tusb_set_lpm_sel(udev, &udev->u2_params);\n}\n\n/* USB 2.0 spec Section 11.24.4.5 */\nstatic int get_hub_descriptor(struct usb_device *hdev, void *data)\n{\n\tint i, ret, size;\n\tunsigned dtype;\n\n\tif (hub_is_superspeed(hdev)) {\n\t\tdtype = USB_DT_SS_HUB;\n\t\tsize = USB_DT_SS_HUB_SIZE;\n\t} else {\n\t\tdtype = USB_DT_HUB;\n\t\tsize = sizeof(struct usb_hub_descriptor);\n\t}\n\n\tfor (i = 0; i < 3; i++) {\n\t\tret = usb_control_msg(hdev, usb_rcvctrlpipe(hdev, 0),\n\t\t\tUSB_REQ_GET_DESCRIPTOR, USB_DIR_IN | USB_RT_HUB,\n\t\t\tdtype << 8, 0, data, size,\n\t\t\tUSB_CTRL_GET_TIMEOUT);\n\t\tif (ret >= (USB_DT_HUB_NONVAR_SIZE + 2))\n\t\t\treturn ret;\n\t}\n\treturn -EINVAL;\n}\n\n/*\n * USB 2.0 spec Section 11.24.2.1\n */\nstatic int clear_hub_feature(struct usb_device *hdev, int feature)\n{\n\treturn usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\n\t\tUSB_REQ_CLEAR_FEATURE, USB_RT_HUB, feature, 0, NULL, 0, 1000);\n}\n\n/*\n * USB 2.0 spec Section 11.24.2.2\n */\nint usb_clear_port_feature(struct usb_device *hdev, int port1, int feature)\n{\n\treturn usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\n\t\tUSB_REQ_CLEAR_FEATURE, USB_RT_PORT, feature, port1,\n\t\tNULL, 0, 1000);\n}\n\n/*\n * USB 2.0 spec Section 11.24.2.13\n */\nstatic int set_port_feature(struct usb_device *hdev, int port1, int feature)\n{\n\treturn usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\n\t\tUSB_REQ_SET_FEATURE, USB_RT_PORT, feature, port1,\n\t\tNULL, 0, 1000);\n}\n\nstatic char *to_led_name(int selector)\n{\n\tswitch (selector) {\n\tcase HUB_LED_AMBER:\n\t\treturn \"amber\";\n\tcase HUB_LED_GREEN:\n\t\treturn \"green\";\n\tcase HUB_LED_OFF:\n\t\treturn \"off\";\n\tcase HUB_LED_AUTO:\n\t\treturn \"auto\";\n\tdefault:\n\t\treturn \"??\";\n\t}\n}\n\n/*\n * USB 2.0 spec Section 11.24.2.7.1.10 and table 11-7\n * for info about using port indicators\n */\nstatic void set_port_led(struct usb_hub *hub, int port1, int selector)\n{\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tint status;\n\n\tstatus = set_port_feature(hub->hdev, (selector << 8) | port1,\n\t\t\tUSB_PORT_FEAT_INDICATOR);\n\tdev_dbg(&port_dev->dev, \"indicator %s status %d\\n\",\n\t\tto_led_name(selector), status);\n}\n\n#define\tLED_CYCLE_PERIOD\t((2*HZ)/3)\n\nstatic void led_work(struct work_struct *work)\n{\n\tstruct usb_hub\t\t*hub =\n\t\tcontainer_of(work, struct usb_hub, leds.work);\n\tstruct usb_device\t*hdev = hub->hdev;\n\tunsigned\t\ti;\n\tunsigned\t\tchanged = 0;\n\tint\t\t\tcursor = -1;\n\n\tif (hdev->state != USB_STATE_CONFIGURED || hub->quiescing)\n\t\treturn;\n\n\tfor (i = 0; i < hdev->maxchild; i++) {\n\t\tunsigned\tselector, mode;\n\n\t\t/* 30%-50% duty cycle */\n\n\t\tswitch (hub->indicator[i]) {\n\t\t/* cycle marker */\n\t\tcase INDICATOR_CYCLE:\n\t\t\tcursor = i;\n\t\t\tselector = HUB_LED_AUTO;\n\t\t\tmode = INDICATOR_AUTO;\n\t\t\tbreak;\n\t\t/* blinking green = sw attention */\n\t\tcase INDICATOR_GREEN_BLINK:\n\t\t\tselector = HUB_LED_GREEN;\n\t\t\tmode = INDICATOR_GREEN_BLINK_OFF;\n\t\t\tbreak;\n\t\tcase INDICATOR_GREEN_BLINK_OFF:\n\t\t\tselector = HUB_LED_OFF;\n\t\t\tmode = INDICATOR_GREEN_BLINK;\n\t\t\tbreak;\n\t\t/* blinking amber = hw attention */\n\t\tcase INDICATOR_AMBER_BLINK:\n\t\t\tselector = HUB_LED_AMBER;\n\t\t\tmode = INDICATOR_AMBER_BLINK_OFF;\n\t\t\tbreak;\n\t\tcase INDICATOR_AMBER_BLINK_OFF:\n\t\t\tselector = HUB_LED_OFF;\n\t\t\tmode = INDICATOR_AMBER_BLINK;\n\t\t\tbreak;\n\t\t/* blink green/amber = reserved */\n\t\tcase INDICATOR_ALT_BLINK:\n\t\t\tselector = HUB_LED_GREEN;\n\t\t\tmode = INDICATOR_ALT_BLINK_OFF;\n\t\t\tbreak;\n\t\tcase INDICATOR_ALT_BLINK_OFF:\n\t\t\tselector = HUB_LED_AMBER;\n\t\t\tmode = INDICATOR_ALT_BLINK;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcontinue;\n\t\t}\n\t\tif (selector != HUB_LED_AUTO)\n\t\t\tchanged = 1;\n\t\tset_port_led(hub, i + 1, selector);\n\t\thub->indicator[i] = mode;\n\t}\n\tif (!changed && blinkenlights) {\n\t\tcursor++;\n\t\tcursor %= hdev->maxchild;\n\t\tset_port_led(hub, cursor + 1, HUB_LED_GREEN);\n\t\thub->indicator[cursor] = INDICATOR_CYCLE;\n\t\tchanged++;\n\t}\n\tif (changed)\n\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t&hub->leds, LED_CYCLE_PERIOD);\n}\n\n/* use a short timeout for hub/port status fetches */\n#define\tUSB_STS_TIMEOUT\t\t1000\n#define\tUSB_STS_RETRIES\t\t5\n\n/*\n * USB 2.0 spec Section 11.24.2.6\n */\nstatic int get_hub_status(struct usb_device *hdev,\n\t\tstruct usb_hub_status *data)\n{\n\tint i, status = -ETIMEDOUT;\n\n\tfor (i = 0; i < USB_STS_RETRIES &&\n\t\t\t(status == -ETIMEDOUT || status == -EPIPE); i++) {\n\t\tstatus = usb_control_msg(hdev, usb_rcvctrlpipe(hdev, 0),\n\t\t\tUSB_REQ_GET_STATUS, USB_DIR_IN | USB_RT_HUB, 0, 0,\n\t\t\tdata, sizeof(*data), USB_STS_TIMEOUT);\n\t}\n\treturn status;\n}\n\n/*\n * USB 2.0 spec Section 11.24.2.7\n */\nstatic int get_port_status(struct usb_device *hdev, int port1,\n\t\tstruct usb_port_status *data)\n{\n\tint i, status = -ETIMEDOUT;\n\n\tfor (i = 0; i < USB_STS_RETRIES &&\n\t\t\t(status == -ETIMEDOUT || status == -EPIPE); i++) {\n\t\tstatus = usb_control_msg(hdev, usb_rcvctrlpipe(hdev, 0),\n\t\t\tUSB_REQ_GET_STATUS, USB_DIR_IN | USB_RT_PORT, 0, port1,\n\t\t\tdata, sizeof(*data), USB_STS_TIMEOUT);\n\t}\n\treturn status;\n}\n\nstatic int hub_port_status(struct usb_hub *hub, int port1,\n\t\tu16 *status, u16 *change)\n{\n\tint ret;\n\n\tmutex_lock(&hub->status_mutex);\n\tret = get_port_status(hub->hdev, port1, &hub->status->port);\n\tif (ret < 4) {\n\t\tif (ret != -ENODEV)\n\t\t\tdev_err(hub->intfdev,\n\t\t\t\t\"%s failed (err = %d)\\n\", __func__, ret);\n\t\tif (ret >= 0)\n\t\t\tret = -EIO;\n\t} else {\n\t\t*status = le16_to_cpu(hub->status->port.wPortStatus);\n\t\t*change = le16_to_cpu(hub->status->port.wPortChange);\n\n\t\tret = 0;\n\t}\n\tmutex_unlock(&hub->status_mutex);\n\treturn ret;\n}\n\nstatic void kick_hub_wq(struct usb_hub *hub)\n{\n\tstruct usb_interface *intf;\n\n\tif (hub->disconnected || work_pending(&hub->events))\n\t\treturn;\n\n\t/*\n\t * Suppress autosuspend until the event is proceed.\n\t *\n\t * Be careful and make sure that the symmetric operation is\n\t * always called. We are here only when there is no pending\n\t * work for this hub. Therefore put the interface either when\n\t * the new work is called or when it is canceled.\n\t */\n\tintf = to_usb_interface(hub->intfdev);\n\tusb_autopm_get_interface_no_resume(intf);\n\tkref_get(&hub->kref);\n\n\tif (queue_work(hub_wq, &hub->events))\n\t\treturn;\n\n\t/* the work has already been scheduled */\n\tusb_autopm_put_interface_async(intf);\n\tkref_put(&hub->kref, hub_release);\n}\n\nvoid usb_kick_hub_wq(struct usb_device *hdev)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\n\tif (hub)\n\t\tkick_hub_wq(hub);\n}\n\n/*\n * Let the USB core know that a USB 3.0 device has sent a Function Wake Device\n * Notification, which indicates it had initiated remote wakeup.\n *\n * USB 3.0 hubs do not report the port link state change from U3 to U0 when the\n * device initiates resume, so the USB core will not receive notice of the\n * resume through the normal hub interrupt URB.\n */\nvoid usb_wakeup_notification(struct usb_device *hdev,\n\t\tunsigned int portnum)\n{\n\tstruct usb_hub *hub;\n\n\tif (!hdev)\n\t\treturn;\n\n\thub = usb_hub_to_struct_hub(hdev);\n\tif (hub) {\n\t\tset_bit(portnum, hub->wakeup_bits);\n\t\tkick_hub_wq(hub);\n\t}\n}\nEXPORT_SYMBOL_GPL(usb_wakeup_notification);\n\n/* completion function, fires on port status changes and various faults */\nstatic void hub_irq(struct urb *urb)\n{\n\tstruct usb_hub *hub = urb->context;\n\tint status = urb->status;\n\tunsigned i;\n\tunsigned long bits;\n\n\tswitch (status) {\n\tcase -ENOENT:\t\t/* synchronous unlink */\n\tcase -ECONNRESET:\t/* async unlink */\n\tcase -ESHUTDOWN:\t/* hardware going away */\n\t\treturn;\n\n\tdefault:\t\t/* presumably an error */\n\t\t/* Cause a hub reset after 10 consecutive errors */\n\t\tdev_dbg(hub->intfdev, \"transfer --> %d\\n\", status);\n\t\tif ((++hub->nerrors < 10) || hub->error)\n\t\t\tgoto resubmit;\n\t\thub->error = status;\n\t\t/* FALL THROUGH */\n\n\t/* let hub_wq handle things */\n\tcase 0:\t\t\t/* we got data:  port status changed */\n\t\tbits = 0;\n\t\tfor (i = 0; i < urb->actual_length; ++i)\n\t\t\tbits |= ((unsigned long) ((*hub->buffer)[i]))\n\t\t\t\t\t<< (i*8);\n\t\thub->event_bits[0] = bits;\n\t\tbreak;\n\t}\n\n\thub->nerrors = 0;\n\n\t/* Something happened, let hub_wq figure it out */\n\tkick_hub_wq(hub);\n\nresubmit:\n\tif (hub->quiescing)\n\t\treturn;\n\n\tstatus = usb_submit_urb(hub->urb, GFP_ATOMIC);\n\tif (status != 0 && status != -ENODEV && status != -EPERM)\n\t\tdev_err(hub->intfdev, \"resubmit --> %d\\n\", status);\n}\n\n/* USB 2.0 spec Section 11.24.2.3 */\nstatic inline int\nhub_clear_tt_buffer(struct usb_device *hdev, u16 devinfo, u16 tt)\n{\n\t/* Need to clear both directions for control ep */\n\tif (((devinfo >> 11) & USB_ENDPOINT_XFERTYPE_MASK) ==\n\t\t\tUSB_ENDPOINT_XFER_CONTROL) {\n\t\tint status = usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\n\t\t\t\tHUB_CLEAR_TT_BUFFER, USB_RT_PORT,\n\t\t\t\tdevinfo ^ 0x8000, tt, NULL, 0, 1000);\n\t\tif (status)\n\t\t\treturn status;\n\t}\n\treturn usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\n\t\t\t       HUB_CLEAR_TT_BUFFER, USB_RT_PORT, devinfo,\n\t\t\t       tt, NULL, 0, 1000);\n}\n\n/*\n * enumeration blocks hub_wq for a long time. we use keventd instead, since\n * long blocking there is the exception, not the rule.  accordingly, HCDs\n * talking to TTs must queue control transfers (not just bulk and iso), so\n * both can talk to the same hub concurrently.\n */\nstatic void hub_tt_work(struct work_struct *work)\n{\n\tstruct usb_hub\t\t*hub =\n\t\tcontainer_of(work, struct usb_hub, tt.clear_work);\n\tunsigned long\t\tflags;\n\n\tspin_lock_irqsave(&hub->tt.lock, flags);\n\twhile (!list_empty(&hub->tt.clear_list)) {\n\t\tstruct list_head\t*next;\n\t\tstruct usb_tt_clear\t*clear;\n\t\tstruct usb_device\t*hdev = hub->hdev;\n\t\tconst struct hc_driver\t*drv;\n\t\tint\t\t\tstatus;\n\n\t\tnext = hub->tt.clear_list.next;\n\t\tclear = list_entry(next, struct usb_tt_clear, clear_list);\n\t\tlist_del(&clear->clear_list);\n\n\t\t/* drop lock so HCD can concurrently report other TT errors */\n\t\tspin_unlock_irqrestore(&hub->tt.lock, flags);\n\t\tstatus = hub_clear_tt_buffer(hdev, clear->devinfo, clear->tt);\n\t\tif (status && status != -ENODEV)\n\t\t\tdev_err(&hdev->dev,\n\t\t\t\t\"clear tt %d (%04x) error %d\\n\",\n\t\t\t\tclear->tt, clear->devinfo, status);\n\n\t\t/* Tell the HCD, even if the operation failed */\n\t\tdrv = clear->hcd->driver;\n\t\tif (drv->clear_tt_buffer_complete)\n\t\t\t(drv->clear_tt_buffer_complete)(clear->hcd, clear->ep);\n\n\t\tkfree(clear);\n\t\tspin_lock_irqsave(&hub->tt.lock, flags);\n\t}\n\tspin_unlock_irqrestore(&hub->tt.lock, flags);\n}\n\n/**\n * usb_hub_set_port_power - control hub port's power state\n * @hdev: USB device belonging to the usb hub\n * @hub: target hub\n * @port1: port index\n * @set: expected status\n *\n * call this function to control port's power via setting or\n * clearing the port's PORT_POWER feature.\n *\n * Return: 0 if successful. A negative error code otherwise.\n */\nint usb_hub_set_port_power(struct usb_device *hdev, struct usb_hub *hub,\n\t\t\t   int port1, bool set)\n{\n\tint ret;\n\n\tif (set)\n\t\tret = set_port_feature(hdev, port1, USB_PORT_FEAT_POWER);\n\telse\n\t\tret = usb_clear_port_feature(hdev, port1, USB_PORT_FEAT_POWER);\n\n\tif (ret)\n\t\treturn ret;\n\n\tif (set)\n\t\tset_bit(port1, hub->power_bits);\n\telse\n\t\tclear_bit(port1, hub->power_bits);\n\treturn 0;\n}\n\n/**\n * usb_hub_clear_tt_buffer - clear control/bulk TT state in high speed hub\n * @urb: an URB associated with the failed or incomplete split transaction\n *\n * High speed HCDs use this to tell the hub driver that some split control or\n * bulk transaction failed in a way that requires clearing internal state of\n * a transaction translator.  This is normally detected (and reported) from\n * interrupt context.\n *\n * It may not be possible for that hub to handle additional full (or low)\n * speed transactions until that state is fully cleared out.\n *\n * Return: 0 if successful. A negative error code otherwise.\n */\nint usb_hub_clear_tt_buffer(struct urb *urb)\n{\n\tstruct usb_device\t*udev = urb->dev;\n\tint\t\t\tpipe = urb->pipe;\n\tstruct usb_tt\t\t*tt = udev->tt;\n\tunsigned long\t\tflags;\n\tstruct usb_tt_clear\t*clear;\n\n\t/* we've got to cope with an arbitrary number of pending TT clears,\n\t * since each TT has \"at least two\" buffers that can need it (and\n\t * there can be many TTs per hub).  even if they're uncommon.\n\t */\n\tclear = kmalloc(sizeof *clear, GFP_ATOMIC);\n\tif (clear == NULL) {\n\t\tdev_err(&udev->dev, \"can't save CLEAR_TT_BUFFER state\\n\");\n\t\t/* FIXME recover somehow ... RESET_TT? */\n\t\treturn -ENOMEM;\n\t}\n\n\t/* info that CLEAR_TT_BUFFER needs */\n\tclear->tt = tt->multi ? udev->ttport : 1;\n\tclear->devinfo = usb_pipeendpoint (pipe);\n\tclear->devinfo |= udev->devnum << 4;\n\tclear->devinfo |= usb_pipecontrol(pipe)\n\t\t\t? (USB_ENDPOINT_XFER_CONTROL << 11)\n\t\t\t: (USB_ENDPOINT_XFER_BULK << 11);\n\tif (usb_pipein(pipe))\n\t\tclear->devinfo |= 1 << 15;\n\n\t/* info for completion callback */\n\tclear->hcd = bus_to_hcd(udev->bus);\n\tclear->ep = urb->ep;\n\n\t/* tell keventd to clear state for this TT */\n\tspin_lock_irqsave(&tt->lock, flags);\n\tlist_add_tail(&clear->clear_list, &tt->clear_list);\n\tschedule_work(&tt->clear_work);\n\tspin_unlock_irqrestore(&tt->lock, flags);\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_hub_clear_tt_buffer);\n\nstatic void hub_power_on(struct usb_hub *hub, bool do_delay)\n{\n\tint port1;\n\n\t/* Enable power on each port.  Some hubs have reserved values\n\t * of LPSM (> 2) in their descriptors, even though they are\n\t * USB 2.0 hubs.  Some hubs do not implement port-power switching\n\t * but only emulate it.  In all cases, the ports won't work\n\t * unless we send these messages to the hub.\n\t */\n\tif (hub_is_port_power_switchable(hub))\n\t\tdev_dbg(hub->intfdev, \"enabling power on all ports\\n\");\n\telse\n\t\tdev_dbg(hub->intfdev, \"trying to enable port power on \"\n\t\t\t\t\"non-switchable hub\\n\");\n\tfor (port1 = 1; port1 <= hub->hdev->maxchild; port1++)\n\t\tif (test_bit(port1, hub->power_bits))\n\t\t\tset_port_feature(hub->hdev, port1, USB_PORT_FEAT_POWER);\n\t\telse\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\t\tUSB_PORT_FEAT_POWER);\n\tif (do_delay)\n\t\tmsleep(hub_power_on_good_delay(hub));\n}\n\nstatic int hub_hub_status(struct usb_hub *hub,\n\t\tu16 *status, u16 *change)\n{\n\tint ret;\n\n\tmutex_lock(&hub->status_mutex);\n\tret = get_hub_status(hub->hdev, &hub->status->hub);\n\tif (ret < 0) {\n\t\tif (ret != -ENODEV)\n\t\t\tdev_err(hub->intfdev,\n\t\t\t\t\"%s failed (err = %d)\\n\", __func__, ret);\n\t} else {\n\t\t*status = le16_to_cpu(hub->status->hub.wHubStatus);\n\t\t*change = le16_to_cpu(hub->status->hub.wHubChange);\n\t\tret = 0;\n\t}\n\tmutex_unlock(&hub->status_mutex);\n\treturn ret;\n}\n\nstatic int hub_set_port_link_state(struct usb_hub *hub, int port1,\n\t\t\tunsigned int link_status)\n{\n\treturn set_port_feature(hub->hdev,\n\t\t\tport1 | (link_status << 3),\n\t\t\tUSB_PORT_FEAT_LINK_STATE);\n}\n\n/*\n * If USB 3.0 ports are placed into the Disabled state, they will no longer\n * detect any device connects or disconnects.  This is generally not what the\n * USB core wants, since it expects a disabled port to produce a port status\n * change event when a new device connects.\n *\n * Instead, set the link state to Disabled, wait for the link to settle into\n * that state, clear any change bits, and then put the port into the RxDetect\n * state.\n */\nstatic int hub_usb3_port_disable(struct usb_hub *hub, int port1)\n{\n\tint ret;\n\tint total_time;\n\tu16 portchange, portstatus;\n\n\tif (!hub_is_superspeed(hub->hdev))\n\t\treturn -EINVAL;\n\n\tret = hub_port_status(hub, port1, &portstatus, &portchange);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/*\n\t * USB controller Advanced Micro Devices, Inc. [AMD] FCH USB XHCI\n\t * Controller [1022:7814] will have spurious result making the following\n\t * usb 3.0 device hotplugging route to the 2.0 root hub and recognized\n\t * as high-speed device if we set the usb 3.0 port link state to\n\t * Disabled. Since it's already in USB_SS_PORT_LS_RX_DETECT state, we\n\t * check the state here to avoid the bug.\n\t */\n\tif ((portstatus & USB_PORT_STAT_LINK_STATE) ==\n\t\t\t\tUSB_SS_PORT_LS_RX_DETECT) {\n\t\tdev_dbg(&hub->ports[port1 - 1]->dev,\n\t\t\t \"Not disabling port; link state is RxDetect\\n\");\n\t\treturn ret;\n\t}\n\n\tret = hub_set_port_link_state(hub, port1, USB_SS_PORT_LS_SS_DISABLED);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Wait for the link to enter the disabled state. */\n\tfor (total_time = 0; ; total_time += HUB_DEBOUNCE_STEP) {\n\t\tret = hub_port_status(hub, port1, &portstatus, &portchange);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif ((portstatus & USB_PORT_STAT_LINK_STATE) ==\n\t\t\t\tUSB_SS_PORT_LS_SS_DISABLED)\n\t\t\tbreak;\n\t\tif (total_time >= HUB_DEBOUNCE_TIMEOUT)\n\t\t\tbreak;\n\t\tmsleep(HUB_DEBOUNCE_STEP);\n\t}\n\tif (total_time >= HUB_DEBOUNCE_TIMEOUT)\n\t\tdev_warn(&hub->ports[port1 - 1]->dev,\n\t\t\t\t\"Could not disable after %d ms\\n\", total_time);\n\n\treturn hub_set_port_link_state(hub, port1, USB_SS_PORT_LS_RX_DETECT);\n}\n\nstatic int hub_port_disable(struct usb_hub *hub, int port1, int set_state)\n{\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tstruct usb_device *hdev = hub->hdev;\n\tint ret = 0;\n\n\tif (port_dev->child && set_state)\n\t\tusb_set_device_state(port_dev->child, USB_STATE_NOTATTACHED);\n\tif (!hub->error) {\n\t\tif (hub_is_superspeed(hub->hdev))\n\t\t\tret = hub_usb3_port_disable(hub, port1);\n\t\telse\n\t\t\tret = usb_clear_port_feature(hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_ENABLE);\n\t}\n\tif (ret && ret != -ENODEV)\n\t\tdev_err(&port_dev->dev, \"cannot disable (err = %d)\\n\", ret);\n\treturn ret;\n}\n\n/*\n * Disable a port and mark a logical connect-change event, so that some\n * time later hub_wq will disconnect() any existing usb_device on the port\n * and will re-enumerate if there actually is a device attached.\n */\nstatic void hub_port_logical_disconnect(struct usb_hub *hub, int port1)\n{\n\tdev_dbg(&hub->ports[port1 - 1]->dev, \"logical disconnect\\n\");\n\thub_port_disable(hub, port1, 1);\n\n\t/* FIXME let caller ask to power down the port:\n\t *  - some devices won't enumerate without a VBUS power cycle\n\t *  - SRP saves power that way\n\t *  - ... new call, TBD ...\n\t * That's easy if this hub can switch power per-port, and\n\t * hub_wq reactivates the port later (timer, SRP, etc).\n\t * Powerdown must be optional, because of reset/DFU.\n\t */\n\n\tset_bit(port1, hub->change_bits);\n\tkick_hub_wq(hub);\n}\n\n/**\n * usb_remove_device - disable a device's port on its parent hub\n * @udev: device to be disabled and removed\n * Context: @udev locked, must be able to sleep.\n *\n * After @udev's port has been disabled, hub_wq is notified and it will\n * see that the device has been disconnected.  When the device is\n * physically unplugged and something is plugged in, the events will\n * be received and processed normally.\n *\n * Return: 0 if successful. A negative error code otherwise.\n */\nint usb_remove_device(struct usb_device *udev)\n{\n\tstruct usb_hub *hub;\n\tstruct usb_interface *intf;\n\n\tif (!udev->parent)\t/* Can't remove a root hub */\n\t\treturn -EINVAL;\n\thub = usb_hub_to_struct_hub(udev->parent);\n\tintf = to_usb_interface(hub->intfdev);\n\n\tusb_autopm_get_interface(intf);\n\tset_bit(udev->portnum, hub->removed_bits);\n\thub_port_logical_disconnect(hub, udev->portnum);\n\tusb_autopm_put_interface(intf);\n\treturn 0;\n}\n\nenum hub_activation_type {\n\tHUB_INIT, HUB_INIT2, HUB_INIT3,\t\t/* INITs must come first */\n\tHUB_POST_RESET, HUB_RESUME, HUB_RESET_RESUME,\n};\n\nstatic void hub_init_func2(struct work_struct *ws);\nstatic void hub_init_func3(struct work_struct *ws);\n\nstatic void hub_activate(struct usb_hub *hub, enum hub_activation_type type)\n{\n\tstruct usb_device *hdev = hub->hdev;\n\tstruct usb_hcd *hcd;\n\tint ret;\n\tint port1;\n\tint status;\n\tbool need_debounce_delay = false;\n\tunsigned delay;\n\n\t/* Continue a partial initialization */\n\tif (type == HUB_INIT2 || type == HUB_INIT3) {\n\t\tdevice_lock(hub->intfdev);\n\n\t\t/* Was the hub disconnected while we were waiting? */\n\t\tif (hub->disconnected) {\n\t\t\tdevice_unlock(hub->intfdev);\n\t\t\tkref_put(&hub->kref, hub_release);\n\t\t\treturn;\n\t\t}\n\t\tif (type == HUB_INIT2)\n\t\t\tgoto init2;\n\t\tgoto init3;\n\t}\n\tkref_get(&hub->kref);\n\n\t/* The superspeed hub except for root hub has to use Hub Depth\n\t * value as an offset into the route string to locate the bits\n\t * it uses to determine the downstream port number. So hub driver\n\t * should send a set hub depth request to superspeed hub after\n\t * the superspeed hub is set configuration in initialization or\n\t * reset procedure.\n\t *\n\t * After a resume, port power should still be on.\n\t * For any other type of activation, turn it on.\n\t */\n\tif (type != HUB_RESUME) {\n\t\tif (hdev->parent && hub_is_superspeed(hdev)) {\n\t\t\tret = usb_control_msg(hdev, usb_sndctrlpipe(hdev, 0),\n\t\t\t\t\tHUB_SET_DEPTH, USB_RT_HUB,\n\t\t\t\t\thdev->level - 1, 0, NULL, 0,\n\t\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t\tif (ret < 0)\n\t\t\t\tdev_err(hub->intfdev,\n\t\t\t\t\t\t\"set hub depth failed\\n\");\n\t\t}\n\n\t\t/* Speed up system boot by using a delayed_work for the\n\t\t * hub's initial power-up delays.  This is pretty awkward\n\t\t * and the implementation looks like a home-brewed sort of\n\t\t * setjmp/longjmp, but it saves at least 100 ms for each\n\t\t * root hub (assuming usbcore is compiled into the kernel\n\t\t * rather than as a module).  It adds up.\n\t\t *\n\t\t * This can't be done for HUB_RESUME or HUB_RESET_RESUME\n\t\t * because for those activation types the ports have to be\n\t\t * operational when we return.  In theory this could be done\n\t\t * for HUB_POST_RESET, but it's easier not to.\n\t\t */\n\t\tif (type == HUB_INIT) {\n\t\t\tdelay = hub_power_on_good_delay(hub);\n\n\t\t\thub_power_on(hub, false);\n\t\t\tINIT_DELAYED_WORK(&hub->init_work, hub_init_func2);\n\t\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t\t&hub->init_work,\n\t\t\t\t\tmsecs_to_jiffies(delay));\n\n\t\t\t/* Suppress autosuspend until init is done */\n\t\t\tusb_autopm_get_interface_no_resume(\n\t\t\t\t\tto_usb_interface(hub->intfdev));\n\t\t\treturn;\t\t/* Continues at init2: below */\n\t\t} else if (type == HUB_RESET_RESUME) {\n\t\t\t/* The internal host controller state for the hub device\n\t\t\t * may be gone after a host power loss on system resume.\n\t\t\t * Update the device's info so the HW knows it's a hub.\n\t\t\t */\n\t\t\thcd = bus_to_hcd(hdev->bus);\n\t\t\tif (hcd->driver->update_hub_device) {\n\t\t\t\tret = hcd->driver->update_hub_device(hcd, hdev,\n\t\t\t\t\t\t&hub->tt, GFP_NOIO);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tdev_err(hub->intfdev, \"Host not \"\n\t\t\t\t\t\t\t\"accepting hub info \"\n\t\t\t\t\t\t\t\"update.\\n\");\n\t\t\t\t\tdev_err(hub->intfdev, \"LS/FS devices \"\n\t\t\t\t\t\t\t\"and hubs may not work \"\n\t\t\t\t\t\t\t\"under this hub\\n.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\thub_power_on(hub, true);\n\t\t} else {\n\t\t\thub_power_on(hub, true);\n\t\t}\n\t}\n init2:\n\n\t/*\n\t * Check each port and set hub->change_bits to let hub_wq know\n\t * which ports need attention.\n\t */\n\tfor (port1 = 1; port1 <= hdev->maxchild; ++port1) {\n\t\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\t\tstruct usb_device *udev = port_dev->child;\n\t\tu16 portstatus, portchange;\n\n\t\tportstatus = portchange = 0;\n\t\tstatus = hub_port_status(hub, port1, &portstatus, &portchange);\n\t\tif (udev || (portstatus & USB_PORT_STAT_CONNECTION))\n\t\t\tdev_dbg(&port_dev->dev, \"status %04x change %04x\\n\",\n\t\t\t\t\tportstatus, portchange);\n\n\t\t/*\n\t\t * After anything other than HUB_RESUME (i.e., initialization\n\t\t * or any sort of reset), every port should be disabled.\n\t\t * Unconnected ports should likewise be disabled (paranoia),\n\t\t * and so should ports for which we have no usb_device.\n\t\t */\n\t\tif ((portstatus & USB_PORT_STAT_ENABLE) && (\n\t\t\t\ttype != HUB_RESUME ||\n\t\t\t\t!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t\t!udev ||\n\t\t\t\tudev->state == USB_STATE_NOTATTACHED)) {\n\t\t\t/*\n\t\t\t * USB3 protocol ports will automatically transition\n\t\t\t * to Enabled state when detect an USB3.0 device attach.\n\t\t\t * Do not disable USB3 protocol ports, just pretend\n\t\t\t * power was lost\n\t\t\t */\n\t\t\tportstatus &= ~USB_PORT_STAT_ENABLE;\n\t\t\tif (!hub_is_superspeed(hdev))\n\t\t\t\tusb_clear_port_feature(hdev, port1,\n\t\t\t\t\t\t   USB_PORT_FEAT_ENABLE);\n\t\t}\n\n\t\t/* Clear status-change flags; we'll debounce later */\n\t\tif (portchange & USB_PORT_STAT_C_CONNECTION) {\n\t\t\tneed_debounce_delay = true;\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_CONNECTION);\n\t\t}\n\t\tif (portchange & USB_PORT_STAT_C_ENABLE) {\n\t\t\tneed_debounce_delay = true;\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_ENABLE);\n\t\t}\n\t\tif (portchange & USB_PORT_STAT_C_RESET) {\n\t\t\tneed_debounce_delay = true;\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_RESET);\n\t\t}\n\t\tif ((portchange & USB_PORT_STAT_C_BH_RESET) &&\n\t\t\t\thub_is_superspeed(hub->hdev)) {\n\t\t\tneed_debounce_delay = true;\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_BH_PORT_RESET);\n\t\t}\n\t\t/* We can forget about a \"removed\" device when there's a\n\t\t * physical disconnect or the connect status changes.\n\t\t */\n\t\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t\t(portchange & USB_PORT_STAT_C_CONNECTION))\n\t\t\tclear_bit(port1, hub->removed_bits);\n\n\t\tif (!udev || udev->state == USB_STATE_NOTATTACHED) {\n\t\t\t/* Tell hub_wq to disconnect the device or\n\t\t\t * check for a new connection\n\t\t\t */\n\t\t\tif (udev || (portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t    (portstatus & USB_PORT_STAT_OVERCURRENT))\n\t\t\t\tset_bit(port1, hub->change_bits);\n\n\t\t} else if (portstatus & USB_PORT_STAT_ENABLE) {\n\t\t\tbool port_resumed = (portstatus &\n\t\t\t\t\tUSB_PORT_STAT_LINK_STATE) ==\n\t\t\t\tUSB_SS_PORT_LS_U0;\n\t\t\t/* The power session apparently survived the resume.\n\t\t\t * If there was an overcurrent or suspend change\n\t\t\t * (i.e., remote wakeup request), have hub_wq\n\t\t\t * take care of it.  Look at the port link state\n\t\t\t * for USB 3.0 hubs, since they don't have a suspend\n\t\t\t * change bit, and they don't set the port link change\n\t\t\t * bit on device-initiated resume.\n\t\t\t */\n\t\t\tif (portchange || (hub_is_superspeed(hub->hdev) &&\n\t\t\t\t\t\tport_resumed))\n\t\t\t\tset_bit(port1, hub->change_bits);\n\n\t\t} else if (udev->persist_enabled) {\n#ifdef CONFIG_PM\n\t\t\tudev->reset_resume = 1;\n#endif\n\t\t\t/* Don't set the change_bits when the device\n\t\t\t * was powered off.\n\t\t\t */\n\t\t\tif (test_bit(port1, hub->power_bits))\n\t\t\t\tset_bit(port1, hub->change_bits);\n\n\t\t} else {\n\t\t\t/* The power session is gone; tell hub_wq */\n\t\t\tusb_set_device_state(udev, USB_STATE_NOTATTACHED);\n\t\t\tset_bit(port1, hub->change_bits);\n\t\t}\n\t}\n\n\t/* If no port-status-change flags were set, we don't need any\n\t * debouncing.  If flags were set we can try to debounce the\n\t * ports all at once right now, instead of letting hub_wq do them\n\t * one at a time later on.\n\t *\n\t * If any port-status changes do occur during this delay, hub_wq\n\t * will see them later and handle them normally.\n\t */\n\tif (need_debounce_delay) {\n\t\tdelay = HUB_DEBOUNCE_STABLE;\n\n\t\t/* Don't do a long sleep inside a workqueue routine */\n\t\tif (type == HUB_INIT2) {\n\t\t\tINIT_DELAYED_WORK(&hub->init_work, hub_init_func3);\n\t\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t\t&hub->init_work,\n\t\t\t\t\tmsecs_to_jiffies(delay));\n\t\t\tdevice_unlock(hub->intfdev);\n\t\t\treturn;\t\t/* Continues at init3: below */\n\t\t} else {\n\t\t\tmsleep(delay);\n\t\t}\n\t}\n init3:\n\thub->quiescing = 0;\n\n\tstatus = usb_submit_urb(hub->urb, GFP_NOIO);\n\tif (status < 0)\n\t\tdev_err(hub->intfdev, \"activate --> %d\\n\", status);\n\tif (hub->has_indicators && blinkenlights)\n\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t&hub->leds, LED_CYCLE_PERIOD);\n\n\t/* Scan all ports that need attention */\n\tkick_hub_wq(hub);\n\n\t/* Allow autosuspend if it was suppressed */\n\tif (type <= HUB_INIT3)\n\t\tusb_autopm_put_interface_async(to_usb_interface(hub->intfdev));\n\n\tif (type == HUB_INIT2 || type == HUB_INIT3)\n\t\tdevice_unlock(hub->intfdev);\n\n\tkref_put(&hub->kref, hub_release);\n}\n\n/* Implement the continuations for the delays above */\nstatic void hub_init_func2(struct work_struct *ws)\n{\n\tstruct usb_hub *hub = container_of(ws, struct usb_hub, init_work.work);\n\n\thub_activate(hub, HUB_INIT2);\n}\n\nstatic void hub_init_func3(struct work_struct *ws)\n{\n\tstruct usb_hub *hub = container_of(ws, struct usb_hub, init_work.work);\n\n\thub_activate(hub, HUB_INIT3);\n}\n\nenum hub_quiescing_type {\n\tHUB_DISCONNECT, HUB_PRE_RESET, HUB_SUSPEND\n};\n\nstatic void hub_quiesce(struct usb_hub *hub, enum hub_quiescing_type type)\n{\n\tstruct usb_device *hdev = hub->hdev;\n\tint i;\n\n\tcancel_delayed_work_sync(&hub->init_work);\n\n\t/* hub_wq and related activity won't re-trigger */\n\thub->quiescing = 1;\n\n\tif (type != HUB_SUSPEND) {\n\t\t/* Disconnect all the children */\n\t\tfor (i = 0; i < hdev->maxchild; ++i) {\n\t\t\tif (hub->ports[i]->child)\n\t\t\t\tusb_disconnect(&hub->ports[i]->child);\n\t\t}\n\t}\n\n\t/* Stop hub_wq and related activity */\n\tusb_kill_urb(hub->urb);\n\tif (hub->has_indicators)\n\t\tcancel_delayed_work_sync(&hub->leds);\n\tif (hub->tt.hub)\n\t\tflush_work(&hub->tt.clear_work);\n}\n\nstatic void hub_pm_barrier_for_all_ports(struct usb_hub *hub)\n{\n\tint i;\n\n\tfor (i = 0; i < hub->hdev->maxchild; ++i)\n\t\tpm_runtime_barrier(&hub->ports[i]->dev);\n}\n\n/* caller has locked the hub device */\nstatic int hub_pre_reset(struct usb_interface *intf)\n{\n\tstruct usb_hub *hub = usb_get_intfdata(intf);\n\n\thub_quiesce(hub, HUB_PRE_RESET);\n\thub->in_reset = 1;\n\thub_pm_barrier_for_all_ports(hub);\n\treturn 0;\n}\n\n/* caller has locked the hub device */\nstatic int hub_post_reset(struct usb_interface *intf)\n{\n\tstruct usb_hub *hub = usb_get_intfdata(intf);\n\n\thub->in_reset = 0;\n\thub_pm_barrier_for_all_ports(hub);\n\thub_activate(hub, HUB_POST_RESET);\n\treturn 0;\n}\n\nstatic int hub_configure(struct usb_hub *hub,\n\tstruct usb_endpoint_descriptor *endpoint)\n{\n\tstruct usb_hcd *hcd;\n\tstruct usb_device *hdev = hub->hdev;\n\tstruct device *hub_dev = hub->intfdev;\n\tu16 hubstatus, hubchange;\n\tu16 wHubCharacteristics;\n\tunsigned int pipe;\n\tint maxp, ret, i;\n\tchar *message = \"out of memory\";\n\tunsigned unit_load;\n\tunsigned full_load;\n\tunsigned maxchild;\n\n\thub->buffer = kmalloc(sizeof(*hub->buffer), GFP_KERNEL);\n\tif (!hub->buffer) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\thub->status = kmalloc(sizeof(*hub->status), GFP_KERNEL);\n\tif (!hub->status) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\tmutex_init(&hub->status_mutex);\n\n\thub->descriptor = kmalloc(sizeof(*hub->descriptor), GFP_KERNEL);\n\tif (!hub->descriptor) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\t/* Request the entire hub descriptor.\n\t * hub->descriptor can handle USB_MAXCHILDREN ports,\n\t * but the hub can/will return fewer bytes here.\n\t */\n\tret = get_hub_descriptor(hdev, hub->descriptor);\n\tif (ret < 0) {\n\t\tmessage = \"can't read hub descriptor\";\n\t\tgoto fail;\n\t} else if (hub->descriptor->bNbrPorts > USB_MAXCHILDREN) {\n\t\tmessage = \"hub has too many ports!\";\n\t\tret = -ENODEV;\n\t\tgoto fail;\n\t} else if (hub->descriptor->bNbrPorts == 0) {\n\t\tmessage = \"hub doesn't have any ports!\";\n\t\tret = -ENODEV;\n\t\tgoto fail;\n\t}\n\n\tmaxchild = hub->descriptor->bNbrPorts;\n\tdev_info(hub_dev, \"%d port%s detected\\n\", maxchild,\n\t\t\t(maxchild == 1) ? \"\" : \"s\");\n\n\thub->ports = kzalloc(maxchild * sizeof(struct usb_port *), GFP_KERNEL);\n\tif (!hub->ports) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\twHubCharacteristics = le16_to_cpu(hub->descriptor->wHubCharacteristics);\n\tif (hub_is_superspeed(hdev)) {\n\t\tunit_load = 150;\n\t\tfull_load = 900;\n\t} else {\n\t\tunit_load = 100;\n\t\tfull_load = 500;\n\t}\n\n\t/* FIXME for USB 3.0, skip for now */\n\tif ((wHubCharacteristics & HUB_CHAR_COMPOUND) &&\n\t\t\t!(hub_is_superspeed(hdev))) {\n\t\tchar\tportstr[USB_MAXCHILDREN + 1];\n\n\t\tfor (i = 0; i < maxchild; i++)\n\t\t\tportstr[i] = hub->descriptor->u.hs.DeviceRemovable\n\t\t\t\t    [((i + 1) / 8)] & (1 << ((i + 1) % 8))\n\t\t\t\t? 'F' : 'R';\n\t\tportstr[maxchild] = 0;\n\t\tdev_dbg(hub_dev, \"compound device; port removable status: %s\\n\", portstr);\n\t} else\n\t\tdev_dbg(hub_dev, \"standalone hub\\n\");\n\n\tswitch (wHubCharacteristics & HUB_CHAR_LPSM) {\n\tcase HUB_CHAR_COMMON_LPSM:\n\t\tdev_dbg(hub_dev, \"ganged power switching\\n\");\n\t\tbreak;\n\tcase HUB_CHAR_INDV_PORT_LPSM:\n\t\tdev_dbg(hub_dev, \"individual port power switching\\n\");\n\t\tbreak;\n\tcase HUB_CHAR_NO_LPSM:\n\tcase HUB_CHAR_LPSM:\n\t\tdev_dbg(hub_dev, \"no power switching (usb 1.0)\\n\");\n\t\tbreak;\n\t}\n\n\tswitch (wHubCharacteristics & HUB_CHAR_OCPM) {\n\tcase HUB_CHAR_COMMON_OCPM:\n\t\tdev_dbg(hub_dev, \"global over-current protection\\n\");\n\t\tbreak;\n\tcase HUB_CHAR_INDV_PORT_OCPM:\n\t\tdev_dbg(hub_dev, \"individual port over-current protection\\n\");\n\t\tbreak;\n\tcase HUB_CHAR_NO_OCPM:\n\tcase HUB_CHAR_OCPM:\n\t\tdev_dbg(hub_dev, \"no over-current protection\\n\");\n\t\tbreak;\n\t}\n\n\tspin_lock_init(&hub->tt.lock);\n\tINIT_LIST_HEAD(&hub->tt.clear_list);\n\tINIT_WORK(&hub->tt.clear_work, hub_tt_work);\n\tswitch (hdev->descriptor.bDeviceProtocol) {\n\tcase USB_HUB_PR_FS:\n\t\tbreak;\n\tcase USB_HUB_PR_HS_SINGLE_TT:\n\t\tdev_dbg(hub_dev, \"Single TT\\n\");\n\t\thub->tt.hub = hdev;\n\t\tbreak;\n\tcase USB_HUB_PR_HS_MULTI_TT:\n\t\tret = usb_set_interface(hdev, 0, 1);\n\t\tif (ret == 0) {\n\t\t\tdev_dbg(hub_dev, \"TT per port\\n\");\n\t\t\thub->tt.multi = 1;\n\t\t} else\n\t\t\tdev_err(hub_dev, \"Using single TT (err %d)\\n\",\n\t\t\t\tret);\n\t\thub->tt.hub = hdev;\n\t\tbreak;\n\tcase USB_HUB_PR_SS:\n\t\t/* USB 3.0 hubs don't have a TT */\n\t\tbreak;\n\tdefault:\n\t\tdev_dbg(hub_dev, \"Unrecognized hub protocol %d\\n\",\n\t\t\thdev->descriptor.bDeviceProtocol);\n\t\tbreak;\n\t}\n\n\t/* Note 8 FS bit times == (8 bits / 12000000 bps) ~= 666ns */\n\tswitch (wHubCharacteristics & HUB_CHAR_TTTT) {\n\tcase HUB_TTTT_8_BITS:\n\t\tif (hdev->descriptor.bDeviceProtocol != 0) {\n\t\t\thub->tt.think_time = 666;\n\t\t\tdev_dbg(hub_dev, \"TT requires at most %d \"\n\t\t\t\t\t\"FS bit times (%d ns)\\n\",\n\t\t\t\t8, hub->tt.think_time);\n\t\t}\n\t\tbreak;\n\tcase HUB_TTTT_16_BITS:\n\t\thub->tt.think_time = 666 * 2;\n\t\tdev_dbg(hub_dev, \"TT requires at most %d \"\n\t\t\t\t\"FS bit times (%d ns)\\n\",\n\t\t\t16, hub->tt.think_time);\n\t\tbreak;\n\tcase HUB_TTTT_24_BITS:\n\t\thub->tt.think_time = 666 * 3;\n\t\tdev_dbg(hub_dev, \"TT requires at most %d \"\n\t\t\t\t\"FS bit times (%d ns)\\n\",\n\t\t\t24, hub->tt.think_time);\n\t\tbreak;\n\tcase HUB_TTTT_32_BITS:\n\t\thub->tt.think_time = 666 * 4;\n\t\tdev_dbg(hub_dev, \"TT requires at most %d \"\n\t\t\t\t\"FS bit times (%d ns)\\n\",\n\t\t\t32, hub->tt.think_time);\n\t\tbreak;\n\t}\n\n\t/* probe() zeroes hub->indicator[] */\n\tif (wHubCharacteristics & HUB_CHAR_PORTIND) {\n\t\thub->has_indicators = 1;\n\t\tdev_dbg(hub_dev, \"Port indicators are supported\\n\");\n\t}\n\n\tdev_dbg(hub_dev, \"power on to power good time: %dms\\n\",\n\t\thub->descriptor->bPwrOn2PwrGood * 2);\n\n\t/* power budgeting mostly matters with bus-powered hubs,\n\t * and battery-powered root hubs (may provide just 8 mA).\n\t */\n\tret = usb_get_status(hdev, USB_RECIP_DEVICE, 0, &hubstatus);\n\tif (ret) {\n\t\tmessage = \"can't get hub status\";\n\t\tgoto fail;\n\t}\n\thcd = bus_to_hcd(hdev->bus);\n\tif (hdev == hdev->bus->root_hub) {\n\t\tif (hcd->power_budget > 0)\n\t\t\thdev->bus_mA = hcd->power_budget;\n\t\telse\n\t\t\thdev->bus_mA = full_load * maxchild;\n\t\tif (hdev->bus_mA >= full_load)\n\t\t\thub->mA_per_port = full_load;\n\t\telse {\n\t\t\thub->mA_per_port = hdev->bus_mA;\n\t\t\thub->limited_power = 1;\n\t\t}\n\t} else if ((hubstatus & (1 << USB_DEVICE_SELF_POWERED)) == 0) {\n\t\tint remaining = hdev->bus_mA -\n\t\t\thub->descriptor->bHubContrCurrent;\n\n\t\tdev_dbg(hub_dev, \"hub controller current requirement: %dmA\\n\",\n\t\t\thub->descriptor->bHubContrCurrent);\n\t\thub->limited_power = 1;\n\n\t\tif (remaining < maxchild * unit_load)\n\t\t\tdev_warn(hub_dev,\n\t\t\t\t\t\"insufficient power available \"\n\t\t\t\t\t\"to use all downstream ports\\n\");\n\t\thub->mA_per_port = unit_load;\t/* 7.2.1 */\n\n\t} else {\t/* Self-powered external hub */\n\t\t/* FIXME: What about battery-powered external hubs that\n\t\t * provide less current per port? */\n\t\thub->mA_per_port = full_load;\n\t}\n\tif (hub->mA_per_port < full_load)\n\t\tdev_dbg(hub_dev, \"%umA bus power budget for each child\\n\",\n\t\t\t\thub->mA_per_port);\n\n\tret = hub_hub_status(hub, &hubstatus, &hubchange);\n\tif (ret < 0) {\n\t\tmessage = \"can't get hub status\";\n\t\tgoto fail;\n\t}\n\n\t/* local power status reports aren't always correct */\n\tif (hdev->actconfig->desc.bmAttributes & USB_CONFIG_ATT_SELFPOWER)\n\t\tdev_dbg(hub_dev, \"local power source is %s\\n\",\n\t\t\t(hubstatus & HUB_STATUS_LOCAL_POWER)\n\t\t\t? \"lost (inactive)\" : \"good\");\n\n\tif ((wHubCharacteristics & HUB_CHAR_OCPM) == 0)\n\t\tdev_dbg(hub_dev, \"%sover-current condition exists\\n\",\n\t\t\t(hubstatus & HUB_STATUS_OVERCURRENT) ? \"\" : \"no \");\n\n\t/* set up the interrupt endpoint\n\t * We use the EP's maxpacket size instead of (PORTS+1+7)/8\n\t * bytes as USB2.0[11.12.3] says because some hubs are known\n\t * to send more data (and thus cause overflow). For root hubs,\n\t * maxpktsize is defined in hcd.c's fake endpoint descriptors\n\t * to be big enough for at least USB_MAXCHILDREN ports. */\n\tpipe = usb_rcvintpipe(hdev, endpoint->bEndpointAddress);\n\tmaxp = usb_maxpacket(hdev, pipe, usb_pipeout(pipe));\n\n\tif (maxp > sizeof(*hub->buffer))\n\t\tmaxp = sizeof(*hub->buffer);\n\n\thub->urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!hub->urb) {\n\t\tret = -ENOMEM;\n\t\tgoto fail;\n\t}\n\n\tusb_fill_int_urb(hub->urb, hdev, pipe, *hub->buffer, maxp, hub_irq,\n\t\thub, endpoint->bInterval);\n\n\t/* maybe cycle the hub leds */\n\tif (hub->has_indicators && blinkenlights)\n\t\thub->indicator[0] = INDICATOR_CYCLE;\n\n\tmutex_lock(&usb_port_peer_mutex);\n\tfor (i = 0; i < maxchild; i++) {\n\t\tret = usb_hub_create_port_device(hub, i + 1);\n\t\tif (ret < 0) {\n\t\t\tdev_err(hub->intfdev,\n\t\t\t\t\"couldn't create port%d device.\\n\", i + 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\thdev->maxchild = i;\n\tfor (i = 0; i < hdev->maxchild; i++) {\n\t\tstruct usb_port *port_dev = hub->ports[i];\n\n\t\tpm_runtime_put(&port_dev->dev);\n\t}\n\n\tmutex_unlock(&usb_port_peer_mutex);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\t/* Update the HCD's internal representation of this hub before hub_wq\n\t * starts getting port status changes for devices under the hub.\n\t */\n\tif (hcd->driver->update_hub_device) {\n\t\tret = hcd->driver->update_hub_device(hcd, hdev,\n\t\t\t\t&hub->tt, GFP_KERNEL);\n\t\tif (ret < 0) {\n\t\t\tmessage = \"can't update HCD hub info\";\n\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tusb_hub_adjust_deviceremovable(hdev, hub->descriptor);\n\n\thub_activate(hub, HUB_INIT);\n\treturn 0;\n\nfail:\n\tdev_err(hub_dev, \"config failed, %s (err %d)\\n\",\n\t\t\tmessage, ret);\n\t/* hub_disconnect() frees urb and descriptor */\n\treturn ret;\n}\n\nstatic void hub_release(struct kref *kref)\n{\n\tstruct usb_hub *hub = container_of(kref, struct usb_hub, kref);\n\n\tusb_put_dev(hub->hdev);\n\tusb_put_intf(to_usb_interface(hub->intfdev));\n\tkfree(hub);\n}\n\nstatic unsigned highspeed_hubs;\n\nstatic void hub_disconnect(struct usb_interface *intf)\n{\n\tstruct usb_hub *hub = usb_get_intfdata(intf);\n\tstruct usb_device *hdev = interface_to_usbdev(intf);\n\tint port1;\n\n\t/*\n\t * Stop adding new hub events. We do not want to block here and thus\n\t * will not try to remove any pending work item.\n\t */\n\thub->disconnected = 1;\n\n\t/* Disconnect all children and quiesce the hub */\n\thub->error = 0;\n\thub_quiesce(hub, HUB_DISCONNECT);\n\n\tmutex_lock(&usb_port_peer_mutex);\n\n\t/* Avoid races with recursively_mark_NOTATTACHED() */\n\tspin_lock_irq(&device_state_lock);\n\tport1 = hdev->maxchild;\n\thdev->maxchild = 0;\n\tusb_set_intfdata(intf, NULL);\n\tspin_unlock_irq(&device_state_lock);\n\n\tfor (; port1 > 0; --port1)\n\t\tusb_hub_remove_port_device(hub, port1);\n\n\tmutex_unlock(&usb_port_peer_mutex);\n\n\tif (hub->hdev->speed == USB_SPEED_HIGH)\n\t\thighspeed_hubs--;\n\n\tusb_free_urb(hub->urb);\n\tkfree(hub->ports);\n\tkfree(hub->descriptor);\n\tkfree(hub->status);\n\tkfree(hub->buffer);\n\n\tpm_suspend_ignore_children(&intf->dev, false);\n\tkref_put(&hub->kref, hub_release);\n}\n\nstatic int hub_probe(struct usb_interface *intf, const struct usb_device_id *id)\n{\n\tstruct usb_host_interface *desc;\n\tstruct usb_endpoint_descriptor *endpoint;\n\tstruct usb_device *hdev;\n\tstruct usb_hub *hub;\n\n\tdesc = intf->cur_altsetting;\n\thdev = interface_to_usbdev(intf);\n\n\t/*\n\t * Set default autosuspend delay as 0 to speedup bus suspend,\n\t * based on the below considerations:\n\t *\n\t * - Unlike other drivers, the hub driver does not rely on the\n\t *   autosuspend delay to provide enough time to handle a wakeup\n\t *   event, and the submitted status URB is just to check future\n\t *   change on hub downstream ports, so it is safe to do it.\n\t *\n\t * - The patch might cause one or more auto supend/resume for\n\t *   below very rare devices when they are plugged into hub\n\t *   first time:\n\t *\n\t *   \tdevices having trouble initializing, and disconnect\n\t *   \tthemselves from the bus and then reconnect a second\n\t *   \tor so later\n\t *\n\t *   \tdevices just for downloading firmware, and disconnects\n\t *   \tthemselves after completing it\n\t *\n\t *   For these quite rare devices, their drivers may change the\n\t *   autosuspend delay of their parent hub in the probe() to one\n\t *   appropriate value to avoid the subtle problem if someone\n\t *   does care it.\n\t *\n\t * - The patch may cause one or more auto suspend/resume on\n\t *   hub during running 'lsusb', but it is probably too\n\t *   infrequent to worry about.\n\t *\n\t * - Change autosuspend delay of hub can avoid unnecessary auto\n\t *   suspend timer for hub, also may decrease power consumption\n\t *   of USB bus.\n\t *\n\t * - If user has indicated to prevent autosuspend by passing\n\t *   usbcore.autosuspend = -1 then keep autosuspend disabled.\n\t */\n#ifdef CONFIG_PM\n\tif (hdev->dev.power.autosuspend_delay >= 0)\n\t\tpm_runtime_set_autosuspend_delay(&hdev->dev, 0);\n#endif\n\n\t/*\n\t * Hubs have proper suspend/resume support, except for root hubs\n\t * where the controller driver doesn't have bus_suspend and\n\t * bus_resume methods.\n\t */\n\tif (hdev->parent) {\t\t/* normal device */\n\t\tusb_enable_autosuspend(hdev);\n\t} else {\t\t\t/* root hub */\n\t\tconst struct hc_driver *drv = bus_to_hcd(hdev->bus)->driver;\n\n\t\tif (drv->bus_suspend && drv->bus_resume)\n\t\t\tusb_enable_autosuspend(hdev);\n\t}\n\n\tif (hdev->level == MAX_TOPO_LEVEL) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"Unsupported bus topology: hub nested too deep\\n\");\n\t\treturn -E2BIG;\n\t}\n\n#ifdef\tCONFIG_USB_OTG_BLACKLIST_HUB\n\tif (hdev->parent) {\n\t\tdev_warn(&intf->dev, \"ignoring external hub\\n\");\n\t\treturn -ENODEV;\n\t}\n#endif\n\n\t/* Some hubs have a subclass of 1, which AFAICT according to the */\n\t/*  specs is not defined, but it works */\n\tif ((desc->desc.bInterfaceSubClass != 0) &&\n\t    (desc->desc.bInterfaceSubClass != 1)) {\ndescriptor_error:\n\t\tdev_err(&intf->dev, \"bad descriptor, ignoring hub\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* Multiple endpoints? What kind of mutant ninja-hub is this? */\n\tif (desc->desc.bNumEndpoints != 1)\n\t\tgoto descriptor_error;\n\n\tendpoint = &desc->endpoint[0].desc;\n\n\t/* If it's not an interrupt in endpoint, we'd better punt! */\n\tif (!usb_endpoint_is_int_in(endpoint))\n\t\tgoto descriptor_error;\n\n\t/* We found a hub */\n\tdev_info(&intf->dev, \"USB hub found\\n\");\n\n\thub = kzalloc(sizeof(*hub), GFP_KERNEL);\n\tif (!hub) {\n\t\tdev_dbg(&intf->dev, \"couldn't kmalloc hub struct\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tkref_init(&hub->kref);\n\thub->intfdev = &intf->dev;\n\thub->hdev = hdev;\n\tINIT_DELAYED_WORK(&hub->leds, led_work);\n\tINIT_DELAYED_WORK(&hub->init_work, NULL);\n\tINIT_WORK(&hub->events, hub_event);\n\tusb_get_intf(intf);\n\tusb_get_dev(hdev);\n\n\tusb_set_intfdata(intf, hub);\n\tintf->needs_remote_wakeup = 1;\n\tpm_suspend_ignore_children(&intf->dev, true);\n\n\tif (hdev->speed == USB_SPEED_HIGH)\n\t\thighspeed_hubs++;\n\n\tif (id->driver_info & HUB_QUIRK_CHECK_PORT_AUTOSUSPEND)\n\t\thub->quirk_check_port_auto_suspend = 1;\n\n\tif (hub_configure(hub, endpoint) >= 0)\n\t\treturn 0;\n\n\thub_disconnect(intf);\n\treturn -ENODEV;\n}\n\nstatic int\nhub_ioctl(struct usb_interface *intf, unsigned int code, void *user_data)\n{\n\tstruct usb_device *hdev = interface_to_usbdev(intf);\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\n\t/* assert ifno == 0 (part of hub spec) */\n\tswitch (code) {\n\tcase USBDEVFS_HUB_PORTINFO: {\n\t\tstruct usbdevfs_hub_portinfo *info = user_data;\n\t\tint i;\n\n\t\tspin_lock_irq(&device_state_lock);\n\t\tif (hdev->devnum <= 0)\n\t\t\tinfo->nports = 0;\n\t\telse {\n\t\t\tinfo->nports = hdev->maxchild;\n\t\t\tfor (i = 0; i < info->nports; i++) {\n\t\t\t\tif (hub->ports[i]->child == NULL)\n\t\t\t\t\tinfo->port[i] = 0;\n\t\t\t\telse\n\t\t\t\t\tinfo->port[i] =\n\t\t\t\t\t\thub->ports[i]->child->devnum;\n\t\t\t}\n\t\t}\n\t\tspin_unlock_irq(&device_state_lock);\n\n\t\treturn info->nports + 1;\n\t\t}\n\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n}\n\n/*\n * Allow user programs to claim ports on a hub.  When a device is attached\n * to one of these \"claimed\" ports, the program will \"own\" the device.\n */\nstatic int find_port_owner(struct usb_device *hdev, unsigned port1,\n\t\tstruct usb_dev_state ***ppowner)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\n\tif (hdev->state == USB_STATE_NOTATTACHED)\n\t\treturn -ENODEV;\n\tif (port1 == 0 || port1 > hdev->maxchild)\n\t\treturn -EINVAL;\n\n\t/* Devices not managed by the hub driver\n\t * will always have maxchild equal to 0.\n\t */\n\t*ppowner = &(hub->ports[port1 - 1]->port_owner);\n\treturn 0;\n}\n\n/* In the following three functions, the caller must hold hdev's lock */\nint usb_hub_claim_port(struct usb_device *hdev, unsigned port1,\n\t\t       struct usb_dev_state *owner)\n{\n\tint rc;\n\tstruct usb_dev_state **powner;\n\n\trc = find_port_owner(hdev, port1, &powner);\n\tif (rc)\n\t\treturn rc;\n\tif (*powner)\n\t\treturn -EBUSY;\n\t*powner = owner;\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(usb_hub_claim_port);\n\nint usb_hub_release_port(struct usb_device *hdev, unsigned port1,\n\t\t\t struct usb_dev_state *owner)\n{\n\tint rc;\n\tstruct usb_dev_state **powner;\n\n\trc = find_port_owner(hdev, port1, &powner);\n\tif (rc)\n\t\treturn rc;\n\tif (*powner != owner)\n\t\treturn -ENOENT;\n\t*powner = NULL;\n\treturn rc;\n}\nEXPORT_SYMBOL_GPL(usb_hub_release_port);\n\nvoid usb_hub_release_all_ports(struct usb_device *hdev, struct usb_dev_state *owner)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\tint n;\n\n\tfor (n = 0; n < hdev->maxchild; n++) {\n\t\tif (hub->ports[n]->port_owner == owner)\n\t\t\thub->ports[n]->port_owner = NULL;\n\t}\n\n}\n\n/* The caller must hold udev's lock */\nbool usb_device_is_owned(struct usb_device *udev)\n{\n\tstruct usb_hub *hub;\n\n\tif (udev->state == USB_STATE_NOTATTACHED || !udev->parent)\n\t\treturn false;\n\thub = usb_hub_to_struct_hub(udev->parent);\n\treturn !!hub->ports[udev->portnum - 1]->port_owner;\n}\n\nstatic void recursively_mark_NOTATTACHED(struct usb_device *udev)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(udev);\n\tint i;\n\n\tfor (i = 0; i < udev->maxchild; ++i) {\n\t\tif (hub->ports[i]->child)\n\t\t\trecursively_mark_NOTATTACHED(hub->ports[i]->child);\n\t}\n\tif (udev->state == USB_STATE_SUSPENDED)\n\t\tudev->active_duration -= jiffies;\n\tudev->state = USB_STATE_NOTATTACHED;\n}\n\n/**\n * usb_set_device_state - change a device's current state (usbcore, hcds)\n * @udev: pointer to device whose state should be changed\n * @new_state: new state value to be stored\n *\n * udev->state is _not_ fully protected by the device lock.  Although\n * most transitions are made only while holding the lock, the state can\n * can change to USB_STATE_NOTATTACHED at almost any time.  This\n * is so that devices can be marked as disconnected as soon as possible,\n * without having to wait for any semaphores to be released.  As a result,\n * all changes to any device's state must be protected by the\n * device_state_lock spinlock.\n *\n * Once a device has been added to the device tree, all changes to its state\n * should be made using this routine.  The state should _not_ be set directly.\n *\n * If udev->state is already USB_STATE_NOTATTACHED then no change is made.\n * Otherwise udev->state is set to new_state, and if new_state is\n * USB_STATE_NOTATTACHED then all of udev's descendants' states are also set\n * to USB_STATE_NOTATTACHED.\n */\nvoid usb_set_device_state(struct usb_device *udev,\n\t\tenum usb_device_state new_state)\n{\n\tunsigned long flags;\n\tint wakeup = -1;\n\n\tspin_lock_irqsave(&device_state_lock, flags);\n\tif (udev->state == USB_STATE_NOTATTACHED)\n\t\t;\t/* do nothing */\n\telse if (new_state != USB_STATE_NOTATTACHED) {\n\n\t\t/* root hub wakeup capabilities are managed out-of-band\n\t\t * and may involve silicon errata ... ignore them here.\n\t\t */\n\t\tif (udev->parent) {\n\t\t\tif (udev->state == USB_STATE_SUSPENDED\n\t\t\t\t\t|| new_state == USB_STATE_SUSPENDED)\n\t\t\t\t;\t/* No change to wakeup settings */\n\t\t\telse if (new_state == USB_STATE_CONFIGURED)\n\t\t\t\twakeup = (udev->quirks &\n\t\t\t\t\tUSB_QUIRK_IGNORE_REMOTE_WAKEUP) ? 0 :\n\t\t\t\t\tudev->actconfig->desc.bmAttributes &\n\t\t\t\t\tUSB_CONFIG_ATT_WAKEUP;\n\t\t\telse\n\t\t\t\twakeup = 0;\n\t\t}\n\t\tif (udev->state == USB_STATE_SUSPENDED &&\n\t\t\tnew_state != USB_STATE_SUSPENDED)\n\t\t\tudev->active_duration -= jiffies;\n\t\telse if (new_state == USB_STATE_SUSPENDED &&\n\t\t\t\tudev->state != USB_STATE_SUSPENDED)\n\t\t\tudev->active_duration += jiffies;\n\t\tudev->state = new_state;\n\t} else\n\t\trecursively_mark_NOTATTACHED(udev);\n\tspin_unlock_irqrestore(&device_state_lock, flags);\n\tif (wakeup >= 0)\n\t\tdevice_set_wakeup_capable(&udev->dev, wakeup);\n}\nEXPORT_SYMBOL_GPL(usb_set_device_state);\n\n/*\n * Choose a device number.\n *\n * Device numbers are used as filenames in usbfs.  On USB-1.1 and\n * USB-2.0 buses they are also used as device addresses, however on\n * USB-3.0 buses the address is assigned by the controller hardware\n * and it usually is not the same as the device number.\n *\n * WUSB devices are simple: they have no hubs behind, so the mapping\n * device <-> virtual port number becomes 1:1. Why? to simplify the\n * life of the device connection logic in\n * drivers/usb/wusbcore/devconnect.c. When we do the initial secret\n * handshake we need to assign a temporary address in the unauthorized\n * space. For simplicity we use the first virtual port number found to\n * be free [drivers/usb/wusbcore/devconnect.c:wusbhc_devconnect_ack()]\n * and that becomes it's address [X < 128] or its unauthorized address\n * [X | 0x80].\n *\n * We add 1 as an offset to the one-based USB-stack port number\n * (zero-based wusb virtual port index) for two reasons: (a) dev addr\n * 0 is reserved by USB for default address; (b) Linux's USB stack\n * uses always #1 for the root hub of the controller. So USB stack's\n * port #1, which is wusb virtual-port #0 has address #2.\n *\n * Devices connected under xHCI are not as simple.  The host controller\n * supports virtualization, so the hardware assigns device addresses and\n * the HCD must setup data structures before issuing a set address\n * command to the hardware.\n */\nstatic void choose_devnum(struct usb_device *udev)\n{\n\tint\t\tdevnum;\n\tstruct usb_bus\t*bus = udev->bus;\n\n\t/* be safe when more hub events are proceed in parallel */\n\tmutex_lock(&bus->usb_address0_mutex);\n\tif (udev->wusb) {\n\t\tdevnum = udev->portnum + 1;\n\t\tBUG_ON(test_bit(devnum, bus->devmap.devicemap));\n\t} else {\n\t\t/* Try to allocate the next devnum beginning at\n\t\t * bus->devnum_next. */\n\t\tdevnum = find_next_zero_bit(bus->devmap.devicemap, 128,\n\t\t\t\t\t    bus->devnum_next);\n\t\tif (devnum >= 128)\n\t\t\tdevnum = find_next_zero_bit(bus->devmap.devicemap,\n\t\t\t\t\t\t    128, 1);\n\t\tbus->devnum_next = (devnum >= 127 ? 1 : devnum + 1);\n\t}\n\tif (devnum < 128) {\n\t\tset_bit(devnum, bus->devmap.devicemap);\n\t\tudev->devnum = devnum;\n\t}\n\tmutex_unlock(&bus->usb_address0_mutex);\n}\n\nstatic void release_devnum(struct usb_device *udev)\n{\n\tif (udev->devnum > 0) {\n\t\tclear_bit(udev->devnum, udev->bus->devmap.devicemap);\n\t\tudev->devnum = -1;\n\t}\n}\n\nstatic void update_devnum(struct usb_device *udev, int devnum)\n{\n\t/* The address for a WUSB device is managed by wusbcore. */\n\tif (!udev->wusb)\n\t\tudev->devnum = devnum;\n}\n\nstatic void hub_free_dev(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\t/* Root hubs aren't real devices, so don't free HCD resources */\n\tif (hcd->driver->free_dev && udev->parent)\n\t\thcd->driver->free_dev(hcd, udev);\n}\n\nstatic void hub_disconnect_children(struct usb_device *udev)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(udev);\n\tint i;\n\n\t/* Free up all the children before we remove this device */\n\tfor (i = 0; i < udev->maxchild; i++) {\n\t\tif (hub->ports[i]->child)\n\t\t\tusb_disconnect(&hub->ports[i]->child);\n\t}\n}\n\n/**\n * usb_disconnect - disconnect a device (usbcore-internal)\n * @pdev: pointer to device being disconnected\n * Context: !in_interrupt ()\n *\n * Something got disconnected. Get rid of it and all of its children.\n *\n * If *pdev is a normal device then the parent hub must already be locked.\n * If *pdev is a root hub then the caller must hold the usb_bus_list_lock,\n * which protects the set of root hubs as well as the list of buses.\n *\n * Only hub drivers (including virtual root hub drivers for host\n * controllers) should ever call this.\n *\n * This call is synchronous, and may not be used in an interrupt context.\n */\nvoid usb_disconnect(struct usb_device **pdev)\n{\n\tstruct usb_port *port_dev = NULL;\n\tstruct usb_device *udev = *pdev;\n\tstruct usb_hub *hub = NULL;\n\tint port1 = 1;\n\n\t/* mark the device as inactive, so any further urb submissions for\n\t * this device (and any of its children) will fail immediately.\n\t * this quiesces everything except pending urbs.\n\t */\n\tusb_set_device_state(udev, USB_STATE_NOTATTACHED);\n\tdev_info(&udev->dev, \"USB disconnect, device number %d\\n\",\n\t\t\tudev->devnum);\n\n\tusb_lock_device(udev);\n\n\thub_disconnect_children(udev);\n\n\t/* deallocate hcd/hardware state ... nuking all pending urbs and\n\t * cleaning up all state associated with the current configuration\n\t * so that the hardware is now fully quiesced.\n\t */\n\tdev_dbg(&udev->dev, \"unregistering device\\n\");\n\tusb_disable_device(udev, 0);\n\tusb_hcd_synchronize_unlinks(udev);\n\n\tif (udev->parent) {\n\t\tport1 = udev->portnum;\n\t\thub = usb_hub_to_struct_hub(udev->parent);\n\t\tport_dev = hub->ports[port1 - 1];\n\n\t\tsysfs_remove_link(&udev->dev.kobj, \"port\");\n\t\tsysfs_remove_link(&port_dev->dev.kobj, \"device\");\n\n\t\t/*\n\t\t * As usb_port_runtime_resume() de-references udev, make\n\t\t * sure no resumes occur during removal\n\t\t */\n\t\tif (!test_and_set_bit(port1, hub->child_usage_bits))\n\t\t\tpm_runtime_get_sync(&port_dev->dev);\n\t}\n\n\tusb_remove_ep_devs(&udev->ep0);\n\tusb_unlock_device(udev);\n\n\t/* Unregister the device.  The device driver is responsible\n\t * for de-configuring the device and invoking the remove-device\n\t * notifier chain (used by usbfs and possibly others).\n\t */\n\tdevice_del(&udev->dev);\n\n\t/* Free the device number and delete the parent's children[]\n\t * (or root_hub) pointer.\n\t */\n\trelease_devnum(udev);\n\n\t/* Avoid races with recursively_mark_NOTATTACHED() */\n\tspin_lock_irq(&device_state_lock);\n\t*pdev = NULL;\n\tspin_unlock_irq(&device_state_lock);\n\n\tif (port_dev && test_and_clear_bit(port1, hub->child_usage_bits))\n\t\tpm_runtime_put(&port_dev->dev);\n\n\thub_free_dev(udev);\n\n\tput_device(&udev->dev);\n}\n\n#ifdef CONFIG_USB_ANNOUNCE_NEW_DEVICES\nstatic void show_string(struct usb_device *udev, char *id, char *string)\n{\n\tif (!string)\n\t\treturn;\n\tdev_info(&udev->dev, \"%s: %s\\n\", id, string);\n}\n\nstatic void announce_device(struct usb_device *udev)\n{\n\tdev_info(&udev->dev, \"New USB device found, idVendor=%04x, idProduct=%04x\\n\",\n\t\tle16_to_cpu(udev->descriptor.idVendor),\n\t\tle16_to_cpu(udev->descriptor.idProduct));\n\tdev_info(&udev->dev,\n\t\t\"New USB device strings: Mfr=%d, Product=%d, SerialNumber=%d\\n\",\n\t\tudev->descriptor.iManufacturer,\n\t\tudev->descriptor.iProduct,\n\t\tudev->descriptor.iSerialNumber);\n\tshow_string(udev, \"Product\", udev->product);\n\tshow_string(udev, \"Manufacturer\", udev->manufacturer);\n\tshow_string(udev, \"SerialNumber\", udev->serial);\n}\n#else\nstatic inline void announce_device(struct usb_device *udev) { }\n#endif\n\n\n/**\n * usb_enumerate_device_otg - FIXME (usbcore-internal)\n * @udev: newly addressed device (in ADDRESS state)\n *\n * Finish enumeration for On-The-Go devices\n *\n * Return: 0 if successful. A negative error code otherwise.\n */\nstatic int usb_enumerate_device_otg(struct usb_device *udev)\n{\n\tint err = 0;\n\n#ifdef\tCONFIG_USB_OTG\n\t/*\n\t * OTG-aware devices on OTG-capable root hubs may be able to use SRP,\n\t * to wake us after we've powered off VBUS; and HNP, switching roles\n\t * \"host\" to \"peripheral\".  The OTG descriptor helps figure this out.\n\t */\n\tif (!udev->bus->is_b_host\n\t\t\t&& udev->config\n\t\t\t&& udev->parent == udev->bus->root_hub) {\n\t\tstruct usb_otg_descriptor\t*desc = NULL;\n\t\tstruct usb_bus\t\t\t*bus = udev->bus;\n\t\tunsigned\t\t\tport1 = udev->portnum;\n\n\t\t/* descriptor may appear anywhere in config */\n\t\terr = __usb_get_extra_descriptor(udev->rawdescriptors[0],\n\t\t\t\tle16_to_cpu(udev->config[0].desc.wTotalLength),\n\t\t\t\tUSB_DT_OTG, (void **) &desc);\n\t\tif (err || !(desc->bmAttributes & USB_OTG_HNP))\n\t\t\treturn 0;\n\n\t\tdev_info(&udev->dev, \"Dual-Role OTG device on %sHNP port\\n\",\n\t\t\t\t\t(port1 == bus->otg_port) ? \"\" : \"non-\");\n\n\t\t/* enable HNP before suspend, it's simpler */\n\t\tif (port1 == bus->otg_port) {\n\t\t\tbus->b_hnp_enable = 1;\n\t\t\terr = usb_control_msg(udev,\n\t\t\t\tusb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, 0,\n\t\t\t\tUSB_DEVICE_B_HNP_ENABLE,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t\tif (err < 0) {\n\t\t\t\t/*\n\t\t\t\t * OTG MESSAGE: report errors here,\n\t\t\t\t * customize to match your product.\n\t\t\t\t */\n\t\t\t\tdev_err(&udev->dev, \"can't set HNP mode: %d\\n\",\n\t\t\t\t\t\t\t\t\terr);\n\t\t\t\tbus->b_hnp_enable = 0;\n\t\t\t}\n\t\t} else if (desc->bLength == sizeof\n\t\t\t\t(struct usb_otg_descriptor)) {\n\t\t\t/* Set a_alt_hnp_support for legacy otg device */\n\t\t\terr = usb_control_msg(udev,\n\t\t\t\tusb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, 0,\n\t\t\t\tUSB_DEVICE_A_ALT_HNP_SUPPORT,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t\tif (err < 0)\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"set a_alt_hnp_support failed: %d\\n\",\n\t\t\t\t\terr);\n\t\t}\n\t}\n#endif\n\treturn err;\n}\n\n\n/**\n * usb_enumerate_device - Read device configs/intfs/otg (usbcore-internal)\n * @udev: newly addressed device (in ADDRESS state)\n *\n * This is only called by usb_new_device() and usb_authorize_device()\n * and FIXME -- all comments that apply to them apply here wrt to\n * environment.\n *\n * If the device is WUSB and not authorized, we don't attempt to read\n * the string descriptors, as they will be errored out by the device\n * until it has been authorized.\n *\n * Return: 0 if successful. A negative error code otherwise.\n */\nstatic int usb_enumerate_device(struct usb_device *udev)\n{\n\tint err;\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\tif (udev->config == NULL) {\n\t\terr = usb_get_configuration(udev);\n\t\tif (err < 0) {\n\t\t\tif (err != -ENODEV)\n\t\t\t\tdev_err(&udev->dev, \"can't read configurations, error %d\\n\",\n\t\t\t\t\t\terr);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\t/* read the standard strings and cache them if present */\n\tudev->product = usb_cache_string(udev, udev->descriptor.iProduct);\n\tudev->manufacturer = usb_cache_string(udev,\n\t\t\t\t\t      udev->descriptor.iManufacturer);\n\tudev->serial = usb_cache_string(udev, udev->descriptor.iSerialNumber);\n\n\terr = usb_enumerate_device_otg(udev);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (IS_ENABLED(CONFIG_USB_OTG_WHITELIST) && hcd->tpl_support &&\n\t\t!is_targeted(udev)) {\n\t\t/* Maybe it can talk to us, though we can't talk to it.\n\t\t * (Includes HNP test device.)\n\t\t */\n\t\tif (IS_ENABLED(CONFIG_USB_OTG) && (udev->bus->b_hnp_enable\n\t\t\t|| udev->bus->is_b_host)) {\n\t\t\terr = usb_port_suspend(udev, PMSG_AUTO_SUSPEND);\n\t\t\tif (err < 0)\n\t\t\t\tdev_dbg(&udev->dev, \"HNP fail, %d\\n\", err);\n\t\t}\n\t\treturn -ENOTSUPP;\n\t}\n\n\tusb_detect_interface_quirks(udev);\n\n\treturn 0;\n}\n\nstatic void set_usb_port_removable(struct usb_device *udev)\n{\n\tstruct usb_device *hdev = udev->parent;\n\tstruct usb_hub *hub;\n\tu8 port = udev->portnum;\n\tu16 wHubCharacteristics;\n\tbool removable = true;\n\n\tif (!hdev)\n\t\treturn;\n\n\thub = usb_hub_to_struct_hub(udev->parent);\n\n\t/*\n\t * If the platform firmware has provided information about a port,\n\t * use that to determine whether it's removable.\n\t */\n\tswitch (hub->ports[udev->portnum - 1]->connect_type) {\n\tcase USB_PORT_CONNECT_TYPE_HOT_PLUG:\n\t\tudev->removable = USB_DEVICE_REMOVABLE;\n\t\treturn;\n\tcase USB_PORT_CONNECT_TYPE_HARD_WIRED:\n\tcase USB_PORT_NOT_USED:\n\t\tudev->removable = USB_DEVICE_FIXED;\n\t\treturn;\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/*\n\t * Otherwise, check whether the hub knows whether a port is removable\n\t * or not\n\t */\n\twHubCharacteristics = le16_to_cpu(hub->descriptor->wHubCharacteristics);\n\n\tif (!(wHubCharacteristics & HUB_CHAR_COMPOUND))\n\t\treturn;\n\n\tif (hub_is_superspeed(hdev)) {\n\t\tif (le16_to_cpu(hub->descriptor->u.ss.DeviceRemovable)\n\t\t\t\t& (1 << port))\n\t\t\tremovable = false;\n\t} else {\n\t\tif (hub->descriptor->u.hs.DeviceRemovable[port / 8] & (1 << (port % 8)))\n\t\t\tremovable = false;\n\t}\n\n\tif (removable)\n\t\tudev->removable = USB_DEVICE_REMOVABLE;\n\telse\n\t\tudev->removable = USB_DEVICE_FIXED;\n\n}\n\n/**\n * usb_new_device - perform initial device setup (usbcore-internal)\n * @udev: newly addressed device (in ADDRESS state)\n *\n * This is called with devices which have been detected but not fully\n * enumerated.  The device descriptor is available, but not descriptors\n * for any device configuration.  The caller must have locked either\n * the parent hub (if udev is a normal device) or else the\n * usb_bus_list_lock (if udev is a root hub).  The parent's pointer to\n * udev has already been installed, but udev is not yet visible through\n * sysfs or other filesystem code.\n *\n * This call is synchronous, and may not be used in an interrupt context.\n *\n * Only the hub driver or root-hub registrar should ever call this.\n *\n * Return: Whether the device is configured properly or not. Zero if the\n * interface was registered with the driver core; else a negative errno\n * value.\n *\n */\nint usb_new_device(struct usb_device *udev)\n{\n\tint err;\n\n\tif (udev->parent) {\n\t\t/* Initialize non-root-hub device wakeup to disabled;\n\t\t * device (un)configuration controls wakeup capable\n\t\t * sysfs power/wakeup controls wakeup enabled/disabled\n\t\t */\n\t\tdevice_init_wakeup(&udev->dev, 0);\n\t}\n\n\t/* Tell the runtime-PM framework the device is active */\n\tpm_runtime_set_active(&udev->dev);\n\tpm_runtime_get_noresume(&udev->dev);\n\tpm_runtime_use_autosuspend(&udev->dev);\n\tpm_runtime_enable(&udev->dev);\n\n\t/* By default, forbid autosuspend for all devices.  It will be\n\t * allowed for hubs during binding.\n\t */\n\tusb_disable_autosuspend(udev);\n\n\terr = usb_enumerate_device(udev);\t/* Read descriptors */\n\tif (err < 0)\n\t\tgoto fail;\n\tdev_dbg(&udev->dev, \"udev %d, busnum %d, minor = %d\\n\",\n\t\t\tudev->devnum, udev->bus->busnum,\n\t\t\t(((udev->bus->busnum-1) * 128) + (udev->devnum-1)));\n\t/* export the usbdev device-node for libusb */\n\tudev->dev.devt = MKDEV(USB_DEVICE_MAJOR,\n\t\t\t(((udev->bus->busnum-1) * 128) + (udev->devnum-1)));\n\n\t/* Tell the world! */\n\tannounce_device(udev);\n\n\tif (udev->serial)\n\t\tadd_device_randomness(udev->serial, strlen(udev->serial));\n\tif (udev->product)\n\t\tadd_device_randomness(udev->product, strlen(udev->product));\n\tif (udev->manufacturer)\n\t\tadd_device_randomness(udev->manufacturer,\n\t\t\t\t      strlen(udev->manufacturer));\n\n\tdevice_enable_async_suspend(&udev->dev);\n\n\t/* check whether the hub or firmware marks this port as non-removable */\n\tif (udev->parent)\n\t\tset_usb_port_removable(udev);\n\n\t/* Register the device.  The device driver is responsible\n\t * for configuring the device and invoking the add-device\n\t * notifier chain (used by usbfs and possibly others).\n\t */\n\terr = device_add(&udev->dev);\n\tif (err) {\n\t\tdev_err(&udev->dev, \"can't device_add, error %d\\n\", err);\n\t\tgoto fail;\n\t}\n\n\t/* Create link files between child device and usb port device. */\n\tif (udev->parent) {\n\t\tstruct usb_hub *hub = usb_hub_to_struct_hub(udev->parent);\n\t\tint port1 = udev->portnum;\n\t\tstruct usb_port\t*port_dev = hub->ports[port1 - 1];\n\n\t\terr = sysfs_create_link(&udev->dev.kobj,\n\t\t\t\t&port_dev->dev.kobj, \"port\");\n\t\tif (err)\n\t\t\tgoto fail;\n\n\t\terr = sysfs_create_link(&port_dev->dev.kobj,\n\t\t\t\t&udev->dev.kobj, \"device\");\n\t\tif (err) {\n\t\t\tsysfs_remove_link(&udev->dev.kobj, \"port\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (!test_and_set_bit(port1, hub->child_usage_bits))\n\t\t\tpm_runtime_get_sync(&port_dev->dev);\n\t}\n\n\t(void) usb_create_ep_devs(&udev->dev, &udev->ep0, udev);\n\tusb_mark_last_busy(udev);\n\tpm_runtime_put_sync_autosuspend(&udev->dev);\n\treturn err;\n\nfail:\n\tusb_set_device_state(udev, USB_STATE_NOTATTACHED);\n\tpm_runtime_disable(&udev->dev);\n\tpm_runtime_set_suspended(&udev->dev);\n\treturn err;\n}\n\n\n/**\n * usb_deauthorize_device - deauthorize a device (usbcore-internal)\n * @usb_dev: USB device\n *\n * Move the USB device to a very basic state where interfaces are disabled\n * and the device is in fact unconfigured and unusable.\n *\n * We share a lock (that we have) with device_del(), so we need to\n * defer its call.\n *\n * Return: 0.\n */\nint usb_deauthorize_device(struct usb_device *usb_dev)\n{\n\tusb_lock_device(usb_dev);\n\tif (usb_dev->authorized == 0)\n\t\tgoto out_unauthorized;\n\n\tusb_dev->authorized = 0;\n\tusb_set_configuration(usb_dev, -1);\n\nout_unauthorized:\n\tusb_unlock_device(usb_dev);\n\treturn 0;\n}\n\n\nint usb_authorize_device(struct usb_device *usb_dev)\n{\n\tint result = 0, c;\n\n\tusb_lock_device(usb_dev);\n\tif (usb_dev->authorized == 1)\n\t\tgoto out_authorized;\n\n\tresult = usb_autoresume_device(usb_dev);\n\tif (result < 0) {\n\t\tdev_err(&usb_dev->dev,\n\t\t\t\"can't autoresume for authorization: %d\\n\", result);\n\t\tgoto error_autoresume;\n\t}\n\n\tif (usb_dev->wusb) {\n\t\tresult = usb_get_device_descriptor(usb_dev, sizeof(usb_dev->descriptor));\n\t\tif (result < 0) {\n\t\t\tdev_err(&usb_dev->dev, \"can't re-read device descriptor for \"\n\t\t\t\t\"authorization: %d\\n\", result);\n\t\t\tgoto error_device_descriptor;\n\t\t}\n\t}\n\n\tusb_dev->authorized = 1;\n\t/* Choose and set the configuration.  This registers the interfaces\n\t * with the driver core and lets interface drivers bind to them.\n\t */\n\tc = usb_choose_configuration(usb_dev);\n\tif (c >= 0) {\n\t\tresult = usb_set_configuration(usb_dev, c);\n\t\tif (result) {\n\t\t\tdev_err(&usb_dev->dev,\n\t\t\t\t\"can't set config #%d, error %d\\n\", c, result);\n\t\t\t/* This need not be fatal.  The user can try to\n\t\t\t * set other configurations. */\n\t\t}\n\t}\n\tdev_info(&usb_dev->dev, \"authorized to connect\\n\");\n\nerror_device_descriptor:\n\tusb_autosuspend_device(usb_dev);\nerror_autoresume:\nout_authorized:\n\tusb_unlock_device(usb_dev);\t/* complements locktree */\n\treturn result;\n}\n\n\n/* Returns 1 if @hub is a WUSB root hub, 0 otherwise */\nstatic unsigned hub_is_wusb(struct usb_hub *hub)\n{\n\tstruct usb_hcd *hcd;\n\tif (hub->hdev->parent != NULL)  /* not a root hub? */\n\t\treturn 0;\n\thcd = container_of(hub->hdev->bus, struct usb_hcd, self);\n\treturn hcd->wireless;\n}\n\n\n#define PORT_RESET_TRIES\t5\n#define SET_ADDRESS_TRIES\t2\n#define GET_DESCRIPTOR_TRIES\t2\n#define SET_CONFIG_TRIES\t(2 * (use_both_schemes + 1))\n#define USE_NEW_SCHEME(i)\t((i) / 2 == (int)old_scheme_first)\n\n#define HUB_ROOT_RESET_TIME\t50\t/* times are in msec */\n#define HUB_SHORT_RESET_TIME\t10\n#define HUB_BH_RESET_TIME\t50\n#define HUB_LONG_RESET_TIME\t200\n#define HUB_RESET_TIMEOUT\t800\n\n/*\n * \"New scheme\" enumeration causes an extra state transition to be\n * exposed to an xhci host and causes USB3 devices to receive control\n * commands in the default state.  This has been seen to cause\n * enumeration failures, so disable this enumeration scheme for USB3\n * devices.\n */\nstatic bool use_new_scheme(struct usb_device *udev, int retry)\n{\n\tif (udev->speed == USB_SPEED_SUPER)\n\t\treturn false;\n\n\treturn USE_NEW_SCHEME(retry);\n}\n\n/* Is a USB 3.0 port in the Inactive or Compliance Mode state?\n * Port worm reset is required to recover\n */\nstatic bool hub_port_warm_reset_required(struct usb_hub *hub, int port1,\n\t\tu16 portstatus)\n{\n\tu16 link_state;\n\n\tif (!hub_is_superspeed(hub->hdev))\n\t\treturn false;\n\n\tif (test_bit(port1, hub->warm_reset_bits))\n\t\treturn true;\n\n\tlink_state = portstatus & USB_PORT_STAT_LINK_STATE;\n\treturn link_state == USB_SS_PORT_LS_SS_INACTIVE\n\t\t|| link_state == USB_SS_PORT_LS_COMP_MOD;\n}\n\nstatic int hub_port_wait_reset(struct usb_hub *hub, int port1,\n\t\t\tstruct usb_device *udev, unsigned int delay, bool warm)\n{\n\tint delay_time, ret;\n\tu16 portstatus;\n\tu16 portchange;\n\n\tfor (delay_time = 0;\n\t\t\tdelay_time < HUB_RESET_TIMEOUT;\n\t\t\tdelay_time += delay) {\n\t\t/* wait to give the device a chance to reset */\n\t\tmsleep(delay);\n\n\t\t/* read and decode port status */\n\t\tret = hub_port_status(hub, port1, &portstatus, &portchange);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\t/* The port state is unknown until the reset completes. */\n\t\tif (!(portstatus & USB_PORT_STAT_RESET))\n\t\t\tbreak;\n\n\t\t/* switch to the long delay after two short delay failures */\n\t\tif (delay_time >= 2 * HUB_SHORT_RESET_TIME)\n\t\t\tdelay = HUB_LONG_RESET_TIME;\n\n\t\tdev_dbg(&hub->ports[port1 - 1]->dev,\n\t\t\t\t\"not %sreset yet, waiting %dms\\n\",\n\t\t\t\twarm ? \"warm \" : \"\", delay);\n\t}\n\n\tif ((portstatus & USB_PORT_STAT_RESET))\n\t\treturn -EBUSY;\n\n\tif (hub_port_warm_reset_required(hub, port1, portstatus))\n\t\treturn -ENOTCONN;\n\n\t/* Device went away? */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION))\n\t\treturn -ENOTCONN;\n\n\t/* bomb out completely if the connection bounced.  A USB 3.0\n\t * connection may bounce if multiple warm resets were issued,\n\t * but the device may have successfully re-connected. Ignore it.\n\t */\n\tif (!hub_is_superspeed(hub->hdev) &&\n\t\t\t(portchange & USB_PORT_STAT_C_CONNECTION))\n\t\treturn -ENOTCONN;\n\n\tif (!(portstatus & USB_PORT_STAT_ENABLE))\n\t\treturn -EBUSY;\n\n\tif (!udev)\n\t\treturn 0;\n\n\tif (hub_is_wusb(hub))\n\t\tudev->speed = USB_SPEED_WIRELESS;\n\telse if (hub_is_superspeed(hub->hdev))\n\t\tudev->speed = USB_SPEED_SUPER;\n\telse if (portstatus & USB_PORT_STAT_HIGH_SPEED)\n\t\tudev->speed = USB_SPEED_HIGH;\n\telse if (portstatus & USB_PORT_STAT_LOW_SPEED)\n\t\tudev->speed = USB_SPEED_LOW;\n\telse\n\t\tudev->speed = USB_SPEED_FULL;\n\treturn 0;\n}\n\n/* Handle port reset and port warm(BH) reset (for USB3 protocol ports) */\nstatic int hub_port_reset(struct usb_hub *hub, int port1,\n\t\t\tstruct usb_device *udev, unsigned int delay, bool warm)\n{\n\tint i, status;\n\tu16 portchange, portstatus;\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\n\tif (!hub_is_superspeed(hub->hdev)) {\n\t\tif (warm) {\n\t\t\tdev_err(hub->intfdev, \"only USB3 hub support \"\n\t\t\t\t\t\t\"warm reset\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t/* Block EHCI CF initialization during the port reset.\n\t\t * Some companion controllers don't like it when they mix.\n\t\t */\n\t\tdown_read(&ehci_cf_port_reset_rwsem);\n\t} else if (!warm) {\n\t\t/*\n\t\t * If the caller hasn't explicitly requested a warm reset,\n\t\t * double check and see if one is needed.\n\t\t */\n\t\tif (hub_port_status(hub, port1, &portstatus, &portchange) == 0)\n\t\t\tif (hub_port_warm_reset_required(hub, port1,\n\t\t\t\t\t\t\tportstatus))\n\t\t\t\twarm = true;\n\t}\n\tclear_bit(port1, hub->warm_reset_bits);\n\n\t/* Reset the port */\n\tfor (i = 0; i < PORT_RESET_TRIES; i++) {\n\t\tstatus = set_port_feature(hub->hdev, port1, (warm ?\n\t\t\t\t\tUSB_PORT_FEAT_BH_PORT_RESET :\n\t\t\t\t\tUSB_PORT_FEAT_RESET));\n\t\tif (status == -ENODEV) {\n\t\t\t;\t/* The hub is gone */\n\t\t} else if (status) {\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"cannot %sreset (err = %d)\\n\",\n\t\t\t\t\twarm ? \"warm \" : \"\", status);\n\t\t} else {\n\t\t\tstatus = hub_port_wait_reset(hub, port1, udev, delay,\n\t\t\t\t\t\t\t\twarm);\n\t\t\tif (status && status != -ENOTCONN && status != -ENODEV)\n\t\t\t\tdev_dbg(hub->intfdev,\n\t\t\t\t\t\t\"port_wait_reset: err = %d\\n\",\n\t\t\t\t\t\tstatus);\n\t\t}\n\n\t\t/* Check for disconnect or reset */\n\t\tif (status == 0 || status == -ENOTCONN || status == -ENODEV) {\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_RESET);\n\n\t\t\tif (!hub_is_superspeed(hub->hdev))\n\t\t\t\tgoto done;\n\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_BH_PORT_RESET);\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_PORT_LINK_STATE);\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_CONNECTION);\n\n\t\t\t/*\n\t\t\t * If a USB 3.0 device migrates from reset to an error\n\t\t\t * state, re-issue the warm reset.\n\t\t\t */\n\t\t\tif (hub_port_status(hub, port1,\n\t\t\t\t\t&portstatus, &portchange) < 0)\n\t\t\t\tgoto done;\n\n\t\t\tif (!hub_port_warm_reset_required(hub, port1,\n\t\t\t\t\tportstatus))\n\t\t\t\tgoto done;\n\n\t\t\t/*\n\t\t\t * If the port is in SS.Inactive or Compliance Mode, the\n\t\t\t * hot or warm reset failed.  Try another warm reset.\n\t\t\t */\n\t\t\tif (!warm) {\n\t\t\t\tdev_dbg(&port_dev->dev,\n\t\t\t\t\t\t\"hot reset failed, warm reset\\n\");\n\t\t\t\twarm = true;\n\t\t\t}\n\t\t}\n\n\t\tdev_dbg(&port_dev->dev,\n\t\t\t\t\"not enabled, trying %sreset again...\\n\",\n\t\t\t\twarm ? \"warm \" : \"\");\n\t\tdelay = HUB_LONG_RESET_TIME;\n\t}\n\n\tdev_err(&port_dev->dev, \"Cannot enable. Maybe the USB cable is bad?\\n\");\n\ndone:\n\tif (status == 0) {\n\t\t/* TRSTRCY = 10 ms; plus some extra */\n\t\tmsleep(10 + 40);\n\t\tif (udev) {\n\t\t\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\t\t\tupdate_devnum(udev, 0);\n\t\t\t/* The xHC may think the device is already reset,\n\t\t\t * so ignore the status.\n\t\t\t */\n\t\t\tif (hcd->driver->reset_device)\n\t\t\t\thcd->driver->reset_device(hcd, udev);\n\n\t\t\tusb_set_device_state(udev, USB_STATE_DEFAULT);\n\t\t}\n\t} else {\n\t\tif (udev)\n\t\t\tusb_set_device_state(udev, USB_STATE_NOTATTACHED);\n\t}\n\n\tif (!hub_is_superspeed(hub->hdev))\n\t\tup_read(&ehci_cf_port_reset_rwsem);\n\n\treturn status;\n}\n\n/* Check if a port is power on */\nstatic int port_is_power_on(struct usb_hub *hub, unsigned portstatus)\n{\n\tint ret = 0;\n\n\tif (hub_is_superspeed(hub->hdev)) {\n\t\tif (portstatus & USB_SS_PORT_STAT_POWER)\n\t\t\tret = 1;\n\t} else {\n\t\tif (portstatus & USB_PORT_STAT_POWER)\n\t\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n\nstatic void usb_lock_port(struct usb_port *port_dev)\n\t\t__acquires(&port_dev->status_lock)\n{\n\tmutex_lock(&port_dev->status_lock);\n\t__acquire(&port_dev->status_lock);\n}\n\nstatic void usb_unlock_port(struct usb_port *port_dev)\n\t\t__releases(&port_dev->status_lock)\n{\n\tmutex_unlock(&port_dev->status_lock);\n\t__release(&port_dev->status_lock);\n}\n\n#ifdef\tCONFIG_PM\n\n/* Check if a port is suspended(USB2.0 port) or in U3 state(USB3.0 port) */\nstatic int port_is_suspended(struct usb_hub *hub, unsigned portstatus)\n{\n\tint ret = 0;\n\n\tif (hub_is_superspeed(hub->hdev)) {\n\t\tif ((portstatus & USB_PORT_STAT_LINK_STATE)\n\t\t\t\t== USB_SS_PORT_LS_U3)\n\t\t\tret = 1;\n\t} else {\n\t\tif (portstatus & USB_PORT_STAT_SUSPEND)\n\t\t\tret = 1;\n\t}\n\n\treturn ret;\n}\n\n/* Determine whether the device on a port is ready for a normal resume,\n * is ready for a reset-resume, or should be disconnected.\n */\nstatic int check_port_resume_type(struct usb_device *udev,\n\t\tstruct usb_hub *hub, int port1,\n\t\tint status, u16 portchange, u16 portstatus)\n{\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tint retries = 3;\n\n retry:\n\t/* Is a warm reset needed to recover the connection? */\n\tif (status == 0 && udev->reset_resume\n\t\t&& hub_port_warm_reset_required(hub, port1, portstatus)) {\n\t\t/* pass */;\n\t}\n\t/* Is the device still present? */\n\telse if (status || port_is_suspended(hub, portstatus) ||\n\t\t\t!port_is_power_on(hub, portstatus)) {\n\t\tif (status >= 0)\n\t\t\tstatus = -ENODEV;\n\t} else if (!(portstatus & USB_PORT_STAT_CONNECTION)) {\n\t\tif (retries--) {\n\t\t\tusleep_range(200, 300);\n\t\t\tstatus = hub_port_status(hub, port1, &portstatus,\n\t\t\t\t\t\t\t     &portchange);\n\t\t\tgoto retry;\n\t\t}\n\t\tstatus = -ENODEV;\n\t}\n\n\t/* Can't do a normal resume if the port isn't enabled,\n\t * so try a reset-resume instead.\n\t */\n\telse if (!(portstatus & USB_PORT_STAT_ENABLE) && !udev->reset_resume) {\n\t\tif (udev->persist_enabled)\n\t\t\tudev->reset_resume = 1;\n\t\telse\n\t\t\tstatus = -ENODEV;\n\t}\n\n\tif (status) {\n\t\tdev_dbg(&port_dev->dev, \"status %04x.%04x after resume, %d\\n\",\n\t\t\t\tportchange, portstatus, status);\n\t} else if (udev->reset_resume) {\n\n\t\t/* Late port handoff can set status-change bits */\n\t\tif (portchange & USB_PORT_STAT_C_CONNECTION)\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_CONNECTION);\n\t\tif (portchange & USB_PORT_STAT_C_ENABLE)\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_ENABLE);\n\t}\n\n\treturn status;\n}\n\nint usb_disable_ltm(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\t/* Check if the roothub and device supports LTM. */\n\tif (!usb_device_supports_ltm(hcd->self.root_hub) ||\n\t\t\t!usb_device_supports_ltm(udev))\n\t\treturn 0;\n\n\t/* Clear Feature LTM Enable can only be sent if the device is\n\t * configured.\n\t */\n\tif (!udev->actconfig)\n\t\treturn 0;\n\n\treturn usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_CLEAR_FEATURE, USB_RECIP_DEVICE,\n\t\t\tUSB_DEVICE_LTM_ENABLE, 0, NULL, 0,\n\t\t\tUSB_CTRL_SET_TIMEOUT);\n}\nEXPORT_SYMBOL_GPL(usb_disable_ltm);\n\nvoid usb_enable_ltm(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\t/* Check if the roothub and device supports LTM. */\n\tif (!usb_device_supports_ltm(hcd->self.root_hub) ||\n\t\t\t!usb_device_supports_ltm(udev))\n\t\treturn;\n\n\t/* Set Feature LTM Enable can only be sent if the device is\n\t * configured.\n\t */\n\tif (!udev->actconfig)\n\t\treturn;\n\n\tusb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_FEATURE, USB_RECIP_DEVICE,\n\t\t\tUSB_DEVICE_LTM_ENABLE, 0, NULL, 0,\n\t\t\tUSB_CTRL_SET_TIMEOUT);\n}\nEXPORT_SYMBOL_GPL(usb_enable_ltm);\n\n/*\n * usb_enable_remote_wakeup - enable remote wakeup for a device\n * @udev: target device\n *\n * For USB-2 devices: Set the device's remote wakeup feature.\n *\n * For USB-3 devices: Assume there's only one function on the device and\n * enable remote wake for the first interface.  FIXME if the interface\n * association descriptor shows there's more than one function.\n */\nstatic int usb_enable_remote_wakeup(struct usb_device *udev)\n{\n\tif (udev->speed < USB_SPEED_SUPER)\n\t\treturn usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, USB_RECIP_DEVICE,\n\t\t\t\tUSB_DEVICE_REMOTE_WAKEUP, 0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\telse\n\t\treturn usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, USB_RECIP_INTERFACE,\n\t\t\t\tUSB_INTRF_FUNC_SUSPEND,\n\t\t\t\tUSB_INTRF_FUNC_SUSPEND_RW |\n\t\t\t\t\tUSB_INTRF_FUNC_SUSPEND_LP,\n\t\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n}\n\n/*\n * usb_disable_remote_wakeup - disable remote wakeup for a device\n * @udev: target device\n *\n * For USB-2 devices: Clear the device's remote wakeup feature.\n *\n * For USB-3 devices: Assume there's only one function on the device and\n * disable remote wake for the first interface.  FIXME if the interface\n * association descriptor shows there's more than one function.\n */\nstatic int usb_disable_remote_wakeup(struct usb_device *udev)\n{\n\tif (udev->speed < USB_SPEED_SUPER)\n\t\treturn usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_CLEAR_FEATURE, USB_RECIP_DEVICE,\n\t\t\t\tUSB_DEVICE_REMOTE_WAKEUP, 0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\telse\n\t\treturn usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_CLEAR_FEATURE, USB_RECIP_INTERFACE,\n\t\t\t\tUSB_INTRF_FUNC_SUSPEND,\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n}\n\n/* Count of wakeup-enabled devices at or below udev */\nstatic unsigned wakeup_enabled_descendants(struct usb_device *udev)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(udev);\n\n\treturn udev->do_remote_wakeup +\n\t\t\t(hub ? hub->wakeup_enabled_descendants : 0);\n}\n\n/*\n * usb_port_suspend - suspend a usb device's upstream port\n * @udev: device that's no longer in active use, not a root hub\n * Context: must be able to sleep; device not locked; pm locks held\n *\n * Suspends a USB device that isn't in active use, conserving power.\n * Devices may wake out of a suspend, if anything important happens,\n * using the remote wakeup mechanism.  They may also be taken out of\n * suspend by the host, using usb_port_resume().  It's also routine\n * to disconnect devices while they are suspended.\n *\n * This only affects the USB hardware for a device; its interfaces\n * (and, for hubs, child devices) must already have been suspended.\n *\n * Selective port suspend reduces power; most suspended devices draw\n * less than 500 uA.  It's also used in OTG, along with remote wakeup.\n * All devices below the suspended port are also suspended.\n *\n * Devices leave suspend state when the host wakes them up.  Some devices\n * also support \"remote wakeup\", where the device can activate the USB\n * tree above them to deliver data, such as a keypress or packet.  In\n * some cases, this wakes the USB host.\n *\n * Suspending OTG devices may trigger HNP, if that's been enabled\n * between a pair of dual-role devices.  That will change roles, such\n * as from A-Host to A-Peripheral or from B-Host back to B-Peripheral.\n *\n * Devices on USB hub ports have only one \"suspend\" state, corresponding\n * to ACPI D2, \"may cause the device to lose some context\".\n * State transitions include:\n *\n *   - suspend, resume ... when the VBUS power link stays live\n *   - suspend, disconnect ... VBUS lost\n *\n * Once VBUS drop breaks the circuit, the port it's using has to go through\n * normal re-enumeration procedures, starting with enabling VBUS power.\n * Other than re-initializing the hub (plug/unplug, except for root hubs),\n * Linux (2.6) currently has NO mechanisms to initiate that:  no hub_wq\n * timer, no SRP, no requests through sysfs.\n *\n * If Runtime PM isn't enabled or used, non-SuperSpeed devices may not get\n * suspended until their bus goes into global suspend (i.e., the root\n * hub is suspended).  Nevertheless, we change @udev->state to\n * USB_STATE_SUSPENDED as this is the device's \"logical\" state.  The actual\n * upstream port setting is stored in @udev->port_is_suspended.\n *\n * Returns 0 on success, else negative errno.\n */\nint usb_port_suspend(struct usb_device *udev, pm_message_t msg)\n{\n\tstruct usb_hub\t*hub = usb_hub_to_struct_hub(udev->parent);\n\tstruct usb_port *port_dev = hub->ports[udev->portnum - 1];\n\tint\t\tport1 = udev->portnum;\n\tint\t\tstatus;\n\tbool\t\treally_suspend = true;\n\n\tusb_lock_port(port_dev);\n\n\t/* enable remote wakeup when appropriate; this lets the device\n\t * wake up the upstream hub (including maybe the root hub).\n\t *\n\t * NOTE:  OTG devices may issue remote wakeup (or SRP) even when\n\t * we don't explicitly enable it here.\n\t */\n\tif (udev->do_remote_wakeup) {\n\t\tstatus = usb_enable_remote_wakeup(udev);\n\t\tif (status) {\n\t\t\tdev_dbg(&udev->dev, \"won't remote wakeup, status %d\\n\",\n\t\t\t\t\tstatus);\n\t\t\t/* bail if autosuspend is requested */\n\t\t\tif (PMSG_IS_AUTO(msg))\n\t\t\t\tgoto err_wakeup;\n\t\t}\n\t}\n\n\t/* disable USB2 hardware LPM */\n\tif (udev->usb2_hw_lpm_enabled == 1)\n\t\tusb_set_usb2_hardware_lpm(udev, 0);\n\n\tif (usb_disable_ltm(udev)) {\n\t\tdev_err(&udev->dev, \"Failed to disable LTM before suspend\\n.\");\n\t\tstatus = -ENOMEM;\n\t\tif (PMSG_IS_AUTO(msg))\n\t\t\tgoto err_ltm;\n\t}\n\tif (usb_unlocked_disable_lpm(udev)) {\n\t\tdev_err(&udev->dev, \"Failed to disable LPM before suspend\\n.\");\n\t\tstatus = -ENOMEM;\n\t\tif (PMSG_IS_AUTO(msg))\n\t\t\tgoto err_lpm3;\n\t}\n\n\t/* see 7.1.7.6 */\n\tif (hub_is_superspeed(hub->hdev))\n\t\tstatus = hub_set_port_link_state(hub, port1, USB_SS_PORT_LS_U3);\n\n\t/*\n\t * For system suspend, we do not need to enable the suspend feature\n\t * on individual USB-2 ports.  The devices will automatically go\n\t * into suspend a few ms after the root hub stops sending packets.\n\t * The USB 2.0 spec calls this \"global suspend\".\n\t *\n\t * However, many USB hubs have a bug: They don't relay wakeup requests\n\t * from a downstream port if the port's suspend feature isn't on.\n\t * Therefore we will turn on the suspend feature if udev or any of its\n\t * descendants is enabled for remote wakeup.\n\t */\n\telse if (PMSG_IS_AUTO(msg) || wakeup_enabled_descendants(udev) > 0)\n\t\tstatus = set_port_feature(hub->hdev, port1,\n\t\t\t\tUSB_PORT_FEAT_SUSPEND);\n\telse {\n\t\treally_suspend = false;\n\t\tstatus = 0;\n\t}\n\tif (status) {\n\t\tdev_dbg(&port_dev->dev, \"can't suspend, status %d\\n\", status);\n\n\t\t/* Try to enable USB3 LPM and LTM again */\n\t\tusb_unlocked_enable_lpm(udev);\n err_lpm3:\n\t\tusb_enable_ltm(udev);\n err_ltm:\n\t\t/* Try to enable USB2 hardware LPM again */\n\t\tif (udev->usb2_hw_lpm_capable == 1)\n\t\t\tusb_set_usb2_hardware_lpm(udev, 1);\n\n\t\tif (udev->do_remote_wakeup)\n\t\t\t(void) usb_disable_remote_wakeup(udev);\n err_wakeup:\n\n\t\t/* System sleep transitions should never fail */\n\t\tif (!PMSG_IS_AUTO(msg))\n\t\t\tstatus = 0;\n\t} else {\n\t\tdev_dbg(&udev->dev, \"usb %ssuspend, wakeup %d\\n\",\n\t\t\t\t(PMSG_IS_AUTO(msg) ? \"auto-\" : \"\"),\n\t\t\t\tudev->do_remote_wakeup);\n\t\tif (really_suspend) {\n\t\t\tudev->port_is_suspended = 1;\n\n\t\t\t/* device has up to 10 msec to fully suspend */\n\t\t\tmsleep(10);\n\t\t}\n\t\tusb_set_device_state(udev, USB_STATE_SUSPENDED);\n\t}\n\n\tif (status == 0 && !udev->do_remote_wakeup && udev->persist_enabled\n\t\t\t&& test_and_clear_bit(port1, hub->child_usage_bits))\n\t\tpm_runtime_put_sync(&port_dev->dev);\n\n\tusb_mark_last_busy(hub->hdev);\n\n\tusb_unlock_port(port_dev);\n\treturn status;\n}\n\n/*\n * If the USB \"suspend\" state is in use (rather than \"global suspend\"),\n * many devices will be individually taken out of suspend state using\n * special \"resume\" signaling.  This routine kicks in shortly after\n * hardware resume signaling is finished, either because of selective\n * resume (by host) or remote wakeup (by device) ... now see what changed\n * in the tree that's rooted at this device.\n *\n * If @udev->reset_resume is set then the device is reset before the\n * status check is done.\n */\nstatic int finish_port_resume(struct usb_device *udev)\n{\n\tint\tstatus = 0;\n\tu16\tdevstatus = 0;\n\n\t/* caller owns the udev device lock */\n\tdev_dbg(&udev->dev, \"%s\\n\",\n\t\tudev->reset_resume ? \"finish reset-resume\" : \"finish resume\");\n\n\t/* usb ch9 identifies four variants of SUSPENDED, based on what\n\t * state the device resumes to.  Linux currently won't see the\n\t * first two on the host side; they'd be inside hub_port_init()\n\t * during many timeouts, but hub_wq can't suspend until later.\n\t */\n\tusb_set_device_state(udev, udev->actconfig\n\t\t\t? USB_STATE_CONFIGURED\n\t\t\t: USB_STATE_ADDRESS);\n\n\t/* 10.5.4.5 says not to reset a suspended port if the attached\n\t * device is enabled for remote wakeup.  Hence the reset\n\t * operation is carried out here, after the port has been\n\t * resumed.\n\t */\n\tif (udev->reset_resume) {\n\t\t/*\n\t\t * If the device morphs or switches modes when it is reset,\n\t\t * we don't want to perform a reset-resume.  We'll fail the\n\t\t * resume, which will cause a logical disconnect, and then\n\t\t * the device will be rediscovered.\n\t\t */\n retry_reset_resume:\n\t\tif (udev->quirks & USB_QUIRK_RESET)\n\t\t\tstatus = -ENODEV;\n\t\telse\n\t\t\tstatus = usb_reset_and_verify_device(udev);\n\t}\n\n\t/* 10.5.4.5 says be sure devices in the tree are still there.\n\t * For now let's assume the device didn't go crazy on resume,\n\t * and device drivers will know about any resume quirks.\n\t */\n\tif (status == 0) {\n\t\tdevstatus = 0;\n\t\tstatus = usb_get_status(udev, USB_RECIP_DEVICE, 0, &devstatus);\n\n\t\t/* If a normal resume failed, try doing a reset-resume */\n\t\tif (status && !udev->reset_resume && udev->persist_enabled) {\n\t\t\tdev_dbg(&udev->dev, \"retry with reset-resume\\n\");\n\t\t\tudev->reset_resume = 1;\n\t\t\tgoto retry_reset_resume;\n\t\t}\n\t}\n\n\tif (status) {\n\t\tdev_dbg(&udev->dev, \"gone after usb resume? status %d\\n\",\n\t\t\t\tstatus);\n\t/*\n\t * There are a few quirky devices which violate the standard\n\t * by claiming to have remote wakeup enabled after a reset,\n\t * which crash if the feature is cleared, hence check for\n\t * udev->reset_resume\n\t */\n\t} else if (udev->actconfig && !udev->reset_resume) {\n\t\tif (udev->speed < USB_SPEED_SUPER) {\n\t\t\tif (devstatus & (1 << USB_DEVICE_REMOTE_WAKEUP))\n\t\t\t\tstatus = usb_disable_remote_wakeup(udev);\n\t\t} else {\n\t\t\tstatus = usb_get_status(udev, USB_RECIP_INTERFACE, 0,\n\t\t\t\t\t&devstatus);\n\t\t\tif (!status && devstatus & (USB_INTRF_STAT_FUNC_RW_CAP\n\t\t\t\t\t| USB_INTRF_STAT_FUNC_RW))\n\t\t\t\tstatus = usb_disable_remote_wakeup(udev);\n\t\t}\n\n\t\tif (status)\n\t\t\tdev_dbg(&udev->dev,\n\t\t\t\t\"disable remote wakeup, status %d\\n\",\n\t\t\t\tstatus);\n\t\tstatus = 0;\n\t}\n\treturn status;\n}\n\n/*\n * There are some SS USB devices which take longer time for link training.\n * XHCI specs 4.19.4 says that when Link training is successful, port\n * sets CSC bit to 1. So if SW reads port status before successful link\n * training, then it will not find device to be present.\n * USB Analyzer log with such buggy devices show that in some cases\n * device switch on the RX termination after long delay of host enabling\n * the VBUS. In few other cases it has been seen that device fails to\n * negotiate link training in first attempt. It has been\n * reported till now that few devices take as long as 2000 ms to train\n * the link after host enabling its VBUS and termination. Following\n * routine implements a 2000 ms timeout for link training. If in a case\n * link trains before timeout, loop will exit earlier.\n *\n * FIXME: If a device was connected before suspend, but was removed\n * while system was asleep, then the loop in the following routine will\n * only exit at timeout.\n *\n * This routine should only be called when persist is enabled for a SS\n * device.\n */\nstatic int wait_for_ss_port_enable(struct usb_device *udev,\n\t\tstruct usb_hub *hub, int *port1,\n\t\tu16 *portchange, u16 *portstatus)\n{\n\tint status = 0, delay_ms = 0;\n\n\twhile (delay_ms < 2000) {\n\t\tif (status || *portstatus & USB_PORT_STAT_CONNECTION)\n\t\t\tbreak;\n\t\tmsleep(20);\n\t\tdelay_ms += 20;\n\t\tstatus = hub_port_status(hub, *port1, portstatus, portchange);\n\t}\n\treturn status;\n}\n\n/*\n * usb_port_resume - re-activate a suspended usb device's upstream port\n * @udev: device to re-activate, not a root hub\n * Context: must be able to sleep; device not locked; pm locks held\n *\n * This will re-activate the suspended device, increasing power usage\n * while letting drivers communicate again with its endpoints.\n * USB resume explicitly guarantees that the power session between\n * the host and the device is the same as it was when the device\n * suspended.\n *\n * If @udev->reset_resume is set then this routine won't check that the\n * port is still enabled.  Furthermore, finish_port_resume() above will\n * reset @udev.  The end result is that a broken power session can be\n * recovered and @udev will appear to persist across a loss of VBUS power.\n *\n * For example, if a host controller doesn't maintain VBUS suspend current\n * during a system sleep or is reset when the system wakes up, all the USB\n * power sessions below it will be broken.  This is especially troublesome\n * for mass-storage devices containing mounted filesystems, since the\n * device will appear to have disconnected and all the memory mappings\n * to it will be lost.  Using the USB_PERSIST facility, the device can be\n * made to appear as if it had not disconnected.\n *\n * This facility can be dangerous.  Although usb_reset_and_verify_device() makes\n * every effort to insure that the same device is present after the\n * reset as before, it cannot provide a 100% guarantee.  Furthermore it's\n * quite possible for a device to remain unaltered but its media to be\n * changed.  If the user replaces a flash memory card while the system is\n * asleep, he will have only himself to blame when the filesystem on the\n * new card is corrupted and the system crashes.\n *\n * Returns 0 on success, else negative errno.\n */\nint usb_port_resume(struct usb_device *udev, pm_message_t msg)\n{\n\tstruct usb_hub\t*hub = usb_hub_to_struct_hub(udev->parent);\n\tstruct usb_port *port_dev = hub->ports[udev->portnum  - 1];\n\tint\t\tport1 = udev->portnum;\n\tint\t\tstatus;\n\tu16\t\tportchange, portstatus;\n\n\tif (!test_and_set_bit(port1, hub->child_usage_bits)) {\n\t\tstatus = pm_runtime_get_sync(&port_dev->dev);\n\t\tif (status < 0) {\n\t\t\tdev_dbg(&udev->dev, \"can't resume usb port, status %d\\n\",\n\t\t\t\t\tstatus);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\tusb_lock_port(port_dev);\n\n\t/* Skip the initial Clear-Suspend step for a remote wakeup */\n\tstatus = hub_port_status(hub, port1, &portstatus, &portchange);\n\tif (status == 0 && !port_is_suspended(hub, portstatus))\n\t\tgoto SuspendCleared;\n\n\t/* see 7.1.7.7; affects power usage, but not budgeting */\n\tif (hub_is_superspeed(hub->hdev))\n\t\tstatus = hub_set_port_link_state(hub, port1, USB_SS_PORT_LS_U0);\n\telse\n\t\tstatus = usb_clear_port_feature(hub->hdev,\n\t\t\t\tport1, USB_PORT_FEAT_SUSPEND);\n\tif (status) {\n\t\tdev_dbg(&port_dev->dev, \"can't resume, status %d\\n\", status);\n\t} else {\n\t\t/* drive resume for USB_RESUME_TIMEOUT msec */\n\t\tdev_dbg(&udev->dev, \"usb %sresume\\n\",\n\t\t\t\t(PMSG_IS_AUTO(msg) ? \"auto-\" : \"\"));\n\t\tmsleep(USB_RESUME_TIMEOUT);\n\n\t\t/* Virtual root hubs can trigger on GET_PORT_STATUS to\n\t\t * stop resume signaling.  Then finish the resume\n\t\t * sequence.\n\t\t */\n\t\tstatus = hub_port_status(hub, port1, &portstatus, &portchange);\n\n\t\t/* TRSMRCY = 10 msec */\n\t\tmsleep(10);\n\t}\n\n SuspendCleared:\n\tif (status == 0) {\n\t\tudev->port_is_suspended = 0;\n\t\tif (hub_is_superspeed(hub->hdev)) {\n\t\t\tif (portchange & USB_PORT_STAT_C_LINK_STATE)\n\t\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_PORT_LINK_STATE);\n\t\t} else {\n\t\t\tif (portchange & USB_PORT_STAT_C_SUSPEND)\n\t\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\t\tUSB_PORT_FEAT_C_SUSPEND);\n\t\t}\n\t}\n\n\tif (udev->persist_enabled && hub_is_superspeed(hub->hdev))\n\t\tstatus = wait_for_ss_port_enable(udev, hub, &port1, &portchange,\n\t\t\t\t&portstatus);\n\n\tstatus = check_port_resume_type(udev,\n\t\t\thub, port1, status, portchange, portstatus);\n\tif (status == 0)\n\t\tstatus = finish_port_resume(udev);\n\tif (status < 0) {\n\t\tdev_dbg(&udev->dev, \"can't resume, status %d\\n\", status);\n\t\thub_port_logical_disconnect(hub, port1);\n\t} else  {\n\t\t/* Try to enable USB2 hardware LPM */\n\t\tif (udev->usb2_hw_lpm_capable == 1)\n\t\t\tusb_set_usb2_hardware_lpm(udev, 1);\n\n\t\t/* Try to enable USB3 LTM and LPM */\n\t\tusb_enable_ltm(udev);\n\t\tusb_unlocked_enable_lpm(udev);\n\t}\n\n\tusb_unlock_port(port_dev);\n\n\treturn status;\n}\n\nint usb_remote_wakeup(struct usb_device *udev)\n{\n\tint\tstatus = 0;\n\n\tusb_lock_device(udev);\n\tif (udev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"usb %sresume\\n\", \"wakeup-\");\n\t\tstatus = usb_autoresume_device(udev);\n\t\tif (status == 0) {\n\t\t\t/* Let the drivers do their thing, then... */\n\t\t\tusb_autosuspend_device(udev);\n\t\t}\n\t}\n\tusb_unlock_device(udev);\n\treturn status;\n}\n\n/* Returns 1 if there was a remote wakeup and a connect status change. */\nstatic int hub_handle_remote_wakeup(struct usb_hub *hub, unsigned int port,\n\t\tu16 portstatus, u16 portchange)\n\t\t__must_hold(&port_dev->status_lock)\n{\n\tstruct usb_port *port_dev = hub->ports[port - 1];\n\tstruct usb_device *hdev;\n\tstruct usb_device *udev;\n\tint connect_change = 0;\n\tint ret;\n\n\thdev = hub->hdev;\n\tudev = port_dev->child;\n\tif (!hub_is_superspeed(hdev)) {\n\t\tif (!(portchange & USB_PORT_STAT_C_SUSPEND))\n\t\t\treturn 0;\n\t\tusb_clear_port_feature(hdev, port, USB_PORT_FEAT_C_SUSPEND);\n\t} else {\n\t\tif (!udev || udev->state != USB_STATE_SUSPENDED ||\n\t\t\t\t (portstatus & USB_PORT_STAT_LINK_STATE) !=\n\t\t\t\t USB_SS_PORT_LS_U0)\n\t\t\treturn 0;\n\t}\n\n\tif (udev) {\n\t\t/* TRSMRCY = 10 msec */\n\t\tmsleep(10);\n\n\t\tusb_unlock_port(port_dev);\n\t\tret = usb_remote_wakeup(udev);\n\t\tusb_lock_port(port_dev);\n\t\tif (ret < 0)\n\t\t\tconnect_change = 1;\n\t} else {\n\t\tret = -ENODEV;\n\t\thub_port_disable(hub, port, 1);\n\t}\n\tdev_dbg(&port_dev->dev, \"resume, status %d\\n\", ret);\n\treturn connect_change;\n}\n\nstatic int check_ports_changed(struct usb_hub *hub)\n{\n\tint port1;\n\n\tfor (port1 = 1; port1 <= hub->hdev->maxchild; ++port1) {\n\t\tu16 portstatus, portchange;\n\t\tint status;\n\n\t\tstatus = hub_port_status(hub, port1, &portstatus, &portchange);\n\t\tif (!status && portchange)\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nstatic int hub_suspend(struct usb_interface *intf, pm_message_t msg)\n{\n\tstruct usb_hub\t\t*hub = usb_get_intfdata(intf);\n\tstruct usb_device\t*hdev = hub->hdev;\n\tunsigned\t\tport1;\n\tint\t\t\tstatus;\n\n\t/*\n\t * Warn if children aren't already suspended.\n\t * Also, add up the number of wakeup-enabled descendants.\n\t */\n\thub->wakeup_enabled_descendants = 0;\n\tfor (port1 = 1; port1 <= hdev->maxchild; port1++) {\n\t\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\t\tstruct usb_device *udev = port_dev->child;\n\n\t\tif (udev && udev->can_submit) {\n\t\t\tdev_warn(&port_dev->dev, \"device %s not suspended yet\\n\",\n\t\t\t\t\tdev_name(&udev->dev));\n\t\t\tif (PMSG_IS_AUTO(msg))\n\t\t\t\treturn -EBUSY;\n\t\t}\n\t\tif (udev)\n\t\t\thub->wakeup_enabled_descendants +=\n\t\t\t\t\twakeup_enabled_descendants(udev);\n\t}\n\n\tif (hdev->do_remote_wakeup && hub->quirk_check_port_auto_suspend) {\n\t\t/* check if there are changes pending on hub ports */\n\t\tif (check_ports_changed(hub)) {\n\t\t\tif (PMSG_IS_AUTO(msg))\n\t\t\t\treturn -EBUSY;\n\t\t\tpm_wakeup_event(&hdev->dev, 2000);\n\t\t}\n\t}\n\n\tif (hub_is_superspeed(hdev) && hdev->do_remote_wakeup) {\n\t\t/* Enable hub to send remote wakeup for all ports. */\n\t\tfor (port1 = 1; port1 <= hdev->maxchild; port1++) {\n\t\t\tstatus = set_port_feature(hdev,\n\t\t\t\t\tport1 |\n\t\t\t\t\tUSB_PORT_FEAT_REMOTE_WAKE_CONNECT |\n\t\t\t\t\tUSB_PORT_FEAT_REMOTE_WAKE_DISCONNECT |\n\t\t\t\t\tUSB_PORT_FEAT_REMOTE_WAKE_OVER_CURRENT,\n\t\t\t\t\tUSB_PORT_FEAT_REMOTE_WAKE_MASK);\n\t\t}\n\t}\n\n\tdev_dbg(&intf->dev, \"%s\\n\", __func__);\n\n\t/* stop hub_wq and related activity */\n\thub_quiesce(hub, HUB_SUSPEND);\n\treturn 0;\n}\n\nstatic int hub_resume(struct usb_interface *intf)\n{\n\tstruct usb_hub *hub = usb_get_intfdata(intf);\n\n\tdev_dbg(&intf->dev, \"%s\\n\", __func__);\n\thub_activate(hub, HUB_RESUME);\n\treturn 0;\n}\n\nstatic int hub_reset_resume(struct usb_interface *intf)\n{\n\tstruct usb_hub *hub = usb_get_intfdata(intf);\n\n\tdev_dbg(&intf->dev, \"%s\\n\", __func__);\n\thub_activate(hub, HUB_RESET_RESUME);\n\treturn 0;\n}\n\n/**\n * usb_root_hub_lost_power - called by HCD if the root hub lost Vbus power\n * @rhdev: struct usb_device for the root hub\n *\n * The USB host controller driver calls this function when its root hub\n * is resumed and Vbus power has been interrupted or the controller\n * has been reset.  The routine marks @rhdev as having lost power.\n * When the hub driver is resumed it will take notice and carry out\n * power-session recovery for all the \"USB-PERSIST\"-enabled child devices;\n * the others will be disconnected.\n */\nvoid usb_root_hub_lost_power(struct usb_device *rhdev)\n{\n\tdev_warn(&rhdev->dev, \"root hub lost power or was reset\\n\");\n\trhdev->reset_resume = 1;\n}\nEXPORT_SYMBOL_GPL(usb_root_hub_lost_power);\n\nstatic const char * const usb3_lpm_names[]  = {\n\t\"U0\",\n\t\"U1\",\n\t\"U2\",\n\t\"U3\",\n};\n\n/*\n * Send a Set SEL control transfer to the device, prior to enabling\n * device-initiated U1 or U2.  This lets the device know the exit latencies from\n * the time the device initiates a U1 or U2 exit, to the time it will receive a\n * packet from the host.\n *\n * This function will fail if the SEL or PEL values for udev are greater than\n * the maximum allowed values for the link state to be enabled.\n */\nstatic int usb_req_set_sel(struct usb_device *udev, enum usb3_link_state state)\n{\n\tstruct usb_set_sel_req *sel_values;\n\tunsigned long long u1_sel;\n\tunsigned long long u1_pel;\n\tunsigned long long u2_sel;\n\tunsigned long long u2_pel;\n\tint ret;\n\n\tif (udev->state != USB_STATE_CONFIGURED)\n\t\treturn 0;\n\n\t/* Convert SEL and PEL stored in ns to us */\n\tu1_sel = DIV_ROUND_UP(udev->u1_params.sel, 1000);\n\tu1_pel = DIV_ROUND_UP(udev->u1_params.pel, 1000);\n\tu2_sel = DIV_ROUND_UP(udev->u2_params.sel, 1000);\n\tu2_pel = DIV_ROUND_UP(udev->u2_params.pel, 1000);\n\n\t/*\n\t * Make sure that the calculated SEL and PEL values for the link\n\t * state we're enabling aren't bigger than the max SEL/PEL\n\t * value that will fit in the SET SEL control transfer.\n\t * Otherwise the device would get an incorrect idea of the exit\n\t * latency for the link state, and could start a device-initiated\n\t * U1/U2 when the exit latencies are too high.\n\t */\n\tif ((state == USB3_LPM_U1 &&\n\t\t\t\t(u1_sel > USB3_LPM_MAX_U1_SEL_PEL ||\n\t\t\t\t u1_pel > USB3_LPM_MAX_U1_SEL_PEL)) ||\n\t\t\t(state == USB3_LPM_U2 &&\n\t\t\t (u2_sel > USB3_LPM_MAX_U2_SEL_PEL ||\n\t\t\t  u2_pel > USB3_LPM_MAX_U2_SEL_PEL))) {\n\t\tdev_dbg(&udev->dev, \"Device-initiated %s disabled due to long SEL %llu us or PEL %llu us\\n\",\n\t\t\t\tusb3_lpm_names[state], u1_sel, u1_pel);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * If we're enabling device-initiated LPM for one link state,\n\t * but the other link state has a too high SEL or PEL value,\n\t * just set those values to the max in the Set SEL request.\n\t */\n\tif (u1_sel > USB3_LPM_MAX_U1_SEL_PEL)\n\t\tu1_sel = USB3_LPM_MAX_U1_SEL_PEL;\n\n\tif (u1_pel > USB3_LPM_MAX_U1_SEL_PEL)\n\t\tu1_pel = USB3_LPM_MAX_U1_SEL_PEL;\n\n\tif (u2_sel > USB3_LPM_MAX_U2_SEL_PEL)\n\t\tu2_sel = USB3_LPM_MAX_U2_SEL_PEL;\n\n\tif (u2_pel > USB3_LPM_MAX_U2_SEL_PEL)\n\t\tu2_pel = USB3_LPM_MAX_U2_SEL_PEL;\n\n\t/*\n\t * usb_enable_lpm() can be called as part of a failed device reset,\n\t * which may be initiated by an error path of a mass storage driver.\n\t * Therefore, use GFP_NOIO.\n\t */\n\tsel_values = kmalloc(sizeof *(sel_values), GFP_NOIO);\n\tif (!sel_values)\n\t\treturn -ENOMEM;\n\n\tsel_values->u1_sel = u1_sel;\n\tsel_values->u1_pel = u1_pel;\n\tsel_values->u2_sel = cpu_to_le16(u2_sel);\n\tsel_values->u2_pel = cpu_to_le16(u2_pel);\n\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_SEL,\n\t\t\tUSB_RECIP_DEVICE,\n\t\t\t0, 0,\n\t\t\tsel_values, sizeof *(sel_values),\n\t\t\tUSB_CTRL_SET_TIMEOUT);\n\tkfree(sel_values);\n\treturn ret;\n}\n\n/*\n * Enable or disable device-initiated U1 or U2 transitions.\n */\nstatic int usb_set_device_initiated_lpm(struct usb_device *udev,\n\t\tenum usb3_link_state state, bool enable)\n{\n\tint ret;\n\tint feature;\n\n\tswitch (state) {\n\tcase USB3_LPM_U1:\n\t\tfeature = USB_DEVICE_U1_ENABLE;\n\t\tbreak;\n\tcase USB3_LPM_U2:\n\t\tfeature = USB_DEVICE_U2_ENABLE;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&udev->dev, \"%s: Can't %s non-U1 or U2 state.\\n\",\n\t\t\t\t__func__, enable ? \"enable\" : \"disable\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (udev->state != USB_STATE_CONFIGURED) {\n\t\tdev_dbg(&udev->dev, \"%s: Can't %s %s state \"\n\t\t\t\t\"for unconfigured device.\\n\",\n\t\t\t\t__func__, enable ? \"enable\" : \"disable\",\n\t\t\t\tusb3_lpm_names[state]);\n\t\treturn 0;\n\t}\n\n\tif (enable) {\n\t\t/*\n\t\t * Now send the control transfer to enable device-initiated LPM\n\t\t * for either U1 or U2.\n\t\t */\n\t\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE,\n\t\t\t\tUSB_RECIP_DEVICE,\n\t\t\t\tfeature,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t} else {\n\t\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_CLEAR_FEATURE,\n\t\t\t\tUSB_RECIP_DEVICE,\n\t\t\t\tfeature,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t}\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev, \"%s of device-initiated %s failed.\\n\",\n\t\t\t\tenable ? \"Enable\" : \"Disable\",\n\t\t\t\tusb3_lpm_names[state]);\n\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}\n\nstatic int usb_set_lpm_timeout(struct usb_device *udev,\n\t\tenum usb3_link_state state, int timeout)\n{\n\tint ret;\n\tint feature;\n\n\tswitch (state) {\n\tcase USB3_LPM_U1:\n\t\tfeature = USB_PORT_FEAT_U1_TIMEOUT;\n\t\tbreak;\n\tcase USB3_LPM_U2:\n\t\tfeature = USB_PORT_FEAT_U2_TIMEOUT;\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&udev->dev, \"%s: Can't set timeout for non-U1 or U2 state.\\n\",\n\t\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (state == USB3_LPM_U1 && timeout > USB3_LPM_U1_MAX_TIMEOUT &&\n\t\t\ttimeout != USB3_LPM_DEVICE_INITIATED) {\n\t\tdev_warn(&udev->dev, \"Failed to set %s timeout to 0x%x, \"\n\t\t\t\t\"which is a reserved value.\\n\",\n\t\t\t\tusb3_lpm_names[state], timeout);\n\t\treturn -EINVAL;\n\t}\n\n\tret = set_port_feature(udev->parent,\n\t\t\tUSB_PORT_LPM_TIMEOUT(timeout) | udev->portnum,\n\t\t\tfeature);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev, \"Failed to set %s timeout to 0x%x,\"\n\t\t\t\t\"error code %i\\n\", usb3_lpm_names[state],\n\t\t\t\ttimeout, ret);\n\t\treturn -EBUSY;\n\t}\n\tif (state == USB3_LPM_U1)\n\t\tudev->u1_params.timeout = timeout;\n\telse\n\t\tudev->u2_params.timeout = timeout;\n\treturn 0;\n}\n\n/*\n * Enable the hub-initiated U1/U2 idle timeouts, and enable device-initiated\n * U1/U2 entry.\n *\n * We will attempt to enable U1 or U2, but there are no guarantees that the\n * control transfers to set the hub timeout or enable device-initiated U1/U2\n * will be successful.\n *\n * If we cannot set the parent hub U1/U2 timeout, we attempt to let the xHCI\n * driver know about it.  If that call fails, it should be harmless, and just\n * take up more slightly more bus bandwidth for unnecessary U1/U2 exit latency.\n */\nstatic void usb_enable_link_state(struct usb_hcd *hcd, struct usb_device *udev,\n\t\tenum usb3_link_state state)\n{\n\tint timeout, ret;\n\t__u8 u1_mel = udev->bos->ss_cap->bU1devExitLat;\n\t__le16 u2_mel = udev->bos->ss_cap->bU2DevExitLat;\n\n\t/* If the device says it doesn't have *any* exit latency to come out of\n\t * U1 or U2, it's probably lying.  Assume it doesn't implement that link\n\t * state.\n\t */\n\tif ((state == USB3_LPM_U1 && u1_mel == 0) ||\n\t\t\t(state == USB3_LPM_U2 && u2_mel == 0))\n\t\treturn;\n\n\t/*\n\t * First, let the device know about the exit latencies\n\t * associated with the link state we're about to enable.\n\t */\n\tret = usb_req_set_sel(udev, state);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev, \"Set SEL for device-initiated %s failed.\\n\",\n\t\t\t\tusb3_lpm_names[state]);\n\t\treturn;\n\t}\n\n\t/* We allow the host controller to set the U1/U2 timeout internally\n\t * first, so that it can change its schedule to account for the\n\t * additional latency to send data to a device in a lower power\n\t * link state.\n\t */\n\ttimeout = hcd->driver->enable_usb3_lpm_timeout(hcd, udev, state);\n\n\t/* xHCI host controller doesn't want to enable this LPM state. */\n\tif (timeout == 0)\n\t\treturn;\n\n\tif (timeout < 0) {\n\t\tdev_warn(&udev->dev, \"Could not enable %s link state, \"\n\t\t\t\t\"xHCI error %i.\\n\", usb3_lpm_names[state],\n\t\t\t\ttimeout);\n\t\treturn;\n\t}\n\n\tif (usb_set_lpm_timeout(udev, state, timeout))\n\t\t/* If we can't set the parent hub U1/U2 timeout,\n\t\t * device-initiated LPM won't be allowed either, so let the xHCI\n\t\t * host know that this link state won't be enabled.\n\t\t */\n\t\thcd->driver->disable_usb3_lpm_timeout(hcd, udev, state);\n\n\t/* Only a configured device will accept the Set Feature U1/U2_ENABLE */\n\telse if (udev->actconfig)\n\t\tusb_set_device_initiated_lpm(udev, state, true);\n\n}\n\n/*\n * Disable the hub-initiated U1/U2 idle timeouts, and disable device-initiated\n * U1/U2 entry.\n *\n * If this function returns -EBUSY, the parent hub will still allow U1/U2 entry.\n * If zero is returned, the parent will not allow the link to go into U1/U2.\n *\n * If zero is returned, device-initiated U1/U2 entry may still be enabled, but\n * it won't have an effect on the bus link state because the parent hub will\n * still disallow device-initiated U1/U2 entry.\n *\n * If zero is returned, the xHCI host controller may still think U1/U2 entry is\n * possible.  The result will be slightly more bus bandwidth will be taken up\n * (to account for U1/U2 exit latency), but it should be harmless.\n */\nstatic int usb_disable_link_state(struct usb_hcd *hcd, struct usb_device *udev,\n\t\tenum usb3_link_state state)\n{\n\tswitch (state) {\n\tcase USB3_LPM_U1:\n\tcase USB3_LPM_U2:\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(&udev->dev, \"%s: Can't disable non-U1 or U2 state.\\n\",\n\t\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (usb_set_lpm_timeout(udev, state, 0))\n\t\treturn -EBUSY;\n\n\tusb_set_device_initiated_lpm(udev, state, false);\n\n\tif (hcd->driver->disable_usb3_lpm_timeout(hcd, udev, state))\n\t\tdev_warn(&udev->dev, \"Could not disable xHCI %s timeout, \"\n\t\t\t\t\"bus schedule bandwidth may be impacted.\\n\",\n\t\t\t\tusb3_lpm_names[state]);\n\treturn 0;\n}\n\n/*\n * Disable hub-initiated and device-initiated U1 and U2 entry.\n * Caller must own the bandwidth_mutex.\n *\n * This will call usb_enable_lpm() on failure, which will decrement\n * lpm_disable_count, and will re-enable LPM if lpm_disable_count reaches zero.\n */\nint usb_disable_lpm(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd;\n\n\tif (!udev || !udev->parent ||\n\t\t\tudev->speed != USB_SPEED_SUPER ||\n\t\t\t!udev->lpm_capable ||\n\t\t\tudev->state < USB_STATE_DEFAULT)\n\t\treturn 0;\n\n\thcd = bus_to_hcd(udev->bus);\n\tif (!hcd || !hcd->driver->disable_usb3_lpm_timeout)\n\t\treturn 0;\n\n\tudev->lpm_disable_count++;\n\tif ((udev->u1_params.timeout == 0 && udev->u2_params.timeout == 0))\n\t\treturn 0;\n\n\t/* If LPM is enabled, attempt to disable it. */\n\tif (usb_disable_link_state(hcd, udev, USB3_LPM_U1))\n\t\tgoto enable_lpm;\n\tif (usb_disable_link_state(hcd, udev, USB3_LPM_U2))\n\t\tgoto enable_lpm;\n\n\tudev->usb3_lpm_enabled = 0;\n\n\treturn 0;\n\nenable_lpm:\n\tusb_enable_lpm(udev);\n\treturn -EBUSY;\n}\nEXPORT_SYMBOL_GPL(usb_disable_lpm);\n\n/* Grab the bandwidth_mutex before calling usb_disable_lpm() */\nint usb_unlocked_disable_lpm(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\tint ret;\n\n\tif (!hcd)\n\t\treturn -EINVAL;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_disable_lpm(udev);\n\tmutex_unlock(hcd->bandwidth_mutex);\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_unlocked_disable_lpm);\n\n/*\n * Attempt to enable device-initiated and hub-initiated U1 and U2 entry.  The\n * xHCI host policy may prevent U1 or U2 from being enabled.\n *\n * Other callers may have disabled link PM, so U1 and U2 entry will be disabled\n * until the lpm_disable_count drops to zero.  Caller must own the\n * bandwidth_mutex.\n */\nvoid usb_enable_lpm(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd;\n\n\tif (!udev || !udev->parent ||\n\t\t\tudev->speed != USB_SPEED_SUPER ||\n\t\t\t!udev->lpm_capable ||\n\t\t\tudev->state < USB_STATE_DEFAULT)\n\t\treturn;\n\n\tudev->lpm_disable_count--;\n\thcd = bus_to_hcd(udev->bus);\n\t/* Double check that we can both enable and disable LPM.\n\t * Device must be configured to accept set feature U1/U2 timeout.\n\t */\n\tif (!hcd || !hcd->driver->enable_usb3_lpm_timeout ||\n\t\t\t!hcd->driver->disable_usb3_lpm_timeout)\n\t\treturn;\n\n\tif (udev->lpm_disable_count > 0)\n\t\treturn;\n\n\tusb_enable_link_state(hcd, udev, USB3_LPM_U1);\n\tusb_enable_link_state(hcd, udev, USB3_LPM_U2);\n\n\tudev->usb3_lpm_enabled = 1;\n}\nEXPORT_SYMBOL_GPL(usb_enable_lpm);\n\n/* Grab the bandwidth_mutex before calling usb_enable_lpm() */\nvoid usb_unlocked_enable_lpm(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\tif (!hcd)\n\t\treturn;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tusb_enable_lpm(udev);\n\tmutex_unlock(hcd->bandwidth_mutex);\n}\nEXPORT_SYMBOL_GPL(usb_unlocked_enable_lpm);\n\n\n#else\t/* CONFIG_PM */\n\n#define hub_suspend\t\tNULL\n#define hub_resume\t\tNULL\n#define hub_reset_resume\tNULL\n\nint usb_disable_lpm(struct usb_device *udev)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_disable_lpm);\n\nvoid usb_enable_lpm(struct usb_device *udev) { }\nEXPORT_SYMBOL_GPL(usb_enable_lpm);\n\nint usb_unlocked_disable_lpm(struct usb_device *udev)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_unlocked_disable_lpm);\n\nvoid usb_unlocked_enable_lpm(struct usb_device *udev) { }\nEXPORT_SYMBOL_GPL(usb_unlocked_enable_lpm);\n\nint usb_disable_ltm(struct usb_device *udev)\n{\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(usb_disable_ltm);\n\nvoid usb_enable_ltm(struct usb_device *udev) { }\nEXPORT_SYMBOL_GPL(usb_enable_ltm);\n\nstatic int hub_handle_remote_wakeup(struct usb_hub *hub, unsigned int port,\n\t\tu16 portstatus, u16 portchange)\n{\n\treturn 0;\n}\n\n#endif\t/* CONFIG_PM */\n\n\n/* USB 2.0 spec, 7.1.7.3 / fig 7-29:\n *\n * Between connect detection and reset signaling there must be a delay\n * of 100ms at least for debounce and power-settling.  The corresponding\n * timer shall restart whenever the downstream port detects a disconnect.\n *\n * Apparently there are some bluetooth and irda-dongles and a number of\n * low-speed devices for which this debounce period may last over a second.\n * Not covered by the spec - but easy to deal with.\n *\n * This implementation uses a 1500ms total debounce timeout; if the\n * connection isn't stable by then it returns -ETIMEDOUT.  It checks\n * every 25ms for transient disconnects.  When the port status has been\n * unchanged for 100ms it returns the port status.\n */\nint hub_port_debounce(struct usb_hub *hub, int port1, bool must_be_connected)\n{\n\tint ret;\n\tu16 portchange, portstatus;\n\tunsigned connection = 0xffff;\n\tint total_time, stable_time = 0;\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\n\tfor (total_time = 0; ; total_time += HUB_DEBOUNCE_STEP) {\n\t\tret = hub_port_status(hub, port1, &portstatus, &portchange);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tif (!(portchange & USB_PORT_STAT_C_CONNECTION) &&\n\t\t     (portstatus & USB_PORT_STAT_CONNECTION) == connection) {\n\t\t\tif (!must_be_connected ||\n\t\t\t     (connection == USB_PORT_STAT_CONNECTION))\n\t\t\t\tstable_time += HUB_DEBOUNCE_STEP;\n\t\t\tif (stable_time >= HUB_DEBOUNCE_STABLE)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tstable_time = 0;\n\t\t\tconnection = portstatus & USB_PORT_STAT_CONNECTION;\n\t\t}\n\n\t\tif (portchange & USB_PORT_STAT_C_CONNECTION) {\n\t\t\tusb_clear_port_feature(hub->hdev, port1,\n\t\t\t\t\tUSB_PORT_FEAT_C_CONNECTION);\n\t\t}\n\n\t\tif (total_time >= HUB_DEBOUNCE_TIMEOUT)\n\t\t\tbreak;\n\t\tmsleep(HUB_DEBOUNCE_STEP);\n\t}\n\n\tdev_dbg(&port_dev->dev, \"debounce total %dms stable %dms status 0x%x\\n\",\n\t\t\ttotal_time, stable_time, portstatus);\n\n\tif (stable_time < HUB_DEBOUNCE_STABLE)\n\t\treturn -ETIMEDOUT;\n\treturn portstatus;\n}\n\nvoid usb_ep0_reinit(struct usb_device *udev)\n{\n\tusb_disable_endpoint(udev, 0 + USB_DIR_IN, true);\n\tusb_disable_endpoint(udev, 0 + USB_DIR_OUT, true);\n\tusb_enable_endpoint(udev, &udev->ep0, true);\n}\nEXPORT_SYMBOL_GPL(usb_ep0_reinit);\n\n#define usb_sndaddr0pipe()\t(PIPE_CONTROL << 30)\n#define usb_rcvaddr0pipe()\t((PIPE_CONTROL << 30) | USB_DIR_IN)\n\nstatic int hub_set_address(struct usb_device *udev, int devnum)\n{\n\tint retval;\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\t/*\n\t * The host controller will choose the device address,\n\t * instead of the core having chosen it earlier\n\t */\n\tif (!hcd->driver->address_device && devnum <= 1)\n\t\treturn -EINVAL;\n\tif (udev->state == USB_STATE_ADDRESS)\n\t\treturn 0;\n\tif (udev->state != USB_STATE_DEFAULT)\n\t\treturn -EINVAL;\n\tif (hcd->driver->address_device)\n\t\tretval = hcd->driver->address_device(hcd, udev);\n\telse\n\t\tretval = usb_control_msg(udev, usb_sndaddr0pipe(),\n\t\t\t\tUSB_REQ_SET_ADDRESS, 0, devnum, 0,\n\t\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (retval == 0) {\n\t\tupdate_devnum(udev, devnum);\n\t\t/* Device now using proper address. */\n\t\tusb_set_device_state(udev, USB_STATE_ADDRESS);\n\t\tusb_ep0_reinit(udev);\n\t}\n\treturn retval;\n}\n\n/*\n * There are reports of USB 3.0 devices that say they support USB 2.0 Link PM\n * when they're plugged into a USB 2.0 port, but they don't work when LPM is\n * enabled.\n *\n * Only enable USB 2.0 Link PM if the port is internal (hardwired), or the\n * device says it supports the new USB 2.0 Link PM errata by setting the BESL\n * support bit in the BOS descriptor.\n */\nstatic void hub_set_initial_usb2_lpm_policy(struct usb_device *udev)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(udev->parent);\n\tint connect_type = USB_PORT_CONNECT_TYPE_UNKNOWN;\n\n\tif (!udev->usb2_hw_lpm_capable)\n\t\treturn;\n\n\tif (hub)\n\t\tconnect_type = hub->ports[udev->portnum - 1]->connect_type;\n\n\tif ((udev->bos->ext_cap->bmAttributes & cpu_to_le32(USB_BESL_SUPPORT)) ||\n\t\t\tconnect_type == USB_PORT_CONNECT_TYPE_HARD_WIRED) {\n\t\tudev->usb2_hw_lpm_allowed = 1;\n\t\tusb_set_usb2_hardware_lpm(udev, 1);\n\t}\n}\n\nstatic int hub_enable_device(struct usb_device *udev)\n{\n\tstruct usb_hcd *hcd = bus_to_hcd(udev->bus);\n\n\tif (!hcd->driver->enable_device)\n\t\treturn 0;\n\tif (udev->state == USB_STATE_ADDRESS)\n\t\treturn 0;\n\tif (udev->state != USB_STATE_DEFAULT)\n\t\treturn -EINVAL;\n\n\treturn hcd->driver->enable_device(hcd, udev);\n}\n\n/* Reset device, (re)assign address, get device descriptor.\n * Device connection must be stable, no more debouncing needed.\n * Returns device in USB_STATE_ADDRESS, except on error.\n *\n * If this is called for an already-existing device (as part of\n * usb_reset_and_verify_device), the caller must own the device lock and\n * the port lock.  For a newly detected device that is not accessible\n * through any global pointers, it's not necessary to lock the device,\n * but it is still necessary to lock the port.\n */\nstatic int\nhub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,\n\t\tint retry_counter)\n{\n\tstruct usb_device\t*hdev = hub->hdev;\n\tstruct usb_hcd\t\t*hcd = bus_to_hcd(hdev->bus);\n\tint\t\t\ti, j, retval;\n\tunsigned\t\tdelay = HUB_SHORT_RESET_TIME;\n\tenum usb_device_speed\toldspeed = udev->speed;\n\tconst char\t\t*speed;\n\tint\t\t\tdevnum = udev->devnum;\n\n\t/* root hub ports have a slightly longer reset period\n\t * (from USB 2.0 spec, section 7.1.7.5)\n\t */\n\tif (!hdev->parent) {\n\t\tdelay = HUB_ROOT_RESET_TIME;\n\t\tif (port1 == hdev->bus->otg_port)\n\t\t\thdev->bus->b_hnp_enable = 0;\n\t}\n\n\t/* Some low speed devices have problems with the quick delay, so */\n\t/*  be a bit pessimistic with those devices. RHbug #23670 */\n\tif (oldspeed == USB_SPEED_LOW)\n\t\tdelay = HUB_LONG_RESET_TIME;\n\n\tmutex_lock(&hdev->bus->usb_address0_mutex);\n\n\t/* Reset the device; full speed may morph to high speed */\n\t/* FIXME a USB 2.0 device may morph into SuperSpeed on reset. */\n\tretval = hub_port_reset(hub, port1, udev, delay, false);\n\tif (retval < 0)\t\t/* error or disconnect */\n\t\tgoto fail;\n\t/* success, speed is known */\n\n\tretval = -ENODEV;\n\n\tif (oldspeed != USB_SPEED_UNKNOWN && oldspeed != udev->speed) {\n\t\tdev_dbg(&udev->dev, \"device reset changed speed!\\n\");\n\t\tgoto fail;\n\t}\n\toldspeed = udev->speed;\n\n\t/* USB 2.0 section 5.5.3 talks about ep0 maxpacket ...\n\t * it's fixed size except for full speed devices.\n\t * For Wireless USB devices, ep0 max packet is always 512 (tho\n\t * reported as 0xff in the device descriptor). WUSB1.0[4.8.1].\n\t */\n\tswitch (udev->speed) {\n\tcase USB_SPEED_SUPER:\n\tcase USB_SPEED_WIRELESS:\t/* fixed at 512 */\n\t\tudev->ep0.desc.wMaxPacketSize = cpu_to_le16(512);\n\t\tbreak;\n\tcase USB_SPEED_HIGH:\t\t/* fixed at 64 */\n\t\tudev->ep0.desc.wMaxPacketSize = cpu_to_le16(64);\n\t\tbreak;\n\tcase USB_SPEED_FULL:\t\t/* 8, 16, 32, or 64 */\n\t\t/* to determine the ep0 maxpacket size, try to read\n\t\t * the device descriptor to get bMaxPacketSize0 and\n\t\t * then correct our initial guess.\n\t\t */\n\t\tudev->ep0.desc.wMaxPacketSize = cpu_to_le16(64);\n\t\tbreak;\n\tcase USB_SPEED_LOW:\t\t/* fixed at 8 */\n\t\tudev->ep0.desc.wMaxPacketSize = cpu_to_le16(8);\n\t\tbreak;\n\tdefault:\n\t\tgoto fail;\n\t}\n\n\tif (udev->speed == USB_SPEED_WIRELESS)\n\t\tspeed = \"variable speed Wireless\";\n\telse\n\t\tspeed = usb_speed_string(udev->speed);\n\n\tif (udev->speed != USB_SPEED_SUPER)\n\t\tdev_info(&udev->dev,\n\t\t\t\t\"%s %s USB device number %d using %s\\n\",\n\t\t\t\t(udev->config) ? \"reset\" : \"new\", speed,\n\t\t\t\tdevnum, udev->bus->controller->driver->name);\n\n\t/* Set up TT records, if needed  */\n\tif (hdev->tt) {\n\t\tudev->tt = hdev->tt;\n\t\tudev->ttport = hdev->ttport;\n\t} else if (udev->speed != USB_SPEED_HIGH\n\t\t\t&& hdev->speed == USB_SPEED_HIGH) {\n\t\tif (!hub->tt.hub) {\n\t\t\tdev_err(&udev->dev, \"parent hub has no TT\\n\");\n\t\t\tretval = -EINVAL;\n\t\t\tgoto fail;\n\t\t}\n\t\tudev->tt = &hub->tt;\n\t\tudev->ttport = port1;\n\t}\n\n\t/* Why interleave GET_DESCRIPTOR and SET_ADDRESS this way?\n\t * Because device hardware and firmware is sometimes buggy in\n\t * this area, and this is how Linux has done it for ages.\n\t * Change it cautiously.\n\t *\n\t * NOTE:  If use_new_scheme() is true we will start by issuing\n\t * a 64-byte GET_DESCRIPTOR request.  This is what Windows does,\n\t * so it may help with some non-standards-compliant devices.\n\t * Otherwise we start with SET_ADDRESS and then try to read the\n\t * first 8 bytes of the device descriptor to get the ep0 maxpacket\n\t * value.\n\t */\n\tfor (i = 0; i < GET_DESCRIPTOR_TRIES; (++i, msleep(100))) {\n\t\tbool did_new_scheme = false;\n\n\t\tif (use_new_scheme(udev, retry_counter)) {\n\t\t\tstruct usb_device_descriptor *buf;\n\t\t\tint r = 0;\n\n\t\t\tdid_new_scheme = true;\n\t\t\tretval = hub_enable_device(udev);\n\t\t\tif (retval < 0) {\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"hub failed to enable device, error %d\\n\",\n\t\t\t\t\tretval);\n\t\t\t\tgoto fail;\n\t\t\t}\n\n#define GET_DESCRIPTOR_BUFSIZE\t64\n\t\t\tbuf = kmalloc(GET_DESCRIPTOR_BUFSIZE, GFP_NOIO);\n\t\t\tif (!buf) {\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Retry on all errors; some devices are flakey.\n\t\t\t * 255 is for WUSB devices, we actually need to use\n\t\t\t * 512 (WUSB1.0[4.8.1]).\n\t\t\t */\n\t\t\tfor (j = 0; j < 3; ++j) {\n\t\t\t\tbuf->bMaxPacketSize0 = 0;\n\t\t\t\tr = usb_control_msg(udev, usb_rcvaddr0pipe(),\n\t\t\t\t\tUSB_REQ_GET_DESCRIPTOR, USB_DIR_IN,\n\t\t\t\t\tUSB_DT_DEVICE << 8, 0,\n\t\t\t\t\tbuf, GET_DESCRIPTOR_BUFSIZE,\n\t\t\t\t\tinitial_descriptor_timeout);\n\t\t\t\tswitch (buf->bMaxPacketSize0) {\n\t\t\t\tcase 8: case 16: case 32: case 64: case 255:\n\t\t\t\t\tif (buf->bDescriptorType ==\n\t\t\t\t\t\t\tUSB_DT_DEVICE) {\n\t\t\t\t\t\tr = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/* FALL THROUGH */\n\t\t\t\tdefault:\n\t\t\t\t\tif (r == 0)\n\t\t\t\t\t\tr = -EPROTO;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (r == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tudev->descriptor.bMaxPacketSize0 =\n\t\t\t\t\tbuf->bMaxPacketSize0;\n\t\t\tkfree(buf);\n\n\t\t\tretval = hub_port_reset(hub, port1, udev, delay, false);\n\t\t\tif (retval < 0)\t\t/* error or disconnect */\n\t\t\t\tgoto fail;\n\t\t\tif (oldspeed != udev->speed) {\n\t\t\t\tdev_dbg(&udev->dev,\n\t\t\t\t\t\"device reset changed speed!\\n\");\n\t\t\t\tretval = -ENODEV;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tif (r) {\n\t\t\t\tif (r != -ENODEV)\n\t\t\t\t\tdev_err(&udev->dev, \"device descriptor read/64, error %d\\n\",\n\t\t\t\t\t\t\tr);\n\t\t\t\tretval = -EMSGSIZE;\n\t\t\t\tcontinue;\n\t\t\t}\n#undef GET_DESCRIPTOR_BUFSIZE\n\t\t}\n\n\t\t/*\n\t\t * If device is WUSB, we already assigned an\n\t\t * unauthorized address in the Connect Ack sequence;\n\t\t * authorization will assign the final address.\n\t\t */\n\t\tif (udev->wusb == 0) {\n\t\t\tfor (j = 0; j < SET_ADDRESS_TRIES; ++j) {\n\t\t\t\tretval = hub_set_address(udev, devnum);\n\t\t\t\tif (retval >= 0)\n\t\t\t\t\tbreak;\n\t\t\t\tmsleep(200);\n\t\t\t}\n\t\t\tif (retval < 0) {\n\t\t\t\tif (retval != -ENODEV)\n\t\t\t\t\tdev_err(&udev->dev, \"device not accepting address %d, error %d\\n\",\n\t\t\t\t\t\t\tdevnum, retval);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tif (udev->speed == USB_SPEED_SUPER) {\n\t\t\t\tdevnum = udev->devnum;\n\t\t\t\tdev_info(&udev->dev,\n\t\t\t\t\t\t\"%s SuperSpeed USB device number %d using %s\\n\",\n\t\t\t\t\t\t(udev->config) ? \"reset\" : \"new\",\n\t\t\t\t\t\tdevnum, udev->bus->controller->driver->name);\n\t\t\t}\n\n\t\t\t/* cope with hardware quirkiness:\n\t\t\t *  - let SET_ADDRESS settle, some device hardware wants it\n\t\t\t *  - read ep0 maxpacket even for high and low speed,\n\t\t\t */\n\t\t\tmsleep(10);\n\t\t\t/* use_new_scheme() checks the speed which may have\n\t\t\t * changed since the initial look so we cache the result\n\t\t\t * in did_new_scheme\n\t\t\t */\n\t\t\tif (did_new_scheme)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tretval = usb_get_device_descriptor(udev, 8);\n\t\tif (retval < 8) {\n\t\t\tif (retval != -ENODEV)\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"device descriptor read/8, error %d\\n\",\n\t\t\t\t\tretval);\n\t\t\tif (retval >= 0)\n\t\t\t\tretval = -EMSGSIZE;\n\t\t} else {\n\t\t\tretval = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (retval)\n\t\tgoto fail;\n\n\t/*\n\t * Some superspeed devices have finished the link training process\n\t * and attached to a superspeed hub port, but the device descriptor\n\t * got from those devices show they aren't superspeed devices. Warm\n\t * reset the port attached by the devices can fix them.\n\t */\n\tif ((udev->speed == USB_SPEED_SUPER) &&\n\t\t\t(le16_to_cpu(udev->descriptor.bcdUSB) < 0x0300)) {\n\t\tdev_err(&udev->dev, \"got a wrong device descriptor, \"\n\t\t\t\t\"warm reset device\\n\");\n\t\thub_port_reset(hub, port1, udev,\n\t\t\t\tHUB_BH_RESET_TIME, true);\n\t\tretval = -EINVAL;\n\t\tgoto fail;\n\t}\n\n\tif (udev->descriptor.bMaxPacketSize0 == 0xff ||\n\t\t\tudev->speed == USB_SPEED_SUPER)\n\t\ti = 512;\n\telse\n\t\ti = udev->descriptor.bMaxPacketSize0;\n\tif (usb_endpoint_maxp(&udev->ep0.desc) != i) {\n\t\tif (udev->speed == USB_SPEED_LOW ||\n\t\t\t\t!(i == 8 || i == 16 || i == 32 || i == 64)) {\n\t\t\tdev_err(&udev->dev, \"Invalid ep0 maxpacket: %d\\n\", i);\n\t\t\tretval = -EMSGSIZE;\n\t\t\tgoto fail;\n\t\t}\n\t\tif (udev->speed == USB_SPEED_FULL)\n\t\t\tdev_dbg(&udev->dev, \"ep0 maxpacket = %d\\n\", i);\n\t\telse\n\t\t\tdev_warn(&udev->dev, \"Using ep0 maxpacket: %d\\n\", i);\n\t\tudev->ep0.desc.wMaxPacketSize = cpu_to_le16(i);\n\t\tusb_ep0_reinit(udev);\n\t}\n\n\tretval = usb_get_device_descriptor(udev, USB_DT_DEVICE_SIZE);\n\tif (retval < (signed)sizeof(udev->descriptor)) {\n\t\tif (retval != -ENODEV)\n\t\t\tdev_err(&udev->dev, \"device descriptor read/all, error %d\\n\",\n\t\t\t\t\tretval);\n\t\tif (retval >= 0)\n\t\t\tretval = -ENOMSG;\n\t\tgoto fail;\n\t}\n\n\tusb_detect_quirks(udev);\n\n\tif (udev->wusb == 0 && le16_to_cpu(udev->descriptor.bcdUSB) >= 0x0201) {\n\t\tretval = usb_get_bos_descriptor(udev);\n\t\tif (!retval) {\n\t\t\tudev->lpm_capable = usb_device_supports_lpm(udev);\n\t\t\tusb_set_lpm_parameters(udev);\n\t\t}\n\t}\n\n\tretval = 0;\n\t/* notify HCD that we have a device connected and addressed */\n\tif (hcd->driver->update_device)\n\t\thcd->driver->update_device(hcd, udev);\n\thub_set_initial_usb2_lpm_policy(udev);\nfail:\n\tif (retval) {\n\t\thub_port_disable(hub, port1, 0);\n\t\tupdate_devnum(udev, devnum);\t/* for disconnect processing */\n\t}\n\tmutex_unlock(&hdev->bus->usb_address0_mutex);\n\treturn retval;\n}\n\nstatic void\ncheck_highspeed(struct usb_hub *hub, struct usb_device *udev, int port1)\n{\n\tstruct usb_qualifier_descriptor\t*qual;\n\tint\t\t\t\tstatus;\n\n\tif (udev->quirks & USB_QUIRK_DEVICE_QUALIFIER)\n\t\treturn;\n\n\tqual = kmalloc(sizeof *qual, GFP_KERNEL);\n\tif (qual == NULL)\n\t\treturn;\n\n\tstatus = usb_get_descriptor(udev, USB_DT_DEVICE_QUALIFIER, 0,\n\t\t\tqual, sizeof *qual);\n\tif (status == sizeof *qual) {\n\t\tdev_info(&udev->dev, \"not running at top speed; \"\n\t\t\t\"connect to a high speed hub\\n\");\n\t\t/* hub LEDs are probably harder to miss than syslog */\n\t\tif (hub->has_indicators) {\n\t\t\thub->indicator[port1-1] = INDICATOR_GREEN_BLINK;\n\t\t\tqueue_delayed_work(system_power_efficient_wq,\n\t\t\t\t\t&hub->leds, 0);\n\t\t}\n\t}\n\tkfree(qual);\n}\n\nstatic unsigned\nhub_power_remaining(struct usb_hub *hub)\n{\n\tstruct usb_device *hdev = hub->hdev;\n\tint remaining;\n\tint port1;\n\n\tif (!hub->limited_power)\n\t\treturn 0;\n\n\tremaining = hdev->bus_mA - hub->descriptor->bHubContrCurrent;\n\tfor (port1 = 1; port1 <= hdev->maxchild; ++port1) {\n\t\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\t\tstruct usb_device *udev = port_dev->child;\n\t\tunsigned unit_load;\n\t\tint delta;\n\n\t\tif (!udev)\n\t\t\tcontinue;\n\t\tif (hub_is_superspeed(udev))\n\t\t\tunit_load = 150;\n\t\telse\n\t\t\tunit_load = 100;\n\n\t\t/*\n\t\t * Unconfigured devices may not use more than one unit load,\n\t\t * or 8mA for OTG ports\n\t\t */\n\t\tif (udev->actconfig)\n\t\t\tdelta = usb_get_max_power(udev, udev->actconfig);\n\t\telse if (port1 != udev->bus->otg_port || hdev->parent)\n\t\t\tdelta = unit_load;\n\t\telse\n\t\t\tdelta = 8;\n\t\tif (delta > hub->mA_per_port)\n\t\t\tdev_warn(&port_dev->dev, \"%dmA is over %umA budget!\\n\",\n\t\t\t\t\tdelta, hub->mA_per_port);\n\t\tremaining -= delta;\n\t}\n\tif (remaining < 0) {\n\t\tdev_warn(hub->intfdev, \"%dmA over power budget!\\n\",\n\t\t\t-remaining);\n\t\tremaining = 0;\n\t}\n\treturn remaining;\n}\n\nstatic void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,\n\t\tu16 portchange)\n{\n\tint status, i;\n\tunsigned unit_load;\n\tstruct usb_device *hdev = hub->hdev;\n\tstruct usb_hcd *hcd = bus_to_hcd(hdev->bus);\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tstruct usb_device *udev = port_dev->child;\n\tstatic int unreliable_port = -1;\n\n\t/* Disconnect any existing devices under this port */\n\tif (udev) {\n\t\tif (hcd->usb_phy && !hdev->parent)\n\t\t\tusb_phy_notify_disconnect(hcd->usb_phy, udev->speed);\n\t\tusb_disconnect(&port_dev->child);\n\t}\n\n\t/* We can forget about a \"removed\" device when there's a physical\n\t * disconnect or the connect status changes.\n\t */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\t(portchange & USB_PORT_STAT_C_CONNECTION))\n\t\tclear_bit(port1, hub->removed_bits);\n\n\tif (portchange & (USB_PORT_STAT_C_CONNECTION |\n\t\t\t\tUSB_PORT_STAT_C_ENABLE)) {\n\t\tstatus = hub_port_debounce_be_stable(hub, port1);\n\t\tif (status < 0) {\n\t\t\tif (status != -ENODEV &&\n\t\t\t\tport1 != unreliable_port &&\n\t\t\t\tprintk_ratelimit())\n\t\t\t\tdev_err(&port_dev->dev, \"connect-debounce failed\\n\");\n\t\t\tportstatus &= ~USB_PORT_STAT_CONNECTION;\n\t\t\tunreliable_port = port1;\n\t\t} else {\n\t\t\tportstatus = status;\n\t\t}\n\t}\n\n\t/* Return now if debouncing failed or nothing is connected or\n\t * the device was \"removed\".\n\t */\n\tif (!(portstatus & USB_PORT_STAT_CONNECTION) ||\n\t\t\ttest_bit(port1, hub->removed_bits)) {\n\n\t\t/*\n\t\t * maybe switch power back on (e.g. root hub was reset)\n\t\t * but only if the port isn't owned by someone else.\n\t\t */\n\t\tif (hub_is_port_power_switchable(hub)\n\t\t\t\t&& !port_is_power_on(hub, portstatus)\n\t\t\t\t&& !port_dev->port_owner)\n\t\t\tset_port_feature(hdev, port1, USB_PORT_FEAT_POWER);\n\n\t\tif (portstatus & USB_PORT_STAT_ENABLE)\n\t\t\tgoto done;\n\t\treturn;\n\t}\n\tif (hub_is_superspeed(hub->hdev))\n\t\tunit_load = 150;\n\telse\n\t\tunit_load = 100;\n\n\tstatus = 0;\n\tfor (i = 0; i < SET_CONFIG_TRIES; i++) {\n\n\t\t/* reallocate for each attempt, since references\n\t\t * to the previous one can escape in various ways\n\t\t */\n\t\tudev = usb_alloc_dev(hdev, hdev->bus, port1);\n\t\tif (!udev) {\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"couldn't allocate usb_device\\n\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tusb_set_device_state(udev, USB_STATE_POWERED);\n\t\tudev->bus_mA = hub->mA_per_port;\n\t\tudev->level = hdev->level + 1;\n\t\tudev->wusb = hub_is_wusb(hub);\n\n\t\t/* Only USB 3.0 devices are connected to SuperSpeed hubs. */\n\t\tif (hub_is_superspeed(hub->hdev))\n\t\t\tudev->speed = USB_SPEED_SUPER;\n\t\telse\n\t\t\tudev->speed = USB_SPEED_UNKNOWN;\n\n\t\tchoose_devnum(udev);\n\t\tif (udev->devnum <= 0) {\n\t\t\tstatus = -ENOTCONN;\t/* Don't retry */\n\t\t\tgoto loop;\n\t\t}\n\n\t\t/* reset (non-USB 3.0 devices) and get descriptor */\n\t\tusb_lock_port(port_dev);\n\t\tstatus = hub_port_init(hub, udev, port1, i);\n\t\tusb_unlock_port(port_dev);\n\t\tif (status < 0)\n\t\t\tgoto loop;\n\n\t\tif (udev->quirks & USB_QUIRK_DELAY_INIT)\n\t\t\tmsleep(1000);\n\n\t\t/* consecutive bus-powered hubs aren't reliable; they can\n\t\t * violate the voltage drop budget.  if the new child has\n\t\t * a \"powered\" LED, users should notice we didn't enable it\n\t\t * (without reading syslog), even without per-port LEDs\n\t\t * on the parent.\n\t\t */\n\t\tif (udev->descriptor.bDeviceClass == USB_CLASS_HUB\n\t\t\t\t&& udev->bus_mA <= unit_load) {\n\t\t\tu16\tdevstat;\n\n\t\t\tstatus = usb_get_status(udev, USB_RECIP_DEVICE, 0,\n\t\t\t\t\t&devstat);\n\t\t\tif (status) {\n\t\t\t\tdev_dbg(&udev->dev, \"get status %d ?\\n\", status);\n\t\t\t\tgoto loop_disable;\n\t\t\t}\n\t\t\tif ((devstat & (1 << USB_DEVICE_SELF_POWERED)) == 0) {\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t\"can't connect bus-powered hub \"\n\t\t\t\t\t\"to this port\\n\");\n\t\t\t\tif (hub->has_indicators) {\n\t\t\t\t\thub->indicator[port1-1] =\n\t\t\t\t\t\tINDICATOR_AMBER_BLINK;\n\t\t\t\t\tqueue_delayed_work(\n\t\t\t\t\t\tsystem_power_efficient_wq,\n\t\t\t\t\t\t&hub->leds, 0);\n\t\t\t\t}\n\t\t\t\tstatus = -ENOTCONN;\t/* Don't retry */\n\t\t\t\tgoto loop_disable;\n\t\t\t}\n\t\t}\n\n\t\t/* check for devices running slower than they could */\n\t\tif (le16_to_cpu(udev->descriptor.bcdUSB) >= 0x0200\n\t\t\t\t&& udev->speed == USB_SPEED_FULL\n\t\t\t\t&& highspeed_hubs != 0)\n\t\t\tcheck_highspeed(hub, udev, port1);\n\n\t\t/* Store the parent's children[] pointer.  At this point\n\t\t * udev becomes globally accessible, although presumably\n\t\t * no one will look at it until hdev is unlocked.\n\t\t */\n\t\tstatus = 0;\n\n\t\tmutex_lock(&usb_port_peer_mutex);\n\n\t\t/* We mustn't add new devices if the parent hub has\n\t\t * been disconnected; we would race with the\n\t\t * recursively_mark_NOTATTACHED() routine.\n\t\t */\n\t\tspin_lock_irq(&device_state_lock);\n\t\tif (hdev->state == USB_STATE_NOTATTACHED)\n\t\t\tstatus = -ENOTCONN;\n\t\telse\n\t\t\tport_dev->child = udev;\n\t\tspin_unlock_irq(&device_state_lock);\n\t\tmutex_unlock(&usb_port_peer_mutex);\n\n\t\t/* Run it through the hoops (find a driver, etc) */\n\t\tif (!status) {\n\t\t\tstatus = usb_new_device(udev);\n\t\t\tif (status) {\n\t\t\t\tmutex_lock(&usb_port_peer_mutex);\n\t\t\t\tspin_lock_irq(&device_state_lock);\n\t\t\t\tport_dev->child = NULL;\n\t\t\t\tspin_unlock_irq(&device_state_lock);\n\t\t\t\tmutex_unlock(&usb_port_peer_mutex);\n\t\t\t} else {\n\t\t\t\tif (hcd->usb_phy && !hdev->parent)\n\t\t\t\t\tusb_phy_notify_connect(hcd->usb_phy,\n\t\t\t\t\t\t\tudev->speed);\n\t\t\t}\n\t\t}\n\n\t\tif (status)\n\t\t\tgoto loop_disable;\n\n\t\tstatus = hub_power_remaining(hub);\n\t\tif (status)\n\t\t\tdev_dbg(hub->intfdev, \"%dmA power budget left\\n\", status);\n\n\t\treturn;\n\nloop_disable:\n\t\thub_port_disable(hub, port1, 1);\nloop:\n\t\tusb_ep0_reinit(udev);\n\t\trelease_devnum(udev);\n\t\thub_free_dev(udev);\n\t\tusb_put_dev(udev);\n\t\tif ((status == -ENOTCONN) || (status == -ENOTSUPP))\n\t\t\tbreak;\n\t}\n\tif (hub->hdev->parent ||\n\t\t\t!hcd->driver->port_handed_over ||\n\t\t\t!(hcd->driver->port_handed_over)(hcd, port1)) {\n\t\tif (status != -ENOTCONN && status != -ENODEV)\n\t\t\tdev_err(&port_dev->dev,\n\t\t\t\t\t\"unable to enumerate USB device\\n\");\n\t}\n\ndone:\n\thub_port_disable(hub, port1, 1);\n\tif (hcd->driver->relinquish_port && !hub->hdev->parent)\n\t\thcd->driver->relinquish_port(hcd, port1);\n\n}\n\n/* Handle physical or logical connection change events.\n * This routine is called when:\n *\ta port connection-change occurs;\n *\ta port enable-change occurs (often caused by EMI);\n *\tusb_reset_and_verify_device() encounters changed descriptors (as from\n *\t\ta firmware download)\n * caller already locked the hub\n */\nstatic void hub_port_connect_change(struct usb_hub *hub, int port1,\n\t\t\t\t\tu16 portstatus, u16 portchange)\n\t\t__must_hold(&port_dev->status_lock)\n{\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tstruct usb_device *udev = port_dev->child;\n\tint status = -ENODEV;\n\n\tdev_dbg(&port_dev->dev, \"status %04x, change %04x, %s\\n\", portstatus,\n\t\t\tportchange, portspeed(hub, portstatus));\n\n\tif (hub->has_indicators) {\n\t\tset_port_led(hub, port1, HUB_LED_AUTO);\n\t\thub->indicator[port1-1] = INDICATOR_AUTO;\n\t}\n\n#ifdef\tCONFIG_USB_OTG\n\t/* during HNP, don't repeat the debounce */\n\tif (hub->hdev->bus->is_b_host)\n\t\tportchange &= ~(USB_PORT_STAT_C_CONNECTION |\n\t\t\t\tUSB_PORT_STAT_C_ENABLE);\n#endif\n\n\t/* Try to resuscitate an existing device */\n\tif ((portstatus & USB_PORT_STAT_CONNECTION) && udev &&\n\t\t\tudev->state != USB_STATE_NOTATTACHED) {\n\t\tif (portstatus & USB_PORT_STAT_ENABLE) {\n\t\t\tstatus = 0;\t\t/* Nothing to do */\n#ifdef CONFIG_PM\n\t\t} else if (udev->state == USB_STATE_SUSPENDED &&\n\t\t\t\tudev->persist_enabled) {\n\t\t\t/* For a suspended device, treat this as a\n\t\t\t * remote wakeup event.\n\t\t\t */\n\t\t\tusb_unlock_port(port_dev);\n\t\t\tstatus = usb_remote_wakeup(udev);\n\t\t\tusb_lock_port(port_dev);\n#endif\n\t\t} else {\n\t\t\t/* Don't resuscitate */;\n\t\t}\n\t}\n\tclear_bit(port1, hub->change_bits);\n\n\t/* successfully revalidated the connection */\n\tif (status == 0)\n\t\treturn;\n\n\tusb_unlock_port(port_dev);\n\thub_port_connect(hub, port1, portstatus, portchange);\n\tusb_lock_port(port_dev);\n}\n\nstatic void port_event(struct usb_hub *hub, int port1)\n\t\t__must_hold(&port_dev->status_lock)\n{\n\tint connect_change;\n\tstruct usb_port *port_dev = hub->ports[port1 - 1];\n\tstruct usb_device *udev = port_dev->child;\n\tstruct usb_device *hdev = hub->hdev;\n\tu16 portstatus, portchange;\n\n\tconnect_change = test_bit(port1, hub->change_bits);\n\tclear_bit(port1, hub->event_bits);\n\tclear_bit(port1, hub->wakeup_bits);\n\n\tif (hub_port_status(hub, port1, &portstatus, &portchange) < 0)\n\t\treturn;\n\n\tif (portchange & USB_PORT_STAT_C_CONNECTION) {\n\t\tusb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_CONNECTION);\n\t\tconnect_change = 1;\n\t}\n\n\tif (portchange & USB_PORT_STAT_C_ENABLE) {\n\t\tif (!connect_change)\n\t\t\tdev_dbg(&port_dev->dev, \"enable change, status %08x\\n\",\n\t\t\t\t\tportstatus);\n\t\tusb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_ENABLE);\n\n\t\t/*\n\t\t * EM interference sometimes causes badly shielded USB devices\n\t\t * to be shutdown by the hub, this hack enables them again.\n\t\t * Works at least with mouse driver.\n\t\t */\n\t\tif (!(portstatus & USB_PORT_STAT_ENABLE)\n\t\t    && !connect_change && udev) {\n\t\t\tdev_err(&port_dev->dev, \"disabled by hub (EMI?), re-enabling...\\n\");\n\t\t\tconnect_change = 1;\n\t\t}\n\t}\n\n\tif (portchange & USB_PORT_STAT_C_OVERCURRENT) {\n\t\tu16 status = 0, unused;\n\n\t\tdev_dbg(&port_dev->dev, \"over-current change\\n\");\n\t\tusb_clear_port_feature(hdev, port1,\n\t\t\t\tUSB_PORT_FEAT_C_OVER_CURRENT);\n\t\tmsleep(100);\t/* Cool down */\n\t\thub_power_on(hub, true);\n\t\thub_port_status(hub, port1, &status, &unused);\n\t\tif (status & USB_PORT_STAT_OVERCURRENT)\n\t\t\tdev_err(&port_dev->dev, \"over-current condition\\n\");\n\t}\n\n\tif (portchange & USB_PORT_STAT_C_RESET) {\n\t\tdev_dbg(&port_dev->dev, \"reset change\\n\");\n\t\tusb_clear_port_feature(hdev, port1, USB_PORT_FEAT_C_RESET);\n\t}\n\tif ((portchange & USB_PORT_STAT_C_BH_RESET)\n\t    && hub_is_superspeed(hdev)) {\n\t\tdev_dbg(&port_dev->dev, \"warm reset change\\n\");\n\t\tusb_clear_port_feature(hdev, port1,\n\t\t\t\tUSB_PORT_FEAT_C_BH_PORT_RESET);\n\t}\n\tif (portchange & USB_PORT_STAT_C_LINK_STATE) {\n\t\tdev_dbg(&port_dev->dev, \"link state change\\n\");\n\t\tusb_clear_port_feature(hdev, port1,\n\t\t\t\tUSB_PORT_FEAT_C_PORT_LINK_STATE);\n\t}\n\tif (portchange & USB_PORT_STAT_C_CONFIG_ERROR) {\n\t\tdev_warn(&port_dev->dev, \"config error\\n\");\n\t\tusb_clear_port_feature(hdev, port1,\n\t\t\t\tUSB_PORT_FEAT_C_PORT_CONFIG_ERROR);\n\t}\n\n\t/* skip port actions that require the port to be powered on */\n\tif (!pm_runtime_active(&port_dev->dev))\n\t\treturn;\n\n\tif (hub_handle_remote_wakeup(hub, port1, portstatus, portchange))\n\t\tconnect_change = 1;\n\n\t/*\n\t * Warm reset a USB3 protocol port if it's in\n\t * SS.Inactive state.\n\t */\n\tif (hub_port_warm_reset_required(hub, port1, portstatus)) {\n\t\tdev_dbg(&port_dev->dev, \"do warm reset\\n\");\n\t\tif (!udev || !(portstatus & USB_PORT_STAT_CONNECTION)\n\t\t\t\t|| udev->state == USB_STATE_NOTATTACHED) {\n\t\t\tif (hub_port_reset(hub, port1, NULL,\n\t\t\t\t\tHUB_BH_RESET_TIME, true) < 0)\n\t\t\t\thub_port_disable(hub, port1, 1);\n\t\t} else {\n\t\t\tusb_unlock_port(port_dev);\n\t\t\tusb_lock_device(udev);\n\t\t\tusb_reset_device(udev);\n\t\t\tusb_unlock_device(udev);\n\t\t\tusb_lock_port(port_dev);\n\t\t\tconnect_change = 0;\n\t\t}\n\t}\n\n\tif (connect_change)\n\t\thub_port_connect_change(hub, port1, portstatus, portchange);\n}\n\nstatic void hub_event(struct work_struct *work)\n{\n\tstruct usb_device *hdev;\n\tstruct usb_interface *intf;\n\tstruct usb_hub *hub;\n\tstruct device *hub_dev;\n\tu16 hubstatus;\n\tu16 hubchange;\n\tint i, ret;\n\n\thub = container_of(work, struct usb_hub, events);\n\thdev = hub->hdev;\n\thub_dev = hub->intfdev;\n\tintf = to_usb_interface(hub_dev);\n\n\tdev_dbg(hub_dev, \"state %d ports %d chg %04x evt %04x\\n\",\n\t\t\thdev->state, hdev->maxchild,\n\t\t\t/* NOTE: expects max 15 ports... */\n\t\t\t(u16) hub->change_bits[0],\n\t\t\t(u16) hub->event_bits[0]);\n\n\t/* Lock the device, then check to see if we were\n\t * disconnected while waiting for the lock to succeed. */\n\tusb_lock_device(hdev);\n\tif (unlikely(hub->disconnected))\n\t\tgoto out_hdev_lock;\n\n\t/* If the hub has died, clean up after it */\n\tif (hdev->state == USB_STATE_NOTATTACHED) {\n\t\thub->error = -ENODEV;\n\t\thub_quiesce(hub, HUB_DISCONNECT);\n\t\tgoto out_hdev_lock;\n\t}\n\n\t/* Autoresume */\n\tret = usb_autopm_get_interface(intf);\n\tif (ret) {\n\t\tdev_dbg(hub_dev, \"Can't autoresume: %d\\n\", ret);\n\t\tgoto out_hdev_lock;\n\t}\n\n\t/* If this is an inactive hub, do nothing */\n\tif (hub->quiescing)\n\t\tgoto out_autopm;\n\n\tif (hub->error) {\n\t\tdev_dbg(hub_dev, \"resetting for error %d\\n\", hub->error);\n\n\t\tret = usb_reset_device(hdev);\n\t\tif (ret) {\n\t\t\tdev_dbg(hub_dev, \"error resetting hub: %d\\n\", ret);\n\t\t\tgoto out_autopm;\n\t\t}\n\n\t\thub->nerrors = 0;\n\t\thub->error = 0;\n\t}\n\n\t/* deal with port status changes */\n\tfor (i = 1; i <= hdev->maxchild; i++) {\n\t\tstruct usb_port *port_dev = hub->ports[i - 1];\n\n\t\tif (test_bit(i, hub->event_bits)\n\t\t\t\t|| test_bit(i, hub->change_bits)\n\t\t\t\t|| test_bit(i, hub->wakeup_bits)) {\n\t\t\t/*\n\t\t\t * The get_noresume and barrier ensure that if\n\t\t\t * the port was in the process of resuming, we\n\t\t\t * flush that work and keep the port active for\n\t\t\t * the duration of the port_event().  However,\n\t\t\t * if the port is runtime pm suspended\n\t\t\t * (powered-off), we leave it in that state, run\n\t\t\t * an abbreviated port_event(), and move on.\n\t\t\t */\n\t\t\tpm_runtime_get_noresume(&port_dev->dev);\n\t\t\tpm_runtime_barrier(&port_dev->dev);\n\t\t\tusb_lock_port(port_dev);\n\t\t\tport_event(hub, i);\n\t\t\tusb_unlock_port(port_dev);\n\t\t\tpm_runtime_put_sync(&port_dev->dev);\n\t\t}\n\t}\n\n\t/* deal with hub status changes */\n\tif (test_and_clear_bit(0, hub->event_bits) == 0)\n\t\t;\t/* do nothing */\n\telse if (hub_hub_status(hub, &hubstatus, &hubchange) < 0)\n\t\tdev_err(hub_dev, \"get_hub_status failed\\n\");\n\telse {\n\t\tif (hubchange & HUB_CHANGE_LOCAL_POWER) {\n\t\t\tdev_dbg(hub_dev, \"power change\\n\");\n\t\t\tclear_hub_feature(hdev, C_HUB_LOCAL_POWER);\n\t\t\tif (hubstatus & HUB_STATUS_LOCAL_POWER)\n\t\t\t\t/* FIXME: Is this always true? */\n\t\t\t\thub->limited_power = 1;\n\t\t\telse\n\t\t\t\thub->limited_power = 0;\n\t\t}\n\t\tif (hubchange & HUB_CHANGE_OVERCURRENT) {\n\t\t\tu16 status = 0;\n\t\t\tu16 unused;\n\n\t\t\tdev_dbg(hub_dev, \"over-current change\\n\");\n\t\t\tclear_hub_feature(hdev, C_HUB_OVER_CURRENT);\n\t\t\tmsleep(500);\t/* Cool down */\n\t\t\thub_power_on(hub, true);\n\t\t\thub_hub_status(hub, &status, &unused);\n\t\t\tif (status & HUB_STATUS_OVERCURRENT)\n\t\t\t\tdev_err(hub_dev, \"over-current condition\\n\");\n\t\t}\n\t}\n\nout_autopm:\n\t/* Balance the usb_autopm_get_interface() above */\n\tusb_autopm_put_interface_no_suspend(intf);\nout_hdev_lock:\n\tusb_unlock_device(hdev);\n\n\t/* Balance the stuff in kick_hub_wq() and allow autosuspend */\n\tusb_autopm_put_interface(intf);\n\tkref_put(&hub->kref, hub_release);\n}\n\nstatic const struct usb_device_id hub_id_table[] = {\n    { .match_flags = USB_DEVICE_ID_MATCH_VENDOR\n\t\t\t| USB_DEVICE_ID_MATCH_INT_CLASS,\n      .idVendor = USB_VENDOR_GENESYS_LOGIC,\n      .bInterfaceClass = USB_CLASS_HUB,\n      .driver_info = HUB_QUIRK_CHECK_PORT_AUTOSUSPEND},\n    { .match_flags = USB_DEVICE_ID_MATCH_DEV_CLASS,\n      .bDeviceClass = USB_CLASS_HUB},\n    { .match_flags = USB_DEVICE_ID_MATCH_INT_CLASS,\n      .bInterfaceClass = USB_CLASS_HUB},\n    { }\t\t\t\t\t\t/* Terminating entry */\n};\n\nMODULE_DEVICE_TABLE(usb, hub_id_table);\n\nstatic struct usb_driver hub_driver = {\n\t.name =\t\t\"hub\",\n\t.probe =\thub_probe,\n\t.disconnect =\thub_disconnect,\n\t.suspend =\thub_suspend,\n\t.resume =\thub_resume,\n\t.reset_resume =\thub_reset_resume,\n\t.pre_reset =\thub_pre_reset,\n\t.post_reset =\thub_post_reset,\n\t.unlocked_ioctl = hub_ioctl,\n\t.id_table =\thub_id_table,\n\t.supports_autosuspend =\t1,\n};\n\nint usb_hub_init(void)\n{\n\tif (usb_register(&hub_driver) < 0) {\n\t\tprintk(KERN_ERR \"%s: can't register hub driver\\n\",\n\t\t\tusbcore_name);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * The workqueue needs to be freezable to avoid interfering with\n\t * USB-PERSIST port handover. Otherwise it might see that a full-speed\n\t * device was gone before the EHCI controller had handed its port\n\t * over to the companion full-speed controller.\n\t */\n\thub_wq = alloc_workqueue(\"usb_hub_wq\", WQ_FREEZABLE, 0);\n\tif (hub_wq)\n\t\treturn 0;\n\n\t/* Fall through if kernel_thread failed */\n\tusb_deregister(&hub_driver);\n\tpr_err(\"%s: can't allocate workqueue for usb hub\\n\", usbcore_name);\n\n\treturn -1;\n}\n\nvoid usb_hub_cleanup(void)\n{\n\tdestroy_workqueue(hub_wq);\n\n\t/*\n\t * Hub resources are freed for us by usb_deregister. It calls\n\t * usb_driver_purge on every device which in turn calls that\n\t * devices disconnect function if it is using this driver.\n\t * The hub_disconnect function takes care of releasing the\n\t * individual hub resources. -greg\n\t */\n\tusb_deregister(&hub_driver);\n} /* usb_hub_cleanup() */\n\nstatic int descriptors_changed(struct usb_device *udev,\n\t\tstruct usb_device_descriptor *old_device_descriptor,\n\t\tstruct usb_host_bos *old_bos)\n{\n\tint\t\tchanged = 0;\n\tunsigned\tindex;\n\tunsigned\tserial_len = 0;\n\tunsigned\tlen;\n\tunsigned\told_length;\n\tint\t\tlength;\n\tchar\t\t*buf;\n\n\tif (memcmp(&udev->descriptor, old_device_descriptor,\n\t\t\tsizeof(*old_device_descriptor)) != 0)\n\t\treturn 1;\n\n\tif ((old_bos && !udev->bos) || (!old_bos && udev->bos))\n\t\treturn 1;\n\tif (udev->bos) {\n\t\tlen = le16_to_cpu(udev->bos->desc->wTotalLength);\n\t\tif (len != le16_to_cpu(old_bos->desc->wTotalLength))\n\t\t\treturn 1;\n\t\tif (memcmp(udev->bos->desc, old_bos->desc, len))\n\t\t\treturn 1;\n\t}\n\n\t/* Since the idVendor, idProduct, and bcdDevice values in the\n\t * device descriptor haven't changed, we will assume the\n\t * Manufacturer and Product strings haven't changed either.\n\t * But the SerialNumber string could be different (e.g., a\n\t * different flash card of the same brand).\n\t */\n\tif (udev->serial)\n\t\tserial_len = strlen(udev->serial) + 1;\n\n\tlen = serial_len;\n\tfor (index = 0; index < udev->descriptor.bNumConfigurations; index++) {\n\t\told_length = le16_to_cpu(udev->config[index].desc.wTotalLength);\n\t\tlen = max(len, old_length);\n\t}\n\n\tbuf = kmalloc(len, GFP_NOIO);\n\tif (buf == NULL) {\n\t\tdev_err(&udev->dev, \"no mem to re-read configs after reset\\n\");\n\t\t/* assume the worst */\n\t\treturn 1;\n\t}\n\tfor (index = 0; index < udev->descriptor.bNumConfigurations; index++) {\n\t\told_length = le16_to_cpu(udev->config[index].desc.wTotalLength);\n\t\tlength = usb_get_descriptor(udev, USB_DT_CONFIG, index, buf,\n\t\t\t\told_length);\n\t\tif (length != old_length) {\n\t\t\tdev_dbg(&udev->dev, \"config index %d, error %d\\n\",\n\t\t\t\t\tindex, length);\n\t\t\tchanged = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (memcmp(buf, udev->rawdescriptors[index], old_length)\n\t\t\t\t!= 0) {\n\t\t\tdev_dbg(&udev->dev, \"config index %d changed (#%d)\\n\",\n\t\t\t\tindex,\n\t\t\t\t((struct usb_config_descriptor *) buf)->\n\t\t\t\t\tbConfigurationValue);\n\t\t\tchanged = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!changed && serial_len) {\n\t\tlength = usb_string(udev, udev->descriptor.iSerialNumber,\n\t\t\t\tbuf, serial_len);\n\t\tif (length + 1 != serial_len) {\n\t\t\tdev_dbg(&udev->dev, \"serial string error %d\\n\",\n\t\t\t\t\tlength);\n\t\t\tchanged = 1;\n\t\t} else if (memcmp(buf, udev->serial, length) != 0) {\n\t\t\tdev_dbg(&udev->dev, \"serial string changed\\n\");\n\t\t\tchanged = 1;\n\t\t}\n\t}\n\n\tkfree(buf);\n\treturn changed;\n}\n\n/**\n * usb_reset_and_verify_device - perform a USB port reset to reinitialize a device\n * @udev: device to reset (not in SUSPENDED or NOTATTACHED state)\n *\n * WARNING - don't use this routine to reset a composite device\n * (one with multiple interfaces owned by separate drivers)!\n * Use usb_reset_device() instead.\n *\n * Do a port reset, reassign the device's address, and establish its\n * former operating configuration.  If the reset fails, or the device's\n * descriptors change from their values before the reset, or the original\n * configuration and altsettings cannot be restored, a flag will be set\n * telling hub_wq to pretend the device has been disconnected and then\n * re-connected.  All drivers will be unbound, and the device will be\n * re-enumerated and probed all over again.\n *\n * Return: 0 if the reset succeeded, -ENODEV if the device has been\n * flagged for logical disconnection, or some other negative error code\n * if the reset wasn't even attempted.\n *\n * Note:\n * The caller must own the device lock and the port lock, the latter is\n * taken by usb_reset_device().  For example, it's safe to use\n * usb_reset_device() from a driver probe() routine after downloading\n * new firmware.  For calls that might not occur during probe(), drivers\n * should lock the device using usb_lock_device_for_reset().\n *\n * Locking exception: This routine may also be called from within an\n * autoresume handler.  Such usage won't conflict with other tasks\n * holding the device lock because these tasks should always call\n * usb_autopm_resume_device(), thereby preventing any unwanted\n * autoresume.  The autoresume handler is expected to have already\n * acquired the port lock before calling this routine.\n */\nstatic int usb_reset_and_verify_device(struct usb_device *udev)\n{\n\tstruct usb_device\t\t*parent_hdev = udev->parent;\n\tstruct usb_hub\t\t\t*parent_hub;\n\tstruct usb_hcd\t\t\t*hcd = bus_to_hcd(udev->bus);\n\tstruct usb_device_descriptor\tdescriptor = udev->descriptor;\n\tstruct usb_host_bos\t\t*bos;\n\tint\t\t\t\ti, j, ret = 0;\n\tint\t\t\t\tport1 = udev->portnum;\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!parent_hdev)\n\t\treturn -EISDIR;\n\n\tparent_hub = usb_hub_to_struct_hub(parent_hdev);\n\n\t/* Disable USB2 hardware LPM.\n\t * It will be re-enabled by the enumeration process.\n\t */\n\tif (udev->usb2_hw_lpm_enabled == 1)\n\t\tusb_set_usb2_hardware_lpm(udev, 0);\n\n\t/* Disable LPM and LTM while we reset the device and reinstall the alt\n\t * settings.  Device-initiated LPM settings, and system exit latency\n\t * settings are cleared when the device is reset, so we have to set\n\t * them up again.\n\t */\n\tret = usb_unlocked_disable_lpm(udev);\n\tif (ret) {\n\t\tdev_err(&udev->dev, \"%s Failed to disable LPM\\n.\", __func__);\n\t\tgoto re_enumerate_no_bos;\n\t}\n\tret = usb_disable_ltm(udev);\n\tif (ret) {\n\t\tdev_err(&udev->dev, \"%s Failed to disable LTM\\n.\",\n\t\t\t\t__func__);\n\t\tgoto re_enumerate_no_bos;\n\t}\n\n\tbos = udev->bos;\n\tudev->bos = NULL;\n\n\tfor (i = 0; i < SET_CONFIG_TRIES; ++i) {\n\n\t\t/* ep0 maxpacket size may change; let the HCD know about it.\n\t\t * Other endpoints will be handled by re-enumeration. */\n\t\tusb_ep0_reinit(udev);\n\t\tret = hub_port_init(parent_hub, udev, port1, i);\n\t\tif (ret >= 0 || ret == -ENOTCONN || ret == -ENODEV)\n\t\t\tbreak;\n\t}\n\n\tif (ret < 0)\n\t\tgoto re_enumerate;\n\n\t/* Device might have changed firmware (DFU or similar) */\n\tif (descriptors_changed(udev, &descriptor, bos)) {\n\t\tdev_info(&udev->dev, \"device firmware changed\\n\");\n\t\tudev->descriptor = descriptor;\t/* for disconnect() calls */\n\t\tgoto re_enumerate;\n\t}\n\n\t/* Restore the device's previous configuration */\n\tif (!udev->actconfig)\n\t\tgoto done;\n\n\tmutex_lock(hcd->bandwidth_mutex);\n\tret = usb_hcd_alloc_bandwidth(udev, udev->actconfig, NULL, NULL);\n\tif (ret < 0) {\n\t\tdev_warn(&udev->dev,\n\t\t\t\t\"Busted HC?  Not enough HCD resources for \"\n\t\t\t\t\"old configuration.\\n\");\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tret = usb_control_msg(udev, usb_sndctrlpipe(udev, 0),\n\t\t\tUSB_REQ_SET_CONFIGURATION, 0,\n\t\t\tudev->actconfig->desc.bConfigurationValue, 0,\n\t\t\tNULL, 0, USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_err(&udev->dev,\n\t\t\t\"can't restore configuration #%d (error=%d)\\n\",\n\t\t\tudev->actconfig->desc.bConfigurationValue, ret);\n\t\tmutex_unlock(hcd->bandwidth_mutex);\n\t\tgoto re_enumerate;\n\t}\n\tmutex_unlock(hcd->bandwidth_mutex);\n\tusb_set_device_state(udev, USB_STATE_CONFIGURED);\n\n\t/* Put interfaces back into the same altsettings as before.\n\t * Don't bother to send the Set-Interface request for interfaces\n\t * that were already in altsetting 0; besides being unnecessary,\n\t * many devices can't handle it.  Instead just reset the host-side\n\t * endpoint state.\n\t */\n\tfor (i = 0; i < udev->actconfig->desc.bNumInterfaces; i++) {\n\t\tstruct usb_host_config *config = udev->actconfig;\n\t\tstruct usb_interface *intf = config->interface[i];\n\t\tstruct usb_interface_descriptor *desc;\n\n\t\tdesc = &intf->cur_altsetting->desc;\n\t\tif (desc->bAlternateSetting == 0) {\n\t\t\tusb_disable_interface(udev, intf, true);\n\t\t\tusb_enable_interface(udev, intf, true);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\t/* Let the bandwidth allocation function know that this\n\t\t\t * device has been reset, and it will have to use\n\t\t\t * alternate setting 0 as the current alternate setting.\n\t\t\t */\n\t\t\tintf->resetting_device = 1;\n\t\t\tret = usb_set_interface(udev, desc->bInterfaceNumber,\n\t\t\t\t\tdesc->bAlternateSetting);\n\t\t\tintf->resetting_device = 0;\n\t\t}\n\t\tif (ret < 0) {\n\t\t\tdev_err(&udev->dev, \"failed to restore interface %d \"\n\t\t\t\t\"altsetting %d (error=%d)\\n\",\n\t\t\t\tdesc->bInterfaceNumber,\n\t\t\t\tdesc->bAlternateSetting,\n\t\t\t\tret);\n\t\t\tgoto re_enumerate;\n\t\t}\n\t\t/* Resetting also frees any allocated streams */\n\t\tfor (j = 0; j < intf->cur_altsetting->desc.bNumEndpoints; j++)\n\t\t\tintf->cur_altsetting->endpoint[j].streams = 0;\n\t}\n\ndone:\n\t/* Now that the alt settings are re-installed, enable LTM and LPM. */\n\tusb_set_usb2_hardware_lpm(udev, 1);\n\tusb_unlocked_enable_lpm(udev);\n\tusb_enable_ltm(udev);\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\n\treturn 0;\n\nre_enumerate:\n\tusb_release_bos_descriptor(udev);\n\tudev->bos = bos;\nre_enumerate_no_bos:\n\t/* LPM state doesn't matter when we're about to destroy the device. */\n\thub_port_logical_disconnect(parent_hub, port1);\n\treturn -ENODEV;\n}\n\n/**\n * usb_reset_device - warn interface drivers and perform a USB port reset\n * @udev: device to reset (not in SUSPENDED or NOTATTACHED state)\n *\n * Warns all drivers bound to registered interfaces (using their pre_reset\n * method), performs the port reset, and then lets the drivers know that\n * the reset is over (using their post_reset method).\n *\n * Return: The same as for usb_reset_and_verify_device().\n *\n * Note:\n * The caller must own the device lock.  For example, it's safe to use\n * this from a driver probe() routine after downloading new firmware.\n * For calls that might not occur during probe(), drivers should lock\n * the device using usb_lock_device_for_reset().\n *\n * If an interface is currently being probed or disconnected, we assume\n * its driver knows how to handle resets.  For all other interfaces,\n * if the driver doesn't have pre_reset and post_reset methods then\n * we attempt to unbind it and rebind afterward.\n */\nint usb_reset_device(struct usb_device *udev)\n{\n\tint ret;\n\tint i;\n\tunsigned int noio_flag;\n\tstruct usb_port *port_dev;\n\tstruct usb_host_config *config = udev->actconfig;\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(udev->parent);\n\n\tif (udev->state == USB_STATE_NOTATTACHED ||\n\t\t\tudev->state == USB_STATE_SUSPENDED) {\n\t\tdev_dbg(&udev->dev, \"device reset not allowed in state %d\\n\",\n\t\t\t\tudev->state);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!udev->parent) {\n\t\t/* this requires hcd-specific logic; see ohci_restart() */\n\t\tdev_dbg(&udev->dev, \"%s for root hub!\\n\", __func__);\n\t\treturn -EISDIR;\n\t}\n\n\tport_dev = hub->ports[udev->portnum - 1];\n\n\t/*\n\t * Don't allocate memory with GFP_KERNEL in current\n\t * context to avoid possible deadlock if usb mass\n\t * storage interface or usbnet interface(iSCSI case)\n\t * is included in current configuration. The easist\n\t * approach is to do it for every device reset,\n\t * because the device 'memalloc_noio' flag may have\n\t * not been set before reseting the usb device.\n\t */\n\tnoio_flag = memalloc_noio_save();\n\n\t/* Prevent autosuspend during the reset */\n\tusb_autoresume_device(udev);\n\n\tif (config) {\n\t\tfor (i = 0; i < config->desc.bNumInterfaces; ++i) {\n\t\t\tstruct usb_interface *cintf = config->interface[i];\n\t\t\tstruct usb_driver *drv;\n\t\t\tint unbind = 0;\n\n\t\t\tif (cintf->dev.driver) {\n\t\t\t\tdrv = to_usb_driver(cintf->dev.driver);\n\t\t\t\tif (drv->pre_reset && drv->post_reset)\n\t\t\t\t\tunbind = (drv->pre_reset)(cintf);\n\t\t\t\telse if (cintf->condition ==\n\t\t\t\t\t\tUSB_INTERFACE_BOUND)\n\t\t\t\t\tunbind = 1;\n\t\t\t\tif (unbind)\n\t\t\t\t\tusb_forced_unbind_intf(cintf);\n\t\t\t}\n\t\t}\n\t}\n\n\tusb_lock_port(port_dev);\n\tret = usb_reset_and_verify_device(udev);\n\tusb_unlock_port(port_dev);\n\n\tif (config) {\n\t\tfor (i = config->desc.bNumInterfaces - 1; i >= 0; --i) {\n\t\t\tstruct usb_interface *cintf = config->interface[i];\n\t\t\tstruct usb_driver *drv;\n\t\t\tint rebind = cintf->needs_binding;\n\n\t\t\tif (!rebind && cintf->dev.driver) {\n\t\t\t\tdrv = to_usb_driver(cintf->dev.driver);\n\t\t\t\tif (drv->post_reset)\n\t\t\t\t\trebind = (drv->post_reset)(cintf);\n\t\t\t\telse if (cintf->condition ==\n\t\t\t\t\t\tUSB_INTERFACE_BOUND)\n\t\t\t\t\trebind = 1;\n\t\t\t\tif (rebind)\n\t\t\t\t\tcintf->needs_binding = 1;\n\t\t\t}\n\t\t}\n\t\tusb_unbind_and_rebind_marked_interfaces(udev);\n\t}\n\n\tusb_autosuspend_device(udev);\n\tmemalloc_noio_restore(noio_flag);\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(usb_reset_device);\n\n\n/**\n * usb_queue_reset_device - Reset a USB device from an atomic context\n * @iface: USB interface belonging to the device to reset\n *\n * This function can be used to reset a USB device from an atomic\n * context, where usb_reset_device() won't work (as it blocks).\n *\n * Doing a reset via this method is functionally equivalent to calling\n * usb_reset_device(), except for the fact that it is delayed to a\n * workqueue. This means that any drivers bound to other interfaces\n * might be unbound, as well as users from usbfs in user space.\n *\n * Corner cases:\n *\n * - Scheduling two resets at the same time from two different drivers\n *   attached to two different interfaces of the same device is\n *   possible; depending on how the driver attached to each interface\n *   handles ->pre_reset(), the second reset might happen or not.\n *\n * - If the reset is delayed so long that the interface is unbound from\n *   its driver, the reset will be skipped.\n *\n * - This function can be called during .probe().  It can also be called\n *   during .disconnect(), but doing so is pointless because the reset\n *   will not occur.  If you really want to reset the device during\n *   .disconnect(), call usb_reset_device() directly -- but watch out\n *   for nested unbinding issues!\n */\nvoid usb_queue_reset_device(struct usb_interface *iface)\n{\n\tif (schedule_work(&iface->reset_ws))\n\t\tusb_get_intf(iface);\n}\nEXPORT_SYMBOL_GPL(usb_queue_reset_device);\n\n/**\n * usb_hub_find_child - Get the pointer of child device\n * attached to the port which is specified by @port1.\n * @hdev: USB device belonging to the usb hub\n * @port1: port num to indicate which port the child device\n *\tis attached to.\n *\n * USB drivers call this function to get hub's child device\n * pointer.\n *\n * Return: %NULL if input param is invalid and\n * child's usb_device pointer if non-NULL.\n */\nstruct usb_device *usb_hub_find_child(struct usb_device *hdev,\n\t\tint port1)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\n\tif (port1 < 1 || port1 > hdev->maxchild)\n\t\treturn NULL;\n\treturn hub->ports[port1 - 1]->child;\n}\nEXPORT_SYMBOL_GPL(usb_hub_find_child);\n\nvoid usb_hub_adjust_deviceremovable(struct usb_device *hdev,\n\t\tstruct usb_hub_descriptor *desc)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\tenum usb_port_connect_type connect_type;\n\tint i;\n\n\tif (!hub)\n\t\treturn;\n\n\tif (!hub_is_superspeed(hdev)) {\n\t\tfor (i = 1; i <= hdev->maxchild; i++) {\n\t\t\tstruct usb_port *port_dev = hub->ports[i - 1];\n\n\t\t\tconnect_type = port_dev->connect_type;\n\t\t\tif (connect_type == USB_PORT_CONNECT_TYPE_HARD_WIRED) {\n\t\t\t\tu8 mask = 1 << (i%8);\n\n\t\t\t\tif (!(desc->u.hs.DeviceRemovable[i/8] & mask)) {\n\t\t\t\t\tdev_dbg(&port_dev->dev, \"DeviceRemovable is changed to 1 according to platform information.\\n\");\n\t\t\t\t\tdesc->u.hs.DeviceRemovable[i/8]\t|= mask;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tu16 port_removable = le16_to_cpu(desc->u.ss.DeviceRemovable);\n\n\t\tfor (i = 1; i <= hdev->maxchild; i++) {\n\t\t\tstruct usb_port *port_dev = hub->ports[i - 1];\n\n\t\t\tconnect_type = port_dev->connect_type;\n\t\t\tif (connect_type == USB_PORT_CONNECT_TYPE_HARD_WIRED) {\n\t\t\t\tu16 mask = 1 << i;\n\n\t\t\t\tif (!(port_removable & mask)) {\n\t\t\t\t\tdev_dbg(&port_dev->dev, \"DeviceRemovable is changed to 1 according to platform information.\\n\");\n\t\t\t\t\tport_removable |= mask;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdesc->u.ss.DeviceRemovable = cpu_to_le16(port_removable);\n\t}\n}\n\n#ifdef CONFIG_ACPI\n/**\n * usb_get_hub_port_acpi_handle - Get the usb port's acpi handle\n * @hdev: USB device belonging to the usb hub\n * @port1: port num of the port\n *\n * Return: Port's acpi handle if successful, %NULL if params are\n * invalid.\n */\nacpi_handle usb_get_hub_port_acpi_handle(struct usb_device *hdev,\n\tint port1)\n{\n\tstruct usb_hub *hub = usb_hub_to_struct_hub(hdev);\n\n\tif (!hub)\n\t\treturn NULL;\n\n\treturn ACPI_HANDLE(&hub->ports[port1 - 1]->dev);\n}\n#endif\n"], "filenames": ["drivers/usb/core/hub.c"], "buggy_code_start_loc": [1038], "buggy_code_end_loc": [1259], "fixing_code_start_loc": [1038], "fixing_code_end_loc": [1276], "type": "NVD-CWE-Other", "message": "The hub_activate function in drivers/usb/core/hub.c in the Linux kernel before 4.3.5 does not properly maintain a hub-interface data structure, which allows physically proximate attackers to cause a denial of service (invalid memory access and system crash) or possibly have unspecified other impact by unplugging a USB hub device.", "other": {"cve": {"id": "CVE-2015-8816", "sourceIdentifier": "cve@mitre.org", "published": "2016-04-27T17:59:03.147", "lastModified": "2016-12-03T03:14:54.603", "vulnStatus": "Modified", "evaluatorComment": "<a href=\"http://cwe.mitre.org/data/definitions/476.html\">CWE-476: NULL Pointer Dereference</a>", "descriptions": [{"lang": "en", "value": "The hub_activate function in drivers/usb/core/hub.c in the Linux kernel before 4.3.5 does not properly maintain a hub-interface data structure, which allows physically proximate attackers to cause a denial of service (invalid memory access and system crash) or possibly have unspecified other impact by unplugging a USB hub device."}, {"lang": "es", "value": "La funci\u00f3n hub_activate en drivers/usb/core/hub.c en el Kernel de Linux en versiones anteriores a 4.3.5 no mantiene correctamente una estructura de datos hub-interface, lo que permite a atacantes f\u00edsicamente pr\u00f3ximos provocar una denegaci\u00f3n de servicio (acceso a memoria no v\u00e1lido y ca\u00edda de sistema) o posiblemente tener otro impacto no especificado desenchufando un dispositivo hub USB."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:P/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:novell:suse_linux_enterprise_debuginfo:11:sp4:*:*:*:*:*:*", "matchCriteriaId": "B942E0F5-7FDC-4AE5-985D-25F4EA7406F1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:novell:suse_linux_enterprise_desktop:12.0:*:*:*:*:*:*:*", "matchCriteriaId": "EA04C9F1-6257-4D82-BA0B-37DE66D94736"}, {"vulnerable": true, "criteria": "cpe:2.3:o:novell:suse_linux_enterprise_live_patching:12.0:*:*:*:*:*:*:*", "matchCriteriaId": "CCAAE4A1-D542-43F3-B7FC-685BCDB248D5"}, {"vulnerable": true, "criteria": "cpe:2.3:o:novell:suse_linux_enterprise_module_for_public_cloud:12:*:*:*:*:*:*:*", "matchCriteriaId": "0441632F-40BF-432B-BB1C-6396C726C4F6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:novell:suse_linux_enterprise_real_time_extension:11:sp4:*:*:*:*:*:*", "matchCriteriaId": "BFF56CE7-91EF-4FF9-B306-5F00249D9FEA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:novell:suse_linux_enterprise_real_time_extension:12:sp1:*:*:*:*:*:*", "matchCriteriaId": "5AB3CAA1-C20C-4A86-841E-EC0858164D7D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:novell:suse_linux_enterprise_server:11:extra:*:*:*:*:*:*", "matchCriteriaId": "4B24E780-3254-4577-BCFF-7FBB6D97C780"}, {"vulnerable": true, "criteria": "cpe:2.3:o:novell:suse_linux_enterprise_server:11:sp4:*:*:*:*:*:*", "matchCriteriaId": "095856BE-4E55-4FEA-BCAC-352C29083545"}, {"vulnerable": true, "criteria": "cpe:2.3:o:novell:suse_linux_enterprise_server:12.0:*:*:*:*:*:*:*", "matchCriteriaId": "C384D0B6-8A5C-45CA-8CD9-7F4E967FE4F0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:novell:suse_linux_enterprise_software_development_kit:11.0:sp4:*:*:*:*:*:*", "matchCriteriaId": "F1E42F04-5E14-4CF6-BD26-C54A4ECD99CF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:novell:suse_linux_enterprise_software_development_kit:12.0:*:*:*:*:*:*:*", "matchCriteriaId": "E85AFCCA-8B55-4F7C-A282-691CCA624D79"}, {"vulnerable": true, "criteria": "cpe:2.3:o:novell:suse_linux_enterprise_workstation_extension:12.0:*:*:*:*:*:*:*", "matchCriteriaId": "DF461FB4-8BA5-4065-9A69-DC017D3611C3"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.3.4", "matchCriteriaId": "FB73CB50-4648-4986-92D3-7B39CFE1204C"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=e50293ef9775c5f1cf3fcc093037dd6a8c5684ea", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-04/msg00019.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-06/msg00052.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-06/msg00054.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-06/msg00059.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-07/msg00005.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-08/msg00003.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-08/msg00008.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-08/msg00009.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-08/msg00015.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-08/msg00016.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-08/msg00018.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-08/msg00019.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-08/msg00020.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-08/msg00021.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-08/msg00022.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-08/msg00026.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2016-08/msg00038.html", "source": "cve@mitre.org"}, {"url": "http://source.android.com/security/bulletin/2016-07-01.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.debian.org/security/2016/dsa-3503", "source": "cve@mitre.org"}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.3.5", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/02/23/5", "source": "cve@mitre.org"}, {"url": "http://www.oracle.com/technetwork/topics/security/linuxbulletinjul2016-3090544.html", "source": "cve@mitre.org"}, {"url": "http://www.oracle.com/technetwork/topics/security/ovmbulletinoct2016-3090547.html", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/83363", "source": "cve@mitre.org"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1311589", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/torvalds/linux/commit/e50293ef9775c5f1cf3fcc093037dd6a8c5684ea", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/e50293ef9775c5f1cf3fcc093037dd6a8c5684ea"}}