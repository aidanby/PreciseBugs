{"buggy_code": ["package configs\n\nconst (\n\t// EXT_COPYUP is a directive to copy up the contents of a directory when\n\t// a tmpfs is mounted over it.\n\tEXT_COPYUP = 1 << iota //nolint:golint // ignore \"don't use ALL_CAPS\" warning\n)\n\ntype Mount struct {\n\t// Source path for the mount.\n\tSource string `json:\"source\"`\n\n\t// Destination path for the mount inside the container.\n\tDestination string `json:\"destination\"`\n\n\t// Device the mount is for.\n\tDevice string `json:\"device\"`\n\n\t// Mount flags.\n\tFlags int `json:\"flags\"`\n\n\t// Propagation Flags\n\tPropagationFlags []int `json:\"propagation_flags\"`\n\n\t// Mount data applied to the mount.\n\tData string `json:\"data\"`\n\n\t// Relabel source if set, \"z\" indicates shared, \"Z\" indicates unshared.\n\tRelabel string `json:\"relabel\"`\n\n\t// Extensions are additional flags that are specific to runc.\n\tExtensions int `json:\"extensions\"`\n\n\t// Optional Command to be run before Source is mounted.\n\tPremountCmds []Command `json:\"premount_cmds\"`\n\n\t// Optional Command to be run after Source is mounted.\n\tPostmountCmds []Command `json:\"postmount_cmds\"`\n}\n", "package libcontainer\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/checkpoint-restore/go-criu/v5\"\n\tcriurpc \"github.com/checkpoint-restore/go-criu/v5/rpc\"\n\tsecurejoin \"github.com/cyphar/filepath-securejoin\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"golang.org/x/sys/unix\"\n\t\"google.golang.org/protobuf/proto\"\n\n\t\"github.com/opencontainers/runc/libcontainer/cgroups\"\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/opencontainers/runc/libcontainer/intelrdt\"\n\t\"github.com/opencontainers/runc/libcontainer/system\"\n\t\"github.com/opencontainers/runc/libcontainer/utils\"\n)\n\nconst stdioFdCount = 3\n\ntype linuxContainer struct {\n\tid                   string\n\troot                 string\n\tconfig               *configs.Config\n\tcgroupManager        cgroups.Manager\n\tintelRdtManager      intelrdt.Manager\n\tinitPath             string\n\tinitArgs             []string\n\tinitProcess          parentProcess\n\tinitProcessStartTime uint64\n\tcriuPath             string\n\tnewuidmapPath        string\n\tnewgidmapPath        string\n\tm                    sync.Mutex\n\tcriuVersion          int\n\tstate                containerState\n\tcreated              time.Time\n\tfifo                 *os.File\n}\n\n// State represents a running container's state\ntype State struct {\n\tBaseState\n\n\t// Platform specific fields below here\n\n\t// Specified if the container was started under the rootless mode.\n\t// Set to true if BaseState.Config.RootlessEUID && BaseState.Config.RootlessCgroups\n\tRootless bool `json:\"rootless\"`\n\n\t// Paths to all the container's cgroups, as returned by (*cgroups.Manager).GetPaths\n\t//\n\t// For cgroup v1, a key is cgroup subsystem name, and the value is the path\n\t// to the cgroup for this subsystem.\n\t//\n\t// For cgroup v2 unified hierarchy, a key is \"\", and the value is the unified path.\n\tCgroupPaths map[string]string `json:\"cgroup_paths\"`\n\n\t// NamespacePaths are filepaths to the container's namespaces. Key is the namespace type\n\t// with the value as the path.\n\tNamespacePaths map[configs.NamespaceType]string `json:\"namespace_paths\"`\n\n\t// Container's standard descriptors (std{in,out,err}), needed for checkpoint and restore\n\tExternalDescriptors []string `json:\"external_descriptors,omitempty\"`\n\n\t// Intel RDT \"resource control\" filesystem path\n\tIntelRdtPath string `json:\"intel_rdt_path\"`\n}\n\n// Container is a libcontainer container object.\n//\n// Each container is thread-safe within the same process. Since a container can\n// be destroyed by a separate process, any function may return that the container\n// was not found.\ntype Container interface {\n\tBaseContainer\n\n\t// Methods below here are platform specific\n\n\t// Checkpoint checkpoints the running container's state to disk using the criu(8) utility.\n\tCheckpoint(criuOpts *CriuOpts) error\n\n\t// Restore restores the checkpointed container to a running state using the criu(8) utility.\n\tRestore(process *Process, criuOpts *CriuOpts) error\n\n\t// If the Container state is RUNNING or CREATED, sets the Container state to PAUSING and pauses\n\t// the execution of any user processes. Asynchronously, when the container finished being paused the\n\t// state is changed to PAUSED.\n\t// If the Container state is PAUSED, do nothing.\n\tPause() error\n\n\t// If the Container state is PAUSED, resumes the execution of any user processes in the\n\t// Container before setting the Container state to RUNNING.\n\t// If the Container state is RUNNING, do nothing.\n\tResume() error\n\n\t// NotifyOOM returns a read-only channel signaling when the container receives an OOM notification.\n\tNotifyOOM() (<-chan struct{}, error)\n\n\t// NotifyMemoryPressure returns a read-only channel signaling when the container reaches a given pressure level\n\tNotifyMemoryPressure(level PressureLevel) (<-chan struct{}, error)\n}\n\n// ID returns the container's unique ID\nfunc (c *linuxContainer) ID() string {\n\treturn c.id\n}\n\n// Config returns the container's configuration\nfunc (c *linuxContainer) Config() configs.Config {\n\treturn *c.config\n}\n\nfunc (c *linuxContainer) Status() (Status, error) {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\treturn c.currentStatus()\n}\n\nfunc (c *linuxContainer) State() (*State, error) {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\treturn c.currentState()\n}\n\nfunc (c *linuxContainer) OCIState() (*specs.State, error) {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\treturn c.currentOCIState()\n}\n\nfunc (c *linuxContainer) Processes() ([]int, error) {\n\tvar pids []int\n\tstatus, err := c.currentStatus()\n\tif err != nil {\n\t\treturn pids, err\n\t}\n\t// for systemd cgroup, the unit's cgroup path will be auto removed if container's all processes exited\n\tif status == Stopped && !c.cgroupManager.Exists() {\n\t\treturn pids, nil\n\t}\n\n\tpids, err = c.cgroupManager.GetAllPids()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to get all container pids: %w\", err)\n\t}\n\treturn pids, nil\n}\n\nfunc (c *linuxContainer) Stats() (*Stats, error) {\n\tvar (\n\t\terr   error\n\t\tstats = &Stats{}\n\t)\n\tif stats.CgroupStats, err = c.cgroupManager.GetStats(); err != nil {\n\t\treturn stats, fmt.Errorf(\"unable to get container cgroup stats: %w\", err)\n\t}\n\tif c.intelRdtManager != nil {\n\t\tif stats.IntelRdtStats, err = c.intelRdtManager.GetStats(); err != nil {\n\t\t\treturn stats, fmt.Errorf(\"unable to get container Intel RDT stats: %w\", err)\n\t\t}\n\t}\n\tfor _, iface := range c.config.Networks {\n\t\tswitch iface.Type {\n\t\tcase \"veth\":\n\t\t\tistats, err := getNetworkInterfaceStats(iface.HostInterfaceName)\n\t\t\tif err != nil {\n\t\t\t\treturn stats, fmt.Errorf(\"unable to get network stats for interface %q: %w\", iface.HostInterfaceName, err)\n\t\t\t}\n\t\t\tstats.Interfaces = append(stats.Interfaces, istats)\n\t\t}\n\t}\n\treturn stats, nil\n}\n\nfunc (c *linuxContainer) Set(config configs.Config) error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\tstatus, err := c.currentStatus()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif status == Stopped {\n\t\treturn ErrNotRunning\n\t}\n\tif err := c.cgroupManager.Set(config.Cgroups.Resources); err != nil {\n\t\t// Set configs back\n\t\tif err2 := c.cgroupManager.Set(c.config.Cgroups.Resources); err2 != nil {\n\t\t\tlogrus.Warnf(\"Setting back cgroup configs failed due to error: %v, your state.json and actual configs might be inconsistent.\", err2)\n\t\t}\n\t\treturn err\n\t}\n\tif c.intelRdtManager != nil {\n\t\tif err := c.intelRdtManager.Set(&config); err != nil {\n\t\t\t// Set configs back\n\t\t\tif err2 := c.cgroupManager.Set(c.config.Cgroups.Resources); err2 != nil {\n\t\t\t\tlogrus.Warnf(\"Setting back cgroup configs failed due to error: %v, your state.json and actual configs might be inconsistent.\", err2)\n\t\t\t}\n\t\t\tif err2 := c.intelRdtManager.Set(c.config); err2 != nil {\n\t\t\t\tlogrus.Warnf(\"Setting back intelrdt configs failed due to error: %v, your state.json and actual configs might be inconsistent.\", err2)\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\t// After config setting succeed, update config and states\n\tc.config = &config\n\t_, err = c.updateState(nil)\n\treturn err\n}\n\nfunc (c *linuxContainer) Start(process *Process) error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\tif c.config.Cgroups.Resources.SkipDevices {\n\t\treturn errors.New(\"can't start container with SkipDevices set\")\n\t}\n\tif process.Init {\n\t\tif err := c.createExecFifo(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := c.start(process); err != nil {\n\t\tif process.Init {\n\t\t\tc.deleteExecFifo()\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (c *linuxContainer) Run(process *Process) error {\n\tif err := c.Start(process); err != nil {\n\t\treturn err\n\t}\n\tif process.Init {\n\t\treturn c.exec()\n\t}\n\treturn nil\n}\n\nfunc (c *linuxContainer) Exec() error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\treturn c.exec()\n}\n\nfunc (c *linuxContainer) exec() error {\n\tpath := filepath.Join(c.root, execFifoFilename)\n\tpid := c.initProcess.pid()\n\tblockingFifoOpenCh := awaitFifoOpen(path)\n\tfor {\n\t\tselect {\n\t\tcase result := <-blockingFifoOpenCh:\n\t\t\treturn handleFifoResult(result)\n\n\t\tcase <-time.After(time.Millisecond * 100):\n\t\t\tstat, err := system.Stat(pid)\n\t\t\tif err != nil || stat.State == system.Zombie {\n\t\t\t\t// could be because process started, ran, and completed between our 100ms timeout and our system.Stat() check.\n\t\t\t\t// see if the fifo exists and has data (with a non-blocking open, which will succeed if the writing process is complete).\n\t\t\t\tif err := handleFifoResult(fifoOpen(path, false)); err != nil {\n\t\t\t\t\treturn errors.New(\"container process is already dead\")\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc readFromExecFifo(execFifo io.Reader) error {\n\tdata, err := ioutil.ReadAll(execFifo)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(data) <= 0 {\n\t\treturn errors.New(\"cannot start an already running container\")\n\t}\n\treturn nil\n}\n\nfunc awaitFifoOpen(path string) <-chan openResult {\n\tfifoOpened := make(chan openResult)\n\tgo func() {\n\t\tresult := fifoOpen(path, true)\n\t\tfifoOpened <- result\n\t}()\n\treturn fifoOpened\n}\n\nfunc fifoOpen(path string, block bool) openResult {\n\tflags := os.O_RDONLY\n\tif !block {\n\t\tflags |= unix.O_NONBLOCK\n\t}\n\tf, err := os.OpenFile(path, flags, 0)\n\tif err != nil {\n\t\treturn openResult{err: fmt.Errorf(\"exec fifo: %w\", err)}\n\t}\n\treturn openResult{file: f}\n}\n\nfunc handleFifoResult(result openResult) error {\n\tif result.err != nil {\n\t\treturn result.err\n\t}\n\tf := result.file\n\tdefer f.Close()\n\tif err := readFromExecFifo(f); err != nil {\n\t\treturn err\n\t}\n\treturn os.Remove(f.Name())\n}\n\ntype openResult struct {\n\tfile *os.File\n\terr  error\n}\n\nfunc (c *linuxContainer) start(process *Process) (retErr error) {\n\tparent, err := c.newParentProcess(process)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to create new parent process: %w\", err)\n\t}\n\n\tlogsDone := parent.forwardChildLogs()\n\tif logsDone != nil {\n\t\tdefer func() {\n\t\t\t// Wait for log forwarder to finish. This depends on\n\t\t\t// runc init closing the _LIBCONTAINER_LOGPIPE log fd.\n\t\t\terr := <-logsDone\n\t\t\tif err != nil && retErr == nil {\n\t\t\t\tretErr = fmt.Errorf(\"unable to forward init logs: %w\", err)\n\t\t\t}\n\t\t}()\n\t}\n\n\tif err := parent.start(); err != nil {\n\t\treturn fmt.Errorf(\"unable to start container process: %w\", err)\n\t}\n\n\tif process.Init {\n\t\tc.fifo.Close()\n\t\tif c.config.Hooks != nil {\n\t\t\ts, err := c.currentOCIState()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif err := c.config.Hooks[configs.Poststart].RunHooks(s); err != nil {\n\t\t\t\tif err := ignoreTerminateErrors(parent.terminate()); err != nil {\n\t\t\t\t\tlogrus.Warn(fmt.Errorf(\"error running poststart hook: %w\", err))\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (c *linuxContainer) Signal(s os.Signal, all bool) error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\tstatus, err := c.currentStatus()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif all {\n\t\t// for systemd cgroup, the unit's cgroup path will be auto removed if container's all processes exited\n\t\tif status == Stopped && !c.cgroupManager.Exists() {\n\t\t\treturn nil\n\t\t}\n\t\treturn signalAllProcesses(c.cgroupManager, s)\n\t}\n\t// to avoid a PID reuse attack\n\tif status == Running || status == Created || status == Paused {\n\t\tif err := c.initProcess.signal(s); err != nil {\n\t\t\treturn fmt.Errorf(\"unable to signal init: %w\", err)\n\t\t}\n\t\tif status == Paused {\n\t\t\t// For cgroup v1, killing a process in a frozen cgroup\n\t\t\t// does nothing until it's thawed. Only thaw the cgroup\n\t\t\t// for SIGKILL.\n\t\t\tif s, ok := s.(unix.Signal); ok && s == unix.SIGKILL {\n\t\t\t\t_ = c.cgroupManager.Freeze(configs.Thawed)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\treturn ErrNotRunning\n}\n\nfunc (c *linuxContainer) createExecFifo() error {\n\trootuid, err := c.Config().HostRootUID()\n\tif err != nil {\n\t\treturn err\n\t}\n\trootgid, err := c.Config().HostRootGID()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfifoName := filepath.Join(c.root, execFifoFilename)\n\tif _, err := os.Stat(fifoName); err == nil {\n\t\treturn fmt.Errorf(\"exec fifo %s already exists\", fifoName)\n\t}\n\toldMask := unix.Umask(0o000)\n\tif err := unix.Mkfifo(fifoName, 0o622); err != nil {\n\t\tunix.Umask(oldMask)\n\t\treturn err\n\t}\n\tunix.Umask(oldMask)\n\treturn os.Chown(fifoName, rootuid, rootgid)\n}\n\nfunc (c *linuxContainer) deleteExecFifo() {\n\tfifoName := filepath.Join(c.root, execFifoFilename)\n\tos.Remove(fifoName)\n}\n\n// includeExecFifo opens the container's execfifo as a pathfd, so that the\n// container cannot access the statedir (and the FIFO itself remains\n// un-opened). It then adds the FifoFd to the given exec.Cmd as an inherited\n// fd, with _LIBCONTAINER_FIFOFD set to its fd number.\nfunc (c *linuxContainer) includeExecFifo(cmd *exec.Cmd) error {\n\tfifoName := filepath.Join(c.root, execFifoFilename)\n\tfifo, err := os.OpenFile(fifoName, unix.O_PATH|unix.O_CLOEXEC, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.fifo = fifo\n\n\tcmd.ExtraFiles = append(cmd.ExtraFiles, fifo)\n\tcmd.Env = append(cmd.Env,\n\t\t\"_LIBCONTAINER_FIFOFD=\"+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1))\n\treturn nil\n}\n\nfunc (c *linuxContainer) newParentProcess(p *Process) (parentProcess, error) {\n\tparentInitPipe, childInitPipe, err := utils.NewSockPair(\"init\")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to create init pipe: %w\", err)\n\t}\n\tmessageSockPair := filePair{parentInitPipe, childInitPipe}\n\n\tparentLogPipe, childLogPipe, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to create log pipe: %w\", err)\n\t}\n\tlogFilePair := filePair{parentLogPipe, childLogPipe}\n\n\tcmd := c.commandTemplate(p, childInitPipe, childLogPipe)\n\tif !p.Init {\n\t\treturn c.newSetnsProcess(p, cmd, messageSockPair, logFilePair)\n\t}\n\n\t// We only set up fifoFd if we're not doing a `runc exec`. The historic\n\t// reason for this is that previously we would pass a dirfd that allowed\n\t// for container rootfs escape (and not doing it in `runc exec` avoided\n\t// that problem), but we no longer do that. However, there's no need to do\n\t// this for `runc exec` so we just keep it this way to be safe.\n\tif err := c.includeExecFifo(cmd); err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to setup exec fifo: %w\", err)\n\t}\n\treturn c.newInitProcess(p, cmd, messageSockPair, logFilePair)\n}\n\nfunc (c *linuxContainer) commandTemplate(p *Process, childInitPipe *os.File, childLogPipe *os.File) *exec.Cmd {\n\tcmd := exec.Command(c.initPath, c.initArgs[1:]...)\n\tcmd.Args[0] = c.initArgs[0]\n\tcmd.Stdin = p.Stdin\n\tcmd.Stdout = p.Stdout\n\tcmd.Stderr = p.Stderr\n\tcmd.Dir = c.config.Rootfs\n\tif cmd.SysProcAttr == nil {\n\t\tcmd.SysProcAttr = &unix.SysProcAttr{}\n\t}\n\tcmd.Env = append(cmd.Env, \"GOMAXPROCS=\"+os.Getenv(\"GOMAXPROCS\"))\n\tcmd.ExtraFiles = append(cmd.ExtraFiles, p.ExtraFiles...)\n\tif p.ConsoleSocket != nil {\n\t\tcmd.ExtraFiles = append(cmd.ExtraFiles, p.ConsoleSocket)\n\t\tcmd.Env = append(cmd.Env,\n\t\t\t\"_LIBCONTAINER_CONSOLE=\"+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1),\n\t\t)\n\t}\n\tcmd.ExtraFiles = append(cmd.ExtraFiles, childInitPipe)\n\tcmd.Env = append(cmd.Env,\n\t\t\"_LIBCONTAINER_INITPIPE=\"+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1),\n\t\t\"_LIBCONTAINER_STATEDIR=\"+c.root,\n\t)\n\n\tcmd.ExtraFiles = append(cmd.ExtraFiles, childLogPipe)\n\tcmd.Env = append(cmd.Env,\n\t\t\"_LIBCONTAINER_LOGPIPE=\"+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1),\n\t\t\"_LIBCONTAINER_LOGLEVEL=\"+p.LogLevel,\n\t)\n\n\t// NOTE: when running a container with no PID namespace and the parent process spawning the container is\n\t// PID1 the pdeathsig is being delivered to the container's init process by the kernel for some reason\n\t// even with the parent still running.\n\tif c.config.ParentDeathSignal > 0 {\n\t\tcmd.SysProcAttr.Pdeathsig = unix.Signal(c.config.ParentDeathSignal)\n\t}\n\treturn cmd\n}\n\nfunc (c *linuxContainer) newInitProcess(p *Process, cmd *exec.Cmd, messageSockPair, logFilePair filePair) (*initProcess, error) {\n\tcmd.Env = append(cmd.Env, \"_LIBCONTAINER_INITTYPE=\"+string(initStandard))\n\tnsMaps := make(map[configs.NamespaceType]string)\n\tfor _, ns := range c.config.Namespaces {\n\t\tif ns.Path != \"\" {\n\t\t\tnsMaps[ns.Type] = ns.Path\n\t\t}\n\t}\n\t_, sharePidns := nsMaps[configs.NEWPID]\n\tdata, err := c.bootstrapData(c.config.Namespaces.CloneFlags(), nsMaps)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tinit := &initProcess{\n\t\tcmd:             cmd,\n\t\tmessageSockPair: messageSockPair,\n\t\tlogFilePair:     logFilePair,\n\t\tmanager:         c.cgroupManager,\n\t\tintelRdtManager: c.intelRdtManager,\n\t\tconfig:          c.newInitConfig(p),\n\t\tcontainer:       c,\n\t\tprocess:         p,\n\t\tbootstrapData:   data,\n\t\tsharePidns:      sharePidns,\n\t}\n\tc.initProcess = init\n\treturn init, nil\n}\n\nfunc (c *linuxContainer) newSetnsProcess(p *Process, cmd *exec.Cmd, messageSockPair, logFilePair filePair) (*setnsProcess, error) {\n\tcmd.Env = append(cmd.Env, \"_LIBCONTAINER_INITTYPE=\"+string(initSetns))\n\tstate, err := c.currentState()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to get container state: %w\", err)\n\t}\n\t// for setns process, we don't have to set cloneflags as the process namespaces\n\t// will only be set via setns syscall\n\tdata, err := c.bootstrapData(0, state.NamespacePaths)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tproc := &setnsProcess{\n\t\tcmd:             cmd,\n\t\tcgroupPaths:     state.CgroupPaths,\n\t\trootlessCgroups: c.config.RootlessCgroups,\n\t\tintelRdtPath:    state.IntelRdtPath,\n\t\tmessageSockPair: messageSockPair,\n\t\tlogFilePair:     logFilePair,\n\t\tmanager:         c.cgroupManager,\n\t\tconfig:          c.newInitConfig(p),\n\t\tprocess:         p,\n\t\tbootstrapData:   data,\n\t\tinitProcessPid:  state.InitProcessPid,\n\t}\n\tif len(p.SubCgroupPaths) > 0 {\n\t\tif add, ok := p.SubCgroupPaths[\"\"]; ok {\n\t\t\t// cgroup v1: using the same path for all controllers.\n\t\t\t// cgroup v2: the only possible way.\n\t\t\tfor k := range proc.cgroupPaths {\n\t\t\t\tproc.cgroupPaths[k] = path.Join(proc.cgroupPaths[k], add)\n\t\t\t}\n\t\t\t// cgroup v2: do not try to join init process's cgroup\n\t\t\t// as a fallback (see (*setnsProcess).start).\n\t\t\tproc.initProcessPid = 0\n\t\t} else {\n\t\t\t// Per-controller paths.\n\t\t\tfor ctrl, add := range p.SubCgroupPaths {\n\t\t\t\tif val, ok := proc.cgroupPaths[ctrl]; ok {\n\t\t\t\t\tproc.cgroupPaths[ctrl] = path.Join(val, add)\n\t\t\t\t} else {\n\t\t\t\t\treturn nil, fmt.Errorf(\"unknown controller %s in SubCgroupPaths\", ctrl)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn proc, nil\n}\n\nfunc (c *linuxContainer) newInitConfig(process *Process) *initConfig {\n\tcfg := &initConfig{\n\t\tConfig:           c.config,\n\t\tArgs:             process.Args,\n\t\tEnv:              process.Env,\n\t\tUser:             process.User,\n\t\tAdditionalGroups: process.AdditionalGroups,\n\t\tCwd:              process.Cwd,\n\t\tCapabilities:     process.Capabilities,\n\t\tPassedFilesCount: len(process.ExtraFiles),\n\t\tContainerId:      c.ID(),\n\t\tNoNewPrivileges:  c.config.NoNewPrivileges,\n\t\tRootlessEUID:     c.config.RootlessEUID,\n\t\tRootlessCgroups:  c.config.RootlessCgroups,\n\t\tAppArmorProfile:  c.config.AppArmorProfile,\n\t\tProcessLabel:     c.config.ProcessLabel,\n\t\tRlimits:          c.config.Rlimits,\n\t\tCreateConsole:    process.ConsoleSocket != nil,\n\t\tConsoleWidth:     process.ConsoleWidth,\n\t\tConsoleHeight:    process.ConsoleHeight,\n\t}\n\tif process.NoNewPrivileges != nil {\n\t\tcfg.NoNewPrivileges = *process.NoNewPrivileges\n\t}\n\tif process.AppArmorProfile != \"\" {\n\t\tcfg.AppArmorProfile = process.AppArmorProfile\n\t}\n\tif process.Label != \"\" {\n\t\tcfg.ProcessLabel = process.Label\n\t}\n\tif len(process.Rlimits) > 0 {\n\t\tcfg.Rlimits = process.Rlimits\n\t}\n\tif cgroups.IsCgroup2UnifiedMode() {\n\t\tcfg.Cgroup2Path = c.cgroupManager.Path(\"\")\n\t}\n\n\treturn cfg\n}\n\nfunc (c *linuxContainer) Destroy() error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\treturn c.state.destroy()\n}\n\nfunc (c *linuxContainer) Pause() error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\tstatus, err := c.currentStatus()\n\tif err != nil {\n\t\treturn err\n\t}\n\tswitch status {\n\tcase Running, Created:\n\t\tif err := c.cgroupManager.Freeze(configs.Frozen); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn c.state.transition(&pausedState{\n\t\t\tc: c,\n\t\t})\n\t}\n\treturn ErrNotRunning\n}\n\nfunc (c *linuxContainer) Resume() error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\tstatus, err := c.currentStatus()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif status != Paused {\n\t\treturn ErrNotPaused\n\t}\n\tif err := c.cgroupManager.Freeze(configs.Thawed); err != nil {\n\t\treturn err\n\t}\n\treturn c.state.transition(&runningState{\n\t\tc: c,\n\t})\n}\n\nfunc (c *linuxContainer) NotifyOOM() (<-chan struct{}, error) {\n\t// XXX(cyphar): This requires cgroups.\n\tif c.config.RootlessCgroups {\n\t\tlogrus.Warn(\"getting OOM notifications may fail if you don't have the full access to cgroups\")\n\t}\n\tpath := c.cgroupManager.Path(\"memory\")\n\tif cgroups.IsCgroup2UnifiedMode() {\n\t\treturn notifyOnOOMV2(path)\n\t}\n\treturn notifyOnOOM(path)\n}\n\nfunc (c *linuxContainer) NotifyMemoryPressure(level PressureLevel) (<-chan struct{}, error) {\n\t// XXX(cyphar): This requires cgroups.\n\tif c.config.RootlessCgroups {\n\t\tlogrus.Warn(\"getting memory pressure notifications may fail if you don't have the full access to cgroups\")\n\t}\n\treturn notifyMemoryPressure(c.cgroupManager.Path(\"memory\"), level)\n}\n\nvar criuFeatures *criurpc.CriuFeatures\n\nfunc (c *linuxContainer) checkCriuFeatures(criuOpts *CriuOpts, rpcOpts *criurpc.CriuOpts, criuFeat *criurpc.CriuFeatures) error {\n\tt := criurpc.CriuReqType_FEATURE_CHECK\n\n\t// make sure the features we are looking for are really not from\n\t// some previous check\n\tcriuFeatures = nil\n\n\treq := &criurpc.CriuReq{\n\t\tType: &t,\n\t\t// Theoretically this should not be necessary but CRIU\n\t\t// segfaults if Opts is empty.\n\t\t// Fixed in CRIU  2.12\n\t\tOpts:     rpcOpts,\n\t\tFeatures: criuFeat,\n\t}\n\n\terr := c.criuSwrk(nil, req, criuOpts, nil)\n\tif err != nil {\n\t\tlogrus.Debugf(\"%s\", err)\n\t\treturn errors.New(\"CRIU feature check failed\")\n\t}\n\n\tmissingFeatures := false\n\n\t// The outer if checks if the fields actually exist\n\tif (criuFeat.MemTrack != nil) &&\n\t\t(criuFeatures.MemTrack != nil) {\n\t\t// The inner if checks if they are set to true\n\t\tif *criuFeat.MemTrack && !*criuFeatures.MemTrack {\n\t\t\tmissingFeatures = true\n\t\t\tlogrus.Debugf(\"CRIU does not support MemTrack\")\n\t\t}\n\t}\n\n\t// This needs to be repeated for every new feature check.\n\t// Is there a way to put this in a function. Reflection?\n\tif (criuFeat.LazyPages != nil) &&\n\t\t(criuFeatures.LazyPages != nil) {\n\t\tif *criuFeat.LazyPages && !*criuFeatures.LazyPages {\n\t\t\tmissingFeatures = true\n\t\t\tlogrus.Debugf(\"CRIU does not support LazyPages\")\n\t\t}\n\t}\n\n\tif missingFeatures {\n\t\treturn errors.New(\"CRIU is missing features\")\n\t}\n\n\treturn nil\n}\n\nfunc compareCriuVersion(criuVersion int, minVersion int) error {\n\t// simple function to perform the actual version compare\n\tif criuVersion < minVersion {\n\t\treturn fmt.Errorf(\"CRIU version %d must be %d or higher\", criuVersion, minVersion)\n\t}\n\n\treturn nil\n}\n\n// checkCriuVersion checks Criu version greater than or equal to minVersion\nfunc (c *linuxContainer) checkCriuVersion(minVersion int) error {\n\t// If the version of criu has already been determined there is no need\n\t// to ask criu for the version again. Use the value from c.criuVersion.\n\tif c.criuVersion != 0 {\n\t\treturn compareCriuVersion(c.criuVersion, minVersion)\n\t}\n\n\tcriu := criu.MakeCriu()\n\tcriu.SetCriuPath(c.criuPath)\n\tvar err error\n\tc.criuVersion, err = criu.GetCriuVersion()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"CRIU version check failed: %w\", err)\n\t}\n\n\treturn compareCriuVersion(c.criuVersion, minVersion)\n}\n\nconst descriptorsFilename = \"descriptors.json\"\n\nfunc (c *linuxContainer) addCriuDumpMount(req *criurpc.CriuReq, m *configs.Mount) {\n\tmountDest := strings.TrimPrefix(m.Destination, c.config.Rootfs)\n\tif dest, err := securejoin.SecureJoin(c.config.Rootfs, mountDest); err == nil {\n\t\tmountDest = dest[len(c.config.Rootfs):]\n\t}\n\textMnt := &criurpc.ExtMountMap{\n\t\tKey: proto.String(mountDest),\n\t\tVal: proto.String(mountDest),\n\t}\n\treq.Opts.ExtMnt = append(req.Opts.ExtMnt, extMnt)\n}\n\nfunc (c *linuxContainer) addMaskPaths(req *criurpc.CriuReq) error {\n\tfor _, path := range c.config.MaskPaths {\n\t\tfi, err := os.Stat(fmt.Sprintf(\"/proc/%d/root/%s\", c.initProcess.pid(), path))\n\t\tif err != nil {\n\t\t\tif os.IsNotExist(err) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tif fi.IsDir() {\n\t\t\tcontinue\n\t\t}\n\n\t\textMnt := &criurpc.ExtMountMap{\n\t\t\tKey: proto.String(path),\n\t\t\tVal: proto.String(\"/dev/null\"),\n\t\t}\n\t\treq.Opts.ExtMnt = append(req.Opts.ExtMnt, extMnt)\n\t}\n\treturn nil\n}\n\nfunc (c *linuxContainer) handleCriuConfigurationFile(rpcOpts *criurpc.CriuOpts) {\n\t// CRIU will evaluate a configuration starting with release 3.11.\n\t// Settings in the configuration file will overwrite RPC settings.\n\t// Look for annotations. The annotation 'org.criu.config'\n\t// specifies if CRIU should use a different, container specific\n\t// configuration file.\n\t_, annotations := utils.Annotations(c.config.Labels)\n\tconfigFile, exists := annotations[\"org.criu.config\"]\n\tif exists {\n\t\t// If the annotation 'org.criu.config' exists and is set\n\t\t// to a non-empty string, tell CRIU to use that as a\n\t\t// configuration file. If the file does not exist, CRIU\n\t\t// will just ignore it.\n\t\tif configFile != \"\" {\n\t\t\trpcOpts.ConfigFile = proto.String(configFile)\n\t\t}\n\t\t// If 'org.criu.config' exists and is set to an empty\n\t\t// string, a runc specific CRIU configuration file will\n\t\t// be not set at all.\n\t} else {\n\t\t// If the mentioned annotation has not been found, specify\n\t\t// a default CRIU configuration file.\n\t\trpcOpts.ConfigFile = proto.String(\"/etc/criu/runc.conf\")\n\t}\n}\n\nfunc (c *linuxContainer) criuSupportsExtNS(t configs.NamespaceType) bool {\n\tvar minVersion int\n\tswitch t {\n\tcase configs.NEWNET:\n\t\t// CRIU supports different external namespace with different released CRIU versions.\n\t\t// For network namespaces to work we need at least criu 3.11.0 => 31100.\n\t\tminVersion = 31100\n\tcase configs.NEWPID:\n\t\t// For PID namespaces criu 31500 is needed.\n\t\tminVersion = 31500\n\tdefault:\n\t\treturn false\n\t}\n\treturn c.checkCriuVersion(minVersion) == nil\n}\n\nfunc criuNsToKey(t configs.NamespaceType) string {\n\treturn \"extRoot\" + strings.Title(configs.NsName(t)) + \"NS\"\n}\n\nfunc (c *linuxContainer) handleCheckpointingExternalNamespaces(rpcOpts *criurpc.CriuOpts, t configs.NamespaceType) error {\n\tif !c.criuSupportsExtNS(t) {\n\t\treturn nil\n\t}\n\n\tnsPath := c.config.Namespaces.PathOf(t)\n\tif nsPath == \"\" {\n\t\treturn nil\n\t}\n\t// CRIU expects the information about an external namespace\n\t// like this: --external <TYPE>[<inode>]:<key>\n\t// This <key> is always 'extRoot<TYPE>NS'.\n\tvar ns unix.Stat_t\n\tif err := unix.Stat(nsPath, &ns); err != nil {\n\t\treturn err\n\t}\n\tcriuExternal := fmt.Sprintf(\"%s[%d]:%s\", configs.NsName(t), ns.Ino, criuNsToKey(t))\n\trpcOpts.External = append(rpcOpts.External, criuExternal)\n\n\treturn nil\n}\n\nfunc (c *linuxContainer) handleRestoringNamespaces(rpcOpts *criurpc.CriuOpts, extraFiles *[]*os.File) error {\n\tfor _, ns := range c.config.Namespaces {\n\t\tswitch ns.Type {\n\t\tcase configs.NEWNET, configs.NEWPID:\n\t\t\t// If the container is running in a network or PID namespace and has\n\t\t\t// a path to the network or PID namespace configured, we will dump\n\t\t\t// that network or PID namespace as an external namespace and we\n\t\t\t// will expect that the namespace exists during restore.\n\t\t\t// This basically means that CRIU will ignore the namespace\n\t\t\t// and expect it to be setup correctly.\n\t\t\tif err := c.handleRestoringExternalNamespaces(rpcOpts, extraFiles, ns.Type); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tdefault:\n\t\t\t// For all other namespaces except NET and PID CRIU has\n\t\t\t// a simpler way of joining the existing namespace if set\n\t\t\tnsPath := c.config.Namespaces.PathOf(ns.Type)\n\t\t\tif nsPath == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif ns.Type == configs.NEWCGROUP {\n\t\t\t\t// CRIU has no code to handle NEWCGROUP\n\t\t\t\treturn fmt.Errorf(\"Do not know how to handle namespace %v\", ns.Type)\n\t\t\t}\n\t\t\t// CRIU has code to handle NEWTIME, but it does not seem to be defined in runc\n\n\t\t\t// CRIU will issue a warning for NEWUSER:\n\t\t\t// criu/namespaces.c: 'join-ns with user-namespace is not fully tested and dangerous'\n\t\t\trpcOpts.JoinNs = append(rpcOpts.JoinNs, &criurpc.JoinNamespace{\n\t\t\t\tNs:     proto.String(configs.NsName(ns.Type)),\n\t\t\t\tNsFile: proto.String(nsPath),\n\t\t\t})\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (c *linuxContainer) handleRestoringExternalNamespaces(rpcOpts *criurpc.CriuOpts, extraFiles *[]*os.File, t configs.NamespaceType) error {\n\tif !c.criuSupportsExtNS(t) {\n\t\treturn nil\n\t}\n\n\tnsPath := c.config.Namespaces.PathOf(t)\n\tif nsPath == \"\" {\n\t\treturn nil\n\t}\n\t// CRIU wants the information about an existing namespace\n\t// like this: --inherit-fd fd[<fd>]:<key>\n\t// The <key> needs to be the same as during checkpointing.\n\t// We are always using 'extRoot<TYPE>NS' as the key in this.\n\tnsFd, err := os.Open(nsPath)\n\tif err != nil {\n\t\tlogrus.Errorf(\"If a specific network namespace is defined it must exist: %s\", err)\n\t\treturn fmt.Errorf(\"Requested network namespace %v does not exist\", nsPath)\n\t}\n\tinheritFd := &criurpc.InheritFd{\n\t\tKey: proto.String(criuNsToKey(t)),\n\t\t// The offset of four is necessary because 0, 1, 2 and 3 are\n\t\t// already used by stdin, stdout, stderr, 'criu swrk' socket.\n\t\tFd: proto.Int32(int32(4 + len(*extraFiles))),\n\t}\n\trpcOpts.InheritFd = append(rpcOpts.InheritFd, inheritFd)\n\t// All open FDs need to be transferred to CRIU via extraFiles\n\t*extraFiles = append(*extraFiles, nsFd)\n\n\treturn nil\n}\n\nfunc (c *linuxContainer) Checkpoint(criuOpts *CriuOpts) error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\n\t// Checkpoint is unlikely to work if os.Geteuid() != 0 || system.RunningInUserNS().\n\t// (CLI prints a warning)\n\t// TODO(avagin): Figure out how to make this work nicely. CRIU 2.0 has\n\t//               support for doing unprivileged dumps, but the setup of\n\t//               rootless containers might make this complicated.\n\n\t// We are relying on the CRIU version RPC which was introduced with CRIU 3.0.0\n\tif err := c.checkCriuVersion(30000); err != nil {\n\t\treturn err\n\t}\n\n\tif criuOpts.ImagesDirectory == \"\" {\n\t\treturn errors.New(\"invalid directory to save checkpoint\")\n\t}\n\n\t// Since a container can be C/R'ed multiple times,\n\t// the checkpoint directory may already exist.\n\tif err := os.Mkdir(criuOpts.ImagesDirectory, 0o700); err != nil && !os.IsExist(err) {\n\t\treturn err\n\t}\n\n\timageDir, err := os.Open(criuOpts.ImagesDirectory)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer imageDir.Close()\n\n\trpcOpts := criurpc.CriuOpts{\n\t\tImagesDirFd:     proto.Int32(int32(imageDir.Fd())),\n\t\tLogLevel:        proto.Int32(4),\n\t\tLogFile:         proto.String(\"dump.log\"),\n\t\tRoot:            proto.String(c.config.Rootfs),\n\t\tManageCgroups:   proto.Bool(true),\n\t\tNotifyScripts:   proto.Bool(true),\n\t\tPid:             proto.Int32(int32(c.initProcess.pid())),\n\t\tShellJob:        proto.Bool(criuOpts.ShellJob),\n\t\tLeaveRunning:    proto.Bool(criuOpts.LeaveRunning),\n\t\tTcpEstablished:  proto.Bool(criuOpts.TcpEstablished),\n\t\tExtUnixSk:       proto.Bool(criuOpts.ExternalUnixConnections),\n\t\tFileLocks:       proto.Bool(criuOpts.FileLocks),\n\t\tEmptyNs:         proto.Uint32(criuOpts.EmptyNs),\n\t\tOrphanPtsMaster: proto.Bool(true),\n\t\tAutoDedup:       proto.Bool(criuOpts.AutoDedup),\n\t\tLazyPages:       proto.Bool(criuOpts.LazyPages),\n\t}\n\n\t// if criuOpts.WorkDirectory is not set, criu default is used.\n\tif criuOpts.WorkDirectory != \"\" {\n\t\tif err := os.Mkdir(criuOpts.WorkDirectory, 0o700); err != nil && !os.IsExist(err) {\n\t\t\treturn err\n\t\t}\n\t\tworkDir, err := os.Open(criuOpts.WorkDirectory)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer workDir.Close()\n\t\trpcOpts.WorkDirFd = proto.Int32(int32(workDir.Fd()))\n\t}\n\n\tc.handleCriuConfigurationFile(&rpcOpts)\n\n\t// If the container is running in a network namespace and has\n\t// a path to the network namespace configured, we will dump\n\t// that network namespace as an external namespace and we\n\t// will expect that the namespace exists during restore.\n\t// This basically means that CRIU will ignore the namespace\n\t// and expect to be setup correctly.\n\tif err := c.handleCheckpointingExternalNamespaces(&rpcOpts, configs.NEWNET); err != nil {\n\t\treturn err\n\t}\n\n\t// Same for possible external PID namespaces\n\tif err := c.handleCheckpointingExternalNamespaces(&rpcOpts, configs.NEWPID); err != nil {\n\t\treturn err\n\t}\n\n\t// CRIU can use cgroup freezer; when rpcOpts.FreezeCgroup\n\t// is not set, CRIU uses ptrace() to pause the processes.\n\t// Note cgroup v2 freezer is only supported since CRIU release 3.14.\n\tif !cgroups.IsCgroup2UnifiedMode() || c.checkCriuVersion(31400) == nil {\n\t\tif fcg := c.cgroupManager.Path(\"freezer\"); fcg != \"\" {\n\t\t\trpcOpts.FreezeCgroup = proto.String(fcg)\n\t\t}\n\t}\n\n\t// append optional criu opts, e.g., page-server and port\n\tif criuOpts.PageServer.Address != \"\" && criuOpts.PageServer.Port != 0 {\n\t\trpcOpts.Ps = &criurpc.CriuPageServerInfo{\n\t\t\tAddress: proto.String(criuOpts.PageServer.Address),\n\t\t\tPort:    proto.Int32(criuOpts.PageServer.Port),\n\t\t}\n\t}\n\n\t// pre-dump may need parentImage param to complete iterative migration\n\tif criuOpts.ParentImage != \"\" {\n\t\trpcOpts.ParentImg = proto.String(criuOpts.ParentImage)\n\t\trpcOpts.TrackMem = proto.Bool(true)\n\t}\n\n\t// append optional manage cgroups mode\n\tif criuOpts.ManageCgroupsMode != 0 {\n\t\tmode := criuOpts.ManageCgroupsMode\n\t\trpcOpts.ManageCgroupsMode = &mode\n\t}\n\n\tvar t criurpc.CriuReqType\n\tif criuOpts.PreDump {\n\t\tfeat := criurpc.CriuFeatures{\n\t\t\tMemTrack: proto.Bool(true),\n\t\t}\n\n\t\tif err := c.checkCriuFeatures(criuOpts, &rpcOpts, &feat); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tt = criurpc.CriuReqType_PRE_DUMP\n\t} else {\n\t\tt = criurpc.CriuReqType_DUMP\n\t}\n\n\tif criuOpts.LazyPages {\n\t\t// lazy migration requested; check if criu supports it\n\t\tfeat := criurpc.CriuFeatures{\n\t\t\tLazyPages: proto.Bool(true),\n\t\t}\n\t\tif err := c.checkCriuFeatures(criuOpts, &rpcOpts, &feat); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif fd := criuOpts.StatusFd; fd != -1 {\n\t\t\t// check that the FD is valid\n\t\t\tflags, err := unix.FcntlInt(uintptr(fd), unix.F_GETFL, 0)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"invalid --status-fd argument %d: %w\", fd, err)\n\t\t\t}\n\t\t\t// and writable\n\t\t\tif flags&unix.O_WRONLY == 0 {\n\t\t\t\treturn fmt.Errorf(\"invalid --status-fd argument %d: not writable\", fd)\n\t\t\t}\n\n\t\t\tif c.checkCriuVersion(31500) != nil {\n\t\t\t\t// For criu 3.15+, use notifications (see case \"status-ready\"\n\t\t\t\t// in criuNotifications). Otherwise, rely on criu status fd.\n\t\t\t\trpcOpts.StatusFd = proto.Int32(int32(fd))\n\t\t\t}\n\t\t}\n\t}\n\n\treq := &criurpc.CriuReq{\n\t\tType: &t,\n\t\tOpts: &rpcOpts,\n\t}\n\n\t// no need to dump all this in pre-dump\n\tif !criuOpts.PreDump {\n\t\thasCgroupns := c.config.Namespaces.Contains(configs.NEWCGROUP)\n\t\tfor _, m := range c.config.Mounts {\n\t\t\tswitch m.Device {\n\t\t\tcase \"bind\":\n\t\t\t\tc.addCriuDumpMount(req, m)\n\t\t\tcase \"cgroup\":\n\t\t\t\tif cgroups.IsCgroup2UnifiedMode() || hasCgroupns {\n\t\t\t\t\t// real mount(s)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\t// a set of \"external\" bind mounts\n\t\t\t\tbinds, err := getCgroupMounts(m)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tfor _, b := range binds {\n\t\t\t\t\tc.addCriuDumpMount(req, b)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif err := c.addMaskPaths(req); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfor _, node := range c.config.Devices {\n\t\t\tm := &configs.Mount{Destination: node.Path, Source: node.Path}\n\t\t\tc.addCriuDumpMount(req, m)\n\t\t}\n\n\t\t// Write the FD info to a file in the image directory\n\t\tfdsJSON, err := json.Marshal(c.initProcess.externalDescriptors())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = ioutil.WriteFile(filepath.Join(criuOpts.ImagesDirectory, descriptorsFilename), fdsJSON, 0o600)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\terr = c.criuSwrk(nil, req, criuOpts, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (c *linuxContainer) addCriuRestoreMount(req *criurpc.CriuReq, m *configs.Mount) {\n\tmountDest := strings.TrimPrefix(m.Destination, c.config.Rootfs)\n\tif dest, err := securejoin.SecureJoin(c.config.Rootfs, mountDest); err == nil {\n\t\tmountDest = dest[len(c.config.Rootfs):]\n\t}\n\textMnt := &criurpc.ExtMountMap{\n\t\tKey: proto.String(mountDest),\n\t\tVal: proto.String(m.Source),\n\t}\n\treq.Opts.ExtMnt = append(req.Opts.ExtMnt, extMnt)\n}\n\nfunc (c *linuxContainer) restoreNetwork(req *criurpc.CriuReq, criuOpts *CriuOpts) {\n\tfor _, iface := range c.config.Networks {\n\t\tswitch iface.Type {\n\t\tcase \"veth\":\n\t\t\tveth := new(criurpc.CriuVethPair)\n\t\t\tveth.IfOut = proto.String(iface.HostInterfaceName)\n\t\t\tveth.IfIn = proto.String(iface.Name)\n\t\t\treq.Opts.Veths = append(req.Opts.Veths, veth)\n\t\tcase \"loopback\":\n\t\t\t// Do nothing\n\t\t}\n\t}\n\tfor _, i := range criuOpts.VethPairs {\n\t\tveth := new(criurpc.CriuVethPair)\n\t\tveth.IfOut = proto.String(i.HostInterfaceName)\n\t\tveth.IfIn = proto.String(i.ContainerInterfaceName)\n\t\treq.Opts.Veths = append(req.Opts.Veths, veth)\n\t}\n}\n\n// makeCriuRestoreMountpoints makes the actual mountpoints for the\n// restore using CRIU. This function is inspired from the code in\n// rootfs_linux.go\nfunc (c *linuxContainer) makeCriuRestoreMountpoints(m *configs.Mount) error {\n\tswitch m.Device {\n\tcase \"cgroup\":\n\t\t// No mount point(s) need to be created:\n\t\t//\n\t\t// * for v1, mount points are saved by CRIU because\n\t\t//   /sys/fs/cgroup is a tmpfs mount\n\t\t//\n\t\t// * for v2, /sys/fs/cgroup is a real mount, but\n\t\t//   the mountpoint appears as soon as /sys is mounted\n\t\treturn nil\n\tcase \"bind\":\n\t\t// The prepareBindMount() function checks if source\n\t\t// exists. So it cannot be used for other filesystem types.\n\t\tif err := prepareBindMount(m, c.config.Rootfs); err != nil {\n\t\t\treturn err\n\t\t}\n\tdefault:\n\t\t// for all other filesystems just create the mountpoints\n\t\tdest, err := securejoin.SecureJoin(c.config.Rootfs, m.Destination)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := checkProcMount(c.config.Rootfs, dest, \"\"); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := os.MkdirAll(dest, 0o755); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// isPathInPrefixList is a small function for CRIU restore to make sure\n// mountpoints, which are on a tmpfs, are not created in the roofs\nfunc isPathInPrefixList(path string, prefix []string) bool {\n\tfor _, p := range prefix {\n\t\tif strings.HasPrefix(path, p+\"/\") {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// prepareCriuRestoreMounts tries to set up the rootfs of the\n// container to be restored in the same way runc does it for\n// initial container creation. Even for a read-only rootfs container\n// runc modifies the rootfs to add mountpoints which do not exist.\n// This function also creates missing mountpoints as long as they\n// are not on top of a tmpfs, as CRIU will restore tmpfs content anyway.\nfunc (c *linuxContainer) prepareCriuRestoreMounts(mounts []*configs.Mount) error {\n\t// First get a list of a all tmpfs mounts\n\ttmpfs := []string{}\n\tfor _, m := range mounts {\n\t\tswitch m.Device {\n\t\tcase \"tmpfs\":\n\t\t\ttmpfs = append(tmpfs, m.Destination)\n\t\t}\n\t}\n\t// Now go through all mounts and create the mountpoints\n\t// if the mountpoints are not on a tmpfs, as CRIU will\n\t// restore the complete tmpfs content from its checkpoint.\n\tumounts := []string{}\n\tdefer func() {\n\t\tfor _, u := range umounts {\n\t\t\t_ = utils.WithProcfd(c.config.Rootfs, u, func(procfd string) error {\n\t\t\t\tif e := unix.Unmount(procfd, unix.MNT_DETACH); e != nil {\n\t\t\t\t\tif e != unix.EINVAL { //nolint:errorlint // unix errors are bare\n\t\t\t\t\t\t// Ignore EINVAL as it means 'target is not a mount point.'\n\t\t\t\t\t\t// It probably has already been unmounted.\n\t\t\t\t\t\tlogrus.Warnf(\"Error during cleanup unmounting of %s (%s): %v\", procfd, u, e)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t})\n\t\t}\n\t}()\n\tfor _, m := range mounts {\n\t\tif !isPathInPrefixList(m.Destination, tmpfs) {\n\t\t\tif err := c.makeCriuRestoreMountpoints(m); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t// If the mount point is a bind mount, we need to mount\n\t\t\t// it now so that runc can create the necessary mount\n\t\t\t// points for mounts in bind mounts.\n\t\t\t// This also happens during initial container creation.\n\t\t\t// Without this CRIU restore will fail\n\t\t\t// See: https://github.com/opencontainers/runc/issues/2748\n\t\t\t// It is also not necessary to order the mount points\n\t\t\t// because during initial container creation mounts are\n\t\t\t// set up in the order they are configured.\n\t\t\tif m.Device == \"bind\" {\n\t\t\t\tif err := utils.WithProcfd(c.config.Rootfs, m.Destination, func(procfd string) error {\n\t\t\t\t\tif err := mount(m.Source, m.Destination, procfd, \"\", unix.MS_BIND|unix.MS_REC, \"\"); err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\treturn nil\n\t\t\t\t}); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tumounts = append(umounts, m.Destination)\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (c *linuxContainer) Restore(process *Process, criuOpts *CriuOpts) error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\n\tvar extraFiles []*os.File\n\n\t// Restore is unlikely to work if os.Geteuid() != 0 || system.RunningInUserNS().\n\t// (CLI prints a warning)\n\t// TODO(avagin): Figure out how to make this work nicely. CRIU doesn't have\n\t//               support for unprivileged restore at the moment.\n\n\t// We are relying on the CRIU version RPC which was introduced with CRIU 3.0.0\n\tif err := c.checkCriuVersion(30000); err != nil {\n\t\treturn err\n\t}\n\tif criuOpts.ImagesDirectory == \"\" {\n\t\treturn errors.New(\"invalid directory to restore checkpoint\")\n\t}\n\timageDir, err := os.Open(criuOpts.ImagesDirectory)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer imageDir.Close()\n\t// CRIU has a few requirements for a root directory:\n\t// * it must be a mount point\n\t// * its parent must not be overmounted\n\t// c.config.Rootfs is bind-mounted to a temporary directory\n\t// to satisfy these requirements.\n\troot := filepath.Join(c.root, \"criu-root\")\n\tif err := os.Mkdir(root, 0o755); err != nil {\n\t\treturn err\n\t}\n\tdefer os.Remove(root)\n\troot, err = filepath.EvalSymlinks(root)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = mount(c.config.Rootfs, root, \"\", \"\", unix.MS_BIND|unix.MS_REC, \"\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer unix.Unmount(root, unix.MNT_DETACH) //nolint: errcheck\n\tt := criurpc.CriuReqType_RESTORE\n\treq := &criurpc.CriuReq{\n\t\tType: &t,\n\t\tOpts: &criurpc.CriuOpts{\n\t\t\tImagesDirFd:     proto.Int32(int32(imageDir.Fd())),\n\t\t\tEvasiveDevices:  proto.Bool(true),\n\t\t\tLogLevel:        proto.Int32(4),\n\t\t\tLogFile:         proto.String(\"restore.log\"),\n\t\t\tRstSibling:      proto.Bool(true),\n\t\t\tRoot:            proto.String(root),\n\t\t\tManageCgroups:   proto.Bool(true),\n\t\t\tNotifyScripts:   proto.Bool(true),\n\t\t\tShellJob:        proto.Bool(criuOpts.ShellJob),\n\t\t\tExtUnixSk:       proto.Bool(criuOpts.ExternalUnixConnections),\n\t\t\tTcpEstablished:  proto.Bool(criuOpts.TcpEstablished),\n\t\t\tFileLocks:       proto.Bool(criuOpts.FileLocks),\n\t\t\tEmptyNs:         proto.Uint32(criuOpts.EmptyNs),\n\t\t\tOrphanPtsMaster: proto.Bool(true),\n\t\t\tAutoDedup:       proto.Bool(criuOpts.AutoDedup),\n\t\t\tLazyPages:       proto.Bool(criuOpts.LazyPages),\n\t\t},\n\t}\n\n\tif criuOpts.LsmProfile != \"\" {\n\t\t// CRIU older than 3.16 has a bug which breaks the possibility\n\t\t// to set a different LSM profile.\n\t\tif err := c.checkCriuVersion(31600); err != nil {\n\t\t\treturn errors.New(\"--lsm-profile requires at least CRIU 3.16\")\n\t\t}\n\t\treq.Opts.LsmProfile = proto.String(criuOpts.LsmProfile)\n\t}\n\tif criuOpts.LsmMountContext != \"\" {\n\t\tif err := c.checkCriuVersion(31600); err != nil {\n\t\t\treturn errors.New(\"--lsm-mount-context requires at least CRIU 3.16\")\n\t\t}\n\t\treq.Opts.LsmMountContext = proto.String(criuOpts.LsmMountContext)\n\t}\n\n\tif criuOpts.WorkDirectory != \"\" {\n\t\t// Since a container can be C/R'ed multiple times,\n\t\t// the work directory may already exist.\n\t\tif err := os.Mkdir(criuOpts.WorkDirectory, 0o700); err != nil && !os.IsExist(err) {\n\t\t\treturn err\n\t\t}\n\t\tworkDir, err := os.Open(criuOpts.WorkDirectory)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer workDir.Close()\n\t\treq.Opts.WorkDirFd = proto.Int32(int32(workDir.Fd()))\n\t}\n\tc.handleCriuConfigurationFile(req.Opts)\n\n\tif err := c.handleRestoringNamespaces(req.Opts, &extraFiles); err != nil {\n\t\treturn err\n\t}\n\n\t// This will modify the rootfs of the container in the same way runc\n\t// modifies the container during initial creation.\n\tif err := c.prepareCriuRestoreMounts(c.config.Mounts); err != nil {\n\t\treturn err\n\t}\n\n\thasCgroupns := c.config.Namespaces.Contains(configs.NEWCGROUP)\n\tfor _, m := range c.config.Mounts {\n\t\tswitch m.Device {\n\t\tcase \"bind\":\n\t\t\tc.addCriuRestoreMount(req, m)\n\t\tcase \"cgroup\":\n\t\t\tif cgroups.IsCgroup2UnifiedMode() || hasCgroupns {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// cgroup v1 is a set of bind mounts, unless cgroupns is used\n\t\t\tbinds, err := getCgroupMounts(m)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tfor _, b := range binds {\n\t\t\t\tc.addCriuRestoreMount(req, b)\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(c.config.MaskPaths) > 0 {\n\t\tm := &configs.Mount{Destination: \"/dev/null\", Source: \"/dev/null\"}\n\t\tc.addCriuRestoreMount(req, m)\n\t}\n\n\tfor _, node := range c.config.Devices {\n\t\tm := &configs.Mount{Destination: node.Path, Source: node.Path}\n\t\tc.addCriuRestoreMount(req, m)\n\t}\n\n\tif criuOpts.EmptyNs&unix.CLONE_NEWNET == 0 {\n\t\tc.restoreNetwork(req, criuOpts)\n\t}\n\n\t// append optional manage cgroups mode\n\tif criuOpts.ManageCgroupsMode != 0 {\n\t\tmode := criuOpts.ManageCgroupsMode\n\t\treq.Opts.ManageCgroupsMode = &mode\n\t}\n\n\tvar (\n\t\tfds    []string\n\t\tfdJSON []byte\n\t)\n\tif fdJSON, err = ioutil.ReadFile(filepath.Join(criuOpts.ImagesDirectory, descriptorsFilename)); err != nil {\n\t\treturn err\n\t}\n\n\tif err := json.Unmarshal(fdJSON, &fds); err != nil {\n\t\treturn err\n\t}\n\tfor i := range fds {\n\t\tif s := fds[i]; strings.Contains(s, \"pipe:\") {\n\t\t\tinheritFd := new(criurpc.InheritFd)\n\t\t\tinheritFd.Key = proto.String(s)\n\t\t\tinheritFd.Fd = proto.Int32(int32(i))\n\t\t\treq.Opts.InheritFd = append(req.Opts.InheritFd, inheritFd)\n\t\t}\n\t}\n\terr = c.criuSwrk(process, req, criuOpts, extraFiles)\n\n\t// Now that CRIU is done let's close all opened FDs CRIU needed.\n\tfor _, fd := range extraFiles {\n\t\tfd.Close()\n\t}\n\n\treturn err\n}\n\nfunc (c *linuxContainer) criuApplyCgroups(pid int, req *criurpc.CriuReq) error {\n\t// need to apply cgroups only on restore\n\tif req.GetType() != criurpc.CriuReqType_RESTORE {\n\t\treturn nil\n\t}\n\n\t// XXX: Do we need to deal with this case? AFAIK criu still requires root.\n\tif err := c.cgroupManager.Apply(pid); err != nil {\n\t\treturn err\n\t}\n\n\tif err := c.cgroupManager.Set(c.config.Cgroups.Resources); err != nil {\n\t\treturn err\n\t}\n\n\tif cgroups.IsCgroup2UnifiedMode() {\n\t\treturn nil\n\t}\n\t// the stuff below is cgroupv1-specific\n\n\tpath := fmt.Sprintf(\"/proc/%d/cgroup\", pid)\n\tcgroupsPaths, err := cgroups.ParseCgroupFile(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor c, p := range cgroupsPaths {\n\t\tcgroupRoot := &criurpc.CgroupRoot{\n\t\t\tCtrl: proto.String(c),\n\t\t\tPath: proto.String(p),\n\t\t}\n\t\treq.Opts.CgRoot = append(req.Opts.CgRoot, cgroupRoot)\n\t}\n\n\treturn nil\n}\n\nfunc (c *linuxContainer) criuSwrk(process *Process, req *criurpc.CriuReq, opts *CriuOpts, extraFiles []*os.File) error {\n\tfds, err := unix.Socketpair(unix.AF_LOCAL, unix.SOCK_SEQPACKET|unix.SOCK_CLOEXEC, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar logPath string\n\tif opts != nil {\n\t\tlogPath = filepath.Join(opts.WorkDirectory, req.GetOpts().GetLogFile())\n\t} else {\n\t\t// For the VERSION RPC 'opts' is set to 'nil' and therefore\n\t\t// opts.WorkDirectory does not exist. Set logPath to \"\".\n\t\tlogPath = \"\"\n\t}\n\tcriuClient := os.NewFile(uintptr(fds[0]), \"criu-transport-client\")\n\tcriuClientFileCon, err := net.FileConn(criuClient)\n\tcriuClient.Close()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcriuClientCon := criuClientFileCon.(*net.UnixConn)\n\tdefer criuClientCon.Close()\n\n\tcriuServer := os.NewFile(uintptr(fds[1]), \"criu-transport-server\")\n\tdefer criuServer.Close()\n\n\targs := []string{\"swrk\", \"3\"}\n\tif c.criuVersion != 0 {\n\t\t// If the CRIU Version is still '0' then this is probably\n\t\t// the initial CRIU run to detect the version. Skip it.\n\t\tlogrus.Debugf(\"Using CRIU %d at: %s\", c.criuVersion, c.criuPath)\n\t}\n\tcmd := exec.Command(c.criuPath, args...)\n\tif process != nil {\n\t\tcmd.Stdin = process.Stdin\n\t\tcmd.Stdout = process.Stdout\n\t\tcmd.Stderr = process.Stderr\n\t}\n\tcmd.ExtraFiles = append(cmd.ExtraFiles, criuServer)\n\tif extraFiles != nil {\n\t\tcmd.ExtraFiles = append(cmd.ExtraFiles, extraFiles...)\n\t}\n\n\tif err := cmd.Start(); err != nil {\n\t\treturn err\n\t}\n\t// we close criuServer so that even if CRIU crashes or unexpectedly exits, runc will not hang.\n\tcriuServer.Close()\n\t// cmd.Process will be replaced by a restored init.\n\tcriuProcess := cmd.Process\n\n\tvar criuProcessState *os.ProcessState\n\tdefer func() {\n\t\tif criuProcessState == nil {\n\t\t\tcriuClientCon.Close()\n\t\t\t_, err := criuProcess.Wait()\n\t\t\tif err != nil {\n\t\t\t\tlogrus.Warnf(\"wait on criuProcess returned %v\", err)\n\t\t\t}\n\t\t}\n\t}()\n\n\tif err := c.criuApplyCgroups(criuProcess.Pid, req); err != nil {\n\t\treturn err\n\t}\n\n\tvar extFds []string\n\tif process != nil {\n\t\textFds, err = getPipeFds(criuProcess.Pid)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tlogrus.Debugf(\"Using CRIU in %s mode\", req.GetType().String())\n\t// In the case of criurpc.CriuReqType_FEATURE_CHECK req.GetOpts()\n\t// should be empty. For older CRIU versions it still will be\n\t// available but empty. criurpc.CriuReqType_VERSION actually\n\t// has no req.GetOpts().\n\tif logrus.GetLevel() >= logrus.DebugLevel &&\n\t\t!(req.GetType() == criurpc.CriuReqType_FEATURE_CHECK ||\n\t\t\treq.GetType() == criurpc.CriuReqType_VERSION) {\n\n\t\tval := reflect.ValueOf(req.GetOpts())\n\t\tv := reflect.Indirect(val)\n\t\tfor i := 0; i < v.NumField(); i++ {\n\t\t\tst := v.Type()\n\t\t\tname := st.Field(i).Name\n\t\t\tif 'A' <= name[0] && name[0] <= 'Z' {\n\t\t\t\tvalue := val.MethodByName(\"Get\" + name).Call([]reflect.Value{})\n\t\t\t\tlogrus.Debugf(\"CRIU option %s with value %v\", name, value[0])\n\t\t\t}\n\t\t}\n\t}\n\tdata, err := proto.Marshal(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = criuClientCon.Write(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tbuf := make([]byte, 10*4096)\n\toob := make([]byte, 4096)\n\tfor {\n\t\tn, oobn, _, _, err := criuClientCon.ReadMsgUnix(buf, oob)\n\t\tif req.Opts != nil && req.Opts.StatusFd != nil {\n\t\t\t// Close status_fd as soon as we got something back from criu,\n\t\t\t// assuming it has consumed (reopened) it by this time.\n\t\t\t// Otherwise it will might be left open forever and whoever\n\t\t\t// is waiting on it will wait forever.\n\t\t\tfd := int(*req.Opts.StatusFd)\n\t\t\t_ = unix.Close(fd)\n\t\t\treq.Opts.StatusFd = nil\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif n == 0 {\n\t\t\treturn errors.New(\"unexpected EOF\")\n\t\t}\n\t\tif n == len(buf) {\n\t\t\treturn errors.New(\"buffer is too small\")\n\t\t}\n\n\t\tresp := new(criurpc.CriuResp)\n\t\terr = proto.Unmarshal(buf[:n], resp)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !resp.GetSuccess() {\n\t\t\ttypeString := req.GetType().String()\n\t\t\treturn fmt.Errorf(\"criu failed: type %s errno %d\\nlog file: %s\", typeString, resp.GetCrErrno(), logPath)\n\t\t}\n\n\t\tt := resp.GetType()\n\t\tswitch {\n\t\tcase t == criurpc.CriuReqType_FEATURE_CHECK:\n\t\t\tlogrus.Debugf(\"Feature check says: %s\", resp)\n\t\t\tcriuFeatures = resp.GetFeatures()\n\t\tcase t == criurpc.CriuReqType_NOTIFY:\n\t\t\tif err := c.criuNotifications(resp, process, cmd, opts, extFds, oob[:oobn]); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tt = criurpc.CriuReqType_NOTIFY\n\t\t\treq = &criurpc.CriuReq{\n\t\t\t\tType:          &t,\n\t\t\t\tNotifySuccess: proto.Bool(true),\n\t\t\t}\n\t\t\tdata, err = proto.Marshal(req)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t_, err = criuClientCon.Write(data)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcontinue\n\t\tcase t == criurpc.CriuReqType_RESTORE:\n\t\tcase t == criurpc.CriuReqType_DUMP:\n\t\tcase t == criurpc.CriuReqType_PRE_DUMP:\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"unable to parse the response %s\", resp.String())\n\t\t}\n\n\t\tbreak\n\t}\n\n\t_ = criuClientCon.CloseWrite()\n\t// cmd.Wait() waits cmd.goroutines which are used for proxying file descriptors.\n\t// Here we want to wait only the CRIU process.\n\tcriuProcessState, err = criuProcess.Wait()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// In pre-dump mode CRIU is in a loop and waits for\n\t// the final DUMP command.\n\t// The current runc pre-dump approach, however, is\n\t// start criu in PRE_DUMP once for a single pre-dump\n\t// and not the whole series of pre-dump, pre-dump, ...m, dump\n\t// If we got the message CriuReqType_PRE_DUMP it means\n\t// CRIU was successful and we need to forcefully stop CRIU\n\tif !criuProcessState.Success() && *req.Type != criurpc.CriuReqType_PRE_DUMP {\n\t\treturn fmt.Errorf(\"criu failed: %s\\nlog file: %s\", criuProcessState.String(), logPath)\n\t}\n\treturn nil\n}\n\n// block any external network activity\nfunc lockNetwork(config *configs.Config) error {\n\tfor _, config := range config.Networks {\n\t\tstrategy, err := getStrategy(config.Type)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := strategy.detach(config); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc unlockNetwork(config *configs.Config) error {\n\tfor _, config := range config.Networks {\n\t\tstrategy, err := getStrategy(config.Type)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = strategy.attach(config); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (c *linuxContainer) criuNotifications(resp *criurpc.CriuResp, process *Process, cmd *exec.Cmd, opts *CriuOpts, fds []string, oob []byte) error {\n\tnotify := resp.GetNotify()\n\tif notify == nil {\n\t\treturn fmt.Errorf(\"invalid response: %s\", resp.String())\n\t}\n\tscript := notify.GetScript()\n\tlogrus.Debugf(\"notify: %s\\n\", script)\n\tswitch script {\n\tcase \"post-dump\":\n\t\tf, err := os.Create(filepath.Join(c.root, \"checkpoint\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tf.Close()\n\tcase \"network-unlock\":\n\t\tif err := unlockNetwork(c.config); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase \"network-lock\":\n\t\tif err := lockNetwork(c.config); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase \"setup-namespaces\":\n\t\tif c.config.Hooks != nil {\n\t\t\ts, err := c.currentOCIState()\n\t\t\tif err != nil {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\ts.Pid = int(notify.GetPid())\n\n\t\t\tif err := c.config.Hooks[configs.Prestart].RunHooks(s); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := c.config.Hooks[configs.CreateRuntime].RunHooks(s); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\tcase \"post-restore\":\n\t\tpid := notify.GetPid()\n\n\t\tp, err := os.FindProcess(int(pid))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcmd.Process = p\n\n\t\tr, err := newRestoredProcess(cmd, fds)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tprocess.ops = r\n\t\tif err := c.state.transition(&restoredState{\n\t\t\timageDir: opts.ImagesDirectory,\n\t\t\tc:        c,\n\t\t}); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// create a timestamp indicating when the restored checkpoint was started\n\t\tc.created = time.Now().UTC()\n\t\tif _, err := c.updateState(r); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := os.Remove(filepath.Join(c.root, \"checkpoint\")); err != nil {\n\t\t\tif !os.IsNotExist(err) {\n\t\t\t\tlogrus.Error(err)\n\t\t\t}\n\t\t}\n\tcase \"orphan-pts-master\":\n\t\tscm, err := unix.ParseSocketControlMessage(oob)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfds, err := unix.ParseUnixRights(&scm[0])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tmaster := os.NewFile(uintptr(fds[0]), \"orphan-pts-master\")\n\t\tdefer master.Close()\n\n\t\t// While we can access console.master, using the API is a good idea.\n\t\tif err := utils.SendFd(process.ConsoleSocket, master.Name(), master.Fd()); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase \"status-ready\":\n\t\tif opts.StatusFd != -1 {\n\t\t\t// write \\0 to status fd to notify that lazy page server is ready\n\t\t\t_, err := unix.Write(opts.StatusFd, []byte{0})\n\t\t\tif err != nil {\n\t\t\t\tlogrus.Warnf(\"can't write \\\\0 to status fd: %v\", err)\n\t\t\t}\n\t\t\t_ = unix.Close(opts.StatusFd)\n\t\t\topts.StatusFd = -1\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (c *linuxContainer) updateState(process parentProcess) (*State, error) {\n\tif process != nil {\n\t\tc.initProcess = process\n\t}\n\tstate, err := c.currentState()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = c.saveState(state)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn state, nil\n}\n\nfunc (c *linuxContainer) saveState(s *State) (retErr error) {\n\ttmpFile, err := ioutil.TempFile(c.root, \"state-\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer func() {\n\t\tif retErr != nil {\n\t\t\ttmpFile.Close()\n\t\t\tos.Remove(tmpFile.Name())\n\t\t}\n\t}()\n\n\terr = utils.WriteJSON(tmpFile, s)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = tmpFile.Close()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tstateFilePath := filepath.Join(c.root, stateFilename)\n\treturn os.Rename(tmpFile.Name(), stateFilePath)\n}\n\nfunc (c *linuxContainer) currentStatus() (Status, error) {\n\tif err := c.refreshState(); err != nil {\n\t\treturn -1, err\n\t}\n\treturn c.state.status(), nil\n}\n\n// refreshState needs to be called to verify that the current state on the\n// container is what is true.  Because consumers of libcontainer can use it\n// out of process we need to verify the container's status based on runtime\n// information and not rely on our in process info.\nfunc (c *linuxContainer) refreshState() error {\n\tpaused, err := c.isPaused()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif paused {\n\t\treturn c.state.transition(&pausedState{c: c})\n\t}\n\tt := c.runType()\n\tswitch t {\n\tcase Created:\n\t\treturn c.state.transition(&createdState{c: c})\n\tcase Running:\n\t\treturn c.state.transition(&runningState{c: c})\n\t}\n\treturn c.state.transition(&stoppedState{c: c})\n}\n\nfunc (c *linuxContainer) runType() Status {\n\tif c.initProcess == nil {\n\t\treturn Stopped\n\t}\n\tpid := c.initProcess.pid()\n\tstat, err := system.Stat(pid)\n\tif err != nil {\n\t\treturn Stopped\n\t}\n\tif stat.StartTime != c.initProcessStartTime || stat.State == system.Zombie || stat.State == system.Dead {\n\t\treturn Stopped\n\t}\n\t// We'll create exec fifo and blocking on it after container is created,\n\t// and delete it after start container.\n\tif _, err := os.Stat(filepath.Join(c.root, execFifoFilename)); err == nil {\n\t\treturn Created\n\t}\n\treturn Running\n}\n\nfunc (c *linuxContainer) isPaused() (bool, error) {\n\tstate, err := c.cgroupManager.GetFreezerState()\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn state == configs.Frozen, nil\n}\n\nfunc (c *linuxContainer) currentState() (*State, error) {\n\tvar (\n\t\tstartTime           uint64\n\t\texternalDescriptors []string\n\t\tpid                 = -1\n\t)\n\tif c.initProcess != nil {\n\t\tpid = c.initProcess.pid()\n\t\tstartTime, _ = c.initProcess.startTime()\n\t\texternalDescriptors = c.initProcess.externalDescriptors()\n\t}\n\n\tintelRdtPath := \"\"\n\tif c.intelRdtManager != nil {\n\t\tintelRdtPath = c.intelRdtManager.GetPath()\n\t}\n\tstate := &State{\n\t\tBaseState: BaseState{\n\t\t\tID:                   c.ID(),\n\t\t\tConfig:               *c.config,\n\t\t\tInitProcessPid:       pid,\n\t\t\tInitProcessStartTime: startTime,\n\t\t\tCreated:              c.created,\n\t\t},\n\t\tRootless:            c.config.RootlessEUID && c.config.RootlessCgroups,\n\t\tCgroupPaths:         c.cgroupManager.GetPaths(),\n\t\tIntelRdtPath:        intelRdtPath,\n\t\tNamespacePaths:      make(map[configs.NamespaceType]string),\n\t\tExternalDescriptors: externalDescriptors,\n\t}\n\tif pid > 0 {\n\t\tfor _, ns := range c.config.Namespaces {\n\t\t\tstate.NamespacePaths[ns.Type] = ns.GetPath(pid)\n\t\t}\n\t\tfor _, nsType := range configs.NamespaceTypes() {\n\t\t\tif !configs.IsNamespaceSupported(nsType) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif _, ok := state.NamespacePaths[nsType]; !ok {\n\t\t\t\tns := configs.Namespace{Type: nsType}\n\t\t\t\tstate.NamespacePaths[ns.Type] = ns.GetPath(pid)\n\t\t\t}\n\t\t}\n\t}\n\treturn state, nil\n}\n\nfunc (c *linuxContainer) currentOCIState() (*specs.State, error) {\n\tbundle, annotations := utils.Annotations(c.config.Labels)\n\tstate := &specs.State{\n\t\tVersion:     specs.Version,\n\t\tID:          c.ID(),\n\t\tBundle:      bundle,\n\t\tAnnotations: annotations,\n\t}\n\tstatus, err := c.currentStatus()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tstate.Status = specs.ContainerState(status.String())\n\tif status != Stopped {\n\t\tif c.initProcess != nil {\n\t\t\tstate.Pid = c.initProcess.pid()\n\t\t}\n\t}\n\treturn state, nil\n}\n\n// orderNamespacePaths sorts namespace paths into a list of paths that we\n// can setns in order.\nfunc (c *linuxContainer) orderNamespacePaths(namespaces map[configs.NamespaceType]string) ([]string, error) {\n\tpaths := []string{}\n\tfor _, ns := range configs.NamespaceTypes() {\n\n\t\t// Remove namespaces that we don't need to join.\n\t\tif !c.config.Namespaces.Contains(ns) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif p, ok := namespaces[ns]; ok && p != \"\" {\n\t\t\t// check if the requested namespace is supported\n\t\t\tif !configs.IsNamespaceSupported(ns) {\n\t\t\t\treturn nil, fmt.Errorf(\"namespace %s is not supported\", ns)\n\t\t\t}\n\t\t\t// only set to join this namespace if it exists\n\t\t\tif _, err := os.Lstat(p); err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"namespace path: %w\", err)\n\t\t\t}\n\t\t\t// do not allow namespace path with comma as we use it to separate\n\t\t\t// the namespace paths\n\t\t\tif strings.ContainsRune(p, ',') {\n\t\t\t\treturn nil, fmt.Errorf(\"invalid namespace path %s\", p)\n\t\t\t}\n\t\t\tpaths = append(paths, fmt.Sprintf(\"%s:%s\", configs.NsName(ns), p))\n\t\t}\n\n\t}\n\n\treturn paths, nil\n}\n\nfunc encodeIDMapping(idMap []configs.IDMap) ([]byte, error) {\n\tdata := bytes.NewBuffer(nil)\n\tfor _, im := range idMap {\n\t\tline := fmt.Sprintf(\"%d %d %d\\n\", im.ContainerID, im.HostID, im.Size)\n\t\tif _, err := data.WriteString(line); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn data.Bytes(), nil\n}\n\n// bootstrapData encodes the necessary data in netlink binary format\n// as a io.Reader.\n// Consumer can write the data to a bootstrap program\n// such as one that uses nsenter package to bootstrap the container's\n// init process correctly, i.e. with correct namespaces, uid/gid\n// mapping etc.\nfunc (c *linuxContainer) bootstrapData(cloneFlags uintptr, nsMaps map[configs.NamespaceType]string) (io.Reader, error) {\n\t// create the netlink message\n\tr := nl.NewNetlinkRequest(int(InitMsg), 0)\n\n\t// write cloneFlags\n\tr.AddData(&Int32msg{\n\t\tType:  CloneFlagsAttr,\n\t\tValue: uint32(cloneFlags),\n\t})\n\n\t// write custom namespace paths\n\tif len(nsMaps) > 0 {\n\t\tnsPaths, err := c.orderNamespacePaths(nsMaps)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tr.AddData(&Bytemsg{\n\t\t\tType:  NsPathsAttr,\n\t\t\tValue: []byte(strings.Join(nsPaths, \",\")),\n\t\t})\n\t}\n\n\t// write namespace paths only when we are not joining an existing user ns\n\t_, joinExistingUser := nsMaps[configs.NEWUSER]\n\tif !joinExistingUser {\n\t\t// write uid mappings\n\t\tif len(c.config.UidMappings) > 0 {\n\t\t\tif c.config.RootlessEUID && c.newuidmapPath != \"\" {\n\t\t\t\tr.AddData(&Bytemsg{\n\t\t\t\t\tType:  UidmapPathAttr,\n\t\t\t\t\tValue: []byte(c.newuidmapPath),\n\t\t\t\t})\n\t\t\t}\n\t\t\tb, err := encodeIDMapping(c.config.UidMappings)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tr.AddData(&Bytemsg{\n\t\t\t\tType:  UidmapAttr,\n\t\t\t\tValue: b,\n\t\t\t})\n\t\t}\n\n\t\t// write gid mappings\n\t\tif len(c.config.GidMappings) > 0 {\n\t\t\tb, err := encodeIDMapping(c.config.GidMappings)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tr.AddData(&Bytemsg{\n\t\t\t\tType:  GidmapAttr,\n\t\t\t\tValue: b,\n\t\t\t})\n\t\t\tif c.config.RootlessEUID && c.newgidmapPath != \"\" {\n\t\t\t\tr.AddData(&Bytemsg{\n\t\t\t\t\tType:  GidmapPathAttr,\n\t\t\t\t\tValue: []byte(c.newgidmapPath),\n\t\t\t\t})\n\t\t\t}\n\t\t\tif requiresRootOrMappingTool(c.config) {\n\t\t\t\tr.AddData(&Boolmsg{\n\t\t\t\t\tType:  SetgroupAttr,\n\t\t\t\t\tValue: true,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\tif c.config.OomScoreAdj != nil {\n\t\t// write oom_score_adj\n\t\tr.AddData(&Bytemsg{\n\t\t\tType:  OomScoreAdjAttr,\n\t\t\tValue: []byte(strconv.Itoa(*c.config.OomScoreAdj)),\n\t\t})\n\t}\n\n\t// write rootless\n\tr.AddData(&Boolmsg{\n\t\tType:  RootlessEUIDAttr,\n\t\tValue: c.config.RootlessEUID,\n\t})\n\n\treturn bytes.NewReader(r.Serialize()), nil\n}\n\n// ignoreTerminateErrors returns nil if the given err matches an error known\n// to indicate that the terminate occurred successfully or err was nil, otherwise\n// err is returned unaltered.\nfunc ignoreTerminateErrors(err error) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\t// terminate() might return an error from either Kill or Wait.\n\t// The (*Cmd).Wait documentation says: \"If the command fails to run\n\t// or doesn't complete successfully, the error is of type *ExitError\".\n\t// Filter out such errors (like \"exit status 1\" or \"signal: killed\").\n\tvar exitErr *exec.ExitError\n\tif errors.As(err, &exitErr) {\n\t\treturn nil\n\t}\n\t// TODO: use errors.Is(err, os.ErrProcessDone) here and\n\t// remove \"process already finished\" string comparison below\n\t// once go 1.16 is minimally supported version.\n\n\ts := err.Error()\n\tif strings.Contains(s, \"process already finished\") ||\n\t\tstrings.Contains(s, \"Wait was already called\") {\n\t\treturn nil\n\t}\n\treturn err\n}\n\nfunc requiresRootOrMappingTool(c *configs.Config) bool {\n\tgidMap := []configs.IDMap{\n\t\t{ContainerID: 0, HostID: os.Getegid(), Size: 1},\n\t}\n\treturn !reflect.DeepEqual(c.GidMappings, gidMap)\n}\n", "package libcontainer\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"runtime/debug\"\n\t\"strconv\"\n\n\tsecurejoin \"github.com/cyphar/filepath-securejoin\"\n\t\"github.com/moby/sys/mountinfo\"\n\t\"golang.org/x/sys/unix\"\n\n\t\"github.com/opencontainers/runc/libcontainer/cgroups/manager\"\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/opencontainers/runc/libcontainer/configs/validate\"\n\t\"github.com/opencontainers/runc/libcontainer/intelrdt\"\n\t\"github.com/opencontainers/runc/libcontainer/utils\"\n\t\"github.com/sirupsen/logrus\"\n)\n\nconst (\n\tstateFilename    = \"state.json\"\n\texecFifoFilename = \"exec.fifo\"\n)\n\nvar idRegex = regexp.MustCompile(`^[\\w+-\\.]+$`)\n\n// InitArgs returns an options func to configure a LinuxFactory with the\n// provided init binary path and arguments.\nfunc InitArgs(args ...string) func(*LinuxFactory) error {\n\treturn func(l *LinuxFactory) (err error) {\n\t\tif len(args) > 0 {\n\t\t\t// Resolve relative paths to ensure that its available\n\t\t\t// after directory changes.\n\t\t\tif args[0], err = filepath.Abs(args[0]); err != nil {\n\t\t\t\t// The only error returned from filepath.Abs is\n\t\t\t\t// the one from os.Getwd, i.e. a system error.\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tl.InitArgs = args\n\t\treturn nil\n\t}\n}\n\n// IntelRdtfs is an options func to configure a LinuxFactory to return\n// containers that use the Intel RDT \"resource control\" filesystem to\n// create and manage Intel RDT resources (e.g., L3 cache, memory bandwidth).\nfunc IntelRdtFs(l *LinuxFactory) error {\n\tif !intelrdt.IsCATEnabled() && !intelrdt.IsMBAEnabled() {\n\t\tl.NewIntelRdtManager = nil\n\t} else {\n\t\tl.NewIntelRdtManager = func(config *configs.Config, id string, path string) intelrdt.Manager {\n\t\t\treturn intelrdt.NewManager(config, id, path)\n\t\t}\n\t}\n\treturn nil\n}\n\n// TmpfsRoot is an option func to mount LinuxFactory.Root to tmpfs.\nfunc TmpfsRoot(l *LinuxFactory) error {\n\tmounted, err := mountinfo.Mounted(l.Root)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !mounted {\n\t\tif err := mount(\"tmpfs\", l.Root, \"\", \"tmpfs\", 0, \"\"); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// CriuPath returns an option func to configure a LinuxFactory with the\n// provided criupath\nfunc CriuPath(criupath string) func(*LinuxFactory) error {\n\treturn func(l *LinuxFactory) error {\n\t\tl.CriuPath = criupath\n\t\treturn nil\n\t}\n}\n\n// New returns a linux based container factory based in the root directory and\n// configures the factory with the provided option funcs.\nfunc New(root string, options ...func(*LinuxFactory) error) (Factory, error) {\n\tif root != \"\" {\n\t\tif err := os.MkdirAll(root, 0o700); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tl := &LinuxFactory{\n\t\tRoot:      root,\n\t\tInitPath:  \"/proc/self/exe\",\n\t\tInitArgs:  []string{os.Args[0], \"init\"},\n\t\tValidator: validate.New(),\n\t\tCriuPath:  \"criu\",\n\t}\n\n\tfor _, opt := range options {\n\t\tif opt == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif err := opt(l); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn l, nil\n}\n\n// LinuxFactory implements the default factory interface for linux based systems.\ntype LinuxFactory struct {\n\t// Root directory for the factory to store state.\n\tRoot string\n\n\t// InitPath is the path for calling the init responsibilities for spawning\n\t// a container.\n\tInitPath string\n\n\t// InitArgs are arguments for calling the init responsibilities for spawning\n\t// a container.\n\tInitArgs []string\n\n\t// CriuPath is the path to the criu binary used for checkpoint and restore of\n\t// containers.\n\tCriuPath string\n\n\t// New{u,g}idmapPath is the path to the binaries used for mapping with\n\t// rootless containers.\n\tNewuidmapPath string\n\tNewgidmapPath string\n\n\t// Validator provides validation to container configurations.\n\tValidator validate.Validator\n\n\t// NewIntelRdtManager returns an initialized Intel RDT manager for a single container.\n\tNewIntelRdtManager func(config *configs.Config, id string, path string) intelrdt.Manager\n}\n\nfunc (l *LinuxFactory) Create(id string, config *configs.Config) (Container, error) {\n\tif l.Root == \"\" {\n\t\treturn nil, errors.New(\"root not set\")\n\t}\n\tif err := l.validateID(id); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := l.Validator.Validate(config); err != nil {\n\t\treturn nil, err\n\t}\n\tcontainerRoot, err := securejoin.SecureJoin(l.Root, id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif _, err := os.Stat(containerRoot); err == nil {\n\t\treturn nil, ErrExist\n\t} else if !os.IsNotExist(err) {\n\t\treturn nil, err\n\t}\n\tif err := os.MkdirAll(containerRoot, 0o711); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := os.Chown(containerRoot, unix.Geteuid(), unix.Getegid()); err != nil {\n\t\treturn nil, err\n\t}\n\tcm, err := manager.New(config.Cgroups)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tc := &linuxContainer{\n\t\tid:            id,\n\t\troot:          containerRoot,\n\t\tconfig:        config,\n\t\tinitPath:      l.InitPath,\n\t\tinitArgs:      l.InitArgs,\n\t\tcriuPath:      l.CriuPath,\n\t\tnewuidmapPath: l.NewuidmapPath,\n\t\tnewgidmapPath: l.NewgidmapPath,\n\t\tcgroupManager: cm,\n\t}\n\tif l.NewIntelRdtManager != nil {\n\t\tc.intelRdtManager = l.NewIntelRdtManager(config, id, \"\")\n\t}\n\tc.state = &stoppedState{c: c}\n\treturn c, nil\n}\n\nfunc (l *LinuxFactory) Load(id string) (Container, error) {\n\tif l.Root == \"\" {\n\t\treturn nil, errors.New(\"root not set\")\n\t}\n\t// when load, we need to check id is valid or not.\n\tif err := l.validateID(id); err != nil {\n\t\treturn nil, err\n\t}\n\tcontainerRoot, err := securejoin.SecureJoin(l.Root, id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tstate, err := l.loadState(containerRoot, id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tr := &nonChildProcess{\n\t\tprocessPid:       state.InitProcessPid,\n\t\tprocessStartTime: state.InitProcessStartTime,\n\t\tfds:              state.ExternalDescriptors,\n\t}\n\tcm, err := manager.NewWithPaths(state.Config.Cgroups, state.CgroupPaths)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tc := &linuxContainer{\n\t\tinitProcess:          r,\n\t\tinitProcessStartTime: state.InitProcessStartTime,\n\t\tid:                   id,\n\t\tconfig:               &state.Config,\n\t\tinitPath:             l.InitPath,\n\t\tinitArgs:             l.InitArgs,\n\t\tcriuPath:             l.CriuPath,\n\t\tnewuidmapPath:        l.NewuidmapPath,\n\t\tnewgidmapPath:        l.NewgidmapPath,\n\t\tcgroupManager:        cm,\n\t\troot:                 containerRoot,\n\t\tcreated:              state.Created,\n\t}\n\tif l.NewIntelRdtManager != nil {\n\t\tc.intelRdtManager = l.NewIntelRdtManager(&state.Config, id, state.IntelRdtPath)\n\t}\n\tc.state = &loadedState{c: c}\n\tif err := c.refreshState(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn c, nil\n}\n\nfunc (l *LinuxFactory) Type() string {\n\treturn \"libcontainer\"\n}\n\n// StartInitialization loads a container by opening the pipe fd from the parent to read the configuration and state\n// This is a low level implementation detail of the reexec and should not be consumed externally\nfunc (l *LinuxFactory) StartInitialization() (err error) {\n\t// Get the INITPIPE.\n\tenvInitPipe := os.Getenv(\"_LIBCONTAINER_INITPIPE\")\n\tpipefd, err := strconv.Atoi(envInitPipe)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"unable to convert _LIBCONTAINER_INITPIPE: %w\", err)\n\t\tlogrus.Error(err)\n\t\treturn err\n\t}\n\tpipe := os.NewFile(uintptr(pipefd), \"pipe\")\n\tdefer pipe.Close()\n\n\tdefer func() {\n\t\t// We have an error during the initialization of the container's init,\n\t\t// send it back to the parent process in the form of an initError.\n\t\tif werr := writeSync(pipe, procError); werr != nil {\n\t\t\tfmt.Fprintln(os.Stderr, err)\n\t\t\treturn\n\t\t}\n\t\tif werr := utils.WriteJSON(pipe, &initError{Message: err.Error()}); werr != nil {\n\t\t\tfmt.Fprintln(os.Stderr, err)\n\t\t\treturn\n\t\t}\n\t}()\n\n\t// Only init processes have FIFOFD.\n\tfifofd := -1\n\tenvInitType := os.Getenv(\"_LIBCONTAINER_INITTYPE\")\n\tit := initType(envInitType)\n\tif it == initStandard {\n\t\tenvFifoFd := os.Getenv(\"_LIBCONTAINER_FIFOFD\")\n\t\tif fifofd, err = strconv.Atoi(envFifoFd); err != nil {\n\t\t\treturn fmt.Errorf(\"unable to convert _LIBCONTAINER_FIFOFD: %w\", err)\n\t\t}\n\t}\n\n\tvar consoleSocket *os.File\n\tif envConsole := os.Getenv(\"_LIBCONTAINER_CONSOLE\"); envConsole != \"\" {\n\t\tconsole, err := strconv.Atoi(envConsole)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to convert _LIBCONTAINER_CONSOLE: %w\", err)\n\t\t}\n\t\tconsoleSocket = os.NewFile(uintptr(console), \"console-socket\")\n\t\tdefer consoleSocket.Close()\n\t}\n\n\tlogPipeFdStr := os.Getenv(\"_LIBCONTAINER_LOGPIPE\")\n\tlogPipeFd, err := strconv.Atoi(logPipeFdStr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to convert _LIBCONTAINER_LOGPIPE: %w\", err)\n\t}\n\n\t// clear the current process's environment to clean any libcontainer\n\t// specific env vars.\n\tos.Clearenv()\n\n\tdefer func() {\n\t\tif e := recover(); e != nil {\n\t\t\terr = fmt.Errorf(\"panic from initialization: %w, %v\", e, string(debug.Stack()))\n\t\t}\n\t}()\n\n\ti, err := newContainerInit(it, pipe, consoleSocket, fifofd, logPipeFd)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// If Init succeeds, syscall.Exec will not return, hence none of the defers will be called.\n\treturn i.Init()\n}\n\nfunc (l *LinuxFactory) loadState(root, id string) (*State, error) {\n\tstateFilePath, err := securejoin.SecureJoin(root, stateFilename)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tf, err := os.Open(stateFilePath)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn nil, ErrNotExist\n\t\t}\n\t\treturn nil, err\n\t}\n\tdefer f.Close()\n\tvar state *State\n\tif err := json.NewDecoder(f).Decode(&state); err != nil {\n\t\treturn nil, err\n\t}\n\treturn state, nil\n}\n\nfunc (l *LinuxFactory) validateID(id string) error {\n\tif !idRegex.MatchString(id) || string(os.PathSeparator)+id != utils.CleanPath(string(os.PathSeparator)+id) {\n\t\treturn ErrInvalidID\n\t}\n\n\treturn nil\n}\n\n// NewuidmapPath returns an option func to configure a LinuxFactory with the\n// provided ..\nfunc NewuidmapPath(newuidmapPath string) func(*LinuxFactory) error {\n\treturn func(l *LinuxFactory) error {\n\t\tl.NewuidmapPath = newuidmapPath\n\t\treturn nil\n\t}\n}\n\n// NewgidmapPath returns an option func to configure a LinuxFactory with the\n// provided ..\nfunc NewgidmapPath(newgidmapPath string) func(*LinuxFactory) error {\n\treturn func(l *LinuxFactory) error {\n\t\tl.NewgidmapPath = newgidmapPath\n\t\treturn nil\n\t}\n}\n", "package libcontainer\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"os\"\n\t\"strings\"\n\t\"unsafe\"\n\n\t\"github.com/containerd/console\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/vishvananda/netlink\"\n\t\"golang.org/x/sys/unix\"\n\n\t\"github.com/opencontainers/runc/libcontainer/capabilities\"\n\t\"github.com/opencontainers/runc/libcontainer/cgroups\"\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/opencontainers/runc/libcontainer/system\"\n\t\"github.com/opencontainers/runc/libcontainer/user\"\n\t\"github.com/opencontainers/runc/libcontainer/utils\"\n)\n\ntype initType string\n\nconst (\n\tinitSetns    initType = \"setns\"\n\tinitStandard initType = \"standard\"\n)\n\ntype pid struct {\n\tPid           int `json:\"stage2_pid\"`\n\tPidFirstChild int `json:\"stage1_pid\"`\n}\n\n// network is an internal struct used to setup container networks.\ntype network struct {\n\tconfigs.Network\n\n\t// TempVethPeerName is a unique temporary veth peer name that was placed into\n\t// the container's namespace.\n\tTempVethPeerName string `json:\"temp_veth_peer_name\"`\n}\n\n// initConfig is used for transferring parameters from Exec() to Init()\ntype initConfig struct {\n\tArgs             []string              `json:\"args\"`\n\tEnv              []string              `json:\"env\"`\n\tCwd              string                `json:\"cwd\"`\n\tCapabilities     *configs.Capabilities `json:\"capabilities\"`\n\tProcessLabel     string                `json:\"process_label\"`\n\tAppArmorProfile  string                `json:\"apparmor_profile\"`\n\tNoNewPrivileges  bool                  `json:\"no_new_privileges\"`\n\tUser             string                `json:\"user\"`\n\tAdditionalGroups []string              `json:\"additional_groups\"`\n\tConfig           *configs.Config       `json:\"config\"`\n\tNetworks         []*network            `json:\"network\"`\n\tPassedFilesCount int                   `json:\"passed_files_count\"`\n\tContainerId      string                `json:\"containerid\"`\n\tRlimits          []configs.Rlimit      `json:\"rlimits\"`\n\tCreateConsole    bool                  `json:\"create_console\"`\n\tConsoleWidth     uint16                `json:\"console_width\"`\n\tConsoleHeight    uint16                `json:\"console_height\"`\n\tRootlessEUID     bool                  `json:\"rootless_euid,omitempty\"`\n\tRootlessCgroups  bool                  `json:\"rootless_cgroups,omitempty\"`\n\tSpecState        *specs.State          `json:\"spec_state,omitempty\"`\n\tCgroup2Path      string                `json:\"cgroup2_path,omitempty\"`\n}\n\ntype initer interface {\n\tInit() error\n}\n\nfunc newContainerInit(t initType, pipe *os.File, consoleSocket *os.File, fifoFd, logFd int) (initer, error) {\n\tvar config *initConfig\n\tif err := json.NewDecoder(pipe).Decode(&config); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := populateProcessEnvironment(config.Env); err != nil {\n\t\treturn nil, err\n\t}\n\tswitch t {\n\tcase initSetns:\n\t\treturn &linuxSetnsInit{\n\t\t\tpipe:          pipe,\n\t\t\tconsoleSocket: consoleSocket,\n\t\t\tconfig:        config,\n\t\t\tlogFd:         logFd,\n\t\t}, nil\n\tcase initStandard:\n\t\treturn &linuxStandardInit{\n\t\t\tpipe:          pipe,\n\t\t\tconsoleSocket: consoleSocket,\n\t\t\tparentPid:     unix.Getppid(),\n\t\t\tconfig:        config,\n\t\t\tfifoFd:        fifoFd,\n\t\t\tlogFd:         logFd,\n\t\t}, nil\n\t}\n\treturn nil, fmt.Errorf(\"unknown init type %q\", t)\n}\n\n// populateProcessEnvironment loads the provided environment variables into the\n// current processes's environment.\nfunc populateProcessEnvironment(env []string) error {\n\tfor _, pair := range env {\n\t\tp := strings.SplitN(pair, \"=\", 2)\n\t\tif len(p) < 2 {\n\t\t\treturn fmt.Errorf(\"invalid environment variable: %q\", pair)\n\t\t}\n\t\tname, val := p[0], p[1]\n\t\tif name == \"\" {\n\t\t\treturn fmt.Errorf(\"environment variable name can't be empty: %q\", pair)\n\t\t}\n\t\tif strings.IndexByte(name, 0) >= 0 {\n\t\t\treturn fmt.Errorf(\"environment variable name can't contain null(\\\\x00): %q\", pair)\n\t\t}\n\t\tif strings.IndexByte(val, 0) >= 0 {\n\t\t\treturn fmt.Errorf(\"environment variable value can't contain null(\\\\x00): %q\", pair)\n\t\t}\n\t\tif err := os.Setenv(name, val); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// finalizeNamespace drops the caps, sets the correct user\n// and working dir, and closes any leaked file descriptors\n// before executing the command inside the namespace\nfunc finalizeNamespace(config *initConfig) error {\n\t// Ensure that all unwanted fds we may have accidentally\n\t// inherited are marked close-on-exec so they stay out of the\n\t// container\n\tif err := utils.CloseExecFrom(config.PassedFilesCount + 3); err != nil {\n\t\treturn fmt.Errorf(\"error closing exec fds: %w\", err)\n\t}\n\n\t// we only do chdir if it's specified\n\tdoChdir := config.Cwd != \"\"\n\tif doChdir {\n\t\t// First, attempt the chdir before setting up the user.\n\t\t// This could allow us to access a directory that the user running runc can access\n\t\t// but the container user cannot.\n\t\terr := unix.Chdir(config.Cwd)\n\t\tswitch {\n\t\tcase err == nil:\n\t\t\tdoChdir = false\n\t\tcase os.IsPermission(err):\n\t\t\t// If we hit an EPERM, we should attempt again after setting up user.\n\t\t\t// This will allow us to successfully chdir if the container user has access\n\t\t\t// to the directory, but the user running runc does not.\n\t\t\t// This is useful in cases where the cwd is also a volume that's been chowned to the container user.\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"chdir to cwd (%q) set in config.json failed: %w\", config.Cwd, err)\n\t\t}\n\t}\n\n\tcaps := &configs.Capabilities{}\n\tif config.Capabilities != nil {\n\t\tcaps = config.Capabilities\n\t} else if config.Config.Capabilities != nil {\n\t\tcaps = config.Config.Capabilities\n\t}\n\tw, err := capabilities.New(caps)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// drop capabilities in bounding set before changing user\n\tif err := w.ApplyBoundingSet(); err != nil {\n\t\treturn fmt.Errorf(\"unable to apply bounding set: %w\", err)\n\t}\n\t// preserve existing capabilities while we change users\n\tif err := system.SetKeepCaps(); err != nil {\n\t\treturn fmt.Errorf(\"unable to set keep caps: %w\", err)\n\t}\n\tif err := setupUser(config); err != nil {\n\t\treturn fmt.Errorf(\"unable to setup user: %w\", err)\n\t}\n\t// Change working directory AFTER the user has been set up, if we haven't done it yet.\n\tif doChdir {\n\t\tif err := unix.Chdir(config.Cwd); err != nil {\n\t\t\treturn fmt.Errorf(\"chdir to cwd (%q) set in config.json failed: %w\", config.Cwd, err)\n\t\t}\n\t}\n\tif err := system.ClearKeepCaps(); err != nil {\n\t\treturn fmt.Errorf(\"unable to clear keep caps: %w\", err)\n\t}\n\tif err := w.ApplyCaps(); err != nil {\n\t\treturn fmt.Errorf(\"unable to apply caps: %w\", err)\n\t}\n\treturn nil\n}\n\n// setupConsole sets up the console from inside the container, and sends the\n// master pty fd to the config.Pipe (using cmsg). This is done to ensure that\n// consoles are scoped to a container properly (see runc#814 and the many\n// issues related to that). This has to be run *after* we've pivoted to the new\n// rootfs (and the users' configuration is entirely set up).\nfunc setupConsole(socket *os.File, config *initConfig, mount bool) error {\n\tdefer socket.Close()\n\t// At this point, /dev/ptmx points to something that we would expect. We\n\t// used to change the owner of the slave path, but since the /dev/pts mount\n\t// can have gid=X set (at the users' option). So touching the owner of the\n\t// slave PTY is not necessary, as the kernel will handle that for us. Note\n\t// however, that setupUser (specifically fixStdioPermissions) *will* change\n\t// the UID owner of the console to be the user the process will run as (so\n\t// they can actually control their console).\n\n\tpty, slavePath, err := console.NewPty()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// After we return from here, we don't need the console anymore.\n\tdefer pty.Close()\n\n\tif config.ConsoleHeight != 0 && config.ConsoleWidth != 0 {\n\t\terr = pty.Resize(console.WinSize{\n\t\t\tHeight: config.ConsoleHeight,\n\t\t\tWidth:  config.ConsoleWidth,\n\t\t})\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Mount the console inside our rootfs.\n\tif mount {\n\t\tif err := mountConsole(slavePath); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t// While we can access console.master, using the API is a good idea.\n\tif err := utils.SendFd(socket, pty.Name(), pty.Fd()); err != nil {\n\t\treturn err\n\t}\n\t// Now, dup over all the things.\n\treturn dupStdio(slavePath)\n}\n\n// syncParentReady sends to the given pipe a JSON payload which indicates that\n// the init is ready to Exec the child process. It then waits for the parent to\n// indicate that it is cleared to Exec.\nfunc syncParentReady(pipe io.ReadWriter) error {\n\t// Tell parent.\n\tif err := writeSync(pipe, procReady); err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for parent to give the all-clear.\n\treturn readSync(pipe, procRun)\n}\n\n// syncParentHooks sends to the given pipe a JSON payload which indicates that\n// the parent should execute pre-start hooks. It then waits for the parent to\n// indicate that it is cleared to resume.\nfunc syncParentHooks(pipe io.ReadWriter) error {\n\t// Tell parent.\n\tif err := writeSync(pipe, procHooks); err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for parent to give the all-clear.\n\treturn readSync(pipe, procResume)\n}\n\n// syncParentSeccomp sends to the given pipe a JSON payload which\n// indicates that the parent should pick up the seccomp fd with pidfd_getfd()\n// and send it to the seccomp agent over a unix socket. It then waits for\n// the parent to indicate that it is cleared to resume and closes the seccompFd.\n// If the seccompFd is -1, there isn't anything to sync with the parent, so it\n// returns no error.\nfunc syncParentSeccomp(pipe io.ReadWriter, seccompFd int) error {\n\tif seccompFd == -1 {\n\t\treturn nil\n\t}\n\n\t// Tell parent.\n\tif err := writeSyncWithFd(pipe, procSeccomp, seccompFd); err != nil {\n\t\tunix.Close(seccompFd)\n\t\treturn err\n\t}\n\n\t// Wait for parent to give the all-clear.\n\tif err := readSync(pipe, procSeccompDone); err != nil {\n\t\tunix.Close(seccompFd)\n\t\treturn fmt.Errorf(\"sync parent seccomp: %w\", err)\n\t}\n\n\tif err := unix.Close(seccompFd); err != nil {\n\t\treturn fmt.Errorf(\"close seccomp fd: %w\", err)\n\t}\n\n\treturn nil\n}\n\n// setupUser changes the groups, gid, and uid for the user inside the container\nfunc setupUser(config *initConfig) error {\n\t// Set up defaults.\n\tdefaultExecUser := user.ExecUser{\n\t\tUid:  0,\n\t\tGid:  0,\n\t\tHome: \"/\",\n\t}\n\n\tpasswdPath, err := user.GetPasswdPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tgroupPath, err := user.GetGroupPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\texecUser, err := user.GetExecUserPath(config.User, &defaultExecUser, passwdPath, groupPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar addGroups []int\n\tif len(config.AdditionalGroups) > 0 {\n\t\taddGroups, err = user.GetAdditionalGroupsPath(config.AdditionalGroups, groupPath)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Rather than just erroring out later in setuid(2) and setgid(2), check\n\t// that the user is mapped here.\n\tif _, err := config.Config.HostUID(execUser.Uid); err != nil {\n\t\treturn errors.New(\"cannot set uid to unmapped user in user namespace\")\n\t}\n\tif _, err := config.Config.HostGID(execUser.Gid); err != nil {\n\t\treturn errors.New(\"cannot set gid to unmapped user in user namespace\")\n\t}\n\n\tif config.RootlessEUID {\n\t\t// We cannot set any additional groups in a rootless container and thus\n\t\t// we bail if the user asked us to do so. TODO: We currently can't do\n\t\t// this check earlier, but if libcontainer.Process.User was typesafe\n\t\t// this might work.\n\t\tif len(addGroups) > 0 {\n\t\t\treturn errors.New(\"cannot set any additional groups in a rootless container\")\n\t\t}\n\t}\n\n\t// Before we change to the container's user make sure that the processes\n\t// STDIO is correctly owned by the user that we are switching to.\n\tif err := fixStdioPermissions(config, execUser); err != nil {\n\t\treturn err\n\t}\n\n\tsetgroups, err := ioutil.ReadFile(\"/proc/self/setgroups\")\n\tif err != nil && !os.IsNotExist(err) {\n\t\treturn err\n\t}\n\n\t// This isn't allowed in an unprivileged user namespace since Linux 3.19.\n\t// There's nothing we can do about /etc/group entries, so we silently\n\t// ignore setting groups here (since the user didn't explicitly ask us to\n\t// set the group).\n\tallowSupGroups := !config.RootlessEUID && string(bytes.TrimSpace(setgroups)) != \"deny\"\n\n\tif allowSupGroups {\n\t\tsuppGroups := append(execUser.Sgids, addGroups...)\n\t\tif err := unix.Setgroups(suppGroups); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := system.Setgid(execUser.Gid); err != nil {\n\t\treturn err\n\t}\n\tif err := system.Setuid(execUser.Uid); err != nil {\n\t\treturn err\n\t}\n\n\t// if we didn't get HOME already, set it based on the user's HOME\n\tif envHome := os.Getenv(\"HOME\"); envHome == \"\" {\n\t\tif err := os.Setenv(\"HOME\", execUser.Home); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// fixStdioPermissions fixes the permissions of PID 1's STDIO within the container to the specified user.\n// The ownership needs to match because it is created outside of the container and needs to be\n// localized.\nfunc fixStdioPermissions(config *initConfig, u *user.ExecUser) error {\n\tvar null unix.Stat_t\n\tif err := unix.Stat(\"/dev/null\", &null); err != nil {\n\t\treturn err\n\t}\n\tfor _, fd := range []uintptr{\n\t\tos.Stdin.Fd(),\n\t\tos.Stderr.Fd(),\n\t\tos.Stdout.Fd(),\n\t} {\n\t\tvar s unix.Stat_t\n\t\tif err := unix.Fstat(int(fd), &s); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Skip chown of /dev/null if it was used as one of the STDIO fds.\n\t\tif s.Rdev == null.Rdev {\n\t\t\tcontinue\n\t\t}\n\n\t\t// We only change the uid owner (as it is possible for the mount to\n\t\t// prefer a different gid, and there's no reason for us to change it).\n\t\t// The reason why we don't just leave the default uid=X mount setup is\n\t\t// that users expect to be able to actually use their console. Without\n\t\t// this code, you couldn't effectively run as a non-root user inside a\n\t\t// container and also have a console set up.\n\t\tif err := unix.Fchown(int(fd), u.Uid, int(s.Gid)); err != nil {\n\t\t\t// If we've hit an EINVAL then s.Gid isn't mapped in the user\n\t\t\t// namespace. If we've hit an EPERM then the inode's current owner\n\t\t\t// is not mapped in our user namespace (in particular,\n\t\t\t// privileged_wrt_inode_uidgid() has failed). In either case, we\n\t\t\t// are in a configuration where it's better for us to just not\n\t\t\t// touch the stdio rather than bail at this point.\n\n\t\t\t// nolint:errorlint // unix errors are bare\n\t\t\tif err == unix.EINVAL || err == unix.EPERM {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// setupNetwork sets up and initializes any network interface inside the container.\nfunc setupNetwork(config *initConfig) error {\n\tfor _, config := range config.Networks {\n\t\tstrategy, err := getStrategy(config.Type)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := strategy.initialize(config); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc setupRoute(config *configs.Config) error {\n\tfor _, config := range config.Routes {\n\t\t_, dst, err := net.ParseCIDR(config.Destination)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsrc := net.ParseIP(config.Source)\n\t\tif src == nil {\n\t\t\treturn fmt.Errorf(\"Invalid source for route: %s\", config.Source)\n\t\t}\n\t\tgw := net.ParseIP(config.Gateway)\n\t\tif gw == nil {\n\t\t\treturn fmt.Errorf(\"Invalid gateway for route: %s\", config.Gateway)\n\t\t}\n\t\tl, err := netlink.LinkByName(config.InterfaceName)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\troute := &netlink.Route{\n\t\t\tScope:     netlink.SCOPE_UNIVERSE,\n\t\t\tDst:       dst,\n\t\t\tSrc:       src,\n\t\t\tGw:        gw,\n\t\t\tLinkIndex: l.Attrs().Index,\n\t\t}\n\t\tif err := netlink.RouteAdd(route); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc setupRlimits(limits []configs.Rlimit, pid int) error {\n\tfor _, rlimit := range limits {\n\t\tif err := system.Prlimit(pid, rlimit.Type, unix.Rlimit{Max: rlimit.Hard, Cur: rlimit.Soft}); err != nil {\n\t\t\treturn fmt.Errorf(\"error setting rlimit type %v: %w\", rlimit.Type, err)\n\t\t}\n\t}\n\treturn nil\n}\n\nconst _P_PID = 1\n\n//nolint:structcheck,unused\ntype siginfo struct {\n\tsi_signo int32\n\tsi_errno int32\n\tsi_code  int32\n\t// below here is a union; si_pid is the only field we use\n\tsi_pid int32\n\t// Pad to 128 bytes as detailed in blockUntilWaitable\n\tpad [96]byte\n}\n\n// isWaitable returns true if the process has exited false otherwise.\n// Its based off blockUntilWaitable in src/os/wait_waitid.go\nfunc isWaitable(pid int) (bool, error) {\n\tsi := &siginfo{}\n\t_, _, e := unix.Syscall6(unix.SYS_WAITID, _P_PID, uintptr(pid), uintptr(unsafe.Pointer(si)), unix.WEXITED|unix.WNOWAIT|unix.WNOHANG, 0, 0)\n\tif e != 0 {\n\t\treturn false, os.NewSyscallError(\"waitid\", e)\n\t}\n\n\treturn si.si_pid != 0, nil\n}\n\n// signalAllProcesses freezes then iterates over all the processes inside the\n// manager's cgroups sending the signal s to them.\n// If s is SIGKILL then it will wait for each process to exit.\n// For all other signals it will check if the process is ready to report its\n// exit status and only if it is will a wait be performed.\nfunc signalAllProcesses(m cgroups.Manager, s os.Signal) error {\n\tvar procs []*os.Process\n\tif err := m.Freeze(configs.Frozen); err != nil {\n\t\tlogrus.Warn(err)\n\t}\n\tpids, err := m.GetAllPids()\n\tif err != nil {\n\t\tif err := m.Freeze(configs.Thawed); err != nil {\n\t\t\tlogrus.Warn(err)\n\t\t}\n\t\treturn err\n\t}\n\tfor _, pid := range pids {\n\t\tp, err := os.FindProcess(pid)\n\t\tif err != nil {\n\t\t\tlogrus.Warn(err)\n\t\t\tcontinue\n\t\t}\n\t\tprocs = append(procs, p)\n\t\tif err := p.Signal(s); err != nil {\n\t\t\tlogrus.Warn(err)\n\t\t}\n\t}\n\tif err := m.Freeze(configs.Thawed); err != nil {\n\t\tlogrus.Warn(err)\n\t}\n\n\tsubreaper, err := system.GetSubreaper()\n\tif err != nil {\n\t\t// The error here means that PR_GET_CHILD_SUBREAPER is not\n\t\t// supported because this code might run on a kernel older\n\t\t// than 3.4. We don't want to throw an error in that case,\n\t\t// and we simplify things, considering there is no subreaper\n\t\t// set.\n\t\tsubreaper = 0\n\t}\n\n\tfor _, p := range procs {\n\t\tif s != unix.SIGKILL {\n\t\t\tif ok, err := isWaitable(p.Pid); err != nil {\n\t\t\t\tif !errors.Is(err, unix.ECHILD) {\n\t\t\t\t\tlogrus.Warn(\"signalAllProcesses: \", p.Pid, err)\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t} else if !ok {\n\t\t\t\t// Not ready to report so don't wait\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\t// In case a subreaper has been setup, this code must not\n\t\t// wait for the process. Otherwise, we cannot be sure the\n\t\t// current process will be reaped by the subreaper, while\n\t\t// the subreaper might be waiting for this process in order\n\t\t// to retrieve its exit code.\n\t\tif subreaper == 0 {\n\t\t\tif _, err := p.Wait(); err != nil {\n\t\t\t\tif !errors.Is(err, unix.ECHILD) {\n\t\t\t\t\tlogrus.Warn(\"wait: \", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n", "package libcontainer\n\nimport (\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"golang.org/x/sys/unix\"\n)\n\n// list of known message types we want to send to bootstrap program\n// The number is randomly chosen to not conflict with known netlink types\nconst (\n\tInitMsg          uint16 = 62000\n\tCloneFlagsAttr   uint16 = 27281\n\tNsPathsAttr      uint16 = 27282\n\tUidmapAttr       uint16 = 27283\n\tGidmapAttr       uint16 = 27284\n\tSetgroupAttr     uint16 = 27285\n\tOomScoreAdjAttr  uint16 = 27286\n\tRootlessEUIDAttr uint16 = 27287\n\tUidmapPathAttr   uint16 = 27288\n\tGidmapPathAttr   uint16 = 27289\n)\n\ntype Int32msg struct {\n\tType  uint16\n\tValue uint32\n}\n\n// Serialize serializes the message.\n// Int32msg has the following representation\n// | nlattr len | nlattr type |\n// | uint32 value             |\nfunc (msg *Int32msg) Serialize() []byte {\n\tbuf := make([]byte, msg.Len())\n\tnative := nl.NativeEndian()\n\tnative.PutUint16(buf[0:2], uint16(msg.Len()))\n\tnative.PutUint16(buf[2:4], msg.Type)\n\tnative.PutUint32(buf[4:8], msg.Value)\n\treturn buf\n}\n\nfunc (msg *Int32msg) Len() int {\n\treturn unix.NLA_HDRLEN + 4\n}\n\n// Bytemsg has the following representation\n// | nlattr len | nlattr type |\n// | value              | pad |\ntype Bytemsg struct {\n\tType  uint16\n\tValue []byte\n}\n\nfunc (msg *Bytemsg) Serialize() []byte {\n\tl := msg.Len()\n\tbuf := make([]byte, (l+unix.NLA_ALIGNTO-1) & ^(unix.NLA_ALIGNTO-1))\n\tnative := nl.NativeEndian()\n\tnative.PutUint16(buf[0:2], uint16(l))\n\tnative.PutUint16(buf[2:4], msg.Type)\n\tcopy(buf[4:], msg.Value)\n\treturn buf\n}\n\nfunc (msg *Bytemsg) Len() int {\n\treturn unix.NLA_HDRLEN + len(msg.Value) + 1 // null-terminated\n}\n\ntype Boolmsg struct {\n\tType  uint16\n\tValue bool\n}\n\nfunc (msg *Boolmsg) Serialize() []byte {\n\tbuf := make([]byte, msg.Len())\n\tnative := nl.NativeEndian()\n\tnative.PutUint16(buf[0:2], uint16(msg.Len()))\n\tnative.PutUint16(buf[2:4], msg.Type)\n\tif msg.Value {\n\t\tnative.PutUint32(buf[4:8], uint32(1))\n\t} else {\n\t\tnative.PutUint32(buf[4:8], uint32(0))\n\t}\n\treturn buf\n}\n\nfunc (msg *Boolmsg) Len() int {\n\treturn unix.NLA_HDRLEN + 4 // alignment\n}\n", "\n#define _GNU_SOURCE\n#include <endian.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <grp.h>\n#include <sched.h>\n#include <setjmp.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <unistd.h>\n\n#include <sys/ioctl.h>\n#include <sys/prctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n\n#include <linux/limits.h>\n#include <linux/netlink.h>\n#include <linux/types.h>\n\n/* Get all of the CLONE_NEW* flags. */\n#include \"namespace.h\"\n\nextern char *escape_json_string(char *str);\n\n/* Synchronisation values. */\nenum sync_t {\n\tSYNC_USERMAP_PLS = 0x40,\t/* Request parent to map our users. */\n\tSYNC_USERMAP_ACK = 0x41,\t/* Mapping finished by the parent. */\n\tSYNC_RECVPID_PLS = 0x42,\t/* Tell parent we're sending the PID. */\n\tSYNC_RECVPID_ACK = 0x43,\t/* PID was correctly received by parent. */\n\tSYNC_GRANDCHILD = 0x44,\t/* The grandchild is ready to run. */\n\tSYNC_CHILD_FINISH = 0x45,\t/* The child or grandchild has finished. */\n};\n\n#define STAGE_SETUP  -1\n/* longjmp() arguments. */\n#define STAGE_PARENT  0\n#define STAGE_CHILD   1\n#define STAGE_INIT    2\n\n/* Stores the current stage of nsexec. */\nint current_stage = STAGE_SETUP;\n\n/* Assume the stack grows down, so arguments should be above it. */\nstruct clone_t {\n\t/*\n\t * Reserve some space for clone() to locate arguments\n\t * and retcode in this place\n\t */\n\tchar stack[4096] __attribute__((aligned(16)));\n\tchar stack_ptr[0];\n\n\t/* There's two children. This is used to execute the different code. */\n\tjmp_buf *env;\n\tint jmpval;\n};\n\nstruct nlconfig_t {\n\tchar *data;\n\n\t/* Process settings. */\n\tuint32_t cloneflags;\n\tchar *oom_score_adj;\n\tsize_t oom_score_adj_len;\n\n\t/* User namespace settings. */\n\tchar *uidmap;\n\tsize_t uidmap_len;\n\tchar *gidmap;\n\tsize_t gidmap_len;\n\tchar *namespaces;\n\tsize_t namespaces_len;\n\tuint8_t is_setgroup;\n\n\t/* Rootless container settings. */\n\tuint8_t is_rootless_euid;\t/* boolean */\n\tchar *uidmappath;\n\tsize_t uidmappath_len;\n\tchar *gidmappath;\n\tsize_t gidmappath_len;\n};\n\n/*\n * Log levels are the same as in logrus.\n */\n#define PANIC   0\n#define FATAL   1\n#define ERROR   2\n#define WARNING 3\n#define INFO    4\n#define DEBUG   5\n#define TRACE   6\n\nstatic const char *level_str[] = { \"panic\", \"fatal\", \"error\", \"warning\", \"info\", \"debug\", \"trace\" };\n\nstatic int logfd = -1;\nstatic int loglevel = DEBUG;\n\n/*\n * List of netlink message types sent to us as part of bootstrapping the init.\n * These constants are defined in libcontainer/message_linux.go.\n */\n#define INIT_MSG\t\t62000\n#define CLONE_FLAGS_ATTR\t27281\n#define NS_PATHS_ATTR\t\t27282\n#define UIDMAP_ATTR\t\t27283\n#define GIDMAP_ATTR\t\t27284\n#define SETGROUP_ATTR\t\t27285\n#define OOM_SCORE_ADJ_ATTR\t27286\n#define ROOTLESS_EUID_ATTR\t27287\n#define UIDMAPPATH_ATTR\t\t27288\n#define GIDMAPPATH_ATTR\t\t27289\n\n/*\n * Use the raw syscall for versions of glibc which don't include a function for\n * it, namely (glibc 2.12).\n */\n#if __GLIBC__ == 2 && __GLIBC_MINOR__ < 14\n#  define _GNU_SOURCE\n#  include \"syscall.h\"\n#  if !defined(SYS_setns) && defined(__NR_setns)\n#    define SYS_setns __NR_setns\n#  endif\n\n#  ifndef SYS_setns\n#    error \"setns(2) syscall not supported by glibc version\"\n#  endif\n\nint setns(int fd, int nstype)\n{\n\treturn syscall(SYS_setns, fd, nstype);\n}\n#endif\n\nstatic void write_log(int level, const char *format, ...)\n{\n\tchar *message = NULL, *stage = NULL, *json = NULL;\n\tva_list args;\n\tint ret;\n\n\tif (logfd < 0 || level > loglevel)\n\t\tgoto out;\n\n\tva_start(args, format);\n\tret = vasprintf(&message, format, args);\n\tva_end(args);\n\tif (ret < 0) {\n\t\tmessage = NULL;\n\t\tgoto out;\n\t}\n\n\tmessage = escape_json_string(message);\n\n\tif (current_stage == STAGE_SETUP)\n\t\tstage = strdup(\"nsexec\");\n\telse\n\t\tret = asprintf(&stage, \"nsexec-%d\", current_stage);\n\tif (ret < 0) {\n\t\tstage = NULL;\n\t\tgoto out;\n\t}\n\n\tret = asprintf(&json, \"{\\\"level\\\":\\\"%s\\\", \\\"msg\\\": \\\"%s[%d]: %s\\\"}\\n\",\n\t\t       level_str[level], stage, getpid(), message);\n\tif (ret < 0) {\n\t\tjson = NULL;\n\t\tgoto out;\n\t}\n\n\t/* This logging is on a best-effort basis. In case of a short or failed\n\t * write there is nothing we can do, so just ignore write() errors.\n\t */\n\tssize_t __attribute__((unused)) __res = write(logfd, json, ret);\n\nout:\n\tfree(message);\n\tfree(stage);\n\tfree(json);\n}\n\n/* XXX: This is ugly. */\nstatic int syncfd = -1;\n\n#define bail(fmt, ...)                                               \\\n\tdo {                                                         \\\n\t\tif (logfd < 0)                                       \\\n\t\t\tfprintf(stderr, \"FATAL: \" fmt \": %m\\n\",      \\\n\t\t\t\t##__VA_ARGS__);                      \\\n\t\telse                                                 \\\n\t\t\twrite_log(FATAL, fmt \": %m\", ##__VA_ARGS__); \\\n\t\texit(1);                                             \\\n\t} while(0)\n\nstatic int write_file(char *data, size_t data_len, char *pathfmt, ...)\n{\n\tint fd, len, ret = 0;\n\tchar path[PATH_MAX];\n\n\tva_list ap;\n\tva_start(ap, pathfmt);\n\tlen = vsnprintf(path, PATH_MAX, pathfmt, ap);\n\tva_end(ap);\n\tif (len < 0)\n\t\treturn -1;\n\n\tfd = open(path, O_RDWR);\n\tif (fd < 0) {\n\t\treturn -1;\n\t}\n\n\tlen = write(fd, data, data_len);\n\tif (len != data_len) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\nout:\n\tclose(fd);\n\treturn ret;\n}\n\nenum policy_t {\n\tSETGROUPS_DEFAULT = 0,\n\tSETGROUPS_ALLOW,\n\tSETGROUPS_DENY,\n};\n\n/* This *must* be called before we touch gid_map. */\nstatic void update_setgroups(int pid, enum policy_t setgroup)\n{\n\tchar *policy;\n\n\tswitch (setgroup) {\n\tcase SETGROUPS_ALLOW:\n\t\tpolicy = \"allow\";\n\t\tbreak;\n\tcase SETGROUPS_DENY:\n\t\tpolicy = \"deny\";\n\t\tbreak;\n\tcase SETGROUPS_DEFAULT:\n\tdefault:\n\t\t/* Nothing to do. */\n\t\treturn;\n\t}\n\n\tif (write_file(policy, strlen(policy), \"/proc/%d/setgroups\", pid) < 0) {\n\t\t/*\n\t\t * If the kernel is too old to support /proc/pid/setgroups,\n\t\t * open(2) or write(2) will return ENOENT. This is fine.\n\t\t */\n\t\tif (errno != ENOENT)\n\t\t\tbail(\"failed to write '%s' to /proc/%d/setgroups\", policy, pid);\n\t}\n}\n\nstatic int try_mapping_tool(const char *app, int pid, char *map, size_t map_len)\n{\n\tint child;\n\n\t/*\n\t * If @app is NULL, execve will segfault. Just check it here and bail (if\n\t * we're in this path, the caller is already getting desperate and there\n\t * isn't a backup to this failing). This usually would be a configuration\n\t * or programming issue.\n\t */\n\tif (!app)\n\t\tbail(\"mapping tool not present\");\n\n\tchild = fork();\n\tif (child < 0)\n\t\tbail(\"failed to fork\");\n\n\tif (!child) {\n#define MAX_ARGV 20\n\t\tchar *argv[MAX_ARGV];\n\t\tchar *envp[] = { NULL };\n\t\tchar pid_fmt[16];\n\t\tint argc = 0;\n\t\tchar *next;\n\n\t\tsnprintf(pid_fmt, 16, \"%d\", pid);\n\n\t\targv[argc++] = (char *)app;\n\t\targv[argc++] = pid_fmt;\n\t\t/*\n\t\t * Convert the map string into a list of argument that\n\t\t * newuidmap/newgidmap can understand.\n\t\t */\n\n\t\twhile (argc < MAX_ARGV) {\n\t\t\tif (*map == '\\0') {\n\t\t\t\targv[argc++] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\targv[argc++] = map;\n\t\t\tnext = strpbrk(map, \"\\n \");\n\t\t\tif (next == NULL)\n\t\t\t\tbreak;\n\t\t\t*next++ = '\\0';\n\t\t\tmap = next + strspn(next, \"\\n \");\n\t\t}\n\n\t\texecve(app, argv, envp);\n\t\tbail(\"failed to execv\");\n\t} else {\n\t\tint status;\n\n\t\twhile (true) {\n\t\t\tif (waitpid(child, &status, 0) < 0) {\n\t\t\t\tif (errno == EINTR)\n\t\t\t\t\tcontinue;\n\t\t\t\tbail(\"failed to waitpid\");\n\t\t\t}\n\t\t\tif (WIFEXITED(status) || WIFSIGNALED(status))\n\t\t\t\treturn WEXITSTATUS(status);\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nstatic void update_uidmap(const char *path, int pid, char *map, size_t map_len)\n{\n\tif (map == NULL || map_len == 0)\n\t\treturn;\n\n\twrite_log(DEBUG, \"update /proc/%d/uid_map to '%s'\", pid, map);\n\tif (write_file(map, map_len, \"/proc/%d/uid_map\", pid) < 0) {\n\t\tif (errno != EPERM)\n\t\t\tbail(\"failed to update /proc/%d/uid_map\", pid);\n\t\twrite_log(DEBUG, \"update /proc/%d/uid_map got -EPERM (trying %s)\", pid, path);\n\t\tif (try_mapping_tool(path, pid, map, map_len))\n\t\t\tbail(\"failed to use newuid map on %d\", pid);\n\t}\n}\n\nstatic void update_gidmap(const char *path, int pid, char *map, size_t map_len)\n{\n\tif (map == NULL || map_len == 0)\n\t\treturn;\n\n\twrite_log(DEBUG, \"update /proc/%d/gid_map to '%s'\", pid, map);\n\tif (write_file(map, map_len, \"/proc/%d/gid_map\", pid) < 0) {\n\t\tif (errno != EPERM)\n\t\t\tbail(\"failed to update /proc/%d/gid_map\", pid);\n\t\twrite_log(DEBUG, \"update /proc/%d/gid_map got -EPERM (trying %s)\", pid, path);\n\t\tif (try_mapping_tool(path, pid, map, map_len))\n\t\t\tbail(\"failed to use newgid map on %d\", pid);\n\t}\n}\n\nstatic void update_oom_score_adj(char *data, size_t len)\n{\n\tif (data == NULL || len == 0)\n\t\treturn;\n\n\twrite_log(DEBUG, \"update /proc/self/oom_score_adj to '%s'\", data);\n\tif (write_file(data, len, \"/proc/self/oom_score_adj\") < 0)\n\t\tbail(\"failed to update /proc/self/oom_score_adj\");\n}\n\n/* A dummy function that just jumps to the given jumpval. */\nstatic int child_func(void *arg) __attribute__((noinline));\nstatic int child_func(void *arg)\n{\n\tstruct clone_t *ca = (struct clone_t *)arg;\n\tlongjmp(*ca->env, ca->jmpval);\n}\n\nstatic int clone_parent(jmp_buf *env, int jmpval) __attribute__((noinline));\nstatic int clone_parent(jmp_buf *env, int jmpval)\n{\n\tstruct clone_t ca = {\n\t\t.env = env,\n\t\t.jmpval = jmpval,\n\t};\n\n\treturn clone(child_func, ca.stack_ptr, CLONE_PARENT | SIGCHLD, &ca);\n}\n\n/*\n * Returns an environment variable value as a non-negative integer, or -ENOENT\n * if the variable was not found or has an empty value.\n *\n * If the value can not be converted to an integer, or the result is out of\n * range, the function bails out.\n */\nstatic int getenv_int(const char *name)\n{\n\tchar *val, *endptr;\n\tint ret;\n\n\tval = getenv(name);\n\t/* Treat empty value as unset variable. */\n\tif (val == NULL || *val == '\\0')\n\t\treturn -ENOENT;\n\n\tret = strtol(val, &endptr, 10);\n\tif (val == endptr || *endptr != '\\0')\n\t\tbail(\"unable to parse %s=%s\", name, val);\n\t/*\n\t * Sanity check: this must be a small non-negative number.\n\t * Practically, we pass two fds (3 and 4) and a log level,\n\t * for which the maximum is 6 (TRACE).\n\t * */\n\tif (ret < 0 || ret > TRACE)\n\t\tbail(\"bad value for %s=%s (%d)\", name, val, ret);\n\n\treturn ret;\n}\n\n/*\n * Sets up logging by getting log fd and log level from the environment,\n * if available.\n */\nstatic void setup_logpipe(void)\n{\n\tint i;\n\n\ti = getenv_int(\"_LIBCONTAINER_LOGPIPE\");\n\tif (i < 0) {\n\t\t/* We are not runc init, or log pipe was not provided. */\n\t\treturn;\n\t}\n\tlogfd = i;\n\n\ti = getenv_int(\"_LIBCONTAINER_LOGLEVEL\");\n\tif (i < 0)\n\t\treturn;\n\tloglevel = i;\n}\n\n/* Returns the clone(2) flag for a namespace, given the name of a namespace. */\nstatic int nsflag(char *name)\n{\n\tif (!strcmp(name, \"cgroup\"))\n\t\treturn CLONE_NEWCGROUP;\n\telse if (!strcmp(name, \"ipc\"))\n\t\treturn CLONE_NEWIPC;\n\telse if (!strcmp(name, \"mnt\"))\n\t\treturn CLONE_NEWNS;\n\telse if (!strcmp(name, \"net\"))\n\t\treturn CLONE_NEWNET;\n\telse if (!strcmp(name, \"pid\"))\n\t\treturn CLONE_NEWPID;\n\telse if (!strcmp(name, \"user\"))\n\t\treturn CLONE_NEWUSER;\n\telse if (!strcmp(name, \"uts\"))\n\t\treturn CLONE_NEWUTS;\n\n\t/* If we don't recognise a name, fallback to 0. */\n\treturn 0;\n}\n\nstatic uint32_t readint32(char *buf)\n{\n\treturn *(uint32_t *) buf;\n}\n\nstatic uint8_t readint8(char *buf)\n{\n\treturn *(uint8_t *) buf;\n}\n\nstatic void nl_parse(int fd, struct nlconfig_t *config)\n{\n\tsize_t len, size;\n\tstruct nlmsghdr hdr;\n\tchar *data, *current;\n\n\t/* Retrieve the netlink header. */\n\tlen = read(fd, &hdr, NLMSG_HDRLEN);\n\tif (len != NLMSG_HDRLEN)\n\t\tbail(\"invalid netlink header length %zu\", len);\n\n\tif (hdr.nlmsg_type == NLMSG_ERROR)\n\t\tbail(\"failed to read netlink message\");\n\n\tif (hdr.nlmsg_type != INIT_MSG)\n\t\tbail(\"unexpected msg type %d\", hdr.nlmsg_type);\n\n\t/* Retrieve data. */\n\tsize = NLMSG_PAYLOAD(&hdr, 0);\n\tcurrent = data = malloc(size);\n\tif (!data)\n\t\tbail(\"failed to allocate %zu bytes of memory for nl_payload\", size);\n\n\tlen = read(fd, data, size);\n\tif (len != size)\n\t\tbail(\"failed to read netlink payload, %zu != %zu\", len, size);\n\n\t/* Parse the netlink payload. */\n\tconfig->data = data;\n\twhile (current < data + size) {\n\t\tstruct nlattr *nlattr = (struct nlattr *)current;\n\t\tsize_t payload_len = nlattr->nla_len - NLA_HDRLEN;\n\n\t\t/* Advance to payload. */\n\t\tcurrent += NLA_HDRLEN;\n\n\t\t/* Handle payload. */\n\t\tswitch (nlattr->nla_type) {\n\t\tcase CLONE_FLAGS_ATTR:\n\t\t\tconfig->cloneflags = readint32(current);\n\t\t\tbreak;\n\t\tcase ROOTLESS_EUID_ATTR:\n\t\t\tconfig->is_rootless_euid = readint8(current);\t/* boolean */\n\t\t\tbreak;\n\t\tcase OOM_SCORE_ADJ_ATTR:\n\t\t\tconfig->oom_score_adj = current;\n\t\t\tconfig->oom_score_adj_len = payload_len;\n\t\t\tbreak;\n\t\tcase NS_PATHS_ATTR:\n\t\t\tconfig->namespaces = current;\n\t\t\tconfig->namespaces_len = payload_len;\n\t\t\tbreak;\n\t\tcase UIDMAP_ATTR:\n\t\t\tconfig->uidmap = current;\n\t\t\tconfig->uidmap_len = payload_len;\n\t\t\tbreak;\n\t\tcase GIDMAP_ATTR:\n\t\t\tconfig->gidmap = current;\n\t\t\tconfig->gidmap_len = payload_len;\n\t\t\tbreak;\n\t\tcase UIDMAPPATH_ATTR:\n\t\t\tconfig->uidmappath = current;\n\t\t\tconfig->uidmappath_len = payload_len;\n\t\t\tbreak;\n\t\tcase GIDMAPPATH_ATTR:\n\t\t\tconfig->gidmappath = current;\n\t\t\tconfig->gidmappath_len = payload_len;\n\t\t\tbreak;\n\t\tcase SETGROUP_ATTR:\n\t\t\tconfig->is_setgroup = readint8(current);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbail(\"unknown netlink message type %d\", nlattr->nla_type);\n\t\t}\n\n\t\tcurrent += NLA_ALIGN(payload_len);\n\t}\n}\n\nvoid nl_free(struct nlconfig_t *config)\n{\n\tfree(config->data);\n}\n\nvoid join_namespaces(char *nslist)\n{\n\tint num = 0, i;\n\tchar *saveptr = NULL;\n\tchar *namespace = strtok_r(nslist, \",\", &saveptr);\n\tstruct namespace_t {\n\t\tint fd;\n\t\tchar type[PATH_MAX];\n\t\tchar path[PATH_MAX];\n\t} *namespaces = NULL;\n\n\tif (!namespace || !strlen(namespace) || !strlen(nslist))\n\t\tbail(\"ns paths are empty\");\n\n\t/*\n\t * We have to open the file descriptors first, since after\n\t * we join the mnt namespace we might no longer be able to\n\t * access the paths.\n\t */\n\tdo {\n\t\tint fd;\n\t\tchar *path;\n\t\tstruct namespace_t *ns;\n\n\t\t/* Resize the namespace array. */\n\t\tnamespaces = realloc(namespaces, ++num * sizeof(struct namespace_t));\n\t\tif (!namespaces)\n\t\t\tbail(\"failed to reallocate namespace array\");\n\t\tns = &namespaces[num - 1];\n\n\t\t/* Split 'ns:path'. */\n\t\tpath = strstr(namespace, \":\");\n\t\tif (!path)\n\t\t\tbail(\"failed to parse %s\", namespace);\n\t\t*path++ = '\\0';\n\n\t\tfd = open(path, O_RDONLY);\n\t\tif (fd < 0)\n\t\t\tbail(\"failed to open %s\", path);\n\n\t\tns->fd = fd;\n\t\tstrncpy(ns->type, namespace, PATH_MAX - 1);\n\t\tstrncpy(ns->path, path, PATH_MAX - 1);\n\t\tns->path[PATH_MAX - 1] = '\\0';\n\t} while ((namespace = strtok_r(NULL, \",\", &saveptr)) != NULL);\n\n\t/*\n\t * The ordering in which we join namespaces is important. We should\n\t * always join the user namespace *first*. This is all guaranteed\n\t * from the container_linux.go side of this, so we're just going to\n\t * follow the order given to us.\n\t */\n\n\tfor (i = 0; i < num; i++) {\n\t\tstruct namespace_t *ns = &namespaces[i];\n\t\tint flag = nsflag(ns->type);\n\n\t\twrite_log(DEBUG, \"setns(%#x) into %s namespace (with path %s)\", flag, ns->type, ns->path);\n\t\tif (setns(ns->fd, flag) < 0)\n\t\t\tbail(\"failed to setns into %s namespace\", ns->type);\n\n\t\tclose(ns->fd);\n\t}\n\n\tfree(namespaces);\n}\n\n/* Defined in cloned_binary.c. */\nextern int ensure_cloned_binary(void);\n\nstatic inline int sane_kill(pid_t pid, int signum)\n{\n\tif (pid > 0)\n\t\treturn kill(pid, signum);\n\telse\n\t\treturn 0;\n}\n\nvoid nsexec(void)\n{\n\tint pipenum;\n\tjmp_buf env;\n\tint sync_child_pipe[2], sync_grandchild_pipe[2];\n\tstruct nlconfig_t config = { 0 };\n\n\t/*\n\t * Setup a pipe to send logs to the parent. This should happen\n\t * first, because bail will use that pipe.\n\t */\n\tsetup_logpipe();\n\n\t/*\n\t * Get the init pipe fd from the environment. The init pipe is used to\n\t * read the bootstrap data and tell the parent what the new pids are\n\t * after the setup is done.\n\t */\n\tpipenum = getenv_int(\"_LIBCONTAINER_INITPIPE\");\n\tif (pipenum < 0) {\n\t\t/* We are not a runc init. Just return to go runtime. */\n\t\treturn;\n\t}\n\n\t/*\n\t * We need to re-exec if we are not in a cloned binary. This is necessary\n\t * to ensure that containers won't be able to access the host binary\n\t * through /proc/self/exe. See CVE-2019-5736.\n\t */\n\tif (ensure_cloned_binary() < 0)\n\t\tbail(\"could not ensure we are a cloned binary\");\n\n\t/*\n\t * Inform the parent we're past initial setup.\n\t * For the other side of this, see initWaiter.\n\t */\n\tif (write(pipenum, \"\", 1) != 1)\n\t\tbail(\"could not inform the parent we are past initial setup\");\n\n\twrite_log(DEBUG, \"=> nsexec container setup\");\n\n\t/* Parse all of the netlink configuration. */\n\tnl_parse(pipenum, &config);\n\n\t/* Set oom_score_adj. This has to be done before !dumpable because\n\t * /proc/self/oom_score_adj is not writeable unless you're an privileged\n\t * user (if !dumpable is set). All children inherit their parent's\n\t * oom_score_adj value on fork(2) so this will always be propagated\n\t * properly.\n\t */\n\tupdate_oom_score_adj(config.oom_score_adj, config.oom_score_adj_len);\n\n\t/*\n\t * Make the process non-dumpable, to avoid various race conditions that\n\t * could cause processes in namespaces we're joining to access host\n\t * resources (or potentially execute code).\n\t *\n\t * However, if the number of namespaces we are joining is 0, we are not\n\t * going to be switching to a different security context. Thus setting\n\t * ourselves to be non-dumpable only breaks things (like rootless\n\t * containers), which is the recommendation from the kernel folks.\n\t */\n\tif (config.namespaces) {\n\t\twrite_log(DEBUG, \"set process as non-dumpable\");\n\t\tif (prctl(PR_SET_DUMPABLE, 0, 0, 0, 0) < 0)\n\t\t\tbail(\"failed to set process as non-dumpable\");\n\t}\n\n\t/* Pipe so we can tell the child when we've finished setting up. */\n\tif (socketpair(AF_LOCAL, SOCK_STREAM, 0, sync_child_pipe) < 0)\n\t\tbail(\"failed to setup sync pipe between parent and child\");\n\n\t/*\n\t * We need a new socketpair to sync with grandchild so we don't have\n\t * race condition with child.\n\t */\n\tif (socketpair(AF_LOCAL, SOCK_STREAM, 0, sync_grandchild_pipe) < 0)\n\t\tbail(\"failed to setup sync pipe between parent and grandchild\");\n\n\t/* TODO: Currently we aren't dealing with child deaths properly. */\n\n\t/*\n\t * Okay, so this is quite annoying.\n\t *\n\t * In order for this unsharing code to be more extensible we need to split\n\t * up unshare(CLONE_NEWUSER) and clone() in various ways. The ideal case\n\t * would be if we did clone(CLONE_NEWUSER) and the other namespaces\n\t * separately, but because of SELinux issues we cannot really do that. But\n\t * we cannot just dump the namespace flags into clone(...) because several\n\t * usecases (such as rootless containers) require more granularity around\n\t * the namespace setup. In addition, some older kernels had issues where\n\t * CLONE_NEWUSER wasn't handled before other namespaces (but we cannot\n\t * handle this while also dealing with SELinux so we choose SELinux support\n\t * over broken kernel support).\n\t *\n\t * However, if we unshare(2) the user namespace *before* we clone(2), then\n\t * all hell breaks loose.\n\t *\n\t * The parent no longer has permissions to do many things (unshare(2) drops\n\t * all capabilities in your old namespace), and the container cannot be set\n\t * up to have more than one {uid,gid} mapping. This is obviously less than\n\t * ideal. In order to fix this, we have to first clone(2) and then unshare.\n\t *\n\t * Unfortunately, it's not as simple as that. We have to fork to enter the\n\t * PID namespace (the PID namespace only applies to children). Since we'll\n\t * have to double-fork, this clone_parent() call won't be able to get the\n\t * PID of the _actual_ init process (without doing more synchronisation than\n\t * I can deal with at the moment). So we'll just get the parent to send it\n\t * for us, the only job of this process is to update\n\t * /proc/pid/{setgroups,uid_map,gid_map}.\n\t *\n\t * And as a result of the above, we also need to setns(2) in the first child\n\t * because if we join a PID namespace in the topmost parent then our child\n\t * will be in that namespace (and it will not be able to give us a PID value\n\t * that makes sense without resorting to sending things with cmsg).\n\t *\n\t * This also deals with an older issue caused by dumping cloneflags into\n\t * clone(2): On old kernels, CLONE_PARENT didn't work with CLONE_NEWPID, so\n\t * we have to unshare(2) before clone(2) in order to do this. This was fixed\n\t * in upstream commit 1f7f4dde5c945f41a7abc2285be43d918029ecc5, and was\n\t * introduced by 40a0d32d1eaffe6aac7324ca92604b6b3977eb0e. As far as we're\n\t * aware, the last mainline kernel which had this bug was Linux 3.12.\n\t * However, we cannot comment on which kernels the broken patch was\n\t * backported to.\n\t *\n\t * -- Aleksa \"what has my life come to?\" Sarai\n\t */\n\n\tcurrent_stage = setjmp(env);\n\tswitch (current_stage) {\n\t\t/*\n\t\t * Stage 0: We're in the parent. Our job is just to create a new child\n\t\t *          (stage 1: STAGE_CHILD) process and write its uid_map and\n\t\t *          gid_map. That process will go on to create a new process, then\n\t\t *          it will send us its PID which we will send to the bootstrap\n\t\t *          process.\n\t\t */\n\tcase STAGE_PARENT:{\n\t\t\tint len;\n\t\t\tpid_t stage1_pid = -1, stage2_pid = -1;\n\t\t\tbool stage1_complete, stage2_complete;\n\n\t\t\t/* For debugging. */\n\t\t\tprctl(PR_SET_NAME, (unsigned long)\"runc:[0:PARENT]\", 0, 0, 0);\n\t\t\twrite_log(DEBUG, \"~> nsexec stage-0\");\n\n\t\t\t/* Start the process of getting a container. */\n\t\t\twrite_log(DEBUG, \"spawn stage-1\");\n\t\t\tstage1_pid = clone_parent(&env, STAGE_CHILD);\n\t\t\tif (stage1_pid < 0)\n\t\t\t\tbail(\"unable to spawn stage-1\");\n\n\t\t\tsyncfd = sync_child_pipe[1];\n\t\t\tif (close(sync_child_pipe[0]) < 0)\n\t\t\t\tbail(\"failed to close sync_child_pipe[0] fd\");\n\n\t\t\t/*\n\t\t\t * State machine for synchronisation with the children. We only\n\t\t\t * return once both the child and grandchild are ready.\n\t\t\t */\n\t\t\twrite_log(DEBUG, \"-> stage-1 synchronisation loop\");\n\t\t\tstage1_complete = false;\n\t\t\twhile (!stage1_complete) {\n\t\t\t\tenum sync_t s;\n\n\t\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with stage-1: next state\");\n\n\t\t\t\tswitch (s) {\n\t\t\t\tcase SYNC_USERMAP_PLS:\n\t\t\t\t\twrite_log(DEBUG, \"stage-1 requested userns mappings\");\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Enable setgroups(2) if we've been asked to. But we also\n\t\t\t\t\t * have to explicitly disable setgroups(2) if we're\n\t\t\t\t\t * creating a rootless container for single-entry mapping.\n\t\t\t\t\t * i.e. config.is_setgroup == false.\n\t\t\t\t\t * (this is required since Linux 3.19).\n\t\t\t\t\t *\n\t\t\t\t\t * For rootless multi-entry mapping, config.is_setgroup shall be true and\n\t\t\t\t\t * newuidmap/newgidmap shall be used.\n\t\t\t\t\t */\n\t\t\t\t\tif (config.is_rootless_euid && !config.is_setgroup)\n\t\t\t\t\t\tupdate_setgroups(stage1_pid, SETGROUPS_DENY);\n\n\t\t\t\t\t/* Set up mappings. */\n\t\t\t\t\tupdate_uidmap(config.uidmappath, stage1_pid, config.uidmap, config.uidmap_len);\n\t\t\t\t\tupdate_gidmap(config.gidmappath, stage1_pid, config.gidmap, config.gidmap_len);\n\n\t\t\t\t\ts = SYNC_USERMAP_ACK;\n\t\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\t\t\tsane_kill(stage1_pid, SIGKILL);\n\t\t\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\t\t\tbail(\"failed to sync with stage-1: write(SYNC_USERMAP_ACK)\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SYNC_RECVPID_PLS:\n\t\t\t\t\twrite_log(DEBUG, \"stage-1 requested pid to be forwarded\");\n\n\t\t\t\t\t/* Get the stage-2 pid. */\n\t\t\t\t\tif (read(syncfd, &stage2_pid, sizeof(stage2_pid)) != sizeof(stage2_pid)) {\n\t\t\t\t\t\tsane_kill(stage1_pid, SIGKILL);\n\t\t\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\t\t\tbail(\"failed to sync with stage-1: read(stage2_pid)\");\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Send ACK. */\n\t\t\t\t\ts = SYNC_RECVPID_ACK;\n\t\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\t\t\tsane_kill(stage1_pid, SIGKILL);\n\t\t\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\t\t\tbail(\"failed to sync with stage-1: write(SYNC_RECVPID_ACK)\");\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Send both the stage-1 and stage-2 pids back to runc.\n\t\t\t\t\t * runc needs the stage-2 to continue process management,\n\t\t\t\t\t * but because stage-1 was spawned with CLONE_PARENT we\n\t\t\t\t\t * cannot reap it within stage-0 and thus we need to ask\n\t\t\t\t\t * runc to reap the zombie for us.\n\t\t\t\t\t */\n\t\t\t\t\twrite_log(DEBUG, \"forward stage-1 (%d) and stage-2 (%d) pids to runc\",\n\t\t\t\t\t\t  stage1_pid, stage2_pid);\n\t\t\t\t\tlen =\n\t\t\t\t\t    dprintf(pipenum, \"{\\\"stage1_pid\\\":%d,\\\"stage2_pid\\\":%d}\\n\", stage1_pid,\n\t\t\t\t\t\t    stage2_pid);\n\t\t\t\t\tif (len < 0) {\n\t\t\t\t\t\tsane_kill(stage1_pid, SIGKILL);\n\t\t\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\t\t\tbail(\"failed to sync with runc: write(pid-JSON)\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SYNC_CHILD_FINISH:\n\t\t\t\t\twrite_log(DEBUG, \"stage-1 complete\");\n\t\t\t\t\tstage1_complete = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbail(\"unexpected sync value: %u\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\twrite_log(DEBUG, \"<- stage-1 synchronisation loop\");\n\n\t\t\t/* Now sync with grandchild. */\n\t\t\tsyncfd = sync_grandchild_pipe[1];\n\t\t\tif (close(sync_grandchild_pipe[0]) < 0)\n\t\t\t\tbail(\"failed to close sync_grandchild_pipe[0] fd\");\n\n\t\t\twrite_log(DEBUG, \"-> stage-2 synchronisation loop\");\n\t\t\tstage2_complete = false;\n\t\t\twhile (!stage2_complete) {\n\t\t\t\tenum sync_t s;\n\n\t\t\t\twrite_log(DEBUG, \"signalling stage-2 to run\");\n\t\t\t\ts = SYNC_GRANDCHILD;\n\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\t\tbail(\"failed to sync with child: write(SYNC_GRANDCHILD)\");\n\t\t\t\t}\n\n\t\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with child: next state\");\n\n\t\t\t\tswitch (s) {\n\t\t\t\tcase SYNC_CHILD_FINISH:\n\t\t\t\t\twrite_log(DEBUG, \"stage-2 complete\");\n\t\t\t\t\tstage2_complete = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbail(\"unexpected sync value: %u\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\twrite_log(DEBUG, \"<- stage-2 synchronisation loop\");\n\t\t\twrite_log(DEBUG, \"<~ nsexec stage-0\");\n\t\t\texit(0);\n\t\t}\n\t\tbreak;\n\n\t\t/*\n\t\t * Stage 1: We're in the first child process. Our job is to join any\n\t\t *          provided namespaces in the netlink payload and unshare all of\n\t\t *          the requested namespaces. If we've been asked to CLONE_NEWUSER,\n\t\t *          we will ask our parent (stage 0) to set up our user mappings\n\t\t *          for us. Then, we create a new child (stage 2: STAGE_INIT) for\n\t\t *          PID namespace. We then send the child's PID to our parent\n\t\t *          (stage 0).\n\t\t */\n\tcase STAGE_CHILD:{\n\t\t\tpid_t stage2_pid = -1;\n\t\t\tenum sync_t s;\n\n\t\t\t/* We're in a child and thus need to tell the parent if we die. */\n\t\t\tsyncfd = sync_child_pipe[0];\n\t\t\tif (close(sync_child_pipe[1]) < 0)\n\t\t\t\tbail(\"failed to close sync_child_pipe[1] fd\");\n\n\t\t\t/* For debugging. */\n\t\t\tprctl(PR_SET_NAME, (unsigned long)\"runc:[1:CHILD]\", 0, 0, 0);\n\t\t\twrite_log(DEBUG, \"~> nsexec stage-1\");\n\n\t\t\t/*\n\t\t\t * We need to setns first. We cannot do this earlier (in stage 0)\n\t\t\t * because of the fact that we forked to get here (the PID of\n\t\t\t * [stage 2: STAGE_INIT]) would be meaningless). We could send it\n\t\t\t * using cmsg(3) but that's just annoying.\n\t\t\t */\n\t\t\tif (config.namespaces)\n\t\t\t\tjoin_namespaces(config.namespaces);\n\n\t\t\t/*\n\t\t\t * Deal with user namespaces first. They are quite special, as they\n\t\t\t * affect our ability to unshare other namespaces and are used as\n\t\t\t * context for privilege checks.\n\t\t\t *\n\t\t\t * We don't unshare all namespaces in one go. The reason for this\n\t\t\t * is that, while the kernel documentation may claim otherwise,\n\t\t\t * there are certain cases where unsharing all namespaces at once\n\t\t\t * will result in namespace objects being owned incorrectly.\n\t\t\t * Ideally we should just fix these kernel bugs, but it's better to\n\t\t\t * be safe than sorry, and fix them separately.\n\t\t\t *\n\t\t\t * A specific case of this is that the SELinux label of the\n\t\t\t * internal kern-mount that mqueue uses will be incorrect if the\n\t\t\t * UTS namespace is cloned before the USER namespace is mapped.\n\t\t\t * I've also heard of similar problems with the network namespace\n\t\t\t * in some scenarios. This also mirrors how LXC deals with this\n\t\t\t * problem.\n\t\t\t */\n\t\t\tif (config.cloneflags & CLONE_NEWUSER) {\n\t\t\t\twrite_log(DEBUG, \"unshare user namespace\");\n\t\t\t\tif (unshare(CLONE_NEWUSER) < 0)\n\t\t\t\t\tbail(\"failed to unshare user namespace\");\n\t\t\t\tconfig.cloneflags &= ~CLONE_NEWUSER;\n\n\t\t\t\t/*\n\t\t\t\t * We need to set ourselves as dumpable temporarily so that the\n\t\t\t\t * parent process can write to our procfs files.\n\t\t\t\t */\n\t\t\t\tif (config.namespaces) {\n\t\t\t\t\twrite_log(DEBUG, \"temporarily set process as dumpable\");\n\t\t\t\t\tif (prctl(PR_SET_DUMPABLE, 1, 0, 0, 0) < 0)\n\t\t\t\t\t\tbail(\"failed to temporarily set process as dumpable\");\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * We don't have the privileges to do any mapping here (see the\n\t\t\t\t * clone_parent rant). So signal stage-0 to do the mapping for\n\t\t\t\t * us.\n\t\t\t\t */\n\t\t\t\twrite_log(DEBUG, \"request stage-0 to map user namespace\");\n\t\t\t\ts = SYNC_USERMAP_PLS;\n\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with parent: write(SYNC_USERMAP_PLS)\");\n\n\t\t\t\t/* ... wait for mapping ... */\n\t\t\t\twrite_log(DEBUG, \"request stage-0 to map user namespace\");\n\t\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with parent: read(SYNC_USERMAP_ACK)\");\n\t\t\t\tif (s != SYNC_USERMAP_ACK)\n\t\t\t\t\tbail(\"failed to sync with parent: SYNC_USERMAP_ACK: got %u\", s);\n\n\t\t\t\t/* Revert temporary re-dumpable setting. */\n\t\t\t\tif (config.namespaces) {\n\t\t\t\t\twrite_log(DEBUG, \"re-set process as non-dumpable\");\n\t\t\t\t\tif (prctl(PR_SET_DUMPABLE, 0, 0, 0, 0) < 0)\n\t\t\t\t\t\tbail(\"failed to re-set process as non-dumpable\");\n\t\t\t\t}\n\n\t\t\t\t/* Become root in the namespace proper. */\n\t\t\t\tif (setresuid(0, 0, 0) < 0)\n\t\t\t\t\tbail(\"failed to become root in user namespace\");\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Unshare all of the namespaces. Now, it should be noted that this\n\t\t\t * ordering might break in the future (especially with rootless\n\t\t\t * containers). But for now, it's not possible to split this into\n\t\t\t * CLONE_NEWUSER + [the rest] because of some RHEL SELinux issues.\n\t\t\t *\n\t\t\t * Note that we don't merge this with clone() because there were\n\t\t\t * some old kernel versions where clone(CLONE_PARENT | CLONE_NEWPID)\n\t\t\t * was broken, so we'll just do it the long way anyway.\n\t\t\t */\n\t\t\twrite_log(DEBUG, \"unshare remaining namespace (except cgroupns)\");\n\t\t\tif (unshare(config.cloneflags & ~CLONE_NEWCGROUP) < 0)\n\t\t\t\tbail(\"failed to unshare remaining namespaces (except cgroupns)\");\n\n\t\t\t/*\n\t\t\t * TODO: What about non-namespace clone flags that we're dropping here?\n\t\t\t *\n\t\t\t * We fork again because of PID namespace, setns(2) or unshare(2) don't\n\t\t\t * change the PID namespace of the calling process, because doing so\n\t\t\t * would change the caller's idea of its own PID (as reported by getpid()),\n\t\t\t * which would break many applications and libraries, so we must fork\n\t\t\t * to actually enter the new PID namespace.\n\t\t\t */\n\t\t\twrite_log(DEBUG, \"spawn stage-2\");\n\t\t\tstage2_pid = clone_parent(&env, STAGE_INIT);\n\t\t\tif (stage2_pid < 0)\n\t\t\t\tbail(\"unable to spawn stage-2\");\n\n\t\t\t/* Send the child to our parent, which knows what it's doing. */\n\t\t\twrite_log(DEBUG, \"request stage-0 to forward stage-2 pid (%d)\", stage2_pid);\n\t\t\ts = SYNC_RECVPID_PLS;\n\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: write(SYNC_RECVPID_PLS)\");\n\t\t\t}\n\t\t\tif (write(syncfd, &stage2_pid, sizeof(stage2_pid)) != sizeof(stage2_pid)) {\n\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: write(stage2_pid)\");\n\t\t\t}\n\n\t\t\t/* ... wait for parent to get the pid ... */\n\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: read(SYNC_RECVPID_ACK)\");\n\t\t\t}\n\t\t\tif (s != SYNC_RECVPID_ACK) {\n\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: SYNC_RECVPID_ACK: got %u\", s);\n\t\t\t}\n\n\t\t\twrite_log(DEBUG, \"signal completion to stage-0\");\n\t\t\ts = SYNC_CHILD_FINISH;\n\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: write(SYNC_CHILD_FINISH)\");\n\t\t\t}\n\n\t\t\t/* Our work is done. [Stage 2: STAGE_INIT] is doing the rest of the work. */\n\t\t\twrite_log(DEBUG, \"<~ nsexec stage-1\");\n\t\t\texit(0);\n\t\t}\n\t\tbreak;\n\n\t\t/*\n\t\t * Stage 2: We're the final child process, and the only process that will\n\t\t *          actually return to the Go runtime. Our job is to just do the\n\t\t *          final cleanup steps and then return to the Go runtime to allow\n\t\t *          init_linux.go to run.\n\t\t */\n\tcase STAGE_INIT:{\n\t\t\t/*\n\t\t\t * We're inside the child now, having jumped from the\n\t\t\t * start_child() code after forking in the parent.\n\t\t\t */\n\t\t\tenum sync_t s;\n\n\t\t\t/* We're in a child and thus need to tell the parent if we die. */\n\t\t\tsyncfd = sync_grandchild_pipe[0];\n\t\t\tif (close(sync_grandchild_pipe[1]) < 0)\n\t\t\t\tbail(\"failed to close sync_grandchild_pipe[1] fd\");\n\n\t\t\tif (close(sync_child_pipe[0]) < 0)\n\t\t\t\tbail(\"failed to close sync_child_pipe[0] fd\");\n\n\t\t\t/* For debugging. */\n\t\t\tprctl(PR_SET_NAME, (unsigned long)\"runc:[2:INIT]\", 0, 0, 0);\n\t\t\twrite_log(DEBUG, \"~> nsexec stage-2\");\n\n\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\tbail(\"failed to sync with parent: read(SYNC_GRANDCHILD)\");\n\t\t\tif (s != SYNC_GRANDCHILD)\n\t\t\t\tbail(\"failed to sync with parent: SYNC_GRANDCHILD: got %u\", s);\n\n\t\t\tif (setsid() < 0)\n\t\t\t\tbail(\"setsid failed\");\n\n\t\t\tif (setuid(0) < 0)\n\t\t\t\tbail(\"setuid failed\");\n\n\t\t\tif (setgid(0) < 0)\n\t\t\t\tbail(\"setgid failed\");\n\n\t\t\tif (!config.is_rootless_euid && config.is_setgroup) {\n\t\t\t\tif (setgroups(0, NULL) < 0)\n\t\t\t\t\tbail(\"setgroups failed\");\n\t\t\t}\n\n\t\t\tif (config.cloneflags & CLONE_NEWCGROUP) {\n\t\t\t\tif (unshare(CLONE_NEWCGROUP) < 0)\n\t\t\t\t\tbail(\"failed to unshare cgroup namespace\");\n\t\t\t}\n\n\t\t\twrite_log(DEBUG, \"signal completion to stage-0\");\n\t\t\ts = SYNC_CHILD_FINISH;\n\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\tbail(\"failed to sync with parent: write(SYNC_CHILD_FINISH)\");\n\n\t\t\t/* Close sync pipes. */\n\t\t\tif (close(sync_grandchild_pipe[0]) < 0)\n\t\t\t\tbail(\"failed to close sync_grandchild_pipe[0] fd\");\n\n\t\t\t/* Free netlink data. */\n\t\t\tnl_free(&config);\n\n\t\t\t/* Finish executing, let the Go runtime take over. */\n\t\t\twrite_log(DEBUG, \"<= nsexec container setup\");\n\t\t\twrite_log(DEBUG, \"booting up go runtime ...\");\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbail(\"unknown stage '%d' for jump value\", current_stage);\n\t}\n\n\t/* Should never be reached. */\n\tbail(\"should never be reached\");\n}\n", "package libcontainer\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\tsecurejoin \"github.com/cyphar/filepath-securejoin\"\n\t\"github.com/moby/sys/mountinfo\"\n\t\"github.com/mrunalp/fileutils\"\n\t\"github.com/opencontainers/runc/libcontainer/cgroups\"\n\t\"github.com/opencontainers/runc/libcontainer/cgroups/fs2\"\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/opencontainers/runc/libcontainer/devices\"\n\t\"github.com/opencontainers/runc/libcontainer/userns\"\n\t\"github.com/opencontainers/runc/libcontainer/utils\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/opencontainers/selinux/go-selinux/label\"\n\t\"github.com/sirupsen/logrus\"\n\t\"golang.org/x/sys/unix\"\n)\n\nconst defaultMountFlags = unix.MS_NOEXEC | unix.MS_NOSUID | unix.MS_NODEV\n\ntype mountConfig struct {\n\troot            string\n\tlabel           string\n\tcgroup2Path     string\n\trootlessCgroups bool\n\tcgroupns        bool\n}\n\n// needsSetupDev returns true if /dev needs to be set up.\nfunc needsSetupDev(config *configs.Config) bool {\n\tfor _, m := range config.Mounts {\n\t\tif m.Device == \"bind\" && utils.CleanPath(m.Destination) == \"/dev\" {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// prepareRootfs sets up the devices, mount points, and filesystems for use\n// inside a new mount namespace. It doesn't set anything as ro. You must call\n// finalizeRootfs after this function to finish setting up the rootfs.\nfunc prepareRootfs(pipe io.ReadWriter, iConfig *initConfig) (err error) {\n\tconfig := iConfig.Config\n\tif err := prepareRoot(config); err != nil {\n\t\treturn fmt.Errorf(\"error preparing rootfs: %w\", err)\n\t}\n\n\tmountConfig := &mountConfig{\n\t\troot:            config.Rootfs,\n\t\tlabel:           config.MountLabel,\n\t\tcgroup2Path:     iConfig.Cgroup2Path,\n\t\trootlessCgroups: iConfig.RootlessCgroups,\n\t\tcgroupns:        config.Namespaces.Contains(configs.NEWCGROUP),\n\t}\n\tsetupDev := needsSetupDev(config)\n\tfor _, m := range config.Mounts {\n\t\tfor _, precmd := range m.PremountCmds {\n\t\t\tif err := mountCmd(precmd); err != nil {\n\t\t\t\treturn fmt.Errorf(\"error running premount command: %w\", err)\n\t\t\t}\n\t\t}\n\t\tif err := mountToRootfs(m, mountConfig); err != nil {\n\t\t\treturn fmt.Errorf(\"error mounting %q to rootfs at %q: %w\", m.Source, m.Destination, err)\n\t\t}\n\n\t\tfor _, postcmd := range m.PostmountCmds {\n\t\t\tif err := mountCmd(postcmd); err != nil {\n\t\t\t\treturn fmt.Errorf(\"error running postmount command: %w\", err)\n\t\t\t}\n\t\t}\n\t}\n\n\tif setupDev {\n\t\tif err := createDevices(config); err != nil {\n\t\t\treturn fmt.Errorf(\"error creating device nodes: %w\", err)\n\t\t}\n\t\tif err := setupPtmx(config); err != nil {\n\t\t\treturn fmt.Errorf(\"error setting up ptmx: %w\", err)\n\t\t}\n\t\tif err := setupDevSymlinks(config.Rootfs); err != nil {\n\t\t\treturn fmt.Errorf(\"error setting up /dev symlinks: %w\", err)\n\t\t}\n\t}\n\n\t// Signal the parent to run the pre-start hooks.\n\t// The hooks are run after the mounts are setup, but before we switch to the new\n\t// root, so that the old root is still available in the hooks for any mount\n\t// manipulations.\n\t// Note that iConfig.Cwd is not guaranteed to exist here.\n\tif err := syncParentHooks(pipe); err != nil {\n\t\treturn err\n\t}\n\n\t// The reason these operations are done here rather than in finalizeRootfs\n\t// is because the console-handling code gets quite sticky if we have to set\n\t// up the console before doing the pivot_root(2). This is because the\n\t// Console API has to also work with the ExecIn case, which means that the\n\t// API must be able to deal with being inside as well as outside the\n\t// container. It's just cleaner to do this here (at the expense of the\n\t// operation not being perfectly split).\n\n\tif err := unix.Chdir(config.Rootfs); err != nil {\n\t\treturn &os.PathError{Op: \"chdir\", Path: config.Rootfs, Err: err}\n\t}\n\n\ts := iConfig.SpecState\n\ts.Pid = unix.Getpid()\n\ts.Status = specs.StateCreating\n\tif err := iConfig.Config.Hooks[configs.CreateContainer].RunHooks(s); err != nil {\n\t\treturn err\n\t}\n\n\tif config.NoPivotRoot {\n\t\terr = msMoveRoot(config.Rootfs)\n\t} else if config.Namespaces.Contains(configs.NEWNS) {\n\t\terr = pivotRoot(config.Rootfs)\n\t} else {\n\t\terr = chroot()\n\t}\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error jailing process inside rootfs: %w\", err)\n\t}\n\n\tif setupDev {\n\t\tif err := reOpenDevNull(); err != nil {\n\t\t\treturn fmt.Errorf(\"error reopening /dev/null inside container: %w\", err)\n\t\t}\n\t}\n\n\tif cwd := iConfig.Cwd; cwd != \"\" {\n\t\t// Note that spec.Process.Cwd can contain unclean value like  \"../../../../foo/bar...\".\n\t\t// However, we are safe to call MkDirAll directly because we are in the jail here.\n\t\tif err := os.MkdirAll(cwd, 0o755); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// finalizeRootfs sets anything to ro if necessary. You must call\n// prepareRootfs first.\nfunc finalizeRootfs(config *configs.Config) (err error) {\n\t// remount dev as ro if specified\n\tfor _, m := range config.Mounts {\n\t\tif utils.CleanPath(m.Destination) == \"/dev\" {\n\t\t\tif m.Flags&unix.MS_RDONLY == unix.MS_RDONLY {\n\t\t\t\tif err := remountReadonly(m); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// set rootfs ( / ) as readonly\n\tif config.Readonlyfs {\n\t\tif err := setReadonly(); err != nil {\n\t\t\treturn fmt.Errorf(\"error setting rootfs as readonly: %w\", err)\n\t\t}\n\t}\n\n\tif config.Umask != nil {\n\t\tunix.Umask(int(*config.Umask))\n\t} else {\n\t\tunix.Umask(0o022)\n\t}\n\treturn nil\n}\n\n// /tmp has to be mounted as private to allow MS_MOVE to work in all situations\nfunc prepareTmp(topTmpDir string) (string, error) {\n\ttmpdir, err := ioutil.TempDir(topTmpDir, \"runctop\")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := mount(tmpdir, tmpdir, \"\", \"bind\", unix.MS_BIND, \"\"); err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := mount(\"\", tmpdir, \"\", \"\", uintptr(unix.MS_PRIVATE), \"\"); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn tmpdir, nil\n}\n\nfunc cleanupTmp(tmpdir string) {\n\t_ = unix.Unmount(tmpdir, 0)\n\t_ = os.RemoveAll(tmpdir)\n}\n\nfunc mountCmd(cmd configs.Command) error {\n\tcommand := exec.Command(cmd.Path, cmd.Args[:]...)\n\tcommand.Env = cmd.Env\n\tcommand.Dir = cmd.Dir\n\tif out, err := command.CombinedOutput(); err != nil {\n\t\treturn fmt.Errorf(\"%#v failed: %s: %w\", cmd, string(out), err)\n\t}\n\treturn nil\n}\n\nfunc prepareBindMount(m *configs.Mount, rootfs string) error {\n\tstat, err := os.Stat(m.Source)\n\tif err != nil {\n\t\t// error out if the source of a bind mount does not exist as we will be\n\t\t// unable to bind anything to it.\n\t\treturn err\n\t}\n\t// ensure that the destination of the bind mount is resolved of symlinks at mount time because\n\t// any previous mounts can invalidate the next mount's destination.\n\t// this can happen when a user specifies mounts within other mounts to cause breakouts or other\n\t// evil stuff to try to escape the container's rootfs.\n\tvar dest string\n\tif dest, err = securejoin.SecureJoin(rootfs, m.Destination); err != nil {\n\t\treturn err\n\t}\n\tif err := checkProcMount(rootfs, dest, m.Source); err != nil {\n\t\treturn err\n\t}\n\tif err := createIfNotExists(dest, stat.IsDir()); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc mountCgroupV1(m *configs.Mount, c *mountConfig) error {\n\tbinds, err := getCgroupMounts(m)\n\tif err != nil {\n\t\treturn err\n\t}\n\tvar merged []string\n\tfor _, b := range binds {\n\t\tss := filepath.Base(b.Destination)\n\t\tif strings.Contains(ss, \",\") {\n\t\t\tmerged = append(merged, ss)\n\t\t}\n\t}\n\ttmpfs := &configs.Mount{\n\t\tSource:           \"tmpfs\",\n\t\tDevice:           \"tmpfs\",\n\t\tDestination:      m.Destination,\n\t\tFlags:            defaultMountFlags,\n\t\tData:             \"mode=755\",\n\t\tPropagationFlags: m.PropagationFlags,\n\t}\n\tif err := mountToRootfs(tmpfs, c); err != nil {\n\t\treturn err\n\t}\n\tfor _, b := range binds {\n\t\tif c.cgroupns {\n\t\t\tsubsystemPath := filepath.Join(c.root, b.Destination)\n\t\t\tif err := os.MkdirAll(subsystemPath, 0o755); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := utils.WithProcfd(c.root, b.Destination, func(procfd string) error {\n\t\t\t\tflags := defaultMountFlags\n\t\t\t\tif m.Flags&unix.MS_RDONLY != 0 {\n\t\t\t\t\tflags = flags | unix.MS_RDONLY\n\t\t\t\t}\n\t\t\t\tvar (\n\t\t\t\t\tsource = \"cgroup\"\n\t\t\t\t\tdata   = filepath.Base(subsystemPath)\n\t\t\t\t)\n\t\t\t\tif data == \"systemd\" {\n\t\t\t\t\tdata = cgroups.CgroupNamePrefix + data\n\t\t\t\t\tsource = \"systemd\"\n\t\t\t\t}\n\t\t\t\treturn mount(source, b.Destination, procfd, \"cgroup\", uintptr(flags), data)\n\t\t\t}); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\tif err := mountToRootfs(b, c); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\tfor _, mc := range merged {\n\t\tfor _, ss := range strings.Split(mc, \",\") {\n\t\t\t// symlink(2) is very dumb, it will just shove the path into\n\t\t\t// the link and doesn't do any checks or relative path\n\t\t\t// conversion. Also, don't error out if the cgroup already exists.\n\t\t\tif err := os.Symlink(mc, filepath.Join(c.root, m.Destination, ss)); err != nil && !os.IsExist(err) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc mountCgroupV2(m *configs.Mount, c *mountConfig) error {\n\tdest, err := securejoin.SecureJoin(c.root, m.Destination)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := os.MkdirAll(dest, 0o755); err != nil {\n\t\treturn err\n\t}\n\treturn utils.WithProcfd(c.root, m.Destination, func(procfd string) error {\n\t\tif err := mount(m.Source, m.Destination, procfd, \"cgroup2\", uintptr(m.Flags), m.Data); err != nil {\n\t\t\t// when we are in UserNS but CgroupNS is not unshared, we cannot mount cgroup2 (#2158)\n\t\t\tif errors.Is(err, unix.EPERM) || errors.Is(err, unix.EBUSY) {\n\t\t\t\tsrc := fs2.UnifiedMountpoint\n\t\t\t\tif c.cgroupns && c.cgroup2Path != \"\" {\n\t\t\t\t\t// Emulate cgroupns by bind-mounting\n\t\t\t\t\t// the container cgroup path rather than\n\t\t\t\t\t// the whole /sys/fs/cgroup.\n\t\t\t\t\tsrc = c.cgroup2Path\n\t\t\t\t}\n\t\t\t\terr = mount(src, m.Destination, procfd, \"\", uintptr(m.Flags)|unix.MS_BIND, \"\")\n\t\t\t\tif c.rootlessCgroups && errors.Is(err, unix.ENOENT) {\n\t\t\t\t\terr = nil\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc doTmpfsCopyUp(m *configs.Mount, rootfs, mountLabel string) (Err error) {\n\t// Set up a scratch dir for the tmpfs on the host.\n\ttmpdir, err := prepareTmp(\"/tmp\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"tmpcopyup: failed to setup tmpdir: %w\", err)\n\t}\n\tdefer cleanupTmp(tmpdir)\n\ttmpDir, err := ioutil.TempDir(tmpdir, \"runctmpdir\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"tmpcopyup: failed to create tmpdir: %w\", err)\n\t}\n\tdefer os.RemoveAll(tmpDir)\n\n\t// Configure the *host* tmpdir as if it's the container mount. We change\n\t// m.Destination since we are going to mount *on the host*.\n\toldDest := m.Destination\n\tm.Destination = tmpDir\n\terr = mountPropagate(m, \"/\", mountLabel)\n\tm.Destination = oldDest\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() {\n\t\tif Err != nil {\n\t\t\tif err := unmount(tmpDir, unix.MNT_DETACH); err != nil {\n\t\t\t\tlogrus.Warnf(\"tmpcopyup: %v\", err)\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn utils.WithProcfd(rootfs, m.Destination, func(procfd string) (Err error) {\n\t\t// Copy the container data to the host tmpdir. We append \"/\" to force\n\t\t// CopyDirectory to resolve the symlink rather than trying to copy the\n\t\t// symlink itself.\n\t\tif err := fileutils.CopyDirectory(procfd+\"/\", tmpDir); err != nil {\n\t\t\treturn fmt.Errorf(\"tmpcopyup: failed to copy %s to %s (%s): %w\", m.Destination, procfd, tmpDir, err)\n\t\t}\n\t\t// Now move the mount into the container.\n\t\tif err := mount(tmpDir, m.Destination, procfd, \"\", unix.MS_MOVE, \"\"); err != nil {\n\t\t\treturn fmt.Errorf(\"tmpcopyup: failed to move mount: %w\", err)\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc mountToRootfs(m *configs.Mount, c *mountConfig) error {\n\trootfs := c.root\n\tmountLabel := c.label\n\tdest, err := securejoin.SecureJoin(rootfs, m.Destination)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tswitch m.Device {\n\tcase \"proc\", \"sysfs\":\n\t\t// If the destination already exists and is not a directory, we bail\n\t\t// out This is to avoid mounting through a symlink or similar -- which\n\t\t// has been a \"fun\" attack scenario in the past.\n\t\t// TODO: This won't be necessary once we switch to libpathrs and we can\n\t\t//       stop all of these symlink-exchange attacks.\n\t\tif fi, err := os.Lstat(dest); err != nil {\n\t\t\tif !os.IsNotExist(err) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else if fi.Mode()&os.ModeDir == 0 {\n\t\t\treturn fmt.Errorf(\"filesystem %q must be mounted on ordinary directory\", m.Device)\n\t\t}\n\t\tif err := os.MkdirAll(dest, 0o755); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Selinux kernels do not support labeling of /proc or /sys\n\t\treturn mountPropagate(m, rootfs, \"\")\n\tcase \"mqueue\":\n\t\tif err := os.MkdirAll(dest, 0o755); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := mountPropagate(m, rootfs, \"\"); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn label.SetFileLabel(dest, mountLabel)\n\tcase \"tmpfs\":\n\t\tstat, err := os.Stat(dest)\n\t\tif err != nil {\n\t\t\tif err := os.MkdirAll(dest, 0o755); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tif m.Extensions&configs.EXT_COPYUP == configs.EXT_COPYUP {\n\t\t\terr = doTmpfsCopyUp(m, rootfs, mountLabel)\n\t\t} else {\n\t\t\terr = mountPropagate(m, rootfs, mountLabel)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif stat != nil {\n\t\t\tif err = os.Chmod(dest, stat.Mode()); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\t// Initially mounted rw in mountPropagate, remount to ro if flag set.\n\t\tif m.Flags&unix.MS_RDONLY != 0 {\n\t\t\tif err := remount(m, rootfs); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\tcase \"bind\":\n\t\tif err := prepareBindMount(m, rootfs); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := mountPropagate(m, rootfs, mountLabel); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// bind mount won't change mount options, we need remount to make mount options effective.\n\t\t// first check that we have non-default options required before attempting a remount\n\t\tif m.Flags&^(unix.MS_REC|unix.MS_REMOUNT|unix.MS_BIND) != 0 {\n\t\t\t// only remount if unique mount options are set\n\t\t\tif err := remount(m, rootfs); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tif m.Relabel != \"\" {\n\t\t\tif err := label.Validate(m.Relabel); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tshared := label.IsShared(m.Relabel)\n\t\t\tif err := label.Relabel(m.Source, mountLabel, shared); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\tcase \"cgroup\":\n\t\tif cgroups.IsCgroup2UnifiedMode() {\n\t\t\treturn mountCgroupV2(m, c)\n\t\t}\n\t\treturn mountCgroupV1(m, c)\n\tdefault:\n\t\tif err := checkProcMount(rootfs, dest, m.Source); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := os.MkdirAll(dest, 0o755); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn mountPropagate(m, rootfs, mountLabel)\n\t}\n\treturn nil\n}\n\nfunc getCgroupMounts(m *configs.Mount) ([]*configs.Mount, error) {\n\tmounts, err := cgroups.GetCgroupMounts(false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcgroupPaths, err := cgroups.ParseCgroupFile(\"/proc/self/cgroup\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar binds []*configs.Mount\n\n\tfor _, mm := range mounts {\n\t\tdir, err := mm.GetOwnCgroup(cgroupPaths)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\trelDir, err := filepath.Rel(mm.Root, dir)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tbinds = append(binds, &configs.Mount{\n\t\t\tDevice:           \"bind\",\n\t\t\tSource:           filepath.Join(mm.Mountpoint, relDir),\n\t\t\tDestination:      filepath.Join(m.Destination, filepath.Base(mm.Mountpoint)),\n\t\t\tFlags:            unix.MS_BIND | unix.MS_REC | m.Flags,\n\t\t\tPropagationFlags: m.PropagationFlags,\n\t\t})\n\t}\n\n\treturn binds, nil\n}\n\n// checkProcMount checks to ensure that the mount destination is not over the top of /proc.\n// dest is required to be an abs path and have any symlinks resolved before calling this function.\n//\n// if source is nil, don't stat the filesystem.  This is used for restore of a checkpoint.\nfunc checkProcMount(rootfs, dest, source string) error {\n\tconst procPath = \"/proc\"\n\tpath, err := filepath.Rel(filepath.Join(rootfs, procPath), dest)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// pass if the mount path is located outside of /proc\n\tif strings.HasPrefix(path, \"..\") {\n\t\treturn nil\n\t}\n\tif path == \".\" {\n\t\t// an empty source is pasted on restore\n\t\tif source == \"\" {\n\t\t\treturn nil\n\t\t}\n\t\t// only allow a mount on-top of proc if it's source is \"proc\"\n\t\tisproc, err := isProc(source)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// pass if the mount is happening on top of /proc and the source of\n\t\t// the mount is a proc filesystem\n\t\tif isproc {\n\t\t\treturn nil\n\t\t}\n\t\treturn fmt.Errorf(\"%q cannot be mounted because it is not of type proc\", dest)\n\t}\n\n\t// Here dest is definitely under /proc. Do not allow those,\n\t// except for a few specific entries emulated by lxcfs.\n\tvalidProcMounts := []string{\n\t\t\"/proc/cpuinfo\",\n\t\t\"/proc/diskstats\",\n\t\t\"/proc/meminfo\",\n\t\t\"/proc/stat\",\n\t\t\"/proc/swaps\",\n\t\t\"/proc/uptime\",\n\t\t\"/proc/loadavg\",\n\t\t\"/proc/slabinfo\",\n\t\t\"/proc/net/dev\",\n\t}\n\tfor _, valid := range validProcMounts {\n\t\tpath, err := filepath.Rel(filepath.Join(rootfs, valid), dest)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif path == \".\" {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn fmt.Errorf(\"%q cannot be mounted because it is inside /proc\", dest)\n}\n\nfunc isProc(path string) (bool, error) {\n\tvar s unix.Statfs_t\n\tif err := unix.Statfs(path, &s); err != nil {\n\t\treturn false, &os.PathError{Op: \"statfs\", Path: path, Err: err}\n\t}\n\treturn s.Type == unix.PROC_SUPER_MAGIC, nil\n}\n\nfunc setupDevSymlinks(rootfs string) error {\n\tlinks := [][2]string{\n\t\t{\"/proc/self/fd\", \"/dev/fd\"},\n\t\t{\"/proc/self/fd/0\", \"/dev/stdin\"},\n\t\t{\"/proc/self/fd/1\", \"/dev/stdout\"},\n\t\t{\"/proc/self/fd/2\", \"/dev/stderr\"},\n\t}\n\t// kcore support can be toggled with CONFIG_PROC_KCORE; only create a symlink\n\t// in /dev if it exists in /proc.\n\tif _, err := os.Stat(\"/proc/kcore\"); err == nil {\n\t\tlinks = append(links, [2]string{\"/proc/kcore\", \"/dev/core\"})\n\t}\n\tfor _, link := range links {\n\t\tvar (\n\t\t\tsrc = link[0]\n\t\t\tdst = filepath.Join(rootfs, link[1])\n\t\t)\n\t\tif err := os.Symlink(src, dst); err != nil && !os.IsExist(err) {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// If stdin, stdout, and/or stderr are pointing to `/dev/null` in the parent's rootfs\n// this method will make them point to `/dev/null` in this container's rootfs.  This\n// needs to be called after we chroot/pivot into the container's rootfs so that any\n// symlinks are resolved locally.\nfunc reOpenDevNull() error {\n\tvar stat, devNullStat unix.Stat_t\n\tfile, err := os.OpenFile(\"/dev/null\", os.O_RDWR, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close() //nolint: errcheck\n\tif err := unix.Fstat(int(file.Fd()), &devNullStat); err != nil {\n\t\treturn &os.PathError{Op: \"fstat\", Path: file.Name(), Err: err}\n\t}\n\tfor fd := 0; fd < 3; fd++ {\n\t\tif err := unix.Fstat(fd, &stat); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif stat.Rdev == devNullStat.Rdev {\n\t\t\t// Close and re-open the fd.\n\t\t\tif err := unix.Dup3(int(file.Fd()), fd, 0); err != nil {\n\t\t\t\treturn &os.PathError{\n\t\t\t\t\tOp:   \"dup3\",\n\t\t\t\t\tPath: \"fd \" + strconv.Itoa(int(file.Fd())),\n\t\t\t\t\tErr:  err,\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// Create the device nodes in the container.\nfunc createDevices(config *configs.Config) error {\n\tuseBindMount := userns.RunningInUserNS() || config.Namespaces.Contains(configs.NEWUSER)\n\toldMask := unix.Umask(0o000)\n\tfor _, node := range config.Devices {\n\n\t\t// The /dev/ptmx device is setup by setupPtmx()\n\t\tif utils.CleanPath(node.Path) == \"/dev/ptmx\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t// containers running in a user namespace are not allowed to mknod\n\t\t// devices so we can just bind mount it from the host.\n\t\tif err := createDeviceNode(config.Rootfs, node, useBindMount); err != nil {\n\t\t\tunix.Umask(oldMask)\n\t\t\treturn err\n\t\t}\n\t}\n\tunix.Umask(oldMask)\n\treturn nil\n}\n\nfunc bindMountDeviceNode(rootfs, dest string, node *devices.Device) error {\n\tf, err := os.Create(dest)\n\tif err != nil && !os.IsExist(err) {\n\t\treturn err\n\t}\n\tif f != nil {\n\t\t_ = f.Close()\n\t}\n\treturn utils.WithProcfd(rootfs, dest, func(procfd string) error {\n\t\treturn mount(node.Path, dest, procfd, \"bind\", unix.MS_BIND, \"\")\n\t})\n}\n\n// Creates the device node in the rootfs of the container.\nfunc createDeviceNode(rootfs string, node *devices.Device, bind bool) error {\n\tif node.Path == \"\" {\n\t\t// The node only exists for cgroup reasons, ignore it here.\n\t\treturn nil\n\t}\n\tdest, err := securejoin.SecureJoin(rootfs, node.Path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := os.MkdirAll(filepath.Dir(dest), 0o755); err != nil {\n\t\treturn err\n\t}\n\tif bind {\n\t\treturn bindMountDeviceNode(rootfs, dest, node)\n\t}\n\tif err := mknodDevice(dest, node); err != nil {\n\t\tif os.IsExist(err) {\n\t\t\treturn nil\n\t\t} else if os.IsPermission(err) {\n\t\t\treturn bindMountDeviceNode(rootfs, dest, node)\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc mknodDevice(dest string, node *devices.Device) error {\n\tfileMode := node.FileMode\n\tswitch node.Type {\n\tcase devices.BlockDevice:\n\t\tfileMode |= unix.S_IFBLK\n\tcase devices.CharDevice:\n\t\tfileMode |= unix.S_IFCHR\n\tcase devices.FifoDevice:\n\t\tfileMode |= unix.S_IFIFO\n\tdefault:\n\t\treturn fmt.Errorf(\"%c is not a valid device type for device %s\", node.Type, node.Path)\n\t}\n\tdev, err := node.Mkdev()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := unix.Mknod(dest, uint32(fileMode), int(dev)); err != nil {\n\t\treturn err\n\t}\n\treturn unix.Chown(dest, int(node.Uid), int(node.Gid))\n}\n\n// Get the parent mount point of directory passed in as argument. Also return\n// optional fields.\nfunc getParentMount(rootfs string) (string, string, error) {\n\tmi, err := mountinfo.GetMounts(mountinfo.ParentsFilter(rootfs))\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tif len(mi) < 1 {\n\t\treturn \"\", \"\", fmt.Errorf(\"could not find parent mount of %s\", rootfs)\n\t}\n\n\t// find the longest mount point\n\tvar idx, maxlen int\n\tfor i := range mi {\n\t\tif len(mi[i].Mountpoint) > maxlen {\n\t\t\tmaxlen = len(mi[i].Mountpoint)\n\t\t\tidx = i\n\t\t}\n\t}\n\treturn mi[idx].Mountpoint, mi[idx].Optional, nil\n}\n\n// Make parent mount private if it was shared\nfunc rootfsParentMountPrivate(rootfs string) error {\n\tsharedMount := false\n\n\tparentMount, optionalOpts, err := getParentMount(rootfs)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\toptsSplit := strings.Split(optionalOpts, \" \")\n\tfor _, opt := range optsSplit {\n\t\tif strings.HasPrefix(opt, \"shared:\") {\n\t\t\tsharedMount = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Make parent mount PRIVATE if it was shared. It is needed for two\n\t// reasons. First of all pivot_root() will fail if parent mount is\n\t// shared. Secondly when we bind mount rootfs it will propagate to\n\t// parent namespace and we don't want that to happen.\n\tif sharedMount {\n\t\treturn mount(\"\", parentMount, \"\", \"\", unix.MS_PRIVATE, \"\")\n\t}\n\n\treturn nil\n}\n\nfunc prepareRoot(config *configs.Config) error {\n\tflag := unix.MS_SLAVE | unix.MS_REC\n\tif config.RootPropagation != 0 {\n\t\tflag = config.RootPropagation\n\t}\n\tif err := mount(\"\", \"/\", \"\", \"\", uintptr(flag), \"\"); err != nil {\n\t\treturn err\n\t}\n\n\t// Make parent mount private to make sure following bind mount does\n\t// not propagate in other namespaces. Also it will help with kernel\n\t// check pass in pivot_root. (IS_SHARED(new_mnt->mnt_parent))\n\tif err := rootfsParentMountPrivate(config.Rootfs); err != nil {\n\t\treturn err\n\t}\n\n\treturn mount(config.Rootfs, config.Rootfs, \"\", \"bind\", unix.MS_BIND|unix.MS_REC, \"\")\n}\n\nfunc setReadonly() error {\n\tflags := uintptr(unix.MS_BIND | unix.MS_REMOUNT | unix.MS_RDONLY)\n\n\terr := mount(\"\", \"/\", \"\", \"\", flags, \"\")\n\tif err == nil {\n\t\treturn nil\n\t}\n\tvar s unix.Statfs_t\n\tif err := unix.Statfs(\"/\", &s); err != nil {\n\t\treturn &os.PathError{Op: \"statfs\", Path: \"/\", Err: err}\n\t}\n\tflags |= uintptr(s.Flags)\n\treturn mount(\"\", \"/\", \"\", \"\", flags, \"\")\n}\n\nfunc setupPtmx(config *configs.Config) error {\n\tptmx := filepath.Join(config.Rootfs, \"dev/ptmx\")\n\tif err := os.Remove(ptmx); err != nil && !os.IsNotExist(err) {\n\t\treturn err\n\t}\n\tif err := os.Symlink(\"pts/ptmx\", ptmx); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// pivotRoot will call pivot_root such that rootfs becomes the new root\n// filesystem, and everything else is cleaned up.\nfunc pivotRoot(rootfs string) error {\n\t// While the documentation may claim otherwise, pivot_root(\".\", \".\") is\n\t// actually valid. What this results in is / being the new root but\n\t// /proc/self/cwd being the old root. Since we can play around with the cwd\n\t// with pivot_root this allows us to pivot without creating directories in\n\t// the rootfs. Shout-outs to the LXC developers for giving us this idea.\n\n\toldroot, err := unix.Open(\"/\", unix.O_DIRECTORY|unix.O_RDONLY, 0)\n\tif err != nil {\n\t\treturn &os.PathError{Op: \"open\", Path: \"/\", Err: err}\n\t}\n\tdefer unix.Close(oldroot) //nolint: errcheck\n\n\tnewroot, err := unix.Open(rootfs, unix.O_DIRECTORY|unix.O_RDONLY, 0)\n\tif err != nil {\n\t\treturn &os.PathError{Op: \"open\", Path: rootfs, Err: err}\n\t}\n\tdefer unix.Close(newroot) //nolint: errcheck\n\n\t// Change to the new root so that the pivot_root actually acts on it.\n\tif err := unix.Fchdir(newroot); err != nil {\n\t\treturn &os.PathError{Op: \"fchdir\", Path: \"fd \" + strconv.Itoa(newroot), Err: err}\n\t}\n\n\tif err := unix.PivotRoot(\".\", \".\"); err != nil {\n\t\treturn &os.PathError{Op: \"pivot_root\", Path: \".\", Err: err}\n\t}\n\n\t// Currently our \".\" is oldroot (according to the current kernel code).\n\t// However, purely for safety, we will fchdir(oldroot) since there isn't\n\t// really any guarantee from the kernel what /proc/self/cwd will be after a\n\t// pivot_root(2).\n\n\tif err := unix.Fchdir(oldroot); err != nil {\n\t\treturn &os.PathError{Op: \"fchdir\", Path: \"fd \" + strconv.Itoa(oldroot), Err: err}\n\t}\n\n\t// Make oldroot rslave to make sure our unmounts don't propagate to the\n\t// host (and thus bork the machine). We don't use rprivate because this is\n\t// known to cause issues due to races where we still have a reference to a\n\t// mount while a process in the host namespace are trying to operate on\n\t// something they think has no mounts (devicemapper in particular).\n\tif err := mount(\"\", \".\", \"\", \"\", unix.MS_SLAVE|unix.MS_REC, \"\"); err != nil {\n\t\treturn err\n\t}\n\t// Perform the unmount. MNT_DETACH allows us to unmount /proc/self/cwd.\n\tif err := unmount(\".\", unix.MNT_DETACH); err != nil {\n\t\treturn err\n\t}\n\n\t// Switch back to our shiny new root.\n\tif err := unix.Chdir(\"/\"); err != nil {\n\t\treturn &os.PathError{Op: \"chdir\", Path: \"/\", Err: err}\n\t}\n\treturn nil\n}\n\nfunc msMoveRoot(rootfs string) error {\n\t// Before we move the root and chroot we have to mask all \"full\" sysfs and\n\t// procfs mounts which exist on the host. This is because while the kernel\n\t// has protections against mounting procfs if it has masks, when using\n\t// chroot(2) the *host* procfs mount is still reachable in the mount\n\t// namespace and the kernel permits procfs mounts inside --no-pivot\n\t// containers.\n\t//\n\t// Users shouldn't be using --no-pivot except in exceptional circumstances,\n\t// but to avoid such a trivial security flaw we apply a best-effort\n\t// protection here. The kernel only allows a mount of a pseudo-filesystem\n\t// like procfs or sysfs if there is a *full* mount (the root of the\n\t// filesystem is mounted) without any other locked mount points covering a\n\t// subtree of the mount.\n\t//\n\t// So we try to unmount (or mount tmpfs on top of) any mountpoint which is\n\t// a full mount of either sysfs or procfs (since those are the most\n\t// concerning filesystems to us).\n\tmountinfos, err := mountinfo.GetMounts(func(info *mountinfo.Info) (skip, stop bool) {\n\t\t// Collect every sysfs and procfs filesystem, except for those which\n\t\t// are non-full mounts or are inside the rootfs of the container.\n\t\tif info.Root != \"/\" ||\n\t\t\t(info.FSType != \"proc\" && info.FSType != \"sysfs\") ||\n\t\t\tstrings.HasPrefix(info.Mountpoint, rootfs) {\n\t\t\tskip = true\n\t\t}\n\t\treturn\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, info := range mountinfos {\n\t\tp := info.Mountpoint\n\t\t// Be sure umount events are not propagated to the host.\n\t\tif err := mount(\"\", p, \"\", \"\", unix.MS_SLAVE|unix.MS_REC, \"\"); err != nil {\n\t\t\tif errors.Is(err, unix.ENOENT) {\n\t\t\t\t// If the mountpoint doesn't exist that means that we've\n\t\t\t\t// already blasted away some parent directory of the mountpoint\n\t\t\t\t// and so we don't care about this error.\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tif err := unmount(p, unix.MNT_DETACH); err != nil {\n\t\t\tif !errors.Is(err, unix.EINVAL) && !errors.Is(err, unix.EPERM) {\n\t\t\t\treturn err\n\t\t\t} else {\n\t\t\t\t// If we have not privileges for umounting (e.g. rootless), then\n\t\t\t\t// cover the path.\n\t\t\t\tif err := mount(\"tmpfs\", p, \"\", \"tmpfs\", 0, \"\"); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Move the rootfs on top of \"/\" in our mount namespace.\n\tif err := mount(rootfs, \"/\", \"\", \"\", unix.MS_MOVE, \"\"); err != nil {\n\t\treturn err\n\t}\n\treturn chroot()\n}\n\nfunc chroot() error {\n\tif err := unix.Chroot(\".\"); err != nil {\n\t\treturn &os.PathError{Op: \"chroot\", Path: \".\", Err: err}\n\t}\n\tif err := unix.Chdir(\"/\"); err != nil {\n\t\treturn &os.PathError{Op: \"chdir\", Path: \"/\", Err: err}\n\t}\n\treturn nil\n}\n\n// createIfNotExists creates a file or a directory only if it does not already exist.\nfunc createIfNotExists(path string, isDir bool) error {\n\tif _, err := os.Stat(path); err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\tif isDir {\n\t\t\t\treturn os.MkdirAll(path, 0o755)\n\t\t\t}\n\t\t\tif err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tf, err := os.OpenFile(path, os.O_CREATE, 0o755)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t_ = f.Close()\n\t\t}\n\t}\n\treturn nil\n}\n\n// readonlyPath will make a path read only.\nfunc readonlyPath(path string) error {\n\tif err := mount(path, path, \"\", \"\", unix.MS_BIND|unix.MS_REC, \"\"); err != nil {\n\t\tif errors.Is(err, os.ErrNotExist) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tvar s unix.Statfs_t\n\tif err := unix.Statfs(path, &s); err != nil {\n\t\treturn &os.PathError{Op: \"statfs\", Path: path, Err: err}\n\t}\n\tflags := uintptr(s.Flags) & (unix.MS_NOSUID | unix.MS_NODEV | unix.MS_NOEXEC)\n\n\tif err := mount(path, path, \"\", \"\", flags|unix.MS_BIND|unix.MS_REMOUNT|unix.MS_RDONLY, \"\"); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// remountReadonly will remount an existing mount point and ensure that it is read-only.\nfunc remountReadonly(m *configs.Mount) error {\n\tvar (\n\t\tdest  = m.Destination\n\t\tflags = m.Flags\n\t)\n\tfor i := 0; i < 5; i++ {\n\t\t// There is a special case in the kernel for\n\t\t// MS_REMOUNT | MS_BIND, which allows us to change only the\n\t\t// flags even as an unprivileged user (i.e. user namespace)\n\t\t// assuming we don't drop any security related flags (nodev,\n\t\t// nosuid, etc.). So, let's use that case so that we can do\n\t\t// this re-mount without failing in a userns.\n\t\tflags |= unix.MS_REMOUNT | unix.MS_BIND | unix.MS_RDONLY\n\t\tif err := mount(\"\", dest, \"\", \"\", uintptr(flags), \"\"); err != nil {\n\t\t\tif errors.Is(err, unix.EBUSY) {\n\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unable to mount %s as readonly max retries reached\", dest)\n}\n\n// maskPath masks the top of the specified path inside a container to avoid\n// security issues from processes reading information from non-namespace aware\n// mounts ( proc/kcore ).\n// For files, maskPath bind mounts /dev/null over the top of the specified path.\n// For directories, maskPath mounts read-only tmpfs over the top of the specified path.\nfunc maskPath(path string, mountLabel string) error {\n\tif err := mount(\"/dev/null\", path, \"\", \"\", unix.MS_BIND, \"\"); err != nil && !errors.Is(err, os.ErrNotExist) {\n\t\tif errors.Is(err, unix.ENOTDIR) {\n\t\t\treturn mount(\"tmpfs\", path, \"\", \"tmpfs\", unix.MS_RDONLY, label.FormatMountLabel(\"\", mountLabel))\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// writeSystemProperty writes the value to a path under /proc/sys as determined from the key.\n// For e.g. net.ipv4.ip_forward translated to /proc/sys/net/ipv4/ip_forward.\nfunc writeSystemProperty(key, value string) error {\n\tkeyPath := strings.Replace(key, \".\", \"/\", -1)\n\treturn ioutil.WriteFile(path.Join(\"/proc/sys\", keyPath), []byte(value), 0o644)\n}\n\nfunc remount(m *configs.Mount, rootfs string) error {\n\treturn utils.WithProcfd(rootfs, m.Destination, func(procfd string) error {\n\t\treturn mount(m.Source, m.Destination, procfd, m.Device, uintptr(m.Flags|unix.MS_REMOUNT), \"\")\n\t})\n}\n\n// Do the mount operation followed by additional mounts required to take care\n// of propagation flags. This will always be scoped inside the container rootfs.\nfunc mountPropagate(m *configs.Mount, rootfs string, mountLabel string) error {\n\tvar (\n\t\tdata  = label.FormatMountLabel(m.Data, mountLabel)\n\t\tflags = m.Flags\n\t)\n\t// Delay mounting the filesystem read-only if we need to do further\n\t// operations on it. We need to set up files in \"/dev\" and tmpfs mounts may\n\t// need to be chmod-ed after mounting. The mount will be remounted ro later\n\t// in finalizeRootfs() if necessary.\n\tif utils.CleanPath(m.Destination) == \"/dev\" || m.Device == \"tmpfs\" {\n\t\tflags &= ^unix.MS_RDONLY\n\t}\n\n\t// Because the destination is inside a container path which might be\n\t// mutating underneath us, we verify that we are actually going to mount\n\t// inside the container with WithProcfd() -- mounting through a procfd\n\t// mounts on the target.\n\tif err := utils.WithProcfd(rootfs, m.Destination, func(procfd string) error {\n\t\treturn mount(m.Source, m.Destination, procfd, m.Device, uintptr(flags), data)\n\t}); err != nil {\n\t\treturn err\n\t}\n\t// We have to apply mount propagation flags in a separate WithProcfd() call\n\t// because the previous call invalidates the passed procfd -- the mount\n\t// target needs to be re-opened.\n\tif err := utils.WithProcfd(rootfs, m.Destination, func(procfd string) error {\n\t\tfor _, pflag := range m.PropagationFlags {\n\t\t\tif err := mount(\"\", m.Destination, procfd, \"\", uintptr(pflag), \"\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\treturn fmt.Errorf(\"change mount propagation through procfd: %w\", err)\n\t}\n\treturn nil\n}\n", "package libcontainer\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"runtime\"\n\t\"strconv\"\n\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/opencontainers/selinux/go-selinux\"\n\t\"github.com/sirupsen/logrus\"\n\t\"golang.org/x/sys/unix\"\n\n\t\"github.com/opencontainers/runc/libcontainer/apparmor\"\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/opencontainers/runc/libcontainer/keys\"\n\t\"github.com/opencontainers/runc/libcontainer/seccomp\"\n\t\"github.com/opencontainers/runc/libcontainer/system\"\n)\n\ntype linuxStandardInit struct {\n\tpipe          *os.File\n\tconsoleSocket *os.File\n\tparentPid     int\n\tfifoFd        int\n\tlogFd         int\n\tconfig        *initConfig\n}\n\nfunc (l *linuxStandardInit) getSessionRingParams() (string, uint32, uint32) {\n\tvar newperms uint32\n\n\tif l.config.Config.Namespaces.Contains(configs.NEWUSER) {\n\t\t// With user ns we need 'other' search permissions.\n\t\tnewperms = 0x8\n\t} else {\n\t\t// Without user ns we need 'UID' search permissions.\n\t\tnewperms = 0x80000\n\t}\n\n\t// Create a unique per session container name that we can join in setns;\n\t// However, other containers can also join it.\n\treturn \"_ses.\" + l.config.ContainerId, 0xffffffff, newperms\n}\n\nfunc (l *linuxStandardInit) Init() error {\n\truntime.LockOSThread()\n\tdefer runtime.UnlockOSThread()\n\tif !l.config.Config.NoNewKeyring {\n\t\tif err := selinux.SetKeyLabel(l.config.ProcessLabel); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer selinux.SetKeyLabel(\"\") //nolint: errcheck\n\t\tringname, keepperms, newperms := l.getSessionRingParams()\n\n\t\t// Do not inherit the parent's session keyring.\n\t\tif sessKeyId, err := keys.JoinSessionKeyring(ringname); err != nil {\n\t\t\t// If keyrings aren't supported then it is likely we are on an\n\t\t\t// older kernel (or inside an LXC container). While we could bail,\n\t\t\t// the security feature we are using here is best-effort (it only\n\t\t\t// really provides marginal protection since VFS credentials are\n\t\t\t// the only significant protection of keyrings).\n\t\t\t//\n\t\t\t// TODO(cyphar): Log this so people know what's going on, once we\n\t\t\t//               have proper logging in 'runc init'.\n\t\t\tif !errors.Is(err, unix.ENOSYS) {\n\t\t\t\treturn fmt.Errorf(\"unable to join session keyring: %w\", err)\n\t\t\t}\n\t\t} else {\n\t\t\t// Make session keyring searchable. If we've gotten this far we\n\t\t\t// bail on any error -- we don't want to have a keyring with bad\n\t\t\t// permissions.\n\t\t\tif err := keys.ModKeyringPerm(sessKeyId, keepperms, newperms); err != nil {\n\t\t\t\treturn fmt.Errorf(\"unable to mod keyring permissions: %w\", err)\n\t\t\t}\n\t\t}\n\t}\n\n\tif err := setupNetwork(l.config); err != nil {\n\t\treturn err\n\t}\n\tif err := setupRoute(l.config.Config); err != nil {\n\t\treturn err\n\t}\n\n\t// initialises the labeling system\n\tselinux.GetEnabled()\n\tif err := prepareRootfs(l.pipe, l.config); err != nil {\n\t\treturn err\n\t}\n\t// Set up the console. This has to be done *before* we finalize the rootfs,\n\t// but *after* we've given the user the chance to set up all of the mounts\n\t// they wanted.\n\tif l.config.CreateConsole {\n\t\tif err := setupConsole(l.consoleSocket, l.config, true); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := system.Setctty(); err != nil {\n\t\t\treturn &os.SyscallError{Syscall: \"ioctl(setctty)\", Err: err}\n\t\t}\n\t}\n\n\t// Finish the rootfs setup.\n\tif l.config.Config.Namespaces.Contains(configs.NEWNS) {\n\t\tif err := finalizeRootfs(l.config.Config); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif hostname := l.config.Config.Hostname; hostname != \"\" {\n\t\tif err := unix.Sethostname([]byte(hostname)); err != nil {\n\t\t\treturn &os.SyscallError{Syscall: \"sethostname\", Err: err}\n\t\t}\n\t}\n\tif err := apparmor.ApplyProfile(l.config.AppArmorProfile); err != nil {\n\t\treturn fmt.Errorf(\"unable to apply apparmor profile: %w\", err)\n\t}\n\n\tfor key, value := range l.config.Config.Sysctl {\n\t\tif err := writeSystemProperty(key, value); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tfor _, path := range l.config.Config.ReadonlyPaths {\n\t\tif err := readonlyPath(path); err != nil {\n\t\t\treturn fmt.Errorf(\"can't make %q read-only: %w\", path, err)\n\t\t}\n\t}\n\tfor _, path := range l.config.Config.MaskPaths {\n\t\tif err := maskPath(path, l.config.Config.MountLabel); err != nil {\n\t\t\treturn fmt.Errorf(\"can't mask path %s: %w\", path, err)\n\t\t}\n\t}\n\tpdeath, err := system.GetParentDeathSignal()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"can't get pdeath signal: %w\", err)\n\t}\n\tif l.config.NoNewPrivileges {\n\t\tif err := unix.Prctl(unix.PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0); err != nil {\n\t\t\treturn &os.SyscallError{Syscall: \"prctl(SET_NO_NEW_PRIVS)\", Err: err}\n\t\t}\n\t}\n\t// Tell our parent that we're ready to Execv. This must be done before the\n\t// Seccomp rules have been applied, because we need to be able to read and\n\t// write to a socket.\n\tif err := syncParentReady(l.pipe); err != nil {\n\t\treturn fmt.Errorf(\"sync ready: %w\", err)\n\t}\n\tif err := selinux.SetExecLabel(l.config.ProcessLabel); err != nil {\n\t\treturn fmt.Errorf(\"can't set process label: %w\", err)\n\t}\n\tdefer selinux.SetExecLabel(\"\") //nolint: errcheck\n\t// Without NoNewPrivileges seccomp is a privileged operation, so we need to\n\t// do this before dropping capabilities; otherwise do it as late as possible\n\t// just before execve so as few syscalls take place after it as possible.\n\tif l.config.Config.Seccomp != nil && !l.config.NoNewPrivileges {\n\t\tseccompFd, err := seccomp.InitSeccomp(l.config.Config.Seccomp)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := syncParentSeccomp(l.pipe, seccompFd); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := finalizeNamespace(l.config); err != nil {\n\t\treturn err\n\t}\n\t// finalizeNamespace can change user/group which clears the parent death\n\t// signal, so we restore it here.\n\tif err := pdeath.Restore(); err != nil {\n\t\treturn fmt.Errorf(\"can't restore pdeath signal: %w\", err)\n\t}\n\t// Compare the parent from the initial start of the init process and make\n\t// sure that it did not change.  if the parent changes that means it died\n\t// and we were reparented to something else so we should just kill ourself\n\t// and not cause problems for someone else.\n\tif unix.Getppid() != l.parentPid {\n\t\treturn unix.Kill(unix.Getpid(), unix.SIGKILL)\n\t}\n\t// Check for the arg before waiting to make sure it exists and it is\n\t// returned as a create time error.\n\tname, err := exec.LookPath(l.config.Args[0])\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Set seccomp as close to execve as possible, so as few syscalls take\n\t// place afterward (reducing the amount of syscalls that users need to\n\t// enable in their seccomp profiles). However, this needs to be done\n\t// before closing the pipe since we need it to pass the seccompFd to\n\t// the parent.\n\tif l.config.Config.Seccomp != nil && l.config.NoNewPrivileges {\n\t\tseccompFd, err := seccomp.InitSeccomp(l.config.Config.Seccomp)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to init seccomp: %w\", err)\n\t\t}\n\n\t\tif err := syncParentSeccomp(l.pipe, seccompFd); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t// Close the pipe to signal that we have completed our init.\n\tlogrus.Debugf(\"init: closing the pipe to signal completion\")\n\t_ = l.pipe.Close()\n\n\t// Close the log pipe fd so the parent's ForwardLogs can exit.\n\tif err := unix.Close(l.logFd); err != nil {\n\t\treturn &os.PathError{Op: \"close log pipe\", Path: \"fd \" + strconv.Itoa(l.logFd), Err: err}\n\t}\n\n\t// Wait for the FIFO to be opened on the other side before exec-ing the\n\t// user process. We open it through /proc/self/fd/$fd, because the fd that\n\t// was given to us was an O_PATH fd to the fifo itself. Linux allows us to\n\t// re-open an O_PATH fd through /proc.\n\tfifoPath := \"/proc/self/fd/\" + strconv.Itoa(l.fifoFd)\n\tfd, err := unix.Open(fifoPath, unix.O_WRONLY|unix.O_CLOEXEC, 0)\n\tif err != nil {\n\t\treturn &os.PathError{Op: \"open exec fifo\", Path: fifoPath, Err: err}\n\t}\n\tif _, err := unix.Write(fd, []byte(\"0\")); err != nil {\n\t\treturn &os.PathError{Op: \"write exec fifo\", Path: fifoPath, Err: err}\n\t}\n\n\t// Close the O_PATH fifofd fd before exec because the kernel resets\n\t// dumpable in the wrong order. This has been fixed in newer kernels, but\n\t// we keep this to ensure CVE-2016-9962 doesn't re-emerge on older kernels.\n\t// N.B. the core issue itself (passing dirfds to the host filesystem) has\n\t// since been resolved.\n\t// https://github.com/torvalds/linux/blob/v4.9/fs/exec.c#L1290-L1318\n\t_ = unix.Close(l.fifoFd)\n\n\ts := l.config.SpecState\n\ts.Pid = unix.Getpid()\n\ts.Status = specs.StateCreated\n\tif err := l.config.Config.Hooks[configs.StartContainer].RunHooks(s); err != nil {\n\t\treturn err\n\t}\n\n\tif err := system.Exec(name, l.config.Args[0:], os.Environ()); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n"], "fixing_code": ["package configs\n\nimport \"golang.org/x/sys/unix\"\n\nconst (\n\t// EXT_COPYUP is a directive to copy up the contents of a directory when\n\t// a tmpfs is mounted over it.\n\tEXT_COPYUP = 1 << iota //nolint:golint // ignore \"don't use ALL_CAPS\" warning\n)\n\ntype Mount struct {\n\t// Source path for the mount.\n\tSource string `json:\"source\"`\n\n\t// Destination path for the mount inside the container.\n\tDestination string `json:\"destination\"`\n\n\t// Device the mount is for.\n\tDevice string `json:\"device\"`\n\n\t// Mount flags.\n\tFlags int `json:\"flags\"`\n\n\t// Propagation Flags\n\tPropagationFlags []int `json:\"propagation_flags\"`\n\n\t// Mount data applied to the mount.\n\tData string `json:\"data\"`\n\n\t// Relabel source if set, \"z\" indicates shared, \"Z\" indicates unshared.\n\tRelabel string `json:\"relabel\"`\n\n\t// Extensions are additional flags that are specific to runc.\n\tExtensions int `json:\"extensions\"`\n\n\t// Optional Command to be run before Source is mounted.\n\tPremountCmds []Command `json:\"premount_cmds\"`\n\n\t// Optional Command to be run after Source is mounted.\n\tPostmountCmds []Command `json:\"postmount_cmds\"`\n}\n\nfunc (m *Mount) IsBind() bool {\n\treturn m.Flags&unix.MS_BIND != 0\n}\n", "package libcontainer\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/checkpoint-restore/go-criu/v5\"\n\tcriurpc \"github.com/checkpoint-restore/go-criu/v5/rpc\"\n\tsecurejoin \"github.com/cyphar/filepath-securejoin\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"golang.org/x/sys/unix\"\n\t\"google.golang.org/protobuf/proto\"\n\n\t\"github.com/opencontainers/runc/libcontainer/cgroups\"\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/opencontainers/runc/libcontainer/intelrdt\"\n\t\"github.com/opencontainers/runc/libcontainer/system\"\n\t\"github.com/opencontainers/runc/libcontainer/utils\"\n)\n\nconst stdioFdCount = 3\n\ntype linuxContainer struct {\n\tid                   string\n\troot                 string\n\tconfig               *configs.Config\n\tcgroupManager        cgroups.Manager\n\tintelRdtManager      intelrdt.Manager\n\tinitPath             string\n\tinitArgs             []string\n\tinitProcess          parentProcess\n\tinitProcessStartTime uint64\n\tcriuPath             string\n\tnewuidmapPath        string\n\tnewgidmapPath        string\n\tm                    sync.Mutex\n\tcriuVersion          int\n\tstate                containerState\n\tcreated              time.Time\n\tfifo                 *os.File\n}\n\n// State represents a running container's state\ntype State struct {\n\tBaseState\n\n\t// Platform specific fields below here\n\n\t// Specified if the container was started under the rootless mode.\n\t// Set to true if BaseState.Config.RootlessEUID && BaseState.Config.RootlessCgroups\n\tRootless bool `json:\"rootless\"`\n\n\t// Paths to all the container's cgroups, as returned by (*cgroups.Manager).GetPaths\n\t//\n\t// For cgroup v1, a key is cgroup subsystem name, and the value is the path\n\t// to the cgroup for this subsystem.\n\t//\n\t// For cgroup v2 unified hierarchy, a key is \"\", and the value is the unified path.\n\tCgroupPaths map[string]string `json:\"cgroup_paths\"`\n\n\t// NamespacePaths are filepaths to the container's namespaces. Key is the namespace type\n\t// with the value as the path.\n\tNamespacePaths map[configs.NamespaceType]string `json:\"namespace_paths\"`\n\n\t// Container's standard descriptors (std{in,out,err}), needed for checkpoint and restore\n\tExternalDescriptors []string `json:\"external_descriptors,omitempty\"`\n\n\t// Intel RDT \"resource control\" filesystem path\n\tIntelRdtPath string `json:\"intel_rdt_path\"`\n}\n\n// Container is a libcontainer container object.\n//\n// Each container is thread-safe within the same process. Since a container can\n// be destroyed by a separate process, any function may return that the container\n// was not found.\ntype Container interface {\n\tBaseContainer\n\n\t// Methods below here are platform specific\n\n\t// Checkpoint checkpoints the running container's state to disk using the criu(8) utility.\n\tCheckpoint(criuOpts *CriuOpts) error\n\n\t// Restore restores the checkpointed container to a running state using the criu(8) utility.\n\tRestore(process *Process, criuOpts *CriuOpts) error\n\n\t// If the Container state is RUNNING or CREATED, sets the Container state to PAUSING and pauses\n\t// the execution of any user processes. Asynchronously, when the container finished being paused the\n\t// state is changed to PAUSED.\n\t// If the Container state is PAUSED, do nothing.\n\tPause() error\n\n\t// If the Container state is PAUSED, resumes the execution of any user processes in the\n\t// Container before setting the Container state to RUNNING.\n\t// If the Container state is RUNNING, do nothing.\n\tResume() error\n\n\t// NotifyOOM returns a read-only channel signaling when the container receives an OOM notification.\n\tNotifyOOM() (<-chan struct{}, error)\n\n\t// NotifyMemoryPressure returns a read-only channel signaling when the container reaches a given pressure level\n\tNotifyMemoryPressure(level PressureLevel) (<-chan struct{}, error)\n}\n\n// ID returns the container's unique ID\nfunc (c *linuxContainer) ID() string {\n\treturn c.id\n}\n\n// Config returns the container's configuration\nfunc (c *linuxContainer) Config() configs.Config {\n\treturn *c.config\n}\n\nfunc (c *linuxContainer) Status() (Status, error) {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\treturn c.currentStatus()\n}\n\nfunc (c *linuxContainer) State() (*State, error) {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\treturn c.currentState()\n}\n\nfunc (c *linuxContainer) OCIState() (*specs.State, error) {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\treturn c.currentOCIState()\n}\n\nfunc (c *linuxContainer) Processes() ([]int, error) {\n\tvar pids []int\n\tstatus, err := c.currentStatus()\n\tif err != nil {\n\t\treturn pids, err\n\t}\n\t// for systemd cgroup, the unit's cgroup path will be auto removed if container's all processes exited\n\tif status == Stopped && !c.cgroupManager.Exists() {\n\t\treturn pids, nil\n\t}\n\n\tpids, err = c.cgroupManager.GetAllPids()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to get all container pids: %w\", err)\n\t}\n\treturn pids, nil\n}\n\nfunc (c *linuxContainer) Stats() (*Stats, error) {\n\tvar (\n\t\terr   error\n\t\tstats = &Stats{}\n\t)\n\tif stats.CgroupStats, err = c.cgroupManager.GetStats(); err != nil {\n\t\treturn stats, fmt.Errorf(\"unable to get container cgroup stats: %w\", err)\n\t}\n\tif c.intelRdtManager != nil {\n\t\tif stats.IntelRdtStats, err = c.intelRdtManager.GetStats(); err != nil {\n\t\t\treturn stats, fmt.Errorf(\"unable to get container Intel RDT stats: %w\", err)\n\t\t}\n\t}\n\tfor _, iface := range c.config.Networks {\n\t\tswitch iface.Type {\n\t\tcase \"veth\":\n\t\t\tistats, err := getNetworkInterfaceStats(iface.HostInterfaceName)\n\t\t\tif err != nil {\n\t\t\t\treturn stats, fmt.Errorf(\"unable to get network stats for interface %q: %w\", iface.HostInterfaceName, err)\n\t\t\t}\n\t\t\tstats.Interfaces = append(stats.Interfaces, istats)\n\t\t}\n\t}\n\treturn stats, nil\n}\n\nfunc (c *linuxContainer) Set(config configs.Config) error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\tstatus, err := c.currentStatus()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif status == Stopped {\n\t\treturn ErrNotRunning\n\t}\n\tif err := c.cgroupManager.Set(config.Cgroups.Resources); err != nil {\n\t\t// Set configs back\n\t\tif err2 := c.cgroupManager.Set(c.config.Cgroups.Resources); err2 != nil {\n\t\t\tlogrus.Warnf(\"Setting back cgroup configs failed due to error: %v, your state.json and actual configs might be inconsistent.\", err2)\n\t\t}\n\t\treturn err\n\t}\n\tif c.intelRdtManager != nil {\n\t\tif err := c.intelRdtManager.Set(&config); err != nil {\n\t\t\t// Set configs back\n\t\t\tif err2 := c.cgroupManager.Set(c.config.Cgroups.Resources); err2 != nil {\n\t\t\t\tlogrus.Warnf(\"Setting back cgroup configs failed due to error: %v, your state.json and actual configs might be inconsistent.\", err2)\n\t\t\t}\n\t\t\tif err2 := c.intelRdtManager.Set(c.config); err2 != nil {\n\t\t\t\tlogrus.Warnf(\"Setting back intelrdt configs failed due to error: %v, your state.json and actual configs might be inconsistent.\", err2)\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\t// After config setting succeed, update config and states\n\tc.config = &config\n\t_, err = c.updateState(nil)\n\treturn err\n}\n\nfunc (c *linuxContainer) Start(process *Process) error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\tif c.config.Cgroups.Resources.SkipDevices {\n\t\treturn errors.New(\"can't start container with SkipDevices set\")\n\t}\n\tif process.Init {\n\t\tif err := c.createExecFifo(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := c.start(process); err != nil {\n\t\tif process.Init {\n\t\t\tc.deleteExecFifo()\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (c *linuxContainer) Run(process *Process) error {\n\tif err := c.Start(process); err != nil {\n\t\treturn err\n\t}\n\tif process.Init {\n\t\treturn c.exec()\n\t}\n\treturn nil\n}\n\nfunc (c *linuxContainer) Exec() error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\treturn c.exec()\n}\n\nfunc (c *linuxContainer) exec() error {\n\tpath := filepath.Join(c.root, execFifoFilename)\n\tpid := c.initProcess.pid()\n\tblockingFifoOpenCh := awaitFifoOpen(path)\n\tfor {\n\t\tselect {\n\t\tcase result := <-blockingFifoOpenCh:\n\t\t\treturn handleFifoResult(result)\n\n\t\tcase <-time.After(time.Millisecond * 100):\n\t\t\tstat, err := system.Stat(pid)\n\t\t\tif err != nil || stat.State == system.Zombie {\n\t\t\t\t// could be because process started, ran, and completed between our 100ms timeout and our system.Stat() check.\n\t\t\t\t// see if the fifo exists and has data (with a non-blocking open, which will succeed if the writing process is complete).\n\t\t\t\tif err := handleFifoResult(fifoOpen(path, false)); err != nil {\n\t\t\t\t\treturn errors.New(\"container process is already dead\")\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc readFromExecFifo(execFifo io.Reader) error {\n\tdata, err := ioutil.ReadAll(execFifo)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(data) <= 0 {\n\t\treturn errors.New(\"cannot start an already running container\")\n\t}\n\treturn nil\n}\n\nfunc awaitFifoOpen(path string) <-chan openResult {\n\tfifoOpened := make(chan openResult)\n\tgo func() {\n\t\tresult := fifoOpen(path, true)\n\t\tfifoOpened <- result\n\t}()\n\treturn fifoOpened\n}\n\nfunc fifoOpen(path string, block bool) openResult {\n\tflags := os.O_RDONLY\n\tif !block {\n\t\tflags |= unix.O_NONBLOCK\n\t}\n\tf, err := os.OpenFile(path, flags, 0)\n\tif err != nil {\n\t\treturn openResult{err: fmt.Errorf(\"exec fifo: %w\", err)}\n\t}\n\treturn openResult{file: f}\n}\n\nfunc handleFifoResult(result openResult) error {\n\tif result.err != nil {\n\t\treturn result.err\n\t}\n\tf := result.file\n\tdefer f.Close()\n\tif err := readFromExecFifo(f); err != nil {\n\t\treturn err\n\t}\n\treturn os.Remove(f.Name())\n}\n\ntype openResult struct {\n\tfile *os.File\n\terr  error\n}\n\nfunc (c *linuxContainer) start(process *Process) (retErr error) {\n\tparent, err := c.newParentProcess(process)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to create new parent process: %w\", err)\n\t}\n\n\tlogsDone := parent.forwardChildLogs()\n\tif logsDone != nil {\n\t\tdefer func() {\n\t\t\t// Wait for log forwarder to finish. This depends on\n\t\t\t// runc init closing the _LIBCONTAINER_LOGPIPE log fd.\n\t\t\terr := <-logsDone\n\t\t\tif err != nil && retErr == nil {\n\t\t\t\tretErr = fmt.Errorf(\"unable to forward init logs: %w\", err)\n\t\t\t}\n\t\t}()\n\t}\n\n\tif err := parent.start(); err != nil {\n\t\treturn fmt.Errorf(\"unable to start container process: %w\", err)\n\t}\n\n\tif process.Init {\n\t\tc.fifo.Close()\n\t\tif c.config.Hooks != nil {\n\t\t\ts, err := c.currentOCIState()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif err := c.config.Hooks[configs.Poststart].RunHooks(s); err != nil {\n\t\t\t\tif err := ignoreTerminateErrors(parent.terminate()); err != nil {\n\t\t\t\t\tlogrus.Warn(fmt.Errorf(\"error running poststart hook: %w\", err))\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (c *linuxContainer) Signal(s os.Signal, all bool) error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\tstatus, err := c.currentStatus()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif all {\n\t\t// for systemd cgroup, the unit's cgroup path will be auto removed if container's all processes exited\n\t\tif status == Stopped && !c.cgroupManager.Exists() {\n\t\t\treturn nil\n\t\t}\n\t\treturn signalAllProcesses(c.cgroupManager, s)\n\t}\n\t// to avoid a PID reuse attack\n\tif status == Running || status == Created || status == Paused {\n\t\tif err := c.initProcess.signal(s); err != nil {\n\t\t\treturn fmt.Errorf(\"unable to signal init: %w\", err)\n\t\t}\n\t\tif status == Paused {\n\t\t\t// For cgroup v1, killing a process in a frozen cgroup\n\t\t\t// does nothing until it's thawed. Only thaw the cgroup\n\t\t\t// for SIGKILL.\n\t\t\tif s, ok := s.(unix.Signal); ok && s == unix.SIGKILL {\n\t\t\t\t_ = c.cgroupManager.Freeze(configs.Thawed)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\treturn ErrNotRunning\n}\n\nfunc (c *linuxContainer) createExecFifo() error {\n\trootuid, err := c.Config().HostRootUID()\n\tif err != nil {\n\t\treturn err\n\t}\n\trootgid, err := c.Config().HostRootGID()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfifoName := filepath.Join(c.root, execFifoFilename)\n\tif _, err := os.Stat(fifoName); err == nil {\n\t\treturn fmt.Errorf(\"exec fifo %s already exists\", fifoName)\n\t}\n\toldMask := unix.Umask(0o000)\n\tif err := unix.Mkfifo(fifoName, 0o622); err != nil {\n\t\tunix.Umask(oldMask)\n\t\treturn err\n\t}\n\tunix.Umask(oldMask)\n\treturn os.Chown(fifoName, rootuid, rootgid)\n}\n\nfunc (c *linuxContainer) deleteExecFifo() {\n\tfifoName := filepath.Join(c.root, execFifoFilename)\n\tos.Remove(fifoName)\n}\n\n// includeExecFifo opens the container's execfifo as a pathfd, so that the\n// container cannot access the statedir (and the FIFO itself remains\n// un-opened). It then adds the FifoFd to the given exec.Cmd as an inherited\n// fd, with _LIBCONTAINER_FIFOFD set to its fd number.\nfunc (c *linuxContainer) includeExecFifo(cmd *exec.Cmd) error {\n\tfifoName := filepath.Join(c.root, execFifoFilename)\n\tfifo, err := os.OpenFile(fifoName, unix.O_PATH|unix.O_CLOEXEC, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.fifo = fifo\n\n\tcmd.ExtraFiles = append(cmd.ExtraFiles, fifo)\n\tcmd.Env = append(cmd.Env,\n\t\t\"_LIBCONTAINER_FIFOFD=\"+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1))\n\treturn nil\n}\n\nfunc (c *linuxContainer) newParentProcess(p *Process) (parentProcess, error) {\n\tparentInitPipe, childInitPipe, err := utils.NewSockPair(\"init\")\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to create init pipe: %w\", err)\n\t}\n\tmessageSockPair := filePair{parentInitPipe, childInitPipe}\n\n\tparentLogPipe, childLogPipe, err := os.Pipe()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to create log pipe: %w\", err)\n\t}\n\tlogFilePair := filePair{parentLogPipe, childLogPipe}\n\n\tcmd := c.commandTemplate(p, childInitPipe, childLogPipe)\n\tif !p.Init {\n\t\treturn c.newSetnsProcess(p, cmd, messageSockPair, logFilePair)\n\t}\n\n\t// We only set up fifoFd if we're not doing a `runc exec`. The historic\n\t// reason for this is that previously we would pass a dirfd that allowed\n\t// for container rootfs escape (and not doing it in `runc exec` avoided\n\t// that problem), but we no longer do that. However, there's no need to do\n\t// this for `runc exec` so we just keep it this way to be safe.\n\tif err := c.includeExecFifo(cmd); err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to setup exec fifo: %w\", err)\n\t}\n\treturn c.newInitProcess(p, cmd, messageSockPair, logFilePair)\n}\n\nfunc (c *linuxContainer) commandTemplate(p *Process, childInitPipe *os.File, childLogPipe *os.File) *exec.Cmd {\n\tcmd := exec.Command(c.initPath, c.initArgs[1:]...)\n\tcmd.Args[0] = c.initArgs[0]\n\tcmd.Stdin = p.Stdin\n\tcmd.Stdout = p.Stdout\n\tcmd.Stderr = p.Stderr\n\tcmd.Dir = c.config.Rootfs\n\tif cmd.SysProcAttr == nil {\n\t\tcmd.SysProcAttr = &unix.SysProcAttr{}\n\t}\n\tcmd.Env = append(cmd.Env, \"GOMAXPROCS=\"+os.Getenv(\"GOMAXPROCS\"))\n\tcmd.ExtraFiles = append(cmd.ExtraFiles, p.ExtraFiles...)\n\tif p.ConsoleSocket != nil {\n\t\tcmd.ExtraFiles = append(cmd.ExtraFiles, p.ConsoleSocket)\n\t\tcmd.Env = append(cmd.Env,\n\t\t\t\"_LIBCONTAINER_CONSOLE=\"+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1),\n\t\t)\n\t}\n\tcmd.ExtraFiles = append(cmd.ExtraFiles, childInitPipe)\n\tcmd.Env = append(cmd.Env,\n\t\t\"_LIBCONTAINER_INITPIPE=\"+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1),\n\t\t\"_LIBCONTAINER_STATEDIR=\"+c.root,\n\t)\n\n\tcmd.ExtraFiles = append(cmd.ExtraFiles, childLogPipe)\n\tcmd.Env = append(cmd.Env,\n\t\t\"_LIBCONTAINER_LOGPIPE=\"+strconv.Itoa(stdioFdCount+len(cmd.ExtraFiles)-1),\n\t\t\"_LIBCONTAINER_LOGLEVEL=\"+p.LogLevel,\n\t)\n\n\t// NOTE: when running a container with no PID namespace and the parent process spawning the container is\n\t// PID1 the pdeathsig is being delivered to the container's init process by the kernel for some reason\n\t// even with the parent still running.\n\tif c.config.ParentDeathSignal > 0 {\n\t\tcmd.SysProcAttr.Pdeathsig = unix.Signal(c.config.ParentDeathSignal)\n\t}\n\treturn cmd\n}\n\n// shouldSendMountSources says whether the child process must setup bind mounts with\n// the source pre-opened (O_PATH) in the host user namespace.\n// See https://github.com/opencontainers/runc/issues/2484\nfunc (c *linuxContainer) shouldSendMountSources() bool {\n\t// Passing the mount sources via SCM_RIGHTS is only necessary when\n\t// both userns and mntns are active.\n\tif !c.config.Namespaces.Contains(configs.NEWUSER) ||\n\t\t!c.config.Namespaces.Contains(configs.NEWNS) {\n\t\treturn false\n\t}\n\n\t// nsexec.c send_mountsources() requires setns(mntns) capabilities\n\t// CAP_SYS_CHROOT and CAP_SYS_ADMIN.\n\tif c.config.RootlessEUID {\n\t\treturn false\n\t}\n\n\t// We need to send sources if there are bind-mounts.\n\tfor _, m := range c.config.Mounts {\n\t\tif m.IsBind() {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc (c *linuxContainer) newInitProcess(p *Process, cmd *exec.Cmd, messageSockPair, logFilePair filePair) (*initProcess, error) {\n\tcmd.Env = append(cmd.Env, \"_LIBCONTAINER_INITTYPE=\"+string(initStandard))\n\tnsMaps := make(map[configs.NamespaceType]string)\n\tfor _, ns := range c.config.Namespaces {\n\t\tif ns.Path != \"\" {\n\t\t\tnsMaps[ns.Type] = ns.Path\n\t\t}\n\t}\n\t_, sharePidns := nsMaps[configs.NEWPID]\n\tdata, err := c.bootstrapData(c.config.Namespaces.CloneFlags(), nsMaps, initStandard)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif c.shouldSendMountSources() {\n\t\t// Elements on this slice will be paired with mounts (see StartInitialization() and\n\t\t// prepareRootfs()). This slice MUST have the same size as c.config.Mounts.\n\t\tmountFds := make([]int, len(c.config.Mounts))\n\t\tfor i, m := range c.config.Mounts {\n\t\t\tif !m.IsBind() {\n\t\t\t\t// Non bind-mounts do not use an fd.\n\t\t\t\tmountFds[i] = -1\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// The fd passed here will not be used: nsexec.c will overwrite it with dup3(). We just need\n\t\t\t// to allocate a fd so that we know the number to pass in the environment variable. The fd\n\t\t\t// must not be closed before cmd.Start(), so we reuse messageSockPair.child because the\n\t\t\t// lifecycle of that fd is already taken care of.\n\t\t\tcmd.ExtraFiles = append(cmd.ExtraFiles, messageSockPair.child)\n\t\t\tmountFds[i] = stdioFdCount + len(cmd.ExtraFiles) - 1\n\t\t}\n\n\t\tmountFdsJson, err := json.Marshal(mountFds)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"Error creating _LIBCONTAINER_MOUNT_FDS: %w\", err)\n\t\t}\n\n\t\tcmd.Env = append(cmd.Env,\n\t\t\t\"_LIBCONTAINER_MOUNT_FDS=\"+string(mountFdsJson),\n\t\t)\n\t}\n\n\tinit := &initProcess{\n\t\tcmd:             cmd,\n\t\tmessageSockPair: messageSockPair,\n\t\tlogFilePair:     logFilePair,\n\t\tmanager:         c.cgroupManager,\n\t\tintelRdtManager: c.intelRdtManager,\n\t\tconfig:          c.newInitConfig(p),\n\t\tcontainer:       c,\n\t\tprocess:         p,\n\t\tbootstrapData:   data,\n\t\tsharePidns:      sharePidns,\n\t}\n\tc.initProcess = init\n\treturn init, nil\n}\n\nfunc (c *linuxContainer) newSetnsProcess(p *Process, cmd *exec.Cmd, messageSockPair, logFilePair filePair) (*setnsProcess, error) {\n\tcmd.Env = append(cmd.Env, \"_LIBCONTAINER_INITTYPE=\"+string(initSetns))\n\tstate, err := c.currentState()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"unable to get container state: %w\", err)\n\t}\n\t// for setns process, we don't have to set cloneflags as the process namespaces\n\t// will only be set via setns syscall\n\tdata, err := c.bootstrapData(0, state.NamespacePaths, initSetns)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tproc := &setnsProcess{\n\t\tcmd:             cmd,\n\t\tcgroupPaths:     state.CgroupPaths,\n\t\trootlessCgroups: c.config.RootlessCgroups,\n\t\tintelRdtPath:    state.IntelRdtPath,\n\t\tmessageSockPair: messageSockPair,\n\t\tlogFilePair:     logFilePair,\n\t\tmanager:         c.cgroupManager,\n\t\tconfig:          c.newInitConfig(p),\n\t\tprocess:         p,\n\t\tbootstrapData:   data,\n\t\tinitProcessPid:  state.InitProcessPid,\n\t}\n\tif len(p.SubCgroupPaths) > 0 {\n\t\tif add, ok := p.SubCgroupPaths[\"\"]; ok {\n\t\t\t// cgroup v1: using the same path for all controllers.\n\t\t\t// cgroup v2: the only possible way.\n\t\t\tfor k := range proc.cgroupPaths {\n\t\t\t\tproc.cgroupPaths[k] = path.Join(proc.cgroupPaths[k], add)\n\t\t\t}\n\t\t\t// cgroup v2: do not try to join init process's cgroup\n\t\t\t// as a fallback (see (*setnsProcess).start).\n\t\t\tproc.initProcessPid = 0\n\t\t} else {\n\t\t\t// Per-controller paths.\n\t\t\tfor ctrl, add := range p.SubCgroupPaths {\n\t\t\t\tif val, ok := proc.cgroupPaths[ctrl]; ok {\n\t\t\t\t\tproc.cgroupPaths[ctrl] = path.Join(val, add)\n\t\t\t\t} else {\n\t\t\t\t\treturn nil, fmt.Errorf(\"unknown controller %s in SubCgroupPaths\", ctrl)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn proc, nil\n}\n\nfunc (c *linuxContainer) newInitConfig(process *Process) *initConfig {\n\tcfg := &initConfig{\n\t\tConfig:           c.config,\n\t\tArgs:             process.Args,\n\t\tEnv:              process.Env,\n\t\tUser:             process.User,\n\t\tAdditionalGroups: process.AdditionalGroups,\n\t\tCwd:              process.Cwd,\n\t\tCapabilities:     process.Capabilities,\n\t\tPassedFilesCount: len(process.ExtraFiles),\n\t\tContainerId:      c.ID(),\n\t\tNoNewPrivileges:  c.config.NoNewPrivileges,\n\t\tRootlessEUID:     c.config.RootlessEUID,\n\t\tRootlessCgroups:  c.config.RootlessCgroups,\n\t\tAppArmorProfile:  c.config.AppArmorProfile,\n\t\tProcessLabel:     c.config.ProcessLabel,\n\t\tRlimits:          c.config.Rlimits,\n\t\tCreateConsole:    process.ConsoleSocket != nil,\n\t\tConsoleWidth:     process.ConsoleWidth,\n\t\tConsoleHeight:    process.ConsoleHeight,\n\t}\n\tif process.NoNewPrivileges != nil {\n\t\tcfg.NoNewPrivileges = *process.NoNewPrivileges\n\t}\n\tif process.AppArmorProfile != \"\" {\n\t\tcfg.AppArmorProfile = process.AppArmorProfile\n\t}\n\tif process.Label != \"\" {\n\t\tcfg.ProcessLabel = process.Label\n\t}\n\tif len(process.Rlimits) > 0 {\n\t\tcfg.Rlimits = process.Rlimits\n\t}\n\tif cgroups.IsCgroup2UnifiedMode() {\n\t\tcfg.Cgroup2Path = c.cgroupManager.Path(\"\")\n\t}\n\n\treturn cfg\n}\n\nfunc (c *linuxContainer) Destroy() error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\treturn c.state.destroy()\n}\n\nfunc (c *linuxContainer) Pause() error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\tstatus, err := c.currentStatus()\n\tif err != nil {\n\t\treturn err\n\t}\n\tswitch status {\n\tcase Running, Created:\n\t\tif err := c.cgroupManager.Freeze(configs.Frozen); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn c.state.transition(&pausedState{\n\t\t\tc: c,\n\t\t})\n\t}\n\treturn ErrNotRunning\n}\n\nfunc (c *linuxContainer) Resume() error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\tstatus, err := c.currentStatus()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif status != Paused {\n\t\treturn ErrNotPaused\n\t}\n\tif err := c.cgroupManager.Freeze(configs.Thawed); err != nil {\n\t\treturn err\n\t}\n\treturn c.state.transition(&runningState{\n\t\tc: c,\n\t})\n}\n\nfunc (c *linuxContainer) NotifyOOM() (<-chan struct{}, error) {\n\t// XXX(cyphar): This requires cgroups.\n\tif c.config.RootlessCgroups {\n\t\tlogrus.Warn(\"getting OOM notifications may fail if you don't have the full access to cgroups\")\n\t}\n\tpath := c.cgroupManager.Path(\"memory\")\n\tif cgroups.IsCgroup2UnifiedMode() {\n\t\treturn notifyOnOOMV2(path)\n\t}\n\treturn notifyOnOOM(path)\n}\n\nfunc (c *linuxContainer) NotifyMemoryPressure(level PressureLevel) (<-chan struct{}, error) {\n\t// XXX(cyphar): This requires cgroups.\n\tif c.config.RootlessCgroups {\n\t\tlogrus.Warn(\"getting memory pressure notifications may fail if you don't have the full access to cgroups\")\n\t}\n\treturn notifyMemoryPressure(c.cgroupManager.Path(\"memory\"), level)\n}\n\nvar criuFeatures *criurpc.CriuFeatures\n\nfunc (c *linuxContainer) checkCriuFeatures(criuOpts *CriuOpts, rpcOpts *criurpc.CriuOpts, criuFeat *criurpc.CriuFeatures) error {\n\tt := criurpc.CriuReqType_FEATURE_CHECK\n\n\t// make sure the features we are looking for are really not from\n\t// some previous check\n\tcriuFeatures = nil\n\n\treq := &criurpc.CriuReq{\n\t\tType: &t,\n\t\t// Theoretically this should not be necessary but CRIU\n\t\t// segfaults if Opts is empty.\n\t\t// Fixed in CRIU  2.12\n\t\tOpts:     rpcOpts,\n\t\tFeatures: criuFeat,\n\t}\n\n\terr := c.criuSwrk(nil, req, criuOpts, nil)\n\tif err != nil {\n\t\tlogrus.Debugf(\"%s\", err)\n\t\treturn errors.New(\"CRIU feature check failed\")\n\t}\n\n\tmissingFeatures := false\n\n\t// The outer if checks if the fields actually exist\n\tif (criuFeat.MemTrack != nil) &&\n\t\t(criuFeatures.MemTrack != nil) {\n\t\t// The inner if checks if they are set to true\n\t\tif *criuFeat.MemTrack && !*criuFeatures.MemTrack {\n\t\t\tmissingFeatures = true\n\t\t\tlogrus.Debugf(\"CRIU does not support MemTrack\")\n\t\t}\n\t}\n\n\t// This needs to be repeated for every new feature check.\n\t// Is there a way to put this in a function. Reflection?\n\tif (criuFeat.LazyPages != nil) &&\n\t\t(criuFeatures.LazyPages != nil) {\n\t\tif *criuFeat.LazyPages && !*criuFeatures.LazyPages {\n\t\t\tmissingFeatures = true\n\t\t\tlogrus.Debugf(\"CRIU does not support LazyPages\")\n\t\t}\n\t}\n\n\tif missingFeatures {\n\t\treturn errors.New(\"CRIU is missing features\")\n\t}\n\n\treturn nil\n}\n\nfunc compareCriuVersion(criuVersion int, minVersion int) error {\n\t// simple function to perform the actual version compare\n\tif criuVersion < minVersion {\n\t\treturn fmt.Errorf(\"CRIU version %d must be %d or higher\", criuVersion, minVersion)\n\t}\n\n\treturn nil\n}\n\n// checkCriuVersion checks Criu version greater than or equal to minVersion\nfunc (c *linuxContainer) checkCriuVersion(minVersion int) error {\n\t// If the version of criu has already been determined there is no need\n\t// to ask criu for the version again. Use the value from c.criuVersion.\n\tif c.criuVersion != 0 {\n\t\treturn compareCriuVersion(c.criuVersion, minVersion)\n\t}\n\n\tcriu := criu.MakeCriu()\n\tcriu.SetCriuPath(c.criuPath)\n\tvar err error\n\tc.criuVersion, err = criu.GetCriuVersion()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"CRIU version check failed: %w\", err)\n\t}\n\n\treturn compareCriuVersion(c.criuVersion, minVersion)\n}\n\nconst descriptorsFilename = \"descriptors.json\"\n\nfunc (c *linuxContainer) addCriuDumpMount(req *criurpc.CriuReq, m *configs.Mount) {\n\tmountDest := strings.TrimPrefix(m.Destination, c.config.Rootfs)\n\tif dest, err := securejoin.SecureJoin(c.config.Rootfs, mountDest); err == nil {\n\t\tmountDest = dest[len(c.config.Rootfs):]\n\t}\n\textMnt := &criurpc.ExtMountMap{\n\t\tKey: proto.String(mountDest),\n\t\tVal: proto.String(mountDest),\n\t}\n\treq.Opts.ExtMnt = append(req.Opts.ExtMnt, extMnt)\n}\n\nfunc (c *linuxContainer) addMaskPaths(req *criurpc.CriuReq) error {\n\tfor _, path := range c.config.MaskPaths {\n\t\tfi, err := os.Stat(fmt.Sprintf(\"/proc/%d/root/%s\", c.initProcess.pid(), path))\n\t\tif err != nil {\n\t\t\tif os.IsNotExist(err) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tif fi.IsDir() {\n\t\t\tcontinue\n\t\t}\n\n\t\textMnt := &criurpc.ExtMountMap{\n\t\t\tKey: proto.String(path),\n\t\t\tVal: proto.String(\"/dev/null\"),\n\t\t}\n\t\treq.Opts.ExtMnt = append(req.Opts.ExtMnt, extMnt)\n\t}\n\treturn nil\n}\n\nfunc (c *linuxContainer) handleCriuConfigurationFile(rpcOpts *criurpc.CriuOpts) {\n\t// CRIU will evaluate a configuration starting with release 3.11.\n\t// Settings in the configuration file will overwrite RPC settings.\n\t// Look for annotations. The annotation 'org.criu.config'\n\t// specifies if CRIU should use a different, container specific\n\t// configuration file.\n\t_, annotations := utils.Annotations(c.config.Labels)\n\tconfigFile, exists := annotations[\"org.criu.config\"]\n\tif exists {\n\t\t// If the annotation 'org.criu.config' exists and is set\n\t\t// to a non-empty string, tell CRIU to use that as a\n\t\t// configuration file. If the file does not exist, CRIU\n\t\t// will just ignore it.\n\t\tif configFile != \"\" {\n\t\t\trpcOpts.ConfigFile = proto.String(configFile)\n\t\t}\n\t\t// If 'org.criu.config' exists and is set to an empty\n\t\t// string, a runc specific CRIU configuration file will\n\t\t// be not set at all.\n\t} else {\n\t\t// If the mentioned annotation has not been found, specify\n\t\t// a default CRIU configuration file.\n\t\trpcOpts.ConfigFile = proto.String(\"/etc/criu/runc.conf\")\n\t}\n}\n\nfunc (c *linuxContainer) criuSupportsExtNS(t configs.NamespaceType) bool {\n\tvar minVersion int\n\tswitch t {\n\tcase configs.NEWNET:\n\t\t// CRIU supports different external namespace with different released CRIU versions.\n\t\t// For network namespaces to work we need at least criu 3.11.0 => 31100.\n\t\tminVersion = 31100\n\tcase configs.NEWPID:\n\t\t// For PID namespaces criu 31500 is needed.\n\t\tminVersion = 31500\n\tdefault:\n\t\treturn false\n\t}\n\treturn c.checkCriuVersion(minVersion) == nil\n}\n\nfunc criuNsToKey(t configs.NamespaceType) string {\n\treturn \"extRoot\" + strings.Title(configs.NsName(t)) + \"NS\"\n}\n\nfunc (c *linuxContainer) handleCheckpointingExternalNamespaces(rpcOpts *criurpc.CriuOpts, t configs.NamespaceType) error {\n\tif !c.criuSupportsExtNS(t) {\n\t\treturn nil\n\t}\n\n\tnsPath := c.config.Namespaces.PathOf(t)\n\tif nsPath == \"\" {\n\t\treturn nil\n\t}\n\t// CRIU expects the information about an external namespace\n\t// like this: --external <TYPE>[<inode>]:<key>\n\t// This <key> is always 'extRoot<TYPE>NS'.\n\tvar ns unix.Stat_t\n\tif err := unix.Stat(nsPath, &ns); err != nil {\n\t\treturn err\n\t}\n\tcriuExternal := fmt.Sprintf(\"%s[%d]:%s\", configs.NsName(t), ns.Ino, criuNsToKey(t))\n\trpcOpts.External = append(rpcOpts.External, criuExternal)\n\n\treturn nil\n}\n\nfunc (c *linuxContainer) handleRestoringNamespaces(rpcOpts *criurpc.CriuOpts, extraFiles *[]*os.File) error {\n\tfor _, ns := range c.config.Namespaces {\n\t\tswitch ns.Type {\n\t\tcase configs.NEWNET, configs.NEWPID:\n\t\t\t// If the container is running in a network or PID namespace and has\n\t\t\t// a path to the network or PID namespace configured, we will dump\n\t\t\t// that network or PID namespace as an external namespace and we\n\t\t\t// will expect that the namespace exists during restore.\n\t\t\t// This basically means that CRIU will ignore the namespace\n\t\t\t// and expect it to be setup correctly.\n\t\t\tif err := c.handleRestoringExternalNamespaces(rpcOpts, extraFiles, ns.Type); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\tdefault:\n\t\t\t// For all other namespaces except NET and PID CRIU has\n\t\t\t// a simpler way of joining the existing namespace if set\n\t\t\tnsPath := c.config.Namespaces.PathOf(ns.Type)\n\t\t\tif nsPath == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif ns.Type == configs.NEWCGROUP {\n\t\t\t\t// CRIU has no code to handle NEWCGROUP\n\t\t\t\treturn fmt.Errorf(\"Do not know how to handle namespace %v\", ns.Type)\n\t\t\t}\n\t\t\t// CRIU has code to handle NEWTIME, but it does not seem to be defined in runc\n\n\t\t\t// CRIU will issue a warning for NEWUSER:\n\t\t\t// criu/namespaces.c: 'join-ns with user-namespace is not fully tested and dangerous'\n\t\t\trpcOpts.JoinNs = append(rpcOpts.JoinNs, &criurpc.JoinNamespace{\n\t\t\t\tNs:     proto.String(configs.NsName(ns.Type)),\n\t\t\t\tNsFile: proto.String(nsPath),\n\t\t\t})\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (c *linuxContainer) handleRestoringExternalNamespaces(rpcOpts *criurpc.CriuOpts, extraFiles *[]*os.File, t configs.NamespaceType) error {\n\tif !c.criuSupportsExtNS(t) {\n\t\treturn nil\n\t}\n\n\tnsPath := c.config.Namespaces.PathOf(t)\n\tif nsPath == \"\" {\n\t\treturn nil\n\t}\n\t// CRIU wants the information about an existing namespace\n\t// like this: --inherit-fd fd[<fd>]:<key>\n\t// The <key> needs to be the same as during checkpointing.\n\t// We are always using 'extRoot<TYPE>NS' as the key in this.\n\tnsFd, err := os.Open(nsPath)\n\tif err != nil {\n\t\tlogrus.Errorf(\"If a specific network namespace is defined it must exist: %s\", err)\n\t\treturn fmt.Errorf(\"Requested network namespace %v does not exist\", nsPath)\n\t}\n\tinheritFd := &criurpc.InheritFd{\n\t\tKey: proto.String(criuNsToKey(t)),\n\t\t// The offset of four is necessary because 0, 1, 2 and 3 are\n\t\t// already used by stdin, stdout, stderr, 'criu swrk' socket.\n\t\tFd: proto.Int32(int32(4 + len(*extraFiles))),\n\t}\n\trpcOpts.InheritFd = append(rpcOpts.InheritFd, inheritFd)\n\t// All open FDs need to be transferred to CRIU via extraFiles\n\t*extraFiles = append(*extraFiles, nsFd)\n\n\treturn nil\n}\n\nfunc (c *linuxContainer) Checkpoint(criuOpts *CriuOpts) error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\n\t// Checkpoint is unlikely to work if os.Geteuid() != 0 || system.RunningInUserNS().\n\t// (CLI prints a warning)\n\t// TODO(avagin): Figure out how to make this work nicely. CRIU 2.0 has\n\t//               support for doing unprivileged dumps, but the setup of\n\t//               rootless containers might make this complicated.\n\n\t// We are relying on the CRIU version RPC which was introduced with CRIU 3.0.0\n\tif err := c.checkCriuVersion(30000); err != nil {\n\t\treturn err\n\t}\n\n\tif criuOpts.ImagesDirectory == \"\" {\n\t\treturn errors.New(\"invalid directory to save checkpoint\")\n\t}\n\n\t// Since a container can be C/R'ed multiple times,\n\t// the checkpoint directory may already exist.\n\tif err := os.Mkdir(criuOpts.ImagesDirectory, 0o700); err != nil && !os.IsExist(err) {\n\t\treturn err\n\t}\n\n\timageDir, err := os.Open(criuOpts.ImagesDirectory)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer imageDir.Close()\n\n\trpcOpts := criurpc.CriuOpts{\n\t\tImagesDirFd:     proto.Int32(int32(imageDir.Fd())),\n\t\tLogLevel:        proto.Int32(4),\n\t\tLogFile:         proto.String(\"dump.log\"),\n\t\tRoot:            proto.String(c.config.Rootfs),\n\t\tManageCgroups:   proto.Bool(true),\n\t\tNotifyScripts:   proto.Bool(true),\n\t\tPid:             proto.Int32(int32(c.initProcess.pid())),\n\t\tShellJob:        proto.Bool(criuOpts.ShellJob),\n\t\tLeaveRunning:    proto.Bool(criuOpts.LeaveRunning),\n\t\tTcpEstablished:  proto.Bool(criuOpts.TcpEstablished),\n\t\tExtUnixSk:       proto.Bool(criuOpts.ExternalUnixConnections),\n\t\tFileLocks:       proto.Bool(criuOpts.FileLocks),\n\t\tEmptyNs:         proto.Uint32(criuOpts.EmptyNs),\n\t\tOrphanPtsMaster: proto.Bool(true),\n\t\tAutoDedup:       proto.Bool(criuOpts.AutoDedup),\n\t\tLazyPages:       proto.Bool(criuOpts.LazyPages),\n\t}\n\n\t// if criuOpts.WorkDirectory is not set, criu default is used.\n\tif criuOpts.WorkDirectory != \"\" {\n\t\tif err := os.Mkdir(criuOpts.WorkDirectory, 0o700); err != nil && !os.IsExist(err) {\n\t\t\treturn err\n\t\t}\n\t\tworkDir, err := os.Open(criuOpts.WorkDirectory)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer workDir.Close()\n\t\trpcOpts.WorkDirFd = proto.Int32(int32(workDir.Fd()))\n\t}\n\n\tc.handleCriuConfigurationFile(&rpcOpts)\n\n\t// If the container is running in a network namespace and has\n\t// a path to the network namespace configured, we will dump\n\t// that network namespace as an external namespace and we\n\t// will expect that the namespace exists during restore.\n\t// This basically means that CRIU will ignore the namespace\n\t// and expect to be setup correctly.\n\tif err := c.handleCheckpointingExternalNamespaces(&rpcOpts, configs.NEWNET); err != nil {\n\t\treturn err\n\t}\n\n\t// Same for possible external PID namespaces\n\tif err := c.handleCheckpointingExternalNamespaces(&rpcOpts, configs.NEWPID); err != nil {\n\t\treturn err\n\t}\n\n\t// CRIU can use cgroup freezer; when rpcOpts.FreezeCgroup\n\t// is not set, CRIU uses ptrace() to pause the processes.\n\t// Note cgroup v2 freezer is only supported since CRIU release 3.14.\n\tif !cgroups.IsCgroup2UnifiedMode() || c.checkCriuVersion(31400) == nil {\n\t\tif fcg := c.cgroupManager.Path(\"freezer\"); fcg != \"\" {\n\t\t\trpcOpts.FreezeCgroup = proto.String(fcg)\n\t\t}\n\t}\n\n\t// append optional criu opts, e.g., page-server and port\n\tif criuOpts.PageServer.Address != \"\" && criuOpts.PageServer.Port != 0 {\n\t\trpcOpts.Ps = &criurpc.CriuPageServerInfo{\n\t\t\tAddress: proto.String(criuOpts.PageServer.Address),\n\t\t\tPort:    proto.Int32(criuOpts.PageServer.Port),\n\t\t}\n\t}\n\n\t// pre-dump may need parentImage param to complete iterative migration\n\tif criuOpts.ParentImage != \"\" {\n\t\trpcOpts.ParentImg = proto.String(criuOpts.ParentImage)\n\t\trpcOpts.TrackMem = proto.Bool(true)\n\t}\n\n\t// append optional manage cgroups mode\n\tif criuOpts.ManageCgroupsMode != 0 {\n\t\tmode := criuOpts.ManageCgroupsMode\n\t\trpcOpts.ManageCgroupsMode = &mode\n\t}\n\n\tvar t criurpc.CriuReqType\n\tif criuOpts.PreDump {\n\t\tfeat := criurpc.CriuFeatures{\n\t\t\tMemTrack: proto.Bool(true),\n\t\t}\n\n\t\tif err := c.checkCriuFeatures(criuOpts, &rpcOpts, &feat); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tt = criurpc.CriuReqType_PRE_DUMP\n\t} else {\n\t\tt = criurpc.CriuReqType_DUMP\n\t}\n\n\tif criuOpts.LazyPages {\n\t\t// lazy migration requested; check if criu supports it\n\t\tfeat := criurpc.CriuFeatures{\n\t\t\tLazyPages: proto.Bool(true),\n\t\t}\n\t\tif err := c.checkCriuFeatures(criuOpts, &rpcOpts, &feat); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif fd := criuOpts.StatusFd; fd != -1 {\n\t\t\t// check that the FD is valid\n\t\t\tflags, err := unix.FcntlInt(uintptr(fd), unix.F_GETFL, 0)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"invalid --status-fd argument %d: %w\", fd, err)\n\t\t\t}\n\t\t\t// and writable\n\t\t\tif flags&unix.O_WRONLY == 0 {\n\t\t\t\treturn fmt.Errorf(\"invalid --status-fd argument %d: not writable\", fd)\n\t\t\t}\n\n\t\t\tif c.checkCriuVersion(31500) != nil {\n\t\t\t\t// For criu 3.15+, use notifications (see case \"status-ready\"\n\t\t\t\t// in criuNotifications). Otherwise, rely on criu status fd.\n\t\t\t\trpcOpts.StatusFd = proto.Int32(int32(fd))\n\t\t\t}\n\t\t}\n\t}\n\n\treq := &criurpc.CriuReq{\n\t\tType: &t,\n\t\tOpts: &rpcOpts,\n\t}\n\n\t// no need to dump all this in pre-dump\n\tif !criuOpts.PreDump {\n\t\thasCgroupns := c.config.Namespaces.Contains(configs.NEWCGROUP)\n\t\tfor _, m := range c.config.Mounts {\n\t\t\tswitch m.Device {\n\t\t\tcase \"bind\":\n\t\t\t\tc.addCriuDumpMount(req, m)\n\t\t\tcase \"cgroup\":\n\t\t\t\tif cgroups.IsCgroup2UnifiedMode() || hasCgroupns {\n\t\t\t\t\t// real mount(s)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\t// a set of \"external\" bind mounts\n\t\t\t\tbinds, err := getCgroupMounts(m)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tfor _, b := range binds {\n\t\t\t\t\tc.addCriuDumpMount(req, b)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif err := c.addMaskPaths(req); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tfor _, node := range c.config.Devices {\n\t\t\tm := &configs.Mount{Destination: node.Path, Source: node.Path}\n\t\t\tc.addCriuDumpMount(req, m)\n\t\t}\n\n\t\t// Write the FD info to a file in the image directory\n\t\tfdsJSON, err := json.Marshal(c.initProcess.externalDescriptors())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\terr = ioutil.WriteFile(filepath.Join(criuOpts.ImagesDirectory, descriptorsFilename), fdsJSON, 0o600)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\terr = c.criuSwrk(nil, req, criuOpts, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (c *linuxContainer) addCriuRestoreMount(req *criurpc.CriuReq, m *configs.Mount) {\n\tmountDest := strings.TrimPrefix(m.Destination, c.config.Rootfs)\n\tif dest, err := securejoin.SecureJoin(c.config.Rootfs, mountDest); err == nil {\n\t\tmountDest = dest[len(c.config.Rootfs):]\n\t}\n\textMnt := &criurpc.ExtMountMap{\n\t\tKey: proto.String(mountDest),\n\t\tVal: proto.String(m.Source),\n\t}\n\treq.Opts.ExtMnt = append(req.Opts.ExtMnt, extMnt)\n}\n\nfunc (c *linuxContainer) restoreNetwork(req *criurpc.CriuReq, criuOpts *CriuOpts) {\n\tfor _, iface := range c.config.Networks {\n\t\tswitch iface.Type {\n\t\tcase \"veth\":\n\t\t\tveth := new(criurpc.CriuVethPair)\n\t\t\tveth.IfOut = proto.String(iface.HostInterfaceName)\n\t\t\tveth.IfIn = proto.String(iface.Name)\n\t\t\treq.Opts.Veths = append(req.Opts.Veths, veth)\n\t\tcase \"loopback\":\n\t\t\t// Do nothing\n\t\t}\n\t}\n\tfor _, i := range criuOpts.VethPairs {\n\t\tveth := new(criurpc.CriuVethPair)\n\t\tveth.IfOut = proto.String(i.HostInterfaceName)\n\t\tveth.IfIn = proto.String(i.ContainerInterfaceName)\n\t\treq.Opts.Veths = append(req.Opts.Veths, veth)\n\t}\n}\n\n// makeCriuRestoreMountpoints makes the actual mountpoints for the\n// restore using CRIU. This function is inspired from the code in\n// rootfs_linux.go\nfunc (c *linuxContainer) makeCriuRestoreMountpoints(m *configs.Mount) error {\n\tswitch m.Device {\n\tcase \"cgroup\":\n\t\t// No mount point(s) need to be created:\n\t\t//\n\t\t// * for v1, mount points are saved by CRIU because\n\t\t//   /sys/fs/cgroup is a tmpfs mount\n\t\t//\n\t\t// * for v2, /sys/fs/cgroup is a real mount, but\n\t\t//   the mountpoint appears as soon as /sys is mounted\n\t\treturn nil\n\tcase \"bind\":\n\t\t// The prepareBindMount() function checks if source\n\t\t// exists. So it cannot be used for other filesystem types.\n\t\t// TODO: pass something else than nil? Not sure if criu is\n\t\t// impacted by issue #2484\n\t\tif err := prepareBindMount(m, c.config.Rootfs, nil); err != nil {\n\t\t\treturn err\n\t\t}\n\tdefault:\n\t\t// for all other filesystems just create the mountpoints\n\t\tdest, err := securejoin.SecureJoin(c.config.Rootfs, m.Destination)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := checkProcMount(c.config.Rootfs, dest, \"\"); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := os.MkdirAll(dest, 0o755); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// isPathInPrefixList is a small function for CRIU restore to make sure\n// mountpoints, which are on a tmpfs, are not created in the roofs\nfunc isPathInPrefixList(path string, prefix []string) bool {\n\tfor _, p := range prefix {\n\t\tif strings.HasPrefix(path, p+\"/\") {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// prepareCriuRestoreMounts tries to set up the rootfs of the\n// container to be restored in the same way runc does it for\n// initial container creation. Even for a read-only rootfs container\n// runc modifies the rootfs to add mountpoints which do not exist.\n// This function also creates missing mountpoints as long as they\n// are not on top of a tmpfs, as CRIU will restore tmpfs content anyway.\nfunc (c *linuxContainer) prepareCriuRestoreMounts(mounts []*configs.Mount) error {\n\t// First get a list of a all tmpfs mounts\n\ttmpfs := []string{}\n\tfor _, m := range mounts {\n\t\tswitch m.Device {\n\t\tcase \"tmpfs\":\n\t\t\ttmpfs = append(tmpfs, m.Destination)\n\t\t}\n\t}\n\t// Now go through all mounts and create the mountpoints\n\t// if the mountpoints are not on a tmpfs, as CRIU will\n\t// restore the complete tmpfs content from its checkpoint.\n\tumounts := []string{}\n\tdefer func() {\n\t\tfor _, u := range umounts {\n\t\t\t_ = utils.WithProcfd(c.config.Rootfs, u, func(procfd string) error {\n\t\t\t\tif e := unix.Unmount(procfd, unix.MNT_DETACH); e != nil {\n\t\t\t\t\tif e != unix.EINVAL { //nolint:errorlint // unix errors are bare\n\t\t\t\t\t\t// Ignore EINVAL as it means 'target is not a mount point.'\n\t\t\t\t\t\t// It probably has already been unmounted.\n\t\t\t\t\t\tlogrus.Warnf(\"Error during cleanup unmounting of %s (%s): %v\", procfd, u, e)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t})\n\t\t}\n\t}()\n\tfor _, m := range mounts {\n\t\tif !isPathInPrefixList(m.Destination, tmpfs) {\n\t\t\tif err := c.makeCriuRestoreMountpoints(m); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t// If the mount point is a bind mount, we need to mount\n\t\t\t// it now so that runc can create the necessary mount\n\t\t\t// points for mounts in bind mounts.\n\t\t\t// This also happens during initial container creation.\n\t\t\t// Without this CRIU restore will fail\n\t\t\t// See: https://github.com/opencontainers/runc/issues/2748\n\t\t\t// It is also not necessary to order the mount points\n\t\t\t// because during initial container creation mounts are\n\t\t\t// set up in the order they are configured.\n\t\t\tif m.Device == \"bind\" {\n\t\t\t\tif err := utils.WithProcfd(c.config.Rootfs, m.Destination, func(procfd string) error {\n\t\t\t\t\tif err := mount(m.Source, m.Destination, procfd, \"\", unix.MS_BIND|unix.MS_REC, \"\"); err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\treturn nil\n\t\t\t\t}); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tumounts = append(umounts, m.Destination)\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (c *linuxContainer) Restore(process *Process, criuOpts *CriuOpts) error {\n\tc.m.Lock()\n\tdefer c.m.Unlock()\n\n\tvar extraFiles []*os.File\n\n\t// Restore is unlikely to work if os.Geteuid() != 0 || system.RunningInUserNS().\n\t// (CLI prints a warning)\n\t// TODO(avagin): Figure out how to make this work nicely. CRIU doesn't have\n\t//               support for unprivileged restore at the moment.\n\n\t// We are relying on the CRIU version RPC which was introduced with CRIU 3.0.0\n\tif err := c.checkCriuVersion(30000); err != nil {\n\t\treturn err\n\t}\n\tif criuOpts.ImagesDirectory == \"\" {\n\t\treturn errors.New(\"invalid directory to restore checkpoint\")\n\t}\n\timageDir, err := os.Open(criuOpts.ImagesDirectory)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer imageDir.Close()\n\t// CRIU has a few requirements for a root directory:\n\t// * it must be a mount point\n\t// * its parent must not be overmounted\n\t// c.config.Rootfs is bind-mounted to a temporary directory\n\t// to satisfy these requirements.\n\troot := filepath.Join(c.root, \"criu-root\")\n\tif err := os.Mkdir(root, 0o755); err != nil {\n\t\treturn err\n\t}\n\tdefer os.Remove(root)\n\troot, err = filepath.EvalSymlinks(root)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = mount(c.config.Rootfs, root, \"\", \"\", unix.MS_BIND|unix.MS_REC, \"\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer unix.Unmount(root, unix.MNT_DETACH) //nolint: errcheck\n\tt := criurpc.CriuReqType_RESTORE\n\treq := &criurpc.CriuReq{\n\t\tType: &t,\n\t\tOpts: &criurpc.CriuOpts{\n\t\t\tImagesDirFd:     proto.Int32(int32(imageDir.Fd())),\n\t\t\tEvasiveDevices:  proto.Bool(true),\n\t\t\tLogLevel:        proto.Int32(4),\n\t\t\tLogFile:         proto.String(\"restore.log\"),\n\t\t\tRstSibling:      proto.Bool(true),\n\t\t\tRoot:            proto.String(root),\n\t\t\tManageCgroups:   proto.Bool(true),\n\t\t\tNotifyScripts:   proto.Bool(true),\n\t\t\tShellJob:        proto.Bool(criuOpts.ShellJob),\n\t\t\tExtUnixSk:       proto.Bool(criuOpts.ExternalUnixConnections),\n\t\t\tTcpEstablished:  proto.Bool(criuOpts.TcpEstablished),\n\t\t\tFileLocks:       proto.Bool(criuOpts.FileLocks),\n\t\t\tEmptyNs:         proto.Uint32(criuOpts.EmptyNs),\n\t\t\tOrphanPtsMaster: proto.Bool(true),\n\t\t\tAutoDedup:       proto.Bool(criuOpts.AutoDedup),\n\t\t\tLazyPages:       proto.Bool(criuOpts.LazyPages),\n\t\t},\n\t}\n\n\tif criuOpts.LsmProfile != \"\" {\n\t\t// CRIU older than 3.16 has a bug which breaks the possibility\n\t\t// to set a different LSM profile.\n\t\tif err := c.checkCriuVersion(31600); err != nil {\n\t\t\treturn errors.New(\"--lsm-profile requires at least CRIU 3.16\")\n\t\t}\n\t\treq.Opts.LsmProfile = proto.String(criuOpts.LsmProfile)\n\t}\n\tif criuOpts.LsmMountContext != \"\" {\n\t\tif err := c.checkCriuVersion(31600); err != nil {\n\t\t\treturn errors.New(\"--lsm-mount-context requires at least CRIU 3.16\")\n\t\t}\n\t\treq.Opts.LsmMountContext = proto.String(criuOpts.LsmMountContext)\n\t}\n\n\tif criuOpts.WorkDirectory != \"\" {\n\t\t// Since a container can be C/R'ed multiple times,\n\t\t// the work directory may already exist.\n\t\tif err := os.Mkdir(criuOpts.WorkDirectory, 0o700); err != nil && !os.IsExist(err) {\n\t\t\treturn err\n\t\t}\n\t\tworkDir, err := os.Open(criuOpts.WorkDirectory)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer workDir.Close()\n\t\treq.Opts.WorkDirFd = proto.Int32(int32(workDir.Fd()))\n\t}\n\tc.handleCriuConfigurationFile(req.Opts)\n\n\tif err := c.handleRestoringNamespaces(req.Opts, &extraFiles); err != nil {\n\t\treturn err\n\t}\n\n\t// This will modify the rootfs of the container in the same way runc\n\t// modifies the container during initial creation.\n\tif err := c.prepareCriuRestoreMounts(c.config.Mounts); err != nil {\n\t\treturn err\n\t}\n\n\thasCgroupns := c.config.Namespaces.Contains(configs.NEWCGROUP)\n\tfor _, m := range c.config.Mounts {\n\t\tswitch m.Device {\n\t\tcase \"bind\":\n\t\t\tc.addCriuRestoreMount(req, m)\n\t\tcase \"cgroup\":\n\t\t\tif cgroups.IsCgroup2UnifiedMode() || hasCgroupns {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// cgroup v1 is a set of bind mounts, unless cgroupns is used\n\t\t\tbinds, err := getCgroupMounts(m)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tfor _, b := range binds {\n\t\t\t\tc.addCriuRestoreMount(req, b)\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(c.config.MaskPaths) > 0 {\n\t\tm := &configs.Mount{Destination: \"/dev/null\", Source: \"/dev/null\"}\n\t\tc.addCriuRestoreMount(req, m)\n\t}\n\n\tfor _, node := range c.config.Devices {\n\t\tm := &configs.Mount{Destination: node.Path, Source: node.Path}\n\t\tc.addCriuRestoreMount(req, m)\n\t}\n\n\tif criuOpts.EmptyNs&unix.CLONE_NEWNET == 0 {\n\t\tc.restoreNetwork(req, criuOpts)\n\t}\n\n\t// append optional manage cgroups mode\n\tif criuOpts.ManageCgroupsMode != 0 {\n\t\tmode := criuOpts.ManageCgroupsMode\n\t\treq.Opts.ManageCgroupsMode = &mode\n\t}\n\n\tvar (\n\t\tfds    []string\n\t\tfdJSON []byte\n\t)\n\tif fdJSON, err = ioutil.ReadFile(filepath.Join(criuOpts.ImagesDirectory, descriptorsFilename)); err != nil {\n\t\treturn err\n\t}\n\n\tif err := json.Unmarshal(fdJSON, &fds); err != nil {\n\t\treturn err\n\t}\n\tfor i := range fds {\n\t\tif s := fds[i]; strings.Contains(s, \"pipe:\") {\n\t\t\tinheritFd := new(criurpc.InheritFd)\n\t\t\tinheritFd.Key = proto.String(s)\n\t\t\tinheritFd.Fd = proto.Int32(int32(i))\n\t\t\treq.Opts.InheritFd = append(req.Opts.InheritFd, inheritFd)\n\t\t}\n\t}\n\terr = c.criuSwrk(process, req, criuOpts, extraFiles)\n\n\t// Now that CRIU is done let's close all opened FDs CRIU needed.\n\tfor _, fd := range extraFiles {\n\t\tfd.Close()\n\t}\n\n\treturn err\n}\n\nfunc (c *linuxContainer) criuApplyCgroups(pid int, req *criurpc.CriuReq) error {\n\t// need to apply cgroups only on restore\n\tif req.GetType() != criurpc.CriuReqType_RESTORE {\n\t\treturn nil\n\t}\n\n\t// XXX: Do we need to deal with this case? AFAIK criu still requires root.\n\tif err := c.cgroupManager.Apply(pid); err != nil {\n\t\treturn err\n\t}\n\n\tif err := c.cgroupManager.Set(c.config.Cgroups.Resources); err != nil {\n\t\treturn err\n\t}\n\n\tif cgroups.IsCgroup2UnifiedMode() {\n\t\treturn nil\n\t}\n\t// the stuff below is cgroupv1-specific\n\n\tpath := fmt.Sprintf(\"/proc/%d/cgroup\", pid)\n\tcgroupsPaths, err := cgroups.ParseCgroupFile(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor c, p := range cgroupsPaths {\n\t\tcgroupRoot := &criurpc.CgroupRoot{\n\t\t\tCtrl: proto.String(c),\n\t\t\tPath: proto.String(p),\n\t\t}\n\t\treq.Opts.CgRoot = append(req.Opts.CgRoot, cgroupRoot)\n\t}\n\n\treturn nil\n}\n\nfunc (c *linuxContainer) criuSwrk(process *Process, req *criurpc.CriuReq, opts *CriuOpts, extraFiles []*os.File) error {\n\tfds, err := unix.Socketpair(unix.AF_LOCAL, unix.SOCK_SEQPACKET|unix.SOCK_CLOEXEC, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar logPath string\n\tif opts != nil {\n\t\tlogPath = filepath.Join(opts.WorkDirectory, req.GetOpts().GetLogFile())\n\t} else {\n\t\t// For the VERSION RPC 'opts' is set to 'nil' and therefore\n\t\t// opts.WorkDirectory does not exist. Set logPath to \"\".\n\t\tlogPath = \"\"\n\t}\n\tcriuClient := os.NewFile(uintptr(fds[0]), \"criu-transport-client\")\n\tcriuClientFileCon, err := net.FileConn(criuClient)\n\tcriuClient.Close()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcriuClientCon := criuClientFileCon.(*net.UnixConn)\n\tdefer criuClientCon.Close()\n\n\tcriuServer := os.NewFile(uintptr(fds[1]), \"criu-transport-server\")\n\tdefer criuServer.Close()\n\n\targs := []string{\"swrk\", \"3\"}\n\tif c.criuVersion != 0 {\n\t\t// If the CRIU Version is still '0' then this is probably\n\t\t// the initial CRIU run to detect the version. Skip it.\n\t\tlogrus.Debugf(\"Using CRIU %d at: %s\", c.criuVersion, c.criuPath)\n\t}\n\tcmd := exec.Command(c.criuPath, args...)\n\tif process != nil {\n\t\tcmd.Stdin = process.Stdin\n\t\tcmd.Stdout = process.Stdout\n\t\tcmd.Stderr = process.Stderr\n\t}\n\tcmd.ExtraFiles = append(cmd.ExtraFiles, criuServer)\n\tif extraFiles != nil {\n\t\tcmd.ExtraFiles = append(cmd.ExtraFiles, extraFiles...)\n\t}\n\n\tif err := cmd.Start(); err != nil {\n\t\treturn err\n\t}\n\t// we close criuServer so that even if CRIU crashes or unexpectedly exits, runc will not hang.\n\tcriuServer.Close()\n\t// cmd.Process will be replaced by a restored init.\n\tcriuProcess := cmd.Process\n\n\tvar criuProcessState *os.ProcessState\n\tdefer func() {\n\t\tif criuProcessState == nil {\n\t\t\tcriuClientCon.Close()\n\t\t\t_, err := criuProcess.Wait()\n\t\t\tif err != nil {\n\t\t\t\tlogrus.Warnf(\"wait on criuProcess returned %v\", err)\n\t\t\t}\n\t\t}\n\t}()\n\n\tif err := c.criuApplyCgroups(criuProcess.Pid, req); err != nil {\n\t\treturn err\n\t}\n\n\tvar extFds []string\n\tif process != nil {\n\t\textFds, err = getPipeFds(criuProcess.Pid)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tlogrus.Debugf(\"Using CRIU in %s mode\", req.GetType().String())\n\t// In the case of criurpc.CriuReqType_FEATURE_CHECK req.GetOpts()\n\t// should be empty. For older CRIU versions it still will be\n\t// available but empty. criurpc.CriuReqType_VERSION actually\n\t// has no req.GetOpts().\n\tif logrus.GetLevel() >= logrus.DebugLevel &&\n\t\t!(req.GetType() == criurpc.CriuReqType_FEATURE_CHECK ||\n\t\t\treq.GetType() == criurpc.CriuReqType_VERSION) {\n\n\t\tval := reflect.ValueOf(req.GetOpts())\n\t\tv := reflect.Indirect(val)\n\t\tfor i := 0; i < v.NumField(); i++ {\n\t\t\tst := v.Type()\n\t\t\tname := st.Field(i).Name\n\t\t\tif 'A' <= name[0] && name[0] <= 'Z' {\n\t\t\t\tvalue := val.MethodByName(\"Get\" + name).Call([]reflect.Value{})\n\t\t\t\tlogrus.Debugf(\"CRIU option %s with value %v\", name, value[0])\n\t\t\t}\n\t\t}\n\t}\n\tdata, err := proto.Marshal(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = criuClientCon.Write(data)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tbuf := make([]byte, 10*4096)\n\toob := make([]byte, 4096)\n\tfor {\n\t\tn, oobn, _, _, err := criuClientCon.ReadMsgUnix(buf, oob)\n\t\tif req.Opts != nil && req.Opts.StatusFd != nil {\n\t\t\t// Close status_fd as soon as we got something back from criu,\n\t\t\t// assuming it has consumed (reopened) it by this time.\n\t\t\t// Otherwise it will might be left open forever and whoever\n\t\t\t// is waiting on it will wait forever.\n\t\t\tfd := int(*req.Opts.StatusFd)\n\t\t\t_ = unix.Close(fd)\n\t\t\treq.Opts.StatusFd = nil\n\t\t}\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif n == 0 {\n\t\t\treturn errors.New(\"unexpected EOF\")\n\t\t}\n\t\tif n == len(buf) {\n\t\t\treturn errors.New(\"buffer is too small\")\n\t\t}\n\n\t\tresp := new(criurpc.CriuResp)\n\t\terr = proto.Unmarshal(buf[:n], resp)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !resp.GetSuccess() {\n\t\t\ttypeString := req.GetType().String()\n\t\t\treturn fmt.Errorf(\"criu failed: type %s errno %d\\nlog file: %s\", typeString, resp.GetCrErrno(), logPath)\n\t\t}\n\n\t\tt := resp.GetType()\n\t\tswitch {\n\t\tcase t == criurpc.CriuReqType_FEATURE_CHECK:\n\t\t\tlogrus.Debugf(\"Feature check says: %s\", resp)\n\t\t\tcriuFeatures = resp.GetFeatures()\n\t\tcase t == criurpc.CriuReqType_NOTIFY:\n\t\t\tif err := c.criuNotifications(resp, process, cmd, opts, extFds, oob[:oobn]); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tt = criurpc.CriuReqType_NOTIFY\n\t\t\treq = &criurpc.CriuReq{\n\t\t\t\tType:          &t,\n\t\t\t\tNotifySuccess: proto.Bool(true),\n\t\t\t}\n\t\t\tdata, err = proto.Marshal(req)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t_, err = criuClientCon.Write(data)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcontinue\n\t\tcase t == criurpc.CriuReqType_RESTORE:\n\t\tcase t == criurpc.CriuReqType_DUMP:\n\t\tcase t == criurpc.CriuReqType_PRE_DUMP:\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"unable to parse the response %s\", resp.String())\n\t\t}\n\n\t\tbreak\n\t}\n\n\t_ = criuClientCon.CloseWrite()\n\t// cmd.Wait() waits cmd.goroutines which are used for proxying file descriptors.\n\t// Here we want to wait only the CRIU process.\n\tcriuProcessState, err = criuProcess.Wait()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// In pre-dump mode CRIU is in a loop and waits for\n\t// the final DUMP command.\n\t// The current runc pre-dump approach, however, is\n\t// start criu in PRE_DUMP once for a single pre-dump\n\t// and not the whole series of pre-dump, pre-dump, ...m, dump\n\t// If we got the message CriuReqType_PRE_DUMP it means\n\t// CRIU was successful and we need to forcefully stop CRIU\n\tif !criuProcessState.Success() && *req.Type != criurpc.CriuReqType_PRE_DUMP {\n\t\treturn fmt.Errorf(\"criu failed: %s\\nlog file: %s\", criuProcessState.String(), logPath)\n\t}\n\treturn nil\n}\n\n// block any external network activity\nfunc lockNetwork(config *configs.Config) error {\n\tfor _, config := range config.Networks {\n\t\tstrategy, err := getStrategy(config.Type)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := strategy.detach(config); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc unlockNetwork(config *configs.Config) error {\n\tfor _, config := range config.Networks {\n\t\tstrategy, err := getStrategy(config.Type)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = strategy.attach(config); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (c *linuxContainer) criuNotifications(resp *criurpc.CriuResp, process *Process, cmd *exec.Cmd, opts *CriuOpts, fds []string, oob []byte) error {\n\tnotify := resp.GetNotify()\n\tif notify == nil {\n\t\treturn fmt.Errorf(\"invalid response: %s\", resp.String())\n\t}\n\tscript := notify.GetScript()\n\tlogrus.Debugf(\"notify: %s\\n\", script)\n\tswitch script {\n\tcase \"post-dump\":\n\t\tf, err := os.Create(filepath.Join(c.root, \"checkpoint\"))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tf.Close()\n\tcase \"network-unlock\":\n\t\tif err := unlockNetwork(c.config); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase \"network-lock\":\n\t\tif err := lockNetwork(c.config); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase \"setup-namespaces\":\n\t\tif c.config.Hooks != nil {\n\t\t\ts, err := c.currentOCIState()\n\t\t\tif err != nil {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\ts.Pid = int(notify.GetPid())\n\n\t\t\tif err := c.config.Hooks[configs.Prestart].RunHooks(s); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := c.config.Hooks[configs.CreateRuntime].RunHooks(s); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\tcase \"post-restore\":\n\t\tpid := notify.GetPid()\n\n\t\tp, err := os.FindProcess(int(pid))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tcmd.Process = p\n\n\t\tr, err := newRestoredProcess(cmd, fds)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tprocess.ops = r\n\t\tif err := c.state.transition(&restoredState{\n\t\t\timageDir: opts.ImagesDirectory,\n\t\t\tc:        c,\n\t\t}); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// create a timestamp indicating when the restored checkpoint was started\n\t\tc.created = time.Now().UTC()\n\t\tif _, err := c.updateState(r); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := os.Remove(filepath.Join(c.root, \"checkpoint\")); err != nil {\n\t\t\tif !os.IsNotExist(err) {\n\t\t\t\tlogrus.Error(err)\n\t\t\t}\n\t\t}\n\tcase \"orphan-pts-master\":\n\t\tscm, err := unix.ParseSocketControlMessage(oob)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfds, err := unix.ParseUnixRights(&scm[0])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tmaster := os.NewFile(uintptr(fds[0]), \"orphan-pts-master\")\n\t\tdefer master.Close()\n\n\t\t// While we can access console.master, using the API is a good idea.\n\t\tif err := utils.SendFd(process.ConsoleSocket, master.Name(), master.Fd()); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase \"status-ready\":\n\t\tif opts.StatusFd != -1 {\n\t\t\t// write \\0 to status fd to notify that lazy page server is ready\n\t\t\t_, err := unix.Write(opts.StatusFd, []byte{0})\n\t\t\tif err != nil {\n\t\t\t\tlogrus.Warnf(\"can't write \\\\0 to status fd: %v\", err)\n\t\t\t}\n\t\t\t_ = unix.Close(opts.StatusFd)\n\t\t\topts.StatusFd = -1\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (c *linuxContainer) updateState(process parentProcess) (*State, error) {\n\tif process != nil {\n\t\tc.initProcess = process\n\t}\n\tstate, err := c.currentState()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = c.saveState(state)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn state, nil\n}\n\nfunc (c *linuxContainer) saveState(s *State) (retErr error) {\n\ttmpFile, err := ioutil.TempFile(c.root, \"state-\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer func() {\n\t\tif retErr != nil {\n\t\t\ttmpFile.Close()\n\t\t\tos.Remove(tmpFile.Name())\n\t\t}\n\t}()\n\n\terr = utils.WriteJSON(tmpFile, s)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = tmpFile.Close()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tstateFilePath := filepath.Join(c.root, stateFilename)\n\treturn os.Rename(tmpFile.Name(), stateFilePath)\n}\n\nfunc (c *linuxContainer) currentStatus() (Status, error) {\n\tif err := c.refreshState(); err != nil {\n\t\treturn -1, err\n\t}\n\treturn c.state.status(), nil\n}\n\n// refreshState needs to be called to verify that the current state on the\n// container is what is true.  Because consumers of libcontainer can use it\n// out of process we need to verify the container's status based on runtime\n// information and not rely on our in process info.\nfunc (c *linuxContainer) refreshState() error {\n\tpaused, err := c.isPaused()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif paused {\n\t\treturn c.state.transition(&pausedState{c: c})\n\t}\n\tt := c.runType()\n\tswitch t {\n\tcase Created:\n\t\treturn c.state.transition(&createdState{c: c})\n\tcase Running:\n\t\treturn c.state.transition(&runningState{c: c})\n\t}\n\treturn c.state.transition(&stoppedState{c: c})\n}\n\nfunc (c *linuxContainer) runType() Status {\n\tif c.initProcess == nil {\n\t\treturn Stopped\n\t}\n\tpid := c.initProcess.pid()\n\tstat, err := system.Stat(pid)\n\tif err != nil {\n\t\treturn Stopped\n\t}\n\tif stat.StartTime != c.initProcessStartTime || stat.State == system.Zombie || stat.State == system.Dead {\n\t\treturn Stopped\n\t}\n\t// We'll create exec fifo and blocking on it after container is created,\n\t// and delete it after start container.\n\tif _, err := os.Stat(filepath.Join(c.root, execFifoFilename)); err == nil {\n\t\treturn Created\n\t}\n\treturn Running\n}\n\nfunc (c *linuxContainer) isPaused() (bool, error) {\n\tstate, err := c.cgroupManager.GetFreezerState()\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn state == configs.Frozen, nil\n}\n\nfunc (c *linuxContainer) currentState() (*State, error) {\n\tvar (\n\t\tstartTime           uint64\n\t\texternalDescriptors []string\n\t\tpid                 = -1\n\t)\n\tif c.initProcess != nil {\n\t\tpid = c.initProcess.pid()\n\t\tstartTime, _ = c.initProcess.startTime()\n\t\texternalDescriptors = c.initProcess.externalDescriptors()\n\t}\n\n\tintelRdtPath := \"\"\n\tif c.intelRdtManager != nil {\n\t\tintelRdtPath = c.intelRdtManager.GetPath()\n\t}\n\tstate := &State{\n\t\tBaseState: BaseState{\n\t\t\tID:                   c.ID(),\n\t\t\tConfig:               *c.config,\n\t\t\tInitProcessPid:       pid,\n\t\t\tInitProcessStartTime: startTime,\n\t\t\tCreated:              c.created,\n\t\t},\n\t\tRootless:            c.config.RootlessEUID && c.config.RootlessCgroups,\n\t\tCgroupPaths:         c.cgroupManager.GetPaths(),\n\t\tIntelRdtPath:        intelRdtPath,\n\t\tNamespacePaths:      make(map[configs.NamespaceType]string),\n\t\tExternalDescriptors: externalDescriptors,\n\t}\n\tif pid > 0 {\n\t\tfor _, ns := range c.config.Namespaces {\n\t\t\tstate.NamespacePaths[ns.Type] = ns.GetPath(pid)\n\t\t}\n\t\tfor _, nsType := range configs.NamespaceTypes() {\n\t\t\tif !configs.IsNamespaceSupported(nsType) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif _, ok := state.NamespacePaths[nsType]; !ok {\n\t\t\t\tns := configs.Namespace{Type: nsType}\n\t\t\t\tstate.NamespacePaths[ns.Type] = ns.GetPath(pid)\n\t\t\t}\n\t\t}\n\t}\n\treturn state, nil\n}\n\nfunc (c *linuxContainer) currentOCIState() (*specs.State, error) {\n\tbundle, annotations := utils.Annotations(c.config.Labels)\n\tstate := &specs.State{\n\t\tVersion:     specs.Version,\n\t\tID:          c.ID(),\n\t\tBundle:      bundle,\n\t\tAnnotations: annotations,\n\t}\n\tstatus, err := c.currentStatus()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tstate.Status = specs.ContainerState(status.String())\n\tif status != Stopped {\n\t\tif c.initProcess != nil {\n\t\t\tstate.Pid = c.initProcess.pid()\n\t\t}\n\t}\n\treturn state, nil\n}\n\n// orderNamespacePaths sorts namespace paths into a list of paths that we\n// can setns in order.\nfunc (c *linuxContainer) orderNamespacePaths(namespaces map[configs.NamespaceType]string) ([]string, error) {\n\tpaths := []string{}\n\tfor _, ns := range configs.NamespaceTypes() {\n\n\t\t// Remove namespaces that we don't need to join.\n\t\tif !c.config.Namespaces.Contains(ns) {\n\t\t\tcontinue\n\t\t}\n\n\t\tif p, ok := namespaces[ns]; ok && p != \"\" {\n\t\t\t// check if the requested namespace is supported\n\t\t\tif !configs.IsNamespaceSupported(ns) {\n\t\t\t\treturn nil, fmt.Errorf(\"namespace %s is not supported\", ns)\n\t\t\t}\n\t\t\t// only set to join this namespace if it exists\n\t\t\tif _, err := os.Lstat(p); err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"namespace path: %w\", err)\n\t\t\t}\n\t\t\t// do not allow namespace path with comma as we use it to separate\n\t\t\t// the namespace paths\n\t\t\tif strings.ContainsRune(p, ',') {\n\t\t\t\treturn nil, fmt.Errorf(\"invalid namespace path %s\", p)\n\t\t\t}\n\t\t\tpaths = append(paths, fmt.Sprintf(\"%s:%s\", configs.NsName(ns), p))\n\t\t}\n\n\t}\n\n\treturn paths, nil\n}\n\nfunc encodeIDMapping(idMap []configs.IDMap) ([]byte, error) {\n\tdata := bytes.NewBuffer(nil)\n\tfor _, im := range idMap {\n\t\tline := fmt.Sprintf(\"%d %d %d\\n\", im.ContainerID, im.HostID, im.Size)\n\t\tif _, err := data.WriteString(line); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn data.Bytes(), nil\n}\n\n// bootstrapData encodes the necessary data in netlink binary format\n// as a io.Reader.\n// Consumer can write the data to a bootstrap program\n// such as one that uses nsenter package to bootstrap the container's\n// init process correctly, i.e. with correct namespaces, uid/gid\n// mapping etc.\nfunc (c *linuxContainer) bootstrapData(cloneFlags uintptr, nsMaps map[configs.NamespaceType]string, it initType) (io.Reader, error) {\n\t// create the netlink message\n\tr := nl.NewNetlinkRequest(int(InitMsg), 0)\n\n\t// write cloneFlags\n\tr.AddData(&Int32msg{\n\t\tType:  CloneFlagsAttr,\n\t\tValue: uint32(cloneFlags),\n\t})\n\n\t// write custom namespace paths\n\tif len(nsMaps) > 0 {\n\t\tnsPaths, err := c.orderNamespacePaths(nsMaps)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tr.AddData(&Bytemsg{\n\t\t\tType:  NsPathsAttr,\n\t\t\tValue: []byte(strings.Join(nsPaths, \",\")),\n\t\t})\n\t}\n\n\t// write namespace paths only when we are not joining an existing user ns\n\t_, joinExistingUser := nsMaps[configs.NEWUSER]\n\tif !joinExistingUser {\n\t\t// write uid mappings\n\t\tif len(c.config.UidMappings) > 0 {\n\t\t\tif c.config.RootlessEUID && c.newuidmapPath != \"\" {\n\t\t\t\tr.AddData(&Bytemsg{\n\t\t\t\t\tType:  UidmapPathAttr,\n\t\t\t\t\tValue: []byte(c.newuidmapPath),\n\t\t\t\t})\n\t\t\t}\n\t\t\tb, err := encodeIDMapping(c.config.UidMappings)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tr.AddData(&Bytemsg{\n\t\t\t\tType:  UidmapAttr,\n\t\t\t\tValue: b,\n\t\t\t})\n\t\t}\n\n\t\t// write gid mappings\n\t\tif len(c.config.GidMappings) > 0 {\n\t\t\tb, err := encodeIDMapping(c.config.GidMappings)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tr.AddData(&Bytemsg{\n\t\t\t\tType:  GidmapAttr,\n\t\t\t\tValue: b,\n\t\t\t})\n\t\t\tif c.config.RootlessEUID && c.newgidmapPath != \"\" {\n\t\t\t\tr.AddData(&Bytemsg{\n\t\t\t\t\tType:  GidmapPathAttr,\n\t\t\t\t\tValue: []byte(c.newgidmapPath),\n\t\t\t\t})\n\t\t\t}\n\t\t\tif requiresRootOrMappingTool(c.config) {\n\t\t\t\tr.AddData(&Boolmsg{\n\t\t\t\t\tType:  SetgroupAttr,\n\t\t\t\t\tValue: true,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\tif c.config.OomScoreAdj != nil {\n\t\t// write oom_score_adj\n\t\tr.AddData(&Bytemsg{\n\t\t\tType:  OomScoreAdjAttr,\n\t\t\tValue: []byte(strconv.Itoa(*c.config.OomScoreAdj)),\n\t\t})\n\t}\n\n\t// write rootless\n\tr.AddData(&Boolmsg{\n\t\tType:  RootlessEUIDAttr,\n\t\tValue: c.config.RootlessEUID,\n\t})\n\n\t// Bind mount source to open.\n\tif it == initStandard && c.shouldSendMountSources() {\n\t\tvar mounts []byte\n\t\tfor _, m := range c.config.Mounts {\n\t\t\tif m.IsBind() {\n\t\t\t\tmounts = append(mounts, []byte(m.Source)...)\n\t\t\t}\n\t\t\tmounts = append(mounts, byte(0))\n\t\t}\n\n\t\tr.AddData(&Bytemsg{\n\t\t\tType:  MountSourcesAttr,\n\t\t\tValue: mounts,\n\t\t})\n\t}\n\n\treturn bytes.NewReader(r.Serialize()), nil\n}\n\n// ignoreTerminateErrors returns nil if the given err matches an error known\n// to indicate that the terminate occurred successfully or err was nil, otherwise\n// err is returned unaltered.\nfunc ignoreTerminateErrors(err error) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\t// terminate() might return an error from either Kill or Wait.\n\t// The (*Cmd).Wait documentation says: \"If the command fails to run\n\t// or doesn't complete successfully, the error is of type *ExitError\".\n\t// Filter out such errors (like \"exit status 1\" or \"signal: killed\").\n\tvar exitErr *exec.ExitError\n\tif errors.As(err, &exitErr) {\n\t\treturn nil\n\t}\n\t// TODO: use errors.Is(err, os.ErrProcessDone) here and\n\t// remove \"process already finished\" string comparison below\n\t// once go 1.16 is minimally supported version.\n\n\ts := err.Error()\n\tif strings.Contains(s, \"process already finished\") ||\n\t\tstrings.Contains(s, \"Wait was already called\") {\n\t\treturn nil\n\t}\n\treturn err\n}\n\nfunc requiresRootOrMappingTool(c *configs.Config) bool {\n\tgidMap := []configs.IDMap{\n\t\t{ContainerID: 0, HostID: os.Getegid(), Size: 1},\n\t}\n\treturn !reflect.DeepEqual(c.GidMappings, gidMap)\n}\n", "package libcontainer\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"runtime/debug\"\n\t\"strconv\"\n\n\tsecurejoin \"github.com/cyphar/filepath-securejoin\"\n\t\"github.com/moby/sys/mountinfo\"\n\t\"golang.org/x/sys/unix\"\n\n\t\"github.com/opencontainers/runc/libcontainer/cgroups/manager\"\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/opencontainers/runc/libcontainer/configs/validate\"\n\t\"github.com/opencontainers/runc/libcontainer/intelrdt\"\n\t\"github.com/opencontainers/runc/libcontainer/utils\"\n\t\"github.com/sirupsen/logrus\"\n)\n\nconst (\n\tstateFilename    = \"state.json\"\n\texecFifoFilename = \"exec.fifo\"\n)\n\nvar idRegex = regexp.MustCompile(`^[\\w+-\\.]+$`)\n\n// InitArgs returns an options func to configure a LinuxFactory with the\n// provided init binary path and arguments.\nfunc InitArgs(args ...string) func(*LinuxFactory) error {\n\treturn func(l *LinuxFactory) (err error) {\n\t\tif len(args) > 0 {\n\t\t\t// Resolve relative paths to ensure that its available\n\t\t\t// after directory changes.\n\t\t\tif args[0], err = filepath.Abs(args[0]); err != nil {\n\t\t\t\t// The only error returned from filepath.Abs is\n\t\t\t\t// the one from os.Getwd, i.e. a system error.\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tl.InitArgs = args\n\t\treturn nil\n\t}\n}\n\n// IntelRdtfs is an options func to configure a LinuxFactory to return\n// containers that use the Intel RDT \"resource control\" filesystem to\n// create and manage Intel RDT resources (e.g., L3 cache, memory bandwidth).\nfunc IntelRdtFs(l *LinuxFactory) error {\n\tif !intelrdt.IsCATEnabled() && !intelrdt.IsMBAEnabled() {\n\t\tl.NewIntelRdtManager = nil\n\t} else {\n\t\tl.NewIntelRdtManager = func(config *configs.Config, id string, path string) intelrdt.Manager {\n\t\t\treturn intelrdt.NewManager(config, id, path)\n\t\t}\n\t}\n\treturn nil\n}\n\n// TmpfsRoot is an option func to mount LinuxFactory.Root to tmpfs.\nfunc TmpfsRoot(l *LinuxFactory) error {\n\tmounted, err := mountinfo.Mounted(l.Root)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !mounted {\n\t\tif err := mount(\"tmpfs\", l.Root, \"\", \"tmpfs\", 0, \"\"); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// CriuPath returns an option func to configure a LinuxFactory with the\n// provided criupath\nfunc CriuPath(criupath string) func(*LinuxFactory) error {\n\treturn func(l *LinuxFactory) error {\n\t\tl.CriuPath = criupath\n\t\treturn nil\n\t}\n}\n\n// New returns a linux based container factory based in the root directory and\n// configures the factory with the provided option funcs.\nfunc New(root string, options ...func(*LinuxFactory) error) (Factory, error) {\n\tif root != \"\" {\n\t\tif err := os.MkdirAll(root, 0o700); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tl := &LinuxFactory{\n\t\tRoot:      root,\n\t\tInitPath:  \"/proc/self/exe\",\n\t\tInitArgs:  []string{os.Args[0], \"init\"},\n\t\tValidator: validate.New(),\n\t\tCriuPath:  \"criu\",\n\t}\n\n\tfor _, opt := range options {\n\t\tif opt == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif err := opt(l); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn l, nil\n}\n\n// LinuxFactory implements the default factory interface for linux based systems.\ntype LinuxFactory struct {\n\t// Root directory for the factory to store state.\n\tRoot string\n\n\t// InitPath is the path for calling the init responsibilities for spawning\n\t// a container.\n\tInitPath string\n\n\t// InitArgs are arguments for calling the init responsibilities for spawning\n\t// a container.\n\tInitArgs []string\n\n\t// CriuPath is the path to the criu binary used for checkpoint and restore of\n\t// containers.\n\tCriuPath string\n\n\t// New{u,g}idmapPath is the path to the binaries used for mapping with\n\t// rootless containers.\n\tNewuidmapPath string\n\tNewgidmapPath string\n\n\t// Validator provides validation to container configurations.\n\tValidator validate.Validator\n\n\t// NewIntelRdtManager returns an initialized Intel RDT manager for a single container.\n\tNewIntelRdtManager func(config *configs.Config, id string, path string) intelrdt.Manager\n}\n\nfunc (l *LinuxFactory) Create(id string, config *configs.Config) (Container, error) {\n\tif l.Root == \"\" {\n\t\treturn nil, errors.New(\"root not set\")\n\t}\n\tif err := l.validateID(id); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := l.Validator.Validate(config); err != nil {\n\t\treturn nil, err\n\t}\n\tcontainerRoot, err := securejoin.SecureJoin(l.Root, id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif _, err := os.Stat(containerRoot); err == nil {\n\t\treturn nil, ErrExist\n\t} else if !os.IsNotExist(err) {\n\t\treturn nil, err\n\t}\n\tif err := os.MkdirAll(containerRoot, 0o711); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := os.Chown(containerRoot, unix.Geteuid(), unix.Getegid()); err != nil {\n\t\treturn nil, err\n\t}\n\tcm, err := manager.New(config.Cgroups)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tc := &linuxContainer{\n\t\tid:            id,\n\t\troot:          containerRoot,\n\t\tconfig:        config,\n\t\tinitPath:      l.InitPath,\n\t\tinitArgs:      l.InitArgs,\n\t\tcriuPath:      l.CriuPath,\n\t\tnewuidmapPath: l.NewuidmapPath,\n\t\tnewgidmapPath: l.NewgidmapPath,\n\t\tcgroupManager: cm,\n\t}\n\tif l.NewIntelRdtManager != nil {\n\t\tc.intelRdtManager = l.NewIntelRdtManager(config, id, \"\")\n\t}\n\tc.state = &stoppedState{c: c}\n\treturn c, nil\n}\n\nfunc (l *LinuxFactory) Load(id string) (Container, error) {\n\tif l.Root == \"\" {\n\t\treturn nil, errors.New(\"root not set\")\n\t}\n\t// when load, we need to check id is valid or not.\n\tif err := l.validateID(id); err != nil {\n\t\treturn nil, err\n\t}\n\tcontainerRoot, err := securejoin.SecureJoin(l.Root, id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tstate, err := l.loadState(containerRoot, id)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tr := &nonChildProcess{\n\t\tprocessPid:       state.InitProcessPid,\n\t\tprocessStartTime: state.InitProcessStartTime,\n\t\tfds:              state.ExternalDescriptors,\n\t}\n\tcm, err := manager.NewWithPaths(state.Config.Cgroups, state.CgroupPaths)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tc := &linuxContainer{\n\t\tinitProcess:          r,\n\t\tinitProcessStartTime: state.InitProcessStartTime,\n\t\tid:                   id,\n\t\tconfig:               &state.Config,\n\t\tinitPath:             l.InitPath,\n\t\tinitArgs:             l.InitArgs,\n\t\tcriuPath:             l.CriuPath,\n\t\tnewuidmapPath:        l.NewuidmapPath,\n\t\tnewgidmapPath:        l.NewgidmapPath,\n\t\tcgroupManager:        cm,\n\t\troot:                 containerRoot,\n\t\tcreated:              state.Created,\n\t}\n\tif l.NewIntelRdtManager != nil {\n\t\tc.intelRdtManager = l.NewIntelRdtManager(&state.Config, id, state.IntelRdtPath)\n\t}\n\tc.state = &loadedState{c: c}\n\tif err := c.refreshState(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn c, nil\n}\n\nfunc (l *LinuxFactory) Type() string {\n\treturn \"libcontainer\"\n}\n\n// StartInitialization loads a container by opening the pipe fd from the parent to read the configuration and state\n// This is a low level implementation detail of the reexec and should not be consumed externally\nfunc (l *LinuxFactory) StartInitialization() (err error) {\n\t// Get the INITPIPE.\n\tenvInitPipe := os.Getenv(\"_LIBCONTAINER_INITPIPE\")\n\tpipefd, err := strconv.Atoi(envInitPipe)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"unable to convert _LIBCONTAINER_INITPIPE: %w\", err)\n\t\tlogrus.Error(err)\n\t\treturn err\n\t}\n\tpipe := os.NewFile(uintptr(pipefd), \"pipe\")\n\tdefer pipe.Close()\n\n\tdefer func() {\n\t\t// We have an error during the initialization of the container's init,\n\t\t// send it back to the parent process in the form of an initError.\n\t\tif werr := writeSync(pipe, procError); werr != nil {\n\t\t\tfmt.Fprintln(os.Stderr, err)\n\t\t\treturn\n\t\t}\n\t\tif werr := utils.WriteJSON(pipe, &initError{Message: err.Error()}); werr != nil {\n\t\t\tfmt.Fprintln(os.Stderr, err)\n\t\t\treturn\n\t\t}\n\t}()\n\n\t// Only init processes have FIFOFD.\n\tfifofd := -1\n\tenvInitType := os.Getenv(\"_LIBCONTAINER_INITTYPE\")\n\tit := initType(envInitType)\n\tif it == initStandard {\n\t\tenvFifoFd := os.Getenv(\"_LIBCONTAINER_FIFOFD\")\n\t\tif fifofd, err = strconv.Atoi(envFifoFd); err != nil {\n\t\t\treturn fmt.Errorf(\"unable to convert _LIBCONTAINER_FIFOFD: %w\", err)\n\t\t}\n\t}\n\n\tvar consoleSocket *os.File\n\tif envConsole := os.Getenv(\"_LIBCONTAINER_CONSOLE\"); envConsole != \"\" {\n\t\tconsole, err := strconv.Atoi(envConsole)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to convert _LIBCONTAINER_CONSOLE: %w\", err)\n\t\t}\n\t\tconsoleSocket = os.NewFile(uintptr(console), \"console-socket\")\n\t\tdefer consoleSocket.Close()\n\t}\n\n\tlogPipeFdStr := os.Getenv(\"_LIBCONTAINER_LOGPIPE\")\n\tlogPipeFd, err := strconv.Atoi(logPipeFdStr)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to convert _LIBCONTAINER_LOGPIPE: %w\", err)\n\t}\n\n\t// Get mount files (O_PATH).\n\tmountFds, err := parseMountFds()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// clear the current process's environment to clean any libcontainer\n\t// specific env vars.\n\tos.Clearenv()\n\n\tdefer func() {\n\t\tif e := recover(); e != nil {\n\t\t\terr = fmt.Errorf(\"panic from initialization: %w, %v\", e, string(debug.Stack()))\n\t\t}\n\t}()\n\n\ti, err := newContainerInit(it, pipe, consoleSocket, fifofd, logPipeFd, mountFds)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// If Init succeeds, syscall.Exec will not return, hence none of the defers will be called.\n\treturn i.Init()\n}\n\nfunc (l *LinuxFactory) loadState(root, id string) (*State, error) {\n\tstateFilePath, err := securejoin.SecureJoin(root, stateFilename)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tf, err := os.Open(stateFilePath)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn nil, ErrNotExist\n\t\t}\n\t\treturn nil, err\n\t}\n\tdefer f.Close()\n\tvar state *State\n\tif err := json.NewDecoder(f).Decode(&state); err != nil {\n\t\treturn nil, err\n\t}\n\treturn state, nil\n}\n\nfunc (l *LinuxFactory) validateID(id string) error {\n\tif !idRegex.MatchString(id) || string(os.PathSeparator)+id != utils.CleanPath(string(os.PathSeparator)+id) {\n\t\treturn ErrInvalidID\n\t}\n\n\treturn nil\n}\n\n// NewuidmapPath returns an option func to configure a LinuxFactory with the\n// provided ..\nfunc NewuidmapPath(newuidmapPath string) func(*LinuxFactory) error {\n\treturn func(l *LinuxFactory) error {\n\t\tl.NewuidmapPath = newuidmapPath\n\t\treturn nil\n\t}\n}\n\n// NewgidmapPath returns an option func to configure a LinuxFactory with the\n// provided ..\nfunc NewgidmapPath(newgidmapPath string) func(*LinuxFactory) error {\n\treturn func(l *LinuxFactory) error {\n\t\tl.NewgidmapPath = newgidmapPath\n\t\treturn nil\n\t}\n}\n\nfunc parseMountFds() ([]int, error) {\n\tfdsJson := os.Getenv(\"_LIBCONTAINER_MOUNT_FDS\")\n\tif fdsJson == \"\" {\n\t\t// Always return the nil slice if no fd is present.\n\t\treturn nil, nil\n\t}\n\n\tvar mountFds []int\n\tif err := json.Unmarshal([]byte(fdsJson), &mountFds); err != nil {\n\t\treturn nil, fmt.Errorf(\"Error unmarshalling _LIBCONTAINER_MOUNT_FDS: %w\", err)\n\t}\n\n\treturn mountFds, nil\n}\n", "package libcontainer\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"os\"\n\t\"strings\"\n\t\"unsafe\"\n\n\t\"github.com/containerd/console\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/vishvananda/netlink\"\n\t\"golang.org/x/sys/unix\"\n\n\t\"github.com/opencontainers/runc/libcontainer/capabilities\"\n\t\"github.com/opencontainers/runc/libcontainer/cgroups\"\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/opencontainers/runc/libcontainer/system\"\n\t\"github.com/opencontainers/runc/libcontainer/user\"\n\t\"github.com/opencontainers/runc/libcontainer/utils\"\n)\n\ntype initType string\n\nconst (\n\tinitSetns    initType = \"setns\"\n\tinitStandard initType = \"standard\"\n)\n\ntype pid struct {\n\tPid           int `json:\"stage2_pid\"`\n\tPidFirstChild int `json:\"stage1_pid\"`\n}\n\n// network is an internal struct used to setup container networks.\ntype network struct {\n\tconfigs.Network\n\n\t// TempVethPeerName is a unique temporary veth peer name that was placed into\n\t// the container's namespace.\n\tTempVethPeerName string `json:\"temp_veth_peer_name\"`\n}\n\n// initConfig is used for transferring parameters from Exec() to Init()\ntype initConfig struct {\n\tArgs             []string              `json:\"args\"`\n\tEnv              []string              `json:\"env\"`\n\tCwd              string                `json:\"cwd\"`\n\tCapabilities     *configs.Capabilities `json:\"capabilities\"`\n\tProcessLabel     string                `json:\"process_label\"`\n\tAppArmorProfile  string                `json:\"apparmor_profile\"`\n\tNoNewPrivileges  bool                  `json:\"no_new_privileges\"`\n\tUser             string                `json:\"user\"`\n\tAdditionalGroups []string              `json:\"additional_groups\"`\n\tConfig           *configs.Config       `json:\"config\"`\n\tNetworks         []*network            `json:\"network\"`\n\tPassedFilesCount int                   `json:\"passed_files_count\"`\n\tContainerId      string                `json:\"containerid\"`\n\tRlimits          []configs.Rlimit      `json:\"rlimits\"`\n\tCreateConsole    bool                  `json:\"create_console\"`\n\tConsoleWidth     uint16                `json:\"console_width\"`\n\tConsoleHeight    uint16                `json:\"console_height\"`\n\tRootlessEUID     bool                  `json:\"rootless_euid,omitempty\"`\n\tRootlessCgroups  bool                  `json:\"rootless_cgroups,omitempty\"`\n\tSpecState        *specs.State          `json:\"spec_state,omitempty\"`\n\tCgroup2Path      string                `json:\"cgroup2_path,omitempty\"`\n}\n\ntype initer interface {\n\tInit() error\n}\n\nfunc newContainerInit(t initType, pipe *os.File, consoleSocket *os.File, fifoFd, logFd int, mountFds []int) (initer, error) {\n\tvar config *initConfig\n\tif err := json.NewDecoder(pipe).Decode(&config); err != nil {\n\t\treturn nil, err\n\t}\n\tif err := populateProcessEnvironment(config.Env); err != nil {\n\t\treturn nil, err\n\t}\n\tswitch t {\n\tcase initSetns:\n\t\t// mountFds must be nil in this case. We don't mount while doing runc exec.\n\t\tif mountFds != nil {\n\t\t\treturn nil, errors.New(\"mountFds must be nil. Can't mount while doing runc exec.\")\n\t\t}\n\n\t\treturn &linuxSetnsInit{\n\t\t\tpipe:          pipe,\n\t\t\tconsoleSocket: consoleSocket,\n\t\t\tconfig:        config,\n\t\t\tlogFd:         logFd,\n\t\t}, nil\n\tcase initStandard:\n\t\treturn &linuxStandardInit{\n\t\t\tpipe:          pipe,\n\t\t\tconsoleSocket: consoleSocket,\n\t\t\tparentPid:     unix.Getppid(),\n\t\t\tconfig:        config,\n\t\t\tfifoFd:        fifoFd,\n\t\t\tlogFd:         logFd,\n\t\t\tmountFds:      mountFds,\n\t\t}, nil\n\t}\n\treturn nil, fmt.Errorf(\"unknown init type %q\", t)\n}\n\n// populateProcessEnvironment loads the provided environment variables into the\n// current processes's environment.\nfunc populateProcessEnvironment(env []string) error {\n\tfor _, pair := range env {\n\t\tp := strings.SplitN(pair, \"=\", 2)\n\t\tif len(p) < 2 {\n\t\t\treturn fmt.Errorf(\"invalid environment variable: %q\", pair)\n\t\t}\n\t\tname, val := p[0], p[1]\n\t\tif name == \"\" {\n\t\t\treturn fmt.Errorf(\"environment variable name can't be empty: %q\", pair)\n\t\t}\n\t\tif strings.IndexByte(name, 0) >= 0 {\n\t\t\treturn fmt.Errorf(\"environment variable name can't contain null(\\\\x00): %q\", pair)\n\t\t}\n\t\tif strings.IndexByte(val, 0) >= 0 {\n\t\t\treturn fmt.Errorf(\"environment variable value can't contain null(\\\\x00): %q\", pair)\n\t\t}\n\t\tif err := os.Setenv(name, val); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// finalizeNamespace drops the caps, sets the correct user\n// and working dir, and closes any leaked file descriptors\n// before executing the command inside the namespace\nfunc finalizeNamespace(config *initConfig) error {\n\t// Ensure that all unwanted fds we may have accidentally\n\t// inherited are marked close-on-exec so they stay out of the\n\t// container\n\tif err := utils.CloseExecFrom(config.PassedFilesCount + 3); err != nil {\n\t\treturn fmt.Errorf(\"error closing exec fds: %w\", err)\n\t}\n\n\t// we only do chdir if it's specified\n\tdoChdir := config.Cwd != \"\"\n\tif doChdir {\n\t\t// First, attempt the chdir before setting up the user.\n\t\t// This could allow us to access a directory that the user running runc can access\n\t\t// but the container user cannot.\n\t\terr := unix.Chdir(config.Cwd)\n\t\tswitch {\n\t\tcase err == nil:\n\t\t\tdoChdir = false\n\t\tcase os.IsPermission(err):\n\t\t\t// If we hit an EPERM, we should attempt again after setting up user.\n\t\t\t// This will allow us to successfully chdir if the container user has access\n\t\t\t// to the directory, but the user running runc does not.\n\t\t\t// This is useful in cases where the cwd is also a volume that's been chowned to the container user.\n\t\tdefault:\n\t\t\treturn fmt.Errorf(\"chdir to cwd (%q) set in config.json failed: %w\", config.Cwd, err)\n\t\t}\n\t}\n\n\tcaps := &configs.Capabilities{}\n\tif config.Capabilities != nil {\n\t\tcaps = config.Capabilities\n\t} else if config.Config.Capabilities != nil {\n\t\tcaps = config.Config.Capabilities\n\t}\n\tw, err := capabilities.New(caps)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// drop capabilities in bounding set before changing user\n\tif err := w.ApplyBoundingSet(); err != nil {\n\t\treturn fmt.Errorf(\"unable to apply bounding set: %w\", err)\n\t}\n\t// preserve existing capabilities while we change users\n\tif err := system.SetKeepCaps(); err != nil {\n\t\treturn fmt.Errorf(\"unable to set keep caps: %w\", err)\n\t}\n\tif err := setupUser(config); err != nil {\n\t\treturn fmt.Errorf(\"unable to setup user: %w\", err)\n\t}\n\t// Change working directory AFTER the user has been set up, if we haven't done it yet.\n\tif doChdir {\n\t\tif err := unix.Chdir(config.Cwd); err != nil {\n\t\t\treturn fmt.Errorf(\"chdir to cwd (%q) set in config.json failed: %w\", config.Cwd, err)\n\t\t}\n\t}\n\tif err := system.ClearKeepCaps(); err != nil {\n\t\treturn fmt.Errorf(\"unable to clear keep caps: %w\", err)\n\t}\n\tif err := w.ApplyCaps(); err != nil {\n\t\treturn fmt.Errorf(\"unable to apply caps: %w\", err)\n\t}\n\treturn nil\n}\n\n// setupConsole sets up the console from inside the container, and sends the\n// master pty fd to the config.Pipe (using cmsg). This is done to ensure that\n// consoles are scoped to a container properly (see runc#814 and the many\n// issues related to that). This has to be run *after* we've pivoted to the new\n// rootfs (and the users' configuration is entirely set up).\nfunc setupConsole(socket *os.File, config *initConfig, mount bool) error {\n\tdefer socket.Close()\n\t// At this point, /dev/ptmx points to something that we would expect. We\n\t// used to change the owner of the slave path, but since the /dev/pts mount\n\t// can have gid=X set (at the users' option). So touching the owner of the\n\t// slave PTY is not necessary, as the kernel will handle that for us. Note\n\t// however, that setupUser (specifically fixStdioPermissions) *will* change\n\t// the UID owner of the console to be the user the process will run as (so\n\t// they can actually control their console).\n\n\tpty, slavePath, err := console.NewPty()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// After we return from here, we don't need the console anymore.\n\tdefer pty.Close()\n\n\tif config.ConsoleHeight != 0 && config.ConsoleWidth != 0 {\n\t\terr = pty.Resize(console.WinSize{\n\t\t\tHeight: config.ConsoleHeight,\n\t\t\tWidth:  config.ConsoleWidth,\n\t\t})\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Mount the console inside our rootfs.\n\tif mount {\n\t\tif err := mountConsole(slavePath); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t// While we can access console.master, using the API is a good idea.\n\tif err := utils.SendFd(socket, pty.Name(), pty.Fd()); err != nil {\n\t\treturn err\n\t}\n\t// Now, dup over all the things.\n\treturn dupStdio(slavePath)\n}\n\n// syncParentReady sends to the given pipe a JSON payload which indicates that\n// the init is ready to Exec the child process. It then waits for the parent to\n// indicate that it is cleared to Exec.\nfunc syncParentReady(pipe io.ReadWriter) error {\n\t// Tell parent.\n\tif err := writeSync(pipe, procReady); err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for parent to give the all-clear.\n\treturn readSync(pipe, procRun)\n}\n\n// syncParentHooks sends to the given pipe a JSON payload which indicates that\n// the parent should execute pre-start hooks. It then waits for the parent to\n// indicate that it is cleared to resume.\nfunc syncParentHooks(pipe io.ReadWriter) error {\n\t// Tell parent.\n\tif err := writeSync(pipe, procHooks); err != nil {\n\t\treturn err\n\t}\n\n\t// Wait for parent to give the all-clear.\n\treturn readSync(pipe, procResume)\n}\n\n// syncParentSeccomp sends to the given pipe a JSON payload which\n// indicates that the parent should pick up the seccomp fd with pidfd_getfd()\n// and send it to the seccomp agent over a unix socket. It then waits for\n// the parent to indicate that it is cleared to resume and closes the seccompFd.\n// If the seccompFd is -1, there isn't anything to sync with the parent, so it\n// returns no error.\nfunc syncParentSeccomp(pipe io.ReadWriter, seccompFd int) error {\n\tif seccompFd == -1 {\n\t\treturn nil\n\t}\n\n\t// Tell parent.\n\tif err := writeSyncWithFd(pipe, procSeccomp, seccompFd); err != nil {\n\t\tunix.Close(seccompFd)\n\t\treturn err\n\t}\n\n\t// Wait for parent to give the all-clear.\n\tif err := readSync(pipe, procSeccompDone); err != nil {\n\t\tunix.Close(seccompFd)\n\t\treturn fmt.Errorf(\"sync parent seccomp: %w\", err)\n\t}\n\n\tif err := unix.Close(seccompFd); err != nil {\n\t\treturn fmt.Errorf(\"close seccomp fd: %w\", err)\n\t}\n\n\treturn nil\n}\n\n// setupUser changes the groups, gid, and uid for the user inside the container\nfunc setupUser(config *initConfig) error {\n\t// Set up defaults.\n\tdefaultExecUser := user.ExecUser{\n\t\tUid:  0,\n\t\tGid:  0,\n\t\tHome: \"/\",\n\t}\n\n\tpasswdPath, err := user.GetPasswdPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tgroupPath, err := user.GetGroupPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\texecUser, err := user.GetExecUserPath(config.User, &defaultExecUser, passwdPath, groupPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar addGroups []int\n\tif len(config.AdditionalGroups) > 0 {\n\t\taddGroups, err = user.GetAdditionalGroupsPath(config.AdditionalGroups, groupPath)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Rather than just erroring out later in setuid(2) and setgid(2), check\n\t// that the user is mapped here.\n\tif _, err := config.Config.HostUID(execUser.Uid); err != nil {\n\t\treturn errors.New(\"cannot set uid to unmapped user in user namespace\")\n\t}\n\tif _, err := config.Config.HostGID(execUser.Gid); err != nil {\n\t\treturn errors.New(\"cannot set gid to unmapped user in user namespace\")\n\t}\n\n\tif config.RootlessEUID {\n\t\t// We cannot set any additional groups in a rootless container and thus\n\t\t// we bail if the user asked us to do so. TODO: We currently can't do\n\t\t// this check earlier, but if libcontainer.Process.User was typesafe\n\t\t// this might work.\n\t\tif len(addGroups) > 0 {\n\t\t\treturn errors.New(\"cannot set any additional groups in a rootless container\")\n\t\t}\n\t}\n\n\t// Before we change to the container's user make sure that the processes\n\t// STDIO is correctly owned by the user that we are switching to.\n\tif err := fixStdioPermissions(config, execUser); err != nil {\n\t\treturn err\n\t}\n\n\tsetgroups, err := ioutil.ReadFile(\"/proc/self/setgroups\")\n\tif err != nil && !os.IsNotExist(err) {\n\t\treturn err\n\t}\n\n\t// This isn't allowed in an unprivileged user namespace since Linux 3.19.\n\t// There's nothing we can do about /etc/group entries, so we silently\n\t// ignore setting groups here (since the user didn't explicitly ask us to\n\t// set the group).\n\tallowSupGroups := !config.RootlessEUID && string(bytes.TrimSpace(setgroups)) != \"deny\"\n\n\tif allowSupGroups {\n\t\tsuppGroups := append(execUser.Sgids, addGroups...)\n\t\tif err := unix.Setgroups(suppGroups); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := system.Setgid(execUser.Gid); err != nil {\n\t\treturn err\n\t}\n\tif err := system.Setuid(execUser.Uid); err != nil {\n\t\treturn err\n\t}\n\n\t// if we didn't get HOME already, set it based on the user's HOME\n\tif envHome := os.Getenv(\"HOME\"); envHome == \"\" {\n\t\tif err := os.Setenv(\"HOME\", execUser.Home); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// fixStdioPermissions fixes the permissions of PID 1's STDIO within the container to the specified user.\n// The ownership needs to match because it is created outside of the container and needs to be\n// localized.\nfunc fixStdioPermissions(config *initConfig, u *user.ExecUser) error {\n\tvar null unix.Stat_t\n\tif err := unix.Stat(\"/dev/null\", &null); err != nil {\n\t\treturn err\n\t}\n\tfor _, fd := range []uintptr{\n\t\tos.Stdin.Fd(),\n\t\tos.Stderr.Fd(),\n\t\tos.Stdout.Fd(),\n\t} {\n\t\tvar s unix.Stat_t\n\t\tif err := unix.Fstat(int(fd), &s); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Skip chown of /dev/null if it was used as one of the STDIO fds.\n\t\tif s.Rdev == null.Rdev {\n\t\t\tcontinue\n\t\t}\n\n\t\t// We only change the uid owner (as it is possible for the mount to\n\t\t// prefer a different gid, and there's no reason for us to change it).\n\t\t// The reason why we don't just leave the default uid=X mount setup is\n\t\t// that users expect to be able to actually use their console. Without\n\t\t// this code, you couldn't effectively run as a non-root user inside a\n\t\t// container and also have a console set up.\n\t\tif err := unix.Fchown(int(fd), u.Uid, int(s.Gid)); err != nil {\n\t\t\t// If we've hit an EINVAL then s.Gid isn't mapped in the user\n\t\t\t// namespace. If we've hit an EPERM then the inode's current owner\n\t\t\t// is not mapped in our user namespace (in particular,\n\t\t\t// privileged_wrt_inode_uidgid() has failed). In either case, we\n\t\t\t// are in a configuration where it's better for us to just not\n\t\t\t// touch the stdio rather than bail at this point.\n\n\t\t\t// nolint:errorlint // unix errors are bare\n\t\t\tif err == unix.EINVAL || err == unix.EPERM {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// setupNetwork sets up and initializes any network interface inside the container.\nfunc setupNetwork(config *initConfig) error {\n\tfor _, config := range config.Networks {\n\t\tstrategy, err := getStrategy(config.Type)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := strategy.initialize(config); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc setupRoute(config *configs.Config) error {\n\tfor _, config := range config.Routes {\n\t\t_, dst, err := net.ParseCIDR(config.Destination)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsrc := net.ParseIP(config.Source)\n\t\tif src == nil {\n\t\t\treturn fmt.Errorf(\"Invalid source for route: %s\", config.Source)\n\t\t}\n\t\tgw := net.ParseIP(config.Gateway)\n\t\tif gw == nil {\n\t\t\treturn fmt.Errorf(\"Invalid gateway for route: %s\", config.Gateway)\n\t\t}\n\t\tl, err := netlink.LinkByName(config.InterfaceName)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\troute := &netlink.Route{\n\t\t\tScope:     netlink.SCOPE_UNIVERSE,\n\t\t\tDst:       dst,\n\t\t\tSrc:       src,\n\t\t\tGw:        gw,\n\t\t\tLinkIndex: l.Attrs().Index,\n\t\t}\n\t\tif err := netlink.RouteAdd(route); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc setupRlimits(limits []configs.Rlimit, pid int) error {\n\tfor _, rlimit := range limits {\n\t\tif err := system.Prlimit(pid, rlimit.Type, unix.Rlimit{Max: rlimit.Hard, Cur: rlimit.Soft}); err != nil {\n\t\t\treturn fmt.Errorf(\"error setting rlimit type %v: %w\", rlimit.Type, err)\n\t\t}\n\t}\n\treturn nil\n}\n\nconst _P_PID = 1\n\n//nolint:structcheck,unused\ntype siginfo struct {\n\tsi_signo int32\n\tsi_errno int32\n\tsi_code  int32\n\t// below here is a union; si_pid is the only field we use\n\tsi_pid int32\n\t// Pad to 128 bytes as detailed in blockUntilWaitable\n\tpad [96]byte\n}\n\n// isWaitable returns true if the process has exited false otherwise.\n// Its based off blockUntilWaitable in src/os/wait_waitid.go\nfunc isWaitable(pid int) (bool, error) {\n\tsi := &siginfo{}\n\t_, _, e := unix.Syscall6(unix.SYS_WAITID, _P_PID, uintptr(pid), uintptr(unsafe.Pointer(si)), unix.WEXITED|unix.WNOWAIT|unix.WNOHANG, 0, 0)\n\tif e != 0 {\n\t\treturn false, os.NewSyscallError(\"waitid\", e)\n\t}\n\n\treturn si.si_pid != 0, nil\n}\n\n// signalAllProcesses freezes then iterates over all the processes inside the\n// manager's cgroups sending the signal s to them.\n// If s is SIGKILL then it will wait for each process to exit.\n// For all other signals it will check if the process is ready to report its\n// exit status and only if it is will a wait be performed.\nfunc signalAllProcesses(m cgroups.Manager, s os.Signal) error {\n\tvar procs []*os.Process\n\tif err := m.Freeze(configs.Frozen); err != nil {\n\t\tlogrus.Warn(err)\n\t}\n\tpids, err := m.GetAllPids()\n\tif err != nil {\n\t\tif err := m.Freeze(configs.Thawed); err != nil {\n\t\t\tlogrus.Warn(err)\n\t\t}\n\t\treturn err\n\t}\n\tfor _, pid := range pids {\n\t\tp, err := os.FindProcess(pid)\n\t\tif err != nil {\n\t\t\tlogrus.Warn(err)\n\t\t\tcontinue\n\t\t}\n\t\tprocs = append(procs, p)\n\t\tif err := p.Signal(s); err != nil {\n\t\t\tlogrus.Warn(err)\n\t\t}\n\t}\n\tif err := m.Freeze(configs.Thawed); err != nil {\n\t\tlogrus.Warn(err)\n\t}\n\n\tsubreaper, err := system.GetSubreaper()\n\tif err != nil {\n\t\t// The error here means that PR_GET_CHILD_SUBREAPER is not\n\t\t// supported because this code might run on a kernel older\n\t\t// than 3.4. We don't want to throw an error in that case,\n\t\t// and we simplify things, considering there is no subreaper\n\t\t// set.\n\t\tsubreaper = 0\n\t}\n\n\tfor _, p := range procs {\n\t\tif s != unix.SIGKILL {\n\t\t\tif ok, err := isWaitable(p.Pid); err != nil {\n\t\t\t\tif !errors.Is(err, unix.ECHILD) {\n\t\t\t\t\tlogrus.Warn(\"signalAllProcesses: \", p.Pid, err)\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t} else if !ok {\n\t\t\t\t// Not ready to report so don't wait\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\t// In case a subreaper has been setup, this code must not\n\t\t// wait for the process. Otherwise, we cannot be sure the\n\t\t// current process will be reaped by the subreaper, while\n\t\t// the subreaper might be waiting for this process in order\n\t\t// to retrieve its exit code.\n\t\tif subreaper == 0 {\n\t\t\tif _, err := p.Wait(); err != nil {\n\t\t\t\tif !errors.Is(err, unix.ECHILD) {\n\t\t\t\t\tlogrus.Warn(\"wait: \", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n", "package libcontainer\n\nimport (\n\t\"github.com/vishvananda/netlink/nl\"\n\t\"golang.org/x/sys/unix\"\n)\n\n// list of known message types we want to send to bootstrap program\n// The number is randomly chosen to not conflict with known netlink types\nconst (\n\tInitMsg          uint16 = 62000\n\tCloneFlagsAttr   uint16 = 27281\n\tNsPathsAttr      uint16 = 27282\n\tUidmapAttr       uint16 = 27283\n\tGidmapAttr       uint16 = 27284\n\tSetgroupAttr     uint16 = 27285\n\tOomScoreAdjAttr  uint16 = 27286\n\tRootlessEUIDAttr uint16 = 27287\n\tUidmapPathAttr   uint16 = 27288\n\tGidmapPathAttr   uint16 = 27289\n\tMountSourcesAttr uint16 = 27290\n)\n\ntype Int32msg struct {\n\tType  uint16\n\tValue uint32\n}\n\n// Serialize serializes the message.\n// Int32msg has the following representation\n// | nlattr len | nlattr type |\n// | uint32 value             |\nfunc (msg *Int32msg) Serialize() []byte {\n\tbuf := make([]byte, msg.Len())\n\tnative := nl.NativeEndian()\n\tnative.PutUint16(buf[0:2], uint16(msg.Len()))\n\tnative.PutUint16(buf[2:4], msg.Type)\n\tnative.PutUint32(buf[4:8], msg.Value)\n\treturn buf\n}\n\nfunc (msg *Int32msg) Len() int {\n\treturn unix.NLA_HDRLEN + 4\n}\n\n// Bytemsg has the following representation\n// | nlattr len | nlattr type |\n// | value              | pad |\ntype Bytemsg struct {\n\tType  uint16\n\tValue []byte\n}\n\nfunc (msg *Bytemsg) Serialize() []byte {\n\tl := msg.Len()\n\tbuf := make([]byte, (l+unix.NLA_ALIGNTO-1) & ^(unix.NLA_ALIGNTO-1))\n\tnative := nl.NativeEndian()\n\tnative.PutUint16(buf[0:2], uint16(l))\n\tnative.PutUint16(buf[2:4], msg.Type)\n\tcopy(buf[4:], msg.Value)\n\treturn buf\n}\n\nfunc (msg *Bytemsg) Len() int {\n\treturn unix.NLA_HDRLEN + len(msg.Value) + 1 // null-terminated\n}\n\ntype Boolmsg struct {\n\tType  uint16\n\tValue bool\n}\n\nfunc (msg *Boolmsg) Serialize() []byte {\n\tbuf := make([]byte, msg.Len())\n\tnative := nl.NativeEndian()\n\tnative.PutUint16(buf[0:2], uint16(msg.Len()))\n\tnative.PutUint16(buf[2:4], msg.Type)\n\tif msg.Value {\n\t\tnative.PutUint32(buf[4:8], uint32(1))\n\t} else {\n\t\tnative.PutUint32(buf[4:8], uint32(0))\n\t}\n\treturn buf\n}\n\nfunc (msg *Boolmsg) Len() int {\n\treturn unix.NLA_HDRLEN + 4 // alignment\n}\n", "\n#define _GNU_SOURCE\n#include <endian.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <grp.h>\n#include <limits.h>\n#include <sched.h>\n#include <setjmp.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <unistd.h>\n\n#include <sys/ioctl.h>\n#include <sys/prctl.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n\n#include <linux/limits.h>\n#include <linux/netlink.h>\n#include <linux/types.h>\n\n/* Get all of the CLONE_NEW* flags. */\n#include \"namespace.h\"\n\nextern char *escape_json_string(char *str);\n\n/* Synchronisation values. */\nenum sync_t {\n\tSYNC_USERMAP_PLS = 0x40,\t/* Request parent to map our users. */\n\tSYNC_USERMAP_ACK = 0x41,\t/* Mapping finished by the parent. */\n\tSYNC_RECVPID_PLS = 0x42,\t/* Tell parent we're sending the PID. */\n\tSYNC_RECVPID_ACK = 0x43,\t/* PID was correctly received by parent. */\n\tSYNC_GRANDCHILD = 0x44,\t/* The grandchild is ready to run. */\n\tSYNC_CHILD_FINISH = 0x45,\t/* The child or grandchild has finished. */\n\tSYNC_MOUNTSOURCES_PLS = 0x46,\t/* Tell parent to send mount sources by SCM_RIGHTS. */\n\tSYNC_MOUNTSOURCES_ACK = 0x47,\t/* All mount sources have been sent. */\n};\n\n#define STAGE_SETUP  -1\n/* longjmp() arguments. */\n#define STAGE_PARENT  0\n#define STAGE_CHILD   1\n#define STAGE_INIT    2\n\n/* Stores the current stage of nsexec. */\nint current_stage = STAGE_SETUP;\n\n/* Assume the stack grows down, so arguments should be above it. */\nstruct clone_t {\n\t/*\n\t * Reserve some space for clone() to locate arguments\n\t * and retcode in this place\n\t */\n\tchar stack[4096] __attribute__((aligned(16)));\n\tchar stack_ptr[0];\n\n\t/* There's two children. This is used to execute the different code. */\n\tjmp_buf *env;\n\tint jmpval;\n};\n\nstruct nlconfig_t {\n\tchar *data;\n\n\t/* Process settings. */\n\tuint32_t cloneflags;\n\tchar *oom_score_adj;\n\tsize_t oom_score_adj_len;\n\n\t/* User namespace settings. */\n\tchar *uidmap;\n\tsize_t uidmap_len;\n\tchar *gidmap;\n\tsize_t gidmap_len;\n\tchar *namespaces;\n\tsize_t namespaces_len;\n\tuint8_t is_setgroup;\n\n\t/* Rootless container settings. */\n\tuint8_t is_rootless_euid;\t/* boolean */\n\tchar *uidmappath;\n\tsize_t uidmappath_len;\n\tchar *gidmappath;\n\tsize_t gidmappath_len;\n\n\t/* Mount sources opened outside the container userns. */\n\tchar *mountsources;\n\tsize_t mountsources_len;\n};\n\n/*\n * Log levels are the same as in logrus.\n */\n#define PANIC   0\n#define FATAL   1\n#define ERROR   2\n#define WARNING 3\n#define INFO    4\n#define DEBUG   5\n#define TRACE   6\n\nstatic const char *level_str[] = { \"panic\", \"fatal\", \"error\", \"warning\", \"info\", \"debug\", \"trace\" };\n\nstatic int logfd = -1;\nstatic int loglevel = DEBUG;\n\n/*\n * List of netlink message types sent to us as part of bootstrapping the init.\n * These constants are defined in libcontainer/message_linux.go.\n */\n#define INIT_MSG\t\t62000\n#define CLONE_FLAGS_ATTR\t27281\n#define NS_PATHS_ATTR\t\t27282\n#define UIDMAP_ATTR\t\t27283\n#define GIDMAP_ATTR\t\t27284\n#define SETGROUP_ATTR\t\t27285\n#define OOM_SCORE_ADJ_ATTR\t27286\n#define ROOTLESS_EUID_ATTR\t27287\n#define UIDMAPPATH_ATTR\t\t27288\n#define GIDMAPPATH_ATTR\t\t27289\n#define MOUNT_SOURCES_ATTR\t27290\n\n/*\n * Use the raw syscall for versions of glibc which don't include a function for\n * it, namely (glibc 2.12).\n */\n#if __GLIBC__ == 2 && __GLIBC_MINOR__ < 14\n#  define _GNU_SOURCE\n#  include \"syscall.h\"\n#  if !defined(SYS_setns) && defined(__NR_setns)\n#    define SYS_setns __NR_setns\n#  endif\n\n#  ifndef SYS_setns\n#    error \"setns(2) syscall not supported by glibc version\"\n#  endif\n\nint setns(int fd, int nstype)\n{\n\treturn syscall(SYS_setns, fd, nstype);\n}\n#endif\n\nstatic void write_log(int level, const char *format, ...)\n{\n\tchar *message = NULL, *stage = NULL, *json = NULL;\n\tva_list args;\n\tint ret;\n\n\tif (logfd < 0 || level > loglevel)\n\t\tgoto out;\n\n\tva_start(args, format);\n\tret = vasprintf(&message, format, args);\n\tva_end(args);\n\tif (ret < 0) {\n\t\tmessage = NULL;\n\t\tgoto out;\n\t}\n\n\tmessage = escape_json_string(message);\n\n\tif (current_stage == STAGE_SETUP)\n\t\tstage = strdup(\"nsexec\");\n\telse\n\t\tret = asprintf(&stage, \"nsexec-%d\", current_stage);\n\tif (ret < 0) {\n\t\tstage = NULL;\n\t\tgoto out;\n\t}\n\n\tret = asprintf(&json, \"{\\\"level\\\":\\\"%s\\\", \\\"msg\\\": \\\"%s[%d]: %s\\\"}\\n\",\n\t\t       level_str[level], stage, getpid(), message);\n\tif (ret < 0) {\n\t\tjson = NULL;\n\t\tgoto out;\n\t}\n\n\t/* This logging is on a best-effort basis. In case of a short or failed\n\t * write there is nothing we can do, so just ignore write() errors.\n\t */\n\tssize_t __attribute__((unused)) __res = write(logfd, json, ret);\n\nout:\n\tfree(message);\n\tfree(stage);\n\tfree(json);\n}\n\n/* XXX: This is ugly. */\nstatic int syncfd = -1;\n\n#define bail(fmt, ...)                                               \\\n\tdo {                                                         \\\n\t\tif (logfd < 0)                                       \\\n\t\t\tfprintf(stderr, \"FATAL: \" fmt \": %m\\n\",      \\\n\t\t\t\t##__VA_ARGS__);                      \\\n\t\telse                                                 \\\n\t\t\twrite_log(FATAL, fmt \": %m\", ##__VA_ARGS__); \\\n\t\texit(1);                                             \\\n\t} while(0)\n\nstatic int write_file(char *data, size_t data_len, char *pathfmt, ...)\n{\n\tint fd, len, ret = 0;\n\tchar path[PATH_MAX];\n\n\tva_list ap;\n\tva_start(ap, pathfmt);\n\tlen = vsnprintf(path, PATH_MAX, pathfmt, ap);\n\tva_end(ap);\n\tif (len < 0)\n\t\treturn -1;\n\n\tfd = open(path, O_RDWR);\n\tif (fd < 0) {\n\t\treturn -1;\n\t}\n\n\tlen = write(fd, data, data_len);\n\tif (len != data_len) {\n\t\tret = -1;\n\t\tgoto out;\n\t}\n\nout:\n\tclose(fd);\n\treturn ret;\n}\n\nenum policy_t {\n\tSETGROUPS_DEFAULT = 0,\n\tSETGROUPS_ALLOW,\n\tSETGROUPS_DENY,\n};\n\n/* This *must* be called before we touch gid_map. */\nstatic void update_setgroups(int pid, enum policy_t setgroup)\n{\n\tchar *policy;\n\n\tswitch (setgroup) {\n\tcase SETGROUPS_ALLOW:\n\t\tpolicy = \"allow\";\n\t\tbreak;\n\tcase SETGROUPS_DENY:\n\t\tpolicy = \"deny\";\n\t\tbreak;\n\tcase SETGROUPS_DEFAULT:\n\tdefault:\n\t\t/* Nothing to do. */\n\t\treturn;\n\t}\n\n\tif (write_file(policy, strlen(policy), \"/proc/%d/setgroups\", pid) < 0) {\n\t\t/*\n\t\t * If the kernel is too old to support /proc/pid/setgroups,\n\t\t * open(2) or write(2) will return ENOENT. This is fine.\n\t\t */\n\t\tif (errno != ENOENT)\n\t\t\tbail(\"failed to write '%s' to /proc/%d/setgroups\", policy, pid);\n\t}\n}\n\nstatic int try_mapping_tool(const char *app, int pid, char *map, size_t map_len)\n{\n\tint child;\n\n\t/*\n\t * If @app is NULL, execve will segfault. Just check it here and bail (if\n\t * we're in this path, the caller is already getting desperate and there\n\t * isn't a backup to this failing). This usually would be a configuration\n\t * or programming issue.\n\t */\n\tif (!app)\n\t\tbail(\"mapping tool not present\");\n\n\tchild = fork();\n\tif (child < 0)\n\t\tbail(\"failed to fork\");\n\n\tif (!child) {\n#define MAX_ARGV 20\n\t\tchar *argv[MAX_ARGV];\n\t\tchar *envp[] = { NULL };\n\t\tchar pid_fmt[16];\n\t\tint argc = 0;\n\t\tchar *next;\n\n\t\tsnprintf(pid_fmt, 16, \"%d\", pid);\n\n\t\targv[argc++] = (char *)app;\n\t\targv[argc++] = pid_fmt;\n\t\t/*\n\t\t * Convert the map string into a list of argument that\n\t\t * newuidmap/newgidmap can understand.\n\t\t */\n\n\t\twhile (argc < MAX_ARGV) {\n\t\t\tif (*map == '\\0') {\n\t\t\t\targv[argc++] = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\targv[argc++] = map;\n\t\t\tnext = strpbrk(map, \"\\n \");\n\t\t\tif (next == NULL)\n\t\t\t\tbreak;\n\t\t\t*next++ = '\\0';\n\t\t\tmap = next + strspn(next, \"\\n \");\n\t\t}\n\n\t\texecve(app, argv, envp);\n\t\tbail(\"failed to execv\");\n\t} else {\n\t\tint status;\n\n\t\twhile (true) {\n\t\t\tif (waitpid(child, &status, 0) < 0) {\n\t\t\t\tif (errno == EINTR)\n\t\t\t\t\tcontinue;\n\t\t\t\tbail(\"failed to waitpid\");\n\t\t\t}\n\t\t\tif (WIFEXITED(status) || WIFSIGNALED(status))\n\t\t\t\treturn WEXITSTATUS(status);\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nstatic void update_uidmap(const char *path, int pid, char *map, size_t map_len)\n{\n\tif (map == NULL || map_len == 0)\n\t\treturn;\n\n\twrite_log(DEBUG, \"update /proc/%d/uid_map to '%s'\", pid, map);\n\tif (write_file(map, map_len, \"/proc/%d/uid_map\", pid) < 0) {\n\t\tif (errno != EPERM)\n\t\t\tbail(\"failed to update /proc/%d/uid_map\", pid);\n\t\twrite_log(DEBUG, \"update /proc/%d/uid_map got -EPERM (trying %s)\", pid, path);\n\t\tif (try_mapping_tool(path, pid, map, map_len))\n\t\t\tbail(\"failed to use newuid map on %d\", pid);\n\t}\n}\n\nstatic void update_gidmap(const char *path, int pid, char *map, size_t map_len)\n{\n\tif (map == NULL || map_len == 0)\n\t\treturn;\n\n\twrite_log(DEBUG, \"update /proc/%d/gid_map to '%s'\", pid, map);\n\tif (write_file(map, map_len, \"/proc/%d/gid_map\", pid) < 0) {\n\t\tif (errno != EPERM)\n\t\t\tbail(\"failed to update /proc/%d/gid_map\", pid);\n\t\twrite_log(DEBUG, \"update /proc/%d/gid_map got -EPERM (trying %s)\", pid, path);\n\t\tif (try_mapping_tool(path, pid, map, map_len))\n\t\t\tbail(\"failed to use newgid map on %d\", pid);\n\t}\n}\n\nstatic void update_oom_score_adj(char *data, size_t len)\n{\n\tif (data == NULL || len == 0)\n\t\treturn;\n\n\twrite_log(DEBUG, \"update /proc/self/oom_score_adj to '%s'\", data);\n\tif (write_file(data, len, \"/proc/self/oom_score_adj\") < 0)\n\t\tbail(\"failed to update /proc/self/oom_score_adj\");\n}\n\n/* A dummy function that just jumps to the given jumpval. */\nstatic int child_func(void *arg) __attribute__((noinline));\nstatic int child_func(void *arg)\n{\n\tstruct clone_t *ca = (struct clone_t *)arg;\n\tlongjmp(*ca->env, ca->jmpval);\n}\n\nstatic int clone_parent(jmp_buf *env, int jmpval) __attribute__((noinline));\nstatic int clone_parent(jmp_buf *env, int jmpval)\n{\n\tstruct clone_t ca = {\n\t\t.env = env,\n\t\t.jmpval = jmpval,\n\t};\n\n\treturn clone(child_func, ca.stack_ptr, CLONE_PARENT | SIGCHLD, &ca);\n}\n\n/*\n * Returns an environment variable value as a non-negative integer, or -ENOENT\n * if the variable was not found or has an empty value.\n *\n * If the value can not be converted to an integer, or the result is out of\n * range, the function bails out.\n */\nstatic int getenv_int(const char *name)\n{\n\tchar *val, *endptr;\n\tint ret;\n\n\tval = getenv(name);\n\t/* Treat empty value as unset variable. */\n\tif (val == NULL || *val == '\\0')\n\t\treturn -ENOENT;\n\n\tret = strtol(val, &endptr, 10);\n\tif (val == endptr || *endptr != '\\0')\n\t\tbail(\"unable to parse %s=%s\", name, val);\n\t/*\n\t * Sanity check: this must be a small non-negative number.\n\t * Practically, we pass two fds (3 and 4) and a log level,\n\t * for which the maximum is 6 (TRACE).\n\t * */\n\tif (ret < 0 || ret > TRACE)\n\t\tbail(\"bad value for %s=%s (%d)\", name, val, ret);\n\n\treturn ret;\n}\n\n/*\n * Sets up logging by getting log fd and log level from the environment,\n * if available.\n */\nstatic void setup_logpipe(void)\n{\n\tint i;\n\n\ti = getenv_int(\"_LIBCONTAINER_LOGPIPE\");\n\tif (i < 0) {\n\t\t/* We are not runc init, or log pipe was not provided. */\n\t\treturn;\n\t}\n\tlogfd = i;\n\n\ti = getenv_int(\"_LIBCONTAINER_LOGLEVEL\");\n\tif (i < 0)\n\t\treturn;\n\tloglevel = i;\n}\n\n/* Returns the clone(2) flag for a namespace, given the name of a namespace. */\nstatic int nsflag(char *name)\n{\n\tif (!strcmp(name, \"cgroup\"))\n\t\treturn CLONE_NEWCGROUP;\n\telse if (!strcmp(name, \"ipc\"))\n\t\treturn CLONE_NEWIPC;\n\telse if (!strcmp(name, \"mnt\"))\n\t\treturn CLONE_NEWNS;\n\telse if (!strcmp(name, \"net\"))\n\t\treturn CLONE_NEWNET;\n\telse if (!strcmp(name, \"pid\"))\n\t\treturn CLONE_NEWPID;\n\telse if (!strcmp(name, \"user\"))\n\t\treturn CLONE_NEWUSER;\n\telse if (!strcmp(name, \"uts\"))\n\t\treturn CLONE_NEWUTS;\n\n\t/* If we don't recognise a name, fallback to 0. */\n\treturn 0;\n}\n\nstatic uint32_t readint32(char *buf)\n{\n\treturn *(uint32_t *) buf;\n}\n\nstatic uint8_t readint8(char *buf)\n{\n\treturn *(uint8_t *) buf;\n}\n\nstatic void nl_parse(int fd, struct nlconfig_t *config)\n{\n\tsize_t len, size;\n\tstruct nlmsghdr hdr;\n\tchar *data, *current;\n\n\t/* Retrieve the netlink header. */\n\tlen = read(fd, &hdr, NLMSG_HDRLEN);\n\tif (len != NLMSG_HDRLEN)\n\t\tbail(\"invalid netlink header length %zu\", len);\n\n\tif (hdr.nlmsg_type == NLMSG_ERROR)\n\t\tbail(\"failed to read netlink message\");\n\n\tif (hdr.nlmsg_type != INIT_MSG)\n\t\tbail(\"unexpected msg type %d\", hdr.nlmsg_type);\n\n\t/* Retrieve data. */\n\tsize = NLMSG_PAYLOAD(&hdr, 0);\n\tcurrent = data = malloc(size);\n\tif (!data)\n\t\tbail(\"failed to allocate %zu bytes of memory for nl_payload\", size);\n\n\tlen = read(fd, data, size);\n\tif (len != size)\n\t\tbail(\"failed to read netlink payload, %zu != %zu\", len, size);\n\n\t/* Parse the netlink payload. */\n\tconfig->data = data;\n\twhile (current < data + size) {\n\t\tstruct nlattr *nlattr = (struct nlattr *)current;\n\t\tsize_t payload_len = nlattr->nla_len - NLA_HDRLEN;\n\n\t\t/* Advance to payload. */\n\t\tcurrent += NLA_HDRLEN;\n\n\t\t/* Handle payload. */\n\t\tswitch (nlattr->nla_type) {\n\t\tcase CLONE_FLAGS_ATTR:\n\t\t\tconfig->cloneflags = readint32(current);\n\t\t\tbreak;\n\t\tcase ROOTLESS_EUID_ATTR:\n\t\t\tconfig->is_rootless_euid = readint8(current);\t/* boolean */\n\t\t\tbreak;\n\t\tcase OOM_SCORE_ADJ_ATTR:\n\t\t\tconfig->oom_score_adj = current;\n\t\t\tconfig->oom_score_adj_len = payload_len;\n\t\t\tbreak;\n\t\tcase NS_PATHS_ATTR:\n\t\t\tconfig->namespaces = current;\n\t\t\tconfig->namespaces_len = payload_len;\n\t\t\tbreak;\n\t\tcase UIDMAP_ATTR:\n\t\t\tconfig->uidmap = current;\n\t\t\tconfig->uidmap_len = payload_len;\n\t\t\tbreak;\n\t\tcase GIDMAP_ATTR:\n\t\t\tconfig->gidmap = current;\n\t\t\tconfig->gidmap_len = payload_len;\n\t\t\tbreak;\n\t\tcase UIDMAPPATH_ATTR:\n\t\t\tconfig->uidmappath = current;\n\t\t\tconfig->uidmappath_len = payload_len;\n\t\t\tbreak;\n\t\tcase GIDMAPPATH_ATTR:\n\t\t\tconfig->gidmappath = current;\n\t\t\tconfig->gidmappath_len = payload_len;\n\t\t\tbreak;\n\t\tcase SETGROUP_ATTR:\n\t\t\tconfig->is_setgroup = readint8(current);\n\t\t\tbreak;\n\t\tcase MOUNT_SOURCES_ATTR:\n\t\t\tconfig->mountsources = current;\n\t\t\tconfig->mountsources_len = payload_len;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbail(\"unknown netlink message type %d\", nlattr->nla_type);\n\t\t}\n\n\t\tcurrent += NLA_ALIGN(payload_len);\n\t}\n}\n\nvoid nl_free(struct nlconfig_t *config)\n{\n\tfree(config->data);\n}\n\nvoid join_namespaces(char *nslist)\n{\n\tint num = 0, i;\n\tchar *saveptr = NULL;\n\tchar *namespace = strtok_r(nslist, \",\", &saveptr);\n\tstruct namespace_t {\n\t\tint fd;\n\t\tchar type[PATH_MAX];\n\t\tchar path[PATH_MAX];\n\t} *namespaces = NULL;\n\n\tif (!namespace || !strlen(namespace) || !strlen(nslist))\n\t\tbail(\"ns paths are empty\");\n\n\t/*\n\t * We have to open the file descriptors first, since after\n\t * we join the mnt namespace we might no longer be able to\n\t * access the paths.\n\t */\n\tdo {\n\t\tint fd;\n\t\tchar *path;\n\t\tstruct namespace_t *ns;\n\n\t\t/* Resize the namespace array. */\n\t\tnamespaces = realloc(namespaces, ++num * sizeof(struct namespace_t));\n\t\tif (!namespaces)\n\t\t\tbail(\"failed to reallocate namespace array\");\n\t\tns = &namespaces[num - 1];\n\n\t\t/* Split 'ns:path'. */\n\t\tpath = strstr(namespace, \":\");\n\t\tif (!path)\n\t\t\tbail(\"failed to parse %s\", namespace);\n\t\t*path++ = '\\0';\n\n\t\tfd = open(path, O_RDONLY);\n\t\tif (fd < 0)\n\t\t\tbail(\"failed to open %s\", path);\n\n\t\tns->fd = fd;\n\t\tstrncpy(ns->type, namespace, PATH_MAX - 1);\n\t\tstrncpy(ns->path, path, PATH_MAX - 1);\n\t\tns->path[PATH_MAX - 1] = '\\0';\n\t} while ((namespace = strtok_r(NULL, \",\", &saveptr)) != NULL);\n\n\t/*\n\t * The ordering in which we join namespaces is important. We should\n\t * always join the user namespace *first*. This is all guaranteed\n\t * from the container_linux.go side of this, so we're just going to\n\t * follow the order given to us.\n\t */\n\n\tfor (i = 0; i < num; i++) {\n\t\tstruct namespace_t *ns = &namespaces[i];\n\t\tint flag = nsflag(ns->type);\n\n\t\twrite_log(DEBUG, \"setns(%#x) into %s namespace (with path %s)\", flag, ns->type, ns->path);\n\t\tif (setns(ns->fd, flag) < 0)\n\t\t\tbail(\"failed to setns into %s namespace\", ns->type);\n\n\t\tclose(ns->fd);\n\t}\n\n\tfree(namespaces);\n}\n\n/* Defined in cloned_binary.c. */\nextern int ensure_cloned_binary(void);\n\nstatic inline int sane_kill(pid_t pid, int signum)\n{\n\tif (pid > 0)\n\t\treturn kill(pid, signum);\n\telse\n\t\treturn 0;\n}\n\nvoid receive_fd(int sockfd, int new_fd)\n{\n\tint bytes_read;\n\tstruct msghdr msg = { };\n\tstruct cmsghdr *cmsg;\n\tstruct iovec iov = { };\n\tchar null_byte = '\\0';\n\tint ret;\n\tint fd_count;\n\tint *fd_payload;\n\n\tiov.iov_base = &null_byte;\n\tiov.iov_len = 1;\n\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\n\tmsg.msg_controllen = CMSG_SPACE(sizeof(int));\n\tmsg.msg_control = malloc(msg.msg_controllen);\n\tif (msg.msg_control == NULL) {\n\t\tbail(\"Can't allocate memory to receive fd.\");\n\t}\n\n\tmemset(msg.msg_control, 0, msg.msg_controllen);\n\n\tbytes_read = recvmsg(sockfd, &msg, 0);\n\tif (bytes_read != 1)\n\t\tbail(\"failed to receive fd from unix socket %d\", sockfd);\n\tif (msg.msg_flags & MSG_CTRUNC)\n\t\tbail(\"received truncated control message from unix socket %d\", sockfd);\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tif (!cmsg)\n\t\tbail(\"received message from unix socket %d without control message\", sockfd);\n\n\tif (cmsg->cmsg_level != SOL_SOCKET)\n\t\tbail(\"received unknown control message from unix socket %d: cmsg_level=%d\", sockfd, cmsg->cmsg_level);\n\n\tif (cmsg->cmsg_type != SCM_RIGHTS)\n\t\tbail(\"received unknown control message from unix socket %d: cmsg_type=%d\", sockfd, cmsg->cmsg_type);\n\n\tfd_count = (cmsg->cmsg_len - CMSG_LEN(0)) / sizeof(int);\n\tif (fd_count != 1)\n\t\tbail(\"received control message from unix socket %d with too many fds: %d\", sockfd, fd_count);\n\n\tfd_payload = (int *)CMSG_DATA(cmsg);\n\tret = dup3(*fd_payload, new_fd, O_CLOEXEC);\n\tif (ret < 0)\n\t\tbail(\"cannot dup3 fd %d to %d\", *fd_payload, new_fd);\n\n\tfree(msg.msg_control);\n\n\tret = close(*fd_payload);\n\tif (ret < 0)\n\t\tbail(\"cannot close fd %d\", *fd_payload);\n}\n\nvoid send_fd(int sockfd, int fd)\n{\n\tint bytes_written;\n\tstruct msghdr msg = { };\n\tstruct cmsghdr *cmsg;\n\tstruct iovec iov[1] = { };\n\tchar null_byte = '\\0';\n\n\tiov[0].iov_base = &null_byte;\n\tiov[0].iov_len = 1;\n\n\tmsg.msg_iov = iov;\n\tmsg.msg_iovlen = 1;\n\n\t/* We send only one fd as specified by cmsg->cmsg_len below, even\n\t * though msg.msg_controllen might have more space due to alignment. */\n\tmsg.msg_controllen = CMSG_SPACE(sizeof(int));\n\tmsg.msg_control = malloc(msg.msg_controllen);\n\tif (msg.msg_control == NULL) {\n\t\tbail(\"Can't allocate memory to send fd.\");\n\t}\n\n\tmemset(msg.msg_control, 0, msg.msg_controllen);\n\n\tcmsg = CMSG_FIRSTHDR(&msg);\n\tcmsg->cmsg_level = SOL_SOCKET;\n\tcmsg->cmsg_type = SCM_RIGHTS;\n\tcmsg->cmsg_len = CMSG_LEN(sizeof(int));\n\tmemcpy(CMSG_DATA(cmsg), &fd, sizeof(int));\n\n\tbytes_written = sendmsg(sockfd, &msg, 0);\n\n\tfree(msg.msg_control);\n\n\tif (bytes_written != 1)\n\t\tbail(\"failed to send fd %d via unix socket %d\", fd, sockfd);\n}\n\nvoid receive_mountsources(int sockfd)\n{\n\tchar *mount_fds, *endp;\n\tlong new_fd;\n\n\t// This env var must be a json array of ints.\n\tmount_fds = getenv(\"_LIBCONTAINER_MOUNT_FDS\");\n\n\tif (mount_fds[0] != '[') {\n\t\tbail(\"malformed _LIBCONTAINER_MOUNT_FDS env var: missing '['\");\n\t}\n\tmount_fds++;\n\n\tfor (endp = mount_fds; *endp != ']'; mount_fds = endp + 1) {\n\t\tnew_fd = strtol(mount_fds, &endp, 10);\n\t\tif (endp == mount_fds) {\n\t\t\tbail(\"malformed _LIBCONTAINER_MOUNT_FDS env var: not a number\");\n\t\t}\n\t\tif (*endp == '\\0') {\n\t\t\tbail(\"malformed _LIBCONTAINER_MOUNT_FDS env var: missing ]\");\n\t\t}\n\t\t// The list contains -1 when no fd is needed. Ignore them.\n\t\tif (new_fd == -1) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (new_fd == LONG_MAX || new_fd < 0 || new_fd > INT_MAX) {\n\t\t\tbail(\"malformed _LIBCONTAINER_MOUNT_FDS env var: fds out of range\");\n\t\t}\n\n\t\treceive_fd(sockfd, new_fd);\n\t}\n}\n\nvoid send_mountsources(int sockfd, pid_t child, char *mountsources, size_t mountsources_len)\n{\n\tchar proc_path[PATH_MAX];\n\tint host_mntns_fd;\n\tint container_mntns_fd;\n\tint fd;\n\tint ret;\n\n\t// container_linux.go shouldSendMountSources() decides if mount sources\n\t// should be pre-opened (O_PATH) and passed via SCM_RIGHTS\n\tif (mountsources == NULL)\n\t\treturn;\n\n\thost_mntns_fd = open(\"/proc/self/ns/mnt\", O_RDONLY | O_CLOEXEC);\n\tif (host_mntns_fd == -1)\n\t\tbail(\"failed to get current mount namespace\");\n\n\tif (snprintf(proc_path, PATH_MAX, \"/proc/%d/ns/mnt\", child) < 0)\n\t\tbail(\"failed to get mount namespace path\");\n\n\tcontainer_mntns_fd = open(proc_path, O_RDONLY | O_CLOEXEC);\n\tif (container_mntns_fd == -1)\n\t\tbail(\"failed to get container mount namespace\");\n\n\tif (setns(container_mntns_fd, CLONE_NEWNS) < 0)\n\t\tbail(\"failed to setns to container mntns\");\n\n\tchar *mountsources_end = mountsources + mountsources_len;\n\twhile (mountsources < mountsources_end) {\n\t\tif (mountsources[0] == '\\0') {\n\t\t\tmountsources++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfd = open(mountsources, O_PATH | O_CLOEXEC);\n\t\tif (fd < 0)\n\t\t\tbail(\"failed to open mount source %s\", mountsources);\n\n\t\tsend_fd(sockfd, fd);\n\n\t\tret = close(fd);\n\t\tif (ret != 0)\n\t\t\tbail(\"failed to close mount source fd %d\", fd);\n\n\t\tmountsources += strlen(mountsources) + 1;\n\t}\n\n\tif (setns(host_mntns_fd, CLONE_NEWNS) < 0)\n\t\tbail(\"failed to setns to host mntns\");\n\n\tret = close(host_mntns_fd);\n\tif (ret != 0)\n\t\tbail(\"failed to close host mount namespace fd %d\", host_mntns_fd);\n\tret = close(container_mntns_fd);\n\tif (ret != 0)\n\t\tbail(\"failed to close container mount namespace fd %d\", container_mntns_fd);\n}\n\nvoid nsexec(void)\n{\n\tint pipenum;\n\tjmp_buf env;\n\tint sync_child_pipe[2], sync_grandchild_pipe[2];\n\tstruct nlconfig_t config = { 0 };\n\n\t/*\n\t * Setup a pipe to send logs to the parent. This should happen\n\t * first, because bail will use that pipe.\n\t */\n\tsetup_logpipe();\n\n\t/*\n\t * Get the init pipe fd from the environment. The init pipe is used to\n\t * read the bootstrap data and tell the parent what the new pids are\n\t * after the setup is done.\n\t */\n\tpipenum = getenv_int(\"_LIBCONTAINER_INITPIPE\");\n\tif (pipenum < 0) {\n\t\t/* We are not a runc init. Just return to go runtime. */\n\t\treturn;\n\t}\n\n\t/*\n\t * We need to re-exec if we are not in a cloned binary. This is necessary\n\t * to ensure that containers won't be able to access the host binary\n\t * through /proc/self/exe. See CVE-2019-5736.\n\t */\n\tif (ensure_cloned_binary() < 0)\n\t\tbail(\"could not ensure we are a cloned binary\");\n\n\t/*\n\t * Inform the parent we're past initial setup.\n\t * For the other side of this, see initWaiter.\n\t */\n\tif (write(pipenum, \"\", 1) != 1)\n\t\tbail(\"could not inform the parent we are past initial setup\");\n\n\twrite_log(DEBUG, \"=> nsexec container setup\");\n\n\t/* Parse all of the netlink configuration. */\n\tnl_parse(pipenum, &config);\n\n\t/* Set oom_score_adj. This has to be done before !dumpable because\n\t * /proc/self/oom_score_adj is not writeable unless you're an privileged\n\t * user (if !dumpable is set). All children inherit their parent's\n\t * oom_score_adj value on fork(2) so this will always be propagated\n\t * properly.\n\t */\n\tupdate_oom_score_adj(config.oom_score_adj, config.oom_score_adj_len);\n\n\t/*\n\t * Make the process non-dumpable, to avoid various race conditions that\n\t * could cause processes in namespaces we're joining to access host\n\t * resources (or potentially execute code).\n\t *\n\t * However, if the number of namespaces we are joining is 0, we are not\n\t * going to be switching to a different security context. Thus setting\n\t * ourselves to be non-dumpable only breaks things (like rootless\n\t * containers), which is the recommendation from the kernel folks.\n\t */\n\tif (config.namespaces) {\n\t\twrite_log(DEBUG, \"set process as non-dumpable\");\n\t\tif (prctl(PR_SET_DUMPABLE, 0, 0, 0, 0) < 0)\n\t\t\tbail(\"failed to set process as non-dumpable\");\n\t}\n\n\t/* Pipe so we can tell the child when we've finished setting up. */\n\tif (socketpair(AF_LOCAL, SOCK_STREAM, 0, sync_child_pipe) < 0)\n\t\tbail(\"failed to setup sync pipe between parent and child\");\n\n\t/*\n\t * We need a new socketpair to sync with grandchild so we don't have\n\t * race condition with child.\n\t */\n\tif (socketpair(AF_LOCAL, SOCK_STREAM, 0, sync_grandchild_pipe) < 0)\n\t\tbail(\"failed to setup sync pipe between parent and grandchild\");\n\n\t/* TODO: Currently we aren't dealing with child deaths properly. */\n\n\t/*\n\t * Okay, so this is quite annoying.\n\t *\n\t * In order for this unsharing code to be more extensible we need to split\n\t * up unshare(CLONE_NEWUSER) and clone() in various ways. The ideal case\n\t * would be if we did clone(CLONE_NEWUSER) and the other namespaces\n\t * separately, but because of SELinux issues we cannot really do that. But\n\t * we cannot just dump the namespace flags into clone(...) because several\n\t * usecases (such as rootless containers) require more granularity around\n\t * the namespace setup. In addition, some older kernels had issues where\n\t * CLONE_NEWUSER wasn't handled before other namespaces (but we cannot\n\t * handle this while also dealing with SELinux so we choose SELinux support\n\t * over broken kernel support).\n\t *\n\t * However, if we unshare(2) the user namespace *before* we clone(2), then\n\t * all hell breaks loose.\n\t *\n\t * The parent no longer has permissions to do many things (unshare(2) drops\n\t * all capabilities in your old namespace), and the container cannot be set\n\t * up to have more than one {uid,gid} mapping. This is obviously less than\n\t * ideal. In order to fix this, we have to first clone(2) and then unshare.\n\t *\n\t * Unfortunately, it's not as simple as that. We have to fork to enter the\n\t * PID namespace (the PID namespace only applies to children). Since we'll\n\t * have to double-fork, this clone_parent() call won't be able to get the\n\t * PID of the _actual_ init process (without doing more synchronisation than\n\t * I can deal with at the moment). So we'll just get the parent to send it\n\t * for us, the only job of this process is to update\n\t * /proc/pid/{setgroups,uid_map,gid_map}.\n\t *\n\t * And as a result of the above, we also need to setns(2) in the first child\n\t * because if we join a PID namespace in the topmost parent then our child\n\t * will be in that namespace (and it will not be able to give us a PID value\n\t * that makes sense without resorting to sending things with cmsg).\n\t *\n\t * This also deals with an older issue caused by dumping cloneflags into\n\t * clone(2): On old kernels, CLONE_PARENT didn't work with CLONE_NEWPID, so\n\t * we have to unshare(2) before clone(2) in order to do this. This was fixed\n\t * in upstream commit 1f7f4dde5c945f41a7abc2285be43d918029ecc5, and was\n\t * introduced by 40a0d32d1eaffe6aac7324ca92604b6b3977eb0e. As far as we're\n\t * aware, the last mainline kernel which had this bug was Linux 3.12.\n\t * However, we cannot comment on which kernels the broken patch was\n\t * backported to.\n\t *\n\t * -- Aleksa \"what has my life come to?\" Sarai\n\t */\n\n\tcurrent_stage = setjmp(env);\n\tswitch (current_stage) {\n\t\t/*\n\t\t * Stage 0: We're in the parent. Our job is just to create a new child\n\t\t *          (stage 1: STAGE_CHILD) process and write its uid_map and\n\t\t *          gid_map. That process will go on to create a new process, then\n\t\t *          it will send us its PID which we will send to the bootstrap\n\t\t *          process.\n\t\t */\n\tcase STAGE_PARENT:{\n\t\t\tint len;\n\t\t\tpid_t stage1_pid = -1, stage2_pid = -1;\n\t\t\tbool stage1_complete, stage2_complete;\n\n\t\t\t/* For debugging. */\n\t\t\tprctl(PR_SET_NAME, (unsigned long)\"runc:[0:PARENT]\", 0, 0, 0);\n\t\t\twrite_log(DEBUG, \"~> nsexec stage-0\");\n\n\t\t\t/* Start the process of getting a container. */\n\t\t\twrite_log(DEBUG, \"spawn stage-1\");\n\t\t\tstage1_pid = clone_parent(&env, STAGE_CHILD);\n\t\t\tif (stage1_pid < 0)\n\t\t\t\tbail(\"unable to spawn stage-1\");\n\n\t\t\tsyncfd = sync_child_pipe[1];\n\t\t\tif (close(sync_child_pipe[0]) < 0)\n\t\t\t\tbail(\"failed to close sync_child_pipe[0] fd\");\n\n\t\t\t/*\n\t\t\t * State machine for synchronisation with the children. We only\n\t\t\t * return once both the child and grandchild are ready.\n\t\t\t */\n\t\t\twrite_log(DEBUG, \"-> stage-1 synchronisation loop\");\n\t\t\tstage1_complete = false;\n\t\t\twhile (!stage1_complete) {\n\t\t\t\tenum sync_t s;\n\n\t\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with stage-1: next state\");\n\n\t\t\t\tswitch (s) {\n\t\t\t\tcase SYNC_USERMAP_PLS:\n\t\t\t\t\twrite_log(DEBUG, \"stage-1 requested userns mappings\");\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Enable setgroups(2) if we've been asked to. But we also\n\t\t\t\t\t * have to explicitly disable setgroups(2) if we're\n\t\t\t\t\t * creating a rootless container for single-entry mapping.\n\t\t\t\t\t * i.e. config.is_setgroup == false.\n\t\t\t\t\t * (this is required since Linux 3.19).\n\t\t\t\t\t *\n\t\t\t\t\t * For rootless multi-entry mapping, config.is_setgroup shall be true and\n\t\t\t\t\t * newuidmap/newgidmap shall be used.\n\t\t\t\t\t */\n\t\t\t\t\tif (config.is_rootless_euid && !config.is_setgroup)\n\t\t\t\t\t\tupdate_setgroups(stage1_pid, SETGROUPS_DENY);\n\n\t\t\t\t\t/* Set up mappings. */\n\t\t\t\t\tupdate_uidmap(config.uidmappath, stage1_pid, config.uidmap, config.uidmap_len);\n\t\t\t\t\tupdate_gidmap(config.gidmappath, stage1_pid, config.gidmap, config.gidmap_len);\n\n\t\t\t\t\ts = SYNC_USERMAP_ACK;\n\t\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\t\t\tsane_kill(stage1_pid, SIGKILL);\n\t\t\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\t\t\tbail(\"failed to sync with stage-1: write(SYNC_USERMAP_ACK)\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SYNC_RECVPID_PLS:\n\t\t\t\t\twrite_log(DEBUG, \"stage-1 requested pid to be forwarded\");\n\n\t\t\t\t\t/* Get the stage-2 pid. */\n\t\t\t\t\tif (read(syncfd, &stage2_pid, sizeof(stage2_pid)) != sizeof(stage2_pid)) {\n\t\t\t\t\t\tsane_kill(stage1_pid, SIGKILL);\n\t\t\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\t\t\tbail(\"failed to sync with stage-1: read(stage2_pid)\");\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Send ACK. */\n\t\t\t\t\ts = SYNC_RECVPID_ACK;\n\t\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\t\t\tsane_kill(stage1_pid, SIGKILL);\n\t\t\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\t\t\tbail(\"failed to sync with stage-1: write(SYNC_RECVPID_ACK)\");\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Send both the stage-1 and stage-2 pids back to runc.\n\t\t\t\t\t * runc needs the stage-2 to continue process management,\n\t\t\t\t\t * but because stage-1 was spawned with CLONE_PARENT we\n\t\t\t\t\t * cannot reap it within stage-0 and thus we need to ask\n\t\t\t\t\t * runc to reap the zombie for us.\n\t\t\t\t\t */\n\t\t\t\t\twrite_log(DEBUG, \"forward stage-1 (%d) and stage-2 (%d) pids to runc\",\n\t\t\t\t\t\t  stage1_pid, stage2_pid);\n\t\t\t\t\tlen =\n\t\t\t\t\t    dprintf(pipenum, \"{\\\"stage1_pid\\\":%d,\\\"stage2_pid\\\":%d}\\n\", stage1_pid,\n\t\t\t\t\t\t    stage2_pid);\n\t\t\t\t\tif (len < 0) {\n\t\t\t\t\t\tsane_kill(stage1_pid, SIGKILL);\n\t\t\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\t\t\tbail(\"failed to sync with runc: write(pid-JSON)\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SYNC_MOUNTSOURCES_PLS:\n\t\t\t\t\tsend_mountsources(syncfd, stage1_pid, config.mountsources,\n\t\t\t\t\t\t\t  config.mountsources_len);\n\n\t\t\t\t\ts = SYNC_MOUNTSOURCES_ACK;\n\t\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\t\t\tkill(stage1_pid, SIGKILL);\n\t\t\t\t\t\tbail(\"failed to sync with child: write(SYNC_MOUNTSOURCES_ACK)\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SYNC_CHILD_FINISH:\n\t\t\t\t\twrite_log(DEBUG, \"stage-1 complete\");\n\t\t\t\t\tstage1_complete = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbail(\"unexpected sync value: %u\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\twrite_log(DEBUG, \"<- stage-1 synchronisation loop\");\n\n\t\t\t/* Now sync with grandchild. */\n\t\t\tsyncfd = sync_grandchild_pipe[1];\n\t\t\tif (close(sync_grandchild_pipe[0]) < 0)\n\t\t\t\tbail(\"failed to close sync_grandchild_pipe[0] fd\");\n\n\t\t\twrite_log(DEBUG, \"-> stage-2 synchronisation loop\");\n\t\t\tstage2_complete = false;\n\t\t\twhile (!stage2_complete) {\n\t\t\t\tenum sync_t s;\n\n\t\t\t\twrite_log(DEBUG, \"signalling stage-2 to run\");\n\t\t\t\ts = SYNC_GRANDCHILD;\n\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\t\tbail(\"failed to sync with child: write(SYNC_GRANDCHILD)\");\n\t\t\t\t}\n\n\t\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with child: next state\");\n\n\t\t\t\tswitch (s) {\n\t\t\t\tcase SYNC_CHILD_FINISH:\n\t\t\t\t\twrite_log(DEBUG, \"stage-2 complete\");\n\t\t\t\t\tstage2_complete = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbail(\"unexpected sync value: %u\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\twrite_log(DEBUG, \"<- stage-2 synchronisation loop\");\n\t\t\twrite_log(DEBUG, \"<~ nsexec stage-0\");\n\t\t\texit(0);\n\t\t}\n\t\tbreak;\n\n\t\t/*\n\t\t * Stage 1: We're in the first child process. Our job is to join any\n\t\t *          provided namespaces in the netlink payload and unshare all of\n\t\t *          the requested namespaces. If we've been asked to CLONE_NEWUSER,\n\t\t *          we will ask our parent (stage 0) to set up our user mappings\n\t\t *          for us. Then, we create a new child (stage 2: STAGE_INIT) for\n\t\t *          PID namespace. We then send the child's PID to our parent\n\t\t *          (stage 0).\n\t\t */\n\tcase STAGE_CHILD:{\n\t\t\tpid_t stage2_pid = -1;\n\t\t\tenum sync_t s;\n\n\t\t\t/* We're in a child and thus need to tell the parent if we die. */\n\t\t\tsyncfd = sync_child_pipe[0];\n\t\t\tif (close(sync_child_pipe[1]) < 0)\n\t\t\t\tbail(\"failed to close sync_child_pipe[1] fd\");\n\n\t\t\t/* For debugging. */\n\t\t\tprctl(PR_SET_NAME, (unsigned long)\"runc:[1:CHILD]\", 0, 0, 0);\n\t\t\twrite_log(DEBUG, \"~> nsexec stage-1\");\n\n\t\t\t/*\n\t\t\t * We need to setns first. We cannot do this earlier (in stage 0)\n\t\t\t * because of the fact that we forked to get here (the PID of\n\t\t\t * [stage 2: STAGE_INIT]) would be meaningless). We could send it\n\t\t\t * using cmsg(3) but that's just annoying.\n\t\t\t */\n\t\t\tif (config.namespaces)\n\t\t\t\tjoin_namespaces(config.namespaces);\n\n\t\t\t/*\n\t\t\t * Deal with user namespaces first. They are quite special, as they\n\t\t\t * affect our ability to unshare other namespaces and are used as\n\t\t\t * context for privilege checks.\n\t\t\t *\n\t\t\t * We don't unshare all namespaces in one go. The reason for this\n\t\t\t * is that, while the kernel documentation may claim otherwise,\n\t\t\t * there are certain cases where unsharing all namespaces at once\n\t\t\t * will result in namespace objects being owned incorrectly.\n\t\t\t * Ideally we should just fix these kernel bugs, but it's better to\n\t\t\t * be safe than sorry, and fix them separately.\n\t\t\t *\n\t\t\t * A specific case of this is that the SELinux label of the\n\t\t\t * internal kern-mount that mqueue uses will be incorrect if the\n\t\t\t * UTS namespace is cloned before the USER namespace is mapped.\n\t\t\t * I've also heard of similar problems with the network namespace\n\t\t\t * in some scenarios. This also mirrors how LXC deals with this\n\t\t\t * problem.\n\t\t\t */\n\t\t\tif (config.cloneflags & CLONE_NEWUSER) {\n\t\t\t\twrite_log(DEBUG, \"unshare user namespace\");\n\t\t\t\tif (unshare(CLONE_NEWUSER) < 0)\n\t\t\t\t\tbail(\"failed to unshare user namespace\");\n\t\t\t\tconfig.cloneflags &= ~CLONE_NEWUSER;\n\n\t\t\t\t/*\n\t\t\t\t * We need to set ourselves as dumpable temporarily so that the\n\t\t\t\t * parent process can write to our procfs files.\n\t\t\t\t */\n\t\t\t\tif (config.namespaces) {\n\t\t\t\t\twrite_log(DEBUG, \"temporarily set process as dumpable\");\n\t\t\t\t\tif (prctl(PR_SET_DUMPABLE, 1, 0, 0, 0) < 0)\n\t\t\t\t\t\tbail(\"failed to temporarily set process as dumpable\");\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * We don't have the privileges to do any mapping here (see the\n\t\t\t\t * clone_parent rant). So signal stage-0 to do the mapping for\n\t\t\t\t * us.\n\t\t\t\t */\n\t\t\t\twrite_log(DEBUG, \"request stage-0 to map user namespace\");\n\t\t\t\ts = SYNC_USERMAP_PLS;\n\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with parent: write(SYNC_USERMAP_PLS)\");\n\n\t\t\t\t/* ... wait for mapping ... */\n\t\t\t\twrite_log(DEBUG, \"request stage-0 to map user namespace\");\n\t\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with parent: read(SYNC_USERMAP_ACK)\");\n\t\t\t\tif (s != SYNC_USERMAP_ACK)\n\t\t\t\t\tbail(\"failed to sync with parent: SYNC_USERMAP_ACK: got %u\", s);\n\n\t\t\t\t/* Revert temporary re-dumpable setting. */\n\t\t\t\tif (config.namespaces) {\n\t\t\t\t\twrite_log(DEBUG, \"re-set process as non-dumpable\");\n\t\t\t\t\tif (prctl(PR_SET_DUMPABLE, 0, 0, 0, 0) < 0)\n\t\t\t\t\t\tbail(\"failed to re-set process as non-dumpable\");\n\t\t\t\t}\n\n\t\t\t\t/* Become root in the namespace proper. */\n\t\t\t\tif (setresuid(0, 0, 0) < 0)\n\t\t\t\t\tbail(\"failed to become root in user namespace\");\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Unshare all of the namespaces. Now, it should be noted that this\n\t\t\t * ordering might break in the future (especially with rootless\n\t\t\t * containers). But for now, it's not possible to split this into\n\t\t\t * CLONE_NEWUSER + [the rest] because of some RHEL SELinux issues.\n\t\t\t *\n\t\t\t * Note that we don't merge this with clone() because there were\n\t\t\t * some old kernel versions where clone(CLONE_PARENT | CLONE_NEWPID)\n\t\t\t * was broken, so we'll just do it the long way anyway.\n\t\t\t */\n\t\t\twrite_log(DEBUG, \"unshare remaining namespace (except cgroupns)\");\n\t\t\tif (unshare(config.cloneflags & ~CLONE_NEWCGROUP) < 0)\n\t\t\t\tbail(\"failed to unshare remaining namespaces (except cgroupns)\");\n\n\t\t\t/* Ask our parent to send the mount sources fds. */\n\t\t\tif (config.mountsources) {\n\t\t\t\ts = SYNC_MOUNTSOURCES_PLS;\n\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\t\tkill(stage2_pid, SIGKILL);\n\t\t\t\t\tbail(\"failed to sync with parent: write(SYNC_MOUNTSOURCES_PLS)\");\n\t\t\t\t}\n\n\t\t\t\t/* Receive and install all mount sources fds. */\n\t\t\t\treceive_mountsources(syncfd);\n\n\t\t\t\t/* Parent finished to send the mount sources fds. */\n\t\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\t\tkill(stage2_pid, SIGKILL);\n\t\t\t\t\tbail(\"failed to sync with parent: read(SYNC_MOUNTSOURCES_ACK)\");\n\t\t\t\t}\n\t\t\t\tif (s != SYNC_MOUNTSOURCES_ACK) {\n\t\t\t\t\tkill(stage2_pid, SIGKILL);\n\t\t\t\t\tbail(\"failed to sync with parent: SYNC_MOUNTSOURCES_ACK: got %u\", s);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * TODO: What about non-namespace clone flags that we're dropping here?\n\t\t\t *\n\t\t\t * We fork again because of PID namespace, setns(2) or unshare(2) don't\n\t\t\t * change the PID namespace of the calling process, because doing so\n\t\t\t * would change the caller's idea of its own PID (as reported by getpid()),\n\t\t\t * which would break many applications and libraries, so we must fork\n\t\t\t * to actually enter the new PID namespace.\n\t\t\t */\n\t\t\twrite_log(DEBUG, \"spawn stage-2\");\n\t\t\tstage2_pid = clone_parent(&env, STAGE_INIT);\n\t\t\tif (stage2_pid < 0)\n\t\t\t\tbail(\"unable to spawn stage-2\");\n\n\t\t\t/* Send the child to our parent, which knows what it's doing. */\n\t\t\twrite_log(DEBUG, \"request stage-0 to forward stage-2 pid (%d)\", stage2_pid);\n\t\t\ts = SYNC_RECVPID_PLS;\n\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: write(SYNC_RECVPID_PLS)\");\n\t\t\t}\n\t\t\tif (write(syncfd, &stage2_pid, sizeof(stage2_pid)) != sizeof(stage2_pid)) {\n\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: write(stage2_pid)\");\n\t\t\t}\n\n\t\t\t/* ... wait for parent to get the pid ... */\n\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: read(SYNC_RECVPID_ACK)\");\n\t\t\t}\n\t\t\tif (s != SYNC_RECVPID_ACK) {\n\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: SYNC_RECVPID_ACK: got %u\", s);\n\t\t\t}\n\n\t\t\twrite_log(DEBUG, \"signal completion to stage-0\");\n\t\t\ts = SYNC_CHILD_FINISH;\n\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\tsane_kill(stage2_pid, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: write(SYNC_CHILD_FINISH)\");\n\t\t\t}\n\n\t\t\t/* Our work is done. [Stage 2: STAGE_INIT] is doing the rest of the work. */\n\t\t\twrite_log(DEBUG, \"<~ nsexec stage-1\");\n\t\t\texit(0);\n\t\t}\n\t\tbreak;\n\n\t\t/*\n\t\t * Stage 2: We're the final child process, and the only process that will\n\t\t *          actually return to the Go runtime. Our job is to just do the\n\t\t *          final cleanup steps and then return to the Go runtime to allow\n\t\t *          init_linux.go to run.\n\t\t */\n\tcase STAGE_INIT:{\n\t\t\t/*\n\t\t\t * We're inside the child now, having jumped from the\n\t\t\t * start_child() code after forking in the parent.\n\t\t\t */\n\t\t\tenum sync_t s;\n\n\t\t\t/* We're in a child and thus need to tell the parent if we die. */\n\t\t\tsyncfd = sync_grandchild_pipe[0];\n\t\t\tif (close(sync_grandchild_pipe[1]) < 0)\n\t\t\t\tbail(\"failed to close sync_grandchild_pipe[1] fd\");\n\n\t\t\tif (close(sync_child_pipe[0]) < 0)\n\t\t\t\tbail(\"failed to close sync_child_pipe[0] fd\");\n\n\t\t\t/* For debugging. */\n\t\t\tprctl(PR_SET_NAME, (unsigned long)\"runc:[2:INIT]\", 0, 0, 0);\n\t\t\twrite_log(DEBUG, \"~> nsexec stage-2\");\n\n\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\tbail(\"failed to sync with parent: read(SYNC_GRANDCHILD)\");\n\t\t\tif (s != SYNC_GRANDCHILD)\n\t\t\t\tbail(\"failed to sync with parent: SYNC_GRANDCHILD: got %u\", s);\n\n\t\t\tif (setsid() < 0)\n\t\t\t\tbail(\"setsid failed\");\n\n\t\t\tif (setuid(0) < 0)\n\t\t\t\tbail(\"setuid failed\");\n\n\t\t\tif (setgid(0) < 0)\n\t\t\t\tbail(\"setgid failed\");\n\n\t\t\tif (!config.is_rootless_euid && config.is_setgroup) {\n\t\t\t\tif (setgroups(0, NULL) < 0)\n\t\t\t\t\tbail(\"setgroups failed\");\n\t\t\t}\n\n\t\t\tif (config.cloneflags & CLONE_NEWCGROUP) {\n\t\t\t\tif (unshare(CLONE_NEWCGROUP) < 0)\n\t\t\t\t\tbail(\"failed to unshare cgroup namespace\");\n\t\t\t}\n\n\t\t\twrite_log(DEBUG, \"signal completion to stage-0\");\n\t\t\ts = SYNC_CHILD_FINISH;\n\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\tbail(\"failed to sync with parent: write(SYNC_CHILD_FINISH)\");\n\n\t\t\t/* Close sync pipes. */\n\t\t\tif (close(sync_grandchild_pipe[0]) < 0)\n\t\t\t\tbail(\"failed to close sync_grandchild_pipe[0] fd\");\n\n\t\t\t/* Free netlink data. */\n\t\t\tnl_free(&config);\n\n\t\t\t/* Finish executing, let the Go runtime take over. */\n\t\t\twrite_log(DEBUG, \"<= nsexec container setup\");\n\t\t\twrite_log(DEBUG, \"booting up go runtime ...\");\n\t\t\treturn;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbail(\"unknown stage '%d' for jump value\", current_stage);\n\t}\n\n\t/* Should never be reached. */\n\tbail(\"should never be reached\");\n}\n", "package libcontainer\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\tsecurejoin \"github.com/cyphar/filepath-securejoin\"\n\t\"github.com/moby/sys/mountinfo\"\n\t\"github.com/mrunalp/fileutils\"\n\t\"github.com/opencontainers/runc/libcontainer/cgroups\"\n\t\"github.com/opencontainers/runc/libcontainer/cgroups/fs2\"\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/opencontainers/runc/libcontainer/devices\"\n\t\"github.com/opencontainers/runc/libcontainer/userns\"\n\t\"github.com/opencontainers/runc/libcontainer/utils\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/opencontainers/selinux/go-selinux/label\"\n\t\"github.com/sirupsen/logrus\"\n\t\"golang.org/x/sys/unix\"\n)\n\nconst defaultMountFlags = unix.MS_NOEXEC | unix.MS_NOSUID | unix.MS_NODEV\n\ntype mountConfig struct {\n\troot            string\n\tlabel           string\n\tcgroup2Path     string\n\trootlessCgroups bool\n\tcgroupns        bool\n\tfd              *int\n}\n\n// needsSetupDev returns true if /dev needs to be set up.\nfunc needsSetupDev(config *configs.Config) bool {\n\tfor _, m := range config.Mounts {\n\t\tif m.Device == \"bind\" && utils.CleanPath(m.Destination) == \"/dev\" {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// prepareRootfs sets up the devices, mount points, and filesystems for use\n// inside a new mount namespace. It doesn't set anything as ro. You must call\n// finalizeRootfs after this function to finish setting up the rootfs.\nfunc prepareRootfs(pipe io.ReadWriter, iConfig *initConfig, mountFds []int) (err error) {\n\tconfig := iConfig.Config\n\tif err := prepareRoot(config); err != nil {\n\t\treturn fmt.Errorf(\"error preparing rootfs: %w\", err)\n\t}\n\n\tif mountFds != nil && len(mountFds) != len(config.Mounts) {\n\t\treturn fmt.Errorf(\"malformed mountFds slice. Expected size: %v, got: %v. Slice: %v\", len(config.Mounts), len(mountFds), mountFds)\n\t}\n\n\tmountConfig := &mountConfig{\n\t\troot:            config.Rootfs,\n\t\tlabel:           config.MountLabel,\n\t\tcgroup2Path:     iConfig.Cgroup2Path,\n\t\trootlessCgroups: iConfig.RootlessCgroups,\n\t\tcgroupns:        config.Namespaces.Contains(configs.NEWCGROUP),\n\t}\n\tsetupDev := needsSetupDev(config)\n\tfor i, m := range config.Mounts {\n\t\tfor _, precmd := range m.PremountCmds {\n\t\t\tif err := mountCmd(precmd); err != nil {\n\t\t\t\treturn fmt.Errorf(\"error running premount command: %w\", err)\n\t\t\t}\n\t\t}\n\n\t\t// Just before the loop we checked that if not empty, len(mountFds) == len(config.Mounts).\n\t\t// Therefore, we can access mountFds[i] without any concerns.\n\t\tif mountFds != nil && mountFds[i] != -1 {\n\t\t\tmountConfig.fd = &mountFds[i]\n\t\t}\n\n\t\tif err := mountToRootfs(m, mountConfig); err != nil {\n\t\t\treturn fmt.Errorf(\"error mounting %q to rootfs at %q: %w\", m.Source, m.Destination, err)\n\t\t}\n\n\t\tfor _, postcmd := range m.PostmountCmds {\n\t\t\tif err := mountCmd(postcmd); err != nil {\n\t\t\t\treturn fmt.Errorf(\"error running postmount command: %w\", err)\n\t\t\t}\n\t\t}\n\t}\n\n\tif setupDev {\n\t\tif err := createDevices(config); err != nil {\n\t\t\treturn fmt.Errorf(\"error creating device nodes: %w\", err)\n\t\t}\n\t\tif err := setupPtmx(config); err != nil {\n\t\t\treturn fmt.Errorf(\"error setting up ptmx: %w\", err)\n\t\t}\n\t\tif err := setupDevSymlinks(config.Rootfs); err != nil {\n\t\t\treturn fmt.Errorf(\"error setting up /dev symlinks: %w\", err)\n\t\t}\n\t}\n\n\t// Signal the parent to run the pre-start hooks.\n\t// The hooks are run after the mounts are setup, but before we switch to the new\n\t// root, so that the old root is still available in the hooks for any mount\n\t// manipulations.\n\t// Note that iConfig.Cwd is not guaranteed to exist here.\n\tif err := syncParentHooks(pipe); err != nil {\n\t\treturn err\n\t}\n\n\t// The reason these operations are done here rather than in finalizeRootfs\n\t// is because the console-handling code gets quite sticky if we have to set\n\t// up the console before doing the pivot_root(2). This is because the\n\t// Console API has to also work with the ExecIn case, which means that the\n\t// API must be able to deal with being inside as well as outside the\n\t// container. It's just cleaner to do this here (at the expense of the\n\t// operation not being perfectly split).\n\n\tif err := unix.Chdir(config.Rootfs); err != nil {\n\t\treturn &os.PathError{Op: \"chdir\", Path: config.Rootfs, Err: err}\n\t}\n\n\ts := iConfig.SpecState\n\ts.Pid = unix.Getpid()\n\ts.Status = specs.StateCreating\n\tif err := iConfig.Config.Hooks[configs.CreateContainer].RunHooks(s); err != nil {\n\t\treturn err\n\t}\n\n\tif config.NoPivotRoot {\n\t\terr = msMoveRoot(config.Rootfs)\n\t} else if config.Namespaces.Contains(configs.NEWNS) {\n\t\terr = pivotRoot(config.Rootfs)\n\t} else {\n\t\terr = chroot()\n\t}\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error jailing process inside rootfs: %w\", err)\n\t}\n\n\tif setupDev {\n\t\tif err := reOpenDevNull(); err != nil {\n\t\t\treturn fmt.Errorf(\"error reopening /dev/null inside container: %w\", err)\n\t\t}\n\t}\n\n\tif cwd := iConfig.Cwd; cwd != \"\" {\n\t\t// Note that spec.Process.Cwd can contain unclean value like  \"../../../../foo/bar...\".\n\t\t// However, we are safe to call MkDirAll directly because we are in the jail here.\n\t\tif err := os.MkdirAll(cwd, 0o755); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// finalizeRootfs sets anything to ro if necessary. You must call\n// prepareRootfs first.\nfunc finalizeRootfs(config *configs.Config) (err error) {\n\t// remount dev as ro if specified\n\tfor _, m := range config.Mounts {\n\t\tif utils.CleanPath(m.Destination) == \"/dev\" {\n\t\t\tif m.Flags&unix.MS_RDONLY == unix.MS_RDONLY {\n\t\t\t\tif err := remountReadonly(m); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// set rootfs ( / ) as readonly\n\tif config.Readonlyfs {\n\t\tif err := setReadonly(); err != nil {\n\t\t\treturn fmt.Errorf(\"error setting rootfs as readonly: %w\", err)\n\t\t}\n\t}\n\n\tif config.Umask != nil {\n\t\tunix.Umask(int(*config.Umask))\n\t} else {\n\t\tunix.Umask(0o022)\n\t}\n\treturn nil\n}\n\n// /tmp has to be mounted as private to allow MS_MOVE to work in all situations\nfunc prepareTmp(topTmpDir string) (string, error) {\n\ttmpdir, err := ioutil.TempDir(topTmpDir, \"runctop\")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := mount(tmpdir, tmpdir, \"\", \"bind\", unix.MS_BIND, \"\"); err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := mount(\"\", tmpdir, \"\", \"\", uintptr(unix.MS_PRIVATE), \"\"); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn tmpdir, nil\n}\n\nfunc cleanupTmp(tmpdir string) {\n\t_ = unix.Unmount(tmpdir, 0)\n\t_ = os.RemoveAll(tmpdir)\n}\n\nfunc mountCmd(cmd configs.Command) error {\n\tcommand := exec.Command(cmd.Path, cmd.Args[:]...)\n\tcommand.Env = cmd.Env\n\tcommand.Dir = cmd.Dir\n\tif out, err := command.CombinedOutput(); err != nil {\n\t\treturn fmt.Errorf(\"%#v failed: %s: %w\", cmd, string(out), err)\n\t}\n\treturn nil\n}\n\nfunc prepareBindMount(m *configs.Mount, rootfs string, mountFd *int) error {\n\tsource := m.Source\n\tif mountFd != nil {\n\t\tsource = \"/proc/self/fd/\" + strconv.Itoa(*mountFd)\n\t}\n\n\tstat, err := os.Stat(source)\n\tif err != nil {\n\t\t// error out if the source of a bind mount does not exist as we will be\n\t\t// unable to bind anything to it.\n\t\treturn err\n\t}\n\t// ensure that the destination of the bind mount is resolved of symlinks at mount time because\n\t// any previous mounts can invalidate the next mount's destination.\n\t// this can happen when a user specifies mounts within other mounts to cause breakouts or other\n\t// evil stuff to try to escape the container's rootfs.\n\tvar dest string\n\tif dest, err = securejoin.SecureJoin(rootfs, m.Destination); err != nil {\n\t\treturn err\n\t}\n\tif err := checkProcMount(rootfs, dest, source); err != nil {\n\t\treturn err\n\t}\n\tif err := createIfNotExists(dest, stat.IsDir()); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc mountCgroupV1(m *configs.Mount, c *mountConfig) error {\n\tbinds, err := getCgroupMounts(m)\n\tif err != nil {\n\t\treturn err\n\t}\n\tvar merged []string\n\tfor _, b := range binds {\n\t\tss := filepath.Base(b.Destination)\n\t\tif strings.Contains(ss, \",\") {\n\t\t\tmerged = append(merged, ss)\n\t\t}\n\t}\n\ttmpfs := &configs.Mount{\n\t\tSource:           \"tmpfs\",\n\t\tDevice:           \"tmpfs\",\n\t\tDestination:      m.Destination,\n\t\tFlags:            defaultMountFlags,\n\t\tData:             \"mode=755\",\n\t\tPropagationFlags: m.PropagationFlags,\n\t}\n\n\tif err := mountToRootfs(tmpfs, c); err != nil {\n\t\treturn err\n\t}\n\n\tfor _, b := range binds {\n\t\tif c.cgroupns {\n\t\t\tsubsystemPath := filepath.Join(c.root, b.Destination)\n\t\t\tif err := os.MkdirAll(subsystemPath, 0o755); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif err := utils.WithProcfd(c.root, b.Destination, func(procfd string) error {\n\t\t\t\tflags := defaultMountFlags\n\t\t\t\tif m.Flags&unix.MS_RDONLY != 0 {\n\t\t\t\t\tflags = flags | unix.MS_RDONLY\n\t\t\t\t}\n\t\t\t\tvar (\n\t\t\t\t\tsource = \"cgroup\"\n\t\t\t\t\tdata   = filepath.Base(subsystemPath)\n\t\t\t\t)\n\t\t\t\tif data == \"systemd\" {\n\t\t\t\t\tdata = cgroups.CgroupNamePrefix + data\n\t\t\t\t\tsource = \"systemd\"\n\t\t\t\t}\n\t\t\t\treturn mount(source, b.Destination, procfd, \"cgroup\", uintptr(flags), data)\n\t\t\t}); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\tif err := mountToRootfs(b, c); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\tfor _, mc := range merged {\n\t\tfor _, ss := range strings.Split(mc, \",\") {\n\t\t\t// symlink(2) is very dumb, it will just shove the path into\n\t\t\t// the link and doesn't do any checks or relative path\n\t\t\t// conversion. Also, don't error out if the cgroup already exists.\n\t\t\tif err := os.Symlink(mc, filepath.Join(c.root, m.Destination, ss)); err != nil && !os.IsExist(err) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc mountCgroupV2(m *configs.Mount, c *mountConfig) error {\n\tdest, err := securejoin.SecureJoin(c.root, m.Destination)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := os.MkdirAll(dest, 0o755); err != nil {\n\t\treturn err\n\t}\n\treturn utils.WithProcfd(c.root, m.Destination, func(procfd string) error {\n\t\tif err := mount(m.Source, m.Destination, procfd, \"cgroup2\", uintptr(m.Flags), m.Data); err != nil {\n\t\t\t// when we are in UserNS but CgroupNS is not unshared, we cannot mount cgroup2 (#2158)\n\t\t\tif errors.Is(err, unix.EPERM) || errors.Is(err, unix.EBUSY) {\n\t\t\t\tsrc := fs2.UnifiedMountpoint\n\t\t\t\tif c.cgroupns && c.cgroup2Path != \"\" {\n\t\t\t\t\t// Emulate cgroupns by bind-mounting\n\t\t\t\t\t// the container cgroup path rather than\n\t\t\t\t\t// the whole /sys/fs/cgroup.\n\t\t\t\t\tsrc = c.cgroup2Path\n\t\t\t\t}\n\t\t\t\terr = mount(src, m.Destination, procfd, \"\", uintptr(m.Flags)|unix.MS_BIND, \"\")\n\t\t\t\tif c.rootlessCgroups && errors.Is(err, unix.ENOENT) {\n\t\t\t\t\terr = nil\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc doTmpfsCopyUp(m *configs.Mount, rootfs, mountLabel string) (Err error) {\n\t// Set up a scratch dir for the tmpfs on the host.\n\ttmpdir, err := prepareTmp(\"/tmp\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"tmpcopyup: failed to setup tmpdir: %w\", err)\n\t}\n\tdefer cleanupTmp(tmpdir)\n\ttmpDir, err := ioutil.TempDir(tmpdir, \"runctmpdir\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"tmpcopyup: failed to create tmpdir: %w\", err)\n\t}\n\tdefer os.RemoveAll(tmpDir)\n\n\t// Configure the *host* tmpdir as if it's the container mount. We change\n\t// m.Destination since we are going to mount *on the host*.\n\toldDest := m.Destination\n\tm.Destination = tmpDir\n\terr = mountPropagate(m, \"/\", mountLabel, nil)\n\tm.Destination = oldDest\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() {\n\t\tif Err != nil {\n\t\t\tif err := unmount(tmpDir, unix.MNT_DETACH); err != nil {\n\t\t\t\tlogrus.Warnf(\"tmpcopyup: %v\", err)\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn utils.WithProcfd(rootfs, m.Destination, func(procfd string) (Err error) {\n\t\t// Copy the container data to the host tmpdir. We append \"/\" to force\n\t\t// CopyDirectory to resolve the symlink rather than trying to copy the\n\t\t// symlink itself.\n\t\tif err := fileutils.CopyDirectory(procfd+\"/\", tmpDir); err != nil {\n\t\t\treturn fmt.Errorf(\"tmpcopyup: failed to copy %s to %s (%s): %w\", m.Destination, procfd, tmpDir, err)\n\t\t}\n\t\t// Now move the mount into the container.\n\t\tif err := mount(tmpDir, m.Destination, procfd, \"\", unix.MS_MOVE, \"\"); err != nil {\n\t\t\treturn fmt.Errorf(\"tmpcopyup: failed to move mount: %w\", err)\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc mountToRootfs(m *configs.Mount, c *mountConfig) error {\n\trootfs := c.root\n\tmountLabel := c.label\n\tmountFd := c.fd\n\tdest, err := securejoin.SecureJoin(rootfs, m.Destination)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tswitch m.Device {\n\tcase \"proc\", \"sysfs\":\n\t\t// If the destination already exists and is not a directory, we bail\n\t\t// out This is to avoid mounting through a symlink or similar -- which\n\t\t// has been a \"fun\" attack scenario in the past.\n\t\t// TODO: This won't be necessary once we switch to libpathrs and we can\n\t\t//       stop all of these symlink-exchange attacks.\n\t\tif fi, err := os.Lstat(dest); err != nil {\n\t\t\tif !os.IsNotExist(err) {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else if fi.Mode()&os.ModeDir == 0 {\n\t\t\treturn fmt.Errorf(\"filesystem %q must be mounted on ordinary directory\", m.Device)\n\t\t}\n\t\tif err := os.MkdirAll(dest, 0o755); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Selinux kernels do not support labeling of /proc or /sys\n\t\treturn mountPropagate(m, rootfs, \"\", nil)\n\tcase \"mqueue\":\n\t\tif err := os.MkdirAll(dest, 0o755); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := mountPropagate(m, rootfs, \"\", nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn label.SetFileLabel(dest, mountLabel)\n\tcase \"tmpfs\":\n\t\tstat, err := os.Stat(dest)\n\t\tif err != nil {\n\t\t\tif err := os.MkdirAll(dest, 0o755); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tif m.Extensions&configs.EXT_COPYUP == configs.EXT_COPYUP {\n\t\t\terr = doTmpfsCopyUp(m, rootfs, mountLabel)\n\t\t} else {\n\t\t\terr = mountPropagate(m, rootfs, mountLabel, nil)\n\t\t}\n\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif stat != nil {\n\t\t\tif err = os.Chmod(dest, stat.Mode()); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\t// Initially mounted rw in mountPropagate, remount to ro if flag set.\n\t\tif m.Flags&unix.MS_RDONLY != 0 {\n\t\t\tif err := remount(m, rootfs, mountFd); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\tcase \"bind\":\n\t\tif err := prepareBindMount(m, rootfs, mountFd); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := mountPropagate(m, rootfs, mountLabel, mountFd); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// bind mount won't change mount options, we need remount to make mount options effective.\n\t\t// first check that we have non-default options required before attempting a remount\n\t\tif m.Flags&^(unix.MS_REC|unix.MS_REMOUNT|unix.MS_BIND) != 0 {\n\t\t\t// only remount if unique mount options are set\n\t\t\tif err := remount(m, rootfs, mountFd); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tif m.Relabel != \"\" {\n\t\t\tif err := label.Validate(m.Relabel); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tshared := label.IsShared(m.Relabel)\n\t\t\tif err := label.Relabel(m.Source, mountLabel, shared); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\tcase \"cgroup\":\n\t\tif cgroups.IsCgroup2UnifiedMode() {\n\t\t\treturn mountCgroupV2(m, c)\n\t\t}\n\t\treturn mountCgroupV1(m, c)\n\tdefault:\n\t\tif err := checkProcMount(rootfs, dest, m.Source); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := os.MkdirAll(dest, 0o755); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn mountPropagate(m, rootfs, mountLabel, mountFd)\n\t}\n\treturn nil\n}\n\nfunc getCgroupMounts(m *configs.Mount) ([]*configs.Mount, error) {\n\tmounts, err := cgroups.GetCgroupMounts(false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tcgroupPaths, err := cgroups.ParseCgroupFile(\"/proc/self/cgroup\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar binds []*configs.Mount\n\n\tfor _, mm := range mounts {\n\t\tdir, err := mm.GetOwnCgroup(cgroupPaths)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\trelDir, err := filepath.Rel(mm.Root, dir)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tbinds = append(binds, &configs.Mount{\n\t\t\tDevice:           \"bind\",\n\t\t\tSource:           filepath.Join(mm.Mountpoint, relDir),\n\t\t\tDestination:      filepath.Join(m.Destination, filepath.Base(mm.Mountpoint)),\n\t\t\tFlags:            unix.MS_BIND | unix.MS_REC | m.Flags,\n\t\t\tPropagationFlags: m.PropagationFlags,\n\t\t})\n\t}\n\n\treturn binds, nil\n}\n\n// checkProcMount checks to ensure that the mount destination is not over the top of /proc.\n// dest is required to be an abs path and have any symlinks resolved before calling this function.\n//\n// if source is nil, don't stat the filesystem.  This is used for restore of a checkpoint.\nfunc checkProcMount(rootfs, dest, source string) error {\n\tconst procPath = \"/proc\"\n\tpath, err := filepath.Rel(filepath.Join(rootfs, procPath), dest)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// pass if the mount path is located outside of /proc\n\tif strings.HasPrefix(path, \"..\") {\n\t\treturn nil\n\t}\n\tif path == \".\" {\n\t\t// an empty source is pasted on restore\n\t\tif source == \"\" {\n\t\t\treturn nil\n\t\t}\n\t\t// only allow a mount on-top of proc if it's source is \"proc\"\n\t\tisproc, err := isProc(source)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// pass if the mount is happening on top of /proc and the source of\n\t\t// the mount is a proc filesystem\n\t\tif isproc {\n\t\t\treturn nil\n\t\t}\n\t\treturn fmt.Errorf(\"%q cannot be mounted because it is not of type proc\", dest)\n\t}\n\n\t// Here dest is definitely under /proc. Do not allow those,\n\t// except for a few specific entries emulated by lxcfs.\n\tvalidProcMounts := []string{\n\t\t\"/proc/cpuinfo\",\n\t\t\"/proc/diskstats\",\n\t\t\"/proc/meminfo\",\n\t\t\"/proc/stat\",\n\t\t\"/proc/swaps\",\n\t\t\"/proc/uptime\",\n\t\t\"/proc/loadavg\",\n\t\t\"/proc/slabinfo\",\n\t\t\"/proc/net/dev\",\n\t}\n\tfor _, valid := range validProcMounts {\n\t\tpath, err := filepath.Rel(filepath.Join(rootfs, valid), dest)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif path == \".\" {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn fmt.Errorf(\"%q cannot be mounted because it is inside /proc\", dest)\n}\n\nfunc isProc(path string) (bool, error) {\n\tvar s unix.Statfs_t\n\tif err := unix.Statfs(path, &s); err != nil {\n\t\treturn false, &os.PathError{Op: \"statfs\", Path: path, Err: err}\n\t}\n\treturn s.Type == unix.PROC_SUPER_MAGIC, nil\n}\n\nfunc setupDevSymlinks(rootfs string) error {\n\tlinks := [][2]string{\n\t\t{\"/proc/self/fd\", \"/dev/fd\"},\n\t\t{\"/proc/self/fd/0\", \"/dev/stdin\"},\n\t\t{\"/proc/self/fd/1\", \"/dev/stdout\"},\n\t\t{\"/proc/self/fd/2\", \"/dev/stderr\"},\n\t}\n\t// kcore support can be toggled with CONFIG_PROC_KCORE; only create a symlink\n\t// in /dev if it exists in /proc.\n\tif _, err := os.Stat(\"/proc/kcore\"); err == nil {\n\t\tlinks = append(links, [2]string{\"/proc/kcore\", \"/dev/core\"})\n\t}\n\tfor _, link := range links {\n\t\tvar (\n\t\t\tsrc = link[0]\n\t\t\tdst = filepath.Join(rootfs, link[1])\n\t\t)\n\t\tif err := os.Symlink(src, dst); err != nil && !os.IsExist(err) {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// If stdin, stdout, and/or stderr are pointing to `/dev/null` in the parent's rootfs\n// this method will make them point to `/dev/null` in this container's rootfs.  This\n// needs to be called after we chroot/pivot into the container's rootfs so that any\n// symlinks are resolved locally.\nfunc reOpenDevNull() error {\n\tvar stat, devNullStat unix.Stat_t\n\tfile, err := os.OpenFile(\"/dev/null\", os.O_RDWR, 0)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer file.Close() //nolint: errcheck\n\tif err := unix.Fstat(int(file.Fd()), &devNullStat); err != nil {\n\t\treturn &os.PathError{Op: \"fstat\", Path: file.Name(), Err: err}\n\t}\n\tfor fd := 0; fd < 3; fd++ {\n\t\tif err := unix.Fstat(fd, &stat); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif stat.Rdev == devNullStat.Rdev {\n\t\t\t// Close and re-open the fd.\n\t\t\tif err := unix.Dup3(int(file.Fd()), fd, 0); err != nil {\n\t\t\t\treturn &os.PathError{\n\t\t\t\t\tOp:   \"dup3\",\n\t\t\t\t\tPath: \"fd \" + strconv.Itoa(int(file.Fd())),\n\t\t\t\t\tErr:  err,\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// Create the device nodes in the container.\nfunc createDevices(config *configs.Config) error {\n\tuseBindMount := userns.RunningInUserNS() || config.Namespaces.Contains(configs.NEWUSER)\n\toldMask := unix.Umask(0o000)\n\tfor _, node := range config.Devices {\n\n\t\t// The /dev/ptmx device is setup by setupPtmx()\n\t\tif utils.CleanPath(node.Path) == \"/dev/ptmx\" {\n\t\t\tcontinue\n\t\t}\n\n\t\t// containers running in a user namespace are not allowed to mknod\n\t\t// devices so we can just bind mount it from the host.\n\t\tif err := createDeviceNode(config.Rootfs, node, useBindMount); err != nil {\n\t\t\tunix.Umask(oldMask)\n\t\t\treturn err\n\t\t}\n\t}\n\tunix.Umask(oldMask)\n\treturn nil\n}\n\nfunc bindMountDeviceNode(rootfs, dest string, node *devices.Device) error {\n\tf, err := os.Create(dest)\n\tif err != nil && !os.IsExist(err) {\n\t\treturn err\n\t}\n\tif f != nil {\n\t\t_ = f.Close()\n\t}\n\treturn utils.WithProcfd(rootfs, dest, func(procfd string) error {\n\t\treturn mount(node.Path, dest, procfd, \"bind\", unix.MS_BIND, \"\")\n\t})\n}\n\n// Creates the device node in the rootfs of the container.\nfunc createDeviceNode(rootfs string, node *devices.Device, bind bool) error {\n\tif node.Path == \"\" {\n\t\t// The node only exists for cgroup reasons, ignore it here.\n\t\treturn nil\n\t}\n\tdest, err := securejoin.SecureJoin(rootfs, node.Path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := os.MkdirAll(filepath.Dir(dest), 0o755); err != nil {\n\t\treturn err\n\t}\n\tif bind {\n\t\treturn bindMountDeviceNode(rootfs, dest, node)\n\t}\n\tif err := mknodDevice(dest, node); err != nil {\n\t\tif os.IsExist(err) {\n\t\t\treturn nil\n\t\t} else if os.IsPermission(err) {\n\t\t\treturn bindMountDeviceNode(rootfs, dest, node)\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc mknodDevice(dest string, node *devices.Device) error {\n\tfileMode := node.FileMode\n\tswitch node.Type {\n\tcase devices.BlockDevice:\n\t\tfileMode |= unix.S_IFBLK\n\tcase devices.CharDevice:\n\t\tfileMode |= unix.S_IFCHR\n\tcase devices.FifoDevice:\n\t\tfileMode |= unix.S_IFIFO\n\tdefault:\n\t\treturn fmt.Errorf(\"%c is not a valid device type for device %s\", node.Type, node.Path)\n\t}\n\tdev, err := node.Mkdev()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := unix.Mknod(dest, uint32(fileMode), int(dev)); err != nil {\n\t\treturn err\n\t}\n\treturn unix.Chown(dest, int(node.Uid), int(node.Gid))\n}\n\n// Get the parent mount point of directory passed in as argument. Also return\n// optional fields.\nfunc getParentMount(rootfs string) (string, string, error) {\n\tmi, err := mountinfo.GetMounts(mountinfo.ParentsFilter(rootfs))\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tif len(mi) < 1 {\n\t\treturn \"\", \"\", fmt.Errorf(\"could not find parent mount of %s\", rootfs)\n\t}\n\n\t// find the longest mount point\n\tvar idx, maxlen int\n\tfor i := range mi {\n\t\tif len(mi[i].Mountpoint) > maxlen {\n\t\t\tmaxlen = len(mi[i].Mountpoint)\n\t\t\tidx = i\n\t\t}\n\t}\n\treturn mi[idx].Mountpoint, mi[idx].Optional, nil\n}\n\n// Make parent mount private if it was shared\nfunc rootfsParentMountPrivate(rootfs string) error {\n\tsharedMount := false\n\n\tparentMount, optionalOpts, err := getParentMount(rootfs)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\toptsSplit := strings.Split(optionalOpts, \" \")\n\tfor _, opt := range optsSplit {\n\t\tif strings.HasPrefix(opt, \"shared:\") {\n\t\t\tsharedMount = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Make parent mount PRIVATE if it was shared. It is needed for two\n\t// reasons. First of all pivot_root() will fail if parent mount is\n\t// shared. Secondly when we bind mount rootfs it will propagate to\n\t// parent namespace and we don't want that to happen.\n\tif sharedMount {\n\t\treturn mount(\"\", parentMount, \"\", \"\", unix.MS_PRIVATE, \"\")\n\t}\n\n\treturn nil\n}\n\nfunc prepareRoot(config *configs.Config) error {\n\tflag := unix.MS_SLAVE | unix.MS_REC\n\tif config.RootPropagation != 0 {\n\t\tflag = config.RootPropagation\n\t}\n\tif err := mount(\"\", \"/\", \"\", \"\", uintptr(flag), \"\"); err != nil {\n\t\treturn err\n\t}\n\n\t// Make parent mount private to make sure following bind mount does\n\t// not propagate in other namespaces. Also it will help with kernel\n\t// check pass in pivot_root. (IS_SHARED(new_mnt->mnt_parent))\n\tif err := rootfsParentMountPrivate(config.Rootfs); err != nil {\n\t\treturn err\n\t}\n\n\treturn mount(config.Rootfs, config.Rootfs, \"\", \"bind\", unix.MS_BIND|unix.MS_REC, \"\")\n}\n\nfunc setReadonly() error {\n\tflags := uintptr(unix.MS_BIND | unix.MS_REMOUNT | unix.MS_RDONLY)\n\n\terr := mount(\"\", \"/\", \"\", \"\", flags, \"\")\n\tif err == nil {\n\t\treturn nil\n\t}\n\tvar s unix.Statfs_t\n\tif err := unix.Statfs(\"/\", &s); err != nil {\n\t\treturn &os.PathError{Op: \"statfs\", Path: \"/\", Err: err}\n\t}\n\tflags |= uintptr(s.Flags)\n\treturn mount(\"\", \"/\", \"\", \"\", flags, \"\")\n}\n\nfunc setupPtmx(config *configs.Config) error {\n\tptmx := filepath.Join(config.Rootfs, \"dev/ptmx\")\n\tif err := os.Remove(ptmx); err != nil && !os.IsNotExist(err) {\n\t\treturn err\n\t}\n\tif err := os.Symlink(\"pts/ptmx\", ptmx); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// pivotRoot will call pivot_root such that rootfs becomes the new root\n// filesystem, and everything else is cleaned up.\nfunc pivotRoot(rootfs string) error {\n\t// While the documentation may claim otherwise, pivot_root(\".\", \".\") is\n\t// actually valid. What this results in is / being the new root but\n\t// /proc/self/cwd being the old root. Since we can play around with the cwd\n\t// with pivot_root this allows us to pivot without creating directories in\n\t// the rootfs. Shout-outs to the LXC developers for giving us this idea.\n\n\toldroot, err := unix.Open(\"/\", unix.O_DIRECTORY|unix.O_RDONLY, 0)\n\tif err != nil {\n\t\treturn &os.PathError{Op: \"open\", Path: \"/\", Err: err}\n\t}\n\tdefer unix.Close(oldroot) //nolint: errcheck\n\n\tnewroot, err := unix.Open(rootfs, unix.O_DIRECTORY|unix.O_RDONLY, 0)\n\tif err != nil {\n\t\treturn &os.PathError{Op: \"open\", Path: rootfs, Err: err}\n\t}\n\tdefer unix.Close(newroot) //nolint: errcheck\n\n\t// Change to the new root so that the pivot_root actually acts on it.\n\tif err := unix.Fchdir(newroot); err != nil {\n\t\treturn &os.PathError{Op: \"fchdir\", Path: \"fd \" + strconv.Itoa(newroot), Err: err}\n\t}\n\n\tif err := unix.PivotRoot(\".\", \".\"); err != nil {\n\t\treturn &os.PathError{Op: \"pivot_root\", Path: \".\", Err: err}\n\t}\n\n\t// Currently our \".\" is oldroot (according to the current kernel code).\n\t// However, purely for safety, we will fchdir(oldroot) since there isn't\n\t// really any guarantee from the kernel what /proc/self/cwd will be after a\n\t// pivot_root(2).\n\n\tif err := unix.Fchdir(oldroot); err != nil {\n\t\treturn &os.PathError{Op: \"fchdir\", Path: \"fd \" + strconv.Itoa(oldroot), Err: err}\n\t}\n\n\t// Make oldroot rslave to make sure our unmounts don't propagate to the\n\t// host (and thus bork the machine). We don't use rprivate because this is\n\t// known to cause issues due to races where we still have a reference to a\n\t// mount while a process in the host namespace are trying to operate on\n\t// something they think has no mounts (devicemapper in particular).\n\tif err := mount(\"\", \".\", \"\", \"\", unix.MS_SLAVE|unix.MS_REC, \"\"); err != nil {\n\t\treturn err\n\t}\n\t// Perform the unmount. MNT_DETACH allows us to unmount /proc/self/cwd.\n\tif err := unmount(\".\", unix.MNT_DETACH); err != nil {\n\t\treturn err\n\t}\n\n\t// Switch back to our shiny new root.\n\tif err := unix.Chdir(\"/\"); err != nil {\n\t\treturn &os.PathError{Op: \"chdir\", Path: \"/\", Err: err}\n\t}\n\treturn nil\n}\n\nfunc msMoveRoot(rootfs string) error {\n\t// Before we move the root and chroot we have to mask all \"full\" sysfs and\n\t// procfs mounts which exist on the host. This is because while the kernel\n\t// has protections against mounting procfs if it has masks, when using\n\t// chroot(2) the *host* procfs mount is still reachable in the mount\n\t// namespace and the kernel permits procfs mounts inside --no-pivot\n\t// containers.\n\t//\n\t// Users shouldn't be using --no-pivot except in exceptional circumstances,\n\t// but to avoid such a trivial security flaw we apply a best-effort\n\t// protection here. The kernel only allows a mount of a pseudo-filesystem\n\t// like procfs or sysfs if there is a *full* mount (the root of the\n\t// filesystem is mounted) without any other locked mount points covering a\n\t// subtree of the mount.\n\t//\n\t// So we try to unmount (or mount tmpfs on top of) any mountpoint which is\n\t// a full mount of either sysfs or procfs (since those are the most\n\t// concerning filesystems to us).\n\tmountinfos, err := mountinfo.GetMounts(func(info *mountinfo.Info) (skip, stop bool) {\n\t\t// Collect every sysfs and procfs filesystem, except for those which\n\t\t// are non-full mounts or are inside the rootfs of the container.\n\t\tif info.Root != \"/\" ||\n\t\t\t(info.FSType != \"proc\" && info.FSType != \"sysfs\") ||\n\t\t\tstrings.HasPrefix(info.Mountpoint, rootfs) {\n\t\t\tskip = true\n\t\t}\n\t\treturn\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, info := range mountinfos {\n\t\tp := info.Mountpoint\n\t\t// Be sure umount events are not propagated to the host.\n\t\tif err := mount(\"\", p, \"\", \"\", unix.MS_SLAVE|unix.MS_REC, \"\"); err != nil {\n\t\t\tif errors.Is(err, unix.ENOENT) {\n\t\t\t\t// If the mountpoint doesn't exist that means that we've\n\t\t\t\t// already blasted away some parent directory of the mountpoint\n\t\t\t\t// and so we don't care about this error.\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tif err := unmount(p, unix.MNT_DETACH); err != nil {\n\t\t\tif !errors.Is(err, unix.EINVAL) && !errors.Is(err, unix.EPERM) {\n\t\t\t\treturn err\n\t\t\t} else {\n\t\t\t\t// If we have not privileges for umounting (e.g. rootless), then\n\t\t\t\t// cover the path.\n\t\t\t\tif err := mount(\"tmpfs\", p, \"\", \"tmpfs\", 0, \"\"); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Move the rootfs on top of \"/\" in our mount namespace.\n\tif err := mount(rootfs, \"/\", \"\", \"\", unix.MS_MOVE, \"\"); err != nil {\n\t\treturn err\n\t}\n\treturn chroot()\n}\n\nfunc chroot() error {\n\tif err := unix.Chroot(\".\"); err != nil {\n\t\treturn &os.PathError{Op: \"chroot\", Path: \".\", Err: err}\n\t}\n\tif err := unix.Chdir(\"/\"); err != nil {\n\t\treturn &os.PathError{Op: \"chdir\", Path: \"/\", Err: err}\n\t}\n\treturn nil\n}\n\n// createIfNotExists creates a file or a directory only if it does not already exist.\nfunc createIfNotExists(path string, isDir bool) error {\n\tif _, err := os.Stat(path); err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\tif isDir {\n\t\t\t\treturn os.MkdirAll(path, 0o755)\n\t\t\t}\n\t\t\tif err := os.MkdirAll(filepath.Dir(path), 0o755); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tf, err := os.OpenFile(path, os.O_CREATE, 0o755)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t_ = f.Close()\n\t\t}\n\t}\n\treturn nil\n}\n\n// readonlyPath will make a path read only.\nfunc readonlyPath(path string) error {\n\tif err := mount(path, path, \"\", \"\", unix.MS_BIND|unix.MS_REC, \"\"); err != nil {\n\t\tif errors.Is(err, os.ErrNotExist) {\n\t\t\treturn nil\n\t\t}\n\t\treturn err\n\t}\n\n\tvar s unix.Statfs_t\n\tif err := unix.Statfs(path, &s); err != nil {\n\t\treturn &os.PathError{Op: \"statfs\", Path: path, Err: err}\n\t}\n\tflags := uintptr(s.Flags) & (unix.MS_NOSUID | unix.MS_NODEV | unix.MS_NOEXEC)\n\n\tif err := mount(path, path, \"\", \"\", flags|unix.MS_BIND|unix.MS_REMOUNT|unix.MS_RDONLY, \"\"); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// remountReadonly will remount an existing mount point and ensure that it is read-only.\nfunc remountReadonly(m *configs.Mount) error {\n\tvar (\n\t\tdest  = m.Destination\n\t\tflags = m.Flags\n\t)\n\tfor i := 0; i < 5; i++ {\n\t\t// There is a special case in the kernel for\n\t\t// MS_REMOUNT | MS_BIND, which allows us to change only the\n\t\t// flags even as an unprivileged user (i.e. user namespace)\n\t\t// assuming we don't drop any security related flags (nodev,\n\t\t// nosuid, etc.). So, let's use that case so that we can do\n\t\t// this re-mount without failing in a userns.\n\t\tflags |= unix.MS_REMOUNT | unix.MS_BIND | unix.MS_RDONLY\n\t\tif err := mount(\"\", dest, \"\", \"\", uintptr(flags), \"\"); err != nil {\n\t\t\tif errors.Is(err, unix.EBUSY) {\n\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"unable to mount %s as readonly max retries reached\", dest)\n}\n\n// maskPath masks the top of the specified path inside a container to avoid\n// security issues from processes reading information from non-namespace aware\n// mounts ( proc/kcore ).\n// For files, maskPath bind mounts /dev/null over the top of the specified path.\n// For directories, maskPath mounts read-only tmpfs over the top of the specified path.\nfunc maskPath(path string, mountLabel string) error {\n\tif err := mount(\"/dev/null\", path, \"\", \"\", unix.MS_BIND, \"\"); err != nil && !errors.Is(err, os.ErrNotExist) {\n\t\tif errors.Is(err, unix.ENOTDIR) {\n\t\t\treturn mount(\"tmpfs\", path, \"\", \"tmpfs\", unix.MS_RDONLY, label.FormatMountLabel(\"\", mountLabel))\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// writeSystemProperty writes the value to a path under /proc/sys as determined from the key.\n// For e.g. net.ipv4.ip_forward translated to /proc/sys/net/ipv4/ip_forward.\nfunc writeSystemProperty(key, value string) error {\n\tkeyPath := strings.Replace(key, \".\", \"/\", -1)\n\treturn ioutil.WriteFile(path.Join(\"/proc/sys\", keyPath), []byte(value), 0o644)\n}\n\nfunc remount(m *configs.Mount, rootfs string, mountFd *int) error {\n\tsource := m.Source\n\tif mountFd != nil {\n\t\tsource = \"/proc/self/fd/\" + strconv.Itoa(*mountFd)\n\t}\n\n\treturn utils.WithProcfd(rootfs, m.Destination, func(procfd string) error {\n\t\treturn mount(source, m.Destination, procfd, m.Device, uintptr(m.Flags|unix.MS_REMOUNT), \"\")\n\t})\n}\n\n// Do the mount operation followed by additional mounts required to take care\n// of propagation flags. This will always be scoped inside the container rootfs.\nfunc mountPropagate(m *configs.Mount, rootfs string, mountLabel string, mountFd *int) error {\n\tvar (\n\t\tdata  = label.FormatMountLabel(m.Data, mountLabel)\n\t\tflags = m.Flags\n\t)\n\t// Delay mounting the filesystem read-only if we need to do further\n\t// operations on it. We need to set up files in \"/dev\" and tmpfs mounts may\n\t// need to be chmod-ed after mounting. The mount will be remounted ro later\n\t// in finalizeRootfs() if necessary.\n\tif utils.CleanPath(m.Destination) == \"/dev\" || m.Device == \"tmpfs\" {\n\t\tflags &= ^unix.MS_RDONLY\n\t}\n\n\t// Because the destination is inside a container path which might be\n\t// mutating underneath us, we verify that we are actually going to mount\n\t// inside the container with WithProcfd() -- mounting through a procfd\n\t// mounts on the target.\n\tsource := m.Source\n\tif mountFd != nil {\n\t\tsource = \"/proc/self/fd/\" + strconv.Itoa(*mountFd)\n\t}\n\n\tif err := utils.WithProcfd(rootfs, m.Destination, func(procfd string) error {\n\t\treturn mount(source, m.Destination, procfd, m.Device, uintptr(flags), data)\n\t}); err != nil {\n\t\treturn err\n\t}\n\t// We have to apply mount propagation flags in a separate WithProcfd() call\n\t// because the previous call invalidates the passed procfd -- the mount\n\t// target needs to be re-opened.\n\tif err := utils.WithProcfd(rootfs, m.Destination, func(procfd string) error {\n\t\tfor _, pflag := range m.PropagationFlags {\n\t\t\tif err := mount(\"\", m.Destination, procfd, \"\", uintptr(pflag), \"\"); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\treturn fmt.Errorf(\"change mount propagation through procfd: %w\", err)\n\t}\n\treturn nil\n}\n", "package libcontainer\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"runtime\"\n\t\"strconv\"\n\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/opencontainers/selinux/go-selinux\"\n\t\"github.com/sirupsen/logrus\"\n\t\"golang.org/x/sys/unix\"\n\n\t\"github.com/opencontainers/runc/libcontainer/apparmor\"\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/opencontainers/runc/libcontainer/keys\"\n\t\"github.com/opencontainers/runc/libcontainer/seccomp\"\n\t\"github.com/opencontainers/runc/libcontainer/system\"\n)\n\ntype linuxStandardInit struct {\n\tpipe          *os.File\n\tconsoleSocket *os.File\n\tparentPid     int\n\tfifoFd        int\n\tlogFd         int\n\tmountFds      []int\n\tconfig        *initConfig\n}\n\nfunc (l *linuxStandardInit) getSessionRingParams() (string, uint32, uint32) {\n\tvar newperms uint32\n\n\tif l.config.Config.Namespaces.Contains(configs.NEWUSER) {\n\t\t// With user ns we need 'other' search permissions.\n\t\tnewperms = 0x8\n\t} else {\n\t\t// Without user ns we need 'UID' search permissions.\n\t\tnewperms = 0x80000\n\t}\n\n\t// Create a unique per session container name that we can join in setns;\n\t// However, other containers can also join it.\n\treturn \"_ses.\" + l.config.ContainerId, 0xffffffff, newperms\n}\n\nfunc (l *linuxStandardInit) Init() error {\n\truntime.LockOSThread()\n\tdefer runtime.UnlockOSThread()\n\tif !l.config.Config.NoNewKeyring {\n\t\tif err := selinux.SetKeyLabel(l.config.ProcessLabel); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer selinux.SetKeyLabel(\"\") //nolint: errcheck\n\t\tringname, keepperms, newperms := l.getSessionRingParams()\n\n\t\t// Do not inherit the parent's session keyring.\n\t\tif sessKeyId, err := keys.JoinSessionKeyring(ringname); err != nil {\n\t\t\t// If keyrings aren't supported then it is likely we are on an\n\t\t\t// older kernel (or inside an LXC container). While we could bail,\n\t\t\t// the security feature we are using here is best-effort (it only\n\t\t\t// really provides marginal protection since VFS credentials are\n\t\t\t// the only significant protection of keyrings).\n\t\t\t//\n\t\t\t// TODO(cyphar): Log this so people know what's going on, once we\n\t\t\t//               have proper logging in 'runc init'.\n\t\t\tif !errors.Is(err, unix.ENOSYS) {\n\t\t\t\treturn fmt.Errorf(\"unable to join session keyring: %w\", err)\n\t\t\t}\n\t\t} else {\n\t\t\t// Make session keyring searchable. If we've gotten this far we\n\t\t\t// bail on any error -- we don't want to have a keyring with bad\n\t\t\t// permissions.\n\t\t\tif err := keys.ModKeyringPerm(sessKeyId, keepperms, newperms); err != nil {\n\t\t\t\treturn fmt.Errorf(\"unable to mod keyring permissions: %w\", err)\n\t\t\t}\n\t\t}\n\t}\n\n\tif err := setupNetwork(l.config); err != nil {\n\t\treturn err\n\t}\n\tif err := setupRoute(l.config.Config); err != nil {\n\t\treturn err\n\t}\n\n\t// initialises the labeling system\n\tselinux.GetEnabled()\n\n\t// We don't need the mountFds after prepareRootfs() nor if it fails.\n\terr := prepareRootfs(l.pipe, l.config, l.mountFds)\n\tfor _, m := range l.mountFds {\n\t\tif m == -1 {\n\t\t\tcontinue\n\t\t}\n\n\t\tif err := unix.Close(m); err != nil {\n\t\t\treturn fmt.Errorf(\"Unable to close mountFds fds: %w\", err)\n\t\t}\n\t}\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Set up the console. This has to be done *before* we finalize the rootfs,\n\t// but *after* we've given the user the chance to set up all of the mounts\n\t// they wanted.\n\tif l.config.CreateConsole {\n\t\tif err := setupConsole(l.consoleSocket, l.config, true); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := system.Setctty(); err != nil {\n\t\t\treturn &os.SyscallError{Syscall: \"ioctl(setctty)\", Err: err}\n\t\t}\n\t}\n\n\t// Finish the rootfs setup.\n\tif l.config.Config.Namespaces.Contains(configs.NEWNS) {\n\t\tif err := finalizeRootfs(l.config.Config); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif hostname := l.config.Config.Hostname; hostname != \"\" {\n\t\tif err := unix.Sethostname([]byte(hostname)); err != nil {\n\t\t\treturn &os.SyscallError{Syscall: \"sethostname\", Err: err}\n\t\t}\n\t}\n\tif err := apparmor.ApplyProfile(l.config.AppArmorProfile); err != nil {\n\t\treturn fmt.Errorf(\"unable to apply apparmor profile: %w\", err)\n\t}\n\n\tfor key, value := range l.config.Config.Sysctl {\n\t\tif err := writeSystemProperty(key, value); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tfor _, path := range l.config.Config.ReadonlyPaths {\n\t\tif err := readonlyPath(path); err != nil {\n\t\t\treturn fmt.Errorf(\"can't make %q read-only: %w\", path, err)\n\t\t}\n\t}\n\tfor _, path := range l.config.Config.MaskPaths {\n\t\tif err := maskPath(path, l.config.Config.MountLabel); err != nil {\n\t\t\treturn fmt.Errorf(\"can't mask path %s: %w\", path, err)\n\t\t}\n\t}\n\tpdeath, err := system.GetParentDeathSignal()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"can't get pdeath signal: %w\", err)\n\t}\n\tif l.config.NoNewPrivileges {\n\t\tif err := unix.Prctl(unix.PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0); err != nil {\n\t\t\treturn &os.SyscallError{Syscall: \"prctl(SET_NO_NEW_PRIVS)\", Err: err}\n\t\t}\n\t}\n\t// Tell our parent that we're ready to Execv. This must be done before the\n\t// Seccomp rules have been applied, because we need to be able to read and\n\t// write to a socket.\n\tif err := syncParentReady(l.pipe); err != nil {\n\t\treturn fmt.Errorf(\"sync ready: %w\", err)\n\t}\n\tif err := selinux.SetExecLabel(l.config.ProcessLabel); err != nil {\n\t\treturn fmt.Errorf(\"can't set process label: %w\", err)\n\t}\n\tdefer selinux.SetExecLabel(\"\") //nolint: errcheck\n\t// Without NoNewPrivileges seccomp is a privileged operation, so we need to\n\t// do this before dropping capabilities; otherwise do it as late as possible\n\t// just before execve so as few syscalls take place after it as possible.\n\tif l.config.Config.Seccomp != nil && !l.config.NoNewPrivileges {\n\t\tseccompFd, err := seccomp.InitSeccomp(l.config.Config.Seccomp)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := syncParentSeccomp(l.pipe, seccompFd); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tif err := finalizeNamespace(l.config); err != nil {\n\t\treturn err\n\t}\n\t// finalizeNamespace can change user/group which clears the parent death\n\t// signal, so we restore it here.\n\tif err := pdeath.Restore(); err != nil {\n\t\treturn fmt.Errorf(\"can't restore pdeath signal: %w\", err)\n\t}\n\t// Compare the parent from the initial start of the init process and make\n\t// sure that it did not change.  if the parent changes that means it died\n\t// and we were reparented to something else so we should just kill ourself\n\t// and not cause problems for someone else.\n\tif unix.Getppid() != l.parentPid {\n\t\treturn unix.Kill(unix.Getpid(), unix.SIGKILL)\n\t}\n\t// Check for the arg before waiting to make sure it exists and it is\n\t// returned as a create time error.\n\tname, err := exec.LookPath(l.config.Args[0])\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Set seccomp as close to execve as possible, so as few syscalls take\n\t// place afterward (reducing the amount of syscalls that users need to\n\t// enable in their seccomp profiles). However, this needs to be done\n\t// before closing the pipe since we need it to pass the seccompFd to\n\t// the parent.\n\tif l.config.Config.Seccomp != nil && l.config.NoNewPrivileges {\n\t\tseccompFd, err := seccomp.InitSeccomp(l.config.Config.Seccomp)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to init seccomp: %w\", err)\n\t\t}\n\n\t\tif err := syncParentSeccomp(l.pipe, seccompFd); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t// Close the pipe to signal that we have completed our init.\n\tlogrus.Debugf(\"init: closing the pipe to signal completion\")\n\t_ = l.pipe.Close()\n\n\t// Close the log pipe fd so the parent's ForwardLogs can exit.\n\tif err := unix.Close(l.logFd); err != nil {\n\t\treturn &os.PathError{Op: \"close log pipe\", Path: \"fd \" + strconv.Itoa(l.logFd), Err: err}\n\t}\n\n\t// Wait for the FIFO to be opened on the other side before exec-ing the\n\t// user process. We open it through /proc/self/fd/$fd, because the fd that\n\t// was given to us was an O_PATH fd to the fifo itself. Linux allows us to\n\t// re-open an O_PATH fd through /proc.\n\tfifoPath := \"/proc/self/fd/\" + strconv.Itoa(l.fifoFd)\n\tfd, err := unix.Open(fifoPath, unix.O_WRONLY|unix.O_CLOEXEC, 0)\n\tif err != nil {\n\t\treturn &os.PathError{Op: \"open exec fifo\", Path: fifoPath, Err: err}\n\t}\n\tif _, err := unix.Write(fd, []byte(\"0\")); err != nil {\n\t\treturn &os.PathError{Op: \"write exec fifo\", Path: fifoPath, Err: err}\n\t}\n\n\t// Close the O_PATH fifofd fd before exec because the kernel resets\n\t// dumpable in the wrong order. This has been fixed in newer kernels, but\n\t// we keep this to ensure CVE-2016-9962 doesn't re-emerge on older kernels.\n\t// N.B. the core issue itself (passing dirfds to the host filesystem) has\n\t// since been resolved.\n\t// https://github.com/torvalds/linux/blob/v4.9/fs/exec.c#L1290-L1318\n\t_ = unix.Close(l.fifoFd)\n\n\ts := l.config.SpecState\n\ts.Pid = unix.Getpid()\n\ts.Status = specs.StateCreated\n\tif err := l.config.Config.Hooks[configs.StartContainer].RunHooks(s); err != nil {\n\t\treturn err\n\t}\n\n\tif err := system.Exec(name, l.config.Args[0:], os.Environ()); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n"], "filenames": ["libcontainer/configs/mount.go", "libcontainer/container_linux.go", "libcontainer/factory_linux.go", "libcontainer/init_linux.go", "libcontainer/message_linux.go", "libcontainer/nsenter/nsexec.c", "libcontainer/rootfs_linux.go", "libcontainer/standard_init_linux.go"], "buggy_code_start_loc": [1, 523, 297, 79, 20, 6, 38, 28], "buggy_code_end_loc": [39, 2134, 361, 102, 20, 1021, 1067, 93], "fixing_code_start_loc": [2, 524, 298, 79, 21, 7, 39, 29], "fixing_code_end_loc": [46, 2210, 383, 109, 22, 1253, 1099, 108], "type": "CWE-190", "message": "runc is a CLI tool for spawning and running containers on Linux according to the OCI specification. In runc, netlink is used internally as a serialization system for specifying the relevant container configuration to the `C` portion of the code (responsible for the based namespace setup of containers). In all versions of runc prior to 1.0.3, the encoder did not handle the possibility of an integer overflow in the 16-bit length field for the byte array attribute type, meaning that a large enough malicious byte array attribute could result in the length overflowing and the attribute contents being parsed as netlink messages for container configuration. This vulnerability requires the attacker to have some control over the configuration of the container and would allow the attacker to bypass the namespace restrictions of the container by simply adding their own netlink payload which disables all namespaces. The main users impacted are those who allow untrusted images with untrusted configurations to run on their machines (such as with shared cloud infrastructure). runc version 1.0.3 contains a fix for this bug. As a workaround, one may try disallowing untrusted namespace paths from your container. It should be noted that untrusted namespace paths would allow the attacker to disable namespace protections entirely even in the absence of this bug.", "other": {"cve": {"id": "CVE-2021-43784", "sourceIdentifier": "security-advisories@github.com", "published": "2021-12-06T18:15:08.240", "lastModified": "2021-12-08T18:05:49.630", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "runc is a CLI tool for spawning and running containers on Linux according to the OCI specification. In runc, netlink is used internally as a serialization system for specifying the relevant container configuration to the `C` portion of the code (responsible for the based namespace setup of containers). In all versions of runc prior to 1.0.3, the encoder did not handle the possibility of an integer overflow in the 16-bit length field for the byte array attribute type, meaning that a large enough malicious byte array attribute could result in the length overflowing and the attribute contents being parsed as netlink messages for container configuration. This vulnerability requires the attacker to have some control over the configuration of the container and would allow the attacker to bypass the namespace restrictions of the container by simply adding their own netlink payload which disables all namespaces. The main users impacted are those who allow untrusted images with untrusted configurations to run on their machines (such as with shared cloud infrastructure). runc version 1.0.3 contains a fix for this bug. As a workaround, one may try disallowing untrusted namespace paths from your container. It should be noted that untrusted namespace paths would allow the attacker to disable namespace protections entirely even in the absence of this bug."}, {"lang": "es", "value": "runc es una herramienta CLI para generar y ejecutar contenedores en Linux seg\u00fan la especificaci\u00f3n OCI. En runc, netlink es usado internamente como un sistema de serializaci\u00f3n para especificar la configuraci\u00f3n relevante del contenedor a la porci\u00f3n \"C\" del c\u00f3digo (responsable de la configuraci\u00f3n del espacio de nombres basado en los contenedores). En todas las versiones de runc anteriores a la 1.0.3, el codificador no manejaba la posibilidad de un desbordamiento de enteros en el campo de longitud de 16 bits para el tipo de atributo de matriz de bytes, lo que significaba que un atributo de matriz de bytes suficientemente grande y malicioso pod\u00eda provocar el desbordamiento de la longitud y que el contenido del atributo fuera analizado como mensajes netlink para la configuraci\u00f3n del contenedor. Esta vulnerabilidad requiere que el atacante tenga cierto control sobre la configuraci\u00f3n del contenedor y le permitir\u00eda saltarse las restricciones de espacio de nombres del contenedor simplemente a\u00f1adiendo su propia carga \u00fatil de netlink que deshabilita todos los espacios de nombres. Los principales usuarios afectados son aquellos que permiten la ejecuci\u00f3n de im\u00e1genes no confiables con configuraciones no confiables en sus m\u00e1quinas (como en el caso de la infraestructura de nube compartida). runc versi\u00f3n 1.0.3 contiene una correcci\u00f3n para este bug. Como soluci\u00f3n, puede intentarse deshabilitar las rutas de espacios de nombres no confiables de su contenedor. Tenga en cuenta que las rutas de espacios de nombres no confiables permitir\u00edan al atacante deshabilitar las protecciones de espacios de nombres por completo incluso en ausencia de este bug"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 3.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 6.8, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:runc:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.3", "matchCriteriaId": "0EDE92EF-36C3-48E0-ADCF-FFAB45F903F2"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/project-zero/issues/detail?id=2241", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/opencontainers/runc/commit/9c444070ec7bb83995dbc0185da68284da71c554", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/opencontainers/runc/commit/d72d057ba794164c3cce9451a00b72a78b25e1ae", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/opencontainers/runc/commit/f50369af4b571e358f20b139eea52d612eb55eed", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/opencontainers/runc/security/advisories/GHSA-v95c-p5hm-xq8f", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/12/msg00005.html", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/opencontainers/runc/commit/9c444070ec7bb83995dbc0185da68284da71c554"}}