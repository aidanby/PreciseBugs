{"buggy_code": ["// Copyright (C) 2016 The Qt Company Ltd.\n// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only\n\n#include \"qsql_odbc_p.h\"\n#include <qsqlrecord.h>\n\n#if defined (Q_OS_WIN32)\n#include <qt_windows.h>\n#endif\n#include <qcoreapplication.h>\n#include <qdatetime.h>\n#include <qlist.h>\n#include <qmath.h>\n#include <qsqlerror.h>\n#include <qsqlfield.h>\n#include <qsqlindex.h>\n#include <qstringlist.h>\n#include <qvariant.h>\n#include <qvarlengtharray.h>\n#include <QDebug>\n#include <QSqlQuery>\n#include <QtSql/private/qsqldriver_p.h>\n#include <QtSql/private/qsqlresult_p.h>\n\nQT_BEGIN_NAMESPACE\n\nusing namespace Qt::StringLiterals;\n\n// undefine this to prevent initial check of the ODBC driver\n#define ODBC_CHECK_DRIVER\n\nstatic const int COLNAMESIZE = 256;\nstatic const SQLSMALLINT TABLENAMESIZE = 128;\n//Map Qt parameter types to ODBC types\nstatic const SQLSMALLINT qParamType[4] = { SQL_PARAM_INPUT, SQL_PARAM_INPUT, SQL_PARAM_OUTPUT, SQL_PARAM_INPUT_OUTPUT };\n\ninline static QString fromSQLTCHAR(const QVarLengthArray<SQLTCHAR>& input, qsizetype size=-1)\n{\n    QString result;\n\n    // Remove any trailing \\0 as some drivers misguidedly append one\n    int realsize = qMin(size, input.size());\n    if (realsize > 0 && input[realsize-1] == 0)\n        realsize--;\n    switch(sizeof(SQLTCHAR)) {\n        case 1:\n            result=QString::fromUtf8((const char *)input.constData(), realsize);\n            break;\n        case 2:\n            result = QString::fromUtf16(reinterpret_cast<const char16_t *>(input.constData()), realsize);\n            break;\n        case 4:\n            result = QString::fromUcs4(reinterpret_cast<const char32_t *>(input.constData()), realsize);\n            break;\n        default:\n            qCritical(\"sizeof(SQLTCHAR) is %d. Don't know how to handle this.\", int(sizeof(SQLTCHAR)));\n    }\n    return result;\n}\n\ntemplate <size_t SizeOfChar = sizeof(SQLTCHAR)>\nvoid toSQLTCHARImpl(QVarLengthArray<SQLTCHAR> &result, const QString &input); // primary template undefined\n\ntemplate <typename Container>\nvoid do_append(QVarLengthArray<SQLTCHAR> &result, const Container &c)\n{\n    result.append(reinterpret_cast<const SQLTCHAR *>(c.data()), c.size());\n}\n\ntemplate <>\nvoid toSQLTCHARImpl<1>(QVarLengthArray<SQLTCHAR> &result, const QString &input)\n{\n    const auto u8 = input.toUtf8();\n    do_append(result, u8);\n}\n\ntemplate <>\nvoid toSQLTCHARImpl<2>(QVarLengthArray<SQLTCHAR> &result, const QString &input)\n{\n    do_append(result, input);\n}\n\ntemplate <>\nvoid toSQLTCHARImpl<4>(QVarLengthArray<SQLTCHAR> &result, const QString &input)\n{\n    const auto u32 = input.toUcs4();\n    do_append(result, u32);\n}\n\ninline static QVarLengthArray<SQLTCHAR> toSQLTCHAR(const QString &input)\n{\n    QVarLengthArray<SQLTCHAR> result;\n    toSQLTCHARImpl(result, input);\n    result.append(0); // make sure it's null terminated, doesn't matter if it already is, it does if it isn't.\n    return result;\n}\n\nclass QODBCDriverPrivate : public QSqlDriverPrivate\n{\n    Q_DECLARE_PUBLIC(QODBCDriver)\n\npublic:\n    enum DefaultCase {Lower, Mixed, Upper, Sensitive};\n    using QSqlDriverPrivate::QSqlDriverPrivate;\n\n    SQLHANDLE hEnv = nullptr;\n    SQLHANDLE hDbc = nullptr;\n\n    int disconnectCount = 0;\n    int datetimePrecision = 19;\n    bool unicode = false;\n    bool useSchema = false;\n    bool isFreeTDSDriver = false;\n    bool hasSQLFetchScroll = true;\n    bool hasMultiResultSets = false;\n\n    bool checkDriver() const;\n    void checkUnicode();\n    void checkDBMS();\n    void checkHasSQLFetchScroll();\n    void checkHasMultiResults();\n    void checkSchemaUsage();\n    void checkDateTimePrecision();\n    bool setConnectionOptions(const QString& connOpts);\n    void splitTableQualifier(const QString &qualifier, QString &catalog,\n                             QString &schema, QString &table);\n    DefaultCase defaultCase() const;\n    QString adjustCase(const QString&) const;\n    QChar quoteChar();\nprivate:\n    bool isQuoteInitialized = false;\n    QChar quote = u'\"';\n};\n\nclass QODBCResultPrivate;\n\nclass QODBCResult: public QSqlResult\n{\n    Q_DECLARE_PRIVATE(QODBCResult)\n\npublic:\n    QODBCResult(const QODBCDriver *db);\n    virtual ~QODBCResult();\n\n    bool prepare(const QString &query) override;\n    bool exec() override;\n\n    QVariant lastInsertId() const override;\n    QVariant handle() const override;\n\nprotected:\n    bool fetchNext() override;\n    bool fetchFirst() override;\n    bool fetchLast() override;\n    bool fetchPrevious() override;\n    bool fetch(int i) override;\n    bool reset(const QString &query) override;\n    QVariant data(int field) override;\n    bool isNull(int field) override;\n    int size() override;\n    int numRowsAffected() override;\n    QSqlRecord record() const override;\n    void virtual_hook(int id, void *data) override;\n    void detachFromResultSet() override;\n    bool nextResult() override;\n};\n\nclass QODBCResultPrivate: public QSqlResultPrivate\n{\n    Q_DECLARE_PUBLIC(QODBCResult)\n\npublic:\n    Q_DECLARE_SQLDRIVER_PRIVATE(QODBCDriver)\n    QODBCResultPrivate(QODBCResult *q, const QODBCDriver *db)\n        : QSqlResultPrivate(q, db)\n    {\n        unicode = drv_d_func()->unicode;\n        useSchema = drv_d_func()->useSchema;\n        disconnectCount = drv_d_func()->disconnectCount;\n        hasSQLFetchScroll = drv_d_func()->hasSQLFetchScroll;\n    }\n\n    inline void clearValues()\n    { fieldCache.fill(QVariant()); fieldCacheIdx = 0; }\n\n    SQLHANDLE dpEnv() const { return drv_d_func() ? drv_d_func()->hEnv : 0;}\n    SQLHANDLE dpDbc() const { return drv_d_func() ? drv_d_func()->hDbc : 0;}\n    SQLHANDLE hStmt = nullptr;\n\n    QSqlRecord rInf;\n    QVariantList fieldCache;\n    int fieldCacheIdx = 0;\n    int disconnectCount = 0;\n    bool hasSQLFetchScroll = true;\n    bool unicode = false;\n    bool useSchema = false;\n\n    bool isStmtHandleValid() const;\n    void updateStmtHandleState();\n};\n\nbool QODBCResultPrivate::isStmtHandleValid() const\n{\n    return drv_d_func() && disconnectCount == drv_d_func()->disconnectCount;\n}\n\nvoid QODBCResultPrivate::updateStmtHandleState()\n{\n    disconnectCount = drv_d_func() ? drv_d_func()->disconnectCount : 0;\n}\n\nstatic QString qWarnODBCHandle(int handleType, SQLHANDLE handle, int *nativeCode = nullptr)\n{\n    SQLINTEGER nativeCode_ = 0;\n    SQLSMALLINT msgLen = 0;\n    SQLRETURN r = SQL_NO_DATA;\n    SQLTCHAR state_[SQL_SQLSTATE_SIZE+1];\n    QVarLengthArray<SQLTCHAR> description_(SQL_MAX_MESSAGE_LENGTH);\n    QString result;\n    int i = 1;\n\n    description_[0] = 0;\n    do {\n        r = SQLGetDiagRec(handleType,\n                          handle,\n                          i,\n                          state_,\n                          &nativeCode_,\n                          0,\n                          0,\n                          &msgLen);\n        if ((r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO) && msgLen > 0)\n            description_.resize(msgLen+1);\n        r = SQLGetDiagRec(handleType,\n                            handle,\n                            i,\n                            state_,\n                            &nativeCode_,\n                            description_.data(),\n                            description_.size(),\n                            &msgLen);\n        if (r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO) {\n            if (nativeCode)\n                *nativeCode = nativeCode_;\n            const QString tmpstore = fromSQLTCHAR(description_, msgLen);\n            if (result != tmpstore) {\n                if (!result.isEmpty())\n                    result += u' ';\n                result += tmpstore;\n            }\n        } else if (r == SQL_ERROR || r == SQL_INVALID_HANDLE) {\n            return result;\n        }\n        ++i;\n    } while (r != SQL_NO_DATA);\n    return result;\n}\n\nstatic QString qODBCWarn(const SQLHANDLE hStmt, const SQLHANDLE envHandle = 0,\n                         const SQLHANDLE pDbC = 0, int *nativeCode = nullptr)\n{\n    QString result;\n    if (envHandle)\n        result += qWarnODBCHandle(SQL_HANDLE_ENV, envHandle, nativeCode);\n    if (pDbC) {\n        const QString dMessage = qWarnODBCHandle(SQL_HANDLE_DBC, pDbC, nativeCode);\n        if (!dMessage.isEmpty()) {\n            if (!result.isEmpty())\n                result += u' ';\n            result += dMessage;\n        }\n    }\n    if (hStmt) {\n        const QString hMessage = qWarnODBCHandle(SQL_HANDLE_STMT, hStmt, nativeCode);\n        if (!hMessage.isEmpty()) {\n            if (!result.isEmpty())\n                result += u' ';\n            result += hMessage;\n        }\n    }\n    return result;\n}\n\nstatic QString qODBCWarn(const QODBCResultPrivate* odbc, int *nativeCode = nullptr)\n{\n    return qODBCWarn(odbc->hStmt, odbc->dpEnv(), odbc->dpDbc(), nativeCode);\n}\n\nstatic QString qODBCWarn(const QODBCDriverPrivate* odbc, int *nativeCode = nullptr)\n{\n    return qODBCWarn(0, odbc->hEnv, odbc->hDbc, nativeCode);\n}\n\nstatic void qSqlWarning(const QString& message, const QODBCResultPrivate* odbc)\n{\n    qWarning() << message << \"\\tError:\" << qODBCWarn(odbc);\n}\n\nstatic void qSqlWarning(const QString &message, const QODBCDriverPrivate *odbc)\n{\n    qWarning() << message << \"\\tError:\" << qODBCWarn(odbc);\n}\n\nstatic void qSqlWarning(const QString &message, const SQLHANDLE hStmt)\n{\n    qWarning() << message << \"\\tError:\" << qODBCWarn(hStmt);\n}\n\nstatic QSqlError qMakeError(const QString& err, QSqlError::ErrorType type, const QODBCResultPrivate* p)\n{\n    int nativeCode = -1;\n    QString message = qODBCWarn(p, &nativeCode);\n    return QSqlError(\"QODBC: \"_L1 + err, message, type,\n                     nativeCode != -1 ? QString::number(nativeCode) : QString());\n}\n\nstatic QSqlError qMakeError(const QString& err, QSqlError::ErrorType type,\n                            const QODBCDriverPrivate* p)\n{\n    int nativeCode = -1;\n    QString message = qODBCWarn(p, &nativeCode);\n    return QSqlError(\"QODBC: \"_L1 + err, message, type,\n                     nativeCode != -1 ? QString::number(nativeCode) : QString());\n}\n\nstatic QMetaType qDecodeODBCType(SQLSMALLINT sqltype, bool isSigned = true)\n{\n    int type = QMetaType::UnknownType;\n    switch (sqltype) {\n    case SQL_DECIMAL:\n    case SQL_NUMERIC:\n    case SQL_FLOAT: // 24 or 53 bits precision\n    case SQL_DOUBLE:// 53 bits\n        type = QMetaType::Double;\n        break;\n    case SQL_REAL:  // 24 bits\n        type = QMetaType::Float;\n        break;\n    case SQL_SMALLINT:\n        type = isSigned ? QMetaType::Short : QMetaType::UShort;\n        break;\n    case SQL_INTEGER:\n    case SQL_BIT:\n        type = isSigned ? QMetaType::Int : QMetaType::UInt;\n        break;\n    case SQL_TINYINT:\n        type = QMetaType::UInt;\n        break;\n    case SQL_BIGINT:\n        type = isSigned ? QMetaType::LongLong : QMetaType::ULongLong;\n        break;\n    case SQL_BINARY:\n    case SQL_VARBINARY:\n    case SQL_LONGVARBINARY:\n        type = QMetaType::QByteArray;\n        break;\n    case SQL_DATE:\n    case SQL_TYPE_DATE:\n        type = QMetaType::QDate;\n        break;\n    case SQL_TIME:\n    case SQL_TYPE_TIME:\n        type = QMetaType::QTime;\n        break;\n    case SQL_TIMESTAMP:\n    case SQL_TYPE_TIMESTAMP:\n        type = QMetaType::QDateTime;\n        break;\n    case SQL_WCHAR:\n    case SQL_WVARCHAR:\n    case SQL_WLONGVARCHAR:\n        type = QMetaType::QString;\n        break;\n    case SQL_CHAR:\n    case SQL_VARCHAR:\n#if (ODBCVER >= 0x0350)\n    case SQL_GUID:\n#endif\n    case SQL_LONGVARCHAR:\n        type = QMetaType::QString;\n        break;\n    default:\n        type = QMetaType::QByteArray;\n        break;\n    }\n    return QMetaType(type);\n}\n\nstatic QVariant qGetStringData(SQLHANDLE hStmt, int column, int colSize, bool unicode)\n{\n    QString fieldVal;\n    SQLRETURN r = SQL_ERROR;\n    SQLLEN lengthIndicator = 0;\n\n    // NB! colSize must be a multiple of 2 for unicode enabled DBs\n    if (colSize <= 0) {\n        colSize = 256;\n    } else if (colSize > 65536) { // limit buffer size to 64 KB\n        colSize = 65536;\n    } else {\n        colSize++; // make sure there is room for more than the 0 termination\n    }\n    if (unicode) {\n        r = SQLGetData(hStmt,\n                        column+1,\n                        SQL_C_TCHAR,\n                        NULL,\n                        0,\n                        &lengthIndicator);\n        if ((r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO) && lengthIndicator > 0)\n            colSize = int(lengthIndicator / sizeof(SQLTCHAR) + 1);\n        QVarLengthArray<SQLTCHAR> buf(colSize);\n        memset(buf.data(), 0, colSize*sizeof(SQLTCHAR));\n        while (true) {\n            r = SQLGetData(hStmt,\n                            column+1,\n                            SQL_C_TCHAR,\n                            (SQLPOINTER)buf.data(),\n                            colSize*sizeof(SQLTCHAR),\n                            &lengthIndicator);\n            if (r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO) {\n                if (lengthIndicator == SQL_NULL_DATA) {\n                    return {};\n                }\n                // starting with ODBC Native Client 2012, SQL_NO_TOTAL is returned\n                // instead of the length (which sometimes was wrong in older versions)\n                // see link for more info: http://msdn.microsoft.com/en-us/library/jj219209.aspx\n                // if length indicator equals SQL_NO_TOTAL, indicating that\n                // more data can be fetched, but size not known, collect data\n                // and fetch next block\n                if (lengthIndicator == SQL_NO_TOTAL) {\n                    fieldVal += fromSQLTCHAR(buf, colSize);\n                    continue;\n                }\n                // if SQL_SUCCESS_WITH_INFO is returned, indicating that\n                // more data can be fetched, the length indicator does NOT\n                // contain the number of bytes returned - it contains the\n                // total number of bytes that CAN be fetched\n                int rSize = (r == SQL_SUCCESS_WITH_INFO) ? colSize : int(lengthIndicator / sizeof(SQLTCHAR));\n                    fieldVal += fromSQLTCHAR(buf, rSize);\n                if (lengthIndicator < SQLLEN(colSize*sizeof(SQLTCHAR))) {\n                    // workaround for Drivermanagers that don't return SQL_NO_DATA\n                    break;\n                }\n            } else if (r == SQL_NO_DATA) {\n                break;\n            } else {\n                qWarning() << \"qGetStringData: Error while fetching data (\" << qWarnODBCHandle(SQL_HANDLE_STMT, hStmt) << ')';\n                return {};\n            }\n        }\n    } else {\n        r = SQLGetData(hStmt,\n                        column+1,\n                        SQL_C_CHAR,\n                        NULL,\n                        0,\n                        &lengthIndicator);\n        if ((r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO) && lengthIndicator > 0)\n            colSize = lengthIndicator + 1;\n        QVarLengthArray<SQLCHAR> buf(colSize);\n        while (true) {\n            r = SQLGetData(hStmt,\n                            column+1,\n                            SQL_C_CHAR,\n                            (SQLPOINTER)buf.data(),\n                            colSize,\n                            &lengthIndicator);\n            if (r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO) {\n                if (lengthIndicator == SQL_NULL_DATA || lengthIndicator == SQL_NO_TOTAL) {\n                  return {};\n                }\n                // if SQL_SUCCESS_WITH_INFO is returned, indicating that\n                // more data can be fetched, the length indicator does NOT\n                // contain the number of bytes returned - it contains the\n                // total number of bytes that CAN be fetched\n                qsizetype rSize = (r == SQL_SUCCESS_WITH_INFO) ? colSize : lengthIndicator;\n                // Remove any trailing \\0 as some drivers misguidedly append one\n                int realsize = qMin(rSize, buf.size());\n                if (realsize > 0 && buf[realsize - 1] == 0)\n                    realsize--;\n                fieldVal += QString::fromUtf8(reinterpret_cast<const char *>(buf.constData()), realsize);\n                if (lengthIndicator < SQLLEN(colSize)) {\n                    // workaround for Drivermanagers that don't return SQL_NO_DATA\n                    break;\n                }\n            } else if (r == SQL_NO_DATA) {\n                break;\n            } else {\n                qWarning() << \"qGetStringData: Error while fetching data (\" << qWarnODBCHandle(SQL_HANDLE_STMT, hStmt) << ')';\n                return {};\n            }\n        }\n    }\n    return fieldVal;\n}\n\nstatic QVariant qGetBinaryData(SQLHANDLE hStmt, int column)\n{\n    QByteArray fieldVal;\n    SQLSMALLINT colNameLen;\n    SQLSMALLINT colType;\n    SQLULEN colSize;\n    SQLSMALLINT colScale;\n    SQLSMALLINT nullable;\n    SQLLEN lengthIndicator = 0;\n    SQLRETURN r = SQL_ERROR;\n\n    QVarLengthArray<SQLTCHAR> colName(COLNAMESIZE);\n\n    r = SQLDescribeCol(hStmt,\n                       column + 1,\n                       colName.data(),\n                       COLNAMESIZE,\n                       &colNameLen,\n                       &colType,\n                       &colSize,\n                       &colScale,\n                       &nullable);\n    if (r != SQL_SUCCESS)\n        qWarning() << \"qGetBinaryData: Unable to describe column\" << column;\n    // SQLDescribeCol may return 0 if size cannot be determined\n    if (!colSize)\n        colSize = 255;\n    else if (colSize > 65536) // read the field in 64 KB chunks\n        colSize = 65536;\n    fieldVal.resize(colSize);\n    ulong read = 0;\n    while (true) {\n        r = SQLGetData(hStmt,\n                        column+1,\n                        SQL_C_BINARY,\n                        const_cast<char *>(fieldVal.constData() + read),\n                        colSize,\n                        &lengthIndicator);\n        if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO)\n            break;\n        if (lengthIndicator == SQL_NULL_DATA)\n            return QVariant(QMetaType(QMetaType::QByteArray));\n        if (lengthIndicator > SQLLEN(colSize) || lengthIndicator == SQL_NO_TOTAL) {\n            read += colSize;\n            colSize = 65536;\n        } else {\n            read += lengthIndicator;\n        }\n        if (r == SQL_SUCCESS) { // the whole field was read in one chunk\n            fieldVal.resize(read);\n            break;\n        }\n        fieldVal.resize(fieldVal.size() + colSize);\n    }\n    return fieldVal;\n}\n\nstatic QVariant qGetIntData(SQLHANDLE hStmt, int column, bool isSigned = true)\n{\n    SQLINTEGER intbuf = 0;\n    SQLLEN lengthIndicator = 0;\n    SQLRETURN r = SQLGetData(hStmt,\n                              column+1,\n                              isSigned ? SQL_C_SLONG : SQL_C_ULONG,\n                              (SQLPOINTER)&intbuf,\n                              sizeof(intbuf),\n                              &lengthIndicator);\n    if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO)\n        return QVariant();\n    if (lengthIndicator == SQL_NULL_DATA)\n        return QVariant(QMetaType::fromType<int>());\n    if (isSigned)\n        return int(intbuf);\n    else\n        return uint(intbuf);\n}\n\nstatic QVariant qGetDoubleData(SQLHANDLE hStmt, int column)\n{\n    SQLDOUBLE dblbuf;\n    SQLLEN lengthIndicator = 0;\n    SQLRETURN r = SQLGetData(hStmt,\n                              column+1,\n                              SQL_C_DOUBLE,\n                              (SQLPOINTER) &dblbuf,\n                              0,\n                              &lengthIndicator);\n    if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO) {\n        return QVariant();\n    }\n    if (lengthIndicator == SQL_NULL_DATA)\n        return QVariant(QMetaType::fromType<double>());\n\n    return (double) dblbuf;\n}\n\n\nstatic QVariant qGetBigIntData(SQLHANDLE hStmt, int column, bool isSigned = true)\n{\n    SQLBIGINT lngbuf = 0;\n    SQLLEN lengthIndicator = 0;\n    SQLRETURN r = SQLGetData(hStmt,\n                              column+1,\n                              isSigned ? SQL_C_SBIGINT : SQL_C_UBIGINT,\n                              (SQLPOINTER) &lngbuf,\n                              sizeof(lngbuf),\n                              &lengthIndicator);\n    if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO)\n        return QVariant();\n    if (lengthIndicator == SQL_NULL_DATA)\n        return QVariant(QMetaType::fromType<qlonglong>());\n\n    if (isSigned)\n        return qint64(lngbuf);\n    else\n        return quint64(lngbuf);\n}\n\nstatic bool isAutoValue(const SQLHANDLE hStmt, int column)\n{\n    SQLLEN nNumericAttribute = 0; // Check for auto-increment\n    const SQLRETURN r = ::SQLColAttribute(hStmt, column + 1, SQL_DESC_AUTO_UNIQUE_VALUE,\n                                          0, 0, 0, &nNumericAttribute);\n    if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO) {\n        qSqlWarning(QStringLiteral(\"qMakeField: Unable to get autovalue attribute for column \")\n                    + QString::number(column), hStmt);\n        return false;\n    }\n    return nNumericAttribute != SQL_FALSE;\n}\n\nstatic QSqlField qMakeFieldInfo(const SQLHANDLE hStmt, int i, QString *errorMessage);\n\n// creates a QSqlField from a valid hStmt generated\n// by SQLColumns. The hStmt has to point to a valid position.\nstatic QSqlField qMakeFieldInfo(const SQLHANDLE hStmt, const QODBCDriverPrivate* p)\n{\n    QString fname = qGetStringData(hStmt, 3, -1, p->unicode).toString();\n    int type = qGetIntData(hStmt, 4).toInt(); // column type\n    QSqlField f(fname, qDecodeODBCType(type, p));\n    QVariant var = qGetIntData(hStmt, 6);\n    f.setLength(var.isNull() ? -1 : var.toInt()); // column size\n    var = qGetIntData(hStmt, 8).toInt();\n    f.setPrecision(var.isNull() ? -1 : var.toInt()); // precision\n    f.setSqlType(type);\n    int required = qGetIntData(hStmt, 10).toInt(); // nullable-flag\n    // required can be SQL_NO_NULLS, SQL_NULLABLE or SQL_NULLABLE_UNKNOWN\n    if (required == SQL_NO_NULLS)\n        f.setRequired(true);\n    else if (required == SQL_NULLABLE)\n        f.setRequired(false);\n    // else we don't know\n    return f;\n}\n\nstatic QSqlField qMakeFieldInfo(const QODBCResultPrivate* p, int i )\n{\n    QString errorMessage;\n    const QSqlField result = qMakeFieldInfo(p->hStmt, i, &errorMessage);\n    if (!errorMessage.isEmpty())\n        qSqlWarning(errorMessage, p);\n    return result;\n}\n\nstatic QSqlField qMakeFieldInfo(const SQLHANDLE hStmt, int i, QString *errorMessage)\n{\n    SQLSMALLINT colNameLen;\n    SQLSMALLINT colType;\n    SQLULEN colSize;\n    SQLSMALLINT colScale;\n    SQLSMALLINT nullable;\n    SQLRETURN r = SQL_ERROR;\n    QVarLengthArray<SQLTCHAR> colName(COLNAMESIZE);\n    errorMessage->clear();\n    r = SQLDescribeCol(hStmt,\n                        i+1,\n                        colName.data(),\n                        (SQLSMALLINT)COLNAMESIZE,\n                        &colNameLen,\n                        &colType,\n                        &colSize,\n                        &colScale,\n                        &nullable);\n\n    if (r != SQL_SUCCESS) {\n        *errorMessage = QStringLiteral(\"qMakeField: Unable to describe column \") + QString::number(i);\n        return QSqlField();\n    }\n\n    SQLLEN unsignedFlag = SQL_FALSE;\n    r = SQLColAttribute (hStmt,\n                         i + 1,\n                         SQL_DESC_UNSIGNED,\n                         0,\n                         0,\n                         0,\n                         &unsignedFlag);\n    if (r != SQL_SUCCESS) {\n        qSqlWarning(QStringLiteral(\"qMakeField: Unable to get column attributes for column \")\n                    + QString::number(i), hStmt);\n    }\n\n    const QString qColName(fromSQLTCHAR(colName, colNameLen));\n    // nullable can be SQL_NO_NULLS, SQL_NULLABLE or SQL_NULLABLE_UNKNOWN\n    QMetaType type = qDecodeODBCType(colType, unsignedFlag == SQL_FALSE);\n    QSqlField f(qColName, type);\n    f.setSqlType(colType);\n    f.setLength(colSize == 0 ? -1 : int(colSize));\n    f.setPrecision(colScale == 0 ? -1 : int(colScale));\n    if (nullable == SQL_NO_NULLS)\n        f.setRequired(true);\n    else if (nullable == SQL_NULLABLE)\n        f.setRequired(false);\n    // else we don't know\n    f.setAutoValue(isAutoValue(hStmt, i));\n    QVarLengthArray<SQLTCHAR> tableName(TABLENAMESIZE);\n    SQLSMALLINT tableNameLen;\n    r = SQLColAttribute(hStmt, i + 1, SQL_DESC_BASE_TABLE_NAME, tableName.data(),\n                        TABLENAMESIZE, &tableNameLen, 0);\n    if (r == SQL_SUCCESS)\n        f.setTableName(fromSQLTCHAR(tableName, tableNameLen));\n    return f;\n}\n\nstatic size_t qGetODBCVersion(const QString &connOpts)\n{\n    if (connOpts.contains(\"SQL_ATTR_ODBC_VERSION=SQL_OV_ODBC3\"_L1, Qt::CaseInsensitive))\n        return SQL_OV_ODBC3;\n    return SQL_OV_ODBC2;\n}\n\nQChar QODBCDriverPrivate::quoteChar()\n{\n    if (!isQuoteInitialized) {\n        SQLTCHAR driverResponse[4];\n        SQLSMALLINT length;\n        int r = SQLGetInfo(hDbc,\n                SQL_IDENTIFIER_QUOTE_CHAR,\n                &driverResponse,\n                sizeof(driverResponse),\n                &length);\n        if (r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO)\n            quote = QChar(driverResponse[0]);\n        else\n            quote = u'\"';\n        isQuoteInitialized = true;\n    }\n    return quote;\n}\n\n\nbool QODBCDriverPrivate::setConnectionOptions(const QString& connOpts)\n{\n    // Set any connection attributes\n    const QStringList opts(connOpts.split(u';', Qt::SkipEmptyParts));\n    SQLRETURN r = SQL_SUCCESS;\n    for (int i = 0; i < opts.count(); ++i) {\n        const QString tmp(opts.at(i));\n        int idx;\n        if ((idx = tmp.indexOf(u'=')) == -1) {\n            qWarning() << \"QODBCDriver::open: Illegal connect option value '\" << tmp << '\\'';\n            continue;\n        }\n        const QString opt(tmp.left(idx));\n        const QString val(tmp.mid(idx + 1).simplified());\n        SQLUINTEGER v = 0;\n\n        r = SQL_SUCCESS;\n        if (opt.toUpper() == \"SQL_ATTR_ACCESS_MODE\"_L1) {\n            if (val.toUpper() == \"SQL_MODE_READ_ONLY\"_L1) {\n                v = SQL_MODE_READ_ONLY;\n            } else if (val.toUpper() == \"SQL_MODE_READ_WRITE\"_L1) {\n                v = SQL_MODE_READ_WRITE;\n            } else {\n                qWarning() << \"QODBCDriver::open: Unknown option value '\" << val << '\\'';\n                continue;\n            }\n            r = SQLSetConnectAttr(hDbc, SQL_ATTR_ACCESS_MODE, (SQLPOINTER) size_t(v), 0);\n        } else if (opt.toUpper() == \"SQL_ATTR_CONNECTION_TIMEOUT\"_L1) {\n            v = val.toUInt();\n            r = SQLSetConnectAttr(hDbc, SQL_ATTR_CONNECTION_TIMEOUT, (SQLPOINTER) size_t(v), 0);\n        } else if (opt.toUpper() == \"SQL_ATTR_LOGIN_TIMEOUT\"_L1) {\n            v = val.toUInt();\n            r = SQLSetConnectAttr(hDbc, SQL_ATTR_LOGIN_TIMEOUT, (SQLPOINTER) size_t(v), 0);\n        } else if (opt.toUpper() == \"SQL_ATTR_CURRENT_CATALOG\"_L1) {\n            val.utf16(); // 0 terminate\n            r = SQLSetConnectAttr(hDbc, SQL_ATTR_CURRENT_CATALOG,\n                                    toSQLTCHAR(val).data(),\n                                    SQLINTEGER(val.length() * sizeof(SQLTCHAR)));\n        } else if (opt.toUpper() == \"SQL_ATTR_METADATA_ID\"_L1) {\n            if (val.toUpper() == \"SQL_TRUE\"_L1) {\n                v = SQL_TRUE;\n            } else if (val.toUpper() == \"SQL_FALSE\"_L1) {\n                v = SQL_FALSE;\n            } else {\n                qWarning() << \"QODBCDriver::open: Unknown option value '\" << val << '\\'';\n                continue;\n            }\n            r = SQLSetConnectAttr(hDbc, SQL_ATTR_METADATA_ID, (SQLPOINTER) size_t(v), 0);\n        } else if (opt.toUpper() == \"SQL_ATTR_PACKET_SIZE\"_L1) {\n            v = val.toUInt();\n            r = SQLSetConnectAttr(hDbc, SQL_ATTR_PACKET_SIZE, (SQLPOINTER) size_t(v), 0);\n        } else if (opt.toUpper() == \"SQL_ATTR_TRACEFILE\"_L1) {\n            val.utf16(); // 0 terminate\n            r = SQLSetConnectAttr(hDbc, SQL_ATTR_TRACEFILE,\n                                    toSQLTCHAR(val).data(),\n                                    SQLINTEGER(val.length() * sizeof(SQLTCHAR)));\n        } else if (opt.toUpper() == \"SQL_ATTR_TRACE\"_L1) {\n            if (val.toUpper() == \"SQL_OPT_TRACE_OFF\"_L1) {\n                v = SQL_OPT_TRACE_OFF;\n            } else if (val.toUpper() == \"SQL_OPT_TRACE_ON\"_L1) {\n                v = SQL_OPT_TRACE_ON;\n            } else {\n                qWarning() << \"QODBCDriver::open: Unknown option value '\" << val << '\\'';\n                continue;\n            }\n            r = SQLSetConnectAttr(hDbc, SQL_ATTR_TRACE, (SQLPOINTER) size_t(v), 0);\n        } else if (opt.toUpper() == \"SQL_ATTR_CONNECTION_POOLING\"_L1) {\n            if (val == \"SQL_CP_OFF\"_L1)\n                v = SQL_CP_OFF;\n            else if (val.toUpper() == \"SQL_CP_ONE_PER_DRIVER\"_L1)\n                v = SQL_CP_ONE_PER_DRIVER;\n            else if (val.toUpper() == \"SQL_CP_ONE_PER_HENV\"_L1)\n                v = SQL_CP_ONE_PER_HENV;\n            else if (val.toUpper() == \"SQL_CP_DEFAULT\"_L1)\n                v = SQL_CP_DEFAULT;\n            else {\n                qWarning() << \"QODBCDriver::open: Unknown option value '\" << val << '\\'';\n                continue;\n            }\n            r = SQLSetConnectAttr(hDbc, SQL_ATTR_CONNECTION_POOLING, (SQLPOINTER) size_t(v), 0);\n        } else if (opt.toUpper() == \"SQL_ATTR_CP_MATCH\"_L1) {\n            if (val.toUpper() == \"SQL_CP_STRICT_MATCH\"_L1)\n                v = SQL_CP_STRICT_MATCH;\n            else if (val.toUpper() == \"SQL_CP_RELAXED_MATCH\"_L1)\n                v = SQL_CP_RELAXED_MATCH;\n            else if (val.toUpper() == \"SQL_CP_MATCH_DEFAULT\"_L1)\n                v = SQL_CP_MATCH_DEFAULT;\n            else {\n                qWarning() << \"QODBCDriver::open: Unknown option value '\" << val << '\\'';\n                continue;\n            }\n            r = SQLSetConnectAttr(hDbc, SQL_ATTR_CP_MATCH, (SQLPOINTER) size_t(v), 0);\n        } else if (opt.toUpper() == \"SQL_ATTR_ODBC_VERSION\"_L1) {\n            // Already handled in QODBCDriver::open()\n            continue;\n        } else {\n                qWarning() << \"QODBCDriver::open: Unknown connection attribute '\" << opt << '\\'';\n        }\n        if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO)\n            qSqlWarning(QString::fromLatin1(\"QODBCDriver::open: Unable to set connection attribute'%1'\").arg(\n                        opt), this);\n    }\n    return true;\n}\n\nvoid QODBCDriverPrivate::splitTableQualifier(const QString & qualifier, QString &catalog,\n                                       QString &schema, QString &table)\n{\n    if (!useSchema) {\n        table = qualifier;\n        return;\n    }\n    QStringList l = qualifier.split(u'.');\n    if (l.count() > 3)\n        return; // can't possibly be a valid table qualifier\n    int i = 0, n = l.count();\n    if (n == 1) {\n        table = qualifier;\n    } else {\n        for (QStringList::Iterator it = l.begin(); it != l.end(); ++it) {\n            if (n == 3) {\n                if (i == 0) {\n                    catalog = *it;\n                } else if (i == 1) {\n                    schema = *it;\n                } else if (i == 2) {\n                    table = *it;\n                }\n            } else if (n == 2) {\n                if (i == 0) {\n                    schema = *it;\n                } else if (i == 1) {\n                    table = *it;\n                }\n            }\n            i++;\n        }\n    }\n}\n\nQODBCDriverPrivate::DefaultCase QODBCDriverPrivate::defaultCase() const\n{\n    DefaultCase ret;\n    SQLUSMALLINT casing;\n    int r = SQLGetInfo(hDbc,\n            SQL_IDENTIFIER_CASE,\n            &casing,\n            sizeof(casing),\n            NULL);\n    if ( r != SQL_SUCCESS)\n        ret = Mixed;//arbitrary case if driver cannot be queried\n    else {\n        switch (casing) {\n            case (SQL_IC_UPPER):\n                ret = Upper;\n                break;\n            case (SQL_IC_LOWER):\n                ret = Lower;\n                break;\n            case (SQL_IC_SENSITIVE):\n                ret = Sensitive;\n                break;\n            case (SQL_IC_MIXED):\n            default:\n                ret = Mixed;\n                break;\n        }\n    }\n    return ret;\n}\n\n/*\n   Adjust the casing of an identifier to match what the\n   database engine would have done to it.\n*/\nQString QODBCDriverPrivate::adjustCase(const QString &identifier) const\n{\n    QString ret = identifier;\n    switch(defaultCase()) {\n        case (Lower):\n            ret = identifier.toLower();\n            break;\n        case (Upper):\n            ret = identifier.toUpper();\n            break;\n        case(Mixed):\n        case(Sensitive):\n        default:\n            ret = identifier;\n    }\n    return ret;\n}\n\n////////////////////////////////////////////////////////////////////////////\n\nQODBCResult::QODBCResult(const QODBCDriver *db)\n    : QSqlResult(*new QODBCResultPrivate(this, db))\n{\n}\n\nQODBCResult::~QODBCResult()\n{\n    Q_D(QODBCResult);\n    if (d->hStmt && d->isStmtHandleValid() && driver() && driver()->isOpen()) {\n        SQLRETURN r = SQLFreeHandle(SQL_HANDLE_STMT, d->hStmt);\n        if (r != SQL_SUCCESS)\n            qSqlWarning(\"QODBCDriver: Unable to free statement handle \"_L1\n                         + QString::number(r), d);\n    }\n}\n\nbool QODBCResult::reset (const QString& query)\n{\n    Q_D(QODBCResult);\n    setActive(false);\n    setAt(QSql::BeforeFirstRow);\n    d->rInf.clear();\n    d->fieldCache.clear();\n    d->fieldCacheIdx = 0;\n\n    // Always reallocate the statement handle - the statement attributes\n    // are not reset if SQLFreeStmt() is called which causes some problems.\n    SQLRETURN r;\n    if (d->hStmt && d->isStmtHandleValid()) {\n        r = SQLFreeHandle(SQL_HANDLE_STMT, d->hStmt);\n        if (r != SQL_SUCCESS) {\n            qSqlWarning(\"QODBCResult::reset: Unable to free statement handle\"_L1, d);\n            return false;\n        }\n    }\n    r  = SQLAllocHandle(SQL_HANDLE_STMT,\n                         d->dpDbc(),\n                         &d->hStmt);\n    if (r != SQL_SUCCESS) {\n        qSqlWarning(\"QODBCResult::reset: Unable to allocate statement handle\"_L1, d);\n        return false;\n    }\n\n    d->updateStmtHandleState();\n\n    if (isForwardOnly()) {\n        r = SQLSetStmtAttr(d->hStmt,\n                            SQL_ATTR_CURSOR_TYPE,\n                            (SQLPOINTER)SQL_CURSOR_FORWARD_ONLY,\n                            SQL_IS_UINTEGER);\n    } else {\n        r = SQLSetStmtAttr(d->hStmt,\n                            SQL_ATTR_CURSOR_TYPE,\n                            (SQLPOINTER)SQL_CURSOR_STATIC,\n                            SQL_IS_UINTEGER);\n    }\n    if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO) {\n        setLastError(qMakeError(QCoreApplication::translate(\"QODBCResult\",\n            \"QODBCResult::reset: Unable to set 'SQL_CURSOR_STATIC' as statement attribute. \"\n            \"Please check your ODBC driver configuration\"), QSqlError::StatementError, d));\n        return false;\n    }\n\n    r = SQLExecDirect(d->hStmt,\n                       toSQLTCHAR(query).data(),\n                       (SQLINTEGER) query.length());\n    if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO && r!= SQL_NO_DATA) {\n        setLastError(qMakeError(QCoreApplication::translate(\"QODBCResult\",\n                     \"Unable to execute statement\"), QSqlError::StatementError, d));\n        return false;\n    }\n\n    SQLULEN isScrollable = 0;\n    r = SQLGetStmtAttr(d->hStmt, SQL_ATTR_CURSOR_SCROLLABLE, &isScrollable, SQL_IS_INTEGER, 0);\n    if (r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO)\n        setForwardOnly(isScrollable == SQL_NONSCROLLABLE);\n\n    SQLSMALLINT count = 0;\n    SQLNumResultCols(d->hStmt, &count);\n    if (count) {\n        setSelect(true);\n        for (int i = 0; i < count; ++i) {\n            d->rInf.append(qMakeFieldInfo(d, i));\n        }\n        d->fieldCache.resize(count);\n    } else {\n        setSelect(false);\n    }\n    setActive(true);\n\n    return true;\n}\n\nbool QODBCResult::fetch(int i)\n{\n    Q_D(QODBCResult);\n    if (!driver()->isOpen())\n        return false;\n\n    if (isForwardOnly() && i < at())\n        return false;\n    if (i == at())\n        return true;\n    d->clearValues();\n    int actualIdx = i + 1;\n    if (actualIdx <= 0) {\n        setAt(QSql::BeforeFirstRow);\n        return false;\n    }\n    SQLRETURN r;\n    if (isForwardOnly()) {\n        bool ok = true;\n        while (ok && i > at())\n            ok = fetchNext();\n        return ok;\n    } else {\n        r = SQLFetchScroll(d->hStmt,\n                            SQL_FETCH_ABSOLUTE,\n                            actualIdx);\n    }\n    if (r != SQL_SUCCESS) {\n        if (r != SQL_NO_DATA)\n            setLastError(qMakeError(QCoreApplication::translate(\"QODBCResult\",\n                \"Unable to fetch\"), QSqlError::ConnectionError, d));\n        return false;\n    }\n    setAt(i);\n    return true;\n}\n\nbool QODBCResult::fetchNext()\n{\n    Q_D(QODBCResult);\n    SQLRETURN r;\n    d->clearValues();\n\n    if (d->hasSQLFetchScroll)\n        r = SQLFetchScroll(d->hStmt,\n                           SQL_FETCH_NEXT,\n                           0);\n    else\n        r = SQLFetch(d->hStmt);\n\n    if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO) {\n        if (r != SQL_NO_DATA)\n            setLastError(qMakeError(QCoreApplication::translate(\"QODBCResult\",\n                \"Unable to fetch next\"), QSqlError::ConnectionError, d));\n        return false;\n    }\n    setAt(at() + 1);\n    return true;\n}\n\nbool QODBCResult::fetchFirst()\n{\n    Q_D(QODBCResult);\n    if (isForwardOnly() && at() != QSql::BeforeFirstRow)\n        return false;\n    SQLRETURN r;\n    d->clearValues();\n    if (isForwardOnly()) {\n        return fetchNext();\n    }\n    r = SQLFetchScroll(d->hStmt,\n                       SQL_FETCH_FIRST,\n                       0);\n    if (r != SQL_SUCCESS) {\n        if (r != SQL_NO_DATA)\n            setLastError(qMakeError(QCoreApplication::translate(\"QODBCResult\",\n                \"Unable to fetch first\"), QSqlError::ConnectionError, d));\n        return false;\n    }\n    setAt(0);\n    return true;\n}\n\nbool QODBCResult::fetchPrevious()\n{\n    Q_D(QODBCResult);\n    if (isForwardOnly())\n        return false;\n    SQLRETURN r;\n    d->clearValues();\n    r = SQLFetchScroll(d->hStmt,\n                       SQL_FETCH_PRIOR,\n                       0);\n    if (r != SQL_SUCCESS) {\n        if (r != SQL_NO_DATA)\n            setLastError(qMakeError(QCoreApplication::translate(\"QODBCResult\",\n                \"Unable to fetch previous\"), QSqlError::ConnectionError, d));\n        return false;\n    }\n    setAt(at() - 1);\n    return true;\n}\n\nbool QODBCResult::fetchLast()\n{\n    Q_D(QODBCResult);\n    SQLRETURN r;\n    d->clearValues();\n\n    if (isForwardOnly()) {\n        // cannot seek to last row in forwardOnly mode, so we have to use brute force\n        int i = at();\n        if (i == QSql::AfterLastRow)\n            return false;\n        if (i == QSql::BeforeFirstRow)\n            i = 0;\n        while (fetchNext())\n            ++i;\n        setAt(i);\n        return true;\n    }\n\n    r = SQLFetchScroll(d->hStmt,\n                       SQL_FETCH_LAST,\n                       0);\n    if (r != SQL_SUCCESS) {\n        if (r != SQL_NO_DATA)\n            setLastError(qMakeError(QCoreApplication::translate(\"QODBCResult\",\n                \"Unable to fetch last\"), QSqlError::ConnectionError, d));\n        return false;\n    }\n    SQLULEN currRow = 0;\n    r = SQLGetStmtAttr(d->hStmt,\n                        SQL_ROW_NUMBER,\n                        &currRow,\n                        SQL_IS_INTEGER,\n                        0);\n    if (r != SQL_SUCCESS)\n        return false;\n    setAt(currRow-1);\n    return true;\n}\n\nQVariant QODBCResult::data(int field)\n{\n    Q_D(QODBCResult);\n    if (field >= d->rInf.count() || field < 0) {\n        qWarning() << \"QODBCResult::data: column\" << field << \"out of range\";\n        return QVariant();\n    }\n    if (field < d->fieldCacheIdx)\n        return d->fieldCache.at(field);\n\n    SQLRETURN r(0);\n    SQLLEN lengthIndicator = 0;\n\n    for (int i = d->fieldCacheIdx; i <= field; ++i) {\n        // some servers do not support fetching column n after we already\n        // fetched column n+1, so cache all previous columns here\n        const QSqlField info = d->rInf.field(i);\n        switch (info.metaType().id()) {\n        case QMetaType::LongLong:\n            d->fieldCache[i] = qGetBigIntData(d->hStmt, i);\n        break;\n        case QMetaType::ULongLong:\n            d->fieldCache[i] = qGetBigIntData(d->hStmt, i, false);\n            break;\n        case QMetaType::Int:\n        case QMetaType::Short:\n            d->fieldCache[i] = qGetIntData(d->hStmt, i);\n            break;\n        case QMetaType::UInt:\n        case QMetaType::UShort:\n            d->fieldCache[i] = qGetIntData(d->hStmt, i, false);\n            break;\n        case QMetaType::QDate:\n            DATE_STRUCT dbuf;\n            r = SQLGetData(d->hStmt,\n                            i + 1,\n                            SQL_C_DATE,\n                            (SQLPOINTER)&dbuf,\n                            0,\n                            &lengthIndicator);\n            if ((r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO) && (lengthIndicator != SQL_NULL_DATA))\n                d->fieldCache[i] = QVariant(QDate(dbuf.year, dbuf.month, dbuf.day));\n            else\n                d->fieldCache[i] = QVariant(QMetaType::fromType<QDate>());\n        break;\n        case QMetaType::QTime:\n            TIME_STRUCT tbuf;\n            r = SQLGetData(d->hStmt,\n                            i + 1,\n                            SQL_C_TIME,\n                            (SQLPOINTER)&tbuf,\n                            0,\n                            &lengthIndicator);\n            if ((r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO) && (lengthIndicator != SQL_NULL_DATA))\n                d->fieldCache[i] = QVariant(QTime(tbuf.hour, tbuf.minute, tbuf.second));\n            else\n                d->fieldCache[i] = QVariant(QMetaType::fromType<QTime>());\n        break;\n        case QMetaType::QDateTime:\n            TIMESTAMP_STRUCT dtbuf;\n            r = SQLGetData(d->hStmt,\n                            i + 1,\n                            SQL_C_TIMESTAMP,\n                            (SQLPOINTER)&dtbuf,\n                            0,\n                            &lengthIndicator);\n            if ((r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO) && (lengthIndicator != SQL_NULL_DATA))\n                d->fieldCache[i] = QVariant(QDateTime(QDate(dtbuf.year, dtbuf.month, dtbuf.day),\n                       QTime(dtbuf.hour, dtbuf.minute, dtbuf.second, dtbuf.fraction / 1000000)));\n            else\n                d->fieldCache[i] = QVariant(QMetaType::fromType<QDateTime>());\n            break;\n        case QMetaType::QByteArray:\n            d->fieldCache[i] = qGetBinaryData(d->hStmt, i);\n            break;\n        case QMetaType::QString:\n            d->fieldCache[i] = qGetStringData(d->hStmt, i, info.length(), d->unicode);\n            break;\n        case QMetaType::Double:\n            switch(numericalPrecisionPolicy()) {\n                case QSql::LowPrecisionInt32:\n                    d->fieldCache[i] = qGetIntData(d->hStmt, i);\n                    break;\n                case QSql::LowPrecisionInt64:\n                    d->fieldCache[i] = qGetBigIntData(d->hStmt, i);\n                    break;\n                case QSql::LowPrecisionDouble:\n                    d->fieldCache[i] = qGetDoubleData(d->hStmt, i);\n                    break;\n                case QSql::HighPrecision:\n                    const int extra = info.precision() > 0 ? 1 : 0;\n                    d->fieldCache[i] = qGetStringData(d->hStmt, i, info.length() + extra, false);\n                    break;\n            }\n            break;\n        default:\n            d->fieldCache[i] = qGetStringData(d->hStmt, i, info.length(), false);\n            break;\n        }\n        d->fieldCacheIdx = field + 1;\n    }\n    return d->fieldCache[field];\n}\n\nbool QODBCResult::isNull(int field)\n{\n    Q_D(const QODBCResult);\n    if (field < 0 || field >= d->fieldCache.size())\n        return true;\n    if (field >= d->fieldCacheIdx) {\n        // since there is no good way to find out whether the value is NULL\n        // without fetching the field we'll fetch it here.\n        // (data() also sets the NULL flag)\n        data(field);\n    }\n    return d->fieldCache.at(field).isNull();\n}\n\nint QODBCResult::size()\n{\n    return -1;\n}\n\nint QODBCResult::numRowsAffected()\n{\n    Q_D(QODBCResult);\n    SQLLEN affectedRowCount = 0;\n    SQLRETURN r = SQLRowCount(d->hStmt, &affectedRowCount);\n    if (r == SQL_SUCCESS)\n        return affectedRowCount;\n    else\n        qSqlWarning(\"QODBCResult::numRowsAffected: Unable to count affected rows\"_L1, d);\n    return -1;\n}\n\nbool QODBCResult::prepare(const QString& query)\n{\n    Q_D(QODBCResult);\n    setActive(false);\n    setAt(QSql::BeforeFirstRow);\n    SQLRETURN r;\n\n    d->rInf.clear();\n    if (d->hStmt && d->isStmtHandleValid()) {\n        r = SQLFreeHandle(SQL_HANDLE_STMT, d->hStmt);\n        if (r != SQL_SUCCESS) {\n            qSqlWarning(\"QODBCResult::prepare: Unable to close statement\"_L1, d);\n            return false;\n        }\n    }\n    r  = SQLAllocHandle(SQL_HANDLE_STMT,\n                         d->dpDbc(),\n                         &d->hStmt);\n    if (r != SQL_SUCCESS) {\n        qSqlWarning(\"QODBCResult::prepare: Unable to allocate statement handle\"_L1, d);\n        return false;\n    }\n\n    d->updateStmtHandleState();\n\n    if (isForwardOnly()) {\n        r = SQLSetStmtAttr(d->hStmt,\n                            SQL_ATTR_CURSOR_TYPE,\n                            (SQLPOINTER)SQL_CURSOR_FORWARD_ONLY,\n                            SQL_IS_UINTEGER);\n    } else {\n        r = SQLSetStmtAttr(d->hStmt,\n                            SQL_ATTR_CURSOR_TYPE,\n                            (SQLPOINTER)SQL_CURSOR_STATIC,\n                            SQL_IS_UINTEGER);\n    }\n    if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO) {\n        setLastError(qMakeError(QCoreApplication::translate(\"QODBCResult\",\n            \"QODBCResult::reset: Unable to set 'SQL_CURSOR_STATIC' as statement attribute. \"\n            \"Please check your ODBC driver configuration\"), QSqlError::StatementError, d));\n        return false;\n    }\n\n    r = SQLPrepare(d->hStmt,\n                    toSQLTCHAR(query).data(),\n                    (SQLINTEGER) query.length());\n\n    if (r != SQL_SUCCESS) {\n        setLastError(qMakeError(QCoreApplication::translate(\"QODBCResult\",\n                     \"Unable to prepare statement\"), QSqlError::StatementError, d));\n        return false;\n    }\n    return true;\n}\n\nbool QODBCResult::exec()\n{\n    Q_D(QODBCResult);\n    setActive(false);\n    setAt(QSql::BeforeFirstRow);\n    d->rInf.clear();\n    d->fieldCache.clear();\n    d->fieldCacheIdx = 0;\n\n    if (!d->hStmt) {\n        qSqlWarning(\"QODBCResult::exec: No statement handle available\"_L1, d);\n        return false;\n    }\n\n    if (isSelect())\n        SQLCloseCursor(d->hStmt);\n\n    QVariantList &values = boundValues();\n    QByteArrayList tmpStorage(values.count(), QByteArray()); // holds temporary buffers\n    QVarLengthArray<SQLLEN, 32> indicators(values.count());\n    memset(indicators.data(), 0, indicators.size() * sizeof(SQLLEN));\n\n    // bind parameters - only positional binding allowed\n    int i;\n    SQLRETURN r;\n    for (i = 0; i < values.count(); ++i) {\n        if (bindValueType(i) & QSql::Out)\n            values[i].detach();\n        const QVariant &val = values.at(i);\n        SQLLEN *ind = &indicators[i];\n        if (QSqlResultPrivate::isVariantNull(val))\n            *ind = SQL_NULL_DATA;\n        switch (val.typeId()) {\n            case QMetaType::QDate: {\n                QByteArray &ba = tmpStorage[i];\n                ba.resize(sizeof(DATE_STRUCT));\n                DATE_STRUCT *dt = (DATE_STRUCT *)const_cast<char *>(ba.constData());\n                QDate qdt = val.toDate();\n                dt->year = qdt.year();\n                dt->month = qdt.month();\n                dt->day = qdt.day();\n                r = SQLBindParameter(d->hStmt,\n                                      i + 1,\n                                      qParamType[bindValueType(i) & QSql::InOut],\n                                      SQL_C_DATE,\n                                      SQL_DATE,\n                                      0,\n                                      0,\n                                      (void *) dt,\n                                      0,\n                                      *ind == SQL_NULL_DATA ? ind : NULL);\n                break; }\n            case QMetaType::QTime: {\n                QByteArray &ba = tmpStorage[i];\n                ba.resize(sizeof(TIME_STRUCT));\n                TIME_STRUCT *dt = (TIME_STRUCT *)const_cast<char *>(ba.constData());\n                QTime qdt = val.toTime();\n                dt->hour = qdt.hour();\n                dt->minute = qdt.minute();\n                dt->second = qdt.second();\n                r = SQLBindParameter(d->hStmt,\n                                      i + 1,\n                                      qParamType[bindValueType(i) & QSql::InOut],\n                                      SQL_C_TIME,\n                                      SQL_TIME,\n                                      0,\n                                      0,\n                                      (void *) dt,\n                                      0,\n                                      *ind == SQL_NULL_DATA ? ind : NULL);\n                break; }\n            case QMetaType::QDateTime: {\n                QByteArray &ba = tmpStorage[i];\n                ba.resize(sizeof(TIMESTAMP_STRUCT));\n                TIMESTAMP_STRUCT *dt = reinterpret_cast<TIMESTAMP_STRUCT *>(const_cast<char *>(ba.constData()));\n                const QDateTime qdt = val.toDateTime();\n                const QDate qdate = qdt.date();\n                const QTime qtime = qdt.time();\n                dt->year = qdate.year();\n                dt->month = qdate.month();\n                dt->day = qdate.day();\n                dt->hour = qtime.hour();\n                dt->minute = qtime.minute();\n                dt->second = qtime.second();\n                // (20 includes a separating period)\n                const int precision = d->drv_d_func()->datetimePrecision - 20;\n                if (precision <= 0) {\n                    dt->fraction = 0;\n                } else {\n                    dt->fraction = qtime.msec() * 1000000;\n\n                    // (How many leading digits do we want to keep?  With SQL Server 2005, this should be 3: 123000000)\n                    int keep = (int)qPow(10.0, 9 - qMin(9, precision));\n                    dt->fraction = (dt->fraction / keep) * keep;\n                }\n\n                r = SQLBindParameter(d->hStmt,\n                                      i + 1,\n                                      qParamType[bindValueType(i) & QSql::InOut],\n                                      SQL_C_TIMESTAMP,\n                                      SQL_TIMESTAMP,\n                                      d->drv_d_func()->datetimePrecision,\n                                      precision,\n                                      (void *) dt,\n                                      0,\n                                      *ind == SQL_NULL_DATA ? ind : NULL);\n                break; }\n            case QMetaType::Int:\n                r = SQLBindParameter(d->hStmt,\n                                      i + 1,\n                                      qParamType[bindValueType(i) & QSql::InOut],\n                                      SQL_C_SLONG,\n                                      SQL_INTEGER,\n                                      0,\n                                      0,\n                                      const_cast<void *>(val.constData()),\n                                      0,\n                                      *ind == SQL_NULL_DATA ? ind : NULL);\n                break;\n            case QMetaType::UInt:\n                r = SQLBindParameter(d->hStmt,\n                                      i + 1,\n                                      qParamType[bindValueType(i) & QSql::InOut],\n                                      SQL_C_ULONG,\n                                      SQL_NUMERIC,\n                                      15,\n                                      0,\n                                      const_cast<void *>(val.constData()),\n                                      0,\n                                      *ind == SQL_NULL_DATA ? ind : NULL);\n                break;\n            case QMetaType::Short:\n                r = SQLBindParameter(d->hStmt,\n                                      i + 1,\n                                      qParamType[bindValueType(i) & QSql::InOut],\n                                      SQL_C_SSHORT,\n                                      SQL_SMALLINT,\n                                      0,\n                                      0,\n                                      const_cast<void *>(val.constData()),\n                                      0,\n                                      *ind == SQL_NULL_DATA ? ind : NULL);\n                break;\n            case QMetaType::UShort:\n                r = SQLBindParameter(d->hStmt,\n                                      i + 1,\n                                      qParamType[bindValueType(i) & QSql::InOut],\n                                      SQL_C_USHORT,\n                                      SQL_NUMERIC,\n                                      15,\n                                      0,\n                                      const_cast<void *>(val.constData()),\n                                      0,\n                                      *ind == SQL_NULL_DATA ? ind : NULL);\n                break;\n            case QMetaType::Double:\n                r = SQLBindParameter(d->hStmt,\n                                      i + 1,\n                                      qParamType[bindValueType(i) & QSql::InOut],\n                                      SQL_C_DOUBLE,\n                                      SQL_DOUBLE,\n                                      0,\n                                      0,\n                                      const_cast<void *>(val.constData()),\n                                      0,\n                                      *ind == SQL_NULL_DATA ? ind : NULL);\n                break;\n            case QMetaType::Float:\n                r = SQLBindParameter(d->hStmt,\n                                      i + 1,\n                                      qParamType[bindValueType(i) & QSql::InOut],\n                                      SQL_C_FLOAT,\n                                      SQL_REAL,\n                                      0,\n                                      0,\n                                      const_cast<void *>(val.constData()),\n                                      0,\n                                      *ind == SQL_NULL_DATA ? ind : NULL);\n                break;\n            case QMetaType::LongLong:\n                r = SQLBindParameter(d->hStmt,\n                                      i + 1,\n                                      qParamType[bindValueType(i) & QSql::InOut],\n                                      SQL_C_SBIGINT,\n                                      SQL_BIGINT,\n                                      0,\n                                      0,\n                                      const_cast<void *>(val.constData()),\n                                      0,\n                                      *ind == SQL_NULL_DATA ? ind : NULL);\n                break;\n            case QMetaType::ULongLong:\n                r = SQLBindParameter(d->hStmt,\n                                      i + 1,\n                                      qParamType[bindValueType(i) & QSql::InOut],\n                                      SQL_C_UBIGINT,\n                                      SQL_BIGINT,\n                                      0,\n                                      0,\n                                      const_cast<void *>(val.constData()),\n                                      0,\n                                      *ind == SQL_NULL_DATA ? ind : NULL);\n                break;\n            case QMetaType::QByteArray:\n                if (*ind != SQL_NULL_DATA) {\n                    *ind = val.toByteArray().size();\n                }\n                r = SQLBindParameter(d->hStmt,\n                                      i + 1,\n                                      qParamType[bindValueType(i) & QSql::InOut],\n                                      SQL_C_BINARY,\n                                      SQL_LONGVARBINARY,\n                                      val.toByteArray().size(),\n                                      0,\n                                      const_cast<char *>(val.toByteArray().constData()),\n                                      val.toByteArray().size(),\n                                      ind);\n                break;\n            case QMetaType::Bool:\n                r = SQLBindParameter(d->hStmt,\n                                      i + 1,\n                                      qParamType[bindValueType(i) & QSql::InOut],\n                                      SQL_C_BIT,\n                                      SQL_BIT,\n                                      0,\n                                      0,\n                                      const_cast<void *>(val.constData()),\n                                      0,\n                                      *ind == SQL_NULL_DATA ? ind : NULL);\n                break;\n            case QMetaType::QString:\n                if (d->unicode) {\n                    QByteArray &ba = tmpStorage[i];\n                    QString str = val.toString();\n                    if (*ind != SQL_NULL_DATA)\n                        *ind = str.length() * sizeof(SQLTCHAR);\n                    const qsizetype strSize = str.length() * sizeof(SQLTCHAR);\n\n                    if (bindValueType(i) & QSql::Out) {\n                        const QVarLengthArray<SQLTCHAR> a(toSQLTCHAR(str));\n                        ba = QByteArray((const char *)a.constData(), int(a.size() * sizeof(SQLTCHAR)));\n                        r = SQLBindParameter(d->hStmt,\n                                            i + 1,\n                                            qParamType[bindValueType(i) & QSql::InOut],\n                                            SQL_C_TCHAR,\n                                            strSize > 254 ? SQL_WLONGVARCHAR : SQL_WVARCHAR,\n                                            0, // god knows... don't change this!\n                                            0,\n                                            ba.data(),\n                                            ba.size(),\n                                            ind);\n                        break;\n                    }\n                    ba = QByteArray(reinterpret_cast<const char *>(toSQLTCHAR(str).constData()),\n                                    int(strSize));\n                    r = SQLBindParameter(d->hStmt,\n                                          i + 1,\n                                          qParamType[bindValueType(i) & QSql::InOut],\n                                          SQL_C_TCHAR,\n                                          strSize > 254 ? SQL_WLONGVARCHAR : SQL_WVARCHAR,\n                                          strSize,\n                                          0,\n                                          const_cast<char *>(ba.constData()),\n                                          ba.size(),\n                                          ind);\n                    break;\n                }\n                else\n                {\n                    QByteArray &str = tmpStorage[i];\n                    str = val.toString().toUtf8();\n                    if (*ind != SQL_NULL_DATA)\n                        *ind = str.length();\n                    int strSize = str.length();\n\n                    r = SQLBindParameter(d->hStmt,\n                                          i + 1,\n                                          qParamType[bindValueType(i) & QSql::InOut],\n                                          SQL_C_CHAR,\n                                          strSize > 254 ? SQL_LONGVARCHAR : SQL_VARCHAR,\n                                          strSize,\n                                          0,\n                                          const_cast<char *>(str.constData()),\n                                          strSize,\n                                          ind);\n                    break;\n                }\n            Q_FALLTHROUGH();\n            default: {\n                QByteArray &ba = tmpStorage[i];\n                if (*ind != SQL_NULL_DATA)\n                    *ind = ba.size();\n                r = SQLBindParameter(d->hStmt,\n                                      i + 1,\n                                      qParamType[bindValueType(i) & QSql::InOut],\n                                      SQL_C_BINARY,\n                                      SQL_VARBINARY,\n                                      ba.length() + 1,\n                                      0,\n                                      const_cast<char *>(ba.constData()),\n                                      ba.length() + 1,\n                                      ind);\n                break; }\n        }\n        if (r != SQL_SUCCESS) {\n            qWarning() << \"QODBCResult::exec: unable to bind variable:\" << qODBCWarn(d);\n            setLastError(qMakeError(QCoreApplication::translate(\"QODBCResult\",\n                         \"Unable to bind variable\"), QSqlError::StatementError, d));\n            return false;\n        }\n    }\n    r = SQLExecute(d->hStmt);\n    if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO && r != SQL_NO_DATA) {\n        qWarning() << \"QODBCResult::exec: Unable to execute statement:\" << qODBCWarn(d);\n        setLastError(qMakeError(QCoreApplication::translate(\"QODBCResult\",\n                     \"Unable to execute statement\"), QSqlError::StatementError, d));\n        return false;\n    }\n\n    SQLULEN isScrollable = 0;\n    r = SQLGetStmtAttr(d->hStmt, SQL_ATTR_CURSOR_SCROLLABLE, &isScrollable, SQL_IS_INTEGER, 0);\n    if (r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO)\n        setForwardOnly(isScrollable == SQL_NONSCROLLABLE);\n\n    SQLSMALLINT count = 0;\n    SQLNumResultCols(d->hStmt, &count);\n    if (count) {\n        setSelect(true);\n        for (int i = 0; i < count; ++i) {\n            d->rInf.append(qMakeFieldInfo(d, i));\n        }\n        d->fieldCache.resize(count);\n    } else {\n        setSelect(false);\n    }\n    setActive(true);\n\n\n    //get out parameters\n    if (!hasOutValues())\n        return true;\n\n    for (i = 0; i < values.count(); ++i) {\n        switch (values.at(i).typeId()) {\n            case QMetaType::QDate: {\n                DATE_STRUCT ds = *((DATE_STRUCT *)const_cast<char *>(tmpStorage.at(i).constData()));\n                values[i] = QVariant(QDate(ds.year, ds.month, ds.day));\n                break; }\n            case QMetaType::QTime: {\n                TIME_STRUCT dt = *((TIME_STRUCT *)const_cast<char *>(tmpStorage.at(i).constData()));\n                values[i] = QVariant(QTime(dt.hour, dt.minute, dt.second));\n                break; }\n            case QMetaType::QDateTime: {\n                TIMESTAMP_STRUCT dt = *((TIMESTAMP_STRUCT*)\n                                        const_cast<char *>(tmpStorage.at(i).constData()));\n                values[i] = QVariant(QDateTime(QDate(dt.year, dt.month, dt.day),\n                               QTime(dt.hour, dt.minute, dt.second, dt.fraction / 1000000)));\n                break; }\n            case QMetaType::Bool:\n            case QMetaType::Short:\n            case QMetaType::UShort:\n            case QMetaType::Int:\n            case QMetaType::UInt:\n            case QMetaType::Float:\n            case QMetaType::Double:\n            case QMetaType::QByteArray:\n            case QMetaType::LongLong:\n            case QMetaType::ULongLong:\n                //nothing to do\n                break;\n            case QMetaType::QString:\n                if (d->unicode) {\n                    if (bindValueType(i) & QSql::Out) {\n                        const QByteArray &bytes = tmpStorage.at(i);\n                        const auto strSize = bytes.size() / sizeof(SQLTCHAR);\n                        QVarLengthArray<SQLTCHAR> string(strSize);\n                        memcpy(string.data(), bytes.data(), strSize * sizeof(SQLTCHAR));\n                        values[i] = fromSQLTCHAR(string);\n                    }\n                    break;\n                }\n                Q_FALLTHROUGH();\n            default: {\n                if (bindValueType(i) & QSql::Out)\n                    values[i] = tmpStorage.at(i);\n                break; }\n        }\n        if (indicators[i] == SQL_NULL_DATA)\n            values[i] = QVariant(values[i].metaType());\n    }\n    return true;\n}\n\nQSqlRecord QODBCResult::record() const\n{\n    Q_D(const QODBCResult);\n    if (!isActive() || !isSelect())\n        return QSqlRecord();\n    return d->rInf;\n}\n\nQVariant QODBCResult::lastInsertId() const\n{\n    Q_D(const QODBCResult);\n    QString sql;\n\n    switch (driver()->dbmsType()) {\n    case QSqlDriver::MSSqlServer:\n    case QSqlDriver::Sybase:\n        sql = \"SELECT @@IDENTITY;\"_L1;\n        break;\n    case QSqlDriver::MySqlServer:\n        sql = \"SELECT LAST_INSERT_ID();\"_L1;\n        break;\n    case QSqlDriver::PostgreSQL:\n        sql = \"SELECT lastval();\"_L1;\n        break;\n    default:\n        break;\n    }\n\n    if (!sql.isEmpty()) {\n        QSqlQuery qry(driver()->createResult());\n        if (qry.exec(sql) && qry.next())\n            return qry.value(0);\n\n        qSqlWarning(\"QODBCResult::lastInsertId: Unable to get lastInsertId\"_L1, d);\n    } else {\n        qSqlWarning(\"QODBCResult::lastInsertId: not implemented for this DBMS\"_L1, d);\n    }\n\n    return QVariant();\n}\n\nQVariant QODBCResult::handle() const\n{\n    Q_D(const QODBCResult);\n    return QVariant(QMetaType::fromType<SQLHANDLE>(), &d->hStmt);\n}\n\nbool QODBCResult::nextResult()\n{\n    Q_D(QODBCResult);\n    setActive(false);\n    setAt(QSql::BeforeFirstRow);\n    d->rInf.clear();\n    d->fieldCache.clear();\n    d->fieldCacheIdx = 0;\n    setSelect(false);\n\n    SQLRETURN r = SQLMoreResults(d->hStmt);\n    if (r != SQL_SUCCESS) {\n        if (r == SQL_SUCCESS_WITH_INFO) {\n            int nativeCode = -1;\n            QString message = qODBCWarn(d, &nativeCode);\n            qWarning() << \"QODBCResult::nextResult():\" << message;\n        } else {\n            if (r != SQL_NO_DATA)\n                setLastError(qMakeError(QCoreApplication::translate(\"QODBCResult\",\n                    \"Unable to fetch last\"), QSqlError::ConnectionError, d));\n            return false;\n        }\n    }\n\n    SQLSMALLINT count = 0;\n    SQLNumResultCols(d->hStmt, &count);\n    if (count) {\n        setSelect(true);\n        for (int i = 0; i < count; ++i) {\n            d->rInf.append(qMakeFieldInfo(d, i));\n        }\n        d->fieldCache.resize(count);\n    } else {\n        setSelect(false);\n    }\n    setActive(true);\n\n    return true;\n}\n\nvoid QODBCResult::virtual_hook(int id, void *data)\n{\n    QSqlResult::virtual_hook(id, data);\n}\n\nvoid QODBCResult::detachFromResultSet()\n{\n    Q_D(QODBCResult);\n    if (d->hStmt)\n        SQLCloseCursor(d->hStmt);\n}\n\n////////////////////////////////////////\n\n\nQODBCDriver::QODBCDriver(QObject *parent)\n    : QSqlDriver(*new QODBCDriverPrivate, parent)\n{\n}\n\nQODBCDriver::QODBCDriver(SQLHANDLE env, SQLHANDLE con, QObject *parent)\n    : QSqlDriver(*new QODBCDriverPrivate, parent)\n{\n    Q_D(QODBCDriver);\n    d->hEnv = env;\n    d->hDbc = con;\n    if (env && con) {\n        setOpen(true);\n        setOpenError(false);\n    }\n}\n\nQODBCDriver::~QODBCDriver()\n{\n    cleanup();\n}\n\nbool QODBCDriver::hasFeature(DriverFeature f) const\n{\n    Q_D(const QODBCDriver);\n    switch (f) {\n    case Transactions: {\n        if (!d->hDbc)\n            return false;\n        SQLUSMALLINT txn;\n        SQLSMALLINT t;\n        int r = SQLGetInfo(d->hDbc,\n                        (SQLUSMALLINT)SQL_TXN_CAPABLE,\n                        &txn,\n                        sizeof(txn),\n                        &t);\n        if (r != SQL_SUCCESS || txn == SQL_TC_NONE)\n            return false;\n        else\n            return true;\n    }\n    case Unicode:\n        return d->unicode;\n    case PreparedQueries:\n    case PositionalPlaceholders:\n    case FinishQuery:\n    case LowPrecisionNumbers:\n        return true;\n    case QuerySize:\n    case NamedPlaceholders:\n    case BatchOperations:\n    case SimpleLocking:\n    case EventNotifications:\n    case CancelQuery:\n        return false;\n    case LastInsertId:\n        return (d->dbmsType == MSSqlServer)\n                || (d->dbmsType == Sybase)\n                || (d->dbmsType == MySqlServer)\n                || (d->dbmsType == PostgreSQL);\n    case MultipleResultSets:\n        return d->hasMultiResultSets;\n    case BLOB: {\n        if (d->dbmsType == MySqlServer)\n            return true;\n        else\n            return false;\n    }\n    }\n    return false;\n}\n\nbool QODBCDriver::open(const QString & db,\n                        const QString & user,\n                        const QString & password,\n                        const QString &,\n                        int,\n                        const QString& connOpts)\n{\n    Q_D(QODBCDriver);\n    if (isOpen())\n      close();\n    SQLRETURN r;\n    r = SQLAllocHandle(SQL_HANDLE_ENV,\n                        SQL_NULL_HANDLE,\n                        &d->hEnv);\n    if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO) {\n        qSqlWarning(\"QODBCDriver::open: Unable to allocate environment\"_L1, d);\n        setOpenError(true);\n        return false;\n    }\n    r = SQLSetEnvAttr(d->hEnv,\n                       SQL_ATTR_ODBC_VERSION,\n                       (SQLPOINTER)qGetODBCVersion(connOpts),\n                       SQL_IS_UINTEGER);\n    r = SQLAllocHandle(SQL_HANDLE_DBC,\n                        d->hEnv,\n                        &d->hDbc);\n    if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO) {\n        qSqlWarning(\"QODBCDriver::open: Unable to allocate connection\"_L1, d);\n        setOpenError(true);\n        cleanup();\n        return false;\n    }\n\n    if (!d->setConnectionOptions(connOpts)) {\n        cleanup();\n        return false;\n    }\n\n    // Create the connection string\n    QString connQStr;\n    // support the \"DRIVER={SQL SERVER};SERVER=blah\" syntax\n    if (db.contains(\".dsn\"_L1, Qt::CaseInsensitive))\n        connQStr = \"FILEDSN=\"_L1 + db;\n    else if (db.contains(\"DRIVER=\"_L1, Qt::CaseInsensitive)\n            || db.contains(\"SERVER=\"_L1, Qt::CaseInsensitive))\n        connQStr = db;\n    else\n        connQStr = \"DSN=\"_L1 + db;\n\n    if (!user.isEmpty())\n        connQStr += \";UID=\"_L1 + user;\n    if (!password.isEmpty())\n        connQStr += \";PWD=\"_L1 + password;\n\n    SQLSMALLINT cb;\n    QVarLengthArray<SQLTCHAR> connOut(1024);\n    memset(connOut.data(), 0, connOut.size() * sizeof(SQLTCHAR));\n    r = SQLDriverConnect(d->hDbc,\n                          NULL,\n                          toSQLTCHAR(connQStr).data(),\n                          (SQLSMALLINT)connQStr.length(),\n                          connOut.data(),\n                          1024,\n                          &cb,\n                          /*SQL_DRIVER_NOPROMPT*/0);\n\n    if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO) {\n        setLastError(qMakeError(tr(\"Unable to connect\"), QSqlError::ConnectionError, d));\n        setOpenError(true);\n        cleanup();\n        return false;\n    }\n\n    if (!d->checkDriver()) {\n        setLastError(qMakeError(tr(\"Unable to connect - Driver doesn't support all \"\n                     \"functionality required\"), QSqlError::ConnectionError, d));\n        setOpenError(true);\n        cleanup();\n        return false;\n    }\n\n    d->checkUnicode();\n    d->checkSchemaUsage();\n    d->checkDBMS();\n    d->checkHasSQLFetchScroll();\n    d->checkHasMultiResults();\n    d->checkDateTimePrecision();\n    setOpen(true);\n    setOpenError(false);\n    if (d->dbmsType == MSSqlServer) {\n        QSqlQuery i(createResult());\n        i.exec(\"SET QUOTED_IDENTIFIER ON\"_L1);\n    }\n    return true;\n}\n\nvoid QODBCDriver::close()\n{\n    cleanup();\n    setOpen(false);\n    setOpenError(false);\n}\n\nvoid QODBCDriver::cleanup()\n{\n    Q_D(QODBCDriver);\n    SQLRETURN r;\n\n    if (d->hDbc) {\n        // Open statements/descriptors handles are automatically cleaned up by SQLDisconnect\n        if (isOpen()) {\n            r = SQLDisconnect(d->hDbc);\n            if (r != SQL_SUCCESS)\n                qSqlWarning(\"QODBCDriver::disconnect: Unable to disconnect datasource\"_L1, d);\n            else\n                d->disconnectCount++;\n        }\n\n        r = SQLFreeHandle(SQL_HANDLE_DBC, d->hDbc);\n        if (r != SQL_SUCCESS)\n            qSqlWarning(\"QODBCDriver::cleanup: Unable to free connection handle\"_L1, d);\n        d->hDbc = 0;\n    }\n\n    if (d->hEnv) {\n        r = SQLFreeHandle(SQL_HANDLE_ENV, d->hEnv);\n        if (r != SQL_SUCCESS)\n            qSqlWarning(\"QODBCDriver::cleanup: Unable to free environment handle\"_L1, d);\n        d->hEnv = 0;\n    }\n}\n\n// checks whether the server can return char, varchar and longvarchar\n// as two byte unicode characters\nvoid QODBCDriverPrivate::checkUnicode()\n{\n    SQLRETURN   r;\n    SQLUINTEGER fFunc;\n\n    unicode = false;\n    r = SQLGetInfo(hDbc,\n                    SQL_CONVERT_CHAR,\n                    (SQLPOINTER)&fFunc,\n                    sizeof(fFunc),\n                    NULL);\n    if ((r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO) && (fFunc & SQL_CVT_WCHAR)) {\n        unicode = true;\n        return;\n    }\n\n    r = SQLGetInfo(hDbc,\n                    SQL_CONVERT_VARCHAR,\n                    (SQLPOINTER)&fFunc,\n                    sizeof(fFunc),\n                    NULL);\n    if ((r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO) && (fFunc & SQL_CVT_WVARCHAR)) {\n        unicode = true;\n        return;\n    }\n\n    r = SQLGetInfo(hDbc,\n                    SQL_CONVERT_LONGVARCHAR,\n                    (SQLPOINTER)&fFunc,\n                    sizeof(fFunc),\n                    NULL);\n    if ((r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO) && (fFunc & SQL_CVT_WLONGVARCHAR)) {\n        unicode = true;\n        return;\n    }\n    SQLHANDLE hStmt;\n    r = SQLAllocHandle(SQL_HANDLE_STMT,\n                                  hDbc,\n                                  &hStmt);\n\n    r = SQLExecDirect(hStmt, toSQLTCHAR(\"select 'test'\"_L1).data(), SQL_NTS);\n    if (r == SQL_SUCCESS) {\n        r = SQLFetch(hStmt);\n        if (r == SQL_SUCCESS) {\n            QVarLengthArray<SQLWCHAR> buffer(10);\n            r = SQLGetData(hStmt, 1, SQL_C_WCHAR, buffer.data(), buffer.size() * sizeof(SQLWCHAR), NULL);\n            if (r == SQL_SUCCESS && fromSQLTCHAR(buffer) == \"test\"_L1) {\n                unicode = true;\n            }\n        }\n    }\n    r = SQLFreeHandle(SQL_HANDLE_STMT, hStmt);\n}\n\nbool QODBCDriverPrivate::checkDriver() const\n{\n#ifdef ODBC_CHECK_DRIVER\n    static const SQLUSMALLINT reqFunc[] = {\n                SQL_API_SQLDESCRIBECOL, SQL_API_SQLGETDATA, SQL_API_SQLCOLUMNS,\n                SQL_API_SQLGETSTMTATTR, SQL_API_SQLGETDIAGREC, SQL_API_SQLEXECDIRECT,\n                SQL_API_SQLGETINFO, SQL_API_SQLTABLES, 0\n    };\n\n    // these functions are optional\n    static const SQLUSMALLINT optFunc[] = {\n        SQL_API_SQLNUMRESULTCOLS, SQL_API_SQLROWCOUNT, 0\n    };\n\n    SQLRETURN r;\n    SQLUSMALLINT sup;\n\n    int i;\n    // check the required functions\n    for (i = 0; reqFunc[i] != 0; ++i) {\n\n        r = SQLGetFunctions(hDbc, reqFunc[i], &sup);\n\n        if (r != SQL_SUCCESS) {\n            qSqlWarning(\"QODBCDriver::checkDriver: Cannot get list of supported functions\"_L1, this);\n            return false;\n        }\n        if (sup == SQL_FALSE) {\n            qWarning () << \"QODBCDriver::open: Warning - Driver doesn't support all needed functionality (\" << reqFunc[i] <<\n                    \").\\nPlease look at the Qt SQL Module Driver documentation for more information.\";\n            return false;\n        }\n    }\n\n    // these functions are optional and just generate a warning\n    for (i = 0; optFunc[i] != 0; ++i) {\n\n        r = SQLGetFunctions(hDbc, optFunc[i], &sup);\n\n        if (r != SQL_SUCCESS) {\n            qSqlWarning(\"QODBCDriver::checkDriver: Cannot get list of supported functions\"_L1, this);\n            return false;\n        }\n        if (sup == SQL_FALSE) {\n            qWarning() << \"QODBCDriver::checkDriver: Warning - Driver doesn't support some non-critical functions (\" << optFunc[i] << ')';\n            return true;\n        }\n    }\n#endif //ODBC_CHECK_DRIVER\n\n    return true;\n}\n\nvoid QODBCDriverPrivate::checkSchemaUsage()\n{\n    SQLRETURN   r;\n    SQLUINTEGER val;\n\n    r = SQLGetInfo(hDbc,\n                   SQL_SCHEMA_USAGE,\n                   (SQLPOINTER) &val,\n                   sizeof(val),\n                   NULL);\n    if (r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO)\n        useSchema = (val != 0);\n}\n\nvoid QODBCDriverPrivate::checkDBMS()\n{\n    SQLRETURN   r;\n    QVarLengthArray<SQLTCHAR> serverString(200);\n    SQLSMALLINT t;\n    memset(serverString.data(), 0, serverString.size() * sizeof(SQLTCHAR));\n\n    r = SQLGetInfo(hDbc,\n                   SQL_DBMS_NAME,\n                   serverString.data(),\n                   SQLSMALLINT(serverString.size() * sizeof(SQLTCHAR)),\n                   &t);\n    if (r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO) {\n        const QString serverType = fromSQLTCHAR(serverString, t / sizeof(SQLTCHAR));\n        if (serverType.contains(\"PostgreSQL\"_L1, Qt::CaseInsensitive))\n            dbmsType = QSqlDriver::PostgreSQL;\n        else if (serverType.contains(\"Oracle\"_L1, Qt::CaseInsensitive))\n            dbmsType = QSqlDriver::Oracle;\n        else if (serverType.contains(\"MySql\"_L1, Qt::CaseInsensitive))\n            dbmsType = QSqlDriver::MySqlServer;\n        else if (serverType.contains(\"Microsoft SQL Server\"_L1, Qt::CaseInsensitive))\n            dbmsType = QSqlDriver::MSSqlServer;\n        else if (serverType.contains(\"Sybase\"_L1, Qt::CaseInsensitive))\n            dbmsType = QSqlDriver::Sybase;\n    }\n    r = SQLGetInfo(hDbc,\n                   SQL_DRIVER_NAME,\n                   serverString.data(),\n                   SQLSMALLINT(serverString.size() * sizeof(SQLTCHAR)),\n                   &t);\n    if (r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO) {\n        const QString serverType = fromSQLTCHAR(serverString, t / sizeof(SQLTCHAR));\n        isFreeTDSDriver = serverType.contains(\"tdsodbc\"_L1, Qt::CaseInsensitive);\n        unicode = unicode && !isFreeTDSDriver;\n    }\n}\n\nvoid QODBCDriverPrivate::checkHasSQLFetchScroll()\n{\n    SQLUSMALLINT sup;\n    SQLRETURN r = SQLGetFunctions(hDbc, SQL_API_SQLFETCHSCROLL, &sup);\n    if ((r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO) || sup != SQL_TRUE) {\n        hasSQLFetchScroll = false;\n        qWarning(\"QODBCDriver::checkHasSQLFetchScroll: Warning - Driver doesn't support scrollable result sets, use forward only mode for queries\");\n    }\n}\n\nvoid QODBCDriverPrivate::checkHasMultiResults()\n{\n    QVarLengthArray<SQLTCHAR> driverResponse(2);\n    SQLSMALLINT length;\n    SQLRETURN r = SQLGetInfo(hDbc,\n                             SQL_MULT_RESULT_SETS,\n                             driverResponse.data(),\n                             SQLSMALLINT(driverResponse.size() * sizeof(SQLTCHAR)),\n                             &length);\n    if (r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO)\n        hasMultiResultSets = fromSQLTCHAR(driverResponse, length/sizeof(SQLTCHAR)).startsWith(u'Y');\n}\n\nvoid QODBCDriverPrivate::checkDateTimePrecision()\n{\n    SQLINTEGER columnSize;\n    SQLHANDLE hStmt;\n\n    SQLRETURN r = SQLAllocHandle(SQL_HANDLE_STMT, hDbc, &hStmt);\n    if (r != SQL_SUCCESS) {\n        return;\n    }\n\n    r = SQLGetTypeInfo(hStmt, SQL_TIMESTAMP);\n    if (r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO) {\n        r = SQLFetch(hStmt);\n        if ( r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO )\n        {\n            if (SQLGetData(hStmt, 3, SQL_INTEGER, &columnSize, sizeof(columnSize), 0) == SQL_SUCCESS) {\n                datetimePrecision = (int)columnSize;\n            }\n        }\n    }\n    SQLFreeHandle(SQL_HANDLE_STMT, hStmt);\n}\n\nQSqlResult *QODBCDriver::createResult() const\n{\n    return new QODBCResult(this);\n}\n\nbool QODBCDriver::beginTransaction()\n{\n    Q_D(QODBCDriver);\n    if (!isOpen()) {\n        qWarning(\"QODBCDriver::beginTransaction: Database not open\");\n        return false;\n    }\n    SQLUINTEGER ac(SQL_AUTOCOMMIT_OFF);\n    SQLRETURN r  = SQLSetConnectAttr(d->hDbc,\n                                      SQL_ATTR_AUTOCOMMIT,\n                                      (SQLPOINTER)size_t(ac),\n                                      sizeof(ac));\n    if (r != SQL_SUCCESS) {\n        setLastError(qMakeError(tr(\"Unable to disable autocommit\"),\n                     QSqlError::TransactionError, d));\n        return false;\n    }\n    return true;\n}\n\nbool QODBCDriver::commitTransaction()\n{\n    Q_D(QODBCDriver);\n    if (!isOpen()) {\n        qWarning(\"QODBCDriver::commitTransaction: Database not open\");\n        return false;\n    }\n    SQLRETURN r = SQLEndTran(SQL_HANDLE_DBC,\n                              d->hDbc,\n                              SQL_COMMIT);\n    if (r != SQL_SUCCESS) {\n        setLastError(qMakeError(tr(\"Unable to commit transaction\"),\n                     QSqlError::TransactionError, d));\n        return false;\n    }\n    return endTrans();\n}\n\nbool QODBCDriver::rollbackTransaction()\n{\n    Q_D(QODBCDriver);\n    if (!isOpen()) {\n        qWarning(\"QODBCDriver::rollbackTransaction: Database not open\");\n        return false;\n    }\n    SQLRETURN r = SQLEndTran(SQL_HANDLE_DBC,\n                              d->hDbc,\n                              SQL_ROLLBACK);\n    if (r != SQL_SUCCESS) {\n        setLastError(qMakeError(tr(\"Unable to rollback transaction\"),\n                     QSqlError::TransactionError, d));\n        return false;\n    }\n    return endTrans();\n}\n\nbool QODBCDriver::endTrans()\n{\n    Q_D(QODBCDriver);\n    SQLUINTEGER ac(SQL_AUTOCOMMIT_ON);\n    SQLRETURN r  = SQLSetConnectAttr(d->hDbc,\n                                      SQL_ATTR_AUTOCOMMIT,\n                                      (SQLPOINTER)size_t(ac),\n                                      sizeof(ac));\n    if (r != SQL_SUCCESS) {\n        setLastError(qMakeError(tr(\"Unable to enable autocommit\"), QSqlError::TransactionError, d));\n        return false;\n    }\n    return true;\n}\n\nQStringList QODBCDriver::tables(QSql::TableType type) const\n{\n    Q_D(const QODBCDriver);\n    QStringList tl;\n    if (!isOpen())\n        return tl;\n    SQLHANDLE hStmt;\n\n    SQLRETURN r = SQLAllocHandle(SQL_HANDLE_STMT,\n                                  d->hDbc,\n                                  &hStmt);\n    if (r != SQL_SUCCESS) {\n        qSqlWarning(\"QODBCDriver::tables: Unable to allocate handle\"_L1, d);\n        return tl;\n    }\n    r = SQLSetStmtAttr(hStmt,\n                        SQL_ATTR_CURSOR_TYPE,\n                        (SQLPOINTER)SQL_CURSOR_FORWARD_ONLY,\n                        SQL_IS_UINTEGER);\n    QStringList tableType;\n    if (type & QSql::Tables)\n        tableType += \"TABLE\"_L1;\n    if (type & QSql::Views)\n        tableType += \"VIEW\"_L1;\n    if (type & QSql::SystemTables)\n        tableType += \"SYSTEM TABLE\"_L1;\n    if (tableType.isEmpty())\n        return tl;\n\n    QString joinedTableTypeString = tableType.join(u',');\n\n    r = SQLTables(hStmt,\n                   NULL,\n                   0,\n                   NULL,\n                   0,\n                   NULL,\n                   0,\n                   toSQLTCHAR(joinedTableTypeString).data(),\n                   joinedTableTypeString.length() /* characters, not bytes */);\n\n    if (r != SQL_SUCCESS)\n        qSqlWarning(\"QODBCDriver::tables Unable to execute table list\"_L1, d);\n\n    if (d->hasSQLFetchScroll)\n        r = SQLFetchScroll(hStmt,\n                           SQL_FETCH_NEXT,\n                           0);\n    else\n        r = SQLFetch(hStmt);\n\n    if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO && r != SQL_NO_DATA) {\n        qWarning() << \"QODBCDriver::tables failed to retrieve table/view list: (\" << r << \",\" << qWarnODBCHandle(SQL_HANDLE_STMT, hStmt) << \")\";\n        return QStringList();\n    }\n\n    while (r == SQL_SUCCESS) {\n        tl.append(qGetStringData(hStmt, 2, -1, d->unicode).toString());\n\n        if (d->hasSQLFetchScroll)\n            r = SQLFetchScroll(hStmt,\n                               SQL_FETCH_NEXT,\n                               0);\n        else\n            r = SQLFetch(hStmt);\n    }\n\n    r = SQLFreeHandle(SQL_HANDLE_STMT, hStmt);\n    if (r!= SQL_SUCCESS)\n        qSqlWarning(\"QODBCDriver: Unable to free statement handle\"_L1 + QString::number(r), d);\n    return tl;\n}\n\nQSqlIndex QODBCDriver::primaryIndex(const QString& tablename) const\n{\n    Q_D(const QODBCDriver);\n    QSqlIndex index(tablename);\n    if (!isOpen())\n        return index;\n    bool usingSpecialColumns = false;\n    QSqlRecord rec = record(tablename);\n\n    SQLHANDLE hStmt;\n    SQLRETURN r = SQLAllocHandle(SQL_HANDLE_STMT,\n                                  d->hDbc,\n                                  &hStmt);\n    if (r != SQL_SUCCESS) {\n        qSqlWarning(\"QODBCDriver::primaryIndex: Unable to list primary key\"_L1, d);\n        return index;\n    }\n    QString catalog, schema, table;\n    const_cast<QODBCDriverPrivate*>(d)->splitTableQualifier(tablename, catalog, schema, table);\n\n    if (isIdentifierEscaped(catalog, QSqlDriver::TableName))\n        catalog = stripDelimiters(catalog, QSqlDriver::TableName);\n    else\n        catalog = d->adjustCase(catalog);\n\n    if (isIdentifierEscaped(schema, QSqlDriver::TableName))\n        schema = stripDelimiters(schema, QSqlDriver::TableName);\n    else\n        schema = d->adjustCase(schema);\n\n    if (isIdentifierEscaped(table, QSqlDriver::TableName))\n        table = stripDelimiters(table, QSqlDriver::TableName);\n    else\n        table = d->adjustCase(table);\n\n    r = SQLSetStmtAttr(hStmt,\n                        SQL_ATTR_CURSOR_TYPE,\n                        (SQLPOINTER)SQL_CURSOR_FORWARD_ONLY,\n                        SQL_IS_UINTEGER);\n    r = SQLPrimaryKeys(hStmt,\n                        catalog.length() == 0 ? NULL : toSQLTCHAR(catalog).data(),\n                        catalog.length(),\n                        schema.length() == 0 ? NULL : toSQLTCHAR(schema).data(),\n                        schema.length(),\n                        toSQLTCHAR(table).data(),\n                        table.length() /* in characters, not in bytes */);\n\n    // if the SQLPrimaryKeys() call does not succeed (e.g the driver\n    // does not support it) - try an alternative method to get hold of\n    // the primary index (e.g MS Access and FoxPro)\n    if (r != SQL_SUCCESS) {\n            r = SQLSpecialColumns(hStmt,\n                        SQL_BEST_ROWID,\n                        catalog.length() == 0 ? NULL : toSQLTCHAR(catalog).data(),\n                        catalog.length(),\n                        schema.length() == 0 ? NULL : toSQLTCHAR(schema).data(),\n                        schema.length(),\n                        toSQLTCHAR(table).data(),\n                        table.length(),\n                        SQL_SCOPE_CURROW,\n                        SQL_NULLABLE);\n\n            if (r != SQL_SUCCESS) {\n                qSqlWarning(\"QODBCDriver::primaryIndex: Unable to execute primary key list\"_L1, d);\n            } else {\n                usingSpecialColumns = true;\n            }\n    }\n\n    if (d->hasSQLFetchScroll)\n        r = SQLFetchScroll(hStmt,\n                           SQL_FETCH_NEXT,\n                           0);\n    else\n        r = SQLFetch(hStmt);\n\n    int fakeId = 0;\n    QString cName, idxName;\n    // Store all fields in a StringList because some drivers can't detail fields in this FETCH loop\n    while (r == SQL_SUCCESS) {\n        if (usingSpecialColumns) {\n            cName = qGetStringData(hStmt, 1, -1, d->unicode).toString(); // column name\n            idxName = QString::number(fakeId++); // invent a fake index name\n        } else {\n            cName = qGetStringData(hStmt, 3, -1, d->unicode).toString(); // column name\n            idxName = qGetStringData(hStmt, 5, -1, d->unicode).toString(); // pk index name\n        }\n        index.append(rec.field(cName));\n        index.setName(idxName);\n\n        if (d->hasSQLFetchScroll)\n            r = SQLFetchScroll(hStmt,\n                               SQL_FETCH_NEXT,\n                               0);\n        else\n            r = SQLFetch(hStmt);\n\n    }\n    r = SQLFreeHandle(SQL_HANDLE_STMT, hStmt);\n    if (r!= SQL_SUCCESS)\n        qSqlWarning(\"QODBCDriver: Unable to free statement handle\"_L1 + QString::number(r), d);\n    return index;\n}\n\nQSqlRecord QODBCDriver::record(const QString& tablename) const\n{\n    Q_D(const QODBCDriver);\n    QSqlRecord fil;\n    if (!isOpen())\n        return fil;\n\n    SQLHANDLE hStmt;\n    QString catalog, schema, table;\n    const_cast<QODBCDriverPrivate*>(d)->splitTableQualifier(tablename, catalog, schema, table);\n\n    if (isIdentifierEscaped(catalog, QSqlDriver::TableName))\n        catalog = stripDelimiters(catalog, QSqlDriver::TableName);\n    else\n        catalog = d->adjustCase(catalog);\n\n    if (isIdentifierEscaped(schema, QSqlDriver::TableName))\n        schema = stripDelimiters(schema, QSqlDriver::TableName);\n    else\n        schema = d->adjustCase(schema);\n\n    if (isIdentifierEscaped(table, QSqlDriver::TableName))\n        table = stripDelimiters(table, QSqlDriver::TableName);\n    else\n        table = d->adjustCase(table);\n\n    SQLRETURN r = SQLAllocHandle(SQL_HANDLE_STMT,\n                                  d->hDbc,\n                                  &hStmt);\n    if (r != SQL_SUCCESS) {\n        qSqlWarning(\"QODBCDriver::record: Unable to allocate handle\"_L1, d);\n        return fil;\n    }\n    r = SQLSetStmtAttr(hStmt,\n                        SQL_ATTR_CURSOR_TYPE,\n                        (SQLPOINTER)SQL_CURSOR_FORWARD_ONLY,\n                        SQL_IS_UINTEGER);\n    r =  SQLColumns(hStmt,\n                     catalog.length() == 0 ? NULL : toSQLTCHAR(catalog).data(),\n                     catalog.length(),\n                     schema.length() == 0 ? NULL : toSQLTCHAR(schema).data(),\n                     schema.length(),\n                     toSQLTCHAR(table).data(),\n                     table.length(),\n                     NULL,\n                     0);\n    if (r != SQL_SUCCESS)\n        qSqlWarning(\"QODBCDriver::record: Unable to execute column list\"_L1, d);\n\n    if (d->hasSQLFetchScroll)\n        r = SQLFetchScroll(hStmt,\n                           SQL_FETCH_NEXT,\n                           0);\n    else\n        r = SQLFetch(hStmt);\n\n    // Store all fields in a StringList because some drivers can't detail fields in this FETCH loop\n    while (r == SQL_SUCCESS) {\n\n        fil.append(qMakeFieldInfo(hStmt, d));\n\n        if (d->hasSQLFetchScroll)\n            r = SQLFetchScroll(hStmt,\n                               SQL_FETCH_NEXT,\n                               0);\n        else\n            r = SQLFetch(hStmt);\n    }\n\n    r = SQLFreeHandle(SQL_HANDLE_STMT, hStmt);\n    if (r!= SQL_SUCCESS)\n        qSqlWarning(\"QODBCDriver: Unable to free statement handle \"_L1 + QString::number(r), d);\n\n    return fil;\n}\n\nQString QODBCDriver::formatValue(const QSqlField &field,\n                                 bool trimStrings) const\n{\n    QString r;\n    if (field.isNull()) {\n        r = \"NULL\"_L1;\n    } else if (field.metaType().id() == QMetaType::QDateTime) {\n        // Use an escape sequence for the datetime fields\n        if (field.value().toDateTime().isValid()){\n            QDate dt = field.value().toDateTime().date();\n            QTime tm = field.value().toDateTime().time();\n            // Dateformat has to be \"yyyy-MM-dd hh:mm:ss\", with leading zeroes if month or day < 10\n            r = \"{ ts '\"_L1 +\n                QString::number(dt.year()) + u'-' +\n                QString::number(dt.month()).rightJustified(2, u'0', true) +\n                u'-' +\n                QString::number(dt.day()).rightJustified(2, u'0', true) +\n                u' ' +\n                tm.toString() +\n                \"' }\"_L1;\n        } else\n            r = \"NULL\"_L1;\n    } else if (field.metaType().id() == QMetaType::QByteArray) {\n        QByteArray ba = field.value().toByteArray();\n        QString res;\n        static const char hexchars[] = \"0123456789abcdef\";\n        for (int i = 0; i < ba.size(); ++i) {\n            uchar s = (uchar) ba[i];\n            res += QLatin1Char(hexchars[s >> 4]);\n            res += QLatin1Char(hexchars[s & 0x0f]);\n        }\n        r = \"0x\"_L1 + res;\n    } else {\n        r = QSqlDriver::formatValue(field, trimStrings);\n    }\n    return r;\n}\n\nQVariant QODBCDriver::handle() const\n{\n    Q_D(const QODBCDriver);\n    return QVariant(QMetaType::fromType<SQLHANDLE>(), &d->hDbc);\n}\n\nQString QODBCDriver::escapeIdentifier(const QString &identifier, IdentifierType) const\n{\n    Q_D(const QODBCDriver);\n    QChar quote = const_cast<QODBCDriverPrivate*>(d)->quoteChar();\n    QString res = identifier;\n    if (!identifier.isEmpty() && !identifier.startsWith(quote) && !identifier.endsWith(quote) ) {\n        res.replace(quote, QString(quote)+QString(quote));\n        res.prepend(quote).append(quote);\n        res.replace(u'.', QString(quote) + u'.' +QString(quote));\n    }\n    return res;\n}\n\nbool QODBCDriver::isIdentifierEscaped(const QString &identifier, IdentifierType) const\n{\n    Q_D(const QODBCDriver);\n    QChar quote = const_cast<QODBCDriverPrivate*>(d)->quoteChar();\n    return identifier.size() > 2\n        && identifier.startsWith(quote) //left delimited\n        && identifier.endsWith(quote); //right delimited\n}\n\nQT_END_NAMESPACE\n\n#include \"moc_qsql_odbc_p.cpp\"\n"], "fixing_code": ["// Copyright (C) 2016 The Qt Company Ltd.\n// SPDX-License-Identifier: LicenseRef-Qt-Commercial OR LGPL-3.0-only OR GPL-2.0-only OR GPL-3.0-only\n\n#include \"qsql_odbc_p.h\"\n#include <qsqlrecord.h>\n\n#if defined (Q_OS_WIN32)\n#include <qt_windows.h>\n#endif\n#include <qcoreapplication.h>\n#include <qdatetime.h>\n#include <qlist.h>\n#include <qmath.h>\n#include <qsqlerror.h>\n#include <qsqlfield.h>\n#include <qsqlindex.h>\n#include <qstringlist.h>\n#include <qvariant.h>\n#include <qvarlengtharray.h>\n#include <QDebug>\n#include <QSqlQuery>\n#include <QtSql/private/qsqldriver_p.h>\n#include <QtSql/private/qsqlresult_p.h>\n\nQT_BEGIN_NAMESPACE\n\nusing namespace Qt::StringLiterals;\n\n// undefine this to prevent initial check of the ODBC driver\n#define ODBC_CHECK_DRIVER\n\nstatic const int COLNAMESIZE = 256;\nstatic const SQLSMALLINT TABLENAMESIZE = 128;\n//Map Qt parameter types to ODBC types\nstatic const SQLSMALLINT qParamType[4] = { SQL_PARAM_INPUT, SQL_PARAM_INPUT, SQL_PARAM_OUTPUT, SQL_PARAM_INPUT_OUTPUT };\n\ninline static QString fromSQLTCHAR(const QVarLengthArray<SQLTCHAR>& input, qsizetype size=-1)\n{\n    QString result;\n\n    // Remove any trailing \\0 as some drivers misguidedly append one\n    int realsize = qMin(size, input.size());\n    if (realsize > 0 && input[realsize-1] == 0)\n        realsize--;\n    switch(sizeof(SQLTCHAR)) {\n        case 1:\n            result=QString::fromUtf8((const char *)input.constData(), realsize);\n            break;\n        case 2:\n            result = QString::fromUtf16(reinterpret_cast<const char16_t *>(input.constData()), realsize);\n            break;\n        case 4:\n            result = QString::fromUcs4(reinterpret_cast<const char32_t *>(input.constData()), realsize);\n            break;\n        default:\n            qCritical(\"sizeof(SQLTCHAR) is %d. Don't know how to handle this.\", int(sizeof(SQLTCHAR)));\n    }\n    return result;\n}\n\ntemplate <size_t SizeOfChar = sizeof(SQLTCHAR)>\nvoid toSQLTCHARImpl(QVarLengthArray<SQLTCHAR> &result, const QString &input); // primary template undefined\n\ntemplate <typename Container>\nvoid do_append(QVarLengthArray<SQLTCHAR> &result, const Container &c)\n{\n    result.append(reinterpret_cast<const SQLTCHAR *>(c.data()), c.size());\n}\n\ntemplate <>\nvoid toSQLTCHARImpl<1>(QVarLengthArray<SQLTCHAR> &result, const QString &input)\n{\n    const auto u8 = input.toUtf8();\n    do_append(result, u8);\n}\n\ntemplate <>\nvoid toSQLTCHARImpl<2>(QVarLengthArray<SQLTCHAR> &result, const QString &input)\n{\n    do_append(result, input);\n}\n\ntemplate <>\nvoid toSQLTCHARImpl<4>(QVarLengthArray<SQLTCHAR> &result, const QString &input)\n{\n    const auto u32 = input.toUcs4();\n    do_append(result, u32);\n}\n\ninline static QVarLengthArray<SQLTCHAR> toSQLTCHAR(const QString &input)\n{\n    QVarLengthArray<SQLTCHAR> result;\n    toSQLTCHARImpl(result, input);\n    result.append(0); // make sure it's null terminated, doesn't matter if it already is, it does if it isn't.\n    return result;\n}\n\nclass QODBCDriverPrivate : public QSqlDriverPrivate\n{\n    Q_DECLARE_PUBLIC(QODBCDriver)\n\npublic:\n    enum DefaultCase {Lower, Mixed, Upper, Sensitive};\n    using QSqlDriverPrivate::QSqlDriverPrivate;\n\n    SQLHANDLE hEnv = nullptr;\n    SQLHANDLE hDbc = nullptr;\n\n    int disconnectCount = 0;\n    int datetimePrecision = 19;\n    bool unicode = false;\n    bool useSchema = false;\n    bool isFreeTDSDriver = false;\n    bool hasSQLFetchScroll = true;\n    bool hasMultiResultSets = false;\n\n    bool checkDriver() const;\n    void checkUnicode();\n    void checkDBMS();\n    void checkHasSQLFetchScroll();\n    void checkHasMultiResults();\n    void checkSchemaUsage();\n    void checkDateTimePrecision();\n    bool setConnectionOptions(const QString& connOpts);\n    void splitTableQualifier(const QString &qualifier, QString &catalog,\n                             QString &schema, QString &table);\n    DefaultCase defaultCase() const;\n    QString adjustCase(const QString&) const;\n    QChar quoteChar();\nprivate:\n    bool isQuoteInitialized = false;\n    QChar quote = u'\"';\n};\n\nclass QODBCResultPrivate;\n\nclass QODBCResult: public QSqlResult\n{\n    Q_DECLARE_PRIVATE(QODBCResult)\n\npublic:\n    QODBCResult(const QODBCDriver *db);\n    virtual ~QODBCResult();\n\n    bool prepare(const QString &query) override;\n    bool exec() override;\n\n    QVariant lastInsertId() const override;\n    QVariant handle() const override;\n\nprotected:\n    bool fetchNext() override;\n    bool fetchFirst() override;\n    bool fetchLast() override;\n    bool fetchPrevious() override;\n    bool fetch(int i) override;\n    bool reset(const QString &query) override;\n    QVariant data(int field) override;\n    bool isNull(int field) override;\n    int size() override;\n    int numRowsAffected() override;\n    QSqlRecord record() const override;\n    void virtual_hook(int id, void *data) override;\n    void detachFromResultSet() override;\n    bool nextResult() override;\n};\n\nclass QODBCResultPrivate: public QSqlResultPrivate\n{\n    Q_DECLARE_PUBLIC(QODBCResult)\n\npublic:\n    Q_DECLARE_SQLDRIVER_PRIVATE(QODBCDriver)\n    QODBCResultPrivate(QODBCResult *q, const QODBCDriver *db)\n        : QSqlResultPrivate(q, db)\n    {\n        unicode = drv_d_func()->unicode;\n        useSchema = drv_d_func()->useSchema;\n        disconnectCount = drv_d_func()->disconnectCount;\n        hasSQLFetchScroll = drv_d_func()->hasSQLFetchScroll;\n    }\n\n    inline void clearValues()\n    { fieldCache.fill(QVariant()); fieldCacheIdx = 0; }\n\n    SQLHANDLE dpEnv() const { return drv_d_func() ? drv_d_func()->hEnv : 0;}\n    SQLHANDLE dpDbc() const { return drv_d_func() ? drv_d_func()->hDbc : 0;}\n    SQLHANDLE hStmt = nullptr;\n\n    QSqlRecord rInf;\n    QVariantList fieldCache;\n    int fieldCacheIdx = 0;\n    int disconnectCount = 0;\n    bool hasSQLFetchScroll = true;\n    bool unicode = false;\n    bool useSchema = false;\n\n    bool isStmtHandleValid() const;\n    void updateStmtHandleState();\n};\n\nbool QODBCResultPrivate::isStmtHandleValid() const\n{\n    return drv_d_func() && disconnectCount == drv_d_func()->disconnectCount;\n}\n\nvoid QODBCResultPrivate::updateStmtHandleState()\n{\n    disconnectCount = drv_d_func() ? drv_d_func()->disconnectCount : 0;\n}\n\nstatic QString qWarnODBCHandle(int handleType, SQLHANDLE handle, int *nativeCode = nullptr)\n{\n    SQLINTEGER nativeCode_ = 0;\n    SQLSMALLINT msgLen = 0;\n    SQLRETURN r = SQL_NO_DATA;\n    SQLTCHAR state_[SQL_SQLSTATE_SIZE+1];\n    QVarLengthArray<SQLTCHAR> description_(SQL_MAX_MESSAGE_LENGTH);\n    QString result;\n    int i = 1;\n\n    description_[0] = 0;\n    do {\n        r = SQLGetDiagRec(handleType,\n                          handle,\n                          i,\n                          state_,\n                          &nativeCode_,\n                          0,\n                          0,\n                          &msgLen);\n        if ((r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO) && msgLen > 0)\n            description_.resize(msgLen+1);\n        r = SQLGetDiagRec(handleType,\n                            handle,\n                            i,\n                            state_,\n                            &nativeCode_,\n                            description_.data(),\n                            description_.size(),\n                            &msgLen);\n        if (r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO) {\n            if (nativeCode)\n                *nativeCode = nativeCode_;\n            const QString tmpstore = fromSQLTCHAR(description_, msgLen);\n            if (result != tmpstore) {\n                if (!result.isEmpty())\n                    result += u' ';\n                result += tmpstore;\n            }\n        } else if (r == SQL_ERROR || r == SQL_INVALID_HANDLE) {\n            return result;\n        }\n        ++i;\n    } while (r != SQL_NO_DATA);\n    return result;\n}\n\nstatic QString qODBCWarn(const SQLHANDLE hStmt, const SQLHANDLE envHandle = 0,\n                         const SQLHANDLE pDbC = 0, int *nativeCode = nullptr)\n{\n    QString result;\n    if (envHandle)\n        result += qWarnODBCHandle(SQL_HANDLE_ENV, envHandle, nativeCode);\n    if (pDbC) {\n        const QString dMessage = qWarnODBCHandle(SQL_HANDLE_DBC, pDbC, nativeCode);\n        if (!dMessage.isEmpty()) {\n            if (!result.isEmpty())\n                result += u' ';\n            result += dMessage;\n        }\n    }\n    if (hStmt) {\n        const QString hMessage = qWarnODBCHandle(SQL_HANDLE_STMT, hStmt, nativeCode);\n        if (!hMessage.isEmpty()) {\n            if (!result.isEmpty())\n                result += u' ';\n            result += hMessage;\n        }\n    }\n    return result;\n}\n\nstatic QString qODBCWarn(const QODBCResultPrivate* odbc, int *nativeCode = nullptr)\n{\n    return qODBCWarn(odbc->hStmt, odbc->dpEnv(), odbc->dpDbc(), nativeCode);\n}\n\nstatic QString qODBCWarn(const QODBCDriverPrivate* odbc, int *nativeCode = nullptr)\n{\n    return qODBCWarn(0, odbc->hEnv, odbc->hDbc, nativeCode);\n}\n\nstatic void qSqlWarning(const QString& message, const QODBCResultPrivate* odbc)\n{\n    qWarning() << message << \"\\tError:\" << qODBCWarn(odbc);\n}\n\nstatic void qSqlWarning(const QString &message, const QODBCDriverPrivate *odbc)\n{\n    qWarning() << message << \"\\tError:\" << qODBCWarn(odbc);\n}\n\nstatic void qSqlWarning(const QString &message, const SQLHANDLE hStmt)\n{\n    qWarning() << message << \"\\tError:\" << qODBCWarn(hStmt);\n}\n\nstatic QSqlError qMakeError(const QString& err, QSqlError::ErrorType type, const QODBCResultPrivate* p)\n{\n    int nativeCode = -1;\n    QString message = qODBCWarn(p, &nativeCode);\n    return QSqlError(\"QODBC: \"_L1 + err, message, type,\n                     nativeCode != -1 ? QString::number(nativeCode) : QString());\n}\n\nstatic QSqlError qMakeError(const QString& err, QSqlError::ErrorType type,\n                            const QODBCDriverPrivate* p)\n{\n    int nativeCode = -1;\n    QString message = qODBCWarn(p, &nativeCode);\n    return QSqlError(\"QODBC: \"_L1 + err, message, type,\n                     nativeCode != -1 ? QString::number(nativeCode) : QString());\n}\n\nstatic QMetaType qDecodeODBCType(SQLSMALLINT sqltype, bool isSigned = true)\n{\n    int type = QMetaType::UnknownType;\n    switch (sqltype) {\n    case SQL_DECIMAL:\n    case SQL_NUMERIC:\n    case SQL_FLOAT: // 24 or 53 bits precision\n    case SQL_DOUBLE:// 53 bits\n        type = QMetaType::Double;\n        break;\n    case SQL_REAL:  // 24 bits\n        type = QMetaType::Float;\n        break;\n    case SQL_SMALLINT:\n        type = isSigned ? QMetaType::Short : QMetaType::UShort;\n        break;\n    case SQL_INTEGER:\n    case SQL_BIT:\n        type = isSigned ? QMetaType::Int : QMetaType::UInt;\n        break;\n    case SQL_TINYINT:\n        type = QMetaType::UInt;\n        break;\n    case SQL_BIGINT:\n        type = isSigned ? QMetaType::LongLong : QMetaType::ULongLong;\n        break;\n    case SQL_BINARY:\n    case SQL_VARBINARY:\n    case SQL_LONGVARBINARY:\n        type = QMetaType::QByteArray;\n        break;\n    case SQL_DATE:\n    case SQL_TYPE_DATE:\n        type = QMetaType::QDate;\n        break;\n    case SQL_TIME:\n    case SQL_TYPE_TIME:\n        type = QMetaType::QTime;\n        break;\n    case SQL_TIMESTAMP:\n    case SQL_TYPE_TIMESTAMP:\n        type = QMetaType::QDateTime;\n        break;\n    case SQL_WCHAR:\n    case SQL_WVARCHAR:\n    case SQL_WLONGVARCHAR:\n        type = QMetaType::QString;\n        break;\n    case SQL_CHAR:\n    case SQL_VARCHAR:\n#if (ODBCVER >= 0x0350)\n    case SQL_GUID:\n#endif\n    case SQL_LONGVARCHAR:\n        type = QMetaType::QString;\n        break;\n    default:\n        type = QMetaType::QByteArray;\n        break;\n    }\n    return QMetaType(type);\n}\n\nstatic QVariant qGetStringData(SQLHANDLE hStmt, int column, int colSize, bool unicode)\n{\n    QString fieldVal;\n    SQLRETURN r = SQL_ERROR;\n    SQLLEN lengthIndicator = 0;\n\n    // NB! colSize must be a multiple of 2 for unicode enabled DBs\n    if (colSize <= 0) {\n        colSize = 256;\n    } else if (colSize > 65536) { // limit buffer size to 64 KB\n        colSize = 65536;\n    } else {\n        colSize++; // make sure there is room for more than the 0 termination\n    }\n    if (unicode) {\n        r = SQLGetData(hStmt,\n                        column+1,\n                        SQL_C_TCHAR,\n                        NULL,\n                        0,\n                        &lengthIndicator);\n        if ((r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO) && lengthIndicator > 0)\n            colSize = int(lengthIndicator / sizeof(SQLTCHAR) + 1);\n        QVarLengthArray<SQLTCHAR> buf(colSize);\n        memset(buf.data(), 0, colSize*sizeof(SQLTCHAR));\n        while (true) {\n            r = SQLGetData(hStmt,\n                            column+1,\n                            SQL_C_TCHAR,\n                            (SQLPOINTER)buf.data(),\n                            colSize*sizeof(SQLTCHAR),\n                            &lengthIndicator);\n            if (r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO) {\n                if (lengthIndicator == SQL_NULL_DATA) {\n                    return {};\n                }\n                // starting with ODBC Native Client 2012, SQL_NO_TOTAL is returned\n                // instead of the length (which sometimes was wrong in older versions)\n                // see link for more info: http://msdn.microsoft.com/en-us/library/jj219209.aspx\n                // if length indicator equals SQL_NO_TOTAL, indicating that\n                // more data can be fetched, but size not known, collect data\n                // and fetch next block\n                if (lengthIndicator == SQL_NO_TOTAL) {\n                    fieldVal += fromSQLTCHAR(buf, colSize);\n                    continue;\n                }\n                // if SQL_SUCCESS_WITH_INFO is returned, indicating that\n                // more data can be fetched, the length indicator does NOT\n                // contain the number of bytes returned - it contains the\n                // total number of bytes that CAN be fetched\n                int rSize = (r == SQL_SUCCESS_WITH_INFO) ? colSize : int(lengthIndicator / sizeof(SQLTCHAR));\n                    fieldVal += fromSQLTCHAR(buf, rSize);\n                if (lengthIndicator < SQLLEN(colSize*sizeof(SQLTCHAR))) {\n                    // workaround for Drivermanagers that don't return SQL_NO_DATA\n                    break;\n                }\n            } else if (r == SQL_NO_DATA) {\n                break;\n            } else {\n                qWarning() << \"qGetStringData: Error while fetching data (\" << qWarnODBCHandle(SQL_HANDLE_STMT, hStmt) << ')';\n                return {};\n            }\n        }\n    } else {\n        r = SQLGetData(hStmt,\n                        column+1,\n                        SQL_C_CHAR,\n                        NULL,\n                        0,\n                        &lengthIndicator);\n        if ((r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO) && lengthIndicator > 0)\n            colSize = lengthIndicator + 1;\n        QVarLengthArray<SQLCHAR> buf(colSize);\n        while (true) {\n            r = SQLGetData(hStmt,\n                            column+1,\n                            SQL_C_CHAR,\n                            (SQLPOINTER)buf.data(),\n                            colSize,\n                            &lengthIndicator);\n            if (r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO) {\n                if (lengthIndicator == SQL_NULL_DATA || lengthIndicator == SQL_NO_TOTAL) {\n                  return {};\n                }\n                // if SQL_SUCCESS_WITH_INFO is returned, indicating that\n                // more data can be fetched, the length indicator does NOT\n                // contain the number of bytes returned - it contains the\n                // total number of bytes that CAN be fetched\n                qsizetype rSize = (r == SQL_SUCCESS_WITH_INFO) ? colSize : lengthIndicator;\n                // Remove any trailing \\0 as some drivers misguidedly append one\n                int realsize = qMin(rSize, buf.size());\n                if (realsize > 0 && buf[realsize - 1] == 0)\n                    realsize--;\n                fieldVal += QString::fromUtf8(reinterpret_cast<const char *>(buf.constData()), realsize);\n                if (lengthIndicator < SQLLEN(colSize)) {\n                    // workaround for Drivermanagers that don't return SQL_NO_DATA\n                    break;\n                }\n            } else if (r == SQL_NO_DATA) {\n                break;\n            } else {\n                qWarning() << \"qGetStringData: Error while fetching data (\" << qWarnODBCHandle(SQL_HANDLE_STMT, hStmt) << ')';\n                return {};\n            }\n        }\n    }\n    return fieldVal;\n}\n\nstatic QVariant qGetBinaryData(SQLHANDLE hStmt, int column)\n{\n    QByteArray fieldVal;\n    SQLSMALLINT colNameLen;\n    SQLSMALLINT colType;\n    SQLULEN colSize;\n    SQLSMALLINT colScale;\n    SQLSMALLINT nullable;\n    SQLLEN lengthIndicator = 0;\n    SQLRETURN r = SQL_ERROR;\n\n    QVarLengthArray<SQLTCHAR> colName(COLNAMESIZE);\n\n    r = SQLDescribeCol(hStmt,\n                       column + 1,\n                       colName.data(),\n                       COLNAMESIZE,\n                       &colNameLen,\n                       &colType,\n                       &colSize,\n                       &colScale,\n                       &nullable);\n    if (r != SQL_SUCCESS)\n        qWarning() << \"qGetBinaryData: Unable to describe column\" << column;\n    // SQLDescribeCol may return 0 if size cannot be determined\n    if (!colSize)\n        colSize = 255;\n    else if (colSize > 65536) // read the field in 64 KB chunks\n        colSize = 65536;\n    fieldVal.resize(colSize);\n    ulong read = 0;\n    while (true) {\n        r = SQLGetData(hStmt,\n                        column+1,\n                        SQL_C_BINARY,\n                        const_cast<char *>(fieldVal.constData() + read),\n                        colSize,\n                        &lengthIndicator);\n        if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO)\n            break;\n        if (lengthIndicator == SQL_NULL_DATA)\n            return QVariant(QMetaType(QMetaType::QByteArray));\n        if (lengthIndicator > SQLLEN(colSize) || lengthIndicator == SQL_NO_TOTAL) {\n            read += colSize;\n            colSize = 65536;\n        } else {\n            read += lengthIndicator;\n        }\n        if (r == SQL_SUCCESS) { // the whole field was read in one chunk\n            fieldVal.resize(read);\n            break;\n        }\n        fieldVal.resize(fieldVal.size() + colSize);\n    }\n    return fieldVal;\n}\n\nstatic QVariant qGetIntData(SQLHANDLE hStmt, int column, bool isSigned = true)\n{\n    SQLINTEGER intbuf = 0;\n    SQLLEN lengthIndicator = 0;\n    SQLRETURN r = SQLGetData(hStmt,\n                              column+1,\n                              isSigned ? SQL_C_SLONG : SQL_C_ULONG,\n                              (SQLPOINTER)&intbuf,\n                              sizeof(intbuf),\n                              &lengthIndicator);\n    if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO)\n        return QVariant();\n    if (lengthIndicator == SQL_NULL_DATA)\n        return QVariant(QMetaType::fromType<int>());\n    if (isSigned)\n        return int(intbuf);\n    else\n        return uint(intbuf);\n}\n\nstatic QVariant qGetDoubleData(SQLHANDLE hStmt, int column)\n{\n    SQLDOUBLE dblbuf;\n    SQLLEN lengthIndicator = 0;\n    SQLRETURN r = SQLGetData(hStmt,\n                              column+1,\n                              SQL_C_DOUBLE,\n                              (SQLPOINTER) &dblbuf,\n                              0,\n                              &lengthIndicator);\n    if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO) {\n        return QVariant();\n    }\n    if (lengthIndicator == SQL_NULL_DATA)\n        return QVariant(QMetaType::fromType<double>());\n\n    return (double) dblbuf;\n}\n\n\nstatic QVariant qGetBigIntData(SQLHANDLE hStmt, int column, bool isSigned = true)\n{\n    SQLBIGINT lngbuf = 0;\n    SQLLEN lengthIndicator = 0;\n    SQLRETURN r = SQLGetData(hStmt,\n                              column+1,\n                              isSigned ? SQL_C_SBIGINT : SQL_C_UBIGINT,\n                              (SQLPOINTER) &lngbuf,\n                              sizeof(lngbuf),\n                              &lengthIndicator);\n    if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO)\n        return QVariant();\n    if (lengthIndicator == SQL_NULL_DATA)\n        return QVariant(QMetaType::fromType<qlonglong>());\n\n    if (isSigned)\n        return qint64(lngbuf);\n    else\n        return quint64(lngbuf);\n}\n\nstatic bool isAutoValue(const SQLHANDLE hStmt, int column)\n{\n    SQLLEN nNumericAttribute = 0; // Check for auto-increment\n    const SQLRETURN r = ::SQLColAttribute(hStmt, column + 1, SQL_DESC_AUTO_UNIQUE_VALUE,\n                                          0, 0, 0, &nNumericAttribute);\n    if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO) {\n        qSqlWarning(QStringLiteral(\"qMakeField: Unable to get autovalue attribute for column \")\n                    + QString::number(column), hStmt);\n        return false;\n    }\n    return nNumericAttribute != SQL_FALSE;\n}\n\nstatic QSqlField qMakeFieldInfo(const SQLHANDLE hStmt, int i, QString *errorMessage);\n\n// creates a QSqlField from a valid hStmt generated\n// by SQLColumns. The hStmt has to point to a valid position.\nstatic QSqlField qMakeFieldInfo(const SQLHANDLE hStmt, const QODBCDriverPrivate* p)\n{\n    QString fname = qGetStringData(hStmt, 3, -1, p->unicode).toString();\n    int type = qGetIntData(hStmt, 4).toInt(); // column type\n    QSqlField f(fname, qDecodeODBCType(type, p));\n    QVariant var = qGetIntData(hStmt, 6);\n    f.setLength(var.isNull() ? -1 : var.toInt()); // column size\n    var = qGetIntData(hStmt, 8).toInt();\n    f.setPrecision(var.isNull() ? -1 : var.toInt()); // precision\n    f.setSqlType(type);\n    int required = qGetIntData(hStmt, 10).toInt(); // nullable-flag\n    // required can be SQL_NO_NULLS, SQL_NULLABLE or SQL_NULLABLE_UNKNOWN\n    if (required == SQL_NO_NULLS)\n        f.setRequired(true);\n    else if (required == SQL_NULLABLE)\n        f.setRequired(false);\n    // else we don't know\n    return f;\n}\n\nstatic QSqlField qMakeFieldInfo(const QODBCResultPrivate* p, int i )\n{\n    QString errorMessage;\n    const QSqlField result = qMakeFieldInfo(p->hStmt, i, &errorMessage);\n    if (!errorMessage.isEmpty())\n        qSqlWarning(errorMessage, p);\n    return result;\n}\n\nstatic QSqlField qMakeFieldInfo(const SQLHANDLE hStmt, int i, QString *errorMessage)\n{\n    SQLSMALLINT colNameLen;\n    SQLSMALLINT colType;\n    SQLULEN colSize;\n    SQLSMALLINT colScale;\n    SQLSMALLINT nullable;\n    SQLRETURN r = SQL_ERROR;\n    QVarLengthArray<SQLTCHAR> colName(COLNAMESIZE);\n    errorMessage->clear();\n    r = SQLDescribeCol(hStmt,\n                        i+1,\n                        colName.data(),\n                        (SQLSMALLINT)COLNAMESIZE,\n                        &colNameLen,\n                        &colType,\n                        &colSize,\n                        &colScale,\n                        &nullable);\n\n    if (r != SQL_SUCCESS) {\n        *errorMessage = QStringLiteral(\"qMakeField: Unable to describe column \") + QString::number(i);\n        return QSqlField();\n    }\n\n    SQLLEN unsignedFlag = SQL_FALSE;\n    r = SQLColAttribute (hStmt,\n                         i + 1,\n                         SQL_DESC_UNSIGNED,\n                         0,\n                         0,\n                         0,\n                         &unsignedFlag);\n    if (r != SQL_SUCCESS) {\n        qSqlWarning(QStringLiteral(\"qMakeField: Unable to get column attributes for column \")\n                    + QString::number(i), hStmt);\n    }\n\n    const QString qColName(fromSQLTCHAR(colName, colNameLen));\n    // nullable can be SQL_NO_NULLS, SQL_NULLABLE or SQL_NULLABLE_UNKNOWN\n    QMetaType type = qDecodeODBCType(colType, unsignedFlag == SQL_FALSE);\n    QSqlField f(qColName, type);\n    f.setSqlType(colType);\n    f.setLength(colSize == 0 ? -1 : int(colSize));\n    f.setPrecision(colScale == 0 ? -1 : int(colScale));\n    if (nullable == SQL_NO_NULLS)\n        f.setRequired(true);\n    else if (nullable == SQL_NULLABLE)\n        f.setRequired(false);\n    // else we don't know\n    f.setAutoValue(isAutoValue(hStmt, i));\n    QVarLengthArray<SQLTCHAR> tableName(TABLENAMESIZE);\n    SQLSMALLINT tableNameLen;\n    r = SQLColAttribute(hStmt, i + 1, SQL_DESC_BASE_TABLE_NAME, tableName.data(),\n                        TABLENAMESIZE, &tableNameLen, 0);\n    if (r == SQL_SUCCESS)\n        f.setTableName(fromSQLTCHAR(tableName, tableNameLen));\n    return f;\n}\n\nstatic size_t qGetODBCVersion(const QString &connOpts)\n{\n    if (connOpts.contains(\"SQL_ATTR_ODBC_VERSION=SQL_OV_ODBC3\"_L1, Qt::CaseInsensitive))\n        return SQL_OV_ODBC3;\n    return SQL_OV_ODBC2;\n}\n\nQChar QODBCDriverPrivate::quoteChar()\n{\n    if (!isQuoteInitialized) {\n        SQLTCHAR driverResponse[4];\n        SQLSMALLINT length;\n        int r = SQLGetInfo(hDbc,\n                SQL_IDENTIFIER_QUOTE_CHAR,\n                &driverResponse,\n                sizeof(driverResponse),\n                &length);\n        if (r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO)\n            quote = QChar(driverResponse[0]);\n        else\n            quote = u'\"';\n        isQuoteInitialized = true;\n    }\n    return quote;\n}\n\nstatic SQLRETURN qt_string_SQLSetConnectAttr(SQLHDBC handle, SQLINTEGER attr, const QString &val)\n{\n    auto encoded = toSQLTCHAR(val);\n    return SQLSetConnectAttr(handle, attr,\n                             encoded.data(),\n                             SQLINTEGER(encoded.size() * sizeof(SQLTCHAR))); // size in bytes\n}\n\n\nbool QODBCDriverPrivate::setConnectionOptions(const QString& connOpts)\n{\n    // Set any connection attributes\n    const QStringList opts(connOpts.split(u';', Qt::SkipEmptyParts));\n    SQLRETURN r = SQL_SUCCESS;\n    for (int i = 0; i < opts.count(); ++i) {\n        const QString tmp(opts.at(i));\n        int idx;\n        if ((idx = tmp.indexOf(u'=')) == -1) {\n            qWarning() << \"QODBCDriver::open: Illegal connect option value '\" << tmp << '\\'';\n            continue;\n        }\n        const QString opt(tmp.left(idx));\n        const QString val(tmp.mid(idx + 1).simplified());\n        SQLUINTEGER v = 0;\n\n        r = SQL_SUCCESS;\n        if (opt.toUpper() == \"SQL_ATTR_ACCESS_MODE\"_L1) {\n            if (val.toUpper() == \"SQL_MODE_READ_ONLY\"_L1) {\n                v = SQL_MODE_READ_ONLY;\n            } else if (val.toUpper() == \"SQL_MODE_READ_WRITE\"_L1) {\n                v = SQL_MODE_READ_WRITE;\n            } else {\n                qWarning() << \"QODBCDriver::open: Unknown option value '\" << val << '\\'';\n                continue;\n            }\n            r = SQLSetConnectAttr(hDbc, SQL_ATTR_ACCESS_MODE, (SQLPOINTER) size_t(v), 0);\n        } else if (opt.toUpper() == \"SQL_ATTR_CONNECTION_TIMEOUT\"_L1) {\n            v = val.toUInt();\n            r = SQLSetConnectAttr(hDbc, SQL_ATTR_CONNECTION_TIMEOUT, (SQLPOINTER) size_t(v), 0);\n        } else if (opt.toUpper() == \"SQL_ATTR_LOGIN_TIMEOUT\"_L1) {\n            v = val.toUInt();\n            r = SQLSetConnectAttr(hDbc, SQL_ATTR_LOGIN_TIMEOUT, (SQLPOINTER) size_t(v), 0);\n        } else if (opt.toUpper() == \"SQL_ATTR_CURRENT_CATALOG\"_L1) {\n            r = qt_string_SQLSetConnectAttr(hDbc, SQL_ATTR_CURRENT_CATALOG, val);\n        } else if (opt.toUpper() == \"SQL_ATTR_METADATA_ID\"_L1) {\n            if (val.toUpper() == \"SQL_TRUE\"_L1) {\n                v = SQL_TRUE;\n            } else if (val.toUpper() == \"SQL_FALSE\"_L1) {\n                v = SQL_FALSE;\n            } else {\n                qWarning() << \"QODBCDriver::open: Unknown option value '\" << val << '\\'';\n                continue;\n            }\n            r = SQLSetConnectAttr(hDbc, SQL_ATTR_METADATA_ID, (SQLPOINTER) size_t(v), 0);\n        } else if (opt.toUpper() == \"SQL_ATTR_PACKET_SIZE\"_L1) {\n            v = val.toUInt();\n            r = SQLSetConnectAttr(hDbc, SQL_ATTR_PACKET_SIZE, (SQLPOINTER) size_t(v), 0);\n        } else if (opt.toUpper() == \"SQL_ATTR_TRACEFILE\"_L1) {\n            r = qt_string_SQLSetConnectAttr(hDbc, SQL_ATTR_TRACEFILE, val);\n        } else if (opt.toUpper() == \"SQL_ATTR_TRACE\"_L1) {\n            if (val.toUpper() == \"SQL_OPT_TRACE_OFF\"_L1) {\n                v = SQL_OPT_TRACE_OFF;\n            } else if (val.toUpper() == \"SQL_OPT_TRACE_ON\"_L1) {\n                v = SQL_OPT_TRACE_ON;\n            } else {\n                qWarning() << \"QODBCDriver::open: Unknown option value '\" << val << '\\'';\n                continue;\n            }\n            r = SQLSetConnectAttr(hDbc, SQL_ATTR_TRACE, (SQLPOINTER) size_t(v), 0);\n        } else if (opt.toUpper() == \"SQL_ATTR_CONNECTION_POOLING\"_L1) {\n            if (val == \"SQL_CP_OFF\"_L1)\n                v = SQL_CP_OFF;\n            else if (val.toUpper() == \"SQL_CP_ONE_PER_DRIVER\"_L1)\n                v = SQL_CP_ONE_PER_DRIVER;\n            else if (val.toUpper() == \"SQL_CP_ONE_PER_HENV\"_L1)\n                v = SQL_CP_ONE_PER_HENV;\n            else if (val.toUpper() == \"SQL_CP_DEFAULT\"_L1)\n                v = SQL_CP_DEFAULT;\n            else {\n                qWarning() << \"QODBCDriver::open: Unknown option value '\" << val << '\\'';\n                continue;\n            }\n            r = SQLSetConnectAttr(hDbc, SQL_ATTR_CONNECTION_POOLING, (SQLPOINTER) size_t(v), 0);\n        } else if (opt.toUpper() == \"SQL_ATTR_CP_MATCH\"_L1) {\n            if (val.toUpper() == \"SQL_CP_STRICT_MATCH\"_L1)\n                v = SQL_CP_STRICT_MATCH;\n            else if (val.toUpper() == \"SQL_CP_RELAXED_MATCH\"_L1)\n                v = SQL_CP_RELAXED_MATCH;\n            else if (val.toUpper() == \"SQL_CP_MATCH_DEFAULT\"_L1)\n                v = SQL_CP_MATCH_DEFAULT;\n            else {\n                qWarning() << \"QODBCDriver::open: Unknown option value '\" << val << '\\'';\n                continue;\n            }\n            r = SQLSetConnectAttr(hDbc, SQL_ATTR_CP_MATCH, (SQLPOINTER) size_t(v), 0);\n        } else if (opt.toUpper() == \"SQL_ATTR_ODBC_VERSION\"_L1) {\n            // Already handled in QODBCDriver::open()\n            continue;\n        } else {\n                qWarning() << \"QODBCDriver::open: Unknown connection attribute '\" << opt << '\\'';\n        }\n        if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO)\n            qSqlWarning(QString::fromLatin1(\"QODBCDriver::open: Unable to set connection attribute'%1'\").arg(\n                        opt), this);\n    }\n    return true;\n}\n\nvoid QODBCDriverPrivate::splitTableQualifier(const QString & qualifier, QString &catalog,\n                                       QString &schema, QString &table)\n{\n    if (!useSchema) {\n        table = qualifier;\n        return;\n    }\n    QStringList l = qualifier.split(u'.');\n    if (l.count() > 3)\n        return; // can't possibly be a valid table qualifier\n    int i = 0, n = l.count();\n    if (n == 1) {\n        table = qualifier;\n    } else {\n        for (QStringList::Iterator it = l.begin(); it != l.end(); ++it) {\n            if (n == 3) {\n                if (i == 0) {\n                    catalog = *it;\n                } else if (i == 1) {\n                    schema = *it;\n                } else if (i == 2) {\n                    table = *it;\n                }\n            } else if (n == 2) {\n                if (i == 0) {\n                    schema = *it;\n                } else if (i == 1) {\n                    table = *it;\n                }\n            }\n            i++;\n        }\n    }\n}\n\nQODBCDriverPrivate::DefaultCase QODBCDriverPrivate::defaultCase() const\n{\n    DefaultCase ret;\n    SQLUSMALLINT casing;\n    int r = SQLGetInfo(hDbc,\n            SQL_IDENTIFIER_CASE,\n            &casing,\n            sizeof(casing),\n            NULL);\n    if ( r != SQL_SUCCESS)\n        ret = Mixed;//arbitrary case if driver cannot be queried\n    else {\n        switch (casing) {\n            case (SQL_IC_UPPER):\n                ret = Upper;\n                break;\n            case (SQL_IC_LOWER):\n                ret = Lower;\n                break;\n            case (SQL_IC_SENSITIVE):\n                ret = Sensitive;\n                break;\n            case (SQL_IC_MIXED):\n            default:\n                ret = Mixed;\n                break;\n        }\n    }\n    return ret;\n}\n\n/*\n   Adjust the casing of an identifier to match what the\n   database engine would have done to it.\n*/\nQString QODBCDriverPrivate::adjustCase(const QString &identifier) const\n{\n    QString ret = identifier;\n    switch(defaultCase()) {\n        case (Lower):\n            ret = identifier.toLower();\n            break;\n        case (Upper):\n            ret = identifier.toUpper();\n            break;\n        case(Mixed):\n        case(Sensitive):\n        default:\n            ret = identifier;\n    }\n    return ret;\n}\n\n////////////////////////////////////////////////////////////////////////////\n\nQODBCResult::QODBCResult(const QODBCDriver *db)\n    : QSqlResult(*new QODBCResultPrivate(this, db))\n{\n}\n\nQODBCResult::~QODBCResult()\n{\n    Q_D(QODBCResult);\n    if (d->hStmt && d->isStmtHandleValid() && driver() && driver()->isOpen()) {\n        SQLRETURN r = SQLFreeHandle(SQL_HANDLE_STMT, d->hStmt);\n        if (r != SQL_SUCCESS)\n            qSqlWarning(\"QODBCDriver: Unable to free statement handle \"_L1\n                         + QString::number(r), d);\n    }\n}\n\nbool QODBCResult::reset (const QString& query)\n{\n    Q_D(QODBCResult);\n    setActive(false);\n    setAt(QSql::BeforeFirstRow);\n    d->rInf.clear();\n    d->fieldCache.clear();\n    d->fieldCacheIdx = 0;\n\n    // Always reallocate the statement handle - the statement attributes\n    // are not reset if SQLFreeStmt() is called which causes some problems.\n    SQLRETURN r;\n    if (d->hStmt && d->isStmtHandleValid()) {\n        r = SQLFreeHandle(SQL_HANDLE_STMT, d->hStmt);\n        if (r != SQL_SUCCESS) {\n            qSqlWarning(\"QODBCResult::reset: Unable to free statement handle\"_L1, d);\n            return false;\n        }\n    }\n    r  = SQLAllocHandle(SQL_HANDLE_STMT,\n                         d->dpDbc(),\n                         &d->hStmt);\n    if (r != SQL_SUCCESS) {\n        qSqlWarning(\"QODBCResult::reset: Unable to allocate statement handle\"_L1, d);\n        return false;\n    }\n\n    d->updateStmtHandleState();\n\n    if (isForwardOnly()) {\n        r = SQLSetStmtAttr(d->hStmt,\n                            SQL_ATTR_CURSOR_TYPE,\n                            (SQLPOINTER)SQL_CURSOR_FORWARD_ONLY,\n                            SQL_IS_UINTEGER);\n    } else {\n        r = SQLSetStmtAttr(d->hStmt,\n                            SQL_ATTR_CURSOR_TYPE,\n                            (SQLPOINTER)SQL_CURSOR_STATIC,\n                            SQL_IS_UINTEGER);\n    }\n    if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO) {\n        setLastError(qMakeError(QCoreApplication::translate(\"QODBCResult\",\n            \"QODBCResult::reset: Unable to set 'SQL_CURSOR_STATIC' as statement attribute. \"\n            \"Please check your ODBC driver configuration\"), QSqlError::StatementError, d));\n        return false;\n    }\n\n    {\n        auto encoded = toSQLTCHAR(query);\n        r = SQLExecDirect(d->hStmt,\n                          encoded.data(),\n                          SQLINTEGER(encoded.size()));\n    }\n    if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO && r!= SQL_NO_DATA) {\n        setLastError(qMakeError(QCoreApplication::translate(\"QODBCResult\",\n                     \"Unable to execute statement\"), QSqlError::StatementError, d));\n        return false;\n    }\n\n    SQLULEN isScrollable = 0;\n    r = SQLGetStmtAttr(d->hStmt, SQL_ATTR_CURSOR_SCROLLABLE, &isScrollable, SQL_IS_INTEGER, 0);\n    if (r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO)\n        setForwardOnly(isScrollable == SQL_NONSCROLLABLE);\n\n    SQLSMALLINT count = 0;\n    SQLNumResultCols(d->hStmt, &count);\n    if (count) {\n        setSelect(true);\n        for (int i = 0; i < count; ++i) {\n            d->rInf.append(qMakeFieldInfo(d, i));\n        }\n        d->fieldCache.resize(count);\n    } else {\n        setSelect(false);\n    }\n    setActive(true);\n\n    return true;\n}\n\nbool QODBCResult::fetch(int i)\n{\n    Q_D(QODBCResult);\n    if (!driver()->isOpen())\n        return false;\n\n    if (isForwardOnly() && i < at())\n        return false;\n    if (i == at())\n        return true;\n    d->clearValues();\n    int actualIdx = i + 1;\n    if (actualIdx <= 0) {\n        setAt(QSql::BeforeFirstRow);\n        return false;\n    }\n    SQLRETURN r;\n    if (isForwardOnly()) {\n        bool ok = true;\n        while (ok && i > at())\n            ok = fetchNext();\n        return ok;\n    } else {\n        r = SQLFetchScroll(d->hStmt,\n                            SQL_FETCH_ABSOLUTE,\n                            actualIdx);\n    }\n    if (r != SQL_SUCCESS) {\n        if (r != SQL_NO_DATA)\n            setLastError(qMakeError(QCoreApplication::translate(\"QODBCResult\",\n                \"Unable to fetch\"), QSqlError::ConnectionError, d));\n        return false;\n    }\n    setAt(i);\n    return true;\n}\n\nbool QODBCResult::fetchNext()\n{\n    Q_D(QODBCResult);\n    SQLRETURN r;\n    d->clearValues();\n\n    if (d->hasSQLFetchScroll)\n        r = SQLFetchScroll(d->hStmt,\n                           SQL_FETCH_NEXT,\n                           0);\n    else\n        r = SQLFetch(d->hStmt);\n\n    if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO) {\n        if (r != SQL_NO_DATA)\n            setLastError(qMakeError(QCoreApplication::translate(\"QODBCResult\",\n                \"Unable to fetch next\"), QSqlError::ConnectionError, d));\n        return false;\n    }\n    setAt(at() + 1);\n    return true;\n}\n\nbool QODBCResult::fetchFirst()\n{\n    Q_D(QODBCResult);\n    if (isForwardOnly() && at() != QSql::BeforeFirstRow)\n        return false;\n    SQLRETURN r;\n    d->clearValues();\n    if (isForwardOnly()) {\n        return fetchNext();\n    }\n    r = SQLFetchScroll(d->hStmt,\n                       SQL_FETCH_FIRST,\n                       0);\n    if (r != SQL_SUCCESS) {\n        if (r != SQL_NO_DATA)\n            setLastError(qMakeError(QCoreApplication::translate(\"QODBCResult\",\n                \"Unable to fetch first\"), QSqlError::ConnectionError, d));\n        return false;\n    }\n    setAt(0);\n    return true;\n}\n\nbool QODBCResult::fetchPrevious()\n{\n    Q_D(QODBCResult);\n    if (isForwardOnly())\n        return false;\n    SQLRETURN r;\n    d->clearValues();\n    r = SQLFetchScroll(d->hStmt,\n                       SQL_FETCH_PRIOR,\n                       0);\n    if (r != SQL_SUCCESS) {\n        if (r != SQL_NO_DATA)\n            setLastError(qMakeError(QCoreApplication::translate(\"QODBCResult\",\n                \"Unable to fetch previous\"), QSqlError::ConnectionError, d));\n        return false;\n    }\n    setAt(at() - 1);\n    return true;\n}\n\nbool QODBCResult::fetchLast()\n{\n    Q_D(QODBCResult);\n    SQLRETURN r;\n    d->clearValues();\n\n    if (isForwardOnly()) {\n        // cannot seek to last row in forwardOnly mode, so we have to use brute force\n        int i = at();\n        if (i == QSql::AfterLastRow)\n            return false;\n        if (i == QSql::BeforeFirstRow)\n            i = 0;\n        while (fetchNext())\n            ++i;\n        setAt(i);\n        return true;\n    }\n\n    r = SQLFetchScroll(d->hStmt,\n                       SQL_FETCH_LAST,\n                       0);\n    if (r != SQL_SUCCESS) {\n        if (r != SQL_NO_DATA)\n            setLastError(qMakeError(QCoreApplication::translate(\"QODBCResult\",\n                \"Unable to fetch last\"), QSqlError::ConnectionError, d));\n        return false;\n    }\n    SQLULEN currRow = 0;\n    r = SQLGetStmtAttr(d->hStmt,\n                        SQL_ROW_NUMBER,\n                        &currRow,\n                        SQL_IS_INTEGER,\n                        0);\n    if (r != SQL_SUCCESS)\n        return false;\n    setAt(currRow-1);\n    return true;\n}\n\nQVariant QODBCResult::data(int field)\n{\n    Q_D(QODBCResult);\n    if (field >= d->rInf.count() || field < 0) {\n        qWarning() << \"QODBCResult::data: column\" << field << \"out of range\";\n        return QVariant();\n    }\n    if (field < d->fieldCacheIdx)\n        return d->fieldCache.at(field);\n\n    SQLRETURN r(0);\n    SQLLEN lengthIndicator = 0;\n\n    for (int i = d->fieldCacheIdx; i <= field; ++i) {\n        // some servers do not support fetching column n after we already\n        // fetched column n+1, so cache all previous columns here\n        const QSqlField info = d->rInf.field(i);\n        switch (info.metaType().id()) {\n        case QMetaType::LongLong:\n            d->fieldCache[i] = qGetBigIntData(d->hStmt, i);\n        break;\n        case QMetaType::ULongLong:\n            d->fieldCache[i] = qGetBigIntData(d->hStmt, i, false);\n            break;\n        case QMetaType::Int:\n        case QMetaType::Short:\n            d->fieldCache[i] = qGetIntData(d->hStmt, i);\n            break;\n        case QMetaType::UInt:\n        case QMetaType::UShort:\n            d->fieldCache[i] = qGetIntData(d->hStmt, i, false);\n            break;\n        case QMetaType::QDate:\n            DATE_STRUCT dbuf;\n            r = SQLGetData(d->hStmt,\n                            i + 1,\n                            SQL_C_DATE,\n                            (SQLPOINTER)&dbuf,\n                            0,\n                            &lengthIndicator);\n            if ((r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO) && (lengthIndicator != SQL_NULL_DATA))\n                d->fieldCache[i] = QVariant(QDate(dbuf.year, dbuf.month, dbuf.day));\n            else\n                d->fieldCache[i] = QVariant(QMetaType::fromType<QDate>());\n        break;\n        case QMetaType::QTime:\n            TIME_STRUCT tbuf;\n            r = SQLGetData(d->hStmt,\n                            i + 1,\n                            SQL_C_TIME,\n                            (SQLPOINTER)&tbuf,\n                            0,\n                            &lengthIndicator);\n            if ((r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO) && (lengthIndicator != SQL_NULL_DATA))\n                d->fieldCache[i] = QVariant(QTime(tbuf.hour, tbuf.minute, tbuf.second));\n            else\n                d->fieldCache[i] = QVariant(QMetaType::fromType<QTime>());\n        break;\n        case QMetaType::QDateTime:\n            TIMESTAMP_STRUCT dtbuf;\n            r = SQLGetData(d->hStmt,\n                            i + 1,\n                            SQL_C_TIMESTAMP,\n                            (SQLPOINTER)&dtbuf,\n                            0,\n                            &lengthIndicator);\n            if ((r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO) && (lengthIndicator != SQL_NULL_DATA))\n                d->fieldCache[i] = QVariant(QDateTime(QDate(dtbuf.year, dtbuf.month, dtbuf.day),\n                       QTime(dtbuf.hour, dtbuf.minute, dtbuf.second, dtbuf.fraction / 1000000)));\n            else\n                d->fieldCache[i] = QVariant(QMetaType::fromType<QDateTime>());\n            break;\n        case QMetaType::QByteArray:\n            d->fieldCache[i] = qGetBinaryData(d->hStmt, i);\n            break;\n        case QMetaType::QString:\n            d->fieldCache[i] = qGetStringData(d->hStmt, i, info.length(), d->unicode);\n            break;\n        case QMetaType::Double:\n            switch(numericalPrecisionPolicy()) {\n                case QSql::LowPrecisionInt32:\n                    d->fieldCache[i] = qGetIntData(d->hStmt, i);\n                    break;\n                case QSql::LowPrecisionInt64:\n                    d->fieldCache[i] = qGetBigIntData(d->hStmt, i);\n                    break;\n                case QSql::LowPrecisionDouble:\n                    d->fieldCache[i] = qGetDoubleData(d->hStmt, i);\n                    break;\n                case QSql::HighPrecision:\n                    const int extra = info.precision() > 0 ? 1 : 0;\n                    d->fieldCache[i] = qGetStringData(d->hStmt, i, info.length() + extra, false);\n                    break;\n            }\n            break;\n        default:\n            d->fieldCache[i] = qGetStringData(d->hStmt, i, info.length(), false);\n            break;\n        }\n        d->fieldCacheIdx = field + 1;\n    }\n    return d->fieldCache[field];\n}\n\nbool QODBCResult::isNull(int field)\n{\n    Q_D(const QODBCResult);\n    if (field < 0 || field >= d->fieldCache.size())\n        return true;\n    if (field >= d->fieldCacheIdx) {\n        // since there is no good way to find out whether the value is NULL\n        // without fetching the field we'll fetch it here.\n        // (data() also sets the NULL flag)\n        data(field);\n    }\n    return d->fieldCache.at(field).isNull();\n}\n\nint QODBCResult::size()\n{\n    return -1;\n}\n\nint QODBCResult::numRowsAffected()\n{\n    Q_D(QODBCResult);\n    SQLLEN affectedRowCount = 0;\n    SQLRETURN r = SQLRowCount(d->hStmt, &affectedRowCount);\n    if (r == SQL_SUCCESS)\n        return affectedRowCount;\n    else\n        qSqlWarning(\"QODBCResult::numRowsAffected: Unable to count affected rows\"_L1, d);\n    return -1;\n}\n\nbool QODBCResult::prepare(const QString& query)\n{\n    Q_D(QODBCResult);\n    setActive(false);\n    setAt(QSql::BeforeFirstRow);\n    SQLRETURN r;\n\n    d->rInf.clear();\n    if (d->hStmt && d->isStmtHandleValid()) {\n        r = SQLFreeHandle(SQL_HANDLE_STMT, d->hStmt);\n        if (r != SQL_SUCCESS) {\n            qSqlWarning(\"QODBCResult::prepare: Unable to close statement\"_L1, d);\n            return false;\n        }\n    }\n    r  = SQLAllocHandle(SQL_HANDLE_STMT,\n                         d->dpDbc(),\n                         &d->hStmt);\n    if (r != SQL_SUCCESS) {\n        qSqlWarning(\"QODBCResult::prepare: Unable to allocate statement handle\"_L1, d);\n        return false;\n    }\n\n    d->updateStmtHandleState();\n\n    if (isForwardOnly()) {\n        r = SQLSetStmtAttr(d->hStmt,\n                            SQL_ATTR_CURSOR_TYPE,\n                            (SQLPOINTER)SQL_CURSOR_FORWARD_ONLY,\n                            SQL_IS_UINTEGER);\n    } else {\n        r = SQLSetStmtAttr(d->hStmt,\n                            SQL_ATTR_CURSOR_TYPE,\n                            (SQLPOINTER)SQL_CURSOR_STATIC,\n                            SQL_IS_UINTEGER);\n    }\n    if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO) {\n        setLastError(qMakeError(QCoreApplication::translate(\"QODBCResult\",\n            \"QODBCResult::reset: Unable to set 'SQL_CURSOR_STATIC' as statement attribute. \"\n            \"Please check your ODBC driver configuration\"), QSqlError::StatementError, d));\n        return false;\n    }\n\n    {\n        auto encoded = toSQLTCHAR(query);\n        r = SQLPrepare(d->hStmt,\n                       encoded.data(),\n                       SQLINTEGER(encoded.size()));\n    }\n\n    if (r != SQL_SUCCESS) {\n        setLastError(qMakeError(QCoreApplication::translate(\"QODBCResult\",\n                     \"Unable to prepare statement\"), QSqlError::StatementError, d));\n        return false;\n    }\n    return true;\n}\n\nbool QODBCResult::exec()\n{\n    Q_D(QODBCResult);\n    setActive(false);\n    setAt(QSql::BeforeFirstRow);\n    d->rInf.clear();\n    d->fieldCache.clear();\n    d->fieldCacheIdx = 0;\n\n    if (!d->hStmt) {\n        qSqlWarning(\"QODBCResult::exec: No statement handle available\"_L1, d);\n        return false;\n    }\n\n    if (isSelect())\n        SQLCloseCursor(d->hStmt);\n\n    QVariantList &values = boundValues();\n    QByteArrayList tmpStorage(values.count(), QByteArray()); // targets for SQLBindParameter()\n    QVarLengthArray<SQLLEN, 32> indicators(values.count());\n    memset(indicators.data(), 0, indicators.size() * sizeof(SQLLEN));\n\n    // bind parameters - only positional binding allowed\n    int i;\n    SQLRETURN r;\n    for (i = 0; i < values.count(); ++i) {\n        if (bindValueType(i) & QSql::Out)\n            values[i].detach();\n        const QVariant &val = values.at(i);\n        SQLLEN *ind = &indicators[i];\n        if (QSqlResultPrivate::isVariantNull(val))\n            *ind = SQL_NULL_DATA;\n        switch (val.typeId()) {\n            case QMetaType::QDate: {\n                QByteArray &ba = tmpStorage[i];\n                ba.resize(sizeof(DATE_STRUCT));\n                DATE_STRUCT *dt = (DATE_STRUCT *)const_cast<char *>(ba.constData());\n                QDate qdt = val.toDate();\n                dt->year = qdt.year();\n                dt->month = qdt.month();\n                dt->day = qdt.day();\n                r = SQLBindParameter(d->hStmt,\n                                      i + 1,\n                                      qParamType[bindValueType(i) & QSql::InOut],\n                                      SQL_C_DATE,\n                                      SQL_DATE,\n                                      0,\n                                      0,\n                                      (void *) dt,\n                                      0,\n                                      *ind == SQL_NULL_DATA ? ind : NULL);\n                break; }\n            case QMetaType::QTime: {\n                QByteArray &ba = tmpStorage[i];\n                ba.resize(sizeof(TIME_STRUCT));\n                TIME_STRUCT *dt = (TIME_STRUCT *)const_cast<char *>(ba.constData());\n                QTime qdt = val.toTime();\n                dt->hour = qdt.hour();\n                dt->minute = qdt.minute();\n                dt->second = qdt.second();\n                r = SQLBindParameter(d->hStmt,\n                                      i + 1,\n                                      qParamType[bindValueType(i) & QSql::InOut],\n                                      SQL_C_TIME,\n                                      SQL_TIME,\n                                      0,\n                                      0,\n                                      (void *) dt,\n                                      0,\n                                      *ind == SQL_NULL_DATA ? ind : NULL);\n                break; }\n            case QMetaType::QDateTime: {\n                QByteArray &ba = tmpStorage[i];\n                ba.resize(sizeof(TIMESTAMP_STRUCT));\n                TIMESTAMP_STRUCT *dt = reinterpret_cast<TIMESTAMP_STRUCT *>(const_cast<char *>(ba.constData()));\n                const QDateTime qdt = val.toDateTime();\n                const QDate qdate = qdt.date();\n                const QTime qtime = qdt.time();\n                dt->year = qdate.year();\n                dt->month = qdate.month();\n                dt->day = qdate.day();\n                dt->hour = qtime.hour();\n                dt->minute = qtime.minute();\n                dt->second = qtime.second();\n                // (20 includes a separating period)\n                const int precision = d->drv_d_func()->datetimePrecision - 20;\n                if (precision <= 0) {\n                    dt->fraction = 0;\n                } else {\n                    dt->fraction = qtime.msec() * 1000000;\n\n                    // (How many leading digits do we want to keep?  With SQL Server 2005, this should be 3: 123000000)\n                    int keep = (int)qPow(10.0, 9 - qMin(9, precision));\n                    dt->fraction = (dt->fraction / keep) * keep;\n                }\n\n                r = SQLBindParameter(d->hStmt,\n                                      i + 1,\n                                      qParamType[bindValueType(i) & QSql::InOut],\n                                      SQL_C_TIMESTAMP,\n                                      SQL_TIMESTAMP,\n                                      d->drv_d_func()->datetimePrecision,\n                                      precision,\n                                      (void *) dt,\n                                      0,\n                                      *ind == SQL_NULL_DATA ? ind : NULL);\n                break; }\n            case QMetaType::Int:\n                r = SQLBindParameter(d->hStmt,\n                                      i + 1,\n                                      qParamType[bindValueType(i) & QSql::InOut],\n                                      SQL_C_SLONG,\n                                      SQL_INTEGER,\n                                      0,\n                                      0,\n                                      const_cast<void *>(val.constData()),\n                                      0,\n                                      *ind == SQL_NULL_DATA ? ind : NULL);\n                break;\n            case QMetaType::UInt:\n                r = SQLBindParameter(d->hStmt,\n                                      i + 1,\n                                      qParamType[bindValueType(i) & QSql::InOut],\n                                      SQL_C_ULONG,\n                                      SQL_NUMERIC,\n                                      15,\n                                      0,\n                                      const_cast<void *>(val.constData()),\n                                      0,\n                                      *ind == SQL_NULL_DATA ? ind : NULL);\n                break;\n            case QMetaType::Short:\n                r = SQLBindParameter(d->hStmt,\n                                      i + 1,\n                                      qParamType[bindValueType(i) & QSql::InOut],\n                                      SQL_C_SSHORT,\n                                      SQL_SMALLINT,\n                                      0,\n                                      0,\n                                      const_cast<void *>(val.constData()),\n                                      0,\n                                      *ind == SQL_NULL_DATA ? ind : NULL);\n                break;\n            case QMetaType::UShort:\n                r = SQLBindParameter(d->hStmt,\n                                      i + 1,\n                                      qParamType[bindValueType(i) & QSql::InOut],\n                                      SQL_C_USHORT,\n                                      SQL_NUMERIC,\n                                      15,\n                                      0,\n                                      const_cast<void *>(val.constData()),\n                                      0,\n                                      *ind == SQL_NULL_DATA ? ind : NULL);\n                break;\n            case QMetaType::Double:\n                r = SQLBindParameter(d->hStmt,\n                                      i + 1,\n                                      qParamType[bindValueType(i) & QSql::InOut],\n                                      SQL_C_DOUBLE,\n                                      SQL_DOUBLE,\n                                      0,\n                                      0,\n                                      const_cast<void *>(val.constData()),\n                                      0,\n                                      *ind == SQL_NULL_DATA ? ind : NULL);\n                break;\n            case QMetaType::Float:\n                r = SQLBindParameter(d->hStmt,\n                                      i + 1,\n                                      qParamType[bindValueType(i) & QSql::InOut],\n                                      SQL_C_FLOAT,\n                                      SQL_REAL,\n                                      0,\n                                      0,\n                                      const_cast<void *>(val.constData()),\n                                      0,\n                                      *ind == SQL_NULL_DATA ? ind : NULL);\n                break;\n            case QMetaType::LongLong:\n                r = SQLBindParameter(d->hStmt,\n                                      i + 1,\n                                      qParamType[bindValueType(i) & QSql::InOut],\n                                      SQL_C_SBIGINT,\n                                      SQL_BIGINT,\n                                      0,\n                                      0,\n                                      const_cast<void *>(val.constData()),\n                                      0,\n                                      *ind == SQL_NULL_DATA ? ind : NULL);\n                break;\n            case QMetaType::ULongLong:\n                r = SQLBindParameter(d->hStmt,\n                                      i + 1,\n                                      qParamType[bindValueType(i) & QSql::InOut],\n                                      SQL_C_UBIGINT,\n                                      SQL_BIGINT,\n                                      0,\n                                      0,\n                                      const_cast<void *>(val.constData()),\n                                      0,\n                                      *ind == SQL_NULL_DATA ? ind : NULL);\n                break;\n            case QMetaType::QByteArray:\n                if (*ind != SQL_NULL_DATA) {\n                    *ind = val.toByteArray().size();\n                }\n                r = SQLBindParameter(d->hStmt,\n                                      i + 1,\n                                      qParamType[bindValueType(i) & QSql::InOut],\n                                      SQL_C_BINARY,\n                                      SQL_LONGVARBINARY,\n                                      val.toByteArray().size(),\n                                      0,\n                                      const_cast<char *>(val.toByteArray().constData()),\n                                      val.toByteArray().size(),\n                                      ind);\n                break;\n            case QMetaType::Bool:\n                r = SQLBindParameter(d->hStmt,\n                                      i + 1,\n                                      qParamType[bindValueType(i) & QSql::InOut],\n                                      SQL_C_BIT,\n                                      SQL_BIT,\n                                      0,\n                                      0,\n                                      const_cast<void *>(val.constData()),\n                                      0,\n                                      *ind == SQL_NULL_DATA ? ind : NULL);\n                break;\n            case QMetaType::QString:\n                if (d->unicode) {\n                    QByteArray &ba = tmpStorage[i];\n                    {\n                        const auto encoded = toSQLTCHAR(val.toString());\n                        ba = QByteArray(reinterpret_cast<const char *>(encoded.data()),\n                                        encoded.size() * sizeof(SQLTCHAR));\n                    }\n\n                    if (*ind != SQL_NULL_DATA)\n                        *ind = ba.size();\n\n                    if (bindValueType(i) & QSql::Out) {\n                        r = SQLBindParameter(d->hStmt,\n                                            i + 1,\n                                            qParamType[bindValueType(i) & QSql::InOut],\n                                            SQL_C_TCHAR,\n                                            ba.size() > 254 ? SQL_WLONGVARCHAR : SQL_WVARCHAR,\n                                            0, // god knows... don't change this!\n                                            0,\n                                            const_cast<char *>(ba.constData()), // don't detach\n                                            ba.size(),\n                                            ind);\n                        break;\n                    }\n                    r = SQLBindParameter(d->hStmt,\n                                          i + 1,\n                                          qParamType[bindValueType(i) & QSql::InOut],\n                                          SQL_C_TCHAR,\n                                          ba.size() > 254 ? SQL_WLONGVARCHAR : SQL_WVARCHAR,\n                                          ba.size(),\n                                          0,\n                                          const_cast<char *>(ba.constData()), // don't detach\n                                          ba.size(),\n                                          ind);\n                    break;\n                }\n                else\n                {\n                    QByteArray &str = tmpStorage[i];\n                    str = val.toString().toUtf8();\n                    if (*ind != SQL_NULL_DATA)\n                        *ind = str.length();\n                    int strSize = str.length();\n\n                    r = SQLBindParameter(d->hStmt,\n                                          i + 1,\n                                          qParamType[bindValueType(i) & QSql::InOut],\n                                          SQL_C_CHAR,\n                                          strSize > 254 ? SQL_LONGVARCHAR : SQL_VARCHAR,\n                                          strSize,\n                                          0,\n                                          const_cast<char *>(str.constData()),\n                                          strSize,\n                                          ind);\n                    break;\n                }\n            Q_FALLTHROUGH();\n            default: {\n                QByteArray &ba = tmpStorage[i];\n                if (*ind != SQL_NULL_DATA)\n                    *ind = ba.size();\n                r = SQLBindParameter(d->hStmt,\n                                      i + 1,\n                                      qParamType[bindValueType(i) & QSql::InOut],\n                                      SQL_C_BINARY,\n                                      SQL_VARBINARY,\n                                      ba.length() + 1,\n                                      0,\n                                      const_cast<char *>(ba.constData()),\n                                      ba.length() + 1,\n                                      ind);\n                break; }\n        }\n        if (r != SQL_SUCCESS) {\n            qWarning() << \"QODBCResult::exec: unable to bind variable:\" << qODBCWarn(d);\n            setLastError(qMakeError(QCoreApplication::translate(\"QODBCResult\",\n                         \"Unable to bind variable\"), QSqlError::StatementError, d));\n            return false;\n        }\n    }\n    r = SQLExecute(d->hStmt);\n    if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO && r != SQL_NO_DATA) {\n        qWarning() << \"QODBCResult::exec: Unable to execute statement:\" << qODBCWarn(d);\n        setLastError(qMakeError(QCoreApplication::translate(\"QODBCResult\",\n                     \"Unable to execute statement\"), QSqlError::StatementError, d));\n        return false;\n    }\n\n    SQLULEN isScrollable = 0;\n    r = SQLGetStmtAttr(d->hStmt, SQL_ATTR_CURSOR_SCROLLABLE, &isScrollable, SQL_IS_INTEGER, 0);\n    if (r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO)\n        setForwardOnly(isScrollable == SQL_NONSCROLLABLE);\n\n    SQLSMALLINT count = 0;\n    SQLNumResultCols(d->hStmt, &count);\n    if (count) {\n        setSelect(true);\n        for (int i = 0; i < count; ++i) {\n            d->rInf.append(qMakeFieldInfo(d, i));\n        }\n        d->fieldCache.resize(count);\n    } else {\n        setSelect(false);\n    }\n    setActive(true);\n\n\n    //get out parameters\n    if (!hasOutValues())\n        return true;\n\n    for (i = 0; i < values.count(); ++i) {\n        switch (values.at(i).typeId()) {\n            case QMetaType::QDate: {\n                DATE_STRUCT ds = *((DATE_STRUCT *)const_cast<char *>(tmpStorage.at(i).constData()));\n                values[i] = QVariant(QDate(ds.year, ds.month, ds.day));\n                break; }\n            case QMetaType::QTime: {\n                TIME_STRUCT dt = *((TIME_STRUCT *)const_cast<char *>(tmpStorage.at(i).constData()));\n                values[i] = QVariant(QTime(dt.hour, dt.minute, dt.second));\n                break; }\n            case QMetaType::QDateTime: {\n                TIMESTAMP_STRUCT dt = *((TIMESTAMP_STRUCT*)\n                                        const_cast<char *>(tmpStorage.at(i).constData()));\n                values[i] = QVariant(QDateTime(QDate(dt.year, dt.month, dt.day),\n                               QTime(dt.hour, dt.minute, dt.second, dt.fraction / 1000000)));\n                break; }\n            case QMetaType::Bool:\n            case QMetaType::Short:\n            case QMetaType::UShort:\n            case QMetaType::Int:\n            case QMetaType::UInt:\n            case QMetaType::Float:\n            case QMetaType::Double:\n            case QMetaType::QByteArray:\n            case QMetaType::LongLong:\n            case QMetaType::ULongLong:\n                //nothing to do\n                break;\n            case QMetaType::QString:\n                if (d->unicode) {\n                    if (bindValueType(i) & QSql::Out) {\n                        const QByteArray &bytes = tmpStorage.at(i);\n                        const auto strSize = bytes.size() / sizeof(SQLTCHAR);\n                        QVarLengthArray<SQLTCHAR> string(strSize);\n                        memcpy(string.data(), bytes.data(), strSize * sizeof(SQLTCHAR));\n                        values[i] = fromSQLTCHAR(string);\n                    }\n                    break;\n                }\n                Q_FALLTHROUGH();\n            default: {\n                if (bindValueType(i) & QSql::Out)\n                    values[i] = tmpStorage.at(i);\n                break; }\n        }\n        if (indicators[i] == SQL_NULL_DATA)\n            values[i] = QVariant(values[i].metaType());\n    }\n    return true;\n}\n\nQSqlRecord QODBCResult::record() const\n{\n    Q_D(const QODBCResult);\n    if (!isActive() || !isSelect())\n        return QSqlRecord();\n    return d->rInf;\n}\n\nQVariant QODBCResult::lastInsertId() const\n{\n    Q_D(const QODBCResult);\n    QString sql;\n\n    switch (driver()->dbmsType()) {\n    case QSqlDriver::MSSqlServer:\n    case QSqlDriver::Sybase:\n        sql = \"SELECT @@IDENTITY;\"_L1;\n        break;\n    case QSqlDriver::MySqlServer:\n        sql = \"SELECT LAST_INSERT_ID();\"_L1;\n        break;\n    case QSqlDriver::PostgreSQL:\n        sql = \"SELECT lastval();\"_L1;\n        break;\n    default:\n        break;\n    }\n\n    if (!sql.isEmpty()) {\n        QSqlQuery qry(driver()->createResult());\n        if (qry.exec(sql) && qry.next())\n            return qry.value(0);\n\n        qSqlWarning(\"QODBCResult::lastInsertId: Unable to get lastInsertId\"_L1, d);\n    } else {\n        qSqlWarning(\"QODBCResult::lastInsertId: not implemented for this DBMS\"_L1, d);\n    }\n\n    return QVariant();\n}\n\nQVariant QODBCResult::handle() const\n{\n    Q_D(const QODBCResult);\n    return QVariant(QMetaType::fromType<SQLHANDLE>(), &d->hStmt);\n}\n\nbool QODBCResult::nextResult()\n{\n    Q_D(QODBCResult);\n    setActive(false);\n    setAt(QSql::BeforeFirstRow);\n    d->rInf.clear();\n    d->fieldCache.clear();\n    d->fieldCacheIdx = 0;\n    setSelect(false);\n\n    SQLRETURN r = SQLMoreResults(d->hStmt);\n    if (r != SQL_SUCCESS) {\n        if (r == SQL_SUCCESS_WITH_INFO) {\n            int nativeCode = -1;\n            QString message = qODBCWarn(d, &nativeCode);\n            qWarning() << \"QODBCResult::nextResult():\" << message;\n        } else {\n            if (r != SQL_NO_DATA)\n                setLastError(qMakeError(QCoreApplication::translate(\"QODBCResult\",\n                    \"Unable to fetch last\"), QSqlError::ConnectionError, d));\n            return false;\n        }\n    }\n\n    SQLSMALLINT count = 0;\n    SQLNumResultCols(d->hStmt, &count);\n    if (count) {\n        setSelect(true);\n        for (int i = 0; i < count; ++i) {\n            d->rInf.append(qMakeFieldInfo(d, i));\n        }\n        d->fieldCache.resize(count);\n    } else {\n        setSelect(false);\n    }\n    setActive(true);\n\n    return true;\n}\n\nvoid QODBCResult::virtual_hook(int id, void *data)\n{\n    QSqlResult::virtual_hook(id, data);\n}\n\nvoid QODBCResult::detachFromResultSet()\n{\n    Q_D(QODBCResult);\n    if (d->hStmt)\n        SQLCloseCursor(d->hStmt);\n}\n\n////////////////////////////////////////\n\n\nQODBCDriver::QODBCDriver(QObject *parent)\n    : QSqlDriver(*new QODBCDriverPrivate, parent)\n{\n}\n\nQODBCDriver::QODBCDriver(SQLHANDLE env, SQLHANDLE con, QObject *parent)\n    : QSqlDriver(*new QODBCDriverPrivate, parent)\n{\n    Q_D(QODBCDriver);\n    d->hEnv = env;\n    d->hDbc = con;\n    if (env && con) {\n        setOpen(true);\n        setOpenError(false);\n    }\n}\n\nQODBCDriver::~QODBCDriver()\n{\n    cleanup();\n}\n\nbool QODBCDriver::hasFeature(DriverFeature f) const\n{\n    Q_D(const QODBCDriver);\n    switch (f) {\n    case Transactions: {\n        if (!d->hDbc)\n            return false;\n        SQLUSMALLINT txn;\n        SQLSMALLINT t;\n        int r = SQLGetInfo(d->hDbc,\n                        (SQLUSMALLINT)SQL_TXN_CAPABLE,\n                        &txn,\n                        sizeof(txn),\n                        &t);\n        if (r != SQL_SUCCESS || txn == SQL_TC_NONE)\n            return false;\n        else\n            return true;\n    }\n    case Unicode:\n        return d->unicode;\n    case PreparedQueries:\n    case PositionalPlaceholders:\n    case FinishQuery:\n    case LowPrecisionNumbers:\n        return true;\n    case QuerySize:\n    case NamedPlaceholders:\n    case BatchOperations:\n    case SimpleLocking:\n    case EventNotifications:\n    case CancelQuery:\n        return false;\n    case LastInsertId:\n        return (d->dbmsType == MSSqlServer)\n                || (d->dbmsType == Sybase)\n                || (d->dbmsType == MySqlServer)\n                || (d->dbmsType == PostgreSQL);\n    case MultipleResultSets:\n        return d->hasMultiResultSets;\n    case BLOB: {\n        if (d->dbmsType == MySqlServer)\n            return true;\n        else\n            return false;\n    }\n    }\n    return false;\n}\n\nbool QODBCDriver::open(const QString & db,\n                        const QString & user,\n                        const QString & password,\n                        const QString &,\n                        int,\n                        const QString& connOpts)\n{\n    Q_D(QODBCDriver);\n    if (isOpen())\n      close();\n    SQLRETURN r;\n    r = SQLAllocHandle(SQL_HANDLE_ENV,\n                        SQL_NULL_HANDLE,\n                        &d->hEnv);\n    if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO) {\n        qSqlWarning(\"QODBCDriver::open: Unable to allocate environment\"_L1, d);\n        setOpenError(true);\n        return false;\n    }\n    r = SQLSetEnvAttr(d->hEnv,\n                       SQL_ATTR_ODBC_VERSION,\n                       (SQLPOINTER)qGetODBCVersion(connOpts),\n                       SQL_IS_UINTEGER);\n    r = SQLAllocHandle(SQL_HANDLE_DBC,\n                        d->hEnv,\n                        &d->hDbc);\n    if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO) {\n        qSqlWarning(\"QODBCDriver::open: Unable to allocate connection\"_L1, d);\n        setOpenError(true);\n        cleanup();\n        return false;\n    }\n\n    if (!d->setConnectionOptions(connOpts)) {\n        cleanup();\n        return false;\n    }\n\n    // Create the connection string\n    QString connQStr;\n    // support the \"DRIVER={SQL SERVER};SERVER=blah\" syntax\n    if (db.contains(\".dsn\"_L1, Qt::CaseInsensitive))\n        connQStr = \"FILEDSN=\"_L1 + db;\n    else if (db.contains(\"DRIVER=\"_L1, Qt::CaseInsensitive)\n            || db.contains(\"SERVER=\"_L1, Qt::CaseInsensitive))\n        connQStr = db;\n    else\n        connQStr = \"DSN=\"_L1 + db;\n\n    if (!user.isEmpty())\n        connQStr += \";UID=\"_L1 + user;\n    if (!password.isEmpty())\n        connQStr += \";PWD=\"_L1 + password;\n\n    SQLSMALLINT cb;\n    QVarLengthArray<SQLTCHAR> connOut(1024);\n    memset(connOut.data(), 0, connOut.size() * sizeof(SQLTCHAR));\n    {\n        auto encoded = toSQLTCHAR(connQStr);\n        r = SQLDriverConnect(d->hDbc,\n                             nullptr,\n                             encoded.data(), SQLSMALLINT(encoded.size()),\n                             connOut.data(),\n                             1024,\n                             &cb,\n                             /*SQL_DRIVER_NOPROMPT*/0);\n    }\n\n    if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO) {\n        setLastError(qMakeError(tr(\"Unable to connect\"), QSqlError::ConnectionError, d));\n        setOpenError(true);\n        cleanup();\n        return false;\n    }\n\n    if (!d->checkDriver()) {\n        setLastError(qMakeError(tr(\"Unable to connect - Driver doesn't support all \"\n                     \"functionality required\"), QSqlError::ConnectionError, d));\n        setOpenError(true);\n        cleanup();\n        return false;\n    }\n\n    d->checkUnicode();\n    d->checkSchemaUsage();\n    d->checkDBMS();\n    d->checkHasSQLFetchScroll();\n    d->checkHasMultiResults();\n    d->checkDateTimePrecision();\n    setOpen(true);\n    setOpenError(false);\n    if (d->dbmsType == MSSqlServer) {\n        QSqlQuery i(createResult());\n        i.exec(\"SET QUOTED_IDENTIFIER ON\"_L1);\n    }\n    return true;\n}\n\nvoid QODBCDriver::close()\n{\n    cleanup();\n    setOpen(false);\n    setOpenError(false);\n}\n\nvoid QODBCDriver::cleanup()\n{\n    Q_D(QODBCDriver);\n    SQLRETURN r;\n\n    if (d->hDbc) {\n        // Open statements/descriptors handles are automatically cleaned up by SQLDisconnect\n        if (isOpen()) {\n            r = SQLDisconnect(d->hDbc);\n            if (r != SQL_SUCCESS)\n                qSqlWarning(\"QODBCDriver::disconnect: Unable to disconnect datasource\"_L1, d);\n            else\n                d->disconnectCount++;\n        }\n\n        r = SQLFreeHandle(SQL_HANDLE_DBC, d->hDbc);\n        if (r != SQL_SUCCESS)\n            qSqlWarning(\"QODBCDriver::cleanup: Unable to free connection handle\"_L1, d);\n        d->hDbc = 0;\n    }\n\n    if (d->hEnv) {\n        r = SQLFreeHandle(SQL_HANDLE_ENV, d->hEnv);\n        if (r != SQL_SUCCESS)\n            qSqlWarning(\"QODBCDriver::cleanup: Unable to free environment handle\"_L1, d);\n        d->hEnv = 0;\n    }\n}\n\n// checks whether the server can return char, varchar and longvarchar\n// as two byte unicode characters\nvoid QODBCDriverPrivate::checkUnicode()\n{\n    SQLRETURN   r;\n    SQLUINTEGER fFunc;\n\n    unicode = false;\n    r = SQLGetInfo(hDbc,\n                    SQL_CONVERT_CHAR,\n                    (SQLPOINTER)&fFunc,\n                    sizeof(fFunc),\n                    NULL);\n    if ((r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO) && (fFunc & SQL_CVT_WCHAR)) {\n        unicode = true;\n        return;\n    }\n\n    r = SQLGetInfo(hDbc,\n                    SQL_CONVERT_VARCHAR,\n                    (SQLPOINTER)&fFunc,\n                    sizeof(fFunc),\n                    NULL);\n    if ((r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO) && (fFunc & SQL_CVT_WVARCHAR)) {\n        unicode = true;\n        return;\n    }\n\n    r = SQLGetInfo(hDbc,\n                    SQL_CONVERT_LONGVARCHAR,\n                    (SQLPOINTER)&fFunc,\n                    sizeof(fFunc),\n                    NULL);\n    if ((r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO) && (fFunc & SQL_CVT_WLONGVARCHAR)) {\n        unicode = true;\n        return;\n    }\n    SQLHANDLE hStmt;\n    r = SQLAllocHandle(SQL_HANDLE_STMT,\n                                  hDbc,\n                                  &hStmt);\n\n    r = SQLExecDirect(hStmt, toSQLTCHAR(\"select 'test'\"_L1).data(), SQL_NTS);\n    if (r == SQL_SUCCESS) {\n        r = SQLFetch(hStmt);\n        if (r == SQL_SUCCESS) {\n            QVarLengthArray<SQLWCHAR> buffer(10);\n            r = SQLGetData(hStmt, 1, SQL_C_WCHAR, buffer.data(), buffer.size() * sizeof(SQLWCHAR), NULL);\n            if (r == SQL_SUCCESS && fromSQLTCHAR(buffer) == \"test\"_L1) {\n                unicode = true;\n            }\n        }\n    }\n    r = SQLFreeHandle(SQL_HANDLE_STMT, hStmt);\n}\n\nbool QODBCDriverPrivate::checkDriver() const\n{\n#ifdef ODBC_CHECK_DRIVER\n    static const SQLUSMALLINT reqFunc[] = {\n                SQL_API_SQLDESCRIBECOL, SQL_API_SQLGETDATA, SQL_API_SQLCOLUMNS,\n                SQL_API_SQLGETSTMTATTR, SQL_API_SQLGETDIAGREC, SQL_API_SQLEXECDIRECT,\n                SQL_API_SQLGETINFO, SQL_API_SQLTABLES, 0\n    };\n\n    // these functions are optional\n    static const SQLUSMALLINT optFunc[] = {\n        SQL_API_SQLNUMRESULTCOLS, SQL_API_SQLROWCOUNT, 0\n    };\n\n    SQLRETURN r;\n    SQLUSMALLINT sup;\n\n    int i;\n    // check the required functions\n    for (i = 0; reqFunc[i] != 0; ++i) {\n\n        r = SQLGetFunctions(hDbc, reqFunc[i], &sup);\n\n        if (r != SQL_SUCCESS) {\n            qSqlWarning(\"QODBCDriver::checkDriver: Cannot get list of supported functions\"_L1, this);\n            return false;\n        }\n        if (sup == SQL_FALSE) {\n            qWarning () << \"QODBCDriver::open: Warning - Driver doesn't support all needed functionality (\" << reqFunc[i] <<\n                    \").\\nPlease look at the Qt SQL Module Driver documentation for more information.\";\n            return false;\n        }\n    }\n\n    // these functions are optional and just generate a warning\n    for (i = 0; optFunc[i] != 0; ++i) {\n\n        r = SQLGetFunctions(hDbc, optFunc[i], &sup);\n\n        if (r != SQL_SUCCESS) {\n            qSqlWarning(\"QODBCDriver::checkDriver: Cannot get list of supported functions\"_L1, this);\n            return false;\n        }\n        if (sup == SQL_FALSE) {\n            qWarning() << \"QODBCDriver::checkDriver: Warning - Driver doesn't support some non-critical functions (\" << optFunc[i] << ')';\n            return true;\n        }\n    }\n#endif //ODBC_CHECK_DRIVER\n\n    return true;\n}\n\nvoid QODBCDriverPrivate::checkSchemaUsage()\n{\n    SQLRETURN   r;\n    SQLUINTEGER val;\n\n    r = SQLGetInfo(hDbc,\n                   SQL_SCHEMA_USAGE,\n                   (SQLPOINTER) &val,\n                   sizeof(val),\n                   NULL);\n    if (r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO)\n        useSchema = (val != 0);\n}\n\nvoid QODBCDriverPrivate::checkDBMS()\n{\n    SQLRETURN   r;\n    QVarLengthArray<SQLTCHAR> serverString(200);\n    SQLSMALLINT t;\n    memset(serverString.data(), 0, serverString.size() * sizeof(SQLTCHAR));\n\n    r = SQLGetInfo(hDbc,\n                   SQL_DBMS_NAME,\n                   serverString.data(),\n                   SQLSMALLINT(serverString.size() * sizeof(SQLTCHAR)),\n                   &t);\n    if (r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO) {\n        const QString serverType = fromSQLTCHAR(serverString, t / sizeof(SQLTCHAR));\n        if (serverType.contains(\"PostgreSQL\"_L1, Qt::CaseInsensitive))\n            dbmsType = QSqlDriver::PostgreSQL;\n        else if (serverType.contains(\"Oracle\"_L1, Qt::CaseInsensitive))\n            dbmsType = QSqlDriver::Oracle;\n        else if (serverType.contains(\"MySql\"_L1, Qt::CaseInsensitive))\n            dbmsType = QSqlDriver::MySqlServer;\n        else if (serverType.contains(\"Microsoft SQL Server\"_L1, Qt::CaseInsensitive))\n            dbmsType = QSqlDriver::MSSqlServer;\n        else if (serverType.contains(\"Sybase\"_L1, Qt::CaseInsensitive))\n            dbmsType = QSqlDriver::Sybase;\n    }\n    r = SQLGetInfo(hDbc,\n                   SQL_DRIVER_NAME,\n                   serverString.data(),\n                   SQLSMALLINT(serverString.size() * sizeof(SQLTCHAR)),\n                   &t);\n    if (r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO) {\n        const QString serverType = fromSQLTCHAR(serverString, t / sizeof(SQLTCHAR));\n        isFreeTDSDriver = serverType.contains(\"tdsodbc\"_L1, Qt::CaseInsensitive);\n        unicode = unicode && !isFreeTDSDriver;\n    }\n}\n\nvoid QODBCDriverPrivate::checkHasSQLFetchScroll()\n{\n    SQLUSMALLINT sup;\n    SQLRETURN r = SQLGetFunctions(hDbc, SQL_API_SQLFETCHSCROLL, &sup);\n    if ((r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO) || sup != SQL_TRUE) {\n        hasSQLFetchScroll = false;\n        qWarning(\"QODBCDriver::checkHasSQLFetchScroll: Warning - Driver doesn't support scrollable result sets, use forward only mode for queries\");\n    }\n}\n\nvoid QODBCDriverPrivate::checkHasMultiResults()\n{\n    QVarLengthArray<SQLTCHAR> driverResponse(2);\n    SQLSMALLINT length;\n    SQLRETURN r = SQLGetInfo(hDbc,\n                             SQL_MULT_RESULT_SETS,\n                             driverResponse.data(),\n                             SQLSMALLINT(driverResponse.size() * sizeof(SQLTCHAR)),\n                             &length);\n    if (r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO)\n        hasMultiResultSets = fromSQLTCHAR(driverResponse, length/sizeof(SQLTCHAR)).startsWith(u'Y');\n}\n\nvoid QODBCDriverPrivate::checkDateTimePrecision()\n{\n    SQLINTEGER columnSize;\n    SQLHANDLE hStmt;\n\n    SQLRETURN r = SQLAllocHandle(SQL_HANDLE_STMT, hDbc, &hStmt);\n    if (r != SQL_SUCCESS) {\n        return;\n    }\n\n    r = SQLGetTypeInfo(hStmt, SQL_TIMESTAMP);\n    if (r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO) {\n        r = SQLFetch(hStmt);\n        if ( r == SQL_SUCCESS || r == SQL_SUCCESS_WITH_INFO )\n        {\n            if (SQLGetData(hStmt, 3, SQL_INTEGER, &columnSize, sizeof(columnSize), 0) == SQL_SUCCESS) {\n                datetimePrecision = (int)columnSize;\n            }\n        }\n    }\n    SQLFreeHandle(SQL_HANDLE_STMT, hStmt);\n}\n\nQSqlResult *QODBCDriver::createResult() const\n{\n    return new QODBCResult(this);\n}\n\nbool QODBCDriver::beginTransaction()\n{\n    Q_D(QODBCDriver);\n    if (!isOpen()) {\n        qWarning(\"QODBCDriver::beginTransaction: Database not open\");\n        return false;\n    }\n    SQLUINTEGER ac(SQL_AUTOCOMMIT_OFF);\n    SQLRETURN r  = SQLSetConnectAttr(d->hDbc,\n                                      SQL_ATTR_AUTOCOMMIT,\n                                      (SQLPOINTER)size_t(ac),\n                                      sizeof(ac));\n    if (r != SQL_SUCCESS) {\n        setLastError(qMakeError(tr(\"Unable to disable autocommit\"),\n                     QSqlError::TransactionError, d));\n        return false;\n    }\n    return true;\n}\n\nbool QODBCDriver::commitTransaction()\n{\n    Q_D(QODBCDriver);\n    if (!isOpen()) {\n        qWarning(\"QODBCDriver::commitTransaction: Database not open\");\n        return false;\n    }\n    SQLRETURN r = SQLEndTran(SQL_HANDLE_DBC,\n                              d->hDbc,\n                              SQL_COMMIT);\n    if (r != SQL_SUCCESS) {\n        setLastError(qMakeError(tr(\"Unable to commit transaction\"),\n                     QSqlError::TransactionError, d));\n        return false;\n    }\n    return endTrans();\n}\n\nbool QODBCDriver::rollbackTransaction()\n{\n    Q_D(QODBCDriver);\n    if (!isOpen()) {\n        qWarning(\"QODBCDriver::rollbackTransaction: Database not open\");\n        return false;\n    }\n    SQLRETURN r = SQLEndTran(SQL_HANDLE_DBC,\n                              d->hDbc,\n                              SQL_ROLLBACK);\n    if (r != SQL_SUCCESS) {\n        setLastError(qMakeError(tr(\"Unable to rollback transaction\"),\n                     QSqlError::TransactionError, d));\n        return false;\n    }\n    return endTrans();\n}\n\nbool QODBCDriver::endTrans()\n{\n    Q_D(QODBCDriver);\n    SQLUINTEGER ac(SQL_AUTOCOMMIT_ON);\n    SQLRETURN r  = SQLSetConnectAttr(d->hDbc,\n                                      SQL_ATTR_AUTOCOMMIT,\n                                      (SQLPOINTER)size_t(ac),\n                                      sizeof(ac));\n    if (r != SQL_SUCCESS) {\n        setLastError(qMakeError(tr(\"Unable to enable autocommit\"), QSqlError::TransactionError, d));\n        return false;\n    }\n    return true;\n}\n\nQStringList QODBCDriver::tables(QSql::TableType type) const\n{\n    Q_D(const QODBCDriver);\n    QStringList tl;\n    if (!isOpen())\n        return tl;\n    SQLHANDLE hStmt;\n\n    SQLRETURN r = SQLAllocHandle(SQL_HANDLE_STMT,\n                                  d->hDbc,\n                                  &hStmt);\n    if (r != SQL_SUCCESS) {\n        qSqlWarning(\"QODBCDriver::tables: Unable to allocate handle\"_L1, d);\n        return tl;\n    }\n    r = SQLSetStmtAttr(hStmt,\n                        SQL_ATTR_CURSOR_TYPE,\n                        (SQLPOINTER)SQL_CURSOR_FORWARD_ONLY,\n                        SQL_IS_UINTEGER);\n    QStringList tableType;\n    if (type & QSql::Tables)\n        tableType += \"TABLE\"_L1;\n    if (type & QSql::Views)\n        tableType += \"VIEW\"_L1;\n    if (type & QSql::SystemTables)\n        tableType += \"SYSTEM TABLE\"_L1;\n    if (tableType.isEmpty())\n        return tl;\n\n    {\n        auto joinedTableTypeString = toSQLTCHAR(tableType.join(u','));\n\n        r = SQLTables(hStmt,\n                      nullptr, 0,\n                      nullptr, 0,\n                      nullptr, 0,\n                      joinedTableTypeString.data(), joinedTableTypeString.size());\n    }\n\n    if (r != SQL_SUCCESS)\n        qSqlWarning(\"QODBCDriver::tables Unable to execute table list\"_L1, d);\n\n    if (d->hasSQLFetchScroll)\n        r = SQLFetchScroll(hStmt,\n                           SQL_FETCH_NEXT,\n                           0);\n    else\n        r = SQLFetch(hStmt);\n\n    if (r != SQL_SUCCESS && r != SQL_SUCCESS_WITH_INFO && r != SQL_NO_DATA) {\n        qWarning() << \"QODBCDriver::tables failed to retrieve table/view list: (\" << r << \",\" << qWarnODBCHandle(SQL_HANDLE_STMT, hStmt) << \")\";\n        return QStringList();\n    }\n\n    while (r == SQL_SUCCESS) {\n        tl.append(qGetStringData(hStmt, 2, -1, d->unicode).toString());\n\n        if (d->hasSQLFetchScroll)\n            r = SQLFetchScroll(hStmt,\n                               SQL_FETCH_NEXT,\n                               0);\n        else\n            r = SQLFetch(hStmt);\n    }\n\n    r = SQLFreeHandle(SQL_HANDLE_STMT, hStmt);\n    if (r!= SQL_SUCCESS)\n        qSqlWarning(\"QODBCDriver: Unable to free statement handle\"_L1 + QString::number(r), d);\n    return tl;\n}\n\nQSqlIndex QODBCDriver::primaryIndex(const QString& tablename) const\n{\n    Q_D(const QODBCDriver);\n    QSqlIndex index(tablename);\n    if (!isOpen())\n        return index;\n    bool usingSpecialColumns = false;\n    QSqlRecord rec = record(tablename);\n\n    SQLHANDLE hStmt;\n    SQLRETURN r = SQLAllocHandle(SQL_HANDLE_STMT,\n                                  d->hDbc,\n                                  &hStmt);\n    if (r != SQL_SUCCESS) {\n        qSqlWarning(\"QODBCDriver::primaryIndex: Unable to list primary key\"_L1, d);\n        return index;\n    }\n    QString catalog, schema, table;\n    const_cast<QODBCDriverPrivate*>(d)->splitTableQualifier(tablename, catalog, schema, table);\n\n    if (isIdentifierEscaped(catalog, QSqlDriver::TableName))\n        catalog = stripDelimiters(catalog, QSqlDriver::TableName);\n    else\n        catalog = d->adjustCase(catalog);\n\n    if (isIdentifierEscaped(schema, QSqlDriver::TableName))\n        schema = stripDelimiters(schema, QSqlDriver::TableName);\n    else\n        schema = d->adjustCase(schema);\n\n    if (isIdentifierEscaped(table, QSqlDriver::TableName))\n        table = stripDelimiters(table, QSqlDriver::TableName);\n    else\n        table = d->adjustCase(table);\n\n    r = SQLSetStmtAttr(hStmt,\n                        SQL_ATTR_CURSOR_TYPE,\n                        (SQLPOINTER)SQL_CURSOR_FORWARD_ONLY,\n                        SQL_IS_UINTEGER);\n    {\n        auto c = toSQLTCHAR(catalog);\n        auto s = toSQLTCHAR(schema);\n        auto t = toSQLTCHAR(table);\n        r = SQLPrimaryKeys(hStmt,\n                           catalog.isEmpty() ? nullptr : c.data(), c.size(),\n                           schema.isEmpty()  ? nullptr : s.data(), s.size(),\n                           t.data(), t.size());\n    }\n\n    // if the SQLPrimaryKeys() call does not succeed (e.g the driver\n    // does not support it) - try an alternative method to get hold of\n    // the primary index (e.g MS Access and FoxPro)\n    if (r != SQL_SUCCESS) {\n        auto c = toSQLTCHAR(catalog);\n        auto s = toSQLTCHAR(schema);\n        auto t = toSQLTCHAR(table);\n        r = SQLSpecialColumns(hStmt,\n                              SQL_BEST_ROWID,\n                              catalog.isEmpty() ? nullptr : c.data(), c.size(),\n                              schema.isEmpty()  ? nullptr : s.data(), s.size(),\n                              t.data(), t.size(),\n                              SQL_SCOPE_CURROW,\n                              SQL_NULLABLE);\n\n            if (r != SQL_SUCCESS) {\n                qSqlWarning(\"QODBCDriver::primaryIndex: Unable to execute primary key list\"_L1, d);\n            } else {\n                usingSpecialColumns = true;\n            }\n    }\n\n    if (d->hasSQLFetchScroll)\n        r = SQLFetchScroll(hStmt,\n                           SQL_FETCH_NEXT,\n                           0);\n    else\n        r = SQLFetch(hStmt);\n\n    int fakeId = 0;\n    QString cName, idxName;\n    // Store all fields in a StringList because some drivers can't detail fields in this FETCH loop\n    while (r == SQL_SUCCESS) {\n        if (usingSpecialColumns) {\n            cName = qGetStringData(hStmt, 1, -1, d->unicode).toString(); // column name\n            idxName = QString::number(fakeId++); // invent a fake index name\n        } else {\n            cName = qGetStringData(hStmt, 3, -1, d->unicode).toString(); // column name\n            idxName = qGetStringData(hStmt, 5, -1, d->unicode).toString(); // pk index name\n        }\n        index.append(rec.field(cName));\n        index.setName(idxName);\n\n        if (d->hasSQLFetchScroll)\n            r = SQLFetchScroll(hStmt,\n                               SQL_FETCH_NEXT,\n                               0);\n        else\n            r = SQLFetch(hStmt);\n\n    }\n    r = SQLFreeHandle(SQL_HANDLE_STMT, hStmt);\n    if (r!= SQL_SUCCESS)\n        qSqlWarning(\"QODBCDriver: Unable to free statement handle\"_L1 + QString::number(r), d);\n    return index;\n}\n\nQSqlRecord QODBCDriver::record(const QString& tablename) const\n{\n    Q_D(const QODBCDriver);\n    QSqlRecord fil;\n    if (!isOpen())\n        return fil;\n\n    SQLHANDLE hStmt;\n    QString catalog, schema, table;\n    const_cast<QODBCDriverPrivate*>(d)->splitTableQualifier(tablename, catalog, schema, table);\n\n    if (isIdentifierEscaped(catalog, QSqlDriver::TableName))\n        catalog = stripDelimiters(catalog, QSqlDriver::TableName);\n    else\n        catalog = d->adjustCase(catalog);\n\n    if (isIdentifierEscaped(schema, QSqlDriver::TableName))\n        schema = stripDelimiters(schema, QSqlDriver::TableName);\n    else\n        schema = d->adjustCase(schema);\n\n    if (isIdentifierEscaped(table, QSqlDriver::TableName))\n        table = stripDelimiters(table, QSqlDriver::TableName);\n    else\n        table = d->adjustCase(table);\n\n    SQLRETURN r = SQLAllocHandle(SQL_HANDLE_STMT,\n                                  d->hDbc,\n                                  &hStmt);\n    if (r != SQL_SUCCESS) {\n        qSqlWarning(\"QODBCDriver::record: Unable to allocate handle\"_L1, d);\n        return fil;\n    }\n    r = SQLSetStmtAttr(hStmt,\n                        SQL_ATTR_CURSOR_TYPE,\n                        (SQLPOINTER)SQL_CURSOR_FORWARD_ONLY,\n                        SQL_IS_UINTEGER);\n    {\n        auto c = toSQLTCHAR(catalog);\n        auto s = toSQLTCHAR(schema);\n        auto t = toSQLTCHAR(table);\n        r =  SQLColumns(hStmt,\n                        catalog.isEmpty() ? nullptr : c.data(), c.size(),\n                        schema.isEmpty()  ? nullptr : s.data(), s.size(),\n                        t.data(), t.size(),\n                        nullptr,\n                        0);\n    }\n    if (r != SQL_SUCCESS)\n        qSqlWarning(\"QODBCDriver::record: Unable to execute column list\"_L1, d);\n\n    if (d->hasSQLFetchScroll)\n        r = SQLFetchScroll(hStmt,\n                           SQL_FETCH_NEXT,\n                           0);\n    else\n        r = SQLFetch(hStmt);\n\n    // Store all fields in a StringList because some drivers can't detail fields in this FETCH loop\n    while (r == SQL_SUCCESS) {\n\n        fil.append(qMakeFieldInfo(hStmt, d));\n\n        if (d->hasSQLFetchScroll)\n            r = SQLFetchScroll(hStmt,\n                               SQL_FETCH_NEXT,\n                               0);\n        else\n            r = SQLFetch(hStmt);\n    }\n\n    r = SQLFreeHandle(SQL_HANDLE_STMT, hStmt);\n    if (r!= SQL_SUCCESS)\n        qSqlWarning(\"QODBCDriver: Unable to free statement handle \"_L1 + QString::number(r), d);\n\n    return fil;\n}\n\nQString QODBCDriver::formatValue(const QSqlField &field,\n                                 bool trimStrings) const\n{\n    QString r;\n    if (field.isNull()) {\n        r = \"NULL\"_L1;\n    } else if (field.metaType().id() == QMetaType::QDateTime) {\n        // Use an escape sequence for the datetime fields\n        if (field.value().toDateTime().isValid()){\n            QDate dt = field.value().toDateTime().date();\n            QTime tm = field.value().toDateTime().time();\n            // Dateformat has to be \"yyyy-MM-dd hh:mm:ss\", with leading zeroes if month or day < 10\n            r = \"{ ts '\"_L1 +\n                QString::number(dt.year()) + u'-' +\n                QString::number(dt.month()).rightJustified(2, u'0', true) +\n                u'-' +\n                QString::number(dt.day()).rightJustified(2, u'0', true) +\n                u' ' +\n                tm.toString() +\n                \"' }\"_L1;\n        } else\n            r = \"NULL\"_L1;\n    } else if (field.metaType().id() == QMetaType::QByteArray) {\n        QByteArray ba = field.value().toByteArray();\n        QString res;\n        static const char hexchars[] = \"0123456789abcdef\";\n        for (int i = 0; i < ba.size(); ++i) {\n            uchar s = (uchar) ba[i];\n            res += QLatin1Char(hexchars[s >> 4]);\n            res += QLatin1Char(hexchars[s & 0x0f]);\n        }\n        r = \"0x\"_L1 + res;\n    } else {\n        r = QSqlDriver::formatValue(field, trimStrings);\n    }\n    return r;\n}\n\nQVariant QODBCDriver::handle() const\n{\n    Q_D(const QODBCDriver);\n    return QVariant(QMetaType::fromType<SQLHANDLE>(), &d->hDbc);\n}\n\nQString QODBCDriver::escapeIdentifier(const QString &identifier, IdentifierType) const\n{\n    Q_D(const QODBCDriver);\n    QChar quote = const_cast<QODBCDriverPrivate*>(d)->quoteChar();\n    QString res = identifier;\n    if (!identifier.isEmpty() && !identifier.startsWith(quote) && !identifier.endsWith(quote) ) {\n        res.replace(quote, QString(quote)+QString(quote));\n        res.prepend(quote).append(quote);\n        res.replace(u'.', QString(quote) + u'.' +QString(quote));\n    }\n    return res;\n}\n\nbool QODBCDriver::isIdentifierEscaped(const QString &identifier, IdentifierType) const\n{\n    Q_D(const QODBCDriver);\n    QChar quote = const_cast<QODBCDriverPrivate*>(d)->quoteChar();\n    return identifier.size() > 2\n        && identifier.startsWith(quote) //left delimited\n        && identifier.endsWith(quote); //right delimited\n}\n\nQT_END_NAMESPACE\n\n#include \"moc_qsql_odbc_p.cpp\"\n"], "filenames": ["src/plugins/sqldrivers/odbc/qsql_odbc.cpp"], "buggy_code_start_loc": [747], "buggy_code_end_loc": [2574], "fixing_code_start_loc": [748], "fixing_code_end_loc": [2586], "type": "NVD-CWE-noinfo", "message": "Qt before 6.4.3 allows a denial of service via a crafted string when the SQL ODBC driver plugin is used and the size of SQLTCHAR is 4. The affected versions are 5.x before 5.15.13, 6.x before 6.2.8, and 6.3.x before 6.4.3.", "other": {"cve": {"id": "CVE-2023-24607", "sourceIdentifier": "cve@mitre.org", "published": "2023-04-15T01:15:07.043", "lastModified": "2023-04-24T20:10:01.590", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Qt before 6.4.3 allows a denial of service via a crafted string when the SQL ODBC driver plugin is used and the size of SQLTCHAR is 4. The affected versions are 5.x before 5.15.13, 6.x before 6.2.8, and 6.3.x before 6.4.3."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:qt:qt:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.0.0", "versionEndExcluding": "5.15.13", "matchCriteriaId": "82BC32FC-2B1F-4FD4-A368-DD37D7FCBA7E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:qt:qt:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.0.0", "versionEndExcluding": "6.2.8", "matchCriteriaId": "4911A94E-AA2F-4017-8702-0AF092FF809F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:qt:qt:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.3.0", "versionEndExcluding": "6.4.3", "matchCriteriaId": "9DC66FEF-0D94-4464-B9F8-800A1F9424C0"}]}]}], "references": [{"url": "https://codereview.qt-project.org/c/qt/qtbase/+/456216", "source": "cve@mitre.org", "tags": ["Issue Tracking"]}, {"url": "https://codereview.qt-project.org/c/qt/tqtc-qtbase/+/456217", "source": "cve@mitre.org", "tags": ["Permissions Required"]}, {"url": "https://codereview.qt-project.org/c/qt/tqtc-qtbase/+/456238", "source": "cve@mitre.org", "tags": ["Permissions Required"]}, {"url": "https://download.qt.io/official_releases/qt/5.15/CVE-2023-24607-qtbase-5.15.diff", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/qt/qtbase/commit/aaf1381eab6292aa0444a5eadcc24165b6e1c02d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.qt.io/blog/security-advisory-qt-sql-odbc-driver-plugin", "source": "cve@mitre.org", "tags": ["Product"]}, {"url": "https://www.qt.io/blog/tag/security", "source": "cve@mitre.org", "tags": ["Release Notes"]}]}, "github_commit_url": "https://github.com/qt/qtbase/commit/aaf1381eab6292aa0444a5eadcc24165b6e1c02d"}}