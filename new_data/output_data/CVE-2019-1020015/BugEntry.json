{"buggy_code": ["#!/usr/bin/env bash\nset -euo pipefail\n\n### Functions\n\nstop_services() {\n   kill -INT $HGE_PIDS || true\n   kill $WH_PID || true\n   kill -INT $WHC_PID || true\n}\n\ntime_elapsed(){\n\tprintf \"(%02d:%02d)\" $[SECONDS/60] $[SECONDS%60]\n}\n\nfail_if_port_busy() {\n    local PORT=$1\n    if nc -z localhost $PORT ; then\n        echo \"Port $PORT is busy. Exiting\"\n        exit 1\n    fi\n}\n\nwait_for_port() {\n    local PORT=$1\n    echo \"waiting for $PORT\"\n    for _ in $(seq 1 240);\n    do\n      nc -z localhost $PORT && echo \"port $PORT is ready\" && return\n      echo -n .\n      sleep 0.25\n    done\n    echo \"Failed waiting for $PORT\" && exit 1\n}\n\ninit_jwt() {\n\tCUR_DIR=\"$PWD\"\n\tmkdir -p \"$OUTPUT_FOLDER/ssl\"\n\tcd \"$OUTPUT_FOLDER/ssl\"\n\topenssl genrsa -out jwt_private.key 2048\n\topenssl rsa -pubout -in jwt_private.key -out  jwt_public.key\n\tcd \"$CUR_DIR\"\n}\n\ninit_ssl() {\n\tCUR_DIR=\"$PWD\"\n\tmkdir -p \"$OUTPUT_FOLDER/ssl\"\n\tcd \"$OUTPUT_FOLDER/ssl\"\n\tCNF_TEMPLATE='[req]\nreq_extensions = v3_req\ndistinguished_name = req_distinguished_name\n\n[req_distinguished_name]\n\n[ v3_req ]\nbasicConstraints = CA:FALSE\nkeyUsage = nonRepudiation, digitalSignature, keyEncipherment\nsubjectAltName = @alt_names\n\n[alt_names]\nDNS.1 = localhost\nIP.1 = 127.0.0.1'\n\n\techo \"$CNF_TEMPLATE\" > webhook-req.cnf\n\n\topenssl genrsa -out ca-key.pem 2048\n\topenssl req -x509 -new -nodes -key ca-key.pem -days 10 -out ca.pem -subj \"/CN=webhook-ca\"\n\topenssl genrsa -out webhook-key.pem 2048\n\topenssl req -new -key webhook-key.pem -out webhook.csr -subj \"/CN=hge-webhook\" -config webhook-req.cnf\n\topenssl x509 -req -in webhook.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out webhook.pem -days 10 -extensions v3_req -extfile webhook-req.cnf\n\n\tcp ca.pem /etc/ssl/certs/webhook.crt\n\tupdate-ca-certificates\n\tcd \"$CUR_DIR\"\n}\n\ncombine_all_hpc_reports() {\n\tcombined_file=\"${OUTPUT_FOLDER}/graphql-engine.tix\"\n\tcombined_file_intermediate=\"${OUTPUT_FOLDER}/hpc/graphql-engine-combined-intermediate.tix\"\n\trm -f \"$combined_file\"\n\tIFS=: tix_files_arr=($TIX_FILES)\n\tunset IFS\n\tfor tix_file in \"${tix_files_arr[@]}\"\n\tdo\n\t\tif ! [ -f \"$tix_file\" ] ; then\n\t\t\tcontinue\n\t\tfi\n\t\tif [ -f \"$combined_file\" ]  ; then\n\t\t\t(set -x && stack --allow-different-user exec -- hpc combine \"$combined_file\" \"$tix_file\" --union --output=\"$combined_file_intermediate\" && set +x && mv \"$combined_file_intermediate\" \"$combined_file\" && rm \"$tix_file\" ) || true\n\t\telse\n\t\t\tmv \"$tix_file\" \"$combined_file\" || true\n\t\tfi\n\tdone\n}\n\nkill_hge_servers() {\n\tkill -INT $HGE_PIDS || true\n\twait $HGE_PIDS || true\n\tHGE_PIDS=\"\"\n}\n\nrun_hge_with_args() {\n\ti=$((TIX_FILE_INDEX++))\n\texport HPCTIXFILE=\"${OUTPUT_FOLDER}/hpc/graphql-engine-${i}-${TEST_TYPE}.tix\"\n\trm -f \"$HPCTIXFILE\"\n\tTIX_FILES=\"$TIX_FILES:$HPCTIXFILE\"\n\tset -x\n\t\"$GRAPHQL_ENGINE\" \"$@\" 2>&1 > \"$OUTPUT_FOLDER/graphql-engine-${i}-${TEST_TYPE}.log\" & HGE_PIDS=\"$HGE_PIDS $!\"\n\tset +x\n}\n\nstart_multiple_hge_servers() {\n\trun_hge_with_args --database-url \"$HASURA_GRAPHQL_DATABASE_URL\" serve \"$@\"\n\tif [ -n ${HASURA_GRAPHQL_DATABASE_URL_2:-} ] ; then\n\t\trun_hge_with_args --database-url \"$HASURA_GRAPHQL_DATABASE_URL_2\" serve --server-port 8081 \"$@\"\n\t\twait_for_port 8081\n\tfi\n\twait_for_port 8080\n}\n\n\nif [ -z \"${HASURA_GRAPHQL_DATABASE_URL:-}\" ] ; then\n\techo \"Env var HASURA_GRAPHQL_DATABASE_URL is not set\"\n\texit 1\nfi\n\nif [ -z \"${HASURA_GRAPHQL_DATABASE_URL_2:-}\" ] ; then\n\techo \"Env var HASURA_GRAPHQL_DATABASE_URL_2 is not set\"\n\texit 1\nfi\n\nif ! stack --allow-different-user exec which hpc ; then\n\techo \"hpc not found; Install it with 'stack install hpc'\"\n\texit 1\nfi\n\nCIRCLECI_FOLDER=\"${BASH_SOURCE[0]%/*}\"\ncd $CIRCLECI_FOLDER\nCIRCLECI_FOLDER=\"$PWD\"\n\nif ! $CIRCLECI_FOLDER/test-server-flags.sh ; then\n\techo \"Testing GraphQL server flags failed\"\n\texit 1\nfi\n\nif ! $CIRCLECI_FOLDER/test-deprecated-server-flags.sh ; then\n\techo \"Testing GraphQL deprecated server flags failed\"\n\texit 1\nfi\n\nPYTEST_ROOT=\"$CIRCLECI_FOLDER/../server/tests-py\"\n\nOUTPUT_FOLDER=${OUTPUT_FOLDER:-\"$CIRCLECI_FOLDER/test-server-output\"}\nmkdir -p \"$OUTPUT_FOLDER\"\n\nTEST_TYPE=\"no-auth\"\nHPCTIXFILE=\"\"\nTIX_FILE_INDEX=\"1\"\nTIX_FILES=\"\"\n\ncd $PYTEST_ROOT\n\nif ! stack --allow-different-user exec -- which graphql-engine > /dev/null && [ -z \"${GRAPHQL_ENGINE:-}\" ] ; then\n\techo \"Do 'stack build' before tests, or export the location of executable in the GRAPHQL_ENGINE envirnoment variable\"\n\texit 1\nfi\nGRAPHQL_ENGINE=${GRAPHQL_ENGINE:-\"$(stack --allow-different-user exec -- which graphql-engine)\"}\nif ! [ -x \"$GRAPHQL_ENGINE\" ] ; then\n\techo \"$GRAPHQL_ENGINE is not present or is not an executable\"\n\texit 1\nfi\nRUN_WEBHOOK_TESTS=true\n\nfor port in 8080 8081 9876 5592\ndo\n\tfail_if_port_busy $port\ndone\n\necho -e \"\\nINFO: GraphQL Executable : $GRAPHQL_ENGINE\"\necho -e \"INFO: Logs Folder        : $OUTPUT_FOLDER\\n\"\n\npip3 install -r requirements.txt\n\nmkdir -p \"$OUTPUT_FOLDER/hpc\"\n\nexport EVENT_WEBHOOK_HEADER=\"MyEnvValue\"\nexport HGE_URL=\"http://localhost:8080\"\nexport HGE_URL_2=\"\"\nif [ -n ${HASURA_GRAPHQL_DATABASE_URL_2:-} ] ; then\n\tHGE_URL_2=\"http://localhost:8081\"\nfi\nexport WEBHOOK_FROM_ENV=\"http://127.0.0.1:5592\"\nexport HASURA_GRAPHQL_STRINGIFY_NUMERIC_TYPES=true\n\nHGE_PIDS=\"\"\nWH_PID=\"\"\nWHC_PID=\"\"\nHS_PID=\"\"\n\ntrap stop_services ERR\ntrap stop_services INT\n\nrun_pytest_parallel() {\n\ttrap stop_services ERR\n\tif [ -n ${HASURA_GRAPHQL_DATABASE_URL_2:-} ] ; then\n\t\tset -x\n\t\tpytest -vv --hge-urls \"$HGE_URL\" \"${HGE_URL_2:-}\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" \"${HASURA_GRAPHQL_DATABASE_URL_2:-}\" -n 2 --dist=loadfile \"$@\"\n\t\tset +x\n\telse\n\t\tset -x\n\t\tpytest -vv --hge-urls \"$HGE_URL\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" -n 1 \"$@\"\n\t\tset +x\n\tfi\n}\n\necho -e \"\\n$(time_elapsed): <########## TEST GRAPHQL-ENGINE WITHOUT ADMIN SECRET ###########################################>\\n\"\nTEST_TYPE=\"no-auth\"\n\nstart_multiple_hge_servers\n\nrun_pytest_parallel\n\nkill_hge_servers\n\n##########\necho -e \"\\n$(time_elapsed): <########## TEST GRAPHQL-ENGINE WITH ADMIN SECRET #####################################>\\n\"\nTEST_TYPE=\"admin-secret\"\n\nexport HASURA_GRAPHQL_ADMIN_SECRET=\"HGE$RANDOM$RANDOM\"\n\nstart_multiple_hge_servers\n\nrun_pytest_parallel --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\"\n\nkill_hge_servers\n\n##########\necho -e \"\\n$(time_elapsed): <########## TEST GRAPHQL-ENGINE WITH ADMIN SECRET AND JWT #####################################>\\n\"\nTEST_TYPE=\"jwt\"\n\ninit_jwt\n\nexport HASURA_GRAPHQL_JWT_SECRET=\"$(jq -n --arg key \"$(cat $OUTPUT_FOLDER/ssl/jwt_public.key)\" '{ type: \"RS512\", key: $key }')\"\n\nstart_multiple_hge_servers\n\nrun_pytest_parallel --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\" --hge-jwt-key-file=\"$OUTPUT_FOLDER/ssl/jwt_private.key\" --hge-jwt-conf=\"$HASURA_GRAPHQL_JWT_SECRET\"\n\nkill_hge_servers\n\nunset HASURA_GRAPHQL_JWT_SECRET\n\necho -e \"\\n$(time_elapsed): <########## TEST GRAPHQL-ENGINE WITH ADMIN SECRET AND JWT (in stringified mode) #####################################>\\n\"\nTEST_TYPE=\"jwt-stringified\"\n\n\nexport HASURA_GRAPHQL_JWT_SECRET=\"$(jq -n --arg key \"$(cat $OUTPUT_FOLDER/ssl/jwt_public.key)\" '{ type: \"RS512\", key: $key , claims_format: \"stringified_json\"}')\"\n\nrun_hge_with_args serve\nwait_for_port 8080\n\npytest -n 1 -vv --hge-urls \"$HGE_URL\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\" --hge-jwt-key-file=\"$OUTPUT_FOLDER/ssl/jwt_private.key\" --hge-jwt-conf=\"$HASURA_GRAPHQL_JWT_SECRET\" test_jwt.py\n\nkill_hge_servers\n\nunset HASURA_GRAPHQL_JWT_SECRET\n\n# test with CORS modes\n\necho -e \"\\n$(time_elapsed): <########## TEST GRAPHQL-ENGINE WITH CORS DOMAINS ########>\\n\"\nexport HASURA_GRAPHQL_CORS_DOMAIN=\"http://*.localhost, http://localhost:3000, https://*.foo.bar.com\"\nTEST_TYPE=\"cors-domains\"\n\nrun_hge_with_args serve\nwait_for_port 8080\n\npytest -n  1 -vv --hge-urls \"$HGE_URL\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\" --test-cors test_cors.py\n\nkill_hge_servers\n\nunset HASURA_GRAPHQL_CORS_DOMAIN\n\n# test websocket transport with initial cookie header\n\necho -e \"\\n$(time_elapsped): <########## TEST GRAPHQL-ENGINE WITH COOKIE IN WEBSOCKET INIT ########>\\n\"\nTEST_TYPE=\"ws-init-cookie-read-cors-enabled\"\nexport HASURA_GRAPHQL_AUTH_HOOK=\"http://localhost:9876/auth\"\nexport HASURA_GRAPHQL_AUTH_HOOK_MODE=\"POST\"\n\npython3 test_cookie_webhook.py > \"$OUTPUT_FOLDER/cookie_webhook.log\" 2>&1  & WHC_PID=$!\n\nwait_for_port 9876\n\nrun_hge_with_args serve\nwait_for_port 8080\n\necho \"$(time_elapsed): testcase 1: read cookie, cors enabled\"\npytest -n 1 -vv --hge-urls \"$HGE_URL\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\" --test-ws-init-cookie=read test_websocket_init_cookie.py\n\nkill_hge_servers\n\necho \"$(time_elapsed): testcase 2: no read cookie, cors disabled\"\nTEST_TYPE=\"ws-init-cookie-noread\"\nrun_hge_with_args serve --disable-cors\n\nwait_for_port 8080\n\npytest -n 1 -vv --hge-urls \"$HGE_URL\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\" --test-ws-init-cookie=noread test_websocket_init_cookie.py\n\nkill_hge_servers\n\necho \"$(time_elapsed): testcase 3: read cookie, cors disabled and ws-read-cookie\"\nTEST_TYPE=\"ws-init-cookie-read-cors-disabled\"\nexport HASURA_GRAPHQL_WS_READ_COOKIE=\"true\"\nrun_hge_with_args serve --disable-cors\nwait_for_port 8080\n\npytest -n 1 -vv --hge-urls \"$HGE_URL\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\" --test-ws-init-cookie=read test_websocket_init_cookie.py\n\nkill_hge_servers\n\nkill $WHC_PID\nunset HASURA_GRAPHQL_WS_READ_COOKIE\nunset HASURA_GRAPHQL_AUTH_HOOK\nunset HASURA_GRAPHQL_AUTH_HOOK_MODE\nsleep 4\n\necho -e \"\\n$(time_elapsed): <########## TEST GRAPHQL-ENGINE WITH GRAPHQL DISABLED ########>\\n\"\nTEST_TYPE=\"ws-graphql-api-disabled\"\nexport HASURA_GRAPHQL_ENABLED_APIS=\"metadata\"\n\nrun_hge_with_args serve\nwait_for_port 8080\n\npytest -n 1 -vv --hge-urls \"$HGE_URL\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\" --test-graphql-disabled test_apis_disabled.py\n\nkill_hge_servers\n\nunset HASURA_GRAPHQL_ENABLED_APIS\n\nrun_hge_with_args serve --enabled-apis metadata\nwait_for_port 8080\n\npytest -n 1 -vv --hge-urls \"$HGE_URL\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\" --test-graphql-disabled test_apis_disabled.py\n\nkill_hge_servers\n\necho -e \"\\n$(time_elapsed): <########## TEST GRAPHQL-ENGINE WITH METADATA DISABLED ########>\\n\"\nTEST_TYPE=\"ws-metadata-api-disabled\"\n\nexport HASURA_GRAPHQL_ENABLED_APIS=\"graphql\"\n\nrun_hge_with_args serve\nwait_for_port 8080\n\npytest -n 1 -vv --hge-urls \"$HGE_URL\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\" --test-metadata-disabled test_apis_disabled.py\n\nkill_hge_servers\nunset HASURA_GRAPHQL_ENABLED_APIS\n\nrun_hge_with_args serve --enabled-apis graphql\nwait_for_port 8080\n\npytest -n 1 -vv --hge-urls \"$HGE_URL\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\" --test-metadata-disabled test_apis_disabled.py\n\nkill_hge_servers\n\n# verbose logging tests\necho -e \"\\n$(time_elapsed): <########## TEST GRAPHQL-ENGINE WITH QUERY LOG ########>\\n\"\nTEST_TYPE=\"query-logs\"\n\nexport HASURA_GRAPHQL_ENABLED_LOG_TYPES=\" startup,http-log,webhook-log,websocket-log,query-log\"\n\n#run_hge_with_args serve\n# we are doing this instead of calling run_hge_with_args, because we want to save in a custom log file\ni=$((TIX_FILE_INDEX++))\nexport HPCTIXFILE=\"${OUTPUT_FOLDER}/hpc/graphql-engine-${i}-${TEST_TYPE}.tix\"\nrm -f \"$HPCTIXFILE\"\nTIX_FILES=\"$TIX_FILES:$HPCTIXFILE\"\nset -x\nexport LOGGING_TEST_LOGFILE_PATH=\"$OUTPUT_FOLDER/graphql-engine-verbose-logging.log\"\n\"$GRAPHQL_ENGINE\" serve 2>&1 > \"$LOGGING_TEST_LOGFILE_PATH\" & HGE_PIDS=\"$HGE_PIDS $!\"\nset +x\n\nwait_for_port 8080\n\npytest -n 1 -vv --hge-urls \"$HGE_URL\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\" --test-logging test_logging.py\n\nunset HASURA_GRAPHQL_ENABLED_LOG_TYPES\nkill_hge_servers\n\n# end verbose logging tests\n\n# webhook tests\n\nif [ $EUID != 0 ] ; then\n\techo -e \"SKIPPING webhook based tests, as \\nroot permission is required for running webhook tests (inorder to trust certificate authority).\"\n\tRUN_WEBHOOK_TESTS=false\nfi\n\nif [ \"$RUN_WEBHOOK_TESTS\" == \"true\" ] ; then\n\n\tTEST_TYPE=\"post-webhook\"\n\techo -e \"\\n$(time_elapsed): <########## TEST GRAPHQL-ENGINE WITH ADMIN SECRET & WEBHOOK (GET) #########################>\\n\"\n\n\texport HASURA_GRAPHQL_AUTH_HOOK=\"https://localhost:9090/\"\n\tinit_ssl\n\n\tstart_multiple_hge_servers\n\n\tpython3 webhook.py 9090 \"$OUTPUT_FOLDER/ssl/webhook-key.pem\" \"$OUTPUT_FOLDER/ssl/webhook.pem\" > \"$OUTPUT_FOLDER/webhook.log\" 2>&1  & WH_PID=$!\n\n\twait_for_port 9090\n\n\trun_pytest_parallel --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\" --hge-webhook=\"$HASURA_GRAPHQL_AUTH_HOOK\"\n\n\tkill_hge_servers\n\n\techo -e \"\\n$(time_elapsed): <########## TEST GRAPHQL-ENGINE WITH ADMIN SECRET & WEBHOOK (POST) #########################>\\n\"\n\tTEST_TYPE=\"get-webhook\"\n\texport HASURA_GRAPHQL_AUTH_HOOK_MODE=\"POST\"\n\n\tstart_multiple_hge_servers\n\n\trun_pytest_parallel --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\" --hge-webhook=\"$HASURA_GRAPHQL_AUTH_HOOK\"\n\n\trm /etc/ssl/certs/webhook.crt\n\tupdate-ca-certificates\n\n\tkill_hge_servers\n\n\techo -e \"\\n$(time_elapsed): <########## TEST GRAPHQL-ENGINE WITH ADMIN SECRET & HTTPS INSECURE WEBHOOK (GET) ########>\\n\"\n\tTEST_TYPE=\"insecure-webhook\"\n  \texport HASURA_GRAPHQL_AUTH_HOOK_MODE=\"GET\"\n\n\trun_hge_with_args serve\n\n\twait_for_port 8080\n\n\tpytest -n 1 -vv --hge-urls \"$HGE_URL\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\" --hge-webhook=\"$HASURA_GRAPHQL_AUTH_HOOK\" --test-webhook-insecure test_webhook_insecure.py\n\n\tkill_hge_servers\n\n\techo -e \"\\n$(time_elapsed): <########## TEST GRAPHQL-ENGINE WITH ADMIN_SECRET & HTTPS INSECURE WEBHOOK (POST) ########>\\n\"\n\tTEST_TYPE=\"insecure-webhook-with-admin-secret\"\n  \texport HASURA_GRAPHQL_AUTH_HOOK_MODE=\"POST\"\n\n\trun_hge_with_args serve\n\n\twait_for_port 8080\n\n\tpytest -n 1 -vv --hge-urls \"$HGE_URL\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\" --hge-webhook=\"$HASURA_GRAPHQL_AUTH_HOOK\" --test-webhook-insecure test_webhook_insecure.py\n\n\tkill_hge_servers\n\n\tkill $WH_PID\n\nfi\n\n# allowlist queries test\nunset HASURA_GRAPHQL_AUTH_HOOK\nunset HASURA_GRAPHQL_AUTH_HOOK_MODE\nunset HASURA_GRAPHQL_JWT_SECRET\nunset HASURA_GRAPHQL_ENABLE_ALLOWLIST\n\necho -e \"\\n$(time_elapsed): <########## TEST GRAPHQL-ENGINE WITH ALLOWLIST QUERIES ########> \\n\"\nexport HASURA_GRAPHQL_ENABLE_ALLOWLIST=true\nTEST_TYPE=\"allowlist-queries\"\n\nrun_hge_with_args serve\nwait_for_port 8080\n\npytest -n  1 -vv --hge-urls \"$HGE_URL\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\" --test-allowlist-queries test_allowlist_queries.py\n\nkill_hge_servers\nunset HASURA_GRAPHQL_ENABLE_ALLOWLIST\n\nrun_hge_with_args serve --enable-allowlist\nwait_for_port 8080\n\npytest -n  1 -vv --hge-urls \"$HGE_URL\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\" --test-allowlist-queries test_allowlist_queries.py\n\nkill_hge_servers\n\n# end allowlist queries test\n\n# horizontal scale test\nunset HASURA_GRAPHQL_AUTH_HOOK\nunset HASURA_GRAPHQL_AUTH_HOOK_MODE\nunset HASURA_GRAPHQL_ADMIN_SECRET\n\necho -e \"\\n$(time_elapsed): <########## TEST GRAPHQL-ENGINE WITH HORIZONTAL SCALING ########>\\n\"\nTEST_TYPE=\"horizontal-scaling\"\n\nHASURA_HS_TEST_DB='postgres://postgres:postgres@localhost:6543/hs_hge_test'\n\nif ! psql \"$HASURA_GRAPHQL_DATABASE_URL\" -c \"SELECT 1 FROM pg_database WHERE datname = 'hs_hge_test'\" | grep -q -F '(1 row)'\nthen\n\tpsql \"$HASURA_GRAPHQL_DATABASE_URL\" -c 'CREATE DATABASE hs_hge_test;'\nfi\n\npgUserInfo=$( python3 -c '\nimport os\nfrom urllib.parse import urlparse\nuri = urlparse( os.environ[\"HASURA_GRAPHQL_DATABASE_URL\"] )\nif uri.password:\n    print(\"password=\"+uri.password+\" user=\"+uri.username)\nelse:\n    print(\"user=\"+uri.username)' )\n\npgDbInfo=$(psql \"$HASURA_GRAPHQL_DATABASE_URL\" -c \"SELECT concat(' host=',inet_server_addr(),' port=', inet_server_port(),' dbname=',current_database())\" | sed -n '3 p')\n\n# create pgbouncer user\nid pgbouncer || useradd pgbouncer\ncd $CIRCLECI_FOLDER\nmkdir -p pgbouncer\nchown -R pgbouncer:pgbouncer pgbouncer\n\necho '[databases]\nhs_hge_test = '\"$pgDbInfo\" \"$pgUserInfo\"'\n\n[pgbouncer]\nlisten_port = 6543\nlisten_addr = 127.0.0.1\nlogfile = pgbouncer/pgbouncer.log\npidfile = pgbouncer/pgbouncer.pid\nauth_type = md5\nauth_file = pgbouncer/users.txt\nadmin_users = postgres' > pgbouncer/pgbouncer.ini\n\n# start pgbouncer\npgbouncer -u pgbouncer -d pgbouncer/pgbouncer.ini\n\ncd $PYTEST_ROOT\nsleep 2\n\n# start 1st server\nrun_hge_with_args --database-url \"$HASURA_HS_TEST_DB\" serve\nwait_for_port 8080\n\n# start 2nd server\nrun_hge_with_args --database-url \"$HASURA_HS_TEST_DB\" serve \\\n                  --server-port 8081\nwait_for_port 8081\n\n# run test\npytest -vv --hge-urls \"$HGE_URL\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" --test-hge-scale-url=\"http://localhost:8081\" test_horizontal_scale.py\n\n# Shutdown pgbouncer\npsql \"postgres://postgres:postgres@localhost:6543/pgbouncer\" -c \"SHUTDOWN;\" || true\n\ncd $CIRCLECI_FOLDER\n\n# start pgbouncer again\npgbouncer -u pgbouncer -d pgbouncer/pgbouncer.ini\n\ncd $PYTEST_ROOT\n\n# sleep for 20 seconds\nsleep 20\n\n# run test\npytest -vv --hge-urls \"$HGE_URL\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" --test-hge-scale-url=\"http://localhost:8081\" test_horizontal_scale.py\n\n# Shutdown pgbouncer\npsql \"postgres://postgres:postgres@localhost:6543/pgbouncer\" -c \"SHUTDOWN;\" || true\n\nkill_hge_servers\n\npsql \"$HASURA_GRAPHQL_DATABASE_URL\" -c \"drop database hs_hge_test;\"\nsleep 4\nunset HASURA_HS_TEST_DB\n\n# end horizontal scale test\n\necho -e \"\\n$(time_elapsed): <########## COMBINE ALL HPC REPORTS ########>\\n\"\ncombine_all_hpc_reports || true\n\necho -e \"\\n$(time_elapsed): <########## DONE ########>\\n\"\n", "Authentication using JWT\n========================\n\n.. contents:: Table of contents\n  :backlinks: none\n  :depth: 1\n  :local:\n\nIntroduction\n------------\n\nYou can configure GraphQL engine to use JWT authorization mode to authorize all incoming requests to Hasura GraphQL engine server.\n\nThe idea is - Your auth server will return JWT tokens, which is decoded and\nverified by GraphQL engine to authorize and get metadata about the request\n(``x-hasura-*`` values).\n\n\n.. thumbnail:: ../../../../img/graphql/manual/auth/jwt-auth.png\n\n\nThe JWT is decoded, the signature is verified, then it is asserted that the\ncurrent role of the user (if specified in the request) is in the list of allowed roles.\nIf current role is not specified in the request, then the default role is picked.\nIf the authorization passes, then all of the ``x-hasura-*`` values in the claim\nis used for the permissions system.\n\n.. admonition:: Prerequisite\n   \n   It is mandatory to first :doc:`secure your GraphQL endpoint <../../deployment/securing-graphql-endpoint>` for the JWT mode to take effect.\n\n\nIn JWT mode, on a secured endpoint:\n\n- JWT authentication is **enforced** when ``X-Hasura-Admin-Secret`` header is **not found** in the request.\n- JWT authentication is **skipped** when ``X-Hasura-Admin-Secret`` header **is found** in the request and\n  admin access is granted.\n\n\nTL;DR\n-----\n1. The JWT must contain: ``x-hasura-default-role``, ``x-hasura-allowed-roles``\n   in a custom namespace in the claims.\n2. Other optional ``x-hasura-*`` fields (required as per your defined\n   permissions).\n3. You can send ``x-hasura-role`` as header in the request to indicate a role.\n4. Send the JWT via ``Authorization: Bearer <JWT>`` header.\n\n\nThe Spec\n--------\nWhen your auth server generates the JWT, the custom claims in the JWT **must contain**\nthe following:\n\n1. A ``x-hasura-default-role`` field : indicating the default role of that user i.e. the role that will be\n   used in case ``x-hasura-role`` header is not passed\n2. A ``x-hasura-allowed-roles`` field : a list of allowed roles for the user i.e. acceptable values of the\n   ``x-hasura-role`` header\n\nThe claims in the JWT, can have other ``x-hasura-*`` fields where their values\ncan only be strings. You can use these ``x-hasura-*`` fields in your\npermissions.\n\nNow, the JWT should be sent by the client to Hasura GraphQL engine via the\n``Authorization: Bearer <JWT>`` header.\n\nExample JWT claim:\n\n.. code-block:: json\n\n  {\n    \"sub\": \"1234567890\",\n    \"name\": \"John Doe\",\n    \"admin\": true,\n    \"iat\": 1516239022,\n    \"https://hasura.io/jwt/claims\": {\n      \"x-hasura-allowed-roles\": [\"editor\",\"user\", \"mod\"],\n      \"x-hasura-default-role\": \"user\",\n      \"x-hasura-user-id\": \"1234567890\",\n      \"x-hasura-org-id\": \"123\",\n      \"x-hasura-custom\": \"custom-value\"\n    }\n  }\n\nThis contains standard (``sub``, ``iat`` etc.) and custom (``name``, ``admin``\netc.) JWT claims, as well as Hasura specific claims inside a custom namespace\n(or key) i.e. ``https://hasura.io/jwt/claims``.\n\nThe ``https://hasura.io/jwt/claims`` is the custom namespace where all Hasura\nspecific claims have to be present. This value can be configured in the JWT\nconfig while starting the server.\n\n**Note**: ``x-hasura-default-role`` and ``x-hasura-allowed-roles`` are\nmandatory, while rest of them are optional.\n\n.. note::\n\n   All ``x-hasura-*`` values should be ``String``, they will be converted to the\n   right type automatically.\n\nThe default role can be overridden by ``x-hasura-role`` header, while making a\nrequest.\n\n.. code-block:: http\n\n   POST /v1/graphql HTTP/1.1\n   Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWI...\n   X-Hasura-Role: editor\n\n   ...\n\n\nConfiguring JWT mode\n--------------------\n\nYou can enable JWT mode by using the ``--jwt-secret`` flag or\n``HASURA_GRAPHQL_JWT_SECRET`` environment variable; the value of which is a\nJSON object:\n\n.. code-block:: json\n\n   {\n     \"type\": \"<standard-JWT-algorithms>\",\n     \"key\": \"<optional-key-as-string>\",\n     \"jwk_url\": \"<optional-url-to-refresh-jwks>\",\n     \"claims_namespace\": \"<optional-key-name-in-claims>\",\n     \"claims_format\": \"json|stringified_json\",\n     \"audience\": <optional-string-or-list-of-strings-to-verify-audience>,\n     \"issuer\": \"<optional-string-to-verify-issuer>\"\n   }\n\n``key`` or ``jwk_url``, **one of them has to be present**.\n\n``type``\n^^^^^^^^\nValid values are : ``HS256``, ``HS384``, ``HS512``, ``RS256``,\n``RS384``, ``RS512``. (see https://jwt.io).\n\n``HS*`` is for HMAC-SHA based algorithms. ``RS*`` is for RSA based signing. For\nexample, if your auth server is using HMAC-SHA256 for signing the JWTs, then\nuse ``HS256``. If it is using RSA with 512-bit keys, then use ``RS512``. EC\npublic keys are not yet supported.\n\n``key``\n^^^^^^^\n- In case of symmetric key (i.e. HMAC based key), the key as it is. (e.g. -\n  \"abcdef...\"). The key must be long enough for the algorithm chosen,\n  (e.g. for HS256 it must be at least 32 characters long).\n- In case of asymmetric keys (RSA etc.), only the public key, in a PEM encoded\n  string or as a X509 certificate.\n\nThis is an optional field. You can also provide a URL to fetch JWKs from using\nthe ``jwk_url`` field.\n\n``jwk_url``\n^^^^^^^^^^^\nA URL where a provider publishes their JWKs (which are used for signing the\nJWTs). The URL **must** publish the JWKs in the standard format as described in\nhttps://tools.ietf.org/html/rfc7517\n\nThis is an optional field. You can also provide the key (certificate, PEM\nencoded public key) as string as well - under the ``key`` field.\n\n**Rotating JWKs**:\n\nSome providers rotate their JWKs (E.g - Firebase). If the provider sends an\n``Expires`` header with the response of JWK, then graphql-engine will refresh\nthe JWKs automatically. If the provider does not send ``Expires`` header, the\nJWKs are not refreshed.\n\n**Example**:\n\n- Auth0 publishes their JWK url at: ``https://<YOUR_AUTH0_DOMAIN>.auth0.com``.\n  But Auth0 has a bug. See known issues: :ref:`auth0-issues`.\n- Firebase publishes their JWK url at:\n  ``https://www.googleapis.com/service_accounts/v1/jwk/securetoken@system.gserviceaccount.com``.\n\n``claims_namespace``\n^^^^^^^^^^^^^^^^^^^^\nThis is an optional field. You can specify the key name\ninside which the Hasura specific claims will be present. E.g. - ``https://mydomain.com/claims``.\n\n**Default value** is: ``https://hasura.io/jwt/claims``.\n\n\n``claims_format``\n^^^^^^^^^^^^^^^^^\nThis is an optional field, with only the following possible values:\n- ``json``\n- ``stringified_json``\n\nDefault is ``json``.\n\nThis is to indicate that if the hasura specific claims are a regular JSON object\nor stringified JSON\n\nThis is required because providers like AWS Cognito only allows strings in the\nJWT claims. `See #1176 <https://github.com/hasura/graphql-engine/issues/1176>`_.\n\nExample:-\n\nIf ``claims_format`` is ``json`` then JWT claims should look like:\n\n.. code-block:: json\n\n  {\n    \"sub\": \"1234567890\",\n    \"name\": \"John Doe\",\n    \"admin\": true,\n    \"iat\": 1516239022,\n    \"https://hasura.io/jwt/claims\": {\n      \"x-hasura-allowed-roles\": [\"editor\",\"user\", \"mod\"],\n      \"x-hasura-default-role\": \"user\",\n      \"x-hasura-user-id\": \"1234567890\",\n      \"x-hasura-org-id\": \"123\",\n      \"x-hasura-custom\": \"custom-value\"\n    }\n  }\n\n\nIf ``claims_format`` is ``stringified_json`` then JWT claims should look like:\n\n.. code-block:: json\n\n  {\n    \"sub\": \"1234567890\",\n    \"name\": \"John Doe\",\n    \"admin\": true,\n    \"iat\": 1516239022,\n    \"https://hasura.io/jwt/claims\": \"{\\\"x-hasura-allowed-roles\\\":[\\\"editor\\\",\\\"user\\\",\\\"mod\\\"],\\\"x-hasura-default-role\\\":\\\"user\\\",\\\"x-hasura-user-id\\\":\\\"1234567890\\\",\\\"x-hasura-org-id\\\":\\\"123\\\",\\\"x-hasura-custom\\\":\\\"custom-value\\\"}\"\n  }\n\n\n``audience``\n^^^^^^^^^^^^\nThis is an optional field. Certain providers might set a claim which indicates\nthe intended audience for the JWT. This can be checked by setting this field.\n\nWhen this field is set, during the verification process of JWT, the ``aud``\nclaim in the JWT will be checked if it is equal to the ``audience`` field given\nin the configuration.\n\nSee `RFC <https://tools.ietf.org/html/rfc7519#section-4.1.3>`__ for more details.\n\nThis field can be a string, or a list of strings.\n\nExamples:\n\n.. code-block:: json\n\n   {\n     \"type\": \"RS512\",\n     \"jwk_url\": \"https://......\",\n     \"audience\": \"myapp-1234\"\n     ...\n   }\n\nor\n\n.. code-block:: json\n\n   {\n     \"type\": \"RS512\",\n     \"jwk_url\": \"https://......\",\n     \"audience\": [\"myapp-1234\", \"myapp-6789\"]\n     ...\n   }\n\n\n``issuer``\n^^^^^^^^^^\nThis is an optional field. It takes a string value.\n\nWhen this field is set, during the verification process of JWT, the ``iss``\nclaim in the JWT will be checked if it is equal to the ``issuer`` field given\nin the configuration.\n\nSee `RFC <https://tools.ietf.org/html/rfc7519#section-4.1.1>`__ for more details.\n\nExamples:\n\n.. code-block:: json\n\n   {\n     \"type\": \"RS512\",\n     \"jwk_url\": \"https://......\",\n     \"issuer\": \"https://my-auth-server.com\"\n     ...\n   }\n\n\nExamples\n^^^^^^^^\n\nHMAC-SHA based\n++++++++++++++\nYour auth server is using HMAC-SHA algorithms to sign JWTs, and is using a\n256-bit key. In this case, the JWT config will look like:\n\n.. code-block:: json\n\n   {\n     \"type\":\"HS256\",\n     \"key\": \"3EK6FD+o0+c7tzBNVfjpMkNDi2yARAAKzQlk8O2IKoxQu4nF7EdAh8s3TwpHwrdWT6R\"\n   }\n\nThe ``key`` is the actual shared secret, which is used by Hasura and the external auth server.\n\nRSA based\n+++++++++\nIf your auth server is using RSA to sign JWTs, and is using a 512-bit key. In this case,\nthe JWT config needs to have the only the public key.\n\n**Example 1**: public key in PEM format (not OpenSSH format):\n\n.. code-block:: json\n\n    {\n      \"type\":\"RS512\",\n      \"key\": \"-----BEGIN PUBLIC KEY-----\\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDdlatRjRjogo3WojgGHFHYLugd\\nUWAY9iR3fy4arWNA1KoS8kVw33cJibXr8bvwUAUparCwlvdbH6dvEOfou0/gCFQs\\nHUfQrSDv+MuSUMAe8jzKE4qW+jK+xQU9a03GUnKHkkle+Q0pX/g6jXZ7r1/xAK5D\\no2kQ+X5xK9cipRgEKwIDAQAB\\n-----END PUBLIC KEY-----\\n\"\n    }\n\n**Example 2**: public key as X509 certificate:\n\n.. code-block:: json\n\n    {\n      \"type\":\"RS512\",\n      \"key\": \"-----BEGIN CERTIFICATE-----\\nMIIDHDCCAgSgAwIBAgIINw9gva8BPPIwDQYJKoZIhvcNAQEFBQAwMTEvMC0GA1UE\\nAxMmc2VjdXJldG9rZW4uc3lzdGVtLmdzZXJ2aWNlYWNjb3VudC5jb20wHhcNMTgQt7dIsMTIU9k1SUrFviZOGnmHWtIAw\\nmtYBcM9I0f9/ka45JIRp5Y1NKpAMFSShs7Wv0m1JS1kXQHdJsPSmjmDKcwnBe3R/\\nTU3foRRywR/3AJRM15FNjTqvUm7TeaW16LkkRoECAwEAAaM4MDYwDAYDVR0TAQH/\\nBAIwADAOBgNVHQ8BAf8EBAMCB4AwFgYDVR0lAQH/BAwwCgYIKwYBBQUHAwIwDQYJ\\nKoZIhvcNAQEFBQADggEBADfY2DEmc2gb8/pqMNWHYq/nTYfJPpK4VA9A0lFTNeoq\\nzmnbGwhKj24X+Nw8trsvkrKxHvCI1alDgBaCyzjGGvgOrh8X0wLtymp1yj6PWwee\\nR2ZPdUaB62TCzO0iRv7W6o39ey+mU/FyYRtxF0ecxG2a0KNsIyFkciXUAeC5UVDo\\nBNp678/SDDx9Ltuxc6h56a/hpBGf9Yzhr0RvYy3DmjBs6eopiGFmjnOKNxQrZ5t2\\n339JWR+yiGEAtoHqk/fINMf1An6Rung1xYowrm4guhCIVi5unAvQ89fq0I6mzPg6\\nLhTpeP0o+mVYrBmtYVpDpv0e71cfYowSJCCkod/9YbY=\\n-----END CERTIFICATE-----\"\n    }\n\n**Example 3**: public key published as JWKs:\n\n.. code-block:: json\n\n    {\n      \"type\":\"RS512\",\n      \"jwk_url\": \"https://www.googleapis.com/service_accounts/v1/jwk/securetoken@system.gserviceaccount.com\"\n    }\n\n\nRunning with JWT\n^^^^^^^^^^^^^^^^\nUsing the flag:\n\n.. code-block:: shell\n\n  $ docker run -p 8080:8080 \\\n      hasura/graphql-engine:latest \\\n      graphql-engine \\\n      --database-url postgres://username:password@hostname:port/dbname \\\n      serve \\\n      --admin-secret myadminsecretkey \\\n      --jwt-secret '{\"type\":\"HS256\", \"key\": \"3EK6FD+o0+c7tzBNVfjpMkNDi2yARAAKzQlk8O2IKoxQu4nF7EdAh8s3TwpHwrdWT6R\"}'\n\nUsing env vars:\n\n.. code-block:: shell\n\n  $ docker run -p 8080:8080 \\\n      -e HASURA_GRAPHQL_ADMIN_SECRET=\"myadminsecretkey\" \\\n      -e HASURA_GRAPHQL_JWT_SECRET='{\"type\":\"RS512\", \"key\": \"-----BEGIN PUBLIC KEY-----\\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDdlatRjRjogo3WojgGHFHYLugd\\nUWAY9iR3fy4arWNA1KoS8kVw33cJibXr8bvwUAUparCwlvdbH6dvEOfou0/gCFQs\\nHUfQrSDv+MuSUMAe8jzKE4qW+jK+xQU9a03GUnKHkkle+Q0pX/g6jXZ7r1/xAK5D\\no2kQ+X5xK9cipRgEKwIDAQAB\\n-----END PUBLIC KEY-----\\n\"}' \\\n      hasura/graphql-engine:latest \\\n      graphql-engine \\\n      --database-url postgres://username:password@hostname:port/dbname \\\n      serve\n\n\nPopular providers and known issues\n----------------------------------\n\nFirebase\n^^^^^^^^\nThis page of Firebase `docs <https://firebase.google.com/docs/auth/admin/verify-id-tokens#verify_id_tokens_using_a_third-party_jwt_library>`__\nmentions that JWKs are published under:\n\nhttps://www.googleapis.com/robot/v1/metadata/x509/securetoken@system.gserviceaccount.com .\n\nBut that is a non-standard format. Firebase also publishes the same certificates\nas proper JWK format under:\n\nhttps://www.googleapis.com/service_accounts/v1/jwk/securetoken@system.gserviceaccount.com .\n\nIf you are using Firebase and Hasura, use this config:\n\n.. code-block:: json\n\n   {\n     \"type\":\"RS256\",\n     \"jwk_url\": \"https://www.googleapis.com/service_accounts/v1/jwk/securetoken@system.gserviceaccount.com\",\n     \"audience\": \"<firebase-project-id>\",\n     \"issuer\": \"https://securetoken.google.com/<firebase-project-id>\"\n   }\n\n\n.. _auth0-issues:\n\nAuth0\n^^^^^\n\nRefer the :doc:`Auth0 JWT Integration guide <../../guides/integrations/auth0-jwt>` for a full integration guide\nwith Auth0\n\nAuth0 publishes their JWK under:\n\n``https://<your-auth0-domain>.auth0.com/.well-known/jwks.json``\n\nBut they have a `bug where the certificate thumbprint does not match\n<https://community.auth0.com/t/certificate-thumbprint-is-longer-than-20-bytes/7794/3>`__.\nHence, currently this URL does not work with Hasura.\n\nCurrent workaround is - download the X590 certificate from:\n\n``https://<your-auth0-domain>.auth0.com/pem``\n\nAnd use it in the ``key`` field:\n\n.. code-block:: json\n\n        {\n          \"type\":\"RS512\",\n          \"key\": \"-----BEGIN CERTIFICATE-----\n    MIIDDTCAfWgAwIBAgIJhNlZ11IDrxbMA0GCSqSIb3DQEBCwUAMCQxIjAgBgNV\n    BAMTGXlc3QtaGdlLWp3C5ldS5hdXRoMC5jb20HhcNMTgwNzMwMTM1MjM1WhcN\n    MzIwND3MTM1MjM1WjAkSIwIAYDVQQDExl0ZXNLWhnZS1qd3QuZXUuYXV0aDAu\n    Y29tMIBIjANBgkqhkiGw0BAQEFAAOCAQ8AMIICgKCAQEA13CivdSkNzRnOnR5\n    ZNiReD+AgbL7BWjRiw3RwjxRp5PYzvAGuj94yR6LRh3QybYtsMFbSg5J7fNq6\n    Ld6yMpMrUu8CBOnYY456b/2jlf+Vp8vEQuKvPOOw8Ev6x7X3blcuXCELSwyL3\n    AGHq9OP2RV6V6CIE863zzuYH5HDLzU35oMZqogJVRJM0+6besH6TnSTNiA7xi\n    BAqFaiRNQRVi1CAUa0bkN1XRp4AFy7d63VldOsM+8QnCNHySdDr1XevVuq6DK\n    LQyGexFy4niALgHV0Q7A+xP1c2G6rJomZmn4j1avnlBpU87E58JMrRHOCj+5m\n    Xj22/QDAQABo0IwQDAPgNVHRMBAf8EBTADAQHMB0GA1UdDgQWBBT6FvNkuUgu\n    tk3OYQi4lo5aOgwazAOgNVHQ8BAf8EBAMCAoQDQYJKoZIhvcNAQELBQADggEB\n    ADCLj+L22pEKyqaIUlhUJh7DAiDSLafy0fw56CntzPhqiZVVRlhxeAKidkCLV\n    r9IEbRuxUoXiQSezPqM//9xHegMp0f2VauVCFg7EpUanYwvqFqjy9LWgH+SBz\n    4uroLSZ5g1EPsHtlArLChA90caTX4e7Z7Xlu8G2kHRJB5nC7ycdbMUvEWBMeI\n    tn/pcbmZ3/vlgj4UTEnURe2UPmSJpxmPwXqBcvwdKHRMgFXhZxojWCi0z4ftf\n    f8t8UJIcbEblnkYe7wzYy8tOXoMMHqGSisCdkp/866029rJsKbwd8rVIyKNC5\n    frGYaw+0cxO6/WvSir0eA=\n    -----END CERTIFICATE-----\n    \"\n        }\n\nGenerating JWT Config\n---------------------\n\nThe JWT Config to be used in env ``HASURA_GRAPHQL_JWT_SECRET`` or ``--jwt-secret`` flag can be generated using:\nhttps://hasura.io/jwt-config.\n\n**Currently the UI supports generating config for Auth0 and Firebase**.\n\nThe config generated from this page can be directly pasted in yaml files and command line arguments as it takes\ncare of escaping new lines.\n\n.. thumbnail:: ../../../../img/graphql/manual/auth/jwt-config-generated.png\n   :width: 75%\n\nAuth JWT Examples\n-----------------\n\nHere are some sample apps that use JWT authorization. You can follow the instructions in the READMEs of the\nrepositories to get started.\n\n- `Auth0 JWT example <https://github.com/hasura/graphql-engine/tree/master/community/sample-apps/todo-auth0-jwt>`__:\n  A todo app that uses Hasura GraphQL Engine and Auth0 JWT\n\n- `Firebase JWT example <https://github.com/hasura/graphql-engine/tree/master/community/sample-apps/firebase-jwt>`__:\n  Barebones example to show how to have Firebase Auth integrated with Hasura JWT mode\n", "module Hasura.Server.Auth\n  ( getUserInfo\n  , getUserInfoWithExpTime\n  , AuthMode(..)\n  , mkAuthMode\n  , AdminSecret (..)\n  , AuthHookType(..)\n  , AuthHookG (..)\n  , AuthHook\n  -- JWT related\n  , RawJWT\n  , JWTConfig (..)\n  , JWTCtx (..)\n  , JWKSet (..)\n  , processJwt\n  , updateJwkRef\n  , jwkRefreshCtrl\n  ) where\n\nimport           Control.Exception      (try)\nimport           Control.Lens\nimport           Data.Aeson\nimport           Data.IORef             (newIORef)\nimport           Data.Time.Clock        (UTCTime)\n\nimport qualified Data.Aeson             as J\nimport qualified Data.ByteString.Lazy   as BL\nimport qualified Data.HashMap.Strict    as Map\nimport qualified Data.Text              as T\nimport qualified Network.HTTP.Client    as H\nimport qualified Network.HTTP.Types     as N\nimport qualified Network.Wreq           as Wreq\n\nimport           Hasura.HTTP\nimport           Hasura.Logging\nimport           Hasura.Prelude\nimport           Hasura.RQL.Types\nimport           Hasura.Server.Auth.JWT\nimport           Hasura.Server.Logging\nimport           Hasura.Server.Utils\n\nimport qualified Hasura.Logging         as L\n\n\nnewtype AdminSecret\n  = AdminSecret { getAdminSecret :: T.Text }\n  deriving (Show, Eq)\n\ndata AuthHookType\n  = AHTGet\n  | AHTPost\n  deriving (Eq)\n\ninstance Show AuthHookType where\n  show AHTGet  = \"GET\"\n  show AHTPost = \"POST\"\n\ndata AuthHookG a b\n  = AuthHookG\n  { ahUrl  :: !a\n  , ahType :: !b\n  } deriving (Show, Eq)\n\ntype AuthHook = AuthHookG T.Text AuthHookType\n\ndata AuthMode\n  = AMNoAuth\n  | AMAdminSecret !AdminSecret !(Maybe RoleName)\n  | AMAdminSecretAndHook !AdminSecret !AuthHook\n  | AMAdminSecretAndJWT !AdminSecret !JWTCtx !(Maybe RoleName)\n  deriving (Show, Eq)\n\nmkAuthMode\n  :: ( MonadIO m\n     , MonadError T.Text m\n     )\n  => Maybe AdminSecret\n  -> Maybe AuthHook\n  -> Maybe JWTConfig\n  -> Maybe RoleName\n  -> H.Manager\n  -> LoggerCtx\n  -> m AuthMode\nmkAuthMode mAdminSecret mWebHook mJwtSecret mUnAuthRole httpManager lCtx =\n  case (mAdminSecret, mWebHook, mJwtSecret) of\n    (Nothing,  Nothing,   Nothing)      -> return AMNoAuth\n    (Just key, Nothing,   Nothing)      -> return $ AMAdminSecret key mUnAuthRole\n    (Just key, Just hook, Nothing)      -> unAuthRoleNotReqForWebHook >>\n                                           return (AMAdminSecretAndHook key hook)\n    (Just key, Nothing,   Just jwtConf) -> do\n      jwtCtx <- mkJwtCtx jwtConf httpManager lCtx\n      return $ AMAdminSecretAndJWT key jwtCtx mUnAuthRole\n\n    (Nothing, Just _, Nothing)     -> throwError $\n      \"Fatal Error : --auth-hook (HASURA_GRAPHQL_AUTH_HOOK)\" <> requiresAdminScrtMsg\n    (Nothing, Nothing, Just _)     -> throwError $\n      \"Fatal Error : --jwt-secret (HASURA_GRAPHQL_JWT_SECRET)\" <> requiresAdminScrtMsg\n    (Nothing, Just _, Just _)     -> throwError\n      \"Fatal Error: Both webhook and JWT mode cannot be enabled at the same time\"\n    (Just _, Just _, Just _)     -> throwError\n      \"Fatal Error: Both webhook and JWT mode cannot be enabled at the same time\"\n  where\n    requiresAdminScrtMsg =\n      \" requires --admin-secret (HASURA_GRAPHQL_ADMIN_SECRET) or \"\n      <> \" --access-key (HASURA_GRAPHQL_ACCESS_KEY) to be set\"\n    unAuthRoleNotReqForWebHook =\n      when (isJust mUnAuthRole) $ throwError $\n        \"Fatal Error: --unauthorized-role (HASURA_GRAPHQL_UNAUTHORIZED_ROLE) is not allowed\"\n        <> \" when --auth-hook (HASURA_GRAPHQL_AUTH_HOOK) is set\"\n\nmkJwtCtx\n  :: ( MonadIO m\n     , MonadError T.Text m\n     )\n  => JWTConfig\n  -> H.Manager\n  -> LoggerCtx\n  -> m JWTCtx\nmkJwtCtx conf httpManager loggerCtx = do\n  jwkRef <- case jcKeyOrUrl conf of\n    Left jwk  -> liftIO $ newIORef (JWKSet [jwk])\n    Right url -> do\n      ref <- liftIO $ newIORef $ JWKSet []\n      let logger = mkLogger loggerCtx\n      mTime <- updateJwkRef logger httpManager url ref\n      case mTime of\n        Nothing -> return ref\n        Just t -> do\n          jwkRefreshCtrl logger httpManager url ref t\n          return ref\n  let claimsFmt = fromMaybe JCFJson (jcClaimsFormat conf)\n  return $ JWTCtx jwkRef (jcClaimNs conf) (jcAudience conf) claimsFmt\n\nmkUserInfoFromResp\n  :: (MonadIO m, MonadError QErr m)\n  => L.Logger\n  -> T.Text\n  -> N.StdMethod\n  -> N.Status\n  -> BL.ByteString\n  -> m UserInfo\nmkUserInfoFromResp logger url method statusCode respBody\n  | statusCode == N.status200 =\n    case eitherDecode respBody of\n      Left e -> do\n        logError\n        throw500 $ \"Invalid response from authorization hook: \" <> T.pack e\n      Right rawHeaders -> getUserInfoFromHdrs rawHeaders\n\n  | statusCode == N.status401 = do\n    logError\n    throw401 \"Authentication hook unauthorized this request\"\n\n  | otherwise = do\n    logError\n    throw500 \"Invalid response from authorization hook\"\n  where\n    getUserInfoFromHdrs rawHeaders = do\n      let usrVars = mkUserVars $ Map.toList rawHeaders\n      case roleFromVars usrVars of\n        Nothing -> do\n          logError\n          throw500 \"missing x-hasura-role key in webhook response\"\n        Just rn -> do\n          logWebHookResp L.LevelInfo Nothing\n          return $ mkUserInfo rn usrVars\n\n    logError =\n      logWebHookResp L.LevelError $ Just respBody\n\n    logWebHookResp logLevel mResp =\n      liftIO $ L.unLogger logger $ WebHookLog logLevel (Just statusCode)\n        url method Nothing $ fmap (bsToTxt . BL.toStrict) mResp\n\nuserInfoFromAuthHook\n  :: (MonadIO m, MonadError QErr m)\n  => L.Logger\n  -> H.Manager\n  -> AuthHook\n  -> [N.Header]\n  -> m UserInfo\nuserInfoFromAuthHook logger manager hook reqHeaders = do\n  res <- liftIO $ try $ bool withGET withPOST isPost\n  resp <- either logAndThrow return res\n  let status = resp ^. Wreq.responseStatus\n      respBody = resp ^. Wreq.responseBody\n\n  mkUserInfoFromResp logger urlT method status respBody\n  where\n    mkOptions = wreqOptions manager\n    AuthHookG urlT ty = hook\n    isPost = case ty of\n      AHTPost -> True\n      AHTGet  -> False\n    method = bool N.GET N.POST isPost\n\n    withGET = Wreq.getWith (mkOptions filteredHeaders) $\n              T.unpack urlT\n\n    contentType = (\"Content-Type\", \"application/json\")\n    postHdrsPayload = J.toJSON $ Map.fromList $ hdrsToText reqHeaders\n    withPOST = Wreq.postWith (mkOptions [contentType]) (T.unpack urlT) $\n               object [\"headers\" J..= postHdrsPayload]\n\n    logAndThrow err = do\n      liftIO $ L.unLogger logger $\n        WebHookLog L.LevelError Nothing urlT method\n        (Just $ HttpException err) Nothing\n      throw500 \"Internal Server Error\"\n\n    filteredHeaders = flip filter reqHeaders $ \\(n, _) ->\n      n `notElem` commonClientHeadersIgnored\n\ngetUserInfo\n  :: (MonadIO m, MonadError QErr m)\n  => L.Logger\n  -> H.Manager\n  -> [N.Header]\n  -> AuthMode\n  -> m UserInfo\ngetUserInfo l m r a = fst <$> getUserInfoWithExpTime l m r a\n\ngetUserInfoWithExpTime\n  :: (MonadIO m, MonadError QErr m)\n  => L.Logger\n  -> H.Manager\n  -> [N.Header]\n  -> AuthMode\n  -> m (UserInfo, Maybe UTCTime)\ngetUserInfoWithExpTime logger manager rawHeaders = \\case\n\n  AMNoAuth -> return (userInfoFromHeaders, Nothing)\n\n  AMAdminSecret adminScrt unAuthRole ->\n    case adminSecretM of\n      Just givenAdminScrt ->\n        withNoExpTime $ userInfoWhenAdminSecret adminScrt givenAdminScrt\n      Nothing             ->\n        withNoExpTime $ userInfoWhenNoAdminSecret unAuthRole\n\n  AMAdminSecretAndHook accKey hook ->\n    whenAdminSecretAbsent accKey $\n      withNoExpTime $ userInfoFromAuthHook logger manager hook rawHeaders\n\n  AMAdminSecretAndJWT accKey jwtSecret unAuthRole ->\n    whenAdminSecretAbsent accKey (processJwt jwtSecret rawHeaders unAuthRole)\n\n  where\n    -- when admin secret is absent, run the action to retrieve UserInfo, otherwise\n    -- adminsecret override\n    whenAdminSecretAbsent ak action =\n      maybe action (withNoExpTime . userInfoWhenAdminSecret ak) adminSecretM\n\n    adminSecretM= foldl1 (<|>) $\n      map (`getVarVal` usrVars) [adminSecretHeader, deprecatedAccessKeyHeader]\n\n    usrVars = mkUserVars $ hdrsToText rawHeaders\n\n    userInfoFromHeaders =\n      case roleFromVars usrVars of\n        Just rn -> mkUserInfo rn usrVars\n        Nothing -> mkUserInfo adminRole usrVars\n\n    userInfoWhenAdminSecret key reqKey = do\n      when (reqKey /= getAdminSecret key) $ throw401 $\n        \"invalid \" <> adminSecretHeader <> \"/\" <> deprecatedAccessKeyHeader\n      return userInfoFromHeaders\n\n    userInfoWhenNoAdminSecret = \\case\n      Nothing -> throw401 $ adminSecretHeader <> \"/\"\n                 <>  deprecatedAccessKeyHeader <> \" required, but not found\"\n      Just role -> return $ mkUserInfo role usrVars\n\n    withNoExpTime a = (, Nothing) <$> a\n", "module Hasura.Server.Auth.JWT\n  ( processJwt\n  , RawJWT\n  , JWTConfig (..)\n  , JWTCtx (..)\n  , JWKSet (..)\n  , JWTClaimsFormat (..)\n  , updateJwkRef\n  , jwkRefreshCtrl\n  , defaultClaimNs\n  ) where\n\nimport           Control.Arrow                   (first)\nimport           Control.Exception               (try)\nimport           Control.Lens\nimport           Control.Monad                   (when)\nimport           Crypto.JWT\nimport           Data.IORef                      (IORef, modifyIORef, readIORef)\n\nimport           Data.List                       (find)\nimport           Data.Time.Clock                 (NominalDiffTime, UTCTime,\n                                                  diffUTCTime, getCurrentTime)\nimport           Data.Time.Format                (defaultTimeLocale, parseTimeM)\nimport           Network.URI                     (URI)\n\nimport           Hasura.HTTP\nimport           Hasura.Logging                  (LogLevel (..), Logger (..))\nimport           Hasura.Prelude\nimport           Hasura.RQL.Types\nimport           Hasura.Server.Auth.JWT.Internal (parseHmacKey, parseRsaKey)\nimport           Hasura.Server.Auth.JWT.Logging\nimport           Hasura.Server.Utils             (diffTimeToMicro,\n                                                  userRoleHeader)\n\nimport qualified Control.Concurrent              as C\nimport qualified Data.Aeson                      as A\nimport qualified Data.Aeson.Casing               as A\nimport qualified Data.Aeson.TH                   as A\nimport qualified Data.ByteString.Lazy            as BL\nimport qualified Data.ByteString.Lazy.Char8      as BLC\nimport qualified Data.CaseInsensitive            as CI\nimport qualified Data.HashMap.Strict             as Map\nimport qualified Data.String.Conversions         as CS\nimport qualified Data.Text                       as T\nimport qualified Data.Text.Encoding              as T\nimport qualified Network.HTTP.Client             as HTTP\nimport qualified Network.HTTP.Types              as HTTP\nimport qualified Network.Wreq                    as Wreq\n\n\nnewtype RawJWT = RawJWT BL.ByteString\n\ndata JWTClaimsFormat\n  = JCFJson\n  | JCFStringifiedJson\n  deriving (Show, Eq)\n\n$(A.deriveJSON A.defaultOptions { A.sumEncoding = A.ObjectWithSingleField\n                                , A.constructorTagModifier = A.snakeCase . drop 3\n                                } ''JWTClaimsFormat)\n\ndata JWTConfig\n  = JWTConfig\n  { jcType         :: !T.Text\n  , jcKeyOrUrl     :: !(Either JWK URI)\n  , jcClaimNs      :: !(Maybe T.Text)\n  , jcAudience     :: !(Maybe T.Text)\n  , jcClaimsFormat :: !(Maybe JWTClaimsFormat)\n  -- , jcIssuer   :: !(Maybe T.Text)\n  } deriving (Show, Eq)\n\ndata JWTCtx\n  = JWTCtx\n  { jcxKey          :: !(IORef JWKSet)\n  , jcxClaimNs      :: !(Maybe T.Text)\n  , jcxAudience     :: !(Maybe T.Text)\n  , jcxClaimsFormat :: !JWTClaimsFormat\n  } deriving (Eq)\n\ninstance Show JWTCtx where\n  show (JWTCtx _ nsM audM cf) =\n    show [\"<IORef JWKSet>\", show nsM, show audM, show cf]\n\ndata HasuraClaims\n  = HasuraClaims\n  { _cmAllowedRoles :: ![RoleName]\n  , _cmDefaultRole  :: !RoleName\n  } deriving (Show, Eq)\n$(A.deriveJSON (A.aesonDrop 3 A.snakeCase) ''HasuraClaims)\n\nallowedRolesClaim :: T.Text\nallowedRolesClaim = \"x-hasura-allowed-roles\"\n\ndefaultRoleClaim :: T.Text\ndefaultRoleClaim = \"x-hasura-default-role\"\n\ndefaultClaimNs :: T.Text\ndefaultClaimNs = \"https://hasura.io/jwt/claims\"\n\n-- | create a background thread to refresh the JWK\njwkRefreshCtrl\n  :: (MonadIO m)\n  => Logger\n  -> HTTP.Manager\n  -> URI\n  -> IORef JWKSet\n  -> NominalDiffTime\n  -> m ()\njwkRefreshCtrl lggr mngr url ref time =\n  void $ liftIO $ C.forkIO $ do\n    C.threadDelay $ diffTimeToMicro time\n    forever $ do\n      res <- runExceptT $ updateJwkRef lggr mngr url ref\n      mTime <- either (const $ return Nothing) return res\n      C.threadDelay $ maybe (60 * aSecond) diffTimeToMicro mTime\n  where\n    aSecond = 1000 * 1000\n\n\n-- | Given a JWK url, fetch JWK from it and update the IORef\nupdateJwkRef\n  :: ( MonadIO m\n     , MonadError T.Text m)\n  => Logger\n  -> HTTP.Manager\n  -> URI\n  -> IORef JWKSet\n  -> m (Maybe NominalDiffTime)\nupdateJwkRef (Logger logger) manager url jwkRef = do\n  let options = wreqOptions manager []\n      urlT    = T.pack $ show url\n      infoMsg = \"refreshing JWK from endpoint: \" <> urlT\n  liftIO $ logger $ JwkRefreshLog LevelInfo infoMsg Nothing\n  res  <- liftIO $ try $ Wreq.getWith options $ show url\n  resp <- either logAndThrowHttp return res\n  let status = resp ^. Wreq.responseStatus\n      respBody = resp ^. Wreq.responseBody\n\n  when (status ^. Wreq.statusCode /= 200) $ do\n    let respBodyT = Just $ CS.cs respBody\n        errMsg = \"Non-200 response on fetching JWK from: \" <> urlT\n        httpErr = Just (JwkRefreshHttpError (Just status) urlT Nothing respBodyT)\n    logAndThrow errMsg httpErr\n\n  let parseErr e = \"Error parsing JWK from url (\" <> urlT <> \"): \" <> T.pack e\n  jwkset <- either (\\e -> logAndThrow (parseErr e) Nothing) return $\n    A.eitherDecode respBody\n  liftIO $ modifyIORef jwkRef (const jwkset)\n\n  let mExpiresT = resp ^? Wreq.responseHeader \"Expires\"\n  forM mExpiresT $ \\expiresT -> do\n    let expiresE = parseTimeM True defaultTimeLocale timeFmt $ CS.cs expiresT\n    expires  <- either (`logAndThrow` Nothing) return expiresE\n    currTime <- liftIO getCurrentTime\n    return $ diffUTCTime expires currTime\n\n  where\n    logAndThrow :: (MonadIO m, MonadError T.Text m) => T.Text -> Maybe JwkRefreshHttpError -> m a\n    logAndThrow err httpErr = do\n      liftIO $ logger $ JwkRefreshLog (LevelOther \"critical\") err httpErr\n      throwError err\n\n    logAndThrowHttp :: (MonadIO m, MonadError T.Text m) => HTTP.HttpException -> m a\n    logAndThrowHttp err = do\n      let httpErr = JwkRefreshHttpError Nothing (T.pack $ show url)\n                    (Just $ HttpException err) Nothing\n          errMsg = \"Error fetching JWK: \" <> T.pack (show err)\n      logAndThrow errMsg (Just httpErr)\n\n    timeFmt = \"%a, %d %b %Y %T GMT\"\n\n\n-- | Process the request headers to verify the JWT and extract UserInfo from it\nprocessJwt\n  :: ( MonadIO m\n     , MonadError QErr m)\n  => JWTCtx\n  -> HTTP.RequestHeaders\n  -> Maybe RoleName\n  -> m (UserInfo, Maybe UTCTime)\nprocessJwt jwtCtx headers mUnAuthRole =\n  maybe withoutAuthZHeader withAuthZHeader mAuthZHeader\n  where\n    mAuthZHeader = find (\\h -> fst h == CI.mk \"Authorization\") headers\n\n    withAuthZHeader (_, authzHeader) =\n      processAuthZHeader jwtCtx headers $ BL.fromStrict authzHeader\n\n    withoutAuthZHeader = do\n      unAuthRole <- maybe missingAuthzHeader return mUnAuthRole\n      return $ (, Nothing) $\n        mkUserInfo unAuthRole $ mkUserVars $ hdrsToText headers\n\n    missingAuthzHeader =\n      throw400 InvalidHeaders \"Missing Authorization header in JWT authentication mode\"\n\nprocessAuthZHeader\n  :: ( MonadIO m\n     , MonadError QErr m)\n  => JWTCtx\n  -> HTTP.RequestHeaders\n  -> BLC.ByteString\n  -> m (UserInfo, Maybe UTCTime)\nprocessAuthZHeader jwtCtx headers authzHeader = do\n  -- try to parse JWT token from Authorization header\n  jwt <- parseAuthzHeader\n\n  -- verify the JWT\n  claims <- liftJWTError invalidJWTError $ verifyJwt jwtCtx $ RawJWT jwt\n\n  let claimsNs  = fromMaybe defaultClaimNs $ jcxClaimNs jwtCtx\n      claimsFmt = jcxClaimsFormat jwtCtx\n      expTimeM = fmap (\\(NumericDate t) -> t) $ claims ^. claimExp\n\n  -- see if the hasura claims key exist in the claims map\n  let mHasuraClaims = Map.lookup claimsNs $ claims ^. unregisteredClaims\n  hasuraClaimsV <- maybe claimsNotFound return mHasuraClaims\n\n  -- get hasura claims value as an object. parse from string possibly\n  hasuraClaims <- parseObjectFromString claimsFmt hasuraClaimsV\n\n  -- filter only x-hasura claims and convert to lower-case\n  let claimsMap = Map.filterWithKey (\\k _ -> T.isPrefixOf \"x-hasura-\" k)\n                $ Map.fromList $ map (first T.toLower)\n                $ Map.toList hasuraClaims\n\n  HasuraClaims allowedRoles defaultRole <- parseHasuraClaims claimsMap\n  let role = getCurrentRole defaultRole\n\n  when (role `notElem` allowedRoles) currRoleNotAllowed\n  let finalClaims =\n        Map.delete defaultRoleClaim . Map.delete allowedRolesClaim $ claimsMap\n\n  -- transform the map of text:aeson-value -> text:text\n  metadata <- decodeJSON $ A.Object finalClaims\n\n  return $ (, expTimeM) $ mkUserInfo role $ mkUserVars $ Map.toList metadata\n\n  where\n    parseAuthzHeader = do\n      let tokenParts = BLC.words authzHeader\n      case tokenParts of\n        [\"Bearer\", jwt] -> return jwt\n        _               -> malformedAuthzHeader\n\n    parseObjectFromString claimsFmt jVal =\n      case (claimsFmt, jVal) of\n        (JCFStringifiedJson, A.String v) ->\n          either (const $ claimsErr $ strngfyErr v) return\n          $ A.eitherDecodeStrict $ T.encodeUtf8 v\n        (JCFStringifiedJson, _) ->\n          claimsErr \"expecting a string when claims_format is stringified_json\"\n        (JCFJson, A.Object o) -> return o\n        (JCFJson, _) ->\n          claimsErr \"expecting a json object when claims_format is json\"\n\n    strngfyErr v = \"expecting stringified json at: '\"\n                   <> fromMaybe defaultClaimNs (jcxClaimNs jwtCtx)\n                   <> \"', but found: \" <> v\n\n    claimsErr = throw400 JWTInvalidClaims\n\n    -- see if there is a x-hasura-role header, or else pick the default role\n    getCurrentRole defaultRole =\n      let userRoleHeaderB = CS.cs userRoleHeader\n          mUserRole = snd <$> find (\\h -> fst h == CI.mk userRoleHeaderB) headers\n      in maybe defaultRole RoleName $ mUserRole >>= mkNonEmptyText . bsToTxt\n\n    decodeJSON val = case A.fromJSON val of\n      A.Error e   -> throw400 JWTInvalidClaims (\"x-hasura-* claims: \" <> T.pack e)\n      A.Success a -> return a\n\n    liftJWTError :: (MonadError e' m) => (e -> e') -> ExceptT e m a -> m a\n    liftJWTError ef action = do\n      res <- runExceptT action\n      either (throwError . ef) return res\n\n    invalidJWTError e =\n      err400 JWTInvalid $ \"Could not verify JWT: \" <> T.pack (show e)\n\n    malformedAuthzHeader =\n      throw400 InvalidHeaders \"Malformed Authorization header\"\n    currRoleNotAllowed =\n      throw400 AccessDenied \"Your current role is not in allowed roles\"\n    claimsNotFound = do\n      let claimsNs = fromMaybe defaultClaimNs $ jcxClaimNs jwtCtx\n      throw400 JWTInvalidClaims $ \"claims key: '\" <> claimsNs <> \"' not found\"\n\n\n-- parse x-hasura-allowed-roles, x-hasura-default-role from JWT claims\nparseHasuraClaims\n  :: (MonadError QErr m)\n  => A.Object -> m HasuraClaims\nparseHasuraClaims claimsMap = do\n  let mAllowedRolesV = Map.lookup allowedRolesClaim claimsMap\n  allowedRolesV <- maybe missingAllowedRolesClaim return mAllowedRolesV\n  allowedRoles <- parseJwtClaim (A.fromJSON allowedRolesV) errMsg\n\n  let mDefaultRoleV = Map.lookup defaultRoleClaim claimsMap\n  defaultRoleV <- maybe missingDefaultRoleClaim return mDefaultRoleV\n  defaultRole <- parseJwtClaim (A.fromJSON defaultRoleV) errMsg\n\n  return $ HasuraClaims allowedRoles defaultRole\n\n  where\n    missingAllowedRolesClaim =\n      let msg = \"JWT claim does not contain \" <> allowedRolesClaim\n      in throw400 JWTRoleClaimMissing msg\n\n    missingDefaultRoleClaim =\n      let msg = \"JWT claim does not contain \" <> defaultRoleClaim\n      in throw400 JWTRoleClaimMissing msg\n\n    errMsg _ = \"invalid \" <> allowedRolesClaim <> \"; should be a list of roles\"\n\n    parseJwtClaim :: (MonadError QErr m) => A.Result a -> (String -> Text) -> m a\n    parseJwtClaim res errFn =\n      case res of\n        A.Success val -> return val\n        A.Error e     -> throw400 JWTInvalidClaims $ errFn e\n\n\n-- | Verify the JWT against given JWK\nverifyJwt\n  :: ( MonadError JWTError m\n     , MonadIO m\n     )\n  => JWTCtx\n  -> RawJWT\n  -> m ClaimsSet\nverifyJwt ctx (RawJWT rawJWT) = do\n  key <- liftIO $ readIORef $ jcxKey ctx\n  jwt <- decodeCompact rawJWT\n  t   <- liftIO getCurrentTime\n  verifyClaimsAt config key t jwt\n  where\n    audCheck aud = maybe True (== (T.pack . show) aud) $ jcxAudience ctx\n    config = defaultJWTValidationSettings audCheck\n\n\ninstance A.ToJSON JWTConfig where\n  toJSON (JWTConfig ty keyOrUrl claimNs aud claimsFmt) =\n    case keyOrUrl of\n         Left _    -> mkObj (\"key\" A..= A.String \"<JWK REDACTED>\")\n         Right url -> mkObj (\"jwk_url\" A..= url)\n    where\n      mkObj item = A.object [ \"type\" A..= ty\n                            , \"claims_namespace\" A..= claimNs\n                            , \"claims_format\" A..= claimsFmt\n                            , \"audience\" A..= aud\n                            , item\n                            ]\n\n-- | Parse from a json string like:\n-- | `{\"type\": \"RS256\", \"key\": \"<PEM-encoded-public-key-or-X509-cert>\"}`\n-- | to JWTConfig\ninstance A.FromJSON JWTConfig where\n\n  parseJSON = A.withObject \"JWTConfig\" $ \\o -> do\n    keyType <- o A..: \"type\"\n    mRawKey <- o A..:? \"key\"\n    claimNs <- o A..:? \"claims_namespace\"\n    aud     <- o A..:? \"audience\"\n    jwkUrl  <- o A..:? \"jwk_url\"\n    isStrngfd <- o A..:? \"claims_format\"\n\n    case (mRawKey, jwkUrl) of\n      (Nothing, Nothing) -> fail \"key and jwk_url both cannot be empty\"\n      (Just _, Just _)   -> fail \"key, jwk_url both cannot be present\"\n      (Just rawKey, Nothing) -> do\n        key <- parseKey keyType rawKey\n        return $ JWTConfig keyType (Left key) claimNs aud isStrngfd\n      (Nothing, Just url) ->\n        return $ JWTConfig keyType (Right url) claimNs aud isStrngfd\n\n    where\n      parseKey keyType rawKey =\n       case keyType of\n          \"HS256\" -> runEither $ parseHmacKey rawKey 256\n          \"HS384\" -> runEither $ parseHmacKey rawKey 384\n          \"HS512\" -> runEither $ parseHmacKey rawKey 512\n          \"RS256\" -> runEither $ parseRsaKey rawKey\n          \"RS384\" -> runEither $ parseRsaKey rawKey\n          \"RS512\" -> runEither $ parseRsaKey rawKey\n          -- TODO: support ES256, ES384, ES512, PS256, PS384\n          _       -> invalidJwk (\"Key type: \" <> T.unpack keyType <> \" is not supported\")\n\n      runEither = either (invalidJwk . T.unpack) return\n      invalidJwk msg = fail (\"Invalid JWK: \" <> msg)\n", "from datetime import datetime, timedelta\nimport math\nimport json\nimport time\n\nimport yaml\nimport pytest\nimport jwt\nfrom test_subscriptions import init_ws_conn\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.hazmat.primitives import serialization\n\nfrom validate import check_query\n\n\nif not pytest.config.getoption('--hge-jwt-key-file'):\n    pytest.skip('--hge-jwt-key-file is missing, skipping JWT basic tests', allow_module_level=True)\n\nif not pytest.config.getoption('--hge-jwt-conf'):\n    pytest.skip('--hge-jwt-key-conf is missing, skipping JWT basic tests', allow_module_level=True)\n\ndef get_claims_fmt(raw_conf):\n    conf = json.loads(raw_conf)\n    try:\n        claims_fmt = conf['claims_format']\n    except KeyError:\n        claims_fmt = 'json'\n    return claims_fmt\n\ndef mk_claims(conf, claims):\n    claims_fmt = get_claims_fmt(conf)\n    if claims_fmt == 'json':\n        return claims\n    elif claims_fmt == 'stringified_json':\n        return json.dumps(claims)\n    else:\n        return claims\n\n@pytest.mark.parametrize('endpoint', ['/v1/graphql', '/v1alpha1/graphql'])\nclass TestJWTBasic():\n\n    def test_jwt_valid_claims_success(self, hge_ctx, endpoint):\n        self.claims['https://hasura.io/jwt/claims'] = mk_claims(hge_ctx.hge_jwt_conf, {\n            'x-hasura-user-id': '1',\n            'x-hasura-allowed-roles': ['user', 'editor'],\n            'x-hasura-default-role': 'user'\n        })\n        token = jwt.encode(self.claims, hge_ctx.hge_jwt_key, algorithm='RS512').decode('utf-8')\n        self.conf['headers']['Authorization'] = 'Bearer ' + token\n        self.conf['url'] = endpoint\n        self.conf['status'] = 200\n        check_query(hge_ctx, self.conf, add_auth=False)\n\n    def test_jwt_invalid_role_in_request_header(self, hge_ctx, endpoint):\n        self.claims['https://hasura.io/jwt/claims'] = mk_claims(hge_ctx.hge_jwt_conf, {\n            'x-hasura-user-id': '1',\n            'x-hasura-allowed-roles': ['contractor', 'editor'],\n            'x-hasura-default-role': 'contractor'\n        })\n        token = jwt.encode(self.claims, hge_ctx.hge_jwt_key, algorithm='RS512').decode('utf-8')\n        self.conf['headers']['Authorization'] = 'Bearer ' + token\n        self.conf['response'] = {\n            'errors': [{\n                'extensions': {\n                    'code': 'access-denied',\n                    'path': '$'\n                },\n                'message': 'Your current role is not in allowed roles'\n            }]\n        }\n        self.conf['url'] = endpoint\n        if endpoint == '/v1/graphql':\n            self.conf['status'] = 200\n        if endpoint == '/v1alpha1/graphql':\n            self.conf['status'] = 400\n        check_query(hge_ctx, self.conf, add_auth=False)\n\n    def test_jwt_no_allowed_roles_in_claim(self, hge_ctx, endpoint):\n        self.claims['https://hasura.io/jwt/claims'] = mk_claims(hge_ctx.hge_jwt_conf, {\n            'x-hasura-user-id': '1',\n            'x-hasura-default-role': 'user'\n        })\n        token = jwt.encode(self.claims, hge_ctx.hge_jwt_key, algorithm='RS512').decode('utf-8')\n        self.conf['headers']['Authorization'] = 'Bearer ' + token\n        self.conf['response'] = {\n            'errors': [{\n                'extensions': {\n                    'code': 'jwt-missing-role-claims',\n                    'path': '$'\n                },\n                'message': 'JWT claim does not contain x-hasura-allowed-roles'\n            }]\n        }\n        self.conf['url'] = endpoint\n        if endpoint == '/v1/graphql':\n            self.conf['status'] = 200\n        if endpoint == '/v1alpha1/graphql':\n            self.conf['status'] = 400\n        check_query(hge_ctx, self.conf, add_auth=False)\n\n    def test_jwt_invalid_allowed_roles_in_claim(self, hge_ctx, endpoint):\n        self.claims['https://hasura.io/jwt/claims'] = mk_claims(hge_ctx.hge_jwt_conf, {\n            'x-hasura-user-id': '1',\n            'x-hasura-allowed-roles': 'user',\n            'x-hasura-default-role': 'user'\n        })\n        token = jwt.encode(self.claims, hge_ctx.hge_jwt_key, algorithm='RS512').decode('utf-8')\n        self.conf['headers']['Authorization'] = 'Bearer ' + token\n        self.conf['response'] = {\n            'errors': [{\n                'extensions': {\n                    'code': 'jwt-invalid-claims',\n                    'path': '$'\n                },\n                'message': 'invalid x-hasura-allowed-roles; should be a list of roles'\n            }]\n        }\n        self.conf['url'] = endpoint\n        if endpoint == '/v1/graphql':\n            self.conf['status'] = 200\n        if endpoint == '/v1alpha1/graphql':\n            self.conf['status'] = 400\n        check_query(hge_ctx, self.conf, add_auth=False)\n\n    def test_jwt_no_default_role(self, hge_ctx, endpoint):\n        self.claims['https://hasura.io/jwt/claims'] = mk_claims(hge_ctx.hge_jwt_conf, {\n            'x-hasura-user-id': '1',\n            'x-hasura-allowed-roles': ['user'],\n        })\n        token = jwt.encode(self.claims, hge_ctx.hge_jwt_key, algorithm='RS512').decode('utf-8')\n        self.conf['headers']['Authorization'] = 'Bearer ' + token\n        self.conf['response'] = {\n            'errors': [{\n                'extensions': {\n                    'code': 'jwt-missing-role-claims',\n                    'path': '$'\n                },\n                'message': 'JWT claim does not contain x-hasura-default-role'\n            }]\n        }\n        self.conf['url'] = endpoint\n        if endpoint == '/v1/graphql':\n            self.conf['status'] = 200\n        if endpoint == '/v1alpha1/graphql':\n            self.conf['status'] = 400\n        check_query(hge_ctx, self.conf, add_auth=False)\n\n    def test_jwt_expired(self, hge_ctx, endpoint):\n        self.claims['https://hasura.io/jwt/claims'] = mk_claims(hge_ctx.hge_jwt_conf, {\n            'x-hasura-user-id': '1',\n            'x-hasura-default-role': 'user',\n            'x-hasura-allowed-roles': ['user'],\n        })\n        exp = datetime.now() - timedelta(minutes=1)\n        self.claims['exp'] = round(exp.timestamp())\n\n        token = jwt.encode(self.claims, hge_ctx.hge_jwt_key, algorithm='RS512').decode('utf-8')\n        self.conf['headers']['Authorization'] = 'Bearer ' + token\n        self.conf['response'] = {\n            'errors': [{\n                'extensions': {\n                    'code': 'invalid-jwt',\n                    'path': '$'\n                },\n                'message': 'Could not verify JWT: JWTExpired'\n            }]\n        }\n        self.conf['url'] = endpoint\n        if endpoint == '/v1/graphql':\n            self.conf['status'] = 200\n        if endpoint == '/v1alpha1/graphql':\n            self.conf['status'] = 400\n        check_query(hge_ctx, self.conf, add_auth=False)\n\n    def test_jwt_invalid_signature(self, hge_ctx, endpoint):\n        self.claims['https://hasura.io/jwt/claims'] = mk_claims(hge_ctx.hge_jwt_conf, {\n            'x-hasura-user-id': '1',\n            'x-hasura-default-role': 'user',\n            'x-hasura-allowed-roles': ['user'],\n        })\n\n        wrong_key = gen_rsa_key()\n        token = jwt.encode(self.claims, wrong_key, algorithm='HS256').decode('utf-8')\n        self.conf['headers']['Authorization'] = 'Bearer ' + token\n        self.conf['response'] = {\n            'errors': [{\n                'extensions': {\n                    'code': 'invalid-jwt',\n                    'path': '$'\n                },\n                'message': 'Could not verify JWT: JWSError JWSInvalidSignature'\n            }]\n        }\n        self.conf['url'] = endpoint\n        if endpoint == '/v1/graphql':\n            self.conf['status'] = 200\n        if endpoint == '/v1alpha1/graphql':\n            self.conf['status'] = 400\n        check_query(hge_ctx, self.conf, add_auth=False)\n\n    @pytest.fixture(autouse=True)\n    def transact(self, setup):\n        self.dir = 'queries/graphql_query/permissions'\n        with open(self.dir + '/user_select_query_unpublished_articles.yaml') as c:\n            self.conf = yaml.safe_load(c)\n        curr_time = datetime.now()\n        exp_time = curr_time + timedelta(hours=1)\n        self.claims = {\n            'sub': '1234567890',\n            'name': 'John Doe',\n            'iat': math.floor(curr_time.timestamp()),\n            'exp': math.floor(exp_time.timestamp())\n        }\n\n    @pytest.fixture(scope='class')\n    def setup(self, request, hge_ctx):\n        self.dir = 'queries/graphql_query/permissions'\n        st_code, resp = hge_ctx.v1q_f(self.dir + '/setup.yaml')\n        assert st_code == 200, resp\n        yield\n        st_code, resp = hge_ctx.v1q_f(self.dir + '/teardown.yaml')\n        assert st_code == 200, resp\n\n\ndef gen_rsa_key():\n    private_key = rsa.generate_private_key(\n        public_exponent=65537,\n        key_size=2048,\n        backend=default_backend()\n    )\n    pem = private_key.private_bytes(\n        encoding=serialization.Encoding.PEM,\n        format=serialization.PrivateFormat.TraditionalOpenSSL,\n        encryption_algorithm=serialization.NoEncryption()\n    )\n    return pem\n\nclass TestSubscriptionJwtExpiry(object):\n\n    def test_jwt_expiry(self, hge_ctx, ws_client):\n        curr_time = datetime.now()\n        self.claims = {\n            'sub': '1234567890',\n            'name': 'John Doe',\n            'iat': math.floor(curr_time.timestamp())\n        }\n        self.claims['https://hasura.io/jwt/claims'] = mk_claims(hge_ctx.hge_jwt_conf, {\n            'x-hasura-user-id': '1',\n            'x-hasura-default-role': 'user',\n            'x-hasura-allowed-roles': ['user'],\n        })\n        exp = curr_time + timedelta(seconds=5)\n        self.claims['exp'] = round(exp.timestamp())\n        token = jwt.encode(self.claims, hge_ctx.hge_jwt_key, algorithm='RS512').decode('utf-8')\n        payload = {\n            'headers': {\n                'Authorization': 'Bearer ' + token\n            }\n        }\n        init_ws_conn(hge_ctx, ws_client, payload)\n        time.sleep(5)\n        assert ws_client.remote_closed == True, ws_client.remote_closed\n"], "fixing_code": ["#!/usr/bin/env bash\nset -euo pipefail\n\n### Functions\n\nstop_services() {\n   kill -INT $HGE_PIDS || true\n   kill $WH_PID || true\n   kill -INT $WHC_PID || true\n}\n\ntime_elapsed(){\n\tprintf \"(%02d:%02d)\" $[SECONDS/60] $[SECONDS%60]\n}\n\nfail_if_port_busy() {\n    local PORT=$1\n    if nc -z localhost $PORT ; then\n        echo \"Port $PORT is busy. Exiting\"\n        exit 1\n    fi\n}\n\nwait_for_port() {\n    local PORT=$1\n    echo \"waiting for $PORT\"\n    for _ in $(seq 1 240);\n    do\n      nc -z localhost $PORT && echo \"port $PORT is ready\" && return\n      echo -n .\n      sleep 0.25\n    done\n    echo \"Failed waiting for $PORT\" && exit 1\n}\n\ninit_jwt() {\n\tCUR_DIR=\"$PWD\"\n\tmkdir -p \"$OUTPUT_FOLDER/ssl\"\n\tcd \"$OUTPUT_FOLDER/ssl\"\n\topenssl genrsa -out jwt_private.key 2048\n\topenssl rsa -pubout -in jwt_private.key -out  jwt_public.key\n\tcd \"$CUR_DIR\"\n}\n\ninit_ssl() {\n\tCUR_DIR=\"$PWD\"\n\tmkdir -p \"$OUTPUT_FOLDER/ssl\"\n\tcd \"$OUTPUT_FOLDER/ssl\"\n\tCNF_TEMPLATE='[req]\nreq_extensions = v3_req\ndistinguished_name = req_distinguished_name\n\n[req_distinguished_name]\n\n[ v3_req ]\nbasicConstraints = CA:FALSE\nkeyUsage = nonRepudiation, digitalSignature, keyEncipherment\nsubjectAltName = @alt_names\n\n[alt_names]\nDNS.1 = localhost\nIP.1 = 127.0.0.1'\n\n\techo \"$CNF_TEMPLATE\" > webhook-req.cnf\n\n\topenssl genrsa -out ca-key.pem 2048\n\topenssl req -x509 -new -nodes -key ca-key.pem -days 10 -out ca.pem -subj \"/CN=webhook-ca\"\n\topenssl genrsa -out webhook-key.pem 2048\n\topenssl req -new -key webhook-key.pem -out webhook.csr -subj \"/CN=hge-webhook\" -config webhook-req.cnf\n\topenssl x509 -req -in webhook.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out webhook.pem -days 10 -extensions v3_req -extfile webhook-req.cnf\n\n\tcp ca.pem /etc/ssl/certs/webhook.crt\n\tupdate-ca-certificates\n\tcd \"$CUR_DIR\"\n}\n\ncombine_all_hpc_reports() {\n\tcombined_file=\"${OUTPUT_FOLDER}/graphql-engine.tix\"\n\tcombined_file_intermediate=\"${OUTPUT_FOLDER}/hpc/graphql-engine-combined-intermediate.tix\"\n\trm -f \"$combined_file\"\n\tIFS=: tix_files_arr=($TIX_FILES)\n\tunset IFS\n\tfor tix_file in \"${tix_files_arr[@]}\"\n\tdo\n\t\tif ! [ -f \"$tix_file\" ] ; then\n\t\t\tcontinue\n\t\tfi\n\t\tif [ -f \"$combined_file\" ]  ; then\n\t\t\t(set -x && stack --allow-different-user exec -- hpc combine \"$combined_file\" \"$tix_file\" --union --output=\"$combined_file_intermediate\" && set +x && mv \"$combined_file_intermediate\" \"$combined_file\" && rm \"$tix_file\" ) || true\n\t\telse\n\t\t\tmv \"$tix_file\" \"$combined_file\" || true\n\t\tfi\n\tdone\n}\n\nkill_hge_servers() {\n\tkill -INT $HGE_PIDS || true\n\twait $HGE_PIDS || true\n\tHGE_PIDS=\"\"\n}\n\nrun_hge_with_args() {\n\ti=$((TIX_FILE_INDEX++))\n\texport HPCTIXFILE=\"${OUTPUT_FOLDER}/hpc/graphql-engine-${i}-${TEST_TYPE}.tix\"\n\trm -f \"$HPCTIXFILE\"\n\tTIX_FILES=\"$TIX_FILES:$HPCTIXFILE\"\n\tset -x\n\t\"$GRAPHQL_ENGINE\" \"$@\" 2>&1 > \"$OUTPUT_FOLDER/graphql-engine-${i}-${TEST_TYPE}.log\" & HGE_PIDS=\"$HGE_PIDS $!\"\n\tset +x\n}\n\nstart_multiple_hge_servers() {\n\trun_hge_with_args --database-url \"$HASURA_GRAPHQL_DATABASE_URL\" serve \"$@\"\n\tif [ -n ${HASURA_GRAPHQL_DATABASE_URL_2:-} ] ; then\n\t\trun_hge_with_args --database-url \"$HASURA_GRAPHQL_DATABASE_URL_2\" serve --server-port 8081 \"$@\"\n\t\twait_for_port 8081\n\tfi\n\twait_for_port 8080\n}\n\n\nif [ -z \"${HASURA_GRAPHQL_DATABASE_URL:-}\" ] ; then\n\techo \"Env var HASURA_GRAPHQL_DATABASE_URL is not set\"\n\texit 1\nfi\n\nif [ -z \"${HASURA_GRAPHQL_DATABASE_URL_2:-}\" ] ; then\n\techo \"Env var HASURA_GRAPHQL_DATABASE_URL_2 is not set\"\n\texit 1\nfi\n\nif ! stack --allow-different-user exec which hpc ; then\n\techo \"hpc not found; Install it with 'stack install hpc'\"\n\texit 1\nfi\n\nCIRCLECI_FOLDER=\"${BASH_SOURCE[0]%/*}\"\ncd $CIRCLECI_FOLDER\nCIRCLECI_FOLDER=\"$PWD\"\n\nif ! $CIRCLECI_FOLDER/test-server-flags.sh ; then\n\techo \"Testing GraphQL server flags failed\"\n\texit 1\nfi\n\nif ! $CIRCLECI_FOLDER/test-deprecated-server-flags.sh ; then\n\techo \"Testing GraphQL deprecated server flags failed\"\n\texit 1\nfi\n\nPYTEST_ROOT=\"$CIRCLECI_FOLDER/../server/tests-py\"\n\nOUTPUT_FOLDER=${OUTPUT_FOLDER:-\"$CIRCLECI_FOLDER/test-server-output\"}\nmkdir -p \"$OUTPUT_FOLDER\"\n\nTEST_TYPE=\"no-auth\"\nHPCTIXFILE=\"\"\nTIX_FILE_INDEX=\"1\"\nTIX_FILES=\"\"\n\ncd $PYTEST_ROOT\n\nif ! stack --allow-different-user exec -- which graphql-engine > /dev/null && [ -z \"${GRAPHQL_ENGINE:-}\" ] ; then\n\techo \"Do 'stack build' before tests, or export the location of executable in the GRAPHQL_ENGINE envirnoment variable\"\n\texit 1\nfi\nGRAPHQL_ENGINE=${GRAPHQL_ENGINE:-\"$(stack --allow-different-user exec -- which graphql-engine)\"}\nif ! [ -x \"$GRAPHQL_ENGINE\" ] ; then\n\techo \"$GRAPHQL_ENGINE is not present or is not an executable\"\n\texit 1\nfi\nRUN_WEBHOOK_TESTS=true\n\nfor port in 8080 8081 9876 5592\ndo\n\tfail_if_port_busy $port\ndone\n\necho -e \"\\nINFO: GraphQL Executable : $GRAPHQL_ENGINE\"\necho -e \"INFO: Logs Folder        : $OUTPUT_FOLDER\\n\"\n\npip3 install -r requirements.txt\n\nmkdir -p \"$OUTPUT_FOLDER/hpc\"\n\nexport EVENT_WEBHOOK_HEADER=\"MyEnvValue\"\nexport HGE_URL=\"http://localhost:8080\"\nexport HGE_URL_2=\"\"\nif [ -n ${HASURA_GRAPHQL_DATABASE_URL_2:-} ] ; then\n\tHGE_URL_2=\"http://localhost:8081\"\nfi\nexport WEBHOOK_FROM_ENV=\"http://127.0.0.1:5592\"\nexport HASURA_GRAPHQL_STRINGIFY_NUMERIC_TYPES=true\n\nHGE_PIDS=\"\"\nWH_PID=\"\"\nWHC_PID=\"\"\nHS_PID=\"\"\n\ntrap stop_services ERR\ntrap stop_services INT\n\nrun_pytest_parallel() {\n\ttrap stop_services ERR\n\tif [ -n ${HASURA_GRAPHQL_DATABASE_URL_2:-} ] ; then\n\t\tset -x\n\t\tpytest -vv --hge-urls \"$HGE_URL\" \"${HGE_URL_2:-}\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" \"${HASURA_GRAPHQL_DATABASE_URL_2:-}\" -n 2 --dist=loadfile \"$@\"\n\t\tset +x\n\telse\n\t\tset -x\n\t\tpytest -vv --hge-urls \"$HGE_URL\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" -n 1 \"$@\"\n\t\tset +x\n\tfi\n}\n\necho -e \"\\n$(time_elapsed): <########## TEST GRAPHQL-ENGINE WITHOUT ADMIN SECRET ###########################################>\\n\"\nTEST_TYPE=\"no-auth\"\n\nstart_multiple_hge_servers\n\nrun_pytest_parallel\n\nkill_hge_servers\n\n##########\necho -e \"\\n$(time_elapsed): <########## TEST GRAPHQL-ENGINE WITH ADMIN SECRET #####################################>\\n\"\nTEST_TYPE=\"admin-secret\"\n\nexport HASURA_GRAPHQL_ADMIN_SECRET=\"HGE$RANDOM$RANDOM\"\n\nstart_multiple_hge_servers\n\nrun_pytest_parallel --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\"\n\nkill_hge_servers\n\n##########\necho -e \"\\n$(time_elapsed): <########## TEST GRAPHQL-ENGINE WITH ADMIN SECRET AND JWT #####################################>\\n\"\nTEST_TYPE=\"jwt\"\n\ninit_jwt\n\nexport HASURA_GRAPHQL_JWT_SECRET=\"$(jq -n --arg key \"$(cat $OUTPUT_FOLDER/ssl/jwt_public.key)\" '{ type: \"RS512\", key: $key }')\"\n\nstart_multiple_hge_servers\n\nrun_pytest_parallel --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\" --hge-jwt-key-file=\"$OUTPUT_FOLDER/ssl/jwt_private.key\" --hge-jwt-conf=\"$HASURA_GRAPHQL_JWT_SECRET\"\n\nkill_hge_servers\n\nunset HASURA_GRAPHQL_JWT_SECRET\n\necho -e \"\\n$(time_elapsed): <########## TEST GRAPHQL-ENGINE WITH ADMIN SECRET AND JWT (in stringified mode) #####################################>\\n\"\nTEST_TYPE=\"jwt-stringified\"\n\n\nexport HASURA_GRAPHQL_JWT_SECRET=\"$(jq -n --arg key \"$(cat $OUTPUT_FOLDER/ssl/jwt_public.key)\" '{ type: \"RS512\", key: $key , claims_format: \"stringified_json\"}')\"\n\nrun_hge_with_args serve\nwait_for_port 8080\n\npytest -n 1 -vv --hge-urls \"$HGE_URL\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\" --hge-jwt-key-file=\"$OUTPUT_FOLDER/ssl/jwt_private.key\" --hge-jwt-conf=\"$HASURA_GRAPHQL_JWT_SECRET\" test_jwt.py\n\nkill_hge_servers\n\nunset HASURA_GRAPHQL_JWT_SECRET\n\necho -e \"\\n$(time_elapsed): <########## TEST GRAPHQL-ENGINE WITH ADMIN SECRET AND JWT (with audience check - string) #####################################>\\n\"\nTEST_TYPE=\"jwt-audience-check-single-string\"\n\n\nexport HASURA_GRAPHQL_JWT_SECRET=\"$(jq -n --arg key \"$(cat $OUTPUT_FOLDER/ssl/jwt_public.key)\" '{ type: \"RS512\", key: $key , audience: \"myapp-1234\"}')\"\n\nrun_hge_with_args serve\nwait_for_port 8080\n\npytest -n 1 -vv --hge-urls \"$HGE_URL\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\" --hge-jwt-key-file=\"$OUTPUT_FOLDER/ssl/jwt_private.key\" --hge-jwt-conf=\"$HASURA_GRAPHQL_JWT_SECRET\" test_jwt.py\n\nkill_hge_servers\n\nunset HASURA_GRAPHQL_JWT_SECRET\n\necho -e \"\\n$(time_elapsed): <########## TEST GRAPHQL-ENGINE WITH ADMIN SECRET AND JWT (with audience check - list of strings) #################################>\\n\"\nTEST_TYPE=\"jwt-audience-check-list-string\"\n\nexport HASURA_GRAPHQL_JWT_SECRET=\"$(jq -n --arg key \"$(cat $OUTPUT_FOLDER/ssl/jwt_public.key)\" '{ type: \"RS512\", key: $key , audience: [\"myapp-1234\", \"myapp-9876\"]}')\"\n\nrun_hge_with_args serve\nwait_for_port 8080\n\npytest -n 1 -vv --hge-urls \"$HGE_URL\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\" --hge-jwt-key-file=\"$OUTPUT_FOLDER/ssl/jwt_private.key\" --hge-jwt-conf=\"$HASURA_GRAPHQL_JWT_SECRET\" test_jwt.py\n\nkill_hge_servers\n\nunset HASURA_GRAPHQL_JWT_SECRET\n\necho -e \"\\n$(time_elapsed): <########## TEST GRAPHQL-ENGINE WITH ADMIN SECRET AND JWT (with issuer check) #####################################>\\n\"\nTEST_TYPE=\"jwt-issuer-check\"\n\nexport HASURA_GRAPHQL_JWT_SECRET=\"$(jq -n --arg key \"$(cat $OUTPUT_FOLDER/ssl/jwt_public.key)\" '{ type: \"RS512\", key: $key , issuer: \"https://hasura.com\"}')\"\n\nrun_hge_with_args serve\nwait_for_port 8080\n\npytest -n 1 -vv --hge-urls \"$HGE_URL\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\" --hge-jwt-key-file=\"$OUTPUT_FOLDER/ssl/jwt_private.key\" --hge-jwt-conf=\"$HASURA_GRAPHQL_JWT_SECRET\" test_jwt.py\n\nkill_hge_servers\n\nunset HASURA_GRAPHQL_JWT_SECRET\n\n\n# test with CORS modes\n\necho -e \"\\n$(time_elapsed): <########## TEST GRAPHQL-ENGINE WITH CORS DOMAINS ########>\\n\"\nexport HASURA_GRAPHQL_CORS_DOMAIN=\"http://*.localhost, http://localhost:3000, https://*.foo.bar.com\"\nTEST_TYPE=\"cors-domains\"\n\nrun_hge_with_args serve\nwait_for_port 8080\n\npytest -n  1 -vv --hge-urls \"$HGE_URL\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\" --test-cors test_cors.py\n\nkill_hge_servers\n\nunset HASURA_GRAPHQL_CORS_DOMAIN\n\n# test websocket transport with initial cookie header\n\necho -e \"\\n$(time_elapsped): <########## TEST GRAPHQL-ENGINE WITH COOKIE IN WEBSOCKET INIT ########>\\n\"\nTEST_TYPE=\"ws-init-cookie-read-cors-enabled\"\nexport HASURA_GRAPHQL_AUTH_HOOK=\"http://localhost:9876/auth\"\nexport HASURA_GRAPHQL_AUTH_HOOK_MODE=\"POST\"\n\npython3 test_cookie_webhook.py > \"$OUTPUT_FOLDER/cookie_webhook.log\" 2>&1  & WHC_PID=$!\n\nwait_for_port 9876\n\nrun_hge_with_args serve\nwait_for_port 8080\n\necho \"$(time_elapsed): testcase 1: read cookie, cors enabled\"\npytest -n 1 -vv --hge-urls \"$HGE_URL\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\" --test-ws-init-cookie=read test_websocket_init_cookie.py\n\nkill_hge_servers\n\necho \"$(time_elapsed): testcase 2: no read cookie, cors disabled\"\nTEST_TYPE=\"ws-init-cookie-noread\"\nrun_hge_with_args serve --disable-cors\n\nwait_for_port 8080\n\npytest -n 1 -vv --hge-urls \"$HGE_URL\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\" --test-ws-init-cookie=noread test_websocket_init_cookie.py\n\nkill_hge_servers\n\necho \"$(time_elapsed): testcase 3: read cookie, cors disabled and ws-read-cookie\"\nTEST_TYPE=\"ws-init-cookie-read-cors-disabled\"\nexport HASURA_GRAPHQL_WS_READ_COOKIE=\"true\"\nrun_hge_with_args serve --disable-cors\nwait_for_port 8080\n\npytest -n 1 -vv --hge-urls \"$HGE_URL\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\" --test-ws-init-cookie=read test_websocket_init_cookie.py\n\nkill_hge_servers\n\nkill $WHC_PID\nunset HASURA_GRAPHQL_WS_READ_COOKIE\nunset HASURA_GRAPHQL_AUTH_HOOK\nunset HASURA_GRAPHQL_AUTH_HOOK_MODE\nsleep 4\n\necho -e \"\\n$(time_elapsed): <########## TEST GRAPHQL-ENGINE WITH GRAPHQL DISABLED ########>\\n\"\nTEST_TYPE=\"ws-graphql-api-disabled\"\nexport HASURA_GRAPHQL_ENABLED_APIS=\"metadata\"\n\nrun_hge_with_args serve\nwait_for_port 8080\n\npytest -n 1 -vv --hge-urls \"$HGE_URL\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\" --test-graphql-disabled test_apis_disabled.py\n\nkill_hge_servers\n\nunset HASURA_GRAPHQL_ENABLED_APIS\n\nrun_hge_with_args serve --enabled-apis metadata\nwait_for_port 8080\n\npytest -n 1 -vv --hge-urls \"$HGE_URL\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\" --test-graphql-disabled test_apis_disabled.py\n\nkill_hge_servers\n\necho -e \"\\n$(time_elapsed): <########## TEST GRAPHQL-ENGINE WITH METADATA DISABLED ########>\\n\"\nTEST_TYPE=\"ws-metadata-api-disabled\"\n\nexport HASURA_GRAPHQL_ENABLED_APIS=\"graphql\"\n\nrun_hge_with_args serve\nwait_for_port 8080\n\npytest -n 1 -vv --hge-urls \"$HGE_URL\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\" --test-metadata-disabled test_apis_disabled.py\n\nkill_hge_servers\nunset HASURA_GRAPHQL_ENABLED_APIS\n\nrun_hge_with_args serve --enabled-apis graphql\nwait_for_port 8080\n\npytest -n 1 -vv --hge-urls \"$HGE_URL\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\" --test-metadata-disabled test_apis_disabled.py\n\nkill_hge_servers\n\n# verbose logging tests\necho -e \"\\n$(time_elapsed): <########## TEST GRAPHQL-ENGINE WITH QUERY LOG ########>\\n\"\nTEST_TYPE=\"query-logs\"\n\nexport HASURA_GRAPHQL_ENABLED_LOG_TYPES=\" startup,http-log,webhook-log,websocket-log,query-log\"\n\n#run_hge_with_args serve\n# we are doing this instead of calling run_hge_with_args, because we want to save in a custom log file\ni=$((TIX_FILE_INDEX++))\nexport HPCTIXFILE=\"${OUTPUT_FOLDER}/hpc/graphql-engine-${i}-${TEST_TYPE}.tix\"\nrm -f \"$HPCTIXFILE\"\nTIX_FILES=\"$TIX_FILES:$HPCTIXFILE\"\nset -x\nexport LOGGING_TEST_LOGFILE_PATH=\"$OUTPUT_FOLDER/graphql-engine-verbose-logging.log\"\n\"$GRAPHQL_ENGINE\" serve 2>&1 > \"$LOGGING_TEST_LOGFILE_PATH\" & HGE_PIDS=\"$HGE_PIDS $!\"\nset +x\n\nwait_for_port 8080\n\npytest -n 1 -vv --hge-urls \"$HGE_URL\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\" --test-logging test_logging.py\n\nunset HASURA_GRAPHQL_ENABLED_LOG_TYPES\nkill_hge_servers\n\n# end verbose logging tests\n\n# webhook tests\n\nif [ $EUID != 0 ] ; then\n\techo -e \"SKIPPING webhook based tests, as \\nroot permission is required for running webhook tests (inorder to trust certificate authority).\"\n\tRUN_WEBHOOK_TESTS=false\nfi\n\nif [ \"$RUN_WEBHOOK_TESTS\" == \"true\" ] ; then\n\n\tTEST_TYPE=\"post-webhook\"\n\techo -e \"\\n$(time_elapsed): <########## TEST GRAPHQL-ENGINE WITH ADMIN SECRET & WEBHOOK (GET) #########################>\\n\"\n\n\texport HASURA_GRAPHQL_AUTH_HOOK=\"https://localhost:9090/\"\n\tinit_ssl\n\n\tstart_multiple_hge_servers\n\n\tpython3 webhook.py 9090 \"$OUTPUT_FOLDER/ssl/webhook-key.pem\" \"$OUTPUT_FOLDER/ssl/webhook.pem\" > \"$OUTPUT_FOLDER/webhook.log\" 2>&1  & WH_PID=$!\n\n\twait_for_port 9090\n\n\trun_pytest_parallel --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\" --hge-webhook=\"$HASURA_GRAPHQL_AUTH_HOOK\"\n\n\tkill_hge_servers\n\n\techo -e \"\\n$(time_elapsed): <########## TEST GRAPHQL-ENGINE WITH ADMIN SECRET & WEBHOOK (POST) #########################>\\n\"\n\tTEST_TYPE=\"get-webhook\"\n\texport HASURA_GRAPHQL_AUTH_HOOK_MODE=\"POST\"\n\n\tstart_multiple_hge_servers\n\n\trun_pytest_parallel --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\" --hge-webhook=\"$HASURA_GRAPHQL_AUTH_HOOK\"\n\n\trm /etc/ssl/certs/webhook.crt\n\tupdate-ca-certificates\n\n\tkill_hge_servers\n\n\techo -e \"\\n$(time_elapsed): <########## TEST GRAPHQL-ENGINE WITH ADMIN SECRET & HTTPS INSECURE WEBHOOK (GET) ########>\\n\"\n\tTEST_TYPE=\"insecure-webhook\"\n  \texport HASURA_GRAPHQL_AUTH_HOOK_MODE=\"GET\"\n\n\trun_hge_with_args serve\n\n\twait_for_port 8080\n\n\tpytest -n 1 -vv --hge-urls \"$HGE_URL\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\" --hge-webhook=\"$HASURA_GRAPHQL_AUTH_HOOK\" --test-webhook-insecure test_webhook_insecure.py\n\n\tkill_hge_servers\n\n\techo -e \"\\n$(time_elapsed): <########## TEST GRAPHQL-ENGINE WITH ADMIN_SECRET & HTTPS INSECURE WEBHOOK (POST) ########>\\n\"\n\tTEST_TYPE=\"insecure-webhook-with-admin-secret\"\n  \texport HASURA_GRAPHQL_AUTH_HOOK_MODE=\"POST\"\n\n\trun_hge_with_args serve\n\n\twait_for_port 8080\n\n\tpytest -n 1 -vv --hge-urls \"$HGE_URL\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\" --hge-webhook=\"$HASURA_GRAPHQL_AUTH_HOOK\" --test-webhook-insecure test_webhook_insecure.py\n\n\tkill_hge_servers\n\n\tkill $WH_PID\n\nfi\n\n# allowlist queries test\nunset HASURA_GRAPHQL_AUTH_HOOK\nunset HASURA_GRAPHQL_AUTH_HOOK_MODE\nunset HASURA_GRAPHQL_JWT_SECRET\nunset HASURA_GRAPHQL_ENABLE_ALLOWLIST\n\necho -e \"\\n$(time_elapsed): <########## TEST GRAPHQL-ENGINE WITH ALLOWLIST QUERIES ########> \\n\"\nexport HASURA_GRAPHQL_ENABLE_ALLOWLIST=true\nTEST_TYPE=\"allowlist-queries\"\n\nrun_hge_with_args serve\nwait_for_port 8080\n\npytest -n  1 -vv --hge-urls \"$HGE_URL\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\" --test-allowlist-queries test_allowlist_queries.py\n\nkill_hge_servers\nunset HASURA_GRAPHQL_ENABLE_ALLOWLIST\n\nrun_hge_with_args serve --enable-allowlist\nwait_for_port 8080\n\npytest -n  1 -vv --hge-urls \"$HGE_URL\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" --hge-key=\"$HASURA_GRAPHQL_ADMIN_SECRET\" --test-allowlist-queries test_allowlist_queries.py\n\nkill_hge_servers\n\n# end allowlist queries test\n\n# horizontal scale test\nunset HASURA_GRAPHQL_AUTH_HOOK\nunset HASURA_GRAPHQL_AUTH_HOOK_MODE\nunset HASURA_GRAPHQL_ADMIN_SECRET\n\necho -e \"\\n$(time_elapsed): <########## TEST GRAPHQL-ENGINE WITH HORIZONTAL SCALING ########>\\n\"\nTEST_TYPE=\"horizontal-scaling\"\n\nHASURA_HS_TEST_DB='postgres://postgres:postgres@localhost:6543/hs_hge_test'\n\nif ! psql \"$HASURA_GRAPHQL_DATABASE_URL\" -c \"SELECT 1 FROM pg_database WHERE datname = 'hs_hge_test'\" | grep -q -F '(1 row)'\nthen\n\tpsql \"$HASURA_GRAPHQL_DATABASE_URL\" -c 'CREATE DATABASE hs_hge_test;'\nfi\n\npgUserInfo=$( python3 -c '\nimport os\nfrom urllib.parse import urlparse\nuri = urlparse( os.environ[\"HASURA_GRAPHQL_DATABASE_URL\"] )\nif uri.password:\n    print(\"password=\"+uri.password+\" user=\"+uri.username)\nelse:\n    print(\"user=\"+uri.username)' )\n\npgDbInfo=$(psql \"$HASURA_GRAPHQL_DATABASE_URL\" -c \"SELECT concat(' host=',inet_server_addr(),' port=', inet_server_port(),' dbname=',current_database())\" | sed -n '3 p')\n\n# create pgbouncer user\nid pgbouncer || useradd pgbouncer\ncd $CIRCLECI_FOLDER\nmkdir -p pgbouncer\nchown -R pgbouncer:pgbouncer pgbouncer\n\necho '[databases]\nhs_hge_test = '\"$pgDbInfo\" \"$pgUserInfo\"'\n\n[pgbouncer]\nlisten_port = 6543\nlisten_addr = 127.0.0.1\nlogfile = pgbouncer/pgbouncer.log\npidfile = pgbouncer/pgbouncer.pid\nauth_type = md5\nauth_file = pgbouncer/users.txt\nadmin_users = postgres' > pgbouncer/pgbouncer.ini\n\n# start pgbouncer\npgbouncer -u pgbouncer -d pgbouncer/pgbouncer.ini\n\ncd $PYTEST_ROOT\nsleep 2\n\n# start 1st server\nrun_hge_with_args --database-url \"$HASURA_HS_TEST_DB\" serve\nwait_for_port 8080\n\n# start 2nd server\nrun_hge_with_args --database-url \"$HASURA_HS_TEST_DB\" serve \\\n                  --server-port 8081\nwait_for_port 8081\n\n# run test\npytest -vv --hge-urls \"$HGE_URL\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" --test-hge-scale-url=\"http://localhost:8081\" test_horizontal_scale.py\n\n# Shutdown pgbouncer\npsql \"postgres://postgres:postgres@localhost:6543/pgbouncer\" -c \"SHUTDOWN;\" || true\n\ncd $CIRCLECI_FOLDER\n\n# start pgbouncer again\npgbouncer -u pgbouncer -d pgbouncer/pgbouncer.ini\n\ncd $PYTEST_ROOT\n\n# sleep for 20 seconds\nsleep 20\n\n# run test\npytest -vv --hge-urls \"$HGE_URL\" --pg-urls \"$HASURA_GRAPHQL_DATABASE_URL\" --test-hge-scale-url=\"http://localhost:8081\" test_horizontal_scale.py\n\n# Shutdown pgbouncer\npsql \"postgres://postgres:postgres@localhost:6543/pgbouncer\" -c \"SHUTDOWN;\" || true\n\nkill_hge_servers\n\npsql \"$HASURA_GRAPHQL_DATABASE_URL\" -c \"drop database hs_hge_test;\"\nsleep 4\nunset HASURA_HS_TEST_DB\n\n# end horizontal scale test\n\necho -e \"\\n$(time_elapsed): <########## COMBINE ALL HPC REPORTS ########>\\n\"\ncombine_all_hpc_reports || true\n\necho -e \"\\n$(time_elapsed): <########## DONE ########>\\n\"\n", "Authentication using JWT\n========================\n\n.. contents:: Table of contents\n  :backlinks: none\n  :depth: 1\n  :local:\n\nIntroduction\n------------\n\nYou can configure GraphQL engine to use JWT authorization mode to authorize all incoming requests to Hasura GraphQL engine server.\n\nThe idea is - Your auth server will return JWT tokens, which is decoded and\nverified by GraphQL engine to authorize and get metadata about the request\n(``x-hasura-*`` values).\n\n\n.. thumbnail:: ../../../../img/graphql/manual/auth/jwt-auth.png\n\n\nThe JWT is decoded, the signature is verified, then it is asserted that the\ncurrent role of the user (if specified in the request) is in the list of allowed roles.\nIf current role is not specified in the request, then the default role is picked.\nIf the authorization passes, then all of the ``x-hasura-*`` values in the claim\nis used for the permissions system.\n\n.. admonition:: Prerequisite\n   \n   It is mandatory to first :doc:`secure your GraphQL endpoint <../../deployment/securing-graphql-endpoint>` for the JWT mode to take effect.\n\n\nIn JWT mode, on a secured endpoint:\n\n- JWT authentication is **enforced** when ``X-Hasura-Admin-Secret`` header is **not found** in the request.\n- JWT authentication is **skipped** when ``X-Hasura-Admin-Secret`` header **is found** in the request and\n  admin access is granted.\n\n\nTL;DR\n-----\n1. The JWT must contain: ``x-hasura-default-role``, ``x-hasura-allowed-roles``\n   in a custom namespace in the claims.\n2. Other optional ``x-hasura-*`` fields (required as per your defined\n   permissions).\n3. You can send ``x-hasura-role`` as header in the request to indicate a role.\n4. Send the JWT via ``Authorization: Bearer <JWT>`` header.\n\n\nThe Spec\n--------\nWhen your auth server generates the JWT, the custom claims in the JWT **must contain**\nthe following:\n\n1. A ``x-hasura-default-role`` field : indicating the default role of that user i.e. the role that will be\n   used in case ``x-hasura-role`` header is not passed\n2. A ``x-hasura-allowed-roles`` field : a list of allowed roles for the user i.e. acceptable values of the\n   ``x-hasura-role`` header\n\nThe claims in the JWT, can have other ``x-hasura-*`` fields where their values\ncan only be strings. You can use these ``x-hasura-*`` fields in your\npermissions.\n\nNow, the JWT should be sent by the client to Hasura GraphQL engine via the\n``Authorization: Bearer <JWT>`` header.\n\nExample JWT claim:\n\n.. code-block:: json\n\n  {\n    \"sub\": \"1234567890\",\n    \"name\": \"John Doe\",\n    \"admin\": true,\n    \"iat\": 1516239022,\n    \"https://hasura.io/jwt/claims\": {\n      \"x-hasura-allowed-roles\": [\"editor\",\"user\", \"mod\"],\n      \"x-hasura-default-role\": \"user\",\n      \"x-hasura-user-id\": \"1234567890\",\n      \"x-hasura-org-id\": \"123\",\n      \"x-hasura-custom\": \"custom-value\"\n    }\n  }\n\nThis contains standard (``sub``, ``iat`` etc.) and custom (``name``, ``admin``\netc.) JWT claims, as well as Hasura specific claims inside a custom namespace\n(or key) i.e. ``https://hasura.io/jwt/claims``.\n\nThe ``https://hasura.io/jwt/claims`` is the custom namespace where all Hasura\nspecific claims have to be present. This value can be configured in the JWT\nconfig while starting the server.\n\n**Note**: ``x-hasura-default-role`` and ``x-hasura-allowed-roles`` are\nmandatory, while rest of them are optional.\n\n.. note::\n\n   All ``x-hasura-*`` values should be ``String``, they will be converted to the\n   right type automatically.\n\nThe default role can be overridden by ``x-hasura-role`` header, while making a\nrequest.\n\n.. code-block:: http\n\n   POST /v1/graphql HTTP/1.1\n   Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWI...\n   X-Hasura-Role: editor\n\n   ...\n\n\nConfiguring JWT mode\n--------------------\n\nYou can enable JWT mode by using the ``--jwt-secret`` flag or\n``HASURA_GRAPHQL_JWT_SECRET`` environment variable; the value of which is a\nJSON object:\n\n.. code-block:: json\n\n   {\n     \"type\": \"<standard-JWT-algorithms>\",\n     \"key\": \"<optional-key-as-string>\",\n     \"jwk_url\": \"<optional-url-to-refresh-jwks>\",\n     \"claims_namespace\": \"<optional-key-name-in-claims>\",\n     \"claims_format\": \"json|stringified_json\",\n     \"audience\": <optional-string-or-list-of-strings-to-verify-audience>,\n     \"issuer\": \"<optional-string-to-verify-issuer>\"\n   }\n\n``key`` or ``jwk_url``, **one of them has to be present**.\n\n``type``\n^^^^^^^^\nValid values are : ``HS256``, ``HS384``, ``HS512``, ``RS256``,\n``RS384``, ``RS512``. (see https://jwt.io).\n\n``HS*`` is for HMAC-SHA based algorithms. ``RS*`` is for RSA based signing. For\nexample, if your auth server is using HMAC-SHA256 for signing the JWTs, then\nuse ``HS256``. If it is using RSA with 512-bit keys, then use ``RS512``. EC\npublic keys are not yet supported.\n\n``key``\n^^^^^^^\n- In case of symmetric key (i.e. HMAC based key), the key as it is. (e.g. -\n  \"abcdef...\"). The key must be long enough for the algorithm chosen,\n  (e.g. for HS256 it must be at least 32 characters long).\n- In case of asymmetric keys (RSA etc.), only the public key, in a PEM encoded\n  string or as a X509 certificate.\n\nThis is an optional field. You can also provide a URL to fetch JWKs from using\nthe ``jwk_url`` field.\n\n``jwk_url``\n^^^^^^^^^^^\nA URL where a provider publishes their JWKs (which are used for signing the\nJWTs). The URL **must** publish the JWKs in the standard format as described in\nhttps://tools.ietf.org/html/rfc7517\n\nThis is an optional field. You can also provide the key (certificate, PEM\nencoded public key) as string as well - under the ``key`` field.\n\n**Rotating JWKs**:\n\nSome providers rotate their JWKs (E.g - Firebase). If the provider sends an\n``Expires`` header with the response of JWK, then graphql-engine will refresh\nthe JWKs automatically. If the provider does not send ``Expires`` header, the\nJWKs are not refreshed.\n\n**Example**:\n\n- Auth0 publishes their JWK url at: ``https://<YOUR_AUTH0_DOMAIN>.auth0.com``.\n  But Auth0 has a bug. See known issues: :ref:`auth0-issues`.\n- Firebase publishes their JWK url at:\n  ``https://www.googleapis.com/service_accounts/v1/jwk/securetoken@system.gserviceaccount.com``.\n\n``claims_namespace``\n^^^^^^^^^^^^^^^^^^^^\nThis is an optional field. You can specify the key name\ninside which the Hasura specific claims will be present. E.g. - ``https://mydomain.com/claims``.\n\n**Default value** is: ``https://hasura.io/jwt/claims``.\n\n\n``claims_format``\n^^^^^^^^^^^^^^^^^\nThis is an optional field, with only the following possible values:\n- ``json``\n- ``stringified_json``\n\nDefault is ``json``.\n\nThis is to indicate that if the hasura specific claims are a regular JSON object\nor stringified JSON\n\nThis is required because providers like AWS Cognito only allows strings in the\nJWT claims. `See #1176 <https://github.com/hasura/graphql-engine/issues/1176>`_.\n\nExample:-\n\nIf ``claims_format`` is ``json`` then JWT claims should look like:\n\n.. code-block:: json\n\n  {\n    \"sub\": \"1234567890\",\n    \"name\": \"John Doe\",\n    \"admin\": true,\n    \"iat\": 1516239022,\n    \"https://hasura.io/jwt/claims\": {\n      \"x-hasura-allowed-roles\": [\"editor\",\"user\", \"mod\"],\n      \"x-hasura-default-role\": \"user\",\n      \"x-hasura-user-id\": \"1234567890\",\n      \"x-hasura-org-id\": \"123\",\n      \"x-hasura-custom\": \"custom-value\"\n    }\n  }\n\n\nIf ``claims_format`` is ``stringified_json`` then JWT claims should look like:\n\n.. code-block:: json\n\n  {\n    \"sub\": \"1234567890\",\n    \"name\": \"John Doe\",\n    \"admin\": true,\n    \"iat\": 1516239022,\n    \"https://hasura.io/jwt/claims\": \"{\\\"x-hasura-allowed-roles\\\":[\\\"editor\\\",\\\"user\\\",\\\"mod\\\"],\\\"x-hasura-default-role\\\":\\\"user\\\",\\\"x-hasura-user-id\\\":\\\"1234567890\\\",\\\"x-hasura-org-id\\\":\\\"123\\\",\\\"x-hasura-custom\\\":\\\"custom-value\\\"}\"\n  }\n\n``audience``\n^^^^^^^^^^^^\nThis is an optional field. Certain providers might set a claim which indicates\nthe intended audience for the JWT. This can be checked by setting this field.\n\nWhen this field is set, during the verification process of JWT, the ``aud``\nclaim in the JWT will be checked if it is equal to the ``audience`` field given\nin the configuration.\n\nSee `RFC <https://tools.ietf.org/html/rfc7519#section-4.1.3>`__ for more details.\n\nThis field can be a string, or a list of strings.\n\nExamples:\n\n.. code-block:: json\n\n   {\n     \"type\": \"RS512\",\n     \"jwk_url\": \"https://......\",\n     \"audience\": \"myapp-1234\"\n   }\n\nor\n\n.. code-block:: json\n\n   {\n     \"type\": \"RS512\",\n     \"jwk_url\": \"https://......\",\n     \"audience\": [\"myapp-1234\", \"myapp-6789\"]\n   }\n\n\n``issuer``\n^^^^^^^^^^\nThis is an optional field. It takes a string value.\n\nWhen this field is set, during the verification process of JWT, the ``iss``\nclaim in the JWT will be checked if it is equal to the ``issuer`` field given\nin the configuration.\n\nSee `RFC <https://tools.ietf.org/html/rfc7519#section-4.1.1>`__ for more details.\n\nExamples:\n\n.. code-block:: json\n\n   {\n     \"type\": \"RS512\",\n     \"jwk_url\": \"https://......\",\n     \"issuer\": \"https://my-auth-server.com\"\n   }\n\n\n\nExamples\n^^^^^^^^\n\nHMAC-SHA based\n++++++++++++++\nYour auth server is using HMAC-SHA algorithms to sign JWTs, and is using a\n256-bit key. In this case, the JWT config will look like:\n\n.. code-block:: json\n\n   {\n     \"type\":\"HS256\",\n     \"key\": \"3EK6FD+o0+c7tzBNVfjpMkNDi2yARAAKzQlk8O2IKoxQu4nF7EdAh8s3TwpHwrdWT6R\"\n   }\n\nThe ``key`` is the actual shared secret, which is used by Hasura and the external auth server.\n\nRSA based\n+++++++++\nIf your auth server is using RSA to sign JWTs, and is using a 512-bit key. In this case,\nthe JWT config needs to have the only the public key.\n\n**Example 1**: public key in PEM format (not OpenSSH format):\n\n.. code-block:: json\n\n    {\n      \"type\":\"RS512\",\n      \"key\": \"-----BEGIN PUBLIC KEY-----\\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDdlatRjRjogo3WojgGHFHYLugd\\nUWAY9iR3fy4arWNA1KoS8kVw33cJibXr8bvwUAUparCwlvdbH6dvEOfou0/gCFQs\\nHUfQrSDv+MuSUMAe8jzKE4qW+jK+xQU9a03GUnKHkkle+Q0pX/g6jXZ7r1/xAK5D\\no2kQ+X5xK9cipRgEKwIDAQAB\\n-----END PUBLIC KEY-----\\n\"\n    }\n\n**Example 2**: public key as X509 certificate:\n\n.. code-block:: json\n\n    {\n      \"type\":\"RS512\",\n      \"key\": \"-----BEGIN CERTIFICATE-----\\nMIIDHDCCAgSgAwIBAgIINw9gva8BPPIwDQYJKoZIhvcNAQEFBQAwMTEvMC0GA1UE\\nAxMmc2VjdXJldG9rZW4uc3lzdGVtLmdzZXJ2aWNlYWNjb3VudC5jb20wHhcNMTgQt7dIsMTIU9k1SUrFviZOGnmHWtIAw\\nmtYBcM9I0f9/ka45JIRp5Y1NKpAMFSShs7Wv0m1JS1kXQHdJsPSmjmDKcwnBe3R/\\nTU3foRRywR/3AJRM15FNjTqvUm7TeaW16LkkRoECAwEAAaM4MDYwDAYDVR0TAQH/\\nBAIwADAOBgNVHQ8BAf8EBAMCB4AwFgYDVR0lAQH/BAwwCgYIKwYBBQUHAwIwDQYJ\\nKoZIhvcNAQEFBQADggEBADfY2DEmc2gb8/pqMNWHYq/nTYfJPpK4VA9A0lFTNeoq\\nzmnbGwhKj24X+Nw8trsvkrKxHvCI1alDgBaCyzjGGvgOrh8X0wLtymp1yj6PWwee\\nR2ZPdUaB62TCzO0iRv7W6o39ey+mU/FyYRtxF0ecxG2a0KNsIyFkciXUAeC5UVDo\\nBNp678/SDDx9Ltuxc6h56a/hpBGf9Yzhr0RvYy3DmjBs6eopiGFmjnOKNxQrZ5t2\\n339JWR+yiGEAtoHqk/fINMf1An6Rung1xYowrm4guhCIVi5unAvQ89fq0I6mzPg6\\nLhTpeP0o+mVYrBmtYVpDpv0e71cfYowSJCCkod/9YbY=\\n-----END CERTIFICATE-----\"\n    }\n\n**Example 3**: public key published as JWKs:\n\n.. code-block:: json\n\n    {\n      \"type\":\"RS512\",\n      \"jwk_url\": \"https://www.googleapis.com/service_accounts/v1/jwk/securetoken@system.gserviceaccount.com\"\n    }\n\n\nRunning with JWT\n^^^^^^^^^^^^^^^^\nUsing the flag:\n\n.. code-block:: shell\n\n  $ docker run -p 8080:8080 \\\n      hasura/graphql-engine:latest \\\n      graphql-engine \\\n      --database-url postgres://username:password@hostname:port/dbname \\\n      serve \\\n      --admin-secret myadminsecretkey \\\n      --jwt-secret '{\"type\":\"HS256\", \"key\": \"3EK6FD+o0+c7tzBNVfjpMkNDi2yARAAKzQlk8O2IKoxQu4nF7EdAh8s3TwpHwrdWT6R\"}'\n\nUsing env vars:\n\n.. code-block:: shell\n\n  $ docker run -p 8080:8080 \\\n      -e HASURA_GRAPHQL_ADMIN_SECRET=\"myadminsecretkey\" \\\n      -e HASURA_GRAPHQL_JWT_SECRET='{\"type\":\"RS512\", \"key\": \"-----BEGIN PUBLIC KEY-----\\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDdlatRjRjogo3WojgGHFHYLugd\\nUWAY9iR3fy4arWNA1KoS8kVw33cJibXr8bvwUAUparCwlvdbH6dvEOfou0/gCFQs\\nHUfQrSDv+MuSUMAe8jzKE4qW+jK+xQU9a03GUnKHkkle+Q0pX/g6jXZ7r1/xAK5D\\no2kQ+X5xK9cipRgEKwIDAQAB\\n-----END PUBLIC KEY-----\\n\"}' \\\n      hasura/graphql-engine:latest \\\n      graphql-engine \\\n      --database-url postgres://username:password@hostname:port/dbname \\\n      serve\n\n\nPopular providers and known issues\n----------------------------------\n\nFirebase\n^^^^^^^^\nThis page of Firebase `docs <https://firebase.google.com/docs/auth/admin/verify-id-tokens#verify_id_tokens_using_a_third-party_jwt_library>`__\nmentions that JWKs are published under:\n\nhttps://www.googleapis.com/robot/v1/metadata/x509/securetoken@system.gserviceaccount.com .\n\nBut that is a non-standard format. Firebase also publishes the same certificates\nas proper JWK format under:\n\nhttps://www.googleapis.com/service_accounts/v1/jwk/securetoken@system.gserviceaccount.com .\n\nIf you are using Firebase and Hasura, use this config:\n\n.. code-block:: json\n\n   {\n     \"type\":\"RS256\",\n     \"jwk_url\": \"https://www.googleapis.com/service_accounts/v1/jwk/securetoken@system.gserviceaccount.com\",\n     \"audience\": \"<firebase-project-id>\",\n     \"issuer\": \"https://securetoken.google.com/<firebase-project-id>\"\n   }\n\n\n.. _auth0-issues:\n\nAuth0\n^^^^^\n\nRefer the :doc:`Auth0 JWT Integration guide <../../guides/integrations/auth0-jwt>` for a full integration guide\nwith Auth0\n\nAuth0 publishes their JWK under:\n\n``https://<your-auth0-domain>.auth0.com/.well-known/jwks.json``\n\nBut they have a `bug where the certificate thumbprint does not match\n<https://community.auth0.com/t/certificate-thumbprint-is-longer-than-20-bytes/7794/3>`__.\nHence, currently this URL does not work with Hasura.\n\nCurrent workaround is - download the X590 certificate from:\n\n``https://<your-auth0-domain>.auth0.com/pem``\n\nAnd use it in the ``key`` field:\n\n.. code-block:: json\n\n        {\n          \"type\":\"RS512\",\n          \"key\": \"-----BEGIN CERTIFICATE-----\n    MIIDDTCAfWgAwIBAgIJhNlZ11IDrxbMA0GCSqSIb3DQEBCwUAMCQxIjAgBgNV\n    BAMTGXlc3QtaGdlLWp3C5ldS5hdXRoMC5jb20HhcNMTgwNzMwMTM1MjM1WhcN\n    MzIwND3MTM1MjM1WjAkSIwIAYDVQQDExl0ZXNLWhnZS1qd3QuZXUuYXV0aDAu\n    Y29tMIBIjANBgkqhkiGw0BAQEFAAOCAQ8AMIICgKCAQEA13CivdSkNzRnOnR5\n    ZNiReD+AgbL7BWjRiw3RwjxRp5PYzvAGuj94yR6LRh3QybYtsMFbSg5J7fNq6\n    Ld6yMpMrUu8CBOnYY456b/2jlf+Vp8vEQuKvPOOw8Ev6x7X3blcuXCELSwyL3\n    AGHq9OP2RV6V6CIE863zzuYH5HDLzU35oMZqogJVRJM0+6besH6TnSTNiA7xi\n    BAqFaiRNQRVi1CAUa0bkN1XRp4AFy7d63VldOsM+8QnCNHySdDr1XevVuq6DK\n    LQyGexFy4niALgHV0Q7A+xP1c2G6rJomZmn4j1avnlBpU87E58JMrRHOCj+5m\n    Xj22/QDAQABo0IwQDAPgNVHRMBAf8EBTADAQHMB0GA1UdDgQWBBT6FvNkuUgu\n    tk3OYQi4lo5aOgwazAOgNVHQ8BAf8EBAMCAoQDQYJKoZIhvcNAQELBQADggEB\n    ADCLj+L22pEKyqaIUlhUJh7DAiDSLafy0fw56CntzPhqiZVVRlhxeAKidkCLV\n    r9IEbRuxUoXiQSezPqM//9xHegMp0f2VauVCFg7EpUanYwvqFqjy9LWgH+SBz\n    4uroLSZ5g1EPsHtlArLChA90caTX4e7Z7Xlu8G2kHRJB5nC7ycdbMUvEWBMeI\n    tn/pcbmZ3/vlgj4UTEnURe2UPmSJpxmPwXqBcvwdKHRMgFXhZxojWCi0z4ftf\n    f8t8UJIcbEblnkYe7wzYy8tOXoMMHqGSisCdkp/866029rJsKbwd8rVIyKNC5\n    frGYaw+0cxO6/WvSir0eA=\n    -----END CERTIFICATE-----\n    \"\n        }\n\nGenerating JWT Config\n---------------------\n\nThe JWT Config to be used in env ``HASURA_GRAPHQL_JWT_SECRET`` or ``--jwt-secret`` flag can be generated using:\nhttps://hasura.io/jwt-config.\n\n**Currently the UI supports generating config for Auth0 and Firebase**.\n\nThe config generated from this page can be directly pasted in yaml files and command line arguments as it takes\ncare of escaping new lines.\n\n.. thumbnail:: ../../../../img/graphql/manual/auth/jwt-config-generated.png\n   :width: 75%\n\nAuth JWT Examples\n-----------------\n\nHere are some sample apps that use JWT authorization. You can follow the instructions in the READMEs of the\nrepositories to get started.\n\n- `Auth0 JWT example <https://github.com/hasura/graphql-engine/tree/master/community/sample-apps/todo-auth0-jwt>`__:\n  A todo app that uses Hasura GraphQL Engine and Auth0 JWT\n\n- `Firebase JWT example <https://github.com/hasura/graphql-engine/tree/master/community/sample-apps/firebase-jwt>`__:\n  Barebones example to show how to have Firebase Auth integrated with Hasura JWT mode\n", "module Hasura.Server.Auth\n  ( getUserInfo\n  , getUserInfoWithExpTime\n  , AuthMode(..)\n  , mkAuthMode\n  , AdminSecret (..)\n  , AuthHookType(..)\n  , AuthHookG (..)\n  , AuthHook\n  -- JWT related\n  , RawJWT\n  , JWTConfig (..)\n  , JWTCtx (..)\n  , JWKSet (..)\n  , processJwt\n  , updateJwkRef\n  , jwkRefreshCtrl\n  ) where\n\nimport           Control.Exception      (try)\nimport           Control.Lens\nimport           Data.Aeson\nimport           Data.IORef             (newIORef)\nimport           Data.Time.Clock        (UTCTime)\n\nimport qualified Data.Aeson             as J\nimport qualified Data.ByteString.Lazy   as BL\nimport qualified Data.HashMap.Strict    as Map\nimport qualified Data.Text              as T\nimport qualified Network.HTTP.Client    as H\nimport qualified Network.HTTP.Types     as N\nimport qualified Network.Wreq           as Wreq\n\nimport           Hasura.HTTP\nimport           Hasura.Logging\nimport           Hasura.Prelude\nimport           Hasura.RQL.Types\nimport           Hasura.Server.Auth.JWT\nimport           Hasura.Server.Logging\nimport           Hasura.Server.Utils\n\nimport qualified Hasura.Logging         as L\n\n\nnewtype AdminSecret\n  = AdminSecret { getAdminSecret :: T.Text }\n  deriving (Show, Eq)\n\ndata AuthHookType\n  = AHTGet\n  | AHTPost\n  deriving (Eq)\n\ninstance Show AuthHookType where\n  show AHTGet  = \"GET\"\n  show AHTPost = \"POST\"\n\ndata AuthHookG a b\n  = AuthHookG\n  { ahUrl  :: !a\n  , ahType :: !b\n  } deriving (Show, Eq)\n\ntype AuthHook = AuthHookG T.Text AuthHookType\n\ndata AuthMode\n  = AMNoAuth\n  | AMAdminSecret !AdminSecret !(Maybe RoleName)\n  | AMAdminSecretAndHook !AdminSecret !AuthHook\n  | AMAdminSecretAndJWT !AdminSecret !JWTCtx !(Maybe RoleName)\n  deriving (Show, Eq)\n\nmkAuthMode\n  :: ( MonadIO m\n     , MonadError T.Text m\n     )\n  => Maybe AdminSecret\n  -> Maybe AuthHook\n  -> Maybe JWTConfig\n  -> Maybe RoleName\n  -> H.Manager\n  -> LoggerCtx\n  -> m AuthMode\nmkAuthMode mAdminSecret mWebHook mJwtSecret mUnAuthRole httpManager lCtx =\n  case (mAdminSecret, mWebHook, mJwtSecret) of\n    (Nothing,  Nothing,   Nothing)      -> return AMNoAuth\n    (Just key, Nothing,   Nothing)      -> return $ AMAdminSecret key mUnAuthRole\n    (Just key, Just hook, Nothing)      -> unAuthRoleNotReqForWebHook >>\n                                           return (AMAdminSecretAndHook key hook)\n    (Just key, Nothing,   Just jwtConf) -> do\n      jwtCtx <- mkJwtCtx jwtConf httpManager lCtx\n      return $ AMAdminSecretAndJWT key jwtCtx mUnAuthRole\n\n    (Nothing, Just _, Nothing)     -> throwError $\n      \"Fatal Error : --auth-hook (HASURA_GRAPHQL_AUTH_HOOK)\" <> requiresAdminScrtMsg\n    (Nothing, Nothing, Just _)     -> throwError $\n      \"Fatal Error : --jwt-secret (HASURA_GRAPHQL_JWT_SECRET)\" <> requiresAdminScrtMsg\n    (Nothing, Just _, Just _)     -> throwError\n      \"Fatal Error: Both webhook and JWT mode cannot be enabled at the same time\"\n    (Just _, Just _, Just _)     -> throwError\n      \"Fatal Error: Both webhook and JWT mode cannot be enabled at the same time\"\n  where\n    requiresAdminScrtMsg =\n      \" requires --admin-secret (HASURA_GRAPHQL_ADMIN_SECRET) or \"\n      <> \" --access-key (HASURA_GRAPHQL_ACCESS_KEY) to be set\"\n    unAuthRoleNotReqForWebHook =\n      when (isJust mUnAuthRole) $ throwError $\n        \"Fatal Error: --unauthorized-role (HASURA_GRAPHQL_UNAUTHORIZED_ROLE) is not allowed\"\n        <> \" when --auth-hook (HASURA_GRAPHQL_AUTH_HOOK) is set\"\n\nmkJwtCtx\n  :: ( MonadIO m\n     , MonadError T.Text m\n     )\n  => JWTConfig\n  -> H.Manager\n  -> LoggerCtx\n  -> m JWTCtx\nmkJwtCtx conf httpManager loggerCtx = do\n  jwkRef <- case jcKeyOrUrl conf of\n    Left jwk  -> liftIO $ newIORef (JWKSet [jwk])\n    Right url -> do\n      ref <- liftIO $ newIORef $ JWKSet []\n      let logger = mkLogger loggerCtx\n      mTime <- updateJwkRef logger httpManager url ref\n      case mTime of\n        Nothing -> return ref\n        Just t -> do\n          jwkRefreshCtrl logger httpManager url ref t\n          return ref\n  let claimsFmt = fromMaybe JCFJson (jcClaimsFormat conf)\n  return $ JWTCtx jwkRef (jcClaimNs conf) (jcAudience conf) claimsFmt (jcIssuer conf)\n\nmkUserInfoFromResp\n  :: (MonadIO m, MonadError QErr m)\n  => L.Logger\n  -> T.Text\n  -> N.StdMethod\n  -> N.Status\n  -> BL.ByteString\n  -> m UserInfo\nmkUserInfoFromResp logger url method statusCode respBody\n  | statusCode == N.status200 =\n    case eitherDecode respBody of\n      Left e -> do\n        logError\n        throw500 $ \"Invalid response from authorization hook: \" <> T.pack e\n      Right rawHeaders -> getUserInfoFromHdrs rawHeaders\n\n  | statusCode == N.status401 = do\n    logError\n    throw401 \"Authentication hook unauthorized this request\"\n\n  | otherwise = do\n    logError\n    throw500 \"Invalid response from authorization hook\"\n  where\n    getUserInfoFromHdrs rawHeaders = do\n      let usrVars = mkUserVars $ Map.toList rawHeaders\n      case roleFromVars usrVars of\n        Nothing -> do\n          logError\n          throw500 \"missing x-hasura-role key in webhook response\"\n        Just rn -> do\n          logWebHookResp L.LevelInfo Nothing\n          return $ mkUserInfo rn usrVars\n\n    logError =\n      logWebHookResp L.LevelError $ Just respBody\n\n    logWebHookResp logLevel mResp =\n      liftIO $ L.unLogger logger $ WebHookLog logLevel (Just statusCode)\n        url method Nothing $ fmap (bsToTxt . BL.toStrict) mResp\n\nuserInfoFromAuthHook\n  :: (MonadIO m, MonadError QErr m)\n  => L.Logger\n  -> H.Manager\n  -> AuthHook\n  -> [N.Header]\n  -> m UserInfo\nuserInfoFromAuthHook logger manager hook reqHeaders = do\n  res <- liftIO $ try $ bool withGET withPOST isPost\n  resp <- either logAndThrow return res\n  let status = resp ^. Wreq.responseStatus\n      respBody = resp ^. Wreq.responseBody\n\n  mkUserInfoFromResp logger urlT method status respBody\n  where\n    mkOptions = wreqOptions manager\n    AuthHookG urlT ty = hook\n    isPost = case ty of\n      AHTPost -> True\n      AHTGet  -> False\n    method = bool N.GET N.POST isPost\n\n    withGET = Wreq.getWith (mkOptions filteredHeaders) $\n              T.unpack urlT\n\n    contentType = (\"Content-Type\", \"application/json\")\n    postHdrsPayload = J.toJSON $ Map.fromList $ hdrsToText reqHeaders\n    withPOST = Wreq.postWith (mkOptions [contentType]) (T.unpack urlT) $\n               object [\"headers\" J..= postHdrsPayload]\n\n    logAndThrow err = do\n      liftIO $ L.unLogger logger $\n        WebHookLog L.LevelError Nothing urlT method\n        (Just $ HttpException err) Nothing\n      throw500 \"Internal Server Error\"\n\n    filteredHeaders = flip filter reqHeaders $ \\(n, _) ->\n      n `notElem` commonClientHeadersIgnored\n\ngetUserInfo\n  :: (MonadIO m, MonadError QErr m)\n  => L.Logger\n  -> H.Manager\n  -> [N.Header]\n  -> AuthMode\n  -> m UserInfo\ngetUserInfo l m r a = fst <$> getUserInfoWithExpTime l m r a\n\ngetUserInfoWithExpTime\n  :: (MonadIO m, MonadError QErr m)\n  => L.Logger\n  -> H.Manager\n  -> [N.Header]\n  -> AuthMode\n  -> m (UserInfo, Maybe UTCTime)\ngetUserInfoWithExpTime logger manager rawHeaders = \\case\n\n  AMNoAuth -> return (userInfoFromHeaders, Nothing)\n\n  AMAdminSecret adminScrt unAuthRole ->\n    case adminSecretM of\n      Just givenAdminScrt ->\n        withNoExpTime $ userInfoWhenAdminSecret adminScrt givenAdminScrt\n      Nothing             ->\n        withNoExpTime $ userInfoWhenNoAdminSecret unAuthRole\n\n  AMAdminSecretAndHook accKey hook ->\n    whenAdminSecretAbsent accKey $\n      withNoExpTime $ userInfoFromAuthHook logger manager hook rawHeaders\n\n  AMAdminSecretAndJWT accKey jwtSecret unAuthRole ->\n    whenAdminSecretAbsent accKey (processJwt jwtSecret rawHeaders unAuthRole)\n\n  where\n    -- when admin secret is absent, run the action to retrieve UserInfo, otherwise\n    -- adminsecret override\n    whenAdminSecretAbsent ak action =\n      maybe action (withNoExpTime . userInfoWhenAdminSecret ak) adminSecretM\n\n    adminSecretM= foldl1 (<|>) $\n      map (`getVarVal` usrVars) [adminSecretHeader, deprecatedAccessKeyHeader]\n\n    usrVars = mkUserVars $ hdrsToText rawHeaders\n\n    userInfoFromHeaders =\n      case roleFromVars usrVars of\n        Just rn -> mkUserInfo rn usrVars\n        Nothing -> mkUserInfo adminRole usrVars\n\n    userInfoWhenAdminSecret key reqKey = do\n      when (reqKey /= getAdminSecret key) $ throw401 $\n        \"invalid \" <> adminSecretHeader <> \"/\" <> deprecatedAccessKeyHeader\n      return userInfoFromHeaders\n\n    userInfoWhenNoAdminSecret = \\case\n      Nothing -> throw401 $ adminSecretHeader <> \"/\"\n                 <>  deprecatedAccessKeyHeader <> \" required, but not found\"\n      Just role -> return $ mkUserInfo role usrVars\n\n    withNoExpTime a = (, Nothing) <$> a\n", "module Hasura.Server.Auth.JWT\n  ( processJwt\n  , RawJWT\n  , JWTConfig (..)\n  , JWTCtx (..)\n  , Jose.JWKSet (..)\n  , JWTClaimsFormat (..)\n  , updateJwkRef\n  , jwkRefreshCtrl\n  , defaultClaimNs\n  ) where\n\nimport           Control.Arrow                   (first)\nimport           Control.Exception               (try)\nimport           Control.Lens\nimport           Control.Monad                   (when)\nimport           Data.IORef                      (IORef, modifyIORef, readIORef)\n\nimport           Data.List                       (find)\nimport           Data.Time.Clock                 (NominalDiffTime, UTCTime,\n                                                  diffUTCTime, getCurrentTime)\nimport           Data.Time.Format                (defaultTimeLocale, parseTimeM)\nimport           Network.URI                     (URI)\n\nimport           Hasura.HTTP\nimport           Hasura.Logging                  (LogLevel (..), Logger (..))\nimport           Hasura.Prelude\nimport           Hasura.RQL.Types\nimport           Hasura.Server.Auth.JWT.Internal (parseHmacKey, parseRsaKey)\nimport           Hasura.Server.Auth.JWT.Logging\nimport           Hasura.Server.Utils             (diffTimeToMicro,\n                                                  userRoleHeader)\n\nimport qualified Control.Concurrent              as C\nimport qualified Crypto.JWT                      as Jose\nimport qualified Data.Aeson                      as A\nimport qualified Data.Aeson.Casing               as A\nimport qualified Data.Aeson.TH                   as A\nimport qualified Data.ByteString.Lazy            as BL\nimport qualified Data.ByteString.Lazy.Char8      as BLC\nimport qualified Data.CaseInsensitive            as CI\nimport qualified Data.HashMap.Strict             as Map\nimport qualified Data.String.Conversions         as CS\nimport qualified Data.Text                       as T\nimport qualified Data.Text.Encoding              as T\nimport qualified Network.HTTP.Client             as HTTP\nimport qualified Network.HTTP.Types              as HTTP\nimport qualified Network.Wreq                    as Wreq\n\n\nnewtype RawJWT = RawJWT BL.ByteString\n\ndata JWTClaimsFormat\n  = JCFJson\n  | JCFStringifiedJson\n  deriving (Show, Eq)\n\n$(A.deriveJSON A.defaultOptions { A.sumEncoding = A.ObjectWithSingleField\n                                , A.constructorTagModifier = A.snakeCase . drop 3\n                                } ''JWTClaimsFormat)\n\ndata JWTConfig\n  = JWTConfig\n  { jcType         :: !T.Text\n  , jcKeyOrUrl     :: !(Either Jose.JWK URI)\n  , jcClaimNs      :: !(Maybe T.Text)\n  , jcAudience     :: !(Maybe Jose.Audience)\n  , jcClaimsFormat :: !(Maybe JWTClaimsFormat)\n  , jcIssuer       :: !(Maybe Jose.StringOrURI)\n  } deriving (Show, Eq)\n\ndata JWTCtx\n  = JWTCtx\n  { jcxKey          :: !(IORef Jose.JWKSet)\n  , jcxClaimNs      :: !(Maybe T.Text)\n  , jcxAudience     :: !(Maybe Jose.Audience)\n  , jcxClaimsFormat :: !JWTClaimsFormat\n  , jcxIssuer       :: !(Maybe Jose.StringOrURI)\n  } deriving (Eq)\n\ninstance Show JWTCtx where\n  show (JWTCtx _ nsM audM cf iss) =\n    show [\"<IORef JWKSet>\", show nsM, show audM, show cf, show iss]\n\ndata HasuraClaims\n  = HasuraClaims\n  { _cmAllowedRoles :: ![RoleName]\n  , _cmDefaultRole  :: !RoleName\n  } deriving (Show, Eq)\n$(A.deriveJSON (A.aesonDrop 3 A.snakeCase) ''HasuraClaims)\n\nallowedRolesClaim :: T.Text\nallowedRolesClaim = \"x-hasura-allowed-roles\"\n\ndefaultRoleClaim :: T.Text\ndefaultRoleClaim = \"x-hasura-default-role\"\n\ndefaultClaimNs :: T.Text\ndefaultClaimNs = \"https://hasura.io/jwt/claims\"\n\n-- | create a background thread to refresh the JWK\njwkRefreshCtrl\n  :: (MonadIO m)\n  => Logger\n  -> HTTP.Manager\n  -> URI\n  -> IORef Jose.JWKSet\n  -> NominalDiffTime\n  -> m ()\njwkRefreshCtrl lggr mngr url ref time =\n  void $ liftIO $ C.forkIO $ do\n    C.threadDelay $ diffTimeToMicro time\n    forever $ do\n      res <- runExceptT $ updateJwkRef lggr mngr url ref\n      mTime <- either (const $ return Nothing) return res\n      C.threadDelay $ maybe (60 * aSecond) diffTimeToMicro mTime\n  where\n    aSecond = 1000 * 1000\n\n\n-- | Given a JWK url, fetch JWK from it and update the IORef\nupdateJwkRef\n  :: ( MonadIO m\n     , MonadError T.Text m)\n  => Logger\n  -> HTTP.Manager\n  -> URI\n  -> IORef Jose.JWKSet\n  -> m (Maybe NominalDiffTime)\nupdateJwkRef (Logger logger) manager url jwkRef = do\n  let options = wreqOptions manager []\n      urlT    = T.pack $ show url\n      infoMsg = \"refreshing JWK from endpoint: \" <> urlT\n  liftIO $ logger $ JwkRefreshLog LevelInfo infoMsg Nothing\n  res  <- liftIO $ try $ Wreq.getWith options $ show url\n  resp <- either logAndThrowHttp return res\n  let status = resp ^. Wreq.responseStatus\n      respBody = resp ^. Wreq.responseBody\n\n  when (status ^. Wreq.statusCode /= 200) $ do\n    let respBodyT = Just $ CS.cs respBody\n        errMsg = \"Non-200 response on fetching JWK from: \" <> urlT\n        httpErr = Just (JwkRefreshHttpError (Just status) urlT Nothing respBodyT)\n    logAndThrow errMsg httpErr\n\n  let parseErr e = \"Error parsing JWK from url (\" <> urlT <> \"): \" <> T.pack e\n  jwkset <- either (\\e -> logAndThrow (parseErr e) Nothing) return $\n    A.eitherDecode respBody\n  liftIO $ modifyIORef jwkRef (const jwkset)\n\n  let mExpiresT = resp ^? Wreq.responseHeader \"Expires\"\n  forM mExpiresT $ \\expiresT -> do\n    let expiresE = parseTimeM True defaultTimeLocale timeFmt $ CS.cs expiresT\n    expires  <- either (`logAndThrow` Nothing) return expiresE\n    currTime <- liftIO getCurrentTime\n    return $ diffUTCTime expires currTime\n\n  where\n    logAndThrow :: (MonadIO m, MonadError T.Text m) => T.Text -> Maybe JwkRefreshHttpError -> m a\n    logAndThrow err httpErr = do\n      liftIO $ logger $ JwkRefreshLog (LevelOther \"critical\") err httpErr\n      throwError err\n\n    logAndThrowHttp :: (MonadIO m, MonadError T.Text m) => HTTP.HttpException -> m a\n    logAndThrowHttp err = do\n      let httpErr = JwkRefreshHttpError Nothing (T.pack $ show url)\n                    (Just $ HttpException err) Nothing\n          errMsg = \"Error fetching JWK: \" <> T.pack (show err)\n      logAndThrow errMsg (Just httpErr)\n\n    timeFmt = \"%a, %d %b %Y %T GMT\"\n\n\n-- | Process the request headers to verify the JWT and extract UserInfo from it\nprocessJwt\n  :: ( MonadIO m\n     , MonadError QErr m)\n  => JWTCtx\n  -> HTTP.RequestHeaders\n  -> Maybe RoleName\n  -> m (UserInfo, Maybe UTCTime)\nprocessJwt jwtCtx headers mUnAuthRole =\n  maybe withoutAuthZHeader withAuthZHeader mAuthZHeader\n  where\n    mAuthZHeader = find (\\h -> fst h == CI.mk \"Authorization\") headers\n\n    withAuthZHeader (_, authzHeader) =\n      processAuthZHeader jwtCtx headers $ BL.fromStrict authzHeader\n\n    withoutAuthZHeader = do\n      unAuthRole <- maybe missingAuthzHeader return mUnAuthRole\n      return $ (, Nothing) $\n        mkUserInfo unAuthRole $ mkUserVars $ hdrsToText headers\n\n    missingAuthzHeader =\n      throw400 InvalidHeaders \"Missing Authorization header in JWT authentication mode\"\n\nprocessAuthZHeader\n  :: ( MonadIO m\n     , MonadError QErr m)\n  => JWTCtx\n  -> HTTP.RequestHeaders\n  -> BLC.ByteString\n  -> m (UserInfo, Maybe UTCTime)\nprocessAuthZHeader jwtCtx headers authzHeader = do\n  -- try to parse JWT token from Authorization header\n  jwt <- parseAuthzHeader\n\n  -- verify the JWT\n  claims <- liftJWTError invalidJWTError $ verifyJwt jwtCtx $ RawJWT jwt\n\n  let claimsNs  = fromMaybe defaultClaimNs $ jcxClaimNs jwtCtx\n      claimsFmt = jcxClaimsFormat jwtCtx\n      expTimeM = fmap (\\(Jose.NumericDate t) -> t) $ claims ^. Jose.claimExp\n\n  -- see if the hasura claims key exist in the claims map\n  let mHasuraClaims = Map.lookup claimsNs $ claims ^. Jose.unregisteredClaims\n  hasuraClaimsV <- maybe claimsNotFound return mHasuraClaims\n\n  -- get hasura claims value as an object. parse from string possibly\n  hasuraClaims <- parseObjectFromString claimsFmt hasuraClaimsV\n\n  -- filter only x-hasura claims and convert to lower-case\n  let claimsMap = Map.filterWithKey (\\k _ -> T.isPrefixOf \"x-hasura-\" k)\n                $ Map.fromList $ map (first T.toLower)\n                $ Map.toList hasuraClaims\n\n  HasuraClaims allowedRoles defaultRole <- parseHasuraClaims claimsMap\n  let role = getCurrentRole defaultRole\n\n  when (role `notElem` allowedRoles) currRoleNotAllowed\n  let finalClaims =\n        Map.delete defaultRoleClaim . Map.delete allowedRolesClaim $ claimsMap\n\n  -- transform the map of text:aeson-value -> text:text\n  metadata <- decodeJSON $ A.Object finalClaims\n\n  return $ (, expTimeM) $ mkUserInfo role $ mkUserVars $ Map.toList metadata\n\n  where\n    parseAuthzHeader = do\n      let tokenParts = BLC.words authzHeader\n      case tokenParts of\n        [\"Bearer\", jwt] -> return jwt\n        _               -> malformedAuthzHeader\n\n    parseObjectFromString claimsFmt jVal =\n      case (claimsFmt, jVal) of\n        (JCFStringifiedJson, A.String v) ->\n          either (const $ claimsErr $ strngfyErr v) return\n          $ A.eitherDecodeStrict $ T.encodeUtf8 v\n        (JCFStringifiedJson, _) ->\n          claimsErr \"expecting a string when claims_format is stringified_json\"\n        (JCFJson, A.Object o) -> return o\n        (JCFJson, _) ->\n          claimsErr \"expecting a json object when claims_format is json\"\n\n    strngfyErr v = \"expecting stringified json at: '\"\n                   <> fromMaybe defaultClaimNs (jcxClaimNs jwtCtx)\n                   <> \"', but found: \" <> v\n\n    claimsErr = throw400 JWTInvalidClaims\n\n    -- see if there is a x-hasura-role header, or else pick the default role\n    getCurrentRole defaultRole =\n      let userRoleHeaderB = CS.cs userRoleHeader\n          mUserRole = snd <$> find (\\h -> fst h == CI.mk userRoleHeaderB) headers\n      in maybe defaultRole RoleName $ mUserRole >>= mkNonEmptyText . bsToTxt\n\n    decodeJSON val = case A.fromJSON val of\n      A.Error e   -> throw400 JWTInvalidClaims (\"x-hasura-* claims: \" <> T.pack e)\n      A.Success a -> return a\n\n    liftJWTError :: (MonadError e' m) => (e -> e') -> ExceptT e m a -> m a\n    liftJWTError ef action = do\n      res <- runExceptT action\n      either (throwError . ef) return res\n\n    invalidJWTError e =\n      err400 JWTInvalid $ \"Could not verify JWT: \" <> T.pack (show e)\n\n    malformedAuthzHeader =\n      throw400 InvalidHeaders \"Malformed Authorization header\"\n    currRoleNotAllowed =\n      throw400 AccessDenied \"Your current role is not in allowed roles\"\n    claimsNotFound = do\n      let claimsNs = fromMaybe defaultClaimNs $ jcxClaimNs jwtCtx\n      throw400 JWTInvalidClaims $ \"claims key: '\" <> claimsNs <> \"' not found\"\n\n\n-- parse x-hasura-allowed-roles, x-hasura-default-role from JWT claims\nparseHasuraClaims\n  :: (MonadError QErr m)\n  => A.Object -> m HasuraClaims\nparseHasuraClaims claimsMap = do\n  let mAllowedRolesV = Map.lookup allowedRolesClaim claimsMap\n  allowedRolesV <- maybe missingAllowedRolesClaim return mAllowedRolesV\n  allowedRoles <- parseJwtClaim (A.fromJSON allowedRolesV) errMsg\n\n  let mDefaultRoleV = Map.lookup defaultRoleClaim claimsMap\n  defaultRoleV <- maybe missingDefaultRoleClaim return mDefaultRoleV\n  defaultRole <- parseJwtClaim (A.fromJSON defaultRoleV) errMsg\n\n  return $ HasuraClaims allowedRoles defaultRole\n\n  where\n    missingAllowedRolesClaim =\n      let msg = \"JWT claim does not contain \" <> allowedRolesClaim\n      in throw400 JWTRoleClaimMissing msg\n\n    missingDefaultRoleClaim =\n      let msg = \"JWT claim does not contain \" <> defaultRoleClaim\n      in throw400 JWTRoleClaimMissing msg\n\n    errMsg _ = \"invalid \" <> allowedRolesClaim <> \"; should be a list of roles\"\n\n    parseJwtClaim :: (MonadError QErr m) => A.Result a -> (String -> Text) -> m a\n    parseJwtClaim res errFn =\n      case res of\n        A.Success val -> return val\n        A.Error e     -> throw400 JWTInvalidClaims $ errFn e\n\n\n-- | Verify the JWT against given JWK\nverifyJwt\n  :: ( MonadError Jose.JWTError m\n     , MonadIO m\n     )\n  => JWTCtx\n  -> RawJWT\n  -> m Jose.ClaimsSet\nverifyJwt ctx (RawJWT rawJWT) = do\n  key <- liftIO $ readIORef $ jcxKey ctx\n  jwt <- Jose.decodeCompact rawJWT\n  t   <- liftIO getCurrentTime\n  Jose.verifyClaimsAt config key t jwt\n  where\n    config = case jcxIssuer ctx of\n      Nothing  -> Jose.defaultJWTValidationSettings audCheck\n      Just iss -> Jose.defaultJWTValidationSettings audCheck\n                  & set Jose.issuerPredicate (== iss)\n    audCheck audience =\n      -- dont perform the check if there are no audiences in the conf\n      case jcxAudience ctx of\n        Nothing                        -> True\n        Just (Jose.Audience audiences) -> audience `elem` audiences\n\n\ninstance A.ToJSON JWTConfig where\n  toJSON (JWTConfig ty keyOrUrl claimNs aud claimsFmt iss) =\n    case keyOrUrl of\n         Left _    -> mkObj (\"key\" A..= A.String \"<JWK REDACTED>\")\n         Right url -> mkObj (\"jwk_url\" A..= url)\n    where\n      mkObj item = A.object [ \"type\" A..= ty\n                            , \"claims_namespace\" A..= claimNs\n                            , \"claims_format\" A..= claimsFmt\n                            , \"audience\" A..= aud\n                            , \"issuer\" A..= iss\n                            , item\n                            ]\n\n-- | Parse from a json string like:\n-- | `{\"type\": \"RS256\", \"key\": \"<PEM-encoded-public-key-or-X509-cert>\"}`\n-- | to JWTConfig\ninstance A.FromJSON JWTConfig where\n\n  parseJSON = A.withObject \"JWTConfig\" $ \\o -> do\n    keyType <- o A..: \"type\"\n    mRawKey <- o A..:? \"key\"\n    claimNs <- o A..:? \"claims_namespace\"\n    aud     <- o A..:? \"audience\"\n    iss     <- o A..:? \"issuer\"\n    jwkUrl  <- o A..:? \"jwk_url\"\n    isStrngfd <- o A..:? \"claims_format\"\n\n    case (mRawKey, jwkUrl) of\n      (Nothing, Nothing) -> fail \"key and jwk_url both cannot be empty\"\n      (Just _, Just _)   -> fail \"key, jwk_url both cannot be present\"\n      (Just rawKey, Nothing) -> do\n        key <- parseKey keyType rawKey\n        return $ JWTConfig keyType (Left key) claimNs aud isStrngfd iss\n      (Nothing, Just url) ->\n        return $ JWTConfig keyType (Right url) claimNs aud isStrngfd iss\n\n    where\n      parseKey keyType rawKey =\n       case keyType of\n          \"HS256\" -> runEither $ parseHmacKey rawKey 256\n          \"HS384\" -> runEither $ parseHmacKey rawKey 384\n          \"HS512\" -> runEither $ parseHmacKey rawKey 512\n          \"RS256\" -> runEither $ parseRsaKey rawKey\n          \"RS384\" -> runEither $ parseRsaKey rawKey\n          \"RS512\" -> runEither $ parseRsaKey rawKey\n          -- TODO: support ES256, ES384, ES512, PS256, PS384\n          _       -> invalidJwk (\"Key type: \" <> T.unpack keyType <> \" is not supported\")\n\n      runEither = either (invalidJwk . T.unpack) return\n      invalidJwk msg = fail (\"Invalid JWK: \" <> msg)\n", "from datetime import datetime, timedelta\nimport math\nimport json\nimport time\n\nimport yaml\nimport pytest\nimport jwt\nfrom test_subscriptions import init_ws_conn\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.hazmat.primitives import serialization\n\nfrom validate import check_query\n\n\nif not pytest.config.getoption('--hge-jwt-key-file'):\n    pytest.skip('--hge-jwt-key-file is missing, skipping JWT tests', allow_module_level=True)\n\nif not pytest.config.getoption('--hge-jwt-conf'):\n    pytest.skip('--hge-jwt-key-conf is missing, skipping JWT tests', allow_module_level=True)\n\ndef get_claims_fmt(raw_conf):\n    conf = json.loads(raw_conf)\n    try:\n        claims_fmt = conf['claims_format']\n    except KeyError:\n        claims_fmt = 'json'\n    return claims_fmt\n\ndef mk_claims(conf, claims):\n    claims_fmt = get_claims_fmt(conf)\n    if claims_fmt == 'json':\n        return claims\n    elif claims_fmt == 'stringified_json':\n        return json.dumps(claims)\n    else:\n        return claims\n\n@pytest.mark.parametrize('endpoint', ['/v1/graphql', '/v1alpha1/graphql'])\nclass TestJWTBasic():\n\n    def test_jwt_valid_claims_success(self, hge_ctx, endpoint):\n        self.claims['https://hasura.io/jwt/claims'] = mk_claims(hge_ctx.hge_jwt_conf, {\n            'x-hasura-user-id': '1',\n            'x-hasura-allowed-roles': ['user', 'editor'],\n            'x-hasura-default-role': 'user'\n        })\n        token = jwt.encode(self.claims, hge_ctx.hge_jwt_key, algorithm='RS512').decode('utf-8')\n        self.conf['headers']['Authorization'] = 'Bearer ' + token\n        self.conf['url'] = endpoint\n        self.conf['status'] = 200\n        check_query(hge_ctx, self.conf, add_auth=False)\n\n    def test_jwt_invalid_role_in_request_header(self, hge_ctx, endpoint):\n        self.claims['https://hasura.io/jwt/claims'] = mk_claims(hge_ctx.hge_jwt_conf, {\n            'x-hasura-user-id': '1',\n            'x-hasura-allowed-roles': ['contractor', 'editor'],\n            'x-hasura-default-role': 'contractor'\n        })\n        token = jwt.encode(self.claims, hge_ctx.hge_jwt_key, algorithm='RS512').decode('utf-8')\n        self.conf['headers']['Authorization'] = 'Bearer ' + token\n        self.conf['response'] = {\n            'errors': [{\n                'extensions': {\n                    'code': 'access-denied',\n                    'path': '$'\n                },\n                'message': 'Your current role is not in allowed roles'\n            }]\n        }\n        self.conf['url'] = endpoint\n        if endpoint == '/v1/graphql':\n            self.conf['status'] = 200\n        if endpoint == '/v1alpha1/graphql':\n            self.conf['status'] = 400\n        check_query(hge_ctx, self.conf, add_auth=False)\n\n    def test_jwt_no_allowed_roles_in_claim(self, hge_ctx, endpoint):\n        self.claims['https://hasura.io/jwt/claims'] = mk_claims(hge_ctx.hge_jwt_conf, {\n            'x-hasura-user-id': '1',\n            'x-hasura-default-role': 'user'\n        })\n        token = jwt.encode(self.claims, hge_ctx.hge_jwt_key, algorithm='RS512').decode('utf-8')\n        self.conf['headers']['Authorization'] = 'Bearer ' + token\n        self.conf['response'] = {\n            'errors': [{\n                'extensions': {\n                    'code': 'jwt-missing-role-claims',\n                    'path': '$'\n                },\n                'message': 'JWT claim does not contain x-hasura-allowed-roles'\n            }]\n        }\n        self.conf['url'] = endpoint\n        if endpoint == '/v1/graphql':\n            self.conf['status'] = 200\n        if endpoint == '/v1alpha1/graphql':\n            self.conf['status'] = 400\n        check_query(hge_ctx, self.conf, add_auth=False)\n\n    def test_jwt_invalid_allowed_roles_in_claim(self, hge_ctx, endpoint):\n        self.claims['https://hasura.io/jwt/claims'] = mk_claims(hge_ctx.hge_jwt_conf, {\n            'x-hasura-user-id': '1',\n            'x-hasura-allowed-roles': 'user',\n            'x-hasura-default-role': 'user'\n        })\n        token = jwt.encode(self.claims, hge_ctx.hge_jwt_key, algorithm='RS512').decode('utf-8')\n        self.conf['headers']['Authorization'] = 'Bearer ' + token\n        self.conf['response'] = {\n            'errors': [{\n                'extensions': {\n                    'code': 'jwt-invalid-claims',\n                    'path': '$'\n                },\n                'message': 'invalid x-hasura-allowed-roles; should be a list of roles'\n            }]\n        }\n        self.conf['url'] = endpoint\n        if endpoint == '/v1/graphql':\n            self.conf['status'] = 200\n        if endpoint == '/v1alpha1/graphql':\n            self.conf['status'] = 400\n        check_query(hge_ctx, self.conf, add_auth=False)\n\n    def test_jwt_no_default_role(self, hge_ctx, endpoint):\n        self.claims['https://hasura.io/jwt/claims'] = mk_claims(hge_ctx.hge_jwt_conf, {\n            'x-hasura-user-id': '1',\n            'x-hasura-allowed-roles': ['user'],\n        })\n        token = jwt.encode(self.claims, hge_ctx.hge_jwt_key, algorithm='RS512').decode('utf-8')\n        self.conf['headers']['Authorization'] = 'Bearer ' + token\n        self.conf['response'] = {\n            'errors': [{\n                'extensions': {\n                    'code': 'jwt-missing-role-claims',\n                    'path': '$'\n                },\n                'message': 'JWT claim does not contain x-hasura-default-role'\n            }]\n        }\n        self.conf['url'] = endpoint\n        if endpoint == '/v1/graphql':\n            self.conf['status'] = 200\n        if endpoint == '/v1alpha1/graphql':\n            self.conf['status'] = 400\n        check_query(hge_ctx, self.conf, add_auth=False)\n\n    def test_jwt_expired(self, hge_ctx, endpoint):\n        self.claims['https://hasura.io/jwt/claims'] = mk_claims(hge_ctx.hge_jwt_conf, {\n            'x-hasura-user-id': '1',\n            'x-hasura-default-role': 'user',\n            'x-hasura-allowed-roles': ['user'],\n        })\n        exp = datetime.now() - timedelta(minutes=1)\n        self.claims['exp'] = round(exp.timestamp())\n\n        token = jwt.encode(self.claims, hge_ctx.hge_jwt_key, algorithm='RS512').decode('utf-8')\n        self.conf['headers']['Authorization'] = 'Bearer ' + token\n        self.conf['response'] = {\n            'errors': [{\n                'extensions': {\n                    'code': 'invalid-jwt',\n                    'path': '$'\n                },\n                'message': 'Could not verify JWT: JWTExpired'\n            }]\n        }\n        self.conf['url'] = endpoint\n        if endpoint == '/v1/graphql':\n            self.conf['status'] = 200\n        if endpoint == '/v1alpha1/graphql':\n            self.conf['status'] = 400\n        check_query(hge_ctx, self.conf, add_auth=False)\n\n    def test_jwt_invalid_signature(self, hge_ctx, endpoint):\n        self.claims['https://hasura.io/jwt/claims'] = mk_claims(hge_ctx.hge_jwt_conf, {\n            'x-hasura-user-id': '1',\n            'x-hasura-default-role': 'user',\n            'x-hasura-allowed-roles': ['user'],\n        })\n\n        wrong_key = gen_rsa_key()\n        token = jwt.encode(self.claims, wrong_key, algorithm='HS256').decode('utf-8')\n        self.conf['headers']['Authorization'] = 'Bearer ' + token\n        self.conf['response'] = {\n            'errors': [{\n                'extensions': {\n                    'code': 'invalid-jwt',\n                    'path': '$'\n                },\n                'message': 'Could not verify JWT: JWSError JWSInvalidSignature'\n            }]\n        }\n        self.conf['url'] = endpoint\n        if endpoint == '/v1/graphql':\n            self.conf['status'] = 200\n        if endpoint == '/v1alpha1/graphql':\n            self.conf['status'] = 400\n        check_query(hge_ctx, self.conf, add_auth=False)\n\n    def test_jwt_no_audience_in_conf(self, hge_ctx, endpoint):\n        self.claims['https://hasura.io/jwt/claims'] = mk_claims(hge_ctx.hge_jwt_conf, {\n            'x-hasura-user-id': '1',\n            'x-hasura-default-role': 'user',\n            'x-hasura-allowed-roles': ['user'],\n        })\n\n        self.claims['aud'] = 'hasura-test-suite'\n        token = jwt.encode(self.claims, hge_ctx.hge_jwt_key, algorithm='RS512').decode('utf-8')\n        self.conf['headers']['Authorization'] = 'Bearer ' + token\n        self.conf['url'] = endpoint\n        check_query(hge_ctx, self.conf, add_auth=False)\n\n    def test_jwt_no_issuer_in_conf(self, hge_ctx, endpoint):\n        self.claims['https://hasura.io/jwt/claims'] = mk_claims(hge_ctx.hge_jwt_conf, {\n            'x-hasura-user-id': '1',\n            'x-hasura-default-role': 'user',\n            'x-hasura-allowed-roles': ['user'],\n        })\n\n        self.claims['iss'] = 'rubbish-issuer'\n        token = jwt.encode(self.claims, hge_ctx.hge_jwt_key, algorithm='RS512').decode('utf-8')\n        self.conf['headers']['Authorization'] = 'Bearer ' + token\n        self.conf['url'] = endpoint\n        check_query(hge_ctx, self.conf, add_auth=False)\n\n    @pytest.fixture(autouse=True)\n    def transact(self, setup):\n        self.dir = 'queries/graphql_query/permissions'\n        with open(self.dir + '/user_select_query_unpublished_articles.yaml') as c:\n            self.conf = yaml.safe_load(c)\n        curr_time = datetime.now()\n        exp_time = curr_time + timedelta(hours=1)\n        self.claims = {\n            'sub': '1234567890',\n            'name': 'John Doe',\n            'iat': math.floor(curr_time.timestamp()),\n            'exp': math.floor(exp_time.timestamp())\n        }\n\n    @pytest.fixture(scope='class')\n    def setup(self, request, hge_ctx):\n        self.dir = 'queries/graphql_query/permissions'\n        st_code, resp = hge_ctx.v1q_f(self.dir + '/setup.yaml')\n        assert st_code == 200, resp\n        yield\n        st_code, resp = hge_ctx.v1q_f(self.dir + '/teardown.yaml')\n        assert st_code == 200, resp\n\n\ndef gen_rsa_key():\n    private_key = rsa.generate_private_key(\n        public_exponent=65537,\n        key_size=2048,\n        backend=default_backend()\n    )\n    pem = private_key.private_bytes(\n        encoding=serialization.Encoding.PEM,\n        format=serialization.PrivateFormat.TraditionalOpenSSL,\n        encryption_algorithm=serialization.NoEncryption()\n    )\n    return pem\n\nclass TestSubscriptionJwtExpiry(object):\n\n    def test_jwt_expiry(self, hge_ctx, ws_client):\n        curr_time = datetime.now()\n        self.claims = {\n            'sub': '1234567890',\n            'name': 'John Doe',\n            'iat': math.floor(curr_time.timestamp())\n        }\n        self.claims['https://hasura.io/jwt/claims'] = mk_claims(hge_ctx.hge_jwt_conf, {\n            'x-hasura-user-id': '1',\n            'x-hasura-default-role': 'user',\n            'x-hasura-allowed-roles': ['user'],\n        })\n        exp = curr_time + timedelta(seconds=5)\n        self.claims['exp'] = round(exp.timestamp())\n        token = jwt.encode(self.claims, hge_ctx.hge_jwt_key, algorithm='RS512').decode('utf-8')\n        payload = {\n            'headers': {\n                'Authorization': 'Bearer ' + token\n            }\n        }\n        init_ws_conn(hge_ctx, ws_client, payload)\n        time.sleep(5)\n        assert ws_client.remote_closed == True, ws_client.remote_closed\n\n\n@pytest.mark.parametrize('endpoint', ['/v1/graphql', '/v1alpha1/graphql'])\nclass TestJwtAudienceCheck():\n    def test_jwt_valid_audience(self, hge_ctx, endpoint):\n        jwt_conf = json.loads(hge_ctx.hge_jwt_conf)\n        if 'audience' not in jwt_conf:\n            pytest.skip('audience not present in conf, skipping testing audience')\n\n        audience = jwt_conf['audience']\n        audience = audience if isinstance(audience, str) else audience[0]\n        self.claims['https://hasura.io/jwt/claims'] = mk_claims(hge_ctx.hge_jwt_conf, {\n            'x-hasura-user-id': '1',\n            'x-hasura-default-role': 'user',\n            'x-hasura-allowed-roles': ['user'],\n        })\n        self.claims['aud'] = audience\n\n        token = jwt.encode(self.claims, hge_ctx.hge_jwt_key, algorithm='RS512').decode('utf-8')\n        self.conf['headers']['Authorization'] = 'Bearer ' + token\n        check_query(hge_ctx, self.conf, add_auth=False)\n\n    def test_jwt_invalid_audience(self, hge_ctx, endpoint):\n        jwt_conf = json.loads(hge_ctx.hge_jwt_conf)\n        if 'audience' not in jwt_conf:\n            pytest.skip('audience not present in conf, skipping testing audience')\n\n        self.claims['https://hasura.io/jwt/claims'] = mk_claims(hge_ctx.hge_jwt_conf, {\n            'x-hasura-user-id': '1',\n            'x-hasura-default-role': 'user',\n            'x-hasura-allowed-roles': ['user'],\n        })\n        self.claims['aud'] = 'rubbish_audience'\n\n        token = jwt.encode(self.claims, hge_ctx.hge_jwt_key, algorithm='RS512').decode('utf-8')\n        self.conf['headers']['Authorization'] = 'Bearer ' + token\n        self.conf['response'] = {\n            'errors': [{\n                'extensions': {\n                    'code': 'invalid-jwt',\n                    'path': '$'\n                },\n                'message': 'Could not verify JWT: JWTNotInAudience'\n            }]\n        }\n        self.conf['url'] = endpoint\n        if endpoint == '/v1/graphql':\n            self.conf['status'] = 200\n        if endpoint == '/v1alpha1/graphql':\n            self.conf['status'] = 400\n        check_query(hge_ctx, self.conf, add_auth=False)\n\n    @pytest.fixture(autouse=True)\n    def transact(self, setup):\n        self.dir = 'queries/graphql_query/permissions'\n        with open(self.dir + '/user_select_query_unpublished_articles.yaml') as c:\n            self.conf = yaml.safe_load(c)\n        curr_time = datetime.now()\n        exp_time = curr_time + timedelta(hours=1)\n        self.claims = {\n            'sub': '1234567890',\n            'name': 'John Doe',\n            'iat': math.floor(curr_time.timestamp()),\n            'exp': math.floor(exp_time.timestamp())\n        }\n\n    @pytest.fixture(scope='class')\n    def setup(self, request, hge_ctx):\n        self.dir = 'queries/graphql_query/permissions'\n        st_code, resp = hge_ctx.v1q_f(self.dir + '/setup.yaml')\n        assert st_code == 200, resp\n        yield\n        st_code, resp = hge_ctx.v1q_f(self.dir + '/teardown.yaml')\n        assert st_code == 200, resp\n\n@pytest.mark.parametrize('endpoint', ['/v1/graphql', '/v1alpha1/graphql'])\nclass TestJwtIssuerCheck():\n    def test_jwt_valid_issuer(self, hge_ctx, endpoint):\n        jwt_conf = json.loads(hge_ctx.hge_jwt_conf)\n        if 'issuer' not in jwt_conf:\n            pytest.skip('issuer not present in conf, skipping testing issuer')\n\n        issuer = jwt_conf['issuer']\n        self.claims['https://hasura.io/jwt/claims'] = mk_claims(hge_ctx.hge_jwt_conf, {\n            'x-hasura-user-id': '1',\n            'x-hasura-default-role': 'user',\n            'x-hasura-allowed-roles': ['user'],\n        })\n        self.claims['iss'] = issuer\n\n        token = jwt.encode(self.claims, hge_ctx.hge_jwt_key, algorithm='RS512').decode('utf-8')\n        self.conf['headers']['Authorization'] = 'Bearer ' + token\n        check_query(hge_ctx, self.conf, add_auth=False)\n\n    def test_jwt_invalid_issuer(self, hge_ctx, endpoint):\n        jwt_conf = json.loads(hge_ctx.hge_jwt_conf)\n        if 'issuer' not in jwt_conf:\n            pytest.skip('issuer not present in conf, skipping testing issuer')\n\n        self.claims['https://hasura.io/jwt/claims'] = mk_claims(hge_ctx.hge_jwt_conf, {\n            'x-hasura-user-id': '1',\n            'x-hasura-default-role': 'user',\n            'x-hasura-allowed-roles': ['user'],\n        })\n        self.claims['iss'] = 'rubbish_issuer'\n\n        token = jwt.encode(self.claims, hge_ctx.hge_jwt_key, algorithm='RS512').decode('utf-8')\n        self.conf['headers']['Authorization'] = 'Bearer ' + token\n        self.conf['response'] = {\n            'errors': [{\n                'extensions': {\n                    'code': 'invalid-jwt',\n                    'path': '$'\n                },\n                'message': 'Could not verify JWT: JWTNotInIssuer'\n            }]\n        }\n        self.conf['url'] = endpoint\n        if endpoint == '/v1/graphql':\n            self.conf['status'] = 200\n        if endpoint == '/v1alpha1/graphql':\n            self.conf['status'] = 400\n        check_query(hge_ctx, self.conf, add_auth=False)\n\n    @pytest.fixture(autouse=True)\n    def transact(self, setup):\n        self.dir = 'queries/graphql_query/permissions'\n        with open(self.dir + '/user_select_query_unpublished_articles.yaml') as c:\n            self.conf = yaml.safe_load(c)\n        curr_time = datetime.now()\n        exp_time = curr_time + timedelta(hours=1)\n        self.claims = {\n            'sub': '1234567890',\n            'name': 'John Doe',\n            'iat': math.floor(curr_time.timestamp()),\n            'exp': math.floor(exp_time.timestamp())\n        }\n\n    @pytest.fixture(scope='class')\n    def setup(self, request, hge_ctx):\n        self.dir = 'queries/graphql_query/permissions'\n        st_code, resp = hge_ctx.v1q_f(self.dir + '/setup.yaml')\n        assert st_code == 200, resp\n        yield\n        st_code, resp = hge_ctx.v1q_f(self.dir + '/teardown.yaml')\n        assert st_code == 200, resp\n"], "filenames": [".circleci/test-server.sh", "docs/graphql/manual/auth/authentication/jwt.rst", "server/src-lib/Hasura/Server/Auth.hs", "server/src-lib/Hasura/Server/Auth/JWT.hs", "server/tests-py/test_jwt.py"], "buggy_code_start_loc": [267, 233, 132, 6, 18], "buggy_code_end_loc": [267, 290, 133, 375, 263], "fixing_code_start_loc": [268, 232, 132, 6, 18], "fixing_code_end_loc": [312, 287, 133, 385, 436], "type": "NVD-CWE-noinfo", "message": "graphql-engine (aka Hasura GraphQL Engine) before 1.0.0-beta.3 mishandles the audience check while verifying JWT.", "other": {"cve": {"id": "CVE-2019-1020015", "sourceIdentifier": "josh@bress.net", "published": "2019-07-29T13:15:12.090", "lastModified": "2021-07-21T11:39:23.747", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "graphql-engine (aka Hasura GraphQL Engine) before 1.0.0-beta.3 mishandles the audience check while verifying JWT."}, {"lang": "es", "value": "graphql-engine (tambi\u00e9n se conoce como Hasura GraphQL Engine) anterior a versi\u00f3n 1.0.0-beta.3, maneja inapropiadamente la comprobaci\u00f3n de audiencia mientras se verifica JWT."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:hasura:graphql_engine:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.0", "matchCriteriaId": "6992CBD9-75D2-4C4B-9219-B61111016195"}, {"vulnerable": true, "criteria": "cpe:2.3:a:hasura:graphql_engine:1.0.0:-:*:*:*:*:*:*", "matchCriteriaId": "F476564A-C527-449E-A0EC-1D286D3C507B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:hasura:graphql_engine:1.0.0:beta.1:*:*:*:*:*:*", "matchCriteriaId": "711E4956-23AC-428A-9FBE-A07F774C9810"}, {"vulnerable": true, "criteria": "cpe:2.3:a:hasura:graphql_engine:1.0.0:beta.2:*:*:*:*:*:*", "matchCriteriaId": "2DD19C5C-B0AA-4C4D-8587-635CF0F2DC13"}]}]}], "references": [{"url": "https://github.com/hasura/graphql-engine/commit/f2f14e727b051e3003ba44b9b63eab8186b291ac", "source": "josh@bress.net", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/hasura/graphql-engine/commit/f2f14e727b051e3003ba44b9b63eab8186b291ac"}}