{"buggy_code": ["use std::sync::Arc;\n\nuse mio;\nuse mio::tcp::{TcpListener, TcpStream, Shutdown};\n\n#[macro_use]\nextern crate log;\n\nuse std::fs;\nuse std::io;\nuse std::net;\nuse std::io::{Write, Read, BufReader};\nuse std::collections::HashMap;\n\n#[macro_use]\nextern crate serde_derive;\n\nuse docopt::Docopt;\n\nuse env_logger;\n\nuse rustls;\n\nuse rustls::{RootCertStore, Session, NoClientAuth, AllowAnyAuthenticatedClient,\n             AllowAnyAnonymousOrAuthenticatedClient};\n\nmod util;\n\n// Token for our listening socket.\nconst LISTENER: mio::Token = mio::Token(0);\n\n// Which mode the server operates in.\n#[derive(Clone)]\nenum ServerMode {\n    /// Write back received bytes\n    Echo,\n\n    /// Do one read, then write a bodged HTTP response and\n    /// cleanly close the connection.\n    Http,\n\n    /// Forward traffic to/from given port on localhost.\n    Forward(u16),\n}\n\n/// This binds together a TCP listening socket, some outstanding\n/// connections, and a TLS server configuration.\nstruct TlsServer {\n    server: TcpListener,\n    connections: HashMap<mio::Token, Connection>,\n    next_id: usize,\n    tls_config: Arc<rustls::ServerConfig>,\n    mode: ServerMode,\n}\n\nimpl TlsServer {\n    fn new(server: TcpListener, mode: ServerMode, cfg: Arc<rustls::ServerConfig>) -> TlsServer {\n        TlsServer {\n            server,\n            connections: HashMap::new(),\n            next_id: 2,\n            tls_config: cfg,\n            mode,\n        }\n    }\n\n    fn accept(&mut self, poll: &mut mio::Poll) -> bool {\n        match self.server.accept() {\n            Ok((socket, addr)) => {\n                debug!(\"Accepting new connection from {:?}\", addr);\n\n                let tls_session = rustls::ServerSession::new(&self.tls_config);\n                let mode = self.mode.clone();\n\n                let token = mio::Token(self.next_id);\n                self.next_id += 1;\n\n                self.connections.insert(token, Connection::new(socket, token, mode, tls_session));\n                self.connections[&token].register(poll);\n                true\n            }\n            Err(e) => {\n                println!(\"encountered error while accepting connection; err={:?}\", e);\n                false\n            }\n        }\n    }\n\n    fn conn_event(&mut self, poll: &mut mio::Poll, event: &mio::Event) {\n        let token = event.token();\n\n        if self.connections.contains_key(&token) {\n            self.connections\n                .get_mut(&token)\n                .unwrap()\n                .ready(poll, event);\n\n            if self.connections[&token].is_closed() {\n                self.connections.remove(&token);\n            }\n        }\n    }\n}\n\n/// This is a connection which has been accepted by the server,\n/// and is currently being served.\n///\n/// It has a TCP-level stream, a TLS-level session, and some\n/// other state/metadata.\nstruct Connection {\n    socket: TcpStream,\n    token: mio::Token,\n    closing: bool,\n    closed: bool,\n    mode: ServerMode,\n    tls_session: rustls::ServerSession,\n    back: Option<TcpStream>,\n    sent_http_response: bool,\n}\n\n/// Open a plaintext TCP-level connection for forwarded connections.\nfn open_back(mode: &ServerMode) -> Option<TcpStream> {\n    match *mode {\n        ServerMode::Forward(ref port) => {\n            let addr = net::SocketAddrV4::new(net::Ipv4Addr::new(127, 0, 0, 1), *port);\n            let conn = TcpStream::connect(&net::SocketAddr::V4(addr)).unwrap();\n            Some(conn)\n        }\n        _ => None,\n    }\n}\n\n/// This used to be conveniently exposed by mio: map EWOULDBLOCK\n/// errors to something less-errory.\nfn try_read(r: io::Result<usize>) -> io::Result<Option<usize>> {\n    match r {\n        Ok(len) => Ok(Some(len)),\n        Err(e) => {\n            if e.kind() == io::ErrorKind::WouldBlock {\n                Ok(None)\n            } else {\n                Err(e)\n            }\n        }\n    }\n}\n\nimpl Connection {\n    fn new(socket: TcpStream,\n           token: mio::Token,\n           mode: ServerMode,\n           tls_session: rustls::ServerSession)\n           -> Connection {\n        let back = open_back(&mode);\n        Connection {\n            socket,\n            token,\n            closing: false,\n            closed: false,\n            mode,\n            tls_session,\n            back,\n            sent_http_response: false,\n        }\n    }\n\n    /// We're a connection, and we have something to do.\n    fn ready(&mut self, poll: &mut mio::Poll, ev: &mio::Event) {\n        // If we're readable: read some TLS.  Then\n        // see if that yielded new plaintext.  Then\n        // see if the backend is readable too.\n        if ev.readiness().is_readable() {\n            self.do_tls_read();\n            self.try_plain_read();\n            self.try_back_read();\n        }\n\n        if ev.readiness().is_writable() {\n            self.do_tls_write_and_handle_error();\n        }\n\n        if self.closing && !self.tls_session.wants_write() {\n            let _ = self.socket.shutdown(Shutdown::Both);\n            self.close_back();\n            self.closed = true;\n        } else {\n            self.reregister(poll);\n        }\n    }\n\n    /// Close the backend connection for forwarded sessions.\n    fn close_back(&mut self) {\n        if self.back.is_some() {\n            let back = self.back.as_mut().unwrap();\n            back.shutdown(Shutdown::Both).unwrap();\n        }\n        self.back = None;\n    }\n\n    fn do_tls_read(&mut self) {\n        // Read some TLS data.\n        let rc = self.tls_session.read_tls(&mut self.socket);\n        if rc.is_err() {\n            let err = rc.unwrap_err();\n\n            if let io::ErrorKind::WouldBlock = err.kind() {\n                return;\n            }\n\n            error!(\"read error {:?}\", err);\n            self.closing = true;\n            return;\n        }\n\n        if rc.unwrap() == 0 {\n            debug!(\"eof\");\n            self.closing = true;\n            return;\n        }\n\n        // Process newly-received TLS messages.\n        let processed = self.tls_session.process_new_packets();\n        if processed.is_err() {\n            error!(\"cannot process packet: {:?}\", processed);\n\n            // last gasp write to send any alerts\n            self.do_tls_write_and_handle_error();\n\n            self.closing = true;\n            return;\n        }\n    }\n\n    fn try_plain_read(&mut self) {\n        // Read and process all available plaintext.\n        let mut buf = Vec::new();\n\n        let rc = self.tls_session.read_to_end(&mut buf);\n        if rc.is_err() {\n            error!(\"plaintext read failed: {:?}\", rc);\n            self.closing = true;\n            return;\n        }\n\n        if !buf.is_empty() {\n            debug!(\"plaintext read {:?}\", buf.len());\n            self.incoming_plaintext(&buf);\n        }\n    }\n\n    fn try_back_read(&mut self) {\n        if self.back.is_none() {\n            return;\n        }\n\n        // Try a non-blocking read.\n        let mut buf = [0u8; 1024];\n        let back = self.back.as_mut().unwrap();\n        let rc = try_read(back.read(&mut buf));\n\n        if rc.is_err() {\n            error!(\"backend read failed: {:?}\", rc);\n            self.closing = true;\n            return;\n        }\n\n        let maybe_len = rc.unwrap();\n\n        // If we have a successful but empty read, that's an EOF.\n        // Otherwise, we shove the data into the TLS session.\n        match maybe_len {\n            Some(len) if len == 0 => {\n                debug!(\"back eof\");\n                self.closing = true;\n            }\n            Some(len) => {\n                self.tls_session.write_all(&buf[..len]).unwrap();\n            }\n            None => {}\n        };\n    }\n\n    /// Process some amount of received plaintext.\n    fn incoming_plaintext(&mut self, buf: &[u8]) {\n        match self.mode {\n            ServerMode::Echo => {\n                self.tls_session.write_all(buf).unwrap();\n            }\n            ServerMode::Http => {\n                self.send_http_response_once();\n            }\n            ServerMode::Forward(_) => {\n                self.back.as_mut().unwrap().write_all(buf).unwrap();\n            }\n        }\n    }\n\n    fn send_http_response_once(&mut self) {\n        let response = b\"HTTP/1.0 200 OK\\r\\nConnection: close\\r\\n\\r\\nHello world from rustls tlsserver\\r\\n\";\n        if !self.sent_http_response {\n            self.tls_session\n                .write_all(response)\n                .unwrap();\n            self.sent_http_response = true;\n            self.tls_session.send_close_notify();\n        }\n    }\n\n    #[cfg(target_os = \"windows\")]\n    fn tls_write(&mut self) -> io::Result<usize> {\n        self.tls_session.write_tls(&mut self.socket)\n    }\n\n    #[cfg(not(target_os = \"windows\"))]\n    fn tls_write(&mut self) -> io::Result<usize> {\n        use crate::util::WriteVAdapter;\n        self.tls_session.writev_tls(&mut WriteVAdapter::new(&mut self.socket))\n    }\n\n    fn do_tls_write_and_handle_error(&mut self) {\n        let rc = self.tls_write();\n        if rc.is_err() {\n            error!(\"write failed {:?}\", rc);\n            self.closing = true;\n            return;\n        }\n    }\n\n    fn register(&self, poll: &mut mio::Poll) {\n        poll.register(&self.socket,\n                      self.token,\n                      self.event_set(),\n                      mio::PollOpt::level() | mio::PollOpt::oneshot())\n            .unwrap();\n\n        if self.back.is_some() {\n            poll.register(self.back.as_ref().unwrap(),\n                          self.token,\n                          mio::Ready::readable(),\n                          mio::PollOpt::level() | mio::PollOpt::oneshot())\n                .unwrap();\n        }\n    }\n\n    fn reregister(&self, poll: &mut mio::Poll) {\n        poll.reregister(&self.socket,\n                        self.token,\n                        self.event_set(),\n                        mio::PollOpt::level() | mio::PollOpt::oneshot())\n            .unwrap();\n\n        if self.back.is_some() {\n            poll.reregister(self.back.as_ref().unwrap(),\n                            self.token,\n                            mio::Ready::readable(),\n                            mio::PollOpt::level() | mio::PollOpt::oneshot())\n                .unwrap();\n        }\n    }\n\n    /// What IO events we're currently waiting for,\n    /// based on wants_read/wants_write.\n    fn event_set(&self) -> mio::Ready {\n        let rd = self.tls_session.wants_read();\n        let wr = self.tls_session.wants_write();\n\n        if rd && wr {\n            mio::Ready::readable() | mio::Ready::writable()\n        } else if wr {\n            mio::Ready::writable()\n        } else {\n            mio::Ready::readable()\n        }\n    }\n\n    fn is_closed(&self) -> bool {\n        self.closed\n    }\n}\n\nconst USAGE: &'static str =\n    \"\nRuns a TLS server on :PORT.  The default PORT is 443.\n\n`echo' mode means the server echoes received data on each connection.\n\n`http' mode means the server blindly sends a HTTP response on each\nconnection.\n\n`forward' means the server forwards plaintext to a connection made to\nlocalhost:fport.\n\n`--certs' names the full certificate chain, `--key' provides the\nRSA private key.\n\nUsage:\n  tlsserver --certs CERTFILE --key KEYFILE [--suite SUITE ...] \\\n     [--proto PROTO ...] [options] echo\n  tlsserver --certs CERTFILE --key KEYFILE [--suite SUITE ...] \\\n     [--proto PROTO ...] [options] http\n  tlsserver --certs CERTFILE --key KEYFILE [--suite SUITE ...] \\\n     [--proto PROTO ...] [options] forward <fport>\n  tlsserver (--version | -v)\n  tlsserver (--help | -h)\n\nOptions:\n    -p, --port PORT     Listen on PORT [default: 443].\n    --certs CERTFILE    Read server certificates from CERTFILE.\n                        This should contain PEM-format certificates\n                        in the right order (the first certificate should\n                        certify KEYFILE, the last should be a root CA).\n    --key KEYFILE       Read private key from KEYFILE.  This should be a RSA\n                        private key or PKCS8-encoded private key, in PEM format.\n    --ocsp OCSPFILE     Read DER-encoded OCSP response from OCSPFILE and staple\n                        to certificate.  Optional.\n    --auth CERTFILE     Enable client authentication, and accept certificates\n                        signed by those roots provided in CERTFILE.\n    --require-auth      Send a fatal alert if the client does not complete client\n                        authentication.\n    --resumption        Support session resumption.\n    --tickets           Support tickets.\n    --protover VERSION  Disable default TLS version list, and use\n                        VERSION instead.  May be used multiple times.\n    --suite SUITE       Disable default cipher suite list, and use\n                        SUITE instead.  May be used multiple times.\n    --proto PROTOCOL    Negotiate PROTOCOL using ALPN.\n                        May be used multiple times.\n    --verbose           Emit log output.\n    --version, -v       Show tool version.\n    --help, -h          Show this screen.\n\";\n\n#[derive(Debug, Deserialize)]\nstruct Args {\n    cmd_echo: bool,\n    cmd_http: bool,\n    cmd_forward: bool,\n    flag_port: Option<u16>,\n    flag_verbose: bool,\n    flag_protover: Vec<String>,\n    flag_suite: Vec<String>,\n    flag_proto: Vec<String>,\n    flag_certs: Option<String>,\n    flag_key: Option<String>,\n    flag_ocsp: Option<String>,\n    flag_auth: Option<String>,\n    flag_require_auth: bool,\n    flag_resumption: bool,\n    flag_tickets: bool,\n    arg_fport: Option<u16>,\n}\n\nfn find_suite(name: &str) -> Option<&'static rustls::SupportedCipherSuite> {\n    for suite in &rustls::ALL_CIPHERSUITES {\n        let sname = format!(\"{:?}\", suite.suite).to_lowercase();\n\n        if sname == name.to_string().to_lowercase() {\n            return Some(suite);\n        }\n    }\n\n    None\n}\n\nfn lookup_suites(suites: &[String]) -> Vec<&'static rustls::SupportedCipherSuite> {\n    let mut out = Vec::new();\n\n    for csname in suites {\n        let scs = find_suite(csname);\n        match scs {\n            Some(s) => out.push(s),\n            None => panic!(\"cannot look up ciphersuite '{}'\", csname),\n        }\n    }\n\n    out\n}\n\n/// Make a vector of protocol versions named in `versions`\nfn lookup_versions(versions: &[String]) -> Vec<rustls::ProtocolVersion> {\n    let mut out = Vec::new();\n\n    for vname in versions {\n        let version = match vname.as_ref() {\n            \"1.2\" => rustls::ProtocolVersion::TLSv1_2,\n            \"1.3\" => rustls::ProtocolVersion::TLSv1_3,\n            _ => panic!(\"cannot look up version '{}', valid are '1.2' and '1.3'\", vname),\n        };\n        out.push(version);\n    }\n\n    out\n}\n\nfn load_certs(filename: &str) -> Vec<rustls::Certificate> {\n    let certfile = fs::File::open(filename).expect(\"cannot open certificate file\");\n    let mut reader = BufReader::new(certfile);\n    rustls::internal::pemfile::certs(&mut reader).unwrap()\n}\n\nfn load_private_key(filename: &str) -> rustls::PrivateKey {\n    let rsa_keys = {\n        let keyfile = fs::File::open(filename)\n            .expect(\"cannot open private key file\");\n        let mut reader = BufReader::new(keyfile);\n        rustls::internal::pemfile::rsa_private_keys(&mut reader)\n            .expect(\"file contains invalid rsa private key\")\n    };\n\n    let pkcs8_keys = {\n        let keyfile = fs::File::open(filename)\n            .expect(\"cannot open private key file\");\n        let mut reader = BufReader::new(keyfile);\n        rustls::internal::pemfile::pkcs8_private_keys(&mut reader)\n            .expect(\"file contains invalid pkcs8 private key (encrypted keys not supported)\")\n    };\n\n    // prefer to load pkcs8 keys\n    if !pkcs8_keys.is_empty() {\n        pkcs8_keys[0].clone()\n    } else {\n        assert!(!rsa_keys.is_empty());\n        rsa_keys[0].clone()\n    }\n}\n\nfn load_ocsp(filename: &Option<String>) -> Vec<u8> {\n    let mut ret = Vec::new();\n\n    if let &Some(ref name) = filename {\n        fs::File::open(name)\n            .expect(\"cannot open ocsp file\")\n            .read_to_end(&mut ret)\n            .unwrap();\n    }\n\n    ret\n}\n\nfn make_config(args: &Args) -> Arc<rustls::ServerConfig> {\n    let client_auth = if args.flag_auth.is_some() {\n        let roots = load_certs(args.flag_auth.as_ref().unwrap());\n        let mut client_auth_roots = RootCertStore::empty();\n        for root in roots {\n            client_auth_roots.add(&root).unwrap();\n        }\n        if args.flag_require_auth {\n            AllowAnyAuthenticatedClient::new(client_auth_roots)\n        } else {\n            AllowAnyAnonymousOrAuthenticatedClient::new(client_auth_roots)\n        }\n    } else {\n        NoClientAuth::new()\n    };\n\n    let mut config = rustls::ServerConfig::new(client_auth);\n    config.key_log = Arc::new(rustls::KeyLogFile::new());\n\n    let certs = load_certs(args.flag_certs.as_ref().expect(\"--certs option missing\"));\n    let privkey = load_private_key(args.flag_key.as_ref().expect(\"--key option missing\"));\n    let ocsp = load_ocsp(&args.flag_ocsp);\n    config.set_single_cert_with_ocsp_and_sct(certs, privkey, ocsp, vec![])\n        .expect(\"bad certificates/private key\");\n\n    if !args.flag_suite.is_empty() {\n        config.ciphersuites = lookup_suites(&args.flag_suite);\n    }\n\n    if !args.flag_protover.is_empty() {\n        config.versions = lookup_versions(&args.flag_protover);\n    }\n\n    if args.flag_resumption {\n        config.set_persistence(rustls::ServerSessionMemoryCache::new(256));\n    }\n\n    if args.flag_tickets {\n        config.ticketer = rustls::Ticketer::new();\n    }\n\n    config.set_protocols(&args.flag_proto\n        .iter()\n        .map(|proto| proto.as_bytes().to_vec())\n        .collect::<Vec<_>>()[..]);\n\n    Arc::new(config)\n}\n\nfn main() {\n    let version = env!(\"CARGO_PKG_NAME\").to_string() + \", version: \" + env!(\"CARGO_PKG_VERSION\");\n\n    let args: Args = Docopt::new(USAGE)\n        .and_then(|d| Ok(d.help(true)))\n        .and_then(|d| Ok(d.version(Some(version))))\n        .and_then(|d| d.deserialize())\n        .unwrap_or_else(|e| e.exit());\n\n    if args.flag_verbose {\n        env_logger::Builder::new()\n            .parse_filters(\"trace\")\n            .init();\n    }\n\n    let mut addr: net::SocketAddr = \"0.0.0.0:443\".parse().unwrap();\n    addr.set_port(args.flag_port.unwrap_or(443));\n\n    let config = make_config(&args);\n\n    let listener = TcpListener::bind(&addr).expect(\"cannot listen on port\");\n    let mut poll = mio::Poll::new()\n        .unwrap();\n    poll.register(&listener,\n                  LISTENER,\n                  mio::Ready::readable(),\n                  mio::PollOpt::level())\n        .unwrap();\n\n    let mode = if args.cmd_echo {\n        ServerMode::Echo\n    } else if args.cmd_http {\n        ServerMode::Http\n    } else {\n        ServerMode::Forward(args.arg_fport.expect(\"fport required\"))\n    };\n\n    let mut tlsserv = TlsServer::new(listener, mode, config);\n\n    let mut events = mio::Events::with_capacity(256);\n    loop {\n        poll.poll(&mut events, None)\n            .unwrap();\n\n        for event in events.iter() {\n            match event.token() {\n                LISTENER => {\n                    if !tlsserv.accept(&mut poll) {\n                        break;\n                    }\n                }\n                _ => tlsserv.conn_event(&mut poll, &event)\n            }\n        }\n    }\n}\n"], "fixing_code": ["use std::sync::Arc;\n\nuse mio;\nuse mio::tcp::{TcpListener, TcpStream, Shutdown};\n\n#[macro_use]\nextern crate log;\n\nuse std::fs;\nuse std::io;\nuse std::net;\nuse std::io::{Write, Read, BufReader};\nuse std::collections::HashMap;\n\n#[macro_use]\nextern crate serde_derive;\n\nuse docopt::Docopt;\n\nuse env_logger;\n\nuse rustls;\n\nuse rustls::{RootCertStore, Session, NoClientAuth, AllowAnyAuthenticatedClient,\n             AllowAnyAnonymousOrAuthenticatedClient};\n\nmod util;\n\n// Token for our listening socket.\nconst LISTENER: mio::Token = mio::Token(0);\n\n// Which mode the server operates in.\n#[derive(Clone)]\nenum ServerMode {\n    /// Write back received bytes\n    Echo,\n\n    /// Do one read, then write a bodged HTTP response and\n    /// cleanly close the connection.\n    Http,\n\n    /// Forward traffic to/from given port on localhost.\n    Forward(u16),\n}\n\n/// This binds together a TCP listening socket, some outstanding\n/// connections, and a TLS server configuration.\nstruct TlsServer {\n    server: TcpListener,\n    connections: HashMap<mio::Token, Connection>,\n    next_id: usize,\n    tls_config: Arc<rustls::ServerConfig>,\n    mode: ServerMode,\n}\n\nimpl TlsServer {\n    fn new(server: TcpListener, mode: ServerMode, cfg: Arc<rustls::ServerConfig>) -> TlsServer {\n        TlsServer {\n            server,\n            connections: HashMap::new(),\n            next_id: 2,\n            tls_config: cfg,\n            mode,\n        }\n    }\n\n    fn accept(&mut self, poll: &mut mio::Poll) -> bool {\n        match self.server.accept() {\n            Ok((socket, addr)) => {\n                debug!(\"Accepting new connection from {:?}\", addr);\n\n                let tls_session = rustls::ServerSession::new(&self.tls_config);\n                let mode = self.mode.clone();\n\n                let token = mio::Token(self.next_id);\n                self.next_id += 1;\n\n                self.connections.insert(token, Connection::new(socket, token, mode, tls_session));\n                self.connections[&token].register(poll);\n                true\n            }\n            Err(e) => {\n                println!(\"encountered error while accepting connection; err={:?}\", e);\n                false\n            }\n        }\n    }\n\n    fn conn_event(&mut self, poll: &mut mio::Poll, event: &mio::Event) {\n        let token = event.token();\n\n        if self.connections.contains_key(&token) {\n            self.connections\n                .get_mut(&token)\n                .unwrap()\n                .ready(poll, event);\n\n            if self.connections[&token].is_closed() {\n                self.connections.remove(&token);\n            }\n        }\n    }\n}\n\n/// This is a connection which has been accepted by the server,\n/// and is currently being served.\n///\n/// It has a TCP-level stream, a TLS-level session, and some\n/// other state/metadata.\nstruct Connection {\n    socket: TcpStream,\n    token: mio::Token,\n    closing: bool,\n    closed: bool,\n    mode: ServerMode,\n    tls_session: rustls::ServerSession,\n    back: Option<TcpStream>,\n    sent_http_response: bool,\n}\n\n/// Open a plaintext TCP-level connection for forwarded connections.\nfn open_back(mode: &ServerMode) -> Option<TcpStream> {\n    match *mode {\n        ServerMode::Forward(ref port) => {\n            let addr = net::SocketAddrV4::new(net::Ipv4Addr::new(127, 0, 0, 1), *port);\n            let conn = TcpStream::connect(&net::SocketAddr::V4(addr)).unwrap();\n            Some(conn)\n        }\n        _ => None,\n    }\n}\n\n/// This used to be conveniently exposed by mio: map EWOULDBLOCK\n/// errors to something less-errory.\nfn try_read(r: io::Result<usize>) -> io::Result<Option<usize>> {\n    match r {\n        Ok(len) => Ok(Some(len)),\n        Err(e) => {\n            if e.kind() == io::ErrorKind::WouldBlock {\n                Ok(None)\n            } else {\n                Err(e)\n            }\n        }\n    }\n}\n\nimpl Connection {\n    fn new(socket: TcpStream,\n           token: mio::Token,\n           mode: ServerMode,\n           tls_session: rustls::ServerSession)\n           -> Connection {\n        let back = open_back(&mode);\n        Connection {\n            socket,\n            token,\n            closing: false,\n            closed: false,\n            mode,\n            tls_session,\n            back,\n            sent_http_response: false,\n        }\n    }\n\n    /// We're a connection, and we have something to do.\n    fn ready(&mut self, poll: &mut mio::Poll, ev: &mio::Event) {\n        // If we're readable: read some TLS.  Then\n        // see if that yielded new plaintext.  Then\n        // see if the backend is readable too.\n        if ev.readiness().is_readable() {\n            self.do_tls_read();\n            self.try_plain_read();\n            self.try_back_read();\n        }\n\n        if ev.readiness().is_writable() {\n            self.do_tls_write_and_handle_error();\n        }\n\n        if self.closing {\n            let _ = self.socket.shutdown(Shutdown::Both);\n            self.close_back();\n            self.closed = true;\n        } else {\n            self.reregister(poll);\n        }\n    }\n\n    /// Close the backend connection for forwarded sessions.\n    fn close_back(&mut self) {\n        if self.back.is_some() {\n            let back = self.back.as_mut().unwrap();\n            back.shutdown(Shutdown::Both).unwrap();\n        }\n        self.back = None;\n    }\n\n    fn do_tls_read(&mut self) {\n        // Read some TLS data.\n        let rc = self.tls_session.read_tls(&mut self.socket);\n        if rc.is_err() {\n            let err = rc.unwrap_err();\n\n            if let io::ErrorKind::WouldBlock = err.kind() {\n                return;\n            }\n\n            error!(\"read error {:?}\", err);\n            self.closing = true;\n            return;\n        }\n\n        if rc.unwrap() == 0 {\n            debug!(\"eof\");\n            self.closing = true;\n            return;\n        }\n\n        // Process newly-received TLS messages.\n        let processed = self.tls_session.process_new_packets();\n        if processed.is_err() {\n            error!(\"cannot process packet: {:?}\", processed);\n\n            // last gasp write to send any alerts\n            self.do_tls_write_and_handle_error();\n\n            self.closing = true;\n            return;\n        }\n    }\n\n    fn try_plain_read(&mut self) {\n        // Read and process all available plaintext.\n        let mut buf = Vec::new();\n\n        let rc = self.tls_session.read_to_end(&mut buf);\n        if rc.is_err() {\n            error!(\"plaintext read failed: {:?}\", rc);\n            self.closing = true;\n            return;\n        }\n\n        if !buf.is_empty() {\n            debug!(\"plaintext read {:?}\", buf.len());\n            self.incoming_plaintext(&buf);\n        }\n    }\n\n    fn try_back_read(&mut self) {\n        if self.back.is_none() {\n            return;\n        }\n\n        // Try a non-blocking read.\n        let mut buf = [0u8; 1024];\n        let back = self.back.as_mut().unwrap();\n        let rc = try_read(back.read(&mut buf));\n\n        if rc.is_err() {\n            error!(\"backend read failed: {:?}\", rc);\n            self.closing = true;\n            return;\n        }\n\n        let maybe_len = rc.unwrap();\n\n        // If we have a successful but empty read, that's an EOF.\n        // Otherwise, we shove the data into the TLS session.\n        match maybe_len {\n            Some(len) if len == 0 => {\n                debug!(\"back eof\");\n                self.closing = true;\n            }\n            Some(len) => {\n                self.tls_session.write_all(&buf[..len]).unwrap();\n            }\n            None => {}\n        };\n    }\n\n    /// Process some amount of received plaintext.\n    fn incoming_plaintext(&mut self, buf: &[u8]) {\n        match self.mode {\n            ServerMode::Echo => {\n                self.tls_session.write_all(buf).unwrap();\n            }\n            ServerMode::Http => {\n                self.send_http_response_once();\n            }\n            ServerMode::Forward(_) => {\n                self.back.as_mut().unwrap().write_all(buf).unwrap();\n            }\n        }\n    }\n\n    fn send_http_response_once(&mut self) {\n        let response = b\"HTTP/1.0 200 OK\\r\\nConnection: close\\r\\n\\r\\nHello world from rustls tlsserver\\r\\n\";\n        if !self.sent_http_response {\n            self.tls_session\n                .write_all(response)\n                .unwrap();\n            self.sent_http_response = true;\n            self.tls_session.send_close_notify();\n        }\n    }\n\n    #[cfg(target_os = \"windows\")]\n    fn tls_write(&mut self) -> io::Result<usize> {\n        self.tls_session.write_tls(&mut self.socket)\n    }\n\n    #[cfg(not(target_os = \"windows\"))]\n    fn tls_write(&mut self) -> io::Result<usize> {\n        use crate::util::WriteVAdapter;\n        self.tls_session.writev_tls(&mut WriteVAdapter::new(&mut self.socket))\n    }\n\n    fn do_tls_write_and_handle_error(&mut self) {\n        let rc = self.tls_write();\n        if rc.is_err() {\n            error!(\"write failed {:?}\", rc);\n            self.closing = true;\n            return;\n        }\n    }\n\n    fn register(&self, poll: &mut mio::Poll) {\n        poll.register(&self.socket,\n                      self.token,\n                      self.event_set(),\n                      mio::PollOpt::level() | mio::PollOpt::oneshot())\n            .unwrap();\n\n        if self.back.is_some() {\n            poll.register(self.back.as_ref().unwrap(),\n                          self.token,\n                          mio::Ready::readable(),\n                          mio::PollOpt::level() | mio::PollOpt::oneshot())\n                .unwrap();\n        }\n    }\n\n    fn reregister(&self, poll: &mut mio::Poll) {\n        poll.reregister(&self.socket,\n                        self.token,\n                        self.event_set(),\n                        mio::PollOpt::level() | mio::PollOpt::oneshot())\n            .unwrap();\n\n        if self.back.is_some() {\n            poll.reregister(self.back.as_ref().unwrap(),\n                            self.token,\n                            mio::Ready::readable(),\n                            mio::PollOpt::level() | mio::PollOpt::oneshot())\n                .unwrap();\n        }\n    }\n\n    /// What IO events we're currently waiting for,\n    /// based on wants_read/wants_write.\n    fn event_set(&self) -> mio::Ready {\n        let rd = self.tls_session.wants_read();\n        let wr = self.tls_session.wants_write();\n\n        if rd && wr {\n            mio::Ready::readable() | mio::Ready::writable()\n        } else if wr {\n            mio::Ready::writable()\n        } else {\n            mio::Ready::readable()\n        }\n    }\n\n    fn is_closed(&self) -> bool {\n        self.closed\n    }\n}\n\nconst USAGE: &'static str =\n    \"\nRuns a TLS server on :PORT.  The default PORT is 443.\n\n`echo' mode means the server echoes received data on each connection.\n\n`http' mode means the server blindly sends a HTTP response on each\nconnection.\n\n`forward' means the server forwards plaintext to a connection made to\nlocalhost:fport.\n\n`--certs' names the full certificate chain, `--key' provides the\nRSA private key.\n\nUsage:\n  tlsserver --certs CERTFILE --key KEYFILE [--suite SUITE ...] \\\n     [--proto PROTO ...] [options] echo\n  tlsserver --certs CERTFILE --key KEYFILE [--suite SUITE ...] \\\n     [--proto PROTO ...] [options] http\n  tlsserver --certs CERTFILE --key KEYFILE [--suite SUITE ...] \\\n     [--proto PROTO ...] [options] forward <fport>\n  tlsserver (--version | -v)\n  tlsserver (--help | -h)\n\nOptions:\n    -p, --port PORT     Listen on PORT [default: 443].\n    --certs CERTFILE    Read server certificates from CERTFILE.\n                        This should contain PEM-format certificates\n                        in the right order (the first certificate should\n                        certify KEYFILE, the last should be a root CA).\n    --key KEYFILE       Read private key from KEYFILE.  This should be a RSA\n                        private key or PKCS8-encoded private key, in PEM format.\n    --ocsp OCSPFILE     Read DER-encoded OCSP response from OCSPFILE and staple\n                        to certificate.  Optional.\n    --auth CERTFILE     Enable client authentication, and accept certificates\n                        signed by those roots provided in CERTFILE.\n    --require-auth      Send a fatal alert if the client does not complete client\n                        authentication.\n    --resumption        Support session resumption.\n    --tickets           Support tickets.\n    --protover VERSION  Disable default TLS version list, and use\n                        VERSION instead.  May be used multiple times.\n    --suite SUITE       Disable default cipher suite list, and use\n                        SUITE instead.  May be used multiple times.\n    --proto PROTOCOL    Negotiate PROTOCOL using ALPN.\n                        May be used multiple times.\n    --verbose           Emit log output.\n    --version, -v       Show tool version.\n    --help, -h          Show this screen.\n\";\n\n#[derive(Debug, Deserialize)]\nstruct Args {\n    cmd_echo: bool,\n    cmd_http: bool,\n    cmd_forward: bool,\n    flag_port: Option<u16>,\n    flag_verbose: bool,\n    flag_protover: Vec<String>,\n    flag_suite: Vec<String>,\n    flag_proto: Vec<String>,\n    flag_certs: Option<String>,\n    flag_key: Option<String>,\n    flag_ocsp: Option<String>,\n    flag_auth: Option<String>,\n    flag_require_auth: bool,\n    flag_resumption: bool,\n    flag_tickets: bool,\n    arg_fport: Option<u16>,\n}\n\nfn find_suite(name: &str) -> Option<&'static rustls::SupportedCipherSuite> {\n    for suite in &rustls::ALL_CIPHERSUITES {\n        let sname = format!(\"{:?}\", suite.suite).to_lowercase();\n\n        if sname == name.to_string().to_lowercase() {\n            return Some(suite);\n        }\n    }\n\n    None\n}\n\nfn lookup_suites(suites: &[String]) -> Vec<&'static rustls::SupportedCipherSuite> {\n    let mut out = Vec::new();\n\n    for csname in suites {\n        let scs = find_suite(csname);\n        match scs {\n            Some(s) => out.push(s),\n            None => panic!(\"cannot look up ciphersuite '{}'\", csname),\n        }\n    }\n\n    out\n}\n\n/// Make a vector of protocol versions named in `versions`\nfn lookup_versions(versions: &[String]) -> Vec<rustls::ProtocolVersion> {\n    let mut out = Vec::new();\n\n    for vname in versions {\n        let version = match vname.as_ref() {\n            \"1.2\" => rustls::ProtocolVersion::TLSv1_2,\n            \"1.3\" => rustls::ProtocolVersion::TLSv1_3,\n            _ => panic!(\"cannot look up version '{}', valid are '1.2' and '1.3'\", vname),\n        };\n        out.push(version);\n    }\n\n    out\n}\n\nfn load_certs(filename: &str) -> Vec<rustls::Certificate> {\n    let certfile = fs::File::open(filename).expect(\"cannot open certificate file\");\n    let mut reader = BufReader::new(certfile);\n    rustls::internal::pemfile::certs(&mut reader).unwrap()\n}\n\nfn load_private_key(filename: &str) -> rustls::PrivateKey {\n    let rsa_keys = {\n        let keyfile = fs::File::open(filename)\n            .expect(\"cannot open private key file\");\n        let mut reader = BufReader::new(keyfile);\n        rustls::internal::pemfile::rsa_private_keys(&mut reader)\n            .expect(\"file contains invalid rsa private key\")\n    };\n\n    let pkcs8_keys = {\n        let keyfile = fs::File::open(filename)\n            .expect(\"cannot open private key file\");\n        let mut reader = BufReader::new(keyfile);\n        rustls::internal::pemfile::pkcs8_private_keys(&mut reader)\n            .expect(\"file contains invalid pkcs8 private key (encrypted keys not supported)\")\n    };\n\n    // prefer to load pkcs8 keys\n    if !pkcs8_keys.is_empty() {\n        pkcs8_keys[0].clone()\n    } else {\n        assert!(!rsa_keys.is_empty());\n        rsa_keys[0].clone()\n    }\n}\n\nfn load_ocsp(filename: &Option<String>) -> Vec<u8> {\n    let mut ret = Vec::new();\n\n    if let &Some(ref name) = filename {\n        fs::File::open(name)\n            .expect(\"cannot open ocsp file\")\n            .read_to_end(&mut ret)\n            .unwrap();\n    }\n\n    ret\n}\n\nfn make_config(args: &Args) -> Arc<rustls::ServerConfig> {\n    let client_auth = if args.flag_auth.is_some() {\n        let roots = load_certs(args.flag_auth.as_ref().unwrap());\n        let mut client_auth_roots = RootCertStore::empty();\n        for root in roots {\n            client_auth_roots.add(&root).unwrap();\n        }\n        if args.flag_require_auth {\n            AllowAnyAuthenticatedClient::new(client_auth_roots)\n        } else {\n            AllowAnyAnonymousOrAuthenticatedClient::new(client_auth_roots)\n        }\n    } else {\n        NoClientAuth::new()\n    };\n\n    let mut config = rustls::ServerConfig::new(client_auth);\n    config.key_log = Arc::new(rustls::KeyLogFile::new());\n\n    let certs = load_certs(args.flag_certs.as_ref().expect(\"--certs option missing\"));\n    let privkey = load_private_key(args.flag_key.as_ref().expect(\"--key option missing\"));\n    let ocsp = load_ocsp(&args.flag_ocsp);\n    config.set_single_cert_with_ocsp_and_sct(certs, privkey, ocsp, vec![])\n        .expect(\"bad certificates/private key\");\n\n    if !args.flag_suite.is_empty() {\n        config.ciphersuites = lookup_suites(&args.flag_suite);\n    }\n\n    if !args.flag_protover.is_empty() {\n        config.versions = lookup_versions(&args.flag_protover);\n    }\n\n    if args.flag_resumption {\n        config.set_persistence(rustls::ServerSessionMemoryCache::new(256));\n    }\n\n    if args.flag_tickets {\n        config.ticketer = rustls::Ticketer::new();\n    }\n\n    config.set_protocols(&args.flag_proto\n        .iter()\n        .map(|proto| proto.as_bytes().to_vec())\n        .collect::<Vec<_>>()[..]);\n\n    Arc::new(config)\n}\n\nfn main() {\n    let version = env!(\"CARGO_PKG_NAME\").to_string() + \", version: \" + env!(\"CARGO_PKG_VERSION\");\n\n    let args: Args = Docopt::new(USAGE)\n        .and_then(|d| Ok(d.help(true)))\n        .and_then(|d| Ok(d.version(Some(version))))\n        .and_then(|d| d.deserialize())\n        .unwrap_or_else(|e| e.exit());\n\n    if args.flag_verbose {\n        env_logger::Builder::new()\n            .parse_filters(\"trace\")\n            .init();\n    }\n\n    let mut addr: net::SocketAddr = \"0.0.0.0:443\".parse().unwrap();\n    addr.set_port(args.flag_port.unwrap_or(443));\n\n    let config = make_config(&args);\n\n    let listener = TcpListener::bind(&addr).expect(\"cannot listen on port\");\n    let mut poll = mio::Poll::new()\n        .unwrap();\n    poll.register(&listener,\n                  LISTENER,\n                  mio::Ready::readable(),\n                  mio::PollOpt::level())\n        .unwrap();\n\n    let mode = if args.cmd_echo {\n        ServerMode::Echo\n    } else if args.cmd_http {\n        ServerMode::Http\n    } else {\n        ServerMode::Forward(args.arg_fport.expect(\"fport required\"))\n    };\n\n    let mut tlsserv = TlsServer::new(listener, mode, config);\n\n    let mut events = mio::Events::with_capacity(256);\n    loop {\n        poll.poll(&mut events, None)\n            .unwrap();\n\n        for event in events.iter() {\n            match event.token() {\n                LISTENER => {\n                    if !tlsserv.accept(&mut poll) {\n                        break;\n                    }\n                }\n                _ => tlsserv.conn_event(&mut poll, &event)\n            }\n        }\n    }\n}\n"], "filenames": ["rustls-mio/examples/tlsserver.rs"], "buggy_code_start_loc": [182], "buggy_code_end_loc": [183], "fixing_code_start_loc": [182], "fixing_code_end_loc": [183], "type": "CWE-88", "message": "rustls-mio/examples/tlsserver.rs in the rustls crate before 0.16.0 for Rust allows attackers to cause a denial of service (loop of conn_event and ready) by arranging for a client to never be writable.", "other": {"cve": {"id": "CVE-2019-15541", "sourceIdentifier": "cve@mitre.org", "published": "2019-08-26T12:15:11.780", "lastModified": "2019-09-03T18:44:40.147", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "rustls-mio/examples/tlsserver.rs in the rustls crate before 0.16.0 for Rust allows attackers to cause a denial of service (loop of conn_event and ready) by arranging for a client to never be writable."}, {"lang": "es", "value": "El archivo rustls-mio/examples/tlsserver.rs en el paquete rustls versiones anteriores a 0.16.0 para Rust, permite a atacantes causar una denegaci\u00f3n de servicio (bucle de conn_event y listo) mediante la realizaci\u00f3n de arreglos para que un cliente nunca se pueda escribir."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-88"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rustls_project:rustls:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.16.0", "matchCriteriaId": "5ED2EB11-1C95-4336-B6C9-33F9D2117888"}]}]}], "references": [{"url": "https://github.com/ctz/rustls/commit/a93ee1abd2ab19ebe4bf9d684d56637ee54a6074", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ctz/rustls/compare/cd66549...17ee52c", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/ctz/rustls/issues/285", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ctz/rustls/commit/a93ee1abd2ab19ebe4bf9d684d56637ee54a6074"}}