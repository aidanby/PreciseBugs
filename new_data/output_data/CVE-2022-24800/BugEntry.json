{"buggy_code": ["<?php namespace October\\Rain\\Database\\Attach;\n\nuse Log;\nuse Cache;\nuse Storage;\nuse Response;\nuse File as FileHelper;\nuse October\\Rain\\Network\\Http;\nuse October\\Rain\\Database\\Model;\nuse October\\Rain\\Resize\\Resizer;\nuse Symfony\\Component\\HttpFoundation\\File\\UploadedFile;\nuse Symfony\\Component\\HttpFoundation\\File\\File as FileObj;\nuse Exception;\n\n/**\n * File attachment model\n *\n * @package october\\database\n * @author Alexey Bobkov, Samuel Georges\n */\nclass File extends Model\n{\n    use \\October\\Rain\\Database\\Traits\\Sortable;\n\n    /**\n     * @var string table associated with the model\n     */\n    protected $table = 'files';\n\n    /**\n     * morphTo relation\n     */\n    public $morphTo = [\n        'attachment' => []\n    ];\n\n    /**\n     * @var array fillable attributes are mass assignable\n     */\n    protected $fillable = [\n        'file_name',\n        'title',\n        'description',\n        'field',\n        'attachment_id',\n        'attachment_type',\n        'is_public',\n        'sort_order',\n        'data',\n    ];\n\n    /**\n     * @var array guarded attributes aren't mass assignable\n     */\n    protected $guarded = [];\n\n    /**\n     * @var array imageExtensions known\n     */\n    public static $imageExtensions = ['jpg', 'jpeg', 'png', 'gif', 'webp'];\n\n    /**\n     * @var array hidden fields from array/json access\n     */\n    protected $hidden = ['attachment_type', 'attachment_id', 'is_public'];\n\n    /**\n     * @var array appends fields to array/json access\n     */\n    protected $appends = ['path', 'extension'];\n\n    /**\n     * @var mixed data is a local file name or an instance of an uploaded file,\n     * objects of the \\Symfony\\Component\\HttpFoundation\\File\\UploadedFile class.\n     */\n    public $data = null;\n\n    /**\n     * @var array autoMimeTypes\n     */\n    protected $autoMimeTypes = [\n        'docx' => 'application/msword',\n        'xlsx' => 'application/excel',\n        'gif'  => 'image/gif',\n        'png'  => 'image/png',\n        'jpg'  => 'image/jpeg',\n        'jpeg' => 'image/jpeg',\n        'webp' => 'image/webp',\n        'pdf'  => 'application/pdf',\n        'svg'  => 'image/svg+xml',\n    ];\n\n    //\n    // Constructors\n    //\n\n    /**\n     * fromPost creates a file object from a file an uploaded file\n     * @param Symfony\\Component\\HttpFoundation\\File\\UploadedFile $uploadedFile\n     */\n    public function fromPost($uploadedFile)\n    {\n        if ($uploadedFile === null) {\n            return;\n        }\n\n        $this->file_name = $uploadedFile->getClientOriginalName();\n        $this->file_size = $uploadedFile->getSize();\n        $this->content_type = $uploadedFile->getMimeType();\n        $this->disk_name = $this->getDiskName();\n\n        /*\n         * getRealPath() can be empty for some environments (IIS)\n         */\n        $realPath = empty(trim($uploadedFile->getRealPath()))\n            ? $uploadedFile->getPath() . DIRECTORY_SEPARATOR . $uploadedFile->getFileName()\n            : $uploadedFile->getRealPath();\n\n        $this->putFile($realPath, $this->disk_name);\n\n        return $this;\n    }\n\n    /**\n     * fromFile creates a file object from a file on the disk\n     */\n    public function fromFile($filePath)\n    {\n        if ($filePath === null) {\n            return;\n        }\n\n        $file = new FileObj($filePath);\n        $this->file_name = $file->getFilename();\n        $this->file_size = $file->getSize();\n        $this->content_type = $file->getMimeType();\n        $this->disk_name = $this->getDiskName();\n\n        $this->putFile($file->getRealPath(), $this->disk_name);\n\n        return $this;\n    }\n\n    /**\n     * fromData creates a file object from raw data\n     * @param $data string Raw data\n     * @param $filename string Filename\n     */\n    public function fromData($data, $filename)\n    {\n        if ($data === null) {\n            return;\n        }\n\n        $tempPath = temp_path(basename($filename));\n        FileHelper::put($tempPath, $data);\n\n        $file = $this->fromFile($tempPath);\n        FileHelper::delete($tempPath);\n\n        return $file;\n    }\n\n    /**\n     * fromUrl creates a file object from url\n     * @param $url string URL\n     * @param $filename string Filename\n     * @return $this\n     */\n    public function fromUrl($url, $filename = null)\n    {\n        $data = Http::get($url);\n\n        if ($data->code !== 200) {\n            throw new Exception(sprintf('Error getting file \"%s\", error code: %d', $data->url, $data->code));\n        }\n\n        if (empty($filename)) {\n            $filename = FileHelper::basename($url);\n        }\n\n        return $this->fromData($data, $filename);\n    }\n\n    //\n    // Attribute mutators\n    //\n\n    /**\n     * getPathAttribute helper attribute for getPath\n     * @return string\n     */\n    public function getPathAttribute()\n    {\n        return $this->getPath();\n    }\n\n    /**\n     * getExtensionAttribute helper attribute for getExtension\n     * @return string\n     */\n    public function getExtensionAttribute()\n    {\n        return $this->getExtension();\n    }\n\n    /**\n     * setDataAttribute used only when filling attributes\n     */\n    public function setDataAttribute($value)\n    {\n        $this->data = $value;\n    }\n\n    /**\n     * getWidthAttribute helper attribute for get image width\n     * @return string\n     */\n    public function getWidthAttribute()\n    {\n        if ($this->isImage()) {\n            $dimensions = $this->getImageDimensions();\n\n            return $dimensions[0];\n        }\n    }\n\n    /**\n     * getHeightAttribute helper attribute for get image height\n     * @return string\n     */\n    public function getHeightAttribute()\n    {\n        if ($this->isImage()) {\n            $dimensions = $this->getImageDimensions();\n\n            return $dimensions[1];\n        }\n    }\n\n    /**\n     * getSizeAttribute helper attribute for file size in human format\n     * @return string\n     */\n    public function getSizeAttribute()\n    {\n        return $this->sizeToString();\n    }\n\n    //\n    // Raw output\n    //\n\n    /**\n     * output the raw file contents\n     * @param string $disposition The Content-Disposition to set, defaults to inline\n     * @param bool $returnResponse\n     * @return Response|void\n     */\n    public function output($disposition = 'inline', $returnResponse = false)\n    {\n        $response = Response::make($this->getContents())->withHeaders([\n            'Content-type' => $this->getContentType(),\n            'Content-Disposition' => $disposition . '; filename=\"' . $this->file_name . '\"',\n            'Cache-Control' => 'private, no-store, no-cache, must-revalidate, pre-check=0, post-check=0, max-age=0',\n            'Accept-Ranges' => 'bytes',\n            'Content-Length' => $this->file_size,\n        ]);\n\n        if ($returnResponse) {\n            return $response;\n        }\n\n        $response->sendHeaders();\n        $response->sendContent();\n    }\n\n    /**\n     * outputThumb the raw thumb file contents\n     * @param integer $width\n     * @param integer $height\n     * @param array $options [\n     *     'mode'      => 'auto',\n     *     'offset'    => [0, 0],\n     *     'quality'   => 90,\n     *     'sharpen'   => 0,\n     *     'interlace' => false,\n     *     'extension' => 'auto',\n     *     'disposition' => 'inline',\n     * ]\n     * @param bool $returnResponse\n     * @return Response|void\n     */\n    public function outputThumb($width, $height, $options = [], $returnResponse = false)\n    {\n        $disposition = array_get($options, 'disposition', 'inline');\n        $options = $this->getDefaultThumbOptions($options);\n\n        // Generate thumb if not existing already\n        $thumbFile = $this->getThumbFilename($width, $height, $options);\n        if (\n            !$this->hasFile($thumbFile) &&\n            !$this->getThumb($width, $height, $options)\n        ) {\n            throw new Exception(sprintf('Thumb file \"%s\" failed to generate. Check error logs for more details.', $thumbFile));\n        }\n\n        $contents = $this->getContents($thumbFile);\n\n        $response = Response::make($contents)->withHeaders([\n            'Content-type' => $this->getContentType(),\n            'Content-Disposition' => $disposition . '; filename=\"' . basename($thumbFile) . '\"',\n            'Cache-Control' => 'private, no-store, no-cache, must-revalidate, pre-check=0, post-check=0, max-age=0',\n            'Accept-Ranges' => 'bytes',\n            'Content-Length' => mb_strlen($contents, '8bit'),\n        ]);\n\n        if ($returnResponse) {\n            return $response;\n        }\n\n        $response->sendHeaders();\n        $response->sendContent();\n    }\n\n    //\n    // Getters\n    //\n\n    /**\n     * getCacheKey returns the cache key used for the hasFile method\n     * @param string $path The path to get the cache key for\n     * @return string\n     */\n    public function getCacheKey($path = null)\n    {\n        if (empty($path)) {\n            $path = $this->getDiskPath();\n        }\n\n        return 'database-file::' . $path;\n    }\n\n    /**\n     * getFilename returns the file name without path\n     */\n    public function getFilename()\n    {\n        return $this->file_name;\n    }\n\n    /**\n     * getExtension returns the file extension\n     */\n    public function getExtension()\n    {\n        return FileHelper::extension($this->file_name);\n    }\n\n    /**\n     * getLastModified returns the last modification date as a UNIX timestamp\n     * @return int\n     */\n    public function getLastModified($fileName = null)\n    {\n        return $this->storageCmd('lastModified', $this->getDiskPath($fileName));\n    }\n\n    /**\n     * getContentType returns the file content type\n     */\n    public function getContentType()\n    {\n        if ($this->content_type !== null) {\n            return $this->content_type;\n        }\n\n        $ext = $this->getExtension();\n        if (isset($this->autoMimeTypes[$ext])) {\n            return $this->content_type = $this->autoMimeTypes[$ext];\n        }\n\n        return null;\n    }\n\n    /**\n     * getContents from storage device\n     */\n    public function getContents($fileName = null)\n    {\n        return $this->storageCmd('get', $this->getDiskPath($fileName));\n    }\n\n    /**\n     * getPath returns the public address to access the file\n     */\n    public function getPath($fileName = null)\n    {\n        if (empty($fileName)) {\n            $fileName = $this->disk_name;\n        }\n\n        return $this->getPublicPath() . $this->getPartitionDirectory() . $fileName;\n    }\n\n    /**\n     * getLocalPath returns a local path to this file. If the file is stored remotely,\n     * it will be downloaded to a temporary directory.\n     */\n    public function getLocalPath()\n    {\n        if ($this->isLocalStorage()) {\n            return $this->getLocalRootPath() . '/' . $this->getDiskPath();\n        }\n\n        $itemSignature = md5($this->getPath()) . $this->getLastModified();\n\n        $cachePath = $this->getLocalTempPath($itemSignature . '.' . $this->getExtension());\n\n        if (!FileHelper::exists($cachePath)) {\n            $this->copyStorageToLocal($this->getDiskPath(), $cachePath);\n        }\n\n        return $cachePath;\n    }\n\n    /**\n     * getDiskPath returns the path to the file, relative to the storage disk\n     * @return string\n     */\n    public function getDiskPath($fileName = null)\n    {\n        if (empty($fileName)) {\n            $fileName = $this->disk_name;\n        }\n\n        return $this->getStorageDirectory() . $this->getPartitionDirectory() . $fileName;\n    }\n\n    /**\n     * isPublic determines if the file is flagged \"public\" or not\n     */\n    public function isPublic()\n    {\n        if (array_key_exists('is_public', $this->attributes)) {\n            return $this->attributes['is_public'];\n        }\n\n        if (isset($this->is_public)) {\n            return $this->is_public;\n        }\n\n        return true;\n    }\n\n    /**\n     * sizeToString returns the file size as string\n     * @return string Returns the size as string.\n     */\n    public function sizeToString()\n    {\n        return FileHelper::sizeToString($this->file_size);\n    }\n\n    //\n    // Events\n    //\n\n    /**\n     * beforeSave check if new file data has been supplied\n     * eg: $model->data = Input::file('something');\n     */\n    public function beforeSave()\n    {\n        /*\n         * Process the data property\n         */\n        if ($this->data !== null) {\n            if ($this->data instanceof UploadedFile) {\n                $this->fromPost($this->data);\n            }\n            else {\n                $this->fromFile($this->data);\n            }\n\n            $this->data = null;\n        }\n    }\n\n    /**\n     * afterDelete clean up it's thumbnails\n     */\n    public function afterDelete()\n    {\n        try {\n            $this->deleteThumbs();\n            $this->deleteFile();\n        }\n        catch (Exception $ex) {\n        }\n    }\n\n    //\n    // Image handling\n    //\n\n    /**\n     * isImage checks if the file extension is an image and returns true or false\n     */\n    public function isImage()\n    {\n        return in_array(strtolower($this->getExtension()), static::$imageExtensions);\n    }\n\n    /**\n     * getImageDimensions\n     * @return array|bool\n     */\n    protected function getImageDimensions()\n    {\n        return getimagesize($this->getLocalPath());\n    }\n\n    /**\n     * getThumb generates and returns a thumbnail path\n     *\n     * @param integer $width\n     * @param integer $height\n     * @param array $options [\n     *     'mode'      => 'auto',\n     *     'offset'    => [0, 0],\n     *     'quality'   => 90,\n     *     'sharpen'   => 0,\n     *     'interlace' => false,\n     *     'extension' => 'auto',\n     * ]\n     * @return string The URL to the generated thumbnail\n     */\n    public function getThumb($width, $height, $options = [])\n    {\n        if (!$this->isImage() || !$this->hasFile($this->disk_name)) {\n            return $this->getPath();\n        }\n\n        $width = (int) $width;\n        $height = (int) $height;\n\n        $options = $this->getDefaultThumbOptions($options);\n\n        $thumbFile = $this->getThumbFilename($width, $height, $options);\n        $thumbPath = $this->getDiskPath($thumbFile);\n        $thumbPublic = $this->getPath($thumbFile);\n\n        if (!$this->hasFile($thumbFile)) {\n            try {\n                if ($this->isLocalStorage()) {\n                    $this->makeThumbLocal($thumbFile, $thumbPath, $width, $height, $options);\n                }\n                else {\n                    $this->makeThumbStorage($thumbFile, $thumbPath, $width, $height, $options);\n                }\n            }\n            catch (Exception $ex) {\n                Log::error($ex);\n                return '';\n            }\n        }\n\n        return $thumbPublic;\n    }\n\n    /**\n     * getThumbFilename generates a thumbnail filename\n     * @return string\n     */\n    public function getThumbFilename($width, $height, $options)\n    {\n        $options = $this->getDefaultThumbOptions($options);\n        return 'thumb_' . $this->id . '_' . $width . '_' . $height . '_' . $options['offset'][0] . '_' . $options['offset'][1] . '_' . $options['mode'] . '.' . $options['extension'];\n    }\n\n    /**\n     * getDefaultThumbOptions returns the default thumbnail options\n     * @return array\n     */\n    protected function getDefaultThumbOptions($overrideOptions = [])\n    {\n        $defaultOptions = [\n            'mode'      => 'auto',\n            'offset'    => [0, 0],\n            'quality'   => 90,\n            'sharpen'   => 0,\n            'interlace' => false,\n            'extension' => 'auto',\n        ];\n\n        if (!is_array($overrideOptions)) {\n            $overrideOptions = ['mode' => $overrideOptions];\n        }\n\n        $options = array_merge($defaultOptions, $overrideOptions);\n\n        $options['mode'] = strtolower($options['mode']);\n\n        if (strtolower($options['extension']) === 'auto') {\n            $options['extension'] = strtolower($this->getExtension());\n        }\n\n        return $options;\n    }\n\n    /**\n     * makeThumbLocal generates the thumbnail based on the local file system. This step\n     * is necessary to simplify things and ensure the correct file permissions are given\n     * to the local files.\n     */\n    protected function makeThumbLocal($thumbFile, $thumbPath, $width, $height, $options)\n    {\n        $rootPath = $this->getLocalRootPath();\n        $filePath = $rootPath.'/'.$this->getDiskPath();\n        $thumbPath = $rootPath.'/'.$thumbPath;\n\n        /*\n         * Generate thumbnail\n         */\n        Resizer::open($filePath)\n            ->resize($width, $height, $options)\n            ->save($thumbPath)\n        ;\n\n        FileHelper::chmod($thumbPath);\n    }\n\n    /**\n     * makeThumbStorage generates the thumbnail based on a remote storage engine\n     */\n    protected function makeThumbStorage($thumbFile, $thumbPath, $width, $height, $options)\n    {\n        $tempFile = $this->getLocalTempPath();\n        $tempThumb = $this->getLocalTempPath($thumbFile);\n\n        /*\n         * Generate thumbnail\n         */\n        $this->copyStorageToLocal($this->getDiskPath(), $tempFile);\n\n        try {\n            Resizer::open($tempFile)\n                ->resize($width, $height, $options)\n                ->save($tempThumb)\n            ;\n        }\n        finally {\n            FileHelper::delete($tempFile);\n        }\n\n        /*\n         * Publish to storage and clean up\n         */\n        $this->copyLocalToStorage($tempThumb, $thumbPath);\n\n        FileHelper::delete($tempThumb);\n    }\n\n    /**\n     * deleteThumbs deletes all thumbnails for this file\n     */\n    public function deleteThumbs()\n    {\n        $pattern = 'thumb_'.$this->id.'_';\n\n        $directory = $this->getStorageDirectory() . $this->getPartitionDirectory();\n        $allFiles = $this->storageCmd('files', $directory);\n        $collection = [];\n        foreach ($allFiles as $file) {\n            if (starts_with(basename($file), $pattern)) {\n                $collection[] = $file;\n            }\n        }\n\n        /*\n         * Delete the collection of files\n         */\n        if (!empty($collection)) {\n            if ($this->isLocalStorage()) {\n                FileHelper::delete($collection);\n            }\n            else {\n                $this->getDisk()->delete($collection);\n\n                foreach ($collection as $filePath) {\n                    Cache::forget($this->getCacheKey($filePath));\n                }\n            }\n        }\n    }\n\n    //\n    // File handling\n    //\n\n    /**\n     * getDiskName generates a disk name from the supplied file name\n     */\n    protected function getDiskName()\n    {\n        if ($this->disk_name !== null) {\n            return $this->disk_name;\n        }\n\n        $ext = strtolower($this->getExtension());\n        $name = str_replace('.', '', uniqid('', true));\n\n        return $this->disk_name = !empty($ext) ? $name.'.'.$ext : $name;\n    }\n\n    /**\n     * getLocalTempPath returns a temporary local path to work from\n     */\n    protected function getLocalTempPath($path = null)\n    {\n        if (!$path) {\n            return $this->getTempPath() . '/' . md5($this->getDiskPath()) . '.' . $this->getExtension();\n        }\n\n        return $this->getTempPath() . '/' . $path;\n    }\n\n    /**\n     * putFile saves a file\n     * @param string $sourcePath An absolute local path to a file name to read from.\n     * @param string $destinationFileName A storage file name to save to.\n     */\n    protected function putFile($sourcePath, $destinationFileName = null)\n    {\n        if (!$destinationFileName) {\n            $destinationFileName = $this->disk_name;\n        }\n\n        $destinationPath = $this->getStorageDirectory() . $this->getPartitionDirectory();\n\n        if (!$this->isLocalStorage()) {\n            return $this->copyLocalToStorage($sourcePath, $destinationPath . $destinationFileName);\n        }\n\n        /*\n         * Using local storage, tack on the root path and work locally\n         * this will ensure the correct permissions are used.\n         */\n        $destinationPath = $this->getLocalRootPath() . '/' . $destinationPath;\n\n        /*\n         * Verify the directory exists, if not try to create it. If creation fails\n         * because the directory was created by a concurrent process then proceed,\n         * otherwise trigger the error.\n         */\n        if (\n            !FileHelper::isDirectory($destinationPath) &&\n            !FileHelper::makeDirectory($destinationPath, 0777, true, true) &&\n            !FileHelper::isDirectory($destinationPath)\n        ) {\n            if (($lastErr = error_get_last()) !== null) {\n                trigger_error($lastErr['message'], E_USER_WARNING);\n            }\n        }\n\n        return FileHelper::copy($sourcePath, $destinationPath . $destinationFileName);\n    }\n\n    /**\n     * deleteFile contents from storage device\n     */\n    protected function deleteFile($fileName = null)\n    {\n        if (!$fileName) {\n            $fileName = $this->disk_name;\n        }\n\n        $directory = $this->getStorageDirectory() . $this->getPartitionDirectory();\n        $filePath = $directory . $fileName;\n\n        if ($this->storageCmd('exists', $filePath)) {\n            $this->storageCmd('delete', $filePath);\n        }\n\n        // Clear remote storage cache\n        if (!$this->isLocalStorage()) {\n            Cache::forget($this->getCacheKey($filePath));\n        }\n\n        $this->deleteEmptyDirectory($directory);\n    }\n\n    /**\n     * hasFile checks file exists on storage device\n     */\n    protected function hasFile($fileName = null)\n    {\n        $filePath = $this->getDiskPath($fileName);\n\n        if ($this->isLocalStorage()) {\n            return $this->storageCmd('exists', $filePath);\n        }\n\n        // Cache remote storage results for performance increase\n        $result = Cache::rememberForever($this->getCacheKey($filePath), function () use ($filePath) {\n            return $this->storageCmd('exists', $filePath);\n        });\n\n        // Forget negative results\n        if (!$result) {\n            Cache::forget($this->getCacheKey($filePath));\n        }\n\n        return $result;\n    }\n\n    /**\n     * deleteEmptyDirectory checks if directory is empty then deletes it,\n     * three levels up to match the partition directory.\n     */\n    protected function deleteEmptyDirectory($dir = null)\n    {\n        if (!$this->isDirectoryEmpty($dir)) {\n            return;\n        }\n\n        $this->storageCmd('deleteDirectory', $dir);\n\n        $dir = dirname($dir);\n        if (!$this->isDirectoryEmpty($dir)) {\n            return;\n        }\n\n        $this->storageCmd('deleteDirectory', $dir);\n\n        $dir = dirname($dir);\n        if (!$this->isDirectoryEmpty($dir)) {\n            return;\n        }\n\n        $this->storageCmd('deleteDirectory', $dir);\n    }\n\n    /**\n     * isDirectoryEmpty returns true if a directory contains no files\n     */\n    protected function isDirectoryEmpty($dir)\n    {\n        if (!$dir) {\n            return null;\n        }\n\n        return count($this->storageCmd('allFiles', $dir)) === 0;\n    }\n\n    //\n    // Storage interface\n    //\n\n    /**\n     * storageCmd calls a method against File or Storage depending on local storage\n     * This allows local storage outside the storage/app folder and is\n     * also good for performance. For local storage, *every* argument\n     * is prefixed with the local root path. Props to Laravel for\n     * the unified interface.\n     */\n    protected function storageCmd()\n    {\n        $args = func_get_args();\n        $command = array_shift($args);\n        $result = null;\n\n        if ($this->isLocalStorage()) {\n            $interface = 'File';\n            $path = $this->getLocalRootPath();\n            $args = array_map(function ($value) use ($path) {\n                return $path . '/' . $value;\n            }, $args);\n\n            $result = forward_static_call_array([$interface, $command], $args);\n        }\n        else {\n            $result = call_user_func_array([$this->getDisk(), $command], $args);\n        }\n\n        return $result;\n    }\n\n    /**\n     * copyStorageToLocal file\n     */\n    protected function copyStorageToLocal($storagePath, $localPath)\n    {\n        return FileHelper::put($localPath, $this->getDisk()->get($storagePath));\n    }\n\n    /**\n     * copyLocalToStorage file\n     */\n    protected function copyLocalToStorage($localPath, $storagePath)\n    {\n        return $this->getDisk()->put($storagePath, FileHelper::get($localPath), $this->isPublic() ? 'public' : null);\n    }\n\n    //\n    // Configuration\n    //\n\n    /**\n     * getMaxFilesize returns the maximum size of an uploaded file as configured in php.ini\n     * @return int The maximum size of an uploaded file in kilobytes\n     */\n    public static function getMaxFilesize()\n    {\n        return round(UploadedFile::getMaxFilesize() / 1024);\n    }\n\n    /**\n     * getStorageDirectory defines the internal storage path, override this method\n     */\n    public function getStorageDirectory()\n    {\n        if ($this->isPublic()) {\n            return 'uploads/public/';\n        }\n\n        return 'uploads/protected/';\n    }\n\n    /**\n     * getPublicPath defines the public address for the storage path\n     */\n    public function getPublicPath()\n    {\n        if ($this->isPublic()) {\n            return 'http://localhost/uploads/public/';\n        }\n\n        return 'http://localhost/uploads/protected/';\n    }\n\n    /**\n     * getTempPath defines the internal working path, override this method\n     */\n    public function getTempPath()\n    {\n        $path = temp_path() . '/uploads';\n\n        if (!FileHelper::isDirectory($path)) {\n            FileHelper::makeDirectory($path, 0777, true, true);\n        }\n\n        return $path;\n    }\n\n    /**\n     * getDisk returns the storage disk the file is stored on\n     * @return FilesystemAdapter\n     */\n    public function getDisk()\n    {\n        return Storage::disk();\n    }\n\n    /**\n     * isLocalStorage returns true if the storage engine is local\n     */\n    protected function isLocalStorage()\n    {\n        return Storage::getDefaultDriver() === 'local';\n    }\n\n    /**\n    * getPartitionDirectory generates a partition for the file\n    * return /ABC/DE1/234 for an name of ABCDE1234.\n    * @param Attachment $attachment\n    * @param string $styleName\n    * @return mixed\n    */\n    protected function getPartitionDirectory()\n    {\n        return implode('/', array_slice(str_split($this->disk_name, 3), 0, 3)) . '/';\n    }\n\n    /**\n     * getLocalRootPath if working with local storage, determine the absolute local path\n     */\n    protected function getLocalRootPath()\n    {\n        return storage_path() . '/app';\n    }\n}\n"], "fixing_code": ["<?php namespace October\\Rain\\Database\\Attach;\n\nuse Log;\nuse Cache;\nuse Storage;\nuse Response;\nuse File as FileHelper;\nuse October\\Rain\\Network\\Http;\nuse October\\Rain\\Database\\Model;\nuse October\\Rain\\Resize\\Resizer;\nuse Symfony\\Component\\HttpFoundation\\File\\UploadedFile;\nuse Symfony\\Component\\HttpFoundation\\File\\File as FileObj;\nuse Exception;\n\n/**\n * File attachment model\n *\n * @package october\\database\n * @author Alexey Bobkov, Samuel Georges\n */\nclass File extends Model\n{\n    use \\October\\Rain\\Database\\Traits\\Sortable;\n\n    /**\n     * @var string table associated with the model\n     */\n    protected $table = 'files';\n\n    /**\n     * morphTo relation\n     */\n    public $morphTo = [\n        'attachment' => []\n    ];\n\n    /**\n     * @var array fillable attributes are mass assignable\n     */\n    protected $fillable = [\n        'file_name',\n        'title',\n        'description',\n        'field',\n        'attachment_id',\n        'attachment_type',\n        'is_public',\n        'sort_order',\n        'data',\n    ];\n\n    /**\n     * @var array guarded attributes aren't mass assignable\n     */\n    protected $guarded = [];\n\n    /**\n     * @var array imageExtensions known\n     */\n    public static $imageExtensions = ['jpg', 'jpeg', 'png', 'gif', 'webp'];\n\n    /**\n     * @var array hidden fields from array/json access\n     */\n    protected $hidden = ['attachment_type', 'attachment_id', 'is_public'];\n\n    /**\n     * @var array appends fields to array/json access\n     */\n    protected $appends = ['path', 'extension'];\n\n    /**\n     * @var mixed data is a local file name or an instance of an uploaded file,\n     * objects of the \\Symfony\\Component\\HttpFoundation\\File\\UploadedFile class.\n     */\n    public $data = null;\n\n    /**\n     * @var array autoMimeTypes\n     */\n    protected $autoMimeTypes = [\n        'docx' => 'application/msword',\n        'xlsx' => 'application/excel',\n        'gif'  => 'image/gif',\n        'png'  => 'image/png',\n        'jpg'  => 'image/jpeg',\n        'jpeg' => 'image/jpeg',\n        'webp' => 'image/webp',\n        'pdf'  => 'application/pdf',\n        'svg'  => 'image/svg+xml',\n    ];\n\n    //\n    // Constructors\n    //\n\n    /**\n     * fromPost creates a file object from a file an uploaded file\n     * @param Symfony\\Component\\HttpFoundation\\File\\UploadedFile $uploadedFile\n     */\n    public function fromPost($uploadedFile)\n    {\n        if ($uploadedFile === null) {\n            return;\n        }\n\n        $this->file_name = $uploadedFile->getClientOriginalName();\n        $this->file_size = $uploadedFile->getSize();\n        $this->content_type = $uploadedFile->getMimeType();\n        $this->disk_name = $this->getDiskName();\n\n        /*\n         * getRealPath() can be empty for some environments (IIS)\n         */\n        $realPath = empty(trim($uploadedFile->getRealPath()))\n            ? $uploadedFile->getPath() . DIRECTORY_SEPARATOR . $uploadedFile->getFileName()\n            : $uploadedFile->getRealPath();\n\n        $this->putFile($realPath, $this->disk_name);\n\n        return $this;\n    }\n\n    /**\n     * fromFile creates a file object from a file on the disk\n     */\n    public function fromFile($filePath, $filename = null)\n    {\n        if ($filePath === null) {\n            return;\n        }\n\n        $file = new FileObj($filePath);\n        $this->file_name = empty($filename) ? $file->getFilename() : $filename;\n        $this->file_size = $file->getSize();\n        $this->content_type = $file->getMimeType();\n        $this->disk_name = $this->getDiskName();\n\n        $this->putFile($file->getRealPath(), $this->disk_name);\n\n        return $this;\n    }\n\n    /**\n     * fromData creates a file object from raw data\n     * @param $data string Raw data\n     * @param $filename string Filename\n     */\n    public function fromData($data, $filename)\n    {\n        if ($data === null) {\n            return;\n        }\n\n        $tempName = str_replace('.', '', uniqid('', true)) . '.tmp';\n        $tempPath = temp_path($tempName);\n        FileHelper::put($tempPath, $data);\n\n        $file = $this->fromFile($tempPath, basename($filename));\n        FileHelper::delete($tempPath);\n\n        return $file;\n    }\n\n    /**\n     * fromUrl creates a file object from url\n     * @param $url string URL\n     * @param $filename string Filename\n     * @return $this\n     */\n    public function fromUrl($url, $filename = null)\n    {\n        $data = Http::get($url);\n\n        if ($data->code !== 200) {\n            throw new Exception(sprintf('Error getting file \"%s\", error code: %d', $data->url, $data->code));\n        }\n\n        if (empty($filename)) {\n            $filename = FileHelper::basename($url);\n        }\n\n        return $this->fromData($data, $filename);\n    }\n\n    //\n    // Attribute mutators\n    //\n\n    /**\n     * getPathAttribute helper attribute for getPath\n     * @return string\n     */\n    public function getPathAttribute()\n    {\n        return $this->getPath();\n    }\n\n    /**\n     * getExtensionAttribute helper attribute for getExtension\n     * @return string\n     */\n    public function getExtensionAttribute()\n    {\n        return $this->getExtension();\n    }\n\n    /**\n     * setDataAttribute used only when filling attributes\n     */\n    public function setDataAttribute($value)\n    {\n        $this->data = $value;\n    }\n\n    /**\n     * getWidthAttribute helper attribute for get image width\n     * @return string\n     */\n    public function getWidthAttribute()\n    {\n        if ($this->isImage()) {\n            $dimensions = $this->getImageDimensions();\n\n            return $dimensions[0];\n        }\n    }\n\n    /**\n     * getHeightAttribute helper attribute for get image height\n     * @return string\n     */\n    public function getHeightAttribute()\n    {\n        if ($this->isImage()) {\n            $dimensions = $this->getImageDimensions();\n\n            return $dimensions[1];\n        }\n    }\n\n    /**\n     * getSizeAttribute helper attribute for file size in human format\n     * @return string\n     */\n    public function getSizeAttribute()\n    {\n        return $this->sizeToString();\n    }\n\n    //\n    // Raw output\n    //\n\n    /**\n     * output the raw file contents\n     * @param string $disposition The Content-Disposition to set, defaults to inline\n     * @param bool $returnResponse\n     * @return Response|void\n     */\n    public function output($disposition = 'inline', $returnResponse = false)\n    {\n        $response = Response::make($this->getContents())->withHeaders([\n            'Content-type' => $this->getContentType(),\n            'Content-Disposition' => $disposition . '; filename=\"' . $this->file_name . '\"',\n            'Cache-Control' => 'private, no-store, no-cache, must-revalidate, pre-check=0, post-check=0, max-age=0',\n            'Accept-Ranges' => 'bytes',\n            'Content-Length' => $this->file_size,\n        ]);\n\n        if ($returnResponse) {\n            return $response;\n        }\n\n        $response->sendHeaders();\n        $response->sendContent();\n    }\n\n    /**\n     * outputThumb the raw thumb file contents\n     * @param integer $width\n     * @param integer $height\n     * @param array $options [\n     *     'mode'      => 'auto',\n     *     'offset'    => [0, 0],\n     *     'quality'   => 90,\n     *     'sharpen'   => 0,\n     *     'interlace' => false,\n     *     'extension' => 'auto',\n     *     'disposition' => 'inline',\n     * ]\n     * @param bool $returnResponse\n     * @return Response|void\n     */\n    public function outputThumb($width, $height, $options = [], $returnResponse = false)\n    {\n        $disposition = array_get($options, 'disposition', 'inline');\n        $options = $this->getDefaultThumbOptions($options);\n\n        // Generate thumb if not existing already\n        $thumbFile = $this->getThumbFilename($width, $height, $options);\n        if (\n            !$this->hasFile($thumbFile) &&\n            !$this->getThumb($width, $height, $options)\n        ) {\n            throw new Exception(sprintf('Thumb file \"%s\" failed to generate. Check error logs for more details.', $thumbFile));\n        }\n\n        $contents = $this->getContents($thumbFile);\n\n        $response = Response::make($contents)->withHeaders([\n            'Content-type' => $this->getContentType(),\n            'Content-Disposition' => $disposition . '; filename=\"' . basename($thumbFile) . '\"',\n            'Cache-Control' => 'private, no-store, no-cache, must-revalidate, pre-check=0, post-check=0, max-age=0',\n            'Accept-Ranges' => 'bytes',\n            'Content-Length' => mb_strlen($contents, '8bit'),\n        ]);\n\n        if ($returnResponse) {\n            return $response;\n        }\n\n        $response->sendHeaders();\n        $response->sendContent();\n    }\n\n    //\n    // Getters\n    //\n\n    /**\n     * getCacheKey returns the cache key used for the hasFile method\n     * @param string $path The path to get the cache key for\n     * @return string\n     */\n    public function getCacheKey($path = null)\n    {\n        if (empty($path)) {\n            $path = $this->getDiskPath();\n        }\n\n        return 'database-file::' . $path;\n    }\n\n    /**\n     * getFilename returns the file name without path\n     */\n    public function getFilename()\n    {\n        return $this->file_name;\n    }\n\n    /**\n     * getExtension returns the file extension\n     */\n    public function getExtension()\n    {\n        return FileHelper::extension($this->file_name);\n    }\n\n    /**\n     * getLastModified returns the last modification date as a UNIX timestamp\n     * @return int\n     */\n    public function getLastModified($fileName = null)\n    {\n        return $this->storageCmd('lastModified', $this->getDiskPath($fileName));\n    }\n\n    /**\n     * getContentType returns the file content type\n     */\n    public function getContentType()\n    {\n        if ($this->content_type !== null) {\n            return $this->content_type;\n        }\n\n        $ext = $this->getExtension();\n        if (isset($this->autoMimeTypes[$ext])) {\n            return $this->content_type = $this->autoMimeTypes[$ext];\n        }\n\n        return null;\n    }\n\n    /**\n     * getContents from storage device\n     */\n    public function getContents($fileName = null)\n    {\n        return $this->storageCmd('get', $this->getDiskPath($fileName));\n    }\n\n    /**\n     * getPath returns the public address to access the file\n     */\n    public function getPath($fileName = null)\n    {\n        if (empty($fileName)) {\n            $fileName = $this->disk_name;\n        }\n\n        return $this->getPublicPath() . $this->getPartitionDirectory() . $fileName;\n    }\n\n    /**\n     * getLocalPath returns a local path to this file. If the file is stored remotely,\n     * it will be downloaded to a temporary directory.\n     */\n    public function getLocalPath()\n    {\n        if ($this->isLocalStorage()) {\n            return $this->getLocalRootPath() . '/' . $this->getDiskPath();\n        }\n\n        $itemSignature = md5($this->getPath()) . $this->getLastModified();\n\n        $cachePath = $this->getLocalTempPath($itemSignature . '.' . $this->getExtension());\n\n        if (!FileHelper::exists($cachePath)) {\n            $this->copyStorageToLocal($this->getDiskPath(), $cachePath);\n        }\n\n        return $cachePath;\n    }\n\n    /**\n     * getDiskPath returns the path to the file, relative to the storage disk\n     * @return string\n     */\n    public function getDiskPath($fileName = null)\n    {\n        if (empty($fileName)) {\n            $fileName = $this->disk_name;\n        }\n\n        return $this->getStorageDirectory() . $this->getPartitionDirectory() . $fileName;\n    }\n\n    /**\n     * isPublic determines if the file is flagged \"public\" or not\n     */\n    public function isPublic()\n    {\n        if (array_key_exists('is_public', $this->attributes)) {\n            return $this->attributes['is_public'];\n        }\n\n        if (isset($this->is_public)) {\n            return $this->is_public;\n        }\n\n        return true;\n    }\n\n    /**\n     * sizeToString returns the file size as string\n     * @return string Returns the size as string.\n     */\n    public function sizeToString()\n    {\n        return FileHelper::sizeToString($this->file_size);\n    }\n\n    //\n    // Events\n    //\n\n    /**\n     * beforeSave check if new file data has been supplied\n     * eg: $model->data = Input::file('something');\n     */\n    public function beforeSave()\n    {\n        /*\n         * Process the data property\n         */\n        if ($this->data !== null) {\n            if ($this->data instanceof UploadedFile) {\n                $this->fromPost($this->data);\n            }\n            else {\n                $this->fromFile($this->data);\n            }\n\n            $this->data = null;\n        }\n    }\n\n    /**\n     * afterDelete clean up it's thumbnails\n     */\n    public function afterDelete()\n    {\n        try {\n            $this->deleteThumbs();\n            $this->deleteFile();\n        }\n        catch (Exception $ex) {\n        }\n    }\n\n    //\n    // Image handling\n    //\n\n    /**\n     * isImage checks if the file extension is an image and returns true or false\n     */\n    public function isImage()\n    {\n        return in_array(strtolower($this->getExtension()), static::$imageExtensions);\n    }\n\n    /**\n     * getImageDimensions\n     * @return array|bool\n     */\n    protected function getImageDimensions()\n    {\n        return getimagesize($this->getLocalPath());\n    }\n\n    /**\n     * getThumb generates and returns a thumbnail path\n     *\n     * @param integer $width\n     * @param integer $height\n     * @param array $options [\n     *     'mode'      => 'auto',\n     *     'offset'    => [0, 0],\n     *     'quality'   => 90,\n     *     'sharpen'   => 0,\n     *     'interlace' => false,\n     *     'extension' => 'auto',\n     * ]\n     * @return string The URL to the generated thumbnail\n     */\n    public function getThumb($width, $height, $options = [])\n    {\n        if (!$this->isImage() || !$this->hasFile($this->disk_name)) {\n            return $this->getPath();\n        }\n\n        $width = (int) $width;\n        $height = (int) $height;\n\n        $options = $this->getDefaultThumbOptions($options);\n\n        $thumbFile = $this->getThumbFilename($width, $height, $options);\n        $thumbPath = $this->getDiskPath($thumbFile);\n        $thumbPublic = $this->getPath($thumbFile);\n\n        if (!$this->hasFile($thumbFile)) {\n            try {\n                if ($this->isLocalStorage()) {\n                    $this->makeThumbLocal($thumbFile, $thumbPath, $width, $height, $options);\n                }\n                else {\n                    $this->makeThumbStorage($thumbFile, $thumbPath, $width, $height, $options);\n                }\n            }\n            catch (Exception $ex) {\n                Log::error($ex);\n                return '';\n            }\n        }\n\n        return $thumbPublic;\n    }\n\n    /**\n     * getThumbFilename generates a thumbnail filename\n     * @return string\n     */\n    public function getThumbFilename($width, $height, $options)\n    {\n        $options = $this->getDefaultThumbOptions($options);\n        return 'thumb_' . $this->id . '_' . $width . '_' . $height . '_' . $options['offset'][0] . '_' . $options['offset'][1] . '_' . $options['mode'] . '.' . $options['extension'];\n    }\n\n    /**\n     * getDefaultThumbOptions returns the default thumbnail options\n     * @return array\n     */\n    protected function getDefaultThumbOptions($overrideOptions = [])\n    {\n        $defaultOptions = [\n            'mode'      => 'auto',\n            'offset'    => [0, 0],\n            'quality'   => 90,\n            'sharpen'   => 0,\n            'interlace' => false,\n            'extension' => 'auto',\n        ];\n\n        if (!is_array($overrideOptions)) {\n            $overrideOptions = ['mode' => $overrideOptions];\n        }\n\n        $options = array_merge($defaultOptions, $overrideOptions);\n\n        $options['mode'] = strtolower($options['mode']);\n\n        if (strtolower($options['extension']) === 'auto') {\n            $options['extension'] = strtolower($this->getExtension());\n        }\n\n        return $options;\n    }\n\n    /**\n     * makeThumbLocal generates the thumbnail based on the local file system. This step\n     * is necessary to simplify things and ensure the correct file permissions are given\n     * to the local files.\n     */\n    protected function makeThumbLocal($thumbFile, $thumbPath, $width, $height, $options)\n    {\n        $rootPath = $this->getLocalRootPath();\n        $filePath = $rootPath.'/'.$this->getDiskPath();\n        $thumbPath = $rootPath.'/'.$thumbPath;\n\n        /*\n         * Generate thumbnail\n         */\n        Resizer::open($filePath)\n            ->resize($width, $height, $options)\n            ->save($thumbPath)\n        ;\n\n        FileHelper::chmod($thumbPath);\n    }\n\n    /**\n     * makeThumbStorage generates the thumbnail based on a remote storage engine\n     */\n    protected function makeThumbStorage($thumbFile, $thumbPath, $width, $height, $options)\n    {\n        $tempFile = $this->getLocalTempPath();\n        $tempThumb = $this->getLocalTempPath($thumbFile);\n\n        /*\n         * Generate thumbnail\n         */\n        $this->copyStorageToLocal($this->getDiskPath(), $tempFile);\n\n        try {\n            Resizer::open($tempFile)\n                ->resize($width, $height, $options)\n                ->save($tempThumb)\n            ;\n        }\n        finally {\n            FileHelper::delete($tempFile);\n        }\n\n        /*\n         * Publish to storage and clean up\n         */\n        $this->copyLocalToStorage($tempThumb, $thumbPath);\n\n        FileHelper::delete($tempThumb);\n    }\n\n    /**\n     * deleteThumbs deletes all thumbnails for this file\n     */\n    public function deleteThumbs()\n    {\n        $pattern = 'thumb_'.$this->id.'_';\n\n        $directory = $this->getStorageDirectory() . $this->getPartitionDirectory();\n        $allFiles = $this->storageCmd('files', $directory);\n        $collection = [];\n        foreach ($allFiles as $file) {\n            if (starts_with(basename($file), $pattern)) {\n                $collection[] = $file;\n            }\n        }\n\n        /*\n         * Delete the collection of files\n         */\n        if (!empty($collection)) {\n            if ($this->isLocalStorage()) {\n                FileHelper::delete($collection);\n            }\n            else {\n                $this->getDisk()->delete($collection);\n\n                foreach ($collection as $filePath) {\n                    Cache::forget($this->getCacheKey($filePath));\n                }\n            }\n        }\n    }\n\n    //\n    // File handling\n    //\n\n    /**\n     * getDiskName generates a disk name from the supplied file name\n     */\n    protected function getDiskName()\n    {\n        if ($this->disk_name !== null) {\n            return $this->disk_name;\n        }\n\n        $ext = strtolower($this->getExtension());\n        $name = str_replace('.', '', uniqid('', true));\n\n        return $this->disk_name = !empty($ext) ? $name.'.'.$ext : $name;\n    }\n\n    /**\n     * getLocalTempPath returns a temporary local path to work from\n     */\n    protected function getLocalTempPath($path = null)\n    {\n        if (!$path) {\n            return $this->getTempPath() . '/' . md5($this->getDiskPath()) . '.' . $this->getExtension();\n        }\n\n        return $this->getTempPath() . '/' . $path;\n    }\n\n    /**\n     * putFile saves a file\n     * @param string $sourcePath An absolute local path to a file name to read from.\n     * @param string $destinationFileName A storage file name to save to.\n     */\n    protected function putFile($sourcePath, $destinationFileName = null)\n    {\n        if (!$destinationFileName) {\n            $destinationFileName = $this->disk_name;\n        }\n\n        $destinationPath = $this->getStorageDirectory() . $this->getPartitionDirectory();\n\n        if (!$this->isLocalStorage()) {\n            return $this->copyLocalToStorage($sourcePath, $destinationPath . $destinationFileName);\n        }\n\n        /*\n         * Using local storage, tack on the root path and work locally\n         * this will ensure the correct permissions are used.\n         */\n        $destinationPath = $this->getLocalRootPath() . '/' . $destinationPath;\n\n        /*\n         * Verify the directory exists, if not try to create it. If creation fails\n         * because the directory was created by a concurrent process then proceed,\n         * otherwise trigger the error.\n         */\n        if (\n            !FileHelper::isDirectory($destinationPath) &&\n            !FileHelper::makeDirectory($destinationPath, 0777, true, true) &&\n            !FileHelper::isDirectory($destinationPath)\n        ) {\n            if (($lastErr = error_get_last()) !== null) {\n                trigger_error($lastErr['message'], E_USER_WARNING);\n            }\n        }\n\n        return FileHelper::copy($sourcePath, $destinationPath . $destinationFileName);\n    }\n\n    /**\n     * deleteFile contents from storage device\n     */\n    protected function deleteFile($fileName = null)\n    {\n        if (!$fileName) {\n            $fileName = $this->disk_name;\n        }\n\n        $directory = $this->getStorageDirectory() . $this->getPartitionDirectory();\n        $filePath = $directory . $fileName;\n\n        if ($this->storageCmd('exists', $filePath)) {\n            $this->storageCmd('delete', $filePath);\n        }\n\n        // Clear remote storage cache\n        if (!$this->isLocalStorage()) {\n            Cache::forget($this->getCacheKey($filePath));\n        }\n\n        $this->deleteEmptyDirectory($directory);\n    }\n\n    /**\n     * hasFile checks file exists on storage device\n     */\n    protected function hasFile($fileName = null)\n    {\n        $filePath = $this->getDiskPath($fileName);\n\n        if ($this->isLocalStorage()) {\n            return $this->storageCmd('exists', $filePath);\n        }\n\n        // Cache remote storage results for performance increase\n        $result = Cache::rememberForever($this->getCacheKey($filePath), function () use ($filePath) {\n            return $this->storageCmd('exists', $filePath);\n        });\n\n        // Forget negative results\n        if (!$result) {\n            Cache::forget($this->getCacheKey($filePath));\n        }\n\n        return $result;\n    }\n\n    /**\n     * deleteEmptyDirectory checks if directory is empty then deletes it,\n     * three levels up to match the partition directory.\n     */\n    protected function deleteEmptyDirectory($dir = null)\n    {\n        if (!$this->isDirectoryEmpty($dir)) {\n            return;\n        }\n\n        $this->storageCmd('deleteDirectory', $dir);\n\n        $dir = dirname($dir);\n        if (!$this->isDirectoryEmpty($dir)) {\n            return;\n        }\n\n        $this->storageCmd('deleteDirectory', $dir);\n\n        $dir = dirname($dir);\n        if (!$this->isDirectoryEmpty($dir)) {\n            return;\n        }\n\n        $this->storageCmd('deleteDirectory', $dir);\n    }\n\n    /**\n     * isDirectoryEmpty returns true if a directory contains no files\n     */\n    protected function isDirectoryEmpty($dir)\n    {\n        if (!$dir) {\n            return null;\n        }\n\n        return count($this->storageCmd('allFiles', $dir)) === 0;\n    }\n\n    //\n    // Storage interface\n    //\n\n    /**\n     * storageCmd calls a method against File or Storage depending on local storage\n     * This allows local storage outside the storage/app folder and is\n     * also good for performance. For local storage, *every* argument\n     * is prefixed with the local root path. Props to Laravel for\n     * the unified interface.\n     */\n    protected function storageCmd()\n    {\n        $args = func_get_args();\n        $command = array_shift($args);\n        $result = null;\n\n        if ($this->isLocalStorage()) {\n            $interface = 'File';\n            $path = $this->getLocalRootPath();\n            $args = array_map(function ($value) use ($path) {\n                return $path . '/' . $value;\n            }, $args);\n\n            $result = forward_static_call_array([$interface, $command], $args);\n        }\n        else {\n            $result = call_user_func_array([$this->getDisk(), $command], $args);\n        }\n\n        return $result;\n    }\n\n    /**\n     * copyStorageToLocal file\n     */\n    protected function copyStorageToLocal($storagePath, $localPath)\n    {\n        return FileHelper::put($localPath, $this->getDisk()->get($storagePath));\n    }\n\n    /**\n     * copyLocalToStorage file\n     */\n    protected function copyLocalToStorage($localPath, $storagePath)\n    {\n        return $this->getDisk()->put($storagePath, FileHelper::get($localPath), $this->isPublic() ? 'public' : null);\n    }\n\n    //\n    // Configuration\n    //\n\n    /**\n     * getMaxFilesize returns the maximum size of an uploaded file as configured in php.ini\n     * @return int The maximum size of an uploaded file in kilobytes\n     */\n    public static function getMaxFilesize()\n    {\n        return round(UploadedFile::getMaxFilesize() / 1024);\n    }\n\n    /**\n     * getStorageDirectory defines the internal storage path, override this method\n     */\n    public function getStorageDirectory()\n    {\n        if ($this->isPublic()) {\n            return 'uploads/public/';\n        }\n\n        return 'uploads/protected/';\n    }\n\n    /**\n     * getPublicPath defines the public address for the storage path\n     */\n    public function getPublicPath()\n    {\n        if ($this->isPublic()) {\n            return 'http://localhost/uploads/public/';\n        }\n\n        return 'http://localhost/uploads/protected/';\n    }\n\n    /**\n     * getTempPath defines the internal working path, override this method\n     */\n    public function getTempPath()\n    {\n        $path = temp_path() . '/uploads';\n\n        if (!FileHelper::isDirectory($path)) {\n            FileHelper::makeDirectory($path, 0777, true, true);\n        }\n\n        return $path;\n    }\n\n    /**\n     * getDisk returns the storage disk the file is stored on\n     * @return FilesystemAdapter\n     */\n    public function getDisk()\n    {\n        return Storage::disk();\n    }\n\n    /**\n     * isLocalStorage returns true if the storage engine is local\n     */\n    protected function isLocalStorage()\n    {\n        return Storage::getDefaultDriver() === 'local';\n    }\n\n    /**\n    * getPartitionDirectory generates a partition for the file\n    * return /ABC/DE1/234 for an name of ABCDE1234.\n    * @param Attachment $attachment\n    * @param string $styleName\n    * @return mixed\n    */\n    protected function getPartitionDirectory()\n    {\n        return implode('/', array_slice(str_split($this->disk_name, 3), 0, 3)) . '/';\n    }\n\n    /**\n     * getLocalRootPath if working with local storage, determine the absolute local path\n     */\n    protected function getLocalRootPath()\n    {\n        return storage_path() . '/app';\n    }\n}\n"], "filenames": ["src/Database/Attach/File.php"], "buggy_code_start_loc": [127], "buggy_code_end_loc": [159], "fixing_code_start_loc": [127], "fixing_code_end_loc": [160], "type": "CWE-362", "message": "October/System is the system module for October CMS, a self-hosted CMS platform based on the Laravel PHP Framework. Prior to versions 1.0.476, 1.1.12, and 2.2.15, when the developer allows the user to specify their own filename in the `fromData` method, an unauthenticated user can perform remote code execution (RCE) by exploiting a race condition in the temporary storage directory. This vulnerability affects plugins that expose the `October\\Rain\\Database\\Attach\\File::fromData` as a public interface and does not affect vanilla installations of October CMS since this method is not exposed or used by the system internally or externally. The issue has been patched in Build 476 (v1.0.476), v1.1.12, and v2.2.15. Those who are unable to upgrade may apply with patch to their installation manually as a workaround.", "other": {"cve": {"id": "CVE-2022-24800", "sourceIdentifier": "security-advisories@github.com", "published": "2022-07-12T20:15:07.967", "lastModified": "2022-07-20T11:40:29.320", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "October/System is the system module for October CMS, a self-hosted CMS platform based on the Laravel PHP Framework. Prior to versions 1.0.476, 1.1.12, and 2.2.15, when the developer allows the user to specify their own filename in the `fromData` method, an unauthenticated user can perform remote code execution (RCE) by exploiting a race condition in the temporary storage directory. This vulnerability affects plugins that expose the `October\\Rain\\Database\\Attach\\File::fromData` as a public interface and does not affect vanilla installations of October CMS since this method is not exposed or used by the system internally or externally. The issue has been patched in Build 476 (v1.0.476), v1.1.12, and v2.2.15. Those who are unable to upgrade may apply with patch to their installation manually as a workaround."}, {"lang": "es", "value": "October/System es el m\u00f3dulo de sistema para October CMS, una plataforma CMS auto-alojada basada en el framework PHP Laravel. En versiones anteriores a 1.0.476, 1.1.12 y 2.2.15, cuando el desarrollador permite al usuario especificar su propio nombre de archivo en el m\u00e9todo \"fromData\", un usuario no autenticado puede llevar a cabo una ejecuci\u00f3n de c\u00f3digo remota (RCE) al explotar una condici\u00f3n de carrera en el directorio de almacenamiento temporal. Esta vulnerabilidad afecta a plugins que exponen el m\u00e9todo \"October\\Rain\\Database\\Attach\\File::fromData\" como una interfaz p\u00fablica y no afecta a las instalaciones vainilla de October CMS, ya que este m\u00e9todo no est\u00e1 expuesto ni es usado por el sistema interna o externamente. El problema ha sido parcheado en la Build 476 (v1.0.476), v1.1.12 y v2.2.15. Aquellos que no puedan actualizar pueden aplicar el parche a su instalaci\u00f3n manualmente como mitigaci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:octobercms:october:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.476", "matchCriteriaId": "8DBDB756-C914-43C4-8EB2-19D890142B02"}, {"vulnerable": true, "criteria": "cpe:2.3:a:octobercms:october:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.1.0", "versionEndExcluding": "1.1.12", "matchCriteriaId": "3C34F54F-A76E-4D74-A2E5-0D1F779D34B8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:octobercms:october:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "2.2.15", "matchCriteriaId": "B74F87D3-6302-4C4E-9F09-4B16681A6FDC"}]}]}], "references": [{"url": "https://github.com/octobercms/library/commit/fe569f3babf3f593be2b1e0a4ae0283506127a83", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/octobercms/october/security/advisories/GHSA-8v7h-cpc2-r8jp", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/octobercms/library/commit/fe569f3babf3f593be2b1e0a4ae0283506127a83"}}