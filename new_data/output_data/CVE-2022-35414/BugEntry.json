{"buggy_code": ["/* SPDX-License-Identifier: GPL-2.0-or-later */\n/*\n * QEMU LoongArch CPU\n *\n * Copyright (c) 2021 Loongson Technology Corporation Limited\n */\n\n#include \"qemu/osdep.h\"\n#include \"qemu/log.h\"\n#include \"qemu/qemu-print.h\"\n#include \"qapi/error.h\"\n#include \"qemu/module.h\"\n#include \"sysemu/qtest.h\"\n#include \"exec/exec-all.h\"\n#include \"qapi/qapi-commands-machine-target.h\"\n#include \"cpu.h\"\n#include \"internals.h\"\n#include \"fpu/softfloat-helpers.h\"\n#include \"cpu-csr.h\"\n#include \"sysemu/reset.h\"\n\nconst char * const regnames[32] = {\n    \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\",\n    \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\n    \"r16\", \"r17\", \"r18\", \"r19\", \"r20\", \"r21\", \"r22\", \"r23\",\n    \"r24\", \"r25\", \"r26\", \"r27\", \"r28\", \"r29\", \"r30\", \"r31\",\n};\n\nconst char * const fregnames[32] = {\n    \"f0\", \"f1\", \"f2\", \"f3\", \"f4\", \"f5\", \"f6\", \"f7\",\n    \"f8\", \"f9\", \"f10\", \"f11\", \"f12\", \"f13\", \"f14\", \"f15\",\n    \"f16\", \"f17\", \"f18\", \"f19\", \"f20\", \"f21\", \"f22\", \"f23\",\n    \"f24\", \"f25\", \"f26\", \"f27\", \"f28\", \"f29\", \"f30\", \"f31\",\n};\n\nstatic const char * const excp_names[] = {\n    [EXCCODE_INT] = \"Interrupt\",\n    [EXCCODE_PIL] = \"Page invalid exception for load\",\n    [EXCCODE_PIS] = \"Page invalid exception for store\",\n    [EXCCODE_PIF] = \"Page invalid exception for fetch\",\n    [EXCCODE_PME] = \"Page modified exception\",\n    [EXCCODE_PNR] = \"Page Not Readable exception\",\n    [EXCCODE_PNX] = \"Page Not Executable exception\",\n    [EXCCODE_PPI] = \"Page Privilege error\",\n    [EXCCODE_ADEF] = \"Address error for instruction fetch\",\n    [EXCCODE_ADEM] = \"Address error for Memory access\",\n    [EXCCODE_SYS] = \"Syscall\",\n    [EXCCODE_BRK] = \"Break\",\n    [EXCCODE_INE] = \"Instruction Non-Existent\",\n    [EXCCODE_IPE] = \"Instruction privilege error\",\n    [EXCCODE_FPE] = \"Floating Point Exception\",\n    [EXCCODE_DBP] = \"Debug breakpoint\",\n    [EXCCODE_BCE] = \"Bound Check Exception\",\n};\n\nconst char *loongarch_exception_name(int32_t exception)\n{\n    assert(excp_names[exception]);\n    return excp_names[exception];\n}\n\nvoid G_NORETURN do_raise_exception(CPULoongArchState *env,\n                                   uint32_t exception,\n                                   uintptr_t pc)\n{\n    CPUState *cs = env_cpu(env);\n\n    qemu_log_mask(CPU_LOG_INT, \"%s: %d (%s)\\n\",\n                  __func__,\n                  exception,\n                  loongarch_exception_name(exception));\n    cs->exception_index = exception;\n\n    cpu_loop_exit_restore(cs, pc);\n}\n\nstatic void loongarch_cpu_set_pc(CPUState *cs, vaddr value)\n{\n    LoongArchCPU *cpu = LOONGARCH_CPU(cs);\n    CPULoongArchState *env = &cpu->env;\n\n    env->pc = value;\n}\n\n#ifndef CONFIG_USER_ONLY\n#include \"hw/loongarch/virt.h\"\n\nvoid loongarch_cpu_set_irq(void *opaque, int irq, int level)\n{\n    LoongArchCPU *cpu = opaque;\n    CPULoongArchState *env = &cpu->env;\n    CPUState *cs = CPU(cpu);\n\n    if (irq < 0 || irq >= N_IRQS) {\n        return;\n    }\n\n    env->CSR_ESTAT = deposit64(env->CSR_ESTAT, irq, 1, level != 0);\n\n    if (FIELD_EX64(env->CSR_ESTAT, CSR_ESTAT, IS)) {\n        cpu_interrupt(cs, CPU_INTERRUPT_HARD);\n    } else {\n        cpu_reset_interrupt(cs, CPU_INTERRUPT_HARD);\n    }\n}\n\nstatic inline bool cpu_loongarch_hw_interrupts_enabled(CPULoongArchState *env)\n{\n    bool ret = 0;\n\n    ret = (FIELD_EX64(env->CSR_CRMD, CSR_CRMD, IE) &&\n          !(FIELD_EX64(env->CSR_DBG, CSR_DBG, DST)));\n\n    return ret;\n}\n\n/* Check if there is pending and not masked out interrupt */\nstatic inline bool cpu_loongarch_hw_interrupts_pending(CPULoongArchState *env)\n{\n    uint32_t pending;\n    uint32_t status;\n    bool r;\n\n    pending = FIELD_EX64(env->CSR_ESTAT, CSR_ESTAT, IS);\n    status  = FIELD_EX64(env->CSR_ECFG, CSR_ECFG, LIE);\n\n    r = (pending & status) != 0;\n    return r;\n}\n\nstatic void loongarch_cpu_do_interrupt(CPUState *cs)\n{\n    LoongArchCPU *cpu = LOONGARCH_CPU(cs);\n    CPULoongArchState *env = &cpu->env;\n    bool update_badinstr = 1;\n    int cause = -1;\n    const char *name;\n    bool tlbfill = FIELD_EX64(env->CSR_TLBRERA, CSR_TLBRERA, ISTLBR);\n    uint32_t vec_size = FIELD_EX64(env->CSR_ECFG, CSR_ECFG, VS);\n\n    if (cs->exception_index != EXCCODE_INT) {\n        if (cs->exception_index < 0 ||\n            cs->exception_index > ARRAY_SIZE(excp_names)) {\n            name = \"unknown\";\n        } else {\n            name = excp_names[cs->exception_index];\n        }\n\n        qemu_log_mask(CPU_LOG_INT,\n                     \"%s enter: pc \" TARGET_FMT_lx \" ERA \" TARGET_FMT_lx\n                     \" TLBRERA \" TARGET_FMT_lx \" %s exception\\n\", __func__,\n                     env->pc, env->CSR_ERA, env->CSR_TLBRERA, name);\n    }\n\n    switch (cs->exception_index) {\n    case EXCCODE_DBP:\n        env->CSR_DBG = FIELD_DP64(env->CSR_DBG, CSR_DBG, DCL, 1);\n        env->CSR_DBG = FIELD_DP64(env->CSR_DBG, CSR_DBG, ECODE, 0xC);\n        goto set_DERA;\n    set_DERA:\n        env->CSR_DERA = env->pc;\n        env->CSR_DBG = FIELD_DP64(env->CSR_DBG, CSR_DBG, DST, 1);\n        env->pc = env->CSR_EENTRY + 0x480;\n        break;\n    case EXCCODE_INT:\n        if (FIELD_EX64(env->CSR_DBG, CSR_DBG, DST)) {\n            env->CSR_DBG = FIELD_DP64(env->CSR_DBG, CSR_DBG, DEI, 1);\n            goto set_DERA;\n        }\n        QEMU_FALLTHROUGH;\n    case EXCCODE_PIF:\n        cause = cs->exception_index;\n        update_badinstr = 0;\n        break;\n    case EXCCODE_SYS:\n    case EXCCODE_BRK:\n    case EXCCODE_INE:\n    case EXCCODE_IPE:\n    case EXCCODE_FPE:\n    case EXCCODE_BCE:\n        env->CSR_BADV = env->pc;\n        QEMU_FALLTHROUGH;\n    case EXCCODE_ADEM:\n    case EXCCODE_PIL:\n    case EXCCODE_PIS:\n    case EXCCODE_PME:\n    case EXCCODE_PNR:\n    case EXCCODE_PNX:\n    case EXCCODE_PPI:\n        cause = cs->exception_index;\n        break;\n    default:\n        qemu_log(\"Error: exception(%d) '%s' has not been supported\\n\",\n                 cs->exception_index, excp_names[cs->exception_index]);\n        abort();\n    }\n\n    if (update_badinstr) {\n        env->CSR_BADI = cpu_ldl_code(env, env->pc);\n    }\n\n    /* Save PLV and IE */\n    if (tlbfill) {\n        env->CSR_TLBRPRMD = FIELD_DP64(env->CSR_TLBRPRMD, CSR_TLBRPRMD, PPLV,\n                                       FIELD_EX64(env->CSR_CRMD,\n                                       CSR_CRMD, PLV));\n        env->CSR_TLBRPRMD = FIELD_DP64(env->CSR_TLBRPRMD, CSR_TLBRPRMD, PIE,\n                                       FIELD_EX64(env->CSR_CRMD, CSR_CRMD, IE));\n        /* set the DA mode */\n        env->CSR_CRMD = FIELD_DP64(env->CSR_CRMD, CSR_CRMD, DA, 1);\n        env->CSR_CRMD = FIELD_DP64(env->CSR_CRMD, CSR_CRMD, PG, 0);\n        env->CSR_TLBRERA = FIELD_DP64(env->CSR_TLBRERA, CSR_TLBRERA,\n                                      PC, (env->pc >> 2));\n    } else {\n        env->CSR_ESTAT = FIELD_DP64(env->CSR_ESTAT, CSR_ESTAT, ECODE, cause);\n        env->CSR_PRMD = FIELD_DP64(env->CSR_PRMD, CSR_PRMD, PPLV,\n                                   FIELD_EX64(env->CSR_CRMD, CSR_CRMD, PLV));\n        env->CSR_PRMD = FIELD_DP64(env->CSR_PRMD, CSR_PRMD, PIE,\n                                   FIELD_EX64(env->CSR_CRMD, CSR_CRMD, IE));\n        env->CSR_ERA = env->pc;\n    }\n\n    env->CSR_CRMD = FIELD_DP64(env->CSR_CRMD, CSR_CRMD, PLV, 0);\n    env->CSR_CRMD = FIELD_DP64(env->CSR_CRMD, CSR_CRMD, IE, 0);\n\n    if (vec_size) {\n        vec_size = (1 << vec_size) * 4;\n    }\n\n    if  (cs->exception_index == EXCCODE_INT) {\n        /* Interrupt */\n        uint32_t vector = 0;\n        uint32_t pending = FIELD_EX64(env->CSR_ESTAT, CSR_ESTAT, IS);\n        pending &= FIELD_EX64(env->CSR_ECFG, CSR_ECFG, LIE);\n\n        /* Find the highest-priority interrupt. */\n        vector = 31 - clz32(pending);\n        env->pc = env->CSR_EENTRY + (EXCCODE_EXTERNAL_INT + vector) * vec_size;\n        qemu_log_mask(CPU_LOG_INT,\n                      \"%s: PC \" TARGET_FMT_lx \" ERA \" TARGET_FMT_lx\n                      \" cause %d\\n\" \"    A \" TARGET_FMT_lx \" D \"\n                      TARGET_FMT_lx \" vector = %d ExC \" TARGET_FMT_lx \"ExS\"\n                      TARGET_FMT_lx \"\\n\",\n                      __func__, env->pc, env->CSR_ERA,\n                      cause, env->CSR_BADV, env->CSR_DERA, vector,\n                      env->CSR_ECFG, env->CSR_ESTAT);\n    } else {\n        if (tlbfill) {\n            env->pc = env->CSR_TLBRENTRY;\n        } else {\n            env->pc = env->CSR_EENTRY;\n            env->pc += cause * vec_size;\n        }\n        qemu_log_mask(CPU_LOG_INT,\n                      \"%s: PC \" TARGET_FMT_lx \" ERA \" TARGET_FMT_lx\n                      \" cause %d%s\\n, ESTAT \" TARGET_FMT_lx\n                      \" EXCFG \" TARGET_FMT_lx \" BADVA \" TARGET_FMT_lx\n                      \"BADI \" TARGET_FMT_lx \" SYS_NUM \" TARGET_FMT_lu\n                      \" cpu %d asid \" TARGET_FMT_lx \"\\n\", __func__, env->pc,\n                      tlbfill ? env->CSR_TLBRERA : env->CSR_ERA,\n                      cause, tlbfill ? \"(refill)\" : \"\", env->CSR_ESTAT,\n                      env->CSR_ECFG,\n                      tlbfill ? env->CSR_TLBRBADV : env->CSR_BADV,\n                      env->CSR_BADI, env->gpr[11], cs->cpu_index,\n                      env->CSR_ASID);\n    }\n    cs->exception_index = -1;\n}\n\nstatic void loongarch_cpu_do_transaction_failed(CPUState *cs, hwaddr physaddr,\n                                                vaddr addr, unsigned size,\n                                                MMUAccessType access_type,\n                                                int mmu_idx, MemTxAttrs attrs,\n                                                MemTxResult response,\n                                                uintptr_t retaddr)\n{\n    LoongArchCPU *cpu = LOONGARCH_CPU(cs);\n    CPULoongArchState *env = &cpu->env;\n\n    if (access_type == MMU_INST_FETCH) {\n        do_raise_exception(env, EXCCODE_ADEF, retaddr);\n    } else {\n        do_raise_exception(env, EXCCODE_ADEM, retaddr);\n    }\n}\n\nstatic bool loongarch_cpu_exec_interrupt(CPUState *cs, int interrupt_request)\n{\n    if (interrupt_request & CPU_INTERRUPT_HARD) {\n        LoongArchCPU *cpu = LOONGARCH_CPU(cs);\n        CPULoongArchState *env = &cpu->env;\n\n        if (cpu_loongarch_hw_interrupts_enabled(env) &&\n            cpu_loongarch_hw_interrupts_pending(env)) {\n            /* Raise it */\n            cs->exception_index = EXCCODE_INT;\n            loongarch_cpu_do_interrupt(cs);\n            return true;\n        }\n    }\n    return false;\n}\n#endif\n\n#ifdef CONFIG_TCG\nstatic void loongarch_cpu_synchronize_from_tb(CPUState *cs,\n                                              const TranslationBlock *tb)\n{\n    LoongArchCPU *cpu = LOONGARCH_CPU(cs);\n    CPULoongArchState *env = &cpu->env;\n\n    env->pc = tb->pc;\n}\n#endif /* CONFIG_TCG */\n\nstatic bool loongarch_cpu_has_work(CPUState *cs)\n{\n#ifdef CONFIG_USER_ONLY\n    return true;\n#else\n    LoongArchCPU *cpu = LOONGARCH_CPU(cs);\n    CPULoongArchState *env = &cpu->env;\n    bool has_work = false;\n\n    if ((cs->interrupt_request & CPU_INTERRUPT_HARD) &&\n        cpu_loongarch_hw_interrupts_pending(env)) {\n        has_work = true;\n    }\n\n    return has_work;\n#endif\n}\n\nstatic void loongarch_la464_initfn(Object *obj)\n{\n    LoongArchCPU *cpu = LOONGARCH_CPU(obj);\n    CPULoongArchState *env = &cpu->env;\n    int i;\n\n    for (i = 0; i < 21; i++) {\n        env->cpucfg[i] = 0x0;\n    }\n\n    env->cpucfg[0] = 0x14c010;  /* PRID */\n\n    uint32_t data = 0;\n    data = FIELD_DP32(data, CPUCFG1, ARCH, 2);\n    data = FIELD_DP32(data, CPUCFG1, PGMMU, 1);\n    data = FIELD_DP32(data, CPUCFG1, IOCSR, 1);\n    data = FIELD_DP32(data, CPUCFG1, PALEN, 0x2f);\n    data = FIELD_DP32(data, CPUCFG1, VALEN, 0x2f);\n    data = FIELD_DP32(data, CPUCFG1, UAL, 1);\n    data = FIELD_DP32(data, CPUCFG1, RI, 1);\n    data = FIELD_DP32(data, CPUCFG1, EP, 1);\n    data = FIELD_DP32(data, CPUCFG1, RPLV, 1);\n    data = FIELD_DP32(data, CPUCFG1, HP, 1);\n    data = FIELD_DP32(data, CPUCFG1, IOCSR_BRD, 1);\n    env->cpucfg[1] = data;\n\n    data = 0;\n    data = FIELD_DP32(data, CPUCFG2, FP, 1);\n    data = FIELD_DP32(data, CPUCFG2, FP_SP, 1);\n    data = FIELD_DP32(data, CPUCFG2, FP_DP, 1);\n    data = FIELD_DP32(data, CPUCFG2, FP_VER, 1);\n    data = FIELD_DP32(data, CPUCFG2, LLFTP, 1);\n    data = FIELD_DP32(data, CPUCFG2, LLFTP_VER, 1);\n    data = FIELD_DP32(data, CPUCFG2, LAM, 1);\n    env->cpucfg[2] = data;\n\n    env->cpucfg[4] = 100 * 1000 * 1000; /* Crystal frequency */\n\n    data = 0;\n    data = FIELD_DP32(data, CPUCFG5, CC_MUL, 1);\n    data = FIELD_DP32(data, CPUCFG5, CC_DIV, 1);\n    env->cpucfg[5] = data;\n\n    data = 0;\n    data = FIELD_DP32(data, CPUCFG16, L1_IUPRE, 1);\n    data = FIELD_DP32(data, CPUCFG16, L1_DPRE, 1);\n    data = FIELD_DP32(data, CPUCFG16, L2_IUPRE, 1);\n    data = FIELD_DP32(data, CPUCFG16, L2_IUUNIFY, 1);\n    data = FIELD_DP32(data, CPUCFG16, L2_IUPRIV, 1);\n    data = FIELD_DP32(data, CPUCFG16, L3_IUPRE, 1);\n    data = FIELD_DP32(data, CPUCFG16, L3_IUUNIFY, 1);\n    data = FIELD_DP32(data, CPUCFG16, L3_IUINCL, 1);\n    env->cpucfg[16] = data;\n\n    data = 0;\n    data = FIELD_DP32(data, CPUCFG17, L1IU_WAYS, 3);\n    data = FIELD_DP32(data, CPUCFG17, L1IU_SETS, 8);\n    data = FIELD_DP32(data, CPUCFG17, L1IU_SIZE, 6);\n    env->cpucfg[17] = data;\n\n    data = 0;\n    data = FIELD_DP32(data, CPUCFG18, L1D_WAYS, 3);\n    data = FIELD_DP32(data, CPUCFG18, L1D_SETS, 8);\n    data = FIELD_DP32(data, CPUCFG18, L1D_SIZE, 6);\n    env->cpucfg[18] = data;\n\n    data = 0;\n    data = FIELD_DP32(data, CPUCFG19, L2IU_WAYS, 15);\n    data = FIELD_DP32(data, CPUCFG19, L2IU_SETS, 8);\n    data = FIELD_DP32(data, CPUCFG19, L2IU_SIZE, 6);\n    env->cpucfg[19] = data;\n\n    data = 0;\n    data = FIELD_DP32(data, CPUCFG20, L3IU_WAYS, 15);\n    data = FIELD_DP32(data, CPUCFG20, L3IU_SETS, 14);\n    data = FIELD_DP32(data, CPUCFG20, L3IU_SETS, 6);\n    env->cpucfg[20] = data;\n\n    env->CSR_ASID = FIELD_DP64(0, CSR_ASID, ASIDBITS, 0xa);\n}\n\nstatic void loongarch_cpu_list_entry(gpointer data, gpointer user_data)\n{\n    const char *typename = object_class_get_name(OBJECT_CLASS(data));\n\n    qemu_printf(\"%s\\n\", typename);\n}\n\nvoid loongarch_cpu_list(void)\n{\n    GSList *list;\n    list = object_class_get_list_sorted(TYPE_LOONGARCH_CPU, false);\n    g_slist_foreach(list, loongarch_cpu_list_entry, NULL);\n    g_slist_free(list);\n}\n\nstatic void loongarch_cpu_reset(DeviceState *dev)\n{\n    CPUState *cs = CPU(dev);\n    LoongArchCPU *cpu = LOONGARCH_CPU(cs);\n    LoongArchCPUClass *lacc = LOONGARCH_CPU_GET_CLASS(cpu);\n    CPULoongArchState *env = &cpu->env;\n\n    lacc->parent_reset(dev);\n\n    env->fcsr0_mask = FCSR0_M1 | FCSR0_M2 | FCSR0_M3;\n    env->fcsr0 = 0x0;\n\n    int n;\n    /* Set csr registers value after reset */\n    env->CSR_CRMD = FIELD_DP64(env->CSR_CRMD, CSR_CRMD, PLV, 0);\n    env->CSR_CRMD = FIELD_DP64(env->CSR_CRMD, CSR_CRMD, IE, 0);\n    env->CSR_CRMD = FIELD_DP64(env->CSR_CRMD, CSR_CRMD, DA, 1);\n    env->CSR_CRMD = FIELD_DP64(env->CSR_CRMD, CSR_CRMD, PG, 0);\n    env->CSR_CRMD = FIELD_DP64(env->CSR_CRMD, CSR_CRMD, DATF, 1);\n    env->CSR_CRMD = FIELD_DP64(env->CSR_CRMD, CSR_CRMD, DATM, 1);\n\n    env->CSR_EUEN = FIELD_DP64(env->CSR_EUEN, CSR_EUEN, FPE, 0);\n    env->CSR_EUEN = FIELD_DP64(env->CSR_EUEN, CSR_EUEN, SXE, 0);\n    env->CSR_EUEN = FIELD_DP64(env->CSR_EUEN, CSR_EUEN, ASXE, 0);\n    env->CSR_EUEN = FIELD_DP64(env->CSR_EUEN, CSR_EUEN, BTE, 0);\n\n    env->CSR_MISC = 0;\n\n    env->CSR_ECFG = FIELD_DP64(env->CSR_ECFG, CSR_ECFG, VS, 0);\n    env->CSR_ECFG = FIELD_DP64(env->CSR_ECFG, CSR_ECFG, LIE, 0);\n\n    env->CSR_ESTAT = env->CSR_ESTAT & (~MAKE_64BIT_MASK(0, 2));\n    env->CSR_RVACFG = FIELD_DP64(env->CSR_RVACFG, CSR_RVACFG, RBITS, 0);\n    env->CSR_TCFG = FIELD_DP64(env->CSR_TCFG, CSR_TCFG, EN, 0);\n    env->CSR_LLBCTL = FIELD_DP64(env->CSR_LLBCTL, CSR_LLBCTL, KLO, 0);\n    env->CSR_TLBRERA = FIELD_DP64(env->CSR_TLBRERA, CSR_TLBRERA, ISTLBR, 0);\n    env->CSR_MERRCTL = FIELD_DP64(env->CSR_MERRCTL, CSR_MERRCTL, ISMERR, 0);\n\n    env->CSR_PRCFG3 = FIELD_DP64(env->CSR_PRCFG3, CSR_PRCFG3, TLB_TYPE, 2);\n    env->CSR_PRCFG3 = FIELD_DP64(env->CSR_PRCFG3, CSR_PRCFG3, MTLB_ENTRY, 63);\n    env->CSR_PRCFG3 = FIELD_DP64(env->CSR_PRCFG3, CSR_PRCFG3, STLB_WAYS, 7);\n    env->CSR_PRCFG3 = FIELD_DP64(env->CSR_PRCFG3, CSR_PRCFG3, STLB_SETS, 8);\n\n    for (n = 0; n < 4; n++) {\n        env->CSR_DMW[n] = FIELD_DP64(env->CSR_DMW[n], CSR_DMW, PLV0, 0);\n        env->CSR_DMW[n] = FIELD_DP64(env->CSR_DMW[n], CSR_DMW, PLV1, 0);\n        env->CSR_DMW[n] = FIELD_DP64(env->CSR_DMW[n], CSR_DMW, PLV2, 0);\n        env->CSR_DMW[n] = FIELD_DP64(env->CSR_DMW[n], CSR_DMW, PLV3, 0);\n    }\n\n#ifndef CONFIG_USER_ONLY\n    env->pc = 0x1c000000;\n#endif\n\n    restore_fp_status(env);\n    cs->exception_index = -1;\n}\n\nstatic void loongarch_cpu_disas_set_info(CPUState *s, disassemble_info *info)\n{\n    info->print_insn = print_insn_loongarch;\n}\n\nstatic void loongarch_cpu_realizefn(DeviceState *dev, Error **errp)\n{\n    CPUState *cs = CPU(dev);\n    LoongArchCPUClass *lacc = LOONGARCH_CPU_GET_CLASS(dev);\n    Error *local_err = NULL;\n\n    cpu_exec_realizefn(cs, &local_err);\n    if (local_err != NULL) {\n        error_propagate(errp, local_err);\n        return;\n    }\n\n    loongarch_cpu_register_gdb_regs_for_features(cs);\n\n    cpu_reset(cs);\n    qemu_init_vcpu(cs);\n\n    lacc->parent_realize(dev, errp);\n}\n\n#ifndef CONFIG_USER_ONLY\nstatic void loongarch_qemu_write(void *opaque, hwaddr addr,\n                                 uint64_t val, unsigned size)\n{\n}\n\nstatic uint64_t loongarch_qemu_read(void *opaque, hwaddr addr, unsigned size)\n{\n    switch (addr) {\n    case FEATURE_REG:\n        return 1ULL << IOCSRF_MSI | 1ULL << IOCSRF_EXTIOI |\n               1ULL << IOCSRF_CSRIPI;\n    case VENDOR_REG:\n        return 0x6e6f73676e6f6f4cULL; /* \"Loongson\" */\n    case CPUNAME_REG:\n        return 0x303030354133ULL;     /* \"3A5000\" */\n    case MISC_FUNC_REG:\n        return 1ULL << IOCSRM_EXTIOI_EN;\n    }\n    return 0ULL;\n}\n\nstatic const MemoryRegionOps loongarch_qemu_ops = {\n    .read = loongarch_qemu_read,\n    .write = loongarch_qemu_write,\n    .endianness = DEVICE_LITTLE_ENDIAN,\n    .valid = {\n        .min_access_size = 4,\n        .max_access_size = 8,\n    },\n    .impl = {\n        .min_access_size = 8,\n        .max_access_size = 8,\n    },\n};\n#endif\n\nstatic void loongarch_cpu_init(Object *obj)\n{\n    LoongArchCPU *cpu = LOONGARCH_CPU(obj);\n\n    cpu_set_cpustate_pointers(cpu);\n\n#ifndef CONFIG_USER_ONLY\n    CPULoongArchState *env = &cpu->env;\n    qdev_init_gpio_in(DEVICE(cpu), loongarch_cpu_set_irq, N_IRQS);\n    timer_init_ns(&cpu->timer, QEMU_CLOCK_VIRTUAL,\n                  &loongarch_constant_timer_cb, cpu);\n    memory_region_init_io(&env->system_iocsr, OBJECT(cpu), NULL,\n                      env, \"iocsr\", UINT64_MAX);\n    address_space_init(&env->address_space_iocsr, &env->system_iocsr, \"IOCSR\");\n    memory_region_init_io(&env->iocsr_mem, OBJECT(cpu), &loongarch_qemu_ops,\n                          NULL, \"iocsr_misc\", 0x428);\n    memory_region_add_subregion(&env->system_iocsr, 0, &env->iocsr_mem);\n#endif\n}\n\nstatic ObjectClass *loongarch_cpu_class_by_name(const char *cpu_model)\n{\n    ObjectClass *oc;\n    char *typename;\n\n    typename = g_strdup_printf(LOONGARCH_CPU_TYPE_NAME(\"%s\"), cpu_model);\n    oc = object_class_by_name(typename);\n    g_free(typename);\n    return oc;\n}\n\nvoid loongarch_cpu_dump_state(CPUState *cs, FILE *f, int flags)\n{\n    LoongArchCPU *cpu = LOONGARCH_CPU(cs);\n    CPULoongArchState *env = &cpu->env;\n    int i;\n\n    qemu_fprintf(f, \" PC=%016\" PRIx64 \" \", env->pc);\n    qemu_fprintf(f, \" FCSR0 0x%08x  fp_status 0x%02x\\n\", env->fcsr0,\n                 get_float_exception_flags(&env->fp_status));\n\n    /* gpr */\n    for (i = 0; i < 32; i++) {\n        if ((i & 3) == 0) {\n            qemu_fprintf(f, \" GPR%02d:\", i);\n        }\n        qemu_fprintf(f, \" %s %016\" PRIx64, regnames[i], env->gpr[i]);\n        if ((i & 3) == 3) {\n            qemu_fprintf(f, \"\\n\");\n        }\n    }\n\n    qemu_fprintf(f, \"CRMD=%016\" PRIx64 \"\\n\", env->CSR_CRMD);\n    qemu_fprintf(f, \"PRMD=%016\" PRIx64 \"\\n\", env->CSR_PRMD);\n    qemu_fprintf(f, \"EUEN=%016\" PRIx64 \"\\n\", env->CSR_EUEN);\n    qemu_fprintf(f, \"ESTAT=%016\" PRIx64 \"\\n\", env->CSR_ESTAT);\n    qemu_fprintf(f, \"ERA=%016\" PRIx64 \"\\n\", env->CSR_ERA);\n    qemu_fprintf(f, \"BADV=%016\" PRIx64 \"\\n\", env->CSR_BADV);\n    qemu_fprintf(f, \"BADI=%016\" PRIx64 \"\\n\", env->CSR_BADI);\n    qemu_fprintf(f, \"EENTRY=%016\" PRIx64 \"\\n\", env->CSR_EENTRY);\n    qemu_fprintf(f, \"PRCFG1=%016\" PRIx64 \", PRCFG2=%016\" PRIx64 \",\"\n                 \" PRCFG3=%016\" PRIx64 \"\\n\",\n                 env->CSR_PRCFG1, env->CSR_PRCFG3, env->CSR_PRCFG3);\n    qemu_fprintf(f, \"TLBRENTRY=%016\" PRIx64 \"\\n\", env->CSR_TLBRENTRY);\n    qemu_fprintf(f, \"TLBRBADV=%016\" PRIx64 \"\\n\", env->CSR_TLBRBADV);\n    qemu_fprintf(f, \"TLBRERA=%016\" PRIx64 \"\\n\", env->CSR_TLBRERA);\n\n    /* fpr */\n    if (flags & CPU_DUMP_FPU) {\n        for (i = 0; i < 32; i++) {\n            qemu_fprintf(f, \" %s %016\" PRIx64, fregnames[i], env->fpr[i]);\n            if ((i & 3) == 3) {\n                qemu_fprintf(f, \"\\n\");\n            }\n        }\n    }\n}\n\n#ifdef CONFIG_TCG\n#include \"hw/core/tcg-cpu-ops.h\"\n\nstatic struct TCGCPUOps loongarch_tcg_ops = {\n    .initialize = loongarch_translate_init,\n    .synchronize_from_tb = loongarch_cpu_synchronize_from_tb,\n\n#ifndef CONFIG_USER_ONLY\n    .tlb_fill = loongarch_cpu_tlb_fill,\n    .cpu_exec_interrupt = loongarch_cpu_exec_interrupt,\n    .do_interrupt = loongarch_cpu_do_interrupt,\n    .do_transaction_failed = loongarch_cpu_do_transaction_failed,\n#endif\n};\n#endif /* CONFIG_TCG */\n\n#ifndef CONFIG_USER_ONLY\n#include \"hw/core/sysemu-cpu-ops.h\"\n\nstatic const struct SysemuCPUOps loongarch_sysemu_ops = {\n    .get_phys_page_debug = loongarch_cpu_get_phys_page_debug,\n};\n#endif\n\nstatic void loongarch_cpu_class_init(ObjectClass *c, void *data)\n{\n    LoongArchCPUClass *lacc = LOONGARCH_CPU_CLASS(c);\n    CPUClass *cc = CPU_CLASS(c);\n    DeviceClass *dc = DEVICE_CLASS(c);\n\n    device_class_set_parent_realize(dc, loongarch_cpu_realizefn,\n                                    &lacc->parent_realize);\n    device_class_set_parent_reset(dc, loongarch_cpu_reset, &lacc->parent_reset);\n\n    cc->class_by_name = loongarch_cpu_class_by_name;\n    cc->has_work = loongarch_cpu_has_work;\n    cc->dump_state = loongarch_cpu_dump_state;\n    cc->set_pc = loongarch_cpu_set_pc;\n#ifndef CONFIG_USER_ONLY\n    dc->vmsd = &vmstate_loongarch_cpu;\n    cc->sysemu_ops = &loongarch_sysemu_ops;\n#endif\n    cc->disas_set_info = loongarch_cpu_disas_set_info;\n    cc->gdb_read_register = loongarch_cpu_gdb_read_register;\n    cc->gdb_write_register = loongarch_cpu_gdb_write_register;\n    cc->disas_set_info = loongarch_cpu_disas_set_info;\n    cc->gdb_num_core_regs = 34;\n    cc->gdb_core_xml_file = \"loongarch-base64.xml\";\n    cc->gdb_stop_before_watchpoint = true;\n\n#ifdef CONFIG_TCG\n    cc->tcg_ops = &loongarch_tcg_ops;\n#endif\n}\n\n#define DEFINE_LOONGARCH_CPU_TYPE(model, initfn) \\\n    { \\\n        .parent = TYPE_LOONGARCH_CPU, \\\n        .instance_init = initfn, \\\n        .name = LOONGARCH_CPU_TYPE_NAME(model), \\\n    }\n\nstatic const TypeInfo loongarch_cpu_type_infos[] = {\n    {\n        .name = TYPE_LOONGARCH_CPU,\n        .parent = TYPE_CPU,\n        .instance_size = sizeof(LoongArchCPU),\n        .instance_init = loongarch_cpu_init,\n\n        .abstract = true,\n        .class_size = sizeof(LoongArchCPUClass),\n        .class_init = loongarch_cpu_class_init,\n    },\n    DEFINE_LOONGARCH_CPU_TYPE(\"la464\", loongarch_la464_initfn),\n};\n\nDEFINE_TYPES(loongarch_cpu_type_infos)\n\nstatic void loongarch_cpu_add_definition(gpointer data, gpointer user_data)\n{\n    ObjectClass *oc = data;\n    CpuDefinitionInfoList **cpu_list = user_data;\n    CpuDefinitionInfo *info = g_new0(CpuDefinitionInfo, 1);\n    const char *typename = object_class_get_name(oc);\n\n    info->name = g_strndup(typename,\n                           strlen(typename) - strlen(\"-\" TYPE_LOONGARCH_CPU));\n    info->q_typename = g_strdup(typename);\n\n    QAPI_LIST_PREPEND(*cpu_list, info);\n}\n\nCpuDefinitionInfoList *qmp_query_cpu_definitions(Error **errp)\n{\n    CpuDefinitionInfoList *cpu_list = NULL;\n    GSList *list;\n\n    list = object_class_get_list(TYPE_LOONGARCH_CPU, false);\n    g_slist_foreach(list, loongarch_cpu_add_definition, &cpu_list);\n    g_slist_free(list);\n\n    return cpu_list;\n}\n"], "fixing_code": ["/* SPDX-License-Identifier: GPL-2.0-or-later */\n/*\n * QEMU LoongArch CPU\n *\n * Copyright (c) 2021 Loongson Technology Corporation Limited\n */\n\n#include \"qemu/osdep.h\"\n#include \"qemu/log.h\"\n#include \"qemu/qemu-print.h\"\n#include \"qapi/error.h\"\n#include \"qemu/module.h\"\n#include \"sysemu/qtest.h\"\n#include \"exec/exec-all.h\"\n#include \"qapi/qapi-commands-machine-target.h\"\n#include \"cpu.h\"\n#include \"internals.h\"\n#include \"fpu/softfloat-helpers.h\"\n#include \"cpu-csr.h\"\n#include \"sysemu/reset.h\"\n\nconst char * const regnames[32] = {\n    \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\",\n    \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\n    \"r16\", \"r17\", \"r18\", \"r19\", \"r20\", \"r21\", \"r22\", \"r23\",\n    \"r24\", \"r25\", \"r26\", \"r27\", \"r28\", \"r29\", \"r30\", \"r31\",\n};\n\nconst char * const fregnames[32] = {\n    \"f0\", \"f1\", \"f2\", \"f3\", \"f4\", \"f5\", \"f6\", \"f7\",\n    \"f8\", \"f9\", \"f10\", \"f11\", \"f12\", \"f13\", \"f14\", \"f15\",\n    \"f16\", \"f17\", \"f18\", \"f19\", \"f20\", \"f21\", \"f22\", \"f23\",\n    \"f24\", \"f25\", \"f26\", \"f27\", \"f28\", \"f29\", \"f30\", \"f31\",\n};\n\nstatic const char * const excp_names[] = {\n    [EXCCODE_INT] = \"Interrupt\",\n    [EXCCODE_PIL] = \"Page invalid exception for load\",\n    [EXCCODE_PIS] = \"Page invalid exception for store\",\n    [EXCCODE_PIF] = \"Page invalid exception for fetch\",\n    [EXCCODE_PME] = \"Page modified exception\",\n    [EXCCODE_PNR] = \"Page Not Readable exception\",\n    [EXCCODE_PNX] = \"Page Not Executable exception\",\n    [EXCCODE_PPI] = \"Page Privilege error\",\n    [EXCCODE_ADEF] = \"Address error for instruction fetch\",\n    [EXCCODE_ADEM] = \"Address error for Memory access\",\n    [EXCCODE_SYS] = \"Syscall\",\n    [EXCCODE_BRK] = \"Break\",\n    [EXCCODE_INE] = \"Instruction Non-Existent\",\n    [EXCCODE_IPE] = \"Instruction privilege error\",\n    [EXCCODE_FPE] = \"Floating Point Exception\",\n    [EXCCODE_DBP] = \"Debug breakpoint\",\n    [EXCCODE_BCE] = \"Bound Check Exception\",\n};\n\nconst char *loongarch_exception_name(int32_t exception)\n{\n    assert(excp_names[exception]);\n    return excp_names[exception];\n}\n\nvoid G_NORETURN do_raise_exception(CPULoongArchState *env,\n                                   uint32_t exception,\n                                   uintptr_t pc)\n{\n    CPUState *cs = env_cpu(env);\n\n    qemu_log_mask(CPU_LOG_INT, \"%s: %d (%s)\\n\",\n                  __func__,\n                  exception,\n                  loongarch_exception_name(exception));\n    cs->exception_index = exception;\n\n    cpu_loop_exit_restore(cs, pc);\n}\n\nstatic void loongarch_cpu_set_pc(CPUState *cs, vaddr value)\n{\n    LoongArchCPU *cpu = LOONGARCH_CPU(cs);\n    CPULoongArchState *env = &cpu->env;\n\n    env->pc = value;\n}\n\n#ifndef CONFIG_USER_ONLY\n#include \"hw/loongarch/virt.h\"\n\nvoid loongarch_cpu_set_irq(void *opaque, int irq, int level)\n{\n    LoongArchCPU *cpu = opaque;\n    CPULoongArchState *env = &cpu->env;\n    CPUState *cs = CPU(cpu);\n\n    if (irq < 0 || irq >= N_IRQS) {\n        return;\n    }\n\n    env->CSR_ESTAT = deposit64(env->CSR_ESTAT, irq, 1, level != 0);\n\n    if (FIELD_EX64(env->CSR_ESTAT, CSR_ESTAT, IS)) {\n        cpu_interrupt(cs, CPU_INTERRUPT_HARD);\n    } else {\n        cpu_reset_interrupt(cs, CPU_INTERRUPT_HARD);\n    }\n}\n\nstatic inline bool cpu_loongarch_hw_interrupts_enabled(CPULoongArchState *env)\n{\n    bool ret = 0;\n\n    ret = (FIELD_EX64(env->CSR_CRMD, CSR_CRMD, IE) &&\n          !(FIELD_EX64(env->CSR_DBG, CSR_DBG, DST)));\n\n    return ret;\n}\n\n/* Check if there is pending and not masked out interrupt */\nstatic inline bool cpu_loongarch_hw_interrupts_pending(CPULoongArchState *env)\n{\n    uint32_t pending;\n    uint32_t status;\n    bool r;\n\n    pending = FIELD_EX64(env->CSR_ESTAT, CSR_ESTAT, IS);\n    status  = FIELD_EX64(env->CSR_ECFG, CSR_ECFG, LIE);\n\n    r = (pending & status) != 0;\n    return r;\n}\n\nstatic void loongarch_cpu_do_interrupt(CPUState *cs)\n{\n    LoongArchCPU *cpu = LOONGARCH_CPU(cs);\n    CPULoongArchState *env = &cpu->env;\n    bool update_badinstr = 1;\n    int cause = -1;\n    const char *name;\n    bool tlbfill = FIELD_EX64(env->CSR_TLBRERA, CSR_TLBRERA, ISTLBR);\n    uint32_t vec_size = FIELD_EX64(env->CSR_ECFG, CSR_ECFG, VS);\n\n    if (cs->exception_index != EXCCODE_INT) {\n        if (cs->exception_index < 0 ||\n            cs->exception_index > ARRAY_SIZE(excp_names)) {\n            name = \"unknown\";\n        } else {\n            name = excp_names[cs->exception_index];\n        }\n\n        qemu_log_mask(CPU_LOG_INT,\n                     \"%s enter: pc \" TARGET_FMT_lx \" ERA \" TARGET_FMT_lx\n                     \" TLBRERA \" TARGET_FMT_lx \" %s exception\\n\", __func__,\n                     env->pc, env->CSR_ERA, env->CSR_TLBRERA, name);\n    }\n\n    switch (cs->exception_index) {\n    case EXCCODE_DBP:\n        env->CSR_DBG = FIELD_DP64(env->CSR_DBG, CSR_DBG, DCL, 1);\n        env->CSR_DBG = FIELD_DP64(env->CSR_DBG, CSR_DBG, ECODE, 0xC);\n        goto set_DERA;\n    set_DERA:\n        env->CSR_DERA = env->pc;\n        env->CSR_DBG = FIELD_DP64(env->CSR_DBG, CSR_DBG, DST, 1);\n        env->pc = env->CSR_EENTRY + 0x480;\n        break;\n    case EXCCODE_INT:\n        if (FIELD_EX64(env->CSR_DBG, CSR_DBG, DST)) {\n            env->CSR_DBG = FIELD_DP64(env->CSR_DBG, CSR_DBG, DEI, 1);\n            goto set_DERA;\n        }\n        QEMU_FALLTHROUGH;\n    case EXCCODE_PIF:\n        cause = cs->exception_index;\n        update_badinstr = 0;\n        break;\n    case EXCCODE_SYS:\n    case EXCCODE_BRK:\n    case EXCCODE_INE:\n    case EXCCODE_IPE:\n    case EXCCODE_FPE:\n    case EXCCODE_BCE:\n        env->CSR_BADV = env->pc;\n        QEMU_FALLTHROUGH;\n    case EXCCODE_ADEM:\n    case EXCCODE_PIL:\n    case EXCCODE_PIS:\n    case EXCCODE_PME:\n    case EXCCODE_PNR:\n    case EXCCODE_PNX:\n    case EXCCODE_PPI:\n        cause = cs->exception_index;\n        break;\n    default:\n        qemu_log(\"Error: exception(%d) '%s' has not been supported\\n\",\n                 cs->exception_index, excp_names[cs->exception_index]);\n        abort();\n    }\n\n    if (update_badinstr) {\n        env->CSR_BADI = cpu_ldl_code(env, env->pc);\n    }\n\n    /* Save PLV and IE */\n    if (tlbfill) {\n        env->CSR_TLBRPRMD = FIELD_DP64(env->CSR_TLBRPRMD, CSR_TLBRPRMD, PPLV,\n                                       FIELD_EX64(env->CSR_CRMD,\n                                       CSR_CRMD, PLV));\n        env->CSR_TLBRPRMD = FIELD_DP64(env->CSR_TLBRPRMD, CSR_TLBRPRMD, PIE,\n                                       FIELD_EX64(env->CSR_CRMD, CSR_CRMD, IE));\n        /* set the DA mode */\n        env->CSR_CRMD = FIELD_DP64(env->CSR_CRMD, CSR_CRMD, DA, 1);\n        env->CSR_CRMD = FIELD_DP64(env->CSR_CRMD, CSR_CRMD, PG, 0);\n        env->CSR_TLBRERA = FIELD_DP64(env->CSR_TLBRERA, CSR_TLBRERA,\n                                      PC, (env->pc >> 2));\n    } else {\n        env->CSR_ESTAT = FIELD_DP64(env->CSR_ESTAT, CSR_ESTAT, ECODE, cause);\n        env->CSR_PRMD = FIELD_DP64(env->CSR_PRMD, CSR_PRMD, PPLV,\n                                   FIELD_EX64(env->CSR_CRMD, CSR_CRMD, PLV));\n        env->CSR_PRMD = FIELD_DP64(env->CSR_PRMD, CSR_PRMD, PIE,\n                                   FIELD_EX64(env->CSR_CRMD, CSR_CRMD, IE));\n        env->CSR_ERA = env->pc;\n    }\n\n    env->CSR_CRMD = FIELD_DP64(env->CSR_CRMD, CSR_CRMD, PLV, 0);\n    env->CSR_CRMD = FIELD_DP64(env->CSR_CRMD, CSR_CRMD, IE, 0);\n\n    if (vec_size) {\n        vec_size = (1 << vec_size) * 4;\n    }\n\n    if  (cs->exception_index == EXCCODE_INT) {\n        /* Interrupt */\n        uint32_t vector = 0;\n        uint32_t pending = FIELD_EX64(env->CSR_ESTAT, CSR_ESTAT, IS);\n        pending &= FIELD_EX64(env->CSR_ECFG, CSR_ECFG, LIE);\n\n        /* Find the highest-priority interrupt. */\n        vector = 31 - clz32(pending);\n        env->pc = env->CSR_EENTRY + (EXCCODE_EXTERNAL_INT + vector) * vec_size;\n        qemu_log_mask(CPU_LOG_INT,\n                      \"%s: PC \" TARGET_FMT_lx \" ERA \" TARGET_FMT_lx\n                      \" cause %d\\n\" \"    A \" TARGET_FMT_lx \" D \"\n                      TARGET_FMT_lx \" vector = %d ExC \" TARGET_FMT_lx \"ExS\"\n                      TARGET_FMT_lx \"\\n\",\n                      __func__, env->pc, env->CSR_ERA,\n                      cause, env->CSR_BADV, env->CSR_DERA, vector,\n                      env->CSR_ECFG, env->CSR_ESTAT);\n    } else {\n        if (tlbfill) {\n            env->pc = env->CSR_TLBRENTRY;\n        } else {\n            env->pc = env->CSR_EENTRY;\n            env->pc += cause * vec_size;\n        }\n        qemu_log_mask(CPU_LOG_INT,\n                      \"%s: PC \" TARGET_FMT_lx \" ERA \" TARGET_FMT_lx\n                      \" cause %d%s\\n, ESTAT \" TARGET_FMT_lx\n                      \" EXCFG \" TARGET_FMT_lx \" BADVA \" TARGET_FMT_lx\n                      \"BADI \" TARGET_FMT_lx \" SYS_NUM \" TARGET_FMT_lu\n                      \" cpu %d asid \" TARGET_FMT_lx \"\\n\", __func__, env->pc,\n                      tlbfill ? env->CSR_TLBRERA : env->CSR_ERA,\n                      cause, tlbfill ? \"(refill)\" : \"\", env->CSR_ESTAT,\n                      env->CSR_ECFG,\n                      tlbfill ? env->CSR_TLBRBADV : env->CSR_BADV,\n                      env->CSR_BADI, env->gpr[11], cs->cpu_index,\n                      env->CSR_ASID);\n    }\n    cs->exception_index = -1;\n}\n\nstatic void loongarch_cpu_do_transaction_failed(CPUState *cs, hwaddr physaddr,\n                                                vaddr addr, unsigned size,\n                                                MMUAccessType access_type,\n                                                int mmu_idx, MemTxAttrs attrs,\n                                                MemTxResult response,\n                                                uintptr_t retaddr)\n{\n    LoongArchCPU *cpu = LOONGARCH_CPU(cs);\n    CPULoongArchState *env = &cpu->env;\n\n    if (access_type == MMU_INST_FETCH) {\n        do_raise_exception(env, EXCCODE_ADEF, retaddr);\n    } else {\n        do_raise_exception(env, EXCCODE_ADEM, retaddr);\n    }\n}\n\nstatic bool loongarch_cpu_exec_interrupt(CPUState *cs, int interrupt_request)\n{\n    if (interrupt_request & CPU_INTERRUPT_HARD) {\n        LoongArchCPU *cpu = LOONGARCH_CPU(cs);\n        CPULoongArchState *env = &cpu->env;\n\n        if (cpu_loongarch_hw_interrupts_enabled(env) &&\n            cpu_loongarch_hw_interrupts_pending(env)) {\n            /* Raise it */\n            cs->exception_index = EXCCODE_INT;\n            loongarch_cpu_do_interrupt(cs);\n            return true;\n        }\n    }\n    return false;\n}\n#endif\n\n#ifdef CONFIG_TCG\nstatic void loongarch_cpu_synchronize_from_tb(CPUState *cs,\n                                              const TranslationBlock *tb)\n{\n    LoongArchCPU *cpu = LOONGARCH_CPU(cs);\n    CPULoongArchState *env = &cpu->env;\n\n    env->pc = tb->pc;\n}\n#endif /* CONFIG_TCG */\n\nstatic bool loongarch_cpu_has_work(CPUState *cs)\n{\n#ifdef CONFIG_USER_ONLY\n    return true;\n#else\n    LoongArchCPU *cpu = LOONGARCH_CPU(cs);\n    CPULoongArchState *env = &cpu->env;\n    bool has_work = false;\n\n    if ((cs->interrupt_request & CPU_INTERRUPT_HARD) &&\n        cpu_loongarch_hw_interrupts_pending(env)) {\n        has_work = true;\n    }\n\n    return has_work;\n#endif\n}\n\nstatic void loongarch_la464_initfn(Object *obj)\n{\n    LoongArchCPU *cpu = LOONGARCH_CPU(obj);\n    CPULoongArchState *env = &cpu->env;\n    int i;\n\n    for (i = 0; i < 21; i++) {\n        env->cpucfg[i] = 0x0;\n    }\n\n    env->cpucfg[0] = 0x14c010;  /* PRID */\n\n    uint32_t data = 0;\n    data = FIELD_DP32(data, CPUCFG1, ARCH, 2);\n    data = FIELD_DP32(data, CPUCFG1, PGMMU, 1);\n    data = FIELD_DP32(data, CPUCFG1, IOCSR, 1);\n    data = FIELD_DP32(data, CPUCFG1, PALEN, 0x2f);\n    data = FIELD_DP32(data, CPUCFG1, VALEN, 0x2f);\n    data = FIELD_DP32(data, CPUCFG1, UAL, 1);\n    data = FIELD_DP32(data, CPUCFG1, RI, 1);\n    data = FIELD_DP32(data, CPUCFG1, EP, 1);\n    data = FIELD_DP32(data, CPUCFG1, RPLV, 1);\n    data = FIELD_DP32(data, CPUCFG1, HP, 1);\n    data = FIELD_DP32(data, CPUCFG1, IOCSR_BRD, 1);\n    env->cpucfg[1] = data;\n\n    data = 0;\n    data = FIELD_DP32(data, CPUCFG2, FP, 1);\n    data = FIELD_DP32(data, CPUCFG2, FP_SP, 1);\n    data = FIELD_DP32(data, CPUCFG2, FP_DP, 1);\n    data = FIELD_DP32(data, CPUCFG2, FP_VER, 1);\n    data = FIELD_DP32(data, CPUCFG2, LLFTP, 1);\n    data = FIELD_DP32(data, CPUCFG2, LLFTP_VER, 1);\n    data = FIELD_DP32(data, CPUCFG2, LAM, 1);\n    env->cpucfg[2] = data;\n\n    env->cpucfg[4] = 100 * 1000 * 1000; /* Crystal frequency */\n\n    data = 0;\n    data = FIELD_DP32(data, CPUCFG5, CC_MUL, 1);\n    data = FIELD_DP32(data, CPUCFG5, CC_DIV, 1);\n    env->cpucfg[5] = data;\n\n    data = 0;\n    data = FIELD_DP32(data, CPUCFG16, L1_IUPRE, 1);\n    data = FIELD_DP32(data, CPUCFG16, L1_DPRE, 1);\n    data = FIELD_DP32(data, CPUCFG16, L2_IUPRE, 1);\n    data = FIELD_DP32(data, CPUCFG16, L2_IUUNIFY, 1);\n    data = FIELD_DP32(data, CPUCFG16, L2_IUPRIV, 1);\n    data = FIELD_DP32(data, CPUCFG16, L3_IUPRE, 1);\n    data = FIELD_DP32(data, CPUCFG16, L3_IUUNIFY, 1);\n    data = FIELD_DP32(data, CPUCFG16, L3_IUINCL, 1);\n    env->cpucfg[16] = data;\n\n    data = 0;\n    data = FIELD_DP32(data, CPUCFG17, L1IU_WAYS, 3);\n    data = FIELD_DP32(data, CPUCFG17, L1IU_SETS, 8);\n    data = FIELD_DP32(data, CPUCFG17, L1IU_SIZE, 6);\n    env->cpucfg[17] = data;\n\n    data = 0;\n    data = FIELD_DP32(data, CPUCFG18, L1D_WAYS, 3);\n    data = FIELD_DP32(data, CPUCFG18, L1D_SETS, 8);\n    data = FIELD_DP32(data, CPUCFG18, L1D_SIZE, 6);\n    env->cpucfg[18] = data;\n\n    data = 0;\n    data = FIELD_DP32(data, CPUCFG19, L2IU_WAYS, 15);\n    data = FIELD_DP32(data, CPUCFG19, L2IU_SETS, 8);\n    data = FIELD_DP32(data, CPUCFG19, L2IU_SIZE, 6);\n    env->cpucfg[19] = data;\n\n    data = 0;\n    data = FIELD_DP32(data, CPUCFG20, L3IU_WAYS, 15);\n    data = FIELD_DP32(data, CPUCFG20, L3IU_SETS, 14);\n    data = FIELD_DP32(data, CPUCFG20, L3IU_SETS, 6);\n    env->cpucfg[20] = data;\n\n    env->CSR_ASID = FIELD_DP64(0, CSR_ASID, ASIDBITS, 0xa);\n}\n\nstatic void loongarch_cpu_list_entry(gpointer data, gpointer user_data)\n{\n    const char *typename = object_class_get_name(OBJECT_CLASS(data));\n\n    qemu_printf(\"%s\\n\", typename);\n}\n\nvoid loongarch_cpu_list(void)\n{\n    GSList *list;\n    list = object_class_get_list_sorted(TYPE_LOONGARCH_CPU, false);\n    g_slist_foreach(list, loongarch_cpu_list_entry, NULL);\n    g_slist_free(list);\n}\n\nstatic void loongarch_cpu_reset(DeviceState *dev)\n{\n    CPUState *cs = CPU(dev);\n    LoongArchCPU *cpu = LOONGARCH_CPU(cs);\n    LoongArchCPUClass *lacc = LOONGARCH_CPU_GET_CLASS(cpu);\n    CPULoongArchState *env = &cpu->env;\n\n    lacc->parent_reset(dev);\n\n    env->fcsr0_mask = FCSR0_M1 | FCSR0_M2 | FCSR0_M3;\n    env->fcsr0 = 0x0;\n\n    int n;\n    /* Set csr registers value after reset */\n    env->CSR_CRMD = FIELD_DP64(env->CSR_CRMD, CSR_CRMD, PLV, 0);\n    env->CSR_CRMD = FIELD_DP64(env->CSR_CRMD, CSR_CRMD, IE, 0);\n    env->CSR_CRMD = FIELD_DP64(env->CSR_CRMD, CSR_CRMD, DA, 1);\n    env->CSR_CRMD = FIELD_DP64(env->CSR_CRMD, CSR_CRMD, PG, 0);\n    env->CSR_CRMD = FIELD_DP64(env->CSR_CRMD, CSR_CRMD, DATF, 1);\n    env->CSR_CRMD = FIELD_DP64(env->CSR_CRMD, CSR_CRMD, DATM, 1);\n\n    env->CSR_EUEN = FIELD_DP64(env->CSR_EUEN, CSR_EUEN, FPE, 0);\n    env->CSR_EUEN = FIELD_DP64(env->CSR_EUEN, CSR_EUEN, SXE, 0);\n    env->CSR_EUEN = FIELD_DP64(env->CSR_EUEN, CSR_EUEN, ASXE, 0);\n    env->CSR_EUEN = FIELD_DP64(env->CSR_EUEN, CSR_EUEN, BTE, 0);\n\n    env->CSR_MISC = 0;\n\n    env->CSR_ECFG = FIELD_DP64(env->CSR_ECFG, CSR_ECFG, VS, 0);\n    env->CSR_ECFG = FIELD_DP64(env->CSR_ECFG, CSR_ECFG, LIE, 0);\n\n    env->CSR_ESTAT = env->CSR_ESTAT & (~MAKE_64BIT_MASK(0, 2));\n    env->CSR_RVACFG = FIELD_DP64(env->CSR_RVACFG, CSR_RVACFG, RBITS, 0);\n    env->CSR_TCFG = FIELD_DP64(env->CSR_TCFG, CSR_TCFG, EN, 0);\n    env->CSR_LLBCTL = FIELD_DP64(env->CSR_LLBCTL, CSR_LLBCTL, KLO, 0);\n    env->CSR_TLBRERA = FIELD_DP64(env->CSR_TLBRERA, CSR_TLBRERA, ISTLBR, 0);\n    env->CSR_MERRCTL = FIELD_DP64(env->CSR_MERRCTL, CSR_MERRCTL, ISMERR, 0);\n\n    env->CSR_PRCFG3 = FIELD_DP64(env->CSR_PRCFG3, CSR_PRCFG3, TLB_TYPE, 2);\n    env->CSR_PRCFG3 = FIELD_DP64(env->CSR_PRCFG3, CSR_PRCFG3, MTLB_ENTRY, 63);\n    env->CSR_PRCFG3 = FIELD_DP64(env->CSR_PRCFG3, CSR_PRCFG3, STLB_WAYS, 7);\n    env->CSR_PRCFG3 = FIELD_DP64(env->CSR_PRCFG3, CSR_PRCFG3, STLB_SETS, 8);\n\n    for (n = 0; n < 4; n++) {\n        env->CSR_DMW[n] = FIELD_DP64(env->CSR_DMW[n], CSR_DMW, PLV0, 0);\n        env->CSR_DMW[n] = FIELD_DP64(env->CSR_DMW[n], CSR_DMW, PLV1, 0);\n        env->CSR_DMW[n] = FIELD_DP64(env->CSR_DMW[n], CSR_DMW, PLV2, 0);\n        env->CSR_DMW[n] = FIELD_DP64(env->CSR_DMW[n], CSR_DMW, PLV3, 0);\n    }\n\n#ifndef CONFIG_USER_ONLY\n    env->pc = 0x1c000000;\n    memset(env->tlb, 0, sizeof(env->tlb));\n#endif\n\n    restore_fp_status(env);\n    cs->exception_index = -1;\n}\n\nstatic void loongarch_cpu_disas_set_info(CPUState *s, disassemble_info *info)\n{\n    info->print_insn = print_insn_loongarch;\n}\n\nstatic void loongarch_cpu_realizefn(DeviceState *dev, Error **errp)\n{\n    CPUState *cs = CPU(dev);\n    LoongArchCPUClass *lacc = LOONGARCH_CPU_GET_CLASS(dev);\n    Error *local_err = NULL;\n\n    cpu_exec_realizefn(cs, &local_err);\n    if (local_err != NULL) {\n        error_propagate(errp, local_err);\n        return;\n    }\n\n    loongarch_cpu_register_gdb_regs_for_features(cs);\n\n    cpu_reset(cs);\n    qemu_init_vcpu(cs);\n\n    lacc->parent_realize(dev, errp);\n}\n\n#ifndef CONFIG_USER_ONLY\nstatic void loongarch_qemu_write(void *opaque, hwaddr addr,\n                                 uint64_t val, unsigned size)\n{\n}\n\nstatic uint64_t loongarch_qemu_read(void *opaque, hwaddr addr, unsigned size)\n{\n    switch (addr) {\n    case FEATURE_REG:\n        return 1ULL << IOCSRF_MSI | 1ULL << IOCSRF_EXTIOI |\n               1ULL << IOCSRF_CSRIPI;\n    case VENDOR_REG:\n        return 0x6e6f73676e6f6f4cULL; /* \"Loongson\" */\n    case CPUNAME_REG:\n        return 0x303030354133ULL;     /* \"3A5000\" */\n    case MISC_FUNC_REG:\n        return 1ULL << IOCSRM_EXTIOI_EN;\n    }\n    return 0ULL;\n}\n\nstatic const MemoryRegionOps loongarch_qemu_ops = {\n    .read = loongarch_qemu_read,\n    .write = loongarch_qemu_write,\n    .endianness = DEVICE_LITTLE_ENDIAN,\n    .valid = {\n        .min_access_size = 4,\n        .max_access_size = 8,\n    },\n    .impl = {\n        .min_access_size = 8,\n        .max_access_size = 8,\n    },\n};\n#endif\n\nstatic void loongarch_cpu_init(Object *obj)\n{\n    LoongArchCPU *cpu = LOONGARCH_CPU(obj);\n\n    cpu_set_cpustate_pointers(cpu);\n\n#ifndef CONFIG_USER_ONLY\n    CPULoongArchState *env = &cpu->env;\n    qdev_init_gpio_in(DEVICE(cpu), loongarch_cpu_set_irq, N_IRQS);\n    timer_init_ns(&cpu->timer, QEMU_CLOCK_VIRTUAL,\n                  &loongarch_constant_timer_cb, cpu);\n    memory_region_init_io(&env->system_iocsr, OBJECT(cpu), NULL,\n                      env, \"iocsr\", UINT64_MAX);\n    address_space_init(&env->address_space_iocsr, &env->system_iocsr, \"IOCSR\");\n    memory_region_init_io(&env->iocsr_mem, OBJECT(cpu), &loongarch_qemu_ops,\n                          NULL, \"iocsr_misc\", 0x428);\n    memory_region_add_subregion(&env->system_iocsr, 0, &env->iocsr_mem);\n#endif\n}\n\nstatic ObjectClass *loongarch_cpu_class_by_name(const char *cpu_model)\n{\n    ObjectClass *oc;\n    char *typename;\n\n    typename = g_strdup_printf(LOONGARCH_CPU_TYPE_NAME(\"%s\"), cpu_model);\n    oc = object_class_by_name(typename);\n    g_free(typename);\n    return oc;\n}\n\nvoid loongarch_cpu_dump_state(CPUState *cs, FILE *f, int flags)\n{\n    LoongArchCPU *cpu = LOONGARCH_CPU(cs);\n    CPULoongArchState *env = &cpu->env;\n    int i;\n\n    qemu_fprintf(f, \" PC=%016\" PRIx64 \" \", env->pc);\n    qemu_fprintf(f, \" FCSR0 0x%08x  fp_status 0x%02x\\n\", env->fcsr0,\n                 get_float_exception_flags(&env->fp_status));\n\n    /* gpr */\n    for (i = 0; i < 32; i++) {\n        if ((i & 3) == 0) {\n            qemu_fprintf(f, \" GPR%02d:\", i);\n        }\n        qemu_fprintf(f, \" %s %016\" PRIx64, regnames[i], env->gpr[i]);\n        if ((i & 3) == 3) {\n            qemu_fprintf(f, \"\\n\");\n        }\n    }\n\n    qemu_fprintf(f, \"CRMD=%016\" PRIx64 \"\\n\", env->CSR_CRMD);\n    qemu_fprintf(f, \"PRMD=%016\" PRIx64 \"\\n\", env->CSR_PRMD);\n    qemu_fprintf(f, \"EUEN=%016\" PRIx64 \"\\n\", env->CSR_EUEN);\n    qemu_fprintf(f, \"ESTAT=%016\" PRIx64 \"\\n\", env->CSR_ESTAT);\n    qemu_fprintf(f, \"ERA=%016\" PRIx64 \"\\n\", env->CSR_ERA);\n    qemu_fprintf(f, \"BADV=%016\" PRIx64 \"\\n\", env->CSR_BADV);\n    qemu_fprintf(f, \"BADI=%016\" PRIx64 \"\\n\", env->CSR_BADI);\n    qemu_fprintf(f, \"EENTRY=%016\" PRIx64 \"\\n\", env->CSR_EENTRY);\n    qemu_fprintf(f, \"PRCFG1=%016\" PRIx64 \", PRCFG2=%016\" PRIx64 \",\"\n                 \" PRCFG3=%016\" PRIx64 \"\\n\",\n                 env->CSR_PRCFG1, env->CSR_PRCFG3, env->CSR_PRCFG3);\n    qemu_fprintf(f, \"TLBRENTRY=%016\" PRIx64 \"\\n\", env->CSR_TLBRENTRY);\n    qemu_fprintf(f, \"TLBRBADV=%016\" PRIx64 \"\\n\", env->CSR_TLBRBADV);\n    qemu_fprintf(f, \"TLBRERA=%016\" PRIx64 \"\\n\", env->CSR_TLBRERA);\n\n    /* fpr */\n    if (flags & CPU_DUMP_FPU) {\n        for (i = 0; i < 32; i++) {\n            qemu_fprintf(f, \" %s %016\" PRIx64, fregnames[i], env->fpr[i]);\n            if ((i & 3) == 3) {\n                qemu_fprintf(f, \"\\n\");\n            }\n        }\n    }\n}\n\n#ifdef CONFIG_TCG\n#include \"hw/core/tcg-cpu-ops.h\"\n\nstatic struct TCGCPUOps loongarch_tcg_ops = {\n    .initialize = loongarch_translate_init,\n    .synchronize_from_tb = loongarch_cpu_synchronize_from_tb,\n\n#ifndef CONFIG_USER_ONLY\n    .tlb_fill = loongarch_cpu_tlb_fill,\n    .cpu_exec_interrupt = loongarch_cpu_exec_interrupt,\n    .do_interrupt = loongarch_cpu_do_interrupt,\n    .do_transaction_failed = loongarch_cpu_do_transaction_failed,\n#endif\n};\n#endif /* CONFIG_TCG */\n\n#ifndef CONFIG_USER_ONLY\n#include \"hw/core/sysemu-cpu-ops.h\"\n\nstatic const struct SysemuCPUOps loongarch_sysemu_ops = {\n    .get_phys_page_debug = loongarch_cpu_get_phys_page_debug,\n};\n#endif\n\nstatic void loongarch_cpu_class_init(ObjectClass *c, void *data)\n{\n    LoongArchCPUClass *lacc = LOONGARCH_CPU_CLASS(c);\n    CPUClass *cc = CPU_CLASS(c);\n    DeviceClass *dc = DEVICE_CLASS(c);\n\n    device_class_set_parent_realize(dc, loongarch_cpu_realizefn,\n                                    &lacc->parent_realize);\n    device_class_set_parent_reset(dc, loongarch_cpu_reset, &lacc->parent_reset);\n\n    cc->class_by_name = loongarch_cpu_class_by_name;\n    cc->has_work = loongarch_cpu_has_work;\n    cc->dump_state = loongarch_cpu_dump_state;\n    cc->set_pc = loongarch_cpu_set_pc;\n#ifndef CONFIG_USER_ONLY\n    dc->vmsd = &vmstate_loongarch_cpu;\n    cc->sysemu_ops = &loongarch_sysemu_ops;\n#endif\n    cc->disas_set_info = loongarch_cpu_disas_set_info;\n    cc->gdb_read_register = loongarch_cpu_gdb_read_register;\n    cc->gdb_write_register = loongarch_cpu_gdb_write_register;\n    cc->disas_set_info = loongarch_cpu_disas_set_info;\n    cc->gdb_num_core_regs = 34;\n    cc->gdb_core_xml_file = \"loongarch-base64.xml\";\n    cc->gdb_stop_before_watchpoint = true;\n\n#ifdef CONFIG_TCG\n    cc->tcg_ops = &loongarch_tcg_ops;\n#endif\n}\n\n#define DEFINE_LOONGARCH_CPU_TYPE(model, initfn) \\\n    { \\\n        .parent = TYPE_LOONGARCH_CPU, \\\n        .instance_init = initfn, \\\n        .name = LOONGARCH_CPU_TYPE_NAME(model), \\\n    }\n\nstatic const TypeInfo loongarch_cpu_type_infos[] = {\n    {\n        .name = TYPE_LOONGARCH_CPU,\n        .parent = TYPE_CPU,\n        .instance_size = sizeof(LoongArchCPU),\n        .instance_init = loongarch_cpu_init,\n\n        .abstract = true,\n        .class_size = sizeof(LoongArchCPUClass),\n        .class_init = loongarch_cpu_class_init,\n    },\n    DEFINE_LOONGARCH_CPU_TYPE(\"la464\", loongarch_la464_initfn),\n};\n\nDEFINE_TYPES(loongarch_cpu_type_infos)\n\nstatic void loongarch_cpu_add_definition(gpointer data, gpointer user_data)\n{\n    ObjectClass *oc = data;\n    CpuDefinitionInfoList **cpu_list = user_data;\n    CpuDefinitionInfo *info = g_new0(CpuDefinitionInfo, 1);\n    const char *typename = object_class_get_name(oc);\n\n    info->name = g_strndup(typename,\n                           strlen(typename) - strlen(\"-\" TYPE_LOONGARCH_CPU));\n    info->q_typename = g_strdup(typename);\n\n    QAPI_LIST_PREPEND(*cpu_list, info);\n}\n\nCpuDefinitionInfoList *qmp_query_cpu_definitions(Error **errp)\n{\n    CpuDefinitionInfoList *cpu_list = NULL;\n    GSList *list;\n\n    list = object_class_get_list(TYPE_LOONGARCH_CPU, false);\n    g_slist_foreach(list, loongarch_cpu_add_definition, &cpu_list);\n    g_slist_free(list);\n\n    return cpu_list;\n}\n"], "filenames": ["target/loongarch/cpu.c"], "buggy_code_start_loc": [481], "buggy_code_end_loc": [481], "fixing_code_start_loc": [482], "fixing_code_end_loc": [483], "type": "CWE-908", "message": "** DISPUTED ** softmmu/physmem.c in QEMU through 7.0.0 can perform an uninitialized read on the translate_fail path, leading to an io_readx or io_writex crash. NOTE: a third party states that the Non-virtualization Use Case in the qemu.org reference applies here, i.e., \"Bugs affecting the non-virtualization use case are not considered security bugs at this time.\"", "other": {"cve": {"id": "CVE-2022-35414", "sourceIdentifier": "cve@mitre.org", "published": "2022-07-11T02:15:07.320", "lastModified": "2022-12-09T16:14:25.007", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "** DISPUTED ** softmmu/physmem.c in QEMU through 7.0.0 can perform an uninitialized read on the translate_fail path, leading to an io_readx or io_writex crash. NOTE: a third party states that the Non-virtualization Use Case in the qemu.org reference applies here, i.e., \"Bugs affecting the non-virtualization use case are not considered security bugs at this time.\""}, {"lang": "es", "value": "** EN DISPUTA ** El archivo softmmu/physmem.c en QEMU versiones hasta 7.0.0, puede llevar a cabo una lectura no inicializada en la ruta translate_fail, conllevando a un bloqueo io_readx o io_writex. NOTA: un tercero afirma que el caso de uso de no virtualizaci\u00f3n en la referencia de qemu.org se aplica aqu\u00ed, es decir, \"Los errores que afectan al caso de uso de no virtualizaci\u00f3n no se consideran errores de seguridad en este momento\""}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.0, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "COMPLETE", "baseScore": 6.1}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 8.5, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-908"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:qemu:qemu:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.1.50", "versionEndIncluding": "7.0.0", "matchCriteriaId": "8950F922-08CB-4E35-B8D2-E21F61E3E23E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/qemu/qemu/blob/f200ff158d5abcb974a6b597a962b6b2fbea2b06/softmmu/physmem.c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/qemu/qemu/blob/v7.0.0/include/exec/cpu-all.h#L145-L148", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/qemu/qemu/commit/3517fb726741c109cae7995f9ea46f0cab6187d6#diff-83c563ed6330dc5d49876f1116e7518b5c16654bbc6e9b4ea8e28f5833d576fcR482", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/qemu/qemu/commit/3517fb726741c109cae7995f9ea46f0cab6187d6#diff-83c563ed6330dc5d49876f1116e7518b5c16654bbc6e9b4ea8e28f5833d576fcR482.aa", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/qemu/qemu/commit/418ade7849ce7641c0f7333718caf5091a02fd4c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://gitlab.com/qemu-project/qemu/-/issues/1065", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Mitigation", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/09/msg00008.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://sick.codes/sick-2022-113", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://www.mail-archive.com/qemu-devel@nongnu.org/msg895266.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.qemu.org/docs/master/system/security.html#non-virtualization-use-case", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/qemu/qemu/commit/3517fb726741c109cae7995f9ea46f0cab6187d6#diff-83c563ed6330dc5d49876f1116e7518b5c16654bbc6e9b4ea8e28f5833d576fcR482"}}