{"buggy_code": ["import { set_current_component, current_component } from './lifecycle';\nimport { run_all, blank_object } from './utils';\nimport { boolean_attributes } from '../../shared/boolean_attributes';\nexport { is_void } from '../../shared/utils/names';\n\nexport const invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\n\nexport function spread(args, attrs_to_add) {\n\tconst attributes = Object.assign({}, ...args);\n\tif (attrs_to_add) {\n\t\tconst classes_to_add = attrs_to_add.classes;\n\t\tconst styles_to_add = attrs_to_add.styles;\n\n\t\tif (classes_to_add) {\n\t\t\tif (attributes.class == null) {\n\t\t\t\tattributes.class = classes_to_add;\n\t\t\t} else {\n\t\t\t\tattributes.class += ' ' + classes_to_add;\n\t\t\t}\n\t\t}\n\n\t\tif (styles_to_add) {\n\t\t\tif (attributes.style == null) {\n\t\t\t\tattributes.style = style_object_to_string(styles_to_add);\n\t\t\t} else {\n\t\t\t\tattributes.style = style_object_to_string(merge_ssr_styles(attributes.style, styles_to_add));\n\t\t\t}\n\t\t}\n\t}\n\n\tlet str = '';\n\n\tObject.keys(attributes).forEach(name => {\n\t\tif (invalid_attribute_name_character.test(name)) return;\n\n\t\tconst value = attributes[name];\n\t\tif (value === true) str += ' ' + name;\n\t\telse if (boolean_attributes.has(name.toLowerCase())) {\n\t\t\tif (value) str += ' ' + name;\n\t\t} else if (value != null) {\n\t\t\tstr += ` ${name}=\"${value}\"`;\n\t\t}\n\t});\n\n\treturn str;\n}\n\nexport function merge_ssr_styles(style_attribute, style_directive) {\n\tconst style_object = {};\n\tfor (const individual_style of style_attribute.split(';')) {\n\t\tconst colon_index = individual_style.indexOf(':');\n\t\tconst name = individual_style.slice(0, colon_index).trim();\n\t\tconst value = individual_style.slice(colon_index + 1).trim();\n\t\tif (!name) continue;\n\t\tstyle_object[name] = value;\n\t}\n\n\tfor (const name in style_directive) {\n\t\tconst value = style_directive[name];\n\t\tif (value) {\n\t\t\tstyle_object[name] = value;\n\t\t} else {\n\t\t\tdelete style_object[name];\n\t\t}\n\t}\n\n\treturn style_object;\n}\n\nconst ATTR_REGEX = /[&\"]/g;\nconst CONTENT_REGEX = /[&<]/g;\n\n/**\n * Note: this method is performance sensitive and has been optimized\n * https://github.com/sveltejs/svelte/pull/5701\n */\nexport function escape(value: unknown, is_attr = false) {\n\tconst str = String(value);\n\n\tconst pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;\n\tpattern.lastIndex = 0;\n\n\tlet escaped = '';\n\tlet last = 0;\n\n  while (pattern.test(str)) {\n    const i = pattern.lastIndex - 1;\n    const ch = str[i];\n    escaped += str.substring(last, i) + (ch === '&' ? '&amp;' : (ch === '\"' ? '&quot;' : '&lt;'));\n    last = i + 1;\n  }\n\n\treturn escaped + str.substring(last);\n}\n\nexport function escape_attribute_value(value) {\n\treturn typeof value === 'string' ? escape(value, true) : value;\n}\n\nexport function escape_object(obj) {\n\tconst result = {};\n\tfor (const key in obj) {\n\t\tresult[key] = escape_attribute_value(obj[key]);\n\t}\n\treturn result;\n}\n\nexport function each(items, fn) {\n\tlet str = '';\n\tfor (let i = 0; i < items.length; i += 1) {\n\t\tstr += fn(items[i], i);\n\t}\n\treturn str;\n}\n\nexport const missing_component = {\n\t$$render: () => ''\n};\n\nexport function validate_component(component, name) {\n\tif (!component || !component.$$render) {\n\t\tif (name === 'svelte:component') name += ' this={...}';\n\t\tthrow new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n\t}\n\n\treturn component;\n}\n\nexport function debug(file, line, column, values) {\n\tconsole.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n\tconsole.log(values); // eslint-disable-line no-console\n\treturn '';\n}\n\nlet on_destroy;\n\nexport function create_ssr_component(fn) {\n\tfunction $$render(result, props, bindings, slots, context) {\n\t\tconst parent_component = current_component;\n\n\t\tconst $$ = {\n\t\t\ton_destroy,\n\t\t\tcontext: new Map(context || (parent_component ? parent_component.$$.context : [])),\n\n\t\t\t// these will be immediately discarded\n\t\t\ton_mount: [],\n\t\t\tbefore_update: [],\n\t\t\tafter_update: [],\n\t\t\tcallbacks: blank_object()\n\t\t};\n\n\t\tset_current_component({ $$ });\n\n\t\tconst html = fn(result, props, bindings, slots);\n\n\t\tset_current_component(parent_component);\n\t\treturn html;\n\t}\n\n\treturn {\n\t\trender: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n\t\t\ton_destroy = [];\n\n\t\t\tconst result: {\n\t\t\t\ttitle: string;\n\t\t\t\thead: string;\n\t\t\t\tcss: Set<{\n\t\t\t\t\tmap: null;\n\t\t\t\t\tcode: string;\n\t\t\t\t}>;\n\t\t\t} = { title: '', head: '', css: new Set() };\n\n\t\t\tconst html = $$render(result, props, {}, $$slots, context);\n\n\t\t\trun_all(on_destroy);\n\n\t\t\treturn {\n\t\t\t\thtml,\n\t\t\t\tcss: {\n\t\t\t\t\tcode: Array.from(result.css).map(css => css.code).join('\\n'),\n\t\t\t\t\tmap: null // TODO\n\t\t\t\t},\n\t\t\t\thead: result.title + result.head\n\t\t\t};\n\t\t},\n\n\t\t$$render\n\t};\n}\n\nexport function add_attribute(name, value, boolean) {\n\tif (value == null || (boolean && !value)) return '';\n\tconst assignment = (boolean && value === true) ? '' : `=\"${escape_attribute_value(value.toString())}\"`;\n\treturn ` ${name}${assignment}`;\n}\n\nexport function add_classes(classes) {\n\treturn classes ? ` class=\"${classes}\"` : '';\n}\n\nfunction style_object_to_string(style_object) {\n\treturn Object.keys(style_object)\n\t\t.filter(key => style_object[key])\n\t\t.map(key => `${key}: ${style_object[key]};`)\n\t\t.join(' ');\n}\n\nexport function add_styles(style_object) {\n  const styles = style_object_to_string(style_object);\n\n  return styles ? ` style=\"${styles}\"` : '';\n}\n", "<div\n\tbar=\"'></div><script>alert(42)</script>\"\n\tfoo=\"&quot;></div><script>alert(42)</script>\"\n\tqux=\"&amp;&amp;&amp;\"\n></div>", "<script>\n\texport let props = {\n\t\tfoo: '\"></div><script>alert(42)</' + 'script>',\n\t\tbar: \"'></div><script>alert(42)</\" + 'script>',\n\t\t['\"></div><script>alert(42)</' + 'script>']: 'baz',\n\t\tqux: '&&&',\n\t};\n</script>\n\n<div {...props}></div>"], "fixing_code": ["import { set_current_component, current_component } from './lifecycle';\nimport { run_all, blank_object } from './utils';\nimport { boolean_attributes } from '../../shared/boolean_attributes';\nexport { is_void } from '../../shared/utils/names';\n\nexport const invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\n\nexport function spread(args, attrs_to_add) {\n\tconst attributes = Object.assign({}, ...args);\n\tif (attrs_to_add) {\n\t\tconst classes_to_add = attrs_to_add.classes;\n\t\tconst styles_to_add = attrs_to_add.styles;\n\n\t\tif (classes_to_add) {\n\t\t\tif (attributes.class == null) {\n\t\t\t\tattributes.class = classes_to_add;\n\t\t\t} else {\n\t\t\t\tattributes.class += ' ' + classes_to_add;\n\t\t\t}\n\t\t}\n\n\t\tif (styles_to_add) {\n\t\t\tif (attributes.style == null) {\n\t\t\t\tattributes.style = style_object_to_string(styles_to_add);\n\t\t\t} else {\n\t\t\t\tattributes.style = style_object_to_string(merge_ssr_styles(attributes.style, styles_to_add));\n\t\t\t}\n\t\t}\n\t}\n\n\tlet str = '';\n\n\tObject.keys(attributes).forEach(name => {\n\t\tif (invalid_attribute_name_character.test(name)) return;\n\n\t\tconst value = attributes[name];\n\t\tif (value === true) str += ' ' + name;\n\t\telse if (boolean_attributes.has(name.toLowerCase())) {\n\t\t\tif (value) str += ' ' + name;\n\t\t} else if (value != null) {\n\t\t\tstr += ` ${name}=\"${value}\"`;\n\t\t}\n\t});\n\n\treturn str;\n}\n\nexport function merge_ssr_styles(style_attribute, style_directive) {\n\tconst style_object = {};\n\tfor (const individual_style of style_attribute.split(';')) {\n\t\tconst colon_index = individual_style.indexOf(':');\n\t\tconst name = individual_style.slice(0, colon_index).trim();\n\t\tconst value = individual_style.slice(colon_index + 1).trim();\n\t\tif (!name) continue;\n\t\tstyle_object[name] = value;\n\t}\n\n\tfor (const name in style_directive) {\n\t\tconst value = style_directive[name];\n\t\tif (value) {\n\t\t\tstyle_object[name] = value;\n\t\t} else {\n\t\t\tdelete style_object[name];\n\t\t}\n\t}\n\n\treturn style_object;\n}\n\nconst ATTR_REGEX = /[&\"]/g;\nconst CONTENT_REGEX = /[&<]/g;\n\n/**\n * Note: this method is performance sensitive and has been optimized\n * https://github.com/sveltejs/svelte/pull/5701\n */\nexport function escape(value: unknown, is_attr = false) {\n\tconst str = String(value);\n\n\tconst pattern = is_attr ? ATTR_REGEX : CONTENT_REGEX;\n\tpattern.lastIndex = 0;\n\n\tlet escaped = '';\n\tlet last = 0;\n\n\twhile (pattern.test(str)) {\n\t\tconst i = pattern.lastIndex - 1;\n\t\tconst ch = str[i];\n\t\tescaped += str.substring(last, i) + (ch === '&' ? '&amp;' : (ch === '\"' ? '&quot;' : '&lt;'));\n\t\tlast = i + 1;\n\t}\n\n\treturn escaped + str.substring(last);\n}\n\nexport function escape_attribute_value(value) {\n\t// keep booleans, null, and undefined for the sake of `spread`\n\tconst should_escape = typeof value === 'string' || (value && typeof value === 'object');\n\treturn should_escape ? escape(value, true) : value;\n}\n\nexport function escape_object(obj) {\n\tconst result = {};\n\tfor (const key in obj) {\n\t\tresult[key] = escape_attribute_value(obj[key]);\n\t}\n\treturn result;\n}\n\nexport function each(items, fn) {\n\tlet str = '';\n\tfor (let i = 0; i < items.length; i += 1) {\n\t\tstr += fn(items[i], i);\n\t}\n\treturn str;\n}\n\nexport const missing_component = {\n\t$$render: () => ''\n};\n\nexport function validate_component(component, name) {\n\tif (!component || !component.$$render) {\n\t\tif (name === 'svelte:component') name += ' this={...}';\n\t\tthrow new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n\t}\n\n\treturn component;\n}\n\nexport function debug(file, line, column, values) {\n\tconsole.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n\tconsole.log(values); // eslint-disable-line no-console\n\treturn '';\n}\n\nlet on_destroy;\n\nexport function create_ssr_component(fn) {\n\tfunction $$render(result, props, bindings, slots, context) {\n\t\tconst parent_component = current_component;\n\n\t\tconst $$ = {\n\t\t\ton_destroy,\n\t\t\tcontext: new Map(context || (parent_component ? parent_component.$$.context : [])),\n\n\t\t\t// these will be immediately discarded\n\t\t\ton_mount: [],\n\t\t\tbefore_update: [],\n\t\t\tafter_update: [],\n\t\t\tcallbacks: blank_object()\n\t\t};\n\n\t\tset_current_component({ $$ });\n\n\t\tconst html = fn(result, props, bindings, slots);\n\n\t\tset_current_component(parent_component);\n\t\treturn html;\n\t}\n\n\treturn {\n\t\trender: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n\t\t\ton_destroy = [];\n\n\t\t\tconst result: {\n\t\t\t\ttitle: string;\n\t\t\t\thead: string;\n\t\t\t\tcss: Set<{\n\t\t\t\t\tmap: null;\n\t\t\t\t\tcode: string;\n\t\t\t\t}>;\n\t\t\t} = { title: '', head: '', css: new Set() };\n\n\t\t\tconst html = $$render(result, props, {}, $$slots, context);\n\n\t\t\trun_all(on_destroy);\n\n\t\t\treturn {\n\t\t\t\thtml,\n\t\t\t\tcss: {\n\t\t\t\t\tcode: Array.from(result.css).map(css => css.code).join('\\n'),\n\t\t\t\t\tmap: null // TODO\n\t\t\t\t},\n\t\t\t\thead: result.title + result.head\n\t\t\t};\n\t\t},\n\n\t\t$$render\n\t};\n}\n\nexport function add_attribute(name, value, boolean) {\n\tif (value == null || (boolean && !value)) return '';\n\tconst assignment = (boolean && value === true) ? '' : `=\"${escape(value, true)}\"`;\n\treturn ` ${name}${assignment}`;\n}\n\nexport function add_classes(classes) {\n\treturn classes ? ` class=\"${classes}\"` : '';\n}\n\nfunction style_object_to_string(style_object) {\n\treturn Object.keys(style_object)\n\t\t.filter(key => style_object[key])\n\t\t.map(key => `${key}: ${style_object[key]};`)\n\t\t.join(' ');\n}\n\nexport function add_styles(style_object) {\n  const styles = style_object_to_string(style_object);\n\n  return styles ? ` style=\"${styles}\"` : '';\n}\n", "<div\n\tbar=\"'></div><script>alert(42)</script>\"\n\tfoo=\"&quot;></div><script>alert(42)</script>\"\n\tqux=\"&amp;&amp;&amp;\"\n\tquux=\"&quot;><script>alert(42)</script>\"\n></div>\n\n<div\n\tfoo=\"foo\"\n\tunsafe=\"&quot;><script>alert(42)</script>\"\n></div>\n", "<script>\n\tconst safe = { foo: 'foo' };\n\tconst unsafe = { toString: () => '\"><script>alert(42)<\\/script>' };\n\n\texport let props = {\n\t\tfoo: '\"></div><script>alert(42)</' + 'script>',\n\t\tbar: \"'></div><script>alert(42)</\" + 'script>',\n\t\t['\"></div><script>alert(42)</' + 'script>']: 'baz',\n\t\tqux: '&&&',\n\t\tquux: unsafe\n\t};\n</script>\n\n<div {...props}></div>\n<div {...safe} {unsafe}></div>\n"], "filenames": ["src/runtime/internal/ssr.ts", "test/server-side-rendering/samples/attribute-escaped-quotes-spread/_expected.html", "test/server-side-rendering/samples/attribute-escaped-quotes-spread/main.svelte"], "buggy_code_start_loc": [88, 5, 1], "buggy_code_end_loc": [196, 6, 11], "fixing_code_start_loc": [88, 5, 2], "fixing_code_end_loc": [198, 12, 16], "type": "CWE-79", "message": "The package svelte before 3.49.0 are vulnerable to Cross-site Scripting (XSS) due to improper input sanitization and to improper escape of attributes when using objects during SSR (Server-Side Rendering). Exploiting this vulnerability is possible via objects with a custom toString() function.", "other": {"cve": {"id": "CVE-2022-25875", "sourceIdentifier": "report@snyk.io", "published": "2022-07-12T19:15:08.330", "lastModified": "2022-07-19T02:23:10.670", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The package svelte before 3.49.0 are vulnerable to Cross-site Scripting (XSS) due to improper input sanitization and to improper escape of attributes when using objects during SSR (Server-Side Rendering). Exploiting this vulnerability is possible via objects with a custom toString() function."}, {"lang": "es", "value": "El paquete svelte versiones anteriores a 3.49.0, es vulnerable a un ataque de tipo Cross-site Scripting (XSS) debido a un saneo inapropiado de la entrada y a un escape de atributos inapropiado cuando son usados objetos durante el SSR (Server-Side Rendering). La explotaci\u00f3n de esta vulnerabilidad es posible por medio de objetos con una funci\u00f3n toString() personalizada"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:svelte:svelte:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "3.49.0", "matchCriteriaId": "63F747DE-2C57-4C07-B79D-542F872AAD78"}]}]}], "references": [{"url": "https://github.com/sveltejs/svelte/commit/f8605d6acbf66976da9b4547f76e90e163899907", "source": "report@snyk.io", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/sveltejs/svelte/pull/7530%23issuecomment-1158575990", "source": "report@snyk.io", "tags": ["Broken Link"]}, {"url": "https://snyk.io/vuln/SNYK-JS-SVELTE-2931080", "source": "report@snyk.io", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/sveltejs/svelte/commit/f8605d6acbf66976da9b4547f76e90e163899907"}}