{"buggy_code": ["const bcrypt = require('bcrypt');\nconst express = require('express');\nconst cors = require('cors');\nconst path = require('path');\nconst uuid = require('uuid');\nconst asyncfs = require('fs').promises;\nconst sessions = require('@nvanexan/node-client-sessions');\nconst favicon = require('serve-favicon');\n\nconst database = require('./database.js');\nconst safeCompare = require('safe-compare');\nconst { Op } = require(\"sequelize\");\nconst sequelize = database.sequelize;\nconst Settings = database.Settings;\nconst PayloadFireResults = database.PayloadFireResults;\nconst CollectedPages = database.CollectedPages;\nconst InjectionRequests = database.InjectionRequests;\nconst update_settings_value = database.update_settings_value;\nconst constants = require('./constants.js');\nconst validate = require('express-jsonschema').validate;\nconst get_hashed_password = require('./utils.js').get_hashed_password;\nconst get_secure_random_string = require('./utils.js').get_secure_random_string;\n\nconst SCREENSHOTS_DIR = path.resolve(process.env.SCREENSHOTS_DIR);\n\nvar sessions_middleware = false;\nvar sessions_settings_object = {\n    cookieName: 'session',\n    duration: 7 * 24 * 60 * 60 * 1000, // Default session time is a week\n    activeDuration: 1000 * 60 * 5, // Extend for five minutes if actively used\n    cookie: {\n        httpOnly: true,\n        secure: true\n    }\n}\nfunction session_wrapper_function(req, res, next) {\n    return sessions_middleware(req, res, next);\n}\n\nasync function set_up_api_server(app) {\n    // Check for existing session secret value\n    const session_secret_setting = await Settings.findOne({\n    \twhere: {\n    \t\tkey: constants.session_secret_key\n    \t}\n    });\n\n    if (!session_secret_setting) {\n    \tconsole.error(`No session secret is set, can't start API server (this really shouldn't happen...)!`);\n    \tthrow new Error('NO_SESSION_SECRET_SET');\n    \treturn\n    }\n\n    const updated_session_settings = {\n        ...sessions_settings_object,\n        ...{\n            secret: session_secret_setting.value\n        }\n    };\n    sessions_middleware = sessions(updated_session_settings);\n\n    // Session management\n    app.use(session_wrapper_function);\n\n    // If that's not present, the request should be rejected.\n    app.use(async function(req, res, next) {\n    \t// Must be an API route else CSRF protection doesn't matter\n    \tif(!req.path.startsWith(constants.API_BASE_PATH)) {\n    \t\tnext();\n    \t\treturn\n    \t}\n\n    \t// Check to see if the required CSRF header is set\n    \t// If it's not set, reject the request.\n    \tconst csrf_header_value = req.header(constants.csrf_header_name);\n    \tif(!csrf_header_value) {\n            res.status(401).json({\n                \"success\": false,\n                \"error\": \"No CSRF header specified, request rejected.\",\n                \"code\": \"CSRF_VIOLATION\"\n            }).end();\n    \t\treturn\n    \t}\n\n    \t// Otherwise we're fine to continue\n    \tnext();\n    });\n\n    // Restrict all API routes unless the user is authenticated.\n    app.use(async function(req, res, next) {\n        const AUTHENTICATION_REQUIRED_ROUTES = [\n            constants.API_BASE_PATH + 'payloadfires',\n            constants.API_BASE_PATH + 'collected_pages',\n            constants.API_BASE_PATH + 'settings',\n        ];\n\n        // If the route is not one of the authentication required routes\n        // then we can allow it through.\n        if(!AUTHENTICATION_REQUIRED_ROUTES.includes(req.path)) {\n            next();\n            return;\n        }\n\n    \t// If the user is authenticated, let them pass\n    \tif(req.session.authenticated === true) {\n    \t\tnext();\n    \t\treturn;\n    \t}\n\n    \t// Otherwise, fall to blocking them by default.\n\t    res.status(401).json({\n\t        \"success\": false,\n\t        \"error\": \"You must be authenticated to use this endpoint.\",\n\t        \"code\": \"NOT_AUTHENTICATED\"\n\t    }).end();\n\t\treturn\n    });\n\n    // Serve the front-end\n    app.use('/admin/', express.static(\n    \t'./front-end/dist/',\n    \t{\n    \t\tsetHeaders: function (res, path, stat) {\n    \t\t\tres.set(\"Content-Security-Policy\", \"default-src 'none'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self'; font-src 'self'; connect-src 'self'; prefetch-src 'self'; manifest-src 'self'\");\n    \t\t},\n    \t},\n    ));\n    app.use(favicon('./front-end/dist/favicon.ico'));\n\n    /*\n\t\tEndpoint which returns if the user is logged in or not.\n    */\n    app.get(constants.API_BASE_PATH + 'auth-check', async (req, res) => {\n        res.status(200).json({\n            \"success\": true,\n            \"result\": {\n            \t\"is_authenticated\": (req.session.authenticated == true)\n            }\n        }).end();\n    });\n\n    /*\n    \tAttempt to log into the administrator account\n    */\n    const LoginSchema = {\n        type: 'object',\n        properties: {\n            password: {\n                type: 'string',\n\t\t\t\tminLength: 1,\n\t\t\t\tmaxLength: 72,\n                required: true,\n            },\n        }\n    }\n    app.post(constants.API_BASE_PATH + 'login', validate({ body: LoginSchema }), async (req, res) => {\n\t\tconst admin_user_password_record = await Settings.findOne({\n\t\t\twhere: {\n\t\t\t\tkey: constants.ADMIN_PASSWORD_SETTINGS_KEY\n\t\t\t}\n\t\t});\n\t\tconst admin_password_hash = admin_user_password_record.value;\n\n\t\t// Compare user-provided password against admin password hash\n        const password_matches = await bcrypt.compare(\n            req.body.password,\n            admin_password_hash,\n        );\n\n        if (!password_matches) {\n            res.status(200).json({\n                \"success\": false,\n                \"error\": \"Incorrect password, please try again.\",\n                \"code\": \"INVALID_CREDENTIALS\"\n            }).end();\n            return\n        }\n\n        // Set session data to set user as authenticated\n        req.session.authenticated = true;\n\n        res.status(200).json({\n            \"success\": true,\n            \"result\": {}\n        }).end();\n    });\n\n    /*\n\t\tDeletes a given XSS payload(s)\n    */\n    const DeletePayloadFiresSchema = {\n        type: 'object',\n        properties: {\n            ids: {\n                type: 'array',\n                required: true,\n                items: {\n                \ttype: 'string'\n                }\n            }\n        }\n    }\n    app.delete(constants.API_BASE_PATH + 'payloadfires', validate({ body: DeletePayloadFiresSchema }), async (req, res) => {\n    \tconst ids_to_delete = req.body.ids;\n\n    \t// Pull the corresponding screenshot_ids from the DB so\n    \t// we can delete all the payload fire images as well as\n    \t// the payload records themselves.\n    \tconst screenshot_id_records = await PayloadFireResults.findAll({\n    \t\twhere: {\n    \t\t\tid: {\n    \t\t\t\t[Op.in]: ids_to_delete\n    \t\t\t}\n    \t\t},\n    \t\tattributes: ['id', 'screenshot_id']\n    \t});\n    \tconst screenshots_to_delete = screenshot_id_records.map(payload => {\n    \t\treturn `${SCREENSHOTS_DIR}/${payload.screenshot_id}.png.gz`;\n    \t});\n    \tawait Promise.all(screenshots_to_delete.map(screenshot_path => {\n    \t\treturn asyncfs.unlink(screenshot_path);\n    \t}));\n    \tconst payload_fires = await PayloadFireResults.destroy({\n    \t\twhere: {\n    \t\t\tid: {\n    \t\t\t\t[Op.in]: ids_to_delete\n    \t\t\t}\n    \t\t}\n    \t});\n\n        res.status(200).json({\n            'success': true,\n            'result': {}\n        }).end();\n    });\n\n    /*\n\t\tReturns the list of XSS payload fire results.\n    */\n    const ListPayloadFiresSchema = {\n        type: 'object',\n        properties: {\n            page: {\n                type: 'string',\n                required: false,\n                default: '0',\n                pattern: '[0-9]+',\n            },\n            limit: {\n                type: 'string',\n                required: false,\n                default: '10',\n                pattern: '[0-9]+',\n            },\n        }\n    }\n    app.get(constants.API_BASE_PATH + 'payloadfires', validate({ query: ListPayloadFiresSchema }), async (req, res) => {\n    \tconst page = (parseInt(req.query.page) - 1);\n    \tconst limit = parseInt(req.query.limit);\n    \tconst offset = (page * limit);\n    \tconst payload_fires = await PayloadFireResults.findAndCountAll({\n    \t\tlimit: limit,\n    \t\toffset: (page * limit),\n    \t\torder: [['createdAt', 'DESC']],\n    \t});\n\n        res.status(200).json({\n            'success': true,\n            'result': {\n            \t'payload_fires': payload_fires.rows,\n            \t'total': payload_fires.count\n            }\n        }).end();\n    });\n\n    /*\n\t\tReturns the list of collected pages\n    */\n    const ListCollectedPagesSchema = {\n        type: 'object',\n        properties: {\n            page: {\n                type: 'string',\n                required: false,\n                default: '0',\n                pattern: '[0-9]+',\n            },\n            limit: {\n                type: 'string',\n                required: false,\n                default: '10',\n                pattern: '[0-9]+',\n            },\n        }\n    }\n    app.get(constants.API_BASE_PATH + 'collected_pages', validate({ query: ListCollectedPagesSchema }), async (req, res) => {\n    \tconst page = (parseInt(req.query.page) - 1);\n    \tconst limit = parseInt(req.query.limit);\n    \tconst offset = (page * limit);\n    \tconst collected_pages = await CollectedPages.findAndCountAll({\n    \t\tlimit: limit,\n    \t\toffset: (page * limit),\n    \t\torder: [['createdAt', 'DESC']],\n    \t});\n\n        res.status(200).json({\n            'success': true,\n            'result': {\n            \t'collected_pages': collected_pages.rows,\n            \t'total': collected_pages.count\n            }\n        }).end();\n    });\n\n    /*\n\t\tDeletes a given collected page(s)\n    */\n    const DeleteCollectedPagesSchema = {\n        type: 'object',\n        properties: {\n            ids: {\n                type: 'array',\n                required: true,\n                items: {\n                \ttype: 'string'\n                }\n            }\n        }\n    }\n    app.delete(constants.API_BASE_PATH + 'collected_pages', validate({ body: DeleteCollectedPagesSchema }), async (req, res) => {\n    \tconst ids_to_delete = req.body.ids;\n    \tconst payload_fires = await CollectedPages.destroy({\n    \t\twhere: {\n    \t\t\tid: {\n    \t\t\t\t[Op.in]: ids_to_delete\n    \t\t\t}\n    \t\t}\n    \t});\n\n        res.status(200).json({\n            'success': true,\n            'result': {}\n        }).end();\n    });\n\n    /*\n    \tCorrelated injections API endpoint.\n    \tAuthentication is custom for this endpoint\n    \t(Uses the correlation API key)\n    */\n    const RecordCorrelatedRequestSchema = {\n        type: 'object',\n        properties: {\n            request: {\n                type: 'string',\n                required: true,\n            },\n            owner_correlation_key: {\n                type: 'string',\n                required: true,\n            },\n            injection_key: {\n                type: 'string',\n                required: true,\n            },\n        }\n    }\n    app.post(constants.API_BASE_PATH + 'record_injection', validate({ body: RecordCorrelatedRequestSchema }), async (req, res) => {\n\t\tconst correlation_key_record = await Settings.findOne({\n\t\t\twhere: {\n\t\t\t\tkey: constants.CORRELATION_API_SECRET_SETTINGS_KEY\n\t\t\t}\n\t\t});\n\n        if (!safeCompare(correlation_key_record.value, req.body.owner_correlation_key)) {\n            res.status(200).json({\n                \"success\": false,\n                \"error\": \"Invalid authentication provided. Please provide a proper correlation API key.\",\n                \"code\": \"INVALID_CREDENTIALS\"\n            }).end();\n            return\n        }\n\n        try {\n\t\t\t// Create injection correlation record\n\t\t\tawait InjectionRequests.create({\n\t\t\t\tid: uuid.v4(),\n\t\t\t\trequest: req.body.request,\n\t\t\t\tinjection_key: req.body.injection_key,\n\t\t\t});\n        } catch (e) {\n        \tif(e.name === 'SequelizeUniqueConstraintError') {\n\t            res.status(200).json({\n\t                \"success\": false,\n\t                \"error\": \"That injection key has already been used previously.\",\n\t                \"code\": \"EXISTING_INJECTION_KEY\"\n\t            }).end();\n\t            return\n        \t}\n            res.status(200).json({\n                \"success\": false,\n                \"error\": \"An unexpected error occurred.\",\n                \"code\": e.name.toString(),\n            }).end();\n            return\n        }\n\n        res.status(200).json({\n            \"success\": true,\n            \"message\": \"Injection request successfully recorded!\"\n        }).end();\n    });\n\n    /*\n\t\tReturns current settings values for the UI\n    */\n    app.get(constants.API_BASE_PATH + 'settings', async (req, res) => {\n    \tconst settings_to_retrieve = [\n    \t\t{\n    \t\t\tkey: constants.CORRELATION_API_SECRET_SETTINGS_KEY,\n    \t\t\treturn_key: 'correlation_api_key',\n    \t\t\tdefault: '',\n    \t\t\tformatter: false,\n    \t\t},\n    \t\t{\n    \t\t\tkey: constants.CHAINLOAD_URI_SETTINGS_KEY,\n    \t\t\treturn_key: 'chainload_uri',\n    \t\t\tdefault: '',\n    \t\t\tformatter: false,\n    \t\t},\n    \t\t{\n    \t\t\tkey: constants.PAGES_TO_COLLECT_SETTINGS_KEY,\n    \t\t\treturn_key: 'pages_to_collect',\n    \t\t\tdefault: [],\n    \t\t\tformatter: ((value) => {\n    \t\t\t\treturn JSON.parse(value);\n    \t\t\t}),\n    \t\t},\n            {\n                key: constants.SEND_ALERT_EMAILS_KEY,\n                return_key: 'send_alert_emails',\n                default: true,\n                formatter: ((value) => {\n                    return JSON.parse(value);\n                }),\n            },\n    \t];\n\n    \tlet result = {};\n    \tlet database_promises = settings_to_retrieve.map(async settings_value_metadata => {\n\t\t\tconst db_record = await Settings.findOne({\n\t\t\t\twhere: {\n\t\t\t\t\tkey: settings_value_metadata.key\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconst formatter_function = settings_value_metadata.formatter ? settings_value_metadata.formatter : (value) => value;\n\t\t\tresult[settings_value_metadata.return_key] = db_record ? formatter_function(db_record.value) : settings_value_metadata.default;\n    \t});\n    \tawait Promise.all(database_promises);\n\n        res.status(200).json({\n            'success': true,\n            result\n        }).end();\n    });\n\n    /*\n\t\tUpdates a specific config for the service\n    */\n    const UpdateConfigSchema = {\n        type: 'object',\n        properties: {\n            password: {\n                type: 'string',\n                required: false,\n            },\n            correlation_api_key: {\n                type: 'boolean',\n                required: false,\n            },\n            chainload_uri: {\n                type: 'string',\n                required: false,\n            },\n            send_alert_emails: {\n                type: 'boolean',\n                required: false,\n            },\n            revoke_all_sessions: {\n                type: 'boolean',\n                required: false,\n            },\n            pages_to_collect: {\n                type: 'array',\n                required: false,\n                items: {\n                    type: 'string'\n                }\n            }\n        }\n    }\n    app.put(constants.API_BASE_PATH + 'settings', validate({ body: UpdateConfigSchema }), async (req, res) => {\n        if(req.body.password) {\n    \t\t// Pull password record\n\t\t\tconst admin_user_password = await Settings.findOne({\n\t\t\t\twhere: {\n\t\t\t\t\tkey: constants.ADMIN_PASSWORD_SETTINGS_KEY\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Update password\n\t\t\tconst bcrypt_hash = await get_hashed_password(req.body.password);\n\t\t\tadmin_user_password.value = bcrypt_hash;\n\t\t\tawait admin_user_password.save();\n    \t}\n\n        if(req.body.correlation_api_key === true) {\n            const correlation_api_key = get_secure_random_string(64);\n            await update_settings_value(\n                constants.CORRELATION_API_SECRET_SETTINGS_KEY,\n                correlation_api_key\n            );\n        }\n\n        // Intentionally no URL validation incase people want to do\n        // data: for inline extra JS.\n        if(req.body.chainload_uri) {\n            await update_settings_value(\n                constants.CHAINLOAD_URI_SETTINGS_KEY,\n                req.body.chainload_uri\n            );\n        }\n\n        if(req.body.send_alert_emails !== undefined) {\n            await update_settings_value(\n                constants.SEND_ALERT_EMAILS_KEY,\n                req.body.send_alert_emails.toString()\n            );\n        }\n\n        // Immediately rotate session secret and revoke all sessions.\n        if(req.body.revoke_all_sessions !== undefined) {\n            const new_session_secret = get_secure_random_string(64);\n            // Update session secret in database\n            const session_secret_setting = await Settings.findOne({\n                where: {\n                    key: constants.session_secret_key\n                }\n            });\n            session_secret_setting.value = new_session_secret;\n            await session_secret_setting.save();\n\n            // We do this by patching the sessions middleware at runtime\n            // to utilize a new HMAC secret so all previous sessions are revoked.\n            const updated_session_settings = {\n                ...sessions_settings_object,\n                ...{\n                    secret: session_secret_setting.value\n                }\n            };\n            sessions_middleware = sessions(updated_session_settings);\n        }\n\n        if(req.body.pages_to_collect) {\n            await update_settings_value(\n                constants.PAGES_TO_COLLECT_SETTINGS_KEY,\n                JSON.stringify(req.body.pages_to_collect)\n            );\n        }\n\n        res.status(200).json({\n            'success': true,\n            'result': {}\n        }).end();\n    });\n}\n\nmodule.exports = {\n    set_up_api_server\n};"], "fixing_code": ["const bcrypt = require('bcrypt');\nconst express = require('express');\nconst cors = require('cors');\nconst path = require('path');\nconst uuid = require('uuid');\nconst asyncfs = require('fs').promises;\nconst sessions = require('@nvanexan/node-client-sessions');\nconst favicon = require('serve-favicon');\n\nconst database = require('./database.js');\nconst safeCompare = require('safe-compare');\nconst { Op } = require(\"sequelize\");\nconst sequelize = database.sequelize;\nconst Settings = database.Settings;\nconst PayloadFireResults = database.PayloadFireResults;\nconst CollectedPages = database.CollectedPages;\nconst InjectionRequests = database.InjectionRequests;\nconst update_settings_value = database.update_settings_value;\nconst constants = require('./constants.js');\nconst validate = require('express-jsonschema').validate;\nconst get_hashed_password = require('./utils.js').get_hashed_password;\nconst get_secure_random_string = require('./utils.js').get_secure_random_string;\n\nconst SCREENSHOTS_DIR = path.resolve(process.env.SCREENSHOTS_DIR);\n\nvar sessions_middleware = false;\nvar sessions_settings_object = {\n    cookieName: 'session',\n    duration: 7 * 24 * 60 * 60 * 1000, // Default session time is a week\n    activeDuration: 1000 * 60 * 5, // Extend for five minutes if actively used\n    cookie: {\n        httpOnly: true,\n        secure: true\n    }\n}\nfunction session_wrapper_function(req, res, next) {\n    return sessions_middleware(req, res, next);\n}\n\nasync function set_up_api_server(app) {\n    // Check for existing session secret value\n    const session_secret_setting = await Settings.findOne({\n    \twhere: {\n    \t\tkey: constants.session_secret_key\n    \t}\n    });\n\n    if (!session_secret_setting) {\n    \tconsole.error(`No session secret is set, can't start API server (this really shouldn't happen...)!`);\n    \tthrow new Error('NO_SESSION_SECRET_SET');\n    \treturn\n    }\n\n    const updated_session_settings = {\n        ...sessions_settings_object,\n        ...{\n            secret: session_secret_setting.value\n        }\n    };\n    sessions_middleware = sessions(updated_session_settings);\n\n    // Session management\n    app.use(session_wrapper_function);\n\n    // If that's not present, the request should be rejected.\n    app.use(async function(req, res, next) {\n    \t// Must be an API route else CSRF protection doesn't matter\n    \tif(!req.path.startsWith(constants.API_BASE_PATH)) {\n    \t\tnext();\n    \t\treturn\n    \t}\n\n    \t// Check to see if the required CSRF header is set\n    \t// If it's not set, reject the request.\n    \tconst csrf_header_value = req.header(constants.csrf_header_name);\n    \tif(!csrf_header_value) {\n            res.status(401).json({\n                \"success\": false,\n                \"error\": \"No CSRF header specified, request rejected.\",\n                \"code\": \"CSRF_VIOLATION\"\n            }).end();\n    \t\treturn\n    \t}\n\n    \t// Otherwise we're fine to continue\n    \tnext();\n    });\n\n    // Restrict all API routes unless the user is authenticated.\n    app.use(async function(req, res, next) {\n        const AUTHENTICATION_REQUIRED_ROUTES = [\n            constants.API_BASE_PATH + 'payloadfires',\n            constants.API_BASE_PATH + 'collected_pages',\n            constants.API_BASE_PATH + 'settings',\n        ];\n\n        // Check if the path being accessed required authentication\n        var requires_authentication = false;\n        AUTHENTICATION_REQUIRED_ROUTES.map(authenticated_route => {\n            if(req.path.toLowerCase().startsWith(authenticated_route)) {\n                requires_authentication = true;\n            }\n        });\n\n        // If the route is not one of the authentication required routes\n        // then we can allow it through.\n        if(!requires_authentication) {\n            next();\n            return;\n        }\n\n    \t// If the user is authenticated, let them pass\n    \tif(req.session.authenticated === true) {\n    \t\tnext();\n    \t\treturn;\n    \t}\n\n    \t// Otherwise, fall to blocking them by default.\n\t    res.status(401).json({\n\t        \"success\": false,\n\t        \"error\": \"You must be authenticated to use this endpoint.\",\n\t        \"code\": \"NOT_AUTHENTICATED\"\n\t    }).end();\n\t\treturn\n    });\n\n    // Serve the front-end\n    app.use('/admin/', express.static(\n    \t'./front-end/dist/',\n    \t{\n    \t\tsetHeaders: function (res, path, stat) {\n    \t\t\tres.set(\"Content-Security-Policy\", \"default-src 'none'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self'; font-src 'self'; connect-src 'self'; prefetch-src 'self'; manifest-src 'self'\");\n    \t\t},\n    \t},\n    ));\n    app.use(favicon('./front-end/dist/favicon.ico'));\n\n    /*\n\t\tEndpoint which returns if the user is logged in or not.\n    */\n    app.get(constants.API_BASE_PATH + 'auth-check', async (req, res) => {\n        res.status(200).json({\n            \"success\": true,\n            \"result\": {\n            \t\"is_authenticated\": (req.session.authenticated == true)\n            }\n        }).end();\n    });\n\n    /*\n    \tAttempt to log into the administrator account\n    */\n    const LoginSchema = {\n        type: 'object',\n        properties: {\n            password: {\n                type: 'string',\n\t\t\t\tminLength: 1,\n\t\t\t\tmaxLength: 72,\n                required: true,\n            },\n        }\n    }\n    app.post(constants.API_BASE_PATH + 'login', validate({ body: LoginSchema }), async (req, res) => {\n\t\tconst admin_user_password_record = await Settings.findOne({\n\t\t\twhere: {\n\t\t\t\tkey: constants.ADMIN_PASSWORD_SETTINGS_KEY\n\t\t\t}\n\t\t});\n\t\tconst admin_password_hash = admin_user_password_record.value;\n\n\t\t// Compare user-provided password against admin password hash\n        const password_matches = await bcrypt.compare(\n            req.body.password,\n            admin_password_hash,\n        );\n\n        if (!password_matches) {\n            res.status(200).json({\n                \"success\": false,\n                \"error\": \"Incorrect password, please try again.\",\n                \"code\": \"INVALID_CREDENTIALS\"\n            }).end();\n            return\n        }\n\n        // Set session data to set user as authenticated\n        req.session.authenticated = true;\n\n        res.status(200).json({\n            \"success\": true,\n            \"result\": {}\n        }).end();\n    });\n\n    /*\n\t\tDeletes a given XSS payload(s)\n    */\n    const DeletePayloadFiresSchema = {\n        type: 'object',\n        properties: {\n            ids: {\n                type: 'array',\n                required: true,\n                items: {\n                \ttype: 'string'\n                }\n            }\n        }\n    }\n    app.delete(constants.API_BASE_PATH + 'payloadfires', validate({ body: DeletePayloadFiresSchema }), async (req, res) => {\n    \tconst ids_to_delete = req.body.ids;\n\n    \t// Pull the corresponding screenshot_ids from the DB so\n    \t// we can delete all the payload fire images as well as\n    \t// the payload records themselves.\n    \tconst screenshot_id_records = await PayloadFireResults.findAll({\n    \t\twhere: {\n    \t\t\tid: {\n    \t\t\t\t[Op.in]: ids_to_delete\n    \t\t\t}\n    \t\t},\n    \t\tattributes: ['id', 'screenshot_id']\n    \t});\n    \tconst screenshots_to_delete = screenshot_id_records.map(payload => {\n    \t\treturn `${SCREENSHOTS_DIR}/${payload.screenshot_id}.png.gz`;\n    \t});\n    \tawait Promise.all(screenshots_to_delete.map(screenshot_path => {\n    \t\treturn asyncfs.unlink(screenshot_path);\n    \t}));\n    \tconst payload_fires = await PayloadFireResults.destroy({\n    \t\twhere: {\n    \t\t\tid: {\n    \t\t\t\t[Op.in]: ids_to_delete\n    \t\t\t}\n    \t\t}\n    \t});\n\n        res.status(200).json({\n            'success': true,\n            'result': {}\n        }).end();\n    });\n\n    /*\n\t\tReturns the list of XSS payload fire results.\n    */\n    const ListPayloadFiresSchema = {\n        type: 'object',\n        properties: {\n            page: {\n                type: 'string',\n                required: false,\n                default: '0',\n                pattern: '[0-9]+',\n            },\n            limit: {\n                type: 'string',\n                required: false,\n                default: '10',\n                pattern: '[0-9]+',\n            },\n        }\n    }\n    app.get(constants.API_BASE_PATH + 'payloadfires', validate({ query: ListPayloadFiresSchema }), async (req, res) => {\n    \tconst page = (parseInt(req.query.page) - 1);\n    \tconst limit = parseInt(req.query.limit);\n    \tconst offset = (page * limit);\n    \tconst payload_fires = await PayloadFireResults.findAndCountAll({\n    \t\tlimit: limit,\n    \t\toffset: (page * limit),\n    \t\torder: [['createdAt', 'DESC']],\n    \t});\n\n        res.status(200).json({\n            'success': true,\n            'result': {\n            \t'payload_fires': payload_fires.rows,\n            \t'total': payload_fires.count\n            }\n        }).end();\n    });\n\n    /*\n\t\tReturns the list of collected pages\n    */\n    const ListCollectedPagesSchema = {\n        type: 'object',\n        properties: {\n            page: {\n                type: 'string',\n                required: false,\n                default: '0',\n                pattern: '[0-9]+',\n            },\n            limit: {\n                type: 'string',\n                required: false,\n                default: '10',\n                pattern: '[0-9]+',\n            },\n        }\n    }\n    app.get(constants.API_BASE_PATH + 'collected_pages', validate({ query: ListCollectedPagesSchema }), async (req, res) => {\n    \tconst page = (parseInt(req.query.page) - 1);\n    \tconst limit = parseInt(req.query.limit);\n    \tconst offset = (page * limit);\n    \tconst collected_pages = await CollectedPages.findAndCountAll({\n    \t\tlimit: limit,\n    \t\toffset: (page * limit),\n    \t\torder: [['createdAt', 'DESC']],\n    \t});\n\n        res.status(200).json({\n            'success': true,\n            'result': {\n            \t'collected_pages': collected_pages.rows,\n            \t'total': collected_pages.count\n            }\n        }).end();\n    });\n\n    /*\n\t\tDeletes a given collected page(s)\n    */\n    const DeleteCollectedPagesSchema = {\n        type: 'object',\n        properties: {\n            ids: {\n                type: 'array',\n                required: true,\n                items: {\n                \ttype: 'string'\n                }\n            }\n        }\n    }\n    app.delete(constants.API_BASE_PATH + 'collected_pages', validate({ body: DeleteCollectedPagesSchema }), async (req, res) => {\n    \tconst ids_to_delete = req.body.ids;\n    \tconst payload_fires = await CollectedPages.destroy({\n    \t\twhere: {\n    \t\t\tid: {\n    \t\t\t\t[Op.in]: ids_to_delete\n    \t\t\t}\n    \t\t}\n    \t});\n\n        res.status(200).json({\n            'success': true,\n            'result': {}\n        }).end();\n    });\n\n    /*\n    \tCorrelated injections API endpoint.\n    \tAuthentication is custom for this endpoint\n    \t(Uses the correlation API key)\n    */\n    const RecordCorrelatedRequestSchema = {\n        type: 'object',\n        properties: {\n            request: {\n                type: 'string',\n                required: true,\n            },\n            owner_correlation_key: {\n                type: 'string',\n                required: true,\n            },\n            injection_key: {\n                type: 'string',\n                required: true,\n            },\n        }\n    }\n    app.post(constants.API_BASE_PATH + 'record_injection', validate({ body: RecordCorrelatedRequestSchema }), async (req, res) => {\n\t\tconst correlation_key_record = await Settings.findOne({\n\t\t\twhere: {\n\t\t\t\tkey: constants.CORRELATION_API_SECRET_SETTINGS_KEY\n\t\t\t}\n\t\t});\n\n        if (!safeCompare(correlation_key_record.value, req.body.owner_correlation_key)) {\n            res.status(200).json({\n                \"success\": false,\n                \"error\": \"Invalid authentication provided. Please provide a proper correlation API key.\",\n                \"code\": \"INVALID_CREDENTIALS\"\n            }).end();\n            return\n        }\n\n        try {\n\t\t\t// Create injection correlation record\n\t\t\tawait InjectionRequests.create({\n\t\t\t\tid: uuid.v4(),\n\t\t\t\trequest: req.body.request,\n\t\t\t\tinjection_key: req.body.injection_key,\n\t\t\t});\n        } catch (e) {\n        \tif(e.name === 'SequelizeUniqueConstraintError') {\n\t            res.status(200).json({\n\t                \"success\": false,\n\t                \"error\": \"That injection key has already been used previously.\",\n\t                \"code\": \"EXISTING_INJECTION_KEY\"\n\t            }).end();\n\t            return\n        \t}\n            res.status(200).json({\n                \"success\": false,\n                \"error\": \"An unexpected error occurred.\",\n                \"code\": e.name.toString(),\n            }).end();\n            return\n        }\n\n        res.status(200).json({\n            \"success\": true,\n            \"message\": \"Injection request successfully recorded!\"\n        }).end();\n    });\n\n    /*\n\t\tReturns current settings values for the UI\n    */\n    app.get(constants.API_BASE_PATH + 'settings', async (req, res) => {\n    \tconst settings_to_retrieve = [\n    \t\t{\n    \t\t\tkey: constants.CORRELATION_API_SECRET_SETTINGS_KEY,\n    \t\t\treturn_key: 'correlation_api_key',\n    \t\t\tdefault: '',\n    \t\t\tformatter: false,\n    \t\t},\n    \t\t{\n    \t\t\tkey: constants.CHAINLOAD_URI_SETTINGS_KEY,\n    \t\t\treturn_key: 'chainload_uri',\n    \t\t\tdefault: '',\n    \t\t\tformatter: false,\n    \t\t},\n    \t\t{\n    \t\t\tkey: constants.PAGES_TO_COLLECT_SETTINGS_KEY,\n    \t\t\treturn_key: 'pages_to_collect',\n    \t\t\tdefault: [],\n    \t\t\tformatter: ((value) => {\n    \t\t\t\treturn JSON.parse(value);\n    \t\t\t}),\n    \t\t},\n            {\n                key: constants.SEND_ALERT_EMAILS_KEY,\n                return_key: 'send_alert_emails',\n                default: true,\n                formatter: ((value) => {\n                    return JSON.parse(value);\n                }),\n            },\n    \t];\n\n    \tlet result = {};\n    \tlet database_promises = settings_to_retrieve.map(async settings_value_metadata => {\n\t\t\tconst db_record = await Settings.findOne({\n\t\t\t\twhere: {\n\t\t\t\t\tkey: settings_value_metadata.key\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconst formatter_function = settings_value_metadata.formatter ? settings_value_metadata.formatter : (value) => value;\n\t\t\tresult[settings_value_metadata.return_key] = db_record ? formatter_function(db_record.value) : settings_value_metadata.default;\n    \t});\n    \tawait Promise.all(database_promises);\n\n        res.status(200).json({\n            'success': true,\n            result\n        }).end();\n    });\n\n    /*\n\t\tUpdates a specific config for the service\n    */\n    const UpdateConfigSchema = {\n        type: 'object',\n        properties: {\n            password: {\n                type: 'string',\n                required: false,\n            },\n            correlation_api_key: {\n                type: 'boolean',\n                required: false,\n            },\n            chainload_uri: {\n                type: 'string',\n                required: false,\n            },\n            send_alert_emails: {\n                type: 'boolean',\n                required: false,\n            },\n            revoke_all_sessions: {\n                type: 'boolean',\n                required: false,\n            },\n            pages_to_collect: {\n                type: 'array',\n                required: false,\n                items: {\n                    type: 'string'\n                }\n            }\n        }\n    }\n    app.put(constants.API_BASE_PATH + 'settings', validate({ body: UpdateConfigSchema }), async (req, res) => {\n        if(req.body.password) {\n    \t\t// Pull password record\n\t\t\tconst admin_user_password = await Settings.findOne({\n\t\t\t\twhere: {\n\t\t\t\t\tkey: constants.ADMIN_PASSWORD_SETTINGS_KEY\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// Update password\n\t\t\tconst bcrypt_hash = await get_hashed_password(req.body.password);\n\t\t\tadmin_user_password.value = bcrypt_hash;\n\t\t\tawait admin_user_password.save();\n    \t}\n\n        if(req.body.correlation_api_key === true) {\n            const correlation_api_key = get_secure_random_string(64);\n            await update_settings_value(\n                constants.CORRELATION_API_SECRET_SETTINGS_KEY,\n                correlation_api_key\n            );\n        }\n\n        // Intentionally no URL validation incase people want to do\n        // data: for inline extra JS.\n        if(req.body.chainload_uri) {\n            await update_settings_value(\n                constants.CHAINLOAD_URI_SETTINGS_KEY,\n                req.body.chainload_uri\n            );\n        }\n\n        if(req.body.send_alert_emails !== undefined) {\n            await update_settings_value(\n                constants.SEND_ALERT_EMAILS_KEY,\n                req.body.send_alert_emails.toString()\n            );\n        }\n\n        // Immediately rotate session secret and revoke all sessions.\n        if(req.body.revoke_all_sessions !== undefined) {\n            const new_session_secret = get_secure_random_string(64);\n            // Update session secret in database\n            const session_secret_setting = await Settings.findOne({\n                where: {\n                    key: constants.session_secret_key\n                }\n            });\n            session_secret_setting.value = new_session_secret;\n            await session_secret_setting.save();\n\n            // We do this by patching the sessions middleware at runtime\n            // to utilize a new HMAC secret so all previous sessions are revoked.\n            const updated_session_settings = {\n                ...sessions_settings_object,\n                ...{\n                    secret: session_secret_setting.value\n                }\n            };\n            sessions_middleware = sessions(updated_session_settings);\n        }\n\n        if(req.body.pages_to_collect) {\n            await update_settings_value(\n                constants.PAGES_TO_COLLECT_SETTINGS_KEY,\n                JSON.stringify(req.body.pages_to_collect)\n            );\n        }\n\n        res.status(200).json({\n            'success': true,\n            'result': {}\n        }).end();\n    });\n}\n\nmodule.exports = {\n    set_up_api_server\n};"], "filenames": ["api.js"], "buggy_code_start_loc": [96], "buggy_code_end_loc": [100], "fixing_code_start_loc": [97], "fixing_code_end_loc": [108], "type": "CWE-287", "message": "XSS Hunter Express before 2021-09-17 does not properly enforce authentication requirements for paths.", "other": {"cve": {"id": "CVE-2021-41317", "sourceIdentifier": "cve@mitre.org", "published": "2021-09-17T16:15:07.660", "lastModified": "2021-09-28T16:01:14.137", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "XSS Hunter Express before 2021-09-17 does not properly enforce authentication requirements for paths."}, {"lang": "es", "value": "XSS Hunter Express versiones anteriores al 17-09-2021, no aplica apropiadamente los requisitos de autenticaci\u00f3n para las rutas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xss_hunter_express_project:xss_hunter_express:*:*:*:*:*:*:*:*", "versionEndExcluding": "2021-09-17", "matchCriteriaId": "C22BC92C-D5A8-4DE9-BDCD-F7C0463D8543"}]}]}], "references": [{"url": "https://docs.google.com/document/d/12rq4YIFZLSmZlEsq7d7hYCI1qO5xyIxA1Wrs1m4y9-4/preview", "source": "cve@mitre.org", "tags": ["Mitigation", "Third Party Advisory"]}, {"url": "https://github.com/mandatoryprogrammer/xsshunter-express/commit/56bb44ed9024849f64173f71583ecb7d873baba0", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuln.ryotak.me/advisories/57", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mandatoryprogrammer/xsshunter-express/commit/56bb44ed9024849f64173f71583ecb7d873baba0"}}