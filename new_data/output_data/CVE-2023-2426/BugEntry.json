{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * quickfix.c: functions for quickfix mode, using a file with error messages\n */\n\n#include \"vim.h\"\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n\nstruct dir_stack_T\n{\n    struct dir_stack_T\t*next;\n    char_u\t\t*dirname;\n};\n\n/*\n * For each error the next struct is allocated and linked in a list.\n */\ntypedef struct qfline_S qfline_T;\nstruct qfline_S\n{\n    qfline_T\t*qf_next;\t// pointer to next error in the list\n    qfline_T\t*qf_prev;\t// pointer to previous error in the list\n    linenr_T\tqf_lnum;\t// line number where the error occurred\n    linenr_T\tqf_end_lnum;\t// line number when the error has range or zero\n    int\t\tqf_fnum;\t// file number for the line\n    int\t\tqf_col;\t\t// column where the error occurred\n    int\t\tqf_end_col;\t// column when the error has range or zero\n    int\t\tqf_nr;\t\t// error number\n    char_u\t*qf_module;\t// module name for this error\n    char_u\t*qf_pattern;\t// search pattern for the error\n    char_u\t*qf_text;\t// description of the error\n    char_u\tqf_viscol;\t// set to TRUE if qf_col and qf_end_col is\n\t\t\t\t// screen column\n    char_u\tqf_cleared;\t// set to TRUE if line has been deleted\n    char_u\tqf_type;\t// type of the error (mostly 'E'); 1 for\n\t\t\t\t// :helpgrep\n    char_u\tqf_valid;\t// valid error message detected\n};\n\n/*\n * There is a stack of error lists.\n */\n#define LISTCOUNT   10\n#define INVALID_QFIDX (-1)\n#define INVALID_QFBUFNR (0)\n\n/*\n * Quickfix list type.\n */\ntypedef enum\n{\n    QFLT_QUICKFIX, // Quickfix list - global list\n    QFLT_LOCATION, // Location list - per window list\n    QFLT_INTERNAL  // Internal - Temporary list used by getqflist()/getloclist()\n} qfltype_T;\n\n/*\n * Quickfix/Location list definition\n * Contains a list of entries (qfline_T). qf_start points to the first entry\n * and qf_last points to the last entry. qf_count contains the list size.\n *\n * Usually the list contains one or more entries. But an empty list can be\n * created using setqflist()/setloclist() with a title and/or user context\n * information and entries can be added later using setqflist()/setloclist().\n */\ntypedef struct qf_list_S\n{\n    int_u\tqf_id;\t\t// Unique identifier for this list\n    qfltype_T\tqfl_type;\n    qfline_T\t*qf_start;\t// pointer to the first error\n    qfline_T\t*qf_last;\t// pointer to the last error\n    qfline_T\t*qf_ptr;\t// pointer to the current error\n    int\t\tqf_count;\t// number of errors (0 means empty list)\n    int\t\tqf_index;\t// current index in the error list\n    int\t\tqf_nonevalid;\t// TRUE if not a single valid entry found\n    char_u\t*qf_title;\t// title derived from the command that created\n\t\t\t\t// the error list or set by setqflist\n    typval_T\t*qf_ctx;\t// context set by setqflist/setloclist\n    callback_T  qf_qftf_cb;\t// 'quickfixtextfunc' callback function\n\n    struct dir_stack_T\t*qf_dir_stack;\n    char_u\t\t*qf_directory;\n    struct dir_stack_T\t*qf_file_stack;\n    char_u\t\t*qf_currfile;\n    int\t\t\tqf_multiline;\n    int\t\t\tqf_multiignore;\n    int\t\t\tqf_multiscan;\n    long\t\tqf_changedtick;\n} qf_list_T;\n\n/*\n * Quickfix/Location list stack definition\n * Contains a list of quickfix/location lists (qf_list_T)\n */\nstruct qf_info_S\n{\n    // Count of references to this list. Used only for location lists.\n    // When a location list window reference this list, qf_refcount\n    // will be 2. Otherwise, qf_refcount will be 1. When qf_refcount\n    // reaches 0, the list is freed.\n    int\t\tqf_refcount;\n    int\t\tqf_listcount;\t    // current number of lists\n    int\t\tqf_curlist;\t    // current error list\n    qf_list_T\tqf_lists[LISTCOUNT];\n    qfltype_T\tqfl_type;\t    // type of list\n    int\t\tqf_bufnr;\t    // quickfix window buffer number\n};\n\nstatic qf_info_T ql_info;\t// global quickfix list\nstatic int_u last_qf_id = 0;\t// Last used quickfix list id\n\n#define FMT_PATTERNS 13\t\t// maximum number of % recognized\n\n/*\n * Structure used to hold the info of one part of 'errorformat'\n */\ntypedef struct efm_S efm_T;\nstruct efm_S\n{\n    regprog_T\t    *prog;\t// pre-formatted part of 'errorformat'\n    efm_T\t    *next;\t// pointer to next (NULL if last)\n    char_u\t    addr[FMT_PATTERNS]; // indices of used % patterns\n    char_u\t    prefix;\t// prefix of this format line:\n\t\t\t\t//   'D' enter directory\n\t\t\t\t//   'X' leave directory\n\t\t\t\t//   'A' start of multi-line message\n\t\t\t\t//   'E' error message\n\t\t\t\t//   'W' warning message\n\t\t\t\t//   'I' informational message\n\t\t\t\t//   'N' note message\n\t\t\t\t//   'C' continuation line\n\t\t\t\t//   'Z' end of multi-line message\n\t\t\t\t//   'G' general, unspecific message\n\t\t\t\t//   'P' push file (partial) message\n\t\t\t\t//   'Q' pop/quit file (partial) message\n\t\t\t\t//   'O' overread (partial) message\n    char_u\t    flags;\t// additional flags given in prefix\n\t\t\t\t//   '-' do not include this line\n\t\t\t\t//   '+' include whole line in message\n    int\t\t    conthere;\t// %> used\n};\n\n// List of location lists to be deleted.\n// Used to delay the deletion of locations lists by autocmds.\ntypedef struct qf_delq_S\n{\n    struct qf_delq_S\t*next;\n    qf_info_T\t\t*qi;\n} qf_delq_T;\nstatic qf_delq_T *qf_delq_head = NULL;\n\n// Counter to prevent autocmds from freeing up location lists when they are\n// still being used.\nstatic int\tquickfix_busy = 0;\n\nstatic efm_T\t*fmt_start = NULL; // cached across qf_parse_line() calls\n\n// callback function for 'quickfixtextfunc'\nstatic callback_T qftf_cb;\n\nstatic void\tqf_new_list(qf_info_T *qi, char_u *qf_title);\nstatic int\tqf_add_entry(qf_list_T *qfl, char_u *dir, char_u *fname, char_u *module, int bufnum, char_u *mesg, long lnum, long end_lnum, int col, int end_col, int vis_col, char_u *pattern, int nr, int type, int valid);\nstatic void\tqf_free(qf_list_T *qfl);\nstatic char_u\t*qf_types(int, int);\nstatic int\tqf_get_fnum(qf_list_T *qfl, char_u *, char_u *);\nstatic char_u\t*qf_push_dir(char_u *, struct dir_stack_T **, int is_file_stack);\nstatic char_u\t*qf_pop_dir(struct dir_stack_T **);\nstatic char_u\t*qf_guess_filepath(qf_list_T *qfl, char_u *);\nstatic void\tqf_jump_newwin(qf_info_T *qi, int dir, int errornr, int forceit, int newwin);\nstatic void\tqf_fmt_text(garray_T *gap, char_u *text);\nstatic void\tqf_range_text(garray_T *gap, qfline_T *qfp);\nstatic int\tqf_win_pos_update(qf_info_T *qi, int old_qf_index);\nstatic win_T\t*qf_find_win(qf_info_T *qi);\nstatic buf_T\t*qf_find_buf(qf_info_T *qi);\nstatic void\tqf_update_buffer(qf_info_T *qi, qfline_T *old_last);\nstatic void\tqf_fill_buffer(qf_list_T *qfl, buf_T *buf, qfline_T *old_last, int qf_winid);\nstatic buf_T\t*load_dummy_buffer(char_u *fname, char_u *dirname_start, char_u *resulting_dir);\nstatic void\twipe_dummy_buffer(buf_T *buf, char_u *dirname_start);\nstatic void\tunload_dummy_buffer(buf_T *buf, char_u *dirname_start);\nstatic qf_info_T *ll_get_or_alloc_list(win_T *);\n\n// Quickfix window check helper macro\n#define IS_QF_WINDOW(wp) (bt_quickfix((wp)->w_buffer) && (wp)->w_llist_ref == NULL)\n// Location list window check helper macro\n#define IS_LL_WINDOW(wp) (bt_quickfix((wp)->w_buffer) && (wp)->w_llist_ref != NULL)\n\n// Quickfix and location list stack check helper macros\n#define IS_QF_STACK(qi)\t\t((qi)->qfl_type == QFLT_QUICKFIX)\n#define IS_LL_STACK(qi)\t\t((qi)->qfl_type == QFLT_LOCATION)\n#define IS_QF_LIST(qfl)\t\t((qfl)->qfl_type == QFLT_QUICKFIX)\n#define IS_LL_LIST(qfl)\t\t((qfl)->qfl_type == QFLT_LOCATION)\n\n/*\n * Return location list for window 'wp'\n * For location list window, return the referenced location list\n */\n#define GET_LOC_LIST(wp) (IS_LL_WINDOW(wp) ? (wp)->w_llist_ref : (wp)->w_llist)\n\n// Macro to loop through all the items in a quickfix list\n// Quickfix item index starts from 1, so i below starts at 1\n#define FOR_ALL_QFL_ITEMS(qfl, qfp, i) \\\n\t\t    for ((i) = 1, (qfp) = (qfl)->qf_start; \\\n\t\t\t    !got_int && (i) <= (qfl)->qf_count && (qfp) != NULL; \\\n\t\t\t    ++(i), (qfp) = (qfp)->qf_next)\n\n/*\n * Looking up a buffer can be slow if there are many.  Remember the last one\n * to make this a lot faster if there are multiple matches in the same file.\n */\nstatic char_u   *qf_last_bufname = NULL;\nstatic bufref_T  qf_last_bufref = {NULL, 0, 0};\n\nstatic garray_T qfga;\n\n/*\n * Get a growarray to buffer text in.  Shared between various commands to avoid\n * many alloc/free calls.\n */\n    static garray_T *\nqfga_get(void)\n{\n    static int initialized = FALSE;\n\n    if (!initialized)\n    {\n\tinitialized = TRUE;\n\tga_init2(&qfga, 1, 256);\n    }\n\n    // Reset the length to zero.  Retain ga_data from previous use to avoid\n    // many alloc/free calls.\n    qfga.ga_len = 0;\n\n    return &qfga;\n}\n\n/*\n * The \"qfga\" grow array buffer is reused across multiple quickfix commands as\n * a temporary buffer to reduce the number of alloc/free calls.  But if the\n * buffer size is large, then to avoid holding on to that memory, clear the\n * grow array.  Otherwise just reset the grow array length.\n */\n    static void\nqfga_clear(void)\n{\n    if (qfga.ga_maxlen > 1000)\n\tga_clear(&qfga);\n    else\n\tqfga.ga_len = 0;\n}\n\n/*\n * Maximum number of bytes allowed per line while reading a errorfile.\n */\n#define LINE_MAXLEN 4096\n\n/*\n * Patterns used.  Keep in sync with qf_parse_fmt[].\n */\nstatic struct fmtpattern\n{\n    char_u\tconvchar;\n    char\t*pattern;\n} fmt_pat[FMT_PATTERNS] =\n    {\n\t{'f', \".\\\\+\"},\t    // only used when at end\n\t{'n', \"\\\\d\\\\+\"},\t// 1\n\t{'l', \"\\\\d\\\\+\"},\t// 2\n\t{'e', \"\\\\d\\\\+\"},\t// 3\n\t{'c', \"\\\\d\\\\+\"},\t// 4\n\t{'k', \"\\\\d\\\\+\"},\t// 5\n\t{'t', \".\"},\t\t// 6\n#define FMT_PATTERN_M 7\n\t{'m', \".\\\\+\"},\t\t// 7\n#define FMT_PATTERN_R 8\n\t{'r', \".*\"},\t\t// 8\n\t{'p', \"[-\t .]*\"},\t// 9\n\t{'v', \"\\\\d\\\\+\"},\t// 10\n\t{'s', \".\\\\+\"},\t\t// 11\n\t{'o', \".\\\\+\"}\t\t// 12\n    };\n\n/*\n * Convert an errorformat pattern to a regular expression pattern.\n * See fmt_pat definition above for the list of supported patterns.  The\n * pattern specifier is supplied in \"efmpat\".  The converted pattern is stored\n * in \"regpat\".  Returns a pointer to the location after the pattern.\n */\n    static char_u *\nefmpat_to_regpat(\n\tchar_u\t*efmpat,\n\tchar_u\t*regpat,\n\tefm_T\t*efminfo,\n\tint\tidx,\n\tint\tround)\n{\n    char_u\t*srcptr;\n\n    if (efminfo->addr[idx])\n    {\n\t// Each errorformat pattern can occur only once\n\tsemsg(_(e_too_many_chr_in_format_string), *efmpat);\n\treturn NULL;\n    }\n    if ((idx && idx < FMT_PATTERN_R\n\t\t&& vim_strchr((char_u *)\"DXOPQ\", efminfo->prefix) != NULL)\n\t    || (idx == FMT_PATTERN_R\n\t\t&& vim_strchr((char_u *)\"OPQ\", efminfo->prefix) == NULL))\n    {\n\tsemsg(_(e_unexpected_chr_in_format_str), *efmpat);\n\treturn NULL;\n    }\n    efminfo->addr[idx] = (char_u)++round;\n    *regpat++ = '\\\\';\n    *regpat++ = '(';\n#ifdef BACKSLASH_IN_FILENAME\n    if (*efmpat == 'f')\n    {\n\t// Also match \"c:\" in the file name, even when\n\t// checking for a colon next: \"%f:\".\n\t// \"\\%(\\a:\\)\\=\"\n\tSTRCPY(regpat, \"\\\\%(\\\\a:\\\\)\\\\=\");\n\tregpat += 10;\n    }\n#endif\n    if (*efmpat == 'f' && efmpat[1] != NUL)\n    {\n\tif (efmpat[1] != '\\\\' && efmpat[1] != '%')\n\t{\n\t    // A file name may contain spaces, but this isn't\n\t    // in \"\\f\".  For \"%f:%l:%m\" there may be a \":\" in\n\t    // the file name.  Use \".\\{-1,}x\" instead (x is\n\t    // the next character), the requirement that :999:\n\t    // follows should work.\n\t    STRCPY(regpat, \".\\\\{-1,}\");\n\t    regpat += 7;\n\t}\n\telse\n\t{\n\t    // File name followed by '\\\\' or '%': include as\n\t    // many file name chars as possible.\n\t    STRCPY(regpat, \"\\\\f\\\\+\");\n\t    regpat += 4;\n\t}\n    }\n    else\n    {\n\tsrcptr = (char_u *)fmt_pat[idx].pattern;\n\twhile ((*regpat = *srcptr++) != NUL)\n\t    ++regpat;\n    }\n    *regpat++ = '\\\\';\n    *regpat++ = ')';\n\n    return regpat;\n}\n\n/*\n * Convert a scanf like format in 'errorformat' to a regular expression.\n * Returns a pointer to the location after the pattern.\n */\n    static char_u *\nscanf_fmt_to_regpat(\n\tchar_u\t**pefmp,\n\tchar_u\t*efm,\n\tint\tlen,\n\tchar_u\t*regpat)\n{\n    char_u\t*efmp = *pefmp;\n\n    if (*efmp == '[' || *efmp == '\\\\')\n    {\n\tif ((*regpat++ = *efmp) == '[')\t// %*[^a-z0-9] etc.\n\t{\n\t    if (efmp[1] == '^')\n\t\t*regpat++ = *++efmp;\n\t    if (efmp < efm + len)\n\t    {\n\t\t*regpat++ = *++efmp;\t    // could be ']'\n\t\twhile (efmp < efm + len\n\t\t\t&& (*regpat++ = *++efmp) != ']')\n\t\t    // skip ;\n\t\tif (efmp == efm + len)\n\t\t{\n\t\t    emsg(_(e_missing_rsb_in_format_string));\n\t\t    return NULL;\n\t\t}\n\t    }\n\t}\n\telse if (efmp < efm + len)\t// %*\\D, %*\\s etc.\n\t    *regpat++ = *++efmp;\n\t*regpat++ = '\\\\';\n\t*regpat++ = '+';\n    }\n    else\n    {\n\t// TODO: scanf()-like: %*ud, %*3c, %*f, ... ?\n\tsemsg(_(e_unsupported_chr_in_format_string), *efmp);\n\treturn NULL;\n    }\n\n    *pefmp = efmp;\n\n    return regpat;\n}\n\n/*\n * Analyze/parse an errorformat prefix.\n */\n    static char_u *\nefm_analyze_prefix(char_u *efmp, efm_T *efminfo)\n{\n    if (vim_strchr((char_u *)\"+-\", *efmp) != NULL)\n\tefminfo->flags = *efmp++;\n    if (vim_strchr((char_u *)\"DXAEWINCZGOPQ\", *efmp) != NULL)\n\tefminfo->prefix = *efmp;\n    else\n    {\n\tsemsg(_(e_invalid_chr_in_format_string_prefix), *efmp);\n\treturn NULL;\n    }\n\n    return efmp;\n}\n\n/*\n * Converts a 'errorformat' string part in 'efm' to a regular expression\n * pattern.  The resulting regex pattern is returned in \"regpat\". Additional\n * information about the 'erroformat' pattern is returned in \"fmt_ptr\".\n * Returns OK or FAIL.\n */\n    static int\nefm_to_regpat(\n\tchar_u\t*efm,\n\tint\tlen,\n\tefm_T\t*fmt_ptr,\n\tchar_u\t*regpat)\n{\n    char_u\t*ptr;\n    char_u\t*efmp;\n    int\t\tround;\n    int\t\tidx = 0;\n\n    // Build a regexp pattern for a 'errorformat' option part\n    ptr = regpat;\n    *ptr++ = '^';\n    round = 0;\n    for (efmp = efm; efmp < efm + len; ++efmp)\n    {\n\tif (*efmp == '%')\n\t{\n\t    ++efmp;\n\t    for (idx = 0; idx < FMT_PATTERNS; ++idx)\n\t\tif (fmt_pat[idx].convchar == *efmp)\n\t\t    break;\n\t    if (idx < FMT_PATTERNS)\n\t    {\n\t\tptr = efmpat_to_regpat(efmp, ptr, fmt_ptr, idx, round);\n\t\tif (ptr == NULL)\n\t\t    return FAIL;\n\t\tround++;\n\t    }\n\t    else if (*efmp == '*')\n\t    {\n\t\t++efmp;\n\t\tptr = scanf_fmt_to_regpat(&efmp, efm, len, ptr);\n\t\tif (ptr == NULL)\n\t\t    return FAIL;\n\t    }\n\t    else if (vim_strchr((char_u *)\"%\\\\.^$~[\", *efmp) != NULL)\n\t\t*ptr++ = *efmp;\t\t// regexp magic characters\n\t    else if (*efmp == '#')\n\t\t*ptr++ = '*';\n\t    else if (*efmp == '>')\n\t\tfmt_ptr->conthere = TRUE;\n\t    else if (efmp == efm + 1)\t\t// analyse prefix\n\t    {\n\t\t// prefix is allowed only at the beginning of the errorformat\n\t\t// option part\n\t\tefmp = efm_analyze_prefix(efmp, fmt_ptr);\n\t\tif (efmp == NULL)\n\t\t    return FAIL;\n\t    }\n\t    else\n\t    {\n\t\tsemsg(_(e_invalid_chr_in_format_string), *efmp);\n\t\treturn FAIL;\n\t    }\n\t}\n\telse\t\t\t// copy normal character\n\t{\n\t    if (*efmp == '\\\\' && efmp + 1 < efm + len)\n\t\t++efmp;\n\t    else if (vim_strchr((char_u *)\".*^$~[\", *efmp) != NULL)\n\t\t*ptr++ = '\\\\';\t// escape regexp atoms\n\t    if (*efmp)\n\t\t*ptr++ = *efmp;\n\t}\n    }\n    *ptr++ = '$';\n    *ptr = NUL;\n\n    return OK;\n}\n\n/*\n * Free the 'errorformat' information list\n */\n    static void\nfree_efm_list(efm_T **efm_first)\n{\n    efm_T *efm_ptr;\n\n    for (efm_ptr = *efm_first; efm_ptr != NULL; efm_ptr = *efm_first)\n    {\n\t*efm_first = efm_ptr->next;\n\tvim_regfree(efm_ptr->prog);\n\tvim_free(efm_ptr);\n    }\n    fmt_start = NULL;\n}\n\n/*\n * Compute the size of the buffer used to convert a 'errorformat' pattern into\n * a regular expression pattern.\n */\n    static int\nefm_regpat_bufsz(char_u *efm)\n{\n    int sz;\n    int i;\n\n    sz = (FMT_PATTERNS * 3) + ((int)STRLEN(efm) << 2);\n    for (i = FMT_PATTERNS; i > 0; )\n\tsz += (int)STRLEN(fmt_pat[--i].pattern);\n#ifdef BACKSLASH_IN_FILENAME\n    sz += 12; // \"%f\" can become twelve chars longer (see efm_to_regpat)\n#else\n    sz += 2; // \"%f\" can become two chars longer\n#endif\n\n    return sz;\n}\n\n/*\n * Return the length of a 'errorformat' option part (separated by \",\").\n */\n    static int\nefm_option_part_len(char_u *efm)\n{\n    int len;\n\n    for (len = 0; efm[len] != NUL && efm[len] != ','; ++len)\n\tif (efm[len] == '\\\\' && efm[len + 1] != NUL)\n\t    ++len;\n\n    return len;\n}\n\n/*\n * Parse the 'errorformat' option. Multiple parts in the 'errorformat' option\n * are parsed and converted to regular expressions. Returns information about\n * the parsed 'errorformat' option.\n */\n    static efm_T *\nparse_efm_option(char_u *efm)\n{\n    efm_T\t*fmt_ptr = NULL;\n    efm_T\t*fmt_first = NULL;\n    efm_T\t*fmt_last = NULL;\n    char_u\t*fmtstr = NULL;\n    int\t\tlen;\n    int\t\tsz;\n\n    // Each part of the format string is copied and modified from errorformat\n    // to regex prog.  Only a few % characters are allowed.\n\n    // Get some space to modify the format string into.\n    sz = efm_regpat_bufsz(efm);\n    if ((fmtstr = alloc_id(sz, aid_qf_efm_fmtstr)) == NULL)\n\tgoto parse_efm_error;\n\n    while (efm[0] != NUL)\n    {\n\t// Allocate a new eformat structure and put it at the end of the list\n\tfmt_ptr = ALLOC_CLEAR_ONE_ID(efm_T, aid_qf_efm_fmtpart);\n\tif (fmt_ptr == NULL)\n\t    goto parse_efm_error;\n\tif (fmt_first == NULL)\t    // first one\n\t    fmt_first = fmt_ptr;\n\telse\n\t    fmt_last->next = fmt_ptr;\n\tfmt_last = fmt_ptr;\n\n\t// Isolate one part in the 'errorformat' option\n\tlen = efm_option_part_len(efm);\n\n\tif (efm_to_regpat(efm, len, fmt_ptr, fmtstr) == FAIL)\n\t    goto parse_efm_error;\n\tif ((fmt_ptr->prog = vim_regcomp(fmtstr, RE_MAGIC + RE_STRING)) == NULL)\n\t    goto parse_efm_error;\n\t// Advance to next part\n\tefm = skip_to_option_part(efm + len);\t// skip comma and spaces\n    }\n\n    if (fmt_first == NULL)\t// nothing found\n\temsg(_(e_errorformat_contains_no_pattern));\n\n    goto parse_efm_end;\n\nparse_efm_error:\n    free_efm_list(&fmt_first);\n\nparse_efm_end:\n    vim_free(fmtstr);\n\n    return fmt_first;\n}\n\nenum {\n    QF_FAIL = 0,\n    QF_OK = 1,\n    QF_END_OF_INPUT = 2,\n    QF_NOMEM = 3,\n    QF_IGNORE_LINE = 4,\n    QF_MULTISCAN = 5,\n    QF_ABORT = 6\n};\n\n/*\n * State information used to parse lines and add entries to a quickfix/location\n * list.\n */\ntypedef struct {\n    char_u\t*linebuf;\n    int\t\tlinelen;\n    char_u\t*growbuf;\n    int\t\tgrowbufsiz;\n    FILE\t*fd;\n    typval_T\t*tv;\n    char_u\t*p_str;\n    listitem_T\t*p_li;\n    buf_T\t*buf;\n    linenr_T\tbuflnum;\n    linenr_T\tlnumlast;\n    vimconv_T\tvc;\n} qfstate_T;\n\n/*\n * Allocate more memory for the line buffer used for parsing lines.\n */\n    static char_u *\nqf_grow_linebuf(qfstate_T *state, int newsz)\n{\n    char_u\t*p;\n\n    // If the line exceeds LINE_MAXLEN exclude the last\n    // byte since it's not a NL character.\n    state->linelen = newsz > LINE_MAXLEN ? LINE_MAXLEN - 1 : newsz;\n    if (state->growbuf == NULL)\n    {\n\tstate->growbuf = alloc_id(state->linelen + 1, aid_qf_linebuf);\n\tif (state->growbuf == NULL)\n\t    return NULL;\n\tstate->growbufsiz = state->linelen;\n    }\n    else if (state->linelen > state->growbufsiz)\n    {\n\tif ((p = vim_realloc(state->growbuf, state->linelen + 1)) == NULL)\n\t    return NULL;\n\tstate->growbuf = p;\n\tstate->growbufsiz = state->linelen;\n    }\n    return state->growbuf;\n}\n\n/*\n * Get the next string (separated by newline) from state->p_str.\n */\n    static int\nqf_get_next_str_line(qfstate_T *state)\n{\n    // Get the next line from the supplied string\n    char_u\t*p_str = state->p_str;\n    char_u\t*p;\n    int\t\tlen;\n\n    if (*p_str == NUL) // Reached the end of the string\n\treturn QF_END_OF_INPUT;\n\n    p = vim_strchr(p_str, '\\n');\n    if (p != NULL)\n\tlen = (int)(p - p_str) + 1;\n    else\n\tlen = (int)STRLEN(p_str);\n\n    if (len > IOSIZE - 2)\n    {\n\tstate->linebuf = qf_grow_linebuf(state, len);\n\tif (state->linebuf == NULL)\n\t    return QF_NOMEM;\n    }\n    else\n    {\n\tstate->linebuf = IObuff;\n\tstate->linelen = len;\n    }\n    vim_strncpy(state->linebuf, p_str, state->linelen);\n\n    // Increment using len in order to discard the rest of the\n    // line if it exceeds LINE_MAXLEN.\n    p_str += len;\n    state->p_str = p_str;\n\n    return QF_OK;\n}\n\n/*\n * Get the next string from the List item state->p_li.\n */\n    static int\nqf_get_next_list_line(qfstate_T *state)\n{\n    listitem_T\t*p_li = state->p_li;\n    int\t\tlen;\n\n    while (p_li != NULL\n\t    && (p_li->li_tv.v_type != VAR_STRING\n\t\t|| p_li->li_tv.vval.v_string == NULL))\n\tp_li = p_li->li_next;\t// Skip non-string items\n\n    if (p_li == NULL)\t\t// End of the list\n    {\n\tstate->p_li = NULL;\n\treturn QF_END_OF_INPUT;\n    }\n\n    len = (int)STRLEN(p_li->li_tv.vval.v_string);\n    if (len > IOSIZE - 2)\n    {\n\tstate->linebuf = qf_grow_linebuf(state, len);\n\tif (state->linebuf == NULL)\n\t    return QF_NOMEM;\n    }\n    else\n    {\n\tstate->linebuf = IObuff;\n\tstate->linelen = len;\n    }\n\n    vim_strncpy(state->linebuf, p_li->li_tv.vval.v_string, state->linelen);\n\n    state->p_li = p_li->li_next;\t// next item\n    return QF_OK;\n}\n\n/*\n * Get the next string from state->buf.\n */\n    static int\nqf_get_next_buf_line(qfstate_T *state)\n{\n    char_u\t*p_buf = NULL;\n    int\t\tlen;\n\n    // Get the next line from the supplied buffer\n    if (state->buflnum > state->lnumlast)\n\treturn QF_END_OF_INPUT;\n\n    p_buf = ml_get_buf(state->buf, state->buflnum, FALSE);\n    state->buflnum += 1;\n\n    len = (int)STRLEN(p_buf);\n    if (len > IOSIZE - 2)\n    {\n\tstate->linebuf = qf_grow_linebuf(state, len);\n\tif (state->linebuf == NULL)\n\t    return QF_NOMEM;\n    }\n    else\n    {\n\tstate->linebuf = IObuff;\n\tstate->linelen = len;\n    }\n    vim_strncpy(state->linebuf, p_buf, state->linelen);\n\n    return QF_OK;\n}\n\n/*\n * Get the next string from file state->fd.\n */\n    static int\nqf_get_next_file_line(qfstate_T *state)\n{\n    int\t    discard;\n    int\t    growbuflen;\n\n    if (fgets((char *)IObuff, IOSIZE, state->fd) == NULL)\n\treturn QF_END_OF_INPUT;\n\n    discard = FALSE;\n    state->linelen = (int)STRLEN(IObuff);\n    if (state->linelen == IOSIZE - 1 && !(IObuff[state->linelen - 1] == '\\n'))\n    {\n\t// The current line exceeds IObuff, continue reading using\n\t// growbuf until EOL or LINE_MAXLEN bytes is read.\n\tif (state->growbuf == NULL)\n\t{\n\t    state->growbufsiz = 2 * (IOSIZE - 1);\n\t    state->growbuf = alloc_id(state->growbufsiz, aid_qf_linebuf);\n\t    if (state->growbuf == NULL)\n\t\treturn QF_NOMEM;\n\t}\n\n\t// Copy the read part of the line, excluding null-terminator\n\tmemcpy(state->growbuf, IObuff, IOSIZE - 1);\n\tgrowbuflen = state->linelen;\n\n\tfor (;;)\n\t{\n\t    char_u\t*p;\n\n\t    if (fgets((char *)state->growbuf + growbuflen,\n\t\t\tstate->growbufsiz - growbuflen, state->fd) == NULL)\n\t\tbreak;\n\t    state->linelen = (int)STRLEN(state->growbuf + growbuflen);\n\t    growbuflen += state->linelen;\n\t    if ((state->growbuf)[growbuflen - 1] == '\\n')\n\t\tbreak;\n\t    if (state->growbufsiz == LINE_MAXLEN)\n\t    {\n\t\tdiscard = TRUE;\n\t\tbreak;\n\t    }\n\n\t    state->growbufsiz = 2 * state->growbufsiz < LINE_MAXLEN\n\t\t? 2 * state->growbufsiz : LINE_MAXLEN;\n\t    if ((p = vim_realloc(state->growbuf, state->growbufsiz)) == NULL)\n\t\treturn QF_NOMEM;\n\t    state->growbuf = p;\n\t}\n\n\twhile (discard)\n\t{\n\t    // The current line is longer than LINE_MAXLEN, continue\n\t    // reading but discard everything until EOL or EOF is\n\t    // reached.\n\t    if (fgets((char *)IObuff, IOSIZE, state->fd) == NULL\n\t\t    || (int)STRLEN(IObuff) < IOSIZE - 1\n\t\t    || IObuff[IOSIZE - 2] == '\\n')\n\t\tbreak;\n\t}\n\n\tstate->linebuf = state->growbuf;\n\tstate->linelen = growbuflen;\n    }\n    else\n\tstate->linebuf = IObuff;\n\n    // Convert a line if it contains a non-ASCII character.\n    if (state->vc.vc_type != CONV_NONE && has_non_ascii(state->linebuf))\n    {\n\tchar_u\t*line;\n\n\tline = string_convert(&state->vc, state->linebuf, &state->linelen);\n\tif (line != NULL)\n\t{\n\t    if (state->linelen < IOSIZE)\n\t    {\n\t\tSTRCPY(state->linebuf, line);\n\t\tvim_free(line);\n\t    }\n\t    else\n\t    {\n\t\tvim_free(state->growbuf);\n\t\tstate->linebuf = state->growbuf = line;\n\t\tstate->growbufsiz = state->linelen < LINE_MAXLEN\n\t\t\t\t\t\t? state->linelen : LINE_MAXLEN;\n\t    }\n\t}\n    }\n\n    return QF_OK;\n}\n\n/*\n * Get the next string from a file/buffer/list/string.\n */\n    static int\nqf_get_nextline(qfstate_T *state)\n{\n    int status = QF_FAIL;\n\n    if (state->fd == NULL)\n    {\n\tif (state->tv != NULL)\n\t{\n\t    if (state->tv->v_type == VAR_STRING)\n\t\t// Get the next line from the supplied string\n\t\tstatus = qf_get_next_str_line(state);\n\t    else if (state->tv->v_type == VAR_LIST)\n\t\t// Get the next line from the supplied list\n\t\tstatus = qf_get_next_list_line(state);\n\t}\n\telse\n\t    // Get the next line from the supplied buffer\n\t    status = qf_get_next_buf_line(state);\n    }\n    else\n\t// Get the next line from the supplied file\n\tstatus = qf_get_next_file_line(state);\n\n    if (status != QF_OK)\n\treturn status;\n\n    // remove newline/CR from the line\n    if (state->linelen > 0 && state->linebuf[state->linelen - 1] == '\\n')\n    {\n\tstate->linebuf[state->linelen - 1] = NUL;\n#ifdef USE_CRNL\n\tif (state->linelen > 1 && state->linebuf[state->linelen - 2] == '\\r')\n\t    state->linebuf[state->linelen - 2] = NUL;\n#endif\n    }\n\n    remove_bom(state->linebuf);\n\n    return QF_OK;\n}\n\ntypedef struct {\n    char_u\t*namebuf;\n    char_u\t*module;\n    char_u\t*errmsg;\n    int\t\terrmsglen;\n    long\tlnum;\n    long\tend_lnum;\n    int\t\tcol;\n    int\t\tend_col;\n    char_u\tuse_viscol;\n    char_u\t*pattern;\n    int\t\tenr;\n    int\t\ttype;\n    int\t\tvalid;\n} qffields_T;\n\n/*\n * Parse the match for filename ('%f') pattern in regmatch.\n * Return the matched value in \"fields->namebuf\".\n */\n    static int\nqf_parse_fmt_f(regmatch_T *rmp, int midx, qffields_T *fields, int prefix)\n{\n    int c;\n\n    if (rmp->startp[midx] == NULL || rmp->endp[midx] == NULL)\n\treturn QF_FAIL;\n\n    // Expand ~/file and $HOME/file to full path.\n    c = *rmp->endp[midx];\n    *rmp->endp[midx] = NUL;\n    expand_env(rmp->startp[midx], fields->namebuf, CMDBUFFSIZE);\n    *rmp->endp[midx] = c;\n\n    // For separate filename patterns (%O, %P and %Q), the specified file\n    // should exist.\n    if (vim_strchr((char_u *)\"OPQ\", prefix) != NULL\n\t    && mch_getperm(fields->namebuf) == -1)\n\treturn QF_FAIL;\n\n    return QF_OK;\n}\n\n/*\n * Parse the match for error number ('%n') pattern in regmatch.\n * Return the matched value in \"fields->enr\".\n */\n    static int\nqf_parse_fmt_n(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    if (rmp->startp[midx] == NULL)\n\treturn QF_FAIL;\n    fields->enr = (int)atol((char *)rmp->startp[midx]);\n    return QF_OK;\n}\n\n/*\n * Parse the match for line number ('%l') pattern in regmatch.\n * Return the matched value in \"fields->lnum\".\n */\n    static int\nqf_parse_fmt_l(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    if (rmp->startp[midx] == NULL)\n\treturn QF_FAIL;\n    fields->lnum = atol((char *)rmp->startp[midx]);\n    return QF_OK;\n}\n\n/*\n * Parse the match for end line number ('%e') pattern in regmatch.\n * Return the matched value in \"fields->end_lnum\".\n */\n    static int\nqf_parse_fmt_e(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    if (rmp->startp[midx] == NULL)\n\treturn QF_FAIL;\n    fields->end_lnum = atol((char *)rmp->startp[midx]);\n    return QF_OK;\n}\n\n/*\n * Parse the match for column number ('%c') pattern in regmatch.\n * Return the matched value in \"fields->col\".\n */\n    static int\nqf_parse_fmt_c(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    if (rmp->startp[midx] == NULL)\n\treturn QF_FAIL;\n    fields->col = (int)atol((char *)rmp->startp[midx]);\n    return QF_OK;\n}\n\n/*\n * Parse the match for end column number ('%k') pattern in regmatch.\n * Return the matched value in \"fields->end_col\".\n */\n    static int\nqf_parse_fmt_k(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    if (rmp->startp[midx] == NULL)\n\treturn QF_FAIL;\n    fields->end_col = (int)atol((char *)rmp->startp[midx]);\n    return QF_OK;\n}\n\n/*\n * Parse the match for error type ('%t') pattern in regmatch.\n * Return the matched value in \"fields->type\".\n */\n    static int\nqf_parse_fmt_t(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    if (rmp->startp[midx] == NULL)\n\treturn QF_FAIL;\n    fields->type = *rmp->startp[midx];\n    return QF_OK;\n}\n\n/*\n * Copy a non-error line into the error string.  Return the matched line in\n * \"fields->errmsg\".\n */\n    static int\ncopy_nonerror_line(char_u *linebuf, int linelen, qffields_T *fields)\n{\n    char_u\t*p;\n\n    if (linelen >= fields->errmsglen)\n    {\n\t// linelen + null terminator\n\tif ((p = vim_realloc(fields->errmsg, linelen + 1)) == NULL)\n\t    return QF_NOMEM;\n\tfields->errmsg = p;\n\tfields->errmsglen = linelen + 1;\n    }\n    // copy whole line to error message\n    vim_strncpy(fields->errmsg, linebuf, linelen);\n\n    return QF_OK;\n}\n\n/*\n * Parse the match for error message ('%m') pattern in regmatch.\n * Return the matched value in \"fields->errmsg\".\n */\n    static int\nqf_parse_fmt_m(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    char_u\t*p;\n    int\t\tlen;\n\n    if (rmp->startp[midx] == NULL || rmp->endp[midx] == NULL)\n\treturn QF_FAIL;\n    len = (int)(rmp->endp[midx] - rmp->startp[midx]);\n    if (len >= fields->errmsglen)\n    {\n\t// len + null terminator\n\tif ((p = vim_realloc(fields->errmsg, len + 1)) == NULL)\n\t    return QF_NOMEM;\n\tfields->errmsg = p;\n\tfields->errmsglen = len + 1;\n    }\n    vim_strncpy(fields->errmsg, rmp->startp[midx], len);\n    return QF_OK;\n}\n\n/*\n * Parse the match for rest of a single-line file message ('%r') pattern.\n * Return the matched value in \"tail\".\n */\n    static int\nqf_parse_fmt_r(regmatch_T *rmp, int midx, char_u **tail)\n{\n    if (rmp->startp[midx] == NULL)\n\treturn QF_FAIL;\n    *tail = rmp->startp[midx];\n    return QF_OK;\n}\n\n/*\n * Parse the match for the pointer line ('%p') pattern in regmatch.\n * Return the matched value in \"fields->col\".\n */\n    static int\nqf_parse_fmt_p(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    char_u\t*match_ptr;\n\n    if (rmp->startp[midx] == NULL || rmp->endp[midx] == NULL)\n\treturn QF_FAIL;\n    fields->col = 0;\n    for (match_ptr = rmp->startp[midx]; match_ptr != rmp->endp[midx];\n\t\t\t\t\t\t\t\t++match_ptr)\n    {\n\t++fields->col;\n\tif (*match_ptr == TAB)\n\t{\n\t    fields->col += 7;\n\t    fields->col -= fields->col % 8;\n\t}\n    }\n    ++fields->col;\n    fields->use_viscol = TRUE;\n    return QF_OK;\n}\n\n/*\n * Parse the match for the virtual column number ('%v') pattern in regmatch.\n * Return the matched value in \"fields->col\".\n */\n    static int\nqf_parse_fmt_v(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    if (rmp->startp[midx] == NULL)\n\treturn QF_FAIL;\n    fields->col = (int)atol((char *)rmp->startp[midx]);\n    fields->use_viscol = TRUE;\n    return QF_OK;\n}\n\n/*\n * Parse the match for the search text ('%s') pattern in regmatch.\n * Return the matched value in \"fields->pattern\".\n */\n    static int\nqf_parse_fmt_s(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    int\t\tlen;\n\n    if (rmp->startp[midx] == NULL || rmp->endp[midx] == NULL)\n\treturn QF_FAIL;\n    len = (int)(rmp->endp[midx] - rmp->startp[midx]);\n    if (len > CMDBUFFSIZE - 5)\n\tlen = CMDBUFFSIZE - 5;\n    STRCPY(fields->pattern, \"^\\\\V\");\n    STRNCAT(fields->pattern, rmp->startp[midx], len);\n    fields->pattern[len + 3] = '\\\\';\n    fields->pattern[len + 4] = '$';\n    fields->pattern[len + 5] = NUL;\n    return QF_OK;\n}\n\n/*\n * Parse the match for the module ('%o') pattern in regmatch.\n * Return the matched value in \"fields->module\".\n */\n    static int\nqf_parse_fmt_o(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    int\t\tlen;\n\n    if (rmp->startp[midx] == NULL || rmp->endp[midx] == NULL)\n\treturn QF_FAIL;\n    len = (int)(rmp->endp[midx] - rmp->startp[midx]);\n    if (len > CMDBUFFSIZE)\n\tlen = CMDBUFFSIZE;\n    STRNCAT(fields->module, rmp->startp[midx], len);\n    return QF_OK;\n}\n\n/*\n * 'errorformat' format pattern parser functions.\n * The '%f' and '%r' formats are parsed differently from other formats.\n * See qf_parse_match() for details.\n * Keep in sync with fmt_pat[].\n */\nstatic int (*qf_parse_fmt[FMT_PATTERNS])(regmatch_T *, int, qffields_T *) =\n{\n    NULL, // %f\n    qf_parse_fmt_n,\n    qf_parse_fmt_l,\n    qf_parse_fmt_e,\n    qf_parse_fmt_c,\n    qf_parse_fmt_k,\n    qf_parse_fmt_t,\n    qf_parse_fmt_m,\n    NULL, // %r\n    qf_parse_fmt_p,\n    qf_parse_fmt_v,\n    qf_parse_fmt_s,\n    qf_parse_fmt_o\n};\n\n/*\n * Parse the error format pattern matches in \"regmatch\" and set the values in\n * \"fields\".  fmt_ptr contains the 'efm' format specifiers/prefixes that have a\n * match.  Returns QF_OK if all the matches are successfully parsed. On\n * failure, returns QF_FAIL or QF_NOMEM.\n */\n    static int\nqf_parse_match(\n\tchar_u\t\t*linebuf,\n\tint\t\tlinelen,\n\tefm_T\t\t*fmt_ptr,\n\tregmatch_T\t*regmatch,\n\tqffields_T\t*fields,\n\tint\t\tqf_multiline,\n\tint\t\tqf_multiscan,\n\tchar_u\t\t**tail)\n{\n    int\t\tidx = fmt_ptr->prefix;\n    int\t\ti;\n    int\t\tmidx;\n    int\t\tstatus;\n\n    if ((idx == 'C' || idx == 'Z') && !qf_multiline)\n\treturn QF_FAIL;\n    if (vim_strchr((char_u *)\"EWIN\", idx) != NULL)\n\tfields->type = idx;\n    else\n\tfields->type = 0;\n\n    // Extract error message data from matched line.\n    // We check for an actual submatch, because \"\\[\" and \"\\]\" in\n    // the 'errorformat' may cause the wrong submatch to be used.\n    for (i = 0; i < FMT_PATTERNS; i++)\n    {\n\tstatus = QF_OK;\n\tmidx = (int)fmt_ptr->addr[i];\n\tif (i == 0 && midx > 0)\t\t\t\t// %f\n\t    status = qf_parse_fmt_f(regmatch, midx, fields, idx);\n\telse if (i == FMT_PATTERN_M)\n\t{\n\t    if (fmt_ptr->flags == '+' && !qf_multiscan)\t// %+\n\t\tstatus = copy_nonerror_line(linebuf, linelen, fields);\n\t    else if (midx > 0)\t\t\t\t// %m\n\t\tstatus = qf_parse_fmt_m(regmatch, midx, fields);\n\t}\n\telse if (i == FMT_PATTERN_R && midx > 0)\t// %r\n\t    status = qf_parse_fmt_r(regmatch, midx, tail);\n\telse if (midx > 0)\t\t\t\t// others\n\t    status = (qf_parse_fmt[i])(regmatch, midx, fields);\n\n\tif (status != QF_OK)\n\t    return status;\n    }\n\n    return QF_OK;\n}\n\n/*\n * Parse an error line in 'linebuf' using a single error format string in\n * 'fmt_ptr->prog' and return the matching values in 'fields'.\n * Returns QF_OK if the efm format matches completely and the fields are\n * successfully copied. Otherwise returns QF_FAIL or QF_NOMEM.\n */\n    static int\nqf_parse_get_fields(\n\tchar_u\t\t*linebuf,\n\tint\t\tlinelen,\n\tefm_T\t\t*fmt_ptr,\n\tqffields_T\t*fields,\n\tint\t\tqf_multiline,\n\tint\t\tqf_multiscan,\n\tchar_u\t\t**tail)\n{\n    regmatch_T\tregmatch;\n    int\t\tstatus = QF_FAIL;\n    int\t\tr;\n\n    if (qf_multiscan &&\n\t\tvim_strchr((char_u *)\"OPQ\", fmt_ptr->prefix) == NULL)\n\treturn QF_FAIL;\n\n    fields->namebuf[0] = NUL;\n    fields->module[0] = NUL;\n    fields->pattern[0] = NUL;\n    if (!qf_multiscan)\n\tfields->errmsg[0] = NUL;\n    fields->lnum = 0;\n    fields->end_lnum = 0;\n    fields->col = 0;\n    fields->end_col = 0;\n    fields->use_viscol = FALSE;\n    fields->enr = -1;\n    fields->type = 0;\n    *tail = NULL;\n\n    // Always ignore case when looking for a matching error.\n    regmatch.rm_ic = TRUE;\n    regmatch.regprog = fmt_ptr->prog;\n    r = vim_regexec(&regmatch, linebuf, (colnr_T)0);\n    fmt_ptr->prog = regmatch.regprog;\n    if (r)\n\tstatus = qf_parse_match(linebuf, linelen, fmt_ptr, &regmatch,\n\t\tfields, qf_multiline, qf_multiscan, tail);\n\n    return status;\n}\n\n/*\n * Parse directory error format prefixes (%D and %X).\n * Push and pop directories from the directory stack when scanning directory\n * names.\n */\n    static int\nqf_parse_dir_pfx(int idx, qffields_T *fields, qf_list_T *qfl)\n{\n    if (idx == 'D')\t\t\t\t// enter directory\n    {\n\tif (*fields->namebuf == NUL)\n\t{\n\t    emsg(_(e_missing_or_empty_directory_name));\n\t    return QF_FAIL;\n\t}\n\tqfl->qf_directory =\n\t    qf_push_dir(fields->namebuf, &qfl->qf_dir_stack, FALSE);\n\tif (qfl->qf_directory == NULL)\n\t    return QF_FAIL;\n    }\n    else if (idx == 'X')\t\t\t// leave directory\n\tqfl->qf_directory = qf_pop_dir(&qfl->qf_dir_stack);\n\n    return QF_OK;\n}\n\n/*\n * Parse global file name error format prefixes (%O, %P and %Q).\n */\n    static int\nqf_parse_file_pfx(\n\tint idx,\n\tqffields_T *fields,\n\tqf_list_T *qfl,\n\tchar_u *tail)\n{\n    fields->valid = FALSE;\n    if (*fields->namebuf == NUL || mch_getperm(fields->namebuf) >= 0)\n    {\n\tif (*fields->namebuf && idx == 'P')\n\t    qfl->qf_currfile =\n\t\tqf_push_dir(fields->namebuf, &qfl->qf_file_stack, TRUE);\n\telse if (idx == 'Q')\n\t    qfl->qf_currfile = qf_pop_dir(&qfl->qf_file_stack);\n\t*fields->namebuf = NUL;\n\tif (tail && *tail)\n\t{\n\t    STRMOVE(IObuff, skipwhite(tail));\n\t    qfl->qf_multiscan = TRUE;\n\t    return QF_MULTISCAN;\n\t}\n    }\n\n    return QF_OK;\n}\n\n/*\n * Parse a non-error line (a line which doesn't match any of the error\n * format in 'efm').\n */\n    static int\nqf_parse_line_nomatch(char_u *linebuf, int linelen, qffields_T *fields)\n{\n    fields->namebuf[0] = NUL;\t// no match found, remove file name\n    fields->lnum = 0;\t\t// don't jump to this line\n    fields->valid = FALSE;\n\n    return copy_nonerror_line(linebuf, linelen, fields);\n}\n\n/*\n * Parse multi-line error format prefixes (%C and %Z)\n */\n    static int\nqf_parse_multiline_pfx(\n\tint idx,\n\tqf_list_T *qfl,\n\tqffields_T *fields)\n{\n    char_u\t\t*ptr;\n    int\t\t\tlen;\n\n    if (!qfl->qf_multiignore)\n    {\n\tqfline_T *qfprev = qfl->qf_last;\n\n\tif (qfprev == NULL)\n\t    return QF_FAIL;\n\tif (*fields->errmsg && !qfl->qf_multiignore)\n\t{\n\t    len = (int)STRLEN(qfprev->qf_text);\n\t    ptr = alloc_id(len + STRLEN(fields->errmsg) + 2,\n\t\t\t\t\t\taid_qf_multiline_pfx);\n\t    if (ptr == NULL)\n\t\treturn QF_FAIL;\n\t    STRCPY(ptr, qfprev->qf_text);\n\t    vim_free(qfprev->qf_text);\n\t    qfprev->qf_text = ptr;\n\t    *(ptr += len) = '\\n';\n\t    STRCPY(++ptr, fields->errmsg);\n\t}\n\tif (qfprev->qf_nr == -1)\n\t    qfprev->qf_nr = fields->enr;\n\tif (vim_isprintc(fields->type) && !qfprev->qf_type)\n\t    // only printable chars allowed\n\t    qfprev->qf_type = fields->type;\n\n\tif (!qfprev->qf_lnum)\n\t    qfprev->qf_lnum = fields->lnum;\n\tif (!qfprev->qf_end_lnum)\n\t    qfprev->qf_end_lnum = fields->end_lnum;\n\tif (!qfprev->qf_col)\n\t{\n\t    qfprev->qf_col = fields->col;\n\t    qfprev->qf_viscol = fields->use_viscol;\n\t}\n\tif (!qfprev->qf_end_col)\n\t    qfprev->qf_end_col = fields->end_col;\n\tif (!qfprev->qf_fnum)\n\t    qfprev->qf_fnum = qf_get_fnum(qfl,\n\t\t    qfl->qf_directory,\n\t\t    *fields->namebuf || qfl->qf_directory != NULL\n\t\t    ? fields->namebuf\n\t\t    : qfl->qf_currfile != NULL && fields->valid\n\t\t    ? qfl->qf_currfile : 0);\n    }\n    if (idx == 'Z')\n\tqfl->qf_multiline = qfl->qf_multiignore = FALSE;\n    line_breakcheck();\n\n    return QF_IGNORE_LINE;\n}\n\n/*\n * Parse a line and get the quickfix fields.\n * Return the QF_ status.\n */\n    static int\nqf_parse_line(\n\tqf_list_T\t*qfl,\n\tchar_u\t\t*linebuf,\n\tint\t\tlinelen,\n\tefm_T\t\t*fmt_first,\n\tqffields_T\t*fields)\n{\n    efm_T\t\t*fmt_ptr;\n    int\t\t\tidx = 0;\n    char_u\t\t*tail = NULL;\n    int\t\t\tstatus;\n\nrestofline:\n    // If there was no %> item start at the first pattern\n    if (fmt_start == NULL)\n\tfmt_ptr = fmt_first;\n    else\n    {\n\t// Otherwise start from the last used pattern\n\tfmt_ptr = fmt_start;\n\tfmt_start = NULL;\n    }\n\n    // Try to match each part of 'errorformat' until we find a complete\n    // match or no match.\n    fields->valid = TRUE;\n    for ( ; fmt_ptr != NULL; fmt_ptr = fmt_ptr->next)\n    {\n\tidx = fmt_ptr->prefix;\n\tstatus = qf_parse_get_fields(linebuf, linelen, fmt_ptr, fields,\n\t\t\t\tqfl->qf_multiline, qfl->qf_multiscan, &tail);\n\tif (status == QF_NOMEM)\n\t    return status;\n\tif (status == QF_OK)\n\t    break;\n    }\n    qfl->qf_multiscan = FALSE;\n\n    if (fmt_ptr == NULL || idx == 'D' || idx == 'X')\n    {\n\tif (fmt_ptr != NULL)\n\t{\n\t    // 'D' and 'X' directory specifiers\n\t    status = qf_parse_dir_pfx(idx, fields, qfl);\n\t    if (status != QF_OK)\n\t\treturn status;\n\t}\n\n\tstatus = qf_parse_line_nomatch(linebuf, linelen, fields);\n\tif (status != QF_OK)\n\t    return status;\n\n\tif (fmt_ptr == NULL)\n\t    qfl->qf_multiline = qfl->qf_multiignore = FALSE;\n    }\n    else if (fmt_ptr != NULL)\n    {\n\t// honor %> item\n\tif (fmt_ptr->conthere)\n\t    fmt_start = fmt_ptr;\n\n\tif (vim_strchr((char_u *)\"AEWIN\", idx) != NULL)\n\t{\n\t    qfl->qf_multiline = TRUE;\t// start of a multi-line message\n\t    qfl->qf_multiignore = FALSE;// reset continuation\n\t}\n\telse if (vim_strchr((char_u *)\"CZ\", idx) != NULL)\n\t{\t\t\t\t// continuation of multi-line msg\n\t    status = qf_parse_multiline_pfx(idx, qfl, fields);\n\t    if (status != QF_OK)\n\t\treturn status;\n\t}\n\telse if (vim_strchr((char_u *)\"OPQ\", idx) != NULL)\n\t{\t\t\t\t// global file names\n\t    status = qf_parse_file_pfx(idx, fields, qfl, tail);\n\t    if (status == QF_MULTISCAN)\n\t\tgoto restofline;\n\t}\n\tif (fmt_ptr->flags == '-')\t// generally exclude this line\n\t{\n\t    if (qfl->qf_multiline)\n\t\t// also exclude continuation lines\n\t\tqfl->qf_multiignore = TRUE;\n\t    return QF_IGNORE_LINE;\n\t}\n    }\n\n    return QF_OK;\n}\n\n/*\n * Returns TRUE if the specified quickfix/location stack is empty\n */\n    static int\nqf_stack_empty(qf_info_T *qi)\n{\n    return qi == NULL || qi->qf_listcount <= 0;\n}\n\n/*\n * Returns TRUE if the specified quickfix/location list is empty.\n */\n    static int\nqf_list_empty(qf_list_T *qfl)\n{\n    return qfl == NULL || qfl->qf_count <= 0;\n}\n\n/*\n * Returns TRUE if the specified quickfix/location list is not empty and\n * has valid entries.\n */\n    static int\nqf_list_has_valid_entries(qf_list_T *qfl)\n{\n    return !qf_list_empty(qfl) && !qfl->qf_nonevalid;\n}\n\n/*\n * Return a pointer to a list in the specified quickfix stack\n */\n    static qf_list_T *\nqf_get_list(qf_info_T *qi, int idx)\n{\n    return &qi->qf_lists[idx];\n}\n\n/*\n * Allocate the fields used for parsing lines and populating a quickfix list.\n */\n    static int\nqf_alloc_fields(qffields_T *pfields)\n{\n    pfields->namebuf = alloc_id(CMDBUFFSIZE + 1, aid_qf_namebuf);\n    pfields->module = alloc_id(CMDBUFFSIZE + 1, aid_qf_module);\n    pfields->errmsglen = CMDBUFFSIZE + 1;\n    pfields->errmsg = alloc_id(pfields->errmsglen, aid_qf_errmsg);\n    pfields->pattern = alloc_id(CMDBUFFSIZE + 1, aid_qf_pattern);\n    if (pfields->namebuf == NULL || pfields->errmsg == NULL\n\t\t|| pfields->pattern == NULL || pfields->module == NULL)\n\treturn FAIL;\n\n    return OK;\n}\n\n/*\n * Free the fields used for parsing lines and populating a quickfix list.\n */\n    static void\nqf_free_fields(qffields_T *pfields)\n{\n    vim_free(pfields->namebuf);\n    vim_free(pfields->module);\n    vim_free(pfields->errmsg);\n    vim_free(pfields->pattern);\n}\n\n/*\n * Setup the state information used for parsing lines and populating a\n * quickfix list.\n */\n    static int\nqf_setup_state(\n\tqfstate_T\t*pstate,\n\tchar_u\t\t*enc,\n\tchar_u\t\t*efile,\n\ttypval_T\t*tv,\n\tbuf_T\t\t*buf,\n\tlinenr_T\tlnumfirst,\n\tlinenr_T\tlnumlast)\n{\n    pstate->vc.vc_type = CONV_NONE;\n    if (enc != NULL && *enc != NUL)\n\tconvert_setup(&pstate->vc, enc, p_enc);\n\n    if (efile != NULL && (pstate->fd = mch_fopen((char *)efile, \"r\")) == NULL)\n    {\n\tsemsg(_(e_cant_open_errorfile_str), efile);\n\treturn FAIL;\n    }\n\n    if (tv != NULL)\n    {\n\tif (tv->v_type == VAR_STRING)\n\t    pstate->p_str = tv->vval.v_string;\n\telse if (tv->v_type == VAR_LIST)\n\t    pstate->p_li = tv->vval.v_list->lv_first;\n\tpstate->tv = tv;\n    }\n    pstate->buf = buf;\n    pstate->buflnum = lnumfirst;\n    pstate->lnumlast = lnumlast;\n\n    return OK;\n}\n\n/*\n * Cleanup the state information used for parsing lines and populating a\n * quickfix list.\n */\n    static void\nqf_cleanup_state(qfstate_T *pstate)\n{\n    if (pstate->fd != NULL)\n\tfclose(pstate->fd);\n\n    vim_free(pstate->growbuf);\n    if (pstate->vc.vc_type != CONV_NONE)\n\tconvert_setup(&pstate->vc, NULL, NULL);\n}\n\n/*\n * Process the next line from a file/buffer/list/string and add it\n * to the quickfix list 'qfl'.\n */\n    static int\nqf_init_process_nextline(\n\tqf_list_T\t*qfl,\n\tefm_T\t\t*fmt_first,\n\tqfstate_T\t*state,\n\tqffields_T\t*fields)\n{\n    int\t\t    status;\n\n    // Get the next line from a file/buffer/list/string\n    status = qf_get_nextline(state);\n    if (status != QF_OK)\n\treturn status;\n\n    status = qf_parse_line(qfl, state->linebuf, state->linelen,\n\t    fmt_first, fields);\n    if (status != QF_OK)\n\treturn status;\n\n    return qf_add_entry(qfl,\n\t\tqfl->qf_directory,\n\t\t(*fields->namebuf || qfl->qf_directory != NULL)\n\t\t? fields->namebuf\n\t\t: ((qfl->qf_currfile != NULL && fields->valid)\n\t\t    ? qfl->qf_currfile : (char_u *)NULL),\n\t\tfields->module,\n\t\t0,\n\t\tfields->errmsg,\n\t\tfields->lnum,\n\t\tfields->end_lnum,\n\t\tfields->col,\n\t\tfields->end_col,\n\t\tfields->use_viscol,\n\t\tfields->pattern,\n\t\tfields->enr,\n\t\tfields->type,\n\t\tfields->valid);\n}\n\n/*\n * Read the errorfile \"efile\" into memory, line by line, building the error\n * list.\n * Alternative: when \"efile\" is NULL read errors from buffer \"buf\".\n * Alternative: when \"tv\" is not NULL get errors from the string or list.\n * Always use 'errorformat' from \"buf\" if there is a local value.\n * Then \"lnumfirst\" and \"lnumlast\" specify the range of lines to use.\n * Set the title of the list to \"qf_title\".\n * Return -1 for error, number of errors for success.\n */\n    static int\nqf_init_ext(\n    qf_info_T\t    *qi,\n    int\t\t    qf_idx,\n    char_u\t    *efile,\n    buf_T\t    *buf,\n    typval_T\t    *tv,\n    char_u\t    *errorformat,\n    int\t\t    newlist,\t\t// TRUE: start a new error list\n    linenr_T\t    lnumfirst,\t\t// first line number to use\n    linenr_T\t    lnumlast,\t\t// last line number to use\n    char_u\t    *qf_title,\n    char_u\t    *enc)\n{\n    qf_list_T\t    *qfl;\n    qfstate_T\t    state;\n    qffields_T\t    fields;\n    qfline_T\t    *old_last = NULL;\n    int\t\t    adding = FALSE;\n    static efm_T    *fmt_first = NULL;\n    char_u\t    *efm;\n    static char_u   *last_efm = NULL;\n    int\t\t    retval = -1;\t// default: return error flag\n    int\t\t    status;\n\n    // Do not used the cached buffer, it may have been wiped out.\n    VIM_CLEAR(qf_last_bufname);\n\n    CLEAR_FIELD(state);\n    CLEAR_FIELD(fields);\n    if ((qf_alloc_fields(&fields) == FAIL) ||\n\t\t(qf_setup_state(&state, enc, efile, tv, buf,\n\t\t\t\t\tlnumfirst, lnumlast) == FAIL))\n\tgoto qf_init_end;\n\n    if (newlist || qf_idx == qi->qf_listcount)\n    {\n\t// make place for a new list\n\tqf_new_list(qi, qf_title);\n\tqf_idx = qi->qf_curlist;\n\tqfl = qf_get_list(qi, qf_idx);\n    }\n    else\n    {\n\t// Adding to existing list, use last entry.\n\tadding = TRUE;\n\tqfl = qf_get_list(qi, qf_idx);\n\tif (!qf_list_empty(qfl))\n\t    old_last = qfl->qf_last;\n    }\n\n    // Use the local value of 'errorformat' if it's set.\n    if (errorformat == p_efm && tv == NULL && *buf->b_p_efm != NUL)\n\tefm = buf->b_p_efm;\n    else\n\tefm = errorformat;\n\n    // If the errorformat didn't change between calls, then reuse the\n    // previously parsed values.\n    if (last_efm == NULL || (STRCMP(last_efm, efm) != 0))\n    {\n\t// free the previously parsed data\n\tVIM_CLEAR(last_efm);\n\tfree_efm_list(&fmt_first);\n\n\t// parse the current 'efm'\n\tfmt_first = parse_efm_option(efm);\n\tif (fmt_first != NULL)\n\t    last_efm = vim_strsave(efm);\n    }\n\n    if (fmt_first == NULL)\t// nothing found\n\tgoto error2;\n\n    // got_int is reset here, because it was probably set when killing the\n    // \":make\" command, but we still want to read the errorfile then.\n    got_int = FALSE;\n\n    // Read the lines in the error file one by one.\n    // Try to recognize one of the error formats in each line.\n    while (!got_int)\n    {\n\tstatus = qf_init_process_nextline(qfl, fmt_first, &state, &fields);\n\tif (status == QF_NOMEM)\t\t// memory alloc failure\n\t    goto qf_init_end;\n\tif (status == QF_END_OF_INPUT)\t// end of input\n\t    break;\n\tif (status == QF_FAIL)\n\t    goto error2;\n\n\tline_breakcheck();\n    }\n    if (state.fd == NULL || !ferror(state.fd))\n    {\n\tif (qfl->qf_index == 0)\n\t{\n\t    // no valid entry found\n\t    qfl->qf_ptr = qfl->qf_start;\n\t    qfl->qf_index = 1;\n\t    qfl->qf_nonevalid = TRUE;\n\t}\n\telse\n\t{\n\t    qfl->qf_nonevalid = FALSE;\n\t    if (qfl->qf_ptr == NULL)\n\t\tqfl->qf_ptr = qfl->qf_start;\n\t}\n\t// return number of matches\n\tretval = qfl->qf_count;\n\tgoto qf_init_end;\n    }\n    emsg(_(e_error_while_reading_errorfile));\nerror2:\n    if (!adding)\n    {\n\t// Error when creating a new list. Free the new list\n\tqf_free(qfl);\n\tqi->qf_listcount--;\n\tif (qi->qf_curlist > 0)\n\t    --qi->qf_curlist;\n    }\nqf_init_end:\n    if (qf_idx == qi->qf_curlist)\n\tqf_update_buffer(qi, old_last);\n    qf_cleanup_state(&state);\n    qf_free_fields(&fields);\n\n    return retval;\n}\n\n/*\n * Read the errorfile \"efile\" into memory, line by line, building the error\n * list. Set the error list's title to qf_title.\n * Return -1 for error, number of errors for success.\n */\n    int\nqf_init(win_T\t    *wp,\n\tchar_u\t    *efile,\n\tchar_u\t    *errorformat,\n\tint\t    newlist,\t\t// TRUE: start a new error list\n\tchar_u\t    *qf_title,\n\tchar_u\t    *enc)\n{\n    qf_info_T\t    *qi = &ql_info;\n\n    if (wp != NULL)\n    {\n\tqi = ll_get_or_alloc_list(wp);\n\tif (qi == NULL)\n\t    return FAIL;\n    }\n\n    return qf_init_ext(qi, qi->qf_curlist, efile, curbuf, NULL, errorformat,\n\t    newlist, (linenr_T)0, (linenr_T)0, qf_title, enc);\n}\n\n/*\n * Set the title of the specified quickfix list. Frees the previous title.\n * Prepends ':' to the title.\n */\n    static void\nqf_store_title(qf_list_T *qfl, char_u *title)\n{\n    VIM_CLEAR(qfl->qf_title);\n\n    if (title == NULL)\n\treturn;\n\n    char_u *p = alloc_id(STRLEN(title) + 2, aid_qf_title);\n\n    qfl->qf_title = p;\n    if (p != NULL)\n\tSTRCPY(p, title);\n}\n\n/*\n * The title of a quickfix/location list is set, by default, to the command\n * that created the quickfix list with the \":\" prefix.\n * Create a quickfix list title string by prepending \":\" to a user command.\n * Returns a pointer to a static buffer with the title.\n */\n    static char_u *\nqf_cmdtitle(char_u *cmd)\n{\n    static char_u qftitle_str[IOSIZE];\n\n    vim_snprintf((char *)qftitle_str, IOSIZE, \":%s\", (char *)cmd);\n    return qftitle_str;\n}\n\n/*\n * Return a pointer to the current list in the specified quickfix stack\n */\n    static qf_list_T *\nqf_get_curlist(qf_info_T *qi)\n{\n    return qf_get_list(qi, qi->qf_curlist);\n}\n\n/*\n * Prepare for adding a new quickfix list. If the current list is in the\n * middle of the stack, then all the following lists are freed and then\n * the new list is added.\n */\n    static void\nqf_new_list(qf_info_T *qi, char_u *qf_title)\n{\n    int\t\ti;\n    qf_list_T\t*qfl;\n\n    // If the current entry is not the last entry, delete entries beyond\n    // the current entry.  This makes it possible to browse in a tree-like\n    // way with \":grep\".\n    while (qi->qf_listcount > qi->qf_curlist + 1)\n\tqf_free(&qi->qf_lists[--qi->qf_listcount]);\n\n    // When the stack is full, remove to oldest entry\n    // Otherwise, add a new entry.\n    if (qi->qf_listcount == LISTCOUNT)\n    {\n\tqf_free(&qi->qf_lists[0]);\n\tfor (i = 1; i < LISTCOUNT; ++i)\n\t    qi->qf_lists[i - 1] = qi->qf_lists[i];\n\tqi->qf_curlist = LISTCOUNT - 1;\n    }\n    else\n\tqi->qf_curlist = qi->qf_listcount++;\n    qfl = qf_get_curlist(qi);\n    CLEAR_POINTER(qfl);\n    qf_store_title(qfl, qf_title);\n    qfl->qfl_type = qi->qfl_type;\n    qfl->qf_id = ++last_qf_id;\n}\n\n/*\n * Queue location list stack delete request.\n */\n    static void\nlocstack_queue_delreq(qf_info_T *qi)\n{\n    qf_delq_T\t*q;\n\n    q = ALLOC_ONE(qf_delq_T);\n    if (q == NULL)\n\treturn;\n\n    q->qi = qi;\n    q->next = qf_delq_head;\n    qf_delq_head = q;\n}\n\n/*\n * Return the global quickfix stack window buffer number.\n */\n    int\nqf_stack_get_bufnr(void)\n{\n    return ql_info.qf_bufnr;\n}\n\n/*\n * Wipe the quickfix window buffer (if present) for the specified\n * quickfix/location list.\n */\n    static void\nwipe_qf_buffer(qf_info_T *qi)\n{\n    buf_T\t*qfbuf;\n\n    if (qi->qf_bufnr == INVALID_QFBUFNR)\n\treturn;\n\n    qfbuf = buflist_findnr(qi->qf_bufnr);\n    if (qfbuf != NULL && qfbuf->b_nwindows == 0)\n    {\n\t// If the quickfix buffer is not loaded in any window, then\n\t// wipe the buffer.\n\tclose_buffer(NULL, qfbuf, DOBUF_WIPE, FALSE, FALSE);\n\tqi->qf_bufnr = INVALID_QFBUFNR;\n    }\n}\n\n/*\n * Free a location list stack\n */\n    static void\nll_free_all(qf_info_T **pqi)\n{\n    int\t\ti;\n    qf_info_T\t*qi;\n\n    qi = *pqi;\n    if (qi == NULL)\n\treturn;\n    *pqi = NULL;\t// Remove reference to this list\n\n    // If the location list is still in use, then queue the delete request\n    // to be processed later.\n    if (quickfix_busy > 0)\n    {\n\tlocstack_queue_delreq(qi);\n\treturn;\n    }\n\n    qi->qf_refcount--;\n    if (qi->qf_refcount < 1)\n    {\n\t// No references to this location list.\n\t// If the quickfix window buffer is loaded, then wipe it\n\twipe_qf_buffer(qi);\n\n\tfor (i = 0; i < qi->qf_listcount; ++i)\n\t    qf_free(qf_get_list(qi, i));\n\tvim_free(qi);\n    }\n}\n\n/*\n * Free all the quickfix/location lists in the stack.\n */\n    void\nqf_free_all(win_T *wp)\n{\n    int\t\ti;\n    qf_info_T\t*qi = &ql_info;\n\n    if (wp != NULL)\n    {\n\t// location list\n\tll_free_all(&wp->w_llist);\n\tll_free_all(&wp->w_llist_ref);\n    }\n    else\n\t// quickfix list\n\tfor (i = 0; i < qi->qf_listcount; ++i)\n\t    qf_free(qf_get_list(qi, i));\n}\n\n/*\n * Delay freeing of location list stacks when the quickfix code is running.\n * Used to avoid problems with autocmds freeing location list stacks when the\n * quickfix code is still referencing the stack.\n * Must always call decr_quickfix_busy() exactly once after this.\n */\n    static void\nincr_quickfix_busy(void)\n{\n    quickfix_busy++;\n}\n\n/*\n * Safe to free location list stacks. Process any delayed delete requests.\n */\n    static void\ndecr_quickfix_busy(void)\n{\n    if (--quickfix_busy == 0)\n    {\n\t// No longer referencing the location lists. Process all the pending\n\t// delete requests.\n\twhile (qf_delq_head != NULL)\n\t{\n\t    qf_delq_T\t*q = qf_delq_head;\n\n\t    qf_delq_head = q->next;\n\t    ll_free_all(&q->qi);\n\t    vim_free(q);\n\t}\n    }\n#ifdef ABORT_ON_INTERNAL_ERROR\n    if (quickfix_busy < 0)\n    {\n\temsg(\"quickfix_busy has become negative\");\n\tabort();\n    }\n#endif\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\ncheck_quickfix_busy(void)\n{\n    if (quickfix_busy != 0)\n    {\n\tsemsg(\"quickfix_busy not zero on exit: %ld\", (long)quickfix_busy);\n# ifdef ABORT_ON_INTERNAL_ERROR\n\tabort();\n# endif\n    }\n}\n#endif\n\n/*\n * Add an entry to the end of the list of errors.\n * Returns QF_OK on success or QF_FAIL on a memory allocation failure.\n */\n    static int\nqf_add_entry(\n    qf_list_T\t*qfl,\t\t// quickfix list entry\n    char_u\t*dir,\t\t// optional directory name\n    char_u\t*fname,\t\t// file name or NULL\n    char_u\t*module,\t// module name or NULL\n    int\t\tbufnum,\t\t// buffer number or zero\n    char_u\t*mesg,\t\t// message\n    long\tlnum,\t\t// line number\n    long\tend_lnum,\t// line number for end\n    int\t\tcol,\t\t// column\n    int\t\tend_col,\t// column for end\n    int\t\tvis_col,\t// using visual column\n    char_u\t*pattern,\t// search pattern\n    int\t\tnr,\t\t// error number\n    int\t\ttype,\t\t// type character\n    int\t\tvalid)\t\t// valid entry\n{\n    qfline_T\t*qfp;\n    qfline_T\t**lastp;\t// pointer to qf_last or NULL\n\n    if ((qfp = ALLOC_ONE_ID(qfline_T, aid_qf_qfline)) == NULL)\n\treturn QF_FAIL;\n    if (bufnum != 0)\n    {\n\tbuf_T *buf = buflist_findnr(bufnum);\n\n\tqfp->qf_fnum = bufnum;\n\tif (buf != NULL)\n\t    buf->b_has_qf_entry |=\n\t\tIS_QF_LIST(qfl) ? BUF_HAS_QF_ENTRY : BUF_HAS_LL_ENTRY;\n    }\n    else\n\tqfp->qf_fnum = qf_get_fnum(qfl, dir, fname);\n    if ((qfp->qf_text = vim_strsave(mesg)) == NULL)\n    {\n\tvim_free(qfp);\n\treturn QF_FAIL;\n    }\n    qfp->qf_lnum = lnum;\n    qfp->qf_end_lnum = end_lnum;\n    qfp->qf_col = col;\n    qfp->qf_end_col = end_col;\n    qfp->qf_viscol = vis_col;\n    if (pattern == NULL || *pattern == NUL)\n\tqfp->qf_pattern = NULL;\n    else if ((qfp->qf_pattern = vim_strsave(pattern)) == NULL)\n    {\n\tvim_free(qfp->qf_text);\n\tvim_free(qfp);\n\treturn QF_FAIL;\n    }\n    if (module == NULL || *module == NUL)\n\tqfp->qf_module = NULL;\n    else if ((qfp->qf_module = vim_strsave(module)) == NULL)\n    {\n\tvim_free(qfp->qf_text);\n\tvim_free(qfp->qf_pattern);\n\tvim_free(qfp);\n\treturn QF_FAIL;\n    }\n    qfp->qf_nr = nr;\n    if (type != 1 && !vim_isprintc(type)) // only printable chars allowed\n\ttype = 0;\n    qfp->qf_type = type;\n    qfp->qf_valid = valid;\n\n    lastp = &qfl->qf_last;\n    if (qf_list_empty(qfl))\t\t// first element in the list\n    {\n\tqfl->qf_start = qfp;\n\tqfl->qf_ptr = qfp;\n\tqfl->qf_index = 0;\n\tqfp->qf_prev = NULL;\n    }\n    else\n    {\n\tqfp->qf_prev = *lastp;\n\t(*lastp)->qf_next = qfp;\n    }\n    qfp->qf_next = NULL;\n    qfp->qf_cleared = FALSE;\n    *lastp = qfp;\n    ++qfl->qf_count;\n    if (qfl->qf_index == 0 && qfp->qf_valid)\t// first valid entry\n    {\n\tqfl->qf_index = qfl->qf_count;\n\tqfl->qf_ptr = qfp;\n    }\n\n    return QF_OK;\n}\n\n/*\n * Allocate a new quickfix/location list stack\n */\n    static qf_info_T *\nqf_alloc_stack(qfltype_T qfltype)\n{\n    qf_info_T *qi;\n\n    qi = ALLOC_CLEAR_ONE_ID(qf_info_T, aid_qf_qfinfo);\n    if (qi == NULL)\n\treturn NULL;\n\n    qi->qf_refcount++;\n    qi->qfl_type = qfltype;\n    qi->qf_bufnr = INVALID_QFBUFNR;\n    return qi;\n}\n\n/*\n * Return the location list stack for window 'wp'.\n * If not present, allocate a location list stack\n */\n    static qf_info_T *\nll_get_or_alloc_list(win_T *wp)\n{\n    if (IS_LL_WINDOW(wp))\n\t// For a location list window, use the referenced location list\n\treturn wp->w_llist_ref;\n\n    // For a non-location list window, w_llist_ref should not point to a\n    // location list.\n    ll_free_all(&wp->w_llist_ref);\n\n    if (wp->w_llist == NULL)\n\twp->w_llist = qf_alloc_stack(QFLT_LOCATION);\t// new location list\n    return wp->w_llist;\n}\n\n/*\n * Get the quickfix/location list stack to use for the specified Ex command.\n * For a location list command, returns the stack for the current window.  If\n * the location list is not found, then returns NULL and prints an error\n * message if 'print_emsg' is TRUE.\n */\n    static qf_info_T *\nqf_cmd_get_stack(exarg_T *eap, int print_emsg)\n{\n    qf_info_T\t*qi = &ql_info;\n\n    if (is_loclist_cmd(eap->cmdidx))\n    {\n\tqi = GET_LOC_LIST(curwin);\n\tif (qi == NULL)\n\t{\n\t    if (print_emsg)\n\t\temsg(_(e_no_location_list));\n\t    return NULL;\n\t}\n    }\n\n    return qi;\n}\n\n/*\n * Get the quickfix/location list stack to use for the specified Ex command.\n * For a location list command, returns the stack for the current window.\n * If the location list is not present, then allocates a new one.\n * Returns NULL if the allocation fails.  For a location list command, sets\n * 'pwinp' to curwin.\n */\n    static qf_info_T *\nqf_cmd_get_or_alloc_stack(exarg_T *eap, win_T **pwinp)\n{\n    qf_info_T\t*qi = &ql_info;\n\n    if (is_loclist_cmd(eap->cmdidx))\n    {\n\tqi = ll_get_or_alloc_list(curwin);\n\tif (qi == NULL)\n\t    return NULL;\n\t*pwinp = curwin;\n    }\n\n    return qi;\n}\n\n/*\n * Copy location list entries from 'from_qfl' to 'to_qfl'.\n */\n    static int\ncopy_loclist_entries(qf_list_T *from_qfl, qf_list_T *to_qfl)\n{\n    int\t\ti;\n    qfline_T    *from_qfp;\n    qfline_T    *prevp;\n\n    // copy all the location entries in this list\n    FOR_ALL_QFL_ITEMS(from_qfl, from_qfp, i)\n    {\n\tif (qf_add_entry(to_qfl,\n\t\t    NULL,\n\t\t    NULL,\n\t\t    from_qfp->qf_module,\n\t\t    0,\n\t\t    from_qfp->qf_text,\n\t\t    from_qfp->qf_lnum,\n\t\t    from_qfp->qf_end_lnum,\n\t\t    from_qfp->qf_col,\n\t\t    from_qfp->qf_end_col,\n\t\t    from_qfp->qf_viscol,\n\t\t    from_qfp->qf_pattern,\n\t\t    from_qfp->qf_nr,\n\t\t    0,\n\t\t    from_qfp->qf_valid) == QF_FAIL)\n\t    return FAIL;\n\n\t// qf_add_entry() will not set the qf_num field, as the\n\t// directory and file names are not supplied. So the qf_fnum\n\t// field is copied here.\n\tprevp = to_qfl->qf_last;\n\tprevp->qf_fnum = from_qfp->qf_fnum;\t// file number\n\tprevp->qf_type = from_qfp->qf_type;\t// error type\n\tif (from_qfl->qf_ptr == from_qfp)\n\t    to_qfl->qf_ptr = prevp;\t\t// current location\n    }\n\n    return OK;\n}\n\n/*\n * Copy the specified location list 'from_qfl' to 'to_qfl'.\n */\n    static int\ncopy_loclist(qf_list_T *from_qfl, qf_list_T *to_qfl)\n{\n    // Some of the fields are populated by qf_add_entry()\n    to_qfl->qfl_type = from_qfl->qfl_type;\n    to_qfl->qf_nonevalid = from_qfl->qf_nonevalid;\n    to_qfl->qf_count = 0;\n    to_qfl->qf_index = 0;\n    to_qfl->qf_start = NULL;\n    to_qfl->qf_last = NULL;\n    to_qfl->qf_ptr = NULL;\n    if (from_qfl->qf_title != NULL)\n\tto_qfl->qf_title = vim_strsave(from_qfl->qf_title);\n    else\n\tto_qfl->qf_title = NULL;\n    if (from_qfl->qf_ctx != NULL)\n    {\n\tto_qfl->qf_ctx = alloc_tv();\n\tif (to_qfl->qf_ctx != NULL)\n\t    copy_tv(from_qfl->qf_ctx, to_qfl->qf_ctx);\n    }\n    else\n\tto_qfl->qf_ctx = NULL;\n    if (from_qfl->qf_qftf_cb.cb_name != NULL)\n\tcopy_callback(&to_qfl->qf_qftf_cb, &from_qfl->qf_qftf_cb);\n    else\n\tto_qfl->qf_qftf_cb.cb_name = NULL;\n\n    if (from_qfl->qf_count)\n\tif (copy_loclist_entries(from_qfl, to_qfl) == FAIL)\n\t    return FAIL;\n\n    to_qfl->qf_index = from_qfl->qf_index;\t// current index in the list\n\n    // Assign a new ID for the location list\n    to_qfl->qf_id = ++last_qf_id;\n    to_qfl->qf_changedtick = 0L;\n\n    // When no valid entries are present in the list, qf_ptr points to\n    // the first item in the list\n    if (to_qfl->qf_nonevalid)\n    {\n\tto_qfl->qf_ptr = to_qfl->qf_start;\n\tto_qfl->qf_index = 1;\n    }\n\n    return OK;\n}\n\n/*\n * Copy the location list stack 'from' window to 'to' window.\n */\n    void\ncopy_loclist_stack(win_T *from, win_T *to)\n{\n    qf_info_T\t*qi;\n    int\t\tidx;\n\n    // When copying from a location list window, copy the referenced\n    // location list. For other windows, copy the location list for\n    // that window.\n    if (IS_LL_WINDOW(from))\n\tqi = from->w_llist_ref;\n    else\n\tqi = from->w_llist;\n\n    if (qi == NULL)\t\t    // no location list to copy\n\treturn;\n\n    // allocate a new location list\n    if ((to->w_llist = qf_alloc_stack(QFLT_LOCATION)) == NULL)\n\treturn;\n\n    to->w_llist->qf_listcount = qi->qf_listcount;\n\n    // Copy the location lists one at a time\n    for (idx = 0; idx < qi->qf_listcount; ++idx)\n    {\n\tto->w_llist->qf_curlist = idx;\n\n\tif (copy_loclist(qf_get_list(qi, idx),\n\t\t\tqf_get_list(to->w_llist, idx)) == FAIL)\n\t{\n\t    qf_free_all(to);\n\t    return;\n\t}\n    }\n\n    to->w_llist->qf_curlist = qi->qf_curlist;\t// current list\n}\n\n/*\n * Get buffer number for file \"directory/fname\".\n * Also sets the b_has_qf_entry flag.\n */\n    static int\nqf_get_fnum(qf_list_T *qfl, char_u *directory, char_u *fname)\n{\n    char_u\t*ptr = NULL;\n    buf_T\t*buf;\n    char_u\t*bufname;\n\n    if (fname == NULL || *fname == NUL)\t\t// no file name\n\treturn 0;\n\n#ifdef VMS\n    vms_remove_version(fname);\n#endif\n#ifdef BACKSLASH_IN_FILENAME\n    if (directory != NULL)\n\tslash_adjust(directory);\n    slash_adjust(fname);\n#endif\n    if (directory != NULL && !vim_isAbsName(fname)\n\t    && (ptr = concat_fnames(directory, fname, TRUE)) != NULL)\n    {\n\t// Here we check if the file really exists.\n\t// This should normally be true, but if make works without\n\t// \"leaving directory\"-messages we might have missed a\n\t// directory change.\n\tif (mch_getperm(ptr) < 0)\n\t{\n\t    vim_free(ptr);\n\t    directory = qf_guess_filepath(qfl, fname);\n\t    if (directory)\n\t\tptr = concat_fnames(directory, fname, TRUE);\n\t    else\n\t\tptr = vim_strsave(fname);\n\t}\n\t// Use concatenated directory name and file name\n\tbufname = ptr;\n    }\n    else\n\tbufname = fname;\n\n    if (qf_last_bufname != NULL && STRCMP(bufname, qf_last_bufname) == 0\n\t    && bufref_valid(&qf_last_bufref))\n    {\n\tbuf = qf_last_bufref.br_buf;\n\tvim_free(ptr);\n    }\n    else\n    {\n\tvim_free(qf_last_bufname);\n\tbuf = buflist_new(bufname, NULL, (linenr_T)0, BLN_NOOPT);\n\tif (bufname == ptr)\n\t    qf_last_bufname = bufname;\n\telse\n\t    qf_last_bufname = vim_strsave(bufname);\n\tset_bufref(&qf_last_bufref, buf);\n    }\n    if (buf == NULL)\n\treturn 0;\n\n    buf->b_has_qf_entry =\n\t\t\tIS_QF_LIST(qfl) ? BUF_HAS_QF_ENTRY : BUF_HAS_LL_ENTRY;\n    return buf->b_fnum;\n}\n\n/*\n * Push dirbuf onto the directory stack and return pointer to actual dir or\n * NULL on error.\n */\n    static char_u *\nqf_push_dir(char_u *dirbuf, struct dir_stack_T **stackptr, int is_file_stack)\n{\n    struct dir_stack_T  *ds_new;\n    struct dir_stack_T  *ds_ptr;\n\n    // allocate new stack element and hook it in\n    ds_new = ALLOC_ONE_ID(struct dir_stack_T, aid_qf_dirstack);\n    if (ds_new == NULL)\n\treturn NULL;\n\n    ds_new->next = *stackptr;\n    *stackptr = ds_new;\n\n    // store directory on the stack\n    if (vim_isAbsName(dirbuf)\n\t    || (*stackptr)->next == NULL\n\t    || is_file_stack)\n\t(*stackptr)->dirname = vim_strsave(dirbuf);\n    else\n    {\n\t// Okay we don't have an absolute path.\n\t// dirbuf must be a subdir of one of the directories on the stack.\n\t// Let's search...\n\tds_new = (*stackptr)->next;\n\t(*stackptr)->dirname = NULL;\n\twhile (ds_new)\n\t{\n\t    vim_free((*stackptr)->dirname);\n\t    (*stackptr)->dirname = concat_fnames(ds_new->dirname, dirbuf,\n\t\t    TRUE);\n\t    if (mch_isdir((*stackptr)->dirname) == TRUE)\n\t\tbreak;\n\n\t    ds_new = ds_new->next;\n\t}\n\n\t// clean up all dirs we already left\n\twhile ((*stackptr)->next != ds_new)\n\t{\n\t    ds_ptr = (*stackptr)->next;\n\t    (*stackptr)->next = (*stackptr)->next->next;\n\t    vim_free(ds_ptr->dirname);\n\t    vim_free(ds_ptr);\n\t}\n\n\t// Nothing found -> it must be on top level\n\tif (ds_new == NULL)\n\t{\n\t    vim_free((*stackptr)->dirname);\n\t    (*stackptr)->dirname = vim_strsave(dirbuf);\n\t}\n    }\n\n    if ((*stackptr)->dirname != NULL)\n\treturn (*stackptr)->dirname;\n    else\n    {\n\tds_ptr = *stackptr;\n\t*stackptr = (*stackptr)->next;\n\tvim_free(ds_ptr);\n\treturn NULL;\n    }\n}\n\n/*\n * pop dirbuf from the directory stack and return previous directory or NULL if\n * stack is empty\n */\n    static char_u *\nqf_pop_dir(struct dir_stack_T **stackptr)\n{\n    struct dir_stack_T  *ds_ptr;\n\n    // TODO: Should we check if dirbuf is the directory on top of the stack?\n    // What to do if it isn't?\n\n    // pop top element and free it\n    if (*stackptr != NULL)\n    {\n\tds_ptr = *stackptr;\n\t*stackptr = (*stackptr)->next;\n\tvim_free(ds_ptr->dirname);\n\tvim_free(ds_ptr);\n    }\n\n    // return NEW top element as current dir or NULL if stack is empty\n    return *stackptr ? (*stackptr)->dirname : NULL;\n}\n\n/*\n * clean up directory stack\n */\n    static void\nqf_clean_dir_stack(struct dir_stack_T **stackptr)\n{\n    struct dir_stack_T  *ds_ptr;\n\n    while ((ds_ptr = *stackptr) != NULL)\n    {\n\t*stackptr = (*stackptr)->next;\n\tvim_free(ds_ptr->dirname);\n\tvim_free(ds_ptr);\n    }\n}\n\n/*\n * Check in which directory of the directory stack the given file can be\n * found.\n * Returns a pointer to the directory name or NULL if not found.\n * Cleans up intermediate directory entries.\n *\n * TODO: How to solve the following problem?\n * If we have this directory tree:\n *     ./\n *     ./aa\n *     ./aa/bb\n *     ./bb\n *     ./bb/x.c\n * and make says:\n *     making all in aa\n *     making all in bb\n *     x.c:9: Error\n * Then qf_push_dir thinks we are in ./aa/bb, but we are in ./bb.\n * qf_guess_filepath will return NULL.\n */\n    static char_u *\nqf_guess_filepath(qf_list_T *qfl, char_u *filename)\n{\n    struct dir_stack_T     *ds_ptr;\n    struct dir_stack_T     *ds_tmp;\n    char_u\t\t   *fullname;\n\n    // no dirs on the stack - there's nothing we can do\n    if (qfl->qf_dir_stack == NULL)\n\treturn NULL;\n\n    ds_ptr = qfl->qf_dir_stack->next;\n    fullname = NULL;\n    while (ds_ptr)\n    {\n\tvim_free(fullname);\n\tfullname = concat_fnames(ds_ptr->dirname, filename, TRUE);\n\n\t// If concat_fnames failed, just go on. The worst thing that can happen\n\t// is that we delete the entire stack.\n\tif ((fullname != NULL) && (mch_getperm(fullname) >= 0))\n\t    break;\n\n\tds_ptr = ds_ptr->next;\n    }\n\n    vim_free(fullname);\n\n    // clean up all dirs we already left\n    while (qfl->qf_dir_stack->next != ds_ptr)\n    {\n\tds_tmp = qfl->qf_dir_stack->next;\n\tqfl->qf_dir_stack->next = qfl->qf_dir_stack->next->next;\n\tvim_free(ds_tmp->dirname);\n\tvim_free(ds_tmp);\n    }\n\n    return ds_ptr == NULL ? NULL : ds_ptr->dirname;\n}\n\n/*\n * Returns TRUE if a quickfix/location list with the given identifier exists.\n */\n    static int\nqflist_valid(win_T *wp, int_u qf_id)\n{\n    qf_info_T\t*qi = &ql_info;\n    int\t\ti;\n\n    if (wp != NULL)\n    {\n\tif (!win_valid(wp))\n\t    return FALSE;\n\tqi = GET_LOC_LIST(wp);\t    // Location list\n\tif (qi == NULL)\n\t    return FALSE;\n    }\n\n    for (i = 0; i < qi->qf_listcount; ++i)\n\tif (qi->qf_lists[i].qf_id == qf_id)\n\t    return TRUE;\n\n    return FALSE;\n}\n\n/*\n * When loading a file from the quickfix, the autocommands may modify it.\n * This may invalidate the current quickfix entry.  This function checks\n * whether an entry is still present in the quickfix list.\n * Similar to location list.\n */\n    static int\nis_qf_entry_present(qf_list_T *qfl, qfline_T *qf_ptr)\n{\n    qfline_T\t*qfp;\n    int\t\ti;\n\n    // Search for the entry in the current list\n    FOR_ALL_QFL_ITEMS(qfl, qfp, i)\n\tif (qfp == qf_ptr)\n\t    break;\n\n    if (i > qfl->qf_count) // Entry is not found\n\treturn FALSE;\n\n    return TRUE;\n}\n\n/*\n * Get the next valid entry in the current quickfix/location list. The search\n * starts from the current entry.  Returns NULL on failure.\n */\n    static qfline_T *\nget_next_valid_entry(\n\tqf_list_T\t*qfl,\n\tqfline_T\t*qf_ptr,\n\tint\t\t*qf_index,\n\tint\t\tdir)\n{\n    int\t\t\tidx;\n    int\t\t\told_qf_fnum;\n\n    idx = *qf_index;\n    old_qf_fnum = qf_ptr->qf_fnum;\n\n    do\n    {\n\tif (idx == qfl->qf_count || qf_ptr->qf_next == NULL)\n\t    return NULL;\n\t++idx;\n\tqf_ptr = qf_ptr->qf_next;\n    } while ((!qfl->qf_nonevalid && !qf_ptr->qf_valid)\n\t    || (dir == FORWARD_FILE && qf_ptr->qf_fnum == old_qf_fnum));\n\n    *qf_index = idx;\n    return qf_ptr;\n}\n\n/*\n * Get the previous valid entry in the current quickfix/location list. The\n * search starts from the current entry.  Returns NULL on failure.\n */\n    static qfline_T *\nget_prev_valid_entry(\n\tqf_list_T\t*qfl,\n\tqfline_T\t*qf_ptr,\n\tint\t\t*qf_index,\n\tint\t\tdir)\n{\n    int\t\t\tidx;\n    int\t\t\told_qf_fnum;\n\n    idx = *qf_index;\n    old_qf_fnum = qf_ptr->qf_fnum;\n\n    do\n    {\n\tif (idx == 1 || qf_ptr->qf_prev == NULL)\n\t    return NULL;\n\t--idx;\n\tqf_ptr = qf_ptr->qf_prev;\n    } while ((!qfl->qf_nonevalid && !qf_ptr->qf_valid)\n\t    || (dir == BACKWARD_FILE && qf_ptr->qf_fnum == old_qf_fnum));\n\n    *qf_index = idx;\n    return qf_ptr;\n}\n\n/*\n * Get the n'th (errornr) previous/next valid entry from the current entry in\n * the quickfix list.\n *   dir == FORWARD or FORWARD_FILE: next valid entry\n *   dir == BACKWARD or BACKWARD_FILE: previous valid entry\n */\n    static qfline_T *\nget_nth_valid_entry(\n\tqf_list_T\t*qfl,\n\tint\t\terrornr,\n\tint\t\tdir,\n\tint\t\t*new_qfidx)\n{\n    qfline_T\t\t*qf_ptr = qfl->qf_ptr;\n    int\t\t\tqf_idx = qfl->qf_index;\n    qfline_T\t\t*prev_qf_ptr;\n    int\t\t\tprev_index;\n    char\t\t*err = e_no_more_items;\n\n    while (errornr--)\n    {\n\tprev_qf_ptr = qf_ptr;\n\tprev_index = qf_idx;\n\n\tif (dir == FORWARD || dir == FORWARD_FILE)\n\t    qf_ptr = get_next_valid_entry(qfl, qf_ptr, &qf_idx, dir);\n\telse\n\t    qf_ptr = get_prev_valid_entry(qfl, qf_ptr, &qf_idx, dir);\n\tif (qf_ptr == NULL)\n\t{\n\t    qf_ptr = prev_qf_ptr;\n\t    qf_idx = prev_index;\n\t    if (err != NULL)\n\t    {\n\t\temsg(_(err));\n\t\treturn NULL;\n\t    }\n\t    break;\n\t}\n\n\terr = NULL;\n    }\n\n    *new_qfidx = qf_idx;\n    return qf_ptr;\n}\n\n/*\n * Get n'th (errornr) quickfix entry from the current entry in the quickfix\n * list 'qfl'. Returns a pointer to the new entry and the index in 'new_qfidx'\n */\n    static qfline_T *\nget_nth_entry(qf_list_T *qfl, int errornr, int *new_qfidx)\n{\n    qfline_T\t*qf_ptr = qfl->qf_ptr;\n    int\t\tqf_idx = qfl->qf_index;\n\n    // New error number is less than the current error number\n    while (errornr < qf_idx && qf_idx > 1 && qf_ptr->qf_prev != NULL)\n    {\n\t--qf_idx;\n\tqf_ptr = qf_ptr->qf_prev;\n    }\n    // New error number is greater than the current error number\n    while (errornr > qf_idx && qf_idx < qfl->qf_count &&\n\t\t\t\t\t\tqf_ptr->qf_next != NULL)\n    {\n\t++qf_idx;\n\tqf_ptr = qf_ptr->qf_next;\n    }\n\n    *new_qfidx = qf_idx;\n    return qf_ptr;\n}\n\n/*\n * Get a entry specified by 'errornr' and 'dir' from the current\n * quickfix/location list. 'errornr' specifies the index of the entry and 'dir'\n * specifies the direction (FORWARD/BACKWARD/FORWARD_FILE/BACKWARD_FILE).\n * Returns a pointer to the entry and the index of the new entry is stored in\n * 'new_qfidx'.\n */\n    static qfline_T *\nqf_get_entry(\n\tqf_list_T\t*qfl,\n\tint\t\terrornr,\n\tint\t\tdir,\n\tint\t\t*new_qfidx)\n{\n    qfline_T\t*qf_ptr = qfl->qf_ptr;\n    int\t\tqfidx = qfl->qf_index;\n\n    if (dir != 0)    // next/prev valid entry\n\tqf_ptr = get_nth_valid_entry(qfl, errornr, dir, &qfidx);\n    else if (errornr != 0)\t// go to specified number\n\tqf_ptr = get_nth_entry(qfl, errornr, &qfidx);\n\n    *new_qfidx = qfidx;\n    return qf_ptr;\n}\n\n/*\n * Find a window displaying a Vim help file in the current tab page.\n */\n    static win_T *\nqf_find_help_win(void)\n{\n    win_T *wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (bt_help(wp->w_buffer))\n\t    return wp;\n\n    return NULL;\n}\n\n/*\n * Set the location list for the specified window to 'qi'.\n */\n    static void\nwin_set_loclist(win_T *wp, qf_info_T *qi)\n{\n    wp->w_llist = qi;\n    qi->qf_refcount++;\n}\n\n/*\n * Find a help window or open one. If 'newwin' is TRUE, then open a new help\n * window.\n */\n    static int\njump_to_help_window(qf_info_T *qi, int newwin, int *opened_window)\n{\n    win_T\t*wp;\n    int\t\tflags;\n\n    if (cmdmod.cmod_tab != 0 || newwin)\n\twp = NULL;\n    else\n\twp = qf_find_help_win();\n    if (wp != NULL && wp->w_buffer->b_nwindows > 0)\n\twin_enter(wp, TRUE);\n    else\n    {\n\t// Split off help window; put it at far top if no position\n\t// specified, the current window is vertically split and narrow.\n\tflags = WSP_HELP;\n\tif (cmdmod.cmod_split == 0 && curwin->w_width != Columns\n\t\t&& curwin->w_width < 80)\n\t    flags |= WSP_TOP;\n\t// If the user asks to open a new window, then copy the location list.\n\t// Otherwise, don't copy the location list.\n\tif (IS_LL_STACK(qi) && !newwin)\n\t    flags |= WSP_NEWLOC;\n\n\tif (win_split(0, flags) == FAIL)\n\t    return FAIL;\n\n\t*opened_window = TRUE;\n\n\tif (curwin->w_height < p_hh)\n\t    win_setheight((int)p_hh);\n\n\t// When using location list, the new window should use the supplied\n\t// location list. If the user asks to open a new window, then the new\n\t// window will get a copy of the location list.\n\tif (IS_LL_STACK(qi) && !newwin)\n\t    win_set_loclist(curwin, qi);\n    }\n\n    if (!p_im)\n\trestart_edit = 0;\t    // don't want insert mode in help file\n\n    return OK;\n}\n\n/*\n * Find a non-quickfix window using the given location list stack in the\n * current tabpage.\n * Returns NULL if a matching window is not found.\n */\n    static win_T *\nqf_find_win_with_loclist(qf_info_T *ll)\n{\n    win_T\t*wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_llist == ll && !bt_quickfix(wp->w_buffer))\n\t    return wp;\n\n    return NULL;\n}\n\n/*\n * Find a window containing a normal buffer in the current tab page.\n */\n    static win_T *\nqf_find_win_with_normal_buf(void)\n{\n    win_T\t*wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (bt_normal(wp->w_buffer))\n\t    return wp;\n\n    return NULL;\n}\n\n/*\n * Go to a window in any tabpage containing the specified file.  Returns TRUE\n * if successfully jumped to the window. Otherwise returns FALSE.\n */\n    static int\nqf_goto_tabwin_with_file(int fnum)\n{\n    tabpage_T\t*tp;\n    win_T\t*wp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tif (wp->w_buffer->b_fnum == fnum)\n\t{\n\t    goto_tabpage_win(tp, wp);\n\t    return TRUE;\n\t}\n\n    return FALSE;\n}\n\n/*\n * Create a new window to show a file above the quickfix window. Called when\n * only the quickfix window is present.\n */\n    static int\nqf_open_new_file_win(qf_info_T *ll_ref)\n{\n    int\t\tflags;\n\n    flags = WSP_ABOVE;\n    if (ll_ref != NULL)\n\tflags |= WSP_NEWLOC;\n    if (win_split(0, flags) == FAIL)\n\treturn FAIL;\t\t// not enough room for window\n    p_swb = empty_option;\t// don't split again\n    swb_flags = 0;\n    RESET_BINDING(curwin);\n    if (ll_ref != NULL)\n\t// The new window should use the location list from the\n\t// location list window\n\twin_set_loclist(curwin, ll_ref);\n    return OK;\n}\n\n/*\n * Go to a window that shows the right buffer. If the window is not found, go\n * to the window just above the location list window. This is used for opening\n * a file from a location window and not from a quickfix window. If some usable\n * window is previously found, then it is supplied in 'use_win'.\n */\n    static void\nqf_goto_win_with_ll_file(win_T *use_win, int qf_fnum, qf_info_T *ll_ref)\n{\n    win_T\t*win = use_win;\n\n    if (win == NULL)\n    {\n\t// Find the window showing the selected file in the current tab page.\n\tFOR_ALL_WINDOWS(win)\n\t    if (win->w_buffer->b_fnum == qf_fnum)\n\t\tbreak;\n\tif (win == NULL)\n\t{\n\t    // Find a previous usable window\n\t    win = curwin;\n\t    do\n\t    {\n\t\tif (bt_normal(win->w_buffer))\n\t\t    break;\n\t\tif (win->w_prev == NULL)\n\t\t    win = lastwin;\t// wrap around the top\n\t\telse\n\t\t    win = win->w_prev; // go to previous window\n\t    } while (win != curwin);\n\t}\n    }\n    win_goto(win);\n\n    // If the location list for the window is not set, then set it\n    // to the location list from the location window\n    if (win->w_llist == NULL && ll_ref != NULL)\n\twin_set_loclist(win, ll_ref);\n}\n\n/*\n * Go to a window that contains the specified buffer 'qf_fnum'. If a window is\n * not found, then go to the window just above the quickfix window. This is\n * used for opening a file from a quickfix window and not from a location\n * window.\n */\n    static void\nqf_goto_win_with_qfl_file(int qf_fnum)\n{\n    win_T\t*win;\n    win_T\t*altwin;\n\n    win = curwin;\n    altwin = NULL;\n    for (;;)\n    {\n\tif (win->w_buffer->b_fnum == qf_fnum)\n\t    break;\n\tif (win->w_prev == NULL)\n\t    win = lastwin;\t// wrap around the top\n\telse\n\t    win = win->w_prev;\t// go to previous window\n\n\tif (IS_QF_WINDOW(win))\n\t{\n\t    // Didn't find it, go to the window before the quickfix\n\t    // window, unless 'switchbuf' contains 'uselast': in this case we\n\t    // try to jump to the previously used window first.\n\t    if ((swb_flags & SWB_USELAST) && win_valid(prevwin))\n\t\twin = prevwin;\n\t    else if (altwin != NULL)\n\t\twin = altwin;\n\t    else if (curwin->w_prev != NULL)\n\t\twin = curwin->w_prev;\n\t    else\n\t\twin = curwin->w_next;\n\t    break;\n\t}\n\n\t// Remember a usable window.\n\tif (altwin == NULL && !win->w_p_pvw && bt_normal(win->w_buffer))\n\t    altwin = win;\n    }\n\n    win_goto(win);\n}\n\n/*\n * Find a suitable window for opening a file (qf_fnum) from the\n * quickfix/location list and jump to it.  If the file is already opened in a\n * window, jump to it. Otherwise open a new window to display the file. If\n * 'newwin' is TRUE, then always open a new window. This is called from either\n * a quickfix or a location list window.\n */\n    static int\nqf_jump_to_usable_window(int qf_fnum, int newwin, int *opened_window)\n{\n    win_T\t*usable_wp = NULL;\n    int\t\tusable_win = FALSE;\n    qf_info_T\t*ll_ref = NULL;\n\n    // If opening a new window, then don't use the location list referred by\n    // the current window.  Otherwise two windows will refer to the same\n    // location list.\n    if (!newwin)\n\tll_ref = curwin->w_llist_ref;\n\n    if (ll_ref != NULL)\n    {\n\t// Find a non-quickfix window with this location list\n\tusable_wp = qf_find_win_with_loclist(ll_ref);\n\tif (usable_wp != NULL)\n\t    usable_win = TRUE;\n    }\n\n    if (!usable_win)\n    {\n\t// Locate a window showing a normal buffer\n\twin_T\t*win = qf_find_win_with_normal_buf();\n\tif (win != NULL)\n\t    usable_win = TRUE;\n    }\n\n    // If no usable window is found and 'switchbuf' contains \"usetab\"\n    // then search in other tabs.\n    if (!usable_win && (swb_flags & SWB_USETAB))\n\tusable_win = qf_goto_tabwin_with_file(qf_fnum);\n\n    // If there is only one window and it is the quickfix window, create a\n    // new one above the quickfix window.\n    if ((ONE_WINDOW && bt_quickfix(curbuf)) || !usable_win || newwin)\n    {\n\tif (qf_open_new_file_win(ll_ref) != OK)\n\t    return FAIL;\n\t*opened_window = TRUE;\t// close it when fail\n    }\n    else\n    {\n\tif (curwin->w_llist_ref != NULL)\t// In a location window\n\t    qf_goto_win_with_ll_file(usable_wp, qf_fnum, ll_ref);\n\telse\t\t\t\t\t// In a quickfix window\n\t    qf_goto_win_with_qfl_file(qf_fnum);\n    }\n\n    return OK;\n}\n\n/*\n * Edit the selected file or help file.\n * Returns OK if successfully edited the file, FAIL on failing to open the\n * buffer and QF_ABORT if the quickfix/location list was freed by an autocmd\n * when opening the buffer.\n */\n    static int\nqf_jump_edit_buffer(\n\tqf_info_T\t*qi,\n\tqfline_T\t*qf_ptr,\n\tint\t\tforceit,\n\tint\t\tprev_winid,\n\tint\t\t*opened_window)\n{\n    qf_list_T\t*qfl = qf_get_curlist(qi);\n    int\t\told_changedtick = qfl->qf_changedtick;\n    qfltype_T\tqfl_type = qfl->qfl_type;\n    int\t\tretval = OK;\n    int\t\told_qf_curlist = qi->qf_curlist;\n    int\t\tsave_qfid = qfl->qf_id;\n\n    if (qf_ptr->qf_type == 1)\n    {\n\t// Open help file (do_ecmd() will set b_help flag, readfile() will\n\t// set b_p_ro flag).\n\tif (!can_abandon(curbuf, forceit))\n\t{\n\t    no_write_message();\n\t    return FAIL;\n\t}\n\n\tretval = do_ecmd(qf_ptr->qf_fnum, NULL, NULL, NULL, (linenr_T)1,\n\t\tECMD_HIDE + ECMD_SET_HELP,\n\t\tprev_winid == curwin->w_id ? curwin : NULL);\n    }\n    else\n\tretval = buflist_getfile(qf_ptr->qf_fnum,\n\t\t(linenr_T)1, GETF_SETMARK | GETF_SWITCH, forceit);\n\n    // If a location list, check whether the associated window is still\n    // present.\n    if (qfl_type == QFLT_LOCATION)\n    {\n\twin_T\t*wp = win_id2wp(prev_winid);\n\n\tif (wp == NULL && curwin->w_llist != qi)\n\t{\n\t    emsg(_(e_current_window_was_closed));\n\t    *opened_window = FALSE;\n\t    return QF_ABORT;\n\t}\n    }\n\n    if (qfl_type == QFLT_QUICKFIX && !qflist_valid(NULL, save_qfid))\n    {\n\temsg(_(e_current_quickfix_list_was_changed));\n\treturn QF_ABORT;\n    }\n\n    // Check if the list was changed.  The pointers may happen to be identical,\n    // thus also check qf_changedtick.\n    if (old_qf_curlist != qi->qf_curlist\n\t    || old_changedtick != qfl->qf_changedtick\n\t    || !is_qf_entry_present(qfl, qf_ptr))\n    {\n\tif (qfl_type == QFLT_QUICKFIX)\n\t    emsg(_(e_current_quickfix_list_was_changed));\n\telse\n\t    emsg(_(e_current_location_list_was_changed));\n\treturn QF_ABORT;\n    }\n\n    return retval;\n}\n\n/*\n * Go to the error line in the current file using either line/column number or\n * a search pattern.\n */\n    static void\nqf_jump_goto_line(\n\tlinenr_T\tqf_lnum,\n\tint\t\tqf_col,\n\tchar_u\t\tqf_viscol,\n\tchar_u\t\t*qf_pattern)\n{\n    linenr_T\t\ti;\n\n    if (qf_pattern == NULL)\n    {\n\t// Go to line with error, unless qf_lnum is 0.\n\ti = qf_lnum;\n\tif (i > 0)\n\t{\n\t    if (i > curbuf->b_ml.ml_line_count)\n\t\ti = curbuf->b_ml.ml_line_count;\n\t    curwin->w_cursor.lnum = i;\n\t}\n\tif (qf_col > 0)\n\t{\n\t    curwin->w_cursor.coladd = 0;\n\t    if (qf_viscol == TRUE)\n\t\tcoladvance(qf_col - 1);\n\t    else\n\t\tcurwin->w_cursor.col = qf_col - 1;\n\t    curwin->w_set_curswant = TRUE;\n\t    check_cursor();\n\t}\n\telse\n\t    beginline(BL_WHITE | BL_FIX);\n    }\n    else\n    {\n\tpos_T save_cursor;\n\n\t// Move the cursor to the first line in the buffer\n\tsave_cursor = curwin->w_cursor;\n\tcurwin->w_cursor.lnum = 0;\n\tif (!do_search(NULL, '/', '/', qf_pattern, (long)1, SEARCH_KEEP, NULL))\n\t    curwin->w_cursor = save_cursor;\n    }\n}\n\n/*\n * Display quickfix list index and size message\n */\n    static void\nqf_jump_print_msg(\n\tqf_info_T\t*qi,\n\tint\t\tqf_index,\n\tqfline_T\t*qf_ptr,\n\tbuf_T\t\t*old_curbuf,\n\tlinenr_T\told_lnum)\n{\n    linenr_T\t\ti;\n    garray_T\t\t*gap;\n\n    gap = qfga_get();\n\n    // Update the screen before showing the message, unless the screen\n    // scrolled up.\n    if (!msg_scrolled)\n\tupdate_topline_redraw();\n    vim_snprintf((char *)IObuff, IOSIZE, _(\"(%d of %d)%s%s: \"), qf_index,\n\t    qf_get_curlist(qi)->qf_count,\n\t    qf_ptr->qf_cleared ? _(\" (line deleted)\") : \"\",\n\t    (char *)qf_types(qf_ptr->qf_type, qf_ptr->qf_nr));\n    // Add the message, skipping leading whitespace and newlines.\n    ga_concat(gap, IObuff);\n    qf_fmt_text(gap, skipwhite(qf_ptr->qf_text));\n\n    // Output the message.  Overwrite to avoid scrolling when the 'O'\n    // flag is present in 'shortmess'; But when not jumping, print the\n    // whole message.\n    i = msg_scroll;\n    if (curbuf == old_curbuf && curwin->w_cursor.lnum == old_lnum)\n\tmsg_scroll = TRUE;\n    else if (!msg_scrolled && shortmess(SHM_OVERALL))\n\tmsg_scroll = FALSE;\n    msg_attr_keep((char *)gap->ga_data, 0, TRUE);\n    msg_scroll = i;\n\n    qfga_clear();\n}\n\n/*\n * Find a usable window for opening a file from the quickfix/location list. If\n * a window is not found then open a new window. If 'newwin' is TRUE, then open\n * a new window.\n * Returns OK if successfully jumped or opened a window. Returns FAIL if not\n * able to jump/open a window.  Returns NOTDONE if a file is not associated\n * with the entry.  Returns QF_ABORT if the quickfix/location list was modified\n * by an autocmd.\n */\n    static int\nqf_jump_open_window(\n\tqf_info_T\t*qi,\n\tqfline_T\t*qf_ptr,\n\tint\t\tnewwin,\n\tint\t\t*opened_window)\n{\n    qf_list_T\t*qfl = qf_get_curlist(qi);\n    int\t\told_changedtick = qfl->qf_changedtick;\n    int\t\told_qf_curlist = qi->qf_curlist;\n    qfltype_T\tqfl_type = qfl->qfl_type;\n\n    // For \":helpgrep\" find a help window or open one.\n    if (qf_ptr->qf_type == 1 && (!bt_help(curwin->w_buffer)\n\t\t\t\t\t\t      || cmdmod.cmod_tab != 0))\n\tif (jump_to_help_window(qi, newwin, opened_window) == FAIL)\n\t    return FAIL;\n    if (old_qf_curlist != qi->qf_curlist\n\t    || old_changedtick != qfl->qf_changedtick\n\t    || !is_qf_entry_present(qfl, qf_ptr))\n    {\n\tif (qfl_type == QFLT_QUICKFIX)\n\t    emsg(_(e_current_quickfix_list_was_changed));\n\telse\n\t    emsg(_(e_current_location_list_was_changed));\n\treturn QF_ABORT;\n    }\n\n    // If currently in the quickfix window, find another window to show the\n    // file in.\n    if (bt_quickfix(curbuf) && !*opened_window)\n    {\n\t// If there is no file specified, we don't know where to go.\n\t// But do advance, otherwise \":cn\" gets stuck.\n\tif (qf_ptr->qf_fnum == 0)\n\t    return NOTDONE;\n\n\tif (qf_jump_to_usable_window(qf_ptr->qf_fnum, newwin,\n\t\t\t\t\t\topened_window) == FAIL)\n\t    return FAIL;\n    }\n    if (old_qf_curlist != qi->qf_curlist\n\t    || old_changedtick != qfl->qf_changedtick\n\t    || !is_qf_entry_present(qfl, qf_ptr))\n    {\n\tif (qfl_type == QFLT_QUICKFIX)\n\t    emsg(_(e_current_quickfix_list_was_changed));\n\telse\n\t    emsg(_(e_current_location_list_was_changed));\n\treturn QF_ABORT;\n    }\n\n    return OK;\n}\n\n/*\n * Edit a selected file from the quickfix/location list and jump to a\n * particular line/column, adjust the folds and display a message about the\n * jump.\n * Returns OK on success and FAIL on failing to open the file/buffer.  Returns\n * QF_ABORT if the quickfix/location list is freed by an autocmd when opening\n * the file.\n */\n    static int\nqf_jump_to_buffer(\n\tqf_info_T\t*qi,\n\tint\t\tqf_index,\n\tqfline_T\t*qf_ptr,\n\tint\t\tforceit,\n\tint\t\tprev_winid,\n\tint\t\t*opened_window,\n\tint\t\topenfold,\n\tint\t\tprint_message)\n{\n    buf_T\t*old_curbuf;\n    linenr_T\told_lnum;\n    int\t\tretval = OK;\n\n    // If there is a file name, read the wanted file if needed, and check\n    // autowrite etc.\n    old_curbuf = curbuf;\n    old_lnum = curwin->w_cursor.lnum;\n\n    if (qf_ptr->qf_fnum != 0)\n    {\n\tretval = qf_jump_edit_buffer(qi, qf_ptr, forceit, prev_winid,\n\t\t\t\t\t\topened_window);\n\tif (retval != OK)\n\t    return retval;\n    }\n\n    // When not switched to another buffer, still need to set pc mark\n    if (curbuf == old_curbuf)\n\tsetpcmark();\n\n    qf_jump_goto_line(qf_ptr->qf_lnum, qf_ptr->qf_col, qf_ptr->qf_viscol,\n\t    qf_ptr->qf_pattern);\n\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_QUICKFIX) && openfold)\n\tfoldOpenCursor();\n#endif\n    if (print_message)\n\tqf_jump_print_msg(qi, qf_index, qf_ptr, old_curbuf, old_lnum);\n\n    return retval;\n}\n\n/*\n * Jump to a quickfix line and try to use an existing window.\n */\n    void\nqf_jump(qf_info_T\t*qi,\n\tint\t\tdir,\n\tint\t\terrornr,\n\tint\t\tforceit)\n{\n    qf_jump_newwin(qi, dir, errornr, forceit, FALSE);\n}\n\n/*\n * Jump to a quickfix line.\n * If dir == 0 go to entry \"errornr\".\n * If dir == FORWARD go \"errornr\" valid entries forward.\n * If dir == BACKWARD go \"errornr\" valid entries backward.\n * If dir == FORWARD_FILE go \"errornr\" valid entries files backward.\n * If dir == BACKWARD_FILE go \"errornr\" valid entries files backward\n * else if \"errornr\" is zero, redisplay the same line\n * If 'forceit' is TRUE, then can discard changes to the current buffer.\n * If 'newwin' is TRUE, then open the file in a new window.\n */\n    static void\nqf_jump_newwin(qf_info_T\t*qi,\n\tint\t\tdir,\n\tint\t\terrornr,\n\tint\t\tforceit,\n\tint\t\tnewwin)\n{\n    qf_list_T\t\t*qfl;\n    qfline_T\t\t*qf_ptr;\n    qfline_T\t\t*old_qf_ptr;\n    int\t\t\tqf_index;\n    int\t\t\told_qf_index;\n    char_u\t\t*old_swb = p_swb;\n    unsigned\t\told_swb_flags = swb_flags;\n    int\t\t\tprev_winid;\n    int\t\t\topened_window = FALSE;\n    int\t\t\tprint_message = TRUE;\n    int\t\t\told_KeyTyped = KeyTyped; // getting file may reset it\n    int\t\t\tretval = OK;\n\n    if (qi == NULL)\n\tqi = &ql_info;\n\n    if (qf_stack_empty(qi) || qf_list_empty(qf_get_curlist(qi)))\n    {\n\temsg(_(e_no_errors));\n\treturn;\n    }\n\n    incr_quickfix_busy();\n\n    qfl = qf_get_curlist(qi);\n\n    qf_ptr = qfl->qf_ptr;\n    old_qf_ptr = qf_ptr;\n    qf_index = qfl->qf_index;\n    old_qf_index = qf_index;\n\n    qf_ptr = qf_get_entry(qfl, errornr, dir, &qf_index);\n    if (qf_ptr == NULL)\n    {\n\tqf_ptr = old_qf_ptr;\n\tqf_index = old_qf_index;\n\tgoto theend;\n    }\n\n    qfl->qf_index = qf_index;\n    qfl->qf_ptr = qf_ptr;\n    if (qf_win_pos_update(qi, old_qf_index))\n\t// No need to print the error message if it's visible in the error\n\t// window\n\tprint_message = FALSE;\n\n    prev_winid = curwin->w_id;\n\n    retval = qf_jump_open_window(qi, qf_ptr, newwin, &opened_window);\n    if (retval == FAIL)\n\tgoto failed;\n    if (retval == QF_ABORT)\n    {\n\tqi = NULL;\n\tqf_ptr = NULL;\n\tgoto theend;\n    }\n    if (retval == NOTDONE)\n\tgoto theend;\n\n    retval = qf_jump_to_buffer(qi, qf_index, qf_ptr, forceit, prev_winid,\n\t\t\t\t  &opened_window, old_KeyTyped, print_message);\n    if (retval == QF_ABORT)\n    {\n\t// Quickfix/location list was modified by an autocmd\n\tqi = NULL;\n\tqf_ptr = NULL;\n    }\n\n    if (retval != OK)\n    {\n\tif (opened_window)\n\t    win_close(curwin, TRUE);    // Close opened window\n\tif (qf_ptr != NULL && qf_ptr->qf_fnum != 0)\n\t{\n\t    // Couldn't open file, so put index back where it was.  This could\n\t    // happen if the file was readonly and we changed something.\nfailed:\n\t    qf_ptr = old_qf_ptr;\n\t    qf_index = old_qf_index;\n\t}\n    }\ntheend:\n    if (qi != NULL)\n    {\n\tqfl->qf_ptr = qf_ptr;\n\tqfl->qf_index = qf_index;\n    }\n    if (p_swb != old_swb && p_swb == empty_option)\n    {\n\t// Restore old 'switchbuf' value, but not when an autocommand or\n\t// modeline has changed the value.\n\tp_swb = old_swb;\n\tswb_flags = old_swb_flags;\n    }\n    decr_quickfix_busy();\n}\n\n// Highlight attributes used for displaying entries from the quickfix list.\nstatic int\tqfFileAttr;\nstatic int\tqfSepAttr;\nstatic int\tqfLineAttr;\n\n/*\n * Display information about a single entry from the quickfix/location list.\n * Used by \":clist/:llist\" commands.\n * 'cursel' will be set to TRUE for the currently selected entry in the\n * quickfix list.\n */\n    static void\nqf_list_entry(qfline_T *qfp, int qf_idx, int cursel)\n{\n    char_u\t*fname;\n    buf_T\t*buf;\n    int\t\tfilter_entry;\n    garray_T\t*gap;\n\n    fname = NULL;\n    if (qfp->qf_module != NULL && *qfp->qf_module != NUL)\n\tvim_snprintf((char *)IObuff, IOSIZE, \"%2d %s\", qf_idx,\n\t\t\t\t\t\t(char *)qfp->qf_module);\n    else\n    {\n\tif (qfp->qf_fnum != 0\n\t\t&& (buf = buflist_findnr(qfp->qf_fnum)) != NULL)\n\t{\n\t    fname = buf->b_fname;\n\t    if (qfp->qf_type == 1)\t// :helpgrep\n\t\tfname = gettail(fname);\n\t}\n\tif (fname == NULL)\n\t    sprintf((char *)IObuff, \"%2d\", qf_idx);\n\telse\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%2d %s\",\n\t\t    qf_idx, (char *)fname);\n    }\n\n    // Support for filtering entries using :filter /pat/ clist\n    // Match against the module name, file name, search pattern and\n    // text of the entry.\n    filter_entry = TRUE;\n    if (qfp->qf_module != NULL && *qfp->qf_module != NUL)\n\tfilter_entry &= message_filtered(qfp->qf_module);\n    if (filter_entry && fname != NULL)\n\tfilter_entry &= message_filtered(fname);\n    if (filter_entry && qfp->qf_pattern != NULL)\n\tfilter_entry &= message_filtered(qfp->qf_pattern);\n    if (filter_entry)\n\tfilter_entry &= message_filtered(qfp->qf_text);\n    if (filter_entry)\n\treturn;\n\n    msg_putchar('\\n');\n    msg_outtrans_attr(IObuff, cursel ? HL_ATTR(HLF_QFL) : qfFileAttr);\n\n    if (qfp->qf_lnum != 0)\n\tmsg_puts_attr(\":\", qfSepAttr);\n    gap = qfga_get();\n    if (qfp->qf_lnum == 0)\n\tga_append(gap, NUL);\n    else\n\tqf_range_text(gap, qfp);\n    ga_concat(gap, qf_types(qfp->qf_type, qfp->qf_nr));\n    ga_append(gap, NUL);\n    msg_puts_attr((char *)gap->ga_data, qfLineAttr);\n    msg_puts_attr(\":\", qfSepAttr);\n    if (qfp->qf_pattern != NULL)\n    {\n\tgap = qfga_get();\n\tqf_fmt_text(gap, qfp->qf_pattern);\n\tmsg_puts((char *)gap->ga_data);\n\tmsg_puts_attr(\":\", qfSepAttr);\n    }\n    msg_puts(\" \");\n\n    // Remove newlines and leading whitespace from the text.  For an\n    // unrecognized line keep the indent, the compiler may mark a word\n    // with ^^^^.\n    gap = qfga_get();\n    qf_fmt_text(gap, (fname != NULL || qfp->qf_lnum != 0)\n\t    ? skipwhite(qfp->qf_text) : qfp->qf_text);\n    msg_prt_line((char_u *)gap->ga_data, FALSE);\n    out_flush();\t\t// show one line at a time\n}\n\n/*\n * \":clist\": list all errors\n * \":llist\": list all locations\n */\n    void\nqf_list(exarg_T *eap)\n{\n    qf_list_T\t*qfl;\n    qfline_T\t*qfp;\n    int\t\ti;\n    int\t\tidx1 = 1;\n    int\t\tidx2 = -1;\n    char_u\t*arg = eap->arg;\n    int\t\tplus = FALSE;\n    int\t\tall = eap->forceit;\t// if not :cl!, only show\n\t\t\t\t\t// recognised errors\n    qf_info_T\t*qi;\n\n    if ((qi = qf_cmd_get_stack(eap, TRUE)) == NULL)\n\treturn;\n\n    if (qf_stack_empty(qi) || qf_list_empty(qf_get_curlist(qi)))\n    {\n\temsg(_(e_no_errors));\n\treturn;\n    }\n    if (*arg == '+')\n    {\n\t++arg;\n\tplus = TRUE;\n    }\n    if (!get_list_range(&arg, &idx1, &idx2) || *arg != NUL)\n    {\n\tsemsg(_(e_trailing_characters_str), arg);\n\treturn;\n    }\n    qfl = qf_get_curlist(qi);\n    if (plus)\n    {\n\ti = qfl->qf_index;\n\tidx2 = i + idx1;\n\tidx1 = i;\n    }\n    else\n    {\n\ti = qfl->qf_count;\n\tif (idx1 < 0)\n\t    idx1 = (-idx1 > i) ? 0 : idx1 + i + 1;\n\tif (idx2 < 0)\n\t    idx2 = (-idx2 > i) ? 0 : idx2 + i + 1;\n    }\n\n    // Shorten all the file names, so that it is easy to read\n    shorten_fnames(FALSE);\n\n    // Get the attributes for the different quickfix highlight items.  Note\n    // that this depends on syntax items defined in the qf.vim syntax file\n    qfFileAttr = syn_name2attr((char_u *)\"qfFileName\");\n    if (qfFileAttr == 0)\n\tqfFileAttr = HL_ATTR(HLF_D);\n    qfSepAttr = syn_name2attr((char_u *)\"qfSeparator\");\n    if (qfSepAttr == 0)\n\tqfSepAttr = HL_ATTR(HLF_D);\n    qfLineAttr = syn_name2attr((char_u *)\"qfLineNr\");\n    if (qfLineAttr == 0)\n\tqfLineAttr = HL_ATTR(HLF_N);\n\n    if (qfl->qf_nonevalid)\n\tall = TRUE;\n    FOR_ALL_QFL_ITEMS(qfl, qfp, i)\n    {\n\tif ((qfp->qf_valid || all) && idx1 <= i && i <= idx2)\n\t    qf_list_entry(qfp, i, i == qfl->qf_index);\n\n\tui_breakcheck();\n    }\n    qfga_clear();\n}\n\n/*\n * Remove newlines and leading whitespace from an error message.\n * Add the result to the grow array \"gap\".\n */\n    static void\nqf_fmt_text(garray_T *gap, char_u *text)\n{\n    char_u\t*p = text;\n\n    while (*p != NUL)\n    {\n\tif (*p == '\\n')\n\t{\n\t    ga_append(gap, ' ');\n\t    while (*++p != NUL)\n\t\tif (!VIM_ISWHITE(*p) && *p != '\\n')\n\t\t    break;\n\t}\n\telse\n\t    ga_append(gap, *p++);\n    }\n\n    ga_append(gap, NUL);\n}\n\n/*\n * Add the range information from the lnum, col, end_lnum, and end_col values\n * of a quickfix entry to the grow array \"gap\".\n */\n    static void\nqf_range_text(garray_T *gap, qfline_T *qfp)\n{\n    char_u\t*buf = IObuff;\n    int\t\tbufsize = IOSIZE;\n    int len;\n\n    vim_snprintf((char *)buf, bufsize, \"%ld\", qfp->qf_lnum);\n    len = (int)STRLEN(buf);\n\n    if (qfp->qf_end_lnum > 0 && qfp->qf_lnum != qfp->qf_end_lnum)\n    {\n\tvim_snprintf((char *)buf + len, bufsize - len,\n\t\t\"-%ld\", qfp->qf_end_lnum);\n\tlen += (int)STRLEN(buf + len);\n    }\n    if (qfp->qf_col > 0)\n    {\n\tvim_snprintf((char *)buf + len, bufsize - len, \" col %d\", qfp->qf_col);\n\tlen += (int)STRLEN(buf + len);\n\tif (qfp->qf_end_col > 0 && qfp->qf_col != qfp->qf_end_col)\n\t{\n\t    vim_snprintf((char *)buf + len, bufsize - len,\n\t\t    \"-%d\", qfp->qf_end_col);\n\t    len += (int)STRLEN(buf + len);\n\t}\n    }\n    buf[len] = NUL;\n\n    ga_concat_len(gap, buf, len);\n}\n\n/*\n * Display information (list number, list size and the title) about a\n * quickfix/location list.\n */\n    static void\nqf_msg(qf_info_T *qi, int which, char *lead)\n{\n    char   *title = (char *)qi->qf_lists[which].qf_title;\n    int    count = qi->qf_lists[which].qf_count;\n    char_u buf[IOSIZE];\n\n    vim_snprintf((char *)buf, IOSIZE, _(\"%serror list %d of %d; %d errors \"),\n\t    lead,\n\t    which + 1,\n\t    qi->qf_listcount,\n\t    count);\n\n    if (title != NULL)\n    {\n\tsize_t\tlen = STRLEN(buf);\n\n\tif (len < 34)\n\t{\n\t    vim_memset(buf + len, ' ', 34 - len);\n\t    buf[34] = NUL;\n\t}\n\tvim_strcat(buf, (char_u *)title, IOSIZE);\n    }\n    trunc_string(buf, buf, Columns - 1, IOSIZE);\n    msg((char *)buf);\n}\n\n/*\n * \":colder [count]\": Up in the quickfix stack.\n * \":cnewer [count]\": Down in the quickfix stack.\n * \":lolder [count]\": Up in the location list stack.\n * \":lnewer [count]\": Down in the location list stack.\n */\n    void\nqf_age(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n    int\t\tcount;\n\n    if ((qi = qf_cmd_get_stack(eap, TRUE)) == NULL)\n\treturn;\n\n    if (eap->addr_count != 0)\n\tcount = eap->line2;\n    else\n\tcount = 1;\n    while (count--)\n    {\n\tif (eap->cmdidx == CMD_colder || eap->cmdidx == CMD_lolder)\n\t{\n\t    if (qi->qf_curlist == 0)\n\t    {\n\t\temsg(_(e_at_bottom_of_quickfix_stack));\n\t\tbreak;\n\t    }\n\t    --qi->qf_curlist;\n\t}\n\telse\n\t{\n\t    if (qi->qf_curlist >= qi->qf_listcount - 1)\n\t    {\n\t\temsg(_(e_at_top_of_quickfix_stack));\n\t\tbreak;\n\t    }\n\t    ++qi->qf_curlist;\n\t}\n    }\n    qf_msg(qi, qi->qf_curlist, \"\");\n    qf_update_buffer(qi, NULL);\n}\n\n/*\n * Display the information about all the quickfix/location lists in the stack\n */\n    void\nqf_history(exarg_T *eap)\n{\n    qf_info_T\t*qi = qf_cmd_get_stack(eap, FALSE);\n    int\t\ti;\n\n    if (eap->addr_count > 0)\n    {\n\tif (qi == NULL)\n\t{\n\t    emsg(_(e_no_location_list));\n\t    return;\n\t}\n\n\t// Jump to the specified quickfix list\n\tif (eap->line2 > 0 && eap->line2 <= qi->qf_listcount)\n\t{\n\t    qi->qf_curlist = eap->line2 - 1;\n\t    qf_msg(qi, qi->qf_curlist, \"\");\n\t    qf_update_buffer(qi, NULL);\n\t}\n\telse\n\t    emsg(_(e_invalid_range));\n\n\treturn;\n    }\n\n    if (qf_stack_empty(qi))\n\tmsg(_(\"No entries\"));\n    else\n\tfor (i = 0; i < qi->qf_listcount; ++i)\n\t    qf_msg(qi, i, i == qi->qf_curlist ? \"> \" : \"  \");\n}\n\n/*\n * Free all the entries in the error list \"idx\". Note that other information\n * associated with the list like context and title are not freed.\n */\n    static void\nqf_free_items(qf_list_T *qfl)\n{\n    qfline_T\t*qfp;\n    qfline_T\t*qfpnext;\n    int\t\tstop = FALSE;\n\n    while (qfl->qf_count && qfl->qf_start != NULL)\n    {\n\tqfp = qfl->qf_start;\n\tqfpnext = qfp->qf_next;\n\tif (!stop)\n\t{\n\t    vim_free(qfp->qf_module);\n\t    vim_free(qfp->qf_text);\n\t    vim_free(qfp->qf_pattern);\n\t    stop = (qfp == qfpnext);\n\t    vim_free(qfp);\n\t    if (stop)\n\t\t// Somehow qf_count may have an incorrect value, set it to 1\n\t\t// to avoid crashing when it's wrong.\n\t\t// TODO: Avoid qf_count being incorrect.\n\t\tqfl->qf_count = 1;\n\t}\n\tqfl->qf_start = qfpnext;\n\t--qfl->qf_count;\n    }\n\n    qfl->qf_index = 0;\n    qfl->qf_start = NULL;\n    qfl->qf_last = NULL;\n    qfl->qf_ptr = NULL;\n    qfl->qf_nonevalid = TRUE;\n\n    qf_clean_dir_stack(&qfl->qf_dir_stack);\n    qfl->qf_directory = NULL;\n    qf_clean_dir_stack(&qfl->qf_file_stack);\n    qfl->qf_currfile = NULL;\n    qfl->qf_multiline = FALSE;\n    qfl->qf_multiignore = FALSE;\n    qfl->qf_multiscan = FALSE;\n}\n\n/*\n * Free error list \"idx\". Frees all the entries in the quickfix list,\n * associated context information and the title.\n */\n    static void\nqf_free(qf_list_T *qfl)\n{\n    qf_free_items(qfl);\n\n    VIM_CLEAR(qfl->qf_title);\n    free_tv(qfl->qf_ctx);\n    qfl->qf_ctx = NULL;\n    free_callback(&qfl->qf_qftf_cb);\n    qfl->qf_id = 0;\n    qfl->qf_changedtick = 0L;\n}\n\n/*\n * qf_mark_adjust: adjust marks\n */\n   void\nqf_mark_adjust(\n\twin_T\t*wp,\n\tlinenr_T\tline1,\n\tlinenr_T\tline2,\n\tlong\tamount,\n\tlong\tamount_after)\n{\n    int\t\ti;\n    qfline_T\t*qfp;\n    int\t\tidx;\n    qf_info_T\t*qi = &ql_info;\n    int\t\tfound_one = FALSE;\n    int\t\tbuf_has_flag = wp == NULL ? BUF_HAS_QF_ENTRY : BUF_HAS_LL_ENTRY;\n\n    if (!(curbuf->b_has_qf_entry & buf_has_flag))\n\treturn;\n    if (wp != NULL)\n    {\n\tif (wp->w_llist == NULL)\n\t    return;\n\tqi = wp->w_llist;\n    }\n\n    for (idx = 0; idx < qi->qf_listcount; ++idx)\n    {\n\tqf_list_T\t*qfl = qf_get_list(qi, idx);\n\n\tif (!qf_list_empty(qfl))\n\t    FOR_ALL_QFL_ITEMS(qfl, qfp, i)\n\t\tif (qfp->qf_fnum == curbuf->b_fnum)\n\t\t{\n\t\t    found_one = TRUE;\n\t\t    if (qfp->qf_lnum >= line1 && qfp->qf_lnum <= line2)\n\t\t    {\n\t\t\tif (amount == MAXLNUM)\n\t\t\t    qfp->qf_cleared = TRUE;\n\t\t\telse\n\t\t\t    qfp->qf_lnum += amount;\n\t\t    }\n\t\t    else if (amount_after && qfp->qf_lnum > line2)\n\t\t\tqfp->qf_lnum += amount_after;\n\t\t}\n    }\n\n    if (!found_one)\n\tcurbuf->b_has_qf_entry &= ~buf_has_flag;\n}\n\n/*\n * Make a nice message out of the error character and the error number:\n *  char    number\tmessage\n *  e or E    0\t\t\" error\"\n *  w or W    0\t\t\" warning\"\n *  i or I    0\t\t\" info\"\n *  n or N    0\t\t\" note\"\n *  0\t      0\t\t\"\"\n *  other     0\t\t\" c\"\n *  e or E    n\t\t\" error n\"\n *  w or W    n\t\t\" warning n\"\n *  i or I    n\t\t\" info n\"\n *  n or N    n\t\t\" note n\"\n *  0\t      n\t\t\" error n\"\n *  other     n\t\t\" c n\"\n *  1\t      x\t\t\"\"\t:helpgrep\n */\n    static char_u *\nqf_types(int c, int nr)\n{\n    static char_u\tbuf[20];\n    static char_u\tcc[3];\n    char_u\t\t*p;\n\n    if (c == 'W' || c == 'w')\n\tp = (char_u *)\" warning\";\n    else if (c == 'I' || c == 'i')\n\tp = (char_u *)\" info\";\n    else if (c == 'N' || c == 'n')\n\tp = (char_u *)\" note\";\n    else if (c == 'E' || c == 'e' || (c == 0 && nr > 0))\n\tp = (char_u *)\" error\";\n    else if (c == 0 || c == 1)\n\tp = (char_u *)\"\";\n    else\n    {\n\tcc[0] = ' ';\n\tcc[1] = c;\n\tcc[2] = NUL;\n\tp = cc;\n    }\n\n    if (nr <= 0)\n\treturn p;\n\n    sprintf((char *)buf, \"%s %3d\", (char *)p, nr);\n    return buf;\n}\n\n/*\n * When \"split\" is FALSE: Open the entry/result under the cursor.\n * When \"split\" is TRUE: Open the entry/result under the cursor in a new window.\n */\n    void\nqf_view_result(int split)\n{\n    qf_info_T   *qi = &ql_info;\n\n    if (IS_LL_WINDOW(curwin))\n\tqi = GET_LOC_LIST(curwin);\n\n    if (qf_list_empty(qf_get_curlist(qi)))\n    {\n\temsg(_(e_no_errors));\n\treturn;\n    }\n\n    if (split)\n    {\n\t// Open the selected entry in a new window\n\tqf_jump_newwin(qi, 0, (long)curwin->w_cursor.lnum, FALSE, TRUE);\n\tdo_cmdline_cmd((char_u *) \"clearjumps\");\n\treturn;\n    }\n\n    do_cmdline_cmd((char_u *)(IS_LL_WINDOW(curwin) ? \".ll\" : \".cc\"));\n}\n\n/*\n * \":cwindow\": open the quickfix window if we have errors to display,\n *\t       close it if not.\n * \":lwindow\": open the location list window if we have locations to display,\n *\t       close it if not.\n */\n    void\nex_cwindow(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n    qf_list_T\t*qfl;\n    win_T\t*win;\n\n    if ((qi = qf_cmd_get_stack(eap, TRUE)) == NULL)\n\treturn;\n\n    qfl = qf_get_curlist(qi);\n\n    // Look for an existing quickfix window.\n    win = qf_find_win(qi);\n\n    // If a quickfix window is open but we have no errors to display,\n    // close the window.  If a quickfix window is not open, then open\n    // it if we have errors; otherwise, leave it closed.\n    if (qf_stack_empty(qi)\n\t    || qfl->qf_nonevalid\n\t    || qf_list_empty(qfl))\n    {\n\tif (win != NULL)\n\t    ex_cclose(eap);\n    }\n    else if (win == NULL)\n\tex_copen(eap);\n}\n\n/*\n * \":cclose\": close the window showing the list of errors.\n * \":lclose\": close the window showing the location list\n */\n    void\nex_cclose(exarg_T *eap)\n{\n    win_T\t*win = NULL;\n    qf_info_T\t*qi;\n\n    if ((qi = qf_cmd_get_stack(eap, FALSE)) == NULL)\n\treturn;\n\n    // Find existing quickfix window and close it.\n    win = qf_find_win(qi);\n    if (win != NULL)\n\twin_close(win, FALSE);\n}\n\n/*\n * Set \"w:quickfix_title\" if \"qi\" has a title.\n */\n    static void\nqf_set_title_var(qf_list_T *qfl)\n{\n    if (qfl->qf_title != NULL)\n\tset_internal_string_var((char_u *)\"w:quickfix_title\", qfl->qf_title);\n}\n\n/*\n * Goto a quickfix or location list window (if present).\n * Returns OK if the window is found, FAIL otherwise.\n */\n    static int\nqf_goto_cwindow(qf_info_T *qi, int resize, int sz, int vertsplit)\n{\n    win_T\t*win;\n\n    win = qf_find_win(qi);\n    if (win == NULL)\n\treturn FAIL;\n\n    win_goto(win);\n    if (resize)\n    {\n\tif (vertsplit)\n\t{\n\t    if (sz != win->w_width)\n\t\twin_setwidth(sz);\n\t}\n\telse if (sz != win->w_height && win->w_height\n\t\t       + win->w_status_height + tabline_height() < cmdline_row)\n\t    win_setheight(sz);\n    }\n\n    return OK;\n}\n\n/*\n * Set options for the buffer in the quickfix or location list window.\n */\n    static void\nqf_set_cwindow_options(void)\n{\n    // switch off 'swapfile'\n    set_option_value_give_err((char_u *)\"swf\", 0L, NULL, OPT_LOCAL);\n    set_option_value_give_err((char_u *)\"bt\",\n\t\t\t\t\t  0L, (char_u *)\"quickfix\", OPT_LOCAL);\n    set_option_value_give_err((char_u *)\"bh\", 0L, (char_u *)\"hide\", OPT_LOCAL);\n    RESET_BINDING(curwin);\n#ifdef FEAT_DIFF\n    curwin->w_p_diff = FALSE;\n#endif\n#ifdef FEAT_FOLDING\n    set_option_value_give_err((char_u *)\"fdm\", 0L, (char_u *)\"manual\",\n\t    OPT_LOCAL);\n#endif\n}\n\n/*\n * Open a new quickfix or location list window, load the quickfix buffer and\n * set the appropriate options for the window.\n * Returns FAIL if the window could not be opened.\n */\n    static int\nqf_open_new_cwindow(qf_info_T *qi, int height)\n{\n    buf_T\t*qf_buf;\n    win_T\t*oldwin = curwin;\n    tabpage_T\t*prevtab = curtab;\n    int\t\tflags = 0;\n    win_T\t*win;\n\n    qf_buf = qf_find_buf(qi);\n\n    // The current window becomes the previous window afterwards.\n    win = curwin;\n\n    if (IS_QF_STACK(qi) && cmdmod.cmod_split == 0)\n\t// Create the new quickfix window at the very bottom, except when\n\t// :belowright or :aboveleft is used.\n\twin_goto(lastwin);\n    // Default is to open the window below the current window\n    if (cmdmod.cmod_split == 0)\n\tflags = WSP_BELOW;\n    flags |= WSP_NEWLOC;\n    if (win_split(height, flags) == FAIL)\n\treturn FAIL;\t\t// not enough room for window\n    RESET_BINDING(curwin);\n\n    if (IS_LL_STACK(qi))\n    {\n\t// For the location list window, create a reference to the\n\t// location list stack from the window 'win'.\n\tcurwin->w_llist_ref = qi;\n\tqi->qf_refcount++;\n    }\n\n    if (oldwin != curwin)\n\toldwin = NULL;  // don't store info when in another window\n    if (qf_buf != NULL)\n    {\n\t// Use the existing quickfix buffer\n\tif (do_ecmd(qf_buf->b_fnum, NULL, NULL, NULL, ECMD_ONE,\n\t\t    ECMD_HIDE + ECMD_OLDBUF + ECMD_NOWINENTER, oldwin) == FAIL)\n\t    return FAIL;\n    }\n    else\n    {\n\t// Create a new quickfix buffer\n\tif (do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE + ECMD_NOWINENTER,\n\t\t\t\t\t\t\t       oldwin) == FAIL)\n\t    return FAIL;\n\n\t// save the number of the new buffer\n\tqi->qf_bufnr = curbuf->b_fnum;\n    }\n\n    // Set the options for the quickfix buffer/window (if not already done)\n    // Do this even if the quickfix buffer was already present, as an autocmd\n    // might have previously deleted (:bdelete) the quickfix buffer.\n    if (!bt_quickfix(curbuf))\n\tqf_set_cwindow_options();\n\n    // Only set the height when still in the same tab page and there is no\n    // window to the side.\n    if (curtab == prevtab && curwin->w_width == Columns)\n\twin_setheight(height);\n    curwin->w_p_wfh = TRUE;\t    // set 'winfixheight'\n    if (win_valid(win))\n\tprevwin = win;\n\n    return OK;\n}\n\n/*\n * \":copen\": open a window that shows the list of errors.\n * \":lopen\": open a window that shows the location list.\n */\n    void\nex_copen(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n    qf_list_T\t*qfl;\n    int\t\theight;\n    int\t\tstatus = FAIL;\n    int\t\tlnum;\n\n    if ((qi = qf_cmd_get_stack(eap, TRUE)) == NULL)\n\treturn;\n\n    incr_quickfix_busy();\n\n    if (eap->addr_count != 0)\n\theight = eap->line2;\n    else\n\theight = QF_WINHEIGHT;\n\n    reset_VIsual_and_resel();\t\t\t// stop Visual mode\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    // Find an existing quickfix window, or open a new one.\n    if (cmdmod.cmod_tab == 0)\n\tstatus = qf_goto_cwindow(qi, eap->addr_count != 0, height,\n\t\t\t\t\t\tcmdmod.cmod_split & WSP_VERT);\n    if (status == FAIL)\n\tif (qf_open_new_cwindow(qi, height) == FAIL)\n\t{\n\t    decr_quickfix_busy();\n\t    return;\n\t}\n\n    qfl = qf_get_curlist(qi);\n    qf_set_title_var(qfl);\n    // Save the current index here, as updating the quickfix buffer may free\n    // the quickfix list\n    lnum = qfl->qf_index;\n\n    // Fill the buffer with the quickfix list.\n    qf_fill_buffer(qfl, curbuf, NULL, curwin->w_id);\n\n    decr_quickfix_busy();\n\n    curwin->w_cursor.lnum = lnum;\n    curwin->w_cursor.col = 0;\n    check_cursor();\n    update_topline();\t\t// scroll to show the line\n}\n\n/*\n * Move the cursor in the quickfix window to \"lnum\".\n */\n    static void\nqf_win_goto(win_T *win, linenr_T lnum)\n{\n    win_T\t*old_curwin = curwin;\n\n    curwin = win;\n    curbuf = win->w_buffer;\n    curwin->w_cursor.lnum = lnum;\n    curwin->w_cursor.col = 0;\n    curwin->w_cursor.coladd = 0;\n    curwin->w_curswant = 0;\n    update_topline();\t\t// scroll to show the line\n    redraw_later(UPD_VALID);\n    curwin->w_redr_status = TRUE;\t// update ruler\n    curwin = old_curwin;\n    curbuf = curwin->w_buffer;\n}\n\n/*\n * :cbottom/:lbottom commands.\n */\n    void\nex_cbottom(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n    win_T\t*win;\n\n    if ((qi = qf_cmd_get_stack(eap, TRUE)) == NULL)\n\treturn;\n\n    win = qf_find_win(qi);\n    if (win != NULL && win->w_cursor.lnum != win->w_buffer->b_ml.ml_line_count)\n\tqf_win_goto(win, win->w_buffer->b_ml.ml_line_count);\n}\n\n/*\n * Return the number of the current entry (line number in the quickfix\n * window).\n */\n     linenr_T\nqf_current_entry(win_T *wp)\n{\n    qf_info_T\t*qi = &ql_info;\n\n    if (IS_LL_WINDOW(wp))\n\t// In the location list window, use the referenced location list\n\tqi = wp->w_llist_ref;\n\n    return qf_get_curlist(qi)->qf_index;\n}\n\n/*\n * Update the cursor position in the quickfix window to the current error.\n * Return TRUE if there is a quickfix window.\n */\n    static int\nqf_win_pos_update(\n    qf_info_T\t*qi,\n    int\t\told_qf_index)\t// previous qf_index or zero\n{\n    win_T\t*win;\n    int\t\tqf_index = qf_get_curlist(qi)->qf_index;\n\n    // Put the cursor on the current error in the quickfix window, so that\n    // it's viewable.\n    win = qf_find_win(qi);\n    if (win != NULL\n\t    && qf_index <= win->w_buffer->b_ml.ml_line_count\n\t    && old_qf_index != qf_index)\n    {\n\tif (qf_index > old_qf_index)\n\t{\n\t    win->w_redraw_top = old_qf_index;\n\t    win->w_redraw_bot = qf_index;\n\t}\n\telse\n\t{\n\t    win->w_redraw_top = qf_index;\n\t    win->w_redraw_bot = old_qf_index;\n\t}\n\tqf_win_goto(win, qf_index);\n    }\n    return win != NULL;\n}\n\n/*\n * Check whether the given window is displaying the specified quickfix/location\n * stack.\n */\n    static int\nis_qf_win(win_T *win, qf_info_T *qi)\n{\n    // A window displaying the quickfix buffer will have the w_llist_ref field\n    // set to NULL.\n    // A window displaying a location list buffer will have the w_llist_ref\n    // pointing to the location list.\n    if (bt_quickfix(win->w_buffer))\n\tif ((IS_QF_STACK(qi) && win->w_llist_ref == NULL)\n\t\t|| (IS_LL_STACK(qi) && win->w_llist_ref == qi))\n\t    return TRUE;\n\n    return FALSE;\n}\n\n/*\n * Find a window displaying the quickfix/location stack 'qi' in the current tab\n * page.\n */\n    static win_T *\nqf_find_win(qf_info_T *qi)\n{\n    win_T\t*win;\n\n    FOR_ALL_WINDOWS(win)\n\tif (is_qf_win(win, qi))\n\t    return win;\n    return NULL;\n}\n\n/*\n * Find a quickfix buffer.\n * Searches in windows opened in all the tab pages.\n */\n    static buf_T *\nqf_find_buf(qf_info_T *qi)\n{\n    tabpage_T\t*tp;\n    win_T\t*win;\n\n    if (qi->qf_bufnr != INVALID_QFBUFNR)\n    {\n\tbuf_T\t*qfbuf;\n\tqfbuf = buflist_findnr(qi->qf_bufnr);\n\tif (qfbuf != NULL)\n\t    return qfbuf;\n\t// buffer is no longer present\n\tqi->qf_bufnr = INVALID_QFBUFNR;\n    }\n\n    FOR_ALL_TAB_WINDOWS(tp, win)\n\tif (is_qf_win(win, qi))\n\t    return win->w_buffer;\n\n    return NULL;\n}\n\n/*\n * Process the 'quickfixtextfunc' option value.\n * Returns OK or FAIL.\n */\n    char *\ndid_set_quickfixtextfunc(optset_T *args UNUSED)\n{\n    if (option_set_callback_func(p_qftf, &qftf_cb) == FAIL)\n\treturn e_invalid_argument;\n\n    return NULL;\n}\n\n/*\n * Update the w:quickfix_title variable in the quickfix/location list window in\n * all the tab pages.\n */\n    static void\nqf_update_win_titlevar(qf_info_T *qi)\n{\n    qf_list_T\t*qfl = qf_get_curlist(qi);\n    tabpage_T\t*tp;\n    win_T\t*win;\n    win_T\t*save_curwin = curwin;\n\n    FOR_ALL_TAB_WINDOWS(tp, win)\n    {\n\tif (is_qf_win(win, qi))\n\t{\n\t    curwin = win;\n\t    qf_set_title_var(qfl);\n\t}\n    }\n    curwin = save_curwin;\n}\n\n/*\n * Find the quickfix buffer.  If it exists, update the contents.\n */\n    static void\nqf_update_buffer(qf_info_T *qi, qfline_T *old_last)\n{\n    buf_T\t*buf;\n    win_T\t*win;\n    aco_save_T\taco;\n\n    // Check if a buffer for the quickfix list exists.  Update it.\n    buf = qf_find_buf(qi);\n    if (buf == NULL)\n\treturn;\n\n    linenr_T\told_line_count = buf->b_ml.ml_line_count;\n    int\t\tqf_winid = 0;\n\n    if (IS_LL_STACK(qi))\n    {\n\tif (curwin->w_llist == qi)\n\t    win = curwin;\n\telse\n\t{\n\t    // Find the file window (non-quickfix) with this location list\n\t    win = qf_find_win_with_loclist(qi);\n\t    if (win == NULL)\n\t\t// File window is not found. Find the location list window.\n\t\twin = qf_find_win(qi);\n\t    if (win == NULL)\n\t\treturn;\n\t}\n\tqf_winid = win->w_id;\n    }\n\n    // autocommands may cause trouble\n    incr_quickfix_busy();\n\n    int do_fill = TRUE;\n    if (old_last == NULL)\n    {\n\t// set curwin/curbuf to buf and save a few things\n\taucmd_prepbuf(&aco, buf);\n\tif (curbuf != buf)\n\t    do_fill = FALSE;  // failed to find a window for \"buf\"\n    }\n\n    if (do_fill)\n    {\n\tqf_update_win_titlevar(qi);\n\n\tqf_fill_buffer(qf_get_curlist(qi), buf, old_last, qf_winid);\n\t++CHANGEDTICK(buf);\n\n\tif (old_last == NULL)\n\t{\n\t    (void)qf_win_pos_update(qi, 0);\n\n\t    // restore curwin/curbuf and a few other things\n\t    aucmd_restbuf(&aco);\n\t}\n    }\n\n    // Only redraw when added lines are visible.  This avoids flickering\n    // when the added lines are not visible.\n    if ((win = qf_find_win(qi)) != NULL && old_line_count < win->w_botline)\n\tredraw_buf_later(buf, UPD_NOT_VALID);\n\n    // always called after incr_quickfix_busy()\n    decr_quickfix_busy();\n}\n\n/*\n * Add an error line to the quickfix buffer.\n */\n    static int\nqf_buf_add_line(\n\tbuf_T\t\t*buf,\t\t// quickfix window buffer\n\tlinenr_T\tlnum,\n\tqfline_T\t*qfp,\n\tchar_u\t\t*dirname,\n\tint\t\tfirst_bufline,\n\tchar_u\t\t*qftf_str)\n{\n    buf_T\t*errbuf;\n    garray_T\t*gap;\n\n    gap = qfga_get();\n\n    // If the 'quickfixtextfunc' function returned a non-empty custom string\n    // for this entry, then use it.\n    if (qftf_str != NULL && *qftf_str != NUL)\n    {\n\tga_concat(gap, qftf_str);\n\tga_append(gap, NUL);\n    }\n    else\n    {\n\tif (qfp->qf_module != NULL)\n\t    ga_concat(gap, qfp->qf_module);\n\telse if (qfp->qf_fnum != 0\n\t\t&& (errbuf = buflist_findnr(qfp->qf_fnum)) != NULL\n\t\t&& errbuf->b_fname != NULL)\n\t{\n\t    if (qfp->qf_type == 1)\t// :helpgrep\n\t\tga_concat(gap, gettail(errbuf->b_fname));\n\t    else\n\t    {\n\t\t// Shorten the file name if not done already.\n\t\t// For optimization, do this only for the first entry in a\n\t\t// buffer.\n\t\tif (first_bufline && (errbuf->b_sfname == NULL\n\t\t\t\t|| mch_isFullName(errbuf->b_sfname)))\n\t\t{\n\t\t    if (*dirname == NUL)\n\t\t\tmch_dirname(dirname, MAXPATHL);\n\t\t    shorten_buf_fname(errbuf, dirname, FALSE);\n\t\t}\n\t\tga_concat(gap, errbuf->b_fname);\n\t    }\n\t}\n\n\tga_append(gap, '|');\n\n\tif (qfp->qf_lnum > 0)\n\t{\n\t    qf_range_text(gap, qfp);\n\t    ga_concat(gap, qf_types(qfp->qf_type, qfp->qf_nr));\n\t}\n\telse if (qfp->qf_pattern != NULL)\n\t    qf_fmt_text(gap, qfp->qf_pattern);\n\tga_append(gap, '|');\n\tga_append(gap, ' ');\n\n\t// Remove newlines and leading whitespace from the text.\n\t// For an unrecognized line keep the indent, the compiler may\n\t// mark a word with ^^^^.\n\tqf_fmt_text(gap, gap->ga_len > 3 ? skipwhite(qfp->qf_text)\n\t\t\t\t\t\t\t       : qfp->qf_text);\n    }\n\n    if (ml_append_buf(buf, lnum, gap->ga_data, gap->ga_len, FALSE) == FAIL)\n\treturn FAIL;\n\n    return OK;\n}\n\n/*\n * Call the 'quickfixtextfunc' function to get the list of lines to display in\n * the quickfix window for the entries 'start_idx' to 'end_idx'.\n */\n    static list_T *\ncall_qftf_func(qf_list_T *qfl, int qf_winid, long start_idx, long end_idx)\n{\n    callback_T\t*cb = &qftf_cb;\n    list_T\t*qftf_list = NULL;\n    static int\trecursive = FALSE;\n\n    if (recursive)\n\treturn NULL;  // this doesn't work properly recursively\n    recursive = TRUE;\n\n    // If 'quickfixtextfunc' is set, then use the user-supplied function to get\n    // the text to display. Use the local value of 'quickfixtextfunc' if it is\n    // set.\n    if (qfl->qf_qftf_cb.cb_name != NULL)\n\tcb = &qfl->qf_qftf_cb;\n    if (cb->cb_name != NULL)\n    {\n\ttypval_T\targs[1];\n\tdict_T\t\t*d;\n\ttypval_T\trettv;\n\n\t// create the dict argument\n\tif ((d = dict_alloc_lock(VAR_FIXED)) == NULL)\n\t{\n\t    recursive = FALSE;\n\t    return NULL;\n\t}\n\tdict_add_number(d, \"quickfix\", (long)IS_QF_LIST(qfl));\n\tdict_add_number(d, \"winid\", (long)qf_winid);\n\tdict_add_number(d, \"id\", (long)qfl->qf_id);\n\tdict_add_number(d, \"start_idx\", start_idx);\n\tdict_add_number(d, \"end_idx\", end_idx);\n\t++d->dv_refcount;\n\targs[0].v_type = VAR_DICT;\n\targs[0].vval.v_dict = d;\n\n\tqftf_list = NULL;\n\tif (call_callback(cb, 0, &rettv, 1, args) != FAIL)\n\t{\n\t    if (rettv.v_type == VAR_LIST)\n\t    {\n\t\tqftf_list = rettv.vval.v_list;\n\t\tqftf_list->lv_refcount++;\n\t    }\n\t    clear_tv(&rettv);\n\t}\n\tdict_unref(d);\n    }\n\n    recursive = FALSE;\n    return qftf_list;\n}\n\n/*\n * Fill current buffer with quickfix errors, replacing any previous contents.\n * curbuf must be the quickfix buffer!\n * If \"old_last\" is not NULL append the items after this one.\n * When \"old_last\" is NULL then \"buf\" must equal \"curbuf\"!  Because\n * ml_delete() is used and autocommands will be triggered.\n */\n    static void\nqf_fill_buffer(qf_list_T *qfl, buf_T *buf, qfline_T *old_last, int qf_winid)\n{\n    linenr_T\tlnum;\n    qfline_T\t*qfp;\n    int\t\told_KeyTyped = KeyTyped;\n    list_T\t*qftf_list = NULL;\n    listitem_T\t*qftf_li = NULL;\n\n    if (old_last == NULL)\n    {\n\tif (buf != curbuf)\n\t{\n\t    internal_error(\"qf_fill_buffer()\");\n\t    return;\n\t}\n\n\t// delete all existing lines\n\twhile ((curbuf->b_ml.ml_flags & ML_EMPTY) == 0)\n\t    (void)ml_delete((linenr_T)1);\n    }\n\n    // Check if there is anything to display\n    if (qfl != NULL && qfl->qf_start != NULL)\n    {\n\tchar_u\t\tdirname[MAXPATHL];\n\tint\t\tinvalid_val = FALSE;\n\tint\t\tprev_bufnr = -1;\n\n\t*dirname = NUL;\n\n\t// Add one line for each error\n\tif (old_last == NULL)\n\t{\n\t    qfp = qfl->qf_start;\n\t    lnum = 0;\n\t}\n\telse\n\t{\n\t    if (old_last->qf_next != NULL)\n\t\tqfp = old_last->qf_next;\n\t    else\n\t\tqfp = old_last;\n\t    lnum = buf->b_ml.ml_line_count;\n\t}\n\n\tqftf_list = call_qftf_func(qfl, qf_winid, (long)(lnum + 1),\n\t\t\t\t\t\t\t(long)qfl->qf_count);\n\tif (qftf_list != NULL)\n\t    qftf_li = qftf_list->lv_first;\n\n\twhile (lnum < qfl->qf_count)\n\t{\n\t    char_u\t*qftf_str = NULL;\n\n\t    // Use the text supplied by the user defined function (if any).\n\t    // If the returned value is not string, then ignore the rest\n\t    // of the returned values and use the default.\n\t    if (qftf_li != NULL && !invalid_val)\n\t    {\n\t\tqftf_str = tv_get_string_chk(&qftf_li->li_tv);\n\t\tif (qftf_str == NULL)\n\t\t    invalid_val = TRUE;\n\t    }\n\n\t    if (qf_buf_add_line(buf, lnum, qfp, dirname,\n\t\t\tprev_bufnr != qfp->qf_fnum, qftf_str) == FAIL)\n\t\tbreak;\n\n\t    prev_bufnr = qfp->qf_fnum;\n\t    ++lnum;\n\t    qfp = qfp->qf_next;\n\t    if (qfp == NULL)\n\t\tbreak;\n\n\t    if (qftf_li != NULL)\n\t\tqftf_li = qftf_li->li_next;\n\t}\n\n\tif (old_last == NULL)\n\t    // Delete the empty line which is now at the end\n\t    (void)ml_delete(lnum + 1);\n\n\tqfga_clear();\n    }\n\n    // correct cursor position\n    check_lnums(TRUE);\n\n    if (old_last == NULL)\n    {\n\t// Set the 'filetype' to \"qf\" each time after filling the buffer.\n\t// This resembles reading a file into a buffer, it's more logical when\n\t// using autocommands.\n\t++curbuf_lock;\n\tset_option_value_give_err((char_u *)\"ft\",\n\t\t\t\t\t\t0L, (char_u *)\"qf\", OPT_LOCAL);\n\tcurbuf->b_p_ma = FALSE;\n\n\tkeep_filetype = TRUE;\t\t// don't detect 'filetype'\n\tapply_autocmds(EVENT_BUFREADPOST, (char_u *)\"quickfix\", NULL,\n\t\t\t\t\t\t\t       FALSE, curbuf);\n\tapply_autocmds(EVENT_BUFWINENTER, (char_u *)\"quickfix\", NULL,\n\t\t\t\t\t\t\t       FALSE, curbuf);\n\tkeep_filetype = FALSE;\n\t--curbuf_lock;\n\n\t// make sure it will be redrawn\n\tredraw_curbuf_later(UPD_NOT_VALID);\n    }\n\n    // Restore KeyTyped, setting 'filetype' may reset it.\n    KeyTyped = old_KeyTyped;\n}\n\n/*\n * For every change made to the quickfix list, update the changed tick.\n */\n    static void\nqf_list_changed(qf_list_T *qfl)\n{\n    qfl->qf_changedtick++;\n}\n\n/*\n * Return the quickfix/location list number with the given identifier.\n * Returns -1 if list is not found.\n */\n    static int\nqf_id2nr(qf_info_T *qi, int_u qfid)\n{\n    int\t\tqf_idx;\n\n    for (qf_idx = 0; qf_idx < qi->qf_listcount; qf_idx++)\n\tif (qi->qf_lists[qf_idx].qf_id == qfid)\n\t    return qf_idx;\n    return INVALID_QFIDX;\n}\n\n/*\n * If the current list is not \"save_qfid\" and we can find the list with that ID\n * then make it the current list.\n * This is used when autocommands may have changed the current list.\n * Returns OK if successfully restored the list. Returns FAIL if the list with\n * the specified identifier (save_qfid) is not found in the stack.\n */\n    static int\nqf_restore_list(qf_info_T *qi, int_u save_qfid)\n{\n    int curlist;\n\n    if (qf_get_curlist(qi)->qf_id == save_qfid)\n\treturn OK;\n\n    curlist = qf_id2nr(qi, save_qfid);\n    if (curlist < 0)\n\t// list is not present\n\treturn FAIL;\n    qi->qf_curlist = curlist;\n    return OK;\n}\n\n/*\n * Jump to the first entry if there is one.\n */\n    static void\nqf_jump_first(qf_info_T *qi, int_u save_qfid, int forceit)\n{\n    if (qf_restore_list(qi, save_qfid) == FAIL)\n\treturn;\n\n    // Autocommands might have cleared the list, check for that.\n    if (!qf_list_empty(qf_get_curlist(qi)))\n\tqf_jump(qi, 0, 0, forceit);\n}\n\n/*\n * Return TRUE when using \":vimgrep\" for \":grep\".\n */\n    int\ngrep_internal(cmdidx_T cmdidx)\n{\n    return ((cmdidx == CMD_grep\n\t\t|| cmdidx == CMD_lgrep\n\t\t|| cmdidx == CMD_grepadd\n\t\t|| cmdidx == CMD_lgrepadd)\n\t    && STRCMP(\"internal\",\n\t\t\t*curbuf->b_p_gp == NUL ? p_gp : curbuf->b_p_gp) == 0);\n}\n\n/*\n * Return the make/grep autocmd name.\n */\n    static char_u *\nmake_get_auname(cmdidx_T cmdidx)\n{\n    switch (cmdidx)\n    {\n\tcase CMD_make:\t    return (char_u *)\"make\";\n\tcase CMD_lmake:\t    return (char_u *)\"lmake\";\n\tcase CMD_grep:\t    return (char_u *)\"grep\";\n\tcase CMD_lgrep:\t    return (char_u *)\"lgrep\";\n\tcase CMD_grepadd:   return (char_u *)\"grepadd\";\n\tcase CMD_lgrepadd:  return (char_u *)\"lgrepadd\";\n\tdefault: return NULL;\n    }\n}\n\n/*\n * Return the name for the errorfile, in allocated memory.\n * Find a new unique name when 'makeef' contains \"##\".\n * Returns NULL for error.\n */\n    static char_u *\nget_mef_name(void)\n{\n    char_u\t*p;\n    char_u\t*name;\n    static int\tstart = -1;\n    static int\toff = 0;\n#ifdef HAVE_LSTAT\n    stat_T\tsb;\n#endif\n\n    if (*p_mef == NUL)\n    {\n\tname = vim_tempname('e', FALSE);\n\tif (name == NULL)\n\t    emsg(_(e_cant_get_temp_file_name));\n\treturn name;\n    }\n\n    for (p = p_mef; *p; ++p)\n\tif (p[0] == '#' && p[1] == '#')\n\t    break;\n\n    if (*p == NUL)\n\treturn vim_strsave(p_mef);\n\n    // Keep trying until the name doesn't exist yet.\n    for (;;)\n    {\n\tif (start == -1)\n\t    start = mch_get_pid();\n\telse\n\t    off += 19;\n\n\tname = alloc_id(STRLEN(p_mef) + 30, aid_qf_mef_name);\n\tif (name == NULL)\n\t    break;\n\tSTRCPY(name, p_mef);\n\tsprintf((char *)name + (p - p_mef), \"%d%d\", start, off);\n\tSTRCAT(name, p + 2);\n\tif (mch_getperm(name) < 0\n#ifdef HAVE_LSTAT\n\t\t    // Don't accept a symbolic link, it's a security risk.\n\t\t    && mch_lstat((char *)name, &sb) < 0\n#endif\n\t\t)\n\t    break;\n\tvim_free(name);\n    }\n    return name;\n}\n\n/*\n * Form the complete command line to invoke 'make'/'grep'. Quote the command\n * using 'shellquote' and append 'shellpipe'. Echo the fully formed command.\n */\n    static char_u *\nmake_get_fullcmd(char_u *makecmd, char_u *fname)\n{\n    char_u\t*cmd;\n    unsigned\tlen;\n\n    len = (unsigned)STRLEN(p_shq) * 2 + (unsigned)STRLEN(makecmd) + 1;\n    if (*p_sp != NUL)\n\tlen += (unsigned)STRLEN(p_sp) + (unsigned)STRLEN(fname) + 3;\n    cmd = alloc_id(len, aid_qf_makecmd);\n    if (cmd == NULL)\n\treturn NULL;\n    sprintf((char *)cmd, \"%s%s%s\", (char *)p_shq, (char *)makecmd,\n\t\t\t\t\t\t\t       (char *)p_shq);\n\n    // If 'shellpipe' empty: don't redirect to 'errorfile'.\n    if (*p_sp != NUL)\n\tappend_redir(cmd, len, p_sp, fname);\n\n    // Display the fully formed command.  Output a newline if there's something\n    // else than the :make command that was typed (in which case the cursor is\n    // in column 0).\n    if (msg_col == 0)\n\tmsg_didout = FALSE;\n    msg_start();\n    msg_puts(\":!\");\n    msg_outtrans(cmd);\t\t// show what we are doing\n\n    return cmd;\n}\n\n/*\n * Used for \":make\", \":lmake\", \":grep\", \":lgrep\", \":grepadd\", and \":lgrepadd\"\n */\n    void\nex_make(exarg_T *eap)\n{\n    char_u\t*fname;\n    char_u\t*cmd;\n    char_u\t*enc = NULL;\n    win_T\t*wp = NULL;\n    qf_info_T\t*qi = &ql_info;\n    int\t\tres;\n    char_u\t*au_name = NULL;\n    int_u\tsave_qfid;\n    char_u\t*errorformat = p_efm;\n    int\t\tnewlist = TRUE;\n\n    // Redirect \":grep\" to \":vimgrep\" if 'grepprg' is \"internal\".\n    if (grep_internal(eap->cmdidx))\n    {\n\tex_vimgrep(eap);\n\treturn;\n    }\n\n    au_name = make_get_auname(eap->cmdidx);\n    if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,\n\t\t\t\t\t       curbuf->b_fname, TRUE, curbuf))\n    {\n#ifdef FEAT_EVAL\n\tif (aborting())\n\t    return;\n#endif\n    }\n    enc = (*curbuf->b_p_menc != NUL) ? curbuf->b_p_menc : p_menc;\n\n    if (is_loclist_cmd(eap->cmdidx))\n\twp = curwin;\n\n    autowrite_all();\n    fname = get_mef_name();\n    if (fname == NULL)\n\treturn;\n    mch_remove(fname);\t    // in case it's not unique\n\n    cmd = make_get_fullcmd(eap->arg, fname);\n    if (cmd == NULL)\n    {\n\tvim_free(fname);\n\treturn;\n    }\n\n    // let the shell know if we are redirecting output or not\n    do_shell(cmd, *p_sp != NUL ? SHELL_DOOUT : 0);\n\n#ifdef AMIGA\n    out_flush();\n\t\t// read window status report and redraw before message\n    (void)char_avail();\n#endif\n\n    incr_quickfix_busy();\n\n    if (eap->cmdidx != CMD_make && eap->cmdidx != CMD_lmake)\n\terrorformat = p_gefm;\n    if (eap->cmdidx == CMD_grepadd || eap->cmdidx == CMD_lgrepadd)\n\tnewlist = FALSE;\n\n    res = qf_init(wp, fname, errorformat, newlist, qf_cmdtitle(*eap->cmdlinep),\n\t\t\t\t\t\t\t\t\tenc);\n    if (wp != NULL)\n    {\n\tqi = GET_LOC_LIST(wp);\n\tif (qi == NULL)\n\t    goto cleanup;\n    }\n    if (res >= 0)\n\tqf_list_changed(qf_get_curlist(qi));\n\n    // Remember the current quickfix list identifier, so that we can\n    // check for autocommands changing the current quickfix list.\n    save_qfid = qf_get_curlist(qi)->qf_id;\n    if (au_name != NULL)\n\tapply_autocmds(EVENT_QUICKFIXCMDPOST, au_name,\n\t\t\t\t\t       curbuf->b_fname, TRUE, curbuf);\n    if (res > 0 && !eap->forceit && qflist_valid(wp, save_qfid))\n\t// display the first error\n\tqf_jump_first(qi, save_qfid, FALSE);\n\ncleanup:\n    decr_quickfix_busy();\n    mch_remove(fname);\n    vim_free(fname);\n    vim_free(cmd);\n}\n\n/*\n * Returns the number of entries in the current quickfix/location list.\n */\n    int\nqf_get_size(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n\n    if ((qi = qf_cmd_get_stack(eap, FALSE)) == NULL)\n\treturn 0;\n    return qf_get_curlist(qi)->qf_count;\n}\n\n/*\n * Returns the number of valid entries in the current quickfix/location list.\n */\n    int\nqf_get_valid_size(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n    qf_list_T\t*qfl;\n    qfline_T\t*qfp;\n    int\t\ti, sz = 0;\n    int\t\tprev_fnum = 0;\n\n    if ((qi = qf_cmd_get_stack(eap, FALSE)) == NULL)\n\treturn 0;\n\n    qfl = qf_get_curlist(qi);\n    FOR_ALL_QFL_ITEMS(qfl, qfp, i)\n    {\n\tif (qfp->qf_valid)\n\t{\n\t    if (eap->cmdidx == CMD_cdo || eap->cmdidx == CMD_ldo)\n\t\tsz++;\t// Count all valid entries\n\t    else if (qfp->qf_fnum > 0 && qfp->qf_fnum != prev_fnum)\n\t    {\n\t\t// Count the number of files\n\t\tsz++;\n\t\tprev_fnum = qfp->qf_fnum;\n\t    }\n\t}\n    }\n\n    return sz;\n}\n\n/*\n * Returns the current index of the quickfix/location list.\n * Returns 0 if there is an error.\n */\n    int\nqf_get_cur_idx(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n\n    if ((qi = qf_cmd_get_stack(eap, FALSE)) == NULL)\n\treturn 0;\n\n    return qf_get_curlist(qi)->qf_index;\n}\n\n/*\n * Returns the current index in the quickfix/location list (counting only valid\n * entries). If no valid entries are in the list, then returns 1.\n */\n    int\nqf_get_cur_valid_idx(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n    qf_list_T\t*qfl;\n    qfline_T\t*qfp;\n    int\t\ti, eidx = 0;\n    int\t\tprev_fnum = 0;\n\n    if ((qi = qf_cmd_get_stack(eap, FALSE)) == NULL)\n\treturn 1;\n\n    qfl = qf_get_curlist(qi);\n    qfp = qfl->qf_start;\n\n    // check if the list has valid errors\n    if (!qf_list_has_valid_entries(qfl))\n\treturn 1;\n\n    for (i = 1; i <= qfl->qf_index && qfp!= NULL; i++, qfp = qfp->qf_next)\n    {\n\tif (qfp->qf_valid)\n\t{\n\t    if (eap->cmdidx == CMD_cfdo || eap->cmdidx == CMD_lfdo)\n\t    {\n\t\tif (qfp->qf_fnum > 0 && qfp->qf_fnum != prev_fnum)\n\t\t{\n\t\t    // Count the number of files\n\t\t    eidx++;\n\t\t    prev_fnum = qfp->qf_fnum;\n\t\t}\n\t    }\n\t    else\n\t\teidx++;\n\t}\n    }\n\n    return eidx ? eidx : 1;\n}\n\n/*\n * Get the 'n'th valid error entry in the quickfix or location list.\n * Used by :cdo, :ldo, :cfdo and :lfdo commands.\n * For :cdo and :ldo returns the 'n'th valid error entry.\n * For :cfdo and :lfdo returns the 'n'th valid file entry.\n */\n    static int\nqf_get_nth_valid_entry(qf_list_T *qfl, int n, int fdo)\n{\n    qfline_T\t*qfp;\n    int\t\ti, eidx;\n    int\t\tprev_fnum = 0;\n\n    // check if the list has valid errors\n    if (!qf_list_has_valid_entries(qfl))\n\treturn 1;\n\n    eidx = 0;\n    FOR_ALL_QFL_ITEMS(qfl, qfp, i)\n    {\n\tif (qfp->qf_valid)\n\t{\n\t    if (fdo)\n\t    {\n\t\tif (qfp->qf_fnum > 0 && qfp->qf_fnum != prev_fnum)\n\t\t{\n\t\t    // Count the number of files\n\t\t    eidx++;\n\t\t    prev_fnum = qfp->qf_fnum;\n\t\t}\n\t    }\n\t    else\n\t\teidx++;\n\t}\n\n\tif (eidx == n)\n\t    break;\n    }\n\n    if (i <= qfl->qf_count)\n\treturn i;\n    else\n\treturn 1;\n}\n\n/*\n * \":cc\", \":crewind\", \":cfirst\" and \":clast\".\n * \":ll\", \":lrewind\", \":lfirst\" and \":llast\".\n * \":cdo\", \":ldo\", \":cfdo\" and \":lfdo\"\n */\n    void\nex_cc(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n    int\t\terrornr;\n\n    if ((qi = qf_cmd_get_stack(eap, TRUE)) == NULL)\n\treturn;\n\n    if (eap->addr_count > 0)\n\terrornr = (int)eap->line2;\n    else\n    {\n\tswitch (eap->cmdidx)\n\t{\n\t    case CMD_cc: case CMD_ll:\n\t\terrornr = 0;\n\t\tbreak;\n\t    case CMD_crewind: case CMD_lrewind: case CMD_cfirst:\n\t    case CMD_lfirst:\n\t\terrornr = 1;\n\t\tbreak;\n\t    default:\n\t\terrornr = 32767;\n\t}\n    }\n\n    // For cdo and ldo commands, jump to the nth valid error.\n    // For cfdo and lfdo commands, jump to the nth valid file entry.\n    if (eap->cmdidx == CMD_cdo || eap->cmdidx == CMD_ldo\n\t    || eap->cmdidx == CMD_cfdo || eap->cmdidx == CMD_lfdo)\n\terrornr = qf_get_nth_valid_entry(qf_get_curlist(qi),\n\t\teap->addr_count > 0 ? (int)eap->line1 : 1,\n\t\teap->cmdidx == CMD_cfdo || eap->cmdidx == CMD_lfdo);\n\n    qf_jump(qi, 0, errornr, eap->forceit);\n}\n\n/*\n * \":cnext\", \":cnfile\", \":cNext\" and \":cprevious\".\n * \":lnext\", \":lNext\", \":lprevious\", \":lnfile\", \":lNfile\" and \":lpfile\".\n * Also, used by \":cdo\", \":ldo\", \":cfdo\" and \":lfdo\" commands.\n */\n    void\nex_cnext(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n    int\t\terrornr;\n    int\t\tdir;\n\n    if ((qi = qf_cmd_get_stack(eap, TRUE)) == NULL)\n\treturn;\n\n    if (eap->addr_count > 0\n\t    && (eap->cmdidx != CMD_cdo && eap->cmdidx != CMD_ldo\n\t\t&& eap->cmdidx != CMD_cfdo && eap->cmdidx != CMD_lfdo))\n\terrornr = (int)eap->line2;\n    else\n\terrornr = 1;\n\n    // Depending on the command jump to either next or previous entry/file.\n    switch (eap->cmdidx)\n    {\n\tcase CMD_cnext: case CMD_lnext: case CMD_cdo: case CMD_ldo:\n\t    dir = FORWARD;\n\t    break;\n\tcase CMD_cprevious: case CMD_lprevious: case CMD_cNext:\n\tcase CMD_lNext:\n\t    dir = BACKWARD;\n\t    break;\n\tcase CMD_cnfile: case CMD_lnfile: case CMD_cfdo: case CMD_lfdo:\n\t    dir = FORWARD_FILE;\n\t    break;\n\tcase CMD_cpfile: case CMD_lpfile: case CMD_cNfile: case CMD_lNfile:\n\t    dir = BACKWARD_FILE;\n\t    break;\n\tdefault:\n\t    dir = FORWARD;\n\t    break;\n    }\n\n    qf_jump(qi, dir, errornr, eap->forceit);\n}\n\n/*\n * Find the first entry in the quickfix list 'qfl' from buffer 'bnr'.\n * The index of the entry is stored in 'errornr'.\n * Returns NULL if an entry is not found.\n */\n    static qfline_T *\nqf_find_first_entry_in_buf(qf_list_T *qfl, int bnr, int *errornr)\n{\n    qfline_T\t*qfp = NULL;\n    int\t\tidx = 0;\n\n    // Find the first entry in this file\n    FOR_ALL_QFL_ITEMS(qfl, qfp, idx)\n\tif (qfp->qf_fnum == bnr)\n\t    break;\n\n    *errornr = idx;\n    return qfp;\n}\n\n/*\n * Find the first quickfix entry on the same line as 'entry'. Updates 'errornr'\n * with the error number for the first entry. Assumes the entries are sorted in\n * the quickfix list by line number.\n */\n    static qfline_T *\nqf_find_first_entry_on_line(qfline_T *entry, int *errornr)\n{\n    while (!got_int\n\t    && entry->qf_prev != NULL\n\t    && entry->qf_fnum == entry->qf_prev->qf_fnum\n\t    && entry->qf_lnum == entry->qf_prev->qf_lnum)\n    {\n\tentry = entry->qf_prev;\n\t--*errornr;\n    }\n\n    return entry;\n}\n\n/*\n * Find the last quickfix entry on the same line as 'entry'. Updates 'errornr'\n * with the error number for the last entry. Assumes the entries are sorted in\n * the quickfix list by line number.\n */\n    static qfline_T *\nqf_find_last_entry_on_line(qfline_T *entry, int *errornr)\n{\n    while (!got_int &&\n\t    entry->qf_next != NULL\n\t    && entry->qf_fnum == entry->qf_next->qf_fnum\n\t    && entry->qf_lnum == entry->qf_next->qf_lnum)\n    {\n\tentry = entry->qf_next;\n\t++*errornr;\n    }\n\n    return entry;\n}\n\n/*\n * Returns TRUE if the specified quickfix entry is\n *   after the given line (linewise is TRUE)\n *   or after the line and column.\n */\n    static int\nqf_entry_after_pos(qfline_T *qfp, pos_T *pos, int linewise)\n{\n    if (linewise)\n\treturn qfp->qf_lnum > pos->lnum;\n    else\n\treturn (qfp->qf_lnum > pos->lnum ||\n\t\t(qfp->qf_lnum == pos->lnum && qfp->qf_col > pos->col));\n}\n\n/*\n * Returns TRUE if the specified quickfix entry is\n *   before the given line (linewise is TRUE)\n *   or before the line and column.\n */\n    static int\nqf_entry_before_pos(qfline_T *qfp, pos_T *pos, int linewise)\n{\n    if (linewise)\n\treturn qfp->qf_lnum < pos->lnum;\n    else\n\treturn (qfp->qf_lnum < pos->lnum ||\n\t\t(qfp->qf_lnum == pos->lnum && qfp->qf_col < pos->col));\n}\n\n/*\n * Returns TRUE if the specified quickfix entry is\n *   on or after the given line (linewise is TRUE)\n *   or on or after the line and column.\n */\n    static int\nqf_entry_on_or_after_pos(qfline_T *qfp, pos_T *pos, int linewise)\n{\n    if (linewise)\n\treturn qfp->qf_lnum >= pos->lnum;\n    else\n\treturn (qfp->qf_lnum > pos->lnum ||\n\t\t(qfp->qf_lnum == pos->lnum && qfp->qf_col >= pos->col));\n}\n\n/*\n * Returns TRUE if the specified quickfix entry is\n *   on or before the given line (linewise is TRUE)\n *   or on or before the line and column.\n */\n    static int\nqf_entry_on_or_before_pos(qfline_T *qfp, pos_T *pos, int linewise)\n{\n    if (linewise)\n\treturn qfp->qf_lnum <= pos->lnum;\n    else\n\treturn (qfp->qf_lnum < pos->lnum ||\n\t\t(qfp->qf_lnum == pos->lnum && qfp->qf_col <= pos->col));\n}\n\n/*\n * Find the first quickfix entry after position 'pos' in buffer 'bnr'.\n * If 'linewise' is TRUE, returns the entry after the specified line and treats\n * multiple entries on a single line as one. Otherwise returns the entry after\n * the specified line and column.\n * 'qfp' points to the very first entry in the buffer and 'errornr' is the\n * index of the very first entry in the quickfix list.\n * Returns NULL if an entry is not found after 'pos'.\n */\n    static qfline_T *\nqf_find_entry_after_pos(\n\tint\t\tbnr,\n\tpos_T\t\t*pos,\n\tint\t\tlinewise,\n\tqfline_T\t*qfp,\n\tint\t\t*errornr)\n{\n    if (qf_entry_after_pos(qfp, pos, linewise))\n\t// First entry is after position 'pos'\n\treturn qfp;\n\n    // Find the entry just before or at the position 'pos'\n    while (qfp->qf_next != NULL\n\t    && qfp->qf_next->qf_fnum == bnr\n\t    && qf_entry_on_or_before_pos(qfp->qf_next, pos, linewise))\n    {\n\tqfp = qfp->qf_next;\n\t++*errornr;\n    }\n\n    if (qfp->qf_next == NULL || qfp->qf_next->qf_fnum != bnr)\n\t// No entries found after position 'pos'\n\treturn NULL;\n\n    // Use the entry just after position 'pos'\n    qfp = qfp->qf_next;\n    ++*errornr;\n\n    return qfp;\n}\n\n/*\n * Find the first quickfix entry before position 'pos' in buffer 'bnr'.\n * If 'linewise' is TRUE, returns the entry before the specified line and\n * treats multiple entries on a single line as one. Otherwise returns the entry\n * before the specified line and column.\n * 'qfp' points to the very first entry in the buffer and 'errornr' is the\n * index of the very first entry in the quickfix list.\n * Returns NULL if an entry is not found before 'pos'.\n */\n    static qfline_T *\nqf_find_entry_before_pos(\n\tint\t\tbnr,\n\tpos_T\t\t*pos,\n\tint\t\tlinewise,\n\tqfline_T\t*qfp,\n\tint\t\t*errornr)\n{\n    // Find the entry just before the position 'pos'\n    while (qfp->qf_next != NULL\n\t    && qfp->qf_next->qf_fnum == bnr\n\t    && qf_entry_before_pos(qfp->qf_next, pos, linewise))\n    {\n\tqfp = qfp->qf_next;\n\t++*errornr;\n    }\n\n    if (qf_entry_on_or_after_pos(qfp, pos, linewise))\n\treturn NULL;\n\n    if (linewise)\n\t// If multiple entries are on the same line, then use the first entry\n\tqfp = qf_find_first_entry_on_line(qfp, errornr);\n\n    return qfp;\n}\n\n/*\n * Find a quickfix entry in 'qfl' closest to position 'pos' in buffer 'bnr' in\n * the direction 'dir'.\n */\n    static qfline_T *\nqf_find_closest_entry(\n\tqf_list_T\t*qfl,\n\tint\t\tbnr,\n\tpos_T\t\t*pos,\n\tint\t\tdir,\n\tint\t\tlinewise,\n\tint\t\t*errornr)\n{\n    qfline_T\t*qfp;\n\n    *errornr = 0;\n\n    // Find the first entry in this file\n    qfp = qf_find_first_entry_in_buf(qfl, bnr, errornr);\n    if (qfp == NULL)\n\treturn NULL;\t\t// no entry in this file\n\n    if (dir == FORWARD)\n\tqfp = qf_find_entry_after_pos(bnr, pos, linewise, qfp, errornr);\n    else\n\tqfp = qf_find_entry_before_pos(bnr, pos, linewise, qfp, errornr);\n\n    return qfp;\n}\n\n/*\n * Get the nth quickfix entry below the specified entry.  Searches forward in\n * the list. If linewise is TRUE, then treat multiple entries on a single line\n * as one.\n */\n    static void\nqf_get_nth_below_entry(qfline_T *entry_arg, int n, int linewise, int *errornr)\n{\n    qfline_T *entry = entry_arg;\n\n    while (n-- > 0 && !got_int)\n    {\n\tint\t\tfirst_errornr = *errornr;\n\n\tif (linewise)\n\t    // Treat all the entries on the same line in this file as one\n\t    entry = qf_find_last_entry_on_line(entry, errornr);\n\n\tif (entry->qf_next == NULL\n\t\t|| entry->qf_next->qf_fnum != entry->qf_fnum)\n\t{\n\t    if (linewise)\n\t\t*errornr = first_errornr;\n\t    break;\n\t}\n\n\tentry = entry->qf_next;\n\t++*errornr;\n    }\n}\n\n/*\n * Get the nth quickfix entry above the specified entry.  Searches backwards in\n * the list. If linewise is TRUE, then treat multiple entries on a single line\n * as one.\n */\n    static void\nqf_get_nth_above_entry(qfline_T *entry, int n, int linewise, int *errornr)\n{\n    while (n-- > 0 && !got_int)\n    {\n\tif (entry->qf_prev == NULL\n\t\t|| entry->qf_prev->qf_fnum != entry->qf_fnum)\n\t    break;\n\n\tentry = entry->qf_prev;\n\t--*errornr;\n\n\t// If multiple entries are on the same line, then use the first entry\n\tif (linewise)\n\t    entry = qf_find_first_entry_on_line(entry, errornr);\n    }\n}\n\n/*\n * Find the n'th quickfix entry adjacent to position 'pos' in buffer 'bnr' in\n * the specified direction.  Returns the error number in the quickfix list or 0\n * if an entry is not found.\n */\n    static int\nqf_find_nth_adj_entry(\n\tqf_list_T\t*qfl,\n\tint\t\tbnr,\n\tpos_T\t\t*pos,\n\tint\t\tn,\n\tint\t\tdir,\n\tint\t\tlinewise)\n{\n    qfline_T\t*adj_entry;\n    int\t\terrornr;\n\n    // Find an entry closest to the specified position\n    adj_entry = qf_find_closest_entry(qfl, bnr, pos, dir, linewise, &errornr);\n    if (adj_entry == NULL)\n\treturn 0;\n\n    if (--n > 0)\n    {\n\t// Go to the n'th entry in the current buffer\n\tif (dir == FORWARD)\n\t    qf_get_nth_below_entry(adj_entry, n, linewise, &errornr);\n\telse\n\t    qf_get_nth_above_entry(adj_entry, n, linewise, &errornr);\n    }\n\n    return errornr;\n}\n\n/*\n * Jump to a quickfix entry in the current file nearest to the current line or\n * current line/col.\n * \":cabove\", \":cbelow\", \":labove\", \":lbelow\", \":cafter\", \":cbefore\",\n * \":lafter\" and \":lbefore\" commands\n */\n    void\nex_cbelow(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n    qf_list_T\t*qfl;\n    int\t\tdir;\n    int\t\tbuf_has_flag;\n    int\t\terrornr = 0;\n    pos_T\tpos;\n\n    if (eap->addr_count > 0 && eap->line2 <= 0)\n    {\n\temsg(_(e_invalid_range));\n\treturn;\n    }\n\n    // Check whether the current buffer has any quickfix entries\n    if (eap->cmdidx == CMD_cabove || eap->cmdidx == CMD_cbelow\n\t    || eap->cmdidx == CMD_cbefore || eap->cmdidx == CMD_cafter)\n\tbuf_has_flag = BUF_HAS_QF_ENTRY;\n    else\n\tbuf_has_flag = BUF_HAS_LL_ENTRY;\n    if (!(curbuf->b_has_qf_entry & buf_has_flag))\n    {\n\temsg(_(e_no_errors));\n\treturn;\n    }\n\n    if ((qi = qf_cmd_get_stack(eap, TRUE)) == NULL)\n\treturn;\n\n    qfl = qf_get_curlist(qi);\n    // check if the list has valid errors\n    if (!qf_list_has_valid_entries(qfl))\n    {\n\temsg(_(e_no_errors));\n\treturn;\n    }\n\n    if (eap->cmdidx == CMD_cbelow\n\t    || eap->cmdidx == CMD_lbelow\n\t    || eap->cmdidx == CMD_cafter\n\t    || eap->cmdidx == CMD_lafter)\n\t// Forward motion commands\n\tdir = FORWARD;\n    else\n\tdir = BACKWARD;\n\n    pos = curwin->w_cursor;\n    // A quickfix entry column number is 1 based whereas cursor column\n    // number is 0 based. Adjust the column number.\n    pos.col++;\n    errornr = qf_find_nth_adj_entry(qfl, curbuf->b_fnum, &pos,\n\t\t\t\teap->addr_count > 0 ? eap->line2 : 0, dir,\n\t\t\t\teap->cmdidx == CMD_cbelow\n\t\t\t\t\t|| eap->cmdidx == CMD_lbelow\n\t\t\t\t\t|| eap->cmdidx == CMD_cabove\n\t\t\t\t\t|| eap->cmdidx == CMD_labove);\n\n    if (errornr > 0)\n\tqf_jump(qi, 0, errornr, FALSE);\n    else\n\temsg(_(e_no_more_items));\n}\n\n/*\n * Return the autocmd name for the :cfile Ex commands\n */\n    static char_u *\ncfile_get_auname(cmdidx_T cmdidx)\n{\n    switch (cmdidx)\n    {\n\tcase CMD_cfile:\t    return (char_u *)\"cfile\";\n\tcase CMD_cgetfile:  return (char_u *)\"cgetfile\";\n\tcase CMD_caddfile:  return (char_u *)\"caddfile\";\n\tcase CMD_lfile:\t    return (char_u *)\"lfile\";\n\tcase CMD_lgetfile:  return (char_u *)\"lgetfile\";\n\tcase CMD_laddfile:  return (char_u *)\"laddfile\";\n\tdefault:\t    return NULL;\n    }\n}\n\n/*\n * \":cfile\"/\":cgetfile\"/\":caddfile\" commands.\n * \":lfile\"/\":lgetfile\"/\":laddfile\" commands.\n */\n    void\nex_cfile(exarg_T *eap)\n{\n    char_u\t*enc = NULL;\n    win_T\t*wp = NULL;\n    qf_info_T\t*qi = &ql_info;\n    char_u\t*au_name = NULL;\n    int_u\tsave_qfid = 0;\t\t// init for gcc\n    int\t\tres;\n\n    au_name = cfile_get_auname(eap->cmdidx);\n    if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,\n\t\t\t\t\t\t\tNULL, FALSE, curbuf))\n    {\n#ifdef FEAT_EVAL\n\tif (aborting())\n\t    return;\n#endif\n    }\n\n    enc = (*curbuf->b_p_menc != NUL) ? curbuf->b_p_menc : p_menc;\n#ifdef FEAT_BROWSE\n    if (cmdmod.cmod_flags & CMOD_BROWSE)\n    {\n\tchar_u *browse_file = do_browse(0, (char_u *)_(\"Error file\"), eap->arg,\n\t\t\t\t   NULL, NULL,\n\t\t\t\t   (char_u *)_(BROWSE_FILTER_ALL_FILES), NULL);\n\tif (browse_file == NULL)\n\t    return;\n\tset_string_option_direct((char_u *)\"ef\", -1, browse_file, OPT_FREE, 0);\n\tvim_free(browse_file);\n    }\n    else\n#endif\n    if (*eap->arg != NUL)\n\tset_string_option_direct((char_u *)\"ef\", -1, eap->arg, OPT_FREE, 0);\n\n    if (is_loclist_cmd(eap->cmdidx))\n\twp = curwin;\n\n    incr_quickfix_busy();\n\n    // This function is used by the :cfile, :cgetfile and :caddfile\n    // commands.\n    // :cfile always creates a new quickfix list and jumps to the\n    // first error.\n    // :cgetfile creates a new quickfix list but doesn't jump to the\n    // first error.\n    // :caddfile adds to an existing quickfix list. If there is no\n    // quickfix list then a new list is created.\n    res = qf_init(wp, p_ef, p_efm, (eap->cmdidx != CMD_caddfile\n\t\t\t&& eap->cmdidx != CMD_laddfile),\n\t\t\tqf_cmdtitle(*eap->cmdlinep), enc);\n    if (wp != NULL)\n    {\n\tqi = GET_LOC_LIST(wp);\n\tif (qi == NULL)\n\t{\n\t    decr_quickfix_busy();\n\t    return;\n\t}\n    }\n    if (res >= 0)\n\tqf_list_changed(qf_get_curlist(qi));\n    save_qfid = qf_get_curlist(qi)->qf_id;\n    if (au_name != NULL)\n\tapply_autocmds(EVENT_QUICKFIXCMDPOST, au_name, NULL, FALSE, curbuf);\n\n    // Jump to the first error for a new list and if autocmds didn't\n    // free the list.\n    if (res > 0 && (eap->cmdidx == CMD_cfile || eap->cmdidx == CMD_lfile)\n\t    && qflist_valid(wp, save_qfid))\n\t// display the first error\n\tqf_jump_first(qi, save_qfid, eap->forceit);\n\n    decr_quickfix_busy();\n}\n\n/*\n * Return the vimgrep autocmd name.\n */\n    static char_u *\nvgr_get_auname(cmdidx_T cmdidx)\n{\n    switch (cmdidx)\n    {\n\tcase CMD_vimgrep:     return (char_u *)\"vimgrep\";\n\tcase CMD_lvimgrep:    return (char_u *)\"lvimgrep\";\n\tcase CMD_vimgrepadd:  return (char_u *)\"vimgrepadd\";\n\tcase CMD_lvimgrepadd: return (char_u *)\"lvimgrepadd\";\n\tcase CMD_grep:\t      return (char_u *)\"grep\";\n\tcase CMD_lgrep:\t      return (char_u *)\"lgrep\";\n\tcase CMD_grepadd:     return (char_u *)\"grepadd\";\n\tcase CMD_lgrepadd:    return (char_u *)\"lgrepadd\";\n\tdefault: return NULL;\n    }\n}\n\n/*\n * Initialize the regmatch used by vimgrep for pattern \"s\".\n */\n    static void\nvgr_init_regmatch(regmmatch_T *regmatch, char_u *s)\n{\n    // Get the search pattern: either white-separated or enclosed in //\n    regmatch->regprog = NULL;\n\n    if (s == NULL || *s == NUL)\n    {\n\t// Pattern is empty, use last search pattern.\n\tif (last_search_pat() == NULL)\n\t{\n\t    emsg(_(e_no_previous_regular_expression));\n\t    return;\n\t}\n\tregmatch->regprog = vim_regcomp(last_search_pat(), RE_MAGIC);\n    }\n    else\n\tregmatch->regprog = vim_regcomp(s, RE_MAGIC);\n\n    regmatch->rmm_ic = p_ic;\n    regmatch->rmm_maxcol = 0;\n}\n\n/*\n * Display a file name when vimgrep is running.\n */\n    static void\nvgr_display_fname(char_u *fname)\n{\n    char_u\t*p;\n\n    msg_start();\n    p = msg_strtrunc(fname, TRUE);\n    if (p == NULL)\n\tmsg_outtrans(fname);\n    else\n    {\n\tmsg_outtrans(p);\n\tvim_free(p);\n    }\n    msg_clr_eos();\n    msg_didout = FALSE;\t    // overwrite this message\n    msg_nowait = TRUE;\t    // don't wait for this message\n    msg_col = 0;\n    out_flush();\n}\n\n/*\n * Load a dummy buffer to search for a pattern using vimgrep.\n */\n    static buf_T *\nvgr_load_dummy_buf(\n\tchar_u *fname,\n\tchar_u *dirname_start,\n\tchar_u *dirname_now)\n{\n    int\t\tsave_mls;\n#if defined(FEAT_SYN_HL)\n    char_u\t*save_ei = NULL;\n#endif\n    buf_T\t*buf;\n\n#if defined(FEAT_SYN_HL)\n    // Don't do Filetype autocommands to avoid loading syntax and\n    // indent scripts, a great speed improvement.\n    save_ei = au_event_disable(\",Filetype\");\n#endif\n    // Don't use modelines here, it's useless.\n    save_mls = p_mls;\n    p_mls = 0;\n\n    // Load file into a buffer, so that 'fileencoding' is detected,\n    // autocommands applied, etc.\n    buf = load_dummy_buffer(fname, dirname_start, dirname_now);\n\n    p_mls = save_mls;\n#if defined(FEAT_SYN_HL)\n    au_event_restore(save_ei);\n#endif\n\n    return buf;\n}\n\n/*\n * Check whether a quickfix/location list is valid. Autocmds may remove or\n * change a quickfix list when vimgrep is running. If the list is not found,\n * create a new list.\n */\n    static int\nvgr_qflist_valid(\n\twin_T\t    *wp,\n\tqf_info_T   *qi,\n\tint_u\t    qfid,\n\tchar_u\t    *title)\n{\n    // Verify that the quickfix/location list was not freed by an autocmd\n    if (!qflist_valid(wp, qfid))\n    {\n\tif (wp != NULL)\n\t{\n\t    // An autocmd has freed the location list.\n\t    emsg(_(e_current_location_list_was_changed));\n\t    return FALSE;\n\t}\n\telse\n\t{\n\t    // Quickfix list is not found, create a new one.\n\t    qf_new_list(qi, title);\n\t    return TRUE;\n\t}\n    }\n\n    if (qf_restore_list(qi, qfid) == FAIL)\n\treturn FALSE;\n\n    return TRUE;\n}\n\n/*\n * Search for a pattern in all the lines in a buffer and add the matching lines\n * to a quickfix list.\n */\n    static int\nvgr_match_buflines(\n\tqf_list_T   *qfl,\n\tchar_u\t    *fname,\n\tbuf_T\t    *buf,\n\tchar_u\t    *spat,\n\tregmmatch_T *regmatch,\n\tlong\t    *tomatch,\n\tint\t    duplicate_name,\n\tint\t    flags)\n{\n    int\t\tfound_match = FALSE;\n    long\tlnum;\n    colnr_T\tcol;\n    int\t\tpat_len = (int)STRLEN(spat);\n\n    for (lnum = 1; lnum <= buf->b_ml.ml_line_count && *tomatch > 0; ++lnum)\n    {\n\tcol = 0;\n\tif (!(flags & VGR_FUZZY))\n\t{\n\t    // Regular expression match\n\t    while (vim_regexec_multi(regmatch, curwin, buf, lnum,\n\t\t\tcol, NULL) > 0)\n\t    {\n\t\t// Pass the buffer number so that it gets used even for a\n\t\t// dummy buffer, unless duplicate_name is set, then the\n\t\t// buffer will be wiped out below.\n\t\tif (qf_add_entry(qfl,\n\t\t\t    NULL,\t// dir\n\t\t\t    fname,\n\t\t\t    NULL,\n\t\t\t    duplicate_name ? 0 : buf->b_fnum,\n\t\t\t    ml_get_buf(buf,\n\t\t\t\tregmatch->startpos[0].lnum + lnum, FALSE),\n\t\t\t    regmatch->startpos[0].lnum + lnum,\n\t\t\t    regmatch->endpos[0].lnum + lnum,\n\t\t\t    regmatch->startpos[0].col + 1,\n\t\t\t    regmatch->endpos[0].col + 1,\n\t\t\t    FALSE,\t// vis_col\n\t\t\t    NULL,\t// search pattern\n\t\t\t    0,\t\t// nr\n\t\t\t    0,\t\t// type\n\t\t\t    TRUE\t// valid\n\t\t\t    ) == QF_FAIL)\n\t\t{\n\t\t    got_int = TRUE;\n\t\t    break;\n\t\t}\n\t\tfound_match = TRUE;\n\t\tif (--*tomatch == 0)\n\t\t    break;\n\t\tif ((flags & VGR_GLOBAL) == 0\n\t\t\t|| regmatch->endpos[0].lnum > 0)\n\t\t    break;\n\t\tcol = regmatch->endpos[0].col\n\t\t    + (col == regmatch->endpos[0].col);\n\t\tif (col > (colnr_T)STRLEN(ml_get_buf(buf, lnum, FALSE)))\n\t\t    break;\n\t    }\n\t}\n\telse\n\t{\n\t    char_u  *str = ml_get_buf(buf, lnum, FALSE);\n\t    int\t    score;\n\t    int_u   matches[MAX_FUZZY_MATCHES];\n\t    int_u   sz = ARRAY_LENGTH(matches);\n\n\t    // Fuzzy string match\n\t    while (fuzzy_match(str + col, spat, FALSE, &score, matches, sz) > 0)\n\t    {\n\t\t// Pass the buffer number so that it gets used even for a\n\t\t// dummy buffer, unless duplicate_name is set, then the\n\t\t// buffer will be wiped out below.\n\t\tif (qf_add_entry(qfl,\n\t\t\t    NULL,\t// dir\n\t\t\t    fname,\n\t\t\t    NULL,\n\t\t\t    duplicate_name ? 0 : buf->b_fnum,\n\t\t\t    str,\n\t\t\t    lnum,\n\t\t\t    0,\n\t\t\t    matches[0] + col + 1,\n\t\t\t    0,\n\t\t\t    FALSE,\t// vis_col\n\t\t\t    NULL,\t// search pattern\n\t\t\t    0,\t\t// nr\n\t\t\t    0,\t\t// type\n\t\t\t    TRUE\t// valid\n\t\t\t    ) == QF_FAIL)\n\t\t{\n\t\t    got_int = TRUE;\n\t\t    break;\n\t\t}\n\t\tfound_match = TRUE;\n\t\tif (--*tomatch == 0)\n\t\t    break;\n\t\tif ((flags & VGR_GLOBAL) == 0)\n\t\t    break;\n\t\tcol = matches[pat_len - 1] + col + 1;\n\t\tif (col > (colnr_T)STRLEN(str))\n\t\t    break;\n\t    }\n\t}\n\tline_breakcheck();\n\tif (got_int)\n\t    break;\n    }\n\n    return found_match;\n}\n\n/*\n * Jump to the first match and update the directory.\n */\n    static void\nvgr_jump_to_match(\n\tqf_info_T   *qi,\n\tint\t    forceit,\n\tint\t    *redraw_for_dummy,\n\tbuf_T\t    *first_match_buf,\n\tchar_u\t    *target_dir)\n{\n    buf_T\t*buf;\n\n    buf = curbuf;\n    qf_jump(qi, 0, 0, forceit);\n    if (buf != curbuf)\n\t// If we jumped to another buffer redrawing will already be\n\t// taken care of.\n\t*redraw_for_dummy = FALSE;\n\n    // Jump to the directory used after loading the buffer.\n    if (curbuf == first_match_buf && target_dir != NULL)\n    {\n\texarg_T ea;\n\n\tCLEAR_FIELD(ea);\n\tea.arg = target_dir;\n\tea.cmdidx = CMD_lcd;\n\tex_cd(&ea);\n    }\n}\n\n/*\n * :vimgrep command arguments\n */\ntypedef struct\n{\n    long\ttomatch;\t// maximum number of matches to find\n    char_u\t*spat;\t\t// search pattern\n    int\t\tflags;\t\t// search modifier\n    char_u\t**fnames;\t// list of files to search\n    int\t\tfcount;\t\t// number of files\n    regmmatch_T\tregmatch;\t// compiled search pattern\n    char_u\t*qf_title;\t// quickfix list title\n} vgr_args_T;\n\n/*\n * Process :vimgrep command arguments. The command syntax is:\n *\n *\t:{count}vimgrep /{pattern}/[g][j] {file} ...\n */\n    static int\nvgr_process_args(\n\texarg_T\t\t*eap,\n\tvgr_args_T\t*args)\n{\n    char_u\t*p;\n\n    CLEAR_POINTER(args);\n\n    args->regmatch.regprog = NULL;\n    args->qf_title = vim_strsave(qf_cmdtitle(*eap->cmdlinep));\n\n    if (eap->addr_count > 0)\n\targs->tomatch = eap->line2;\n    else\n\targs->tomatch = MAXLNUM;\n\n    // Get the search pattern: either white-separated or enclosed in //\n    p = skip_vimgrep_pat(eap->arg, &args->spat, &args->flags);\n    if (p == NULL)\n    {\n\temsg(_(e_invalid_search_pattern_or_delimiter));\n\treturn FAIL;\n    }\n\n    vgr_init_regmatch(&args->regmatch, args->spat);\n    if (args->regmatch.regprog == NULL)\n\treturn FAIL;\n\n    p = skipwhite(p);\n    if (*p == NUL)\n    {\n\temsg(_(e_file_name_missing_or_invalid_pattern));\n\treturn FAIL;\n    }\n\n    // Parse the list of arguments, wildcards have already been expanded.\n    if ((get_arglist_exp(p, &args->fcount, &args->fnames, TRUE) == FAIL) ||\n\targs->fcount == 0)\n    {\n\temsg(_(e_no_match));\n\treturn FAIL;\n    }\n\n    return OK;\n}\n\n/*\n * Return TRUE if \"buf\" had an existing swap file, the current swap file does\n * not end in \".swp\".\n */\n    static int\nexisting_swapfile(buf_T *buf)\n{\n    if (buf->b_ml.ml_mfp != NULL && buf->b_ml.ml_mfp->mf_fname != NULL)\n    {\n\tchar_u *fname = buf->b_ml.ml_mfp->mf_fname;\n\tsize_t len = STRLEN(fname);\n\n\treturn fname[len - 1] != 'p' || fname[len - 2] != 'w';\n    }\n    return FALSE;\n}\n\n/*\n * Search for a pattern in a list of files and populate the quickfix list with\n * the matches.\n */\n    static int\nvgr_process_files(\n\twin_T\t\t*wp,\n\tqf_info_T\t*qi,\n\tvgr_args_T\t*cmd_args,\n\tint\t\t*redraw_for_dummy,\n\tbuf_T\t\t**first_match_buf,\n\tchar_u\t\t**target_dir)\n{\n    int\t\tstatus = FAIL;\n    int_u\tsave_qfid = qf_get_curlist(qi)->qf_id;\n    time_t\tseconds = 0;\n    char_u\t*fname;\n    int\t\tfi;\n    buf_T\t*buf;\n    int\t\tduplicate_name = FALSE;\n    int\t\tusing_dummy;\n    char_u\t*dirname_start = NULL;\n    char_u\t*dirname_now = NULL;\n    int\t\tfound_match;\n    aco_save_T\taco;\n\n    dirname_start = alloc_id(MAXPATHL, aid_qf_dirname_start);\n    dirname_now = alloc_id(MAXPATHL, aid_qf_dirname_now);\n    if (dirname_start == NULL || dirname_now == NULL)\n\tgoto theend;\n\n    // Remember the current directory, because a BufRead autocommand that does\n    // \":lcd %:p:h\" changes the meaning of short path names.\n    mch_dirname(dirname_start, MAXPATHL);\n\n    seconds = (time_t)0;\n    for (fi = 0; fi < cmd_args->fcount && !got_int && cmd_args->tomatch > 0;\n\t\t\t\t\t\t\t\t\t++fi)\n    {\n\tfname = shorten_fname1(cmd_args->fnames[fi]);\n\tif (time(NULL) > seconds)\n\t{\n\t    // Display the file name every second or so, show the user we are\n\t    // working on it.\n\t    seconds = time(NULL);\n\t    vgr_display_fname(fname);\n\t}\n\n\tbuf = buflist_findname_exp(cmd_args->fnames[fi]);\n\tif (buf == NULL || buf->b_ml.ml_mfp == NULL)\n\t{\n\t    // Remember that a buffer with this name already exists.\n\t    duplicate_name = (buf != NULL);\n\t    using_dummy = TRUE;\n\t    *redraw_for_dummy = TRUE;\n\n\t    buf = vgr_load_dummy_buf(fname, dirname_start, dirname_now);\n\t}\n\telse\n\t    // Use existing, loaded buffer.\n\t    using_dummy = FALSE;\n\n\t// Check whether the quickfix list is still valid. When loading a\n\t// buffer above, autocommands might have changed the quickfix list.\n\tif (!vgr_qflist_valid(wp, qi, save_qfid, cmd_args->qf_title))\n\t    goto theend;\n\n\tsave_qfid = qf_get_curlist(qi)->qf_id;\n\n\tif (buf == NULL)\n\t{\n\t    if (!got_int)\n\t\tsmsg(_(\"Cannot open file \\\"%s\\\"\"), fname);\n\t}\n\telse\n\t{\n\t    // Try for a match in all lines of the buffer.\n\t    // For \":1vimgrep\" look for first match only.\n\t    found_match = vgr_match_buflines(qf_get_curlist(qi),\n\t\t    fname, buf, cmd_args->spat, &cmd_args->regmatch,\n\t\t    &cmd_args->tomatch, duplicate_name, cmd_args->flags);\n\n\t    if (using_dummy)\n\t    {\n\t\tif (found_match && *first_match_buf == NULL)\n\t\t    *first_match_buf = buf;\n\t\tif (duplicate_name)\n\t\t{\n\t\t    // Never keep a dummy buffer if there is another buffer\n\t\t    // with the same name.\n\t\t    wipe_dummy_buffer(buf, dirname_start);\n\t\t    buf = NULL;\n\t\t}\n\t\telse if ((cmdmod.cmod_flags & CMOD_HIDE) == 0\n\t\t\t    || buf->b_p_bh[0] == 'u'\t// \"unload\"\n\t\t\t    || buf->b_p_bh[0] == 'w'\t// \"wipe\"\n\t\t\t    || buf->b_p_bh[0] == 'd')\t// \"delete\"\n\t\t{\n\t\t    // When no match was found we don't need to remember the\n\t\t    // buffer, wipe it out.  If there was a match and it\n\t\t    // wasn't the first one or we won't jump there: only\n\t\t    // unload the buffer.\n\t\t    // Ignore 'hidden' here, because it may lead to having too\n\t\t    // many swap files.\n\t\t    if (!found_match)\n\t\t    {\n\t\t\twipe_dummy_buffer(buf, dirname_start);\n\t\t\tbuf = NULL;\n\t\t    }\n\t\t    else if (buf != *first_match_buf\n\t\t\t\t\t|| (cmd_args->flags & VGR_NOJUMP)\n\t\t\t\t\t|| existing_swapfile(buf))\n\t\t    {\n\t\t\tunload_dummy_buffer(buf, dirname_start);\n\t\t\t// Keeping the buffer, remove the dummy flag.\n\t\t\tbuf->b_flags &= ~BF_DUMMY;\n\t\t\tbuf = NULL;\n\t\t    }\n\t\t}\n\n\t\tif (buf != NULL)\n\t\t{\n\t\t    // Keeping the buffer, remove the dummy flag.\n\t\t    buf->b_flags &= ~BF_DUMMY;\n\n\t\t    // If the buffer is still loaded we need to use the\n\t\t    // directory we jumped to below.\n\t\t    if (buf == *first_match_buf\n\t\t\t    && *target_dir == NULL\n\t\t\t    && STRCMP(dirname_start, dirname_now) != 0)\n\t\t\t*target_dir = vim_strsave(dirname_now);\n\n\t\t    // The buffer is still loaded, the Filetype autocommands\n\t\t    // need to be done now, in that buffer.  And the modelines\n\t\t    // need to be done (again).  But not the window-local\n\t\t    // options!\n\t\t    aucmd_prepbuf(&aco, buf);\n\t\t    if (curbuf == buf)\n\t\t    {\n#if defined(FEAT_SYN_HL)\n\t\t\tapply_autocmds(EVENT_FILETYPE, buf->b_p_ft,\n\t\t\t\t\t\t     buf->b_fname, TRUE, buf);\n#endif\n\t\t\tdo_modelines(OPT_NOWIN);\n\t\t\taucmd_restbuf(&aco);\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n    status = OK;\n\ntheend:\n    vim_free(dirname_now);\n    vim_free(dirname_start);\n    return status;\n}\n\n/*\n * \":vimgrep {pattern} file(s)\"\n * \":vimgrepadd {pattern} file(s)\"\n * \":lvimgrep {pattern} file(s)\"\n * \":lvimgrepadd {pattern} file(s)\"\n */\n    void\nex_vimgrep(exarg_T *eap)\n{\n    vgr_args_T\targs;\n    qf_info_T\t*qi;\n    qf_list_T\t*qfl;\n    int_u\tsave_qfid;\n    win_T\t*wp = NULL;\n    int\t\tredraw_for_dummy = FALSE;\n    buf_T\t*first_match_buf = NULL;\n    char_u\t*target_dir = NULL;\n    char_u\t*au_name =  NULL;\n    int\t\tstatus;\n\n    au_name = vgr_get_auname(eap->cmdidx);\n    if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,\n\t\t\t\t\t       curbuf->b_fname, TRUE, curbuf))\n    {\n#ifdef FEAT_EVAL\n\tif (aborting())\n\t    return;\n#endif\n    }\n\n    qi = qf_cmd_get_or_alloc_stack(eap, &wp);\n    if (qi == NULL)\n\treturn;\n\n    if (vgr_process_args(eap, &args) == FAIL)\n\tgoto theend;\n\n    if ((eap->cmdidx != CMD_grepadd && eap->cmdidx != CMD_lgrepadd\n\t\t&& eap->cmdidx != CMD_vimgrepadd\n\t\t&& eap->cmdidx != CMD_lvimgrepadd)\n\t\t\t\t\t|| qf_stack_empty(qi))\n\t// make place for a new list\n\tqf_new_list(qi, args.qf_title);\n\n    incr_quickfix_busy();\n\n    status = vgr_process_files(wp, qi, &args, &redraw_for_dummy,\n\t\t\t\t\t\t&first_match_buf, &target_dir);\n    if (status != OK)\n    {\n\tFreeWild(args.fcount, args.fnames);\n\tdecr_quickfix_busy();\n\tgoto theend;\n    }\n\n    FreeWild(args.fcount, args.fnames);\n\n    qfl = qf_get_curlist(qi);\n    qfl->qf_nonevalid = FALSE;\n    qfl->qf_ptr = qfl->qf_start;\n    qfl->qf_index = 1;\n    qf_list_changed(qfl);\n\n    qf_update_buffer(qi, NULL);\n\n    // Remember the current quickfix list identifier, so that we can check for\n    // autocommands changing the current quickfix list.\n    save_qfid = qf_get_curlist(qi)->qf_id;\n\n    if (au_name != NULL)\n\tapply_autocmds(EVENT_QUICKFIXCMDPOST, au_name,\n\t\t\t\t\t       curbuf->b_fname, TRUE, curbuf);\n    // The QuickFixCmdPost autocmd may free the quickfix list. Check the list\n    // is still valid.\n    if (!qflist_valid(wp, save_qfid)\n\t    || qf_restore_list(qi, save_qfid) == FAIL)\n    {\n\tdecr_quickfix_busy();\n\tgoto theend;\n    }\n\n    // Jump to first match.\n    if (!qf_list_empty(qf_get_curlist(qi)))\n    {\n\tif ((args.flags & VGR_NOJUMP) == 0)\n\t    vgr_jump_to_match(qi, eap->forceit, &redraw_for_dummy,\n\t\t    first_match_buf, target_dir);\n    }\n    else\n\tsemsg(_(e_no_match_str_2), args.spat);\n\n    decr_quickfix_busy();\n\n    // If we loaded a dummy buffer into the current window, the autocommands\n    // may have messed up things, need to redraw and recompute folds.\n    if (redraw_for_dummy)\n    {\n#ifdef FEAT_FOLDING\n\tfoldUpdateAll(curwin);\n#else\n\tredraw_later(UPD_NOT_VALID);\n#endif\n    }\n\ntheend:\n    vim_free(args.qf_title);\n    vim_free(target_dir);\n    vim_regfree(args.regmatch.regprog);\n}\n\n/*\n * Restore current working directory to \"dirname_start\" if they differ, taking\n * into account whether it is set locally or globally.\n */\n    static void\nrestore_start_dir(char_u *dirname_start)\n{\n    char_u *dirname_now = alloc(MAXPATHL);\n\n    if (dirname_now == NULL)\n\treturn;\n\n    mch_dirname(dirname_now, MAXPATHL);\n    if (STRCMP(dirname_start, dirname_now) != 0)\n    {\n\t// If the directory has changed, change it back by building up an\n\t// appropriate ex command and executing it.\n\texarg_T ea;\n\n\tCLEAR_FIELD(ea);\n\tea.arg = dirname_start;\n\tea.cmdidx = (curwin->w_localdir == NULL) ? CMD_cd : CMD_lcd;\n\tex_cd(&ea);\n    }\n    vim_free(dirname_now);\n}\n\n/*\n * Load file \"fname\" into a dummy buffer and return the buffer pointer,\n * placing the directory resulting from the buffer load into the\n * \"resulting_dir\" pointer. \"resulting_dir\" must be allocated by the caller\n * prior to calling this function. Restores directory to \"dirname_start\" prior\n * to returning, if autocmds or the 'autochdir' option have changed it.\n *\n * If creating the dummy buffer does not fail, must call unload_dummy_buffer()\n * or wipe_dummy_buffer() later!\n *\n * Returns NULL if it fails.\n */\n    static buf_T *\nload_dummy_buffer(\n    char_u\t*fname,\n    char_u\t*dirname_start,  // in: old directory\n    char_u\t*resulting_dir)  // out: new directory\n{\n    buf_T\t*newbuf;\n    bufref_T\tnewbufref;\n    bufref_T\tnewbuf_to_wipe;\n    int\t\tfailed = TRUE;\n    aco_save_T\taco;\n    int\t\treadfile_result;\n\n    // Allocate a buffer without putting it in the buffer list.\n    newbuf = buflist_new(NULL, NULL, (linenr_T)1, BLN_DUMMY);\n    if (newbuf == NULL)\n\treturn NULL;\n    set_bufref(&newbufref, newbuf);\n\n    // Init the options.\n    buf_copy_options(newbuf, BCO_ENTER | BCO_NOHELP);\n\n    // need to open the memfile before putting the buffer in a window\n    if (ml_open(newbuf) == OK)\n    {\n\t// Make sure this buffer isn't wiped out by autocommands.\n\t++newbuf->b_locked;\n\n\t// set curwin/curbuf to buf and save a few things\n\taucmd_prepbuf(&aco, newbuf);\n\tif (curbuf == newbuf)\n\t{\n\t    // Need to set the filename for autocommands.\n\t    (void)setfname(curbuf, fname, NULL, FALSE);\n\n\t    // Create swap file now to avoid the ATTENTION message.\n\t    check_need_swap(TRUE);\n\n\t    // Remove the \"dummy\" flag, otherwise autocommands may not\n\t    // work.\n\t    curbuf->b_flags &= ~BF_DUMMY;\n\n\t    newbuf_to_wipe.br_buf = NULL;\n\t    readfile_result = readfile(fname, NULL,\n\t\t\t(linenr_T)0, (linenr_T)0, (linenr_T)MAXLNUM,\n\t\t\tNULL, READ_NEW | READ_DUMMY);\n\t    --newbuf->b_locked;\n\t    if (readfile_result == OK\n\t\t    && !got_int\n\t\t    && !(curbuf->b_flags & BF_NEW))\n\t    {\n\t\tfailed = FALSE;\n\t\tif (curbuf != newbuf)\n\t\t{\n\t\t    // Bloody autocommands changed the buffer!  Can happen when\n\t\t    // using netrw and editing a remote file.  Use the current\n\t\t    // buffer instead, delete the dummy one after restoring the\n\t\t    // window stuff.\n\t\t    set_bufref(&newbuf_to_wipe, newbuf);\n\t\t    newbuf = curbuf;\n\t\t}\n\t    }\n\n\t    // restore curwin/curbuf and a few other things\n\t    aucmd_restbuf(&aco);\n\n\t    if (newbuf_to_wipe.br_buf != NULL && bufref_valid(&newbuf_to_wipe))\n\t\twipe_buffer(newbuf_to_wipe.br_buf, FALSE);\n\t}\n\n\t// Add back the \"dummy\" flag, otherwise buflist_findname_stat() won't\n\t// skip it.\n\tnewbuf->b_flags |= BF_DUMMY;\n    }\n\n    // When autocommands/'autochdir' option changed directory: go back.\n    // Let the caller know what the resulting dir was first, in case it is\n    // important.\n    mch_dirname(resulting_dir, MAXPATHL);\n    restore_start_dir(dirname_start);\n\n    if (!bufref_valid(&newbufref))\n\treturn NULL;\n    if (failed)\n    {\n\twipe_dummy_buffer(newbuf, dirname_start);\n\treturn NULL;\n    }\n    return newbuf;\n}\n\n/*\n * Wipe out the dummy buffer that load_dummy_buffer() created. Restores\n * directory to \"dirname_start\" prior to returning, if autocmds or the\n * 'autochdir' option have changed it.\n */\n    static void\nwipe_dummy_buffer(buf_T *buf, char_u *dirname_start)\n{\n    // If any autocommand opened a window on the dummy buffer, close that\n    // window.  If we can't close them all then give up.\n    while (buf->b_nwindows > 0)\n    {\n\tint\t    did_one = FALSE;\n\twin_T\t    *wp;\n\n\tif (firstwin->w_next != NULL)\n\t    FOR_ALL_WINDOWS(wp)\n\t\tif (wp->w_buffer == buf)\n\t\t{\n\t\t    if (win_close(wp, FALSE) == OK)\n\t\t\tdid_one = TRUE;\n\t\t    break;\n\t\t}\n\tif (!did_one)\n\t    return;\n    }\n\n    if (curbuf != buf && buf->b_nwindows == 0)\t// safety check\n    {\n#if defined(FEAT_EVAL)\n\tcleanup_T   cs;\n\n\t// Reset the error/interrupt/exception state here so that aborting()\n\t// returns FALSE when wiping out the buffer.  Otherwise it doesn't\n\t// work when got_int is set.\n\tenter_cleanup(&cs);\n#endif\n\n\twipe_buffer(buf, TRUE);\n\n#if defined(FEAT_EVAL)\n\t// Restore the error/interrupt/exception state if not discarded by a\n\t// new aborting error, interrupt, or uncaught exception.\n\tleave_cleanup(&cs);\n#endif\n\t// When autocommands/'autochdir' option changed directory: go back.\n\trestore_start_dir(dirname_start);\n    }\n}\n\n/*\n * Unload the dummy buffer that load_dummy_buffer() created. Restores\n * directory to \"dirname_start\" prior to returning, if autocmds or the\n * 'autochdir' option have changed it.\n */\n    static void\nunload_dummy_buffer(buf_T *buf, char_u *dirname_start)\n{\n    if (curbuf == buf)\t\t// safety check\n\treturn;\n\n    close_buffer(NULL, buf, DOBUF_UNLOAD, FALSE, TRUE);\n\n    // When autocommands/'autochdir' option changed directory: go back.\n    restore_start_dir(dirname_start);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Copy the specified quickfix entry items into a new dict and append the dict\n * to 'list'.  Returns OK on success.\n */\n    static int\nget_qfline_items(qfline_T *qfp, list_T *list)\n{\n    int\t\tbufnum;\n    dict_T\t*dict;\n    char_u\tbuf[2];\n\n    // Handle entries with a non-existing buffer number.\n    bufnum = qfp->qf_fnum;\n    if (bufnum != 0 && (buflist_findnr(bufnum) == NULL))\n\tbufnum = 0;\n\n    if ((dict = dict_alloc()) == NULL)\n\treturn FAIL;\n    if (list_append_dict(list, dict) == FAIL)\n\treturn FAIL;\n\n    buf[0] = qfp->qf_type;\n    buf[1] = NUL;\n    if (dict_add_number(dict, \"bufnr\", (long)bufnum) == FAIL\n\t    || dict_add_number(dict, \"lnum\",     (long)qfp->qf_lnum) == FAIL\n\t    || dict_add_number(dict, \"end_lnum\", (long)qfp->qf_end_lnum) == FAIL\n\t    || dict_add_number(dict, \"col\",      (long)qfp->qf_col) == FAIL\n\t    || dict_add_number(dict, \"end_col\",  (long)qfp->qf_end_col) == FAIL\n\t    || dict_add_number(dict, \"vcol\",     (long)qfp->qf_viscol) == FAIL\n\t    || dict_add_number(dict, \"nr\",       (long)qfp->qf_nr) == FAIL\n\t    || dict_add_string(dict, \"module\", qfp->qf_module) == FAIL\n\t    || dict_add_string(dict, \"pattern\", qfp->qf_pattern) == FAIL\n\t    || dict_add_string(dict, \"text\", qfp->qf_text) == FAIL\n\t    || dict_add_string(dict, \"type\", buf) == FAIL\n\t    || dict_add_number(dict, \"valid\", (long)qfp->qf_valid) == FAIL)\n\treturn FAIL;\n\n    return OK;\n}\n\n/*\n * Add each quickfix error to list \"list\" as a dictionary.\n * If qf_idx is -1, use the current list. Otherwise, use the specified list.\n * If eidx is not 0, then return only the specified entry. Otherwise return\n * all the entries.\n */\n    static int\nget_errorlist(\n\tqf_info_T\t*qi_arg,\n\twin_T\t\t*wp,\n\tint\t\tqf_idx,\n\tint\t\teidx,\n\tlist_T\t\t*list)\n{\n    qf_info_T\t*qi = qi_arg;\n    qf_list_T\t*qfl;\n    qfline_T\t*qfp;\n    int\t\ti;\n\n    if (qi == NULL)\n    {\n\tqi = &ql_info;\n\tif (wp != NULL)\n\t{\n\t    qi = GET_LOC_LIST(wp);\n\t    if (qi == NULL)\n\t\treturn FAIL;\n\t}\n    }\n\n    if (eidx < 0)\n\treturn OK;\n\n    if (qf_idx == INVALID_QFIDX)\n\tqf_idx = qi->qf_curlist;\n\n    if (qf_idx >= qi->qf_listcount)\n\treturn FAIL;\n\n    qfl = qf_get_list(qi, qf_idx);\n    if (qf_list_empty(qfl))\n\treturn FAIL;\n\n    FOR_ALL_QFL_ITEMS(qfl, qfp, i)\n    {\n\tif (eidx > 0)\n\t{\n\t    if (eidx == i)\n\t\treturn get_qfline_items(qfp, list);\n\t}\n\telse if (get_qfline_items(qfp, list) == FAIL)\n\t    return FAIL;\n    }\n\n    return OK;\n}\n\n// Flags used by getqflist()/getloclist() to determine which fields to return.\nenum {\n    QF_GETLIST_NONE\t= 0x0,\n    QF_GETLIST_TITLE\t= 0x1,\n    QF_GETLIST_ITEMS\t= 0x2,\n    QF_GETLIST_NR\t= 0x4,\n    QF_GETLIST_WINID\t= 0x8,\n    QF_GETLIST_CONTEXT\t= 0x10,\n    QF_GETLIST_ID\t= 0x20,\n    QF_GETLIST_IDX\t= 0x40,\n    QF_GETLIST_SIZE\t= 0x80,\n    QF_GETLIST_TICK\t= 0x100,\n    QF_GETLIST_FILEWINID\t= 0x200,\n    QF_GETLIST_QFBUFNR\t= 0x400,\n    QF_GETLIST_QFTF\t= 0x800,\n    QF_GETLIST_ALL\t= 0xFFF,\n};\n\n/*\n * Parse text from 'di' and return the quickfix list items.\n * Existing quickfix lists are not modified.\n */\n    static int\nqf_get_list_from_lines(dict_T *what, dictitem_T *di, dict_T *retdict)\n{\n    int\t\tstatus = FAIL;\n    qf_info_T\t*qi;\n    char_u\t*errorformat = p_efm;\n    dictitem_T\t*efm_di;\n    list_T\t*l;\n\n    // Only a List value is supported\n    if (di->di_tv.v_type != VAR_LIST || di->di_tv.vval.v_list == NULL)\n\treturn FAIL;\n\n    // If errorformat is supplied then use it, otherwise use the 'efm'\n    // option setting\n    if ((efm_di = dict_find(what, (char_u *)\"efm\", -1)) != NULL)\n    {\n\tif (efm_di->di_tv.v_type != VAR_STRING ||\n\t\tefm_di->di_tv.vval.v_string == NULL)\n\t    return FAIL;\n\terrorformat = efm_di->di_tv.vval.v_string;\n    }\n\n    l = list_alloc();\n    if (l == NULL)\n\treturn FAIL;\n\n    qi = qf_alloc_stack(QFLT_INTERNAL);\n    if (qi != NULL)\n    {\n\tif (qf_init_ext(qi, 0, NULL, NULL, &di->di_tv, errorformat,\n\t\t    TRUE, (linenr_T)0, (linenr_T)0, NULL, NULL) > 0)\n\t{\n\t    (void)get_errorlist(qi, NULL, 0, 0, l);\n\t    qf_free(&qi->qf_lists[0]);\n\t}\n\tfree(qi);\n    }\n    dict_add_list(retdict, \"items\", l);\n    status = OK;\n\n    return status;\n}\n\n/*\n * Return the quickfix/location list window identifier in the current tabpage.\n */\n    static int\nqf_winid(qf_info_T *qi)\n{\n    win_T\t*win;\n\n    // The quickfix window can be opened even if the quickfix list is not set\n    // using \":copen\". This is not true for location lists.\n    if (qi == NULL)\n\treturn 0;\n    win = qf_find_win(qi);\n    if (win != NULL)\n\treturn win->w_id;\n    return 0;\n}\n\n/*\n * Returns the number of the buffer displayed in the quickfix/location list\n * window. If there is no buffer associated with the list or the buffer is\n * wiped out, then returns 0.\n */\n    static int\nqf_getprop_qfbufnr(qf_info_T *qi, dict_T *retdict)\n{\n    int\tbufnum = 0;\n\n    if (qi != NULL && buflist_findnr(qi->qf_bufnr) != NULL)\n\tbufnum = qi->qf_bufnr;\n\n    return dict_add_number(retdict, \"qfbufnr\", bufnum);\n}\n\n/*\n * Convert the keys in 'what' to quickfix list property flags.\n */\n    static int\nqf_getprop_keys2flags(dict_T *what, int loclist)\n{\n    int\t\tflags = QF_GETLIST_NONE;\n\n    if (dict_has_key(what, \"all\"))\n    {\n\tflags |= QF_GETLIST_ALL;\n\tif (!loclist)\n\t    // File window ID is applicable only to location list windows\n\t    flags &= ~ QF_GETLIST_FILEWINID;\n    }\n\n    if (dict_has_key(what, \"title\"))\n\tflags |= QF_GETLIST_TITLE;\n\n    if (dict_has_key(what, \"nr\"))\n\tflags |= QF_GETLIST_NR;\n\n    if (dict_has_key(what, \"winid\"))\n\tflags |= QF_GETLIST_WINID;\n\n    if (dict_has_key(what, \"context\"))\n\tflags |= QF_GETLIST_CONTEXT;\n\n    if (dict_has_key(what, \"id\"))\n\tflags |= QF_GETLIST_ID;\n\n    if (dict_has_key(what, \"items\"))\n\tflags |= QF_GETLIST_ITEMS;\n\n    if (dict_has_key(what, \"idx\"))\n\tflags |= QF_GETLIST_IDX;\n\n    if (dict_has_key(what, \"size\"))\n\tflags |= QF_GETLIST_SIZE;\n\n    if (dict_has_key(what, \"changedtick\"))\n\tflags |= QF_GETLIST_TICK;\n\n    if (loclist && dict_has_key(what, \"filewinid\"))\n\tflags |= QF_GETLIST_FILEWINID;\n\n    if (dict_has_key(what, \"qfbufnr\"))\n\tflags |= QF_GETLIST_QFBUFNR;\n\n    if (dict_has_key(what, \"quickfixtextfunc\"))\n\tflags |= QF_GETLIST_QFTF;\n\n    return flags;\n}\n\n/*\n * Return the quickfix list index based on 'nr' or 'id' in 'what'.\n * If 'nr' and 'id' are not present in 'what' then return the current\n * quickfix list index.\n * If 'nr' is zero then return the current quickfix list index.\n * If 'nr' is '$' then return the last quickfix list index.\n * If 'id' is present then return the index of the quickfix list with that id.\n * If 'id' is zero then return the quickfix list index specified by 'nr'.\n * Return -1, if quickfix list is not present or if the stack is empty.\n */\n    static int\nqf_getprop_qfidx(qf_info_T *qi, dict_T *what)\n{\n    int\t\tqf_idx;\n    dictitem_T\t*di;\n\n    qf_idx = qi->qf_curlist;\t// default is the current list\n    if ((di = dict_find(what, (char_u *)\"nr\", -1)) != NULL)\n    {\n\t// Use the specified quickfix/location list\n\tif (di->di_tv.v_type == VAR_NUMBER)\n\t{\n\t    // for zero use the current list\n\t    if (di->di_tv.vval.v_number != 0)\n\t    {\n\t\tqf_idx = di->di_tv.vval.v_number - 1;\n\t\tif (qf_idx < 0 || qf_idx >= qi->qf_listcount)\n\t\t    qf_idx = INVALID_QFIDX;\n\t    }\n\t}\n\telse if (di->di_tv.v_type == VAR_STRING\n\t\t&& di->di_tv.vval.v_string != NULL\n\t\t&& STRCMP(di->di_tv.vval.v_string, \"$\") == 0)\n\t    // Get the last quickfix list number\n\t    qf_idx = qi->qf_listcount - 1;\n\telse\n\t    qf_idx = INVALID_QFIDX;\n    }\n\n    if ((di = dict_find(what, (char_u *)\"id\", -1)) != NULL)\n    {\n\t// Look for a list with the specified id\n\tif (di->di_tv.v_type == VAR_NUMBER)\n\t{\n\t    // For zero, use the current list or the list specified by 'nr'\n\t    if (di->di_tv.vval.v_number != 0)\n\t\tqf_idx = qf_id2nr(qi, di->di_tv.vval.v_number);\n\t}\n\telse\n\t    qf_idx = INVALID_QFIDX;\n    }\n\n    return qf_idx;\n}\n\n/*\n * Return default values for quickfix list properties in retdict.\n */\n    static int\nqf_getprop_defaults(qf_info_T *qi, int flags, int locstack, dict_T *retdict)\n{\n    int\t\tstatus = OK;\n\n    if (flags & QF_GETLIST_TITLE)\n\tstatus = dict_add_string(retdict, \"title\", (char_u *)\"\");\n    if ((status == OK) && (flags & QF_GETLIST_ITEMS))\n    {\n\tlist_T\t*l = list_alloc();\n\tif (l != NULL)\n\t    status = dict_add_list(retdict, \"items\", l);\n\telse\n\t    status = FAIL;\n    }\n    if ((status == OK) && (flags & QF_GETLIST_NR))\n\tstatus = dict_add_number(retdict, \"nr\", 0);\n    if ((status == OK) && (flags & QF_GETLIST_WINID))\n\tstatus = dict_add_number(retdict, \"winid\", qf_winid(qi));\n    if ((status == OK) && (flags & QF_GETLIST_CONTEXT))\n\tstatus = dict_add_string(retdict, \"context\", (char_u *)\"\");\n    if ((status == OK) && (flags & QF_GETLIST_ID))\n\tstatus = dict_add_number(retdict, \"id\", 0);\n    if ((status == OK) && (flags & QF_GETLIST_IDX))\n\tstatus = dict_add_number(retdict, \"idx\", 0);\n    if ((status == OK) && (flags & QF_GETLIST_SIZE))\n\tstatus = dict_add_number(retdict, \"size\", 0);\n    if ((status == OK) && (flags & QF_GETLIST_TICK))\n\tstatus = dict_add_number(retdict, \"changedtick\", 0);\n    if ((status == OK) && locstack && (flags & QF_GETLIST_FILEWINID))\n\tstatus = dict_add_number(retdict, \"filewinid\", 0);\n    if ((status == OK) && (flags & QF_GETLIST_QFBUFNR))\n\tstatus = qf_getprop_qfbufnr(qi, retdict);\n    if ((status == OK) && (flags & QF_GETLIST_QFTF))\n\tstatus = dict_add_string(retdict, \"quickfixtextfunc\", (char_u *)\"\");\n\n    return status;\n}\n\n/*\n * Return the quickfix list title as 'title' in retdict\n */\n    static int\nqf_getprop_title(qf_list_T *qfl, dict_T *retdict)\n{\n    return dict_add_string(retdict, \"title\", qfl->qf_title);\n}\n\n/*\n * Returns the identifier of the window used to display files from a location\n * list.  If there is no associated window, then returns 0. Useful only when\n * called from a location list window.\n */\n    static int\nqf_getprop_filewinid(win_T *wp, qf_info_T *qi, dict_T *retdict)\n{\n    int winid = 0;\n\n    if (wp != NULL && IS_LL_WINDOW(wp))\n    {\n\twin_T\t*ll_wp = qf_find_win_with_loclist(qi);\n\tif (ll_wp != NULL)\n\t    winid = ll_wp->w_id;\n    }\n\n    return dict_add_number(retdict, \"filewinid\", winid);\n}\n\n/*\n * Return the quickfix list items/entries as 'items' in retdict.\n * If eidx is not 0, then return the item at the specified index.\n */\n    static int\nqf_getprop_items(qf_info_T *qi, int qf_idx, int eidx, dict_T *retdict)\n{\n    int\t\tstatus = OK;\n    list_T\t*l = list_alloc();\n    if (l != NULL)\n    {\n\t(void)get_errorlist(qi, NULL, qf_idx, eidx, l);\n\tdict_add_list(retdict, \"items\", l);\n    }\n    else\n\tstatus = FAIL;\n\n    return status;\n}\n\n/*\n * Return the quickfix list context (if any) as 'context' in retdict.\n */\n    static int\nqf_getprop_ctx(qf_list_T *qfl, dict_T *retdict)\n{\n    int\t\tstatus;\n    dictitem_T\t*di;\n\n    if (qfl->qf_ctx != NULL)\n    {\n\tdi = dictitem_alloc((char_u *)\"context\");\n\tif (di != NULL)\n\t{\n\t    copy_tv(qfl->qf_ctx, &di->di_tv);\n\t    status = dict_add(retdict, di);\n\t    if (status == FAIL)\n\t\tdictitem_free(di);\n\t}\n\telse\n\t    status = FAIL;\n    }\n    else\n\tstatus = dict_add_string(retdict, \"context\", (char_u *)\"\");\n\n    return status;\n}\n\n/*\n * Return the current quickfix list index as 'idx' in retdict.\n * If a specific entry index (eidx) is supplied, then use that.\n */\n    static int\nqf_getprop_idx(qf_list_T *qfl, int eidx, dict_T *retdict)\n{\n    if (eidx == 0)\n    {\n\teidx = qfl->qf_index;\n\tif (qf_list_empty(qfl))\n\t    // For empty lists, current index is set to 0\n\t    eidx = 0;\n    }\n    return dict_add_number(retdict, \"idx\", eidx);\n}\n\n/*\n * Return the 'quickfixtextfunc' function of a quickfix/location list\n */\n    static int\nqf_getprop_qftf(qf_list_T *qfl, dict_T *retdict)\n{\n    int\t\tstatus;\n\n    if (qfl->qf_qftf_cb.cb_name != NULL)\n    {\n\ttypval_T\ttv;\n\n\tput_callback(&qfl->qf_qftf_cb, &tv);\n\tstatus = dict_add_tv(retdict, \"quickfixtextfunc\", &tv);\n\tclear_tv(&tv);\n    }\n    else\n\tstatus = dict_add_string(retdict, \"quickfixtextfunc\", (char_u *)\"\");\n\n    return status;\n}\n\n/*\n * Return quickfix/location list details (title) as a\n * dictionary. 'what' contains the details to return. If 'list_idx' is -1,\n * then current list is used. Otherwise the specified list is used.\n */\n    static int\nqf_get_properties(win_T *wp, dict_T *what, dict_T *retdict)\n{\n    qf_info_T\t*qi = &ql_info;\n    qf_list_T\t*qfl;\n    int\t\tstatus = OK;\n    int\t\tqf_idx = INVALID_QFIDX;\n    int\t\teidx = 0;\n    dictitem_T\t*di;\n    int\t\tflags = QF_GETLIST_NONE;\n\n    if ((di = dict_find(what, (char_u *)\"lines\", -1)) != NULL)\n\treturn qf_get_list_from_lines(what, di, retdict);\n\n    if (wp != NULL)\n\tqi = GET_LOC_LIST(wp);\n\n    flags = qf_getprop_keys2flags(what, (wp != NULL));\n\n    if (!qf_stack_empty(qi))\n\tqf_idx = qf_getprop_qfidx(qi, what);\n\n    // List is not present or is empty\n    if (qf_stack_empty(qi) || qf_idx == INVALID_QFIDX)\n\treturn qf_getprop_defaults(qi, flags, wp != NULL, retdict);\n\n    qfl = qf_get_list(qi, qf_idx);\n\n    // If an entry index is specified, use that\n    if ((di = dict_find(what, (char_u *)\"idx\", -1)) != NULL)\n    {\n\tif (di->di_tv.v_type != VAR_NUMBER)\n\t    return FAIL;\n\teidx = di->di_tv.vval.v_number;\n    }\n\n    if (flags & QF_GETLIST_TITLE)\n\tstatus = qf_getprop_title(qfl, retdict);\n    if ((status == OK) && (flags & QF_GETLIST_NR))\n\tstatus = dict_add_number(retdict, \"nr\", qf_idx + 1);\n    if ((status == OK) && (flags & QF_GETLIST_WINID))\n\tstatus = dict_add_number(retdict, \"winid\", qf_winid(qi));\n    if ((status == OK) && (flags & QF_GETLIST_ITEMS))\n\tstatus = qf_getprop_items(qi, qf_idx, eidx, retdict);\n    if ((status == OK) && (flags & QF_GETLIST_CONTEXT))\n\tstatus = qf_getprop_ctx(qfl, retdict);\n    if ((status == OK) && (flags & QF_GETLIST_ID))\n\tstatus = dict_add_number(retdict, \"id\", qfl->qf_id);\n    if ((status == OK) && (flags & QF_GETLIST_IDX))\n\tstatus = qf_getprop_idx(qfl, eidx, retdict);\n    if ((status == OK) && (flags & QF_GETLIST_SIZE))\n\tstatus = dict_add_number(retdict, \"size\", qfl->qf_count);\n    if ((status == OK) && (flags & QF_GETLIST_TICK))\n\tstatus = dict_add_number(retdict, \"changedtick\", qfl->qf_changedtick);\n    if ((status == OK) && (wp != NULL) && (flags & QF_GETLIST_FILEWINID))\n\tstatus = qf_getprop_filewinid(wp, qi, retdict);\n    if ((status == OK) && (flags & QF_GETLIST_QFBUFNR))\n\tstatus = qf_getprop_qfbufnr(qi, retdict);\n    if ((status == OK) && (flags & QF_GETLIST_QFTF))\n\tstatus = qf_getprop_qftf(qfl, retdict);\n\n    return status;\n}\n\n/*\n * Add a new quickfix entry to list at 'qf_idx' in the stack 'qi' from the\n * items in the dict 'd'. If it is a valid error entry, then set 'valid_entry'\n * to TRUE.\n */\n    static int\nqf_add_entry_from_dict(\n\tqf_list_T\t*qfl,\n\tdict_T\t\t*d,\n\tint\t\tfirst_entry,\n\tint\t\t*valid_entry)\n{\n    static int\tdid_bufnr_emsg;\n    char_u\t*filename, *module, *pattern, *text, *type;\n    int\t\tbufnum, valid, status, col, end_col, vcol, nr;\n    long\tlnum, end_lnum;\n\n    if (first_entry)\n\tdid_bufnr_emsg = FALSE;\n\n    filename = dict_get_string(d, \"filename\", TRUE);\n    module = dict_get_string(d, \"module\", TRUE);\n    bufnum = (int)dict_get_number(d, \"bufnr\");\n    lnum = (int)dict_get_number(d, \"lnum\");\n    end_lnum = (int)dict_get_number(d, \"end_lnum\");\n    col = (int)dict_get_number(d, \"col\");\n    end_col = (int)dict_get_number(d, \"end_col\");\n    vcol = (int)dict_get_number(d, \"vcol\");\n    nr = (int)dict_get_number(d, \"nr\");\n    type = dict_get_string(d, \"type\", TRUE);\n    pattern = dict_get_string(d, \"pattern\", TRUE);\n    text = dict_get_string(d, \"text\", TRUE);\n    if (text == NULL)\n\ttext = vim_strsave((char_u *)\"\");\n\n    valid = TRUE;\n    if ((filename == NULL && bufnum == 0) || (lnum == 0 && pattern == NULL))\n\tvalid = FALSE;\n\n    // Mark entries with non-existing buffer number as not valid. Give the\n    // error message only once.\n    if (bufnum != 0 && (buflist_findnr(bufnum) == NULL))\n    {\n\tif (!did_bufnr_emsg)\n\t{\n\t    did_bufnr_emsg = TRUE;\n\t    semsg(_(e_buffer_nr_not_found), bufnum);\n\t}\n\tvalid = FALSE;\n\tbufnum = 0;\n    }\n\n    // If the 'valid' field is present it overrules the detected value.\n    if (dict_has_key(d, \"valid\"))\n\tvalid = (int)dict_get_bool(d, \"valid\", FALSE);\n\n    status =  qf_add_entry(qfl,\n\t\t\tNULL,\t\t// dir\n\t\t\tfilename,\n\t\t\tmodule,\n\t\t\tbufnum,\n\t\t\ttext,\n\t\t\tlnum,\n\t\t\tend_lnum,\n\t\t\tcol,\n\t\t\tend_col,\n\t\t\tvcol,\t\t// vis_col\n\t\t\tpattern,\t// search pattern\n\t\t\tnr,\n\t\t\ttype == NULL ? NUL : *type,\n\t\t\tvalid);\n\n    vim_free(filename);\n    vim_free(module);\n    vim_free(pattern);\n    vim_free(text);\n    vim_free(type);\n\n    if (valid)\n\t*valid_entry = TRUE;\n\n    return status;\n}\n\n/*\n * Add list of entries to quickfix/location list. Each list entry is\n * a dictionary with item information.\n */\n    static int\nqf_add_entries(\n\tqf_info_T\t*qi,\n\tint\t\tqf_idx,\n\tlist_T\t\t*list,\n\tchar_u\t\t*title,\n\tint\t\taction)\n{\n    qf_list_T\t*qfl = qf_get_list(qi, qf_idx);\n    listitem_T\t*li;\n    dict_T\t*d;\n    qfline_T\t*old_last = NULL;\n    int\t\tretval = OK;\n    int\t\tvalid_entry = FALSE;\n\n    if (action == ' ' || qf_idx == qi->qf_listcount)\n    {\n\t// make place for a new list\n\tqf_new_list(qi, title);\n\tqf_idx = qi->qf_curlist;\n\tqfl = qf_get_list(qi, qf_idx);\n    }\n    else if (action == 'a' && !qf_list_empty(qfl))\n\t// Adding to existing list, use last entry.\n\told_last = qfl->qf_last;\n    else if (action == 'r')\n    {\n\tqf_free_items(qfl);\n\tqf_store_title(qfl, title);\n    }\n\n    FOR_ALL_LIST_ITEMS(list, li)\n    {\n\tif (li->li_tv.v_type != VAR_DICT)\n\t    continue; // Skip non-dict items\n\n\td = li->li_tv.vval.v_dict;\n\tif (d == NULL)\n\t    continue;\n\n\tretval = qf_add_entry_from_dict(qfl, d, li == list->lv_first,\n\t\t\t\t\t\t\t\t&valid_entry);\n\tif (retval == QF_FAIL)\n\t    break;\n    }\n\n    // Check if any valid error entries are added to the list.\n    if (valid_entry)\n\tqfl->qf_nonevalid = FALSE;\n    else if (qfl->qf_index == 0)\n\t// no valid entry\n\tqfl->qf_nonevalid = TRUE;\n\n    // If not appending to the list, set the current error to the first entry\n    if (action != 'a')\n\tqfl->qf_ptr = qfl->qf_start;\n\n    // Update the current error index if not appending to the list or if the\n    // list was empty before and it is not empty now.\n    if ((action != 'a' || qfl->qf_index == 0) && !qf_list_empty(qfl))\n\tqfl->qf_index = 1;\n\n    // Don't update the cursor in quickfix window when appending entries\n    qf_update_buffer(qi, old_last);\n\n    return retval;\n}\n\n/*\n * Get the quickfix list index from 'nr' or 'id'\n */\n    static int\nqf_setprop_get_qfidx(\n\tqf_info_T\t*qi,\n\tdict_T\t\t*what,\n\tint\t\taction,\n\tint\t\t*newlist)\n{\n    dictitem_T\t*di;\n    int\t\tqf_idx = qi->qf_curlist;    // default is the current list\n\n    if ((di = dict_find(what, (char_u *)\"nr\", -1)) != NULL)\n    {\n\t// Use the specified quickfix/location list\n\tif (di->di_tv.v_type == VAR_NUMBER)\n\t{\n\t    // for zero use the current list\n\t    if (di->di_tv.vval.v_number != 0)\n\t\tqf_idx = di->di_tv.vval.v_number - 1;\n\n\t    if ((action == ' ' || action == 'a') && qf_idx == qi->qf_listcount)\n\t    {\n\t\t// When creating a new list, accept qf_idx pointing to the next\n\t\t// non-available list and add the new list at the end of the\n\t\t// stack.\n\t\t*newlist = TRUE;\n\t\tqf_idx = qf_stack_empty(qi) ? 0 : qi->qf_listcount - 1;\n\t    }\n\t    else if (qf_idx < 0 || qf_idx >= qi->qf_listcount)\n\t\treturn INVALID_QFIDX;\n\t    else if (action != ' ')\n\t\t*newlist = FALSE;\t// use the specified list\n\t}\n\telse if (di->di_tv.v_type == VAR_STRING\n\t\t&& di->di_tv.vval.v_string != NULL\n\t\t&& STRCMP(di->di_tv.vval.v_string, \"$\") == 0)\n\t{\n\t    if (!qf_stack_empty(qi))\n\t\tqf_idx = qi->qf_listcount - 1;\n\t    else if (*newlist)\n\t\tqf_idx = 0;\n\t    else\n\t\treturn INVALID_QFIDX;\n\t}\n\telse\n\t    return INVALID_QFIDX;\n    }\n\n    if (!*newlist && (di = dict_find(what, (char_u *)\"id\", -1)) != NULL)\n    {\n\t// Use the quickfix/location list with the specified id\n\tif (di->di_tv.v_type != VAR_NUMBER)\n\t    return INVALID_QFIDX;\n\n\treturn qf_id2nr(qi, di->di_tv.vval.v_number);\n    }\n\n    return qf_idx;\n}\n\n/*\n * Set the quickfix list title.\n */\n    static int\nqf_setprop_title(qf_info_T *qi, int qf_idx, dict_T *what, dictitem_T *di)\n{\n    qf_list_T\t*qfl = qf_get_list(qi, qf_idx);\n\n    if (di->di_tv.v_type != VAR_STRING)\n\treturn FAIL;\n\n    vim_free(qfl->qf_title);\n    qfl->qf_title = dict_get_string(what, \"title\", TRUE);\n    if (qf_idx == qi->qf_curlist)\n\tqf_update_win_titlevar(qi);\n\n    return OK;\n}\n\n/*\n * Set quickfix list items/entries.\n */\n    static int\nqf_setprop_items(qf_info_T *qi, int qf_idx, dictitem_T *di, int action)\n{\n    int\t\tretval = FAIL;\n    char_u\t*title_save;\n\n    if (di->di_tv.v_type != VAR_LIST)\n\treturn FAIL;\n\n    title_save = vim_strsave(qi->qf_lists[qf_idx].qf_title);\n    retval = qf_add_entries(qi, qf_idx, di->di_tv.vval.v_list,\n\t    title_save, action == ' ' ? 'a' : action);\n    vim_free(title_save);\n\n    return retval;\n}\n\n/*\n * Set quickfix list items/entries from a list of lines.\n */\n    static int\nqf_setprop_items_from_lines(\n\tqf_info_T\t*qi,\n\tint\t\tqf_idx,\n\tdict_T\t\t*what,\n\tdictitem_T\t*di,\n\tint\t\taction)\n{\n    char_u\t*errorformat = p_efm;\n    dictitem_T\t*efm_di;\n    int\t\tretval = FAIL;\n\n    // Use the user supplied errorformat settings (if present)\n    if ((efm_di = dict_find(what, (char_u *)\"efm\", -1)) != NULL)\n    {\n\tif (efm_di->di_tv.v_type != VAR_STRING ||\n\t\tefm_di->di_tv.vval.v_string == NULL)\n\t    return FAIL;\n\terrorformat = efm_di->di_tv.vval.v_string;\n    }\n\n    // Only a List value is supported\n    if (di->di_tv.v_type != VAR_LIST || di->di_tv.vval.v_list == NULL)\n\treturn FAIL;\n\n    if (action == 'r')\n\tqf_free_items(&qi->qf_lists[qf_idx]);\n    if (qf_init_ext(qi, qf_idx, NULL, NULL, &di->di_tv, errorformat,\n\t\tFALSE, (linenr_T)0, (linenr_T)0, NULL, NULL) >= 0)\n\tretval = OK;\n\n    return retval;\n}\n\n/*\n * Set quickfix list context.\n */\n    static int\nqf_setprop_context(qf_list_T *qfl, dictitem_T *di)\n{\n    typval_T\t*ctx;\n\n    free_tv(qfl->qf_ctx);\n    ctx =  alloc_tv();\n    if (ctx != NULL)\n\tcopy_tv(&di->di_tv, ctx);\n    qfl->qf_ctx = ctx;\n\n    return OK;\n}\n\n/*\n * Set the current index in the specified quickfix list\n */\n    static int\nqf_setprop_curidx(qf_info_T *qi, qf_list_T *qfl, dictitem_T *di)\n{\n    int\t\tdenote = FALSE;\n    int\t\tnewidx;\n    int\t\told_qfidx;\n    qfline_T\t*qf_ptr;\n\n    // If the specified index is '$', then use the last entry\n    if (di->di_tv.v_type == VAR_STRING\n\t    && di->di_tv.vval.v_string != NULL\n\t    && STRCMP(di->di_tv.vval.v_string, \"$\") == 0)\n\tnewidx = qfl->qf_count;\n    else\n    {\n\t// Otherwise use the specified index\n\tnewidx = tv_get_number_chk(&di->di_tv, &denote);\n\tif (denote)\n\t    return FAIL;\n    }\n\n    if (newidx < 1)\t\t// sanity check\n\treturn FAIL;\n    if (newidx > qfl->qf_count)\n\tnewidx = qfl->qf_count;\n\n    old_qfidx = qfl->qf_index;\n    qf_ptr = get_nth_entry(qfl, newidx, &newidx);\n    if (qf_ptr == NULL)\n\treturn FAIL;\n    qfl->qf_ptr = qf_ptr;\n    qfl->qf_index = newidx;\n\n    // If the current list is modified and it is displayed in the quickfix\n    // window, then Update it.\n    if (qf_get_curlist(qi)->qf_id == qfl->qf_id)\n\tqf_win_pos_update(qi, old_qfidx);\n\n    return OK;\n}\n\n/*\n * Set the current index in the specified quickfix list\n */\n    static int\nqf_setprop_qftf(qf_info_T *qi UNUSED, qf_list_T *qfl, dictitem_T *di)\n{\n    callback_T\tcb;\n\n    free_callback(&qfl->qf_qftf_cb);\n    cb = get_callback(&di->di_tv);\n    if (cb.cb_name == NULL || *cb.cb_name == NUL)\n\treturn OK;\n\n    set_callback(&qfl->qf_qftf_cb, &cb);\n    if (cb.cb_free_name)\n\tvim_free(cb.cb_name);\n\n    return OK;\n}\n\n/*\n * Set quickfix/location list properties (title, items, context).\n * Also used to add items from parsing a list of lines.\n * Used by the setqflist() and setloclist() Vim script functions.\n */\n    static int\nqf_set_properties(qf_info_T *qi, dict_T *what, int action, char_u *title)\n{\n    dictitem_T\t*di;\n    int\t\tretval = FAIL;\n    int\t\tqf_idx;\n    int\t\tnewlist = FALSE;\n    qf_list_T\t*qfl;\n\n    if (action == ' ' || qf_stack_empty(qi))\n\tnewlist = TRUE;\n\n    qf_idx = qf_setprop_get_qfidx(qi, what, action, &newlist);\n    if (qf_idx == INVALID_QFIDX)\t// List not found\n\treturn FAIL;\n\n    if (newlist)\n    {\n\tqi->qf_curlist = qf_idx;\n\tqf_new_list(qi, title);\n\tqf_idx = qi->qf_curlist;\n    }\n\n    qfl = qf_get_list(qi, qf_idx);\n    if ((di = dict_find(what, (char_u *)\"title\", -1)) != NULL)\n\tretval = qf_setprop_title(qi, qf_idx, what, di);\n    if ((di = dict_find(what, (char_u *)\"items\", -1)) != NULL)\n\tretval = qf_setprop_items(qi, qf_idx, di, action);\n    if ((di = dict_find(what, (char_u *)\"lines\", -1)) != NULL)\n\tretval = qf_setprop_items_from_lines(qi, qf_idx, what, di, action);\n    if ((di = dict_find(what, (char_u *)\"context\", -1)) != NULL)\n\tretval = qf_setprop_context(qfl, di);\n    if ((di = dict_find(what, (char_u *)\"idx\", -1)) != NULL)\n\tretval = qf_setprop_curidx(qi, qfl, di);\n    if ((di = dict_find(what, (char_u *)\"quickfixtextfunc\", -1)) != NULL)\n\tretval = qf_setprop_qftf(qi, qfl, di);\n\n    if (newlist || retval == OK)\n\tqf_list_changed(qfl);\n    if (newlist)\n\tqf_update_buffer(qi, NULL);\n\n    return retval;\n}\n\n/*\n * Free the entire quickfix/location list stack.\n * If the quickfix/location list window is open, then clear it.\n */\n    static void\nqf_free_stack(win_T *wp, qf_info_T *qi)\n{\n    win_T\t*qfwin = qf_find_win(qi);\n    win_T\t*llwin = NULL;\n\n    if (qfwin != NULL)\n    {\n\t// If the quickfix/location list window is open, then clear it\n\tif (qi->qf_curlist < qi->qf_listcount)\n\t    qf_free(qf_get_curlist(qi));\n\tqf_update_buffer(qi, NULL);\n    }\n\n    if (wp != NULL && IS_LL_WINDOW(wp))\n    {\n\t// If in the location list window, then use the non-location list\n\t// window with this location list (if present)\n\tllwin = qf_find_win_with_loclist(qi);\n\tif (llwin != NULL)\n\t    wp = llwin;\n    }\n\n    qf_free_all(wp);\n    if (wp == NULL)\n    {\n\t// quickfix list\n\tqi->qf_curlist = 0;\n\tqi->qf_listcount = 0;\n    }\n    else if (qfwin != NULL)\n    {\n\t// If the location list window is open, then create a new empty\n\t// location list\n\tqf_info_T *new_ll = qf_alloc_stack(QFLT_LOCATION);\n\n\tif (new_ll != NULL)\n\t{\n\t    new_ll->qf_bufnr = qfwin->w_buffer->b_fnum;\n\n\t    // first free the list reference in the location list window\n\t    ll_free_all(&qfwin->w_llist_ref);\n\n\t    qfwin->w_llist_ref = new_ll;\n\t    if (wp != qfwin)\n\t\twin_set_loclist(wp, new_ll);\n\t}\n    }\n}\n\n/*\n * Populate the quickfix list with the items supplied in the list\n * of dictionaries. \"title\" will be copied to w:quickfix_title.\n * \"action\" is 'a' for add, 'r' for replace.  Otherwise create a new list.\n * When \"what\" is not NULL then only set some properties.\n */\n    int\nset_errorlist(\n\twin_T\t*wp,\n\tlist_T\t*list,\n\tint\taction,\n\tchar_u\t*title,\n\tdict_T\t*what)\n{\n    qf_info_T\t*qi = &ql_info;\n    int\t\tretval = OK;\n\n    if (wp != NULL)\n    {\n\tqi = ll_get_or_alloc_list(wp);\n\tif (qi == NULL)\n\t    return FAIL;\n    }\n\n    if (action == 'f')\n    {\n\t// Free the entire quickfix or location list stack\n\tqf_free_stack(wp, qi);\n\treturn OK;\n    }\n\n    // A dict argument cannot be specified with a non-empty list argument\n    if (list->lv_len != 0 && what != NULL)\n    {\n\tsemsg(_(e_invalid_argument_str),\n\t\t\t _(\"cannot have both a list and a \\\"what\\\" argument\"));\n\treturn FAIL;\n    }\n\n    incr_quickfix_busy();\n\n    if (what != NULL)\n\tretval = qf_set_properties(qi, what, action, title);\n    else\n    {\n\tretval = qf_add_entries(qi, qi->qf_curlist, list, title, action);\n\tif (retval == OK)\n\t    qf_list_changed(qf_get_curlist(qi));\n    }\n\n    decr_quickfix_busy();\n\n    return retval;\n}\n\n/*\n * Mark the quickfix context and callback function as in use for all the lists\n * in a quickfix stack.\n */\n    static int\nmark_quickfix_ctx(qf_info_T *qi, int copyID)\n{\n    int\t\ti;\n    int\t\tabort = FALSE;\n    typval_T\t*ctx;\n    callback_T\t*cb;\n\n    for (i = 0; i < LISTCOUNT && !abort; ++i)\n    {\n\tctx = qi->qf_lists[i].qf_ctx;\n\tif (ctx != NULL && ctx->v_type != VAR_NUMBER\n\t\t&& ctx->v_type != VAR_STRING && ctx->v_type != VAR_FLOAT)\n\t    abort = abort || set_ref_in_item(ctx, copyID, NULL, NULL);\n\n\tcb = &qi->qf_lists[i].qf_qftf_cb;\n\tabort = abort || set_ref_in_callback(cb, copyID);\n    }\n\n    return abort;\n}\n\n/*\n * Mark the context of the quickfix list and the location lists (if present) as\n * \"in use\". So that garbage collection doesn't free the context.\n */\n    int\nset_ref_in_quickfix(int copyID)\n{\n    int\t\tabort = FALSE;\n    tabpage_T\t*tp;\n    win_T\t*win;\n\n    abort = mark_quickfix_ctx(&ql_info, copyID);\n    if (abort)\n\treturn abort;\n\n    abort = set_ref_in_callback(&qftf_cb, copyID);\n    if (abort)\n\treturn abort;\n\n    FOR_ALL_TAB_WINDOWS(tp, win)\n    {\n\tif (win->w_llist != NULL)\n\t{\n\t    abort = mark_quickfix_ctx(win->w_llist, copyID);\n\t    if (abort)\n\t\treturn abort;\n\t}\n\tif (IS_LL_WINDOW(win) && (win->w_llist_ref->qf_refcount == 1))\n\t{\n\t    // In a location list window and none of the other windows is\n\t    // referring to this location list. Mark the location list\n\t    // context as still in use.\n\t    abort = mark_quickfix_ctx(win->w_llist_ref, copyID);\n\t    if (abort)\n\t\treturn abort;\n\t}\n    }\n\n    return abort;\n}\n#endif\n\n/*\n * Return the autocmd name for the :cbuffer Ex commands\n */\n    static char_u *\ncbuffer_get_auname(cmdidx_T cmdidx)\n{\n    switch (cmdidx)\n    {\n\tcase CMD_cbuffer:\treturn (char_u *)\"cbuffer\";\n\tcase CMD_cgetbuffer:\treturn (char_u *)\"cgetbuffer\";\n\tcase CMD_caddbuffer:\treturn (char_u *)\"caddbuffer\";\n\tcase CMD_lbuffer:\treturn (char_u *)\"lbuffer\";\n\tcase CMD_lgetbuffer:\treturn (char_u *)\"lgetbuffer\";\n\tcase CMD_laddbuffer:\treturn (char_u *)\"laddbuffer\";\n\tdefault:\t\treturn NULL;\n    }\n}\n\n/*\n * Process and validate the arguments passed to the :cbuffer, :caddbuffer,\n * :cgetbuffer, :lbuffer, :laddbuffer, :lgetbuffer Ex commands.\n */\n    static int\ncbuffer_process_args(\n\texarg_T\t\t*eap,\n\tbuf_T\t\t**bufp,\n\tlinenr_T\t*line1,\n\tlinenr_T\t*line2)\n{\n    buf_T\t*buf = NULL;\n\n    if (*eap->arg == NUL)\n\tbuf = curbuf;\n    else if (*skipwhite(skipdigits(eap->arg)) == NUL)\n\tbuf = buflist_findnr(atoi((char *)eap->arg));\n\n    if (buf == NULL)\n    {\n\temsg(_(e_invalid_argument));\n\treturn FAIL;\n    }\n\n    if (buf->b_ml.ml_mfp == NULL)\n    {\n\temsg(_(e_buffer_is_not_loaded));\n\treturn FAIL;\n    }\n\n    if (eap->addr_count == 0)\n    {\n\teap->line1 = 1;\n\teap->line2 = buf->b_ml.ml_line_count;\n    }\n\n    if (eap->line1 < 1 || eap->line1 > buf->b_ml.ml_line_count\n\t    || eap->line2 < 1 || eap->line2 > buf->b_ml.ml_line_count)\n    {\n\temsg(_(e_invalid_range));\n\treturn FAIL;\n    }\n\n    *line1 = eap->line1;\n    *line2 = eap->line2;\n    *bufp = buf;\n\n    return OK;\n}\n\n/*\n * \":[range]cbuffer [bufnr]\" command.\n * \":[range]caddbuffer [bufnr]\" command.\n * \":[range]cgetbuffer [bufnr]\" command.\n * \":[range]lbuffer [bufnr]\" command.\n * \":[range]laddbuffer [bufnr]\" command.\n * \":[range]lgetbuffer [bufnr]\" command.\n */\n    void\nex_cbuffer(exarg_T *eap)\n{\n    buf_T\t*buf = NULL;\n    qf_info_T\t*qi;\n    char_u\t*au_name = NULL;\n    int\t\tres;\n    int_u\tsave_qfid;\n    win_T\t*wp = NULL;\n    char_u\t*qf_title;\n    linenr_T\tline1;\n    linenr_T\tline2;\n\n    au_name = cbuffer_get_auname(eap->cmdidx);\n    if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,\n\t\t\t\t\tcurbuf->b_fname, TRUE, curbuf))\n    {\n#ifdef FEAT_EVAL\n\tif (aborting())\n\t    return;\n#endif\n    }\n\n    // Must come after autocommands.\n    qi = qf_cmd_get_or_alloc_stack(eap, &wp);\n    if (qi == NULL)\n\treturn;\n\n    if (cbuffer_process_args(eap, &buf, &line1, &line2) == FAIL)\n\treturn;\n\n    qf_title = qf_cmdtitle(*eap->cmdlinep);\n\n    if (buf->b_sfname)\n    {\n\tvim_snprintf((char *)IObuff, IOSIZE, \"%s (%s)\",\n\t\t(char *)qf_title, (char *)buf->b_sfname);\n\tqf_title = IObuff;\n    }\n\n    incr_quickfix_busy();\n\n    res = qf_init_ext(qi, qi->qf_curlist, NULL, buf, NULL, p_efm,\n\t    (eap->cmdidx != CMD_caddbuffer\n\t     && eap->cmdidx != CMD_laddbuffer),\n\t    line1, line2,\n\t    qf_title, NULL);\n    if (qf_stack_empty(qi))\n    {\n\tdecr_quickfix_busy();\n\treturn;\n    }\n    if (res >= 0)\n\tqf_list_changed(qf_get_curlist(qi));\n\n    // Remember the current quickfix list identifier, so that we can\n    // check for autocommands changing the current quickfix list.\n    save_qfid = qf_get_curlist(qi)->qf_id;\n    if (au_name != NULL)\n    {\n\tbuf_T *curbuf_old = curbuf;\n\n\tapply_autocmds(EVENT_QUICKFIXCMDPOST, au_name, curbuf->b_fname,\n\t\t\t\t\t\t\t\tTRUE, curbuf);\n\tif (curbuf != curbuf_old)\n\t    // Autocommands changed buffer, don't jump now, \"qi\" may\n\t    // be invalid.\n\t    res = 0;\n    }\n    // Jump to the first error for a new list and if autocmds didn't\n    // free the list.\n    if (res > 0 && (eap->cmdidx == CMD_cbuffer ||\n\t\teap->cmdidx == CMD_lbuffer)\n\t    && qflist_valid(wp, save_qfid))\n\t// display the first error\n\tqf_jump_first(qi, save_qfid, eap->forceit);\n\n    decr_quickfix_busy();\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return the autocmd name for the :cexpr Ex commands.\n */\n    char_u *\ncexpr_get_auname(cmdidx_T cmdidx)\n{\n    switch (cmdidx)\n    {\n\tcase CMD_cexpr:\t    return (char_u *)\"cexpr\";\n\tcase CMD_cgetexpr:  return (char_u *)\"cgetexpr\";\n\tcase CMD_caddexpr:  return (char_u *)\"caddexpr\";\n\tcase CMD_lexpr:\t    return (char_u *)\"lexpr\";\n\tcase CMD_lgetexpr:  return (char_u *)\"lgetexpr\";\n\tcase CMD_laddexpr:  return (char_u *)\"laddexpr\";\n\tdefault:\t    return NULL;\n    }\n}\n\n    int\ntrigger_cexpr_autocmd(int cmdidx)\n{\n    char_u\t*au_name = cexpr_get_auname(cmdidx);\n\n    if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,\n\t\t\t\t\t       curbuf->b_fname, TRUE, curbuf))\n    {\n\tif (aborting())\n\t    return FAIL;\n    }\n    return OK;\n}\n\n    int\ncexpr_core(exarg_T *eap, typval_T *tv)\n{\n    qf_info_T\t*qi;\n    win_T\t*wp = NULL;\n\n    qi = qf_cmd_get_or_alloc_stack(eap, &wp);\n    if (qi == NULL)\n\treturn FAIL;\n\n    if ((tv->v_type == VAR_STRING && tv->vval.v_string != NULL)\n\t    || (tv->v_type == VAR_LIST && tv->vval.v_list != NULL))\n    {\n\tint\tres;\n\tint_u\tsave_qfid;\n\tchar_u\t*au_name = cexpr_get_auname(eap->cmdidx);\n\n\tincr_quickfix_busy();\n\tres = qf_init_ext(qi, qi->qf_curlist, NULL, NULL, tv, p_efm,\n\t\t\t(eap->cmdidx != CMD_caddexpr\n\t\t\t && eap->cmdidx != CMD_laddexpr),\n\t\t\t     (linenr_T)0, (linenr_T)0,\n\t\t\t     qf_cmdtitle(*eap->cmdlinep), NULL);\n\tif (qf_stack_empty(qi))\n\t{\n\t    decr_quickfix_busy();\n\t    return FAIL;\n\t}\n\tif (res >= 0)\n\t    qf_list_changed(qf_get_curlist(qi));\n\n\t// Remember the current quickfix list identifier, so that we can\n\t// check for autocommands changing the current quickfix list.\n\tsave_qfid = qf_get_curlist(qi)->qf_id;\n\tif (au_name != NULL)\n\t    apply_autocmds(EVENT_QUICKFIXCMDPOST, au_name,\n\t\t\t\t\t    curbuf->b_fname, TRUE, curbuf);\n\n\t// Jump to the first error for a new list and if autocmds didn't\n\t// free the list.\n\tif (res > 0 && (eap->cmdidx == CMD_cexpr || eap->cmdidx == CMD_lexpr)\n\t\t&& qflist_valid(wp, save_qfid))\n\t    // display the first error\n\t    qf_jump_first(qi, save_qfid, eap->forceit);\n\tdecr_quickfix_busy();\n\treturn OK;\n    }\n\n    emsg(_(e_string_or_list_expected));\n    return FAIL;\n}\n\n/*\n * \":cexpr {expr}\", \":cgetexpr {expr}\", \":caddexpr {expr}\" command.\n * \":lexpr {expr}\", \":lgetexpr {expr}\", \":laddexpr {expr}\" command.\n * Also: \":caddexpr\", \":cgetexpr\", \"laddexpr\" and \"laddexpr\".\n */\n    void\nex_cexpr(exarg_T *eap)\n{\n    typval_T\t*tv;\n\n    if (trigger_cexpr_autocmd(eap->cmdidx) == FAIL)\n\treturn;\n\n    // Evaluate the expression.  When the result is a string or a list we can\n    // use it to fill the errorlist.\n    tv = eval_expr(eap->arg, eap);\n    if (tv == NULL)\n\treturn;\n\n    (void)cexpr_core(eap, tv);\n    free_tv(tv);\n}\n#endif\n\n/*\n * Get the location list for \":lhelpgrep\"\n */\n    static qf_info_T *\nhgr_get_ll(int *new_ll)\n{\n    win_T\t*wp;\n    qf_info_T\t*qi;\n\n    // If the current window is a help window, then use it\n    if (bt_help(curwin->w_buffer))\n\twp = curwin;\n    else\n\t// Find an existing help window\n\twp = qf_find_help_win();\n\n    if (wp == NULL)\t    // Help window not found\n\tqi = NULL;\n    else\n\tqi = wp->w_llist;\n\n    if (qi == NULL)\n    {\n\t// Allocate a new location list for help text matches\n\tif ((qi = qf_alloc_stack(QFLT_LOCATION)) == NULL)\n\t    return NULL;\n\t*new_ll = TRUE;\n    }\n\n    return qi;\n}\n\n/*\n * Search for a pattern in a help file.\n */\n    static void\nhgr_search_file(\n\tqf_list_T *qfl,\n\tchar_u *fname,\n\tvimconv_T *p_vc,\n\tregmatch_T *p_regmatch)\n{\n    FILE\t*fd;\n    long\tlnum;\n\n    fd = mch_fopen((char *)fname, \"r\");\n    if (fd == NULL)\n\treturn;\n\n    lnum = 1;\n    while (!vim_fgets(IObuff, IOSIZE, fd) && !got_int)\n    {\n\tchar_u    *line = IObuff;\n\n\t// Convert a line if 'encoding' is not utf-8 and\n\t// the line contains a non-ASCII character.\n\tif (p_vc->vc_type != CONV_NONE && has_non_ascii(IObuff))\n\t{\n\t    line = string_convert(p_vc, IObuff, NULL);\n\t    if (line == NULL)\n\t\tline = IObuff;\n\t}\n\n\tif (vim_regexec(p_regmatch, line, (colnr_T)0))\n\t{\n\t    int\tl = (int)STRLEN(line);\n\n\t    // remove trailing CR, LF, spaces, etc.\n\t    while (l > 0 && line[l - 1] <= ' ')\n\t\tline[--l] = NUL;\n\n\t    if (qf_add_entry(qfl,\n\t\t\tNULL,\t// dir\n\t\t\tfname,\n\t\t\tNULL,\n\t\t\t0,\n\t\t\tline,\n\t\t\tlnum,\n\t\t\t0,\n\t\t\t(int)(p_regmatch->startp[0] - line)\n\t\t\t+ 1,\t// col\n\t\t\t(int)(p_regmatch->endp[0] - line)\n\t\t\t+ 1,\t// end_col\n\t\t\tFALSE,\t// vis_col\n\t\t\tNULL,\t// search pattern\n\t\t\t0,\t// nr\n\t\t\t1,\t// type\n\t\t\tTRUE\t// valid\n\t\t\t) == QF_FAIL)\n\t    {\n\t\tgot_int = TRUE;\n\t\tif (line != IObuff)\n\t\t    vim_free(line);\n\t\tbreak;\n\t    }\n\t}\n\tif (line != IObuff)\n\t    vim_free(line);\n\t++lnum;\n\tline_breakcheck();\n    }\n    fclose(fd);\n}\n\n/*\n * Search for a pattern in all the help files in the doc directory under\n * the given directory.\n */\n    static void\nhgr_search_files_in_dir(\n\tqf_list_T *qfl,\n\tchar_u *dirname,\n\tregmatch_T *p_regmatch,\n\tvimconv_T *p_vc\n#ifdef FEAT_MULTI_LANG\n\t, char_u *lang\n#endif\n\t)\n{\n    int\t\tfcount;\n    char_u\t**fnames;\n    int\t\tfi;\n\n    // Find all \"*.txt\" and \"*.??x\" files in the \"doc\" directory.\n    add_pathsep(dirname);\n    STRCAT(dirname, \"doc/*.\\\\(txt\\\\|??x\\\\)\");\n    if (gen_expand_wildcards(1, &dirname, &fcount,\n\t\t&fnames, EW_FILE|EW_SILENT) == OK\n\t    && fcount > 0)\n    {\n\tfor (fi = 0; fi < fcount && !got_int; ++fi)\n\t{\n#ifdef FEAT_MULTI_LANG\n\t    // Skip files for a different language.\n\t    if (lang != NULL\n\t\t    && STRNICMP(lang, fnames[fi]\n\t\t\t\t    + STRLEN(fnames[fi]) - 3, 2) != 0\n\t\t    && !(STRNICMP(lang, \"en\", 2) == 0\n\t\t\t&& STRNICMP(\"txt\", fnames[fi]\n\t\t\t    + STRLEN(fnames[fi]) - 3, 3) == 0))\n\t\tcontinue;\n#endif\n\n\t    hgr_search_file(qfl, fnames[fi], p_vc, p_regmatch);\n\t}\n\tFreeWild(fcount, fnames);\n    }\n}\n\n/*\n * Search for a pattern in all the help files in the 'runtimepath'\n * and add the matches to a quickfix list.\n * 'lang' is the language specifier.  If supplied, then only matches in the\n * specified language are found.\n */\n    static void\nhgr_search_in_rtp(qf_list_T *qfl, regmatch_T *p_regmatch, char_u *lang)\n{\n    char_u\t*p;\n\n    vimconv_T\tvc;\n\n    // Help files are in utf-8 or latin1, convert lines when 'encoding'\n    // differs.\n    vc.vc_type = CONV_NONE;\n    if (!enc_utf8)\n\tconvert_setup(&vc, (char_u *)\"utf-8\", p_enc);\n\n    // Go through all the directories in 'runtimepath'\n    p = p_rtp;\n    while (*p != NUL && !got_int)\n    {\n\tcopy_option_part(&p, NameBuff, MAXPATHL, \",\");\n\n\thgr_search_files_in_dir(qfl, NameBuff, p_regmatch, &vc\n#ifdef FEAT_MULTI_LANG\n\t\t, lang\n#endif\n\t\t);\n    }\n\n    if (vc.vc_type != CONV_NONE)\n\tconvert_setup(&vc, NULL, NULL);\n}\n\n/*\n * \":helpgrep {pattern}\"\n */\n    void\nex_helpgrep(exarg_T *eap)\n{\n    regmatch_T\tregmatch;\n    char_u\t*save_cpo;\n    int\t\tsave_cpo_allocated;\n    qf_info_T\t*qi = &ql_info;\n    int\t\tnew_qi = FALSE;\n    char_u\t*au_name =  NULL;\n    char_u\t*lang = NULL;\n    int\t\tupdated = FALSE;\n\n    switch (eap->cmdidx)\n    {\n\tcase CMD_helpgrep:  au_name = (char_u *)\"helpgrep\"; break;\n\tcase CMD_lhelpgrep: au_name = (char_u *)\"lhelpgrep\"; break;\n\tdefault: break;\n    }\n    if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,\n\t\t\t\t\t       curbuf->b_fname, TRUE, curbuf))\n    {\n#ifdef FEAT_EVAL\n\tif (aborting())\n\t    return;\n#endif\n    }\n\n    if (is_loclist_cmd(eap->cmdidx))\n    {\n\tqi = hgr_get_ll(&new_qi);\n\tif (qi == NULL)\n\t    return;\n    }\n\n    // Make 'cpoptions' empty, the 'l' flag should not be used here.\n    save_cpo = p_cpo;\n    save_cpo_allocated = is_option_allocated(\"cpo\");\n    p_cpo = empty_option;\n\n    incr_quickfix_busy();\n\n#ifdef FEAT_MULTI_LANG\n    // Check for a specified language\n    lang = check_help_lang(eap->arg);\n#endif\n    regmatch.regprog = vim_regcomp(eap->arg, RE_MAGIC + RE_STRING);\n    regmatch.rm_ic = FALSE;\n    if (regmatch.regprog != NULL)\n    {\n\tqf_list_T\t*qfl;\n\n\t// create a new quickfix list\n\tqf_new_list(qi, qf_cmdtitle(*eap->cmdlinep));\n\tqfl = qf_get_curlist(qi);\n\n\thgr_search_in_rtp(qfl, &regmatch, lang);\n\n\tvim_regfree(regmatch.regprog);\n\n\tqfl->qf_nonevalid = FALSE;\n\tqfl->qf_ptr = qfl->qf_start;\n\tqfl->qf_index = 1;\n\tqf_list_changed(qfl);\n\tupdated = TRUE;\n    }\n\n    if (p_cpo == empty_option)\n\tp_cpo = save_cpo;\n    else\n    {\n\t// Darn, some plugin changed the value.  If it's still empty it was\n\t// changed and restored, need to restore in the complicated way.\n\tif (*p_cpo == NUL)\n\t    set_option_value_give_err((char_u *)\"cpo\", 0L, save_cpo, 0);\n\tif (save_cpo_allocated)\n\t    free_string_option(save_cpo);\n    }\n\n    if (updated)\n\t// This may open a window and source scripts, do this after 'cpo' was\n\t// restored.\n\tqf_update_buffer(qi, NULL);\n\n    if (au_name != NULL)\n    {\n\tapply_autocmds(EVENT_QUICKFIXCMDPOST, au_name,\n\t\t\t\t\t       curbuf->b_fname, TRUE, curbuf);\n\t// When adding a location list to an existing location list stack,\n\t// if the autocmd made the stack invalid, then just return.\n\tif (!new_qi && IS_LL_STACK(qi) && qf_find_win_with_loclist(qi) == NULL)\n\t{\n\t    decr_quickfix_busy();\n\t    return;\n\t}\n    }\n\n    // Jump to first match.\n    if (!qf_list_empty(qf_get_curlist(qi)))\n\tqf_jump(qi, 0, 0, FALSE);\n    else\n\tsemsg(_(e_no_match_str_2), eap->arg);\n\n    decr_quickfix_busy();\n\n    if (eap->cmdidx == CMD_lhelpgrep)\n    {\n\t// If the help window is not opened or if it already points to the\n\t// correct location list, then free the new location list.\n\tif (!bt_help(curwin->w_buffer) || curwin->w_llist == qi)\n\t{\n\t    if (new_qi)\n\t\tll_free_all(&qi);\n\t}\n\telse if (curwin->w_llist == NULL && new_qi)\n\t    // current window didn't have a location list associated with it\n\t    // before. Associate the new location list now.\n\t    curwin->w_llist = qi;\n    }\n}\n\n# if defined(EXITFREE) || defined(PROTO)\n    void\nfree_quickfix(void)\n{\n    win_T\t*win;\n    tabpage_T\t*tab;\n\n    qf_free_all(NULL);\n    // Free all location lists\n    FOR_ALL_TAB_WINDOWS(tab, win)\n\tqf_free_all(win);\n\n    ga_clear(&qfga);\n}\n# endif\n\n#endif // FEAT_QUICKFIX\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n# ifdef FEAT_QUICKFIX\n    static void\nget_qf_loc_list(int is_qf, win_T *wp, typval_T *what_arg, typval_T *rettv)\n{\n    if (what_arg->v_type == VAR_UNKNOWN)\n    {\n\tif (rettv_list_alloc(rettv) == OK)\n\t    if (is_qf || wp != NULL)\n\t\t(void)get_errorlist(NULL, wp, -1, 0, rettv->vval.v_list);\n    }\n    else\n    {\n\tif (rettv_dict_alloc(rettv) == OK)\n\t    if (is_qf || (wp != NULL))\n\t    {\n\t\tif (what_arg->v_type == VAR_DICT)\n\t\t{\n\t\t    dict_T\t*d = what_arg->vval.v_dict;\n\n\t\t    if (d != NULL)\n\t\t\tqf_get_properties(wp, d, rettv->vval.v_dict);\n\t\t}\n\t\telse\n\t\t    emsg(_(e_dictionary_required));\n\t    }\n    }\n}\n# endif\n\n/*\n * \"getloclist()\" function\n */\n    void\nf_getloclist(typval_T *argvars UNUSED, typval_T *rettv UNUSED)\n{\n# ifdef FEAT_QUICKFIX\n    win_T\t*wp;\n\n    if (in_vim9script()\n\t    && (check_for_number_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_dict_arg(argvars, 1) == FAIL))\n\treturn;\n\n    wp = find_win_by_nr_or_id(&argvars[0]);\n    get_qf_loc_list(FALSE, wp, &argvars[1], rettv);\n# endif\n}\n\n/*\n * \"getqflist()\" function\n */\n    void\nf_getqflist(typval_T *argvars UNUSED, typval_T *rettv UNUSED)\n{\n# ifdef FEAT_QUICKFIX\n    if (in_vim9script() && check_for_opt_dict_arg(argvars, 0) == FAIL)\n\treturn;\n\n    get_qf_loc_list(TRUE, NULL, &argvars[0], rettv);\n# endif\n}\n\n/*\n * Used by \"setqflist()\" and \"setloclist()\" functions\n */\n    static void\nset_qf_ll_list(\n    win_T\t*wp UNUSED,\n    typval_T\t*list_arg UNUSED,\n    typval_T\t*action_arg UNUSED,\n    typval_T\t*what_arg UNUSED,\n    typval_T\t*rettv)\n{\n# ifdef FEAT_QUICKFIX\n    char_u\t*act;\n    int\t\taction = 0;\n    static int\trecursive = 0;\n# endif\n\n    rettv->vval.v_number = -1;\n\n# ifdef FEAT_QUICKFIX\n    if (list_arg->v_type != VAR_LIST)\n\temsg(_(e_list_required));\n    else if (recursive != 0)\n\temsg(_(e_autocommand_caused_recursive_behavior));\n    else\n    {\n\tlist_T  *l = list_arg->vval.v_list;\n\tdict_T\t*what = NULL;\n\tint\tvalid_dict = TRUE;\n\n\tif (action_arg->v_type == VAR_STRING)\n\t{\n\t    act = tv_get_string_chk(action_arg);\n\t    if (act == NULL)\n\t\treturn;\t\t// type error; errmsg already given\n\t    if ((*act == 'a' || *act == 'r' || *act == ' ' || *act == 'f') &&\n\t\t    act[1] == NUL)\n\t\taction = *act;\n\t    else\n\t\tsemsg(_(e_invalid_action_str_1), act);\n\t}\n\telse if (action_arg->v_type == VAR_UNKNOWN)\n\t    action = ' ';\n\telse\n\t    emsg(_(e_string_required));\n\n\tif (action_arg->v_type != VAR_UNKNOWN\n\t\t&& what_arg->v_type != VAR_UNKNOWN)\n\t{\n\t    if (what_arg->v_type == VAR_DICT && what_arg->vval.v_dict != NULL)\n\t\twhat = what_arg->vval.v_dict;\n\t    else\n\t    {\n\t\temsg(_(e_dictionary_required));\n\t\tvalid_dict = FALSE;\n\t    }\n\t}\n\n\t++recursive;\n\tif (l != NULL && action && valid_dict\n\t\t    && set_errorlist(wp, l, action,\n\t\t     (char_u *)(wp == NULL ? \":setqflist()\" : \":setloclist()\"),\n\t\t     what) == OK)\n\t    rettv->vval.v_number = 0;\n\t--recursive;\n    }\n# endif\n}\n\n/*\n * \"setloclist()\" function\n */\n    void\nf_setloclist(typval_T *argvars, typval_T *rettv)\n{\n    win_T\t*win;\n\n    rettv->vval.v_number = -1;\n\n    if (in_vim9script()\n\t    && (check_for_number_arg(argvars, 0) == FAIL\n\t\t|| check_for_list_arg(argvars, 1) == FAIL\n\t\t|| check_for_opt_string_arg(argvars, 2) == FAIL\n\t\t|| (argvars[2].v_type != VAR_UNKNOWN\n\t\t    && check_for_opt_dict_arg(argvars, 3) == FAIL)))\n\treturn;\n\n    win = find_win_by_nr_or_id(&argvars[0]);\n    if (win != NULL)\n\tset_qf_ll_list(win, &argvars[1], &argvars[2], &argvars[3], rettv);\n}\n\n/*\n * \"setqflist()\" function\n */\n    void\nf_setqflist(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script()\n\t    && (check_for_list_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_string_arg(argvars, 1) == FAIL\n\t\t|| (argvars[1].v_type != VAR_UNKNOWN\n\t\t    && check_for_opt_dict_arg(argvars, 2) == FAIL)))\n\treturn;\n\n    set_qf_ll_list(NULL, &argvars[0], &argvars[1], &argvars[2], rettv);\n}\n#endif\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n/*\n * search.c: code for normal mode searching commands\n */\n\n#include \"vim.h\"\n\n#ifdef FEAT_EVAL\nstatic void set_vv_searchforward(void);\nstatic int first_submatch(regmmatch_T *rp);\n#endif\n#ifdef FEAT_FIND_ID\nstatic void show_pat_in_path(char_u *, int,\n\t\t\t\t\t int, int, FILE *, linenr_T *, long);\n#endif\n\ntypedef struct searchstat\n{\n    int\t    cur;\t    // current position of found words\n    int\t    cnt;\t    // total count of found words\n    int\t    exact_match;    // TRUE if matched exactly on specified position\n    int\t    incomplete;\t    // 0: search was fully completed\n\t\t\t    // 1: recomputing was timed out\n\t\t\t    // 2: max count exceeded\n    int\t    last_maxcount;  // the max count of the last search\n} searchstat_T;\n\nstatic void cmdline_search_stat(int dirc, pos_T *pos, pos_T *cursor_pos, int show_top_bot_msg, char_u *msgbuf, int recompute, int maxcount, long timeout);\nstatic void update_search_stat(int dirc, pos_T *pos, pos_T *cursor_pos, searchstat_T *stat, int recompute, int maxcount, long timeout);\n\n#define SEARCH_STAT_DEF_TIMEOUT 40L\n#define SEARCH_STAT_DEF_MAX_COUNT 99\n#define SEARCH_STAT_BUF_LEN 12\n\n/*\n * This file contains various searching-related routines. These fall into\n * three groups:\n * 1. string searches (for /, ?, n, and N)\n * 2. character searches within a single line (for f, F, t, T, etc)\n * 3. \"other\" kinds of searches like the '%' command, and 'word' searches.\n */\n\n/*\n * String searches\n *\n * The string search functions are divided into two levels:\n * lowest:  searchit(); uses an pos_T for starting position and found match.\n * Highest: do_search(); uses curwin->w_cursor; calls searchit().\n *\n * The last search pattern is remembered for repeating the same search.\n * This pattern is shared between the :g, :s, ? and / commands.\n * This is in search_regcomp().\n *\n * The actual string matching is done using a heavily modified version of\n * Henry Spencer's regular expression library.  See regexp.c.\n */\n\n/*\n * Two search patterns are remembered: One for the :substitute command and\n * one for other searches.  last_idx points to the one that was used the last\n * time.\n */\nstatic spat_T spats[2] =\n{\n    {NULL, TRUE, FALSE, {'/', 0, 0, 0L}},\t// last used search pat\n    {NULL, TRUE, FALSE, {'/', 0, 0, 0L}}\t// last used substitute pat\n};\n\nstatic int last_idx = 0;\t// index in spats[] for RE_LAST\n\nstatic char_u lastc[2] = {NUL, NUL};\t// last character searched for\nstatic int lastcdir = FORWARD;\t\t// last direction of character search\nstatic int last_t_cmd = TRUE;\t\t// last search t_cmd\nstatic char_u\tlastc_bytes[MB_MAXBYTES + 1];\nstatic int\tlastc_bytelen = 1;\t// >1 for multi-byte char\n\n// copy of spats[], for keeping the search patterns while executing autocmds\nstatic spat_T\t    saved_spats[2];\nstatic char_u\t    *saved_mr_pattern = NULL;\n# ifdef FEAT_SEARCH_EXTRA\nstatic int\t    saved_spats_last_idx = 0;\nstatic int\t    saved_spats_no_hlsearch = 0;\n# endif\n\n// allocated copy of pattern used by search_regcomp()\nstatic char_u\t    *mr_pattern = NULL;\n\n#ifdef FEAT_FIND_ID\n/*\n * Type used by find_pattern_in_path() to remember which included files have\n * been searched already.\n */\ntypedef struct SearchedFile\n{\n    FILE\t*fp;\t\t// File pointer\n    char_u\t*name;\t\t// Full name of file\n    linenr_T\tlnum;\t\t// Line we were up to in file\n    int\t\tmatched;\t// Found a match in this file\n} SearchedFile;\n#endif\n\n/*\n * translate search pattern for vim_regcomp()\n *\n * pat_save == RE_SEARCH: save pat in spats[RE_SEARCH].pat (normal search cmd)\n * pat_save == RE_SUBST: save pat in spats[RE_SUBST].pat (:substitute command)\n * pat_save == RE_BOTH: save pat in both patterns (:global command)\n * pat_use  == RE_SEARCH: use previous search pattern if \"pat\" is NULL\n * pat_use  == RE_SUBST: use previous substitute pattern if \"pat\" is NULL\n * pat_use  == RE_LAST: use last used pattern if \"pat\" is NULL\n * options & SEARCH_HIS: put search string in history\n * options & SEARCH_KEEP: keep previous search pattern\n *\n * returns FAIL if failed, OK otherwise.\n */\n    int\nsearch_regcomp(\n    char_u\t*pat,\n    char_u\t**used_pat,\n    int\t\tpat_save,\n    int\t\tpat_use,\n    int\t\toptions,\n    regmmatch_T\t*regmatch)\t// return: pattern and ignore-case flag\n{\n    int\t\tmagic;\n    int\t\ti;\n\n    rc_did_emsg = FALSE;\n    magic = magic_isset();\n\n    /*\n     * If no pattern given, use a previously defined pattern.\n     */\n    if (pat == NULL || *pat == NUL)\n    {\n\tif (pat_use == RE_LAST)\n\t    i = last_idx;\n\telse\n\t    i = pat_use;\n\tif (spats[i].pat == NULL)\t// pattern was never defined\n\t{\n\t    if (pat_use == RE_SUBST)\n\t\temsg(_(e_no_previous_substitute_regular_expression));\n\t    else\n\t\temsg(_(e_no_previous_regular_expression));\n\t    rc_did_emsg = TRUE;\n\t    return FAIL;\n\t}\n\tpat = spats[i].pat;\n\tmagic = spats[i].magic;\n\tno_smartcase = spats[i].no_scs;\n    }\n    else if (options & SEARCH_HIS)\t// put new pattern in history\n\tadd_to_history(HIST_SEARCH, pat, TRUE, NUL);\n\n    if (used_pat)\n\t*used_pat = pat;\n\n    vim_free(mr_pattern);\n#ifdef FEAT_RIGHTLEFT\n    if (curwin->w_p_rl && *curwin->w_p_rlc == 's')\n\tmr_pattern = reverse_text(pat);\n    else\n#endif\n\tmr_pattern = vim_strsave(pat);\n\n    /*\n     * Save the currently used pattern in the appropriate place,\n     * unless the pattern should not be remembered.\n     */\n    if (!(options & SEARCH_KEEP)\n\t\t\t       && (cmdmod.cmod_flags & CMOD_KEEPPATTERNS) == 0)\n    {\n\t// search or global command\n\tif (pat_save == RE_SEARCH || pat_save == RE_BOTH)\n\t    save_re_pat(RE_SEARCH, pat, magic);\n\t// substitute or global command\n\tif (pat_save == RE_SUBST || pat_save == RE_BOTH)\n\t    save_re_pat(RE_SUBST, pat, magic);\n    }\n\n    regmatch->rmm_ic = ignorecase(pat);\n    regmatch->rmm_maxcol = 0;\n    regmatch->regprog = vim_regcomp(pat, magic ? RE_MAGIC : 0);\n    if (regmatch->regprog == NULL)\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * Get search pattern used by search_regcomp().\n */\n    char_u *\nget_search_pat(void)\n{\n    return mr_pattern;\n}\n\n#if defined(FEAT_RIGHTLEFT) || defined(PROTO)\n/*\n * Reverse text into allocated memory.\n * Returns the allocated string, NULL when out of memory.\n */\n    char_u *\nreverse_text(char_u *s)\n{\n    unsigned\tlen;\n    unsigned\ts_i, rev_i;\n    char_u\t*rev;\n\n    /*\n     * Reverse the pattern.\n     */\n    len = (unsigned)STRLEN(s);\n    rev = alloc(len + 1);\n    if (rev == NULL)\n\treturn NULL;\n\n    rev_i = len;\n    for (s_i = 0; s_i < len; ++s_i)\n    {\n\tif (has_mbyte)\n\t{\n\t    int\tmb_len;\n\n\t    mb_len = (*mb_ptr2len)(s + s_i);\n\t    rev_i -= mb_len;\n\t    mch_memmove(rev + rev_i, s + s_i, mb_len);\n\t    s_i += mb_len - 1;\n\t}\n\telse\n\t    rev[--rev_i] = s[s_i];\n\n    }\n    rev[len] = NUL;\n    return rev;\n}\n#endif\n\n    void\nsave_re_pat(int idx, char_u *pat, int magic)\n{\n    if (spats[idx].pat == pat)\n\treturn;\n\n    vim_free(spats[idx].pat);\n    spats[idx].pat = vim_strsave(pat);\n    spats[idx].magic = magic;\n    spats[idx].no_scs = no_smartcase;\n    last_idx = idx;\n#ifdef FEAT_SEARCH_EXTRA\n    // If 'hlsearch' set and search pat changed: need redraw.\n    if (p_hls)\n\tredraw_all_later(UPD_SOME_VALID);\n    set_no_hlsearch(FALSE);\n#endif\n}\n\n/*\n * Save the search patterns, so they can be restored later.\n * Used before/after executing autocommands and user functions.\n */\nstatic int save_level = 0;\n\n    void\nsave_search_patterns(void)\n{\n    if (save_level++ != 0)\n\treturn;\n\n    saved_spats[0] = spats[0];\n    if (spats[0].pat != NULL)\n\tsaved_spats[0].pat = vim_strsave(spats[0].pat);\n    saved_spats[1] = spats[1];\n    if (spats[1].pat != NULL)\n\tsaved_spats[1].pat = vim_strsave(spats[1].pat);\n    if (mr_pattern == NULL)\n\tsaved_mr_pattern = NULL;\n    else\n\tsaved_mr_pattern = vim_strsave(mr_pattern);\n#ifdef FEAT_SEARCH_EXTRA\n    saved_spats_last_idx = last_idx;\n    saved_spats_no_hlsearch = no_hlsearch;\n#endif\n}\n\n    void\nrestore_search_patterns(void)\n{\n    if (--save_level != 0)\n\treturn;\n\n    vim_free(spats[0].pat);\n    spats[0] = saved_spats[0];\n#if defined(FEAT_EVAL)\n    set_vv_searchforward();\n#endif\n    vim_free(spats[1].pat);\n    spats[1] = saved_spats[1];\n    vim_free(mr_pattern);\n    mr_pattern = saved_mr_pattern;\n#ifdef FEAT_SEARCH_EXTRA\n    last_idx = saved_spats_last_idx;\n    set_no_hlsearch(saved_spats_no_hlsearch);\n#endif\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_search_patterns(void)\n{\n    vim_free(spats[0].pat);\n    vim_free(spats[1].pat);\n    VIM_CLEAR(mr_pattern);\n}\n#endif\n\n#ifdef FEAT_SEARCH_EXTRA\n// copy of spats[RE_SEARCH], for keeping the search patterns while incremental\n// searching\nstatic spat_T\t    saved_last_search_spat;\nstatic int\t    did_save_last_search_spat = 0;\nstatic int\t    saved_last_idx = 0;\nstatic int\t    saved_no_hlsearch = 0;\nstatic int\t    saved_search_match_endcol;\nstatic int\t    saved_search_match_lines;\n\n/*\n * Save and restore the search pattern for incremental highlight search\n * feature.\n *\n * It's similar to but different from save_search_patterns() and\n * restore_search_patterns(), because the search pattern must be restored when\n * canceling incremental searching even if it's called inside user functions.\n */\n    void\nsave_last_search_pattern(void)\n{\n    if (++did_save_last_search_spat != 1)\n\t// nested call, nothing to do\n\treturn;\n\n    saved_last_search_spat = spats[RE_SEARCH];\n    if (spats[RE_SEARCH].pat != NULL)\n\tsaved_last_search_spat.pat = vim_strsave(spats[RE_SEARCH].pat);\n    saved_last_idx = last_idx;\n    saved_no_hlsearch = no_hlsearch;\n}\n\n    void\nrestore_last_search_pattern(void)\n{\n    if (--did_save_last_search_spat > 0)\n\t// nested call, nothing to do\n\treturn;\n    if (did_save_last_search_spat != 0)\n    {\n\tiemsg(\"restore_last_search_pattern() called more often than save_last_search_pattern()\");\n\treturn;\n    }\n\n    vim_free(spats[RE_SEARCH].pat);\n    spats[RE_SEARCH] = saved_last_search_spat;\n    saved_last_search_spat.pat = NULL;\n# if defined(FEAT_EVAL)\n    set_vv_searchforward();\n# endif\n    last_idx = saved_last_idx;\n    set_no_hlsearch(saved_no_hlsearch);\n}\n\n/*\n * Save and restore the incsearch highlighting variables.\n * This is required so that calling searchcount() at does not invalidate the\n * incsearch highlighting.\n */\n    static void\nsave_incsearch_state(void)\n{\n    saved_search_match_endcol = search_match_endcol;\n    saved_search_match_lines  = search_match_lines;\n}\n\n    static void\nrestore_incsearch_state(void)\n{\n    search_match_endcol = saved_search_match_endcol;\n    search_match_lines  = saved_search_match_lines;\n}\n\n    char_u *\nlast_search_pattern(void)\n{\n    return spats[RE_SEARCH].pat;\n}\n#endif\n\n/*\n * Return TRUE when case should be ignored for search pattern \"pat\".\n * Uses the 'ignorecase' and 'smartcase' options.\n */\n    int\nignorecase(char_u *pat)\n{\n    return ignorecase_opt(pat, p_ic, p_scs);\n}\n\n/*\n * As ignorecase() put pass the \"ic\" and \"scs\" flags.\n */\n    int\nignorecase_opt(char_u *pat, int ic_in, int scs)\n{\n    int\t\tic = ic_in;\n\n    if (ic && !no_smartcase && scs\n\t\t\t    && !(ctrl_x_mode_not_default() && curbuf->b_p_inf))\n\tic = !pat_has_uppercase(pat);\n    no_smartcase = FALSE;\n\n    return ic;\n}\n\n/*\n * Return TRUE if pattern \"pat\" has an uppercase character.\n */\n    int\npat_has_uppercase(char_u *pat)\n{\n    char_u *p = pat;\n    magic_T magic_val = MAGIC_ON;\n\n    // get the magicness of the pattern\n    (void)skip_regexp_ex(pat, NUL, magic_isset(), NULL, NULL, &magic_val);\n\n    while (*p != NUL)\n    {\n\tint\t\tl;\n\n\tif (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)\n\t{\n\t    if (enc_utf8 && utf_isupper(utf_ptr2char(p)))\n\t\treturn TRUE;\n\t    p += l;\n\t}\n\telse if (*p == '\\\\' && magic_val <= MAGIC_ON)\n\t{\n\t    if (p[1] == '_' && p[2] != NUL)  // skip \"\\_X\"\n\t\tp += 3;\n\t    else if (p[1] == '%' && p[2] != NUL)  // skip \"\\%X\"\n\t\tp += 3;\n\t    else if (p[1] != NUL)  // skip \"\\X\"\n\t\tp += 2;\n\t    else\n\t\tp += 1;\n\t}\n\telse if ((*p == '%' || *p == '_') && magic_val == MAGIC_ALL)\n\t{\n\t    if (p[1] != NUL)  // skip \"_X\" and %X\n\t\tp += 2;\n\t    else\n\t\tp++;\n\t}\n\telse if (MB_ISUPPER(*p))\n\t    return TRUE;\n\telse\n\t    ++p;\n    }\n    return FALSE;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n    char_u *\nlast_csearch(void)\n{\n    return lastc_bytes;\n}\n\n    int\nlast_csearch_forward(void)\n{\n    return lastcdir == FORWARD;\n}\n\n    int\nlast_csearch_until(void)\n{\n    return last_t_cmd == TRUE;\n}\n\n    void\nset_last_csearch(int c, char_u *s UNUSED, int len UNUSED)\n{\n    *lastc = c;\n    lastc_bytelen = len;\n    if (len)\n\tmemcpy(lastc_bytes, s, len);\n    else\n\tCLEAR_FIELD(lastc_bytes);\n}\n#endif\n\n    void\nset_csearch_direction(int cdir)\n{\n    lastcdir = cdir;\n}\n\n    void\nset_csearch_until(int t_cmd)\n{\n    last_t_cmd = t_cmd;\n}\n\n    char_u *\nlast_search_pat(void)\n{\n    return spats[last_idx].pat;\n}\n\n/*\n * Reset search direction to forward.  For \"gd\" and \"gD\" commands.\n */\n    void\nreset_search_dir(void)\n{\n    spats[0].off.dir = '/';\n#if defined(FEAT_EVAL)\n    set_vv_searchforward();\n#endif\n}\n\n#if defined(FEAT_EVAL) || defined(FEAT_VIMINFO)\n/*\n * Set the last search pattern.  For \":let @/ =\" and viminfo.\n * Also set the saved search pattern, so that this works in an autocommand.\n */\n    void\nset_last_search_pat(\n    char_u\t*s,\n    int\t\tidx,\n    int\t\tmagic,\n    int\t\tsetlast)\n{\n    vim_free(spats[idx].pat);\n    // An empty string means that nothing should be matched.\n    if (*s == NUL)\n\tspats[idx].pat = NULL;\n    else\n\tspats[idx].pat = vim_strsave(s);\n    spats[idx].magic = magic;\n    spats[idx].no_scs = FALSE;\n    spats[idx].off.dir = '/';\n#if defined(FEAT_EVAL)\n    set_vv_searchforward();\n#endif\n    spats[idx].off.line = FALSE;\n    spats[idx].off.end = FALSE;\n    spats[idx].off.off = 0;\n    if (setlast)\n\tlast_idx = idx;\n    if (save_level)\n    {\n\tvim_free(saved_spats[idx].pat);\n\tsaved_spats[idx] = spats[0];\n\tif (spats[idx].pat == NULL)\n\t    saved_spats[idx].pat = NULL;\n\telse\n\t    saved_spats[idx].pat = vim_strsave(spats[idx].pat);\n# ifdef FEAT_SEARCH_EXTRA\n\tsaved_spats_last_idx = last_idx;\n# endif\n    }\n# ifdef FEAT_SEARCH_EXTRA\n    // If 'hlsearch' set and search pat changed: need redraw.\n    if (p_hls && idx == last_idx && !no_hlsearch)\n\tredraw_all_later(UPD_SOME_VALID);\n# endif\n}\n#endif\n\n#ifdef FEAT_SEARCH_EXTRA\n/*\n * Get a regexp program for the last used search pattern.\n * This is used for highlighting all matches in a window.\n * Values returned in regmatch->regprog and regmatch->rmm_ic.\n */\n    void\nlast_pat_prog(regmmatch_T *regmatch)\n{\n    if (spats[last_idx].pat == NULL)\n    {\n\tregmatch->regprog = NULL;\n\treturn;\n    }\n    ++emsg_off;\t\t// So it doesn't beep if bad expr\n    (void)search_regcomp((char_u *)\"\", NULL, 0, last_idx, SEARCH_KEEP, regmatch);\n    --emsg_off;\n}\n#endif\n\n/*\n * Lowest level search function.\n * Search for 'count'th occurrence of pattern \"pat\" in direction \"dir\".\n * Start at position \"pos\" and return the found position in \"pos\".\n *\n * if (options & SEARCH_MSG) == 0 don't give any messages\n * if (options & SEARCH_MSG) == SEARCH_NFMSG don't give 'notfound' messages\n * if (options & SEARCH_MSG) == SEARCH_MSG give all messages\n * if (options & SEARCH_HIS) put search pattern in history\n * if (options & SEARCH_END) return position at end of match\n * if (options & SEARCH_START) accept match at pos itself\n * if (options & SEARCH_KEEP) keep previous search pattern\n * if (options & SEARCH_FOLD) match only once in a closed fold\n * if (options & SEARCH_PEEK) check for typed char, cancel search\n * if (options & SEARCH_COL) start at pos->col instead of zero\n *\n * Return FAIL (zero) for failure, non-zero for success.\n * When FEAT_EVAL is defined, returns the index of the first matching\n * subpattern plus one; one if there was none.\n */\n    int\nsearchit(\n    win_T\t*win,\t\t// window to search in; can be NULL for a\n\t\t\t\t// buffer without a window!\n    buf_T\t*buf,\n    pos_T\t*pos,\n    pos_T\t*end_pos,\t// set to end of the match, unless NULL\n    int\t\tdir,\n    char_u\t*pat,\n    long\tcount,\n    int\t\toptions,\n    int\t\tpat_use,\t// which pattern to use when \"pat\" is empty\n    searchit_arg_T *extra_arg)\t// optional extra arguments, can be NULL\n{\n    int\t\tfound;\n    linenr_T\tlnum;\t\t// no init to shut up Apollo cc\n    colnr_T\tcol;\n    regmmatch_T\tregmatch;\n    char_u\t*ptr;\n    colnr_T\tmatchcol;\n    lpos_T\tendpos;\n    lpos_T\tmatchpos;\n    int\t\tloop;\n    pos_T\tstart_pos;\n    int\t\tat_first_line;\n    int\t\textra_col;\n    int\t\tstart_char_len;\n    int\t\tmatch_ok;\n    long\tnmatched;\n    int\t\tsubmatch = 0;\n    int\t\tfirst_match = TRUE;\n    int\t\tcalled_emsg_before = called_emsg;\n#ifdef FEAT_SEARCH_EXTRA\n    int\t\tbreak_loop = FALSE;\n#endif\n    linenr_T\tstop_lnum = 0;\t// stop after this line number when != 0\n    int\t\tunused_timeout_flag = FALSE;\n    int\t\t*timed_out = &unused_timeout_flag;  // set when timed out.\n\n    if (search_regcomp(pat, NULL, RE_SEARCH, pat_use,\n\t\t   (options & (SEARCH_HIS + SEARCH_KEEP)), &regmatch) == FAIL)\n    {\n\tif ((options & SEARCH_MSG) && !rc_did_emsg)\n\t    semsg(_(e_invalid_search_string_str), mr_pattern);\n\treturn FAIL;\n    }\n\n    if (extra_arg != NULL)\n    {\n\tstop_lnum = extra_arg->sa_stop_lnum;\n#ifdef FEAT_RELTIME\n\tif (extra_arg->sa_tm > 0)\n\t    init_regexp_timeout(extra_arg->sa_tm);\n\t// Also set the pointer when sa_tm is zero, the caller may have set the\n\t// timeout.\n\ttimed_out = &extra_arg->sa_timed_out;\n#endif\n    }\n\n    /*\n     * find the string\n     */\n    do\t// loop for count\n    {\n\t// When not accepting a match at the start position set \"extra_col\" to\n\t// a non-zero value.  Don't do that when starting at MAXCOL, since\n\t// MAXCOL + 1 is zero.\n\tif (pos->col == MAXCOL)\n\t    start_char_len = 0;\n\t// Watch out for the \"col\" being MAXCOL - 2, used in a closed fold.\n\telse if (has_mbyte\n\t\t    && pos->lnum >= 1 && pos->lnum <= buf->b_ml.ml_line_count\n\t\t\t\t\t\t    && pos->col < MAXCOL - 2)\n\t{\n\t    ptr = ml_get_buf(buf, pos->lnum, FALSE);\n\t    if ((int)STRLEN(ptr) <= pos->col)\n\t\tstart_char_len = 1;\n\t    else\n\t\tstart_char_len = (*mb_ptr2len)(ptr + pos->col);\n\t}\n\telse\n\t    start_char_len = 1;\n\tif (dir == FORWARD)\n\t{\n\t    if (options & SEARCH_START)\n\t\textra_col = 0;\n\t    else\n\t\textra_col = start_char_len;\n\t}\n\telse\n\t{\n\t    if (options & SEARCH_START)\n\t\textra_col = start_char_len;\n\t    else\n\t\textra_col = 0;\n\t}\n\n\tstart_pos = *pos;\t// remember start pos for detecting no match\n\tfound = 0;\t\t// default: not found\n\tat_first_line = TRUE;\t// default: start in first line\n\tif (pos->lnum == 0)\t// correct lnum for when starting in line 0\n\t{\n\t    pos->lnum = 1;\n\t    pos->col = 0;\n\t    at_first_line = FALSE;  // not in first line now\n\t}\n\n\t/*\n\t * Start searching in current line, unless searching backwards and\n\t * we're in column 0.\n\t * If we are searching backwards, in column 0, and not including the\n\t * current position, gain some efficiency by skipping back a line.\n\t * Otherwise begin the search in the current line.\n\t */\n\tif (dir == BACKWARD && start_pos.col == 0\n\t\t\t\t\t     && (options & SEARCH_START) == 0)\n\t{\n\t    lnum = pos->lnum - 1;\n\t    at_first_line = FALSE;\n\t}\n\telse\n\t    lnum = pos->lnum;\n\n\tfor (loop = 0; loop <= 1; ++loop)   // loop twice if 'wrapscan' set\n\t{\n\t    for ( ; lnum > 0 && lnum <= buf->b_ml.ml_line_count;\n\t\t\t\t\t   lnum += dir, at_first_line = FALSE)\n\t    {\n\t\t// Stop after checking \"stop_lnum\", if it's set.\n\t\tif (stop_lnum != 0 && (dir == FORWARD\n\t\t\t\t       ? lnum > stop_lnum : lnum < stop_lnum))\n\t\t    break;\n\t\t// Stop after passing the time limit.\n\t\tif (*timed_out)\n\t\t    break;\n\n\t\t/*\n\t\t * Look for a match somewhere in line \"lnum\".\n\t\t */\n\t\tcol = at_first_line && (options & SEARCH_COL) ? pos->col\n\t\t\t\t\t\t\t\t : (colnr_T)0;\n\t\tnmatched = vim_regexec_multi(&regmatch, win, buf,\n\t\t\t\t\t\t\t lnum, col, timed_out);\n\t\t// vim_regexec_multi() may clear \"regprog\"\n\t\tif (regmatch.regprog == NULL)\n\t\t    break;\n\t\t// Abort searching on an error (e.g., out of stack).\n\t\tif (called_emsg > called_emsg_before || *timed_out)\n\t\t    break;\n\t\tif (nmatched > 0)\n\t\t{\n\t\t    // match may actually be in another line when using \\zs\n\t\t    matchpos = regmatch.startpos[0];\n\t\t    endpos = regmatch.endpos[0];\n#ifdef FEAT_EVAL\n\t\t    submatch = first_submatch(&regmatch);\n#endif\n\t\t    // \"lnum\" may be past end of buffer for \"\\n\\zs\".\n\t\t    if (lnum + matchpos.lnum > buf->b_ml.ml_line_count)\n\t\t\tptr = (char_u *)\"\";\n\t\t    else\n\t\t\tptr = ml_get_buf(buf, lnum + matchpos.lnum, FALSE);\n\n\t\t    /*\n\t\t     * Forward search in the first line: match should be after\n\t\t     * the start position. If not, continue at the end of the\n\t\t     * match (this is vi compatible) or on the next char.\n\t\t     */\n\t\t    if (dir == FORWARD && at_first_line)\n\t\t    {\n\t\t\tmatch_ok = TRUE;\n\n\t\t\t/*\n\t\t\t * When the match starts in a next line it's certainly\n\t\t\t * past the start position.\n\t\t\t * When match lands on a NUL the cursor will be put\n\t\t\t * one back afterwards, compare with that position,\n\t\t\t * otherwise \"/$\" will get stuck on end of line.\n\t\t\t */\n\t\t\twhile (matchpos.lnum == 0\n\t\t\t\t&& ((options & SEARCH_END) && first_match\n\t\t\t\t    ?  (nmatched == 1\n\t\t\t\t\t&& (int)endpos.col - 1\n\t\t\t\t\t     < (int)start_pos.col + extra_col)\n\t\t\t\t    : ((int)matchpos.col\n\t\t\t\t\t\t  - (ptr[matchpos.col] == NUL)\n\t\t\t\t\t    < (int)start_pos.col + extra_col)))\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * If vi-compatible searching, continue at the end\n\t\t\t     * of the match, otherwise continue one position\n\t\t\t     * forward.\n\t\t\t     */\n\t\t\t    if (vim_strchr(p_cpo, CPO_SEARCH) != NULL)\n\t\t\t    {\n\t\t\t\tif (nmatched > 1)\n\t\t\t\t{\n\t\t\t\t    // end is in next line, thus no match in\n\t\t\t\t    // this line\n\t\t\t\t    match_ok = FALSE;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t\tmatchcol = endpos.col;\n\t\t\t\t// for empty match: advance one char\n\t\t\t\tif (matchcol == matchpos.col\n\t\t\t\t\t\t      && ptr[matchcol] != NUL)\n\t\t\t\t{\n\t\t\t\t    if (has_mbyte)\n\t\t\t\t\tmatchcol +=\n\t\t\t\t\t  (*mb_ptr2len)(ptr + matchcol);\n\t\t\t\t    else\n\t\t\t\t\t++matchcol;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\t// Advance \"matchcol\" to the next character.\n\t\t\t\t// This uses rmm_matchcol, the actual start of\n\t\t\t\t// the match, ignoring \"\\zs\".\n\t\t\t\tmatchcol = regmatch.rmm_matchcol;\n\t\t\t\tif (ptr[matchcol] != NUL)\n\t\t\t\t{\n\t\t\t\t    if (has_mbyte)\n\t\t\t\t\tmatchcol += (*mb_ptr2len)(ptr\n\t\t\t\t\t\t\t\t  + matchcol);\n\t\t\t\t    else\n\t\t\t\t\t++matchcol;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    if (matchcol == 0 && (options & SEARCH_START))\n\t\t\t\tbreak;\n\t\t\t    if (ptr[matchcol] == NUL\n\t\t\t\t    || (nmatched = vim_regexec_multi(&regmatch,\n\t\t\t\t\t      win, buf, lnum + matchpos.lnum,\n\t\t\t\t\t      matchcol, timed_out)) == 0)\n\t\t\t    {\n\t\t\t\tmatch_ok = FALSE;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    // vim_regexec_multi() may clear \"regprog\"\n\t\t\t    if (regmatch.regprog == NULL)\n\t\t\t\tbreak;\n\t\t\t    matchpos = regmatch.startpos[0];\n\t\t\t    endpos = regmatch.endpos[0];\n# ifdef FEAT_EVAL\n\t\t\t    submatch = first_submatch(&regmatch);\n# endif\n\n\t\t\t    // Need to get the line pointer again, a\n\t\t\t    // multi-line search may have made it invalid.\n\t\t\t    ptr = ml_get_buf(buf, lnum + matchpos.lnum, FALSE);\n\t\t\t}\n\t\t\tif (!match_ok)\n\t\t\t    continue;\n\t\t    }\n\t\t    if (dir == BACKWARD)\n\t\t    {\n\t\t\t/*\n\t\t\t * Now, if there are multiple matches on this line,\n\t\t\t * we have to get the last one. Or the last one before\n\t\t\t * the cursor, if we're on that line.\n\t\t\t * When putting the new cursor at the end, compare\n\t\t\t * relative to the end of the match.\n\t\t\t */\n\t\t\tmatch_ok = FALSE;\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t    // Remember a position that is before the start\n\t\t\t    // position, we use it if it's the last match in\n\t\t\t    // the line.  Always accept a position after\n\t\t\t    // wrapping around.\n\t\t\t    if (loop\n\t\t\t\t|| ((options & SEARCH_END)\n\t\t\t\t    ? (lnum + regmatch.endpos[0].lnum\n\t\t\t\t\t\t\t      < start_pos.lnum\n\t\t\t\t\t|| (lnum + regmatch.endpos[0].lnum\n\t\t\t\t\t\t\t     == start_pos.lnum\n\t\t\t\t\t     && (int)regmatch.endpos[0].col - 1\n\t\t\t\t\t\t\t< (int)start_pos.col\n\t\t\t\t\t\t\t\t+ extra_col))\n\t\t\t\t    : (lnum + regmatch.startpos[0].lnum\n\t\t\t\t\t\t\t      < start_pos.lnum\n\t\t\t\t\t|| (lnum + regmatch.startpos[0].lnum\n\t\t\t\t\t\t\t     == start_pos.lnum\n\t\t\t\t\t     && (int)regmatch.startpos[0].col\n\t\t\t\t\t\t      < (int)start_pos.col\n\t\t\t\t\t\t\t      + extra_col))))\n\t\t\t    {\n\t\t\t\tmatch_ok = TRUE;\n\t\t\t\tmatchpos = regmatch.startpos[0];\n\t\t\t\tendpos = regmatch.endpos[0];\n# ifdef FEAT_EVAL\n\t\t\t\tsubmatch = first_submatch(&regmatch);\n# endif\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tbreak;\n\n\t\t\t    /*\n\t\t\t     * We found a valid match, now check if there is\n\t\t\t     * another one after it.\n\t\t\t     * If vi-compatible searching, continue at the end\n\t\t\t     * of the match, otherwise continue one position\n\t\t\t     * forward.\n\t\t\t     */\n\t\t\t    if (vim_strchr(p_cpo, CPO_SEARCH) != NULL)\n\t\t\t    {\n\t\t\t\tif (nmatched > 1)\n\t\t\t\t    break;\n\t\t\t\tmatchcol = endpos.col;\n\t\t\t\t// for empty match: advance one char\n\t\t\t\tif (matchcol == matchpos.col\n\t\t\t\t\t\t      && ptr[matchcol] != NUL)\n\t\t\t\t{\n\t\t\t\t    if (has_mbyte)\n\t\t\t\t\tmatchcol +=\n\t\t\t\t\t  (*mb_ptr2len)(ptr + matchcol);\n\t\t\t\t    else\n\t\t\t\t\t++matchcol;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\t// Stop when the match is in a next line.\n\t\t\t\tif (matchpos.lnum > 0)\n\t\t\t\t    break;\n\t\t\t\tmatchcol = matchpos.col;\n\t\t\t\tif (ptr[matchcol] != NUL)\n\t\t\t\t{\n\t\t\t\t    if (has_mbyte)\n\t\t\t\t\tmatchcol +=\n\t\t\t\t\t  (*mb_ptr2len)(ptr + matchcol);\n\t\t\t\t    else\n\t\t\t\t\t++matchcol;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    if (ptr[matchcol] == NUL\n\t\t\t\t    || (nmatched = vim_regexec_multi(&regmatch,\n\t\t\t\t\t      win, buf, lnum + matchpos.lnum,\n\t\t\t\t\t      matchcol, timed_out)) == 0)\n\t\t\t    {\n\t\t\t\t// If the search timed out, we did find a match\n\t\t\t\t// but it might be the wrong one, so that's not\n\t\t\t\t// OK.\n\t\t\t\tif (*timed_out)\n\t\t\t\t    match_ok = FALSE;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    // vim_regexec_multi() may clear \"regprog\"\n\t\t\t    if (regmatch.regprog == NULL)\n\t\t\t\tbreak;\n\n\t\t\t    // Need to get the line pointer again, a\n\t\t\t    // multi-line search may have made it invalid.\n\t\t\t    ptr = ml_get_buf(buf, lnum + matchpos.lnum, FALSE);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If there is only a match after the cursor, skip\n\t\t\t * this match.\n\t\t\t */\n\t\t\tif (!match_ok)\n\t\t\t    continue;\n\t\t    }\n\n\t\t    // With the SEARCH_END option move to the last character\n\t\t    // of the match.  Don't do it for an empty match, end\n\t\t    // should be same as start then.\n\t\t    if ((options & SEARCH_END) && !(options & SEARCH_NOOF)\n\t\t\t    && !(matchpos.lnum == endpos.lnum\n\t\t\t\t&& matchpos.col == endpos.col))\n\t\t    {\n\t\t\t// For a match in the first column, set the position\n\t\t\t// on the NUL in the previous line.\n\t\t\tpos->lnum = lnum + endpos.lnum;\n\t\t\tpos->col = endpos.col;\n\t\t\tif (endpos.col == 0)\n\t\t\t{\n\t\t\t    if (pos->lnum > 1)  // just in case\n\t\t\t    {\n\t\t\t\t--pos->lnum;\n\t\t\t\tpos->col = (colnr_T)STRLEN(ml_get_buf(buf,\n\t\t\t\t\t\t\t   pos->lnum, FALSE));\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    --pos->col;\n\t\t\t    if (has_mbyte\n\t\t\t\t    && pos->lnum <= buf->b_ml.ml_line_count)\n\t\t\t    {\n\t\t\t\tptr = ml_get_buf(buf, pos->lnum, FALSE);\n\t\t\t\tpos->col -= (*mb_head_off)(ptr, ptr + pos->col);\n\t\t\t    }\n\t\t\t}\n\t\t\tif (end_pos != NULL)\n\t\t\t{\n\t\t\t    end_pos->lnum = lnum + matchpos.lnum;\n\t\t\t    end_pos->col = matchpos.col;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tpos->lnum = lnum + matchpos.lnum;\n\t\t\tpos->col = matchpos.col;\n\t\t\tif (end_pos != NULL)\n\t\t\t{\n\t\t\t    end_pos->lnum = lnum + endpos.lnum;\n\t\t\t    end_pos->col = endpos.col;\n\t\t\t}\n\t\t    }\n\t\t    pos->coladd = 0;\n\t\t    if (end_pos != NULL)\n\t\t\tend_pos->coladd = 0;\n\t\t    found = 1;\n\t\t    first_match = FALSE;\n\n\t\t    // Set variables used for 'incsearch' highlighting.\n\t\t    search_match_lines = endpos.lnum - matchpos.lnum;\n\t\t    search_match_endcol = endpos.col;\n\t\t    break;\n\t\t}\n\t\tline_breakcheck();\t// stop if ctrl-C typed\n\t\tif (got_int)\n\t\t    break;\n\n#ifdef FEAT_SEARCH_EXTRA\n\t\t// Cancel searching if a character was typed.  Used for\n\t\t// 'incsearch'.  Don't check too often, that would slowdown\n\t\t// searching too much.\n\t\tif ((options & SEARCH_PEEK)\n\t\t\t&& ((lnum - pos->lnum) & 0x3f) == 0\n\t\t\t&& char_avail())\n\t\t{\n\t\t    break_loop = TRUE;\n\t\t    break;\n\t\t}\n#endif\n\n\t\tif (loop && lnum == start_pos.lnum)\n\t\t    break;\t    // if second loop, stop where started\n\t    }\n\t    at_first_line = FALSE;\n\n\t    // vim_regexec_multi() may clear \"regprog\"\n\t    if (regmatch.regprog == NULL)\n\t\tbreak;\n\n\t    /*\n\t     * Stop the search if wrapscan isn't set, \"stop_lnum\" is\n\t     * specified, after an interrupt, after a match and after looping\n\t     * twice.\n\t     */\n\t    if (!p_ws || stop_lnum != 0 || got_int\n\t\t\t      || called_emsg > called_emsg_before || *timed_out\n#ifdef FEAT_SEARCH_EXTRA\n\t\t\t      || break_loop\n#endif\n\t\t\t      || found || loop)\n\t\tbreak;\n\n\t    /*\n\t     * If 'wrapscan' is set we continue at the other end of the file.\n\t     * If 'shortmess' does not contain 's', we give a message.\n\t     * This message is also remembered in keep_msg for when the screen\n\t     * is redrawn. The keep_msg is cleared whenever another message is\n\t     * written.\n\t     */\n\t    if (dir == BACKWARD)    // start second loop at the other end\n\t\tlnum = buf->b_ml.ml_line_count;\n\t    else\n\t\tlnum = 1;\n\t    if (!shortmess(SHM_SEARCH) && (options & SEARCH_MSG))\n\t\tgive_warning((char_u *)_(dir == BACKWARD\n\t\t\t\t\t  ? top_bot_msg : bot_top_msg), TRUE);\n\t    if (extra_arg != NULL)\n\t\textra_arg->sa_wrapped = TRUE;\n\t}\n\tif (got_int || called_emsg > called_emsg_before || *timed_out\n#ifdef FEAT_SEARCH_EXTRA\n\t\t|| break_loop\n#endif\n\t\t)\n\t    break;\n    }\n    while (--count > 0 && found);   // stop after count matches or no match\n\n#ifdef FEAT_RELTIME\n    if (extra_arg != NULL && extra_arg->sa_tm > 0)\n\tdisable_regexp_timeout();\n#endif\n    vim_regfree(regmatch.regprog);\n\n    if (!found)\t\t    // did not find it\n    {\n\tif (got_int)\n\t    emsg(_(e_interrupted));\n\telse if ((options & SEARCH_MSG) == SEARCH_MSG)\n\t{\n\t    if (p_ws)\n\t\tsemsg(_(e_pattern_not_found_str), mr_pattern);\n\t    else if (lnum == 0)\n\t\tsemsg(_(e_search_hit_top_without_match_for_str), mr_pattern);\n\t    else\n\t\tsemsg(_(e_search_hit_bottom_without_match_for_str), mr_pattern);\n\t}\n\treturn FAIL;\n    }\n\n    // A pattern like \"\\n\\zs\" may go past the last line.\n    if (pos->lnum > buf->b_ml.ml_line_count)\n    {\n\tpos->lnum = buf->b_ml.ml_line_count;\n\tpos->col = (int)STRLEN(ml_get_buf(buf, pos->lnum, FALSE));\n\tif (pos->col > 0)\n\t    --pos->col;\n    }\n\n    return submatch + 1;\n}\n\n#if defined(FEAT_EVAL) || defined(FEAT_PROTO)\n    void\nset_search_direction(int cdir)\n{\n    spats[0].off.dir = cdir;\n}\n\n    static void\nset_vv_searchforward(void)\n{\n    set_vim_var_nr(VV_SEARCHFORWARD, (long)(spats[0].off.dir == '/'));\n}\n\n/*\n * Return the number of the first subpat that matched.\n * Return zero if none of them matched.\n */\n    static int\nfirst_submatch(regmmatch_T *rp)\n{\n    int\t\tsubmatch;\n\n    for (submatch = 1; ; ++submatch)\n    {\n\tif (rp->startpos[submatch].lnum >= 0)\n\t    break;\n\tif (submatch == 9)\n\t{\n\t    submatch = 0;\n\t    break;\n\t}\n    }\n    return submatch;\n}\n#endif\n\n/*\n * Highest level string search function.\n * Search for the 'count'th occurrence of pattern 'pat' in direction 'dirc'\n *\t\t  If 'dirc' is 0: use previous dir.\n *    If 'pat' is NULL or empty : use previous string.\n *    If 'options & SEARCH_REV' : go in reverse of previous dir.\n *    If 'options & SEARCH_ECHO': echo the search command and handle options\n *    If 'options & SEARCH_MSG' : may give error message\n *    If 'options & SEARCH_OPT' : interpret optional flags\n *    If 'options & SEARCH_HIS' : put search pattern in history\n *    If 'options & SEARCH_NOOF': don't add offset to position\n *    If 'options & SEARCH_MARK': set previous context mark\n *    If 'options & SEARCH_KEEP': keep previous search pattern\n *    If 'options & SEARCH_START': accept match at curpos itself\n *    If 'options & SEARCH_PEEK': check for typed char, cancel search\n *\n * Careful: If spats[0].off.line == TRUE and spats[0].off.off == 0 this\n * makes the movement linewise without moving the match position.\n *\n * Return 0 for failure, 1 for found, 2 for found and line offset added.\n */\n    int\ndo_search(\n    oparg_T\t    *oap,\t// can be NULL\n    int\t\t    dirc,\t// '/' or '?'\n    int\t\t    search_delim, // the delimiter for the search, e.g. '%' in\n\t\t\t\t  // s%regex%replacement%\n    char_u\t    *pat,\n    long\t    count,\n    int\t\t    options,\n    searchit_arg_T  *sia)\t// optional arguments or NULL\n{\n    pos_T\t    pos;\t// position of the last match\n    char_u\t    *searchstr;\n    soffset_T\t    old_off;\n    int\t\t    retval;\t// Return value\n    char_u\t    *p;\n    long\t    c;\n    char_u\t    *dircp;\n    char_u\t    *strcopy = NULL;\n    char_u\t    *ps;\n    char_u\t    *msgbuf = NULL;\n    size_t\t    len;\n    int\t\t    has_offset = FALSE;\n\n    /*\n     * A line offset is not remembered, this is vi compatible.\n     */\n    if (spats[0].off.line && vim_strchr(p_cpo, CPO_LINEOFF) != NULL)\n    {\n\tspats[0].off.line = FALSE;\n\tspats[0].off.off = 0;\n    }\n\n    /*\n     * Save the values for when (options & SEARCH_KEEP) is used.\n     * (there is no \"if ()\" around this because gcc wants them initialized)\n     */\n    old_off = spats[0].off;\n\n    pos = curwin->w_cursor;\t// start searching at the cursor position\n\n    /*\n     * Find out the direction of the search.\n     */\n    if (dirc == 0)\n\tdirc = spats[0].off.dir;\n    else\n    {\n\tspats[0].off.dir = dirc;\n#if defined(FEAT_EVAL)\n\tset_vv_searchforward();\n#endif\n    }\n    if (options & SEARCH_REV)\n    {\n#ifdef MSWIN\n\t// There is a bug in the Visual C++ 2.2 compiler which means that\n\t// dirc always ends up being '/'\n\tdirc = (dirc == '/')  ?  '?'  :  '/';\n#else\n\tif (dirc == '/')\n\t    dirc = '?';\n\telse\n\t    dirc = '/';\n#endif\n    }\n\n#ifdef FEAT_FOLDING\n    // If the cursor is in a closed fold, don't find another match in the same\n    // fold.\n    if (dirc == '/')\n    {\n\tif (hasFolding(pos.lnum, NULL, &pos.lnum))\n\t    pos.col = MAXCOL - 2;\t// avoid overflow when adding 1\n    }\n    else\n    {\n\tif (hasFolding(pos.lnum, &pos.lnum, NULL))\n\t    pos.col = 0;\n    }\n#endif\n\n#ifdef FEAT_SEARCH_EXTRA\n    /*\n     * Turn 'hlsearch' highlighting back on.\n     */\n    if (no_hlsearch && !(options & SEARCH_KEEP))\n    {\n\tredraw_all_later(UPD_SOME_VALID);\n\tset_no_hlsearch(FALSE);\n    }\n#endif\n\n    /*\n     * Repeat the search when pattern followed by ';', e.g. \"/foo/;?bar\".\n     */\n    for (;;)\n    {\n\tint\t\tshow_top_bot_msg = FALSE;\n\n\tsearchstr = pat;\n\tdircp = NULL;\n\t\t\t\t\t    // use previous pattern\n\tif (pat == NULL || *pat == NUL || *pat == search_delim)\n\t{\n\t    if (spats[RE_SEARCH].pat == NULL)\t    // no previous pattern\n\t    {\n\t\tsearchstr = spats[RE_SUBST].pat;\n\t\tif (searchstr == NULL)\n\t\t{\n\t\t    emsg(_(e_no_previous_regular_expression));\n\t\t    retval = 0;\n\t\t    goto end_do_search;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// make search_regcomp() use spats[RE_SEARCH].pat\n\t\tsearchstr = (char_u *)\"\";\n\t    }\n\t}\n\n\tif (pat != NULL && *pat != NUL)\t// look for (new) offset\n\t{\n\t    /*\n\t     * Find end of regular expression.\n\t     * If there is a matching '/' or '?', toss it.\n\t     */\n\t    ps = strcopy;\n\t    p = skip_regexp_ex(pat, search_delim, magic_isset(),\n\t\t\t\t\t\t\t&strcopy, NULL, NULL);\n\t    if (strcopy != ps)\n\t    {\n\t\t// made a copy of \"pat\" to change \"\\?\" to \"?\"\n\t\tsearchcmdlen += (int)(STRLEN(pat) - STRLEN(strcopy));\n\t\tpat = strcopy;\n\t\tsearchstr = strcopy;\n\t    }\n\t    if (*p == search_delim)\n\t    {\n\t\tdircp = p;\t// remember where we put the NUL\n\t\t*p++ = NUL;\n\t    }\n\t    spats[0].off.line = FALSE;\n\t    spats[0].off.end = FALSE;\n\t    spats[0].off.off = 0;\n\t    /*\n\t     * Check for a line offset or a character offset.\n\t     * For get_address (echo off) we don't check for a character\n\t     * offset, because it is meaningless and the 's' could be a\n\t     * substitute command.\n\t     */\n\t    if (*p == '+' || *p == '-' || VIM_ISDIGIT(*p))\n\t\tspats[0].off.line = TRUE;\n\t    else if ((options & SEARCH_OPT)\n\t\t\t\t      && (*p == 'e' || *p == 's' || *p == 'b'))\n\t    {\n\t\tif (*p == 'e')\t\t// end\n\t\t    spats[0].off.end = SEARCH_END;\n\t\t++p;\n\t    }\n\t    if (VIM_ISDIGIT(*p) || *p == '+' || *p == '-')  // got an offset\n\t    {\n\t\t\t\t\t    // 'nr' or '+nr' or '-nr'\n\t\tif (VIM_ISDIGIT(*p) || VIM_ISDIGIT(*(p + 1)))\n\t\t    spats[0].off.off = atol((char *)p);\n\t\telse if (*p == '-')\t    // single '-'\n\t\t    spats[0].off.off = -1;\n\t\telse\t\t\t    // single '+'\n\t\t    spats[0].off.off = 1;\n\t\t++p;\n\t\twhile (VIM_ISDIGIT(*p))\t    // skip number\n\t\t    ++p;\n\t    }\n\n\t    // compute length of search command for get_address()\n\t    searchcmdlen += (int)(p - pat);\n\n\t    pat = p;\t\t\t    // put pat after search command\n\t}\n\n\tif ((options & SEARCH_ECHO) && messaging()\n\t\t&& !msg_silent\n\t\t&& (!cmd_silent || !shortmess(SHM_SEARCHCOUNT)))\n\t{\n\t    char_u\t*trunc;\n\t    char_u\toff_buf[40];\n\t    size_t\toff_len = 0;\n\n\t    // Compute msg_row early.\n\t    msg_start();\n\n\t    // Get the offset, so we know how long it is.\n\t    if (!cmd_silent &&\n\t\t    (spats[0].off.line || spats[0].off.end || spats[0].off.off))\n\t    {\n\t\tp = off_buf;\n\t\t*p++ = dirc;\n\t\tif (spats[0].off.end)\n\t\t    *p++ = 'e';\n\t\telse if (!spats[0].off.line)\n\t\t    *p++ = 's';\n\t\tif (spats[0].off.off > 0 || spats[0].off.line)\n\t\t    *p++ = '+';\n\t\t*p = NUL;\n\t\tif (spats[0].off.off != 0 || spats[0].off.line)\n\t\t    sprintf((char *)p, \"%ld\", spats[0].off.off);\n\t\toff_len = STRLEN(off_buf);\n\t    }\n\n\t    if (*searchstr == NUL)\n\t\tp = spats[0].pat;\n\t    else\n\t\tp = searchstr;\n\n\t    if (!shortmess(SHM_SEARCHCOUNT) || cmd_silent)\n\t    {\n\t\t// Reserve enough space for the search pattern + offset +\n\t\t// search stat.  Use all the space available, so that the\n\t\t// search state is right aligned.  If there is not enough space\n\t\t// msg_strtrunc() will shorten in the middle.\n\t\tif (msg_scrolled != 0 && !cmd_silent)\n\t\t    // Use all the columns.\n\t\t    len = (int)(Rows - msg_row) * Columns - 1;\n\t\telse\n\t\t    // Use up to 'showcmd' column.\n\t\t    len = (int)(Rows - msg_row - 1) * Columns + sc_col - 1;\n\t\tif (len < STRLEN(p) + off_len + SEARCH_STAT_BUF_LEN + 3)\n\t\t    len = STRLEN(p) + off_len + SEARCH_STAT_BUF_LEN + 3;\n\t    }\n\t    else\n\t\t// Reserve enough space for the search pattern + offset.\n\t\tlen = STRLEN(p) + off_len + 3;\n\n\t    vim_free(msgbuf);\n\t    msgbuf = alloc(len);\n\t    if (msgbuf != NULL)\n\t    {\n\t\tvim_memset(msgbuf, ' ', len);\n\t\tmsgbuf[len - 1] = NUL;\n\t\t// do not fill the msgbuf buffer, if cmd_silent is set, leave it\n\t\t// empty for the search_stat feature.\n\t\tif (!cmd_silent)\n\t\t{\n\t\t    msgbuf[0] = dirc;\n\n\t\t    if (enc_utf8 && utf_iscomposing(utf_ptr2char(p)))\n\t\t    {\n\t\t\t// Use a space to draw the composing char on.\n\t\t\tmsgbuf[1] = ' ';\n\t\t\tmch_memmove(msgbuf + 2, p, STRLEN(p));\n\t\t    }\n\t\t    else\n\t\t\tmch_memmove(msgbuf + 1, p, STRLEN(p));\n\t\t    if (off_len > 0)\n\t\t\tmch_memmove(msgbuf + STRLEN(p) + 1, off_buf, off_len);\n\n\t\t    trunc = msg_strtrunc(msgbuf, TRUE);\n\t\t    if (trunc != NULL)\n\t\t    {\n\t\t\tvim_free(msgbuf);\n\t\t\tmsgbuf = trunc;\n\t\t    }\n\n#ifdef FEAT_RIGHTLEFT\n\t\t    // The search pattern could be shown on the right in\n\t\t    // rightleft mode, but the 'ruler' and 'showcmd' area use\n\t\t    // it too, thus it would be blanked out again very soon.\n\t\t    // Show it on the left, but do reverse the text.\n\t\t    if (curwin->w_p_rl && *curwin->w_p_rlc == 's')\n\t\t    {\n\t\t\tchar_u *r;\n\t\t\tsize_t pat_len;\n\n\t\t\tr = reverse_text(msgbuf);\n\t\t\tif (r != NULL)\n\t\t\t{\n\t\t\t    vim_free(msgbuf);\n\t\t\t    msgbuf = r;\n\t\t\t    // move reversed text to beginning of buffer\n\t\t\t    while (*r != NUL && *r == ' ')\n\t\t\t\tr++;\n\t\t\t    pat_len = msgbuf + STRLEN(msgbuf) - r;\n\t\t\t    mch_memmove(msgbuf, r, pat_len);\n\t\t\t    // overwrite old text\n\t\t\t    if ((size_t)(r - msgbuf) >= pat_len)\n\t\t\t\tvim_memset(r, ' ', pat_len);\n\t\t\t    else\n\t\t\t\tvim_memset(msgbuf + pat_len, ' ', r - msgbuf);\n\t\t\t}\n\t\t    }\n#endif\n\t\t    msg_outtrans(msgbuf);\n\t\t    msg_clr_eos();\n\t\t    msg_check();\n\n\t\t    gotocmdline(FALSE);\n\t\t    out_flush();\n\t\t    msg_nowait = TRUE;\t    // don't wait for this message\n\t\t}\n\t    }\n\t}\n\n\t/*\n\t * If there is a character offset, subtract it from the current\n\t * position, so we don't get stuck at \"?pat?e+2\" or \"/pat/s-2\".\n\t * Skip this if pos.col is near MAXCOL (closed fold).\n\t * This is not done for a line offset, because then we would not be vi\n\t * compatible.\n\t */\n\tif (!spats[0].off.line && spats[0].off.off && pos.col < MAXCOL - 2)\n\t{\n\t    if (spats[0].off.off > 0)\n\t    {\n\t\tfor (c = spats[0].off.off; c; --c)\n\t\t    if (decl(&pos) == -1)\n\t\t\tbreak;\n\t\tif (c)\t\t\t// at start of buffer\n\t\t{\n\t\t    pos.lnum = 0;\t// allow lnum == 0 here\n\t\t    pos.col = MAXCOL;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tfor (c = spats[0].off.off; c; ++c)\n\t\t    if (incl(&pos) == -1)\n\t\t\tbreak;\n\t\tif (c)\t\t\t// at end of buffer\n\t\t{\n\t\t    pos.lnum = curbuf->b_ml.ml_line_count + 1;\n\t\t    pos.col = 0;\n\t\t}\n\t    }\n\t}\n\n\t/*\n\t * The actual search.\n\t */\n\tc = searchit(curwin, curbuf, &pos, NULL,\n\t\t\t\t\t      dirc == '/' ? FORWARD : BACKWARD,\n\t\tsearchstr, count, spats[0].off.end + (options &\n\t\t       (SEARCH_KEEP + SEARCH_PEEK + SEARCH_HIS\n\t\t\t+ SEARCH_MSG + SEARCH_START\n\t\t\t+ ((pat != NULL && *pat == ';') ? 0 : SEARCH_NOOF))),\n\t\tRE_LAST, sia);\n\n\tif (dircp != NULL)\n\t    *dircp = search_delim; // restore second '/' or '?' for normal_cmd()\n\n\tif (!shortmess(SHM_SEARCH)\n\t\t&& ((dirc == '/' && LT_POS(pos, curwin->w_cursor))\n\t\t\t    || (dirc == '?' && LT_POS(curwin->w_cursor, pos))))\n\t    show_top_bot_msg = TRUE;\n\n\tif (c == FAIL)\n\t{\n\t    retval = 0;\n\t    goto end_do_search;\n\t}\n\tif (spats[0].off.end && oap != NULL)\n\t    oap->inclusive = TRUE;  // 'e' includes last character\n\n\tretval = 1;\t\t    // pattern found\n\n\t/*\n\t * Add character and/or line offset\n\t */\n\tif (!(options & SEARCH_NOOF) || (pat != NULL && *pat == ';'))\n\t{\n\t    pos_T org_pos = pos;\n\n\t    if (spats[0].off.line)\t// Add the offset to the line number.\n\t    {\n\t\tc = pos.lnum + spats[0].off.off;\n\t\tif (c < 1)\n\t\t    pos.lnum = 1;\n\t\telse if (c > curbuf->b_ml.ml_line_count)\n\t\t    pos.lnum = curbuf->b_ml.ml_line_count;\n\t\telse\n\t\t    pos.lnum = c;\n\t\tpos.col = 0;\n\n\t\tretval = 2;\t    // pattern found, line offset added\n\t    }\n\t    else if (pos.col < MAXCOL - 2)\t// just in case\n\t    {\n\t\t// to the right, check for end of file\n\t\tc = spats[0].off.off;\n\t\tif (c > 0)\n\t\t{\n\t\t    while (c-- > 0)\n\t\t\tif (incl(&pos) == -1)\n\t\t\t    break;\n\t\t}\n\t\t// to the left, check for start of file\n\t\telse\n\t\t{\n\t\t    while (c++ < 0)\n\t\t\tif (decl(&pos) == -1)\n\t\t\t    break;\n\t\t}\n\t    }\n\t    if (!EQUAL_POS(pos, org_pos))\n\t\thas_offset = TRUE;\n\t}\n\n\t// Show [1/15] if 'S' is not in 'shortmess'.\n\tif ((options & SEARCH_ECHO)\n\t\t&& messaging()\n\t\t&& !msg_silent\n\t\t&& c != FAIL\n\t\t&& !shortmess(SHM_SEARCHCOUNT)\n\t\t&& msgbuf != NULL)\n\t     cmdline_search_stat(dirc, &pos, &curwin->w_cursor,\n\t\t\t\tshow_top_bot_msg, msgbuf,\n\t\t\t\t(count != 1 || has_offset\n#ifdef FEAT_FOLDING\n\t\t\t\t || (!(fdo_flags & FDO_SEARCH)\n\t\t\t\t     && hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t\t\t   NULL, NULL))\n#endif\n\t\t\t\t),\n\t\t\t\tSEARCH_STAT_DEF_MAX_COUNT,\n\t\t\t\tSEARCH_STAT_DEF_TIMEOUT);\n\n\t/*\n\t * The search command can be followed by a ';' to do another search.\n\t * For example: \"/pat/;/foo/+3;?bar\"\n\t * This is like doing another search command, except:\n\t * - The remembered direction '/' or '?' is from the first search.\n\t * - When an error happens the cursor isn't moved at all.\n\t * Don't do this when called by get_address() (it handles ';' itself).\n\t */\n\tif (!(options & SEARCH_OPT) || pat == NULL || *pat != ';')\n\t    break;\n\n\tdirc = *++pat;\n\tsearch_delim = dirc;\n\tif (dirc != '?' && dirc != '/')\n\t{\n\t    retval = 0;\n\t    emsg(_(e_expected_question_or_slash_after_semicolon));\n\t    goto end_do_search;\n\t}\n\t++pat;\n    }\n\n    if (options & SEARCH_MARK)\n\tsetpcmark();\n    curwin->w_cursor = pos;\n    curwin->w_set_curswant = TRUE;\n\nend_do_search:\n    if ((options & SEARCH_KEEP) || (cmdmod.cmod_flags & CMOD_KEEPPATTERNS))\n\tspats[0].off = old_off;\n    vim_free(strcopy);\n    vim_free(msgbuf);\n\n    return retval;\n}\n\n/*\n * search_for_exact_line(buf, pos, dir, pat)\n *\n * Search for a line starting with the given pattern (ignoring leading\n * white-space), starting from pos and going in direction \"dir\". \"pos\" will\n * contain the position of the match found.    Blank lines match only if\n * ADDING is set.  If p_ic is set then the pattern must be in lowercase.\n * Return OK for success, or FAIL if no line found.\n */\n    int\nsearch_for_exact_line(\n    buf_T\t*buf,\n    pos_T\t*pos,\n    int\t\tdir,\n    char_u\t*pat)\n{\n    linenr_T\tstart = 0;\n    char_u\t*ptr;\n    char_u\t*p;\n\n    if (buf->b_ml.ml_line_count == 0)\n\treturn FAIL;\n    for (;;)\n    {\n\tpos->lnum += dir;\n\tif (pos->lnum < 1)\n\t{\n\t    if (p_ws)\n\t    {\n\t\tpos->lnum = buf->b_ml.ml_line_count;\n\t\tif (!shortmess(SHM_SEARCH))\n\t\t    give_warning((char_u *)_(top_bot_msg), TRUE);\n\t    }\n\t    else\n\t    {\n\t\tpos->lnum = 1;\n\t\tbreak;\n\t    }\n\t}\n\telse if (pos->lnum > buf->b_ml.ml_line_count)\n\t{\n\t    if (p_ws)\n\t    {\n\t\tpos->lnum = 1;\n\t\tif (!shortmess(SHM_SEARCH))\n\t\t    give_warning((char_u *)_(bot_top_msg), TRUE);\n\t    }\n\t    else\n\t    {\n\t\tpos->lnum = 1;\n\t\tbreak;\n\t    }\n\t}\n\tif (pos->lnum == start)\n\t    break;\n\tif (start == 0)\n\t    start = pos->lnum;\n\tptr = ml_get_buf(buf, pos->lnum, FALSE);\n\tp = skipwhite(ptr);\n\tpos->col = (colnr_T) (p - ptr);\n\n\t// when adding lines the matching line may be empty but it is not\n\t// ignored because we are interested in the next line -- Acevedo\n\tif (compl_status_adding() && !compl_status_sol())\n\t{\n\t    if ((p_ic ? MB_STRICMP(p, pat) : STRCMP(p, pat)) == 0)\n\t\treturn OK;\n\t}\n\telse if (*p != NUL)\t// ignore empty lines\n\t{\t// expanding lines or words\n\t    if ((p_ic ? MB_STRNICMP(p, pat, ins_compl_len())\n\t\t\t\t   : STRNCMP(p, pat, ins_compl_len())) == 0)\n\t\treturn OK;\n\t}\n    }\n    return FAIL;\n}\n\n/*\n * Character Searches\n */\n\n/*\n * Search for a character in a line.  If \"t_cmd\" is FALSE, move to the\n * position of the character, otherwise move to just before the char.\n * Do this \"cap->count1\" times.\n * Return FAIL or OK.\n */\n    int\nsearchc(cmdarg_T *cap, int t_cmd)\n{\n    int\t\t\tc = cap->nchar;\t// char to search for\n    int\t\t\tdir = cap->arg;\t// TRUE for searching forward\n    long\t\tcount = cap->count1;\t// repeat count\n    int\t\t\tcol;\n    char_u\t\t*p;\n    int\t\t\tlen;\n    int\t\t\tstop = TRUE;\n\n    if (c != NUL)\t// normal search: remember args for repeat\n    {\n\tif (!KeyStuffed)    // don't remember when redoing\n\t{\n\t    *lastc = c;\n\t    set_csearch_direction(dir);\n\t    set_csearch_until(t_cmd);\n\t    lastc_bytelen = (*mb_char2bytes)(c, lastc_bytes);\n\t    if (cap->ncharC1 != 0)\n\t    {\n\t\tlastc_bytelen += (*mb_char2bytes)(cap->ncharC1,\n\t\t\tlastc_bytes + lastc_bytelen);\n\t\tif (cap->ncharC2 != 0)\n\t\t    lastc_bytelen += (*mb_char2bytes)(cap->ncharC2,\n\t\t\t    lastc_bytes + lastc_bytelen);\n\t    }\n\t}\n    }\n    else\t\t// repeat previous search\n    {\n\tif (*lastc == NUL && lastc_bytelen == 1)\n\t    return FAIL;\n\tif (dir)\t// repeat in opposite direction\n\t    dir = -lastcdir;\n\telse\n\t    dir = lastcdir;\n\tt_cmd = last_t_cmd;\n\tc = *lastc;\n\t// For multi-byte re-use last lastc_bytes[] and lastc_bytelen.\n\n\t// Force a move of at least one char, so \";\" and \",\" will move the\n\t// cursor, even if the cursor is right in front of char we are looking\n\t// at.\n\tif (vim_strchr(p_cpo, CPO_SCOLON) == NULL && count == 1 && t_cmd)\n\t    stop = FALSE;\n    }\n\n    if (dir == BACKWARD)\n\tcap->oap->inclusive = FALSE;\n    else\n\tcap->oap->inclusive = TRUE;\n\n    p = ml_get_curline();\n    col = curwin->w_cursor.col;\n    len = (int)STRLEN(p);\n\n    while (count--)\n    {\n\tif (has_mbyte)\n\t{\n\t    for (;;)\n\t    {\n\t\tif (dir > 0)\n\t\t{\n\t\t    col += (*mb_ptr2len)(p + col);\n\t\t    if (col >= len)\n\t\t\treturn FAIL;\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (col == 0)\n\t\t\treturn FAIL;\n\t\t    col -= (*mb_head_off)(p, p + col - 1) + 1;\n\t\t}\n\t\tif (lastc_bytelen == 1)\n\t\t{\n\t\t    if (p[col] == c && stop)\n\t\t\tbreak;\n\t\t}\n\t\telse if (STRNCMP(p + col, lastc_bytes, lastc_bytelen) == 0\n\t\t\t\t\t\t\t\t       && stop)\n\t\t    break;\n\t\tstop = TRUE;\n\t    }\n\t}\n\telse\n\t{\n\t    for (;;)\n\t    {\n\t\tif ((col += dir) < 0 || col >= len)\n\t\t    return FAIL;\n\t\tif (p[col] == c && stop)\n\t\t    break;\n\t\tstop = TRUE;\n\t    }\n\t}\n    }\n\n    if (t_cmd)\n    {\n\t// backup to before the character (possibly double-byte)\n\tcol -= dir;\n\tif (has_mbyte)\n\t{\n\t    if (dir < 0)\n\t\t// Landed on the search char which is lastc_bytelen long\n\t\tcol += lastc_bytelen - 1;\n\t    else\n\t\t// To previous char, which may be multi-byte.\n\t\tcol -= (*mb_head_off)(p, p + col);\n\t}\n    }\n    curwin->w_cursor.col = col;\n\n    return OK;\n}\n\n/*\n * \"Other\" Searches\n */\n\n/*\n * findmatch - find the matching paren or brace\n *\n * Improvement over vi: Braces inside quotes are ignored.\n */\n    pos_T *\nfindmatch(oparg_T *oap, int initc)\n{\n    return findmatchlimit(oap, initc, 0, 0);\n}\n\n/*\n * Return TRUE if the character before \"linep[col]\" equals \"ch\".\n * Return FALSE if \"col\" is zero.\n * Update \"*prevcol\" to the column of the previous character, unless \"prevcol\"\n * is NULL.\n * Handles multibyte string correctly.\n */\n    static int\ncheck_prevcol(\n    char_u\t*linep,\n    int\t\tcol,\n    int\t\tch,\n    int\t\t*prevcol)\n{\n    --col;\n    if (col > 0 && has_mbyte)\n\tcol -= (*mb_head_off)(linep, linep + col);\n    if (prevcol)\n\t*prevcol = col;\n    return (col >= 0 && linep[col] == ch) ? TRUE : FALSE;\n}\n\n/*\n * Raw string start is found at linep[startpos.col - 1].\n * Return TRUE if the matching end can be found between startpos and endpos.\n */\n    static int\nfind_rawstring_end(char_u *linep, pos_T *startpos, pos_T *endpos)\n{\n    char_u\t*p;\n    char_u\t*delim_copy;\n    size_t\tdelim_len;\n    linenr_T\tlnum;\n    int\t\tfound = FALSE;\n\n    for (p = linep + startpos->col + 1; *p && *p != '('; ++p)\n\t;\n    delim_len = (p - linep) - startpos->col - 1;\n    delim_copy = vim_strnsave(linep + startpos->col + 1, delim_len);\n    if (delim_copy == NULL)\n\treturn FALSE;\n    for (lnum = startpos->lnum; lnum <= endpos->lnum; ++lnum)\n    {\n\tchar_u *line = ml_get(lnum);\n\n\tfor (p = line + (lnum == startpos->lnum\n\t\t\t\t\t    ? startpos->col + 1 : 0); *p; ++p)\n\t{\n\t    if (lnum == endpos->lnum && (colnr_T)(p - line) >= endpos->col)\n\t\tbreak;\n\t    if (*p == ')' && STRNCMP(delim_copy, p + 1, delim_len) == 0\n\t\t\t  && p[delim_len + 1] == '\"')\n\t    {\n\t\tfound = TRUE;\n\t\tbreak;\n\t    }\n\t}\n\tif (found)\n\t    break;\n    }\n    vim_free(delim_copy);\n    return found;\n}\n\n/*\n * Check matchpairs option for \"*initc\".\n * If there is a match set \"*initc\" to the matching character and \"*findc\" to\n * the opposite character.  Set \"*backwards\" to the direction.\n * When \"switchit\" is TRUE swap the direction.\n */\n    static void\nfind_mps_values(\n    int\t    *initc,\n    int\t    *findc,\n    int\t    *backwards,\n    int\t    switchit)\n{\n    char_u\t*ptr;\n\n    ptr = curbuf->b_p_mps;\n    while (*ptr != NUL)\n    {\n\tif (has_mbyte)\n\t{\n\t    char_u *prev;\n\n\t    if (mb_ptr2char(ptr) == *initc)\n\t    {\n\t\tif (switchit)\n\t\t{\n\t\t    *findc = *initc;\n\t\t    *initc = mb_ptr2char(ptr + mb_ptr2len(ptr) + 1);\n\t\t    *backwards = TRUE;\n\t\t}\n\t\telse\n\t\t{\n\t\t    *findc = mb_ptr2char(ptr + mb_ptr2len(ptr) + 1);\n\t\t    *backwards = FALSE;\n\t\t}\n\t\treturn;\n\t    }\n\t    prev = ptr;\n\t    ptr += mb_ptr2len(ptr) + 1;\n\t    if (mb_ptr2char(ptr) == *initc)\n\t    {\n\t\tif (switchit)\n\t\t{\n\t\t    *findc = *initc;\n\t\t    *initc = mb_ptr2char(prev);\n\t\t    *backwards = FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t    *findc = mb_ptr2char(prev);\n\t\t    *backwards = TRUE;\n\t\t}\n\t\treturn;\n\t    }\n\t    ptr += mb_ptr2len(ptr);\n\t}\n\telse\n\t{\n\t    if (*ptr == *initc)\n\t    {\n\t\tif (switchit)\n\t\t{\n\t\t    *backwards = TRUE;\n\t\t    *findc = *initc;\n\t\t    *initc = ptr[2];\n\t\t}\n\t\telse\n\t\t{\n\t\t    *backwards = FALSE;\n\t\t    *findc = ptr[2];\n\t\t}\n\t\treturn;\n\t    }\n\t    ptr += 2;\n\t    if (*ptr == *initc)\n\t    {\n\t\tif (switchit)\n\t\t{\n\t\t    *backwards = FALSE;\n\t\t    *findc = *initc;\n\t\t    *initc = ptr[-2];\n\t\t}\n\t\telse\n\t\t{\n\t\t    *backwards = TRUE;\n\t\t    *findc =  ptr[-2];\n\t\t}\n\t\treturn;\n\t    }\n\t    ++ptr;\n\t}\n\tif (*ptr == ',')\n\t    ++ptr;\n    }\n}\n\n/*\n * findmatchlimit -- find the matching paren or brace, if it exists within\n * maxtravel lines of the cursor.  A maxtravel of 0 means search until falling\n * off the edge of the file.\n *\n * \"initc\" is the character to find a match for.  NUL means to find the\n * character at or after the cursor. Special values:\n * '*'  look for C-style comment / *\n * '/'  look for C-style comment / *, ignoring comment-end\n * '#'  look for preprocessor directives\n * 'R'  look for raw string start: R\"delim(text)delim\" (only backwards)\n *\n * flags: FM_BACKWARD\tsearch backwards (when initc is '/', '*' or '#')\n *\t  FM_FORWARD\tsearch forwards (when initc is '/', '*' or '#')\n *\t  FM_BLOCKSTOP\tstop at start/end of block ({ or } in column 0)\n *\t  FM_SKIPCOMM\tskip comments (not implemented yet!)\n *\n * \"oap\" is only used to set oap->motion_type for a linewise motion, it can be\n * NULL\n */\n    pos_T *\nfindmatchlimit(\n    oparg_T\t*oap,\n    int\t\tinitc,\n    int\t\tflags,\n    int\t\tmaxtravel)\n{\n    static pos_T pos;\t\t\t// current search position\n    int\t\tfindc = 0;\t\t// matching brace\n    int\t\tc;\n    int\t\tcount = 0;\t\t// cumulative number of braces\n    int\t\tbackwards = FALSE;\t// init for gcc\n    int\t\traw_string = FALSE;\t// search for raw string\n    int\t\tinquote = FALSE;\t// TRUE when inside quotes\n    char_u\t*linep;\t\t\t// pointer to current line\n    char_u\t*ptr;\n    int\t\tdo_quotes;\t\t// check for quotes in current line\n    int\t\tat_start;\t\t// do_quotes value at start position\n    int\t\thash_dir = 0;\t\t// Direction searched for # things\n    int\t\tcomment_dir = 0;\t// Direction searched for comments\n    pos_T\tmatch_pos;\t\t// Where last slash-star was found\n    int\t\tstart_in_quotes;\t// start position is in quotes\n    int\t\ttraveled = 0;\t\t// how far we've searched so far\n    int\t\tignore_cend = FALSE;    // ignore comment end\n    int\t\tcpo_match;\t\t// vi compatible matching\n    int\t\tcpo_bsl;\t\t// don't recognize backslashes\n    int\t\tmatch_escaped = 0;\t// search for escaped match\n    int\t\tdir;\t\t\t// Direction to search\n    int\t\tcomment_col = MAXCOL;   // start of / / comment\n    int\t\tlispcomm = FALSE;\t// inside of Lisp-style comment\n    int\t\tlisp = curbuf->b_p_lisp; // engage Lisp-specific hacks ;)\n\n    pos = curwin->w_cursor;\n    pos.coladd = 0;\n    linep = ml_get(pos.lnum);\n\n    cpo_match = (vim_strchr(p_cpo, CPO_MATCH) != NULL);\n    cpo_bsl = (vim_strchr(p_cpo, CPO_MATCHBSL) != NULL);\n\n    // Direction to search when initc is '/', '*' or '#'\n    if (flags & FM_BACKWARD)\n\tdir = BACKWARD;\n    else if (flags & FM_FORWARD)\n\tdir = FORWARD;\n    else\n\tdir = 0;\n\n    /*\n     * if initc given, look in the table for the matching character\n     * '/' and '*' are special cases: look for start or end of comment.\n     * When '/' is used, we ignore running backwards into an star-slash, for\n     * \"[*\" command, we just want to find any comment.\n     */\n    if (initc == '/' || initc == '*' || initc == 'R')\n    {\n\tcomment_dir = dir;\n\tif (initc == '/')\n\t    ignore_cend = TRUE;\n\tbackwards = (dir == FORWARD) ? FALSE : TRUE;\n\traw_string = (initc == 'R');\n\tinitc = NUL;\n    }\n    else if (initc != '#' && initc != NUL)\n    {\n\tfind_mps_values(&initc, &findc, &backwards, TRUE);\n\tif (dir)\n\t    backwards = (dir == FORWARD) ? FALSE : TRUE;\n\tif (findc == NUL)\n\t    return NULL;\n    }\n    else\n    {\n\t/*\n\t * Either initc is '#', or no initc was given and we need to look\n\t * under the cursor.\n\t */\n\tif (initc == '#')\n\t{\n\t    hash_dir = dir;\n\t}\n\telse\n\t{\n\t    /*\n\t     * initc was not given, must look for something to match under\n\t     * or near the cursor.\n\t     * Only check for special things when 'cpo' doesn't have '%'.\n\t     */\n\t    if (!cpo_match)\n\t    {\n\t\t// Are we before or at #if, #else etc.?\n\t\tptr = skipwhite(linep);\n\t\tif (*ptr == '#' && pos.col <= (colnr_T)(ptr - linep))\n\t\t{\n\t\t    ptr = skipwhite(ptr + 1);\n\t\t    if (   STRNCMP(ptr, \"if\", 2) == 0\n\t\t\t|| STRNCMP(ptr, \"endif\", 5) == 0\n\t\t\t|| STRNCMP(ptr, \"el\", 2) == 0)\n\t\t\thash_dir = 1;\n\t\t}\n\n\t\t// Are we on a comment?\n\t\telse if (linep[pos.col] == '/')\n\t\t{\n\t\t    if (linep[pos.col + 1] == '*')\n\t\t    {\n\t\t\tcomment_dir = FORWARD;\n\t\t\tbackwards = FALSE;\n\t\t\tpos.col++;\n\t\t    }\n\t\t    else if (pos.col > 0 && linep[pos.col - 1] == '*')\n\t\t    {\n\t\t\tcomment_dir = BACKWARD;\n\t\t\tbackwards = TRUE;\n\t\t\tpos.col--;\n\t\t    }\n\t\t}\n\t\telse if (linep[pos.col] == '*')\n\t\t{\n\t\t    if (linep[pos.col + 1] == '/')\n\t\t    {\n\t\t\tcomment_dir = BACKWARD;\n\t\t\tbackwards = TRUE;\n\t\t    }\n\t\t    else if (pos.col > 0 && linep[pos.col - 1] == '/')\n\t\t    {\n\t\t\tcomment_dir = FORWARD;\n\t\t\tbackwards = FALSE;\n\t\t    }\n\t\t}\n\t    }\n\n\t    /*\n\t     * If we are not on a comment or the # at the start of a line, then\n\t     * look for brace anywhere on this line after the cursor.\n\t     */\n\t    if (!hash_dir && !comment_dir)\n\t    {\n\t\t/*\n\t\t * Find the brace under or after the cursor.\n\t\t * If beyond the end of the line, use the last character in\n\t\t * the line.\n\t\t */\n\t\tif (linep[pos.col] == NUL && pos.col)\n\t\t    --pos.col;\n\t\tfor (;;)\n\t\t{\n\t\t    initc = PTR2CHAR(linep + pos.col);\n\t\t    if (initc == NUL)\n\t\t\tbreak;\n\n\t\t    find_mps_values(&initc, &findc, &backwards, FALSE);\n\t\t    if (findc)\n\t\t\tbreak;\n\t\t    pos.col += mb_ptr2len(linep + pos.col);\n\t\t}\n\t\tif (!findc)\n\t\t{\n\t\t    // no brace in the line, maybe use \"  #if\" then\n\t\t    if (!cpo_match && *skipwhite(linep) == '#')\n\t\t\thash_dir = 1;\n\t\t    else\n\t\t\treturn NULL;\n\t\t}\n\t\telse if (!cpo_bsl)\n\t\t{\n\t\t    int col, bslcnt = 0;\n\n\t\t    // Set \"match_escaped\" if there are an odd number of\n\t\t    // backslashes.\n\t\t    for (col = pos.col; check_prevcol(linep, col, '\\\\', &col);)\n\t\t\tbslcnt++;\n\t\t    match_escaped = (bslcnt & 1);\n\t\t}\n\t    }\n\t}\n\tif (hash_dir)\n\t{\n\t    /*\n\t     * Look for matching #if, #else, #elif, or #endif\n\t     */\n\t    if (oap != NULL)\n\t\toap->motion_type = MLINE;   // Linewise for this case only\n\t    if (initc != '#')\n\t    {\n\t\tptr = skipwhite(skipwhite(linep) + 1);\n\t\tif (STRNCMP(ptr, \"if\", 2) == 0 || STRNCMP(ptr, \"el\", 2) == 0)\n\t\t    hash_dir = 1;\n\t\telse if (STRNCMP(ptr, \"endif\", 5) == 0)\n\t\t    hash_dir = -1;\n\t\telse\n\t\t    return NULL;\n\t    }\n\t    pos.col = 0;\n\t    while (!got_int)\n\t    {\n\t\tif (hash_dir > 0)\n\t\t{\n\t\t    if (pos.lnum == curbuf->b_ml.ml_line_count)\n\t\t\tbreak;\n\t\t}\n\t\telse if (pos.lnum == 1)\n\t\t    break;\n\t\tpos.lnum += hash_dir;\n\t\tlinep = ml_get(pos.lnum);\n\t\tline_breakcheck();\t// check for CTRL-C typed\n\t\tptr = skipwhite(linep);\n\t\tif (*ptr != '#')\n\t\t    continue;\n\t\tpos.col = (colnr_T) (ptr - linep);\n\t\tptr = skipwhite(ptr + 1);\n\t\tif (hash_dir > 0)\n\t\t{\n\t\t    if (STRNCMP(ptr, \"if\", 2) == 0)\n\t\t\tcount++;\n\t\t    else if (STRNCMP(ptr, \"el\", 2) == 0)\n\t\t    {\n\t\t\tif (count == 0)\n\t\t\t    return &pos;\n\t\t    }\n\t\t    else if (STRNCMP(ptr, \"endif\", 5) == 0)\n\t\t    {\n\t\t\tif (count == 0)\n\t\t\t    return &pos;\n\t\t\tcount--;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (STRNCMP(ptr, \"if\", 2) == 0)\n\t\t    {\n\t\t\tif (count == 0)\n\t\t\t    return &pos;\n\t\t\tcount--;\n\t\t    }\n\t\t    else if (initc == '#' && STRNCMP(ptr, \"el\", 2) == 0)\n\t\t    {\n\t\t\tif (count == 0)\n\t\t\t    return &pos;\n\t\t    }\n\t\t    else if (STRNCMP(ptr, \"endif\", 5) == 0)\n\t\t\tcount++;\n\t\t}\n\t    }\n\t    return NULL;\n\t}\n    }\n\n#ifdef FEAT_RIGHTLEFT\n    // This is just guessing: when 'rightleft' is set, search for a matching\n    // paren/brace in the other direction.\n    if (curwin->w_p_rl && vim_strchr((char_u *)\"()[]{}<>\", initc) != NULL)\n\tbackwards = !backwards;\n#endif\n\n    do_quotes = -1;\n    start_in_quotes = MAYBE;\n    CLEAR_POS(&match_pos);\n\n    // backward search: Check if this line contains a single-line comment\n    if ((backwards && comment_dir) || lisp)\n\tcomment_col = check_linecomment(linep);\n    if (lisp && comment_col != MAXCOL && pos.col > (colnr_T)comment_col)\n\tlispcomm = TRUE;    // find match inside this comment\n\n    while (!got_int)\n    {\n\t/*\n\t * Go to the next position, forward or backward. We could use\n\t * inc() and dec() here, but that is much slower\n\t */\n\tif (backwards)\n\t{\n\t    // char to match is inside of comment, don't search outside\n\t    if (lispcomm && pos.col < (colnr_T)comment_col)\n\t\tbreak;\n\t    if (pos.col == 0)\t\t// at start of line, go to prev. one\n\t    {\n\t\tif (pos.lnum == 1)\t// start of file\n\t\t    break;\n\t\t--pos.lnum;\n\n\t\tif (maxtravel > 0 && ++traveled > maxtravel)\n\t\t    break;\n\n\t\tlinep = ml_get(pos.lnum);\n\t\tpos.col = (colnr_T)STRLEN(linep); // pos.col on trailing NUL\n\t\tdo_quotes = -1;\n\t\tline_breakcheck();\n\n\t\t// Check if this line contains a single-line comment\n\t\tif (comment_dir || lisp)\n\t\t    comment_col = check_linecomment(linep);\n\t\t// skip comment\n\t\tif (lisp && comment_col != MAXCOL)\n\t\t    pos.col = comment_col;\n\t    }\n\t    else\n\t    {\n\t\t--pos.col;\n\t\tif (has_mbyte)\n\t\t    pos.col -= (*mb_head_off)(linep, linep + pos.col);\n\t    }\n\t}\n\telse\t\t\t\t// forward search\n\t{\n\t    if (linep[pos.col] == NUL\n\t\t    // at end of line, go to next one\n\t\t    // For lisp don't search for match in comment\n\t\t    || (lisp && comment_col != MAXCOL\n\t\t\t\t\t   && pos.col == (colnr_T)comment_col))\n\t    {\n\t\tif (pos.lnum == curbuf->b_ml.ml_line_count  // end of file\n\t\t\t// line is exhausted and comment with it,\n\t\t\t// don't search for match in code\n\t\t\t || lispcomm)\n\t\t    break;\n\t\t++pos.lnum;\n\n\t\tif (maxtravel && traveled++ > maxtravel)\n\t\t    break;\n\n\t\tlinep = ml_get(pos.lnum);\n\t\tpos.col = 0;\n\t\tdo_quotes = -1;\n\t\tline_breakcheck();\n\t\tif (lisp)   // find comment pos in new line\n\t\t    comment_col = check_linecomment(linep);\n\t    }\n\t    else\n\t    {\n\t\tif (has_mbyte)\n\t\t    pos.col += (*mb_ptr2len)(linep + pos.col);\n\t\telse\n\t\t    ++pos.col;\n\t    }\n\t}\n\n\t/*\n\t * If FM_BLOCKSTOP given, stop at a '{' or '}' in column 0.\n\t */\n\tif (pos.col == 0 && (flags & FM_BLOCKSTOP)\n\t\t\t\t       && (linep[0] == '{' || linep[0] == '}'))\n\t{\n\t    if (linep[0] == findc && count == 0)\t// match!\n\t\treturn &pos;\n\t    break;\t\t\t\t\t// out of scope\n\t}\n\n\tif (comment_dir)\n\t{\n\t    // Note: comments do not nest, and we ignore quotes in them\n\t    // TODO: ignore comment brackets inside strings\n\t    if (comment_dir == FORWARD)\n\t    {\n\t\tif (linep[pos.col] == '*' && linep[pos.col + 1] == '/')\n\t\t{\n\t\t    pos.col++;\n\t\t    return &pos;\n\t\t}\n\t    }\n\t    else    // Searching backwards\n\t    {\n\t\t/*\n\t\t * A comment may contain / * or / /, it may also start or end\n\t\t * with / * /.\tIgnore a / * after / / and after *.\n\t\t */\n\t\tif (pos.col == 0)\n\t\t    continue;\n\t\telse if (raw_string)\n\t\t{\n\t\t    if (linep[pos.col - 1] == 'R'\n\t\t\t&& linep[pos.col] == '\"'\n\t\t\t&& vim_strchr(linep + pos.col + 1, '(') != NULL)\n\t\t    {\n\t\t\t// Possible start of raw string. Now that we have the\n\t\t\t// delimiter we can check if it ends before where we\n\t\t\t// started searching, or before the previously found\n\t\t\t// raw string start.\n\t\t\tif (!find_rawstring_end(linep, &pos,\n\t\t\t\t  count > 0 ? &match_pos : &curwin->w_cursor))\n\t\t\t{\n\t\t\t    count++;\n\t\t\t    match_pos = pos;\n\t\t\t    match_pos.col--;\n\t\t\t}\n\t\t\tlinep = ml_get(pos.lnum); // may have been released\n\t\t    }\n\t\t}\n\t\telse if (  linep[pos.col - 1] == '/'\n\t\t\t&& linep[pos.col] == '*'\n\t\t\t&& (pos.col == 1 || linep[pos.col - 2] != '*')\n\t\t\t&& (int)pos.col < comment_col)\n\t\t{\n\t\t    count++;\n\t\t    match_pos = pos;\n\t\t    match_pos.col--;\n\t\t}\n\t\telse if (linep[pos.col - 1] == '*' && linep[pos.col] == '/')\n\t\t{\n\t\t    if (count > 0)\n\t\t\tpos = match_pos;\n\t\t    else if (pos.col > 1 && linep[pos.col - 2] == '/'\n\t\t\t\t\t       && (int)pos.col <= comment_col)\n\t\t\tpos.col -= 2;\n\t\t    else if (ignore_cend)\n\t\t\tcontinue;\n\t\t    else\n\t\t\treturn NULL;\n\t\t    return &pos;\n\t\t}\n\t    }\n\t    continue;\n\t}\n\n\t/*\n\t * If smart matching ('cpoptions' does not contain '%'), braces inside\n\t * of quotes are ignored, but only if there is an even number of\n\t * quotes in the line.\n\t */\n\tif (cpo_match)\n\t    do_quotes = 0;\n\telse if (do_quotes == -1)\n\t{\n\t    /*\n\t     * Count the number of quotes in the line, skipping \\\" and '\"'.\n\t     * Watch out for \"\\\\\".\n\t     */\n\t    at_start = do_quotes;\n\t    for (ptr = linep; *ptr; ++ptr)\n\t    {\n\t\tif (ptr == linep + pos.col + backwards)\n\t\t    at_start = (do_quotes & 1);\n\t\tif (*ptr == '\"'\n\t\t\t&& (ptr == linep || ptr[-1] != '\\'' || ptr[1] != '\\''))\n\t\t    ++do_quotes;\n\t\tif (*ptr == '\\\\' && ptr[1] != NUL)\n\t\t    ++ptr;\n\t    }\n\t    do_quotes &= 1;\t    // result is 1 with even number of quotes\n\n\t    /*\n\t     * If we find an uneven count, check current line and previous\n\t     * one for a '\\' at the end.\n\t     */\n\t    if (!do_quotes)\n\t    {\n\t\tinquote = FALSE;\n\t\tif (ptr[-1] == '\\\\')\n\t\t{\n\t\t    do_quotes = 1;\n\t\t    if (start_in_quotes == MAYBE)\n\t\t    {\n\t\t\t// Do we need to use at_start here?\n\t\t\tinquote = TRUE;\n\t\t\tstart_in_quotes = TRUE;\n\t\t    }\n\t\t    else if (backwards)\n\t\t\tinquote = TRUE;\n\t\t}\n\t\tif (pos.lnum > 1)\n\t\t{\n\t\t    ptr = ml_get(pos.lnum - 1);\n\t\t    if (*ptr && *(ptr + STRLEN(ptr) - 1) == '\\\\')\n\t\t    {\n\t\t\tdo_quotes = 1;\n\t\t\tif (start_in_quotes == MAYBE)\n\t\t\t{\n\t\t\t    inquote = at_start;\n\t\t\t    if (inquote)\n\t\t\t\tstart_in_quotes = TRUE;\n\t\t\t}\n\t\t\telse if (!backwards)\n\t\t\t    inquote = TRUE;\n\t\t    }\n\n\t\t    // ml_get() only keeps one line, need to get linep again\n\t\t    linep = ml_get(pos.lnum);\n\t\t}\n\t    }\n\t}\n\tif (start_in_quotes == MAYBE)\n\t    start_in_quotes = FALSE;\n\n\t/*\n\t * If 'smartmatch' is set:\n\t *   Things inside quotes are ignored by setting 'inquote'.  If we\n\t *   find a quote without a preceding '\\' invert 'inquote'.  At the\n\t *   end of a line not ending in '\\' we reset 'inquote'.\n\t *\n\t *   In lines with an uneven number of quotes (without preceding '\\')\n\t *   we do not know which part to ignore. Therefore we only set\n\t *   inquote if the number of quotes in a line is even, unless this\n\t *   line or the previous one ends in a '\\'.  Complicated, isn't it?\n\t */\n\tc = PTR2CHAR(linep + pos.col);\n\tswitch (c)\n\t{\n\tcase NUL:\n\t    // at end of line without trailing backslash, reset inquote\n\t    if (pos.col == 0 || linep[pos.col - 1] != '\\\\')\n\t    {\n\t\tinquote = FALSE;\n\t\tstart_in_quotes = FALSE;\n\t    }\n\t    break;\n\n\tcase '\"':\n\t    // a quote that is preceded with an odd number of backslashes is\n\t    // ignored\n\t    if (do_quotes)\n\t    {\n\t\tint col;\n\n\t\tfor (col = pos.col - 1; col >= 0; --col)\n\t\t    if (linep[col] != '\\\\')\n\t\t\tbreak;\n\t\tif ((((int)pos.col - 1 - col) & 1) == 0)\n\t\t{\n\t\t    inquote = !inquote;\n\t\t    start_in_quotes = FALSE;\n\t\t}\n\t    }\n\t    break;\n\n\t/*\n\t * If smart matching ('cpoptions' does not contain '%'):\n\t *   Skip things in single quotes: 'x' or '\\x'.  Be careful for single\n\t *   single quotes, eg jon's.  Things like '\\233' or '\\x3f' are not\n\t *   skipped, there is never a brace in them.\n\t *   Ignore this when finding matches for `'.\n\t */\n\tcase '\\'':\n\t    if (!cpo_match && initc != '\\'' && findc != '\\'')\n\t    {\n\t\tif (backwards)\n\t\t{\n\t\t    if (pos.col > 1)\n\t\t    {\n\t\t\tif (linep[pos.col - 2] == '\\'')\n\t\t\t{\n\t\t\t    pos.col -= 2;\n\t\t\t    break;\n\t\t\t}\n\t\t\telse if (linep[pos.col - 2] == '\\\\'\n\t\t\t\t  && pos.col > 2 && linep[pos.col - 3] == '\\'')\n\t\t\t{\n\t\t\t    pos.col -= 3;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse if (linep[pos.col + 1])\t// forward search\n\t\t{\n\t\t    if (linep[pos.col + 1] == '\\\\'\n\t\t\t   && linep[pos.col + 2] && linep[pos.col + 3] == '\\'')\n\t\t    {\n\t\t\tpos.col += 3;\n\t\t\tbreak;\n\t\t    }\n\t\t    else if (linep[pos.col + 2] == '\\'')\n\t\t    {\n\t\t\tpos.col += 2;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    // FALLTHROUGH\n\n\tdefault:\n\t    /*\n\t     * For Lisp skip over backslashed (), {} and [].\n\t     * (actually, we skip #\\( et al)\n\t     */\n\t    if (curbuf->b_p_lisp\n\t\t    && vim_strchr((char_u *)\"{}()[]\", c) != NULL\n\t\t    && pos.col > 1\n\t\t    && check_prevcol(linep, pos.col, '\\\\', NULL)\n\t\t    && check_prevcol(linep, pos.col - 1, '#', NULL))\n\t\tbreak;\n\n\t    // Check for match outside of quotes, and inside of\n\t    // quotes when the start is also inside of quotes.\n\t    if ((!inquote || start_in_quotes == TRUE)\n\t\t    && (c == initc || c == findc))\n\t    {\n\t\tint\tcol, bslcnt = 0;\n\n\t\tif (!cpo_bsl)\n\t\t{\n\t\t    for (col = pos.col; check_prevcol(linep, col, '\\\\', &col);)\n\t\t\tbslcnt++;\n\t\t}\n\t\t// Only accept a match when 'M' is in 'cpo' or when escaping\n\t\t// is what we expect.\n\t\tif (cpo_bsl || (bslcnt & 1) == match_escaped)\n\t\t{\n\t\t    if (c == initc)\n\t\t\tcount++;\n\t\t    else\n\t\t    {\n\t\t\tif (count == 0)\n\t\t\t    return &pos;\n\t\t\tcount--;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n    if (comment_dir == BACKWARD && count > 0)\n    {\n\tpos = match_pos;\n\treturn &pos;\n    }\n    return (pos_T *)NULL;\t// never found it\n}\n\n/*\n * Check if line[] contains a / / comment.\n * Return MAXCOL if not, otherwise return the column.\n */\n    int\ncheck_linecomment(char_u *line)\n{\n    char_u  *p;\n\n    p = line;\n    // skip Lispish one-line comments\n    if (curbuf->b_p_lisp)\n    {\n\tif (vim_strchr(p, ';') != NULL) // there may be comments\n\t{\n\t    int in_str = FALSE;\t// inside of string\n\n\t    p = line;\t\t// scan from start\n\t    while ((p = vim_strpbrk(p, (char_u *)\"\\\";\")) != NULL)\n\t    {\n\t\tif (*p == '\"')\n\t\t{\n\t\t    if (in_str)\n\t\t    {\n\t\t\tif (*(p - 1) != '\\\\') // skip escaped quote\n\t\t\t    in_str = FALSE;\n\t\t    }\n\t\t    else if (p == line || ((p - line) >= 2\n\t\t\t\t      // skip #\\\" form\n\t\t\t\t      && *(p - 1) != '\\\\' && *(p - 2) != '#'))\n\t\t\tin_str = TRUE;\n\t\t}\n\t\telse if (!in_str && ((p - line) < 2\n\t\t\t\t    || (*(p - 1) != '\\\\' && *(p - 2) != '#'))\n\t\t\t       && !is_pos_in_string(line, (colnr_T)(p - line)))\n\t\t    break;\t// found!\n\t\t++p;\n\t    }\n\t}\n\telse\n\t    p = NULL;\n    }\n    else\n\twhile ((p = vim_strchr(p, '/')) != NULL)\n\t{\n\t    // Accept a double /, unless it's preceded with * and followed by\n\t    // *, because * / / * is an end and start of a C comment.  Only\n\t    // accept the position if it is not inside a string.\n\t    if (p[1] == '/' && (p == line || p[-1] != '*' || p[2] != '*')\n\t\t\t       && !is_pos_in_string(line, (colnr_T)(p - line)))\n\t\tbreak;\n\t    ++p;\n\t}\n\n    if (p == NULL)\n\treturn MAXCOL;\n    return (int)(p - line);\n}\n\n/*\n * Move cursor briefly to character matching the one under the cursor.\n * Used for Insert mode and \"r\" command.\n * Show the match only if it is visible on the screen.\n * If there isn't a match, then beep.\n */\n    void\nshowmatch(\n    int\t\tc)\t    // char to show match for\n{\n    pos_T\t*lpos, save_cursor;\n    pos_T\tmpos;\n    colnr_T\tvcol;\n    long\tsave_so;\n    long\tsave_siso;\n#ifdef CURSOR_SHAPE\n    int\t\tsave_state;\n#endif\n    colnr_T\tsave_dollar_vcol;\n    char_u\t*p;\n    long\t*so = curwin->w_p_so >= 0 ? &curwin->w_p_so : &p_so;\n    long\t*siso = curwin->w_p_siso >= 0 ? &curwin->w_p_siso : &p_siso;\n\n    /*\n     * Only show match for chars in the 'matchpairs' option.\n     */\n    // 'matchpairs' is \"x:y,x:y\"\n    for (p = curbuf->b_p_mps; *p != NUL; ++p)\n    {\n#ifdef FEAT_RIGHTLEFT\n\tif (PTR2CHAR(p) == c && (curwin->w_p_rl ^ p_ri))\n\t    break;\n#endif\n\tp += mb_ptr2len(p) + 1;\n\tif (PTR2CHAR(p) == c\n#ifdef FEAT_RIGHTLEFT\n\t\t&& !(curwin->w_p_rl ^ p_ri)\n#endif\n\t   )\n\t    break;\n\tp += mb_ptr2len(p);\n\tif (*p == NUL)\n\t    return;\n    }\n    if (*p == NUL)\n\treturn;\n\n    if ((lpos = findmatch(NULL, NUL)) == NULL)\t    // no match, so beep\n    {\n\tvim_beep(BO_MATCH);\n\treturn;\n    }\n\n    if (lpos->lnum < curwin->w_topline || lpos->lnum >= curwin->w_botline)\n\treturn;\n\n    if (!curwin->w_p_wrap)\n\tgetvcol(curwin, lpos, NULL, &vcol, NULL);\n\n    int col_visible = (curwin->w_p_wrap\n\t    || (vcol >= curwin->w_leftcol\n\t\t&& vcol < curwin->w_leftcol + curwin->w_width));\n    if (!col_visible)\n\treturn;\n\n    mpos = *lpos;    // save the pos, update_screen() may change it\n    save_cursor = curwin->w_cursor;\n    save_so = *so;\n    save_siso = *siso;\n    // Handle \"$\" in 'cpo': If the ')' is typed on top of the \"$\",\n    // stop displaying the \"$\".\n    if (dollar_vcol >= 0 && dollar_vcol == curwin->w_virtcol)\n\tdollar_vcol = -1;\n    ++curwin->w_virtcol;\t// do display ')' just before \"$\"\n    update_screen(UPD_VALID);\t// show the new char first\n\n    save_dollar_vcol = dollar_vcol;\n#ifdef CURSOR_SHAPE\n    save_state = State;\n    State = MODE_SHOWMATCH;\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n    curwin->w_cursor = mpos;\t// move to matching char\n    *so = 0;\t\t\t// don't use 'scrolloff' here\n    *siso = 0;\t\t\t// don't use 'sidescrolloff' here\n    showruler(FALSE);\n    setcursor();\n    cursor_on();\t\t// make sure that the cursor is shown\n    out_flush_cursor(TRUE, FALSE);\n\n    // Restore dollar_vcol(), because setcursor() may call curs_rows()\n    // which resets it if the matching position is in a previous line\n    // and has a higher column number.\n    dollar_vcol = save_dollar_vcol;\n\n    /*\n     * brief pause, unless 'm' is present in 'cpo' and a character is\n     * available.\n     */\n    if (vim_strchr(p_cpo, CPO_SHOWMATCH) != NULL)\n\tui_delay(p_mat * 100L + 8, TRUE);\n    else if (!char_avail())\n\tui_delay(p_mat * 100L + 9, FALSE);\n    curwin->w_cursor = save_cursor;\t// restore cursor position\n    *so = save_so;\n    *siso = save_siso;\n#ifdef CURSOR_SHAPE\n    State = save_state;\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n}\n\n/*\n * Check if the pattern is zero-width.\n * If move is TRUE, check from the beginning of the buffer, else from position\n * \"cur\".\n * \"direction\" is FORWARD or BACKWARD.\n * Returns TRUE, FALSE or -1 for failure.\n */\n    static int\nis_zero_width(char_u *pattern, int move, pos_T *cur, int direction)\n{\n    regmmatch_T\tregmatch;\n    int\t\tnmatched = 0;\n    int\t\tresult = -1;\n    pos_T\tpos;\n    int\t\tcalled_emsg_before = called_emsg;\n    int\t\tflag = 0;\n\n    if (pattern == NULL)\n\tpattern = spats[last_idx].pat;\n\n    if (search_regcomp(pattern, NULL, RE_SEARCH, RE_SEARCH,\n\t\t\t\t\t      SEARCH_KEEP, &regmatch) == FAIL)\n\treturn -1;\n\n    // init startcol correctly\n    regmatch.startpos[0].col = -1;\n    // move to match\n    if (move)\n    {\n\tCLEAR_POS(&pos);\n    }\n    else\n    {\n\tpos = *cur;\n\t// accept a match at the cursor position\n\tflag = SEARCH_START;\n    }\n\n    if (searchit(curwin, curbuf, &pos, NULL, direction, pattern, 1,\n\t\t\t\t  SEARCH_KEEP + flag, RE_SEARCH, NULL) != FAIL)\n    {\n\t// Zero-width pattern should match somewhere, then we can check if\n\t// start and end are in the same position.\n\tdo\n\t{\n\t    regmatch.startpos[0].col++;\n\t    nmatched = vim_regexec_multi(&regmatch, curwin, curbuf,\n\t\t\t       pos.lnum, regmatch.startpos[0].col, NULL);\n\t    if (nmatched != 0)\n\t\tbreak;\n\t} while (regmatch.regprog != NULL\n\t\t&& direction == FORWARD ? regmatch.startpos[0].col < pos.col\n\t\t\t\t      : regmatch.startpos[0].col > pos.col);\n\n\tif (called_emsg == called_emsg_before)\n\t{\n\t    result = (nmatched != 0\n\t\t&& regmatch.startpos[0].lnum == regmatch.endpos[0].lnum\n\t\t&& regmatch.startpos[0].col == regmatch.endpos[0].col);\n\t}\n    }\n\n    vim_regfree(regmatch.regprog);\n    return result;\n}\n\n\n/*\n * Find next search match under cursor, cursor at end.\n * Used while an operator is pending, and in Visual mode.\n */\n    int\ncurrent_search(\n    long\tcount,\n    int\t\tforward)\t// TRUE for forward, FALSE for backward\n{\n    pos_T\tstart_pos;\t// start position of the pattern match\n    pos_T\tend_pos;\t// end position of the pattern match\n    pos_T\torig_pos;\t// position of the cursor at beginning\n    pos_T\tpos;\t\t// position after the pattern\n    int\t\ti;\n    int\t\tdir;\n    int\t\tresult;\t\t// result of various function calls\n    char_u\told_p_ws = p_ws;\n    int\t\tflags = 0;\n    pos_T\tsave_VIsual = VIsual;\n    int\t\tzero_width;\n    int\t\tskip_first_backward;\n\n    // Correct cursor when 'selection' is exclusive\n    if (VIsual_active && *p_sel == 'e' && LT_POS(VIsual, curwin->w_cursor))\n\tdec_cursor();\n\n    // When searching forward and the cursor is at the start of the Visual\n    // area, skip the first search backward, otherwise it doesn't move.\n    skip_first_backward = forward && VIsual_active\n\t\t\t\t\t   && LT_POS(curwin->w_cursor, VIsual);\n\n    orig_pos = pos = curwin->w_cursor;\n    if (VIsual_active)\n    {\n\tif (forward)\n\t    incl(&pos);\n\telse\n\t    decl(&pos);\n    }\n\n    // Is the pattern is zero-width?, this time, don't care about the direction\n    zero_width = is_zero_width(spats[last_idx].pat, TRUE, &curwin->w_cursor,\n\t\t\t\t\t\t\t\t      FORWARD);\n    if (zero_width == -1)\n\treturn FAIL;  // pattern not found\n\n    /*\n     * The trick is to first search backwards and then search forward again,\n     * so that a match at the current cursor position will be correctly\n     * captured.  When \"forward\" is false do it the other way around.\n     */\n    for (i = 0; i < 2; i++)\n    {\n\tif (forward)\n\t{\n\t    if (i == 0 && skip_first_backward)\n\t\tcontinue;\n\t    dir = i;\n\t}\n\telse\n\t    dir = !i;\n\n\tflags = 0;\n\tif (!dir && !zero_width)\n\t    flags = SEARCH_END;\n\tend_pos = pos;\n\n\t// wrapping should not occur in the first round\n\tif (i == 0)\n\t    p_ws = FALSE;\n\n\tresult = searchit(curwin, curbuf, &pos, &end_pos,\n\t\t(dir ? FORWARD : BACKWARD),\n\t\tspats[last_idx].pat, (long) (i ? count : 1),\n\t\tSEARCH_KEEP | flags, RE_SEARCH, NULL);\n\n\tp_ws = old_p_ws;\n\n\t// First search may fail, but then start searching from the\n\t// beginning of the file (cursor might be on the search match)\n\t// except when Visual mode is active, so that extending the visual\n\t// selection works.\n\tif (i == 1 && !result) // not found, abort\n\t{\n\t    curwin->w_cursor = orig_pos;\n\t    if (VIsual_active)\n\t\tVIsual = save_VIsual;\n\t    return FAIL;\n\t}\n\telse if (i == 0 && !result)\n\t{\n\t    if (forward)\n\t    {\n\t\t// try again from start of buffer\n\t\tCLEAR_POS(&pos);\n\t    }\n\t    else\n\t    {\n\t\t// try again from end of buffer\n\t\t// searching backwards, so set pos to last line and col\n\t\tpos.lnum = curwin->w_buffer->b_ml.ml_line_count;\n\t\tpos.col  = (colnr_T)STRLEN(\n\t\t\t\tml_get(curwin->w_buffer->b_ml.ml_line_count));\n\t    }\n\t}\n    }\n\n    start_pos = pos;\n\n    if (!VIsual_active)\n\tVIsual = start_pos;\n\n    // put the cursor after the match\n    curwin->w_cursor = end_pos;\n    if (LT_POS(VIsual, end_pos) && forward)\n    {\n\tif (skip_first_backward)\n\t    // put the cursor on the start of the match\n\t    curwin->w_cursor = pos;\n\telse\n\t    // put the cursor on last character of match\n\t    dec_cursor();\n    }\n    else if (VIsual_active && LT_POS(curwin->w_cursor, VIsual) && forward)\n\tcurwin->w_cursor = pos;   // put the cursor on the start of the match\n    VIsual_active = TRUE;\n    VIsual_mode = 'v';\n\n    if (*p_sel == 'e')\n    {\n\t// Correction for exclusive selection depends on the direction.\n\tif (forward && LTOREQ_POS(VIsual, curwin->w_cursor))\n\t    inc_cursor();\n\telse if (!forward && LTOREQ_POS(curwin->w_cursor, VIsual))\n\t    inc(&VIsual);\n    }\n\n#ifdef FEAT_FOLDING\n    if (fdo_flags & FDO_SEARCH && KeyTyped)\n\tfoldOpenCursor();\n#endif\n\n    may_start_select('c');\n    setmouse();\n#ifdef FEAT_CLIPBOARD\n    // Make sure the clipboard gets updated.  Needed because start and\n    // end are still the same, and the selection needs to be owned\n    clip_star.vmode = NUL;\n#endif\n    redraw_curbuf_later(UPD_INVERTED);\n    showmode();\n\n    return OK;\n}\n\n/*\n * return TRUE if line 'lnum' is empty or has white chars only.\n */\n    int\nlinewhite(linenr_T lnum)\n{\n    char_u  *p;\n\n    p = skipwhite(ml_get(lnum));\n    return (*p == NUL);\n}\n\n/*\n * Add the search count \"[3/19]\" to \"msgbuf\".\n * See update_search_stat() for other arguments.\n */\n    static void\ncmdline_search_stat(\n    int\t\tdirc,\n    pos_T\t*pos,\n    pos_T\t*cursor_pos,\n    int\t\tshow_top_bot_msg,\n    char_u\t*msgbuf,\n    int\t\trecompute,\n    int\t\tmaxcount,\n    long\ttimeout)\n{\n    searchstat_T stat;\n\n    update_search_stat(dirc, pos, cursor_pos, &stat, recompute, maxcount,\n\t\t\t\t\t\t\t\t      timeout);\n    if (stat.cur <= 0)\n\treturn;\n\n    char\tt[SEARCH_STAT_BUF_LEN];\n    size_t\tlen;\n\n#ifdef FEAT_RIGHTLEFT\n    if (curwin->w_p_rl && *curwin->w_p_rlc == 's')\n    {\n\tif (stat.incomplete == 1)\n\t    vim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[?/??]\");\n\telse if (stat.cnt > maxcount && stat.cur > maxcount)\n\t    vim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[>%d/>%d]\",\n\t\t    maxcount, maxcount);\n\telse if (stat.cnt > maxcount)\n\t    vim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[>%d/%d]\",\n\t\t    maxcount, stat.cur);\n\telse\n\t    vim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[%d/%d]\",\n\t\t    stat.cnt, stat.cur);\n    }\n    else\n#endif\n    {\n\tif (stat.incomplete == 1)\n\t    vim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[?/??]\");\n\telse if (stat.cnt > maxcount && stat.cur > maxcount)\n\t    vim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[>%d/>%d]\",\n\t\t    maxcount, maxcount);\n\telse if (stat.cnt > maxcount)\n\t    vim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[%d/>%d]\",\n\t\t    stat.cur, maxcount);\n\telse\n\t    vim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[%d/%d]\",\n\t\t    stat.cur, stat.cnt);\n    }\n\n    len = STRLEN(t);\n    if (show_top_bot_msg && len + 2 < SEARCH_STAT_BUF_LEN)\n    {\n\tmch_memmove(t + 2, t, len);\n\tt[0] = 'W';\n\tt[1] = ' ';\n\tlen += 2;\n    }\n\n    size_t msgbuf_len = STRLEN(msgbuf);\n    if (len > msgbuf_len)\n\tlen = msgbuf_len;\n    mch_memmove(msgbuf + msgbuf_len - len, t, len);\n\n    if (dirc == '?' && stat.cur == maxcount + 1)\n\tstat.cur = -1;\n\n    // keep the message even after redraw, but don't put in history\n    msg_hist_off = TRUE;\n    give_warning(msgbuf, FALSE);\n    msg_hist_off = FALSE;\n}\n\n/*\n * Add the search count information to \"stat\".\n * \"stat\" must not be NULL.\n * When \"recompute\" is TRUE always recompute the numbers.\n * dirc == 0: don't find the next/previous match (only set the result to \"stat\")\n * dirc == '/': find the next match\n * dirc == '?': find the previous match\n */\n    static void\nupdate_search_stat(\n    int\t\t\tdirc,\n    pos_T\t\t*pos,\n    pos_T\t\t*cursor_pos,\n    searchstat_T\t*stat,\n    int\t\t\trecompute,\n    int\t\t\tmaxcount,\n    long\t\ttimeout UNUSED)\n{\n    int\t\t    save_ws = p_ws;\n    int\t\t    wraparound = FALSE;\n    pos_T\t    p = (*pos);\n    static pos_T    lastpos = {0, 0, 0};\n    static int\t    cur = 0;\n    static int\t    cnt = 0;\n    static int\t    exact_match = FALSE;\n    static int\t    incomplete = 0;\n    static int\t    last_maxcount = SEARCH_STAT_DEF_MAX_COUNT;\n    static int\t    chgtick = 0;\n    static char_u   *lastpat = NULL;\n    static buf_T    *lbuf = NULL;\n#ifdef FEAT_RELTIME\n    proftime_T  start;\n#endif\n\n    CLEAR_POINTER(stat);\n\n    if (dirc == 0 && !recompute && !EMPTY_POS(lastpos))\n    {\n\tstat->cur = cur;\n\tstat->cnt = cnt;\n\tstat->exact_match = exact_match;\n\tstat->incomplete = incomplete;\n\tstat->last_maxcount = last_maxcount;\n\treturn;\n    }\n    last_maxcount = maxcount;\n\n    wraparound = ((dirc == '?' && LT_POS(lastpos, p))\n\t       || (dirc == '/' && LT_POS(p, lastpos)));\n\n    // If anything relevant changed the count has to be recomputed.\n    // MB_STRNICMP ignores case, but we should not ignore case.\n    // Unfortunately, there is no MB_STRNICMP function.\n    // XXX: above comment should be \"no MB_STRCMP function\" ?\n    if (!(chgtick == CHANGEDTICK(curbuf)\n\t&& MB_STRNICMP(lastpat, spats[last_idx].pat, STRLEN(lastpat)) == 0\n\t&& STRLEN(lastpat) == STRLEN(spats[last_idx].pat)\n\t&& EQUAL_POS(lastpos, *cursor_pos)\n\t&& lbuf == curbuf) || wraparound || cur < 0\n\t    || (maxcount > 0 && cur > maxcount) || recompute)\n    {\n\tcur = 0;\n\tcnt = 0;\n\texact_match = FALSE;\n\tincomplete = 0;\n\tCLEAR_POS(&lastpos);\n\tlbuf = curbuf;\n    }\n\n    if (EQUAL_POS(lastpos, *cursor_pos) && !wraparound\n\t\t&& (dirc == 0 || dirc == '/' ? cur < cnt : cur > 0))\n\tcur += dirc == 0 ? 0 : dirc == '/' ? 1 : -1;\n    else\n    {\n\tint\tdone_search = FALSE;\n\tpos_T\tendpos = {0, 0, 0};\n\n\tp_ws = FALSE;\n#ifdef FEAT_RELTIME\n\tif (timeout > 0)\n\t    profile_setlimit(timeout, &start);\n#endif\n\twhile (!got_int && searchit(curwin, curbuf, &lastpos, &endpos,\n\t\t\t FORWARD, NULL, 1, SEARCH_KEEP, RE_LAST, NULL) != FAIL)\n\t{\n\t    done_search = TRUE;\n#ifdef FEAT_RELTIME\n\t    // Stop after passing the time limit.\n\t    if (timeout > 0 && profile_passed_limit(&start))\n\t    {\n\t\tincomplete = 1;\n\t\tbreak;\n\t    }\n#endif\n\t    cnt++;\n\t    if (LTOREQ_POS(lastpos, p))\n\t    {\n\t\tcur = cnt;\n\t\tif (LT_POS(p, endpos))\n\t\t    exact_match = TRUE;\n\t    }\n\t    fast_breakcheck();\n\t    if (maxcount > 0 && cnt > maxcount)\n\t    {\n\t\tincomplete = 2;    // max count exceeded\n\t\tbreak;\n\t    }\n\t}\n\tif (got_int)\n\t    cur = -1; // abort\n\tif (done_search)\n\t{\n\t    vim_free(lastpat);\n\t    lastpat = vim_strsave(spats[last_idx].pat);\n\t    chgtick = CHANGEDTICK(curbuf);\n\t    lbuf = curbuf;\n\t    lastpos = p;\n\t}\n    }\n    stat->cur = cur;\n    stat->cnt = cnt;\n    stat->exact_match = exact_match;\n    stat->incomplete = incomplete;\n    stat->last_maxcount = last_maxcount;\n    p_ws = save_ws;\n}\n\n#if defined(FEAT_FIND_ID) || defined(PROTO)\n\n/*\n * Get line \"lnum\" and copy it into \"buf[LSIZE]\".\n * The copy is made because the regexp may make the line invalid when using a\n * mark.\n */\n    static char_u *\nget_line_and_copy(linenr_T lnum, char_u *buf)\n{\n    char_u *line = ml_get(lnum);\n\n    vim_strncpy(buf, line, LSIZE - 1);\n    return buf;\n}\n\n/*\n * Find identifiers or defines in included files.\n * If p_ic && compl_status_sol() then ptr must be in lowercase.\n */\n    void\nfind_pattern_in_path(\n    char_u\t*ptr,\t\t// pointer to search pattern\n    int\t\tdir UNUSED,\t// direction of expansion\n    int\t\tlen,\t\t// length of search pattern\n    int\t\twhole,\t\t// match whole words only\n    int\t\tskip_comments,\t// don't match inside comments\n    int\t\ttype,\t\t// Type of search; are we looking for a type?\n\t\t\t\t// a macro?\n    long\tcount,\n    int\t\taction,\t\t// What to do when we find it\n    linenr_T\tstart_lnum,\t// first line to start searching\n    linenr_T\tend_lnum)\t// last line for searching\n{\n    SearchedFile *files;\t\t// Stack of included files\n    SearchedFile *bigger;\t\t// When we need more space\n    int\t\tmax_path_depth = 50;\n    long\tmatch_count = 1;\n\n    char_u\t*pat;\n    char_u\t*new_fname;\n    char_u\t*curr_fname = curbuf->b_fname;\n    char_u\t*prev_fname = NULL;\n    linenr_T\tlnum;\n    int\t\tdepth;\n    int\t\tdepth_displayed;\t// For type==CHECK_PATH\n    int\t\told_files;\n    int\t\talready_searched;\n    char_u\t*file_line;\n    char_u\t*line;\n    char_u\t*p;\n    char_u\tsave_char;\n    int\t\tdefine_matched;\n    regmatch_T\tregmatch;\n    regmatch_T\tincl_regmatch;\n    regmatch_T\tdef_regmatch;\n    int\t\tmatched = FALSE;\n    int\t\tdid_show = FALSE;\n    int\t\tfound = FALSE;\n    int\t\ti;\n    char_u\t*already = NULL;\n    char_u\t*startp = NULL;\n    char_u\t*inc_opt = NULL;\n#if defined(FEAT_QUICKFIX)\n    win_T\t*curwin_save = NULL;\n#endif\n\n    regmatch.regprog = NULL;\n    incl_regmatch.regprog = NULL;\n    def_regmatch.regprog = NULL;\n\n    file_line = alloc(LSIZE);\n    if (file_line == NULL)\n\treturn;\n\n    if (type != CHECK_PATH && type != FIND_DEFINE\n\t    // when CONT_SOL is set compare \"ptr\" with the beginning of the\n\t    // line is faster than quote_meta/regcomp/regexec \"ptr\" -- Acevedo\n\t    && !compl_status_sol())\n    {\n\tpat = alloc(len + 5);\n\tif (pat == NULL)\n\t    goto fpip_end;\n\tsprintf((char *)pat, whole ? \"\\\\<%.*s\\\\>\" : \"%.*s\", len, ptr);\n\t// ignore case according to p_ic, p_scs and pat\n\tregmatch.rm_ic = ignorecase(pat);\n\tregmatch.regprog = vim_regcomp(pat, magic_isset() ? RE_MAGIC : 0);\n\tvim_free(pat);\n\tif (regmatch.regprog == NULL)\n\t    goto fpip_end;\n    }\n    inc_opt = (*curbuf->b_p_inc == NUL) ? p_inc : curbuf->b_p_inc;\n    if (*inc_opt != NUL)\n    {\n\tincl_regmatch.regprog = vim_regcomp(inc_opt,\n\t\t\t\t\t\t magic_isset() ? RE_MAGIC : 0);\n\tif (incl_regmatch.regprog == NULL)\n\t    goto fpip_end;\n\tincl_regmatch.rm_ic = FALSE;\t// don't ignore case in incl. pat.\n    }\n    if (type == FIND_DEFINE && (*curbuf->b_p_def != NUL || *p_def != NUL))\n    {\n\tdef_regmatch.regprog = vim_regcomp(*curbuf->b_p_def == NUL\n\t\t\t   ? p_def : curbuf->b_p_def,\n\t\t\t\t\t\t magic_isset() ? RE_MAGIC : 0);\n\tif (def_regmatch.regprog == NULL)\n\t    goto fpip_end;\n\tdef_regmatch.rm_ic = FALSE;\t// don't ignore case in define pat.\n    }\n    files = lalloc_clear(max_path_depth * sizeof(SearchedFile), TRUE);\n    if (files == NULL)\n\tgoto fpip_end;\n    old_files = max_path_depth;\n    depth = depth_displayed = -1;\n\n    lnum = start_lnum;\n    if (end_lnum > curbuf->b_ml.ml_line_count)\n\tend_lnum = curbuf->b_ml.ml_line_count;\n    if (lnum > end_lnum)\t\t// do at least one line\n\tlnum = end_lnum;\n    line = get_line_and_copy(lnum, file_line);\n\n    for (;;)\n    {\n\tif (incl_regmatch.regprog != NULL\n\t\t&& vim_regexec(&incl_regmatch, line, (colnr_T)0))\n\t{\n\t    char_u *p_fname = (curr_fname == curbuf->b_fname)\n\t\t\t\t\t      ? curbuf->b_ffname : curr_fname;\n\n\t    if (inc_opt != NULL && strstr((char *)inc_opt, \"\\\\zs\") != NULL)\n\t\t// Use text from '\\zs' to '\\ze' (or end) of 'include'.\n\t\tnew_fname = find_file_name_in_path(incl_regmatch.startp[0],\n\t\t       (int)(incl_regmatch.endp[0] - incl_regmatch.startp[0]),\n\t\t\t\t FNAME_EXP|FNAME_INCL|FNAME_REL, 1L, p_fname);\n\t    else\n\t\t// Use text after match with 'include'.\n\t\tnew_fname = file_name_in_line(incl_regmatch.endp[0], 0,\n\t\t\t     FNAME_EXP|FNAME_INCL|FNAME_REL, 1L, p_fname, NULL);\n\t    already_searched = FALSE;\n\t    if (new_fname != NULL)\n\t    {\n\t\t// Check whether we have already searched in this file\n\t\tfor (i = 0;; i++)\n\t\t{\n\t\t    if (i == depth + 1)\n\t\t\ti = old_files;\n\t\t    if (i == max_path_depth)\n\t\t\tbreak;\n\t\t    if (fullpathcmp(new_fname, files[i].name, TRUE, TRUE)\n\t\t\t\t\t\t\t\t    & FPC_SAME)\n\t\t    {\n\t\t\tif (type != CHECK_PATH\n\t\t\t\t&& action == ACTION_SHOW_ALL\n\t\t\t\t&& files[i].matched)\n\t\t\t{\n\t\t\t    msg_putchar('\\n');\t    // cursor below last one\n\t\t\t    if (!got_int)\t    // don't display if 'q'\n\t\t\t\t\t\t    // typed at \"--more--\"\n\t\t\t\t\t\t    // message\n\t\t\t    {\n\t\t\t\tmsg_home_replace_hl(new_fname);\n\t\t\t\tmsg_puts(_(\" (includes previously listed match)\"));\n\t\t\t\tprev_fname = NULL;\n\t\t\t    }\n\t\t\t}\n\t\t\tVIM_CLEAR(new_fname);\n\t\t\talready_searched = TRUE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if (type == CHECK_PATH && (action == ACTION_SHOW_ALL\n\t\t\t\t || (new_fname == NULL && !already_searched)))\n\t    {\n\t\tif (did_show)\n\t\t    msg_putchar('\\n');\t    // cursor below last one\n\t\telse\n\t\t{\n\t\t    gotocmdline(TRUE);\t    // cursor at status line\n\t\t    msg_puts_title(_(\"--- Included files \"));\n\t\t    if (action != ACTION_SHOW_ALL)\n\t\t\tmsg_puts_title(_(\"not found \"));\n\t\t    msg_puts_title(_(\"in path ---\\n\"));\n\t\t}\n\t\tdid_show = TRUE;\n\t\twhile (depth_displayed < depth && !got_int)\n\t\t{\n\t\t    ++depth_displayed;\n\t\t    for (i = 0; i < depth_displayed; i++)\n\t\t\tmsg_puts(\"  \");\n\t\t    msg_home_replace(files[depth_displayed].name);\n\t\t    msg_puts(\" -->\\n\");\n\t\t}\n\t\tif (!got_int)\t\t    // don't display if 'q' typed\n\t\t\t\t\t    // for \"--more--\" message\n\t\t{\n\t\t    for (i = 0; i <= depth_displayed; i++)\n\t\t\tmsg_puts(\"  \");\n\t\t    if (new_fname != NULL)\n\t\t    {\n\t\t\t// using \"new_fname\" is more reliable, e.g., when\n\t\t\t// 'includeexpr' is set.\n\t\t\tmsg_outtrans_attr(new_fname, HL_ATTR(HLF_D));\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t/*\n\t\t\t * Isolate the file name.\n\t\t\t * Include the surrounding \"\" or <> if present.\n\t\t\t */\n\t\t\tif (inc_opt != NULL\n\t\t\t\t   && strstr((char *)inc_opt, \"\\\\zs\") != NULL)\n\t\t\t{\n\t\t\t    // pattern contains \\zs, use the match\n\t\t\t    p = incl_regmatch.startp[0];\n\t\t\t    i = (int)(incl_regmatch.endp[0]\n\t\t\t\t\t\t   - incl_regmatch.startp[0]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // find the file name after the end of the match\n\t\t\t    for (p = incl_regmatch.endp[0];\n\t\t\t\t\t\t  *p && !vim_isfilec(*p); p++)\n\t\t\t\t;\n\t\t\t    for (i = 0; vim_isfilec(p[i]); i++)\n\t\t\t\t;\n\t\t\t}\n\n\t\t\tif (i == 0)\n\t\t\t{\n\t\t\t    // Nothing found, use the rest of the line.\n\t\t\t    p = incl_regmatch.endp[0];\n\t\t\t    i = (int)STRLEN(p);\n\t\t\t}\n\t\t\t// Avoid checking before the start of the line, can\n\t\t\t// happen if \\zs appears in the regexp.\n\t\t\telse if (p > line)\n\t\t\t{\n\t\t\t    if (p[-1] == '\"' || p[-1] == '<')\n\t\t\t    {\n\t\t\t\t--p;\n\t\t\t\t++i;\n\t\t\t    }\n\t\t\t    if (p[i] == '\"' || p[i] == '>')\n\t\t\t\t++i;\n\t\t\t}\n\t\t\tsave_char = p[i];\n\t\t\tp[i] = NUL;\n\t\t\tmsg_outtrans_attr(p, HL_ATTR(HLF_D));\n\t\t\tp[i] = save_char;\n\t\t    }\n\n\t\t    if (new_fname == NULL && action == ACTION_SHOW_ALL)\n\t\t    {\n\t\t\tif (already_searched)\n\t\t\t    msg_puts(_(\"  (Already listed)\"));\n\t\t\telse\n\t\t\t    msg_puts(_(\"  NOT FOUND\"));\n\t\t    }\n\t\t}\n\t\tout_flush();\t    // output each line directly\n\t    }\n\n\t    if (new_fname != NULL)\n\t    {\n\t\t// Push the new file onto the file stack\n\t\tif (depth + 1 == old_files)\n\t\t{\n\t\t    bigger = ALLOC_MULT(SearchedFile, max_path_depth * 2);\n\t\t    if (bigger != NULL)\n\t\t    {\n\t\t\tfor (i = 0; i <= depth; i++)\n\t\t\t    bigger[i] = files[i];\n\t\t\tfor (i = depth + 1; i < old_files + max_path_depth; i++)\n\t\t\t{\n\t\t\t    bigger[i].fp = NULL;\n\t\t\t    bigger[i].name = NULL;\n\t\t\t    bigger[i].lnum = 0;\n\t\t\t    bigger[i].matched = FALSE;\n\t\t\t}\n\t\t\tfor (i = old_files; i < max_path_depth; i++)\n\t\t\t    bigger[i + max_path_depth] = files[i];\n\t\t\told_files += max_path_depth;\n\t\t\tmax_path_depth *= 2;\n\t\t\tvim_free(files);\n\t\t\tfiles = bigger;\n\t\t    }\n\t\t}\n\t\tif ((files[depth + 1].fp = mch_fopen((char *)new_fname, \"r\"))\n\t\t\t\t\t\t\t\t    == NULL)\n\t\t    vim_free(new_fname);\n\t\telse\n\t\t{\n\t\t    if (++depth == old_files)\n\t\t    {\n\t\t\t/*\n\t\t\t * lalloc() for 'bigger' must have failed above.  We\n\t\t\t * will forget one of our already visited files now.\n\t\t\t */\n\t\t\tvim_free(files[old_files].name);\n\t\t\t++old_files;\n\t\t    }\n\t\t    files[depth].name = curr_fname = new_fname;\n\t\t    files[depth].lnum = 0;\n\t\t    files[depth].matched = FALSE;\n\t\t    if (action == ACTION_EXPAND)\n\t\t    {\n\t\t\tmsg_hist_off = TRUE;\t// reset in msg_trunc_attr()\n\t\t\tvim_snprintf((char*)IObuff, IOSIZE,\n\t\t\t\t_(\"Scanning included file: %s\"),\n\t\t\t\t(char *)new_fname);\n\t\t\tmsg_trunc_attr((char *)IObuff, TRUE, HL_ATTR(HLF_R));\n\t\t    }\n\t\t    else if (p_verbose >= 5)\n\t\t    {\n\t\t\tverbose_enter();\n\t\t\tsmsg(_(\"Searching included file %s\"),\n\t\t\t\t\t\t\t   (char *)new_fname);\n\t\t\tverbose_leave();\n\t\t    }\n\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    /*\n\t     * Check if the line is a define (type == FIND_DEFINE)\n\t     */\n\t    p = line;\nsearch_line:\n\t    define_matched = FALSE;\n\t    if (def_regmatch.regprog != NULL\n\t\t\t      && vim_regexec(&def_regmatch, line, (colnr_T)0))\n\t    {\n\t\t/*\n\t\t * Pattern must be first identifier after 'define', so skip\n\t\t * to that position before checking for match of pattern.  Also\n\t\t * don't let it match beyond the end of this identifier.\n\t\t */\n\t\tp = def_regmatch.endp[0];\n\t\twhile (*p && !vim_iswordc(*p))\n\t\t    p++;\n\t\tdefine_matched = TRUE;\n\t    }\n\n\t    /*\n\t     * Look for a match.  Don't do this if we are looking for a\n\t     * define and this line didn't match define_prog above.\n\t     */\n\t    if (def_regmatch.regprog == NULL || define_matched)\n\t    {\n\t\tif (define_matched || compl_status_sol())\n\t\t{\n\t\t    // compare the first \"len\" chars from \"ptr\"\n\t\t    startp = skipwhite(p);\n\t\t    if (p_ic)\n\t\t\tmatched = !MB_STRNICMP(startp, ptr, len);\n\t\t    else\n\t\t\tmatched = !STRNCMP(startp, ptr, len);\n\t\t    if (matched && define_matched && whole\n\t\t\t\t\t\t  && vim_iswordc(startp[len]))\n\t\t\tmatched = FALSE;\n\t\t}\n\t\telse if (regmatch.regprog != NULL\n\t\t\t && vim_regexec(&regmatch, line, (colnr_T)(p - line)))\n\t\t{\n\t\t    matched = TRUE;\n\t\t    startp = regmatch.startp[0];\n\t\t    /*\n\t\t     * Check if the line is not a comment line (unless we are\n\t\t     * looking for a define).  A line starting with \"# define\"\n\t\t     * is not considered to be a comment line.\n\t\t     */\n\t\t    if (!define_matched && skip_comments)\n\t\t    {\n\t\t\tif ((*line != '#' ||\n\t\t\t\tSTRNCMP(skipwhite(line + 1), \"define\", 6) != 0)\n\t\t\t\t&& get_leader_len(line, NULL, FALSE, TRUE))\n\t\t\t    matched = FALSE;\n\n\t\t\t/*\n\t\t\t * Also check for a \"/ *\" or \"/ /\" before the match.\n\t\t\t * Skips lines like \"int backwards;  / * normal index\n\t\t\t * * /\" when looking for \"normal\".\n\t\t\t * Note: Doesn't skip \"/ *\" in comments.\n\t\t\t */\n\t\t\tp = skipwhite(line);\n\t\t\tif (matched\n\t\t\t\t|| (p[0] == '/' && p[1] == '*') || p[0] == '*')\n\t\t\t    for (p = line; *p && p < startp; ++p)\n\t\t\t    {\n\t\t\t\tif (matched\n\t\t\t\t\t&& p[0] == '/'\n\t\t\t\t\t&& (p[1] == '*' || p[1] == '/'))\n\t\t\t\t{\n\t\t\t\t    matched = FALSE;\n\t\t\t\t    // After \"//\" all text is comment\n\t\t\t\t    if (p[1] == '/')\n\t\t\t\t\tbreak;\n\t\t\t\t    ++p;\n\t\t\t\t}\n\t\t\t\telse if (!matched && p[0] == '*' && p[1] == '/')\n\t\t\t\t{\n\t\t\t\t    // Can find match after \"* /\".\n\t\t\t\t    matched = TRUE;\n\t\t\t\t    ++p;\n\t\t\t\t}\n\t\t\t    }\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif (matched)\n\t{\n\t    if (action == ACTION_EXPAND)\n\t    {\n\t\tint\tcont_s_ipos = FALSE;\n\t\tint\tadd_r;\n\t\tchar_u\t*aux;\n\n\t\tif (depth == -1 && lnum == curwin->w_cursor.lnum)\n\t\t    break;\n\t\tfound = TRUE;\n\t\taux = p = startp;\n\t\tif (compl_status_adding())\n\t\t{\n\t\t    p += ins_compl_len();\n\t\t    if (vim_iswordp(p))\n\t\t\tgoto exit_matched;\n\t\t    p = find_word_start(p);\n\t\t}\n\t\tp = find_word_end(p);\n\t\ti = (int)(p - aux);\n\n\t\tif (compl_status_adding() && i == ins_compl_len())\n\t\t{\n\t\t    // IOSIZE > compl_length, so the STRNCPY works\n\t\t    STRNCPY(IObuff, aux, i);\n\n\t\t    // Get the next line: when \"depth\" < 0  from the current\n\t\t    // buffer, otherwise from the included file.  Jump to\n\t\t    // exit_matched when past the last line.\n\t\t    if (depth < 0)\n\t\t    {\n\t\t\tif (lnum >= end_lnum)\n\t\t\t    goto exit_matched;\n\t\t\tline = get_line_and_copy(++lnum, file_line);\n\t\t    }\n\t\t    else if (vim_fgets(line = file_line,\n\t\t\t\t\t\t      LSIZE, files[depth].fp))\n\t\t\tgoto exit_matched;\n\n\t\t    // we read a line, set \"already\" to check this \"line\" later\n\t\t    // if depth >= 0 we'll increase files[depth].lnum far\n\t\t    // below  -- Acevedo\n\t\t    already = aux = p = skipwhite(line);\n\t\t    p = find_word_start(p);\n\t\t    p = find_word_end(p);\n\t\t    if (p > aux)\n\t\t    {\n\t\t\tif (*aux != ')' && IObuff[i-1] != TAB)\n\t\t\t{\n\t\t\t    if (IObuff[i-1] != ' ')\n\t\t\t\tIObuff[i++] = ' ';\n\t\t\t    // IObuf =~ \"\\(\\k\\|\\i\\).* \", thus i >= 2\n\t\t\t    if (p_js\n\t\t\t\t&& (IObuff[i-2] == '.'\n\t\t\t\t    || (vim_strchr(p_cpo, CPO_JOINSP) == NULL\n\t\t\t\t\t&& (IObuff[i-2] == '?'\n\t\t\t\t\t    || IObuff[i-2] == '!'))))\n\t\t\t\tIObuff[i++] = ' ';\n\t\t\t}\n\t\t\t// copy as much as possible of the new word\n\t\t\tif (p - aux >= IOSIZE - i)\n\t\t\t    p = aux + IOSIZE - i - 1;\n\t\t\tSTRNCPY(IObuff + i, aux, p - aux);\n\t\t\ti += (int)(p - aux);\n\t\t\tcont_s_ipos = TRUE;\n\t\t    }\n\t\t    IObuff[i] = NUL;\n\t\t    aux = IObuff;\n\n\t\t    if (i == ins_compl_len())\n\t\t\tgoto exit_matched;\n\t\t}\n\n\t\tadd_r = ins_compl_add_infercase(aux, i, p_ic,\n\t\t\tcurr_fname == curbuf->b_fname ? NULL : curr_fname,\n\t\t\tdir, cont_s_ipos);\n\t\tif (add_r == OK)\n\t\t    // if dir was BACKWARD then honor it just once\n\t\t    dir = FORWARD;\n\t\telse if (add_r == FAIL)\n\t\t    break;\n\t    }\n\t    else if (action == ACTION_SHOW_ALL)\n\t    {\n\t\tfound = TRUE;\n\t\tif (!did_show)\n\t\t    gotocmdline(TRUE);\t\t// cursor at status line\n\t\tif (curr_fname != prev_fname)\n\t\t{\n\t\t    if (did_show)\n\t\t\tmsg_putchar('\\n');\t// cursor below last one\n\t\t    if (!got_int)\t\t// don't display if 'q' typed\n\t\t\t\t\t\t// at \"--more--\" message\n\t\t\tmsg_home_replace_hl(curr_fname);\n\t\t    prev_fname = curr_fname;\n\t\t}\n\t\tdid_show = TRUE;\n\t\tif (!got_int)\n\t\t    show_pat_in_path(line, type, TRUE, action,\n\t\t\t    (depth == -1) ? NULL : files[depth].fp,\n\t\t\t    (depth == -1) ? &lnum : &files[depth].lnum,\n\t\t\t    match_count++);\n\n\t\t// Set matched flag for this file and all the ones that\n\t\t// include it\n\t\tfor (i = 0; i <= depth; ++i)\n\t\t    files[i].matched = TRUE;\n\t    }\n\t    else if (--count <= 0)\n\t    {\n\t\tfound = TRUE;\n\t\tif (depth == -1 && lnum == curwin->w_cursor.lnum\n#if defined(FEAT_QUICKFIX)\n\t\t\t\t\t\t      && g_do_tagpreview == 0\n#endif\n\t\t\t\t\t\t      )\n\t\t    emsg(_(e_match_is_on_current_line));\n\t\telse if (action == ACTION_SHOW)\n\t\t{\n\t\t    show_pat_in_path(line, type, did_show, action,\n\t\t\t(depth == -1) ? NULL : files[depth].fp,\n\t\t\t(depth == -1) ? &lnum : &files[depth].lnum, 1L);\n\t\t    did_show = TRUE;\n\t\t}\n\t\telse\n\t\t{\n#ifdef FEAT_GUI\n\t\t    need_mouse_correct = TRUE;\n#endif\n#if defined(FEAT_QUICKFIX)\n\t\t    // \":psearch\" uses the preview window\n\t\t    if (g_do_tagpreview != 0)\n\t\t    {\n\t\t\tcurwin_save = curwin;\n\t\t\tprepare_tagpreview(TRUE, TRUE, FALSE);\n\t\t    }\n#endif\n\t\t    if (action == ACTION_SPLIT)\n\t\t    {\n\t\t\tif (win_split(0, 0) == FAIL)\n\t\t\t    break;\n\t\t\tRESET_BINDING(curwin);\n\t\t    }\n\t\t    if (depth == -1)\n\t\t    {\n\t\t\t// match in current file\n#if defined(FEAT_QUICKFIX)\n\t\t\tif (g_do_tagpreview != 0)\n\t\t\t{\n\t\t\t    if (!win_valid(curwin_save))\n\t\t\t\tbreak;\n\t\t\t    if (!GETFILE_SUCCESS(getfile(\n\t\t\t\t\t   curwin_save->w_buffer->b_fnum, NULL,\n\t\t\t\t\t\t     NULL, TRUE, lnum, FALSE)))\n\t\t\t\tbreak;\t// failed to jump to file\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t    setpcmark();\n\t\t\tcurwin->w_cursor.lnum = lnum;\n\t\t\tcheck_cursor();\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (!GETFILE_SUCCESS(getfile(\n\t\t\t\t\t0, files[depth].name, NULL, TRUE,\n\t\t\t\t\t\t    files[depth].lnum, FALSE)))\n\t\t\t    break;\t// failed to jump to file\n\t\t\t// autocommands may have changed the lnum, we don't\n\t\t\t// want that here\n\t\t\tcurwin->w_cursor.lnum = files[depth].lnum;\n\t\t    }\n\t\t}\n\t\tif (action != ACTION_SHOW)\n\t\t{\n\t\t    curwin->w_cursor.col = (colnr_T)(startp - line);\n\t\t    curwin->w_set_curswant = TRUE;\n\t\t}\n\n#if defined(FEAT_QUICKFIX)\n\t\tif (g_do_tagpreview != 0\n\t\t\t   && curwin != curwin_save && win_valid(curwin_save))\n\t\t{\n\t\t    // Return cursor to where we were\n\t\t    validate_cursor();\n\t\t    redraw_later(UPD_VALID);\n\t\t    win_enter(curwin_save, TRUE);\n\t\t}\n# ifdef FEAT_PROP_POPUP\n\t\telse if (WIN_IS_POPUP(curwin))\n\t\t    // can't keep focus in popup window\n\t\t    win_enter(firstwin, TRUE);\n# endif\n#endif\n\t\tbreak;\n\t    }\nexit_matched:\n\t    matched = FALSE;\n\t    // look for other matches in the rest of the line if we\n\t    // are not at the end of it already\n\t    if (def_regmatch.regprog == NULL\n\t\t    && action == ACTION_EXPAND\n\t\t    && !compl_status_sol()\n\t\t    && *startp != NUL\n\t\t    && *(p = startp + mb_ptr2len(startp)) != NUL)\n\t\tgoto search_line;\n\t}\n\tline_breakcheck();\n\tif (action == ACTION_EXPAND)\n\t    ins_compl_check_keys(30, FALSE);\n\tif (got_int || ins_compl_interrupted())\n\t    break;\n\n\t/*\n\t * Read the next line.  When reading an included file and encountering\n\t * end-of-file, close the file and continue in the file that included\n\t * it.\n\t */\n\twhile (depth >= 0 && !already\n\t\t&& vim_fgets(line = file_line, LSIZE, files[depth].fp))\n\t{\n\t    fclose(files[depth].fp);\n\t    --old_files;\n\t    files[old_files].name = files[depth].name;\n\t    files[old_files].matched = files[depth].matched;\n\t    --depth;\n\t    curr_fname = (depth == -1) ? curbuf->b_fname\n\t\t\t\t       : files[depth].name;\n\t    if (depth < depth_displayed)\n\t\tdepth_displayed = depth;\n\t}\n\tif (depth >= 0)\t\t// we could read the line\n\t{\n\t    files[depth].lnum++;\n\t    // Remove any CR and LF from the line.\n\t    i = (int)STRLEN(line);\n\t    if (i > 0 && line[i - 1] == '\\n')\n\t\tline[--i] = NUL;\n\t    if (i > 0 && line[i - 1] == '\\r')\n\t\tline[--i] = NUL;\n\t}\n\telse if (!already)\n\t{\n\t    if (++lnum > end_lnum)\n\t\tbreak;\n\t    line = get_line_and_copy(lnum, file_line);\n\t}\n\talready = NULL;\n    }\n    // End of big for (;;) loop.\n\n    // Close any files that are still open.\n    for (i = 0; i <= depth; i++)\n    {\n\tfclose(files[i].fp);\n\tvim_free(files[i].name);\n    }\n    for (i = old_files; i < max_path_depth; i++)\n\tvim_free(files[i].name);\n    vim_free(files);\n\n    if (type == CHECK_PATH)\n    {\n\tif (!did_show)\n\t{\n\t    if (action != ACTION_SHOW_ALL)\n\t\tmsg(_(\"All included files were found\"));\n\t    else\n\t\tmsg(_(\"No included files\"));\n\t}\n    }\n    else if (!found && action != ACTION_EXPAND)\n    {\n\tif (got_int || ins_compl_interrupted())\n\t    emsg(_(e_interrupted));\n\telse if (type == FIND_DEFINE)\n\t    emsg(_(e_couldnt_find_definition));\n\telse\n\t    emsg(_(e_couldnt_find_pattern));\n    }\n    if (action == ACTION_SHOW || action == ACTION_SHOW_ALL)\n\tmsg_end();\n\nfpip_end:\n    vim_free(file_line);\n    vim_regfree(regmatch.regprog);\n    vim_regfree(incl_regmatch.regprog);\n    vim_regfree(def_regmatch.regprog);\n}\n\n    static void\nshow_pat_in_path(\n    char_u  *line,\n    int\t    type,\n    int\t    did_show,\n    int\t    action,\n    FILE    *fp,\n    linenr_T *lnum,\n    long    count)\n{\n    char_u  *p;\n\n    if (did_show)\n\tmsg_putchar('\\n');\t// cursor below last one\n    else if (!msg_silent)\n\tgotocmdline(TRUE);\t// cursor at status line\n    if (got_int)\t\t// 'q' typed at \"--more--\" message\n\treturn;\n    for (;;)\n    {\n\tp = line + STRLEN(line) - 1;\n\tif (fp != NULL)\n\t{\n\t    // We used fgets(), so get rid of newline at end\n\t    if (p >= line && *p == '\\n')\n\t\t--p;\n\t    if (p >= line && *p == '\\r')\n\t\t--p;\n\t    *(p + 1) = NUL;\n\t}\n\tif (action == ACTION_SHOW_ALL)\n\t{\n\t    sprintf((char *)IObuff, \"%3ld: \", count);\t// show match nr\n\t    msg_puts((char *)IObuff);\n\t    sprintf((char *)IObuff, \"%4ld\", *lnum);\t// show line nr\n\t\t\t\t\t\t// Highlight line numbers\n\t    msg_puts_attr((char *)IObuff, HL_ATTR(HLF_N));\n\t    msg_puts(\" \");\n\t}\n\tmsg_prt_line(line, FALSE);\n\tout_flush();\t\t\t// show one line at a time\n\n\t// Definition continues until line that doesn't end with '\\'\n\tif (got_int || type != FIND_DEFINE || p < line || *p != '\\\\')\n\t    break;\n\n\tif (fp != NULL)\n\t{\n\t    if (vim_fgets(line, LSIZE, fp)) // end of file\n\t\tbreak;\n\t    ++*lnum;\n\t}\n\telse\n\t{\n\t    if (++*lnum > curbuf->b_ml.ml_line_count)\n\t\tbreak;\n\t    line = ml_get(*lnum);\n\t}\n\tmsg_putchar('\\n');\n    }\n}\n#endif\n\n#ifdef FEAT_VIMINFO\n/*\n * Return the last used search pattern at \"idx\".\n */\n    spat_T *\nget_spat(int idx)\n{\n    return &spats[idx];\n}\n\n/*\n * Return the last used search pattern index.\n */\n    int\nget_spat_last_idx(void)\n{\n    return last_idx;\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(FEAT_PROTO)\n/*\n * \"searchcount()\" function\n */\n    void\nf_searchcount(typval_T *argvars, typval_T *rettv)\n{\n    pos_T\t\tpos = curwin->w_cursor;\n    char_u\t\t*pattern = NULL;\n    int\t\t\tmaxcount = SEARCH_STAT_DEF_MAX_COUNT;\n    long\t\ttimeout = SEARCH_STAT_DEF_TIMEOUT;\n    int\t\t\trecompute = TRUE;\n    searchstat_T\tstat;\n\n    if (rettv_dict_alloc(rettv) == FAIL)\n\treturn;\n\n    if (in_vim9script() && check_for_opt_dict_arg(argvars, 0) == FAIL)\n\treturn;\n\n    if (shortmess(SHM_SEARCHCOUNT))\t// 'shortmess' contains 'S' flag\n\trecompute = TRUE;\n\n    if (argvars[0].v_type != VAR_UNKNOWN)\n    {\n\tdict_T\t\t*dict;\n\tdictitem_T\t*di;\n\tlistitem_T\t*li;\n\tint\t\terror = FALSE;\n\n\tif (check_for_nonnull_dict_arg(argvars, 0) == FAIL)\n\t    return;\n\tdict = argvars[0].vval.v_dict;\n\tdi = dict_find(dict, (char_u *)\"timeout\", -1);\n\tif (di != NULL)\n\t{\n\t    timeout = (long)tv_get_number_chk(&di->di_tv, &error);\n\t    if (error)\n\t\treturn;\n\t}\n\tdi = dict_find(dict, (char_u *)\"maxcount\", -1);\n\tif (di != NULL)\n\t{\n\t    maxcount = (int)tv_get_number_chk(&di->di_tv, &error);\n\t    if (error)\n\t\treturn;\n\t}\n\trecompute = dict_get_bool(dict, \"recompute\", recompute);\n\tdi = dict_find(dict, (char_u *)\"pattern\", -1);\n\tif (di != NULL)\n\t{\n\t    pattern = tv_get_string_chk(&di->di_tv);\n\t    if (pattern == NULL)\n\t\treturn;\n\t}\n\tdi = dict_find(dict, (char_u *)\"pos\", -1);\n\tif (di != NULL)\n\t{\n\t    if (di->di_tv.v_type != VAR_LIST)\n\t    {\n\t\tsemsg(_(e_invalid_argument_str), \"pos\");\n\t\treturn;\n\t    }\n\t    if (list_len(di->di_tv.vval.v_list) != 3)\n\t    {\n\t\tsemsg(_(e_invalid_argument_str), \"List format should be [lnum, col, off]\");\n\t\treturn;\n\t    }\n\t    li = list_find(di->di_tv.vval.v_list, 0L);\n\t    if (li != NULL)\n\t    {\n\t\tpos.lnum = tv_get_number_chk(&li->li_tv, &error);\n\t\tif (error)\n\t\t    return;\n\t    }\n\t    li = list_find(di->di_tv.vval.v_list, 1L);\n\t    if (li != NULL)\n\t    {\n\t\tpos.col = tv_get_number_chk(&li->li_tv, &error) - 1;\n\t\tif (error)\n\t\t    return;\n\t    }\n\t    li = list_find(di->di_tv.vval.v_list, 2L);\n\t    if (li != NULL)\n\t    {\n\t\tpos.coladd = tv_get_number_chk(&li->li_tv, &error);\n\t\tif (error)\n\t\t    return;\n\t    }\n\t}\n    }\n\n    save_last_search_pattern();\n#ifdef FEAT_SEARCH_EXTRA\n    save_incsearch_state();\n#endif\n    if (pattern != NULL)\n    {\n\tif (*pattern == NUL)\n\t    goto the_end;\n\tvim_free(spats[last_idx].pat);\n\tspats[last_idx].pat = vim_strsave(pattern);\n    }\n    if (spats[last_idx].pat == NULL || *spats[last_idx].pat == NUL)\n\tgoto the_end;\t// the previous pattern was never defined\n\n    update_search_stat(0, &pos, &pos, &stat, recompute, maxcount, timeout);\n\n    dict_add_number(rettv->vval.v_dict, \"current\", stat.cur);\n    dict_add_number(rettv->vval.v_dict, \"total\", stat.cnt);\n    dict_add_number(rettv->vval.v_dict, \"exact_match\", stat.exact_match);\n    dict_add_number(rettv->vval.v_dict, \"incomplete\", stat.incomplete);\n    dict_add_number(rettv->vval.v_dict, \"maxcount\", stat.last_maxcount);\n\nthe_end:\n    restore_last_search_pattern();\n#ifdef FEAT_SEARCH_EXTRA\n    restore_incsearch_state();\n#endif\n}\n#endif\n\n/*\n * Fuzzy string matching\n *\n * Ported from the lib_fts library authored by Forrest Smith.\n * https://github.com/forrestthewoods/lib_fts/tree/master/code\n *\n * The following blog describes the fuzzy matching algorithm:\n * https://www.forrestthewoods.com/blog/reverse_engineering_sublime_texts_fuzzy_match/\n *\n * Each matching string is assigned a score. The following factors are checked:\n *   - Matched letter\n *   - Unmatched letter\n *   - Consecutively matched letters\n *   - Proximity to start\n *   - Letter following a separator (space, underscore)\n *   - Uppercase letter following lowercase (aka CamelCase)\n *\n * Matched letters are good. Unmatched letters are bad. Matching near the start\n * is good. Matching the first letter in the middle of a phrase is good.\n * Matching the uppercase letters in camel case entries is good.\n *\n * The score assigned for each factor is explained below.\n * File paths are different from file names. File extensions may be ignorable.\n * Single words care about consecutive matches but not separators or camel\n * case.\n *   Score starts at 100\n *   Matched letter: +0 points\n *   Unmatched letter: -1 point\n *   Consecutive match bonus: +15 points\n *   First letter bonus: +15 points\n *   Separator bonus: +30 points\n *   Camel case bonus: +30 points\n *   Unmatched leading letter: -5 points (max: -15)\n *\n * There is some nuance to this. Scores don\u2019t have an intrinsic meaning. The\n * score range isn\u2019t 0 to 100. It\u2019s roughly [50, 150]. Longer words have a\n * lower minimum score due to unmatched letter penalty. Longer search patterns\n * have a higher maximum score due to match bonuses.\n *\n * Separator and camel case bonus is worth a LOT. Consecutive matches are worth\n * quite a bit.\n *\n * There is a penalty if you DON\u2019T match the first three letters. Which\n * effectively rewards matching near the start. However there\u2019s no difference\n * in matching between the middle and end.\n *\n * There is not an explicit bonus for an exact match. Unmatched letters receive\n * a penalty. So shorter strings and closer matches are worth more.\n */\ntypedef struct\n{\n    int\t\tidx;\t\t// used for stable sort\n    listitem_T\t*item;\n    int\t\tscore;\n    list_T\t*lmatchpos;\n} fuzzyItem_T;\n\n// bonus for adjacent matches; this is higher than SEPARATOR_BONUS so that\n// matching a whole word is preferred.\n#define SEQUENTIAL_BONUS 40\n// bonus if match occurs after a path separator\n#define PATH_SEPARATOR_BONUS 30\n// bonus if match occurs after a word separator\n#define WORD_SEPARATOR_BONUS 25\n// bonus if match is uppercase and prev is lower\n#define CAMEL_BONUS 30\n// bonus if the first letter is matched\n#define FIRST_LETTER_BONUS 15\n// penalty applied for every letter in str before the first match\n#define LEADING_LETTER_PENALTY (-5)\n// maximum penalty for leading letters\n#define MAX_LEADING_LETTER_PENALTY (-15)\n// penalty for every letter that doesn't match\n#define UNMATCHED_LETTER_PENALTY (-1)\n// penalty for gap in matching positions (-2 * k)\n#define GAP_PENALTY\t(-2)\n// Score for a string that doesn't fuzzy match the pattern\n#define SCORE_NONE\t(-9999)\n\n#define FUZZY_MATCH_RECURSION_LIMIT\t10\n\n/*\n * Compute a score for a fuzzy matched string. The matching character locations\n * are in 'matches'.\n */\n    static int\nfuzzy_match_compute_score(\n\tchar_u\t\t*str,\n\tint\t\tstrSz,\n\tint_u\t\t*matches,\n\tint\t\tnumMatches)\n{\n    int\t\tscore;\n    int\t\tpenalty;\n    int\t\tunmatched;\n    int\t\ti;\n    char_u\t*p = str;\n    int_u\tsidx = 0;\n\n    // Initialize score\n    score = 100;\n\n    // Apply leading letter penalty\n    penalty = LEADING_LETTER_PENALTY * matches[0];\n    if (penalty < MAX_LEADING_LETTER_PENALTY)\n\tpenalty = MAX_LEADING_LETTER_PENALTY;\n    score += penalty;\n\n    // Apply unmatched penalty\n    unmatched = strSz - numMatches;\n    score += UNMATCHED_LETTER_PENALTY * unmatched;\n\n    // Apply ordering bonuses\n    for (i = 0; i < numMatches; ++i)\n    {\n\tint_u\tcurrIdx = matches[i];\n\n\tif (i > 0)\n\t{\n\t    int_u\tprevIdx = matches[i - 1];\n\n\t    // Sequential\n\t    if (currIdx == (prevIdx + 1))\n\t\tscore += SEQUENTIAL_BONUS;\n\t    else\n\t\tscore += GAP_PENALTY * (currIdx - prevIdx);\n\t}\n\n\t// Check for bonuses based on neighbor character value\n\tif (currIdx > 0)\n\t{\n\t    // Camel case\n\t    int\tneighbor = ' ';\n\t    int\tcurr;\n\n\t    if (has_mbyte)\n\t    {\n\t\twhile (sidx < currIdx)\n\t\t{\n\t\t    neighbor = (*mb_ptr2char)(p);\n\t\t    MB_PTR_ADV(p);\n\t\t    sidx++;\n\t\t}\n\t\tcurr = (*mb_ptr2char)(p);\n\t    }\n\t    else\n\t    {\n\t\tneighbor = str[currIdx - 1];\n\t\tcurr = str[currIdx];\n\t    }\n\n\t    if (vim_islower(neighbor) && vim_isupper(curr))\n\t\tscore += CAMEL_BONUS;\n\n\t    // Bonus if the match follows a separator character\n\t    if (neighbor == '/' || neighbor == '\\\\')\n\t\tscore += PATH_SEPARATOR_BONUS;\n\t    else if (neighbor == ' ' || neighbor == '_')\n\t\tscore += WORD_SEPARATOR_BONUS;\n\t}\n\telse\n\t{\n\t    // First letter\n\t    score += FIRST_LETTER_BONUS;\n\t}\n    }\n    return score;\n}\n\n/*\n * Perform a recursive search for fuzzy matching 'fuzpat' in 'str'.\n * Return the number of matching characters.\n */\n    static int\nfuzzy_match_recursive(\n\tchar_u\t\t*fuzpat,\n\tchar_u\t\t*str,\n\tint_u\t\tstrIdx,\n\tint\t\t*outScore,\n\tchar_u\t\t*strBegin,\n\tint\t\tstrLen,\n\tint_u\t\t*srcMatches,\n\tint_u\t\t*matches,\n\tint\t\tmaxMatches,\n\tint\t\tnextMatch,\n\tint\t\t*recursionCount)\n{\n    // Recursion params\n    int\t\trecursiveMatch = FALSE;\n    int_u\tbestRecursiveMatches[MAX_FUZZY_MATCHES];\n    int\t\tbestRecursiveScore = 0;\n    int\t\tfirst_match;\n    int\t\tmatched;\n\n    // Count recursions\n    ++*recursionCount;\n    if (*recursionCount >= FUZZY_MATCH_RECURSION_LIMIT)\n\treturn 0;\n\n    // Detect end of strings\n    if (*fuzpat == NUL || *str == NUL)\n\treturn 0;\n\n    // Loop through fuzpat and str looking for a match\n    first_match = TRUE;\n    while (*fuzpat != NUL && *str != NUL)\n    {\n\tint\tc1;\n\tint\tc2;\n\n\tc1 = PTR2CHAR(fuzpat);\n\tc2 = PTR2CHAR(str);\n\n\t// Found match\n\tif (vim_tolower(c1) == vim_tolower(c2))\n\t{\n\t    int_u\trecursiveMatches[MAX_FUZZY_MATCHES];\n\t    int\t\trecursiveScore = 0;\n\t    char_u\t*next_char;\n\n\t    // Supplied matches buffer was too short\n\t    if (nextMatch >= maxMatches)\n\t\treturn 0;\n\n\t    // \"Copy-on-Write\" srcMatches into matches\n\t    if (first_match && srcMatches)\n\t    {\n\t\tmemcpy(matches, srcMatches, nextMatch * sizeof(srcMatches[0]));\n\t\tfirst_match = FALSE;\n\t    }\n\n\t    // Recursive call that \"skips\" this match\n\t    if (has_mbyte)\n\t\tnext_char = str + (*mb_ptr2len)(str);\n\t    else\n\t\tnext_char = str + 1;\n\t    if (fuzzy_match_recursive(fuzpat, next_char, strIdx + 1,\n\t\t\t&recursiveScore, strBegin, strLen, matches,\n\t\t\trecursiveMatches,\n\t\t\tARRAY_LENGTH(recursiveMatches),\n\t\t\tnextMatch, recursionCount))\n\t    {\n\t\t// Pick best recursive score\n\t\tif (!recursiveMatch || recursiveScore > bestRecursiveScore)\n\t\t{\n\t\t    memcpy(bestRecursiveMatches, recursiveMatches,\n\t\t\t    MAX_FUZZY_MATCHES * sizeof(recursiveMatches[0]));\n\t\t    bestRecursiveScore = recursiveScore;\n\t\t}\n\t\trecursiveMatch = TRUE;\n\t    }\n\n\t    // Advance\n\t    matches[nextMatch++] = strIdx;\n\t    if (has_mbyte)\n\t\tMB_PTR_ADV(fuzpat);\n\t    else\n\t\t++fuzpat;\n\t}\n\tif (has_mbyte)\n\t    MB_PTR_ADV(str);\n\telse\n\t    ++str;\n\tstrIdx++;\n    }\n\n    // Determine if full fuzpat was matched\n    matched = *fuzpat == NUL ? TRUE : FALSE;\n\n    // Calculate score\n    if (matched)\n\t*outScore = fuzzy_match_compute_score(strBegin, strLen, matches,\n\t\tnextMatch);\n\n    // Return best result\n    if (recursiveMatch && (!matched || bestRecursiveScore > *outScore))\n    {\n\t// Recursive score is better than \"this\"\n\tmemcpy(matches, bestRecursiveMatches, maxMatches * sizeof(matches[0]));\n\t*outScore = bestRecursiveScore;\n\treturn nextMatch;\n    }\n    else if (matched)\n\treturn nextMatch;\t// \"this\" score is better than recursive\n\n    return 0;\t\t// no match\n}\n\n/*\n * fuzzy_match()\n *\n * Performs exhaustive search via recursion to find all possible matches and\n * match with highest score.\n * Scores values have no intrinsic meaning.  Possible score range is not\n * normalized and varies with pattern.\n * Recursion is limited internally (default=10) to prevent degenerate cases\n * (pat_arg=\"aaaaaa\" str=\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\").\n * Uses char_u for match indices. Therefore patterns are limited to\n * MAX_FUZZY_MATCHES characters.\n *\n * Returns TRUE if 'pat_arg' matches 'str'. Also returns the match score in\n * 'outScore' and the matching character positions in 'matches'.\n */\n    int\nfuzzy_match(\n\tchar_u\t\t*str,\n\tchar_u\t\t*pat_arg,\n\tint\t\tmatchseq,\n\tint\t\t*outScore,\n\tint_u\t\t*matches,\n\tint\t\tmaxMatches)\n{\n    int\t\trecursionCount = 0;\n    int\t\tlen = MB_CHARLEN(str);\n    char_u\t*save_pat;\n    char_u\t*pat;\n    char_u\t*p;\n    int\t\tcomplete = FALSE;\n    int\t\tscore = 0;\n    int\t\tnumMatches = 0;\n    int\t\tmatchCount;\n\n    *outScore = 0;\n\n    save_pat = vim_strsave(pat_arg);\n    if (save_pat == NULL)\n\treturn FALSE;\n    pat = save_pat;\n    p = pat;\n\n    // Try matching each word in 'pat_arg' in 'str'\n    while (TRUE)\n    {\n\tif (matchseq)\n\t    complete = TRUE;\n\telse\n\t{\n\t    // Extract one word from the pattern (separated by space)\n\t    p = skipwhite(p);\n\t    if (*p == NUL)\n\t\tbreak;\n\t    pat = p;\n\t    while (*p != NUL && !VIM_ISWHITE(PTR2CHAR(p)))\n\t    {\n\t\tif (has_mbyte)\n\t\t    MB_PTR_ADV(p);\n\t\telse\n\t\t    ++p;\n\t    }\n\t    if (*p == NUL)\t\t// processed all the words\n\t\tcomplete = TRUE;\n\t    *p = NUL;\n\t}\n\n\tscore = 0;\n\trecursionCount = 0;\n\tmatchCount = fuzzy_match_recursive(pat, str, 0, &score, str, len, NULL,\n\t\t\t\tmatches + numMatches, maxMatches - numMatches,\n\t\t\t\t0, &recursionCount);\n\tif (matchCount == 0)\n\t{\n\t    numMatches = 0;\n\t    break;\n\t}\n\n\t// Accumulate the match score and the number of matches\n\t*outScore += score;\n\tnumMatches += matchCount;\n\n\tif (complete)\n\t    break;\n\n\t// try matching the next word\n\t++p;\n    }\n\n    vim_free(save_pat);\n    return numMatches != 0;\n}\n\n#if defined(FEAT_EVAL) || defined(FEAT_PROTO)\n/*\n * Sort the fuzzy matches in the descending order of the match score.\n * For items with same score, retain the order using the index (stable sort)\n */\n    static int\nfuzzy_match_item_compare(const void *s1, const void *s2)\n{\n    int\t\tv1 = ((fuzzyItem_T *)s1)->score;\n    int\t\tv2 = ((fuzzyItem_T *)s2)->score;\n    int\t\tidx1 = ((fuzzyItem_T *)s1)->idx;\n    int\t\tidx2 = ((fuzzyItem_T *)s2)->idx;\n\n    return v1 == v2 ? (idx1 - idx2) : v1 > v2 ? -1 : 1;\n}\n\n/*\n * Fuzzy search the string 'str' in a list of 'items' and return the matching\n * strings in 'fmatchlist'.\n * If 'matchseq' is TRUE, then for multi-word search strings, match all the\n * words in sequence.\n * If 'items' is a list of strings, then search for 'str' in the list.\n * If 'items' is a list of dicts, then either use 'key' to lookup the string\n * for each item or use 'item_cb' Funcref function to get the string.\n * If 'retmatchpos' is TRUE, then return a list of positions where 'str'\n * matches for each item.\n */\n    static void\nfuzzy_match_in_list(\n\tlist_T\t\t*l,\n\tchar_u\t\t*str,\n\tint\t\tmatchseq,\n\tchar_u\t\t*key,\n\tcallback_T\t*item_cb,\n\tint\t\tretmatchpos,\n\tlist_T\t\t*fmatchlist,\n\tlong\t\tmax_matches)\n{\n    long\tlen;\n    fuzzyItem_T\t*items;\n    listitem_T\t*li;\n    long\ti = 0;\n    long\tmatch_count = 0;\n    int_u\tmatches[MAX_FUZZY_MATCHES];\n\n    len = list_len(l);\n    if (len == 0)\n\treturn;\n    if (max_matches > 0 && len > max_matches)\n\tlen = max_matches;\n\n    items = ALLOC_CLEAR_MULT(fuzzyItem_T, len);\n    if (items == NULL)\n\treturn;\n\n    // For all the string items in items, get the fuzzy matching score\n    FOR_ALL_LIST_ITEMS(l, li)\n    {\n\tint\t\tscore;\n\tchar_u\t\t*itemstr;\n\ttypval_T\trettv;\n\n\tif (max_matches > 0 && match_count >= max_matches)\n\t    break;\n\n\titemstr = NULL;\n\trettv.v_type = VAR_UNKNOWN;\n\tif (li->li_tv.v_type == VAR_STRING)\t// list of strings\n\t    itemstr = li->li_tv.vval.v_string;\n\telse if (li->li_tv.v_type == VAR_DICT\n\t\t\t\t&& (key != NULL || item_cb->cb_name != NULL))\n\t{\n\t    // For a dict, either use the specified key to lookup the string or\n\t    // use the specified callback function to get the string.\n\t    if (key != NULL)\n\t\titemstr = dict_get_string(li->li_tv.vval.v_dict,\n\t\t\t\t\t\t\t   (char *)key, FALSE);\n\t    else\n\t    {\n\t\ttypval_T\targv[2];\n\n\t\t// Invoke the supplied callback (if any) to get the dict item\n\t\tli->li_tv.vval.v_dict->dv_refcount++;\n\t\targv[0].v_type = VAR_DICT;\n\t\targv[0].vval.v_dict = li->li_tv.vval.v_dict;\n\t\targv[1].v_type = VAR_UNKNOWN;\n\t\tif (call_callback(item_cb, -1, &rettv, 1, argv) != FAIL)\n\t\t{\n\t\t    if (rettv.v_type == VAR_STRING)\n\t\t\titemstr = rettv.vval.v_string;\n\t\t}\n\t\tdict_unref(li->li_tv.vval.v_dict);\n\t    }\n\t}\n\n\tif (itemstr != NULL\n\t\t&& fuzzy_match(itemstr, str, matchseq, &score, matches,\n\t\t\t\t\t\t\tMAX_FUZZY_MATCHES))\n\t{\n\t    items[match_count].idx = match_count;\n\t    items[match_count].item = li;\n\t    items[match_count].score = score;\n\n\t    // Copy the list of matching positions in itemstr to a list, if\n\t    // 'retmatchpos' is set.\n\t    if (retmatchpos)\n\t    {\n\t\tint\tj = 0;\n\t\tchar_u\t*p;\n\n\t\titems[match_count].lmatchpos = list_alloc();\n\t\tif (items[match_count].lmatchpos == NULL)\n\t\t    goto done;\n\n\t\tp = str;\n\t\twhile (*p != NUL)\n\t\t{\n\t\t    if (!VIM_ISWHITE(PTR2CHAR(p)) || matchseq)\n\t\t    {\n\t\t\tif (list_append_number(items[match_count].lmatchpos,\n\t\t\t\t    matches[j]) == FAIL)\n\t\t\t    goto done;\n\t\t\tj++;\n\t\t    }\n\t\t    if (has_mbyte)\n\t\t\tMB_PTR_ADV(p);\n\t\t    else\n\t\t\t++p;\n\t\t}\n\t    }\n\t    ++match_count;\n\t}\n\tclear_tv(&rettv);\n    }\n\n    if (match_count > 0)\n    {\n\tlist_T\t\t*retlist;\n\n\t// Sort the list by the descending order of the match score\n\tqsort((void *)items, (size_t)match_count, sizeof(fuzzyItem_T),\n\t\tfuzzy_match_item_compare);\n\n\t// For matchfuzzy(), return a list of matched strings.\n\t//\t    ['str1', 'str2', 'str3']\n\t// For matchfuzzypos(), return a list with three items.\n\t// The first item is a list of matched strings. The second item\n\t// is a list of lists where each list item is a list of matched\n\t// character positions. The third item is a list of matching scores.\n\t//\t[['str1', 'str2', 'str3'], [[1, 3], [1, 3], [1, 3]]]\n\tif (retmatchpos)\n\t{\n\t    li = list_find(fmatchlist, 0);\n\t    if (li == NULL || li->li_tv.vval.v_list == NULL)\n\t\tgoto done;\n\t    retlist = li->li_tv.vval.v_list;\n\t}\n\telse\n\t    retlist = fmatchlist;\n\n\t// Copy the matching strings with a valid score to the return list\n\tfor (i = 0; i < match_count; i++)\n\t{\n\t    if (items[i].score == SCORE_NONE)\n\t\tbreak;\n\t    list_append_tv(retlist, &items[i].item->li_tv);\n\t}\n\n\t// next copy the list of matching positions\n\tif (retmatchpos)\n\t{\n\t    li = list_find(fmatchlist, -2);\n\t    if (li == NULL || li->li_tv.vval.v_list == NULL)\n\t\tgoto done;\n\t    retlist = li->li_tv.vval.v_list;\n\n\t    for (i = 0; i < match_count; i++)\n\t    {\n\t\tif (items[i].score == SCORE_NONE)\n\t\t    break;\n\t\tif (items[i].lmatchpos != NULL\n\t\t      && list_append_list(retlist, items[i].lmatchpos) == FAIL)\n\t\t    goto done;\n\t    }\n\n\t    // copy the matching scores\n\t    li = list_find(fmatchlist, -1);\n\t    if (li == NULL || li->li_tv.vval.v_list == NULL)\n\t\tgoto done;\n\t    retlist = li->li_tv.vval.v_list;\n\t    for (i = 0; i < match_count; i++)\n\t    {\n\t\tif (items[i].score == SCORE_NONE)\n\t\t    break;\n\t\tif (list_append_number(retlist, items[i].score) == FAIL)\n\t\t    goto done;\n\t    }\n\t}\n    }\n\ndone:\n    vim_free(items);\n}\n\n/*\n * Do fuzzy matching. Returns the list of matched strings in 'rettv'.\n * If 'retmatchpos' is TRUE, also returns the matching character positions.\n */\n    static void\ndo_fuzzymatch(typval_T *argvars, typval_T *rettv, int retmatchpos)\n{\n    callback_T\tcb;\n    char_u\t*key = NULL;\n    int\t\tret;\n    int\t\tmatchseq = FALSE;\n    long\tmax_matches = 0;\n\n    if (in_vim9script()\n\t    && (check_for_list_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL\n\t\t|| check_for_opt_dict_arg(argvars, 2) == FAIL))\n\treturn;\n\n    CLEAR_POINTER(&cb);\n\n    // validate and get the arguments\n    if (argvars[0].v_type != VAR_LIST || argvars[0].vval.v_list == NULL)\n    {\n\tsemsg(_(e_argument_of_str_must_be_list),\n\t\t\t     retmatchpos ? \"matchfuzzypos()\" : \"matchfuzzy()\");\n\treturn;\n    }\n    if (argvars[1].v_type != VAR_STRING\n\t    || argvars[1].vval.v_string == NULL)\n    {\n\tsemsg(_(e_invalid_argument_str), tv_get_string(&argvars[1]));\n\treturn;\n    }\n\n    if (argvars[2].v_type != VAR_UNKNOWN)\n    {\n\tdict_T\t\t*d;\n\tdictitem_T\t*di;\n\n\tif (check_for_nonnull_dict_arg(argvars, 2) == FAIL)\n\t    return;\n\n\t// To search a dict, either a callback function or a key can be\n\t// specified.\n\td = argvars[2].vval.v_dict;\n\tif ((di = dict_find(d, (char_u *)\"key\", -1)) != NULL)\n\t{\n\t    if (di->di_tv.v_type != VAR_STRING\n\t\t    || di->di_tv.vval.v_string == NULL\n\t\t    || *di->di_tv.vval.v_string == NUL)\n\t    {\n\t\tsemsg(_(e_invalid_argument_str), tv_get_string(&di->di_tv));\n\t\treturn;\n\t    }\n\t    key = tv_get_string(&di->di_tv);\n\t}\n\telse if ((di = dict_find(d, (char_u *)\"text_cb\", -1)) != NULL)\n\t{\n\t    cb = get_callback(&di->di_tv);\n\t    if (cb.cb_name == NULL)\n\t    {\n\t\tsemsg(_(e_invalid_value_for_argument_str), \"text_cb\");\n\t\treturn;\n\t    }\n\t}\n\n\tif ((di = dict_find(d, (char_u *)\"limit\", -1)) != NULL)\n\t{\n\t    if (di->di_tv.v_type != VAR_NUMBER)\n\t    {\n\t\tsemsg(_(e_invalid_argument_str), tv_get_string(&di->di_tv));\n\t\treturn;\n\t    }\n\t    max_matches = (long)tv_get_number_chk(&di->di_tv, NULL);\n\t}\n\n\tif (dict_has_key(d, \"matchseq\"))\n\t    matchseq = TRUE;\n    }\n\n    // get the fuzzy matches\n    ret = rettv_list_alloc(rettv);\n    if (ret == FAIL)\n\tgoto done;\n    if (retmatchpos)\n    {\n\tlist_T\t*l;\n\n\t// For matchfuzzypos(), a list with three items are returned. First\n\t// item is a list of matching strings, the second item is a list of\n\t// lists with matching positions within each string and the third item\n\t// is the list of scores of the matches.\n\tl = list_alloc();\n\tif (l == NULL)\n\t    goto done;\n\tif (list_append_list(rettv->vval.v_list, l) == FAIL)\n\t{\n\t    vim_free(l);\n\t    goto done;\n\t}\n\tl = list_alloc();\n\tif (l == NULL)\n\t    goto done;\n\tif (list_append_list(rettv->vval.v_list, l) == FAIL)\n\t{\n\t    vim_free(l);\n\t    goto done;\n\t}\n\tl = list_alloc();\n\tif (l == NULL)\n\t    goto done;\n\tif (list_append_list(rettv->vval.v_list, l) == FAIL)\n\t{\n\t    vim_free(l);\n\t    goto done;\n\t}\n    }\n\n    fuzzy_match_in_list(argvars[0].vval.v_list, tv_get_string(&argvars[1]),\n\t    matchseq, key, &cb, retmatchpos, rettv->vval.v_list, max_matches);\n\ndone:\n    free_callback(&cb);\n}\n\n/*\n * \"matchfuzzy()\" function\n */\n    void\nf_matchfuzzy(typval_T *argvars, typval_T *rettv)\n{\n    do_fuzzymatch(argvars, rettv, FALSE);\n}\n\n/*\n * \"matchfuzzypos()\" function\n */\n    void\nf_matchfuzzypos(typval_T *argvars, typval_T *rettv)\n{\n    do_fuzzymatch(argvars, rettv, TRUE);\n}\n#endif\n\n/*\n * Same as fuzzy_match_item_compare() except for use with a string match\n */\n    static int\nfuzzy_match_str_compare(const void *s1, const void *s2)\n{\n    int\t\tv1 = ((fuzmatch_str_T *)s1)->score;\n    int\t\tv2 = ((fuzmatch_str_T *)s2)->score;\n    int\t\tidx1 = ((fuzmatch_str_T *)s1)->idx;\n    int\t\tidx2 = ((fuzmatch_str_T *)s2)->idx;\n\n    return v1 == v2 ? (idx1 - idx2) : v1 > v2 ? -1 : 1;\n}\n\n/*\n * Sort fuzzy matches by score\n */\n    static void\nfuzzy_match_str_sort(fuzmatch_str_T *fm, int sz)\n{\n    // Sort the list by the descending order of the match score\n    qsort((void *)fm, (size_t)sz, sizeof(fuzmatch_str_T),\n\t    fuzzy_match_str_compare);\n}\n\n/*\n * Same as fuzzy_match_item_compare() except for use with a function name\n * string match. <SNR> functions should be sorted to the end.\n */\n    static int\nfuzzy_match_func_compare(const void *s1, const void *s2)\n{\n    int\t\tv1 = ((fuzmatch_str_T *)s1)->score;\n    int\t\tv2 = ((fuzmatch_str_T *)s2)->score;\n    int\t\tidx1 = ((fuzmatch_str_T *)s1)->idx;\n    int\t\tidx2 = ((fuzmatch_str_T *)s2)->idx;\n    char_u\t*str1 = ((fuzmatch_str_T *)s1)->str;\n    char_u\t*str2 = ((fuzmatch_str_T *)s2)->str;\n\n    if (*str1 != '<' && *str2 == '<') return -1;\n    if (*str1 == '<' && *str2 != '<') return 1;\n    return v1 == v2 ? (idx1 - idx2) : v1 > v2 ? -1 : 1;\n}\n\n/*\n * Sort fuzzy matches of function names by score.\n * <SNR> functions should be sorted to the end.\n */\n    static void\nfuzzy_match_func_sort(fuzmatch_str_T *fm, int sz)\n{\n    // Sort the list by the descending order of the match score\n    qsort((void *)fm, (size_t)sz, sizeof(fuzmatch_str_T),\n\t\tfuzzy_match_func_compare);\n}\n\n/*\n * Fuzzy match 'pat' in 'str'. Returns 0 if there is no match. Otherwise,\n * returns the match score.\n */\n    int\nfuzzy_match_str(char_u *str, char_u *pat)\n{\n    int\t\tscore = 0;\n    int_u\tmatchpos[MAX_FUZZY_MATCHES];\n\n    if (str == NULL || pat == NULL)\n\treturn 0;\n\n    fuzzy_match(str, pat, TRUE, &score, matchpos,\n\t\t\t\tsizeof(matchpos) / sizeof(matchpos[0]));\n\n    return score;\n}\n\n/*\n * Free an array of fuzzy string matches \"fuzmatch[count]\".\n */\n    void\nfuzmatch_str_free(fuzmatch_str_T *fuzmatch, int count)\n{\n    int i;\n\n    if (fuzmatch == NULL)\n\treturn;\n    for (i = 0; i < count; ++i)\n\tvim_free(fuzmatch[i].str);\n    vim_free(fuzmatch);\n}\n\n/*\n * Copy a list of fuzzy matches into a string list after sorting the matches by\n * the fuzzy score. Frees the memory allocated for 'fuzmatch'.\n * Returns OK on success and FAIL on memory allocation failure.\n */\n    int\nfuzzymatches_to_strmatches(\n\tfuzmatch_str_T\t*fuzmatch,\n\tchar_u\t\t***matches,\n\tint\t\tcount,\n\tint\t\tfuncsort)\n{\n    int\t\ti;\n\n    if (count <= 0)\n\treturn OK;\n\n    *matches = ALLOC_MULT(char_u *, count);\n    if (*matches == NULL)\n    {\n\tfuzmatch_str_free(fuzmatch, count);\n\treturn FAIL;\n    }\n\n    // Sort the list by the descending order of the match score\n    if (funcsort)\n\tfuzzy_match_func_sort((void *)fuzmatch, (size_t)count);\n    else\n\tfuzzy_match_str_sort((void *)fuzmatch, (size_t)count);\n\n    for (i = 0; i < count; i++)\n\t(*matches)[i] = fuzmatch[i].str;\n    vim_free(fuzmatch);\n\n    return OK;\n}\n", "\" Tests for fuzzy matching\n\nsource shared.vim\nsource check.vim\n\n\" Test for matchfuzzy()\nfunc Test_matchfuzzy()\n  call assert_fails('call matchfuzzy(10, \"abc\")', 'E686:')\n  call assert_fails('call matchfuzzy([\"abc\"], [])', 'E730:')\n  call assert_fails(\"let x = matchfuzzy(test_null_list(), 'foo')\", 'E686:')\n  call assert_fails('call matchfuzzy([\"abc\"], test_null_string())', 'E475:')\n  call assert_equal([], matchfuzzy([], 'abc'))\n  call assert_equal([], matchfuzzy(['abc'], ''))\n  call assert_equal(['abc'], matchfuzzy(['abc', 10], 'ac'))\n  call assert_equal([], matchfuzzy([10, 20], 'ac'))\n  call assert_equal(['abc'], matchfuzzy(['abc'], 'abc'))\n  call assert_equal(['crayon', 'camera'], matchfuzzy(['camera', 'crayon'], 'cra'))\n  call assert_equal(['aabbaa', 'aaabbbaaa', 'aaaabbbbaaaa', 'aba'], matchfuzzy(['aba', 'aabbaa', 'aaabbbaaa', 'aaaabbbbaaaa'], 'aa'))\n  call assert_equal(['one'], matchfuzzy(['one', 'two'], 'one'))\n  call assert_equal(['oneTwo', 'onetwo'], matchfuzzy(['onetwo', 'oneTwo'], 'oneTwo'))\n  call assert_equal(['onetwo', 'one_two'], matchfuzzy(['onetwo', 'one_two'], 'oneTwo'))\n  call assert_equal(['aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'], matchfuzzy(['aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'], 'aa'))\n  call assert_equal(256, matchfuzzy([repeat('a', 256)], repeat('a', 256))[0]->len())\n  call assert_equal([], matchfuzzy([repeat('a', 300)], repeat('a', 257)))\n  \" matches with same score should not be reordered\n  let l = ['abc1', 'abc2', 'abc3']\n  call assert_equal(l, l->matchfuzzy('abc'))\n\n  \" Tests for match preferences\n  \" preference for camel case match\n  call assert_equal(['oneTwo', 'onetwo'], ['onetwo', 'oneTwo']->matchfuzzy('onetwo'))\n  \" preference for match after a separator (_ or space)\n  call assert_equal(['onetwo', 'one_two', 'one two'], ['onetwo', 'one_two', 'one two']->matchfuzzy('onetwo'))\n  \" preference for leading letter match\n  call assert_equal(['onetwo', 'xonetwo'], ['xonetwo', 'onetwo']->matchfuzzy('onetwo'))\n  \" preference for sequential match\n  call assert_equal(['onetwo', 'oanbectdweo'], ['oanbectdweo', 'onetwo']->matchfuzzy('onetwo'))\n  \" non-matching leading letter(s) penalty\n  call assert_equal(['xonetwo', 'xxonetwo'], ['xxonetwo', 'xonetwo']->matchfuzzy('onetwo'))\n  \" total non-matching letter(s) penalty\n  call assert_equal(['one', 'onex', 'onexx'], ['onexx', 'one', 'onex']->matchfuzzy('one'))\n  \" prefer complete matches over separator matches\n  call assert_equal(['.vim/vimrc', '.vim/vimrc_colors', '.vim/v_i_m_r_c'], ['.vim/vimrc', '.vim/vimrc_colors', '.vim/v_i_m_r_c']->matchfuzzy('vimrc'))\n  \" gap penalty\n  call assert_equal(['xxayybxxxx', 'xxayyybxxx', 'xxayyyybxx'], ['xxayyyybxx', 'xxayyybxxx', 'xxayybxxxx']->matchfuzzy('ab'))\n  \" path separator vs word separator\n  call assert_equal(['color/setup.vim', 'color\\\\setup.vim', 'color setup.vim', 'color_setup.vim', 'colorsetup.vim'], matchfuzzy(['colorsetup.vim', 'color setup.vim', 'color/setup.vim', 'color_setup.vim', 'color\\\\setup.vim'], 'setup.vim'))\n\n  \" match multiple words (separated by space)\n  call assert_equal(['foo bar baz'], ['foo bar baz', 'foo', 'foo bar', 'baz bar']->matchfuzzy('baz foo'))\n  call assert_equal([], ['foo bar baz', 'foo', 'foo bar', 'baz bar']->matchfuzzy('one two'))\n  call assert_equal([], ['foo bar']->matchfuzzy(\" \\t \"))\n\n  \" test for matching a sequence of words\n  call assert_equal(['bar foo'], ['foo bar', 'bar foo', 'foobar', 'barfoo']->matchfuzzy('bar foo', {'matchseq' : 1}))\n  call assert_equal([#{text: 'two one'}], [#{text: 'one two'}, #{text: 'two one'}]->matchfuzzy('two one', #{key: 'text', matchseq: v:true}))\n\n  %bw!\n  eval ['somebuf', 'anotherone', 'needle', 'yetanotherone']->map({_, v -> bufadd(v) + bufload(v)})\n  let l = getbufinfo()->map({_, v -> fnamemodify(v.name, ':t')})->matchfuzzy('ndl')\n  call assert_equal(1, len(l))\n  call assert_match('needle', l[0])\n\n  \" Test for fuzzy matching dicts\n  let l = [{'id' : 5, 'val' : 'crayon'}, {'id' : 6, 'val' : 'camera'}]\n  call assert_equal([{'id' : 6, 'val' : 'camera'}], matchfuzzy(l, 'cam', {'text_cb' : {v -> v.val}}))\n  call assert_equal([{'id' : 6, 'val' : 'camera'}], matchfuzzy(l, 'cam', {'key' : 'val'}))\n  call assert_equal([], matchfuzzy(l, 'day', {'text_cb' : {v -> v.val}}))\n  call assert_equal([], matchfuzzy(l, 'day', {'key' : 'val'}))\n  call assert_fails(\"let x = matchfuzzy(l, 'cam', 'random')\", 'E1206:')\n  call assert_equal([], matchfuzzy(l, 'day', {'text_cb' : {v -> []}}))\n  call assert_equal([], matchfuzzy(l, 'day', {'text_cb' : {v -> 1}}))\n  call assert_fails(\"let x = matchfuzzy(l, 'day', {'text_cb' : {a, b -> 1}})\", 'E119:')\n  call assert_equal([], matchfuzzy(l, 'cam'))\n  call assert_fails(\"let x = matchfuzzy(l, 'cam', {'text_cb' : []})\", 'E921:')\n  call assert_fails(\"let x = matchfuzzy(l, 'foo', {'key' : []})\", 'E730:')\n  call assert_fails(\"let x = matchfuzzy(l, 'cam', test_null_dict())\", 'E1297:')\n  call assert_fails(\"let x = matchfuzzy(l, 'foo', {'key' : test_null_string()})\", 'E475:')\n  call assert_fails(\"let x = matchfuzzy(l, 'foo', {'text_cb' : test_null_function()})\", 'E475:')\n  \" matches with same score should not be reordered\n  let l = [#{text: 'abc', id: 1}, #{text: 'abc', id: 2}, #{text: 'abc', id: 3}]\n  call assert_equal(l, l->matchfuzzy('abc', #{key: 'text'}))\n\n  let l = [{'id' : 5, 'name' : 'foo'}, {'id' : 6, 'name' : []}, {'id' : 7}]\n  call assert_fails(\"let x = matchfuzzy(l, 'foo', {'key' : 'name'})\", 'E730:')\n\n  \" Test in latin1 encoding\n  let save_enc = &encoding\n  set encoding=latin1\n  call assert_equal(['abc'], matchfuzzy(['abc'], 'abc'))\n  let &encoding = save_enc\nendfunc\n\n\" Test for the matchfuzzypos() function\nfunc Test_matchfuzzypos()\n  call assert_equal([['curl', 'world'], [[2,3], [2,3]], [128, 127]], matchfuzzypos(['world', 'curl'], 'rl'))\n  call assert_equal([['curl', 'world'], [[2,3], [2,3]], [128, 127]], matchfuzzypos(['world', 'one', 'curl'], 'rl'))\n  call assert_equal([['hello', 'hello world hello world'],\n        \\ [[0, 1, 2, 3, 4], [0, 1, 2, 3, 4]], [275, 257]],\n        \\ matchfuzzypos(['hello world hello world', 'hello', 'world'], 'hello'))\n  call assert_equal([['aaaaaaa'], [[0, 1, 2]], [191]], matchfuzzypos(['aaaaaaa'], 'aaa'))\n  call assert_equal([['a  b'], [[0, 3]], [219]], matchfuzzypos(['a  b'], 'a  b'))\n  call assert_equal([['a  b'], [[0, 3]], [219]], matchfuzzypos(['a  b'], 'a    b'))\n  call assert_equal([['a  b'], [[0]], [112]], matchfuzzypos(['a  b'], '  a  '))\n  call assert_equal([[], [], []], matchfuzzypos(['a  b'], '  '))\n  call assert_equal([[], [], []], matchfuzzypos(['world', 'curl'], 'ab'))\n  let x = matchfuzzypos([repeat('a', 256)], repeat('a', 256))\n  call assert_equal(range(256), x[1][0])\n  call assert_equal([[], [], []], matchfuzzypos([repeat('a', 300)], repeat('a', 257)))\n  call assert_equal([[], [], []], matchfuzzypos([], 'abc'))\n\n  \" match in a long string\n  call assert_equal([[repeat('x', 300) .. 'abc'], [[300, 301, 302]], [-135]],\n        \\ matchfuzzypos([repeat('x', 300) .. 'abc'], 'abc'))\n\n  \" preference for camel case match\n  call assert_equal([['xabcxxaBc'], [[6, 7, 8]], [189]], matchfuzzypos(['xabcxxaBc'], 'abc'))\n  \" preference for match after a separator (_ or space)\n  call assert_equal([['xabx_ab'], [[5, 6]], [145]], matchfuzzypos(['xabx_ab'], 'ab'))\n  \" preference for leading letter match\n  call assert_equal([['abcxabc'], [[0, 1]], [150]], matchfuzzypos(['abcxabc'], 'ab'))\n  \" preference for sequential match\n  call assert_equal([['aobncedone'], [[7, 8, 9]], [158]], matchfuzzypos(['aobncedone'], 'one'))\n  \" best recursive match\n  call assert_equal([['xoone'], [[2, 3, 4]], [168]], matchfuzzypos(['xoone'], 'one'))\n\n  \" match multiple words (separated by space)\n  call assert_equal([['foo bar baz'], [[8, 9, 10, 0, 1, 2]], [369]], ['foo bar baz', 'foo', 'foo bar', 'baz bar']->matchfuzzypos('baz foo'))\n  call assert_equal([[], [], []], ['foo bar baz', 'foo', 'foo bar', 'baz bar']->matchfuzzypos('baz foo', {'matchseq': 1}))\n  call assert_equal([['foo bar baz'], [[0, 1, 2, 8, 9, 10]], [369]], ['foo bar baz', 'foo', 'foo bar', 'baz bar']->matchfuzzypos('foo baz'))\n  call assert_equal([['foo bar baz'], [[0, 1, 2, 3, 4, 5, 10]], [326]], ['foo bar baz', 'foo', 'foo bar', 'baz bar']->matchfuzzypos('foo baz', {'matchseq': 1}))\n  call assert_equal([[], [], []], ['foo bar baz', 'foo', 'foo bar', 'baz bar']->matchfuzzypos('one two'))\n  call assert_equal([[], [], []], ['foo bar']->matchfuzzypos(\" \\t \"))\n  call assert_equal([['grace'], [[1, 2, 3, 4, 2, 3, 4, 0, 1, 2, 3, 4]], [657]], ['grace']->matchfuzzypos('race ace grace'))\n\n  let l = [{'id' : 5, 'val' : 'crayon'}, {'id' : 6, 'val' : 'camera'}]\n  call assert_equal([[{'id' : 6, 'val' : 'camera'}], [[0, 1, 2]], [192]],\n        \\ matchfuzzypos(l, 'cam', {'text_cb' : {v -> v.val}}))\n  call assert_equal([[{'id' : 6, 'val' : 'camera'}], [[0, 1, 2]], [192]],\n        \\ matchfuzzypos(l, 'cam', {'key' : 'val'}))\n  call assert_equal([[], [], []], matchfuzzypos(l, 'day', {'text_cb' : {v -> v.val}}))\n  call assert_equal([[], [], []], matchfuzzypos(l, 'day', {'key' : 'val'}))\n  call assert_fails(\"let x = matchfuzzypos(l, 'cam', 'random')\", 'E1206:')\n  call assert_equal([[], [], []], matchfuzzypos(l, 'day', {'text_cb' : {v -> []}}))\n  call assert_equal([[], [], []], matchfuzzypos(l, 'day', {'text_cb' : {v -> 1}}))\n  call assert_fails(\"let x = matchfuzzypos(l, 'day', {'text_cb' : {a, b -> 1}})\", 'E119:')\n  call assert_equal([[], [], []], matchfuzzypos(l, 'cam'))\n  call assert_fails(\"let x = matchfuzzypos(l, 'cam', {'text_cb' : []})\", 'E921:')\n  call assert_fails(\"let x = matchfuzzypos(l, 'foo', {'key' : []})\", 'E730:')\n  call assert_fails(\"let x = matchfuzzypos(l, 'cam', test_null_dict())\", 'E1297:')\n  call assert_fails(\"let x = matchfuzzypos(l, 'foo', {'key' : test_null_string()})\", 'E475:')\n  call assert_fails(\"let x = matchfuzzypos(l, 'foo', {'text_cb' : test_null_function()})\", 'E475:')\n\n  let l = [{'id' : 5, 'name' : 'foo'}, {'id' : 6, 'name' : []}, {'id' : 7}]\n  call assert_fails(\"let x = matchfuzzypos(l, 'foo', {'key' : 'name'})\", 'E730:')\nendfunc\n\n\" Test for matchfuzzy() with multibyte characters\nfunc Test_matchfuzzy_mbyte()\n  CheckFeature multi_lang\n  call assert_equal(['\u30f3\u30f9\u3107\u30fa\u30f4'], matchfuzzy(['\u30f3\u30f9\u3107\u30fa\u30f4'], '\u30f9\u30fa'))\n  \" reverse the order of characters\n  call assert_equal([], matchfuzzy(['\u30f3\u30f9\u3107\u30fa\u30f4'], '\u30fa\u30f9'))\n  call assert_equal(['\u03b1\u03b2\u03a9xxx', 'x\u03b1x\u03b2x\u03a9x'],\n        \\ matchfuzzy(['\u03b1\u03b2\u03a9xxx', 'x\u03b1x\u03b2x\u03a9x'], '\u03b1\u03b2\u03a9'))\n  call assert_equal(['\u03c0\u03c0bb\u03c0\u03c0', '\u03c0\u03c0\u03c0bbb\u03c0\u03c0\u03c0', '\u03c0\u03c0\u03c0\u03c0bbbb\u03c0\u03c0\u03c0\u03c0', '\u03c0b\u03c0'],\n        \\ matchfuzzy(['\u03c0b\u03c0', '\u03c0\u03c0bb\u03c0\u03c0', '\u03c0\u03c0\u03c0bbb\u03c0\u03c0\u03c0', '\u03c0\u03c0\u03c0\u03c0bbbb\u03c0\u03c0\u03c0\u03c0'], '\u03c0\u03c0'))\n\n  \" match multiple words (separated by space)\n  call assert_equal(['\uc138 \ub9c8\ub9ac\uc758 \uc791\uc740 \ub3fc\uc9c0'], ['\uc138 \ub9c8\ub9ac\uc758 \uc791\uc740 \ub3fc\uc9c0', '\ub9c8\ub9ac\uc758', '\ub9c8\ub9ac\uc758 \uc791\uc740', '\uc791\uc740 \ub3fc\uc9c0']->matchfuzzy('\ub3fc\uc9c0 \ub9c8\ub9ac\uc758'))\n  call assert_equal([], ['\uc138 \ub9c8\ub9ac\uc758 \uc791\uc740 \ub3fc\uc9c0', '\ub9c8\ub9ac\uc758', '\ub9c8\ub9ac\uc758 \uc791\uc740', '\uc791\uc740 \ub3fc\uc9c0']->matchfuzzy('\ud30c\ub780 \ud558\ub298'))\n\n  \" preference for camel case match\n  call assert_equal(['one\u0104wo', 'one\u0105wo'],\n        \\ ['one\u0105wo', 'one\u0104wo']->matchfuzzy('one\u0105wo'))\n  \" preference for complete match then match after separator (_ or space)\n  call assert_equal(['\u2160\u2161ab\u311f\u3120'] + sort(['\u2160\u2161a_b\u311f\u3120', '\u2160\u2161a b\u311f\u3120']),\n          \\ ['\u2160\u2161ab\u311f\u3120', '\u2160\u2161a b\u311f\u3120', '\u2160\u2161a_b\u311f\u3120']->matchfuzzy('\u2160\u2161ab\u311f\u3120'))\n  \" preference for match after a separator (_ or space)\n  call assert_equal(['\u3113\u3114ab\u311f\u3120', '\u3113\u3114a_b\u311f\u3120', '\u3113\u3114a b\u311f\u3120'],\n        \\ ['\u3113\u3114a_b\u311f\u3120', '\u3113\u3114a b\u311f\u3120', '\u3113\u3114ab\u311f\u3120']->matchfuzzy('\u3113\u3114ab\u311f\u3120'))\n  \" preference for leading letter match\n  call assert_equal(['\u0157\u015d\u0163\u0169\u0175\u017c', 'x\u0157\u015d\u0163\u0169\u0175\u017c'],\n        \\ ['x\u0157\u015d\u0163\u0169\u0175\u017c', '\u0157\u015d\u0163\u0169\u0175\u017c']->matchfuzzy('\u0157\u015d\u0163\u0169\u0175\u017c'))\n  \" preference for sequential match\n  call assert_equal(['\u311e\u3121\u3124\ufb00\ufb01\ufb02', '\u311ea\u3121b\u3124c\ufb00d\ufb01e\ufb02'],\n        \\ ['\u311ea\u3121b\u3124c\ufb00d\ufb01e\ufb02', '\u311e\u3121\u3124\ufb00\ufb01\ufb02']->matchfuzzy('\u311e\u3121\u3124\ufb00\ufb01\ufb02'))\n  \" non-matching leading letter(s) penalty\n  call assert_equal(['x\u311e\u3121\u3124\ufb00\ufb01\ufb02', 'xx\u311e\u3121\u3124\ufb00\ufb01\ufb02'],\n        \\ ['xx\u311e\u3121\u3124\ufb00\ufb01\ufb02', 'x\u311e\u3121\u3124\ufb00\ufb01\ufb02']->matchfuzzy('\u311e\u3121\u3124\ufb00\ufb01\ufb02'))\n  \" total non-matching letter(s) penalty\n  call assert_equal(['\u0157\u015d\u0163', '\u0157\u015d\u0163x', '\u0157\u015d\u0163xx'],\n        \\ ['\u0157\u015d\u0163xx', '\u0157\u015d\u0163', '\u0157\u015d\u0163x']->matchfuzzy('\u0157\u015d\u0163'))\nendfunc\n\n\" Test for matchfuzzypos() with multibyte characters\nfunc Test_matchfuzzypos_mbyte()\n  CheckFeature multi_lang\n  call assert_equal([['\u3053\u3093\u306b\u3061\u306f\u4e16\u754c'], [[0, 1, 2, 3, 4]], [273]],\n        \\ matchfuzzypos(['\u3053\u3093\u306b\u3061\u306f\u4e16\u754c'], '\u3053\u3093\u306b\u3061\u306f'))\n  call assert_equal([['\u30f3\u30f9\u3107\u30fa\u30f4'], [[1, 3]], [88]], matchfuzzypos(['\u30f3\u30f9\u3107\u30fa\u30f4'], '\u30f9\u30fa'))\n  \" reverse the order of characters\n  call assert_equal([[], [], []], matchfuzzypos(['\u30f3\u30f9\u3107\u30fa\u30f4'], '\u30fa\u30f9'))\n  call assert_equal([['\u03b1\u03b2\u03a9xxx', 'x\u03b1x\u03b2x\u03a9x'], [[0, 1, 2], [1, 3, 5]], [222, 113]],\n        \\ matchfuzzypos(['\u03b1\u03b2\u03a9xxx', 'x\u03b1x\u03b2x\u03a9x'], '\u03b1\u03b2\u03a9'))\n  call assert_equal([['\u03c0\u03c0bb\u03c0\u03c0', '\u03c0\u03c0\u03c0bbb\u03c0\u03c0\u03c0', '\u03c0\u03c0\u03c0\u03c0bbbb\u03c0\u03c0\u03c0\u03c0', '\u03c0b\u03c0'],\n        \\ [[0, 1], [0, 1], [0, 1], [0, 2]], [151, 148, 145, 110]],\n        \\ matchfuzzypos(['\u03c0b\u03c0', '\u03c0\u03c0bb\u03c0\u03c0', '\u03c0\u03c0\u03c0bbb\u03c0\u03c0\u03c0', '\u03c0\u03c0\u03c0\u03c0bbbb\u03c0\u03c0\u03c0\u03c0'], '\u03c0\u03c0'))\n  call assert_equal([['\u03b1\u03b1\u03b1\u03b1\u03b1\u03b1\u03b1'], [[0, 1, 2]], [191]],\n        \\ matchfuzzypos(['\u03b1\u03b1\u03b1\u03b1\u03b1\u03b1\u03b1'], '\u03b1\u03b1\u03b1'))\n\n  call assert_equal([[], [], []], matchfuzzypos(['\u30f3\u30f9\u3107', '\u0157\u015d\u0163'], '\ufb00\ufb01\ufb02'))\n  let x = matchfuzzypos([repeat('\u03a8', 256)], repeat('\u03a8', 256))\n  call assert_equal(range(256), x[1][0])\n  call assert_equal([[], [], []], matchfuzzypos([repeat('\u2713', 300)], repeat('\u2713', 257)))\n\n  \" match multiple words (separated by space)\n  call assert_equal([['\uc138 \ub9c8\ub9ac\uc758 \uc791\uc740 \ub3fc\uc9c0'], [[9, 10, 2, 3, 4]], [328]], ['\uc138 \ub9c8\ub9ac\uc758 \uc791\uc740 \ub3fc\uc9c0', '\ub9c8\ub9ac\uc758', '\ub9c8\ub9ac\uc758 \uc791\uc740', '\uc791\uc740 \ub3fc\uc9c0']->matchfuzzypos('\ub3fc\uc9c0 \ub9c8\ub9ac\uc758'))\n  call assert_equal([[], [], []], ['\uc138 \ub9c8\ub9ac\uc758 \uc791\uc740 \ub3fc\uc9c0', '\ub9c8\ub9ac\uc758', '\ub9c8\ub9ac\uc758 \uc791\uc740', '\uc791\uc740 \ub3fc\uc9c0']->matchfuzzypos('\ud30c\ub780 \ud558\ub298'))\n\n  \" match in a long string\n  call assert_equal([[repeat('\u3076', 300) .. '\u1ebc\u1ebc\u1ebc'], [[300, 301, 302]], [-135]],\n        \\ matchfuzzypos([repeat('\u3076', 300) .. '\u1ebc\u1ebc\u1ebc'], '\u1ebc\u1ebc\u1ebc'))\n  \" preference for camel case match\n  call assert_equal([['x\u0473\u0475\u0481xx\u0473\u0474\u0481'], [[6, 7, 8]], [189]], matchfuzzypos(['x\u0473\u0475\u0481xx\u0473\u0474\u0481'], '\u0473\u0475\u0481'))\n  \" preference for match after a separator (_ or space)\n  call assert_equal([['x\u3061\u3060x_\u3061\u3060'], [[5, 6]], [145]], matchfuzzypos(['x\u3061\u3060x_\u3061\u3060'], '\u3061\u3060'))\n  \" preference for leading letter match\n  call assert_equal([['\u0473\u0475\u0481x\u0473\u0475\u0481'], [[0, 1]], [150]], matchfuzzypos(['\u0473\u0475\u0481x\u0473\u0475\u0481'], '\u0473\u0475'))\n  \" preference for sequential match\n  call assert_equal([['a\u30f3b\u30f9c\u3107d\u30f3\u30f9\u3107'], [[7, 8, 9]], [158]], matchfuzzypos(['a\u30f3b\u30f9c\u3107d\u30f3\u30f9\u3107'], '\u30f3\u30f9\u3107'))\n  \" best recursive match\n  call assert_equal([['x\u0444\u0444\u0439\u0434'], [[2, 3, 4]], [168]], matchfuzzypos(['x\u0444\u0444\u0439\u0434'], '\u0444\u0439\u0434'))\nendfunc\n\n\" Test for matchfuzzy() with limit\nfunc Test_matchfuzzy_limit()\n  let x = ['1', '2', '3', '2']\n  call assert_equal(['2', '2'], x->matchfuzzy('2'))\n  call assert_equal(['2', '2'], x->matchfuzzy('2', #{}))\n  call assert_equal(['2', '2'], x->matchfuzzy('2', #{limit: 0}))\n  call assert_equal(['2'], x->matchfuzzy('2', #{limit: 1}))\n  call assert_equal(['2', '2'], x->matchfuzzy('2', #{limit: 2}))\n  call assert_equal(['2', '2'], x->matchfuzzy('2', #{limit: 3}))\n  call assert_fails(\"call matchfuzzy(x, '2', #{limit: '2'})\", 'E475:')\n\n  let l = [{'id': 5, 'val': 'crayon'}, {'id': 6, 'val': 'camera'}]\n  call assert_equal([{'id': 5, 'val': 'crayon'}, {'id': 6, 'val': 'camera'}], l->matchfuzzy('c', #{text_cb: {v -> v.val}}))\n  call assert_equal([{'id': 5, 'val': 'crayon'}, {'id': 6, 'val': 'camera'}], l->matchfuzzy('c', #{key: 'val'}))\n  call assert_equal([{'id': 5, 'val': 'crayon'}, {'id': 6, 'val': 'camera'}], l->matchfuzzy('c', #{text_cb: {v -> v.val}, limit: 0}))\n  call assert_equal([{'id': 5, 'val': 'crayon'}, {'id': 6, 'val': 'camera'}], l->matchfuzzy('c', #{key: 'val', limit: 0}))\n  call assert_equal([{'id': 5, 'val': 'crayon'}], l->matchfuzzy('c', #{text_cb: {v -> v.val}, limit: 1}))\n  call assert_equal([{'id': 5, 'val': 'crayon'}], l->matchfuzzy('c', #{key: 'val', limit: 1}))\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion != NULL)\n\treturn;\n\n#ifdef BUILD_DATE\n    char *date_time = BUILD_DATE;\n#else\n    char *date_time = __DATE__ \" \" __TIME__;\n#endif\n    char *msg = _(\"%s (%s, compiled %s)\");\n    size_t len = strlen(msg)\n\t+ strlen(VIM_VERSION_LONG_ONLY)\n\t+ strlen(VIM_VERSION_DATE_ONLY)\n\t+ strlen(date_time);\n\n    longVersion = alloc(len);\n    if (longVersion == NULL)\n\tlongVersion = VIM_VERSION_LONG;\n    else\n\tvim_snprintf(longVersion, len, msg,\n\t\tVIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * quickfix.c: functions for quickfix mode, using a file with error messages\n */\n\n#include \"vim.h\"\n\n#if defined(FEAT_QUICKFIX) || defined(PROTO)\n\nstruct dir_stack_T\n{\n    struct dir_stack_T\t*next;\n    char_u\t\t*dirname;\n};\n\n/*\n * For each error the next struct is allocated and linked in a list.\n */\ntypedef struct qfline_S qfline_T;\nstruct qfline_S\n{\n    qfline_T\t*qf_next;\t// pointer to next error in the list\n    qfline_T\t*qf_prev;\t// pointer to previous error in the list\n    linenr_T\tqf_lnum;\t// line number where the error occurred\n    linenr_T\tqf_end_lnum;\t// line number when the error has range or zero\n    int\t\tqf_fnum;\t// file number for the line\n    int\t\tqf_col;\t\t// column where the error occurred\n    int\t\tqf_end_col;\t// column when the error has range or zero\n    int\t\tqf_nr;\t\t// error number\n    char_u\t*qf_module;\t// module name for this error\n    char_u\t*qf_pattern;\t// search pattern for the error\n    char_u\t*qf_text;\t// description of the error\n    char_u\tqf_viscol;\t// set to TRUE if qf_col and qf_end_col is\n\t\t\t\t// screen column\n    char_u\tqf_cleared;\t// set to TRUE if line has been deleted\n    char_u\tqf_type;\t// type of the error (mostly 'E'); 1 for\n\t\t\t\t// :helpgrep\n    char_u\tqf_valid;\t// valid error message detected\n};\n\n/*\n * There is a stack of error lists.\n */\n#define LISTCOUNT   10\n#define INVALID_QFIDX (-1)\n#define INVALID_QFBUFNR (0)\n\n/*\n * Quickfix list type.\n */\ntypedef enum\n{\n    QFLT_QUICKFIX, // Quickfix list - global list\n    QFLT_LOCATION, // Location list - per window list\n    QFLT_INTERNAL  // Internal - Temporary list used by getqflist()/getloclist()\n} qfltype_T;\n\n/*\n * Quickfix/Location list definition\n * Contains a list of entries (qfline_T). qf_start points to the first entry\n * and qf_last points to the last entry. qf_count contains the list size.\n *\n * Usually the list contains one or more entries. But an empty list can be\n * created using setqflist()/setloclist() with a title and/or user context\n * information and entries can be added later using setqflist()/setloclist().\n */\ntypedef struct qf_list_S\n{\n    int_u\tqf_id;\t\t// Unique identifier for this list\n    qfltype_T\tqfl_type;\n    qfline_T\t*qf_start;\t// pointer to the first error\n    qfline_T\t*qf_last;\t// pointer to the last error\n    qfline_T\t*qf_ptr;\t// pointer to the current error\n    int\t\tqf_count;\t// number of errors (0 means empty list)\n    int\t\tqf_index;\t// current index in the error list\n    int\t\tqf_nonevalid;\t// TRUE if not a single valid entry found\n    char_u\t*qf_title;\t// title derived from the command that created\n\t\t\t\t// the error list or set by setqflist\n    typval_T\t*qf_ctx;\t// context set by setqflist/setloclist\n    callback_T  qf_qftf_cb;\t// 'quickfixtextfunc' callback function\n\n    struct dir_stack_T\t*qf_dir_stack;\n    char_u\t\t*qf_directory;\n    struct dir_stack_T\t*qf_file_stack;\n    char_u\t\t*qf_currfile;\n    int\t\t\tqf_multiline;\n    int\t\t\tqf_multiignore;\n    int\t\t\tqf_multiscan;\n    long\t\tqf_changedtick;\n} qf_list_T;\n\n/*\n * Quickfix/Location list stack definition\n * Contains a list of quickfix/location lists (qf_list_T)\n */\nstruct qf_info_S\n{\n    // Count of references to this list. Used only for location lists.\n    // When a location list window reference this list, qf_refcount\n    // will be 2. Otherwise, qf_refcount will be 1. When qf_refcount\n    // reaches 0, the list is freed.\n    int\t\tqf_refcount;\n    int\t\tqf_listcount;\t    // current number of lists\n    int\t\tqf_curlist;\t    // current error list\n    qf_list_T\tqf_lists[LISTCOUNT];\n    qfltype_T\tqfl_type;\t    // type of list\n    int\t\tqf_bufnr;\t    // quickfix window buffer number\n};\n\nstatic qf_info_T ql_info;\t// global quickfix list\nstatic int_u last_qf_id = 0;\t// Last used quickfix list id\n\n#define FMT_PATTERNS 13\t\t// maximum number of % recognized\n\n/*\n * Structure used to hold the info of one part of 'errorformat'\n */\ntypedef struct efm_S efm_T;\nstruct efm_S\n{\n    regprog_T\t    *prog;\t// pre-formatted part of 'errorformat'\n    efm_T\t    *next;\t// pointer to next (NULL if last)\n    char_u\t    addr[FMT_PATTERNS]; // indices of used % patterns\n    char_u\t    prefix;\t// prefix of this format line:\n\t\t\t\t//   'D' enter directory\n\t\t\t\t//   'X' leave directory\n\t\t\t\t//   'A' start of multi-line message\n\t\t\t\t//   'E' error message\n\t\t\t\t//   'W' warning message\n\t\t\t\t//   'I' informational message\n\t\t\t\t//   'N' note message\n\t\t\t\t//   'C' continuation line\n\t\t\t\t//   'Z' end of multi-line message\n\t\t\t\t//   'G' general, unspecific message\n\t\t\t\t//   'P' push file (partial) message\n\t\t\t\t//   'Q' pop/quit file (partial) message\n\t\t\t\t//   'O' overread (partial) message\n    char_u\t    flags;\t// additional flags given in prefix\n\t\t\t\t//   '-' do not include this line\n\t\t\t\t//   '+' include whole line in message\n    int\t\t    conthere;\t// %> used\n};\n\n// List of location lists to be deleted.\n// Used to delay the deletion of locations lists by autocmds.\ntypedef struct qf_delq_S\n{\n    struct qf_delq_S\t*next;\n    qf_info_T\t\t*qi;\n} qf_delq_T;\nstatic qf_delq_T *qf_delq_head = NULL;\n\n// Counter to prevent autocmds from freeing up location lists when they are\n// still being used.\nstatic int\tquickfix_busy = 0;\n\nstatic efm_T\t*fmt_start = NULL; // cached across qf_parse_line() calls\n\n// callback function for 'quickfixtextfunc'\nstatic callback_T qftf_cb;\n\nstatic void\tqf_new_list(qf_info_T *qi, char_u *qf_title);\nstatic int\tqf_add_entry(qf_list_T *qfl, char_u *dir, char_u *fname, char_u *module, int bufnum, char_u *mesg, long lnum, long end_lnum, int col, int end_col, int vis_col, char_u *pattern, int nr, int type, int valid);\nstatic void\tqf_free(qf_list_T *qfl);\nstatic char_u\t*qf_types(int, int);\nstatic int\tqf_get_fnum(qf_list_T *qfl, char_u *, char_u *);\nstatic char_u\t*qf_push_dir(char_u *, struct dir_stack_T **, int is_file_stack);\nstatic char_u\t*qf_pop_dir(struct dir_stack_T **);\nstatic char_u\t*qf_guess_filepath(qf_list_T *qfl, char_u *);\nstatic void\tqf_jump_newwin(qf_info_T *qi, int dir, int errornr, int forceit, int newwin);\nstatic void\tqf_fmt_text(garray_T *gap, char_u *text);\nstatic void\tqf_range_text(garray_T *gap, qfline_T *qfp);\nstatic int\tqf_win_pos_update(qf_info_T *qi, int old_qf_index);\nstatic win_T\t*qf_find_win(qf_info_T *qi);\nstatic buf_T\t*qf_find_buf(qf_info_T *qi);\nstatic void\tqf_update_buffer(qf_info_T *qi, qfline_T *old_last);\nstatic void\tqf_fill_buffer(qf_list_T *qfl, buf_T *buf, qfline_T *old_last, int qf_winid);\nstatic buf_T\t*load_dummy_buffer(char_u *fname, char_u *dirname_start, char_u *resulting_dir);\nstatic void\twipe_dummy_buffer(buf_T *buf, char_u *dirname_start);\nstatic void\tunload_dummy_buffer(buf_T *buf, char_u *dirname_start);\nstatic qf_info_T *ll_get_or_alloc_list(win_T *);\n\n// Quickfix window check helper macro\n#define IS_QF_WINDOW(wp) (bt_quickfix((wp)->w_buffer) && (wp)->w_llist_ref == NULL)\n// Location list window check helper macro\n#define IS_LL_WINDOW(wp) (bt_quickfix((wp)->w_buffer) && (wp)->w_llist_ref != NULL)\n\n// Quickfix and location list stack check helper macros\n#define IS_QF_STACK(qi)\t\t((qi)->qfl_type == QFLT_QUICKFIX)\n#define IS_LL_STACK(qi)\t\t((qi)->qfl_type == QFLT_LOCATION)\n#define IS_QF_LIST(qfl)\t\t((qfl)->qfl_type == QFLT_QUICKFIX)\n#define IS_LL_LIST(qfl)\t\t((qfl)->qfl_type == QFLT_LOCATION)\n\n/*\n * Return location list for window 'wp'\n * For location list window, return the referenced location list\n */\n#define GET_LOC_LIST(wp) (IS_LL_WINDOW(wp) ? (wp)->w_llist_ref : (wp)->w_llist)\n\n// Macro to loop through all the items in a quickfix list\n// Quickfix item index starts from 1, so i below starts at 1\n#define FOR_ALL_QFL_ITEMS(qfl, qfp, i) \\\n\t\t    for ((i) = 1, (qfp) = (qfl)->qf_start; \\\n\t\t\t    !got_int && (i) <= (qfl)->qf_count && (qfp) != NULL; \\\n\t\t\t    ++(i), (qfp) = (qfp)->qf_next)\n\n/*\n * Looking up a buffer can be slow if there are many.  Remember the last one\n * to make this a lot faster if there are multiple matches in the same file.\n */\nstatic char_u   *qf_last_bufname = NULL;\nstatic bufref_T  qf_last_bufref = {NULL, 0, 0};\n\nstatic garray_T qfga;\n\n/*\n * Get a growarray to buffer text in.  Shared between various commands to avoid\n * many alloc/free calls.\n */\n    static garray_T *\nqfga_get(void)\n{\n    static int initialized = FALSE;\n\n    if (!initialized)\n    {\n\tinitialized = TRUE;\n\tga_init2(&qfga, 1, 256);\n    }\n\n    // Reset the length to zero.  Retain ga_data from previous use to avoid\n    // many alloc/free calls.\n    qfga.ga_len = 0;\n\n    return &qfga;\n}\n\n/*\n * The \"qfga\" grow array buffer is reused across multiple quickfix commands as\n * a temporary buffer to reduce the number of alloc/free calls.  But if the\n * buffer size is large, then to avoid holding on to that memory, clear the\n * grow array.  Otherwise just reset the grow array length.\n */\n    static void\nqfga_clear(void)\n{\n    if (qfga.ga_maxlen > 1000)\n\tga_clear(&qfga);\n    else\n\tqfga.ga_len = 0;\n}\n\n/*\n * Maximum number of bytes allowed per line while reading a errorfile.\n */\n#define LINE_MAXLEN 4096\n\n/*\n * Patterns used.  Keep in sync with qf_parse_fmt[].\n */\nstatic struct fmtpattern\n{\n    char_u\tconvchar;\n    char\t*pattern;\n} fmt_pat[FMT_PATTERNS] =\n    {\n\t{'f', \".\\\\+\"},\t    // only used when at end\n\t{'n', \"\\\\d\\\\+\"},\t// 1\n\t{'l', \"\\\\d\\\\+\"},\t// 2\n\t{'e', \"\\\\d\\\\+\"},\t// 3\n\t{'c', \"\\\\d\\\\+\"},\t// 4\n\t{'k', \"\\\\d\\\\+\"},\t// 5\n\t{'t', \".\"},\t\t// 6\n#define FMT_PATTERN_M 7\n\t{'m', \".\\\\+\"},\t\t// 7\n#define FMT_PATTERN_R 8\n\t{'r', \".*\"},\t\t// 8\n\t{'p', \"[-\t .]*\"},\t// 9\n\t{'v', \"\\\\d\\\\+\"},\t// 10\n\t{'s', \".\\\\+\"},\t\t// 11\n\t{'o', \".\\\\+\"}\t\t// 12\n    };\n\n/*\n * Convert an errorformat pattern to a regular expression pattern.\n * See fmt_pat definition above for the list of supported patterns.  The\n * pattern specifier is supplied in \"efmpat\".  The converted pattern is stored\n * in \"regpat\".  Returns a pointer to the location after the pattern.\n */\n    static char_u *\nefmpat_to_regpat(\n\tchar_u\t*efmpat,\n\tchar_u\t*regpat,\n\tefm_T\t*efminfo,\n\tint\tidx,\n\tint\tround)\n{\n    char_u\t*srcptr;\n\n    if (efminfo->addr[idx])\n    {\n\t// Each errorformat pattern can occur only once\n\tsemsg(_(e_too_many_chr_in_format_string), *efmpat);\n\treturn NULL;\n    }\n    if ((idx && idx < FMT_PATTERN_R\n\t\t&& vim_strchr((char_u *)\"DXOPQ\", efminfo->prefix) != NULL)\n\t    || (idx == FMT_PATTERN_R\n\t\t&& vim_strchr((char_u *)\"OPQ\", efminfo->prefix) == NULL))\n    {\n\tsemsg(_(e_unexpected_chr_in_format_str), *efmpat);\n\treturn NULL;\n    }\n    efminfo->addr[idx] = (char_u)++round;\n    *regpat++ = '\\\\';\n    *regpat++ = '(';\n#ifdef BACKSLASH_IN_FILENAME\n    if (*efmpat == 'f')\n    {\n\t// Also match \"c:\" in the file name, even when\n\t// checking for a colon next: \"%f:\".\n\t// \"\\%(\\a:\\)\\=\"\n\tSTRCPY(regpat, \"\\\\%(\\\\a:\\\\)\\\\=\");\n\tregpat += 10;\n    }\n#endif\n    if (*efmpat == 'f' && efmpat[1] != NUL)\n    {\n\tif (efmpat[1] != '\\\\' && efmpat[1] != '%')\n\t{\n\t    // A file name may contain spaces, but this isn't\n\t    // in \"\\f\".  For \"%f:%l:%m\" there may be a \":\" in\n\t    // the file name.  Use \".\\{-1,}x\" instead (x is\n\t    // the next character), the requirement that :999:\n\t    // follows should work.\n\t    STRCPY(regpat, \".\\\\{-1,}\");\n\t    regpat += 7;\n\t}\n\telse\n\t{\n\t    // File name followed by '\\\\' or '%': include as\n\t    // many file name chars as possible.\n\t    STRCPY(regpat, \"\\\\f\\\\+\");\n\t    regpat += 4;\n\t}\n    }\n    else\n    {\n\tsrcptr = (char_u *)fmt_pat[idx].pattern;\n\twhile ((*regpat = *srcptr++) != NUL)\n\t    ++regpat;\n    }\n    *regpat++ = '\\\\';\n    *regpat++ = ')';\n\n    return regpat;\n}\n\n/*\n * Convert a scanf like format in 'errorformat' to a regular expression.\n * Returns a pointer to the location after the pattern.\n */\n    static char_u *\nscanf_fmt_to_regpat(\n\tchar_u\t**pefmp,\n\tchar_u\t*efm,\n\tint\tlen,\n\tchar_u\t*regpat)\n{\n    char_u\t*efmp = *pefmp;\n\n    if (*efmp == '[' || *efmp == '\\\\')\n    {\n\tif ((*regpat++ = *efmp) == '[')\t// %*[^a-z0-9] etc.\n\t{\n\t    if (efmp[1] == '^')\n\t\t*regpat++ = *++efmp;\n\t    if (efmp < efm + len)\n\t    {\n\t\t*regpat++ = *++efmp;\t    // could be ']'\n\t\twhile (efmp < efm + len\n\t\t\t&& (*regpat++ = *++efmp) != ']')\n\t\t    // skip ;\n\t\tif (efmp == efm + len)\n\t\t{\n\t\t    emsg(_(e_missing_rsb_in_format_string));\n\t\t    return NULL;\n\t\t}\n\t    }\n\t}\n\telse if (efmp < efm + len)\t// %*\\D, %*\\s etc.\n\t    *regpat++ = *++efmp;\n\t*regpat++ = '\\\\';\n\t*regpat++ = '+';\n    }\n    else\n    {\n\t// TODO: scanf()-like: %*ud, %*3c, %*f, ... ?\n\tsemsg(_(e_unsupported_chr_in_format_string), *efmp);\n\treturn NULL;\n    }\n\n    *pefmp = efmp;\n\n    return regpat;\n}\n\n/*\n * Analyze/parse an errorformat prefix.\n */\n    static char_u *\nefm_analyze_prefix(char_u *efmp, efm_T *efminfo)\n{\n    if (vim_strchr((char_u *)\"+-\", *efmp) != NULL)\n\tefminfo->flags = *efmp++;\n    if (vim_strchr((char_u *)\"DXAEWINCZGOPQ\", *efmp) != NULL)\n\tefminfo->prefix = *efmp;\n    else\n    {\n\tsemsg(_(e_invalid_chr_in_format_string_prefix), *efmp);\n\treturn NULL;\n    }\n\n    return efmp;\n}\n\n/*\n * Converts a 'errorformat' string part in 'efm' to a regular expression\n * pattern.  The resulting regex pattern is returned in \"regpat\". Additional\n * information about the 'erroformat' pattern is returned in \"fmt_ptr\".\n * Returns OK or FAIL.\n */\n    static int\nefm_to_regpat(\n\tchar_u\t*efm,\n\tint\tlen,\n\tefm_T\t*fmt_ptr,\n\tchar_u\t*regpat)\n{\n    char_u\t*ptr;\n    char_u\t*efmp;\n    int\t\tround;\n    int\t\tidx = 0;\n\n    // Build a regexp pattern for a 'errorformat' option part\n    ptr = regpat;\n    *ptr++ = '^';\n    round = 0;\n    for (efmp = efm; efmp < efm + len; ++efmp)\n    {\n\tif (*efmp == '%')\n\t{\n\t    ++efmp;\n\t    for (idx = 0; idx < FMT_PATTERNS; ++idx)\n\t\tif (fmt_pat[idx].convchar == *efmp)\n\t\t    break;\n\t    if (idx < FMT_PATTERNS)\n\t    {\n\t\tptr = efmpat_to_regpat(efmp, ptr, fmt_ptr, idx, round);\n\t\tif (ptr == NULL)\n\t\t    return FAIL;\n\t\tround++;\n\t    }\n\t    else if (*efmp == '*')\n\t    {\n\t\t++efmp;\n\t\tptr = scanf_fmt_to_regpat(&efmp, efm, len, ptr);\n\t\tif (ptr == NULL)\n\t\t    return FAIL;\n\t    }\n\t    else if (vim_strchr((char_u *)\"%\\\\.^$~[\", *efmp) != NULL)\n\t\t*ptr++ = *efmp;\t\t// regexp magic characters\n\t    else if (*efmp == '#')\n\t\t*ptr++ = '*';\n\t    else if (*efmp == '>')\n\t\tfmt_ptr->conthere = TRUE;\n\t    else if (efmp == efm + 1)\t\t// analyse prefix\n\t    {\n\t\t// prefix is allowed only at the beginning of the errorformat\n\t\t// option part\n\t\tefmp = efm_analyze_prefix(efmp, fmt_ptr);\n\t\tif (efmp == NULL)\n\t\t    return FAIL;\n\t    }\n\t    else\n\t    {\n\t\tsemsg(_(e_invalid_chr_in_format_string), *efmp);\n\t\treturn FAIL;\n\t    }\n\t}\n\telse\t\t\t// copy normal character\n\t{\n\t    if (*efmp == '\\\\' && efmp + 1 < efm + len)\n\t\t++efmp;\n\t    else if (vim_strchr((char_u *)\".*^$~[\", *efmp) != NULL)\n\t\t*ptr++ = '\\\\';\t// escape regexp atoms\n\t    if (*efmp)\n\t\t*ptr++ = *efmp;\n\t}\n    }\n    *ptr++ = '$';\n    *ptr = NUL;\n\n    return OK;\n}\n\n/*\n * Free the 'errorformat' information list\n */\n    static void\nfree_efm_list(efm_T **efm_first)\n{\n    efm_T *efm_ptr;\n\n    for (efm_ptr = *efm_first; efm_ptr != NULL; efm_ptr = *efm_first)\n    {\n\t*efm_first = efm_ptr->next;\n\tvim_regfree(efm_ptr->prog);\n\tvim_free(efm_ptr);\n    }\n    fmt_start = NULL;\n}\n\n/*\n * Compute the size of the buffer used to convert a 'errorformat' pattern into\n * a regular expression pattern.\n */\n    static int\nefm_regpat_bufsz(char_u *efm)\n{\n    int sz;\n    int i;\n\n    sz = (FMT_PATTERNS * 3) + ((int)STRLEN(efm) << 2);\n    for (i = FMT_PATTERNS; i > 0; )\n\tsz += (int)STRLEN(fmt_pat[--i].pattern);\n#ifdef BACKSLASH_IN_FILENAME\n    sz += 12; // \"%f\" can become twelve chars longer (see efm_to_regpat)\n#else\n    sz += 2; // \"%f\" can become two chars longer\n#endif\n\n    return sz;\n}\n\n/*\n * Return the length of a 'errorformat' option part (separated by \",\").\n */\n    static int\nefm_option_part_len(char_u *efm)\n{\n    int len;\n\n    for (len = 0; efm[len] != NUL && efm[len] != ','; ++len)\n\tif (efm[len] == '\\\\' && efm[len + 1] != NUL)\n\t    ++len;\n\n    return len;\n}\n\n/*\n * Parse the 'errorformat' option. Multiple parts in the 'errorformat' option\n * are parsed and converted to regular expressions. Returns information about\n * the parsed 'errorformat' option.\n */\n    static efm_T *\nparse_efm_option(char_u *efm)\n{\n    efm_T\t*fmt_ptr = NULL;\n    efm_T\t*fmt_first = NULL;\n    efm_T\t*fmt_last = NULL;\n    char_u\t*fmtstr = NULL;\n    int\t\tlen;\n    int\t\tsz;\n\n    // Each part of the format string is copied and modified from errorformat\n    // to regex prog.  Only a few % characters are allowed.\n\n    // Get some space to modify the format string into.\n    sz = efm_regpat_bufsz(efm);\n    if ((fmtstr = alloc_id(sz, aid_qf_efm_fmtstr)) == NULL)\n\tgoto parse_efm_error;\n\n    while (efm[0] != NUL)\n    {\n\t// Allocate a new eformat structure and put it at the end of the list\n\tfmt_ptr = ALLOC_CLEAR_ONE_ID(efm_T, aid_qf_efm_fmtpart);\n\tif (fmt_ptr == NULL)\n\t    goto parse_efm_error;\n\tif (fmt_first == NULL)\t    // first one\n\t    fmt_first = fmt_ptr;\n\telse\n\t    fmt_last->next = fmt_ptr;\n\tfmt_last = fmt_ptr;\n\n\t// Isolate one part in the 'errorformat' option\n\tlen = efm_option_part_len(efm);\n\n\tif (efm_to_regpat(efm, len, fmt_ptr, fmtstr) == FAIL)\n\t    goto parse_efm_error;\n\tif ((fmt_ptr->prog = vim_regcomp(fmtstr, RE_MAGIC + RE_STRING)) == NULL)\n\t    goto parse_efm_error;\n\t// Advance to next part\n\tefm = skip_to_option_part(efm + len);\t// skip comma and spaces\n    }\n\n    if (fmt_first == NULL)\t// nothing found\n\temsg(_(e_errorformat_contains_no_pattern));\n\n    goto parse_efm_end;\n\nparse_efm_error:\n    free_efm_list(&fmt_first);\n\nparse_efm_end:\n    vim_free(fmtstr);\n\n    return fmt_first;\n}\n\nenum {\n    QF_FAIL = 0,\n    QF_OK = 1,\n    QF_END_OF_INPUT = 2,\n    QF_NOMEM = 3,\n    QF_IGNORE_LINE = 4,\n    QF_MULTISCAN = 5,\n    QF_ABORT = 6\n};\n\n/*\n * State information used to parse lines and add entries to a quickfix/location\n * list.\n */\ntypedef struct {\n    char_u\t*linebuf;\n    int\t\tlinelen;\n    char_u\t*growbuf;\n    int\t\tgrowbufsiz;\n    FILE\t*fd;\n    typval_T\t*tv;\n    char_u\t*p_str;\n    listitem_T\t*p_li;\n    buf_T\t*buf;\n    linenr_T\tbuflnum;\n    linenr_T\tlnumlast;\n    vimconv_T\tvc;\n} qfstate_T;\n\n/*\n * Allocate more memory for the line buffer used for parsing lines.\n */\n    static char_u *\nqf_grow_linebuf(qfstate_T *state, int newsz)\n{\n    char_u\t*p;\n\n    // If the line exceeds LINE_MAXLEN exclude the last\n    // byte since it's not a NL character.\n    state->linelen = newsz > LINE_MAXLEN ? LINE_MAXLEN - 1 : newsz;\n    if (state->growbuf == NULL)\n    {\n\tstate->growbuf = alloc_id(state->linelen + 1, aid_qf_linebuf);\n\tif (state->growbuf == NULL)\n\t    return NULL;\n\tstate->growbufsiz = state->linelen;\n    }\n    else if (state->linelen > state->growbufsiz)\n    {\n\tif ((p = vim_realloc(state->growbuf, state->linelen + 1)) == NULL)\n\t    return NULL;\n\tstate->growbuf = p;\n\tstate->growbufsiz = state->linelen;\n    }\n    return state->growbuf;\n}\n\n/*\n * Get the next string (separated by newline) from state->p_str.\n */\n    static int\nqf_get_next_str_line(qfstate_T *state)\n{\n    // Get the next line from the supplied string\n    char_u\t*p_str = state->p_str;\n    char_u\t*p;\n    int\t\tlen;\n\n    if (*p_str == NUL) // Reached the end of the string\n\treturn QF_END_OF_INPUT;\n\n    p = vim_strchr(p_str, '\\n');\n    if (p != NULL)\n\tlen = (int)(p - p_str) + 1;\n    else\n\tlen = (int)STRLEN(p_str);\n\n    if (len > IOSIZE - 2)\n    {\n\tstate->linebuf = qf_grow_linebuf(state, len);\n\tif (state->linebuf == NULL)\n\t    return QF_NOMEM;\n    }\n    else\n    {\n\tstate->linebuf = IObuff;\n\tstate->linelen = len;\n    }\n    vim_strncpy(state->linebuf, p_str, state->linelen);\n\n    // Increment using len in order to discard the rest of the\n    // line if it exceeds LINE_MAXLEN.\n    p_str += len;\n    state->p_str = p_str;\n\n    return QF_OK;\n}\n\n/*\n * Get the next string from the List item state->p_li.\n */\n    static int\nqf_get_next_list_line(qfstate_T *state)\n{\n    listitem_T\t*p_li = state->p_li;\n    int\t\tlen;\n\n    while (p_li != NULL\n\t    && (p_li->li_tv.v_type != VAR_STRING\n\t\t|| p_li->li_tv.vval.v_string == NULL))\n\tp_li = p_li->li_next;\t// Skip non-string items\n\n    if (p_li == NULL)\t\t// End of the list\n    {\n\tstate->p_li = NULL;\n\treturn QF_END_OF_INPUT;\n    }\n\n    len = (int)STRLEN(p_li->li_tv.vval.v_string);\n    if (len > IOSIZE - 2)\n    {\n\tstate->linebuf = qf_grow_linebuf(state, len);\n\tif (state->linebuf == NULL)\n\t    return QF_NOMEM;\n    }\n    else\n    {\n\tstate->linebuf = IObuff;\n\tstate->linelen = len;\n    }\n\n    vim_strncpy(state->linebuf, p_li->li_tv.vval.v_string, state->linelen);\n\n    state->p_li = p_li->li_next;\t// next item\n    return QF_OK;\n}\n\n/*\n * Get the next string from state->buf.\n */\n    static int\nqf_get_next_buf_line(qfstate_T *state)\n{\n    char_u\t*p_buf = NULL;\n    int\t\tlen;\n\n    // Get the next line from the supplied buffer\n    if (state->buflnum > state->lnumlast)\n\treturn QF_END_OF_INPUT;\n\n    p_buf = ml_get_buf(state->buf, state->buflnum, FALSE);\n    state->buflnum += 1;\n\n    len = (int)STRLEN(p_buf);\n    if (len > IOSIZE - 2)\n    {\n\tstate->linebuf = qf_grow_linebuf(state, len);\n\tif (state->linebuf == NULL)\n\t    return QF_NOMEM;\n    }\n    else\n    {\n\tstate->linebuf = IObuff;\n\tstate->linelen = len;\n    }\n    vim_strncpy(state->linebuf, p_buf, state->linelen);\n\n    return QF_OK;\n}\n\n/*\n * Get the next string from file state->fd.\n */\n    static int\nqf_get_next_file_line(qfstate_T *state)\n{\n    int\t    discard;\n    int\t    growbuflen;\n\n    if (fgets((char *)IObuff, IOSIZE, state->fd) == NULL)\n\treturn QF_END_OF_INPUT;\n\n    discard = FALSE;\n    state->linelen = (int)STRLEN(IObuff);\n    if (state->linelen == IOSIZE - 1 && !(IObuff[state->linelen - 1] == '\\n'))\n    {\n\t// The current line exceeds IObuff, continue reading using\n\t// growbuf until EOL or LINE_MAXLEN bytes is read.\n\tif (state->growbuf == NULL)\n\t{\n\t    state->growbufsiz = 2 * (IOSIZE - 1);\n\t    state->growbuf = alloc_id(state->growbufsiz, aid_qf_linebuf);\n\t    if (state->growbuf == NULL)\n\t\treturn QF_NOMEM;\n\t}\n\n\t// Copy the read part of the line, excluding null-terminator\n\tmemcpy(state->growbuf, IObuff, IOSIZE - 1);\n\tgrowbuflen = state->linelen;\n\n\tfor (;;)\n\t{\n\t    char_u\t*p;\n\n\t    if (fgets((char *)state->growbuf + growbuflen,\n\t\t\tstate->growbufsiz - growbuflen, state->fd) == NULL)\n\t\tbreak;\n\t    state->linelen = (int)STRLEN(state->growbuf + growbuflen);\n\t    growbuflen += state->linelen;\n\t    if ((state->growbuf)[growbuflen - 1] == '\\n')\n\t\tbreak;\n\t    if (state->growbufsiz == LINE_MAXLEN)\n\t    {\n\t\tdiscard = TRUE;\n\t\tbreak;\n\t    }\n\n\t    state->growbufsiz = 2 * state->growbufsiz < LINE_MAXLEN\n\t\t? 2 * state->growbufsiz : LINE_MAXLEN;\n\t    if ((p = vim_realloc(state->growbuf, state->growbufsiz)) == NULL)\n\t\treturn QF_NOMEM;\n\t    state->growbuf = p;\n\t}\n\n\twhile (discard)\n\t{\n\t    // The current line is longer than LINE_MAXLEN, continue\n\t    // reading but discard everything until EOL or EOF is\n\t    // reached.\n\t    if (fgets((char *)IObuff, IOSIZE, state->fd) == NULL\n\t\t    || (int)STRLEN(IObuff) < IOSIZE - 1\n\t\t    || IObuff[IOSIZE - 2] == '\\n')\n\t\tbreak;\n\t}\n\n\tstate->linebuf = state->growbuf;\n\tstate->linelen = growbuflen;\n    }\n    else\n\tstate->linebuf = IObuff;\n\n    // Convert a line if it contains a non-ASCII character.\n    if (state->vc.vc_type != CONV_NONE && has_non_ascii(state->linebuf))\n    {\n\tchar_u\t*line;\n\n\tline = string_convert(&state->vc, state->linebuf, &state->linelen);\n\tif (line != NULL)\n\t{\n\t    if (state->linelen < IOSIZE)\n\t    {\n\t\tSTRCPY(state->linebuf, line);\n\t\tvim_free(line);\n\t    }\n\t    else\n\t    {\n\t\tvim_free(state->growbuf);\n\t\tstate->linebuf = state->growbuf = line;\n\t\tstate->growbufsiz = state->linelen < LINE_MAXLEN\n\t\t\t\t\t\t? state->linelen : LINE_MAXLEN;\n\t    }\n\t}\n    }\n\n    return QF_OK;\n}\n\n/*\n * Get the next string from a file/buffer/list/string.\n */\n    static int\nqf_get_nextline(qfstate_T *state)\n{\n    int status = QF_FAIL;\n\n    if (state->fd == NULL)\n    {\n\tif (state->tv != NULL)\n\t{\n\t    if (state->tv->v_type == VAR_STRING)\n\t\t// Get the next line from the supplied string\n\t\tstatus = qf_get_next_str_line(state);\n\t    else if (state->tv->v_type == VAR_LIST)\n\t\t// Get the next line from the supplied list\n\t\tstatus = qf_get_next_list_line(state);\n\t}\n\telse\n\t    // Get the next line from the supplied buffer\n\t    status = qf_get_next_buf_line(state);\n    }\n    else\n\t// Get the next line from the supplied file\n\tstatus = qf_get_next_file_line(state);\n\n    if (status != QF_OK)\n\treturn status;\n\n    // remove newline/CR from the line\n    if (state->linelen > 0 && state->linebuf[state->linelen - 1] == '\\n')\n    {\n\tstate->linebuf[state->linelen - 1] = NUL;\n#ifdef USE_CRNL\n\tif (state->linelen > 1 && state->linebuf[state->linelen - 2] == '\\r')\n\t    state->linebuf[state->linelen - 2] = NUL;\n#endif\n    }\n\n    remove_bom(state->linebuf);\n\n    return QF_OK;\n}\n\ntypedef struct {\n    char_u\t*namebuf;\n    char_u\t*module;\n    char_u\t*errmsg;\n    int\t\terrmsglen;\n    long\tlnum;\n    long\tend_lnum;\n    int\t\tcol;\n    int\t\tend_col;\n    char_u\tuse_viscol;\n    char_u\t*pattern;\n    int\t\tenr;\n    int\t\ttype;\n    int\t\tvalid;\n} qffields_T;\n\n/*\n * Parse the match for filename ('%f') pattern in regmatch.\n * Return the matched value in \"fields->namebuf\".\n */\n    static int\nqf_parse_fmt_f(regmatch_T *rmp, int midx, qffields_T *fields, int prefix)\n{\n    int c;\n\n    if (rmp->startp[midx] == NULL || rmp->endp[midx] == NULL)\n\treturn QF_FAIL;\n\n    // Expand ~/file and $HOME/file to full path.\n    c = *rmp->endp[midx];\n    *rmp->endp[midx] = NUL;\n    expand_env(rmp->startp[midx], fields->namebuf, CMDBUFFSIZE);\n    *rmp->endp[midx] = c;\n\n    // For separate filename patterns (%O, %P and %Q), the specified file\n    // should exist.\n    if (vim_strchr((char_u *)\"OPQ\", prefix) != NULL\n\t    && mch_getperm(fields->namebuf) == -1)\n\treturn QF_FAIL;\n\n    return QF_OK;\n}\n\n/*\n * Parse the match for error number ('%n') pattern in regmatch.\n * Return the matched value in \"fields->enr\".\n */\n    static int\nqf_parse_fmt_n(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    if (rmp->startp[midx] == NULL)\n\treturn QF_FAIL;\n    fields->enr = (int)atol((char *)rmp->startp[midx]);\n    return QF_OK;\n}\n\n/*\n * Parse the match for line number ('%l') pattern in regmatch.\n * Return the matched value in \"fields->lnum\".\n */\n    static int\nqf_parse_fmt_l(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    if (rmp->startp[midx] == NULL)\n\treturn QF_FAIL;\n    fields->lnum = atol((char *)rmp->startp[midx]);\n    return QF_OK;\n}\n\n/*\n * Parse the match for end line number ('%e') pattern in regmatch.\n * Return the matched value in \"fields->end_lnum\".\n */\n    static int\nqf_parse_fmt_e(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    if (rmp->startp[midx] == NULL)\n\treturn QF_FAIL;\n    fields->end_lnum = atol((char *)rmp->startp[midx]);\n    return QF_OK;\n}\n\n/*\n * Parse the match for column number ('%c') pattern in regmatch.\n * Return the matched value in \"fields->col\".\n */\n    static int\nqf_parse_fmt_c(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    if (rmp->startp[midx] == NULL)\n\treturn QF_FAIL;\n    fields->col = (int)atol((char *)rmp->startp[midx]);\n    return QF_OK;\n}\n\n/*\n * Parse the match for end column number ('%k') pattern in regmatch.\n * Return the matched value in \"fields->end_col\".\n */\n    static int\nqf_parse_fmt_k(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    if (rmp->startp[midx] == NULL)\n\treturn QF_FAIL;\n    fields->end_col = (int)atol((char *)rmp->startp[midx]);\n    return QF_OK;\n}\n\n/*\n * Parse the match for error type ('%t') pattern in regmatch.\n * Return the matched value in \"fields->type\".\n */\n    static int\nqf_parse_fmt_t(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    if (rmp->startp[midx] == NULL)\n\treturn QF_FAIL;\n    fields->type = *rmp->startp[midx];\n    return QF_OK;\n}\n\n/*\n * Copy a non-error line into the error string.  Return the matched line in\n * \"fields->errmsg\".\n */\n    static int\ncopy_nonerror_line(char_u *linebuf, int linelen, qffields_T *fields)\n{\n    char_u\t*p;\n\n    if (linelen >= fields->errmsglen)\n    {\n\t// linelen + null terminator\n\tif ((p = vim_realloc(fields->errmsg, linelen + 1)) == NULL)\n\t    return QF_NOMEM;\n\tfields->errmsg = p;\n\tfields->errmsglen = linelen + 1;\n    }\n    // copy whole line to error message\n    vim_strncpy(fields->errmsg, linebuf, linelen);\n\n    return QF_OK;\n}\n\n/*\n * Parse the match for error message ('%m') pattern in regmatch.\n * Return the matched value in \"fields->errmsg\".\n */\n    static int\nqf_parse_fmt_m(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    char_u\t*p;\n    int\t\tlen;\n\n    if (rmp->startp[midx] == NULL || rmp->endp[midx] == NULL)\n\treturn QF_FAIL;\n    len = (int)(rmp->endp[midx] - rmp->startp[midx]);\n    if (len >= fields->errmsglen)\n    {\n\t// len + null terminator\n\tif ((p = vim_realloc(fields->errmsg, len + 1)) == NULL)\n\t    return QF_NOMEM;\n\tfields->errmsg = p;\n\tfields->errmsglen = len + 1;\n    }\n    vim_strncpy(fields->errmsg, rmp->startp[midx], len);\n    return QF_OK;\n}\n\n/*\n * Parse the match for rest of a single-line file message ('%r') pattern.\n * Return the matched value in \"tail\".\n */\n    static int\nqf_parse_fmt_r(regmatch_T *rmp, int midx, char_u **tail)\n{\n    if (rmp->startp[midx] == NULL)\n\treturn QF_FAIL;\n    *tail = rmp->startp[midx];\n    return QF_OK;\n}\n\n/*\n * Parse the match for the pointer line ('%p') pattern in regmatch.\n * Return the matched value in \"fields->col\".\n */\n    static int\nqf_parse_fmt_p(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    char_u\t*match_ptr;\n\n    if (rmp->startp[midx] == NULL || rmp->endp[midx] == NULL)\n\treturn QF_FAIL;\n    fields->col = 0;\n    for (match_ptr = rmp->startp[midx]; match_ptr != rmp->endp[midx];\n\t\t\t\t\t\t\t\t++match_ptr)\n    {\n\t++fields->col;\n\tif (*match_ptr == TAB)\n\t{\n\t    fields->col += 7;\n\t    fields->col -= fields->col % 8;\n\t}\n    }\n    ++fields->col;\n    fields->use_viscol = TRUE;\n    return QF_OK;\n}\n\n/*\n * Parse the match for the virtual column number ('%v') pattern in regmatch.\n * Return the matched value in \"fields->col\".\n */\n    static int\nqf_parse_fmt_v(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    if (rmp->startp[midx] == NULL)\n\treturn QF_FAIL;\n    fields->col = (int)atol((char *)rmp->startp[midx]);\n    fields->use_viscol = TRUE;\n    return QF_OK;\n}\n\n/*\n * Parse the match for the search text ('%s') pattern in regmatch.\n * Return the matched value in \"fields->pattern\".\n */\n    static int\nqf_parse_fmt_s(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    int\t\tlen;\n\n    if (rmp->startp[midx] == NULL || rmp->endp[midx] == NULL)\n\treturn QF_FAIL;\n    len = (int)(rmp->endp[midx] - rmp->startp[midx]);\n    if (len > CMDBUFFSIZE - 5)\n\tlen = CMDBUFFSIZE - 5;\n    STRCPY(fields->pattern, \"^\\\\V\");\n    STRNCAT(fields->pattern, rmp->startp[midx], len);\n    fields->pattern[len + 3] = '\\\\';\n    fields->pattern[len + 4] = '$';\n    fields->pattern[len + 5] = NUL;\n    return QF_OK;\n}\n\n/*\n * Parse the match for the module ('%o') pattern in regmatch.\n * Return the matched value in \"fields->module\".\n */\n    static int\nqf_parse_fmt_o(regmatch_T *rmp, int midx, qffields_T *fields)\n{\n    int\t\tlen;\n\n    if (rmp->startp[midx] == NULL || rmp->endp[midx] == NULL)\n\treturn QF_FAIL;\n    len = (int)(rmp->endp[midx] - rmp->startp[midx]);\n    if (len > CMDBUFFSIZE)\n\tlen = CMDBUFFSIZE;\n    STRNCAT(fields->module, rmp->startp[midx], len);\n    return QF_OK;\n}\n\n/*\n * 'errorformat' format pattern parser functions.\n * The '%f' and '%r' formats are parsed differently from other formats.\n * See qf_parse_match() for details.\n * Keep in sync with fmt_pat[].\n */\nstatic int (*qf_parse_fmt[FMT_PATTERNS])(regmatch_T *, int, qffields_T *) =\n{\n    NULL, // %f\n    qf_parse_fmt_n,\n    qf_parse_fmt_l,\n    qf_parse_fmt_e,\n    qf_parse_fmt_c,\n    qf_parse_fmt_k,\n    qf_parse_fmt_t,\n    qf_parse_fmt_m,\n    NULL, // %r\n    qf_parse_fmt_p,\n    qf_parse_fmt_v,\n    qf_parse_fmt_s,\n    qf_parse_fmt_o\n};\n\n/*\n * Parse the error format pattern matches in \"regmatch\" and set the values in\n * \"fields\".  fmt_ptr contains the 'efm' format specifiers/prefixes that have a\n * match.  Returns QF_OK if all the matches are successfully parsed. On\n * failure, returns QF_FAIL or QF_NOMEM.\n */\n    static int\nqf_parse_match(\n\tchar_u\t\t*linebuf,\n\tint\t\tlinelen,\n\tefm_T\t\t*fmt_ptr,\n\tregmatch_T\t*regmatch,\n\tqffields_T\t*fields,\n\tint\t\tqf_multiline,\n\tint\t\tqf_multiscan,\n\tchar_u\t\t**tail)\n{\n    int\t\tidx = fmt_ptr->prefix;\n    int\t\ti;\n    int\t\tmidx;\n    int\t\tstatus;\n\n    if ((idx == 'C' || idx == 'Z') && !qf_multiline)\n\treturn QF_FAIL;\n    if (vim_strchr((char_u *)\"EWIN\", idx) != NULL)\n\tfields->type = idx;\n    else\n\tfields->type = 0;\n\n    // Extract error message data from matched line.\n    // We check for an actual submatch, because \"\\[\" and \"\\]\" in\n    // the 'errorformat' may cause the wrong submatch to be used.\n    for (i = 0; i < FMT_PATTERNS; i++)\n    {\n\tstatus = QF_OK;\n\tmidx = (int)fmt_ptr->addr[i];\n\tif (i == 0 && midx > 0)\t\t\t\t// %f\n\t    status = qf_parse_fmt_f(regmatch, midx, fields, idx);\n\telse if (i == FMT_PATTERN_M)\n\t{\n\t    if (fmt_ptr->flags == '+' && !qf_multiscan)\t// %+\n\t\tstatus = copy_nonerror_line(linebuf, linelen, fields);\n\t    else if (midx > 0)\t\t\t\t// %m\n\t\tstatus = qf_parse_fmt_m(regmatch, midx, fields);\n\t}\n\telse if (i == FMT_PATTERN_R && midx > 0)\t// %r\n\t    status = qf_parse_fmt_r(regmatch, midx, tail);\n\telse if (midx > 0)\t\t\t\t// others\n\t    status = (qf_parse_fmt[i])(regmatch, midx, fields);\n\n\tif (status != QF_OK)\n\t    return status;\n    }\n\n    return QF_OK;\n}\n\n/*\n * Parse an error line in 'linebuf' using a single error format string in\n * 'fmt_ptr->prog' and return the matching values in 'fields'.\n * Returns QF_OK if the efm format matches completely and the fields are\n * successfully copied. Otherwise returns QF_FAIL or QF_NOMEM.\n */\n    static int\nqf_parse_get_fields(\n\tchar_u\t\t*linebuf,\n\tint\t\tlinelen,\n\tefm_T\t\t*fmt_ptr,\n\tqffields_T\t*fields,\n\tint\t\tqf_multiline,\n\tint\t\tqf_multiscan,\n\tchar_u\t\t**tail)\n{\n    regmatch_T\tregmatch;\n    int\t\tstatus = QF_FAIL;\n    int\t\tr;\n\n    if (qf_multiscan &&\n\t\tvim_strchr((char_u *)\"OPQ\", fmt_ptr->prefix) == NULL)\n\treturn QF_FAIL;\n\n    fields->namebuf[0] = NUL;\n    fields->module[0] = NUL;\n    fields->pattern[0] = NUL;\n    if (!qf_multiscan)\n\tfields->errmsg[0] = NUL;\n    fields->lnum = 0;\n    fields->end_lnum = 0;\n    fields->col = 0;\n    fields->end_col = 0;\n    fields->use_viscol = FALSE;\n    fields->enr = -1;\n    fields->type = 0;\n    *tail = NULL;\n\n    // Always ignore case when looking for a matching error.\n    regmatch.rm_ic = TRUE;\n    regmatch.regprog = fmt_ptr->prog;\n    r = vim_regexec(&regmatch, linebuf, (colnr_T)0);\n    fmt_ptr->prog = regmatch.regprog;\n    if (r)\n\tstatus = qf_parse_match(linebuf, linelen, fmt_ptr, &regmatch,\n\t\tfields, qf_multiline, qf_multiscan, tail);\n\n    return status;\n}\n\n/*\n * Parse directory error format prefixes (%D and %X).\n * Push and pop directories from the directory stack when scanning directory\n * names.\n */\n    static int\nqf_parse_dir_pfx(int idx, qffields_T *fields, qf_list_T *qfl)\n{\n    if (idx == 'D')\t\t\t\t// enter directory\n    {\n\tif (*fields->namebuf == NUL)\n\t{\n\t    emsg(_(e_missing_or_empty_directory_name));\n\t    return QF_FAIL;\n\t}\n\tqfl->qf_directory =\n\t    qf_push_dir(fields->namebuf, &qfl->qf_dir_stack, FALSE);\n\tif (qfl->qf_directory == NULL)\n\t    return QF_FAIL;\n    }\n    else if (idx == 'X')\t\t\t// leave directory\n\tqfl->qf_directory = qf_pop_dir(&qfl->qf_dir_stack);\n\n    return QF_OK;\n}\n\n/*\n * Parse global file name error format prefixes (%O, %P and %Q).\n */\n    static int\nqf_parse_file_pfx(\n\tint idx,\n\tqffields_T *fields,\n\tqf_list_T *qfl,\n\tchar_u *tail)\n{\n    fields->valid = FALSE;\n    if (*fields->namebuf == NUL || mch_getperm(fields->namebuf) >= 0)\n    {\n\tif (*fields->namebuf && idx == 'P')\n\t    qfl->qf_currfile =\n\t\tqf_push_dir(fields->namebuf, &qfl->qf_file_stack, TRUE);\n\telse if (idx == 'Q')\n\t    qfl->qf_currfile = qf_pop_dir(&qfl->qf_file_stack);\n\t*fields->namebuf = NUL;\n\tif (tail && *tail)\n\t{\n\t    STRMOVE(IObuff, skipwhite(tail));\n\t    qfl->qf_multiscan = TRUE;\n\t    return QF_MULTISCAN;\n\t}\n    }\n\n    return QF_OK;\n}\n\n/*\n * Parse a non-error line (a line which doesn't match any of the error\n * format in 'efm').\n */\n    static int\nqf_parse_line_nomatch(char_u *linebuf, int linelen, qffields_T *fields)\n{\n    fields->namebuf[0] = NUL;\t// no match found, remove file name\n    fields->lnum = 0;\t\t// don't jump to this line\n    fields->valid = FALSE;\n\n    return copy_nonerror_line(linebuf, linelen, fields);\n}\n\n/*\n * Parse multi-line error format prefixes (%C and %Z)\n */\n    static int\nqf_parse_multiline_pfx(\n\tint idx,\n\tqf_list_T *qfl,\n\tqffields_T *fields)\n{\n    char_u\t\t*ptr;\n    int\t\t\tlen;\n\n    if (!qfl->qf_multiignore)\n    {\n\tqfline_T *qfprev = qfl->qf_last;\n\n\tif (qfprev == NULL)\n\t    return QF_FAIL;\n\tif (*fields->errmsg && !qfl->qf_multiignore)\n\t{\n\t    len = (int)STRLEN(qfprev->qf_text);\n\t    ptr = alloc_id(len + STRLEN(fields->errmsg) + 2,\n\t\t\t\t\t\taid_qf_multiline_pfx);\n\t    if (ptr == NULL)\n\t\treturn QF_FAIL;\n\t    STRCPY(ptr, qfprev->qf_text);\n\t    vim_free(qfprev->qf_text);\n\t    qfprev->qf_text = ptr;\n\t    *(ptr += len) = '\\n';\n\t    STRCPY(++ptr, fields->errmsg);\n\t}\n\tif (qfprev->qf_nr == -1)\n\t    qfprev->qf_nr = fields->enr;\n\tif (vim_isprintc(fields->type) && !qfprev->qf_type)\n\t    // only printable chars allowed\n\t    qfprev->qf_type = fields->type;\n\n\tif (!qfprev->qf_lnum)\n\t    qfprev->qf_lnum = fields->lnum;\n\tif (!qfprev->qf_end_lnum)\n\t    qfprev->qf_end_lnum = fields->end_lnum;\n\tif (!qfprev->qf_col)\n\t{\n\t    qfprev->qf_col = fields->col;\n\t    qfprev->qf_viscol = fields->use_viscol;\n\t}\n\tif (!qfprev->qf_end_col)\n\t    qfprev->qf_end_col = fields->end_col;\n\tif (!qfprev->qf_fnum)\n\t    qfprev->qf_fnum = qf_get_fnum(qfl,\n\t\t    qfl->qf_directory,\n\t\t    *fields->namebuf || qfl->qf_directory != NULL\n\t\t    ? fields->namebuf\n\t\t    : qfl->qf_currfile != NULL && fields->valid\n\t\t    ? qfl->qf_currfile : 0);\n    }\n    if (idx == 'Z')\n\tqfl->qf_multiline = qfl->qf_multiignore = FALSE;\n    line_breakcheck();\n\n    return QF_IGNORE_LINE;\n}\n\n/*\n * Parse a line and get the quickfix fields.\n * Return the QF_ status.\n */\n    static int\nqf_parse_line(\n\tqf_list_T\t*qfl,\n\tchar_u\t\t*linebuf,\n\tint\t\tlinelen,\n\tefm_T\t\t*fmt_first,\n\tqffields_T\t*fields)\n{\n    efm_T\t\t*fmt_ptr;\n    int\t\t\tidx = 0;\n    char_u\t\t*tail = NULL;\n    int\t\t\tstatus;\n\nrestofline:\n    // If there was no %> item start at the first pattern\n    if (fmt_start == NULL)\n\tfmt_ptr = fmt_first;\n    else\n    {\n\t// Otherwise start from the last used pattern\n\tfmt_ptr = fmt_start;\n\tfmt_start = NULL;\n    }\n\n    // Try to match each part of 'errorformat' until we find a complete\n    // match or no match.\n    fields->valid = TRUE;\n    for ( ; fmt_ptr != NULL; fmt_ptr = fmt_ptr->next)\n    {\n\tidx = fmt_ptr->prefix;\n\tstatus = qf_parse_get_fields(linebuf, linelen, fmt_ptr, fields,\n\t\t\t\tqfl->qf_multiline, qfl->qf_multiscan, &tail);\n\tif (status == QF_NOMEM)\n\t    return status;\n\tif (status == QF_OK)\n\t    break;\n    }\n    qfl->qf_multiscan = FALSE;\n\n    if (fmt_ptr == NULL || idx == 'D' || idx == 'X')\n    {\n\tif (fmt_ptr != NULL)\n\t{\n\t    // 'D' and 'X' directory specifiers\n\t    status = qf_parse_dir_pfx(idx, fields, qfl);\n\t    if (status != QF_OK)\n\t\treturn status;\n\t}\n\n\tstatus = qf_parse_line_nomatch(linebuf, linelen, fields);\n\tif (status != QF_OK)\n\t    return status;\n\n\tif (fmt_ptr == NULL)\n\t    qfl->qf_multiline = qfl->qf_multiignore = FALSE;\n    }\n    else if (fmt_ptr != NULL)\n    {\n\t// honor %> item\n\tif (fmt_ptr->conthere)\n\t    fmt_start = fmt_ptr;\n\n\tif (vim_strchr((char_u *)\"AEWIN\", idx) != NULL)\n\t{\n\t    qfl->qf_multiline = TRUE;\t// start of a multi-line message\n\t    qfl->qf_multiignore = FALSE;// reset continuation\n\t}\n\telse if (vim_strchr((char_u *)\"CZ\", idx) != NULL)\n\t{\t\t\t\t// continuation of multi-line msg\n\t    status = qf_parse_multiline_pfx(idx, qfl, fields);\n\t    if (status != QF_OK)\n\t\treturn status;\n\t}\n\telse if (vim_strchr((char_u *)\"OPQ\", idx) != NULL)\n\t{\t\t\t\t// global file names\n\t    status = qf_parse_file_pfx(idx, fields, qfl, tail);\n\t    if (status == QF_MULTISCAN)\n\t\tgoto restofline;\n\t}\n\tif (fmt_ptr->flags == '-')\t// generally exclude this line\n\t{\n\t    if (qfl->qf_multiline)\n\t\t// also exclude continuation lines\n\t\tqfl->qf_multiignore = TRUE;\n\t    return QF_IGNORE_LINE;\n\t}\n    }\n\n    return QF_OK;\n}\n\n/*\n * Returns TRUE if the specified quickfix/location stack is empty\n */\n    static int\nqf_stack_empty(qf_info_T *qi)\n{\n    return qi == NULL || qi->qf_listcount <= 0;\n}\n\n/*\n * Returns TRUE if the specified quickfix/location list is empty.\n */\n    static int\nqf_list_empty(qf_list_T *qfl)\n{\n    return qfl == NULL || qfl->qf_count <= 0;\n}\n\n/*\n * Returns TRUE if the specified quickfix/location list is not empty and\n * has valid entries.\n */\n    static int\nqf_list_has_valid_entries(qf_list_T *qfl)\n{\n    return !qf_list_empty(qfl) && !qfl->qf_nonevalid;\n}\n\n/*\n * Return a pointer to a list in the specified quickfix stack\n */\n    static qf_list_T *\nqf_get_list(qf_info_T *qi, int idx)\n{\n    return &qi->qf_lists[idx];\n}\n\n/*\n * Allocate the fields used for parsing lines and populating a quickfix list.\n */\n    static int\nqf_alloc_fields(qffields_T *pfields)\n{\n    pfields->namebuf = alloc_id(CMDBUFFSIZE + 1, aid_qf_namebuf);\n    pfields->module = alloc_id(CMDBUFFSIZE + 1, aid_qf_module);\n    pfields->errmsglen = CMDBUFFSIZE + 1;\n    pfields->errmsg = alloc_id(pfields->errmsglen, aid_qf_errmsg);\n    pfields->pattern = alloc_id(CMDBUFFSIZE + 1, aid_qf_pattern);\n    if (pfields->namebuf == NULL || pfields->errmsg == NULL\n\t\t|| pfields->pattern == NULL || pfields->module == NULL)\n\treturn FAIL;\n\n    return OK;\n}\n\n/*\n * Free the fields used for parsing lines and populating a quickfix list.\n */\n    static void\nqf_free_fields(qffields_T *pfields)\n{\n    vim_free(pfields->namebuf);\n    vim_free(pfields->module);\n    vim_free(pfields->errmsg);\n    vim_free(pfields->pattern);\n}\n\n/*\n * Setup the state information used for parsing lines and populating a\n * quickfix list.\n */\n    static int\nqf_setup_state(\n\tqfstate_T\t*pstate,\n\tchar_u\t\t*enc,\n\tchar_u\t\t*efile,\n\ttypval_T\t*tv,\n\tbuf_T\t\t*buf,\n\tlinenr_T\tlnumfirst,\n\tlinenr_T\tlnumlast)\n{\n    pstate->vc.vc_type = CONV_NONE;\n    if (enc != NULL && *enc != NUL)\n\tconvert_setup(&pstate->vc, enc, p_enc);\n\n    if (efile != NULL && (pstate->fd = mch_fopen((char *)efile, \"r\")) == NULL)\n    {\n\tsemsg(_(e_cant_open_errorfile_str), efile);\n\treturn FAIL;\n    }\n\n    if (tv != NULL)\n    {\n\tif (tv->v_type == VAR_STRING)\n\t    pstate->p_str = tv->vval.v_string;\n\telse if (tv->v_type == VAR_LIST)\n\t    pstate->p_li = tv->vval.v_list->lv_first;\n\tpstate->tv = tv;\n    }\n    pstate->buf = buf;\n    pstate->buflnum = lnumfirst;\n    pstate->lnumlast = lnumlast;\n\n    return OK;\n}\n\n/*\n * Cleanup the state information used for parsing lines and populating a\n * quickfix list.\n */\n    static void\nqf_cleanup_state(qfstate_T *pstate)\n{\n    if (pstate->fd != NULL)\n\tfclose(pstate->fd);\n\n    vim_free(pstate->growbuf);\n    if (pstate->vc.vc_type != CONV_NONE)\n\tconvert_setup(&pstate->vc, NULL, NULL);\n}\n\n/*\n * Process the next line from a file/buffer/list/string and add it\n * to the quickfix list 'qfl'.\n */\n    static int\nqf_init_process_nextline(\n\tqf_list_T\t*qfl,\n\tefm_T\t\t*fmt_first,\n\tqfstate_T\t*state,\n\tqffields_T\t*fields)\n{\n    int\t\t    status;\n\n    // Get the next line from a file/buffer/list/string\n    status = qf_get_nextline(state);\n    if (status != QF_OK)\n\treturn status;\n\n    status = qf_parse_line(qfl, state->linebuf, state->linelen,\n\t    fmt_first, fields);\n    if (status != QF_OK)\n\treturn status;\n\n    return qf_add_entry(qfl,\n\t\tqfl->qf_directory,\n\t\t(*fields->namebuf || qfl->qf_directory != NULL)\n\t\t? fields->namebuf\n\t\t: ((qfl->qf_currfile != NULL && fields->valid)\n\t\t    ? qfl->qf_currfile : (char_u *)NULL),\n\t\tfields->module,\n\t\t0,\n\t\tfields->errmsg,\n\t\tfields->lnum,\n\t\tfields->end_lnum,\n\t\tfields->col,\n\t\tfields->end_col,\n\t\tfields->use_viscol,\n\t\tfields->pattern,\n\t\tfields->enr,\n\t\tfields->type,\n\t\tfields->valid);\n}\n\n/*\n * Read the errorfile \"efile\" into memory, line by line, building the error\n * list.\n * Alternative: when \"efile\" is NULL read errors from buffer \"buf\".\n * Alternative: when \"tv\" is not NULL get errors from the string or list.\n * Always use 'errorformat' from \"buf\" if there is a local value.\n * Then \"lnumfirst\" and \"lnumlast\" specify the range of lines to use.\n * Set the title of the list to \"qf_title\".\n * Return -1 for error, number of errors for success.\n */\n    static int\nqf_init_ext(\n    qf_info_T\t    *qi,\n    int\t\t    qf_idx,\n    char_u\t    *efile,\n    buf_T\t    *buf,\n    typval_T\t    *tv,\n    char_u\t    *errorformat,\n    int\t\t    newlist,\t\t// TRUE: start a new error list\n    linenr_T\t    lnumfirst,\t\t// first line number to use\n    linenr_T\t    lnumlast,\t\t// last line number to use\n    char_u\t    *qf_title,\n    char_u\t    *enc)\n{\n    qf_list_T\t    *qfl;\n    qfstate_T\t    state;\n    qffields_T\t    fields;\n    qfline_T\t    *old_last = NULL;\n    int\t\t    adding = FALSE;\n    static efm_T    *fmt_first = NULL;\n    char_u\t    *efm;\n    static char_u   *last_efm = NULL;\n    int\t\t    retval = -1;\t// default: return error flag\n    int\t\t    status;\n\n    // Do not used the cached buffer, it may have been wiped out.\n    VIM_CLEAR(qf_last_bufname);\n\n    CLEAR_FIELD(state);\n    CLEAR_FIELD(fields);\n    if ((qf_alloc_fields(&fields) == FAIL) ||\n\t\t(qf_setup_state(&state, enc, efile, tv, buf,\n\t\t\t\t\tlnumfirst, lnumlast) == FAIL))\n\tgoto qf_init_end;\n\n    if (newlist || qf_idx == qi->qf_listcount)\n    {\n\t// make place for a new list\n\tqf_new_list(qi, qf_title);\n\tqf_idx = qi->qf_curlist;\n\tqfl = qf_get_list(qi, qf_idx);\n    }\n    else\n    {\n\t// Adding to existing list, use last entry.\n\tadding = TRUE;\n\tqfl = qf_get_list(qi, qf_idx);\n\tif (!qf_list_empty(qfl))\n\t    old_last = qfl->qf_last;\n    }\n\n    // Use the local value of 'errorformat' if it's set.\n    if (errorformat == p_efm && tv == NULL && *buf->b_p_efm != NUL)\n\tefm = buf->b_p_efm;\n    else\n\tefm = errorformat;\n\n    // If the errorformat didn't change between calls, then reuse the\n    // previously parsed values.\n    if (last_efm == NULL || (STRCMP(last_efm, efm) != 0))\n    {\n\t// free the previously parsed data\n\tVIM_CLEAR(last_efm);\n\tfree_efm_list(&fmt_first);\n\n\t// parse the current 'efm'\n\tfmt_first = parse_efm_option(efm);\n\tif (fmt_first != NULL)\n\t    last_efm = vim_strsave(efm);\n    }\n\n    if (fmt_first == NULL)\t// nothing found\n\tgoto error2;\n\n    // got_int is reset here, because it was probably set when killing the\n    // \":make\" command, but we still want to read the errorfile then.\n    got_int = FALSE;\n\n    // Read the lines in the error file one by one.\n    // Try to recognize one of the error formats in each line.\n    while (!got_int)\n    {\n\tstatus = qf_init_process_nextline(qfl, fmt_first, &state, &fields);\n\tif (status == QF_NOMEM)\t\t// memory alloc failure\n\t    goto qf_init_end;\n\tif (status == QF_END_OF_INPUT)\t// end of input\n\t    break;\n\tif (status == QF_FAIL)\n\t    goto error2;\n\n\tline_breakcheck();\n    }\n    if (state.fd == NULL || !ferror(state.fd))\n    {\n\tif (qfl->qf_index == 0)\n\t{\n\t    // no valid entry found\n\t    qfl->qf_ptr = qfl->qf_start;\n\t    qfl->qf_index = 1;\n\t    qfl->qf_nonevalid = TRUE;\n\t}\n\telse\n\t{\n\t    qfl->qf_nonevalid = FALSE;\n\t    if (qfl->qf_ptr == NULL)\n\t\tqfl->qf_ptr = qfl->qf_start;\n\t}\n\t// return number of matches\n\tretval = qfl->qf_count;\n\tgoto qf_init_end;\n    }\n    emsg(_(e_error_while_reading_errorfile));\nerror2:\n    if (!adding)\n    {\n\t// Error when creating a new list. Free the new list\n\tqf_free(qfl);\n\tqi->qf_listcount--;\n\tif (qi->qf_curlist > 0)\n\t    --qi->qf_curlist;\n    }\nqf_init_end:\n    if (qf_idx == qi->qf_curlist)\n\tqf_update_buffer(qi, old_last);\n    qf_cleanup_state(&state);\n    qf_free_fields(&fields);\n\n    return retval;\n}\n\n/*\n * Read the errorfile \"efile\" into memory, line by line, building the error\n * list. Set the error list's title to qf_title.\n * Return -1 for error, number of errors for success.\n */\n    int\nqf_init(win_T\t    *wp,\n\tchar_u\t    *efile,\n\tchar_u\t    *errorformat,\n\tint\t    newlist,\t\t// TRUE: start a new error list\n\tchar_u\t    *qf_title,\n\tchar_u\t    *enc)\n{\n    qf_info_T\t    *qi = &ql_info;\n\n    if (wp != NULL)\n    {\n\tqi = ll_get_or_alloc_list(wp);\n\tif (qi == NULL)\n\t    return FAIL;\n    }\n\n    return qf_init_ext(qi, qi->qf_curlist, efile, curbuf, NULL, errorformat,\n\t    newlist, (linenr_T)0, (linenr_T)0, qf_title, enc);\n}\n\n/*\n * Set the title of the specified quickfix list. Frees the previous title.\n * Prepends ':' to the title.\n */\n    static void\nqf_store_title(qf_list_T *qfl, char_u *title)\n{\n    VIM_CLEAR(qfl->qf_title);\n\n    if (title == NULL)\n\treturn;\n\n    char_u *p = alloc_id(STRLEN(title) + 2, aid_qf_title);\n\n    qfl->qf_title = p;\n    if (p != NULL)\n\tSTRCPY(p, title);\n}\n\n/*\n * The title of a quickfix/location list is set, by default, to the command\n * that created the quickfix list with the \":\" prefix.\n * Create a quickfix list title string by prepending \":\" to a user command.\n * Returns a pointer to a static buffer with the title.\n */\n    static char_u *\nqf_cmdtitle(char_u *cmd)\n{\n    static char_u qftitle_str[IOSIZE];\n\n    vim_snprintf((char *)qftitle_str, IOSIZE, \":%s\", (char *)cmd);\n    return qftitle_str;\n}\n\n/*\n * Return a pointer to the current list in the specified quickfix stack\n */\n    static qf_list_T *\nqf_get_curlist(qf_info_T *qi)\n{\n    return qf_get_list(qi, qi->qf_curlist);\n}\n\n/*\n * Prepare for adding a new quickfix list. If the current list is in the\n * middle of the stack, then all the following lists are freed and then\n * the new list is added.\n */\n    static void\nqf_new_list(qf_info_T *qi, char_u *qf_title)\n{\n    int\t\ti;\n    qf_list_T\t*qfl;\n\n    // If the current entry is not the last entry, delete entries beyond\n    // the current entry.  This makes it possible to browse in a tree-like\n    // way with \":grep\".\n    while (qi->qf_listcount > qi->qf_curlist + 1)\n\tqf_free(&qi->qf_lists[--qi->qf_listcount]);\n\n    // When the stack is full, remove to oldest entry\n    // Otherwise, add a new entry.\n    if (qi->qf_listcount == LISTCOUNT)\n    {\n\tqf_free(&qi->qf_lists[0]);\n\tfor (i = 1; i < LISTCOUNT; ++i)\n\t    qi->qf_lists[i - 1] = qi->qf_lists[i];\n\tqi->qf_curlist = LISTCOUNT - 1;\n    }\n    else\n\tqi->qf_curlist = qi->qf_listcount++;\n    qfl = qf_get_curlist(qi);\n    CLEAR_POINTER(qfl);\n    qf_store_title(qfl, qf_title);\n    qfl->qfl_type = qi->qfl_type;\n    qfl->qf_id = ++last_qf_id;\n}\n\n/*\n * Queue location list stack delete request.\n */\n    static void\nlocstack_queue_delreq(qf_info_T *qi)\n{\n    qf_delq_T\t*q;\n\n    q = ALLOC_ONE(qf_delq_T);\n    if (q == NULL)\n\treturn;\n\n    q->qi = qi;\n    q->next = qf_delq_head;\n    qf_delq_head = q;\n}\n\n/*\n * Return the global quickfix stack window buffer number.\n */\n    int\nqf_stack_get_bufnr(void)\n{\n    return ql_info.qf_bufnr;\n}\n\n/*\n * Wipe the quickfix window buffer (if present) for the specified\n * quickfix/location list.\n */\n    static void\nwipe_qf_buffer(qf_info_T *qi)\n{\n    buf_T\t*qfbuf;\n\n    if (qi->qf_bufnr == INVALID_QFBUFNR)\n\treturn;\n\n    qfbuf = buflist_findnr(qi->qf_bufnr);\n    if (qfbuf != NULL && qfbuf->b_nwindows == 0)\n    {\n\t// If the quickfix buffer is not loaded in any window, then\n\t// wipe the buffer.\n\tclose_buffer(NULL, qfbuf, DOBUF_WIPE, FALSE, FALSE);\n\tqi->qf_bufnr = INVALID_QFBUFNR;\n    }\n}\n\n/*\n * Free a location list stack\n */\n    static void\nll_free_all(qf_info_T **pqi)\n{\n    int\t\ti;\n    qf_info_T\t*qi;\n\n    qi = *pqi;\n    if (qi == NULL)\n\treturn;\n    *pqi = NULL;\t// Remove reference to this list\n\n    // If the location list is still in use, then queue the delete request\n    // to be processed later.\n    if (quickfix_busy > 0)\n    {\n\tlocstack_queue_delreq(qi);\n\treturn;\n    }\n\n    qi->qf_refcount--;\n    if (qi->qf_refcount < 1)\n    {\n\t// No references to this location list.\n\t// If the quickfix window buffer is loaded, then wipe it\n\twipe_qf_buffer(qi);\n\n\tfor (i = 0; i < qi->qf_listcount; ++i)\n\t    qf_free(qf_get_list(qi, i));\n\tvim_free(qi);\n    }\n}\n\n/*\n * Free all the quickfix/location lists in the stack.\n */\n    void\nqf_free_all(win_T *wp)\n{\n    int\t\ti;\n    qf_info_T\t*qi = &ql_info;\n\n    if (wp != NULL)\n    {\n\t// location list\n\tll_free_all(&wp->w_llist);\n\tll_free_all(&wp->w_llist_ref);\n    }\n    else\n\t// quickfix list\n\tfor (i = 0; i < qi->qf_listcount; ++i)\n\t    qf_free(qf_get_list(qi, i));\n}\n\n/*\n * Delay freeing of location list stacks when the quickfix code is running.\n * Used to avoid problems with autocmds freeing location list stacks when the\n * quickfix code is still referencing the stack.\n * Must always call decr_quickfix_busy() exactly once after this.\n */\n    static void\nincr_quickfix_busy(void)\n{\n    quickfix_busy++;\n}\n\n/*\n * Safe to free location list stacks. Process any delayed delete requests.\n */\n    static void\ndecr_quickfix_busy(void)\n{\n    if (--quickfix_busy == 0)\n    {\n\t// No longer referencing the location lists. Process all the pending\n\t// delete requests.\n\twhile (qf_delq_head != NULL)\n\t{\n\t    qf_delq_T\t*q = qf_delq_head;\n\n\t    qf_delq_head = q->next;\n\t    ll_free_all(&q->qi);\n\t    vim_free(q);\n\t}\n    }\n#ifdef ABORT_ON_INTERNAL_ERROR\n    if (quickfix_busy < 0)\n    {\n\temsg(\"quickfix_busy has become negative\");\n\tabort();\n    }\n#endif\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\ncheck_quickfix_busy(void)\n{\n    if (quickfix_busy != 0)\n    {\n\tsemsg(\"quickfix_busy not zero on exit: %ld\", (long)quickfix_busy);\n# ifdef ABORT_ON_INTERNAL_ERROR\n\tabort();\n# endif\n    }\n}\n#endif\n\n/*\n * Add an entry to the end of the list of errors.\n * Returns QF_OK on success or QF_FAIL on a memory allocation failure.\n */\n    static int\nqf_add_entry(\n    qf_list_T\t*qfl,\t\t// quickfix list entry\n    char_u\t*dir,\t\t// optional directory name\n    char_u\t*fname,\t\t// file name or NULL\n    char_u\t*module,\t// module name or NULL\n    int\t\tbufnum,\t\t// buffer number or zero\n    char_u\t*mesg,\t\t// message\n    long\tlnum,\t\t// line number\n    long\tend_lnum,\t// line number for end\n    int\t\tcol,\t\t// column\n    int\t\tend_col,\t// column for end\n    int\t\tvis_col,\t// using visual column\n    char_u\t*pattern,\t// search pattern\n    int\t\tnr,\t\t// error number\n    int\t\ttype,\t\t// type character\n    int\t\tvalid)\t\t// valid entry\n{\n    qfline_T\t*qfp;\n    qfline_T\t**lastp;\t// pointer to qf_last or NULL\n\n    if ((qfp = ALLOC_ONE_ID(qfline_T, aid_qf_qfline)) == NULL)\n\treturn QF_FAIL;\n    if (bufnum != 0)\n    {\n\tbuf_T *buf = buflist_findnr(bufnum);\n\n\tqfp->qf_fnum = bufnum;\n\tif (buf != NULL)\n\t    buf->b_has_qf_entry |=\n\t\tIS_QF_LIST(qfl) ? BUF_HAS_QF_ENTRY : BUF_HAS_LL_ENTRY;\n    }\n    else\n\tqfp->qf_fnum = qf_get_fnum(qfl, dir, fname);\n    if ((qfp->qf_text = vim_strsave(mesg)) == NULL)\n    {\n\tvim_free(qfp);\n\treturn QF_FAIL;\n    }\n    qfp->qf_lnum = lnum;\n    qfp->qf_end_lnum = end_lnum;\n    qfp->qf_col = col;\n    qfp->qf_end_col = end_col;\n    qfp->qf_viscol = vis_col;\n    if (pattern == NULL || *pattern == NUL)\n\tqfp->qf_pattern = NULL;\n    else if ((qfp->qf_pattern = vim_strsave(pattern)) == NULL)\n    {\n\tvim_free(qfp->qf_text);\n\tvim_free(qfp);\n\treturn QF_FAIL;\n    }\n    if (module == NULL || *module == NUL)\n\tqfp->qf_module = NULL;\n    else if ((qfp->qf_module = vim_strsave(module)) == NULL)\n    {\n\tvim_free(qfp->qf_text);\n\tvim_free(qfp->qf_pattern);\n\tvim_free(qfp);\n\treturn QF_FAIL;\n    }\n    qfp->qf_nr = nr;\n    if (type != 1 && !vim_isprintc(type)) // only printable chars allowed\n\ttype = 0;\n    qfp->qf_type = type;\n    qfp->qf_valid = valid;\n\n    lastp = &qfl->qf_last;\n    if (qf_list_empty(qfl))\t\t// first element in the list\n    {\n\tqfl->qf_start = qfp;\n\tqfl->qf_ptr = qfp;\n\tqfl->qf_index = 0;\n\tqfp->qf_prev = NULL;\n    }\n    else\n    {\n\tqfp->qf_prev = *lastp;\n\t(*lastp)->qf_next = qfp;\n    }\n    qfp->qf_next = NULL;\n    qfp->qf_cleared = FALSE;\n    *lastp = qfp;\n    ++qfl->qf_count;\n    if (qfl->qf_index == 0 && qfp->qf_valid)\t// first valid entry\n    {\n\tqfl->qf_index = qfl->qf_count;\n\tqfl->qf_ptr = qfp;\n    }\n\n    return QF_OK;\n}\n\n/*\n * Allocate a new quickfix/location list stack\n */\n    static qf_info_T *\nqf_alloc_stack(qfltype_T qfltype)\n{\n    qf_info_T *qi;\n\n    qi = ALLOC_CLEAR_ONE_ID(qf_info_T, aid_qf_qfinfo);\n    if (qi == NULL)\n\treturn NULL;\n\n    qi->qf_refcount++;\n    qi->qfl_type = qfltype;\n    qi->qf_bufnr = INVALID_QFBUFNR;\n    return qi;\n}\n\n/*\n * Return the location list stack for window 'wp'.\n * If not present, allocate a location list stack\n */\n    static qf_info_T *\nll_get_or_alloc_list(win_T *wp)\n{\n    if (IS_LL_WINDOW(wp))\n\t// For a location list window, use the referenced location list\n\treturn wp->w_llist_ref;\n\n    // For a non-location list window, w_llist_ref should not point to a\n    // location list.\n    ll_free_all(&wp->w_llist_ref);\n\n    if (wp->w_llist == NULL)\n\twp->w_llist = qf_alloc_stack(QFLT_LOCATION);\t// new location list\n    return wp->w_llist;\n}\n\n/*\n * Get the quickfix/location list stack to use for the specified Ex command.\n * For a location list command, returns the stack for the current window.  If\n * the location list is not found, then returns NULL and prints an error\n * message if 'print_emsg' is TRUE.\n */\n    static qf_info_T *\nqf_cmd_get_stack(exarg_T *eap, int print_emsg)\n{\n    qf_info_T\t*qi = &ql_info;\n\n    if (is_loclist_cmd(eap->cmdidx))\n    {\n\tqi = GET_LOC_LIST(curwin);\n\tif (qi == NULL)\n\t{\n\t    if (print_emsg)\n\t\temsg(_(e_no_location_list));\n\t    return NULL;\n\t}\n    }\n\n    return qi;\n}\n\n/*\n * Get the quickfix/location list stack to use for the specified Ex command.\n * For a location list command, returns the stack for the current window.\n * If the location list is not present, then allocates a new one.\n * Returns NULL if the allocation fails.  For a location list command, sets\n * 'pwinp' to curwin.\n */\n    static qf_info_T *\nqf_cmd_get_or_alloc_stack(exarg_T *eap, win_T **pwinp)\n{\n    qf_info_T\t*qi = &ql_info;\n\n    if (is_loclist_cmd(eap->cmdidx))\n    {\n\tqi = ll_get_or_alloc_list(curwin);\n\tif (qi == NULL)\n\t    return NULL;\n\t*pwinp = curwin;\n    }\n\n    return qi;\n}\n\n/*\n * Copy location list entries from 'from_qfl' to 'to_qfl'.\n */\n    static int\ncopy_loclist_entries(qf_list_T *from_qfl, qf_list_T *to_qfl)\n{\n    int\t\ti;\n    qfline_T    *from_qfp;\n    qfline_T    *prevp;\n\n    // copy all the location entries in this list\n    FOR_ALL_QFL_ITEMS(from_qfl, from_qfp, i)\n    {\n\tif (qf_add_entry(to_qfl,\n\t\t    NULL,\n\t\t    NULL,\n\t\t    from_qfp->qf_module,\n\t\t    0,\n\t\t    from_qfp->qf_text,\n\t\t    from_qfp->qf_lnum,\n\t\t    from_qfp->qf_end_lnum,\n\t\t    from_qfp->qf_col,\n\t\t    from_qfp->qf_end_col,\n\t\t    from_qfp->qf_viscol,\n\t\t    from_qfp->qf_pattern,\n\t\t    from_qfp->qf_nr,\n\t\t    0,\n\t\t    from_qfp->qf_valid) == QF_FAIL)\n\t    return FAIL;\n\n\t// qf_add_entry() will not set the qf_num field, as the\n\t// directory and file names are not supplied. So the qf_fnum\n\t// field is copied here.\n\tprevp = to_qfl->qf_last;\n\tprevp->qf_fnum = from_qfp->qf_fnum;\t// file number\n\tprevp->qf_type = from_qfp->qf_type;\t// error type\n\tif (from_qfl->qf_ptr == from_qfp)\n\t    to_qfl->qf_ptr = prevp;\t\t// current location\n    }\n\n    return OK;\n}\n\n/*\n * Copy the specified location list 'from_qfl' to 'to_qfl'.\n */\n    static int\ncopy_loclist(qf_list_T *from_qfl, qf_list_T *to_qfl)\n{\n    // Some of the fields are populated by qf_add_entry()\n    to_qfl->qfl_type = from_qfl->qfl_type;\n    to_qfl->qf_nonevalid = from_qfl->qf_nonevalid;\n    to_qfl->qf_count = 0;\n    to_qfl->qf_index = 0;\n    to_qfl->qf_start = NULL;\n    to_qfl->qf_last = NULL;\n    to_qfl->qf_ptr = NULL;\n    if (from_qfl->qf_title != NULL)\n\tto_qfl->qf_title = vim_strsave(from_qfl->qf_title);\n    else\n\tto_qfl->qf_title = NULL;\n    if (from_qfl->qf_ctx != NULL)\n    {\n\tto_qfl->qf_ctx = alloc_tv();\n\tif (to_qfl->qf_ctx != NULL)\n\t    copy_tv(from_qfl->qf_ctx, to_qfl->qf_ctx);\n    }\n    else\n\tto_qfl->qf_ctx = NULL;\n    if (from_qfl->qf_qftf_cb.cb_name != NULL)\n\tcopy_callback(&to_qfl->qf_qftf_cb, &from_qfl->qf_qftf_cb);\n    else\n\tto_qfl->qf_qftf_cb.cb_name = NULL;\n\n    if (from_qfl->qf_count)\n\tif (copy_loclist_entries(from_qfl, to_qfl) == FAIL)\n\t    return FAIL;\n\n    to_qfl->qf_index = from_qfl->qf_index;\t// current index in the list\n\n    // Assign a new ID for the location list\n    to_qfl->qf_id = ++last_qf_id;\n    to_qfl->qf_changedtick = 0L;\n\n    // When no valid entries are present in the list, qf_ptr points to\n    // the first item in the list\n    if (to_qfl->qf_nonevalid)\n    {\n\tto_qfl->qf_ptr = to_qfl->qf_start;\n\tto_qfl->qf_index = 1;\n    }\n\n    return OK;\n}\n\n/*\n * Copy the location list stack 'from' window to 'to' window.\n */\n    void\ncopy_loclist_stack(win_T *from, win_T *to)\n{\n    qf_info_T\t*qi;\n    int\t\tidx;\n\n    // When copying from a location list window, copy the referenced\n    // location list. For other windows, copy the location list for\n    // that window.\n    if (IS_LL_WINDOW(from))\n\tqi = from->w_llist_ref;\n    else\n\tqi = from->w_llist;\n\n    if (qi == NULL)\t\t    // no location list to copy\n\treturn;\n\n    // allocate a new location list\n    if ((to->w_llist = qf_alloc_stack(QFLT_LOCATION)) == NULL)\n\treturn;\n\n    to->w_llist->qf_listcount = qi->qf_listcount;\n\n    // Copy the location lists one at a time\n    for (idx = 0; idx < qi->qf_listcount; ++idx)\n    {\n\tto->w_llist->qf_curlist = idx;\n\n\tif (copy_loclist(qf_get_list(qi, idx),\n\t\t\tqf_get_list(to->w_llist, idx)) == FAIL)\n\t{\n\t    qf_free_all(to);\n\t    return;\n\t}\n    }\n\n    to->w_llist->qf_curlist = qi->qf_curlist;\t// current list\n}\n\n/*\n * Get buffer number for file \"directory/fname\".\n * Also sets the b_has_qf_entry flag.\n */\n    static int\nqf_get_fnum(qf_list_T *qfl, char_u *directory, char_u *fname)\n{\n    char_u\t*ptr = NULL;\n    buf_T\t*buf;\n    char_u\t*bufname;\n\n    if (fname == NULL || *fname == NUL)\t\t// no file name\n\treturn 0;\n\n#ifdef VMS\n    vms_remove_version(fname);\n#endif\n#ifdef BACKSLASH_IN_FILENAME\n    if (directory != NULL)\n\tslash_adjust(directory);\n    slash_adjust(fname);\n#endif\n    if (directory != NULL && !vim_isAbsName(fname)\n\t    && (ptr = concat_fnames(directory, fname, TRUE)) != NULL)\n    {\n\t// Here we check if the file really exists.\n\t// This should normally be true, but if make works without\n\t// \"leaving directory\"-messages we might have missed a\n\t// directory change.\n\tif (mch_getperm(ptr) < 0)\n\t{\n\t    vim_free(ptr);\n\t    directory = qf_guess_filepath(qfl, fname);\n\t    if (directory)\n\t\tptr = concat_fnames(directory, fname, TRUE);\n\t    else\n\t\tptr = vim_strsave(fname);\n\t}\n\t// Use concatenated directory name and file name\n\tbufname = ptr;\n    }\n    else\n\tbufname = fname;\n\n    if (qf_last_bufname != NULL && STRCMP(bufname, qf_last_bufname) == 0\n\t    && bufref_valid(&qf_last_bufref))\n    {\n\tbuf = qf_last_bufref.br_buf;\n\tvim_free(ptr);\n    }\n    else\n    {\n\tvim_free(qf_last_bufname);\n\tbuf = buflist_new(bufname, NULL, (linenr_T)0, BLN_NOOPT);\n\tif (bufname == ptr)\n\t    qf_last_bufname = bufname;\n\telse\n\t    qf_last_bufname = vim_strsave(bufname);\n\tset_bufref(&qf_last_bufref, buf);\n    }\n    if (buf == NULL)\n\treturn 0;\n\n    buf->b_has_qf_entry =\n\t\t\tIS_QF_LIST(qfl) ? BUF_HAS_QF_ENTRY : BUF_HAS_LL_ENTRY;\n    return buf->b_fnum;\n}\n\n/*\n * Push dirbuf onto the directory stack and return pointer to actual dir or\n * NULL on error.\n */\n    static char_u *\nqf_push_dir(char_u *dirbuf, struct dir_stack_T **stackptr, int is_file_stack)\n{\n    struct dir_stack_T  *ds_new;\n    struct dir_stack_T  *ds_ptr;\n\n    // allocate new stack element and hook it in\n    ds_new = ALLOC_ONE_ID(struct dir_stack_T, aid_qf_dirstack);\n    if (ds_new == NULL)\n\treturn NULL;\n\n    ds_new->next = *stackptr;\n    *stackptr = ds_new;\n\n    // store directory on the stack\n    if (vim_isAbsName(dirbuf)\n\t    || (*stackptr)->next == NULL\n\t    || is_file_stack)\n\t(*stackptr)->dirname = vim_strsave(dirbuf);\n    else\n    {\n\t// Okay we don't have an absolute path.\n\t// dirbuf must be a subdir of one of the directories on the stack.\n\t// Let's search...\n\tds_new = (*stackptr)->next;\n\t(*stackptr)->dirname = NULL;\n\twhile (ds_new)\n\t{\n\t    vim_free((*stackptr)->dirname);\n\t    (*stackptr)->dirname = concat_fnames(ds_new->dirname, dirbuf,\n\t\t    TRUE);\n\t    if (mch_isdir((*stackptr)->dirname) == TRUE)\n\t\tbreak;\n\n\t    ds_new = ds_new->next;\n\t}\n\n\t// clean up all dirs we already left\n\twhile ((*stackptr)->next != ds_new)\n\t{\n\t    ds_ptr = (*stackptr)->next;\n\t    (*stackptr)->next = (*stackptr)->next->next;\n\t    vim_free(ds_ptr->dirname);\n\t    vim_free(ds_ptr);\n\t}\n\n\t// Nothing found -> it must be on top level\n\tif (ds_new == NULL)\n\t{\n\t    vim_free((*stackptr)->dirname);\n\t    (*stackptr)->dirname = vim_strsave(dirbuf);\n\t}\n    }\n\n    if ((*stackptr)->dirname != NULL)\n\treturn (*stackptr)->dirname;\n    else\n    {\n\tds_ptr = *stackptr;\n\t*stackptr = (*stackptr)->next;\n\tvim_free(ds_ptr);\n\treturn NULL;\n    }\n}\n\n/*\n * pop dirbuf from the directory stack and return previous directory or NULL if\n * stack is empty\n */\n    static char_u *\nqf_pop_dir(struct dir_stack_T **stackptr)\n{\n    struct dir_stack_T  *ds_ptr;\n\n    // TODO: Should we check if dirbuf is the directory on top of the stack?\n    // What to do if it isn't?\n\n    // pop top element and free it\n    if (*stackptr != NULL)\n    {\n\tds_ptr = *stackptr;\n\t*stackptr = (*stackptr)->next;\n\tvim_free(ds_ptr->dirname);\n\tvim_free(ds_ptr);\n    }\n\n    // return NEW top element as current dir or NULL if stack is empty\n    return *stackptr ? (*stackptr)->dirname : NULL;\n}\n\n/*\n * clean up directory stack\n */\n    static void\nqf_clean_dir_stack(struct dir_stack_T **stackptr)\n{\n    struct dir_stack_T  *ds_ptr;\n\n    while ((ds_ptr = *stackptr) != NULL)\n    {\n\t*stackptr = (*stackptr)->next;\n\tvim_free(ds_ptr->dirname);\n\tvim_free(ds_ptr);\n    }\n}\n\n/*\n * Check in which directory of the directory stack the given file can be\n * found.\n * Returns a pointer to the directory name or NULL if not found.\n * Cleans up intermediate directory entries.\n *\n * TODO: How to solve the following problem?\n * If we have this directory tree:\n *     ./\n *     ./aa\n *     ./aa/bb\n *     ./bb\n *     ./bb/x.c\n * and make says:\n *     making all in aa\n *     making all in bb\n *     x.c:9: Error\n * Then qf_push_dir thinks we are in ./aa/bb, but we are in ./bb.\n * qf_guess_filepath will return NULL.\n */\n    static char_u *\nqf_guess_filepath(qf_list_T *qfl, char_u *filename)\n{\n    struct dir_stack_T     *ds_ptr;\n    struct dir_stack_T     *ds_tmp;\n    char_u\t\t   *fullname;\n\n    // no dirs on the stack - there's nothing we can do\n    if (qfl->qf_dir_stack == NULL)\n\treturn NULL;\n\n    ds_ptr = qfl->qf_dir_stack->next;\n    fullname = NULL;\n    while (ds_ptr)\n    {\n\tvim_free(fullname);\n\tfullname = concat_fnames(ds_ptr->dirname, filename, TRUE);\n\n\t// If concat_fnames failed, just go on. The worst thing that can happen\n\t// is that we delete the entire stack.\n\tif ((fullname != NULL) && (mch_getperm(fullname) >= 0))\n\t    break;\n\n\tds_ptr = ds_ptr->next;\n    }\n\n    vim_free(fullname);\n\n    // clean up all dirs we already left\n    while (qfl->qf_dir_stack->next != ds_ptr)\n    {\n\tds_tmp = qfl->qf_dir_stack->next;\n\tqfl->qf_dir_stack->next = qfl->qf_dir_stack->next->next;\n\tvim_free(ds_tmp->dirname);\n\tvim_free(ds_tmp);\n    }\n\n    return ds_ptr == NULL ? NULL : ds_ptr->dirname;\n}\n\n/*\n * Returns TRUE if a quickfix/location list with the given identifier exists.\n */\n    static int\nqflist_valid(win_T *wp, int_u qf_id)\n{\n    qf_info_T\t*qi = &ql_info;\n    int\t\ti;\n\n    if (wp != NULL)\n    {\n\tif (!win_valid(wp))\n\t    return FALSE;\n\tqi = GET_LOC_LIST(wp);\t    // Location list\n\tif (qi == NULL)\n\t    return FALSE;\n    }\n\n    for (i = 0; i < qi->qf_listcount; ++i)\n\tif (qi->qf_lists[i].qf_id == qf_id)\n\t    return TRUE;\n\n    return FALSE;\n}\n\n/*\n * When loading a file from the quickfix, the autocommands may modify it.\n * This may invalidate the current quickfix entry.  This function checks\n * whether an entry is still present in the quickfix list.\n * Similar to location list.\n */\n    static int\nis_qf_entry_present(qf_list_T *qfl, qfline_T *qf_ptr)\n{\n    qfline_T\t*qfp;\n    int\t\ti;\n\n    // Search for the entry in the current list\n    FOR_ALL_QFL_ITEMS(qfl, qfp, i)\n\tif (qfp == qf_ptr)\n\t    break;\n\n    if (i > qfl->qf_count) // Entry is not found\n\treturn FALSE;\n\n    return TRUE;\n}\n\n/*\n * Get the next valid entry in the current quickfix/location list. The search\n * starts from the current entry.  Returns NULL on failure.\n */\n    static qfline_T *\nget_next_valid_entry(\n\tqf_list_T\t*qfl,\n\tqfline_T\t*qf_ptr,\n\tint\t\t*qf_index,\n\tint\t\tdir)\n{\n    int\t\t\tidx;\n    int\t\t\told_qf_fnum;\n\n    idx = *qf_index;\n    old_qf_fnum = qf_ptr->qf_fnum;\n\n    do\n    {\n\tif (idx == qfl->qf_count || qf_ptr->qf_next == NULL)\n\t    return NULL;\n\t++idx;\n\tqf_ptr = qf_ptr->qf_next;\n    } while ((!qfl->qf_nonevalid && !qf_ptr->qf_valid)\n\t    || (dir == FORWARD_FILE && qf_ptr->qf_fnum == old_qf_fnum));\n\n    *qf_index = idx;\n    return qf_ptr;\n}\n\n/*\n * Get the previous valid entry in the current quickfix/location list. The\n * search starts from the current entry.  Returns NULL on failure.\n */\n    static qfline_T *\nget_prev_valid_entry(\n\tqf_list_T\t*qfl,\n\tqfline_T\t*qf_ptr,\n\tint\t\t*qf_index,\n\tint\t\tdir)\n{\n    int\t\t\tidx;\n    int\t\t\told_qf_fnum;\n\n    idx = *qf_index;\n    old_qf_fnum = qf_ptr->qf_fnum;\n\n    do\n    {\n\tif (idx == 1 || qf_ptr->qf_prev == NULL)\n\t    return NULL;\n\t--idx;\n\tqf_ptr = qf_ptr->qf_prev;\n    } while ((!qfl->qf_nonevalid && !qf_ptr->qf_valid)\n\t    || (dir == BACKWARD_FILE && qf_ptr->qf_fnum == old_qf_fnum));\n\n    *qf_index = idx;\n    return qf_ptr;\n}\n\n/*\n * Get the n'th (errornr) previous/next valid entry from the current entry in\n * the quickfix list.\n *   dir == FORWARD or FORWARD_FILE: next valid entry\n *   dir == BACKWARD or BACKWARD_FILE: previous valid entry\n */\n    static qfline_T *\nget_nth_valid_entry(\n\tqf_list_T\t*qfl,\n\tint\t\terrornr,\n\tint\t\tdir,\n\tint\t\t*new_qfidx)\n{\n    qfline_T\t\t*qf_ptr = qfl->qf_ptr;\n    int\t\t\tqf_idx = qfl->qf_index;\n    qfline_T\t\t*prev_qf_ptr;\n    int\t\t\tprev_index;\n    char\t\t*err = e_no_more_items;\n\n    while (errornr--)\n    {\n\tprev_qf_ptr = qf_ptr;\n\tprev_index = qf_idx;\n\n\tif (dir == FORWARD || dir == FORWARD_FILE)\n\t    qf_ptr = get_next_valid_entry(qfl, qf_ptr, &qf_idx, dir);\n\telse\n\t    qf_ptr = get_prev_valid_entry(qfl, qf_ptr, &qf_idx, dir);\n\tif (qf_ptr == NULL)\n\t{\n\t    qf_ptr = prev_qf_ptr;\n\t    qf_idx = prev_index;\n\t    if (err != NULL)\n\t    {\n\t\temsg(_(err));\n\t\treturn NULL;\n\t    }\n\t    break;\n\t}\n\n\terr = NULL;\n    }\n\n    *new_qfidx = qf_idx;\n    return qf_ptr;\n}\n\n/*\n * Get n'th (errornr) quickfix entry from the current entry in the quickfix\n * list 'qfl'. Returns a pointer to the new entry and the index in 'new_qfidx'\n */\n    static qfline_T *\nget_nth_entry(qf_list_T *qfl, int errornr, int *new_qfidx)\n{\n    qfline_T\t*qf_ptr = qfl->qf_ptr;\n    int\t\tqf_idx = qfl->qf_index;\n\n    // New error number is less than the current error number\n    while (errornr < qf_idx && qf_idx > 1 && qf_ptr->qf_prev != NULL)\n    {\n\t--qf_idx;\n\tqf_ptr = qf_ptr->qf_prev;\n    }\n    // New error number is greater than the current error number\n    while (errornr > qf_idx && qf_idx < qfl->qf_count &&\n\t\t\t\t\t\tqf_ptr->qf_next != NULL)\n    {\n\t++qf_idx;\n\tqf_ptr = qf_ptr->qf_next;\n    }\n\n    *new_qfidx = qf_idx;\n    return qf_ptr;\n}\n\n/*\n * Get a entry specified by 'errornr' and 'dir' from the current\n * quickfix/location list. 'errornr' specifies the index of the entry and 'dir'\n * specifies the direction (FORWARD/BACKWARD/FORWARD_FILE/BACKWARD_FILE).\n * Returns a pointer to the entry and the index of the new entry is stored in\n * 'new_qfidx'.\n */\n    static qfline_T *\nqf_get_entry(\n\tqf_list_T\t*qfl,\n\tint\t\terrornr,\n\tint\t\tdir,\n\tint\t\t*new_qfidx)\n{\n    qfline_T\t*qf_ptr = qfl->qf_ptr;\n    int\t\tqfidx = qfl->qf_index;\n\n    if (dir != 0)    // next/prev valid entry\n\tqf_ptr = get_nth_valid_entry(qfl, errornr, dir, &qfidx);\n    else if (errornr != 0)\t// go to specified number\n\tqf_ptr = get_nth_entry(qfl, errornr, &qfidx);\n\n    *new_qfidx = qfidx;\n    return qf_ptr;\n}\n\n/*\n * Find a window displaying a Vim help file in the current tab page.\n */\n    static win_T *\nqf_find_help_win(void)\n{\n    win_T *wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (bt_help(wp->w_buffer))\n\t    return wp;\n\n    return NULL;\n}\n\n/*\n * Set the location list for the specified window to 'qi'.\n */\n    static void\nwin_set_loclist(win_T *wp, qf_info_T *qi)\n{\n    wp->w_llist = qi;\n    qi->qf_refcount++;\n}\n\n/*\n * Find a help window or open one. If 'newwin' is TRUE, then open a new help\n * window.\n */\n    static int\njump_to_help_window(qf_info_T *qi, int newwin, int *opened_window)\n{\n    win_T\t*wp;\n    int\t\tflags;\n\n    if (cmdmod.cmod_tab != 0 || newwin)\n\twp = NULL;\n    else\n\twp = qf_find_help_win();\n    if (wp != NULL && wp->w_buffer->b_nwindows > 0)\n\twin_enter(wp, TRUE);\n    else\n    {\n\t// Split off help window; put it at far top if no position\n\t// specified, the current window is vertically split and narrow.\n\tflags = WSP_HELP;\n\tif (cmdmod.cmod_split == 0 && curwin->w_width != Columns\n\t\t&& curwin->w_width < 80)\n\t    flags |= WSP_TOP;\n\t// If the user asks to open a new window, then copy the location list.\n\t// Otherwise, don't copy the location list.\n\tif (IS_LL_STACK(qi) && !newwin)\n\t    flags |= WSP_NEWLOC;\n\n\tif (win_split(0, flags) == FAIL)\n\t    return FAIL;\n\n\t*opened_window = TRUE;\n\n\tif (curwin->w_height < p_hh)\n\t    win_setheight((int)p_hh);\n\n\t// When using location list, the new window should use the supplied\n\t// location list. If the user asks to open a new window, then the new\n\t// window will get a copy of the location list.\n\tif (IS_LL_STACK(qi) && !newwin)\n\t    win_set_loclist(curwin, qi);\n    }\n\n    if (!p_im)\n\trestart_edit = 0;\t    // don't want insert mode in help file\n\n    return OK;\n}\n\n/*\n * Find a non-quickfix window using the given location list stack in the\n * current tabpage.\n * Returns NULL if a matching window is not found.\n */\n    static win_T *\nqf_find_win_with_loclist(qf_info_T *ll)\n{\n    win_T\t*wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_llist == ll && !bt_quickfix(wp->w_buffer))\n\t    return wp;\n\n    return NULL;\n}\n\n/*\n * Find a window containing a normal buffer in the current tab page.\n */\n    static win_T *\nqf_find_win_with_normal_buf(void)\n{\n    win_T\t*wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (bt_normal(wp->w_buffer))\n\t    return wp;\n\n    return NULL;\n}\n\n/*\n * Go to a window in any tabpage containing the specified file.  Returns TRUE\n * if successfully jumped to the window. Otherwise returns FALSE.\n */\n    static int\nqf_goto_tabwin_with_file(int fnum)\n{\n    tabpage_T\t*tp;\n    win_T\t*wp;\n\n    FOR_ALL_TAB_WINDOWS(tp, wp)\n\tif (wp->w_buffer->b_fnum == fnum)\n\t{\n\t    goto_tabpage_win(tp, wp);\n\t    return TRUE;\n\t}\n\n    return FALSE;\n}\n\n/*\n * Create a new window to show a file above the quickfix window. Called when\n * only the quickfix window is present.\n */\n    static int\nqf_open_new_file_win(qf_info_T *ll_ref)\n{\n    int\t\tflags;\n\n    flags = WSP_ABOVE;\n    if (ll_ref != NULL)\n\tflags |= WSP_NEWLOC;\n    if (win_split(0, flags) == FAIL)\n\treturn FAIL;\t\t// not enough room for window\n    p_swb = empty_option;\t// don't split again\n    swb_flags = 0;\n    RESET_BINDING(curwin);\n    if (ll_ref != NULL)\n\t// The new window should use the location list from the\n\t// location list window\n\twin_set_loclist(curwin, ll_ref);\n    return OK;\n}\n\n/*\n * Go to a window that shows the right buffer. If the window is not found, go\n * to the window just above the location list window. This is used for opening\n * a file from a location window and not from a quickfix window. If some usable\n * window is previously found, then it is supplied in 'use_win'.\n */\n    static void\nqf_goto_win_with_ll_file(win_T *use_win, int qf_fnum, qf_info_T *ll_ref)\n{\n    win_T\t*win = use_win;\n\n    if (win == NULL)\n    {\n\t// Find the window showing the selected file in the current tab page.\n\tFOR_ALL_WINDOWS(win)\n\t    if (win->w_buffer->b_fnum == qf_fnum)\n\t\tbreak;\n\tif (win == NULL)\n\t{\n\t    // Find a previous usable window\n\t    win = curwin;\n\t    do\n\t    {\n\t\tif (bt_normal(win->w_buffer))\n\t\t    break;\n\t\tif (win->w_prev == NULL)\n\t\t    win = lastwin;\t// wrap around the top\n\t\telse\n\t\t    win = win->w_prev; // go to previous window\n\t    } while (win != curwin);\n\t}\n    }\n    win_goto(win);\n\n    // If the location list for the window is not set, then set it\n    // to the location list from the location window\n    if (win->w_llist == NULL && ll_ref != NULL)\n\twin_set_loclist(win, ll_ref);\n}\n\n/*\n * Go to a window that contains the specified buffer 'qf_fnum'. If a window is\n * not found, then go to the window just above the quickfix window. This is\n * used for opening a file from a quickfix window and not from a location\n * window.\n */\n    static void\nqf_goto_win_with_qfl_file(int qf_fnum)\n{\n    win_T\t*win;\n    win_T\t*altwin;\n\n    win = curwin;\n    altwin = NULL;\n    for (;;)\n    {\n\tif (win->w_buffer->b_fnum == qf_fnum)\n\t    break;\n\tif (win->w_prev == NULL)\n\t    win = lastwin;\t// wrap around the top\n\telse\n\t    win = win->w_prev;\t// go to previous window\n\n\tif (IS_QF_WINDOW(win))\n\t{\n\t    // Didn't find it, go to the window before the quickfix\n\t    // window, unless 'switchbuf' contains 'uselast': in this case we\n\t    // try to jump to the previously used window first.\n\t    if ((swb_flags & SWB_USELAST) && win_valid(prevwin))\n\t\twin = prevwin;\n\t    else if (altwin != NULL)\n\t\twin = altwin;\n\t    else if (curwin->w_prev != NULL)\n\t\twin = curwin->w_prev;\n\t    else\n\t\twin = curwin->w_next;\n\t    break;\n\t}\n\n\t// Remember a usable window.\n\tif (altwin == NULL && !win->w_p_pvw && bt_normal(win->w_buffer))\n\t    altwin = win;\n    }\n\n    win_goto(win);\n}\n\n/*\n * Find a suitable window for opening a file (qf_fnum) from the\n * quickfix/location list and jump to it.  If the file is already opened in a\n * window, jump to it. Otherwise open a new window to display the file. If\n * 'newwin' is TRUE, then always open a new window. This is called from either\n * a quickfix or a location list window.\n */\n    static int\nqf_jump_to_usable_window(int qf_fnum, int newwin, int *opened_window)\n{\n    win_T\t*usable_wp = NULL;\n    int\t\tusable_win = FALSE;\n    qf_info_T\t*ll_ref = NULL;\n\n    // If opening a new window, then don't use the location list referred by\n    // the current window.  Otherwise two windows will refer to the same\n    // location list.\n    if (!newwin)\n\tll_ref = curwin->w_llist_ref;\n\n    if (ll_ref != NULL)\n    {\n\t// Find a non-quickfix window with this location list\n\tusable_wp = qf_find_win_with_loclist(ll_ref);\n\tif (usable_wp != NULL)\n\t    usable_win = TRUE;\n    }\n\n    if (!usable_win)\n    {\n\t// Locate a window showing a normal buffer\n\twin_T\t*win = qf_find_win_with_normal_buf();\n\tif (win != NULL)\n\t    usable_win = TRUE;\n    }\n\n    // If no usable window is found and 'switchbuf' contains \"usetab\"\n    // then search in other tabs.\n    if (!usable_win && (swb_flags & SWB_USETAB))\n\tusable_win = qf_goto_tabwin_with_file(qf_fnum);\n\n    // If there is only one window and it is the quickfix window, create a\n    // new one above the quickfix window.\n    if ((ONE_WINDOW && bt_quickfix(curbuf)) || !usable_win || newwin)\n    {\n\tif (qf_open_new_file_win(ll_ref) != OK)\n\t    return FAIL;\n\t*opened_window = TRUE;\t// close it when fail\n    }\n    else\n    {\n\tif (curwin->w_llist_ref != NULL)\t// In a location window\n\t    qf_goto_win_with_ll_file(usable_wp, qf_fnum, ll_ref);\n\telse\t\t\t\t\t// In a quickfix window\n\t    qf_goto_win_with_qfl_file(qf_fnum);\n    }\n\n    return OK;\n}\n\n/*\n * Edit the selected file or help file.\n * Returns OK if successfully edited the file, FAIL on failing to open the\n * buffer and QF_ABORT if the quickfix/location list was freed by an autocmd\n * when opening the buffer.\n */\n    static int\nqf_jump_edit_buffer(\n\tqf_info_T\t*qi,\n\tqfline_T\t*qf_ptr,\n\tint\t\tforceit,\n\tint\t\tprev_winid,\n\tint\t\t*opened_window)\n{\n    qf_list_T\t*qfl = qf_get_curlist(qi);\n    int\t\told_changedtick = qfl->qf_changedtick;\n    qfltype_T\tqfl_type = qfl->qfl_type;\n    int\t\tretval = OK;\n    int\t\told_qf_curlist = qi->qf_curlist;\n    int\t\tsave_qfid = qfl->qf_id;\n\n    if (qf_ptr->qf_type == 1)\n    {\n\t// Open help file (do_ecmd() will set b_help flag, readfile() will\n\t// set b_p_ro flag).\n\tif (!can_abandon(curbuf, forceit))\n\t{\n\t    no_write_message();\n\t    return FAIL;\n\t}\n\n\tretval = do_ecmd(qf_ptr->qf_fnum, NULL, NULL, NULL, (linenr_T)1,\n\t\tECMD_HIDE + ECMD_SET_HELP,\n\t\tprev_winid == curwin->w_id ? curwin : NULL);\n    }\n    else\n\tretval = buflist_getfile(qf_ptr->qf_fnum,\n\t\t(linenr_T)1, GETF_SETMARK | GETF_SWITCH, forceit);\n\n    // If a location list, check whether the associated window is still\n    // present.\n    if (qfl_type == QFLT_LOCATION)\n    {\n\twin_T\t*wp = win_id2wp(prev_winid);\n\n\tif (wp == NULL && curwin->w_llist != qi)\n\t{\n\t    emsg(_(e_current_window_was_closed));\n\t    *opened_window = FALSE;\n\t    return QF_ABORT;\n\t}\n    }\n\n    if (qfl_type == QFLT_QUICKFIX && !qflist_valid(NULL, save_qfid))\n    {\n\temsg(_(e_current_quickfix_list_was_changed));\n\treturn QF_ABORT;\n    }\n\n    // Check if the list was changed.  The pointers may happen to be identical,\n    // thus also check qf_changedtick.\n    if (old_qf_curlist != qi->qf_curlist\n\t    || old_changedtick != qfl->qf_changedtick\n\t    || !is_qf_entry_present(qfl, qf_ptr))\n    {\n\tif (qfl_type == QFLT_QUICKFIX)\n\t    emsg(_(e_current_quickfix_list_was_changed));\n\telse\n\t    emsg(_(e_current_location_list_was_changed));\n\treturn QF_ABORT;\n    }\n\n    return retval;\n}\n\n/*\n * Go to the error line in the current file using either line/column number or\n * a search pattern.\n */\n    static void\nqf_jump_goto_line(\n\tlinenr_T\tqf_lnum,\n\tint\t\tqf_col,\n\tchar_u\t\tqf_viscol,\n\tchar_u\t\t*qf_pattern)\n{\n    linenr_T\t\ti;\n\n    if (qf_pattern == NULL)\n    {\n\t// Go to line with error, unless qf_lnum is 0.\n\ti = qf_lnum;\n\tif (i > 0)\n\t{\n\t    if (i > curbuf->b_ml.ml_line_count)\n\t\ti = curbuf->b_ml.ml_line_count;\n\t    curwin->w_cursor.lnum = i;\n\t}\n\tif (qf_col > 0)\n\t{\n\t    curwin->w_cursor.coladd = 0;\n\t    if (qf_viscol == TRUE)\n\t\tcoladvance(qf_col - 1);\n\t    else\n\t\tcurwin->w_cursor.col = qf_col - 1;\n\t    curwin->w_set_curswant = TRUE;\n\t    check_cursor();\n\t}\n\telse\n\t    beginline(BL_WHITE | BL_FIX);\n    }\n    else\n    {\n\tpos_T save_cursor;\n\n\t// Move the cursor to the first line in the buffer\n\tsave_cursor = curwin->w_cursor;\n\tcurwin->w_cursor.lnum = 0;\n\tif (!do_search(NULL, '/', '/', qf_pattern, (long)1, SEARCH_KEEP, NULL))\n\t    curwin->w_cursor = save_cursor;\n    }\n}\n\n/*\n * Display quickfix list index and size message\n */\n    static void\nqf_jump_print_msg(\n\tqf_info_T\t*qi,\n\tint\t\tqf_index,\n\tqfline_T\t*qf_ptr,\n\tbuf_T\t\t*old_curbuf,\n\tlinenr_T\told_lnum)\n{\n    linenr_T\t\ti;\n    garray_T\t\t*gap;\n\n    gap = qfga_get();\n\n    // Update the screen before showing the message, unless the screen\n    // scrolled up.\n    if (!msg_scrolled)\n\tupdate_topline_redraw();\n    vim_snprintf((char *)IObuff, IOSIZE, _(\"(%d of %d)%s%s: \"), qf_index,\n\t    qf_get_curlist(qi)->qf_count,\n\t    qf_ptr->qf_cleared ? _(\" (line deleted)\") : \"\",\n\t    (char *)qf_types(qf_ptr->qf_type, qf_ptr->qf_nr));\n    // Add the message, skipping leading whitespace and newlines.\n    ga_concat(gap, IObuff);\n    qf_fmt_text(gap, skipwhite(qf_ptr->qf_text));\n\n    // Output the message.  Overwrite to avoid scrolling when the 'O'\n    // flag is present in 'shortmess'; But when not jumping, print the\n    // whole message.\n    i = msg_scroll;\n    if (curbuf == old_curbuf && curwin->w_cursor.lnum == old_lnum)\n\tmsg_scroll = TRUE;\n    else if (!msg_scrolled && shortmess(SHM_OVERALL))\n\tmsg_scroll = FALSE;\n    msg_attr_keep((char *)gap->ga_data, 0, TRUE);\n    msg_scroll = i;\n\n    qfga_clear();\n}\n\n/*\n * Find a usable window for opening a file from the quickfix/location list. If\n * a window is not found then open a new window. If 'newwin' is TRUE, then open\n * a new window.\n * Returns OK if successfully jumped or opened a window. Returns FAIL if not\n * able to jump/open a window.  Returns NOTDONE if a file is not associated\n * with the entry.  Returns QF_ABORT if the quickfix/location list was modified\n * by an autocmd.\n */\n    static int\nqf_jump_open_window(\n\tqf_info_T\t*qi,\n\tqfline_T\t*qf_ptr,\n\tint\t\tnewwin,\n\tint\t\t*opened_window)\n{\n    qf_list_T\t*qfl = qf_get_curlist(qi);\n    int\t\told_changedtick = qfl->qf_changedtick;\n    int\t\told_qf_curlist = qi->qf_curlist;\n    qfltype_T\tqfl_type = qfl->qfl_type;\n\n    // For \":helpgrep\" find a help window or open one.\n    if (qf_ptr->qf_type == 1 && (!bt_help(curwin->w_buffer)\n\t\t\t\t\t\t      || cmdmod.cmod_tab != 0))\n\tif (jump_to_help_window(qi, newwin, opened_window) == FAIL)\n\t    return FAIL;\n    if (old_qf_curlist != qi->qf_curlist\n\t    || old_changedtick != qfl->qf_changedtick\n\t    || !is_qf_entry_present(qfl, qf_ptr))\n    {\n\tif (qfl_type == QFLT_QUICKFIX)\n\t    emsg(_(e_current_quickfix_list_was_changed));\n\telse\n\t    emsg(_(e_current_location_list_was_changed));\n\treturn QF_ABORT;\n    }\n\n    // If currently in the quickfix window, find another window to show the\n    // file in.\n    if (bt_quickfix(curbuf) && !*opened_window)\n    {\n\t// If there is no file specified, we don't know where to go.\n\t// But do advance, otherwise \":cn\" gets stuck.\n\tif (qf_ptr->qf_fnum == 0)\n\t    return NOTDONE;\n\n\tif (qf_jump_to_usable_window(qf_ptr->qf_fnum, newwin,\n\t\t\t\t\t\topened_window) == FAIL)\n\t    return FAIL;\n    }\n    if (old_qf_curlist != qi->qf_curlist\n\t    || old_changedtick != qfl->qf_changedtick\n\t    || !is_qf_entry_present(qfl, qf_ptr))\n    {\n\tif (qfl_type == QFLT_QUICKFIX)\n\t    emsg(_(e_current_quickfix_list_was_changed));\n\telse\n\t    emsg(_(e_current_location_list_was_changed));\n\treturn QF_ABORT;\n    }\n\n    return OK;\n}\n\n/*\n * Edit a selected file from the quickfix/location list and jump to a\n * particular line/column, adjust the folds and display a message about the\n * jump.\n * Returns OK on success and FAIL on failing to open the file/buffer.  Returns\n * QF_ABORT if the quickfix/location list is freed by an autocmd when opening\n * the file.\n */\n    static int\nqf_jump_to_buffer(\n\tqf_info_T\t*qi,\n\tint\t\tqf_index,\n\tqfline_T\t*qf_ptr,\n\tint\t\tforceit,\n\tint\t\tprev_winid,\n\tint\t\t*opened_window,\n\tint\t\topenfold,\n\tint\t\tprint_message)\n{\n    buf_T\t*old_curbuf;\n    linenr_T\told_lnum;\n    int\t\tretval = OK;\n\n    // If there is a file name, read the wanted file if needed, and check\n    // autowrite etc.\n    old_curbuf = curbuf;\n    old_lnum = curwin->w_cursor.lnum;\n\n    if (qf_ptr->qf_fnum != 0)\n    {\n\tretval = qf_jump_edit_buffer(qi, qf_ptr, forceit, prev_winid,\n\t\t\t\t\t\topened_window);\n\tif (retval != OK)\n\t    return retval;\n    }\n\n    // When not switched to another buffer, still need to set pc mark\n    if (curbuf == old_curbuf)\n\tsetpcmark();\n\n    qf_jump_goto_line(qf_ptr->qf_lnum, qf_ptr->qf_col, qf_ptr->qf_viscol,\n\t    qf_ptr->qf_pattern);\n\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_QUICKFIX) && openfold)\n\tfoldOpenCursor();\n#endif\n    if (print_message)\n\tqf_jump_print_msg(qi, qf_index, qf_ptr, old_curbuf, old_lnum);\n\n    return retval;\n}\n\n/*\n * Jump to a quickfix line and try to use an existing window.\n */\n    void\nqf_jump(qf_info_T\t*qi,\n\tint\t\tdir,\n\tint\t\terrornr,\n\tint\t\tforceit)\n{\n    qf_jump_newwin(qi, dir, errornr, forceit, FALSE);\n}\n\n/*\n * Jump to a quickfix line.\n * If dir == 0 go to entry \"errornr\".\n * If dir == FORWARD go \"errornr\" valid entries forward.\n * If dir == BACKWARD go \"errornr\" valid entries backward.\n * If dir == FORWARD_FILE go \"errornr\" valid entries files backward.\n * If dir == BACKWARD_FILE go \"errornr\" valid entries files backward\n * else if \"errornr\" is zero, redisplay the same line\n * If 'forceit' is TRUE, then can discard changes to the current buffer.\n * If 'newwin' is TRUE, then open the file in a new window.\n */\n    static void\nqf_jump_newwin(qf_info_T\t*qi,\n\tint\t\tdir,\n\tint\t\terrornr,\n\tint\t\tforceit,\n\tint\t\tnewwin)\n{\n    qf_list_T\t\t*qfl;\n    qfline_T\t\t*qf_ptr;\n    qfline_T\t\t*old_qf_ptr;\n    int\t\t\tqf_index;\n    int\t\t\told_qf_index;\n    char_u\t\t*old_swb = p_swb;\n    unsigned\t\told_swb_flags = swb_flags;\n    int\t\t\tprev_winid;\n    int\t\t\topened_window = FALSE;\n    int\t\t\tprint_message = TRUE;\n    int\t\t\told_KeyTyped = KeyTyped; // getting file may reset it\n    int\t\t\tretval = OK;\n\n    if (qi == NULL)\n\tqi = &ql_info;\n\n    if (qf_stack_empty(qi) || qf_list_empty(qf_get_curlist(qi)))\n    {\n\temsg(_(e_no_errors));\n\treturn;\n    }\n\n    incr_quickfix_busy();\n\n    qfl = qf_get_curlist(qi);\n\n    qf_ptr = qfl->qf_ptr;\n    old_qf_ptr = qf_ptr;\n    qf_index = qfl->qf_index;\n    old_qf_index = qf_index;\n\n    qf_ptr = qf_get_entry(qfl, errornr, dir, &qf_index);\n    if (qf_ptr == NULL)\n    {\n\tqf_ptr = old_qf_ptr;\n\tqf_index = old_qf_index;\n\tgoto theend;\n    }\n\n    qfl->qf_index = qf_index;\n    qfl->qf_ptr = qf_ptr;\n    if (qf_win_pos_update(qi, old_qf_index))\n\t// No need to print the error message if it's visible in the error\n\t// window\n\tprint_message = FALSE;\n\n    prev_winid = curwin->w_id;\n\n    retval = qf_jump_open_window(qi, qf_ptr, newwin, &opened_window);\n    if (retval == FAIL)\n\tgoto failed;\n    if (retval == QF_ABORT)\n    {\n\tqi = NULL;\n\tqf_ptr = NULL;\n\tgoto theend;\n    }\n    if (retval == NOTDONE)\n\tgoto theend;\n\n    retval = qf_jump_to_buffer(qi, qf_index, qf_ptr, forceit, prev_winid,\n\t\t\t\t  &opened_window, old_KeyTyped, print_message);\n    if (retval == QF_ABORT)\n    {\n\t// Quickfix/location list was modified by an autocmd\n\tqi = NULL;\n\tqf_ptr = NULL;\n    }\n\n    if (retval != OK)\n    {\n\tif (opened_window)\n\t    win_close(curwin, TRUE);    // Close opened window\n\tif (qf_ptr != NULL && qf_ptr->qf_fnum != 0)\n\t{\n\t    // Couldn't open file, so put index back where it was.  This could\n\t    // happen if the file was readonly and we changed something.\nfailed:\n\t    qf_ptr = old_qf_ptr;\n\t    qf_index = old_qf_index;\n\t}\n    }\ntheend:\n    if (qi != NULL)\n    {\n\tqfl->qf_ptr = qf_ptr;\n\tqfl->qf_index = qf_index;\n    }\n    if (p_swb != old_swb && p_swb == empty_option)\n    {\n\t// Restore old 'switchbuf' value, but not when an autocommand or\n\t// modeline has changed the value.\n\tp_swb = old_swb;\n\tswb_flags = old_swb_flags;\n    }\n    decr_quickfix_busy();\n}\n\n// Highlight attributes used for displaying entries from the quickfix list.\nstatic int\tqfFileAttr;\nstatic int\tqfSepAttr;\nstatic int\tqfLineAttr;\n\n/*\n * Display information about a single entry from the quickfix/location list.\n * Used by \":clist/:llist\" commands.\n * 'cursel' will be set to TRUE for the currently selected entry in the\n * quickfix list.\n */\n    static void\nqf_list_entry(qfline_T *qfp, int qf_idx, int cursel)\n{\n    char_u\t*fname;\n    buf_T\t*buf;\n    int\t\tfilter_entry;\n    garray_T\t*gap;\n\n    fname = NULL;\n    if (qfp->qf_module != NULL && *qfp->qf_module != NUL)\n\tvim_snprintf((char *)IObuff, IOSIZE, \"%2d %s\", qf_idx,\n\t\t\t\t\t\t(char *)qfp->qf_module);\n    else\n    {\n\tif (qfp->qf_fnum != 0\n\t\t&& (buf = buflist_findnr(qfp->qf_fnum)) != NULL)\n\t{\n\t    fname = buf->b_fname;\n\t    if (qfp->qf_type == 1)\t// :helpgrep\n\t\tfname = gettail(fname);\n\t}\n\tif (fname == NULL)\n\t    sprintf((char *)IObuff, \"%2d\", qf_idx);\n\telse\n\t    vim_snprintf((char *)IObuff, IOSIZE, \"%2d %s\",\n\t\t    qf_idx, (char *)fname);\n    }\n\n    // Support for filtering entries using :filter /pat/ clist\n    // Match against the module name, file name, search pattern and\n    // text of the entry.\n    filter_entry = TRUE;\n    if (qfp->qf_module != NULL && *qfp->qf_module != NUL)\n\tfilter_entry &= message_filtered(qfp->qf_module);\n    if (filter_entry && fname != NULL)\n\tfilter_entry &= message_filtered(fname);\n    if (filter_entry && qfp->qf_pattern != NULL)\n\tfilter_entry &= message_filtered(qfp->qf_pattern);\n    if (filter_entry)\n\tfilter_entry &= message_filtered(qfp->qf_text);\n    if (filter_entry)\n\treturn;\n\n    msg_putchar('\\n');\n    msg_outtrans_attr(IObuff, cursel ? HL_ATTR(HLF_QFL) : qfFileAttr);\n\n    if (qfp->qf_lnum != 0)\n\tmsg_puts_attr(\":\", qfSepAttr);\n    gap = qfga_get();\n    if (qfp->qf_lnum == 0)\n\tga_append(gap, NUL);\n    else\n\tqf_range_text(gap, qfp);\n    ga_concat(gap, qf_types(qfp->qf_type, qfp->qf_nr));\n    ga_append(gap, NUL);\n    msg_puts_attr((char *)gap->ga_data, qfLineAttr);\n    msg_puts_attr(\":\", qfSepAttr);\n    if (qfp->qf_pattern != NULL)\n    {\n\tgap = qfga_get();\n\tqf_fmt_text(gap, qfp->qf_pattern);\n\tmsg_puts((char *)gap->ga_data);\n\tmsg_puts_attr(\":\", qfSepAttr);\n    }\n    msg_puts(\" \");\n\n    // Remove newlines and leading whitespace from the text.  For an\n    // unrecognized line keep the indent, the compiler may mark a word\n    // with ^^^^.\n    gap = qfga_get();\n    qf_fmt_text(gap, (fname != NULL || qfp->qf_lnum != 0)\n\t    ? skipwhite(qfp->qf_text) : qfp->qf_text);\n    msg_prt_line((char_u *)gap->ga_data, FALSE);\n    out_flush();\t\t// show one line at a time\n}\n\n/*\n * \":clist\": list all errors\n * \":llist\": list all locations\n */\n    void\nqf_list(exarg_T *eap)\n{\n    qf_list_T\t*qfl;\n    qfline_T\t*qfp;\n    int\t\ti;\n    int\t\tidx1 = 1;\n    int\t\tidx2 = -1;\n    char_u\t*arg = eap->arg;\n    int\t\tplus = FALSE;\n    int\t\tall = eap->forceit;\t// if not :cl!, only show\n\t\t\t\t\t// recognised errors\n    qf_info_T\t*qi;\n\n    if ((qi = qf_cmd_get_stack(eap, TRUE)) == NULL)\n\treturn;\n\n    if (qf_stack_empty(qi) || qf_list_empty(qf_get_curlist(qi)))\n    {\n\temsg(_(e_no_errors));\n\treturn;\n    }\n    if (*arg == '+')\n    {\n\t++arg;\n\tplus = TRUE;\n    }\n    if (!get_list_range(&arg, &idx1, &idx2) || *arg != NUL)\n    {\n\tsemsg(_(e_trailing_characters_str), arg);\n\treturn;\n    }\n    qfl = qf_get_curlist(qi);\n    if (plus)\n    {\n\ti = qfl->qf_index;\n\tidx2 = i + idx1;\n\tidx1 = i;\n    }\n    else\n    {\n\ti = qfl->qf_count;\n\tif (idx1 < 0)\n\t    idx1 = (-idx1 > i) ? 0 : idx1 + i + 1;\n\tif (idx2 < 0)\n\t    idx2 = (-idx2 > i) ? 0 : idx2 + i + 1;\n    }\n\n    // Shorten all the file names, so that it is easy to read\n    shorten_fnames(FALSE);\n\n    // Get the attributes for the different quickfix highlight items.  Note\n    // that this depends on syntax items defined in the qf.vim syntax file\n    qfFileAttr = syn_name2attr((char_u *)\"qfFileName\");\n    if (qfFileAttr == 0)\n\tqfFileAttr = HL_ATTR(HLF_D);\n    qfSepAttr = syn_name2attr((char_u *)\"qfSeparator\");\n    if (qfSepAttr == 0)\n\tqfSepAttr = HL_ATTR(HLF_D);\n    qfLineAttr = syn_name2attr((char_u *)\"qfLineNr\");\n    if (qfLineAttr == 0)\n\tqfLineAttr = HL_ATTR(HLF_N);\n\n    if (qfl->qf_nonevalid)\n\tall = TRUE;\n    FOR_ALL_QFL_ITEMS(qfl, qfp, i)\n    {\n\tif ((qfp->qf_valid || all) && idx1 <= i && i <= idx2)\n\t    qf_list_entry(qfp, i, i == qfl->qf_index);\n\n\tui_breakcheck();\n    }\n    qfga_clear();\n}\n\n/*\n * Remove newlines and leading whitespace from an error message.\n * Add the result to the grow array \"gap\".\n */\n    static void\nqf_fmt_text(garray_T *gap, char_u *text)\n{\n    char_u\t*p = text;\n\n    while (*p != NUL)\n    {\n\tif (*p == '\\n')\n\t{\n\t    ga_append(gap, ' ');\n\t    while (*++p != NUL)\n\t\tif (!VIM_ISWHITE(*p) && *p != '\\n')\n\t\t    break;\n\t}\n\telse\n\t    ga_append(gap, *p++);\n    }\n\n    ga_append(gap, NUL);\n}\n\n/*\n * Add the range information from the lnum, col, end_lnum, and end_col values\n * of a quickfix entry to the grow array \"gap\".\n */\n    static void\nqf_range_text(garray_T *gap, qfline_T *qfp)\n{\n    char_u\t*buf = IObuff;\n    int\t\tbufsize = IOSIZE;\n    int len;\n\n    vim_snprintf((char *)buf, bufsize, \"%ld\", qfp->qf_lnum);\n    len = (int)STRLEN(buf);\n\n    if (qfp->qf_end_lnum > 0 && qfp->qf_lnum != qfp->qf_end_lnum)\n    {\n\tvim_snprintf((char *)buf + len, bufsize - len,\n\t\t\"-%ld\", qfp->qf_end_lnum);\n\tlen += (int)STRLEN(buf + len);\n    }\n    if (qfp->qf_col > 0)\n    {\n\tvim_snprintf((char *)buf + len, bufsize - len, \" col %d\", qfp->qf_col);\n\tlen += (int)STRLEN(buf + len);\n\tif (qfp->qf_end_col > 0 && qfp->qf_col != qfp->qf_end_col)\n\t{\n\t    vim_snprintf((char *)buf + len, bufsize - len,\n\t\t    \"-%d\", qfp->qf_end_col);\n\t    len += (int)STRLEN(buf + len);\n\t}\n    }\n    buf[len] = NUL;\n\n    ga_concat_len(gap, buf, len);\n}\n\n/*\n * Display information (list number, list size and the title) about a\n * quickfix/location list.\n */\n    static void\nqf_msg(qf_info_T *qi, int which, char *lead)\n{\n    char   *title = (char *)qi->qf_lists[which].qf_title;\n    int    count = qi->qf_lists[which].qf_count;\n    char_u buf[IOSIZE];\n\n    vim_snprintf((char *)buf, IOSIZE, _(\"%serror list %d of %d; %d errors \"),\n\t    lead,\n\t    which + 1,\n\t    qi->qf_listcount,\n\t    count);\n\n    if (title != NULL)\n    {\n\tsize_t\tlen = STRLEN(buf);\n\n\tif (len < 34)\n\t{\n\t    vim_memset(buf + len, ' ', 34 - len);\n\t    buf[34] = NUL;\n\t}\n\tvim_strcat(buf, (char_u *)title, IOSIZE);\n    }\n    trunc_string(buf, buf, Columns - 1, IOSIZE);\n    msg((char *)buf);\n}\n\n/*\n * \":colder [count]\": Up in the quickfix stack.\n * \":cnewer [count]\": Down in the quickfix stack.\n * \":lolder [count]\": Up in the location list stack.\n * \":lnewer [count]\": Down in the location list stack.\n */\n    void\nqf_age(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n    int\t\tcount;\n\n    if ((qi = qf_cmd_get_stack(eap, TRUE)) == NULL)\n\treturn;\n\n    if (eap->addr_count != 0)\n\tcount = eap->line2;\n    else\n\tcount = 1;\n    while (count--)\n    {\n\tif (eap->cmdidx == CMD_colder || eap->cmdidx == CMD_lolder)\n\t{\n\t    if (qi->qf_curlist == 0)\n\t    {\n\t\temsg(_(e_at_bottom_of_quickfix_stack));\n\t\tbreak;\n\t    }\n\t    --qi->qf_curlist;\n\t}\n\telse\n\t{\n\t    if (qi->qf_curlist >= qi->qf_listcount - 1)\n\t    {\n\t\temsg(_(e_at_top_of_quickfix_stack));\n\t\tbreak;\n\t    }\n\t    ++qi->qf_curlist;\n\t}\n    }\n    qf_msg(qi, qi->qf_curlist, \"\");\n    qf_update_buffer(qi, NULL);\n}\n\n/*\n * Display the information about all the quickfix/location lists in the stack\n */\n    void\nqf_history(exarg_T *eap)\n{\n    qf_info_T\t*qi = qf_cmd_get_stack(eap, FALSE);\n    int\t\ti;\n\n    if (eap->addr_count > 0)\n    {\n\tif (qi == NULL)\n\t{\n\t    emsg(_(e_no_location_list));\n\t    return;\n\t}\n\n\t// Jump to the specified quickfix list\n\tif (eap->line2 > 0 && eap->line2 <= qi->qf_listcount)\n\t{\n\t    qi->qf_curlist = eap->line2 - 1;\n\t    qf_msg(qi, qi->qf_curlist, \"\");\n\t    qf_update_buffer(qi, NULL);\n\t}\n\telse\n\t    emsg(_(e_invalid_range));\n\n\treturn;\n    }\n\n    if (qf_stack_empty(qi))\n\tmsg(_(\"No entries\"));\n    else\n\tfor (i = 0; i < qi->qf_listcount; ++i)\n\t    qf_msg(qi, i, i == qi->qf_curlist ? \"> \" : \"  \");\n}\n\n/*\n * Free all the entries in the error list \"idx\". Note that other information\n * associated with the list like context and title are not freed.\n */\n    static void\nqf_free_items(qf_list_T *qfl)\n{\n    qfline_T\t*qfp;\n    qfline_T\t*qfpnext;\n    int\t\tstop = FALSE;\n\n    while (qfl->qf_count && qfl->qf_start != NULL)\n    {\n\tqfp = qfl->qf_start;\n\tqfpnext = qfp->qf_next;\n\tif (!stop)\n\t{\n\t    vim_free(qfp->qf_module);\n\t    vim_free(qfp->qf_text);\n\t    vim_free(qfp->qf_pattern);\n\t    stop = (qfp == qfpnext);\n\t    vim_free(qfp);\n\t    if (stop)\n\t\t// Somehow qf_count may have an incorrect value, set it to 1\n\t\t// to avoid crashing when it's wrong.\n\t\t// TODO: Avoid qf_count being incorrect.\n\t\tqfl->qf_count = 1;\n\t}\n\tqfl->qf_start = qfpnext;\n\t--qfl->qf_count;\n    }\n\n    qfl->qf_index = 0;\n    qfl->qf_start = NULL;\n    qfl->qf_last = NULL;\n    qfl->qf_ptr = NULL;\n    qfl->qf_nonevalid = TRUE;\n\n    qf_clean_dir_stack(&qfl->qf_dir_stack);\n    qfl->qf_directory = NULL;\n    qf_clean_dir_stack(&qfl->qf_file_stack);\n    qfl->qf_currfile = NULL;\n    qfl->qf_multiline = FALSE;\n    qfl->qf_multiignore = FALSE;\n    qfl->qf_multiscan = FALSE;\n}\n\n/*\n * Free error list \"idx\". Frees all the entries in the quickfix list,\n * associated context information and the title.\n */\n    static void\nqf_free(qf_list_T *qfl)\n{\n    qf_free_items(qfl);\n\n    VIM_CLEAR(qfl->qf_title);\n    free_tv(qfl->qf_ctx);\n    qfl->qf_ctx = NULL;\n    free_callback(&qfl->qf_qftf_cb);\n    qfl->qf_id = 0;\n    qfl->qf_changedtick = 0L;\n}\n\n/*\n * qf_mark_adjust: adjust marks\n */\n   void\nqf_mark_adjust(\n\twin_T\t*wp,\n\tlinenr_T\tline1,\n\tlinenr_T\tline2,\n\tlong\tamount,\n\tlong\tamount_after)\n{\n    int\t\ti;\n    qfline_T\t*qfp;\n    int\t\tidx;\n    qf_info_T\t*qi = &ql_info;\n    int\t\tfound_one = FALSE;\n    int\t\tbuf_has_flag = wp == NULL ? BUF_HAS_QF_ENTRY : BUF_HAS_LL_ENTRY;\n\n    if (!(curbuf->b_has_qf_entry & buf_has_flag))\n\treturn;\n    if (wp != NULL)\n    {\n\tif (wp->w_llist == NULL)\n\t    return;\n\tqi = wp->w_llist;\n    }\n\n    for (idx = 0; idx < qi->qf_listcount; ++idx)\n    {\n\tqf_list_T\t*qfl = qf_get_list(qi, idx);\n\n\tif (!qf_list_empty(qfl))\n\t    FOR_ALL_QFL_ITEMS(qfl, qfp, i)\n\t\tif (qfp->qf_fnum == curbuf->b_fnum)\n\t\t{\n\t\t    found_one = TRUE;\n\t\t    if (qfp->qf_lnum >= line1 && qfp->qf_lnum <= line2)\n\t\t    {\n\t\t\tif (amount == MAXLNUM)\n\t\t\t    qfp->qf_cleared = TRUE;\n\t\t\telse\n\t\t\t    qfp->qf_lnum += amount;\n\t\t    }\n\t\t    else if (amount_after && qfp->qf_lnum > line2)\n\t\t\tqfp->qf_lnum += amount_after;\n\t\t}\n    }\n\n    if (!found_one)\n\tcurbuf->b_has_qf_entry &= ~buf_has_flag;\n}\n\n/*\n * Make a nice message out of the error character and the error number:\n *  char    number\tmessage\n *  e or E    0\t\t\" error\"\n *  w or W    0\t\t\" warning\"\n *  i or I    0\t\t\" info\"\n *  n or N    0\t\t\" note\"\n *  0\t      0\t\t\"\"\n *  other     0\t\t\" c\"\n *  e or E    n\t\t\" error n\"\n *  w or W    n\t\t\" warning n\"\n *  i or I    n\t\t\" info n\"\n *  n or N    n\t\t\" note n\"\n *  0\t      n\t\t\" error n\"\n *  other     n\t\t\" c n\"\n *  1\t      x\t\t\"\"\t:helpgrep\n */\n    static char_u *\nqf_types(int c, int nr)\n{\n    static char_u\tbuf[20];\n    static char_u\tcc[3];\n    char_u\t\t*p;\n\n    if (c == 'W' || c == 'w')\n\tp = (char_u *)\" warning\";\n    else if (c == 'I' || c == 'i')\n\tp = (char_u *)\" info\";\n    else if (c == 'N' || c == 'n')\n\tp = (char_u *)\" note\";\n    else if (c == 'E' || c == 'e' || (c == 0 && nr > 0))\n\tp = (char_u *)\" error\";\n    else if (c == 0 || c == 1)\n\tp = (char_u *)\"\";\n    else\n    {\n\tcc[0] = ' ';\n\tcc[1] = c;\n\tcc[2] = NUL;\n\tp = cc;\n    }\n\n    if (nr <= 0)\n\treturn p;\n\n    sprintf((char *)buf, \"%s %3d\", (char *)p, nr);\n    return buf;\n}\n\n/*\n * When \"split\" is FALSE: Open the entry/result under the cursor.\n * When \"split\" is TRUE: Open the entry/result under the cursor in a new window.\n */\n    void\nqf_view_result(int split)\n{\n    qf_info_T   *qi = &ql_info;\n\n    if (IS_LL_WINDOW(curwin))\n\tqi = GET_LOC_LIST(curwin);\n\n    if (qf_list_empty(qf_get_curlist(qi)))\n    {\n\temsg(_(e_no_errors));\n\treturn;\n    }\n\n    if (split)\n    {\n\t// Open the selected entry in a new window\n\tqf_jump_newwin(qi, 0, (long)curwin->w_cursor.lnum, FALSE, TRUE);\n\tdo_cmdline_cmd((char_u *) \"clearjumps\");\n\treturn;\n    }\n\n    do_cmdline_cmd((char_u *)(IS_LL_WINDOW(curwin) ? \".ll\" : \".cc\"));\n}\n\n/*\n * \":cwindow\": open the quickfix window if we have errors to display,\n *\t       close it if not.\n * \":lwindow\": open the location list window if we have locations to display,\n *\t       close it if not.\n */\n    void\nex_cwindow(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n    qf_list_T\t*qfl;\n    win_T\t*win;\n\n    if ((qi = qf_cmd_get_stack(eap, TRUE)) == NULL)\n\treturn;\n\n    qfl = qf_get_curlist(qi);\n\n    // Look for an existing quickfix window.\n    win = qf_find_win(qi);\n\n    // If a quickfix window is open but we have no errors to display,\n    // close the window.  If a quickfix window is not open, then open\n    // it if we have errors; otherwise, leave it closed.\n    if (qf_stack_empty(qi)\n\t    || qfl->qf_nonevalid\n\t    || qf_list_empty(qfl))\n    {\n\tif (win != NULL)\n\t    ex_cclose(eap);\n    }\n    else if (win == NULL)\n\tex_copen(eap);\n}\n\n/*\n * \":cclose\": close the window showing the list of errors.\n * \":lclose\": close the window showing the location list\n */\n    void\nex_cclose(exarg_T *eap)\n{\n    win_T\t*win = NULL;\n    qf_info_T\t*qi;\n\n    if ((qi = qf_cmd_get_stack(eap, FALSE)) == NULL)\n\treturn;\n\n    // Find existing quickfix window and close it.\n    win = qf_find_win(qi);\n    if (win != NULL)\n\twin_close(win, FALSE);\n}\n\n/*\n * Set \"w:quickfix_title\" if \"qi\" has a title.\n */\n    static void\nqf_set_title_var(qf_list_T *qfl)\n{\n    if (qfl->qf_title != NULL)\n\tset_internal_string_var((char_u *)\"w:quickfix_title\", qfl->qf_title);\n}\n\n/*\n * Goto a quickfix or location list window (if present).\n * Returns OK if the window is found, FAIL otherwise.\n */\n    static int\nqf_goto_cwindow(qf_info_T *qi, int resize, int sz, int vertsplit)\n{\n    win_T\t*win;\n\n    win = qf_find_win(qi);\n    if (win == NULL)\n\treturn FAIL;\n\n    win_goto(win);\n    if (resize)\n    {\n\tif (vertsplit)\n\t{\n\t    if (sz != win->w_width)\n\t\twin_setwidth(sz);\n\t}\n\telse if (sz != win->w_height && win->w_height\n\t\t       + win->w_status_height + tabline_height() < cmdline_row)\n\t    win_setheight(sz);\n    }\n\n    return OK;\n}\n\n/*\n * Set options for the buffer in the quickfix or location list window.\n */\n    static void\nqf_set_cwindow_options(void)\n{\n    // switch off 'swapfile'\n    set_option_value_give_err((char_u *)\"swf\", 0L, NULL, OPT_LOCAL);\n    set_option_value_give_err((char_u *)\"bt\",\n\t\t\t\t\t  0L, (char_u *)\"quickfix\", OPT_LOCAL);\n    set_option_value_give_err((char_u *)\"bh\", 0L, (char_u *)\"hide\", OPT_LOCAL);\n    RESET_BINDING(curwin);\n#ifdef FEAT_DIFF\n    curwin->w_p_diff = FALSE;\n#endif\n#ifdef FEAT_FOLDING\n    set_option_value_give_err((char_u *)\"fdm\", 0L, (char_u *)\"manual\",\n\t    OPT_LOCAL);\n#endif\n}\n\n/*\n * Open a new quickfix or location list window, load the quickfix buffer and\n * set the appropriate options for the window.\n * Returns FAIL if the window could not be opened.\n */\n    static int\nqf_open_new_cwindow(qf_info_T *qi, int height)\n{\n    buf_T\t*qf_buf;\n    win_T\t*oldwin = curwin;\n    tabpage_T\t*prevtab = curtab;\n    int\t\tflags = 0;\n    win_T\t*win;\n\n    qf_buf = qf_find_buf(qi);\n\n    // The current window becomes the previous window afterwards.\n    win = curwin;\n\n    if (IS_QF_STACK(qi) && cmdmod.cmod_split == 0)\n\t// Create the new quickfix window at the very bottom, except when\n\t// :belowright or :aboveleft is used.\n\twin_goto(lastwin);\n    // Default is to open the window below the current window\n    if (cmdmod.cmod_split == 0)\n\tflags = WSP_BELOW;\n    flags |= WSP_NEWLOC;\n    if (win_split(height, flags) == FAIL)\n\treturn FAIL;\t\t// not enough room for window\n    RESET_BINDING(curwin);\n\n    if (IS_LL_STACK(qi))\n    {\n\t// For the location list window, create a reference to the\n\t// location list stack from the window 'win'.\n\tcurwin->w_llist_ref = qi;\n\tqi->qf_refcount++;\n    }\n\n    if (oldwin != curwin)\n\toldwin = NULL;  // don't store info when in another window\n    if (qf_buf != NULL)\n    {\n\t// Use the existing quickfix buffer\n\tif (do_ecmd(qf_buf->b_fnum, NULL, NULL, NULL, ECMD_ONE,\n\t\t    ECMD_HIDE + ECMD_OLDBUF + ECMD_NOWINENTER, oldwin) == FAIL)\n\t    return FAIL;\n    }\n    else\n    {\n\t// Create a new quickfix buffer\n\tif (do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE + ECMD_NOWINENTER,\n\t\t\t\t\t\t\t       oldwin) == FAIL)\n\t    return FAIL;\n\n\t// save the number of the new buffer\n\tqi->qf_bufnr = curbuf->b_fnum;\n    }\n\n    // Set the options for the quickfix buffer/window (if not already done)\n    // Do this even if the quickfix buffer was already present, as an autocmd\n    // might have previously deleted (:bdelete) the quickfix buffer.\n    if (!bt_quickfix(curbuf))\n\tqf_set_cwindow_options();\n\n    // Only set the height when still in the same tab page and there is no\n    // window to the side.\n    if (curtab == prevtab && curwin->w_width == Columns)\n\twin_setheight(height);\n    curwin->w_p_wfh = TRUE;\t    // set 'winfixheight'\n    if (win_valid(win))\n\tprevwin = win;\n\n    return OK;\n}\n\n/*\n * \":copen\": open a window that shows the list of errors.\n * \":lopen\": open a window that shows the location list.\n */\n    void\nex_copen(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n    qf_list_T\t*qfl;\n    int\t\theight;\n    int\t\tstatus = FAIL;\n    int\t\tlnum;\n\n    if ((qi = qf_cmd_get_stack(eap, TRUE)) == NULL)\n\treturn;\n\n    incr_quickfix_busy();\n\n    if (eap->addr_count != 0)\n\theight = eap->line2;\n    else\n\theight = QF_WINHEIGHT;\n\n    reset_VIsual_and_resel();\t\t\t// stop Visual mode\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    // Find an existing quickfix window, or open a new one.\n    if (cmdmod.cmod_tab == 0)\n\tstatus = qf_goto_cwindow(qi, eap->addr_count != 0, height,\n\t\t\t\t\t\tcmdmod.cmod_split & WSP_VERT);\n    if (status == FAIL)\n\tif (qf_open_new_cwindow(qi, height) == FAIL)\n\t{\n\t    decr_quickfix_busy();\n\t    return;\n\t}\n\n    qfl = qf_get_curlist(qi);\n    qf_set_title_var(qfl);\n    // Save the current index here, as updating the quickfix buffer may free\n    // the quickfix list\n    lnum = qfl->qf_index;\n\n    // Fill the buffer with the quickfix list.\n    qf_fill_buffer(qfl, curbuf, NULL, curwin->w_id);\n\n    decr_quickfix_busy();\n\n    curwin->w_cursor.lnum = lnum;\n    curwin->w_cursor.col = 0;\n    check_cursor();\n    update_topline();\t\t// scroll to show the line\n}\n\n/*\n * Move the cursor in the quickfix window to \"lnum\".\n */\n    static void\nqf_win_goto(win_T *win, linenr_T lnum)\n{\n    win_T\t*old_curwin = curwin;\n\n    curwin = win;\n    curbuf = win->w_buffer;\n    curwin->w_cursor.lnum = lnum;\n    curwin->w_cursor.col = 0;\n    curwin->w_cursor.coladd = 0;\n    curwin->w_curswant = 0;\n    update_topline();\t\t// scroll to show the line\n    redraw_later(UPD_VALID);\n    curwin->w_redr_status = TRUE;\t// update ruler\n    curwin = old_curwin;\n    curbuf = curwin->w_buffer;\n}\n\n/*\n * :cbottom/:lbottom commands.\n */\n    void\nex_cbottom(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n    win_T\t*win;\n\n    if ((qi = qf_cmd_get_stack(eap, TRUE)) == NULL)\n\treturn;\n\n    win = qf_find_win(qi);\n    if (win != NULL && win->w_cursor.lnum != win->w_buffer->b_ml.ml_line_count)\n\tqf_win_goto(win, win->w_buffer->b_ml.ml_line_count);\n}\n\n/*\n * Return the number of the current entry (line number in the quickfix\n * window).\n */\n     linenr_T\nqf_current_entry(win_T *wp)\n{\n    qf_info_T\t*qi = &ql_info;\n\n    if (IS_LL_WINDOW(wp))\n\t// In the location list window, use the referenced location list\n\tqi = wp->w_llist_ref;\n\n    return qf_get_curlist(qi)->qf_index;\n}\n\n/*\n * Update the cursor position in the quickfix window to the current error.\n * Return TRUE if there is a quickfix window.\n */\n    static int\nqf_win_pos_update(\n    qf_info_T\t*qi,\n    int\t\told_qf_index)\t// previous qf_index or zero\n{\n    win_T\t*win;\n    int\t\tqf_index = qf_get_curlist(qi)->qf_index;\n\n    // Put the cursor on the current error in the quickfix window, so that\n    // it's viewable.\n    win = qf_find_win(qi);\n    if (win != NULL\n\t    && qf_index <= win->w_buffer->b_ml.ml_line_count\n\t    && old_qf_index != qf_index)\n    {\n\tif (qf_index > old_qf_index)\n\t{\n\t    win->w_redraw_top = old_qf_index;\n\t    win->w_redraw_bot = qf_index;\n\t}\n\telse\n\t{\n\t    win->w_redraw_top = qf_index;\n\t    win->w_redraw_bot = old_qf_index;\n\t}\n\tqf_win_goto(win, qf_index);\n    }\n    return win != NULL;\n}\n\n/*\n * Check whether the given window is displaying the specified quickfix/location\n * stack.\n */\n    static int\nis_qf_win(win_T *win, qf_info_T *qi)\n{\n    // A window displaying the quickfix buffer will have the w_llist_ref field\n    // set to NULL.\n    // A window displaying a location list buffer will have the w_llist_ref\n    // pointing to the location list.\n    if (bt_quickfix(win->w_buffer))\n\tif ((IS_QF_STACK(qi) && win->w_llist_ref == NULL)\n\t\t|| (IS_LL_STACK(qi) && win->w_llist_ref == qi))\n\t    return TRUE;\n\n    return FALSE;\n}\n\n/*\n * Find a window displaying the quickfix/location stack 'qi' in the current tab\n * page.\n */\n    static win_T *\nqf_find_win(qf_info_T *qi)\n{\n    win_T\t*win;\n\n    FOR_ALL_WINDOWS(win)\n\tif (is_qf_win(win, qi))\n\t    return win;\n    return NULL;\n}\n\n/*\n * Find a quickfix buffer.\n * Searches in windows opened in all the tab pages.\n */\n    static buf_T *\nqf_find_buf(qf_info_T *qi)\n{\n    tabpage_T\t*tp;\n    win_T\t*win;\n\n    if (qi->qf_bufnr != INVALID_QFBUFNR)\n    {\n\tbuf_T\t*qfbuf;\n\tqfbuf = buflist_findnr(qi->qf_bufnr);\n\tif (qfbuf != NULL)\n\t    return qfbuf;\n\t// buffer is no longer present\n\tqi->qf_bufnr = INVALID_QFBUFNR;\n    }\n\n    FOR_ALL_TAB_WINDOWS(tp, win)\n\tif (is_qf_win(win, qi))\n\t    return win->w_buffer;\n\n    return NULL;\n}\n\n/*\n * Process the 'quickfixtextfunc' option value.\n * Returns OK or FAIL.\n */\n    char *\ndid_set_quickfixtextfunc(optset_T *args UNUSED)\n{\n    if (option_set_callback_func(p_qftf, &qftf_cb) == FAIL)\n\treturn e_invalid_argument;\n\n    return NULL;\n}\n\n/*\n * Update the w:quickfix_title variable in the quickfix/location list window in\n * all the tab pages.\n */\n    static void\nqf_update_win_titlevar(qf_info_T *qi)\n{\n    qf_list_T\t*qfl = qf_get_curlist(qi);\n    tabpage_T\t*tp;\n    win_T\t*win;\n    win_T\t*save_curwin = curwin;\n\n    FOR_ALL_TAB_WINDOWS(tp, win)\n    {\n\tif (is_qf_win(win, qi))\n\t{\n\t    curwin = win;\n\t    qf_set_title_var(qfl);\n\t}\n    }\n    curwin = save_curwin;\n}\n\n/*\n * Find the quickfix buffer.  If it exists, update the contents.\n */\n    static void\nqf_update_buffer(qf_info_T *qi, qfline_T *old_last)\n{\n    buf_T\t*buf;\n    win_T\t*win;\n    aco_save_T\taco;\n\n    // Check if a buffer for the quickfix list exists.  Update it.\n    buf = qf_find_buf(qi);\n    if (buf == NULL)\n\treturn;\n\n    linenr_T\told_line_count = buf->b_ml.ml_line_count;\n    int\t\tqf_winid = 0;\n\n    if (IS_LL_STACK(qi))\n    {\n\tif (curwin->w_llist == qi)\n\t    win = curwin;\n\telse\n\t{\n\t    // Find the file window (non-quickfix) with this location list\n\t    win = qf_find_win_with_loclist(qi);\n\t    if (win == NULL)\n\t\t// File window is not found. Find the location list window.\n\t\twin = qf_find_win(qi);\n\t    if (win == NULL)\n\t\treturn;\n\t}\n\tqf_winid = win->w_id;\n    }\n\n    // autocommands may cause trouble\n    incr_quickfix_busy();\n\n    int do_fill = TRUE;\n    if (old_last == NULL)\n    {\n\t// set curwin/curbuf to buf and save a few things\n\taucmd_prepbuf(&aco, buf);\n\tif (curbuf != buf)\n\t    do_fill = FALSE;  // failed to find a window for \"buf\"\n    }\n\n    if (do_fill)\n    {\n\tqf_update_win_titlevar(qi);\n\n\tqf_fill_buffer(qf_get_curlist(qi), buf, old_last, qf_winid);\n\t++CHANGEDTICK(buf);\n\n\tif (old_last == NULL)\n\t{\n\t    (void)qf_win_pos_update(qi, 0);\n\n\t    // restore curwin/curbuf and a few other things\n\t    aucmd_restbuf(&aco);\n\t}\n    }\n\n    // Only redraw when added lines are visible.  This avoids flickering\n    // when the added lines are not visible.\n    if ((win = qf_find_win(qi)) != NULL && old_line_count < win->w_botline)\n\tredraw_buf_later(buf, UPD_NOT_VALID);\n\n    // always called after incr_quickfix_busy()\n    decr_quickfix_busy();\n}\n\n/*\n * Add an error line to the quickfix buffer.\n */\n    static int\nqf_buf_add_line(\n\tbuf_T\t\t*buf,\t\t// quickfix window buffer\n\tlinenr_T\tlnum,\n\tqfline_T\t*qfp,\n\tchar_u\t\t*dirname,\n\tint\t\tfirst_bufline,\n\tchar_u\t\t*qftf_str)\n{\n    buf_T\t*errbuf;\n    garray_T\t*gap;\n\n    gap = qfga_get();\n\n    // If the 'quickfixtextfunc' function returned a non-empty custom string\n    // for this entry, then use it.\n    if (qftf_str != NULL && *qftf_str != NUL)\n    {\n\tga_concat(gap, qftf_str);\n\tga_append(gap, NUL);\n    }\n    else\n    {\n\tif (qfp->qf_module != NULL)\n\t    ga_concat(gap, qfp->qf_module);\n\telse if (qfp->qf_fnum != 0\n\t\t&& (errbuf = buflist_findnr(qfp->qf_fnum)) != NULL\n\t\t&& errbuf->b_fname != NULL)\n\t{\n\t    if (qfp->qf_type == 1)\t// :helpgrep\n\t\tga_concat(gap, gettail(errbuf->b_fname));\n\t    else\n\t    {\n\t\t// Shorten the file name if not done already.\n\t\t// For optimization, do this only for the first entry in a\n\t\t// buffer.\n\t\tif (first_bufline && (errbuf->b_sfname == NULL\n\t\t\t\t|| mch_isFullName(errbuf->b_sfname)))\n\t\t{\n\t\t    if (*dirname == NUL)\n\t\t\tmch_dirname(dirname, MAXPATHL);\n\t\t    shorten_buf_fname(errbuf, dirname, FALSE);\n\t\t}\n\t\tga_concat(gap, errbuf->b_fname);\n\t    }\n\t}\n\n\tga_append(gap, '|');\n\n\tif (qfp->qf_lnum > 0)\n\t{\n\t    qf_range_text(gap, qfp);\n\t    ga_concat(gap, qf_types(qfp->qf_type, qfp->qf_nr));\n\t}\n\telse if (qfp->qf_pattern != NULL)\n\t    qf_fmt_text(gap, qfp->qf_pattern);\n\tga_append(gap, '|');\n\tga_append(gap, ' ');\n\n\t// Remove newlines and leading whitespace from the text.\n\t// For an unrecognized line keep the indent, the compiler may\n\t// mark a word with ^^^^.\n\tqf_fmt_text(gap, gap->ga_len > 3 ? skipwhite(qfp->qf_text)\n\t\t\t\t\t\t\t       : qfp->qf_text);\n    }\n\n    if (ml_append_buf(buf, lnum, gap->ga_data, gap->ga_len, FALSE) == FAIL)\n\treturn FAIL;\n\n    return OK;\n}\n\n/*\n * Call the 'quickfixtextfunc' function to get the list of lines to display in\n * the quickfix window for the entries 'start_idx' to 'end_idx'.\n */\n    static list_T *\ncall_qftf_func(qf_list_T *qfl, int qf_winid, long start_idx, long end_idx)\n{\n    callback_T\t*cb = &qftf_cb;\n    list_T\t*qftf_list = NULL;\n    static int\trecursive = FALSE;\n\n    if (recursive)\n\treturn NULL;  // this doesn't work properly recursively\n    recursive = TRUE;\n\n    // If 'quickfixtextfunc' is set, then use the user-supplied function to get\n    // the text to display. Use the local value of 'quickfixtextfunc' if it is\n    // set.\n    if (qfl->qf_qftf_cb.cb_name != NULL)\n\tcb = &qfl->qf_qftf_cb;\n    if (cb->cb_name != NULL)\n    {\n\ttypval_T\targs[1];\n\tdict_T\t\t*d;\n\ttypval_T\trettv;\n\n\t// create the dict argument\n\tif ((d = dict_alloc_lock(VAR_FIXED)) == NULL)\n\t{\n\t    recursive = FALSE;\n\t    return NULL;\n\t}\n\tdict_add_number(d, \"quickfix\", (long)IS_QF_LIST(qfl));\n\tdict_add_number(d, \"winid\", (long)qf_winid);\n\tdict_add_number(d, \"id\", (long)qfl->qf_id);\n\tdict_add_number(d, \"start_idx\", start_idx);\n\tdict_add_number(d, \"end_idx\", end_idx);\n\t++d->dv_refcount;\n\targs[0].v_type = VAR_DICT;\n\targs[0].vval.v_dict = d;\n\n\tqftf_list = NULL;\n\tif (call_callback(cb, 0, &rettv, 1, args) != FAIL)\n\t{\n\t    if (rettv.v_type == VAR_LIST)\n\t    {\n\t\tqftf_list = rettv.vval.v_list;\n\t\tqftf_list->lv_refcount++;\n\t    }\n\t    clear_tv(&rettv);\n\t}\n\tdict_unref(d);\n    }\n\n    recursive = FALSE;\n    return qftf_list;\n}\n\n/*\n * Fill current buffer with quickfix errors, replacing any previous contents.\n * curbuf must be the quickfix buffer!\n * If \"old_last\" is not NULL append the items after this one.\n * When \"old_last\" is NULL then \"buf\" must equal \"curbuf\"!  Because\n * ml_delete() is used and autocommands will be triggered.\n */\n    static void\nqf_fill_buffer(qf_list_T *qfl, buf_T *buf, qfline_T *old_last, int qf_winid)\n{\n    linenr_T\tlnum;\n    qfline_T\t*qfp;\n    int\t\told_KeyTyped = KeyTyped;\n    list_T\t*qftf_list = NULL;\n    listitem_T\t*qftf_li = NULL;\n\n    if (old_last == NULL)\n    {\n\tif (buf != curbuf)\n\t{\n\t    internal_error(\"qf_fill_buffer()\");\n\t    return;\n\t}\n\n\t// delete all existing lines\n\twhile ((curbuf->b_ml.ml_flags & ML_EMPTY) == 0)\n\t    (void)ml_delete((linenr_T)1);\n    }\n\n    // Check if there is anything to display\n    if (qfl != NULL && qfl->qf_start != NULL)\n    {\n\tchar_u\t\tdirname[MAXPATHL];\n\tint\t\tinvalid_val = FALSE;\n\tint\t\tprev_bufnr = -1;\n\n\t*dirname = NUL;\n\n\t// Add one line for each error\n\tif (old_last == NULL)\n\t{\n\t    qfp = qfl->qf_start;\n\t    lnum = 0;\n\t}\n\telse\n\t{\n\t    if (old_last->qf_next != NULL)\n\t\tqfp = old_last->qf_next;\n\t    else\n\t\tqfp = old_last;\n\t    lnum = buf->b_ml.ml_line_count;\n\t}\n\n\tqftf_list = call_qftf_func(qfl, qf_winid, (long)(lnum + 1),\n\t\t\t\t\t\t\t(long)qfl->qf_count);\n\tif (qftf_list != NULL)\n\t    qftf_li = qftf_list->lv_first;\n\n\twhile (lnum < qfl->qf_count)\n\t{\n\t    char_u\t*qftf_str = NULL;\n\n\t    // Use the text supplied by the user defined function (if any).\n\t    // If the returned value is not string, then ignore the rest\n\t    // of the returned values and use the default.\n\t    if (qftf_li != NULL && !invalid_val)\n\t    {\n\t\tqftf_str = tv_get_string_chk(&qftf_li->li_tv);\n\t\tif (qftf_str == NULL)\n\t\t    invalid_val = TRUE;\n\t    }\n\n\t    if (qf_buf_add_line(buf, lnum, qfp, dirname,\n\t\t\tprev_bufnr != qfp->qf_fnum, qftf_str) == FAIL)\n\t\tbreak;\n\n\t    prev_bufnr = qfp->qf_fnum;\n\t    ++lnum;\n\t    qfp = qfp->qf_next;\n\t    if (qfp == NULL)\n\t\tbreak;\n\n\t    if (qftf_li != NULL)\n\t\tqftf_li = qftf_li->li_next;\n\t}\n\n\tif (old_last == NULL)\n\t    // Delete the empty line which is now at the end\n\t    (void)ml_delete(lnum + 1);\n\n\tqfga_clear();\n    }\n\n    // correct cursor position\n    check_lnums(TRUE);\n\n    if (old_last == NULL)\n    {\n\t// Set the 'filetype' to \"qf\" each time after filling the buffer.\n\t// This resembles reading a file into a buffer, it's more logical when\n\t// using autocommands.\n\t++curbuf_lock;\n\tset_option_value_give_err((char_u *)\"ft\",\n\t\t\t\t\t\t0L, (char_u *)\"qf\", OPT_LOCAL);\n\tcurbuf->b_p_ma = FALSE;\n\n\tkeep_filetype = TRUE;\t\t// don't detect 'filetype'\n\tapply_autocmds(EVENT_BUFREADPOST, (char_u *)\"quickfix\", NULL,\n\t\t\t\t\t\t\t       FALSE, curbuf);\n\tapply_autocmds(EVENT_BUFWINENTER, (char_u *)\"quickfix\", NULL,\n\t\t\t\t\t\t\t       FALSE, curbuf);\n\tkeep_filetype = FALSE;\n\t--curbuf_lock;\n\n\t// make sure it will be redrawn\n\tredraw_curbuf_later(UPD_NOT_VALID);\n    }\n\n    // Restore KeyTyped, setting 'filetype' may reset it.\n    KeyTyped = old_KeyTyped;\n}\n\n/*\n * For every change made to the quickfix list, update the changed tick.\n */\n    static void\nqf_list_changed(qf_list_T *qfl)\n{\n    qfl->qf_changedtick++;\n}\n\n/*\n * Return the quickfix/location list number with the given identifier.\n * Returns -1 if list is not found.\n */\n    static int\nqf_id2nr(qf_info_T *qi, int_u qfid)\n{\n    int\t\tqf_idx;\n\n    for (qf_idx = 0; qf_idx < qi->qf_listcount; qf_idx++)\n\tif (qi->qf_lists[qf_idx].qf_id == qfid)\n\t    return qf_idx;\n    return INVALID_QFIDX;\n}\n\n/*\n * If the current list is not \"save_qfid\" and we can find the list with that ID\n * then make it the current list.\n * This is used when autocommands may have changed the current list.\n * Returns OK if successfully restored the list. Returns FAIL if the list with\n * the specified identifier (save_qfid) is not found in the stack.\n */\n    static int\nqf_restore_list(qf_info_T *qi, int_u save_qfid)\n{\n    int curlist;\n\n    if (qf_get_curlist(qi)->qf_id == save_qfid)\n\treturn OK;\n\n    curlist = qf_id2nr(qi, save_qfid);\n    if (curlist < 0)\n\t// list is not present\n\treturn FAIL;\n    qi->qf_curlist = curlist;\n    return OK;\n}\n\n/*\n * Jump to the first entry if there is one.\n */\n    static void\nqf_jump_first(qf_info_T *qi, int_u save_qfid, int forceit)\n{\n    if (qf_restore_list(qi, save_qfid) == FAIL)\n\treturn;\n\n    // Autocommands might have cleared the list, check for that.\n    if (!qf_list_empty(qf_get_curlist(qi)))\n\tqf_jump(qi, 0, 0, forceit);\n}\n\n/*\n * Return TRUE when using \":vimgrep\" for \":grep\".\n */\n    int\ngrep_internal(cmdidx_T cmdidx)\n{\n    return ((cmdidx == CMD_grep\n\t\t|| cmdidx == CMD_lgrep\n\t\t|| cmdidx == CMD_grepadd\n\t\t|| cmdidx == CMD_lgrepadd)\n\t    && STRCMP(\"internal\",\n\t\t\t*curbuf->b_p_gp == NUL ? p_gp : curbuf->b_p_gp) == 0);\n}\n\n/*\n * Return the make/grep autocmd name.\n */\n    static char_u *\nmake_get_auname(cmdidx_T cmdidx)\n{\n    switch (cmdidx)\n    {\n\tcase CMD_make:\t    return (char_u *)\"make\";\n\tcase CMD_lmake:\t    return (char_u *)\"lmake\";\n\tcase CMD_grep:\t    return (char_u *)\"grep\";\n\tcase CMD_lgrep:\t    return (char_u *)\"lgrep\";\n\tcase CMD_grepadd:   return (char_u *)\"grepadd\";\n\tcase CMD_lgrepadd:  return (char_u *)\"lgrepadd\";\n\tdefault: return NULL;\n    }\n}\n\n/*\n * Return the name for the errorfile, in allocated memory.\n * Find a new unique name when 'makeef' contains \"##\".\n * Returns NULL for error.\n */\n    static char_u *\nget_mef_name(void)\n{\n    char_u\t*p;\n    char_u\t*name;\n    static int\tstart = -1;\n    static int\toff = 0;\n#ifdef HAVE_LSTAT\n    stat_T\tsb;\n#endif\n\n    if (*p_mef == NUL)\n    {\n\tname = vim_tempname('e', FALSE);\n\tif (name == NULL)\n\t    emsg(_(e_cant_get_temp_file_name));\n\treturn name;\n    }\n\n    for (p = p_mef; *p; ++p)\n\tif (p[0] == '#' && p[1] == '#')\n\t    break;\n\n    if (*p == NUL)\n\treturn vim_strsave(p_mef);\n\n    // Keep trying until the name doesn't exist yet.\n    for (;;)\n    {\n\tif (start == -1)\n\t    start = mch_get_pid();\n\telse\n\t    off += 19;\n\n\tname = alloc_id(STRLEN(p_mef) + 30, aid_qf_mef_name);\n\tif (name == NULL)\n\t    break;\n\tSTRCPY(name, p_mef);\n\tsprintf((char *)name + (p - p_mef), \"%d%d\", start, off);\n\tSTRCAT(name, p + 2);\n\tif (mch_getperm(name) < 0\n#ifdef HAVE_LSTAT\n\t\t    // Don't accept a symbolic link, it's a security risk.\n\t\t    && mch_lstat((char *)name, &sb) < 0\n#endif\n\t\t)\n\t    break;\n\tvim_free(name);\n    }\n    return name;\n}\n\n/*\n * Form the complete command line to invoke 'make'/'grep'. Quote the command\n * using 'shellquote' and append 'shellpipe'. Echo the fully formed command.\n */\n    static char_u *\nmake_get_fullcmd(char_u *makecmd, char_u *fname)\n{\n    char_u\t*cmd;\n    unsigned\tlen;\n\n    len = (unsigned)STRLEN(p_shq) * 2 + (unsigned)STRLEN(makecmd) + 1;\n    if (*p_sp != NUL)\n\tlen += (unsigned)STRLEN(p_sp) + (unsigned)STRLEN(fname) + 3;\n    cmd = alloc_id(len, aid_qf_makecmd);\n    if (cmd == NULL)\n\treturn NULL;\n    sprintf((char *)cmd, \"%s%s%s\", (char *)p_shq, (char *)makecmd,\n\t\t\t\t\t\t\t       (char *)p_shq);\n\n    // If 'shellpipe' empty: don't redirect to 'errorfile'.\n    if (*p_sp != NUL)\n\tappend_redir(cmd, len, p_sp, fname);\n\n    // Display the fully formed command.  Output a newline if there's something\n    // else than the :make command that was typed (in which case the cursor is\n    // in column 0).\n    if (msg_col == 0)\n\tmsg_didout = FALSE;\n    msg_start();\n    msg_puts(\":!\");\n    msg_outtrans(cmd);\t\t// show what we are doing\n\n    return cmd;\n}\n\n/*\n * Used for \":make\", \":lmake\", \":grep\", \":lgrep\", \":grepadd\", and \":lgrepadd\"\n */\n    void\nex_make(exarg_T *eap)\n{\n    char_u\t*fname;\n    char_u\t*cmd;\n    char_u\t*enc = NULL;\n    win_T\t*wp = NULL;\n    qf_info_T\t*qi = &ql_info;\n    int\t\tres;\n    char_u\t*au_name = NULL;\n    int_u\tsave_qfid;\n    char_u\t*errorformat = p_efm;\n    int\t\tnewlist = TRUE;\n\n    // Redirect \":grep\" to \":vimgrep\" if 'grepprg' is \"internal\".\n    if (grep_internal(eap->cmdidx))\n    {\n\tex_vimgrep(eap);\n\treturn;\n    }\n\n    au_name = make_get_auname(eap->cmdidx);\n    if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,\n\t\t\t\t\t       curbuf->b_fname, TRUE, curbuf))\n    {\n#ifdef FEAT_EVAL\n\tif (aborting())\n\t    return;\n#endif\n    }\n    enc = (*curbuf->b_p_menc != NUL) ? curbuf->b_p_menc : p_menc;\n\n    if (is_loclist_cmd(eap->cmdidx))\n\twp = curwin;\n\n    autowrite_all();\n    fname = get_mef_name();\n    if (fname == NULL)\n\treturn;\n    mch_remove(fname);\t    // in case it's not unique\n\n    cmd = make_get_fullcmd(eap->arg, fname);\n    if (cmd == NULL)\n    {\n\tvim_free(fname);\n\treturn;\n    }\n\n    // let the shell know if we are redirecting output or not\n    do_shell(cmd, *p_sp != NUL ? SHELL_DOOUT : 0);\n\n#ifdef AMIGA\n    out_flush();\n\t\t// read window status report and redraw before message\n    (void)char_avail();\n#endif\n\n    incr_quickfix_busy();\n\n    if (eap->cmdidx != CMD_make && eap->cmdidx != CMD_lmake)\n\terrorformat = p_gefm;\n    if (eap->cmdidx == CMD_grepadd || eap->cmdidx == CMD_lgrepadd)\n\tnewlist = FALSE;\n\n    res = qf_init(wp, fname, errorformat, newlist, qf_cmdtitle(*eap->cmdlinep),\n\t\t\t\t\t\t\t\t\tenc);\n    if (wp != NULL)\n    {\n\tqi = GET_LOC_LIST(wp);\n\tif (qi == NULL)\n\t    goto cleanup;\n    }\n    if (res >= 0)\n\tqf_list_changed(qf_get_curlist(qi));\n\n    // Remember the current quickfix list identifier, so that we can\n    // check for autocommands changing the current quickfix list.\n    save_qfid = qf_get_curlist(qi)->qf_id;\n    if (au_name != NULL)\n\tapply_autocmds(EVENT_QUICKFIXCMDPOST, au_name,\n\t\t\t\t\t       curbuf->b_fname, TRUE, curbuf);\n    if (res > 0 && !eap->forceit && qflist_valid(wp, save_qfid))\n\t// display the first error\n\tqf_jump_first(qi, save_qfid, FALSE);\n\ncleanup:\n    decr_quickfix_busy();\n    mch_remove(fname);\n    vim_free(fname);\n    vim_free(cmd);\n}\n\n/*\n * Returns the number of entries in the current quickfix/location list.\n */\n    int\nqf_get_size(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n\n    if ((qi = qf_cmd_get_stack(eap, FALSE)) == NULL)\n\treturn 0;\n    return qf_get_curlist(qi)->qf_count;\n}\n\n/*\n * Returns the number of valid entries in the current quickfix/location list.\n */\n    int\nqf_get_valid_size(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n    qf_list_T\t*qfl;\n    qfline_T\t*qfp;\n    int\t\ti, sz = 0;\n    int\t\tprev_fnum = 0;\n\n    if ((qi = qf_cmd_get_stack(eap, FALSE)) == NULL)\n\treturn 0;\n\n    qfl = qf_get_curlist(qi);\n    FOR_ALL_QFL_ITEMS(qfl, qfp, i)\n    {\n\tif (qfp->qf_valid)\n\t{\n\t    if (eap->cmdidx == CMD_cdo || eap->cmdidx == CMD_ldo)\n\t\tsz++;\t// Count all valid entries\n\t    else if (qfp->qf_fnum > 0 && qfp->qf_fnum != prev_fnum)\n\t    {\n\t\t// Count the number of files\n\t\tsz++;\n\t\tprev_fnum = qfp->qf_fnum;\n\t    }\n\t}\n    }\n\n    return sz;\n}\n\n/*\n * Returns the current index of the quickfix/location list.\n * Returns 0 if there is an error.\n */\n    int\nqf_get_cur_idx(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n\n    if ((qi = qf_cmd_get_stack(eap, FALSE)) == NULL)\n\treturn 0;\n\n    return qf_get_curlist(qi)->qf_index;\n}\n\n/*\n * Returns the current index in the quickfix/location list (counting only valid\n * entries). If no valid entries are in the list, then returns 1.\n */\n    int\nqf_get_cur_valid_idx(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n    qf_list_T\t*qfl;\n    qfline_T\t*qfp;\n    int\t\ti, eidx = 0;\n    int\t\tprev_fnum = 0;\n\n    if ((qi = qf_cmd_get_stack(eap, FALSE)) == NULL)\n\treturn 1;\n\n    qfl = qf_get_curlist(qi);\n    qfp = qfl->qf_start;\n\n    // check if the list has valid errors\n    if (!qf_list_has_valid_entries(qfl))\n\treturn 1;\n\n    for (i = 1; i <= qfl->qf_index && qfp!= NULL; i++, qfp = qfp->qf_next)\n    {\n\tif (qfp->qf_valid)\n\t{\n\t    if (eap->cmdidx == CMD_cfdo || eap->cmdidx == CMD_lfdo)\n\t    {\n\t\tif (qfp->qf_fnum > 0 && qfp->qf_fnum != prev_fnum)\n\t\t{\n\t\t    // Count the number of files\n\t\t    eidx++;\n\t\t    prev_fnum = qfp->qf_fnum;\n\t\t}\n\t    }\n\t    else\n\t\teidx++;\n\t}\n    }\n\n    return eidx ? eidx : 1;\n}\n\n/*\n * Get the 'n'th valid error entry in the quickfix or location list.\n * Used by :cdo, :ldo, :cfdo and :lfdo commands.\n * For :cdo and :ldo returns the 'n'th valid error entry.\n * For :cfdo and :lfdo returns the 'n'th valid file entry.\n */\n    static int\nqf_get_nth_valid_entry(qf_list_T *qfl, int n, int fdo)\n{\n    qfline_T\t*qfp;\n    int\t\ti, eidx;\n    int\t\tprev_fnum = 0;\n\n    // check if the list has valid errors\n    if (!qf_list_has_valid_entries(qfl))\n\treturn 1;\n\n    eidx = 0;\n    FOR_ALL_QFL_ITEMS(qfl, qfp, i)\n    {\n\tif (qfp->qf_valid)\n\t{\n\t    if (fdo)\n\t    {\n\t\tif (qfp->qf_fnum > 0 && qfp->qf_fnum != prev_fnum)\n\t\t{\n\t\t    // Count the number of files\n\t\t    eidx++;\n\t\t    prev_fnum = qfp->qf_fnum;\n\t\t}\n\t    }\n\t    else\n\t\teidx++;\n\t}\n\n\tif (eidx == n)\n\t    break;\n    }\n\n    if (i <= qfl->qf_count)\n\treturn i;\n    else\n\treturn 1;\n}\n\n/*\n * \":cc\", \":crewind\", \":cfirst\" and \":clast\".\n * \":ll\", \":lrewind\", \":lfirst\" and \":llast\".\n * \":cdo\", \":ldo\", \":cfdo\" and \":lfdo\"\n */\n    void\nex_cc(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n    int\t\terrornr;\n\n    if ((qi = qf_cmd_get_stack(eap, TRUE)) == NULL)\n\treturn;\n\n    if (eap->addr_count > 0)\n\terrornr = (int)eap->line2;\n    else\n    {\n\tswitch (eap->cmdidx)\n\t{\n\t    case CMD_cc: case CMD_ll:\n\t\terrornr = 0;\n\t\tbreak;\n\t    case CMD_crewind: case CMD_lrewind: case CMD_cfirst:\n\t    case CMD_lfirst:\n\t\terrornr = 1;\n\t\tbreak;\n\t    default:\n\t\terrornr = 32767;\n\t}\n    }\n\n    // For cdo and ldo commands, jump to the nth valid error.\n    // For cfdo and lfdo commands, jump to the nth valid file entry.\n    if (eap->cmdidx == CMD_cdo || eap->cmdidx == CMD_ldo\n\t    || eap->cmdidx == CMD_cfdo || eap->cmdidx == CMD_lfdo)\n\terrornr = qf_get_nth_valid_entry(qf_get_curlist(qi),\n\t\teap->addr_count > 0 ? (int)eap->line1 : 1,\n\t\teap->cmdidx == CMD_cfdo || eap->cmdidx == CMD_lfdo);\n\n    qf_jump(qi, 0, errornr, eap->forceit);\n}\n\n/*\n * \":cnext\", \":cnfile\", \":cNext\" and \":cprevious\".\n * \":lnext\", \":lNext\", \":lprevious\", \":lnfile\", \":lNfile\" and \":lpfile\".\n * Also, used by \":cdo\", \":ldo\", \":cfdo\" and \":lfdo\" commands.\n */\n    void\nex_cnext(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n    int\t\terrornr;\n    int\t\tdir;\n\n    if ((qi = qf_cmd_get_stack(eap, TRUE)) == NULL)\n\treturn;\n\n    if (eap->addr_count > 0\n\t    && (eap->cmdidx != CMD_cdo && eap->cmdidx != CMD_ldo\n\t\t&& eap->cmdidx != CMD_cfdo && eap->cmdidx != CMD_lfdo))\n\terrornr = (int)eap->line2;\n    else\n\terrornr = 1;\n\n    // Depending on the command jump to either next or previous entry/file.\n    switch (eap->cmdidx)\n    {\n\tcase CMD_cnext: case CMD_lnext: case CMD_cdo: case CMD_ldo:\n\t    dir = FORWARD;\n\t    break;\n\tcase CMD_cprevious: case CMD_lprevious: case CMD_cNext:\n\tcase CMD_lNext:\n\t    dir = BACKWARD;\n\t    break;\n\tcase CMD_cnfile: case CMD_lnfile: case CMD_cfdo: case CMD_lfdo:\n\t    dir = FORWARD_FILE;\n\t    break;\n\tcase CMD_cpfile: case CMD_lpfile: case CMD_cNfile: case CMD_lNfile:\n\t    dir = BACKWARD_FILE;\n\t    break;\n\tdefault:\n\t    dir = FORWARD;\n\t    break;\n    }\n\n    qf_jump(qi, dir, errornr, eap->forceit);\n}\n\n/*\n * Find the first entry in the quickfix list 'qfl' from buffer 'bnr'.\n * The index of the entry is stored in 'errornr'.\n * Returns NULL if an entry is not found.\n */\n    static qfline_T *\nqf_find_first_entry_in_buf(qf_list_T *qfl, int bnr, int *errornr)\n{\n    qfline_T\t*qfp = NULL;\n    int\t\tidx = 0;\n\n    // Find the first entry in this file\n    FOR_ALL_QFL_ITEMS(qfl, qfp, idx)\n\tif (qfp->qf_fnum == bnr)\n\t    break;\n\n    *errornr = idx;\n    return qfp;\n}\n\n/*\n * Find the first quickfix entry on the same line as 'entry'. Updates 'errornr'\n * with the error number for the first entry. Assumes the entries are sorted in\n * the quickfix list by line number.\n */\n    static qfline_T *\nqf_find_first_entry_on_line(qfline_T *entry, int *errornr)\n{\n    while (!got_int\n\t    && entry->qf_prev != NULL\n\t    && entry->qf_fnum == entry->qf_prev->qf_fnum\n\t    && entry->qf_lnum == entry->qf_prev->qf_lnum)\n    {\n\tentry = entry->qf_prev;\n\t--*errornr;\n    }\n\n    return entry;\n}\n\n/*\n * Find the last quickfix entry on the same line as 'entry'. Updates 'errornr'\n * with the error number for the last entry. Assumes the entries are sorted in\n * the quickfix list by line number.\n */\n    static qfline_T *\nqf_find_last_entry_on_line(qfline_T *entry, int *errornr)\n{\n    while (!got_int &&\n\t    entry->qf_next != NULL\n\t    && entry->qf_fnum == entry->qf_next->qf_fnum\n\t    && entry->qf_lnum == entry->qf_next->qf_lnum)\n    {\n\tentry = entry->qf_next;\n\t++*errornr;\n    }\n\n    return entry;\n}\n\n/*\n * Returns TRUE if the specified quickfix entry is\n *   after the given line (linewise is TRUE)\n *   or after the line and column.\n */\n    static int\nqf_entry_after_pos(qfline_T *qfp, pos_T *pos, int linewise)\n{\n    if (linewise)\n\treturn qfp->qf_lnum > pos->lnum;\n    else\n\treturn (qfp->qf_lnum > pos->lnum ||\n\t\t(qfp->qf_lnum == pos->lnum && qfp->qf_col > pos->col));\n}\n\n/*\n * Returns TRUE if the specified quickfix entry is\n *   before the given line (linewise is TRUE)\n *   or before the line and column.\n */\n    static int\nqf_entry_before_pos(qfline_T *qfp, pos_T *pos, int linewise)\n{\n    if (linewise)\n\treturn qfp->qf_lnum < pos->lnum;\n    else\n\treturn (qfp->qf_lnum < pos->lnum ||\n\t\t(qfp->qf_lnum == pos->lnum && qfp->qf_col < pos->col));\n}\n\n/*\n * Returns TRUE if the specified quickfix entry is\n *   on or after the given line (linewise is TRUE)\n *   or on or after the line and column.\n */\n    static int\nqf_entry_on_or_after_pos(qfline_T *qfp, pos_T *pos, int linewise)\n{\n    if (linewise)\n\treturn qfp->qf_lnum >= pos->lnum;\n    else\n\treturn (qfp->qf_lnum > pos->lnum ||\n\t\t(qfp->qf_lnum == pos->lnum && qfp->qf_col >= pos->col));\n}\n\n/*\n * Returns TRUE if the specified quickfix entry is\n *   on or before the given line (linewise is TRUE)\n *   or on or before the line and column.\n */\n    static int\nqf_entry_on_or_before_pos(qfline_T *qfp, pos_T *pos, int linewise)\n{\n    if (linewise)\n\treturn qfp->qf_lnum <= pos->lnum;\n    else\n\treturn (qfp->qf_lnum < pos->lnum ||\n\t\t(qfp->qf_lnum == pos->lnum && qfp->qf_col <= pos->col));\n}\n\n/*\n * Find the first quickfix entry after position 'pos' in buffer 'bnr'.\n * If 'linewise' is TRUE, returns the entry after the specified line and treats\n * multiple entries on a single line as one. Otherwise returns the entry after\n * the specified line and column.\n * 'qfp' points to the very first entry in the buffer and 'errornr' is the\n * index of the very first entry in the quickfix list.\n * Returns NULL if an entry is not found after 'pos'.\n */\n    static qfline_T *\nqf_find_entry_after_pos(\n\tint\t\tbnr,\n\tpos_T\t\t*pos,\n\tint\t\tlinewise,\n\tqfline_T\t*qfp,\n\tint\t\t*errornr)\n{\n    if (qf_entry_after_pos(qfp, pos, linewise))\n\t// First entry is after position 'pos'\n\treturn qfp;\n\n    // Find the entry just before or at the position 'pos'\n    while (qfp->qf_next != NULL\n\t    && qfp->qf_next->qf_fnum == bnr\n\t    && qf_entry_on_or_before_pos(qfp->qf_next, pos, linewise))\n    {\n\tqfp = qfp->qf_next;\n\t++*errornr;\n    }\n\n    if (qfp->qf_next == NULL || qfp->qf_next->qf_fnum != bnr)\n\t// No entries found after position 'pos'\n\treturn NULL;\n\n    // Use the entry just after position 'pos'\n    qfp = qfp->qf_next;\n    ++*errornr;\n\n    return qfp;\n}\n\n/*\n * Find the first quickfix entry before position 'pos' in buffer 'bnr'.\n * If 'linewise' is TRUE, returns the entry before the specified line and\n * treats multiple entries on a single line as one. Otherwise returns the entry\n * before the specified line and column.\n * 'qfp' points to the very first entry in the buffer and 'errornr' is the\n * index of the very first entry in the quickfix list.\n * Returns NULL if an entry is not found before 'pos'.\n */\n    static qfline_T *\nqf_find_entry_before_pos(\n\tint\t\tbnr,\n\tpos_T\t\t*pos,\n\tint\t\tlinewise,\n\tqfline_T\t*qfp,\n\tint\t\t*errornr)\n{\n    // Find the entry just before the position 'pos'\n    while (qfp->qf_next != NULL\n\t    && qfp->qf_next->qf_fnum == bnr\n\t    && qf_entry_before_pos(qfp->qf_next, pos, linewise))\n    {\n\tqfp = qfp->qf_next;\n\t++*errornr;\n    }\n\n    if (qf_entry_on_or_after_pos(qfp, pos, linewise))\n\treturn NULL;\n\n    if (linewise)\n\t// If multiple entries are on the same line, then use the first entry\n\tqfp = qf_find_first_entry_on_line(qfp, errornr);\n\n    return qfp;\n}\n\n/*\n * Find a quickfix entry in 'qfl' closest to position 'pos' in buffer 'bnr' in\n * the direction 'dir'.\n */\n    static qfline_T *\nqf_find_closest_entry(\n\tqf_list_T\t*qfl,\n\tint\t\tbnr,\n\tpos_T\t\t*pos,\n\tint\t\tdir,\n\tint\t\tlinewise,\n\tint\t\t*errornr)\n{\n    qfline_T\t*qfp;\n\n    *errornr = 0;\n\n    // Find the first entry in this file\n    qfp = qf_find_first_entry_in_buf(qfl, bnr, errornr);\n    if (qfp == NULL)\n\treturn NULL;\t\t// no entry in this file\n\n    if (dir == FORWARD)\n\tqfp = qf_find_entry_after_pos(bnr, pos, linewise, qfp, errornr);\n    else\n\tqfp = qf_find_entry_before_pos(bnr, pos, linewise, qfp, errornr);\n\n    return qfp;\n}\n\n/*\n * Get the nth quickfix entry below the specified entry.  Searches forward in\n * the list. If linewise is TRUE, then treat multiple entries on a single line\n * as one.\n */\n    static void\nqf_get_nth_below_entry(qfline_T *entry_arg, int n, int linewise, int *errornr)\n{\n    qfline_T *entry = entry_arg;\n\n    while (n-- > 0 && !got_int)\n    {\n\tint\t\tfirst_errornr = *errornr;\n\n\tif (linewise)\n\t    // Treat all the entries on the same line in this file as one\n\t    entry = qf_find_last_entry_on_line(entry, errornr);\n\n\tif (entry->qf_next == NULL\n\t\t|| entry->qf_next->qf_fnum != entry->qf_fnum)\n\t{\n\t    if (linewise)\n\t\t*errornr = first_errornr;\n\t    break;\n\t}\n\n\tentry = entry->qf_next;\n\t++*errornr;\n    }\n}\n\n/*\n * Get the nth quickfix entry above the specified entry.  Searches backwards in\n * the list. If linewise is TRUE, then treat multiple entries on a single line\n * as one.\n */\n    static void\nqf_get_nth_above_entry(qfline_T *entry, int n, int linewise, int *errornr)\n{\n    while (n-- > 0 && !got_int)\n    {\n\tif (entry->qf_prev == NULL\n\t\t|| entry->qf_prev->qf_fnum != entry->qf_fnum)\n\t    break;\n\n\tentry = entry->qf_prev;\n\t--*errornr;\n\n\t// If multiple entries are on the same line, then use the first entry\n\tif (linewise)\n\t    entry = qf_find_first_entry_on_line(entry, errornr);\n    }\n}\n\n/*\n * Find the n'th quickfix entry adjacent to position 'pos' in buffer 'bnr' in\n * the specified direction.  Returns the error number in the quickfix list or 0\n * if an entry is not found.\n */\n    static int\nqf_find_nth_adj_entry(\n\tqf_list_T\t*qfl,\n\tint\t\tbnr,\n\tpos_T\t\t*pos,\n\tint\t\tn,\n\tint\t\tdir,\n\tint\t\tlinewise)\n{\n    qfline_T\t*adj_entry;\n    int\t\terrornr;\n\n    // Find an entry closest to the specified position\n    adj_entry = qf_find_closest_entry(qfl, bnr, pos, dir, linewise, &errornr);\n    if (adj_entry == NULL)\n\treturn 0;\n\n    if (--n > 0)\n    {\n\t// Go to the n'th entry in the current buffer\n\tif (dir == FORWARD)\n\t    qf_get_nth_below_entry(adj_entry, n, linewise, &errornr);\n\telse\n\t    qf_get_nth_above_entry(adj_entry, n, linewise, &errornr);\n    }\n\n    return errornr;\n}\n\n/*\n * Jump to a quickfix entry in the current file nearest to the current line or\n * current line/col.\n * \":cabove\", \":cbelow\", \":labove\", \":lbelow\", \":cafter\", \":cbefore\",\n * \":lafter\" and \":lbefore\" commands\n */\n    void\nex_cbelow(exarg_T *eap)\n{\n    qf_info_T\t*qi;\n    qf_list_T\t*qfl;\n    int\t\tdir;\n    int\t\tbuf_has_flag;\n    int\t\terrornr = 0;\n    pos_T\tpos;\n\n    if (eap->addr_count > 0 && eap->line2 <= 0)\n    {\n\temsg(_(e_invalid_range));\n\treturn;\n    }\n\n    // Check whether the current buffer has any quickfix entries\n    if (eap->cmdidx == CMD_cabove || eap->cmdidx == CMD_cbelow\n\t    || eap->cmdidx == CMD_cbefore || eap->cmdidx == CMD_cafter)\n\tbuf_has_flag = BUF_HAS_QF_ENTRY;\n    else\n\tbuf_has_flag = BUF_HAS_LL_ENTRY;\n    if (!(curbuf->b_has_qf_entry & buf_has_flag))\n    {\n\temsg(_(e_no_errors));\n\treturn;\n    }\n\n    if ((qi = qf_cmd_get_stack(eap, TRUE)) == NULL)\n\treturn;\n\n    qfl = qf_get_curlist(qi);\n    // check if the list has valid errors\n    if (!qf_list_has_valid_entries(qfl))\n    {\n\temsg(_(e_no_errors));\n\treturn;\n    }\n\n    if (eap->cmdidx == CMD_cbelow\n\t    || eap->cmdidx == CMD_lbelow\n\t    || eap->cmdidx == CMD_cafter\n\t    || eap->cmdidx == CMD_lafter)\n\t// Forward motion commands\n\tdir = FORWARD;\n    else\n\tdir = BACKWARD;\n\n    pos = curwin->w_cursor;\n    // A quickfix entry column number is 1 based whereas cursor column\n    // number is 0 based. Adjust the column number.\n    pos.col++;\n    errornr = qf_find_nth_adj_entry(qfl, curbuf->b_fnum, &pos,\n\t\t\t\teap->addr_count > 0 ? eap->line2 : 0, dir,\n\t\t\t\teap->cmdidx == CMD_cbelow\n\t\t\t\t\t|| eap->cmdidx == CMD_lbelow\n\t\t\t\t\t|| eap->cmdidx == CMD_cabove\n\t\t\t\t\t|| eap->cmdidx == CMD_labove);\n\n    if (errornr > 0)\n\tqf_jump(qi, 0, errornr, FALSE);\n    else\n\temsg(_(e_no_more_items));\n}\n\n/*\n * Return the autocmd name for the :cfile Ex commands\n */\n    static char_u *\ncfile_get_auname(cmdidx_T cmdidx)\n{\n    switch (cmdidx)\n    {\n\tcase CMD_cfile:\t    return (char_u *)\"cfile\";\n\tcase CMD_cgetfile:  return (char_u *)\"cgetfile\";\n\tcase CMD_caddfile:  return (char_u *)\"caddfile\";\n\tcase CMD_lfile:\t    return (char_u *)\"lfile\";\n\tcase CMD_lgetfile:  return (char_u *)\"lgetfile\";\n\tcase CMD_laddfile:  return (char_u *)\"laddfile\";\n\tdefault:\t    return NULL;\n    }\n}\n\n/*\n * \":cfile\"/\":cgetfile\"/\":caddfile\" commands.\n * \":lfile\"/\":lgetfile\"/\":laddfile\" commands.\n */\n    void\nex_cfile(exarg_T *eap)\n{\n    char_u\t*enc = NULL;\n    win_T\t*wp = NULL;\n    qf_info_T\t*qi = &ql_info;\n    char_u\t*au_name = NULL;\n    int_u\tsave_qfid = 0;\t\t// init for gcc\n    int\t\tres;\n\n    au_name = cfile_get_auname(eap->cmdidx);\n    if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,\n\t\t\t\t\t\t\tNULL, FALSE, curbuf))\n    {\n#ifdef FEAT_EVAL\n\tif (aborting())\n\t    return;\n#endif\n    }\n\n    enc = (*curbuf->b_p_menc != NUL) ? curbuf->b_p_menc : p_menc;\n#ifdef FEAT_BROWSE\n    if (cmdmod.cmod_flags & CMOD_BROWSE)\n    {\n\tchar_u *browse_file = do_browse(0, (char_u *)_(\"Error file\"), eap->arg,\n\t\t\t\t   NULL, NULL,\n\t\t\t\t   (char_u *)_(BROWSE_FILTER_ALL_FILES), NULL);\n\tif (browse_file == NULL)\n\t    return;\n\tset_string_option_direct((char_u *)\"ef\", -1, browse_file, OPT_FREE, 0);\n\tvim_free(browse_file);\n    }\n    else\n#endif\n    if (*eap->arg != NUL)\n\tset_string_option_direct((char_u *)\"ef\", -1, eap->arg, OPT_FREE, 0);\n\n    if (is_loclist_cmd(eap->cmdidx))\n\twp = curwin;\n\n    incr_quickfix_busy();\n\n    // This function is used by the :cfile, :cgetfile and :caddfile\n    // commands.\n    // :cfile always creates a new quickfix list and jumps to the\n    // first error.\n    // :cgetfile creates a new quickfix list but doesn't jump to the\n    // first error.\n    // :caddfile adds to an existing quickfix list. If there is no\n    // quickfix list then a new list is created.\n    res = qf_init(wp, p_ef, p_efm, (eap->cmdidx != CMD_caddfile\n\t\t\t&& eap->cmdidx != CMD_laddfile),\n\t\t\tqf_cmdtitle(*eap->cmdlinep), enc);\n    if (wp != NULL)\n    {\n\tqi = GET_LOC_LIST(wp);\n\tif (qi == NULL)\n\t{\n\t    decr_quickfix_busy();\n\t    return;\n\t}\n    }\n    if (res >= 0)\n\tqf_list_changed(qf_get_curlist(qi));\n    save_qfid = qf_get_curlist(qi)->qf_id;\n    if (au_name != NULL)\n\tapply_autocmds(EVENT_QUICKFIXCMDPOST, au_name, NULL, FALSE, curbuf);\n\n    // Jump to the first error for a new list and if autocmds didn't\n    // free the list.\n    if (res > 0 && (eap->cmdidx == CMD_cfile || eap->cmdidx == CMD_lfile)\n\t    && qflist_valid(wp, save_qfid))\n\t// display the first error\n\tqf_jump_first(qi, save_qfid, eap->forceit);\n\n    decr_quickfix_busy();\n}\n\n/*\n * Return the vimgrep autocmd name.\n */\n    static char_u *\nvgr_get_auname(cmdidx_T cmdidx)\n{\n    switch (cmdidx)\n    {\n\tcase CMD_vimgrep:     return (char_u *)\"vimgrep\";\n\tcase CMD_lvimgrep:    return (char_u *)\"lvimgrep\";\n\tcase CMD_vimgrepadd:  return (char_u *)\"vimgrepadd\";\n\tcase CMD_lvimgrepadd: return (char_u *)\"lvimgrepadd\";\n\tcase CMD_grep:\t      return (char_u *)\"grep\";\n\tcase CMD_lgrep:\t      return (char_u *)\"lgrep\";\n\tcase CMD_grepadd:     return (char_u *)\"grepadd\";\n\tcase CMD_lgrepadd:    return (char_u *)\"lgrepadd\";\n\tdefault: return NULL;\n    }\n}\n\n/*\n * Initialize the regmatch used by vimgrep for pattern \"s\".\n */\n    static void\nvgr_init_regmatch(regmmatch_T *regmatch, char_u *s)\n{\n    // Get the search pattern: either white-separated or enclosed in //\n    regmatch->regprog = NULL;\n\n    if (s == NULL || *s == NUL)\n    {\n\t// Pattern is empty, use last search pattern.\n\tif (last_search_pat() == NULL)\n\t{\n\t    emsg(_(e_no_previous_regular_expression));\n\t    return;\n\t}\n\tregmatch->regprog = vim_regcomp(last_search_pat(), RE_MAGIC);\n    }\n    else\n\tregmatch->regprog = vim_regcomp(s, RE_MAGIC);\n\n    regmatch->rmm_ic = p_ic;\n    regmatch->rmm_maxcol = 0;\n}\n\n/*\n * Display a file name when vimgrep is running.\n */\n    static void\nvgr_display_fname(char_u *fname)\n{\n    char_u\t*p;\n\n    msg_start();\n    p = msg_strtrunc(fname, TRUE);\n    if (p == NULL)\n\tmsg_outtrans(fname);\n    else\n    {\n\tmsg_outtrans(p);\n\tvim_free(p);\n    }\n    msg_clr_eos();\n    msg_didout = FALSE;\t    // overwrite this message\n    msg_nowait = TRUE;\t    // don't wait for this message\n    msg_col = 0;\n    out_flush();\n}\n\n/*\n * Load a dummy buffer to search for a pattern using vimgrep.\n */\n    static buf_T *\nvgr_load_dummy_buf(\n\tchar_u *fname,\n\tchar_u *dirname_start,\n\tchar_u *dirname_now)\n{\n    int\t\tsave_mls;\n#if defined(FEAT_SYN_HL)\n    char_u\t*save_ei = NULL;\n#endif\n    buf_T\t*buf;\n\n#if defined(FEAT_SYN_HL)\n    // Don't do Filetype autocommands to avoid loading syntax and\n    // indent scripts, a great speed improvement.\n    save_ei = au_event_disable(\",Filetype\");\n#endif\n    // Don't use modelines here, it's useless.\n    save_mls = p_mls;\n    p_mls = 0;\n\n    // Load file into a buffer, so that 'fileencoding' is detected,\n    // autocommands applied, etc.\n    buf = load_dummy_buffer(fname, dirname_start, dirname_now);\n\n    p_mls = save_mls;\n#if defined(FEAT_SYN_HL)\n    au_event_restore(save_ei);\n#endif\n\n    return buf;\n}\n\n/*\n * Check whether a quickfix/location list is valid. Autocmds may remove or\n * change a quickfix list when vimgrep is running. If the list is not found,\n * create a new list.\n */\n    static int\nvgr_qflist_valid(\n\twin_T\t    *wp,\n\tqf_info_T   *qi,\n\tint_u\t    qfid,\n\tchar_u\t    *title)\n{\n    // Verify that the quickfix/location list was not freed by an autocmd\n    if (!qflist_valid(wp, qfid))\n    {\n\tif (wp != NULL)\n\t{\n\t    // An autocmd has freed the location list.\n\t    emsg(_(e_current_location_list_was_changed));\n\t    return FALSE;\n\t}\n\telse\n\t{\n\t    // Quickfix list is not found, create a new one.\n\t    qf_new_list(qi, title);\n\t    return TRUE;\n\t}\n    }\n\n    if (qf_restore_list(qi, qfid) == FAIL)\n\treturn FALSE;\n\n    return TRUE;\n}\n\n/*\n * Search for a pattern in all the lines in a buffer and add the matching lines\n * to a quickfix list.\n */\n    static int\nvgr_match_buflines(\n\tqf_list_T   *qfl,\n\tchar_u\t    *fname,\n\tbuf_T\t    *buf,\n\tchar_u\t    *spat,\n\tregmmatch_T *regmatch,\n\tlong\t    *tomatch,\n\tint\t    duplicate_name,\n\tint\t    flags)\n{\n    int\t\tfound_match = FALSE;\n    long\tlnum;\n    colnr_T\tcol;\n    int\t\tpat_len = (int)STRLEN(spat);\n    if (pat_len > MAX_FUZZY_MATCHES)\n\tpat_len = MAX_FUZZY_MATCHES;\n\n    for (lnum = 1; lnum <= buf->b_ml.ml_line_count && *tomatch > 0; ++lnum)\n    {\n\tcol = 0;\n\tif (!(flags & VGR_FUZZY))\n\t{\n\t    // Regular expression match\n\t    while (vim_regexec_multi(regmatch, curwin, buf, lnum,\n\t\t\t\t\t\t\t\tcol, NULL) > 0)\n\t    {\n\t\t// Pass the buffer number so that it gets used even for a\n\t\t// dummy buffer, unless duplicate_name is set, then the\n\t\t// buffer will be wiped out below.\n\t\tif (qf_add_entry(qfl,\n\t\t\t    NULL,\t// dir\n\t\t\t    fname,\n\t\t\t    NULL,\n\t\t\t    duplicate_name ? 0 : buf->b_fnum,\n\t\t\t    ml_get_buf(buf,\n\t\t\t\tregmatch->startpos[0].lnum + lnum, FALSE),\n\t\t\t    regmatch->startpos[0].lnum + lnum,\n\t\t\t    regmatch->endpos[0].lnum + lnum,\n\t\t\t    regmatch->startpos[0].col + 1,\n\t\t\t    regmatch->endpos[0].col + 1,\n\t\t\t    FALSE,\t// vis_col\n\t\t\t    NULL,\t// search pattern\n\t\t\t    0,\t\t// nr\n\t\t\t    0,\t\t// type\n\t\t\t    TRUE\t// valid\n\t\t\t    ) == QF_FAIL)\n\t\t{\n\t\t    got_int = TRUE;\n\t\t    break;\n\t\t}\n\t\tfound_match = TRUE;\n\t\tif (--*tomatch == 0)\n\t\t    break;\n\t\tif ((flags & VGR_GLOBAL) == 0\n\t\t\t|| regmatch->endpos[0].lnum > 0)\n\t\t    break;\n\t\tcol = regmatch->endpos[0].col\n\t\t    + (col == regmatch->endpos[0].col);\n\t\tif (col > (colnr_T)STRLEN(ml_get_buf(buf, lnum, FALSE)))\n\t\t    break;\n\t    }\n\t}\n\telse\n\t{\n\t    char_u  *str = ml_get_buf(buf, lnum, FALSE);\n\t    int\t    score;\n\t    int_u   matches[MAX_FUZZY_MATCHES];\n\t    int_u   sz = ARRAY_LENGTH(matches);\n\n\t    // Fuzzy string match\n\t    CLEAR_FIELD(matches);\n\t    while (fuzzy_match(str + col, spat, FALSE, &score, matches, sz) > 0)\n\t    {\n\t\t// Pass the buffer number so that it gets used even for a\n\t\t// dummy buffer, unless duplicate_name is set, then the\n\t\t// buffer will be wiped out below.\n\t\tif (qf_add_entry(qfl,\n\t\t\t    NULL,\t// dir\n\t\t\t    fname,\n\t\t\t    NULL,\n\t\t\t    duplicate_name ? 0 : buf->b_fnum,\n\t\t\t    str,\n\t\t\t    lnum,\n\t\t\t    0,\n\t\t\t    matches[0] + col + 1,\n\t\t\t    0,\n\t\t\t    FALSE,\t// vis_col\n\t\t\t    NULL,\t// search pattern\n\t\t\t    0,\t\t// nr\n\t\t\t    0,\t\t// type\n\t\t\t    TRUE\t// valid\n\t\t\t    ) == QF_FAIL)\n\t\t{\n\t\t    got_int = TRUE;\n\t\t    break;\n\t\t}\n\t\tfound_match = TRUE;\n\t\tif (--*tomatch == 0)\n\t\t    break;\n\t\tif ((flags & VGR_GLOBAL) == 0)\n\t\t    break;\n\t\tcol = matches[pat_len - 1] + col + 1;\n\t\tif (col > (colnr_T)STRLEN(str))\n\t\t    break;\n\t    }\n\t}\n\tline_breakcheck();\n\tif (got_int)\n\t    break;\n    }\n\n    return found_match;\n}\n\n/*\n * Jump to the first match and update the directory.\n */\n    static void\nvgr_jump_to_match(\n\tqf_info_T   *qi,\n\tint\t    forceit,\n\tint\t    *redraw_for_dummy,\n\tbuf_T\t    *first_match_buf,\n\tchar_u\t    *target_dir)\n{\n    buf_T\t*buf;\n\n    buf = curbuf;\n    qf_jump(qi, 0, 0, forceit);\n    if (buf != curbuf)\n\t// If we jumped to another buffer redrawing will already be\n\t// taken care of.\n\t*redraw_for_dummy = FALSE;\n\n    // Jump to the directory used after loading the buffer.\n    if (curbuf == first_match_buf && target_dir != NULL)\n    {\n\texarg_T ea;\n\n\tCLEAR_FIELD(ea);\n\tea.arg = target_dir;\n\tea.cmdidx = CMD_lcd;\n\tex_cd(&ea);\n    }\n}\n\n/*\n * :vimgrep command arguments\n */\ntypedef struct\n{\n    long\ttomatch;\t// maximum number of matches to find\n    char_u\t*spat;\t\t// search pattern\n    int\t\tflags;\t\t// search modifier\n    char_u\t**fnames;\t// list of files to search\n    int\t\tfcount;\t\t// number of files\n    regmmatch_T\tregmatch;\t// compiled search pattern\n    char_u\t*qf_title;\t// quickfix list title\n} vgr_args_T;\n\n/*\n * Process :vimgrep command arguments. The command syntax is:\n *\n *\t:{count}vimgrep /{pattern}/[g][j] {file} ...\n */\n    static int\nvgr_process_args(\n\texarg_T\t\t*eap,\n\tvgr_args_T\t*args)\n{\n    char_u\t*p;\n\n    CLEAR_POINTER(args);\n\n    args->regmatch.regprog = NULL;\n    args->qf_title = vim_strsave(qf_cmdtitle(*eap->cmdlinep));\n\n    if (eap->addr_count > 0)\n\targs->tomatch = eap->line2;\n    else\n\targs->tomatch = MAXLNUM;\n\n    // Get the search pattern: either white-separated or enclosed in //\n    p = skip_vimgrep_pat(eap->arg, &args->spat, &args->flags);\n    if (p == NULL)\n    {\n\temsg(_(e_invalid_search_pattern_or_delimiter));\n\treturn FAIL;\n    }\n\n    vgr_init_regmatch(&args->regmatch, args->spat);\n    if (args->regmatch.regprog == NULL)\n\treturn FAIL;\n\n    p = skipwhite(p);\n    if (*p == NUL)\n    {\n\temsg(_(e_file_name_missing_or_invalid_pattern));\n\treturn FAIL;\n    }\n\n    // Parse the list of arguments, wildcards have already been expanded.\n    if ((get_arglist_exp(p, &args->fcount, &args->fnames, TRUE) == FAIL) ||\n\targs->fcount == 0)\n    {\n\temsg(_(e_no_match));\n\treturn FAIL;\n    }\n\n    return OK;\n}\n\n/*\n * Return TRUE if \"buf\" had an existing swap file, the current swap file does\n * not end in \".swp\".\n */\n    static int\nexisting_swapfile(buf_T *buf)\n{\n    if (buf->b_ml.ml_mfp != NULL && buf->b_ml.ml_mfp->mf_fname != NULL)\n    {\n\tchar_u *fname = buf->b_ml.ml_mfp->mf_fname;\n\tsize_t len = STRLEN(fname);\n\n\treturn fname[len - 1] != 'p' || fname[len - 2] != 'w';\n    }\n    return FALSE;\n}\n\n/*\n * Search for a pattern in a list of files and populate the quickfix list with\n * the matches.\n */\n    static int\nvgr_process_files(\n\twin_T\t\t*wp,\n\tqf_info_T\t*qi,\n\tvgr_args_T\t*cmd_args,\n\tint\t\t*redraw_for_dummy,\n\tbuf_T\t\t**first_match_buf,\n\tchar_u\t\t**target_dir)\n{\n    int\t\tstatus = FAIL;\n    int_u\tsave_qfid = qf_get_curlist(qi)->qf_id;\n    time_t\tseconds = 0;\n    char_u\t*fname;\n    int\t\tfi;\n    buf_T\t*buf;\n    int\t\tduplicate_name = FALSE;\n    int\t\tusing_dummy;\n    char_u\t*dirname_start = NULL;\n    char_u\t*dirname_now = NULL;\n    int\t\tfound_match;\n    aco_save_T\taco;\n\n    dirname_start = alloc_id(MAXPATHL, aid_qf_dirname_start);\n    dirname_now = alloc_id(MAXPATHL, aid_qf_dirname_now);\n    if (dirname_start == NULL || dirname_now == NULL)\n\tgoto theend;\n\n    // Remember the current directory, because a BufRead autocommand that does\n    // \":lcd %:p:h\" changes the meaning of short path names.\n    mch_dirname(dirname_start, MAXPATHL);\n\n    seconds = (time_t)0;\n    for (fi = 0; fi < cmd_args->fcount && !got_int && cmd_args->tomatch > 0;\n\t\t\t\t\t\t\t\t\t++fi)\n    {\n\tfname = shorten_fname1(cmd_args->fnames[fi]);\n\tif (time(NULL) > seconds)\n\t{\n\t    // Display the file name every second or so, show the user we are\n\t    // working on it.\n\t    seconds = time(NULL);\n\t    vgr_display_fname(fname);\n\t}\n\n\tbuf = buflist_findname_exp(cmd_args->fnames[fi]);\n\tif (buf == NULL || buf->b_ml.ml_mfp == NULL)\n\t{\n\t    // Remember that a buffer with this name already exists.\n\t    duplicate_name = (buf != NULL);\n\t    using_dummy = TRUE;\n\t    *redraw_for_dummy = TRUE;\n\n\t    buf = vgr_load_dummy_buf(fname, dirname_start, dirname_now);\n\t}\n\telse\n\t    // Use existing, loaded buffer.\n\t    using_dummy = FALSE;\n\n\t// Check whether the quickfix list is still valid. When loading a\n\t// buffer above, autocommands might have changed the quickfix list.\n\tif (!vgr_qflist_valid(wp, qi, save_qfid, cmd_args->qf_title))\n\t    goto theend;\n\n\tsave_qfid = qf_get_curlist(qi)->qf_id;\n\n\tif (buf == NULL)\n\t{\n\t    if (!got_int)\n\t\tsmsg(_(\"Cannot open file \\\"%s\\\"\"), fname);\n\t}\n\telse\n\t{\n\t    // Try for a match in all lines of the buffer.\n\t    // For \":1vimgrep\" look for first match only.\n\t    found_match = vgr_match_buflines(qf_get_curlist(qi),\n\t\t    fname, buf, cmd_args->spat, &cmd_args->regmatch,\n\t\t    &cmd_args->tomatch, duplicate_name, cmd_args->flags);\n\n\t    if (using_dummy)\n\t    {\n\t\tif (found_match && *first_match_buf == NULL)\n\t\t    *first_match_buf = buf;\n\t\tif (duplicate_name)\n\t\t{\n\t\t    // Never keep a dummy buffer if there is another buffer\n\t\t    // with the same name.\n\t\t    wipe_dummy_buffer(buf, dirname_start);\n\t\t    buf = NULL;\n\t\t}\n\t\telse if ((cmdmod.cmod_flags & CMOD_HIDE) == 0\n\t\t\t    || buf->b_p_bh[0] == 'u'\t// \"unload\"\n\t\t\t    || buf->b_p_bh[0] == 'w'\t// \"wipe\"\n\t\t\t    || buf->b_p_bh[0] == 'd')\t// \"delete\"\n\t\t{\n\t\t    // When no match was found we don't need to remember the\n\t\t    // buffer, wipe it out.  If there was a match and it\n\t\t    // wasn't the first one or we won't jump there: only\n\t\t    // unload the buffer.\n\t\t    // Ignore 'hidden' here, because it may lead to having too\n\t\t    // many swap files.\n\t\t    if (!found_match)\n\t\t    {\n\t\t\twipe_dummy_buffer(buf, dirname_start);\n\t\t\tbuf = NULL;\n\t\t    }\n\t\t    else if (buf != *first_match_buf\n\t\t\t\t\t|| (cmd_args->flags & VGR_NOJUMP)\n\t\t\t\t\t|| existing_swapfile(buf))\n\t\t    {\n\t\t\tunload_dummy_buffer(buf, dirname_start);\n\t\t\t// Keeping the buffer, remove the dummy flag.\n\t\t\tbuf->b_flags &= ~BF_DUMMY;\n\t\t\tbuf = NULL;\n\t\t    }\n\t\t}\n\n\t\tif (buf != NULL)\n\t\t{\n\t\t    // Keeping the buffer, remove the dummy flag.\n\t\t    buf->b_flags &= ~BF_DUMMY;\n\n\t\t    // If the buffer is still loaded we need to use the\n\t\t    // directory we jumped to below.\n\t\t    if (buf == *first_match_buf\n\t\t\t    && *target_dir == NULL\n\t\t\t    && STRCMP(dirname_start, dirname_now) != 0)\n\t\t\t*target_dir = vim_strsave(dirname_now);\n\n\t\t    // The buffer is still loaded, the Filetype autocommands\n\t\t    // need to be done now, in that buffer.  And the modelines\n\t\t    // need to be done (again).  But not the window-local\n\t\t    // options!\n\t\t    aucmd_prepbuf(&aco, buf);\n\t\t    if (curbuf == buf)\n\t\t    {\n#if defined(FEAT_SYN_HL)\n\t\t\tapply_autocmds(EVENT_FILETYPE, buf->b_p_ft,\n\t\t\t\t\t\t     buf->b_fname, TRUE, buf);\n#endif\n\t\t\tdo_modelines(OPT_NOWIN);\n\t\t\taucmd_restbuf(&aco);\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n    status = OK;\n\ntheend:\n    vim_free(dirname_now);\n    vim_free(dirname_start);\n    return status;\n}\n\n/*\n * \":vimgrep {pattern} file(s)\"\n * \":vimgrepadd {pattern} file(s)\"\n * \":lvimgrep {pattern} file(s)\"\n * \":lvimgrepadd {pattern} file(s)\"\n */\n    void\nex_vimgrep(exarg_T *eap)\n{\n    vgr_args_T\targs;\n    qf_info_T\t*qi;\n    qf_list_T\t*qfl;\n    int_u\tsave_qfid;\n    win_T\t*wp = NULL;\n    int\t\tredraw_for_dummy = FALSE;\n    buf_T\t*first_match_buf = NULL;\n    char_u\t*target_dir = NULL;\n    char_u\t*au_name =  NULL;\n    int\t\tstatus;\n\n    au_name = vgr_get_auname(eap->cmdidx);\n    if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,\n\t\t\t\t\t       curbuf->b_fname, TRUE, curbuf))\n    {\n#ifdef FEAT_EVAL\n\tif (aborting())\n\t    return;\n#endif\n    }\n\n    qi = qf_cmd_get_or_alloc_stack(eap, &wp);\n    if (qi == NULL)\n\treturn;\n\n    if (vgr_process_args(eap, &args) == FAIL)\n\tgoto theend;\n\n    if ((eap->cmdidx != CMD_grepadd && eap->cmdidx != CMD_lgrepadd\n\t\t&& eap->cmdidx != CMD_vimgrepadd\n\t\t&& eap->cmdidx != CMD_lvimgrepadd)\n\t\t\t\t\t|| qf_stack_empty(qi))\n\t// make place for a new list\n\tqf_new_list(qi, args.qf_title);\n\n    incr_quickfix_busy();\n\n    status = vgr_process_files(wp, qi, &args, &redraw_for_dummy,\n\t\t\t\t\t\t&first_match_buf, &target_dir);\n    if (status != OK)\n    {\n\tFreeWild(args.fcount, args.fnames);\n\tdecr_quickfix_busy();\n\tgoto theend;\n    }\n\n    FreeWild(args.fcount, args.fnames);\n\n    qfl = qf_get_curlist(qi);\n    qfl->qf_nonevalid = FALSE;\n    qfl->qf_ptr = qfl->qf_start;\n    qfl->qf_index = 1;\n    qf_list_changed(qfl);\n\n    qf_update_buffer(qi, NULL);\n\n    // Remember the current quickfix list identifier, so that we can check for\n    // autocommands changing the current quickfix list.\n    save_qfid = qf_get_curlist(qi)->qf_id;\n\n    if (au_name != NULL)\n\tapply_autocmds(EVENT_QUICKFIXCMDPOST, au_name,\n\t\t\t\t\t       curbuf->b_fname, TRUE, curbuf);\n    // The QuickFixCmdPost autocmd may free the quickfix list. Check the list\n    // is still valid.\n    if (!qflist_valid(wp, save_qfid)\n\t    || qf_restore_list(qi, save_qfid) == FAIL)\n    {\n\tdecr_quickfix_busy();\n\tgoto theend;\n    }\n\n    // Jump to first match.\n    if (!qf_list_empty(qf_get_curlist(qi)))\n    {\n\tif ((args.flags & VGR_NOJUMP) == 0)\n\t    vgr_jump_to_match(qi, eap->forceit, &redraw_for_dummy,\n\t\t    first_match_buf, target_dir);\n    }\n    else\n\tsemsg(_(e_no_match_str_2), args.spat);\n\n    decr_quickfix_busy();\n\n    // If we loaded a dummy buffer into the current window, the autocommands\n    // may have messed up things, need to redraw and recompute folds.\n    if (redraw_for_dummy)\n    {\n#ifdef FEAT_FOLDING\n\tfoldUpdateAll(curwin);\n#else\n\tredraw_later(UPD_NOT_VALID);\n#endif\n    }\n\ntheend:\n    vim_free(args.qf_title);\n    vim_free(target_dir);\n    vim_regfree(args.regmatch.regprog);\n}\n\n/*\n * Restore current working directory to \"dirname_start\" if they differ, taking\n * into account whether it is set locally or globally.\n */\n    static void\nrestore_start_dir(char_u *dirname_start)\n{\n    char_u *dirname_now = alloc(MAXPATHL);\n\n    if (dirname_now == NULL)\n\treturn;\n\n    mch_dirname(dirname_now, MAXPATHL);\n    if (STRCMP(dirname_start, dirname_now) != 0)\n    {\n\t// If the directory has changed, change it back by building up an\n\t// appropriate ex command and executing it.\n\texarg_T ea;\n\n\tCLEAR_FIELD(ea);\n\tea.arg = dirname_start;\n\tea.cmdidx = (curwin->w_localdir == NULL) ? CMD_cd : CMD_lcd;\n\tex_cd(&ea);\n    }\n    vim_free(dirname_now);\n}\n\n/*\n * Load file \"fname\" into a dummy buffer and return the buffer pointer,\n * placing the directory resulting from the buffer load into the\n * \"resulting_dir\" pointer. \"resulting_dir\" must be allocated by the caller\n * prior to calling this function. Restores directory to \"dirname_start\" prior\n * to returning, if autocmds or the 'autochdir' option have changed it.\n *\n * If creating the dummy buffer does not fail, must call unload_dummy_buffer()\n * or wipe_dummy_buffer() later!\n *\n * Returns NULL if it fails.\n */\n    static buf_T *\nload_dummy_buffer(\n    char_u\t*fname,\n    char_u\t*dirname_start,  // in: old directory\n    char_u\t*resulting_dir)  // out: new directory\n{\n    buf_T\t*newbuf;\n    bufref_T\tnewbufref;\n    bufref_T\tnewbuf_to_wipe;\n    int\t\tfailed = TRUE;\n    aco_save_T\taco;\n    int\t\treadfile_result;\n\n    // Allocate a buffer without putting it in the buffer list.\n    newbuf = buflist_new(NULL, NULL, (linenr_T)1, BLN_DUMMY);\n    if (newbuf == NULL)\n\treturn NULL;\n    set_bufref(&newbufref, newbuf);\n\n    // Init the options.\n    buf_copy_options(newbuf, BCO_ENTER | BCO_NOHELP);\n\n    // need to open the memfile before putting the buffer in a window\n    if (ml_open(newbuf) == OK)\n    {\n\t// Make sure this buffer isn't wiped out by autocommands.\n\t++newbuf->b_locked;\n\n\t// set curwin/curbuf to buf and save a few things\n\taucmd_prepbuf(&aco, newbuf);\n\tif (curbuf == newbuf)\n\t{\n\t    // Need to set the filename for autocommands.\n\t    (void)setfname(curbuf, fname, NULL, FALSE);\n\n\t    // Create swap file now to avoid the ATTENTION message.\n\t    check_need_swap(TRUE);\n\n\t    // Remove the \"dummy\" flag, otherwise autocommands may not\n\t    // work.\n\t    curbuf->b_flags &= ~BF_DUMMY;\n\n\t    newbuf_to_wipe.br_buf = NULL;\n\t    readfile_result = readfile(fname, NULL,\n\t\t\t(linenr_T)0, (linenr_T)0, (linenr_T)MAXLNUM,\n\t\t\tNULL, READ_NEW | READ_DUMMY);\n\t    --newbuf->b_locked;\n\t    if (readfile_result == OK\n\t\t    && !got_int\n\t\t    && !(curbuf->b_flags & BF_NEW))\n\t    {\n\t\tfailed = FALSE;\n\t\tif (curbuf != newbuf)\n\t\t{\n\t\t    // Bloody autocommands changed the buffer!  Can happen when\n\t\t    // using netrw and editing a remote file.  Use the current\n\t\t    // buffer instead, delete the dummy one after restoring the\n\t\t    // window stuff.\n\t\t    set_bufref(&newbuf_to_wipe, newbuf);\n\t\t    newbuf = curbuf;\n\t\t}\n\t    }\n\n\t    // restore curwin/curbuf and a few other things\n\t    aucmd_restbuf(&aco);\n\n\t    if (newbuf_to_wipe.br_buf != NULL && bufref_valid(&newbuf_to_wipe))\n\t\twipe_buffer(newbuf_to_wipe.br_buf, FALSE);\n\t}\n\n\t// Add back the \"dummy\" flag, otherwise buflist_findname_stat() won't\n\t// skip it.\n\tnewbuf->b_flags |= BF_DUMMY;\n    }\n\n    // When autocommands/'autochdir' option changed directory: go back.\n    // Let the caller know what the resulting dir was first, in case it is\n    // important.\n    mch_dirname(resulting_dir, MAXPATHL);\n    restore_start_dir(dirname_start);\n\n    if (!bufref_valid(&newbufref))\n\treturn NULL;\n    if (failed)\n    {\n\twipe_dummy_buffer(newbuf, dirname_start);\n\treturn NULL;\n    }\n    return newbuf;\n}\n\n/*\n * Wipe out the dummy buffer that load_dummy_buffer() created. Restores\n * directory to \"dirname_start\" prior to returning, if autocmds or the\n * 'autochdir' option have changed it.\n */\n    static void\nwipe_dummy_buffer(buf_T *buf, char_u *dirname_start)\n{\n    // If any autocommand opened a window on the dummy buffer, close that\n    // window.  If we can't close them all then give up.\n    while (buf->b_nwindows > 0)\n    {\n\tint\t    did_one = FALSE;\n\twin_T\t    *wp;\n\n\tif (firstwin->w_next != NULL)\n\t    FOR_ALL_WINDOWS(wp)\n\t\tif (wp->w_buffer == buf)\n\t\t{\n\t\t    if (win_close(wp, FALSE) == OK)\n\t\t\tdid_one = TRUE;\n\t\t    break;\n\t\t}\n\tif (!did_one)\n\t    return;\n    }\n\n    if (curbuf != buf && buf->b_nwindows == 0)\t// safety check\n    {\n#if defined(FEAT_EVAL)\n\tcleanup_T   cs;\n\n\t// Reset the error/interrupt/exception state here so that aborting()\n\t// returns FALSE when wiping out the buffer.  Otherwise it doesn't\n\t// work when got_int is set.\n\tenter_cleanup(&cs);\n#endif\n\n\twipe_buffer(buf, TRUE);\n\n#if defined(FEAT_EVAL)\n\t// Restore the error/interrupt/exception state if not discarded by a\n\t// new aborting error, interrupt, or uncaught exception.\n\tleave_cleanup(&cs);\n#endif\n\t// When autocommands/'autochdir' option changed directory: go back.\n\trestore_start_dir(dirname_start);\n    }\n}\n\n/*\n * Unload the dummy buffer that load_dummy_buffer() created. Restores\n * directory to \"dirname_start\" prior to returning, if autocmds or the\n * 'autochdir' option have changed it.\n */\n    static void\nunload_dummy_buffer(buf_T *buf, char_u *dirname_start)\n{\n    if (curbuf == buf)\t\t// safety check\n\treturn;\n\n    close_buffer(NULL, buf, DOBUF_UNLOAD, FALSE, TRUE);\n\n    // When autocommands/'autochdir' option changed directory: go back.\n    restore_start_dir(dirname_start);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Copy the specified quickfix entry items into a new dict and append the dict\n * to 'list'.  Returns OK on success.\n */\n    static int\nget_qfline_items(qfline_T *qfp, list_T *list)\n{\n    int\t\tbufnum;\n    dict_T\t*dict;\n    char_u\tbuf[2];\n\n    // Handle entries with a non-existing buffer number.\n    bufnum = qfp->qf_fnum;\n    if (bufnum != 0 && (buflist_findnr(bufnum) == NULL))\n\tbufnum = 0;\n\n    if ((dict = dict_alloc()) == NULL)\n\treturn FAIL;\n    if (list_append_dict(list, dict) == FAIL)\n\treturn FAIL;\n\n    buf[0] = qfp->qf_type;\n    buf[1] = NUL;\n    if (dict_add_number(dict, \"bufnr\", (long)bufnum) == FAIL\n\t    || dict_add_number(dict, \"lnum\",     (long)qfp->qf_lnum) == FAIL\n\t    || dict_add_number(dict, \"end_lnum\", (long)qfp->qf_end_lnum) == FAIL\n\t    || dict_add_number(dict, \"col\",      (long)qfp->qf_col) == FAIL\n\t    || dict_add_number(dict, \"end_col\",  (long)qfp->qf_end_col) == FAIL\n\t    || dict_add_number(dict, \"vcol\",     (long)qfp->qf_viscol) == FAIL\n\t    || dict_add_number(dict, \"nr\",       (long)qfp->qf_nr) == FAIL\n\t    || dict_add_string(dict, \"module\", qfp->qf_module) == FAIL\n\t    || dict_add_string(dict, \"pattern\", qfp->qf_pattern) == FAIL\n\t    || dict_add_string(dict, \"text\", qfp->qf_text) == FAIL\n\t    || dict_add_string(dict, \"type\", buf) == FAIL\n\t    || dict_add_number(dict, \"valid\", (long)qfp->qf_valid) == FAIL)\n\treturn FAIL;\n\n    return OK;\n}\n\n/*\n * Add each quickfix error to list \"list\" as a dictionary.\n * If qf_idx is -1, use the current list. Otherwise, use the specified list.\n * If eidx is not 0, then return only the specified entry. Otherwise return\n * all the entries.\n */\n    static int\nget_errorlist(\n\tqf_info_T\t*qi_arg,\n\twin_T\t\t*wp,\n\tint\t\tqf_idx,\n\tint\t\teidx,\n\tlist_T\t\t*list)\n{\n    qf_info_T\t*qi = qi_arg;\n    qf_list_T\t*qfl;\n    qfline_T\t*qfp;\n    int\t\ti;\n\n    if (qi == NULL)\n    {\n\tqi = &ql_info;\n\tif (wp != NULL)\n\t{\n\t    qi = GET_LOC_LIST(wp);\n\t    if (qi == NULL)\n\t\treturn FAIL;\n\t}\n    }\n\n    if (eidx < 0)\n\treturn OK;\n\n    if (qf_idx == INVALID_QFIDX)\n\tqf_idx = qi->qf_curlist;\n\n    if (qf_idx >= qi->qf_listcount)\n\treturn FAIL;\n\n    qfl = qf_get_list(qi, qf_idx);\n    if (qf_list_empty(qfl))\n\treturn FAIL;\n\n    FOR_ALL_QFL_ITEMS(qfl, qfp, i)\n    {\n\tif (eidx > 0)\n\t{\n\t    if (eidx == i)\n\t\treturn get_qfline_items(qfp, list);\n\t}\n\telse if (get_qfline_items(qfp, list) == FAIL)\n\t    return FAIL;\n    }\n\n    return OK;\n}\n\n// Flags used by getqflist()/getloclist() to determine which fields to return.\nenum {\n    QF_GETLIST_NONE\t= 0x0,\n    QF_GETLIST_TITLE\t= 0x1,\n    QF_GETLIST_ITEMS\t= 0x2,\n    QF_GETLIST_NR\t= 0x4,\n    QF_GETLIST_WINID\t= 0x8,\n    QF_GETLIST_CONTEXT\t= 0x10,\n    QF_GETLIST_ID\t= 0x20,\n    QF_GETLIST_IDX\t= 0x40,\n    QF_GETLIST_SIZE\t= 0x80,\n    QF_GETLIST_TICK\t= 0x100,\n    QF_GETLIST_FILEWINID\t= 0x200,\n    QF_GETLIST_QFBUFNR\t= 0x400,\n    QF_GETLIST_QFTF\t= 0x800,\n    QF_GETLIST_ALL\t= 0xFFF,\n};\n\n/*\n * Parse text from 'di' and return the quickfix list items.\n * Existing quickfix lists are not modified.\n */\n    static int\nqf_get_list_from_lines(dict_T *what, dictitem_T *di, dict_T *retdict)\n{\n    int\t\tstatus = FAIL;\n    qf_info_T\t*qi;\n    char_u\t*errorformat = p_efm;\n    dictitem_T\t*efm_di;\n    list_T\t*l;\n\n    // Only a List value is supported\n    if (di->di_tv.v_type != VAR_LIST || di->di_tv.vval.v_list == NULL)\n\treturn FAIL;\n\n    // If errorformat is supplied then use it, otherwise use the 'efm'\n    // option setting\n    if ((efm_di = dict_find(what, (char_u *)\"efm\", -1)) != NULL)\n    {\n\tif (efm_di->di_tv.v_type != VAR_STRING ||\n\t\tefm_di->di_tv.vval.v_string == NULL)\n\t    return FAIL;\n\terrorformat = efm_di->di_tv.vval.v_string;\n    }\n\n    l = list_alloc();\n    if (l == NULL)\n\treturn FAIL;\n\n    qi = qf_alloc_stack(QFLT_INTERNAL);\n    if (qi != NULL)\n    {\n\tif (qf_init_ext(qi, 0, NULL, NULL, &di->di_tv, errorformat,\n\t\t    TRUE, (linenr_T)0, (linenr_T)0, NULL, NULL) > 0)\n\t{\n\t    (void)get_errorlist(qi, NULL, 0, 0, l);\n\t    qf_free(&qi->qf_lists[0]);\n\t}\n\tfree(qi);\n    }\n    dict_add_list(retdict, \"items\", l);\n    status = OK;\n\n    return status;\n}\n\n/*\n * Return the quickfix/location list window identifier in the current tabpage.\n */\n    static int\nqf_winid(qf_info_T *qi)\n{\n    win_T\t*win;\n\n    // The quickfix window can be opened even if the quickfix list is not set\n    // using \":copen\". This is not true for location lists.\n    if (qi == NULL)\n\treturn 0;\n    win = qf_find_win(qi);\n    if (win != NULL)\n\treturn win->w_id;\n    return 0;\n}\n\n/*\n * Returns the number of the buffer displayed in the quickfix/location list\n * window. If there is no buffer associated with the list or the buffer is\n * wiped out, then returns 0.\n */\n    static int\nqf_getprop_qfbufnr(qf_info_T *qi, dict_T *retdict)\n{\n    int\tbufnum = 0;\n\n    if (qi != NULL && buflist_findnr(qi->qf_bufnr) != NULL)\n\tbufnum = qi->qf_bufnr;\n\n    return dict_add_number(retdict, \"qfbufnr\", bufnum);\n}\n\n/*\n * Convert the keys in 'what' to quickfix list property flags.\n */\n    static int\nqf_getprop_keys2flags(dict_T *what, int loclist)\n{\n    int\t\tflags = QF_GETLIST_NONE;\n\n    if (dict_has_key(what, \"all\"))\n    {\n\tflags |= QF_GETLIST_ALL;\n\tif (!loclist)\n\t    // File window ID is applicable only to location list windows\n\t    flags &= ~ QF_GETLIST_FILEWINID;\n    }\n\n    if (dict_has_key(what, \"title\"))\n\tflags |= QF_GETLIST_TITLE;\n\n    if (dict_has_key(what, \"nr\"))\n\tflags |= QF_GETLIST_NR;\n\n    if (dict_has_key(what, \"winid\"))\n\tflags |= QF_GETLIST_WINID;\n\n    if (dict_has_key(what, \"context\"))\n\tflags |= QF_GETLIST_CONTEXT;\n\n    if (dict_has_key(what, \"id\"))\n\tflags |= QF_GETLIST_ID;\n\n    if (dict_has_key(what, \"items\"))\n\tflags |= QF_GETLIST_ITEMS;\n\n    if (dict_has_key(what, \"idx\"))\n\tflags |= QF_GETLIST_IDX;\n\n    if (dict_has_key(what, \"size\"))\n\tflags |= QF_GETLIST_SIZE;\n\n    if (dict_has_key(what, \"changedtick\"))\n\tflags |= QF_GETLIST_TICK;\n\n    if (loclist && dict_has_key(what, \"filewinid\"))\n\tflags |= QF_GETLIST_FILEWINID;\n\n    if (dict_has_key(what, \"qfbufnr\"))\n\tflags |= QF_GETLIST_QFBUFNR;\n\n    if (dict_has_key(what, \"quickfixtextfunc\"))\n\tflags |= QF_GETLIST_QFTF;\n\n    return flags;\n}\n\n/*\n * Return the quickfix list index based on 'nr' or 'id' in 'what'.\n * If 'nr' and 'id' are not present in 'what' then return the current\n * quickfix list index.\n * If 'nr' is zero then return the current quickfix list index.\n * If 'nr' is '$' then return the last quickfix list index.\n * If 'id' is present then return the index of the quickfix list with that id.\n * If 'id' is zero then return the quickfix list index specified by 'nr'.\n * Return -1, if quickfix list is not present or if the stack is empty.\n */\n    static int\nqf_getprop_qfidx(qf_info_T *qi, dict_T *what)\n{\n    int\t\tqf_idx;\n    dictitem_T\t*di;\n\n    qf_idx = qi->qf_curlist;\t// default is the current list\n    if ((di = dict_find(what, (char_u *)\"nr\", -1)) != NULL)\n    {\n\t// Use the specified quickfix/location list\n\tif (di->di_tv.v_type == VAR_NUMBER)\n\t{\n\t    // for zero use the current list\n\t    if (di->di_tv.vval.v_number != 0)\n\t    {\n\t\tqf_idx = di->di_tv.vval.v_number - 1;\n\t\tif (qf_idx < 0 || qf_idx >= qi->qf_listcount)\n\t\t    qf_idx = INVALID_QFIDX;\n\t    }\n\t}\n\telse if (di->di_tv.v_type == VAR_STRING\n\t\t&& di->di_tv.vval.v_string != NULL\n\t\t&& STRCMP(di->di_tv.vval.v_string, \"$\") == 0)\n\t    // Get the last quickfix list number\n\t    qf_idx = qi->qf_listcount - 1;\n\telse\n\t    qf_idx = INVALID_QFIDX;\n    }\n\n    if ((di = dict_find(what, (char_u *)\"id\", -1)) != NULL)\n    {\n\t// Look for a list with the specified id\n\tif (di->di_tv.v_type == VAR_NUMBER)\n\t{\n\t    // For zero, use the current list or the list specified by 'nr'\n\t    if (di->di_tv.vval.v_number != 0)\n\t\tqf_idx = qf_id2nr(qi, di->di_tv.vval.v_number);\n\t}\n\telse\n\t    qf_idx = INVALID_QFIDX;\n    }\n\n    return qf_idx;\n}\n\n/*\n * Return default values for quickfix list properties in retdict.\n */\n    static int\nqf_getprop_defaults(qf_info_T *qi, int flags, int locstack, dict_T *retdict)\n{\n    int\t\tstatus = OK;\n\n    if (flags & QF_GETLIST_TITLE)\n\tstatus = dict_add_string(retdict, \"title\", (char_u *)\"\");\n    if ((status == OK) && (flags & QF_GETLIST_ITEMS))\n    {\n\tlist_T\t*l = list_alloc();\n\tif (l != NULL)\n\t    status = dict_add_list(retdict, \"items\", l);\n\telse\n\t    status = FAIL;\n    }\n    if ((status == OK) && (flags & QF_GETLIST_NR))\n\tstatus = dict_add_number(retdict, \"nr\", 0);\n    if ((status == OK) && (flags & QF_GETLIST_WINID))\n\tstatus = dict_add_number(retdict, \"winid\", qf_winid(qi));\n    if ((status == OK) && (flags & QF_GETLIST_CONTEXT))\n\tstatus = dict_add_string(retdict, \"context\", (char_u *)\"\");\n    if ((status == OK) && (flags & QF_GETLIST_ID))\n\tstatus = dict_add_number(retdict, \"id\", 0);\n    if ((status == OK) && (flags & QF_GETLIST_IDX))\n\tstatus = dict_add_number(retdict, \"idx\", 0);\n    if ((status == OK) && (flags & QF_GETLIST_SIZE))\n\tstatus = dict_add_number(retdict, \"size\", 0);\n    if ((status == OK) && (flags & QF_GETLIST_TICK))\n\tstatus = dict_add_number(retdict, \"changedtick\", 0);\n    if ((status == OK) && locstack && (flags & QF_GETLIST_FILEWINID))\n\tstatus = dict_add_number(retdict, \"filewinid\", 0);\n    if ((status == OK) && (flags & QF_GETLIST_QFBUFNR))\n\tstatus = qf_getprop_qfbufnr(qi, retdict);\n    if ((status == OK) && (flags & QF_GETLIST_QFTF))\n\tstatus = dict_add_string(retdict, \"quickfixtextfunc\", (char_u *)\"\");\n\n    return status;\n}\n\n/*\n * Return the quickfix list title as 'title' in retdict\n */\n    static int\nqf_getprop_title(qf_list_T *qfl, dict_T *retdict)\n{\n    return dict_add_string(retdict, \"title\", qfl->qf_title);\n}\n\n/*\n * Returns the identifier of the window used to display files from a location\n * list.  If there is no associated window, then returns 0. Useful only when\n * called from a location list window.\n */\n    static int\nqf_getprop_filewinid(win_T *wp, qf_info_T *qi, dict_T *retdict)\n{\n    int winid = 0;\n\n    if (wp != NULL && IS_LL_WINDOW(wp))\n    {\n\twin_T\t*ll_wp = qf_find_win_with_loclist(qi);\n\tif (ll_wp != NULL)\n\t    winid = ll_wp->w_id;\n    }\n\n    return dict_add_number(retdict, \"filewinid\", winid);\n}\n\n/*\n * Return the quickfix list items/entries as 'items' in retdict.\n * If eidx is not 0, then return the item at the specified index.\n */\n    static int\nqf_getprop_items(qf_info_T *qi, int qf_idx, int eidx, dict_T *retdict)\n{\n    int\t\tstatus = OK;\n    list_T\t*l = list_alloc();\n    if (l != NULL)\n    {\n\t(void)get_errorlist(qi, NULL, qf_idx, eidx, l);\n\tdict_add_list(retdict, \"items\", l);\n    }\n    else\n\tstatus = FAIL;\n\n    return status;\n}\n\n/*\n * Return the quickfix list context (if any) as 'context' in retdict.\n */\n    static int\nqf_getprop_ctx(qf_list_T *qfl, dict_T *retdict)\n{\n    int\t\tstatus;\n    dictitem_T\t*di;\n\n    if (qfl->qf_ctx != NULL)\n    {\n\tdi = dictitem_alloc((char_u *)\"context\");\n\tif (di != NULL)\n\t{\n\t    copy_tv(qfl->qf_ctx, &di->di_tv);\n\t    status = dict_add(retdict, di);\n\t    if (status == FAIL)\n\t\tdictitem_free(di);\n\t}\n\telse\n\t    status = FAIL;\n    }\n    else\n\tstatus = dict_add_string(retdict, \"context\", (char_u *)\"\");\n\n    return status;\n}\n\n/*\n * Return the current quickfix list index as 'idx' in retdict.\n * If a specific entry index (eidx) is supplied, then use that.\n */\n    static int\nqf_getprop_idx(qf_list_T *qfl, int eidx, dict_T *retdict)\n{\n    if (eidx == 0)\n    {\n\teidx = qfl->qf_index;\n\tif (qf_list_empty(qfl))\n\t    // For empty lists, current index is set to 0\n\t    eidx = 0;\n    }\n    return dict_add_number(retdict, \"idx\", eidx);\n}\n\n/*\n * Return the 'quickfixtextfunc' function of a quickfix/location list\n */\n    static int\nqf_getprop_qftf(qf_list_T *qfl, dict_T *retdict)\n{\n    int\t\tstatus;\n\n    if (qfl->qf_qftf_cb.cb_name != NULL)\n    {\n\ttypval_T\ttv;\n\n\tput_callback(&qfl->qf_qftf_cb, &tv);\n\tstatus = dict_add_tv(retdict, \"quickfixtextfunc\", &tv);\n\tclear_tv(&tv);\n    }\n    else\n\tstatus = dict_add_string(retdict, \"quickfixtextfunc\", (char_u *)\"\");\n\n    return status;\n}\n\n/*\n * Return quickfix/location list details (title) as a\n * dictionary. 'what' contains the details to return. If 'list_idx' is -1,\n * then current list is used. Otherwise the specified list is used.\n */\n    static int\nqf_get_properties(win_T *wp, dict_T *what, dict_T *retdict)\n{\n    qf_info_T\t*qi = &ql_info;\n    qf_list_T\t*qfl;\n    int\t\tstatus = OK;\n    int\t\tqf_idx = INVALID_QFIDX;\n    int\t\teidx = 0;\n    dictitem_T\t*di;\n    int\t\tflags = QF_GETLIST_NONE;\n\n    if ((di = dict_find(what, (char_u *)\"lines\", -1)) != NULL)\n\treturn qf_get_list_from_lines(what, di, retdict);\n\n    if (wp != NULL)\n\tqi = GET_LOC_LIST(wp);\n\n    flags = qf_getprop_keys2flags(what, (wp != NULL));\n\n    if (!qf_stack_empty(qi))\n\tqf_idx = qf_getprop_qfidx(qi, what);\n\n    // List is not present or is empty\n    if (qf_stack_empty(qi) || qf_idx == INVALID_QFIDX)\n\treturn qf_getprop_defaults(qi, flags, wp != NULL, retdict);\n\n    qfl = qf_get_list(qi, qf_idx);\n\n    // If an entry index is specified, use that\n    if ((di = dict_find(what, (char_u *)\"idx\", -1)) != NULL)\n    {\n\tif (di->di_tv.v_type != VAR_NUMBER)\n\t    return FAIL;\n\teidx = di->di_tv.vval.v_number;\n    }\n\n    if (flags & QF_GETLIST_TITLE)\n\tstatus = qf_getprop_title(qfl, retdict);\n    if ((status == OK) && (flags & QF_GETLIST_NR))\n\tstatus = dict_add_number(retdict, \"nr\", qf_idx + 1);\n    if ((status == OK) && (flags & QF_GETLIST_WINID))\n\tstatus = dict_add_number(retdict, \"winid\", qf_winid(qi));\n    if ((status == OK) && (flags & QF_GETLIST_ITEMS))\n\tstatus = qf_getprop_items(qi, qf_idx, eidx, retdict);\n    if ((status == OK) && (flags & QF_GETLIST_CONTEXT))\n\tstatus = qf_getprop_ctx(qfl, retdict);\n    if ((status == OK) && (flags & QF_GETLIST_ID))\n\tstatus = dict_add_number(retdict, \"id\", qfl->qf_id);\n    if ((status == OK) && (flags & QF_GETLIST_IDX))\n\tstatus = qf_getprop_idx(qfl, eidx, retdict);\n    if ((status == OK) && (flags & QF_GETLIST_SIZE))\n\tstatus = dict_add_number(retdict, \"size\", qfl->qf_count);\n    if ((status == OK) && (flags & QF_GETLIST_TICK))\n\tstatus = dict_add_number(retdict, \"changedtick\", qfl->qf_changedtick);\n    if ((status == OK) && (wp != NULL) && (flags & QF_GETLIST_FILEWINID))\n\tstatus = qf_getprop_filewinid(wp, qi, retdict);\n    if ((status == OK) && (flags & QF_GETLIST_QFBUFNR))\n\tstatus = qf_getprop_qfbufnr(qi, retdict);\n    if ((status == OK) && (flags & QF_GETLIST_QFTF))\n\tstatus = qf_getprop_qftf(qfl, retdict);\n\n    return status;\n}\n\n/*\n * Add a new quickfix entry to list at 'qf_idx' in the stack 'qi' from the\n * items in the dict 'd'. If it is a valid error entry, then set 'valid_entry'\n * to TRUE.\n */\n    static int\nqf_add_entry_from_dict(\n\tqf_list_T\t*qfl,\n\tdict_T\t\t*d,\n\tint\t\tfirst_entry,\n\tint\t\t*valid_entry)\n{\n    static int\tdid_bufnr_emsg;\n    char_u\t*filename, *module, *pattern, *text, *type;\n    int\t\tbufnum, valid, status, col, end_col, vcol, nr;\n    long\tlnum, end_lnum;\n\n    if (first_entry)\n\tdid_bufnr_emsg = FALSE;\n\n    filename = dict_get_string(d, \"filename\", TRUE);\n    module = dict_get_string(d, \"module\", TRUE);\n    bufnum = (int)dict_get_number(d, \"bufnr\");\n    lnum = (int)dict_get_number(d, \"lnum\");\n    end_lnum = (int)dict_get_number(d, \"end_lnum\");\n    col = (int)dict_get_number(d, \"col\");\n    end_col = (int)dict_get_number(d, \"end_col\");\n    vcol = (int)dict_get_number(d, \"vcol\");\n    nr = (int)dict_get_number(d, \"nr\");\n    type = dict_get_string(d, \"type\", TRUE);\n    pattern = dict_get_string(d, \"pattern\", TRUE);\n    text = dict_get_string(d, \"text\", TRUE);\n    if (text == NULL)\n\ttext = vim_strsave((char_u *)\"\");\n\n    valid = TRUE;\n    if ((filename == NULL && bufnum == 0) || (lnum == 0 && pattern == NULL))\n\tvalid = FALSE;\n\n    // Mark entries with non-existing buffer number as not valid. Give the\n    // error message only once.\n    if (bufnum != 0 && (buflist_findnr(bufnum) == NULL))\n    {\n\tif (!did_bufnr_emsg)\n\t{\n\t    did_bufnr_emsg = TRUE;\n\t    semsg(_(e_buffer_nr_not_found), bufnum);\n\t}\n\tvalid = FALSE;\n\tbufnum = 0;\n    }\n\n    // If the 'valid' field is present it overrules the detected value.\n    if (dict_has_key(d, \"valid\"))\n\tvalid = (int)dict_get_bool(d, \"valid\", FALSE);\n\n    status =  qf_add_entry(qfl,\n\t\t\tNULL,\t\t// dir\n\t\t\tfilename,\n\t\t\tmodule,\n\t\t\tbufnum,\n\t\t\ttext,\n\t\t\tlnum,\n\t\t\tend_lnum,\n\t\t\tcol,\n\t\t\tend_col,\n\t\t\tvcol,\t\t// vis_col\n\t\t\tpattern,\t// search pattern\n\t\t\tnr,\n\t\t\ttype == NULL ? NUL : *type,\n\t\t\tvalid);\n\n    vim_free(filename);\n    vim_free(module);\n    vim_free(pattern);\n    vim_free(text);\n    vim_free(type);\n\n    if (valid)\n\t*valid_entry = TRUE;\n\n    return status;\n}\n\n/*\n * Add list of entries to quickfix/location list. Each list entry is\n * a dictionary with item information.\n */\n    static int\nqf_add_entries(\n\tqf_info_T\t*qi,\n\tint\t\tqf_idx,\n\tlist_T\t\t*list,\n\tchar_u\t\t*title,\n\tint\t\taction)\n{\n    qf_list_T\t*qfl = qf_get_list(qi, qf_idx);\n    listitem_T\t*li;\n    dict_T\t*d;\n    qfline_T\t*old_last = NULL;\n    int\t\tretval = OK;\n    int\t\tvalid_entry = FALSE;\n\n    if (action == ' ' || qf_idx == qi->qf_listcount)\n    {\n\t// make place for a new list\n\tqf_new_list(qi, title);\n\tqf_idx = qi->qf_curlist;\n\tqfl = qf_get_list(qi, qf_idx);\n    }\n    else if (action == 'a' && !qf_list_empty(qfl))\n\t// Adding to existing list, use last entry.\n\told_last = qfl->qf_last;\n    else if (action == 'r')\n    {\n\tqf_free_items(qfl);\n\tqf_store_title(qfl, title);\n    }\n\n    FOR_ALL_LIST_ITEMS(list, li)\n    {\n\tif (li->li_tv.v_type != VAR_DICT)\n\t    continue; // Skip non-dict items\n\n\td = li->li_tv.vval.v_dict;\n\tif (d == NULL)\n\t    continue;\n\n\tretval = qf_add_entry_from_dict(qfl, d, li == list->lv_first,\n\t\t\t\t\t\t\t\t&valid_entry);\n\tif (retval == QF_FAIL)\n\t    break;\n    }\n\n    // Check if any valid error entries are added to the list.\n    if (valid_entry)\n\tqfl->qf_nonevalid = FALSE;\n    else if (qfl->qf_index == 0)\n\t// no valid entry\n\tqfl->qf_nonevalid = TRUE;\n\n    // If not appending to the list, set the current error to the first entry\n    if (action != 'a')\n\tqfl->qf_ptr = qfl->qf_start;\n\n    // Update the current error index if not appending to the list or if the\n    // list was empty before and it is not empty now.\n    if ((action != 'a' || qfl->qf_index == 0) && !qf_list_empty(qfl))\n\tqfl->qf_index = 1;\n\n    // Don't update the cursor in quickfix window when appending entries\n    qf_update_buffer(qi, old_last);\n\n    return retval;\n}\n\n/*\n * Get the quickfix list index from 'nr' or 'id'\n */\n    static int\nqf_setprop_get_qfidx(\n\tqf_info_T\t*qi,\n\tdict_T\t\t*what,\n\tint\t\taction,\n\tint\t\t*newlist)\n{\n    dictitem_T\t*di;\n    int\t\tqf_idx = qi->qf_curlist;    // default is the current list\n\n    if ((di = dict_find(what, (char_u *)\"nr\", -1)) != NULL)\n    {\n\t// Use the specified quickfix/location list\n\tif (di->di_tv.v_type == VAR_NUMBER)\n\t{\n\t    // for zero use the current list\n\t    if (di->di_tv.vval.v_number != 0)\n\t\tqf_idx = di->di_tv.vval.v_number - 1;\n\n\t    if ((action == ' ' || action == 'a') && qf_idx == qi->qf_listcount)\n\t    {\n\t\t// When creating a new list, accept qf_idx pointing to the next\n\t\t// non-available list and add the new list at the end of the\n\t\t// stack.\n\t\t*newlist = TRUE;\n\t\tqf_idx = qf_stack_empty(qi) ? 0 : qi->qf_listcount - 1;\n\t    }\n\t    else if (qf_idx < 0 || qf_idx >= qi->qf_listcount)\n\t\treturn INVALID_QFIDX;\n\t    else if (action != ' ')\n\t\t*newlist = FALSE;\t// use the specified list\n\t}\n\telse if (di->di_tv.v_type == VAR_STRING\n\t\t&& di->di_tv.vval.v_string != NULL\n\t\t&& STRCMP(di->di_tv.vval.v_string, \"$\") == 0)\n\t{\n\t    if (!qf_stack_empty(qi))\n\t\tqf_idx = qi->qf_listcount - 1;\n\t    else if (*newlist)\n\t\tqf_idx = 0;\n\t    else\n\t\treturn INVALID_QFIDX;\n\t}\n\telse\n\t    return INVALID_QFIDX;\n    }\n\n    if (!*newlist && (di = dict_find(what, (char_u *)\"id\", -1)) != NULL)\n    {\n\t// Use the quickfix/location list with the specified id\n\tif (di->di_tv.v_type != VAR_NUMBER)\n\t    return INVALID_QFIDX;\n\n\treturn qf_id2nr(qi, di->di_tv.vval.v_number);\n    }\n\n    return qf_idx;\n}\n\n/*\n * Set the quickfix list title.\n */\n    static int\nqf_setprop_title(qf_info_T *qi, int qf_idx, dict_T *what, dictitem_T *di)\n{\n    qf_list_T\t*qfl = qf_get_list(qi, qf_idx);\n\n    if (di->di_tv.v_type != VAR_STRING)\n\treturn FAIL;\n\n    vim_free(qfl->qf_title);\n    qfl->qf_title = dict_get_string(what, \"title\", TRUE);\n    if (qf_idx == qi->qf_curlist)\n\tqf_update_win_titlevar(qi);\n\n    return OK;\n}\n\n/*\n * Set quickfix list items/entries.\n */\n    static int\nqf_setprop_items(qf_info_T *qi, int qf_idx, dictitem_T *di, int action)\n{\n    int\t\tretval = FAIL;\n    char_u\t*title_save;\n\n    if (di->di_tv.v_type != VAR_LIST)\n\treturn FAIL;\n\n    title_save = vim_strsave(qi->qf_lists[qf_idx].qf_title);\n    retval = qf_add_entries(qi, qf_idx, di->di_tv.vval.v_list,\n\t    title_save, action == ' ' ? 'a' : action);\n    vim_free(title_save);\n\n    return retval;\n}\n\n/*\n * Set quickfix list items/entries from a list of lines.\n */\n    static int\nqf_setprop_items_from_lines(\n\tqf_info_T\t*qi,\n\tint\t\tqf_idx,\n\tdict_T\t\t*what,\n\tdictitem_T\t*di,\n\tint\t\taction)\n{\n    char_u\t*errorformat = p_efm;\n    dictitem_T\t*efm_di;\n    int\t\tretval = FAIL;\n\n    // Use the user supplied errorformat settings (if present)\n    if ((efm_di = dict_find(what, (char_u *)\"efm\", -1)) != NULL)\n    {\n\tif (efm_di->di_tv.v_type != VAR_STRING ||\n\t\tefm_di->di_tv.vval.v_string == NULL)\n\t    return FAIL;\n\terrorformat = efm_di->di_tv.vval.v_string;\n    }\n\n    // Only a List value is supported\n    if (di->di_tv.v_type != VAR_LIST || di->di_tv.vval.v_list == NULL)\n\treturn FAIL;\n\n    if (action == 'r')\n\tqf_free_items(&qi->qf_lists[qf_idx]);\n    if (qf_init_ext(qi, qf_idx, NULL, NULL, &di->di_tv, errorformat,\n\t\tFALSE, (linenr_T)0, (linenr_T)0, NULL, NULL) >= 0)\n\tretval = OK;\n\n    return retval;\n}\n\n/*\n * Set quickfix list context.\n */\n    static int\nqf_setprop_context(qf_list_T *qfl, dictitem_T *di)\n{\n    typval_T\t*ctx;\n\n    free_tv(qfl->qf_ctx);\n    ctx =  alloc_tv();\n    if (ctx != NULL)\n\tcopy_tv(&di->di_tv, ctx);\n    qfl->qf_ctx = ctx;\n\n    return OK;\n}\n\n/*\n * Set the current index in the specified quickfix list\n */\n    static int\nqf_setprop_curidx(qf_info_T *qi, qf_list_T *qfl, dictitem_T *di)\n{\n    int\t\tdenote = FALSE;\n    int\t\tnewidx;\n    int\t\told_qfidx;\n    qfline_T\t*qf_ptr;\n\n    // If the specified index is '$', then use the last entry\n    if (di->di_tv.v_type == VAR_STRING\n\t    && di->di_tv.vval.v_string != NULL\n\t    && STRCMP(di->di_tv.vval.v_string, \"$\") == 0)\n\tnewidx = qfl->qf_count;\n    else\n    {\n\t// Otherwise use the specified index\n\tnewidx = tv_get_number_chk(&di->di_tv, &denote);\n\tif (denote)\n\t    return FAIL;\n    }\n\n    if (newidx < 1)\t\t// sanity check\n\treturn FAIL;\n    if (newidx > qfl->qf_count)\n\tnewidx = qfl->qf_count;\n\n    old_qfidx = qfl->qf_index;\n    qf_ptr = get_nth_entry(qfl, newidx, &newidx);\n    if (qf_ptr == NULL)\n\treturn FAIL;\n    qfl->qf_ptr = qf_ptr;\n    qfl->qf_index = newidx;\n\n    // If the current list is modified and it is displayed in the quickfix\n    // window, then Update it.\n    if (qf_get_curlist(qi)->qf_id == qfl->qf_id)\n\tqf_win_pos_update(qi, old_qfidx);\n\n    return OK;\n}\n\n/*\n * Set the current index in the specified quickfix list\n */\n    static int\nqf_setprop_qftf(qf_info_T *qi UNUSED, qf_list_T *qfl, dictitem_T *di)\n{\n    callback_T\tcb;\n\n    free_callback(&qfl->qf_qftf_cb);\n    cb = get_callback(&di->di_tv);\n    if (cb.cb_name == NULL || *cb.cb_name == NUL)\n\treturn OK;\n\n    set_callback(&qfl->qf_qftf_cb, &cb);\n    if (cb.cb_free_name)\n\tvim_free(cb.cb_name);\n\n    return OK;\n}\n\n/*\n * Set quickfix/location list properties (title, items, context).\n * Also used to add items from parsing a list of lines.\n * Used by the setqflist() and setloclist() Vim script functions.\n */\n    static int\nqf_set_properties(qf_info_T *qi, dict_T *what, int action, char_u *title)\n{\n    dictitem_T\t*di;\n    int\t\tretval = FAIL;\n    int\t\tqf_idx;\n    int\t\tnewlist = FALSE;\n    qf_list_T\t*qfl;\n\n    if (action == ' ' || qf_stack_empty(qi))\n\tnewlist = TRUE;\n\n    qf_idx = qf_setprop_get_qfidx(qi, what, action, &newlist);\n    if (qf_idx == INVALID_QFIDX)\t// List not found\n\treturn FAIL;\n\n    if (newlist)\n    {\n\tqi->qf_curlist = qf_idx;\n\tqf_new_list(qi, title);\n\tqf_idx = qi->qf_curlist;\n    }\n\n    qfl = qf_get_list(qi, qf_idx);\n    if ((di = dict_find(what, (char_u *)\"title\", -1)) != NULL)\n\tretval = qf_setprop_title(qi, qf_idx, what, di);\n    if ((di = dict_find(what, (char_u *)\"items\", -1)) != NULL)\n\tretval = qf_setprop_items(qi, qf_idx, di, action);\n    if ((di = dict_find(what, (char_u *)\"lines\", -1)) != NULL)\n\tretval = qf_setprop_items_from_lines(qi, qf_idx, what, di, action);\n    if ((di = dict_find(what, (char_u *)\"context\", -1)) != NULL)\n\tretval = qf_setprop_context(qfl, di);\n    if ((di = dict_find(what, (char_u *)\"idx\", -1)) != NULL)\n\tretval = qf_setprop_curidx(qi, qfl, di);\n    if ((di = dict_find(what, (char_u *)\"quickfixtextfunc\", -1)) != NULL)\n\tretval = qf_setprop_qftf(qi, qfl, di);\n\n    if (newlist || retval == OK)\n\tqf_list_changed(qfl);\n    if (newlist)\n\tqf_update_buffer(qi, NULL);\n\n    return retval;\n}\n\n/*\n * Free the entire quickfix/location list stack.\n * If the quickfix/location list window is open, then clear it.\n */\n    static void\nqf_free_stack(win_T *wp, qf_info_T *qi)\n{\n    win_T\t*qfwin = qf_find_win(qi);\n    win_T\t*llwin = NULL;\n\n    if (qfwin != NULL)\n    {\n\t// If the quickfix/location list window is open, then clear it\n\tif (qi->qf_curlist < qi->qf_listcount)\n\t    qf_free(qf_get_curlist(qi));\n\tqf_update_buffer(qi, NULL);\n    }\n\n    if (wp != NULL && IS_LL_WINDOW(wp))\n    {\n\t// If in the location list window, then use the non-location list\n\t// window with this location list (if present)\n\tllwin = qf_find_win_with_loclist(qi);\n\tif (llwin != NULL)\n\t    wp = llwin;\n    }\n\n    qf_free_all(wp);\n    if (wp == NULL)\n    {\n\t// quickfix list\n\tqi->qf_curlist = 0;\n\tqi->qf_listcount = 0;\n    }\n    else if (qfwin != NULL)\n    {\n\t// If the location list window is open, then create a new empty\n\t// location list\n\tqf_info_T *new_ll = qf_alloc_stack(QFLT_LOCATION);\n\n\tif (new_ll != NULL)\n\t{\n\t    new_ll->qf_bufnr = qfwin->w_buffer->b_fnum;\n\n\t    // first free the list reference in the location list window\n\t    ll_free_all(&qfwin->w_llist_ref);\n\n\t    qfwin->w_llist_ref = new_ll;\n\t    if (wp != qfwin)\n\t\twin_set_loclist(wp, new_ll);\n\t}\n    }\n}\n\n/*\n * Populate the quickfix list with the items supplied in the list\n * of dictionaries. \"title\" will be copied to w:quickfix_title.\n * \"action\" is 'a' for add, 'r' for replace.  Otherwise create a new list.\n * When \"what\" is not NULL then only set some properties.\n */\n    int\nset_errorlist(\n\twin_T\t*wp,\n\tlist_T\t*list,\n\tint\taction,\n\tchar_u\t*title,\n\tdict_T\t*what)\n{\n    qf_info_T\t*qi = &ql_info;\n    int\t\tretval = OK;\n\n    if (wp != NULL)\n    {\n\tqi = ll_get_or_alloc_list(wp);\n\tif (qi == NULL)\n\t    return FAIL;\n    }\n\n    if (action == 'f')\n    {\n\t// Free the entire quickfix or location list stack\n\tqf_free_stack(wp, qi);\n\treturn OK;\n    }\n\n    // A dict argument cannot be specified with a non-empty list argument\n    if (list->lv_len != 0 && what != NULL)\n    {\n\tsemsg(_(e_invalid_argument_str),\n\t\t\t _(\"cannot have both a list and a \\\"what\\\" argument\"));\n\treturn FAIL;\n    }\n\n    incr_quickfix_busy();\n\n    if (what != NULL)\n\tretval = qf_set_properties(qi, what, action, title);\n    else\n    {\n\tretval = qf_add_entries(qi, qi->qf_curlist, list, title, action);\n\tif (retval == OK)\n\t    qf_list_changed(qf_get_curlist(qi));\n    }\n\n    decr_quickfix_busy();\n\n    return retval;\n}\n\n/*\n * Mark the quickfix context and callback function as in use for all the lists\n * in a quickfix stack.\n */\n    static int\nmark_quickfix_ctx(qf_info_T *qi, int copyID)\n{\n    int\t\ti;\n    int\t\tabort = FALSE;\n    typval_T\t*ctx;\n    callback_T\t*cb;\n\n    for (i = 0; i < LISTCOUNT && !abort; ++i)\n    {\n\tctx = qi->qf_lists[i].qf_ctx;\n\tif (ctx != NULL && ctx->v_type != VAR_NUMBER\n\t\t&& ctx->v_type != VAR_STRING && ctx->v_type != VAR_FLOAT)\n\t    abort = abort || set_ref_in_item(ctx, copyID, NULL, NULL);\n\n\tcb = &qi->qf_lists[i].qf_qftf_cb;\n\tabort = abort || set_ref_in_callback(cb, copyID);\n    }\n\n    return abort;\n}\n\n/*\n * Mark the context of the quickfix list and the location lists (if present) as\n * \"in use\". So that garbage collection doesn't free the context.\n */\n    int\nset_ref_in_quickfix(int copyID)\n{\n    int\t\tabort = FALSE;\n    tabpage_T\t*tp;\n    win_T\t*win;\n\n    abort = mark_quickfix_ctx(&ql_info, copyID);\n    if (abort)\n\treturn abort;\n\n    abort = set_ref_in_callback(&qftf_cb, copyID);\n    if (abort)\n\treturn abort;\n\n    FOR_ALL_TAB_WINDOWS(tp, win)\n    {\n\tif (win->w_llist != NULL)\n\t{\n\t    abort = mark_quickfix_ctx(win->w_llist, copyID);\n\t    if (abort)\n\t\treturn abort;\n\t}\n\tif (IS_LL_WINDOW(win) && (win->w_llist_ref->qf_refcount == 1))\n\t{\n\t    // In a location list window and none of the other windows is\n\t    // referring to this location list. Mark the location list\n\t    // context as still in use.\n\t    abort = mark_quickfix_ctx(win->w_llist_ref, copyID);\n\t    if (abort)\n\t\treturn abort;\n\t}\n    }\n\n    return abort;\n}\n#endif\n\n/*\n * Return the autocmd name for the :cbuffer Ex commands\n */\n    static char_u *\ncbuffer_get_auname(cmdidx_T cmdidx)\n{\n    switch (cmdidx)\n    {\n\tcase CMD_cbuffer:\treturn (char_u *)\"cbuffer\";\n\tcase CMD_cgetbuffer:\treturn (char_u *)\"cgetbuffer\";\n\tcase CMD_caddbuffer:\treturn (char_u *)\"caddbuffer\";\n\tcase CMD_lbuffer:\treturn (char_u *)\"lbuffer\";\n\tcase CMD_lgetbuffer:\treturn (char_u *)\"lgetbuffer\";\n\tcase CMD_laddbuffer:\treturn (char_u *)\"laddbuffer\";\n\tdefault:\t\treturn NULL;\n    }\n}\n\n/*\n * Process and validate the arguments passed to the :cbuffer, :caddbuffer,\n * :cgetbuffer, :lbuffer, :laddbuffer, :lgetbuffer Ex commands.\n */\n    static int\ncbuffer_process_args(\n\texarg_T\t\t*eap,\n\tbuf_T\t\t**bufp,\n\tlinenr_T\t*line1,\n\tlinenr_T\t*line2)\n{\n    buf_T\t*buf = NULL;\n\n    if (*eap->arg == NUL)\n\tbuf = curbuf;\n    else if (*skipwhite(skipdigits(eap->arg)) == NUL)\n\tbuf = buflist_findnr(atoi((char *)eap->arg));\n\n    if (buf == NULL)\n    {\n\temsg(_(e_invalid_argument));\n\treturn FAIL;\n    }\n\n    if (buf->b_ml.ml_mfp == NULL)\n    {\n\temsg(_(e_buffer_is_not_loaded));\n\treturn FAIL;\n    }\n\n    if (eap->addr_count == 0)\n    {\n\teap->line1 = 1;\n\teap->line2 = buf->b_ml.ml_line_count;\n    }\n\n    if (eap->line1 < 1 || eap->line1 > buf->b_ml.ml_line_count\n\t    || eap->line2 < 1 || eap->line2 > buf->b_ml.ml_line_count)\n    {\n\temsg(_(e_invalid_range));\n\treturn FAIL;\n    }\n\n    *line1 = eap->line1;\n    *line2 = eap->line2;\n    *bufp = buf;\n\n    return OK;\n}\n\n/*\n * \":[range]cbuffer [bufnr]\" command.\n * \":[range]caddbuffer [bufnr]\" command.\n * \":[range]cgetbuffer [bufnr]\" command.\n * \":[range]lbuffer [bufnr]\" command.\n * \":[range]laddbuffer [bufnr]\" command.\n * \":[range]lgetbuffer [bufnr]\" command.\n */\n    void\nex_cbuffer(exarg_T *eap)\n{\n    buf_T\t*buf = NULL;\n    qf_info_T\t*qi;\n    char_u\t*au_name = NULL;\n    int\t\tres;\n    int_u\tsave_qfid;\n    win_T\t*wp = NULL;\n    char_u\t*qf_title;\n    linenr_T\tline1;\n    linenr_T\tline2;\n\n    au_name = cbuffer_get_auname(eap->cmdidx);\n    if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,\n\t\t\t\t\tcurbuf->b_fname, TRUE, curbuf))\n    {\n#ifdef FEAT_EVAL\n\tif (aborting())\n\t    return;\n#endif\n    }\n\n    // Must come after autocommands.\n    qi = qf_cmd_get_or_alloc_stack(eap, &wp);\n    if (qi == NULL)\n\treturn;\n\n    if (cbuffer_process_args(eap, &buf, &line1, &line2) == FAIL)\n\treturn;\n\n    qf_title = qf_cmdtitle(*eap->cmdlinep);\n\n    if (buf->b_sfname)\n    {\n\tvim_snprintf((char *)IObuff, IOSIZE, \"%s (%s)\",\n\t\t(char *)qf_title, (char *)buf->b_sfname);\n\tqf_title = IObuff;\n    }\n\n    incr_quickfix_busy();\n\n    res = qf_init_ext(qi, qi->qf_curlist, NULL, buf, NULL, p_efm,\n\t    (eap->cmdidx != CMD_caddbuffer\n\t     && eap->cmdidx != CMD_laddbuffer),\n\t    line1, line2,\n\t    qf_title, NULL);\n    if (qf_stack_empty(qi))\n    {\n\tdecr_quickfix_busy();\n\treturn;\n    }\n    if (res >= 0)\n\tqf_list_changed(qf_get_curlist(qi));\n\n    // Remember the current quickfix list identifier, so that we can\n    // check for autocommands changing the current quickfix list.\n    save_qfid = qf_get_curlist(qi)->qf_id;\n    if (au_name != NULL)\n    {\n\tbuf_T *curbuf_old = curbuf;\n\n\tapply_autocmds(EVENT_QUICKFIXCMDPOST, au_name, curbuf->b_fname,\n\t\t\t\t\t\t\t\tTRUE, curbuf);\n\tif (curbuf != curbuf_old)\n\t    // Autocommands changed buffer, don't jump now, \"qi\" may\n\t    // be invalid.\n\t    res = 0;\n    }\n    // Jump to the first error for a new list and if autocmds didn't\n    // free the list.\n    if (res > 0 && (eap->cmdidx == CMD_cbuffer ||\n\t\teap->cmdidx == CMD_lbuffer)\n\t    && qflist_valid(wp, save_qfid))\n\t// display the first error\n\tqf_jump_first(qi, save_qfid, eap->forceit);\n\n    decr_quickfix_busy();\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return the autocmd name for the :cexpr Ex commands.\n */\n    char_u *\ncexpr_get_auname(cmdidx_T cmdidx)\n{\n    switch (cmdidx)\n    {\n\tcase CMD_cexpr:\t    return (char_u *)\"cexpr\";\n\tcase CMD_cgetexpr:  return (char_u *)\"cgetexpr\";\n\tcase CMD_caddexpr:  return (char_u *)\"caddexpr\";\n\tcase CMD_lexpr:\t    return (char_u *)\"lexpr\";\n\tcase CMD_lgetexpr:  return (char_u *)\"lgetexpr\";\n\tcase CMD_laddexpr:  return (char_u *)\"laddexpr\";\n\tdefault:\t    return NULL;\n    }\n}\n\n    int\ntrigger_cexpr_autocmd(int cmdidx)\n{\n    char_u\t*au_name = cexpr_get_auname(cmdidx);\n\n    if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,\n\t\t\t\t\t       curbuf->b_fname, TRUE, curbuf))\n    {\n\tif (aborting())\n\t    return FAIL;\n    }\n    return OK;\n}\n\n    int\ncexpr_core(exarg_T *eap, typval_T *tv)\n{\n    qf_info_T\t*qi;\n    win_T\t*wp = NULL;\n\n    qi = qf_cmd_get_or_alloc_stack(eap, &wp);\n    if (qi == NULL)\n\treturn FAIL;\n\n    if ((tv->v_type == VAR_STRING && tv->vval.v_string != NULL)\n\t    || (tv->v_type == VAR_LIST && tv->vval.v_list != NULL))\n    {\n\tint\tres;\n\tint_u\tsave_qfid;\n\tchar_u\t*au_name = cexpr_get_auname(eap->cmdidx);\n\n\tincr_quickfix_busy();\n\tres = qf_init_ext(qi, qi->qf_curlist, NULL, NULL, tv, p_efm,\n\t\t\t(eap->cmdidx != CMD_caddexpr\n\t\t\t && eap->cmdidx != CMD_laddexpr),\n\t\t\t     (linenr_T)0, (linenr_T)0,\n\t\t\t     qf_cmdtitle(*eap->cmdlinep), NULL);\n\tif (qf_stack_empty(qi))\n\t{\n\t    decr_quickfix_busy();\n\t    return FAIL;\n\t}\n\tif (res >= 0)\n\t    qf_list_changed(qf_get_curlist(qi));\n\n\t// Remember the current quickfix list identifier, so that we can\n\t// check for autocommands changing the current quickfix list.\n\tsave_qfid = qf_get_curlist(qi)->qf_id;\n\tif (au_name != NULL)\n\t    apply_autocmds(EVENT_QUICKFIXCMDPOST, au_name,\n\t\t\t\t\t    curbuf->b_fname, TRUE, curbuf);\n\n\t// Jump to the first error for a new list and if autocmds didn't\n\t// free the list.\n\tif (res > 0 && (eap->cmdidx == CMD_cexpr || eap->cmdidx == CMD_lexpr)\n\t\t&& qflist_valid(wp, save_qfid))\n\t    // display the first error\n\t    qf_jump_first(qi, save_qfid, eap->forceit);\n\tdecr_quickfix_busy();\n\treturn OK;\n    }\n\n    emsg(_(e_string_or_list_expected));\n    return FAIL;\n}\n\n/*\n * \":cexpr {expr}\", \":cgetexpr {expr}\", \":caddexpr {expr}\" command.\n * \":lexpr {expr}\", \":lgetexpr {expr}\", \":laddexpr {expr}\" command.\n * Also: \":caddexpr\", \":cgetexpr\", \"laddexpr\" and \"laddexpr\".\n */\n    void\nex_cexpr(exarg_T *eap)\n{\n    typval_T\t*tv;\n\n    if (trigger_cexpr_autocmd(eap->cmdidx) == FAIL)\n\treturn;\n\n    // Evaluate the expression.  When the result is a string or a list we can\n    // use it to fill the errorlist.\n    tv = eval_expr(eap->arg, eap);\n    if (tv == NULL)\n\treturn;\n\n    (void)cexpr_core(eap, tv);\n    free_tv(tv);\n}\n#endif\n\n/*\n * Get the location list for \":lhelpgrep\"\n */\n    static qf_info_T *\nhgr_get_ll(int *new_ll)\n{\n    win_T\t*wp;\n    qf_info_T\t*qi;\n\n    // If the current window is a help window, then use it\n    if (bt_help(curwin->w_buffer))\n\twp = curwin;\n    else\n\t// Find an existing help window\n\twp = qf_find_help_win();\n\n    if (wp == NULL)\t    // Help window not found\n\tqi = NULL;\n    else\n\tqi = wp->w_llist;\n\n    if (qi == NULL)\n    {\n\t// Allocate a new location list for help text matches\n\tif ((qi = qf_alloc_stack(QFLT_LOCATION)) == NULL)\n\t    return NULL;\n\t*new_ll = TRUE;\n    }\n\n    return qi;\n}\n\n/*\n * Search for a pattern in a help file.\n */\n    static void\nhgr_search_file(\n\tqf_list_T *qfl,\n\tchar_u *fname,\n\tvimconv_T *p_vc,\n\tregmatch_T *p_regmatch)\n{\n    FILE\t*fd;\n    long\tlnum;\n\n    fd = mch_fopen((char *)fname, \"r\");\n    if (fd == NULL)\n\treturn;\n\n    lnum = 1;\n    while (!vim_fgets(IObuff, IOSIZE, fd) && !got_int)\n    {\n\tchar_u    *line = IObuff;\n\n\t// Convert a line if 'encoding' is not utf-8 and\n\t// the line contains a non-ASCII character.\n\tif (p_vc->vc_type != CONV_NONE && has_non_ascii(IObuff))\n\t{\n\t    line = string_convert(p_vc, IObuff, NULL);\n\t    if (line == NULL)\n\t\tline = IObuff;\n\t}\n\n\tif (vim_regexec(p_regmatch, line, (colnr_T)0))\n\t{\n\t    int\tl = (int)STRLEN(line);\n\n\t    // remove trailing CR, LF, spaces, etc.\n\t    while (l > 0 && line[l - 1] <= ' ')\n\t\tline[--l] = NUL;\n\n\t    if (qf_add_entry(qfl,\n\t\t\tNULL,\t// dir\n\t\t\tfname,\n\t\t\tNULL,\n\t\t\t0,\n\t\t\tline,\n\t\t\tlnum,\n\t\t\t0,\n\t\t\t(int)(p_regmatch->startp[0] - line)\n\t\t\t+ 1,\t// col\n\t\t\t(int)(p_regmatch->endp[0] - line)\n\t\t\t+ 1,\t// end_col\n\t\t\tFALSE,\t// vis_col\n\t\t\tNULL,\t// search pattern\n\t\t\t0,\t// nr\n\t\t\t1,\t// type\n\t\t\tTRUE\t// valid\n\t\t\t) == QF_FAIL)\n\t    {\n\t\tgot_int = TRUE;\n\t\tif (line != IObuff)\n\t\t    vim_free(line);\n\t\tbreak;\n\t    }\n\t}\n\tif (line != IObuff)\n\t    vim_free(line);\n\t++lnum;\n\tline_breakcheck();\n    }\n    fclose(fd);\n}\n\n/*\n * Search for a pattern in all the help files in the doc directory under\n * the given directory.\n */\n    static void\nhgr_search_files_in_dir(\n\tqf_list_T *qfl,\n\tchar_u *dirname,\n\tregmatch_T *p_regmatch,\n\tvimconv_T *p_vc\n#ifdef FEAT_MULTI_LANG\n\t, char_u *lang\n#endif\n\t)\n{\n    int\t\tfcount;\n    char_u\t**fnames;\n    int\t\tfi;\n\n    // Find all \"*.txt\" and \"*.??x\" files in the \"doc\" directory.\n    add_pathsep(dirname);\n    STRCAT(dirname, \"doc/*.\\\\(txt\\\\|??x\\\\)\");\n    if (gen_expand_wildcards(1, &dirname, &fcount,\n\t\t&fnames, EW_FILE|EW_SILENT) == OK\n\t    && fcount > 0)\n    {\n\tfor (fi = 0; fi < fcount && !got_int; ++fi)\n\t{\n#ifdef FEAT_MULTI_LANG\n\t    // Skip files for a different language.\n\t    if (lang != NULL\n\t\t    && STRNICMP(lang, fnames[fi]\n\t\t\t\t    + STRLEN(fnames[fi]) - 3, 2) != 0\n\t\t    && !(STRNICMP(lang, \"en\", 2) == 0\n\t\t\t&& STRNICMP(\"txt\", fnames[fi]\n\t\t\t    + STRLEN(fnames[fi]) - 3, 3) == 0))\n\t\tcontinue;\n#endif\n\n\t    hgr_search_file(qfl, fnames[fi], p_vc, p_regmatch);\n\t}\n\tFreeWild(fcount, fnames);\n    }\n}\n\n/*\n * Search for a pattern in all the help files in the 'runtimepath'\n * and add the matches to a quickfix list.\n * 'lang' is the language specifier.  If supplied, then only matches in the\n * specified language are found.\n */\n    static void\nhgr_search_in_rtp(qf_list_T *qfl, regmatch_T *p_regmatch, char_u *lang)\n{\n    char_u\t*p;\n\n    vimconv_T\tvc;\n\n    // Help files are in utf-8 or latin1, convert lines when 'encoding'\n    // differs.\n    vc.vc_type = CONV_NONE;\n    if (!enc_utf8)\n\tconvert_setup(&vc, (char_u *)\"utf-8\", p_enc);\n\n    // Go through all the directories in 'runtimepath'\n    p = p_rtp;\n    while (*p != NUL && !got_int)\n    {\n\tcopy_option_part(&p, NameBuff, MAXPATHL, \",\");\n\n\thgr_search_files_in_dir(qfl, NameBuff, p_regmatch, &vc\n#ifdef FEAT_MULTI_LANG\n\t\t, lang\n#endif\n\t\t);\n    }\n\n    if (vc.vc_type != CONV_NONE)\n\tconvert_setup(&vc, NULL, NULL);\n}\n\n/*\n * \":helpgrep {pattern}\"\n */\n    void\nex_helpgrep(exarg_T *eap)\n{\n    regmatch_T\tregmatch;\n    char_u\t*save_cpo;\n    int\t\tsave_cpo_allocated;\n    qf_info_T\t*qi = &ql_info;\n    int\t\tnew_qi = FALSE;\n    char_u\t*au_name =  NULL;\n    char_u\t*lang = NULL;\n    int\t\tupdated = FALSE;\n\n    switch (eap->cmdidx)\n    {\n\tcase CMD_helpgrep:  au_name = (char_u *)\"helpgrep\"; break;\n\tcase CMD_lhelpgrep: au_name = (char_u *)\"lhelpgrep\"; break;\n\tdefault: break;\n    }\n    if (au_name != NULL && apply_autocmds(EVENT_QUICKFIXCMDPRE, au_name,\n\t\t\t\t\t       curbuf->b_fname, TRUE, curbuf))\n    {\n#ifdef FEAT_EVAL\n\tif (aborting())\n\t    return;\n#endif\n    }\n\n    if (is_loclist_cmd(eap->cmdidx))\n    {\n\tqi = hgr_get_ll(&new_qi);\n\tif (qi == NULL)\n\t    return;\n    }\n\n    // Make 'cpoptions' empty, the 'l' flag should not be used here.\n    save_cpo = p_cpo;\n    save_cpo_allocated = is_option_allocated(\"cpo\");\n    p_cpo = empty_option;\n\n    incr_quickfix_busy();\n\n#ifdef FEAT_MULTI_LANG\n    // Check for a specified language\n    lang = check_help_lang(eap->arg);\n#endif\n    regmatch.regprog = vim_regcomp(eap->arg, RE_MAGIC + RE_STRING);\n    regmatch.rm_ic = FALSE;\n    if (regmatch.regprog != NULL)\n    {\n\tqf_list_T\t*qfl;\n\n\t// create a new quickfix list\n\tqf_new_list(qi, qf_cmdtitle(*eap->cmdlinep));\n\tqfl = qf_get_curlist(qi);\n\n\thgr_search_in_rtp(qfl, &regmatch, lang);\n\n\tvim_regfree(regmatch.regprog);\n\n\tqfl->qf_nonevalid = FALSE;\n\tqfl->qf_ptr = qfl->qf_start;\n\tqfl->qf_index = 1;\n\tqf_list_changed(qfl);\n\tupdated = TRUE;\n    }\n\n    if (p_cpo == empty_option)\n\tp_cpo = save_cpo;\n    else\n    {\n\t// Darn, some plugin changed the value.  If it's still empty it was\n\t// changed and restored, need to restore in the complicated way.\n\tif (*p_cpo == NUL)\n\t    set_option_value_give_err((char_u *)\"cpo\", 0L, save_cpo, 0);\n\tif (save_cpo_allocated)\n\t    free_string_option(save_cpo);\n    }\n\n    if (updated)\n\t// This may open a window and source scripts, do this after 'cpo' was\n\t// restored.\n\tqf_update_buffer(qi, NULL);\n\n    if (au_name != NULL)\n    {\n\tapply_autocmds(EVENT_QUICKFIXCMDPOST, au_name,\n\t\t\t\t\t       curbuf->b_fname, TRUE, curbuf);\n\t// When adding a location list to an existing location list stack,\n\t// if the autocmd made the stack invalid, then just return.\n\tif (!new_qi && IS_LL_STACK(qi) && qf_find_win_with_loclist(qi) == NULL)\n\t{\n\t    decr_quickfix_busy();\n\t    return;\n\t}\n    }\n\n    // Jump to first match.\n    if (!qf_list_empty(qf_get_curlist(qi)))\n\tqf_jump(qi, 0, 0, FALSE);\n    else\n\tsemsg(_(e_no_match_str_2), eap->arg);\n\n    decr_quickfix_busy();\n\n    if (eap->cmdidx == CMD_lhelpgrep)\n    {\n\t// If the help window is not opened or if it already points to the\n\t// correct location list, then free the new location list.\n\tif (!bt_help(curwin->w_buffer) || curwin->w_llist == qi)\n\t{\n\t    if (new_qi)\n\t\tll_free_all(&qi);\n\t}\n\telse if (curwin->w_llist == NULL && new_qi)\n\t    // current window didn't have a location list associated with it\n\t    // before. Associate the new location list now.\n\t    curwin->w_llist = qi;\n    }\n}\n\n# if defined(EXITFREE) || defined(PROTO)\n    void\nfree_quickfix(void)\n{\n    win_T\t*win;\n    tabpage_T\t*tab;\n\n    qf_free_all(NULL);\n    // Free all location lists\n    FOR_ALL_TAB_WINDOWS(tab, win)\n\tqf_free_all(win);\n\n    ga_clear(&qfga);\n}\n# endif\n\n#endif // FEAT_QUICKFIX\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n# ifdef FEAT_QUICKFIX\n    static void\nget_qf_loc_list(int is_qf, win_T *wp, typval_T *what_arg, typval_T *rettv)\n{\n    if (what_arg->v_type == VAR_UNKNOWN)\n    {\n\tif (rettv_list_alloc(rettv) == OK)\n\t    if (is_qf || wp != NULL)\n\t\t(void)get_errorlist(NULL, wp, -1, 0, rettv->vval.v_list);\n    }\n    else\n    {\n\tif (rettv_dict_alloc(rettv) == OK)\n\t    if (is_qf || (wp != NULL))\n\t    {\n\t\tif (what_arg->v_type == VAR_DICT)\n\t\t{\n\t\t    dict_T\t*d = what_arg->vval.v_dict;\n\n\t\t    if (d != NULL)\n\t\t\tqf_get_properties(wp, d, rettv->vval.v_dict);\n\t\t}\n\t\telse\n\t\t    emsg(_(e_dictionary_required));\n\t    }\n    }\n}\n# endif\n\n/*\n * \"getloclist()\" function\n */\n    void\nf_getloclist(typval_T *argvars UNUSED, typval_T *rettv UNUSED)\n{\n# ifdef FEAT_QUICKFIX\n    win_T\t*wp;\n\n    if (in_vim9script()\n\t    && (check_for_number_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_dict_arg(argvars, 1) == FAIL))\n\treturn;\n\n    wp = find_win_by_nr_or_id(&argvars[0]);\n    get_qf_loc_list(FALSE, wp, &argvars[1], rettv);\n# endif\n}\n\n/*\n * \"getqflist()\" function\n */\n    void\nf_getqflist(typval_T *argvars UNUSED, typval_T *rettv UNUSED)\n{\n# ifdef FEAT_QUICKFIX\n    if (in_vim9script() && check_for_opt_dict_arg(argvars, 0) == FAIL)\n\treturn;\n\n    get_qf_loc_list(TRUE, NULL, &argvars[0], rettv);\n# endif\n}\n\n/*\n * Used by \"setqflist()\" and \"setloclist()\" functions\n */\n    static void\nset_qf_ll_list(\n    win_T\t*wp UNUSED,\n    typval_T\t*list_arg UNUSED,\n    typval_T\t*action_arg UNUSED,\n    typval_T\t*what_arg UNUSED,\n    typval_T\t*rettv)\n{\n# ifdef FEAT_QUICKFIX\n    char_u\t*act;\n    int\t\taction = 0;\n    static int\trecursive = 0;\n# endif\n\n    rettv->vval.v_number = -1;\n\n# ifdef FEAT_QUICKFIX\n    if (list_arg->v_type != VAR_LIST)\n\temsg(_(e_list_required));\n    else if (recursive != 0)\n\temsg(_(e_autocommand_caused_recursive_behavior));\n    else\n    {\n\tlist_T  *l = list_arg->vval.v_list;\n\tdict_T\t*what = NULL;\n\tint\tvalid_dict = TRUE;\n\n\tif (action_arg->v_type == VAR_STRING)\n\t{\n\t    act = tv_get_string_chk(action_arg);\n\t    if (act == NULL)\n\t\treturn;\t\t// type error; errmsg already given\n\t    if ((*act == 'a' || *act == 'r' || *act == ' ' || *act == 'f') &&\n\t\t    act[1] == NUL)\n\t\taction = *act;\n\t    else\n\t\tsemsg(_(e_invalid_action_str_1), act);\n\t}\n\telse if (action_arg->v_type == VAR_UNKNOWN)\n\t    action = ' ';\n\telse\n\t    emsg(_(e_string_required));\n\n\tif (action_arg->v_type != VAR_UNKNOWN\n\t\t&& what_arg->v_type != VAR_UNKNOWN)\n\t{\n\t    if (what_arg->v_type == VAR_DICT && what_arg->vval.v_dict != NULL)\n\t\twhat = what_arg->vval.v_dict;\n\t    else\n\t    {\n\t\temsg(_(e_dictionary_required));\n\t\tvalid_dict = FALSE;\n\t    }\n\t}\n\n\t++recursive;\n\tif (l != NULL && action && valid_dict\n\t\t    && set_errorlist(wp, l, action,\n\t\t     (char_u *)(wp == NULL ? \":setqflist()\" : \":setloclist()\"),\n\t\t     what) == OK)\n\t    rettv->vval.v_number = 0;\n\t--recursive;\n    }\n# endif\n}\n\n/*\n * \"setloclist()\" function\n */\n    void\nf_setloclist(typval_T *argvars, typval_T *rettv)\n{\n    win_T\t*win;\n\n    rettv->vval.v_number = -1;\n\n    if (in_vim9script()\n\t    && (check_for_number_arg(argvars, 0) == FAIL\n\t\t|| check_for_list_arg(argvars, 1) == FAIL\n\t\t|| check_for_opt_string_arg(argvars, 2) == FAIL\n\t\t|| (argvars[2].v_type != VAR_UNKNOWN\n\t\t    && check_for_opt_dict_arg(argvars, 3) == FAIL)))\n\treturn;\n\n    win = find_win_by_nr_or_id(&argvars[0]);\n    if (win != NULL)\n\tset_qf_ll_list(win, &argvars[1], &argvars[2], &argvars[3], rettv);\n}\n\n/*\n * \"setqflist()\" function\n */\n    void\nf_setqflist(typval_T *argvars, typval_T *rettv)\n{\n    if (in_vim9script()\n\t    && (check_for_list_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_string_arg(argvars, 1) == FAIL\n\t\t|| (argvars[1].v_type != VAR_UNKNOWN\n\t\t    && check_for_opt_dict_arg(argvars, 2) == FAIL)))\n\treturn;\n\n    set_qf_ll_list(NULL, &argvars[0], &argvars[1], &argvars[2], rettv);\n}\n#endif\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n/*\n * search.c: code for normal mode searching commands\n */\n\n#include \"vim.h\"\n\n#ifdef FEAT_EVAL\nstatic void set_vv_searchforward(void);\nstatic int first_submatch(regmmatch_T *rp);\n#endif\n#ifdef FEAT_FIND_ID\nstatic void show_pat_in_path(char_u *, int,\n\t\t\t\t\t int, int, FILE *, linenr_T *, long);\n#endif\n\ntypedef struct searchstat\n{\n    int\t    cur;\t    // current position of found words\n    int\t    cnt;\t    // total count of found words\n    int\t    exact_match;    // TRUE if matched exactly on specified position\n    int\t    incomplete;\t    // 0: search was fully completed\n\t\t\t    // 1: recomputing was timed out\n\t\t\t    // 2: max count exceeded\n    int\t    last_maxcount;  // the max count of the last search\n} searchstat_T;\n\nstatic void cmdline_search_stat(int dirc, pos_T *pos, pos_T *cursor_pos, int show_top_bot_msg, char_u *msgbuf, int recompute, int maxcount, long timeout);\nstatic void update_search_stat(int dirc, pos_T *pos, pos_T *cursor_pos, searchstat_T *stat, int recompute, int maxcount, long timeout);\n\n#define SEARCH_STAT_DEF_TIMEOUT 40L\n#define SEARCH_STAT_DEF_MAX_COUNT 99\n#define SEARCH_STAT_BUF_LEN 12\n\n/*\n * This file contains various searching-related routines. These fall into\n * three groups:\n * 1. string searches (for /, ?, n, and N)\n * 2. character searches within a single line (for f, F, t, T, etc)\n * 3. \"other\" kinds of searches like the '%' command, and 'word' searches.\n */\n\n/*\n * String searches\n *\n * The string search functions are divided into two levels:\n * lowest:  searchit(); uses an pos_T for starting position and found match.\n * Highest: do_search(); uses curwin->w_cursor; calls searchit().\n *\n * The last search pattern is remembered for repeating the same search.\n * This pattern is shared between the :g, :s, ? and / commands.\n * This is in search_regcomp().\n *\n * The actual string matching is done using a heavily modified version of\n * Henry Spencer's regular expression library.  See regexp.c.\n */\n\n/*\n * Two search patterns are remembered: One for the :substitute command and\n * one for other searches.  last_idx points to the one that was used the last\n * time.\n */\nstatic spat_T spats[2] =\n{\n    {NULL, TRUE, FALSE, {'/', 0, 0, 0L}},\t// last used search pat\n    {NULL, TRUE, FALSE, {'/', 0, 0, 0L}}\t// last used substitute pat\n};\n\nstatic int last_idx = 0;\t// index in spats[] for RE_LAST\n\nstatic char_u lastc[2] = {NUL, NUL};\t// last character searched for\nstatic int lastcdir = FORWARD;\t\t// last direction of character search\nstatic int last_t_cmd = TRUE;\t\t// last search t_cmd\nstatic char_u\tlastc_bytes[MB_MAXBYTES + 1];\nstatic int\tlastc_bytelen = 1;\t// >1 for multi-byte char\n\n// copy of spats[], for keeping the search patterns while executing autocmds\nstatic spat_T\t    saved_spats[2];\nstatic char_u\t    *saved_mr_pattern = NULL;\n# ifdef FEAT_SEARCH_EXTRA\nstatic int\t    saved_spats_last_idx = 0;\nstatic int\t    saved_spats_no_hlsearch = 0;\n# endif\n\n// allocated copy of pattern used by search_regcomp()\nstatic char_u\t    *mr_pattern = NULL;\n\n#ifdef FEAT_FIND_ID\n/*\n * Type used by find_pattern_in_path() to remember which included files have\n * been searched already.\n */\ntypedef struct SearchedFile\n{\n    FILE\t*fp;\t\t// File pointer\n    char_u\t*name;\t\t// Full name of file\n    linenr_T\tlnum;\t\t// Line we were up to in file\n    int\t\tmatched;\t// Found a match in this file\n} SearchedFile;\n#endif\n\n/*\n * translate search pattern for vim_regcomp()\n *\n * pat_save == RE_SEARCH: save pat in spats[RE_SEARCH].pat (normal search cmd)\n * pat_save == RE_SUBST: save pat in spats[RE_SUBST].pat (:substitute command)\n * pat_save == RE_BOTH: save pat in both patterns (:global command)\n * pat_use  == RE_SEARCH: use previous search pattern if \"pat\" is NULL\n * pat_use  == RE_SUBST: use previous substitute pattern if \"pat\" is NULL\n * pat_use  == RE_LAST: use last used pattern if \"pat\" is NULL\n * options & SEARCH_HIS: put search string in history\n * options & SEARCH_KEEP: keep previous search pattern\n *\n * returns FAIL if failed, OK otherwise.\n */\n    int\nsearch_regcomp(\n    char_u\t*pat,\n    char_u\t**used_pat,\n    int\t\tpat_save,\n    int\t\tpat_use,\n    int\t\toptions,\n    regmmatch_T\t*regmatch)\t// return: pattern and ignore-case flag\n{\n    int\t\tmagic;\n    int\t\ti;\n\n    rc_did_emsg = FALSE;\n    magic = magic_isset();\n\n    /*\n     * If no pattern given, use a previously defined pattern.\n     */\n    if (pat == NULL || *pat == NUL)\n    {\n\tif (pat_use == RE_LAST)\n\t    i = last_idx;\n\telse\n\t    i = pat_use;\n\tif (spats[i].pat == NULL)\t// pattern was never defined\n\t{\n\t    if (pat_use == RE_SUBST)\n\t\temsg(_(e_no_previous_substitute_regular_expression));\n\t    else\n\t\temsg(_(e_no_previous_regular_expression));\n\t    rc_did_emsg = TRUE;\n\t    return FAIL;\n\t}\n\tpat = spats[i].pat;\n\tmagic = spats[i].magic;\n\tno_smartcase = spats[i].no_scs;\n    }\n    else if (options & SEARCH_HIS)\t// put new pattern in history\n\tadd_to_history(HIST_SEARCH, pat, TRUE, NUL);\n\n    if (used_pat)\n\t*used_pat = pat;\n\n    vim_free(mr_pattern);\n#ifdef FEAT_RIGHTLEFT\n    if (curwin->w_p_rl && *curwin->w_p_rlc == 's')\n\tmr_pattern = reverse_text(pat);\n    else\n#endif\n\tmr_pattern = vim_strsave(pat);\n\n    /*\n     * Save the currently used pattern in the appropriate place,\n     * unless the pattern should not be remembered.\n     */\n    if (!(options & SEARCH_KEEP)\n\t\t\t       && (cmdmod.cmod_flags & CMOD_KEEPPATTERNS) == 0)\n    {\n\t// search or global command\n\tif (pat_save == RE_SEARCH || pat_save == RE_BOTH)\n\t    save_re_pat(RE_SEARCH, pat, magic);\n\t// substitute or global command\n\tif (pat_save == RE_SUBST || pat_save == RE_BOTH)\n\t    save_re_pat(RE_SUBST, pat, magic);\n    }\n\n    regmatch->rmm_ic = ignorecase(pat);\n    regmatch->rmm_maxcol = 0;\n    regmatch->regprog = vim_regcomp(pat, magic ? RE_MAGIC : 0);\n    if (regmatch->regprog == NULL)\n\treturn FAIL;\n    return OK;\n}\n\n/*\n * Get search pattern used by search_regcomp().\n */\n    char_u *\nget_search_pat(void)\n{\n    return mr_pattern;\n}\n\n#if defined(FEAT_RIGHTLEFT) || defined(PROTO)\n/*\n * Reverse text into allocated memory.\n * Returns the allocated string, NULL when out of memory.\n */\n    char_u *\nreverse_text(char_u *s)\n{\n    unsigned\tlen;\n    unsigned\ts_i, rev_i;\n    char_u\t*rev;\n\n    /*\n     * Reverse the pattern.\n     */\n    len = (unsigned)STRLEN(s);\n    rev = alloc(len + 1);\n    if (rev == NULL)\n\treturn NULL;\n\n    rev_i = len;\n    for (s_i = 0; s_i < len; ++s_i)\n    {\n\tif (has_mbyte)\n\t{\n\t    int\tmb_len;\n\n\t    mb_len = (*mb_ptr2len)(s + s_i);\n\t    rev_i -= mb_len;\n\t    mch_memmove(rev + rev_i, s + s_i, mb_len);\n\t    s_i += mb_len - 1;\n\t}\n\telse\n\t    rev[--rev_i] = s[s_i];\n\n    }\n    rev[len] = NUL;\n    return rev;\n}\n#endif\n\n    void\nsave_re_pat(int idx, char_u *pat, int magic)\n{\n    if (spats[idx].pat == pat)\n\treturn;\n\n    vim_free(spats[idx].pat);\n    spats[idx].pat = vim_strsave(pat);\n    spats[idx].magic = magic;\n    spats[idx].no_scs = no_smartcase;\n    last_idx = idx;\n#ifdef FEAT_SEARCH_EXTRA\n    // If 'hlsearch' set and search pat changed: need redraw.\n    if (p_hls)\n\tredraw_all_later(UPD_SOME_VALID);\n    set_no_hlsearch(FALSE);\n#endif\n}\n\n/*\n * Save the search patterns, so they can be restored later.\n * Used before/after executing autocommands and user functions.\n */\nstatic int save_level = 0;\n\n    void\nsave_search_patterns(void)\n{\n    if (save_level++ != 0)\n\treturn;\n\n    saved_spats[0] = spats[0];\n    if (spats[0].pat != NULL)\n\tsaved_spats[0].pat = vim_strsave(spats[0].pat);\n    saved_spats[1] = spats[1];\n    if (spats[1].pat != NULL)\n\tsaved_spats[1].pat = vim_strsave(spats[1].pat);\n    if (mr_pattern == NULL)\n\tsaved_mr_pattern = NULL;\n    else\n\tsaved_mr_pattern = vim_strsave(mr_pattern);\n#ifdef FEAT_SEARCH_EXTRA\n    saved_spats_last_idx = last_idx;\n    saved_spats_no_hlsearch = no_hlsearch;\n#endif\n}\n\n    void\nrestore_search_patterns(void)\n{\n    if (--save_level != 0)\n\treturn;\n\n    vim_free(spats[0].pat);\n    spats[0] = saved_spats[0];\n#if defined(FEAT_EVAL)\n    set_vv_searchforward();\n#endif\n    vim_free(spats[1].pat);\n    spats[1] = saved_spats[1];\n    vim_free(mr_pattern);\n    mr_pattern = saved_mr_pattern;\n#ifdef FEAT_SEARCH_EXTRA\n    last_idx = saved_spats_last_idx;\n    set_no_hlsearch(saved_spats_no_hlsearch);\n#endif\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_search_patterns(void)\n{\n    vim_free(spats[0].pat);\n    vim_free(spats[1].pat);\n    VIM_CLEAR(mr_pattern);\n}\n#endif\n\n#ifdef FEAT_SEARCH_EXTRA\n// copy of spats[RE_SEARCH], for keeping the search patterns while incremental\n// searching\nstatic spat_T\t    saved_last_search_spat;\nstatic int\t    did_save_last_search_spat = 0;\nstatic int\t    saved_last_idx = 0;\nstatic int\t    saved_no_hlsearch = 0;\nstatic int\t    saved_search_match_endcol;\nstatic int\t    saved_search_match_lines;\n\n/*\n * Save and restore the search pattern for incremental highlight search\n * feature.\n *\n * It's similar to but different from save_search_patterns() and\n * restore_search_patterns(), because the search pattern must be restored when\n * canceling incremental searching even if it's called inside user functions.\n */\n    void\nsave_last_search_pattern(void)\n{\n    if (++did_save_last_search_spat != 1)\n\t// nested call, nothing to do\n\treturn;\n\n    saved_last_search_spat = spats[RE_SEARCH];\n    if (spats[RE_SEARCH].pat != NULL)\n\tsaved_last_search_spat.pat = vim_strsave(spats[RE_SEARCH].pat);\n    saved_last_idx = last_idx;\n    saved_no_hlsearch = no_hlsearch;\n}\n\n    void\nrestore_last_search_pattern(void)\n{\n    if (--did_save_last_search_spat > 0)\n\t// nested call, nothing to do\n\treturn;\n    if (did_save_last_search_spat != 0)\n    {\n\tiemsg(\"restore_last_search_pattern() called more often than save_last_search_pattern()\");\n\treturn;\n    }\n\n    vim_free(spats[RE_SEARCH].pat);\n    spats[RE_SEARCH] = saved_last_search_spat;\n    saved_last_search_spat.pat = NULL;\n# if defined(FEAT_EVAL)\n    set_vv_searchforward();\n# endif\n    last_idx = saved_last_idx;\n    set_no_hlsearch(saved_no_hlsearch);\n}\n\n/*\n * Save and restore the incsearch highlighting variables.\n * This is required so that calling searchcount() at does not invalidate the\n * incsearch highlighting.\n */\n    static void\nsave_incsearch_state(void)\n{\n    saved_search_match_endcol = search_match_endcol;\n    saved_search_match_lines  = search_match_lines;\n}\n\n    static void\nrestore_incsearch_state(void)\n{\n    search_match_endcol = saved_search_match_endcol;\n    search_match_lines  = saved_search_match_lines;\n}\n\n    char_u *\nlast_search_pattern(void)\n{\n    return spats[RE_SEARCH].pat;\n}\n#endif\n\n/*\n * Return TRUE when case should be ignored for search pattern \"pat\".\n * Uses the 'ignorecase' and 'smartcase' options.\n */\n    int\nignorecase(char_u *pat)\n{\n    return ignorecase_opt(pat, p_ic, p_scs);\n}\n\n/*\n * As ignorecase() put pass the \"ic\" and \"scs\" flags.\n */\n    int\nignorecase_opt(char_u *pat, int ic_in, int scs)\n{\n    int\t\tic = ic_in;\n\n    if (ic && !no_smartcase && scs\n\t\t\t    && !(ctrl_x_mode_not_default() && curbuf->b_p_inf))\n\tic = !pat_has_uppercase(pat);\n    no_smartcase = FALSE;\n\n    return ic;\n}\n\n/*\n * Return TRUE if pattern \"pat\" has an uppercase character.\n */\n    int\npat_has_uppercase(char_u *pat)\n{\n    char_u *p = pat;\n    magic_T magic_val = MAGIC_ON;\n\n    // get the magicness of the pattern\n    (void)skip_regexp_ex(pat, NUL, magic_isset(), NULL, NULL, &magic_val);\n\n    while (*p != NUL)\n    {\n\tint\t\tl;\n\n\tif (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)\n\t{\n\t    if (enc_utf8 && utf_isupper(utf_ptr2char(p)))\n\t\treturn TRUE;\n\t    p += l;\n\t}\n\telse if (*p == '\\\\' && magic_val <= MAGIC_ON)\n\t{\n\t    if (p[1] == '_' && p[2] != NUL)  // skip \"\\_X\"\n\t\tp += 3;\n\t    else if (p[1] == '%' && p[2] != NUL)  // skip \"\\%X\"\n\t\tp += 3;\n\t    else if (p[1] != NUL)  // skip \"\\X\"\n\t\tp += 2;\n\t    else\n\t\tp += 1;\n\t}\n\telse if ((*p == '%' || *p == '_') && magic_val == MAGIC_ALL)\n\t{\n\t    if (p[1] != NUL)  // skip \"_X\" and %X\n\t\tp += 2;\n\t    else\n\t\tp++;\n\t}\n\telse if (MB_ISUPPER(*p))\n\t    return TRUE;\n\telse\n\t    ++p;\n    }\n    return FALSE;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n    char_u *\nlast_csearch(void)\n{\n    return lastc_bytes;\n}\n\n    int\nlast_csearch_forward(void)\n{\n    return lastcdir == FORWARD;\n}\n\n    int\nlast_csearch_until(void)\n{\n    return last_t_cmd == TRUE;\n}\n\n    void\nset_last_csearch(int c, char_u *s UNUSED, int len UNUSED)\n{\n    *lastc = c;\n    lastc_bytelen = len;\n    if (len)\n\tmemcpy(lastc_bytes, s, len);\n    else\n\tCLEAR_FIELD(lastc_bytes);\n}\n#endif\n\n    void\nset_csearch_direction(int cdir)\n{\n    lastcdir = cdir;\n}\n\n    void\nset_csearch_until(int t_cmd)\n{\n    last_t_cmd = t_cmd;\n}\n\n    char_u *\nlast_search_pat(void)\n{\n    return spats[last_idx].pat;\n}\n\n/*\n * Reset search direction to forward.  For \"gd\" and \"gD\" commands.\n */\n    void\nreset_search_dir(void)\n{\n    spats[0].off.dir = '/';\n#if defined(FEAT_EVAL)\n    set_vv_searchforward();\n#endif\n}\n\n#if defined(FEAT_EVAL) || defined(FEAT_VIMINFO)\n/*\n * Set the last search pattern.  For \":let @/ =\" and viminfo.\n * Also set the saved search pattern, so that this works in an autocommand.\n */\n    void\nset_last_search_pat(\n    char_u\t*s,\n    int\t\tidx,\n    int\t\tmagic,\n    int\t\tsetlast)\n{\n    vim_free(spats[idx].pat);\n    // An empty string means that nothing should be matched.\n    if (*s == NUL)\n\tspats[idx].pat = NULL;\n    else\n\tspats[idx].pat = vim_strsave(s);\n    spats[idx].magic = magic;\n    spats[idx].no_scs = FALSE;\n    spats[idx].off.dir = '/';\n#if defined(FEAT_EVAL)\n    set_vv_searchforward();\n#endif\n    spats[idx].off.line = FALSE;\n    spats[idx].off.end = FALSE;\n    spats[idx].off.off = 0;\n    if (setlast)\n\tlast_idx = idx;\n    if (save_level)\n    {\n\tvim_free(saved_spats[idx].pat);\n\tsaved_spats[idx] = spats[0];\n\tif (spats[idx].pat == NULL)\n\t    saved_spats[idx].pat = NULL;\n\telse\n\t    saved_spats[idx].pat = vim_strsave(spats[idx].pat);\n# ifdef FEAT_SEARCH_EXTRA\n\tsaved_spats_last_idx = last_idx;\n# endif\n    }\n# ifdef FEAT_SEARCH_EXTRA\n    // If 'hlsearch' set and search pat changed: need redraw.\n    if (p_hls && idx == last_idx && !no_hlsearch)\n\tredraw_all_later(UPD_SOME_VALID);\n# endif\n}\n#endif\n\n#ifdef FEAT_SEARCH_EXTRA\n/*\n * Get a regexp program for the last used search pattern.\n * This is used for highlighting all matches in a window.\n * Values returned in regmatch->regprog and regmatch->rmm_ic.\n */\n    void\nlast_pat_prog(regmmatch_T *regmatch)\n{\n    if (spats[last_idx].pat == NULL)\n    {\n\tregmatch->regprog = NULL;\n\treturn;\n    }\n    ++emsg_off;\t\t// So it doesn't beep if bad expr\n    (void)search_regcomp((char_u *)\"\", NULL, 0, last_idx, SEARCH_KEEP, regmatch);\n    --emsg_off;\n}\n#endif\n\n/*\n * Lowest level search function.\n * Search for 'count'th occurrence of pattern \"pat\" in direction \"dir\".\n * Start at position \"pos\" and return the found position in \"pos\".\n *\n * if (options & SEARCH_MSG) == 0 don't give any messages\n * if (options & SEARCH_MSG) == SEARCH_NFMSG don't give 'notfound' messages\n * if (options & SEARCH_MSG) == SEARCH_MSG give all messages\n * if (options & SEARCH_HIS) put search pattern in history\n * if (options & SEARCH_END) return position at end of match\n * if (options & SEARCH_START) accept match at pos itself\n * if (options & SEARCH_KEEP) keep previous search pattern\n * if (options & SEARCH_FOLD) match only once in a closed fold\n * if (options & SEARCH_PEEK) check for typed char, cancel search\n * if (options & SEARCH_COL) start at pos->col instead of zero\n *\n * Return FAIL (zero) for failure, non-zero for success.\n * When FEAT_EVAL is defined, returns the index of the first matching\n * subpattern plus one; one if there was none.\n */\n    int\nsearchit(\n    win_T\t*win,\t\t// window to search in; can be NULL for a\n\t\t\t\t// buffer without a window!\n    buf_T\t*buf,\n    pos_T\t*pos,\n    pos_T\t*end_pos,\t// set to end of the match, unless NULL\n    int\t\tdir,\n    char_u\t*pat,\n    long\tcount,\n    int\t\toptions,\n    int\t\tpat_use,\t// which pattern to use when \"pat\" is empty\n    searchit_arg_T *extra_arg)\t// optional extra arguments, can be NULL\n{\n    int\t\tfound;\n    linenr_T\tlnum;\t\t// no init to shut up Apollo cc\n    colnr_T\tcol;\n    regmmatch_T\tregmatch;\n    char_u\t*ptr;\n    colnr_T\tmatchcol;\n    lpos_T\tendpos;\n    lpos_T\tmatchpos;\n    int\t\tloop;\n    pos_T\tstart_pos;\n    int\t\tat_first_line;\n    int\t\textra_col;\n    int\t\tstart_char_len;\n    int\t\tmatch_ok;\n    long\tnmatched;\n    int\t\tsubmatch = 0;\n    int\t\tfirst_match = TRUE;\n    int\t\tcalled_emsg_before = called_emsg;\n#ifdef FEAT_SEARCH_EXTRA\n    int\t\tbreak_loop = FALSE;\n#endif\n    linenr_T\tstop_lnum = 0;\t// stop after this line number when != 0\n    int\t\tunused_timeout_flag = FALSE;\n    int\t\t*timed_out = &unused_timeout_flag;  // set when timed out.\n\n    if (search_regcomp(pat, NULL, RE_SEARCH, pat_use,\n\t\t   (options & (SEARCH_HIS + SEARCH_KEEP)), &regmatch) == FAIL)\n    {\n\tif ((options & SEARCH_MSG) && !rc_did_emsg)\n\t    semsg(_(e_invalid_search_string_str), mr_pattern);\n\treturn FAIL;\n    }\n\n    if (extra_arg != NULL)\n    {\n\tstop_lnum = extra_arg->sa_stop_lnum;\n#ifdef FEAT_RELTIME\n\tif (extra_arg->sa_tm > 0)\n\t    init_regexp_timeout(extra_arg->sa_tm);\n\t// Also set the pointer when sa_tm is zero, the caller may have set the\n\t// timeout.\n\ttimed_out = &extra_arg->sa_timed_out;\n#endif\n    }\n\n    /*\n     * find the string\n     */\n    do\t// loop for count\n    {\n\t// When not accepting a match at the start position set \"extra_col\" to\n\t// a non-zero value.  Don't do that when starting at MAXCOL, since\n\t// MAXCOL + 1 is zero.\n\tif (pos->col == MAXCOL)\n\t    start_char_len = 0;\n\t// Watch out for the \"col\" being MAXCOL - 2, used in a closed fold.\n\telse if (has_mbyte\n\t\t    && pos->lnum >= 1 && pos->lnum <= buf->b_ml.ml_line_count\n\t\t\t\t\t\t    && pos->col < MAXCOL - 2)\n\t{\n\t    ptr = ml_get_buf(buf, pos->lnum, FALSE);\n\t    if ((int)STRLEN(ptr) <= pos->col)\n\t\tstart_char_len = 1;\n\t    else\n\t\tstart_char_len = (*mb_ptr2len)(ptr + pos->col);\n\t}\n\telse\n\t    start_char_len = 1;\n\tif (dir == FORWARD)\n\t{\n\t    if (options & SEARCH_START)\n\t\textra_col = 0;\n\t    else\n\t\textra_col = start_char_len;\n\t}\n\telse\n\t{\n\t    if (options & SEARCH_START)\n\t\textra_col = start_char_len;\n\t    else\n\t\textra_col = 0;\n\t}\n\n\tstart_pos = *pos;\t// remember start pos for detecting no match\n\tfound = 0;\t\t// default: not found\n\tat_first_line = TRUE;\t// default: start in first line\n\tif (pos->lnum == 0)\t// correct lnum for when starting in line 0\n\t{\n\t    pos->lnum = 1;\n\t    pos->col = 0;\n\t    at_first_line = FALSE;  // not in first line now\n\t}\n\n\t/*\n\t * Start searching in current line, unless searching backwards and\n\t * we're in column 0.\n\t * If we are searching backwards, in column 0, and not including the\n\t * current position, gain some efficiency by skipping back a line.\n\t * Otherwise begin the search in the current line.\n\t */\n\tif (dir == BACKWARD && start_pos.col == 0\n\t\t\t\t\t     && (options & SEARCH_START) == 0)\n\t{\n\t    lnum = pos->lnum - 1;\n\t    at_first_line = FALSE;\n\t}\n\telse\n\t    lnum = pos->lnum;\n\n\tfor (loop = 0; loop <= 1; ++loop)   // loop twice if 'wrapscan' set\n\t{\n\t    for ( ; lnum > 0 && lnum <= buf->b_ml.ml_line_count;\n\t\t\t\t\t   lnum += dir, at_first_line = FALSE)\n\t    {\n\t\t// Stop after checking \"stop_lnum\", if it's set.\n\t\tif (stop_lnum != 0 && (dir == FORWARD\n\t\t\t\t       ? lnum > stop_lnum : lnum < stop_lnum))\n\t\t    break;\n\t\t// Stop after passing the time limit.\n\t\tif (*timed_out)\n\t\t    break;\n\n\t\t/*\n\t\t * Look for a match somewhere in line \"lnum\".\n\t\t */\n\t\tcol = at_first_line && (options & SEARCH_COL) ? pos->col\n\t\t\t\t\t\t\t\t : (colnr_T)0;\n\t\tnmatched = vim_regexec_multi(&regmatch, win, buf,\n\t\t\t\t\t\t\t lnum, col, timed_out);\n\t\t// vim_regexec_multi() may clear \"regprog\"\n\t\tif (regmatch.regprog == NULL)\n\t\t    break;\n\t\t// Abort searching on an error (e.g., out of stack).\n\t\tif (called_emsg > called_emsg_before || *timed_out)\n\t\t    break;\n\t\tif (nmatched > 0)\n\t\t{\n\t\t    // match may actually be in another line when using \\zs\n\t\t    matchpos = regmatch.startpos[0];\n\t\t    endpos = regmatch.endpos[0];\n#ifdef FEAT_EVAL\n\t\t    submatch = first_submatch(&regmatch);\n#endif\n\t\t    // \"lnum\" may be past end of buffer for \"\\n\\zs\".\n\t\t    if (lnum + matchpos.lnum > buf->b_ml.ml_line_count)\n\t\t\tptr = (char_u *)\"\";\n\t\t    else\n\t\t\tptr = ml_get_buf(buf, lnum + matchpos.lnum, FALSE);\n\n\t\t    /*\n\t\t     * Forward search in the first line: match should be after\n\t\t     * the start position. If not, continue at the end of the\n\t\t     * match (this is vi compatible) or on the next char.\n\t\t     */\n\t\t    if (dir == FORWARD && at_first_line)\n\t\t    {\n\t\t\tmatch_ok = TRUE;\n\n\t\t\t/*\n\t\t\t * When the match starts in a next line it's certainly\n\t\t\t * past the start position.\n\t\t\t * When match lands on a NUL the cursor will be put\n\t\t\t * one back afterwards, compare with that position,\n\t\t\t * otherwise \"/$\" will get stuck on end of line.\n\t\t\t */\n\t\t\twhile (matchpos.lnum == 0\n\t\t\t\t&& ((options & SEARCH_END) && first_match\n\t\t\t\t    ?  (nmatched == 1\n\t\t\t\t\t&& (int)endpos.col - 1\n\t\t\t\t\t     < (int)start_pos.col + extra_col)\n\t\t\t\t    : ((int)matchpos.col\n\t\t\t\t\t\t  - (ptr[matchpos.col] == NUL)\n\t\t\t\t\t    < (int)start_pos.col + extra_col)))\n\t\t\t{\n\t\t\t    /*\n\t\t\t     * If vi-compatible searching, continue at the end\n\t\t\t     * of the match, otherwise continue one position\n\t\t\t     * forward.\n\t\t\t     */\n\t\t\t    if (vim_strchr(p_cpo, CPO_SEARCH) != NULL)\n\t\t\t    {\n\t\t\t\tif (nmatched > 1)\n\t\t\t\t{\n\t\t\t\t    // end is in next line, thus no match in\n\t\t\t\t    // this line\n\t\t\t\t    match_ok = FALSE;\n\t\t\t\t    break;\n\t\t\t\t}\n\t\t\t\tmatchcol = endpos.col;\n\t\t\t\t// for empty match: advance one char\n\t\t\t\tif (matchcol == matchpos.col\n\t\t\t\t\t\t      && ptr[matchcol] != NUL)\n\t\t\t\t{\n\t\t\t\t    if (has_mbyte)\n\t\t\t\t\tmatchcol +=\n\t\t\t\t\t  (*mb_ptr2len)(ptr + matchcol);\n\t\t\t\t    else\n\t\t\t\t\t++matchcol;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\t// Advance \"matchcol\" to the next character.\n\t\t\t\t// This uses rmm_matchcol, the actual start of\n\t\t\t\t// the match, ignoring \"\\zs\".\n\t\t\t\tmatchcol = regmatch.rmm_matchcol;\n\t\t\t\tif (ptr[matchcol] != NUL)\n\t\t\t\t{\n\t\t\t\t    if (has_mbyte)\n\t\t\t\t\tmatchcol += (*mb_ptr2len)(ptr\n\t\t\t\t\t\t\t\t  + matchcol);\n\t\t\t\t    else\n\t\t\t\t\t++matchcol;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    if (matchcol == 0 && (options & SEARCH_START))\n\t\t\t\tbreak;\n\t\t\t    if (ptr[matchcol] == NUL\n\t\t\t\t    || (nmatched = vim_regexec_multi(&regmatch,\n\t\t\t\t\t      win, buf, lnum + matchpos.lnum,\n\t\t\t\t\t      matchcol, timed_out)) == 0)\n\t\t\t    {\n\t\t\t\tmatch_ok = FALSE;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    // vim_regexec_multi() may clear \"regprog\"\n\t\t\t    if (regmatch.regprog == NULL)\n\t\t\t\tbreak;\n\t\t\t    matchpos = regmatch.startpos[0];\n\t\t\t    endpos = regmatch.endpos[0];\n# ifdef FEAT_EVAL\n\t\t\t    submatch = first_submatch(&regmatch);\n# endif\n\n\t\t\t    // Need to get the line pointer again, a\n\t\t\t    // multi-line search may have made it invalid.\n\t\t\t    ptr = ml_get_buf(buf, lnum + matchpos.lnum, FALSE);\n\t\t\t}\n\t\t\tif (!match_ok)\n\t\t\t    continue;\n\t\t    }\n\t\t    if (dir == BACKWARD)\n\t\t    {\n\t\t\t/*\n\t\t\t * Now, if there are multiple matches on this line,\n\t\t\t * we have to get the last one. Or the last one before\n\t\t\t * the cursor, if we're on that line.\n\t\t\t * When putting the new cursor at the end, compare\n\t\t\t * relative to the end of the match.\n\t\t\t */\n\t\t\tmatch_ok = FALSE;\n\t\t\tfor (;;)\n\t\t\t{\n\t\t\t    // Remember a position that is before the start\n\t\t\t    // position, we use it if it's the last match in\n\t\t\t    // the line.  Always accept a position after\n\t\t\t    // wrapping around.\n\t\t\t    if (loop\n\t\t\t\t|| ((options & SEARCH_END)\n\t\t\t\t    ? (lnum + regmatch.endpos[0].lnum\n\t\t\t\t\t\t\t      < start_pos.lnum\n\t\t\t\t\t|| (lnum + regmatch.endpos[0].lnum\n\t\t\t\t\t\t\t     == start_pos.lnum\n\t\t\t\t\t     && (int)regmatch.endpos[0].col - 1\n\t\t\t\t\t\t\t< (int)start_pos.col\n\t\t\t\t\t\t\t\t+ extra_col))\n\t\t\t\t    : (lnum + regmatch.startpos[0].lnum\n\t\t\t\t\t\t\t      < start_pos.lnum\n\t\t\t\t\t|| (lnum + regmatch.startpos[0].lnum\n\t\t\t\t\t\t\t     == start_pos.lnum\n\t\t\t\t\t     && (int)regmatch.startpos[0].col\n\t\t\t\t\t\t      < (int)start_pos.col\n\t\t\t\t\t\t\t      + extra_col))))\n\t\t\t    {\n\t\t\t\tmatch_ok = TRUE;\n\t\t\t\tmatchpos = regmatch.startpos[0];\n\t\t\t\tendpos = regmatch.endpos[0];\n# ifdef FEAT_EVAL\n\t\t\t\tsubmatch = first_submatch(&regmatch);\n# endif\n\t\t\t    }\n\t\t\t    else\n\t\t\t\tbreak;\n\n\t\t\t    /*\n\t\t\t     * We found a valid match, now check if there is\n\t\t\t     * another one after it.\n\t\t\t     * If vi-compatible searching, continue at the end\n\t\t\t     * of the match, otherwise continue one position\n\t\t\t     * forward.\n\t\t\t     */\n\t\t\t    if (vim_strchr(p_cpo, CPO_SEARCH) != NULL)\n\t\t\t    {\n\t\t\t\tif (nmatched > 1)\n\t\t\t\t    break;\n\t\t\t\tmatchcol = endpos.col;\n\t\t\t\t// for empty match: advance one char\n\t\t\t\tif (matchcol == matchpos.col\n\t\t\t\t\t\t      && ptr[matchcol] != NUL)\n\t\t\t\t{\n\t\t\t\t    if (has_mbyte)\n\t\t\t\t\tmatchcol +=\n\t\t\t\t\t  (*mb_ptr2len)(ptr + matchcol);\n\t\t\t\t    else\n\t\t\t\t\t++matchcol;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\t// Stop when the match is in a next line.\n\t\t\t\tif (matchpos.lnum > 0)\n\t\t\t\t    break;\n\t\t\t\tmatchcol = matchpos.col;\n\t\t\t\tif (ptr[matchcol] != NUL)\n\t\t\t\t{\n\t\t\t\t    if (has_mbyte)\n\t\t\t\t\tmatchcol +=\n\t\t\t\t\t  (*mb_ptr2len)(ptr + matchcol);\n\t\t\t\t    else\n\t\t\t\t\t++matchcol;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t    if (ptr[matchcol] == NUL\n\t\t\t\t    || (nmatched = vim_regexec_multi(&regmatch,\n\t\t\t\t\t      win, buf, lnum + matchpos.lnum,\n\t\t\t\t\t      matchcol, timed_out)) == 0)\n\t\t\t    {\n\t\t\t\t// If the search timed out, we did find a match\n\t\t\t\t// but it might be the wrong one, so that's not\n\t\t\t\t// OK.\n\t\t\t\tif (*timed_out)\n\t\t\t\t    match_ok = FALSE;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t    // vim_regexec_multi() may clear \"regprog\"\n\t\t\t    if (regmatch.regprog == NULL)\n\t\t\t\tbreak;\n\n\t\t\t    // Need to get the line pointer again, a\n\t\t\t    // multi-line search may have made it invalid.\n\t\t\t    ptr = ml_get_buf(buf, lnum + matchpos.lnum, FALSE);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * If there is only a match after the cursor, skip\n\t\t\t * this match.\n\t\t\t */\n\t\t\tif (!match_ok)\n\t\t\t    continue;\n\t\t    }\n\n\t\t    // With the SEARCH_END option move to the last character\n\t\t    // of the match.  Don't do it for an empty match, end\n\t\t    // should be same as start then.\n\t\t    if ((options & SEARCH_END) && !(options & SEARCH_NOOF)\n\t\t\t    && !(matchpos.lnum == endpos.lnum\n\t\t\t\t&& matchpos.col == endpos.col))\n\t\t    {\n\t\t\t// For a match in the first column, set the position\n\t\t\t// on the NUL in the previous line.\n\t\t\tpos->lnum = lnum + endpos.lnum;\n\t\t\tpos->col = endpos.col;\n\t\t\tif (endpos.col == 0)\n\t\t\t{\n\t\t\t    if (pos->lnum > 1)  // just in case\n\t\t\t    {\n\t\t\t\t--pos->lnum;\n\t\t\t\tpos->col = (colnr_T)STRLEN(ml_get_buf(buf,\n\t\t\t\t\t\t\t   pos->lnum, FALSE));\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    --pos->col;\n\t\t\t    if (has_mbyte\n\t\t\t\t    && pos->lnum <= buf->b_ml.ml_line_count)\n\t\t\t    {\n\t\t\t\tptr = ml_get_buf(buf, pos->lnum, FALSE);\n\t\t\t\tpos->col -= (*mb_head_off)(ptr, ptr + pos->col);\n\t\t\t    }\n\t\t\t}\n\t\t\tif (end_pos != NULL)\n\t\t\t{\n\t\t\t    end_pos->lnum = lnum + matchpos.lnum;\n\t\t\t    end_pos->col = matchpos.col;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tpos->lnum = lnum + matchpos.lnum;\n\t\t\tpos->col = matchpos.col;\n\t\t\tif (end_pos != NULL)\n\t\t\t{\n\t\t\t    end_pos->lnum = lnum + endpos.lnum;\n\t\t\t    end_pos->col = endpos.col;\n\t\t\t}\n\t\t    }\n\t\t    pos->coladd = 0;\n\t\t    if (end_pos != NULL)\n\t\t\tend_pos->coladd = 0;\n\t\t    found = 1;\n\t\t    first_match = FALSE;\n\n\t\t    // Set variables used for 'incsearch' highlighting.\n\t\t    search_match_lines = endpos.lnum - matchpos.lnum;\n\t\t    search_match_endcol = endpos.col;\n\t\t    break;\n\t\t}\n\t\tline_breakcheck();\t// stop if ctrl-C typed\n\t\tif (got_int)\n\t\t    break;\n\n#ifdef FEAT_SEARCH_EXTRA\n\t\t// Cancel searching if a character was typed.  Used for\n\t\t// 'incsearch'.  Don't check too often, that would slowdown\n\t\t// searching too much.\n\t\tif ((options & SEARCH_PEEK)\n\t\t\t&& ((lnum - pos->lnum) & 0x3f) == 0\n\t\t\t&& char_avail())\n\t\t{\n\t\t    break_loop = TRUE;\n\t\t    break;\n\t\t}\n#endif\n\n\t\tif (loop && lnum == start_pos.lnum)\n\t\t    break;\t    // if second loop, stop where started\n\t    }\n\t    at_first_line = FALSE;\n\n\t    // vim_regexec_multi() may clear \"regprog\"\n\t    if (regmatch.regprog == NULL)\n\t\tbreak;\n\n\t    /*\n\t     * Stop the search if wrapscan isn't set, \"stop_lnum\" is\n\t     * specified, after an interrupt, after a match and after looping\n\t     * twice.\n\t     */\n\t    if (!p_ws || stop_lnum != 0 || got_int\n\t\t\t      || called_emsg > called_emsg_before || *timed_out\n#ifdef FEAT_SEARCH_EXTRA\n\t\t\t      || break_loop\n#endif\n\t\t\t      || found || loop)\n\t\tbreak;\n\n\t    /*\n\t     * If 'wrapscan' is set we continue at the other end of the file.\n\t     * If 'shortmess' does not contain 's', we give a message.\n\t     * This message is also remembered in keep_msg for when the screen\n\t     * is redrawn. The keep_msg is cleared whenever another message is\n\t     * written.\n\t     */\n\t    if (dir == BACKWARD)    // start second loop at the other end\n\t\tlnum = buf->b_ml.ml_line_count;\n\t    else\n\t\tlnum = 1;\n\t    if (!shortmess(SHM_SEARCH) && (options & SEARCH_MSG))\n\t\tgive_warning((char_u *)_(dir == BACKWARD\n\t\t\t\t\t  ? top_bot_msg : bot_top_msg), TRUE);\n\t    if (extra_arg != NULL)\n\t\textra_arg->sa_wrapped = TRUE;\n\t}\n\tif (got_int || called_emsg > called_emsg_before || *timed_out\n#ifdef FEAT_SEARCH_EXTRA\n\t\t|| break_loop\n#endif\n\t\t)\n\t    break;\n    }\n    while (--count > 0 && found);   // stop after count matches or no match\n\n#ifdef FEAT_RELTIME\n    if (extra_arg != NULL && extra_arg->sa_tm > 0)\n\tdisable_regexp_timeout();\n#endif\n    vim_regfree(regmatch.regprog);\n\n    if (!found)\t\t    // did not find it\n    {\n\tif (got_int)\n\t    emsg(_(e_interrupted));\n\telse if ((options & SEARCH_MSG) == SEARCH_MSG)\n\t{\n\t    if (p_ws)\n\t\tsemsg(_(e_pattern_not_found_str), mr_pattern);\n\t    else if (lnum == 0)\n\t\tsemsg(_(e_search_hit_top_without_match_for_str), mr_pattern);\n\t    else\n\t\tsemsg(_(e_search_hit_bottom_without_match_for_str), mr_pattern);\n\t}\n\treturn FAIL;\n    }\n\n    // A pattern like \"\\n\\zs\" may go past the last line.\n    if (pos->lnum > buf->b_ml.ml_line_count)\n    {\n\tpos->lnum = buf->b_ml.ml_line_count;\n\tpos->col = (int)STRLEN(ml_get_buf(buf, pos->lnum, FALSE));\n\tif (pos->col > 0)\n\t    --pos->col;\n    }\n\n    return submatch + 1;\n}\n\n#if defined(FEAT_EVAL) || defined(FEAT_PROTO)\n    void\nset_search_direction(int cdir)\n{\n    spats[0].off.dir = cdir;\n}\n\n    static void\nset_vv_searchforward(void)\n{\n    set_vim_var_nr(VV_SEARCHFORWARD, (long)(spats[0].off.dir == '/'));\n}\n\n/*\n * Return the number of the first subpat that matched.\n * Return zero if none of them matched.\n */\n    static int\nfirst_submatch(regmmatch_T *rp)\n{\n    int\t\tsubmatch;\n\n    for (submatch = 1; ; ++submatch)\n    {\n\tif (rp->startpos[submatch].lnum >= 0)\n\t    break;\n\tif (submatch == 9)\n\t{\n\t    submatch = 0;\n\t    break;\n\t}\n    }\n    return submatch;\n}\n#endif\n\n/*\n * Highest level string search function.\n * Search for the 'count'th occurrence of pattern 'pat' in direction 'dirc'\n *\t\t  If 'dirc' is 0: use previous dir.\n *    If 'pat' is NULL or empty : use previous string.\n *    If 'options & SEARCH_REV' : go in reverse of previous dir.\n *    If 'options & SEARCH_ECHO': echo the search command and handle options\n *    If 'options & SEARCH_MSG' : may give error message\n *    If 'options & SEARCH_OPT' : interpret optional flags\n *    If 'options & SEARCH_HIS' : put search pattern in history\n *    If 'options & SEARCH_NOOF': don't add offset to position\n *    If 'options & SEARCH_MARK': set previous context mark\n *    If 'options & SEARCH_KEEP': keep previous search pattern\n *    If 'options & SEARCH_START': accept match at curpos itself\n *    If 'options & SEARCH_PEEK': check for typed char, cancel search\n *\n * Careful: If spats[0].off.line == TRUE and spats[0].off.off == 0 this\n * makes the movement linewise without moving the match position.\n *\n * Return 0 for failure, 1 for found, 2 for found and line offset added.\n */\n    int\ndo_search(\n    oparg_T\t    *oap,\t// can be NULL\n    int\t\t    dirc,\t// '/' or '?'\n    int\t\t    search_delim, // the delimiter for the search, e.g. '%' in\n\t\t\t\t  // s%regex%replacement%\n    char_u\t    *pat,\n    long\t    count,\n    int\t\t    options,\n    searchit_arg_T  *sia)\t// optional arguments or NULL\n{\n    pos_T\t    pos;\t// position of the last match\n    char_u\t    *searchstr;\n    soffset_T\t    old_off;\n    int\t\t    retval;\t// Return value\n    char_u\t    *p;\n    long\t    c;\n    char_u\t    *dircp;\n    char_u\t    *strcopy = NULL;\n    char_u\t    *ps;\n    char_u\t    *msgbuf = NULL;\n    size_t\t    len;\n    int\t\t    has_offset = FALSE;\n\n    /*\n     * A line offset is not remembered, this is vi compatible.\n     */\n    if (spats[0].off.line && vim_strchr(p_cpo, CPO_LINEOFF) != NULL)\n    {\n\tspats[0].off.line = FALSE;\n\tspats[0].off.off = 0;\n    }\n\n    /*\n     * Save the values for when (options & SEARCH_KEEP) is used.\n     * (there is no \"if ()\" around this because gcc wants them initialized)\n     */\n    old_off = spats[0].off;\n\n    pos = curwin->w_cursor;\t// start searching at the cursor position\n\n    /*\n     * Find out the direction of the search.\n     */\n    if (dirc == 0)\n\tdirc = spats[0].off.dir;\n    else\n    {\n\tspats[0].off.dir = dirc;\n#if defined(FEAT_EVAL)\n\tset_vv_searchforward();\n#endif\n    }\n    if (options & SEARCH_REV)\n    {\n#ifdef MSWIN\n\t// There is a bug in the Visual C++ 2.2 compiler which means that\n\t// dirc always ends up being '/'\n\tdirc = (dirc == '/')  ?  '?'  :  '/';\n#else\n\tif (dirc == '/')\n\t    dirc = '?';\n\telse\n\t    dirc = '/';\n#endif\n    }\n\n#ifdef FEAT_FOLDING\n    // If the cursor is in a closed fold, don't find another match in the same\n    // fold.\n    if (dirc == '/')\n    {\n\tif (hasFolding(pos.lnum, NULL, &pos.lnum))\n\t    pos.col = MAXCOL - 2;\t// avoid overflow when adding 1\n    }\n    else\n    {\n\tif (hasFolding(pos.lnum, &pos.lnum, NULL))\n\t    pos.col = 0;\n    }\n#endif\n\n#ifdef FEAT_SEARCH_EXTRA\n    /*\n     * Turn 'hlsearch' highlighting back on.\n     */\n    if (no_hlsearch && !(options & SEARCH_KEEP))\n    {\n\tredraw_all_later(UPD_SOME_VALID);\n\tset_no_hlsearch(FALSE);\n    }\n#endif\n\n    /*\n     * Repeat the search when pattern followed by ';', e.g. \"/foo/;?bar\".\n     */\n    for (;;)\n    {\n\tint\t\tshow_top_bot_msg = FALSE;\n\n\tsearchstr = pat;\n\tdircp = NULL;\n\t\t\t\t\t    // use previous pattern\n\tif (pat == NULL || *pat == NUL || *pat == search_delim)\n\t{\n\t    if (spats[RE_SEARCH].pat == NULL)\t    // no previous pattern\n\t    {\n\t\tsearchstr = spats[RE_SUBST].pat;\n\t\tif (searchstr == NULL)\n\t\t{\n\t\t    emsg(_(e_no_previous_regular_expression));\n\t\t    retval = 0;\n\t\t    goto end_do_search;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t// make search_regcomp() use spats[RE_SEARCH].pat\n\t\tsearchstr = (char_u *)\"\";\n\t    }\n\t}\n\n\tif (pat != NULL && *pat != NUL)\t// look for (new) offset\n\t{\n\t    /*\n\t     * Find end of regular expression.\n\t     * If there is a matching '/' or '?', toss it.\n\t     */\n\t    ps = strcopy;\n\t    p = skip_regexp_ex(pat, search_delim, magic_isset(),\n\t\t\t\t\t\t\t&strcopy, NULL, NULL);\n\t    if (strcopy != ps)\n\t    {\n\t\t// made a copy of \"pat\" to change \"\\?\" to \"?\"\n\t\tsearchcmdlen += (int)(STRLEN(pat) - STRLEN(strcopy));\n\t\tpat = strcopy;\n\t\tsearchstr = strcopy;\n\t    }\n\t    if (*p == search_delim)\n\t    {\n\t\tdircp = p;\t// remember where we put the NUL\n\t\t*p++ = NUL;\n\t    }\n\t    spats[0].off.line = FALSE;\n\t    spats[0].off.end = FALSE;\n\t    spats[0].off.off = 0;\n\t    /*\n\t     * Check for a line offset or a character offset.\n\t     * For get_address (echo off) we don't check for a character\n\t     * offset, because it is meaningless and the 's' could be a\n\t     * substitute command.\n\t     */\n\t    if (*p == '+' || *p == '-' || VIM_ISDIGIT(*p))\n\t\tspats[0].off.line = TRUE;\n\t    else if ((options & SEARCH_OPT)\n\t\t\t\t      && (*p == 'e' || *p == 's' || *p == 'b'))\n\t    {\n\t\tif (*p == 'e')\t\t// end\n\t\t    spats[0].off.end = SEARCH_END;\n\t\t++p;\n\t    }\n\t    if (VIM_ISDIGIT(*p) || *p == '+' || *p == '-')  // got an offset\n\t    {\n\t\t\t\t\t    // 'nr' or '+nr' or '-nr'\n\t\tif (VIM_ISDIGIT(*p) || VIM_ISDIGIT(*(p + 1)))\n\t\t    spats[0].off.off = atol((char *)p);\n\t\telse if (*p == '-')\t    // single '-'\n\t\t    spats[0].off.off = -1;\n\t\telse\t\t\t    // single '+'\n\t\t    spats[0].off.off = 1;\n\t\t++p;\n\t\twhile (VIM_ISDIGIT(*p))\t    // skip number\n\t\t    ++p;\n\t    }\n\n\t    // compute length of search command for get_address()\n\t    searchcmdlen += (int)(p - pat);\n\n\t    pat = p;\t\t\t    // put pat after search command\n\t}\n\n\tif ((options & SEARCH_ECHO) && messaging()\n\t\t&& !msg_silent\n\t\t&& (!cmd_silent || !shortmess(SHM_SEARCHCOUNT)))\n\t{\n\t    char_u\t*trunc;\n\t    char_u\toff_buf[40];\n\t    size_t\toff_len = 0;\n\n\t    // Compute msg_row early.\n\t    msg_start();\n\n\t    // Get the offset, so we know how long it is.\n\t    if (!cmd_silent &&\n\t\t    (spats[0].off.line || spats[0].off.end || spats[0].off.off))\n\t    {\n\t\tp = off_buf;\n\t\t*p++ = dirc;\n\t\tif (spats[0].off.end)\n\t\t    *p++ = 'e';\n\t\telse if (!spats[0].off.line)\n\t\t    *p++ = 's';\n\t\tif (spats[0].off.off > 0 || spats[0].off.line)\n\t\t    *p++ = '+';\n\t\t*p = NUL;\n\t\tif (spats[0].off.off != 0 || spats[0].off.line)\n\t\t    sprintf((char *)p, \"%ld\", spats[0].off.off);\n\t\toff_len = STRLEN(off_buf);\n\t    }\n\n\t    if (*searchstr == NUL)\n\t\tp = spats[0].pat;\n\t    else\n\t\tp = searchstr;\n\n\t    if (!shortmess(SHM_SEARCHCOUNT) || cmd_silent)\n\t    {\n\t\t// Reserve enough space for the search pattern + offset +\n\t\t// search stat.  Use all the space available, so that the\n\t\t// search state is right aligned.  If there is not enough space\n\t\t// msg_strtrunc() will shorten in the middle.\n\t\tif (msg_scrolled != 0 && !cmd_silent)\n\t\t    // Use all the columns.\n\t\t    len = (int)(Rows - msg_row) * Columns - 1;\n\t\telse\n\t\t    // Use up to 'showcmd' column.\n\t\t    len = (int)(Rows - msg_row - 1) * Columns + sc_col - 1;\n\t\tif (len < STRLEN(p) + off_len + SEARCH_STAT_BUF_LEN + 3)\n\t\t    len = STRLEN(p) + off_len + SEARCH_STAT_BUF_LEN + 3;\n\t    }\n\t    else\n\t\t// Reserve enough space for the search pattern + offset.\n\t\tlen = STRLEN(p) + off_len + 3;\n\n\t    vim_free(msgbuf);\n\t    msgbuf = alloc(len);\n\t    if (msgbuf != NULL)\n\t    {\n\t\tvim_memset(msgbuf, ' ', len);\n\t\tmsgbuf[len - 1] = NUL;\n\t\t// do not fill the msgbuf buffer, if cmd_silent is set, leave it\n\t\t// empty for the search_stat feature.\n\t\tif (!cmd_silent)\n\t\t{\n\t\t    msgbuf[0] = dirc;\n\n\t\t    if (enc_utf8 && utf_iscomposing(utf_ptr2char(p)))\n\t\t    {\n\t\t\t// Use a space to draw the composing char on.\n\t\t\tmsgbuf[1] = ' ';\n\t\t\tmch_memmove(msgbuf + 2, p, STRLEN(p));\n\t\t    }\n\t\t    else\n\t\t\tmch_memmove(msgbuf + 1, p, STRLEN(p));\n\t\t    if (off_len > 0)\n\t\t\tmch_memmove(msgbuf + STRLEN(p) + 1, off_buf, off_len);\n\n\t\t    trunc = msg_strtrunc(msgbuf, TRUE);\n\t\t    if (trunc != NULL)\n\t\t    {\n\t\t\tvim_free(msgbuf);\n\t\t\tmsgbuf = trunc;\n\t\t    }\n\n#ifdef FEAT_RIGHTLEFT\n\t\t    // The search pattern could be shown on the right in\n\t\t    // rightleft mode, but the 'ruler' and 'showcmd' area use\n\t\t    // it too, thus it would be blanked out again very soon.\n\t\t    // Show it on the left, but do reverse the text.\n\t\t    if (curwin->w_p_rl && *curwin->w_p_rlc == 's')\n\t\t    {\n\t\t\tchar_u *r;\n\t\t\tsize_t pat_len;\n\n\t\t\tr = reverse_text(msgbuf);\n\t\t\tif (r != NULL)\n\t\t\t{\n\t\t\t    vim_free(msgbuf);\n\t\t\t    msgbuf = r;\n\t\t\t    // move reversed text to beginning of buffer\n\t\t\t    while (*r != NUL && *r == ' ')\n\t\t\t\tr++;\n\t\t\t    pat_len = msgbuf + STRLEN(msgbuf) - r;\n\t\t\t    mch_memmove(msgbuf, r, pat_len);\n\t\t\t    // overwrite old text\n\t\t\t    if ((size_t)(r - msgbuf) >= pat_len)\n\t\t\t\tvim_memset(r, ' ', pat_len);\n\t\t\t    else\n\t\t\t\tvim_memset(msgbuf + pat_len, ' ', r - msgbuf);\n\t\t\t}\n\t\t    }\n#endif\n\t\t    msg_outtrans(msgbuf);\n\t\t    msg_clr_eos();\n\t\t    msg_check();\n\n\t\t    gotocmdline(FALSE);\n\t\t    out_flush();\n\t\t    msg_nowait = TRUE;\t    // don't wait for this message\n\t\t}\n\t    }\n\t}\n\n\t/*\n\t * If there is a character offset, subtract it from the current\n\t * position, so we don't get stuck at \"?pat?e+2\" or \"/pat/s-2\".\n\t * Skip this if pos.col is near MAXCOL (closed fold).\n\t * This is not done for a line offset, because then we would not be vi\n\t * compatible.\n\t */\n\tif (!spats[0].off.line && spats[0].off.off && pos.col < MAXCOL - 2)\n\t{\n\t    if (spats[0].off.off > 0)\n\t    {\n\t\tfor (c = spats[0].off.off; c; --c)\n\t\t    if (decl(&pos) == -1)\n\t\t\tbreak;\n\t\tif (c)\t\t\t// at start of buffer\n\t\t{\n\t\t    pos.lnum = 0;\t// allow lnum == 0 here\n\t\t    pos.col = MAXCOL;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\tfor (c = spats[0].off.off; c; ++c)\n\t\t    if (incl(&pos) == -1)\n\t\t\tbreak;\n\t\tif (c)\t\t\t// at end of buffer\n\t\t{\n\t\t    pos.lnum = curbuf->b_ml.ml_line_count + 1;\n\t\t    pos.col = 0;\n\t\t}\n\t    }\n\t}\n\n\t/*\n\t * The actual search.\n\t */\n\tc = searchit(curwin, curbuf, &pos, NULL,\n\t\t\t\t\t      dirc == '/' ? FORWARD : BACKWARD,\n\t\tsearchstr, count, spats[0].off.end + (options &\n\t\t       (SEARCH_KEEP + SEARCH_PEEK + SEARCH_HIS\n\t\t\t+ SEARCH_MSG + SEARCH_START\n\t\t\t+ ((pat != NULL && *pat == ';') ? 0 : SEARCH_NOOF))),\n\t\tRE_LAST, sia);\n\n\tif (dircp != NULL)\n\t    *dircp = search_delim; // restore second '/' or '?' for normal_cmd()\n\n\tif (!shortmess(SHM_SEARCH)\n\t\t&& ((dirc == '/' && LT_POS(pos, curwin->w_cursor))\n\t\t\t    || (dirc == '?' && LT_POS(curwin->w_cursor, pos))))\n\t    show_top_bot_msg = TRUE;\n\n\tif (c == FAIL)\n\t{\n\t    retval = 0;\n\t    goto end_do_search;\n\t}\n\tif (spats[0].off.end && oap != NULL)\n\t    oap->inclusive = TRUE;  // 'e' includes last character\n\n\tretval = 1;\t\t    // pattern found\n\n\t/*\n\t * Add character and/or line offset\n\t */\n\tif (!(options & SEARCH_NOOF) || (pat != NULL && *pat == ';'))\n\t{\n\t    pos_T org_pos = pos;\n\n\t    if (spats[0].off.line)\t// Add the offset to the line number.\n\t    {\n\t\tc = pos.lnum + spats[0].off.off;\n\t\tif (c < 1)\n\t\t    pos.lnum = 1;\n\t\telse if (c > curbuf->b_ml.ml_line_count)\n\t\t    pos.lnum = curbuf->b_ml.ml_line_count;\n\t\telse\n\t\t    pos.lnum = c;\n\t\tpos.col = 0;\n\n\t\tretval = 2;\t    // pattern found, line offset added\n\t    }\n\t    else if (pos.col < MAXCOL - 2)\t// just in case\n\t    {\n\t\t// to the right, check for end of file\n\t\tc = spats[0].off.off;\n\t\tif (c > 0)\n\t\t{\n\t\t    while (c-- > 0)\n\t\t\tif (incl(&pos) == -1)\n\t\t\t    break;\n\t\t}\n\t\t// to the left, check for start of file\n\t\telse\n\t\t{\n\t\t    while (c++ < 0)\n\t\t\tif (decl(&pos) == -1)\n\t\t\t    break;\n\t\t}\n\t    }\n\t    if (!EQUAL_POS(pos, org_pos))\n\t\thas_offset = TRUE;\n\t}\n\n\t// Show [1/15] if 'S' is not in 'shortmess'.\n\tif ((options & SEARCH_ECHO)\n\t\t&& messaging()\n\t\t&& !msg_silent\n\t\t&& c != FAIL\n\t\t&& !shortmess(SHM_SEARCHCOUNT)\n\t\t&& msgbuf != NULL)\n\t     cmdline_search_stat(dirc, &pos, &curwin->w_cursor,\n\t\t\t\tshow_top_bot_msg, msgbuf,\n\t\t\t\t(count != 1 || has_offset\n#ifdef FEAT_FOLDING\n\t\t\t\t || (!(fdo_flags & FDO_SEARCH)\n\t\t\t\t     && hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t\t\t   NULL, NULL))\n#endif\n\t\t\t\t),\n\t\t\t\tSEARCH_STAT_DEF_MAX_COUNT,\n\t\t\t\tSEARCH_STAT_DEF_TIMEOUT);\n\n\t/*\n\t * The search command can be followed by a ';' to do another search.\n\t * For example: \"/pat/;/foo/+3;?bar\"\n\t * This is like doing another search command, except:\n\t * - The remembered direction '/' or '?' is from the first search.\n\t * - When an error happens the cursor isn't moved at all.\n\t * Don't do this when called by get_address() (it handles ';' itself).\n\t */\n\tif (!(options & SEARCH_OPT) || pat == NULL || *pat != ';')\n\t    break;\n\n\tdirc = *++pat;\n\tsearch_delim = dirc;\n\tif (dirc != '?' && dirc != '/')\n\t{\n\t    retval = 0;\n\t    emsg(_(e_expected_question_or_slash_after_semicolon));\n\t    goto end_do_search;\n\t}\n\t++pat;\n    }\n\n    if (options & SEARCH_MARK)\n\tsetpcmark();\n    curwin->w_cursor = pos;\n    curwin->w_set_curswant = TRUE;\n\nend_do_search:\n    if ((options & SEARCH_KEEP) || (cmdmod.cmod_flags & CMOD_KEEPPATTERNS))\n\tspats[0].off = old_off;\n    vim_free(strcopy);\n    vim_free(msgbuf);\n\n    return retval;\n}\n\n/*\n * search_for_exact_line(buf, pos, dir, pat)\n *\n * Search for a line starting with the given pattern (ignoring leading\n * white-space), starting from pos and going in direction \"dir\". \"pos\" will\n * contain the position of the match found.    Blank lines match only if\n * ADDING is set.  If p_ic is set then the pattern must be in lowercase.\n * Return OK for success, or FAIL if no line found.\n */\n    int\nsearch_for_exact_line(\n    buf_T\t*buf,\n    pos_T\t*pos,\n    int\t\tdir,\n    char_u\t*pat)\n{\n    linenr_T\tstart = 0;\n    char_u\t*ptr;\n    char_u\t*p;\n\n    if (buf->b_ml.ml_line_count == 0)\n\treturn FAIL;\n    for (;;)\n    {\n\tpos->lnum += dir;\n\tif (pos->lnum < 1)\n\t{\n\t    if (p_ws)\n\t    {\n\t\tpos->lnum = buf->b_ml.ml_line_count;\n\t\tif (!shortmess(SHM_SEARCH))\n\t\t    give_warning((char_u *)_(top_bot_msg), TRUE);\n\t    }\n\t    else\n\t    {\n\t\tpos->lnum = 1;\n\t\tbreak;\n\t    }\n\t}\n\telse if (pos->lnum > buf->b_ml.ml_line_count)\n\t{\n\t    if (p_ws)\n\t    {\n\t\tpos->lnum = 1;\n\t\tif (!shortmess(SHM_SEARCH))\n\t\t    give_warning((char_u *)_(bot_top_msg), TRUE);\n\t    }\n\t    else\n\t    {\n\t\tpos->lnum = 1;\n\t\tbreak;\n\t    }\n\t}\n\tif (pos->lnum == start)\n\t    break;\n\tif (start == 0)\n\t    start = pos->lnum;\n\tptr = ml_get_buf(buf, pos->lnum, FALSE);\n\tp = skipwhite(ptr);\n\tpos->col = (colnr_T) (p - ptr);\n\n\t// when adding lines the matching line may be empty but it is not\n\t// ignored because we are interested in the next line -- Acevedo\n\tif (compl_status_adding() && !compl_status_sol())\n\t{\n\t    if ((p_ic ? MB_STRICMP(p, pat) : STRCMP(p, pat)) == 0)\n\t\treturn OK;\n\t}\n\telse if (*p != NUL)\t// ignore empty lines\n\t{\t// expanding lines or words\n\t    if ((p_ic ? MB_STRNICMP(p, pat, ins_compl_len())\n\t\t\t\t   : STRNCMP(p, pat, ins_compl_len())) == 0)\n\t\treturn OK;\n\t}\n    }\n    return FAIL;\n}\n\n/*\n * Character Searches\n */\n\n/*\n * Search for a character in a line.  If \"t_cmd\" is FALSE, move to the\n * position of the character, otherwise move to just before the char.\n * Do this \"cap->count1\" times.\n * Return FAIL or OK.\n */\n    int\nsearchc(cmdarg_T *cap, int t_cmd)\n{\n    int\t\t\tc = cap->nchar;\t// char to search for\n    int\t\t\tdir = cap->arg;\t// TRUE for searching forward\n    long\t\tcount = cap->count1;\t// repeat count\n    int\t\t\tcol;\n    char_u\t\t*p;\n    int\t\t\tlen;\n    int\t\t\tstop = TRUE;\n\n    if (c != NUL)\t// normal search: remember args for repeat\n    {\n\tif (!KeyStuffed)    // don't remember when redoing\n\t{\n\t    *lastc = c;\n\t    set_csearch_direction(dir);\n\t    set_csearch_until(t_cmd);\n\t    lastc_bytelen = (*mb_char2bytes)(c, lastc_bytes);\n\t    if (cap->ncharC1 != 0)\n\t    {\n\t\tlastc_bytelen += (*mb_char2bytes)(cap->ncharC1,\n\t\t\tlastc_bytes + lastc_bytelen);\n\t\tif (cap->ncharC2 != 0)\n\t\t    lastc_bytelen += (*mb_char2bytes)(cap->ncharC2,\n\t\t\t    lastc_bytes + lastc_bytelen);\n\t    }\n\t}\n    }\n    else\t\t// repeat previous search\n    {\n\tif (*lastc == NUL && lastc_bytelen == 1)\n\t    return FAIL;\n\tif (dir)\t// repeat in opposite direction\n\t    dir = -lastcdir;\n\telse\n\t    dir = lastcdir;\n\tt_cmd = last_t_cmd;\n\tc = *lastc;\n\t// For multi-byte re-use last lastc_bytes[] and lastc_bytelen.\n\n\t// Force a move of at least one char, so \";\" and \",\" will move the\n\t// cursor, even if the cursor is right in front of char we are looking\n\t// at.\n\tif (vim_strchr(p_cpo, CPO_SCOLON) == NULL && count == 1 && t_cmd)\n\t    stop = FALSE;\n    }\n\n    if (dir == BACKWARD)\n\tcap->oap->inclusive = FALSE;\n    else\n\tcap->oap->inclusive = TRUE;\n\n    p = ml_get_curline();\n    col = curwin->w_cursor.col;\n    len = (int)STRLEN(p);\n\n    while (count--)\n    {\n\tif (has_mbyte)\n\t{\n\t    for (;;)\n\t    {\n\t\tif (dir > 0)\n\t\t{\n\t\t    col += (*mb_ptr2len)(p + col);\n\t\t    if (col >= len)\n\t\t\treturn FAIL;\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (col == 0)\n\t\t\treturn FAIL;\n\t\t    col -= (*mb_head_off)(p, p + col - 1) + 1;\n\t\t}\n\t\tif (lastc_bytelen == 1)\n\t\t{\n\t\t    if (p[col] == c && stop)\n\t\t\tbreak;\n\t\t}\n\t\telse if (STRNCMP(p + col, lastc_bytes, lastc_bytelen) == 0\n\t\t\t\t\t\t\t\t       && stop)\n\t\t    break;\n\t\tstop = TRUE;\n\t    }\n\t}\n\telse\n\t{\n\t    for (;;)\n\t    {\n\t\tif ((col += dir) < 0 || col >= len)\n\t\t    return FAIL;\n\t\tif (p[col] == c && stop)\n\t\t    break;\n\t\tstop = TRUE;\n\t    }\n\t}\n    }\n\n    if (t_cmd)\n    {\n\t// backup to before the character (possibly double-byte)\n\tcol -= dir;\n\tif (has_mbyte)\n\t{\n\t    if (dir < 0)\n\t\t// Landed on the search char which is lastc_bytelen long\n\t\tcol += lastc_bytelen - 1;\n\t    else\n\t\t// To previous char, which may be multi-byte.\n\t\tcol -= (*mb_head_off)(p, p + col);\n\t}\n    }\n    curwin->w_cursor.col = col;\n\n    return OK;\n}\n\n/*\n * \"Other\" Searches\n */\n\n/*\n * findmatch - find the matching paren or brace\n *\n * Improvement over vi: Braces inside quotes are ignored.\n */\n    pos_T *\nfindmatch(oparg_T *oap, int initc)\n{\n    return findmatchlimit(oap, initc, 0, 0);\n}\n\n/*\n * Return TRUE if the character before \"linep[col]\" equals \"ch\".\n * Return FALSE if \"col\" is zero.\n * Update \"*prevcol\" to the column of the previous character, unless \"prevcol\"\n * is NULL.\n * Handles multibyte string correctly.\n */\n    static int\ncheck_prevcol(\n    char_u\t*linep,\n    int\t\tcol,\n    int\t\tch,\n    int\t\t*prevcol)\n{\n    --col;\n    if (col > 0 && has_mbyte)\n\tcol -= (*mb_head_off)(linep, linep + col);\n    if (prevcol)\n\t*prevcol = col;\n    return (col >= 0 && linep[col] == ch) ? TRUE : FALSE;\n}\n\n/*\n * Raw string start is found at linep[startpos.col - 1].\n * Return TRUE if the matching end can be found between startpos and endpos.\n */\n    static int\nfind_rawstring_end(char_u *linep, pos_T *startpos, pos_T *endpos)\n{\n    char_u\t*p;\n    char_u\t*delim_copy;\n    size_t\tdelim_len;\n    linenr_T\tlnum;\n    int\t\tfound = FALSE;\n\n    for (p = linep + startpos->col + 1; *p && *p != '('; ++p)\n\t;\n    delim_len = (p - linep) - startpos->col - 1;\n    delim_copy = vim_strnsave(linep + startpos->col + 1, delim_len);\n    if (delim_copy == NULL)\n\treturn FALSE;\n    for (lnum = startpos->lnum; lnum <= endpos->lnum; ++lnum)\n    {\n\tchar_u *line = ml_get(lnum);\n\n\tfor (p = line + (lnum == startpos->lnum\n\t\t\t\t\t    ? startpos->col + 1 : 0); *p; ++p)\n\t{\n\t    if (lnum == endpos->lnum && (colnr_T)(p - line) >= endpos->col)\n\t\tbreak;\n\t    if (*p == ')' && STRNCMP(delim_copy, p + 1, delim_len) == 0\n\t\t\t  && p[delim_len + 1] == '\"')\n\t    {\n\t\tfound = TRUE;\n\t\tbreak;\n\t    }\n\t}\n\tif (found)\n\t    break;\n    }\n    vim_free(delim_copy);\n    return found;\n}\n\n/*\n * Check matchpairs option for \"*initc\".\n * If there is a match set \"*initc\" to the matching character and \"*findc\" to\n * the opposite character.  Set \"*backwards\" to the direction.\n * When \"switchit\" is TRUE swap the direction.\n */\n    static void\nfind_mps_values(\n    int\t    *initc,\n    int\t    *findc,\n    int\t    *backwards,\n    int\t    switchit)\n{\n    char_u\t*ptr;\n\n    ptr = curbuf->b_p_mps;\n    while (*ptr != NUL)\n    {\n\tif (has_mbyte)\n\t{\n\t    char_u *prev;\n\n\t    if (mb_ptr2char(ptr) == *initc)\n\t    {\n\t\tif (switchit)\n\t\t{\n\t\t    *findc = *initc;\n\t\t    *initc = mb_ptr2char(ptr + mb_ptr2len(ptr) + 1);\n\t\t    *backwards = TRUE;\n\t\t}\n\t\telse\n\t\t{\n\t\t    *findc = mb_ptr2char(ptr + mb_ptr2len(ptr) + 1);\n\t\t    *backwards = FALSE;\n\t\t}\n\t\treturn;\n\t    }\n\t    prev = ptr;\n\t    ptr += mb_ptr2len(ptr) + 1;\n\t    if (mb_ptr2char(ptr) == *initc)\n\t    {\n\t\tif (switchit)\n\t\t{\n\t\t    *findc = *initc;\n\t\t    *initc = mb_ptr2char(prev);\n\t\t    *backwards = FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t    *findc = mb_ptr2char(prev);\n\t\t    *backwards = TRUE;\n\t\t}\n\t\treturn;\n\t    }\n\t    ptr += mb_ptr2len(ptr);\n\t}\n\telse\n\t{\n\t    if (*ptr == *initc)\n\t    {\n\t\tif (switchit)\n\t\t{\n\t\t    *backwards = TRUE;\n\t\t    *findc = *initc;\n\t\t    *initc = ptr[2];\n\t\t}\n\t\telse\n\t\t{\n\t\t    *backwards = FALSE;\n\t\t    *findc = ptr[2];\n\t\t}\n\t\treturn;\n\t    }\n\t    ptr += 2;\n\t    if (*ptr == *initc)\n\t    {\n\t\tif (switchit)\n\t\t{\n\t\t    *backwards = FALSE;\n\t\t    *findc = *initc;\n\t\t    *initc = ptr[-2];\n\t\t}\n\t\telse\n\t\t{\n\t\t    *backwards = TRUE;\n\t\t    *findc =  ptr[-2];\n\t\t}\n\t\treturn;\n\t    }\n\t    ++ptr;\n\t}\n\tif (*ptr == ',')\n\t    ++ptr;\n    }\n}\n\n/*\n * findmatchlimit -- find the matching paren or brace, if it exists within\n * maxtravel lines of the cursor.  A maxtravel of 0 means search until falling\n * off the edge of the file.\n *\n * \"initc\" is the character to find a match for.  NUL means to find the\n * character at or after the cursor. Special values:\n * '*'  look for C-style comment / *\n * '/'  look for C-style comment / *, ignoring comment-end\n * '#'  look for preprocessor directives\n * 'R'  look for raw string start: R\"delim(text)delim\" (only backwards)\n *\n * flags: FM_BACKWARD\tsearch backwards (when initc is '/', '*' or '#')\n *\t  FM_FORWARD\tsearch forwards (when initc is '/', '*' or '#')\n *\t  FM_BLOCKSTOP\tstop at start/end of block ({ or } in column 0)\n *\t  FM_SKIPCOMM\tskip comments (not implemented yet!)\n *\n * \"oap\" is only used to set oap->motion_type for a linewise motion, it can be\n * NULL\n */\n    pos_T *\nfindmatchlimit(\n    oparg_T\t*oap,\n    int\t\tinitc,\n    int\t\tflags,\n    int\t\tmaxtravel)\n{\n    static pos_T pos;\t\t\t// current search position\n    int\t\tfindc = 0;\t\t// matching brace\n    int\t\tc;\n    int\t\tcount = 0;\t\t// cumulative number of braces\n    int\t\tbackwards = FALSE;\t// init for gcc\n    int\t\traw_string = FALSE;\t// search for raw string\n    int\t\tinquote = FALSE;\t// TRUE when inside quotes\n    char_u\t*linep;\t\t\t// pointer to current line\n    char_u\t*ptr;\n    int\t\tdo_quotes;\t\t// check for quotes in current line\n    int\t\tat_start;\t\t// do_quotes value at start position\n    int\t\thash_dir = 0;\t\t// Direction searched for # things\n    int\t\tcomment_dir = 0;\t// Direction searched for comments\n    pos_T\tmatch_pos;\t\t// Where last slash-star was found\n    int\t\tstart_in_quotes;\t// start position is in quotes\n    int\t\ttraveled = 0;\t\t// how far we've searched so far\n    int\t\tignore_cend = FALSE;    // ignore comment end\n    int\t\tcpo_match;\t\t// vi compatible matching\n    int\t\tcpo_bsl;\t\t// don't recognize backslashes\n    int\t\tmatch_escaped = 0;\t// search for escaped match\n    int\t\tdir;\t\t\t// Direction to search\n    int\t\tcomment_col = MAXCOL;   // start of / / comment\n    int\t\tlispcomm = FALSE;\t// inside of Lisp-style comment\n    int\t\tlisp = curbuf->b_p_lisp; // engage Lisp-specific hacks ;)\n\n    pos = curwin->w_cursor;\n    pos.coladd = 0;\n    linep = ml_get(pos.lnum);\n\n    cpo_match = (vim_strchr(p_cpo, CPO_MATCH) != NULL);\n    cpo_bsl = (vim_strchr(p_cpo, CPO_MATCHBSL) != NULL);\n\n    // Direction to search when initc is '/', '*' or '#'\n    if (flags & FM_BACKWARD)\n\tdir = BACKWARD;\n    else if (flags & FM_FORWARD)\n\tdir = FORWARD;\n    else\n\tdir = 0;\n\n    /*\n     * if initc given, look in the table for the matching character\n     * '/' and '*' are special cases: look for start or end of comment.\n     * When '/' is used, we ignore running backwards into an star-slash, for\n     * \"[*\" command, we just want to find any comment.\n     */\n    if (initc == '/' || initc == '*' || initc == 'R')\n    {\n\tcomment_dir = dir;\n\tif (initc == '/')\n\t    ignore_cend = TRUE;\n\tbackwards = (dir == FORWARD) ? FALSE : TRUE;\n\traw_string = (initc == 'R');\n\tinitc = NUL;\n    }\n    else if (initc != '#' && initc != NUL)\n    {\n\tfind_mps_values(&initc, &findc, &backwards, TRUE);\n\tif (dir)\n\t    backwards = (dir == FORWARD) ? FALSE : TRUE;\n\tif (findc == NUL)\n\t    return NULL;\n    }\n    else\n    {\n\t/*\n\t * Either initc is '#', or no initc was given and we need to look\n\t * under the cursor.\n\t */\n\tif (initc == '#')\n\t{\n\t    hash_dir = dir;\n\t}\n\telse\n\t{\n\t    /*\n\t     * initc was not given, must look for something to match under\n\t     * or near the cursor.\n\t     * Only check for special things when 'cpo' doesn't have '%'.\n\t     */\n\t    if (!cpo_match)\n\t    {\n\t\t// Are we before or at #if, #else etc.?\n\t\tptr = skipwhite(linep);\n\t\tif (*ptr == '#' && pos.col <= (colnr_T)(ptr - linep))\n\t\t{\n\t\t    ptr = skipwhite(ptr + 1);\n\t\t    if (   STRNCMP(ptr, \"if\", 2) == 0\n\t\t\t|| STRNCMP(ptr, \"endif\", 5) == 0\n\t\t\t|| STRNCMP(ptr, \"el\", 2) == 0)\n\t\t\thash_dir = 1;\n\t\t}\n\n\t\t// Are we on a comment?\n\t\telse if (linep[pos.col] == '/')\n\t\t{\n\t\t    if (linep[pos.col + 1] == '*')\n\t\t    {\n\t\t\tcomment_dir = FORWARD;\n\t\t\tbackwards = FALSE;\n\t\t\tpos.col++;\n\t\t    }\n\t\t    else if (pos.col > 0 && linep[pos.col - 1] == '*')\n\t\t    {\n\t\t\tcomment_dir = BACKWARD;\n\t\t\tbackwards = TRUE;\n\t\t\tpos.col--;\n\t\t    }\n\t\t}\n\t\telse if (linep[pos.col] == '*')\n\t\t{\n\t\t    if (linep[pos.col + 1] == '/')\n\t\t    {\n\t\t\tcomment_dir = BACKWARD;\n\t\t\tbackwards = TRUE;\n\t\t    }\n\t\t    else if (pos.col > 0 && linep[pos.col - 1] == '/')\n\t\t    {\n\t\t\tcomment_dir = FORWARD;\n\t\t\tbackwards = FALSE;\n\t\t    }\n\t\t}\n\t    }\n\n\t    /*\n\t     * If we are not on a comment or the # at the start of a line, then\n\t     * look for brace anywhere on this line after the cursor.\n\t     */\n\t    if (!hash_dir && !comment_dir)\n\t    {\n\t\t/*\n\t\t * Find the brace under or after the cursor.\n\t\t * If beyond the end of the line, use the last character in\n\t\t * the line.\n\t\t */\n\t\tif (linep[pos.col] == NUL && pos.col)\n\t\t    --pos.col;\n\t\tfor (;;)\n\t\t{\n\t\t    initc = PTR2CHAR(linep + pos.col);\n\t\t    if (initc == NUL)\n\t\t\tbreak;\n\n\t\t    find_mps_values(&initc, &findc, &backwards, FALSE);\n\t\t    if (findc)\n\t\t\tbreak;\n\t\t    pos.col += mb_ptr2len(linep + pos.col);\n\t\t}\n\t\tif (!findc)\n\t\t{\n\t\t    // no brace in the line, maybe use \"  #if\" then\n\t\t    if (!cpo_match && *skipwhite(linep) == '#')\n\t\t\thash_dir = 1;\n\t\t    else\n\t\t\treturn NULL;\n\t\t}\n\t\telse if (!cpo_bsl)\n\t\t{\n\t\t    int col, bslcnt = 0;\n\n\t\t    // Set \"match_escaped\" if there are an odd number of\n\t\t    // backslashes.\n\t\t    for (col = pos.col; check_prevcol(linep, col, '\\\\', &col);)\n\t\t\tbslcnt++;\n\t\t    match_escaped = (bslcnt & 1);\n\t\t}\n\t    }\n\t}\n\tif (hash_dir)\n\t{\n\t    /*\n\t     * Look for matching #if, #else, #elif, or #endif\n\t     */\n\t    if (oap != NULL)\n\t\toap->motion_type = MLINE;   // Linewise for this case only\n\t    if (initc != '#')\n\t    {\n\t\tptr = skipwhite(skipwhite(linep) + 1);\n\t\tif (STRNCMP(ptr, \"if\", 2) == 0 || STRNCMP(ptr, \"el\", 2) == 0)\n\t\t    hash_dir = 1;\n\t\telse if (STRNCMP(ptr, \"endif\", 5) == 0)\n\t\t    hash_dir = -1;\n\t\telse\n\t\t    return NULL;\n\t    }\n\t    pos.col = 0;\n\t    while (!got_int)\n\t    {\n\t\tif (hash_dir > 0)\n\t\t{\n\t\t    if (pos.lnum == curbuf->b_ml.ml_line_count)\n\t\t\tbreak;\n\t\t}\n\t\telse if (pos.lnum == 1)\n\t\t    break;\n\t\tpos.lnum += hash_dir;\n\t\tlinep = ml_get(pos.lnum);\n\t\tline_breakcheck();\t// check for CTRL-C typed\n\t\tptr = skipwhite(linep);\n\t\tif (*ptr != '#')\n\t\t    continue;\n\t\tpos.col = (colnr_T) (ptr - linep);\n\t\tptr = skipwhite(ptr + 1);\n\t\tif (hash_dir > 0)\n\t\t{\n\t\t    if (STRNCMP(ptr, \"if\", 2) == 0)\n\t\t\tcount++;\n\t\t    else if (STRNCMP(ptr, \"el\", 2) == 0)\n\t\t    {\n\t\t\tif (count == 0)\n\t\t\t    return &pos;\n\t\t    }\n\t\t    else if (STRNCMP(ptr, \"endif\", 5) == 0)\n\t\t    {\n\t\t\tif (count == 0)\n\t\t\t    return &pos;\n\t\t\tcount--;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (STRNCMP(ptr, \"if\", 2) == 0)\n\t\t    {\n\t\t\tif (count == 0)\n\t\t\t    return &pos;\n\t\t\tcount--;\n\t\t    }\n\t\t    else if (initc == '#' && STRNCMP(ptr, \"el\", 2) == 0)\n\t\t    {\n\t\t\tif (count == 0)\n\t\t\t    return &pos;\n\t\t    }\n\t\t    else if (STRNCMP(ptr, \"endif\", 5) == 0)\n\t\t\tcount++;\n\t\t}\n\t    }\n\t    return NULL;\n\t}\n    }\n\n#ifdef FEAT_RIGHTLEFT\n    // This is just guessing: when 'rightleft' is set, search for a matching\n    // paren/brace in the other direction.\n    if (curwin->w_p_rl && vim_strchr((char_u *)\"()[]{}<>\", initc) != NULL)\n\tbackwards = !backwards;\n#endif\n\n    do_quotes = -1;\n    start_in_quotes = MAYBE;\n    CLEAR_POS(&match_pos);\n\n    // backward search: Check if this line contains a single-line comment\n    if ((backwards && comment_dir) || lisp)\n\tcomment_col = check_linecomment(linep);\n    if (lisp && comment_col != MAXCOL && pos.col > (colnr_T)comment_col)\n\tlispcomm = TRUE;    // find match inside this comment\n\n    while (!got_int)\n    {\n\t/*\n\t * Go to the next position, forward or backward. We could use\n\t * inc() and dec() here, but that is much slower\n\t */\n\tif (backwards)\n\t{\n\t    // char to match is inside of comment, don't search outside\n\t    if (lispcomm && pos.col < (colnr_T)comment_col)\n\t\tbreak;\n\t    if (pos.col == 0)\t\t// at start of line, go to prev. one\n\t    {\n\t\tif (pos.lnum == 1)\t// start of file\n\t\t    break;\n\t\t--pos.lnum;\n\n\t\tif (maxtravel > 0 && ++traveled > maxtravel)\n\t\t    break;\n\n\t\tlinep = ml_get(pos.lnum);\n\t\tpos.col = (colnr_T)STRLEN(linep); // pos.col on trailing NUL\n\t\tdo_quotes = -1;\n\t\tline_breakcheck();\n\n\t\t// Check if this line contains a single-line comment\n\t\tif (comment_dir || lisp)\n\t\t    comment_col = check_linecomment(linep);\n\t\t// skip comment\n\t\tif (lisp && comment_col != MAXCOL)\n\t\t    pos.col = comment_col;\n\t    }\n\t    else\n\t    {\n\t\t--pos.col;\n\t\tif (has_mbyte)\n\t\t    pos.col -= (*mb_head_off)(linep, linep + pos.col);\n\t    }\n\t}\n\telse\t\t\t\t// forward search\n\t{\n\t    if (linep[pos.col] == NUL\n\t\t    // at end of line, go to next one\n\t\t    // For lisp don't search for match in comment\n\t\t    || (lisp && comment_col != MAXCOL\n\t\t\t\t\t   && pos.col == (colnr_T)comment_col))\n\t    {\n\t\tif (pos.lnum == curbuf->b_ml.ml_line_count  // end of file\n\t\t\t// line is exhausted and comment with it,\n\t\t\t// don't search for match in code\n\t\t\t || lispcomm)\n\t\t    break;\n\t\t++pos.lnum;\n\n\t\tif (maxtravel && traveled++ > maxtravel)\n\t\t    break;\n\n\t\tlinep = ml_get(pos.lnum);\n\t\tpos.col = 0;\n\t\tdo_quotes = -1;\n\t\tline_breakcheck();\n\t\tif (lisp)   // find comment pos in new line\n\t\t    comment_col = check_linecomment(linep);\n\t    }\n\t    else\n\t    {\n\t\tif (has_mbyte)\n\t\t    pos.col += (*mb_ptr2len)(linep + pos.col);\n\t\telse\n\t\t    ++pos.col;\n\t    }\n\t}\n\n\t/*\n\t * If FM_BLOCKSTOP given, stop at a '{' or '}' in column 0.\n\t */\n\tif (pos.col == 0 && (flags & FM_BLOCKSTOP)\n\t\t\t\t       && (linep[0] == '{' || linep[0] == '}'))\n\t{\n\t    if (linep[0] == findc && count == 0)\t// match!\n\t\treturn &pos;\n\t    break;\t\t\t\t\t// out of scope\n\t}\n\n\tif (comment_dir)\n\t{\n\t    // Note: comments do not nest, and we ignore quotes in them\n\t    // TODO: ignore comment brackets inside strings\n\t    if (comment_dir == FORWARD)\n\t    {\n\t\tif (linep[pos.col] == '*' && linep[pos.col + 1] == '/')\n\t\t{\n\t\t    pos.col++;\n\t\t    return &pos;\n\t\t}\n\t    }\n\t    else    // Searching backwards\n\t    {\n\t\t/*\n\t\t * A comment may contain / * or / /, it may also start or end\n\t\t * with / * /.\tIgnore a / * after / / and after *.\n\t\t */\n\t\tif (pos.col == 0)\n\t\t    continue;\n\t\telse if (raw_string)\n\t\t{\n\t\t    if (linep[pos.col - 1] == 'R'\n\t\t\t&& linep[pos.col] == '\"'\n\t\t\t&& vim_strchr(linep + pos.col + 1, '(') != NULL)\n\t\t    {\n\t\t\t// Possible start of raw string. Now that we have the\n\t\t\t// delimiter we can check if it ends before where we\n\t\t\t// started searching, or before the previously found\n\t\t\t// raw string start.\n\t\t\tif (!find_rawstring_end(linep, &pos,\n\t\t\t\t  count > 0 ? &match_pos : &curwin->w_cursor))\n\t\t\t{\n\t\t\t    count++;\n\t\t\t    match_pos = pos;\n\t\t\t    match_pos.col--;\n\t\t\t}\n\t\t\tlinep = ml_get(pos.lnum); // may have been released\n\t\t    }\n\t\t}\n\t\telse if (  linep[pos.col - 1] == '/'\n\t\t\t&& linep[pos.col] == '*'\n\t\t\t&& (pos.col == 1 || linep[pos.col - 2] != '*')\n\t\t\t&& (int)pos.col < comment_col)\n\t\t{\n\t\t    count++;\n\t\t    match_pos = pos;\n\t\t    match_pos.col--;\n\t\t}\n\t\telse if (linep[pos.col - 1] == '*' && linep[pos.col] == '/')\n\t\t{\n\t\t    if (count > 0)\n\t\t\tpos = match_pos;\n\t\t    else if (pos.col > 1 && linep[pos.col - 2] == '/'\n\t\t\t\t\t       && (int)pos.col <= comment_col)\n\t\t\tpos.col -= 2;\n\t\t    else if (ignore_cend)\n\t\t\tcontinue;\n\t\t    else\n\t\t\treturn NULL;\n\t\t    return &pos;\n\t\t}\n\t    }\n\t    continue;\n\t}\n\n\t/*\n\t * If smart matching ('cpoptions' does not contain '%'), braces inside\n\t * of quotes are ignored, but only if there is an even number of\n\t * quotes in the line.\n\t */\n\tif (cpo_match)\n\t    do_quotes = 0;\n\telse if (do_quotes == -1)\n\t{\n\t    /*\n\t     * Count the number of quotes in the line, skipping \\\" and '\"'.\n\t     * Watch out for \"\\\\\".\n\t     */\n\t    at_start = do_quotes;\n\t    for (ptr = linep; *ptr; ++ptr)\n\t    {\n\t\tif (ptr == linep + pos.col + backwards)\n\t\t    at_start = (do_quotes & 1);\n\t\tif (*ptr == '\"'\n\t\t\t&& (ptr == linep || ptr[-1] != '\\'' || ptr[1] != '\\''))\n\t\t    ++do_quotes;\n\t\tif (*ptr == '\\\\' && ptr[1] != NUL)\n\t\t    ++ptr;\n\t    }\n\t    do_quotes &= 1;\t    // result is 1 with even number of quotes\n\n\t    /*\n\t     * If we find an uneven count, check current line and previous\n\t     * one for a '\\' at the end.\n\t     */\n\t    if (!do_quotes)\n\t    {\n\t\tinquote = FALSE;\n\t\tif (ptr[-1] == '\\\\')\n\t\t{\n\t\t    do_quotes = 1;\n\t\t    if (start_in_quotes == MAYBE)\n\t\t    {\n\t\t\t// Do we need to use at_start here?\n\t\t\tinquote = TRUE;\n\t\t\tstart_in_quotes = TRUE;\n\t\t    }\n\t\t    else if (backwards)\n\t\t\tinquote = TRUE;\n\t\t}\n\t\tif (pos.lnum > 1)\n\t\t{\n\t\t    ptr = ml_get(pos.lnum - 1);\n\t\t    if (*ptr && *(ptr + STRLEN(ptr) - 1) == '\\\\')\n\t\t    {\n\t\t\tdo_quotes = 1;\n\t\t\tif (start_in_quotes == MAYBE)\n\t\t\t{\n\t\t\t    inquote = at_start;\n\t\t\t    if (inquote)\n\t\t\t\tstart_in_quotes = TRUE;\n\t\t\t}\n\t\t\telse if (!backwards)\n\t\t\t    inquote = TRUE;\n\t\t    }\n\n\t\t    // ml_get() only keeps one line, need to get linep again\n\t\t    linep = ml_get(pos.lnum);\n\t\t}\n\t    }\n\t}\n\tif (start_in_quotes == MAYBE)\n\t    start_in_quotes = FALSE;\n\n\t/*\n\t * If 'smartmatch' is set:\n\t *   Things inside quotes are ignored by setting 'inquote'.  If we\n\t *   find a quote without a preceding '\\' invert 'inquote'.  At the\n\t *   end of a line not ending in '\\' we reset 'inquote'.\n\t *\n\t *   In lines with an uneven number of quotes (without preceding '\\')\n\t *   we do not know which part to ignore. Therefore we only set\n\t *   inquote if the number of quotes in a line is even, unless this\n\t *   line or the previous one ends in a '\\'.  Complicated, isn't it?\n\t */\n\tc = PTR2CHAR(linep + pos.col);\n\tswitch (c)\n\t{\n\tcase NUL:\n\t    // at end of line without trailing backslash, reset inquote\n\t    if (pos.col == 0 || linep[pos.col - 1] != '\\\\')\n\t    {\n\t\tinquote = FALSE;\n\t\tstart_in_quotes = FALSE;\n\t    }\n\t    break;\n\n\tcase '\"':\n\t    // a quote that is preceded with an odd number of backslashes is\n\t    // ignored\n\t    if (do_quotes)\n\t    {\n\t\tint col;\n\n\t\tfor (col = pos.col - 1; col >= 0; --col)\n\t\t    if (linep[col] != '\\\\')\n\t\t\tbreak;\n\t\tif ((((int)pos.col - 1 - col) & 1) == 0)\n\t\t{\n\t\t    inquote = !inquote;\n\t\t    start_in_quotes = FALSE;\n\t\t}\n\t    }\n\t    break;\n\n\t/*\n\t * If smart matching ('cpoptions' does not contain '%'):\n\t *   Skip things in single quotes: 'x' or '\\x'.  Be careful for single\n\t *   single quotes, eg jon's.  Things like '\\233' or '\\x3f' are not\n\t *   skipped, there is never a brace in them.\n\t *   Ignore this when finding matches for `'.\n\t */\n\tcase '\\'':\n\t    if (!cpo_match && initc != '\\'' && findc != '\\'')\n\t    {\n\t\tif (backwards)\n\t\t{\n\t\t    if (pos.col > 1)\n\t\t    {\n\t\t\tif (linep[pos.col - 2] == '\\'')\n\t\t\t{\n\t\t\t    pos.col -= 2;\n\t\t\t    break;\n\t\t\t}\n\t\t\telse if (linep[pos.col - 2] == '\\\\'\n\t\t\t\t  && pos.col > 2 && linep[pos.col - 3] == '\\'')\n\t\t\t{\n\t\t\t    pos.col -= 3;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\telse if (linep[pos.col + 1])\t// forward search\n\t\t{\n\t\t    if (linep[pos.col + 1] == '\\\\'\n\t\t\t   && linep[pos.col + 2] && linep[pos.col + 3] == '\\'')\n\t\t    {\n\t\t\tpos.col += 3;\n\t\t\tbreak;\n\t\t    }\n\t\t    else if (linep[pos.col + 2] == '\\'')\n\t\t    {\n\t\t\tpos.col += 2;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    // FALLTHROUGH\n\n\tdefault:\n\t    /*\n\t     * For Lisp skip over backslashed (), {} and [].\n\t     * (actually, we skip #\\( et al)\n\t     */\n\t    if (curbuf->b_p_lisp\n\t\t    && vim_strchr((char_u *)\"{}()[]\", c) != NULL\n\t\t    && pos.col > 1\n\t\t    && check_prevcol(linep, pos.col, '\\\\', NULL)\n\t\t    && check_prevcol(linep, pos.col - 1, '#', NULL))\n\t\tbreak;\n\n\t    // Check for match outside of quotes, and inside of\n\t    // quotes when the start is also inside of quotes.\n\t    if ((!inquote || start_in_quotes == TRUE)\n\t\t    && (c == initc || c == findc))\n\t    {\n\t\tint\tcol, bslcnt = 0;\n\n\t\tif (!cpo_bsl)\n\t\t{\n\t\t    for (col = pos.col; check_prevcol(linep, col, '\\\\', &col);)\n\t\t\tbslcnt++;\n\t\t}\n\t\t// Only accept a match when 'M' is in 'cpo' or when escaping\n\t\t// is what we expect.\n\t\tif (cpo_bsl || (bslcnt & 1) == match_escaped)\n\t\t{\n\t\t    if (c == initc)\n\t\t\tcount++;\n\t\t    else\n\t\t    {\n\t\t\tif (count == 0)\n\t\t\t    return &pos;\n\t\t\tcount--;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n    if (comment_dir == BACKWARD && count > 0)\n    {\n\tpos = match_pos;\n\treturn &pos;\n    }\n    return (pos_T *)NULL;\t// never found it\n}\n\n/*\n * Check if line[] contains a / / comment.\n * Return MAXCOL if not, otherwise return the column.\n */\n    int\ncheck_linecomment(char_u *line)\n{\n    char_u  *p;\n\n    p = line;\n    // skip Lispish one-line comments\n    if (curbuf->b_p_lisp)\n    {\n\tif (vim_strchr(p, ';') != NULL) // there may be comments\n\t{\n\t    int in_str = FALSE;\t// inside of string\n\n\t    p = line;\t\t// scan from start\n\t    while ((p = vim_strpbrk(p, (char_u *)\"\\\";\")) != NULL)\n\t    {\n\t\tif (*p == '\"')\n\t\t{\n\t\t    if (in_str)\n\t\t    {\n\t\t\tif (*(p - 1) != '\\\\') // skip escaped quote\n\t\t\t    in_str = FALSE;\n\t\t    }\n\t\t    else if (p == line || ((p - line) >= 2\n\t\t\t\t      // skip #\\\" form\n\t\t\t\t      && *(p - 1) != '\\\\' && *(p - 2) != '#'))\n\t\t\tin_str = TRUE;\n\t\t}\n\t\telse if (!in_str && ((p - line) < 2\n\t\t\t\t    || (*(p - 1) != '\\\\' && *(p - 2) != '#'))\n\t\t\t       && !is_pos_in_string(line, (colnr_T)(p - line)))\n\t\t    break;\t// found!\n\t\t++p;\n\t    }\n\t}\n\telse\n\t    p = NULL;\n    }\n    else\n\twhile ((p = vim_strchr(p, '/')) != NULL)\n\t{\n\t    // Accept a double /, unless it's preceded with * and followed by\n\t    // *, because * / / * is an end and start of a C comment.  Only\n\t    // accept the position if it is not inside a string.\n\t    if (p[1] == '/' && (p == line || p[-1] != '*' || p[2] != '*')\n\t\t\t       && !is_pos_in_string(line, (colnr_T)(p - line)))\n\t\tbreak;\n\t    ++p;\n\t}\n\n    if (p == NULL)\n\treturn MAXCOL;\n    return (int)(p - line);\n}\n\n/*\n * Move cursor briefly to character matching the one under the cursor.\n * Used for Insert mode and \"r\" command.\n * Show the match only if it is visible on the screen.\n * If there isn't a match, then beep.\n */\n    void\nshowmatch(\n    int\t\tc)\t    // char to show match for\n{\n    pos_T\t*lpos, save_cursor;\n    pos_T\tmpos;\n    colnr_T\tvcol;\n    long\tsave_so;\n    long\tsave_siso;\n#ifdef CURSOR_SHAPE\n    int\t\tsave_state;\n#endif\n    colnr_T\tsave_dollar_vcol;\n    char_u\t*p;\n    long\t*so = curwin->w_p_so >= 0 ? &curwin->w_p_so : &p_so;\n    long\t*siso = curwin->w_p_siso >= 0 ? &curwin->w_p_siso : &p_siso;\n\n    /*\n     * Only show match for chars in the 'matchpairs' option.\n     */\n    // 'matchpairs' is \"x:y,x:y\"\n    for (p = curbuf->b_p_mps; *p != NUL; ++p)\n    {\n#ifdef FEAT_RIGHTLEFT\n\tif (PTR2CHAR(p) == c && (curwin->w_p_rl ^ p_ri))\n\t    break;\n#endif\n\tp += mb_ptr2len(p) + 1;\n\tif (PTR2CHAR(p) == c\n#ifdef FEAT_RIGHTLEFT\n\t\t&& !(curwin->w_p_rl ^ p_ri)\n#endif\n\t   )\n\t    break;\n\tp += mb_ptr2len(p);\n\tif (*p == NUL)\n\t    return;\n    }\n    if (*p == NUL)\n\treturn;\n\n    if ((lpos = findmatch(NULL, NUL)) == NULL)\t    // no match, so beep\n    {\n\tvim_beep(BO_MATCH);\n\treturn;\n    }\n\n    if (lpos->lnum < curwin->w_topline || lpos->lnum >= curwin->w_botline)\n\treturn;\n\n    if (!curwin->w_p_wrap)\n\tgetvcol(curwin, lpos, NULL, &vcol, NULL);\n\n    int col_visible = (curwin->w_p_wrap\n\t    || (vcol >= curwin->w_leftcol\n\t\t&& vcol < curwin->w_leftcol + curwin->w_width));\n    if (!col_visible)\n\treturn;\n\n    mpos = *lpos;    // save the pos, update_screen() may change it\n    save_cursor = curwin->w_cursor;\n    save_so = *so;\n    save_siso = *siso;\n    // Handle \"$\" in 'cpo': If the ')' is typed on top of the \"$\",\n    // stop displaying the \"$\".\n    if (dollar_vcol >= 0 && dollar_vcol == curwin->w_virtcol)\n\tdollar_vcol = -1;\n    ++curwin->w_virtcol;\t// do display ')' just before \"$\"\n    update_screen(UPD_VALID);\t// show the new char first\n\n    save_dollar_vcol = dollar_vcol;\n#ifdef CURSOR_SHAPE\n    save_state = State;\n    State = MODE_SHOWMATCH;\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n    curwin->w_cursor = mpos;\t// move to matching char\n    *so = 0;\t\t\t// don't use 'scrolloff' here\n    *siso = 0;\t\t\t// don't use 'sidescrolloff' here\n    showruler(FALSE);\n    setcursor();\n    cursor_on();\t\t// make sure that the cursor is shown\n    out_flush_cursor(TRUE, FALSE);\n\n    // Restore dollar_vcol(), because setcursor() may call curs_rows()\n    // which resets it if the matching position is in a previous line\n    // and has a higher column number.\n    dollar_vcol = save_dollar_vcol;\n\n    /*\n     * brief pause, unless 'm' is present in 'cpo' and a character is\n     * available.\n     */\n    if (vim_strchr(p_cpo, CPO_SHOWMATCH) != NULL)\n\tui_delay(p_mat * 100L + 8, TRUE);\n    else if (!char_avail())\n\tui_delay(p_mat * 100L + 9, FALSE);\n    curwin->w_cursor = save_cursor;\t// restore cursor position\n    *so = save_so;\n    *siso = save_siso;\n#ifdef CURSOR_SHAPE\n    State = save_state;\n    ui_cursor_shape();\t\t// may show different cursor shape\n#endif\n}\n\n/*\n * Check if the pattern is zero-width.\n * If move is TRUE, check from the beginning of the buffer, else from position\n * \"cur\".\n * \"direction\" is FORWARD or BACKWARD.\n * Returns TRUE, FALSE or -1 for failure.\n */\n    static int\nis_zero_width(char_u *pattern, int move, pos_T *cur, int direction)\n{\n    regmmatch_T\tregmatch;\n    int\t\tnmatched = 0;\n    int\t\tresult = -1;\n    pos_T\tpos;\n    int\t\tcalled_emsg_before = called_emsg;\n    int\t\tflag = 0;\n\n    if (pattern == NULL)\n\tpattern = spats[last_idx].pat;\n\n    if (search_regcomp(pattern, NULL, RE_SEARCH, RE_SEARCH,\n\t\t\t\t\t      SEARCH_KEEP, &regmatch) == FAIL)\n\treturn -1;\n\n    // init startcol correctly\n    regmatch.startpos[0].col = -1;\n    // move to match\n    if (move)\n    {\n\tCLEAR_POS(&pos);\n    }\n    else\n    {\n\tpos = *cur;\n\t// accept a match at the cursor position\n\tflag = SEARCH_START;\n    }\n\n    if (searchit(curwin, curbuf, &pos, NULL, direction, pattern, 1,\n\t\t\t\t  SEARCH_KEEP + flag, RE_SEARCH, NULL) != FAIL)\n    {\n\t// Zero-width pattern should match somewhere, then we can check if\n\t// start and end are in the same position.\n\tdo\n\t{\n\t    regmatch.startpos[0].col++;\n\t    nmatched = vim_regexec_multi(&regmatch, curwin, curbuf,\n\t\t\t       pos.lnum, regmatch.startpos[0].col, NULL);\n\t    if (nmatched != 0)\n\t\tbreak;\n\t} while (regmatch.regprog != NULL\n\t\t&& direction == FORWARD ? regmatch.startpos[0].col < pos.col\n\t\t\t\t      : regmatch.startpos[0].col > pos.col);\n\n\tif (called_emsg == called_emsg_before)\n\t{\n\t    result = (nmatched != 0\n\t\t&& regmatch.startpos[0].lnum == regmatch.endpos[0].lnum\n\t\t&& regmatch.startpos[0].col == regmatch.endpos[0].col);\n\t}\n    }\n\n    vim_regfree(regmatch.regprog);\n    return result;\n}\n\n\n/*\n * Find next search match under cursor, cursor at end.\n * Used while an operator is pending, and in Visual mode.\n */\n    int\ncurrent_search(\n    long\tcount,\n    int\t\tforward)\t// TRUE for forward, FALSE for backward\n{\n    pos_T\tstart_pos;\t// start position of the pattern match\n    pos_T\tend_pos;\t// end position of the pattern match\n    pos_T\torig_pos;\t// position of the cursor at beginning\n    pos_T\tpos;\t\t// position after the pattern\n    int\t\ti;\n    int\t\tdir;\n    int\t\tresult;\t\t// result of various function calls\n    char_u\told_p_ws = p_ws;\n    int\t\tflags = 0;\n    pos_T\tsave_VIsual = VIsual;\n    int\t\tzero_width;\n    int\t\tskip_first_backward;\n\n    // Correct cursor when 'selection' is exclusive\n    if (VIsual_active && *p_sel == 'e' && LT_POS(VIsual, curwin->w_cursor))\n\tdec_cursor();\n\n    // When searching forward and the cursor is at the start of the Visual\n    // area, skip the first search backward, otherwise it doesn't move.\n    skip_first_backward = forward && VIsual_active\n\t\t\t\t\t   && LT_POS(curwin->w_cursor, VIsual);\n\n    orig_pos = pos = curwin->w_cursor;\n    if (VIsual_active)\n    {\n\tif (forward)\n\t    incl(&pos);\n\telse\n\t    decl(&pos);\n    }\n\n    // Is the pattern is zero-width?, this time, don't care about the direction\n    zero_width = is_zero_width(spats[last_idx].pat, TRUE, &curwin->w_cursor,\n\t\t\t\t\t\t\t\t      FORWARD);\n    if (zero_width == -1)\n\treturn FAIL;  // pattern not found\n\n    /*\n     * The trick is to first search backwards and then search forward again,\n     * so that a match at the current cursor position will be correctly\n     * captured.  When \"forward\" is false do it the other way around.\n     */\n    for (i = 0; i < 2; i++)\n    {\n\tif (forward)\n\t{\n\t    if (i == 0 && skip_first_backward)\n\t\tcontinue;\n\t    dir = i;\n\t}\n\telse\n\t    dir = !i;\n\n\tflags = 0;\n\tif (!dir && !zero_width)\n\t    flags = SEARCH_END;\n\tend_pos = pos;\n\n\t// wrapping should not occur in the first round\n\tif (i == 0)\n\t    p_ws = FALSE;\n\n\tresult = searchit(curwin, curbuf, &pos, &end_pos,\n\t\t(dir ? FORWARD : BACKWARD),\n\t\tspats[last_idx].pat, (long) (i ? count : 1),\n\t\tSEARCH_KEEP | flags, RE_SEARCH, NULL);\n\n\tp_ws = old_p_ws;\n\n\t// First search may fail, but then start searching from the\n\t// beginning of the file (cursor might be on the search match)\n\t// except when Visual mode is active, so that extending the visual\n\t// selection works.\n\tif (i == 1 && !result) // not found, abort\n\t{\n\t    curwin->w_cursor = orig_pos;\n\t    if (VIsual_active)\n\t\tVIsual = save_VIsual;\n\t    return FAIL;\n\t}\n\telse if (i == 0 && !result)\n\t{\n\t    if (forward)\n\t    {\n\t\t// try again from start of buffer\n\t\tCLEAR_POS(&pos);\n\t    }\n\t    else\n\t    {\n\t\t// try again from end of buffer\n\t\t// searching backwards, so set pos to last line and col\n\t\tpos.lnum = curwin->w_buffer->b_ml.ml_line_count;\n\t\tpos.col  = (colnr_T)STRLEN(\n\t\t\t\tml_get(curwin->w_buffer->b_ml.ml_line_count));\n\t    }\n\t}\n    }\n\n    start_pos = pos;\n\n    if (!VIsual_active)\n\tVIsual = start_pos;\n\n    // put the cursor after the match\n    curwin->w_cursor = end_pos;\n    if (LT_POS(VIsual, end_pos) && forward)\n    {\n\tif (skip_first_backward)\n\t    // put the cursor on the start of the match\n\t    curwin->w_cursor = pos;\n\telse\n\t    // put the cursor on last character of match\n\t    dec_cursor();\n    }\n    else if (VIsual_active && LT_POS(curwin->w_cursor, VIsual) && forward)\n\tcurwin->w_cursor = pos;   // put the cursor on the start of the match\n    VIsual_active = TRUE;\n    VIsual_mode = 'v';\n\n    if (*p_sel == 'e')\n    {\n\t// Correction for exclusive selection depends on the direction.\n\tif (forward && LTOREQ_POS(VIsual, curwin->w_cursor))\n\t    inc_cursor();\n\telse if (!forward && LTOREQ_POS(curwin->w_cursor, VIsual))\n\t    inc(&VIsual);\n    }\n\n#ifdef FEAT_FOLDING\n    if (fdo_flags & FDO_SEARCH && KeyTyped)\n\tfoldOpenCursor();\n#endif\n\n    may_start_select('c');\n    setmouse();\n#ifdef FEAT_CLIPBOARD\n    // Make sure the clipboard gets updated.  Needed because start and\n    // end are still the same, and the selection needs to be owned\n    clip_star.vmode = NUL;\n#endif\n    redraw_curbuf_later(UPD_INVERTED);\n    showmode();\n\n    return OK;\n}\n\n/*\n * return TRUE if line 'lnum' is empty or has white chars only.\n */\n    int\nlinewhite(linenr_T lnum)\n{\n    char_u  *p;\n\n    p = skipwhite(ml_get(lnum));\n    return (*p == NUL);\n}\n\n/*\n * Add the search count \"[3/19]\" to \"msgbuf\".\n * See update_search_stat() for other arguments.\n */\n    static void\ncmdline_search_stat(\n    int\t\tdirc,\n    pos_T\t*pos,\n    pos_T\t*cursor_pos,\n    int\t\tshow_top_bot_msg,\n    char_u\t*msgbuf,\n    int\t\trecompute,\n    int\t\tmaxcount,\n    long\ttimeout)\n{\n    searchstat_T stat;\n\n    update_search_stat(dirc, pos, cursor_pos, &stat, recompute, maxcount,\n\t\t\t\t\t\t\t\t      timeout);\n    if (stat.cur <= 0)\n\treturn;\n\n    char\tt[SEARCH_STAT_BUF_LEN];\n    size_t\tlen;\n\n#ifdef FEAT_RIGHTLEFT\n    if (curwin->w_p_rl && *curwin->w_p_rlc == 's')\n    {\n\tif (stat.incomplete == 1)\n\t    vim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[?/??]\");\n\telse if (stat.cnt > maxcount && stat.cur > maxcount)\n\t    vim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[>%d/>%d]\",\n\t\t    maxcount, maxcount);\n\telse if (stat.cnt > maxcount)\n\t    vim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[>%d/%d]\",\n\t\t    maxcount, stat.cur);\n\telse\n\t    vim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[%d/%d]\",\n\t\t    stat.cnt, stat.cur);\n    }\n    else\n#endif\n    {\n\tif (stat.incomplete == 1)\n\t    vim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[?/??]\");\n\telse if (stat.cnt > maxcount && stat.cur > maxcount)\n\t    vim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[>%d/>%d]\",\n\t\t    maxcount, maxcount);\n\telse if (stat.cnt > maxcount)\n\t    vim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[%d/>%d]\",\n\t\t    stat.cur, maxcount);\n\telse\n\t    vim_snprintf(t, SEARCH_STAT_BUF_LEN, \"[%d/%d]\",\n\t\t    stat.cur, stat.cnt);\n    }\n\n    len = STRLEN(t);\n    if (show_top_bot_msg && len + 2 < SEARCH_STAT_BUF_LEN)\n    {\n\tmch_memmove(t + 2, t, len);\n\tt[0] = 'W';\n\tt[1] = ' ';\n\tlen += 2;\n    }\n\n    size_t msgbuf_len = STRLEN(msgbuf);\n    if (len > msgbuf_len)\n\tlen = msgbuf_len;\n    mch_memmove(msgbuf + msgbuf_len - len, t, len);\n\n    if (dirc == '?' && stat.cur == maxcount + 1)\n\tstat.cur = -1;\n\n    // keep the message even after redraw, but don't put in history\n    msg_hist_off = TRUE;\n    give_warning(msgbuf, FALSE);\n    msg_hist_off = FALSE;\n}\n\n/*\n * Add the search count information to \"stat\".\n * \"stat\" must not be NULL.\n * When \"recompute\" is TRUE always recompute the numbers.\n * dirc == 0: don't find the next/previous match (only set the result to \"stat\")\n * dirc == '/': find the next match\n * dirc == '?': find the previous match\n */\n    static void\nupdate_search_stat(\n    int\t\t\tdirc,\n    pos_T\t\t*pos,\n    pos_T\t\t*cursor_pos,\n    searchstat_T\t*stat,\n    int\t\t\trecompute,\n    int\t\t\tmaxcount,\n    long\t\ttimeout UNUSED)\n{\n    int\t\t    save_ws = p_ws;\n    int\t\t    wraparound = FALSE;\n    pos_T\t    p = (*pos);\n    static pos_T    lastpos = {0, 0, 0};\n    static int\t    cur = 0;\n    static int\t    cnt = 0;\n    static int\t    exact_match = FALSE;\n    static int\t    incomplete = 0;\n    static int\t    last_maxcount = SEARCH_STAT_DEF_MAX_COUNT;\n    static int\t    chgtick = 0;\n    static char_u   *lastpat = NULL;\n    static buf_T    *lbuf = NULL;\n#ifdef FEAT_RELTIME\n    proftime_T  start;\n#endif\n\n    CLEAR_POINTER(stat);\n\n    if (dirc == 0 && !recompute && !EMPTY_POS(lastpos))\n    {\n\tstat->cur = cur;\n\tstat->cnt = cnt;\n\tstat->exact_match = exact_match;\n\tstat->incomplete = incomplete;\n\tstat->last_maxcount = last_maxcount;\n\treturn;\n    }\n    last_maxcount = maxcount;\n\n    wraparound = ((dirc == '?' && LT_POS(lastpos, p))\n\t       || (dirc == '/' && LT_POS(p, lastpos)));\n\n    // If anything relevant changed the count has to be recomputed.\n    // MB_STRNICMP ignores case, but we should not ignore case.\n    // Unfortunately, there is no MB_STRNICMP function.\n    // XXX: above comment should be \"no MB_STRCMP function\" ?\n    if (!(chgtick == CHANGEDTICK(curbuf)\n\t&& MB_STRNICMP(lastpat, spats[last_idx].pat, STRLEN(lastpat)) == 0\n\t&& STRLEN(lastpat) == STRLEN(spats[last_idx].pat)\n\t&& EQUAL_POS(lastpos, *cursor_pos)\n\t&& lbuf == curbuf) || wraparound || cur < 0\n\t    || (maxcount > 0 && cur > maxcount) || recompute)\n    {\n\tcur = 0;\n\tcnt = 0;\n\texact_match = FALSE;\n\tincomplete = 0;\n\tCLEAR_POS(&lastpos);\n\tlbuf = curbuf;\n    }\n\n    if (EQUAL_POS(lastpos, *cursor_pos) && !wraparound\n\t\t&& (dirc == 0 || dirc == '/' ? cur < cnt : cur > 0))\n\tcur += dirc == 0 ? 0 : dirc == '/' ? 1 : -1;\n    else\n    {\n\tint\tdone_search = FALSE;\n\tpos_T\tendpos = {0, 0, 0};\n\n\tp_ws = FALSE;\n#ifdef FEAT_RELTIME\n\tif (timeout > 0)\n\t    profile_setlimit(timeout, &start);\n#endif\n\twhile (!got_int && searchit(curwin, curbuf, &lastpos, &endpos,\n\t\t\t FORWARD, NULL, 1, SEARCH_KEEP, RE_LAST, NULL) != FAIL)\n\t{\n\t    done_search = TRUE;\n#ifdef FEAT_RELTIME\n\t    // Stop after passing the time limit.\n\t    if (timeout > 0 && profile_passed_limit(&start))\n\t    {\n\t\tincomplete = 1;\n\t\tbreak;\n\t    }\n#endif\n\t    cnt++;\n\t    if (LTOREQ_POS(lastpos, p))\n\t    {\n\t\tcur = cnt;\n\t\tif (LT_POS(p, endpos))\n\t\t    exact_match = TRUE;\n\t    }\n\t    fast_breakcheck();\n\t    if (maxcount > 0 && cnt > maxcount)\n\t    {\n\t\tincomplete = 2;    // max count exceeded\n\t\tbreak;\n\t    }\n\t}\n\tif (got_int)\n\t    cur = -1; // abort\n\tif (done_search)\n\t{\n\t    vim_free(lastpat);\n\t    lastpat = vim_strsave(spats[last_idx].pat);\n\t    chgtick = CHANGEDTICK(curbuf);\n\t    lbuf = curbuf;\n\t    lastpos = p;\n\t}\n    }\n    stat->cur = cur;\n    stat->cnt = cnt;\n    stat->exact_match = exact_match;\n    stat->incomplete = incomplete;\n    stat->last_maxcount = last_maxcount;\n    p_ws = save_ws;\n}\n\n#if defined(FEAT_FIND_ID) || defined(PROTO)\n\n/*\n * Get line \"lnum\" and copy it into \"buf[LSIZE]\".\n * The copy is made because the regexp may make the line invalid when using a\n * mark.\n */\n    static char_u *\nget_line_and_copy(linenr_T lnum, char_u *buf)\n{\n    char_u *line = ml_get(lnum);\n\n    vim_strncpy(buf, line, LSIZE - 1);\n    return buf;\n}\n\n/*\n * Find identifiers or defines in included files.\n * If p_ic && compl_status_sol() then ptr must be in lowercase.\n */\n    void\nfind_pattern_in_path(\n    char_u\t*ptr,\t\t// pointer to search pattern\n    int\t\tdir UNUSED,\t// direction of expansion\n    int\t\tlen,\t\t// length of search pattern\n    int\t\twhole,\t\t// match whole words only\n    int\t\tskip_comments,\t// don't match inside comments\n    int\t\ttype,\t\t// Type of search; are we looking for a type?\n\t\t\t\t// a macro?\n    long\tcount,\n    int\t\taction,\t\t// What to do when we find it\n    linenr_T\tstart_lnum,\t// first line to start searching\n    linenr_T\tend_lnum)\t// last line for searching\n{\n    SearchedFile *files;\t\t// Stack of included files\n    SearchedFile *bigger;\t\t// When we need more space\n    int\t\tmax_path_depth = 50;\n    long\tmatch_count = 1;\n\n    char_u\t*pat;\n    char_u\t*new_fname;\n    char_u\t*curr_fname = curbuf->b_fname;\n    char_u\t*prev_fname = NULL;\n    linenr_T\tlnum;\n    int\t\tdepth;\n    int\t\tdepth_displayed;\t// For type==CHECK_PATH\n    int\t\told_files;\n    int\t\talready_searched;\n    char_u\t*file_line;\n    char_u\t*line;\n    char_u\t*p;\n    char_u\tsave_char;\n    int\t\tdefine_matched;\n    regmatch_T\tregmatch;\n    regmatch_T\tincl_regmatch;\n    regmatch_T\tdef_regmatch;\n    int\t\tmatched = FALSE;\n    int\t\tdid_show = FALSE;\n    int\t\tfound = FALSE;\n    int\t\ti;\n    char_u\t*already = NULL;\n    char_u\t*startp = NULL;\n    char_u\t*inc_opt = NULL;\n#if defined(FEAT_QUICKFIX)\n    win_T\t*curwin_save = NULL;\n#endif\n\n    regmatch.regprog = NULL;\n    incl_regmatch.regprog = NULL;\n    def_regmatch.regprog = NULL;\n\n    file_line = alloc(LSIZE);\n    if (file_line == NULL)\n\treturn;\n\n    if (type != CHECK_PATH && type != FIND_DEFINE\n\t    // when CONT_SOL is set compare \"ptr\" with the beginning of the\n\t    // line is faster than quote_meta/regcomp/regexec \"ptr\" -- Acevedo\n\t    && !compl_status_sol())\n    {\n\tpat = alloc(len + 5);\n\tif (pat == NULL)\n\t    goto fpip_end;\n\tsprintf((char *)pat, whole ? \"\\\\<%.*s\\\\>\" : \"%.*s\", len, ptr);\n\t// ignore case according to p_ic, p_scs and pat\n\tregmatch.rm_ic = ignorecase(pat);\n\tregmatch.regprog = vim_regcomp(pat, magic_isset() ? RE_MAGIC : 0);\n\tvim_free(pat);\n\tif (regmatch.regprog == NULL)\n\t    goto fpip_end;\n    }\n    inc_opt = (*curbuf->b_p_inc == NUL) ? p_inc : curbuf->b_p_inc;\n    if (*inc_opt != NUL)\n    {\n\tincl_regmatch.regprog = vim_regcomp(inc_opt,\n\t\t\t\t\t\t magic_isset() ? RE_MAGIC : 0);\n\tif (incl_regmatch.regprog == NULL)\n\t    goto fpip_end;\n\tincl_regmatch.rm_ic = FALSE;\t// don't ignore case in incl. pat.\n    }\n    if (type == FIND_DEFINE && (*curbuf->b_p_def != NUL || *p_def != NUL))\n    {\n\tdef_regmatch.regprog = vim_regcomp(*curbuf->b_p_def == NUL\n\t\t\t   ? p_def : curbuf->b_p_def,\n\t\t\t\t\t\t magic_isset() ? RE_MAGIC : 0);\n\tif (def_regmatch.regprog == NULL)\n\t    goto fpip_end;\n\tdef_regmatch.rm_ic = FALSE;\t// don't ignore case in define pat.\n    }\n    files = lalloc_clear(max_path_depth * sizeof(SearchedFile), TRUE);\n    if (files == NULL)\n\tgoto fpip_end;\n    old_files = max_path_depth;\n    depth = depth_displayed = -1;\n\n    lnum = start_lnum;\n    if (end_lnum > curbuf->b_ml.ml_line_count)\n\tend_lnum = curbuf->b_ml.ml_line_count;\n    if (lnum > end_lnum)\t\t// do at least one line\n\tlnum = end_lnum;\n    line = get_line_and_copy(lnum, file_line);\n\n    for (;;)\n    {\n\tif (incl_regmatch.regprog != NULL\n\t\t&& vim_regexec(&incl_regmatch, line, (colnr_T)0))\n\t{\n\t    char_u *p_fname = (curr_fname == curbuf->b_fname)\n\t\t\t\t\t      ? curbuf->b_ffname : curr_fname;\n\n\t    if (inc_opt != NULL && strstr((char *)inc_opt, \"\\\\zs\") != NULL)\n\t\t// Use text from '\\zs' to '\\ze' (or end) of 'include'.\n\t\tnew_fname = find_file_name_in_path(incl_regmatch.startp[0],\n\t\t       (int)(incl_regmatch.endp[0] - incl_regmatch.startp[0]),\n\t\t\t\t FNAME_EXP|FNAME_INCL|FNAME_REL, 1L, p_fname);\n\t    else\n\t\t// Use text after match with 'include'.\n\t\tnew_fname = file_name_in_line(incl_regmatch.endp[0], 0,\n\t\t\t     FNAME_EXP|FNAME_INCL|FNAME_REL, 1L, p_fname, NULL);\n\t    already_searched = FALSE;\n\t    if (new_fname != NULL)\n\t    {\n\t\t// Check whether we have already searched in this file\n\t\tfor (i = 0;; i++)\n\t\t{\n\t\t    if (i == depth + 1)\n\t\t\ti = old_files;\n\t\t    if (i == max_path_depth)\n\t\t\tbreak;\n\t\t    if (fullpathcmp(new_fname, files[i].name, TRUE, TRUE)\n\t\t\t\t\t\t\t\t    & FPC_SAME)\n\t\t    {\n\t\t\tif (type != CHECK_PATH\n\t\t\t\t&& action == ACTION_SHOW_ALL\n\t\t\t\t&& files[i].matched)\n\t\t\t{\n\t\t\t    msg_putchar('\\n');\t    // cursor below last one\n\t\t\t    if (!got_int)\t    // don't display if 'q'\n\t\t\t\t\t\t    // typed at \"--more--\"\n\t\t\t\t\t\t    // message\n\t\t\t    {\n\t\t\t\tmsg_home_replace_hl(new_fname);\n\t\t\t\tmsg_puts(_(\" (includes previously listed match)\"));\n\t\t\t\tprev_fname = NULL;\n\t\t\t    }\n\t\t\t}\n\t\t\tVIM_CLEAR(new_fname);\n\t\t\talready_searched = TRUE;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\n\t    if (type == CHECK_PATH && (action == ACTION_SHOW_ALL\n\t\t\t\t || (new_fname == NULL && !already_searched)))\n\t    {\n\t\tif (did_show)\n\t\t    msg_putchar('\\n');\t    // cursor below last one\n\t\telse\n\t\t{\n\t\t    gotocmdline(TRUE);\t    // cursor at status line\n\t\t    msg_puts_title(_(\"--- Included files \"));\n\t\t    if (action != ACTION_SHOW_ALL)\n\t\t\tmsg_puts_title(_(\"not found \"));\n\t\t    msg_puts_title(_(\"in path ---\\n\"));\n\t\t}\n\t\tdid_show = TRUE;\n\t\twhile (depth_displayed < depth && !got_int)\n\t\t{\n\t\t    ++depth_displayed;\n\t\t    for (i = 0; i < depth_displayed; i++)\n\t\t\tmsg_puts(\"  \");\n\t\t    msg_home_replace(files[depth_displayed].name);\n\t\t    msg_puts(\" -->\\n\");\n\t\t}\n\t\tif (!got_int)\t\t    // don't display if 'q' typed\n\t\t\t\t\t    // for \"--more--\" message\n\t\t{\n\t\t    for (i = 0; i <= depth_displayed; i++)\n\t\t\tmsg_puts(\"  \");\n\t\t    if (new_fname != NULL)\n\t\t    {\n\t\t\t// using \"new_fname\" is more reliable, e.g., when\n\t\t\t// 'includeexpr' is set.\n\t\t\tmsg_outtrans_attr(new_fname, HL_ATTR(HLF_D));\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t/*\n\t\t\t * Isolate the file name.\n\t\t\t * Include the surrounding \"\" or <> if present.\n\t\t\t */\n\t\t\tif (inc_opt != NULL\n\t\t\t\t   && strstr((char *)inc_opt, \"\\\\zs\") != NULL)\n\t\t\t{\n\t\t\t    // pattern contains \\zs, use the match\n\t\t\t    p = incl_regmatch.startp[0];\n\t\t\t    i = (int)(incl_regmatch.endp[0]\n\t\t\t\t\t\t   - incl_regmatch.startp[0]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    // find the file name after the end of the match\n\t\t\t    for (p = incl_regmatch.endp[0];\n\t\t\t\t\t\t  *p && !vim_isfilec(*p); p++)\n\t\t\t\t;\n\t\t\t    for (i = 0; vim_isfilec(p[i]); i++)\n\t\t\t\t;\n\t\t\t}\n\n\t\t\tif (i == 0)\n\t\t\t{\n\t\t\t    // Nothing found, use the rest of the line.\n\t\t\t    p = incl_regmatch.endp[0];\n\t\t\t    i = (int)STRLEN(p);\n\t\t\t}\n\t\t\t// Avoid checking before the start of the line, can\n\t\t\t// happen if \\zs appears in the regexp.\n\t\t\telse if (p > line)\n\t\t\t{\n\t\t\t    if (p[-1] == '\"' || p[-1] == '<')\n\t\t\t    {\n\t\t\t\t--p;\n\t\t\t\t++i;\n\t\t\t    }\n\t\t\t    if (p[i] == '\"' || p[i] == '>')\n\t\t\t\t++i;\n\t\t\t}\n\t\t\tsave_char = p[i];\n\t\t\tp[i] = NUL;\n\t\t\tmsg_outtrans_attr(p, HL_ATTR(HLF_D));\n\t\t\tp[i] = save_char;\n\t\t    }\n\n\t\t    if (new_fname == NULL && action == ACTION_SHOW_ALL)\n\t\t    {\n\t\t\tif (already_searched)\n\t\t\t    msg_puts(_(\"  (Already listed)\"));\n\t\t\telse\n\t\t\t    msg_puts(_(\"  NOT FOUND\"));\n\t\t    }\n\t\t}\n\t\tout_flush();\t    // output each line directly\n\t    }\n\n\t    if (new_fname != NULL)\n\t    {\n\t\t// Push the new file onto the file stack\n\t\tif (depth + 1 == old_files)\n\t\t{\n\t\t    bigger = ALLOC_MULT(SearchedFile, max_path_depth * 2);\n\t\t    if (bigger != NULL)\n\t\t    {\n\t\t\tfor (i = 0; i <= depth; i++)\n\t\t\t    bigger[i] = files[i];\n\t\t\tfor (i = depth + 1; i < old_files + max_path_depth; i++)\n\t\t\t{\n\t\t\t    bigger[i].fp = NULL;\n\t\t\t    bigger[i].name = NULL;\n\t\t\t    bigger[i].lnum = 0;\n\t\t\t    bigger[i].matched = FALSE;\n\t\t\t}\n\t\t\tfor (i = old_files; i < max_path_depth; i++)\n\t\t\t    bigger[i + max_path_depth] = files[i];\n\t\t\told_files += max_path_depth;\n\t\t\tmax_path_depth *= 2;\n\t\t\tvim_free(files);\n\t\t\tfiles = bigger;\n\t\t    }\n\t\t}\n\t\tif ((files[depth + 1].fp = mch_fopen((char *)new_fname, \"r\"))\n\t\t\t\t\t\t\t\t    == NULL)\n\t\t    vim_free(new_fname);\n\t\telse\n\t\t{\n\t\t    if (++depth == old_files)\n\t\t    {\n\t\t\t/*\n\t\t\t * lalloc() for 'bigger' must have failed above.  We\n\t\t\t * will forget one of our already visited files now.\n\t\t\t */\n\t\t\tvim_free(files[old_files].name);\n\t\t\t++old_files;\n\t\t    }\n\t\t    files[depth].name = curr_fname = new_fname;\n\t\t    files[depth].lnum = 0;\n\t\t    files[depth].matched = FALSE;\n\t\t    if (action == ACTION_EXPAND)\n\t\t    {\n\t\t\tmsg_hist_off = TRUE;\t// reset in msg_trunc_attr()\n\t\t\tvim_snprintf((char*)IObuff, IOSIZE,\n\t\t\t\t_(\"Scanning included file: %s\"),\n\t\t\t\t(char *)new_fname);\n\t\t\tmsg_trunc_attr((char *)IObuff, TRUE, HL_ATTR(HLF_R));\n\t\t    }\n\t\t    else if (p_verbose >= 5)\n\t\t    {\n\t\t\tverbose_enter();\n\t\t\tsmsg(_(\"Searching included file %s\"),\n\t\t\t\t\t\t\t   (char *)new_fname);\n\t\t\tverbose_leave();\n\t\t    }\n\n\t\t}\n\t    }\n\t}\n\telse\n\t{\n\t    /*\n\t     * Check if the line is a define (type == FIND_DEFINE)\n\t     */\n\t    p = line;\nsearch_line:\n\t    define_matched = FALSE;\n\t    if (def_regmatch.regprog != NULL\n\t\t\t      && vim_regexec(&def_regmatch, line, (colnr_T)0))\n\t    {\n\t\t/*\n\t\t * Pattern must be first identifier after 'define', so skip\n\t\t * to that position before checking for match of pattern.  Also\n\t\t * don't let it match beyond the end of this identifier.\n\t\t */\n\t\tp = def_regmatch.endp[0];\n\t\twhile (*p && !vim_iswordc(*p))\n\t\t    p++;\n\t\tdefine_matched = TRUE;\n\t    }\n\n\t    /*\n\t     * Look for a match.  Don't do this if we are looking for a\n\t     * define and this line didn't match define_prog above.\n\t     */\n\t    if (def_regmatch.regprog == NULL || define_matched)\n\t    {\n\t\tif (define_matched || compl_status_sol())\n\t\t{\n\t\t    // compare the first \"len\" chars from \"ptr\"\n\t\t    startp = skipwhite(p);\n\t\t    if (p_ic)\n\t\t\tmatched = !MB_STRNICMP(startp, ptr, len);\n\t\t    else\n\t\t\tmatched = !STRNCMP(startp, ptr, len);\n\t\t    if (matched && define_matched && whole\n\t\t\t\t\t\t  && vim_iswordc(startp[len]))\n\t\t\tmatched = FALSE;\n\t\t}\n\t\telse if (regmatch.regprog != NULL\n\t\t\t && vim_regexec(&regmatch, line, (colnr_T)(p - line)))\n\t\t{\n\t\t    matched = TRUE;\n\t\t    startp = regmatch.startp[0];\n\t\t    /*\n\t\t     * Check if the line is not a comment line (unless we are\n\t\t     * looking for a define).  A line starting with \"# define\"\n\t\t     * is not considered to be a comment line.\n\t\t     */\n\t\t    if (!define_matched && skip_comments)\n\t\t    {\n\t\t\tif ((*line != '#' ||\n\t\t\t\tSTRNCMP(skipwhite(line + 1), \"define\", 6) != 0)\n\t\t\t\t&& get_leader_len(line, NULL, FALSE, TRUE))\n\t\t\t    matched = FALSE;\n\n\t\t\t/*\n\t\t\t * Also check for a \"/ *\" or \"/ /\" before the match.\n\t\t\t * Skips lines like \"int backwards;  / * normal index\n\t\t\t * * /\" when looking for \"normal\".\n\t\t\t * Note: Doesn't skip \"/ *\" in comments.\n\t\t\t */\n\t\t\tp = skipwhite(line);\n\t\t\tif (matched\n\t\t\t\t|| (p[0] == '/' && p[1] == '*') || p[0] == '*')\n\t\t\t    for (p = line; *p && p < startp; ++p)\n\t\t\t    {\n\t\t\t\tif (matched\n\t\t\t\t\t&& p[0] == '/'\n\t\t\t\t\t&& (p[1] == '*' || p[1] == '/'))\n\t\t\t\t{\n\t\t\t\t    matched = FALSE;\n\t\t\t\t    // After \"//\" all text is comment\n\t\t\t\t    if (p[1] == '/')\n\t\t\t\t\tbreak;\n\t\t\t\t    ++p;\n\t\t\t\t}\n\t\t\t\telse if (!matched && p[0] == '*' && p[1] == '/')\n\t\t\t\t{\n\t\t\t\t    // Can find match after \"* /\".\n\t\t\t\t    matched = TRUE;\n\t\t\t\t    ++p;\n\t\t\t\t}\n\t\t\t    }\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif (matched)\n\t{\n\t    if (action == ACTION_EXPAND)\n\t    {\n\t\tint\tcont_s_ipos = FALSE;\n\t\tint\tadd_r;\n\t\tchar_u\t*aux;\n\n\t\tif (depth == -1 && lnum == curwin->w_cursor.lnum)\n\t\t    break;\n\t\tfound = TRUE;\n\t\taux = p = startp;\n\t\tif (compl_status_adding())\n\t\t{\n\t\t    p += ins_compl_len();\n\t\t    if (vim_iswordp(p))\n\t\t\tgoto exit_matched;\n\t\t    p = find_word_start(p);\n\t\t}\n\t\tp = find_word_end(p);\n\t\ti = (int)(p - aux);\n\n\t\tif (compl_status_adding() && i == ins_compl_len())\n\t\t{\n\t\t    // IOSIZE > compl_length, so the STRNCPY works\n\t\t    STRNCPY(IObuff, aux, i);\n\n\t\t    // Get the next line: when \"depth\" < 0  from the current\n\t\t    // buffer, otherwise from the included file.  Jump to\n\t\t    // exit_matched when past the last line.\n\t\t    if (depth < 0)\n\t\t    {\n\t\t\tif (lnum >= end_lnum)\n\t\t\t    goto exit_matched;\n\t\t\tline = get_line_and_copy(++lnum, file_line);\n\t\t    }\n\t\t    else if (vim_fgets(line = file_line,\n\t\t\t\t\t\t      LSIZE, files[depth].fp))\n\t\t\tgoto exit_matched;\n\n\t\t    // we read a line, set \"already\" to check this \"line\" later\n\t\t    // if depth >= 0 we'll increase files[depth].lnum far\n\t\t    // below  -- Acevedo\n\t\t    already = aux = p = skipwhite(line);\n\t\t    p = find_word_start(p);\n\t\t    p = find_word_end(p);\n\t\t    if (p > aux)\n\t\t    {\n\t\t\tif (*aux != ')' && IObuff[i-1] != TAB)\n\t\t\t{\n\t\t\t    if (IObuff[i-1] != ' ')\n\t\t\t\tIObuff[i++] = ' ';\n\t\t\t    // IObuf =~ \"\\(\\k\\|\\i\\).* \", thus i >= 2\n\t\t\t    if (p_js\n\t\t\t\t&& (IObuff[i-2] == '.'\n\t\t\t\t    || (vim_strchr(p_cpo, CPO_JOINSP) == NULL\n\t\t\t\t\t&& (IObuff[i-2] == '?'\n\t\t\t\t\t    || IObuff[i-2] == '!'))))\n\t\t\t\tIObuff[i++] = ' ';\n\t\t\t}\n\t\t\t// copy as much as possible of the new word\n\t\t\tif (p - aux >= IOSIZE - i)\n\t\t\t    p = aux + IOSIZE - i - 1;\n\t\t\tSTRNCPY(IObuff + i, aux, p - aux);\n\t\t\ti += (int)(p - aux);\n\t\t\tcont_s_ipos = TRUE;\n\t\t    }\n\t\t    IObuff[i] = NUL;\n\t\t    aux = IObuff;\n\n\t\t    if (i == ins_compl_len())\n\t\t\tgoto exit_matched;\n\t\t}\n\n\t\tadd_r = ins_compl_add_infercase(aux, i, p_ic,\n\t\t\tcurr_fname == curbuf->b_fname ? NULL : curr_fname,\n\t\t\tdir, cont_s_ipos);\n\t\tif (add_r == OK)\n\t\t    // if dir was BACKWARD then honor it just once\n\t\t    dir = FORWARD;\n\t\telse if (add_r == FAIL)\n\t\t    break;\n\t    }\n\t    else if (action == ACTION_SHOW_ALL)\n\t    {\n\t\tfound = TRUE;\n\t\tif (!did_show)\n\t\t    gotocmdline(TRUE);\t\t// cursor at status line\n\t\tif (curr_fname != prev_fname)\n\t\t{\n\t\t    if (did_show)\n\t\t\tmsg_putchar('\\n');\t// cursor below last one\n\t\t    if (!got_int)\t\t// don't display if 'q' typed\n\t\t\t\t\t\t// at \"--more--\" message\n\t\t\tmsg_home_replace_hl(curr_fname);\n\t\t    prev_fname = curr_fname;\n\t\t}\n\t\tdid_show = TRUE;\n\t\tif (!got_int)\n\t\t    show_pat_in_path(line, type, TRUE, action,\n\t\t\t    (depth == -1) ? NULL : files[depth].fp,\n\t\t\t    (depth == -1) ? &lnum : &files[depth].lnum,\n\t\t\t    match_count++);\n\n\t\t// Set matched flag for this file and all the ones that\n\t\t// include it\n\t\tfor (i = 0; i <= depth; ++i)\n\t\t    files[i].matched = TRUE;\n\t    }\n\t    else if (--count <= 0)\n\t    {\n\t\tfound = TRUE;\n\t\tif (depth == -1 && lnum == curwin->w_cursor.lnum\n#if defined(FEAT_QUICKFIX)\n\t\t\t\t\t\t      && g_do_tagpreview == 0\n#endif\n\t\t\t\t\t\t      )\n\t\t    emsg(_(e_match_is_on_current_line));\n\t\telse if (action == ACTION_SHOW)\n\t\t{\n\t\t    show_pat_in_path(line, type, did_show, action,\n\t\t\t(depth == -1) ? NULL : files[depth].fp,\n\t\t\t(depth == -1) ? &lnum : &files[depth].lnum, 1L);\n\t\t    did_show = TRUE;\n\t\t}\n\t\telse\n\t\t{\n#ifdef FEAT_GUI\n\t\t    need_mouse_correct = TRUE;\n#endif\n#if defined(FEAT_QUICKFIX)\n\t\t    // \":psearch\" uses the preview window\n\t\t    if (g_do_tagpreview != 0)\n\t\t    {\n\t\t\tcurwin_save = curwin;\n\t\t\tprepare_tagpreview(TRUE, TRUE, FALSE);\n\t\t    }\n#endif\n\t\t    if (action == ACTION_SPLIT)\n\t\t    {\n\t\t\tif (win_split(0, 0) == FAIL)\n\t\t\t    break;\n\t\t\tRESET_BINDING(curwin);\n\t\t    }\n\t\t    if (depth == -1)\n\t\t    {\n\t\t\t// match in current file\n#if defined(FEAT_QUICKFIX)\n\t\t\tif (g_do_tagpreview != 0)\n\t\t\t{\n\t\t\t    if (!win_valid(curwin_save))\n\t\t\t\tbreak;\n\t\t\t    if (!GETFILE_SUCCESS(getfile(\n\t\t\t\t\t   curwin_save->w_buffer->b_fnum, NULL,\n\t\t\t\t\t\t     NULL, TRUE, lnum, FALSE)))\n\t\t\t\tbreak;\t// failed to jump to file\n\t\t\t}\n\t\t\telse\n#endif\n\t\t\t    setpcmark();\n\t\t\tcurwin->w_cursor.lnum = lnum;\n\t\t\tcheck_cursor();\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (!GETFILE_SUCCESS(getfile(\n\t\t\t\t\t0, files[depth].name, NULL, TRUE,\n\t\t\t\t\t\t    files[depth].lnum, FALSE)))\n\t\t\t    break;\t// failed to jump to file\n\t\t\t// autocommands may have changed the lnum, we don't\n\t\t\t// want that here\n\t\t\tcurwin->w_cursor.lnum = files[depth].lnum;\n\t\t    }\n\t\t}\n\t\tif (action != ACTION_SHOW)\n\t\t{\n\t\t    curwin->w_cursor.col = (colnr_T)(startp - line);\n\t\t    curwin->w_set_curswant = TRUE;\n\t\t}\n\n#if defined(FEAT_QUICKFIX)\n\t\tif (g_do_tagpreview != 0\n\t\t\t   && curwin != curwin_save && win_valid(curwin_save))\n\t\t{\n\t\t    // Return cursor to where we were\n\t\t    validate_cursor();\n\t\t    redraw_later(UPD_VALID);\n\t\t    win_enter(curwin_save, TRUE);\n\t\t}\n# ifdef FEAT_PROP_POPUP\n\t\telse if (WIN_IS_POPUP(curwin))\n\t\t    // can't keep focus in popup window\n\t\t    win_enter(firstwin, TRUE);\n# endif\n#endif\n\t\tbreak;\n\t    }\nexit_matched:\n\t    matched = FALSE;\n\t    // look for other matches in the rest of the line if we\n\t    // are not at the end of it already\n\t    if (def_regmatch.regprog == NULL\n\t\t    && action == ACTION_EXPAND\n\t\t    && !compl_status_sol()\n\t\t    && *startp != NUL\n\t\t    && *(p = startp + mb_ptr2len(startp)) != NUL)\n\t\tgoto search_line;\n\t}\n\tline_breakcheck();\n\tif (action == ACTION_EXPAND)\n\t    ins_compl_check_keys(30, FALSE);\n\tif (got_int || ins_compl_interrupted())\n\t    break;\n\n\t/*\n\t * Read the next line.  When reading an included file and encountering\n\t * end-of-file, close the file and continue in the file that included\n\t * it.\n\t */\n\twhile (depth >= 0 && !already\n\t\t&& vim_fgets(line = file_line, LSIZE, files[depth].fp))\n\t{\n\t    fclose(files[depth].fp);\n\t    --old_files;\n\t    files[old_files].name = files[depth].name;\n\t    files[old_files].matched = files[depth].matched;\n\t    --depth;\n\t    curr_fname = (depth == -1) ? curbuf->b_fname\n\t\t\t\t       : files[depth].name;\n\t    if (depth < depth_displayed)\n\t\tdepth_displayed = depth;\n\t}\n\tif (depth >= 0)\t\t// we could read the line\n\t{\n\t    files[depth].lnum++;\n\t    // Remove any CR and LF from the line.\n\t    i = (int)STRLEN(line);\n\t    if (i > 0 && line[i - 1] == '\\n')\n\t\tline[--i] = NUL;\n\t    if (i > 0 && line[i - 1] == '\\r')\n\t\tline[--i] = NUL;\n\t}\n\telse if (!already)\n\t{\n\t    if (++lnum > end_lnum)\n\t\tbreak;\n\t    line = get_line_and_copy(lnum, file_line);\n\t}\n\talready = NULL;\n    }\n    // End of big for (;;) loop.\n\n    // Close any files that are still open.\n    for (i = 0; i <= depth; i++)\n    {\n\tfclose(files[i].fp);\n\tvim_free(files[i].name);\n    }\n    for (i = old_files; i < max_path_depth; i++)\n\tvim_free(files[i].name);\n    vim_free(files);\n\n    if (type == CHECK_PATH)\n    {\n\tif (!did_show)\n\t{\n\t    if (action != ACTION_SHOW_ALL)\n\t\tmsg(_(\"All included files were found\"));\n\t    else\n\t\tmsg(_(\"No included files\"));\n\t}\n    }\n    else if (!found && action != ACTION_EXPAND)\n    {\n\tif (got_int || ins_compl_interrupted())\n\t    emsg(_(e_interrupted));\n\telse if (type == FIND_DEFINE)\n\t    emsg(_(e_couldnt_find_definition));\n\telse\n\t    emsg(_(e_couldnt_find_pattern));\n    }\n    if (action == ACTION_SHOW || action == ACTION_SHOW_ALL)\n\tmsg_end();\n\nfpip_end:\n    vim_free(file_line);\n    vim_regfree(regmatch.regprog);\n    vim_regfree(incl_regmatch.regprog);\n    vim_regfree(def_regmatch.regprog);\n}\n\n    static void\nshow_pat_in_path(\n    char_u  *line,\n    int\t    type,\n    int\t    did_show,\n    int\t    action,\n    FILE    *fp,\n    linenr_T *lnum,\n    long    count)\n{\n    char_u  *p;\n\n    if (did_show)\n\tmsg_putchar('\\n');\t// cursor below last one\n    else if (!msg_silent)\n\tgotocmdline(TRUE);\t// cursor at status line\n    if (got_int)\t\t// 'q' typed at \"--more--\" message\n\treturn;\n    for (;;)\n    {\n\tp = line + STRLEN(line) - 1;\n\tif (fp != NULL)\n\t{\n\t    // We used fgets(), so get rid of newline at end\n\t    if (p >= line && *p == '\\n')\n\t\t--p;\n\t    if (p >= line && *p == '\\r')\n\t\t--p;\n\t    *(p + 1) = NUL;\n\t}\n\tif (action == ACTION_SHOW_ALL)\n\t{\n\t    sprintf((char *)IObuff, \"%3ld: \", count);\t// show match nr\n\t    msg_puts((char *)IObuff);\n\t    sprintf((char *)IObuff, \"%4ld\", *lnum);\t// show line nr\n\t\t\t\t\t\t// Highlight line numbers\n\t    msg_puts_attr((char *)IObuff, HL_ATTR(HLF_N));\n\t    msg_puts(\" \");\n\t}\n\tmsg_prt_line(line, FALSE);\n\tout_flush();\t\t\t// show one line at a time\n\n\t// Definition continues until line that doesn't end with '\\'\n\tif (got_int || type != FIND_DEFINE || p < line || *p != '\\\\')\n\t    break;\n\n\tif (fp != NULL)\n\t{\n\t    if (vim_fgets(line, LSIZE, fp)) // end of file\n\t\tbreak;\n\t    ++*lnum;\n\t}\n\telse\n\t{\n\t    if (++*lnum > curbuf->b_ml.ml_line_count)\n\t\tbreak;\n\t    line = ml_get(*lnum);\n\t}\n\tmsg_putchar('\\n');\n    }\n}\n#endif\n\n#ifdef FEAT_VIMINFO\n/*\n * Return the last used search pattern at \"idx\".\n */\n    spat_T *\nget_spat(int idx)\n{\n    return &spats[idx];\n}\n\n/*\n * Return the last used search pattern index.\n */\n    int\nget_spat_last_idx(void)\n{\n    return last_idx;\n}\n#endif\n\n#if defined(FEAT_EVAL) || defined(FEAT_PROTO)\n/*\n * \"searchcount()\" function\n */\n    void\nf_searchcount(typval_T *argvars, typval_T *rettv)\n{\n    pos_T\t\tpos = curwin->w_cursor;\n    char_u\t\t*pattern = NULL;\n    int\t\t\tmaxcount = SEARCH_STAT_DEF_MAX_COUNT;\n    long\t\ttimeout = SEARCH_STAT_DEF_TIMEOUT;\n    int\t\t\trecompute = TRUE;\n    searchstat_T\tstat;\n\n    if (rettv_dict_alloc(rettv) == FAIL)\n\treturn;\n\n    if (in_vim9script() && check_for_opt_dict_arg(argvars, 0) == FAIL)\n\treturn;\n\n    if (shortmess(SHM_SEARCHCOUNT))\t// 'shortmess' contains 'S' flag\n\trecompute = TRUE;\n\n    if (argvars[0].v_type != VAR_UNKNOWN)\n    {\n\tdict_T\t\t*dict;\n\tdictitem_T\t*di;\n\tlistitem_T\t*li;\n\tint\t\terror = FALSE;\n\n\tif (check_for_nonnull_dict_arg(argvars, 0) == FAIL)\n\t    return;\n\tdict = argvars[0].vval.v_dict;\n\tdi = dict_find(dict, (char_u *)\"timeout\", -1);\n\tif (di != NULL)\n\t{\n\t    timeout = (long)tv_get_number_chk(&di->di_tv, &error);\n\t    if (error)\n\t\treturn;\n\t}\n\tdi = dict_find(dict, (char_u *)\"maxcount\", -1);\n\tif (di != NULL)\n\t{\n\t    maxcount = (int)tv_get_number_chk(&di->di_tv, &error);\n\t    if (error)\n\t\treturn;\n\t}\n\trecompute = dict_get_bool(dict, \"recompute\", recompute);\n\tdi = dict_find(dict, (char_u *)\"pattern\", -1);\n\tif (di != NULL)\n\t{\n\t    pattern = tv_get_string_chk(&di->di_tv);\n\t    if (pattern == NULL)\n\t\treturn;\n\t}\n\tdi = dict_find(dict, (char_u *)\"pos\", -1);\n\tif (di != NULL)\n\t{\n\t    if (di->di_tv.v_type != VAR_LIST)\n\t    {\n\t\tsemsg(_(e_invalid_argument_str), \"pos\");\n\t\treturn;\n\t    }\n\t    if (list_len(di->di_tv.vval.v_list) != 3)\n\t    {\n\t\tsemsg(_(e_invalid_argument_str), \"List format should be [lnum, col, off]\");\n\t\treturn;\n\t    }\n\t    li = list_find(di->di_tv.vval.v_list, 0L);\n\t    if (li != NULL)\n\t    {\n\t\tpos.lnum = tv_get_number_chk(&li->li_tv, &error);\n\t\tif (error)\n\t\t    return;\n\t    }\n\t    li = list_find(di->di_tv.vval.v_list, 1L);\n\t    if (li != NULL)\n\t    {\n\t\tpos.col = tv_get_number_chk(&li->li_tv, &error) - 1;\n\t\tif (error)\n\t\t    return;\n\t    }\n\t    li = list_find(di->di_tv.vval.v_list, 2L);\n\t    if (li != NULL)\n\t    {\n\t\tpos.coladd = tv_get_number_chk(&li->li_tv, &error);\n\t\tif (error)\n\t\t    return;\n\t    }\n\t}\n    }\n\n    save_last_search_pattern();\n#ifdef FEAT_SEARCH_EXTRA\n    save_incsearch_state();\n#endif\n    if (pattern != NULL)\n    {\n\tif (*pattern == NUL)\n\t    goto the_end;\n\tvim_free(spats[last_idx].pat);\n\tspats[last_idx].pat = vim_strsave(pattern);\n    }\n    if (spats[last_idx].pat == NULL || *spats[last_idx].pat == NUL)\n\tgoto the_end;\t// the previous pattern was never defined\n\n    update_search_stat(0, &pos, &pos, &stat, recompute, maxcount, timeout);\n\n    dict_add_number(rettv->vval.v_dict, \"current\", stat.cur);\n    dict_add_number(rettv->vval.v_dict, \"total\", stat.cnt);\n    dict_add_number(rettv->vval.v_dict, \"exact_match\", stat.exact_match);\n    dict_add_number(rettv->vval.v_dict, \"incomplete\", stat.incomplete);\n    dict_add_number(rettv->vval.v_dict, \"maxcount\", stat.last_maxcount);\n\nthe_end:\n    restore_last_search_pattern();\n#ifdef FEAT_SEARCH_EXTRA\n    restore_incsearch_state();\n#endif\n}\n#endif\n\n/*\n * Fuzzy string matching\n *\n * Ported from the lib_fts library authored by Forrest Smith.\n * https://github.com/forrestthewoods/lib_fts/tree/master/code\n *\n * The following blog describes the fuzzy matching algorithm:\n * https://www.forrestthewoods.com/blog/reverse_engineering_sublime_texts_fuzzy_match/\n *\n * Each matching string is assigned a score. The following factors are checked:\n *   - Matched letter\n *   - Unmatched letter\n *   - Consecutively matched letters\n *   - Proximity to start\n *   - Letter following a separator (space, underscore)\n *   - Uppercase letter following lowercase (aka CamelCase)\n *\n * Matched letters are good. Unmatched letters are bad. Matching near the start\n * is good. Matching the first letter in the middle of a phrase is good.\n * Matching the uppercase letters in camel case entries is good.\n *\n * The score assigned for each factor is explained below.\n * File paths are different from file names. File extensions may be ignorable.\n * Single words care about consecutive matches but not separators or camel\n * case.\n *   Score starts at 100\n *   Matched letter: +0 points\n *   Unmatched letter: -1 point\n *   Consecutive match bonus: +15 points\n *   First letter bonus: +15 points\n *   Separator bonus: +30 points\n *   Camel case bonus: +30 points\n *   Unmatched leading letter: -5 points (max: -15)\n *\n * There is some nuance to this. Scores don\u2019t have an intrinsic meaning. The\n * score range isn\u2019t 0 to 100. It\u2019s roughly [50, 150]. Longer words have a\n * lower minimum score due to unmatched letter penalty. Longer search patterns\n * have a higher maximum score due to match bonuses.\n *\n * Separator and camel case bonus is worth a LOT. Consecutive matches are worth\n * quite a bit.\n *\n * There is a penalty if you DON\u2019T match the first three letters. Which\n * effectively rewards matching near the start. However there\u2019s no difference\n * in matching between the middle and end.\n *\n * There is not an explicit bonus for an exact match. Unmatched letters receive\n * a penalty. So shorter strings and closer matches are worth more.\n */\ntypedef struct\n{\n    int\t\tidx;\t\t// used for stable sort\n    listitem_T\t*item;\n    int\t\tscore;\n    list_T\t*lmatchpos;\n} fuzzyItem_T;\n\n// bonus for adjacent matches; this is higher than SEPARATOR_BONUS so that\n// matching a whole word is preferred.\n#define SEQUENTIAL_BONUS 40\n// bonus if match occurs after a path separator\n#define PATH_SEPARATOR_BONUS 30\n// bonus if match occurs after a word separator\n#define WORD_SEPARATOR_BONUS 25\n// bonus if match is uppercase and prev is lower\n#define CAMEL_BONUS 30\n// bonus if the first letter is matched\n#define FIRST_LETTER_BONUS 15\n// penalty applied for every letter in str before the first match\n#define LEADING_LETTER_PENALTY (-5)\n// maximum penalty for leading letters\n#define MAX_LEADING_LETTER_PENALTY (-15)\n// penalty for every letter that doesn't match\n#define UNMATCHED_LETTER_PENALTY (-1)\n// penalty for gap in matching positions (-2 * k)\n#define GAP_PENALTY\t(-2)\n// Score for a string that doesn't fuzzy match the pattern\n#define SCORE_NONE\t(-9999)\n\n#define FUZZY_MATCH_RECURSION_LIMIT\t10\n\n/*\n * Compute a score for a fuzzy matched string. The matching character locations\n * are in 'matches'.\n */\n    static int\nfuzzy_match_compute_score(\n\tchar_u\t\t*str,\n\tint\t\tstrSz,\n\tint_u\t\t*matches,\n\tint\t\tnumMatches)\n{\n    int\t\tscore;\n    int\t\tpenalty;\n    int\t\tunmatched;\n    int\t\ti;\n    char_u\t*p = str;\n    int_u\tsidx = 0;\n\n    // Initialize score\n    score = 100;\n\n    // Apply leading letter penalty\n    penalty = LEADING_LETTER_PENALTY * matches[0];\n    if (penalty < MAX_LEADING_LETTER_PENALTY)\n\tpenalty = MAX_LEADING_LETTER_PENALTY;\n    score += penalty;\n\n    // Apply unmatched penalty\n    unmatched = strSz - numMatches;\n    score += UNMATCHED_LETTER_PENALTY * unmatched;\n\n    // Apply ordering bonuses\n    for (i = 0; i < numMatches; ++i)\n    {\n\tint_u\tcurrIdx = matches[i];\n\n\tif (i > 0)\n\t{\n\t    int_u\tprevIdx = matches[i - 1];\n\n\t    // Sequential\n\t    if (currIdx == (prevIdx + 1))\n\t\tscore += SEQUENTIAL_BONUS;\n\t    else\n\t\tscore += GAP_PENALTY * (currIdx - prevIdx);\n\t}\n\n\t// Check for bonuses based on neighbor character value\n\tif (currIdx > 0)\n\t{\n\t    // Camel case\n\t    int\tneighbor = ' ';\n\t    int\tcurr;\n\n\t    if (has_mbyte)\n\t    {\n\t\twhile (sidx < currIdx)\n\t\t{\n\t\t    neighbor = (*mb_ptr2char)(p);\n\t\t    MB_PTR_ADV(p);\n\t\t    sidx++;\n\t\t}\n\t\tcurr = (*mb_ptr2char)(p);\n\t    }\n\t    else\n\t    {\n\t\tneighbor = str[currIdx - 1];\n\t\tcurr = str[currIdx];\n\t    }\n\n\t    if (vim_islower(neighbor) && vim_isupper(curr))\n\t\tscore += CAMEL_BONUS;\n\n\t    // Bonus if the match follows a separator character\n\t    if (neighbor == '/' || neighbor == '\\\\')\n\t\tscore += PATH_SEPARATOR_BONUS;\n\t    else if (neighbor == ' ' || neighbor == '_')\n\t\tscore += WORD_SEPARATOR_BONUS;\n\t}\n\telse\n\t{\n\t    // First letter\n\t    score += FIRST_LETTER_BONUS;\n\t}\n    }\n    return score;\n}\n\n/*\n * Perform a recursive search for fuzzy matching 'fuzpat' in 'str'.\n * Return the number of matching characters.\n */\n    static int\nfuzzy_match_recursive(\n\tchar_u\t\t*fuzpat,\n\tchar_u\t\t*str,\n\tint_u\t\tstrIdx,\n\tint\t\t*outScore,\n\tchar_u\t\t*strBegin,\n\tint\t\tstrLen,\n\tint_u\t\t*srcMatches,\n\tint_u\t\t*matches,\n\tint\t\tmaxMatches,\n\tint\t\tnextMatch,\n\tint\t\t*recursionCount)\n{\n    // Recursion params\n    int\t\trecursiveMatch = FALSE;\n    int_u\tbestRecursiveMatches[MAX_FUZZY_MATCHES];\n    int\t\tbestRecursiveScore = 0;\n    int\t\tfirst_match;\n    int\t\tmatched;\n\n    // Count recursions\n    ++*recursionCount;\n    if (*recursionCount >= FUZZY_MATCH_RECURSION_LIMIT)\n\treturn 0;\n\n    // Detect end of strings\n    if (*fuzpat == NUL || *str == NUL)\n\treturn 0;\n\n    // Loop through fuzpat and str looking for a match\n    first_match = TRUE;\n    while (*fuzpat != NUL && *str != NUL)\n    {\n\tint\tc1;\n\tint\tc2;\n\n\tc1 = PTR2CHAR(fuzpat);\n\tc2 = PTR2CHAR(str);\n\n\t// Found match\n\tif (vim_tolower(c1) == vim_tolower(c2))\n\t{\n\t    // Supplied matches buffer was too short\n\t    if (nextMatch >= maxMatches)\n\t\treturn 0;\n\n\t    int\t\trecursiveScore = 0;\n\t    int_u\trecursiveMatches[MAX_FUZZY_MATCHES];\n\t    CLEAR_FIELD(recursiveMatches);\n\n\t    // \"Copy-on-Write\" srcMatches into matches\n\t    if (first_match && srcMatches)\n\t    {\n\t\tmemcpy(matches, srcMatches, nextMatch * sizeof(srcMatches[0]));\n\t\tfirst_match = FALSE;\n\t    }\n\n\t    // Recursive call that \"skips\" this match\n\t    char_u *next_char = str + (has_mbyte ? (*mb_ptr2len)(str) : 1);\n\t    if (fuzzy_match_recursive(fuzpat, next_char, strIdx + 1,\n\t\t\t&recursiveScore, strBegin, strLen, matches,\n\t\t\trecursiveMatches,\n\t\t\tARRAY_LENGTH(recursiveMatches),\n\t\t\tnextMatch, recursionCount))\n\t    {\n\t\t// Pick best recursive score\n\t\tif (!recursiveMatch || recursiveScore > bestRecursiveScore)\n\t\t{\n\t\t    memcpy(bestRecursiveMatches, recursiveMatches,\n\t\t\t    MAX_FUZZY_MATCHES * sizeof(recursiveMatches[0]));\n\t\t    bestRecursiveScore = recursiveScore;\n\t\t}\n\t\trecursiveMatch = TRUE;\n\t    }\n\n\t    // Advance\n\t    matches[nextMatch++] = strIdx;\n\t    if (has_mbyte)\n\t\tMB_PTR_ADV(fuzpat);\n\t    else\n\t\t++fuzpat;\n\t}\n\tif (has_mbyte)\n\t    MB_PTR_ADV(str);\n\telse\n\t    ++str;\n\tstrIdx++;\n    }\n\n    // Determine if full fuzpat was matched\n    matched = *fuzpat == NUL ? TRUE : FALSE;\n\n    // Calculate score\n    if (matched)\n\t*outScore = fuzzy_match_compute_score(strBegin, strLen, matches,\n\t\tnextMatch);\n\n    // Return best result\n    if (recursiveMatch && (!matched || bestRecursiveScore > *outScore))\n    {\n\t// Recursive score is better than \"this\"\n\tmemcpy(matches, bestRecursiveMatches, maxMatches * sizeof(matches[0]));\n\t*outScore = bestRecursiveScore;\n\treturn nextMatch;\n    }\n    else if (matched)\n\treturn nextMatch;\t// \"this\" score is better than recursive\n\n    return 0;\t\t// no match\n}\n\n/*\n * fuzzy_match()\n *\n * Performs exhaustive search via recursion to find all possible matches and\n * match with highest score.\n * Scores values have no intrinsic meaning.  Possible score range is not\n * normalized and varies with pattern.\n * Recursion is limited internally (default=10) to prevent degenerate cases\n * (pat_arg=\"aaaaaa\" str=\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\").\n * Uses char_u for match indices. Therefore patterns are limited to\n * MAX_FUZZY_MATCHES characters.\n *\n * Returns TRUE if \"pat_arg\" matches \"str\". Also returns the match score in\n * \"outScore\" and the matching character positions in \"matches\".\n */\n    int\nfuzzy_match(\n\tchar_u\t\t*str,\n\tchar_u\t\t*pat_arg,\n\tint\t\tmatchseq,\n\tint\t\t*outScore,\n\tint_u\t\t*matches,\n\tint\t\tmaxMatches)\n{\n    int\t\trecursionCount = 0;\n    int\t\tlen = MB_CHARLEN(str);\n    char_u\t*save_pat;\n    char_u\t*pat;\n    char_u\t*p;\n    int\t\tcomplete = FALSE;\n    int\t\tscore = 0;\n    int\t\tnumMatches = 0;\n    int\t\tmatchCount;\n\n    *outScore = 0;\n\n    save_pat = vim_strsave(pat_arg);\n    if (save_pat == NULL)\n\treturn FALSE;\n    pat = save_pat;\n    p = pat;\n\n    // Try matching each word in 'pat_arg' in 'str'\n    while (TRUE)\n    {\n\tif (matchseq)\n\t    complete = TRUE;\n\telse\n\t{\n\t    // Extract one word from the pattern (separated by space)\n\t    p = skipwhite(p);\n\t    if (*p == NUL)\n\t\tbreak;\n\t    pat = p;\n\t    while (*p != NUL && !VIM_ISWHITE(PTR2CHAR(p)))\n\t    {\n\t\tif (has_mbyte)\n\t\t    MB_PTR_ADV(p);\n\t\telse\n\t\t    ++p;\n\t    }\n\t    if (*p == NUL)\t\t// processed all the words\n\t\tcomplete = TRUE;\n\t    *p = NUL;\n\t}\n\n\tscore = 0;\n\trecursionCount = 0;\n\tmatchCount = fuzzy_match_recursive(pat, str, 0, &score, str, len, NULL,\n\t\t\t\tmatches + numMatches, maxMatches - numMatches,\n\t\t\t\t0, &recursionCount);\n\tif (matchCount == 0)\n\t{\n\t    numMatches = 0;\n\t    break;\n\t}\n\n\t// Accumulate the match score and the number of matches\n\t*outScore += score;\n\tnumMatches += matchCount;\n\n\tif (complete)\n\t    break;\n\n\t// try matching the next word\n\t++p;\n    }\n\n    vim_free(save_pat);\n    return numMatches != 0;\n}\n\n#if defined(FEAT_EVAL) || defined(FEAT_PROTO)\n/*\n * Sort the fuzzy matches in the descending order of the match score.\n * For items with same score, retain the order using the index (stable sort)\n */\n    static int\nfuzzy_match_item_compare(const void *s1, const void *s2)\n{\n    int\t\tv1 = ((fuzzyItem_T *)s1)->score;\n    int\t\tv2 = ((fuzzyItem_T *)s2)->score;\n    int\t\tidx1 = ((fuzzyItem_T *)s1)->idx;\n    int\t\tidx2 = ((fuzzyItem_T *)s2)->idx;\n\n    return v1 == v2 ? (idx1 - idx2) : v1 > v2 ? -1 : 1;\n}\n\n/*\n * Fuzzy search the string 'str' in a list of 'items' and return the matching\n * strings in 'fmatchlist'.\n * If 'matchseq' is TRUE, then for multi-word search strings, match all the\n * words in sequence.\n * If 'items' is a list of strings, then search for 'str' in the list.\n * If 'items' is a list of dicts, then either use 'key' to lookup the string\n * for each item or use 'item_cb' Funcref function to get the string.\n * If 'retmatchpos' is TRUE, then return a list of positions where 'str'\n * matches for each item.\n */\n    static void\nfuzzy_match_in_list(\n\tlist_T\t\t*l,\n\tchar_u\t\t*str,\n\tint\t\tmatchseq,\n\tchar_u\t\t*key,\n\tcallback_T\t*item_cb,\n\tint\t\tretmatchpos,\n\tlist_T\t\t*fmatchlist,\n\tlong\t\tmax_matches)\n{\n    long\tlen;\n    fuzzyItem_T\t*items;\n    listitem_T\t*li;\n    long\ti = 0;\n    long\tmatch_count = 0;\n    int_u\tmatches[MAX_FUZZY_MATCHES];\n\n    len = list_len(l);\n    if (len == 0)\n\treturn;\n    if (max_matches > 0 && len > max_matches)\n\tlen = max_matches;\n\n    items = ALLOC_CLEAR_MULT(fuzzyItem_T, len);\n    if (items == NULL)\n\treturn;\n\n    // For all the string items in items, get the fuzzy matching score\n    FOR_ALL_LIST_ITEMS(l, li)\n    {\n\tint\t\tscore;\n\tchar_u\t\t*itemstr;\n\ttypval_T\trettv;\n\n\tif (max_matches > 0 && match_count >= max_matches)\n\t    break;\n\n\titemstr = NULL;\n\trettv.v_type = VAR_UNKNOWN;\n\tif (li->li_tv.v_type == VAR_STRING)\t// list of strings\n\t    itemstr = li->li_tv.vval.v_string;\n\telse if (li->li_tv.v_type == VAR_DICT\n\t\t\t\t&& (key != NULL || item_cb->cb_name != NULL))\n\t{\n\t    // For a dict, either use the specified key to lookup the string or\n\t    // use the specified callback function to get the string.\n\t    if (key != NULL)\n\t\titemstr = dict_get_string(li->li_tv.vval.v_dict,\n\t\t\t\t\t\t\t   (char *)key, FALSE);\n\t    else\n\t    {\n\t\ttypval_T\targv[2];\n\n\t\t// Invoke the supplied callback (if any) to get the dict item\n\t\tli->li_tv.vval.v_dict->dv_refcount++;\n\t\targv[0].v_type = VAR_DICT;\n\t\targv[0].vval.v_dict = li->li_tv.vval.v_dict;\n\t\targv[1].v_type = VAR_UNKNOWN;\n\t\tif (call_callback(item_cb, -1, &rettv, 1, argv) != FAIL)\n\t\t{\n\t\t    if (rettv.v_type == VAR_STRING)\n\t\t\titemstr = rettv.vval.v_string;\n\t\t}\n\t\tdict_unref(li->li_tv.vval.v_dict);\n\t    }\n\t}\n\n\tif (itemstr != NULL\n\t\t&& fuzzy_match(itemstr, str, matchseq, &score, matches,\n\t\t\t\t\t\t\tMAX_FUZZY_MATCHES))\n\t{\n\t    items[match_count].idx = match_count;\n\t    items[match_count].item = li;\n\t    items[match_count].score = score;\n\n\t    // Copy the list of matching positions in itemstr to a list, if\n\t    // 'retmatchpos' is set.\n\t    if (retmatchpos)\n\t    {\n\t\tint\tj = 0;\n\t\tchar_u\t*p;\n\n\t\titems[match_count].lmatchpos = list_alloc();\n\t\tif (items[match_count].lmatchpos == NULL)\n\t\t    goto done;\n\n\t\tp = str;\n\t\twhile (*p != NUL)\n\t\t{\n\t\t    if (!VIM_ISWHITE(PTR2CHAR(p)) || matchseq)\n\t\t    {\n\t\t\tif (list_append_number(items[match_count].lmatchpos,\n\t\t\t\t    matches[j]) == FAIL)\n\t\t\t    goto done;\n\t\t\tj++;\n\t\t    }\n\t\t    if (has_mbyte)\n\t\t\tMB_PTR_ADV(p);\n\t\t    else\n\t\t\t++p;\n\t\t}\n\t    }\n\t    ++match_count;\n\t}\n\tclear_tv(&rettv);\n    }\n\n    if (match_count > 0)\n    {\n\tlist_T\t\t*retlist;\n\n\t// Sort the list by the descending order of the match score\n\tqsort((void *)items, (size_t)match_count, sizeof(fuzzyItem_T),\n\t\tfuzzy_match_item_compare);\n\n\t// For matchfuzzy(), return a list of matched strings.\n\t//\t    ['str1', 'str2', 'str3']\n\t// For matchfuzzypos(), return a list with three items.\n\t// The first item is a list of matched strings. The second item\n\t// is a list of lists where each list item is a list of matched\n\t// character positions. The third item is a list of matching scores.\n\t//\t[['str1', 'str2', 'str3'], [[1, 3], [1, 3], [1, 3]]]\n\tif (retmatchpos)\n\t{\n\t    li = list_find(fmatchlist, 0);\n\t    if (li == NULL || li->li_tv.vval.v_list == NULL)\n\t\tgoto done;\n\t    retlist = li->li_tv.vval.v_list;\n\t}\n\telse\n\t    retlist = fmatchlist;\n\n\t// Copy the matching strings with a valid score to the return list\n\tfor (i = 0; i < match_count; i++)\n\t{\n\t    if (items[i].score == SCORE_NONE)\n\t\tbreak;\n\t    list_append_tv(retlist, &items[i].item->li_tv);\n\t}\n\n\t// next copy the list of matching positions\n\tif (retmatchpos)\n\t{\n\t    li = list_find(fmatchlist, -2);\n\t    if (li == NULL || li->li_tv.vval.v_list == NULL)\n\t\tgoto done;\n\t    retlist = li->li_tv.vval.v_list;\n\n\t    for (i = 0; i < match_count; i++)\n\t    {\n\t\tif (items[i].score == SCORE_NONE)\n\t\t    break;\n\t\tif (items[i].lmatchpos != NULL\n\t\t      && list_append_list(retlist, items[i].lmatchpos) == FAIL)\n\t\t    goto done;\n\t    }\n\n\t    // copy the matching scores\n\t    li = list_find(fmatchlist, -1);\n\t    if (li == NULL || li->li_tv.vval.v_list == NULL)\n\t\tgoto done;\n\t    retlist = li->li_tv.vval.v_list;\n\t    for (i = 0; i < match_count; i++)\n\t    {\n\t\tif (items[i].score == SCORE_NONE)\n\t\t    break;\n\t\tif (list_append_number(retlist, items[i].score) == FAIL)\n\t\t    goto done;\n\t    }\n\t}\n    }\n\ndone:\n    vim_free(items);\n}\n\n/*\n * Do fuzzy matching. Returns the list of matched strings in 'rettv'.\n * If 'retmatchpos' is TRUE, also returns the matching character positions.\n */\n    static void\ndo_fuzzymatch(typval_T *argvars, typval_T *rettv, int retmatchpos)\n{\n    callback_T\tcb;\n    char_u\t*key = NULL;\n    int\t\tret;\n    int\t\tmatchseq = FALSE;\n    long\tmax_matches = 0;\n\n    if (in_vim9script()\n\t    && (check_for_list_arg(argvars, 0) == FAIL\n\t\t|| check_for_string_arg(argvars, 1) == FAIL\n\t\t|| check_for_opt_dict_arg(argvars, 2) == FAIL))\n\treturn;\n\n    CLEAR_POINTER(&cb);\n\n    // validate and get the arguments\n    if (argvars[0].v_type != VAR_LIST || argvars[0].vval.v_list == NULL)\n    {\n\tsemsg(_(e_argument_of_str_must_be_list),\n\t\t\t     retmatchpos ? \"matchfuzzypos()\" : \"matchfuzzy()\");\n\treturn;\n    }\n    if (argvars[1].v_type != VAR_STRING\n\t    || argvars[1].vval.v_string == NULL)\n    {\n\tsemsg(_(e_invalid_argument_str), tv_get_string(&argvars[1]));\n\treturn;\n    }\n\n    if (argvars[2].v_type != VAR_UNKNOWN)\n    {\n\tdict_T\t\t*d;\n\tdictitem_T\t*di;\n\n\tif (check_for_nonnull_dict_arg(argvars, 2) == FAIL)\n\t    return;\n\n\t// To search a dict, either a callback function or a key can be\n\t// specified.\n\td = argvars[2].vval.v_dict;\n\tif ((di = dict_find(d, (char_u *)\"key\", -1)) != NULL)\n\t{\n\t    if (di->di_tv.v_type != VAR_STRING\n\t\t    || di->di_tv.vval.v_string == NULL\n\t\t    || *di->di_tv.vval.v_string == NUL)\n\t    {\n\t\tsemsg(_(e_invalid_argument_str), tv_get_string(&di->di_tv));\n\t\treturn;\n\t    }\n\t    key = tv_get_string(&di->di_tv);\n\t}\n\telse if ((di = dict_find(d, (char_u *)\"text_cb\", -1)) != NULL)\n\t{\n\t    cb = get_callback(&di->di_tv);\n\t    if (cb.cb_name == NULL)\n\t    {\n\t\tsemsg(_(e_invalid_value_for_argument_str), \"text_cb\");\n\t\treturn;\n\t    }\n\t}\n\n\tif ((di = dict_find(d, (char_u *)\"limit\", -1)) != NULL)\n\t{\n\t    if (di->di_tv.v_type != VAR_NUMBER)\n\t    {\n\t\tsemsg(_(e_invalid_argument_str), tv_get_string(&di->di_tv));\n\t\treturn;\n\t    }\n\t    max_matches = (long)tv_get_number_chk(&di->di_tv, NULL);\n\t}\n\n\tif (dict_has_key(d, \"matchseq\"))\n\t    matchseq = TRUE;\n    }\n\n    // get the fuzzy matches\n    ret = rettv_list_alloc(rettv);\n    if (ret == FAIL)\n\tgoto done;\n    if (retmatchpos)\n    {\n\tlist_T\t*l;\n\n\t// For matchfuzzypos(), a list with three items are returned. First\n\t// item is a list of matching strings, the second item is a list of\n\t// lists with matching positions within each string and the third item\n\t// is the list of scores of the matches.\n\tl = list_alloc();\n\tif (l == NULL)\n\t    goto done;\n\tif (list_append_list(rettv->vval.v_list, l) == FAIL)\n\t{\n\t    vim_free(l);\n\t    goto done;\n\t}\n\tl = list_alloc();\n\tif (l == NULL)\n\t    goto done;\n\tif (list_append_list(rettv->vval.v_list, l) == FAIL)\n\t{\n\t    vim_free(l);\n\t    goto done;\n\t}\n\tl = list_alloc();\n\tif (l == NULL)\n\t    goto done;\n\tif (list_append_list(rettv->vval.v_list, l) == FAIL)\n\t{\n\t    vim_free(l);\n\t    goto done;\n\t}\n    }\n\n    fuzzy_match_in_list(argvars[0].vval.v_list, tv_get_string(&argvars[1]),\n\t    matchseq, key, &cb, retmatchpos, rettv->vval.v_list, max_matches);\n\ndone:\n    free_callback(&cb);\n}\n\n/*\n * \"matchfuzzy()\" function\n */\n    void\nf_matchfuzzy(typval_T *argvars, typval_T *rettv)\n{\n    do_fuzzymatch(argvars, rettv, FALSE);\n}\n\n/*\n * \"matchfuzzypos()\" function\n */\n    void\nf_matchfuzzypos(typval_T *argvars, typval_T *rettv)\n{\n    do_fuzzymatch(argvars, rettv, TRUE);\n}\n#endif\n\n/*\n * Same as fuzzy_match_item_compare() except for use with a string match\n */\n    static int\nfuzzy_match_str_compare(const void *s1, const void *s2)\n{\n    int\t\tv1 = ((fuzmatch_str_T *)s1)->score;\n    int\t\tv2 = ((fuzmatch_str_T *)s2)->score;\n    int\t\tidx1 = ((fuzmatch_str_T *)s1)->idx;\n    int\t\tidx2 = ((fuzmatch_str_T *)s2)->idx;\n\n    return v1 == v2 ? (idx1 - idx2) : v1 > v2 ? -1 : 1;\n}\n\n/*\n * Sort fuzzy matches by score\n */\n    static void\nfuzzy_match_str_sort(fuzmatch_str_T *fm, int sz)\n{\n    // Sort the list by the descending order of the match score\n    qsort((void *)fm, (size_t)sz, sizeof(fuzmatch_str_T),\n\t    fuzzy_match_str_compare);\n}\n\n/*\n * Same as fuzzy_match_item_compare() except for use with a function name\n * string match. <SNR> functions should be sorted to the end.\n */\n    static int\nfuzzy_match_func_compare(const void *s1, const void *s2)\n{\n    int\t\tv1 = ((fuzmatch_str_T *)s1)->score;\n    int\t\tv2 = ((fuzmatch_str_T *)s2)->score;\n    int\t\tidx1 = ((fuzmatch_str_T *)s1)->idx;\n    int\t\tidx2 = ((fuzmatch_str_T *)s2)->idx;\n    char_u\t*str1 = ((fuzmatch_str_T *)s1)->str;\n    char_u\t*str2 = ((fuzmatch_str_T *)s2)->str;\n\n    if (*str1 != '<' && *str2 == '<') return -1;\n    if (*str1 == '<' && *str2 != '<') return 1;\n    return v1 == v2 ? (idx1 - idx2) : v1 > v2 ? -1 : 1;\n}\n\n/*\n * Sort fuzzy matches of function names by score.\n * <SNR> functions should be sorted to the end.\n */\n    static void\nfuzzy_match_func_sort(fuzmatch_str_T *fm, int sz)\n{\n    // Sort the list by the descending order of the match score\n    qsort((void *)fm, (size_t)sz, sizeof(fuzmatch_str_T),\n\t\tfuzzy_match_func_compare);\n}\n\n/*\n * Fuzzy match 'pat' in 'str'. Returns 0 if there is no match. Otherwise,\n * returns the match score.\n */\n    int\nfuzzy_match_str(char_u *str, char_u *pat)\n{\n    int\t\tscore = 0;\n    int_u\tmatchpos[MAX_FUZZY_MATCHES];\n\n    if (str == NULL || pat == NULL)\n\treturn 0;\n\n    fuzzy_match(str, pat, TRUE, &score, matchpos,\n\t\t\t\tsizeof(matchpos) / sizeof(matchpos[0]));\n\n    return score;\n}\n\n/*\n * Free an array of fuzzy string matches \"fuzmatch[count]\".\n */\n    void\nfuzmatch_str_free(fuzmatch_str_T *fuzmatch, int count)\n{\n    int i;\n\n    if (fuzmatch == NULL)\n\treturn;\n    for (i = 0; i < count; ++i)\n\tvim_free(fuzmatch[i].str);\n    vim_free(fuzmatch);\n}\n\n/*\n * Copy a list of fuzzy matches into a string list after sorting the matches by\n * the fuzzy score. Frees the memory allocated for 'fuzmatch'.\n * Returns OK on success and FAIL on memory allocation failure.\n */\n    int\nfuzzymatches_to_strmatches(\n\tfuzmatch_str_T\t*fuzmatch,\n\tchar_u\t\t***matches,\n\tint\t\tcount,\n\tint\t\tfuncsort)\n{\n    int\t\ti;\n\n    if (count <= 0)\n\treturn OK;\n\n    *matches = ALLOC_MULT(char_u *, count);\n    if (*matches == NULL)\n    {\n\tfuzmatch_str_free(fuzmatch, count);\n\treturn FAIL;\n    }\n\n    // Sort the list by the descending order of the match score\n    if (funcsort)\n\tfuzzy_match_func_sort((void *)fuzmatch, (size_t)count);\n    else\n\tfuzzy_match_str_sort((void *)fuzmatch, (size_t)count);\n\n    for (i = 0; i < count; i++)\n\t(*matches)[i] = fuzmatch[i].str;\n    vim_free(fuzmatch);\n\n    return OK;\n}\n", "\" Tests for fuzzy matching\n\nsource shared.vim\nsource check.vim\nsource term_util.vim\n\n\" Test for matchfuzzy()\nfunc Test_matchfuzzy()\n  call assert_fails('call matchfuzzy(10, \"abc\")', 'E686:')\n  call assert_fails('call matchfuzzy([\"abc\"], [])', 'E730:')\n  call assert_fails(\"let x = matchfuzzy(test_null_list(), 'foo')\", 'E686:')\n  call assert_fails('call matchfuzzy([\"abc\"], test_null_string())', 'E475:')\n  call assert_equal([], matchfuzzy([], 'abc'))\n  call assert_equal([], matchfuzzy(['abc'], ''))\n  call assert_equal(['abc'], matchfuzzy(['abc', 10], 'ac'))\n  call assert_equal([], matchfuzzy([10, 20], 'ac'))\n  call assert_equal(['abc'], matchfuzzy(['abc'], 'abc'))\n  call assert_equal(['crayon', 'camera'], matchfuzzy(['camera', 'crayon'], 'cra'))\n  call assert_equal(['aabbaa', 'aaabbbaaa', 'aaaabbbbaaaa', 'aba'], matchfuzzy(['aba', 'aabbaa', 'aaabbbaaa', 'aaaabbbbaaaa'], 'aa'))\n  call assert_equal(['one'], matchfuzzy(['one', 'two'], 'one'))\n  call assert_equal(['oneTwo', 'onetwo'], matchfuzzy(['onetwo', 'oneTwo'], 'oneTwo'))\n  call assert_equal(['onetwo', 'one_two'], matchfuzzy(['onetwo', 'one_two'], 'oneTwo'))\n  call assert_equal(['aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'], matchfuzzy(['aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'], 'aa'))\n  call assert_equal(256, matchfuzzy([repeat('a', 256)], repeat('a', 256))[0]->len())\n  call assert_equal([], matchfuzzy([repeat('a', 300)], repeat('a', 257)))\n  \" matches with same score should not be reordered\n  let l = ['abc1', 'abc2', 'abc3']\n  call assert_equal(l, l->matchfuzzy('abc'))\n\n  \" Tests for match preferences\n  \" preference for camel case match\n  call assert_equal(['oneTwo', 'onetwo'], ['onetwo', 'oneTwo']->matchfuzzy('onetwo'))\n  \" preference for match after a separator (_ or space)\n  call assert_equal(['onetwo', 'one_two', 'one two'], ['onetwo', 'one_two', 'one two']->matchfuzzy('onetwo'))\n  \" preference for leading letter match\n  call assert_equal(['onetwo', 'xonetwo'], ['xonetwo', 'onetwo']->matchfuzzy('onetwo'))\n  \" preference for sequential match\n  call assert_equal(['onetwo', 'oanbectdweo'], ['oanbectdweo', 'onetwo']->matchfuzzy('onetwo'))\n  \" non-matching leading letter(s) penalty\n  call assert_equal(['xonetwo', 'xxonetwo'], ['xxonetwo', 'xonetwo']->matchfuzzy('onetwo'))\n  \" total non-matching letter(s) penalty\n  call assert_equal(['one', 'onex', 'onexx'], ['onexx', 'one', 'onex']->matchfuzzy('one'))\n  \" prefer complete matches over separator matches\n  call assert_equal(['.vim/vimrc', '.vim/vimrc_colors', '.vim/v_i_m_r_c'], ['.vim/vimrc', '.vim/vimrc_colors', '.vim/v_i_m_r_c']->matchfuzzy('vimrc'))\n  \" gap penalty\n  call assert_equal(['xxayybxxxx', 'xxayyybxxx', 'xxayyyybxx'], ['xxayyyybxx', 'xxayyybxxx', 'xxayybxxxx']->matchfuzzy('ab'))\n  \" path separator vs word separator\n  call assert_equal(['color/setup.vim', 'color\\\\setup.vim', 'color setup.vim', 'color_setup.vim', 'colorsetup.vim'], matchfuzzy(['colorsetup.vim', 'color setup.vim', 'color/setup.vim', 'color_setup.vim', 'color\\\\setup.vim'], 'setup.vim'))\n\n  \" match multiple words (separated by space)\n  call assert_equal(['foo bar baz'], ['foo bar baz', 'foo', 'foo bar', 'baz bar']->matchfuzzy('baz foo'))\n  call assert_equal([], ['foo bar baz', 'foo', 'foo bar', 'baz bar']->matchfuzzy('one two'))\n  call assert_equal([], ['foo bar']->matchfuzzy(\" \\t \"))\n\n  \" test for matching a sequence of words\n  call assert_equal(['bar foo'], ['foo bar', 'bar foo', 'foobar', 'barfoo']->matchfuzzy('bar foo', {'matchseq' : 1}))\n  call assert_equal([#{text: 'two one'}], [#{text: 'one two'}, #{text: 'two one'}]->matchfuzzy('two one', #{key: 'text', matchseq: v:true}))\n\n  %bw!\n  eval ['somebuf', 'anotherone', 'needle', 'yetanotherone']->map({_, v -> bufadd(v) + bufload(v)})\n  let l = getbufinfo()->map({_, v -> fnamemodify(v.name, ':t')})->matchfuzzy('ndl')\n  call assert_equal(1, len(l))\n  call assert_match('needle', l[0])\n\n  \" Test for fuzzy matching dicts\n  let l = [{'id' : 5, 'val' : 'crayon'}, {'id' : 6, 'val' : 'camera'}]\n  call assert_equal([{'id' : 6, 'val' : 'camera'}], matchfuzzy(l, 'cam', {'text_cb' : {v -> v.val}}))\n  call assert_equal([{'id' : 6, 'val' : 'camera'}], matchfuzzy(l, 'cam', {'key' : 'val'}))\n  call assert_equal([], matchfuzzy(l, 'day', {'text_cb' : {v -> v.val}}))\n  call assert_equal([], matchfuzzy(l, 'day', {'key' : 'val'}))\n  call assert_fails(\"let x = matchfuzzy(l, 'cam', 'random')\", 'E1206:')\n  call assert_equal([], matchfuzzy(l, 'day', {'text_cb' : {v -> []}}))\n  call assert_equal([], matchfuzzy(l, 'day', {'text_cb' : {v -> 1}}))\n  call assert_fails(\"let x = matchfuzzy(l, 'day', {'text_cb' : {a, b -> 1}})\", 'E119:')\n  call assert_equal([], matchfuzzy(l, 'cam'))\n  call assert_fails(\"let x = matchfuzzy(l, 'cam', {'text_cb' : []})\", 'E921:')\n  call assert_fails(\"let x = matchfuzzy(l, 'foo', {'key' : []})\", 'E730:')\n  call assert_fails(\"let x = matchfuzzy(l, 'cam', test_null_dict())\", 'E1297:')\n  call assert_fails(\"let x = matchfuzzy(l, 'foo', {'key' : test_null_string()})\", 'E475:')\n  call assert_fails(\"let x = matchfuzzy(l, 'foo', {'text_cb' : test_null_function()})\", 'E475:')\n  \" matches with same score should not be reordered\n  let l = [#{text: 'abc', id: 1}, #{text: 'abc', id: 2}, #{text: 'abc', id: 3}]\n  call assert_equal(l, l->matchfuzzy('abc', #{key: 'text'}))\n\n  let l = [{'id' : 5, 'name' : 'foo'}, {'id' : 6, 'name' : []}, {'id' : 7}]\n  call assert_fails(\"let x = matchfuzzy(l, 'foo', {'key' : 'name'})\", 'E730:')\n\n  \" Test in latin1 encoding\n  let save_enc = &encoding\n  set encoding=latin1\n  call assert_equal(['abc'], matchfuzzy(['abc'], 'abc'))\n  let &encoding = save_enc\nendfunc\n\n\" Test for the matchfuzzypos() function\nfunc Test_matchfuzzypos()\n  call assert_equal([['curl', 'world'], [[2,3], [2,3]], [128, 127]], matchfuzzypos(['world', 'curl'], 'rl'))\n  call assert_equal([['curl', 'world'], [[2,3], [2,3]], [128, 127]], matchfuzzypos(['world', 'one', 'curl'], 'rl'))\n  call assert_equal([['hello', 'hello world hello world'],\n        \\ [[0, 1, 2, 3, 4], [0, 1, 2, 3, 4]], [275, 257]],\n        \\ matchfuzzypos(['hello world hello world', 'hello', 'world'], 'hello'))\n  call assert_equal([['aaaaaaa'], [[0, 1, 2]], [191]], matchfuzzypos(['aaaaaaa'], 'aaa'))\n  call assert_equal([['a  b'], [[0, 3]], [219]], matchfuzzypos(['a  b'], 'a  b'))\n  call assert_equal([['a  b'], [[0, 3]], [219]], matchfuzzypos(['a  b'], 'a    b'))\n  call assert_equal([['a  b'], [[0]], [112]], matchfuzzypos(['a  b'], '  a  '))\n  call assert_equal([[], [], []], matchfuzzypos(['a  b'], '  '))\n  call assert_equal([[], [], []], matchfuzzypos(['world', 'curl'], 'ab'))\n  let x = matchfuzzypos([repeat('a', 256)], repeat('a', 256))\n  call assert_equal(range(256), x[1][0])\n  call assert_equal([[], [], []], matchfuzzypos([repeat('a', 300)], repeat('a', 257)))\n  call assert_equal([[], [], []], matchfuzzypos([], 'abc'))\n\n  \" match in a long string\n  call assert_equal([[repeat('x', 300) .. 'abc'], [[300, 301, 302]], [-135]],\n        \\ matchfuzzypos([repeat('x', 300) .. 'abc'], 'abc'))\n\n  \" preference for camel case match\n  call assert_equal([['xabcxxaBc'], [[6, 7, 8]], [189]], matchfuzzypos(['xabcxxaBc'], 'abc'))\n  \" preference for match after a separator (_ or space)\n  call assert_equal([['xabx_ab'], [[5, 6]], [145]], matchfuzzypos(['xabx_ab'], 'ab'))\n  \" preference for leading letter match\n  call assert_equal([['abcxabc'], [[0, 1]], [150]], matchfuzzypos(['abcxabc'], 'ab'))\n  \" preference for sequential match\n  call assert_equal([['aobncedone'], [[7, 8, 9]], [158]], matchfuzzypos(['aobncedone'], 'one'))\n  \" best recursive match\n  call assert_equal([['xoone'], [[2, 3, 4]], [168]], matchfuzzypos(['xoone'], 'one'))\n\n  \" match multiple words (separated by space)\n  call assert_equal([['foo bar baz'], [[8, 9, 10, 0, 1, 2]], [369]], ['foo bar baz', 'foo', 'foo bar', 'baz bar']->matchfuzzypos('baz foo'))\n  call assert_equal([[], [], []], ['foo bar baz', 'foo', 'foo bar', 'baz bar']->matchfuzzypos('baz foo', {'matchseq': 1}))\n  call assert_equal([['foo bar baz'], [[0, 1, 2, 8, 9, 10]], [369]], ['foo bar baz', 'foo', 'foo bar', 'baz bar']->matchfuzzypos('foo baz'))\n  call assert_equal([['foo bar baz'], [[0, 1, 2, 3, 4, 5, 10]], [326]], ['foo bar baz', 'foo', 'foo bar', 'baz bar']->matchfuzzypos('foo baz', {'matchseq': 1}))\n  call assert_equal([[], [], []], ['foo bar baz', 'foo', 'foo bar', 'baz bar']->matchfuzzypos('one two'))\n  call assert_equal([[], [], []], ['foo bar']->matchfuzzypos(\" \\t \"))\n  call assert_equal([['grace'], [[1, 2, 3, 4, 2, 3, 4, 0, 1, 2, 3, 4]], [657]], ['grace']->matchfuzzypos('race ace grace'))\n\n  let l = [{'id' : 5, 'val' : 'crayon'}, {'id' : 6, 'val' : 'camera'}]\n  call assert_equal([[{'id' : 6, 'val' : 'camera'}], [[0, 1, 2]], [192]],\n        \\ matchfuzzypos(l, 'cam', {'text_cb' : {v -> v.val}}))\n  call assert_equal([[{'id' : 6, 'val' : 'camera'}], [[0, 1, 2]], [192]],\n        \\ matchfuzzypos(l, 'cam', {'key' : 'val'}))\n  call assert_equal([[], [], []], matchfuzzypos(l, 'day', {'text_cb' : {v -> v.val}}))\n  call assert_equal([[], [], []], matchfuzzypos(l, 'day', {'key' : 'val'}))\n  call assert_fails(\"let x = matchfuzzypos(l, 'cam', 'random')\", 'E1206:')\n  call assert_equal([[], [], []], matchfuzzypos(l, 'day', {'text_cb' : {v -> []}}))\n  call assert_equal([[], [], []], matchfuzzypos(l, 'day', {'text_cb' : {v -> 1}}))\n  call assert_fails(\"let x = matchfuzzypos(l, 'day', {'text_cb' : {a, b -> 1}})\", 'E119:')\n  call assert_equal([[], [], []], matchfuzzypos(l, 'cam'))\n  call assert_fails(\"let x = matchfuzzypos(l, 'cam', {'text_cb' : []})\", 'E921:')\n  call assert_fails(\"let x = matchfuzzypos(l, 'foo', {'key' : []})\", 'E730:')\n  call assert_fails(\"let x = matchfuzzypos(l, 'cam', test_null_dict())\", 'E1297:')\n  call assert_fails(\"let x = matchfuzzypos(l, 'foo', {'key' : test_null_string()})\", 'E475:')\n  call assert_fails(\"let x = matchfuzzypos(l, 'foo', {'text_cb' : test_null_function()})\", 'E475:')\n\n  let l = [{'id' : 5, 'name' : 'foo'}, {'id' : 6, 'name' : []}, {'id' : 7}]\n  call assert_fails(\"let x = matchfuzzypos(l, 'foo', {'key' : 'name'})\", 'E730:')\nendfunc\n\n\" Test for matchfuzzy() with multibyte characters\nfunc Test_matchfuzzy_mbyte()\n  CheckFeature multi_lang\n  call assert_equal(['\u30f3\u30f9\u3107\u30fa\u30f4'], matchfuzzy(['\u30f3\u30f9\u3107\u30fa\u30f4'], '\u30f9\u30fa'))\n  \" reverse the order of characters\n  call assert_equal([], matchfuzzy(['\u30f3\u30f9\u3107\u30fa\u30f4'], '\u30fa\u30f9'))\n  call assert_equal(['\u03b1\u03b2\u03a9xxx', 'x\u03b1x\u03b2x\u03a9x'],\n        \\ matchfuzzy(['\u03b1\u03b2\u03a9xxx', 'x\u03b1x\u03b2x\u03a9x'], '\u03b1\u03b2\u03a9'))\n  call assert_equal(['\u03c0\u03c0bb\u03c0\u03c0', '\u03c0\u03c0\u03c0bbb\u03c0\u03c0\u03c0', '\u03c0\u03c0\u03c0\u03c0bbbb\u03c0\u03c0\u03c0\u03c0', '\u03c0b\u03c0'],\n        \\ matchfuzzy(['\u03c0b\u03c0', '\u03c0\u03c0bb\u03c0\u03c0', '\u03c0\u03c0\u03c0bbb\u03c0\u03c0\u03c0', '\u03c0\u03c0\u03c0\u03c0bbbb\u03c0\u03c0\u03c0\u03c0'], '\u03c0\u03c0'))\n\n  \" match multiple words (separated by space)\n  call assert_equal(['\uc138 \ub9c8\ub9ac\uc758 \uc791\uc740 \ub3fc\uc9c0'], ['\uc138 \ub9c8\ub9ac\uc758 \uc791\uc740 \ub3fc\uc9c0', '\ub9c8\ub9ac\uc758', '\ub9c8\ub9ac\uc758 \uc791\uc740', '\uc791\uc740 \ub3fc\uc9c0']->matchfuzzy('\ub3fc\uc9c0 \ub9c8\ub9ac\uc758'))\n  call assert_equal([], ['\uc138 \ub9c8\ub9ac\uc758 \uc791\uc740 \ub3fc\uc9c0', '\ub9c8\ub9ac\uc758', '\ub9c8\ub9ac\uc758 \uc791\uc740', '\uc791\uc740 \ub3fc\uc9c0']->matchfuzzy('\ud30c\ub780 \ud558\ub298'))\n\n  \" preference for camel case match\n  call assert_equal(['one\u0104wo', 'one\u0105wo'],\n        \\ ['one\u0105wo', 'one\u0104wo']->matchfuzzy('one\u0105wo'))\n  \" preference for complete match then match after separator (_ or space)\n  call assert_equal(['\u2160\u2161ab\u311f\u3120'] + sort(['\u2160\u2161a_b\u311f\u3120', '\u2160\u2161a b\u311f\u3120']),\n          \\ ['\u2160\u2161ab\u311f\u3120', '\u2160\u2161a b\u311f\u3120', '\u2160\u2161a_b\u311f\u3120']->matchfuzzy('\u2160\u2161ab\u311f\u3120'))\n  \" preference for match after a separator (_ or space)\n  call assert_equal(['\u3113\u3114ab\u311f\u3120', '\u3113\u3114a_b\u311f\u3120', '\u3113\u3114a b\u311f\u3120'],\n        \\ ['\u3113\u3114a_b\u311f\u3120', '\u3113\u3114a b\u311f\u3120', '\u3113\u3114ab\u311f\u3120']->matchfuzzy('\u3113\u3114ab\u311f\u3120'))\n  \" preference for leading letter match\n  call assert_equal(['\u0157\u015d\u0163\u0169\u0175\u017c', 'x\u0157\u015d\u0163\u0169\u0175\u017c'],\n        \\ ['x\u0157\u015d\u0163\u0169\u0175\u017c', '\u0157\u015d\u0163\u0169\u0175\u017c']->matchfuzzy('\u0157\u015d\u0163\u0169\u0175\u017c'))\n  \" preference for sequential match\n  call assert_equal(['\u311e\u3121\u3124\ufb00\ufb01\ufb02', '\u311ea\u3121b\u3124c\ufb00d\ufb01e\ufb02'],\n        \\ ['\u311ea\u3121b\u3124c\ufb00d\ufb01e\ufb02', '\u311e\u3121\u3124\ufb00\ufb01\ufb02']->matchfuzzy('\u311e\u3121\u3124\ufb00\ufb01\ufb02'))\n  \" non-matching leading letter(s) penalty\n  call assert_equal(['x\u311e\u3121\u3124\ufb00\ufb01\ufb02', 'xx\u311e\u3121\u3124\ufb00\ufb01\ufb02'],\n        \\ ['xx\u311e\u3121\u3124\ufb00\ufb01\ufb02', 'x\u311e\u3121\u3124\ufb00\ufb01\ufb02']->matchfuzzy('\u311e\u3121\u3124\ufb00\ufb01\ufb02'))\n  \" total non-matching letter(s) penalty\n  call assert_equal(['\u0157\u015d\u0163', '\u0157\u015d\u0163x', '\u0157\u015d\u0163xx'],\n        \\ ['\u0157\u015d\u0163xx', '\u0157\u015d\u0163', '\u0157\u015d\u0163x']->matchfuzzy('\u0157\u015d\u0163'))\nendfunc\n\n\" Test for matchfuzzypos() with multibyte characters\nfunc Test_matchfuzzypos_mbyte()\n  CheckFeature multi_lang\n  call assert_equal([['\u3053\u3093\u306b\u3061\u306f\u4e16\u754c'], [[0, 1, 2, 3, 4]], [273]],\n        \\ matchfuzzypos(['\u3053\u3093\u306b\u3061\u306f\u4e16\u754c'], '\u3053\u3093\u306b\u3061\u306f'))\n  call assert_equal([['\u30f3\u30f9\u3107\u30fa\u30f4'], [[1, 3]], [88]], matchfuzzypos(['\u30f3\u30f9\u3107\u30fa\u30f4'], '\u30f9\u30fa'))\n  \" reverse the order of characters\n  call assert_equal([[], [], []], matchfuzzypos(['\u30f3\u30f9\u3107\u30fa\u30f4'], '\u30fa\u30f9'))\n  call assert_equal([['\u03b1\u03b2\u03a9xxx', 'x\u03b1x\u03b2x\u03a9x'], [[0, 1, 2], [1, 3, 5]], [222, 113]],\n        \\ matchfuzzypos(['\u03b1\u03b2\u03a9xxx', 'x\u03b1x\u03b2x\u03a9x'], '\u03b1\u03b2\u03a9'))\n  call assert_equal([['\u03c0\u03c0bb\u03c0\u03c0', '\u03c0\u03c0\u03c0bbb\u03c0\u03c0\u03c0', '\u03c0\u03c0\u03c0\u03c0bbbb\u03c0\u03c0\u03c0\u03c0', '\u03c0b\u03c0'],\n        \\ [[0, 1], [0, 1], [0, 1], [0, 2]], [151, 148, 145, 110]],\n        \\ matchfuzzypos(['\u03c0b\u03c0', '\u03c0\u03c0bb\u03c0\u03c0', '\u03c0\u03c0\u03c0bbb\u03c0\u03c0\u03c0', '\u03c0\u03c0\u03c0\u03c0bbbb\u03c0\u03c0\u03c0\u03c0'], '\u03c0\u03c0'))\n  call assert_equal([['\u03b1\u03b1\u03b1\u03b1\u03b1\u03b1\u03b1'], [[0, 1, 2]], [191]],\n        \\ matchfuzzypos(['\u03b1\u03b1\u03b1\u03b1\u03b1\u03b1\u03b1'], '\u03b1\u03b1\u03b1'))\n\n  call assert_equal([[], [], []], matchfuzzypos(['\u30f3\u30f9\u3107', '\u0157\u015d\u0163'], '\ufb00\ufb01\ufb02'))\n  let x = matchfuzzypos([repeat('\u03a8', 256)], repeat('\u03a8', 256))\n  call assert_equal(range(256), x[1][0])\n  call assert_equal([[], [], []], matchfuzzypos([repeat('\u2713', 300)], repeat('\u2713', 257)))\n\n  \" match multiple words (separated by space)\n  call assert_equal([['\uc138 \ub9c8\ub9ac\uc758 \uc791\uc740 \ub3fc\uc9c0'], [[9, 10, 2, 3, 4]], [328]], ['\uc138 \ub9c8\ub9ac\uc758 \uc791\uc740 \ub3fc\uc9c0', '\ub9c8\ub9ac\uc758', '\ub9c8\ub9ac\uc758 \uc791\uc740', '\uc791\uc740 \ub3fc\uc9c0']->matchfuzzypos('\ub3fc\uc9c0 \ub9c8\ub9ac\uc758'))\n  call assert_equal([[], [], []], ['\uc138 \ub9c8\ub9ac\uc758 \uc791\uc740 \ub3fc\uc9c0', '\ub9c8\ub9ac\uc758', '\ub9c8\ub9ac\uc758 \uc791\uc740', '\uc791\uc740 \ub3fc\uc9c0']->matchfuzzypos('\ud30c\ub780 \ud558\ub298'))\n\n  \" match in a long string\n  call assert_equal([[repeat('\u3076', 300) .. '\u1ebc\u1ebc\u1ebc'], [[300, 301, 302]], [-135]],\n        \\ matchfuzzypos([repeat('\u3076', 300) .. '\u1ebc\u1ebc\u1ebc'], '\u1ebc\u1ebc\u1ebc'))\n  \" preference for camel case match\n  call assert_equal([['x\u0473\u0475\u0481xx\u0473\u0474\u0481'], [[6, 7, 8]], [189]], matchfuzzypos(['x\u0473\u0475\u0481xx\u0473\u0474\u0481'], '\u0473\u0475\u0481'))\n  \" preference for match after a separator (_ or space)\n  call assert_equal([['x\u3061\u3060x_\u3061\u3060'], [[5, 6]], [145]], matchfuzzypos(['x\u3061\u3060x_\u3061\u3060'], '\u3061\u3060'))\n  \" preference for leading letter match\n  call assert_equal([['\u0473\u0475\u0481x\u0473\u0475\u0481'], [[0, 1]], [150]], matchfuzzypos(['\u0473\u0475\u0481x\u0473\u0475\u0481'], '\u0473\u0475'))\n  \" preference for sequential match\n  call assert_equal([['a\u30f3b\u30f9c\u3107d\u30f3\u30f9\u3107'], [[7, 8, 9]], [158]], matchfuzzypos(['a\u30f3b\u30f9c\u3107d\u30f3\u30f9\u3107'], '\u30f3\u30f9\u3107'))\n  \" best recursive match\n  call assert_equal([['x\u0444\u0444\u0439\u0434'], [[2, 3, 4]], [168]], matchfuzzypos(['x\u0444\u0444\u0439\u0434'], '\u0444\u0439\u0434'))\nendfunc\n\n\" Test for matchfuzzy() with limit\nfunc Test_matchfuzzy_limit()\n  let x = ['1', '2', '3', '2']\n  call assert_equal(['2', '2'], x->matchfuzzy('2'))\n  call assert_equal(['2', '2'], x->matchfuzzy('2', #{}))\n  call assert_equal(['2', '2'], x->matchfuzzy('2', #{limit: 0}))\n  call assert_equal(['2'], x->matchfuzzy('2', #{limit: 1}))\n  call assert_equal(['2', '2'], x->matchfuzzy('2', #{limit: 2}))\n  call assert_equal(['2', '2'], x->matchfuzzy('2', #{limit: 3}))\n  call assert_fails(\"call matchfuzzy(x, '2', #{limit: '2'})\", 'E475:')\n\n  let l = [{'id': 5, 'val': 'crayon'}, {'id': 6, 'val': 'camera'}]\n  call assert_equal([{'id': 5, 'val': 'crayon'}, {'id': 6, 'val': 'camera'}], l->matchfuzzy('c', #{text_cb: {v -> v.val}}))\n  call assert_equal([{'id': 5, 'val': 'crayon'}, {'id': 6, 'val': 'camera'}], l->matchfuzzy('c', #{key: 'val'}))\n  call assert_equal([{'id': 5, 'val': 'crayon'}, {'id': 6, 'val': 'camera'}], l->matchfuzzy('c', #{text_cb: {v -> v.val}, limit: 0}))\n  call assert_equal([{'id': 5, 'val': 'crayon'}, {'id': 6, 'val': 'camera'}], l->matchfuzzy('c', #{key: 'val', limit: 0}))\n  call assert_equal([{'id': 5, 'val': 'crayon'}], l->matchfuzzy('c', #{text_cb: {v -> v.val}, limit: 1}))\n  call assert_equal([{'id': 5, 'val': 'crayon'}], l->matchfuzzy('c', #{key: 'val', limit: 1}))\nendfunc\n\n\" This was using uninitialized memory\nfunc Test_matchfuzzy_initialized()\n  CheckRunVimInTerminal\n\n  \" This can take a very long time (esp. when using valgrind).  Run in a\n  \" separate Vim instance and kill it after two seconds.  We only check for\n  \" memory errors.\n  let lines =<< trim END\n      lvimgrep [ss [fg*\n  END\n  call writefile(lines, 'XTest_matchfuzzy', 'D')\n\n  let buf = RunVimInTerminal('-u NONE -X -Z', {})\n  call term_sendkeys(buf, \":source XTest_matchfuzzy\\n\")\n  call TermWait(buf, 2000)\n\n  let job = term_getjob(buf)\n  if job_status(job) == \"run\"\n    call job_stop(job, \"int\")\n    call TermWait(buf, 50)\n  endif\n\n  \" clean up\n  call StopVimInTerminal(buf)\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion != NULL)\n\treturn;\n\n#ifdef BUILD_DATE\n    char *date_time = BUILD_DATE;\n#else\n    char *date_time = __DATE__ \" \" __TIME__;\n#endif\n    char *msg = _(\"%s (%s, compiled %s)\");\n    size_t len = strlen(msg)\n\t+ strlen(VIM_VERSION_LONG_ONLY)\n\t+ strlen(VIM_VERSION_DATE_ONLY)\n\t+ strlen(date_time);\n\n    longVersion = alloc(len);\n    if (longVersion == NULL)\n\tlongVersion = VIM_VERSION_LONG;\n    else\n\tvim_snprintf(longVersion, len, msg,\n\t\tVIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/quickfix.c", "src/search.c", "src/testdir/test_matchfuzzy.vim", "src/version.c"], "buggy_code_start_loc": [6060, 4425, 4, 697], "buggy_code_end_loc": [6114, 4511, 255, 697], "fixing_code_start_loc": [6061, 4424, 5, 698], "fixing_code_end_loc": [6118, 4508, 283, 700], "type": "CWE-823", "message": "Use of Out-of-range Pointer Offset in GitHub repository vim/vim prior to 9.0.1499.", "other": {"cve": {"id": "CVE-2023-2426", "sourceIdentifier": "security@huntr.dev", "published": "2023-04-29T22:15:09.243", "lastModified": "2023-05-24T05:15:09.700", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Use of Out-of-range Pointer Offset in GitHub repository vim/vim prior to 9.0.1499."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:N/S:C/C:L/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 3.7}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-823"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.1499", "matchCriteriaId": "98C576DD-6CD7-46FC-BD71-374BCC670575"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/caf642c25de526229264cab9425e7c9979f3509b", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/3451be4c-91c8-4d08-926b-cbff7396f425", "source": "security@huntr.dev", "tags": ["Exploit"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/LOJP6M7ZTKZQYOGVOOAY6TIE6ACBJL55/", "source": "security@huntr.dev"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PCLJN4QINITA3ZASKLEJ64C5TFNKELMO/", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/caf642c25de526229264cab9425e7c9979f3509b"}}