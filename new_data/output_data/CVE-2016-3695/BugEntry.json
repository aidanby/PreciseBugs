{"buggy_code": ["/*\n * APEI Error INJection support\n *\n * EINJ provides a hardware error injection mechanism, this is useful\n * for debugging and testing of other APEI and RAS features.\n *\n * For more information about EINJ, please refer to ACPI Specification\n * version 4.0, section 17.5.\n *\n * Copyright 2009-2010 Intel Corp.\n *   Author: Huang Ying <ying.huang@intel.com>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License version\n * 2 as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n */\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n#include <asm/unaligned.h>\n\n#include \"apei-internal.h\"\n\n#define EINJ_PFX \"EINJ: \"\n\n#define SPIN_UNIT\t\t100\t\t\t/* 100ns */\n/* Firmware should respond within 1 milliseconds */\n#define FIRMWARE_TIMEOUT\t(1 * NSEC_PER_MSEC)\n#define ACPI5_VENDOR_BIT\tBIT(31)\n#define MEM_ERROR_MASK\t\t(ACPI_EINJ_MEMORY_CORRECTABLE | \\\n\t\t\t\tACPI_EINJ_MEMORY_UNCORRECTABLE | \\\n\t\t\t\tACPI_EINJ_MEMORY_FATAL)\n\n/*\n * ACPI version 5 provides a SET_ERROR_TYPE_WITH_ADDRESS action.\n */\nstatic int acpi5;\n\nstruct set_error_type_with_address {\n\tu32\ttype;\n\tu32\tvendor_extension;\n\tu32\tflags;\n\tu32\tapicid;\n\tu64\tmemory_address;\n\tu64\tmemory_address_range;\n\tu32\tpcie_sbdf;\n};\nenum {\n\tSETWA_FLAGS_APICID = 1,\n\tSETWA_FLAGS_MEM = 2,\n\tSETWA_FLAGS_PCIE_SBDF = 4,\n};\n\n/*\n * Vendor extensions for platform specific operations\n */\nstruct vendor_error_type_extension {\n\tu32\tlength;\n\tu32\tpcie_sbdf;\n\tu16\tvendor_id;\n\tu16\tdevice_id;\n\tu8\trev_id;\n\tu8\treserved[3];\n};\n\nstatic u32 notrigger;\n\nstatic u32 vendor_flags;\nstatic struct debugfs_blob_wrapper vendor_blob;\nstatic char vendor_dev[64];\n\n/*\n * Some BIOSes allow parameters to the SET_ERROR_TYPE entries in the\n * EINJ table through an unpublished extension. Use with caution as\n * most will ignore the parameter and make their own choice of address\n * for error injection.  This extension is used only if\n * param_extension module parameter is specified.\n */\nstruct einj_parameter {\n\tu64 type;\n\tu64 reserved1;\n\tu64 reserved2;\n\tu64 param1;\n\tu64 param2;\n};\n\n#define EINJ_OP_BUSY\t\t\t0x1\n#define EINJ_STATUS_SUCCESS\t\t0x0\n#define EINJ_STATUS_FAIL\t\t0x1\n#define EINJ_STATUS_INVAL\t\t0x2\n\n#define EINJ_TAB_ENTRY(tab)\t\t\t\t\t\t\\\n\t((struct acpi_whea_header *)((char *)(tab) +\t\t\t\\\n\t\t\t\t    sizeof(struct acpi_table_einj)))\n\nstatic bool param_extension;\nmodule_param(param_extension, bool, 0);\n\nstatic struct acpi_table_einj *einj_tab;\n\nstatic struct apei_resources einj_resources;\n\nstatic struct apei_exec_ins_type einj_ins_type[] = {\n\t[ACPI_EINJ_READ_REGISTER] = {\n\t\t.flags = APEI_EXEC_INS_ACCESS_REGISTER,\n\t\t.run   = apei_exec_read_register,\n\t},\n\t[ACPI_EINJ_READ_REGISTER_VALUE] = {\n\t\t.flags = APEI_EXEC_INS_ACCESS_REGISTER,\n\t\t.run   = apei_exec_read_register_value,\n\t},\n\t[ACPI_EINJ_WRITE_REGISTER] = {\n\t\t.flags = APEI_EXEC_INS_ACCESS_REGISTER,\n\t\t.run   = apei_exec_write_register,\n\t},\n\t[ACPI_EINJ_WRITE_REGISTER_VALUE] = {\n\t\t.flags = APEI_EXEC_INS_ACCESS_REGISTER,\n\t\t.run   = apei_exec_write_register_value,\n\t},\n\t[ACPI_EINJ_NOOP] = {\n\t\t.flags = 0,\n\t\t.run   = apei_exec_noop,\n\t},\n};\n\n/*\n * Prevent EINJ interpreter to run simultaneously, because the\n * corresponding firmware implementation may not work properly when\n * invoked simultaneously.\n */\nstatic DEFINE_MUTEX(einj_mutex);\n\nstatic void *einj_param;\n\nstatic void einj_exec_ctx_init(struct apei_exec_context *ctx)\n{\n\tapei_exec_ctx_init(ctx, einj_ins_type, ARRAY_SIZE(einj_ins_type),\n\t\t\t   EINJ_TAB_ENTRY(einj_tab), einj_tab->entries);\n}\n\nstatic int __einj_get_available_error_type(u32 *type)\n{\n\tstruct apei_exec_context ctx;\n\tint rc;\n\n\teinj_exec_ctx_init(&ctx);\n\trc = apei_exec_run(&ctx, ACPI_EINJ_GET_ERROR_TYPE);\n\tif (rc)\n\t\treturn rc;\n\t*type = apei_exec_ctx_get_output(&ctx);\n\n\treturn 0;\n}\n\n/* Get error injection capabilities of the platform */\nstatic int einj_get_available_error_type(u32 *type)\n{\n\tint rc;\n\n\tmutex_lock(&einj_mutex);\n\trc = __einj_get_available_error_type(type);\n\tmutex_unlock(&einj_mutex);\n\n\treturn rc;\n}\n\nstatic int einj_timedout(u64 *t)\n{\n\tif ((s64)*t < SPIN_UNIT) {\n\t\tpr_warning(FW_WARN EINJ_PFX\n\t\t\t   \"Firmware does not respond in time\\n\");\n\t\treturn 1;\n\t}\n\t*t -= SPIN_UNIT;\n\tndelay(SPIN_UNIT);\n\ttouch_nmi_watchdog();\n\treturn 0;\n}\n\nstatic void check_vendor_extension(u64 paddr,\n\t\t\t\t   struct set_error_type_with_address *v5param)\n{\n\tint\toffset = v5param->vendor_extension;\n\tstruct\tvendor_error_type_extension *v;\n\tu32\tsbdf;\n\n\tif (!offset)\n\t\treturn;\n\tv = acpi_os_map_iomem(paddr + offset, sizeof(*v));\n\tif (!v)\n\t\treturn;\n\tsbdf = v->pcie_sbdf;\n\tsprintf(vendor_dev, \"%x:%x:%x.%x vendor_id=%x device_id=%x rev_id=%x\\n\",\n\t\tsbdf >> 24, (sbdf >> 16) & 0xff,\n\t\t(sbdf >> 11) & 0x1f, (sbdf >> 8) & 0x7,\n\t\t v->vendor_id, v->device_id, v->rev_id);\n\tacpi_os_unmap_iomem(v, sizeof(*v));\n}\n\nstatic void *einj_get_parameter_address(void)\n{\n\tint i;\n\tu64 pa_v4 = 0, pa_v5 = 0;\n\tstruct acpi_whea_header *entry;\n\n\tentry = EINJ_TAB_ENTRY(einj_tab);\n\tfor (i = 0; i < einj_tab->entries; i++) {\n\t\tif (entry->action == ACPI_EINJ_SET_ERROR_TYPE &&\n\t\t    entry->instruction == ACPI_EINJ_WRITE_REGISTER &&\n\t\t    entry->register_region.space_id ==\n\t\t    ACPI_ADR_SPACE_SYSTEM_MEMORY)\n\t\t\tpa_v4 = get_unaligned(&entry->register_region.address);\n\t\tif (entry->action == ACPI_EINJ_SET_ERROR_TYPE_WITH_ADDRESS &&\n\t\t    entry->instruction == ACPI_EINJ_WRITE_REGISTER &&\n\t\t    entry->register_region.space_id ==\n\t\t    ACPI_ADR_SPACE_SYSTEM_MEMORY)\n\t\t\tpa_v5 = get_unaligned(&entry->register_region.address);\n\t\tentry++;\n\t}\n\tif (pa_v5) {\n\t\tstruct set_error_type_with_address *v5param;\n\n\t\tv5param = acpi_os_map_iomem(pa_v5, sizeof(*v5param));\n\t\tif (v5param) {\n\t\t\tacpi5 = 1;\n\t\t\tcheck_vendor_extension(pa_v5, v5param);\n\t\t\treturn v5param;\n\t\t}\n\t}\n\tif (param_extension && pa_v4) {\n\t\tstruct einj_parameter *v4param;\n\n\t\tv4param = acpi_os_map_iomem(pa_v4, sizeof(*v4param));\n\t\tif (!v4param)\n\t\t\treturn NULL;\n\t\tif (v4param->reserved1 || v4param->reserved2) {\n\t\t\tacpi_os_unmap_iomem(v4param, sizeof(*v4param));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn v4param;\n\t}\n\n\treturn NULL;\n}\n\n/* do sanity check to trigger table */\nstatic int einj_check_trigger_header(struct acpi_einj_trigger *trigger_tab)\n{\n\tif (trigger_tab->header_size != sizeof(struct acpi_einj_trigger))\n\t\treturn -EINVAL;\n\tif (trigger_tab->table_size > PAGE_SIZE ||\n\t    trigger_tab->table_size < trigger_tab->header_size)\n\t\treturn -EINVAL;\n\tif (trigger_tab->entry_count !=\n\t    (trigger_tab->table_size - trigger_tab->header_size) /\n\t    sizeof(struct acpi_einj_entry))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic struct acpi_generic_address *einj_get_trigger_parameter_region(\n\tstruct acpi_einj_trigger *trigger_tab, u64 param1, u64 param2)\n{\n\tint i;\n\tstruct acpi_whea_header *entry;\n\n\tentry = (struct acpi_whea_header *)\n\t\t((char *)trigger_tab + sizeof(struct acpi_einj_trigger));\n\tfor (i = 0; i < trigger_tab->entry_count; i++) {\n\t\tif (entry->action == ACPI_EINJ_TRIGGER_ERROR &&\n\t\tentry->instruction == ACPI_EINJ_WRITE_REGISTER_VALUE &&\n\t\tentry->register_region.space_id ==\n\t\t\tACPI_ADR_SPACE_SYSTEM_MEMORY &&\n\t\t(entry->register_region.address & param2) == (param1 & param2))\n\t\t\treturn &entry->register_region;\n\t\tentry++;\n\t}\n\n\treturn NULL;\n}\n/* Execute instructions in trigger error action table */\nstatic int __einj_error_trigger(u64 trigger_paddr, u32 type,\n\t\t\t\tu64 param1, u64 param2)\n{\n\tstruct acpi_einj_trigger *trigger_tab = NULL;\n\tstruct apei_exec_context trigger_ctx;\n\tstruct apei_resources trigger_resources;\n\tstruct acpi_whea_header *trigger_entry;\n\tstruct resource *r;\n\tu32 table_size;\n\tint rc = -EIO;\n\tstruct acpi_generic_address *trigger_param_region = NULL;\n\n\tr = request_mem_region(trigger_paddr, sizeof(*trigger_tab),\n\t\t\t       \"APEI EINJ Trigger Table\");\n\tif (!r) {\n\t\tpr_err(EINJ_PFX\n\t\"Can not request [mem %#010llx-%#010llx] for Trigger table\\n\",\n\t\t       (unsigned long long)trigger_paddr,\n\t\t       (unsigned long long)trigger_paddr +\n\t\t\t    sizeof(*trigger_tab) - 1);\n\t\tgoto out;\n\t}\n\ttrigger_tab = ioremap_cache(trigger_paddr, sizeof(*trigger_tab));\n\tif (!trigger_tab) {\n\t\tpr_err(EINJ_PFX \"Failed to map trigger table!\\n\");\n\t\tgoto out_rel_header;\n\t}\n\trc = einj_check_trigger_header(trigger_tab);\n\tif (rc) {\n\t\tpr_warning(FW_BUG EINJ_PFX\n\t\t\t   \"The trigger error action table is invalid\\n\");\n\t\tgoto out_rel_header;\n\t}\n\n\t/* No action structures in the TRIGGER_ERROR table, nothing to do */\n\tif (!trigger_tab->entry_count)\n\t\tgoto out_rel_header;\n\n\trc = -EIO;\n\ttable_size = trigger_tab->table_size;\n\tr = request_mem_region(trigger_paddr + sizeof(*trigger_tab),\n\t\t\t       table_size - sizeof(*trigger_tab),\n\t\t\t       \"APEI EINJ Trigger Table\");\n\tif (!r) {\n\t\tpr_err(EINJ_PFX\n\"Can not request [mem %#010llx-%#010llx] for Trigger Table Entry\\n\",\n\t\t       (unsigned long long)trigger_paddr + sizeof(*trigger_tab),\n\t\t       (unsigned long long)trigger_paddr + table_size - 1);\n\t\tgoto out_rel_header;\n\t}\n\tiounmap(trigger_tab);\n\ttrigger_tab = ioremap_cache(trigger_paddr, table_size);\n\tif (!trigger_tab) {\n\t\tpr_err(EINJ_PFX \"Failed to map trigger table!\\n\");\n\t\tgoto out_rel_entry;\n\t}\n\ttrigger_entry = (struct acpi_whea_header *)\n\t\t((char *)trigger_tab + sizeof(struct acpi_einj_trigger));\n\tapei_resources_init(&trigger_resources);\n\tapei_exec_ctx_init(&trigger_ctx, einj_ins_type,\n\t\t\t   ARRAY_SIZE(einj_ins_type),\n\t\t\t   trigger_entry, trigger_tab->entry_count);\n\trc = apei_exec_collect_resources(&trigger_ctx, &trigger_resources);\n\tif (rc)\n\t\tgoto out_fini;\n\trc = apei_resources_sub(&trigger_resources, &einj_resources);\n\tif (rc)\n\t\tgoto out_fini;\n\t/*\n\t * Some firmware will access target address specified in\n\t * param1 to trigger the error when injecting memory error.\n\t * This will cause resource conflict with regular memory.  So\n\t * remove it from trigger table resources.\n\t */\n\tif ((param_extension || acpi5) && (type & MEM_ERROR_MASK) && param2) {\n\t\tstruct apei_resources addr_resources;\n\t\tapei_resources_init(&addr_resources);\n\t\ttrigger_param_region = einj_get_trigger_parameter_region(\n\t\t\ttrigger_tab, param1, param2);\n\t\tif (trigger_param_region) {\n\t\t\trc = apei_resources_add(&addr_resources,\n\t\t\t\ttrigger_param_region->address,\n\t\t\t\ttrigger_param_region->bit_width/8, true);\n\t\t\tif (rc)\n\t\t\t\tgoto out_fini;\n\t\t\trc = apei_resources_sub(&trigger_resources,\n\t\t\t\t\t&addr_resources);\n\t\t}\n\t\tapei_resources_fini(&addr_resources);\n\t\tif (rc)\n\t\t\tgoto out_fini;\n\t}\n\trc = apei_resources_request(&trigger_resources, \"APEI EINJ Trigger\");\n\tif (rc)\n\t\tgoto out_fini;\n\trc = apei_exec_pre_map_gars(&trigger_ctx);\n\tif (rc)\n\t\tgoto out_release;\n\n\trc = apei_exec_run(&trigger_ctx, ACPI_EINJ_TRIGGER_ERROR);\n\n\tapei_exec_post_unmap_gars(&trigger_ctx);\nout_release:\n\tapei_resources_release(&trigger_resources);\nout_fini:\n\tapei_resources_fini(&trigger_resources);\nout_rel_entry:\n\trelease_mem_region(trigger_paddr + sizeof(*trigger_tab),\n\t\t\t   table_size - sizeof(*trigger_tab));\nout_rel_header:\n\trelease_mem_region(trigger_paddr, sizeof(*trigger_tab));\nout:\n\tif (trigger_tab)\n\t\tiounmap(trigger_tab);\n\n\treturn rc;\n}\n\nstatic int __einj_error_inject(u32 type, u32 flags, u64 param1, u64 param2,\n\t\t\t       u64 param3, u64 param4)\n{\n\tstruct apei_exec_context ctx;\n\tu64 val, trigger_paddr, timeout = FIRMWARE_TIMEOUT;\n\tint rc;\n\n\teinj_exec_ctx_init(&ctx);\n\n\trc = apei_exec_run_optional(&ctx, ACPI_EINJ_BEGIN_OPERATION);\n\tif (rc)\n\t\treturn rc;\n\tapei_exec_ctx_set_input(&ctx, type);\n\tif (acpi5) {\n\t\tstruct set_error_type_with_address *v5param = einj_param;\n\n\t\tv5param->type = type;\n\t\tif (type & ACPI5_VENDOR_BIT) {\n\t\t\tswitch (vendor_flags) {\n\t\t\tcase SETWA_FLAGS_APICID:\n\t\t\t\tv5param->apicid = param1;\n\t\t\t\tbreak;\n\t\t\tcase SETWA_FLAGS_MEM:\n\t\t\t\tv5param->memory_address = param1;\n\t\t\t\tv5param->memory_address_range = param2;\n\t\t\t\tbreak;\n\t\t\tcase SETWA_FLAGS_PCIE_SBDF:\n\t\t\t\tv5param->pcie_sbdf = param1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tv5param->flags = vendor_flags;\n\t\t} else if (flags) {\n\t\t\t\tv5param->flags = flags;\n\t\t\t\tv5param->memory_address = param1;\n\t\t\t\tv5param->memory_address_range = param2;\n\t\t\t\tv5param->apicid = param3;\n\t\t\t\tv5param->pcie_sbdf = param4;\n\t\t} else {\n\t\t\tswitch (type) {\n\t\t\tcase ACPI_EINJ_PROCESSOR_CORRECTABLE:\n\t\t\tcase ACPI_EINJ_PROCESSOR_UNCORRECTABLE:\n\t\t\tcase ACPI_EINJ_PROCESSOR_FATAL:\n\t\t\t\tv5param->apicid = param1;\n\t\t\t\tv5param->flags = SETWA_FLAGS_APICID;\n\t\t\t\tbreak;\n\t\t\tcase ACPI_EINJ_MEMORY_CORRECTABLE:\n\t\t\tcase ACPI_EINJ_MEMORY_UNCORRECTABLE:\n\t\t\tcase ACPI_EINJ_MEMORY_FATAL:\n\t\t\t\tv5param->memory_address = param1;\n\t\t\t\tv5param->memory_address_range = param2;\n\t\t\t\tv5param->flags = SETWA_FLAGS_MEM;\n\t\t\t\tbreak;\n\t\t\tcase ACPI_EINJ_PCIX_CORRECTABLE:\n\t\t\tcase ACPI_EINJ_PCIX_UNCORRECTABLE:\n\t\t\tcase ACPI_EINJ_PCIX_FATAL:\n\t\t\t\tv5param->pcie_sbdf = param1;\n\t\t\t\tv5param->flags = SETWA_FLAGS_PCIE_SBDF;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\trc = apei_exec_run(&ctx, ACPI_EINJ_SET_ERROR_TYPE);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (einj_param) {\n\t\t\tstruct einj_parameter *v4param = einj_param;\n\t\t\tv4param->param1 = param1;\n\t\t\tv4param->param2 = param2;\n\t\t}\n\t}\n\trc = apei_exec_run(&ctx, ACPI_EINJ_EXECUTE_OPERATION);\n\tif (rc)\n\t\treturn rc;\n\tfor (;;) {\n\t\trc = apei_exec_run(&ctx, ACPI_EINJ_CHECK_BUSY_STATUS);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tval = apei_exec_ctx_get_output(&ctx);\n\t\tif (!(val & EINJ_OP_BUSY))\n\t\t\tbreak;\n\t\tif (einj_timedout(&timeout))\n\t\t\treturn -EIO;\n\t}\n\trc = apei_exec_run(&ctx, ACPI_EINJ_GET_COMMAND_STATUS);\n\tif (rc)\n\t\treturn rc;\n\tval = apei_exec_ctx_get_output(&ctx);\n\tif (val != EINJ_STATUS_SUCCESS)\n\t\treturn -EBUSY;\n\n\trc = apei_exec_run(&ctx, ACPI_EINJ_GET_TRIGGER_TABLE);\n\tif (rc)\n\t\treturn rc;\n\ttrigger_paddr = apei_exec_ctx_get_output(&ctx);\n\tif (notrigger == 0) {\n\t\trc = __einj_error_trigger(trigger_paddr, type, param1, param2);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\trc = apei_exec_run_optional(&ctx, ACPI_EINJ_END_OPERATION);\n\n\treturn rc;\n}\n\n/* Inject the specified hardware error */\nstatic int einj_error_inject(u32 type, u32 flags, u64 param1, u64 param2,\n\t\t\t     u64 param3, u64 param4)\n{\n\tint rc;\n\tu64 base_addr, size;\n\n\t/* If user manually set \"flags\", make sure it is legal */\n\tif (flags && (flags &\n\t\t~(SETWA_FLAGS_APICID|SETWA_FLAGS_MEM|SETWA_FLAGS_PCIE_SBDF)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * We need extra sanity checks for memory errors.\n\t * Other types leap directly to injection.\n\t */\n\n\t/* ensure param1/param2 existed */\n\tif (!(param_extension || acpi5))\n\t\tgoto inject;\n\n\t/* ensure injection is memory related */\n\tif (type & ACPI5_VENDOR_BIT) {\n\t\tif (vendor_flags != SETWA_FLAGS_MEM)\n\t\t\tgoto inject;\n\t} else if (!(type & MEM_ERROR_MASK) && !(flags & SETWA_FLAGS_MEM))\n\t\tgoto inject;\n\n\t/*\n\t * Disallow crazy address masks that give BIOS leeway to pick\n\t * injection address almost anywhere. Insist on page or\n\t * better granularity and that target address is normal RAM or\n\t * NVDIMM.\n\t */\n\tbase_addr = param1 & param2;\n\tsize = ~param2 + 1;\n\n\tif (((param2 & PAGE_MASK) != PAGE_MASK) ||\n\t    ((region_intersects(base_addr, size, IORESOURCE_SYSTEM_RAM, IORES_DESC_NONE)\n\t\t\t\t!= REGION_INTERSECTS) &&\n\t     (region_intersects(base_addr, size, IORESOURCE_MEM, IORES_DESC_PERSISTENT_MEMORY)\n\t\t\t\t!= REGION_INTERSECTS)))\n\t\treturn -EINVAL;\n\ninject:\n\tmutex_lock(&einj_mutex);\n\trc = __einj_error_inject(type, flags, param1, param2, param3, param4);\n\tmutex_unlock(&einj_mutex);\n\n\treturn rc;\n}\n\nstatic u32 error_type;\nstatic u32 error_flags;\nstatic u64 error_param1;\nstatic u64 error_param2;\nstatic u64 error_param3;\nstatic u64 error_param4;\nstatic struct dentry *einj_debug_dir;\n\nstatic int available_error_type_show(struct seq_file *m, void *v)\n{\n\tint rc;\n\tu32 available_error_type = 0;\n\n\trc = einj_get_available_error_type(&available_error_type);\n\tif (rc)\n\t\treturn rc;\n\tif (available_error_type & 0x0001)\n\t\tseq_printf(m, \"0x00000001\\tProcessor Correctable\\n\");\n\tif (available_error_type & 0x0002)\n\t\tseq_printf(m, \"0x00000002\\tProcessor Uncorrectable non-fatal\\n\");\n\tif (available_error_type & 0x0004)\n\t\tseq_printf(m, \"0x00000004\\tProcessor Uncorrectable fatal\\n\");\n\tif (available_error_type & 0x0008)\n\t\tseq_printf(m, \"0x00000008\\tMemory Correctable\\n\");\n\tif (available_error_type & 0x0010)\n\t\tseq_printf(m, \"0x00000010\\tMemory Uncorrectable non-fatal\\n\");\n\tif (available_error_type & 0x0020)\n\t\tseq_printf(m, \"0x00000020\\tMemory Uncorrectable fatal\\n\");\n\tif (available_error_type & 0x0040)\n\t\tseq_printf(m, \"0x00000040\\tPCI Express Correctable\\n\");\n\tif (available_error_type & 0x0080)\n\t\tseq_printf(m, \"0x00000080\\tPCI Express Uncorrectable non-fatal\\n\");\n\tif (available_error_type & 0x0100)\n\t\tseq_printf(m, \"0x00000100\\tPCI Express Uncorrectable fatal\\n\");\n\tif (available_error_type & 0x0200)\n\t\tseq_printf(m, \"0x00000200\\tPlatform Correctable\\n\");\n\tif (available_error_type & 0x0400)\n\t\tseq_printf(m, \"0x00000400\\tPlatform Uncorrectable non-fatal\\n\");\n\tif (available_error_type & 0x0800)\n\t\tseq_printf(m, \"0x00000800\\tPlatform Uncorrectable fatal\\n\");\n\n\treturn 0;\n}\n\nstatic int available_error_type_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, available_error_type_show, NULL);\n}\n\nstatic const struct file_operations available_error_type_fops = {\n\t.open\t\t= available_error_type_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nstatic int error_type_get(void *data, u64 *val)\n{\n\t*val = error_type;\n\n\treturn 0;\n}\n\nstatic int error_type_set(void *data, u64 val)\n{\n\tint rc;\n\tu32 available_error_type = 0;\n\tu32 tval, vendor;\n\n\t/*\n\t * Vendor defined types have 0x80000000 bit set, and\n\t * are not enumerated by ACPI_EINJ_GET_ERROR_TYPE\n\t */\n\tvendor = val & ACPI5_VENDOR_BIT;\n\ttval = val & 0x7fffffff;\n\n\t/* Only one error type can be specified */\n\tif (tval & (tval - 1))\n\t\treturn -EINVAL;\n\tif (!vendor) {\n\t\trc = einj_get_available_error_type(&available_error_type);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (!(val & available_error_type))\n\t\t\treturn -EINVAL;\n\t}\n\terror_type = val;\n\n\treturn 0;\n}\n\nDEFINE_SIMPLE_ATTRIBUTE(error_type_fops, error_type_get,\n\t\t\terror_type_set, \"0x%llx\\n\");\n\nstatic int error_inject_set(void *data, u64 val)\n{\n\tif (!error_type)\n\t\treturn -EINVAL;\n\n\treturn einj_error_inject(error_type, error_flags, error_param1, error_param2,\n\t\terror_param3, error_param4);\n}\n\nDEFINE_SIMPLE_ATTRIBUTE(error_inject_fops, NULL,\n\t\t\terror_inject_set, \"%llu\\n\");\n\nstatic int einj_check_table(struct acpi_table_einj *einj_tab)\n{\n\tif ((einj_tab->header_length !=\n\t     (sizeof(struct acpi_table_einj) - sizeof(einj_tab->header)))\n\t    && (einj_tab->header_length != sizeof(struct acpi_table_einj)))\n\t\treturn -EINVAL;\n\tif (einj_tab->header.length < sizeof(struct acpi_table_einj))\n\t\treturn -EINVAL;\n\tif (einj_tab->entries !=\n\t    (einj_tab->header.length - sizeof(struct acpi_table_einj)) /\n\t    sizeof(struct acpi_einj_entry))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int __init einj_init(void)\n{\n\tint rc;\n\tacpi_status status;\n\tstruct dentry *fentry;\n\tstruct apei_exec_context ctx;\n\n\tif (acpi_disabled)\n\t\treturn -ENODEV;\n\n\tstatus = acpi_get_table(ACPI_SIG_EINJ, 0,\n\t\t\t\t(struct acpi_table_header **)&einj_tab);\n\tif (status == AE_NOT_FOUND)\n\t\treturn -ENODEV;\n\telse if (ACPI_FAILURE(status)) {\n\t\tconst char *msg = acpi_format_exception(status);\n\t\tpr_err(EINJ_PFX \"Failed to get table, %s\\n\", msg);\n\t\treturn -EINVAL;\n\t}\n\n\trc = einj_check_table(einj_tab);\n\tif (rc) {\n\t\tpr_warning(FW_BUG EINJ_PFX \"EINJ table is invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trc = -ENOMEM;\n\teinj_debug_dir = debugfs_create_dir(\"einj\", apei_get_debugfs_dir());\n\tif (!einj_debug_dir)\n\t\tgoto err_cleanup;\n\tfentry = debugfs_create_file(\"available_error_type\", S_IRUSR,\n\t\t\t\t     einj_debug_dir, NULL,\n\t\t\t\t     &available_error_type_fops);\n\tif (!fentry)\n\t\tgoto err_cleanup;\n\tfentry = debugfs_create_file(\"error_type\", S_IRUSR | S_IWUSR,\n\t\t\t\t     einj_debug_dir, NULL, &error_type_fops);\n\tif (!fentry)\n\t\tgoto err_cleanup;\n\tfentry = debugfs_create_file(\"error_inject\", S_IWUSR,\n\t\t\t\t     einj_debug_dir, NULL, &error_inject_fops);\n\tif (!fentry)\n\t\tgoto err_cleanup;\n\n\tapei_resources_init(&einj_resources);\n\teinj_exec_ctx_init(&ctx);\n\trc = apei_exec_collect_resources(&ctx, &einj_resources);\n\tif (rc)\n\t\tgoto err_fini;\n\trc = apei_resources_request(&einj_resources, \"APEI EINJ\");\n\tif (rc)\n\t\tgoto err_fini;\n\trc = apei_exec_pre_map_gars(&ctx);\n\tif (rc)\n\t\tgoto err_release;\n\n\trc = -ENOMEM;\n\teinj_param = einj_get_parameter_address();\n\tif ((param_extension || acpi5) && einj_param) {\n\t\tfentry = debugfs_create_x32(\"flags\", S_IRUSR | S_IWUSR,\n\t\t\t\t\t    einj_debug_dir, &error_flags);\n\t\tif (!fentry)\n\t\t\tgoto err_unmap;\n\t\tfentry = debugfs_create_x64(\"param1\", S_IRUSR | S_IWUSR,\n\t\t\t\t\t    einj_debug_dir, &error_param1);\n\t\tif (!fentry)\n\t\t\tgoto err_unmap;\n\t\tfentry = debugfs_create_x64(\"param2\", S_IRUSR | S_IWUSR,\n\t\t\t\t\t    einj_debug_dir, &error_param2);\n\t\tif (!fentry)\n\t\t\tgoto err_unmap;\n\t\tfentry = debugfs_create_x64(\"param3\", S_IRUSR | S_IWUSR,\n\t\t\t\t\t    einj_debug_dir, &error_param3);\n\t\tif (!fentry)\n\t\t\tgoto err_unmap;\n\t\tfentry = debugfs_create_x64(\"param4\", S_IRUSR | S_IWUSR,\n\t\t\t\t\t    einj_debug_dir, &error_param4);\n\t\tif (!fentry)\n\t\t\tgoto err_unmap;\n\n\t\tfentry = debugfs_create_x32(\"notrigger\", S_IRUSR | S_IWUSR,\n\t\t\t\t\t    einj_debug_dir, &notrigger);\n\t\tif (!fentry)\n\t\t\tgoto err_unmap;\n\t}\n\n\tif (vendor_dev[0]) {\n\t\tvendor_blob.data = vendor_dev;\n\t\tvendor_blob.size = strlen(vendor_dev);\n\t\tfentry = debugfs_create_blob(\"vendor\", S_IRUSR,\n\t\t\t\t\t     einj_debug_dir, &vendor_blob);\n\t\tif (!fentry)\n\t\t\tgoto err_unmap;\n\t\tfentry = debugfs_create_x32(\"vendor_flags\", S_IRUSR | S_IWUSR,\n\t\t\t\t\t    einj_debug_dir, &vendor_flags);\n\t\tif (!fentry)\n\t\t\tgoto err_unmap;\n\t}\n\n\tpr_info(EINJ_PFX \"Error INJection is initialized.\\n\");\n\n\treturn 0;\n\nerr_unmap:\n\tif (einj_param) {\n\t\tacpi_size size = (acpi5) ?\n\t\t\tsizeof(struct set_error_type_with_address) :\n\t\t\tsizeof(struct einj_parameter);\n\n\t\tacpi_os_unmap_iomem(einj_param, size);\n\t}\n\tapei_exec_post_unmap_gars(&ctx);\nerr_release:\n\tapei_resources_release(&einj_resources);\nerr_fini:\n\tapei_resources_fini(&einj_resources);\nerr_cleanup:\n\tdebugfs_remove_recursive(einj_debug_dir);\n\n\treturn rc;\n}\n\nstatic void __exit einj_exit(void)\n{\n\tstruct apei_exec_context ctx;\n\n\tif (einj_param) {\n\t\tacpi_size size = (acpi5) ?\n\t\t\tsizeof(struct set_error_type_with_address) :\n\t\t\tsizeof(struct einj_parameter);\n\n\t\tacpi_os_unmap_iomem(einj_param, size);\n\t}\n\teinj_exec_ctx_init(&ctx);\n\tapei_exec_post_unmap_gars(&ctx);\n\tapei_resources_release(&einj_resources);\n\tapei_resources_fini(&einj_resources);\n\tdebugfs_remove_recursive(einj_debug_dir);\n}\n\nmodule_init(einj_init);\nmodule_exit(einj_exit);\n\nMODULE_AUTHOR(\"Huang Ying\");\nMODULE_DESCRIPTION(\"APEI Error INJection support\");\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["/*\n * APEI Error INJection support\n *\n * EINJ provides a hardware error injection mechanism, this is useful\n * for debugging and testing of other APEI and RAS features.\n *\n * For more information about EINJ, please refer to ACPI Specification\n * version 4.0, section 17.5.\n *\n * Copyright 2009-2010 Intel Corp.\n *   Author: Huang Ying <ying.huang@intel.com>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License version\n * 2 as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n */\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/io.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/mm.h>\n#include <linux/security.h>\n#include <asm/unaligned.h>\n\n#include \"apei-internal.h\"\n\n#define EINJ_PFX \"EINJ: \"\n\n#define SPIN_UNIT\t\t100\t\t\t/* 100ns */\n/* Firmware should respond within 1 milliseconds */\n#define FIRMWARE_TIMEOUT\t(1 * NSEC_PER_MSEC)\n#define ACPI5_VENDOR_BIT\tBIT(31)\n#define MEM_ERROR_MASK\t\t(ACPI_EINJ_MEMORY_CORRECTABLE | \\\n\t\t\t\tACPI_EINJ_MEMORY_UNCORRECTABLE | \\\n\t\t\t\tACPI_EINJ_MEMORY_FATAL)\n\n/*\n * ACPI version 5 provides a SET_ERROR_TYPE_WITH_ADDRESS action.\n */\nstatic int acpi5;\n\nstruct set_error_type_with_address {\n\tu32\ttype;\n\tu32\tvendor_extension;\n\tu32\tflags;\n\tu32\tapicid;\n\tu64\tmemory_address;\n\tu64\tmemory_address_range;\n\tu32\tpcie_sbdf;\n};\nenum {\n\tSETWA_FLAGS_APICID = 1,\n\tSETWA_FLAGS_MEM = 2,\n\tSETWA_FLAGS_PCIE_SBDF = 4,\n};\n\n/*\n * Vendor extensions for platform specific operations\n */\nstruct vendor_error_type_extension {\n\tu32\tlength;\n\tu32\tpcie_sbdf;\n\tu16\tvendor_id;\n\tu16\tdevice_id;\n\tu8\trev_id;\n\tu8\treserved[3];\n};\n\nstatic u32 notrigger;\n\nstatic u32 vendor_flags;\nstatic struct debugfs_blob_wrapper vendor_blob;\nstatic char vendor_dev[64];\n\n/*\n * Some BIOSes allow parameters to the SET_ERROR_TYPE entries in the\n * EINJ table through an unpublished extension. Use with caution as\n * most will ignore the parameter and make their own choice of address\n * for error injection.  This extension is used only if\n * param_extension module parameter is specified.\n */\nstruct einj_parameter {\n\tu64 type;\n\tu64 reserved1;\n\tu64 reserved2;\n\tu64 param1;\n\tu64 param2;\n};\n\n#define EINJ_OP_BUSY\t\t\t0x1\n#define EINJ_STATUS_SUCCESS\t\t0x0\n#define EINJ_STATUS_FAIL\t\t0x1\n#define EINJ_STATUS_INVAL\t\t0x2\n\n#define EINJ_TAB_ENTRY(tab)\t\t\t\t\t\t\\\n\t((struct acpi_whea_header *)((char *)(tab) +\t\t\t\\\n\t\t\t\t    sizeof(struct acpi_table_einj)))\n\nstatic bool param_extension;\nmodule_param(param_extension, bool, 0);\n\nstatic struct acpi_table_einj *einj_tab;\n\nstatic struct apei_resources einj_resources;\n\nstatic struct apei_exec_ins_type einj_ins_type[] = {\n\t[ACPI_EINJ_READ_REGISTER] = {\n\t\t.flags = APEI_EXEC_INS_ACCESS_REGISTER,\n\t\t.run   = apei_exec_read_register,\n\t},\n\t[ACPI_EINJ_READ_REGISTER_VALUE] = {\n\t\t.flags = APEI_EXEC_INS_ACCESS_REGISTER,\n\t\t.run   = apei_exec_read_register_value,\n\t},\n\t[ACPI_EINJ_WRITE_REGISTER] = {\n\t\t.flags = APEI_EXEC_INS_ACCESS_REGISTER,\n\t\t.run   = apei_exec_write_register,\n\t},\n\t[ACPI_EINJ_WRITE_REGISTER_VALUE] = {\n\t\t.flags = APEI_EXEC_INS_ACCESS_REGISTER,\n\t\t.run   = apei_exec_write_register_value,\n\t},\n\t[ACPI_EINJ_NOOP] = {\n\t\t.flags = 0,\n\t\t.run   = apei_exec_noop,\n\t},\n};\n\n/*\n * Prevent EINJ interpreter to run simultaneously, because the\n * corresponding firmware implementation may not work properly when\n * invoked simultaneously.\n */\nstatic DEFINE_MUTEX(einj_mutex);\n\nstatic void *einj_param;\n\nstatic void einj_exec_ctx_init(struct apei_exec_context *ctx)\n{\n\tapei_exec_ctx_init(ctx, einj_ins_type, ARRAY_SIZE(einj_ins_type),\n\t\t\t   EINJ_TAB_ENTRY(einj_tab), einj_tab->entries);\n}\n\nstatic int __einj_get_available_error_type(u32 *type)\n{\n\tstruct apei_exec_context ctx;\n\tint rc;\n\n\teinj_exec_ctx_init(&ctx);\n\trc = apei_exec_run(&ctx, ACPI_EINJ_GET_ERROR_TYPE);\n\tif (rc)\n\t\treturn rc;\n\t*type = apei_exec_ctx_get_output(&ctx);\n\n\treturn 0;\n}\n\n/* Get error injection capabilities of the platform */\nstatic int einj_get_available_error_type(u32 *type)\n{\n\tint rc;\n\n\tmutex_lock(&einj_mutex);\n\trc = __einj_get_available_error_type(type);\n\tmutex_unlock(&einj_mutex);\n\n\treturn rc;\n}\n\nstatic int einj_timedout(u64 *t)\n{\n\tif ((s64)*t < SPIN_UNIT) {\n\t\tpr_warning(FW_WARN EINJ_PFX\n\t\t\t   \"Firmware does not respond in time\\n\");\n\t\treturn 1;\n\t}\n\t*t -= SPIN_UNIT;\n\tndelay(SPIN_UNIT);\n\ttouch_nmi_watchdog();\n\treturn 0;\n}\n\nstatic void check_vendor_extension(u64 paddr,\n\t\t\t\t   struct set_error_type_with_address *v5param)\n{\n\tint\toffset = v5param->vendor_extension;\n\tstruct\tvendor_error_type_extension *v;\n\tu32\tsbdf;\n\n\tif (!offset)\n\t\treturn;\n\tv = acpi_os_map_iomem(paddr + offset, sizeof(*v));\n\tif (!v)\n\t\treturn;\n\tsbdf = v->pcie_sbdf;\n\tsprintf(vendor_dev, \"%x:%x:%x.%x vendor_id=%x device_id=%x rev_id=%x\\n\",\n\t\tsbdf >> 24, (sbdf >> 16) & 0xff,\n\t\t(sbdf >> 11) & 0x1f, (sbdf >> 8) & 0x7,\n\t\t v->vendor_id, v->device_id, v->rev_id);\n\tacpi_os_unmap_iomem(v, sizeof(*v));\n}\n\nstatic void *einj_get_parameter_address(void)\n{\n\tint i;\n\tu64 pa_v4 = 0, pa_v5 = 0;\n\tstruct acpi_whea_header *entry;\n\n\tentry = EINJ_TAB_ENTRY(einj_tab);\n\tfor (i = 0; i < einj_tab->entries; i++) {\n\t\tif (entry->action == ACPI_EINJ_SET_ERROR_TYPE &&\n\t\t    entry->instruction == ACPI_EINJ_WRITE_REGISTER &&\n\t\t    entry->register_region.space_id ==\n\t\t    ACPI_ADR_SPACE_SYSTEM_MEMORY)\n\t\t\tpa_v4 = get_unaligned(&entry->register_region.address);\n\t\tif (entry->action == ACPI_EINJ_SET_ERROR_TYPE_WITH_ADDRESS &&\n\t\t    entry->instruction == ACPI_EINJ_WRITE_REGISTER &&\n\t\t    entry->register_region.space_id ==\n\t\t    ACPI_ADR_SPACE_SYSTEM_MEMORY)\n\t\t\tpa_v5 = get_unaligned(&entry->register_region.address);\n\t\tentry++;\n\t}\n\tif (pa_v5) {\n\t\tstruct set_error_type_with_address *v5param;\n\n\t\tv5param = acpi_os_map_iomem(pa_v5, sizeof(*v5param));\n\t\tif (v5param) {\n\t\t\tacpi5 = 1;\n\t\t\tcheck_vendor_extension(pa_v5, v5param);\n\t\t\treturn v5param;\n\t\t}\n\t}\n\tif (param_extension && pa_v4) {\n\t\tstruct einj_parameter *v4param;\n\n\t\tv4param = acpi_os_map_iomem(pa_v4, sizeof(*v4param));\n\t\tif (!v4param)\n\t\t\treturn NULL;\n\t\tif (v4param->reserved1 || v4param->reserved2) {\n\t\t\tacpi_os_unmap_iomem(v4param, sizeof(*v4param));\n\t\t\treturn NULL;\n\t\t}\n\t\treturn v4param;\n\t}\n\n\treturn NULL;\n}\n\n/* do sanity check to trigger table */\nstatic int einj_check_trigger_header(struct acpi_einj_trigger *trigger_tab)\n{\n\tif (trigger_tab->header_size != sizeof(struct acpi_einj_trigger))\n\t\treturn -EINVAL;\n\tif (trigger_tab->table_size > PAGE_SIZE ||\n\t    trigger_tab->table_size < trigger_tab->header_size)\n\t\treturn -EINVAL;\n\tif (trigger_tab->entry_count !=\n\t    (trigger_tab->table_size - trigger_tab->header_size) /\n\t    sizeof(struct acpi_einj_entry))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic struct acpi_generic_address *einj_get_trigger_parameter_region(\n\tstruct acpi_einj_trigger *trigger_tab, u64 param1, u64 param2)\n{\n\tint i;\n\tstruct acpi_whea_header *entry;\n\n\tentry = (struct acpi_whea_header *)\n\t\t((char *)trigger_tab + sizeof(struct acpi_einj_trigger));\n\tfor (i = 0; i < trigger_tab->entry_count; i++) {\n\t\tif (entry->action == ACPI_EINJ_TRIGGER_ERROR &&\n\t\tentry->instruction == ACPI_EINJ_WRITE_REGISTER_VALUE &&\n\t\tentry->register_region.space_id ==\n\t\t\tACPI_ADR_SPACE_SYSTEM_MEMORY &&\n\t\t(entry->register_region.address & param2) == (param1 & param2))\n\t\t\treturn &entry->register_region;\n\t\tentry++;\n\t}\n\n\treturn NULL;\n}\n/* Execute instructions in trigger error action table */\nstatic int __einj_error_trigger(u64 trigger_paddr, u32 type,\n\t\t\t\tu64 param1, u64 param2)\n{\n\tstruct acpi_einj_trigger *trigger_tab = NULL;\n\tstruct apei_exec_context trigger_ctx;\n\tstruct apei_resources trigger_resources;\n\tstruct acpi_whea_header *trigger_entry;\n\tstruct resource *r;\n\tu32 table_size;\n\tint rc = -EIO;\n\tstruct acpi_generic_address *trigger_param_region = NULL;\n\n\tr = request_mem_region(trigger_paddr, sizeof(*trigger_tab),\n\t\t\t       \"APEI EINJ Trigger Table\");\n\tif (!r) {\n\t\tpr_err(EINJ_PFX\n\t\"Can not request [mem %#010llx-%#010llx] for Trigger table\\n\",\n\t\t       (unsigned long long)trigger_paddr,\n\t\t       (unsigned long long)trigger_paddr +\n\t\t\t    sizeof(*trigger_tab) - 1);\n\t\tgoto out;\n\t}\n\ttrigger_tab = ioremap_cache(trigger_paddr, sizeof(*trigger_tab));\n\tif (!trigger_tab) {\n\t\tpr_err(EINJ_PFX \"Failed to map trigger table!\\n\");\n\t\tgoto out_rel_header;\n\t}\n\trc = einj_check_trigger_header(trigger_tab);\n\tif (rc) {\n\t\tpr_warning(FW_BUG EINJ_PFX\n\t\t\t   \"The trigger error action table is invalid\\n\");\n\t\tgoto out_rel_header;\n\t}\n\n\t/* No action structures in the TRIGGER_ERROR table, nothing to do */\n\tif (!trigger_tab->entry_count)\n\t\tgoto out_rel_header;\n\n\trc = -EIO;\n\ttable_size = trigger_tab->table_size;\n\tr = request_mem_region(trigger_paddr + sizeof(*trigger_tab),\n\t\t\t       table_size - sizeof(*trigger_tab),\n\t\t\t       \"APEI EINJ Trigger Table\");\n\tif (!r) {\n\t\tpr_err(EINJ_PFX\n\"Can not request [mem %#010llx-%#010llx] for Trigger Table Entry\\n\",\n\t\t       (unsigned long long)trigger_paddr + sizeof(*trigger_tab),\n\t\t       (unsigned long long)trigger_paddr + table_size - 1);\n\t\tgoto out_rel_header;\n\t}\n\tiounmap(trigger_tab);\n\ttrigger_tab = ioremap_cache(trigger_paddr, table_size);\n\tif (!trigger_tab) {\n\t\tpr_err(EINJ_PFX \"Failed to map trigger table!\\n\");\n\t\tgoto out_rel_entry;\n\t}\n\ttrigger_entry = (struct acpi_whea_header *)\n\t\t((char *)trigger_tab + sizeof(struct acpi_einj_trigger));\n\tapei_resources_init(&trigger_resources);\n\tapei_exec_ctx_init(&trigger_ctx, einj_ins_type,\n\t\t\t   ARRAY_SIZE(einj_ins_type),\n\t\t\t   trigger_entry, trigger_tab->entry_count);\n\trc = apei_exec_collect_resources(&trigger_ctx, &trigger_resources);\n\tif (rc)\n\t\tgoto out_fini;\n\trc = apei_resources_sub(&trigger_resources, &einj_resources);\n\tif (rc)\n\t\tgoto out_fini;\n\t/*\n\t * Some firmware will access target address specified in\n\t * param1 to trigger the error when injecting memory error.\n\t * This will cause resource conflict with regular memory.  So\n\t * remove it from trigger table resources.\n\t */\n\tif ((param_extension || acpi5) && (type & MEM_ERROR_MASK) && param2) {\n\t\tstruct apei_resources addr_resources;\n\t\tapei_resources_init(&addr_resources);\n\t\ttrigger_param_region = einj_get_trigger_parameter_region(\n\t\t\ttrigger_tab, param1, param2);\n\t\tif (trigger_param_region) {\n\t\t\trc = apei_resources_add(&addr_resources,\n\t\t\t\ttrigger_param_region->address,\n\t\t\t\ttrigger_param_region->bit_width/8, true);\n\t\t\tif (rc)\n\t\t\t\tgoto out_fini;\n\t\t\trc = apei_resources_sub(&trigger_resources,\n\t\t\t\t\t&addr_resources);\n\t\t}\n\t\tapei_resources_fini(&addr_resources);\n\t\tif (rc)\n\t\t\tgoto out_fini;\n\t}\n\trc = apei_resources_request(&trigger_resources, \"APEI EINJ Trigger\");\n\tif (rc)\n\t\tgoto out_fini;\n\trc = apei_exec_pre_map_gars(&trigger_ctx);\n\tif (rc)\n\t\tgoto out_release;\n\n\trc = apei_exec_run(&trigger_ctx, ACPI_EINJ_TRIGGER_ERROR);\n\n\tapei_exec_post_unmap_gars(&trigger_ctx);\nout_release:\n\tapei_resources_release(&trigger_resources);\nout_fini:\n\tapei_resources_fini(&trigger_resources);\nout_rel_entry:\n\trelease_mem_region(trigger_paddr + sizeof(*trigger_tab),\n\t\t\t   table_size - sizeof(*trigger_tab));\nout_rel_header:\n\trelease_mem_region(trigger_paddr, sizeof(*trigger_tab));\nout:\n\tif (trigger_tab)\n\t\tiounmap(trigger_tab);\n\n\treturn rc;\n}\n\nstatic int __einj_error_inject(u32 type, u32 flags, u64 param1, u64 param2,\n\t\t\t       u64 param3, u64 param4)\n{\n\tstruct apei_exec_context ctx;\n\tu64 val, trigger_paddr, timeout = FIRMWARE_TIMEOUT;\n\tint rc;\n\n\teinj_exec_ctx_init(&ctx);\n\n\trc = apei_exec_run_optional(&ctx, ACPI_EINJ_BEGIN_OPERATION);\n\tif (rc)\n\t\treturn rc;\n\tapei_exec_ctx_set_input(&ctx, type);\n\tif (acpi5) {\n\t\tstruct set_error_type_with_address *v5param = einj_param;\n\n\t\tv5param->type = type;\n\t\tif (type & ACPI5_VENDOR_BIT) {\n\t\t\tswitch (vendor_flags) {\n\t\t\tcase SETWA_FLAGS_APICID:\n\t\t\t\tv5param->apicid = param1;\n\t\t\t\tbreak;\n\t\t\tcase SETWA_FLAGS_MEM:\n\t\t\t\tv5param->memory_address = param1;\n\t\t\t\tv5param->memory_address_range = param2;\n\t\t\t\tbreak;\n\t\t\tcase SETWA_FLAGS_PCIE_SBDF:\n\t\t\t\tv5param->pcie_sbdf = param1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tv5param->flags = vendor_flags;\n\t\t} else if (flags) {\n\t\t\t\tv5param->flags = flags;\n\t\t\t\tv5param->memory_address = param1;\n\t\t\t\tv5param->memory_address_range = param2;\n\t\t\t\tv5param->apicid = param3;\n\t\t\t\tv5param->pcie_sbdf = param4;\n\t\t} else {\n\t\t\tswitch (type) {\n\t\t\tcase ACPI_EINJ_PROCESSOR_CORRECTABLE:\n\t\t\tcase ACPI_EINJ_PROCESSOR_UNCORRECTABLE:\n\t\t\tcase ACPI_EINJ_PROCESSOR_FATAL:\n\t\t\t\tv5param->apicid = param1;\n\t\t\t\tv5param->flags = SETWA_FLAGS_APICID;\n\t\t\t\tbreak;\n\t\t\tcase ACPI_EINJ_MEMORY_CORRECTABLE:\n\t\t\tcase ACPI_EINJ_MEMORY_UNCORRECTABLE:\n\t\t\tcase ACPI_EINJ_MEMORY_FATAL:\n\t\t\t\tv5param->memory_address = param1;\n\t\t\t\tv5param->memory_address_range = param2;\n\t\t\t\tv5param->flags = SETWA_FLAGS_MEM;\n\t\t\t\tbreak;\n\t\t\tcase ACPI_EINJ_PCIX_CORRECTABLE:\n\t\t\tcase ACPI_EINJ_PCIX_UNCORRECTABLE:\n\t\t\tcase ACPI_EINJ_PCIX_FATAL:\n\t\t\t\tv5param->pcie_sbdf = param1;\n\t\t\t\tv5param->flags = SETWA_FLAGS_PCIE_SBDF;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\trc = apei_exec_run(&ctx, ACPI_EINJ_SET_ERROR_TYPE);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (einj_param) {\n\t\t\tstruct einj_parameter *v4param = einj_param;\n\t\t\tv4param->param1 = param1;\n\t\t\tv4param->param2 = param2;\n\t\t}\n\t}\n\trc = apei_exec_run(&ctx, ACPI_EINJ_EXECUTE_OPERATION);\n\tif (rc)\n\t\treturn rc;\n\tfor (;;) {\n\t\trc = apei_exec_run(&ctx, ACPI_EINJ_CHECK_BUSY_STATUS);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tval = apei_exec_ctx_get_output(&ctx);\n\t\tif (!(val & EINJ_OP_BUSY))\n\t\t\tbreak;\n\t\tif (einj_timedout(&timeout))\n\t\t\treturn -EIO;\n\t}\n\trc = apei_exec_run(&ctx, ACPI_EINJ_GET_COMMAND_STATUS);\n\tif (rc)\n\t\treturn rc;\n\tval = apei_exec_ctx_get_output(&ctx);\n\tif (val != EINJ_STATUS_SUCCESS)\n\t\treturn -EBUSY;\n\n\trc = apei_exec_run(&ctx, ACPI_EINJ_GET_TRIGGER_TABLE);\n\tif (rc)\n\t\treturn rc;\n\ttrigger_paddr = apei_exec_ctx_get_output(&ctx);\n\tif (notrigger == 0) {\n\t\trc = __einj_error_trigger(trigger_paddr, type, param1, param2);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\trc = apei_exec_run_optional(&ctx, ACPI_EINJ_END_OPERATION);\n\n\treturn rc;\n}\n\n/* Inject the specified hardware error */\nstatic int einj_error_inject(u32 type, u32 flags, u64 param1, u64 param2,\n\t\t\t     u64 param3, u64 param4)\n{\n\tint rc;\n\tu64 base_addr, size;\n\n\tif (get_securelevel() > 0)\n\t\treturn -EPERM;\n\n\t/* If user manually set \"flags\", make sure it is legal */\n\tif (flags && (flags &\n\t\t~(SETWA_FLAGS_APICID|SETWA_FLAGS_MEM|SETWA_FLAGS_PCIE_SBDF)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * We need extra sanity checks for memory errors.\n\t * Other types leap directly to injection.\n\t */\n\n\t/* ensure param1/param2 existed */\n\tif (!(param_extension || acpi5))\n\t\tgoto inject;\n\n\t/* ensure injection is memory related */\n\tif (type & ACPI5_VENDOR_BIT) {\n\t\tif (vendor_flags != SETWA_FLAGS_MEM)\n\t\t\tgoto inject;\n\t} else if (!(type & MEM_ERROR_MASK) && !(flags & SETWA_FLAGS_MEM))\n\t\tgoto inject;\n\n\t/*\n\t * Disallow crazy address masks that give BIOS leeway to pick\n\t * injection address almost anywhere. Insist on page or\n\t * better granularity and that target address is normal RAM or\n\t * NVDIMM.\n\t */\n\tbase_addr = param1 & param2;\n\tsize = ~param2 + 1;\n\n\tif (((param2 & PAGE_MASK) != PAGE_MASK) ||\n\t    ((region_intersects(base_addr, size, IORESOURCE_SYSTEM_RAM, IORES_DESC_NONE)\n\t\t\t\t!= REGION_INTERSECTS) &&\n\t     (region_intersects(base_addr, size, IORESOURCE_MEM, IORES_DESC_PERSISTENT_MEMORY)\n\t\t\t\t!= REGION_INTERSECTS)))\n\t\treturn -EINVAL;\n\ninject:\n\tmutex_lock(&einj_mutex);\n\trc = __einj_error_inject(type, flags, param1, param2, param3, param4);\n\tmutex_unlock(&einj_mutex);\n\n\treturn rc;\n}\n\nstatic u32 error_type;\nstatic u32 error_flags;\nstatic u64 error_param1;\nstatic u64 error_param2;\nstatic u64 error_param3;\nstatic u64 error_param4;\nstatic struct dentry *einj_debug_dir;\n\nstatic int available_error_type_show(struct seq_file *m, void *v)\n{\n\tint rc;\n\tu32 available_error_type = 0;\n\n\trc = einj_get_available_error_type(&available_error_type);\n\tif (rc)\n\t\treturn rc;\n\tif (available_error_type & 0x0001)\n\t\tseq_printf(m, \"0x00000001\\tProcessor Correctable\\n\");\n\tif (available_error_type & 0x0002)\n\t\tseq_printf(m, \"0x00000002\\tProcessor Uncorrectable non-fatal\\n\");\n\tif (available_error_type & 0x0004)\n\t\tseq_printf(m, \"0x00000004\\tProcessor Uncorrectable fatal\\n\");\n\tif (available_error_type & 0x0008)\n\t\tseq_printf(m, \"0x00000008\\tMemory Correctable\\n\");\n\tif (available_error_type & 0x0010)\n\t\tseq_printf(m, \"0x00000010\\tMemory Uncorrectable non-fatal\\n\");\n\tif (available_error_type & 0x0020)\n\t\tseq_printf(m, \"0x00000020\\tMemory Uncorrectable fatal\\n\");\n\tif (available_error_type & 0x0040)\n\t\tseq_printf(m, \"0x00000040\\tPCI Express Correctable\\n\");\n\tif (available_error_type & 0x0080)\n\t\tseq_printf(m, \"0x00000080\\tPCI Express Uncorrectable non-fatal\\n\");\n\tif (available_error_type & 0x0100)\n\t\tseq_printf(m, \"0x00000100\\tPCI Express Uncorrectable fatal\\n\");\n\tif (available_error_type & 0x0200)\n\t\tseq_printf(m, \"0x00000200\\tPlatform Correctable\\n\");\n\tif (available_error_type & 0x0400)\n\t\tseq_printf(m, \"0x00000400\\tPlatform Uncorrectable non-fatal\\n\");\n\tif (available_error_type & 0x0800)\n\t\tseq_printf(m, \"0x00000800\\tPlatform Uncorrectable fatal\\n\");\n\n\treturn 0;\n}\n\nstatic int available_error_type_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, available_error_type_show, NULL);\n}\n\nstatic const struct file_operations available_error_type_fops = {\n\t.open\t\t= available_error_type_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nstatic int error_type_get(void *data, u64 *val)\n{\n\t*val = error_type;\n\n\treturn 0;\n}\n\nstatic int error_type_set(void *data, u64 val)\n{\n\tint rc;\n\tu32 available_error_type = 0;\n\tu32 tval, vendor;\n\n\t/*\n\t * Vendor defined types have 0x80000000 bit set, and\n\t * are not enumerated by ACPI_EINJ_GET_ERROR_TYPE\n\t */\n\tvendor = val & ACPI5_VENDOR_BIT;\n\ttval = val & 0x7fffffff;\n\n\t/* Only one error type can be specified */\n\tif (tval & (tval - 1))\n\t\treturn -EINVAL;\n\tif (!vendor) {\n\t\trc = einj_get_available_error_type(&available_error_type);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tif (!(val & available_error_type))\n\t\t\treturn -EINVAL;\n\t}\n\terror_type = val;\n\n\treturn 0;\n}\n\nDEFINE_SIMPLE_ATTRIBUTE(error_type_fops, error_type_get,\n\t\t\terror_type_set, \"0x%llx\\n\");\n\nstatic int error_inject_set(void *data, u64 val)\n{\n\tif (!error_type)\n\t\treturn -EINVAL;\n\n\treturn einj_error_inject(error_type, error_flags, error_param1, error_param2,\n\t\terror_param3, error_param4);\n}\n\nDEFINE_SIMPLE_ATTRIBUTE(error_inject_fops, NULL,\n\t\t\terror_inject_set, \"%llu\\n\");\n\nstatic int einj_check_table(struct acpi_table_einj *einj_tab)\n{\n\tif ((einj_tab->header_length !=\n\t     (sizeof(struct acpi_table_einj) - sizeof(einj_tab->header)))\n\t    && (einj_tab->header_length != sizeof(struct acpi_table_einj)))\n\t\treturn -EINVAL;\n\tif (einj_tab->header.length < sizeof(struct acpi_table_einj))\n\t\treturn -EINVAL;\n\tif (einj_tab->entries !=\n\t    (einj_tab->header.length - sizeof(struct acpi_table_einj)) /\n\t    sizeof(struct acpi_einj_entry))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int __init einj_init(void)\n{\n\tint rc;\n\tacpi_status status;\n\tstruct dentry *fentry;\n\tstruct apei_exec_context ctx;\n\n\tif (acpi_disabled)\n\t\treturn -ENODEV;\n\n\tstatus = acpi_get_table(ACPI_SIG_EINJ, 0,\n\t\t\t\t(struct acpi_table_header **)&einj_tab);\n\tif (status == AE_NOT_FOUND)\n\t\treturn -ENODEV;\n\telse if (ACPI_FAILURE(status)) {\n\t\tconst char *msg = acpi_format_exception(status);\n\t\tpr_err(EINJ_PFX \"Failed to get table, %s\\n\", msg);\n\t\treturn -EINVAL;\n\t}\n\n\trc = einj_check_table(einj_tab);\n\tif (rc) {\n\t\tpr_warning(FW_BUG EINJ_PFX \"EINJ table is invalid\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\trc = -ENOMEM;\n\teinj_debug_dir = debugfs_create_dir(\"einj\", apei_get_debugfs_dir());\n\tif (!einj_debug_dir)\n\t\tgoto err_cleanup;\n\tfentry = debugfs_create_file(\"available_error_type\", S_IRUSR,\n\t\t\t\t     einj_debug_dir, NULL,\n\t\t\t\t     &available_error_type_fops);\n\tif (!fentry)\n\t\tgoto err_cleanup;\n\tfentry = debugfs_create_file(\"error_type\", S_IRUSR | S_IWUSR,\n\t\t\t\t     einj_debug_dir, NULL, &error_type_fops);\n\tif (!fentry)\n\t\tgoto err_cleanup;\n\tfentry = debugfs_create_file(\"error_inject\", S_IWUSR,\n\t\t\t\t     einj_debug_dir, NULL, &error_inject_fops);\n\tif (!fentry)\n\t\tgoto err_cleanup;\n\n\tapei_resources_init(&einj_resources);\n\teinj_exec_ctx_init(&ctx);\n\trc = apei_exec_collect_resources(&ctx, &einj_resources);\n\tif (rc)\n\t\tgoto err_fini;\n\trc = apei_resources_request(&einj_resources, \"APEI EINJ\");\n\tif (rc)\n\t\tgoto err_fini;\n\trc = apei_exec_pre_map_gars(&ctx);\n\tif (rc)\n\t\tgoto err_release;\n\n\trc = -ENOMEM;\n\teinj_param = einj_get_parameter_address();\n\tif ((param_extension || acpi5) && einj_param) {\n\t\tfentry = debugfs_create_x32(\"flags\", S_IRUSR | S_IWUSR,\n\t\t\t\t\t    einj_debug_dir, &error_flags);\n\t\tif (!fentry)\n\t\t\tgoto err_unmap;\n\t\tfentry = debugfs_create_x64(\"param1\", S_IRUSR | S_IWUSR,\n\t\t\t\t\t    einj_debug_dir, &error_param1);\n\t\tif (!fentry)\n\t\t\tgoto err_unmap;\n\t\tfentry = debugfs_create_x64(\"param2\", S_IRUSR | S_IWUSR,\n\t\t\t\t\t    einj_debug_dir, &error_param2);\n\t\tif (!fentry)\n\t\t\tgoto err_unmap;\n\t\tfentry = debugfs_create_x64(\"param3\", S_IRUSR | S_IWUSR,\n\t\t\t\t\t    einj_debug_dir, &error_param3);\n\t\tif (!fentry)\n\t\t\tgoto err_unmap;\n\t\tfentry = debugfs_create_x64(\"param4\", S_IRUSR | S_IWUSR,\n\t\t\t\t\t    einj_debug_dir, &error_param4);\n\t\tif (!fentry)\n\t\t\tgoto err_unmap;\n\n\t\tfentry = debugfs_create_x32(\"notrigger\", S_IRUSR | S_IWUSR,\n\t\t\t\t\t    einj_debug_dir, &notrigger);\n\t\tif (!fentry)\n\t\t\tgoto err_unmap;\n\t}\n\n\tif (vendor_dev[0]) {\n\t\tvendor_blob.data = vendor_dev;\n\t\tvendor_blob.size = strlen(vendor_dev);\n\t\tfentry = debugfs_create_blob(\"vendor\", S_IRUSR,\n\t\t\t\t\t     einj_debug_dir, &vendor_blob);\n\t\tif (!fentry)\n\t\t\tgoto err_unmap;\n\t\tfentry = debugfs_create_x32(\"vendor_flags\", S_IRUSR | S_IWUSR,\n\t\t\t\t\t    einj_debug_dir, &vendor_flags);\n\t\tif (!fentry)\n\t\t\tgoto err_unmap;\n\t}\n\n\tpr_info(EINJ_PFX \"Error INJection is initialized.\\n\");\n\n\treturn 0;\n\nerr_unmap:\n\tif (einj_param) {\n\t\tacpi_size size = (acpi5) ?\n\t\t\tsizeof(struct set_error_type_with_address) :\n\t\t\tsizeof(struct einj_parameter);\n\n\t\tacpi_os_unmap_iomem(einj_param, size);\n\t}\n\tapei_exec_post_unmap_gars(&ctx);\nerr_release:\n\tapei_resources_release(&einj_resources);\nerr_fini:\n\tapei_resources_fini(&einj_resources);\nerr_cleanup:\n\tdebugfs_remove_recursive(einj_debug_dir);\n\n\treturn rc;\n}\n\nstatic void __exit einj_exit(void)\n{\n\tstruct apei_exec_context ctx;\n\n\tif (einj_param) {\n\t\tacpi_size size = (acpi5) ?\n\t\t\tsizeof(struct set_error_type_with_address) :\n\t\t\tsizeof(struct einj_parameter);\n\n\t\tacpi_os_unmap_iomem(einj_param, size);\n\t}\n\teinj_exec_ctx_init(&ctx);\n\tapei_exec_post_unmap_gars(&ctx);\n\tapei_resources_release(&einj_resources);\n\tapei_resources_fini(&einj_resources);\n\tdebugfs_remove_recursive(einj_debug_dir);\n}\n\nmodule_init(einj_init);\nmodule_exit(einj_exit);\n\nMODULE_AUTHOR(\"Huang Ying\");\nMODULE_DESCRIPTION(\"APEI Error INJection support\");\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["drivers/acpi/apei/einj.c"], "buggy_code_start_loc": [31], "buggy_code_end_loc": [523], "fixing_code_start_loc": [32], "fixing_code_end_loc": [528], "type": "CWE-74", "message": "The einj_error_inject function in drivers/acpi/apei/einj.c in the Linux kernel allows local users to simulate hardware errors and consequently cause a denial of service by leveraging failure to disable APEI error injection through EINJ when securelevel is set.", "other": {"cve": {"id": "CVE-2016-3695", "sourceIdentifier": "secalert@redhat.com", "published": "2017-12-29T15:29:00.580", "lastModified": "2018-01-10T16:44:01.997", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The einj_error_inject function in drivers/acpi/apei/einj.c in the Linux kernel allows local users to simulate hardware errors and consequently cause a denial of service by leveraging failure to disable APEI error injection through EINJ when securelevel is set."}, {"lang": "es", "value": "La funci\u00f3n einj_error_inject en drivers/acpi/apei/einj.c en el kernel de Linux permite que usuarios locales simulen errores de hardware y, consecuentemente, provoquen una denegaci\u00f3n de servicio (DoS) aprovechando el error a la hora de deshabilitar la inyecci\u00f3n de errores APEI mediante EINJ cuando est\u00e1 establecido securelevel."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:-:*:*:*:*:*:*:*", "matchCriteriaId": "703AF700-7A70-47E2-BC3A-7FD03B3CA9C1"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "142AD0DD-4CF3-4D74-9442-459CE3347E3A"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/102327", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1322755", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/mjg59/linux/commit/d7a6be58edc01b1c66ecd8fcc91236bfbce0a420", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mjg59/linux/commit/d7a6be58edc01b1c66ecd8fcc91236bfbce0a420"}}