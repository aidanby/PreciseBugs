{"buggy_code": ["// SPDX-FileCopyrightText: 2021 RizinOrg <info@rizin.re>\n// SPDX-FileCopyrightText: 2021 deroad <wargio@libero.it>\n// SPDX-License-Identifier: LGPL-3.0-only\n\n#include \"dex.h\"\n#include <rz_util.h>\n\n#define DEX_INVALID_CLASS  \"Lunknown_class;\"\n#define DEX_INVALID_METHOD \"unknown_method\"\n\ntypedef struct dex_access_flags_readable_t {\n\tut32 flag;\n\tconst char *readable;\n} DexAccessFlagsReadable;\n\n#define read_le_bits_or_fail(bits, buf, val, fail) \\\n\tdo { \\\n\t\tif (!rz_buf_read_le##bits(buf, &val)) { \\\n\t\t\tgoto fail; \\\n\t\t} \\\n\t} while (0)\n\n#define read_le_at_bits_or_fail(bits, buf, val, offset, fail) \\\n\tdo { \\\n\t\tif (!rz_buf_read_le##bits##_at(buf, offset, &val)) { \\\n\t\t\tgoto fail; \\\n\t\t} \\\n\t} while (0)\n\n#define read_le32_or_fail(buf, val, fail)            read_le_bits_or_fail(32, buf, val, fail)\n#define read_le16_or_fail(buf, val, fail)            read_le_bits_or_fail(16, buf, val, fail)\n#define read_le32_at_or_fail(buf, val, offset, fail) read_le_at_bits_or_fail(32, buf, val, offset, fail)\n#define read_le16_at_or_fail(buf, val, offset, fail) read_le_at_bits_or_fail(16, buf, val, offset, fail)\n\n#define dex_is_static(a)  (a & ACCESS_FLAG_STATIC)\n#define dex_is_varargs(a) (a & ACCESS_FLAG_VARARGS)\n\n#define dex_fail_if_bad_ids(name, z, s, g) \\\n\tdo { \\\n\t\tut64 end = name##_offset; \\\n\t\tend += name##_size * (z); \\\n\t\tif (end >= (s)) { \\\n\t\t\tgoto g; \\\n\t\t} \\\n\t} while (0)\n\n#define CLASS_ACCESS_FLAGS_SIZE 18\nstatic const DexAccessFlagsReadable access_flags_list[CLASS_ACCESS_FLAGS_SIZE] = {\n\t{ ACCESS_FLAG_PUBLIC /*               */, \"public\" },\n\t{ ACCESS_FLAG_PRIVATE /*              */, \"private\" },\n\t{ ACCESS_FLAG_PROTECTED /*            */, \"protected\" },\n\t{ ACCESS_FLAG_STATIC /*               */, \"static\" },\n\t{ ACCESS_FLAG_FINAL /*                */, \"final\" },\n\t{ ACCESS_FLAG_SYNCHRONIZED /*         */, \"synchronized\" },\n\t{ ACCESS_FLAG_BRIDGE /*               */, \"bridge\" },\n\t{ ACCESS_FLAG_VARARGS /*              */, \"varargs\" },\n\t{ ACCESS_FLAG_NATIVE /*               */, \"native\" },\n\t{ ACCESS_FLAG_INTERFACE /*            */, \"interface\" },\n\t{ ACCESS_FLAG_ABSTRACT /*             */, \"abstract\" },\n\t{ ACCESS_FLAG_STRICT /*               */, \"strict\" },\n\t{ ACCESS_FLAG_SYNTHETIC /*            */, \"synthetic\" },\n\t{ ACCESS_FLAG_ANNOTATION /*           */, \"annotation\" },\n\t{ ACCESS_FLAG_ENUM /*                 */, \"enum\" },\n\t{ ACCESS_FLAG_MODULE /*               */, \"module\" },\n\t{ ACCESS_FLAG_CONSTRUCTOR /*          */, \"constructor\" },\n\t{ ACCESS_FLAG_DECLARED_SYNCHRONIZED /**/, \"synchronized\" },\n};\n\nstatic void dex_string_free(DexString *string) {\n\tif (!string) {\n\t\treturn;\n\t}\n\tfree(string->data);\n\tfree(string);\n}\n\nstatic DexString *dex_string_new(RzBuffer *buf, ut64 offset, st64 *pread) {\n\tut64 size = 0;\n\tchar *data = NULL;\n\tst64 read;\n\tDexString *string = NULL;\n\n\tread = rz_buf_uleb128(buf, &size);\n\tdata = malloc(size + 1);\n\tif (!data || rz_buf_read(buf, (ut8 *)data, size) != size) {\n\t\tfree(data);\n\t\treturn NULL;\n\t}\n\tdata[size] = 0;\n\n\tstring = RZ_NEW0(DexString);\n\tif (!string) {\n\t\tfree(data);\n\t\treturn NULL;\n\t}\n\n\t*pread = read;\n\tstring->size = size;\n\tstring->offset = offset;\n\tstring->data = data;\n\treturn string;\n}\n\nstatic void dex_proto_id_free(DexProtoId *string) {\n\tif (!string) {\n\t\treturn;\n\t}\n\tfree(string->type_list);\n\tfree(string);\n}\n\nstatic DexProtoId *dex_proto_id_new(RzBuffer *buf, ut64 offset) {\n\tDexProtoId *proto_id = RZ_NEW0(DexProtoId);\n\tif (!proto_id) {\n\t\treturn NULL;\n\t}\n\n\tut32 parameters_offset = 0;\n\tproto_id->offset = offset;\n\tread_le32_or_fail(buf, proto_id->shorty_idx, dex_proto_id_new_fail);\n\tread_le32_or_fail(buf, proto_id->return_type_idx, dex_proto_id_new_fail);\n\n\tread_le32_or_fail(buf, parameters_offset, dex_proto_id_new_fail);\n\tif (parameters_offset > 0) {\n\t\tut32 count = 0;\n\t\tread_le32_at_or_fail(buf, count, parameters_offset, dex_proto_id_new_fail);\n\n\t\tproto_id->type_list_size = count;\n\t\tproto_id->type_list = RZ_NEWS(ut16, count);\n\t\tif (!proto_id->type_list) {\n\t\t\tgoto dex_proto_id_new_fail;\n\t\t}\n\n\t\tparameters_offset += sizeof(ut32);\n\t\tfor (ut32 i = 0; i < count; ++i, parameters_offset += sizeof(ut16)) {\n\t\t\tread_le16_at_or_fail(buf, proto_id->type_list[i], parameters_offset, dex_proto_id_new_fail);\n\t\t}\n\t}\n\n\treturn proto_id;\n\ndex_proto_id_new_fail:\n\tfree(proto_id);\n\treturn NULL;\n}\n\n#define dex_field_id_free free\nstatic DexFieldId *dex_field_id_new(RzBuffer *buf, ut64 offset) {\n\tDexFieldId *field_id = RZ_NEW0(DexFieldId);\n\tif (!field_id) {\n\t\treturn NULL;\n\t}\n\n\tread_le16_or_fail(buf, field_id->class_idx, dex_field_id_new_fail);\n\tread_le16_or_fail(buf, field_id->type_idx, dex_field_id_new_fail);\n\tread_le32_or_fail(buf, field_id->name_idx, dex_field_id_new_fail);\n\tfield_id->offset = offset;\n\treturn field_id;\n\ndex_field_id_new_fail:\n\tfree(field_id);\n\treturn NULL;\n}\n\n#define dex_method_id_free free\nstatic DexMethodId *dex_method_id_new(RzBuffer *buf, ut64 offset) {\n\tDexMethodId *method_id = RZ_NEW0(DexMethodId);\n\tif (!method_id) {\n\t\treturn NULL;\n\t}\n\n\tread_le16_or_fail(buf, method_id->class_idx, dex_method_id_new_fail);\n\tread_le16_or_fail(buf, method_id->proto_idx, dex_method_id_new_fail);\n\tread_le32_or_fail(buf, method_id->name_idx, dex_method_id_new_fail);\n\tmethod_id->offset = offset;\n\treturn method_id;\n\ndex_method_id_new_fail:\n\tfree(method_id);\n\treturn NULL;\n}\n\nstatic void dex_class_def_free(DexClassDef *class_def) {\n\tif (!class_def) {\n\t\treturn;\n\t}\n\trz_list_free(class_def->static_fields);\n\trz_list_free(class_def->instance_fields);\n\trz_list_free(class_def->direct_methods);\n\trz_list_free(class_def->virtual_methods);\n\tfree(class_def->interfaces);\n\tfree(class_def);\n}\n\nstatic DexEncodedField *dex_new_encoded_field(RzBuffer *buf, ut64 base, ut64 *diff_value_prev, bool first) {\n\tDexEncodedField *encoded_field = RZ_NEW0(DexEncodedField);\n\tif (!encoded_field) {\n\t\treturn NULL;\n\t}\n\tut64 diff_value = 0;\n\n\tencoded_field->offset = rz_buf_tell(buf) + base;\n\trz_buf_uleb128(buf, &diff_value);\n\trz_buf_uleb128(buf, &encoded_field->access_flags);\n\n\tif (first) {\n\t\tencoded_field->field_idx = diff_value;\n\t\t*diff_value_prev = diff_value;\n\t} else {\n\t\tencoded_field->field_idx = *diff_value_prev + diff_value;\n\t\t*diff_value_prev = encoded_field->field_idx;\n\t}\n\treturn encoded_field;\n}\n\nstatic DexEncodedMethod *dex_new_encoded_method(RzBuffer *buf, ut64 base, ut64 *diff_value_prev, bool first, RzPVector *method_ids) {\n\tDexEncodedMethod *encoded_method = RZ_NEW0(DexEncodedMethod);\n\tif (!encoded_method) {\n\t\treturn NULL;\n\t}\n\tut64 diff_value = 0;\n\tut64 code_offset = 0;\n\n\tencoded_method->offset = rz_buf_tell(buf) + base;\n\trz_buf_uleb128(buf, &diff_value);\n\trz_buf_uleb128(buf, &encoded_method->access_flags);\n\trz_buf_uleb128(buf, &code_offset);\n\n\tif (first) {\n\t\tencoded_method->method_idx = diff_value;\n\t\t*diff_value_prev = diff_value;\n\t} else {\n\t\tencoded_method->method_idx = *diff_value_prev + diff_value;\n\t\t*diff_value_prev = encoded_method->method_idx;\n\t}\n\n\tif (code_offset > 0) {\n\t\tread_le16_at_or_fail(buf, encoded_method->registers_size, code_offset, dex_new_encoded_method_fail);\n\t\tread_le16_at_or_fail(buf, encoded_method->ins_size, code_offset + 2, dex_new_encoded_method_fail);\n\t\tread_le16_at_or_fail(buf, encoded_method->outs_size, code_offset + 4, dex_new_encoded_method_fail);\n\t\tread_le16_at_or_fail(buf, encoded_method->tries_size, code_offset + 6, dex_new_encoded_method_fail);\n\t\tread_le32_at_or_fail(buf, encoded_method->debug_info_offset, code_offset + 8, dex_new_encoded_method_fail);\n\t\tread_le32_at_or_fail(buf, encoded_method->code_size, code_offset + 12, dex_new_encoded_method_fail);\n\t\tencoded_method->code_size *= sizeof(ut16); // code ushort[insns_size]\n\t\tencoded_method->code_offset = code_offset + 16 + base;\n\n\t\tif (encoded_method->method_idx < rz_pvector_len(method_ids)) {\n\t\t\tDexMethodId *method_id = (DexMethodId *)rz_pvector_at(method_ids, encoded_method->method_idx);\n\t\t\tif (method_id) {\n\t\t\t\tmethod_id->code_offset = encoded_method->code_offset;\n\t\t\t\tmethod_id->code_size = encoded_method->code_size;\n\t\t\t}\n\t\t}\n\t}\n\treturn encoded_method;\n\ndex_new_encoded_method_fail:\n\tfree(encoded_method);\n\treturn NULL;\n}\n\nstatic DexClassDef *dex_class_def_new(RzBuffer *buf, ut64 offset, ut64 base, RzPVector *method_ids) {\n\tDexClassDef *class_def = RZ_NEW0(DexClassDef);\n\tif (!class_def) {\n\t\treturn NULL;\n\t}\n\n\tut64 static_fields_size = 0;\n\tut64 instance_fields_size = 0;\n\tut64 direct_methods_size = 0;\n\tut64 virtual_methods_size = 0;\n\tut64 diff_value_prev;\n\n\tclass_def->static_fields = /*  */ rz_list_newf((RzListFree)free);\n\tclass_def->instance_fields = /**/ rz_list_newf((RzListFree)free);\n\tclass_def->direct_methods = /* */ rz_list_newf((RzListFree)free);\n\tclass_def->virtual_methods = /**/ rz_list_newf((RzListFree)free);\n\n\tread_le16_or_fail(buf, class_def->class_idx, dex_class_def_new_fail);\n\tread_le16_or_fail(buf, class_def->_padding1, dex_class_def_new_fail);\n\tread_le32_or_fail(buf, class_def->access_flags, dex_class_def_new_fail);\n\tread_le16_or_fail(buf, class_def->superclass_idx, dex_class_def_new_fail);\n\tread_le16_or_fail(buf, class_def->_padding2, dex_class_def_new_fail);\n\tread_le32_or_fail(buf, class_def->interfaces_offset, dex_class_def_new_fail);\n\tread_le32_or_fail(buf, class_def->source_file_idx, dex_class_def_new_fail);\n\tread_le32_or_fail(buf, class_def->annotations_offset, dex_class_def_new_fail);\n\tread_le32_or_fail(buf, class_def->class_data_offset, dex_class_def_new_fail);\n\tread_le32_or_fail(buf, class_def->static_values_offset, dex_class_def_new_fail);\n\tclass_def->offset = offset;\n\n\tif (class_def->interfaces_offset > 0) {\n\t\tif (rz_buf_seek(buf, class_def->interfaces_offset, RZ_BUF_SET) < 0) {\n\t\t\tgoto dex_class_def_new_fail;\n\t\t}\n\t\tread_le32_or_fail(buf, class_def->n_interfaces, dex_class_def_new_fail);\n\t\tif (class_def->n_interfaces > 0) {\n\t\t\tclass_def->interfaces = RZ_NEWS0(ut16, class_def->n_interfaces);\n\t\t\tif (!class_def->interfaces) {\n\t\t\t\tgoto dex_class_def_new_fail;\n\t\t\t}\n\t\t\tfor (ut32 i = 0; i < class_def->n_interfaces; ++i) {\n\t\t\t\tread_le16_or_fail(buf, class_def->interfaces[i], dex_class_def_new_fail);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!class_def->class_data_offset) {\n\t\treturn class_def;\n\t}\n\n\tif (rz_buf_seek(buf, class_def->class_data_offset, RZ_BUF_SET) < 0) {\n\t\tgoto dex_class_def_new_fail;\n\t}\n\n\trz_buf_uleb128(buf, &static_fields_size);\n\trz_buf_uleb128(buf, &instance_fields_size);\n\trz_buf_uleb128(buf, &direct_methods_size);\n\trz_buf_uleb128(buf, &virtual_methods_size);\n\n\tfor (ut64 i = 0; i < static_fields_size; ++i) {\n\t\tDexEncodedField *encoded_field = dex_new_encoded_field(buf, base, &diff_value_prev, i < 1);\n\t\tif (!encoded_field || !rz_list_append(class_def->static_fields, encoded_field)) {\n\t\t\tfree(encoded_field);\n\t\t\tgoto dex_class_def_new_fail;\n\t\t}\n\t}\n\n\tfor (ut64 i = 0; i < instance_fields_size; ++i) {\n\t\tDexEncodedField *encoded_field = dex_new_encoded_field(buf, base, &diff_value_prev, i < 1);\n\t\tif (!encoded_field || !rz_list_append(class_def->instance_fields, encoded_field)) {\n\t\t\tfree(encoded_field);\n\t\t\tgoto dex_class_def_new_fail;\n\t\t}\n\t}\n\n\tfor (ut64 i = 0; i < direct_methods_size; ++i) {\n\t\tDexEncodedMethod *encoded_method = dex_new_encoded_method(buf, base, &diff_value_prev, i < 1, method_ids);\n\t\tif (!encoded_method || !rz_list_append(class_def->direct_methods, encoded_method)) {\n\t\t\tfree(encoded_method);\n\t\t\tgoto dex_class_def_new_fail;\n\t\t}\n\t}\n\n\tfor (ut64 i = 0; i < virtual_methods_size; ++i) {\n\t\tDexEncodedMethod *encoded_method = dex_new_encoded_method(buf, base, &diff_value_prev, i < 1, method_ids);\n\t\tif (!encoded_method || !rz_list_append(class_def->virtual_methods, encoded_method)) {\n\t\t\tfree(encoded_method);\n\t\t\tgoto dex_class_def_new_fail;\n\t\t}\n\t}\n\n\treturn class_def;\n\ndex_class_def_new_fail:\n\tdex_class_def_free(class_def);\n\treturn NULL;\n}\n\nstatic void dex_resolve_virtual_method_code(RzBinDex *dex, DexMethodId *to_resolve, ut32 superclass_idx) {\n\tDexMethodId *method_id = NULL;\n\tvoid **it;\n\n\trz_pvector_foreach (dex->method_ids, it) {\n\t\tmethod_id = (DexMethodId *)*it;\n\t\tif (method_id == to_resolve ||\n\t\t\tmethod_id->class_idx != superclass_idx ||\n\t\t\tmethod_id->proto_idx != to_resolve->proto_idx ||\n\t\t\tmethod_id->name_idx != to_resolve->name_idx) {\n\t\t\tcontinue;\n\t\t}\n\t\tto_resolve->code_offset = method_id->code_offset;\n\t\tto_resolve->code_size = method_id->code_size;\n\t\treturn;\n\t}\n}\n\nstatic void dex_resolve_all_virtual_methods(RzBinDex *dex) {\n\tDexClassDef *class_def;\n\tDexMethodId *method_id = NULL;\n\tvoid **it;\n\tdex->relocs_size = 0;\n\trz_pvector_foreach (dex->method_ids, it) {\n\t\tmethod_id = (DexMethodId *)*it;\n\t\tif (method_id->code_offset ||\n\t\t\tmethod_id->class_idx >= rz_pvector_len(dex->class_defs)) {\n\t\t\tcontinue;\n\t\t}\n\t\tclass_def = rz_pvector_at(dex->class_defs, method_id->class_idx);\n\t\tdex_resolve_virtual_method_code(dex, method_id, class_def->superclass_idx);\n\t}\n}\n\nstatic bool dex_create_relocations(RzBinDex *dex) {\n\tvoid **iter_p0;\n\tRzListIter *iter_l;\n\tDexClassDef *class_def;\n\tDexEncodedMethod *encoded_method = NULL;\n\tDexMethodId *method_id = NULL;\n\n\tdex->relocs_size = 0;\n\trz_pvector_foreach (dex->method_ids, iter_p0) {\n\t\tmethod_id = (DexMethodId *)*iter_p0;\n\t\tif (method_id->code_offset) {\n\t\t\tcontinue;\n\t\t}\n\t\t// patch the imported method.\n\t\tmethod_id->code_offset = dex->relocs_offset + dex->relocs_size;\n\t\tmethod_id->code_size = 2;\n\t\tdex->relocs_size += 2;\n\t}\n\n\t// sync classes with method_ids\n\trz_pvector_foreach (dex->class_defs, iter_p0) {\n\t\tclass_def = (DexClassDef *)*iter_p0;\n\t\trz_list_foreach (class_def->direct_methods, iter_l, encoded_method) {\n\t\t\tif (encoded_method->code_offset) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmethod_id = NULL;\n\t\t\tif (encoded_method->method_idx < rz_pvector_len(dex->method_ids)) {\n\t\t\t\tmethod_id = (DexMethodId *)rz_pvector_at(dex->method_ids, encoded_method->method_idx);\n\t\t\t\tif (method_id->code_offset) {\n\t\t\t\t\tencoded_method->code_offset = method_id->code_offset;\n\t\t\t\t\tencoded_method->code_size = method_id->code_size;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// patch the imported method.\n\t\t\tencoded_method->code_offset = dex->relocs_offset + dex->relocs_size;\n\t\t\tencoded_method->code_size = 2;\n\t\t\tdex->relocs_size += 2;\n\t\t\tif (method_id) {\n\t\t\t\tmethod_id->code_offset = encoded_method->code_offset;\n\t\t\t\tmethod_id->code_size = encoded_method->code_size;\n\t\t\t}\n\t\t}\n\n\t\trz_list_foreach (class_def->virtual_methods, iter_l, encoded_method) {\n\t\t\tif (encoded_method->code_offset) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmethod_id = NULL;\n\t\t\tif (encoded_method->method_idx < rz_pvector_len(dex->method_ids)) {\n\t\t\t\tmethod_id = (DexMethodId *)rz_pvector_at(dex->method_ids, encoded_method->method_idx);\n\t\t\t\tif (method_id->code_offset) {\n\t\t\t\t\tencoded_method->code_offset = method_id->code_offset;\n\t\t\t\t\tencoded_method->code_size = method_id->code_size;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// patch the imported method.\n\t\t\tencoded_method->code_offset = dex->relocs_offset + dex->relocs_size;\n\t\t\tencoded_method->code_size = 2;\n\t\t\tdex->relocs_size += 2;\n\t\t\tif (method_id) {\n\t\t\t\tmethod_id->code_offset = encoded_method->code_offset;\n\t\t\t\tmethod_id->code_size = encoded_method->code_size;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dex->relocs_size < 1) {\n\t\treturn true;\n\t}\n\tdex->relocs_code = malloc(dex->relocs_size);\n\tif (!dex->relocs_code) {\n\t\treturn false;\n\t}\n\tfor (ut32 i = 0; i < dex->relocs_size; i += 2) {\n\t\tdex->relocs_code[i] = 0x0e;\n\t\tdex->relocs_code[i + 1] = 0x00;\n\t}\n\tdex->relocs_buffer = rz_buf_new_with_bytes(dex->relocs_code, dex->relocs_size);\n\treturn dex->relocs_buffer;\n}\n\nstatic bool dex_parse(RzBinDex *dex, ut64 base, RzBuffer *buf) {\n\tut64 offset = 0;\n\tst64 read = 0;\n\tst64 buffer_size = rz_buf_size(buf);\n\tif (buffer_size < 116) {\n\t\t// 116 bytes is the smalled dex that can be built.\n\t\tRZ_LOG_ERROR(\"dex bin: invalid buffer size (size < 116)\\n\");\n\t\tgoto dex_parse_bad;\n\t}\n\n\tdex->header_offset = base;\n\tdex->relocs_offset = base + RZ_DEX_RELOC_ADDRESS;\n\trz_buf_read(buf, dex->magic, sizeof(dex->magic));\n\trz_buf_read(buf, dex->version, sizeof(dex->version));\n\tdex->checksum_offset = rz_buf_tell(buf) + base;\n\tread_le32_or_fail(buf, dex->checksum, dex_parse_bad);\n\tdex->signature_offset = rz_buf_tell(buf) + base;\n\trz_buf_read(buf, dex->signature, sizeof(dex->signature));\n\tread_le32_or_fail(buf, dex->file_size, dex_parse_bad);\n\tread_le32_or_fail(buf, dex->header_size, dex_parse_bad);\n\tread_le32_or_fail(buf, dex->endian_tag, dex_parse_bad);\n\n\tread_le32_or_fail(buf, dex->link_size, dex_parse_bad);\n\tread_le32_or_fail(buf, dex->link_offset, dex_parse_bad);\n\n\tread_le32_or_fail(buf, dex->map_offset, dex_parse_bad);\n\n\tread_le32_or_fail(buf, dex->string_ids_size, dex_parse_bad);\n\tread_le32_or_fail(buf, dex->string_ids_offset, dex_parse_bad);\n\t// string_ids points to an array of offsets.\n\tdex_fail_if_bad_ids(dex->string_ids, sizeof(ut32), buffer_size, dex_parse_bad);\n\n\tread_le32_or_fail(buf, dex->type_ids_size, dex_parse_bad);\n\tread_le32_or_fail(buf, dex->type_ids_offset, dex_parse_bad);\n\tdex_fail_if_bad_ids(dex->type_ids, DEX_TYPE_ID_SIZE, buffer_size, dex_parse_bad);\n\n\tread_le32_or_fail(buf, dex->proto_ids_size, dex_parse_bad);\n\tread_le32_or_fail(buf, dex->proto_ids_offset, dex_parse_bad);\n\tdex_fail_if_bad_ids(dex->proto_ids, DEX_PROTO_ID_SIZE, buffer_size, dex_parse_bad);\n\n\tread_le32_or_fail(buf, dex->field_ids_size, dex_parse_bad);\n\tread_le32_or_fail(buf, dex->field_ids_offset, dex_parse_bad);\n\tdex_fail_if_bad_ids(dex->field_ids, DEX_FIELD_ID_SIZE, buffer_size, dex_parse_bad);\n\n\tread_le32_or_fail(buf, dex->method_ids_size, dex_parse_bad);\n\tread_le32_or_fail(buf, dex->method_ids_offset, dex_parse_bad);\n\tdex_fail_if_bad_ids(dex->method_ids, DEX_METHOD_ID_SIZE, buffer_size, dex_parse_bad);\n\n\tread_le32_or_fail(buf, dex->class_defs_size, dex_parse_bad);\n\tread_le32_or_fail(buf, dex->class_defs_offset, dex_parse_bad);\n\n\tread_le32_or_fail(buf, dex->data_size, dex_parse_bad);\n\tread_le32_or_fail(buf, dex->data_offset, dex_parse_bad);\n\n\t/* Strings */\n\toffset = dex->string_ids_offset;\n\tif (!rz_pvector_reserve(dex->strings, dex->string_ids_size)) {\n\t\tgoto dex_parse_bad;\n\t}\n\tfor (ut32 i = 0; i < dex->string_ids_size; ++i, offset += sizeof(ut32)) {\n\t\tut32 string_offset = 0;\n\t\tread_le32_at_or_fail(buf, string_offset, offset, dex_parse_bad);\n\n\t\tif (rz_buf_seek(buf, string_offset, RZ_BUF_SET) < 0) {\n\t\t\tgoto dex_parse_bad;\n\t\t}\n\t\tDexString *string = dex_string_new(buf, base + string_offset, &read);\n\t\tif (!string) {\n\t\t\tgoto dex_parse_bad;\n\t\t}\n\t\trz_pvector_push(dex->strings, string);\n\t}\n\n\t/* Type Ids */\n\tdex->types = RZ_NEWS0(DexTypeId, dex->type_ids_size);\n\tif (!dex->types) {\n\t\tgoto dex_parse_bad;\n\t}\n\tif (rz_buf_seek(buf, dex->type_ids_offset, RZ_BUF_SET) < 0) {\n\t\tgoto dex_parse_bad;\n\t}\n\tfor (ut32 i = 0; i < dex->type_ids_size; ++i) {\n\t\tread_le32_or_fail(buf, dex->types[i], dex_parse_bad);\n\t}\n\n\t/* Proto Ids */\n\toffset = dex->proto_ids_offset;\n\tif (!rz_pvector_reserve(dex->proto_ids, dex->proto_ids_size)) {\n\t\tgoto dex_parse_bad;\n\t}\n\tfor (ut32 i = 0; i < dex->proto_ids_size; ++i, offset += DEX_PROTO_ID_SIZE) {\n\t\tif (rz_buf_seek(buf, offset, RZ_BUF_SET) < 0) {\n\t\t\tgoto dex_parse_bad;\n\t\t}\n\t\tDexProtoId *proto_id = dex_proto_id_new(buf, base + offset);\n\t\tif (!proto_id) {\n\t\t\tgoto dex_parse_bad;\n\t\t}\n\t\trz_pvector_push(dex->proto_ids, proto_id);\n\t}\n\n\t/* Field Ids */\n\toffset = dex->field_ids_offset;\n\tif (!rz_pvector_reserve(dex->field_ids, dex->field_ids_size)) {\n\t\tgoto dex_parse_bad;\n\t}\n\tfor (ut32 i = 0; i < dex->field_ids_size; ++i, offset += DEX_FIELD_ID_SIZE) {\n\t\tif (rz_buf_seek(buf, offset, RZ_BUF_SET) < 0) {\n\t\t\tgoto dex_parse_bad;\n\t\t}\n\t\tDexFieldId *field_id = dex_field_id_new(buf, base + offset);\n\t\tif (!field_id) {\n\t\t\tgoto dex_parse_bad;\n\t\t}\n\t\trz_pvector_push(dex->field_ids, field_id);\n\t}\n\n\t/* Method Ids */\n\toffset = dex->method_ids_offset;\n\tif (!rz_pvector_reserve(dex->method_ids, dex->method_ids_size)) {\n\t\tgoto dex_parse_bad;\n\t}\n\tfor (ut32 i = 0; i < dex->method_ids_size; ++i, offset += DEX_METHOD_ID_SIZE) {\n\t\tif (rz_buf_seek(buf, offset, RZ_BUF_SET) < 0) {\n\t\t\tgoto dex_parse_bad;\n\t\t}\n\t\tDexMethodId *method_id = dex_method_id_new(buf, base + offset);\n\t\tif (!method_id) {\n\t\t\tgoto dex_parse_bad;\n\t\t}\n\t\trz_pvector_push(dex->method_ids, method_id);\n\t}\n\n\t/* Class Defs */\n\toffset = dex->class_defs_offset;\n\tif (!rz_pvector_reserve(dex->class_defs, dex->class_defs_size)) {\n\t\tgoto dex_parse_bad;\n\t}\n\tfor (ut32 i = 0; i < dex->class_defs_size; ++i, offset += DEX_CLASS_DEF_SIZE) {\n\t\tif (rz_buf_seek(buf, offset, RZ_BUF_SET) < 0) {\n\t\t\tgoto dex_parse_bad;\n\t\t}\n\t\tDexClassDef *class_def = dex_class_def_new(buf, base + offset, base, dex->method_ids);\n\t\tif (!class_def) {\n\t\t\tgoto dex_parse_bad;\n\t\t}\n\t\trz_pvector_push(dex->class_defs, class_def);\n\t}\n\n\t/* Resolve all virtual methods */\n\tdex_resolve_all_virtual_methods(dex);\n\n\t/* generate relocation code buffer this buffer will contain a\n\t * sequence of 0e00, i.e 'return-void', which will be used to\n\t * resolve imports for the xrefs.\n\t */\n\tif (!dex_create_relocations(dex)) {\n\t\tgoto dex_parse_bad;\n\t}\n\n\treturn true;\n\ndex_parse_bad:\n\trz_bin_dex_free(dex);\n\treturn false;\n}\n\n/**\n * \\brief Frees a RzBinDex struct\n */\nRZ_API void rz_bin_dex_free(RZ_NULLABLE RzBinDex *dex) {\n\tif (!dex) {\n\t\treturn;\n\t}\n\n\trz_pvector_free(dex->strings);\n\trz_pvector_free(dex->proto_ids);\n\trz_pvector_free(dex->field_ids);\n\trz_pvector_free(dex->method_ids);\n\trz_pvector_free(dex->class_defs);\n\trz_buf_free(dex->relocs_buffer);\n\n\tfree(dex->types);\n\tfree(dex->relocs_code);\n\tfree(dex);\n}\n\n/**\n * \\brief Parses the dex file and returns a RzBinDex struct\n */\nRZ_API RZ_OWN RzBinDex *rz_bin_dex_new(RZ_NONNULL RzBuffer *buf, ut64 base, RZ_NONNULL Sdb *kv) {\n\trz_return_val_if_fail(buf, NULL);\n\n\tRzBinDex *dex = (RzBinDex *)RZ_NEW0(RzBinDex);\n\tif (!dex) {\n\t\treturn NULL;\n\t}\n\n\tdex->strings = rz_pvector_new((RzPVectorFree)dex_string_free);\n\tif (!dex->strings) {\n\t\trz_bin_dex_free(dex);\n\t\treturn NULL;\n\t}\n\tdex->proto_ids = rz_pvector_new((RzPVectorFree)dex_proto_id_free);\n\tif (!dex->proto_ids) {\n\t\trz_bin_dex_free(dex);\n\t\treturn NULL;\n\t}\n\tdex->field_ids = rz_pvector_new((RzPVectorFree)dex_field_id_free);\n\tif (!dex->field_ids) {\n\t\trz_bin_dex_free(dex);\n\t\treturn NULL;\n\t}\n\tdex->method_ids = rz_pvector_new((RzPVectorFree)dex_method_id_free);\n\tif (!dex->method_ids) {\n\t\trz_bin_dex_free(dex);\n\t\treturn NULL;\n\t}\n\tdex->class_defs = rz_pvector_new((RzPVectorFree)dex_class_def_free);\n\tif (!dex->class_defs) {\n\t\trz_bin_dex_free(dex);\n\t\treturn NULL;\n\t}\n\n\tif (!dex_parse(dex, base, buf)) {\n\t\treturn NULL;\n\t}\n\n\treturn dex;\n}\n\nRZ_API RZ_OWN char *rz_bin_dex_access_flags_readable(ut32 access_flags) {\n\tRzStrBuf *sb = NULL;\n\tfor (ut32 i = 0; i < CLASS_ACCESS_FLAGS_SIZE; ++i) {\n\t\tconst DexAccessFlagsReadable *afr = &access_flags_list[i];\n\t\tif (afr->flag == ACCESS_FLAG_VARARGS) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (access_flags & afr->flag) {\n\t\t\tif (!sb) {\n\t\t\t\tsb = rz_strbuf_new(afr->readable);\n\t\t\t\tif (!sb) {\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trz_strbuf_appendf(sb, \" %s\", afr->readable);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sb ? rz_strbuf_drain(sb) : NULL;\n}\n\n/**\n * \\brief Returns a RzList<RzBinString*> containing the dex strings\n */\nRZ_API RZ_OWN RzList /*<RzBinString *>*/ *rz_bin_dex_strings(RZ_NONNULL RzBinDex *dex) {\n\trz_return_val_if_fail(dex, NULL);\n\n\tDexString *string;\n\tvoid **it;\n\tRzList *strings = rz_list_newf(rz_bin_string_free);\n\tif (!strings) {\n\t\treturn NULL;\n\t}\n\n\tut32 ordinal = 0;\n\trz_pvector_foreach (dex->strings, it) {\n\t\tstring = (DexString *)*it;\n\t\tRzBinString *bstr = RZ_NEW0(RzBinString);\n\t\tif (!bstr) {\n\t\t\tcontinue;\n\t\t}\n\t\tbstr->paddr = string->offset;\n\t\tbstr->vaddr = RZ_DEX_VIRT_ADDRESS + string->offset;\n\t\tbstr->ordinal = ordinal;\n\t\tbstr->length = string->size;\n\t\tbstr->size = string->size;\n\t\tbstr->string = rz_str_ndup(string->data, string->size);\n\t\tbstr->type = RZ_STRING_ENC_UTF8;\n\t\tif (!rz_list_append(strings, bstr)) {\n\t\t\tfree(bstr);\n\t\t}\n\t\tordinal++;\n\t}\n\treturn strings;\n}\n\nstatic inline DexString *dex_resolve_string_id_native(RzBinDex *dex, ut32 string_idx) {\n\tif (string_idx >= rz_pvector_len(dex->strings)) {\n\t\treturn NULL;\n\t}\n\treturn (DexString *)rz_pvector_at(dex->strings, string_idx);\n}\n\nstatic char *dex_resolve_string_id(RzBinDex *dex, ut32 string_idx) {\n\tDexString *string = dex_resolve_string_id_native(dex, string_idx);\n\tif (!string) {\n\t\tRZ_LOG_INFO(\"cannot find string with index %u\\n\", string_idx);\n\t\treturn NULL;\n\t}\n\treturn rz_str_ndup(string->data, string->size);\n}\n\nstatic char *dex_resolve_type_id(RzBinDex *dex, ut32 type_idx) {\n\tif (type_idx >= dex->type_ids_size) {\n\t\tRZ_LOG_INFO(\"cannot find type_id with index %u\\n\", type_idx);\n\t\treturn NULL;\n\t}\n\tDexTypeId type_id = dex->types[type_idx];\n\treturn dex_resolve_string_id(dex, type_id);\n}\n\nstatic char *dex_resolve_proto_id(RzBinDex *dex, const char *name, ut32 proto_idx, bool varargs) {\n\tif (proto_idx >= rz_pvector_len(dex->proto_ids)) {\n\t\tRZ_LOG_INFO(\"cannot find proto_id with index %u\\n\", proto_idx);\n\t\treturn NULL;\n\t}\n\n\tDexProtoId *proto_id = (DexProtoId *)rz_pvector_at(dex->proto_ids, proto_idx);\n\tif (proto_id->return_type_idx >= dex->type_ids_size) {\n\t\tRZ_LOG_INFO(\"cannot find return type id with index %u\\n\", proto_id->return_type_idx);\n\t\treturn NULL;\n\t}\n\n\tRzStrBuf *sb = rz_strbuf_new(name);\n\tif (!sb) {\n\t\treturn NULL;\n\t}\n\n\tconst DexString *return_type = dex_resolve_string_id_native(dex, dex->types[proto_id->return_type_idx]);\n\tif (!return_type) {\n\t\tRZ_LOG_INFO(\"cannot find return type string with index %u\\n\", proto_id->return_type_idx);\n\t\trz_strbuf_free(sb);\n\t\treturn NULL;\n\t}\n\n\trz_strbuf_append(sb, \"(\");\n\tfor (ut32 i = 0; i < proto_id->type_list_size; ++i) {\n\t\tut32 type_idx = proto_id->type_list[i];\n\t\tif (type_idx >= dex->type_ids_size) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst DexString *param = dex_resolve_string_id_native(dex, dex->types[type_idx]);\n\t\tif (!param) {\n\t\t\tRZ_LOG_INFO(\"cannot find param string with index %d\\n\", dex->types[type_idx]);\n\t\t\trz_strbuf_free(sb);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (varargs && (i + 1) >= proto_id->type_list_size) {\n\t\t\trz_strbuf_append(sb, \"...\");\n\t\t}\n\t\trz_strbuf_append_n(sb, param->data, param->size);\n\t}\n\trz_strbuf_append(sb, \")\");\n\trz_strbuf_append_n(sb, return_type->data, return_type->size);\n\treturn rz_strbuf_drain(sb);\n}\n\nstatic ut64 dex_access_flags_to_bin_flags(ut64 access_flags) {\n\tut64 flags = 0;\n\tif (access_flags & ACCESS_FLAG_PUBLIC) {\n\t\tflags |= RZ_BIN_METH_PUBLIC;\n\t}\n\tif (access_flags & ACCESS_FLAG_PRIVATE) {\n\t\tflags |= RZ_BIN_METH_PRIVATE;\n\t}\n\tif (access_flags & ACCESS_FLAG_PROTECTED) {\n\t\tflags |= RZ_BIN_METH_PROTECTED;\n\t}\n\tif (access_flags & ACCESS_FLAG_STATIC) {\n\t\tflags |= RZ_BIN_METH_STATIC;\n\t}\n\tif (access_flags & ACCESS_FLAG_FINAL) {\n\t\tflags |= RZ_BIN_METH_FINAL;\n\t}\n\tif (access_flags & ACCESS_FLAG_SYNCHRONIZED) {\n\t\tflags |= RZ_BIN_METH_SYNCHRONIZED;\n\t}\n\tif (access_flags & ACCESS_FLAG_BRIDGE) {\n\t\tflags |= RZ_BIN_METH_BRIDGE;\n\t}\n\tif (access_flags & ACCESS_FLAG_VARARGS) {\n\t\tflags |= RZ_BIN_METH_VARARGS;\n\t}\n\tif (access_flags & ACCESS_FLAG_NATIVE) {\n\t\tflags |= RZ_BIN_METH_NATIVE;\n\t}\n\t// RZ_BIN_METH_INTERFACE does not exists\n\t// if (access_flags & ACCESS_FLAG_INTERFACE) {\n\t//\tflags |= RZ_BIN_METH_INTERFACE;\n\t//}\n\tif (access_flags & ACCESS_FLAG_ABSTRACT) {\n\t\tflags |= RZ_BIN_METH_ABSTRACT;\n\t}\n\tif (access_flags & ACCESS_FLAG_STRICT) {\n\t\tflags |= RZ_BIN_METH_STRICT;\n\t}\n\tif (access_flags & ACCESS_FLAG_SYNTHETIC) {\n\t\tflags |= RZ_BIN_METH_SYNTHETIC;\n\t}\n\t// RZ_BIN_METH_ANNOTATION does not exists\n\t// if (access_flags & ACCESS_FLAG_ANNOTATION) {\n\t//\tflags |= RZ_BIN_METH_ANNOTATION;\n\t//}\n\t// RZ_BIN_METH_ENUM does not exists\n\t// if (access_flags & ACCESS_FLAG_ENUM) {\n\t//\tflags |= RZ_BIN_METH_ENUM;\n\t//}\n\t// RZ_BIN_METH_MODULE does not exists\n\t// if (access_flags & ACCESS_FLAG_MODULE) {\n\t//\tflags |= RZ_BIN_METH_MODULE;\n\t//}\n\tif (access_flags & ACCESS_FLAG_CONSTRUCTOR) {\n\t\tflags |= RZ_BIN_METH_CONSTRUCTOR;\n\t}\n\tif (access_flags & ACCESS_FLAG_DECLARED_SYNCHRONIZED) {\n\t\tflags |= RZ_BIN_METH_DECLARED_SYNCHRONIZED;\n\t}\n\treturn flags;\n}\n\nstatic char *dex_resolve_library(const char *library) {\n\tif (!library || library[0] != 'L') {\n\t\treturn NULL;\n\t}\n\tchar *demangled = strdup(library + 1);\n\trz_str_replace_ch(demangled, '/', '.', 1);\n\tdemangled[strlen(demangled) - 1] = 0;\n\treturn demangled;\n}\n\nstatic RzBinSymbol *dex_method_to_symbol(RzBinDex *dex, DexEncodedMethod *encoded_method, DexMethodId *method_id, bool is_imported) {\n\tRzBinSymbol *symbol = RZ_NEW0(RzBinSymbol);\n\tif (!symbol) {\n\t\treturn NULL;\n\t}\n\n\tbool varargs = dex_is_varargs(encoded_method->access_flags);\n\tsymbol->name = dex_resolve_string_id(dex, method_id->name_idx);\n\tsymbol->classname = dex_resolve_type_id(dex, method_id->class_idx);\n\tsymbol->libname = dex_resolve_library(symbol->classname);\n\tsymbol->dname = dex_resolve_proto_id(dex, symbol->name, method_id->proto_idx, varargs);\n\tsymbol->bind = dex_is_static(encoded_method->access_flags) ? RZ_BIN_BIND_GLOBAL_STR : RZ_BIN_BIND_LOCAL_STR;\n\tsymbol->is_imported = is_imported;\n\tsymbol->visibility = encoded_method->access_flags & UT32_MAX;\n\tsymbol->visibility_str = rz_bin_dex_access_flags_readable(symbol->visibility);\n\tsymbol->size = encoded_method->code_size;\n\tif (encoded_method->code_offset < RZ_DEX_RELOC_ADDRESS) {\n\t\tsymbol->vaddr = RZ_DEX_VIRT_ADDRESS + encoded_method->code_offset;\n\t\tsymbol->paddr = encoded_method->code_offset;\n\t} else {\n\t\tsymbol->vaddr = encoded_method->code_offset;\n\t\tsymbol->paddr = 0;\n\t}\n\tsymbol->ordinal = encoded_method->method_idx;\n\tsymbol->method_flags = dex_access_flags_to_bin_flags(encoded_method->access_flags);\n\tsymbol->type = RZ_BIN_TYPE_METH_STR;\n\n\treturn symbol;\n}\n\nstatic RzList /*<RzBinSymbol *>*/ *dex_resolve_methods_in_class(RzBinDex *dex, DexClassDef *class_def, ut8 *inserted) {\n\tRzList *methods = rz_list_newf((RzListFree)rz_bin_symbol_free);\n\tif (!methods) {\n\t\treturn NULL;\n\t}\n\n\tDexMethodId *method_id = NULL;\n\tDexEncodedMethod *encoded_method = NULL;\n\tRzListIter *it = NULL;\n\n\trz_list_foreach (class_def->direct_methods, it, encoded_method) {\n\t\tif (encoded_method->method_idx >= rz_pvector_len(dex->method_ids)) {\n\t\t\tRZ_LOG_INFO(\"cannot find direct method with index %\" PFMT64u \"\\n\", encoded_method->method_idx);\n\t\t\tcontinue;\n\t\t} else if (inserted[encoded_method->method_idx]) {\n\t\t\tcontinue;\n\t\t}\n\t\tmethod_id = (DexMethodId *)rz_pvector_at(dex->method_ids, encoded_method->method_idx);\n\t\tinserted[encoded_method->method_idx] = true;\n\n\t\tRzBinSymbol *symbol = dex_method_to_symbol(dex, encoded_method, method_id, false);\n\t\tif (!symbol || !rz_list_append(methods, symbol)) {\n\t\t\trz_bin_symbol_free(symbol);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trz_list_foreach (class_def->virtual_methods, it, encoded_method) {\n\t\tif (encoded_method->method_idx >= rz_pvector_len(dex->method_ids)) {\n\t\t\tRZ_LOG_INFO(\"cannot find virtual method with index %\" PFMT64u \"\\n\", encoded_method->method_idx);\n\t\t\tcontinue;\n\t\t} else if (inserted[encoded_method->method_idx]) {\n\t\t\tcontinue;\n\t\t}\n\t\tmethod_id = (DexMethodId *)rz_pvector_at(dex->method_ids, encoded_method->method_idx);\n\t\tinserted[encoded_method->method_idx] = true;\n\n\t\tRzBinSymbol *symbol = dex_method_to_symbol(dex, encoded_method, method_id, false);\n\t\tif (!symbol || !rz_list_append(methods, symbol)) {\n\t\t\trz_bin_symbol_free(symbol);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn methods;\n}\n\nstatic RzBinField *dex_field_to_bin_field(RzBinDex *dex, DexEncodedField *encoded_field, DexFieldId *field_id, bool is_static) {\n\tRzBinField *field = RZ_NEW0(RzBinField);\n\tif (!field) {\n\t\treturn NULL;\n\t}\n\n\tut64 access_flags = encoded_field->access_flags;\n\tif (is_static) {\n\t\taccess_flags |= ACCESS_FLAG_STATIC;\n\t}\n\n\tfield->vaddr = RZ_DEX_VIRT_ADDRESS + encoded_field->offset;\n\tfield->paddr = encoded_field->offset;\n\tfield->visibility = encoded_field->access_flags & UT32_MAX;\n\tfield->visibility_str = rz_bin_dex_access_flags_readable(access_flags);\n\tfield->name = dex_resolve_string_id(dex, field_id->name_idx);\n\tfield->type = dex_resolve_type_id(dex, field_id->type_idx);\n\tfield->flags = dex_access_flags_to_bin_flags(access_flags);\n\n\treturn field;\n}\n\nstatic RzList /*<RzBinField *>*/ *dex_resolve_fields_in_class(RzBinDex *dex, DexClassDef *class_def, ut8 *inserted) {\n\tRzList *fields = rz_list_newf((RzListFree)rz_bin_field_free);\n\tif (!fields) {\n\t\treturn NULL;\n\t}\n\tDexFieldId *field_id = NULL;\n\tDexEncodedField *encoded_field = NULL;\n\tRzListIter *it = NULL;\n\n\trz_list_foreach (class_def->static_fields, it, encoded_field) {\n\t\tif (encoded_field->field_idx >= rz_pvector_len(dex->field_ids)) {\n\t\t\tRZ_LOG_INFO(\"cannot find static field with index %\" PFMT64u \"\\n\", encoded_field->field_idx);\n\t\t\tcontinue;\n\t\t} else if (inserted[encoded_field->field_idx]) {\n\t\t\tcontinue;\n\t\t}\n\t\tinserted[encoded_field->field_idx] = true;\n\t\tfield_id = (DexFieldId *)rz_pvector_at(dex->field_ids, encoded_field->field_idx);\n\n\t\tRzBinField *field = dex_field_to_bin_field(dex, encoded_field, field_id, true);\n\t\tif (!field || !rz_list_append(fields, field)) {\n\t\t\trz_bin_field_free(field);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trz_list_foreach (class_def->instance_fields, it, encoded_field) {\n\t\tif (encoded_field->field_idx >= rz_pvector_len(dex->field_ids)) {\n\t\t\tRZ_LOG_INFO(\"cannot find instance field with index %\" PFMT64u \"\\n\", encoded_field->field_idx);\n\t\t\tcontinue;\n\t\t} else if (inserted[encoded_field->field_idx]) {\n\t\t\tcontinue;\n\t\t}\n\t\tinserted[encoded_field->field_idx] = true;\n\t\tfield_id = (DexFieldId *)rz_pvector_at(dex->field_ids, encoded_field->field_idx);\n\n\t\tRzBinField *field = dex_field_to_bin_field(dex, encoded_field, field_id, false);\n\t\tif (!field || !rz_list_append(fields, field)) {\n\t\t\trz_bin_field_free(field);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn fields;\n}\n\nstatic RzBinSymbol *dex_field_to_symbol(RzBinDex *dex, DexEncodedField *encoded_field, DexFieldId *field_id, bool is_imported) {\n\tRzBinSymbol *field = RZ_NEW0(RzBinSymbol);\n\tif (!field) {\n\t\treturn NULL;\n\t}\n\n\tfield->name = dex_resolve_string_id(dex, field_id->name_idx);\n\tfield->classname = dex_resolve_type_id(dex, field_id->class_idx);\n\tfield->libname = dex_resolve_library(field->classname);\n\tfield->bind = dex_is_static(encoded_field->access_flags) ? RZ_BIN_BIND_GLOBAL_STR : RZ_BIN_BIND_LOCAL_STR;\n\tfield->is_imported = false;\n\tfield->visibility = encoded_field->access_flags & UT32_MAX;\n\tfield->visibility_str = rz_bin_dex_access_flags_readable(encoded_field->access_flags);\n\tfield->vaddr = RZ_DEX_VIRT_ADDRESS + encoded_field->offset;\n\tfield->paddr = encoded_field->offset;\n\tfield->ordinal = encoded_field->field_idx;\n\tfield->method_flags = dex_access_flags_to_bin_flags(encoded_field->access_flags);\n\tfield->type = RZ_BIN_TYPE_FIELD_STR;\n\n\treturn field;\n}\n\nstatic RzList /*<RzBinSymbol *>*/ *dex_resolve_fields_in_class_as_symbols(RzBinDex *dex, DexClassDef *class_def, ut8 *inserted) {\n\tRzList *fields = rz_list_newf((RzListFree)rz_bin_symbol_free);\n\tif (!fields) {\n\t\treturn NULL;\n\t}\n\tDexFieldId *field_id = NULL;\n\tDexEncodedField *encoded_field = NULL;\n\tRzListIter *it = NULL;\n\n\trz_list_foreach (class_def->static_fields, it, encoded_field) {\n\t\tif (encoded_field->field_idx >= rz_pvector_len(dex->field_ids)) {\n\t\t\tRZ_LOG_INFO(\"cannot find static field with index %\" PFMT64u \"\\n\", encoded_field->field_idx);\n\t\t\tcontinue;\n\t\t}\n\t\tfield_id = (DexFieldId *)rz_pvector_at(dex->field_ids, encoded_field->field_idx);\n\t\tinserted[encoded_field->field_idx] = true;\n\n\t\tRzBinSymbol *field = dex_field_to_symbol(dex, encoded_field, field_id, false);\n\t\tif (!field || !rz_list_append(fields, field)) {\n\t\t\trz_bin_symbol_free(field);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trz_list_foreach (class_def->instance_fields, it, encoded_field) {\n\t\tif (encoded_field->field_idx >= rz_pvector_len(dex->field_ids)) {\n\t\t\tRZ_LOG_INFO(\"cannot find instance field with index %\" PFMT64u \"\\n\", encoded_field->field_idx);\n\t\t\tcontinue;\n\t\t}\n\t\tfield_id = (DexFieldId *)rz_pvector_at(dex->field_ids, encoded_field->field_idx);\n\t\tinserted[encoded_field->field_idx] = true;\n\n\t\tRzBinSymbol *field = dex_field_to_symbol(dex, encoded_field, field_id, false);\n\t\tif (!field || !rz_list_append(fields, field)) {\n\t\t\trz_bin_symbol_free(field);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn fields;\n}\n\nstatic void free_rz_bin_class(RzBinClass *bclass) {\n\tif (!bclass) {\n\t\treturn;\n\t}\n\trz_list_free(bclass->methods);\n\trz_list_free(bclass->fields);\n\tfree(bclass->name);\n\tfree(bclass->super);\n\tfree(bclass->visibility_str);\n\tfree(bclass);\n}\n\n/**\n * \\brief Returns a RzList<RzBinClass*> containing the dex classes\n */\nRZ_API RZ_OWN RzList /*<RzBinClass *>*/ *rz_bin_dex_classes(RZ_NONNULL RzBinDex *dex) {\n\trz_return_val_if_fail(dex, NULL);\n\n\tDexClassDef *class_def;\n\tRzBinClass *bclass = NULL;\n\tRzList *classes = NULL;\n\tvoid **it;\n\n\tut32 n_methods = rz_pvector_len(dex->method_ids);\n\tut32 n_fields = rz_pvector_len(dex->field_ids);\n\n\tut8 *inserted_methods = RZ_NEWS0(ut8, n_methods);\n\tut8 *inserted_fields = RZ_NEWS0(ut8, n_fields);\n\tif ((n_methods > 0 && !inserted_methods) || (n_fields > 0 && !inserted_fields)) {\n\t\tfree(inserted_fields);\n\t\tfree(inserted_methods);\n\t\treturn NULL;\n\t}\n\n\tclasses = rz_list_newf((RzListFree)free_rz_bin_class);\n\tif (!classes) {\n\t\tfree(inserted_fields);\n\t\tfree(inserted_methods);\n\t\treturn NULL;\n\t}\n\n\trz_pvector_foreach (dex->class_defs, it) {\n\t\tclass_def = (DexClassDef *)*it;\n\t\tbclass = RZ_NEW0(RzBinClass);\n\t\tif (!bclass) {\n\t\t\tbreak;\n\t\t}\n\n\t\tbclass->name = dex_resolve_type_id(dex, class_def->class_idx);\n\t\tbclass->super = dex_resolve_type_id(dex, class_def->superclass_idx);\n\t\tbclass->visibility = class_def->access_flags;\n\t\tbclass->visibility_str = rz_bin_dex_access_flags_readable(class_def->access_flags);\n\t\tbclass->index = class_def->class_idx;\n\t\tbclass->addr = class_def->offset;\n\t\tbclass->methods = dex_resolve_methods_in_class(dex, class_def, inserted_methods);\n\t\tbclass->fields = dex_resolve_fields_in_class(dex, class_def, inserted_fields);\n\n\t\tif (!rz_list_append(classes, bclass)) {\n\t\t\tfree_rz_bin_class(bclass);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(inserted_fields);\n\tfree(inserted_methods);\n\n\treturn classes;\n}\n\nstatic RzBinSection *section_new(const char *name, ut32 perm, ut32 size, ut64 paddr, ut64 vaddr) {\n\tRzBinSection *section = RZ_NEW0(RzBinSection);\n\tif (!section) {\n\t\treturn NULL;\n\t}\n\tsection->name = strdup(name);\n\tsection->paddr = paddr;\n\tsection->vaddr = vaddr;\n\tsection->size = section->vsize = size;\n\tsection->perm = perm;\n\treturn section;\n}\n\n/**\n * \\brief Returns a RzList<RzBinSection*> containing the dex sections\n */\nRZ_API RZ_OWN RzList /*<RzBinSection *>*/ *rz_bin_dex_sections(RZ_NONNULL RzBinDex *dex) {\n\trz_return_val_if_fail(dex, NULL);\n\n\tRzBinSection *section;\n\tRzList *sections = NULL;\n\n\tsections = rz_list_newf((RzListFree)rz_bin_section_free);\n\tif (!sections) {\n\t\treturn NULL;\n\t}\n\tsection = section_new(\"data\", RZ_PERM_RWX, dex->data_size, dex->data_offset, RZ_DEX_VIRT_ADDRESS + dex->data_offset);\n\tif (section && !rz_list_append(sections, section)) {\n\t\trz_bin_section_free(section);\n\t}\n\tsection = section_new(\"file\", RZ_PERM_R, dex->file_size, dex->header_offset, 0);\n\tif (section && !rz_list_append(sections, section)) {\n\t\trz_bin_section_free(section);\n\t}\n\n\tif (dex->relocs_code) {\n\t\tsection = section_new(RZ_DEX_RELOC_TARGETS, RZ_PERM_RWX, dex->relocs_size, 0, dex->relocs_offset);\n\t\tif (section && !rz_list_append(sections, section)) {\n\t\t\trz_bin_section_free(section);\n\t\t}\n\t}\n\n\treturn sections;\n}\n\n/**\n * \\brief Returns a RzList<RzBinField*> containing the dex fields\n */\nRZ_API RZ_OWN RzList /*<RzBinField *>*/ *rz_bin_dex_fields(RZ_NONNULL RzBinDex *dex) {\n\trz_return_val_if_fail(dex, NULL);\n\n\tDexClassDef *class_def;\n\tRzList *fields = NULL;\n\tvoid **it;\n\tut32 n_fields = rz_pvector_len(dex->field_ids);\n\tut8 *inserted = RZ_NEWS0(ut8, n_fields);\n\tif (n_fields > 0 && !inserted) {\n\t\tfree(inserted);\n\t\treturn NULL;\n\t}\n\n\tfields = rz_list_newf((RzListFree)rz_bin_field_free);\n\tif (!fields) {\n\t\tfree(inserted);\n\t\treturn NULL;\n\t}\n\n\trz_pvector_foreach (dex->class_defs, it) {\n\t\tclass_def = (DexClassDef *)*it;\n\t\tRzList *class_fields = dex_resolve_fields_in_class(dex, class_def, inserted);\n\t\tif (class_fields) {\n\t\t\trz_list_join(fields, class_fields);\n\t\t\trz_list_free(class_fields);\n\t\t}\n\t}\n\tfree(inserted);\n\n\treturn fields;\n}\n\n/**\n * \\brief Returns a RzList<RzBinSymbol*> containing the dex symbols\n */\nRZ_API RZ_OWN RzList /*<RzBinSymbol *>*/ *rz_bin_dex_symbols(RZ_NONNULL RzBinDex *dex) {\n\trz_return_val_if_fail(dex, NULL);\n\n\tDexClassDef *class_def;\n\tDexFieldId *field_id;\n\tDexMethodId *method_id;\n\tRzList *class_symbols = NULL;\n\tRzList *symbols = NULL;\n\tvoid **vit;\n\tut8 *inserted_methods = NULL;\n\tut8 *inserted_fields = NULL;\n\tut32 n_methods = rz_pvector_len(dex->method_ids);\n\tut32 n_fields = rz_pvector_len(dex->field_ids);\n\n\tinserted_methods = RZ_NEWS0(ut8, n_methods);\n\tinserted_fields = RZ_NEWS0(ut8, n_fields);\n\tif ((n_methods > 0 && !inserted_methods) || (n_fields > 0 && !inserted_fields)) {\n\t\tfree(inserted_fields);\n\t\tfree(inserted_methods);\n\t\treturn NULL;\n\t}\n\n\tsymbols = rz_list_newf((RzListFree)rz_bin_symbol_free);\n\tif (!symbols) {\n\t\tfree(inserted_fields);\n\t\tfree(inserted_methods);\n\t\treturn NULL;\n\t}\n\n\trz_pvector_foreach (dex->class_defs, vit) {\n\t\tclass_def = (DexClassDef *)*vit;\n\n\t\tclass_symbols = dex_resolve_fields_in_class_as_symbols(dex, class_def, inserted_fields);\n\t\tif (class_symbols) {\n\t\t\trz_list_join(symbols, class_symbols);\n\t\t\trz_list_free(class_symbols);\n\t\t}\n\n\t\tclass_symbols = dex_resolve_methods_in_class(dex, class_def, inserted_methods);\n\t\tif (class_symbols) {\n\t\t\trz_list_join(symbols, class_symbols);\n\t\t\trz_list_free(class_symbols);\n\t\t}\n\t}\n\n\tut32 j = 0;\n\trz_pvector_foreach (dex->field_ids, vit) {\n\t\tfield_id = (DexFieldId *)*vit;\n\t\tif (inserted_fields[j++]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tRzBinSymbol *field = RZ_NEW0(RzBinSymbol);\n\t\tif (!field) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfield->name = dex_resolve_string_id(dex, field_id->name_idx);\n\t\tfield->classname = dex_resolve_type_id(dex, field_id->class_idx);\n\t\tfield->libname = dex_resolve_library(field->classname);\n\t\tfield->bind = RZ_BIN_BIND_WEAK_STR;\n\t\tfield->type = RZ_BIN_TYPE_FIELD_STR;\n\t\tfield->is_imported = true;\n\n\t\tif (!rz_list_append(symbols, field)) {\n\t\t\trz_bin_symbol_free(field);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tj = 0;\n\trz_pvector_foreach (dex->method_ids, vit) {\n\t\tmethod_id = (DexMethodId *)*vit;\n\t\tif (inserted_methods[j++]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tRzBinSymbol *method = RZ_NEW0(RzBinSymbol);\n\t\tif (!method) {\n\t\t\tbreak;\n\t\t}\n\n\t\tmethod->name = dex_resolve_string_id(dex, method_id->name_idx);\n\t\tmethod->classname = dex_resolve_type_id(dex, method_id->class_idx);\n\t\tmethod->libname = dex_resolve_library(method->classname);\n\t\tmethod->dname = dex_resolve_proto_id(dex, method->name, method_id->proto_idx, false);\n\t\tmethod->bind = RZ_BIN_BIND_WEAK_STR;\n\t\tmethod->is_imported = true;\n\t\tmethod->type = RZ_BIN_TYPE_METH_STR;\n\t\tif (method_id->code_offset < RZ_DEX_RELOC_ADDRESS) {\n\t\t\tmethod->vaddr = RZ_DEX_VIRT_ADDRESS + method_id->code_offset;\n\t\t\tmethod->paddr = method_id->code_offset;\n\t\t} else {\n\t\t\tmethod->vaddr = method_id->code_offset;\n\t\t\tmethod->paddr = 0;\n\t\t}\n\t\tmethod->size = method_id->code_size;\n\n\t\tif (!rz_list_append(symbols, method)) {\n\t\t\trz_bin_symbol_free(method);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree(inserted_fields);\n\tfree(inserted_methods);\n\treturn symbols;\n}\n\n/**\n * \\brief Returns a RzList<RzBinImport*> containing the dex imports\n */\nRZ_API RZ_OWN RzList /*<RzBinImport *>*/ *rz_bin_dex_imports(RZ_NONNULL RzBinDex *dex) {\n\trz_return_val_if_fail(dex, NULL);\n\n\tDexFieldId *field_id;\n\tDexMethodId *method_id;\n\tDexClassDef *class_def;\n\tRzList *imports = NULL;\n\tut32 *class_ids = NULL;\n\tvoid **vit;\n\n\tut32 n_classes = rz_pvector_len(dex->class_defs);\n\tif (n_classes < 1) {\n\t\treturn rz_list_newf((RzListFree)rz_bin_import_free);\n\t}\n\n\tclass_ids = RZ_NEWS0(ut32, n_classes);\n\tif (!class_ids) {\n\t\treturn NULL;\n\t}\n\n\tut32 j = 0;\n\trz_pvector_foreach (dex->class_defs, vit) {\n\t\tclass_def = (DexClassDef *)*vit;\n\t\tclass_ids[j] = class_def->class_idx;\n\t\tj++;\n\t}\n\n\timports = rz_list_newf((RzListFree)rz_bin_import_free);\n\tif (!imports) {\n\t\tfree(class_ids);\n\t\treturn NULL;\n\t}\n\n\tut32 ordinal = 0;\n\trz_pvector_foreach (dex->field_ids, vit) {\n\t\tfield_id = (DexFieldId *)*vit;\n\t\tbool class_found = false;\n\t\tfor (ut32 i = 0; i < n_classes; ++i) {\n\t\t\tif (field_id->class_idx == class_ids[i]) {\n\t\t\t\tclass_found = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (class_found) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tRzBinImport *import = RZ_NEW0(RzBinImport);\n\t\tif (!import) {\n\t\t\tbreak;\n\t\t}\n\n\t\tchar *object = dex_resolve_type_id(dex, field_id->class_idx);\n\t\tif (RZ_STR_ISEMPTY(object)) {\n\t\t\tfree(object);\n\t\t\tfree(import);\n\t\t\tbreak;\n\t\t}\n\t\trz_str_replace_char(object, ';', 0);\n\n\t\tchar *class_name = (char *)rz_str_rchr(object, NULL, '/');\n\t\tif (class_name) {\n\t\t\tclass_name[0] = 0;\n\t\t\tclass_name++;\n\t\t}\n\t\trz_str_replace_ch(object, '/', '.', 1);\n\n\t\timport->name = dex_resolve_string_id(dex, field_id->name_idx);\n\t\timport->libname = class_name ? strdup(object + 1) : NULL;\n\t\timport->classname = strdup(class_name ? class_name : object + 1);\n\t\timport->bind = RZ_BIN_BIND_WEAK_STR;\n\t\timport->type = RZ_BIN_TYPE_FIELD_STR;\n\t\timport->ordinal = ordinal;\n\t\tfree(object);\n\n\t\tif (!rz_list_append(imports, import)) {\n\t\t\trz_bin_import_free(import);\n\t\t\tbreak;\n\t\t}\n\t\tordinal++;\n\t}\n\n\trz_pvector_foreach (dex->method_ids, vit) {\n\t\tmethod_id = (DexMethodId *)*vit;\n\t\tbool class_found = false;\n\t\tfor (ut32 i = 0; i < n_classes; ++i) {\n\t\t\tif (method_id->class_idx == class_ids[i]) {\n\t\t\t\tclass_found = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (class_found) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tRzBinImport *import = RZ_NEW0(RzBinImport);\n\t\tif (!import) {\n\t\t\tbreak;\n\t\t}\n\n\t\tchar *object = dex_resolve_type_id(dex, method_id->class_idx);\n\t\tif (RZ_STR_ISEMPTY(object)) {\n\t\t\tfree(object);\n\t\t\trz_bin_import_free(import);\n\t\t\tbreak;\n\t\t}\n\t\trz_str_replace_char(object, ';', 0);\n\n\t\tchar *class_name = (char *)rz_str_rchr(object, NULL, '/');\n\t\tif (class_name) {\n\t\t\tclass_name[0] = 0;\n\t\t\tclass_name++;\n\t\t}\n\t\trz_str_replace_ch(object, '/', '.', 1);\n\n\t\tchar *name = dex_resolve_string_id(dex, method_id->name_idx);\n\t\timport->name = dex_resolve_proto_id(dex, name, method_id->proto_idx, false);\n\t\timport->libname = class_name ? strdup(object + 1) : NULL;\n\t\timport->classname = strdup(class_name ? class_name : object + 1);\n\t\timport->bind = RZ_BIN_BIND_WEAK_STR;\n\t\timport->type = RZ_BIN_TYPE_FUNC_STR;\n\t\timport->ordinal = ordinal;\n\t\tfree(name);\n\t\tfree(object);\n\n\t\tif (!rz_list_append(imports, import)) {\n\t\t\trz_bin_import_free(import);\n\t\t\tbreak;\n\t\t}\n\t\tordinal++;\n\t}\n\n\tfree(class_ids);\n\treturn imports;\n}\n\nstatic int compare_strings(const void *a, const void *b) {\n\treturn strcmp((const char *)a, (const char *)b);\n}\n\n/**\n * \\brief Returns a RzList<char*> containing the dex libraries\n */\nRZ_API RZ_OWN RzList /*<char *>*/ *rz_bin_dex_libraries(RZ_NONNULL RzBinDex *dex) {\n\trz_return_val_if_fail(dex, NULL);\n\n\tDexMethodId *method_id;\n\tDexClassDef *class_def;\n\tRzList *libraries = NULL;\n\tut32 *class_ids = NULL;\n\tvoid **vit;\n\n\tut32 n_classes = rz_pvector_len(dex->class_defs);\n\tif (n_classes < 1) {\n\t\treturn rz_list_newf((RzListFree)free);\n\t}\n\n\tclass_ids = RZ_NEWS0(ut32, n_classes);\n\tif (!class_ids) {\n\t\treturn NULL;\n\t}\n\n\tut32 j = 0;\n\trz_pvector_foreach (dex->class_defs, vit) {\n\t\tclass_def = (DexClassDef *)*vit;\n\t\tclass_ids[j] = class_def->class_idx;\n\t\tj++;\n\t}\n\n\tlibraries = rz_list_newf((RzListFree)free);\n\tif (!libraries) {\n\t\tfree(class_ids);\n\t\treturn NULL;\n\t}\n\n\trz_pvector_foreach (dex->method_ids, vit) {\n\t\tmethod_id = (DexMethodId *)*vit;\n\t\tbool class_found = false;\n\t\tfor (ut32 i = 0; i < n_classes; ++i) {\n\t\t\tif (method_id->class_idx == class_ids[i]) {\n\t\t\t\tclass_found = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (class_found) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tchar *object = dex_resolve_type_id(dex, method_id->class_idx);\n\t\tif (RZ_STR_ISEMPTY(object) || *object != 'L' || !strncmp(object, \"Ljava/\", strlen(\"Ljava/\"))) {\n\t\t\tfree(object);\n\t\t\tcontinue;\n\t\t}\n\n\t\tchar *p = object;\n\t\tif ((p = strchr(p, '/')) && (p = strchr(p + 1, '/'))) {\n\t\t\t*p = 0;\n\t\t\tp = rz_str_newf(\"%s/*;\", object);\n\t\t\tfree(object);\n\t\t\tobject = p;\n\t\t}\n\n\t\tif (rz_list_find(libraries, object, compare_strings)) {\n\t\t\tfree(object);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!rz_list_append(libraries, object)) {\n\t\t\tfree(object);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree(class_ids);\n\treturn libraries;\n}\n\nstatic bool dex_resolve_symbol_in_class_methods(RzBinDex *dex, DexClassDef *class_def, RzBinSpecialSymbol resolve, ut64 *paddr, ut64 *vaddr) {\n\tRzListIter *it;\n\tDexEncodedMethod *encoded_method = NULL;\n\n\trz_list_foreach (class_def->direct_methods, it, encoded_method) {\n\t\tif (encoded_method->method_idx >= rz_pvector_len(dex->method_ids)) {\n\t\t\tRZ_LOG_INFO(\"cannot find virtual method with index %\" PFMT64u \"\\n\", encoded_method->method_idx);\n\t\t\tcontinue;\n\t\t}\n\t\tDexMethodId *method_id = (DexMethodId *)rz_pvector_at(dex->method_ids, encoded_method->method_idx);\n\n\t\tchar *name = dex_resolve_string_id(dex, method_id->name_idx);\n\t\tif (!name) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (resolve == RZ_BIN_SPECIAL_SYMBOL_ENTRY || resolve == RZ_BIN_SPECIAL_SYMBOL_INIT) {\n\t\t\tif (strcmp(name, \"<init>\") != 0 && strcmp(name, \"<clinit>\") != 0) {\n\t\t\t\tfree(name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if (resolve == RZ_BIN_SPECIAL_SYMBOL_MAIN) {\n\t\t\tif (strcmp(name, \"main\") != 0) {\n\t\t\t\tfree(name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tfree(name);\n\t\tif (method_id->code_offset < RZ_DEX_RELOC_ADDRESS) {\n\t\t\t*vaddr = RZ_DEX_VIRT_ADDRESS + encoded_method->code_offset;\n\t\t\t*paddr = method_id->code_offset;\n\t\t} else {\n\t\t\t*vaddr = encoded_method->code_offset;\n\t\t\t*paddr = 0;\n\t\t}\n\t\treturn true;\n\t}\n\n\trz_list_foreach (class_def->virtual_methods, it, encoded_method) {\n\t\tif (encoded_method->method_idx >= rz_pvector_len(dex->method_ids)) {\n\t\t\tRZ_LOG_INFO(\"cannot find direct method with index %\" PFMT64u \"\\n\", encoded_method->method_idx);\n\t\t\tcontinue;\n\t\t}\n\t\tDexMethodId *method_id = (DexMethodId *)rz_pvector_at(dex->method_ids, encoded_method->method_idx);\n\n\t\tchar *name = dex_resolve_string_id(dex, method_id->name_idx);\n\t\tif (!name) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (resolve == RZ_BIN_SPECIAL_SYMBOL_ENTRY || resolve == RZ_BIN_SPECIAL_SYMBOL_INIT) {\n\t\t\tif (strcmp(name, \"<init>\") != 0 && strcmp(name, \"<clinit>\") != 0) {\n\t\t\t\tfree(name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if (resolve == RZ_BIN_SPECIAL_SYMBOL_MAIN) {\n\t\t\tif (strcmp(name, \"main\") != 0) {\n\t\t\t\tfree(name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tfree(name);\n\n\t\tif (method_id->code_offset < RZ_DEX_RELOC_ADDRESS) {\n\t\t\t*vaddr = RZ_DEX_VIRT_ADDRESS + encoded_method->code_offset;\n\t\t\t*paddr = method_id->code_offset;\n\t\t} else {\n\t\t\t*vaddr = encoded_method->code_offset;\n\t\t\t*paddr = 0;\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/**\n * \\brief Returns a RzBinAddr pointer containing the resolved RzBinSpecialSymbol\n */\nRZ_API RZ_OWN RzBinAddr *rz_bin_dex_resolve_symbol(RZ_NONNULL RzBinDex *dex, RzBinSpecialSymbol resolve) {\n\trz_return_val_if_fail(dex, NULL);\n\n\tDexClassDef *class_def;\n\tvoid **it;\n\n\tRzBinAddr *ret = RZ_NEW0(RzBinAddr);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->paddr = UT64_MAX;\n\tret->vaddr = UT64_MAX;\n\n\trz_pvector_foreach (dex->class_defs, it) {\n\t\tclass_def = (DexClassDef *)*it;\n\t\tif (dex_resolve_symbol_in_class_methods(dex, class_def, resolve, &ret->paddr, &ret->vaddr)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic RzList /*<RzBinAddr *>*/ *dex_resolve_entrypoints_in_class(RzBinDex *dex, DexClassDef *class_def) {\n\tRzListIter *it;\n\tDexEncodedMethod *encoded_method = NULL;\n\tRzList *entrypoints = NULL;\n\n\tentrypoints = rz_list_newf((RzListFree)free);\n\tif (!entrypoints) {\n\t\treturn NULL;\n\t}\n\n\trz_list_foreach (class_def->direct_methods, it, encoded_method) {\n\t\tif (!dex_is_static(encoded_method->access_flags)) {\n\t\t\t// entrypoints are static\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (encoded_method->method_idx >= rz_pvector_len(dex->method_ids)) {\n\t\t\tRZ_LOG_INFO(\"cannot find direct method with index %\" PFMT64u \"\\n\", encoded_method->method_idx);\n\t\t\tcontinue;\n\t\t}\n\t\tDexMethodId *method_id = (DexMethodId *)rz_pvector_at(dex->method_ids, encoded_method->method_idx);\n\n\t\tchar *name = dex_resolve_string_id(dex, method_id->name_idx);\n\t\tif (!name) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strcmp(name, \"main\") != 0 && strcmp(name, \"<init>\") != 0 && strcmp(name, \"<clinit>\") != 0) {\n\t\t\tfree(name);\n\t\t\tcontinue;\n\t\t}\n\t\tfree(name);\n\n\t\tRzBinAddr *entrypoint = RZ_NEW0(RzBinAddr);\n\t\tif (!entrypoint) {\n\t\t\tbreak;\n\t\t}\n\t\tif (encoded_method->code_offset < RZ_DEX_RELOC_ADDRESS) {\n\t\t\tentrypoint->vaddr = RZ_DEX_VIRT_ADDRESS + encoded_method->code_offset;\n\t\t\tentrypoint->paddr = encoded_method->code_offset;\n\t\t} else {\n\t\t\tentrypoint->vaddr = encoded_method->code_offset;\n\t\t\tentrypoint->paddr = 0;\n\t\t}\n\t\tif (entrypoint && !rz_list_append(entrypoints, entrypoint)) {\n\t\t\tfree(entrypoint);\n\t\t}\n\t}\n\n\trz_list_foreach (class_def->virtual_methods, it, encoded_method) {\n\t\tif (!dex_is_static(encoded_method->access_flags)) {\n\t\t\t// entrypoints are static\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (encoded_method->method_idx >= rz_pvector_len(dex->method_ids)) {\n\t\t\tRZ_LOG_INFO(\"cannot find virtual method with index %\" PFMT64u \"\\n\", encoded_method->method_idx);\n\t\t\tcontinue;\n\t\t}\n\n\t\tDexMethodId *method_id = (DexMethodId *)rz_pvector_at(dex->method_ids, encoded_method->method_idx);\n\t\tif (method_id->code_offset < 1) {\n\t\t\t// if there is no code, skip\n\t\t\tcontinue;\n\t\t}\n\n\t\tchar *name = dex_resolve_string_id(dex, method_id->name_idx);\n\t\tif (!name) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strcmp(name, \"main\") != 0 && strcmp(name, \"<init>\") != 0 && strcmp(name, \"<clinit>\") != 0) {\n\t\t\tfree(name);\n\t\t\tcontinue;\n\t\t}\n\t\tfree(name);\n\n\t\tRzBinAddr *entrypoint = RZ_NEW0(RzBinAddr);\n\t\tif (!entrypoint) {\n\t\t\tbreak;\n\t\t}\n\t\tif (encoded_method->code_offset < RZ_DEX_RELOC_ADDRESS) {\n\t\t\tentrypoint->vaddr = RZ_DEX_VIRT_ADDRESS + encoded_method->code_offset;\n\t\t\tentrypoint->paddr = encoded_method->code_offset;\n\t\t} else {\n\t\t\tentrypoint->vaddr = encoded_method->code_offset;\n\t\t\tentrypoint->paddr = 0;\n\t\t}\n\t\tif (entrypoint && !rz_list_append(entrypoints, entrypoint)) {\n\t\t\tfree(entrypoint);\n\t\t}\n\t}\n\n\treturn entrypoints;\n}\n\n/**\n * \\brief Returns a RzList<RzBinAddr*> containing the dex entripoints\n */\nRZ_API RZ_OWN RzList /*<RzBinAddr *>*/ *rz_bin_dex_entrypoints(RZ_NONNULL RzBinDex *dex) {\n\trz_return_val_if_fail(dex, NULL);\n\n\tDexClassDef *class_def;\n\tRzList *list = NULL;\n\tRzList *entrypoints = NULL;\n\tvoid **it;\n\n\tentrypoints = rz_list_newf((RzListFree)free);\n\tif (!entrypoints) {\n\t\treturn NULL;\n\t}\n\n\trz_pvector_foreach (dex->class_defs, it) {\n\t\tclass_def = (DexClassDef *)*it;\n\t\tlist = dex_resolve_entrypoints_in_class(dex, class_def);\n\t\tif (list) {\n\t\t\trz_list_join(entrypoints, list);\n\t\t\trz_list_free(list);\n\t\t}\n\t}\n\n\treturn entrypoints;\n}\n\n/**\n * This method will create a buffer filled with return-void values to mapped\n * to the imports and allow the code to generate xrefs pointing to the imports\n */\nRZ_API RZ_BORROW RzBuffer *rz_bin_dex_relocations(RZ_NONNULL RzBinDex *dex) {\n\trz_return_val_if_fail(dex, NULL);\n\treturn dex->relocs_buffer;\n}\n\n/**\n * \\brief Returns the resolved string linked to the given method id\n */\nRZ_API RZ_OWN char *rz_bin_dex_resolve_method_by_idx(RZ_NONNULL RzBinDex *dex, ut32 method_idx) {\n\trz_return_val_if_fail(dex, NULL);\n\n\tif (method_idx >= rz_pvector_len(dex->method_ids)) {\n\t\treturn NULL;\n\t}\n\n\tDexMethodId *method_id = (DexMethodId *)rz_pvector_at(dex->method_ids, method_idx);\n\tchar *name = dex_resolve_string_id(dex, method_id->name_idx);\n\tif (!name) {\n\t\treturn NULL;\n\t}\n\n\tchar *proto = dex_resolve_proto_id(dex, name, method_id->proto_idx, false);\n\tRZ_FREE(name);\n\tif (!proto) {\n\t\treturn NULL;\n\t}\n\n\tname = dex_resolve_type_id(dex, method_id->class_idx);\n\tif (!name) {\n\t\tfree(proto);\n\t\treturn NULL;\n\t}\n\n\tchar *method = rz_str_newf(\"%s->%s\", name, proto);\n\tfree(name);\n\tfree(proto);\n\treturn method;\n}\n\n/**\n * \\brief Returns the resolved string linked to the given field id\n */\nRZ_API RZ_OWN char *rz_bin_dex_resolve_field_by_idx(RZ_NONNULL RzBinDex *dex, ut32 field_idx) {\n\trz_return_val_if_fail(dex, NULL);\n\n\tif (field_idx >= rz_pvector_len(dex->field_ids)) {\n\t\treturn NULL;\n\t}\n\n\tDexFieldId *field_id = (DexFieldId *)rz_pvector_at(dex->field_ids, field_idx);\n\tchar *class_name = dex_resolve_type_id(dex, field_id->class_idx);\n\tif (!class_name) {\n\t\treturn NULL;\n\t}\n\n\tchar *name = dex_resolve_string_id(dex, field_id->name_idx);\n\tif (!name) {\n\t\tfree(class_name);\n\t\treturn NULL;\n\t}\n\n\tchar *type = dex_resolve_type_id(dex, field_id->type_idx);\n\tif (!type) {\n\t\tfree(class_name);\n\t\tfree(name);\n\t\treturn NULL;\n\t}\n\n\tchar *method = rz_str_newf(\"%s->%s %s\", class_name, name, type);\n\n\tfree(type);\n\tfree(class_name);\n\tfree(name);\n\treturn method;\n}\n\n/**\n * \\brief Returns the resolved offset linked to the given string id\n */\nRZ_API ut64 rz_bin_dex_resolve_string_offset_by_idx(RZ_NONNULL RzBinDex *dex, ut32 string_idx) {\n\trz_return_val_if_fail(dex, UT64_MAX);\n\n\tDexString *string = dex_resolve_string_id_native(dex, string_idx);\n\tif (!string) {\n\t\tRZ_LOG_INFO(\"cannot find string with index %u\\n\", string_idx);\n\t\treturn UT64_MAX;\n\t}\n\treturn RZ_DEX_VIRT_ADDRESS + string->offset;\n}\n\n/**\n * \\brief Returns the resolved offset linked to the given type id\n */\nRZ_API ut64 rz_bin_dex_resolve_type_id_offset_by_idx(RZ_NONNULL RzBinDex *dex, ut32 type_idx) {\n\trz_return_val_if_fail(dex, UT64_MAX);\n\n\tif (type_idx >= dex->type_ids_size) {\n\t\tRZ_LOG_INFO(\"cannot find type_id with index %u\\n\", type_idx);\n\t\treturn UT64_MAX;\n\t}\n\tDexTypeId type_id = dex->types[type_idx];\n\treturn rz_bin_dex_resolve_string_offset_by_idx(dex, type_id);\n}\n\n/**\n * \\brief Returns the resolved offset linked to the given method id\n */\nRZ_API ut64 rz_bin_dex_resolve_method_offset_by_idx(RZ_NONNULL RzBinDex *dex, ut32 method_idx) {\n\trz_return_val_if_fail(dex, UT64_MAX);\n\n\tif (method_idx >= rz_pvector_len(dex->method_ids)) {\n\t\tRZ_LOG_INFO(\"cannot find method with index %u\\n\", method_idx);\n\t\treturn UT64_MAX;\n\t}\n\n\tDexMethodId *method = (DexMethodId *)rz_pvector_at(dex->method_ids, method_idx);\n\tif (method->code_offset) {\n\t\tif (method->code_offset < RZ_DEX_RELOC_ADDRESS) {\n\t\t\treturn RZ_DEX_VIRT_ADDRESS + method->code_offset;\n\t\t}\n\t\treturn method->code_offset;\n\t}\n\treturn UT64_MAX;\n}\n\n/**\n * \\brief Returns the resolved string linked to the given type id\n */\nRZ_API RZ_OWN char *rz_bin_dex_resolve_type_id_by_idx(RZ_NONNULL RzBinDex *dex, ut32 type_idx) {\n\trz_return_val_if_fail(dex, NULL);\n\n\tif (type_idx >= dex->type_ids_size) {\n\t\tRZ_LOG_INFO(\"cannot find type_id with index %u\\n\", type_idx);\n\t\treturn NULL;\n\t}\n\tDexTypeId type_id = dex->types[type_idx];\n\treturn rz_bin_dex_resolve_string_by_idx(dex, type_id);\n}\n\n/**\n * \\brief Returns the resolved string linked to the given string id\n */\nRZ_API RZ_OWN char *rz_bin_dex_resolve_string_by_idx(RZ_NONNULL RzBinDex *dex, ut32 string_idx) {\n\trz_return_val_if_fail(dex, NULL);\n\n\treturn dex_resolve_string_id(dex, string_idx);\n}\n\n/**\n * \\brief Returns the resolved string linked to the given class id\n */\nRZ_API RZ_OWN char *rz_bin_dex_resolve_class_by_idx(RZ_NONNULL RzBinDex *dex, ut32 class_idx) {\n\trz_return_val_if_fail(dex, NULL);\n\n\treturn dex_resolve_type_id(dex, class_idx);\n}\n\n/**\n * \\brief Returns the resolved string linked to the given prototype id\n */\nRZ_API RZ_OWN char *rz_bin_dex_resolve_proto_by_idx(RZ_NONNULL RzBinDex *dex, ut32 proto_idx) {\n\trz_return_val_if_fail(dex, NULL);\n\n\treturn dex_resolve_proto_id(dex, \"\", proto_idx, false);\n}\n\n/**\n * \\brief Sets the RzBinHash dex checksum (adler32)\n */\nRZ_API void rz_bin_dex_checksum(RZ_NONNULL RzBinDex *dex, RZ_NONNULL RzBinHash *hash) {\n\trz_return_if_fail(dex && hash);\n\thash->type = \"adler32\";\n\thash->len = sizeof(dex->checksum);\n\thash->addr = dex->checksum_offset;\n\thash->from = dex->checksum_offset + sizeof(dex->checksum);\n\thash->to = dex->file_size - hash->from;\n\trz_write_le32(hash->buf, dex->checksum);\n}\n\n/**\n * \\brief Sets the RzBinHash dex digest (sha1)\n */\nRZ_API void rz_bin_dex_sha1(RZ_NONNULL RzBinDex *dex, RZ_NONNULL RzBinHash *hash) {\n\trz_return_if_fail(dex && hash);\n\thash->type = \"sha1\";\n\thash->len = 20;\n\thash->addr = dex->signature_offset;\n\thash->from = dex->signature_offset + sizeof(dex->signature);\n\thash->to = dex->file_size - hash->from;\n\tmemcpy(hash->buf, dex->signature, sizeof(dex->signature));\n}\n\n/**\n * \\brief Returns the dex version (string format)\n */\nRZ_API RZ_OWN char *rz_bin_dex_version(RZ_NONNULL RzBinDex *dex) {\n\trz_return_val_if_fail(dex, NULL);\n\t// https://cs.android.com/android/platform/superproject/+/master:dalvik/dx/src/com/android/dex/DexFormat.java;l=55;bpv=1;bpt=0\n\t// https://developer.android.com/studio/releases/platforms\n\tif (!strncmp((char *)dex->version, \"009\", 3)) {\n\t\treturn strdup(\"Android M3 release (Nov-Dec 2007)\");\n\t} else if (!strncmp((char *)dex->version, \"013\", 3)) {\n\t\treturn strdup(\"Android M5 release (Feb-Mar 2008)\");\n\t} else if (!strncmp((char *)dex->version, \"035\", 3)) {\n\t\treturn strdup(\"Android 3.2 (API level 13 and earlier)\");\n\t} else if (!strncmp((char *)dex->version, \"037\", 3)) {\n\t\treturn strdup(\"Android 7 (API level 24 and earlier)\");\n\t} else if (!strncmp((char *)dex->version, \"038\", 3)) {\n\t\treturn strdup(\"Android 8 (API level 26 and earlier)\");\n\t} else if (!strncmp((char *)dex->version, \"039\", 3)) {\n\t\treturn strdup(\"Android 9 (API level 28 and earlier)\");\n\t} else if (!strncmp((char *)dex->version, \"040\", 3)) {\n\t\treturn strdup(\"Android 10+ (Aug 2019)\");\n\t}\n\treturn NULL;\n}\n\n/**\n * \\brief Returns the dex debug info RzBin values\n */\nRZ_API ut64 rz_bin_dex_debug_info(RZ_NONNULL RzBinDex *dex) {\n\trz_return_val_if_fail(dex, 0);\n\t// TODO\n\treturn 0;\n}\n"], "fixing_code": ["// SPDX-FileCopyrightText: 2021 RizinOrg <info@rizin.re>\n// SPDX-FileCopyrightText: 2021 deroad <wargio@libero.it>\n// SPDX-License-Identifier: LGPL-3.0-only\n\n#include \"dex.h\"\n#include <rz_util.h>\n\n#define DEX_INVALID_CLASS  \"Lunknown_class;\"\n#define DEX_INVALID_METHOD \"unknown_method\"\n\ntypedef struct dex_access_flags_readable_t {\n\tut32 flag;\n\tconst char *readable;\n} DexAccessFlagsReadable;\n\n#define read_le_bits_or_fail(bits, buf, val, fail) \\\n\tdo { \\\n\t\tif (!rz_buf_read_le##bits(buf, &val)) { \\\n\t\t\tgoto fail; \\\n\t\t} \\\n\t} while (0)\n\n#define read_le_at_bits_or_fail(bits, buf, val, offset, fail) \\\n\tdo { \\\n\t\tif (!rz_buf_read_le##bits##_at(buf, offset, &val)) { \\\n\t\t\tgoto fail; \\\n\t\t} \\\n\t} while (0)\n\n#define read_le32_or_fail(buf, val, fail)            read_le_bits_or_fail(32, buf, val, fail)\n#define read_le16_or_fail(buf, val, fail)            read_le_bits_or_fail(16, buf, val, fail)\n#define read_le32_at_or_fail(buf, val, offset, fail) read_le_at_bits_or_fail(32, buf, val, offset, fail)\n#define read_le16_at_or_fail(buf, val, offset, fail) read_le_at_bits_or_fail(16, buf, val, offset, fail)\n\n#define dex_is_static(a)  (a & ACCESS_FLAG_STATIC)\n#define dex_is_varargs(a) (a & ACCESS_FLAG_VARARGS)\n\n#define dex_fail_if_bad_ids(name, z, s, g) \\\n\tdo { \\\n\t\tut64 end = name##_offset; \\\n\t\tend += name##_size * (z); \\\n\t\tif (end >= (s)) { \\\n\t\t\tgoto g; \\\n\t\t} \\\n\t} while (0)\n\n#define CLASS_ACCESS_FLAGS_SIZE 18\nstatic const DexAccessFlagsReadable access_flags_list[CLASS_ACCESS_FLAGS_SIZE] = {\n\t{ ACCESS_FLAG_PUBLIC /*               */, \"public\" },\n\t{ ACCESS_FLAG_PRIVATE /*              */, \"private\" },\n\t{ ACCESS_FLAG_PROTECTED /*            */, \"protected\" },\n\t{ ACCESS_FLAG_STATIC /*               */, \"static\" },\n\t{ ACCESS_FLAG_FINAL /*                */, \"final\" },\n\t{ ACCESS_FLAG_SYNCHRONIZED /*         */, \"synchronized\" },\n\t{ ACCESS_FLAG_BRIDGE /*               */, \"bridge\" },\n\t{ ACCESS_FLAG_VARARGS /*              */, \"varargs\" },\n\t{ ACCESS_FLAG_NATIVE /*               */, \"native\" },\n\t{ ACCESS_FLAG_INTERFACE /*            */, \"interface\" },\n\t{ ACCESS_FLAG_ABSTRACT /*             */, \"abstract\" },\n\t{ ACCESS_FLAG_STRICT /*               */, \"strict\" },\n\t{ ACCESS_FLAG_SYNTHETIC /*            */, \"synthetic\" },\n\t{ ACCESS_FLAG_ANNOTATION /*           */, \"annotation\" },\n\t{ ACCESS_FLAG_ENUM /*                 */, \"enum\" },\n\t{ ACCESS_FLAG_MODULE /*               */, \"module\" },\n\t{ ACCESS_FLAG_CONSTRUCTOR /*          */, \"constructor\" },\n\t{ ACCESS_FLAG_DECLARED_SYNCHRONIZED /**/, \"synchronized\" },\n};\n\nstatic void dex_string_free(DexString *string) {\n\tif (!string) {\n\t\treturn;\n\t}\n\tfree(string->data);\n\tfree(string);\n}\n\nstatic DexString *dex_string_new(RzBuffer *buf, ut64 offset, st64 *pread) {\n\tut64 size = 0;\n\tchar *data = NULL;\n\tst64 read;\n\tDexString *string = NULL;\n\n\tread = rz_buf_uleb128(buf, &size);\n\tif (UT64_ADD_OVFCHK(size, 1)) {\n\t\treturn NULL;\n\t}\n\n\tdata = malloc(size + 1);\n\tif (!data || rz_buf_read(buf, (ut8 *)data, size) != size) {\n\t\tfree(data);\n\t\treturn NULL;\n\t}\n\tdata[size] = 0;\n\n\tstring = RZ_NEW0(DexString);\n\tif (!string) {\n\t\tfree(data);\n\t\treturn NULL;\n\t}\n\n\t*pread = read;\n\tstring->size = size;\n\tstring->offset = offset;\n\tstring->data = data;\n\treturn string;\n}\n\nstatic void dex_proto_id_free(DexProtoId *string) {\n\tif (!string) {\n\t\treturn;\n\t}\n\tfree(string->type_list);\n\tfree(string);\n}\n\nstatic DexProtoId *dex_proto_id_new(RzBuffer *buf, ut64 offset) {\n\tDexProtoId *proto_id = RZ_NEW0(DexProtoId);\n\tif (!proto_id) {\n\t\treturn NULL;\n\t}\n\n\tut32 parameters_offset = 0;\n\tproto_id->offset = offset;\n\tread_le32_or_fail(buf, proto_id->shorty_idx, dex_proto_id_new_fail);\n\tread_le32_or_fail(buf, proto_id->return_type_idx, dex_proto_id_new_fail);\n\n\tread_le32_or_fail(buf, parameters_offset, dex_proto_id_new_fail);\n\tif (parameters_offset > 0) {\n\t\tut32 count = 0;\n\t\tread_le32_at_or_fail(buf, count, parameters_offset, dex_proto_id_new_fail);\n\n\t\tproto_id->type_list_size = count;\n\t\tproto_id->type_list = RZ_NEWS(ut16, count);\n\t\tif (!proto_id->type_list) {\n\t\t\tgoto dex_proto_id_new_fail;\n\t\t}\n\n\t\tparameters_offset += sizeof(ut32);\n\t\tfor (ut32 i = 0; i < count; ++i, parameters_offset += sizeof(ut16)) {\n\t\t\tread_le16_at_or_fail(buf, proto_id->type_list[i], parameters_offset, dex_proto_id_new_fail);\n\t\t}\n\t}\n\n\treturn proto_id;\n\ndex_proto_id_new_fail:\n\tfree(proto_id);\n\treturn NULL;\n}\n\n#define dex_field_id_free free\nstatic DexFieldId *dex_field_id_new(RzBuffer *buf, ut64 offset) {\n\tDexFieldId *field_id = RZ_NEW0(DexFieldId);\n\tif (!field_id) {\n\t\treturn NULL;\n\t}\n\n\tread_le16_or_fail(buf, field_id->class_idx, dex_field_id_new_fail);\n\tread_le16_or_fail(buf, field_id->type_idx, dex_field_id_new_fail);\n\tread_le32_or_fail(buf, field_id->name_idx, dex_field_id_new_fail);\n\tfield_id->offset = offset;\n\treturn field_id;\n\ndex_field_id_new_fail:\n\tfree(field_id);\n\treturn NULL;\n}\n\n#define dex_method_id_free free\nstatic DexMethodId *dex_method_id_new(RzBuffer *buf, ut64 offset) {\n\tDexMethodId *method_id = RZ_NEW0(DexMethodId);\n\tif (!method_id) {\n\t\treturn NULL;\n\t}\n\n\tread_le16_or_fail(buf, method_id->class_idx, dex_method_id_new_fail);\n\tread_le16_or_fail(buf, method_id->proto_idx, dex_method_id_new_fail);\n\tread_le32_or_fail(buf, method_id->name_idx, dex_method_id_new_fail);\n\tmethod_id->offset = offset;\n\treturn method_id;\n\ndex_method_id_new_fail:\n\tfree(method_id);\n\treturn NULL;\n}\n\nstatic void dex_class_def_free(DexClassDef *class_def) {\n\tif (!class_def) {\n\t\treturn;\n\t}\n\trz_list_free(class_def->static_fields);\n\trz_list_free(class_def->instance_fields);\n\trz_list_free(class_def->direct_methods);\n\trz_list_free(class_def->virtual_methods);\n\tfree(class_def->interfaces);\n\tfree(class_def);\n}\n\nstatic DexEncodedField *dex_new_encoded_field(RzBuffer *buf, ut64 base, ut64 *diff_value_prev, bool first) {\n\tDexEncodedField *encoded_field = RZ_NEW0(DexEncodedField);\n\tif (!encoded_field) {\n\t\treturn NULL;\n\t}\n\tut64 diff_value = 0;\n\n\tencoded_field->offset = rz_buf_tell(buf) + base;\n\trz_buf_uleb128(buf, &diff_value);\n\trz_buf_uleb128(buf, &encoded_field->access_flags);\n\n\tif (first) {\n\t\tencoded_field->field_idx = diff_value;\n\t\t*diff_value_prev = diff_value;\n\t} else {\n\t\tencoded_field->field_idx = *diff_value_prev + diff_value;\n\t\t*diff_value_prev = encoded_field->field_idx;\n\t}\n\treturn encoded_field;\n}\n\nstatic DexEncodedMethod *dex_new_encoded_method(RzBuffer *buf, ut64 base, ut64 *diff_value_prev, bool first, RzPVector *method_ids) {\n\tDexEncodedMethod *encoded_method = RZ_NEW0(DexEncodedMethod);\n\tif (!encoded_method) {\n\t\treturn NULL;\n\t}\n\tut64 diff_value = 0;\n\tut64 code_offset = 0;\n\n\tencoded_method->offset = rz_buf_tell(buf) + base;\n\trz_buf_uleb128(buf, &diff_value);\n\trz_buf_uleb128(buf, &encoded_method->access_flags);\n\trz_buf_uleb128(buf, &code_offset);\n\n\tif (first) {\n\t\tencoded_method->method_idx = diff_value;\n\t\t*diff_value_prev = diff_value;\n\t} else {\n\t\tencoded_method->method_idx = *diff_value_prev + diff_value;\n\t\t*diff_value_prev = encoded_method->method_idx;\n\t}\n\n\tif (code_offset > 0) {\n\t\tread_le16_at_or_fail(buf, encoded_method->registers_size, code_offset, dex_new_encoded_method_fail);\n\t\tread_le16_at_or_fail(buf, encoded_method->ins_size, code_offset + 2, dex_new_encoded_method_fail);\n\t\tread_le16_at_or_fail(buf, encoded_method->outs_size, code_offset + 4, dex_new_encoded_method_fail);\n\t\tread_le16_at_or_fail(buf, encoded_method->tries_size, code_offset + 6, dex_new_encoded_method_fail);\n\t\tread_le32_at_or_fail(buf, encoded_method->debug_info_offset, code_offset + 8, dex_new_encoded_method_fail);\n\t\tread_le32_at_or_fail(buf, encoded_method->code_size, code_offset + 12, dex_new_encoded_method_fail);\n\t\tencoded_method->code_size *= sizeof(ut16); // code ushort[insns_size]\n\t\tencoded_method->code_offset = code_offset + 16 + base;\n\n\t\tif (encoded_method->method_idx < rz_pvector_len(method_ids)) {\n\t\t\tDexMethodId *method_id = (DexMethodId *)rz_pvector_at(method_ids, encoded_method->method_idx);\n\t\t\tif (method_id) {\n\t\t\t\tmethod_id->code_offset = encoded_method->code_offset;\n\t\t\t\tmethod_id->code_size = encoded_method->code_size;\n\t\t\t}\n\t\t}\n\t}\n\treturn encoded_method;\n\ndex_new_encoded_method_fail:\n\tfree(encoded_method);\n\treturn NULL;\n}\n\nstatic DexClassDef *dex_class_def_new(RzBuffer *buf, ut64 offset, ut64 base, RzPVector *method_ids) {\n\tDexClassDef *class_def = RZ_NEW0(DexClassDef);\n\tif (!class_def) {\n\t\treturn NULL;\n\t}\n\n\tut64 static_fields_size = 0;\n\tut64 instance_fields_size = 0;\n\tut64 direct_methods_size = 0;\n\tut64 virtual_methods_size = 0;\n\tut64 diff_value_prev;\n\n\tclass_def->static_fields = /*  */ rz_list_newf((RzListFree)free);\n\tclass_def->instance_fields = /**/ rz_list_newf((RzListFree)free);\n\tclass_def->direct_methods = /* */ rz_list_newf((RzListFree)free);\n\tclass_def->virtual_methods = /**/ rz_list_newf((RzListFree)free);\n\n\tread_le16_or_fail(buf, class_def->class_idx, dex_class_def_new_fail);\n\tread_le16_or_fail(buf, class_def->_padding1, dex_class_def_new_fail);\n\tread_le32_or_fail(buf, class_def->access_flags, dex_class_def_new_fail);\n\tread_le16_or_fail(buf, class_def->superclass_idx, dex_class_def_new_fail);\n\tread_le16_or_fail(buf, class_def->_padding2, dex_class_def_new_fail);\n\tread_le32_or_fail(buf, class_def->interfaces_offset, dex_class_def_new_fail);\n\tread_le32_or_fail(buf, class_def->source_file_idx, dex_class_def_new_fail);\n\tread_le32_or_fail(buf, class_def->annotations_offset, dex_class_def_new_fail);\n\tread_le32_or_fail(buf, class_def->class_data_offset, dex_class_def_new_fail);\n\tread_le32_or_fail(buf, class_def->static_values_offset, dex_class_def_new_fail);\n\tclass_def->offset = offset;\n\n\tif (class_def->interfaces_offset > 0) {\n\t\tif (rz_buf_seek(buf, class_def->interfaces_offset, RZ_BUF_SET) < 0) {\n\t\t\tgoto dex_class_def_new_fail;\n\t\t}\n\t\tread_le32_or_fail(buf, class_def->n_interfaces, dex_class_def_new_fail);\n\t\tif (class_def->n_interfaces > 0) {\n\t\t\tclass_def->interfaces = RZ_NEWS0(ut16, class_def->n_interfaces);\n\t\t\tif (!class_def->interfaces) {\n\t\t\t\tgoto dex_class_def_new_fail;\n\t\t\t}\n\t\t\tfor (ut32 i = 0; i < class_def->n_interfaces; ++i) {\n\t\t\t\tread_le16_or_fail(buf, class_def->interfaces[i], dex_class_def_new_fail);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!class_def->class_data_offset) {\n\t\treturn class_def;\n\t}\n\n\tif (rz_buf_seek(buf, class_def->class_data_offset, RZ_BUF_SET) < 0) {\n\t\tgoto dex_class_def_new_fail;\n\t}\n\n\trz_buf_uleb128(buf, &static_fields_size);\n\trz_buf_uleb128(buf, &instance_fields_size);\n\trz_buf_uleb128(buf, &direct_methods_size);\n\trz_buf_uleb128(buf, &virtual_methods_size);\n\n\tfor (ut64 i = 0; i < static_fields_size; ++i) {\n\t\tDexEncodedField *encoded_field = dex_new_encoded_field(buf, base, &diff_value_prev, i < 1);\n\t\tif (!encoded_field || !rz_list_append(class_def->static_fields, encoded_field)) {\n\t\t\tfree(encoded_field);\n\t\t\tgoto dex_class_def_new_fail;\n\t\t}\n\t}\n\n\tfor (ut64 i = 0; i < instance_fields_size; ++i) {\n\t\tDexEncodedField *encoded_field = dex_new_encoded_field(buf, base, &diff_value_prev, i < 1);\n\t\tif (!encoded_field || !rz_list_append(class_def->instance_fields, encoded_field)) {\n\t\t\tfree(encoded_field);\n\t\t\tgoto dex_class_def_new_fail;\n\t\t}\n\t}\n\n\tfor (ut64 i = 0; i < direct_methods_size; ++i) {\n\t\tDexEncodedMethod *encoded_method = dex_new_encoded_method(buf, base, &diff_value_prev, i < 1, method_ids);\n\t\tif (!encoded_method || !rz_list_append(class_def->direct_methods, encoded_method)) {\n\t\t\tfree(encoded_method);\n\t\t\tgoto dex_class_def_new_fail;\n\t\t}\n\t}\n\n\tfor (ut64 i = 0; i < virtual_methods_size; ++i) {\n\t\tDexEncodedMethod *encoded_method = dex_new_encoded_method(buf, base, &diff_value_prev, i < 1, method_ids);\n\t\tif (!encoded_method || !rz_list_append(class_def->virtual_methods, encoded_method)) {\n\t\t\tfree(encoded_method);\n\t\t\tgoto dex_class_def_new_fail;\n\t\t}\n\t}\n\n\treturn class_def;\n\ndex_class_def_new_fail:\n\tdex_class_def_free(class_def);\n\treturn NULL;\n}\n\nstatic void dex_resolve_virtual_method_code(RzBinDex *dex, DexMethodId *to_resolve, ut32 superclass_idx) {\n\tDexMethodId *method_id = NULL;\n\tvoid **it;\n\n\trz_pvector_foreach (dex->method_ids, it) {\n\t\tmethod_id = (DexMethodId *)*it;\n\t\tif (method_id == to_resolve ||\n\t\t\tmethod_id->class_idx != superclass_idx ||\n\t\t\tmethod_id->proto_idx != to_resolve->proto_idx ||\n\t\t\tmethod_id->name_idx != to_resolve->name_idx) {\n\t\t\tcontinue;\n\t\t}\n\t\tto_resolve->code_offset = method_id->code_offset;\n\t\tto_resolve->code_size = method_id->code_size;\n\t\treturn;\n\t}\n}\n\nstatic void dex_resolve_all_virtual_methods(RzBinDex *dex) {\n\tDexClassDef *class_def;\n\tDexMethodId *method_id = NULL;\n\tvoid **it;\n\tdex->relocs_size = 0;\n\trz_pvector_foreach (dex->method_ids, it) {\n\t\tmethod_id = (DexMethodId *)*it;\n\t\tif (method_id->code_offset ||\n\t\t\tmethod_id->class_idx >= rz_pvector_len(dex->class_defs)) {\n\t\t\tcontinue;\n\t\t}\n\t\tclass_def = rz_pvector_at(dex->class_defs, method_id->class_idx);\n\t\tdex_resolve_virtual_method_code(dex, method_id, class_def->superclass_idx);\n\t}\n}\n\nstatic bool dex_create_relocations(RzBinDex *dex) {\n\tvoid **iter_p0;\n\tRzListIter *iter_l;\n\tDexClassDef *class_def;\n\tDexEncodedMethod *encoded_method = NULL;\n\tDexMethodId *method_id = NULL;\n\n\tdex->relocs_size = 0;\n\trz_pvector_foreach (dex->method_ids, iter_p0) {\n\t\tmethod_id = (DexMethodId *)*iter_p0;\n\t\tif (method_id->code_offset) {\n\t\t\tcontinue;\n\t\t}\n\t\t// patch the imported method.\n\t\tmethod_id->code_offset = dex->relocs_offset + dex->relocs_size;\n\t\tmethod_id->code_size = 2;\n\t\tdex->relocs_size += 2;\n\t}\n\n\t// sync classes with method_ids\n\trz_pvector_foreach (dex->class_defs, iter_p0) {\n\t\tclass_def = (DexClassDef *)*iter_p0;\n\t\trz_list_foreach (class_def->direct_methods, iter_l, encoded_method) {\n\t\t\tif (encoded_method->code_offset) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmethod_id = NULL;\n\t\t\tif (encoded_method->method_idx < rz_pvector_len(dex->method_ids)) {\n\t\t\t\tmethod_id = (DexMethodId *)rz_pvector_at(dex->method_ids, encoded_method->method_idx);\n\t\t\t\tif (method_id->code_offset) {\n\t\t\t\t\tencoded_method->code_offset = method_id->code_offset;\n\t\t\t\t\tencoded_method->code_size = method_id->code_size;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// patch the imported method.\n\t\t\tencoded_method->code_offset = dex->relocs_offset + dex->relocs_size;\n\t\t\tencoded_method->code_size = 2;\n\t\t\tdex->relocs_size += 2;\n\t\t\tif (method_id) {\n\t\t\t\tmethod_id->code_offset = encoded_method->code_offset;\n\t\t\t\tmethod_id->code_size = encoded_method->code_size;\n\t\t\t}\n\t\t}\n\n\t\trz_list_foreach (class_def->virtual_methods, iter_l, encoded_method) {\n\t\t\tif (encoded_method->code_offset) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tmethod_id = NULL;\n\t\t\tif (encoded_method->method_idx < rz_pvector_len(dex->method_ids)) {\n\t\t\t\tmethod_id = (DexMethodId *)rz_pvector_at(dex->method_ids, encoded_method->method_idx);\n\t\t\t\tif (method_id->code_offset) {\n\t\t\t\t\tencoded_method->code_offset = method_id->code_offset;\n\t\t\t\t\tencoded_method->code_size = method_id->code_size;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// patch the imported method.\n\t\t\tencoded_method->code_offset = dex->relocs_offset + dex->relocs_size;\n\t\t\tencoded_method->code_size = 2;\n\t\t\tdex->relocs_size += 2;\n\t\t\tif (method_id) {\n\t\t\t\tmethod_id->code_offset = encoded_method->code_offset;\n\t\t\t\tmethod_id->code_size = encoded_method->code_size;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dex->relocs_size < 1) {\n\t\treturn true;\n\t}\n\tdex->relocs_code = malloc(dex->relocs_size);\n\tif (!dex->relocs_code) {\n\t\treturn false;\n\t}\n\tfor (ut32 i = 0; i < dex->relocs_size; i += 2) {\n\t\tdex->relocs_code[i] = 0x0e;\n\t\tdex->relocs_code[i + 1] = 0x00;\n\t}\n\tdex->relocs_buffer = rz_buf_new_with_bytes(dex->relocs_code, dex->relocs_size);\n\treturn dex->relocs_buffer;\n}\n\nstatic bool dex_parse(RzBinDex *dex, ut64 base, RzBuffer *buf) {\n\tut64 offset = 0;\n\tst64 read = 0;\n\tst64 buffer_size = rz_buf_size(buf);\n\tif (buffer_size < 116) {\n\t\t// 116 bytes is the smalled dex that can be built.\n\t\tRZ_LOG_ERROR(\"dex bin: invalid buffer size (size < 116)\\n\");\n\t\tgoto dex_parse_bad;\n\t}\n\n\tdex->header_offset = base;\n\tdex->relocs_offset = base + RZ_DEX_RELOC_ADDRESS;\n\trz_buf_read(buf, dex->magic, sizeof(dex->magic));\n\trz_buf_read(buf, dex->version, sizeof(dex->version));\n\tdex->checksum_offset = rz_buf_tell(buf) + base;\n\tread_le32_or_fail(buf, dex->checksum, dex_parse_bad);\n\tdex->signature_offset = rz_buf_tell(buf) + base;\n\trz_buf_read(buf, dex->signature, sizeof(dex->signature));\n\tread_le32_or_fail(buf, dex->file_size, dex_parse_bad);\n\tread_le32_or_fail(buf, dex->header_size, dex_parse_bad);\n\tread_le32_or_fail(buf, dex->endian_tag, dex_parse_bad);\n\n\tread_le32_or_fail(buf, dex->link_size, dex_parse_bad);\n\tread_le32_or_fail(buf, dex->link_offset, dex_parse_bad);\n\n\tread_le32_or_fail(buf, dex->map_offset, dex_parse_bad);\n\n\tread_le32_or_fail(buf, dex->string_ids_size, dex_parse_bad);\n\tread_le32_or_fail(buf, dex->string_ids_offset, dex_parse_bad);\n\t// string_ids points to an array of offsets.\n\tdex_fail_if_bad_ids(dex->string_ids, sizeof(ut32), buffer_size, dex_parse_bad);\n\n\tread_le32_or_fail(buf, dex->type_ids_size, dex_parse_bad);\n\tread_le32_or_fail(buf, dex->type_ids_offset, dex_parse_bad);\n\tdex_fail_if_bad_ids(dex->type_ids, DEX_TYPE_ID_SIZE, buffer_size, dex_parse_bad);\n\n\tread_le32_or_fail(buf, dex->proto_ids_size, dex_parse_bad);\n\tread_le32_or_fail(buf, dex->proto_ids_offset, dex_parse_bad);\n\tdex_fail_if_bad_ids(dex->proto_ids, DEX_PROTO_ID_SIZE, buffer_size, dex_parse_bad);\n\n\tread_le32_or_fail(buf, dex->field_ids_size, dex_parse_bad);\n\tread_le32_or_fail(buf, dex->field_ids_offset, dex_parse_bad);\n\tdex_fail_if_bad_ids(dex->field_ids, DEX_FIELD_ID_SIZE, buffer_size, dex_parse_bad);\n\n\tread_le32_or_fail(buf, dex->method_ids_size, dex_parse_bad);\n\tread_le32_or_fail(buf, dex->method_ids_offset, dex_parse_bad);\n\tdex_fail_if_bad_ids(dex->method_ids, DEX_METHOD_ID_SIZE, buffer_size, dex_parse_bad);\n\n\tread_le32_or_fail(buf, dex->class_defs_size, dex_parse_bad);\n\tread_le32_or_fail(buf, dex->class_defs_offset, dex_parse_bad);\n\n\tread_le32_or_fail(buf, dex->data_size, dex_parse_bad);\n\tread_le32_or_fail(buf, dex->data_offset, dex_parse_bad);\n\n\t/* Strings */\n\toffset = dex->string_ids_offset;\n\tif (!rz_pvector_reserve(dex->strings, dex->string_ids_size)) {\n\t\tgoto dex_parse_bad;\n\t}\n\tfor (ut32 i = 0; i < dex->string_ids_size; ++i, offset += sizeof(ut32)) {\n\t\tut32 string_offset = 0;\n\t\tread_le32_at_or_fail(buf, string_offset, offset, dex_parse_bad);\n\n\t\tif (rz_buf_seek(buf, string_offset, RZ_BUF_SET) < 0) {\n\t\t\tgoto dex_parse_bad;\n\t\t}\n\t\tDexString *string = dex_string_new(buf, base + string_offset, &read);\n\t\tif (!string) {\n\t\t\tgoto dex_parse_bad;\n\t\t}\n\t\trz_pvector_push(dex->strings, string);\n\t}\n\n\t/* Type Ids */\n\tdex->types = RZ_NEWS0(DexTypeId, dex->type_ids_size);\n\tif (!dex->types) {\n\t\tgoto dex_parse_bad;\n\t}\n\tif (rz_buf_seek(buf, dex->type_ids_offset, RZ_BUF_SET) < 0) {\n\t\tgoto dex_parse_bad;\n\t}\n\tfor (ut32 i = 0; i < dex->type_ids_size; ++i) {\n\t\tread_le32_or_fail(buf, dex->types[i], dex_parse_bad);\n\t}\n\n\t/* Proto Ids */\n\toffset = dex->proto_ids_offset;\n\tif (!rz_pvector_reserve(dex->proto_ids, dex->proto_ids_size)) {\n\t\tgoto dex_parse_bad;\n\t}\n\tfor (ut32 i = 0; i < dex->proto_ids_size; ++i, offset += DEX_PROTO_ID_SIZE) {\n\t\tif (rz_buf_seek(buf, offset, RZ_BUF_SET) < 0) {\n\t\t\tgoto dex_parse_bad;\n\t\t}\n\t\tDexProtoId *proto_id = dex_proto_id_new(buf, base + offset);\n\t\tif (!proto_id) {\n\t\t\tgoto dex_parse_bad;\n\t\t}\n\t\trz_pvector_push(dex->proto_ids, proto_id);\n\t}\n\n\t/* Field Ids */\n\toffset = dex->field_ids_offset;\n\tif (!rz_pvector_reserve(dex->field_ids, dex->field_ids_size)) {\n\t\tgoto dex_parse_bad;\n\t}\n\tfor (ut32 i = 0; i < dex->field_ids_size; ++i, offset += DEX_FIELD_ID_SIZE) {\n\t\tif (rz_buf_seek(buf, offset, RZ_BUF_SET) < 0) {\n\t\t\tgoto dex_parse_bad;\n\t\t}\n\t\tDexFieldId *field_id = dex_field_id_new(buf, base + offset);\n\t\tif (!field_id) {\n\t\t\tgoto dex_parse_bad;\n\t\t}\n\t\trz_pvector_push(dex->field_ids, field_id);\n\t}\n\n\t/* Method Ids */\n\toffset = dex->method_ids_offset;\n\tif (!rz_pvector_reserve(dex->method_ids, dex->method_ids_size)) {\n\t\tgoto dex_parse_bad;\n\t}\n\tfor (ut32 i = 0; i < dex->method_ids_size; ++i, offset += DEX_METHOD_ID_SIZE) {\n\t\tif (rz_buf_seek(buf, offset, RZ_BUF_SET) < 0) {\n\t\t\tgoto dex_parse_bad;\n\t\t}\n\t\tDexMethodId *method_id = dex_method_id_new(buf, base + offset);\n\t\tif (!method_id) {\n\t\t\tgoto dex_parse_bad;\n\t\t}\n\t\trz_pvector_push(dex->method_ids, method_id);\n\t}\n\n\t/* Class Defs */\n\toffset = dex->class_defs_offset;\n\tif (!rz_pvector_reserve(dex->class_defs, dex->class_defs_size)) {\n\t\tgoto dex_parse_bad;\n\t}\n\tfor (ut32 i = 0; i < dex->class_defs_size; ++i, offset += DEX_CLASS_DEF_SIZE) {\n\t\tif (rz_buf_seek(buf, offset, RZ_BUF_SET) < 0) {\n\t\t\tgoto dex_parse_bad;\n\t\t}\n\t\tDexClassDef *class_def = dex_class_def_new(buf, base + offset, base, dex->method_ids);\n\t\tif (!class_def) {\n\t\t\tgoto dex_parse_bad;\n\t\t}\n\t\trz_pvector_push(dex->class_defs, class_def);\n\t}\n\n\t/* Resolve all virtual methods */\n\tdex_resolve_all_virtual_methods(dex);\n\n\t/* generate relocation code buffer this buffer will contain a\n\t * sequence of 0e00, i.e 'return-void', which will be used to\n\t * resolve imports for the xrefs.\n\t */\n\tif (!dex_create_relocations(dex)) {\n\t\tgoto dex_parse_bad;\n\t}\n\n\treturn true;\n\ndex_parse_bad:\n\trz_bin_dex_free(dex);\n\treturn false;\n}\n\n/**\n * \\brief Frees a RzBinDex struct\n */\nRZ_API void rz_bin_dex_free(RZ_NULLABLE RzBinDex *dex) {\n\tif (!dex) {\n\t\treturn;\n\t}\n\n\trz_pvector_free(dex->strings);\n\trz_pvector_free(dex->proto_ids);\n\trz_pvector_free(dex->field_ids);\n\trz_pvector_free(dex->method_ids);\n\trz_pvector_free(dex->class_defs);\n\trz_buf_free(dex->relocs_buffer);\n\n\tfree(dex->types);\n\tfree(dex->relocs_code);\n\tfree(dex);\n}\n\n/**\n * \\brief Parses the dex file and returns a RzBinDex struct\n */\nRZ_API RZ_OWN RzBinDex *rz_bin_dex_new(RZ_NONNULL RzBuffer *buf, ut64 base, RZ_NONNULL Sdb *kv) {\n\trz_return_val_if_fail(buf, NULL);\n\n\tRzBinDex *dex = (RzBinDex *)RZ_NEW0(RzBinDex);\n\tif (!dex) {\n\t\treturn NULL;\n\t}\n\n\tdex->strings = rz_pvector_new((RzPVectorFree)dex_string_free);\n\tif (!dex->strings) {\n\t\trz_bin_dex_free(dex);\n\t\treturn NULL;\n\t}\n\tdex->proto_ids = rz_pvector_new((RzPVectorFree)dex_proto_id_free);\n\tif (!dex->proto_ids) {\n\t\trz_bin_dex_free(dex);\n\t\treturn NULL;\n\t}\n\tdex->field_ids = rz_pvector_new((RzPVectorFree)dex_field_id_free);\n\tif (!dex->field_ids) {\n\t\trz_bin_dex_free(dex);\n\t\treturn NULL;\n\t}\n\tdex->method_ids = rz_pvector_new((RzPVectorFree)dex_method_id_free);\n\tif (!dex->method_ids) {\n\t\trz_bin_dex_free(dex);\n\t\treturn NULL;\n\t}\n\tdex->class_defs = rz_pvector_new((RzPVectorFree)dex_class_def_free);\n\tif (!dex->class_defs) {\n\t\trz_bin_dex_free(dex);\n\t\treturn NULL;\n\t}\n\n\tif (!dex_parse(dex, base, buf)) {\n\t\treturn NULL;\n\t}\n\n\treturn dex;\n}\n\nRZ_API RZ_OWN char *rz_bin_dex_access_flags_readable(ut32 access_flags) {\n\tRzStrBuf *sb = NULL;\n\tfor (ut32 i = 0; i < CLASS_ACCESS_FLAGS_SIZE; ++i) {\n\t\tconst DexAccessFlagsReadable *afr = &access_flags_list[i];\n\t\tif (afr->flag == ACCESS_FLAG_VARARGS) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (access_flags & afr->flag) {\n\t\t\tif (!sb) {\n\t\t\t\tsb = rz_strbuf_new(afr->readable);\n\t\t\t\tif (!sb) {\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trz_strbuf_appendf(sb, \" %s\", afr->readable);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sb ? rz_strbuf_drain(sb) : NULL;\n}\n\n/**\n * \\brief Returns a RzList<RzBinString*> containing the dex strings\n */\nRZ_API RZ_OWN RzList /*<RzBinString *>*/ *rz_bin_dex_strings(RZ_NONNULL RzBinDex *dex) {\n\trz_return_val_if_fail(dex, NULL);\n\n\tDexString *string;\n\tvoid **it;\n\tRzList *strings = rz_list_newf(rz_bin_string_free);\n\tif (!strings) {\n\t\treturn NULL;\n\t}\n\n\tut32 ordinal = 0;\n\trz_pvector_foreach (dex->strings, it) {\n\t\tstring = (DexString *)*it;\n\t\tRzBinString *bstr = RZ_NEW0(RzBinString);\n\t\tif (!bstr) {\n\t\t\tcontinue;\n\t\t}\n\t\tbstr->paddr = string->offset;\n\t\tbstr->vaddr = RZ_DEX_VIRT_ADDRESS + string->offset;\n\t\tbstr->ordinal = ordinal;\n\t\tbstr->length = string->size;\n\t\tbstr->size = string->size;\n\t\tbstr->string = rz_str_ndup(string->data, string->size);\n\t\tbstr->type = RZ_STRING_ENC_UTF8;\n\t\tif (!rz_list_append(strings, bstr)) {\n\t\t\tfree(bstr);\n\t\t}\n\t\tordinal++;\n\t}\n\treturn strings;\n}\n\nstatic inline DexString *dex_resolve_string_id_native(RzBinDex *dex, ut32 string_idx) {\n\tif (string_idx >= rz_pvector_len(dex->strings)) {\n\t\treturn NULL;\n\t}\n\treturn (DexString *)rz_pvector_at(dex->strings, string_idx);\n}\n\nstatic char *dex_resolve_string_id(RzBinDex *dex, ut32 string_idx) {\n\tDexString *string = dex_resolve_string_id_native(dex, string_idx);\n\tif (!string) {\n\t\tRZ_LOG_INFO(\"cannot find string with index %u\\n\", string_idx);\n\t\treturn NULL;\n\t}\n\treturn rz_str_ndup(string->data, string->size);\n}\n\nstatic char *dex_resolve_type_id(RzBinDex *dex, ut32 type_idx) {\n\tif (type_idx >= dex->type_ids_size) {\n\t\tRZ_LOG_INFO(\"cannot find type_id with index %u\\n\", type_idx);\n\t\treturn NULL;\n\t}\n\tDexTypeId type_id = dex->types[type_idx];\n\treturn dex_resolve_string_id(dex, type_id);\n}\n\nstatic char *dex_resolve_proto_id(RzBinDex *dex, const char *name, ut32 proto_idx, bool varargs) {\n\tif (proto_idx >= rz_pvector_len(dex->proto_ids)) {\n\t\tRZ_LOG_INFO(\"cannot find proto_id with index %u\\n\", proto_idx);\n\t\treturn NULL;\n\t}\n\n\tDexProtoId *proto_id = (DexProtoId *)rz_pvector_at(dex->proto_ids, proto_idx);\n\tif (proto_id->return_type_idx >= dex->type_ids_size) {\n\t\tRZ_LOG_INFO(\"cannot find return type id with index %u\\n\", proto_id->return_type_idx);\n\t\treturn NULL;\n\t}\n\n\tRzStrBuf *sb = rz_strbuf_new(name);\n\tif (!sb) {\n\t\treturn NULL;\n\t}\n\n\tconst DexString *return_type = dex_resolve_string_id_native(dex, dex->types[proto_id->return_type_idx]);\n\tif (!return_type) {\n\t\tRZ_LOG_INFO(\"cannot find return type string with index %u\\n\", proto_id->return_type_idx);\n\t\trz_strbuf_free(sb);\n\t\treturn NULL;\n\t}\n\n\trz_strbuf_append(sb, \"(\");\n\tfor (ut32 i = 0; i < proto_id->type_list_size; ++i) {\n\t\tut32 type_idx = proto_id->type_list[i];\n\t\tif (type_idx >= dex->type_ids_size) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst DexString *param = dex_resolve_string_id_native(dex, dex->types[type_idx]);\n\t\tif (!param) {\n\t\t\tRZ_LOG_INFO(\"cannot find param string with index %d\\n\", dex->types[type_idx]);\n\t\t\trz_strbuf_free(sb);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (varargs && (i + 1) >= proto_id->type_list_size) {\n\t\t\trz_strbuf_append(sb, \"...\");\n\t\t}\n\t\trz_strbuf_append_n(sb, param->data, param->size);\n\t}\n\trz_strbuf_append(sb, \")\");\n\trz_strbuf_append_n(sb, return_type->data, return_type->size);\n\treturn rz_strbuf_drain(sb);\n}\n\nstatic ut64 dex_access_flags_to_bin_flags(ut64 access_flags) {\n\tut64 flags = 0;\n\tif (access_flags & ACCESS_FLAG_PUBLIC) {\n\t\tflags |= RZ_BIN_METH_PUBLIC;\n\t}\n\tif (access_flags & ACCESS_FLAG_PRIVATE) {\n\t\tflags |= RZ_BIN_METH_PRIVATE;\n\t}\n\tif (access_flags & ACCESS_FLAG_PROTECTED) {\n\t\tflags |= RZ_BIN_METH_PROTECTED;\n\t}\n\tif (access_flags & ACCESS_FLAG_STATIC) {\n\t\tflags |= RZ_BIN_METH_STATIC;\n\t}\n\tif (access_flags & ACCESS_FLAG_FINAL) {\n\t\tflags |= RZ_BIN_METH_FINAL;\n\t}\n\tif (access_flags & ACCESS_FLAG_SYNCHRONIZED) {\n\t\tflags |= RZ_BIN_METH_SYNCHRONIZED;\n\t}\n\tif (access_flags & ACCESS_FLAG_BRIDGE) {\n\t\tflags |= RZ_BIN_METH_BRIDGE;\n\t}\n\tif (access_flags & ACCESS_FLAG_VARARGS) {\n\t\tflags |= RZ_BIN_METH_VARARGS;\n\t}\n\tif (access_flags & ACCESS_FLAG_NATIVE) {\n\t\tflags |= RZ_BIN_METH_NATIVE;\n\t}\n\t// RZ_BIN_METH_INTERFACE does not exists\n\t// if (access_flags & ACCESS_FLAG_INTERFACE) {\n\t//\tflags |= RZ_BIN_METH_INTERFACE;\n\t//}\n\tif (access_flags & ACCESS_FLAG_ABSTRACT) {\n\t\tflags |= RZ_BIN_METH_ABSTRACT;\n\t}\n\tif (access_flags & ACCESS_FLAG_STRICT) {\n\t\tflags |= RZ_BIN_METH_STRICT;\n\t}\n\tif (access_flags & ACCESS_FLAG_SYNTHETIC) {\n\t\tflags |= RZ_BIN_METH_SYNTHETIC;\n\t}\n\t// RZ_BIN_METH_ANNOTATION does not exists\n\t// if (access_flags & ACCESS_FLAG_ANNOTATION) {\n\t//\tflags |= RZ_BIN_METH_ANNOTATION;\n\t//}\n\t// RZ_BIN_METH_ENUM does not exists\n\t// if (access_flags & ACCESS_FLAG_ENUM) {\n\t//\tflags |= RZ_BIN_METH_ENUM;\n\t//}\n\t// RZ_BIN_METH_MODULE does not exists\n\t// if (access_flags & ACCESS_FLAG_MODULE) {\n\t//\tflags |= RZ_BIN_METH_MODULE;\n\t//}\n\tif (access_flags & ACCESS_FLAG_CONSTRUCTOR) {\n\t\tflags |= RZ_BIN_METH_CONSTRUCTOR;\n\t}\n\tif (access_flags & ACCESS_FLAG_DECLARED_SYNCHRONIZED) {\n\t\tflags |= RZ_BIN_METH_DECLARED_SYNCHRONIZED;\n\t}\n\treturn flags;\n}\n\nstatic char *dex_resolve_library(const char *library) {\n\tif (!library || library[0] != 'L') {\n\t\treturn NULL;\n\t}\n\tchar *demangled = strdup(library + 1);\n\trz_str_replace_ch(demangled, '/', '.', 1);\n\tif (RZ_STR_ISNOTEMPTY(demangled)) {\n\t\tdemangled[strlen(demangled) - 1] = 0;\n\t}\n\treturn demangled;\n}\n\nstatic RzBinSymbol *dex_method_to_symbol(RzBinDex *dex, DexEncodedMethod *encoded_method, DexMethodId *method_id, bool is_imported) {\n\tRzBinSymbol *symbol = RZ_NEW0(RzBinSymbol);\n\tif (!symbol) {\n\t\treturn NULL;\n\t}\n\n\tbool varargs = dex_is_varargs(encoded_method->access_flags);\n\tsymbol->name = dex_resolve_string_id(dex, method_id->name_idx);\n\tsymbol->classname = dex_resolve_type_id(dex, method_id->class_idx);\n\tsymbol->libname = dex_resolve_library(symbol->classname);\n\tsymbol->dname = dex_resolve_proto_id(dex, symbol->name, method_id->proto_idx, varargs);\n\tsymbol->bind = dex_is_static(encoded_method->access_flags) ? RZ_BIN_BIND_GLOBAL_STR : RZ_BIN_BIND_LOCAL_STR;\n\tsymbol->is_imported = is_imported;\n\tsymbol->visibility = encoded_method->access_flags & UT32_MAX;\n\tsymbol->visibility_str = rz_bin_dex_access_flags_readable(symbol->visibility);\n\tsymbol->size = encoded_method->code_size;\n\tif (encoded_method->code_offset < RZ_DEX_RELOC_ADDRESS) {\n\t\tsymbol->vaddr = RZ_DEX_VIRT_ADDRESS + encoded_method->code_offset;\n\t\tsymbol->paddr = encoded_method->code_offset;\n\t} else {\n\t\tsymbol->vaddr = encoded_method->code_offset;\n\t\tsymbol->paddr = 0;\n\t}\n\tsymbol->ordinal = encoded_method->method_idx;\n\tsymbol->method_flags = dex_access_flags_to_bin_flags(encoded_method->access_flags);\n\tsymbol->type = RZ_BIN_TYPE_METH_STR;\n\n\treturn symbol;\n}\n\nstatic RzList /*<RzBinSymbol *>*/ *dex_resolve_methods_in_class(RzBinDex *dex, DexClassDef *class_def, ut8 *inserted) {\n\tRzList *methods = rz_list_newf((RzListFree)rz_bin_symbol_free);\n\tif (!methods) {\n\t\treturn NULL;\n\t}\n\n\tDexMethodId *method_id = NULL;\n\tDexEncodedMethod *encoded_method = NULL;\n\tRzListIter *it = NULL;\n\n\trz_list_foreach (class_def->direct_methods, it, encoded_method) {\n\t\tif (encoded_method->method_idx >= rz_pvector_len(dex->method_ids)) {\n\t\t\tRZ_LOG_INFO(\"cannot find direct method with index %\" PFMT64u \"\\n\", encoded_method->method_idx);\n\t\t\tcontinue;\n\t\t} else if (inserted[encoded_method->method_idx]) {\n\t\t\tcontinue;\n\t\t}\n\t\tmethod_id = (DexMethodId *)rz_pvector_at(dex->method_ids, encoded_method->method_idx);\n\t\tinserted[encoded_method->method_idx] = true;\n\n\t\tRzBinSymbol *symbol = dex_method_to_symbol(dex, encoded_method, method_id, false);\n\t\tif (!symbol || !rz_list_append(methods, symbol)) {\n\t\t\trz_bin_symbol_free(symbol);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trz_list_foreach (class_def->virtual_methods, it, encoded_method) {\n\t\tif (encoded_method->method_idx >= rz_pvector_len(dex->method_ids)) {\n\t\t\tRZ_LOG_INFO(\"cannot find virtual method with index %\" PFMT64u \"\\n\", encoded_method->method_idx);\n\t\t\tcontinue;\n\t\t} else if (inserted[encoded_method->method_idx]) {\n\t\t\tcontinue;\n\t\t}\n\t\tmethod_id = (DexMethodId *)rz_pvector_at(dex->method_ids, encoded_method->method_idx);\n\t\tinserted[encoded_method->method_idx] = true;\n\n\t\tRzBinSymbol *symbol = dex_method_to_symbol(dex, encoded_method, method_id, false);\n\t\tif (!symbol || !rz_list_append(methods, symbol)) {\n\t\t\trz_bin_symbol_free(symbol);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn methods;\n}\n\nstatic RzBinField *dex_field_to_bin_field(RzBinDex *dex, DexEncodedField *encoded_field, DexFieldId *field_id, bool is_static) {\n\tRzBinField *field = RZ_NEW0(RzBinField);\n\tif (!field) {\n\t\treturn NULL;\n\t}\n\n\tut64 access_flags = encoded_field->access_flags;\n\tif (is_static) {\n\t\taccess_flags |= ACCESS_FLAG_STATIC;\n\t}\n\n\tfield->vaddr = RZ_DEX_VIRT_ADDRESS + encoded_field->offset;\n\tfield->paddr = encoded_field->offset;\n\tfield->visibility = encoded_field->access_flags & UT32_MAX;\n\tfield->visibility_str = rz_bin_dex_access_flags_readable(access_flags);\n\tfield->name = dex_resolve_string_id(dex, field_id->name_idx);\n\tfield->type = dex_resolve_type_id(dex, field_id->type_idx);\n\tfield->flags = dex_access_flags_to_bin_flags(access_flags);\n\n\treturn field;\n}\n\nstatic RzList /*<RzBinField *>*/ *dex_resolve_fields_in_class(RzBinDex *dex, DexClassDef *class_def, ut8 *inserted) {\n\tRzList *fields = rz_list_newf((RzListFree)rz_bin_field_free);\n\tif (!fields) {\n\t\treturn NULL;\n\t}\n\tDexFieldId *field_id = NULL;\n\tDexEncodedField *encoded_field = NULL;\n\tRzListIter *it = NULL;\n\n\trz_list_foreach (class_def->static_fields, it, encoded_field) {\n\t\tif (encoded_field->field_idx >= rz_pvector_len(dex->field_ids)) {\n\t\t\tRZ_LOG_INFO(\"cannot find static field with index %\" PFMT64u \"\\n\", encoded_field->field_idx);\n\t\t\tcontinue;\n\t\t} else if (inserted[encoded_field->field_idx]) {\n\t\t\tcontinue;\n\t\t}\n\t\tinserted[encoded_field->field_idx] = true;\n\t\tfield_id = (DexFieldId *)rz_pvector_at(dex->field_ids, encoded_field->field_idx);\n\n\t\tRzBinField *field = dex_field_to_bin_field(dex, encoded_field, field_id, true);\n\t\tif (!field || !rz_list_append(fields, field)) {\n\t\t\trz_bin_field_free(field);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trz_list_foreach (class_def->instance_fields, it, encoded_field) {\n\t\tif (encoded_field->field_idx >= rz_pvector_len(dex->field_ids)) {\n\t\t\tRZ_LOG_INFO(\"cannot find instance field with index %\" PFMT64u \"\\n\", encoded_field->field_idx);\n\t\t\tcontinue;\n\t\t} else if (inserted[encoded_field->field_idx]) {\n\t\t\tcontinue;\n\t\t}\n\t\tinserted[encoded_field->field_idx] = true;\n\t\tfield_id = (DexFieldId *)rz_pvector_at(dex->field_ids, encoded_field->field_idx);\n\n\t\tRzBinField *field = dex_field_to_bin_field(dex, encoded_field, field_id, false);\n\t\tif (!field || !rz_list_append(fields, field)) {\n\t\t\trz_bin_field_free(field);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn fields;\n}\n\nstatic RzBinSymbol *dex_field_to_symbol(RzBinDex *dex, DexEncodedField *encoded_field, DexFieldId *field_id, bool is_imported) {\n\tRzBinSymbol *field = RZ_NEW0(RzBinSymbol);\n\tif (!field) {\n\t\treturn NULL;\n\t}\n\n\tfield->name = dex_resolve_string_id(dex, field_id->name_idx);\n\tfield->classname = dex_resolve_type_id(dex, field_id->class_idx);\n\tfield->libname = dex_resolve_library(field->classname);\n\tfield->bind = dex_is_static(encoded_field->access_flags) ? RZ_BIN_BIND_GLOBAL_STR : RZ_BIN_BIND_LOCAL_STR;\n\tfield->is_imported = false;\n\tfield->visibility = encoded_field->access_flags & UT32_MAX;\n\tfield->visibility_str = rz_bin_dex_access_flags_readable(encoded_field->access_flags);\n\tfield->vaddr = RZ_DEX_VIRT_ADDRESS + encoded_field->offset;\n\tfield->paddr = encoded_field->offset;\n\tfield->ordinal = encoded_field->field_idx;\n\tfield->method_flags = dex_access_flags_to_bin_flags(encoded_field->access_flags);\n\tfield->type = RZ_BIN_TYPE_FIELD_STR;\n\n\treturn field;\n}\n\nstatic RzList /*<RzBinSymbol *>*/ *dex_resolve_fields_in_class_as_symbols(RzBinDex *dex, DexClassDef *class_def, ut8 *inserted) {\n\tRzList *fields = rz_list_newf((RzListFree)rz_bin_symbol_free);\n\tif (!fields) {\n\t\treturn NULL;\n\t}\n\tDexFieldId *field_id = NULL;\n\tDexEncodedField *encoded_field = NULL;\n\tRzListIter *it = NULL;\n\n\trz_list_foreach (class_def->static_fields, it, encoded_field) {\n\t\tif (encoded_field->field_idx >= rz_pvector_len(dex->field_ids)) {\n\t\t\tRZ_LOG_INFO(\"cannot find static field with index %\" PFMT64u \"\\n\", encoded_field->field_idx);\n\t\t\tcontinue;\n\t\t}\n\t\tfield_id = (DexFieldId *)rz_pvector_at(dex->field_ids, encoded_field->field_idx);\n\t\tinserted[encoded_field->field_idx] = true;\n\n\t\tRzBinSymbol *field = dex_field_to_symbol(dex, encoded_field, field_id, false);\n\t\tif (!field || !rz_list_append(fields, field)) {\n\t\t\trz_bin_symbol_free(field);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trz_list_foreach (class_def->instance_fields, it, encoded_field) {\n\t\tif (encoded_field->field_idx >= rz_pvector_len(dex->field_ids)) {\n\t\t\tRZ_LOG_INFO(\"cannot find instance field with index %\" PFMT64u \"\\n\", encoded_field->field_idx);\n\t\t\tcontinue;\n\t\t}\n\t\tfield_id = (DexFieldId *)rz_pvector_at(dex->field_ids, encoded_field->field_idx);\n\t\tinserted[encoded_field->field_idx] = true;\n\n\t\tRzBinSymbol *field = dex_field_to_symbol(dex, encoded_field, field_id, false);\n\t\tif (!field || !rz_list_append(fields, field)) {\n\t\t\trz_bin_symbol_free(field);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn fields;\n}\n\nstatic void free_rz_bin_class(RzBinClass *bclass) {\n\tif (!bclass) {\n\t\treturn;\n\t}\n\trz_list_free(bclass->methods);\n\trz_list_free(bclass->fields);\n\tfree(bclass->name);\n\tfree(bclass->super);\n\tfree(bclass->visibility_str);\n\tfree(bclass);\n}\n\n/**\n * \\brief Returns a RzList<RzBinClass*> containing the dex classes\n */\nRZ_API RZ_OWN RzList /*<RzBinClass *>*/ *rz_bin_dex_classes(RZ_NONNULL RzBinDex *dex) {\n\trz_return_val_if_fail(dex, NULL);\n\n\tDexClassDef *class_def;\n\tRzBinClass *bclass = NULL;\n\tRzList *classes = NULL;\n\tvoid **it;\n\n\tut32 n_methods = rz_pvector_len(dex->method_ids);\n\tut32 n_fields = rz_pvector_len(dex->field_ids);\n\n\tut8 *inserted_methods = RZ_NEWS0(ut8, n_methods);\n\tut8 *inserted_fields = RZ_NEWS0(ut8, n_fields);\n\tif ((n_methods > 0 && !inserted_methods) || (n_fields > 0 && !inserted_fields)) {\n\t\tfree(inserted_fields);\n\t\tfree(inserted_methods);\n\t\treturn NULL;\n\t}\n\n\tclasses = rz_list_newf((RzListFree)free_rz_bin_class);\n\tif (!classes) {\n\t\tfree(inserted_fields);\n\t\tfree(inserted_methods);\n\t\treturn NULL;\n\t}\n\n\trz_pvector_foreach (dex->class_defs, it) {\n\t\tclass_def = (DexClassDef *)*it;\n\t\tbclass = RZ_NEW0(RzBinClass);\n\t\tif (!bclass) {\n\t\t\tbreak;\n\t\t}\n\n\t\tbclass->name = dex_resolve_type_id(dex, class_def->class_idx);\n\t\tbclass->super = dex_resolve_type_id(dex, class_def->superclass_idx);\n\t\tbclass->visibility = class_def->access_flags;\n\t\tbclass->visibility_str = rz_bin_dex_access_flags_readable(class_def->access_flags);\n\t\tbclass->index = class_def->class_idx;\n\t\tbclass->addr = class_def->offset;\n\t\tbclass->methods = dex_resolve_methods_in_class(dex, class_def, inserted_methods);\n\t\tbclass->fields = dex_resolve_fields_in_class(dex, class_def, inserted_fields);\n\n\t\tif (!rz_list_append(classes, bclass)) {\n\t\t\tfree_rz_bin_class(bclass);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfree(inserted_fields);\n\tfree(inserted_methods);\n\n\treturn classes;\n}\n\nstatic RzBinSection *section_new(const char *name, ut32 perm, ut32 size, ut64 paddr, ut64 vaddr) {\n\tRzBinSection *section = RZ_NEW0(RzBinSection);\n\tif (!section) {\n\t\treturn NULL;\n\t}\n\tsection->name = strdup(name);\n\tsection->paddr = paddr;\n\tsection->vaddr = vaddr;\n\tsection->size = section->vsize = size;\n\tsection->perm = perm;\n\treturn section;\n}\n\n/**\n * \\brief Returns a RzList<RzBinSection*> containing the dex sections\n */\nRZ_API RZ_OWN RzList /*<RzBinSection *>*/ *rz_bin_dex_sections(RZ_NONNULL RzBinDex *dex) {\n\trz_return_val_if_fail(dex, NULL);\n\n\tRzBinSection *section;\n\tRzList *sections = NULL;\n\n\tsections = rz_list_newf((RzListFree)rz_bin_section_free);\n\tif (!sections) {\n\t\treturn NULL;\n\t}\n\tsection = section_new(\"data\", RZ_PERM_RWX, dex->data_size, dex->data_offset, RZ_DEX_VIRT_ADDRESS + dex->data_offset);\n\tif (section && !rz_list_append(sections, section)) {\n\t\trz_bin_section_free(section);\n\t}\n\tsection = section_new(\"file\", RZ_PERM_R, dex->file_size, dex->header_offset, 0);\n\tif (section && !rz_list_append(sections, section)) {\n\t\trz_bin_section_free(section);\n\t}\n\n\tif (dex->relocs_code) {\n\t\tsection = section_new(RZ_DEX_RELOC_TARGETS, RZ_PERM_RWX, dex->relocs_size, 0, dex->relocs_offset);\n\t\tif (section && !rz_list_append(sections, section)) {\n\t\t\trz_bin_section_free(section);\n\t\t}\n\t}\n\n\treturn sections;\n}\n\n/**\n * \\brief Returns a RzList<RzBinField*> containing the dex fields\n */\nRZ_API RZ_OWN RzList /*<RzBinField *>*/ *rz_bin_dex_fields(RZ_NONNULL RzBinDex *dex) {\n\trz_return_val_if_fail(dex, NULL);\n\n\tDexClassDef *class_def;\n\tRzList *fields = NULL;\n\tvoid **it;\n\tut32 n_fields = rz_pvector_len(dex->field_ids);\n\tut8 *inserted = RZ_NEWS0(ut8, n_fields);\n\tif (n_fields > 0 && !inserted) {\n\t\tfree(inserted);\n\t\treturn NULL;\n\t}\n\n\tfields = rz_list_newf((RzListFree)rz_bin_field_free);\n\tif (!fields) {\n\t\tfree(inserted);\n\t\treturn NULL;\n\t}\n\n\trz_pvector_foreach (dex->class_defs, it) {\n\t\tclass_def = (DexClassDef *)*it;\n\t\tRzList *class_fields = dex_resolve_fields_in_class(dex, class_def, inserted);\n\t\tif (class_fields) {\n\t\t\trz_list_join(fields, class_fields);\n\t\t\trz_list_free(class_fields);\n\t\t}\n\t}\n\tfree(inserted);\n\n\treturn fields;\n}\n\n/**\n * \\brief Returns a RzList<RzBinSymbol*> containing the dex symbols\n */\nRZ_API RZ_OWN RzList /*<RzBinSymbol *>*/ *rz_bin_dex_symbols(RZ_NONNULL RzBinDex *dex) {\n\trz_return_val_if_fail(dex, NULL);\n\n\tDexClassDef *class_def;\n\tDexFieldId *field_id;\n\tDexMethodId *method_id;\n\tRzList *class_symbols = NULL;\n\tRzList *symbols = NULL;\n\tvoid **vit;\n\tut8 *inserted_methods = NULL;\n\tut8 *inserted_fields = NULL;\n\tut32 n_methods = rz_pvector_len(dex->method_ids);\n\tut32 n_fields = rz_pvector_len(dex->field_ids);\n\n\tinserted_methods = RZ_NEWS0(ut8, n_methods);\n\tinserted_fields = RZ_NEWS0(ut8, n_fields);\n\tif ((n_methods > 0 && !inserted_methods) || (n_fields > 0 && !inserted_fields)) {\n\t\tfree(inserted_fields);\n\t\tfree(inserted_methods);\n\t\treturn NULL;\n\t}\n\n\tsymbols = rz_list_newf((RzListFree)rz_bin_symbol_free);\n\tif (!symbols) {\n\t\tfree(inserted_fields);\n\t\tfree(inserted_methods);\n\t\treturn NULL;\n\t}\n\n\trz_pvector_foreach (dex->class_defs, vit) {\n\t\tclass_def = (DexClassDef *)*vit;\n\n\t\tclass_symbols = dex_resolve_fields_in_class_as_symbols(dex, class_def, inserted_fields);\n\t\tif (class_symbols) {\n\t\t\trz_list_join(symbols, class_symbols);\n\t\t\trz_list_free(class_symbols);\n\t\t}\n\n\t\tclass_symbols = dex_resolve_methods_in_class(dex, class_def, inserted_methods);\n\t\tif (class_symbols) {\n\t\t\trz_list_join(symbols, class_symbols);\n\t\t\trz_list_free(class_symbols);\n\t\t}\n\t}\n\n\tut32 j = 0;\n\trz_pvector_foreach (dex->field_ids, vit) {\n\t\tfield_id = (DexFieldId *)*vit;\n\t\tif (inserted_fields[j++]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tRzBinSymbol *field = RZ_NEW0(RzBinSymbol);\n\t\tif (!field) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfield->name = dex_resolve_string_id(dex, field_id->name_idx);\n\t\tfield->classname = dex_resolve_type_id(dex, field_id->class_idx);\n\t\tfield->libname = dex_resolve_library(field->classname);\n\t\tfield->bind = RZ_BIN_BIND_WEAK_STR;\n\t\tfield->type = RZ_BIN_TYPE_FIELD_STR;\n\t\tfield->is_imported = true;\n\n\t\tif (!rz_list_append(symbols, field)) {\n\t\t\trz_bin_symbol_free(field);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tj = 0;\n\trz_pvector_foreach (dex->method_ids, vit) {\n\t\tmethod_id = (DexMethodId *)*vit;\n\t\tif (inserted_methods[j++]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tRzBinSymbol *method = RZ_NEW0(RzBinSymbol);\n\t\tif (!method) {\n\t\t\tbreak;\n\t\t}\n\n\t\tmethod->name = dex_resolve_string_id(dex, method_id->name_idx);\n\t\tmethod->classname = dex_resolve_type_id(dex, method_id->class_idx);\n\t\tmethod->libname = dex_resolve_library(method->classname);\n\t\tmethod->dname = dex_resolve_proto_id(dex, method->name, method_id->proto_idx, false);\n\t\tmethod->bind = RZ_BIN_BIND_WEAK_STR;\n\t\tmethod->is_imported = true;\n\t\tmethod->type = RZ_BIN_TYPE_METH_STR;\n\t\tif (method_id->code_offset < RZ_DEX_RELOC_ADDRESS) {\n\t\t\tmethod->vaddr = RZ_DEX_VIRT_ADDRESS + method_id->code_offset;\n\t\t\tmethod->paddr = method_id->code_offset;\n\t\t} else {\n\t\t\tmethod->vaddr = method_id->code_offset;\n\t\t\tmethod->paddr = 0;\n\t\t}\n\t\tmethod->size = method_id->code_size;\n\n\t\tif (!rz_list_append(symbols, method)) {\n\t\t\trz_bin_symbol_free(method);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree(inserted_fields);\n\tfree(inserted_methods);\n\treturn symbols;\n}\n\n/**\n * \\brief Returns a RzList<RzBinImport*> containing the dex imports\n */\nRZ_API RZ_OWN RzList /*<RzBinImport *>*/ *rz_bin_dex_imports(RZ_NONNULL RzBinDex *dex) {\n\trz_return_val_if_fail(dex, NULL);\n\n\tDexFieldId *field_id;\n\tDexMethodId *method_id;\n\tDexClassDef *class_def;\n\tRzList *imports = NULL;\n\tut32 *class_ids = NULL;\n\tvoid **vit;\n\n\tut32 n_classes = rz_pvector_len(dex->class_defs);\n\tif (n_classes < 1) {\n\t\treturn rz_list_newf((RzListFree)rz_bin_import_free);\n\t}\n\n\tclass_ids = RZ_NEWS0(ut32, n_classes);\n\tif (!class_ids) {\n\t\treturn NULL;\n\t}\n\n\tut32 j = 0;\n\trz_pvector_foreach (dex->class_defs, vit) {\n\t\tclass_def = (DexClassDef *)*vit;\n\t\tclass_ids[j] = class_def->class_idx;\n\t\tj++;\n\t}\n\n\timports = rz_list_newf((RzListFree)rz_bin_import_free);\n\tif (!imports) {\n\t\tfree(class_ids);\n\t\treturn NULL;\n\t}\n\n\tut32 ordinal = 0;\n\trz_pvector_foreach (dex->field_ids, vit) {\n\t\tfield_id = (DexFieldId *)*vit;\n\t\tbool class_found = false;\n\t\tfor (ut32 i = 0; i < n_classes; ++i) {\n\t\t\tif (field_id->class_idx == class_ids[i]) {\n\t\t\t\tclass_found = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (class_found) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tRzBinImport *import = RZ_NEW0(RzBinImport);\n\t\tif (!import) {\n\t\t\tbreak;\n\t\t}\n\n\t\tchar *object = dex_resolve_type_id(dex, field_id->class_idx);\n\t\tif (RZ_STR_ISEMPTY(object)) {\n\t\t\tfree(object);\n\t\t\tfree(import);\n\t\t\tbreak;\n\t\t}\n\t\trz_str_replace_char(object, ';', 0);\n\n\t\tchar *class_name = (char *)rz_str_rchr(object, NULL, '/');\n\t\tif (class_name) {\n\t\t\tclass_name[0] = 0;\n\t\t\tclass_name++;\n\t\t}\n\t\trz_str_replace_ch(object, '/', '.', 1);\n\n\t\timport->name = dex_resolve_string_id(dex, field_id->name_idx);\n\t\timport->libname = class_name ? strdup(object + 1) : NULL;\n\t\timport->classname = strdup(class_name ? class_name : object + 1);\n\t\timport->bind = RZ_BIN_BIND_WEAK_STR;\n\t\timport->type = RZ_BIN_TYPE_FIELD_STR;\n\t\timport->ordinal = ordinal;\n\t\tfree(object);\n\n\t\tif (!rz_list_append(imports, import)) {\n\t\t\trz_bin_import_free(import);\n\t\t\tbreak;\n\t\t}\n\t\tordinal++;\n\t}\n\n\trz_pvector_foreach (dex->method_ids, vit) {\n\t\tmethod_id = (DexMethodId *)*vit;\n\t\tbool class_found = false;\n\t\tfor (ut32 i = 0; i < n_classes; ++i) {\n\t\t\tif (method_id->class_idx == class_ids[i]) {\n\t\t\t\tclass_found = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (class_found) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tRzBinImport *import = RZ_NEW0(RzBinImport);\n\t\tif (!import) {\n\t\t\tbreak;\n\t\t}\n\n\t\tchar *object = dex_resolve_type_id(dex, method_id->class_idx);\n\t\tif (RZ_STR_ISEMPTY(object)) {\n\t\t\tfree(object);\n\t\t\trz_bin_import_free(import);\n\t\t\tbreak;\n\t\t}\n\t\trz_str_replace_char(object, ';', 0);\n\n\t\tchar *class_name = (char *)rz_str_rchr(object, NULL, '/');\n\t\tif (class_name) {\n\t\t\tclass_name[0] = 0;\n\t\t\tclass_name++;\n\t\t}\n\t\trz_str_replace_ch(object, '/', '.', 1);\n\n\t\tchar *name = dex_resolve_string_id(dex, method_id->name_idx);\n\t\timport->name = dex_resolve_proto_id(dex, name, method_id->proto_idx, false);\n\t\timport->libname = class_name ? strdup(object + 1) : NULL;\n\t\timport->classname = strdup(class_name ? class_name : object + 1);\n\t\timport->bind = RZ_BIN_BIND_WEAK_STR;\n\t\timport->type = RZ_BIN_TYPE_FUNC_STR;\n\t\timport->ordinal = ordinal;\n\t\tfree(name);\n\t\tfree(object);\n\n\t\tif (!rz_list_append(imports, import)) {\n\t\t\trz_bin_import_free(import);\n\t\t\tbreak;\n\t\t}\n\t\tordinal++;\n\t}\n\n\tfree(class_ids);\n\treturn imports;\n}\n\nstatic int compare_strings(const void *a, const void *b) {\n\treturn strcmp((const char *)a, (const char *)b);\n}\n\n/**\n * \\brief Returns a RzList<char*> containing the dex libraries\n */\nRZ_API RZ_OWN RzList /*<char *>*/ *rz_bin_dex_libraries(RZ_NONNULL RzBinDex *dex) {\n\trz_return_val_if_fail(dex, NULL);\n\n\tDexMethodId *method_id;\n\tDexClassDef *class_def;\n\tRzList *libraries = NULL;\n\tut32 *class_ids = NULL;\n\tvoid **vit;\n\n\tut32 n_classes = rz_pvector_len(dex->class_defs);\n\tif (n_classes < 1) {\n\t\treturn rz_list_newf((RzListFree)free);\n\t}\n\n\tclass_ids = RZ_NEWS0(ut32, n_classes);\n\tif (!class_ids) {\n\t\treturn NULL;\n\t}\n\n\tut32 j = 0;\n\trz_pvector_foreach (dex->class_defs, vit) {\n\t\tclass_def = (DexClassDef *)*vit;\n\t\tclass_ids[j] = class_def->class_idx;\n\t\tj++;\n\t}\n\n\tlibraries = rz_list_newf((RzListFree)free);\n\tif (!libraries) {\n\t\tfree(class_ids);\n\t\treturn NULL;\n\t}\n\n\trz_pvector_foreach (dex->method_ids, vit) {\n\t\tmethod_id = (DexMethodId *)*vit;\n\t\tbool class_found = false;\n\t\tfor (ut32 i = 0; i < n_classes; ++i) {\n\t\t\tif (method_id->class_idx == class_ids[i]) {\n\t\t\t\tclass_found = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (class_found) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tchar *object = dex_resolve_type_id(dex, method_id->class_idx);\n\t\tif (RZ_STR_ISEMPTY(object) || *object != 'L' || !strncmp(object, \"Ljava/\", strlen(\"Ljava/\"))) {\n\t\t\tfree(object);\n\t\t\tcontinue;\n\t\t}\n\n\t\tchar *p = object;\n\t\tif ((p = strchr(p, '/')) && (p = strchr(p + 1, '/'))) {\n\t\t\t*p = 0;\n\t\t\tp = rz_str_newf(\"%s/*;\", object);\n\t\t\tfree(object);\n\t\t\tobject = p;\n\t\t}\n\n\t\tif (rz_list_find(libraries, object, compare_strings)) {\n\t\t\tfree(object);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!rz_list_append(libraries, object)) {\n\t\t\tfree(object);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfree(class_ids);\n\treturn libraries;\n}\n\nstatic bool dex_resolve_symbol_in_class_methods(RzBinDex *dex, DexClassDef *class_def, RzBinSpecialSymbol resolve, ut64 *paddr, ut64 *vaddr) {\n\tRzListIter *it;\n\tDexEncodedMethod *encoded_method = NULL;\n\n\trz_list_foreach (class_def->direct_methods, it, encoded_method) {\n\t\tif (encoded_method->method_idx >= rz_pvector_len(dex->method_ids)) {\n\t\t\tRZ_LOG_INFO(\"cannot find virtual method with index %\" PFMT64u \"\\n\", encoded_method->method_idx);\n\t\t\tcontinue;\n\t\t}\n\t\tDexMethodId *method_id = (DexMethodId *)rz_pvector_at(dex->method_ids, encoded_method->method_idx);\n\n\t\tchar *name = dex_resolve_string_id(dex, method_id->name_idx);\n\t\tif (!name) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (resolve == RZ_BIN_SPECIAL_SYMBOL_ENTRY || resolve == RZ_BIN_SPECIAL_SYMBOL_INIT) {\n\t\t\tif (strcmp(name, \"<init>\") != 0 && strcmp(name, \"<clinit>\") != 0) {\n\t\t\t\tfree(name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if (resolve == RZ_BIN_SPECIAL_SYMBOL_MAIN) {\n\t\t\tif (strcmp(name, \"main\") != 0) {\n\t\t\t\tfree(name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tfree(name);\n\t\tif (method_id->code_offset < RZ_DEX_RELOC_ADDRESS) {\n\t\t\t*vaddr = RZ_DEX_VIRT_ADDRESS + encoded_method->code_offset;\n\t\t\t*paddr = method_id->code_offset;\n\t\t} else {\n\t\t\t*vaddr = encoded_method->code_offset;\n\t\t\t*paddr = 0;\n\t\t}\n\t\treturn true;\n\t}\n\n\trz_list_foreach (class_def->virtual_methods, it, encoded_method) {\n\t\tif (encoded_method->method_idx >= rz_pvector_len(dex->method_ids)) {\n\t\t\tRZ_LOG_INFO(\"cannot find direct method with index %\" PFMT64u \"\\n\", encoded_method->method_idx);\n\t\t\tcontinue;\n\t\t}\n\t\tDexMethodId *method_id = (DexMethodId *)rz_pvector_at(dex->method_ids, encoded_method->method_idx);\n\n\t\tchar *name = dex_resolve_string_id(dex, method_id->name_idx);\n\t\tif (!name) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (resolve == RZ_BIN_SPECIAL_SYMBOL_ENTRY || resolve == RZ_BIN_SPECIAL_SYMBOL_INIT) {\n\t\t\tif (strcmp(name, \"<init>\") != 0 && strcmp(name, \"<clinit>\") != 0) {\n\t\t\t\tfree(name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if (resolve == RZ_BIN_SPECIAL_SYMBOL_MAIN) {\n\t\t\tif (strcmp(name, \"main\") != 0) {\n\t\t\t\tfree(name);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tfree(name);\n\n\t\tif (method_id->code_offset < RZ_DEX_RELOC_ADDRESS) {\n\t\t\t*vaddr = RZ_DEX_VIRT_ADDRESS + encoded_method->code_offset;\n\t\t\t*paddr = method_id->code_offset;\n\t\t} else {\n\t\t\t*vaddr = encoded_method->code_offset;\n\t\t\t*paddr = 0;\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/**\n * \\brief Returns a RzBinAddr pointer containing the resolved RzBinSpecialSymbol\n */\nRZ_API RZ_OWN RzBinAddr *rz_bin_dex_resolve_symbol(RZ_NONNULL RzBinDex *dex, RzBinSpecialSymbol resolve) {\n\trz_return_val_if_fail(dex, NULL);\n\n\tDexClassDef *class_def;\n\tvoid **it;\n\n\tRzBinAddr *ret = RZ_NEW0(RzBinAddr);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->paddr = UT64_MAX;\n\tret->vaddr = UT64_MAX;\n\n\trz_pvector_foreach (dex->class_defs, it) {\n\t\tclass_def = (DexClassDef *)*it;\n\t\tif (dex_resolve_symbol_in_class_methods(dex, class_def, resolve, &ret->paddr, &ret->vaddr)) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nstatic RzList /*<RzBinAddr *>*/ *dex_resolve_entrypoints_in_class(RzBinDex *dex, DexClassDef *class_def) {\n\tRzListIter *it;\n\tDexEncodedMethod *encoded_method = NULL;\n\tRzList *entrypoints = NULL;\n\n\tentrypoints = rz_list_newf((RzListFree)free);\n\tif (!entrypoints) {\n\t\treturn NULL;\n\t}\n\n\trz_list_foreach (class_def->direct_methods, it, encoded_method) {\n\t\tif (!dex_is_static(encoded_method->access_flags)) {\n\t\t\t// entrypoints are static\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (encoded_method->method_idx >= rz_pvector_len(dex->method_ids)) {\n\t\t\tRZ_LOG_INFO(\"cannot find direct method with index %\" PFMT64u \"\\n\", encoded_method->method_idx);\n\t\t\tcontinue;\n\t\t}\n\t\tDexMethodId *method_id = (DexMethodId *)rz_pvector_at(dex->method_ids, encoded_method->method_idx);\n\n\t\tchar *name = dex_resolve_string_id(dex, method_id->name_idx);\n\t\tif (!name) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strcmp(name, \"main\") != 0 && strcmp(name, \"<init>\") != 0 && strcmp(name, \"<clinit>\") != 0) {\n\t\t\tfree(name);\n\t\t\tcontinue;\n\t\t}\n\t\tfree(name);\n\n\t\tRzBinAddr *entrypoint = RZ_NEW0(RzBinAddr);\n\t\tif (!entrypoint) {\n\t\t\tbreak;\n\t\t}\n\t\tif (encoded_method->code_offset < RZ_DEX_RELOC_ADDRESS) {\n\t\t\tentrypoint->vaddr = RZ_DEX_VIRT_ADDRESS + encoded_method->code_offset;\n\t\t\tentrypoint->paddr = encoded_method->code_offset;\n\t\t} else {\n\t\t\tentrypoint->vaddr = encoded_method->code_offset;\n\t\t\tentrypoint->paddr = 0;\n\t\t}\n\t\tif (entrypoint && !rz_list_append(entrypoints, entrypoint)) {\n\t\t\tfree(entrypoint);\n\t\t}\n\t}\n\n\trz_list_foreach (class_def->virtual_methods, it, encoded_method) {\n\t\tif (!dex_is_static(encoded_method->access_flags)) {\n\t\t\t// entrypoints are static\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (encoded_method->method_idx >= rz_pvector_len(dex->method_ids)) {\n\t\t\tRZ_LOG_INFO(\"cannot find virtual method with index %\" PFMT64u \"\\n\", encoded_method->method_idx);\n\t\t\tcontinue;\n\t\t}\n\n\t\tDexMethodId *method_id = (DexMethodId *)rz_pvector_at(dex->method_ids, encoded_method->method_idx);\n\t\tif (method_id->code_offset < 1) {\n\t\t\t// if there is no code, skip\n\t\t\tcontinue;\n\t\t}\n\n\t\tchar *name = dex_resolve_string_id(dex, method_id->name_idx);\n\t\tif (!name) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (strcmp(name, \"main\") != 0 && strcmp(name, \"<init>\") != 0 && strcmp(name, \"<clinit>\") != 0) {\n\t\t\tfree(name);\n\t\t\tcontinue;\n\t\t}\n\t\tfree(name);\n\n\t\tRzBinAddr *entrypoint = RZ_NEW0(RzBinAddr);\n\t\tif (!entrypoint) {\n\t\t\tbreak;\n\t\t}\n\t\tif (encoded_method->code_offset < RZ_DEX_RELOC_ADDRESS) {\n\t\t\tentrypoint->vaddr = RZ_DEX_VIRT_ADDRESS + encoded_method->code_offset;\n\t\t\tentrypoint->paddr = encoded_method->code_offset;\n\t\t} else {\n\t\t\tentrypoint->vaddr = encoded_method->code_offset;\n\t\t\tentrypoint->paddr = 0;\n\t\t}\n\t\tif (entrypoint && !rz_list_append(entrypoints, entrypoint)) {\n\t\t\tfree(entrypoint);\n\t\t}\n\t}\n\n\treturn entrypoints;\n}\n\n/**\n * \\brief Returns a RzList<RzBinAddr*> containing the dex entripoints\n */\nRZ_API RZ_OWN RzList /*<RzBinAddr *>*/ *rz_bin_dex_entrypoints(RZ_NONNULL RzBinDex *dex) {\n\trz_return_val_if_fail(dex, NULL);\n\n\tDexClassDef *class_def;\n\tRzList *list = NULL;\n\tRzList *entrypoints = NULL;\n\tvoid **it;\n\n\tentrypoints = rz_list_newf((RzListFree)free);\n\tif (!entrypoints) {\n\t\treturn NULL;\n\t}\n\n\trz_pvector_foreach (dex->class_defs, it) {\n\t\tclass_def = (DexClassDef *)*it;\n\t\tlist = dex_resolve_entrypoints_in_class(dex, class_def);\n\t\tif (list) {\n\t\t\trz_list_join(entrypoints, list);\n\t\t\trz_list_free(list);\n\t\t}\n\t}\n\n\treturn entrypoints;\n}\n\n/**\n * This method will create a buffer filled with return-void values to mapped\n * to the imports and allow the code to generate xrefs pointing to the imports\n */\nRZ_API RZ_BORROW RzBuffer *rz_bin_dex_relocations(RZ_NONNULL RzBinDex *dex) {\n\trz_return_val_if_fail(dex, NULL);\n\treturn dex->relocs_buffer;\n}\n\n/**\n * \\brief Returns the resolved string linked to the given method id\n */\nRZ_API RZ_OWN char *rz_bin_dex_resolve_method_by_idx(RZ_NONNULL RzBinDex *dex, ut32 method_idx) {\n\trz_return_val_if_fail(dex, NULL);\n\n\tif (method_idx >= rz_pvector_len(dex->method_ids)) {\n\t\treturn NULL;\n\t}\n\n\tDexMethodId *method_id = (DexMethodId *)rz_pvector_at(dex->method_ids, method_idx);\n\tchar *name = dex_resolve_string_id(dex, method_id->name_idx);\n\tif (!name) {\n\t\treturn NULL;\n\t}\n\n\tchar *proto = dex_resolve_proto_id(dex, name, method_id->proto_idx, false);\n\tRZ_FREE(name);\n\tif (!proto) {\n\t\treturn NULL;\n\t}\n\n\tname = dex_resolve_type_id(dex, method_id->class_idx);\n\tif (!name) {\n\t\tfree(proto);\n\t\treturn NULL;\n\t}\n\n\tchar *method = rz_str_newf(\"%s->%s\", name, proto);\n\tfree(name);\n\tfree(proto);\n\treturn method;\n}\n\n/**\n * \\brief Returns the resolved string linked to the given field id\n */\nRZ_API RZ_OWN char *rz_bin_dex_resolve_field_by_idx(RZ_NONNULL RzBinDex *dex, ut32 field_idx) {\n\trz_return_val_if_fail(dex, NULL);\n\n\tif (field_idx >= rz_pvector_len(dex->field_ids)) {\n\t\treturn NULL;\n\t}\n\n\tDexFieldId *field_id = (DexFieldId *)rz_pvector_at(dex->field_ids, field_idx);\n\tchar *class_name = dex_resolve_type_id(dex, field_id->class_idx);\n\tif (!class_name) {\n\t\treturn NULL;\n\t}\n\n\tchar *name = dex_resolve_string_id(dex, field_id->name_idx);\n\tif (!name) {\n\t\tfree(class_name);\n\t\treturn NULL;\n\t}\n\n\tchar *type = dex_resolve_type_id(dex, field_id->type_idx);\n\tif (!type) {\n\t\tfree(class_name);\n\t\tfree(name);\n\t\treturn NULL;\n\t}\n\n\tchar *method = rz_str_newf(\"%s->%s %s\", class_name, name, type);\n\n\tfree(type);\n\tfree(class_name);\n\tfree(name);\n\treturn method;\n}\n\n/**\n * \\brief Returns the resolved offset linked to the given string id\n */\nRZ_API ut64 rz_bin_dex_resolve_string_offset_by_idx(RZ_NONNULL RzBinDex *dex, ut32 string_idx) {\n\trz_return_val_if_fail(dex, UT64_MAX);\n\n\tDexString *string = dex_resolve_string_id_native(dex, string_idx);\n\tif (!string) {\n\t\tRZ_LOG_INFO(\"cannot find string with index %u\\n\", string_idx);\n\t\treturn UT64_MAX;\n\t}\n\treturn RZ_DEX_VIRT_ADDRESS + string->offset;\n}\n\n/**\n * \\brief Returns the resolved offset linked to the given type id\n */\nRZ_API ut64 rz_bin_dex_resolve_type_id_offset_by_idx(RZ_NONNULL RzBinDex *dex, ut32 type_idx) {\n\trz_return_val_if_fail(dex, UT64_MAX);\n\n\tif (type_idx >= dex->type_ids_size) {\n\t\tRZ_LOG_INFO(\"cannot find type_id with index %u\\n\", type_idx);\n\t\treturn UT64_MAX;\n\t}\n\tDexTypeId type_id = dex->types[type_idx];\n\treturn rz_bin_dex_resolve_string_offset_by_idx(dex, type_id);\n}\n\n/**\n * \\brief Returns the resolved offset linked to the given method id\n */\nRZ_API ut64 rz_bin_dex_resolve_method_offset_by_idx(RZ_NONNULL RzBinDex *dex, ut32 method_idx) {\n\trz_return_val_if_fail(dex, UT64_MAX);\n\n\tif (method_idx >= rz_pvector_len(dex->method_ids)) {\n\t\tRZ_LOG_INFO(\"cannot find method with index %u\\n\", method_idx);\n\t\treturn UT64_MAX;\n\t}\n\n\tDexMethodId *method = (DexMethodId *)rz_pvector_at(dex->method_ids, method_idx);\n\tif (method->code_offset) {\n\t\tif (method->code_offset < RZ_DEX_RELOC_ADDRESS) {\n\t\t\treturn RZ_DEX_VIRT_ADDRESS + method->code_offset;\n\t\t}\n\t\treturn method->code_offset;\n\t}\n\treturn UT64_MAX;\n}\n\n/**\n * \\brief Returns the resolved string linked to the given type id\n */\nRZ_API RZ_OWN char *rz_bin_dex_resolve_type_id_by_idx(RZ_NONNULL RzBinDex *dex, ut32 type_idx) {\n\trz_return_val_if_fail(dex, NULL);\n\n\tif (type_idx >= dex->type_ids_size) {\n\t\tRZ_LOG_INFO(\"cannot find type_id with index %u\\n\", type_idx);\n\t\treturn NULL;\n\t}\n\tDexTypeId type_id = dex->types[type_idx];\n\treturn rz_bin_dex_resolve_string_by_idx(dex, type_id);\n}\n\n/**\n * \\brief Returns the resolved string linked to the given string id\n */\nRZ_API RZ_OWN char *rz_bin_dex_resolve_string_by_idx(RZ_NONNULL RzBinDex *dex, ut32 string_idx) {\n\trz_return_val_if_fail(dex, NULL);\n\n\treturn dex_resolve_string_id(dex, string_idx);\n}\n\n/**\n * \\brief Returns the resolved string linked to the given class id\n */\nRZ_API RZ_OWN char *rz_bin_dex_resolve_class_by_idx(RZ_NONNULL RzBinDex *dex, ut32 class_idx) {\n\trz_return_val_if_fail(dex, NULL);\n\n\treturn dex_resolve_type_id(dex, class_idx);\n}\n\n/**\n * \\brief Returns the resolved string linked to the given prototype id\n */\nRZ_API RZ_OWN char *rz_bin_dex_resolve_proto_by_idx(RZ_NONNULL RzBinDex *dex, ut32 proto_idx) {\n\trz_return_val_if_fail(dex, NULL);\n\n\treturn dex_resolve_proto_id(dex, \"\", proto_idx, false);\n}\n\n/**\n * \\brief Sets the RzBinHash dex checksum (adler32)\n */\nRZ_API void rz_bin_dex_checksum(RZ_NONNULL RzBinDex *dex, RZ_NONNULL RzBinHash *hash) {\n\trz_return_if_fail(dex && hash);\n\thash->type = \"adler32\";\n\thash->len = sizeof(dex->checksum);\n\thash->addr = dex->checksum_offset;\n\thash->from = dex->checksum_offset + sizeof(dex->checksum);\n\thash->to = dex->file_size - hash->from;\n\trz_write_le32(hash->buf, dex->checksum);\n}\n\n/**\n * \\brief Sets the RzBinHash dex digest (sha1)\n */\nRZ_API void rz_bin_dex_sha1(RZ_NONNULL RzBinDex *dex, RZ_NONNULL RzBinHash *hash) {\n\trz_return_if_fail(dex && hash);\n\thash->type = \"sha1\";\n\thash->len = 20;\n\thash->addr = dex->signature_offset;\n\thash->from = dex->signature_offset + sizeof(dex->signature);\n\thash->to = dex->file_size - hash->from;\n\tmemcpy(hash->buf, dex->signature, sizeof(dex->signature));\n}\n\n/**\n * \\brief Returns the dex version (string format)\n */\nRZ_API RZ_OWN char *rz_bin_dex_version(RZ_NONNULL RzBinDex *dex) {\n\trz_return_val_if_fail(dex, NULL);\n\t// https://cs.android.com/android/platform/superproject/+/master:dalvik/dx/src/com/android/dex/DexFormat.java;l=55;bpv=1;bpt=0\n\t// https://developer.android.com/studio/releases/platforms\n\tif (!strncmp((char *)dex->version, \"009\", 3)) {\n\t\treturn strdup(\"Android M3 release (Nov-Dec 2007)\");\n\t} else if (!strncmp((char *)dex->version, \"013\", 3)) {\n\t\treturn strdup(\"Android M5 release (Feb-Mar 2008)\");\n\t} else if (!strncmp((char *)dex->version, \"035\", 3)) {\n\t\treturn strdup(\"Android 3.2 (API level 13 and earlier)\");\n\t} else if (!strncmp((char *)dex->version, \"037\", 3)) {\n\t\treturn strdup(\"Android 7 (API level 24 and earlier)\");\n\t} else if (!strncmp((char *)dex->version, \"038\", 3)) {\n\t\treturn strdup(\"Android 8 (API level 26 and earlier)\");\n\t} else if (!strncmp((char *)dex->version, \"039\", 3)) {\n\t\treturn strdup(\"Android 9 (API level 28 and earlier)\");\n\t} else if (!strncmp((char *)dex->version, \"040\", 3)) {\n\t\treturn strdup(\"Android 10+ (Aug 2019)\");\n\t}\n\treturn NULL;\n}\n\n/**\n * \\brief Returns the dex debug info RzBin values\n */\nRZ_API ut64 rz_bin_dex_debug_info(RZ_NONNULL RzBinDex *dex) {\n\trz_return_val_if_fail(dex, 0);\n\t// TODO\n\treturn 0;\n}\n"], "filenames": ["librz/bin/format/dex/dex.c"], "buggy_code_start_loc": [83], "buggy_code_end_loc": [909], "fixing_code_start_loc": [84], "fixing_code_end_loc": [915], "type": "CWE-787", "message": "Rizin is a UNIX-like reverse engineering framework and command-line toolset. Versions 0.4.0 and prior are vulnerable to out-of-bounds write when parsing DEX files. A user opening a malicious DEX file could be affected by this vulnerability, allowing an attacker to execute code on the user's machine. A patch is available on the `dev` branch of the repository.", "other": {"cve": {"id": "CVE-2022-36039", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-06T19:15:08.603", "lastModified": "2022-09-27T20:07:54.717", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Rizin is a UNIX-like reverse engineering framework and command-line toolset. Versions 0.4.0 and prior are vulnerable to out-of-bounds write when parsing DEX files. A user opening a malicious DEX file could be affected by this vulnerability, allowing an attacker to execute code on the user's machine. A patch is available on the `dev` branch of the repository."}, {"lang": "es", "value": "Rizin es un marco de trabajo de ingenier\u00eda inversa tipo UNIX y un conjunto de herramientas de l\u00ednea de comandos. Las versiones 0.4.0 y anteriores son vulnerables a una escritura fuera de l\u00edmites cuando analizan archivos DEX. Un usuario que abra un archivo DEX malicioso podr\u00eda verse afectado por esta vulnerabilidad, permitiendo a un atacante ejecutar c\u00f3digo en la m\u00e1quina del usuario. Se presenta un parche disponible en la rama \"dev\" del repositorio.\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rizin:rizin:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.4.0", "matchCriteriaId": "5E797DF4-7DCA-46AA-9A36-5C0064FE79CA"}]}]}], "references": [{"url": "https://github.com/rizinorg/rizin/commit/1524f85211445e41506f98180f8f69f7bf115406", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/rizinorg/rizin/issues/2969", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/rizinorg/rizin/security/advisories/GHSA-pr85-hv85-45pg", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202209-06", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/rizinorg/rizin/commit/1524f85211445e41506f98180f8f69f7bf115406"}}