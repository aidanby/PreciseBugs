{"buggy_code": ["/*\n *   fs/cifs/sess.c\n *\n *   SMB/CIFS session setup handling routines\n *\n *   Copyright (c) International Business Machines  Corp., 2006, 2009\n *   Author(s): Steve French (sfrench@us.ibm.com)\n *\n *   This library is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published\n *   by the Free Software Foundation; either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This library is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See\n *   the GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this library; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n */\n\n#include \"cifspdu.h\"\n#include \"cifsglob.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"ntlmssp.h\"\n#include \"nterr.h\"\n#include <linux/utsname.h>\n#include <linux/slab.h>\n#include \"cifs_spnego.h\"\n\nstatic __u32 cifs_ssetup_hdr(struct cifs_ses *ses, SESSION_SETUP_ANDX *pSMB)\n{\n\t__u32 capabilities = 0;\n\n\t/* init fields common to all four types of SessSetup */\n\t/* Note that offsets for first seven fields in req struct are same  */\n\t/*\tin CIFS Specs so does not matter which of 3 forms of struct */\n\t/*\tthat we use in next few lines                               */\n\t/* Note that header is initialized to zero in header_assemble */\n\tpSMB->req.AndXCommand = 0xFF;\n\tpSMB->req.MaxBufferSize = cpu_to_le16(min_t(u32,\n\t\t\t\t\tCIFSMaxBufSize + MAX_CIFS_HDR_SIZE - 4,\n\t\t\t\t\tUSHRT_MAX));\n\tpSMB->req.MaxMpxCount = cpu_to_le16(ses->server->maxReq);\n\tpSMB->req.VcNumber = cpu_to_le16(1);\n\n\t/* Now no need to set SMBFLG_CASELESS or obsolete CANONICAL PATH */\n\n\t/* BB verify whether signing required on neg or just on auth frame\n\t   (and NTLM case) */\n\n\tcapabilities = CAP_LARGE_FILES | CAP_NT_SMBS | CAP_LEVEL_II_OPLOCKS |\n\t\t\tCAP_LARGE_WRITE_X | CAP_LARGE_READ_X;\n\n\tif (ses->server->sign)\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_UNICODE;\n\t\tcapabilities |= CAP_UNICODE;\n\t}\n\tif (ses->capabilities & CAP_STATUS32) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_ERR_STATUS;\n\t\tcapabilities |= CAP_STATUS32;\n\t}\n\tif (ses->capabilities & CAP_DFS) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_DFS;\n\t\tcapabilities |= CAP_DFS;\n\t}\n\tif (ses->capabilities & CAP_UNIX)\n\t\tcapabilities |= CAP_UNIX;\n\n\treturn capabilities;\n}\n\nstatic void\nunicode_oslm_strings(char **pbcc_area, const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\tint bytes_ret = 0;\n\n\t/* Copy OS version */\n\tbytes_ret = cifs_strtoUTF16((__le16 *)bcc_ptr, \"Linux version \", 32,\n\t\t\t\t    nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, init_utsname()->release,\n\t\t\t\t    32, nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2; /* trailing null */\n\n\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, CIFS_NETWORK_OPSYS,\n\t\t\t\t    32, nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2; /* trailing null */\n\n\t*pbcc_area = bcc_ptr;\n}\n\nstatic void unicode_domain_string(char **pbcc_area, struct cifs_ses *ses,\n\t\t\t\t   const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\tint bytes_ret = 0;\n\n\t/* copy domain */\n\tif (ses->domainName == NULL) {\n\t\t/* Sending null domain better than using a bogus domain name (as\n\t\twe did briefly in 2.6.18) since server will use its default */\n\t\t*bcc_ptr = 0;\n\t\t*(bcc_ptr+1) = 0;\n\t\tbytes_ret = 0;\n\t} else\n\t\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, ses->domainName,\n\t\t\t\t\t    CIFS_MAX_DOMAINNAME_LEN, nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2;  /* account for null terminator */\n\n\t*pbcc_area = bcc_ptr;\n}\n\n\nstatic void unicode_ssetup_strings(char **pbcc_area, struct cifs_ses *ses,\n\t\t\t\t   const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\tint bytes_ret = 0;\n\n\t/* BB FIXME add check that strings total less\n\tthan 335 or will need to send them as arrays */\n\n\t/* unicode strings, must be word aligned before the call */\n/*\tif ((long) bcc_ptr % 2)\t{\n\t\t*bcc_ptr = 0;\n\t\tbcc_ptr++;\n\t} */\n\t/* copy user */\n\tif (ses->user_name == NULL) {\n\t\t/* null user mount */\n\t\t*bcc_ptr = 0;\n\t\t*(bcc_ptr+1) = 0;\n\t} else {\n\t\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, ses->user_name,\n\t\t\t\t\t    CIFS_MAX_USERNAME_LEN, nls_cp);\n\t}\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2; /* account for null termination */\n\n\tunicode_domain_string(&bcc_ptr, ses, nls_cp);\n\tunicode_oslm_strings(&bcc_ptr, nls_cp);\n\n\t*pbcc_area = bcc_ptr;\n}\n\nstatic void ascii_ssetup_strings(char **pbcc_area, struct cifs_ses *ses,\n\t\t\t\t const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\n\t/* copy user */\n\t/* BB what about null user mounts - check that we do this BB */\n\t/* copy user */\n\tif (ses->user_name != NULL) {\n\t\tstrncpy(bcc_ptr, ses->user_name, CIFS_MAX_USERNAME_LEN);\n\t\tbcc_ptr += strnlen(ses->user_name, CIFS_MAX_USERNAME_LEN);\n\t}\n\t/* else null user mount */\n\t*bcc_ptr = 0;\n\tbcc_ptr++; /* account for null termination */\n\n\t/* copy domain */\n\tif (ses->domainName != NULL) {\n\t\tstrncpy(bcc_ptr, ses->domainName, CIFS_MAX_DOMAINNAME_LEN);\n\t\tbcc_ptr += strnlen(ses->domainName, CIFS_MAX_DOMAINNAME_LEN);\n\t} /* else we will send a null domain name\n\t     so the server will default to its own domain */\n\t*bcc_ptr = 0;\n\tbcc_ptr++;\n\n\t/* BB check for overflow here */\n\n\tstrcpy(bcc_ptr, \"Linux version \");\n\tbcc_ptr += strlen(\"Linux version \");\n\tstrcpy(bcc_ptr, init_utsname()->release);\n\tbcc_ptr += strlen(init_utsname()->release) + 1;\n\n\tstrcpy(bcc_ptr, CIFS_NETWORK_OPSYS);\n\tbcc_ptr += strlen(CIFS_NETWORK_OPSYS) + 1;\n\n\t*pbcc_area = bcc_ptr;\n}\n\nstatic void\ndecode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,\n\t\t      const struct nls_table *nls_cp)\n{\n\tint len;\n\tchar *data = *pbcc_area;\n\n\tcifs_dbg(FYI, \"bleft %d\\n\", bleft);\n\n\tkfree(ses->serverOS);\n\tses->serverOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverOS=%s\\n\", ses->serverOS);\n\tlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\n\tdata += len;\n\tbleft -= len;\n\tif (bleft <= 0)\n\t\treturn;\n\n\tkfree(ses->serverNOS);\n\tses->serverNOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverNOS=%s\\n\", ses->serverNOS);\n\tlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\n\tdata += len;\n\tbleft -= len;\n\tif (bleft <= 0)\n\t\treturn;\n\n\tkfree(ses->serverDomain);\n\tses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverDomain=%s\\n\", ses->serverDomain);\n\n\treturn;\n}\n\nstatic void decode_ascii_ssetup(char **pbcc_area, __u16 bleft,\n\t\t\t\tstruct cifs_ses *ses,\n\t\t\t\tconst struct nls_table *nls_cp)\n{\n\tint len;\n\tchar *bcc_ptr = *pbcc_area;\n\n\tcifs_dbg(FYI, \"decode sessetup ascii. bleft %d\\n\", bleft);\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len >= bleft)\n\t\treturn;\n\n\tkfree(ses->serverOS);\n\n\tses->serverOS = kzalloc(len + 1, GFP_KERNEL);\n\tif (ses->serverOS) {\n\t\tstrncpy(ses->serverOS, bcc_ptr, len);\n\t\tif (strncmp(ses->serverOS, \"OS/2\", 4) == 0)\n\t\t\tcifs_dbg(FYI, \"OS/2 server\\n\");\n\t}\n\n\tbcc_ptr += len + 1;\n\tbleft -= len + 1;\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len >= bleft)\n\t\treturn;\n\n\tkfree(ses->serverNOS);\n\n\tses->serverNOS = kzalloc(len + 1, GFP_KERNEL);\n\tif (ses->serverNOS)\n\t\tstrncpy(ses->serverNOS, bcc_ptr, len);\n\n\tbcc_ptr += len + 1;\n\tbleft -= len + 1;\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len > bleft)\n\t\treturn;\n\n\t/* No domain field in LANMAN case. Domain is\n\t   returned by old servers in the SMB negprot response */\n\t/* BB For newer servers which do not support Unicode,\n\t   but thus do return domain here we could add parsing\n\t   for it later, but it is not very important */\n\tcifs_dbg(FYI, \"ascii: bytes left %d\\n\", bleft);\n}\n\nint decode_ntlmssp_challenge(char *bcc_ptr, int blob_len,\n\t\t\t\t    struct cifs_ses *ses)\n{\n\tunsigned int tioffset; /* challenge message target info area */\n\tunsigned int tilen; /* challenge message target info area length  */\n\n\tCHALLENGE_MESSAGE *pblob = (CHALLENGE_MESSAGE *)bcc_ptr;\n\n\tif (blob_len < sizeof(CHALLENGE_MESSAGE)) {\n\t\tcifs_dbg(VFS, \"challenge blob len %d too small\\n\", blob_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (memcmp(pblob->Signature, \"NTLMSSP\", 8)) {\n\t\tcifs_dbg(VFS, \"blob signature incorrect %s\\n\",\n\t\t\t pblob->Signature);\n\t\treturn -EINVAL;\n\t}\n\tif (pblob->MessageType != NtLmChallenge) {\n\t\tcifs_dbg(VFS, \"Incorrect message type %d\\n\",\n\t\t\t pblob->MessageType);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(ses->ntlmssp->cryptkey, pblob->Challenge, CIFS_CRYPTO_KEY_SIZE);\n\t/* BB we could decode pblob->NegotiateFlags; some may be useful */\n\t/* In particular we can examine sign flags */\n\t/* BB spec says that if AvId field of MsvAvTimestamp is populated then\n\t\twe must set the MIC field of the AUTHENTICATE_MESSAGE */\n\tses->ntlmssp->server_flags = le32_to_cpu(pblob->NegotiateFlags);\n\ttioffset = le32_to_cpu(pblob->TargetInfoArray.BufferOffset);\n\ttilen = le16_to_cpu(pblob->TargetInfoArray.Length);\n\tif (tioffset > blob_len || tioffset + tilen > blob_len) {\n\t\tcifs_dbg(VFS, \"tioffset + tilen too high %u + %u\",\n\t\t\ttioffset, tilen);\n\t\treturn -EINVAL;\n\t}\n\tif (tilen) {\n\t\tses->auth_key.response = kmemdup(bcc_ptr + tioffset, tilen,\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (!ses->auth_key.response) {\n\t\t\tcifs_dbg(VFS, \"Challenge target info alloc failure\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tses->auth_key.len = tilen;\n\t}\n\n\treturn 0;\n}\n\n/* BB Move to ntlmssp.c eventually */\n\n/* We do not malloc the blob, it is passed in pbuffer, because\n   it is fixed size, and small, making this approach cleaner */\nvoid build_ntlmssp_negotiate_blob(unsigned char *pbuffer,\n\t\t\t\t\t struct cifs_ses *ses)\n{\n\tNEGOTIATE_MESSAGE *sec_blob = (NEGOTIATE_MESSAGE *)pbuffer;\n\t__u32 flags;\n\n\tmemset(pbuffer, 0, sizeof(NEGOTIATE_MESSAGE));\n\tmemcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);\n\tsec_blob->MessageType = NtLmNegotiate;\n\n\t/* BB is NTLMV2 session security format easier to use here? */\n\tflags = NTLMSSP_NEGOTIATE_56 |\tNTLMSSP_REQUEST_TARGET |\n\t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;\n\tif (ses->server->sign) {\n\t\tflags |= NTLMSSP_NEGOTIATE_SIGN;\n\t\tif (!ses->server->session_estab ||\n\t\t\t\tses->ntlmssp->sesskey_per_smbsess)\n\t\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n\t}\n\n\tsec_blob->NegotiateFlags = cpu_to_le32(flags);\n\n\tsec_blob->WorkstationName.BufferOffset = 0;\n\tsec_blob->WorkstationName.Length = 0;\n\tsec_blob->WorkstationName.MaximumLength = 0;\n\n\t/* Domain name is sent on the Challenge not Negotiate NTLMSSP request */\n\tsec_blob->DomainName.BufferOffset = 0;\n\tsec_blob->DomainName.Length = 0;\n\tsec_blob->DomainName.MaximumLength = 0;\n}\n\nstatic int size_of_ntlmssp_blob(struct cifs_ses *ses)\n{\n\tint sz = sizeof(AUTHENTICATE_MESSAGE) + ses->auth_key.len\n\t\t- CIFS_SESS_KEY_SIZE + CIFS_CPHTXT_SIZE + 2;\n\n\tif (ses->domainName)\n\t\tsz += 2 * strnlen(ses->domainName, CIFS_MAX_DOMAINNAME_LEN);\n\telse\n\t\tsz += 2;\n\n\tif (ses->user_name)\n\t\tsz += 2 * strnlen(ses->user_name, CIFS_MAX_USERNAME_LEN);\n\telse\n\t\tsz += 2;\n\n\treturn sz;\n}\n\nint build_ntlmssp_auth_blob(unsigned char **pbuffer,\n\t\t\t\t\tu16 *buflen,\n\t\t\t\t   struct cifs_ses *ses,\n\t\t\t\t   const struct nls_table *nls_cp)\n{\n\tint rc;\n\tAUTHENTICATE_MESSAGE *sec_blob;\n\t__u32 flags;\n\tunsigned char *tmp;\n\n\trc = setup_ntlmv2_rsp(ses, nls_cp);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Error %d during NTLMSSP authentication\\n\", rc);\n\t\t*buflen = 0;\n\t\tgoto setup_ntlmv2_ret;\n\t}\n\t*pbuffer = kmalloc(size_of_ntlmssp_blob(ses), GFP_KERNEL);\n\tsec_blob = (AUTHENTICATE_MESSAGE *)*pbuffer;\n\n\tmemcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);\n\tsec_blob->MessageType = NtLmAuthenticate;\n\n\tflags = NTLMSSP_NEGOTIATE_56 |\n\t\tNTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_TARGET_INFO |\n\t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC;\n\tif (ses->server->sign) {\n\t\tflags |= NTLMSSP_NEGOTIATE_SIGN;\n\t\tif (!ses->server->session_estab ||\n\t\t\t\tses->ntlmssp->sesskey_per_smbsess)\n\t\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n\t}\n\n\ttmp = *pbuffer + sizeof(AUTHENTICATE_MESSAGE);\n\tsec_blob->NegotiateFlags = cpu_to_le32(flags);\n\n\tsec_blob->LmChallengeResponse.BufferOffset =\n\t\t\t\tcpu_to_le32(sizeof(AUTHENTICATE_MESSAGE));\n\tsec_blob->LmChallengeResponse.Length = 0;\n\tsec_blob->LmChallengeResponse.MaximumLength = 0;\n\n\tsec_blob->NtChallengeResponse.BufferOffset =\n\t\t\t\tcpu_to_le32(tmp - *pbuffer);\n\tif (ses->user_name != NULL) {\n\t\tmemcpy(tmp, ses->auth_key.response + CIFS_SESS_KEY_SIZE,\n\t\t\t\tses->auth_key.len - CIFS_SESS_KEY_SIZE);\n\t\ttmp += ses->auth_key.len - CIFS_SESS_KEY_SIZE;\n\n\t\tsec_blob->NtChallengeResponse.Length =\n\t\t\t\tcpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);\n\t\tsec_blob->NtChallengeResponse.MaximumLength =\n\t\t\t\tcpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);\n\t} else {\n\t\t/*\n\t\t * don't send an NT Response for anonymous access\n\t\t */\n\t\tsec_blob->NtChallengeResponse.Length = 0;\n\t\tsec_blob->NtChallengeResponse.MaximumLength = 0;\n\t}\n\n\tif (ses->domainName == NULL) {\n\t\tsec_blob->DomainName.BufferOffset = cpu_to_le32(tmp - *pbuffer);\n\t\tsec_blob->DomainName.Length = 0;\n\t\tsec_blob->DomainName.MaximumLength = 0;\n\t\ttmp += 2;\n\t} else {\n\t\tint len;\n\t\tlen = cifs_strtoUTF16((__le16 *)tmp, ses->domainName,\n\t\t\t\t      CIFS_MAX_DOMAINNAME_LEN, nls_cp);\n\t\tlen *= 2; /* unicode is 2 bytes each */\n\t\tsec_blob->DomainName.BufferOffset = cpu_to_le32(tmp - *pbuffer);\n\t\tsec_blob->DomainName.Length = cpu_to_le16(len);\n\t\tsec_blob->DomainName.MaximumLength = cpu_to_le16(len);\n\t\ttmp += len;\n\t}\n\n\tif (ses->user_name == NULL) {\n\t\tsec_blob->UserName.BufferOffset = cpu_to_le32(tmp - *pbuffer);\n\t\tsec_blob->UserName.Length = 0;\n\t\tsec_blob->UserName.MaximumLength = 0;\n\t\ttmp += 2;\n\t} else {\n\t\tint len;\n\t\tlen = cifs_strtoUTF16((__le16 *)tmp, ses->user_name,\n\t\t\t\t      CIFS_MAX_USERNAME_LEN, nls_cp);\n\t\tlen *= 2; /* unicode is 2 bytes each */\n\t\tsec_blob->UserName.BufferOffset = cpu_to_le32(tmp - *pbuffer);\n\t\tsec_blob->UserName.Length = cpu_to_le16(len);\n\t\tsec_blob->UserName.MaximumLength = cpu_to_le16(len);\n\t\ttmp += len;\n\t}\n\n\tsec_blob->WorkstationName.BufferOffset = cpu_to_le32(tmp - *pbuffer);\n\tsec_blob->WorkstationName.Length = 0;\n\tsec_blob->WorkstationName.MaximumLength = 0;\n\ttmp += 2;\n\n\tif (((ses->ntlmssp->server_flags & NTLMSSP_NEGOTIATE_KEY_XCH) ||\n\t\t(ses->ntlmssp->server_flags & NTLMSSP_NEGOTIATE_EXTENDED_SEC))\n\t\t\t&& !calc_seckey(ses)) {\n\t\tmemcpy(tmp, ses->ntlmssp->ciphertext, CIFS_CPHTXT_SIZE);\n\t\tsec_blob->SessionKey.BufferOffset = cpu_to_le32(tmp - *pbuffer);\n\t\tsec_blob->SessionKey.Length = cpu_to_le16(CIFS_CPHTXT_SIZE);\n\t\tsec_blob->SessionKey.MaximumLength =\n\t\t\t\tcpu_to_le16(CIFS_CPHTXT_SIZE);\n\t\ttmp += CIFS_CPHTXT_SIZE;\n\t} else {\n\t\tsec_blob->SessionKey.BufferOffset = cpu_to_le32(tmp - *pbuffer);\n\t\tsec_blob->SessionKey.Length = 0;\n\t\tsec_blob->SessionKey.MaximumLength = 0;\n\t}\n\n\t*buflen = tmp - *pbuffer;\nsetup_ntlmv2_ret:\n\treturn rc;\n}\n\nenum securityEnum\nselect_sectype(struct TCP_Server_Info *server, enum securityEnum requested)\n{\n\tswitch (server->negflavor) {\n\tcase CIFS_NEGFLAVOR_EXTENDED:\n\t\tswitch (requested) {\n\t\tcase Kerberos:\n\t\tcase RawNTLMSSP:\n\t\t\treturn requested;\n\t\tcase Unspecified:\n\t\t\tif (server->sec_ntlmssp &&\n\t\t\t    (global_secflags & CIFSSEC_MAY_NTLMSSP))\n\t\t\t\treturn RawNTLMSSP;\n\t\t\tif ((server->sec_kerberos || server->sec_mskerberos) &&\n\t\t\t    (global_secflags & CIFSSEC_MAY_KRB5))\n\t\t\t\treturn Kerberos;\n\t\t\t/* Fallthrough */\n\t\tdefault:\n\t\t\treturn Unspecified;\n\t\t}\n\tcase CIFS_NEGFLAVOR_UNENCAP:\n\t\tswitch (requested) {\n\t\tcase NTLM:\n\t\tcase NTLMv2:\n\t\t\treturn requested;\n\t\tcase Unspecified:\n\t\t\tif (global_secflags & CIFSSEC_MAY_NTLMV2)\n\t\t\t\treturn NTLMv2;\n\t\t\tif (global_secflags & CIFSSEC_MAY_NTLM)\n\t\t\t\treturn NTLM;\n\t\tdefault:\n\t\t\t/* Fallthrough to attempt LANMAN authentication next */\n\t\t\tbreak;\n\t\t}\n\tcase CIFS_NEGFLAVOR_LANMAN:\n\t\tswitch (requested) {\n\t\tcase LANMAN:\n\t\t\treturn requested;\n\t\tcase Unspecified:\n\t\t\tif (global_secflags & CIFSSEC_MAY_LANMAN)\n\t\t\t\treturn LANMAN;\n\t\t\t/* Fallthrough */\n\t\tdefault:\n\t\t\treturn Unspecified;\n\t\t}\n\tdefault:\n\t\treturn Unspecified;\n\t}\n}\n\nstruct sess_data {\n\tunsigned int xid;\n\tstruct cifs_ses *ses;\n\tstruct nls_table *nls_cp;\n\tvoid (*func)(struct sess_data *);\n\tint result;\n\n\t/* we will send the SMB in three pieces:\n\t * a fixed length beginning part, an optional\n\t * SPNEGO blob (which can be zero length), and a\n\t * last part which will include the strings\n\t * and rest of bcc area. This allows us to avoid\n\t * a large buffer 17K allocation\n\t */\n\tint buf0_type;\n\tstruct kvec iov[3];\n};\n\nstatic int\nsess_alloc_buffer(struct sess_data *sess_data, int wct)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct smb_hdr *smb_buf;\n\n\trc = small_smb_init_no_tc(SMB_COM_SESSION_SETUP_ANDX, wct, ses,\n\t\t\t\t  (void **)&smb_buf);\n\n\tif (rc)\n\t\treturn rc;\n\n\tsess_data->iov[0].iov_base = (char *)smb_buf;\n\tsess_data->iov[0].iov_len = be32_to_cpu(smb_buf->smb_buf_length) + 4;\n\t/*\n\t * This variable will be used to clear the buffer\n\t * allocated above in case of any error in the calling function.\n\t */\n\tsess_data->buf0_type = CIFS_SMALL_BUFFER;\n\n\t/* 2000 big enough to fit max user, domain, NOS name etc. */\n\tsess_data->iov[2].iov_base = kmalloc(2000, GFP_KERNEL);\n\tif (!sess_data->iov[2].iov_base) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_smb_buf;\n\t}\n\n\treturn 0;\n\nout_free_smb_buf:\n\tkfree(smb_buf);\n\tsess_data->iov[0].iov_base = NULL;\n\tsess_data->iov[0].iov_len = 0;\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\treturn rc;\n}\n\nstatic void\nsess_free_buffer(struct sess_data *sess_data)\n{\n\n\tfree_rsp_buf(sess_data->buf0_type, sess_data->iov[0].iov_base);\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\tkfree(sess_data->iov[2].iov_base);\n}\n\nstatic int\nsess_establish_session(struct sess_data *sess_data)\n{\n\tstruct cifs_ses *ses = sess_data->ses;\n\n\tmutex_lock(&ses->server->srv_mutex);\n\tif (!ses->server->session_estab) {\n\t\tif (ses->server->sign) {\n\t\t\tses->server->session_key.response =\n\t\t\t\tkmemdup(ses->auth_key.response,\n\t\t\t\tses->auth_key.len, GFP_KERNEL);\n\t\t\tif (!ses->server->session_key.response) {\n\t\t\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tses->server->session_key.len =\n\t\t\t\t\t\tses->auth_key.len;\n\t\t}\n\t\tses->server->sequence_number = 0x2;\n\t\tses->server->session_estab = true;\n\t}\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tcifs_dbg(FYI, \"CIFS session established successfully\\n\");\n\tspin_lock(&GlobalMid_Lock);\n\tses->status = CifsGood;\n\tses->need_reconnect = false;\n\tspin_unlock(&GlobalMid_Lock);\n\n\treturn 0;\n}\n\nstatic int\nsess_sendreceive(struct sess_data *sess_data)\n{\n\tint rc;\n\tstruct smb_hdr *smb_buf = (struct smb_hdr *) sess_data->iov[0].iov_base;\n\t__u16 count;\n\tstruct kvec rsp_iov = { NULL, 0 };\n\n\tcount = sess_data->iov[1].iov_len + sess_data->iov[2].iov_len;\n\tsmb_buf->smb_buf_length =\n\t\tcpu_to_be32(be32_to_cpu(smb_buf->smb_buf_length) + count);\n\tput_bcc(count, smb_buf);\n\n\trc = SendReceive2(sess_data->xid, sess_data->ses,\n\t\t\t  sess_data->iov, 3 /* num_iovecs */,\n\t\t\t  &sess_data->buf0_type,\n\t\t\t  CIFS_LOG_ERROR, &rsp_iov);\n\tcifs_small_buf_release(sess_data->iov[0].iov_base);\n\tmemcpy(&sess_data->iov[0], &rsp_iov, sizeof(struct kvec));\n\n\treturn rc;\n}\n\n/*\n * LANMAN and plaintext are less secure and off by default.\n * So we make this explicitly be turned on in kconfig (in the\n * build) and turned on at runtime (changed from the default)\n * in proc/fs/cifs or via mount parm.  Unfortunately this is\n * needed for old Win (e.g. Win95), some obscure NAS and OS/2\n */\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\nstatic void\nsess_auth_lanman(struct sess_data *sess_data)\n{\n\tint rc = 0;\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tchar *bcc_ptr;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tchar lnm_session_key[CIFS_AUTH_RESP_SIZE];\n\t__u32 capabilities;\n\t__u16 bytes_remaining;\n\n\t/* lanman 2 style sessionsetup */\n\t/* wct = 10 */\n\trc = sess_alloc_buffer(sess_data, 10);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tbcc_ptr = sess_data->iov[2].iov_base;\n\tcapabilities = cifs_ssetup_hdr(ses, pSMB);\n\n\tpSMB->req.hdr.Flags2 &= ~SMBFLG2_UNICODE;\n\n\tif (ses->user_name != NULL) {\n\t\t/* no capabilities flags in old lanman negotiation */\n\t\tpSMB->old_req.PasswordLength = cpu_to_le16(CIFS_AUTH_RESP_SIZE);\n\n\t\t/* Calculate hash with password and copy into bcc_ptr.\n\t\t * Encryption Key (stored as in cryptkey) gets used if the\n\t\t * security mode bit in Negottiate Protocol response states\n\t\t * to use challenge/response method (i.e. Password bit is 1).\n\t\t */\n\t\trc = calc_lanman_hash(ses->password, ses->server->cryptkey,\n\t\t\t\t      ses->server->sec_mode & SECMODE_PW_ENCRYPT ?\n\t\t\t\t      true : false, lnm_session_key);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tmemcpy(bcc_ptr, (char *)lnm_session_key, CIFS_AUTH_RESP_SIZE);\n\t\tbcc_ptr += CIFS_AUTH_RESP_SIZE;\n\t} else {\n\t\tpSMB->old_req.PasswordLength = 0;\n\t}\n\n\t/*\n\t * can not sign if LANMAN negotiated so no need\n\t * to calculate signing key? but what if server\n\t * changed to do higher than lanman dialect and\n\t * we reconnected would we ever calc signing_key?\n\t */\n\n\tcifs_dbg(FYI, \"Negotiating LANMAN setting up strings\\n\");\n\t/* Unicode not allowed for LANMAN dialects */\n\tascii_ssetup_strings(&bcc_ptr, ses, sess_data->nls_cp);\n\n\tsess_data->iov[2].iov_len = (long) bcc_ptr -\n\t\t\t(long) sess_data->iov[2].iov_base;\n\n\trc = sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)sess_data->iov[0].iov_base;\n\n\t/* lanman response has a word count of 3 */\n\tif (smb_buf->WordCount != 3) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"bad word count %d\\n\", smb_buf->WordCount);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(pSMB->resp.Action) & GUEST_LOGIN)\n\t\tcifs_dbg(FYI, \"Guest login\\n\"); /* BB mark SesInfo struct? */\n\n\tses->Suid = smb_buf->Uid;   /* UID left in wire format (le) */\n\tcifs_dbg(FYI, \"UID = %llu\\n\", ses->Suid);\n\n\tbytes_remaining = get_bcc(smb_buf);\n\tbcc_ptr = pByteArea(smb_buf);\n\n\t/* BB check if Unicode and decode strings */\n\tif (bytes_remaining == 0) {\n\t\t/* no string area to decode, do nothing */\n\t} else if (smb_buf->Flags2 & SMBFLG2_UNICODE) {\n\t\t/* unicode string area must be word-aligned */\n\t\tif (((unsigned long) bcc_ptr - (unsigned long) smb_buf) % 2) {\n\t\t\t++bcc_ptr;\n\t\t\t--bytes_remaining;\n\t\t}\n\t\tdecode_unicode_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t      sess_data->nls_cp);\n\t} else {\n\t\tdecode_ascii_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t    sess_data->nls_cp);\n\t}\n\n\trc = sess_establish_session(sess_data);\nout:\n\tsess_data->result = rc;\n\tsess_data->func = NULL;\n\tsess_free_buffer(sess_data);\n}\n\n#endif\n\nstatic void\nsess_auth_ntlm(struct sess_data *sess_data)\n{\n\tint rc = 0;\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tchar *bcc_ptr;\n\tstruct cifs_ses *ses = sess_data->ses;\n\t__u32 capabilities;\n\t__u16 bytes_remaining;\n\n\t/* old style NTLM sessionsetup */\n\t/* wct = 13 */\n\trc = sess_alloc_buffer(sess_data, 13);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tbcc_ptr = sess_data->iov[2].iov_base;\n\tcapabilities = cifs_ssetup_hdr(ses, pSMB);\n\n\tpSMB->req_no_secext.Capabilities = cpu_to_le32(capabilities);\n\tif (ses->user_name != NULL) {\n\t\tpSMB->req_no_secext.CaseInsensitivePasswordLength =\n\t\t\t\tcpu_to_le16(CIFS_AUTH_RESP_SIZE);\n\t\tpSMB->req_no_secext.CaseSensitivePasswordLength =\n\t\t\t\tcpu_to_le16(CIFS_AUTH_RESP_SIZE);\n\n\t\t/* calculate ntlm response and session key */\n\t\trc = setup_ntlm_response(ses, sess_data->nls_cp);\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"Error %d during NTLM authentication\\n\",\n\t\t\t\t\t rc);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* copy ntlm response */\n\t\tmemcpy(bcc_ptr, ses->auth_key.response + CIFS_SESS_KEY_SIZE,\n\t\t\t\tCIFS_AUTH_RESP_SIZE);\n\t\tbcc_ptr += CIFS_AUTH_RESP_SIZE;\n\t\tmemcpy(bcc_ptr, ses->auth_key.response + CIFS_SESS_KEY_SIZE,\n\t\t\t\tCIFS_AUTH_RESP_SIZE);\n\t\tbcc_ptr += CIFS_AUTH_RESP_SIZE;\n\t} else {\n\t\tpSMB->req_no_secext.CaseInsensitivePasswordLength = 0;\n\t\tpSMB->req_no_secext.CaseSensitivePasswordLength = 0;\n\t}\n\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\t/* unicode strings must be word aligned */\n\t\tif (sess_data->iov[0].iov_len % 2) {\n\t\t\t*bcc_ptr = 0;\n\t\t\tbcc_ptr++;\n\t\t}\n\t\tunicode_ssetup_strings(&bcc_ptr, ses, sess_data->nls_cp);\n\t} else {\n\t\tascii_ssetup_strings(&bcc_ptr, ses, sess_data->nls_cp);\n\t}\n\n\n\tsess_data->iov[2].iov_len = (long) bcc_ptr -\n\t\t\t(long) sess_data->iov[2].iov_base;\n\n\trc = sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)sess_data->iov[0].iov_base;\n\n\tif (smb_buf->WordCount != 3) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"bad word count %d\\n\", smb_buf->WordCount);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(pSMB->resp.Action) & GUEST_LOGIN)\n\t\tcifs_dbg(FYI, \"Guest login\\n\"); /* BB mark SesInfo struct? */\n\n\tses->Suid = smb_buf->Uid;   /* UID left in wire format (le) */\n\tcifs_dbg(FYI, \"UID = %llu\\n\", ses->Suid);\n\n\tbytes_remaining = get_bcc(smb_buf);\n\tbcc_ptr = pByteArea(smb_buf);\n\n\t/* BB check if Unicode and decode strings */\n\tif (bytes_remaining == 0) {\n\t\t/* no string area to decode, do nothing */\n\t} else if (smb_buf->Flags2 & SMBFLG2_UNICODE) {\n\t\t/* unicode string area must be word-aligned */\n\t\tif (((unsigned long) bcc_ptr - (unsigned long) smb_buf) % 2) {\n\t\t\t++bcc_ptr;\n\t\t\t--bytes_remaining;\n\t\t}\n\t\tdecode_unicode_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t      sess_data->nls_cp);\n\t} else {\n\t\tdecode_ascii_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t    sess_data->nls_cp);\n\t}\n\n\trc = sess_establish_session(sess_data);\nout:\n\tsess_data->result = rc;\n\tsess_data->func = NULL;\n\tsess_free_buffer(sess_data);\n\tkfree(ses->auth_key.response);\n\tses->auth_key.response = NULL;\n}\n\nstatic void\nsess_auth_ntlmv2(struct sess_data *sess_data)\n{\n\tint rc = 0;\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tchar *bcc_ptr;\n\tstruct cifs_ses *ses = sess_data->ses;\n\t__u32 capabilities;\n\t__u16 bytes_remaining;\n\n\t/* old style NTLM sessionsetup */\n\t/* wct = 13 */\n\trc = sess_alloc_buffer(sess_data, 13);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tbcc_ptr = sess_data->iov[2].iov_base;\n\tcapabilities = cifs_ssetup_hdr(ses, pSMB);\n\n\tpSMB->req_no_secext.Capabilities = cpu_to_le32(capabilities);\n\n\t/* LM2 password would be here if we supported it */\n\tpSMB->req_no_secext.CaseInsensitivePasswordLength = 0;\n\n\tif (ses->user_name != NULL) {\n\t\t/* calculate nlmv2 response and session key */\n\t\trc = setup_ntlmv2_rsp(ses, sess_data->nls_cp);\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"Error %d during NTLMv2 authentication\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\n\t\tmemcpy(bcc_ptr, ses->auth_key.response + CIFS_SESS_KEY_SIZE,\n\t\t\t\tses->auth_key.len - CIFS_SESS_KEY_SIZE);\n\t\tbcc_ptr += ses->auth_key.len - CIFS_SESS_KEY_SIZE;\n\n\t\t/* set case sensitive password length after tilen may get\n\t\t * assigned, tilen is 0 otherwise.\n\t\t */\n\t\tpSMB->req_no_secext.CaseSensitivePasswordLength =\n\t\t\tcpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);\n\t} else {\n\t\tpSMB->req_no_secext.CaseSensitivePasswordLength = 0;\n\t}\n\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tif (sess_data->iov[0].iov_len % 2) {\n\t\t\t*bcc_ptr = 0;\n\t\t\tbcc_ptr++;\n\t\t}\n\t\tunicode_ssetup_strings(&bcc_ptr, ses, sess_data->nls_cp);\n\t} else {\n\t\tascii_ssetup_strings(&bcc_ptr, ses, sess_data->nls_cp);\n\t}\n\n\n\tsess_data->iov[2].iov_len = (long) bcc_ptr -\n\t\t\t(long) sess_data->iov[2].iov_base;\n\n\trc = sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)sess_data->iov[0].iov_base;\n\n\tif (smb_buf->WordCount != 3) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"bad word count %d\\n\", smb_buf->WordCount);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(pSMB->resp.Action) & GUEST_LOGIN)\n\t\tcifs_dbg(FYI, \"Guest login\\n\"); /* BB mark SesInfo struct? */\n\n\tses->Suid = smb_buf->Uid;   /* UID left in wire format (le) */\n\tcifs_dbg(FYI, \"UID = %llu\\n\", ses->Suid);\n\n\tbytes_remaining = get_bcc(smb_buf);\n\tbcc_ptr = pByteArea(smb_buf);\n\n\t/* BB check if Unicode and decode strings */\n\tif (bytes_remaining == 0) {\n\t\t/* no string area to decode, do nothing */\n\t} else if (smb_buf->Flags2 & SMBFLG2_UNICODE) {\n\t\t/* unicode string area must be word-aligned */\n\t\tif (((unsigned long) bcc_ptr - (unsigned long) smb_buf) % 2) {\n\t\t\t++bcc_ptr;\n\t\t\t--bytes_remaining;\n\t\t}\n\t\tdecode_unicode_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t      sess_data->nls_cp);\n\t} else {\n\t\tdecode_ascii_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t    sess_data->nls_cp);\n\t}\n\n\trc = sess_establish_session(sess_data);\nout:\n\tsess_data->result = rc;\n\tsess_data->func = NULL;\n\tsess_free_buffer(sess_data);\n\tkfree(ses->auth_key.response);\n\tses->auth_key.response = NULL;\n}\n\n#ifdef CONFIG_CIFS_UPCALL\nstatic void\nsess_auth_kerberos(struct sess_data *sess_data)\n{\n\tint rc = 0;\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tchar *bcc_ptr;\n\tstruct cifs_ses *ses = sess_data->ses;\n\t__u32 capabilities;\n\t__u16 bytes_remaining;\n\tstruct key *spnego_key = NULL;\n\tstruct cifs_spnego_msg *msg;\n\tu16 blob_len;\n\n\t/* extended security */\n\t/* wct = 12 */\n\trc = sess_alloc_buffer(sess_data, 12);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tbcc_ptr = sess_data->iov[2].iov_base;\n\tcapabilities = cifs_ssetup_hdr(ses, pSMB);\n\n\tspnego_key = cifs_get_spnego_key(ses);\n\tif (IS_ERR(spnego_key)) {\n\t\trc = PTR_ERR(spnego_key);\n\t\tspnego_key = NULL;\n\t\tgoto out;\n\t}\n\n\tmsg = spnego_key->payload.data[0];\n\t/*\n\t * check version field to make sure that cifs.upcall is\n\t * sending us a response in an expected form\n\t */\n\tif (msg->version != CIFS_SPNEGO_UPCALL_VERSION) {\n\t\tcifs_dbg(VFS,\n\t\t  \"incorrect version of cifs.upcall (expected %d but got %d)\",\n\t\t\t      CIFS_SPNEGO_UPCALL_VERSION, msg->version);\n\t\trc = -EKEYREJECTED;\n\t\tgoto out_put_spnego_key;\n\t}\n\n\tses->auth_key.response = kmemdup(msg->data, msg->sesskey_len,\n\t\t\t\t\t GFP_KERNEL);\n\tif (!ses->auth_key.response) {\n\t\tcifs_dbg(VFS, \"Kerberos can't allocate (%u bytes) memory\",\n\t\t\t\tmsg->sesskey_len);\n\t\trc = -ENOMEM;\n\t\tgoto out_put_spnego_key;\n\t}\n\tses->auth_key.len = msg->sesskey_len;\n\n\tpSMB->req.hdr.Flags2 |= SMBFLG2_EXT_SEC;\n\tcapabilities |= CAP_EXTENDED_SECURITY;\n\tpSMB->req.Capabilities = cpu_to_le32(capabilities);\n\tsess_data->iov[1].iov_base = msg->data + msg->sesskey_len;\n\tsess_data->iov[1].iov_len = msg->secblob_len;\n\tpSMB->req.SecurityBlobLength = cpu_to_le16(sess_data->iov[1].iov_len);\n\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\t/* unicode strings must be word aligned */\n\t\tif ((sess_data->iov[0].iov_len\n\t\t\t+ sess_data->iov[1].iov_len) % 2) {\n\t\t\t*bcc_ptr = 0;\n\t\t\tbcc_ptr++;\n\t\t}\n\t\tunicode_oslm_strings(&bcc_ptr, sess_data->nls_cp);\n\t\tunicode_domain_string(&bcc_ptr, ses, sess_data->nls_cp);\n\t} else {\n\t\t/* BB: is this right? */\n\t\tascii_ssetup_strings(&bcc_ptr, ses, sess_data->nls_cp);\n\t}\n\n\tsess_data->iov[2].iov_len = (long) bcc_ptr -\n\t\t\t(long) sess_data->iov[2].iov_base;\n\n\trc = sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out_put_spnego_key;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)sess_data->iov[0].iov_base;\n\n\tif (smb_buf->WordCount != 4) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"bad word count %d\\n\", smb_buf->WordCount);\n\t\tgoto out_put_spnego_key;\n\t}\n\n\tif (le16_to_cpu(pSMB->resp.Action) & GUEST_LOGIN)\n\t\tcifs_dbg(FYI, \"Guest login\\n\"); /* BB mark SesInfo struct? */\n\n\tses->Suid = smb_buf->Uid;   /* UID left in wire format (le) */\n\tcifs_dbg(FYI, \"UID = %llu\\n\", ses->Suid);\n\n\tbytes_remaining = get_bcc(smb_buf);\n\tbcc_ptr = pByteArea(smb_buf);\n\n\tblob_len = le16_to_cpu(pSMB->resp.SecurityBlobLength);\n\tif (blob_len > bytes_remaining) {\n\t\tcifs_dbg(VFS, \"bad security blob length %d\\n\",\n\t\t\t\tblob_len);\n\t\trc = -EINVAL;\n\t\tgoto out_put_spnego_key;\n\t}\n\tbcc_ptr += blob_len;\n\tbytes_remaining -= blob_len;\n\n\t/* BB check if Unicode and decode strings */\n\tif (bytes_remaining == 0) {\n\t\t/* no string area to decode, do nothing */\n\t} else if (smb_buf->Flags2 & SMBFLG2_UNICODE) {\n\t\t/* unicode string area must be word-aligned */\n\t\tif (((unsigned long) bcc_ptr - (unsigned long) smb_buf) % 2) {\n\t\t\t++bcc_ptr;\n\t\t\t--bytes_remaining;\n\t\t}\n\t\tdecode_unicode_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t      sess_data->nls_cp);\n\t} else {\n\t\tdecode_ascii_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t    sess_data->nls_cp);\n\t}\n\n\trc = sess_establish_session(sess_data);\nout_put_spnego_key:\n\tkey_invalidate(spnego_key);\n\tkey_put(spnego_key);\nout:\n\tsess_data->result = rc;\n\tsess_data->func = NULL;\n\tsess_free_buffer(sess_data);\n\tkfree(ses->auth_key.response);\n\tses->auth_key.response = NULL;\n}\n\n#endif /* ! CONFIG_CIFS_UPCALL */\n\n/*\n * The required kvec buffers have to be allocated before calling this\n * function.\n */\nstatic int\n_sess_auth_rawntlmssp_assemble_req(struct sess_data *sess_data)\n{\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tstruct cifs_ses *ses = sess_data->ses;\n\t__u32 capabilities;\n\tchar *bcc_ptr;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)pSMB;\n\n\tcapabilities = cifs_ssetup_hdr(ses, pSMB);\n\tif ((pSMB->req.hdr.Flags2 & SMBFLG2_UNICODE) == 0) {\n\t\tcifs_dbg(VFS, \"NTLMSSP requires Unicode support\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\tpSMB->req.hdr.Flags2 |= SMBFLG2_EXT_SEC;\n\tcapabilities |= CAP_EXTENDED_SECURITY;\n\tpSMB->req.Capabilities |= cpu_to_le32(capabilities);\n\n\tbcc_ptr = sess_data->iov[2].iov_base;\n\t/* unicode strings must be word aligned */\n\tif ((sess_data->iov[0].iov_len + sess_data->iov[1].iov_len) % 2) {\n\t\t*bcc_ptr = 0;\n\t\tbcc_ptr++;\n\t}\n\tunicode_oslm_strings(&bcc_ptr, sess_data->nls_cp);\n\n\tsess_data->iov[2].iov_len = (long) bcc_ptr -\n\t\t\t\t\t(long) sess_data->iov[2].iov_base;\n\n\treturn 0;\n}\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic void\nsess_auth_rawntlmssp_negotiate(struct sess_data *sess_data)\n{\n\tint rc;\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tstruct cifs_ses *ses = sess_data->ses;\n\t__u16 bytes_remaining;\n\tchar *bcc_ptr;\n\tu16 blob_len;\n\n\tcifs_dbg(FYI, \"rawntlmssp session setup negotiate phase\\n\");\n\n\t/*\n\t * if memory allocation is successful, caller of this function\n\t * frees it.\n\t */\n\tses->ntlmssp = kmalloc(sizeof(struct ntlmssp_auth), GFP_KERNEL);\n\tif (!ses->ntlmssp) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tses->ntlmssp->sesskey_per_smbsess = false;\n\n\t/* wct = 12 */\n\trc = sess_alloc_buffer(sess_data, 12);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\n\t/* Build security blob before we assemble the request */\n\tbuild_ntlmssp_negotiate_blob(pSMB->req.SecurityBlob, ses);\n\tsess_data->iov[1].iov_len = sizeof(NEGOTIATE_MESSAGE);\n\tsess_data->iov[1].iov_base = pSMB->req.SecurityBlob;\n\tpSMB->req.SecurityBlobLength = cpu_to_le16(sizeof(NEGOTIATE_MESSAGE));\n\n\trc = _sess_auth_rawntlmssp_assemble_req(sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\trc = sess_sendreceive(sess_data);\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)sess_data->iov[0].iov_base;\n\n\t/* If true, rc here is expected and not an error */\n\tif (sess_data->buf0_type != CIFS_NO_BUFFER &&\n\t    smb_buf->Status.CifsError ==\n\t\t\tcpu_to_le32(NT_STATUS_MORE_PROCESSING_REQUIRED))\n\t\trc = 0;\n\n\tif (rc)\n\t\tgoto out;\n\n\tcifs_dbg(FYI, \"rawntlmssp session setup challenge phase\\n\");\n\n\tif (smb_buf->WordCount != 4) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"bad word count %d\\n\", smb_buf->WordCount);\n\t\tgoto out;\n\t}\n\n\tses->Suid = smb_buf->Uid;   /* UID left in wire format (le) */\n\tcifs_dbg(FYI, \"UID = %llu\\n\", ses->Suid);\n\n\tbytes_remaining = get_bcc(smb_buf);\n\tbcc_ptr = pByteArea(smb_buf);\n\n\tblob_len = le16_to_cpu(pSMB->resp.SecurityBlobLength);\n\tif (blob_len > bytes_remaining) {\n\t\tcifs_dbg(VFS, \"bad security blob length %d\\n\",\n\t\t\t\tblob_len);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trc = decode_ntlmssp_challenge(bcc_ptr, blob_len, ses);\nout:\n\tsess_free_buffer(sess_data);\n\n\tif (!rc) {\n\t\tsess_data->func = sess_auth_rawntlmssp_authenticate;\n\t\treturn;\n\t}\n\n\t/* Else error. Cleanup */\n\tkfree(ses->auth_key.response);\n\tses->auth_key.response = NULL;\n\tkfree(ses->ntlmssp);\n\tses->ntlmssp = NULL;\n\n\tsess_data->func = NULL;\n\tsess_data->result = rc;\n}\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data)\n{\n\tint rc;\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tstruct cifs_ses *ses = sess_data->ses;\n\t__u16 bytes_remaining;\n\tchar *bcc_ptr;\n\tunsigned char *ntlmsspblob = NULL;\n\tu16 blob_len;\n\n\tcifs_dbg(FYI, \"rawntlmssp session setup authenticate phase\\n\");\n\n\t/* wct = 12 */\n\trc = sess_alloc_buffer(sess_data, 12);\n\tif (rc)\n\t\tgoto out;\n\n\t/* Build security blob before we assemble the request */\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)pSMB;\n\trc = build_ntlmssp_auth_blob(&ntlmsspblob,\n\t\t\t\t\t&blob_len, ses, sess_data->nls_cp);\n\tif (rc)\n\t\tgoto out_free_ntlmsspblob;\n\tsess_data->iov[1].iov_len = blob_len;\n\tsess_data->iov[1].iov_base = ntlmsspblob;\n\tpSMB->req.SecurityBlobLength = cpu_to_le16(blob_len);\n\t/*\n\t * Make sure that we tell the server that we are using\n\t * the uid that it just gave us back on the response\n\t * (challenge)\n\t */\n\tsmb_buf->Uid = ses->Suid;\n\n\trc = _sess_auth_rawntlmssp_assemble_req(sess_data);\n\tif (rc)\n\t\tgoto out_free_ntlmsspblob;\n\n\trc = sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out_free_ntlmsspblob;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)sess_data->iov[0].iov_base;\n\tif (smb_buf->WordCount != 4) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"bad word count %d\\n\", smb_buf->WordCount);\n\t\tgoto out_free_ntlmsspblob;\n\t}\n\n\tif (le16_to_cpu(pSMB->resp.Action) & GUEST_LOGIN)\n\t\tcifs_dbg(FYI, \"Guest login\\n\"); /* BB mark SesInfo struct? */\n\n\tif (ses->Suid != smb_buf->Uid) {\n\t\tses->Suid = smb_buf->Uid;\n\t\tcifs_dbg(FYI, \"UID changed! new UID = %llu\\n\", ses->Suid);\n\t}\n\n\tbytes_remaining = get_bcc(smb_buf);\n\tbcc_ptr = pByteArea(smb_buf);\n\tblob_len = le16_to_cpu(pSMB->resp.SecurityBlobLength);\n\tif (blob_len > bytes_remaining) {\n\t\tcifs_dbg(VFS, \"bad security blob length %d\\n\",\n\t\t\t\tblob_len);\n\t\trc = -EINVAL;\n\t\tgoto out_free_ntlmsspblob;\n\t}\n\tbcc_ptr += blob_len;\n\tbytes_remaining -= blob_len;\n\n\n\t/* BB check if Unicode and decode strings */\n\tif (bytes_remaining == 0) {\n\t\t/* no string area to decode, do nothing */\n\t} else if (smb_buf->Flags2 & SMBFLG2_UNICODE) {\n\t\t/* unicode string area must be word-aligned */\n\t\tif (((unsigned long) bcc_ptr - (unsigned long) smb_buf) % 2) {\n\t\t\t++bcc_ptr;\n\t\t\t--bytes_remaining;\n\t\t}\n\t\tdecode_unicode_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t      sess_data->nls_cp);\n\t} else {\n\t\tdecode_ascii_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t    sess_data->nls_cp);\n\t}\n\nout_free_ntlmsspblob:\n\tkfree(ntlmsspblob);\nout:\n\tsess_free_buffer(sess_data);\n\n\t if (!rc)\n\t\trc = sess_establish_session(sess_data);\n\n\t/* Cleanup */\n\tkfree(ses->auth_key.response);\n\tses->auth_key.response = NULL;\n\tkfree(ses->ntlmssp);\n\tses->ntlmssp = NULL;\n\n\tsess_data->func = NULL;\n\tsess_data->result = rc;\n}\n\nstatic int select_sec(struct cifs_ses *ses, struct sess_data *sess_data)\n{\n\tint type;\n\n\ttype = select_sectype(ses->server, ses->sectype);\n\tcifs_dbg(FYI, \"sess setup type %d\\n\", type);\n\tif (type == Unspecified) {\n\t\tcifs_dbg(VFS,\n\t\t\t\"Unable to select appropriate authentication method!\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (type) {\n\tcase LANMAN:\n\t\t/* LANMAN and plaintext are less secure and off by default.\n\t\t * So we make this explicitly be turned on in kconfig (in the\n\t\t * build) and turned on at runtime (changed from the default)\n\t\t * in proc/fs/cifs or via mount parm.  Unfortunately this is\n\t\t * needed for old Win (e.g. Win95), some obscure NAS and OS/2 */\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n\t\tsess_data->func = sess_auth_lanman;\n\t\tbreak;\n#else\n\t\treturn -EOPNOTSUPP;\n#endif\n\tcase NTLM:\n\t\tsess_data->func = sess_auth_ntlm;\n\t\tbreak;\n\tcase NTLMv2:\n\t\tsess_data->func = sess_auth_ntlmv2;\n\t\tbreak;\n\tcase Kerberos:\n#ifdef CONFIG_CIFS_UPCALL\n\t\tsess_data->func = sess_auth_kerberos;\n\t\tbreak;\n#else\n\t\tcifs_dbg(VFS, \"Kerberos negotiated but upcall support disabled!\\n\");\n\t\treturn -ENOSYS;\n\t\tbreak;\n#endif /* CONFIG_CIFS_UPCALL */\n\tcase RawNTLMSSP:\n\t\tsess_data->func = sess_auth_rawntlmssp_negotiate;\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"secType %d not supported!\\n\", type);\n\t\treturn -ENOSYS;\n\t}\n\n\treturn 0;\n}\n\nint CIFS_SessSetup(const unsigned int xid, struct cifs_ses *ses,\n\t\t    const struct nls_table *nls_cp)\n{\n\tint rc = 0;\n\tstruct sess_data *sess_data;\n\n\tif (ses == NULL) {\n\t\tWARN(1, \"%s: ses == NULL!\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tsess_data = kzalloc(sizeof(struct sess_data), GFP_KERNEL);\n\tif (!sess_data)\n\t\treturn -ENOMEM;\n\n\trc = select_sec(ses, sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\tsess_data->xid = xid;\n\tsess_data->ses = ses;\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\tsess_data->nls_cp = (struct nls_table *) nls_cp;\n\n\twhile (sess_data->func)\n\t\tsess_data->func(sess_data);\n\n\t/* Store result before we free sess_data */\n\trc = sess_data->result;\n\nout:\n\tkfree(sess_data);\n\treturn rc;\n}\n", "/*\n *   fs/cifs/smb2pdu.c\n *\n *   Copyright (C) International Business Machines  Corp., 2009, 2013\n *                 Etersoft, 2012\n *   Author(s): Steve French (sfrench@us.ibm.com)\n *              Pavel Shilovsky (pshilovsky@samba.org) 2012\n *\n *   Contains the routines for constructing the SMB2 PDUs themselves\n *\n *   This library is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published\n *   by the Free Software Foundation; either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This library is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See\n *   the GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this library; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n */\n\n /* SMB2 PDU handling routines here - except for leftovers (eg session setup) */\n /* Note that there are handle based routines which must be\t\t      */\n /* treated slightly differently for reconnection purposes since we never     */\n /* want to reuse a stale file handle and only the caller knows the file info */\n\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/vfs.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include \"cifsacl.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"ntlmssp.h\"\n#include \"smb2status.h\"\n#include \"smb2glob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_spnego.h\"\n\n/*\n *  The following table defines the expected \"StructureSize\" of SMB2 requests\n *  in order by SMB2 command.  This is similar to \"wct\" in SMB/CIFS requests.\n *\n *  Note that commands are defined in smb2pdu.h in le16 but the array below is\n *  indexed by command in host byte order.\n */\nstatic const int smb2_req_struct_sizes[NUMBER_OF_SMB2_COMMANDS] = {\n\t/* SMB2_NEGOTIATE */ 36,\n\t/* SMB2_SESSION_SETUP */ 25,\n\t/* SMB2_LOGOFF */ 4,\n\t/* SMB2_TREE_CONNECT */\t9,\n\t/* SMB2_TREE_DISCONNECT */ 4,\n\t/* SMB2_CREATE */ 57,\n\t/* SMB2_CLOSE */ 24,\n\t/* SMB2_FLUSH */ 24,\n\t/* SMB2_READ */\t49,\n\t/* SMB2_WRITE */ 49,\n\t/* SMB2_LOCK */\t48,\n\t/* SMB2_IOCTL */ 57,\n\t/* SMB2_CANCEL */ 4,\n\t/* SMB2_ECHO */ 4,\n\t/* SMB2_QUERY_DIRECTORY */ 33,\n\t/* SMB2_CHANGE_NOTIFY */ 32,\n\t/* SMB2_QUERY_INFO */ 41,\n\t/* SMB2_SET_INFO */ 33,\n\t/* SMB2_OPLOCK_BREAK */ 24 /* BB this is 36 for LEASE_BREAK variant */\n};\n\nstatic int encryption_required(const struct cifs_tcon *tcon)\n{\n\tif ((tcon->ses->session_flags & SMB2_SESSION_FLAG_ENCRYPT_DATA) ||\n\t    (tcon->share_flags & SHI1005_FLAGS_ENCRYPT_DATA))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic void\nsmb2_hdr_assemble(struct smb2_sync_hdr *shdr, __le16 smb2_cmd,\n\t\t  const struct cifs_tcon *tcon)\n{\n\tshdr->ProtocolId = SMB2_PROTO_NUMBER;\n\tshdr->StructureSize = cpu_to_le16(64);\n\tshdr->Command = smb2_cmd;\n\tif (tcon && tcon->ses && tcon->ses->server) {\n\t\tstruct TCP_Server_Info *server = tcon->ses->server;\n\n\t\tspin_lock(&server->req_lock);\n\t\t/* Request up to 2 credits but don't go over the limit. */\n\t\tif (server->credits >= server->max_credits)\n\t\t\tshdr->CreditRequest = cpu_to_le16(0);\n\t\telse\n\t\t\tshdr->CreditRequest = cpu_to_le16(\n\t\t\t\tmin_t(int, server->max_credits -\n\t\t\t\t\t\tserver->credits, 2));\n\t\tspin_unlock(&server->req_lock);\n\t} else {\n\t\tshdr->CreditRequest = cpu_to_le16(2);\n\t}\n\tshdr->ProcessId = cpu_to_le32((__u16)current->tgid);\n\n\tif (!tcon)\n\t\tgoto out;\n\n\t/* GLOBAL_CAP_LARGE_MTU will only be set if dialect > SMB2.02 */\n\t/* See sections 2.2.4 and 3.2.4.1.5 of MS-SMB2 */\n\tif ((tcon->ses) && (tcon->ses->server) &&\n\t    (tcon->ses->server->capabilities & SMB2_GLOBAL_CAP_LARGE_MTU))\n\t\tshdr->CreditCharge = cpu_to_le16(1);\n\t/* else CreditCharge MBZ */\n\n\tshdr->TreeId = tcon->tid;\n\t/* Uid is not converted */\n\tif (tcon->ses)\n\t\tshdr->SessionId = tcon->ses->Suid;\n\n\t/*\n\t * If we would set SMB2_FLAGS_DFS_OPERATIONS on open we also would have\n\t * to pass the path on the Open SMB prefixed by \\\\server\\share.\n\t * Not sure when we would need to do the augmented path (if ever) and\n\t * setting this flag breaks the SMB2 open operation since it is\n\t * illegal to send an empty path name (without \\\\server\\share prefix)\n\t * when the DFS flag is set in the SMB open header. We could\n\t * consider setting the flag on all operations other than open\n\t * but it is safer to net set it for now.\n\t */\n/*\tif (tcon->share_flags & SHI1005_FLAGS_DFS)\n\t\tshdr->Flags |= SMB2_FLAGS_DFS_OPERATIONS; */\n\n\tif (tcon->ses && tcon->ses->server && tcon->ses->server->sign &&\n\t    !encryption_required(tcon))\n\t\tshdr->Flags |= SMB2_FLAGS_SIGNED;\nout:\n\treturn;\n}\n\nstatic int\nsmb2_reconnect(__le16 smb2_command, struct cifs_tcon *tcon)\n{\n\tint rc = 0;\n\tstruct nls_table *nls_codepage;\n\tstruct cifs_ses *ses;\n\tstruct TCP_Server_Info *server;\n\n\t/*\n\t * SMB2s NegProt, SessSetup, Logoff do not have tcon yet so\n\t * check for tcp and smb session status done differently\n\t * for those three - in the calling routine.\n\t */\n\tif (tcon == NULL)\n\t\treturn rc;\n\n\tif (smb2_command == SMB2_TREE_CONNECT)\n\t\treturn rc;\n\n\tif (tcon->tidStatus == CifsExiting) {\n\t\t/*\n\t\t * only tree disconnect, open, and write,\n\t\t * (and ulogoff which does not have tcon)\n\t\t * are allowed as we start force umount.\n\t\t */\n\t\tif ((smb2_command != SMB2_WRITE) &&\n\t\t   (smb2_command != SMB2_CREATE) &&\n\t\t   (smb2_command != SMB2_TREE_DISCONNECT)) {\n\t\t\tcifs_dbg(FYI, \"can not send cmd %d while umounting\\n\",\n\t\t\t\t smb2_command);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\tif ((!tcon->ses) || (tcon->ses->status == CifsExiting) ||\n\t    (!tcon->ses->server))\n\t\treturn -EIO;\n\n\tses = tcon->ses;\n\tserver = ses->server;\n\n\t/*\n\t * Give demultiplex thread up to 10 seconds to reconnect, should be\n\t * greater than cifs socket timeout which is 7 seconds\n\t */\n\twhile (server->tcpStatus == CifsNeedReconnect) {\n\t\t/*\n\t\t * Return to caller for TREE_DISCONNECT and LOGOFF and CLOSE\n\t\t * here since they are implicitly done when session drops.\n\t\t */\n\t\tswitch (smb2_command) {\n\t\t/*\n\t\t * BB Should we keep oplock break and add flush to exceptions?\n\t\t */\n\t\tcase SMB2_TREE_DISCONNECT:\n\t\tcase SMB2_CANCEL:\n\t\tcase SMB2_CLOSE:\n\t\tcase SMB2_OPLOCK_BREAK:\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\twait_event_interruptible_timeout(server->response_q,\n\t\t\t(server->tcpStatus != CifsNeedReconnect), 10 * HZ);\n\n\t\t/* are we still trying to reconnect? */\n\t\tif (server->tcpStatus != CifsNeedReconnect)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * on \"soft\" mounts we wait once. Hard mounts keep\n\t\t * retrying until process is killed or server comes\n\t\t * back on-line\n\t\t */\n\t\tif (!tcon->retry) {\n\t\t\tcifs_dbg(FYI, \"gave up waiting on reconnect in smb_init\\n\");\n\t\t\treturn -EHOSTDOWN;\n\t\t}\n\t}\n\n\tif (!tcon->ses->need_reconnect && !tcon->need_reconnect)\n\t\treturn rc;\n\n\tnls_codepage = load_nls_default();\n\n\t/*\n\t * need to prevent multiple threads trying to simultaneously reconnect\n\t * the same SMB session\n\t */\n\tmutex_lock(&tcon->ses->session_mutex);\n\trc = cifs_negotiate_protocol(0, tcon->ses);\n\tif (!rc && tcon->ses->need_reconnect)\n\t\trc = cifs_setup_session(0, tcon->ses, nls_codepage);\n\n\tif (rc || !tcon->need_reconnect) {\n\t\tmutex_unlock(&tcon->ses->session_mutex);\n\t\tgoto out;\n\t}\n\n\tcifs_mark_open_files_invalid(tcon);\n\tif (tcon->use_persistent)\n\t\ttcon->need_reopen_files = true;\n\n\trc = SMB2_tcon(0, tcon->ses, tcon->treeName, tcon, nls_codepage);\n\tmutex_unlock(&tcon->ses->session_mutex);\n\n\tcifs_dbg(FYI, \"reconnect tcon rc = %d\\n\", rc);\n\tif (rc)\n\t\tgoto out;\n\n\tif (smb2_command != SMB2_INTERNAL_CMD)\n\t\tqueue_delayed_work(cifsiod_wq, &server->reconnect, 0);\n\n\tatomic_inc(&tconInfoReconnectCount);\nout:\n\t/*\n\t * Check if handle based operation so we know whether we can continue\n\t * or not without returning to caller to reset file handle.\n\t */\n\t/*\n\t * BB Is flush done by server on drop of tcp session? Should we special\n\t * case it and skip above?\n\t */\n\tswitch (smb2_command) {\n\tcase SMB2_FLUSH:\n\tcase SMB2_READ:\n\tcase SMB2_WRITE:\n\tcase SMB2_LOCK:\n\tcase SMB2_IOCTL:\n\tcase SMB2_QUERY_DIRECTORY:\n\tcase SMB2_CHANGE_NOTIFY:\n\tcase SMB2_QUERY_INFO:\n\tcase SMB2_SET_INFO:\n\t\trc = -EAGAIN;\n\t}\n\tunload_nls(nls_codepage);\n\treturn rc;\n}\n\nstatic void\nfill_small_buf(__le16 smb2_command, struct cifs_tcon *tcon, void *buf,\n\t       unsigned int *total_len)\n{\n\tstruct smb2_sync_pdu *spdu = (struct smb2_sync_pdu *)buf;\n\t/* lookup word count ie StructureSize from table */\n\t__u16 parmsize = smb2_req_struct_sizes[le16_to_cpu(smb2_command)];\n\n\t/*\n\t * smaller than SMALL_BUFFER_SIZE but bigger than fixed area of\n\t * largest operations (Create)\n\t */\n\tmemset(buf, 0, 256);\n\n\tsmb2_hdr_assemble(&spdu->sync_hdr, smb2_command, tcon);\n\tspdu->StructureSize2 = cpu_to_le16(parmsize);\n\n\t*total_len = parmsize + sizeof(struct smb2_sync_hdr);\n}\n\n/* init request without RFC1001 length at the beginning */\nstatic int\nsmb2_plain_req_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\t    void **request_buf, unsigned int *total_len)\n{\n\tint rc;\n\tstruct smb2_sync_hdr *shdr;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tshdr = (struct smb2_sync_hdr *)(*request_buf);\n\n\tfill_small_buf(smb2_command, tcon, shdr, total_len);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}\n\n/*\n * Allocate and return pointer to an SMB request hdr, and set basic\n * SMB information in the SMB header. If the return code is zero, this\n * function must have filled in request_buf pointer. The returned buffer\n * has RFC1001 length at the beginning.\n */\nstatic int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc;\n\tunsigned int total_len;\n\tstruct smb2_pdu *pdu;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tpdu = (struct smb2_pdu *)(*request_buf);\n\n\tfill_small_buf(smb2_command, tcon, get_sync_hdr(pdu), &total_len);\n\n\t/* Note this is only network field converted to big endian */\n\tpdu->hdr.smb2_buf_length = cpu_to_be32(total_len);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}\n\n#ifdef CONFIG_CIFS_SMB311\n/* offset is sizeof smb2_negotiate_req - 4 but rounded up to 8 bytes */\n#define OFFSET_OF_NEG_CONTEXT 0x68  /* sizeof(struct smb2_negotiate_req) - 4 */\n\n\n#define SMB2_PREAUTH_INTEGRITY_CAPABILITIES\tcpu_to_le16(1)\n#define SMB2_ENCRYPTION_CAPABILITIES\t\tcpu_to_le16(2)\n\nstatic void\nbuild_preauth_ctxt(struct smb2_preauth_neg_context *pneg_ctxt)\n{\n\tpneg_ctxt->ContextType = SMB2_PREAUTH_INTEGRITY_CAPABILITIES;\n\tpneg_ctxt->DataLength = cpu_to_le16(38);\n\tpneg_ctxt->HashAlgorithmCount = cpu_to_le16(1);\n\tpneg_ctxt->SaltLength = cpu_to_le16(SMB311_SALT_SIZE);\n\tget_random_bytes(pneg_ctxt->Salt, SMB311_SALT_SIZE);\n\tpneg_ctxt->HashAlgorithms = SMB2_PREAUTH_INTEGRITY_SHA512;\n}\n\nstatic void\nbuild_encrypt_ctxt(struct smb2_encryption_neg_context *pneg_ctxt)\n{\n\tpneg_ctxt->ContextType = SMB2_ENCRYPTION_CAPABILITIES;\n\tpneg_ctxt->DataLength = cpu_to_le16(6);\n\tpneg_ctxt->CipherCount = cpu_to_le16(2);\n\tpneg_ctxt->Ciphers[0] = SMB2_ENCRYPTION_AES128_GCM;\n\tpneg_ctxt->Ciphers[1] = SMB2_ENCRYPTION_AES128_CCM;\n}\n\nstatic void\nassemble_neg_contexts(struct smb2_negotiate_req *req)\n{\n\n\t/* +4 is to account for the RFC1001 len field */\n\tchar *pneg_ctxt = (char *)req + OFFSET_OF_NEG_CONTEXT + 4;\n\n\tbuild_preauth_ctxt((struct smb2_preauth_neg_context *)pneg_ctxt);\n\t/* Add 2 to size to round to 8 byte boundary */\n\tpneg_ctxt += 2 + sizeof(struct smb2_preauth_neg_context);\n\tbuild_encrypt_ctxt((struct smb2_encryption_neg_context *)pneg_ctxt);\n\treq->NegotiateContextOffset = cpu_to_le32(OFFSET_OF_NEG_CONTEXT);\n\treq->NegotiateContextCount = cpu_to_le16(2);\n\tinc_rfc1001_len(req, 4 + sizeof(struct smb2_preauth_neg_context) + 2\n\t\t\t+ sizeof(struct smb2_encryption_neg_context)); /* calculate hash */\n}\n#else\nstatic void assemble_neg_contexts(struct smb2_negotiate_req *req)\n{\n\treturn;\n}\n#endif /* SMB311 */\n\n/*\n *\n *\tSMB2 Worker functions follow:\n *\n *\tThe general structure of the worker functions is:\n *\t1) Call smb2_init (assembles SMB2 header)\n *\t2) Initialize SMB2 command specific fields in fixed length area of SMB\n *\t3) Call smb_sendrcv2 (sends request on socket and waits for response)\n *\t4) Decode SMB2 command specific fields in the fixed length area\n *\t5) Decode variable length data area (if any for this SMB2 command type)\n *\t6) Call free smb buffer\n *\t7) return\n *\n */\n\nint\nSMB2_negotiate(const unsigned int xid, struct cifs_ses *ses)\n{\n\tstruct smb2_negotiate_req *req;\n\tstruct smb2_negotiate_rsp *rsp;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tint rc = 0;\n\tint resp_buftype;\n\tstruct TCP_Server_Info *server = ses->server;\n\tint blob_offset, blob_length;\n\tchar *security_blob;\n\tint flags = CIFS_NEG_OP;\n\n\tcifs_dbg(FYI, \"Negotiate protocol\\n\");\n\n\tif (!server) {\n\t\tWARN(1, \"%s: server is NULL!\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\trc = small_smb2_init(SMB2_NEGOTIATE, NULL, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->hdr.sync_hdr.SessionId = 0;\n\n\treq->Dialects[0] = cpu_to_le16(ses->server->vals->protocol_id);\n\n\treq->DialectCount = cpu_to_le16(1); /* One vers= at a time for now */\n\tinc_rfc1001_len(req, 2);\n\n\t/* only one of SMB2 signing flags may be set in SMB2 request */\n\tif (ses->sign)\n\t\treq->SecurityMode = cpu_to_le16(SMB2_NEGOTIATE_SIGNING_REQUIRED);\n\telse if (global_secflags & CIFSSEC_MAY_SIGN)\n\t\treq->SecurityMode = cpu_to_le16(SMB2_NEGOTIATE_SIGNING_ENABLED);\n\telse\n\t\treq->SecurityMode = 0;\n\n\treq->Capabilities = cpu_to_le32(ses->server->vals->req_capabilities);\n\n\t/* ClientGUID must be zero for SMB2.02 dialect */\n\tif (ses->server->vals->protocol_id == SMB20_PROT_ID)\n\t\tmemset(req->ClientGUID, 0, SMB2_CLIENT_GUID_SIZE);\n\telse {\n\t\tmemcpy(req->ClientGUID, server->client_guid,\n\t\t\tSMB2_CLIENT_GUID_SIZE);\n\t\tif (ses->server->vals->protocol_id == SMB311_PROT_ID)\n\t\t\tassemble_neg_contexts(req);\n\t}\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\trsp = (struct smb2_negotiate_rsp *)rsp_iov.iov_base;\n\t/*\n\t * No tcon so can't do\n\t * cifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_fail[SMB2...]);\n\t */\n\tif (rc != 0)\n\t\tgoto neg_exit;\n\n\tcifs_dbg(FYI, \"mode 0x%x\\n\", rsp->SecurityMode);\n\n\t/* BB we may eventually want to match the negotiated vs. requested\n\t   dialect, even though we are only requesting one at a time */\n\tif (rsp->DialectRevision == cpu_to_le16(SMB20_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb2.0 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB21_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb2.1 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB30_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb3.0 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB302_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb3.02 dialect\\n\");\n#ifdef CONFIG_CIFS_SMB311\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB311_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb3.1.1 dialect\\n\");\n#endif /* SMB311 */\n\telse {\n\t\tcifs_dbg(VFS, \"Illegal dialect returned by server 0x%x\\n\",\n\t\t\t le16_to_cpu(rsp->DialectRevision));\n\t\trc = -EIO;\n\t\tgoto neg_exit;\n\t}\n\tserver->dialect = le16_to_cpu(rsp->DialectRevision);\n\n\t/* SMB2 only has an extended negflavor */\n\tserver->negflavor = CIFS_NEGFLAVOR_EXTENDED;\n\t/* set it to the maximum buffer size value we can send with 1 credit */\n\tserver->maxBuf = min_t(unsigned int, le32_to_cpu(rsp->MaxTransactSize),\n\t\t\t       SMB2_MAX_BUFFER_SIZE);\n\tserver->max_read = le32_to_cpu(rsp->MaxReadSize);\n\tserver->max_write = le32_to_cpu(rsp->MaxWriteSize);\n\t/* BB Do we need to validate the SecurityMode? */\n\tserver->sec_mode = le16_to_cpu(rsp->SecurityMode);\n\tserver->capabilities = le32_to_cpu(rsp->Capabilities);\n\t/* Internal types */\n\tserver->capabilities |= SMB2_NT_FIND | SMB2_LARGE_FILES;\n\n\tsecurity_blob = smb2_get_data_area_len(&blob_offset, &blob_length,\n\t\t\t\t\t       &rsp->hdr);\n\t/*\n\t * See MS-SMB2 section 2.2.4: if no blob, client picks default which\n\t * for us will be\n\t *\tses->sectype = RawNTLMSSP;\n\t * but for time being this is our only auth choice so doesn't matter.\n\t * We just found a server which sets blob length to zero expecting raw.\n\t */\n\tif (blob_length == 0)\n\t\tcifs_dbg(FYI, \"missing security blob on negprot\\n\");\n\n\trc = cifs_enable_signing(server, ses->sign);\n\tif (rc)\n\t\tgoto neg_exit;\n\tif (blob_length) {\n\t\trc = decode_negTokenInit(security_blob, blob_length, server);\n\t\tif (rc == 1)\n\t\t\trc = 0;\n\t\telse if (rc == 0)\n\t\t\trc = -EIO;\n\t}\nneg_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}\n\nint smb3_validate_negotiate(const unsigned int xid, struct cifs_tcon *tcon)\n{\n\tint rc = 0;\n\tstruct validate_negotiate_info_req vneg_inbuf;\n\tstruct validate_negotiate_info_rsp *pneg_rsp;\n\tu32 rsplen;\n\n\tcifs_dbg(FYI, \"validate negotiate\\n\");\n\n\t/*\n\t * validation ioctl must be signed, so no point sending this if we\n\t * can not sign it.  We could eventually change this to selectively\n\t * sign just this, the first and only signed request on a connection.\n\t * This is good enough for now since a user who wants better security\n\t * would also enable signing on the mount. Having validation of\n\t * negotiate info for signed connections helps reduce attack vectors\n\t */\n\tif (tcon->ses->server->sign == false)\n\t\treturn 0; /* validation requires signing */\n\n\tvneg_inbuf.Capabilities =\n\t\t\tcpu_to_le32(tcon->ses->server->vals->req_capabilities);\n\tmemcpy(vneg_inbuf.Guid, tcon->ses->server->client_guid,\n\t\t\t\t\tSMB2_CLIENT_GUID_SIZE);\n\n\tif (tcon->ses->sign)\n\t\tvneg_inbuf.SecurityMode =\n\t\t\tcpu_to_le16(SMB2_NEGOTIATE_SIGNING_REQUIRED);\n\telse if (global_secflags & CIFSSEC_MAY_SIGN)\n\t\tvneg_inbuf.SecurityMode =\n\t\t\tcpu_to_le16(SMB2_NEGOTIATE_SIGNING_ENABLED);\n\telse\n\t\tvneg_inbuf.SecurityMode = 0;\n\n\tvneg_inbuf.DialectCount = cpu_to_le16(1);\n\tvneg_inbuf.Dialects[0] =\n\t\tcpu_to_le16(tcon->ses->server->vals->protocol_id);\n\n\trc = SMB2_ioctl(xid, tcon, NO_FILE_ID, NO_FILE_ID,\n\t\tFSCTL_VALIDATE_NEGOTIATE_INFO, true /* is_fsctl */,\n\t\t(char *)&vneg_inbuf, sizeof(struct validate_negotiate_info_req),\n\t\t(char **)&pneg_rsp, &rsplen);\n\n\tif (rc != 0) {\n\t\tcifs_dbg(VFS, \"validate protocol negotiate failed: %d\\n\", rc);\n\t\treturn -EIO;\n\t}\n\n\tif (rsplen != sizeof(struct validate_negotiate_info_rsp)) {\n\t\tcifs_dbg(VFS, \"invalid size of protocol negotiate response\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* check validate negotiate info response matches what we got earlier */\n\tif (pneg_rsp->Dialect !=\n\t\t\tcpu_to_le16(tcon->ses->server->vals->protocol_id))\n\t\tgoto vneg_out;\n\n\tif (pneg_rsp->SecurityMode != cpu_to_le16(tcon->ses->server->sec_mode))\n\t\tgoto vneg_out;\n\n\t/* do not validate server guid because not saved at negprot time yet */\n\n\tif ((le32_to_cpu(pneg_rsp->Capabilities) | SMB2_NT_FIND |\n\t      SMB2_LARGE_FILES) != tcon->ses->server->capabilities)\n\t\tgoto vneg_out;\n\n\t/* validate negotiate successful */\n\tcifs_dbg(FYI, \"validate negotiate info successful\\n\");\n\treturn 0;\n\nvneg_out:\n\tcifs_dbg(VFS, \"protocol revalidation - security settings mismatch\\n\");\n\treturn -EIO;\n}\n\nstruct SMB2_sess_data {\n\tunsigned int xid;\n\tstruct cifs_ses *ses;\n\tstruct nls_table *nls_cp;\n\tvoid (*func)(struct SMB2_sess_data *);\n\tint result;\n\tu64 previous_session;\n\n\t/* we will send the SMB in three pieces:\n\t * a fixed length beginning part, an optional\n\t * SPNEGO blob (which can be zero length), and a\n\t * last part which will include the strings\n\t * and rest of bcc area. This allows us to avoid\n\t * a large buffer 17K allocation\n\t */\n\tint buf0_type;\n\tstruct kvec iov[2];\n};\n\nstatic int\nSMB2_sess_alloc_buffer(struct SMB2_sess_data *sess_data)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct smb2_sess_setup_req *req;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\trc = small_smb2_init(SMB2_SESSION_SETUP, NULL, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\t/* First session, not a reauthenticate */\n\treq->hdr.sync_hdr.SessionId = 0;\n\n\t/* if reconnect, we need to send previous sess id, otherwise it is 0 */\n\treq->PreviousSessionId = sess_data->previous_session;\n\n\treq->Flags = 0; /* MBZ */\n\t/* to enable echos and oplocks */\n\treq->hdr.sync_hdr.CreditRequest = cpu_to_le16(3);\n\n\t/* only one of SMB2 signing flags may be set in SMB2 request */\n\tif (server->sign)\n\t\treq->SecurityMode = SMB2_NEGOTIATE_SIGNING_REQUIRED;\n\telse if (global_secflags & CIFSSEC_MAY_SIGN) /* one flag unlike MUST_ */\n\t\treq->SecurityMode = SMB2_NEGOTIATE_SIGNING_ENABLED;\n\telse\n\t\treq->SecurityMode = 0;\n\n\treq->Capabilities = 0;\n\treq->Channel = 0; /* MBZ */\n\n\tsess_data->iov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field and 1 for pad */\n\tsess_data->iov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\t/*\n\t * This variable will be used to clear the buffer\n\t * allocated above in case of any error in the calling function.\n\t */\n\tsess_data->buf0_type = CIFS_SMALL_BUFFER;\n\n\treturn 0;\n}\n\nstatic void\nSMB2_sess_free_buffer(struct SMB2_sess_data *sess_data)\n{\n\tfree_rsp_buf(sess_data->buf0_type, sess_data->iov[0].iov_base);\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n}\n\nstatic int\nSMB2_sess_sendreceive(struct SMB2_sess_data *sess_data)\n{\n\tint rc;\n\tstruct smb2_sess_setup_req *req = sess_data->iov[0].iov_base;\n\tstruct kvec rsp_iov = { NULL, 0 };\n\n\t/* Testing shows that buffer offset must be at location of Buffer[0] */\n\treq->SecurityBufferOffset =\n\t\tcpu_to_le16(sizeof(struct smb2_sess_setup_req) -\n\t\t\t1 /* pad */ - 4 /* rfc1001 len */);\n\treq->SecurityBufferLength = cpu_to_le16(sess_data->iov[1].iov_len);\n\n\tinc_rfc1001_len(req, sess_data->iov[1].iov_len - 1 /* pad */);\n\n\t/* BB add code to build os and lm fields */\n\n\trc = SendReceive2(sess_data->xid, sess_data->ses,\n\t\t\t\tsess_data->iov, 2,\n\t\t\t\t&sess_data->buf0_type,\n\t\t\t\tCIFS_LOG_ERROR | CIFS_NEG_OP, &rsp_iov);\n\tcifs_small_buf_release(sess_data->iov[0].iov_base);\n\tmemcpy(&sess_data->iov[0], &rsp_iov, sizeof(struct kvec));\n\n\treturn rc;\n}\n\nstatic int\nSMB2_sess_establish_session(struct SMB2_sess_data *sess_data)\n{\n\tint rc = 0;\n\tstruct cifs_ses *ses = sess_data->ses;\n\n\tmutex_lock(&ses->server->srv_mutex);\n\tif (ses->server->sign && ses->server->ops->generate_signingkey) {\n\t\trc = ses->server->ops->generate_signingkey(ses);\n\t\tkfree(ses->auth_key.response);\n\t\tses->auth_key.response = NULL;\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI,\n\t\t\t\t\"SMB3 session key generation failed\\n\");\n\t\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t\tgoto keygen_exit;\n\t\t}\n\t}\n\tif (!ses->server->session_estab) {\n\t\tses->server->sequence_number = 0x2;\n\t\tses->server->session_estab = true;\n\t}\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tcifs_dbg(FYI, \"SMB2/3 session established successfully\\n\");\n\tspin_lock(&GlobalMid_Lock);\n\tses->status = CifsGood;\n\tses->need_reconnect = false;\n\tspin_unlock(&GlobalMid_Lock);\n\nkeygen_exit:\n\tif (!ses->server->sign) {\n\t\tkfree(ses->auth_key.response);\n\t\tses->auth_key.response = NULL;\n\t}\n\treturn rc;\n}\n\n#ifdef CONFIG_CIFS_UPCALL\nstatic void\nSMB2_auth_kerberos(struct SMB2_sess_data *sess_data)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct cifs_spnego_msg *msg;\n\tstruct key *spnego_key = NULL;\n\tstruct smb2_sess_setup_rsp *rsp = NULL;\n\n\trc = SMB2_sess_alloc_buffer(sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\tspnego_key = cifs_get_spnego_key(ses);\n\tif (IS_ERR(spnego_key)) {\n\t\trc = PTR_ERR(spnego_key);\n\t\tspnego_key = NULL;\n\t\tgoto out;\n\t}\n\n\tmsg = spnego_key->payload.data[0];\n\t/*\n\t * check version field to make sure that cifs.upcall is\n\t * sending us a response in an expected form\n\t */\n\tif (msg->version != CIFS_SPNEGO_UPCALL_VERSION) {\n\t\tcifs_dbg(VFS,\n\t\t\t  \"bad cifs.upcall version. Expected %d got %d\",\n\t\t\t  CIFS_SPNEGO_UPCALL_VERSION, msg->version);\n\t\trc = -EKEYREJECTED;\n\t\tgoto out_put_spnego_key;\n\t}\n\n\tses->auth_key.response = kmemdup(msg->data, msg->sesskey_len,\n\t\t\t\t\t GFP_KERNEL);\n\tif (!ses->auth_key.response) {\n\t\tcifs_dbg(VFS,\n\t\t\t\"Kerberos can't allocate (%u bytes) memory\",\n\t\t\tmsg->sesskey_len);\n\t\trc = -ENOMEM;\n\t\tgoto out_put_spnego_key;\n\t}\n\tses->auth_key.len = msg->sesskey_len;\n\n\tsess_data->iov[1].iov_base = msg->data + msg->sesskey_len;\n\tsess_data->iov[1].iov_len = msg->secblob_len;\n\n\trc = SMB2_sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out_put_spnego_key;\n\n\trsp = (struct smb2_sess_setup_rsp *)sess_data->iov[0].iov_base;\n\tses->Suid = rsp->hdr.sync_hdr.SessionId;\n\n\tses->session_flags = le16_to_cpu(rsp->SessionFlags);\n\tif (ses->session_flags & SMB2_SESSION_FLAG_ENCRYPT_DATA)\n\t\tcifs_dbg(VFS, \"SMB3 encryption not supported yet\\n\");\n\n\trc = SMB2_sess_establish_session(sess_data);\nout_put_spnego_key:\n\tkey_invalidate(spnego_key);\n\tkey_put(spnego_key);\nout:\n\tsess_data->result = rc;\n\tsess_data->func = NULL;\n\tSMB2_sess_free_buffer(sess_data);\n}\n#else\nstatic void\nSMB2_auth_kerberos(struct SMB2_sess_data *sess_data)\n{\n\tcifs_dbg(VFS, \"Kerberos negotiated but upcall support disabled!\\n\");\n\tsess_data->result = -EOPNOTSUPP;\n\tsess_data->func = NULL;\n}\n#endif\n\nstatic void\nSMB2_sess_auth_rawntlmssp_authenticate(struct SMB2_sess_data *sess_data);\n\nstatic void\nSMB2_sess_auth_rawntlmssp_negotiate(struct SMB2_sess_data *sess_data)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct smb2_sess_setup_rsp *rsp = NULL;\n\tchar *ntlmssp_blob = NULL;\n\tbool use_spnego = false; /* else use raw ntlmssp */\n\tu16 blob_length = 0;\n\n\t/*\n\t * If memory allocation is successful, caller of this function\n\t * frees it.\n\t */\n\tses->ntlmssp = kmalloc(sizeof(struct ntlmssp_auth), GFP_KERNEL);\n\tif (!ses->ntlmssp) {\n\t\trc = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\tses->ntlmssp->sesskey_per_smbsess = true;\n\n\trc = SMB2_sess_alloc_buffer(sess_data);\n\tif (rc)\n\t\tgoto out_err;\n\n\tntlmssp_blob = kmalloc(sizeof(struct _NEGOTIATE_MESSAGE),\n\t\t\t       GFP_KERNEL);\n\tif (ntlmssp_blob == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tbuild_ntlmssp_negotiate_blob(ntlmssp_blob, ses);\n\tif (use_spnego) {\n\t\t/* BB eventually need to add this */\n\t\tcifs_dbg(VFS, \"spnego not supported for SMB2 yet\\n\");\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t} else {\n\t\tblob_length = sizeof(struct _NEGOTIATE_MESSAGE);\n\t\t/* with raw NTLMSSP we don't encapsulate in SPNEGO */\n\t}\n\tsess_data->iov[1].iov_base = ntlmssp_blob;\n\tsess_data->iov[1].iov_len = blob_length;\n\n\trc = SMB2_sess_sendreceive(sess_data);\n\trsp = (struct smb2_sess_setup_rsp *)sess_data->iov[0].iov_base;\n\n\t/* If true, rc here is expected and not an error */\n\tif (sess_data->buf0_type != CIFS_NO_BUFFER &&\n\t\trsp->hdr.sync_hdr.Status == STATUS_MORE_PROCESSING_REQUIRED)\n\t\trc = 0;\n\n\tif (rc)\n\t\tgoto out;\n\n\tif (offsetof(struct smb2_sess_setup_rsp, Buffer) - 4 !=\n\t\t\tle16_to_cpu(rsp->SecurityBufferOffset)) {\n\t\tcifs_dbg(VFS, \"Invalid security buffer offset %d\\n\",\n\t\t\tle16_to_cpu(rsp->SecurityBufferOffset));\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\trc = decode_ntlmssp_challenge(rsp->Buffer,\n\t\t\tle16_to_cpu(rsp->SecurityBufferLength), ses);\n\tif (rc)\n\t\tgoto out;\n\n\tcifs_dbg(FYI, \"rawntlmssp session setup challenge phase\\n\");\n\n\n\tses->Suid = rsp->hdr.sync_hdr.SessionId;\n\tses->session_flags = le16_to_cpu(rsp->SessionFlags);\n\tif (ses->session_flags & SMB2_SESSION_FLAG_ENCRYPT_DATA)\n\t\tcifs_dbg(VFS, \"SMB3 encryption not supported yet\\n\");\n\nout:\n\tkfree(ntlmssp_blob);\n\tSMB2_sess_free_buffer(sess_data);\n\tif (!rc) {\n\t\tsess_data->result = 0;\n\t\tsess_data->func = SMB2_sess_auth_rawntlmssp_authenticate;\n\t\treturn;\n\t}\nout_err:\n\tkfree(ses->ntlmssp);\n\tses->ntlmssp = NULL;\n\tsess_data->result = rc;\n\tsess_data->func = NULL;\n}\n\nstatic void\nSMB2_sess_auth_rawntlmssp_authenticate(struct SMB2_sess_data *sess_data)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct smb2_sess_setup_req *req;\n\tstruct smb2_sess_setup_rsp *rsp = NULL;\n\tunsigned char *ntlmssp_blob = NULL;\n\tbool use_spnego = false; /* else use raw ntlmssp */\n\tu16 blob_length = 0;\n\n\trc = SMB2_sess_alloc_buffer(sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\treq = (struct smb2_sess_setup_req *) sess_data->iov[0].iov_base;\n\treq->hdr.sync_hdr.SessionId = ses->Suid;\n\n\trc = build_ntlmssp_auth_blob(&ntlmssp_blob, &blob_length, ses,\n\t\t\t\t\tsess_data->nls_cp);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"build_ntlmssp_auth_blob failed %d\\n\", rc);\n\t\tgoto out;\n\t}\n\n\tif (use_spnego) {\n\t\t/* BB eventually need to add this */\n\t\tcifs_dbg(VFS, \"spnego not supported for SMB2 yet\\n\");\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tsess_data->iov[1].iov_base = ntlmssp_blob;\n\tsess_data->iov[1].iov_len = blob_length;\n\n\trc = SMB2_sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\trsp = (struct smb2_sess_setup_rsp *)sess_data->iov[0].iov_base;\n\n\tses->Suid = rsp->hdr.sync_hdr.SessionId;\n\tses->session_flags = le16_to_cpu(rsp->SessionFlags);\n\tif (ses->session_flags & SMB2_SESSION_FLAG_ENCRYPT_DATA)\n\t\tcifs_dbg(VFS, \"SMB3 encryption not supported yet\\n\");\n\n\trc = SMB2_sess_establish_session(sess_data);\nout:\n\tkfree(ntlmssp_blob);\n\tSMB2_sess_free_buffer(sess_data);\n\tkfree(ses->ntlmssp);\n\tses->ntlmssp = NULL;\n\tsess_data->result = rc;\n\tsess_data->func = NULL;\n}\n\nstatic int\nSMB2_select_sec(struct cifs_ses *ses, struct SMB2_sess_data *sess_data)\n{\n\tif (ses->sectype != Kerberos && ses->sectype != RawNTLMSSP)\n\t\tses->sectype = RawNTLMSSP;\n\n\tswitch (ses->sectype) {\n\tcase Kerberos:\n\t\tsess_data->func = SMB2_auth_kerberos;\n\t\tbreak;\n\tcase RawNTLMSSP:\n\t\tsess_data->func = SMB2_sess_auth_rawntlmssp_negotiate;\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"secType %d not supported!\\n\", ses->sectype);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nint\nSMB2_sess_setup(const unsigned int xid, struct cifs_ses *ses,\n\t\tconst struct nls_table *nls_cp)\n{\n\tint rc = 0;\n\tstruct TCP_Server_Info *server = ses->server;\n\tstruct SMB2_sess_data *sess_data;\n\n\tcifs_dbg(FYI, \"Session Setup\\n\");\n\n\tif (!server) {\n\t\tWARN(1, \"%s: server is NULL!\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\tsess_data = kzalloc(sizeof(struct SMB2_sess_data), GFP_KERNEL);\n\tif (!sess_data)\n\t\treturn -ENOMEM;\n\n\trc = SMB2_select_sec(ses, sess_data);\n\tif (rc)\n\t\tgoto out;\n\tsess_data->xid = xid;\n\tsess_data->ses = ses;\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\tsess_data->nls_cp = (struct nls_table *) nls_cp;\n\n\twhile (sess_data->func)\n\t\tsess_data->func(sess_data);\n\n\trc = sess_data->result;\nout:\n\tkfree(sess_data);\n\treturn rc;\n}\n\nint\nSMB2_logoff(const unsigned int xid, struct cifs_ses *ses)\n{\n\tstruct smb2_logoff_req *req; /* response is also trivial struct */\n\tint rc = 0;\n\tstruct TCP_Server_Info *server;\n\tint flags = 0;\n\n\tcifs_dbg(FYI, \"disconnect session %p\\n\", ses);\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\t/* no need to send SMB logoff if uid already closed due to reconnect */\n\tif (ses->need_reconnect)\n\t\tgoto smb2_session_already_dead;\n\n\trc = small_smb2_init(SMB2_LOGOFF, NULL, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\t /* since no tcon, smb2_init can not do this, so do here */\n\treq->hdr.sync_hdr.SessionId = ses->Suid;\n\n\tif (ses->session_flags & SMB2_SESSION_FLAG_ENCRYPT_DATA)\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\telse if (server->sign)\n\t\treq->hdr.sync_hdr.Flags |= SMB2_FLAGS_SIGNED;\n\n\trc = SendReceiveNoRsp(xid, ses, (char *) req, flags);\n\tcifs_small_buf_release(req);\n\t/*\n\t * No tcon so can't do\n\t * cifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_fail[SMB2...]);\n\t */\n\nsmb2_session_already_dead:\n\treturn rc;\n}\n\nstatic inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}\n\n#define MAX_SHARENAME_LENGTH (255 /* server */ + 80 /* share */ + 1 /* NULL */)\n\n/* These are similar values to what Windows uses */\nstatic inline void init_copy_chunk_defaults(struct cifs_tcon *tcon)\n{\n\ttcon->max_chunks = 256;\n\ttcon->max_bytes_chunk = 1048576;\n\ttcon->max_bytes_copy = 16777216;\n}\n\nint\nSMB2_tcon(const unsigned int xid, struct cifs_ses *ses, const char *tree,\n\t  struct cifs_tcon *tcon, const struct nls_table *cp)\n{\n\tstruct smb2_tree_connect_req *req;\n\tstruct smb2_tree_connect_rsp *rsp = NULL;\n\tstruct kvec iov[2];\n\tstruct kvec rsp_iov;\n\tint rc = 0;\n\tint resp_buftype;\n\tint unc_path_len;\n\tstruct TCP_Server_Info *server;\n\t__le16 *unc_path = NULL;\n\tint flags = 0;\n\n\tcifs_dbg(FYI, \"TCON\\n\");\n\n\tif ((ses->server) && tree)\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\tif (tcon && tcon->bad_network_name)\n\t\treturn -ENOENT;\n\n\tif ((tcon && tcon->seal) &&\n\t    ((ses->server->capabilities & SMB2_GLOBAL_CAP_ENCRYPTION) == 0)) {\n\t\tcifs_dbg(VFS, \"encryption requested but no server support\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tunc_path = kmalloc(MAX_SHARENAME_LENGTH * 2, GFP_KERNEL);\n\tif (unc_path == NULL)\n\t\treturn -ENOMEM;\n\n\tunc_path_len = cifs_strtoUTF16(unc_path, tree, strlen(tree), cp) + 1;\n\tunc_path_len *= 2;\n\tif (unc_path_len < 2) {\n\t\tkfree(unc_path);\n\t\treturn -EINVAL;\n\t}\n\n\trc = small_smb2_init(SMB2_TREE_CONNECT, tcon, (void **) &req);\n\tif (rc) {\n\t\tkfree(unc_path);\n\t\treturn rc;\n\t}\n\n\tif (ses->session_flags & SMB2_SESSION_FLAG_ENCRYPT_DATA)\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tif (tcon == NULL) {\n\t\t/* since no tcon, smb2_init can not do this, so do here */\n\t\treq->hdr.sync_hdr.SessionId = ses->Suid;\n\t\t/* if (ses->server->sec_mode & SECMODE_SIGN_REQUIRED)\n\t\t\treq->hdr.Flags |= SMB2_FLAGS_SIGNED; */\n\t}\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field and 1 for pad */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\n\t/* Testing shows that buffer offset must be at location of Buffer[0] */\n\treq->PathOffset = cpu_to_le16(sizeof(struct smb2_tree_connect_req)\n\t\t\t- 1 /* pad */ - 4 /* do not count rfc1001 len field */);\n\treq->PathLength = cpu_to_le16(unc_path_len - 2);\n\tiov[1].iov_base = unc_path;\n\tiov[1].iov_len = unc_path_len;\n\n\tinc_rfc1001_len(req, unc_path_len - 1 /* pad */);\n\n\trc = SendReceive2(xid, ses, iov, 2, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\trsp = (struct smb2_tree_connect_rsp *)rsp_iov.iov_base;\n\n\tif (rc != 0) {\n\t\tif (tcon) {\n\t\t\tcifs_stats_fail_inc(tcon, SMB2_TREE_CONNECT_HE);\n\t\t\ttcon->need_reconnect = true;\n\t\t}\n\t\tgoto tcon_error_exit;\n\t}\n\n\tif (tcon == NULL) {\n\t\tses->ipc_tid = rsp->hdr.sync_hdr.TreeId;\n\t\tgoto tcon_exit;\n\t}\n\n\tif (rsp->ShareType & SMB2_SHARE_TYPE_DISK)\n\t\tcifs_dbg(FYI, \"connection to disk share\\n\");\n\telse if (rsp->ShareType & SMB2_SHARE_TYPE_PIPE) {\n\t\ttcon->ipc = true;\n\t\tcifs_dbg(FYI, \"connection to pipe share\\n\");\n\t} else if (rsp->ShareType & SMB2_SHARE_TYPE_PRINT) {\n\t\ttcon->print = true;\n\t\tcifs_dbg(FYI, \"connection to printer\\n\");\n\t} else {\n\t\tcifs_dbg(VFS, \"unknown share type %d\\n\", rsp->ShareType);\n\t\trc = -EOPNOTSUPP;\n\t\tgoto tcon_error_exit;\n\t}\n\n\ttcon->share_flags = le32_to_cpu(rsp->ShareFlags);\n\ttcon->capabilities = rsp->Capabilities; /* we keep caps little endian */\n\ttcon->maximal_access = le32_to_cpu(rsp->MaximalAccess);\n\ttcon->tidStatus = CifsGood;\n\ttcon->need_reconnect = false;\n\ttcon->tid = rsp->hdr.sync_hdr.TreeId;\n\tstrlcpy(tcon->treeName, tree, sizeof(tcon->treeName));\n\n\tif ((rsp->Capabilities & SMB2_SHARE_CAP_DFS) &&\n\t    ((tcon->share_flags & SHI1005_FLAGS_DFS) == 0))\n\t\tcifs_dbg(VFS, \"DFS capability contradicts DFS flag\\n\");\n\tinit_copy_chunk_defaults(tcon);\n\tif (tcon->share_flags & SHI1005_FLAGS_ENCRYPT_DATA)\n\t\tcifs_dbg(VFS, \"Encrypted shares not supported\");\n\tif (tcon->ses->server->ops->validate_negotiate)\n\t\trc = tcon->ses->server->ops->validate_negotiate(xid, tcon);\ntcon_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\tkfree(unc_path);\n\treturn rc;\n\ntcon_error_exit:\n\tif (rsp->hdr.sync_hdr.Status == STATUS_BAD_NETWORK_NAME) {\n\t\tcifs_dbg(VFS, \"BAD_NETWORK_NAME: %s\\n\", tree);\n\t\tif (tcon)\n\t\t\ttcon->bad_network_name = true;\n\t}\n\tgoto tcon_exit;\n}\n\nint\nSMB2_tdis(const unsigned int xid, struct cifs_tcon *tcon)\n{\n\tstruct smb2_tree_disconnect_req *req; /* response is trivial */\n\tint rc = 0;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tint flags = 0;\n\n\tcifs_dbg(FYI, \"Tree Disconnect\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\tif ((tcon->need_reconnect) || (tcon->ses->need_reconnect))\n\t\treturn 0;\n\n\trc = small_smb2_init(SMB2_TREE_DISCONNECT, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\trc = SendReceiveNoRsp(xid, ses, (char *)req, flags);\n\tcifs_small_buf_release(req);\n\tif (rc)\n\t\tcifs_stats_fail_inc(tcon, SMB2_TREE_DISCONNECT_HE);\n\n\treturn rc;\n}\n\n\nstatic struct create_durable *\ncreate_durable_buf(void)\n{\n\tstruct create_durable *buf;\n\n\tbuf = kzalloc(sizeof(struct create_durable), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct create_durable, Data));\n\tbuf->ccontext.DataLength = cpu_to_le32(16);\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_durable, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\t/* SMB2_CREATE_DURABLE_HANDLE_REQUEST is \"DHnQ\" */\n\tbuf->Name[0] = 'D';\n\tbuf->Name[1] = 'H';\n\tbuf->Name[2] = 'n';\n\tbuf->Name[3] = 'Q';\n\treturn buf;\n}\n\nstatic struct create_durable *\ncreate_reconnect_durable_buf(struct cifs_fid *fid)\n{\n\tstruct create_durable *buf;\n\n\tbuf = kzalloc(sizeof(struct create_durable), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct create_durable, Data));\n\tbuf->ccontext.DataLength = cpu_to_le32(16);\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_durable, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\tbuf->Data.Fid.PersistentFileId = fid->persistent_fid;\n\tbuf->Data.Fid.VolatileFileId = fid->volatile_fid;\n\t/* SMB2_CREATE_DURABLE_HANDLE_RECONNECT is \"DHnC\" */\n\tbuf->Name[0] = 'D';\n\tbuf->Name[1] = 'H';\n\tbuf->Name[2] = 'n';\n\tbuf->Name[3] = 'C';\n\treturn buf;\n}\n\nstatic __u8\nparse_lease_state(struct TCP_Server_Info *server, struct smb2_create_rsp *rsp,\n\t\t  unsigned int *epoch)\n{\n\tchar *data_offset;\n\tstruct create_context *cc;\n\tunsigned int next;\n\tunsigned int remaining;\n\tchar *name;\n\n\tdata_offset = (char *)rsp + 4 + le32_to_cpu(rsp->CreateContextsOffset);\n\tremaining = le32_to_cpu(rsp->CreateContextsLength);\n\tcc = (struct create_context *)data_offset;\n\twhile (remaining >= sizeof(struct create_context)) {\n\t\tname = le16_to_cpu(cc->NameOffset) + (char *)cc;\n\t\tif (le16_to_cpu(cc->NameLength) == 4 &&\n\t\t    strncmp(name, \"RqLs\", 4) == 0)\n\t\t\treturn server->ops->parse_lease_buf(cc, epoch);\n\n\t\tnext = le32_to_cpu(cc->Next);\n\t\tif (!next)\n\t\t\tbreak;\n\t\tremaining -= next;\n\t\tcc = (struct create_context *)((char *)cc + next);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nadd_lease_context(struct TCP_Server_Info *server, struct kvec *iov,\n\t\t  unsigned int *num_iovec, __u8 *oplock)\n{\n\tstruct smb2_create_req *req = iov[0].iov_base;\n\tunsigned int num = *num_iovec;\n\n\tiov[num].iov_base = server->ops->create_lease_buf(oplock+1, *oplock);\n\tif (iov[num].iov_base == NULL)\n\t\treturn -ENOMEM;\n\tiov[num].iov_len = server->vals->create_lease_size;\n\treq->RequestedOplockLevel = SMB2_OPLOCK_LEVEL_LEASE;\n\tif (!req->CreateContextsOffset)\n\t\treq->CreateContextsOffset = cpu_to_le32(\n\t\t\t\tsizeof(struct smb2_create_req) - 4 +\n\t\t\t\tiov[num - 1].iov_len);\n\tle32_add_cpu(&req->CreateContextsLength,\n\t\t     server->vals->create_lease_size);\n\tinc_rfc1001_len(&req->hdr, server->vals->create_lease_size);\n\t*num_iovec = num + 1;\n\treturn 0;\n}\n\nstatic struct create_durable_v2 *\ncreate_durable_v2_buf(struct cifs_fid *pfid)\n{\n\tstruct create_durable_v2 *buf;\n\n\tbuf = kzalloc(sizeof(struct create_durable_v2), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct create_durable_v2, dcontext));\n\tbuf->ccontext.DataLength = cpu_to_le32(sizeof(struct durable_context_v2));\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_durable_v2, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\n\tbuf->dcontext.Timeout = 0; /* Should this be configurable by workload */\n\tbuf->dcontext.Flags = cpu_to_le32(SMB2_DHANDLE_FLAG_PERSISTENT);\n\tgenerate_random_uuid(buf->dcontext.CreateGuid);\n\tmemcpy(pfid->create_guid, buf->dcontext.CreateGuid, 16);\n\n\t/* SMB2_CREATE_DURABLE_HANDLE_REQUEST is \"DH2Q\" */\n\tbuf->Name[0] = 'D';\n\tbuf->Name[1] = 'H';\n\tbuf->Name[2] = '2';\n\tbuf->Name[3] = 'Q';\n\treturn buf;\n}\n\nstatic struct create_durable_handle_reconnect_v2 *\ncreate_reconnect_durable_v2_buf(struct cifs_fid *fid)\n{\n\tstruct create_durable_handle_reconnect_v2 *buf;\n\n\tbuf = kzalloc(sizeof(struct create_durable_handle_reconnect_v2),\n\t\t\tGFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->ccontext.DataOffset =\n\t\tcpu_to_le16(offsetof(struct create_durable_handle_reconnect_v2,\n\t\t\t\t     dcontext));\n\tbuf->ccontext.DataLength =\n\t\tcpu_to_le32(sizeof(struct durable_reconnect_context_v2));\n\tbuf->ccontext.NameOffset =\n\t\tcpu_to_le16(offsetof(struct create_durable_handle_reconnect_v2,\n\t\t\t    Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\n\tbuf->dcontext.Fid.PersistentFileId = fid->persistent_fid;\n\tbuf->dcontext.Fid.VolatileFileId = fid->volatile_fid;\n\tbuf->dcontext.Flags = cpu_to_le32(SMB2_DHANDLE_FLAG_PERSISTENT);\n\tmemcpy(buf->dcontext.CreateGuid, fid->create_guid, 16);\n\n\t/* SMB2_CREATE_DURABLE_HANDLE_RECONNECT_V2 is \"DH2C\" */\n\tbuf->Name[0] = 'D';\n\tbuf->Name[1] = 'H';\n\tbuf->Name[2] = '2';\n\tbuf->Name[3] = 'C';\n\treturn buf;\n}\n\nstatic int\nadd_durable_v2_context(struct kvec *iov, unsigned int *num_iovec,\n\t\t    struct cifs_open_parms *oparms)\n{\n\tstruct smb2_create_req *req = iov[0].iov_base;\n\tunsigned int num = *num_iovec;\n\n\tiov[num].iov_base = create_durable_v2_buf(oparms->fid);\n\tif (iov[num].iov_base == NULL)\n\t\treturn -ENOMEM;\n\tiov[num].iov_len = sizeof(struct create_durable_v2);\n\tif (!req->CreateContextsOffset)\n\t\treq->CreateContextsOffset =\n\t\t\tcpu_to_le32(sizeof(struct smb2_create_req) - 4 +\n\t\t\t\t\t\t\t\tiov[1].iov_len);\n\tle32_add_cpu(&req->CreateContextsLength, sizeof(struct create_durable_v2));\n\tinc_rfc1001_len(&req->hdr, sizeof(struct create_durable_v2));\n\t*num_iovec = num + 1;\n\treturn 0;\n}\n\nstatic int\nadd_durable_reconnect_v2_context(struct kvec *iov, unsigned int *num_iovec,\n\t\t    struct cifs_open_parms *oparms)\n{\n\tstruct smb2_create_req *req = iov[0].iov_base;\n\tunsigned int num = *num_iovec;\n\n\t/* indicate that we don't need to relock the file */\n\toparms->reconnect = false;\n\n\tiov[num].iov_base = create_reconnect_durable_v2_buf(oparms->fid);\n\tif (iov[num].iov_base == NULL)\n\t\treturn -ENOMEM;\n\tiov[num].iov_len = sizeof(struct create_durable_handle_reconnect_v2);\n\tif (!req->CreateContextsOffset)\n\t\treq->CreateContextsOffset =\n\t\t\tcpu_to_le32(sizeof(struct smb2_create_req) - 4 +\n\t\t\t\t\t\t\t\tiov[1].iov_len);\n\tle32_add_cpu(&req->CreateContextsLength,\n\t\t\tsizeof(struct create_durable_handle_reconnect_v2));\n\tinc_rfc1001_len(&req->hdr,\n\t\t\tsizeof(struct create_durable_handle_reconnect_v2));\n\t*num_iovec = num + 1;\n\treturn 0;\n}\n\nstatic int\nadd_durable_context(struct kvec *iov, unsigned int *num_iovec,\n\t\t    struct cifs_open_parms *oparms, bool use_persistent)\n{\n\tstruct smb2_create_req *req = iov[0].iov_base;\n\tunsigned int num = *num_iovec;\n\n\tif (use_persistent) {\n\t\tif (oparms->reconnect)\n\t\t\treturn add_durable_reconnect_v2_context(iov, num_iovec,\n\t\t\t\t\t\t\t\toparms);\n\t\telse\n\t\t\treturn add_durable_v2_context(iov, num_iovec, oparms);\n\t}\n\n\tif (oparms->reconnect) {\n\t\tiov[num].iov_base = create_reconnect_durable_buf(oparms->fid);\n\t\t/* indicate that we don't need to relock the file */\n\t\toparms->reconnect = false;\n\t} else\n\t\tiov[num].iov_base = create_durable_buf();\n\tif (iov[num].iov_base == NULL)\n\t\treturn -ENOMEM;\n\tiov[num].iov_len = sizeof(struct create_durable);\n\tif (!req->CreateContextsOffset)\n\t\treq->CreateContextsOffset =\n\t\t\tcpu_to_le32(sizeof(struct smb2_create_req) - 4 +\n\t\t\t\t\t\t\t\tiov[1].iov_len);\n\tle32_add_cpu(&req->CreateContextsLength, sizeof(struct create_durable));\n\tinc_rfc1001_len(&req->hdr, sizeof(struct create_durable));\n\t*num_iovec = num + 1;\n\treturn 0;\n}\n\nint\nSMB2_open(const unsigned int xid, struct cifs_open_parms *oparms, __le16 *path,\n\t  __u8 *oplock, struct smb2_file_all_info *buf,\n\t  struct smb2_err_rsp **err_buf)\n{\n\tstruct smb2_create_req *req;\n\tstruct smb2_create_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[4];\n\tstruct kvec rsp_iov;\n\tint resp_buftype;\n\tint uni_path_len;\n\t__le16 *copy_path = NULL;\n\tint copy_size;\n\tint rc = 0;\n\tunsigned int n_iov = 2;\n\t__u32 file_attributes = 0;\n\tchar *dhc_buf = NULL, *lc_buf = NULL;\n\tint flags = 0;\n\n\tcifs_dbg(FYI, \"create/open\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CREATE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tif (oparms->create_options & CREATE_OPTION_READONLY)\n\t\tfile_attributes |= ATTR_READONLY;\n\tif (oparms->create_options & CREATE_OPTION_SPECIAL)\n\t\tfile_attributes |= ATTR_SYSTEM;\n\n\treq->ImpersonationLevel = IL_IMPERSONATION;\n\treq->DesiredAccess = cpu_to_le32(oparms->desired_access);\n\t/* File attributes ignored on open (used in create though) */\n\treq->FileAttributes = cpu_to_le32(file_attributes);\n\treq->ShareAccess = FILE_SHARE_ALL_LE;\n\treq->CreateDisposition = cpu_to_le32(oparms->disposition);\n\treq->CreateOptions = cpu_to_le32(oparms->create_options & CREATE_OPTIONS_MASK);\n\tuni_path_len = (2 * UniStrnlen((wchar_t *)path, PATH_MAX)) + 2;\n\t/* do not count rfc1001 len field */\n\treq->NameOffset = cpu_to_le16(sizeof(struct smb2_create_req) - 4);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\t/* MUST set path len (NameLength) to 0 opening root of share */\n\treq->NameLength = cpu_to_le16(uni_path_len - 2);\n\t/* -1 since last byte is buf[0] which is sent below (path) */\n\tiov[0].iov_len--;\n\tif (uni_path_len % 8 != 0) {\n\t\tcopy_size = uni_path_len / 8 * 8;\n\t\tif (copy_size < uni_path_len)\n\t\t\tcopy_size += 8;\n\n\t\tcopy_path = kzalloc(copy_size, GFP_KERNEL);\n\t\tif (!copy_path)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy((char *)copy_path, (const char *)path,\n\t\t\tuni_path_len);\n\t\tuni_path_len = copy_size;\n\t\tpath = copy_path;\n\t}\n\n\tiov[1].iov_len = uni_path_len;\n\tiov[1].iov_base = path;\n\t/* -1 since last byte is buf[0] which was counted in smb2_buf_len */\n\tinc_rfc1001_len(req, uni_path_len - 1);\n\n\tif (!server->oplocks)\n\t\t*oplock = SMB2_OPLOCK_LEVEL_NONE;\n\n\tif (!(server->capabilities & SMB2_GLOBAL_CAP_LEASING) ||\n\t    *oplock == SMB2_OPLOCK_LEVEL_NONE)\n\t\treq->RequestedOplockLevel = *oplock;\n\telse {\n\t\trc = add_lease_context(server, iov, &n_iov, oplock);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\treturn rc;\n\t\t}\n\t\tlc_buf = iov[n_iov-1].iov_base;\n\t}\n\n\tif (*oplock == SMB2_OPLOCK_LEVEL_BATCH) {\n\t\t/* need to set Next field of lease context if we request it */\n\t\tif (server->capabilities & SMB2_GLOBAL_CAP_LEASING) {\n\t\t\tstruct create_context *ccontext =\n\t\t\t    (struct create_context *)iov[n_iov-1].iov_base;\n\t\t\tccontext->Next =\n\t\t\t\tcpu_to_le32(server->vals->create_lease_size);\n\t\t}\n\n\t\trc = add_durable_context(iov, &n_iov, oparms,\n\t\t\t\t\ttcon->use_persistent);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\tkfree(lc_buf);\n\t\t\treturn rc;\n\t\t}\n\t\tdhc_buf = iov[n_iov-1].iov_base;\n\t}\n\n\trc = SendReceive2(xid, ses, iov, n_iov, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\trsp = (struct smb2_create_rsp *)rsp_iov.iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CREATE_HE);\n\t\tif (err_buf)\n\t\t\t*err_buf = kmemdup(rsp, get_rfc1002_length(rsp) + 4,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tgoto creat_exit;\n\t}\n\n\toparms->fid->persistent_fid = rsp->PersistentFileId;\n\toparms->fid->volatile_fid = rsp->VolatileFileId;\n\n\tif (buf) {\n\t\tmemcpy(buf, &rsp->CreationTime, 32);\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndofFile;\n\t\tbuf->Attributes = rsp->FileAttributes;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tif (rsp->OplockLevel == SMB2_OPLOCK_LEVEL_LEASE)\n\t\t*oplock = parse_lease_state(server, rsp, &oparms->fid->epoch);\n\telse\n\t\t*oplock = rsp->OplockLevel;\ncreat_exit:\n\tkfree(copy_path);\n\tkfree(lc_buf);\n\tkfree(dhc_buf);\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}\n\n/*\n *\tSMB2 IOCTL is used for both IOCTLs and FSCTLs\n */\nint\nSMB2_ioctl(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t   u64 volatile_fid, u32 opcode, bool is_fsctl, char *in_data,\n\t   u32 indatalen, char **out_data, u32 *plen /* returned data len */)\n{\n\tstruct smb2_ioctl_req *req;\n\tstruct smb2_ioctl_rsp *rsp;\n\tstruct smb2_sync_hdr *shdr;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses;\n\tstruct kvec iov[2];\n\tstruct kvec rsp_iov;\n\tint resp_buftype;\n\tint n_iov;\n\tint rc = 0;\n\tint flags = 0;\n\n\tcifs_dbg(FYI, \"SMB2 IOCTL\\n\");\n\n\tif (out_data != NULL)\n\t\t*out_data = NULL;\n\n\t/* zero out returned data len, in case of error */\n\tif (plen)\n\t\t*plen = 0;\n\n\tif (tcon)\n\t\tses = tcon->ses;\n\telse\n\t\treturn -EIO;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_IOCTL, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq->CtlCode = cpu_to_le32(opcode);\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tif (indatalen) {\n\t\treq->InputCount = cpu_to_le32(indatalen);\n\t\t/* do not set InputOffset if no input data */\n\t\treq->InputOffset =\n\t\t       cpu_to_le32(offsetof(struct smb2_ioctl_req, Buffer) - 4);\n\t\tiov[1].iov_base = in_data;\n\t\tiov[1].iov_len = indatalen;\n\t\tn_iov = 2;\n\t} else\n\t\tn_iov = 1;\n\n\treq->OutputOffset = 0;\n\treq->OutputCount = 0; /* MBZ */\n\n\t/*\n\t * Could increase MaxOutputResponse, but that would require more\n\t * than one credit. Windows typically sets this smaller, but for some\n\t * ioctls it may be useful to allow server to send more. No point\n\t * limiting what the server can send as long as fits in one credit\n\t */\n\treq->MaxOutputResponse = cpu_to_le32(0xFF00); /* < 64K uses 1 credit */\n\n\tif (is_fsctl)\n\t\treq->Flags = cpu_to_le32(SMB2_0_IOCTL_IS_FSCTL);\n\telse\n\t\treq->Flags = 0;\n\n\tiov[0].iov_base = (char *)req;\n\n\t/*\n\t * If no input data, the size of ioctl struct in\n\t * protocol spec still includes a 1 byte data buffer,\n\t * but if input data passed to ioctl, we do not\n\t * want to double count this, so we do not send\n\t * the dummy one byte of data in iovec[0] if sending\n\t * input data (in iovec[1]). We also must add 4 bytes\n\t * in first iovec to allow for rfc1002 length field.\n\t */\n\n\tif (indatalen) {\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\t\tinc_rfc1001_len(req, indatalen - 1);\n\t} else\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\n\trc = SendReceive2(xid, ses, iov, n_iov, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\trsp = (struct smb2_ioctl_rsp *)rsp_iov.iov_base;\n\n\tif ((rc != 0) && (rc != -EINVAL)) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\tgoto ioctl_exit;\n\t} else if (rc == -EINVAL) {\n\t\tif ((opcode != FSCTL_SRV_COPYCHUNK_WRITE) &&\n\t\t    (opcode != FSCTL_SRV_COPYCHUNK)) {\n\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\t\tgoto ioctl_exit;\n\t\t}\n\t}\n\n\t/* check if caller wants to look at return data or just return rc */\n\tif ((plen == NULL) || (out_data == NULL))\n\t\tgoto ioctl_exit;\n\n\t*plen = le32_to_cpu(rsp->OutputCount);\n\n\t/* We check for obvious errors in the output buffer length and offset */\n\tif (*plen == 0)\n\t\tgoto ioctl_exit; /* server returned no data */\n\telse if (*plen > 0xFF00) {\n\t\tcifs_dbg(VFS, \"srv returned invalid ioctl length: %d\\n\", *plen);\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\tif (get_rfc1002_length(rsp) < le32_to_cpu(rsp->OutputOffset) + *plen) {\n\t\tcifs_dbg(VFS, \"Malformed ioctl resp: len %d offset %d\\n\", *plen,\n\t\t\tle32_to_cpu(rsp->OutputOffset));\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\t*out_data = kmalloc(*plen, GFP_KERNEL);\n\tif (*out_data == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto ioctl_exit;\n\t}\n\n\tshdr = get_sync_hdr(rsp);\n\tmemcpy(*out_data, (char *)shdr + le32_to_cpu(rsp->OutputOffset), *plen);\nioctl_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}\n\n/*\n *   Individual callers to ioctl worker function follow\n */\n\nint\nSMB2_set_compression(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     u64 persistent_fid, u64 volatile_fid)\n{\n\tint rc;\n\tstruct  compress_ioctl fsctl_input;\n\tchar *ret_data = NULL;\n\n\tfsctl_input.CompressionState =\n\t\t\tcpu_to_le16(COMPRESSION_FORMAT_DEFAULT);\n\n\trc = SMB2_ioctl(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tFSCTL_SET_COMPRESSION, true /* is_fsctl */,\n\t\t\t(char *)&fsctl_input /* data input */,\n\t\t\t2 /* in data len */, &ret_data /* out data */, NULL);\n\n\tcifs_dbg(FYI, \"set compression rc %d\\n\", rc);\n\n\treturn rc;\n}\n\nint\nSMB2_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t   u64 persistent_fid, u64 volatile_fid)\n{\n\tstruct smb2_close_req *req;\n\tstruct smb2_close_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tint resp_buftype;\n\tint rc = 0;\n\tint flags = 0;\n\n\tcifs_dbg(FYI, \"Close\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CLOSE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\trsp = (struct smb2_close_rsp *)rsp_iov.iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CLOSE_HE);\n\t\tgoto close_exit;\n\t}\n\n\t/* BB FIXME - decode close response, update inode for caching */\n\nclose_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}\n\nstatic int\nvalidate_buf(unsigned int offset, unsigned int buffer_length,\n\t     struct smb2_hdr *hdr, unsigned int min_buf_size)\n\n{\n\tunsigned int smb_len = be32_to_cpu(hdr->smb2_buf_length);\n\tchar *end_of_smb = smb_len + 4 /* RFC1001 length field */ + (char *)hdr;\n\tchar *begin_of_buf = 4 /* RFC1001 len field */ + offset + (char *)hdr;\n\tchar *end_of_buf = begin_of_buf + buffer_length;\n\n\n\tif (buffer_length < min_buf_size) {\n\t\tcifs_dbg(VFS, \"buffer length %d smaller than minimum size %d\\n\",\n\t\t\t buffer_length, min_buf_size);\n\t\treturn -EINVAL;\n\t}\n\n\t/* check if beyond RFC1001 maximum length */\n\tif ((smb_len > 0x7FFFFF) || (buffer_length > 0x7FFFFF)) {\n\t\tcifs_dbg(VFS, \"buffer length %d or smb length %d too large\\n\",\n\t\t\t buffer_length, smb_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((begin_of_buf > end_of_smb) || (end_of_buf > end_of_smb)) {\n\t\tcifs_dbg(VFS, \"illegal server response, bad offset to data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/*\n * If SMB buffer fields are valid, copy into temporary buffer to hold result.\n * Caller must free buffer.\n */\nstatic int\nvalidate_and_copy_buf(unsigned int offset, unsigned int buffer_length,\n\t\t      struct smb2_hdr *hdr, unsigned int minbufsize,\n\t\t      char *data)\n\n{\n\tchar *begin_of_buf = 4 /* RFC1001 len field */ + offset + (char *)hdr;\n\tint rc;\n\n\tif (!data)\n\t\treturn -EINVAL;\n\n\trc = validate_buf(offset, buffer_length, hdr, minbufsize);\n\tif (rc)\n\t\treturn rc;\n\n\tmemcpy(data, begin_of_buf, buffer_length);\n\n\treturn 0;\n}\n\nstatic int\nquery_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t   u64 persistent_fid, u64 volatile_fid, u8 info_class,\n\t   size_t output_len, size_t min_len, void *data)\n{\n\tstruct smb2_query_info_req *req;\n\tstruct smb2_query_info_rsp *rsp = NULL;\n\tstruct kvec iov[2];\n\tstruct kvec rsp_iov;\n\tint rc = 0;\n\tint resp_buftype;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tint flags = 0;\n\n\tcifs_dbg(FYI, \"Query Info\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_QUERY_INFO, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq->InfoType = SMB2_O_INFO_FILE;\n\treq->FileInfoClass = info_class;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\t/* 4 for rfc1002 length field and 1 for Buffer */\n\treq->InputBufferOffset =\n\t\tcpu_to_le16(sizeof(struct smb2_query_info_req) - 1 - 4);\n\treq->OutputBufferLength = cpu_to_le32(output_len);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\trsp = (struct smb2_query_info_rsp *)rsp_iov.iov_base;\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_INFO_HE);\n\t\tgoto qinf_exit;\n\t}\n\n\trc = validate_and_copy_buf(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t\t   le32_to_cpu(rsp->OutputBufferLength),\n\t\t\t\t   &rsp->hdr, min_len, data);\n\nqinf_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}\n\nint\nSMB2_query_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tu64 persistent_fid, u64 volatile_fid,\n\t\tstruct smb2_file_all_info *data)\n{\n\treturn query_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t  FILE_ALL_INFORMATION,\n\t\t\t  sizeof(struct smb2_file_all_info) + PATH_MAX * 2,\n\t\t\t  sizeof(struct smb2_file_all_info), data);\n}\n\nint\nSMB2_get_srv_num(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t u64 persistent_fid, u64 volatile_fid, __le64 *uniqueid)\n{\n\treturn query_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t  FILE_INTERNAL_INFORMATION,\n\t\t\t  sizeof(struct smb2_file_internal_info),\n\t\t\t  sizeof(struct smb2_file_internal_info), uniqueid);\n}\n\n/*\n * This is a no-op for now. We're not really interested in the reply, but\n * rather in the fact that the server sent one and that server->lstrp\n * gets updated.\n *\n * FIXME: maybe we should consider checking that the reply matches request?\n */\nstatic void\nsmb2_echo_callback(struct mid_q_entry *mid)\n{\n\tstruct TCP_Server_Info *server = mid->callback_data;\n\tstruct smb2_echo_rsp *rsp = (struct smb2_echo_rsp *)mid->resp_buf;\n\tunsigned int credits_received = 1;\n\n\tif (mid->mid_state == MID_RESPONSE_RECEIVED)\n\t\tcredits_received = le16_to_cpu(rsp->hdr.sync_hdr.CreditRequest);\n\n\tmutex_lock(&server->srv_mutex);\n\tDeleteMidQEntry(mid);\n\tmutex_unlock(&server->srv_mutex);\n\tadd_credits(server, credits_received, CIFS_ECHO_OP);\n}\n\nvoid smb2_reconnect_server(struct work_struct *work)\n{\n\tstruct TCP_Server_Info *server = container_of(work,\n\t\t\t\t\tstruct TCP_Server_Info, reconnect.work);\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon, *tcon2;\n\tstruct list_head tmp_list;\n\tint tcon_exist = false;\n\n\t/* Prevent simultaneous reconnects that can corrupt tcon->rlist list */\n\tmutex_lock(&server->reconnect_mutex);\n\n\tINIT_LIST_HEAD(&tmp_list);\n\tcifs_dbg(FYI, \"Need negotiate, reconnecting tcons\\n\");\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {\n\t\tlist_for_each_entry(tcon, &ses->tcon_list, tcon_list) {\n\t\t\tif (tcon->need_reconnect || tcon->need_reopen_files) {\n\t\t\t\ttcon->tc_count++;\n\t\t\t\tlist_add_tail(&tcon->rlist, &tmp_list);\n\t\t\t\ttcon_exist = true;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * Get the reference to server struct to be sure that the last call of\n\t * cifs_put_tcon() in the loop below won't release the server pointer.\n\t */\n\tif (tcon_exist)\n\t\tserver->srv_count++;\n\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tlist_for_each_entry_safe(tcon, tcon2, &tmp_list, rlist) {\n\t\tif (!smb2_reconnect(SMB2_INTERNAL_CMD, tcon))\n\t\t\tcifs_reopen_persistent_handles(tcon);\n\t\tlist_del_init(&tcon->rlist);\n\t\tcifs_put_tcon(tcon);\n\t}\n\n\tcifs_dbg(FYI, \"Reconnecting tcons finished\\n\");\n\tmutex_unlock(&server->reconnect_mutex);\n\n\t/* now we can safely release srv struct */\n\tif (tcon_exist)\n\t\tcifs_put_tcp_session(server, 1);\n}\n\nint\nSMB2_echo(struct TCP_Server_Info *server)\n{\n\tstruct smb2_echo_req *req;\n\tint rc = 0;\n\tstruct kvec iov[2];\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = 2 };\n\n\tcifs_dbg(FYI, \"In echo request\\n\");\n\n\tif (server->tcpStatus == CifsNeedNegotiate) {\n\t\t/* No need to send echo on newly established connections */\n\t\tqueue_delayed_work(cifsiod_wq, &server->reconnect, 0);\n\t\treturn rc;\n\t}\n\n\trc = small_smb2_init(SMB2_ECHO, NULL, (void **)&req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->hdr.sync_hdr.CreditRequest = cpu_to_le16(1);\n\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = 4;\n\tiov[0].iov_base = (char *)req;\n\tiov[1].iov_len = get_rfc1002_length(req);\n\tiov[1].iov_base = (char *)req + 4;\n\n\trc = cifs_call_async(server, &rqst, NULL, smb2_echo_callback, server,\n\t\t\t     CIFS_ECHO_OP);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Echo request failed: %d\\n\", rc);\n\n\tcifs_small_buf_release(req);\n\treturn rc;\n}\n\nint\nSMB2_flush(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t   u64 volatile_fid)\n{\n\tstruct smb2_flush_req *req;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tint resp_buftype;\n\tint rc = 0;\n\tint flags = 0;\n\n\tcifs_dbg(FYI, \"Flush\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_FLUSH, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\n\tif (rc != 0)\n\t\tcifs_stats_fail_inc(tcon, SMB2_FLUSH_HE);\n\n\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\treturn rc;\n}\n\n/*\n * To form a chain of read requests, any read requests after the first should\n * have the end_of_chain boolean set to true.\n */\nstatic int\nsmb2_new_read_req(void **buf, unsigned int *total_len,\n\t\t  struct cifs_io_parms *io_parms, unsigned int remaining_bytes,\n\t\t  int request_type)\n{\n\tint rc = -EACCES;\n\tstruct smb2_read_plain_req *req = NULL;\n\tstruct smb2_sync_hdr *shdr;\n\n\trc = smb2_plain_req_init(SMB2_READ, io_parms->tcon, (void **) &req,\n\t\t\t\t total_len);\n\tif (rc)\n\t\treturn rc;\n\tif (io_parms->tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tshdr = &req->sync_hdr;\n\tshdr->ProcessId = cpu_to_le32(io_parms->pid);\n\n\treq->PersistentFileId = io_parms->persistent_fid;\n\treq->VolatileFileId = io_parms->volatile_fid;\n\treq->ReadChannelInfoOffset = 0; /* reserved */\n\treq->ReadChannelInfoLength = 0; /* reserved */\n\treq->Channel = 0; /* reserved */\n\treq->MinimumCount = 0;\n\treq->Length = cpu_to_le32(io_parms->length);\n\treq->Offset = cpu_to_le64(io_parms->offset);\n\n\tif (request_type & CHAINED_REQUEST) {\n\t\tif (!(request_type & END_OF_CHAIN)) {\n\t\t\t/* next 8-byte aligned request */\n\t\t\t*total_len = DIV_ROUND_UP(*total_len, 8) * 8;\n\t\t\tshdr->NextCommand = cpu_to_le32(*total_len);\n\t\t} else /* END_OF_CHAIN */\n\t\t\tshdr->NextCommand = 0;\n\t\tif (request_type & RELATED_REQUEST) {\n\t\t\tshdr->Flags |= SMB2_FLAGS_RELATED_OPERATIONS;\n\t\t\t/*\n\t\t\t * Related requests use info from previous read request\n\t\t\t * in chain.\n\t\t\t */\n\t\t\tshdr->SessionId = 0xFFFFFFFF;\n\t\t\tshdr->TreeId = 0xFFFFFFFF;\n\t\t\treq->PersistentFileId = 0xFFFFFFFF;\n\t\t\treq->VolatileFileId = 0xFFFFFFFF;\n\t\t}\n\t}\n\tif (remaining_bytes > io_parms->length)\n\t\treq->RemainingBytes = cpu_to_le32(remaining_bytes);\n\telse\n\t\treq->RemainingBytes = 0;\n\n\t*buf = req;\n\treturn rc;\n}\n\nstatic void\nsmb2_readv_callback(struct mid_q_entry *mid)\n{\n\tstruct cifs_readdata *rdata = mid->callback_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(rdata->cfile->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct smb2_sync_hdr *shdr =\n\t\t\t\t(struct smb2_sync_hdr *)rdata->iov[1].iov_base;\n\tunsigned int credits_received = 1;\n\tstruct smb_rqst rqst = { .rq_iov = rdata->iov,\n\t\t\t\t .rq_nvec = 2,\n\t\t\t\t .rq_pages = rdata->pages,\n\t\t\t\t .rq_npages = rdata->nr_pages,\n\t\t\t\t .rq_pagesz = rdata->pagesz,\n\t\t\t\t .rq_tailsz = rdata->tailsz };\n\n\tcifs_dbg(FYI, \"%s: mid=%llu state=%d result=%d bytes=%u\\n\",\n\t\t __func__, mid->mid, mid->mid_state, rdata->result,\n\t\t rdata->bytes);\n\n\tswitch (mid->mid_state) {\n\tcase MID_RESPONSE_RECEIVED:\n\t\tcredits_received = le16_to_cpu(shdr->CreditRequest);\n\t\t/* result already set, check signature */\n\t\tif (server->sign) {\n\t\t\tint rc;\n\n\t\t\trc = smb2_verify_signature(&rqst, server);\n\t\t\tif (rc)\n\t\t\t\tcifs_dbg(VFS, \"SMB signature verification returned error = %d\\n\",\n\t\t\t\t\t rc);\n\t\t}\n\t\t/* FIXME: should this be counted toward the initiating task? */\n\t\ttask_io_account_read(rdata->got_bytes);\n\t\tcifs_stats_bytes_read(tcon, rdata->got_bytes);\n\t\tbreak;\n\tcase MID_REQUEST_SUBMITTED:\n\tcase MID_RETRY_NEEDED:\n\t\trdata->result = -EAGAIN;\n\t\tif (server->sign && rdata->got_bytes)\n\t\t\t/* reset bytes number since we can not check a sign */\n\t\t\trdata->got_bytes = 0;\n\t\t/* FIXME: should this be counted toward the initiating task? */\n\t\ttask_io_account_read(rdata->got_bytes);\n\t\tcifs_stats_bytes_read(tcon, rdata->got_bytes);\n\t\tbreak;\n\tdefault:\n\t\tif (rdata->result != -ENODATA)\n\t\t\trdata->result = -EIO;\n\t}\n\n\tif (rdata->result)\n\t\tcifs_stats_fail_inc(tcon, SMB2_READ_HE);\n\n\tqueue_work(cifsiod_wq, &rdata->work);\n\tmutex_lock(&server->srv_mutex);\n\tDeleteMidQEntry(mid);\n\tmutex_unlock(&server->srv_mutex);\n\tadd_credits(server, credits_received, 0);\n}\n\n/* smb2_async_readv - send an async read, and set up mid to handle result */\nint\nsmb2_async_readv(struct cifs_readdata *rdata)\n{\n\tint rc, flags = 0;\n\tchar *buf;\n\tstruct smb2_sync_hdr *shdr;\n\tstruct cifs_io_parms io_parms;\n\tstruct smb_rqst rqst = { .rq_iov = rdata->iov,\n\t\t\t\t .rq_nvec = 2 };\n\tstruct TCP_Server_Info *server;\n\tunsigned int total_len;\n\t__be32 req_len;\n\n\tcifs_dbg(FYI, \"%s: offset=%llu bytes=%u\\n\",\n\t\t __func__, rdata->offset, rdata->bytes);\n\n\tio_parms.tcon = tlink_tcon(rdata->cfile->tlink);\n\tio_parms.offset = rdata->offset;\n\tio_parms.length = rdata->bytes;\n\tio_parms.persistent_fid = rdata->cfile->fid.persistent_fid;\n\tio_parms.volatile_fid = rdata->cfile->fid.volatile_fid;\n\tio_parms.pid = rdata->pid;\n\n\tserver = io_parms.tcon->ses->server;\n\n\trc = smb2_new_read_req((void **) &buf, &total_len, &io_parms, 0, 0);\n\tif (rc) {\n\t\tif (rc == -EAGAIN && rdata->credits) {\n\t\t\t/* credits was reset by reconnect */\n\t\t\trdata->credits = 0;\n\t\t\t/* reduce in_flight value since we won't send the req */\n\t\t\tspin_lock(&server->req_lock);\n\t\t\tserver->in_flight--;\n\t\t\tspin_unlock(&server->req_lock);\n\t\t}\n\t\treturn rc;\n\t}\n\n\tif (encryption_required(io_parms.tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq_len = cpu_to_be32(total_len);\n\n\trdata->iov[0].iov_base = &req_len;\n\trdata->iov[0].iov_len = sizeof(__be32);\n\trdata->iov[1].iov_base = buf;\n\trdata->iov[1].iov_len = total_len;\n\n\tshdr = (struct smb2_sync_hdr *)buf;\n\n\tif (rdata->credits) {\n\t\tshdr->CreditCharge = cpu_to_le16(DIV_ROUND_UP(rdata->bytes,\n\t\t\t\t\t\tSMB2_MAX_BUFFER_SIZE));\n\t\tshdr->CreditRequest = shdr->CreditCharge;\n\t\tspin_lock(&server->req_lock);\n\t\tserver->credits += rdata->credits -\n\t\t\t\t\t\tle16_to_cpu(shdr->CreditCharge);\n\t\tspin_unlock(&server->req_lock);\n\t\twake_up(&server->request_q);\n\t\tflags |= CIFS_HAS_CREDITS;\n\t}\n\n\tkref_get(&rdata->refcount);\n\trc = cifs_call_async(io_parms.tcon->ses->server, &rqst,\n\t\t\t     cifs_readv_receive, smb2_readv_callback,\n\t\t\t     rdata, flags);\n\tif (rc) {\n\t\tkref_put(&rdata->refcount, cifs_readdata_release);\n\t\tcifs_stats_fail_inc(io_parms.tcon, SMB2_READ_HE);\n\t}\n\n\tcifs_small_buf_release(buf);\n\treturn rc;\n}\n\nint\nSMB2_read(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t  unsigned int *nbytes, char **buf, int *buf_type)\n{\n\tint resp_buftype, rc = -EACCES;\n\tstruct smb2_read_plain_req *req = NULL;\n\tstruct smb2_read_rsp *rsp = NULL;\n\tstruct smb2_sync_hdr *shdr;\n\tstruct kvec iov[2];\n\tstruct kvec rsp_iov;\n\tunsigned int total_len;\n\t__be32 req_len;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = 2 };\n\tint flags = CIFS_LOG_ERROR;\n\tstruct cifs_ses *ses = io_parms->tcon->ses;\n\n\t*nbytes = 0;\n\trc = smb2_new_read_req((void **)&req, &total_len, io_parms, 0, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tif (encryption_required(io_parms->tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq_len = cpu_to_be32(total_len);\n\n\tiov[0].iov_base = &req_len;\n\tiov[0].iov_len = sizeof(__be32);\n\tiov[1].iov_base = req;\n\tiov[1].iov_len = total_len;\n\n\trc = cifs_send_recv(xid, ses, &rqst, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\n\trsp = (struct smb2_read_rsp *)rsp_iov.iov_base;\n\tshdr = get_sync_hdr(rsp);\n\n\tif (shdr->Status == STATUS_END_OF_FILE) {\n\t\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\t\treturn 0;\n\t}\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(io_parms->tcon, SMB2_READ_HE);\n\t\tcifs_dbg(VFS, \"Send error in read = %d\\n\", rc);\n\t} else {\n\t\t*nbytes = le32_to_cpu(rsp->DataLength);\n\t\tif ((*nbytes > CIFS_MAX_MSGSIZE) ||\n\t\t    (*nbytes > io_parms->length)) {\n\t\t\tcifs_dbg(FYI, \"bad length %d for count %d\\n\",\n\t\t\t\t *nbytes, io_parms->length);\n\t\t\trc = -EIO;\n\t\t\t*nbytes = 0;\n\t\t}\n\t}\n\n\tif (*buf) {\n\t\tmemcpy(*buf, (char *)shdr + rsp->DataOffset, *nbytes);\n\t\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\t} else if (resp_buftype != CIFS_NO_BUFFER) {\n\t\t*buf = rsp_iov.iov_base;\n\t\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\t\t*buf_type = CIFS_SMALL_BUFFER;\n\t\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\t\t*buf_type = CIFS_LARGE_BUFFER;\n\t}\n\treturn rc;\n}\n\n/*\n * Check the mid_state and signature on received buffer (if any), and queue the\n * workqueue completion task.\n */\nstatic void\nsmb2_writev_callback(struct mid_q_entry *mid)\n{\n\tstruct cifs_writedata *wdata = mid->callback_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(wdata->cfile->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tunsigned int written;\n\tstruct smb2_write_rsp *rsp = (struct smb2_write_rsp *)mid->resp_buf;\n\tunsigned int credits_received = 1;\n\n\tswitch (mid->mid_state) {\n\tcase MID_RESPONSE_RECEIVED:\n\t\tcredits_received = le16_to_cpu(rsp->hdr.sync_hdr.CreditRequest);\n\t\twdata->result = smb2_check_receive(mid, tcon->ses->server, 0);\n\t\tif (wdata->result != 0)\n\t\t\tbreak;\n\n\t\twritten = le32_to_cpu(rsp->DataLength);\n\t\t/*\n\t\t * Mask off high 16 bits when bytes written as returned\n\t\t * by the server is greater than bytes requested by the\n\t\t * client. OS/2 servers are known to set incorrect\n\t\t * CountHigh values.\n\t\t */\n\t\tif (written > wdata->bytes)\n\t\t\twritten &= 0xFFFF;\n\n\t\tif (written < wdata->bytes)\n\t\t\twdata->result = -ENOSPC;\n\t\telse\n\t\t\twdata->bytes = written;\n\t\tbreak;\n\tcase MID_REQUEST_SUBMITTED:\n\tcase MID_RETRY_NEEDED:\n\t\twdata->result = -EAGAIN;\n\t\tbreak;\n\tdefault:\n\t\twdata->result = -EIO;\n\t\tbreak;\n\t}\n\n\tif (wdata->result)\n\t\tcifs_stats_fail_inc(tcon, SMB2_WRITE_HE);\n\n\tqueue_work(cifsiod_wq, &wdata->work);\n\tmutex_lock(&server->srv_mutex);\n\tDeleteMidQEntry(mid);\n\tmutex_unlock(&server->srv_mutex);\n\tadd_credits(tcon->ses->server, credits_received, 0);\n}\n\n/* smb2_async_writev - send an async write, and set up mid to handle result */\nint\nsmb2_async_writev(struct cifs_writedata *wdata,\n\t\t  void (*release)(struct kref *kref))\n{\n\tint rc = -EACCES, flags = 0;\n\tstruct smb2_write_req *req = NULL;\n\tstruct smb2_sync_hdr *shdr;\n\tstruct cifs_tcon *tcon = tlink_tcon(wdata->cfile->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct kvec iov[2];\n\tstruct smb_rqst rqst = { };\n\n\trc = small_smb2_init(SMB2_WRITE, tcon, (void **) &req);\n\tif (rc) {\n\t\tif (rc == -EAGAIN && wdata->credits) {\n\t\t\t/* credits was reset by reconnect */\n\t\t\twdata->credits = 0;\n\t\t\t/* reduce in_flight value since we won't send the req */\n\t\t\tspin_lock(&server->req_lock);\n\t\t\tserver->in_flight--;\n\t\t\tspin_unlock(&server->req_lock);\n\t\t}\n\t\tgoto async_writev_out;\n\t}\n\n\tif (encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tshdr = get_sync_hdr(req);\n\tshdr->ProcessId = cpu_to_le32(wdata->cfile->pid);\n\n\treq->PersistentFileId = wdata->cfile->fid.persistent_fid;\n\treq->VolatileFileId = wdata->cfile->fid.volatile_fid;\n\treq->WriteChannelInfoOffset = 0;\n\treq->WriteChannelInfoLength = 0;\n\treq->Channel = 0;\n\treq->Offset = cpu_to_le64(wdata->offset);\n\t/* 4 for rfc1002 length field */\n\treq->DataOffset = cpu_to_le16(\n\t\t\t\toffsetof(struct smb2_write_req, Buffer) - 4);\n\treq->RemainingBytes = 0;\n\n\t/* 4 for rfc1002 length field and 1 for Buffer */\n\tiov[0].iov_len = 4;\n\tiov[0].iov_base = req;\n\tiov[1].iov_len = get_rfc1002_length(req) - 1;\n\tiov[1].iov_base = (char *)req + 4;\n\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 2;\n\trqst.rq_pages = wdata->pages;\n\trqst.rq_npages = wdata->nr_pages;\n\trqst.rq_pagesz = wdata->pagesz;\n\trqst.rq_tailsz = wdata->tailsz;\n\n\tcifs_dbg(FYI, \"async write at %llu %u bytes\\n\",\n\t\t wdata->offset, wdata->bytes);\n\n\treq->Length = cpu_to_le32(wdata->bytes);\n\n\tinc_rfc1001_len(&req->hdr, wdata->bytes - 1 /* Buffer */);\n\n\tif (wdata->credits) {\n\t\tshdr->CreditCharge = cpu_to_le16(DIV_ROUND_UP(wdata->bytes,\n\t\t\t\t\t\t    SMB2_MAX_BUFFER_SIZE));\n\t\tshdr->CreditRequest = shdr->CreditCharge;\n\t\tspin_lock(&server->req_lock);\n\t\tserver->credits += wdata->credits -\n\t\t\t\t\t\tle16_to_cpu(shdr->CreditCharge);\n\t\tspin_unlock(&server->req_lock);\n\t\twake_up(&server->request_q);\n\t\tflags |= CIFS_HAS_CREDITS;\n\t}\n\n\tkref_get(&wdata->refcount);\n\trc = cifs_call_async(server, &rqst, NULL, smb2_writev_callback, wdata,\n\t\t\t     flags);\n\n\tif (rc) {\n\t\tkref_put(&wdata->refcount, release);\n\t\tcifs_stats_fail_inc(tcon, SMB2_WRITE_HE);\n\t}\n\nasync_writev_out:\n\tcifs_small_buf_release(req);\n\treturn rc;\n}\n\n/*\n * SMB2_write function gets iov pointer to kvec array with n_vec as a length.\n * The length field from io_parms must be at least 1 and indicates a number of\n * elements with data to write that begins with position 1 in iov array. All\n * data length is specified by count.\n */\nint\nSMB2_write(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t   unsigned int *nbytes, struct kvec *iov, int n_vec)\n{\n\tint rc = 0;\n\tstruct smb2_write_req *req = NULL;\n\tstruct smb2_write_rsp *rsp = NULL;\n\tint resp_buftype;\n\tstruct kvec rsp_iov;\n\tint flags = 0;\n\n\t*nbytes = 0;\n\n\tif (n_vec < 1)\n\t\treturn rc;\n\n\trc = small_smb2_init(SMB2_WRITE, io_parms->tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (io_parms->tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tif (encryption_required(io_parms->tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq->hdr.sync_hdr.ProcessId = cpu_to_le32(io_parms->pid);\n\n\treq->PersistentFileId = io_parms->persistent_fid;\n\treq->VolatileFileId = io_parms->volatile_fid;\n\treq->WriteChannelInfoOffset = 0;\n\treq->WriteChannelInfoLength = 0;\n\treq->Channel = 0;\n\treq->Length = cpu_to_le32(io_parms->length);\n\treq->Offset = cpu_to_le64(io_parms->offset);\n\t/* 4 for rfc1002 length field */\n\treq->DataOffset = cpu_to_le16(\n\t\t\t\toffsetof(struct smb2_write_req, Buffer) - 4);\n\treq->RemainingBytes = 0;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field and 1 for Buffer */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\n\t/* length of entire message including data to be written */\n\tinc_rfc1001_len(req, io_parms->length - 1 /* Buffer */);\n\n\trc = SendReceive2(xid, io_parms->tcon->ses, iov, n_vec + 1,\n\t\t\t  &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\trsp = (struct smb2_write_rsp *)rsp_iov.iov_base;\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(io_parms->tcon, SMB2_WRITE_HE);\n\t\tcifs_dbg(VFS, \"Send error in write = %d\\n\", rc);\n\t} else\n\t\t*nbytes = le32_to_cpu(rsp->DataLength);\n\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}\n\nstatic unsigned int\nnum_entries(char *bufstart, char *end_of_buf, char **lastentry, size_t size)\n{\n\tint len;\n\tunsigned int entrycount = 0;\n\tunsigned int next_offset = 0;\n\tFILE_DIRECTORY_INFO *entryptr;\n\n\tif (bufstart == NULL)\n\t\treturn 0;\n\n\tentryptr = (FILE_DIRECTORY_INFO *)bufstart;\n\n\twhile (1) {\n\t\tentryptr = (FILE_DIRECTORY_INFO *)\n\t\t\t\t\t((char *)entryptr + next_offset);\n\n\t\tif ((char *)entryptr + size > end_of_buf) {\n\t\t\tcifs_dbg(VFS, \"malformed search entry would overflow\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tlen = le32_to_cpu(entryptr->FileNameLength);\n\t\tif ((char *)entryptr + len + size > end_of_buf) {\n\t\t\tcifs_dbg(VFS, \"directory entry name would overflow frame end of buf %p\\n\",\n\t\t\t\t end_of_buf);\n\t\t\tbreak;\n\t\t}\n\n\t\t*lastentry = (char *)entryptr;\n\t\tentrycount++;\n\n\t\tnext_offset = le32_to_cpu(entryptr->NextEntryOffset);\n\t\tif (!next_offset)\n\t\t\tbreak;\n\t}\n\n\treturn entrycount;\n}\n\n/*\n * Readdir/FindFirst\n */\nint\nSMB2_query_directory(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     u64 persistent_fid, u64 volatile_fid, int index,\n\t\t     struct cifs_search_info *srch_inf)\n{\n\tstruct smb2_query_directory_req *req;\n\tstruct smb2_query_directory_rsp *rsp = NULL;\n\tstruct kvec iov[2];\n\tstruct kvec rsp_iov;\n\tint rc = 0;\n\tint len;\n\tint resp_buftype = CIFS_NO_BUFFER;\n\tunsigned char *bufptr;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\t__le16 asteriks = cpu_to_le16('*');\n\tchar *end_of_smb;\n\tunsigned int output_size = CIFSMaxBufSize;\n\tsize_t info_buf_size;\n\tint flags = 0;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_QUERY_DIRECTORY, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tswitch (srch_inf->info_level) {\n\tcase SMB_FIND_FILE_DIRECTORY_INFO:\n\t\treq->FileInformationClass = FILE_DIRECTORY_INFORMATION;\n\t\tinfo_buf_size = sizeof(FILE_DIRECTORY_INFO) - 1;\n\t\tbreak;\n\tcase SMB_FIND_FILE_ID_FULL_DIR_INFO:\n\t\treq->FileInformationClass = FILEID_FULL_DIRECTORY_INFORMATION;\n\t\tinfo_buf_size = sizeof(SEARCH_ID_FULL_DIR_INFO) - 1;\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"info level %u isn't supported\\n\",\n\t\t\t srch_inf->info_level);\n\t\trc = -EINVAL;\n\t\tgoto qdir_exit;\n\t}\n\n\treq->FileIndex = cpu_to_le32(index);\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tlen = 0x2;\n\tbufptr = req->Buffer;\n\tmemcpy(bufptr, &asteriks, len);\n\n\treq->FileNameOffset =\n\t\tcpu_to_le16(sizeof(struct smb2_query_directory_req) - 1 - 4);\n\treq->FileNameLength = cpu_to_le16(len);\n\t/*\n\t * BB could be 30 bytes or so longer if we used SMB2 specific\n\t * buffer lengths, but this is safe and close enough.\n\t */\n\toutput_size = min_t(unsigned int, output_size, server->maxBuf);\n\toutput_size = min_t(unsigned int, output_size, 2 << 15);\n\treq->OutputBufferLength = cpu_to_le32(output_size);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for RFC1001 length and 1 for Buffer */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\n\tiov[1].iov_base = (char *)(req->Buffer);\n\tiov[1].iov_len = len;\n\n\tinc_rfc1001_len(req, len - 1 /* Buffer */);\n\n\trc = SendReceive2(xid, ses, iov, 2, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\trsp = (struct smb2_query_directory_rsp *)rsp_iov.iov_base;\n\n\tif (rc) {\n\t\tif (rc == -ENODATA &&\n\t\t    rsp->hdr.sync_hdr.Status == STATUS_NO_MORE_FILES) {\n\t\t\tsrch_inf->endOfSearch = true;\n\t\t\trc = 0;\n\t\t}\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_DIRECTORY_HE);\n\t\tgoto qdir_exit;\n\t}\n\n\trc = validate_buf(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t  le32_to_cpu(rsp->OutputBufferLength), &rsp->hdr,\n\t\t\t  info_buf_size);\n\tif (rc)\n\t\tgoto qdir_exit;\n\n\tsrch_inf->unicode = true;\n\n\tif (srch_inf->ntwrk_buf_start) {\n\t\tif (srch_inf->smallBuf)\n\t\t\tcifs_small_buf_release(srch_inf->ntwrk_buf_start);\n\t\telse\n\t\t\tcifs_buf_release(srch_inf->ntwrk_buf_start);\n\t}\n\tsrch_inf->ntwrk_buf_start = (char *)rsp;\n\tsrch_inf->srch_entries_start = srch_inf->last_entry = 4 /* rfclen */ +\n\t\t(char *)&rsp->hdr + le16_to_cpu(rsp->OutputBufferOffset);\n\t/* 4 for rfc1002 length field */\n\tend_of_smb = get_rfc1002_length(rsp) + 4 + (char *)&rsp->hdr;\n\tsrch_inf->entries_in_buffer =\n\t\t\tnum_entries(srch_inf->srch_entries_start, end_of_smb,\n\t\t\t\t    &srch_inf->last_entry, info_buf_size);\n\tsrch_inf->index_of_last_entry += srch_inf->entries_in_buffer;\n\tcifs_dbg(FYI, \"num entries %d last_index %lld srch start %p srch end %p\\n\",\n\t\t srch_inf->entries_in_buffer, srch_inf->index_of_last_entry,\n\t\t srch_inf->srch_entries_start, srch_inf->last_entry);\n\tif (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tsrch_inf->smallBuf = false;\n\telse if (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tsrch_inf->smallBuf = true;\n\telse\n\t\tcifs_dbg(VFS, \"illegal search buffer type\\n\");\n\n\treturn rc;\n\nqdir_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}\n\nstatic int\nsend_set_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t       u64 persistent_fid, u64 volatile_fid, u32 pid, int info_class,\n\t       unsigned int num, void **data, unsigned int *size)\n{\n\tstruct smb2_set_info_req *req;\n\tstruct smb2_set_info_rsp *rsp = NULL;\n\tstruct kvec *iov;\n\tstruct kvec rsp_iov;\n\tint rc = 0;\n\tint resp_buftype;\n\tunsigned int i;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tint flags = 0;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\tif (!num)\n\t\treturn -EINVAL;\n\n\tiov = kmalloc(sizeof(struct kvec) * num, GFP_KERNEL);\n\tif (!iov)\n\t\treturn -ENOMEM;\n\n\trc = small_smb2_init(SMB2_SET_INFO, tcon, (void **) &req);\n\tif (rc) {\n\t\tkfree(iov);\n\t\treturn rc;\n\t}\n\n\tif (encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq->hdr.sync_hdr.ProcessId = cpu_to_le32(pid);\n\n\treq->InfoType = SMB2_O_INFO_FILE;\n\treq->FileInfoClass = info_class;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\t/* 4 for RFC1001 length and 1 for Buffer */\n\treq->BufferOffset =\n\t\t\tcpu_to_le16(sizeof(struct smb2_set_info_req) - 1 - 4);\n\treq->BufferLength = cpu_to_le32(*size);\n\n\tinc_rfc1001_len(req, *size - 1 /* Buffer */);\n\n\tmemcpy(req->Buffer, *data, *size);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for RFC1001 length */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\tfor (i = 1; i < num; i++) {\n\t\tinc_rfc1001_len(req, size[i]);\n\t\tle32_add_cpu(&req->BufferLength, size[i]);\n\t\tiov[i].iov_base = (char *)data[i];\n\t\tiov[i].iov_len = size[i];\n\t}\n\n\trc = SendReceive2(xid, ses, iov, num, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\trsp = (struct smb2_set_info_rsp *)rsp_iov.iov_base;\n\n\tif (rc != 0)\n\t\tcifs_stats_fail_inc(tcon, SMB2_SET_INFO_HE);\n\n\tfree_rsp_buf(resp_buftype, rsp);\n\tkfree(iov);\n\treturn rc;\n}\n\nint\nSMB2_rename(const unsigned int xid, struct cifs_tcon *tcon,\n\t    u64 persistent_fid, u64 volatile_fid, __le16 *target_file)\n{\n\tstruct smb2_file_rename_info info;\n\tvoid **data;\n\tunsigned int size[2];\n\tint rc;\n\tint len = (2 * UniStrnlen((wchar_t *)target_file, PATH_MAX));\n\n\tdata = kmalloc(sizeof(void *) * 2, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tinfo.ReplaceIfExists = 1; /* 1 = replace existing target with new */\n\t\t\t      /* 0 = fail if target already exists */\n\tinfo.RootDirectory = 0;  /* MBZ for network ops (why does spec say?) */\n\tinfo.FileNameLength = cpu_to_le32(len);\n\n\tdata[0] = &info;\n\tsize[0] = sizeof(struct smb2_file_rename_info);\n\n\tdata[1] = target_file;\n\tsize[1] = len + 2 /* null */;\n\n\trc = send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t   current->tgid, FILE_RENAME_INFORMATION, 2, data,\n\t\t\t   size);\n\tkfree(data);\n\treturn rc;\n}\n\nint\nSMB2_rmdir(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t  u64 persistent_fid, u64 volatile_fid)\n{\n\t__u8 delete_pending = 1;\n\tvoid *data;\n\tunsigned int size;\n\n\tdata = &delete_pending;\n\tsize = 1; /* sizeof __u8 */\n\n\treturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tcurrent->tgid, FILE_DISPOSITION_INFORMATION, 1, &data,\n\t\t\t&size);\n}\n\nint\nSMB2_set_hardlink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t  u64 persistent_fid, u64 volatile_fid, __le16 *target_file)\n{\n\tstruct smb2_file_link_info info;\n\tvoid **data;\n\tunsigned int size[2];\n\tint rc;\n\tint len = (2 * UniStrnlen((wchar_t *)target_file, PATH_MAX));\n\n\tdata = kmalloc(sizeof(void *) * 2, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tinfo.ReplaceIfExists = 0; /* 1 = replace existing link with new */\n\t\t\t      /* 0 = fail if link already exists */\n\tinfo.RootDirectory = 0;  /* MBZ for network ops (why does spec say?) */\n\tinfo.FileNameLength = cpu_to_le32(len);\n\n\tdata[0] = &info;\n\tsize[0] = sizeof(struct smb2_file_link_info);\n\n\tdata[1] = target_file;\n\tsize[1] = len + 2 /* null */;\n\n\trc = send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t   current->tgid, FILE_LINK_INFORMATION, 2, data, size);\n\tkfree(data);\n\treturn rc;\n}\n\nint\nSMB2_set_eof(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t     u64 volatile_fid, u32 pid, __le64 *eof, bool is_falloc)\n{\n\tstruct smb2_file_eof_info info;\n\tvoid *data;\n\tunsigned int size;\n\n\tinfo.EndOfFile = *eof;\n\n\tdata = &info;\n\tsize = sizeof(struct smb2_file_eof_info);\n\n\tif (is_falloc)\n\t\treturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tpid, FILE_ALLOCATION_INFORMATION, 1, &data, &size);\n\telse\n\t\treturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tpid, FILE_END_OF_FILE_INFORMATION, 1, &data, &size);\n}\n\nint\nSMB2_set_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t      u64 persistent_fid, u64 volatile_fid, FILE_BASIC_INFO *buf)\n{\n\tunsigned int size;\n\tsize = sizeof(FILE_BASIC_INFO);\n\treturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t     current->tgid, FILE_BASIC_INFORMATION, 1,\n\t\t\t     (void **)&buf, &size);\n}\n\nint\nSMB2_oplock_break(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t  const u64 persistent_fid, const u64 volatile_fid,\n\t\t  __u8 oplock_level)\n{\n\tint rc;\n\tstruct smb2_oplock_break *req = NULL;\n\tint flags = CIFS_OBREAK_OP;\n\n\tcifs_dbg(FYI, \"SMB2_oplock_break\\n\");\n\trc = small_smb2_init(SMB2_OPLOCK_BREAK, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq->VolatileFid = volatile_fid;\n\treq->PersistentFid = persistent_fid;\n\treq->OplockLevel = oplock_level;\n\treq->hdr.sync_hdr.CreditRequest = cpu_to_le16(1);\n\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) req, flags);\n\tcifs_small_buf_release(req);\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_OPLOCK_BREAK_HE);\n\t\tcifs_dbg(FYI, \"Send error in Oplock Break = %d\\n\", rc);\n\t}\n\n\treturn rc;\n}\n\nstatic void\ncopy_fs_info_to_kstatfs(struct smb2_fs_full_size_info *pfs_inf,\n\t\t\tstruct kstatfs *kst)\n{\n\tkst->f_bsize = le32_to_cpu(pfs_inf->BytesPerSector) *\n\t\t\t  le32_to_cpu(pfs_inf->SectorsPerAllocationUnit);\n\tkst->f_blocks = le64_to_cpu(pfs_inf->TotalAllocationUnits);\n\tkst->f_bfree  = le64_to_cpu(pfs_inf->ActualAvailableAllocationUnits);\n\tkst->f_bavail = le64_to_cpu(pfs_inf->CallerAvailableAllocationUnits);\n\treturn;\n}\n\nstatic int\nbuild_qfs_info_req(struct kvec *iov, struct cifs_tcon *tcon, int level,\n\t\t   int outbuf_len, u64 persistent_fid, u64 volatile_fid)\n{\n\tint rc;\n\tstruct smb2_query_info_req *req;\n\n\tcifs_dbg(FYI, \"Query FSInfo level %d\\n\", level);\n\n\tif ((tcon->ses == NULL) || (tcon->ses->server == NULL))\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_QUERY_INFO, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->InfoType = SMB2_O_INFO_FILESYSTEM;\n\treq->FileInfoClass = level;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\t/* 4 for rfc1002 length field and 1 for pad */\n\treq->InputBufferOffset =\n\t\t\tcpu_to_le16(sizeof(struct smb2_query_info_req) - 1 - 4);\n\treq->OutputBufferLength = cpu_to_le32(\n\t\toutbuf_len + sizeof(struct smb2_query_info_rsp) - 1 - 4);\n\n\tiov->iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov->iov_len = get_rfc1002_length(req) + 4;\n\treturn 0;\n}\n\nint\nSMB2_QFS_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t      u64 persistent_fid, u64 volatile_fid, struct kstatfs *fsdata)\n{\n\tstruct smb2_query_info_rsp *rsp = NULL;\n\tstruct kvec iov;\n\tstruct kvec rsp_iov;\n\tint rc = 0;\n\tint resp_buftype;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct smb2_fs_full_size_info *info = NULL;\n\tint flags = 0;\n\n\trc = build_qfs_info_req(&iov, tcon, FS_FULL_SIZE_INFORMATION,\n\t\t\t\tsizeof(struct smb2_fs_full_size_info),\n\t\t\t\tpersistent_fid, volatile_fid);\n\tif (rc)\n\t\treturn rc;\n\n\tif (encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\trc = SendReceive2(xid, ses, &iov, 1, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(iov.iov_base);\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_INFO_HE);\n\t\tgoto qfsinf_exit;\n\t}\n\trsp = (struct smb2_query_info_rsp *)rsp_iov.iov_base;\n\n\tinfo = (struct smb2_fs_full_size_info *)(4 /* RFC1001 len */ +\n\t\tle16_to_cpu(rsp->OutputBufferOffset) + (char *)&rsp->hdr);\n\trc = validate_buf(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t  le32_to_cpu(rsp->OutputBufferLength), &rsp->hdr,\n\t\t\t  sizeof(struct smb2_fs_full_size_info));\n\tif (!rc)\n\t\tcopy_fs_info_to_kstatfs(info, fsdata);\n\nqfsinf_exit:\n\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\treturn rc;\n}\n\nint\nSMB2_QFS_attr(const unsigned int xid, struct cifs_tcon *tcon,\n\t      u64 persistent_fid, u64 volatile_fid, int level)\n{\n\tstruct smb2_query_info_rsp *rsp = NULL;\n\tstruct kvec iov;\n\tstruct kvec rsp_iov;\n\tint rc = 0;\n\tint resp_buftype, max_len, min_len;\n\tstruct cifs_ses *ses = tcon->ses;\n\tunsigned int rsp_len, offset;\n\tint flags = 0;\n\n\tif (level == FS_DEVICE_INFORMATION) {\n\t\tmax_len = sizeof(FILE_SYSTEM_DEVICE_INFO);\n\t\tmin_len = sizeof(FILE_SYSTEM_DEVICE_INFO);\n\t} else if (level == FS_ATTRIBUTE_INFORMATION) {\n\t\tmax_len = sizeof(FILE_SYSTEM_ATTRIBUTE_INFO);\n\t\tmin_len = MIN_FS_ATTR_INFO_SIZE;\n\t} else if (level == FS_SECTOR_SIZE_INFORMATION) {\n\t\tmax_len = sizeof(struct smb3_fs_ss_info);\n\t\tmin_len = sizeof(struct smb3_fs_ss_info);\n\t} else {\n\t\tcifs_dbg(FYI, \"Invalid qfsinfo level %d\\n\", level);\n\t\treturn -EINVAL;\n\t}\n\n\trc = build_qfs_info_req(&iov, tcon, level, max_len,\n\t\t\t\tpersistent_fid, volatile_fid);\n\tif (rc)\n\t\treturn rc;\n\n\tif (encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\trc = SendReceive2(xid, ses, &iov, 1, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(iov.iov_base);\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_INFO_HE);\n\t\tgoto qfsattr_exit;\n\t}\n\trsp = (struct smb2_query_info_rsp *)rsp_iov.iov_base;\n\n\trsp_len = le32_to_cpu(rsp->OutputBufferLength);\n\toffset = le16_to_cpu(rsp->OutputBufferOffset);\n\trc = validate_buf(offset, rsp_len, &rsp->hdr, min_len);\n\tif (rc)\n\t\tgoto qfsattr_exit;\n\n\tif (level == FS_ATTRIBUTE_INFORMATION)\n\t\tmemcpy(&tcon->fsAttrInfo, 4 /* RFC1001 len */ + offset\n\t\t\t+ (char *)&rsp->hdr, min_t(unsigned int,\n\t\t\trsp_len, max_len));\n\telse if (level == FS_DEVICE_INFORMATION)\n\t\tmemcpy(&tcon->fsDevInfo, 4 /* RFC1001 len */ + offset\n\t\t\t+ (char *)&rsp->hdr, sizeof(FILE_SYSTEM_DEVICE_INFO));\n\telse if (level == FS_SECTOR_SIZE_INFORMATION) {\n\t\tstruct smb3_fs_ss_info *ss_info = (struct smb3_fs_ss_info *)\n\t\t\t(4 /* RFC1001 len */ + offset + (char *)&rsp->hdr);\n\t\ttcon->ss_flags = le32_to_cpu(ss_info->Flags);\n\t\ttcon->perf_sector_size =\n\t\t\tle32_to_cpu(ss_info->PhysicalBytesPerSectorForPerf);\n\t}\n\nqfsattr_exit:\n\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\treturn rc;\n}\n\nint\nsmb2_lockv(const unsigned int xid, struct cifs_tcon *tcon,\n\t   const __u64 persist_fid, const __u64 volatile_fid, const __u32 pid,\n\t   const __u32 num_lock, struct smb2_lock_element *buf)\n{\n\tint rc = 0;\n\tstruct smb2_lock_req *req = NULL;\n\tstruct kvec iov[2];\n\tstruct kvec rsp_iov;\n\tint resp_buf_type;\n\tunsigned int count;\n\tint flags = CIFS_NO_RESP;\n\n\tcifs_dbg(FYI, \"smb2_lockv num lock %d\\n\", num_lock);\n\n\trc = small_smb2_init(SMB2_LOCK, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq->hdr.sync_hdr.ProcessId = cpu_to_le32(pid);\n\treq->LockCount = cpu_to_le16(num_lock);\n\n\treq->PersistentFileId = persist_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tcount = num_lock * sizeof(struct smb2_lock_element);\n\tinc_rfc1001_len(req, count - sizeof(struct smb2_lock_element));\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field and count for all locks */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4 - count;\n\tiov[1].iov_base = (char *)buf;\n\tiov[1].iov_len = count;\n\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_locks);\n\trc = SendReceive2(xid, tcon->ses, iov, 2, &resp_buf_type, flags,\n\t\t\t  &rsp_iov);\n\tcifs_small_buf_release(req);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in smb2_lockv = %d\\n\", rc);\n\t\tcifs_stats_fail_inc(tcon, SMB2_LOCK_HE);\n\t}\n\n\treturn rc;\n}\n\nint\nSMB2_lock(const unsigned int xid, struct cifs_tcon *tcon,\n\t  const __u64 persist_fid, const __u64 volatile_fid, const __u32 pid,\n\t  const __u64 length, const __u64 offset, const __u32 lock_flags,\n\t  const bool wait)\n{\n\tstruct smb2_lock_element lock;\n\n\tlock.Offset = cpu_to_le64(offset);\n\tlock.Length = cpu_to_le64(length);\n\tlock.Flags = cpu_to_le32(lock_flags);\n\tif (!wait && lock_flags != SMB2_LOCKFLAG_UNLOCK)\n\t\tlock.Flags |= cpu_to_le32(SMB2_LOCKFLAG_FAIL_IMMEDIATELY);\n\n\treturn smb2_lockv(xid, tcon, persist_fid, volatile_fid, pid, 1, &lock);\n}\n\nint\nSMB2_lease_break(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t __u8 *lease_key, const __le32 lease_state)\n{\n\tint rc;\n\tstruct smb2_lease_ack *req = NULL;\n\tint flags = CIFS_OBREAK_OP;\n\n\tcifs_dbg(FYI, \"SMB2_lease_break\\n\");\n\trc = small_smb2_init(SMB2_OPLOCK_BREAK, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq->hdr.sync_hdr.CreditRequest = cpu_to_le16(1);\n\treq->StructureSize = cpu_to_le16(36);\n\tinc_rfc1001_len(req, 12);\n\n\tmemcpy(req->LeaseKey, lease_key, 16);\n\treq->LeaseState = lease_state;\n\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) req, flags);\n\tcifs_small_buf_release(req);\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_OPLOCK_BREAK_HE);\n\t\tcifs_dbg(FYI, \"Send error in Lease Break = %d\\n\", rc);\n\t}\n\n\treturn rc;\n}\n"], "fixing_code": ["/*\n *   fs/cifs/sess.c\n *\n *   SMB/CIFS session setup handling routines\n *\n *   Copyright (c) International Business Machines  Corp., 2006, 2009\n *   Author(s): Steve French (sfrench@us.ibm.com)\n *\n *   This library is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published\n *   by the Free Software Foundation; either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This library is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See\n *   the GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this library; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n */\n\n#include \"cifspdu.h\"\n#include \"cifsglob.h\"\n#include \"cifsproto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"ntlmssp.h\"\n#include \"nterr.h\"\n#include <linux/utsname.h>\n#include <linux/slab.h>\n#include \"cifs_spnego.h\"\n\nstatic __u32 cifs_ssetup_hdr(struct cifs_ses *ses, SESSION_SETUP_ANDX *pSMB)\n{\n\t__u32 capabilities = 0;\n\n\t/* init fields common to all four types of SessSetup */\n\t/* Note that offsets for first seven fields in req struct are same  */\n\t/*\tin CIFS Specs so does not matter which of 3 forms of struct */\n\t/*\tthat we use in next few lines                               */\n\t/* Note that header is initialized to zero in header_assemble */\n\tpSMB->req.AndXCommand = 0xFF;\n\tpSMB->req.MaxBufferSize = cpu_to_le16(min_t(u32,\n\t\t\t\t\tCIFSMaxBufSize + MAX_CIFS_HDR_SIZE - 4,\n\t\t\t\t\tUSHRT_MAX));\n\tpSMB->req.MaxMpxCount = cpu_to_le16(ses->server->maxReq);\n\tpSMB->req.VcNumber = cpu_to_le16(1);\n\n\t/* Now no need to set SMBFLG_CASELESS or obsolete CANONICAL PATH */\n\n\t/* BB verify whether signing required on neg or just on auth frame\n\t   (and NTLM case) */\n\n\tcapabilities = CAP_LARGE_FILES | CAP_NT_SMBS | CAP_LEVEL_II_OPLOCKS |\n\t\t\tCAP_LARGE_WRITE_X | CAP_LARGE_READ_X;\n\n\tif (ses->server->sign)\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_SECURITY_SIGNATURE;\n\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_UNICODE;\n\t\tcapabilities |= CAP_UNICODE;\n\t}\n\tif (ses->capabilities & CAP_STATUS32) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_ERR_STATUS;\n\t\tcapabilities |= CAP_STATUS32;\n\t}\n\tif (ses->capabilities & CAP_DFS) {\n\t\tpSMB->req.hdr.Flags2 |= SMBFLG2_DFS;\n\t\tcapabilities |= CAP_DFS;\n\t}\n\tif (ses->capabilities & CAP_UNIX)\n\t\tcapabilities |= CAP_UNIX;\n\n\treturn capabilities;\n}\n\nstatic void\nunicode_oslm_strings(char **pbcc_area, const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\tint bytes_ret = 0;\n\n\t/* Copy OS version */\n\tbytes_ret = cifs_strtoUTF16((__le16 *)bcc_ptr, \"Linux version \", 32,\n\t\t\t\t    nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, init_utsname()->release,\n\t\t\t\t    32, nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2; /* trailing null */\n\n\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, CIFS_NETWORK_OPSYS,\n\t\t\t\t    32, nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2; /* trailing null */\n\n\t*pbcc_area = bcc_ptr;\n}\n\nstatic void unicode_domain_string(char **pbcc_area, struct cifs_ses *ses,\n\t\t\t\t   const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\tint bytes_ret = 0;\n\n\t/* copy domain */\n\tif (ses->domainName == NULL) {\n\t\t/* Sending null domain better than using a bogus domain name (as\n\t\twe did briefly in 2.6.18) since server will use its default */\n\t\t*bcc_ptr = 0;\n\t\t*(bcc_ptr+1) = 0;\n\t\tbytes_ret = 0;\n\t} else\n\t\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, ses->domainName,\n\t\t\t\t\t    CIFS_MAX_DOMAINNAME_LEN, nls_cp);\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2;  /* account for null terminator */\n\n\t*pbcc_area = bcc_ptr;\n}\n\n\nstatic void unicode_ssetup_strings(char **pbcc_area, struct cifs_ses *ses,\n\t\t\t\t   const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\tint bytes_ret = 0;\n\n\t/* BB FIXME add check that strings total less\n\tthan 335 or will need to send them as arrays */\n\n\t/* unicode strings, must be word aligned before the call */\n/*\tif ((long) bcc_ptr % 2)\t{\n\t\t*bcc_ptr = 0;\n\t\tbcc_ptr++;\n\t} */\n\t/* copy user */\n\tif (ses->user_name == NULL) {\n\t\t/* null user mount */\n\t\t*bcc_ptr = 0;\n\t\t*(bcc_ptr+1) = 0;\n\t} else {\n\t\tbytes_ret = cifs_strtoUTF16((__le16 *) bcc_ptr, ses->user_name,\n\t\t\t\t\t    CIFS_MAX_USERNAME_LEN, nls_cp);\n\t}\n\tbcc_ptr += 2 * bytes_ret;\n\tbcc_ptr += 2; /* account for null termination */\n\n\tunicode_domain_string(&bcc_ptr, ses, nls_cp);\n\tunicode_oslm_strings(&bcc_ptr, nls_cp);\n\n\t*pbcc_area = bcc_ptr;\n}\n\nstatic void ascii_ssetup_strings(char **pbcc_area, struct cifs_ses *ses,\n\t\t\t\t const struct nls_table *nls_cp)\n{\n\tchar *bcc_ptr = *pbcc_area;\n\n\t/* copy user */\n\t/* BB what about null user mounts - check that we do this BB */\n\t/* copy user */\n\tif (ses->user_name != NULL) {\n\t\tstrncpy(bcc_ptr, ses->user_name, CIFS_MAX_USERNAME_LEN);\n\t\tbcc_ptr += strnlen(ses->user_name, CIFS_MAX_USERNAME_LEN);\n\t}\n\t/* else null user mount */\n\t*bcc_ptr = 0;\n\tbcc_ptr++; /* account for null termination */\n\n\t/* copy domain */\n\tif (ses->domainName != NULL) {\n\t\tstrncpy(bcc_ptr, ses->domainName, CIFS_MAX_DOMAINNAME_LEN);\n\t\tbcc_ptr += strnlen(ses->domainName, CIFS_MAX_DOMAINNAME_LEN);\n\t} /* else we will send a null domain name\n\t     so the server will default to its own domain */\n\t*bcc_ptr = 0;\n\tbcc_ptr++;\n\n\t/* BB check for overflow here */\n\n\tstrcpy(bcc_ptr, \"Linux version \");\n\tbcc_ptr += strlen(\"Linux version \");\n\tstrcpy(bcc_ptr, init_utsname()->release);\n\tbcc_ptr += strlen(init_utsname()->release) + 1;\n\n\tstrcpy(bcc_ptr, CIFS_NETWORK_OPSYS);\n\tbcc_ptr += strlen(CIFS_NETWORK_OPSYS) + 1;\n\n\t*pbcc_area = bcc_ptr;\n}\n\nstatic void\ndecode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,\n\t\t      const struct nls_table *nls_cp)\n{\n\tint len;\n\tchar *data = *pbcc_area;\n\n\tcifs_dbg(FYI, \"bleft %d\\n\", bleft);\n\n\tkfree(ses->serverOS);\n\tses->serverOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverOS=%s\\n\", ses->serverOS);\n\tlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\n\tdata += len;\n\tbleft -= len;\n\tif (bleft <= 0)\n\t\treturn;\n\n\tkfree(ses->serverNOS);\n\tses->serverNOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverNOS=%s\\n\", ses->serverNOS);\n\tlen = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;\n\tdata += len;\n\tbleft -= len;\n\tif (bleft <= 0)\n\t\treturn;\n\n\tkfree(ses->serverDomain);\n\tses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, nls_cp);\n\tcifs_dbg(FYI, \"serverDomain=%s\\n\", ses->serverDomain);\n\n\treturn;\n}\n\nstatic void decode_ascii_ssetup(char **pbcc_area, __u16 bleft,\n\t\t\t\tstruct cifs_ses *ses,\n\t\t\t\tconst struct nls_table *nls_cp)\n{\n\tint len;\n\tchar *bcc_ptr = *pbcc_area;\n\n\tcifs_dbg(FYI, \"decode sessetup ascii. bleft %d\\n\", bleft);\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len >= bleft)\n\t\treturn;\n\n\tkfree(ses->serverOS);\n\n\tses->serverOS = kzalloc(len + 1, GFP_KERNEL);\n\tif (ses->serverOS) {\n\t\tstrncpy(ses->serverOS, bcc_ptr, len);\n\t\tif (strncmp(ses->serverOS, \"OS/2\", 4) == 0)\n\t\t\tcifs_dbg(FYI, \"OS/2 server\\n\");\n\t}\n\n\tbcc_ptr += len + 1;\n\tbleft -= len + 1;\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len >= bleft)\n\t\treturn;\n\n\tkfree(ses->serverNOS);\n\n\tses->serverNOS = kzalloc(len + 1, GFP_KERNEL);\n\tif (ses->serverNOS)\n\t\tstrncpy(ses->serverNOS, bcc_ptr, len);\n\n\tbcc_ptr += len + 1;\n\tbleft -= len + 1;\n\n\tlen = strnlen(bcc_ptr, bleft);\n\tif (len > bleft)\n\t\treturn;\n\n\t/* No domain field in LANMAN case. Domain is\n\t   returned by old servers in the SMB negprot response */\n\t/* BB For newer servers which do not support Unicode,\n\t   but thus do return domain here we could add parsing\n\t   for it later, but it is not very important */\n\tcifs_dbg(FYI, \"ascii: bytes left %d\\n\", bleft);\n}\n\nint decode_ntlmssp_challenge(char *bcc_ptr, int blob_len,\n\t\t\t\t    struct cifs_ses *ses)\n{\n\tunsigned int tioffset; /* challenge message target info area */\n\tunsigned int tilen; /* challenge message target info area length  */\n\n\tCHALLENGE_MESSAGE *pblob = (CHALLENGE_MESSAGE *)bcc_ptr;\n\n\tif (blob_len < sizeof(CHALLENGE_MESSAGE)) {\n\t\tcifs_dbg(VFS, \"challenge blob len %d too small\\n\", blob_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (memcmp(pblob->Signature, \"NTLMSSP\", 8)) {\n\t\tcifs_dbg(VFS, \"blob signature incorrect %s\\n\",\n\t\t\t pblob->Signature);\n\t\treturn -EINVAL;\n\t}\n\tif (pblob->MessageType != NtLmChallenge) {\n\t\tcifs_dbg(VFS, \"Incorrect message type %d\\n\",\n\t\t\t pblob->MessageType);\n\t\treturn -EINVAL;\n\t}\n\n\tmemcpy(ses->ntlmssp->cryptkey, pblob->Challenge, CIFS_CRYPTO_KEY_SIZE);\n\t/* BB we could decode pblob->NegotiateFlags; some may be useful */\n\t/* In particular we can examine sign flags */\n\t/* BB spec says that if AvId field of MsvAvTimestamp is populated then\n\t\twe must set the MIC field of the AUTHENTICATE_MESSAGE */\n\tses->ntlmssp->server_flags = le32_to_cpu(pblob->NegotiateFlags);\n\ttioffset = le32_to_cpu(pblob->TargetInfoArray.BufferOffset);\n\ttilen = le16_to_cpu(pblob->TargetInfoArray.Length);\n\tif (tioffset > blob_len || tioffset + tilen > blob_len) {\n\t\tcifs_dbg(VFS, \"tioffset + tilen too high %u + %u\",\n\t\t\ttioffset, tilen);\n\t\treturn -EINVAL;\n\t}\n\tif (tilen) {\n\t\tses->auth_key.response = kmemdup(bcc_ptr + tioffset, tilen,\n\t\t\t\t\t\t GFP_KERNEL);\n\t\tif (!ses->auth_key.response) {\n\t\t\tcifs_dbg(VFS, \"Challenge target info alloc failure\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tses->auth_key.len = tilen;\n\t}\n\n\treturn 0;\n}\n\n/* BB Move to ntlmssp.c eventually */\n\n/* We do not malloc the blob, it is passed in pbuffer, because\n   it is fixed size, and small, making this approach cleaner */\nvoid build_ntlmssp_negotiate_blob(unsigned char *pbuffer,\n\t\t\t\t\t struct cifs_ses *ses)\n{\n\tNEGOTIATE_MESSAGE *sec_blob = (NEGOTIATE_MESSAGE *)pbuffer;\n\t__u32 flags;\n\n\tmemset(pbuffer, 0, sizeof(NEGOTIATE_MESSAGE));\n\tmemcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);\n\tsec_blob->MessageType = NtLmNegotiate;\n\n\t/* BB is NTLMV2 session security format easier to use here? */\n\tflags = NTLMSSP_NEGOTIATE_56 |\tNTLMSSP_REQUEST_TARGET |\n\t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC |\n\t\tNTLMSSP_NEGOTIATE_SEAL;\n\tif (ses->server->sign)\n\t\tflags |= NTLMSSP_NEGOTIATE_SIGN;\n\tif (!ses->server->session_estab || ses->ntlmssp->sesskey_per_smbsess)\n\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n\n\tsec_blob->NegotiateFlags = cpu_to_le32(flags);\n\n\tsec_blob->WorkstationName.BufferOffset = 0;\n\tsec_blob->WorkstationName.Length = 0;\n\tsec_blob->WorkstationName.MaximumLength = 0;\n\n\t/* Domain name is sent on the Challenge not Negotiate NTLMSSP request */\n\tsec_blob->DomainName.BufferOffset = 0;\n\tsec_blob->DomainName.Length = 0;\n\tsec_blob->DomainName.MaximumLength = 0;\n}\n\nstatic int size_of_ntlmssp_blob(struct cifs_ses *ses)\n{\n\tint sz = sizeof(AUTHENTICATE_MESSAGE) + ses->auth_key.len\n\t\t- CIFS_SESS_KEY_SIZE + CIFS_CPHTXT_SIZE + 2;\n\n\tif (ses->domainName)\n\t\tsz += 2 * strnlen(ses->domainName, CIFS_MAX_DOMAINNAME_LEN);\n\telse\n\t\tsz += 2;\n\n\tif (ses->user_name)\n\t\tsz += 2 * strnlen(ses->user_name, CIFS_MAX_USERNAME_LEN);\n\telse\n\t\tsz += 2;\n\n\treturn sz;\n}\n\nint build_ntlmssp_auth_blob(unsigned char **pbuffer,\n\t\t\t\t\tu16 *buflen,\n\t\t\t\t   struct cifs_ses *ses,\n\t\t\t\t   const struct nls_table *nls_cp)\n{\n\tint rc;\n\tAUTHENTICATE_MESSAGE *sec_blob;\n\t__u32 flags;\n\tunsigned char *tmp;\n\n\trc = setup_ntlmv2_rsp(ses, nls_cp);\n\tif (rc) {\n\t\tcifs_dbg(VFS, \"Error %d during NTLMSSP authentication\\n\", rc);\n\t\t*buflen = 0;\n\t\tgoto setup_ntlmv2_ret;\n\t}\n\t*pbuffer = kmalloc(size_of_ntlmssp_blob(ses), GFP_KERNEL);\n\tsec_blob = (AUTHENTICATE_MESSAGE *)*pbuffer;\n\n\tmemcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8);\n\tsec_blob->MessageType = NtLmAuthenticate;\n\n\tflags = NTLMSSP_NEGOTIATE_56 |\n\t\tNTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_TARGET_INFO |\n\t\tNTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE |\n\t\tNTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC |\n\t\tNTLMSSP_NEGOTIATE_SEAL;\n\tif (ses->server->sign)\n\t\tflags |= NTLMSSP_NEGOTIATE_SIGN;\n\tif (!ses->server->session_estab || ses->ntlmssp->sesskey_per_smbsess)\n\t\tflags |= NTLMSSP_NEGOTIATE_KEY_XCH;\n\n\ttmp = *pbuffer + sizeof(AUTHENTICATE_MESSAGE);\n\tsec_blob->NegotiateFlags = cpu_to_le32(flags);\n\n\tsec_blob->LmChallengeResponse.BufferOffset =\n\t\t\t\tcpu_to_le32(sizeof(AUTHENTICATE_MESSAGE));\n\tsec_blob->LmChallengeResponse.Length = 0;\n\tsec_blob->LmChallengeResponse.MaximumLength = 0;\n\n\tsec_blob->NtChallengeResponse.BufferOffset =\n\t\t\t\tcpu_to_le32(tmp - *pbuffer);\n\tif (ses->user_name != NULL) {\n\t\tmemcpy(tmp, ses->auth_key.response + CIFS_SESS_KEY_SIZE,\n\t\t\t\tses->auth_key.len - CIFS_SESS_KEY_SIZE);\n\t\ttmp += ses->auth_key.len - CIFS_SESS_KEY_SIZE;\n\n\t\tsec_blob->NtChallengeResponse.Length =\n\t\t\t\tcpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);\n\t\tsec_blob->NtChallengeResponse.MaximumLength =\n\t\t\t\tcpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);\n\t} else {\n\t\t/*\n\t\t * don't send an NT Response for anonymous access\n\t\t */\n\t\tsec_blob->NtChallengeResponse.Length = 0;\n\t\tsec_blob->NtChallengeResponse.MaximumLength = 0;\n\t}\n\n\tif (ses->domainName == NULL) {\n\t\tsec_blob->DomainName.BufferOffset = cpu_to_le32(tmp - *pbuffer);\n\t\tsec_blob->DomainName.Length = 0;\n\t\tsec_blob->DomainName.MaximumLength = 0;\n\t\ttmp += 2;\n\t} else {\n\t\tint len;\n\t\tlen = cifs_strtoUTF16((__le16 *)tmp, ses->domainName,\n\t\t\t\t      CIFS_MAX_DOMAINNAME_LEN, nls_cp);\n\t\tlen *= 2; /* unicode is 2 bytes each */\n\t\tsec_blob->DomainName.BufferOffset = cpu_to_le32(tmp - *pbuffer);\n\t\tsec_blob->DomainName.Length = cpu_to_le16(len);\n\t\tsec_blob->DomainName.MaximumLength = cpu_to_le16(len);\n\t\ttmp += len;\n\t}\n\n\tif (ses->user_name == NULL) {\n\t\tsec_blob->UserName.BufferOffset = cpu_to_le32(tmp - *pbuffer);\n\t\tsec_blob->UserName.Length = 0;\n\t\tsec_blob->UserName.MaximumLength = 0;\n\t\ttmp += 2;\n\t} else {\n\t\tint len;\n\t\tlen = cifs_strtoUTF16((__le16 *)tmp, ses->user_name,\n\t\t\t\t      CIFS_MAX_USERNAME_LEN, nls_cp);\n\t\tlen *= 2; /* unicode is 2 bytes each */\n\t\tsec_blob->UserName.BufferOffset = cpu_to_le32(tmp - *pbuffer);\n\t\tsec_blob->UserName.Length = cpu_to_le16(len);\n\t\tsec_blob->UserName.MaximumLength = cpu_to_le16(len);\n\t\ttmp += len;\n\t}\n\n\tsec_blob->WorkstationName.BufferOffset = cpu_to_le32(tmp - *pbuffer);\n\tsec_blob->WorkstationName.Length = 0;\n\tsec_blob->WorkstationName.MaximumLength = 0;\n\ttmp += 2;\n\n\tif (((ses->ntlmssp->server_flags & NTLMSSP_NEGOTIATE_KEY_XCH) ||\n\t\t(ses->ntlmssp->server_flags & NTLMSSP_NEGOTIATE_EXTENDED_SEC))\n\t\t\t&& !calc_seckey(ses)) {\n\t\tmemcpy(tmp, ses->ntlmssp->ciphertext, CIFS_CPHTXT_SIZE);\n\t\tsec_blob->SessionKey.BufferOffset = cpu_to_le32(tmp - *pbuffer);\n\t\tsec_blob->SessionKey.Length = cpu_to_le16(CIFS_CPHTXT_SIZE);\n\t\tsec_blob->SessionKey.MaximumLength =\n\t\t\t\tcpu_to_le16(CIFS_CPHTXT_SIZE);\n\t\ttmp += CIFS_CPHTXT_SIZE;\n\t} else {\n\t\tsec_blob->SessionKey.BufferOffset = cpu_to_le32(tmp - *pbuffer);\n\t\tsec_blob->SessionKey.Length = 0;\n\t\tsec_blob->SessionKey.MaximumLength = 0;\n\t}\n\n\t*buflen = tmp - *pbuffer;\nsetup_ntlmv2_ret:\n\treturn rc;\n}\n\nenum securityEnum\nselect_sectype(struct TCP_Server_Info *server, enum securityEnum requested)\n{\n\tswitch (server->negflavor) {\n\tcase CIFS_NEGFLAVOR_EXTENDED:\n\t\tswitch (requested) {\n\t\tcase Kerberos:\n\t\tcase RawNTLMSSP:\n\t\t\treturn requested;\n\t\tcase Unspecified:\n\t\t\tif (server->sec_ntlmssp &&\n\t\t\t    (global_secflags & CIFSSEC_MAY_NTLMSSP))\n\t\t\t\treturn RawNTLMSSP;\n\t\t\tif ((server->sec_kerberos || server->sec_mskerberos) &&\n\t\t\t    (global_secflags & CIFSSEC_MAY_KRB5))\n\t\t\t\treturn Kerberos;\n\t\t\t/* Fallthrough */\n\t\tdefault:\n\t\t\treturn Unspecified;\n\t\t}\n\tcase CIFS_NEGFLAVOR_UNENCAP:\n\t\tswitch (requested) {\n\t\tcase NTLM:\n\t\tcase NTLMv2:\n\t\t\treturn requested;\n\t\tcase Unspecified:\n\t\t\tif (global_secflags & CIFSSEC_MAY_NTLMV2)\n\t\t\t\treturn NTLMv2;\n\t\t\tif (global_secflags & CIFSSEC_MAY_NTLM)\n\t\t\t\treturn NTLM;\n\t\tdefault:\n\t\t\t/* Fallthrough to attempt LANMAN authentication next */\n\t\t\tbreak;\n\t\t}\n\tcase CIFS_NEGFLAVOR_LANMAN:\n\t\tswitch (requested) {\n\t\tcase LANMAN:\n\t\t\treturn requested;\n\t\tcase Unspecified:\n\t\t\tif (global_secflags & CIFSSEC_MAY_LANMAN)\n\t\t\t\treturn LANMAN;\n\t\t\t/* Fallthrough */\n\t\tdefault:\n\t\t\treturn Unspecified;\n\t\t}\n\tdefault:\n\t\treturn Unspecified;\n\t}\n}\n\nstruct sess_data {\n\tunsigned int xid;\n\tstruct cifs_ses *ses;\n\tstruct nls_table *nls_cp;\n\tvoid (*func)(struct sess_data *);\n\tint result;\n\n\t/* we will send the SMB in three pieces:\n\t * a fixed length beginning part, an optional\n\t * SPNEGO blob (which can be zero length), and a\n\t * last part which will include the strings\n\t * and rest of bcc area. This allows us to avoid\n\t * a large buffer 17K allocation\n\t */\n\tint buf0_type;\n\tstruct kvec iov[3];\n};\n\nstatic int\nsess_alloc_buffer(struct sess_data *sess_data, int wct)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct smb_hdr *smb_buf;\n\n\trc = small_smb_init_no_tc(SMB_COM_SESSION_SETUP_ANDX, wct, ses,\n\t\t\t\t  (void **)&smb_buf);\n\n\tif (rc)\n\t\treturn rc;\n\n\tsess_data->iov[0].iov_base = (char *)smb_buf;\n\tsess_data->iov[0].iov_len = be32_to_cpu(smb_buf->smb_buf_length) + 4;\n\t/*\n\t * This variable will be used to clear the buffer\n\t * allocated above in case of any error in the calling function.\n\t */\n\tsess_data->buf0_type = CIFS_SMALL_BUFFER;\n\n\t/* 2000 big enough to fit max user, domain, NOS name etc. */\n\tsess_data->iov[2].iov_base = kmalloc(2000, GFP_KERNEL);\n\tif (!sess_data->iov[2].iov_base) {\n\t\trc = -ENOMEM;\n\t\tgoto out_free_smb_buf;\n\t}\n\n\treturn 0;\n\nout_free_smb_buf:\n\tkfree(smb_buf);\n\tsess_data->iov[0].iov_base = NULL;\n\tsess_data->iov[0].iov_len = 0;\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\treturn rc;\n}\n\nstatic void\nsess_free_buffer(struct sess_data *sess_data)\n{\n\n\tfree_rsp_buf(sess_data->buf0_type, sess_data->iov[0].iov_base);\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\tkfree(sess_data->iov[2].iov_base);\n}\n\nstatic int\nsess_establish_session(struct sess_data *sess_data)\n{\n\tstruct cifs_ses *ses = sess_data->ses;\n\n\tmutex_lock(&ses->server->srv_mutex);\n\tif (!ses->server->session_estab) {\n\t\tif (ses->server->sign) {\n\t\t\tses->server->session_key.response =\n\t\t\t\tkmemdup(ses->auth_key.response,\n\t\t\t\tses->auth_key.len, GFP_KERNEL);\n\t\t\tif (!ses->server->session_key.response) {\n\t\t\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tses->server->session_key.len =\n\t\t\t\t\t\tses->auth_key.len;\n\t\t}\n\t\tses->server->sequence_number = 0x2;\n\t\tses->server->session_estab = true;\n\t}\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tcifs_dbg(FYI, \"CIFS session established successfully\\n\");\n\tspin_lock(&GlobalMid_Lock);\n\tses->status = CifsGood;\n\tses->need_reconnect = false;\n\tspin_unlock(&GlobalMid_Lock);\n\n\treturn 0;\n}\n\nstatic int\nsess_sendreceive(struct sess_data *sess_data)\n{\n\tint rc;\n\tstruct smb_hdr *smb_buf = (struct smb_hdr *) sess_data->iov[0].iov_base;\n\t__u16 count;\n\tstruct kvec rsp_iov = { NULL, 0 };\n\n\tcount = sess_data->iov[1].iov_len + sess_data->iov[2].iov_len;\n\tsmb_buf->smb_buf_length =\n\t\tcpu_to_be32(be32_to_cpu(smb_buf->smb_buf_length) + count);\n\tput_bcc(count, smb_buf);\n\n\trc = SendReceive2(sess_data->xid, sess_data->ses,\n\t\t\t  sess_data->iov, 3 /* num_iovecs */,\n\t\t\t  &sess_data->buf0_type,\n\t\t\t  CIFS_LOG_ERROR, &rsp_iov);\n\tcifs_small_buf_release(sess_data->iov[0].iov_base);\n\tmemcpy(&sess_data->iov[0], &rsp_iov, sizeof(struct kvec));\n\n\treturn rc;\n}\n\n/*\n * LANMAN and plaintext are less secure and off by default.\n * So we make this explicitly be turned on in kconfig (in the\n * build) and turned on at runtime (changed from the default)\n * in proc/fs/cifs or via mount parm.  Unfortunately this is\n * needed for old Win (e.g. Win95), some obscure NAS and OS/2\n */\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\nstatic void\nsess_auth_lanman(struct sess_data *sess_data)\n{\n\tint rc = 0;\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tchar *bcc_ptr;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tchar lnm_session_key[CIFS_AUTH_RESP_SIZE];\n\t__u32 capabilities;\n\t__u16 bytes_remaining;\n\n\t/* lanman 2 style sessionsetup */\n\t/* wct = 10 */\n\trc = sess_alloc_buffer(sess_data, 10);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tbcc_ptr = sess_data->iov[2].iov_base;\n\tcapabilities = cifs_ssetup_hdr(ses, pSMB);\n\n\tpSMB->req.hdr.Flags2 &= ~SMBFLG2_UNICODE;\n\n\tif (ses->user_name != NULL) {\n\t\t/* no capabilities flags in old lanman negotiation */\n\t\tpSMB->old_req.PasswordLength = cpu_to_le16(CIFS_AUTH_RESP_SIZE);\n\n\t\t/* Calculate hash with password and copy into bcc_ptr.\n\t\t * Encryption Key (stored as in cryptkey) gets used if the\n\t\t * security mode bit in Negottiate Protocol response states\n\t\t * to use challenge/response method (i.e. Password bit is 1).\n\t\t */\n\t\trc = calc_lanman_hash(ses->password, ses->server->cryptkey,\n\t\t\t\t      ses->server->sec_mode & SECMODE_PW_ENCRYPT ?\n\t\t\t\t      true : false, lnm_session_key);\n\t\tif (rc)\n\t\t\tgoto out;\n\n\t\tmemcpy(bcc_ptr, (char *)lnm_session_key, CIFS_AUTH_RESP_SIZE);\n\t\tbcc_ptr += CIFS_AUTH_RESP_SIZE;\n\t} else {\n\t\tpSMB->old_req.PasswordLength = 0;\n\t}\n\n\t/*\n\t * can not sign if LANMAN negotiated so no need\n\t * to calculate signing key? but what if server\n\t * changed to do higher than lanman dialect and\n\t * we reconnected would we ever calc signing_key?\n\t */\n\n\tcifs_dbg(FYI, \"Negotiating LANMAN setting up strings\\n\");\n\t/* Unicode not allowed for LANMAN dialects */\n\tascii_ssetup_strings(&bcc_ptr, ses, sess_data->nls_cp);\n\n\tsess_data->iov[2].iov_len = (long) bcc_ptr -\n\t\t\t(long) sess_data->iov[2].iov_base;\n\n\trc = sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)sess_data->iov[0].iov_base;\n\n\t/* lanman response has a word count of 3 */\n\tif (smb_buf->WordCount != 3) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"bad word count %d\\n\", smb_buf->WordCount);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(pSMB->resp.Action) & GUEST_LOGIN)\n\t\tcifs_dbg(FYI, \"Guest login\\n\"); /* BB mark SesInfo struct? */\n\n\tses->Suid = smb_buf->Uid;   /* UID left in wire format (le) */\n\tcifs_dbg(FYI, \"UID = %llu\\n\", ses->Suid);\n\n\tbytes_remaining = get_bcc(smb_buf);\n\tbcc_ptr = pByteArea(smb_buf);\n\n\t/* BB check if Unicode and decode strings */\n\tif (bytes_remaining == 0) {\n\t\t/* no string area to decode, do nothing */\n\t} else if (smb_buf->Flags2 & SMBFLG2_UNICODE) {\n\t\t/* unicode string area must be word-aligned */\n\t\tif (((unsigned long) bcc_ptr - (unsigned long) smb_buf) % 2) {\n\t\t\t++bcc_ptr;\n\t\t\t--bytes_remaining;\n\t\t}\n\t\tdecode_unicode_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t      sess_data->nls_cp);\n\t} else {\n\t\tdecode_ascii_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t    sess_data->nls_cp);\n\t}\n\n\trc = sess_establish_session(sess_data);\nout:\n\tsess_data->result = rc;\n\tsess_data->func = NULL;\n\tsess_free_buffer(sess_data);\n}\n\n#endif\n\nstatic void\nsess_auth_ntlm(struct sess_data *sess_data)\n{\n\tint rc = 0;\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tchar *bcc_ptr;\n\tstruct cifs_ses *ses = sess_data->ses;\n\t__u32 capabilities;\n\t__u16 bytes_remaining;\n\n\t/* old style NTLM sessionsetup */\n\t/* wct = 13 */\n\trc = sess_alloc_buffer(sess_data, 13);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tbcc_ptr = sess_data->iov[2].iov_base;\n\tcapabilities = cifs_ssetup_hdr(ses, pSMB);\n\n\tpSMB->req_no_secext.Capabilities = cpu_to_le32(capabilities);\n\tif (ses->user_name != NULL) {\n\t\tpSMB->req_no_secext.CaseInsensitivePasswordLength =\n\t\t\t\tcpu_to_le16(CIFS_AUTH_RESP_SIZE);\n\t\tpSMB->req_no_secext.CaseSensitivePasswordLength =\n\t\t\t\tcpu_to_le16(CIFS_AUTH_RESP_SIZE);\n\n\t\t/* calculate ntlm response and session key */\n\t\trc = setup_ntlm_response(ses, sess_data->nls_cp);\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"Error %d during NTLM authentication\\n\",\n\t\t\t\t\t rc);\n\t\t\tgoto out;\n\t\t}\n\n\t\t/* copy ntlm response */\n\t\tmemcpy(bcc_ptr, ses->auth_key.response + CIFS_SESS_KEY_SIZE,\n\t\t\t\tCIFS_AUTH_RESP_SIZE);\n\t\tbcc_ptr += CIFS_AUTH_RESP_SIZE;\n\t\tmemcpy(bcc_ptr, ses->auth_key.response + CIFS_SESS_KEY_SIZE,\n\t\t\t\tCIFS_AUTH_RESP_SIZE);\n\t\tbcc_ptr += CIFS_AUTH_RESP_SIZE;\n\t} else {\n\t\tpSMB->req_no_secext.CaseInsensitivePasswordLength = 0;\n\t\tpSMB->req_no_secext.CaseSensitivePasswordLength = 0;\n\t}\n\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\t/* unicode strings must be word aligned */\n\t\tif (sess_data->iov[0].iov_len % 2) {\n\t\t\t*bcc_ptr = 0;\n\t\t\tbcc_ptr++;\n\t\t}\n\t\tunicode_ssetup_strings(&bcc_ptr, ses, sess_data->nls_cp);\n\t} else {\n\t\tascii_ssetup_strings(&bcc_ptr, ses, sess_data->nls_cp);\n\t}\n\n\n\tsess_data->iov[2].iov_len = (long) bcc_ptr -\n\t\t\t(long) sess_data->iov[2].iov_base;\n\n\trc = sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)sess_data->iov[0].iov_base;\n\n\tif (smb_buf->WordCount != 3) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"bad word count %d\\n\", smb_buf->WordCount);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(pSMB->resp.Action) & GUEST_LOGIN)\n\t\tcifs_dbg(FYI, \"Guest login\\n\"); /* BB mark SesInfo struct? */\n\n\tses->Suid = smb_buf->Uid;   /* UID left in wire format (le) */\n\tcifs_dbg(FYI, \"UID = %llu\\n\", ses->Suid);\n\n\tbytes_remaining = get_bcc(smb_buf);\n\tbcc_ptr = pByteArea(smb_buf);\n\n\t/* BB check if Unicode and decode strings */\n\tif (bytes_remaining == 0) {\n\t\t/* no string area to decode, do nothing */\n\t} else if (smb_buf->Flags2 & SMBFLG2_UNICODE) {\n\t\t/* unicode string area must be word-aligned */\n\t\tif (((unsigned long) bcc_ptr - (unsigned long) smb_buf) % 2) {\n\t\t\t++bcc_ptr;\n\t\t\t--bytes_remaining;\n\t\t}\n\t\tdecode_unicode_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t      sess_data->nls_cp);\n\t} else {\n\t\tdecode_ascii_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t    sess_data->nls_cp);\n\t}\n\n\trc = sess_establish_session(sess_data);\nout:\n\tsess_data->result = rc;\n\tsess_data->func = NULL;\n\tsess_free_buffer(sess_data);\n\tkfree(ses->auth_key.response);\n\tses->auth_key.response = NULL;\n}\n\nstatic void\nsess_auth_ntlmv2(struct sess_data *sess_data)\n{\n\tint rc = 0;\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tchar *bcc_ptr;\n\tstruct cifs_ses *ses = sess_data->ses;\n\t__u32 capabilities;\n\t__u16 bytes_remaining;\n\n\t/* old style NTLM sessionsetup */\n\t/* wct = 13 */\n\trc = sess_alloc_buffer(sess_data, 13);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tbcc_ptr = sess_data->iov[2].iov_base;\n\tcapabilities = cifs_ssetup_hdr(ses, pSMB);\n\n\tpSMB->req_no_secext.Capabilities = cpu_to_le32(capabilities);\n\n\t/* LM2 password would be here if we supported it */\n\tpSMB->req_no_secext.CaseInsensitivePasswordLength = 0;\n\n\tif (ses->user_name != NULL) {\n\t\t/* calculate nlmv2 response and session key */\n\t\trc = setup_ntlmv2_rsp(ses, sess_data->nls_cp);\n\t\tif (rc) {\n\t\t\tcifs_dbg(VFS, \"Error %d during NTLMv2 authentication\\n\", rc);\n\t\t\tgoto out;\n\t\t}\n\n\t\tmemcpy(bcc_ptr, ses->auth_key.response + CIFS_SESS_KEY_SIZE,\n\t\t\t\tses->auth_key.len - CIFS_SESS_KEY_SIZE);\n\t\tbcc_ptr += ses->auth_key.len - CIFS_SESS_KEY_SIZE;\n\n\t\t/* set case sensitive password length after tilen may get\n\t\t * assigned, tilen is 0 otherwise.\n\t\t */\n\t\tpSMB->req_no_secext.CaseSensitivePasswordLength =\n\t\t\tcpu_to_le16(ses->auth_key.len - CIFS_SESS_KEY_SIZE);\n\t} else {\n\t\tpSMB->req_no_secext.CaseSensitivePasswordLength = 0;\n\t}\n\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\tif (sess_data->iov[0].iov_len % 2) {\n\t\t\t*bcc_ptr = 0;\n\t\t\tbcc_ptr++;\n\t\t}\n\t\tunicode_ssetup_strings(&bcc_ptr, ses, sess_data->nls_cp);\n\t} else {\n\t\tascii_ssetup_strings(&bcc_ptr, ses, sess_data->nls_cp);\n\t}\n\n\n\tsess_data->iov[2].iov_len = (long) bcc_ptr -\n\t\t\t(long) sess_data->iov[2].iov_base;\n\n\trc = sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)sess_data->iov[0].iov_base;\n\n\tif (smb_buf->WordCount != 3) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"bad word count %d\\n\", smb_buf->WordCount);\n\t\tgoto out;\n\t}\n\n\tif (le16_to_cpu(pSMB->resp.Action) & GUEST_LOGIN)\n\t\tcifs_dbg(FYI, \"Guest login\\n\"); /* BB mark SesInfo struct? */\n\n\tses->Suid = smb_buf->Uid;   /* UID left in wire format (le) */\n\tcifs_dbg(FYI, \"UID = %llu\\n\", ses->Suid);\n\n\tbytes_remaining = get_bcc(smb_buf);\n\tbcc_ptr = pByteArea(smb_buf);\n\n\t/* BB check if Unicode and decode strings */\n\tif (bytes_remaining == 0) {\n\t\t/* no string area to decode, do nothing */\n\t} else if (smb_buf->Flags2 & SMBFLG2_UNICODE) {\n\t\t/* unicode string area must be word-aligned */\n\t\tif (((unsigned long) bcc_ptr - (unsigned long) smb_buf) % 2) {\n\t\t\t++bcc_ptr;\n\t\t\t--bytes_remaining;\n\t\t}\n\t\tdecode_unicode_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t      sess_data->nls_cp);\n\t} else {\n\t\tdecode_ascii_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t    sess_data->nls_cp);\n\t}\n\n\trc = sess_establish_session(sess_data);\nout:\n\tsess_data->result = rc;\n\tsess_data->func = NULL;\n\tsess_free_buffer(sess_data);\n\tkfree(ses->auth_key.response);\n\tses->auth_key.response = NULL;\n}\n\n#ifdef CONFIG_CIFS_UPCALL\nstatic void\nsess_auth_kerberos(struct sess_data *sess_data)\n{\n\tint rc = 0;\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tchar *bcc_ptr;\n\tstruct cifs_ses *ses = sess_data->ses;\n\t__u32 capabilities;\n\t__u16 bytes_remaining;\n\tstruct key *spnego_key = NULL;\n\tstruct cifs_spnego_msg *msg;\n\tu16 blob_len;\n\n\t/* extended security */\n\t/* wct = 12 */\n\trc = sess_alloc_buffer(sess_data, 12);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tbcc_ptr = sess_data->iov[2].iov_base;\n\tcapabilities = cifs_ssetup_hdr(ses, pSMB);\n\n\tspnego_key = cifs_get_spnego_key(ses);\n\tif (IS_ERR(spnego_key)) {\n\t\trc = PTR_ERR(spnego_key);\n\t\tspnego_key = NULL;\n\t\tgoto out;\n\t}\n\n\tmsg = spnego_key->payload.data[0];\n\t/*\n\t * check version field to make sure that cifs.upcall is\n\t * sending us a response in an expected form\n\t */\n\tif (msg->version != CIFS_SPNEGO_UPCALL_VERSION) {\n\t\tcifs_dbg(VFS,\n\t\t  \"incorrect version of cifs.upcall (expected %d but got %d)\",\n\t\t\t      CIFS_SPNEGO_UPCALL_VERSION, msg->version);\n\t\trc = -EKEYREJECTED;\n\t\tgoto out_put_spnego_key;\n\t}\n\n\tses->auth_key.response = kmemdup(msg->data, msg->sesskey_len,\n\t\t\t\t\t GFP_KERNEL);\n\tif (!ses->auth_key.response) {\n\t\tcifs_dbg(VFS, \"Kerberos can't allocate (%u bytes) memory\",\n\t\t\t\tmsg->sesskey_len);\n\t\trc = -ENOMEM;\n\t\tgoto out_put_spnego_key;\n\t}\n\tses->auth_key.len = msg->sesskey_len;\n\n\tpSMB->req.hdr.Flags2 |= SMBFLG2_EXT_SEC;\n\tcapabilities |= CAP_EXTENDED_SECURITY;\n\tpSMB->req.Capabilities = cpu_to_le32(capabilities);\n\tsess_data->iov[1].iov_base = msg->data + msg->sesskey_len;\n\tsess_data->iov[1].iov_len = msg->secblob_len;\n\tpSMB->req.SecurityBlobLength = cpu_to_le16(sess_data->iov[1].iov_len);\n\n\tif (ses->capabilities & CAP_UNICODE) {\n\t\t/* unicode strings must be word aligned */\n\t\tif ((sess_data->iov[0].iov_len\n\t\t\t+ sess_data->iov[1].iov_len) % 2) {\n\t\t\t*bcc_ptr = 0;\n\t\t\tbcc_ptr++;\n\t\t}\n\t\tunicode_oslm_strings(&bcc_ptr, sess_data->nls_cp);\n\t\tunicode_domain_string(&bcc_ptr, ses, sess_data->nls_cp);\n\t} else {\n\t\t/* BB: is this right? */\n\t\tascii_ssetup_strings(&bcc_ptr, ses, sess_data->nls_cp);\n\t}\n\n\tsess_data->iov[2].iov_len = (long) bcc_ptr -\n\t\t\t(long) sess_data->iov[2].iov_base;\n\n\trc = sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out_put_spnego_key;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)sess_data->iov[0].iov_base;\n\n\tif (smb_buf->WordCount != 4) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"bad word count %d\\n\", smb_buf->WordCount);\n\t\tgoto out_put_spnego_key;\n\t}\n\n\tif (le16_to_cpu(pSMB->resp.Action) & GUEST_LOGIN)\n\t\tcifs_dbg(FYI, \"Guest login\\n\"); /* BB mark SesInfo struct? */\n\n\tses->Suid = smb_buf->Uid;   /* UID left in wire format (le) */\n\tcifs_dbg(FYI, \"UID = %llu\\n\", ses->Suid);\n\n\tbytes_remaining = get_bcc(smb_buf);\n\tbcc_ptr = pByteArea(smb_buf);\n\n\tblob_len = le16_to_cpu(pSMB->resp.SecurityBlobLength);\n\tif (blob_len > bytes_remaining) {\n\t\tcifs_dbg(VFS, \"bad security blob length %d\\n\",\n\t\t\t\tblob_len);\n\t\trc = -EINVAL;\n\t\tgoto out_put_spnego_key;\n\t}\n\tbcc_ptr += blob_len;\n\tbytes_remaining -= blob_len;\n\n\t/* BB check if Unicode and decode strings */\n\tif (bytes_remaining == 0) {\n\t\t/* no string area to decode, do nothing */\n\t} else if (smb_buf->Flags2 & SMBFLG2_UNICODE) {\n\t\t/* unicode string area must be word-aligned */\n\t\tif (((unsigned long) bcc_ptr - (unsigned long) smb_buf) % 2) {\n\t\t\t++bcc_ptr;\n\t\t\t--bytes_remaining;\n\t\t}\n\t\tdecode_unicode_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t      sess_data->nls_cp);\n\t} else {\n\t\tdecode_ascii_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t    sess_data->nls_cp);\n\t}\n\n\trc = sess_establish_session(sess_data);\nout_put_spnego_key:\n\tkey_invalidate(spnego_key);\n\tkey_put(spnego_key);\nout:\n\tsess_data->result = rc;\n\tsess_data->func = NULL;\n\tsess_free_buffer(sess_data);\n\tkfree(ses->auth_key.response);\n\tses->auth_key.response = NULL;\n}\n\n#endif /* ! CONFIG_CIFS_UPCALL */\n\n/*\n * The required kvec buffers have to be allocated before calling this\n * function.\n */\nstatic int\n_sess_auth_rawntlmssp_assemble_req(struct sess_data *sess_data)\n{\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tstruct cifs_ses *ses = sess_data->ses;\n\t__u32 capabilities;\n\tchar *bcc_ptr;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)pSMB;\n\n\tcapabilities = cifs_ssetup_hdr(ses, pSMB);\n\tif ((pSMB->req.hdr.Flags2 & SMBFLG2_UNICODE) == 0) {\n\t\tcifs_dbg(VFS, \"NTLMSSP requires Unicode support\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\tpSMB->req.hdr.Flags2 |= SMBFLG2_EXT_SEC;\n\tcapabilities |= CAP_EXTENDED_SECURITY;\n\tpSMB->req.Capabilities |= cpu_to_le32(capabilities);\n\n\tbcc_ptr = sess_data->iov[2].iov_base;\n\t/* unicode strings must be word aligned */\n\tif ((sess_data->iov[0].iov_len + sess_data->iov[1].iov_len) % 2) {\n\t\t*bcc_ptr = 0;\n\t\tbcc_ptr++;\n\t}\n\tunicode_oslm_strings(&bcc_ptr, sess_data->nls_cp);\n\n\tsess_data->iov[2].iov_len = (long) bcc_ptr -\n\t\t\t\t\t(long) sess_data->iov[2].iov_base;\n\n\treturn 0;\n}\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data);\n\nstatic void\nsess_auth_rawntlmssp_negotiate(struct sess_data *sess_data)\n{\n\tint rc;\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tstruct cifs_ses *ses = sess_data->ses;\n\t__u16 bytes_remaining;\n\tchar *bcc_ptr;\n\tu16 blob_len;\n\n\tcifs_dbg(FYI, \"rawntlmssp session setup negotiate phase\\n\");\n\n\t/*\n\t * if memory allocation is successful, caller of this function\n\t * frees it.\n\t */\n\tses->ntlmssp = kmalloc(sizeof(struct ntlmssp_auth), GFP_KERNEL);\n\tif (!ses->ntlmssp) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\tses->ntlmssp->sesskey_per_smbsess = false;\n\n\t/* wct = 12 */\n\trc = sess_alloc_buffer(sess_data, 12);\n\tif (rc)\n\t\tgoto out;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\n\t/* Build security blob before we assemble the request */\n\tbuild_ntlmssp_negotiate_blob(pSMB->req.SecurityBlob, ses);\n\tsess_data->iov[1].iov_len = sizeof(NEGOTIATE_MESSAGE);\n\tsess_data->iov[1].iov_base = pSMB->req.SecurityBlob;\n\tpSMB->req.SecurityBlobLength = cpu_to_le16(sizeof(NEGOTIATE_MESSAGE));\n\n\trc = _sess_auth_rawntlmssp_assemble_req(sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\trc = sess_sendreceive(sess_data);\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)sess_data->iov[0].iov_base;\n\n\t/* If true, rc here is expected and not an error */\n\tif (sess_data->buf0_type != CIFS_NO_BUFFER &&\n\t    smb_buf->Status.CifsError ==\n\t\t\tcpu_to_le32(NT_STATUS_MORE_PROCESSING_REQUIRED))\n\t\trc = 0;\n\n\tif (rc)\n\t\tgoto out;\n\n\tcifs_dbg(FYI, \"rawntlmssp session setup challenge phase\\n\");\n\n\tif (smb_buf->WordCount != 4) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"bad word count %d\\n\", smb_buf->WordCount);\n\t\tgoto out;\n\t}\n\n\tses->Suid = smb_buf->Uid;   /* UID left in wire format (le) */\n\tcifs_dbg(FYI, \"UID = %llu\\n\", ses->Suid);\n\n\tbytes_remaining = get_bcc(smb_buf);\n\tbcc_ptr = pByteArea(smb_buf);\n\n\tblob_len = le16_to_cpu(pSMB->resp.SecurityBlobLength);\n\tif (blob_len > bytes_remaining) {\n\t\tcifs_dbg(VFS, \"bad security blob length %d\\n\",\n\t\t\t\tblob_len);\n\t\trc = -EINVAL;\n\t\tgoto out;\n\t}\n\n\trc = decode_ntlmssp_challenge(bcc_ptr, blob_len, ses);\nout:\n\tsess_free_buffer(sess_data);\n\n\tif (!rc) {\n\t\tsess_data->func = sess_auth_rawntlmssp_authenticate;\n\t\treturn;\n\t}\n\n\t/* Else error. Cleanup */\n\tkfree(ses->auth_key.response);\n\tses->auth_key.response = NULL;\n\tkfree(ses->ntlmssp);\n\tses->ntlmssp = NULL;\n\n\tsess_data->func = NULL;\n\tsess_data->result = rc;\n}\n\nstatic void\nsess_auth_rawntlmssp_authenticate(struct sess_data *sess_data)\n{\n\tint rc;\n\tstruct smb_hdr *smb_buf;\n\tSESSION_SETUP_ANDX *pSMB;\n\tstruct cifs_ses *ses = sess_data->ses;\n\t__u16 bytes_remaining;\n\tchar *bcc_ptr;\n\tunsigned char *ntlmsspblob = NULL;\n\tu16 blob_len;\n\n\tcifs_dbg(FYI, \"rawntlmssp session setup authenticate phase\\n\");\n\n\t/* wct = 12 */\n\trc = sess_alloc_buffer(sess_data, 12);\n\tif (rc)\n\t\tgoto out;\n\n\t/* Build security blob before we assemble the request */\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)pSMB;\n\trc = build_ntlmssp_auth_blob(&ntlmsspblob,\n\t\t\t\t\t&blob_len, ses, sess_data->nls_cp);\n\tif (rc)\n\t\tgoto out_free_ntlmsspblob;\n\tsess_data->iov[1].iov_len = blob_len;\n\tsess_data->iov[1].iov_base = ntlmsspblob;\n\tpSMB->req.SecurityBlobLength = cpu_to_le16(blob_len);\n\t/*\n\t * Make sure that we tell the server that we are using\n\t * the uid that it just gave us back on the response\n\t * (challenge)\n\t */\n\tsmb_buf->Uid = ses->Suid;\n\n\trc = _sess_auth_rawntlmssp_assemble_req(sess_data);\n\tif (rc)\n\t\tgoto out_free_ntlmsspblob;\n\n\trc = sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out_free_ntlmsspblob;\n\n\tpSMB = (SESSION_SETUP_ANDX *)sess_data->iov[0].iov_base;\n\tsmb_buf = (struct smb_hdr *)sess_data->iov[0].iov_base;\n\tif (smb_buf->WordCount != 4) {\n\t\trc = -EIO;\n\t\tcifs_dbg(VFS, \"bad word count %d\\n\", smb_buf->WordCount);\n\t\tgoto out_free_ntlmsspblob;\n\t}\n\n\tif (le16_to_cpu(pSMB->resp.Action) & GUEST_LOGIN)\n\t\tcifs_dbg(FYI, \"Guest login\\n\"); /* BB mark SesInfo struct? */\n\n\tif (ses->Suid != smb_buf->Uid) {\n\t\tses->Suid = smb_buf->Uid;\n\t\tcifs_dbg(FYI, \"UID changed! new UID = %llu\\n\", ses->Suid);\n\t}\n\n\tbytes_remaining = get_bcc(smb_buf);\n\tbcc_ptr = pByteArea(smb_buf);\n\tblob_len = le16_to_cpu(pSMB->resp.SecurityBlobLength);\n\tif (blob_len > bytes_remaining) {\n\t\tcifs_dbg(VFS, \"bad security blob length %d\\n\",\n\t\t\t\tblob_len);\n\t\trc = -EINVAL;\n\t\tgoto out_free_ntlmsspblob;\n\t}\n\tbcc_ptr += blob_len;\n\tbytes_remaining -= blob_len;\n\n\n\t/* BB check if Unicode and decode strings */\n\tif (bytes_remaining == 0) {\n\t\t/* no string area to decode, do nothing */\n\t} else if (smb_buf->Flags2 & SMBFLG2_UNICODE) {\n\t\t/* unicode string area must be word-aligned */\n\t\tif (((unsigned long) bcc_ptr - (unsigned long) smb_buf) % 2) {\n\t\t\t++bcc_ptr;\n\t\t\t--bytes_remaining;\n\t\t}\n\t\tdecode_unicode_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t      sess_data->nls_cp);\n\t} else {\n\t\tdecode_ascii_ssetup(&bcc_ptr, bytes_remaining, ses,\n\t\t\t\t    sess_data->nls_cp);\n\t}\n\nout_free_ntlmsspblob:\n\tkfree(ntlmsspblob);\nout:\n\tsess_free_buffer(sess_data);\n\n\t if (!rc)\n\t\trc = sess_establish_session(sess_data);\n\n\t/* Cleanup */\n\tkfree(ses->auth_key.response);\n\tses->auth_key.response = NULL;\n\tkfree(ses->ntlmssp);\n\tses->ntlmssp = NULL;\n\n\tsess_data->func = NULL;\n\tsess_data->result = rc;\n}\n\nstatic int select_sec(struct cifs_ses *ses, struct sess_data *sess_data)\n{\n\tint type;\n\n\ttype = select_sectype(ses->server, ses->sectype);\n\tcifs_dbg(FYI, \"sess setup type %d\\n\", type);\n\tif (type == Unspecified) {\n\t\tcifs_dbg(VFS,\n\t\t\t\"Unable to select appropriate authentication method!\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (type) {\n\tcase LANMAN:\n\t\t/* LANMAN and plaintext are less secure and off by default.\n\t\t * So we make this explicitly be turned on in kconfig (in the\n\t\t * build) and turned on at runtime (changed from the default)\n\t\t * in proc/fs/cifs or via mount parm.  Unfortunately this is\n\t\t * needed for old Win (e.g. Win95), some obscure NAS and OS/2 */\n#ifdef CONFIG_CIFS_WEAK_PW_HASH\n\t\tsess_data->func = sess_auth_lanman;\n\t\tbreak;\n#else\n\t\treturn -EOPNOTSUPP;\n#endif\n\tcase NTLM:\n\t\tsess_data->func = sess_auth_ntlm;\n\t\tbreak;\n\tcase NTLMv2:\n\t\tsess_data->func = sess_auth_ntlmv2;\n\t\tbreak;\n\tcase Kerberos:\n#ifdef CONFIG_CIFS_UPCALL\n\t\tsess_data->func = sess_auth_kerberos;\n\t\tbreak;\n#else\n\t\tcifs_dbg(VFS, \"Kerberos negotiated but upcall support disabled!\\n\");\n\t\treturn -ENOSYS;\n\t\tbreak;\n#endif /* CONFIG_CIFS_UPCALL */\n\tcase RawNTLMSSP:\n\t\tsess_data->func = sess_auth_rawntlmssp_negotiate;\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"secType %d not supported!\\n\", type);\n\t\treturn -ENOSYS;\n\t}\n\n\treturn 0;\n}\n\nint CIFS_SessSetup(const unsigned int xid, struct cifs_ses *ses,\n\t\t    const struct nls_table *nls_cp)\n{\n\tint rc = 0;\n\tstruct sess_data *sess_data;\n\n\tif (ses == NULL) {\n\t\tWARN(1, \"%s: ses == NULL!\", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tsess_data = kzalloc(sizeof(struct sess_data), GFP_KERNEL);\n\tif (!sess_data)\n\t\treturn -ENOMEM;\n\n\trc = select_sec(ses, sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\tsess_data->xid = xid;\n\tsess_data->ses = ses;\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\tsess_data->nls_cp = (struct nls_table *) nls_cp;\n\n\twhile (sess_data->func)\n\t\tsess_data->func(sess_data);\n\n\t/* Store result before we free sess_data */\n\trc = sess_data->result;\n\nout:\n\tkfree(sess_data);\n\treturn rc;\n}\n", "/*\n *   fs/cifs/smb2pdu.c\n *\n *   Copyright (C) International Business Machines  Corp., 2009, 2013\n *                 Etersoft, 2012\n *   Author(s): Steve French (sfrench@us.ibm.com)\n *              Pavel Shilovsky (pshilovsky@samba.org) 2012\n *\n *   Contains the routines for constructing the SMB2 PDUs themselves\n *\n *   This library is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU Lesser General Public License as published\n *   by the Free Software Foundation; either version 2.1 of the License, or\n *   (at your option) any later version.\n *\n *   This library is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See\n *   the GNU Lesser General Public License for more details.\n *\n *   You should have received a copy of the GNU Lesser General Public License\n *   along with this library; if not, write to the Free Software\n *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n */\n\n /* SMB2 PDU handling routines here - except for leftovers (eg session setup) */\n /* Note that there are handle based routines which must be\t\t      */\n /* treated slightly differently for reconnection purposes since we never     */\n /* want to reuse a stale file handle and only the caller knows the file info */\n\n#include <linux/fs.h>\n#include <linux/kernel.h>\n#include <linux/vfs.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/uaccess.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n#include \"smb2pdu.h\"\n#include \"cifsglob.h\"\n#include \"cifsacl.h\"\n#include \"cifsproto.h\"\n#include \"smb2proto.h\"\n#include \"cifs_unicode.h\"\n#include \"cifs_debug.h\"\n#include \"ntlmssp.h\"\n#include \"smb2status.h\"\n#include \"smb2glob.h\"\n#include \"cifspdu.h\"\n#include \"cifs_spnego.h\"\n\n/*\n *  The following table defines the expected \"StructureSize\" of SMB2 requests\n *  in order by SMB2 command.  This is similar to \"wct\" in SMB/CIFS requests.\n *\n *  Note that commands are defined in smb2pdu.h in le16 but the array below is\n *  indexed by command in host byte order.\n */\nstatic const int smb2_req_struct_sizes[NUMBER_OF_SMB2_COMMANDS] = {\n\t/* SMB2_NEGOTIATE */ 36,\n\t/* SMB2_SESSION_SETUP */ 25,\n\t/* SMB2_LOGOFF */ 4,\n\t/* SMB2_TREE_CONNECT */\t9,\n\t/* SMB2_TREE_DISCONNECT */ 4,\n\t/* SMB2_CREATE */ 57,\n\t/* SMB2_CLOSE */ 24,\n\t/* SMB2_FLUSH */ 24,\n\t/* SMB2_READ */\t49,\n\t/* SMB2_WRITE */ 49,\n\t/* SMB2_LOCK */\t48,\n\t/* SMB2_IOCTL */ 57,\n\t/* SMB2_CANCEL */ 4,\n\t/* SMB2_ECHO */ 4,\n\t/* SMB2_QUERY_DIRECTORY */ 33,\n\t/* SMB2_CHANGE_NOTIFY */ 32,\n\t/* SMB2_QUERY_INFO */ 41,\n\t/* SMB2_SET_INFO */ 33,\n\t/* SMB2_OPLOCK_BREAK */ 24 /* BB this is 36 for LEASE_BREAK variant */\n};\n\nstatic int encryption_required(const struct cifs_tcon *tcon)\n{\n\tif ((tcon->ses->session_flags & SMB2_SESSION_FLAG_ENCRYPT_DATA) ||\n\t    (tcon->share_flags & SHI1005_FLAGS_ENCRYPT_DATA))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic void\nsmb2_hdr_assemble(struct smb2_sync_hdr *shdr, __le16 smb2_cmd,\n\t\t  const struct cifs_tcon *tcon)\n{\n\tshdr->ProtocolId = SMB2_PROTO_NUMBER;\n\tshdr->StructureSize = cpu_to_le16(64);\n\tshdr->Command = smb2_cmd;\n\tif (tcon && tcon->ses && tcon->ses->server) {\n\t\tstruct TCP_Server_Info *server = tcon->ses->server;\n\n\t\tspin_lock(&server->req_lock);\n\t\t/* Request up to 2 credits but don't go over the limit. */\n\t\tif (server->credits >= server->max_credits)\n\t\t\tshdr->CreditRequest = cpu_to_le16(0);\n\t\telse\n\t\t\tshdr->CreditRequest = cpu_to_le16(\n\t\t\t\tmin_t(int, server->max_credits -\n\t\t\t\t\t\tserver->credits, 2));\n\t\tspin_unlock(&server->req_lock);\n\t} else {\n\t\tshdr->CreditRequest = cpu_to_le16(2);\n\t}\n\tshdr->ProcessId = cpu_to_le32((__u16)current->tgid);\n\n\tif (!tcon)\n\t\tgoto out;\n\n\t/* GLOBAL_CAP_LARGE_MTU will only be set if dialect > SMB2.02 */\n\t/* See sections 2.2.4 and 3.2.4.1.5 of MS-SMB2 */\n\tif ((tcon->ses) && (tcon->ses->server) &&\n\t    (tcon->ses->server->capabilities & SMB2_GLOBAL_CAP_LARGE_MTU))\n\t\tshdr->CreditCharge = cpu_to_le16(1);\n\t/* else CreditCharge MBZ */\n\n\tshdr->TreeId = tcon->tid;\n\t/* Uid is not converted */\n\tif (tcon->ses)\n\t\tshdr->SessionId = tcon->ses->Suid;\n\n\t/*\n\t * If we would set SMB2_FLAGS_DFS_OPERATIONS on open we also would have\n\t * to pass the path on the Open SMB prefixed by \\\\server\\share.\n\t * Not sure when we would need to do the augmented path (if ever) and\n\t * setting this flag breaks the SMB2 open operation since it is\n\t * illegal to send an empty path name (without \\\\server\\share prefix)\n\t * when the DFS flag is set in the SMB open header. We could\n\t * consider setting the flag on all operations other than open\n\t * but it is safer to net set it for now.\n\t */\n/*\tif (tcon->share_flags & SHI1005_FLAGS_DFS)\n\t\tshdr->Flags |= SMB2_FLAGS_DFS_OPERATIONS; */\n\n\tif (tcon->ses && tcon->ses->server && tcon->ses->server->sign &&\n\t    !encryption_required(tcon))\n\t\tshdr->Flags |= SMB2_FLAGS_SIGNED;\nout:\n\treturn;\n}\n\nstatic int\nsmb2_reconnect(__le16 smb2_command, struct cifs_tcon *tcon)\n{\n\tint rc = 0;\n\tstruct nls_table *nls_codepage;\n\tstruct cifs_ses *ses;\n\tstruct TCP_Server_Info *server;\n\n\t/*\n\t * SMB2s NegProt, SessSetup, Logoff do not have tcon yet so\n\t * check for tcp and smb session status done differently\n\t * for those three - in the calling routine.\n\t */\n\tif (tcon == NULL)\n\t\treturn rc;\n\n\tif (smb2_command == SMB2_TREE_CONNECT)\n\t\treturn rc;\n\n\tif (tcon->tidStatus == CifsExiting) {\n\t\t/*\n\t\t * only tree disconnect, open, and write,\n\t\t * (and ulogoff which does not have tcon)\n\t\t * are allowed as we start force umount.\n\t\t */\n\t\tif ((smb2_command != SMB2_WRITE) &&\n\t\t   (smb2_command != SMB2_CREATE) &&\n\t\t   (smb2_command != SMB2_TREE_DISCONNECT)) {\n\t\t\tcifs_dbg(FYI, \"can not send cmd %d while umounting\\n\",\n\t\t\t\t smb2_command);\n\t\t\treturn -ENODEV;\n\t\t}\n\t}\n\tif ((!tcon->ses) || (tcon->ses->status == CifsExiting) ||\n\t    (!tcon->ses->server))\n\t\treturn -EIO;\n\n\tses = tcon->ses;\n\tserver = ses->server;\n\n\t/*\n\t * Give demultiplex thread up to 10 seconds to reconnect, should be\n\t * greater than cifs socket timeout which is 7 seconds\n\t */\n\twhile (server->tcpStatus == CifsNeedReconnect) {\n\t\t/*\n\t\t * Return to caller for TREE_DISCONNECT and LOGOFF and CLOSE\n\t\t * here since they are implicitly done when session drops.\n\t\t */\n\t\tswitch (smb2_command) {\n\t\t/*\n\t\t * BB Should we keep oplock break and add flush to exceptions?\n\t\t */\n\t\tcase SMB2_TREE_DISCONNECT:\n\t\tcase SMB2_CANCEL:\n\t\tcase SMB2_CLOSE:\n\t\tcase SMB2_OPLOCK_BREAK:\n\t\t\treturn -EAGAIN;\n\t\t}\n\n\t\twait_event_interruptible_timeout(server->response_q,\n\t\t\t(server->tcpStatus != CifsNeedReconnect), 10 * HZ);\n\n\t\t/* are we still trying to reconnect? */\n\t\tif (server->tcpStatus != CifsNeedReconnect)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * on \"soft\" mounts we wait once. Hard mounts keep\n\t\t * retrying until process is killed or server comes\n\t\t * back on-line\n\t\t */\n\t\tif (!tcon->retry) {\n\t\t\tcifs_dbg(FYI, \"gave up waiting on reconnect in smb_init\\n\");\n\t\t\treturn -EHOSTDOWN;\n\t\t}\n\t}\n\n\tif (!tcon->ses->need_reconnect && !tcon->need_reconnect)\n\t\treturn rc;\n\n\tnls_codepage = load_nls_default();\n\n\t/*\n\t * need to prevent multiple threads trying to simultaneously reconnect\n\t * the same SMB session\n\t */\n\tmutex_lock(&tcon->ses->session_mutex);\n\trc = cifs_negotiate_protocol(0, tcon->ses);\n\tif (!rc && tcon->ses->need_reconnect)\n\t\trc = cifs_setup_session(0, tcon->ses, nls_codepage);\n\n\tif (rc || !tcon->need_reconnect) {\n\t\tmutex_unlock(&tcon->ses->session_mutex);\n\t\tgoto out;\n\t}\n\n\tcifs_mark_open_files_invalid(tcon);\n\tif (tcon->use_persistent)\n\t\ttcon->need_reopen_files = true;\n\n\trc = SMB2_tcon(0, tcon->ses, tcon->treeName, tcon, nls_codepage);\n\tmutex_unlock(&tcon->ses->session_mutex);\n\n\tcifs_dbg(FYI, \"reconnect tcon rc = %d\\n\", rc);\n\tif (rc)\n\t\tgoto out;\n\n\tif (smb2_command != SMB2_INTERNAL_CMD)\n\t\tqueue_delayed_work(cifsiod_wq, &server->reconnect, 0);\n\n\tatomic_inc(&tconInfoReconnectCount);\nout:\n\t/*\n\t * Check if handle based operation so we know whether we can continue\n\t * or not without returning to caller to reset file handle.\n\t */\n\t/*\n\t * BB Is flush done by server on drop of tcp session? Should we special\n\t * case it and skip above?\n\t */\n\tswitch (smb2_command) {\n\tcase SMB2_FLUSH:\n\tcase SMB2_READ:\n\tcase SMB2_WRITE:\n\tcase SMB2_LOCK:\n\tcase SMB2_IOCTL:\n\tcase SMB2_QUERY_DIRECTORY:\n\tcase SMB2_CHANGE_NOTIFY:\n\tcase SMB2_QUERY_INFO:\n\tcase SMB2_SET_INFO:\n\t\trc = -EAGAIN;\n\t}\n\tunload_nls(nls_codepage);\n\treturn rc;\n}\n\nstatic void\nfill_small_buf(__le16 smb2_command, struct cifs_tcon *tcon, void *buf,\n\t       unsigned int *total_len)\n{\n\tstruct smb2_sync_pdu *spdu = (struct smb2_sync_pdu *)buf;\n\t/* lookup word count ie StructureSize from table */\n\t__u16 parmsize = smb2_req_struct_sizes[le16_to_cpu(smb2_command)];\n\n\t/*\n\t * smaller than SMALL_BUFFER_SIZE but bigger than fixed area of\n\t * largest operations (Create)\n\t */\n\tmemset(buf, 0, 256);\n\n\tsmb2_hdr_assemble(&spdu->sync_hdr, smb2_command, tcon);\n\tspdu->StructureSize2 = cpu_to_le16(parmsize);\n\n\t*total_len = parmsize + sizeof(struct smb2_sync_hdr);\n}\n\n/* init request without RFC1001 length at the beginning */\nstatic int\nsmb2_plain_req_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\t    void **request_buf, unsigned int *total_len)\n{\n\tint rc;\n\tstruct smb2_sync_hdr *shdr;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tshdr = (struct smb2_sync_hdr *)(*request_buf);\n\n\tfill_small_buf(smb2_command, tcon, shdr, total_len);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}\n\n/*\n * Allocate and return pointer to an SMB request hdr, and set basic\n * SMB information in the SMB header. If the return code is zero, this\n * function must have filled in request_buf pointer. The returned buffer\n * has RFC1001 length at the beginning.\n */\nstatic int\nsmall_smb2_init(__le16 smb2_command, struct cifs_tcon *tcon,\n\t\tvoid **request_buf)\n{\n\tint rc;\n\tunsigned int total_len;\n\tstruct smb2_pdu *pdu;\n\n\trc = smb2_reconnect(smb2_command, tcon);\n\tif (rc)\n\t\treturn rc;\n\n\t/* BB eventually switch this to SMB2 specific small buf size */\n\t*request_buf = cifs_small_buf_get();\n\tif (*request_buf == NULL) {\n\t\t/* BB should we add a retry in here if not a writepage? */\n\t\treturn -ENOMEM;\n\t}\n\n\tpdu = (struct smb2_pdu *)(*request_buf);\n\n\tfill_small_buf(smb2_command, tcon, get_sync_hdr(pdu), &total_len);\n\n\t/* Note this is only network field converted to big endian */\n\tpdu->hdr.smb2_buf_length = cpu_to_be32(total_len);\n\n\tif (tcon != NULL) {\n#ifdef CONFIG_CIFS_STATS2\n\t\tuint16_t com_code = le16_to_cpu(smb2_command);\n\t\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_sent[com_code]);\n#endif\n\t\tcifs_stats_inc(&tcon->num_smbs_sent);\n\t}\n\n\treturn rc;\n}\n\n#ifdef CONFIG_CIFS_SMB311\n/* offset is sizeof smb2_negotiate_req - 4 but rounded up to 8 bytes */\n#define OFFSET_OF_NEG_CONTEXT 0x68  /* sizeof(struct smb2_negotiate_req) - 4 */\n\n\n#define SMB2_PREAUTH_INTEGRITY_CAPABILITIES\tcpu_to_le16(1)\n#define SMB2_ENCRYPTION_CAPABILITIES\t\tcpu_to_le16(2)\n\nstatic void\nbuild_preauth_ctxt(struct smb2_preauth_neg_context *pneg_ctxt)\n{\n\tpneg_ctxt->ContextType = SMB2_PREAUTH_INTEGRITY_CAPABILITIES;\n\tpneg_ctxt->DataLength = cpu_to_le16(38);\n\tpneg_ctxt->HashAlgorithmCount = cpu_to_le16(1);\n\tpneg_ctxt->SaltLength = cpu_to_le16(SMB311_SALT_SIZE);\n\tget_random_bytes(pneg_ctxt->Salt, SMB311_SALT_SIZE);\n\tpneg_ctxt->HashAlgorithms = SMB2_PREAUTH_INTEGRITY_SHA512;\n}\n\nstatic void\nbuild_encrypt_ctxt(struct smb2_encryption_neg_context *pneg_ctxt)\n{\n\tpneg_ctxt->ContextType = SMB2_ENCRYPTION_CAPABILITIES;\n\tpneg_ctxt->DataLength = cpu_to_le16(6);\n\tpneg_ctxt->CipherCount = cpu_to_le16(2);\n\tpneg_ctxt->Ciphers[0] = SMB2_ENCRYPTION_AES128_GCM;\n\tpneg_ctxt->Ciphers[1] = SMB2_ENCRYPTION_AES128_CCM;\n}\n\nstatic void\nassemble_neg_contexts(struct smb2_negotiate_req *req)\n{\n\n\t/* +4 is to account for the RFC1001 len field */\n\tchar *pneg_ctxt = (char *)req + OFFSET_OF_NEG_CONTEXT + 4;\n\n\tbuild_preauth_ctxt((struct smb2_preauth_neg_context *)pneg_ctxt);\n\t/* Add 2 to size to round to 8 byte boundary */\n\tpneg_ctxt += 2 + sizeof(struct smb2_preauth_neg_context);\n\tbuild_encrypt_ctxt((struct smb2_encryption_neg_context *)pneg_ctxt);\n\treq->NegotiateContextOffset = cpu_to_le32(OFFSET_OF_NEG_CONTEXT);\n\treq->NegotiateContextCount = cpu_to_le16(2);\n\tinc_rfc1001_len(req, 4 + sizeof(struct smb2_preauth_neg_context) + 2\n\t\t\t+ sizeof(struct smb2_encryption_neg_context)); /* calculate hash */\n}\n#else\nstatic void assemble_neg_contexts(struct smb2_negotiate_req *req)\n{\n\treturn;\n}\n#endif /* SMB311 */\n\n/*\n *\n *\tSMB2 Worker functions follow:\n *\n *\tThe general structure of the worker functions is:\n *\t1) Call smb2_init (assembles SMB2 header)\n *\t2) Initialize SMB2 command specific fields in fixed length area of SMB\n *\t3) Call smb_sendrcv2 (sends request on socket and waits for response)\n *\t4) Decode SMB2 command specific fields in the fixed length area\n *\t5) Decode variable length data area (if any for this SMB2 command type)\n *\t6) Call free smb buffer\n *\t7) return\n *\n */\n\nint\nSMB2_negotiate(const unsigned int xid, struct cifs_ses *ses)\n{\n\tstruct smb2_negotiate_req *req;\n\tstruct smb2_negotiate_rsp *rsp;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tint rc = 0;\n\tint resp_buftype;\n\tstruct TCP_Server_Info *server = ses->server;\n\tint blob_offset, blob_length;\n\tchar *security_blob;\n\tint flags = CIFS_NEG_OP;\n\n\tcifs_dbg(FYI, \"Negotiate protocol\\n\");\n\n\tif (!server) {\n\t\tWARN(1, \"%s: server is NULL!\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\trc = small_smb2_init(SMB2_NEGOTIATE, NULL, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->hdr.sync_hdr.SessionId = 0;\n\n\treq->Dialects[0] = cpu_to_le16(ses->server->vals->protocol_id);\n\n\treq->DialectCount = cpu_to_le16(1); /* One vers= at a time for now */\n\tinc_rfc1001_len(req, 2);\n\n\t/* only one of SMB2 signing flags may be set in SMB2 request */\n\tif (ses->sign)\n\t\treq->SecurityMode = cpu_to_le16(SMB2_NEGOTIATE_SIGNING_REQUIRED);\n\telse if (global_secflags & CIFSSEC_MAY_SIGN)\n\t\treq->SecurityMode = cpu_to_le16(SMB2_NEGOTIATE_SIGNING_ENABLED);\n\telse\n\t\treq->SecurityMode = 0;\n\n\treq->Capabilities = cpu_to_le32(ses->server->vals->req_capabilities);\n\n\t/* ClientGUID must be zero for SMB2.02 dialect */\n\tif (ses->server->vals->protocol_id == SMB20_PROT_ID)\n\t\tmemset(req->ClientGUID, 0, SMB2_CLIENT_GUID_SIZE);\n\telse {\n\t\tmemcpy(req->ClientGUID, server->client_guid,\n\t\t\tSMB2_CLIENT_GUID_SIZE);\n\t\tif (ses->server->vals->protocol_id == SMB311_PROT_ID)\n\t\t\tassemble_neg_contexts(req);\n\t}\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\trsp = (struct smb2_negotiate_rsp *)rsp_iov.iov_base;\n\t/*\n\t * No tcon so can't do\n\t * cifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_fail[SMB2...]);\n\t */\n\tif (rc != 0)\n\t\tgoto neg_exit;\n\n\tcifs_dbg(FYI, \"mode 0x%x\\n\", rsp->SecurityMode);\n\n\t/* BB we may eventually want to match the negotiated vs. requested\n\t   dialect, even though we are only requesting one at a time */\n\tif (rsp->DialectRevision == cpu_to_le16(SMB20_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb2.0 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB21_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb2.1 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB30_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb3.0 dialect\\n\");\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB302_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb3.02 dialect\\n\");\n#ifdef CONFIG_CIFS_SMB311\n\telse if (rsp->DialectRevision == cpu_to_le16(SMB311_PROT_ID))\n\t\tcifs_dbg(FYI, \"negotiated smb3.1.1 dialect\\n\");\n#endif /* SMB311 */\n\telse {\n\t\tcifs_dbg(VFS, \"Illegal dialect returned by server 0x%x\\n\",\n\t\t\t le16_to_cpu(rsp->DialectRevision));\n\t\trc = -EIO;\n\t\tgoto neg_exit;\n\t}\n\tserver->dialect = le16_to_cpu(rsp->DialectRevision);\n\n\t/* SMB2 only has an extended negflavor */\n\tserver->negflavor = CIFS_NEGFLAVOR_EXTENDED;\n\t/* set it to the maximum buffer size value we can send with 1 credit */\n\tserver->maxBuf = min_t(unsigned int, le32_to_cpu(rsp->MaxTransactSize),\n\t\t\t       SMB2_MAX_BUFFER_SIZE);\n\tserver->max_read = le32_to_cpu(rsp->MaxReadSize);\n\tserver->max_write = le32_to_cpu(rsp->MaxWriteSize);\n\t/* BB Do we need to validate the SecurityMode? */\n\tserver->sec_mode = le16_to_cpu(rsp->SecurityMode);\n\tserver->capabilities = le32_to_cpu(rsp->Capabilities);\n\t/* Internal types */\n\tserver->capabilities |= SMB2_NT_FIND | SMB2_LARGE_FILES;\n\n\tsecurity_blob = smb2_get_data_area_len(&blob_offset, &blob_length,\n\t\t\t\t\t       &rsp->hdr);\n\t/*\n\t * See MS-SMB2 section 2.2.4: if no blob, client picks default which\n\t * for us will be\n\t *\tses->sectype = RawNTLMSSP;\n\t * but for time being this is our only auth choice so doesn't matter.\n\t * We just found a server which sets blob length to zero expecting raw.\n\t */\n\tif (blob_length == 0)\n\t\tcifs_dbg(FYI, \"missing security blob on negprot\\n\");\n\n\trc = cifs_enable_signing(server, ses->sign);\n\tif (rc)\n\t\tgoto neg_exit;\n\tif (blob_length) {\n\t\trc = decode_negTokenInit(security_blob, blob_length, server);\n\t\tif (rc == 1)\n\t\t\trc = 0;\n\t\telse if (rc == 0)\n\t\t\trc = -EIO;\n\t}\nneg_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}\n\nint smb3_validate_negotiate(const unsigned int xid, struct cifs_tcon *tcon)\n{\n\tint rc = 0;\n\tstruct validate_negotiate_info_req vneg_inbuf;\n\tstruct validate_negotiate_info_rsp *pneg_rsp;\n\tu32 rsplen;\n\n\tcifs_dbg(FYI, \"validate negotiate\\n\");\n\n\t/*\n\t * validation ioctl must be signed, so no point sending this if we\n\t * can not sign it.  We could eventually change this to selectively\n\t * sign just this, the first and only signed request on a connection.\n\t * This is good enough for now since a user who wants better security\n\t * would also enable signing on the mount. Having validation of\n\t * negotiate info for signed connections helps reduce attack vectors\n\t */\n\tif (tcon->ses->server->sign == false)\n\t\treturn 0; /* validation requires signing */\n\n\tvneg_inbuf.Capabilities =\n\t\t\tcpu_to_le32(tcon->ses->server->vals->req_capabilities);\n\tmemcpy(vneg_inbuf.Guid, tcon->ses->server->client_guid,\n\t\t\t\t\tSMB2_CLIENT_GUID_SIZE);\n\n\tif (tcon->ses->sign)\n\t\tvneg_inbuf.SecurityMode =\n\t\t\tcpu_to_le16(SMB2_NEGOTIATE_SIGNING_REQUIRED);\n\telse if (global_secflags & CIFSSEC_MAY_SIGN)\n\t\tvneg_inbuf.SecurityMode =\n\t\t\tcpu_to_le16(SMB2_NEGOTIATE_SIGNING_ENABLED);\n\telse\n\t\tvneg_inbuf.SecurityMode = 0;\n\n\tvneg_inbuf.DialectCount = cpu_to_le16(1);\n\tvneg_inbuf.Dialects[0] =\n\t\tcpu_to_le16(tcon->ses->server->vals->protocol_id);\n\n\trc = SMB2_ioctl(xid, tcon, NO_FILE_ID, NO_FILE_ID,\n\t\tFSCTL_VALIDATE_NEGOTIATE_INFO, true /* is_fsctl */,\n\t\t(char *)&vneg_inbuf, sizeof(struct validate_negotiate_info_req),\n\t\t(char **)&pneg_rsp, &rsplen);\n\n\tif (rc != 0) {\n\t\tcifs_dbg(VFS, \"validate protocol negotiate failed: %d\\n\", rc);\n\t\treturn -EIO;\n\t}\n\n\tif (rsplen != sizeof(struct validate_negotiate_info_rsp)) {\n\t\tcifs_dbg(VFS, \"invalid size of protocol negotiate response\\n\");\n\t\treturn -EIO;\n\t}\n\n\t/* check validate negotiate info response matches what we got earlier */\n\tif (pneg_rsp->Dialect !=\n\t\t\tcpu_to_le16(tcon->ses->server->vals->protocol_id))\n\t\tgoto vneg_out;\n\n\tif (pneg_rsp->SecurityMode != cpu_to_le16(tcon->ses->server->sec_mode))\n\t\tgoto vneg_out;\n\n\t/* do not validate server guid because not saved at negprot time yet */\n\n\tif ((le32_to_cpu(pneg_rsp->Capabilities) | SMB2_NT_FIND |\n\t      SMB2_LARGE_FILES) != tcon->ses->server->capabilities)\n\t\tgoto vneg_out;\n\n\t/* validate negotiate successful */\n\tcifs_dbg(FYI, \"validate negotiate info successful\\n\");\n\treturn 0;\n\nvneg_out:\n\tcifs_dbg(VFS, \"protocol revalidation - security settings mismatch\\n\");\n\treturn -EIO;\n}\n\nstruct SMB2_sess_data {\n\tunsigned int xid;\n\tstruct cifs_ses *ses;\n\tstruct nls_table *nls_cp;\n\tvoid (*func)(struct SMB2_sess_data *);\n\tint result;\n\tu64 previous_session;\n\n\t/* we will send the SMB in three pieces:\n\t * a fixed length beginning part, an optional\n\t * SPNEGO blob (which can be zero length), and a\n\t * last part which will include the strings\n\t * and rest of bcc area. This allows us to avoid\n\t * a large buffer 17K allocation\n\t */\n\tint buf0_type;\n\tstruct kvec iov[2];\n};\n\nstatic int\nSMB2_sess_alloc_buffer(struct SMB2_sess_data *sess_data)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct smb2_sess_setup_req *req;\n\tstruct TCP_Server_Info *server = ses->server;\n\n\trc = small_smb2_init(SMB2_SESSION_SETUP, NULL, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\t/* First session, not a reauthenticate */\n\treq->hdr.sync_hdr.SessionId = 0;\n\n\t/* if reconnect, we need to send previous sess id, otherwise it is 0 */\n\treq->PreviousSessionId = sess_data->previous_session;\n\n\treq->Flags = 0; /* MBZ */\n\t/* to enable echos and oplocks */\n\treq->hdr.sync_hdr.CreditRequest = cpu_to_le16(3);\n\n\t/* only one of SMB2 signing flags may be set in SMB2 request */\n\tif (server->sign)\n\t\treq->SecurityMode = SMB2_NEGOTIATE_SIGNING_REQUIRED;\n\telse if (global_secflags & CIFSSEC_MAY_SIGN) /* one flag unlike MUST_ */\n\t\treq->SecurityMode = SMB2_NEGOTIATE_SIGNING_ENABLED;\n\telse\n\t\treq->SecurityMode = 0;\n\n\treq->Capabilities = 0;\n\treq->Channel = 0; /* MBZ */\n\n\tsess_data->iov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field and 1 for pad */\n\tsess_data->iov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\t/*\n\t * This variable will be used to clear the buffer\n\t * allocated above in case of any error in the calling function.\n\t */\n\tsess_data->buf0_type = CIFS_SMALL_BUFFER;\n\n\treturn 0;\n}\n\nstatic void\nSMB2_sess_free_buffer(struct SMB2_sess_data *sess_data)\n{\n\tfree_rsp_buf(sess_data->buf0_type, sess_data->iov[0].iov_base);\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n}\n\nstatic int\nSMB2_sess_sendreceive(struct SMB2_sess_data *sess_data)\n{\n\tint rc;\n\tstruct smb2_sess_setup_req *req = sess_data->iov[0].iov_base;\n\tstruct kvec rsp_iov = { NULL, 0 };\n\n\t/* Testing shows that buffer offset must be at location of Buffer[0] */\n\treq->SecurityBufferOffset =\n\t\tcpu_to_le16(sizeof(struct smb2_sess_setup_req) -\n\t\t\t1 /* pad */ - 4 /* rfc1001 len */);\n\treq->SecurityBufferLength = cpu_to_le16(sess_data->iov[1].iov_len);\n\n\tinc_rfc1001_len(req, sess_data->iov[1].iov_len - 1 /* pad */);\n\n\t/* BB add code to build os and lm fields */\n\n\trc = SendReceive2(sess_data->xid, sess_data->ses,\n\t\t\t\tsess_data->iov, 2,\n\t\t\t\t&sess_data->buf0_type,\n\t\t\t\tCIFS_LOG_ERROR | CIFS_NEG_OP, &rsp_iov);\n\tcifs_small_buf_release(sess_data->iov[0].iov_base);\n\tmemcpy(&sess_data->iov[0], &rsp_iov, sizeof(struct kvec));\n\n\treturn rc;\n}\n\nstatic int\nSMB2_sess_establish_session(struct SMB2_sess_data *sess_data)\n{\n\tint rc = 0;\n\tstruct cifs_ses *ses = sess_data->ses;\n\n\tmutex_lock(&ses->server->srv_mutex);\n\tif (ses->server->ops->generate_signingkey) {\n\t\trc = ses->server->ops->generate_signingkey(ses);\n\t\tif (rc) {\n\t\t\tcifs_dbg(FYI,\n\t\t\t\t\"SMB3 session key generation failed\\n\");\n\t\t\tmutex_unlock(&ses->server->srv_mutex);\n\t\t\treturn rc;\n\t\t}\n\t}\n\tif (!ses->server->session_estab) {\n\t\tses->server->sequence_number = 0x2;\n\t\tses->server->session_estab = true;\n\t}\n\tmutex_unlock(&ses->server->srv_mutex);\n\n\tcifs_dbg(FYI, \"SMB2/3 session established successfully\\n\");\n\tspin_lock(&GlobalMid_Lock);\n\tses->status = CifsGood;\n\tses->need_reconnect = false;\n\tspin_unlock(&GlobalMid_Lock);\n\treturn rc;\n}\n\n#ifdef CONFIG_CIFS_UPCALL\nstatic void\nSMB2_auth_kerberos(struct SMB2_sess_data *sess_data)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct cifs_spnego_msg *msg;\n\tstruct key *spnego_key = NULL;\n\tstruct smb2_sess_setup_rsp *rsp = NULL;\n\n\trc = SMB2_sess_alloc_buffer(sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\tspnego_key = cifs_get_spnego_key(ses);\n\tif (IS_ERR(spnego_key)) {\n\t\trc = PTR_ERR(spnego_key);\n\t\tspnego_key = NULL;\n\t\tgoto out;\n\t}\n\n\tmsg = spnego_key->payload.data[0];\n\t/*\n\t * check version field to make sure that cifs.upcall is\n\t * sending us a response in an expected form\n\t */\n\tif (msg->version != CIFS_SPNEGO_UPCALL_VERSION) {\n\t\tcifs_dbg(VFS,\n\t\t\t  \"bad cifs.upcall version. Expected %d got %d\",\n\t\t\t  CIFS_SPNEGO_UPCALL_VERSION, msg->version);\n\t\trc = -EKEYREJECTED;\n\t\tgoto out_put_spnego_key;\n\t}\n\n\tses->auth_key.response = kmemdup(msg->data, msg->sesskey_len,\n\t\t\t\t\t GFP_KERNEL);\n\tif (!ses->auth_key.response) {\n\t\tcifs_dbg(VFS,\n\t\t\t\"Kerberos can't allocate (%u bytes) memory\",\n\t\t\tmsg->sesskey_len);\n\t\trc = -ENOMEM;\n\t\tgoto out_put_spnego_key;\n\t}\n\tses->auth_key.len = msg->sesskey_len;\n\n\tsess_data->iov[1].iov_base = msg->data + msg->sesskey_len;\n\tsess_data->iov[1].iov_len = msg->secblob_len;\n\n\trc = SMB2_sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out_put_spnego_key;\n\n\trsp = (struct smb2_sess_setup_rsp *)sess_data->iov[0].iov_base;\n\tses->Suid = rsp->hdr.sync_hdr.SessionId;\n\n\tses->session_flags = le16_to_cpu(rsp->SessionFlags);\n\tif (ses->session_flags & SMB2_SESSION_FLAG_ENCRYPT_DATA)\n\t\tcifs_dbg(VFS, \"SMB3 encryption not supported yet\\n\");\n\n\trc = SMB2_sess_establish_session(sess_data);\nout_put_spnego_key:\n\tkey_invalidate(spnego_key);\n\tkey_put(spnego_key);\nout:\n\tsess_data->result = rc;\n\tsess_data->func = NULL;\n\tSMB2_sess_free_buffer(sess_data);\n}\n#else\nstatic void\nSMB2_auth_kerberos(struct SMB2_sess_data *sess_data)\n{\n\tcifs_dbg(VFS, \"Kerberos negotiated but upcall support disabled!\\n\");\n\tsess_data->result = -EOPNOTSUPP;\n\tsess_data->func = NULL;\n}\n#endif\n\nstatic void\nSMB2_sess_auth_rawntlmssp_authenticate(struct SMB2_sess_data *sess_data);\n\nstatic void\nSMB2_sess_auth_rawntlmssp_negotiate(struct SMB2_sess_data *sess_data)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct smb2_sess_setup_rsp *rsp = NULL;\n\tchar *ntlmssp_blob = NULL;\n\tbool use_spnego = false; /* else use raw ntlmssp */\n\tu16 blob_length = 0;\n\n\t/*\n\t * If memory allocation is successful, caller of this function\n\t * frees it.\n\t */\n\tses->ntlmssp = kmalloc(sizeof(struct ntlmssp_auth), GFP_KERNEL);\n\tif (!ses->ntlmssp) {\n\t\trc = -ENOMEM;\n\t\tgoto out_err;\n\t}\n\tses->ntlmssp->sesskey_per_smbsess = true;\n\n\trc = SMB2_sess_alloc_buffer(sess_data);\n\tif (rc)\n\t\tgoto out_err;\n\n\tntlmssp_blob = kmalloc(sizeof(struct _NEGOTIATE_MESSAGE),\n\t\t\t       GFP_KERNEL);\n\tif (ntlmssp_blob == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tbuild_ntlmssp_negotiate_blob(ntlmssp_blob, ses);\n\tif (use_spnego) {\n\t\t/* BB eventually need to add this */\n\t\tcifs_dbg(VFS, \"spnego not supported for SMB2 yet\\n\");\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t} else {\n\t\tblob_length = sizeof(struct _NEGOTIATE_MESSAGE);\n\t\t/* with raw NTLMSSP we don't encapsulate in SPNEGO */\n\t}\n\tsess_data->iov[1].iov_base = ntlmssp_blob;\n\tsess_data->iov[1].iov_len = blob_length;\n\n\trc = SMB2_sess_sendreceive(sess_data);\n\trsp = (struct smb2_sess_setup_rsp *)sess_data->iov[0].iov_base;\n\n\t/* If true, rc here is expected and not an error */\n\tif (sess_data->buf0_type != CIFS_NO_BUFFER &&\n\t\trsp->hdr.sync_hdr.Status == STATUS_MORE_PROCESSING_REQUIRED)\n\t\trc = 0;\n\n\tif (rc)\n\t\tgoto out;\n\n\tif (offsetof(struct smb2_sess_setup_rsp, Buffer) - 4 !=\n\t\t\tle16_to_cpu(rsp->SecurityBufferOffset)) {\n\t\tcifs_dbg(VFS, \"Invalid security buffer offset %d\\n\",\n\t\t\tle16_to_cpu(rsp->SecurityBufferOffset));\n\t\trc = -EIO;\n\t\tgoto out;\n\t}\n\trc = decode_ntlmssp_challenge(rsp->Buffer,\n\t\t\tle16_to_cpu(rsp->SecurityBufferLength), ses);\n\tif (rc)\n\t\tgoto out;\n\n\tcifs_dbg(FYI, \"rawntlmssp session setup challenge phase\\n\");\n\n\n\tses->Suid = rsp->hdr.sync_hdr.SessionId;\n\tses->session_flags = le16_to_cpu(rsp->SessionFlags);\n\tif (ses->session_flags & SMB2_SESSION_FLAG_ENCRYPT_DATA)\n\t\tcifs_dbg(VFS, \"SMB3 encryption not supported yet\\n\");\n\nout:\n\tkfree(ntlmssp_blob);\n\tSMB2_sess_free_buffer(sess_data);\n\tif (!rc) {\n\t\tsess_data->result = 0;\n\t\tsess_data->func = SMB2_sess_auth_rawntlmssp_authenticate;\n\t\treturn;\n\t}\nout_err:\n\tkfree(ses->ntlmssp);\n\tses->ntlmssp = NULL;\n\tsess_data->result = rc;\n\tsess_data->func = NULL;\n}\n\nstatic void\nSMB2_sess_auth_rawntlmssp_authenticate(struct SMB2_sess_data *sess_data)\n{\n\tint rc;\n\tstruct cifs_ses *ses = sess_data->ses;\n\tstruct smb2_sess_setup_req *req;\n\tstruct smb2_sess_setup_rsp *rsp = NULL;\n\tunsigned char *ntlmssp_blob = NULL;\n\tbool use_spnego = false; /* else use raw ntlmssp */\n\tu16 blob_length = 0;\n\n\trc = SMB2_sess_alloc_buffer(sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\treq = (struct smb2_sess_setup_req *) sess_data->iov[0].iov_base;\n\treq->hdr.sync_hdr.SessionId = ses->Suid;\n\n\trc = build_ntlmssp_auth_blob(&ntlmssp_blob, &blob_length, ses,\n\t\t\t\t\tsess_data->nls_cp);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"build_ntlmssp_auth_blob failed %d\\n\", rc);\n\t\tgoto out;\n\t}\n\n\tif (use_spnego) {\n\t\t/* BB eventually need to add this */\n\t\tcifs_dbg(VFS, \"spnego not supported for SMB2 yet\\n\");\n\t\trc = -EOPNOTSUPP;\n\t\tgoto out;\n\t}\n\tsess_data->iov[1].iov_base = ntlmssp_blob;\n\tsess_data->iov[1].iov_len = blob_length;\n\n\trc = SMB2_sess_sendreceive(sess_data);\n\tif (rc)\n\t\tgoto out;\n\n\trsp = (struct smb2_sess_setup_rsp *)sess_data->iov[0].iov_base;\n\n\tses->Suid = rsp->hdr.sync_hdr.SessionId;\n\tses->session_flags = le16_to_cpu(rsp->SessionFlags);\n\tif (ses->session_flags & SMB2_SESSION_FLAG_ENCRYPT_DATA)\n\t\tcifs_dbg(VFS, \"SMB3 encryption not supported yet\\n\");\n\n\trc = SMB2_sess_establish_session(sess_data);\nout:\n\tkfree(ntlmssp_blob);\n\tSMB2_sess_free_buffer(sess_data);\n\tkfree(ses->ntlmssp);\n\tses->ntlmssp = NULL;\n\tsess_data->result = rc;\n\tsess_data->func = NULL;\n}\n\nstatic int\nSMB2_select_sec(struct cifs_ses *ses, struct SMB2_sess_data *sess_data)\n{\n\tif (ses->sectype != Kerberos && ses->sectype != RawNTLMSSP)\n\t\tses->sectype = RawNTLMSSP;\n\n\tswitch (ses->sectype) {\n\tcase Kerberos:\n\t\tsess_data->func = SMB2_auth_kerberos;\n\t\tbreak;\n\tcase RawNTLMSSP:\n\t\tsess_data->func = SMB2_sess_auth_rawntlmssp_negotiate;\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"secType %d not supported!\\n\", ses->sectype);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nint\nSMB2_sess_setup(const unsigned int xid, struct cifs_ses *ses,\n\t\tconst struct nls_table *nls_cp)\n{\n\tint rc = 0;\n\tstruct TCP_Server_Info *server = ses->server;\n\tstruct SMB2_sess_data *sess_data;\n\n\tcifs_dbg(FYI, \"Session Setup\\n\");\n\n\tif (!server) {\n\t\tWARN(1, \"%s: server is NULL!\\n\", __func__);\n\t\treturn -EIO;\n\t}\n\n\tsess_data = kzalloc(sizeof(struct SMB2_sess_data), GFP_KERNEL);\n\tif (!sess_data)\n\t\treturn -ENOMEM;\n\n\trc = SMB2_select_sec(ses, sess_data);\n\tif (rc)\n\t\tgoto out;\n\tsess_data->xid = xid;\n\tsess_data->ses = ses;\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\tsess_data->nls_cp = (struct nls_table *) nls_cp;\n\n\twhile (sess_data->func)\n\t\tsess_data->func(sess_data);\n\n\trc = sess_data->result;\nout:\n\tkfree(sess_data);\n\treturn rc;\n}\n\nint\nSMB2_logoff(const unsigned int xid, struct cifs_ses *ses)\n{\n\tstruct smb2_logoff_req *req; /* response is also trivial struct */\n\tint rc = 0;\n\tstruct TCP_Server_Info *server;\n\tint flags = 0;\n\n\tcifs_dbg(FYI, \"disconnect session %p\\n\", ses);\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\t/* no need to send SMB logoff if uid already closed due to reconnect */\n\tif (ses->need_reconnect)\n\t\tgoto smb2_session_already_dead;\n\n\trc = small_smb2_init(SMB2_LOGOFF, NULL, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\t /* since no tcon, smb2_init can not do this, so do here */\n\treq->hdr.sync_hdr.SessionId = ses->Suid;\n\n\tif (ses->session_flags & SMB2_SESSION_FLAG_ENCRYPT_DATA)\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\telse if (server->sign)\n\t\treq->hdr.sync_hdr.Flags |= SMB2_FLAGS_SIGNED;\n\n\trc = SendReceiveNoRsp(xid, ses, (char *) req, flags);\n\tcifs_small_buf_release(req);\n\t/*\n\t * No tcon so can't do\n\t * cifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_fail[SMB2...]);\n\t */\n\nsmb2_session_already_dead:\n\treturn rc;\n}\n\nstatic inline void cifs_stats_fail_inc(struct cifs_tcon *tcon, uint16_t code)\n{\n\tcifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_failed[code]);\n}\n\n#define MAX_SHARENAME_LENGTH (255 /* server */ + 80 /* share */ + 1 /* NULL */)\n\n/* These are similar values to what Windows uses */\nstatic inline void init_copy_chunk_defaults(struct cifs_tcon *tcon)\n{\n\ttcon->max_chunks = 256;\n\ttcon->max_bytes_chunk = 1048576;\n\ttcon->max_bytes_copy = 16777216;\n}\n\nint\nSMB2_tcon(const unsigned int xid, struct cifs_ses *ses, const char *tree,\n\t  struct cifs_tcon *tcon, const struct nls_table *cp)\n{\n\tstruct smb2_tree_connect_req *req;\n\tstruct smb2_tree_connect_rsp *rsp = NULL;\n\tstruct kvec iov[2];\n\tstruct kvec rsp_iov;\n\tint rc = 0;\n\tint resp_buftype;\n\tint unc_path_len;\n\tstruct TCP_Server_Info *server;\n\t__le16 *unc_path = NULL;\n\tint flags = 0;\n\n\tcifs_dbg(FYI, \"TCON\\n\");\n\n\tif ((ses->server) && tree)\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\tif (tcon && tcon->bad_network_name)\n\t\treturn -ENOENT;\n\n\tif ((tcon && tcon->seal) &&\n\t    ((ses->server->capabilities & SMB2_GLOBAL_CAP_ENCRYPTION) == 0)) {\n\t\tcifs_dbg(VFS, \"encryption requested but no server support\");\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tunc_path = kmalloc(MAX_SHARENAME_LENGTH * 2, GFP_KERNEL);\n\tif (unc_path == NULL)\n\t\treturn -ENOMEM;\n\n\tunc_path_len = cifs_strtoUTF16(unc_path, tree, strlen(tree), cp) + 1;\n\tunc_path_len *= 2;\n\tif (unc_path_len < 2) {\n\t\tkfree(unc_path);\n\t\treturn -EINVAL;\n\t}\n\n\trc = small_smb2_init(SMB2_TREE_CONNECT, tcon, (void **) &req);\n\tif (rc) {\n\t\tkfree(unc_path);\n\t\treturn rc;\n\t}\n\n\tif (ses->session_flags & SMB2_SESSION_FLAG_ENCRYPT_DATA)\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tif (tcon == NULL) {\n\t\t/* since no tcon, smb2_init can not do this, so do here */\n\t\treq->hdr.sync_hdr.SessionId = ses->Suid;\n\t\t/* if (ses->server->sec_mode & SECMODE_SIGN_REQUIRED)\n\t\t\treq->hdr.Flags |= SMB2_FLAGS_SIGNED; */\n\t}\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field and 1 for pad */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\n\t/* Testing shows that buffer offset must be at location of Buffer[0] */\n\treq->PathOffset = cpu_to_le16(sizeof(struct smb2_tree_connect_req)\n\t\t\t- 1 /* pad */ - 4 /* do not count rfc1001 len field */);\n\treq->PathLength = cpu_to_le16(unc_path_len - 2);\n\tiov[1].iov_base = unc_path;\n\tiov[1].iov_len = unc_path_len;\n\n\tinc_rfc1001_len(req, unc_path_len - 1 /* pad */);\n\n\trc = SendReceive2(xid, ses, iov, 2, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\trsp = (struct smb2_tree_connect_rsp *)rsp_iov.iov_base;\n\n\tif (rc != 0) {\n\t\tif (tcon) {\n\t\t\tcifs_stats_fail_inc(tcon, SMB2_TREE_CONNECT_HE);\n\t\t\ttcon->need_reconnect = true;\n\t\t}\n\t\tgoto tcon_error_exit;\n\t}\n\n\tif (tcon == NULL) {\n\t\tses->ipc_tid = rsp->hdr.sync_hdr.TreeId;\n\t\tgoto tcon_exit;\n\t}\n\n\tif (rsp->ShareType & SMB2_SHARE_TYPE_DISK)\n\t\tcifs_dbg(FYI, \"connection to disk share\\n\");\n\telse if (rsp->ShareType & SMB2_SHARE_TYPE_PIPE) {\n\t\ttcon->ipc = true;\n\t\tcifs_dbg(FYI, \"connection to pipe share\\n\");\n\t} else if (rsp->ShareType & SMB2_SHARE_TYPE_PRINT) {\n\t\ttcon->print = true;\n\t\tcifs_dbg(FYI, \"connection to printer\\n\");\n\t} else {\n\t\tcifs_dbg(VFS, \"unknown share type %d\\n\", rsp->ShareType);\n\t\trc = -EOPNOTSUPP;\n\t\tgoto tcon_error_exit;\n\t}\n\n\ttcon->share_flags = le32_to_cpu(rsp->ShareFlags);\n\ttcon->capabilities = rsp->Capabilities; /* we keep caps little endian */\n\ttcon->maximal_access = le32_to_cpu(rsp->MaximalAccess);\n\ttcon->tidStatus = CifsGood;\n\ttcon->need_reconnect = false;\n\ttcon->tid = rsp->hdr.sync_hdr.TreeId;\n\tstrlcpy(tcon->treeName, tree, sizeof(tcon->treeName));\n\n\tif ((rsp->Capabilities & SMB2_SHARE_CAP_DFS) &&\n\t    ((tcon->share_flags & SHI1005_FLAGS_DFS) == 0))\n\t\tcifs_dbg(VFS, \"DFS capability contradicts DFS flag\\n\");\n\tinit_copy_chunk_defaults(tcon);\n\tif (tcon->share_flags & SHI1005_FLAGS_ENCRYPT_DATA)\n\t\tcifs_dbg(VFS, \"Encrypted shares not supported\");\n\tif (tcon->ses->server->ops->validate_negotiate)\n\t\trc = tcon->ses->server->ops->validate_negotiate(xid, tcon);\ntcon_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\tkfree(unc_path);\n\treturn rc;\n\ntcon_error_exit:\n\tif (rsp->hdr.sync_hdr.Status == STATUS_BAD_NETWORK_NAME) {\n\t\tcifs_dbg(VFS, \"BAD_NETWORK_NAME: %s\\n\", tree);\n\t\tif (tcon)\n\t\t\ttcon->bad_network_name = true;\n\t}\n\tgoto tcon_exit;\n}\n\nint\nSMB2_tdis(const unsigned int xid, struct cifs_tcon *tcon)\n{\n\tstruct smb2_tree_disconnect_req *req; /* response is trivial */\n\tint rc = 0;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tint flags = 0;\n\n\tcifs_dbg(FYI, \"Tree Disconnect\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\tif ((tcon->need_reconnect) || (tcon->ses->need_reconnect))\n\t\treturn 0;\n\n\trc = small_smb2_init(SMB2_TREE_DISCONNECT, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\trc = SendReceiveNoRsp(xid, ses, (char *)req, flags);\n\tcifs_small_buf_release(req);\n\tif (rc)\n\t\tcifs_stats_fail_inc(tcon, SMB2_TREE_DISCONNECT_HE);\n\n\treturn rc;\n}\n\n\nstatic struct create_durable *\ncreate_durable_buf(void)\n{\n\tstruct create_durable *buf;\n\n\tbuf = kzalloc(sizeof(struct create_durable), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct create_durable, Data));\n\tbuf->ccontext.DataLength = cpu_to_le32(16);\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_durable, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\t/* SMB2_CREATE_DURABLE_HANDLE_REQUEST is \"DHnQ\" */\n\tbuf->Name[0] = 'D';\n\tbuf->Name[1] = 'H';\n\tbuf->Name[2] = 'n';\n\tbuf->Name[3] = 'Q';\n\treturn buf;\n}\n\nstatic struct create_durable *\ncreate_reconnect_durable_buf(struct cifs_fid *fid)\n{\n\tstruct create_durable *buf;\n\n\tbuf = kzalloc(sizeof(struct create_durable), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct create_durable, Data));\n\tbuf->ccontext.DataLength = cpu_to_le32(16);\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_durable, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\tbuf->Data.Fid.PersistentFileId = fid->persistent_fid;\n\tbuf->Data.Fid.VolatileFileId = fid->volatile_fid;\n\t/* SMB2_CREATE_DURABLE_HANDLE_RECONNECT is \"DHnC\" */\n\tbuf->Name[0] = 'D';\n\tbuf->Name[1] = 'H';\n\tbuf->Name[2] = 'n';\n\tbuf->Name[3] = 'C';\n\treturn buf;\n}\n\nstatic __u8\nparse_lease_state(struct TCP_Server_Info *server, struct smb2_create_rsp *rsp,\n\t\t  unsigned int *epoch)\n{\n\tchar *data_offset;\n\tstruct create_context *cc;\n\tunsigned int next;\n\tunsigned int remaining;\n\tchar *name;\n\n\tdata_offset = (char *)rsp + 4 + le32_to_cpu(rsp->CreateContextsOffset);\n\tremaining = le32_to_cpu(rsp->CreateContextsLength);\n\tcc = (struct create_context *)data_offset;\n\twhile (remaining >= sizeof(struct create_context)) {\n\t\tname = le16_to_cpu(cc->NameOffset) + (char *)cc;\n\t\tif (le16_to_cpu(cc->NameLength) == 4 &&\n\t\t    strncmp(name, \"RqLs\", 4) == 0)\n\t\t\treturn server->ops->parse_lease_buf(cc, epoch);\n\n\t\tnext = le32_to_cpu(cc->Next);\n\t\tif (!next)\n\t\t\tbreak;\n\t\tremaining -= next;\n\t\tcc = (struct create_context *)((char *)cc + next);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nadd_lease_context(struct TCP_Server_Info *server, struct kvec *iov,\n\t\t  unsigned int *num_iovec, __u8 *oplock)\n{\n\tstruct smb2_create_req *req = iov[0].iov_base;\n\tunsigned int num = *num_iovec;\n\n\tiov[num].iov_base = server->ops->create_lease_buf(oplock+1, *oplock);\n\tif (iov[num].iov_base == NULL)\n\t\treturn -ENOMEM;\n\tiov[num].iov_len = server->vals->create_lease_size;\n\treq->RequestedOplockLevel = SMB2_OPLOCK_LEVEL_LEASE;\n\tif (!req->CreateContextsOffset)\n\t\treq->CreateContextsOffset = cpu_to_le32(\n\t\t\t\tsizeof(struct smb2_create_req) - 4 +\n\t\t\t\tiov[num - 1].iov_len);\n\tle32_add_cpu(&req->CreateContextsLength,\n\t\t     server->vals->create_lease_size);\n\tinc_rfc1001_len(&req->hdr, server->vals->create_lease_size);\n\t*num_iovec = num + 1;\n\treturn 0;\n}\n\nstatic struct create_durable_v2 *\ncreate_durable_v2_buf(struct cifs_fid *pfid)\n{\n\tstruct create_durable_v2 *buf;\n\n\tbuf = kzalloc(sizeof(struct create_durable_v2), GFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->ccontext.DataOffset = cpu_to_le16(offsetof\n\t\t\t\t\t(struct create_durable_v2, dcontext));\n\tbuf->ccontext.DataLength = cpu_to_le32(sizeof(struct durable_context_v2));\n\tbuf->ccontext.NameOffset = cpu_to_le16(offsetof\n\t\t\t\t(struct create_durable_v2, Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\n\tbuf->dcontext.Timeout = 0; /* Should this be configurable by workload */\n\tbuf->dcontext.Flags = cpu_to_le32(SMB2_DHANDLE_FLAG_PERSISTENT);\n\tgenerate_random_uuid(buf->dcontext.CreateGuid);\n\tmemcpy(pfid->create_guid, buf->dcontext.CreateGuid, 16);\n\n\t/* SMB2_CREATE_DURABLE_HANDLE_REQUEST is \"DH2Q\" */\n\tbuf->Name[0] = 'D';\n\tbuf->Name[1] = 'H';\n\tbuf->Name[2] = '2';\n\tbuf->Name[3] = 'Q';\n\treturn buf;\n}\n\nstatic struct create_durable_handle_reconnect_v2 *\ncreate_reconnect_durable_v2_buf(struct cifs_fid *fid)\n{\n\tstruct create_durable_handle_reconnect_v2 *buf;\n\n\tbuf = kzalloc(sizeof(struct create_durable_handle_reconnect_v2),\n\t\t\tGFP_KERNEL);\n\tif (!buf)\n\t\treturn NULL;\n\n\tbuf->ccontext.DataOffset =\n\t\tcpu_to_le16(offsetof(struct create_durable_handle_reconnect_v2,\n\t\t\t\t     dcontext));\n\tbuf->ccontext.DataLength =\n\t\tcpu_to_le32(sizeof(struct durable_reconnect_context_v2));\n\tbuf->ccontext.NameOffset =\n\t\tcpu_to_le16(offsetof(struct create_durable_handle_reconnect_v2,\n\t\t\t    Name));\n\tbuf->ccontext.NameLength = cpu_to_le16(4);\n\n\tbuf->dcontext.Fid.PersistentFileId = fid->persistent_fid;\n\tbuf->dcontext.Fid.VolatileFileId = fid->volatile_fid;\n\tbuf->dcontext.Flags = cpu_to_le32(SMB2_DHANDLE_FLAG_PERSISTENT);\n\tmemcpy(buf->dcontext.CreateGuid, fid->create_guid, 16);\n\n\t/* SMB2_CREATE_DURABLE_HANDLE_RECONNECT_V2 is \"DH2C\" */\n\tbuf->Name[0] = 'D';\n\tbuf->Name[1] = 'H';\n\tbuf->Name[2] = '2';\n\tbuf->Name[3] = 'C';\n\treturn buf;\n}\n\nstatic int\nadd_durable_v2_context(struct kvec *iov, unsigned int *num_iovec,\n\t\t    struct cifs_open_parms *oparms)\n{\n\tstruct smb2_create_req *req = iov[0].iov_base;\n\tunsigned int num = *num_iovec;\n\n\tiov[num].iov_base = create_durable_v2_buf(oparms->fid);\n\tif (iov[num].iov_base == NULL)\n\t\treturn -ENOMEM;\n\tiov[num].iov_len = sizeof(struct create_durable_v2);\n\tif (!req->CreateContextsOffset)\n\t\treq->CreateContextsOffset =\n\t\t\tcpu_to_le32(sizeof(struct smb2_create_req) - 4 +\n\t\t\t\t\t\t\t\tiov[1].iov_len);\n\tle32_add_cpu(&req->CreateContextsLength, sizeof(struct create_durable_v2));\n\tinc_rfc1001_len(&req->hdr, sizeof(struct create_durable_v2));\n\t*num_iovec = num + 1;\n\treturn 0;\n}\n\nstatic int\nadd_durable_reconnect_v2_context(struct kvec *iov, unsigned int *num_iovec,\n\t\t    struct cifs_open_parms *oparms)\n{\n\tstruct smb2_create_req *req = iov[0].iov_base;\n\tunsigned int num = *num_iovec;\n\n\t/* indicate that we don't need to relock the file */\n\toparms->reconnect = false;\n\n\tiov[num].iov_base = create_reconnect_durable_v2_buf(oparms->fid);\n\tif (iov[num].iov_base == NULL)\n\t\treturn -ENOMEM;\n\tiov[num].iov_len = sizeof(struct create_durable_handle_reconnect_v2);\n\tif (!req->CreateContextsOffset)\n\t\treq->CreateContextsOffset =\n\t\t\tcpu_to_le32(sizeof(struct smb2_create_req) - 4 +\n\t\t\t\t\t\t\t\tiov[1].iov_len);\n\tle32_add_cpu(&req->CreateContextsLength,\n\t\t\tsizeof(struct create_durable_handle_reconnect_v2));\n\tinc_rfc1001_len(&req->hdr,\n\t\t\tsizeof(struct create_durable_handle_reconnect_v2));\n\t*num_iovec = num + 1;\n\treturn 0;\n}\n\nstatic int\nadd_durable_context(struct kvec *iov, unsigned int *num_iovec,\n\t\t    struct cifs_open_parms *oparms, bool use_persistent)\n{\n\tstruct smb2_create_req *req = iov[0].iov_base;\n\tunsigned int num = *num_iovec;\n\n\tif (use_persistent) {\n\t\tif (oparms->reconnect)\n\t\t\treturn add_durable_reconnect_v2_context(iov, num_iovec,\n\t\t\t\t\t\t\t\toparms);\n\t\telse\n\t\t\treturn add_durable_v2_context(iov, num_iovec, oparms);\n\t}\n\n\tif (oparms->reconnect) {\n\t\tiov[num].iov_base = create_reconnect_durable_buf(oparms->fid);\n\t\t/* indicate that we don't need to relock the file */\n\t\toparms->reconnect = false;\n\t} else\n\t\tiov[num].iov_base = create_durable_buf();\n\tif (iov[num].iov_base == NULL)\n\t\treturn -ENOMEM;\n\tiov[num].iov_len = sizeof(struct create_durable);\n\tif (!req->CreateContextsOffset)\n\t\treq->CreateContextsOffset =\n\t\t\tcpu_to_le32(sizeof(struct smb2_create_req) - 4 +\n\t\t\t\t\t\t\t\tiov[1].iov_len);\n\tle32_add_cpu(&req->CreateContextsLength, sizeof(struct create_durable));\n\tinc_rfc1001_len(&req->hdr, sizeof(struct create_durable));\n\t*num_iovec = num + 1;\n\treturn 0;\n}\n\nint\nSMB2_open(const unsigned int xid, struct cifs_open_parms *oparms, __le16 *path,\n\t  __u8 *oplock, struct smb2_file_all_info *buf,\n\t  struct smb2_err_rsp **err_buf)\n{\n\tstruct smb2_create_req *req;\n\tstruct smb2_create_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_tcon *tcon = oparms->tcon;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[4];\n\tstruct kvec rsp_iov;\n\tint resp_buftype;\n\tint uni_path_len;\n\t__le16 *copy_path = NULL;\n\tint copy_size;\n\tint rc = 0;\n\tunsigned int n_iov = 2;\n\t__u32 file_attributes = 0;\n\tchar *dhc_buf = NULL, *lc_buf = NULL;\n\tint flags = 0;\n\n\tcifs_dbg(FYI, \"create/open\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CREATE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tif (oparms->create_options & CREATE_OPTION_READONLY)\n\t\tfile_attributes |= ATTR_READONLY;\n\tif (oparms->create_options & CREATE_OPTION_SPECIAL)\n\t\tfile_attributes |= ATTR_SYSTEM;\n\n\treq->ImpersonationLevel = IL_IMPERSONATION;\n\treq->DesiredAccess = cpu_to_le32(oparms->desired_access);\n\t/* File attributes ignored on open (used in create though) */\n\treq->FileAttributes = cpu_to_le32(file_attributes);\n\treq->ShareAccess = FILE_SHARE_ALL_LE;\n\treq->CreateDisposition = cpu_to_le32(oparms->disposition);\n\treq->CreateOptions = cpu_to_le32(oparms->create_options & CREATE_OPTIONS_MASK);\n\tuni_path_len = (2 * UniStrnlen((wchar_t *)path, PATH_MAX)) + 2;\n\t/* do not count rfc1001 len field */\n\treq->NameOffset = cpu_to_le16(sizeof(struct smb2_create_req) - 4);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\t/* MUST set path len (NameLength) to 0 opening root of share */\n\treq->NameLength = cpu_to_le16(uni_path_len - 2);\n\t/* -1 since last byte is buf[0] which is sent below (path) */\n\tiov[0].iov_len--;\n\tif (uni_path_len % 8 != 0) {\n\t\tcopy_size = uni_path_len / 8 * 8;\n\t\tif (copy_size < uni_path_len)\n\t\t\tcopy_size += 8;\n\n\t\tcopy_path = kzalloc(copy_size, GFP_KERNEL);\n\t\tif (!copy_path)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy((char *)copy_path, (const char *)path,\n\t\t\tuni_path_len);\n\t\tuni_path_len = copy_size;\n\t\tpath = copy_path;\n\t}\n\n\tiov[1].iov_len = uni_path_len;\n\tiov[1].iov_base = path;\n\t/* -1 since last byte is buf[0] which was counted in smb2_buf_len */\n\tinc_rfc1001_len(req, uni_path_len - 1);\n\n\tif (!server->oplocks)\n\t\t*oplock = SMB2_OPLOCK_LEVEL_NONE;\n\n\tif (!(server->capabilities & SMB2_GLOBAL_CAP_LEASING) ||\n\t    *oplock == SMB2_OPLOCK_LEVEL_NONE)\n\t\treq->RequestedOplockLevel = *oplock;\n\telse {\n\t\trc = add_lease_context(server, iov, &n_iov, oplock);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\treturn rc;\n\t\t}\n\t\tlc_buf = iov[n_iov-1].iov_base;\n\t}\n\n\tif (*oplock == SMB2_OPLOCK_LEVEL_BATCH) {\n\t\t/* need to set Next field of lease context if we request it */\n\t\tif (server->capabilities & SMB2_GLOBAL_CAP_LEASING) {\n\t\t\tstruct create_context *ccontext =\n\t\t\t    (struct create_context *)iov[n_iov-1].iov_base;\n\t\t\tccontext->Next =\n\t\t\t\tcpu_to_le32(server->vals->create_lease_size);\n\t\t}\n\n\t\trc = add_durable_context(iov, &n_iov, oparms,\n\t\t\t\t\ttcon->use_persistent);\n\t\tif (rc) {\n\t\t\tcifs_small_buf_release(req);\n\t\t\tkfree(copy_path);\n\t\t\tkfree(lc_buf);\n\t\t\treturn rc;\n\t\t}\n\t\tdhc_buf = iov[n_iov-1].iov_base;\n\t}\n\n\trc = SendReceive2(xid, ses, iov, n_iov, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\trsp = (struct smb2_create_rsp *)rsp_iov.iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CREATE_HE);\n\t\tif (err_buf)\n\t\t\t*err_buf = kmemdup(rsp, get_rfc1002_length(rsp) + 4,\n\t\t\t\t\t   GFP_KERNEL);\n\t\tgoto creat_exit;\n\t}\n\n\toparms->fid->persistent_fid = rsp->PersistentFileId;\n\toparms->fid->volatile_fid = rsp->VolatileFileId;\n\n\tif (buf) {\n\t\tmemcpy(buf, &rsp->CreationTime, 32);\n\t\tbuf->AllocationSize = rsp->AllocationSize;\n\t\tbuf->EndOfFile = rsp->EndofFile;\n\t\tbuf->Attributes = rsp->FileAttributes;\n\t\tbuf->NumberOfLinks = cpu_to_le32(1);\n\t\tbuf->DeletePending = 0;\n\t}\n\n\tif (rsp->OplockLevel == SMB2_OPLOCK_LEVEL_LEASE)\n\t\t*oplock = parse_lease_state(server, rsp, &oparms->fid->epoch);\n\telse\n\t\t*oplock = rsp->OplockLevel;\ncreat_exit:\n\tkfree(copy_path);\n\tkfree(lc_buf);\n\tkfree(dhc_buf);\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}\n\n/*\n *\tSMB2 IOCTL is used for both IOCTLs and FSCTLs\n */\nint\nSMB2_ioctl(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t   u64 volatile_fid, u32 opcode, bool is_fsctl, char *in_data,\n\t   u32 indatalen, char **out_data, u32 *plen /* returned data len */)\n{\n\tstruct smb2_ioctl_req *req;\n\tstruct smb2_ioctl_rsp *rsp;\n\tstruct smb2_sync_hdr *shdr;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses;\n\tstruct kvec iov[2];\n\tstruct kvec rsp_iov;\n\tint resp_buftype;\n\tint n_iov;\n\tint rc = 0;\n\tint flags = 0;\n\n\tcifs_dbg(FYI, \"SMB2 IOCTL\\n\");\n\n\tif (out_data != NULL)\n\t\t*out_data = NULL;\n\n\t/* zero out returned data len, in case of error */\n\tif (plen)\n\t\t*plen = 0;\n\n\tif (tcon)\n\t\tses = tcon->ses;\n\telse\n\t\treturn -EIO;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_IOCTL, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq->CtlCode = cpu_to_le32(opcode);\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tif (indatalen) {\n\t\treq->InputCount = cpu_to_le32(indatalen);\n\t\t/* do not set InputOffset if no input data */\n\t\treq->InputOffset =\n\t\t       cpu_to_le32(offsetof(struct smb2_ioctl_req, Buffer) - 4);\n\t\tiov[1].iov_base = in_data;\n\t\tiov[1].iov_len = indatalen;\n\t\tn_iov = 2;\n\t} else\n\t\tn_iov = 1;\n\n\treq->OutputOffset = 0;\n\treq->OutputCount = 0; /* MBZ */\n\n\t/*\n\t * Could increase MaxOutputResponse, but that would require more\n\t * than one credit. Windows typically sets this smaller, but for some\n\t * ioctls it may be useful to allow server to send more. No point\n\t * limiting what the server can send as long as fits in one credit\n\t */\n\treq->MaxOutputResponse = cpu_to_le32(0xFF00); /* < 64K uses 1 credit */\n\n\tif (is_fsctl)\n\t\treq->Flags = cpu_to_le32(SMB2_0_IOCTL_IS_FSCTL);\n\telse\n\t\treq->Flags = 0;\n\n\tiov[0].iov_base = (char *)req;\n\n\t/*\n\t * If no input data, the size of ioctl struct in\n\t * protocol spec still includes a 1 byte data buffer,\n\t * but if input data passed to ioctl, we do not\n\t * want to double count this, so we do not send\n\t * the dummy one byte of data in iovec[0] if sending\n\t * input data (in iovec[1]). We also must add 4 bytes\n\t * in first iovec to allow for rfc1002 length field.\n\t */\n\n\tif (indatalen) {\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\t\tinc_rfc1001_len(req, indatalen - 1);\n\t} else\n\t\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\n\trc = SendReceive2(xid, ses, iov, n_iov, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\trsp = (struct smb2_ioctl_rsp *)rsp_iov.iov_base;\n\n\tif ((rc != 0) && (rc != -EINVAL)) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\tgoto ioctl_exit;\n\t} else if (rc == -EINVAL) {\n\t\tif ((opcode != FSCTL_SRV_COPYCHUNK_WRITE) &&\n\t\t    (opcode != FSCTL_SRV_COPYCHUNK)) {\n\t\t\tcifs_stats_fail_inc(tcon, SMB2_IOCTL_HE);\n\t\t\tgoto ioctl_exit;\n\t\t}\n\t}\n\n\t/* check if caller wants to look at return data or just return rc */\n\tif ((plen == NULL) || (out_data == NULL))\n\t\tgoto ioctl_exit;\n\n\t*plen = le32_to_cpu(rsp->OutputCount);\n\n\t/* We check for obvious errors in the output buffer length and offset */\n\tif (*plen == 0)\n\t\tgoto ioctl_exit; /* server returned no data */\n\telse if (*plen > 0xFF00) {\n\t\tcifs_dbg(VFS, \"srv returned invalid ioctl length: %d\\n\", *plen);\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\tif (get_rfc1002_length(rsp) < le32_to_cpu(rsp->OutputOffset) + *plen) {\n\t\tcifs_dbg(VFS, \"Malformed ioctl resp: len %d offset %d\\n\", *plen,\n\t\t\tle32_to_cpu(rsp->OutputOffset));\n\t\t*plen = 0;\n\t\trc = -EIO;\n\t\tgoto ioctl_exit;\n\t}\n\n\t*out_data = kmalloc(*plen, GFP_KERNEL);\n\tif (*out_data == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto ioctl_exit;\n\t}\n\n\tshdr = get_sync_hdr(rsp);\n\tmemcpy(*out_data, (char *)shdr + le32_to_cpu(rsp->OutputOffset), *plen);\nioctl_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}\n\n/*\n *   Individual callers to ioctl worker function follow\n */\n\nint\nSMB2_set_compression(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     u64 persistent_fid, u64 volatile_fid)\n{\n\tint rc;\n\tstruct  compress_ioctl fsctl_input;\n\tchar *ret_data = NULL;\n\n\tfsctl_input.CompressionState =\n\t\t\tcpu_to_le16(COMPRESSION_FORMAT_DEFAULT);\n\n\trc = SMB2_ioctl(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tFSCTL_SET_COMPRESSION, true /* is_fsctl */,\n\t\t\t(char *)&fsctl_input /* data input */,\n\t\t\t2 /* in data len */, &ret_data /* out data */, NULL);\n\n\tcifs_dbg(FYI, \"set compression rc %d\\n\", rc);\n\n\treturn rc;\n}\n\nint\nSMB2_close(const unsigned int xid, struct cifs_tcon *tcon,\n\t   u64 persistent_fid, u64 volatile_fid)\n{\n\tstruct smb2_close_req *req;\n\tstruct smb2_close_rsp *rsp;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tint resp_buftype;\n\tint rc = 0;\n\tint flags = 0;\n\n\tcifs_dbg(FYI, \"Close\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_CLOSE, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\trsp = (struct smb2_close_rsp *)rsp_iov.iov_base;\n\n\tif (rc != 0) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_CLOSE_HE);\n\t\tgoto close_exit;\n\t}\n\n\t/* BB FIXME - decode close response, update inode for caching */\n\nclose_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}\n\nstatic int\nvalidate_buf(unsigned int offset, unsigned int buffer_length,\n\t     struct smb2_hdr *hdr, unsigned int min_buf_size)\n\n{\n\tunsigned int smb_len = be32_to_cpu(hdr->smb2_buf_length);\n\tchar *end_of_smb = smb_len + 4 /* RFC1001 length field */ + (char *)hdr;\n\tchar *begin_of_buf = 4 /* RFC1001 len field */ + offset + (char *)hdr;\n\tchar *end_of_buf = begin_of_buf + buffer_length;\n\n\n\tif (buffer_length < min_buf_size) {\n\t\tcifs_dbg(VFS, \"buffer length %d smaller than minimum size %d\\n\",\n\t\t\t buffer_length, min_buf_size);\n\t\treturn -EINVAL;\n\t}\n\n\t/* check if beyond RFC1001 maximum length */\n\tif ((smb_len > 0x7FFFFF) || (buffer_length > 0x7FFFFF)) {\n\t\tcifs_dbg(VFS, \"buffer length %d or smb length %d too large\\n\",\n\t\t\t buffer_length, smb_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((begin_of_buf > end_of_smb) || (end_of_buf > end_of_smb)) {\n\t\tcifs_dbg(VFS, \"illegal server response, bad offset to data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n/*\n * If SMB buffer fields are valid, copy into temporary buffer to hold result.\n * Caller must free buffer.\n */\nstatic int\nvalidate_and_copy_buf(unsigned int offset, unsigned int buffer_length,\n\t\t      struct smb2_hdr *hdr, unsigned int minbufsize,\n\t\t      char *data)\n\n{\n\tchar *begin_of_buf = 4 /* RFC1001 len field */ + offset + (char *)hdr;\n\tint rc;\n\n\tif (!data)\n\t\treturn -EINVAL;\n\n\trc = validate_buf(offset, buffer_length, hdr, minbufsize);\n\tif (rc)\n\t\treturn rc;\n\n\tmemcpy(data, begin_of_buf, buffer_length);\n\n\treturn 0;\n}\n\nstatic int\nquery_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t   u64 persistent_fid, u64 volatile_fid, u8 info_class,\n\t   size_t output_len, size_t min_len, void *data)\n{\n\tstruct smb2_query_info_req *req;\n\tstruct smb2_query_info_rsp *rsp = NULL;\n\tstruct kvec iov[2];\n\tstruct kvec rsp_iov;\n\tint rc = 0;\n\tint resp_buftype;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tint flags = 0;\n\n\tcifs_dbg(FYI, \"Query Info\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_QUERY_INFO, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq->InfoType = SMB2_O_INFO_FILE;\n\treq->FileInfoClass = info_class;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\t/* 4 for rfc1002 length field and 1 for Buffer */\n\treq->InputBufferOffset =\n\t\tcpu_to_le16(sizeof(struct smb2_query_info_req) - 1 - 4);\n\treq->OutputBufferLength = cpu_to_le32(output_len);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\trsp = (struct smb2_query_info_rsp *)rsp_iov.iov_base;\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_INFO_HE);\n\t\tgoto qinf_exit;\n\t}\n\n\trc = validate_and_copy_buf(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t\t   le32_to_cpu(rsp->OutputBufferLength),\n\t\t\t\t   &rsp->hdr, min_len, data);\n\nqinf_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}\n\nint\nSMB2_query_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t\tu64 persistent_fid, u64 volatile_fid,\n\t\tstruct smb2_file_all_info *data)\n{\n\treturn query_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t  FILE_ALL_INFORMATION,\n\t\t\t  sizeof(struct smb2_file_all_info) + PATH_MAX * 2,\n\t\t\t  sizeof(struct smb2_file_all_info), data);\n}\n\nint\nSMB2_get_srv_num(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t u64 persistent_fid, u64 volatile_fid, __le64 *uniqueid)\n{\n\treturn query_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t  FILE_INTERNAL_INFORMATION,\n\t\t\t  sizeof(struct smb2_file_internal_info),\n\t\t\t  sizeof(struct smb2_file_internal_info), uniqueid);\n}\n\n/*\n * This is a no-op for now. We're not really interested in the reply, but\n * rather in the fact that the server sent one and that server->lstrp\n * gets updated.\n *\n * FIXME: maybe we should consider checking that the reply matches request?\n */\nstatic void\nsmb2_echo_callback(struct mid_q_entry *mid)\n{\n\tstruct TCP_Server_Info *server = mid->callback_data;\n\tstruct smb2_echo_rsp *rsp = (struct smb2_echo_rsp *)mid->resp_buf;\n\tunsigned int credits_received = 1;\n\n\tif (mid->mid_state == MID_RESPONSE_RECEIVED)\n\t\tcredits_received = le16_to_cpu(rsp->hdr.sync_hdr.CreditRequest);\n\n\tmutex_lock(&server->srv_mutex);\n\tDeleteMidQEntry(mid);\n\tmutex_unlock(&server->srv_mutex);\n\tadd_credits(server, credits_received, CIFS_ECHO_OP);\n}\n\nvoid smb2_reconnect_server(struct work_struct *work)\n{\n\tstruct TCP_Server_Info *server = container_of(work,\n\t\t\t\t\tstruct TCP_Server_Info, reconnect.work);\n\tstruct cifs_ses *ses;\n\tstruct cifs_tcon *tcon, *tcon2;\n\tstruct list_head tmp_list;\n\tint tcon_exist = false;\n\n\t/* Prevent simultaneous reconnects that can corrupt tcon->rlist list */\n\tmutex_lock(&server->reconnect_mutex);\n\n\tINIT_LIST_HEAD(&tmp_list);\n\tcifs_dbg(FYI, \"Need negotiate, reconnecting tcons\\n\");\n\n\tspin_lock(&cifs_tcp_ses_lock);\n\tlist_for_each_entry(ses, &server->smb_ses_list, smb_ses_list) {\n\t\tlist_for_each_entry(tcon, &ses->tcon_list, tcon_list) {\n\t\t\tif (tcon->need_reconnect || tcon->need_reopen_files) {\n\t\t\t\ttcon->tc_count++;\n\t\t\t\tlist_add_tail(&tcon->rlist, &tmp_list);\n\t\t\t\ttcon_exist = true;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\t * Get the reference to server struct to be sure that the last call of\n\t * cifs_put_tcon() in the loop below won't release the server pointer.\n\t */\n\tif (tcon_exist)\n\t\tserver->srv_count++;\n\n\tspin_unlock(&cifs_tcp_ses_lock);\n\n\tlist_for_each_entry_safe(tcon, tcon2, &tmp_list, rlist) {\n\t\tif (!smb2_reconnect(SMB2_INTERNAL_CMD, tcon))\n\t\t\tcifs_reopen_persistent_handles(tcon);\n\t\tlist_del_init(&tcon->rlist);\n\t\tcifs_put_tcon(tcon);\n\t}\n\n\tcifs_dbg(FYI, \"Reconnecting tcons finished\\n\");\n\tmutex_unlock(&server->reconnect_mutex);\n\n\t/* now we can safely release srv struct */\n\tif (tcon_exist)\n\t\tcifs_put_tcp_session(server, 1);\n}\n\nint\nSMB2_echo(struct TCP_Server_Info *server)\n{\n\tstruct smb2_echo_req *req;\n\tint rc = 0;\n\tstruct kvec iov[2];\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = 2 };\n\n\tcifs_dbg(FYI, \"In echo request\\n\");\n\n\tif (server->tcpStatus == CifsNeedNegotiate) {\n\t\t/* No need to send echo on newly established connections */\n\t\tqueue_delayed_work(cifsiod_wq, &server->reconnect, 0);\n\t\treturn rc;\n\t}\n\n\trc = small_smb2_init(SMB2_ECHO, NULL, (void **)&req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->hdr.sync_hdr.CreditRequest = cpu_to_le16(1);\n\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = 4;\n\tiov[0].iov_base = (char *)req;\n\tiov[1].iov_len = get_rfc1002_length(req);\n\tiov[1].iov_base = (char *)req + 4;\n\n\trc = cifs_call_async(server, &rqst, NULL, smb2_echo_callback, server,\n\t\t\t     CIFS_ECHO_OP);\n\tif (rc)\n\t\tcifs_dbg(FYI, \"Echo request failed: %d\\n\", rc);\n\n\tcifs_small_buf_release(req);\n\treturn rc;\n}\n\nint\nSMB2_flush(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t   u64 volatile_fid)\n{\n\tstruct smb2_flush_req *req;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct kvec iov[1];\n\tstruct kvec rsp_iov;\n\tint resp_buftype;\n\tint rc = 0;\n\tint flags = 0;\n\n\tcifs_dbg(FYI, \"Flush\\n\");\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_FLUSH, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\trc = SendReceive2(xid, ses, iov, 1, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\n\tif (rc != 0)\n\t\tcifs_stats_fail_inc(tcon, SMB2_FLUSH_HE);\n\n\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\treturn rc;\n}\n\n/*\n * To form a chain of read requests, any read requests after the first should\n * have the end_of_chain boolean set to true.\n */\nstatic int\nsmb2_new_read_req(void **buf, unsigned int *total_len,\n\t\t  struct cifs_io_parms *io_parms, unsigned int remaining_bytes,\n\t\t  int request_type)\n{\n\tint rc = -EACCES;\n\tstruct smb2_read_plain_req *req = NULL;\n\tstruct smb2_sync_hdr *shdr;\n\n\trc = smb2_plain_req_init(SMB2_READ, io_parms->tcon, (void **) &req,\n\t\t\t\t total_len);\n\tif (rc)\n\t\treturn rc;\n\tif (io_parms->tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tshdr = &req->sync_hdr;\n\tshdr->ProcessId = cpu_to_le32(io_parms->pid);\n\n\treq->PersistentFileId = io_parms->persistent_fid;\n\treq->VolatileFileId = io_parms->volatile_fid;\n\treq->ReadChannelInfoOffset = 0; /* reserved */\n\treq->ReadChannelInfoLength = 0; /* reserved */\n\treq->Channel = 0; /* reserved */\n\treq->MinimumCount = 0;\n\treq->Length = cpu_to_le32(io_parms->length);\n\treq->Offset = cpu_to_le64(io_parms->offset);\n\n\tif (request_type & CHAINED_REQUEST) {\n\t\tif (!(request_type & END_OF_CHAIN)) {\n\t\t\t/* next 8-byte aligned request */\n\t\t\t*total_len = DIV_ROUND_UP(*total_len, 8) * 8;\n\t\t\tshdr->NextCommand = cpu_to_le32(*total_len);\n\t\t} else /* END_OF_CHAIN */\n\t\t\tshdr->NextCommand = 0;\n\t\tif (request_type & RELATED_REQUEST) {\n\t\t\tshdr->Flags |= SMB2_FLAGS_RELATED_OPERATIONS;\n\t\t\t/*\n\t\t\t * Related requests use info from previous read request\n\t\t\t * in chain.\n\t\t\t */\n\t\t\tshdr->SessionId = 0xFFFFFFFF;\n\t\t\tshdr->TreeId = 0xFFFFFFFF;\n\t\t\treq->PersistentFileId = 0xFFFFFFFF;\n\t\t\treq->VolatileFileId = 0xFFFFFFFF;\n\t\t}\n\t}\n\tif (remaining_bytes > io_parms->length)\n\t\treq->RemainingBytes = cpu_to_le32(remaining_bytes);\n\telse\n\t\treq->RemainingBytes = 0;\n\n\t*buf = req;\n\treturn rc;\n}\n\nstatic void\nsmb2_readv_callback(struct mid_q_entry *mid)\n{\n\tstruct cifs_readdata *rdata = mid->callback_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(rdata->cfile->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct smb2_sync_hdr *shdr =\n\t\t\t\t(struct smb2_sync_hdr *)rdata->iov[1].iov_base;\n\tunsigned int credits_received = 1;\n\tstruct smb_rqst rqst = { .rq_iov = rdata->iov,\n\t\t\t\t .rq_nvec = 2,\n\t\t\t\t .rq_pages = rdata->pages,\n\t\t\t\t .rq_npages = rdata->nr_pages,\n\t\t\t\t .rq_pagesz = rdata->pagesz,\n\t\t\t\t .rq_tailsz = rdata->tailsz };\n\n\tcifs_dbg(FYI, \"%s: mid=%llu state=%d result=%d bytes=%u\\n\",\n\t\t __func__, mid->mid, mid->mid_state, rdata->result,\n\t\t rdata->bytes);\n\n\tswitch (mid->mid_state) {\n\tcase MID_RESPONSE_RECEIVED:\n\t\tcredits_received = le16_to_cpu(shdr->CreditRequest);\n\t\t/* result already set, check signature */\n\t\tif (server->sign) {\n\t\t\tint rc;\n\n\t\t\trc = smb2_verify_signature(&rqst, server);\n\t\t\tif (rc)\n\t\t\t\tcifs_dbg(VFS, \"SMB signature verification returned error = %d\\n\",\n\t\t\t\t\t rc);\n\t\t}\n\t\t/* FIXME: should this be counted toward the initiating task? */\n\t\ttask_io_account_read(rdata->got_bytes);\n\t\tcifs_stats_bytes_read(tcon, rdata->got_bytes);\n\t\tbreak;\n\tcase MID_REQUEST_SUBMITTED:\n\tcase MID_RETRY_NEEDED:\n\t\trdata->result = -EAGAIN;\n\t\tif (server->sign && rdata->got_bytes)\n\t\t\t/* reset bytes number since we can not check a sign */\n\t\t\trdata->got_bytes = 0;\n\t\t/* FIXME: should this be counted toward the initiating task? */\n\t\ttask_io_account_read(rdata->got_bytes);\n\t\tcifs_stats_bytes_read(tcon, rdata->got_bytes);\n\t\tbreak;\n\tdefault:\n\t\tif (rdata->result != -ENODATA)\n\t\t\trdata->result = -EIO;\n\t}\n\n\tif (rdata->result)\n\t\tcifs_stats_fail_inc(tcon, SMB2_READ_HE);\n\n\tqueue_work(cifsiod_wq, &rdata->work);\n\tmutex_lock(&server->srv_mutex);\n\tDeleteMidQEntry(mid);\n\tmutex_unlock(&server->srv_mutex);\n\tadd_credits(server, credits_received, 0);\n}\n\n/* smb2_async_readv - send an async read, and set up mid to handle result */\nint\nsmb2_async_readv(struct cifs_readdata *rdata)\n{\n\tint rc, flags = 0;\n\tchar *buf;\n\tstruct smb2_sync_hdr *shdr;\n\tstruct cifs_io_parms io_parms;\n\tstruct smb_rqst rqst = { .rq_iov = rdata->iov,\n\t\t\t\t .rq_nvec = 2 };\n\tstruct TCP_Server_Info *server;\n\tunsigned int total_len;\n\t__be32 req_len;\n\n\tcifs_dbg(FYI, \"%s: offset=%llu bytes=%u\\n\",\n\t\t __func__, rdata->offset, rdata->bytes);\n\n\tio_parms.tcon = tlink_tcon(rdata->cfile->tlink);\n\tio_parms.offset = rdata->offset;\n\tio_parms.length = rdata->bytes;\n\tio_parms.persistent_fid = rdata->cfile->fid.persistent_fid;\n\tio_parms.volatile_fid = rdata->cfile->fid.volatile_fid;\n\tio_parms.pid = rdata->pid;\n\n\tserver = io_parms.tcon->ses->server;\n\n\trc = smb2_new_read_req((void **) &buf, &total_len, &io_parms, 0, 0);\n\tif (rc) {\n\t\tif (rc == -EAGAIN && rdata->credits) {\n\t\t\t/* credits was reset by reconnect */\n\t\t\trdata->credits = 0;\n\t\t\t/* reduce in_flight value since we won't send the req */\n\t\t\tspin_lock(&server->req_lock);\n\t\t\tserver->in_flight--;\n\t\t\tspin_unlock(&server->req_lock);\n\t\t}\n\t\treturn rc;\n\t}\n\n\tif (encryption_required(io_parms.tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq_len = cpu_to_be32(total_len);\n\n\trdata->iov[0].iov_base = &req_len;\n\trdata->iov[0].iov_len = sizeof(__be32);\n\trdata->iov[1].iov_base = buf;\n\trdata->iov[1].iov_len = total_len;\n\n\tshdr = (struct smb2_sync_hdr *)buf;\n\n\tif (rdata->credits) {\n\t\tshdr->CreditCharge = cpu_to_le16(DIV_ROUND_UP(rdata->bytes,\n\t\t\t\t\t\tSMB2_MAX_BUFFER_SIZE));\n\t\tshdr->CreditRequest = shdr->CreditCharge;\n\t\tspin_lock(&server->req_lock);\n\t\tserver->credits += rdata->credits -\n\t\t\t\t\t\tle16_to_cpu(shdr->CreditCharge);\n\t\tspin_unlock(&server->req_lock);\n\t\twake_up(&server->request_q);\n\t\tflags |= CIFS_HAS_CREDITS;\n\t}\n\n\tkref_get(&rdata->refcount);\n\trc = cifs_call_async(io_parms.tcon->ses->server, &rqst,\n\t\t\t     cifs_readv_receive, smb2_readv_callback,\n\t\t\t     rdata, flags);\n\tif (rc) {\n\t\tkref_put(&rdata->refcount, cifs_readdata_release);\n\t\tcifs_stats_fail_inc(io_parms.tcon, SMB2_READ_HE);\n\t}\n\n\tcifs_small_buf_release(buf);\n\treturn rc;\n}\n\nint\nSMB2_read(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t  unsigned int *nbytes, char **buf, int *buf_type)\n{\n\tint resp_buftype, rc = -EACCES;\n\tstruct smb2_read_plain_req *req = NULL;\n\tstruct smb2_read_rsp *rsp = NULL;\n\tstruct smb2_sync_hdr *shdr;\n\tstruct kvec iov[2];\n\tstruct kvec rsp_iov;\n\tunsigned int total_len;\n\t__be32 req_len;\n\tstruct smb_rqst rqst = { .rq_iov = iov,\n\t\t\t\t .rq_nvec = 2 };\n\tint flags = CIFS_LOG_ERROR;\n\tstruct cifs_ses *ses = io_parms->tcon->ses;\n\n\t*nbytes = 0;\n\trc = smb2_new_read_req((void **)&req, &total_len, io_parms, 0, 0);\n\tif (rc)\n\t\treturn rc;\n\n\tif (encryption_required(io_parms->tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq_len = cpu_to_be32(total_len);\n\n\tiov[0].iov_base = &req_len;\n\tiov[0].iov_len = sizeof(__be32);\n\tiov[1].iov_base = req;\n\tiov[1].iov_len = total_len;\n\n\trc = cifs_send_recv(xid, ses, &rqst, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\n\trsp = (struct smb2_read_rsp *)rsp_iov.iov_base;\n\tshdr = get_sync_hdr(rsp);\n\n\tif (shdr->Status == STATUS_END_OF_FILE) {\n\t\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\t\treturn 0;\n\t}\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(io_parms->tcon, SMB2_READ_HE);\n\t\tcifs_dbg(VFS, \"Send error in read = %d\\n\", rc);\n\t} else {\n\t\t*nbytes = le32_to_cpu(rsp->DataLength);\n\t\tif ((*nbytes > CIFS_MAX_MSGSIZE) ||\n\t\t    (*nbytes > io_parms->length)) {\n\t\t\tcifs_dbg(FYI, \"bad length %d for count %d\\n\",\n\t\t\t\t *nbytes, io_parms->length);\n\t\t\trc = -EIO;\n\t\t\t*nbytes = 0;\n\t\t}\n\t}\n\n\tif (*buf) {\n\t\tmemcpy(*buf, (char *)shdr + rsp->DataOffset, *nbytes);\n\t\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\t} else if (resp_buftype != CIFS_NO_BUFFER) {\n\t\t*buf = rsp_iov.iov_base;\n\t\tif (resp_buftype == CIFS_SMALL_BUFFER)\n\t\t\t*buf_type = CIFS_SMALL_BUFFER;\n\t\telse if (resp_buftype == CIFS_LARGE_BUFFER)\n\t\t\t*buf_type = CIFS_LARGE_BUFFER;\n\t}\n\treturn rc;\n}\n\n/*\n * Check the mid_state and signature on received buffer (if any), and queue the\n * workqueue completion task.\n */\nstatic void\nsmb2_writev_callback(struct mid_q_entry *mid)\n{\n\tstruct cifs_writedata *wdata = mid->callback_data;\n\tstruct cifs_tcon *tcon = tlink_tcon(wdata->cfile->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tunsigned int written;\n\tstruct smb2_write_rsp *rsp = (struct smb2_write_rsp *)mid->resp_buf;\n\tunsigned int credits_received = 1;\n\n\tswitch (mid->mid_state) {\n\tcase MID_RESPONSE_RECEIVED:\n\t\tcredits_received = le16_to_cpu(rsp->hdr.sync_hdr.CreditRequest);\n\t\twdata->result = smb2_check_receive(mid, tcon->ses->server, 0);\n\t\tif (wdata->result != 0)\n\t\t\tbreak;\n\n\t\twritten = le32_to_cpu(rsp->DataLength);\n\t\t/*\n\t\t * Mask off high 16 bits when bytes written as returned\n\t\t * by the server is greater than bytes requested by the\n\t\t * client. OS/2 servers are known to set incorrect\n\t\t * CountHigh values.\n\t\t */\n\t\tif (written > wdata->bytes)\n\t\t\twritten &= 0xFFFF;\n\n\t\tif (written < wdata->bytes)\n\t\t\twdata->result = -ENOSPC;\n\t\telse\n\t\t\twdata->bytes = written;\n\t\tbreak;\n\tcase MID_REQUEST_SUBMITTED:\n\tcase MID_RETRY_NEEDED:\n\t\twdata->result = -EAGAIN;\n\t\tbreak;\n\tdefault:\n\t\twdata->result = -EIO;\n\t\tbreak;\n\t}\n\n\tif (wdata->result)\n\t\tcifs_stats_fail_inc(tcon, SMB2_WRITE_HE);\n\n\tqueue_work(cifsiod_wq, &wdata->work);\n\tmutex_lock(&server->srv_mutex);\n\tDeleteMidQEntry(mid);\n\tmutex_unlock(&server->srv_mutex);\n\tadd_credits(tcon->ses->server, credits_received, 0);\n}\n\n/* smb2_async_writev - send an async write, and set up mid to handle result */\nint\nsmb2_async_writev(struct cifs_writedata *wdata,\n\t\t  void (*release)(struct kref *kref))\n{\n\tint rc = -EACCES, flags = 0;\n\tstruct smb2_write_req *req = NULL;\n\tstruct smb2_sync_hdr *shdr;\n\tstruct cifs_tcon *tcon = tlink_tcon(wdata->cfile->tlink);\n\tstruct TCP_Server_Info *server = tcon->ses->server;\n\tstruct kvec iov[2];\n\tstruct smb_rqst rqst = { };\n\n\trc = small_smb2_init(SMB2_WRITE, tcon, (void **) &req);\n\tif (rc) {\n\t\tif (rc == -EAGAIN && wdata->credits) {\n\t\t\t/* credits was reset by reconnect */\n\t\t\twdata->credits = 0;\n\t\t\t/* reduce in_flight value since we won't send the req */\n\t\t\tspin_lock(&server->req_lock);\n\t\t\tserver->in_flight--;\n\t\t\tspin_unlock(&server->req_lock);\n\t\t}\n\t\tgoto async_writev_out;\n\t}\n\n\tif (encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tshdr = get_sync_hdr(req);\n\tshdr->ProcessId = cpu_to_le32(wdata->cfile->pid);\n\n\treq->PersistentFileId = wdata->cfile->fid.persistent_fid;\n\treq->VolatileFileId = wdata->cfile->fid.volatile_fid;\n\treq->WriteChannelInfoOffset = 0;\n\treq->WriteChannelInfoLength = 0;\n\treq->Channel = 0;\n\treq->Offset = cpu_to_le64(wdata->offset);\n\t/* 4 for rfc1002 length field */\n\treq->DataOffset = cpu_to_le16(\n\t\t\t\toffsetof(struct smb2_write_req, Buffer) - 4);\n\treq->RemainingBytes = 0;\n\n\t/* 4 for rfc1002 length field and 1 for Buffer */\n\tiov[0].iov_len = 4;\n\tiov[0].iov_base = req;\n\tiov[1].iov_len = get_rfc1002_length(req) - 1;\n\tiov[1].iov_base = (char *)req + 4;\n\n\trqst.rq_iov = iov;\n\trqst.rq_nvec = 2;\n\trqst.rq_pages = wdata->pages;\n\trqst.rq_npages = wdata->nr_pages;\n\trqst.rq_pagesz = wdata->pagesz;\n\trqst.rq_tailsz = wdata->tailsz;\n\n\tcifs_dbg(FYI, \"async write at %llu %u bytes\\n\",\n\t\t wdata->offset, wdata->bytes);\n\n\treq->Length = cpu_to_le32(wdata->bytes);\n\n\tinc_rfc1001_len(&req->hdr, wdata->bytes - 1 /* Buffer */);\n\n\tif (wdata->credits) {\n\t\tshdr->CreditCharge = cpu_to_le16(DIV_ROUND_UP(wdata->bytes,\n\t\t\t\t\t\t    SMB2_MAX_BUFFER_SIZE));\n\t\tshdr->CreditRequest = shdr->CreditCharge;\n\t\tspin_lock(&server->req_lock);\n\t\tserver->credits += wdata->credits -\n\t\t\t\t\t\tle16_to_cpu(shdr->CreditCharge);\n\t\tspin_unlock(&server->req_lock);\n\t\twake_up(&server->request_q);\n\t\tflags |= CIFS_HAS_CREDITS;\n\t}\n\n\tkref_get(&wdata->refcount);\n\trc = cifs_call_async(server, &rqst, NULL, smb2_writev_callback, wdata,\n\t\t\t     flags);\n\n\tif (rc) {\n\t\tkref_put(&wdata->refcount, release);\n\t\tcifs_stats_fail_inc(tcon, SMB2_WRITE_HE);\n\t}\n\nasync_writev_out:\n\tcifs_small_buf_release(req);\n\treturn rc;\n}\n\n/*\n * SMB2_write function gets iov pointer to kvec array with n_vec as a length.\n * The length field from io_parms must be at least 1 and indicates a number of\n * elements with data to write that begins with position 1 in iov array. All\n * data length is specified by count.\n */\nint\nSMB2_write(const unsigned int xid, struct cifs_io_parms *io_parms,\n\t   unsigned int *nbytes, struct kvec *iov, int n_vec)\n{\n\tint rc = 0;\n\tstruct smb2_write_req *req = NULL;\n\tstruct smb2_write_rsp *rsp = NULL;\n\tint resp_buftype;\n\tstruct kvec rsp_iov;\n\tint flags = 0;\n\n\t*nbytes = 0;\n\n\tif (n_vec < 1)\n\t\treturn rc;\n\n\trc = small_smb2_init(SMB2_WRITE, io_parms->tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (io_parms->tcon->ses->server == NULL)\n\t\treturn -ECONNABORTED;\n\n\tif (encryption_required(io_parms->tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq->hdr.sync_hdr.ProcessId = cpu_to_le32(io_parms->pid);\n\n\treq->PersistentFileId = io_parms->persistent_fid;\n\treq->VolatileFileId = io_parms->volatile_fid;\n\treq->WriteChannelInfoOffset = 0;\n\treq->WriteChannelInfoLength = 0;\n\treq->Channel = 0;\n\treq->Length = cpu_to_le32(io_parms->length);\n\treq->Offset = cpu_to_le64(io_parms->offset);\n\t/* 4 for rfc1002 length field */\n\treq->DataOffset = cpu_to_le16(\n\t\t\t\toffsetof(struct smb2_write_req, Buffer) - 4);\n\treq->RemainingBytes = 0;\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field and 1 for Buffer */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\n\t/* length of entire message including data to be written */\n\tinc_rfc1001_len(req, io_parms->length - 1 /* Buffer */);\n\n\trc = SendReceive2(xid, io_parms->tcon->ses, iov, n_vec + 1,\n\t\t\t  &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\trsp = (struct smb2_write_rsp *)rsp_iov.iov_base;\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(io_parms->tcon, SMB2_WRITE_HE);\n\t\tcifs_dbg(VFS, \"Send error in write = %d\\n\", rc);\n\t} else\n\t\t*nbytes = le32_to_cpu(rsp->DataLength);\n\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}\n\nstatic unsigned int\nnum_entries(char *bufstart, char *end_of_buf, char **lastentry, size_t size)\n{\n\tint len;\n\tunsigned int entrycount = 0;\n\tunsigned int next_offset = 0;\n\tFILE_DIRECTORY_INFO *entryptr;\n\n\tif (bufstart == NULL)\n\t\treturn 0;\n\n\tentryptr = (FILE_DIRECTORY_INFO *)bufstart;\n\n\twhile (1) {\n\t\tentryptr = (FILE_DIRECTORY_INFO *)\n\t\t\t\t\t((char *)entryptr + next_offset);\n\n\t\tif ((char *)entryptr + size > end_of_buf) {\n\t\t\tcifs_dbg(VFS, \"malformed search entry would overflow\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tlen = le32_to_cpu(entryptr->FileNameLength);\n\t\tif ((char *)entryptr + len + size > end_of_buf) {\n\t\t\tcifs_dbg(VFS, \"directory entry name would overflow frame end of buf %p\\n\",\n\t\t\t\t end_of_buf);\n\t\t\tbreak;\n\t\t}\n\n\t\t*lastentry = (char *)entryptr;\n\t\tentrycount++;\n\n\t\tnext_offset = le32_to_cpu(entryptr->NextEntryOffset);\n\t\tif (!next_offset)\n\t\t\tbreak;\n\t}\n\n\treturn entrycount;\n}\n\n/*\n * Readdir/FindFirst\n */\nint\nSMB2_query_directory(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t     u64 persistent_fid, u64 volatile_fid, int index,\n\t\t     struct cifs_search_info *srch_inf)\n{\n\tstruct smb2_query_directory_req *req;\n\tstruct smb2_query_directory_rsp *rsp = NULL;\n\tstruct kvec iov[2];\n\tstruct kvec rsp_iov;\n\tint rc = 0;\n\tint len;\n\tint resp_buftype = CIFS_NO_BUFFER;\n\tunsigned char *bufptr;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\t__le16 asteriks = cpu_to_le16('*');\n\tchar *end_of_smb;\n\tunsigned int output_size = CIFSMaxBufSize;\n\tsize_t info_buf_size;\n\tint flags = 0;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_QUERY_DIRECTORY, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\tswitch (srch_inf->info_level) {\n\tcase SMB_FIND_FILE_DIRECTORY_INFO:\n\t\treq->FileInformationClass = FILE_DIRECTORY_INFORMATION;\n\t\tinfo_buf_size = sizeof(FILE_DIRECTORY_INFO) - 1;\n\t\tbreak;\n\tcase SMB_FIND_FILE_ID_FULL_DIR_INFO:\n\t\treq->FileInformationClass = FILEID_FULL_DIRECTORY_INFORMATION;\n\t\tinfo_buf_size = sizeof(SEARCH_ID_FULL_DIR_INFO) - 1;\n\t\tbreak;\n\tdefault:\n\t\tcifs_dbg(VFS, \"info level %u isn't supported\\n\",\n\t\t\t srch_inf->info_level);\n\t\trc = -EINVAL;\n\t\tgoto qdir_exit;\n\t}\n\n\treq->FileIndex = cpu_to_le32(index);\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tlen = 0x2;\n\tbufptr = req->Buffer;\n\tmemcpy(bufptr, &asteriks, len);\n\n\treq->FileNameOffset =\n\t\tcpu_to_le16(sizeof(struct smb2_query_directory_req) - 1 - 4);\n\treq->FileNameLength = cpu_to_le16(len);\n\t/*\n\t * BB could be 30 bytes or so longer if we used SMB2 specific\n\t * buffer lengths, but this is safe and close enough.\n\t */\n\toutput_size = min_t(unsigned int, output_size, server->maxBuf);\n\toutput_size = min_t(unsigned int, output_size, 2 << 15);\n\treq->OutputBufferLength = cpu_to_le32(output_size);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for RFC1001 length and 1 for Buffer */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4 - 1;\n\n\tiov[1].iov_base = (char *)(req->Buffer);\n\tiov[1].iov_len = len;\n\n\tinc_rfc1001_len(req, len - 1 /* Buffer */);\n\n\trc = SendReceive2(xid, ses, iov, 2, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\trsp = (struct smb2_query_directory_rsp *)rsp_iov.iov_base;\n\n\tif (rc) {\n\t\tif (rc == -ENODATA &&\n\t\t    rsp->hdr.sync_hdr.Status == STATUS_NO_MORE_FILES) {\n\t\t\tsrch_inf->endOfSearch = true;\n\t\t\trc = 0;\n\t\t}\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_DIRECTORY_HE);\n\t\tgoto qdir_exit;\n\t}\n\n\trc = validate_buf(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t  le32_to_cpu(rsp->OutputBufferLength), &rsp->hdr,\n\t\t\t  info_buf_size);\n\tif (rc)\n\t\tgoto qdir_exit;\n\n\tsrch_inf->unicode = true;\n\n\tif (srch_inf->ntwrk_buf_start) {\n\t\tif (srch_inf->smallBuf)\n\t\t\tcifs_small_buf_release(srch_inf->ntwrk_buf_start);\n\t\telse\n\t\t\tcifs_buf_release(srch_inf->ntwrk_buf_start);\n\t}\n\tsrch_inf->ntwrk_buf_start = (char *)rsp;\n\tsrch_inf->srch_entries_start = srch_inf->last_entry = 4 /* rfclen */ +\n\t\t(char *)&rsp->hdr + le16_to_cpu(rsp->OutputBufferOffset);\n\t/* 4 for rfc1002 length field */\n\tend_of_smb = get_rfc1002_length(rsp) + 4 + (char *)&rsp->hdr;\n\tsrch_inf->entries_in_buffer =\n\t\t\tnum_entries(srch_inf->srch_entries_start, end_of_smb,\n\t\t\t\t    &srch_inf->last_entry, info_buf_size);\n\tsrch_inf->index_of_last_entry += srch_inf->entries_in_buffer;\n\tcifs_dbg(FYI, \"num entries %d last_index %lld srch start %p srch end %p\\n\",\n\t\t srch_inf->entries_in_buffer, srch_inf->index_of_last_entry,\n\t\t srch_inf->srch_entries_start, srch_inf->last_entry);\n\tif (resp_buftype == CIFS_LARGE_BUFFER)\n\t\tsrch_inf->smallBuf = false;\n\telse if (resp_buftype == CIFS_SMALL_BUFFER)\n\t\tsrch_inf->smallBuf = true;\n\telse\n\t\tcifs_dbg(VFS, \"illegal search buffer type\\n\");\n\n\treturn rc;\n\nqdir_exit:\n\tfree_rsp_buf(resp_buftype, rsp);\n\treturn rc;\n}\n\nstatic int\nsend_set_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t       u64 persistent_fid, u64 volatile_fid, u32 pid, int info_class,\n\t       unsigned int num, void **data, unsigned int *size)\n{\n\tstruct smb2_set_info_req *req;\n\tstruct smb2_set_info_rsp *rsp = NULL;\n\tstruct kvec *iov;\n\tstruct kvec rsp_iov;\n\tint rc = 0;\n\tint resp_buftype;\n\tunsigned int i;\n\tstruct TCP_Server_Info *server;\n\tstruct cifs_ses *ses = tcon->ses;\n\tint flags = 0;\n\n\tif (ses && (ses->server))\n\t\tserver = ses->server;\n\telse\n\t\treturn -EIO;\n\n\tif (!num)\n\t\treturn -EINVAL;\n\n\tiov = kmalloc(sizeof(struct kvec) * num, GFP_KERNEL);\n\tif (!iov)\n\t\treturn -ENOMEM;\n\n\trc = small_smb2_init(SMB2_SET_INFO, tcon, (void **) &req);\n\tif (rc) {\n\t\tkfree(iov);\n\t\treturn rc;\n\t}\n\n\tif (encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq->hdr.sync_hdr.ProcessId = cpu_to_le32(pid);\n\n\treq->InfoType = SMB2_O_INFO_FILE;\n\treq->FileInfoClass = info_class;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\t/* 4 for RFC1001 length and 1 for Buffer */\n\treq->BufferOffset =\n\t\t\tcpu_to_le16(sizeof(struct smb2_set_info_req) - 1 - 4);\n\treq->BufferLength = cpu_to_le32(*size);\n\n\tinc_rfc1001_len(req, *size - 1 /* Buffer */);\n\n\tmemcpy(req->Buffer, *data, *size);\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for RFC1001 length */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4;\n\n\tfor (i = 1; i < num; i++) {\n\t\tinc_rfc1001_len(req, size[i]);\n\t\tle32_add_cpu(&req->BufferLength, size[i]);\n\t\tiov[i].iov_base = (char *)data[i];\n\t\tiov[i].iov_len = size[i];\n\t}\n\n\trc = SendReceive2(xid, ses, iov, num, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(req);\n\trsp = (struct smb2_set_info_rsp *)rsp_iov.iov_base;\n\n\tif (rc != 0)\n\t\tcifs_stats_fail_inc(tcon, SMB2_SET_INFO_HE);\n\n\tfree_rsp_buf(resp_buftype, rsp);\n\tkfree(iov);\n\treturn rc;\n}\n\nint\nSMB2_rename(const unsigned int xid, struct cifs_tcon *tcon,\n\t    u64 persistent_fid, u64 volatile_fid, __le16 *target_file)\n{\n\tstruct smb2_file_rename_info info;\n\tvoid **data;\n\tunsigned int size[2];\n\tint rc;\n\tint len = (2 * UniStrnlen((wchar_t *)target_file, PATH_MAX));\n\n\tdata = kmalloc(sizeof(void *) * 2, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tinfo.ReplaceIfExists = 1; /* 1 = replace existing target with new */\n\t\t\t      /* 0 = fail if target already exists */\n\tinfo.RootDirectory = 0;  /* MBZ for network ops (why does spec say?) */\n\tinfo.FileNameLength = cpu_to_le32(len);\n\n\tdata[0] = &info;\n\tsize[0] = sizeof(struct smb2_file_rename_info);\n\n\tdata[1] = target_file;\n\tsize[1] = len + 2 /* null */;\n\n\trc = send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t   current->tgid, FILE_RENAME_INFORMATION, 2, data,\n\t\t\t   size);\n\tkfree(data);\n\treturn rc;\n}\n\nint\nSMB2_rmdir(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t  u64 persistent_fid, u64 volatile_fid)\n{\n\t__u8 delete_pending = 1;\n\tvoid *data;\n\tunsigned int size;\n\n\tdata = &delete_pending;\n\tsize = 1; /* sizeof __u8 */\n\n\treturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tcurrent->tgid, FILE_DISPOSITION_INFORMATION, 1, &data,\n\t\t\t&size);\n}\n\nint\nSMB2_set_hardlink(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t  u64 persistent_fid, u64 volatile_fid, __le16 *target_file)\n{\n\tstruct smb2_file_link_info info;\n\tvoid **data;\n\tunsigned int size[2];\n\tint rc;\n\tint len = (2 * UniStrnlen((wchar_t *)target_file, PATH_MAX));\n\n\tdata = kmalloc(sizeof(void *) * 2, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tinfo.ReplaceIfExists = 0; /* 1 = replace existing link with new */\n\t\t\t      /* 0 = fail if link already exists */\n\tinfo.RootDirectory = 0;  /* MBZ for network ops (why does spec say?) */\n\tinfo.FileNameLength = cpu_to_le32(len);\n\n\tdata[0] = &info;\n\tsize[0] = sizeof(struct smb2_file_link_info);\n\n\tdata[1] = target_file;\n\tsize[1] = len + 2 /* null */;\n\n\trc = send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t   current->tgid, FILE_LINK_INFORMATION, 2, data, size);\n\tkfree(data);\n\treturn rc;\n}\n\nint\nSMB2_set_eof(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,\n\t     u64 volatile_fid, u32 pid, __le64 *eof, bool is_falloc)\n{\n\tstruct smb2_file_eof_info info;\n\tvoid *data;\n\tunsigned int size;\n\n\tinfo.EndOfFile = *eof;\n\n\tdata = &info;\n\tsize = sizeof(struct smb2_file_eof_info);\n\n\tif (is_falloc)\n\t\treturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tpid, FILE_ALLOCATION_INFORMATION, 1, &data, &size);\n\telse\n\t\treturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\tpid, FILE_END_OF_FILE_INFORMATION, 1, &data, &size);\n}\n\nint\nSMB2_set_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t      u64 persistent_fid, u64 volatile_fid, FILE_BASIC_INFO *buf)\n{\n\tunsigned int size;\n\tsize = sizeof(FILE_BASIC_INFO);\n\treturn send_set_info(xid, tcon, persistent_fid, volatile_fid,\n\t\t\t     current->tgid, FILE_BASIC_INFORMATION, 1,\n\t\t\t     (void **)&buf, &size);\n}\n\nint\nSMB2_oplock_break(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t  const u64 persistent_fid, const u64 volatile_fid,\n\t\t  __u8 oplock_level)\n{\n\tint rc;\n\tstruct smb2_oplock_break *req = NULL;\n\tint flags = CIFS_OBREAK_OP;\n\n\tcifs_dbg(FYI, \"SMB2_oplock_break\\n\");\n\trc = small_smb2_init(SMB2_OPLOCK_BREAK, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq->VolatileFid = volatile_fid;\n\treq->PersistentFid = persistent_fid;\n\treq->OplockLevel = oplock_level;\n\treq->hdr.sync_hdr.CreditRequest = cpu_to_le16(1);\n\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) req, flags);\n\tcifs_small_buf_release(req);\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_OPLOCK_BREAK_HE);\n\t\tcifs_dbg(FYI, \"Send error in Oplock Break = %d\\n\", rc);\n\t}\n\n\treturn rc;\n}\n\nstatic void\ncopy_fs_info_to_kstatfs(struct smb2_fs_full_size_info *pfs_inf,\n\t\t\tstruct kstatfs *kst)\n{\n\tkst->f_bsize = le32_to_cpu(pfs_inf->BytesPerSector) *\n\t\t\t  le32_to_cpu(pfs_inf->SectorsPerAllocationUnit);\n\tkst->f_blocks = le64_to_cpu(pfs_inf->TotalAllocationUnits);\n\tkst->f_bfree  = le64_to_cpu(pfs_inf->ActualAvailableAllocationUnits);\n\tkst->f_bavail = le64_to_cpu(pfs_inf->CallerAvailableAllocationUnits);\n\treturn;\n}\n\nstatic int\nbuild_qfs_info_req(struct kvec *iov, struct cifs_tcon *tcon, int level,\n\t\t   int outbuf_len, u64 persistent_fid, u64 volatile_fid)\n{\n\tint rc;\n\tstruct smb2_query_info_req *req;\n\n\tcifs_dbg(FYI, \"Query FSInfo level %d\\n\", level);\n\n\tif ((tcon->ses == NULL) || (tcon->ses->server == NULL))\n\t\treturn -EIO;\n\n\trc = small_smb2_init(SMB2_QUERY_INFO, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\treq->InfoType = SMB2_O_INFO_FILESYSTEM;\n\treq->FileInfoClass = level;\n\treq->PersistentFileId = persistent_fid;\n\treq->VolatileFileId = volatile_fid;\n\t/* 4 for rfc1002 length field and 1 for pad */\n\treq->InputBufferOffset =\n\t\t\tcpu_to_le16(sizeof(struct smb2_query_info_req) - 1 - 4);\n\treq->OutputBufferLength = cpu_to_le32(\n\t\toutbuf_len + sizeof(struct smb2_query_info_rsp) - 1 - 4);\n\n\tiov->iov_base = (char *)req;\n\t/* 4 for rfc1002 length field */\n\tiov->iov_len = get_rfc1002_length(req) + 4;\n\treturn 0;\n}\n\nint\nSMB2_QFS_info(const unsigned int xid, struct cifs_tcon *tcon,\n\t      u64 persistent_fid, u64 volatile_fid, struct kstatfs *fsdata)\n{\n\tstruct smb2_query_info_rsp *rsp = NULL;\n\tstruct kvec iov;\n\tstruct kvec rsp_iov;\n\tint rc = 0;\n\tint resp_buftype;\n\tstruct cifs_ses *ses = tcon->ses;\n\tstruct smb2_fs_full_size_info *info = NULL;\n\tint flags = 0;\n\n\trc = build_qfs_info_req(&iov, tcon, FS_FULL_SIZE_INFORMATION,\n\t\t\t\tsizeof(struct smb2_fs_full_size_info),\n\t\t\t\tpersistent_fid, volatile_fid);\n\tif (rc)\n\t\treturn rc;\n\n\tif (encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\trc = SendReceive2(xid, ses, &iov, 1, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(iov.iov_base);\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_INFO_HE);\n\t\tgoto qfsinf_exit;\n\t}\n\trsp = (struct smb2_query_info_rsp *)rsp_iov.iov_base;\n\n\tinfo = (struct smb2_fs_full_size_info *)(4 /* RFC1001 len */ +\n\t\tle16_to_cpu(rsp->OutputBufferOffset) + (char *)&rsp->hdr);\n\trc = validate_buf(le16_to_cpu(rsp->OutputBufferOffset),\n\t\t\t  le32_to_cpu(rsp->OutputBufferLength), &rsp->hdr,\n\t\t\t  sizeof(struct smb2_fs_full_size_info));\n\tif (!rc)\n\t\tcopy_fs_info_to_kstatfs(info, fsdata);\n\nqfsinf_exit:\n\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\treturn rc;\n}\n\nint\nSMB2_QFS_attr(const unsigned int xid, struct cifs_tcon *tcon,\n\t      u64 persistent_fid, u64 volatile_fid, int level)\n{\n\tstruct smb2_query_info_rsp *rsp = NULL;\n\tstruct kvec iov;\n\tstruct kvec rsp_iov;\n\tint rc = 0;\n\tint resp_buftype, max_len, min_len;\n\tstruct cifs_ses *ses = tcon->ses;\n\tunsigned int rsp_len, offset;\n\tint flags = 0;\n\n\tif (level == FS_DEVICE_INFORMATION) {\n\t\tmax_len = sizeof(FILE_SYSTEM_DEVICE_INFO);\n\t\tmin_len = sizeof(FILE_SYSTEM_DEVICE_INFO);\n\t} else if (level == FS_ATTRIBUTE_INFORMATION) {\n\t\tmax_len = sizeof(FILE_SYSTEM_ATTRIBUTE_INFO);\n\t\tmin_len = MIN_FS_ATTR_INFO_SIZE;\n\t} else if (level == FS_SECTOR_SIZE_INFORMATION) {\n\t\tmax_len = sizeof(struct smb3_fs_ss_info);\n\t\tmin_len = sizeof(struct smb3_fs_ss_info);\n\t} else {\n\t\tcifs_dbg(FYI, \"Invalid qfsinfo level %d\\n\", level);\n\t\treturn -EINVAL;\n\t}\n\n\trc = build_qfs_info_req(&iov, tcon, level, max_len,\n\t\t\t\tpersistent_fid, volatile_fid);\n\tif (rc)\n\t\treturn rc;\n\n\tif (encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\trc = SendReceive2(xid, ses, &iov, 1, &resp_buftype, flags, &rsp_iov);\n\tcifs_small_buf_release(iov.iov_base);\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_QUERY_INFO_HE);\n\t\tgoto qfsattr_exit;\n\t}\n\trsp = (struct smb2_query_info_rsp *)rsp_iov.iov_base;\n\n\trsp_len = le32_to_cpu(rsp->OutputBufferLength);\n\toffset = le16_to_cpu(rsp->OutputBufferOffset);\n\trc = validate_buf(offset, rsp_len, &rsp->hdr, min_len);\n\tif (rc)\n\t\tgoto qfsattr_exit;\n\n\tif (level == FS_ATTRIBUTE_INFORMATION)\n\t\tmemcpy(&tcon->fsAttrInfo, 4 /* RFC1001 len */ + offset\n\t\t\t+ (char *)&rsp->hdr, min_t(unsigned int,\n\t\t\trsp_len, max_len));\n\telse if (level == FS_DEVICE_INFORMATION)\n\t\tmemcpy(&tcon->fsDevInfo, 4 /* RFC1001 len */ + offset\n\t\t\t+ (char *)&rsp->hdr, sizeof(FILE_SYSTEM_DEVICE_INFO));\n\telse if (level == FS_SECTOR_SIZE_INFORMATION) {\n\t\tstruct smb3_fs_ss_info *ss_info = (struct smb3_fs_ss_info *)\n\t\t\t(4 /* RFC1001 len */ + offset + (char *)&rsp->hdr);\n\t\ttcon->ss_flags = le32_to_cpu(ss_info->Flags);\n\t\ttcon->perf_sector_size =\n\t\t\tle32_to_cpu(ss_info->PhysicalBytesPerSectorForPerf);\n\t}\n\nqfsattr_exit:\n\tfree_rsp_buf(resp_buftype, rsp_iov.iov_base);\n\treturn rc;\n}\n\nint\nsmb2_lockv(const unsigned int xid, struct cifs_tcon *tcon,\n\t   const __u64 persist_fid, const __u64 volatile_fid, const __u32 pid,\n\t   const __u32 num_lock, struct smb2_lock_element *buf)\n{\n\tint rc = 0;\n\tstruct smb2_lock_req *req = NULL;\n\tstruct kvec iov[2];\n\tstruct kvec rsp_iov;\n\tint resp_buf_type;\n\tunsigned int count;\n\tint flags = CIFS_NO_RESP;\n\n\tcifs_dbg(FYI, \"smb2_lockv num lock %d\\n\", num_lock);\n\n\trc = small_smb2_init(SMB2_LOCK, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq->hdr.sync_hdr.ProcessId = cpu_to_le32(pid);\n\treq->LockCount = cpu_to_le16(num_lock);\n\n\treq->PersistentFileId = persist_fid;\n\treq->VolatileFileId = volatile_fid;\n\n\tcount = num_lock * sizeof(struct smb2_lock_element);\n\tinc_rfc1001_len(req, count - sizeof(struct smb2_lock_element));\n\n\tiov[0].iov_base = (char *)req;\n\t/* 4 for rfc1002 length field and count for all locks */\n\tiov[0].iov_len = get_rfc1002_length(req) + 4 - count;\n\tiov[1].iov_base = (char *)buf;\n\tiov[1].iov_len = count;\n\n\tcifs_stats_inc(&tcon->stats.cifs_stats.num_locks);\n\trc = SendReceive2(xid, tcon->ses, iov, 2, &resp_buf_type, flags,\n\t\t\t  &rsp_iov);\n\tcifs_small_buf_release(req);\n\tif (rc) {\n\t\tcifs_dbg(FYI, \"Send error in smb2_lockv = %d\\n\", rc);\n\t\tcifs_stats_fail_inc(tcon, SMB2_LOCK_HE);\n\t}\n\n\treturn rc;\n}\n\nint\nSMB2_lock(const unsigned int xid, struct cifs_tcon *tcon,\n\t  const __u64 persist_fid, const __u64 volatile_fid, const __u32 pid,\n\t  const __u64 length, const __u64 offset, const __u32 lock_flags,\n\t  const bool wait)\n{\n\tstruct smb2_lock_element lock;\n\n\tlock.Offset = cpu_to_le64(offset);\n\tlock.Length = cpu_to_le64(length);\n\tlock.Flags = cpu_to_le32(lock_flags);\n\tif (!wait && lock_flags != SMB2_LOCKFLAG_UNLOCK)\n\t\tlock.Flags |= cpu_to_le32(SMB2_LOCKFLAG_FAIL_IMMEDIATELY);\n\n\treturn smb2_lockv(xid, tcon, persist_fid, volatile_fid, pid, 1, &lock);\n}\n\nint\nSMB2_lease_break(const unsigned int xid, struct cifs_tcon *tcon,\n\t\t __u8 *lease_key, const __le32 lease_state)\n{\n\tint rc;\n\tstruct smb2_lease_ack *req = NULL;\n\tint flags = CIFS_OBREAK_OP;\n\n\tcifs_dbg(FYI, \"SMB2_lease_break\\n\");\n\trc = small_smb2_init(SMB2_OPLOCK_BREAK, tcon, (void **) &req);\n\tif (rc)\n\t\treturn rc;\n\n\tif (encryption_required(tcon))\n\t\tflags |= CIFS_TRANSFORM_REQ;\n\n\treq->hdr.sync_hdr.CreditRequest = cpu_to_le16(1);\n\treq->StructureSize = cpu_to_le16(36);\n\tinc_rfc1001_len(req, 12);\n\n\tmemcpy(req->LeaseKey, lease_key, 16);\n\treq->LeaseState = lease_state;\n\n\trc = SendReceiveNoRsp(xid, tcon->ses, (char *) req, flags);\n\tcifs_small_buf_release(req);\n\n\tif (rc) {\n\t\tcifs_stats_fail_inc(tcon, SMB2_OPLOCK_BREAK_HE);\n\t\tcifs_dbg(FYI, \"Send error in Lease Break = %d\\n\", rc);\n\t}\n\n\treturn rc;\n}\n"], "filenames": ["fs/cifs/sess.c", "fs/cifs/smb2pdu.c"], "buggy_code_start_loc": [347, 759], "buggy_code_end_loc": [417, 787], "fixing_code_start_loc": [347, 759], "fixing_code_end_loc": [415, 778], "type": "CWE-476", "message": "The Linux kernel before version 4.11 is vulnerable to a NULL pointer dereference in fs/cifs/cifsencrypt.c:setup_ntlmv2_rsp() that allows an attacker controlling a CIFS server to kernel panic a client that has this server mounted, because an empty TargetInfo field in an NTLMSSP setup negotiation response is mishandled during session recovery.", "other": {"cve": {"id": "CVE-2018-1066", "sourceIdentifier": "secalert@redhat.com", "published": "2018-03-02T08:29:00.337", "lastModified": "2019-04-23T13:37:27.487", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The Linux kernel before version 4.11 is vulnerable to a NULL pointer dereference in fs/cifs/cifsencrypt.c:setup_ntlmv2_rsp() that allows an attacker controlling a CIFS server to kernel panic a client that has this server mounted, because an empty TargetInfo field in an NTLMSSP setup negotiation response is mishandled during session recovery."}, {"lang": "es", "value": "El kernel de Linux, en versiones anteriores a la 4.11, es vulnerable a una desreferencia de puntero NULL en fs/cifs/cifsencrypt.c:setup_ntlmv2_rsp() que permite que un atacante que controla un servidor CIFS provoque un p\u00e1nico en un cliente con el servidor montado, debido a que un campo TargetInfo en una respuesta de negociaci\u00f3n de instalaci\u00f3n NTLMSSP se gestiona de manera incorrecta durante la recuperaci\u00f3n de sesi\u00f3n."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.1}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.10.15", "matchCriteriaId": "3E45C2CA-27DC-4E06-A7E3-DF1F9235CA06"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:esm:*:*:*", "matchCriteriaId": "8D305F7A-D159-4716-AB26-5E38BB5CD991"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=cabfb3680f78981d26c078a26e5c748531257ebb", "source": "secalert@redhat.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/103378", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1539599", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/cabfb3680f78981d26c078a26e5c748531257ebb", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/07/msg00015.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/07/msg00016.html", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://patchwork.kernel.org/patch/10187633/", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3880-1/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3880-2/", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4187", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4188", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/cabfb3680f78981d26c078a26e5c748531257ebb"}}