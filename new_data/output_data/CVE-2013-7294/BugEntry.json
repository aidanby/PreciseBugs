{"buggy_code": ["/*\n * IKEv2 parent SA creation routines\n * Copyright (C) 2007-2008 Michael Richardson <mcr@xelerance.com>\n * Copyright (C) 2008-2011 Paul Wouters <paul@xelerance.com>\n * Copyright (C) 2008 Antony Antony <antony@xelerance.com>\n * Copyright (C) 2008-2009 David McCullough <david_mccullough@securecomputing.com>\n * Copyright (C) 2010,2012 Avesh Agarwal <avagarwa@redhat.com>\n * Copyright (C) 2010 Tuomo Soini <tis@foobar.fi\n * Copyright (C) 2012 Paul Wouters <pwouters@redhat.com>\n * Copyright (C) 2012 Antony Antony <antony@phenome.org>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 2 of the License, or (at your\n * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * for more details.\n *\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <gmp.h>\n\n#include <libreswan.h>\n#include <libreswan/ipsec_policy.h>\n\n#include \"sysdep.h\"\n#include \"constants.h\"\n#include \"defs.h\"\n#include \"state.h\"\n#include \"id.h\"\n#include \"connections.h\"\n\n#include \"crypto.h\" /* requires sha1.h and md5.h */\n#include \"x509.h\"\n#include \"x509more.h\"\n#include \"ike_alg.h\"\n#include \"kernel_alg.h\"\n#include \"plutoalg.h\"\n#include \"pluto_crypt.h\"\n#include \"packet.h\"\n#include \"demux.h\"\n#include \"ikev2.h\"\n#include \"log.h\"\n#include \"spdb.h\"          /* for out_sa */\n#include \"ipsec_doi.h\"\n#include \"vendor.h\"\n#include \"timer.h\"\n#include \"ike_continuations.h\"\n#include \"cookie.h\"\n#include \"rnd.h\"\n#include \"pending.h\"\n#include \"kernel.h\"\n\n#define SEND_NOTIFICATION_AA(t, d) \\\n\tif (st) \\\n\t\tsend_v2_notification_from_state(st, st->st_state, t, d); \\\n\telse \\\n\t\tsend_v2_notification_from_md(md, t, d);\n\n#define SEND_NOTIFICATION(t) \\\n\tif (st) \\\n\t\tsend_v2_notification_from_state(st, st->st_state, t, NULL); \\\n\telse \\\n\t\tsend_v2_notification_from_md(md, t, NULL);\n\nstatic void ikev2_parent_outI1_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\tstruct pluto_crypto_req *r,\n\t\t\t\t\terr_t ugh);\n\nstatic stf_status ikev2_parent_outI1_tail(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t  struct pluto_crypto_req *r);\n\nstatic bool ikev2_get_dcookie(u_char *dcookie, chunk_t st_ni,\n\t\t\t      ip_address *addr, u_int8_t *spiI);\n\nstatic stf_status ikev2_parent_outI1_common(struct msg_digest *md,\n\t\t\t\t\t    struct state *st);\n\nstatic int build_ike_version();\n\n/*\n *\n ***************************************************************\n *****                   PARENT_OUTI1                      *****\n ***************************************************************\n *\n *\n * Initiate an Oakley Main Mode exchange.\n *       HDR, SAi1, KEi, Ni   -->\n *\n * Note: this is not called from demux.c, but from ipsecdoi_initiate().\n *\n */\nstf_status ikev2parent_outI1(int whack_sock,\n\t\t\t     struct connection *c,\n\t\t\t     struct state *predecessor,\n\t\t\t     lset_t policy,\n\t\t\t     unsigned long try,\n\t\t\t     enum crypto_importance importance\n#ifdef HAVE_LABELED_IPSEC\n\t\t\t     , struct xfrm_user_sec_ctx_ike * uctx\n#endif\n\t\t\t     )\n{\n\tstruct state *st = new_state();\n\tstruct db_sa *sadb;\n\tint groupnum;\n\tint policy_index = POLICY_ISAKMP(policy,\n\t\t\t\t\t c->spd.this.xauth_server,\n\t\t\t\t\t c->spd.this.xauth_client);\n\n\t/* set up new state */\n\tget_cookie(TRUE, st->st_icookie, COOKIE_SIZE, &c->spd.that.host_addr);\n\tinitialize_new_state(st, c, policy, try, whack_sock, importance);\n\tst->st_ikev2 = TRUE;\n\tchange_state(st, STATE_PARENT_I1);\n\tst->st_msgid_lastack = INVALID_MSGID;\n\tst->st_msgid_nextuse = 0;\n\tst->st_try   = try;\n\n\tif (HAS_IPSEC_POLICY(policy)) {\n#ifdef HAVE_LABELED_IPSEC\n\t\tst->sec_ctx = NULL;\n\t\tif ( uctx != NULL)\n\t\t\tlibreswan_log(\n\t\t\t\t\"Labeled ipsec is not supported with ikev2 yet\");\n\n\n#endif\n\n\t\tadd_pending(dup_any(\n\t\t\t\t    whack_sock), st, c, policy, 1,\n\t\t\t    predecessor == NULL ? SOS_NOBODY : predecessor->st_serialno\n#ifdef HAVE_LABELED_IPSEC\n\t\t\t    , st->sec_ctx\n#endif\n\t\t\t    );\n\t}\n\n\tif (predecessor == NULL)\n\t\tlibreswan_log(\"initiating v2 parent SA\");\n\telse\n\t\tlibreswan_log(\"initiating v2 parent SA to replace #%lu\",\n\t\t\t      predecessor->st_serialno);\n\n\tif (predecessor != NULL) {\n\t\tupdate_pending(predecessor, st);\n\t\twhack_log(RC_NEW_STATE + STATE_PARENT_I1,\n\t\t\t  \"%s: initiate, replacing #%lu\",\n\t\t\t  enum_name(&state_names, st->st_state),\n\t\t\t  predecessor->st_serialno);\n\t} else {\n\t\twhack_log(RC_NEW_STATE + STATE_PARENT_I1,\n\t\t\t  \"%s: initiate\",\n\t\t\t  enum_name(&state_names, st->st_state));\n\t}\n\n\t/*\n\t * now, we need to initialize st->st_oakley, specifically, the group\n\t * number needs to be initialized.\n\t */\n\tgroupnum = 0;\n\n\tst->st_sadb = &oakley_sadb[policy_index];\n\tsadb = oakley_alg_makedb(st->st_connection->alg_info_ike,\n\t\t\t\t st->st_sadb, 0);\n\tif (sadb != NULL)\n\t\tst->st_sadb = sadb;\n\tsadb = st->st_sadb = sa_v2_convert(st->st_sadb);\n\t{\n\t\tunsigned int pc_cnt;\n\n\t\t/* look at all the proposals */\n\t\tif (st->st_sadb->prop_disj != NULL) {\n\t\t\tfor (pc_cnt = 0;\n\t\t\t     pc_cnt < st->st_sadb->prop_disj_cnt && groupnum ==\n\t\t\t     0;\n\t\t\t     pc_cnt++) {\n\t\t\t\tstruct db_v2_prop *vp =\n\t\t\t\t\t&st->st_sadb->prop_disj[pc_cnt];\n\t\t\t\tunsigned int pr_cnt;\n\n\t\t\t\t/* look at all the proposals */\n\t\t\t\tif (vp->props != NULL) {\n\t\t\t\t\tfor (pr_cnt = 0;\n\t\t\t\t\t     pr_cnt < vp->prop_cnt &&\n\t\t\t\t\t     groupnum == 0;\n\t\t\t\t\t     pr_cnt++) {\n\t\t\t\t\t\tunsigned int ts_cnt;\n\t\t\t\t\t\tstruct db_v2_prop_conj *vpc =\n\t\t\t\t\t\t\t&vp->props[pr_cnt];\n\n\t\t\t\t\t\tfor (ts_cnt = 0;\n\t\t\t\t\t\t     ts_cnt < vpc->trans_cnt &&\n\t\t\t\t\t\t     groupnum == 0; ts_cnt++) {\n\t\t\t\t\t\t\tstruct db_v2_trans *tr\n\t\t\t\t\t\t\t\t=\n\t\t\t\t\t\t\t\t\t&vpc->\n\t\t\t\t\t\t\t\t\ttrans[\n\t\t\t\t\t\t\t\t\t\tts_cnt\n\t\t\t\t\t\t\t\t\t];\n\t\t\t\t\t\t\tif (tr != NULL &&\n\t\t\t\t\t\t\t    tr->transform_type\n\t\t\t\t\t\t\t    ==\n\t\t\t\t\t\t\t    IKEv2_TRANS_TYPE_DH)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tgroupnum =\n\t\t\t\t\t\t\t\t\ttr->\n\t\t\t\t\t\t\t\t\ttransid;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (groupnum == 0)\n\t\tgroupnum = OAKLEY_GROUP_MODP2048;\n\tst->st_oakley.group = lookup_group(groupnum);\n\tst->st_oakley.groupnum = groupnum;\n\n\t/* now. we need to go calculate the nonce, and the KE */\n\t{\n\t\tstruct ke_continuation *ke = alloc_thing(\n\t\t\tstruct ke_continuation,\n\t\t\t\"ikev2_outI1 KE\");\n\t\tstf_status e;\n\n\t\tke->md = alloc_md();\n\t\tke->md->from_state = STATE_IKEv2_BASE;\n\t\tke->md->svm = ikev2_parent_firststate();\n\t\tke->md->st = st;\n\t\tset_suspended(st, ke->md);\n\n\t\tif (!st->st_sec_in_use) {\n\t\t\tpcrc_init(&ke->ke_pcrc);\n\t\t\tke->ke_pcrc.pcrc_func = ikev2_parent_outI1_continue;\n\t\t\te = build_ke(&ke->ke_pcrc, st, st->st_oakley.group,\n\t\t\t\t     importance);\n\t\t\tif ( (e != STF_SUSPEND &&\n\t\t\t      e != STF_INLINE) || (e == STF_TOOMUCHCRYPTO)) {\n\t\t\t\tloglog(RC_CRYPTOFAILED,\n\t\t\t\t       \"system too busy - Enabling dcookies [TODO]\");\n\t\t\t\tdelete_state(st);\n\t\t\t}\n\t\t} else {\n\t\t\te =\n\t\t\t\tikev2_parent_outI1_tail(\n\t\t\t\t\t(struct pluto_crypto_req_cont *)ke,\n\t\t\t\t\tNULL);\n\t\t}\n\n\t\treset_globals();\n\n\t\treturn e;\n\t}\n}\n\nstatic void ikev2_parent_outI1_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\tstruct pluto_crypto_req *r,\n\t\t\t\t\terr_t ugh)\n{\n\tstruct ke_continuation *ke = (struct ke_continuation *)pcrc;\n\tstruct msg_digest *md = ke->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent outI1: calculated ke+nonce, sending I1\"));\n\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t\treturn;\n\t}\n\n\t/* XXX should check out ugh */\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\n\tpassert(st->st_suspended_md == ke->md);\n\tset_suspended(st, NULL); /* no longer connected or suspended */\n\n\tset_cur_state(st);\n\n\tst->st_calculating = FALSE;\n\n\te = ikev2_parent_outI1_tail(pcrc, r);\n\n\tif (ke->md != NULL) {\n\t\tcomplete_v2_state_transition(&ke->md, e);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t}\n\treset_cur_state();\n\treset_globals();\n\n\tpassert(GLOBALS_ARE_RESET());\n}\n\n/*\n * unpack the calculate KE value, store it in state.\n * used by IKEv2: parent, child (PFS)\n */\nstatic int unpack_v2KE(struct state *st,\n\t\t       struct pluto_crypto_req *r,\n\t\t       chunk_t *g)\n{\n\tstruct pcr_kenonce *kn = &r->pcr_d.kn;\n\n\tunpack_KE(st, r, g);\n\treturn kn->oakley_group;\n}\n\n/*\n * package up the calculate KE value, and emit it as a KE payload.\n * used by IKEv2: parent, child (PFS)\n */\nstatic bool justship_v2KE(struct state *st UNUSED,\n\t\t\t  chunk_t *g, unsigned int oakley_group,\n\t\t\t  pb_stream *outs, u_int8_t np)\n{\n\tstruct ikev2_ke v2ke;\n\tpb_stream kepbs;\n\n\tmemset(&v2ke, 0, sizeof(v2ke));\n\tv2ke.isak_np      = np;\n\tv2ke.isak_group   = oakley_group;\n\tif (!out_struct(&v2ke, &ikev2_ke_desc, outs, &kepbs))\n\t\treturn FALSE;\n\n\tif (!out_chunk(*g, &kepbs, \"ikev2 g^x\"))\n\t\treturn FALSE;\n\n\tclose_output_pbs(&kepbs);\n\treturn TRUE;\n}\n\nstatic bool ship_v2KE(struct state *st,\n\t\t      struct pluto_crypto_req *r,\n\t\t      chunk_t *g,\n\t\t      pb_stream *outs, u_int8_t np)\n{\n\tint oakley_group = unpack_v2KE(st, r, g);\n\n\treturn justship_v2KE(st, g, oakley_group, outs, np);\n}\n\nstatic stf_status ikev2_parent_outI1_tail(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t  struct pluto_crypto_req *r)\n{\n\tstruct ke_continuation *ke = (struct ke_continuation *)pcrc;\n\tstruct msg_digest *md = ke->md;\n\tstruct state *const st = md->st;\n\n\tunpack_v2KE(st, r, &st->st_gi);\n\tunpack_nonce(&st->st_ni, r);\n\treturn ikev2_parent_outI1_common(md, st);\n}\n\nstatic stf_status ikev2_parent_outI1_common(struct msg_digest *md,\n\t\t\t\t\t    struct state *st)\n{\n\tstruct connection *c = st->st_connection;\n\tint numvidtosend = 0;\n\n\t/* set up reply */\n\tinit_pbs(&reply_stream, reply_buffer, sizeof(reply_buffer),\n\t\t \"reply packet\");\n\n\t/* HDR out */\n\t{\n\t\tstruct isakmp_hdr hdr;\n\n\t\tzero(&hdr);                             /* default to 0 */\n\t\t/* Impair function will raise major/minor by 1 for testing */\n\t\thdr.isa_version = build_ike_version();\n\t\tif (st->st_dcookie.ptr)\n\t\t\thdr.isa_np   = ISAKMP_NEXT_v2N;\n\t\telse\n\t\t\thdr.isa_np   = ISAKMP_NEXT_v2SA;\n\t\thdr.isa_xchg = ISAKMP_v2_SA_INIT;\n\t\thdr.isa_flags = ISAKMP_FLAGS_I;\n\t\tmemcpy(hdr.isa_icookie, st->st_icookie, COOKIE_SIZE);\n\t\t/* R-cookie, are left zero */\n\n\t\tif (!out_struct(&hdr, &isakmp_hdr_desc, &reply_stream,\n\t\t\t\t&md->rbody)) {\n\t\t\treset_cur_state();\n\t\t\treturn STF_INTERNAL_ERROR;\n\t\t}\n\t}\n\t/* send an anti DOS cookie, 4306 2.6, if we have received one from the\n\t * responder\n\t */\n\n\tif (st->st_dcookie.ptr) {\n\t\tchunk_t child_spi;\n\t\tmemset(&child_spi, 0, sizeof(child_spi));\n\t\tship_v2N(ISAKMP_NEXT_v2SA, DBGP(\n\t\t\t\t IMPAIR_SEND_BOGUS_ISAKMP_FLAG) ?\n\t\t\t (ISAKMP_PAYLOAD_NONCRITICAL |\n\t\t\t  ISAKMP_PAYLOAD_LIBRESWAN_BOGUS) :\n\t\t\t ISAKMP_PAYLOAD_NONCRITICAL, PROTO_ISAKMP,\n\t\t\t &child_spi,\n\t\t\t v2N_COOKIE, &st->st_dcookie, &md->rbody);\n\t}\n\t/* SA out */\n\t{\n\t\tu_char *sa_start = md->rbody.cur;\n\n\t\tif (st->st_sadb->prop_disj_cnt == 0 || st->st_sadb->prop_disj)\n\t\t\tst->st_sadb = sa_v2_convert(st->st_sadb);\n\n\t\tif (!ikev2_out_sa(&md->rbody,\n\t\t\t\t  PROTO_ISAKMP,\n\t\t\t\t  st->st_sadb,\n\t\t\t\t  st, TRUE, /* parentSA */\n\t\t\t\t  ISAKMP_NEXT_v2KE)) {\n\t\t\tlibreswan_log(\"outsa fail\");\n\t\t\treset_cur_state();\n\t\t\treturn STF_INTERNAL_ERROR;\n\t\t}\n\t\t/* save initiator SA for later HASH */\n\t\tif (st->st_p1isa.ptr == NULL) { /* no leak!  (MUST be first time) */\n\t\t\tclonetochunk(st->st_p1isa, sa_start,\n\t\t\t\t     md->rbody.cur - sa_start,\n\t\t\t\t     \"sa in main_outI1\");\n\t\t}\n\t}\n\n\t/* send KE */\n\tif (!justship_v2KE(st, &st->st_gi, st->st_oakley.groupnum,  &md->rbody,\n\t\t\t   ISAKMP_NEXT_v2Ni))\n\t\treturn STF_INTERNAL_ERROR;\n\n\t/*\n\t * Check which Vendor ID's we need to send - there will be more soon\n\t * In IKEv2, DPD and NAT-T are no longer vendorid's\n\t */\n\tif (c->send_vendorid) {\n\t\tnumvidtosend++;  /* if we need to send Libreswan VID */\n\t}\n\n\t/* send NONCE */\n\t{\n\t\tint np = numvidtosend > 0 ? ISAKMP_NEXT_v2V : ISAKMP_NEXT_v2NONE;\n\t\tstruct ikev2_generic in;\n\t\tpb_stream pb;\n\n\t\tmemset(&in, 0, sizeof(in));\n\t\tin.isag_np = np;\n\t\tin.isag_critical = ISAKMP_PAYLOAD_NONCRITICAL;\n\t\tif (DBGP(IMPAIR_SEND_BOGUS_ISAKMP_FLAG)) {\n\t\t\tlibreswan_log(\n\t\t\t\t\" setting bogus ISAKMP_PAYLOAD_LIBRESWAN_BOGUS flag in ISAKMP payload\");\n\t\t\tin.isag_critical |= ISAKMP_PAYLOAD_LIBRESWAN_BOGUS;\n\t\t}\n\n\t\tif (!out_struct(&in, &ikev2_nonce_desc, &md->rbody, &pb) ||\n\t\t    !out_raw(st->st_ni.ptr, st->st_ni.len, &pb, \"IKEv2 nonce\"))\n\t\t\treturn STF_INTERNAL_ERROR;\n\n\t\tclose_output_pbs(&pb);\n\t}\n\n\t/* Send Vendor VID if needed */\n\tif (c->send_vendorid) {\n\t\tconst char *myvid = ipsec_version_vendorid();\n\t\tint np = --numvidtosend >\n\t\t\t 0 ? ISAKMP_NEXT_v2V : ISAKMP_NEXT_v2NONE;\n\n\t\tif (!out_generic_raw(np, &isakmp_vendor_id_desc, &md->rbody,\n\t\t\t\t     myvid, strlen(myvid),\n\t\t\t\t     \"Vendor ID\"))\n\t\t\treturn STF_INTERNAL_ERROR;\n\n\t\t/* ensure our VID chain was valid */\n\t\tpassert(numvidtosend == 0);\n\t}\n\n\tclose_message(&md->rbody, st);\n\tclose_output_pbs(&reply_stream);\n\n\tfreeanychunk(st->st_tpacket);\n\tclonetochunk(st->st_tpacket, reply_stream.start,\n\t\t     pbs_offset(&reply_stream),\n\t\t     \"reply packet for ikev2_parent_outI1_tail\");\n\n\t/* save packet for later signing */\n\tfreeanychunk(st->st_firstpacket_me);\n\tclonetochunk(st->st_firstpacket_me, reply_stream.start,\n\t\t     pbs_offset(&reply_stream), \"saved first packet\");\n\n\t/* Transmit */\n\tsend_ike_msg(st, __FUNCTION__);\n\n\tdelete_event(st);\n\tevent_schedule(EVENT_v2_RETRANSMIT, EVENT_RETRANSMIT_DELAY_0, st);\n\n\treset_cur_state();\n\treturn STF_OK;\n}\n\n/*\n *\n ***************************************************************\n *                       PARENT_INI1                       *****\n ***************************************************************\n *  -\n *\n *\n */\nstatic void ikev2_parent_inI1outR1_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh);\n\nstatic stf_status ikev2_parent_inI1outR1_tail(\n\tstruct pluto_crypto_req_cont *pcrc,\n\tstruct pluto_crypto_req *r);\n\nstf_status ikev2parent_inI1outR1(struct msg_digest *md)\n{\n\tstruct state *st = md->st;\n\tlset_t policy = POLICY_IKEV2_ALLOW;\n\tstruct connection *c = find_host_connection(&md->iface->ip_addr,\n\t\t\t\t\t\t    md->iface->port,\n\t\t\t\t\t\t    &md->sender,\n\t\t\t\t\t\t    md->sender_port,\n\t\t\t\t\t\t    POLICY_IKEV2_ALLOW);\n\n\t/* retrieve st->st_gi */\n\n#if 0\n\tif (c == NULL) {\n\t\t/*\n\t\t * make up a policy from the thing that was proposed, and see\n\t\t * if we can find a connection with that policy.\n\t\t */\n\n\t\tpb_stream pre_sa_pbs = sa_pd->pbs;\n\t\tpolicy = preparse_isakmp_sa_body(&pre_sa_pbs);\n\t\tc = find_host_connection(&md->iface->ip_addr, pluto_port,\n\t\t\t\t\t (ip_address*)NULL, md->sender_port,\n\t\t\t\t\t policy);\n\n\t}\n#endif\n\n\tif (c == NULL) {\n\n\t\t/* See if a wildcarded connection can be found.\n\t\t * We cannot pick the right connection, so we're making a guess.\n\t\t * All Road Warrior connections are fair game:\n\t\t * we pick the first we come across (if any).\n\t\t * If we don't find any, we pick the first opportunistic\n\t\t * with the smallest subnet that includes the peer.\n\t\t * There is, of course, no necessary relationship between\n\t\t * an Initiator's address and that of its client,\n\t\t * but Food Groups kind of assumes one.\n\t\t */\n\t\t{\n\t\t\tstruct connection *d;\n\t\t\td = find_host_connection(&md->iface->ip_addr,\n\t\t\t\t\t\t pluto_port,\n\t\t\t\t\t\t (ip_address*)NULL,\n\t\t\t\t\t\t md->sender_port, policy);\n\n\t\t\tfor (; d != NULL; d = d->hp_next) {\n\t\t\t\tif (d->kind == CK_GROUP) {\n\t\t\t\t\t/* ignore */\n\t\t\t\t} else {\n\t\t\t\t\tif (d->kind == CK_TEMPLATE &&\n\t\t\t\t\t    !(d->policy & POLICY_OPPO)) {\n\t\t\t\t\t\t/* must be Road Warrior: we have a winner */\n\t\t\t\t\t\tc = d;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Opportunistic or Shunt: pick tightest match */\n\t\t\t\t\tif (addrinsubnet(&md->sender,\n\t\t\t\t\t\t\t &d->spd.that.client)\n\t\t\t\t\t    &&\n\t\t\t\t\t    (c == NULL ||\n\t\t\t\t\t     !subnetinsubnet(&c->spd.that.\n\t\t\t\t\t\t\t     client,\n\t\t\t\t\t\t\t     &d->spd.that.\n\t\t\t\t\t\t\t     client)))\n\t\t\t\t\t\tc = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (c == NULL) {\n\t\t\tloglog(RC_LOG_SERIOUS, \"initial parent SA message received on %s:%u\"\n\t\t\t       \" but no connection has been authorized%s%s\",\n\t\t\t       ip_str(\n\t\t\t\t       &md->iface->ip_addr),\n\t\t\t       ntohs(portof(&md->iface->ip_addr)),\n\t\t\t       (policy != LEMPTY) ? \" with policy=\" : \"\",\n\t\t\t       (policy !=\n\t\t\t\tLEMPTY) ? bitnamesof(sa_policy_bit_names,\n\t\t\t\t\t\t     policy) : \"\");\n\t\t\treturn STF_FAIL + v2N_NO_PROPOSAL_CHOSEN;\n\t\t}\n\t\tif (c->kind != CK_TEMPLATE) {\n\t\t\tloglog(RC_LOG_SERIOUS, \"initial parent SA message received on %s:%u\"\n\t\t\t       \" but \\\"%s\\\" forbids connection\",\n\t\t\t       ip_str(\n\t\t\t\t       &md->iface->ip_addr), pluto_port,\n\t\t\t       c->name);\n\t\t\treturn STF_FAIL + v2N_NO_PROPOSAL_CHOSEN;\n\t\t}\n\t\tc = rw_instantiate(c, &md->sender, NULL, NULL);\n\n\t} else {\n\t\t/* we found a non-wildcard conn. double check if it needs instantiation anyway (eg vnet=) */\n\t\t/* vnet=/vhost= should have set CK_TEMPLATE on connection loading */\n\t\tif ((c->kind == CK_TEMPLATE) && c->spd.that.virt) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\n\t\t\t\t    \"local endpoint has virt (vnet/vhost) set without wildcards - needs instantiation\"));\n\t\t\tc = rw_instantiate(c, &md->sender, NULL, NULL);\n\t\t} else if ((c->kind == CK_TEMPLATE) &&\n\t\t\t   (c->policy & POLICY_IKEV2_ALLOW_NARROWING)) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\n\t\t\t\t    \"local endpoint has narrowing=yes - needs instantiation\"));\n\t\t\tc = rw_instantiate(c, &md->sender, NULL, NULL);\n\t\t}\n\t}\n\n\tDBG_log(\"found connection: %s\\n\", c ? c->name : \"<none>\");\n\n\tif (!st) {\n\t\tst = new_state();\n\t\t/* set up new state */\n\t\tmemcpy(st->st_icookie, md->hdr.isa_icookie, COOKIE_SIZE);\n\t\t/* initialize_new_state expects valid icookie/rcookie values, so create it now */\n\t\tget_cookie(FALSE, st->st_rcookie, COOKIE_SIZE, &md->sender);\n\t\tinitialize_new_state(st, c, policy, 0, NULL_FD,\n\t\t\t\t     pcim_stranger_crypto);\n\t\tst->st_ikev2 = TRUE;\n\t\tchange_state(st, STATE_PARENT_R1);\n\t\tst->st_msgid_lastack = INVALID_MSGID;\n\t\tst->st_msgid_nextuse = 0;\n\n\t\tmd->st = st;\n\t\tmd->from_state = STATE_IKEv2_BASE;\n\t}\n\n\t/* check,as a responder, are we under dos attack or not\n\t * if yes go to 6 message exchange mode. it is a config option for now.\n\t * TBD set force_busy dynamically\n\t * Paul: Can we check for STF_TOOMUCHCRYPTO ?\n\t */\n\tif (force_busy == TRUE) {\n\t\tu_char dcookie[SHA1_DIGEST_SIZE];\n\t\tchunk_t dc;\n\t\tikev2_get_dcookie( dcookie, st->st_ni, &md->sender,\n\t\t\t\t   st->st_icookie);\n\t\tdc.ptr = dcookie;\n\t\tdc.len = SHA1_DIGEST_SIZE;\n\n\t\t/* check if I1 packet contian KE and a v2N payload with type COOKIE */\n\t\tif ( md->chain[ISAKMP_NEXT_v2KE] &&\n\t\t     md->chain[ISAKMP_NEXT_v2N] &&\n\t\t     (md->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type ==\n\t\t      v2N_COOKIE)) {\n\t\t\tu_int8_t spisize;\n\t\t\tconst pb_stream *dc_pbs;\n\t\t\tchunk_t blob;\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\"received a DOS cookie in I1 verify it\"));\n\t\t\t/* we received dcookie we send earlier verify it */\n\t\t\tspisize =\n\t\t\t\tmd->chain[ISAKMP_NEXT_v2N]->payload.v2n.\n\t\t\t\tisan_spisize;\n\t\t\tdc_pbs = &md->chain[ISAKMP_NEXT_v2N]->pbs;\n\t\t\tblob.ptr = dc_pbs->cur + spisize;\n\t\t\tblob.len = pbs_left(dc_pbs) - spisize;\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_dump_chunk(\"dcookie received in I1 Packet\",\n\t\t\t\t\t   blob);\n\t\t\t    DBG_dump(\"dcookie computed\", dcookie,\n\t\t\t\t     SHA1_DIGEST_SIZE));\n\n\t\t\tif (memcmp(blob.ptr, dcookie, SHA1_DIGEST_SIZE) != 0) {\n\t\t\t\tlibreswan_log(\n\t\t\t\t\t\"mismatch in DOS v2N_COOKIE,send a new one\");\n\t\t\t\tSEND_NOTIFICATION_AA(v2N_COOKIE, &dc);\n\t\t\t\treturn STF_FAIL + v2N_INVALID_IKE_SPI;\n\t\t\t}\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\"dcookie received match with computed one\"));\n\t\t} else {\n\t\t\t/* we are under DOS attack I1 contains no DOS COOKIE */\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\n\t\t\t\t    \"busy mode on. receieved I1 without a valid dcookie\");\n\t\t\t    DBG_log(\"send a dcookie and forget this state\"));\n\t\t\tSEND_NOTIFICATION_AA(v2N_COOKIE, &dc);\n\t\t\treturn STF_FAIL;\n\t\t}\n\t} else {\n\t\tDBG(DBG_CONTROLMORE,\n\t\t    DBG_log(\"will not send/process a dcookie\"));\n\n\t}\n\n\t/*\n\t * We have to agree to the DH group before we actually know who\n\t * we are talking to.   If we support the group, we use it.\n\t *\n\t * It is really too hard here to go through all the possible policies\n\t * that might permit this group.  If we think we are being DOS'ed\n\t * then we should demand a cookie.\n\t */\n\t{\n\t\tstruct ikev2_ke *ke;\n\t\tke = &md->chain[ISAKMP_NEXT_v2KE]->payload.v2ke;\n\n\t\tst->st_oakley.group = lookup_group(ke->isak_group);\n\t\tif (st->st_oakley.group == NULL) {\n\t\t\tchar fromname[ADDRTOT_BUF];\n\n\t\t\taddrtot(&md->sender, 0, fromname, ADDRTOT_BUF);\n\t\t\tlibreswan_log(\n\t\t\t\t\"rejecting I1 from %s:%u, invalid DH group=%u\",\n\t\t\t\tfromname, md->sender_port,\n\t\t\t\tke->isak_group);\n\t\t\treturn v2N_INVALID_KE_PAYLOAD;\n\t\t}\n\t}\n\n\t/* now. we need to go calculate the nonce, and the KE */\n\t{\n\t\tstruct ke_continuation *ke = alloc_thing(\n\t\t\tstruct ke_continuation,\n\t\t\t\"ikev2_inI1outR1 KE\");\n\t\tstf_status e;\n\n\t\tke->md = md;\n\t\tset_suspended(st, ke->md);\n\n\t\tif (!st->st_sec_in_use) {\n\t\t\tpcrc_init(&ke->ke_pcrc);\n\t\t\tke->ke_pcrc.pcrc_func =\n\t\t\t\tikev2_parent_inI1outR1_continue;\n\t\t\te = build_ke(&ke->ke_pcrc, st, st->st_oakley.group,\n\t\t\t\t     pcim_stranger_crypto);\n\t\t\tif (e != STF_SUSPEND && e != STF_INLINE) {\n\t\t\t\tloglog(RC_CRYPTOFAILED, \"system too busy\");\n\t\t\t\tdelete_state(st);\n\t\t\t}\n\t\t} else {\n\t\t\te =\n\t\t\t\tikev2_parent_inI1outR1_tail((struct\n\t\t\t\t\t\t\t     pluto_crypto_req_cont\n\t\t\t\t\t\t\t     *)ke,\n\t\t\t\t\t\t\t    NULL);\n\t\t}\n\n\t\treset_globals();\n\n\t\treturn e;\n\t}\n}\n\nstatic void ikev2_parent_inI1outR1_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct ke_continuation *ke = (struct ke_continuation *)pcrc;\n\tstruct msg_digest *md = ke->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent inI1outR1: calculated ke+nonce, sending R1\"));\n\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t\treturn;\n\t}\n\n\t/* XXX should check out ugh */\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\n\tpassert(st->st_suspended_md == ke->md);\n\tset_suspended(st, NULL); /* no longer connected or suspended */\n\n\tset_cur_state(st);\n\n\tst->st_calculating = FALSE;\n\n\te = ikev2_parent_inI1outR1_tail(pcrc, r);\n\n\tif (ke->md != NULL) {\n\t\tcomplete_v2_state_transition(&ke->md, e);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t}\n\treset_globals();\n\n\tpassert(GLOBALS_ARE_RESET());\n}\n\nstatic stf_status ikev2_parent_inI1outR1_tail(\n\tstruct pluto_crypto_req_cont *pcrc,\n\tstruct pluto_crypto_req *r)\n{\n\tstruct ke_continuation *ke = (struct ke_continuation *)pcrc;\n\tstruct msg_digest *md = ke->md;\n\tstruct payload_digest *const sa_pd = md->chain[ISAKMP_NEXT_v2SA];\n\tstruct state *const st = md->st;\n\tstruct connection *c = st->st_connection;\n\tpb_stream *keyex_pbs;\n\tint numvidtosend = 0;\n\n\tif (c->send_vendorid) {\n\t\tnumvidtosend++; /* we send Libreswan VID */\n\t}\n\t/* note that we don't update the state here yet */\n\n\t/* record first packet for later checking of signature */\n\tclonetochunk(st->st_firstpacket_him, md->message_pbs.start,\n\t\t     pbs_offset(\n\t\t\t     &md->message_pbs), \"saved first received packet\");\n\n\t/* make sure HDR is at start of a clean buffer */\n\tzero(reply_buffer);\n\tinit_pbs(&reply_stream, reply_buffer, sizeof(reply_buffer),\n\t\t \"reply packet\");\n\n\t/* HDR out */\n\t{\n\t\tstruct isakmp_hdr r_hdr = md->hdr;\n\n\t\tmemcpy(r_hdr.isa_rcookie, st->st_rcookie, COOKIE_SIZE);\n\t\tr_hdr.isa_np = ISAKMP_NEXT_v2SA;\n\t\t/* major will be same, but their minor might be higher */\n\t\tr_hdr.isa_version = build_ike_version();\n\t\tr_hdr.isa_flags &= ~ISAKMP_FLAGS_I;\n\t\tr_hdr.isa_flags |=  ISAKMP_FLAGS_R;\n\t\t/* PAUL shouldn't we set r_hdr.isa_msgid = [htonl](st->st_msgid);  here? */\n\t\tif (!out_struct(&r_hdr, &isakmp_hdr_desc, &reply_stream,\n\t\t\t\t&md->rbody))\n\t\t\treturn STF_INTERNAL_ERROR;\n\t}\n\n\t/* start of SA out */\n\t{\n\t\tstruct isakmp_sa r_sa = sa_pd->payload.sa;\n\t\tv2_notification_t rn;\n\t\tpb_stream r_sa_pbs;\n\n\t\tr_sa.isasa_np = ISAKMP_NEXT_v2KE; /* XXX */\n\t\tif (!out_struct(&r_sa, &ikev2_sa_desc, &md->rbody, &r_sa_pbs))\n\t\t\treturn STF_INTERNAL_ERROR;\n\n\t\t/* SA body in and out */\n\t\trn = ikev2_parse_parent_sa_body(&sa_pd->pbs,\n\t\t\t\t\t\t&sa_pd->payload.v2sa,\n\t\t\t\t\t\t&r_sa_pbs, st, FALSE);\n\n\t\tif (rn != v2N_NOTHING_WRONG)\n\t\t\treturn STF_FAIL + rn;\n\t}\n\n\t{\n\t\tv2_notification_t rn;\n\t\tchunk_t dc;\n\t\tkeyex_pbs = &md->chain[ISAKMP_NEXT_v2KE]->pbs;\n\t\t/* KE in */\n\t\trn =\n\t\t\taccept_KE(&st->st_gi, \"Gi\", st->st_oakley.group,\n\t\t\t\t  keyex_pbs);\n\t\tif (rn != v2N_NOTHING_WRONG) {\n\t\t\tu_int16_t group_number = htons(\n\t\t\t\tst->st_oakley.group->group);\n\t\t\tdc.ptr = (unsigned char *)&group_number;\n\t\t\tdc.len = 2;\n\t\t\tSEND_NOTIFICATION_AA(v2N_INVALID_KE_PAYLOAD, &dc);\n\t\t\tdelete_state(st);\n\t\t\treturn STF_FAIL + rn;\n\t\t}\n\t}\n\n\t/* Ni in */\n\tRETURN_STF_FAILURE(accept_v2_nonce(md, &st->st_ni, \"Ni\"));\n\n\t/* send KE */\n\tif (!ship_v2KE(st, r, &st->st_gr, &md->rbody, ISAKMP_NEXT_v2Nr))\n\t\treturn STF_INTERNAL_ERROR;\n\n\t/* send NONCE */\n\tunpack_nonce(&st->st_nr, r);\n\t{\n\t\tint np = numvidtosend > 0 ? ISAKMP_NEXT_v2V : ISAKMP_NEXT_v2NONE;\n\t\tstruct ikev2_generic in;\n\t\tpb_stream pb;\n\n\t\tmemset(&in, 0, sizeof(in));\n\t\tin.isag_np = np;\n\t\tin.isag_critical = ISAKMP_PAYLOAD_NONCRITICAL;\n\t\tif (DBGP(IMPAIR_SEND_BOGUS_ISAKMP_FLAG)) {\n\t\t\tlibreswan_log(\n\t\t\t\t\" setting bogus ISAKMP_PAYLOAD_LIBRESWAN_BOGUS flag in ISAKMP payload\");\n\t\t\tin.isag_critical |= ISAKMP_PAYLOAD_LIBRESWAN_BOGUS;\n\t\t}\n\n\t\tif (!out_struct(&in, &ikev2_nonce_desc, &md->rbody, &pb) ||\n\t\t    !out_raw(st->st_nr.ptr, st->st_nr.len, &pb, \"IKEv2 nonce\"))\n\t\t\treturn STF_INTERNAL_ERROR;\n\n\t\tclose_output_pbs(&pb);\n\t}\n\n\t/* Send VendrID if needed VID */\n\tif (c->send_vendorid) {\n\t\tconst char *myvid = ipsec_version_vendorid();\n\t\tint np = --numvidtosend >\n\t\t\t 0 ? ISAKMP_NEXT_v2V : ISAKMP_NEXT_v2NONE;\n\n\t\tif (!out_generic_raw(np, &isakmp_vendor_id_desc, &md->rbody,\n\t\t\t\t     myvid, strlen(myvid),\n\t\t\t\t     \"Vendor ID\"))\n\t\t\treturn STF_INTERNAL_ERROR;\n\t}\n\n\tclose_message(&md->rbody, st);\n\tclose_output_pbs(&reply_stream);\n\n\t/* keep it for a retransmit if necessary */\n\tfreeanychunk(st->st_tpacket);\n\tclonetochunk(st->st_tpacket, reply_stream.start,\n\t\t     pbs_offset(&reply_stream),\n\t\t     \"reply packet for ikev2_parent_inI1outR1_tail\");\n\n\t/* save packet for later signing */\n\tfreeanychunk(st->st_firstpacket_me);\n\tclonetochunk(st->st_firstpacket_me, reply_stream.start,\n\t\t     pbs_offset(&reply_stream), \"saved first packet\");\n\n\t/* note: retransimission is driven by initiator */\n\n\treturn STF_OK;\n}\n\n/*\n *\n ***************************************************************\n *                       PARENT_inR1                       *****\n ***************************************************************\n *  -\n *\n *\n */\nstatic void ikev2_parent_inR1outI2_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh);\n\nstatic stf_status ikev2_parent_inR1outI2_tail(\n\tstruct pluto_crypto_req_cont *pcrc,\n\tstruct pluto_crypto_req *r);\n\nstf_status ikev2parent_inR1outI2(struct msg_digest *md)\n{\n\tstruct state *st = md->st;\n\t/* struct connection *c = st->st_connection; */\n\tpb_stream *keyex_pbs;\n\n\t/* check if the responder replied with v2N with DOS COOKIE */\n\tif ( md->chain[ISAKMP_NEXT_v2N] &&\n\t     md->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type ==\n\t     v2N_COOKIE) {\n\t\tu_int8_t spisize;\n\t\tconst pb_stream *dc_pbs;\n\t\tDBG(DBG_CONTROLMORE,\n\t\t    DBG_log(\n\t\t\t    \"inR1OutI2 received a DOS v2N_COOKIE from the responder\");\n\t\t    DBG_log(\"resend the I1 with a cookie payload\"));\n\t\tspisize = md->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_spisize;\n\t\tdc_pbs = &md->chain[ISAKMP_NEXT_v2N]->pbs;\n\t\tclonetochunk(st->st_dcookie,  (dc_pbs->cur + spisize),\n\t\t\t     (pbs_left(\n\t\t\t\t      dc_pbs) - spisize),\n\t\t\t     \"saved received dcookie\");\n\n\t\tDBG(DBG_CONTROLMORE,\n\t\t    DBG_dump_chunk(\"dcookie received (instead of a R1):\",\n\t\t\t\t   st->st_dcookie);\n\t\t    DBG_log(\"next STATE_PARENT_I1 resend I1 with the dcookie\"));\n\n\t\tmd->svm = ikev2_parent_firststate();\n\n\t\tchange_state(st, STATE_PARENT_I1);\n\t\tst->st_msgid_lastack = INVALID_MSGID;\n\t\tmd->msgid_received = INVALID_MSGID; /* AAA hack  */\n\t\tst->st_msgid_nextuse = 0;\n\n\t\treturn ikev2_parent_outI1_common(md, st);\n\t}\n\n\t/*\n\t * If we did not get a KE payload, we cannot continue. There * should be\n\t * a Notify telling us why. We inform the user, but continue to try this\n\t * connection via regular retransmit intervals.\n\t */\n\tif ( md->chain[ISAKMP_NEXT_v2N]  &&\n\t     (md->chain[ISAKMP_NEXT_v2KE] == NULL)) {\n\t\tconst char *from_state_name = enum_name(&state_names,\n\t\t\t\t\t\t\tst->st_state);\n\t\tconst u_int16_t isan_type =\n\t\t\tmd->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type;\n\t\tlibreswan_log(\"%s: received %s\",\n\t\t\t      from_state_name,\n\t\t\t      enum_name(&ikev2_notify_names, isan_type));\n\t\treturn STF_FAIL + isan_type;\n\t} else if ( md->chain[ISAKMP_NEXT_v2N]) {\n\t\tDBG(DBG_CONTROL, DBG_log(\"received a notify..\"));\n\t}\n\n\t/*\n\t * the responder sent us back KE, Gr, Nr, and it's our time to calculate\n\t * the shared key values.\n\t */\n\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\n\t\t    \"ikev2 parent inR1: calculating g^{xy} in order to send I2\"));\n\n\t/* KE in */\n\tkeyex_pbs = &md->chain[ISAKMP_NEXT_v2KE]->pbs;\n\tRETURN_STF_FAILURE(accept_KE(&st->st_gr, \"Gr\", st->st_oakley.group,\n\t\t\t\t     keyex_pbs));\n\n\t/* Ni in */\n\tRETURN_STF_FAILURE(accept_v2_nonce(md, &st->st_nr, \"Ni\"));\n\n\tif (md->chain[ISAKMP_NEXT_v2SA] == NULL) {\n\t\tlibreswan_log(\"No responder SA proposal found\");\n\t\treturn v2N_INVALID_SYNTAX;\n\t}\n\n\t/* process and confirm the SA selected */\n\t{\n\t\tstruct payload_digest *const sa_pd =\n\t\t\tmd->chain[ISAKMP_NEXT_v2SA];\n\t\tv2_notification_t rn;\n\n\t\t/* SA body in and out */\n\t\trn = ikev2_parse_parent_sa_body(&sa_pd->pbs,\n\t\t\t\t\t\t&sa_pd->payload.v2sa,\n\t\t\t\t\t\tNULL, st, FALSE);\n\n\t\tif (rn != v2N_NOTHING_WRONG)\n\t\t\treturn STF_FAIL + rn;\n\t}\n\n\t/* update state */\n\tikev2_update_counters(md);\n\n\t/* now. we need to go calculate the g^xy */\n\t{\n\t\tstruct dh_continuation *dh = alloc_thing(\n\t\t\tstruct dh_continuation,\n\t\t\t\"ikev2_inR1outI2 KE\");\n\t\tstf_status e;\n\n\t\tdh->md = md;\n\t\tset_suspended(st, dh->md);\n\n\t\tpcrc_init(&dh->dh_pcrc);\n\t\tdh->dh_pcrc.pcrc_func = ikev2_parent_inR1outI2_continue;\n\t\te = start_dh_v2(&dh->dh_pcrc, st, st->st_import, INITIATOR,\n\t\t\t\tst->st_oakley.groupnum);\n\t\tif (e != STF_SUSPEND && e != STF_INLINE) {\n\t\t\tloglog(RC_CRYPTOFAILED, \"system too busy\");\n\t\t\tdelete_state(st);\n\t\t}\n\n\t\treset_globals();\n\n\t\treturn e;\n\t}\n}\n\nstatic void ikev2_parent_inR1outI2_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct dh_continuation *dh = (struct dh_continuation *)pcrc;\n\tstruct msg_digest *md = dh->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent inR1outI2: calculating g^{xy}, sending I2\"));\n\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t\treturn;\n\t}\n\n\t/* XXX should check out ugh */\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\n\tpassert(st->st_suspended_md == dh->md);\n\tset_suspended(st, NULL); /* no longer connected or suspended */\n\n\tset_cur_state(st);\n\n\tst->st_calculating = FALSE;\n\n\te = ikev2_parent_inR1outI2_tail(pcrc, r);\n\n\tif (dh->md != NULL) {\n\t\tcomplete_v2_state_transition(&dh->md, e);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t}\n\treset_globals();\n\n\tpassert(GLOBALS_ARE_RESET());\n}\n\nstatic void ikev2_padup_pre_encrypt(struct msg_digest *md,\n\t\t\t\t    pb_stream *e_pbs_cipher)\n{\n\tstruct state *st = md->st;\n\tstruct state *pst = st;\n\n\tif (st->st_clonedfrom != 0)\n\t\tpst = state_with_serialno(st->st_clonedfrom);\n\n\t/* pads things up to message size boundary */\n\t{\n\t\tsize_t blocksize = pst->st_oakley.encrypter->enc_blocksize;\n\t\tchar  *b = alloca(blocksize);\n\t\tunsigned int i;\n\t\tsize_t padding =  pad_up(pbs_offset(e_pbs_cipher), blocksize);\n\t\tif (padding == 0)\n\t\t\tpadding = blocksize;\n\n\t\tfor (i = 0; i < padding; i++)\n\t\t\tb[i] = i;\n\t\tout_raw(b, padding, e_pbs_cipher, \"padding and length\");\n\t}\n}\n\nstatic unsigned char *ikev2_authloc(struct msg_digest *md,\n\t\t\t\t    pb_stream *e_pbs)\n{\n\tunsigned char *b12;\n\tstruct state *st = md->st;\n\tstruct state *pst = st;\n\n\tif (st->st_clonedfrom != 0) {\n\t\tpst = state_with_serialno(st->st_clonedfrom);\n\t\tif ( pst == NULL)\n\t\t\treturn NULL;\n\t}\n\n\tb12 = e_pbs->cur;\n\tif (!out_zero(pst->st_oakley.integ_hasher->hash_integ_len, e_pbs,\n\t\t      \"length of truncated HMAC\"))\n\t\treturn NULL;\n\n\treturn b12;\n}\n\nstatic stf_status ikev2_encrypt_msg(struct msg_digest *md,\n\t\t\t\t    enum phase1_role init,\n\t\t\t\t    unsigned char *authstart,\n\t\t\t\t    unsigned char *iv,\n\t\t\t\t    unsigned char *encstart,\n\t\t\t\t    unsigned char *authloc,\n\t\t\t\t    pb_stream *e_pbs UNUSED,\n\t\t\t\t    pb_stream *e_pbs_cipher)\n{\n\tstruct state *st = md->st;\n\tstruct state *pst = st;\n\tchunk_t *cipherkey, *authkey;\n\n\tif (st->st_clonedfrom != 0)\n\t\tpst = state_with_serialno(st->st_clonedfrom);\n\n\tif (init == INITIATOR) {\n\t\tcipherkey = &pst->st_skey_ei;\n\t\tauthkey   = &pst->st_skey_ai;\n\t} else {\n\t\tcipherkey = &pst->st_skey_er;\n\t\tauthkey   = &pst->st_skey_ar;\n\t}\n\n\t/* encrypt the block */\n\t{\n\t\tsize_t blocksize = pst->st_oakley.encrypter->enc_blocksize;\n\t\tunsigned char *savediv = alloca(blocksize);\n\t\tunsigned int cipherlen = e_pbs_cipher->cur - encstart;\n\n\t\tDBG(DBG_CRYPT,\n\t\t    DBG_dump(\"data before encryption:\", encstart, cipherlen));\n\n\t\tmemcpy(savediv, iv, blocksize);\n\n\t\t/* now, encrypt */\n\t\t(st->st_oakley.encrypter->do_crypt)(encstart,\n\t\t\t\t\t\t    cipherlen,\n\t\t\t\t\t\t    cipherkey->ptr,\n\t\t\t\t\t\t    cipherkey->len,\n\t\t\t\t\t\t    savediv, TRUE);\n\n\t\tDBG(DBG_CRYPT,\n\t\t    DBG_dump(\"data after encryption:\", encstart, cipherlen));\n\t}\n\n\t/* okay, authenticate from beginning of IV */\n\t{\n\t\tstruct hmac_ctx ctx;\n\t\tDBG(DBG_PARSING, DBG_log(\"Inside authloc\"));\n\t\tDBG(DBG_CRYPT,\n\t\t    DBG_dump(\"authkey value: \", authkey->ptr, authkey->len));\n\t\thmac_init_chunk(&ctx, pst->st_oakley.integ_hasher, *authkey);\n\t\tDBG(DBG_PARSING, DBG_log(\"Inside authloc after init\"));\n\t\thmac_update(&ctx, authstart, authloc - authstart);\n\t\tDBG(DBG_PARSING, DBG_log(\"Inside authloc after update\"));\n\t\thmac_final(authloc, &ctx);\n\t\tDBG(DBG_PARSING, DBG_log(\"Inside authloc after final\"));\n\n\t\tDBG(DBG_PARSING, {\n\t\t\t    DBG_dump(\"data being hmac:\", authstart, authloc -\n\t\t\t\t     authstart);\n\t\t\t    DBG_dump(\"out calculated auth:\", authloc,\n\t\t\t\t     pst->st_oakley.integ_hasher->\n\t\t\t\t     hash_integ_len);\n\t\t    });\n\t}\n\n\treturn STF_OK;\n}\n\nstatic\nstf_status ikev2_decrypt_msg(struct msg_digest *md,\n\t\t\t     enum phase1_role init)\n{\n\tstruct state *st = md->st;\n\tunsigned char *encend;\n\tpb_stream     *e_pbs;\n\tunsigned int np;\n\tunsigned char *iv;\n\tchunk_t       *cipherkey, *authkey;\n\tunsigned char *authstart;\n\tstruct state *pst = st;\n\n\tif (st->st_clonedfrom != 0)\n\t\tpst = state_with_serialno(st->st_clonedfrom);\n\n\tif (init == INITIATOR) {\n\t\tcipherkey = &pst->st_skey_er;\n\t\tauthkey   = &pst->st_skey_ar;\n\t} else {\n\t\tcipherkey = &pst->st_skey_ei;\n\t\tauthkey   = &pst->st_skey_ai;\n\t}\n\n\te_pbs = &md->chain[ISAKMP_NEXT_v2E]->pbs;\n\tnp    = md->chain[ISAKMP_NEXT_v2E]->payload.generic.isag_np;\n\n\tauthstart = md->packet_pbs.start;\n\tiv     = e_pbs->cur;\n\tencend = e_pbs->roof - pst->st_oakley.integ_hasher->hash_integ_len;\n\n\t/* start by checking authenticator */\n\t{\n\t\tunsigned char  *b12 = alloca(\n\t\t\tpst->st_oakley.integ_hasher->hash_digest_len);\n\t\tstruct hmac_ctx ctx;\n\n\t\thmac_init_chunk(&ctx, pst->st_oakley.integ_hasher, *authkey);\n\t\thmac_update(&ctx, authstart, encend - authstart);\n\t\thmac_final(b12, &ctx);\n\n\t\tDBG(DBG_PARSING, {\n\t\t\t    DBG_dump(\"data being hmac:\", authstart, encend -\n\t\t\t\t     authstart);\n\t\t\t    DBG_dump(\"R2 calculated auth:\", b12,\n\t\t\t\t     pst->st_oakley.integ_hasher->\n\t\t\t\t     hash_integ_len);\n\t\t\t    DBG_dump(\"R2  provided  auth:\", encend,\n\t\t\t\t     pst->st_oakley.integ_hasher->\n\t\t\t\t     hash_integ_len);\n\t\t    });\n\n\t\t/* compare first 96 bits == 12 bytes */\n\t\t/* It is not always 96 bytes, it depends upon which integ algo is used*/\n\t\tif (memcmp(b12, encend,\n\t\t\t   pst->st_oakley.integ_hasher->hash_integ_len) != 0) {\n\t\t\tlibreswan_log(\"R2 failed to match authenticator\");\n\t\t\treturn STF_FAIL;\n\t\t}\n\t}\n\n\tDBG(DBG_PARSING, DBG_log(\"authenticator matched\"));\n\n\t/* decrypt */\n\t{\n\t\tsize_t blocksize = pst->st_oakley.encrypter->enc_blocksize;\n\t\tunsigned char *encstart  = iv + blocksize;\n\t\tunsigned int enclen    = encend - encstart;\n\t\tunsigned int padlen;\n\n\t\tDBG(DBG_CRYPT,\n\t\t    DBG_dump(\"data before decryption:\", encstart, enclen));\n\n\t\t/* now, decrypt */\n\t\t(pst->st_oakley.encrypter->do_crypt)(encstart,\n\t\t\t\t\t\t     enclen,\n\t\t\t\t\t\t     cipherkey->ptr,\n\t\t\t\t\t\t     cipherkey->len,\n\t\t\t\t\t\t     iv, FALSE);\n\n\t\tpadlen = encstart[enclen - 1];\n\t\tencend = encend - padlen + 1;\n\n\t\tif (encend < encstart) {\n\t\t\tlibreswan_log(\"invalid pad length: %u\", padlen);\n\t\t\treturn STF_FAIL;\n\t\t}\n\n\t\tDBG(DBG_CRYPT, {\n\t\t\t    DBG_dump(\"decrypted payload:\", encstart, enclen);\n\t\t\t    DBG_log(\"striping %u bytes as pad\", padlen + 1);\n\t\t    });\n\n\t\tinit_pbs(&md->clr_pbs, encstart, enclen - (padlen + 1),\n\t\t\t \"cleartext\");\n\t}\n\n\t{\n\t\tstf_status ret;\n\t\tret =\n\t\t\tikev2_process_payloads(md, &md->clr_pbs, st->st_state,\n\t\t\t\t\t       np);\n\t\tif (ret != STF_OK)\n\t\t\treturn ret;\n\t}\n\n\treturn STF_OK;\n}\n\nstatic stf_status ikev2_send_auth(struct connection *c,\n\t\t\t\t  struct state *st,\n\t\t\t\t  enum phase1_role role,\n\t\t\t\t  unsigned int np,\n\t\t\t\t  unsigned char *idhash_out,\n\t\t\t\t  pb_stream *outpbs)\n{\n\tstruct ikev2_a a;\n\tpb_stream a_pbs;\n\tstruct state *pst = st;\n\n\tif (st->st_clonedfrom != 0)\n\t\tpst = state_with_serialno(st->st_clonedfrom);\n\n\ta.isaa_critical = ISAKMP_PAYLOAD_NONCRITICAL;\n\tif (DBGP(IMPAIR_SEND_BOGUS_ISAKMP_FLAG)) {\n\t\tlibreswan_log(\n\t\t\t\" setting bogus ISAKMP_PAYLOAD_LIBRESWAN_BOGUS flag in ISAKMP payload\");\n\t\ta.isaa_critical |= ISAKMP_PAYLOAD_LIBRESWAN_BOGUS;\n\t}\n\n\ta.isaa_np = np;\n\n\tif (c->policy & POLICY_RSASIG) {\n\t\ta.isaa_type = v2_AUTH_RSA;\n\t} else if (c->policy & POLICY_PSK) {\n\t\ta.isaa_type = v2_AUTH_SHARED;\n\t} else {\n\t\t/* what else is there?... DSS not implemented. */\n\t\treturn STF_FAIL;\n\t}\n\n\tif (!out_struct(&a,\n\t\t\t&ikev2_a_desc,\n\t\t\toutpbs,\n\t\t\t&a_pbs))\n\t\treturn STF_INTERNAL_ERROR;\n\n\tif (c->policy & POLICY_RSASIG) {\n\t\tif (!ikev2_calculate_rsa_sha1(pst, role, idhash_out, &a_pbs))\n\t\t\treturn STF_FATAL + v2N_AUTHENTICATION_FAILED;\n\n\t} else if (c->policy & POLICY_PSK) {\n\t\tif (!ikev2_calculate_psk_auth(pst, role, idhash_out, &a_pbs))\n\t\t\treturn STF_FAIL + v2N_AUTHENTICATION_FAILED;\n\t}\n\n\tclose_output_pbs(&a_pbs);\n\treturn STF_OK;\n}\n\nstatic stf_status ikev2_parent_inR1outI2_tail(\n\tstruct pluto_crypto_req_cont *pcrc,\n\tstruct pluto_crypto_req *r)\n{\n\tstruct dh_continuation *dh = (struct dh_continuation *)pcrc;\n\tstruct msg_digest *md = dh->md;\n\tstruct state *st      = md->st;\n\tstruct connection *c  = st->st_connection;\n\tstruct ikev2_generic e;\n\tunsigned char *encstart;\n\tpb_stream e_pbs, e_pbs_cipher;\n\tunsigned char *iv;\n\tint ivsize;\n\tstf_status ret;\n\tunsigned char *idhash;\n\tunsigned char *authstart;\n\tstruct state *pst = st;\n\tbool send_cert = FALSE;\n\n\tfinish_dh_v2(st, r);\n\n\tif (DBGP(DBG_PRIVATE) && DBGP(DBG_CRYPT))\n\t\tikev2_log_parentSA(st);\n\n\tpst = st;\n\tst = duplicate_state(pst);\n\tst->st_msgid = htonl(pst->st_msgid_nextuse); /* PAUL: note ordering */\n\tinsert_state(st);\n\tmd->st = st;\n\tmd->pst = pst;\n\n\t/* parent had crypto failed, replace it with rekey! */\n\tdelete_event(pst);\n\tevent_schedule(EVENT_SA_REPLACE, c->sa_ike_life_seconds, pst);\n\n\t/* need to force parent state to I2 */\n\tchange_state(pst, STATE_PARENT_I2);\n\n\t/* record first packet for later checking of signature */\n\tclonetochunk(pst->st_firstpacket_him, md->message_pbs.start,\n\t\t     pbs_offset(\n\t\t\t     &md->message_pbs), \"saved first received packet\");\n\n\t/* beginning of data going out */\n\tauthstart = reply_stream.cur;\n\n\t/* make sure HDR is at start of a clean buffer */\n\tzero(reply_buffer);\n\tinit_pbs(&reply_stream, reply_buffer, sizeof(reply_buffer),\n\t\t \"reply packet\");\n\n\t/* HDR out */\n\t{\n\t\tstruct isakmp_hdr r_hdr = md->hdr;\n\n\t\tr_hdr.isa_np    = ISAKMP_NEXT_v2E;\n\t\tr_hdr.isa_xchg  = ISAKMP_v2_AUTH;\n\t\tr_hdr.isa_flags = ISAKMP_FLAGS_I;\n\t\tr_hdr.isa_msgid = st->st_msgid;\n\t\tmemcpy(r_hdr.isa_icookie, st->st_icookie, COOKIE_SIZE);\n\t\tmemcpy(r_hdr.isa_rcookie, st->st_rcookie, COOKIE_SIZE);\n\t\tif (!out_struct(&r_hdr, &isakmp_hdr_desc, &reply_stream,\n\t\t\t\t&md->rbody))\n\t\t\treturn STF_INTERNAL_ERROR;\n\t}\n\n\t/* insert an Encryption payload header */\n\te.isag_np = ISAKMP_NEXT_v2IDi;\n\te.isag_critical = ISAKMP_PAYLOAD_NONCRITICAL;\n\tif (DBGP(IMPAIR_SEND_BOGUS_ISAKMP_FLAG)) {\n\t\tlibreswan_log(\n\t\t\t\" setting bogus ISAKMP_PAYLOAD_LIBRESWAN_BOGUS flag in ISAKMP payload\");\n\t\te.isag_critical |= ISAKMP_PAYLOAD_LIBRESWAN_BOGUS;\n\t}\n\n\tif (!out_struct(&e, &ikev2_e_desc, &md->rbody, &e_pbs))\n\t\treturn STF_INTERNAL_ERROR;\n\n\t/* insert IV */\n\tiv     = e_pbs.cur;\n\tivsize = st->st_oakley.encrypter->iv_size;\n\tif (!out_zero(ivsize, &e_pbs, \"iv\"))\n\t\treturn STF_INTERNAL_ERROR;\n\n\tget_rnd_bytes(iv, ivsize);\n\n\t/* note where cleartext starts */\n\tinit_pbs(&e_pbs_cipher, e_pbs.cur, e_pbs.roof - e_pbs.cur,\n\t\t \"cleartext\");\n\te_pbs_cipher.container = &e_pbs;\n\te_pbs_cipher.desc = NULL;\n\te_pbs_cipher.cur = e_pbs.cur;\n\tencstart = e_pbs_cipher.cur;\n\n\t/* send out the IDi payload */\n\t{\n\t\tstruct ikev2_id r_id;\n\t\tpb_stream r_id_pbs;\n\t\tchunk_t id_b;\n\t\tstruct hmac_ctx id_ctx;\n\t\tunsigned char *id_start;\n\t\tunsigned int id_len;\n\n\t\thmac_init_chunk(&id_ctx, pst->st_oakley.prf_hasher,\n\t\t\t\tpst->st_skey_pi);\n\t\tbuild_id_payload((struct isakmp_ipsec_id *)&r_id, &id_b,\n\t\t\t\t &c->spd.this);\n\t\tr_id.isai_critical = ISAKMP_PAYLOAD_NONCRITICAL;\n\t\tif (DBGP(IMPAIR_SEND_BOGUS_ISAKMP_FLAG)) {\n\t\t\tlibreswan_log(\n\t\t\t\t\" setting bogus ISAKMP_PAYLOAD_LIBRESWAN_BOGUS flag in ISAKMP payload\");\n\t\t\tr_id.isai_critical |= ISAKMP_PAYLOAD_LIBRESWAN_BOGUS;\n\t\t}\n\n\t\t{       /* decide to send CERT payload */\n\t\t\tsend_cert = doi_send_ikev2_cert_thinking(st);\n\n\t\t\tif (send_cert)\n\t\t\t\tr_id.isai_np = ISAKMP_NEXT_v2CERT;\n\t\t\telse\n\t\t\t\tr_id.isai_np = ISAKMP_NEXT_v2AUTH;\n\t\t}\n\n\t\tid_start = e_pbs_cipher.cur;\n\t\tif (!out_struct(&r_id,\n\t\t\t\t&ikev2_id_desc,\n\t\t\t\t&e_pbs_cipher,\n\t\t\t\t&r_id_pbs) ||\n\t\t    !out_chunk(id_b, &r_id_pbs, \"my identity\"))\n\t\t\treturn STF_INTERNAL_ERROR;\n\n\t\t/* HASH of ID is not done over common header */\n\t\tid_start += 4;\n\n\t\tclose_output_pbs(&r_id_pbs);\n\n\t\t/* calculate hash of IDi for AUTH below */\n\t\tid_len = e_pbs_cipher.cur - id_start;\n\t\tDBG(DBG_CRYPT, DBG_dump_chunk(\"idhash calc pi\",\n\t\t\t\t\t      pst->st_skey_pi));\n\t\tDBG(DBG_CRYPT, DBG_dump(\"idhash calc I2\", id_start, id_len));\n\t\thmac_update(&id_ctx, id_start, id_len);\n\t\tidhash = alloca(pst->st_oakley.prf_hasher->hash_digest_len);\n\t\thmac_final(idhash, &id_ctx);\n\t}\n\n\t/* send [CERT,] payload RFC 4306 3.6, 1.2) */\n\t{\n\n\t\tif (send_cert) {\n\t\t\tstf_status certstat = ikev2_send_cert( st, md,\n\t\t\t\t\t\t\t       INITIATOR,\n\t\t\t\t\t\t\t       ISAKMP_NEXT_v2AUTH,\n\t\t\t\t\t\t\t       &e_pbs_cipher);\n\t\t\tif (certstat != STF_OK)\n\t\t\t\treturn certstat;\n\t\t}\n\t}\n\n\t/* send out the AUTH payload */\n\t{\n\t\tlset_t policy;\n\t\tstruct connection *c0 = first_pending(pst, &policy,\n\t\t\t\t\t\t      &st->st_whack_sock);\n\t\tunsigned int np = (c0 ? ISAKMP_NEXT_v2SA : ISAKMP_NEXT_v2NONE);\n\t\tDBG(DBG_CONTROL,\n\t\t    DBG_log(\" payload after AUTH will be %s\",\n\t\t\t    (c0) ? \"ISAKMP_NEXT_v2SA\" :\n\t\t\t    \"ISAKMP_NEXT_v2NONE/NOTIFY\"));\n\n\t\tstf_status authstat = ikev2_send_auth(c, st,\n\t\t\t\t\t\t      INITIATOR,\n\t\t\t\t\t\t      np,\n\t\t\t\t\t\t      idhash, &e_pbs_cipher);\n\t\tif (authstat != STF_OK)\n\t\t\treturn authstat;\n\n\t\t/*\n\t\t * now, find an eligible child SA from the pending list, and emit\n\t\t * SA2i, TSi and TSr and (v2N_USE_TRANSPORT_MODE notification in transport mode) for it .\n\t\t */\n\t\tif (c0) {\n\t\t\tchunk_t child_spi, notify_data;\n\t\t\tst->st_connection = c0;\n\n\t\t\tikev2_emit_ipsec_sa(md, &e_pbs_cipher,\n\t\t\t\t\t    ISAKMP_NEXT_v2TSi, c0, policy);\n\n\t\t\tst->st_ts_this = ikev2_end_to_ts(&c0->spd.this);\n\t\t\tst->st_ts_that = ikev2_end_to_ts(&c0->spd.that);\n\n\t\t\tikev2_calc_emit_ts(md, &e_pbs_cipher, INITIATOR, c0,\n\t\t\t\t\t   policy);\n\n\t\t\tif ( !(st->st_connection->policy & POLICY_TUNNEL) ) {\n\t\t\t\tDBG_log(\n\t\t\t\t\t\"Initiator child policy is transport mode, sending v2N_USE_TRANSPORT_MODE\");\n\t\t\t\tmemset(&child_spi, 0, sizeof(child_spi));\n\t\t\t\tmemset(&notify_data, 0, sizeof(notify_data));\n\t\t\t\tship_v2N(ISAKMP_NEXT_v2NONE,\n\t\t\t\t\t ISAKMP_PAYLOAD_NONCRITICAL, 0,\n\t\t\t\t\t &child_spi,\n\t\t\t\t\t v2N_USE_TRANSPORT_MODE, &notify_data,\n\t\t\t\t\t &e_pbs_cipher);\n\t\t\t}\n\t\t} else {\n\t\t\tlibreswan_log(\n\t\t\t\t\"no pending SAs found, PARENT SA keyed only\");\n\t\t}\n\t}\n\n\t/*\n\t * need to extend the packet so that we will know how big it is\n\t * since the length is under the integrity check\n\t */\n\tikev2_padup_pre_encrypt(md, &e_pbs_cipher);\n\tclose_output_pbs(&e_pbs_cipher);\n\n\t{\n\t\tunsigned char *authloc = ikev2_authloc(md, &e_pbs);\n\n\t\tif (authloc == NULL)\n\t\t\treturn STF_INTERNAL_ERROR;\n\n\t\tclose_output_pbs(&e_pbs);\n\t\tclose_output_pbs(&md->rbody);\n\t\tclose_output_pbs(&reply_stream);\n\n\t\tret = ikev2_encrypt_msg(md, INITIATOR,\n\t\t\t\t\tauthstart,\n\t\t\t\t\tiv, encstart, authloc,\n\t\t\t\t\t&e_pbs, &e_pbs_cipher);\n\t\tif (ret != STF_OK)\n\t\t\treturn ret;\n\t}\n\n\t/* keep it for a retransmit if necessary, but on initiator\n\t * we never do that, but send_ike_msg() uses it.\n\t */\n\tfreeanychunk(pst->st_tpacket);\n\tclonetochunk(pst->st_tpacket, reply_stream.start,\n\t\t     pbs_offset(&reply_stream),\n\t\t     \"reply packet for ikev2_parent_outI1\");\n\n\t/*\n\t * Delete previous retransmission event.\n\t */\n\tdelete_event(st);\n\tevent_schedule(EVENT_v2_RETRANSMIT, EVENT_RETRANSMIT_DELAY_0, st);\n\n\treturn STF_OK;\n\n}\n\n/*\n *\n ***************************************************************\n *                       PARENT_inI2                       *****\n ***************************************************************\n *  -\n *\n *\n */\nstatic void ikev2_parent_inI2outR2_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh);\n\nstatic stf_status ikev2_parent_inI2outR2_tail(\n\tstruct pluto_crypto_req_cont *pcrc,\n\tstruct pluto_crypto_req *r);\n\nstf_status ikev2parent_inI2outR2(struct msg_digest *md)\n{\n\tstruct state *st = md->st;\n\n\t/* struct connection *c = st->st_connection; */\n\n\t/*\n\t * the initiator sent us an encrypted payload. We need to calculate\n\t * our g^xy, and skeyseed values, and then decrypt the payload.\n\t */\n\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\n\t\t    \"ikev2 parent inI2outR2: calculating g^{xy} in order to decrypt I2\"));\n\n\t/* verify that there is in fact an encrypted payload */\n\tif (!md->chain[ISAKMP_NEXT_v2E]) {\n\t\tlibreswan_log(\"R2 state should receive an encrypted payload\");\n\t\treset_globals();\n\t\treturn STF_FATAL;\n\t}\n\n\t/* now. we need to go calculate the g^xy */\n\t{\n\t\tstruct dh_continuation *dh = alloc_thing(\n\t\t\tstruct dh_continuation,\n\t\t\t\"ikev2_inI2outR2 KE\");\n\t\tstf_status e;\n\n\t\tdh->md = md;\n\t\tset_suspended(st, dh->md);\n\n\t\tpcrc_init(&dh->dh_pcrc);\n\t\tdh->dh_pcrc.pcrc_func = ikev2_parent_inI2outR2_continue;\n\t\te = start_dh_v2(&dh->dh_pcrc, st, st->st_import, RESPONDER,\n\t\t\t\tst->st_oakley.groupnum);\n\t\tif (e != STF_SUSPEND && e != STF_INLINE) {\n\t\t\tloglog(RC_CRYPTOFAILED, \"system too busy\");\n\t\t\tdelete_state(st);\n\t\t}\n\n\t\treset_globals();\n\n\t\treturn e;\n\t}\n}\n\nstatic void ikev2_parent_inI2outR2_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct dh_continuation *dh = (struct dh_continuation *)pcrc;\n\tstruct msg_digest *md = dh->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent inI2outR2: calculating g^{xy}, sending R2\"));\n\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t\treturn;\n\t}\n\n\t/* XXX should check out ugh */\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\n\tpassert(st->st_suspended_md == dh->md);\n\tset_suspended(st, NULL); /* no longer connected or suspended */\n\n\tset_cur_state(st);\n\n\tst->st_calculating = FALSE;\n\n\te = ikev2_parent_inI2outR2_tail(pcrc, r);\n\tif ( e > STF_FAIL) {\n\t\t/* we do not send a notify because we are the initiator that could be responding to an error notification */\n\t\tint v2_notify_num = e - STF_FAIL;\n\t\tDBG_log(\n\t\t\t\"ikev2_parent_inI2outR2_tail returned STF_FAIL with %s\",\n\t\t\tenum_name(&ikev2_notify_names, v2_notify_num));\n\t} else if ( e != STF_OK) {\n\t\tDBG_log(\"ikev2_parent_inI2outR2_tail returned %s\",\n\t\t\tenum_name(&stfstatus_name, e));\n\t}\n\n\tif (dh->md != NULL) {\n\t\tcomplete_v2_state_transition(&dh->md, e);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t}\n\treset_globals();\n\n\tpassert(GLOBALS_ARE_RESET());\n}\n\nstatic stf_status ikev2_parent_inI2outR2_tail(\n\tstruct pluto_crypto_req_cont *pcrc,\n\tstruct pluto_crypto_req *r)\n{\n\tstruct dh_continuation *dh = (struct dh_continuation *)pcrc;\n\tstruct msg_digest *md  = dh->md;\n\tstruct state *const st = md->st;\n\tstruct connection *c   = st->st_connection;\n\tunsigned char *idhash_in, *idhash_out;\n\tunsigned char *authstart;\n\tunsigned int np;\n\tint v2_notify_num = 0;\n\n\t/* extract calculated values from r */\n\tfinish_dh_v2(st, r);\n\n\tif (DBGP(DBG_PRIVATE) && DBGP(DBG_CRYPT))\n\t\tikev2_log_parentSA(st);\n\n\t/* decrypt things. */\n\t{\n\t\tstf_status ret;\n\t\tret = ikev2_decrypt_msg(md, RESPONDER);\n\t\tif (ret != STF_OK)\n\t\t\treturn ret;\n\t}\n\n\t/*Once the message has been decrypted, then only we can check for auth payload*/\n\t/*check the presense of auth payload now so that it does not crash in rehash_state if auth payload has not been received*/\n\tif (!md->chain[ISAKMP_NEXT_v2AUTH]) {\n\t\tlibreswan_log(\"no authentication payload found\");\n\t\treturn STF_FAIL;\n\t}\n\n\tif (!ikev2_decode_peer_id(md, RESPONDER))\n\t\treturn STF_FAIL + v2N_AUTHENTICATION_FAILED;\n\n\t{\n\t\tstruct hmac_ctx id_ctx;\n\t\tconst pb_stream *id_pbs = &md->chain[ISAKMP_NEXT_v2IDi]->pbs;\n\t\tunsigned char *idstart = id_pbs->start + 4;\n\t\tunsigned int idlen  = pbs_room(id_pbs) - 4;\n\n\t\thmac_init_chunk(&id_ctx, st->st_oakley.prf_hasher,\n\t\t\t\tst->st_skey_pi);\n\n\t\t/* calculate hash of IDi for AUTH below */\n\t\tDBG(DBG_CRYPT,\n\t\t    DBG_dump_chunk(\"idhash verify pi\", st->st_skey_pi));\n\t\tDBG(DBG_CRYPT, DBG_dump(\"idhash verify I2\", idstart, idlen));\n\t\thmac_update(&id_ctx, idstart, idlen);\n\t\tidhash_in = alloca(st->st_oakley.prf_hasher->hash_digest_len);\n\t\thmac_final(idhash_in, &id_ctx);\n\t}\n\n\t/* process CERT payload */\n\t{\n\t\tif (md->chain[ISAKMP_NEXT_v2CERT]) {\n\t\t\t/* should we check if we should accept a cert payload ?\n\t\t\t *  has_preloaded_public_key(st)\n\t\t\t */\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\n\t\t\t\t    \"has a v2_CERT payload going to process it \"));\n\t\t\tikev2_decode_cert(md);\n\t\t}\n\t}\n\n\t/* process CERTREQ payload */\n\tif (md->chain[ISAKMP_NEXT_v2CERTREQ]) {\n\t\tDBG(DBG_CONTROLMORE,\n\t\t    DBG_log(\"has a v2CERTREQ payload going to decode it\"));\n\t\tikev2_decode_cr(md, &st->st_connection->requested_ca);\n\t}\n\n\t/* process AUTH payload now */\n\t/* now check signature from RSA key */\n\tswitch (md->chain[ISAKMP_NEXT_v2AUTH]->payload.v2a.isaa_type) {\n\tcase v2_AUTH_RSA:\n\t{\n\t\tstf_status authstat = ikev2_verify_rsa_sha1(st,\n\t\t\t\t\t\t\t    RESPONDER,\n\t\t\t\t\t\t\t    idhash_in,\n\t\t\t\t\t\t\t    NULL,       /* keys from DNS */\n\t\t\t\t\t\t\t    NULL,       /* gateways from DNS */\n\t\t\t\t\t\t\t    &md->chain[\n\t\t\t\t\t\t\t\t    ISAKMP_NEXT_v2AUTH]->pbs);\n\t\tif (authstat != STF_OK) {\n\t\t\tlibreswan_log(\"RSA authentication failed\");\n\t\t\tSEND_NOTIFICATION(v2N_AUTHENTICATION_FAILED);\n\t\t\treturn STF_FATAL;\n\t\t}\n\t\tbreak;\n\t}\n\tcase v2_AUTH_SHARED:\n\t{\n\t\tstf_status authstat = ikev2_verify_psk_auth(st,\n\t\t\t\t\t\t\t    RESPONDER,\n\t\t\t\t\t\t\t    idhash_in,\n\t\t\t\t\t\t\t    &md->chain[\n\t\t\t\t\t\t\t\t    ISAKMP_NEXT_v2AUTH]->pbs);\n\t\tif (authstat != STF_OK) {\n\t\t\tlibreswan_log(\n\t\t\t\t\"PSK authentication failed AUTH mismatch!\");\n\t\t\tSEND_NOTIFICATION(v2N_AUTHENTICATION_FAILED);\n\t\t\treturn STF_FATAL;\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\tlibreswan_log(\"authentication method: %s not supported\",\n\t\t\t      enum_name(&ikev2_auth_names,\n\t\t\t\t\tmd->chain[ISAKMP_NEXT_v2AUTH]->payload.\n\t\t\t\t\tv2a.isaa_type));\n\t\treturn STF_FATAL;\n\t}\n\n\t/* Is there a notify about an error ? */\n\tif (md->chain[ISAKMP_NEXT_v2N] != NULL) {\n\t\tDBG(DBG_CONTROL,\n\t\t    DBG_log(\n\t\t\t    \" notify payload detected, should be processed....\"));\n\t}\n\n\t/* good. now create child state */\n\t/* note: as we will switch to child state, we force the parent to the\n\t * new state now */\n\tchange_state(st, STATE_PARENT_R2);\n\tc->newest_isakmp_sa = st->st_serialno;\n\n\tdelete_event(st);\n\tevent_schedule(EVENT_SA_REPLACE, c->sa_ike_life_seconds, st);\n\n\tauthstart = reply_stream.cur;\n\t/* send response */\n\t{\n\t\tunsigned char *encstart;\n\t\tunsigned char *iv;\n\t\tunsigned int ivsize;\n\t\tstruct ikev2_generic e;\n\t\tpb_stream e_pbs, e_pbs_cipher;\n\t\tstf_status ret;\n\t\tbool send_cert = FALSE;\n\n\t\t/* make sure HDR is at start of a clean buffer */\n\t\tzero(reply_buffer);\n\t\tinit_pbs(&reply_stream, reply_buffer, sizeof(reply_buffer),\n\t\t\t \"reply packet\");\n\n\t\t/* HDR out */\n\t\t{\n\t\t\tstruct isakmp_hdr r_hdr = md->hdr;\n\n\t\t\tr_hdr.isa_np    = ISAKMP_NEXT_v2E;\n\t\t\tr_hdr.isa_xchg  = ISAKMP_v2_AUTH;\n\t\t\tr_hdr.isa_flags = ISAKMP_FLAGS_R;\n\t\t\tmemcpy(r_hdr.isa_icookie, st->st_icookie, COOKIE_SIZE);\n\t\t\tmemcpy(r_hdr.isa_rcookie, st->st_rcookie, COOKIE_SIZE);\n\t\t\tif (!out_struct(&r_hdr, &isakmp_hdr_desc,\n\t\t\t\t\t&reply_stream, &md->rbody))\n\t\t\t\treturn STF_INTERNAL_ERROR;\n\t\t}\n\n\t\t/* insert an Encryption payload header */\n\t\te.isag_np = ISAKMP_NEXT_v2IDr;\n\t\te.isag_critical = ISAKMP_PAYLOAD_NONCRITICAL;\n\n\t\tif (!out_struct(&e, &ikev2_e_desc, &md->rbody, &e_pbs))\n\t\t\treturn STF_INTERNAL_ERROR;\n\n\t\t/* insert IV */\n\t\tiv     = e_pbs.cur;\n\t\tivsize = st->st_oakley.encrypter->iv_size;\n\t\tif (!out_zero(ivsize, &e_pbs, \"iv\"))\n\t\t\treturn STF_INTERNAL_ERROR;\n\n\t\tget_rnd_bytes(iv, ivsize);\n\n\t\t/* note where cleartext starts */\n\t\tinit_pbs(&e_pbs_cipher, e_pbs.cur, e_pbs.roof - e_pbs.cur,\n\t\t\t \"cleartext\");\n\t\te_pbs_cipher.container = &e_pbs;\n\t\te_pbs_cipher.desc = NULL;\n\t\te_pbs_cipher.cur = e_pbs.cur;\n\t\tencstart = e_pbs_cipher.cur;\n\n\t\t/* decide to send CERT payload before we generate IDr */\n\t\tsend_cert = doi_send_ikev2_cert_thinking(st);\n\n\t\t/* send out the IDr payload */\n\t\t{\n\t\t\tstruct ikev2_id r_id;\n\t\t\tpb_stream r_id_pbs;\n\t\t\tchunk_t id_b;\n\t\t\tstruct hmac_ctx id_ctx;\n\t\t\tunsigned char *id_start;\n\t\t\tunsigned int id_len;\n\n\t\t\thmac_init_chunk(&id_ctx, st->st_oakley.prf_hasher,\n\t\t\t\t\tst->st_skey_pr);\n\t\t\tbuild_id_payload((struct isakmp_ipsec_id *)&r_id,\n\t\t\t\t\t &id_b,\n\t\t\t\t\t &c->spd.this);\n\t\t\tr_id.isai_critical = ISAKMP_PAYLOAD_NONCRITICAL;\n\n\t\t\tif (send_cert)\n\t\t\t\tr_id.isai_np = ISAKMP_NEXT_v2CERT;\n\t\t\telse\n\t\t\t\tr_id.isai_np = ISAKMP_NEXT_v2AUTH;\n\n\t\t\tid_start = e_pbs_cipher.cur;\n\n\t\t\tif (!out_struct(&r_id,\n\t\t\t\t\t&ikev2_id_desc,\n\t\t\t\t\t&e_pbs_cipher,\n\t\t\t\t\t&r_id_pbs) ||\n\t\t\t    !out_chunk(id_b, &r_id_pbs, \"my identity\"))\n\t\t\t\treturn STF_INTERNAL_ERROR;\n\n\t\t\tclose_output_pbs(&r_id_pbs);\n\n\t\t\tid_start += 4;\n\n\t\t\t/* calculate hash of IDi for AUTH below */\n\t\t\tid_len = e_pbs_cipher.cur - id_start;\n\t\t\tDBG(DBG_CRYPT,\n\t\t\t    DBG_dump_chunk(\"idhash calc pr\", st->st_skey_pr));\n\t\t\tDBG(DBG_CRYPT,\n\t\t\t    DBG_dump(\"idhash calc R2\", id_start, id_len));\n\t\t\thmac_update(&id_ctx, id_start, id_len);\n\t\t\tidhash_out = alloca(\n\t\t\t\tst->st_oakley.prf_hasher->hash_digest_len);\n\t\t\thmac_final(idhash_out, &id_ctx);\n\t\t}\n\n\t\tDBG(DBG_CONTROLMORE,\n\t\t    DBG_log(\"assembled IDr payload -- CERT next\"));\n\n\t\t/* send CERT payload RFC 4306 3.6, 1.2:([CERT,] ) */\n\t\tif (send_cert) {\n\t\t\tstf_status certstat = ikev2_send_cert(st, md,\n\t\t\t\t\t\t\t      RESPONDER,\n\t\t\t\t\t\t\t      ISAKMP_NEXT_v2AUTH,\n\t\t\t\t\t\t\t      &e_pbs_cipher);\n\t\t\tif (certstat != STF_OK)\n\t\t\t\treturn certstat;\n\t\t}\n\n\t\t/* authentication good, see if there is a child SA being proposed */\n\t\tif (md->chain[ISAKMP_NEXT_v2SA] == NULL ||\n\t\t    md->chain[ISAKMP_NEXT_v2TSi] == NULL ||\n\t\t    md->chain[ISAKMP_NEXT_v2TSr] == NULL) {\n\n\t\t\t/* initiator didn't propose anything. Weird. Try unpending out end. */\n\t\t\t/* UNPEND XXX */\n\t\t\tlibreswan_log(\"No CHILD SA proposals received.\");\n\t\t\tnp = ISAKMP_NEXT_v2NONE;\n\t\t} else {\n\t\t\tDBG_log(\"CHILD SA proposals received\");\n\t\t\tlibreswan_log(\n\t\t\t\t\"PAUL: this is where we have to check the TSi/TSr\");\n\t\t\tnp = ISAKMP_NEXT_v2SA;\n\t\t}\n\n\t\tDBG(DBG_CONTROLMORE,\n\t\t    DBG_log(\"going to assemble AUTH payload\"));\n\n\t\t/* now send AUTH payload */\n\t\t{\n\t\t\tstf_status authstat = ikev2_send_auth(c, st,\n\t\t\t\t\t\t\t      RESPONDER, np,\n\t\t\t\t\t\t\t      idhash_out,\n\t\t\t\t\t\t\t      &e_pbs_cipher);\n\t\t\tif (authstat != STF_OK)\n\t\t\t\treturn authstat;\n\t\t}\n\n\t\tif (np == ISAKMP_NEXT_v2SA) {\n\t\t\t/* must have enough to build an CHILD_SA */\n\t\t\tret = ikev2_child_sa_respond(md, RESPONDER,\n\t\t\t\t\t\t     &e_pbs_cipher);\n\t\t\tif (ret > STF_FAIL) {\n\t\t\t\tv2_notify_num = ret - STF_FAIL;\n\t\t\t\tDBG(DBG_CONTROL,\n\t\t\t\t    DBG_log(\n\t\t\t\t\t    \"ikev2_child_sa_respond returned STF_FAIL with %s\",\n\t\t\t\t\t    enum_name(&ikev2_notify_names,\n\t\t\t\t\t\t      v2_notify_num)));\n\t\t\t\tnp = ISAKMP_NEXT_v2NONE;\n\t\t\t} else if (ret != STF_OK) {\n\t\t\t\tDBG_log(\"ikev2_child_sa_respond returned %s\", enum_name(\n\t\t\t\t\t\t&stfstatus_name,\n\t\t\t\t\t\tret));\n\t\t\t\tnp = ISAKMP_NEXT_v2NONE;\n\t\t\t}\n\t\t}\n\n\t\tikev2_padup_pre_encrypt(md, &e_pbs_cipher);\n\t\tclose_output_pbs(&e_pbs_cipher);\n\n\t\t{\n\t\t\tunsigned char *authloc = ikev2_authloc(md, &e_pbs);\n\n\t\t\tif (authloc == NULL)\n\t\t\t\treturn STF_INTERNAL_ERROR;\n\n\t\t\tclose_output_pbs(&e_pbs);\n\n\t\t\tclose_output_pbs(&md->rbody);\n\t\t\tclose_output_pbs(&reply_stream);\n\n\t\t\tret = ikev2_encrypt_msg(md, RESPONDER,\n\t\t\t\t\t\tauthstart,\n\t\t\t\t\t\tiv, encstart, authloc,\n\t\t\t\t\t\t&e_pbs, &e_pbs_cipher);\n\t\t\tif (ret != STF_OK)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* keep it for a retransmit if necessary */\n\tfreeanychunk(st->st_tpacket);\n\tclonetochunk(st->st_tpacket, reply_stream.start,\n\t\t     pbs_offset(&reply_stream),\n\t\t     \"reply packet for ikev2_parent_inI2outR2_tail\");\n\n\t/* note: retransimission is driven by initiator */\n\n\t/* if the child failed, delete its state here - we sent the packet */\n\t/* PAUL */\n\treturn STF_OK;\n\n}\n\n/*\n *\n ***************************************************************\n *                       PARENT_inR2    (I3 state)         *****\n ***************************************************************\n *  - there are no cryptographic continuations, but be certain\n *    that there will have to be DNS continuations, but they\n *    just aren't implemented yet.\n *\n */\nstf_status ikev2parent_inR2(struct msg_digest *md)\n{\n\tstruct state *st = md->st;\n\tstruct connection *c = st->st_connection;\n\tunsigned char *idhash_in;\n\tstruct state *pst = st;\n\n\tif (st->st_clonedfrom != 0)\n\t\tpst = state_with_serialno(st->st_clonedfrom);\n\n\t/*\n\t * the initiator sent us an encrypted payload. We need to calculate\n\t * our g^xy, and skeyseed values, and then decrypt the payload.\n\t */\n\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\n\t\t    \"ikev2 parent inR2: calculating g^{xy} in order to decrypt I2\"));\n\n\t/* verify that there is in fact an encrypted payload */\n\tif (!md->chain[ISAKMP_NEXT_v2E]) {\n\t\tlibreswan_log(\"R2 state should receive an encrypted payload\");\n\t\treturn STF_FATAL;\n\t}\n\n\t/* decrypt things. */\n\t{\n\t\tstf_status ret;\n\t\tret = ikev2_decrypt_msg(md, INITIATOR);\n\t\tif (ret != STF_OK)\n\t\t\treturn ret;\n\t}\n\n\tif (!ikev2_decode_peer_id(md, INITIATOR))\n\t\treturn STF_FAIL + v2N_AUTHENTICATION_FAILED;\n\n\t{\n\t\tstruct hmac_ctx id_ctx;\n\t\tconst pb_stream *id_pbs = &md->chain[ISAKMP_NEXT_v2IDr]->pbs;\n\t\tunsigned char *idstart = id_pbs->start + 4;\n\t\tunsigned int idlen  = pbs_room(id_pbs) - 4;\n\n\t\thmac_init_chunk(&id_ctx, pst->st_oakley.prf_hasher,\n\t\t\t\tpst->st_skey_pr);\n\n\t\t/* calculate hash of IDr for AUTH below */\n\t\tDBG(DBG_CRYPT,\n\t\t    DBG_dump_chunk(\"idhash verify pr\", pst->st_skey_pr));\n\t\tDBG(DBG_CRYPT, DBG_dump(\"idhash auth R2\", idstart, idlen));\n\t\thmac_update(&id_ctx, idstart, idlen);\n\t\tidhash_in = alloca(pst->st_oakley.prf_hasher->hash_digest_len);\n\t\thmac_final(idhash_in, &id_ctx);\n\t}\n\n\tif (md->chain[ISAKMP_NEXT_v2CERT]) {\n\t\t/* should we check if we should accept a cert payload ?\n\t\t *  has_preloaded_public_key(st)\n\t\t */\n\t\t/* in v1 code it is  decode_cert(struct msg_digest *md) */\n\t\tDBG(DBG_CONTROLMORE,\n\t\t    DBG_log(\"has a v2_CERT payload going to decode it\"));\n\t\tikev2_decode_cert(md);\n\t}\n\n\t/* process AUTH payload */\n\tif (!md->chain[ISAKMP_NEXT_v2AUTH]) {\n\t\tlibreswan_log(\"no authentication payload found\");\n\t\treturn STF_FAIL;\n\t}\n\n\t/* now check signature from RSA key */\n\tswitch (md->chain[ISAKMP_NEXT_v2AUTH]->payload.v2a.isaa_type) {\n\tcase v2_AUTH_RSA:\n\t{\n\t\tstf_status authstat = ikev2_verify_rsa_sha1(pst,\n\t\t\t\t\t\t\t    INITIATOR,\n\t\t\t\t\t\t\t    idhash_in,\n\t\t\t\t\t\t\t    NULL,       /* keys from DNS */\n\t\t\t\t\t\t\t    NULL,       /* gateways from DNS */\n\t\t\t\t\t\t\t    &md->chain[\n\t\t\t\t\t\t\t\t    ISAKMP_NEXT_v2AUTH]->pbs);\n\t\tif (authstat != STF_OK) {\n\t\t\tlibreswan_log(\"authentication failed\");\n\t\t\tSEND_NOTIFICATION(v2N_AUTHENTICATION_FAILED);\n\t\t\treturn STF_FAIL;\n\t\t}\n\t\tbreak;\n\t}\n\tcase v2_AUTH_SHARED:\n\t{\n\t\tstf_status authstat = ikev2_verify_psk_auth(pst,\n\t\t\t\t\t\t\t    INITIATOR,\n\t\t\t\t\t\t\t    idhash_in,\n\t\t\t\t\t\t\t    &md->chain[\n\t\t\t\t\t\t\t\t    ISAKMP_NEXT_v2AUTH]->pbs);\n\t\tif (authstat != STF_OK) {\n\t\t\tlibreswan_log(\"PSK authentication failed\");\n\t\t\tSEND_NOTIFICATION(v2N_AUTHENTICATION_FAILED);\n\t\t\treturn STF_FAIL;\n\t\t}\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tlibreswan_log(\"authentication method: %s not supported\",\n\t\t\t      enum_name(&ikev2_auth_names,\n\t\t\t\t\tmd->chain[ISAKMP_NEXT_v2AUTH]->payload.\n\t\t\t\t\tv2a.isaa_type));\n\t\treturn STF_FAIL;\n\t}\n\n\t/*\n\t * update the parent state to make sure that it knows we have\n\t * authenticated properly.\n\t */\n\tchange_state(pst, STATE_PARENT_I3);\n\tc->newest_isakmp_sa = pst->st_serialno;\n\n\t/* authentication good, see if there is a child SA available */\n\tif (md->chain[ISAKMP_NEXT_v2SA] == NULL ||\n\t    md->chain[ISAKMP_NEXT_v2TSi] == NULL ||\n\t    md->chain[ISAKMP_NEXT_v2TSr] == NULL) {\n\t\t/* not really anything to here... but it would be worth unpending again */\n\t\tDBG(DBG_CONTROLMORE,\n\t\t    DBG_log(\n\t\t\t    \"no v2SA, v2TSi or v2TSr received, not attempting to setup child SA\"));\n\t\tDBG(DBG_CONTROLMORE,\n\t\t    DBG_log(\"  Should we check for some notify?\"));\n\t\t/*\n\t\t * Delete previous retransmission event.\n\t\t */\n\t\tdelete_event(st);\n\t\treturn STF_OK;\n\t}\n\n\t{\n\t\tint bestfit_n, bestfit_p, bestfit_pr;\n\t\tunsigned int best_tsi_i,  best_tsr_i;\n\t\tbestfit_n = -1;\n\t\tbestfit_p = -1;\n\t\tbestfit_pr = -1;\n\n\t\t/* Check TSi/TSr http://tools.ietf.org/html/rfc5996#section-2.9 */\n\t\tDBG(DBG_CONTROLMORE,\n\t\t    DBG_log(\" check narrowing - we are responding to I2\"));\n\n\t\tstruct payload_digest *const tsi_pd =\n\t\t\tmd->chain[ISAKMP_NEXT_v2TSi];\n\t\tstruct payload_digest *const tsr_pd =\n\t\t\tmd->chain[ISAKMP_NEXT_v2TSr];\n\t\tstruct traffic_selector tsi[16], tsr[16];\n#if 0\n\t\tbool instantiate = FALSE;\n\t\tip_subnet tsi_subnet, tsr_subnet;\n\t\tconst char *oops;\n#endif\n\n\t\tunsigned int tsi_n, tsr_n;\n\t\ttsi_n = ikev2_parse_ts(tsi_pd, tsi, 16);\n\t\ttsr_n = ikev2_parse_ts(tsr_pd, tsr, 16);\n\n\t\tDBG_log(\n\t\t\t\"Checking TSi(%d)/TSr(%d) selectors, looking for exact match\", tsi_n,\n\t\t\ttsr_n);\n\t\t{\n\t\t\tstruct spd_route *sra;\n\t\t\tsra = &c->spd;\n\t\t\tint bfit_n = ikev2_evaluate_connection_fit(c, sra,\n\t\t\t\t\t\t\t\t   INITIATOR,\n\t\t\t\t\t\t\t\t   tsi, tsr,\n\t\t\t\t\t\t\t\t   tsi_n,\n\t\t\t\t\t\t\t\t   tsr_n);\n\t\t\tif (bfit_n > bestfit_n) {\n\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t    DBG_log(\n\t\t\t\t\t    \"bfit_n=ikev2_evaluate_connection_fit found better fit c %s\",\n\t\t\t\t\t    c->name));\n\t\t\t\tint bfit_p =\n\t\t\t\t\tikev2_evaluate_connection_port_fit(c,\n\t\t\t\t\t\t\t\t\t   sra,\n\t\t\t\t\t\t\t\t\t   INITIATOR,\n\t\t\t\t\t\t\t\t\t   tsi, tsr,\n\t\t\t\t\t\t\t\t\t   tsi_n, tsr_n, &best_tsi_i,\n\t\t\t\t\t\t\t\t\t   &best_tsr_i);\n\t\t\t\tif (bfit_p > bestfit_p) {\n\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t    DBG_log(\n\t\t\t\t\t\t    \"ikev2_evaluate_connection_port_fit found better fit c %s, tsi[%d],tsr[%d]\",\n\t\t\t\t\t\t    c->name,\n\t\t\t\t\t\t    best_tsi_i, best_tsr_i));\n\t\t\t\t\tint bfit_pr =\n\t\t\t\t\t\tikev2_evaluate_connection_protocol_fit(\n\t\t\t\t\t\t\tc, sra, INITIATOR, tsi,\n\t\t\t\t\t\t\ttsr,\n\t\t\t\t\t\t\ttsi_n, tsr_n,\n\t\t\t\t\t\t\t&best_tsi_i,\n\t\t\t\t\t\t\t&best_tsr_i);\n\t\t\t\t\tif (bfit_pr > bestfit_pr ) {\n\t\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t\t    DBG_log(\n\t\t\t\t\t\t\t    \"ikev2_evaluate_connection_protocol_fit found better fit c %s, tsi[%d],tsr[%d]\",\n\t\t\t\t\t\t\t    c\n\t\t\t\t\t\t\t    ->name, best_tsi_i,\n\t\t\t\t\t\t\t    best_tsr_i));\n\t\t\t\t\t\tbestfit_p = bfit_p;\n\t\t\t\t\t\tbestfit_n = bfit_n;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t\t    DBG_log(\n\t\t\t\t\t\t\t    \"protocol range fit c %s c->name was rejected by protocol matching\",\n\t\t\t\t\t\t\t    c\n\t\t\t\t\t\t\t    ->name));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t    DBG_log(\n\t\t\t\t\t    \"prefix range fit c %s c->name was rejected by port matching\",\n\t\t\t\t\t    c->name));\n\t\t\t}\n\t\t}\n\n\t\tif ( ( bestfit_n > 0 )  && (bestfit_p > 0)) {\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\n\t\t\t\t    (\n\t\t\t\t\t    \"found an acceptable TSi/TSr Traffic Selector\")));\n\t\t\tmemcpy(&st->st_ts_this, &tsi[best_tsi_i],\n\t\t\t       sizeof(struct traffic_selector));\n\t\t\tmemcpy(&st->st_ts_that, &tsr[best_tsr_i],\n\t\t\t       sizeof(struct traffic_selector));\n\t\t\tikev2_print_ts(&st->st_ts_this);\n\t\t\tikev2_print_ts(&st->st_ts_that);\n\n\t\t\tip_subnet tmp_subnet_i;\n\t\t\tip_subnet tmp_subnet_r;\n\t\t\trangetosubnet(&st->st_ts_this.low,\n\t\t\t\t      &st->st_ts_this.high, &tmp_subnet_i);\n\t\t\trangetosubnet(&st->st_ts_that.low,\n\t\t\t\t      &st->st_ts_that.high, &tmp_subnet_r);\n\n\t\t\tc->spd.this.client = tmp_subnet_i;\n\t\t\tc->spd.this.port  = st->st_ts_this.startport;\n\t\t\tc->spd.this.protocol  = st->st_ts_this.ipprotoid;\n\t\t\tsetportof(htons(\n\t\t\t\t\t  c->spd.this.port),\n\t\t\t\t  &c->spd.this.host_addr);\n\t\t\tsetportof(htons(\n\t\t\t\t\t  c->spd.this.port),\n\t\t\t\t  &c->spd.this.client.addr);\n\n\t\t\tif ( subnetishost(&c->spd.this.client) &&\n\t\t\t     addrinsubnet(&c->spd.this.host_addr,\n\t\t\t\t\t  &c->spd.this.client))\n\t\t\t\tc->spd.this.has_client = FALSE;\n\t\t\telse\n\t\t\t\tc->spd.this.has_client = TRUE;\n\n\t\t\tc->spd.that.client = tmp_subnet_r;\n\t\t\tc->spd.that.port = st->st_ts_that.startport;\n\t\t\tc->spd.that.protocol = st->st_ts_that.ipprotoid;\n\t\t\tsetportof(htons(\n\t\t\t\t\t  c->spd.that.port),\n\t\t\t\t  &c->spd.that.host_addr);\n\t\t\tsetportof(htons(\n\t\t\t\t\t  c->spd.that.port),\n\t\t\t\t  &c->spd.that.client.addr);\n\n\t\t\tif ( subnetishost(&c->spd.that.client) &&\n\t\t\t     addrinsubnet(&c->spd.that.host_addr,\n\t\t\t\t\t  &c->spd.that.client))\n\t\t\t\tc->spd.that.has_client = FALSE;\n\t\t\telse\n\t\t\t\tc->spd.that.has_client = TRUE;\n\t\t\t/* AAAA */\n\t\t} else {\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log((\n\t\t\t\t\t    \"reject responder TSi/TSr Traffic Selector\")));\n\t\t\t/* prevents parent from going to I3 */\n\t\t\treturn STF_FAIL + v2N_TS_UNACCEPTABLE;\n\t\t}\n\t} /* end of TS check block */\n\n\t{\n\t\tv2_notification_t rn;\n\t\tstruct payload_digest *const sa_pd =\n\t\t\tmd->chain[ISAKMP_NEXT_v2SA];\n\n\t\trn = ikev2_parse_child_sa_body(&sa_pd->pbs,\n\t\t\t\t\t       &sa_pd->payload.v2sa,\n\t\t\t\t\t       NULL, st, FALSE);\n\n\t\tif (rn != v2N_NOTHING_WRONG)\n\t\t\treturn STF_FAIL + rn;\n\t}\n\n\t{\n\t\tstruct payload_digest *p;\n\n\t\tfor (p = md->chain[ISAKMP_NEXT_v2N]; p != NULL; p = p->next) {\n\t\t\t/* RFC 5996 */\n\t\t\t/*Types in the range 0 - 16383 are intended for reporting errors.  An\n\t\t\t * implementation receiving a Notify payload with one of these types\n\t\t\t * that it does not recognize in a response MUST assume that the\n\t\t\t * corresponding request has failed entirely.  Unrecognized error types\n\t\t\t * in a request and status types in a request or response MUST be\n\t\t\t * ignored, and they should be logged.*/\n\n\t\t\tif (enum_name(&ikev2_notify_names,\n\t\t\t\t      p->payload.v2n.isan_type) == NULL) {\n\t\t\t\tif (p->payload.v2n.isan_type <\n\t\t\t\t    v2N_INITIAL_CONTACT)\n\t\t\t\t\treturn STF_FAIL +\n\t\t\t\t\t       p->payload.v2n.isan_type;\n\t\t\t}\n\n\t\t\tif ( p->payload.v2n.isan_type ==\n\t\t\t     v2N_USE_TRANSPORT_MODE ) {\n\t\t\t\tif ( st->st_connection->policy &\n\t\t\t\t     POLICY_TUNNEL) {\n\t\t\t\t\t/*This means we did not send v2N_USE_TRANSPORT, however responder is sending it in now (inR2), seems incorrect*/\n\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t    DBG_log(\n\t\t\t\t\t\t    \"Initiator policy is tunnel, responder sends v2N_USE_TRANSPORT_MODE notification in inR2, ignoring it\"));\n\t\t\t\t} else {\n\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t    DBG_log(\n\t\t\t\t\t\t    \"Initiator policy is transport, responder sends v2N_USE_TRANSPORT_MODE, setting CHILD SA to transport mode\"));\n\t\t\t\t\tif (st->st_esp.present == TRUE) {\n\t\t\t\t\t\t/*libreswan supports only \"esp\" with ikev2 it seems, look at ikev2_parse_child_sa_body handling*/\n\t\t\t\t\t\tst->st_esp.attrs.encapsulation\n\t\t\t\t\t\t\t=\n\t\t\t\t\t\t\t\tENCAPSULATION_MODE_TRANSPORT;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}       /* for */\n\n\t}               /* notification block */\n\n\tikev2_derive_child_keys(st, md->role);\n\n\tc->newest_ipsec_sa = st->st_serialno;\n\n\t/* now install child SAs */\n\tif (!install_ipsec_sa(st, TRUE))\n\t\treturn STF_FATAL;\n\n\t/*\n\t * Delete previous retransmission event.\n\t */\n\tdelete_event(st);\n\n\treturn STF_OK;\n}\n\n/*\n * Cookie = <VersionIDofSecret> | Hash(Ni | IPi | SPIi | <secret>)\n * where <secret> is a randomly generated secret known only to the\n * in LSW implementation <VersionIDofSecret> is not used.\n */\nstatic bool ikev2_get_dcookie(u_char *dcookie,  chunk_t st_ni,\n\t\t\t      ip_address *addr, u_int8_t *spiI)\n{\n\tsize_t addr_length;\n\tSHA1_CTX ctx_sha1;\n\tunsigned char addr_buff[\n\t\tsizeof(union { struct in_addr A;\n\t\t\t       struct in6_addr B;\n\t\t       })];\n\n\taddr_length = addrbytesof(addr, addr_buff, sizeof(addr_buff));\n\tSHA1Init(&ctx_sha1);\n\tSHA1Update(&ctx_sha1, st_ni.ptr, st_ni.len);\n\tSHA1Update(&ctx_sha1, addr_buff, addr_length);\n\tSHA1Update(&ctx_sha1, spiI, sizeof(*spiI));\n\tSHA1Update(&ctx_sha1, ikev2_secret_of_the_day,\n\t\t   SHA1_DIGEST_SIZE);\n\tSHA1Final(dcookie, &ctx_sha1);\n\tDBG(DBG_PRIVATE,\n\t    DBG_log(\"ikev2 secret_of_the_day used %s, length %d\",\n\t\t    ikev2_secret_of_the_day,\n\t\t    SHA1_DIGEST_SIZE);\n\t    );\n\n\tDBG(DBG_CRYPT,\n\t    DBG_dump(\"computed dcookie: HASH(Ni | IPi | SPIi | <secret>)\",\n\t\t     dcookie, SHA1_DIGEST_SIZE));\n#if 0\n\tikev2_secrets_recycle++;\n\tif (ikev2_secrets_recycle >= 32768) {\n\t\t/* handed out too many cookies, cycle secrets */\n\t\tikev2_secrets_recycle = 0;\n\t\t/* can we call init_secrets() without adding an EVENT? */\n\t\tinit_secrets();\n\t}\n#endif\n\treturn TRUE;\n}\n\n/*\n *\n ***************************************************************\n *                       NOTIFICATION_OUT Complete packet  *****\n ***************************************************************\n *\n */\n\nvoid send_v2_notification(struct state *p1st, u_int16_t type,\n\t\t\t  struct state *encst,\n\t\t\t  u_char *icookie,\n\t\t\t  u_char *rcookie,\n\t\t\t  chunk_t *n_data)\n{\n\tu_char buffer[1024];\n\tpb_stream reply;\n\tpb_stream rbody;\n\tchunk_t child_spi, notify_data;\n\n\t/* this function is not generic enough yet just enough for 6msg\n\t * TBD accept HDR FLAGS as arg. default ISAKMP_FLAGS_R\n\t * TBD when there is a child SA use that SPI in the notify paylod.\n\t * TBD support encrypted notifications payloads.\n\t * TBD accept Critical bit as an argument. default is set.\n\t * TBD accept exchange type as an arg, default is ISAKMP_v2_SA_INIT\n\t * do we need to send a notify with empty data?\n\t * do we need to support more Protocol ID? more than PROTO_ISAKMP\n\t */\n\n\tlibreswan_log(\"sending %s notification %s to %s:%u\",\n\t\t      encst ? \"encrypted \" : \"\",\n\t\t      enum_name(&ikev2_notify_names, type),\n\t\t      ip_str(&p1st->st_remoteaddr),\n\t\t      p1st->st_remoteport);\n#if 0\n/* Empty notification data section should be fine? */\n\tif (n_data == NULL) {\n\t\tDBG(DBG_CONTROLMORE,\n\t\t    DBG_log(\"don't send packet when notification data empty\"));\n\t\treturn;\n\t}\n#endif\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tinit_pbs(&reply, buffer, sizeof(buffer), \"notification msg\");\n\n\t/* HDR out */\n\t{\n\t\tstruct isakmp_hdr n_hdr;\n\t\tzero(&n_hdr);                           /* default to 0 */  /* AAA should we copy from MD? */\n\t\t/* Impair function will raise major/minor by 1 for testing */\n\t\tn_hdr.isa_version = build_ike_version();\n\t\tmemcpy(n_hdr.isa_rcookie, rcookie, COOKIE_SIZE);\n\t\tmemcpy(n_hdr.isa_icookie, icookie, COOKIE_SIZE);\n\t\tn_hdr.isa_xchg = ISAKMP_v2_SA_INIT;\n\t\tn_hdr.isa_np = ISAKMP_NEXT_v2N;\n\t\tn_hdr.isa_flags &= ~ISAKMP_FLAGS_I;\n\t\tn_hdr.isa_flags  |=  ISAKMP_FLAGS_R;\n#warning check msgid code here\n\t\t/* PAUL: shouldn't we set n_hdr.isa_msgid = [htonl](p1st->st_msgid); */\n\t\tif (!out_struct(&n_hdr, &isakmp_hdr_desc, &reply, &rbody)) {\n\t\t\tlibreswan_log(\n\t\t\t\t\"error initializing hdr for notify message\");\n\t\t\treturn;\n\t\t}\n\n\t}\n\tchild_spi.ptr = NULL;\n\tchild_spi.len = 0;\n\n\t/* build and add v2N payload to the packet */\n\tmemset(&child_spi, 0, sizeof(child_spi));\n\tmemset(&notify_data, 0, sizeof(notify_data));\n\tship_v2N(ISAKMP_NEXT_v2NONE, DBGP(\n\t\t\t IMPAIR_SEND_BOGUS_ISAKMP_FLAG) ?\n\t\t (ISAKMP_PAYLOAD_NONCRITICAL | ISAKMP_PAYLOAD_LIBRESWAN_BOGUS) :\n\t\t ISAKMP_PAYLOAD_NONCRITICAL, PROTO_ISAKMP,\n\t\t &child_spi,\n\t\t type, n_data, &rbody);\n\n\tclose_message(&rbody, p1st);\n\tclose_output_pbs(&reply);\n\n\tclonetochunk(p1st->st_tpacket, reply.start, pbs_offset(&reply),\n\t\t     \"notification packet\");\n\n\tsend_ike_msg(p1st, __FUNCTION__);\n}\n/* add notify payload to the rbody */\nbool ship_v2N(unsigned int np, u_int8_t critical,\n\t      u_int8_t protoid, chunk_t *spi,\n\t      u_int16_t type, chunk_t *n_data, pb_stream *rbody)\n{\n\tstruct ikev2_notify n;\n\tpb_stream n_pbs;\n\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"Adding a v2N Payload\"));\n\tn.isan_np =  np;\n\tn.isan_critical = critical;\n\tif (DBGP(IMPAIR_SEND_BOGUS_ISAKMP_FLAG)) {\n\t\tlibreswan_log(\n\t\t\t\" setting bogus ISAKMP_PAYLOAD_LIBRESWAN_BOGUS flag in ISAKMP payload\");\n\t\tn.isan_critical |= ISAKMP_PAYLOAD_LIBRESWAN_BOGUS;\n\t}\n\n\tn.isan_protoid =  protoid;\n\tn.isan_spisize = spi->len;\n\tn.isan_type = type;\n\n\tif (!out_struct(&n, &ikev2_notify_desc, rbody, &n_pbs)) {\n\t\tlibreswan_log(\n\t\t\t\"error initializing notify payload for notify message\");\n\t\treturn FALSE;\n\t}\n\n\tif (spi->len > 0) {\n\t\tif (!out_raw(spi->ptr, spi->len, &n_pbs, \"SPI \")) {\n\t\t\tlibreswan_log(\"error writing SPI to notify payload\");\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\tif (n_data != NULL) {\n\t\tif (!out_raw(n_data->ptr, n_data->len, &n_pbs,\n\t\t\t     \"Notify data\")) {\n\t\t\tlibreswan_log(\n\t\t\t\t\"error writing notify payload for notify message\");\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tclose_output_pbs(&n_pbs);\n\treturn TRUE;\n}\n\n/*\n *\n ***************************************************************\n *                       INFORMATIONAL                     *****\n ***************************************************************\n *  -\n *\n *\n */\nstf_status process_informational_ikev2(struct msg_digest *md)\n{\n\t/* verify that there is in fact an encrypted payload */\n\tif (!md->chain[ISAKMP_NEXT_v2E]) {\n\t\tlibreswan_log(\n\t\t\t\"Ignoring informational exchange outside encrypted payload (rfc5996 section 1.4)\");\n\t\treturn STF_IGNORE;\n\t}\n\n\t/* decrypt things. */\n\t{\n\t\tstf_status ret;\n\n\t\tif (md->hdr.isa_flags & ISAKMP_FLAGS_I) {\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\n\t\t\t\t    \"received informational exchange request from INITIATOR\"));\n\t\t\tret = ikev2_decrypt_msg(md, RESPONDER);\n\t\t} else {\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\n\t\t\t\t    \"received informational exchange request from RESPONDER\"));\n\t\t\tret = ikev2_decrypt_msg(md, INITIATOR);\n\t\t}\n\n\t\tif (ret != STF_OK)\n\t\t\treturn ret;\n\t}\n\n\t{\n\t\tstruct payload_digest *p;\n\t\tstruct ikev2_delete *v2del = NULL;\n\t\tstf_status ret;\n\t\tstruct state *const st = md->st;\n\n\t\t/* Only send response if it is request*/\n\t\tif (!(md->hdr.isa_flags & ISAKMP_FLAGS_R)) {\n\t\t\tunsigned char *authstart;\n\t\t\tpb_stream e_pbs, e_pbs_cipher;\n\t\t\tstruct ikev2_generic e;\n\t\t\tunsigned char *iv;\n\t\t\tint ivsize;\n\t\t\tunsigned char *encstart;\n\n\t\t\t/* beginning of data going out */\n\t\t\tauthstart = reply_stream.cur;\n\n\t\t\t/* make sure HDR is at start of a clean buffer */\n\t\t\tzero(reply_buffer);\n\t\t\tinit_pbs(&reply_stream, reply_buffer,\n\t\t\t\t sizeof(reply_buffer),\n\t\t\t\t \"information exchange reply packet\");\n\n\t\t\tDBG(DBG_CONTROLMORE | DBG_DPD,\n\t\t\t    DBG_log(\"Received an INFORMATIONAL request, \"\n\t\t\t\t    \"updating liveness, no longer pending\"));\n\t\t\tst->st_last_liveness = now();\n\t\t\tst->st_pend_liveness = FALSE;\n\n\t\t\t/* HDR out */\n\t\t\t{\n\t\t\t\tstruct isakmp_hdr r_hdr;\n\t\t\t\tzero(&r_hdr); /* default to 0 */  /* AAA should we copy from MD? */\n\t\t\t\tr_hdr.isa_version = build_ike_version();\n\t\t\t\tmemcpy(r_hdr.isa_rcookie, st->st_rcookie,\n\t\t\t\t       COOKIE_SIZE);\n\t\t\t\tmemcpy(r_hdr.isa_icookie, st->st_icookie,\n\t\t\t\t       COOKIE_SIZE);\n\t\t\t\tr_hdr.isa_xchg = ISAKMP_v2_INFORMATIONAL;\n\t\t\t\tr_hdr.isa_np = ISAKMP_NEXT_v2E;\n\t\t\t\tr_hdr.isa_msgid = htonl(md->msgid_received);\n\n\t\t\t\t/*set initiator bit if we are initiator*/\n\t\t\t\tif (md->role == INITIATOR)\n\t\t\t\t\tr_hdr.isa_flags |= ISAKMP_FLAGS_I;\n\n\t\t\t\tr_hdr.isa_flags  |=  ISAKMP_FLAGS_R;\n\n\t\t\t\tif (!out_struct(&r_hdr, &isakmp_hdr_desc,\n\t\t\t\t\t\t&reply_stream, &md->rbody)) {\n\t\t\t\t\tlibreswan_log(\n\t\t\t\t\t\t\"error initializing hdr for informational message\");\n\t\t\t\t\treturn STF_INTERNAL_ERROR;\n\t\t\t\t}\n\n\t\t\t} /*HDR Done*/\n\n\t\t\t/* insert an Encryption payload header */\n\t\t\tif (md->chain[ISAKMP_NEXT_v2D]) {\n\t\t\t\tbool ikesa_flag = FALSE;\n\t\t\t\t/* Search if there is a IKE SA delete payload*/\n\t\t\t\tfor (p = md->chain[ISAKMP_NEXT_v2D]; p != NULL;\n\t\t\t\t     p = p->next) {\n\t\t\t\t\tif (p->payload.v2delete.isad_protoid ==\n\t\t\t\t\t    PROTO_ISAKMP) {\n\t\t\t\t\t\te.isag_np = ISAKMP_NEXT_v2NONE;\n\t\t\t\t\t\tikesa_flag = TRUE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* if there is no IKE SA DELETE PAYLOAD*/\n\t\t\t\t/* That means, there are AH OR ESP*/\n\t\t\t\tif (!ikesa_flag)\n\t\t\t\t\te.isag_np = ISAKMP_NEXT_v2D;\n\n\t\t\t} else {\n\t\t\t\te.isag_np = ISAKMP_NEXT_v2NONE;\n\t\t\t}\n\n\t\t\te.isag_critical = ISAKMP_PAYLOAD_NONCRITICAL;\n\n\t\t\tif (!out_struct(&e, &ikev2_e_desc, &md->rbody, &e_pbs))\n\t\t\t\treturn STF_INTERNAL_ERROR;\n\n\t\t\t/* insert IV */\n\t\t\tiv     = e_pbs.cur;\n\t\t\tivsize = st->st_oakley.encrypter->iv_size;\n\t\t\tif (!out_zero(ivsize, &e_pbs, \"iv\"))\n\t\t\t\treturn STF_INTERNAL_ERROR;\n\n\t\t\tget_rnd_bytes(iv, ivsize);\n\n\t\t\t/* note where cleartext starts */\n\t\t\tinit_pbs(&e_pbs_cipher, e_pbs.cur,\n\t\t\t\t e_pbs.roof - e_pbs.cur, \"cleartext\");\n\t\t\te_pbs_cipher.container = &e_pbs;\n\t\t\te_pbs_cipher.desc = NULL;\n\t\t\te_pbs_cipher.cur = e_pbs.cur;\n\t\t\tencstart = e_pbs_cipher.cur;\n\n\t\t\tif (md->chain[ISAKMP_NEXT_v2D]) {\n\n\t\t\t\tfor (p = md->chain[ISAKMP_NEXT_v2D]; p != NULL;\n\t\t\t\t     p = p->next) {\n\t\t\t\t\tv2del = &p->payload.v2delete;\n\n\t\t\t\t\tswitch (v2del->isad_protoid) {\n\t\t\t\t\tcase PROTO_ISAKMP:\n\t\t\t\t\t\t/* My understanding is that delete payload for IKE SA\n\t\t\t\t\t\t *  should be the only payload in the informational exchange\n\t\t\t\t\t\t */\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase PROTO_IPSEC_AH:\n\t\t\t\t\tcase PROTO_IPSEC_ESP:\n\t\t\t\t\t{\n\t\t\t\t\t\tchar spi_buf[1024];\n\t\t\t\t\t\tpb_stream del_pbs;\n\t\t\t\t\t\tstruct ikev2_delete v2del_tmp;\n\t\t\t\t\t\tu_int16_t i, j = 0;\n\t\t\t\t\t\tu_char *spi;\n\n\t\t\t\t\t\tfor (i = 0;\n\t\t\t\t\t\t     i < v2del->isad_nrspi;\n\t\t\t\t\t\t     i++ ) {\n\t\t\t\t\t\t\tspi = p->pbs.cur +\n\t\t\t\t\t\t\t      (i *\n\t\t\t\t\t\t\t       v2del->\n\t\t\t\t\t\t\t       isad_spisize);\n\t\t\t\t\t\t\tDBG(DBG_CONTROLMORE, DBG_log(\n\t\t\t\t\t\t\t\t    \"received delete request for %s SA(0x%08lx)\",\n\t\t\t\t\t\t\t\t    enum_show(\n\t\t\t\t\t\t\t\t\t    &\n\t\t\t\t\t\t\t\t\t    protocol_names,\n\t\t\t\t\t\t\t\t\t    v2del\n\t\t\t\t\t\t\t\t\t    ->\n\t\t\t\t\t\t\t\t\t    isad_protoid),\n\t\t\t\t\t\t\t\t    (\n\t\t\t\t\t\t\t\t\t    unsigned\n\t\t\t\t\t\t\t\t\t    long)\n\t\t\t\t\t\t\t\t    ntohl((\n\t\t\t\t\t\t\t\t\t\t  unsigned\n\t\t\t\t\t\t\t\t\t\t  long)\n\t\t\t\t\t\t\t\t\t  *(\n\t\t\t\t\t\t\t\t\t\t  ipsec_spi_t\n\t\t\t\t\t\t\t\t\t\t  *)\n\t\t\t\t\t\t\t\t\t  spi)));\n\n\t\t\t\t\t\t\tstruct state *dst =\n\t\t\t\t\t\t\t\tfind_state_ikev2_child_to_delete(\n\t\t\t\t\t\t\t\t\tst->st_icookie,\n\t\t\t\t\t\t\t\t\tst->st_rcookie,\n\t\t\t\t\t\t\t\t\tv2del->isad_protoid,\n\t\t\t\t\t\t\t\t\t*(\n\t\t\t\t\t\t\t\t\t\tipsec_spi_t\n\t\t\t\t\t\t\t\t\t\t*)spi);\n\n\t\t\t\t\t\t\tif (dst != NULL) {\n\t\t\t\t\t\t\t\tstruct\n\t\t\t\t\t\t\t\tipsec_proto_info\n\t\t\t\t\t\t\t\t*pr =\n\t\t\t\t\t\t\t\t\tv2del->\n\t\t\t\t\t\t\t\t\tisad_protoid\n\t\t\t\t\t\t\t\t\t==\n\t\t\t\t\t\t\t\t\tPROTO_IPSEC_AH\n\t\t\t\t\t\t\t\t\t?\n\t\t\t\t\t\t\t\t\t&dst\n\t\t\t\t\t\t\t\t\t->st_ah\n\t\t\t\t\t\t\t\t\t:\n\t\t\t\t\t\t\t\t\t&dst\n\t\t\t\t\t\t\t\t\t->\n\t\t\t\t\t\t\t\t\tst_esp;\n\t\t\t\t\t\t\t\tDBG(\n\t\t\t\t\t\t\t\t\tDBG_CONTROLMORE,\n\t\t\t\t\t\t\t\t\tDBG_log(\n\t\t\t\t\t\t\t\t\t\t\"our side spi that needs to be sent: %s SA(0x%08lx)\",\n\t\t\t\t\t\t\t\t\t\tenum_show(\n\t\t\t\t\t\t\t\t\t\t\t&\n\t\t\t\t\t\t\t\t\t\t\tprotocol_names,\n\t\t\t\t\t\t\t\t\t\t\tv2del\n\t\t\t\t\t\t\t\t\t\t\t->\n\t\t\t\t\t\t\t\t\t\t\tisad_protoid),\n\t\t\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\t\t\tunsigned\n\t\t\t\t\t\t\t\t\t\t\tlong)\n\t\t\t\t\t\t\t\t\t\tntohl(\n\t\t\t\t\t\t\t\t\t\t\tpr\n\t\t\t\t\t\t\t\t\t\t\t->\n\t\t\t\t\t\t\t\t\t\t\tour_spi)));\n\n\t\t\t\t\t\t\t\tmemcpy(\n\t\t\t\t\t\t\t\t\tspi_buf +\n\t\t\t\t\t\t\t\t\t(j *\n\t\t\t\t\t\t\t\t\t v2del\n\t\t\t\t\t\t\t\t\t ->\n\t\t\t\t\t\t\t\t\t isad_spisize),\n\t\t\t\t\t\t\t\t\t(u_char\n\t\t\t\t\t\t\t\t\t *)&pr->our_spi,\n\t\t\t\t\t\t\t\t\tv2del->isad_spisize);\n\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tDBG(\n\t\t\t\t\t\t\t\t\tDBG_CONTROLMORE,\n\t\t\t\t\t\t\t\t\tDBG_log(\n\t\t\t\t\t\t\t\t\t\t\"received delete request for %s SA(0x%08lx) but local state is not found\",\n\t\t\t\t\t\t\t\t\t\tenum_show(\n\t\t\t\t\t\t\t\t\t\t\t&\n\t\t\t\t\t\t\t\t\t\t\tprotocol_names,\n\t\t\t\t\t\t\t\t\t\t\tv2del\n\t\t\t\t\t\t\t\t\t\t\t->\n\t\t\t\t\t\t\t\t\t\t\tisad_protoid),\n\t\t\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\t\t\tunsigned\n\t\t\t\t\t\t\t\t\t\t\tlong)\n\t\t\t\t\t\t\t\t\t\tntohl((\n\t\t\t\t\t\t\t\t\t\t\t      unsigned\n\t\t\t\t\t\t\t\t\t\t\t      long)\n\t\t\t\t\t\t\t\t\t\t      *(\n\t\t\t\t\t\t\t\t\t\t\t      ipsec_spi_t\n\t\t\t\t\t\t\t\t\t\t\t      *)\n\t\t\t\t\t\t\t\t\t\t      spi)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( !j ) {\n\t\t\t\t\t\t\tDBG(DBG_CONTROLMORE, DBG_log(\n\t\t\t\t\t\t\t\t    \"This delete payload does not contain a single spi that has any local state, ignoring\"));\n\t\t\t\t\t\t\treturn STF_IGNORE;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDBG(DBG_CONTROLMORE, DBG_log(\n\t\t\t\t\t\t\t\t    \"No. of SPIs to be sent %d\",\n\t\t\t\t\t\t\t\t    j);\n\t\t\t\t\t\t\t    DBG_dump(\n\t\t\t\t\t\t\t\t    \" Emit SPIs\",\n\t\t\t\t\t\t\t\t    spi_buf,\n\t\t\t\t\t\t\t\t    j *\n\t\t\t\t\t\t\t\t    v2del->\n\t\t\t\t\t\t\t\t    isad_spisize));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tzero(&v2del_tmp);\n\n\t\t\t\t\t\tif (p->next != NULL)\n\t\t\t\t\t\t\tv2del_tmp.isad_np =\n\t\t\t\t\t\t\t\tISAKMP_NEXT_v2D;\n\n\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tv2del_tmp.isad_np =\n\t\t\t\t\t\t\t\tISAKMP_NEXT_v2NONE;\n\n\n\t\t\t\t\t\tv2del_tmp.isad_protoid =\n\t\t\t\t\t\t\tv2del->isad_protoid;\n\t\t\t\t\t\tv2del_tmp.isad_spisize =\n\t\t\t\t\t\t\tv2del->isad_spisize;\n\t\t\t\t\t\tv2del_tmp.isad_nrspi = j;\n\n\t\t\t\t\t\t/* Emit delete payload header out*/\n\t\t\t\t\t\tif (!out_struct(&v2del_tmp,\n\t\t\t\t\t\t\t\t&\n\t\t\t\t\t\t\t\tikev2_delete_desc,\n\t\t\t\t\t\t\t\t&e_pbs_cipher,\n\t\t\t\t\t\t\t\t&del_pbs)) {\n\t\t\t\t\t\t\tlibreswan_log(\n\t\t\t\t\t\t\t\t\"error initializing hdr for delete payload\");\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\tSTF_INTERNAL_ERROR;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Emit values of spi to be sent to the peer*/\n\t\t\t\t\t\tif (!out_raw(spi_buf, j *\n\t\t\t\t\t\t\t     v2del->\n\t\t\t\t\t\t\t     isad_spisize,\n\t\t\t\t\t\t\t     &del_pbs,\n\t\t\t\t\t\t\t     \"local spis\")) {\n\t\t\t\t\t\t\tlibreswan_log(\n\t\t\t\t\t\t\t\t\"error sending spi values in delete payload\");\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\tSTF_INTERNAL_ERROR;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tclose_output_pbs(&del_pbs);\n\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/*Unrecongnized protocol */\n\t\t\t\t\t\treturn STF_IGNORE;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* this will break from for loop*/\n\t\t\t\t\tif (v2del->isad_protoid ==\n\t\t\t\t\t    PROTO_ISAKMP)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*If there are no payloads or in other words empty payload in request\n\t\t\t * that means it is check for liveliness, so send an empty payload message\n\t\t\t * this will end up sending an empty payload\n\t\t\t */\n\n\t\t\tikev2_padup_pre_encrypt(md, &e_pbs_cipher);\n\t\t\tclose_output_pbs(&e_pbs_cipher);\n\n\t\t\t{\n\t\t\t\tunsigned char *authloc = ikev2_authloc(md,\n\t\t\t\t\t\t\t\t       &e_pbs);\n\t\t\t\tif (authloc == NULL)\n\t\t\t\t\treturn STF_INTERNAL_ERROR;\n\n\t\t\t\tclose_output_pbs(&e_pbs);\n\t\t\t\tclose_output_pbs(&md->rbody);\n\t\t\t\tclose_output_pbs(&reply_stream);\n\n\t\t\t\tret = ikev2_encrypt_msg(md, md->role,\n\t\t\t\t\t\t\tauthstart,\n\t\t\t\t\t\t\tiv, encstart, authloc,\n\t\t\t\t\t\t\t&e_pbs, &e_pbs_cipher);\n\t\t\t\tif (ret != STF_OK)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\n\n\t\t\t/* keep it for a retransmit if necessary */\n\t\t\tfreeanychunk(st->st_tpacket);\n\t\t\tclonetochunk(st->st_tpacket, reply_stream.start, pbs_offset(\n\t\t\t\t\t     &reply_stream),\n\t\t\t\t     \"reply packet for informational exchange\");\n\n\t\t\tsend_ike_msg(st, __FUNCTION__);\n\t\t}\n\n\t\t/* Now carry out the actualy task, we can not carry the actual task since\n\t\t * we need to send informational responde using existig SAs\n\t\t */\n\n\t\t{\n\t\t\tif (md->chain[ISAKMP_NEXT_v2D] && st->st_state !=\n\t\t\t    STATE_IKESA_DEL) {\n\n\t\t\t\tfor (p = md->chain[ISAKMP_NEXT_v2D]; p != NULL;\n\t\t\t\t     p = p->next) {\n\t\t\t\t\tv2del = &p->payload.v2delete;\n\n\t\t\t\t\tswitch (v2del->isad_protoid) {\n\t\t\t\t\tcase PROTO_ISAKMP:\n\t\t\t\t\t{\n\t\t\t\t\t\t/* My understanding is that delete payload for IKE SA\n\t\t\t\t\t\t *  should be the only payload in the informational\n\t\t\t\t\t\t * Now delete the IKE SA state and all its child states\n\t\t\t\t\t\t */\n\t\t\t\t\t\tstruct state *current_st = st;\n\t\t\t\t\t\tstruct state *next_st = NULL;\n\t\t\t\t\t\tstruct state *first_st = NULL;\n\n\t\t\t\t\t\t/* Find the first state in the hash chain*/\n\t\t\t\t\t\twhile (current_st !=\n\t\t\t\t\t\t       (struct state *) NULL) {\n\t\t\t\t\t\t\tfirst_st = current_st;\n\t\t\t\t\t\t\tcurrent_st =\n\t\t\t\t\t\t\t\tfirst_st->\n\t\t\t\t\t\t\t\tst_hashchain_prev;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurrent_st = first_st;\n\t\t\t\t\t\twhile (current_st !=\n\t\t\t\t\t\t       (struct state *) NULL) {\n\t\t\t\t\t\t\tnext_st =\n\t\t\t\t\t\t\t\tcurrent_st->\n\t\t\t\t\t\t\t\tst_hashchain_next;\n\t\t\t\t\t\t\tif (current_st->\n\t\t\t\t\t\t\t    st_clonedfrom !=\n\t\t\t\t\t\t\t    0 ) {\n\t\t\t\t\t\t\t\tchange_state(\n\t\t\t\t\t\t\t\t\tcurrent_st,\n\t\t\t\t\t\t\t\t\tSTATE_CHILDSA_DEL);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tchange_state(\n\t\t\t\t\t\t\t\t\tcurrent_st,\n\t\t\t\t\t\t\t\t\tSTATE_IKESA_DEL);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdelete_state(current_st);\n\t\t\t\t\t\t\tcurrent_st = next_st;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase PROTO_IPSEC_AH:\n\t\t\t\t\tcase PROTO_IPSEC_ESP:\n\t\t\t\t\t{\n\t\t\t\t\t\t/* pb_stream del_pbs; */\n\t\t\t\t\t\tstruct ikev2_delete;\n\t\t\t\t\t\tu_int16_t i;\n\t\t\t\t\t\tu_char *spi;\n\n\t\t\t\t\t\tfor (i = 0;\n\t\t\t\t\t\t     i < v2del->isad_nrspi;\n\t\t\t\t\t\t     i++ ) {\n\t\t\t\t\t\t\tspi = p->pbs.cur +\n\t\t\t\t\t\t\t      (i *\n\t\t\t\t\t\t\t       v2del->\n\t\t\t\t\t\t\t       isad_spisize);\n\t\t\t\t\t\t\tDBG(DBG_CONTROLMORE, DBG_log(\n\t\t\t\t\t\t\t\t    \"Now doing actual deletion for request: %s SA(0x%08lx)\",\n\t\t\t\t\t\t\t\t    enum_show(\n\t\t\t\t\t\t\t\t\t    &\n\t\t\t\t\t\t\t\t\t    protocol_names,\n\t\t\t\t\t\t\t\t\t    v2del\n\t\t\t\t\t\t\t\t\t    ->\n\t\t\t\t\t\t\t\t\t    isad_protoid),\n\t\t\t\t\t\t\t\t    (\n\t\t\t\t\t\t\t\t\t    unsigned\n\t\t\t\t\t\t\t\t\t    long)\n\t\t\t\t\t\t\t\t    ntohl((\n\t\t\t\t\t\t\t\t\t\t  unsigned\n\t\t\t\t\t\t\t\t\t\t  long)\n\t\t\t\t\t\t\t\t\t  *(\n\t\t\t\t\t\t\t\t\t\t  ipsec_spi_t\n\t\t\t\t\t\t\t\t\t\t  *)\n\t\t\t\t\t\t\t\t\t  spi)));\n\n\t\t\t\t\t\t\tstruct state *dst =\n\t\t\t\t\t\t\t\tfind_state_ikev2_child_to_delete(\n\t\t\t\t\t\t\t\t\tst->st_icookie,\n\t\t\t\t\t\t\t\t\tst->st_rcookie,\n\t\t\t\t\t\t\t\t\tv2del->isad_protoid,\n\t\t\t\t\t\t\t\t\t*(\n\t\t\t\t\t\t\t\t\t\tipsec_spi_t\n\t\t\t\t\t\t\t\t\t\t*)spi);\n\n\t\t\t\t\t\t\tif (dst != NULL) {\n\t\t\t\t\t\t\t\tstruct\n\t\t\t\t\t\t\t\tipsec_proto_info\n\t\t\t\t\t\t\t\t*pr =\n\t\t\t\t\t\t\t\t\tv2del->\n\t\t\t\t\t\t\t\t\tisad_protoid\n\t\t\t\t\t\t\t\t\t==\n\t\t\t\t\t\t\t\t\tPROTO_IPSEC_AH\n\t\t\t\t\t\t\t\t\t?\n\t\t\t\t\t\t\t\t\t&dst\n\t\t\t\t\t\t\t\t\t->st_ah\n\t\t\t\t\t\t\t\t\t:\n\t\t\t\t\t\t\t\t\t&dst\n\t\t\t\t\t\t\t\t\t->\n\t\t\t\t\t\t\t\t\tst_esp;\n\t\t\t\t\t\t\t\tDBG(\n\t\t\t\t\t\t\t\t\tDBG_CONTROLMORE,\n\t\t\t\t\t\t\t\t\tDBG_log(\n\t\t\t\t\t\t\t\t\t\t\"our side spi that needs to be deleted: %s SA(0x%08lx)\",\n\t\t\t\t\t\t\t\t\t\tenum_show(\n\t\t\t\t\t\t\t\t\t\t\t&\n\t\t\t\t\t\t\t\t\t\t\tprotocol_names,\n\t\t\t\t\t\t\t\t\t\t\tv2del\n\t\t\t\t\t\t\t\t\t\t\t->\n\t\t\t\t\t\t\t\t\t\t\tisad_protoid),\n\t\t\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\t\t\tunsigned\n\t\t\t\t\t\t\t\t\t\t\tlong)\n\t\t\t\t\t\t\t\t\t\tntohl(\n\t\t\t\t\t\t\t\t\t\t\tpr\n\t\t\t\t\t\t\t\t\t\t\t->\n\t\t\t\t\t\t\t\t\t\t\tour_spi)));\n\n\t\t\t\t\t\t\t\t/* now delete the state*/\n\t\t\t\t\t\t\t\tchange_state(\n\t\t\t\t\t\t\t\t\tdst,\n\t\t\t\t\t\t\t\t\tSTATE_CHILDSA_DEL);\n\t\t\t\t\t\t\t\tdelete_state(\n\t\t\t\t\t\t\t\t\tdst);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tDBG(\n\t\t\t\t\t\t\t\t\tDBG_CONTROLMORE,\n\t\t\t\t\t\t\t\t\tDBG_log(\n\t\t\t\t\t\t\t\t\t\t\"received delete request for %s SA(0x%08lx) but local state is not found\",\n\t\t\t\t\t\t\t\t\t\tenum_show(\n\t\t\t\t\t\t\t\t\t\t\t&\n\t\t\t\t\t\t\t\t\t\t\tprotocol_names,\n\t\t\t\t\t\t\t\t\t\t\tv2del\n\t\t\t\t\t\t\t\t\t\t\t->\n\t\t\t\t\t\t\t\t\t\t\tisad_protoid),\n\t\t\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\t\t\tunsigned\n\t\t\t\t\t\t\t\t\t\t\tlong)\n\t\t\t\t\t\t\t\t\t\tntohl((\n\t\t\t\t\t\t\t\t\t\t\t      unsigned\n\t\t\t\t\t\t\t\t\t\t\t      long)\n\t\t\t\t\t\t\t\t\t\t      *(\n\t\t\t\t\t\t\t\t\t\t\t      ipsec_spi_t\n\t\t\t\t\t\t\t\t\t\t\t      *)\n\t\t\t\t\t\t\t\t\t\t      spi)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/*Unrecongnized protocol */\n\t\t\t\t\t\treturn STF_IGNORE;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* this will break from for loop*/\n\t\t\t\t\tif (v2del->isad_protoid ==\n\t\t\t\t\t    PROTO_ISAKMP)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}       /* for */\n\n\t\t\t}               /* if*/\n\t\t\telse {\n\t\t\t\t/* empty response to our IKESA delete request*/\n\t\t\t\tif ((md->hdr.isa_flags & ISAKMP_FLAGS_R) &&\n\t\t\t\t    st->st_state == STATE_IKESA_DEL) {\n\t\t\t\t\t/* My understanding is that delete payload for IKE SA\n\t\t\t\t\t *  should be the only payload in the informational\n\t\t\t\t\t * Now delete the IKE SA state and all its child states\n\t\t\t\t\t */\n\t\t\t\t\tstruct state *current_st = st;\n\t\t\t\t\tstruct state *next_st = NULL;\n\t\t\t\t\tstruct state *first_st = NULL;\n\n\t\t\t\t\t/* Find the first state in the hash chain*/\n\t\t\t\t\twhile (current_st !=\n\t\t\t\t\t       (struct state *) NULL) {\n\t\t\t\t\t\tfirst_st = current_st;\n\t\t\t\t\t\tcurrent_st =\n\t\t\t\t\t\t\tfirst_st->\n\t\t\t\t\t\t\tst_hashchain_prev;\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrent_st = first_st;\n\t\t\t\t\twhile (current_st !=\n\t\t\t\t\t       (struct state *) NULL) {\n\t\t\t\t\t\tnext_st =\n\t\t\t\t\t\t\tcurrent_st->\n\t\t\t\t\t\t\tst_hashchain_next;\n\t\t\t\t\t\tif (current_st->st_clonedfrom\n\t\t\t\t\t\t    !=\n\t\t\t\t\t\t    0 ) {\n\t\t\t\t\t\t\tchange_state(\n\t\t\t\t\t\t\t\tcurrent_st,\n\t\t\t\t\t\t\t\tSTATE_CHILDSA_DEL);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchange_state(\n\t\t\t\t\t\t\t\tcurrent_st,\n\t\t\t\t\t\t\t\tSTATE_IKESA_DEL);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdelete_state(current_st);\n\t\t\t\t\t\tcurrent_st = next_st;\n\t\t\t\t\t}\n\t\t\t\t\t/* empty response to our empty INFORMATIONAL\n\t\t\t\t\t * We don't send anything back */\n\t\t\t\t} else if ((md->hdr.isa_flags &\n\t\t\t\t\t    ISAKMP_FLAGS_R) &&\n\t\t\t\t\t   st->st_state != STATE_IKESA_DEL) {\n\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t    DBG_log(\n\t\t\t\t\t\t    \"Received an INFORMATIONAL response, \"\n\t\t\t\t\t\t    \"updating liveness, no longer pending.\"));\n\t\t\t\t\tst->st_last_liveness = now();\n\t\t\t\t\tst->st_pend_liveness = FALSE;\n\t\t\t\t\tst->st_msgid_lastrecv =\n\t\t\t\t\t\tmd->msgid_received;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn STF_OK;\n}\n\nstf_status ikev2_send_informational(struct state *st)\n{\n\tstruct state *pst = NULL;\n\n\tif (st->st_clonedfrom != SOS_NOBODY) {\n\t\tpst = state_with_serialno(st->st_clonedfrom);\n\t\tif (!pst) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\n\t\t\t\t    \"IKE SA does not exist for this child SA - should not happen\"));\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\"INFORMATIONAL exchange can not be sent\"));\n\t\t\treturn STF_IGNORE;\n\t\t}\n\t} else {\n\t\tpst = st;\n\t}\n\n\t{\n\t\tunsigned char *authstart;\n\t\tunsigned char *encstart;\n\t\tunsigned char *iv;\n\t\tint ivsize;\n\t\tstruct msg_digest md;\n\t\tstruct ikev2_generic e;\n\t\tenum phase1_role role;\n\t\tpb_stream e_pbs, e_pbs_cipher;\n\t\tpb_stream rbody;\n\t\tpb_stream request;\n\t\tu_char buffer[1024];\n\n\t\tmd.st = st;\n\t\tmd.pst = pst;\n\t\tmemset(buffer, 0, sizeof(buffer));\n\t\tinit_pbs(&request, buffer, sizeof(buffer),\n\t\t\t \"informational exchange request packet\");\n\t\tauthstart = request.cur;\n\n\t\t/* HDR out */\n\t\t{\n\t\t\tstruct isakmp_hdr r_hdr;\n\t\t\tzero(&r_hdr);\n\t\t\tr_hdr.isa_version = build_ike_version();\n\t\t\tmemcpy(r_hdr.isa_rcookie, pst->st_rcookie,\n\t\t\t       COOKIE_SIZE);\n\t\t\tmemcpy(r_hdr.isa_icookie, pst->st_icookie,\n\t\t\t       COOKIE_SIZE);\n\t\t\tr_hdr.isa_xchg = ISAKMP_v2_INFORMATIONAL;\n\t\t\tr_hdr.isa_np = ISAKMP_NEXT_v2E;\n\n\t\t\tif (pst->st_state == STATE_PARENT_I2 ||\n\t\t\t    pst->st_state == STATE_PARENT_I3) {\n\t\t\t\tr_hdr.isa_flags |= ISAKMP_FLAGS_I;\n\t\t\t\trole = INITIATOR;\n\t\t\t\tr_hdr.isa_msgid = htonl(pst->st_msgid_nextuse);\n\t\t\t} else {\n\t\t\t\trole = RESPONDER;\n\t\t\t\tr_hdr.isa_msgid = htonl(\n\t\t\t\t\tpst->st_msgid_lastrecv + 1);\n\t\t\t}\n\n\t\t\tif (!out_struct(&r_hdr, &isakmp_hdr_desc,\n\t\t\t\t\t&request, &rbody)) {\n\t\t\t\tlibreswan_log(\n\t\t\t\t\t\"error initializing hdr for informational message\");\n\t\t\t\treturn STF_FATAL;\n\t\t\t}\n\t\t} /* HDR done*/\n\n\t\t/* insert an Encryption payload header */\n\t\te.isag_np = ISAKMP_NEXT_v2NONE;\n\t\te.isag_critical = ISAKMP_PAYLOAD_NONCRITICAL;\n\t\tif (!out_struct(&e, &ikev2_e_desc, &rbody, &e_pbs))\n\t\t\treturn STF_FATAL;\n\n\t\t/* IV */\n\t\tiv = e_pbs.cur;\n\t\tivsize = pst->st_oakley.encrypter->iv_size;\n\t\tif (!out_zero(ivsize, &e_pbs, \"iv\"))\n\t\t\treturn STF_FATAL;\n\n\t\tget_rnd_bytes(iv, ivsize);\n\n\t\t/* note where cleartext starts */\n\t\tinit_pbs(&e_pbs_cipher, e_pbs.cur, e_pbs.roof - e_pbs.cur,\n\t\t\t \"cleartext\");\n\t\te_pbs_cipher.container = &e_pbs;\n\t\te_pbs_cipher.desc = NULL;\n\t\te_pbs_cipher.cur = e_pbs.cur;\n\t\tencstart = e_pbs_cipher.cur;\n\n\t\t/* This is an empty informational exchange (A.K.A liveness check) */\n\t\tikev2_padup_pre_encrypt(&md, &e_pbs_cipher);\n\t\tclose_output_pbs(&e_pbs_cipher);\n\n\t\t{\n\t\t\tstf_status ret;\n\t\t\tunsigned char *authloc = ikev2_authloc(&md, &e_pbs);\n\n\t\t\tif (!authloc)\n\t\t\t\treturn STF_FATAL;\n\n\t\t\tclose_output_pbs(&e_pbs);\n\t\t\tclose_output_pbs(&rbody);\n\t\t\tclose_output_pbs(&request);\n\n\t\t\tret = ikev2_encrypt_msg(&md, role,\n\t\t\t\t\t\tauthstart,\n\t\t\t\t\t\tiv, encstart, authloc,\n\t\t\t\t\t\t&e_pbs, &e_pbs_cipher);\n\t\t\tif (ret != STF_OK)\n\t\t\t\treturn STF_FATAL;\n\t\t}\n\t\t/* keep it for a retransmit if necessary */\n\t\tfreeanychunk(pst->st_tpacket);\n\t\tclonetochunk(pst->st_tpacket, request.start,\n\t\t\t     pbs_offset(&request),\n\t\t\t     \"reply packet for informational exchange\");\n\t\tpst->st_pend_liveness = TRUE; /* we should only do this when dpd/liveness is active? */\n\t\tsend_ike_msg(pst, __FUNCTION__);\n\t\tikev2_update_counters(&md);\n\n\t}\n\n\treturn STF_OK;\n}\n/*\n *\n ***************************************************************\n *                       DELETE_OUT                        *****\n ***************************************************************\n *\n */\nvoid ikev2_delete_out(struct state *st)\n{\n\tstruct state *pst = NULL;\n\n\tif (st->st_clonedfrom != 0) {\n\t\t/*child SA*/\n\t\tpst = state_with_serialno(st->st_clonedfrom);\n\n\t\tif (!pst) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\"IKE SA does not exist for this child SA\"));\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\n\t\t\t\t    \"INFORMATIONAL exchange can not be sent, deleting state\"));\n\t\t\tgoto end;\n\t\t}\n\t} else {\n\t\t/* Parent SA*/\n\t\tpst = st;\n\n\t}\n\n\t{\n\t\tunsigned char *authstart;\n\t\tpb_stream e_pbs, e_pbs_cipher;\n\t\tpb_stream rbody;\n\t\tstruct ikev2_generic e;\n\t\tunsigned char *iv;\n\t\tint ivsize;\n\t\tunsigned char *encstart;\n\t\tstruct msg_digest md;\n\t\tenum phase1_role role;\n\n\t\tmd.st = st;\n\t\tmd.pst = pst;\n\t\t/* beginning of data going out */\n\t\tauthstart = reply_stream.cur;\n\n\t\t/* make sure HDR is at start of a clean buffer */\n\t\tzero(reply_buffer);\n\t\tinit_pbs(&reply_stream, reply_buffer, sizeof(reply_buffer),\n\t\t\t \"information exchange request packet\");\n\n\t\t/* HDR out */\n\t\t{\n\t\t\tstruct isakmp_hdr r_hdr;\n\t\t\tzero(&r_hdr); /* default to 0 */  /* AAA should we copy from MD? */\n\t\t\tr_hdr.isa_version = build_ike_version();\n\t\t\tmemcpy(r_hdr.isa_rcookie, pst->st_rcookie,\n\t\t\t       COOKIE_SIZE);\n\t\t\tmemcpy(r_hdr.isa_icookie, pst->st_icookie,\n\t\t\t       COOKIE_SIZE);\n\t\t\tr_hdr.isa_xchg = ISAKMP_v2_INFORMATIONAL;\n\t\t\tr_hdr.isa_np = ISAKMP_NEXT_v2E;\n\t\t\tr_hdr.isa_msgid = htonl(pst->st_msgid_nextuse);\n\n\t\t\t/*set initiator bit if we are initiator*/\n\t\t\tif (pst->st_state == STATE_PARENT_I2 ||\n\t\t\t    pst->st_state == STATE_PARENT_I3) {\n\t\t\t\tr_hdr.isa_flags |= ISAKMP_FLAGS_I;\n\t\t\t\trole = INITIATOR;\n\t\t\t} else {\n\t\t\t\trole = RESPONDER;\n\t\t\t}\n\n\t\t\t/* r_hdr.isa_flags  |=  ISAKMP_FLAGS_R; */\n\n\t\t\tif (!out_struct(&r_hdr, &isakmp_hdr_desc,\n\t\t\t\t\t&reply_stream, &rbody)) {\n\t\t\t\tlibreswan_log(\n\t\t\t\t\t\"error initializing hdr for informational message\");\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t} /*HDR Done*/\n\n\t\t/* insert an Encryption payload header */\n\t\te.isag_np = ISAKMP_NEXT_v2D;\n\t\te.isag_critical = ISAKMP_PAYLOAD_NONCRITICAL;\n\n\t\tif (!out_struct(&e, &ikev2_e_desc, &rbody, &e_pbs))\n\t\t\tgoto end;\n\n\t\t/* insert IV */\n\t\tiv     = e_pbs.cur;\n\t\tivsize = pst->st_oakley.encrypter->iv_size;\n\t\tif (!out_zero(ivsize, &e_pbs, \"iv\"))\n\t\t\tgoto end;\n\t\tget_rnd_bytes(iv, ivsize);\n\n\t\t/* note where cleartext starts */\n\t\tinit_pbs(&e_pbs_cipher, e_pbs.cur, e_pbs.roof - e_pbs.cur,\n\t\t\t \"cleartext\");\n\t\te_pbs_cipher.container = &e_pbs;\n\t\te_pbs_cipher.desc = NULL;\n\t\te_pbs_cipher.cur = e_pbs.cur;\n\t\tencstart = e_pbs_cipher.cur;\n\n\t\t{\n\t\t\tpb_stream del_pbs;\n\t\t\tstruct ikev2_delete v2del_tmp;\n\t\t\t/*\n\t\t\t * u_int16_t i, j=0;\n\t\t\t * u_char *spi;\n\t\t\t * char spi_buf[1024];\n\t\t\t */\n\n\t\t\tzero(&v2del_tmp);\n\t\t\tv2del_tmp.isad_np = ISAKMP_NEXT_v2NONE;\n\n\t\t\tif (st->st_clonedfrom != 0 ) {\n\t\t\t\tv2del_tmp.isad_protoid = PROTO_IPSEC_ESP;\n\t\t\t\tv2del_tmp.isad_spisize = sizeof(ipsec_spi_t);\n\t\t\t\tv2del_tmp.isad_nrspi = 1;\n\t\t\t} else {\n\t\t\t\tv2del_tmp.isad_protoid = PROTO_ISAKMP;\n\t\t\t\tv2del_tmp.isad_spisize = 0;\n\t\t\t\tv2del_tmp.isad_nrspi = 0;\n\t\t\t}\n\n\t\t\t/* Emit delete payload header out*/\n\t\t\tif (!out_struct(&v2del_tmp, &ikev2_delete_desc,\n\t\t\t\t\t&e_pbs_cipher, &del_pbs)) {\n\t\t\t\tlibreswan_log(\n\t\t\t\t\t\"error initializing hdr for delete payload\");\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\t/* Emit values of spi to be sent to the peer*/\n\t\t\tif (st->st_clonedfrom != 0) {\n\t\t\t\tif (!out_raw( (u_char *)&st->st_esp.our_spi,\n\t\t\t\t\t      sizeof(ipsec_spi_t), &del_pbs,\n\t\t\t\t\t      \"local spis\")) {\n\t\t\t\t\tlibreswan_log(\n\t\t\t\t\t\t\"error sending spi values in delete payload\");\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tclose_output_pbs(&del_pbs);\n\n\t\t}\n\n\t\tikev2_padup_pre_encrypt(&md, &e_pbs_cipher);\n\t\tclose_output_pbs(&e_pbs_cipher);\n\n\t\t{\n\t\t\tstf_status ret;\n\t\t\tunsigned char *authloc = ikev2_authloc(&md, &e_pbs);\n\t\t\tif (authloc == NULL)\n\t\t\t\tgoto end;\n\t\t\tclose_output_pbs(&e_pbs);\n\t\t\tclose_output_pbs(&rbody);\n\t\t\tclose_output_pbs(&reply_stream);\n\n\t\t\tret = ikev2_encrypt_msg(&md, role,\n\t\t\t\t\t\tauthstart,\n\t\t\t\t\t\tiv, encstart, authloc,\n\t\t\t\t\t\t&e_pbs, &e_pbs_cipher);\n\t\t\tif (ret != STF_OK)\n\t\t\t\tgoto end;\n\t\t}\n\n\t\t/* keep it for a retransmit if necessary */\n\t\tfreeanychunk(pst->st_tpacket);\n\t\tclonetochunk(pst->st_tpacket, reply_stream.start,\n\t\t\t     pbs_offset(&reply_stream),\n\t\t\t     \"request packet for informational exchange\");\n\n\t\tsend_ike_msg(pst, __FUNCTION__);\n\n\t\t/* update state */\n\t\tikev2_update_counters(&md);\n\n\t}\n\n\t/* If everything is fine, and we sent packet, goto real_end*/\n\tgoto real_end;\n\nend:\n\t/* If some error occurs above that prevents us sending a request packet*/\n\t/* delete the states right now*/\n\n\tif (st->st_clonedfrom != SOS_NOBODY) {\n\t\tchange_state(st, STATE_CHILDSA_DEL);\n\t\tdelete_state(st);\n\t} else {\n\n\t\tstruct state *current_st = pst;\n\t\tstruct state *next_st = NULL;\n\t\tstruct state *first_st = NULL;\n\n\t\t/* Find the first state in the hash chain*/\n\t\twhile (current_st != (struct state *) NULL) {\n\t\t\tfirst_st = current_st;\n\t\t\tcurrent_st = first_st->st_hashchain_prev;\n\t\t}\n\n\t\tcurrent_st = first_st;\n\t\twhile (current_st != (struct state *) NULL) {\n\t\t\tnext_st = current_st->st_hashchain_next;\n\t\t\tif (current_st->st_clonedfrom != 0 )\n\t\t\t\tchange_state(current_st, STATE_CHILDSA_DEL);\n\t\t\telse\n\t\t\t\tchange_state(current_st, STATE_IKESA_DEL);\n\t\t\tdelete_state(current_st);\n\t\t\tcurrent_st = next_st;\n\t\t}\n\t}\n\nreal_end:;\n}\n\n/*\n * Determine the IKE version we will use for the IKE packet\n * Normally, this is \"2.0\", but in the future we might need to\n * change that. Version used is the minimum 2.x version both\n * sides support. So if we support 2.1, and they support 2.0,\n * we should sent 2.0 (not implemented until we hit 2.1 ourselves)\n * We also have some impair functions that modify the major/minor\n * version on purpose - for testing\n *\n * rcv_version: the received IKE version, 0 if we don't know\n *\n * top 4 bits are major version, lower 4 bits are minor version\n */\nstatic int build_ike_version()\n{\nreturn ((IKEv2_MAJOR_VERSION + (DBGP(IMPAIR_MAJOR_VERSION_BUMP) ? 1 : 0))\n\t<< ISA_MAJ_SHIFT) | (IKEv2_MINOR_VERSION +\n\t(DBGP(IMPAIR_MINOR_VERSION_BUMP) ? 1 : 0));\n}\n"], "fixing_code": ["/*\n * IKEv2 parent SA creation routines\n * Copyright (C) 2007-2008 Michael Richardson <mcr@xelerance.com>\n * Copyright (C) 2008-2011 Paul Wouters <paul@xelerance.com>\n * Copyright (C) 2008 Antony Antony <antony@xelerance.com>\n * Copyright (C) 2008-2009 David McCullough <david_mccullough@securecomputing.com>\n * Copyright (C) 2010,2012 Avesh Agarwal <avagarwa@redhat.com>\n * Copyright (C) 2010 Tuomo Soini <tis@foobar.fi\n * Copyright (C) 2012 Paul Wouters <pwouters@redhat.com>\n * Copyright (C) 2012 Antony Antony <antony@phenome.org>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the\n * Free Software Foundation; either version 2 of the License, or (at your\n * option) any later version.  See <http://www.fsf.org/copyleft/gpl.txt>.\n *\n * This program is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * for more details.\n *\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <gmp.h>\n\n#include <libreswan.h>\n#include <libreswan/ipsec_policy.h>\n\n#include \"sysdep.h\"\n#include \"constants.h\"\n#include \"defs.h\"\n#include \"state.h\"\n#include \"id.h\"\n#include \"connections.h\"\n\n#include \"crypto.h\" /* requires sha1.h and md5.h */\n#include \"x509.h\"\n#include \"x509more.h\"\n#include \"ike_alg.h\"\n#include \"kernel_alg.h\"\n#include \"plutoalg.h\"\n#include \"pluto_crypt.h\"\n#include \"packet.h\"\n#include \"demux.h\"\n#include \"ikev2.h\"\n#include \"log.h\"\n#include \"spdb.h\"          /* for out_sa */\n#include \"ipsec_doi.h\"\n#include \"vendor.h\"\n#include \"timer.h\"\n#include \"ike_continuations.h\"\n#include \"cookie.h\"\n#include \"rnd.h\"\n#include \"pending.h\"\n#include \"kernel.h\"\n\n#define SEND_NOTIFICATION_AA(t, d) \\\n\tif (st) \\\n\t\tsend_v2_notification_from_state(st, st->st_state, t, d); \\\n\telse \\\n\t\tsend_v2_notification_from_md(md, t, d);\n\n#define SEND_NOTIFICATION(t) \\\n\tif (st) \\\n\t\tsend_v2_notification_from_state(st, st->st_state, t, NULL); \\\n\telse \\\n\t\tsend_v2_notification_from_md(md, t, NULL);\n\nstatic void ikev2_parent_outI1_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\tstruct pluto_crypto_req *r,\n\t\t\t\t\terr_t ugh);\n\nstatic stf_status ikev2_parent_outI1_tail(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t  struct pluto_crypto_req *r);\n\nstatic bool ikev2_get_dcookie(u_char *dcookie, chunk_t st_ni,\n\t\t\t      ip_address *addr, u_int8_t *spiI);\n\nstatic stf_status ikev2_parent_outI1_common(struct msg_digest *md,\n\t\t\t\t\t    struct state *st);\n\nstatic int build_ike_version();\n\n/*\n *\n ***************************************************************\n *****                   PARENT_OUTI1                      *****\n ***************************************************************\n *\n *\n * Initiate an Oakley Main Mode exchange.\n *       HDR, SAi1, KEi, Ni   -->\n *\n * Note: this is not called from demux.c, but from ipsecdoi_initiate().\n *\n */\nstf_status ikev2parent_outI1(int whack_sock,\n\t\t\t     struct connection *c,\n\t\t\t     struct state *predecessor,\n\t\t\t     lset_t policy,\n\t\t\t     unsigned long try,\n\t\t\t     enum crypto_importance importance\n#ifdef HAVE_LABELED_IPSEC\n\t\t\t     , struct xfrm_user_sec_ctx_ike * uctx\n#endif\n\t\t\t     )\n{\n\tstruct state *st = new_state();\n\tstruct db_sa *sadb;\n\tint groupnum;\n\tint policy_index = POLICY_ISAKMP(policy,\n\t\t\t\t\t c->spd.this.xauth_server,\n\t\t\t\t\t c->spd.this.xauth_client);\n\n\t/* set up new state */\n\tget_cookie(TRUE, st->st_icookie, COOKIE_SIZE, &c->spd.that.host_addr);\n\tinitialize_new_state(st, c, policy, try, whack_sock, importance);\n\tst->st_ikev2 = TRUE;\n\tchange_state(st, STATE_PARENT_I1);\n\tst->st_msgid_lastack = INVALID_MSGID;\n\tst->st_msgid_nextuse = 0;\n\tst->st_try   = try;\n\n\tif (HAS_IPSEC_POLICY(policy)) {\n#ifdef HAVE_LABELED_IPSEC\n\t\tst->sec_ctx = NULL;\n\t\tif ( uctx != NULL)\n\t\t\tlibreswan_log(\n\t\t\t\t\"Labeled ipsec is not supported with ikev2 yet\");\n\n\n#endif\n\n\t\tadd_pending(dup_any(\n\t\t\t\t    whack_sock), st, c, policy, 1,\n\t\t\t    predecessor == NULL ? SOS_NOBODY : predecessor->st_serialno\n#ifdef HAVE_LABELED_IPSEC\n\t\t\t    , st->sec_ctx\n#endif\n\t\t\t    );\n\t}\n\n\tif (predecessor == NULL)\n\t\tlibreswan_log(\"initiating v2 parent SA\");\n\telse\n\t\tlibreswan_log(\"initiating v2 parent SA to replace #%lu\",\n\t\t\t      predecessor->st_serialno);\n\n\tif (predecessor != NULL) {\n\t\tupdate_pending(predecessor, st);\n\t\twhack_log(RC_NEW_STATE + STATE_PARENT_I1,\n\t\t\t  \"%s: initiate, replacing #%lu\",\n\t\t\t  enum_name(&state_names, st->st_state),\n\t\t\t  predecessor->st_serialno);\n\t} else {\n\t\twhack_log(RC_NEW_STATE + STATE_PARENT_I1,\n\t\t\t  \"%s: initiate\",\n\t\t\t  enum_name(&state_names, st->st_state));\n\t}\n\n\t/*\n\t * now, we need to initialize st->st_oakley, specifically, the group\n\t * number needs to be initialized.\n\t */\n\tgroupnum = 0;\n\n\tst->st_sadb = &oakley_sadb[policy_index];\n\tsadb = oakley_alg_makedb(st->st_connection->alg_info_ike,\n\t\t\t\t st->st_sadb, 0);\n\tif (sadb != NULL)\n\t\tst->st_sadb = sadb;\n\tsadb = st->st_sadb = sa_v2_convert(st->st_sadb);\n\t{\n\t\tunsigned int pc_cnt;\n\n\t\t/* look at all the proposals */\n\t\tif (st->st_sadb->prop_disj != NULL) {\n\t\t\tfor (pc_cnt = 0;\n\t\t\t     pc_cnt < st->st_sadb->prop_disj_cnt && groupnum ==\n\t\t\t     0;\n\t\t\t     pc_cnt++) {\n\t\t\t\tstruct db_v2_prop *vp =\n\t\t\t\t\t&st->st_sadb->prop_disj[pc_cnt];\n\t\t\t\tunsigned int pr_cnt;\n\n\t\t\t\t/* look at all the proposals */\n\t\t\t\tif (vp->props != NULL) {\n\t\t\t\t\tfor (pr_cnt = 0;\n\t\t\t\t\t     pr_cnt < vp->prop_cnt &&\n\t\t\t\t\t     groupnum == 0;\n\t\t\t\t\t     pr_cnt++) {\n\t\t\t\t\t\tunsigned int ts_cnt;\n\t\t\t\t\t\tstruct db_v2_prop_conj *vpc =\n\t\t\t\t\t\t\t&vp->props[pr_cnt];\n\n\t\t\t\t\t\tfor (ts_cnt = 0;\n\t\t\t\t\t\t     ts_cnt < vpc->trans_cnt &&\n\t\t\t\t\t\t     groupnum == 0; ts_cnt++) {\n\t\t\t\t\t\t\tstruct db_v2_trans *tr\n\t\t\t\t\t\t\t\t=\n\t\t\t\t\t\t\t\t\t&vpc->\n\t\t\t\t\t\t\t\t\ttrans[\n\t\t\t\t\t\t\t\t\t\tts_cnt\n\t\t\t\t\t\t\t\t\t];\n\t\t\t\t\t\t\tif (tr != NULL &&\n\t\t\t\t\t\t\t    tr->transform_type\n\t\t\t\t\t\t\t    ==\n\t\t\t\t\t\t\t    IKEv2_TRANS_TYPE_DH)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tgroupnum =\n\t\t\t\t\t\t\t\t\ttr->\n\t\t\t\t\t\t\t\t\ttransid;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (groupnum == 0)\n\t\tgroupnum = OAKLEY_GROUP_MODP2048;\n\tst->st_oakley.group = lookup_group(groupnum);\n\tst->st_oakley.groupnum = groupnum;\n\n\t/* now. we need to go calculate the nonce, and the KE */\n\t{\n\t\tstruct ke_continuation *ke = alloc_thing(\n\t\t\tstruct ke_continuation,\n\t\t\t\"ikev2_outI1 KE\");\n\t\tstf_status e;\n\n\t\tke->md = alloc_md();\n\t\tke->md->from_state = STATE_IKEv2_BASE;\n\t\tke->md->svm = ikev2_parent_firststate();\n\t\tke->md->st = st;\n\t\tset_suspended(st, ke->md);\n\n\t\tif (!st->st_sec_in_use) {\n\t\t\tpcrc_init(&ke->ke_pcrc);\n\t\t\tke->ke_pcrc.pcrc_func = ikev2_parent_outI1_continue;\n\t\t\te = build_ke(&ke->ke_pcrc, st, st->st_oakley.group,\n\t\t\t\t     importance);\n\t\t\tif ( (e != STF_SUSPEND &&\n\t\t\t      e != STF_INLINE) || (e == STF_TOOMUCHCRYPTO)) {\n\t\t\t\tloglog(RC_CRYPTOFAILED,\n\t\t\t\t       \"system too busy - Enabling dcookies [TODO]\");\n\t\t\t\tdelete_state(st);\n\t\t\t}\n\t\t} else {\n\t\t\te =\n\t\t\t\tikev2_parent_outI1_tail(\n\t\t\t\t\t(struct pluto_crypto_req_cont *)ke,\n\t\t\t\t\tNULL);\n\t\t}\n\n\t\treset_globals();\n\n\t\treturn e;\n\t}\n}\n\nstatic void ikev2_parent_outI1_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\tstruct pluto_crypto_req *r,\n\t\t\t\t\terr_t ugh)\n{\n\tstruct ke_continuation *ke = (struct ke_continuation *)pcrc;\n\tstruct msg_digest *md = ke->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent outI1: calculated ke+nonce, sending I1\"));\n\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t\treturn;\n\t}\n\n\t/* XXX should check out ugh */\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\n\tpassert(st->st_suspended_md == ke->md);\n\tset_suspended(st, NULL); /* no longer connected or suspended */\n\n\tset_cur_state(st);\n\n\tst->st_calculating = FALSE;\n\n\te = ikev2_parent_outI1_tail(pcrc, r);\n\n\tif (ke->md != NULL) {\n\t\tcomplete_v2_state_transition(&ke->md, e);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t}\n\treset_cur_state();\n\treset_globals();\n}\n\n/*\n * unpack the calculate KE value, store it in state.\n * used by IKEv2: parent, child (PFS)\n */\nstatic int unpack_v2KE(struct state *st,\n\t\t       struct pluto_crypto_req *r,\n\t\t       chunk_t *g)\n{\n\tstruct pcr_kenonce *kn = &r->pcr_d.kn;\n\n\tunpack_KE(st, r, g);\n\treturn kn->oakley_group;\n}\n\n/*\n * package up the calculate KE value, and emit it as a KE payload.\n * used by IKEv2: parent, child (PFS)\n */\nstatic bool justship_v2KE(struct state *st UNUSED,\n\t\t\t  chunk_t *g, unsigned int oakley_group,\n\t\t\t  pb_stream *outs, u_int8_t np)\n{\n\tstruct ikev2_ke v2ke;\n\tpb_stream kepbs;\n\n\tmemset(&v2ke, 0, sizeof(v2ke));\n\tv2ke.isak_np      = np;\n\tv2ke.isak_group   = oakley_group;\n\tif (!out_struct(&v2ke, &ikev2_ke_desc, outs, &kepbs))\n\t\treturn FALSE;\n\n\tif (!out_chunk(*g, &kepbs, \"ikev2 g^x\"))\n\t\treturn FALSE;\n\n\tclose_output_pbs(&kepbs);\n\treturn TRUE;\n}\n\nstatic bool ship_v2KE(struct state *st,\n\t\t      struct pluto_crypto_req *r,\n\t\t      chunk_t *g,\n\t\t      pb_stream *outs, u_int8_t np)\n{\n\tint oakley_group = unpack_v2KE(st, r, g);\n\n\treturn justship_v2KE(st, g, oakley_group, outs, np);\n}\n\nstatic stf_status ikev2_parent_outI1_tail(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t  struct pluto_crypto_req *r)\n{\n\tstruct ke_continuation *ke = (struct ke_continuation *)pcrc;\n\tstruct msg_digest *md = ke->md;\n\tstruct state *const st = md->st;\n\n\tunpack_v2KE(st, r, &st->st_gi);\n\tunpack_nonce(&st->st_ni, r);\n\treturn ikev2_parent_outI1_common(md, st);\n}\n\nstatic stf_status ikev2_parent_outI1_common(struct msg_digest *md,\n\t\t\t\t\t    struct state *st)\n{\n\tstruct connection *c = st->st_connection;\n\tint numvidtosend = 0;\n\n\t/* set up reply */\n\tinit_pbs(&reply_stream, reply_buffer, sizeof(reply_buffer),\n\t\t \"reply packet\");\n\n\t/* HDR out */\n\t{\n\t\tstruct isakmp_hdr hdr;\n\n\t\tzero(&hdr);                             /* default to 0 */\n\t\t/* Impair function will raise major/minor by 1 for testing */\n\t\thdr.isa_version = build_ike_version();\n\t\tif (st->st_dcookie.ptr)\n\t\t\thdr.isa_np   = ISAKMP_NEXT_v2N;\n\t\telse\n\t\t\thdr.isa_np   = ISAKMP_NEXT_v2SA;\n\t\thdr.isa_xchg = ISAKMP_v2_SA_INIT;\n\t\thdr.isa_flags = ISAKMP_FLAGS_I;\n\t\tmemcpy(hdr.isa_icookie, st->st_icookie, COOKIE_SIZE);\n\t\t/* R-cookie, are left zero */\n\n\t\tif (!out_struct(&hdr, &isakmp_hdr_desc, &reply_stream,\n\t\t\t\t&md->rbody)) {\n\t\t\treset_cur_state();\n\t\t\treturn STF_INTERNAL_ERROR;\n\t\t}\n\t}\n\t/* send an anti DOS cookie, 4306 2.6, if we have received one from the\n\t * responder\n\t */\n\n\tif (st->st_dcookie.ptr) {\n\t\tchunk_t child_spi;\n\t\tmemset(&child_spi, 0, sizeof(child_spi));\n\t\tship_v2N(ISAKMP_NEXT_v2SA, DBGP(\n\t\t\t\t IMPAIR_SEND_BOGUS_ISAKMP_FLAG) ?\n\t\t\t (ISAKMP_PAYLOAD_NONCRITICAL |\n\t\t\t  ISAKMP_PAYLOAD_LIBRESWAN_BOGUS) :\n\t\t\t ISAKMP_PAYLOAD_NONCRITICAL, PROTO_ISAKMP,\n\t\t\t &child_spi,\n\t\t\t v2N_COOKIE, &st->st_dcookie, &md->rbody);\n\t}\n\t/* SA out */\n\t{\n\t\tu_char *sa_start = md->rbody.cur;\n\n\t\tif (st->st_sadb->prop_disj_cnt == 0 || st->st_sadb->prop_disj)\n\t\t\tst->st_sadb = sa_v2_convert(st->st_sadb);\n\n\t\tif (!ikev2_out_sa(&md->rbody,\n\t\t\t\t  PROTO_ISAKMP,\n\t\t\t\t  st->st_sadb,\n\t\t\t\t  st, TRUE, /* parentSA */\n\t\t\t\t  ISAKMP_NEXT_v2KE)) {\n\t\t\tlibreswan_log(\"outsa fail\");\n\t\t\treset_cur_state();\n\t\t\treturn STF_INTERNAL_ERROR;\n\t\t}\n\t\t/* save initiator SA for later HASH */\n\t\tif (st->st_p1isa.ptr == NULL) { /* no leak!  (MUST be first time) */\n\t\t\tclonetochunk(st->st_p1isa, sa_start,\n\t\t\t\t     md->rbody.cur - sa_start,\n\t\t\t\t     \"sa in main_outI1\");\n\t\t}\n\t}\n\n\t/* send KE */\n\tif (!justship_v2KE(st, &st->st_gi, st->st_oakley.groupnum,  &md->rbody,\n\t\t\t   ISAKMP_NEXT_v2Ni))\n\t\treturn STF_INTERNAL_ERROR;\n\n\t/*\n\t * Check which Vendor ID's we need to send - there will be more soon\n\t * In IKEv2, DPD and NAT-T are no longer vendorid's\n\t */\n\tif (c->send_vendorid) {\n\t\tnumvidtosend++;  /* if we need to send Libreswan VID */\n\t}\n\n\t/* send NONCE */\n\t{\n\t\tint np = numvidtosend > 0 ? ISAKMP_NEXT_v2V : ISAKMP_NEXT_v2NONE;\n\t\tstruct ikev2_generic in;\n\t\tpb_stream pb;\n\n\t\tmemset(&in, 0, sizeof(in));\n\t\tin.isag_np = np;\n\t\tin.isag_critical = ISAKMP_PAYLOAD_NONCRITICAL;\n\t\tif (DBGP(IMPAIR_SEND_BOGUS_ISAKMP_FLAG)) {\n\t\t\tlibreswan_log(\n\t\t\t\t\" setting bogus ISAKMP_PAYLOAD_LIBRESWAN_BOGUS flag in ISAKMP payload\");\n\t\t\tin.isag_critical |= ISAKMP_PAYLOAD_LIBRESWAN_BOGUS;\n\t\t}\n\n\t\tif (!out_struct(&in, &ikev2_nonce_desc, &md->rbody, &pb) ||\n\t\t    !out_raw(st->st_ni.ptr, st->st_ni.len, &pb, \"IKEv2 nonce\"))\n\t\t\treturn STF_INTERNAL_ERROR;\n\n\t\tclose_output_pbs(&pb);\n\t}\n\n\t/* Send Vendor VID if needed */\n\tif (c->send_vendorid) {\n\t\tconst char *myvid = ipsec_version_vendorid();\n\t\tint np = --numvidtosend >\n\t\t\t 0 ? ISAKMP_NEXT_v2V : ISAKMP_NEXT_v2NONE;\n\n\t\tif (!out_generic_raw(np, &isakmp_vendor_id_desc, &md->rbody,\n\t\t\t\t     myvid, strlen(myvid),\n\t\t\t\t     \"Vendor ID\"))\n\t\t\treturn STF_INTERNAL_ERROR;\n\n\t\t/* ensure our VID chain was valid */\n\t\tpassert(numvidtosend == 0);\n\t}\n\n\tclose_message(&md->rbody, st);\n\tclose_output_pbs(&reply_stream);\n\n\tfreeanychunk(st->st_tpacket);\n\tclonetochunk(st->st_tpacket, reply_stream.start,\n\t\t     pbs_offset(&reply_stream),\n\t\t     \"reply packet for ikev2_parent_outI1_tail\");\n\n\t/* save packet for later signing */\n\tfreeanychunk(st->st_firstpacket_me);\n\tclonetochunk(st->st_firstpacket_me, reply_stream.start,\n\t\t     pbs_offset(&reply_stream), \"saved first packet\");\n\n\t/* Transmit */\n\tsend_ike_msg(st, __FUNCTION__);\n\n\tdelete_event(st);\n\tevent_schedule(EVENT_v2_RETRANSMIT, EVENT_RETRANSMIT_DELAY_0, st);\n\n\treset_cur_state();\n\treturn STF_OK;\n}\n\n/*\n *\n ***************************************************************\n *                       PARENT_INI1                       *****\n ***************************************************************\n *  -\n *\n *\n */\nstatic void ikev2_parent_inI1outR1_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh);\n\nstatic stf_status ikev2_parent_inI1outR1_tail(\n\tstruct pluto_crypto_req_cont *pcrc,\n\tstruct pluto_crypto_req *r);\n\nstf_status ikev2parent_inI1outR1(struct msg_digest *md)\n{\n\tstruct state *st = md->st;\n\tlset_t policy = POLICY_IKEV2_ALLOW;\n\tstruct connection *c = find_host_connection(&md->iface->ip_addr,\n\t\t\t\t\t\t    md->iface->port,\n\t\t\t\t\t\t    &md->sender,\n\t\t\t\t\t\t    md->sender_port,\n\t\t\t\t\t\t    POLICY_IKEV2_ALLOW);\n\n\t/* retrieve st->st_gi */\n\n#if 0\n\tif (c == NULL) {\n\t\t/*\n\t\t * make up a policy from the thing that was proposed, and see\n\t\t * if we can find a connection with that policy.\n\t\t */\n\n\t\tpb_stream pre_sa_pbs = sa_pd->pbs;\n\t\tpolicy = preparse_isakmp_sa_body(&pre_sa_pbs);\n\t\tc = find_host_connection(&md->iface->ip_addr, pluto_port,\n\t\t\t\t\t (ip_address*)NULL, md->sender_port,\n\t\t\t\t\t policy);\n\n\t}\n#endif\n\n\tif (c == NULL) {\n\n\t\t/* See if a wildcarded connection can be found.\n\t\t * We cannot pick the right connection, so we're making a guess.\n\t\t * All Road Warrior connections are fair game:\n\t\t * we pick the first we come across (if any).\n\t\t * If we don't find any, we pick the first opportunistic\n\t\t * with the smallest subnet that includes the peer.\n\t\t * There is, of course, no necessary relationship between\n\t\t * an Initiator's address and that of its client,\n\t\t * but Food Groups kind of assumes one.\n\t\t */\n\t\t{\n\t\t\tstruct connection *d;\n\t\t\td = find_host_connection(&md->iface->ip_addr,\n\t\t\t\t\t\t pluto_port,\n\t\t\t\t\t\t (ip_address*)NULL,\n\t\t\t\t\t\t md->sender_port, policy);\n\n\t\t\tfor (; d != NULL; d = d->hp_next) {\n\t\t\t\tif (d->kind == CK_GROUP) {\n\t\t\t\t\t/* ignore */\n\t\t\t\t} else {\n\t\t\t\t\tif (d->kind == CK_TEMPLATE &&\n\t\t\t\t\t    !(d->policy & POLICY_OPPO)) {\n\t\t\t\t\t\t/* must be Road Warrior: we have a winner */\n\t\t\t\t\t\tc = d;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Opportunistic or Shunt: pick tightest match */\n\t\t\t\t\tif (addrinsubnet(&md->sender,\n\t\t\t\t\t\t\t &d->spd.that.client)\n\t\t\t\t\t    &&\n\t\t\t\t\t    (c == NULL ||\n\t\t\t\t\t     !subnetinsubnet(&c->spd.that.\n\t\t\t\t\t\t\t     client,\n\t\t\t\t\t\t\t     &d->spd.that.\n\t\t\t\t\t\t\t     client)))\n\t\t\t\t\t\tc = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (c == NULL) {\n\t\t\tloglog(RC_LOG_SERIOUS, \"initial parent SA message received on %s:%u\"\n\t\t\t       \" but no connection has been authorized%s%s\",\n\t\t\t       ip_str(\n\t\t\t\t       &md->iface->ip_addr),\n\t\t\t       ntohs(portof(&md->iface->ip_addr)),\n\t\t\t       (policy != LEMPTY) ? \" with policy=\" : \"\",\n\t\t\t       (policy !=\n\t\t\t\tLEMPTY) ? bitnamesof(sa_policy_bit_names,\n\t\t\t\t\t\t     policy) : \"\");\n\t\t\treturn STF_FAIL + v2N_NO_PROPOSAL_CHOSEN;\n\t\t}\n\t\tif (c->kind != CK_TEMPLATE) {\n\t\t\tloglog(RC_LOG_SERIOUS, \"initial parent SA message received on %s:%u\"\n\t\t\t       \" but \\\"%s\\\" forbids connection\",\n\t\t\t       ip_str(\n\t\t\t\t       &md->iface->ip_addr), pluto_port,\n\t\t\t       c->name);\n\t\t\treturn STF_FAIL + v2N_NO_PROPOSAL_CHOSEN;\n\t\t}\n\t\tc = rw_instantiate(c, &md->sender, NULL, NULL);\n\n\t} else {\n\t\t/* we found a non-wildcard conn. double check if it needs instantiation anyway (eg vnet=) */\n\t\t/* vnet=/vhost= should have set CK_TEMPLATE on connection loading */\n\t\tif ((c->kind == CK_TEMPLATE) && c->spd.that.virt) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\n\t\t\t\t    \"local endpoint has virt (vnet/vhost) set without wildcards - needs instantiation\"));\n\t\t\tc = rw_instantiate(c, &md->sender, NULL, NULL);\n\t\t} else if ((c->kind == CK_TEMPLATE) &&\n\t\t\t   (c->policy & POLICY_IKEV2_ALLOW_NARROWING)) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\n\t\t\t\t    \"local endpoint has narrowing=yes - needs instantiation\"));\n\t\t\tc = rw_instantiate(c, &md->sender, NULL, NULL);\n\t\t}\n\t}\n\n\tDBG_log(\"found connection: %s\\n\", c ? c->name : \"<none>\");\n\n\tif (!st) {\n\t\tst = new_state();\n\t\t/* set up new state */\n\t\tmemcpy(st->st_icookie, md->hdr.isa_icookie, COOKIE_SIZE);\n\t\t/* initialize_new_state expects valid icookie/rcookie values, so create it now */\n\t\tget_cookie(FALSE, st->st_rcookie, COOKIE_SIZE, &md->sender);\n\t\tinitialize_new_state(st, c, policy, 0, NULL_FD,\n\t\t\t\t     pcim_stranger_crypto);\n\t\tst->st_ikev2 = TRUE;\n\t\tchange_state(st, STATE_PARENT_R1);\n\t\tst->st_msgid_lastack = INVALID_MSGID;\n\t\tst->st_msgid_nextuse = 0;\n\n\t\tmd->st = st;\n\t\tmd->from_state = STATE_IKEv2_BASE;\n\t}\n\n\t/* check,as a responder, are we under dos attack or not\n\t * if yes go to 6 message exchange mode. it is a config option for now.\n\t * TBD set force_busy dynamically\n\t * Paul: Can we check for STF_TOOMUCHCRYPTO ?\n\t */\n\tif (force_busy == TRUE) {\n\t\tu_char dcookie[SHA1_DIGEST_SIZE];\n\t\tchunk_t dc;\n\t\tikev2_get_dcookie( dcookie, st->st_ni, &md->sender,\n\t\t\t\t   st->st_icookie);\n\t\tdc.ptr = dcookie;\n\t\tdc.len = SHA1_DIGEST_SIZE;\n\n\t\t/* check if I1 packet contian KE and a v2N payload with type COOKIE */\n\t\tif ( md->chain[ISAKMP_NEXT_v2KE] &&\n\t\t     md->chain[ISAKMP_NEXT_v2N] &&\n\t\t     (md->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type ==\n\t\t      v2N_COOKIE)) {\n\t\t\tu_int8_t spisize;\n\t\t\tconst pb_stream *dc_pbs;\n\t\t\tchunk_t blob;\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\"received a DOS cookie in I1 verify it\"));\n\t\t\t/* we received dcookie we send earlier verify it */\n\t\t\tspisize =\n\t\t\t\tmd->chain[ISAKMP_NEXT_v2N]->payload.v2n.\n\t\t\t\tisan_spisize;\n\t\t\tdc_pbs = &md->chain[ISAKMP_NEXT_v2N]->pbs;\n\t\t\tblob.ptr = dc_pbs->cur + spisize;\n\t\t\tblob.len = pbs_left(dc_pbs) - spisize;\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_dump_chunk(\"dcookie received in I1 Packet\",\n\t\t\t\t\t   blob);\n\t\t\t    DBG_dump(\"dcookie computed\", dcookie,\n\t\t\t\t     SHA1_DIGEST_SIZE));\n\n\t\t\tif (memcmp(blob.ptr, dcookie, SHA1_DIGEST_SIZE) != 0) {\n\t\t\t\tlibreswan_log(\n\t\t\t\t\t\"mismatch in DOS v2N_COOKIE,send a new one\");\n\t\t\t\tSEND_NOTIFICATION_AA(v2N_COOKIE, &dc);\n\t\t\t\treturn STF_FAIL + v2N_INVALID_IKE_SPI;\n\t\t\t}\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\"dcookie received match with computed one\"));\n\t\t} else {\n\t\t\t/* we are under DOS attack I1 contains no DOS COOKIE */\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\n\t\t\t\t    \"busy mode on. receieved I1 without a valid dcookie\");\n\t\t\t    DBG_log(\"send a dcookie and forget this state\"));\n\t\t\tSEND_NOTIFICATION_AA(v2N_COOKIE, &dc);\n\t\t\treturn STF_FAIL;\n\t\t}\n\t} else {\n\t\tDBG(DBG_CONTROLMORE,\n\t\t    DBG_log(\"will not send/process a dcookie\"));\n\n\t}\n\n\t/*\n\t * We have to agree to the DH group before we actually know who\n\t * we are talking to.   If we support the group, we use it.\n\t *\n\t * It is really too hard here to go through all the possible policies\n\t * that might permit this group.  If we think we are being DOS'ed\n\t * then we should demand a cookie.\n\t */\n\t{\n\t\tstruct ikev2_ke *ke;\n\t\tchar fromname[ADDRTOT_BUF];\n\t\taddrtot(&md->sender, 0, fromname, ADDRTOT_BUF);\n\n\t\tif (!md->chain[ISAKMP_NEXT_v2KE]) {\n\t\t\t/* is this a notify? If so, log it */\n\t\t\tif(md->chain[ISAKMP_NEXT_v2N]) {\n\t\t\t\tlibreswan_log(\"Received Notify(%d): %s\",\n\t\t\t\t\tmd->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type,\n\t\t\t\t\tenum_name(&ikev2_notify_names,\n\t\t\t\t\t\tmd->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type));\n\t\t\t}\n\t\t\tlibreswan_log(\n\t\t\t\t\"rejecting I1 from %s:%u, no KE payload present\",\n\t\t\t\tfromname, md->sender_port);\n\t\t\treturn STF_FAIL + v2N_INVALID_KE_PAYLOAD;\n\t\t}\n\t\tke = &md->chain[ISAKMP_NEXT_v2KE]->payload.v2ke;\n\n\t\tst->st_oakley.group = lookup_group(ke->isak_group);\n\t\tif (st->st_oakley.group == NULL) {\n\t\t\tlibreswan_log(\n\t\t\t\t\"rejecting I1 from %s:%u, invalid DH group=%u\",\n\t\t\t\tfromname, md->sender_port,\n\t\t\t\tke->isak_group);\n\t\t\treturn STF_FAIL + v2N_INVALID_KE_PAYLOAD;\n\t\t}\n\t}\n\n\t/* now. we need to go calculate the nonce, and the KE */\n\t{\n\t\tstruct ke_continuation *ke = alloc_thing(\n\t\t\tstruct ke_continuation,\n\t\t\t\"ikev2_inI1outR1 KE\");\n\t\tstf_status e;\n\n\t\tke->md = md;\n\t\tset_suspended(st, ke->md);\n\n\t\tif (!st->st_sec_in_use) {\n\t\t\tpcrc_init(&ke->ke_pcrc);\n\t\t\tke->ke_pcrc.pcrc_func =\n\t\t\t\tikev2_parent_inI1outR1_continue;\n\t\t\te = build_ke(&ke->ke_pcrc, st, st->st_oakley.group,\n\t\t\t\t     pcim_stranger_crypto);\n\t\t\tif (e != STF_SUSPEND && e != STF_INLINE) {\n\t\t\t\tloglog(RC_CRYPTOFAILED, \"system too busy\");\n\t\t\t\tdelete_state(st);\n\t\t\t}\n\t\t} else {\n\t\t\te =\n\t\t\t\tikev2_parent_inI1outR1_tail((struct\n\t\t\t\t\t\t\t     pluto_crypto_req_cont\n\t\t\t\t\t\t\t     *)ke,\n\t\t\t\t\t\t\t    NULL);\n\t\t}\n\n\t\treset_globals();\n\n\t\treturn e;\n\t}\n}\n\nstatic void ikev2_parent_inI1outR1_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct ke_continuation *ke = (struct ke_continuation *)pcrc;\n\tstruct msg_digest *md = ke->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent inI1outR1: calculated ke+nonce, sending R1\"));\n\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t\treturn;\n\t}\n\n\t/* XXX should check out ugh */\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\n\tpassert(st->st_suspended_md == ke->md);\n\tset_suspended(st, NULL); /* no longer connected or suspended */\n\n\tset_cur_state(st);\n\n\tst->st_calculating = FALSE;\n\n\te = ikev2_parent_inI1outR1_tail(pcrc, r);\n\n\tif (ke->md != NULL) {\n\t\tcomplete_v2_state_transition(&ke->md, e);\n\t\tif (ke->md)\n\t\t\trelease_md(ke->md);\n\t}\n\treset_globals();\n}\n\nstatic stf_status ikev2_parent_inI1outR1_tail(\n\tstruct pluto_crypto_req_cont *pcrc,\n\tstruct pluto_crypto_req *r)\n{\n\tstruct ke_continuation *ke = (struct ke_continuation *)pcrc;\n\tstruct msg_digest *md = ke->md;\n\tstruct payload_digest *const sa_pd = md->chain[ISAKMP_NEXT_v2SA];\n\tstruct state *const st = md->st;\n\tstruct connection *c = st->st_connection;\n\tpb_stream *keyex_pbs;\n\tint numvidtosend = 0;\n\n\tif (c->send_vendorid) {\n\t\tnumvidtosend++; /* we send Libreswan VID */\n\t}\n\t/* note that we don't update the state here yet */\n\n\t/* record first packet for later checking of signature */\n\tclonetochunk(st->st_firstpacket_him, md->message_pbs.start,\n\t\t     pbs_offset(\n\t\t\t     &md->message_pbs), \"saved first received packet\");\n\n\t/* make sure HDR is at start of a clean buffer */\n\tzero(reply_buffer);\n\tinit_pbs(&reply_stream, reply_buffer, sizeof(reply_buffer),\n\t\t \"reply packet\");\n\n\t/* HDR out */\n\t{\n\t\tstruct isakmp_hdr r_hdr = md->hdr;\n\n\t\tmemcpy(r_hdr.isa_rcookie, st->st_rcookie, COOKIE_SIZE);\n\t\tr_hdr.isa_np = ISAKMP_NEXT_v2SA;\n\t\t/* major will be same, but their minor might be higher */\n\t\tr_hdr.isa_version = build_ike_version();\n\t\tr_hdr.isa_flags &= ~ISAKMP_FLAGS_I;\n\t\tr_hdr.isa_flags |=  ISAKMP_FLAGS_R;\n\t\t/* PAUL shouldn't we set r_hdr.isa_msgid = [htonl](st->st_msgid);  here? */\n\t\tif (!out_struct(&r_hdr, &isakmp_hdr_desc, &reply_stream,\n\t\t\t\t&md->rbody))\n\t\t\treturn STF_INTERNAL_ERROR;\n\t}\n\n\t/* start of SA out */\n\t{\n\t\tstruct isakmp_sa r_sa = sa_pd->payload.sa;\n\t\tv2_notification_t rn;\n\t\tpb_stream r_sa_pbs;\n\n\t\tr_sa.isasa_np = ISAKMP_NEXT_v2KE; /* XXX */\n\t\tif (!out_struct(&r_sa, &ikev2_sa_desc, &md->rbody, &r_sa_pbs))\n\t\t\treturn STF_INTERNAL_ERROR;\n\n\t\t/* SA body in and out */\n\t\trn = ikev2_parse_parent_sa_body(&sa_pd->pbs,\n\t\t\t\t\t\t&sa_pd->payload.v2sa,\n\t\t\t\t\t\t&r_sa_pbs, st, FALSE);\n\n\t\tif (rn != v2N_NOTHING_WRONG)\n\t\t\treturn STF_FAIL + rn;\n\t}\n\n\t{\n\t\tv2_notification_t rn;\n\t\tchunk_t dc;\n\t\tkeyex_pbs = &md->chain[ISAKMP_NEXT_v2KE]->pbs;\n\t\t/* KE in */\n\t\trn =\n\t\t\taccept_KE(&st->st_gi, \"Gi\", st->st_oakley.group,\n\t\t\t\t  keyex_pbs);\n\t\tif (rn != v2N_NOTHING_WRONG) {\n\t\t\tu_int16_t group_number = htons(\n\t\t\t\tst->st_oakley.group->group);\n\t\t\tdc.ptr = (unsigned char *)&group_number;\n\t\t\tdc.len = 2;\n\t\t\tSEND_NOTIFICATION_AA(v2N_INVALID_KE_PAYLOAD, &dc);\n\t\t\tdelete_state(st);\n\t\t\treturn STF_FAIL + rn;\n\t\t}\n\t}\n\n\t/* Ni in */\n\tRETURN_STF_FAILURE(accept_v2_nonce(md, &st->st_ni, \"Ni\"));\n\n\t/* send KE */\n\tif (!ship_v2KE(st, r, &st->st_gr, &md->rbody, ISAKMP_NEXT_v2Nr))\n\t\treturn STF_INTERNAL_ERROR;\n\n\t/* send NONCE */\n\tunpack_nonce(&st->st_nr, r);\n\t{\n\t\tint np = numvidtosend > 0 ? ISAKMP_NEXT_v2V : ISAKMP_NEXT_v2NONE;\n\t\tstruct ikev2_generic in;\n\t\tpb_stream pb;\n\n\t\tmemset(&in, 0, sizeof(in));\n\t\tin.isag_np = np;\n\t\tin.isag_critical = ISAKMP_PAYLOAD_NONCRITICAL;\n\t\tif (DBGP(IMPAIR_SEND_BOGUS_ISAKMP_FLAG)) {\n\t\t\tlibreswan_log(\n\t\t\t\t\" setting bogus ISAKMP_PAYLOAD_LIBRESWAN_BOGUS flag in ISAKMP payload\");\n\t\t\tin.isag_critical |= ISAKMP_PAYLOAD_LIBRESWAN_BOGUS;\n\t\t}\n\n\t\tif (!out_struct(&in, &ikev2_nonce_desc, &md->rbody, &pb) ||\n\t\t    !out_raw(st->st_nr.ptr, st->st_nr.len, &pb, \"IKEv2 nonce\"))\n\t\t\treturn STF_INTERNAL_ERROR;\n\n\t\tclose_output_pbs(&pb);\n\t}\n\n\t/* Send VendrID if needed VID */\n\tif (c->send_vendorid) {\n\t\tconst char *myvid = ipsec_version_vendorid();\n\t\tint np = --numvidtosend >\n\t\t\t 0 ? ISAKMP_NEXT_v2V : ISAKMP_NEXT_v2NONE;\n\n\t\tif (!out_generic_raw(np, &isakmp_vendor_id_desc, &md->rbody,\n\t\t\t\t     myvid, strlen(myvid),\n\t\t\t\t     \"Vendor ID\"))\n\t\t\treturn STF_INTERNAL_ERROR;\n\t}\n\n\tclose_message(&md->rbody, st);\n\tclose_output_pbs(&reply_stream);\n\n\t/* keep it for a retransmit if necessary */\n\tfreeanychunk(st->st_tpacket);\n\tclonetochunk(st->st_tpacket, reply_stream.start,\n\t\t     pbs_offset(&reply_stream),\n\t\t     \"reply packet for ikev2_parent_inI1outR1_tail\");\n\n\t/* save packet for later signing */\n\tfreeanychunk(st->st_firstpacket_me);\n\tclonetochunk(st->st_firstpacket_me, reply_stream.start,\n\t\t     pbs_offset(&reply_stream), \"saved first packet\");\n\n\t/* note: retransimission is driven by initiator */\n\n\treturn STF_OK;\n}\n\n/*\n *\n ***************************************************************\n *                       PARENT_inR1                       *****\n ***************************************************************\n *  -\n *\n *\n */\nstatic void ikev2_parent_inR1outI2_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh);\n\nstatic stf_status ikev2_parent_inR1outI2_tail(\n\tstruct pluto_crypto_req_cont *pcrc,\n\tstruct pluto_crypto_req *r);\n\nstf_status ikev2parent_inR1outI2(struct msg_digest *md)\n{\n\tstruct state *st = md->st;\n\t/* struct connection *c = st->st_connection; */\n\tpb_stream *keyex_pbs;\n\n\t/* check if the responder replied with v2N with DOS COOKIE */\n\tif ( md->chain[ISAKMP_NEXT_v2N] &&\n\t     md->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type ==\n\t     v2N_COOKIE) {\n\t\tu_int8_t spisize;\n\t\tconst pb_stream *dc_pbs;\n\t\tDBG(DBG_CONTROLMORE,\n\t\t    DBG_log(\n\t\t\t    \"inR1OutI2 received a DOS v2N_COOKIE from the responder\");\n\t\t    DBG_log(\"resend the I1 with a cookie payload\"));\n\t\tspisize = md->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_spisize;\n\t\tdc_pbs = &md->chain[ISAKMP_NEXT_v2N]->pbs;\n\t\tclonetochunk(st->st_dcookie,  (dc_pbs->cur + spisize),\n\t\t\t     (pbs_left(\n\t\t\t\t      dc_pbs) - spisize),\n\t\t\t     \"saved received dcookie\");\n\n\t\tDBG(DBG_CONTROLMORE,\n\t\t    DBG_dump_chunk(\"dcookie received (instead of a R1):\",\n\t\t\t\t   st->st_dcookie);\n\t\t    DBG_log(\"next STATE_PARENT_I1 resend I1 with the dcookie\"));\n\n\t\tmd->svm = ikev2_parent_firststate();\n\n\t\tchange_state(st, STATE_PARENT_I1);\n\t\tst->st_msgid_lastack = INVALID_MSGID;\n\t\tmd->msgid_received = INVALID_MSGID; /* AAA hack  */\n\t\tst->st_msgid_nextuse = 0;\n\n\t\treturn ikev2_parent_outI1_common(md, st);\n\t}\n\n\t/*\n\t * If we did not get a KE payload, we cannot continue. There * should be\n\t * a Notify telling us why. We inform the user, but continue to try this\n\t * connection via regular retransmit intervals.\n\t */\n\tif ( md->chain[ISAKMP_NEXT_v2N]  &&\n\t     (md->chain[ISAKMP_NEXT_v2KE] == NULL)) {\n\t\tconst char *from_state_name = enum_name(&state_names,\n\t\t\t\t\t\t\tst->st_state);\n\t\tconst u_int16_t isan_type =\n\t\t\tmd->chain[ISAKMP_NEXT_v2N]->payload.v2n.isan_type;\n\t\tlibreswan_log(\"%s: received %s\",\n\t\t\t      from_state_name,\n\t\t\t      enum_name(&ikev2_notify_names, isan_type));\n\t\treturn STF_FAIL + isan_type;\n\t} else if ( md->chain[ISAKMP_NEXT_v2N]) {\n\t\tDBG(DBG_CONTROL, DBG_log(\"received a notify..\"));\n\t}\n\n\t/*\n\t * the responder sent us back KE, Gr, Nr, and it's our time to calculate\n\t * the shared key values.\n\t */\n\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\n\t\t    \"ikev2 parent inR1: calculating g^{xy} in order to send I2\"));\n\n\t/* KE in */\n\tkeyex_pbs = &md->chain[ISAKMP_NEXT_v2KE]->pbs;\n\tRETURN_STF_FAILURE(accept_KE(&st->st_gr, \"Gr\", st->st_oakley.group,\n\t\t\t\t     keyex_pbs));\n\n\t/* Ni in */\n\tRETURN_STF_FAILURE(accept_v2_nonce(md, &st->st_nr, \"Ni\"));\n\n\tif (md->chain[ISAKMP_NEXT_v2SA] == NULL) {\n\t\tlibreswan_log(\"No responder SA proposal found\");\n\t\treturn v2N_INVALID_SYNTAX;\n\t}\n\n\t/* process and confirm the SA selected */\n\t{\n\t\tstruct payload_digest *const sa_pd =\n\t\t\tmd->chain[ISAKMP_NEXT_v2SA];\n\t\tv2_notification_t rn;\n\n\t\t/* SA body in and out */\n\t\trn = ikev2_parse_parent_sa_body(&sa_pd->pbs,\n\t\t\t\t\t\t&sa_pd->payload.v2sa,\n\t\t\t\t\t\tNULL, st, FALSE);\n\n\t\tif (rn != v2N_NOTHING_WRONG)\n\t\t\treturn STF_FAIL + rn;\n\t}\n\n\t/* update state */\n\tikev2_update_counters(md);\n\n\t/* now. we need to go calculate the g^xy */\n\t{\n\t\tstruct dh_continuation *dh = alloc_thing(\n\t\t\tstruct dh_continuation,\n\t\t\t\"ikev2_inR1outI2 KE\");\n\t\tstf_status e;\n\n\t\tdh->md = md;\n\t\tset_suspended(st, dh->md);\n\n\t\tpcrc_init(&dh->dh_pcrc);\n\t\tdh->dh_pcrc.pcrc_func = ikev2_parent_inR1outI2_continue;\n\t\te = start_dh_v2(&dh->dh_pcrc, st, st->st_import, INITIATOR,\n\t\t\t\tst->st_oakley.groupnum);\n\t\tif (e != STF_SUSPEND && e != STF_INLINE) {\n\t\t\tloglog(RC_CRYPTOFAILED, \"system too busy\");\n\t\t\tdelete_state(st);\n\t\t}\n\n\t\treset_globals();\n\n\t\treturn e;\n\t}\n}\n\nstatic void ikev2_parent_inR1outI2_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct dh_continuation *dh = (struct dh_continuation *)pcrc;\n\tstruct msg_digest *md = dh->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent inR1outI2: calculating g^{xy}, sending I2\"));\n\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t\treturn;\n\t}\n\n\t/* XXX should check out ugh */\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\n\tpassert(st->st_suspended_md == dh->md);\n\tset_suspended(st, NULL); /* no longer connected or suspended */\n\n\tset_cur_state(st);\n\n\tst->st_calculating = FALSE;\n\n\te = ikev2_parent_inR1outI2_tail(pcrc, r);\n\n\tif (dh->md != NULL) {\n\t\tcomplete_v2_state_transition(&dh->md, e);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t}\n\treset_globals();\n}\n\nstatic void ikev2_padup_pre_encrypt(struct msg_digest *md,\n\t\t\t\t    pb_stream *e_pbs_cipher)\n{\n\tstruct state *st = md->st;\n\tstruct state *pst = st;\n\n\tif (st->st_clonedfrom != 0)\n\t\tpst = state_with_serialno(st->st_clonedfrom);\n\n\t/* pads things up to message size boundary */\n\t{\n\t\tsize_t blocksize = pst->st_oakley.encrypter->enc_blocksize;\n\t\tchar  *b = alloca(blocksize);\n\t\tunsigned int i;\n\t\tsize_t padding =  pad_up(pbs_offset(e_pbs_cipher), blocksize);\n\t\tif (padding == 0)\n\t\t\tpadding = blocksize;\n\n\t\tfor (i = 0; i < padding; i++)\n\t\t\tb[i] = i;\n\t\tout_raw(b, padding, e_pbs_cipher, \"padding and length\");\n\t}\n}\n\nstatic unsigned char *ikev2_authloc(struct msg_digest *md,\n\t\t\t\t    pb_stream *e_pbs)\n{\n\tunsigned char *b12;\n\tstruct state *st = md->st;\n\tstruct state *pst = st;\n\n\tif (st->st_clonedfrom != 0) {\n\t\tpst = state_with_serialno(st->st_clonedfrom);\n\t\tif ( pst == NULL)\n\t\t\treturn NULL;\n\t}\n\n\tb12 = e_pbs->cur;\n\tif (!out_zero(pst->st_oakley.integ_hasher->hash_integ_len, e_pbs,\n\t\t      \"length of truncated HMAC\"))\n\t\treturn NULL;\n\n\treturn b12;\n}\n\nstatic stf_status ikev2_encrypt_msg(struct msg_digest *md,\n\t\t\t\t    enum phase1_role init,\n\t\t\t\t    unsigned char *authstart,\n\t\t\t\t    unsigned char *iv,\n\t\t\t\t    unsigned char *encstart,\n\t\t\t\t    unsigned char *authloc,\n\t\t\t\t    pb_stream *e_pbs UNUSED,\n\t\t\t\t    pb_stream *e_pbs_cipher)\n{\n\tstruct state *st = md->st;\n\tstruct state *pst = st;\n\tchunk_t *cipherkey, *authkey;\n\n\tif (st->st_clonedfrom != 0)\n\t\tpst = state_with_serialno(st->st_clonedfrom);\n\n\tif (init == INITIATOR) {\n\t\tcipherkey = &pst->st_skey_ei;\n\t\tauthkey   = &pst->st_skey_ai;\n\t} else {\n\t\tcipherkey = &pst->st_skey_er;\n\t\tauthkey   = &pst->st_skey_ar;\n\t}\n\n\t/* encrypt the block */\n\t{\n\t\tsize_t blocksize = pst->st_oakley.encrypter->enc_blocksize;\n\t\tunsigned char *savediv = alloca(blocksize);\n\t\tunsigned int cipherlen = e_pbs_cipher->cur - encstart;\n\n\t\tDBG(DBG_CRYPT,\n\t\t    DBG_dump(\"data before encryption:\", encstart, cipherlen));\n\n\t\tmemcpy(savediv, iv, blocksize);\n\n\t\t/* now, encrypt */\n\t\t(st->st_oakley.encrypter->do_crypt)(encstart,\n\t\t\t\t\t\t    cipherlen,\n\t\t\t\t\t\t    cipherkey->ptr,\n\t\t\t\t\t\t    cipherkey->len,\n\t\t\t\t\t\t    savediv, TRUE);\n\n\t\tDBG(DBG_CRYPT,\n\t\t    DBG_dump(\"data after encryption:\", encstart, cipherlen));\n\t}\n\n\t/* okay, authenticate from beginning of IV */\n\t{\n\t\tstruct hmac_ctx ctx;\n\t\tDBG(DBG_PARSING, DBG_log(\"Inside authloc\"));\n\t\tDBG(DBG_CRYPT,\n\t\t    DBG_dump(\"authkey value: \", authkey->ptr, authkey->len));\n\t\thmac_init_chunk(&ctx, pst->st_oakley.integ_hasher, *authkey);\n\t\tDBG(DBG_PARSING, DBG_log(\"Inside authloc after init\"));\n\t\thmac_update(&ctx, authstart, authloc - authstart);\n\t\tDBG(DBG_PARSING, DBG_log(\"Inside authloc after update\"));\n\t\thmac_final(authloc, &ctx);\n\t\tDBG(DBG_PARSING, DBG_log(\"Inside authloc after final\"));\n\n\t\tDBG(DBG_PARSING, {\n\t\t\t    DBG_dump(\"data being hmac:\", authstart, authloc -\n\t\t\t\t     authstart);\n\t\t\t    DBG_dump(\"out calculated auth:\", authloc,\n\t\t\t\t     pst->st_oakley.integ_hasher->\n\t\t\t\t     hash_integ_len);\n\t\t    });\n\t}\n\n\treturn STF_OK;\n}\n\nstatic\nstf_status ikev2_decrypt_msg(struct msg_digest *md,\n\t\t\t     enum phase1_role init)\n{\n\tstruct state *st = md->st;\n\tunsigned char *encend;\n\tpb_stream     *e_pbs;\n\tunsigned int np;\n\tunsigned char *iv;\n\tchunk_t       *cipherkey, *authkey;\n\tunsigned char *authstart;\n\tstruct state *pst = st;\n\n\tif (st->st_clonedfrom != 0)\n\t\tpst = state_with_serialno(st->st_clonedfrom);\n\n\tif (init == INITIATOR) {\n\t\tcipherkey = &pst->st_skey_er;\n\t\tauthkey   = &pst->st_skey_ar;\n\t} else {\n\t\tcipherkey = &pst->st_skey_ei;\n\t\tauthkey   = &pst->st_skey_ai;\n\t}\n\n\te_pbs = &md->chain[ISAKMP_NEXT_v2E]->pbs;\n\tnp    = md->chain[ISAKMP_NEXT_v2E]->payload.generic.isag_np;\n\n\tauthstart = md->packet_pbs.start;\n\tiv     = e_pbs->cur;\n\tencend = e_pbs->roof - pst->st_oakley.integ_hasher->hash_integ_len;\n\n\t/* start by checking authenticator */\n\t{\n\t\tunsigned char  *b12 = alloca(\n\t\t\tpst->st_oakley.integ_hasher->hash_digest_len);\n\t\tstruct hmac_ctx ctx;\n\n\t\thmac_init_chunk(&ctx, pst->st_oakley.integ_hasher, *authkey);\n\t\thmac_update(&ctx, authstart, encend - authstart);\n\t\thmac_final(b12, &ctx);\n\n\t\tDBG(DBG_PARSING, {\n\t\t\t    DBG_dump(\"data being hmac:\", authstart, encend -\n\t\t\t\t     authstart);\n\t\t\t    DBG_dump(\"R2 calculated auth:\", b12,\n\t\t\t\t     pst->st_oakley.integ_hasher->\n\t\t\t\t     hash_integ_len);\n\t\t\t    DBG_dump(\"R2  provided  auth:\", encend,\n\t\t\t\t     pst->st_oakley.integ_hasher->\n\t\t\t\t     hash_integ_len);\n\t\t    });\n\n\t\t/* compare first 96 bits == 12 bytes */\n\t\t/* It is not always 96 bytes, it depends upon which integ algo is used*/\n\t\tif (memcmp(b12, encend,\n\t\t\t   pst->st_oakley.integ_hasher->hash_integ_len) != 0) {\n\t\t\tlibreswan_log(\"R2 failed to match authenticator\");\n\t\t\treturn STF_FAIL;\n\t\t}\n\t}\n\n\tDBG(DBG_PARSING, DBG_log(\"authenticator matched\"));\n\n\t/* decrypt */\n\t{\n\t\tsize_t blocksize = pst->st_oakley.encrypter->enc_blocksize;\n\t\tunsigned char *encstart  = iv + blocksize;\n\t\tunsigned int enclen    = encend - encstart;\n\t\tunsigned int padlen;\n\n\t\tDBG(DBG_CRYPT,\n\t\t    DBG_dump(\"data before decryption:\", encstart, enclen));\n\n\t\t/* now, decrypt */\n\t\t(pst->st_oakley.encrypter->do_crypt)(encstart,\n\t\t\t\t\t\t     enclen,\n\t\t\t\t\t\t     cipherkey->ptr,\n\t\t\t\t\t\t     cipherkey->len,\n\t\t\t\t\t\t     iv, FALSE);\n\n\t\tpadlen = encstart[enclen - 1];\n\t\tencend = encend - padlen + 1;\n\n\t\tif (encend < encstart) {\n\t\t\tlibreswan_log(\"invalid pad length: %u\", padlen);\n\t\t\treturn STF_FAIL;\n\t\t}\n\n\t\tDBG(DBG_CRYPT, {\n\t\t\t    DBG_dump(\"decrypted payload:\", encstart, enclen);\n\t\t\t    DBG_log(\"striping %u bytes as pad\", padlen + 1);\n\t\t    });\n\n\t\tinit_pbs(&md->clr_pbs, encstart, enclen - (padlen + 1),\n\t\t\t \"cleartext\");\n\t}\n\n\t{\n\t\tstf_status ret;\n\t\tret =\n\t\t\tikev2_process_payloads(md, &md->clr_pbs, st->st_state,\n\t\t\t\t\t       np);\n\t\tif (ret != STF_OK)\n\t\t\treturn ret;\n\t}\n\n\treturn STF_OK;\n}\n\nstatic stf_status ikev2_send_auth(struct connection *c,\n\t\t\t\t  struct state *st,\n\t\t\t\t  enum phase1_role role,\n\t\t\t\t  unsigned int np,\n\t\t\t\t  unsigned char *idhash_out,\n\t\t\t\t  pb_stream *outpbs)\n{\n\tstruct ikev2_a a;\n\tpb_stream a_pbs;\n\tstruct state *pst = st;\n\n\tif (st->st_clonedfrom != 0)\n\t\tpst = state_with_serialno(st->st_clonedfrom);\n\n\ta.isaa_critical = ISAKMP_PAYLOAD_NONCRITICAL;\n\tif (DBGP(IMPAIR_SEND_BOGUS_ISAKMP_FLAG)) {\n\t\tlibreswan_log(\n\t\t\t\" setting bogus ISAKMP_PAYLOAD_LIBRESWAN_BOGUS flag in ISAKMP payload\");\n\t\ta.isaa_critical |= ISAKMP_PAYLOAD_LIBRESWAN_BOGUS;\n\t}\n\n\ta.isaa_np = np;\n\n\tif (c->policy & POLICY_RSASIG) {\n\t\ta.isaa_type = v2_AUTH_RSA;\n\t} else if (c->policy & POLICY_PSK) {\n\t\ta.isaa_type = v2_AUTH_SHARED;\n\t} else {\n\t\t/* what else is there?... DSS not implemented. */\n\t\treturn STF_FAIL;\n\t}\n\n\tif (!out_struct(&a,\n\t\t\t&ikev2_a_desc,\n\t\t\toutpbs,\n\t\t\t&a_pbs))\n\t\treturn STF_INTERNAL_ERROR;\n\n\tif (c->policy & POLICY_RSASIG) {\n\t\tif (!ikev2_calculate_rsa_sha1(pst, role, idhash_out, &a_pbs))\n\t\t\treturn STF_FATAL + v2N_AUTHENTICATION_FAILED;\n\n\t} else if (c->policy & POLICY_PSK) {\n\t\tif (!ikev2_calculate_psk_auth(pst, role, idhash_out, &a_pbs))\n\t\t\treturn STF_FAIL + v2N_AUTHENTICATION_FAILED;\n\t}\n\n\tclose_output_pbs(&a_pbs);\n\treturn STF_OK;\n}\n\nstatic stf_status ikev2_parent_inR1outI2_tail(\n\tstruct pluto_crypto_req_cont *pcrc,\n\tstruct pluto_crypto_req *r)\n{\n\tstruct dh_continuation *dh = (struct dh_continuation *)pcrc;\n\tstruct msg_digest *md = dh->md;\n\tstruct state *st      = md->st;\n\tstruct connection *c  = st->st_connection;\n\tstruct ikev2_generic e;\n\tunsigned char *encstart;\n\tpb_stream e_pbs, e_pbs_cipher;\n\tunsigned char *iv;\n\tint ivsize;\n\tstf_status ret;\n\tunsigned char *idhash;\n\tunsigned char *authstart;\n\tstruct state *pst = st;\n\tbool send_cert = FALSE;\n\n\tfinish_dh_v2(st, r);\n\n\tif (DBGP(DBG_PRIVATE) && DBGP(DBG_CRYPT))\n\t\tikev2_log_parentSA(st);\n\n\tpst = st;\n\tst = duplicate_state(pst);\n\tst->st_msgid = htonl(pst->st_msgid_nextuse); /* PAUL: note ordering */\n\tinsert_state(st);\n\tmd->st = st;\n\tmd->pst = pst;\n\n\t/* parent had crypto failed, replace it with rekey! */\n\tdelete_event(pst);\n\tevent_schedule(EVENT_SA_REPLACE, c->sa_ike_life_seconds, pst);\n\n\t/* need to force parent state to I2 */\n\tchange_state(pst, STATE_PARENT_I2);\n\n\t/* record first packet for later checking of signature */\n\tclonetochunk(pst->st_firstpacket_him, md->message_pbs.start,\n\t\t     pbs_offset(\n\t\t\t     &md->message_pbs), \"saved first received packet\");\n\n\t/* beginning of data going out */\n\tauthstart = reply_stream.cur;\n\n\t/* make sure HDR is at start of a clean buffer */\n\tzero(reply_buffer);\n\tinit_pbs(&reply_stream, reply_buffer, sizeof(reply_buffer),\n\t\t \"reply packet\");\n\n\t/* HDR out */\n\t{\n\t\tstruct isakmp_hdr r_hdr = md->hdr;\n\n\t\tr_hdr.isa_np    = ISAKMP_NEXT_v2E;\n\t\tr_hdr.isa_xchg  = ISAKMP_v2_AUTH;\n\t\tr_hdr.isa_flags = ISAKMP_FLAGS_I;\n\t\tr_hdr.isa_msgid = st->st_msgid;\n\t\tmemcpy(r_hdr.isa_icookie, st->st_icookie, COOKIE_SIZE);\n\t\tmemcpy(r_hdr.isa_rcookie, st->st_rcookie, COOKIE_SIZE);\n\t\tif (!out_struct(&r_hdr, &isakmp_hdr_desc, &reply_stream,\n\t\t\t\t&md->rbody))\n\t\t\treturn STF_INTERNAL_ERROR;\n\t}\n\n\t/* insert an Encryption payload header */\n\te.isag_np = ISAKMP_NEXT_v2IDi;\n\te.isag_critical = ISAKMP_PAYLOAD_NONCRITICAL;\n\tif (DBGP(IMPAIR_SEND_BOGUS_ISAKMP_FLAG)) {\n\t\tlibreswan_log(\n\t\t\t\" setting bogus ISAKMP_PAYLOAD_LIBRESWAN_BOGUS flag in ISAKMP payload\");\n\t\te.isag_critical |= ISAKMP_PAYLOAD_LIBRESWAN_BOGUS;\n\t}\n\n\tif (!out_struct(&e, &ikev2_e_desc, &md->rbody, &e_pbs))\n\t\treturn STF_INTERNAL_ERROR;\n\n\t/* insert IV */\n\tiv     = e_pbs.cur;\n\tivsize = st->st_oakley.encrypter->iv_size;\n\tif (!out_zero(ivsize, &e_pbs, \"iv\"))\n\t\treturn STF_INTERNAL_ERROR;\n\n\tget_rnd_bytes(iv, ivsize);\n\n\t/* note where cleartext starts */\n\tinit_pbs(&e_pbs_cipher, e_pbs.cur, e_pbs.roof - e_pbs.cur,\n\t\t \"cleartext\");\n\te_pbs_cipher.container = &e_pbs;\n\te_pbs_cipher.desc = NULL;\n\te_pbs_cipher.cur = e_pbs.cur;\n\tencstart = e_pbs_cipher.cur;\n\n\t/* send out the IDi payload */\n\t{\n\t\tstruct ikev2_id r_id;\n\t\tpb_stream r_id_pbs;\n\t\tchunk_t id_b;\n\t\tstruct hmac_ctx id_ctx;\n\t\tunsigned char *id_start;\n\t\tunsigned int id_len;\n\n\t\thmac_init_chunk(&id_ctx, pst->st_oakley.prf_hasher,\n\t\t\t\tpst->st_skey_pi);\n\t\tbuild_id_payload((struct isakmp_ipsec_id *)&r_id, &id_b,\n\t\t\t\t &c->spd.this);\n\t\tr_id.isai_critical = ISAKMP_PAYLOAD_NONCRITICAL;\n\t\tif (DBGP(IMPAIR_SEND_BOGUS_ISAKMP_FLAG)) {\n\t\t\tlibreswan_log(\n\t\t\t\t\" setting bogus ISAKMP_PAYLOAD_LIBRESWAN_BOGUS flag in ISAKMP payload\");\n\t\t\tr_id.isai_critical |= ISAKMP_PAYLOAD_LIBRESWAN_BOGUS;\n\t\t}\n\n\t\t{       /* decide to send CERT payload */\n\t\t\tsend_cert = doi_send_ikev2_cert_thinking(st);\n\n\t\t\tif (send_cert)\n\t\t\t\tr_id.isai_np = ISAKMP_NEXT_v2CERT;\n\t\t\telse\n\t\t\t\tr_id.isai_np = ISAKMP_NEXT_v2AUTH;\n\t\t}\n\n\t\tid_start = e_pbs_cipher.cur;\n\t\tif (!out_struct(&r_id,\n\t\t\t\t&ikev2_id_desc,\n\t\t\t\t&e_pbs_cipher,\n\t\t\t\t&r_id_pbs) ||\n\t\t    !out_chunk(id_b, &r_id_pbs, \"my identity\"))\n\t\t\treturn STF_INTERNAL_ERROR;\n\n\t\t/* HASH of ID is not done over common header */\n\t\tid_start += 4;\n\n\t\tclose_output_pbs(&r_id_pbs);\n\n\t\t/* calculate hash of IDi for AUTH below */\n\t\tid_len = e_pbs_cipher.cur - id_start;\n\t\tDBG(DBG_CRYPT, DBG_dump_chunk(\"idhash calc pi\",\n\t\t\t\t\t      pst->st_skey_pi));\n\t\tDBG(DBG_CRYPT, DBG_dump(\"idhash calc I2\", id_start, id_len));\n\t\thmac_update(&id_ctx, id_start, id_len);\n\t\tidhash = alloca(pst->st_oakley.prf_hasher->hash_digest_len);\n\t\thmac_final(idhash, &id_ctx);\n\t}\n\n\t/* send [CERT,] payload RFC 4306 3.6, 1.2) */\n\t{\n\n\t\tif (send_cert) {\n\t\t\tstf_status certstat = ikev2_send_cert( st, md,\n\t\t\t\t\t\t\t       INITIATOR,\n\t\t\t\t\t\t\t       ISAKMP_NEXT_v2AUTH,\n\t\t\t\t\t\t\t       &e_pbs_cipher);\n\t\t\tif (certstat != STF_OK)\n\t\t\t\treturn certstat;\n\t\t}\n\t}\n\n\t/* send out the AUTH payload */\n\t{\n\t\tlset_t policy;\n\t\tstruct connection *c0 = first_pending(pst, &policy,\n\t\t\t\t\t\t      &st->st_whack_sock);\n\t\tunsigned int np = (c0 ? ISAKMP_NEXT_v2SA : ISAKMP_NEXT_v2NONE);\n\t\tDBG(DBG_CONTROL,\n\t\t    DBG_log(\" payload after AUTH will be %s\",\n\t\t\t    (c0) ? \"ISAKMP_NEXT_v2SA\" :\n\t\t\t    \"ISAKMP_NEXT_v2NONE/NOTIFY\"));\n\n\t\tstf_status authstat = ikev2_send_auth(c, st,\n\t\t\t\t\t\t      INITIATOR,\n\t\t\t\t\t\t      np,\n\t\t\t\t\t\t      idhash, &e_pbs_cipher);\n\t\tif (authstat != STF_OK)\n\t\t\treturn authstat;\n\n\t\t/*\n\t\t * now, find an eligible child SA from the pending list, and emit\n\t\t * SA2i, TSi and TSr and (v2N_USE_TRANSPORT_MODE notification in transport mode) for it .\n\t\t */\n\t\tif (c0) {\n\t\t\tchunk_t child_spi, notify_data;\n\t\t\tst->st_connection = c0;\n\n\t\t\tikev2_emit_ipsec_sa(md, &e_pbs_cipher,\n\t\t\t\t\t    ISAKMP_NEXT_v2TSi, c0, policy);\n\n\t\t\tst->st_ts_this = ikev2_end_to_ts(&c0->spd.this);\n\t\t\tst->st_ts_that = ikev2_end_to_ts(&c0->spd.that);\n\n\t\t\tikev2_calc_emit_ts(md, &e_pbs_cipher, INITIATOR, c0,\n\t\t\t\t\t   policy);\n\n\t\t\tif ( !(st->st_connection->policy & POLICY_TUNNEL) ) {\n\t\t\t\tDBG_log(\n\t\t\t\t\t\"Initiator child policy is transport mode, sending v2N_USE_TRANSPORT_MODE\");\n\t\t\t\tmemset(&child_spi, 0, sizeof(child_spi));\n\t\t\t\tmemset(&notify_data, 0, sizeof(notify_data));\n\t\t\t\tship_v2N(ISAKMP_NEXT_v2NONE,\n\t\t\t\t\t ISAKMP_PAYLOAD_NONCRITICAL, 0,\n\t\t\t\t\t &child_spi,\n\t\t\t\t\t v2N_USE_TRANSPORT_MODE, &notify_data,\n\t\t\t\t\t &e_pbs_cipher);\n\t\t\t}\n\t\t} else {\n\t\t\tlibreswan_log(\n\t\t\t\t\"no pending SAs found, PARENT SA keyed only\");\n\t\t}\n\t}\n\n\t/*\n\t * need to extend the packet so that we will know how big it is\n\t * since the length is under the integrity check\n\t */\n\tikev2_padup_pre_encrypt(md, &e_pbs_cipher);\n\tclose_output_pbs(&e_pbs_cipher);\n\n\t{\n\t\tunsigned char *authloc = ikev2_authloc(md, &e_pbs);\n\n\t\tif (authloc == NULL)\n\t\t\treturn STF_INTERNAL_ERROR;\n\n\t\tclose_output_pbs(&e_pbs);\n\t\tclose_output_pbs(&md->rbody);\n\t\tclose_output_pbs(&reply_stream);\n\n\t\tret = ikev2_encrypt_msg(md, INITIATOR,\n\t\t\t\t\tauthstart,\n\t\t\t\t\tiv, encstart, authloc,\n\t\t\t\t\t&e_pbs, &e_pbs_cipher);\n\t\tif (ret != STF_OK)\n\t\t\treturn ret;\n\t}\n\n\t/* keep it for a retransmit if necessary, but on initiator\n\t * we never do that, but send_ike_msg() uses it.\n\t */\n\tfreeanychunk(pst->st_tpacket);\n\tclonetochunk(pst->st_tpacket, reply_stream.start,\n\t\t     pbs_offset(&reply_stream),\n\t\t     \"reply packet for ikev2_parent_outI1\");\n\n\t/*\n\t * Delete previous retransmission event.\n\t */\n\tdelete_event(st);\n\tevent_schedule(EVENT_v2_RETRANSMIT, EVENT_RETRANSMIT_DELAY_0, st);\n\n\treturn STF_OK;\n\n}\n\n/*\n *\n ***************************************************************\n *                       PARENT_inI2                       *****\n ***************************************************************\n *  -\n *\n *\n */\nstatic void ikev2_parent_inI2outR2_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh);\n\nstatic stf_status ikev2_parent_inI2outR2_tail(\n\tstruct pluto_crypto_req_cont *pcrc,\n\tstruct pluto_crypto_req *r);\n\nstf_status ikev2parent_inI2outR2(struct msg_digest *md)\n{\n\tstruct state *st = md->st;\n\n\t/* struct connection *c = st->st_connection; */\n\n\t/*\n\t * the initiator sent us an encrypted payload. We need to calculate\n\t * our g^xy, and skeyseed values, and then decrypt the payload.\n\t */\n\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\n\t\t    \"ikev2 parent inI2outR2: calculating g^{xy} in order to decrypt I2\"));\n\n\t/* verify that there is in fact an encrypted payload */\n\tif (!md->chain[ISAKMP_NEXT_v2E]) {\n\t\tlibreswan_log(\"R2 state should receive an encrypted payload\");\n\t\treset_globals(); /* XXX suspicious - why was this deemed neccessary? */\n\t\treturn STF_FATAL;\n\t}\n\n\t/* now. we need to go calculate the g^xy */\n\t{\n\t\tstruct dh_continuation *dh = alloc_thing(\n\t\t\tstruct dh_continuation,\n\t\t\t\"ikev2_inI2outR2 KE\");\n\t\tstf_status e;\n\n\t\tdh->md = md;\n\t\tset_suspended(st, dh->md);\n\n\t\tpcrc_init(&dh->dh_pcrc);\n\t\tdh->dh_pcrc.pcrc_func = ikev2_parent_inI2outR2_continue;\n\t\te = start_dh_v2(&dh->dh_pcrc, st, st->st_import, RESPONDER,\n\t\t\t\tst->st_oakley.groupnum);\n\t\tif (e != STF_SUSPEND && e != STF_INLINE) {\n\t\t\tloglog(RC_CRYPTOFAILED, \"system too busy\");\n\t\t\tdelete_state(st);\n\t\t}\n\n\t\treset_globals();\n\n\t\treturn e;\n\t}\n}\n\nstatic void ikev2_parent_inI2outR2_continue(struct pluto_crypto_req_cont *pcrc,\n\t\t\t\t\t    struct pluto_crypto_req *r,\n\t\t\t\t\t    err_t ugh)\n{\n\tstruct dh_continuation *dh = (struct dh_continuation *)pcrc;\n\tstruct msg_digest *md = dh->md;\n\tstruct state *const st = md->st;\n\tstf_status e;\n\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"ikev2 parent inI2outR2: calculating g^{xy}, sending R2\"));\n\n\tif (st == NULL) {\n\t\tloglog(RC_LOG_SERIOUS,\n\t\t       \"%s: Request was disconnected from state\",\n\t\t       __FUNCTION__);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t\treturn;\n\t}\n\n\t/* XXX should check out ugh */\n\tpassert(ugh == NULL);\n\tpassert(cur_state == NULL);\n\tpassert(st != NULL);\n\n\tpassert(st->st_suspended_md == dh->md);\n\tset_suspended(st, NULL); /* no longer connected or suspended */\n\n\tset_cur_state(st);\n\n\tst->st_calculating = FALSE;\n\n\te = ikev2_parent_inI2outR2_tail(pcrc, r);\n\tif ( e > STF_FAIL) {\n\t\t/* we do not send a notify because we are the initiator that could be responding to an error notification */\n\t\tint v2_notify_num = e - STF_FAIL;\n\t\tDBG_log(\n\t\t\t\"ikev2_parent_inI2outR2_tail returned STF_FAIL with %s\",\n\t\t\tenum_name(&ikev2_notify_names, v2_notify_num));\n\t} else if ( e != STF_OK) {\n\t\tDBG_log(\"ikev2_parent_inI2outR2_tail returned %s\",\n\t\t\tenum_name(&stfstatus_name, e));\n\t}\n\n\tif (dh->md != NULL) {\n\t\tcomplete_v2_state_transition(&dh->md, e);\n\t\tif (dh->md)\n\t\t\trelease_md(dh->md);\n\t}\n\treset_globals();\n}\n\nstatic stf_status ikev2_parent_inI2outR2_tail(\n\tstruct pluto_crypto_req_cont *pcrc,\n\tstruct pluto_crypto_req *r)\n{\n\tstruct dh_continuation *dh = (struct dh_continuation *)pcrc;\n\tstruct msg_digest *md  = dh->md;\n\tstruct state *const st = md->st;\n\tstruct connection *c   = st->st_connection;\n\tunsigned char *idhash_in, *idhash_out;\n\tunsigned char *authstart;\n\tunsigned int np;\n\tint v2_notify_num = 0;\n\n\t/* extract calculated values from r */\n\tfinish_dh_v2(st, r);\n\n\tif (DBGP(DBG_PRIVATE) && DBGP(DBG_CRYPT))\n\t\tikev2_log_parentSA(st);\n\n\t/* decrypt things. */\n\t{\n\t\tstf_status ret;\n\t\tret = ikev2_decrypt_msg(md, RESPONDER);\n\t\tif (ret != STF_OK)\n\t\t\treturn ret;\n\t}\n\n\t/*Once the message has been decrypted, then only we can check for auth payload*/\n\t/*check the presense of auth payload now so that it does not crash in rehash_state if auth payload has not been received*/\n\tif (!md->chain[ISAKMP_NEXT_v2AUTH]) {\n\t\tlibreswan_log(\"no authentication payload found\");\n\t\treturn STF_FAIL;\n\t}\n\n\tif (!ikev2_decode_peer_id(md, RESPONDER))\n\t\treturn STF_FAIL + v2N_AUTHENTICATION_FAILED;\n\n\t{\n\t\tstruct hmac_ctx id_ctx;\n\t\tconst pb_stream *id_pbs = &md->chain[ISAKMP_NEXT_v2IDi]->pbs;\n\t\tunsigned char *idstart = id_pbs->start + 4;\n\t\tunsigned int idlen  = pbs_room(id_pbs) - 4;\n\n\t\thmac_init_chunk(&id_ctx, st->st_oakley.prf_hasher,\n\t\t\t\tst->st_skey_pi);\n\n\t\t/* calculate hash of IDi for AUTH below */\n\t\tDBG(DBG_CRYPT,\n\t\t    DBG_dump_chunk(\"idhash verify pi\", st->st_skey_pi));\n\t\tDBG(DBG_CRYPT, DBG_dump(\"idhash verify I2\", idstart, idlen));\n\t\thmac_update(&id_ctx, idstart, idlen);\n\t\tidhash_in = alloca(st->st_oakley.prf_hasher->hash_digest_len);\n\t\thmac_final(idhash_in, &id_ctx);\n\t}\n\n\t/* process CERT payload */\n\t{\n\t\tif (md->chain[ISAKMP_NEXT_v2CERT]) {\n\t\t\t/* should we check if we should accept a cert payload ?\n\t\t\t *  has_preloaded_public_key(st)\n\t\t\t */\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\n\t\t\t\t    \"has a v2_CERT payload going to process it \"));\n\t\t\tikev2_decode_cert(md);\n\t\t}\n\t}\n\n\t/* process CERTREQ payload */\n\tif (md->chain[ISAKMP_NEXT_v2CERTREQ]) {\n\t\tDBG(DBG_CONTROLMORE,\n\t\t    DBG_log(\"has a v2CERTREQ payload going to decode it\"));\n\t\tikev2_decode_cr(md, &st->st_connection->requested_ca);\n\t}\n\n\t/* process AUTH payload now */\n\t/* now check signature from RSA key */\n\tswitch (md->chain[ISAKMP_NEXT_v2AUTH]->payload.v2a.isaa_type) {\n\tcase v2_AUTH_RSA:\n\t{\n\t\tstf_status authstat = ikev2_verify_rsa_sha1(st,\n\t\t\t\t\t\t\t    RESPONDER,\n\t\t\t\t\t\t\t    idhash_in,\n\t\t\t\t\t\t\t    NULL,       /* keys from DNS */\n\t\t\t\t\t\t\t    NULL,       /* gateways from DNS */\n\t\t\t\t\t\t\t    &md->chain[\n\t\t\t\t\t\t\t\t    ISAKMP_NEXT_v2AUTH]->pbs);\n\t\tif (authstat != STF_OK) {\n\t\t\tlibreswan_log(\"RSA authentication failed\");\n\t\t\tSEND_NOTIFICATION(v2N_AUTHENTICATION_FAILED);\n\t\t\treturn STF_FATAL;\n\t\t}\n\t\tbreak;\n\t}\n\tcase v2_AUTH_SHARED:\n\t{\n\t\tstf_status authstat = ikev2_verify_psk_auth(st,\n\t\t\t\t\t\t\t    RESPONDER,\n\t\t\t\t\t\t\t    idhash_in,\n\t\t\t\t\t\t\t    &md->chain[\n\t\t\t\t\t\t\t\t    ISAKMP_NEXT_v2AUTH]->pbs);\n\t\tif (authstat != STF_OK) {\n\t\t\tlibreswan_log(\n\t\t\t\t\"PSK authentication failed AUTH mismatch!\");\n\t\t\tSEND_NOTIFICATION(v2N_AUTHENTICATION_FAILED);\n\t\t\treturn STF_FATAL;\n\t\t}\n\t\tbreak;\n\t}\n\tdefault:\n\t\tlibreswan_log(\"authentication method: %s not supported\",\n\t\t\t      enum_name(&ikev2_auth_names,\n\t\t\t\t\tmd->chain[ISAKMP_NEXT_v2AUTH]->payload.\n\t\t\t\t\tv2a.isaa_type));\n\t\treturn STF_FATAL;\n\t}\n\n\t/* Is there a notify about an error ? */\n\tif (md->chain[ISAKMP_NEXT_v2N] != NULL) {\n\t\tDBG(DBG_CONTROL,\n\t\t    DBG_log(\n\t\t\t    \" notify payload detected, should be processed....\"));\n\t}\n\n\t/* good. now create child state */\n\t/* note: as we will switch to child state, we force the parent to the\n\t * new state now */\n\tchange_state(st, STATE_PARENT_R2);\n\tc->newest_isakmp_sa = st->st_serialno;\n\n\tdelete_event(st);\n\tevent_schedule(EVENT_SA_REPLACE, c->sa_ike_life_seconds, st);\n\n\tauthstart = reply_stream.cur;\n\t/* send response */\n\t{\n\t\tunsigned char *encstart;\n\t\tunsigned char *iv;\n\t\tunsigned int ivsize;\n\t\tstruct ikev2_generic e;\n\t\tpb_stream e_pbs, e_pbs_cipher;\n\t\tstf_status ret;\n\t\tbool send_cert = FALSE;\n\n\t\t/* make sure HDR is at start of a clean buffer */\n\t\tzero(reply_buffer);\n\t\tinit_pbs(&reply_stream, reply_buffer, sizeof(reply_buffer),\n\t\t\t \"reply packet\");\n\n\t\t/* HDR out */\n\t\t{\n\t\t\tstruct isakmp_hdr r_hdr = md->hdr;\n\n\t\t\tr_hdr.isa_np    = ISAKMP_NEXT_v2E;\n\t\t\tr_hdr.isa_xchg  = ISAKMP_v2_AUTH;\n\t\t\tr_hdr.isa_flags = ISAKMP_FLAGS_R;\n\t\t\tmemcpy(r_hdr.isa_icookie, st->st_icookie, COOKIE_SIZE);\n\t\t\tmemcpy(r_hdr.isa_rcookie, st->st_rcookie, COOKIE_SIZE);\n\t\t\tif (!out_struct(&r_hdr, &isakmp_hdr_desc,\n\t\t\t\t\t&reply_stream, &md->rbody))\n\t\t\t\treturn STF_INTERNAL_ERROR;\n\t\t}\n\n\t\t/* insert an Encryption payload header */\n\t\te.isag_np = ISAKMP_NEXT_v2IDr;\n\t\te.isag_critical = ISAKMP_PAYLOAD_NONCRITICAL;\n\n\t\tif (!out_struct(&e, &ikev2_e_desc, &md->rbody, &e_pbs))\n\t\t\treturn STF_INTERNAL_ERROR;\n\n\t\t/* insert IV */\n\t\tiv     = e_pbs.cur;\n\t\tivsize = st->st_oakley.encrypter->iv_size;\n\t\tif (!out_zero(ivsize, &e_pbs, \"iv\"))\n\t\t\treturn STF_INTERNAL_ERROR;\n\n\t\tget_rnd_bytes(iv, ivsize);\n\n\t\t/* note where cleartext starts */\n\t\tinit_pbs(&e_pbs_cipher, e_pbs.cur, e_pbs.roof - e_pbs.cur,\n\t\t\t \"cleartext\");\n\t\te_pbs_cipher.container = &e_pbs;\n\t\te_pbs_cipher.desc = NULL;\n\t\te_pbs_cipher.cur = e_pbs.cur;\n\t\tencstart = e_pbs_cipher.cur;\n\n\t\t/* decide to send CERT payload before we generate IDr */\n\t\tsend_cert = doi_send_ikev2_cert_thinking(st);\n\n\t\t/* send out the IDr payload */\n\t\t{\n\t\t\tstruct ikev2_id r_id;\n\t\t\tpb_stream r_id_pbs;\n\t\t\tchunk_t id_b;\n\t\t\tstruct hmac_ctx id_ctx;\n\t\t\tunsigned char *id_start;\n\t\t\tunsigned int id_len;\n\n\t\t\thmac_init_chunk(&id_ctx, st->st_oakley.prf_hasher,\n\t\t\t\t\tst->st_skey_pr);\n\t\t\tbuild_id_payload((struct isakmp_ipsec_id *)&r_id,\n\t\t\t\t\t &id_b,\n\t\t\t\t\t &c->spd.this);\n\t\t\tr_id.isai_critical = ISAKMP_PAYLOAD_NONCRITICAL;\n\n\t\t\tif (send_cert)\n\t\t\t\tr_id.isai_np = ISAKMP_NEXT_v2CERT;\n\t\t\telse\n\t\t\t\tr_id.isai_np = ISAKMP_NEXT_v2AUTH;\n\n\t\t\tid_start = e_pbs_cipher.cur;\n\n\t\t\tif (!out_struct(&r_id,\n\t\t\t\t\t&ikev2_id_desc,\n\t\t\t\t\t&e_pbs_cipher,\n\t\t\t\t\t&r_id_pbs) ||\n\t\t\t    !out_chunk(id_b, &r_id_pbs, \"my identity\"))\n\t\t\t\treturn STF_INTERNAL_ERROR;\n\n\t\t\tclose_output_pbs(&r_id_pbs);\n\n\t\t\tid_start += 4;\n\n\t\t\t/* calculate hash of IDi for AUTH below */\n\t\t\tid_len = e_pbs_cipher.cur - id_start;\n\t\t\tDBG(DBG_CRYPT,\n\t\t\t    DBG_dump_chunk(\"idhash calc pr\", st->st_skey_pr));\n\t\t\tDBG(DBG_CRYPT,\n\t\t\t    DBG_dump(\"idhash calc R2\", id_start, id_len));\n\t\t\thmac_update(&id_ctx, id_start, id_len);\n\t\t\tidhash_out = alloca(\n\t\t\t\tst->st_oakley.prf_hasher->hash_digest_len);\n\t\t\thmac_final(idhash_out, &id_ctx);\n\t\t}\n\n\t\tDBG(DBG_CONTROLMORE,\n\t\t    DBG_log(\"assembled IDr payload -- CERT next\"));\n\n\t\t/* send CERT payload RFC 4306 3.6, 1.2:([CERT,] ) */\n\t\tif (send_cert) {\n\t\t\tstf_status certstat = ikev2_send_cert(st, md,\n\t\t\t\t\t\t\t      RESPONDER,\n\t\t\t\t\t\t\t      ISAKMP_NEXT_v2AUTH,\n\t\t\t\t\t\t\t      &e_pbs_cipher);\n\t\t\tif (certstat != STF_OK)\n\t\t\t\treturn certstat;\n\t\t}\n\n\t\t/* authentication good, see if there is a child SA being proposed */\n\t\tif (md->chain[ISAKMP_NEXT_v2SA] == NULL ||\n\t\t    md->chain[ISAKMP_NEXT_v2TSi] == NULL ||\n\t\t    md->chain[ISAKMP_NEXT_v2TSr] == NULL) {\n\n\t\t\t/* initiator didn't propose anything. Weird. Try unpending out end. */\n\t\t\t/* UNPEND XXX */\n\t\t\tlibreswan_log(\"No CHILD SA proposals received.\");\n\t\t\tnp = ISAKMP_NEXT_v2NONE;\n\t\t} else {\n\t\t\tDBG_log(\"CHILD SA proposals received\");\n\t\t\tlibreswan_log(\n\t\t\t\t\"PAUL: this is where we have to check the TSi/TSr\");\n\t\t\tnp = ISAKMP_NEXT_v2SA;\n\t\t}\n\n\t\tDBG(DBG_CONTROLMORE,\n\t\t    DBG_log(\"going to assemble AUTH payload\"));\n\n\t\t/* now send AUTH payload */\n\t\t{\n\t\t\tstf_status authstat = ikev2_send_auth(c, st,\n\t\t\t\t\t\t\t      RESPONDER, np,\n\t\t\t\t\t\t\t      idhash_out,\n\t\t\t\t\t\t\t      &e_pbs_cipher);\n\t\t\tif (authstat != STF_OK)\n\t\t\t\treturn authstat;\n\t\t}\n\n\t\tif (np == ISAKMP_NEXT_v2SA) {\n\t\t\t/* must have enough to build an CHILD_SA */\n\t\t\tret = ikev2_child_sa_respond(md, RESPONDER,\n\t\t\t\t\t\t     &e_pbs_cipher);\n\t\t\tif (ret > STF_FAIL) {\n\t\t\t\tv2_notify_num = ret - STF_FAIL;\n\t\t\t\tDBG(DBG_CONTROL,\n\t\t\t\t    DBG_log(\n\t\t\t\t\t    \"ikev2_child_sa_respond returned STF_FAIL with %s\",\n\t\t\t\t\t    enum_name(&ikev2_notify_names,\n\t\t\t\t\t\t      v2_notify_num)));\n\t\t\t\tnp = ISAKMP_NEXT_v2NONE;\n\t\t\t} else if (ret != STF_OK) {\n\t\t\t\tDBG_log(\"ikev2_child_sa_respond returned %s\", enum_name(\n\t\t\t\t\t\t&stfstatus_name,\n\t\t\t\t\t\tret));\n\t\t\t\tnp = ISAKMP_NEXT_v2NONE;\n\t\t\t}\n\t\t}\n\n\t\tikev2_padup_pre_encrypt(md, &e_pbs_cipher);\n\t\tclose_output_pbs(&e_pbs_cipher);\n\n\t\t{\n\t\t\tunsigned char *authloc = ikev2_authloc(md, &e_pbs);\n\n\t\t\tif (authloc == NULL)\n\t\t\t\treturn STF_INTERNAL_ERROR;\n\n\t\t\tclose_output_pbs(&e_pbs);\n\n\t\t\tclose_output_pbs(&md->rbody);\n\t\t\tclose_output_pbs(&reply_stream);\n\n\t\t\tret = ikev2_encrypt_msg(md, RESPONDER,\n\t\t\t\t\t\tauthstart,\n\t\t\t\t\t\tiv, encstart, authloc,\n\t\t\t\t\t\t&e_pbs, &e_pbs_cipher);\n\t\t\tif (ret != STF_OK)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* keep it for a retransmit if necessary */\n\tfreeanychunk(st->st_tpacket);\n\tclonetochunk(st->st_tpacket, reply_stream.start,\n\t\t     pbs_offset(&reply_stream),\n\t\t     \"reply packet for ikev2_parent_inI2outR2_tail\");\n\n\t/* note: retransimission is driven by initiator */\n\n\t/* if the child failed, delete its state here - we sent the packet */\n\t/* PAUL */\n\treturn STF_OK;\n\n}\n\n/*\n *\n ***************************************************************\n *                       PARENT_inR2    (I3 state)         *****\n ***************************************************************\n *  - there are no cryptographic continuations, but be certain\n *    that there will have to be DNS continuations, but they\n *    just aren't implemented yet.\n *\n */\nstf_status ikev2parent_inR2(struct msg_digest *md)\n{\n\tstruct state *st = md->st;\n\tstruct connection *c = st->st_connection;\n\tunsigned char *idhash_in;\n\tstruct state *pst = st;\n\n\tif (st->st_clonedfrom != 0)\n\t\tpst = state_with_serialno(st->st_clonedfrom);\n\n\t/*\n\t * the initiator sent us an encrypted payload. We need to calculate\n\t * our g^xy, and skeyseed values, and then decrypt the payload.\n\t */\n\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\n\t\t    \"ikev2 parent inR2: calculating g^{xy} in order to decrypt I2\"));\n\n\t/* verify that there is in fact an encrypted payload */\n\tif (!md->chain[ISAKMP_NEXT_v2E]) {\n\t\tlibreswan_log(\"R2 state should receive an encrypted payload\");\n\t\treturn STF_FATAL;\n\t}\n\n\t/* decrypt things. */\n\t{\n\t\tstf_status ret;\n\t\tret = ikev2_decrypt_msg(md, INITIATOR);\n\t\tif (ret != STF_OK)\n\t\t\treturn ret;\n\t}\n\n\tif (!ikev2_decode_peer_id(md, INITIATOR))\n\t\treturn STF_FAIL + v2N_AUTHENTICATION_FAILED;\n\n\t{\n\t\tstruct hmac_ctx id_ctx;\n\t\tconst pb_stream *id_pbs = &md->chain[ISAKMP_NEXT_v2IDr]->pbs;\n\t\tunsigned char *idstart = id_pbs->start + 4;\n\t\tunsigned int idlen  = pbs_room(id_pbs) - 4;\n\n\t\thmac_init_chunk(&id_ctx, pst->st_oakley.prf_hasher,\n\t\t\t\tpst->st_skey_pr);\n\n\t\t/* calculate hash of IDr for AUTH below */\n\t\tDBG(DBG_CRYPT,\n\t\t    DBG_dump_chunk(\"idhash verify pr\", pst->st_skey_pr));\n\t\tDBG(DBG_CRYPT, DBG_dump(\"idhash auth R2\", idstart, idlen));\n\t\thmac_update(&id_ctx, idstart, idlen);\n\t\tidhash_in = alloca(pst->st_oakley.prf_hasher->hash_digest_len);\n\t\thmac_final(idhash_in, &id_ctx);\n\t}\n\n\tif (md->chain[ISAKMP_NEXT_v2CERT]) {\n\t\t/* should we check if we should accept a cert payload ?\n\t\t *  has_preloaded_public_key(st)\n\t\t */\n\t\t/* in v1 code it is  decode_cert(struct msg_digest *md) */\n\t\tDBG(DBG_CONTROLMORE,\n\t\t    DBG_log(\"has a v2_CERT payload going to decode it\"));\n\t\tikev2_decode_cert(md);\n\t}\n\n\t/* process AUTH payload */\n\tif (!md->chain[ISAKMP_NEXT_v2AUTH]) {\n\t\tlibreswan_log(\"no authentication payload found\");\n\t\treturn STF_FAIL;\n\t}\n\n\t/* now check signature from RSA key */\n\tswitch (md->chain[ISAKMP_NEXT_v2AUTH]->payload.v2a.isaa_type) {\n\tcase v2_AUTH_RSA:\n\t{\n\t\tstf_status authstat = ikev2_verify_rsa_sha1(pst,\n\t\t\t\t\t\t\t    INITIATOR,\n\t\t\t\t\t\t\t    idhash_in,\n\t\t\t\t\t\t\t    NULL,       /* keys from DNS */\n\t\t\t\t\t\t\t    NULL,       /* gateways from DNS */\n\t\t\t\t\t\t\t    &md->chain[\n\t\t\t\t\t\t\t\t    ISAKMP_NEXT_v2AUTH]->pbs);\n\t\tif (authstat != STF_OK) {\n\t\t\tlibreswan_log(\"authentication failed\");\n\t\t\tSEND_NOTIFICATION(v2N_AUTHENTICATION_FAILED);\n\t\t\treturn STF_FAIL;\n\t\t}\n\t\tbreak;\n\t}\n\tcase v2_AUTH_SHARED:\n\t{\n\t\tstf_status authstat = ikev2_verify_psk_auth(pst,\n\t\t\t\t\t\t\t    INITIATOR,\n\t\t\t\t\t\t\t    idhash_in,\n\t\t\t\t\t\t\t    &md->chain[\n\t\t\t\t\t\t\t\t    ISAKMP_NEXT_v2AUTH]->pbs);\n\t\tif (authstat != STF_OK) {\n\t\t\tlibreswan_log(\"PSK authentication failed\");\n\t\t\tSEND_NOTIFICATION(v2N_AUTHENTICATION_FAILED);\n\t\t\treturn STF_FAIL;\n\t\t}\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\tlibreswan_log(\"authentication method: %s not supported\",\n\t\t\t      enum_name(&ikev2_auth_names,\n\t\t\t\t\tmd->chain[ISAKMP_NEXT_v2AUTH]->payload.\n\t\t\t\t\tv2a.isaa_type));\n\t\treturn STF_FAIL;\n\t}\n\n\t/*\n\t * update the parent state to make sure that it knows we have\n\t * authenticated properly.\n\t */\n\tchange_state(pst, STATE_PARENT_I3);\n\tc->newest_isakmp_sa = pst->st_serialno;\n\n\t/* authentication good, see if there is a child SA available */\n\tif (md->chain[ISAKMP_NEXT_v2SA] == NULL ||\n\t    md->chain[ISAKMP_NEXT_v2TSi] == NULL ||\n\t    md->chain[ISAKMP_NEXT_v2TSr] == NULL) {\n\t\t/* not really anything to here... but it would be worth unpending again */\n\t\tDBG(DBG_CONTROLMORE,\n\t\t    DBG_log(\n\t\t\t    \"no v2SA, v2TSi or v2TSr received, not attempting to setup child SA\"));\n\t\tDBG(DBG_CONTROLMORE,\n\t\t    DBG_log(\"  Should we check for some notify?\"));\n\t\t/*\n\t\t * Delete previous retransmission event.\n\t\t */\n\t\tdelete_event(st);\n\t\treturn STF_OK;\n\t}\n\n\t{\n\t\tint bestfit_n, bestfit_p, bestfit_pr;\n\t\tunsigned int best_tsi_i,  best_tsr_i;\n\t\tbestfit_n = -1;\n\t\tbestfit_p = -1;\n\t\tbestfit_pr = -1;\n\n\t\t/* Check TSi/TSr http://tools.ietf.org/html/rfc5996#section-2.9 */\n\t\tDBG(DBG_CONTROLMORE,\n\t\t    DBG_log(\" check narrowing - we are responding to I2\"));\n\n\t\tstruct payload_digest *const tsi_pd =\n\t\t\tmd->chain[ISAKMP_NEXT_v2TSi];\n\t\tstruct payload_digest *const tsr_pd =\n\t\t\tmd->chain[ISAKMP_NEXT_v2TSr];\n\t\tstruct traffic_selector tsi[16], tsr[16];\n#if 0\n\t\tbool instantiate = FALSE;\n\t\tip_subnet tsi_subnet, tsr_subnet;\n\t\tconst char *oops;\n#endif\n\n\t\tunsigned int tsi_n, tsr_n;\n\t\ttsi_n = ikev2_parse_ts(tsi_pd, tsi, 16);\n\t\ttsr_n = ikev2_parse_ts(tsr_pd, tsr, 16);\n\n\t\tDBG_log(\n\t\t\t\"Checking TSi(%d)/TSr(%d) selectors, looking for exact match\", tsi_n,\n\t\t\ttsr_n);\n\t\t{\n\t\t\tstruct spd_route *sra;\n\t\t\tsra = &c->spd;\n\t\t\tint bfit_n = ikev2_evaluate_connection_fit(c, sra,\n\t\t\t\t\t\t\t\t   INITIATOR,\n\t\t\t\t\t\t\t\t   tsi, tsr,\n\t\t\t\t\t\t\t\t   tsi_n,\n\t\t\t\t\t\t\t\t   tsr_n);\n\t\t\tif (bfit_n > bestfit_n) {\n\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t    DBG_log(\n\t\t\t\t\t    \"bfit_n=ikev2_evaluate_connection_fit found better fit c %s\",\n\t\t\t\t\t    c->name));\n\t\t\t\tint bfit_p =\n\t\t\t\t\tikev2_evaluate_connection_port_fit(c,\n\t\t\t\t\t\t\t\t\t   sra,\n\t\t\t\t\t\t\t\t\t   INITIATOR,\n\t\t\t\t\t\t\t\t\t   tsi, tsr,\n\t\t\t\t\t\t\t\t\t   tsi_n, tsr_n, &best_tsi_i,\n\t\t\t\t\t\t\t\t\t   &best_tsr_i);\n\t\t\t\tif (bfit_p > bestfit_p) {\n\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t    DBG_log(\n\t\t\t\t\t\t    \"ikev2_evaluate_connection_port_fit found better fit c %s, tsi[%d],tsr[%d]\",\n\t\t\t\t\t\t    c->name,\n\t\t\t\t\t\t    best_tsi_i, best_tsr_i));\n\t\t\t\t\tint bfit_pr =\n\t\t\t\t\t\tikev2_evaluate_connection_protocol_fit(\n\t\t\t\t\t\t\tc, sra, INITIATOR, tsi,\n\t\t\t\t\t\t\ttsr,\n\t\t\t\t\t\t\ttsi_n, tsr_n,\n\t\t\t\t\t\t\t&best_tsi_i,\n\t\t\t\t\t\t\t&best_tsr_i);\n\t\t\t\t\tif (bfit_pr > bestfit_pr ) {\n\t\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t\t    DBG_log(\n\t\t\t\t\t\t\t    \"ikev2_evaluate_connection_protocol_fit found better fit c %s, tsi[%d],tsr[%d]\",\n\t\t\t\t\t\t\t    c\n\t\t\t\t\t\t\t    ->name, best_tsi_i,\n\t\t\t\t\t\t\t    best_tsr_i));\n\t\t\t\t\t\tbestfit_p = bfit_p;\n\t\t\t\t\t\tbestfit_n = bfit_n;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t\t    DBG_log(\n\t\t\t\t\t\t\t    \"protocol range fit c %s c->name was rejected by protocol matching\",\n\t\t\t\t\t\t\t    c\n\t\t\t\t\t\t\t    ->name));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t    DBG_log(\n\t\t\t\t\t    \"prefix range fit c %s c->name was rejected by port matching\",\n\t\t\t\t\t    c->name));\n\t\t\t}\n\t\t}\n\n\t\tif ( ( bestfit_n > 0 )  && (bestfit_p > 0)) {\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\n\t\t\t\t    (\n\t\t\t\t\t    \"found an acceptable TSi/TSr Traffic Selector\")));\n\t\t\tmemcpy(&st->st_ts_this, &tsi[best_tsi_i],\n\t\t\t       sizeof(struct traffic_selector));\n\t\t\tmemcpy(&st->st_ts_that, &tsr[best_tsr_i],\n\t\t\t       sizeof(struct traffic_selector));\n\t\t\tikev2_print_ts(&st->st_ts_this);\n\t\t\tikev2_print_ts(&st->st_ts_that);\n\n\t\t\tip_subnet tmp_subnet_i;\n\t\t\tip_subnet tmp_subnet_r;\n\t\t\trangetosubnet(&st->st_ts_this.low,\n\t\t\t\t      &st->st_ts_this.high, &tmp_subnet_i);\n\t\t\trangetosubnet(&st->st_ts_that.low,\n\t\t\t\t      &st->st_ts_that.high, &tmp_subnet_r);\n\n\t\t\tc->spd.this.client = tmp_subnet_i;\n\t\t\tc->spd.this.port  = st->st_ts_this.startport;\n\t\t\tc->spd.this.protocol  = st->st_ts_this.ipprotoid;\n\t\t\tsetportof(htons(\n\t\t\t\t\t  c->spd.this.port),\n\t\t\t\t  &c->spd.this.host_addr);\n\t\t\tsetportof(htons(\n\t\t\t\t\t  c->spd.this.port),\n\t\t\t\t  &c->spd.this.client.addr);\n\n\t\t\tif ( subnetishost(&c->spd.this.client) &&\n\t\t\t     addrinsubnet(&c->spd.this.host_addr,\n\t\t\t\t\t  &c->spd.this.client))\n\t\t\t\tc->spd.this.has_client = FALSE;\n\t\t\telse\n\t\t\t\tc->spd.this.has_client = TRUE;\n\n\t\t\tc->spd.that.client = tmp_subnet_r;\n\t\t\tc->spd.that.port = st->st_ts_that.startport;\n\t\t\tc->spd.that.protocol = st->st_ts_that.ipprotoid;\n\t\t\tsetportof(htons(\n\t\t\t\t\t  c->spd.that.port),\n\t\t\t\t  &c->spd.that.host_addr);\n\t\t\tsetportof(htons(\n\t\t\t\t\t  c->spd.that.port),\n\t\t\t\t  &c->spd.that.client.addr);\n\n\t\t\tif ( subnetishost(&c->spd.that.client) &&\n\t\t\t     addrinsubnet(&c->spd.that.host_addr,\n\t\t\t\t\t  &c->spd.that.client))\n\t\t\t\tc->spd.that.has_client = FALSE;\n\t\t\telse\n\t\t\t\tc->spd.that.has_client = TRUE;\n\t\t\t/* AAAA */\n\t\t} else {\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log((\n\t\t\t\t\t    \"reject responder TSi/TSr Traffic Selector\")));\n\t\t\t/* prevents parent from going to I3 */\n\t\t\treturn STF_FAIL + v2N_TS_UNACCEPTABLE;\n\t\t}\n\t} /* end of TS check block */\n\n\t{\n\t\tv2_notification_t rn;\n\t\tstruct payload_digest *const sa_pd =\n\t\t\tmd->chain[ISAKMP_NEXT_v2SA];\n\n\t\trn = ikev2_parse_child_sa_body(&sa_pd->pbs,\n\t\t\t\t\t       &sa_pd->payload.v2sa,\n\t\t\t\t\t       NULL, st, FALSE);\n\n\t\tif (rn != v2N_NOTHING_WRONG)\n\t\t\treturn STF_FAIL + rn;\n\t}\n\n\t{\n\t\tstruct payload_digest *p;\n\n\t\tfor (p = md->chain[ISAKMP_NEXT_v2N]; p != NULL; p = p->next) {\n\t\t\t/* RFC 5996 */\n\t\t\t/*Types in the range 0 - 16383 are intended for reporting errors.  An\n\t\t\t * implementation receiving a Notify payload with one of these types\n\t\t\t * that it does not recognize in a response MUST assume that the\n\t\t\t * corresponding request has failed entirely.  Unrecognized error types\n\t\t\t * in a request and status types in a request or response MUST be\n\t\t\t * ignored, and they should be logged.*/\n\n\t\t\tif (enum_name(&ikev2_notify_names,\n\t\t\t\t      p->payload.v2n.isan_type) == NULL) {\n\t\t\t\tif (p->payload.v2n.isan_type <\n\t\t\t\t    v2N_INITIAL_CONTACT)\n\t\t\t\t\treturn STF_FAIL +\n\t\t\t\t\t       p->payload.v2n.isan_type;\n\t\t\t}\n\n\t\t\tif ( p->payload.v2n.isan_type ==\n\t\t\t     v2N_USE_TRANSPORT_MODE ) {\n\t\t\t\tif ( st->st_connection->policy &\n\t\t\t\t     POLICY_TUNNEL) {\n\t\t\t\t\t/*This means we did not send v2N_USE_TRANSPORT, however responder is sending it in now (inR2), seems incorrect*/\n\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t    DBG_log(\n\t\t\t\t\t\t    \"Initiator policy is tunnel, responder sends v2N_USE_TRANSPORT_MODE notification in inR2, ignoring it\"));\n\t\t\t\t} else {\n\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t    DBG_log(\n\t\t\t\t\t\t    \"Initiator policy is transport, responder sends v2N_USE_TRANSPORT_MODE, setting CHILD SA to transport mode\"));\n\t\t\t\t\tif (st->st_esp.present == TRUE) {\n\t\t\t\t\t\t/*libreswan supports only \"esp\" with ikev2 it seems, look at ikev2_parse_child_sa_body handling*/\n\t\t\t\t\t\tst->st_esp.attrs.encapsulation\n\t\t\t\t\t\t\t=\n\t\t\t\t\t\t\t\tENCAPSULATION_MODE_TRANSPORT;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}       /* for */\n\n\t}               /* notification block */\n\n\tikev2_derive_child_keys(st, md->role);\n\n\tc->newest_ipsec_sa = st->st_serialno;\n\n\t/* now install child SAs */\n\tif (!install_ipsec_sa(st, TRUE))\n\t\treturn STF_FATAL;\n\n\t/*\n\t * Delete previous retransmission event.\n\t */\n\tdelete_event(st);\n\n\treturn STF_OK;\n}\n\n/*\n * Cookie = <VersionIDofSecret> | Hash(Ni | IPi | SPIi | <secret>)\n * where <secret> is a randomly generated secret known only to the\n * in LSW implementation <VersionIDofSecret> is not used.\n */\nstatic bool ikev2_get_dcookie(u_char *dcookie,  chunk_t st_ni,\n\t\t\t      ip_address *addr, u_int8_t *spiI)\n{\n\tsize_t addr_length;\n\tSHA1_CTX ctx_sha1;\n\tunsigned char addr_buff[\n\t\tsizeof(union { struct in_addr A;\n\t\t\t       struct in6_addr B;\n\t\t       })];\n\n\taddr_length = addrbytesof(addr, addr_buff, sizeof(addr_buff));\n\tSHA1Init(&ctx_sha1);\n\tSHA1Update(&ctx_sha1, st_ni.ptr, st_ni.len);\n\tSHA1Update(&ctx_sha1, addr_buff, addr_length);\n\tSHA1Update(&ctx_sha1, spiI, sizeof(*spiI));\n\tSHA1Update(&ctx_sha1, ikev2_secret_of_the_day,\n\t\t   SHA1_DIGEST_SIZE);\n\tSHA1Final(dcookie, &ctx_sha1);\n\tDBG(DBG_PRIVATE,\n\t    DBG_log(\"ikev2 secret_of_the_day used %s, length %d\",\n\t\t    ikev2_secret_of_the_day,\n\t\t    SHA1_DIGEST_SIZE);\n\t    );\n\n\tDBG(DBG_CRYPT,\n\t    DBG_dump(\"computed dcookie: HASH(Ni | IPi | SPIi | <secret>)\",\n\t\t     dcookie, SHA1_DIGEST_SIZE));\n#if 0\n\tikev2_secrets_recycle++;\n\tif (ikev2_secrets_recycle >= 32768) {\n\t\t/* handed out too many cookies, cycle secrets */\n\t\tikev2_secrets_recycle = 0;\n\t\t/* can we call init_secrets() without adding an EVENT? */\n\t\tinit_secrets();\n\t}\n#endif\n\treturn TRUE;\n}\n\n/*\n *\n ***************************************************************\n *                       NOTIFICATION_OUT Complete packet  *****\n ***************************************************************\n *\n */\n\nvoid send_v2_notification(struct state *p1st, u_int16_t type,\n\t\t\t  struct state *encst,\n\t\t\t  u_char *icookie,\n\t\t\t  u_char *rcookie,\n\t\t\t  chunk_t *n_data)\n{\n\tu_char buffer[1024];\n\tpb_stream reply;\n\tpb_stream rbody;\n\tchunk_t child_spi, notify_data;\n\n\t/* this function is not generic enough yet just enough for 6msg\n\t * TBD accept HDR FLAGS as arg. default ISAKMP_FLAGS_R\n\t * TBD when there is a child SA use that SPI in the notify paylod.\n\t * TBD support encrypted notifications payloads.\n\t * TBD accept Critical bit as an argument. default is set.\n\t * TBD accept exchange type as an arg, default is ISAKMP_v2_SA_INIT\n\t * do we need to send a notify with empty data?\n\t * do we need to support more Protocol ID? more than PROTO_ISAKMP\n\t */\n\n\tlibreswan_log(\"sending %s notification %s to %s:%u\",\n\t\t      encst ? \"encrypted \" : \"\",\n\t\t      enum_name(&ikev2_notify_names, type),\n\t\t      ip_str(&p1st->st_remoteaddr),\n\t\t      p1st->st_remoteport);\n#if 0\n/* Empty notification data section should be fine? */\n\tif (n_data == NULL) {\n\t\tDBG(DBG_CONTROLMORE,\n\t\t    DBG_log(\"don't send packet when notification data empty\"));\n\t\treturn;\n\t}\n#endif\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tinit_pbs(&reply, buffer, sizeof(buffer), \"notification msg\");\n\n\t/* HDR out */\n\t{\n\t\tstruct isakmp_hdr n_hdr;\n\t\tzero(&n_hdr);                           /* default to 0 */  /* AAA should we copy from MD? */\n\t\t/* Impair function will raise major/minor by 1 for testing */\n\t\tn_hdr.isa_version = build_ike_version();\n\t\tmemcpy(n_hdr.isa_rcookie, rcookie, COOKIE_SIZE);\n\t\tmemcpy(n_hdr.isa_icookie, icookie, COOKIE_SIZE);\n\t\tn_hdr.isa_xchg = ISAKMP_v2_SA_INIT;\n\t\tn_hdr.isa_np = ISAKMP_NEXT_v2N;\n\t\tn_hdr.isa_flags &= ~ISAKMP_FLAGS_I;\n\t\tn_hdr.isa_flags  |=  ISAKMP_FLAGS_R;\n#warning check msgid code here\n\t\t/* PAUL: shouldn't we set n_hdr.isa_msgid = [htonl](p1st->st_msgid); */\n\t\tif (!out_struct(&n_hdr, &isakmp_hdr_desc, &reply, &rbody)) {\n\t\t\tlibreswan_log(\n\t\t\t\t\"error initializing hdr for notify message\");\n\t\t\treturn;\n\t\t}\n\n\t}\n\tchild_spi.ptr = NULL;\n\tchild_spi.len = 0;\n\n\t/* build and add v2N payload to the packet */\n\tmemset(&child_spi, 0, sizeof(child_spi));\n\tmemset(&notify_data, 0, sizeof(notify_data));\n\tship_v2N(ISAKMP_NEXT_v2NONE, DBGP(\n\t\t\t IMPAIR_SEND_BOGUS_ISAKMP_FLAG) ?\n\t\t (ISAKMP_PAYLOAD_NONCRITICAL | ISAKMP_PAYLOAD_LIBRESWAN_BOGUS) :\n\t\t ISAKMP_PAYLOAD_NONCRITICAL, PROTO_ISAKMP,\n\t\t &child_spi,\n\t\t type, n_data, &rbody);\n\n\tclose_message(&rbody, p1st);\n\tclose_output_pbs(&reply);\n\n\tclonetochunk(p1st->st_tpacket, reply.start, pbs_offset(&reply),\n\t\t     \"notification packet\");\n\n\tsend_ike_msg(p1st, __FUNCTION__);\n}\n/* add notify payload to the rbody */\nbool ship_v2N(unsigned int np, u_int8_t critical,\n\t      u_int8_t protoid, chunk_t *spi,\n\t      u_int16_t type, chunk_t *n_data, pb_stream *rbody)\n{\n\tstruct ikev2_notify n;\n\tpb_stream n_pbs;\n\n\tDBG(DBG_CONTROLMORE,\n\t    DBG_log(\"Adding a v2N Payload\"));\n\tn.isan_np =  np;\n\tn.isan_critical = critical;\n\tif (DBGP(IMPAIR_SEND_BOGUS_ISAKMP_FLAG)) {\n\t\tlibreswan_log(\n\t\t\t\" setting bogus ISAKMP_PAYLOAD_LIBRESWAN_BOGUS flag in ISAKMP payload\");\n\t\tn.isan_critical |= ISAKMP_PAYLOAD_LIBRESWAN_BOGUS;\n\t}\n\n\tn.isan_protoid =  protoid;\n\tn.isan_spisize = spi->len;\n\tn.isan_type = type;\n\n\tif (!out_struct(&n, &ikev2_notify_desc, rbody, &n_pbs)) {\n\t\tlibreswan_log(\n\t\t\t\"error initializing notify payload for notify message\");\n\t\treturn FALSE;\n\t}\n\n\tif (spi->len > 0) {\n\t\tif (!out_raw(spi->ptr, spi->len, &n_pbs, \"SPI \")) {\n\t\t\tlibreswan_log(\"error writing SPI to notify payload\");\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\tif (n_data != NULL) {\n\t\tif (!out_raw(n_data->ptr, n_data->len, &n_pbs,\n\t\t\t     \"Notify data\")) {\n\t\t\tlibreswan_log(\n\t\t\t\t\"error writing notify payload for notify message\");\n\t\t\treturn FALSE;\n\t\t}\n\t}\n\n\tclose_output_pbs(&n_pbs);\n\treturn TRUE;\n}\n\n/*\n *\n ***************************************************************\n *                       INFORMATIONAL                     *****\n ***************************************************************\n *  -\n *\n *\n */\nstf_status process_informational_ikev2(struct msg_digest *md)\n{\n\t/* verify that there is in fact an encrypted payload */\n\tif (!md->chain[ISAKMP_NEXT_v2E]) {\n\t\tlibreswan_log(\n\t\t\t\"Ignoring informational exchange outside encrypted payload (rfc5996 section 1.4)\");\n\t\treturn STF_IGNORE;\n\t}\n\n\t/* decrypt things. */\n\t{\n\t\tstf_status ret;\n\n\t\tif (md->hdr.isa_flags & ISAKMP_FLAGS_I) {\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\n\t\t\t\t    \"received informational exchange request from INITIATOR\"));\n\t\t\tret = ikev2_decrypt_msg(md, RESPONDER);\n\t\t} else {\n\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t    DBG_log(\n\t\t\t\t    \"received informational exchange request from RESPONDER\"));\n\t\t\tret = ikev2_decrypt_msg(md, INITIATOR);\n\t\t}\n\n\t\tif (ret != STF_OK)\n\t\t\treturn ret;\n\t}\n\n\t{\n\t\tstruct payload_digest *p;\n\t\tstruct ikev2_delete *v2del = NULL;\n\t\tstf_status ret;\n\t\tstruct state *const st = md->st;\n\n\t\t/* Only send response if it is request*/\n\t\tif (!(md->hdr.isa_flags & ISAKMP_FLAGS_R)) {\n\t\t\tunsigned char *authstart;\n\t\t\tpb_stream e_pbs, e_pbs_cipher;\n\t\t\tstruct ikev2_generic e;\n\t\t\tunsigned char *iv;\n\t\t\tint ivsize;\n\t\t\tunsigned char *encstart;\n\n\t\t\t/* beginning of data going out */\n\t\t\tauthstart = reply_stream.cur;\n\n\t\t\t/* make sure HDR is at start of a clean buffer */\n\t\t\tzero(reply_buffer);\n\t\t\tinit_pbs(&reply_stream, reply_buffer,\n\t\t\t\t sizeof(reply_buffer),\n\t\t\t\t \"information exchange reply packet\");\n\n\t\t\tDBG(DBG_CONTROLMORE | DBG_DPD,\n\t\t\t    DBG_log(\"Received an INFORMATIONAL request, \"\n\t\t\t\t    \"updating liveness, no longer pending\"));\n\t\t\tst->st_last_liveness = now();\n\t\t\tst->st_pend_liveness = FALSE;\n\n\t\t\t/* HDR out */\n\t\t\t{\n\t\t\t\tstruct isakmp_hdr r_hdr;\n\t\t\t\tzero(&r_hdr); /* default to 0 */  /* AAA should we copy from MD? */\n\t\t\t\tr_hdr.isa_version = build_ike_version();\n\t\t\t\tmemcpy(r_hdr.isa_rcookie, st->st_rcookie,\n\t\t\t\t       COOKIE_SIZE);\n\t\t\t\tmemcpy(r_hdr.isa_icookie, st->st_icookie,\n\t\t\t\t       COOKIE_SIZE);\n\t\t\t\tr_hdr.isa_xchg = ISAKMP_v2_INFORMATIONAL;\n\t\t\t\tr_hdr.isa_np = ISAKMP_NEXT_v2E;\n\t\t\t\tr_hdr.isa_msgid = htonl(md->msgid_received);\n\n\t\t\t\t/*set initiator bit if we are initiator*/\n\t\t\t\tif (md->role == INITIATOR)\n\t\t\t\t\tr_hdr.isa_flags |= ISAKMP_FLAGS_I;\n\n\t\t\t\tr_hdr.isa_flags  |=  ISAKMP_FLAGS_R;\n\n\t\t\t\tif (!out_struct(&r_hdr, &isakmp_hdr_desc,\n\t\t\t\t\t\t&reply_stream, &md->rbody)) {\n\t\t\t\t\tlibreswan_log(\n\t\t\t\t\t\t\"error initializing hdr for informational message\");\n\t\t\t\t\treturn STF_INTERNAL_ERROR;\n\t\t\t\t}\n\n\t\t\t} /*HDR Done*/\n\n\t\t\t/* insert an Encryption payload header */\n\t\t\tif (md->chain[ISAKMP_NEXT_v2D]) {\n\t\t\t\tbool ikesa_flag = FALSE;\n\t\t\t\t/* Search if there is a IKE SA delete payload*/\n\t\t\t\tfor (p = md->chain[ISAKMP_NEXT_v2D]; p != NULL;\n\t\t\t\t     p = p->next) {\n\t\t\t\t\tif (p->payload.v2delete.isad_protoid ==\n\t\t\t\t\t    PROTO_ISAKMP) {\n\t\t\t\t\t\te.isag_np = ISAKMP_NEXT_v2NONE;\n\t\t\t\t\t\tikesa_flag = TRUE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* if there is no IKE SA DELETE PAYLOAD*/\n\t\t\t\t/* That means, there are AH OR ESP*/\n\t\t\t\tif (!ikesa_flag)\n\t\t\t\t\te.isag_np = ISAKMP_NEXT_v2D;\n\n\t\t\t} else {\n\t\t\t\te.isag_np = ISAKMP_NEXT_v2NONE;\n\t\t\t}\n\n\t\t\te.isag_critical = ISAKMP_PAYLOAD_NONCRITICAL;\n\n\t\t\tif (!out_struct(&e, &ikev2_e_desc, &md->rbody, &e_pbs))\n\t\t\t\treturn STF_INTERNAL_ERROR;\n\n\t\t\t/* insert IV */\n\t\t\tiv     = e_pbs.cur;\n\t\t\tivsize = st->st_oakley.encrypter->iv_size;\n\t\t\tif (!out_zero(ivsize, &e_pbs, \"iv\"))\n\t\t\t\treturn STF_INTERNAL_ERROR;\n\n\t\t\tget_rnd_bytes(iv, ivsize);\n\n\t\t\t/* note where cleartext starts */\n\t\t\tinit_pbs(&e_pbs_cipher, e_pbs.cur,\n\t\t\t\t e_pbs.roof - e_pbs.cur, \"cleartext\");\n\t\t\te_pbs_cipher.container = &e_pbs;\n\t\t\te_pbs_cipher.desc = NULL;\n\t\t\te_pbs_cipher.cur = e_pbs.cur;\n\t\t\tencstart = e_pbs_cipher.cur;\n\n\t\t\tif (md->chain[ISAKMP_NEXT_v2D]) {\n\n\t\t\t\tfor (p = md->chain[ISAKMP_NEXT_v2D]; p != NULL;\n\t\t\t\t     p = p->next) {\n\t\t\t\t\tv2del = &p->payload.v2delete;\n\n\t\t\t\t\tswitch (v2del->isad_protoid) {\n\t\t\t\t\tcase PROTO_ISAKMP:\n\t\t\t\t\t\t/* My understanding is that delete payload for IKE SA\n\t\t\t\t\t\t *  should be the only payload in the informational exchange\n\t\t\t\t\t\t */\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase PROTO_IPSEC_AH:\n\t\t\t\t\tcase PROTO_IPSEC_ESP:\n\t\t\t\t\t{\n\t\t\t\t\t\tchar spi_buf[1024];\n\t\t\t\t\t\tpb_stream del_pbs;\n\t\t\t\t\t\tstruct ikev2_delete v2del_tmp;\n\t\t\t\t\t\tu_int16_t i, j = 0;\n\t\t\t\t\t\tu_char *spi;\n\n\t\t\t\t\t\tfor (i = 0;\n\t\t\t\t\t\t     i < v2del->isad_nrspi;\n\t\t\t\t\t\t     i++ ) {\n\t\t\t\t\t\t\tspi = p->pbs.cur +\n\t\t\t\t\t\t\t      (i *\n\t\t\t\t\t\t\t       v2del->\n\t\t\t\t\t\t\t       isad_spisize);\n\t\t\t\t\t\t\tDBG(DBG_CONTROLMORE, DBG_log(\n\t\t\t\t\t\t\t\t    \"received delete request for %s SA(0x%08lx)\",\n\t\t\t\t\t\t\t\t    enum_show(\n\t\t\t\t\t\t\t\t\t    &\n\t\t\t\t\t\t\t\t\t    protocol_names,\n\t\t\t\t\t\t\t\t\t    v2del\n\t\t\t\t\t\t\t\t\t    ->\n\t\t\t\t\t\t\t\t\t    isad_protoid),\n\t\t\t\t\t\t\t\t    (\n\t\t\t\t\t\t\t\t\t    unsigned\n\t\t\t\t\t\t\t\t\t    long)\n\t\t\t\t\t\t\t\t    ntohl((\n\t\t\t\t\t\t\t\t\t\t  unsigned\n\t\t\t\t\t\t\t\t\t\t  long)\n\t\t\t\t\t\t\t\t\t  *(\n\t\t\t\t\t\t\t\t\t\t  ipsec_spi_t\n\t\t\t\t\t\t\t\t\t\t  *)\n\t\t\t\t\t\t\t\t\t  spi)));\n\n\t\t\t\t\t\t\tstruct state *dst =\n\t\t\t\t\t\t\t\tfind_state_ikev2_child_to_delete(\n\t\t\t\t\t\t\t\t\tst->st_icookie,\n\t\t\t\t\t\t\t\t\tst->st_rcookie,\n\t\t\t\t\t\t\t\t\tv2del->isad_protoid,\n\t\t\t\t\t\t\t\t\t*(\n\t\t\t\t\t\t\t\t\t\tipsec_spi_t\n\t\t\t\t\t\t\t\t\t\t*)spi);\n\n\t\t\t\t\t\t\tif (dst != NULL) {\n\t\t\t\t\t\t\t\tstruct\n\t\t\t\t\t\t\t\tipsec_proto_info\n\t\t\t\t\t\t\t\t*pr =\n\t\t\t\t\t\t\t\t\tv2del->\n\t\t\t\t\t\t\t\t\tisad_protoid\n\t\t\t\t\t\t\t\t\t==\n\t\t\t\t\t\t\t\t\tPROTO_IPSEC_AH\n\t\t\t\t\t\t\t\t\t?\n\t\t\t\t\t\t\t\t\t&dst\n\t\t\t\t\t\t\t\t\t->st_ah\n\t\t\t\t\t\t\t\t\t:\n\t\t\t\t\t\t\t\t\t&dst\n\t\t\t\t\t\t\t\t\t->\n\t\t\t\t\t\t\t\t\tst_esp;\n\t\t\t\t\t\t\t\tDBG(\n\t\t\t\t\t\t\t\t\tDBG_CONTROLMORE,\n\t\t\t\t\t\t\t\t\tDBG_log(\n\t\t\t\t\t\t\t\t\t\t\"our side spi that needs to be sent: %s SA(0x%08lx)\",\n\t\t\t\t\t\t\t\t\t\tenum_show(\n\t\t\t\t\t\t\t\t\t\t\t&\n\t\t\t\t\t\t\t\t\t\t\tprotocol_names,\n\t\t\t\t\t\t\t\t\t\t\tv2del\n\t\t\t\t\t\t\t\t\t\t\t->\n\t\t\t\t\t\t\t\t\t\t\tisad_protoid),\n\t\t\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\t\t\tunsigned\n\t\t\t\t\t\t\t\t\t\t\tlong)\n\t\t\t\t\t\t\t\t\t\tntohl(\n\t\t\t\t\t\t\t\t\t\t\tpr\n\t\t\t\t\t\t\t\t\t\t\t->\n\t\t\t\t\t\t\t\t\t\t\tour_spi)));\n\n\t\t\t\t\t\t\t\tmemcpy(\n\t\t\t\t\t\t\t\t\tspi_buf +\n\t\t\t\t\t\t\t\t\t(j *\n\t\t\t\t\t\t\t\t\t v2del\n\t\t\t\t\t\t\t\t\t ->\n\t\t\t\t\t\t\t\t\t isad_spisize),\n\t\t\t\t\t\t\t\t\t(u_char\n\t\t\t\t\t\t\t\t\t *)&pr->our_spi,\n\t\t\t\t\t\t\t\t\tv2del->isad_spisize);\n\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tDBG(\n\t\t\t\t\t\t\t\t\tDBG_CONTROLMORE,\n\t\t\t\t\t\t\t\t\tDBG_log(\n\t\t\t\t\t\t\t\t\t\t\"received delete request for %s SA(0x%08lx) but local state is not found\",\n\t\t\t\t\t\t\t\t\t\tenum_show(\n\t\t\t\t\t\t\t\t\t\t\t&\n\t\t\t\t\t\t\t\t\t\t\tprotocol_names,\n\t\t\t\t\t\t\t\t\t\t\tv2del\n\t\t\t\t\t\t\t\t\t\t\t->\n\t\t\t\t\t\t\t\t\t\t\tisad_protoid),\n\t\t\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\t\t\tunsigned\n\t\t\t\t\t\t\t\t\t\t\tlong)\n\t\t\t\t\t\t\t\t\t\tntohl((\n\t\t\t\t\t\t\t\t\t\t\t      unsigned\n\t\t\t\t\t\t\t\t\t\t\t      long)\n\t\t\t\t\t\t\t\t\t\t      *(\n\t\t\t\t\t\t\t\t\t\t\t      ipsec_spi_t\n\t\t\t\t\t\t\t\t\t\t\t      *)\n\t\t\t\t\t\t\t\t\t\t      spi)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( !j ) {\n\t\t\t\t\t\t\tDBG(DBG_CONTROLMORE, DBG_log(\n\t\t\t\t\t\t\t\t    \"This delete payload does not contain a single spi that has any local state, ignoring\"));\n\t\t\t\t\t\t\treturn STF_IGNORE;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDBG(DBG_CONTROLMORE, DBG_log(\n\t\t\t\t\t\t\t\t    \"No. of SPIs to be sent %d\",\n\t\t\t\t\t\t\t\t    j);\n\t\t\t\t\t\t\t    DBG_dump(\n\t\t\t\t\t\t\t\t    \" Emit SPIs\",\n\t\t\t\t\t\t\t\t    spi_buf,\n\t\t\t\t\t\t\t\t    j *\n\t\t\t\t\t\t\t\t    v2del->\n\t\t\t\t\t\t\t\t    isad_spisize));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tzero(&v2del_tmp);\n\n\t\t\t\t\t\tif (p->next != NULL)\n\t\t\t\t\t\t\tv2del_tmp.isad_np =\n\t\t\t\t\t\t\t\tISAKMP_NEXT_v2D;\n\n\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tv2del_tmp.isad_np =\n\t\t\t\t\t\t\t\tISAKMP_NEXT_v2NONE;\n\n\n\t\t\t\t\t\tv2del_tmp.isad_protoid =\n\t\t\t\t\t\t\tv2del->isad_protoid;\n\t\t\t\t\t\tv2del_tmp.isad_spisize =\n\t\t\t\t\t\t\tv2del->isad_spisize;\n\t\t\t\t\t\tv2del_tmp.isad_nrspi = j;\n\n\t\t\t\t\t\t/* Emit delete payload header out*/\n\t\t\t\t\t\tif (!out_struct(&v2del_tmp,\n\t\t\t\t\t\t\t\t&\n\t\t\t\t\t\t\t\tikev2_delete_desc,\n\t\t\t\t\t\t\t\t&e_pbs_cipher,\n\t\t\t\t\t\t\t\t&del_pbs)) {\n\t\t\t\t\t\t\tlibreswan_log(\n\t\t\t\t\t\t\t\t\"error initializing hdr for delete payload\");\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\tSTF_INTERNAL_ERROR;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Emit values of spi to be sent to the peer*/\n\t\t\t\t\t\tif (!out_raw(spi_buf, j *\n\t\t\t\t\t\t\t     v2del->\n\t\t\t\t\t\t\t     isad_spisize,\n\t\t\t\t\t\t\t     &del_pbs,\n\t\t\t\t\t\t\t     \"local spis\")) {\n\t\t\t\t\t\t\tlibreswan_log(\n\t\t\t\t\t\t\t\t\"error sending spi values in delete payload\");\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\tSTF_INTERNAL_ERROR;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tclose_output_pbs(&del_pbs);\n\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/*Unrecongnized protocol */\n\t\t\t\t\t\treturn STF_IGNORE;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* this will break from for loop*/\n\t\t\t\t\tif (v2del->isad_protoid ==\n\t\t\t\t\t    PROTO_ISAKMP)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*If there are no payloads or in other words empty payload in request\n\t\t\t * that means it is check for liveliness, so send an empty payload message\n\t\t\t * this will end up sending an empty payload\n\t\t\t */\n\n\t\t\tikev2_padup_pre_encrypt(md, &e_pbs_cipher);\n\t\t\tclose_output_pbs(&e_pbs_cipher);\n\n\t\t\t{\n\t\t\t\tunsigned char *authloc = ikev2_authloc(md,\n\t\t\t\t\t\t\t\t       &e_pbs);\n\t\t\t\tif (authloc == NULL)\n\t\t\t\t\treturn STF_INTERNAL_ERROR;\n\n\t\t\t\tclose_output_pbs(&e_pbs);\n\t\t\t\tclose_output_pbs(&md->rbody);\n\t\t\t\tclose_output_pbs(&reply_stream);\n\n\t\t\t\tret = ikev2_encrypt_msg(md, md->role,\n\t\t\t\t\t\t\tauthstart,\n\t\t\t\t\t\t\tiv, encstart, authloc,\n\t\t\t\t\t\t\t&e_pbs, &e_pbs_cipher);\n\t\t\t\tif (ret != STF_OK)\n\t\t\t\t\treturn ret;\n\t\t\t}\n\n\n\t\t\t/* keep it for a retransmit if necessary */\n\t\t\tfreeanychunk(st->st_tpacket);\n\t\t\tclonetochunk(st->st_tpacket, reply_stream.start, pbs_offset(\n\t\t\t\t\t     &reply_stream),\n\t\t\t\t     \"reply packet for informational exchange\");\n\n\t\t\tsend_ike_msg(st, __FUNCTION__);\n\t\t}\n\n\t\t/* Now carry out the actualy task, we can not carry the actual task since\n\t\t * we need to send informational responde using existig SAs\n\t\t */\n\n\t\t{\n\t\t\tif (md->chain[ISAKMP_NEXT_v2D] && st->st_state !=\n\t\t\t    STATE_IKESA_DEL) {\n\n\t\t\t\tfor (p = md->chain[ISAKMP_NEXT_v2D]; p != NULL;\n\t\t\t\t     p = p->next) {\n\t\t\t\t\tv2del = &p->payload.v2delete;\n\n\t\t\t\t\tswitch (v2del->isad_protoid) {\n\t\t\t\t\tcase PROTO_ISAKMP:\n\t\t\t\t\t{\n\t\t\t\t\t\t/* My understanding is that delete payload for IKE SA\n\t\t\t\t\t\t *  should be the only payload in the informational\n\t\t\t\t\t\t * Now delete the IKE SA state and all its child states\n\t\t\t\t\t\t */\n\t\t\t\t\t\tstruct state *current_st = st;\n\t\t\t\t\t\tstruct state *next_st = NULL;\n\t\t\t\t\t\tstruct state *first_st = NULL;\n\n\t\t\t\t\t\t/* Find the first state in the hash chain*/\n\t\t\t\t\t\twhile (current_st !=\n\t\t\t\t\t\t       (struct state *) NULL) {\n\t\t\t\t\t\t\tfirst_st = current_st;\n\t\t\t\t\t\t\tcurrent_st =\n\t\t\t\t\t\t\t\tfirst_st->\n\t\t\t\t\t\t\t\tst_hashchain_prev;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurrent_st = first_st;\n\t\t\t\t\t\twhile (current_st !=\n\t\t\t\t\t\t       (struct state *) NULL) {\n\t\t\t\t\t\t\tnext_st =\n\t\t\t\t\t\t\t\tcurrent_st->\n\t\t\t\t\t\t\t\tst_hashchain_next;\n\t\t\t\t\t\t\tif (current_st->\n\t\t\t\t\t\t\t    st_clonedfrom !=\n\t\t\t\t\t\t\t    0 ) {\n\t\t\t\t\t\t\t\tchange_state(\n\t\t\t\t\t\t\t\t\tcurrent_st,\n\t\t\t\t\t\t\t\t\tSTATE_CHILDSA_DEL);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tchange_state(\n\t\t\t\t\t\t\t\t\tcurrent_st,\n\t\t\t\t\t\t\t\t\tSTATE_IKESA_DEL);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdelete_state(current_st);\n\t\t\t\t\t\t\tcurrent_st = next_st;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase PROTO_IPSEC_AH:\n\t\t\t\t\tcase PROTO_IPSEC_ESP:\n\t\t\t\t\t{\n\t\t\t\t\t\t/* pb_stream del_pbs; */\n\t\t\t\t\t\tstruct ikev2_delete;\n\t\t\t\t\t\tu_int16_t i;\n\t\t\t\t\t\tu_char *spi;\n\n\t\t\t\t\t\tfor (i = 0;\n\t\t\t\t\t\t     i < v2del->isad_nrspi;\n\t\t\t\t\t\t     i++ ) {\n\t\t\t\t\t\t\tspi = p->pbs.cur +\n\t\t\t\t\t\t\t      (i *\n\t\t\t\t\t\t\t       v2del->\n\t\t\t\t\t\t\t       isad_spisize);\n\t\t\t\t\t\t\tDBG(DBG_CONTROLMORE, DBG_log(\n\t\t\t\t\t\t\t\t    \"Now doing actual deletion for request: %s SA(0x%08lx)\",\n\t\t\t\t\t\t\t\t    enum_show(\n\t\t\t\t\t\t\t\t\t    &\n\t\t\t\t\t\t\t\t\t    protocol_names,\n\t\t\t\t\t\t\t\t\t    v2del\n\t\t\t\t\t\t\t\t\t    ->\n\t\t\t\t\t\t\t\t\t    isad_protoid),\n\t\t\t\t\t\t\t\t    (\n\t\t\t\t\t\t\t\t\t    unsigned\n\t\t\t\t\t\t\t\t\t    long)\n\t\t\t\t\t\t\t\t    ntohl((\n\t\t\t\t\t\t\t\t\t\t  unsigned\n\t\t\t\t\t\t\t\t\t\t  long)\n\t\t\t\t\t\t\t\t\t  *(\n\t\t\t\t\t\t\t\t\t\t  ipsec_spi_t\n\t\t\t\t\t\t\t\t\t\t  *)\n\t\t\t\t\t\t\t\t\t  spi)));\n\n\t\t\t\t\t\t\tstruct state *dst =\n\t\t\t\t\t\t\t\tfind_state_ikev2_child_to_delete(\n\t\t\t\t\t\t\t\t\tst->st_icookie,\n\t\t\t\t\t\t\t\t\tst->st_rcookie,\n\t\t\t\t\t\t\t\t\tv2del->isad_protoid,\n\t\t\t\t\t\t\t\t\t*(\n\t\t\t\t\t\t\t\t\t\tipsec_spi_t\n\t\t\t\t\t\t\t\t\t\t*)spi);\n\n\t\t\t\t\t\t\tif (dst != NULL) {\n\t\t\t\t\t\t\t\tstruct\n\t\t\t\t\t\t\t\tipsec_proto_info\n\t\t\t\t\t\t\t\t*pr =\n\t\t\t\t\t\t\t\t\tv2del->\n\t\t\t\t\t\t\t\t\tisad_protoid\n\t\t\t\t\t\t\t\t\t==\n\t\t\t\t\t\t\t\t\tPROTO_IPSEC_AH\n\t\t\t\t\t\t\t\t\t?\n\t\t\t\t\t\t\t\t\t&dst\n\t\t\t\t\t\t\t\t\t->st_ah\n\t\t\t\t\t\t\t\t\t:\n\t\t\t\t\t\t\t\t\t&dst\n\t\t\t\t\t\t\t\t\t->\n\t\t\t\t\t\t\t\t\tst_esp;\n\t\t\t\t\t\t\t\tDBG(\n\t\t\t\t\t\t\t\t\tDBG_CONTROLMORE,\n\t\t\t\t\t\t\t\t\tDBG_log(\n\t\t\t\t\t\t\t\t\t\t\"our side spi that needs to be deleted: %s SA(0x%08lx)\",\n\t\t\t\t\t\t\t\t\t\tenum_show(\n\t\t\t\t\t\t\t\t\t\t\t&\n\t\t\t\t\t\t\t\t\t\t\tprotocol_names,\n\t\t\t\t\t\t\t\t\t\t\tv2del\n\t\t\t\t\t\t\t\t\t\t\t->\n\t\t\t\t\t\t\t\t\t\t\tisad_protoid),\n\t\t\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\t\t\tunsigned\n\t\t\t\t\t\t\t\t\t\t\tlong)\n\t\t\t\t\t\t\t\t\t\tntohl(\n\t\t\t\t\t\t\t\t\t\t\tpr\n\t\t\t\t\t\t\t\t\t\t\t->\n\t\t\t\t\t\t\t\t\t\t\tour_spi)));\n\n\t\t\t\t\t\t\t\t/* now delete the state*/\n\t\t\t\t\t\t\t\tchange_state(\n\t\t\t\t\t\t\t\t\tdst,\n\t\t\t\t\t\t\t\t\tSTATE_CHILDSA_DEL);\n\t\t\t\t\t\t\t\tdelete_state(\n\t\t\t\t\t\t\t\t\tdst);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tDBG(\n\t\t\t\t\t\t\t\t\tDBG_CONTROLMORE,\n\t\t\t\t\t\t\t\t\tDBG_log(\n\t\t\t\t\t\t\t\t\t\t\"received delete request for %s SA(0x%08lx) but local state is not found\",\n\t\t\t\t\t\t\t\t\t\tenum_show(\n\t\t\t\t\t\t\t\t\t\t\t&\n\t\t\t\t\t\t\t\t\t\t\tprotocol_names,\n\t\t\t\t\t\t\t\t\t\t\tv2del\n\t\t\t\t\t\t\t\t\t\t\t->\n\t\t\t\t\t\t\t\t\t\t\tisad_protoid),\n\t\t\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\t\t\tunsigned\n\t\t\t\t\t\t\t\t\t\t\tlong)\n\t\t\t\t\t\t\t\t\t\tntohl((\n\t\t\t\t\t\t\t\t\t\t\t      unsigned\n\t\t\t\t\t\t\t\t\t\t\t      long)\n\t\t\t\t\t\t\t\t\t\t      *(\n\t\t\t\t\t\t\t\t\t\t\t      ipsec_spi_t\n\t\t\t\t\t\t\t\t\t\t\t      *)\n\t\t\t\t\t\t\t\t\t\t      spi)));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t/*Unrecongnized protocol */\n\t\t\t\t\t\treturn STF_IGNORE;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* this will break from for loop*/\n\t\t\t\t\tif (v2del->isad_protoid ==\n\t\t\t\t\t    PROTO_ISAKMP)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}       /* for */\n\n\t\t\t}               /* if*/\n\t\t\telse {\n\t\t\t\t/* empty response to our IKESA delete request*/\n\t\t\t\tif ((md->hdr.isa_flags & ISAKMP_FLAGS_R) &&\n\t\t\t\t    st->st_state == STATE_IKESA_DEL) {\n\t\t\t\t\t/* My understanding is that delete payload for IKE SA\n\t\t\t\t\t *  should be the only payload in the informational\n\t\t\t\t\t * Now delete the IKE SA state and all its child states\n\t\t\t\t\t */\n\t\t\t\t\tstruct state *current_st = st;\n\t\t\t\t\tstruct state *next_st = NULL;\n\t\t\t\t\tstruct state *first_st = NULL;\n\n\t\t\t\t\t/* Find the first state in the hash chain*/\n\t\t\t\t\twhile (current_st !=\n\t\t\t\t\t       (struct state *) NULL) {\n\t\t\t\t\t\tfirst_st = current_st;\n\t\t\t\t\t\tcurrent_st =\n\t\t\t\t\t\t\tfirst_st->\n\t\t\t\t\t\t\tst_hashchain_prev;\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrent_st = first_st;\n\t\t\t\t\twhile (current_st !=\n\t\t\t\t\t       (struct state *) NULL) {\n\t\t\t\t\t\tnext_st =\n\t\t\t\t\t\t\tcurrent_st->\n\t\t\t\t\t\t\tst_hashchain_next;\n\t\t\t\t\t\tif (current_st->st_clonedfrom\n\t\t\t\t\t\t    !=\n\t\t\t\t\t\t    0 ) {\n\t\t\t\t\t\t\tchange_state(\n\t\t\t\t\t\t\t\tcurrent_st,\n\t\t\t\t\t\t\t\tSTATE_CHILDSA_DEL);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tchange_state(\n\t\t\t\t\t\t\t\tcurrent_st,\n\t\t\t\t\t\t\t\tSTATE_IKESA_DEL);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdelete_state(current_st);\n\t\t\t\t\t\tcurrent_st = next_st;\n\t\t\t\t\t}\n\t\t\t\t\t/* empty response to our empty INFORMATIONAL\n\t\t\t\t\t * We don't send anything back */\n\t\t\t\t} else if ((md->hdr.isa_flags &\n\t\t\t\t\t    ISAKMP_FLAGS_R) &&\n\t\t\t\t\t   st->st_state != STATE_IKESA_DEL) {\n\t\t\t\t\tDBG(DBG_CONTROLMORE,\n\t\t\t\t\t    DBG_log(\n\t\t\t\t\t\t    \"Received an INFORMATIONAL response, \"\n\t\t\t\t\t\t    \"updating liveness, no longer pending.\"));\n\t\t\t\t\tst->st_last_liveness = now();\n\t\t\t\t\tst->st_pend_liveness = FALSE;\n\t\t\t\t\tst->st_msgid_lastrecv =\n\t\t\t\t\t\tmd->msgid_received;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn STF_OK;\n}\n\nstf_status ikev2_send_informational(struct state *st)\n{\n\tstruct state *pst = NULL;\n\n\tif (st->st_clonedfrom != SOS_NOBODY) {\n\t\tpst = state_with_serialno(st->st_clonedfrom);\n\t\tif (!pst) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\n\t\t\t\t    \"IKE SA does not exist for this child SA - should not happen\"));\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\"INFORMATIONAL exchange can not be sent\"));\n\t\t\treturn STF_IGNORE;\n\t\t}\n\t} else {\n\t\tpst = st;\n\t}\n\n\t{\n\t\tunsigned char *authstart;\n\t\tunsigned char *encstart;\n\t\tunsigned char *iv;\n\t\tint ivsize;\n\t\tstruct msg_digest md;\n\t\tstruct ikev2_generic e;\n\t\tenum phase1_role role;\n\t\tpb_stream e_pbs, e_pbs_cipher;\n\t\tpb_stream rbody;\n\t\tpb_stream request;\n\t\tu_char buffer[1024];\n\n\t\tmd.st = st;\n\t\tmd.pst = pst;\n\t\tmemset(buffer, 0, sizeof(buffer));\n\t\tinit_pbs(&request, buffer, sizeof(buffer),\n\t\t\t \"informational exchange request packet\");\n\t\tauthstart = request.cur;\n\n\t\t/* HDR out */\n\t\t{\n\t\t\tstruct isakmp_hdr r_hdr;\n\t\t\tzero(&r_hdr);\n\t\t\tr_hdr.isa_version = build_ike_version();\n\t\t\tmemcpy(r_hdr.isa_rcookie, pst->st_rcookie,\n\t\t\t       COOKIE_SIZE);\n\t\t\tmemcpy(r_hdr.isa_icookie, pst->st_icookie,\n\t\t\t       COOKIE_SIZE);\n\t\t\tr_hdr.isa_xchg = ISAKMP_v2_INFORMATIONAL;\n\t\t\tr_hdr.isa_np = ISAKMP_NEXT_v2E;\n\n\t\t\tif (pst->st_state == STATE_PARENT_I2 ||\n\t\t\t    pst->st_state == STATE_PARENT_I3) {\n\t\t\t\tr_hdr.isa_flags |= ISAKMP_FLAGS_I;\n\t\t\t\trole = INITIATOR;\n\t\t\t\tr_hdr.isa_msgid = htonl(pst->st_msgid_nextuse);\n\t\t\t} else {\n\t\t\t\trole = RESPONDER;\n\t\t\t\tr_hdr.isa_msgid = htonl(\n\t\t\t\t\tpst->st_msgid_lastrecv + 1);\n\t\t\t}\n\n\t\t\tif (!out_struct(&r_hdr, &isakmp_hdr_desc,\n\t\t\t\t\t&request, &rbody)) {\n\t\t\t\tlibreswan_log(\n\t\t\t\t\t\"error initializing hdr for informational message\");\n\t\t\t\treturn STF_FATAL;\n\t\t\t}\n\t\t} /* HDR done*/\n\n\t\t/* insert an Encryption payload header */\n\t\te.isag_np = ISAKMP_NEXT_v2NONE;\n\t\te.isag_critical = ISAKMP_PAYLOAD_NONCRITICAL;\n\t\tif (!out_struct(&e, &ikev2_e_desc, &rbody, &e_pbs))\n\t\t\treturn STF_FATAL;\n\n\t\t/* IV */\n\t\tiv = e_pbs.cur;\n\t\tivsize = pst->st_oakley.encrypter->iv_size;\n\t\tif (!out_zero(ivsize, &e_pbs, \"iv\"))\n\t\t\treturn STF_FATAL;\n\n\t\tget_rnd_bytes(iv, ivsize);\n\n\t\t/* note where cleartext starts */\n\t\tinit_pbs(&e_pbs_cipher, e_pbs.cur, e_pbs.roof - e_pbs.cur,\n\t\t\t \"cleartext\");\n\t\te_pbs_cipher.container = &e_pbs;\n\t\te_pbs_cipher.desc = NULL;\n\t\te_pbs_cipher.cur = e_pbs.cur;\n\t\tencstart = e_pbs_cipher.cur;\n\n\t\t/* This is an empty informational exchange (A.K.A liveness check) */\n\t\tikev2_padup_pre_encrypt(&md, &e_pbs_cipher);\n\t\tclose_output_pbs(&e_pbs_cipher);\n\n\t\t{\n\t\t\tstf_status ret;\n\t\t\tunsigned char *authloc = ikev2_authloc(&md, &e_pbs);\n\n\t\t\tif (!authloc)\n\t\t\t\treturn STF_FATAL;\n\n\t\t\tclose_output_pbs(&e_pbs);\n\t\t\tclose_output_pbs(&rbody);\n\t\t\tclose_output_pbs(&request);\n\n\t\t\tret = ikev2_encrypt_msg(&md, role,\n\t\t\t\t\t\tauthstart,\n\t\t\t\t\t\tiv, encstart, authloc,\n\t\t\t\t\t\t&e_pbs, &e_pbs_cipher);\n\t\t\tif (ret != STF_OK)\n\t\t\t\treturn STF_FATAL;\n\t\t}\n\t\t/* keep it for a retransmit if necessary */\n\t\tfreeanychunk(pst->st_tpacket);\n\t\tclonetochunk(pst->st_tpacket, request.start,\n\t\t\t     pbs_offset(&request),\n\t\t\t     \"reply packet for informational exchange\");\n\t\tpst->st_pend_liveness = TRUE; /* we should only do this when dpd/liveness is active? */\n\t\tsend_ike_msg(pst, __FUNCTION__);\n\t\tikev2_update_counters(&md);\n\n\t}\n\n\treturn STF_OK;\n}\n/*\n *\n ***************************************************************\n *                       DELETE_OUT                        *****\n ***************************************************************\n *\n */\nvoid ikev2_delete_out(struct state *st)\n{\n\tstruct state *pst = NULL;\n\n\tif (st->st_clonedfrom != 0) {\n\t\t/*child SA*/\n\t\tpst = state_with_serialno(st->st_clonedfrom);\n\n\t\tif (!pst) {\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\"IKE SA does not exist for this child SA\"));\n\t\t\tDBG(DBG_CONTROL,\n\t\t\t    DBG_log(\n\t\t\t\t    \"INFORMATIONAL exchange can not be sent, deleting state\"));\n\t\t\tgoto end;\n\t\t}\n\t} else {\n\t\t/* Parent SA*/\n\t\tpst = st;\n\n\t}\n\n\t{\n\t\tunsigned char *authstart;\n\t\tpb_stream e_pbs, e_pbs_cipher;\n\t\tpb_stream rbody;\n\t\tstruct ikev2_generic e;\n\t\tunsigned char *iv;\n\t\tint ivsize;\n\t\tunsigned char *encstart;\n\t\tstruct msg_digest md;\n\t\tenum phase1_role role;\n\n\t\tmd.st = st;\n\t\tmd.pst = pst;\n\t\t/* beginning of data going out */\n\t\tauthstart = reply_stream.cur;\n\n\t\t/* make sure HDR is at start of a clean buffer */\n\t\tzero(reply_buffer);\n\t\tinit_pbs(&reply_stream, reply_buffer, sizeof(reply_buffer),\n\t\t\t \"information exchange request packet\");\n\n\t\t/* HDR out */\n\t\t{\n\t\t\tstruct isakmp_hdr r_hdr;\n\t\t\tzero(&r_hdr); /* default to 0 */  /* AAA should we copy from MD? */\n\t\t\tr_hdr.isa_version = build_ike_version();\n\t\t\tmemcpy(r_hdr.isa_rcookie, pst->st_rcookie,\n\t\t\t       COOKIE_SIZE);\n\t\t\tmemcpy(r_hdr.isa_icookie, pst->st_icookie,\n\t\t\t       COOKIE_SIZE);\n\t\t\tr_hdr.isa_xchg = ISAKMP_v2_INFORMATIONAL;\n\t\t\tr_hdr.isa_np = ISAKMP_NEXT_v2E;\n\t\t\tr_hdr.isa_msgid = htonl(pst->st_msgid_nextuse);\n\n\t\t\t/*set initiator bit if we are initiator*/\n\t\t\tif (pst->st_state == STATE_PARENT_I2 ||\n\t\t\t    pst->st_state == STATE_PARENT_I3) {\n\t\t\t\tr_hdr.isa_flags |= ISAKMP_FLAGS_I;\n\t\t\t\trole = INITIATOR;\n\t\t\t} else {\n\t\t\t\trole = RESPONDER;\n\t\t\t}\n\n\t\t\t/* r_hdr.isa_flags  |=  ISAKMP_FLAGS_R; */\n\n\t\t\tif (!out_struct(&r_hdr, &isakmp_hdr_desc,\n\t\t\t\t\t&reply_stream, &rbody)) {\n\t\t\t\tlibreswan_log(\n\t\t\t\t\t\"error initializing hdr for informational message\");\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t} /*HDR Done*/\n\n\t\t/* insert an Encryption payload header */\n\t\te.isag_np = ISAKMP_NEXT_v2D;\n\t\te.isag_critical = ISAKMP_PAYLOAD_NONCRITICAL;\n\n\t\tif (!out_struct(&e, &ikev2_e_desc, &rbody, &e_pbs))\n\t\t\tgoto end;\n\n\t\t/* insert IV */\n\t\tiv     = e_pbs.cur;\n\t\tivsize = pst->st_oakley.encrypter->iv_size;\n\t\tif (!out_zero(ivsize, &e_pbs, \"iv\"))\n\t\t\tgoto end;\n\t\tget_rnd_bytes(iv, ivsize);\n\n\t\t/* note where cleartext starts */\n\t\tinit_pbs(&e_pbs_cipher, e_pbs.cur, e_pbs.roof - e_pbs.cur,\n\t\t\t \"cleartext\");\n\t\te_pbs_cipher.container = &e_pbs;\n\t\te_pbs_cipher.desc = NULL;\n\t\te_pbs_cipher.cur = e_pbs.cur;\n\t\tencstart = e_pbs_cipher.cur;\n\n\t\t{\n\t\t\tpb_stream del_pbs;\n\t\t\tstruct ikev2_delete v2del_tmp;\n\t\t\t/*\n\t\t\t * u_int16_t i, j=0;\n\t\t\t * u_char *spi;\n\t\t\t * char spi_buf[1024];\n\t\t\t */\n\n\t\t\tzero(&v2del_tmp);\n\t\t\tv2del_tmp.isad_np = ISAKMP_NEXT_v2NONE;\n\n\t\t\tif (st->st_clonedfrom != 0 ) {\n\t\t\t\tv2del_tmp.isad_protoid = PROTO_IPSEC_ESP;\n\t\t\t\tv2del_tmp.isad_spisize = sizeof(ipsec_spi_t);\n\t\t\t\tv2del_tmp.isad_nrspi = 1;\n\t\t\t} else {\n\t\t\t\tv2del_tmp.isad_protoid = PROTO_ISAKMP;\n\t\t\t\tv2del_tmp.isad_spisize = 0;\n\t\t\t\tv2del_tmp.isad_nrspi = 0;\n\t\t\t}\n\n\t\t\t/* Emit delete payload header out*/\n\t\t\tif (!out_struct(&v2del_tmp, &ikev2_delete_desc,\n\t\t\t\t\t&e_pbs_cipher, &del_pbs)) {\n\t\t\t\tlibreswan_log(\n\t\t\t\t\t\"error initializing hdr for delete payload\");\n\t\t\t\tgoto end;\n\t\t\t}\n\n\t\t\t/* Emit values of spi to be sent to the peer*/\n\t\t\tif (st->st_clonedfrom != 0) {\n\t\t\t\tif (!out_raw( (u_char *)&st->st_esp.our_spi,\n\t\t\t\t\t      sizeof(ipsec_spi_t), &del_pbs,\n\t\t\t\t\t      \"local spis\")) {\n\t\t\t\t\tlibreswan_log(\n\t\t\t\t\t\t\"error sending spi values in delete payload\");\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tclose_output_pbs(&del_pbs);\n\n\t\t}\n\n\t\tikev2_padup_pre_encrypt(&md, &e_pbs_cipher);\n\t\tclose_output_pbs(&e_pbs_cipher);\n\n\t\t{\n\t\t\tstf_status ret;\n\t\t\tunsigned char *authloc = ikev2_authloc(&md, &e_pbs);\n\t\t\tif (authloc == NULL)\n\t\t\t\tgoto end;\n\t\t\tclose_output_pbs(&e_pbs);\n\t\t\tclose_output_pbs(&rbody);\n\t\t\tclose_output_pbs(&reply_stream);\n\n\t\t\tret = ikev2_encrypt_msg(&md, role,\n\t\t\t\t\t\tauthstart,\n\t\t\t\t\t\tiv, encstart, authloc,\n\t\t\t\t\t\t&e_pbs, &e_pbs_cipher);\n\t\t\tif (ret != STF_OK)\n\t\t\t\tgoto end;\n\t\t}\n\n\t\t/* keep it for a retransmit if necessary */\n\t\tfreeanychunk(pst->st_tpacket);\n\t\tclonetochunk(pst->st_tpacket, reply_stream.start,\n\t\t\t     pbs_offset(&reply_stream),\n\t\t\t     \"request packet for informational exchange\");\n\n\t\tsend_ike_msg(pst, __FUNCTION__);\n\n\t\t/* update state */\n\t\tikev2_update_counters(&md);\n\n\t}\n\n\t/* If everything is fine, and we sent packet, goto real_end*/\n\tgoto real_end;\n\nend:\n\t/* If some error occurs above that prevents us sending a request packet*/\n\t/* delete the states right now*/\n\n\tif (st->st_clonedfrom != SOS_NOBODY) {\n\t\tchange_state(st, STATE_CHILDSA_DEL);\n\t\tdelete_state(st);\n\t} else {\n\n\t\tstruct state *current_st = pst;\n\t\tstruct state *next_st = NULL;\n\t\tstruct state *first_st = NULL;\n\n\t\t/* Find the first state in the hash chain*/\n\t\twhile (current_st != (struct state *) NULL) {\n\t\t\tfirst_st = current_st;\n\t\t\tcurrent_st = first_st->st_hashchain_prev;\n\t\t}\n\n\t\tcurrent_st = first_st;\n\t\twhile (current_st != (struct state *) NULL) {\n\t\t\tnext_st = current_st->st_hashchain_next;\n\t\t\tif (current_st->st_clonedfrom != 0 )\n\t\t\t\tchange_state(current_st, STATE_CHILDSA_DEL);\n\t\t\telse\n\t\t\t\tchange_state(current_st, STATE_IKESA_DEL);\n\t\t\tdelete_state(current_st);\n\t\t\tcurrent_st = next_st;\n\t\t}\n\t}\n\nreal_end:;\n}\n\n/*\n * Determine the IKE version we will use for the IKE packet\n * Normally, this is \"2.0\", but in the future we might need to\n * change that. Version used is the minimum 2.x version both\n * sides support. So if we support 2.1, and they support 2.0,\n * we should sent 2.0 (not implemented until we hit 2.1 ourselves)\n * We also have some impair functions that modify the major/minor\n * version on purpose - for testing\n *\n * rcv_version: the received IKE version, 0 if we don't know\n *\n * top 4 bits are major version, lower 4 bits are minor version\n */\nstatic int build_ike_version()\n{\nreturn ((IKEv2_MAJOR_VERSION + (DBGP(IMPAIR_MAJOR_VERSION_BUMP) ? 1 : 0))\n\t<< ISA_MAJ_SHIFT) | (IKEv2_MINOR_VERSION +\n\t(DBGP(IMPAIR_MINOR_VERSION_BUMP) ? 1 : 0));\n}\n"], "filenames": ["programs/pluto/ikev2_parent.c"], "buggy_code_start_loc": [309], "buggy_code_end_loc": [1799], "fixing_code_start_loc": [308], "fixing_code_end_loc": [1803], "type": "CWE-20", "message": "The ikev2parent_inI1outR1 function in pluto/ikev2_parent.c in libreswan before 3.7 allows remote attackers to cause a denial of service (restart) via an IKEv2 I1 notification without a KE payload.", "other": {"cve": {"id": "CVE-2013-7294", "sourceIdentifier": "cve@mitre.org", "published": "2014-01-16T05:05:26.523", "lastModified": "2018-01-03T02:29:00.240", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The ikev2parent_inI1outR1 function in pluto/ikev2_parent.c in libreswan before 3.7 allows remote attackers to cause a denial of service (restart) via an IKEv2 I1 notification without a KE payload."}, {"lang": "es", "value": "La funci\u00f3n ikev2parent_inI1outR1 en pluto/ikev2_parent.c de libreswan antes de 3.7 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (reinicio) a trav\u00e9s de una notificaci\u00f3n por IKEv2 I1 sin datos KE."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libreswan:libreswan:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.6", "matchCriteriaId": "81EE32A6-FAB7-42FD-B469-C5CD4355C443"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libreswan:libreswan:3.0:*:*:*:*:*:*:*", "matchCriteriaId": "20FC436A-6A9B-4546-8C12-2135BEBF615A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libreswan:libreswan:3.1:*:*:*:*:*:*:*", "matchCriteriaId": "82F2BE71-D672-44FB-AF13-F17B615CA829"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libreswan:libreswan:3.2:*:*:*:*:*:*:*", "matchCriteriaId": "EF083931-4370-468F-A0C6-9ACF6C846E75"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libreswan:libreswan:3.3:*:*:*:*:*:*:*", "matchCriteriaId": "79429CD5-F92C-4581-86FA-763935ACB680"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libreswan:libreswan:3.4:*:*:*:*:*:*:*", "matchCriteriaId": "9B70E897-574B-4FA9-B9F9-A5622E6B685C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libreswan:libreswan:3.5:*:*:*:*:*:*:*", "matchCriteriaId": "9E018CD7-6E5B-421E-BF06-AEE4EE0CA4BD"}]}]}], "references": [{"url": "http://secunia.com/advisories/56915", "source": "cve@mitre.org"}, {"url": "https://github.com/libreswan/libreswan/commit/2899351224fe2940aec37d7656e1e392c0fe07f0", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}, {"url": "https://lists.libreswan.org/pipermail/swan-announce/2013/000007.html", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/libreswan/libreswan/commit/2899351224fe2940aec37d7656e1e392c0fe07f0"}}