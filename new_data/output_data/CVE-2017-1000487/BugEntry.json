{"buggy_code": ["package org.codehaus.plexus.util.cli;\n\n/*\n * Copyright The Codehaus Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/***************************************************************************************************\n * CruiseControl, a Continuous Integration Toolkit Copyright (c) 2001-2003, ThoughtWorks, Inc. 651 W\n * Washington Ave. Suite 500 Chicago, IL 60661 USA All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted\n * provided that the following conditions are met: + Redistributions of source code must retain the\n * above copyright notice, this list of conditions and the following disclaimer. + Redistributions\n * in binary form must reproduce the above copyright notice, this list of conditions and the\n * following disclaimer in the documentation and/or other materials provided with the distribution. +\n * Neither the name of ThoughtWorks, Inc., CruiseControl, nor the names of its contributors may be\n * used to endorse or promote products derived from this software without specific prior written\n * permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n **************************************************************************************************/\n\n/*\n * ====================================================================\n * Copyright 2003-2004 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ====================================================================\n */\n\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.shell.BourneShell;\nimport org.codehaus.plexus.util.cli.shell.CmdShell;\nimport org.codehaus.plexus.util.cli.shell.CommandShell;\nimport org.codehaus.plexus.util.cli.shell.Shell;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Vector;\n\n/**\n * <p/>\n * Commandline objects help handling command lines specifying processes to\n * execute.\n * </p>\n * <p/>\n * The class can be used to define a command line as nested elements or as a\n * helper to define a command line by an application.\n * </p>\n * <p/>\n * <code>\n * &lt;someelement&gt;<br>\n * &nbsp;&nbsp;&lt;acommandline executable=\"/executable/to/run\"&gt;<br>\n * &nbsp;&nbsp;&nbsp;&nbsp;&lt;argument value=\"argument 1\" /&gt;<br>\n * &nbsp;&nbsp;&nbsp;&nbsp;&lt;argument line=\"argument_1 argument_2 argument_3\" /&gt;<br>\n * &nbsp;&nbsp;&nbsp;&nbsp;&lt;argument value=\"argument 4\" /&gt;<br>\n * &nbsp;&nbsp;&lt;/acommandline&gt;<br>\n * &lt;/someelement&gt;<br>\n * </code>\n * </p>\n * <p/>\n * The element <code>someelement</code> must provide a method\n * <code>createAcommandline</code> which returns an instance of this class.\n * </p>\n *\n * @author thomas.haas@softwired-inc.com\n * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig</a>\n */\npublic class Commandline\n    implements Cloneable\n{\n    /**\n     * @deprecated Use {@link org.codehaus.plexus.util.Os} class instead.\n     */\n    protected static final String OS_NAME = \"os.name\";\n\n    /**\n     * @deprecated Use {@link org.codehaus.plexus.util.Os} class instead.\n     */\n    protected static final String WINDOWS = \"Windows\";\n\n    protected Vector arguments = new Vector();\n\n    //protected Vector envVars = new Vector();\n    // synchronized added to preserve synchronize of Vector class\n    protected Map envVars = Collections.synchronizedMap( new LinkedHashMap() );\n\n    private long pid = -1;\n\n    private Shell shell;\n\n    /**\n     * @deprecated Use {@link Commandline#setExecutable(String)} instead.\n     */\n    protected String executable;\n\n    /**\n     * @deprecated Use {@link Commandline#setWorkingDirectory(File)} or\n     * {@link Commandline#setWorkingDirectory(String)} instead.\n     */\n    private File workingDir;\n\n    /**\n     * Create a new command line object.\n     * Shell is autodetected from operating system\n     *\n     * @param toProcess\n     */\n    public Commandline( String toProcess, Shell shell )\n    {\n        this.shell = shell;\n\n        String[] tmp = new String[0];\n        try\n        {\n            tmp = CommandLineUtils.translateCommandline( toProcess );\n        }\n        catch ( Exception e )\n        {\n            System.err.println( \"Error translating Commandline.\" );\n        }\n        if ( ( tmp != null ) && ( tmp.length > 0 ) )\n        {\n            setExecutable( tmp[0] );\n            for ( int i = 1; i < tmp.length; i++ )\n            {\n                createArgument().setValue( tmp[i] );\n            }\n        }\n    }\n\n    /**\n     * Create a new command line object.\n     * Shell is autodetected from operating system\n     */\n    public Commandline( Shell shell )\n    {\n        this.shell = shell;\n    }\n\n    /**\n     * Create a new command line object.\n     * Shell is autodetected from operating system\n     *\n     * @param toProcess\n     */\n    public Commandline( String toProcess )\n    {\n        setDefaultShell();\n        String[] tmp = new String[0];\n        try\n        {\n            tmp = CommandLineUtils.translateCommandline( toProcess );\n        }\n        catch ( Exception e )\n        {\n            System.err.println( \"Error translating Commandline.\" );\n        }\n        if ( ( tmp != null ) && ( tmp.length > 0 ) )\n        {\n            setExecutable( tmp[0] );\n            for ( int i = 1; i < tmp.length; i++ )\n            {\n                createArgument().setValue( tmp[i] );\n            }\n        }\n    }\n\n    /**\n     * Create a new command line object.\n     * Shell is autodetected from operating system\n     */\n    public Commandline()\n    {\n        setDefaultShell();\n    }\n\n    public long getPid()\n    {\n        if ( pid == -1 )\n        {\n            pid = Long.parseLong( String.valueOf( System.currentTimeMillis() ) );\n        }\n\n        return pid;\n    }\n\n    public void setPid( long pid )\n    {\n        this.pid = pid;\n    }\n\n    /**\n     * Class to keep track of the position of an Argument.\n     */\n    // <p>This class is there to support the srcfile and targetfile\n    // elements of &lt;execon&gt; and &lt;transform&gt; - don't know\n    // whether there might be additional use cases.</p> --SB\n    public class Marker\n    {\n\n        private int position;\n\n        private int realPos = -1;\n\n        Marker( int position )\n        {\n            this.position = position;\n        }\n\n        /**\n         * Return the number of arguments that preceeded this marker.\n         * <p/>\n         * <p>The name of the executable - if set - is counted as the\n         * very first argument.</p>\n         */\n        public int getPosition()\n        {\n            if ( realPos == -1 )\n            {\n                realPos = ( getExecutable() == null ? 0 : 1 );\n                for ( int i = 0; i < position; i++ )\n                {\n                    Arg arg = (Arg) arguments.elementAt( i );\n                    realPos += arg.getParts().length;\n                }\n            }\n            return realPos;\n        }\n    }\n\n    /**\n     * <p>Sets the shell or command-line interpretor for the detected operating system,\n     * and the shell arguments.</p>\n     */\n    private void setDefaultShell()\n    {\n        //If this is windows set the shell to command.com or cmd.exe with correct arguments.\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            if ( Os.isFamily( Os.FAMILY_WIN9X ) )\n            {\n                setShell( new CommandShell() );\n            }\n            else\n            {\n                setShell( new CmdShell() );\n            }\n        }\n        else\n        {\n            setShell( new BourneShell() );\n        }\n    }\n\n    /**\n     * Creates an argument object.\n     * <p/>\n     * <p>Each commandline object has at most one instance of the\n     * argument class.  This method calls\n     * <code>this.createArgument(false)</code>.</p>\n     *\n     * @return the argument object.\n     * @see #createArgument(boolean)\n     * @deprecated Use {@link Commandline#createArg()} instead\n     */\n    public Argument createArgument()\n    {\n        return this.createArgument( false );\n    }\n\n    /**\n     * Creates an argument object and adds it to our list of args.\n     * <p/>\n     * <p>Each commandline object has at most one instance of the\n     * argument class.</p>\n     *\n     * @param insertAtStart if true, the argument is inserted at the\n     *                      beginning of the list of args, otherwise it is appended.\n     * @deprecated Use {@link Commandline#createArg(boolean)} instead\n     */\n    public Argument createArgument( boolean insertAtStart )\n    {\n        Argument argument = new Argument();\n        if ( insertAtStart )\n        {\n            arguments.insertElementAt( argument, 0 );\n        }\n        else\n        {\n            arguments.addElement( argument );\n        }\n        return argument;\n    }\n\n    /**\n     * Creates an argument object.\n     * <p/>\n     * <p>Each commandline object has at most one instance of the\n     * argument class.  This method calls\n     * <code>this.createArgument(false)</code>.</p>\n     *\n     * @return the argument object.\n     * @see #createArgument(boolean)\n     */\n    public Arg createArg()\n    {\n        return this.createArg( false );\n    }\n\n    /**\n     * Creates an argument object and adds it to our list of args.\n     * <p/>\n     * <p>Each commandline object has at most one instance of the\n     * argument class.</p>\n     *\n     * @param insertAtStart if true, the argument is inserted at the\n     *                      beginning of the list of args, otherwise it is appended.\n     */\n    public Arg createArg( boolean insertAtStart )\n    {\n        Arg argument = new Argument();\n        if ( insertAtStart )\n        {\n            arguments.insertElementAt( argument, 0 );\n        }\n        else\n        {\n            arguments.addElement( argument );\n        }\n        return argument;\n    }\n\n    /**\n     * Adds an argument object to our list of args.\n     *\n     * @return the argument object.\n     * @see #addArg(Arg,boolean)\n     */\n    public void addArg( Arg argument )\n    {\n        this.addArg( argument, false );\n    }\n\n    /**\n     * Adds an argument object to our list of args.\n     *\n     * @param insertAtStart if true, the argument is inserted at the\n     *                      beginning of the list of args, otherwise it is appended.\n     */\n    public void addArg( Arg argument, boolean insertAtStart )\n    {\n        if ( insertAtStart )\n        {\n            arguments.insertElementAt( argument, 0 );\n        }\n        else\n        {\n            arguments.addElement( argument );\n        }\n    }\n\n    /**\n     * Sets the executable to run.\n     */\n    public void setExecutable( String executable )\n    {\n        shell.setExecutable( executable );\n        this.executable = executable;\n    }\n\n    public String getExecutable()\n    {\n        String exec = shell.getExecutable();\n\n        if ( exec == null )\n        {\n            exec = executable;\n        }\n\n        return exec;\n    }\n\n    public void addArguments( String[] line )\n    {\n        for ( int i = 0; i < line.length; i++ )\n        {\n            createArgument().setValue( line[i] );\n        }\n    }\n\n    /**\n     * Add an environment variable\n     */\n    public void addEnvironment( String name, String value )\n    {\n        //envVars.add( name + \"=\" + value );\n        envVars.put( name, value );\n    }\n\n    /**\n     * Add system environment variables\n     */\n    public void addSystemEnvironment()\n        throws Exception\n    {\n        Properties systemEnvVars = CommandLineUtils.getSystemEnvVars();\n\n        for ( Iterator i = systemEnvVars.keySet().iterator(); i.hasNext(); )\n        {\n            String key = (String) i.next();\n            if ( !envVars.containsKey( key ) )\n            {\n                addEnvironment( key, systemEnvVars.getProperty( key ) );\n            }\n        }\n    }\n\n    /**\n     * Return the list of environment variables\n     */\n    public String[] getEnvironmentVariables()\n        throws CommandLineException\n    {\n        try\n        {\n            addSystemEnvironment();\n        }\n        catch ( Exception e )\n        {\n            throw new CommandLineException( \"Error setting up environmental variables\", e );\n        }\n        String[] environmentVars = new String[envVars.size()];\n        int i = 0;\n        for ( Iterator iterator = envVars.keySet().iterator(); iterator.hasNext(); )\n        {\n            String name = (String) iterator.next();\n            String value = (String) envVars.get( name );\n            environmentVars[i] = name + \"=\" + value;\n            i++;\n        }\n        return environmentVars;\n    }\n\n    /**\n     * Returns the executable and all defined arguments.\n     */\n    public String[] getCommandline()\n    {\n        final String[] args = getArguments();\n        String executable = getExecutable();\n\n        if ( executable == null )\n        {\n            return args;\n        }\n        final String[] result = new String[args.length + 1];\n        result[0] = executable;\n        System.arraycopy( args, 0, result, 1, args.length );\n        return result;\n    }\n\n    /**\n     * Returns the shell, executable and all defined arguments.\n     */\n    public String[] getShellCommandline()\n    {\n        // TODO: Provided only for backward compat. with <= 1.4\n        verifyShellState();\n\n        return (String[]) getShell().getShellCommandLine( getArguments() ).toArray( new String[0] );\n    }\n\n    /**\n     * Returns all arguments defined by <code>addLine</code>,\n     * <code>addValue</code> or the argument object.\n     */\n    public String[] getArguments()\n    {\n        Vector result = new Vector( arguments.size() * 2 );\n        for ( int i = 0; i < arguments.size(); i++ )\n        {\n            Argument arg = (Argument) arguments.elementAt( i );\n            String[] s = arg.getParts();\n            if ( s != null )\n            {\n                for ( int j = 0; j < s.length; j++ )\n                {\n                    result.addElement( s[j] );\n                }\n            }\n        }\n\n        String[] res = new String[result.size()];\n        result.copyInto( res );\n        return res;\n    }\n\n    public String toString()\n    {\n        return StringUtils.join( getShellCommandline(), \" \" );\n    }\n\n    public int size()\n    {\n        return getCommandline().length;\n    }\n\n    public Object clone()\n    {\n        Commandline c = new Commandline( (Shell) shell.clone() );\n        c.executable = executable;\n        c.workingDir = workingDir;\n        c.addArguments( getArguments() );\n        return c;\n    }\n\n    /**\n     * Clear out the whole command line.\n     */\n    public void clear()\n    {\n        executable = null;\n        workingDir = null;\n        shell.setExecutable( null );\n        shell.clearArguments();\n        arguments.removeAllElements();\n    }\n\n    /**\n     * Clear out the arguments but leave the executable in place for another operation.\n     */\n    public void clearArgs()\n    {\n        arguments.removeAllElements();\n    }\n\n    /**\n     * Return a marker.\n     * <p/>\n     * <p>This marker can be used to locate a position on the\n     * commandline - to insert something for example - when all\n     * parameters have been set.</p>\n     */\n    public Marker createMarker()\n    {\n        return new Marker( arguments.size() );\n    }\n\n    /**\n     * Sets execution directory.\n     */\n    public void setWorkingDirectory( String path )\n    {\n        shell.setWorkingDirectory( path );\n        workingDir = new File( path );\n    }\n\n    /**\n     * Sets execution directory.\n     */\n    public void setWorkingDirectory( File workingDirectory )\n    {\n        shell.setWorkingDirectory( workingDirectory );\n        workingDir = workingDirectory;\n    }\n\n    public File getWorkingDirectory()\n    {\n        File workDir = shell.getWorkingDirectory();\n\n        if ( workDir == null )\n        {\n            workDir = workingDir;\n        }\n\n        return workDir;\n    }\n\n    /**\n     * Executes the command.\n     */\n    public Process execute()\n        throws CommandLineException\n    {\n        // TODO: Provided only for backward compat. with <= 1.4\n        verifyShellState();\n\n        Process process;\n\n        //addEnvironment( \"MAVEN_TEST_ENVAR\", \"MAVEN_TEST_ENVAR_VALUE\" );\n\n        String[] environment = getEnvironmentVariables();\n\n        File workingDir = shell.getWorkingDirectory();\n\n        try\n        {\n            if ( workingDir == null )\n            {\n                process = Runtime.getRuntime().exec( getShellCommandline(), environment );\n            }\n            else\n            {\n                if ( !workingDir.exists() )\n                {\n                    throw new CommandLineException( \"Working directory \\\"\" + workingDir.getPath()\n                        + \"\\\" does not exist!\" );\n                }\n                else if ( !workingDir.isDirectory() )\n                {\n                    throw new CommandLineException( \"Path \\\"\" + workingDir.getPath()\n                        + \"\\\" does not specify a directory.\" );\n                }\n\n                process = Runtime.getRuntime().exec( getShellCommandline(), environment, workingDir );\n            }\n        }\n        catch ( IOException ex )\n        {\n            throw new CommandLineException( \"Error while executing process.\", ex );\n        }\n\n        return process;\n    }\n\n    /**\n     * @deprecated Remove once backward compat with plexus-utils <= 1.4 is no longer a consideration\n     */\n    private void verifyShellState()\n    {\n        if ( shell.getWorkingDirectory() == null )\n        {\n            shell.setWorkingDirectory( workingDir );\n        }\n\n        if ( shell.getExecutable() == null )\n        {\n            shell.setExecutable( executable );\n        }\n    }\n\n    public Properties getSystemEnvVars()\n        throws Exception\n    {\n        return CommandLineUtils.getSystemEnvVars();\n    }\n\n    /**\n     * Allows to set the shell to be used in this command line.\n     *\n     * @param shell\n     * @since 1.2\n     */\n    public void setShell( Shell shell )\n    {\n        this.shell = shell;\n    }\n\n    /**\n     * Get the shell to be used in this command line.\n     *\n     * @since 1.2\n     */\n    public Shell getShell()\n    {\n        return shell;\n    }\n\n    /**\n     * @deprecated Use {@link CommandLineUtils#translateCommandline(String)} instead.\n     */\n    public static String[] translateCommandline( String toProcess )\n        throws Exception\n    {\n        return CommandLineUtils.translateCommandline( toProcess );\n    }\n\n    /**\n     * @deprecated Use {@link CommandLineUtils#quote(String)} instead.\n     */\n    public static String quoteArgument( String argument )\n        throws CommandLineException\n    {\n        return CommandLineUtils.quote( argument );\n    }\n\n    /**\n     * @deprecated Use {@link CommandLineUtils#toString(String[])} instead.\n     */\n    public static String toString( String[] line )\n    {\n        return CommandLineUtils.toString( line );\n    }\n\n    public static class Argument\n        implements Arg\n    {\n        private String[] parts;\n\n        /* (non-Javadoc)\n         * @see org.codehaus.plexus.util.cli.Argumnt#setValue(java.lang.String)\n         */\n        public void setValue( String value )\n        {\n            if ( value != null )\n            {\n                parts = new String[] { value };\n            }\n        }\n\n        /* (non-Javadoc)\n         * @see org.codehaus.plexus.util.cli.Argumnt#setLine(java.lang.String)\n         */\n        public void setLine( String line )\n        {\n            if ( line == null )\n            {\n                return;\n            }\n            try\n            {\n                parts = CommandLineUtils.translateCommandline( line );\n            }\n            catch ( Exception e )\n            {\n                System.err.println( \"Error translating Commandline.\" );\n            }\n        }\n\n        /* (non-Javadoc)\n         * @see org.codehaus.plexus.util.cli.Argumnt#setFile(java.io.File)\n         */\n        public void setFile( File value )\n        {\n            parts = new String[] { value.getAbsolutePath() };\n        }\n\n        /* (non-Javadoc)\n         * @see org.codehaus.plexus.util.cli.Argumnt#getParts()\n         */\n        public String[] getParts()\n        {\n            return parts;\n        }\n    }\n}\n", "package org.codehaus.plexus.util.cli.shell;\n\n/*\n * Copyright The Codehaus Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @author Jason van Zyl\n * @version $Id$\n */\npublic class BourneShell\n    extends Shell\n{\n    private static final char[] BASH_QUOTING_TRIGGER_CHARS = {\n        ' ',\n        '$',\n        ';',\n        '&',\n        '|',\n        '<',\n        '>',\n        '*',\n        '?',\n        '(',\n        ')',\n        '[',\n        ']',\n        '{',\n        '}',\n        '`' };\n\n    public BourneShell()\n    {\n        this( false );\n    }\n\n    public BourneShell( boolean isLoginShell )\n    {\n        setShellCommand( \"/bin/sh\" );\n        setArgumentQuoteDelimiter( '\\'' );\n        setExecutableQuoteDelimiter( '\\\"' );\n        setSingleQuotedArgumentEscaped( true );\n        setSingleQuotedExecutableEscaped( false );\n        setQuotedExecutableEnabled( true );\n        setArgumentEscapePattern(\"'\\\\%s'\");\n\n        if ( isLoginShell )\n        {\n            addShellArg( \"-l\" );\n        }\n    }\n\n    /** {@inheritDoc} */\n    public String getExecutable()\n    {\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            return super.getExecutable();\n        }\n\n        return unifyQuotes( super.getExecutable());\n    }\n\n    public List<String> getShellArgsList()\n    {\n        List<String> shellArgs = new ArrayList<String>();\n        List<String> existingShellArgs = super.getShellArgsList();\n\n        if ( ( existingShellArgs != null ) && !existingShellArgs.isEmpty() )\n        {\n            shellArgs.addAll( existingShellArgs );\n        }\n\n        shellArgs.add( \"-c\" );\n\n        return shellArgs;\n    }\n\n    public String[] getShellArgs()\n    {\n        String[] shellArgs = super.getShellArgs();\n        if ( shellArgs == null )\n        {\n            shellArgs = new String[0];\n        }\n\n        if ( ( shellArgs.length > 0 ) && !shellArgs[shellArgs.length - 1].equals( \"-c\" ) )\n        {\n            String[] newArgs = new String[shellArgs.length + 1];\n\n            System.arraycopy( shellArgs, 0, newArgs, 0, shellArgs.length );\n            newArgs[shellArgs.length] = \"-c\";\n\n            shellArgs = newArgs;\n        }\n\n        return shellArgs;\n    }\n\n    protected String getExecutionPreamble()\n    {\n        if ( getWorkingDirectoryAsString() == null )\n        {\n            return null;\n        }\n\n        String dir = getWorkingDirectoryAsString();\n        StringBuilder sb = new StringBuilder();\n        sb.append( \"cd \" );\n\n        sb.append( unifyQuotes( dir ) );\n        sb.append( \" && \" );\n\n        return sb.toString();\n    }\n\n    protected char[] getQuotingTriggerChars()\n    {\n        return BASH_QUOTING_TRIGGER_CHARS;\n    }\n\n    /**\n     * <p>Unify quotes in a path for the Bourne Shell.</p>\n     *\n     * <pre>\n     * BourneShell.unifyQuotes(null)                       = null\n     * BourneShell.unifyQuotes(\"\")                         = (empty)\n     * BourneShell.unifyQuotes(\"/test/quotedpath'abc\")     = /test/quotedpath\\'abc\n     * BourneShell.unifyQuotes(\"/test/quoted path'abc\")    = \"/test/quoted path'abc\"\n     * BourneShell.unifyQuotes(\"/test/quotedpath\\\"abc\")    = \"/test/quotedpath\\\"abc\"\n     * BourneShell.unifyQuotes(\"/test/quoted path\\\"abc\")   = \"/test/quoted path\\\"abc\"\n     * BourneShell.unifyQuotes(\"/test/quotedpath\\\"'abc\")   = \"/test/quotedpath\\\"'abc\"\n     * BourneShell.unifyQuotes(\"/test/quoted path\\\"'abc\")  = \"/test/quoted path\\\"'abc\"\n     * </pre>\n     *\n     * @param path not null path.\n     * @return the path unified correctly for the Bourne shell.\n     */\n    protected static String unifyQuotes( String path )\n    {\n        if ( path == null )\n        {\n            return null;\n        }\n\n        if ( path.indexOf( \" \" ) == -1 && path.indexOf( \"'\" ) != -1 && path.indexOf( \"\\\"\" ) == -1 )\n        {\n            return StringUtils.escape( path );\n        }\n\n        return StringUtils.quoteAndEscape( path, '\\\"', BASH_QUOTING_TRIGGER_CHARS );\n    }\n}\n", "package org.codehaus.plexus.util.cli.shell;\n\n/*\n * Copyright The Codehaus Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * <p>\n * Class that abstracts the Shell functionality,\n * with subclases for shells that behave particularly, like\n * <ul>\n * <li><code>command.com</code></li>\n * <li><code>cmd.exe</code></li>\n * </ul>\n * </p>\n *\n * @author <a href=\"mailto:carlos@apache.org\">Carlos Sanchez</a>\n * @since 1.2\n * @version $Id$\n */\npublic class Shell\n    implements Cloneable\n{\n    private static final char[] DEFAULT_QUOTING_TRIGGER_CHARS = { ' ' };\n\n    private String shellCommand;\n\n    private List<String> shellArgs = new ArrayList<String>();\n\n    private boolean quotedArgumentsEnabled = true;\n\n    private String executable;\n\n    private String workingDir;\n\n    private boolean quotedExecutableEnabled = true;\n\n    private boolean doubleQuotedArgumentEscaped = false;\n\n    private boolean singleQuotedArgumentEscaped = false;\n\n    private boolean doubleQuotedExecutableEscaped = false;\n\n    private boolean singleQuotedExecutableEscaped = false;\n\n    private char argQuoteDelimiter = '\\\"';\n\n    private char exeQuoteDelimiter = '\\\"';\n\n    private String argumentEscapePattern = \"\\\\%s\";\n\n    /**\n     * Set the command to execute the shell (eg. COMMAND.COM, /bin/bash,...)\n     *\n     * @param shellCommand\n     */\n    public void setShellCommand( String shellCommand )\n    {\n        this.shellCommand = shellCommand;\n    }\n\n    /**\n     * Get the command to execute the shell\n     *\n     * @return\n     */\n    public String getShellCommand()\n    {\n        return shellCommand;\n    }\n\n    /**\n     * Set the shell arguments when calling a command line (not the executable arguments)\n     * (eg. /X /C for CMD.EXE)\n     *\n     * @param shellArgs\n     */\n    public void setShellArgs( String[] shellArgs )\n    {\n        this.shellArgs.clear();\n        this.shellArgs.addAll( Arrays.asList( shellArgs ) );\n    }\n\n    /**\n     * Get the shell arguments\n     *\n     * @return\n     */\n    public String[] getShellArgs()\n    {\n        if ( ( shellArgs == null ) || shellArgs.isEmpty() )\n        {\n            return null;\n        }\n        else\n        {\n            return (String[]) shellArgs.toArray( new String[shellArgs.size()] );\n        }\n    }\n\n    /**\n     * Get the command line for the provided executable and arguments in this shell\n     *\n     * @param executable executable that the shell has to call\n     * @param arguments  arguments for the executable, not the shell\n     * @return List with one String object with executable and arguments quoted as needed\n     */\n    public List<String> getCommandLine( String executable, String[] arguments )\n    {\n        return getRawCommandLine( executable, arguments );\n    }\n\n    protected List<String> getRawCommandLine( String executable, String[] arguments )\n    {\n        List<String> commandLine = new ArrayList<String>();\n        StringBuilder sb = new StringBuilder();\n\n        if ( executable != null )\n        {\n            String preamble = getExecutionPreamble();\n            if ( preamble != null )\n            {\n                sb.append( preamble );\n            }\n\n            if ( isQuotedExecutableEnabled() )\n            {\n                char[] escapeChars = getEscapeChars( isSingleQuotedExecutableEscaped(), isDoubleQuotedExecutableEscaped() );\n\n                sb.append( StringUtils.quoteAndEscape( getExecutable(), getExecutableQuoteDelimiter(), escapeChars, getQuotingTriggerChars(), '\\\\', false ) );\n            }\n            else\n            {\n                sb.append( getExecutable() );\n            }\n        }\n        for ( int i = 0; i < arguments.length; i++ )\n        {\n            if ( sb.length() > 0 )\n            {\n                sb.append( \" \" );\n            }\n\n            if ( isQuotedArgumentsEnabled() )\n            {\n                char[] escapeChars = getEscapeChars( isSingleQuotedArgumentEscaped(), isDoubleQuotedArgumentEscaped() );\n\n                sb.append( StringUtils.quoteAndEscape( arguments[i], getArgumentQuoteDelimiter(), escapeChars, getQuotingTriggerChars(), getArgumentEscapePattern(), false ) );\n            }\n            else\n            {\n                sb.append( arguments[i] );\n            }\n        }\n\n        commandLine.add( sb.toString() );\n\n        return commandLine;\n    }\n\n    protected char[] getQuotingTriggerChars()\n    {\n        return DEFAULT_QUOTING_TRIGGER_CHARS;\n    }\n\n    protected String getExecutionPreamble()\n    {\n        return null;\n    }\n\n    protected char[] getEscapeChars( boolean includeSingleQuote, boolean includeDoubleQuote )\n    {\n        StringBuilder buf = new StringBuilder( 2 );\n        if ( includeSingleQuote )\n        {\n            buf.append( '\\'' );\n        }\n\n        if ( includeDoubleQuote )\n        {\n            buf.append( '\\\"' );\n        }\n\n        char[] result = new char[buf.length()];\n        buf.getChars( 0, buf.length(), result, 0 );\n\n        return result;\n    }\n\n    protected boolean isDoubleQuotedArgumentEscaped()\n    {\n        return doubleQuotedArgumentEscaped;\n    }\n\n    protected boolean isSingleQuotedArgumentEscaped()\n    {\n        return singleQuotedArgumentEscaped;\n    }\n\n    protected boolean isDoubleQuotedExecutableEscaped()\n    {\n        return doubleQuotedExecutableEscaped;\n    }\n\n    protected boolean isSingleQuotedExecutableEscaped()\n    {\n        return singleQuotedExecutableEscaped;\n    }\n\n    protected void setArgumentQuoteDelimiter( char argQuoteDelimiter )\n    {\n        this.argQuoteDelimiter = argQuoteDelimiter;\n    }\n\n    protected char getArgumentQuoteDelimiter()\n    {\n        return argQuoteDelimiter;\n    }\n\n    protected void setExecutableQuoteDelimiter( char exeQuoteDelimiter )\n    {\n        this.exeQuoteDelimiter = exeQuoteDelimiter;\n    }\n\n    protected char getExecutableQuoteDelimiter()\n    {\n        return exeQuoteDelimiter;\n    }\n\n    protected void setArgumentEscapePattern(String argumentEscapePattern)\n    {\n        this.argumentEscapePattern = argumentEscapePattern;\n    }\n\n    protected String getArgumentEscapePattern() {\n        return argumentEscapePattern;\n    }\n\n    /**\n     * Get the full command line to execute, including shell command, shell arguments,\n     * executable and executable arguments\n     *\n     * @param arguments  arguments for the executable, not the shell\n     * @return List of String objects, whose array version is suitable to be used as argument\n     *         of Runtime.getRuntime().exec()\n     */\n    public List<String> getShellCommandLine( String[] arguments )\n    {\n\n        List<String> commandLine = new ArrayList<String>();\n\n        if ( getShellCommand() != null )\n        {\n            commandLine.add( getShellCommand() );\n        }\n\n        if ( getShellArgs() != null )\n        {\n            commandLine.addAll( getShellArgsList() );\n        }\n\n        commandLine.addAll( getCommandLine( getExecutable(), arguments ) );\n\n        return commandLine;\n\n    }\n\n    public List<String> getShellArgsList()\n    {\n        return shellArgs;\n    }\n\n    public void addShellArg( String arg )\n    {\n        shellArgs.add( arg );\n    }\n\n    public void setQuotedArgumentsEnabled( boolean quotedArgumentsEnabled )\n    {\n        this.quotedArgumentsEnabled = quotedArgumentsEnabled;\n    }\n\n    public boolean isQuotedArgumentsEnabled()\n    {\n        return quotedArgumentsEnabled;\n    }\n\n    public void setQuotedExecutableEnabled( boolean quotedExecutableEnabled )\n    {\n        this.quotedExecutableEnabled = quotedExecutableEnabled;\n    }\n\n    public boolean isQuotedExecutableEnabled()\n    {\n        return quotedExecutableEnabled;\n    }\n\n    /**\n     * Sets the executable to run.\n     */\n    public void setExecutable( String executable )\n    {\n        if ( ( executable == null ) || ( executable.length() == 0 ) )\n        {\n            return;\n        }\n        this.executable = executable.replace( '/', File.separatorChar ).replace( '\\\\', File.separatorChar );\n    }\n\n    public String getExecutable()\n    {\n        return executable;\n    }\n\n    /**\n     * Sets execution directory.\n     */\n    public void setWorkingDirectory( String path )\n    {\n        if ( path != null )\n        {\n            workingDir = path;\n        }\n    }\n\n    /**\n     * Sets execution directory.\n     */\n    public void setWorkingDirectory( File workingDir )\n    {\n        if ( workingDir != null )\n        {\n            this.workingDir = workingDir.getAbsolutePath();\n        }\n    }\n\n    public File getWorkingDirectory()\n    {\n        return workingDir == null ? null : new File( workingDir );\n    }\n\n    public String getWorkingDirectoryAsString()\n    {\n        return workingDir;\n    }\n\n    public void clearArguments()\n    {\n        shellArgs.clear();\n    }\n\n    public Object clone()\n    {\n        Shell shell = new Shell();\n        shell.setExecutable( getExecutable() );\n        shell.setWorkingDirectory( getWorkingDirectory() );\n        shell.setShellArgs( getShellArgs() );\n        return shell;\n    }\n\n    public String getOriginalExecutable()\n    {\n        return executable;\n    }\n\n    public List<String> getOriginalCommandLine( String executable, String[] arguments )\n    {\n        return getRawCommandLine( executable, arguments );\n    }\n\n    protected void setDoubleQuotedArgumentEscaped( boolean doubleQuotedArgumentEscaped )\n    {\n        this.doubleQuotedArgumentEscaped = doubleQuotedArgumentEscaped;\n    }\n\n    protected void setDoubleQuotedExecutableEscaped( boolean doubleQuotedExecutableEscaped )\n    {\n        this.doubleQuotedExecutableEscaped = doubleQuotedExecutableEscaped;\n    }\n\n    protected void setSingleQuotedArgumentEscaped( boolean singleQuotedArgumentEscaped )\n    {\n        this.singleQuotedArgumentEscaped = singleQuotedArgumentEscaped;\n    }\n\n    protected void setSingleQuotedExecutableEscaped( boolean singleQuotedExecutableEscaped )\n    {\n        this.singleQuotedExecutableEscaped = singleQuotedExecutableEscaped;\n    }\n}\n", "package org.codehaus.plexus.util.cli;\n\n/*\n * Copyright The Codehaus Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.shell.BourneShell;\nimport org.codehaus.plexus.util.cli.shell.CmdShell;\nimport org.codehaus.plexus.util.cli.shell.Shell;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringWriter;\nimport java.io.Writer;\n\nimport junit.framework.TestCase;\n\npublic class CommandlineTest\n    extends TestCase\n{\n    private String baseDir;\n\n    /**\n     * @param testName\n     */\n    public CommandlineTest( final String testName )\n    {\n        super( testName );\n    }\n\n    /*\n     * @see TestCase#setUp()\n     */\n    public void setUp()\n        throws Exception\n    {\n        super.setUp();\n        baseDir = System.getProperty( \"basedir\" );\n\n        if ( baseDir == null )\n        {\n            baseDir = new File( \".\" ).getCanonicalPath();\n        }\n    }\n\n    public void testCommandlineWithoutCommandInConstructor()\n    {\n        try\n        {\n            Commandline cmd = new Commandline( new Shell() );\n            cmd.setWorkingDirectory( baseDir );\n            cmd.createArgument().setValue( \"cd\" );\n            cmd.createArgument().setValue( \".\" );\n\n            // NOTE: cmd.toString() uses CommandLineUtils.toString( String[] ), which *quotes* the result.\n            assertEquals( \"cd .\", cmd.toString() );\n        }\n        catch ( Exception e )\n        {\n            fail( e.getMessage() );\n        }\n    }\n\n    public void testCommandlineWithCommandInConstructor()\n    {\n        try\n        {\n            Commandline cmd = new Commandline( \"cd .\", new Shell() );\n            cmd.setWorkingDirectory( baseDir );\n\n            // NOTE: cmd.toString() uses CommandLineUtils.toString( String[] ), which *quotes* the result.\n            assertEquals( \"cd .\", cmd.toString() );\n        }\n        catch ( Exception e )\n        {\n            fail( e.getMessage() );\n        }\n    }\n\n    public void testExecute()\n    {\n        try\n        {\n            // allow it to detect the proper shell here.\n            Commandline cmd = new Commandline();\n            cmd.setWorkingDirectory( baseDir );\n            cmd.setExecutable( \"echo\" );\n            assertEquals( \"echo\", cmd.getShell().getOriginalExecutable() );\n            cmd.createArgument().setValue( \"Hello\" );\n\n            StringWriter swriter = new StringWriter();\n            Process process = cmd.execute();\n\n            Reader reader = new InputStreamReader( process.getInputStream() );\n\n            char[] chars = new char[16];\n            int read = -1;\n            while ( ( read = reader.read( chars ) ) > -1 )\n            {\n                swriter.write( chars, 0, read );\n            }\n\n            String output = swriter.toString().trim();\n\n            assertEquals( \"Hello\", output );\n        }\n        catch ( Exception e )\n        {\n            fail( e.getMessage() );\n        }\n    }\n\n    public void testSetLine()\n    {\n        try\n        {\n            Commandline cmd = new Commandline( new Shell() );\n            cmd.setWorkingDirectory( baseDir );\n            cmd.setExecutable( \"echo\" );\n            cmd.createArgument().setLine( null );\n            cmd.createArgument().setLine( \"Hello\" );\n\n            // NOTE: cmd.toString() uses CommandLineUtils.toString( String[] ), which *quotes* the result.\n            assertEquals( \"echo Hello\", cmd.toString() );\n        }\n        catch ( Exception e )\n        {\n            fail( e.getMessage() );\n        }\n    }\n\n    public void testCreateCommandInReverseOrder()\n    {\n        try\n        {\n            Commandline cmd = new Commandline( new Shell() );\n            cmd.setWorkingDirectory( baseDir );\n            cmd.createArgument().setValue( \".\" );\n            cmd.createArgument( true ).setValue( \"cd\" );\n\n            // NOTE: cmd.toString() uses CommandLineUtils.toString( String[] ), which *quotes* the result.\n            assertEquals( \"cd .\", cmd.toString() );\n        }\n        catch ( Exception e )\n        {\n            fail( e.getMessage() );\n        }\n    }\n\n    public void testSetFile()\n    {\n        try\n        {\n            Commandline cmd = new Commandline( new Shell() );\n            cmd.setWorkingDirectory( baseDir );\n            cmd.createArgument().setValue( \"more\" );\n            File f = new File( \"test.txt\" );\n            cmd.createArgument().setFile( f );\n            String fileName = f.getAbsolutePath();\n            if ( fileName.indexOf( \" \" ) >= 0 )\n            {\n                fileName = \"\\\"\" + fileName + \"\\\"\";\n            }\n\n            // NOTE: cmd.toString() uses CommandLineUtils.toString( String[] ), which *quotes* the result.\n            assertEquals( \"more \" + fileName, cmd.toString() );\n        }\n        catch ( Exception e )\n        {\n            fail( e.getMessage() );\n        }\n    }\n\n    public void testGetShellCommandLineWindows()\n        throws Exception\n    {\n        Commandline cmd = new Commandline( new CmdShell() );\n        cmd.setExecutable( \"c:\\\\Program Files\\\\xxx\" );\n        cmd.addArguments( new String[] {\n            \"a\",\n            \"b\"\n        } );\n        String[] shellCommandline = cmd.getShellCommandline();\n\n        assertEquals( \"Command line size\", 4, shellCommandline.length );\n\n        assertEquals( \"cmd.exe\", shellCommandline[0] );\n        assertEquals( \"/X\", shellCommandline[1] );\n        assertEquals( \"/C\", shellCommandline[2] );\n        String expectedShellCmd = \"\\\"c:\" + File.separator + \"Program Files\" + File.separator\n                                  + \"xxx\\\" a b\";\n        expectedShellCmd = \"\\\"\" + expectedShellCmd + \"\\\"\";\n        assertEquals( expectedShellCmd, shellCommandline[3] );\n    }\n\n    public void testGetShellCommandLineWindowsWithSeveralQuotes()\n        throws Exception\n    {\n        Commandline cmd = new Commandline( new CmdShell() );\n        cmd.setExecutable( \"c:\\\\Program Files\\\\xxx\" );\n        cmd.addArguments( new String[] {\n            \"c:\\\\Documents and Settings\\\\whatever\",\n            \"b\"\n        } );\n        String[] shellCommandline = cmd.getShellCommandline();\n\n        assertEquals( \"Command line size\", 4, shellCommandline.length );\n\n        assertEquals( \"cmd.exe\", shellCommandline[0] );\n        assertEquals( \"/X\", shellCommandline[1] );\n        assertEquals( \"/C\", shellCommandline[2] );\n        String expectedShellCmd = \"\\\"c:\" + File.separator + \"Program Files\" + File.separator\n                                  + \"xxx\\\" \\\"c:\\\\Documents and Settings\\\\whatever\\\" b\";\n        expectedShellCmd = \"\\\"\" + expectedShellCmd + \"\\\"\";\n        assertEquals( expectedShellCmd, shellCommandline[3] );\n    }\n\n    /**\n     * Test the command line generated for the bash shell\n     * @throws Exception\n     */\n    public void testGetShellCommandLineBash()\n        throws Exception\n    {\n        Commandline cmd = new Commandline( new BourneShell() );\n        cmd.setExecutable( \"/bin/echo\" );\n        cmd.addArguments( new String[] {\n            \"hello world\"\n        } );\n\n        String[] shellCommandline = cmd.getShellCommandline();\n\n        assertEquals( \"Command line size\", 3, shellCommandline.length );\n\n        assertEquals( \"/bin/sh\", shellCommandline[0] );\n        assertEquals( \"-c\", shellCommandline[1] );\n        String expectedShellCmd = \"/bin/echo \\'hello world\\'\";\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            expectedShellCmd = \"\\\\bin\\\\echo \\'hello world\\'\";\n        }\n        assertEquals( expectedShellCmd, shellCommandline[2] );\n    }\n\n    /**\n    * Test the command line generated for the bash shell\n    * @throws Exception\n    */\n    public void testGetShellCommandLineBash_WithWorkingDirectory()\n        throws Exception\n    {\n        Commandline cmd = new Commandline( new BourneShell() );\n        cmd.setExecutable( \"/bin/echo\" );\n        cmd.addArguments( new String[] {\n            \"hello world\"\n        } );\n        File root = File.listRoots()[0];\n        File workingDirectory = new File( root, \"path with spaces\" );\n        cmd.setWorkingDirectory( workingDirectory );\n\n        String[] shellCommandline = cmd.getShellCommandline();\n\n        assertEquals( \"Command line size\", 3, shellCommandline.length );\n\n        assertEquals( \"/bin/sh\", shellCommandline[0] );\n        assertEquals( \"-c\", shellCommandline[1] );\n        String expectedShellCmd = \"cd \\\"\" + root.getAbsolutePath()\n                                  + \"path with spaces\\\" && /bin/echo \\'hello world\\'\";\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            expectedShellCmd = \"cd \\\"\" + root.getAbsolutePath()\n                               + \"path with spaces\\\" && \\\\bin\\\\echo \\'hello world\\'\";\n        }\n        assertEquals( expectedShellCmd, shellCommandline[2] );\n    }\n\n    /**\n     * Test the command line generated for the bash shell\n     * @throws Exception\n     */\n    public void testGetShellCommandLineBash_WithSingleQuotedArg()\n        throws Exception\n    {\n        Commandline cmd = new Commandline( new BourneShell() );\n        cmd.setExecutable( \"/bin/echo\" );\n        cmd.addArguments( new String[] {\n            \"\\'hello world\\'\"\n        } );\n\n        String[] shellCommandline = cmd.getShellCommandline();\n\n        assertEquals( \"Command line size\", 3, shellCommandline.length );\n\n        assertEquals( \"/bin/sh\", shellCommandline[0] );\n        assertEquals( \"-c\", shellCommandline[1] );\n        String expectedShellCmd = \"/bin/echo \\'hello world\\'\";\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            expectedShellCmd = \"\\\\bin\\\\echo \\'hello world\\'\";\n        }\n        assertEquals( expectedShellCmd, shellCommandline[2] );\n    }\n\n    public void testGetShellCommandLineNonWindows()\n        throws Exception\n    {\n        Commandline cmd = new Commandline( new BourneShell() );\n        cmd.setExecutable( \"/usr/bin\" );\n        cmd.addArguments( new String[] {\n            \"a\",\n            \"b\"\n        } );\n        String[] shellCommandline = cmd.getShellCommandline();\n\n        assertEquals( \"Command line size\", 3, shellCommandline.length );\n\n        assertEquals( \"/bin/sh\", shellCommandline[0] );\n        assertEquals( \"-c\", shellCommandline[1] );\n\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            assertEquals( \"\\\\usr\\\\bin a b\", shellCommandline[2] );\n        }\n        else\n        {\n            assertEquals( \"/usr/bin a b\", shellCommandline[2] );\n        }\n    }\n\n    public void testEnvironment()\n        throws Exception\n    {\n        Commandline cmd = new Commandline();\n        cmd.addEnvironment( \"name\", \"value\" );\n        assertEquals( \"name=value\", cmd.getEnvironmentVariables()[0] );\n    }\n\n    public void testEnvironmentWitOverrideSystemEnvironment()\n        throws Exception\n    {\n        Commandline cmd = new Commandline();\n        cmd.addSystemEnvironment();\n        cmd.addEnvironment( \"JAVA_HOME\", \"/usr/jdk1.5\" );\n        String[] environmentVariables = cmd.getEnvironmentVariables();\n\n        for ( int i = 0, size = environmentVariables.length; i < size; i++ )\n        {\n            if ( \"JAVA_HOME=/usr/jdk1.5\".equals( environmentVariables[i] ) )\n            {\n                return;\n            }\n        }\n\n        fail( \"can't find JAVA_HOME=/usr/jdk1.5\" );\n    }\n\n    /**\n     * Test an executable with a single apostrophe <code>'</code> in its path\n     *\n     * @throws Exception\n     */\n    public void testQuotedPathWithSingleApostrophe()\n        throws Exception\n    {\n        File dir = new File( System.getProperty( \"basedir\" ), \"target/test/quotedpath'test\" );\n        createAndCallScript( dir, \"echo Quoted\" );\n\n        dir = new File( System.getProperty( \"basedir\" ), \"target/test/quoted path'test\" );\n        createAndCallScript( dir, \"echo Quoted\" );\n    }\n\n    /**\n     * Test an executable with a single quotation mark <code>\\\"</code> in its path only for non Windows box.\n     *\n     * @throws Exception\n     */\n    public void testQuotedPathWithQuotationMark()\n        throws Exception\n    {\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            System.out.println( \"testQuotedPathWithQuotationMark() skipped on Windows\" );\n            return;\n        }\n\n        File dir = new File( System.getProperty( \"basedir\" ), \"target/test/quotedpath\\\"test\" );\n        createAndCallScript( dir, \"echo Quoted\" );\n\n        dir = new File( System.getProperty( \"basedir\" ), \"target/test/quoted path\\\"test\" );\n        createAndCallScript( dir, \"echo Quoted\" );\n    }\n\n    /**\n     * Test an executable with a single quotation mark <code>\\\"</code> and <code>'</code> in its path only for non\n     * Windows box.\n     *\n     * @throws Exception\n     */\n    public void testQuotedPathWithQuotationMarkAndApostrophe()\n        throws Exception\n    {\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            System.out.println( \"testQuotedPathWithQuotationMarkAndApostrophe() skipped on Windows\" );\n            return;\n        }\n\n        File dir = new File( System.getProperty( \"basedir\" ), \"target/test/quotedpath\\\"'test\" );\n        createAndCallScript( dir, \"echo Quoted\" );\n\n        dir = new File( System.getProperty( \"basedir\" ), \"target/test/quoted path\\\"'test\" );\n        createAndCallScript( dir, \"echo Quoted\" );\n    }\n\n    /**\n     * Test an executable with a quote in its path and no space\n     *\n     * @throws Exception\n     */\n    public void testOnlyQuotedPath()\n        throws Exception\n    {\n        File dir = new File( System.getProperty( \"basedir\" ), \"target/test/quotedpath\\'test\" );\n\n        File javaHome = new File( System.getProperty( \"java.home\" ) );\n        File java;\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            java = new File( javaHome, \"/bin/java.exe\" );\n        }\n        else\n        {\n            java = new File( javaHome, \"/bin/java\" );\n        }\n\n        if ( !java.exists() )\n        {\n            throw new IOException( java.getAbsolutePath() + \" doesn't exist\" );\n        }\n\n        createAndCallScript( dir, java.getAbsolutePath() + \" -version\" );\n    }\n\n    public void testDollarSignInArgumentPath()\n        throws Exception\n    {\n        File dir = new File( System.getProperty( \"basedir\" ), \"target/test\" );\n        if ( !dir.exists() )\n        {\n            assertTrue( \"Can't create dir:\" + dir.getAbsolutePath(), dir.mkdirs() );\n        }\n\n        FileWriter writer = null;\n        try\n        {\n            writer = new FileWriter( new File( dir, \"test$1.txt\" ) );\n            IOUtil.copy( \"Success\", writer );\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n\n        Commandline cmd = new Commandline();\n        //cmd.getShell().setShellCommand( \"/bin/sh\" );\n        cmd.getShell().setQuotedArgumentsEnabled( true );\n        cmd.setExecutable( \"cat\" );\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            cmd.setExecutable( \"dir\" );\n        }\n        cmd.setWorkingDirectory( dir );\n        cmd.createArg().setLine( \"test$1.txt\" );\n\n        executeCommandLine( cmd );\n    }\n\n    public void testTimeOutException() throws Exception\n    {\n        File javaHome = new File( System.getProperty( \"java.home\" ) );\n        File java;\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            java = new File( javaHome, \"/bin/java.exe\" );\n        }\n        else\n        {\n            java = new File( javaHome, \"/bin/java\" );\n        }\n\n        if ( !java.exists() )\n        {\n            throw new IOException( java.getAbsolutePath() + \" doesn't exist\" );\n        }\n        \n        Commandline cli = new Commandline();\n        cli.setExecutable( java.getAbsolutePath() );\n        cli.createArg().setLine( \"-version\" );\n        CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n        try\n        {\n            // if the os is faster than 1s to execute java -version the unit will fail :-)\n            CommandLineUtils.executeCommandLine( cli, new DefaultConsumer(), err, 1 );\n        }\n        catch ( CommandLineTimeOutException e )\n        {\n            // it works\n        }\n        \n    }\n    \n    /**\n     * Make the file executable for Unix box.\n     *\n     * @param path not null\n     * @throws IOException if any\n     */\n    private static void makeExecutable( File path )\n        throws IOException\n    {\n        if ( path == null )\n        {\n            throw new IllegalArgumentException( \"The file is null\" );\n        }\n\n        if ( !path.isFile() )\n        {\n            throw new IllegalArgumentException( \"The file '\" + path.getAbsolutePath() + \"' should be a file\" );\n        }\n\n        if ( !Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            Process proc = Runtime.getRuntime().exec( new String[] { \"chmod\", \"a+x\", path.getAbsolutePath() } );\n            while ( true )\n            {\n                try\n                {\n                    proc.waitFor();\n                    break;\n                }\n                catch ( InterruptedException e )\n                {\n                    // ignore\n                }\n            }\n        }\n    }\n\n    /**\n     * Create and execute a script file in the given dir with the given content. The script file will be called\n     * <code>echo.bat</code> for Windows box, otherwise <code>echo</code>.\n     *\n     * @param dir the parent dir where echo.bat or echo will be created\n     * @param content the content of the script file\n     * @throws Exception if any\n     */\n    private static void createAndCallScript( File dir, String content )\n        throws Exception\n    {\n        if ( !dir.exists() )\n        {\n            assertTrue( \"Can't create dir:\" + dir.getAbsolutePath(), dir.mkdirs() );\n        }\n\n        // Create a script file\n        File bat;\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            bat = new File( dir, \"echo.bat\" );\n        }\n        else\n        {\n            bat = new File( dir, \"echo\" );\n        }\n\n        Writer w = new FileWriter( bat );\n        try\n        {\n            IOUtil.copy( content, w );\n        }\n        finally\n        {\n            IOUtil.close( w );\n        }\n\n        // Change permission\n        makeExecutable( bat );\n\n        Commandline cmd = new Commandline();\n        cmd.setExecutable( bat.getAbsolutePath() );\n        cmd.setWorkingDirectory( dir );\n\n        // Execute the script file\n        executeCommandLine( cmd );\n    }\n\n    /**\n     * Execute the command line\n     *\n     * @param cmd not null\n     * @throws Exception if any\n     */\n    private static void executeCommandLine( Commandline cmd )\n        throws Exception\n    {\n        CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n\n        try\n        {\n            System.out.println( \"Command line is: \" + StringUtils.join( cmd.getShellCommandline(), \" \" ) );\n\n            int exitCode = CommandLineUtils.executeCommandLine( cmd, new DefaultConsumer(), err );\n\n            if ( exitCode != 0 )\n            {\n                String msg = \"Exit code: \" + exitCode + \" - \" + err.getOutput();\n                throw new Exception( msg.toString() );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            throw new Exception( \"Unable to execute command: \" + e.getMessage(), e );\n        }\n    }\n}\n", "package org.codehaus.plexus.util.cli.shell;\n\n/*\n * Copyright The Codehaus Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport junit.framework.TestCase;\n\npublic class BourneShellTest\n    extends TestCase\n{\n\n    protected Shell newShell()\n    {\n        return new BourneShell();\n    }\n\n    public void testQuoteWorkingDirectoryAndExecutable()\n    {\n        Shell sh = newShell();\n\n        sh.setWorkingDirectory( \"/usr/local/bin\" );\n        sh.setExecutable( \"chmod\" );\n\n        String executable = StringUtils.join( sh.getShellCommandLine( new String[]{} ).iterator(), \" \" );\n\n        assertEquals( \"/bin/sh -c cd /usr/local/bin && chmod\", executable );\n    }\n\n    public void testQuoteWorkingDirectoryAndExecutable_WDPathWithSingleQuotes()\n    {\n        Shell sh = newShell();\n\n        sh.setWorkingDirectory( \"/usr/local/'something else'\" );\n        sh.setExecutable( \"chmod\" );\n\n        String executable = StringUtils.join( sh.getShellCommandLine( new String[]{} ).iterator(), \" \" );\n\n        assertEquals( \"/bin/sh -c cd \\\"/usr/local/\\'something else\\'\\\" && chmod\", executable );\n    }\n\n    public void testQuoteWorkingDirectoryAndExecutable_WDPathWithSingleQuotes_BackslashFileSep()\n    {\n        Shell sh = newShell();\n\n        sh.setWorkingDirectory( \"\\\\usr\\\\local\\\\'something else'\" );\n        sh.setExecutable( \"chmod\" );\n\n        String executable = StringUtils.join( sh.getShellCommandLine( new String[]{} ).iterator(), \" \" );\n\n        assertEquals( \"/bin/sh -c cd \\\"\\\\usr\\\\local\\\\\\'something else\\'\\\" && chmod\", executable );\n    }\n\n    public void testPreserveSingleQuotesOnArgument()\n    {\n        Shell sh = newShell();\n\n        sh.setWorkingDirectory( \"/usr/bin\" );\n        sh.setExecutable( \"chmod\" );\n\n        String[] args = { \"\\'some arg with spaces\\'\" };\n\n        List shellCommandLine = sh.getShellCommandLine( args );\n\n        String cli = StringUtils.join( shellCommandLine.iterator(), \" \" );\n        System.out.println( cli );\n        assertTrue( cli.endsWith( args[0] ) );\n    }\n\n    public void testAddSingleQuotesOnArgumentWithSpaces()\n    {\n        Shell sh = newShell();\n\n        sh.setWorkingDirectory( \"/usr/bin\" );\n        sh.setExecutable( \"chmod\" );\n\n        String[] args = { \"some arg with spaces\" };\n\n        List shellCommandLine = sh.getShellCommandLine( args );\n\n        String cli = StringUtils.join( shellCommandLine.iterator(), \" \" );\n        System.out.println( cli );\n        assertTrue( cli.endsWith( \"\\'\" + args[0] + \"\\'\" ) );\n    }\n\n    public void testEscapeSingleQuotesOnArgument()\n    {\n        Shell sh = newShell();\n\n        sh.setWorkingDirectory( \"/usr/bin\" );\n        sh.setExecutable( \"chmod\" );\n\n        String[] args = { \"arg'withquote\" };\n\n        List shellCommandLine = sh.getShellCommandLine( args );\n\n        String cli = StringUtils.join( shellCommandLine.iterator(), \" \" );\n        System.out.println( cli );\n        assertEquals(\"cd /usr/bin && chmod 'arg'\\\\''withquote'\", shellCommandLine.get(shellCommandLine.size() - 1));\n    }\n\n    public void testArgumentsWithsemicolon()\n    {\n\n        System.out.println( \"---- semi colon tests ----\" );\n\n        Shell sh = newShell();\n\n        sh.setWorkingDirectory( \"/usr/bin\" );\n        sh.setExecutable( \"chmod\" );\n\n        String[] args = { \";some&argwithunix$chars\" };\n\n        List shellCommandLine = sh.getShellCommandLine( args );\n\n        String cli = StringUtils.join( shellCommandLine.iterator(), \" \" );\n        System.out.println( cli );\n        assertTrue( cli.endsWith( \"\\'\" + args[0] + \"\\'\" ) );\n\n        Commandline commandline = new Commandline( newShell() );\n        commandline.setExecutable( \"chmod\" );\n        commandline.getShell().setQuotedArgumentsEnabled( true );\n        commandline.createArg().setValue( \"--password\" );\n        commandline.createArg().setValue( \";password\" );\n\n        String[] lines = commandline.getShellCommandline();\n        System.out.println( Arrays.asList( lines ) );\n\n        assertEquals( \"/bin/sh\", lines[0] );\n        assertEquals( \"-c\", lines[1] );\n        assertEquals( \"chmod --password ';password'\", lines[2] );\n\n        commandline = new Commandline( newShell() );\n        commandline.setExecutable( \"chmod\" );\n        commandline.getShell().setQuotedArgumentsEnabled( true );\n        commandline.createArg().setValue( \"--password\" );\n        commandline.createArg().setValue( \";password\" );\n        lines = commandline.getShellCommandline();\n        System.out.println( Arrays.asList( lines ) );\n\n        assertEquals( \"/bin/sh\", lines[0] );\n        assertEquals( \"-c\", lines[1] );\n        assertEquals( \"chmod --password ';password'\", lines[2] );\n\n        commandline = new Commandline( new CmdShell() );\n        commandline.getShell().setQuotedArgumentsEnabled( true );\n        commandline.createArg().setValue( \"--password\" );\n        commandline.createArg().setValue( \";password\" );\n        lines = commandline.getShellCommandline();\n        System.out.println( Arrays.asList( lines ) );\n\n        assertEquals( \"cmd.exe\", lines[0] );\n        assertEquals( \"/X\", lines[1] );\n        assertEquals( \"/C\", lines[2] );\n        assertEquals( \"\\\"--password ;password\\\"\", lines[3] );\n    }\n\n    public void testBourneShellQuotingCharacters()\n        throws Exception\n    {\n        // { ' ', '$', ';', '&', '|', '<', '>', '*', '?', '(', ')' };\n        // test with values http://steve-parker.org/sh/bourne.shtml Appendix B - Meta-characters and Reserved Words\n        Commandline commandline = new Commandline( newShell() );\n        commandline.setExecutable( \"chmod\" );\n        commandline.getShell().setQuotedArgumentsEnabled( true );\n        commandline.createArg().setValue( \" \" );\n        commandline.createArg().setValue( \"|\" );\n        commandline.createArg().setValue( \"&&\" );\n        commandline.createArg().setValue( \"||\" );\n        commandline.createArg().setValue( \";\" );\n        commandline.createArg().setValue( \";;\" );\n        commandline.createArg().setValue( \"&\" );\n        commandline.createArg().setValue( \"()\" );\n        commandline.createArg().setValue( \"<\" );\n        commandline.createArg().setValue( \"<<\" );\n        commandline.createArg().setValue( \">\" );\n        commandline.createArg().setValue( \">>\" );\n        commandline.createArg().setValue( \"*\" );\n        commandline.createArg().setValue( \"?\" );\n        commandline.createArg().setValue( \"[\" );\n        commandline.createArg().setValue( \"]\" );\n        commandline.createArg().setValue( \"{\" );\n        commandline.createArg().setValue( \"}\" );\n        commandline.createArg().setValue( \"`\" );\n\n        String[] lines = commandline.getShellCommandline();\n        System.out.println( Arrays.asList( lines ) );\n\n        assertEquals( \"/bin/sh\", lines[0] );\n        assertEquals( \"-c\", lines[1] );\n        assertEquals( \"chmod ' ' '|' '&&' '||' ';' ';;' '&' '()' '<' '<<' '>' '>>' '*' '?' '[' ']' '{' '}' '`'\",\n                      lines[2] );\n\n    }\n\n}\n"], "fixing_code": ["package org.codehaus.plexus.util.cli;\n\n/*\n * Copyright The Codehaus Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/***************************************************************************************************\n * CruiseControl, a Continuous Integration Toolkit Copyright (c) 2001-2003, ThoughtWorks, Inc. 651 W\n * Washington Ave. Suite 500 Chicago, IL 60661 USA All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted\n * provided that the following conditions are met: + Redistributions of source code must retain the\n * above copyright notice, this list of conditions and the following disclaimer. + Redistributions\n * in binary form must reproduce the above copyright notice, this list of conditions and the\n * following disclaimer in the documentation and/or other materials provided with the distribution. +\n * Neither the name of ThoughtWorks, Inc., CruiseControl, nor the names of its contributors may be\n * used to endorse or promote products derived from this software without specific prior written\n * permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n **************************************************************************************************/\n\n/*\n * ====================================================================\n * Copyright 2003-2004 The Apache Software Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ====================================================================\n */\n\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.shell.BourneShell;\nimport org.codehaus.plexus.util.cli.shell.CmdShell;\nimport org.codehaus.plexus.util.cli.shell.CommandShell;\nimport org.codehaus.plexus.util.cli.shell.Shell;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Vector;\n\n/**\n * <p/>\n * Commandline objects help handling command lines specifying processes to\n * execute.\n * </p>\n * <p/>\n * The class can be used to define a command line as nested elements or as a\n * helper to define a command line by an application.\n * </p>\n * <p/>\n * <code>\n * &lt;someelement&gt;<br>\n * &nbsp;&nbsp;&lt;acommandline executable=\"/executable/to/run\"&gt;<br>\n * &nbsp;&nbsp;&nbsp;&nbsp;&lt;argument value=\"argument 1\" /&gt;<br>\n * &nbsp;&nbsp;&nbsp;&nbsp;&lt;argument line=\"argument_1 argument_2 argument_3\" /&gt;<br>\n * &nbsp;&nbsp;&nbsp;&nbsp;&lt;argument value=\"argument 4\" /&gt;<br>\n * &nbsp;&nbsp;&lt;/acommandline&gt;<br>\n * &lt;/someelement&gt;<br>\n * </code>\n * </p>\n * <p/>\n * The element <code>someelement</code> must provide a method\n * <code>createAcommandline</code> which returns an instance of this class.\n * </p>\n *\n * @author thomas.haas@softwired-inc.com\n * @author <a href=\"mailto:stefan.bodewig@epost.de\">Stefan Bodewig</a>\n */\npublic class Commandline\n    implements Cloneable\n{\n    /**\n     * @deprecated Use {@link org.codehaus.plexus.util.Os} class instead.\n     */\n    protected static final String OS_NAME = \"os.name\";\n\n    /**\n     * @deprecated Use {@link org.codehaus.plexus.util.Os} class instead.\n     */\n    protected static final String WINDOWS = \"Windows\";\n\n    protected Vector arguments = new Vector();\n\n    //protected Vector envVars = new Vector();\n    // synchronized added to preserve synchronize of Vector class\n    protected Map envVars = Collections.synchronizedMap( new LinkedHashMap() );\n\n    private long pid = -1;\n\n    private Shell shell;\n\n    /**\n     * @deprecated Use {@link Commandline#setExecutable(String)} instead.\n     */\n    protected String executable;\n\n    /**\n     * @deprecated Use {@link Commandline#setWorkingDirectory(File)} or\n     * {@link Commandline#setWorkingDirectory(String)} instead.\n     */\n    private File workingDir;\n\n    /**\n     * Create a new command line object.\n     * Shell is autodetected from operating system\n     *\n     * Shell usage is only desirable when generating code for remote execution.\n     *\n     * @param toProcess\n     */\n    public Commandline( String toProcess, Shell shell )\n    {\n        this.shell = shell;\n\n        String[] tmp = new String[0];\n        try\n        {\n            tmp = CommandLineUtils.translateCommandline( toProcess );\n        }\n        catch ( Exception e )\n        {\n            System.err.println( \"Error translating Commandline.\" );\n        }\n        if ( ( tmp != null ) && ( tmp.length > 0 ) )\n        {\n            setExecutable( tmp[0] );\n            for ( int i = 1; i < tmp.length; i++ )\n            {\n                createArgument().setValue( tmp[i] );\n            }\n        }\n    }\n\n    /**\n     * Create a new command line object.\n     * Shell is autodetected from operating system\n     *\n     * Shell usage is only desirable when generating code for remote execution.\n     */\n    public Commandline( Shell shell )\n    {\n        this.shell = shell;\n    }\n\n    /**\n     * Create a new command line object, given a command following POSIX sh quoting rules\n     *\n     * @param toProcess\n     */\n    public Commandline( String toProcess )\n    {\n        setDefaultShell();\n        String[] tmp = new String[0];\n        try\n        {\n            tmp = CommandLineUtils.translateCommandline( toProcess );\n        }\n        catch ( Exception e )\n        {\n            System.err.println( \"Error translating Commandline.\" );\n        }\n        if ( ( tmp != null ) && ( tmp.length > 0 ) )\n        {\n            setExecutable( tmp[0] );\n            for ( int i = 1; i < tmp.length; i++ )\n            {\n                createArgument().setValue( tmp[i] );\n            }\n        }\n    }\n\n    /**\n     * Create a new command line object.\n     */\n    public Commandline()\n    {\n        setDefaultShell();\n    }\n\n    public long getPid()\n    {\n        if ( pid == -1 )\n        {\n            pid = Long.parseLong( String.valueOf( System.currentTimeMillis() ) );\n        }\n\n        return pid;\n    }\n\n    public void setPid( long pid )\n    {\n        this.pid = pid;\n    }\n\n    /**\n     * Class to keep track of the position of an Argument.\n     */\n    // <p>This class is there to support the srcfile and targetfile\n    // elements of &lt;execon&gt; and &lt;transform&gt; - don't know\n    // whether there might be additional use cases.</p> --SB\n    public class Marker\n    {\n\n        private int position;\n\n        private int realPos = -1;\n\n        Marker( int position )\n        {\n            this.position = position;\n        }\n\n        /**\n         * Return the number of arguments that preceeded this marker.\n         * <p/>\n         * <p>The name of the executable - if set - is counted as the\n         * very first argument.</p>\n         */\n        public int getPosition()\n        {\n            if ( realPos == -1 )\n            {\n                realPos = ( getLiteralExecutable() == null ? 0 : 1 );\n                for ( int i = 0; i < position; i++ )\n                {\n                    Arg arg = (Arg) arguments.elementAt( i );\n                    realPos += arg.getParts().length;\n                }\n            }\n            return realPos;\n        }\n    }\n\n    /**\n     * <p>Sets the shell or command-line interpretor for the detected operating system,\n     * and the shell arguments.</p>\n     */\n    private void setDefaultShell()\n    {\n        //If this is windows set the shell to command.com or cmd.exe with correct arguments.\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            if ( Os.isFamily( Os.FAMILY_WIN9X ) )\n            {\n                setShell( new CommandShell() );\n            }\n            else\n            {\n                setShell( new CmdShell() );\n            }\n        }\n        else\n        {\n            setShell( new BourneShell() );\n        }\n    }\n\n    /**\n     * Creates an argument object.\n     * <p/>\n     * <p>Each commandline object has at most one instance of the\n     * argument class.  This method calls\n     * <code>this.createArgument(false)</code>.</p>\n     *\n     * @return the argument object.\n     * @see #createArgument(boolean)\n     * @deprecated Use {@link Commandline#createArg()} instead\n     */\n    public Argument createArgument()\n    {\n        return this.createArgument( false );\n    }\n\n    /**\n     * Creates an argument object and adds it to our list of args.\n     * <p/>\n     * <p>Each commandline object has at most one instance of the\n     * argument class.</p>\n     *\n     * @param insertAtStart if true, the argument is inserted at the\n     *                      beginning of the list of args, otherwise it is appended.\n     * @deprecated Use {@link Commandline#createArg(boolean)} instead\n     */\n    public Argument createArgument( boolean insertAtStart )\n    {\n        Argument argument = new Argument();\n        if ( insertAtStart )\n        {\n            arguments.insertElementAt( argument, 0 );\n        }\n        else\n        {\n            arguments.addElement( argument );\n        }\n        return argument;\n    }\n\n    /**\n     * Creates an argument object.\n     * <p/>\n     * <p>Each commandline object has at most one instance of the\n     * argument class.  This method calls\n     * <code>this.createArgument(false)</code>.</p>\n     *\n     * @return the argument object.\n     * @see #createArgument(boolean)\n     */\n    public Arg createArg()\n    {\n        return this.createArg( false );\n    }\n\n    /**\n     * Creates an argument object and adds it to our list of args.\n     * <p/>\n     * <p>Each commandline object has at most one instance of the\n     * argument class.</p>\n     *\n     * @param insertAtStart if true, the argument is inserted at the\n     *                      beginning of the list of args, otherwise it is appended.\n     */\n    public Arg createArg( boolean insertAtStart )\n    {\n        Arg argument = new Argument();\n        if ( insertAtStart )\n        {\n            arguments.insertElementAt( argument, 0 );\n        }\n        else\n        {\n            arguments.addElement( argument );\n        }\n        return argument;\n    }\n\n    /**\n     * Adds an argument object to our list of args.\n     *\n     * @return the argument object.\n     * @see #addArg(Arg,boolean)\n     */\n    public void addArg( Arg argument )\n    {\n        this.addArg( argument, false );\n    }\n\n    /**\n     * Adds an argument object to our list of args.\n     *\n     * @param insertAtStart if true, the argument is inserted at the\n     *                      beginning of the list of args, otherwise it is appended.\n     */\n    public void addArg( Arg argument, boolean insertAtStart )\n    {\n        if ( insertAtStart )\n        {\n            arguments.insertElementAt( argument, 0 );\n        }\n        else\n        {\n            arguments.addElement( argument );\n        }\n    }\n\n    /**\n     * Sets the executable to run.\n     */\n    public void setExecutable( String executable )\n    {\n        shell.setExecutable( executable );\n        this.executable = executable;\n    }\n\n    /**\n     * @return Executable to be run, as a literal string (no shell quoting/munging)\n     */\n    public String getLiteralExecutable()\n    {\n        return executable;\n    }\n\n    /**\n     * Return an executable name, quoted for shell use.\n     *\n     * Shell usage is only desirable when generating code for remote execution.\n     *\n     * @return Executable to be run, quoted for shell interpretation\n     */\n    public String getExecutable()\n    {\n        String exec = shell.getExecutable();\n\n        if ( exec == null )\n        {\n            exec = executable;\n        }\n\n        return exec;\n    }\n\n    public void addArguments( String[] line )\n    {\n        for ( int i = 0; i < line.length; i++ )\n        {\n            createArgument().setValue( line[i] );\n        }\n    }\n\n    /**\n     * Add an environment variable\n     */\n    public void addEnvironment( String name, String value )\n    {\n        //envVars.add( name + \"=\" + value );\n        envVars.put( name, value );\n    }\n\n    /**\n     * Add system environment variables\n     */\n    public void addSystemEnvironment()\n        throws Exception\n    {\n        Properties systemEnvVars = CommandLineUtils.getSystemEnvVars();\n\n        for ( Iterator i = systemEnvVars.keySet().iterator(); i.hasNext(); )\n        {\n            String key = (String) i.next();\n            if ( !envVars.containsKey( key ) )\n            {\n                addEnvironment( key, systemEnvVars.getProperty( key ) );\n            }\n        }\n    }\n\n    /**\n     * Return the list of environment variables\n     */\n    public String[] getEnvironmentVariables()\n        throws CommandLineException\n    {\n        try\n        {\n            addSystemEnvironment();\n        }\n        catch ( Exception e )\n        {\n            throw new CommandLineException( \"Error setting up environmental variables\", e );\n        }\n        String[] environmentVars = new String[envVars.size()];\n        int i = 0;\n        for ( Iterator iterator = envVars.keySet().iterator(); iterator.hasNext(); )\n        {\n            String name = (String) iterator.next();\n            String value = (String) envVars.get( name );\n            environmentVars[i] = name + \"=\" + value;\n            i++;\n        }\n        return environmentVars;\n    }\n\n    /**\n     * Returns the executable and all defined arguments.\n     */\n    public String[] getCommandline()\n    {\n        final String[] args = getArguments();\n        String executable = getLiteralExecutable();\n\n        if ( executable == null )\n        {\n            return args;\n        }\n        final String[] result = new String[args.length + 1];\n        result[0] = executable;\n        System.arraycopy( args, 0, result, 1, args.length );\n        return result;\n    }\n\n    /**\n     * Returns the shell, executable and all defined arguments.\n     *\n     * Shell usage is only desirable when generating code for remote execution.\n     */\n    public String[] getShellCommandline()\n    {\n        // TODO: Provided only for backward compat. with <= 1.4\n        verifyShellState();\n\n        return (String[]) getShell().getShellCommandLine( getArguments() ).toArray( new String[0] );\n    }\n\n    /**\n     * Returns all arguments defined by <code>addLine</code>,\n     * <code>addValue</code> or the argument object.\n     */\n    public String[] getArguments()\n    {\n        Vector result = new Vector( arguments.size() * 2 );\n        for ( int i = 0; i < arguments.size(); i++ )\n        {\n            Argument arg = (Argument) arguments.elementAt( i );\n            String[] s = arg.getParts();\n            if ( s != null )\n            {\n                for ( int j = 0; j < s.length; j++ )\n                {\n                    result.addElement( s[j] );\n                }\n            }\n        }\n\n        String[] res = new String[result.size()];\n        result.copyInto( res );\n        return res;\n    }\n\n    public String toString()\n    {\n        return StringUtils.join( getShellCommandline(), \" \" );\n    }\n\n    public int size()\n    {\n        return getCommandline().length;\n    }\n\n    public Object clone()\n    {\n        Commandline c = new Commandline( (Shell) shell.clone() );\n        c.executable = executable;\n        c.workingDir = workingDir;\n        c.addArguments( getArguments() );\n        return c;\n    }\n\n    /**\n     * Clear out the whole command line.\n     */\n    public void clear()\n    {\n        executable = null;\n        workingDir = null;\n        shell.setExecutable( null );\n        shell.clearArguments();\n        arguments.removeAllElements();\n    }\n\n    /**\n     * Clear out the arguments but leave the executable in place for another operation.\n     */\n    public void clearArgs()\n    {\n        arguments.removeAllElements();\n    }\n\n    /**\n     * Return a marker.\n     * <p/>\n     * <p>This marker can be used to locate a position on the\n     * commandline - to insert something for example - when all\n     * parameters have been set.</p>\n     */\n    public Marker createMarker()\n    {\n        return new Marker( arguments.size() );\n    }\n\n    /**\n     * Sets execution directory.\n     */\n    public void setWorkingDirectory( String path )\n    {\n        shell.setWorkingDirectory( path );\n        workingDir = new File( path );\n    }\n\n    /**\n     * Sets execution directory.\n     */\n    public void setWorkingDirectory( File workingDirectory )\n    {\n        shell.setWorkingDirectory( workingDirectory );\n        workingDir = workingDirectory;\n    }\n\n    public File getWorkingDirectory()\n    {\n        File workDir = shell.getWorkingDirectory();\n\n        if ( workDir == null )\n        {\n            workDir = workingDir;\n        }\n\n        return workDir;\n    }\n\n    /**\n     * Executes the command.\n     */\n    public Process execute()\n        throws CommandLineException\n    {\n        // TODO: Provided only for backward compat. with <= 1.4\n        verifyShellState();\n\n        Process process;\n\n        //addEnvironment( \"MAVEN_TEST_ENVAR\", \"MAVEN_TEST_ENVAR_VALUE\" );\n\n        String[] environment = getEnvironmentVariables();\n\n        File workingDir = shell.getWorkingDirectory();\n\n        try\n        {\n            if ( workingDir == null )\n            {\n                process = Runtime.getRuntime().exec( getCommandline(), environment, workingDir );\n            }\n            else\n            {\n                if ( !workingDir.exists() )\n                {\n                    throw new CommandLineException( \"Working directory \\\"\" + workingDir.getPath()\n                        + \"\\\" does not exist!\" );\n                }\n                else if ( !workingDir.isDirectory() )\n                {\n                    throw new CommandLineException( \"Path \\\"\" + workingDir.getPath()\n                        + \"\\\" does not specify a directory.\" );\n                }\n\n                process = Runtime.getRuntime().exec( getCommandline(), environment, workingDir );\n            }\n        }\n        catch ( IOException ex )\n        {\n            throw new CommandLineException( \"Error while executing process.\", ex );\n        }\n\n        return process;\n    }\n\n    /**\n     * @deprecated Remove once backward compat with plexus-utils <= 1.4 is no longer a consideration\n     */\n    private void verifyShellState()\n    {\n        if ( shell.getWorkingDirectory() == null )\n        {\n            shell.setWorkingDirectory( workingDir );\n        }\n\n        if ( shell.getOriginalExecutable() == null )\n        {\n            shell.setExecutable( executable );\n        }\n    }\n\n    public Properties getSystemEnvVars()\n        throws Exception\n    {\n        return CommandLineUtils.getSystemEnvVars();\n    }\n\n    /**\n     * Allows to set the shell to be used in this command line.\n     *\n     * Shell usage is only desirable when generating code for remote execution.\n     *\n     * @param shell\n     * @since 1.2\n     */\n    public void setShell( Shell shell )\n    {\n        this.shell = shell;\n    }\n\n    /**\n     * Get the shell to be used in this command line.\n     *\n     * Shell usage is only desirable when generating code for remote execution.\n     * @since 1.2\n     */\n    public Shell getShell()\n    {\n        return shell;\n    }\n\n    /**\n     * @deprecated Use {@link CommandLineUtils#translateCommandline(String)} instead.\n     */\n    public static String[] translateCommandline( String toProcess )\n        throws Exception\n    {\n        return CommandLineUtils.translateCommandline( toProcess );\n    }\n\n    /**\n     * @deprecated Use {@link CommandLineUtils#quote(String)} instead.\n     */\n    public static String quoteArgument( String argument )\n        throws CommandLineException\n    {\n        return CommandLineUtils.quote( argument );\n    }\n\n    /**\n     * @deprecated Use {@link CommandLineUtils#toString(String[])} instead.\n     */\n    public static String toString( String[] line )\n    {\n        return CommandLineUtils.toString( line );\n    }\n\n    public static class Argument\n        implements Arg\n    {\n        private String[] parts;\n\n        /* (non-Javadoc)\n         * @see org.codehaus.plexus.util.cli.Argumnt#setValue(java.lang.String)\n         */\n        public void setValue( String value )\n        {\n            if ( value != null )\n            {\n                parts = new String[] { value };\n            }\n        }\n\n        /* (non-Javadoc)\n         * @see org.codehaus.plexus.util.cli.Argumnt#setLine(java.lang.String)\n         */\n        public void setLine( String line )\n        {\n            if ( line == null )\n            {\n                return;\n            }\n            try\n            {\n                parts = CommandLineUtils.translateCommandline( line );\n            }\n            catch ( Exception e )\n            {\n                System.err.println( \"Error translating Commandline.\" );\n            }\n        }\n\n        /* (non-Javadoc)\n         * @see org.codehaus.plexus.util.cli.Argumnt#setFile(java.io.File)\n         */\n        public void setFile( File value )\n        {\n            parts = new String[] { value.getAbsolutePath() };\n        }\n\n        /* (non-Javadoc)\n         * @see org.codehaus.plexus.util.cli.Argumnt#getParts()\n         */\n        public String[] getParts()\n        {\n            return parts;\n        }\n    }\n}\n", "package org.codehaus.plexus.util.cli.shell;\n\n/*\n * Copyright The Codehaus Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.codehaus.plexus.util.Os;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @author Jason van Zyl\n * @version $Id$\n */\npublic class BourneShell\n    extends Shell\n{\n\n    public BourneShell()\n    {\n        this(false);\n    }\n\n    public BourneShell( boolean isLoginShell )\n    {\n        setUnconditionalQuoting( true );\n        setShellCommand( \"/bin/sh\" );\n        setArgumentQuoteDelimiter( '\\'' );\n        setExecutableQuoteDelimiter( '\\'' );\n        setSingleQuotedArgumentEscaped( true );\n        setSingleQuotedExecutableEscaped( false );\n        setQuotedExecutableEnabled( true );\n        setArgumentEscapePattern(\"'\\\\%s'\");\n\n        if ( isLoginShell )\n        {\n            addShellArg( \"-l\" );\n        }\n    }\n\n    /** {@inheritDoc} */\n    public String getExecutable()\n    {\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            return super.getExecutable();\n        }\n\n        return quoteOneItem( super.getOriginalExecutable(), true );\n    }\n\n    public List<String> getShellArgsList()\n    {\n        List<String> shellArgs = new ArrayList<String>();\n        List<String> existingShellArgs = super.getShellArgsList();\n\n        if ( ( existingShellArgs != null ) && !existingShellArgs.isEmpty() )\n        {\n            shellArgs.addAll( existingShellArgs );\n        }\n\n        shellArgs.add( \"-c\" );\n\n        return shellArgs;\n    }\n\n    public String[] getShellArgs()\n    {\n        String[] shellArgs = super.getShellArgs();\n        if ( shellArgs == null )\n        {\n            shellArgs = new String[0];\n        }\n\n        if ( ( shellArgs.length > 0 ) && !shellArgs[shellArgs.length - 1].equals( \"-c\" ) )\n        {\n            String[] newArgs = new String[shellArgs.length + 1];\n\n            System.arraycopy( shellArgs, 0, newArgs, 0, shellArgs.length );\n            newArgs[shellArgs.length] = \"-c\";\n\n            shellArgs = newArgs;\n        }\n\n        return shellArgs;\n    }\n\n    protected String getExecutionPreamble()\n    {\n        if ( getWorkingDirectoryAsString() == null )\n        {\n            return null;\n        }\n\n        String dir = getWorkingDirectoryAsString();\n        StringBuilder sb = new StringBuilder();\n        sb.append( \"cd \" );\n\n        sb.append( quoteOneItem( dir, false ) );\n        sb.append( \" && \" );\n\n        return sb.toString();\n    }\n\n    /**\n     * <p>Unify quotes in a path for the Bourne Shell.</p>\n     *\n     * <pre>\n     * BourneShell.quoteOneItem(null)                       = null\n     * BourneShell.quoteOneItem(\"\")                         = ''\n     * BourneShell.quoteOneItem(\"/test/quotedpath'abc\")     = '/test/quotedpath'\"'\"'abc'\n     * BourneShell.quoteOneItem(\"/test/quoted path'abc\")    = '/test/quoted pat'\"'\"'habc'\n     * BourneShell.quoteOneItem(\"/test/quotedpath\\\"abc\")    = '/test/quotedpath\"abc'\n     * BourneShell.quoteOneItem(\"/test/quoted path\\\"abc\")   = '/test/quoted path\"abc'\n     * BourneShell.quoteOneItem(\"/test/quotedpath\\\"'abc\")   = '/test/quotedpath\"'\"'\"'abc'\n     * BourneShell.quoteOneItem(\"/test/quoted path\\\"'abc\")  = '/test/quoted path\"'\"'\"'abc'\n     * </pre>\n     *\n     * @param path not null path.\n     * @return the path unified correctly for the Bourne shell.\n     */\n    protected String quoteOneItem( String path, boolean isExecutable )\n    {\n        if ( path == null )\n        {\n            return null;\n        }\n\n        StringBuilder sb = new StringBuilder();\n        sb.append( \"'\" );\n        sb.append( path.replace( \"'\", \"'\\\"'\\\"'\" ) );\n        sb.append( \"'\" );\n\n        return sb.toString();\n    }\n}\n", "package org.codehaus.plexus.util.cli.shell;\n\n/*\n * Copyright The Codehaus Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * <p>\n * Class that abstracts the Shell functionality,\n * with subclases for shells that behave particularly, like\n * <ul>\n * <li><code>command.com</code></li>\n * <li><code>cmd.exe</code></li>\n * </ul>\n * </p>\n *\n * @author <a href=\"mailto:carlos@apache.org\">Carlos Sanchez</a>\n * @since 1.2\n * @version $Id$\n */\npublic class Shell\n    implements Cloneable\n{\n    private static final char[] DEFAULT_QUOTING_TRIGGER_CHARS = { ' ' };\n\n    private String shellCommand;\n\n    private List<String> shellArgs = new ArrayList<String>();\n\n    private boolean quotedArgumentsEnabled = true;\n\n    private boolean unconditionallyQuote = false;\n\n    private String executable;\n\n    private String workingDir;\n\n    private boolean quotedExecutableEnabled = true;\n\n    private boolean doubleQuotedArgumentEscaped = false;\n\n    private boolean singleQuotedArgumentEscaped = false;\n\n    private boolean doubleQuotedExecutableEscaped = false;\n\n    private boolean singleQuotedExecutableEscaped = false;\n\n    private char argQuoteDelimiter = '\\\"';\n\n    private char exeQuoteDelimiter = '\\\"';\n\n    private String argumentEscapePattern = \"\\\\%s\";\n\n    /**\n     * Toggle unconditional quoting\n     *\n     * @param unconditionallyQuote\n     */\n    public void setUnconditionalQuoting(boolean unconditionallyQuote)\n    {\n        this.unconditionallyQuote = unconditionallyQuote;\n    }\n\n    /**\n     * Set the command to execute the shell (eg. COMMAND.COM, /bin/bash,...)\n     *\n     * @param shellCommand\n     */\n    public void setShellCommand( String shellCommand )\n    {\n        this.shellCommand = shellCommand;\n    }\n\n    /**\n     * Get the command to execute the shell\n     *\n     * @return\n     */\n    public String getShellCommand()\n    {\n        return shellCommand;\n    }\n\n    /**\n     * Set the shell arguments when calling a command line (not the executable arguments)\n     * (eg. /X /C for CMD.EXE)\n     *\n     * @param shellArgs\n     */\n    public void setShellArgs( String[] shellArgs )\n    {\n        this.shellArgs.clear();\n        this.shellArgs.addAll( Arrays.asList( shellArgs ) );\n    }\n\n    /**\n     * Get the shell arguments\n     *\n     * @return\n     */\n    public String[] getShellArgs()\n    {\n        if ( ( shellArgs == null ) || shellArgs.isEmpty() )\n        {\n            return null;\n        }\n        else\n        {\n            return (String[]) shellArgs.toArray( new String[shellArgs.size()] );\n        }\n    }\n\n    /**\n     * Get the command line for the provided executable and arguments in this shell\n     *\n     * @param executable executable that the shell has to call\n     * @param arguments  arguments for the executable, not the shell\n     * @return List with one String object with executable and arguments quoted as needed\n     */\n    public List<String> getCommandLine( String executable, String[] arguments )\n    {\n        return getRawCommandLine( executable, arguments );\n    }\n\n    protected String quoteOneItem(String inputString, boolean isExecutable)\n    {\n        char[] escapeChars = getEscapeChars( isSingleQuotedExecutableEscaped(), isDoubleQuotedExecutableEscaped() );\n        return StringUtils.quoteAndEscape(\n            inputString,\n            isExecutable ? getExecutableQuoteDelimiter() : getArgumentQuoteDelimiter(),\n            escapeChars,\n            getQuotingTriggerChars(),\n            '\\\\',\n            unconditionallyQuote\n        );\n    }\n\n    protected List<String> getRawCommandLine( String executable, String[] arguments )\n    {\n        List<String> commandLine = new ArrayList<String>();\n        StringBuilder sb = new StringBuilder();\n\n        if ( executable != null )\n        {\n            String preamble = getExecutionPreamble();\n            if ( preamble != null )\n            {\n                sb.append( preamble );\n            }\n\n            if ( isQuotedExecutableEnabled() )\n            {\n                sb.append( quoteOneItem( getOriginalExecutable(), true ) );\n            }\n            else\n            {\n                sb.append( getExecutable() );\n            }\n        }\n        for ( int i = 0; i < arguments.length; i++ )\n        {\n            if ( sb.length() > 0 )\n            {\n                sb.append( \" \" );\n            }\n\n            if ( isQuotedArgumentsEnabled() )\n            {\n                sb.append( quoteOneItem( arguments[i], false ) );\n            }\n            else\n            {\n                sb.append( arguments[i] );\n            }\n        }\n\n        commandLine.add( sb.toString() );\n\n        return commandLine;\n    }\n\n    protected char[] getQuotingTriggerChars()\n    {\n        return DEFAULT_QUOTING_TRIGGER_CHARS;\n    }\n\n    protected String getExecutionPreamble()\n    {\n        return null;\n    }\n\n    protected char[] getEscapeChars( boolean includeSingleQuote, boolean includeDoubleQuote )\n    {\n        StringBuilder buf = new StringBuilder( 2 );\n        if ( includeSingleQuote )\n        {\n            buf.append( '\\'' );\n        }\n\n        if ( includeDoubleQuote )\n        {\n            buf.append( '\\\"' );\n        }\n\n        char[] result = new char[buf.length()];\n        buf.getChars( 0, buf.length(), result, 0 );\n\n        return result;\n    }\n\n    protected boolean isDoubleQuotedArgumentEscaped()\n    {\n        return doubleQuotedArgumentEscaped;\n    }\n\n    protected boolean isSingleQuotedArgumentEscaped()\n    {\n        return singleQuotedArgumentEscaped;\n    }\n\n    protected boolean isDoubleQuotedExecutableEscaped()\n    {\n        return doubleQuotedExecutableEscaped;\n    }\n\n    protected boolean isSingleQuotedExecutableEscaped()\n    {\n        return singleQuotedExecutableEscaped;\n    }\n\n    protected void setArgumentQuoteDelimiter( char argQuoteDelimiter )\n    {\n        this.argQuoteDelimiter = argQuoteDelimiter;\n    }\n\n    protected char getArgumentQuoteDelimiter()\n    {\n        return argQuoteDelimiter;\n    }\n\n    protected void setExecutableQuoteDelimiter( char exeQuoteDelimiter )\n    {\n        this.exeQuoteDelimiter = exeQuoteDelimiter;\n    }\n\n    protected char getExecutableQuoteDelimiter()\n    {\n        return exeQuoteDelimiter;\n    }\n\n    protected void setArgumentEscapePattern(String argumentEscapePattern)\n    {\n        this.argumentEscapePattern = argumentEscapePattern;\n    }\n\n    protected String getArgumentEscapePattern() {\n        return argumentEscapePattern;\n    }\n\n    /**\n     * Get the full command line to execute, including shell command, shell arguments,\n     * executable and executable arguments\n     *\n     * @param arguments  arguments for the executable, not the shell\n     * @return List of String objects, whose array version is suitable to be used as argument\n     *         of Runtime.getRuntime().exec()\n     */\n    public List<String> getShellCommandLine( String[] arguments )\n    {\n\n        List<String> commandLine = new ArrayList<String>();\n\n        if ( getShellCommand() != null )\n        {\n            commandLine.add( getShellCommand() );\n        }\n\n        if ( getShellArgs() != null )\n        {\n            commandLine.addAll( getShellArgsList() );\n        }\n\n        commandLine.addAll( getCommandLine( getOriginalExecutable(), arguments ) );\n\n        return commandLine;\n\n    }\n\n    public List<String> getShellArgsList()\n    {\n        return shellArgs;\n    }\n\n    public void addShellArg( String arg )\n    {\n        shellArgs.add( arg );\n    }\n\n    public void setQuotedArgumentsEnabled( boolean quotedArgumentsEnabled )\n    {\n        this.quotedArgumentsEnabled = quotedArgumentsEnabled;\n    }\n\n    public boolean isQuotedArgumentsEnabled()\n    {\n        return quotedArgumentsEnabled;\n    }\n\n    public void setQuotedExecutableEnabled( boolean quotedExecutableEnabled )\n    {\n        this.quotedExecutableEnabled = quotedExecutableEnabled;\n    }\n\n    public boolean isQuotedExecutableEnabled()\n    {\n        return quotedExecutableEnabled;\n    }\n\n    /**\n     * Sets the executable to run.\n     */\n    public void setExecutable( String executable )\n    {\n        if ( ( executable == null ) || ( executable.length() == 0 ) )\n        {\n            return;\n        }\n        this.executable = executable.replace( '/', File.separatorChar ).replace( '\\\\', File.separatorChar );\n    }\n\n    public String getExecutable()\n    {\n        return executable;\n    }\n\n    /**\n     * Sets execution directory.\n     */\n    public void setWorkingDirectory( String path )\n    {\n        if ( path != null )\n        {\n            workingDir = path;\n        }\n    }\n\n    /**\n     * Sets execution directory.\n     */\n    public void setWorkingDirectory( File workingDir )\n    {\n        if ( workingDir != null )\n        {\n            this.workingDir = workingDir.getAbsolutePath();\n        }\n    }\n\n    public File getWorkingDirectory()\n    {\n        return workingDir == null ? null : new File( workingDir );\n    }\n\n    public String getWorkingDirectoryAsString()\n    {\n        return workingDir;\n    }\n\n    public void clearArguments()\n    {\n        shellArgs.clear();\n    }\n\n    public Object clone()\n    {\n        Shell shell = new Shell();\n        shell.setExecutable( getExecutable() );\n        shell.setWorkingDirectory( getWorkingDirectory() );\n        shell.setShellArgs( getShellArgs() );\n        return shell;\n    }\n\n    public String getOriginalExecutable()\n    {\n        return executable;\n    }\n\n    public List<String> getOriginalCommandLine( String executable, String[] arguments )\n    {\n        return getRawCommandLine( executable, arguments );\n    }\n\n    protected void setDoubleQuotedArgumentEscaped( boolean doubleQuotedArgumentEscaped )\n    {\n        this.doubleQuotedArgumentEscaped = doubleQuotedArgumentEscaped;\n    }\n\n    protected void setDoubleQuotedExecutableEscaped( boolean doubleQuotedExecutableEscaped )\n    {\n        this.doubleQuotedExecutableEscaped = doubleQuotedExecutableEscaped;\n    }\n\n    protected void setSingleQuotedArgumentEscaped( boolean singleQuotedArgumentEscaped )\n    {\n        this.singleQuotedArgumentEscaped = singleQuotedArgumentEscaped;\n    }\n\n    protected void setSingleQuotedExecutableEscaped( boolean singleQuotedExecutableEscaped )\n    {\n        this.singleQuotedExecutableEscaped = singleQuotedExecutableEscaped;\n    }\n}\n", "package org.codehaus.plexus.util.cli;\n\n/*\n * Copyright The Codehaus Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport junit.framework.TestCase;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.shell.BourneShell;\nimport org.codehaus.plexus.util.cli.shell.CmdShell;\nimport org.codehaus.plexus.util.cli.shell.Shell;\n\nimport java.io.*;\n\npublic class CommandlineTest\n    extends TestCase\n{\n    private String baseDir;\n\n    /**\n     * @param testName\n     */\n    public CommandlineTest( final String testName )\n    {\n        super( testName );\n    }\n\n    /*\n     * @see TestCase#setUp()\n     */\n    public void setUp()\n        throws Exception\n    {\n        super.setUp();\n        baseDir = System.getProperty( \"basedir\" );\n\n        if ( baseDir == null )\n        {\n            baseDir = new File( \".\" ).getCanonicalPath();\n        }\n    }\n\n    public void testCommandlineWithoutCommandInConstructor()\n    {\n        try\n        {\n            Commandline cmd = new Commandline( new Shell() );\n            cmd.setWorkingDirectory( baseDir );\n            cmd.createArgument().setValue( \"cd\" );\n            cmd.createArgument().setValue( \".\" );\n\n            // NOTE: cmd.toString() uses CommandLineUtils.toString( String[] ), which *quotes* the result.\n            assertEquals( \"cd .\", cmd.toString() );\n        }\n        catch ( Exception e )\n        {\n            fail( e.getMessage() );\n        }\n    }\n\n    public void testCommandlineWithCommandInConstructor()\n    {\n        try\n        {\n            Commandline cmd = new Commandline( \"cd .\", new Shell() );\n            cmd.setWorkingDirectory( baseDir );\n\n            // NOTE: cmd.toString() uses CommandLineUtils.toString( String[] ), which *quotes* the result.\n            assertEquals( \"cd .\", cmd.toString() );\n        }\n        catch ( Exception e )\n        {\n            fail( e.getMessage() );\n        }\n    }\n\n    public void testExecute()\n    {\n        try\n        {\n            // allow it to detect the proper shell here.\n            Commandline cmd = new Commandline();\n            cmd.setWorkingDirectory( baseDir );\n            cmd.setExecutable( \"echo\" );\n            assertEquals( \"echo\", cmd.getShell().getOriginalExecutable() );\n            cmd.createArgument().setValue( \"Hello\" );\n\n            StringWriter swriter = new StringWriter();\n            Process process = cmd.execute();\n\n            Reader reader = new InputStreamReader( process.getInputStream() );\n\n            char[] chars = new char[16];\n            int read = -1;\n            while ( ( read = reader.read( chars ) ) > -1 )\n            {\n                swriter.write( chars, 0, read );\n            }\n\n            String output = swriter.toString().trim();\n\n            assertEquals( \"Hello\", output );\n        }\n        catch ( Exception e )\n        {\n            fail( e.getMessage() );\n        }\n    }\n\n    public void testSetLine()\n    {\n        try\n        {\n            Commandline cmd = new Commandline( new Shell() );\n            cmd.setWorkingDirectory( baseDir );\n            cmd.setExecutable( \"echo\" );\n            cmd.createArgument().setLine( null );\n            cmd.createArgument().setLine( \"Hello\" );\n\n            // NOTE: cmd.toString() uses CommandLineUtils.toString( String[] ), which *quotes* the result.\n            assertEquals( \"echo Hello\", cmd.toString() );\n        }\n        catch ( Exception e )\n        {\n            fail( e.getMessage() );\n        }\n    }\n\n    public void testCreateCommandInReverseOrder()\n    {\n        try\n        {\n            Commandline cmd = new Commandline( new Shell() );\n            cmd.setWorkingDirectory( baseDir );\n            cmd.createArgument().setValue( \".\" );\n            cmd.createArgument( true ).setValue( \"cd\" );\n\n            // NOTE: cmd.toString() uses CommandLineUtils.toString( String[] ), which *quotes* the result.\n            assertEquals( \"cd .\", cmd.toString() );\n        }\n        catch ( Exception e )\n        {\n            fail( e.getMessage() );\n        }\n    }\n\n    public void testSetFile()\n    {\n        try\n        {\n            Commandline cmd = new Commandline( new Shell() );\n            cmd.setWorkingDirectory( baseDir );\n            cmd.createArgument().setValue( \"more\" );\n            File f = new File( \"test.txt\" );\n            cmd.createArgument().setFile( f );\n            String fileName = f.getAbsolutePath();\n            if ( fileName.indexOf( \" \" ) >= 0 )\n            {\n                fileName = \"\\\"\" + fileName + \"\\\"\";\n            }\n\n            // NOTE: cmd.toString() uses CommandLineUtils.toString( String[] ), which *quotes* the result.\n            assertEquals( \"more \" + fileName, cmd.toString() );\n        }\n        catch ( Exception e )\n        {\n            fail( e.getMessage() );\n        }\n    }\n\n    public void testGetShellCommandLineWindows()\n        throws Exception\n    {\n        Commandline cmd = new Commandline( new CmdShell() );\n        cmd.setExecutable( \"c:\\\\Program Files\\\\xxx\" );\n        cmd.addArguments( new String[] {\n            \"a\",\n            \"b\"\n        } );\n        String[] shellCommandline = cmd.getShellCommandline();\n\n        assertEquals( \"Command line size\", 4, shellCommandline.length );\n\n        assertEquals( \"cmd.exe\", shellCommandline[0] );\n        assertEquals( \"/X\", shellCommandline[1] );\n        assertEquals( \"/C\", shellCommandline[2] );\n        String expectedShellCmd = \"\\\"c:\" + File.separator + \"Program Files\" + File.separator\n                                  + \"xxx\\\" a b\";\n        expectedShellCmd = \"\\\"\" + expectedShellCmd + \"\\\"\";\n        assertEquals( expectedShellCmd, shellCommandline[3] );\n    }\n\n    public void testGetShellCommandLineWindowsWithSeveralQuotes()\n        throws Exception\n    {\n        Commandline cmd = new Commandline( new CmdShell() );\n        cmd.setExecutable( \"c:\\\\Program Files\\\\xxx\" );\n        cmd.addArguments( new String[] {\n            \"c:\\\\Documents and Settings\\\\whatever\",\n            \"b\"\n        } );\n        String[] shellCommandline = cmd.getShellCommandline();\n\n        assertEquals( \"Command line size\", 4, shellCommandline.length );\n\n        assertEquals( \"cmd.exe\", shellCommandline[0] );\n        assertEquals( \"/X\", shellCommandline[1] );\n        assertEquals( \"/C\", shellCommandline[2] );\n        String expectedShellCmd = \"\\\"c:\" + File.separator + \"Program Files\" + File.separator\n                                  + \"xxx\\\" \\\"c:\\\\Documents and Settings\\\\whatever\\\" b\";\n        expectedShellCmd = \"\\\"\" + expectedShellCmd + \"\\\"\";\n        assertEquals( expectedShellCmd, shellCommandline[3] );\n    }\n\n    /**\n     * Test the command line generated for the bash shell\n     * @throws Exception\n     */\n    public void testGetShellCommandLineBash()\n        throws Exception\n    {\n        Commandline cmd = new Commandline( new BourneShell() );\n        cmd.setExecutable( \"/bin/echo\" );\n        cmd.addArguments( new String[] {\n            \"hello world\"\n        } );\n\n        String[] shellCommandline = cmd.getShellCommandline();\n\n        assertEquals( \"Command line size\", 3, shellCommandline.length );\n\n        assertEquals( \"/bin/sh\", shellCommandline[0] );\n        assertEquals( \"-c\", shellCommandline[1] );\n        String expectedShellCmd = \"'/bin/echo' 'hello world'\";\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            expectedShellCmd = \"\\\\bin\\\\echo \\'hello world\\'\";\n        }\n        assertEquals( expectedShellCmd, shellCommandline[2] );\n    }\n\n    /**\n    * Test the command line generated for the bash shell\n    * @throws Exception\n    */\n    public void testGetShellCommandLineBash_WithWorkingDirectory()\n        throws Exception\n    {\n        Commandline cmd = new Commandline( new BourneShell() );\n        cmd.setExecutable( \"/bin/echo\" );\n        cmd.addArguments( new String[] {\n            \"hello world\"\n        } );\n        File root = File.listRoots()[0];\n        File workingDirectory = new File( root, \"path with spaces\" );\n        cmd.setWorkingDirectory( workingDirectory );\n\n        String[] shellCommandline = cmd.getShellCommandline();\n\n        assertEquals( \"Command line size\", 3, shellCommandline.length );\n\n        assertEquals( \"/bin/sh\", shellCommandline[0] );\n        assertEquals( \"-c\", shellCommandline[1] );\n        String expectedShellCmd = \"cd '\" + root.getAbsolutePath()\n                                  + \"path with spaces' && '/bin/echo' 'hello world'\";\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            expectedShellCmd = \"cd '\" + root.getAbsolutePath()\n                               + \"path with spaces' && '\\\\bin\\\\echo' 'hello world'\";\n        }\n        assertEquals( expectedShellCmd, shellCommandline[2] );\n    }\n\n    /**\n     * Test the command line generated for the bash shell\n     * @throws Exception\n     */\n    public void testGetShellCommandLineBash_WithSingleQuotedArg()\n        throws Exception\n    {\n        Commandline cmd = new Commandline( new BourneShell() );\n        cmd.setExecutable( \"/bin/echo\" );\n        cmd.addArguments( new String[] {\n            \"\\'hello world\\'\"\n        } );\n\n        String[] shellCommandline = cmd.getShellCommandline();\n\n        assertEquals( \"Command line size\", 3, shellCommandline.length );\n\n        assertEquals( \"/bin/sh\", shellCommandline[0] );\n        assertEquals( \"-c\", shellCommandline[1] );\n        String expectedShellCmd = \"'/bin/echo' ''\\\"'\\\"'hello world'\\\"'\\\"''\";\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            expectedShellCmd = \"\\\\bin\\\\echo \\'hello world\\'\";\n        }\n        assertEquals( expectedShellCmd, shellCommandline[2] );\n    }\n\n    public void testGetShellCommandLineNonWindows()\n        throws Exception\n    {\n        Commandline cmd = new Commandline( new BourneShell() );\n        cmd.setExecutable( \"/usr/bin\" );\n        cmd.addArguments( new String[] {\n            \"a\",\n            \"b\"\n        } );\n        String[] shellCommandline = cmd.getShellCommandline();\n\n        assertEquals( \"Command line size\", 3, shellCommandline.length );\n\n        assertEquals( \"/bin/sh\", shellCommandline[0] );\n        assertEquals( \"-c\", shellCommandline[1] );\n\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            assertEquals( \"\\\\usr\\\\bin a b\", shellCommandline[2] );\n        }\n        else\n        {\n            assertEquals( \"'/usr/bin' 'a' 'b'\", shellCommandline[2] );\n        }\n    }\n\n    public void testEnvironment()\n        throws Exception\n    {\n        Commandline cmd = new Commandline();\n        cmd.addEnvironment( \"name\", \"value\" );\n        assertEquals( \"name=value\", cmd.getEnvironmentVariables()[0] );\n    }\n\n    public void testEnvironmentWitOverrideSystemEnvironment()\n        throws Exception\n    {\n        Commandline cmd = new Commandline();\n        cmd.addSystemEnvironment();\n        cmd.addEnvironment( \"JAVA_HOME\", \"/usr/jdk1.5\" );\n        String[] environmentVariables = cmd.getEnvironmentVariables();\n\n        for ( int i = 0, size = environmentVariables.length; i < size; i++ )\n        {\n            if ( \"JAVA_HOME=/usr/jdk1.5\".equals( environmentVariables[i] ) )\n            {\n                return;\n            }\n        }\n\n        fail( \"can't find JAVA_HOME=/usr/jdk1.5\" );\n    }\n\n    /**\n     * Test an executable with a single apostrophe <code>'</code> in its path\n     *\n     * @throws Exception\n     */\n    public void testQuotedPathWithSingleApostrophe()\n        throws Exception\n    {\n        File dir = new File( System.getProperty( \"basedir\" ), \"target/test/quotedpath'test\" );\n        createAndCallScript( dir, \"echo Quoted\" );\n\n        dir = new File( System.getProperty( \"basedir\" ), \"target/test/quoted path'test\" );\n        createAndCallScript( dir, \"echo Quoted\" );\n    }\n\n    /**\n     * Test an executable with shell-expandable content in its path.\n     *\n     * @throws Exception\n     */\n    public void testPathWithShellExpansionStrings()\n        throws Exception\n    {\n        File dir = new File( System.getProperty( \"basedir\" ), \"target/test/dollar$test\" );\n        createAndCallScript( dir, \"echo Quoted\" );\n    }\n\n    /**\n     * Test an executable with a single quotation mark <code>\\\"</code> in its path only for non Windows box.\n     *\n     * @throws Exception\n     */\n    public void testQuotedPathWithQuotationMark()\n        throws Exception\n    {\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            System.out.println( \"testQuotedPathWithQuotationMark() skipped on Windows\" );\n            return;\n        }\n\n        File dir = new File( System.getProperty( \"basedir\" ), \"target/test/quotedpath\\\"test\" );\n        createAndCallScript( dir, \"echo Quoted\" );\n\n        dir = new File( System.getProperty( \"basedir\" ), \"target/test/quoted path\\\"test\" );\n        createAndCallScript( dir, \"echo Quoted\" );\n    }\n\n    /**\n     * Test an executable with a single quotation mark <code>\\\"</code> and <code>'</code> in its path only for non\n     * Windows box.\n     *\n     * @throws Exception\n     */\n    public void testQuotedPathWithQuotationMarkAndApostrophe()\n        throws Exception\n    {\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            System.out.println( \"testQuotedPathWithQuotationMarkAndApostrophe() skipped on Windows\" );\n            return;\n        }\n\n        File dir = new File( System.getProperty( \"basedir\" ), \"target/test/quotedpath\\\"'test\" );\n        createAndCallScript( dir, \"echo Quoted\" );\n\n        dir = new File( System.getProperty( \"basedir\" ), \"target/test/quoted path\\\"'test\" );\n        createAndCallScript( dir, \"echo Quoted\" );\n    }\n\n    /**\n     * Test an executable with a quote in its path and no space\n     *\n     * @throws Exception\n     */\n    public void testOnlyQuotedPath()\n        throws Exception\n    {\n        File dir = new File( System.getProperty( \"basedir\" ), \"target/test/quotedpath\\'test\" );\n\n        File javaHome = new File( System.getProperty( \"java.home\" ) );\n        File java;\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            java = new File( javaHome, \"/bin/java.exe\" );\n        }\n        else\n        {\n            java = new File( javaHome, \"/bin/java\" );\n        }\n\n        if ( !java.exists() )\n        {\n            throw new IOException( java.getAbsolutePath() + \" doesn't exist\" );\n        }\n\n        createAndCallScript( dir, java.getAbsolutePath() + \" -version\" );\n    }\n\n    public void testDollarSignInArgumentPath()\n        throws Exception\n    {\n        File dir = new File( System.getProperty( \"basedir\" ), \"target/test\" );\n        if ( !dir.exists() )\n        {\n            assertTrue( \"Can't create dir:\" + dir.getAbsolutePath(), dir.mkdirs() );\n        }\n\n        FileWriter writer = null;\n        try\n        {\n            writer = new FileWriter( new File( dir, \"test$1.txt\" ) );\n            IOUtil.copy( \"Success\", writer );\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n\n        Commandline cmd = new Commandline();\n        //cmd.getShell().setShellCommand( \"/bin/sh\" );\n        cmd.getShell().setQuotedArgumentsEnabled( true );\n        cmd.setExecutable( \"cat\" );\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            cmd.setExecutable( \"dir\" );\n        }\n        cmd.setWorkingDirectory( dir );\n        cmd.createArg().setLine( \"test$1.txt\" );\n\n        executeCommandLine( cmd );\n    }\n\n    public void testTimeOutException() throws Exception\n    {\n        File javaHome = new File( System.getProperty( \"java.home\" ) );\n        File java;\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            java = new File( javaHome, \"/bin/java.exe\" );\n        }\n        else\n        {\n            java = new File( javaHome, \"/bin/java\" );\n        }\n\n        if ( !java.exists() )\n        {\n            throw new IOException( java.getAbsolutePath() + \" doesn't exist\" );\n        }\n        \n        Commandline cli = new Commandline();\n        cli.setExecutable( java.getAbsolutePath() );\n        cli.createArg().setLine( \"-version\" );\n        CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n        try\n        {\n            // if the os is faster than 1s to execute java -version the unit will fail :-)\n            CommandLineUtils.executeCommandLine( cli, new DefaultConsumer(), err, 1 );\n        }\n        catch ( CommandLineTimeOutException e )\n        {\n            // it works\n        }\n        \n    }\n    \n    /**\n     * Make the file executable for Unix box.\n     *\n     * @param path not null\n     * @throws IOException if any\n     */\n    private static void makeExecutable( File path )\n        throws IOException\n    {\n        if ( path == null )\n        {\n            throw new IllegalArgumentException( \"The file is null\" );\n        }\n\n        if ( !path.isFile() )\n        {\n            throw new IllegalArgumentException( \"The file '\" + path.getAbsolutePath() + \"' should be a file\" );\n        }\n\n        if ( !Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            Process proc = Runtime.getRuntime().exec( new String[] { \"chmod\", \"a+x\", path.getAbsolutePath() } );\n            while ( true )\n            {\n                try\n                {\n                    proc.waitFor();\n                    break;\n                }\n                catch ( InterruptedException e )\n                {\n                    // ignore\n                }\n            }\n        }\n    }\n\n    /**\n     * Create and execute a script file in the given dir with the given content. The script file will be called\n     * <code>echo.bat</code> for Windows box, otherwise <code>echo</code>.\n     *\n     * @param dir the parent dir where echo.bat or echo will be created\n     * @param content the content of the script file\n     * @throws Exception if any\n     */\n    private static void createAndCallScript( File dir, String content )\n        throws Exception\n    {\n        if ( !dir.exists() )\n        {\n            assertTrue( \"Can't create dir:\" + dir.getAbsolutePath(), dir.mkdirs() );\n        }\n\n        // Create a script file\n        File bat;\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            bat = new File( dir, \"echo.bat\" );\n        }\n        else\n        {\n            bat = new File( dir, \"echo\" );\n        }\n\n        Writer w = new FileWriter( bat );\n        try\n        {\n            IOUtil.copy( content, w );\n        }\n        finally\n        {\n            IOUtil.close( w );\n        }\n\n        // Change permission\n        makeExecutable( bat );\n\n        Commandline cmd = new Commandline();\n        cmd.setExecutable( bat.getAbsolutePath() );\n        cmd.setWorkingDirectory( dir );\n\n        // Execute the script file\n        executeCommandLine( cmd );\n    }\n\n    /**\n     * Execute the command line\n     *\n     * @param cmd not null\n     * @throws Exception if any\n     */\n    private static void executeCommandLine( Commandline cmd )\n        throws Exception\n    {\n        CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n\n        try\n        {\n            System.out.println( \"Command line is: \" + StringUtils.join( cmd.getShellCommandline(), \" \" ) );\n\n            int exitCode = CommandLineUtils.executeCommandLine( cmd, new DefaultConsumer(), err );\n\n            if ( exitCode != 0 )\n            {\n                String msg = \"Exit code: \" + exitCode + \" - \" + err.getOutput();\n                throw new Exception( msg.toString() );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            throw new Exception( \"Unable to execute command: \" + e.getMessage(), e );\n        }\n    }\n}\n", "package org.codehaus.plexus.util.cli.shell;\n\n/*\n * Copyright The Codehaus Foundation.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport junit.framework.TestCase;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class BourneShellTest\n    extends TestCase\n{\n\n    protected Shell newShell()\n    {\n        return new BourneShell();\n    }\n\n    public void testQuoteWorkingDirectoryAndExecutable()\n    {\n        Shell sh = newShell();\n\n        sh.setWorkingDirectory( \"/usr/local/bin\" );\n        sh.setExecutable( \"chmod\" );\n\n        String executable = StringUtils.join( sh.getShellCommandLine( new String[]{} ).iterator(), \" \" );\n\n        assertEquals( \"/bin/sh -c cd '/usr/local/bin' && 'chmod'\", executable );\n    }\n\n    public void testQuoteWorkingDirectoryAndExecutable_WDPathWithSingleQuotes()\n    {\n        Shell sh = newShell();\n\n        sh.setWorkingDirectory( \"/usr/local/'something else'\" );\n        sh.setExecutable( \"chmod\" );\n\n        String executable = StringUtils.join( sh.getShellCommandLine( new String[]{} ).iterator(), \" \" );\n\n        assertEquals( \"/bin/sh -c cd '/usr/local/'\\\"'\\\"'something else'\\\"'\\\"'' && 'chmod'\", executable );\n    }\n\n    public void testQuoteWorkingDirectoryAndExecutable_WDPathWithSingleQuotes_BackslashFileSep()\n    {\n        Shell sh = newShell();\n\n        sh.setWorkingDirectory( \"\\\\usr\\\\local\\\\'something else'\" );\n        sh.setExecutable( \"chmod\" );\n\n        String executable = StringUtils.join( sh.getShellCommandLine( new String[]{} ).iterator(), \" \" );\n\n        assertEquals( \"/bin/sh -c cd '\\\\usr\\\\local\\\\\\'\\\"'\\\"'something else'\\\"'\\\"'' && 'chmod'\", executable );\n    }\n\n    public void testPreserveSingleQuotesOnArgument()\n    {\n        Shell sh = newShell();\n\n        sh.setWorkingDirectory( \"/usr/bin\" );\n        sh.setExecutable( \"chmod\" );\n\n        String[] args = { \"\\'some arg with spaces\\'\" };\n\n        List shellCommandLine = sh.getShellCommandLine( args );\n\n        String cli = StringUtils.join( shellCommandLine.iterator(), \" \" );\n        System.out.println( cli );\n        assertTrue( cli.endsWith(\"''\\\"'\\\"'some arg with spaces'\\\"'\\\"''\"));\n    }\n\n    public void testAddSingleQuotesOnArgumentWithSpaces()\n    {\n        Shell sh = newShell();\n\n        sh.setWorkingDirectory( \"/usr/bin\" );\n        sh.setExecutable( \"chmod\" );\n\n        String[] args = { \"some arg with spaces\" };\n\n        List shellCommandLine = sh.getShellCommandLine( args );\n\n        String cli = StringUtils.join( shellCommandLine.iterator(), \" \" );\n        System.out.println( cli );\n        assertTrue( cli.endsWith( \"\\'\" + args[0] + \"\\'\" ) );\n    }\n\n    public void testEscapeSingleQuotesOnArgument()\n    {\n        Shell sh = newShell();\n\n        sh.setWorkingDirectory( \"/usr/bin\" );\n        sh.setExecutable( \"chmod\" );\n\n        String[] args = { \"arg'withquote\" };\n\n        List shellCommandLine = sh.getShellCommandLine( args );\n\n        String cli = StringUtils.join( shellCommandLine.iterator(), \" \" );\n        System.out.println( cli );\n        assertEquals(\"cd '/usr/bin' && 'chmod' 'arg'\\\"'\\\"'withquote'\", shellCommandLine.get(shellCommandLine.size() - 1));\n    }\n\n    public void testArgumentsWithsemicolon()\n    {\n\n        System.out.println( \"---- semi colon tests ----\" );\n\n        Shell sh = newShell();\n\n        sh.setWorkingDirectory( \"/usr/bin\" );\n        sh.setExecutable( \"chmod\" );\n\n        String[] args = { \";some&argwithunix$chars\" };\n\n        List shellCommandLine = sh.getShellCommandLine( args );\n\n        String cli = StringUtils.join( shellCommandLine.iterator(), \" \" );\n        System.out.println( cli );\n        assertTrue( cli.endsWith( \"\\'\" + args[0] + \"\\'\" ) );\n\n        Commandline commandline = new Commandline( newShell() );\n        commandline.setExecutable( \"chmod\" );\n        commandline.getShell().setQuotedArgumentsEnabled( true );\n        commandline.createArg().setValue( \"--password\" );\n        commandline.createArg().setValue( \";password\" );\n\n        String[] lines = commandline.getShellCommandline();\n        System.out.println( Arrays.asList( lines ) );\n\n        assertEquals( \"/bin/sh\", lines[0] );\n        assertEquals( \"-c\", lines[1] );\n        assertEquals( \"'chmod' '--password' ';password'\", lines[2] );\n\n        commandline = new Commandline( newShell() );\n        commandline.setExecutable( \"chmod\" );\n        commandline.getShell().setQuotedArgumentsEnabled( true );\n        commandline.createArg().setValue( \"--password\" );\n        commandline.createArg().setValue( \";password\" );\n        lines = commandline.getShellCommandline();\n        System.out.println( Arrays.asList( lines ) );\n\n        assertEquals( \"/bin/sh\", lines[0] );\n        assertEquals( \"-c\", lines[1] );\n        assertEquals( \"'chmod' '--password' ';password'\", lines[2] );\n\n        commandline = new Commandline( new CmdShell() );\n        commandline.getShell().setQuotedArgumentsEnabled( true );\n        commandline.createArg().setValue( \"--password\" );\n        commandline.createArg().setValue( \";password\" );\n        lines = commandline.getShellCommandline();\n        System.out.println( Arrays.asList( lines ) );\n\n        assertEquals( \"cmd.exe\", lines[0] );\n        assertEquals( \"/X\", lines[1] );\n        assertEquals( \"/C\", lines[2] );\n        assertEquals( \"\\\"--password ;password\\\"\", lines[3] );\n    }\n\n    public void testBourneShellQuotingCharacters()\n        throws Exception\n    {\n        // { ' ', '$', ';', '&', '|', '<', '>', '*', '?', '(', ')' };\n        // test with values http://steve-parker.org/sh/bourne.shtml Appendix B - Meta-characters and Reserved Words\n        Commandline commandline = new Commandline( newShell() );\n        commandline.setExecutable( \"chmod\" );\n        commandline.getShell().setQuotedArgumentsEnabled( true );\n        commandline.createArg().setValue( \" \" );\n        commandline.createArg().setValue( \"|\" );\n        commandline.createArg().setValue( \"&&\" );\n        commandline.createArg().setValue( \"||\" );\n        commandline.createArg().setValue( \";\" );\n        commandline.createArg().setValue( \";;\" );\n        commandline.createArg().setValue( \"&\" );\n        commandline.createArg().setValue( \"()\" );\n        commandline.createArg().setValue( \"<\" );\n        commandline.createArg().setValue( \"<<\" );\n        commandline.createArg().setValue( \">\" );\n        commandline.createArg().setValue( \">>\" );\n        commandline.createArg().setValue( \"*\" );\n        commandline.createArg().setValue( \"?\" );\n        commandline.createArg().setValue( \"[\" );\n        commandline.createArg().setValue( \"]\" );\n        commandline.createArg().setValue( \"{\" );\n        commandline.createArg().setValue( \"}\" );\n        commandline.createArg().setValue( \"`\" );\n\n        String[] lines = commandline.getShellCommandline();\n        System.out.println( Arrays.asList( lines ) );\n\n        assertEquals( \"/bin/sh\", lines[0] );\n        assertEquals( \"-c\", lines[1] );\n        assertEquals( \"'chmod' ' ' '|' '&&' '||' ';' ';;' '&' '()' '<' '<<' '>' '>>' '*' '?' '[' ']' '{' '}' '`'\",\n                      lines[2] );\n\n    }\n\n}\n"], "filenames": ["src/main/java/org/codehaus/plexus/util/cli/Commandline.java", "src/main/java/org/codehaus/plexus/util/cli/shell/BourneShell.java", "src/main/java/org/codehaus/plexus/util/cli/shell/Shell.java", "src/test/java/org/codehaus/plexus/util/cli/CommandlineTest.java", "src/test/java/org/codehaus/plexus/util/cli/shell/BourneShellTest.java"], "buggy_code_start_loc": [141, 20, 50, 18, 18], "buggy_code_end_loc": [697, 170, 282, 386, 210], "fixing_code_start_loc": [142, 19, 51, 19, 19], "fixing_code_end_loc": [720, 148, 303, 392, 209], "type": "CWE-78", "message": "Plexus-utils before 3.0.16 is vulnerable to command injection because it does not correctly process the contents of double quoted strings.", "other": {"cve": {"id": "CVE-2017-1000487", "sourceIdentifier": "cve@mitre.org", "published": "2018-01-03T20:29:00.703", "lastModified": "2021-01-28T18:11:21.243", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Plexus-utils before 3.0.16 is vulnerable to command injection because it does not correctly process the contents of double quoted strings."}, {"lang": "es", "value": "Plexus-utils, en versiones anteriores a la 3.0.16, es vulnerable a inyecci\u00f3n de comandos debido a que no procesa correctamente el contenido de cadenas con dobles comillas."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-78"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:plexus-utils_project:plexus-utils:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.0.16", "matchCriteriaId": "32FC40BD-9DA1-480F-A13E-1A4C14776DB4"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2018:1322", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/codehaus-plexus/plexus-utils/commit/b38a1b3a4352303e4312b2bb601a0d7ec6e28f41", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/9317fd092b257a0815434b116a8af8daea6e920b6673f4fd5583d5fe@%3Ccommits.druid.apache.org%3E", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r2e94f72f53df432302d359fd66cfa9e9efb8d42633d54579a4377e62@%3Cdev.avro.apache.org%3E", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r9584c4304c888f651d214341a939bd264ed30c9e3d0d30fe85097ecf@%3Ccommits.pulsar.apache.org%3E", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rd0e44e8ef71eeaaa3cf3d1b8b41eb25894372e2995ec908ce7624d26@%3Ccommits.pulsar.apache.org%3E", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/01/msg00010.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/01/msg00011.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JAVA-ORGCODEHAUSPLEXUS-31522", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4146", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4149", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/codehaus-plexus/plexus-utils/commit/b38a1b3a4352303e4312b2bb601a0d7ec6e28f41"}}