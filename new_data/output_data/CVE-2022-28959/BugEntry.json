{"buggy_code": ["<?php\n/***************************************************************************\\\n *  SPIP, Systeme de publication pour l'internet                           *\n *                                                                         *\n *  Copyright (c) 2001-2019                                                *\n *  Arnaud Martin, Antoine Pitrou, Philippe Riviere, Emmanuel Saint-James  *\n *                                                                         *\n *  Ce programme est un logiciel libre distribue sous licence GNU/GPL.     *\n *  Pour plus de details voir le fichier COPYING.txt ou l'aide en ligne.   *\n\\***************************************************************************/\n\n/**\n * Gestion du formulaire d'\u00e9dition de liens\n *\n * @package SPIP\\Core\\Formulaires\n **/\nif (!defined('_ECRIRE_INC_VERSION')) {\n\treturn;\n}\n\n\n/**\n * Retrouve la source et l'objet de la liaison\n *\n * \u00c0 partir des 3 premiers param\u00e8tres transmis au formulaire,\n * la fonction retrouve :\n * - l'objet dont on utilise sa table de liaison (table_source)\n * - l'objet et id_objet sur qui on lie des \u00e9l\u00e9ments (objet, id_objet)\n * - l'objet que l'on veut lier dessus (objet_lien)\n *\n * @param string $a\n * @param string|int $b\n * @param int|string $c\n * @return array\n *   ($table_source,$objet,$id_objet,$objet_lien)\n */\nfunction determine_source_lien_objet($a, $b, $c) {\n\t$table_source = $objet_lien = $objet = $id_objet = null;\n\t// auteurs, article, 23 :\n\t// associer des auteurs \u00e0 l'article 23, sur la table pivot spip_auteurs_liens\n\tif (is_numeric($c) and !is_numeric($b)) {\n\t\t$table_source = table_objet($a);\n\t\t$objet_lien = objet_type($a);\n\t\t$objet = objet_type($b);\n\t\t$id_objet = $c;\n\t}\n\t// article, 23, auteurs\n\t// associer des auteurs \u00e0 l'article 23, sur la table pivot spip_articles_liens\n\tif (is_numeric($b) and !is_numeric($c)) {\n\t\t$table_source = table_objet($c);\n\t\t$objet_lien = objet_type($a);\n\t\t$objet = objet_type($a);\n\t\t$id_objet = $b;\n\t}\n\n\treturn array($table_source, $objet, $id_objet, $objet_lien);\n}\n\n/**\n * Chargement du formulaire d'\u00e9dition de liens\n *\n * #FORMULAIRE_EDITER_LIENS{auteurs,article,23}\n *   pour associer des auteurs \u00e0 l'article 23, sur la table pivot spip_auteurs_liens\n * #FORMULAIRE_EDITER_LIENS{article,23,auteurs}\n *   pour associer des auteurs \u00e0 l'article 23, sur la table pivot spip_articles_liens\n * #FORMULAIRE_EDITER_LIENS{articles,auteur,12}\n *   pour associer des articles \u00e0 l'auteur 12, sur la table pivot spip_articles_liens\n * #FORMULAIRE_EDITER_LIENS{auteur,12,articles}\n *   pour associer des articles \u00e0 l'auteur 12, sur la table pivot spip_auteurs_liens\n *\n * @param string $a\n * @param string|int $b\n * @param int|string $c\n * @param array|bool $options\n *    - Si array, tableau d'options\n *    - Si bool : valeur de l'option 'editable' uniquement\n *\n * @return array\n */\nfunction formulaires_editer_liens_charger_dist($a, $b, $c, $options = array()) {\n\n\t// compat avec ancienne signature ou le 4eme argument est $editable\n\tif (!is_array($options)) {\n\t\t$options = array('editable' => $options);\n\t} elseif (!isset($options['editable'])) {\n\t\t$options['editable'] = true;\n\t}\n\n\t$editable = $options['editable'];\n\n\tlist($table_source, $objet, $id_objet, $objet_lien) = determine_source_lien_objet($a, $b, $c);\n\tif (!$table_source or !$objet or !$objet_lien or !$id_objet) {\n\t\treturn false;\n\t}\n\n\t$objet_source = objet_type($table_source);\n\t$table_sql_source = table_objet_sql($objet_source);\n\n\t// verifier existence de la table xxx_liens\n\tinclude_spip('action/editer_liens');\n\tif (!objet_associable($objet_lien)) {\n\t\treturn false;\n\t}\n\n\t// L'\u00e9ditabilit\u00e9 :) est d\u00e9finie par un test permanent (par exemple \"associermots\") ET le 4\u00e8me argument\n\tinclude_spip('inc/autoriser');\n\t$editable = ($editable and autoriser('associer' . $table_source, $objet, $id_objet)\n\t\tand autoriser('modifier', $objet, $id_objet));\n\n\tif (!$editable and !count(objet_trouver_liens(\n\t\tarray($objet_lien => '*'),\n\t\tarray(($objet_lien == $objet_source ? $objet : $objet_source) => $id_objet)\n\t))) {\n\t\treturn false;\n\t}\n\n\t// squelettes de vue et de d'association\n\t// ils sont diff\u00e9rents si des r\u00f4les sont d\u00e9finis.\n\t$skel_vue = $table_source . '_lies';\n\t$skel_ajout = $table_source . '_associer';\n\n\t// description des roles\n\tinclude_spip('inc/roles');\n\tif ($roles = roles_presents($objet_source, $objet)) {\n\t\t// on demande de nouveaux squelettes en cons\u00e9quence\n\t\t$skel_vue = $table_source . '_roles_lies';\n\t\t$skel_ajout = $table_source . '_roles_associer';\n\t}\n\n\t$valeurs = array(\n\t\t'id' => \"$table_source-$objet-$id_objet-$objet_lien\", // identifiant unique pour les id du form\n\t\t'_vue_liee' => $skel_vue,\n\t\t'_vue_ajout' => $skel_ajout,\n\t\t'_objet_lien' => $objet_lien,\n\t\t'id_lien_ajoute' => _request('id_lien_ajoute'),\n\t\t'objet' => $objet,\n\t\t'id_objet' => $id_objet,\n\t\t'objet_source' => $objet_source,\n\t\t'table_source' => $table_source,\n\t\t'recherche' => '',\n\t\t'visible' => 0,\n\t\t'ajouter_lien' => '',\n\t\t'supprimer_lien' => '',\n\t\t'qualifier_lien' => '',\n\t\t'ordonner_lien' => '',\n\t\t'desordonner_liens' => '',\n\t\t'_roles' => $roles, # description des roles\n\t\t'_oups' => _request('_oups'),\n\t\t'editable' => $editable,\n\t);\n\n\t// les options non definies dans $valeurs sont passees telles quelles au formulaire html\n\t$valeurs = array_merge($options, $valeurs);\n\n\treturn $valeurs;\n}\n\n/**\n * Traiter le post des informations d'\u00e9dition de liens\n *\n * Les formulaires peuvent poster dans quatre variables\n * - ajouter_lien et supprimer_lien\n * - remplacer_lien\n * - qualifier_lien\n * - ordonner_lien\n * - desordonner_liens\n *\n * Les deux premi\u00e8res peuvent \u00eatre de trois formes diff\u00e9rentes :\n * ajouter_lien[]=\"objet1-id1-objet2-id2\"\n * ajouter_lien[objet1-id1-objet2-id2]=\"nimportequoi\"\n * ajouter_lien['clenonnumerique']=\"objet1-id1-objet2-id2\"\n * Dans ce dernier cas, la valeur ne sera prise en compte\n * que si _request('clenonnumerique') est vrai (submit associ\u00e9 a l'input)\n *\n * remplacer_lien doit \u00eatre de la forme\n * remplacer_lien[objet1-id1-objet2-id2]=\"objet3-id3-objet2-id2\"\n * ou objet1-id1 est celui qu'on enleve et objet3-id3 celui qu'on ajoute\n *\n * qualifier_lien doit \u00eatre de la forme, et sert en compl\u00e9ment de ajouter_lien\n * qualifier_lien[objet1-id1-objet2-id2][role] = array(\"role1\", \"autre_role\")\n * qualifier_lien[objet1-id1-objet2-id2][valeur] = array(\"truc\", \"chose\")\n * produira 2 liens chacun avec array(\"role\"=>\"role1\",\"valeur\"=>\"truc\") et array(\"role\"=>\"autre_role\",\"valeur\"=>\"chose\")\n *\n * ordonner_lien doit \u00eatre de la forme, et sert pour trier les liens\n * ordonner_lien[objet1-id1-objet2-id2] = nouveau_rang\n *\n * desordonner_liens n'a pas de forme pr\u00e9cise, il doit simplement \u00eatre non nul/non vide\n *\n * @param string $a\n * @param string|int $b\n * @param int|string $c\n * @param array|bool $options\n *    - Si array, tableau d'options\n *    - Si bool : valeur de l'option 'editable' uniquement\n *\n * @return array\n */\nfunction formulaires_editer_liens_traiter_dist($a, $b, $c, $options = array()) {\n\t// compat avec ancienne signature ou le 4eme argument est $editable\n\tif (!is_array($options)) {\n\t\t$options = array('editable' => $options);\n\t} elseif (!isset($options['editable'])) {\n\t\t$options['editable'] = true;\n\t}\n\n\t$editable = $options['editable'];\n\n\t$res = array('editable' => $editable ? true : false);\n\tlist($table_source, $objet, $id_objet, $objet_lien) = determine_source_lien_objet($a, $b, $c);\n\tif (!$table_source or !$objet or !$objet_lien) {\n\t\treturn $res;\n\t}\n\n\n\tif (_request('tout_voir')) {\n\t\tset_request('recherche', '');\n\t}\n\n\tinclude_spip('inc/autoriser');\n\tif (autoriser('modifier', $objet, $id_objet)) {\n\t\t// annuler les suppressions du coup d'avant !\n\t\tif (_request('annuler_oups')\n\t\t\tand $oups = _request('_oups')\n\t\t\tand $oups = unserialize($oups)\n\t\t) {\n\t\t\tif ($oups_objets = charger_fonction(\"editer_liens_oups_{$table_source}_{$objet}_{$objet_lien}\", 'action', true)) {\n\t\t\t\t$oups_objets($oups);\n\t\t\t} else {\n\t\t\t\t$objet_source = objet_type($table_source);\n\t\t\t\tinclude_spip('action/editer_liens');\n\t\t\t\tforeach ($oups as $oup) {\n\t\t\t\t\tif ($objet_lien == $objet_source) {\n\t\t\t\t\t\tobjet_associer(array($objet_source => $oup[$objet_source]), array($objet => $oup[$objet]), $oup);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobjet_associer(array($objet => $oup[$objet]), array($objet_source => $oup[$objet_source]), $oup);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t# oups ne persiste que pour la derniere action, si suppression\n\t\t\tset_request('_oups');\n\t\t}\n\n\t\t$supprimer = _request('supprimer_lien');\n\t\t$ajouter = _request('ajouter_lien');\n\t\t$ordonner = _request('ordonner_lien');\n\n\t\tif (_request('desordonner_liens')) {\n\t\t\tinclude_spip('action/editer_liens');\n\t\t\tobjet_qualifier_liens(array($objet_lien => '*'), array($objet => $id_objet), array('rang_lien' => 0));\n\t\t}\n\n\t\t// il est possible de preciser dans une seule variable un remplacement :\n\t\t// remplacer_lien[old][new]\n\t\tif ($remplacer = _request('remplacer_lien')) {\n\t\t\tforeach ($remplacer as $k => $v) {\n\t\t\t\tif ($old = lien_verifier_action($k, '')) {\n\t\t\t\t\tforeach (is_array($v) ? $v : array($v) as $kn => $vn) {\n\t\t\t\t\t\tif ($new = lien_verifier_action($kn, $vn)) {\n\t\t\t\t\t\t\t$supprimer[$old] = 'x';\n\t\t\t\t\t\t\t$ajouter[$new] = '+';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ($supprimer) {\n\t\t\tif ($supprimer_objets = charger_fonction(\n\t\t\t\t\"editer_liens_supprimer_{$table_source}_{$objet}_{$objet_lien}\",\n\t\t\t\t'action',\n\t\t\t\ttrue\n\t\t\t)) {\n\t\t\t\t$oups = $supprimer_objets($supprimer);\n\t\t\t} else {\n\t\t\t\tinclude_spip('action/editer_liens');\n\t\t\t\t$oups = array();\n\n\t\t\t\tforeach ($supprimer as $k => $v) {\n\t\t\t\t\tif ($lien = lien_verifier_action($k, $v)) {\n\t\t\t\t\t\t$lien = explode('-', $lien);\n\t\t\t\t\t\tlist($objet_source, $ids, $objet_lie, $idl, $role) = array_pad($lien, 5, null);\n\t\t\t\t\t\t// appliquer une condition sur le r\u00f4le si d\u00e9fini ('*' pour tous les roles)\n\t\t\t\t\t\t$cond = (!is_null($role) ? array('role' => $role) : array());\n\t\t\t\t\t\tif ($objet_lien == $objet_source) {\n\t\t\t\t\t\t\t$oups = array_merge(\n\t\t\t\t\t\t\t\t$oups,\n\t\t\t\t\t\t\t\tobjet_trouver_liens(array($objet_source => $ids), array($objet_lie => $idl), $cond)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tobjet_dissocier(array($objet_source => $ids), array($objet_lie => $idl), $cond);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$oups = array_merge(\n\t\t\t\t\t\t\t\t$oups,\n\t\t\t\t\t\t\t\tobjet_trouver_liens(array($objet_lie => $idl), array($objet_source => $ids), $cond)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tobjet_dissocier(array($objet_lie => $idl), array($objet_source => $ids), $cond);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tset_request('_oups', $oups ? serialize($oups) : null);\n\t\t}\n\n\t\tif ($ajouter) {\n\t\t\tif ($ajouter_objets = charger_fonction(\"editer_liens_ajouter_{$table_source}_{$objet}_{$objet_lien}\", 'action', true)\n\t\t\t) {\n\t\t\t\t$ajout_ok = $ajouter_objets($ajouter);\n\t\t\t} else {\n\t\t\t\t$ajout_ok = false;\n\t\t\t\tinclude_spip('action/editer_liens');\n\t\t\t\tforeach ($ajouter as $k => $v) {\n\t\t\t\t\tif ($lien = lien_verifier_action($k, $v)) {\n\t\t\t\t\t\t$ajout_ok = true;\n\t\t\t\t\t\tlist($objet1, $ids, $objet2, $idl) = explode('-', $lien);\n\t\t\t\t\t\t$qualifs = lien_retrouver_qualif($objet_lien, $lien);\n\t\t\t\t\t\tif ($objet_lien == $objet1) {\n\t\t\t\t\t\t\tlien_ajouter_liaisons($objet1, $ids, $objet2, $idl, $qualifs);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlien_ajouter_liaisons($objet2, $idl, $objet1, $ids, $qualifs);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tset_request('id_lien_ajoute', $ids);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t# oups ne persiste que pour la derniere action, si suppression\n\t\t\t# une suppression suivie d'un ajout dans le meme hit est un remplacement\n\t\t\t# non annulable !\n\t\t\tif ($ajout_ok) {\n\t\t\t\tset_request('_oups');\n\t\t\t}\n\t\t}\n\n\t\tif ($ordonner) {\n\t\t\tinclude_spip('action/editer_liens');\n\t\t\tforeach ($ordonner as $k => $rang_lien) {\n\t\t\t\tif ($lien = lien_verifier_action($k, '')) {\n\t\t\t\t\tlist($objet1, $ids, $objet2, $idl) = explode('-', $lien);\n\t\t\t\t\t$qualif = array('rang_lien' => $rang_lien);\n\n\t\t\t\t\tif ($objet_lien == $objet1) {\n\t\t\t\t\t\tobjet_qualifier_liens(array($objet1 => $ids), array($objet2 => $idl), $qualif);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobjet_qualifier_liens(array($objet2 => $idl), array($objet1 => $ids), $qualif);\n\t\t\t\t\t}\n\t\t\t\t\tset_request('id_lien_ajoute', $ids);\n\t\t\t\t\tset_request('_oups');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\treturn $res;\n}\n\n\n/**\n * Retrouver l'action de liaision demand\u00e9e\n *\n * Les formulaires envoient une action dans un tableau ajouter_lien\n * ou supprimer_lien\n *\n * L'action est de la forme : objet1-id1-objet2-id2\n * ou de la forme : objet1-id1-objet2-id2-role\n *\n * L'action peut-\u00eatre indiqu\u00e9e dans la cl\u00e9 ou dans la valeur.\n * Si elle est indiquee dans la valeur et que la cl\u00e9 est non num\u00e9rique,\n * on ne la prend en compte que si un submit avec la cl\u00e9 a \u00e9t\u00e9 envoy\u00e9\n *\n * @internal\n * @param string $k Cl\u00e9 du tableau\n * @param string $v Valeur du tableau\n * @return string Action demand\u00e9e si trouv\u00e9e, sinon ''\n */\nfunction lien_verifier_action($k, $v) {\n\t$action = '';\n\tif (preg_match(',^\\w+-[\\w*]+-[\\w*]+-[\\w*]+(-[\\w*])?,', $k)) {\n\t\t$action = $k;\n\t}\n\tif (preg_match(',^\\w+-[\\w*]+-[\\w*]+-[\\w*]+(-[\\w*])?,', $v)) {\n\t\tif (is_numeric($k)) {\n\t\t\t$action = $v;\n\t\t}\n\t\tif (_request($k)) {\n\t\t\t$action = $v;\n\t\t}\n\t}\n\t// ajout un role null fictif (plus pratique) si pas d\u00e9fini\n\tif ($action and count(explode('-', $action)) == 4) {\n\t\t$action .= '-';\n\t}\n\n\treturn $action;\n}\n\n\n/**\n * Retrouve le ou les qualificatifs post\u00e9s avec une liaison demand\u00e9e\n *\n * @internal\n * @param string $objet_lien\n *    objet qui porte le lien\n * @param string $lien\n *   Action du lien\n * @return array\n *   Liste des qualifs pour chaque lien. Tableau vide s'il n'y en a pas.\n **/\nfunction lien_retrouver_qualif($objet_lien, $lien) {\n\t// un role est d\u00e9fini dans la liaison\n\t$defs = explode('-', $lien);\n\tlist($objet1, , $objet2, , $role) = array_pad($defs, 5, null);\n\tif ($objet_lien == $objet1) {\n\t\t$colonne_role = roles_colonne($objet1, $objet2);\n\t} else {\n\t\t$colonne_role = roles_colonne($objet2, $objet1);\n\t}\n\n\t// cas ou le role est defini en 5e argument de l'action sur le lien (suppression, ajout rapide sans autre attribut)\n\tif ($role) {\n\t\treturn array(\n\t\t\t// un seul lien avec ce role\n\t\t\tarray($colonne_role => $role)\n\t\t);\n\t}\n\n\t// retrouver les r\u00f4les post\u00e9s pour cette liaison, s'il y en a.\n\t$qualifier_lien = _request('qualifier_lien');\n\tif (!$qualifier_lien or !is_array($qualifier_lien)) {\n\t\treturn array();\n\t}\n\n\t// pas avec l'action complete (incluant le role)\n\t$qualif = array();\n\tif ((!isset($qualifier_lien[$lien]) or !$qualif = $qualifier_lien[$lien])\n\t\tand count($defs) == 5\n\t) {\n\t\t// on tente avec l'action sans le role\n\t\tarray_pop($defs);\n\t\t$lien = implode('-', $defs);\n\t\tif (!isset($qualifier_lien[$lien]) or !$qualif = $qualifier_lien[$lien]) {\n\t\t\t$qualif = array();\n\t\t}\n\t}\n\n\t// $qualif de la forme array(role=>array(...),valeur=>array(...),....)\n\t// on le reforme en array(array(role=>..,valeur=>..,..),array(role=>..,valeur=>..,..),...)\n\t$qualifs = array();\n\twhile (count($qualif)) {\n\t\t$q = array();\n\t\tforeach ($qualif as $att => $values) {\n\t\t\tif (is_array($values)) {\n\t\t\t\t$q[$att] = array_shift($qualif[$att]);\n\t\t\t\tif (!count($qualif[$att])) {\n\t\t\t\t\tunset($qualif[$att]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$q[$att] = $values;\n\t\t\t\tunset($qualif[$att]);\n\t\t\t}\n\t\t}\n\t\t// pas de r\u00f4le vide\n\t\tif (!$colonne_role or !isset($q[$colonne_role]) or $q[$colonne_role]) {\n\t\t\t$qualifs[] = $q;\n\t\t}\n\t}\n\n\treturn $qualifs;\n}\n\n/**\n * Ajoute les liens demand\u00e9s en prenant \u00e9ventuellement en compte le r\u00f4le\n *\n * Appelle la fonction objet_associer. L'appelle autant de fois qu'il y\n * a de r\u00f4les demand\u00e9s pour cette liaison.\n *\n * @internal\n * @param string $objet_source Objet source de la liaison (qui a la table de liaison)\n * @param array|string $ids Identifiants pour l'objet source\n * @param string $objet_lien Objet \u00e0 lier\n * @param array|string $idl Identifiants pour l'objet li\u00e9\n * @param array $qualifs\n * @return void\n **/\nfunction lien_ajouter_liaisons($objet_source, $ids, $objet_lien, $idl, $qualifs) {\n\n\t// retrouver la colonne de roles s'il y en a a lier\n\tif (is_array($qualifs) and count($qualifs)) {\n\t\tforeach ($qualifs as $qualif) {\n\t\t\tobjet_associer(array($objet_source => $ids), array($objet_lien => $idl), $qualif);\n\t\t}\n\t} else {\n\t\tobjet_associer(array($objet_source => $ids), array($objet_lien => $idl));\n\t}\n}\n"], "fixing_code": ["<?php\n/***************************************************************************\\\n *  SPIP, Systeme de publication pour l'internet                           *\n *                                                                         *\n *  Copyright (c) 2001-2019                                                *\n *  Arnaud Martin, Antoine Pitrou, Philippe Riviere, Emmanuel Saint-James  *\n *                                                                         *\n *  Ce programme est un logiciel libre distribue sous licence GNU/GPL.     *\n *  Pour plus de details voir le fichier COPYING.txt ou l'aide en ligne.   *\n\\***************************************************************************/\n\n/**\n * Gestion du formulaire d'\u00e9dition de liens\n *\n * @package SPIP\\Core\\Formulaires\n **/\nif (!defined('_ECRIRE_INC_VERSION')) {\n\treturn;\n}\n\n\n/**\n * Retrouve la source et l'objet de la liaison\n *\n * \u00c0 partir des 3 premiers param\u00e8tres transmis au formulaire,\n * la fonction retrouve :\n * - l'objet dont on utilise sa table de liaison (table_source)\n * - l'objet et id_objet sur qui on lie des \u00e9l\u00e9ments (objet, id_objet)\n * - l'objet que l'on veut lier dessus (objet_lien)\n *\n * @param string $a\n * @param string|int $b\n * @param int|string $c\n * @return array\n *   ($table_source,$objet,$id_objet,$objet_lien)\n */\nfunction determine_source_lien_objet($a, $b, $c) {\n\t$table_source = $objet_lien = $objet = $id_objet = null;\n\t// auteurs, article, 23 :\n\t// associer des auteurs \u00e0 l'article 23, sur la table pivot spip_auteurs_liens\n\tif (is_numeric($c) and !is_numeric($b)) {\n\t\t$table_source = table_objet($a);\n\t\t$objet_lien = objet_type($a);\n\t\t$objet = objet_type($b);\n\t\t$id_objet = $c;\n\t}\n\t// article, 23, auteurs\n\t// associer des auteurs \u00e0 l'article 23, sur la table pivot spip_articles_liens\n\tif (is_numeric($b) and !is_numeric($c)) {\n\t\t$table_source = table_objet($c);\n\t\t$objet_lien = objet_type($a);\n\t\t$objet = objet_type($a);\n\t\t$id_objet = $b;\n\t}\n\n\treturn array($table_source, $objet, $id_objet, $objet_lien);\n}\n\n/**\n * Chargement du formulaire d'\u00e9dition de liens\n *\n * #FORMULAIRE_EDITER_LIENS{auteurs,article,23}\n *   pour associer des auteurs \u00e0 l'article 23, sur la table pivot spip_auteurs_liens\n * #FORMULAIRE_EDITER_LIENS{article,23,auteurs}\n *   pour associer des auteurs \u00e0 l'article 23, sur la table pivot spip_articles_liens\n * #FORMULAIRE_EDITER_LIENS{articles,auteur,12}\n *   pour associer des articles \u00e0 l'auteur 12, sur la table pivot spip_articles_liens\n * #FORMULAIRE_EDITER_LIENS{auteur,12,articles}\n *   pour associer des articles \u00e0 l'auteur 12, sur la table pivot spip_auteurs_liens\n *\n * @param string $a\n * @param string|int $b\n * @param int|string $c\n * @param array|bool $options\n *    - Si array, tableau d'options\n *    - Si bool : valeur de l'option 'editable' uniquement\n *\n * @return array\n */\nfunction formulaires_editer_liens_charger_dist($a, $b, $c, $options = array()) {\n\n\t// compat avec ancienne signature ou le 4eme argument est $editable\n\tif (!is_array($options)) {\n\t\t$options = array('editable' => $options);\n\t} elseif (!isset($options['editable'])) {\n\t\t$options['editable'] = true;\n\t}\n\n\t$editable = $options['editable'];\n\n\tlist($table_source, $objet, $id_objet, $objet_lien) = determine_source_lien_objet($a, $b, $c);\n\tif (!$table_source or !$objet or !$objet_lien or !$id_objet) {\n\t\treturn false;\n\t}\n\n\t$objet_source = objet_type($table_source);\n\t$table_sql_source = table_objet_sql($objet_source);\n\n\t// verifier existence de la table xxx_liens\n\tinclude_spip('action/editer_liens');\n\tif (!objet_associable($objet_lien)) {\n\t\treturn false;\n\t}\n\n\t// L'\u00e9ditabilit\u00e9 :) est d\u00e9finie par un test permanent (par exemple \"associermots\") ET le 4\u00e8me argument\n\tinclude_spip('inc/autoriser');\n\t$editable = ($editable and autoriser('associer' . $table_source, $objet, $id_objet)\n\t\tand autoriser('modifier', $objet, $id_objet));\n\n\tif (!$editable and !count(objet_trouver_liens(\n\t\tarray($objet_lien => '*'),\n\t\tarray(($objet_lien == $objet_source ? $objet : $objet_source) => $id_objet)\n\t))) {\n\t\treturn false;\n\t}\n\n\t// squelettes de vue et de d'association\n\t// ils sont diff\u00e9rents si des r\u00f4les sont d\u00e9finis.\n\t$skel_vue = $table_source . '_lies';\n\t$skel_ajout = $table_source . '_associer';\n\n\t// description des roles\n\tinclude_spip('inc/roles');\n\tif ($roles = roles_presents($objet_source, $objet)) {\n\t\t// on demande de nouveaux squelettes en cons\u00e9quence\n\t\t$skel_vue = $table_source . '_roles_lies';\n\t\t$skel_ajout = $table_source . '_roles_associer';\n\t}\n\n\t$oups = _request('_oups');\n\tif (unserialize(base64_decode($oups))) {\n\t\t// on est bon, rien a faire\n\t}\n\telseif(unserialize($oups)) {\n\t\t// il faut encoder\n\t\t$oups = base64_encode($oups);\n\t}\n\telse {\n\t\t$oups = '';\n\t}\n\t$valeurs = array(\n\t\t'id' => \"$table_source-$objet-$id_objet-$objet_lien\", // identifiant unique pour les id du form\n\t\t'_vue_liee' => $skel_vue,\n\t\t'_vue_ajout' => $skel_ajout,\n\t\t'_objet_lien' => $objet_lien,\n\t\t'id_lien_ajoute' => _request('id_lien_ajoute'),\n\t\t'objet' => $objet,\n\t\t'id_objet' => $id_objet,\n\t\t'objet_source' => $objet_source,\n\t\t'table_source' => $table_source,\n\t\t'recherche' => '',\n\t\t'visible' => 0,\n\t\t'ajouter_lien' => '',\n\t\t'supprimer_lien' => '',\n\t\t'qualifier_lien' => '',\n\t\t'ordonner_lien' => '',\n\t\t'desordonner_liens' => '',\n\t\t'_roles' => $roles, # description des roles\n\t\t'_oups' => $oups,\n\t\t'editable' => $editable,\n\t);\n\n\t// les options non definies dans $valeurs sont passees telles quelles au formulaire html\n\t$valeurs = array_merge($options, $valeurs);\n\n\treturn $valeurs;\n}\n\n/**\n * Traiter le post des informations d'\u00e9dition de liens\n *\n * Les formulaires peuvent poster dans quatre variables\n * - ajouter_lien et supprimer_lien\n * - remplacer_lien\n * - qualifier_lien\n * - ordonner_lien\n * - desordonner_liens\n *\n * Les deux premi\u00e8res peuvent \u00eatre de trois formes diff\u00e9rentes :\n * ajouter_lien[]=\"objet1-id1-objet2-id2\"\n * ajouter_lien[objet1-id1-objet2-id2]=\"nimportequoi\"\n * ajouter_lien['clenonnumerique']=\"objet1-id1-objet2-id2\"\n * Dans ce dernier cas, la valeur ne sera prise en compte\n * que si _request('clenonnumerique') est vrai (submit associ\u00e9 a l'input)\n *\n * remplacer_lien doit \u00eatre de la forme\n * remplacer_lien[objet1-id1-objet2-id2]=\"objet3-id3-objet2-id2\"\n * ou objet1-id1 est celui qu'on enleve et objet3-id3 celui qu'on ajoute\n *\n * qualifier_lien doit \u00eatre de la forme, et sert en compl\u00e9ment de ajouter_lien\n * qualifier_lien[objet1-id1-objet2-id2][role] = array(\"role1\", \"autre_role\")\n * qualifier_lien[objet1-id1-objet2-id2][valeur] = array(\"truc\", \"chose\")\n * produira 2 liens chacun avec array(\"role\"=>\"role1\",\"valeur\"=>\"truc\") et array(\"role\"=>\"autre_role\",\"valeur\"=>\"chose\")\n *\n * ordonner_lien doit \u00eatre de la forme, et sert pour trier les liens\n * ordonner_lien[objet1-id1-objet2-id2] = nouveau_rang\n *\n * desordonner_liens n'a pas de forme pr\u00e9cise, il doit simplement \u00eatre non nul/non vide\n *\n * @param string $a\n * @param string|int $b\n * @param int|string $c\n * @param array|bool $options\n *    - Si array, tableau d'options\n *    - Si bool : valeur de l'option 'editable' uniquement\n *\n * @return array\n */\nfunction formulaires_editer_liens_traiter_dist($a, $b, $c, $options = array()) {\n\t// compat avec ancienne signature ou le 4eme argument est $editable\n\tif (!is_array($options)) {\n\t\t$options = array('editable' => $options);\n\t} elseif (!isset($options['editable'])) {\n\t\t$options['editable'] = true;\n\t}\n\n\t$editable = $options['editable'];\n\n\t$res = array('editable' => $editable ? true : false);\n\tlist($table_source, $objet, $id_objet, $objet_lien) = determine_source_lien_objet($a, $b, $c);\n\tif (!$table_source or !$objet or !$objet_lien) {\n\t\treturn $res;\n\t}\n\n\n\tif (_request('tout_voir')) {\n\t\tset_request('recherche', '');\n\t}\n\n\tinclude_spip('inc/autoriser');\n\tif (autoriser('modifier', $objet, $id_objet)) {\n\t\t// annuler les suppressions du coup d'avant !\n\t\tif (_request('annuler_oups')\n\t\t\tand $oups = _request('_oups')\n\t\t\tand $oups = base64_decode($oups)\n\t\t\tand $oups = unserialize($oups)\n\t\t) {\n\t\t\tif ($oups_objets = charger_fonction(\"editer_liens_oups_{$table_source}_{$objet}_{$objet_lien}\", 'action', true)) {\n\t\t\t\t$oups_objets($oups);\n\t\t\t} else {\n\t\t\t\t$objet_source = objet_type($table_source);\n\t\t\t\tinclude_spip('action/editer_liens');\n\t\t\t\tforeach ($oups as $oup) {\n\t\t\t\t\tif ($objet_lien == $objet_source) {\n\t\t\t\t\t\tobjet_associer(array($objet_source => $oup[$objet_source]), array($objet => $oup[$objet]), $oup);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobjet_associer(array($objet => $oup[$objet]), array($objet_source => $oup[$objet_source]), $oup);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t# oups ne persiste que pour la derniere action, si suppression\n\t\t\tset_request('_oups');\n\t\t}\n\n\t\t$supprimer = _request('supprimer_lien');\n\t\t$ajouter = _request('ajouter_lien');\n\t\t$ordonner = _request('ordonner_lien');\n\n\t\tif (_request('desordonner_liens')) {\n\t\t\tinclude_spip('action/editer_liens');\n\t\t\tobjet_qualifier_liens(array($objet_lien => '*'), array($objet => $id_objet), array('rang_lien' => 0));\n\t\t}\n\n\t\t// il est possible de preciser dans une seule variable un remplacement :\n\t\t// remplacer_lien[old][new]\n\t\tif ($remplacer = _request('remplacer_lien')) {\n\t\t\tforeach ($remplacer as $k => $v) {\n\t\t\t\tif ($old = lien_verifier_action($k, '')) {\n\t\t\t\t\tforeach (is_array($v) ? $v : array($v) as $kn => $vn) {\n\t\t\t\t\t\tif ($new = lien_verifier_action($kn, $vn)) {\n\t\t\t\t\t\t\t$supprimer[$old] = 'x';\n\t\t\t\t\t\t\t$ajouter[$new] = '+';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ($supprimer) {\n\t\t\tif ($supprimer_objets = charger_fonction(\n\t\t\t\t\"editer_liens_supprimer_{$table_source}_{$objet}_{$objet_lien}\",\n\t\t\t\t'action',\n\t\t\t\ttrue\n\t\t\t)) {\n\t\t\t\t$oups = $supprimer_objets($supprimer);\n\t\t\t} else {\n\t\t\t\tinclude_spip('action/editer_liens');\n\t\t\t\t$oups = array();\n\n\t\t\t\tforeach ($supprimer as $k => $v) {\n\t\t\t\t\tif ($lien = lien_verifier_action($k, $v)) {\n\t\t\t\t\t\t$lien = explode('-', $lien);\n\t\t\t\t\t\tlist($objet_source, $ids, $objet_lie, $idl, $role) = array_pad($lien, 5, null);\n\t\t\t\t\t\t// appliquer une condition sur le r\u00f4le si d\u00e9fini ('*' pour tous les roles)\n\t\t\t\t\t\t$cond = (!is_null($role) ? array('role' => $role) : array());\n\t\t\t\t\t\tif ($objet_lien == $objet_source) {\n\t\t\t\t\t\t\t$oups = array_merge(\n\t\t\t\t\t\t\t\t$oups,\n\t\t\t\t\t\t\t\tobjet_trouver_liens(array($objet_source => $ids), array($objet_lie => $idl), $cond)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tobjet_dissocier(array($objet_source => $ids), array($objet_lie => $idl), $cond);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$oups = array_merge(\n\t\t\t\t\t\t\t\t$oups,\n\t\t\t\t\t\t\t\tobjet_trouver_liens(array($objet_lie => $idl), array($objet_source => $ids), $cond)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tobjet_dissocier(array($objet_lie => $idl), array($objet_source => $ids), $cond);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tset_request('_oups', $oups ? base64_encode(serialize($oups)) : null);\n\t\t}\n\n\t\tif ($ajouter) {\n\t\t\tif ($ajouter_objets = charger_fonction(\"editer_liens_ajouter_{$table_source}_{$objet}_{$objet_lien}\", 'action', true)\n\t\t\t) {\n\t\t\t\t$ajout_ok = $ajouter_objets($ajouter);\n\t\t\t} else {\n\t\t\t\t$ajout_ok = false;\n\t\t\t\tinclude_spip('action/editer_liens');\n\t\t\t\tforeach ($ajouter as $k => $v) {\n\t\t\t\t\tif ($lien = lien_verifier_action($k, $v)) {\n\t\t\t\t\t\t$ajout_ok = true;\n\t\t\t\t\t\tlist($objet1, $ids, $objet2, $idl) = explode('-', $lien);\n\t\t\t\t\t\t$qualifs = lien_retrouver_qualif($objet_lien, $lien);\n\t\t\t\t\t\tif ($objet_lien == $objet1) {\n\t\t\t\t\t\t\tlien_ajouter_liaisons($objet1, $ids, $objet2, $idl, $qualifs);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlien_ajouter_liaisons($objet2, $idl, $objet1, $ids, $qualifs);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tset_request('id_lien_ajoute', $ids);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t# oups ne persiste que pour la derniere action, si suppression\n\t\t\t# une suppression suivie d'un ajout dans le meme hit est un remplacement\n\t\t\t# non annulable !\n\t\t\tif ($ajout_ok) {\n\t\t\t\tset_request('_oups');\n\t\t\t}\n\t\t}\n\n\t\tif ($ordonner) {\n\t\t\tinclude_spip('action/editer_liens');\n\t\t\tforeach ($ordonner as $k => $rang_lien) {\n\t\t\t\tif ($lien = lien_verifier_action($k, '')) {\n\t\t\t\t\tlist($objet1, $ids, $objet2, $idl) = explode('-', $lien);\n\t\t\t\t\t$qualif = array('rang_lien' => $rang_lien);\n\n\t\t\t\t\tif ($objet_lien == $objet1) {\n\t\t\t\t\t\tobjet_qualifier_liens(array($objet1 => $ids), array($objet2 => $idl), $qualif);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tobjet_qualifier_liens(array($objet2 => $idl), array($objet1 => $ids), $qualif);\n\t\t\t\t\t}\n\t\t\t\t\tset_request('id_lien_ajoute', $ids);\n\t\t\t\t\tset_request('_oups');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\treturn $res;\n}\n\n\n/**\n * Retrouver l'action de liaision demand\u00e9e\n *\n * Les formulaires envoient une action dans un tableau ajouter_lien\n * ou supprimer_lien\n *\n * L'action est de la forme : objet1-id1-objet2-id2\n * ou de la forme : objet1-id1-objet2-id2-role\n *\n * L'action peut-\u00eatre indiqu\u00e9e dans la cl\u00e9 ou dans la valeur.\n * Si elle est indiquee dans la valeur et que la cl\u00e9 est non num\u00e9rique,\n * on ne la prend en compte que si un submit avec la cl\u00e9 a \u00e9t\u00e9 envoy\u00e9\n *\n * @internal\n * @param string $k Cl\u00e9 du tableau\n * @param string $v Valeur du tableau\n * @return string Action demand\u00e9e si trouv\u00e9e, sinon ''\n */\nfunction lien_verifier_action($k, $v) {\n\t$action = '';\n\tif (preg_match(',^\\w+-[\\w*]+-[\\w*]+-[\\w*]+(-[\\w*])?,', $k)) {\n\t\t$action = $k;\n\t}\n\tif (preg_match(',^\\w+-[\\w*]+-[\\w*]+-[\\w*]+(-[\\w*])?,', $v)) {\n\t\tif (is_numeric($k)) {\n\t\t\t$action = $v;\n\t\t}\n\t\tif (_request($k)) {\n\t\t\t$action = $v;\n\t\t}\n\t}\n\t// ajout un role null fictif (plus pratique) si pas d\u00e9fini\n\tif ($action and count(explode('-', $action)) == 4) {\n\t\t$action .= '-';\n\t}\n\n\treturn $action;\n}\n\n\n/**\n * Retrouve le ou les qualificatifs post\u00e9s avec une liaison demand\u00e9e\n *\n * @internal\n * @param string $objet_lien\n *    objet qui porte le lien\n * @param string $lien\n *   Action du lien\n * @return array\n *   Liste des qualifs pour chaque lien. Tableau vide s'il n'y en a pas.\n **/\nfunction lien_retrouver_qualif($objet_lien, $lien) {\n\t// un role est d\u00e9fini dans la liaison\n\t$defs = explode('-', $lien);\n\tlist($objet1, , $objet2, , $role) = array_pad($defs, 5, null);\n\tif ($objet_lien == $objet1) {\n\t\t$colonne_role = roles_colonne($objet1, $objet2);\n\t} else {\n\t\t$colonne_role = roles_colonne($objet2, $objet1);\n\t}\n\n\t// cas ou le role est defini en 5e argument de l'action sur le lien (suppression, ajout rapide sans autre attribut)\n\tif ($role) {\n\t\treturn array(\n\t\t\t// un seul lien avec ce role\n\t\t\tarray($colonne_role => $role)\n\t\t);\n\t}\n\n\t// retrouver les r\u00f4les post\u00e9s pour cette liaison, s'il y en a.\n\t$qualifier_lien = _request('qualifier_lien');\n\tif (!$qualifier_lien or !is_array($qualifier_lien)) {\n\t\treturn array();\n\t}\n\n\t// pas avec l'action complete (incluant le role)\n\t$qualif = array();\n\tif ((!isset($qualifier_lien[$lien]) or !$qualif = $qualifier_lien[$lien])\n\t\tand count($defs) == 5\n\t) {\n\t\t// on tente avec l'action sans le role\n\t\tarray_pop($defs);\n\t\t$lien = implode('-', $defs);\n\t\tif (!isset($qualifier_lien[$lien]) or !$qualif = $qualifier_lien[$lien]) {\n\t\t\t$qualif = array();\n\t\t}\n\t}\n\n\t// $qualif de la forme array(role=>array(...),valeur=>array(...),....)\n\t// on le reforme en array(array(role=>..,valeur=>..,..),array(role=>..,valeur=>..,..),...)\n\t$qualifs = array();\n\twhile (count($qualif)) {\n\t\t$q = array();\n\t\tforeach ($qualif as $att => $values) {\n\t\t\tif (is_array($values)) {\n\t\t\t\t$q[$att] = array_shift($qualif[$att]);\n\t\t\t\tif (!count($qualif[$att])) {\n\t\t\t\t\tunset($qualif[$att]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t$q[$att] = $values;\n\t\t\t\tunset($qualif[$att]);\n\t\t\t}\n\t\t}\n\t\t// pas de r\u00f4le vide\n\t\tif (!$colonne_role or !isset($q[$colonne_role]) or $q[$colonne_role]) {\n\t\t\t$qualifs[] = $q;\n\t\t}\n\t}\n\n\treturn $qualifs;\n}\n\n/**\n * Ajoute les liens demand\u00e9s en prenant \u00e9ventuellement en compte le r\u00f4le\n *\n * Appelle la fonction objet_associer. L'appelle autant de fois qu'il y\n * a de r\u00f4les demand\u00e9s pour cette liaison.\n *\n * @internal\n * @param string $objet_source Objet source de la liaison (qui a la table de liaison)\n * @param array|string $ids Identifiants pour l'objet source\n * @param string $objet_lien Objet \u00e0 lier\n * @param array|string $idl Identifiants pour l'objet li\u00e9\n * @param array $qualifs\n * @return void\n **/\nfunction lien_ajouter_liaisons($objet_source, $ids, $objet_lien, $idl, $qualifs) {\n\n\t// retrouver la colonne de roles s'il y en a a lier\n\tif (is_array($qualifs) and count($qualifs)) {\n\t\tforeach ($qualifs as $qualif) {\n\t\t\tobjet_associer(array($objet_source => $ids), array($objet_lien => $idl), $qualif);\n\t\t}\n\t} else {\n\t\tobjet_associer(array($objet_source => $ids), array($objet_lien => $idl));\n\t}\n}\n"], "filenames": ["prive/formulaires/editer_liens.php"], "buggy_code_start_loc": [129], "buggy_code_end_loc": [301], "fixing_code_start_loc": [130], "fixing_code_end_loc": [313], "type": "CWE-79", "message": "Multiple cross-site scripting (XSS) vulnerabilities in the component /spip.php of Spip Web Framework v3.1.13 and below allows attackers to execute arbitrary web scripts or HTML.", "other": {"cve": {"id": "CVE-2022-28959", "sourceIdentifier": "cve@mitre.org", "published": "2022-05-19T21:15:08.060", "lastModified": "2022-05-26T04:55:19.037", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Multiple cross-site scripting (XSS) vulnerabilities in the component /spip.php of Spip Web Framework v3.1.13 and below allows attackers to execute arbitrary web scripts or HTML."}, {"lang": "es", "value": "M\u00faltiples vulnerabilidades de tipo cross-site scripting (XSS) en el componente /spip.php de Spip Web Framework versiones v3.1.13 y anteriores, permite a atacantes ejecutar scripts web o HTML arbitrarios"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:spip:spip:*:*:*:*:*:*:*:*", "versionEndIncluding": "3.1.13", "matchCriteriaId": "D2834C8B-8286-43F8-8DD9-0CAC21094A30"}]}]}], "references": [{"url": "https://blog.spip.net/Mise-a-jour-CRITIQUE-de-securite-SPIP-3-2-8-et-SPIP-3-1-13.html", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/spip/SPIP/commit/0394b44774555ae8331b6e65e35065dfa0bb41e4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/spip/SPIP/commit/6c1650713fc948318852ace759aab8f1a84791cf", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://thinkloveshare.com/en/hacking/rce_on_spip_and_root_me/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://www.root-me.org/fr/Informations/Faiblesses-decouvertes/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/spip/SPIP/commit/0394b44774555ae8331b6e65e35065dfa0bb41e4"}}