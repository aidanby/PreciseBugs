{"buggy_code": ["/**\n  Onion HTTP server library\n  Copyright (C) 2010-2018 David Moreno Montero and others\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of, at your choice:\n\n  a. the Apache License Version 2.0.\n\n  b. the GNU General Public License as published by the\n  Free Software Foundation; either version 2.0 of the License,\n  or (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of both licenses, if not see\n  <http://www.gnu.org/licenses/> and\n  <http://www.apache.org/licenses/LICENSE-2.0>.\n*/\n\n#ifndef ONION_LOW_UTIL_H\n#define ONION_LOW_UTIL_H\n\n/**\n * @defgroup low Low level. Basic OS functions that can be exchanged for alternative implementations (Boehm GC.)\n *\n * File low.h provides low level utilities, notably wrapping\n * memory allocation and thread creation. Adventurous users could even\n * customize them during early initialization, e.g. when using Hans\n * Boehm conservative garbage collector from http://hboehm.info/gc/ or\n * when using their own malloc variant so we specialize general data -\n * which might contain pointers and could be allocated with GC_MALLOC\n * into scalar data which is guaranteed to be pointer free and could\n * be allocated with GC_MALLOC_ATOMIC ...\n *\n * If your server does not use an alternative implementation, feel free not\n * to use this functions, but if it might use it, please use them.\n */\n\n#include <stdlib.h>\n#include <signal.h>\n#include <pthread.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n * @short NEVER FAILING MEMORY ALLOCATORS\n * @{\n *\n * These allocators should not fail: if memory is exhausted, they\n * invoke the memory failure routine then abort with a short\n * failure message.\n */\n/**\n * @short Our malloc wrapper for any kind of data, including data containing pointers.\n * @ingroup low\n */\n  void *onion_low_malloc(size_t sz);\n\n/**\n * @short Our malloc wrapper for scalar data which does not contain any pointers inside.\n * @ingroup low\n *\n * Knowing that a given zone does not contain any pointer can be useful, e.g. to Hans Boehm's conservative garbage\n * collector on http://hboehm.info/gc/ using GC_MALLOC_ATOMIC....\n */\n  void *onion_low_scalar_malloc(size_t sz);\n\n/// @short Our calloc wrapper for any kind of data, even scalar one.\n/// @ingroup low\n  void *onion_low_calloc(size_t nmemb, size_t size);\n\n/// @short Our realloc wrapper for any kind of data, even scalar one.\n/// @ingroup low\n  void *onion_low_realloc(void *ptr, size_t size);\n\n/// @short Our strdup wrapper.\n/// @ingroup low\n  char *onion_low_strdup(const char *str);\n\n/// @}\n\n/**\n * @short POSSIBLY FAILING MEMORY ALLOCATORS\n * @{\n *\n * These allocators could fail by returning NULL. Their caller is\n * requested to handle that failure.\n */\n\n/// @short Our malloc wrapper for any kind of data, including data containing pointers. May return NULL on fail.\n/// @ingroup low\n  void *onion_low_try_malloc(size_t sz);\n\n/// @short Our malloc wrapper for scalar data which does not contain any pointers inside.  May return NULL on fail.\n/// @ingroup low\n  void *onion_low_try_scalar_malloc(size_t sz);\n\n/// @short Our calloc wrapper for any kind of data, even scalar one.  May return NULL on fail.\n/// @ingroup low\n  void *onion_low_try_calloc(size_t nmemb, size_t size);\n\n/// @short Our realloc wrapper for any kind of data, even scalar one. May return NULL on fail.\n/// @ingroup low\n  void *onion_low_try_realloc(void *ptr, size_t size);\n\n/// @short Our strdup wrapper. May return NULL on fail.\n/// @ingroup low\n  char *onion_low_try_strdup(const char *str);\n\n  /******** FREE WRAPPER ******/\n/// @short Our free wrapper for any kind of data, even scalar one.\n/// @ingroup low\n  void onion_low_free(void *ptr);\n\n// @}\n\n/// @short Signatures of user configurable memory routine replacement.  @{\n/// @ingroup low\n  typedef void *onion_low_malloc_sigt(size_t sz);\n  typedef void *onion_low_scalar_malloc_sigt(size_t sz);\n  typedef void *onion_low_calloc_sigt(size_t nmemb, size_t size);\n  typedef void *onion_low_realloc_sigt(void *ptr, size_t size);\n  typedef char *onion_low_strdup_sigt(const char *ptr);\n  typedef void onion_low_free_sigt(void *ptr);\n\n/**\n * @short The memory failure handler is called with a short message.\n * @ingroup low\n *\n * It generally should not return, i.e. should exit, abort, or perhaps\n * setjmp....\n */\n  typedef void onion_low_memoryfailure_sigt(const char *msg);\n/// @}\n\n/**\n * @short Our configurator for memory routines.\n * @ingroup low\n *\n * To be called once before any other onion processing at initialization.\n * All the routines should be explicitly provided.\n */\n  void onion_low_initialize_memory_allocation\n      (onion_low_malloc_sigt * mallocrout,\n       onion_low_scalar_malloc_sigt * scalarmallocrout,\n       onion_low_calloc_sigt * callocrout,\n       onion_low_realloc_sigt * reallocrout,\n       onion_low_strdup_sigt * strduprout,\n       onion_low_free_sigt * freerout,\n       onion_low_memoryfailure_sigt * memoryfailurerout);\n\n/**\n * @short Configuration for pthread creation and management.\n * @ingroup low\n * @{\n * We also offer a mean to wrap thread creation, join, cancel,\n * detach, exit. This is needed for Boehm's garbage collector -\n * which has GC_pthread_create, GC_pthread_join, ... and could be\n * useful to others, e.g. for calling pthread_setname_np on Linux\n * system.  There is no need to wrap mutexes... The wrapper functions\n * can fail and their caller is expected to check for failure.\n */\n#ifdef HAVE_PTHREADS\n  int onion_low_pthread_create(pthread_t * thread,\n                               const pthread_attr_t * attr,\n                               void *(*start_routine) (void *), void *arg);\n  typedef int onion_low_pthread_create_sigt(pthread_t * thread,\n                                            const pthread_attr_t * attr,\n                                            void *(*start_routine) (void *),\n                                            void *arg);\n\n  int onion_low_pthread_join(pthread_t thread, void **retval);\n  typedef int onion_low_pthread_join_sigt(pthread_t thread, void **retval);\n\n  int onion_low_pthread_cancel(pthread_t thread);\n  typedef int onion_low_pthread_cancel_sigt(pthread_t thread);\n\n  int onion_low_pthread_detach(pthread_t thread);\n  typedef int onion_low_pthread_detach_sigt(pthread_t thread);\n\n  void onion_low_pthread_exit(void *retval);\n  typedef void onion_low_pthread_exit_sigt(void *retval);\n\n  int onion_low_pthread_sigmask(int how, const sigset_t * set,\n                                sigset_t * oldset);\n  typedef int onion_low_pthread_sigmask_sigt(int how, const sigset_t * set,\n                                             sigset_t * oldset);\n\n/**\n * @short Our configurator for pthread wrapping.\n * @ingroup low\n *\n * Every routine should be provided. This initialization should happen early,\n * at the same time as onion_low_initialize_memory_allocation, and before any\n * other onion calls. If using Boehm GC you probably want to pass\n * GC_pthread_create, GC_pthread_join, etc, etc...\n */\n  void onion_low_initialize_threads\n      (onion_low_pthread_create_sigt * thrcreator,\n       onion_low_pthread_join_sigt * thrjoiner,\n       onion_low_pthread_cancel_sigt * thrcanceler,\n       onion_low_pthread_detach_sigt * thrdetacher,\n       onion_low_pthread_exit_sigt * threxiter,\n       onion_low_pthread_sigmask_sigt * thrsigmasker);\n/// @}\n#endif                          /*HAVE_PTHREADS */\n\n#ifdef __cplusplus\n}                               /* end extern \"C\" */\n#endif\n#endif                          /*ONION_LOW_UTIL_H */\n", "/**\n  Onion HTTP server library\n  Copyright (C) 2010-2021 David Moreno Montero and others\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of, at your choice:\n\n  a. the Apache License Version 2.0.\n\n  b. the GNU General Public License as published by the\n  Free Software Foundation; either version 2.0 of the License,\n  or (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of both licenses, if not see\n  <http://www.gnu.org/licenses/> and\n  <http://www.apache.org/licenses/LICENSE-2.0>.\n*/\n\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <time.h>\n#include <stdarg.h>\n#include <assert.h>\n#include <errno.h>\n\n#ifdef HAVE_PTHREADS\n#include <pthread.h>\n#endif\n\n#include \"dict.h\"\n#include \"request.h\"\n#include \"response.h\"\n#include \"types_internal.h\"\n#include \"log.h\"\n#include \"codecs.h\"\n#include \"low.h\"\n\n/// @defgroup response Response. Write response data to client: headers, content body...\n\nconst char *onion_response_code_description(int code);\n\n// DONT_USE_DATE_HEADER is not defined anywhere, but here just in case needed in the future.\n\n#ifndef DONT_USE_DATE_HEADER\nstatic volatile time_t onion_response_last_time = 0;\nstatic char *onion_response_last_date_header = NULL;\n#ifdef HAVE_PTHREADS\npthread_rwlock_t onion_response_date_lock = PTHREAD_RWLOCK_INITIALIZER;\n#endif\n#endif\n\n/**\n * @short Generates a new response object\n * @memberof onion_response_t\n * @ingroup response\n *\n * This response is generated from a request, and gets from there the writer and writer data.\n *\n * Also fills some important data, as server Id, License type, and the default content type.\n *\n * Default content type is HTML, as normally this is what is needed. This is nontheless just\n * the default, and can be changed to any other with a call to:\n *\n *   onion_response_set_header(res, \"Content-Type\", my_type);\n *\n * The response object must be freed with onion_response_free, which also returns the keep alive\n * status.\n *\n * onion_response objects are passed by onion internally to process the request, and should not be\n * created by user normally. Nontheless the option exist.\n *\n * @returns An onion_response object for that request.\n */\nonion_response *onion_response_new(onion_request * req) {\n  onion_response *res = onion_low_malloc(sizeof(onion_response));\n\n  res->request = req;\n  res->headers = onion_dict_new();\n  res->code = 200;              // The most normal code, so no need to overwrite it in other codes.\n  res->flags = 0;\n  res->sent_bytes_total = res->length = res->sent_bytes = 0;\n  res->buffer_pos = 0;\n\n#ifndef DONT_USE_DATE_HEADER\n  {\n    time_t t;\n    struct tm tmp;\n\n    t = time(NULL);\n\n    // onion_response_last_date_header is set to t later. It should be more or less atomic.\n    // If not no big deal, as we will just use slightly more CPU on those \"ephemeral\" moments.\n\n    time_t current = __sync_add_and_fetch(&onion_response_last_time, 0);\n\n    if (t != current) {\n      ONION_DEBUG(\"Recalculating date header\");\n      char current_datetime[200];\n\n      if (localtime_r(&t, &tmp) == NULL) {\n        perror(\"localtime\");\n        exit(EXIT_FAILURE);\n      }\n\n      if (strftime\n          (current_datetime, sizeof(current_datetime),\n           \"%a, %d %b %Y %H:%M:%S %Z\", &tmp) == 0) {\n        fprintf(stderr, \"strftime returned 0\");\n        exit(EXIT_FAILURE);\n      }\n#ifdef HAVE_PTHREADS\n      pthread_rwlock_wrlock(&onion_response_date_lock);\n#endif\n      __sync_bool_compare_and_swap(&onion_response_last_time, current, t);\n      if (onion_response_last_date_header)\n        onion_low_free(onion_response_last_date_header);\n      onion_response_last_date_header = onion_low_strdup(current_datetime);\n#ifdef HAVE_PTHREADS\n      pthread_rwlock_unlock(&onion_response_date_lock);\n#endif\n    }\n  }\n#ifdef HAVE_PTHREADS\n  pthread_rwlock_rdlock(&onion_response_date_lock);\n#endif\n  assert(onion_response_last_date_header);\n  onion_dict_add(res->headers, \"Date\", onion_response_last_date_header,\n                 OD_DUP_VALUE);\n#ifdef HAVE_PTHREADS\n  pthread_rwlock_unlock(&onion_response_date_lock);\n#endif\n#endif                          // USE_DATE_HEADER\n  // Sorry for the advertisment.\n  onion_dict_add(res->headers, \"Server\",\n                 \"libonion v\" ONION_VERSION \" - coralbits.com\", 0);\n  onion_dict_add(res->headers, \"Content-Type\", \"text/html\", 0); // Maybe not the best guess, but really useful.\n  //time_t t=time(NULL);\n  //onion_dict_add(res->headers, \"Date\", asctime(localtime(&t)), OD_DUP_VALUE);\n\n  return res;\n}\n\n/**\n * @short Frees the memory consumed by this object\n * @memberof onion_response_t\n * @ingroup response\n *\n * This function returns the close status: OR_KEEP_ALIVE or OR_CLOSE_CONNECTION as needed.\n *\n * @returns Whether the connection should be closed or not, or an error status to be handled by server.\n * @see onion_connection_status\n */\nonion_connection_status onion_response_free(onion_response * res) {\n  // write pending data.\n  if (!(res->flags & OR_HEADER_SENT) && res->buffer_pos < sizeof(res->buffer))\n    onion_response_set_length(res, res->buffer_pos);\n\n  if (!(res->flags & OR_HEADER_SENT))\n    onion_response_write_headers(res);\n\n  onion_response_flush(res);\n  onion_request *req = res->request;\n\n  if (res->flags & OR_CHUNKED) {        // Set the chunked data end.\n    req->connection.listen_point->write(req, \"0\\r\\n\\r\\n\", 5);\n  }\n\n  int r = OCS_CLOSE_CONNECTION;\n\n  // it is a rare ocasion that there is no request, but although unlikely, it may happen\n  if (req) {\n    // keep alive only on HTTP/1.1.\n    ONION_DEBUG0\n        (\"keep alive [req wants] %d && ([skip] %d || [lenght ok] %d==%d || [chunked] %d)\",\n         onion_request_keep_alive(req), res->flags & OR_SKIP_CONTENT,\n         res->length, res->sent_bytes, res->flags & OR_CHUNKED);\n    if (onion_request_keep_alive(req)\n        && (res->flags & OR_SKIP_CONTENT || res->length == res->sent_bytes\n            || res->flags & OR_CHUNKED)\n        )\n      r = OCS_KEEP_ALIVE;\n\n    if ((onion_log_flags & OF_NOINFO) != OF_NOINFO)\n      // FIXME! This is no proper logging at all. Maybe use a handler.\n      ONION_INFO(\"[%s] \\\"%s %s\\\" %d %d (%s)\",\n                 onion_request_get_client_description(res->request),\n                 onion_request_methods[res->request->flags & OR_METHODS],\n                 res->request->fullpath, res->code, res->sent_bytes,\n                 (r == OCS_KEEP_ALIVE) ? \"Keep-Alive\" : \"Close connection\");\n  }\n\n  onion_dict_free(res->headers);\n  onion_low_free(res);\n\n  return r;\n}\n\n/**\n * @short Adds a header to the response object\n * @memberof onion_response_t\n * @ingroup response\n */\nvoid onion_response_set_header(onion_response * res, const char *key,\n                               const char *value) {\n  ONION_DEBUG0(\"Adding header %s = %s\", key, value);\n  onion_dict_add(res->headers, key, value, OD_DUP_ALL | OD_REPLACE);    // DUP_ALL not so nice on memory side...\n}\n\n/**\n * @short Sets the header length. Normally it should be through set_header, but as its very common and needs some procesing here is a shortcut\n * @memberof onion_response_t\n * @ingroup response\n */\nvoid onion_response_set_length(onion_response * res, size_t len) {\n  if (len != res->sent_bytes && res->flags & OR_HEADER_SENT) {\n    ONION_WARNING\n        (\"Trying to set length after headers sent. Undefined onion behaviour.\");\n    return;\n  }\n  char tmp[16];\n  sprintf(tmp, \"%lu\", (unsigned long)len);\n  onion_response_set_header(res, \"Content-Length\", tmp);\n  res->length = len;\n  res->flags |= OR_LENGTH_SET;\n}\n\n/**\n * @short Sets the return code\n * @memberof onion_response_t\n * @ingroup response\n */\nvoid onion_response_set_code(onion_response * res, int code) {\n  res->code = code;\n}\n\n/**\n * @short Helper that is called on each header, and writes the header\n * @memberof onion_response_t\n * @ingroup response\n */\nstatic void write_header(onion_response * res, const char *key,\n                         const char *value, int flags) {\n  //ONION_DEBUG0(\"Response header: %s: %s\",key, value);\n\n  onion_response_write0(res, key);\n  onion_response_write(res, \": \", 2);\n  onion_response_write0(res, value);\n  onion_response_write(res, \"\\r\\n\", 2);\n}\n\n#define CONNECTION_CLOSE \"Connection: Close\\r\\n\"\n#define CONNECTION_KEEP_ALIVE \"Connection: Keep-Alive\\r\\n\"\n#define CONNECTION_CHUNK_ENCODING \"Transfer-Encoding: chunked\\r\\n\"\n#define CONNECTION_UPGRADE \"Connection: Upgrade\\r\\n\"\n\n/**\n * @short Writes all the header to the given response\n * @memberof onion_response_t\n * @ingroup response\n *\n * It writes the headers and depending on the method, return OR_SKIP_CONTENT. this is set when in head mode. Handlers\n * should react to this return by not trying to write more, but if they try this object will just skip those writtings.\n *\n * Explicit calling to this function is not necessary, as as soon as the user calls any write function this will\n * be performed.\n *\n * As soon as the headers are written, any modification on them will be just ignored.\n *\n * @returns 0 if should procced to normal data write, or OR_SKIP_CONTENT if should not write content.\n */\nint onion_response_write_headers(onion_response * res) {\n  if (!res->request) {\n    ONION_ERROR\n        (\"Bad formed response. Need a request at creation. Will not write headers.\");\n    return -1;\n  }\n\n  res->flags |= OR_HEADER_SENT; // I Set at the begining so I can do normal writing.\n  res->request->flags |= OR_HEADER_SENT;\n  char chunked = 0;\n\n  if (res->request->flags & OR_HTTP11) {\n    onion_response_printf(res, \"HTTP/1.1 %d %s\\r\\n\", res->code,\n                          onion_response_code_description(res->code));\n    //ONION_DEBUG(\"Response header: HTTP/1.1 %d %s\\n\",res->code, onion_response_code_description(res->code));\n    if (!(res->flags & OR_LENGTH_SET) && onion_request_keep_alive(res->request)) {\n      onion_response_write(res, CONNECTION_CHUNK_ENCODING,\n                           sizeof(CONNECTION_CHUNK_ENCODING) - 1);\n      chunked = 1;\n    }\n  } else {\n    onion_response_printf(res, \"HTTP/1.0 %d %s\\r\\n\", res->code,\n                          onion_response_code_description(res->code));\n    //ONION_DEBUG(\"Response header: HTTP/1.0 %d %s\\n\",res->code, onion_response_code_description(res->code));\n    if (res->flags & OR_LENGTH_SET)     // On HTTP/1.0, i need to state it. On 1.1 it is default.\n      onion_response_write(res, CONNECTION_KEEP_ALIVE,\n                           sizeof(CONNECTION_KEEP_ALIVE) - 1);\n  }\n\n  if (!(res->flags & OR_LENGTH_SET) && !chunked\n      && !(res->flags & OR_CONNECTION_UPGRADE))\n    onion_response_write(res, CONNECTION_CLOSE, sizeof(CONNECTION_CLOSE) - 1);\n\n  if (res->flags & OR_CONNECTION_UPGRADE)\n    onion_response_write(res, CONNECTION_UPGRADE,\n                         sizeof(CONNECTION_UPGRADE) - 1);\n\n  onion_dict_preorder(res->headers, write_header, res);\n\n  if (res->request->session_id && (onion_dict_count(res->request->session) > 0))        // I have session with something, tell user\n    onion_response_printf(res, \"Set-Cookie: sessionid=%s; httponly; Path=/\\n\",\n                          res->request->session_id);\n\n  onion_response_write(res, \"\\r\\n\", 2);\n\n  ONION_DEBUG0(\"Headers written\");\n  res->sent_bytes = -res->buffer_pos;   // the header size is not counted here. It will add again so start negative.\n\n  if ((res->request->flags & OR_METHODS) == OR_HEAD) {\n    onion_response_flush(res);\n    res->flags |= OR_SKIP_CONTENT;\n    return OR_SKIP_CONTENT;\n  }\n  if (chunked) {\n    onion_response_flush(res);\n    res->flags |= OR_CHUNKED;\n  }\n\n  return 0;\n}\n\n/**\n * @short Write some response data.\n * @memberof onion_response_t\n * @ingroup response\n *\n * This is the main write data function. If the headers have not been sent yet, they are now.\n *\n * It's internally used also by the write0 and printf versions.\n *\n * Also it does some buffering, so data is not sent as written by code, but only in chunks.\n * These chunks are when the response is finished, or when the internal buffer is full. This\n * helps performance, and eases the programming on the user side.\n *\n * If length is 0, forces the write of pending data.\n *\n * @returns The bytes written, normally just length. On error returns OCS_CLOSE_CONNECTION.\n */\nssize_t onion_response_write(onion_response * res, const char *data,\n                             size_t length) {\n  if (res->flags & OR_SKIP_CONTENT) {\n    if (!(res->flags & OR_HEADER_SENT)) {       // Automatic header write\n      onion_response_write_headers(res);\n    }\n    ONION_DEBUG(\"Skipping content as we are in HEAD mode\");\n    return OCS_CLOSE_CONNECTION;\n  }\n  if (length == 0) {\n    onion_response_flush(res);\n    return 0;\n  }\n  //ONION_DEBUG0(\"Write %d bytes [%d total] (%p)\", length, res->sent_bytes, res);\n\n  int l = length;\n  int w = 0;\n  while (res->buffer_pos + l > sizeof(res->buffer)) {\n    int wb = sizeof(res->buffer) - res->buffer_pos;\n    memcpy(&res->buffer[res->buffer_pos], data, wb);\n\n    res->buffer_pos = sizeof(res->buffer);\n    if (onion_response_flush(res) < 0)\n      return w;\n\n    l -= wb;\n    data += wb;\n    w += wb;\n  }\n\n  memcpy(&res->buffer[res->buffer_pos], data, l);\n  res->buffer_pos += l;\n  w += l;\n\n  return w;\n}\n\n/**\n * @short Writes all buffered output waiting for sending.\n * @ingroup response\n *\n * If header has not been sent yet (delayed), it uses a temporary buffer to send it now. This\n * way header can use the buffer_size information to send the proper content-length, even when it\n * wasnt properly set by programmer. Whith this information its possib to keep alive the connection\n * on more cases.\n */\nint onion_response_flush(onion_response * res) {\n  res->sent_bytes += res->buffer_pos;\n  res->sent_bytes_total += res->buffer_pos;\n  if (res->buffer_pos == 0)     // Not used.\n    return 0;\n  if (!(res->flags & OR_HEADER_SENT)) { // Automatic header write\n    ONION_DEBUG0\n        (\"Doing fast header hack: store current buffer, send current headers. Resend buffer.\");\n    char tmpb[sizeof(res->buffer)];\n    int tmpp = res->buffer_pos;\n    memcpy(tmpb, res->buffer, res->buffer_pos);\n    res->buffer_pos = 0;\n\n    onion_response_write_headers(res);\n    onion_response_write(res, tmpb, tmpp);\n    return 0;\n  }\n  if (res->flags & OR_SKIP_CONTENT)     // HEAD request\n    return 0;\n  ONION_DEBUG0(\"Flush %d bytes\", res->buffer_pos);\n\n  onion_request *req = res->request;\n  ssize_t(*write) (onion_request *, const char *data, size_t len);\n  write = req->connection.listen_point->write;\n\n  ssize_t w;\n  off_t pos = 0;\n  //ONION_DEBUG0(\"Write %d bytes\",res->buffer_pos);\n  if (res->flags & OR_CHUNKED) {\n    char tmp[16];\n    snprintf(tmp, sizeof(tmp), \"%X\\r\\n\", (unsigned int)res->buffer_pos);\n    if ((w = write(req, tmp, strlen(tmp))) <= 0) {\n      ONION_WARNING(\"Error writing chunk encoding length (%X) %s. Aborting write.\",\n\n\t\t    (unsigned int)res->buffer_pos, strerror(errno));\n      return OCS_CLOSE_CONNECTION;\n    }\n    ONION_DEBUG0(\"Write %d-%d bytes\", res->buffer_pos, w);\n  }\n  int savederrno = errno;\n  errno = 0;\n  while ((w =\n          write(req, &res->buffer[pos], res->buffer_pos)) != res->buffer_pos) {\n    if (w <= 0 || res->buffer_pos < 0) {\n      ONION_ERROR(\"Error writing %d bytes (%s). Maybe closed connection. Code %d. \",\n                  res->buffer_pos, strerror(errno), w);\n      res->buffer_pos = 0;\n      errno = savederrno;\n      return OCS_CLOSE_CONNECTION;\n    }\n    pos += w;\n    ONION_DEBUG0(\"Write %d-%d bytes\", res->buffer_pos, w);\n    res->buffer_pos -= w;\n  }\n  if (res->flags & OR_CHUNKED) {\n    write(req, \"\\r\\n\", 2);\n  }\n  res->buffer_pos = 0;\n  errno = savederrno;\n  return 0;\n}\n\n/// Writes a 0-ended string to the response.\n/// @ingroup response\nssize_t onion_response_write0(onion_response * res, const char *data) {\n  return onion_response_write(res, data, strlen(data));\n}\n\n/**\n * @short Writes the given string to the res, but encodes the data using html entities\n * @ingroup response\n *\n * The encoding mens that <code><html> whould become &lt;html&gt;</code>\n */\nssize_t onion_response_write_html_safe(onion_response * res, const char *data) {\n  char *tmp = onion_html_quote(data);\n  if (tmp) {\n    int r = onion_response_write0(res, tmp);\n    onion_low_free(tmp);\n    return r;\n  } else\n    return onion_response_write0(res, data);\n}\n\n/**\n * @short Writes some data to the response. Using sprintf format strings.\n * @memberof onion_response_t\n * @ingroup response\n */\nssize_t onion_response_printf(onion_response * res, const char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  ssize_t ret = onion_response_vprintf(res, fmt, ap);\n  va_end(ap);\n  return ret;\n}\n\n/**\n * @short Writes some data to the response. Using sprintf format strings. va_list args version\n * @ingroup response\n *\n * @param args va_list of arguments\n * @memberof onion_response_t\n */\nssize_t onion_response_vprintf(onion_response * res, const char *fmt,\n                               va_list args) {\n  char temp[512];\n  va_list argz;\n  int l;\n  va_copy(argz, args);\n  l = vsnprintf(temp, sizeof(temp), fmt, argz);\n  va_end(argz);\n  if (l < 0) {\n    ONION_ERROR(\"Invalid vprintf fmt\");\n    return -1;\n  } else if (l < sizeof(temp)) {\n    return onion_response_write(res, temp, l);\n  } else {\n    ssize_t s;\n    char *buf = onion_low_scalar_malloc(l + 1);\n    if (!buf) {\n      // this cannot happen, since onion_low_scalar_malloc\n      // handles that error...\n      ONION_ERROR(\"Could not reserve %d bytes\", l + 1);\n      return -1;\n    }\n    vsnprintf(buf, l + 1, fmt, args);\n    s = onion_response_write(res, buf, l);\n    onion_low_free(buf);\n    return s;\n  }\n}\n\n/**\n * @short Returns a const char * string with the code description.\n * @memberof onion_response_t\n * @ingroup response\n */\nconst char *onion_response_code_description(int code) {\n  switch (code) {\n  case HTTP_OK:\n    return \"OK\";\n  case HTTP_CREATED:\n    return \"Created\";\n  case HTTP_PARTIAL_CONTENT:\n    return \"Partial Content\";\n  case HTTP_MULTI_STATUS:\n    return \"Multi-Status\";\n\n  case HTTP_SWITCH_PROTOCOL:\n    return \"Switching Protocols\";\n\n  case HTTP_MOVED:\n    return \"Moved Permanently\";\n  case HTTP_REDIRECT:\n    return \"Found\";\n  case HTTP_SEE_OTHER:\n    return \"See Other\";\n  case HTTP_NOT_MODIFIED:\n    return \"Not Modified\";\n  case HTTP_TEMPORARY_REDIRECT:\n    return \"Temporary Redirect\";\n\n  case HTTP_BAD_REQUEST:\n    return \"Bad Request\";\n  case HTTP_UNAUTHORIZED:\n    return \"Unauthorized\";\n  case HTTP_FORBIDDEN:\n    return \"Forbidden\";\n  case HTTP_NOT_FOUND:\n    return \"Not Found\";\n  case HTTP_METHOD_NOT_ALLOWED:\n    return \"Method Not Allowed\";\n  case HTTP_RANGE_NOT_SATISFIABLE:\n    return \"Range Not Satisfiable\";\n  case HTTP_IM_A_TEAPOT:\n    return \"I'm a teapot\";\n\n  case HTTP_INTERNAL_ERROR:\n    return \"Internal Server Error\";\n  case HTTP_NOT_IMPLEMENTED:\n    return \"Not Implemented\";\n  case HTTP_BAD_GATEWAY:\n    return \"Bad Gateway\";\n  case HTTP_SERVICE_UNAVAILABLE:\n    return \"Service Unavailable\";\n  }\n  return \"CODE UNKNOWN\";\n}\n\n/**\n * @short Returns the headers dictionary, so user can add repeated headers\n * @ingroup response\n *\n * Only simple use case is to add several coockies; using normal set_header is not possible,\n * but accessing the dictionary user can add repeated headers without problem.\n */\nonion_dict *onion_response_get_headers(onion_response * res) {\n  return res->headers;\n}\n\n/**\n * @short Sets a new cookie into the response.\n * @ingroup response\n *\n * @param res Response object\n * @param cookiename Name for the cookie\n * @param cookievalue Value for the cookies\n * @param validity_t Seconds this cookie is valid (added to current datetime). -1 to do not expire, 0 to expire immediately.\n * @param path Cookie valid only for this path\n * @param Domain Cookie valid only for this domain (www.example.com, or *.example.com).\n * @param flags Flags from onion_cookie_flags_t, for example OC_SECURE or OC_HTTP_ONLY\n *\n * @returns boolean indicating succesfully added the cookie or not.\n *\n * If validity is 0, cookie is set to expire right now.\n *\n * If the cookie is too long (all data > 4096), it is not added. A warning is\n * emmited and returns false.\n */\nbool onion_response_add_cookie(onion_response * res, const char *cookiename,\n                               const char *cookievalue, time_t validity_t,\n                               const char *path, const char *domain,\n                               int flags) {\n  char data[4096];\n  int pos;\n  pos = snprintf(data, sizeof(data), \"%s=%s\", cookiename, cookievalue);\n  if (validity_t == 0)\n    pos +=\n        snprintf(data + pos, sizeof(data) - pos,\n                 \"; expires=Thu, 01 Jan 1970 00:00:00 GMT\");\n  else if (validity_t > 0) {\n    struct tm *tmp;\n    time_t t = time(NULL) + validity_t;\n    tmp = localtime(&t);\n    pos +=\n        strftime(data + pos, sizeof(data) - pos,\n                 \"; expires=%a, %d %b %Y %H:%M:%S %Z\", tmp);\n  }\n  if (path)\n    pos += snprintf(data + pos, sizeof(data) - pos, \"; path=%s\", path);\n  if (domain)\n    pos += snprintf(data + pos, sizeof(data) - pos, \"; domain=%s\", domain);\n  if (flags & OC_HTTP_ONLY)\n    pos += snprintf(data + pos, sizeof(data) - pos, \"; HttpOnly\");\n  if (flags & OC_SECURE)\n    pos += snprintf(data + pos, sizeof(data) - pos, \"; Secure\");\n\n  switch (flags & (OC_SAMESITE_NONE | OC_SAMESITE_LAX | OC_SAMESITE_STRICT)) {\n  case OC_SAMESITE_NONE:\n    pos+=snprintf(data+pos, sizeof(data)-pos, \"; SameSite=None\");\n    break;\n  case OC_SAMESITE_LAX:\n    pos+=snprintf(data+pos, sizeof(data)-pos, \"; SameSite=Lax\");\n    break;\n  case OC_SAMESITE_STRICT:\n    pos+=snprintf(data+pos, sizeof(data)-pos, \"; SameSite=Strict\");\n    break;\n  default:\n    break;\n  }\n\n  if (pos >= sizeof(data)) {\n    ONION_WARNING(\"Cookie too long to be constructed. Not added to response.\");\n    return false;\n  }\n\n  onion_response_set_header(res, \"Set-Cookie\", data);\n  ONION_DEBUG(\"Set cookie %s\", data);\n\n  return true;\n}\n"], "fixing_code": ["/**\n  Onion HTTP server library\n  Copyright (C) 2010-2018 David Moreno Montero and others\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of, at your choice:\n\n  a. the Apache License Version 2.0.\n\n  b. the GNU General Public License as published by the\n  Free Software Foundation; either version 2.0 of the License,\n  or (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of both licenses, if not see\n  <http://www.gnu.org/licenses/> and\n  <http://www.apache.org/licenses/LICENSE-2.0>.\n*/\n\n#ifndef ONION_LOW_UTIL_H\n#define ONION_LOW_UTIL_H\n\n/**\n * @defgroup low Low level. Basic OS functions that can be exchanged for alternative implementations (Boehm GC.)\n *\n * File low.h provides low level utilities, notably wrapping\n * memory allocation and thread creation. Adventurous users could even\n * customize them during early initialization, e.g. when using Hans\n * Boehm conservative garbage collector from http://hboehm.info/gc/ or\n * when using their own malloc variant so we specialize general data -\n * which might contain pointers and could be allocated with GC_MALLOC\n * into scalar data which is guaranteed to be pointer free and could\n * be allocated with GC_MALLOC_ATOMIC ...\n *\n * If your server does not use an alternative implementation, feel free not\n * to use this functions, but if it might use it, please use them.\n */\n\n#include <stdlib.h>\n#include <signal.h>\n#include <pthread.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n  * @short A portable macro for declaring thread-local variables.\n  * @ingroup low\n  * @{\n  *\n  * This macro should be used instead of C11-and-newer's _Thread_local \n  * and GCC's __thread for portability's sake.\n  */\n  #if __STDC_VERSION__ >= 201112 && !defined(__STDC_NO_THREADS__)\n  # define ONION_THREAD_LOCAL _Thread_local\n  #elif defined(_WIN32) && ( \\\n   defined(_MSC_VER) || \\\n   defined(__ICL) || \\\n   defined(__DMC__) || \\\n   defined(__BORLANDC__) \\\n  )\n  # define ONION_THREAD_LOCAL __declspec(thread)\n  #elif defined(__TINYC__) || defined (__SDCC) || defined (__CC65__) || defined (__TenDRA__) /* Might apply to other compilers. From a brief glance PCC supports __thread. */\n  # error You are using an obsolete compiler that does not support thread-local variables. Onion will not compile. Consider using a different compiler.\n  #else\n  # define ONION_THREAD_LOCAL __thread\n  #endif\n/// @}\n\n/**\n * @short MACROS FOR CALLING A FUNCTION ONCE AT MOST EVERY X SECONDS IN EACH THREAD.\n * @{\n * \n * This is especially useful for preventing log-spamming, and possible DoS attacks\n * that can happen as a consequence of threads having to write out a massive log.\n * To use them you MUST include <time.h>.\n */\n/**\n * @short Call a function once at most every X seconds in each thread - don't count or pass the calls that happened in between.\n * @ingroup low\n */\n#define ONION_CALL_MAX_ONCE_PER_T(seconds, func, ...) do { \\\n  static ONION_THREAD_LOCAL time_t last_func_call = 0; \\\n  if (difftime(time(0), last_func_call) >= seconds) { \\\n    func(__VA_ARGS__); \\\n    time(&last_func_call); \\\n  } \\\n} while (0)\n/**\n * @short Call a function once at most every X seconds in each thread and pass the number of ignored calls + 1 as the last argument (an unsigned int).\n * @ingroup low\n */\n#define ONION_CALL_MAX_ONCE_PER_T_COUNT(seconds, func, ...) do { \\\n  static ONION_THREAD_LOCAL time_t last_func_call = 0; \\\n  static ONION_THREAD_LOCAL unsigned int func_calls_since = 0; \\\n  if (difftime(time(0), last_func_call) >= seconds) { \\\n    func(__VA_ARGS__, func_calls_since + 1); \\\n    func_calls_since = 0; \\\n    time(&last_func_call); \\\n  } \\\n  else \\\n    ++func_calls_since; \\\n} while (0)\n/// @}\n\n/**\n * @short NEVER FAILING MEMORY ALLOCATORS\n * @{\n *\n * These allocators should not fail: if memory is exhausted, they\n * invoke the memory failure routine then abort with a short\n * failure message.\n */\n/**\n * @short Our malloc wrapper for any kind of data, including data containing pointers.\n * @ingroup low\n */\n  void *onion_low_malloc(size_t sz);\n\n/**\n * @short Our malloc wrapper for scalar data which does not contain any pointers inside.\n * @ingroup low\n *\n * Knowing that a given zone does not contain any pointer can be useful, e.g. to Hans Boehm's conservative garbage\n * collector on http://hboehm.info/gc/ using GC_MALLOC_ATOMIC....\n */\n  void *onion_low_scalar_malloc(size_t sz);\n\n/// @short Our calloc wrapper for any kind of data, even scalar one.\n/// @ingroup low\n  void *onion_low_calloc(size_t nmemb, size_t size);\n\n/// @short Our realloc wrapper for any kind of data, even scalar one.\n/// @ingroup low\n  void *onion_low_realloc(void *ptr, size_t size);\n\n/// @short Our strdup wrapper.\n/// @ingroup low\n  char *onion_low_strdup(const char *str);\n\n/// @}\n\n/**\n * @short POSSIBLY FAILING MEMORY ALLOCATORS\n * @{\n *\n * These allocators could fail by returning NULL. Their caller is\n * requested to handle that failure.\n */\n\n/// @short Our malloc wrapper for any kind of data, including data containing pointers. May return NULL on fail.\n/// @ingroup low\n  void *onion_low_try_malloc(size_t sz);\n\n/// @short Our malloc wrapper for scalar data which does not contain any pointers inside.  May return NULL on fail.\n/// @ingroup low\n  void *onion_low_try_scalar_malloc(size_t sz);\n\n/// @short Our calloc wrapper for any kind of data, even scalar one.  May return NULL on fail.\n/// @ingroup low\n  void *onion_low_try_calloc(size_t nmemb, size_t size);\n\n/// @short Our realloc wrapper for any kind of data, even scalar one. May return NULL on fail.\n/// @ingroup low\n  void *onion_low_try_realloc(void *ptr, size_t size);\n\n/// @short Our strdup wrapper. May return NULL on fail.\n/// @ingroup low\n  char *onion_low_try_strdup(const char *str);\n\n  /******** FREE WRAPPER ******/\n/// @short Our free wrapper for any kind of data, even scalar one.\n/// @ingroup low\n  void onion_low_free(void *ptr);\n\n// @}\n\n/// @short Signatures of user configurable memory routine replacement.  @{\n/// @ingroup low\n  typedef void *onion_low_malloc_sigt(size_t sz);\n  typedef void *onion_low_scalar_malloc_sigt(size_t sz);\n  typedef void *onion_low_calloc_sigt(size_t nmemb, size_t size);\n  typedef void *onion_low_realloc_sigt(void *ptr, size_t size);\n  typedef char *onion_low_strdup_sigt(const char *ptr);\n  typedef void onion_low_free_sigt(void *ptr);\n\n/**\n * @short The memory failure handler is called with a short message.\n * @ingroup low\n *\n * It generally should not return, i.e. should exit, abort, or perhaps\n * setjmp....\n */\n  typedef void onion_low_memoryfailure_sigt(const char *msg);\n/// @}\n\n/**\n * @short Our configurator for memory routines.\n * @ingroup low\n *\n * To be called once before any other onion processing at initialization.\n * All the routines should be explicitly provided.\n */\n  void onion_low_initialize_memory_allocation\n      (onion_low_malloc_sigt * mallocrout,\n       onion_low_scalar_malloc_sigt * scalarmallocrout,\n       onion_low_calloc_sigt * callocrout,\n       onion_low_realloc_sigt * reallocrout,\n       onion_low_strdup_sigt * strduprout,\n       onion_low_free_sigt * freerout,\n       onion_low_memoryfailure_sigt * memoryfailurerout);\n\n/**\n * @short Configuration for pthread creation and management.\n * @ingroup low\n * @{\n * We also offer a mean to wrap thread creation, join, cancel,\n * detach, exit. This is needed for Boehm's garbage collector -\n * which has GC_pthread_create, GC_pthread_join, ... and could be\n * useful to others, e.g. for calling pthread_setname_np on Linux\n * system.  There is no need to wrap mutexes... The wrapper functions\n * can fail and their caller is expected to check for failure.\n */\n#ifdef HAVE_PTHREADS\n  int onion_low_pthread_create(pthread_t * thread,\n                               const pthread_attr_t * attr,\n                               void *(*start_routine) (void *), void *arg);\n  typedef int onion_low_pthread_create_sigt(pthread_t * thread,\n                                            const pthread_attr_t * attr,\n                                            void *(*start_routine) (void *),\n                                            void *arg);\n\n  int onion_low_pthread_join(pthread_t thread, void **retval);\n  typedef int onion_low_pthread_join_sigt(pthread_t thread, void **retval);\n\n  int onion_low_pthread_cancel(pthread_t thread);\n  typedef int onion_low_pthread_cancel_sigt(pthread_t thread);\n\n  int onion_low_pthread_detach(pthread_t thread);\n  typedef int onion_low_pthread_detach_sigt(pthread_t thread);\n\n  void onion_low_pthread_exit(void *retval);\n  typedef void onion_low_pthread_exit_sigt(void *retval);\n\n  int onion_low_pthread_sigmask(int how, const sigset_t * set,\n                                sigset_t * oldset);\n  typedef int onion_low_pthread_sigmask_sigt(int how, const sigset_t * set,\n                                             sigset_t * oldset);\n\n/**\n * @short Our configurator for pthread wrapping.\n * @ingroup low\n *\n * Every routine should be provided. This initialization should happen early,\n * at the same time as onion_low_initialize_memory_allocation, and before any\n * other onion calls. If using Boehm GC you probably want to pass\n * GC_pthread_create, GC_pthread_join, etc, etc...\n */\n  void onion_low_initialize_threads\n      (onion_low_pthread_create_sigt * thrcreator,\n       onion_low_pthread_join_sigt * thrjoiner,\n       onion_low_pthread_cancel_sigt * thrcanceler,\n       onion_low_pthread_detach_sigt * thrdetacher,\n       onion_low_pthread_exit_sigt * threxiter,\n       onion_low_pthread_sigmask_sigt * thrsigmasker);\n/// @}\n#endif                          /*HAVE_PTHREADS */\n\n#ifdef __cplusplus\n}                               /* end extern \"C\" */\n#endif\n#endif                          /*ONION_LOW_UTIL_H */\n", "/**\n  Onion HTTP server library\n  Copyright (C) 2010-2021 David Moreno Montero and others\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of, at your choice:\n\n  a. the Apache License Version 2.0.\n\n  b. the GNU General Public License as published by the\n  Free Software Foundation; either version 2.0 of the License,\n  or (at your option) any later version.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of both licenses, if not see\n  <http://www.gnu.org/licenses/> and\n  <http://www.apache.org/licenses/LICENSE-2.0>.\n*/\n\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <time.h>\n#include <stdarg.h>\n#include <assert.h>\n#include <errno.h>\n\n#ifdef HAVE_PTHREADS\n#include <pthread.h>\n#endif\n\n#include \"dict.h\"\n#include \"request.h\"\n#include \"response.h\"\n#include \"types_internal.h\"\n#include \"log.h\"\n#include \"codecs.h\"\n#include \"low.h\"\n\n/// @defgroup response Response. Write response data to client: headers, content body...\n\nconst char *onion_response_code_description(int code);\n\n// DONT_USE_DATE_HEADER is not defined anywhere, but here just in case needed in the future.\n\n#ifndef DONT_USE_DATE_HEADER\nstatic volatile time_t onion_response_last_time = 0;\nstatic char *onion_response_last_date_header = NULL;\n#ifdef HAVE_PTHREADS\npthread_rwlock_t onion_response_date_lock = PTHREAD_RWLOCK_INITIALIZER;\n#endif\n#endif\n\n/**\n * @short Generates a new response object\n * @memberof onion_response_t\n * @ingroup response\n *\n * This response is generated from a request, and gets from there the writer and writer data.\n *\n * Also fills some important data, as server Id, License type, and the default content type.\n *\n * Default content type is HTML, as normally this is what is needed. This is nontheless just\n * the default, and can be changed to any other with a call to:\n *\n *   onion_response_set_header(res, \"Content-Type\", my_type);\n *\n * The response object must be freed with onion_response_free, which also returns the keep alive\n * status.\n *\n * onion_response objects are passed by onion internally to process the request, and should not be\n * created by user normally. Nontheless the option exist.\n *\n * @returns An onion_response object for that request.\n */\nonion_response *onion_response_new(onion_request * req) {\n  onion_response *res = onion_low_malloc(sizeof(onion_response));\n\n  res->request = req;\n  res->headers = onion_dict_new();\n  res->code = 200;              // The most normal code, so no need to overwrite it in other codes.\n  res->flags = 0;\n  res->sent_bytes_total = res->length = res->sent_bytes = 0;\n  res->buffer_pos = 0;\n\n#ifndef DONT_USE_DATE_HEADER\n  {\n    time_t t;\n    struct tm tmp;\n\n    t = time(NULL);\n\n    // onion_response_last_date_header is set to t later. It should be more or less atomic.\n    // If not no big deal, as we will just use slightly more CPU on those \"ephemeral\" moments.\n\n    time_t current = __sync_add_and_fetch(&onion_response_last_time, 0);\n\n    if (t != current) {\n      ONION_DEBUG(\"Recalculating date header\");\n      char current_datetime[200];\n\n      if (localtime_r(&t, &tmp) == NULL) {\n        perror(\"localtime\");\n        exit(EXIT_FAILURE);\n      }\n\n      if (strftime\n          (current_datetime, sizeof(current_datetime),\n           \"%a, %d %b %Y %H:%M:%S %Z\", &tmp) == 0) {\n        fprintf(stderr, \"strftime returned 0\");\n        exit(EXIT_FAILURE);\n      }\n#ifdef HAVE_PTHREADS\n      pthread_rwlock_wrlock(&onion_response_date_lock);\n#endif\n      __sync_bool_compare_and_swap(&onion_response_last_time, current, t);\n      if (onion_response_last_date_header)\n        onion_low_free(onion_response_last_date_header);\n      onion_response_last_date_header = onion_low_strdup(current_datetime);\n#ifdef HAVE_PTHREADS\n      pthread_rwlock_unlock(&onion_response_date_lock);\n#endif\n    }\n  }\n#ifdef HAVE_PTHREADS\n  pthread_rwlock_rdlock(&onion_response_date_lock);\n#endif\n  assert(onion_response_last_date_header);\n  onion_dict_add(res->headers, \"Date\", onion_response_last_date_header,\n                 OD_DUP_VALUE);\n#ifdef HAVE_PTHREADS\n  pthread_rwlock_unlock(&onion_response_date_lock);\n#endif\n#endif                          // USE_DATE_HEADER\n  // Sorry for the advertisment.\n  onion_dict_add(res->headers, \"Server\",\n                 \"libonion v\" ONION_VERSION \" - coralbits.com\", 0);\n  onion_dict_add(res->headers, \"Content-Type\", \"text/html\", 0); // Maybe not the best guess, but really useful.\n  //time_t t=time(NULL);\n  //onion_dict_add(res->headers, \"Date\", asctime(localtime(&t)), OD_DUP_VALUE);\n\n  return res;\n}\n\n/**\n * @short Frees the memory consumed by this object\n * @memberof onion_response_t\n * @ingroup response\n *\n * This function returns the close status: OR_KEEP_ALIVE or OR_CLOSE_CONNECTION as needed.\n *\n * @returns Whether the connection should be closed or not, or an error status to be handled by server.\n * @see onion_connection_status\n */\nonion_connection_status onion_response_free(onion_response * res) {\n  // write pending data.\n  if (!(res->flags & OR_HEADER_SENT) && res->buffer_pos < sizeof(res->buffer))\n    onion_response_set_length(res, res->buffer_pos);\n\n  if (!(res->flags & OR_HEADER_SENT))\n    onion_response_write_headers(res);\n\n  onion_response_flush(res);\n  onion_request *req = res->request;\n\n  if (res->flags & OR_CHUNKED) {        // Set the chunked data end.\n    req->connection.listen_point->write(req, \"0\\r\\n\\r\\n\", 5);\n  }\n\n  int r = OCS_CLOSE_CONNECTION;\n\n  // it is a rare ocasion that there is no request, but although unlikely, it may happen\n  if (req) {\n    // keep alive only on HTTP/1.1.\n    ONION_DEBUG0\n        (\"keep alive [req wants] %d && ([skip] %d || [lenght ok] %d==%d || [chunked] %d)\",\n         onion_request_keep_alive(req), res->flags & OR_SKIP_CONTENT,\n         res->length, res->sent_bytes, res->flags & OR_CHUNKED);\n    if (onion_request_keep_alive(req)\n        && (res->flags & OR_SKIP_CONTENT || res->length == res->sent_bytes\n            || res->flags & OR_CHUNKED)\n        )\n      r = OCS_KEEP_ALIVE;\n\n    if ((onion_log_flags & OF_NOINFO) != OF_NOINFO)\n      // FIXME! This is no proper logging at all. Maybe use a handler.\n      ONION_INFO(\"[%s] \\\"%s %s\\\" %d %d (%s)\",\n                 onion_request_get_client_description(res->request),\n                 onion_request_methods[res->request->flags & OR_METHODS],\n                 res->request->fullpath, res->code, res->sent_bytes,\n                 (r == OCS_KEEP_ALIVE) ? \"Keep-Alive\" : \"Close connection\");\n  }\n\n  onion_dict_free(res->headers);\n  onion_low_free(res);\n\n  return r;\n}\n\n/**\n * @short Adds a header to the response object\n * @memberof onion_response_t\n * @ingroup response\n */\nvoid onion_response_set_header(onion_response * res, const char *key,\n                               const char *value) {\n  ONION_DEBUG0(\"Adding header %s = %s\", key, value);\n  onion_dict_add(res->headers, key, value, OD_DUP_ALL | OD_REPLACE);    // DUP_ALL not so nice on memory side...\n}\n\n/**\n * @short Sets the header length. Normally it should be through set_header, but as its very common and needs some procesing here is a shortcut\n * @memberof onion_response_t\n * @ingroup response\n */\nvoid onion_response_set_length(onion_response * res, size_t len) {\n  if (len != res->sent_bytes && res->flags & OR_HEADER_SENT) {\n    ONION_WARNING\n        (\"Trying to set length after headers sent. Undefined onion behaviour.\");\n    return;\n  }\n  char tmp[16];\n  sprintf(tmp, \"%lu\", (unsigned long)len);\n  onion_response_set_header(res, \"Content-Length\", tmp);\n  res->length = len;\n  res->flags |= OR_LENGTH_SET;\n}\n\n/**\n * @short Sets the return code\n * @memberof onion_response_t\n * @ingroup response\n */\nvoid onion_response_set_code(onion_response * res, int code) {\n  res->code = code;\n}\n\n/**\n * @short Helper that is called on each header, and writes the header\n * @memberof onion_response_t\n * @ingroup response\n */\nstatic void write_header(onion_response * res, const char *key,\n                         const char *value, int flags) {\n  //ONION_DEBUG0(\"Response header: %s: %s\",key, value);\n\n  onion_response_write0(res, key);\n  onion_response_write(res, \": \", 2);\n  onion_response_write0(res, value);\n  onion_response_write(res, \"\\r\\n\", 2);\n}\n\n#define CONNECTION_CLOSE \"Connection: Close\\r\\n\"\n#define CONNECTION_KEEP_ALIVE \"Connection: Keep-Alive\\r\\n\"\n#define CONNECTION_CHUNK_ENCODING \"Transfer-Encoding: chunked\\r\\n\"\n#define CONNECTION_UPGRADE \"Connection: Upgrade\\r\\n\"\n\n/**\n * @short Writes all the header to the given response\n * @memberof onion_response_t\n * @ingroup response\n *\n * It writes the headers and depending on the method, return OR_SKIP_CONTENT. this is set when in head mode. Handlers\n * should react to this return by not trying to write more, but if they try this object will just skip those writtings.\n *\n * Explicit calling to this function is not necessary, as as soon as the user calls any write function this will\n * be performed.\n *\n * As soon as the headers are written, any modification on them will be just ignored.\n *\n * @returns 0 if should procced to normal data write, or OR_SKIP_CONTENT if should not write content.\n */\nint onion_response_write_headers(onion_response * res) {\n  if (!res->request) {\n    ONION_ERROR\n        (\"Bad formed response. Need a request at creation. Will not write headers.\");\n    return -1;\n  }\n\n  res->flags |= OR_HEADER_SENT; // I Set at the begining so I can do normal writing.\n  res->request->flags |= OR_HEADER_SENT;\n  char chunked = 0;\n\n  if (res->request->flags & OR_HTTP11) {\n    onion_response_printf(res, \"HTTP/1.1 %d %s\\r\\n\", res->code,\n                          onion_response_code_description(res->code));\n    //ONION_DEBUG(\"Response header: HTTP/1.1 %d %s\\n\",res->code, onion_response_code_description(res->code));\n    if (!(res->flags & OR_LENGTH_SET) && onion_request_keep_alive(res->request)) {\n      onion_response_write(res, CONNECTION_CHUNK_ENCODING,\n                           sizeof(CONNECTION_CHUNK_ENCODING) - 1);\n      chunked = 1;\n    }\n  } else {\n    onion_response_printf(res, \"HTTP/1.0 %d %s\\r\\n\", res->code,\n                          onion_response_code_description(res->code));\n    //ONION_DEBUG(\"Response header: HTTP/1.0 %d %s\\n\",res->code, onion_response_code_description(res->code));\n    if (res->flags & OR_LENGTH_SET)     // On HTTP/1.0, i need to state it. On 1.1 it is default.\n      onion_response_write(res, CONNECTION_KEEP_ALIVE,\n                           sizeof(CONNECTION_KEEP_ALIVE) - 1);\n  }\n\n  if (!(res->flags & OR_LENGTH_SET) && !chunked\n      && !(res->flags & OR_CONNECTION_UPGRADE))\n    onion_response_write(res, CONNECTION_CLOSE, sizeof(CONNECTION_CLOSE) - 1);\n\n  if (res->flags & OR_CONNECTION_UPGRADE)\n    onion_response_write(res, CONNECTION_UPGRADE,\n                         sizeof(CONNECTION_UPGRADE) - 1);\n\n  onion_dict_preorder(res->headers, write_header, res);\n\n  if (res->request->session_id && (onion_dict_count(res->request->session) > 0))        // I have session with something, tell user\n    onion_response_printf(res, \"Set-Cookie: sessionid=%s; httponly; Path=/\\n\",\n                          res->request->session_id);\n\n  onion_response_write(res, \"\\r\\n\", 2);\n\n  ONION_DEBUG0(\"Headers written\");\n  res->sent_bytes = -res->buffer_pos;   // the header size is not counted here. It will add again so start negative.\n\n  if ((res->request->flags & OR_METHODS) == OR_HEAD) {\n    onion_response_flush(res);\n    res->flags |= OR_SKIP_CONTENT;\n    return OR_SKIP_CONTENT;\n  }\n  if (chunked) {\n    onion_response_flush(res);\n    res->flags |= OR_CHUNKED;\n  }\n\n  return 0;\n}\n\n/**\n * @short Write some response data.\n * @memberof onion_response_t\n * @ingroup response\n *\n * This is the main write data function. If the headers have not been sent yet, they are now.\n *\n * It's internally used also by the write0 and printf versions.\n *\n * Also it does some buffering, so data is not sent as written by code, but only in chunks.\n * These chunks are when the response is finished, or when the internal buffer is full. This\n * helps performance, and eases the programming on the user side.\n *\n * If length is 0, forces the write of pending data.\n *\n * @returns The bytes written, normally just length. On error returns OCS_CLOSE_CONNECTION.\n */\nssize_t onion_response_write(onion_response * res, const char *data,\n                             size_t length) {\n  if (res->flags & OR_SKIP_CONTENT) {\n    if (!(res->flags & OR_HEADER_SENT)) {       // Automatic header write\n      onion_response_write_headers(res);\n    }\n    ONION_DEBUG(\"Skipping content as we are in HEAD mode\");\n    return OCS_CLOSE_CONNECTION;\n  }\n  if (length == 0) {\n    onion_response_flush(res);\n    return 0;\n  }\n  //ONION_DEBUG0(\"Write %d bytes [%d total] (%p)\", length, res->sent_bytes, res);\n\n  int l = length;\n  int w = 0;\n  while (res->buffer_pos + l > sizeof(res->buffer)) {\n    int wb = sizeof(res->buffer) - res->buffer_pos;\n    memcpy(&res->buffer[res->buffer_pos], data, wb);\n\n    res->buffer_pos = sizeof(res->buffer);\n    if (onion_response_flush(res) < 0)\n      return w;\n\n    l -= wb;\n    data += wb;\n    w += wb;\n  }\n\n  memcpy(&res->buffer[res->buffer_pos], data, l);\n  res->buffer_pos += l;\n  w += l;\n\n  return w;\n}\n\n/**\n * @short Writes all buffered output waiting for sending.\n * @ingroup response\n *\n * If header has not been sent yet (delayed), it uses a temporary buffer to send it now. This\n * way header can use the buffer_size information to send the proper content-length, even when it\n * wasnt properly set by programmer. Whith this information its possib to keep alive the connection\n * on more cases.\n */\nint onion_response_flush(onion_response * res) {\n  res->sent_bytes += res->buffer_pos;\n  res->sent_bytes_total += res->buffer_pos;\n  if (res->buffer_pos == 0)     // Not used.\n    return 0;\n  if (!(res->flags & OR_HEADER_SENT)) { // Automatic header write\n    ONION_DEBUG0\n        (\"Doing fast header hack: store current buffer, send current headers. Resend buffer.\");\n    char tmpb[sizeof(res->buffer)];\n    int tmpp = res->buffer_pos;\n    memcpy(tmpb, res->buffer, res->buffer_pos);\n    res->buffer_pos = 0;\n\n    onion_response_write_headers(res);\n    onion_response_write(res, tmpb, tmpp);\n    return 0;\n  }\n  if (res->flags & OR_SKIP_CONTENT)     // HEAD request\n    return 0;\n  ONION_DEBUG0(\"Flush %d bytes\", res->buffer_pos);\n\n  onion_request *req = res->request;\n  ssize_t(*write) (onion_request *, const char *data, size_t len);\n  write = req->connection.listen_point->write;\n\n  ssize_t w;\n  off_t pos = 0;\n  //ONION_DEBUG0(\"Write %d bytes\",res->buffer_pos);\n  if (res->flags & OR_CHUNKED) {\n    char tmp[16];\n    snprintf(tmp, sizeof(tmp), \"%X\\r\\n\", (unsigned int)res->buffer_pos);\n    if ((w = write(req, tmp, strlen(tmp))) <= 0) {\n      ONION_CALL_MAX_ONCE_PER_T_COUNT(1, ONION_WARNING, \"Error writing chunk encoding length (%X) %s. Aborting write. (x%u)\",\n        (unsigned int)res->buffer_pos, strerror(errno));\n      \n      return OCS_CLOSE_CONNECTION;\n    }\n    ONION_DEBUG0(\"Write %d-%d bytes\", res->buffer_pos, w);\n  }\n  int savederrno = errno;\n  errno = 0;\n  while ((w =\n          write(req, &res->buffer[pos], res->buffer_pos)) != res->buffer_pos) {\n    if (w <= 0 || res->buffer_pos < 0) {\n      ONION_ERROR(\"Error writing %d bytes (%s). Maybe closed connection. Code %d. \",\n                  res->buffer_pos, strerror(errno), w);\n      res->buffer_pos = 0;\n      errno = savederrno;\n      return OCS_CLOSE_CONNECTION;\n    }\n    pos += w;\n    ONION_DEBUG0(\"Write %d-%d bytes\", res->buffer_pos, w);\n    res->buffer_pos -= w;\n  }\n  if (res->flags & OR_CHUNKED) {\n    write(req, \"\\r\\n\", 2);\n  }\n  res->buffer_pos = 0;\n  errno = savederrno;\n  return 0;\n}\n\n/// Writes a 0-ended string to the response.\n/// @ingroup response\nssize_t onion_response_write0(onion_response * res, const char *data) {\n  return onion_response_write(res, data, strlen(data));\n}\n\n/**\n * @short Writes the given string to the res, but encodes the data using html entities\n * @ingroup response\n *\n * The encoding mens that <code><html> whould become &lt;html&gt;</code>\n */\nssize_t onion_response_write_html_safe(onion_response * res, const char *data) {\n  char *tmp = onion_html_quote(data);\n  if (tmp) {\n    int r = onion_response_write0(res, tmp);\n    onion_low_free(tmp);\n    return r;\n  } else\n    return onion_response_write0(res, data);\n}\n\n/**\n * @short Writes some data to the response. Using sprintf format strings.\n * @memberof onion_response_t\n * @ingroup response\n */\nssize_t onion_response_printf(onion_response * res, const char *fmt, ...) {\n  va_list ap;\n  va_start(ap, fmt);\n  ssize_t ret = onion_response_vprintf(res, fmt, ap);\n  va_end(ap);\n  return ret;\n}\n\n/**\n * @short Writes some data to the response. Using sprintf format strings. va_list args version\n * @ingroup response\n *\n * @param args va_list of arguments\n * @memberof onion_response_t\n */\nssize_t onion_response_vprintf(onion_response * res, const char *fmt,\n                               va_list args) {\n  char temp[512];\n  va_list argz;\n  int l;\n  va_copy(argz, args);\n  l = vsnprintf(temp, sizeof(temp), fmt, argz);\n  va_end(argz);\n  if (l < 0) {\n    ONION_ERROR(\"Invalid vprintf fmt\");\n    return -1;\n  } else if (l < sizeof(temp)) {\n    return onion_response_write(res, temp, l);\n  } else {\n    ssize_t s;\n    char *buf = onion_low_scalar_malloc(l + 1);\n    if (!buf) {\n      // this cannot happen, since onion_low_scalar_malloc\n      // handles that error...\n      ONION_ERROR(\"Could not reserve %d bytes\", l + 1);\n      return -1;\n    }\n    vsnprintf(buf, l + 1, fmt, args);\n    s = onion_response_write(res, buf, l);\n    onion_low_free(buf);\n    return s;\n  }\n}\n\n/**\n * @short Returns a const char * string with the code description.\n * @memberof onion_response_t\n * @ingroup response\n */\nconst char *onion_response_code_description(int code) {\n  switch (code) {\n  case HTTP_OK:\n    return \"OK\";\n  case HTTP_CREATED:\n    return \"Created\";\n  case HTTP_PARTIAL_CONTENT:\n    return \"Partial Content\";\n  case HTTP_MULTI_STATUS:\n    return \"Multi-Status\";\n\n  case HTTP_SWITCH_PROTOCOL:\n    return \"Switching Protocols\";\n\n  case HTTP_MOVED:\n    return \"Moved Permanently\";\n  case HTTP_REDIRECT:\n    return \"Found\";\n  case HTTP_SEE_OTHER:\n    return \"See Other\";\n  case HTTP_NOT_MODIFIED:\n    return \"Not Modified\";\n  case HTTP_TEMPORARY_REDIRECT:\n    return \"Temporary Redirect\";\n\n  case HTTP_BAD_REQUEST:\n    return \"Bad Request\";\n  case HTTP_UNAUTHORIZED:\n    return \"Unauthorized\";\n  case HTTP_FORBIDDEN:\n    return \"Forbidden\";\n  case HTTP_NOT_FOUND:\n    return \"Not Found\";\n  case HTTP_METHOD_NOT_ALLOWED:\n    return \"Method Not Allowed\";\n  case HTTP_RANGE_NOT_SATISFIABLE:\n    return \"Range Not Satisfiable\";\n  case HTTP_IM_A_TEAPOT:\n    return \"I'm a teapot\";\n\n  case HTTP_INTERNAL_ERROR:\n    return \"Internal Server Error\";\n  case HTTP_NOT_IMPLEMENTED:\n    return \"Not Implemented\";\n  case HTTP_BAD_GATEWAY:\n    return \"Bad Gateway\";\n  case HTTP_SERVICE_UNAVAILABLE:\n    return \"Service Unavailable\";\n  }\n  return \"CODE UNKNOWN\";\n}\n\n/**\n * @short Returns the headers dictionary, so user can add repeated headers\n * @ingroup response\n *\n * Only simple use case is to add several coockies; using normal set_header is not possible,\n * but accessing the dictionary user can add repeated headers without problem.\n */\nonion_dict *onion_response_get_headers(onion_response * res) {\n  return res->headers;\n}\n\n/**\n * @short Sets a new cookie into the response.\n * @ingroup response\n *\n * @param res Response object\n * @param cookiename Name for the cookie\n * @param cookievalue Value for the cookies\n * @param validity_t Seconds this cookie is valid (added to current datetime). -1 to do not expire, 0 to expire immediately.\n * @param path Cookie valid only for this path\n * @param Domain Cookie valid only for this domain (www.example.com, or *.example.com).\n * @param flags Flags from onion_cookie_flags_t, for example OC_SECURE or OC_HTTP_ONLY\n *\n * @returns boolean indicating succesfully added the cookie or not.\n *\n * If validity is 0, cookie is set to expire right now.\n *\n * If the cookie is too long (all data > 4096), it is not added. A warning is\n * emmited and returns false.\n */\nbool onion_response_add_cookie(onion_response * res, const char *cookiename,\n                               const char *cookievalue, time_t validity_t,\n                               const char *path, const char *domain,\n                               int flags) {\n  char data[4096];\n  int pos;\n  pos = snprintf(data, sizeof(data), \"%s=%s\", cookiename, cookievalue);\n  if (validity_t == 0)\n    pos +=\n        snprintf(data + pos, sizeof(data) - pos,\n                 \"; expires=Thu, 01 Jan 1970 00:00:00 GMT\");\n  else if (validity_t > 0) {\n    struct tm *tmp;\n    time_t t = time(NULL) + validity_t;\n    tmp = localtime(&t);\n    pos +=\n        strftime(data + pos, sizeof(data) - pos,\n                 \"; expires=%a, %d %b %Y %H:%M:%S %Z\", tmp);\n  }\n  if (path)\n    pos += snprintf(data + pos, sizeof(data) - pos, \"; path=%s\", path);\n  if (domain)\n    pos += snprintf(data + pos, sizeof(data) - pos, \"; domain=%s\", domain);\n  if (flags & OC_HTTP_ONLY)\n    pos += snprintf(data + pos, sizeof(data) - pos, \"; HttpOnly\");\n  if (flags & OC_SECURE)\n    pos += snprintf(data + pos, sizeof(data) - pos, \"; Secure\");\n\n  switch (flags & (OC_SAMESITE_NONE | OC_SAMESITE_LAX | OC_SAMESITE_STRICT)) {\n  case OC_SAMESITE_NONE:\n    pos+=snprintf(data+pos, sizeof(data)-pos, \"; SameSite=None\");\n    break;\n  case OC_SAMESITE_LAX:\n    pos+=snprintf(data+pos, sizeof(data)-pos, \"; SameSite=Lax\");\n    break;\n  case OC_SAMESITE_STRICT:\n    pos+=snprintf(data+pos, sizeof(data)-pos, \"; SameSite=Strict\");\n    break;\n  default:\n    break;\n  }\n\n  if (pos >= sizeof(data)) {\n    ONION_WARNING(\"Cookie too long to be constructed. Not added to response.\");\n    return false;\n  }\n\n  onion_response_set_header(res, \"Set-Cookie\", data);\n  ONION_DEBUG(\"Set cookie %s\", data);\n\n  return true;\n}\n"], "filenames": ["src/onion/low.h", "src/onion/response.c"], "buggy_code_start_loc": [51, 434], "buggy_code_end_loc": [51, 437], "fixing_code_start_loc": [52, 434], "fixing_code_end_loc": [112, 437], "type": "CWE-400", "message": "A vulnerability was found in davidmoreno onion. It has been rated as problematic. Affected by this issue is the function onion_response_flush of the file src/onion/response.c of the component Log Handler. The manipulation leads to allocation of resources. The name of the patch is de8ea938342b36c28024fd8393ebc27b8442a161. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-214028.", "other": {"cve": {"id": "CVE-2022-4066", "sourceIdentifier": "cna@vuldb.com", "published": "2022-11-19T19:15:10.547", "lastModified": "2022-11-28T13:41:30.543", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in davidmoreno onion. It has been rated as problematic. Affected by this issue is the function onion_response_flush of the file src/onion/response.c of the component Log Handler. The manipulation leads to allocation of resources. The name of the patch is de8ea938342b36c28024fd8393ebc27b8442a161. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-214028."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.2}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}, {"lang": "en", "value": "CWE-404"}, {"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:-:*:*:*:*:*:*:*", "matchCriteriaId": "97D4FFCF-5309-43B6-9FD5-680C6D535A7F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:onion_project:onion:*:*:*:*:*:*:*:*", "versionEndExcluding": "2022-09-05", "matchCriteriaId": "9ACA4272-A0A9-4C2A-A7A8-1EB99192303E"}]}]}], "references": [{"url": "https://github.com/davidmoreno/onion/commit/de8ea938342b36c28024fd8393ebc27b8442a161", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/davidmoreno/onion/pull/308", "source": "cna@vuldb.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.214028", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/davidmoreno/onion/commit/de8ea938342b36c28024fd8393ebc27b8442a161"}}