{"buggy_code": ["C Fix\\sthe\\sregexp\\sextension\\sso\\sthat\\sit\\scorrectly\\stranslates\\sall\\sover-length\\n3-byte\\sUTF8\\ssequences\\sinto\\s0xfffd.\nD 2019-12-19T21:11:48.622\nF .fossil-settings/empty-dirs dbb81e8fc0401ac46a1491ab34a7f2c7c0452f2f06b54ebb845d024ca8283ef1\nF .fossil-settings/ignore-glob 35175cdfcf539b2318cb04a9901442804be81cd677d8b889fcc9149c21f239ea\nF LICENSE.md df5091916dbb40e6e9686186587125e1b2ff51f022cc334e886c19a0e9982724\nF Makefile.in d3a862c9742f5a08230a3b295c0a47fd3067f19356dc39935280135f90474b04\nF Makefile.linux-gcc f609543700659711fbd230eced1f01353117621dccae7b9fb70daa64236c5241\nF Makefile.msc 0b0acbf34bb238170bdf1fd343a1fd37bc81c042ce029c1cc53fe15b5d4ed07b\nF README.md 1514a365ffca3c138e00c5cc839906108a01011a6b082bad19b09781e3aa498a\nF VERSION 081500f0aeaadc989d85aafbc717af45512018aebc73d89e5c2368fe62a600ff\nF aclocal.m4 a5c22d164aff7ed549d53a90fa56d56955281f50\nF art/sqlite370.eps aa97a671332b432a54e1d74ff5e8775be34200c2\nF art/sqlite370.ico af56c1d00fee7cd4753e8631ed60703ed0fc6e90\nF art/sqlite370.jpg d512473dae7e378a67e28ff96a34da7cb331def2\nF autoconf/INSTALL 83e4a25da9fd053c7b3665eaaaf7919707915903\nF autoconf/Makefile.am e14b629addaa1ce372b72043f28f40de2e32b7e211b6e0fc18dbb87989197e40\nF autoconf/Makefile.fallback 22fe523eb36dfce31e0f6349f782eb084e86a5620b2b0b4f84a2d6133f53f5ac\nF autoconf/Makefile.msc 492ea431c411378094593a5225b9a02645455a5d87a26d018b5461b723e52125\nF autoconf/README.first 6c4f34fe115ff55d4e8dbfa3cecf04a0188292f7\nF autoconf/README.txt 4f04b0819303aabaa35fff5f7b257fb0c1ef95f1\nF autoconf/configure.ac 308de24343e76ecfbe9a67f8fcd4c5216b790d230c5d9ce10210b7d5965d6192\nF autoconf/tea/Makefile.in b438a7020446c8a8156e8d97c8914a04833da6fd\nF autoconf/tea/README 3e9a3c060f29a44344ab50aec506f4db903fb873\nF autoconf/tea/aclocal.m4 52c47aac44ce0ddb1f918b6993e8beb8eee88f43\nF autoconf/tea/configure.ac 8aa16e3f0a5ca7959d4af198f46934ec187d395f\nF autoconf/tea/doc/sqlite3.n e1fe45d4f5286ee3d0ccc877aca2a0def488e9bb\nF autoconf/tea/license.terms 13bd403c9610fd2b76ece0ab50c4c5eda933d523\nF autoconf/tea/pkgIndex.tcl.in 3ef61715cf1c7bdcff56947ffadb26bc991ca39d\nF autoconf/tea/tclconfig/install-sh bdd5e293591621ae60d9824d86a4b1c5f22c3d00\nF autoconf/tea/tclconfig/tcl.m4 66ddf0a5d5e4b1d29bff472c0985fd7fa89d0fb5\nF autoconf/tea/win/makefile.vc f89d0184d0eee5f7e356ea407964dcd139939928\nF autoconf/tea/win/nmakehlp.c 247538ad8e8c508f33c03ec1fbd67d3a07ef6291\nF autoconf/tea/win/rules.vc c511f222b80064096b705dbeb97060ee1d6b6d63\nF config.guess 883205ddf25b46f10c181818bf42c09da9888884af96f79e1719264345053bd6\nF config.h.in 6376abec766e9a0785178b1823b5a587e9f1ccbc\nF config.sub c2d0260f17f3e4bc0b6808fccf1b291cb5e9126c14fc5890efc77b9fd0175559\nF configure fdc9f8d53360170679349d8f72fb2e5c79f511424891b7bb8a2f48de41c7a6ef x\nF configure.ac 3552d3aecade98a9d4b64bceb48ffb7726cbc85902efde956812942f060fbd0a\nF contrib/sqlitecon.tcl 210a913ad63f9f991070821e599d600bd913e0ad\nF doc/F2FS.txt c1d4a0ae9711cfe0e1d8b019d154f1c29e0d3abfe820787ba1e9ed7691160fcd\nF doc/lemon.html 24956ab2995e55fe171e55bdd04f22b553957dc8bb43501dbb9311e30187e0d3\nF doc/pager-invariants.txt 27fed9a70ddad2088750c4a2b493b63853da2710\nF doc/vfs-shm.txt e101f27ea02a8387ce46a05be2b1a902a021d37a\nF ext/README.md fd5f78013b0a2bc6f0067afb19e6ad040e89a10179b4f6f03eee58fac5f169bd\nF ext/async/README.txt e12275968f6fde133a80e04387d0e839b0c51f91\nF ext/async/sqlite3async.c 0f3070cc3f5ede78f2b9361fb3b629ce200d7d74\nF ext/async/sqlite3async.h f489b080af7e72aec0e1ee6f1d98ab6cf2e4dcef\nF ext/expert/README.md b321c2762bb93c18ea102d5a5f7753a4b8bac646cb392b3b437f633caf2020c3\nF ext/expert/expert.c d548d603a4cc9e61f446cc179c120c6713511c413f82a4a32b1e1e69d3f086a4\nF ext/expert/expert1.test e2afc53a27610e8251e44c7f961806607a5490ff204b3db342740d558e052662\nF ext/expert/sqlite3expert.c 3da865f2286433588260f41e796422c611bceaca3a0bbf9139a619cf7d062c19\nF ext/expert/sqlite3expert.h ca81efc2679a92373a13a3e76a6138d0310e32be53d6c3bfaedabd158ea8969b\nF ext/expert/test_expert.c d56c194b769bdc90cf829a14c9ecbc1edca9c850b837a4d0b13be14095c32a72\nF ext/fts1/README.txt 20ac73b006a70bcfd80069bdaf59214b6cf1db5e\nF ext/fts1/ft_hash.c 3927bd880e65329bdc6f506555b228b28924921b\nF ext/fts1/ft_hash.h 06df7bba40dadd19597aa400a875dbc2fed705ea\nF ext/fts1/fts1.c a39f7d21c2994d27c959ef9c3505c81542c81432\nF ext/fts1/fts1.h 6060b8f62c1d925ea8356cb1a6598073eb9159a6\nF ext/fts1/fts1_hash.c 3196cee866edbebb1c0521e21672e6d599965114\nF ext/fts1/fts1_hash.h e7f0d761353996a8175eda351104acfde23afcb0\nF ext/fts1/fts1_porter.c b1c7304b8988ba3f764a147cdd32043b4913ea7b\nF ext/fts1/fts1_tokenizer.h fdea722c38a9f82ed921642981234f666e47919c\nF ext/fts1/fts1_tokenizer1.c fd00d1fe4dc30dfc5c64cba695ce34f4af20d2fa\nF ext/fts1/fulltext.c 37698e1909584f6d8ea67d1485e3ad39dbf42d19\nF ext/fts1/fulltext.h 08525a47852d1d62a0be81d3fc3fe2d23b094efd\nF ext/fts1/simple_tokenizer.c bbfa4e3b2a26ef17d4edc6d98cd4a3f5396d998a\nF ext/fts1/tokenizer.h 0c53421b832366d20d720d21ea3e1f6e66a36ef9\nF ext/fts2/README.tokenizers 21e3684ea5a095b55d70f6878b4ce6af5932dfb7\nF ext/fts2/README.txt 8c18f41574404623b76917b9da66fcb0ab38328d\nF ext/fts2/fts2.c 72c816a9ae448049fbbe8f18a85698765fc7956c\nF ext/fts2/fts2.h da5f76c65163301d1068a971fd32f4119e3c95fa\nF ext/fts2/fts2_hash.c 011a1d32de45bb1b519a1fd0048e857d6a843558\nF ext/fts2/fts2_hash.h 1824b99dfd8d0225facbdb26a2c87289b2e7dcf8\nF ext/fts2/fts2_icu.c 51c5cd3c04954badd329fa738c95fcdb717b5188\nF ext/fts2/fts2_porter.c 2cd4a507bf3c3085fe66f59b0f2a325f65aaacf5\nF ext/fts2/fts2_tokenizer.c b529493d55e55497213c37e1f31680a77746be26\nF ext/fts2/fts2_tokenizer.h 27a1a99ca2d615cf7e142839b8d79e8751b4529e\nF ext/fts2/fts2_tokenizer1.c 07e223eecb483d448313b5f1553a4f299a7fb7a1\nF ext/fts2/mkfts2amal.tcl 974d5d438cb3f7c4a652639262f82418c1e4cff0\nF ext/fts3/README.content fdc666a70d5257a64fee209f97cf89e0e6e32b51\nF ext/fts3/README.syntax a19711dc5458c20734b8e485e75fb1981ec2427a\nF ext/fts3/README.tokenizers b92bdeb8b46503f0dd301d364efc5ef59ef9fa8e2758b8e742f39fa93a2e422d\nF ext/fts3/README.txt 8c18f41574404623b76917b9da66fcb0ab38328d\nF ext/fts3/fts3.c a05938725571651cc9bedc63a52ede4b39277fec17884c8ff6011dab2ff78c75\nF ext/fts3/fts3.h 3a10a0af180d502cecc50df77b1b22df142817fe\nF ext/fts3/fts3Int.h f091030b976045e7df91af2337935952b477cdbd9f48058c44c965684484cb50\nF ext/fts3/fts3_aux.c 96708c8b3a7d9b8ca1b68ea2b7e503e283f20e95f145becadedfad096dbd0f34\nF ext/fts3/fts3_expr.c b132af223e90e35b9f9efa9fe63d6ae737d34153a3b6066736086df8abc78a1f\nF ext/fts3/fts3_hash.c 8b6e31bfb0844c27dc6092c2620bdb1fca17ed613072db057d96952c6bdb48b7\nF ext/fts3/fts3_hash.h 39cf6874dc239d6b4e30479b1975fe5b22a3caaf\nF ext/fts3/fts3_icu.c 305ce7fb6036484085b5556a9c8e62acdc7763f0f4cdf5fd538212a9f3720116\nF ext/fts3/fts3_porter.c 3565faf04b626cddf85f03825e86056a4562c009\nF ext/fts3/fts3_snippet.c d62e40baa6a200586c3a425478109418f44926b1c318c870b59a4286afbe2795\nF ext/fts3/fts3_term.c f45a1e7c6ef464abb1231245d123dae12266b69e05cc56e14045b76591ae92d1\nF ext/fts3/fts3_test.c 73b16e229e517c1b1f0fb8e1046182a4e5dbc8dbe6eea8a5d4353fcce7dbbf39\nF ext/fts3/fts3_tokenize_vtab.c 1de9a61acfa2a0445ed989310c31839c57f6b6086dd9d5c97177ae734a17fd8b\nF ext/fts3/fts3_tokenizer.c a1ca0ab7c9c688ccb1d605645809f74f5df2bf4ca568e4bb37fb51113fd78e45\nF ext/fts3/fts3_tokenizer.h 64c6ef6c5272c51ebe60fc607a896e84288fcbc3\nF ext/fts3/fts3_tokenizer1.c 5c98225a53705e5ee34824087478cf477bdb7004\nF ext/fts3/fts3_unicode.c 4b9af6151c29b35ed09574937083cece7c31e911f69615e168a39677569b684d\nF ext/fts3/fts3_unicode2.c 416eb7e1e81142703520d284b768ca2751d40e31fa912cae24ba74860532bf0f\nF ext/fts3/fts3_write.c 51e0a4e3782ee17b6dd5e89949b7095fc98e36e87725c53de631734535507498\nF ext/fts3/fts3speed.tcl b54caf6a18d38174f1a6e84219950d85e98bb1e9\nF ext/fts3/mkfts3amal.tcl 252ecb7fe6467854f2aa237bf2c390b74e71f100\nF ext/fts3/tool/fts3cov.sh c331d006359456cf6f8f953e37f2b9c7d568f3863f00bb5f7eb87fea4ac01b73\nF ext/fts3/tool/fts3view.c 202801a2056995b763864d60c2dee744d46f1677\nF ext/fts3/unicode/CaseFolding.txt 8c678ca52ecc95e16bc7afc2dbf6fc9ffa05db8c\nF ext/fts3/unicode/UnicodeData.txt cd07314edb62d49fde34debdaf92fa2aa69011e7\nF ext/fts3/unicode/mkunicode.tcl bf7fcaa6d68e6d38223467983785d054f1cff4d9e3905dd51f6ed8801bb590d5\nF ext/fts3/unicode/parseunicode.tcl a981bd6466d12dd17967515801c3ff23f74a281be1a03cf1e6f52a6959fc77eb\nF ext/fts5/extract_api_docs.tcl a36e54ec777172ddd3f9a88daf593b00848368e0\nF ext/fts5/fts5.h c132a9323f22a972c4c93a8d5a3d901113a6e612faf30ca8e695788438c5ca2a\nF ext/fts5/fts5Int.h d7cbc214ee167496f70905667e18f73ea0402f7ef09236ce305e117e0efc866a\nF ext/fts5/fts5_aux.c dcc627d8b6e3fc773db528ff67b39955dab7b51628f9dba8e15849e5bedfd7fa\nF ext/fts5/fts5_buffer.c 5a5fe0159752c0fb0a5a93c722e9db2662822709490769d482b76a6dc8aaca70\nF ext/fts5/fts5_config.c b447948f35ad3354e8fe5e242e0a7e7b5b941555400b9404259944e3aa570037\nF ext/fts5/fts5_expr.c 2be456484786333d559dc2987a00f2750981fab91d52db8452a8046278c5f22e\nF ext/fts5/fts5_hash.c 1cc0095646f5f3b46721aa112fb4f9bf29ae175cb5338f89dcec66ed97acfe75\nF ext/fts5/fts5_index.c 99b77ae1f503978ca76985bcfff7345c822aed8bbaa8edb3747f804f614685b5\nF ext/fts5/fts5_main.c 9db1f173d299466aeff89bd949fb1eb0a181265726fb56f11e07ea292dcc9a73\nF ext/fts5/fts5_storage.c 167e3d8f8052a71032d498e32a2f2ed5ffe489e5d4d47e298adfa02ed55c7882\nF ext/fts5/fts5_tcl.c 39bcbae507f594aad778172fa914cad0f585bf92fd3b078c686e249282db0d95\nF ext/fts5/fts5_test_mi.c 08c11ec968148d4cb4119d96d819f8c1f329812c568bac3684f5464be177d3ee\nF ext/fts5/fts5_test_tok.c f96c6e193c466711d6d7828d5f190407fe7ab897062d371426dd3036f01258e7\nF ext/fts5/fts5_tokenize.c 2e508c6a3bd8ee56c48e98a38052e1a650e49b32a484cce9b189984114bc3b88\nF ext/fts5/fts5_unicode2.c 8bd0cd07396b74c1a05590e4070d635bccfc849812c305619f109e6c0485e250\nF ext/fts5/fts5_varint.c e64d2113f6e1bfee0032972cffc1207b77af63319746951bf1d09885d1dadf80\nF ext/fts5/fts5_vocab.c c3f12188570abb423303cd193b16dd19ba54e21c2e930e9b748d743de3b385f5\nF ext/fts5/fts5parse.y eb526940f892ade5693f22ffd6c4f2702543a9059942772526eac1fde256bb05\nF ext/fts5/mkportersteps.tcl 5acf962d2e0074f701620bb5308155fa1e4a63ba\nF ext/fts5/test/fts5_common.tcl b01c584144b5064f30e6c648145a2dd6bc440841\nF ext/fts5/test/fts5aa.test 5bd43427b7d08ce2e19c488a26534be450538b9232d4d5305049e8de236e9aa9\nF ext/fts5/test/fts5ab.test 9205c839332c908aaad2b01ab8670ece8b161e8f2ec8a9fabf18ca9385880bb7\nF ext/fts5/test/fts5ac.test a7aa7e1fefc6e1918aa4d3111d5c44a09177168e962c5fd2cca9620de8a7ed6d\nF ext/fts5/test/fts5ad.test e8cf959dfcd57c8e46d6f5f25665686f3b6627130a9a981371dafdf6482790de\nF ext/fts5/test/fts5ae.test 1142d16d9cc193894dc13cc8f9c7a8a21411ac61b5567a878514df6f9f0d7bb7\nF ext/fts5/test/fts5af.test 724247405b13f8f06cc6ce464dc4f152dc5dd4e86b12c2099685d8f19747bf7b\nF ext/fts5/test/fts5ag.test 7816f25a0707578f08145ab539fc0ca025f8951e788b28a6a18a06b2099469dd\nF ext/fts5/test/fts5ah.test 27b5a33bfd0363ca8a4dc659e6e2a5df3dea1c3c5b04bc51ca6aeb1277bd9b21\nF ext/fts5/test/fts5ai.test bc97e4758cc93e06bf851d61c98fdf4e8b8f8315ee28a84fb15f916360856414\nF ext/fts5/test/fts5aj.test 745020852d85f5dd49d11cb7ad11d3cc6dafc4fe6d6d24bc0875ac8f43ee4149\nF ext/fts5/test/fts5ak.test fc3595f8e6873bb86d70c9bd4b67d0413ce577bd4793c39a2b60a7b8825b60a6\nF ext/fts5/test/fts5al.test 00c4c1c6a1366b73aa48ce2068c634520867c3cf7f5d1676ebbb775ee1f35734\nF ext/fts5/test/fts5alter.test 5565f7e4605512b69171ac18ca84398603f9f6456dbe377beeca97e83cc242cd\nF ext/fts5/test/fts5auto.test 78989e6527ce69c9eddbef7392fea5c10b0010cd2b2ae68eec7bc869c471e691\nF ext/fts5/test/fts5aux.test ebf6f2ff7cb556e83f66991b7f12bff016d3c83d4eab36704b649dd6b1437318\nF ext/fts5/test/fts5auxdata.test eacc97ff04892f1a5f3d4df5a73f8bcbc3955ea1d12c9f24137eb1fc079e7611\nF ext/fts5/test/fts5bigpl.test 6466c89b38439f0aba26ac09e232a6b963f29b1cbe1304f6a664fe1e7a8f5fd3\nF ext/fts5/test/fts5bigtok.test 541119e616c637caea925a8c028c37c2c29e94383e00aa2f9198d530724b6e36\nF ext/fts5/test/fts5cat.test daba0b80659460b0cb60bd1f40b402478a761fe7ea414c3c94c2be25568cc33a\nF ext/fts5/test/fts5circref.test f880dfd0d99f6fb73b88ccacb0927d18e833672fd906cc47d6b4e529419eaa62\nF ext/fts5/test/fts5colset.test a30473451321bbf0b6218af62e96b4ae5fa99931cfdb210b5ecc804623b30f75\nF ext/fts5/test/fts5columnsize.test 45459ce4dd9fd853b6044cdc9674921bff89e3d840f348ca8c1630f9edbf5482\nF ext/fts5/test/fts5config.test 60094712debc59286c59aef0e6cf511c37d866802776a825ce437d26afe0817f\nF ext/fts5/test/fts5conflict.test 655925678e630d3cdf145d18725a558971806416f453ac8410ca8c04d934238d\nF ext/fts5/test/fts5connect.test 08030168fc96fc278fa81f28654fb7e90566f33aff269c073e19b3ae9126b2f4\nF ext/fts5/test/fts5content.test 213506436fb2c87567b8e31f6d43ab30aab99354cec74ed679f22aad0cdbf283\nF ext/fts5/test/fts5corrupt.test 77ae6f41a7eba10620efb921cf7dbe218b0ef232b04519deb43581cb17a57ebe\nF ext/fts5/test/fts5corrupt2.test 7453752ba12ce91690c469a6449d412561cc604b1dec994e16ab132952e7805f\nF ext/fts5/test/fts5corrupt3.test 5aaa2f8b44a85246a2ea76db1695bde38a75802979f3961702afa8f322d331c8\nF ext/fts5/test/fts5corrupt4.test ea805c4d7c68b5f185b9db5d2060a7ae5875339738dd48203c92162f41e7ca91\nF ext/fts5/test/fts5delete.test cbf87e3b8867c4d5cfcaed975c7475fd3f99d072bce2075fcedf43d1f82af775\nF ext/fts5/test/fts5detail.test 31b240dbf6d44ac3507e2f8b65f29fdc12465ffd531212378c7ce1066766f54e\nF ext/fts5/test/fts5determin.test 1b77879b2ae818b5b71c859e534ee334dac088b7cf3ff3bf76a2c82b1c788d11\nF ext/fts5/test/fts5dlidx.test b90852c55881b29dbac6380b274de27beae623ac4b6d567c6c8fb9cdc315a86e\nF ext/fts5/test/fts5doclist.test e39a6001495f1dc68e20323586ac965787986c2bf6f515b9b0285627b089d9e6\nF ext/fts5/test/fts5ea.test b01e3a18cdfabbff8104a96a5242a06a68a998a0\nF ext/fts5/test/fts5eb.test 239bb2f02571f8cccfc7018d08f502df1cd8cc6a69b65ed1dde5f6a070e3f669\nF ext/fts5/test/fts5fault1.test d28a65caee75db6897c3cf1358c5230d3bb2a3bf7fb31062c19c7e5382b3d2bd\nF ext/fts5/test/fts5fault2.test 69c8fdbef830cd0d450908d4504d5bb86609e255af99c421c20a0756251fe344\nF ext/fts5/test/fts5fault3.test da2f9e3e56ff5740d68ebdd6877c97089e7ed28ddff28a0da87a6afea27e5522\nF ext/fts5/test/fts5fault4.test 1c1db5fcfe59401e7833146100f1d8de284a0a686fac31ddac9fb56c459f725b\nF ext/fts5/test/fts5fault5.test a336e4e11847de24c9497f80cce18e00bb3fab7fb11f97d04eb9af898900a762\nF ext/fts5/test/fts5fault6.test a0fc0a8f99e4b16500c31dfc7e38e1defe0f1693ac47650517ac7b723b1956f8\nF ext/fts5/test/fts5fault7.test 0acbec416edb24b8881f154e99c31e9ccf73f539cfcd164090be139e9e97ed4c\nF ext/fts5/test/fts5fault8.test 318238659d35f82ad215ecb57ca4c87486ea85d45dbeedaee42f148ff5105ee2\nF ext/fts5/test/fts5fault9.test 098e6b894bbdf9b2192f994a30f4043673fb3f338b6b8ab1624c704422f39119\nF ext/fts5/test/fts5faultA.test be4487576bff8c22cee6597d1893b312f306504a8c6ccd3c53ca85af12290c8c\nF ext/fts5/test/fts5faultB.test d606bdb8e81aaeb6f41de3fc9fc7ae315733f0903fbff05cf54f5b045b729ab5\nF ext/fts5/test/fts5faultD.test cc5d1225556e356615e719c612e845d41bff7d5a\nF ext/fts5/test/fts5first.test 3fcf2365c00a15fc9704233674789a3b95131d12de18a9b996159f6909dc8079\nF ext/fts5/test/fts5full.test e1701a112354e0ff9a1fdffb0c940c576530c33732ee20ac5e8361777070d717\nF ext/fts5/test/fts5fuzz1.test 238d8c45f3b81342aa384de3e581ff2fa330bf922a7b69e484bbc06051a1080e\nF ext/fts5/test/fts5hash.test a4cf51acad99bfc43c16fb74f9d22495dc221ae0701fc5e908ca963a9b26a02b\nF ext/fts5/test/fts5integrity.test 4317561cd25eca7df16aa1f7d1a700ee958059fa639785f94aba0a84df9ab17b\nF ext/fts5/test/fts5interrupt.test 09613247b273a99889808ef852898177e671406fe71fdde7ea00e78ea283d227\nF ext/fts5/test/fts5lastrowid.test be98fe3e03235296585b72daad7aed5717ba0062bae5e5c18dd6e04e194c6b28\nF ext/fts5/test/fts5leftjoin.test c0b4cafb9661379e576dc4405c0891d8fcc2782680740513c4d1fc114b43d4ad\nF ext/fts5/test/fts5matchinfo.test 50d86da66ec5b27603dcd90ba0227f5d9deb10351cbc52974a88e24f6fc9b076\nF ext/fts5/test/fts5merge.test e92a8db28b45931e7a9c7b1bbd36101692759d00274df74d83fd29d25d53b3a6\nF ext/fts5/test/fts5merge2.test 3ebad1a59d6ad3fb66eff6523a09e95dc6367cbefb3cd73196801dea0425c8e2\nF ext/fts5/test/fts5misc.test a5b53328b5b79275915de8f67ae85905eb2133d8dbcc808411f67c094b1bd347\nF ext/fts5/test/fts5multi.test a15bc91cdb717492e6e1b66fec1c356cb57386b980c7ba5af1915f97fe878581\nF ext/fts5/test/fts5multiclient.test 5ff811c028d6108045ffef737f1e9f05028af2458e456c0937c1d1b8dea56d45\nF ext/fts5/test/fts5near.test 211477940142d733ac04fad97cb24095513ab2507073a99c2765c3ddd2ef58bd\nF ext/fts5/test/fts5onepass.test f9b7d9b2c334900c6542a869760290e2ab5382af8fbd618834bf1fcc3e7b84da\nF ext/fts5/test/fts5optimize.test 36a752d24c818792032e4ff502936fc9cc5ef938721696396fdc79214b2717f1\nF ext/fts5/test/fts5phrase.test 13e5d8e9083077b3d9c74315b3c92ec723cc6eb37c8155e0bfe1bba00559f07b\nF ext/fts5/test/fts5plan.test 771b999d161e24fd803ce0290adb7c6e7c9b9cc2c6a0adb344813fb89473aa32\nF ext/fts5/test/fts5porter.test 8d08010c28527db66bc3feebd2b8767504aaeb9b101a986342fa7833d49d0d15\nF ext/fts5/test/fts5porter2.test 0d251a673f02fa13ca7f011654873b3add20745f7402f108600a23e52d8c7457\nF ext/fts5/test/fts5prefix.test a0fa67b06650f2deaa7bf27745899d94e0fb547ad9ecbd08bfad98c04912c056\nF ext/fts5/test/fts5query.test ac363b17a442620bb0780e93c24f16a5f963dfe2f23dc85647b869efcfada728\nF ext/fts5/test/fts5rank.test c9fd4a1e36b4fa92d572ec13d846469b97da249d1c2f7fd3ee7e017ce46f2416\nF ext/fts5/test/fts5rebuild.test 55d6f17715cddbf825680dd6551efbc72ed916d8cf1cde40a46fc5d785b451e7\nF ext/fts5/test/fts5restart.test 835ecc8f449e3919f72509ab58056d0cedca40d1fe04108ccf8ac4c2ba41f415\nF ext/fts5/test/fts5rowid.test b8790ec170a8dc1942a15aef3db926a5f3061b1ff171013003d8297203a20ad6\nF ext/fts5/test/fts5simple.test a298670508c1458b88ce6030440f26a30673931884eb5f4094ac1773b3ba217b\nF ext/fts5/test/fts5simple2.test 258a1b0c590409bfa5271e872c79572b319d2a56554d0585f68f146a0da603f0\nF ext/fts5/test/fts5simple3.test d5c74a9d3ca71bd5dd5cacb7c55b86ea12cdddfc8b1910e3de2995206898380f\nF ext/fts5/test/fts5synonym.test 1651815b8008de170e8e600dcacc17521d765482ea8f074ae82cfa870d8bb7fb\nF ext/fts5/test/fts5synonym2.test b54cce5c34ec08ed616f646635538ae82e34a0e28f947ec60b6fadbc4b3fb17a\nF ext/fts5/test/fts5tok1.test ce6551e41ff56f30b69963577324624733bed0d1753589f06120d664d9cd45c9\nF ext/fts5/test/fts5tok2.test dcacb32d4a2a3f0dd3215d4a3987f78ae4be21a2\nF ext/fts5/test/fts5tokenizer.test ac3c9112b263a639fb0508ae73a3ee886bf4866d2153771a8e8a20c721305a43\nF ext/fts5/test/fts5umlaut.test a42fe2fe6387c40c49ab27ccbd070e1ae38e07f38d05926482cc0bccac9ad602\nF ext/fts5/test/fts5unicode.test 17056f4efe6b0a5d4f41fdf7a7dc9af2873004562eaa899d40633b93dc95f5a9\nF ext/fts5/test/fts5unicode2.test 9b3df486de05fb4bde4aa7ee8de2e6dae1df6eb90e3f2e242c9383b95d314e3e\nF ext/fts5/test/fts5unicode3.test 590c72e18195bda2446133f9d82d04a4e89d094bba58c75ae10f4afc6faa0744\nF ext/fts5/test/fts5unicode4.test 6463301d669f963c83988017aa354108be0b947d325aef58d3abddf27147b687\nF ext/fts5/test/fts5unindexed.test 9021af86a0fb9fc616f7a69a996db0116e7936d0db63892db6bafabbec21af4d\nF ext/fts5/test/fts5update.test b8affd796e45c94a4d19ad5c26606ea06065a0f162a9562d9f005b5a80ccf0bc\nF ext/fts5/test/fts5version.test c8f2cc105f0abf0224965f93e584633dee3e06c91478bc67e468f7cfdf97fd6a\nF ext/fts5/test/fts5vocab.test 648fb2fe86b55e08295e34504704718d92fba3e2cf3e1f5d72fa3682df4cd0f0\nF ext/fts5/test/fts5vocab2.test e0fdc3a3095f6eda68ac9bf9a443ff929a124d46f00af19933604085712e9d47\nF ext/fts5/tool/fts5speed.tcl b0056f91a55b2d1a3684ec05729de92b042e2f85\nF ext/fts5/tool/fts5txt2db.tcl 526a9979c963f1c54fd50976a05a502e533a4c59\nF ext/fts5/tool/loadfts5.tcl 95b03429ee6b138645703c6ca192c3ac96eaf093\nF ext/fts5/tool/mkfts5c.tcl d1c2a9ab8e0ec690a52316f33dd9b1d379942f45\nF ext/fts5/tool/showfts5.tcl d54da0e067306663e2d5d523965ca487698e722c\nF ext/icu/README.txt a295e91db742b153e8dce8f7efd31d28ad1eea4df31ef4daa3eedc85be2f5138\nF ext/icu/icu.c c2c7592574c08cd1270d909b8fb8797f6ea1f49e931e71dbcc25506b9b224580\nF ext/icu/sqliteicu.h 728867a802baa5a96de7495e9689a8e01715ef37\nF ext/lsm1/Makefile a553b728bba6c11201b795188c5708915cc4290f02b7df6ba7e8c4c943fd5cd9\nF ext/lsm1/Makefile.msc f8c878b467232226de288da320e1ac71c131f5ec91e08b21f502303347260013\nF ext/lsm1/lsm-test/README 87ea529d2abe615e856d4714bfe8bb185e6c2771b8612aa6298588b7b43e6f86\nF ext/lsm1/lsm-test/lsmtest.h cf58528ffe0cfe535e91b44584e2ec5fb1caacdabecef0d8dcf83bf83168bf28\nF ext/lsm1/lsm-test/lsmtest1.c ae6ba48a0851b39be69a7d0eb220bfb9521a526e926223d5014bd385df10abb3\nF ext/lsm1/lsm-test/lsmtest2.c 188b09aec776516aeedcfd13b9c6faf85ba16b3671a0897a2c740ee00a5dc4f8\nF ext/lsm1/lsm-test/lsmtest3.c 9ab87528a36dbf4a61d7c8ad954f5ee368c0878c127b84b942b2e2abe522de26\nF ext/lsm1/lsm-test/lsmtest4.c d258d6a245db5d8eaede096e2368d23f859c5e92c80ab9122463f708514fe10c\nF ext/lsm1/lsm-test/lsmtest5.c 8d5242a0f870d65eeada191c8945781fed9cb8ece3886573790ebd373b62dac5\nF ext/lsm1/lsm-test/lsmtest6.c 869cb4a172cd07d1a75b3aeaecd61d0a477787b3b8668bad0d3ff0f43b642b7c\nF ext/lsm1/lsm-test/lsmtest7.c 7a917455a0f956a8ed3f44f5c9387ec0ea6627714874464cc3fa5c5a9cabb2f2\nF ext/lsm1/lsm-test/lsmtest8.c 589b68c44531a0f04d5e879bb1e211be5f7100f48eed7e8631e07ed5cbd68f94\nF ext/lsm1/lsm-test/lsmtest9.c dd1a0ebf41134933a744d1e00e60429a2a21fc50d587ae7dd6bdb6e96d805bdc\nF ext/lsm1/lsm-test/lsmtest_bt.c d70d9a9be5eef9360af1251dd083948d74fd30137a08f61bef995f7ac04e037f\nF ext/lsm1/lsm-test/lsmtest_datasource.c 5d770be191d0ca51315926723009b2c25c0b4b8136840494ef710ac324aa916c\nF ext/lsm1/lsm-test/lsmtest_func.c 159aa401bc8032bfa3d8cf2977bd687abebab880255895a5eb45770d626fa38d\nF ext/lsm1/lsm-test/lsmtest_io.c cf11b27b129c6bd5818fa1d440176502dc27229f0db892b4479118d61993ea20\nF ext/lsm1/lsm-test/lsmtest_main.c a9bc647738c0dcaebf205d6d194b3ce4a6ef3925801cd2d919f0a4ea33a15aeb\nF ext/lsm1/lsm-test/lsmtest_mem.c 4e63c764345ab1df59d4f13a77980c6f3643798210b10d6cdbd785b4b888fda5\nF ext/lsm1/lsm-test/lsmtest_tdb.c 618a8619183fda4f5540fcde15f9068293c5e3180e1a246e34409b0c148758b3\nF ext/lsm1/lsm-test/lsmtest_tdb.h 8733eee249b12956a9df8322994b43d19bd8c02ad2e8b0bb5164db4d6ccc1735\nF ext/lsm1/lsm-test/lsmtest_tdb2.cc 99ea7f2dd9c7536c8fb9bdd329e4cfeb76899f3ddf6f48bdd3926e016922b715\nF ext/lsm1/lsm-test/lsmtest_tdb3.c 7a7ccae189f5bb25bcd1ec3bbd740529706eded7f6729a5a0a9eeaeb57785320\nF ext/lsm1/lsm-test/lsmtest_tdb4.c 47e8bb5eba266472d690fb8264f1855ebdba0ae5a0e541e35fcda61ebf1d277f\nF ext/lsm1/lsm-test/lsmtest_util.c 241622db5a332a09c8e6e7606b617d288a37b557f7d3bce0bb97809f67cc2806\nF ext/lsm1/lsm-test/lsmtest_win32.c 0e0a224674c4d3170631c41b026b56c7e1672b151f5261e1b4cc19068641da2d\nF ext/lsm1/lsm.h 0f6f64ff071471cb87bf98beb8386566f30ea001\nF ext/lsm1/lsmInt.h 5983690e05e83653cc01ba9d8fbf8455e534ddf8349ed9adedbf46a7549760b0\nF ext/lsm1/lsm_ckpt.c 0eabfaf812ddb4ea43add38f05e430694cd054eb622c3e35af4c43118a2d5321\nF ext/lsm1/lsm_file.c 3c51841d5b3e7da162693cbac9a9f47eeedf6bcbbe2969a4d25e30c428c9fe36\nF ext/lsm1/lsm_log.c a8bf334532109bba05b09a504ee45fc393828b0d034ca61ab45e3940709d9a7c\nF ext/lsm1/lsm_main.c b5703f8042e71d3a2d65e671f6832e077e79e89e9975818f67f969922618db63\nF ext/lsm1/lsm_mem.c 4c51ea9fa285ee6e35301b33491642d071740a0a\nF ext/lsm1/lsm_mutex.c 378edf0a2b142b4f7640ee982df06d50b98788ea\nF ext/lsm1/lsm_shared.c 76adfc1ed9ffebaf92746dde4b370ccc48143ca8b05b563816eadd2aadf1c525\nF ext/lsm1/lsm_sorted.c 6f7d8cf7a7d3d3f1ab5d9ba6347e8f39f3d73c00ec48afcd0c4bcbefd806f9b8\nF ext/lsm1/lsm_str.c 65e361b488c87b10bf3e5c0070b14ffc602cf84f094880bece77bbf6678bca82\nF ext/lsm1/lsm_tree.c 682679d7ef2b8b6f2fe77aeb532c8d29695bca671c220b0abac77069de5fb9fb\nF ext/lsm1/lsm_unix.c 57361bcf5b1a1a028f5d66571ee490e9064d2cfb145a2cc9e5ddade467bb551b\nF ext/lsm1/lsm_varint.c 43f954af668a66c7928b81597c14d6ad4be9fedbc276bbd80f52fa28a02fdb62\nF ext/lsm1/lsm_vtab.c 169bfe7ef8e6c9de9c77e17c4c50c9ae55fb0167d80be3d1be82c991184b6f35\nF ext/lsm1/lsm_win32.c 0a4acbd7e8d136dd3a5753f0a9e7a9802263a9d96cef3278cf120bcaa724db7c\nF ext/lsm1/test/lsm1_common.tcl 5ed4bab07c93be2e4f300ebe46007ecf4b3e20bc5fbe1dedaf04a8774a6d8d82\nF ext/lsm1/test/lsm1_simple.test a04d08e8661ae6fc53786c67f0bd102c6692f003e859dde03ed9ac3f12e066e5\nF ext/lsm1/tool/mklsm1c.tcl f31561bbee5349f0a554d1ad7236ac1991fc09176626f529f6078e07335398b0\nF ext/misc/README.md d6dd0fe1d8af77040216798a6a2b0c46c73054d2f0ea544fbbcdccf6f238c240\nF ext/misc/amatch.c 50a9ef2d38dabfa371f8c1904097d493271e63d58ccb0e9b79a4fa4a94e66660\nF ext/misc/anycollseq.c 5ffdfde9829eeac52219136ad6aa7cd9a4edb3b15f4f2532de52f4a22525eddb\nF ext/misc/appendvfs.c 3777f22ec1057dc4e5fd89f2fbddcc7a29fbeef1ad038c736c54411bb1967af7\nF ext/misc/blobio.c a867c4c4617f6ec223a307ebfe0eabb45e0992f74dd47722b96f3e631c0edb2a\nF ext/misc/btreeinfo.c 4f0ebf278f46e68e6306c667917766cebc5550fd35d5de17847988e22892d4d2\nF ext/misc/carray.c 91e9a7f512fda934894bed30464552fffa7d3073b5be04189ae0bd0c59f26bfd\nF ext/misc/closure.c dbfd8543b2a017ae6b1a5843986b22ddf99ff126ec9634a2f4047cd14c85c243\nF ext/misc/completion.c cec672d40604075bb341a7f11ac48393efdcd90a979269b8fe7977ea62d0547f\nF ext/misc/compress.c dd4f8a6d0baccff3c694757db5b430f3bbd821d8686d1fc24df55cf9f035b189\nF ext/misc/csv.c 7f047aeb68f5802e7ce6639292095d622a488bb43526ed04810e0649faa71ceb\nF ext/misc/dbdata.c e316fba936571584e55abd5b974a32a191727a6b746053a0c9d439bd2cf93940\nF ext/misc/dbdump.c baf6e37447c9d6968417b1cd34cbedb0b0ab3f91b5329501d8a8d5be3287c336\nF ext/misc/eval.c 4b4757592d00fd32e44c7a067e6a0e4839c81a4d57abc4131ee7806d1be3104e\nF ext/misc/explain.c d5c12962d79913ef774b297006872af1fccda388f61a11d37758f9179a09551f\nF ext/misc/fileio.c 288e7230e0fe464d71b0694e2d8bdd3a353118ac2e31da3964b95f460f09915f\nF ext/misc/fossildelta.c 7708651072eb5620ab21bbfb518d184f27b2c29c0131b09b9a2d8852a8016430\nF ext/misc/fuzzer.c c4e27daf41433a64cad5265cd27dbcb891147e9994d0422200ce81ce9a54b625\nF ext/misc/ieee754.c f190d0cc5182529acb15babd177781be1ac1718c\nF ext/misc/json1.c 760107d0b97ab422952591b0d7519327dcb482954a7706ee387a54c135f8aabf\nF ext/misc/memstat.c 3017a0832c645c0f8c773435620d663855f04690172316bd127270d1a7523d4d\nF ext/misc/memtrace.c 7c0d115d2ef716ad0ba632c91e05bd119cb16c1aedf3bec9f06196ead2d5537b\nF ext/misc/memvfs.c ab36f49e02ebcdf85a1e08dc4d8599ea8f343e073ac9e0bca18a98b7e1ec9567\nF ext/misc/mmapwarm.c 8c5fe90d807a23e44a8b93e96e8b812b19b300d5fd8c1d40a4fd1d8224e33f46\nF ext/misc/nextchar.c 279f80fe8ef5ba413242e2704e246503ac601f005eefb180d19e6c920338a0ba\nF ext/misc/normalize.c b4290464f542bae7a97b43f15bd197949b833ffd668b7c313631bd5d4610212c\nF ext/misc/percentile.c 148dd07286b16e50f232bb638a47850085ad37d51f270429905bd865e595d1ca\nF ext/misc/prefixes.c 7be86d17525cfae6ed462fc3c519efc44488ac329890f77491c8f82871f57e17\nF ext/misc/regexp.c be064ad9478361e40c7b8ca460f78b3d3c9b96080d5f391126c95e14bd362fae\nF ext/misc/remember.c add730f0f7e7436cd15ea3fd6a90fd83c3f706ab44169f7f048438b7d6baa69c\nF ext/misc/rot13.c 540a169cb0d74f15522a8930b0cccdcb37a4fd071d219a5a083a319fc6e8db77\nF ext/misc/scrub.c db9fff56fed322ca587d73727c6021b11ae79ce3f31b389e1d82891d144f22ad\nF ext/misc/series.c 0c97f63378fddc9f425e82ba139b9aaf902211f24ced115c2b6ae12b425f7334\nF ext/misc/sha1.c d8125a88ee9023bc17d6f87ea8850db33f906d5701b30d4fd9bddb57f231e60a\nF ext/misc/shathree.c 22ba7ca84a433d6466a7d05dcc876910b435a715da8cc462517db9351412b8c8\nF ext/misc/showauth.c 732578f0fe4ce42d577e1c86dc89dd14a006ab52\nF ext/misc/spellfix.c f88ecb2c0294453ce8b7704b211f5350c41b085b38c8e056852e3a08b0f5e484\nF ext/misc/sqlar.c 57d5bc45cd5492208e451f697404be88f8612527d64c9d42f96b325b64983d74\nF ext/misc/stmt.c 8a8dc4675042e4551e4afe99b8d0cc7a4a2fc1a8dacc0a9ce1b1bbff145da93d\nF ext/misc/templatevtab.c 8a16a91a5ceaccfcbd6aaaa56d46828806e460dd194965b3f77bf38f14b942c4\nF ext/misc/totype.c 5b6b1eafaa993e29f8df843319b3292b029f1b5cbbbf11c8a88e05d3f714159f\nF ext/misc/unionvtab.c 36237f0607ca954ac13a4a0e2d2ac40c33bc6e032a5f55f431713061ef1625f9\nF ext/misc/uuid.c db4db81e8c6a92ad6176ebd9f81dcb6870e331e1a286d0452f4319e3ba3df812\nF ext/misc/vfslog.c 3b25c2f56ba60788db247287be6ab024b53c4afffd412b4876db563389be0d35\nF ext/misc/vfsstat.c 77b5b4235c9f7f11eddf82487c0a422944ac2f132dafd5af3be7a68a057b1cdb\nF ext/misc/vtablog.c 5538acd0c8ddaae372331bee11608d76973436b77d6a91e8635cfc9432fba5ae\nF ext/misc/vtshim.c 1976e6dd68dd0d64508c91a6dfab8e75f8aaf6cd\nF ext/misc/wholenumber.c 784b12543d60702ebdd47da936e278aa03076212\nF ext/misc/zipfile.c 8f965eb309da3ae8c30088f6c3ebdddcdbdf9e0ef24f3bc7ae0756deb93da503\nF ext/misc/zorder.c b0ff58fa643afa1d846786d51ea8d5c4b6b35aa0254ab5a82617db92f3adda64\nF ext/rbu/rbu.c 8681f6157db6adc82c34af24b14ea8a3be0146ad2a3b6c1d5da6cb8a5796c8ce\nF ext/rbu/rbu1.test 221d9c18a5e600ac9ac6b1810d99d9f99163a7909ba61597876ab6e4d4beb3d6\nF ext/rbu/rbu10.test 0a201c32202143f23c81c0144503da339786fc20acb7a2fda11601b65659f314\nF ext/rbu/rbu11.test 5c834cf491086b45e071eabf71f708febc143e86a384a92de69e0b1a4cace144\nF ext/rbu/rbu12.test 29f8b2118f6c96fac3755bd6d2b55c2db24f878b1f11fbfbe294f3a230a3dcdc\nF ext/rbu/rbu13.test 1285298e3360ec74511764841b3c174dcfe21da2f618c22febf1a20abd0365c2\nF ext/rbu/rbu14.test 4a7bf0b3a4516d3ab0bc0ba4ceb53eb7e3324147ccda152e561060f659dbba31\nF ext/rbu/rbu3.test d6c6cc7a1326e8e23b9820f30bd3054f22092e503fadfd2a660ae006653f6d80\nF ext/rbu/rbu5.test 724b38ea5f722e3d22dc76343860bd998bb676c3f78c4bc8175df5c5d7720e23\nF ext/rbu/rbu6.test 401064236d3cf86b7edc01c586d7c5554f48553946fbfa1a3af35d7e47dce9e3\nF ext/rbu/rbu7.test ae25f47b56f178197fc1098537a35a39176cc73d1629b03dc9d795929fc36ec2\nF ext/rbu/rbu8.test b98a6fc58ead84a0e6ddee775b9702cd981f318d5d4fd1d4df0fa0c40db7251b\nF ext/rbu/rbu9.test 0e4d985e25620d61920597e8ea69c871c9e8c1f5a0be2ae9fa70bb641d74378c\nF ext/rbu/rbuA.test b34a90cb495682c25b5fc03a9d5e7a4fc99541c29256f25e2e2a4f6542b4f5b3\nF ext/rbu/rbuB.test 52b07158824c6927b7e25554ace92a695cdebfc296ae3d308ac386984aded9bc\nF ext/rbu/rbuC.test 80f1cc2fb74f44b1128fd0ed8eedab3a76fefeb72a947860e2869ef76fc8dc6b\nF ext/rbu/rbu_common.tcl 60d904133ff843fe72cc0514e9dd2486707181e6e0fbab20979da28c48d21de9\nF ext/rbu/rbucollate.test cac528a9a46318cba42e61258bb42660bbbf4fdb9a8c863de5a54ad0c658d197\nF ext/rbu/rbucrash.test 000981a1fe8a6e4d9a684232f6a129e66a3ef595f5ed74655e2f9c68ffa613b4\nF ext/rbu/rbucrash2.test efa143cc94228eb0266d3f1abfbee60a5838a84cef7cc3fcb8c145b74d96fd41\nF ext/rbu/rbudiff.test 156957851136b63c143478518dc1bda6c832103cdbe8ac1d7cdd47edb3cbe0a3\nF ext/rbu/rbudor.test e3e8623926012f43eebe51fedf06a102df2640750d971596b052495f2536db20\nF ext/rbu/rbuexpr.test 10d0420537c3bc7666e576d72adeffe7e86cfbb00dcc30aa9ce096c042415190\nF ext/rbu/rbufault.test 2d7f567b79d558f6e093c58808cab4354f8a174e3802f69e7790a9689b3c09f8\nF ext/rbu/rbufault2.test c81327a3ac2c385b9b954db3644d4e0df93eeebfc3de9f1f29975a1e73fd3d0c\nF ext/rbu/rbufault3.test b2fcc9db5c982b869f67d1d4688d8cb515d5b92f58011fff95665f2e62cec179\nF ext/rbu/rbufault4.test 03d2849c3df7d7bd14a622e789ff049e5080edd34a79cd432e01204db2a5930a\nF ext/rbu/rbufts.test 0ae8d1da191c75bd776b86e24456db0fb6e97b7c944259fae5407ea55d23c31d\nF ext/rbu/rbumisc.test 329986cf5dd51890c4eb906c2f960ebb773a79a64bed90f506b7c417825b37eb\nF ext/rbu/rbumulti.test 5fb139058f37ddc5a113c5b93238de915b769b7792de41b44c983bc7c18cf5b9\nF ext/rbu/rbupartial.test f25df014b8dbe3c5345851fba6e66f79ab237f57dc201b2d5f0dbae658ae5a4c\nF ext/rbu/rbuprogress.test 857cf1f8166c83ef977edb9ef4fc42d80f71fbd798652b46ae2f3a7031870f8d\nF ext/rbu/rburesume.test dbdc4ca504e9c76375a69e5f0d91205db967dcc509a5166ca80231f8fda49eb1\nF ext/rbu/rbusave.test f4190a1a86fccf84f723af5c93813365ae33feda35845ba107b59683d1cdd926\nF ext/rbu/rbusplit.test b37e7b40b38760881dc9c854bd40b4744c6b6cd74990754eca3bda0f407051e8\nF ext/rbu/rbutemplimit.test 05ceefa90a2e26a99f40dd48282ed63a00df5e59c1f2bfd479c143e201a1b0ba\nF ext/rbu/rbuvacuum.test 55e101e90168c2b31df6c9638fe73dc7f7cc666b6142266d1563697d79f73534\nF ext/rbu/rbuvacuum2.test b8e5b51dc8b2c0153373d024c0936be3f66f9234acbd6d0baab0869d56b14e6b\nF ext/rbu/rbuvacuum3.test 8addd82e4b83b4c93fa47428eae4fd0dbf410f8512c186f38e348feb49ba03dc\nF ext/rbu/rbuvacuum4.test a78898e438a44803eb2bc897ba3323373c9f277418e2d6d76e90f2f1dbccfd10\nF ext/rbu/sqlite3rbu.c f3a3e09f575157052813be667d6ab3b54f47fb02e6e1c9f767ad7bb8f1fb90b3\nF ext/rbu/sqlite3rbu.h 1dc88ab7bd32d0f15890ea08d23476c4198d3da3056985403991f8c9cd389812\nF ext/rbu/test_rbu.c 03f6f177096a5f822d68d8e4069ad8907fe572c62ff2d19b141f59742821828a\nF ext/repair/README.md 92f5e8aae749a4dae14f02eea8e1bb42d4db2b6ce5e83dbcdd6b1446997e0c15\nF ext/repair/checkfreelist.c 0dbae18c1b552f58d64f8969e4fb1e7f11930c60a8c2a9a8d50b7f15bdfd54bd\nF ext/repair/checkindex.c 7d28c01a2e012ac64257d230fc452b2cafb78311a91a343633d01d95220f66f3\nF ext/repair/sqlite3_checker.c.in 4a5a3af3f450fe503e5a2985e98516dc2a6b9ad247449e284c1cf140fc91720f\nF ext/repair/sqlite3_checker.tcl a9a2caa9660567257c177a91124d8c0dccdfa341e25c51e6da7f1fd9e601eafa\nF ext/repair/test/README.md 34b2f542cf5be7bffe479242b33ee3492cea30711e447cc4a1a86cb5915f419e\nF ext/repair/test/checkfreelist01.test 3e8aa6aeb4007680c94a8d07b41c339aa635cc78249442da72ff3f8297398a69\nF ext/repair/test/checkindex01.test b530f141413b587c9eb78ff734de6bb79bc3515c335096108c12c01bddbadcec\nF ext/repair/test/test.tcl 686d76d888dffd021f64260abf29a55c57b2cedfa7fc69150b42b1d6119aac3c\nF ext/rtree/README 6315c0d73ebf0ec40dedb5aa0e942bc8b54e3761\nF ext/rtree/geopoly.c c591164125808f8bba9659e92665b78412cd263e654b6f05294f3a8da7cdd9fb\nF ext/rtree/rtree.c 26fcb3f7a92fda9afcf5eee684cc3188b7367da69bc9c374492d844fb8ed4e25\nF ext/rtree/rtree.h 4a690463901cb5e6127cf05eb8e642f127012fd5003830dbc974eca5802d9412\nF ext/rtree/rtree1.test 4092a8bd2b5eafc4fafe4fe9024249c12b13e4bab23c2c3eaff57412fdf805fa\nF ext/rtree/rtree2.test 9d9deddbb16fd0c30c36e6b4fdc3ee3132d765567f0f9432ee71e1303d32603d\nF ext/rtree/rtree3.test 4ee5d7df86040efe3d8d84f141f2962a7745452200a7cba1db06f86d97050499\nF ext/rtree/rtree4.test 304de65d484540111b896827e4261815e5dca4ce28eeecd58be648cd73452c4b\nF ext/rtree/rtree5.test 49c9041d713d54560b315c2c7ef7207ee287eba1b20f8266968a06f2e55d3142\nF ext/rtree/rtree6.test 1252a0439da01d2f1f5cbbdeeb80455a2d68b9bae2a9787937b167a5e3957828\nF ext/rtree/rtree7.test c8fb2e555b128dd0f0bdb520c61380014f497f8a23c40f2e820acc9f9e4fdce5\nF ext/rtree/rtree8.test 2d99006a1386663978c9e1df167554671e4f711c419175b39f332719deb1ce0e\nF ext/rtree/rtree9.test c646f12c8c1c68ef015c6c043d86a0c42488e2e68ed1bb1b0771a7ca246cbabf\nF ext/rtree/rtreeA.test ed2f1be9c06dde0b1ab93a95dd9e87eeaa02db2d30bcb4b9179b69ee3dc3319b\nF ext/rtree/rtreeB.test 4cec297f8e5c588654bbf3c6ed0903f10612be8a2878055dd25faf8c71758bc9\nF ext/rtree/rtreeC.test 6aa87eba4d9a3003b941a1ba77db259c5cabc3fd92fc5a6360f5369520eb9a4d\nF ext/rtree/rtreeD.test fe46aa7f012e137bd58294409b16c0d43976c3bb92c8f710481e577c4a1100dc\nF ext/rtree/rtreeE.test e65d3fc625da1800b412fc8785817327d43ccfec5f5973912d8c9e471928caa9\nF ext/rtree/rtreeF.test 81ffa7ef51c4e4618d497a57328c265bf576990c7070633b623b23cd450ed331\nF ext/rtree/rtreeG.test 1b9ca6e3effb48f4161edaa463ddeaa8fca4b2526d084f9cbf5dbe4e0184939c\nF ext/rtree/rtreeH.test 0885151ee8429242625600ae47142cca935332c70a06737f35af53a7bd7aaf90\nF ext/rtree/rtreeI.test 608e77f7fde9be5a12eae316baef640fffaafcfa90a3d67443e78123e19c4ca4\nF ext/rtree/rtree_perf.tcl 6c18c1f23cd48e0f948930c98dfdd37dfccb5195\nF ext/rtree/rtree_util.tcl db734b4c5e75fed6acc56d9701f2235345acfdec750b5fc7b587936f5f6bceed\nF ext/rtree/rtreecheck.test d67d5b3e9e45bfa8cd90734e8e9302144ac415b8e9176c6f02d4f92892ee8a35\nF ext/rtree/rtreecirc.test aec664eb21ae943aeb344191407afff5d392d3ae9d12b9a112ced0d9c5de298e\nF ext/rtree/rtreeconnect.test 225ad3fcb483d36cbee423a25052a6bbae762c9576ae9268332360c68c170d3d\nF ext/rtree/rtreefuzz001.test eef1ed593bb15886cd5d5367a2f2492f81e315848896cdf7afb6e21454978827\nF ext/rtree/sqlite3rtree.h 03c8db3261e435fbddcfc961471795cbf12b24e03001d0015b2636b0f3881373\nF ext/rtree/tkt3363.test 142ab96eded44a3615ec79fba98c7bde7d0f96de\nF ext/rtree/util/randomshape.tcl 54ee03d0d4a1c621806f7f44d5b78d2db8fac26e0e8687c36c4bd0203b27dbff\nF ext/rtree/viewrtree.tcl eea6224b3553599ae665b239bd827e182b466024\nF ext/rtree/visual01.txt e9c2564083bcd30ec51b07f881bffbf0e12b50a3f6fced0c222c5c1d2f94ac66\nF ext/session/changeset.c 7a1e6a14c7e92d36ca177e92e88b5281acd709f3b726298dc34ec0fb58869cb5\nF ext/session/changesetfuzz.c 227076ab0ae4447d742c01ee88a564da6478bbf26b65108bf8fac9cd8b0b24aa\nF ext/session/changesetfuzz1.test 2e1b90d888fbf0eea5e1bd2f1e527a48cc85f8e0ff75df1ec4e320b21f580b3a\nF ext/session/session1.test 0b2f88995832ea040ae8e83a1ad4afa99c00b85c779d213da73a95ea4113233e\nF ext/session/session2.test 284de45abae4cc1082bc52012ee81521d5ac58e0\nF ext/session/session3.test ce9ce3dfa489473987f899e9f6a0f2db9bde3479\nF ext/session/session4.test 6778997065b44d99c51ff9cece047ff9244a32856b328735ae27ddef68979c40\nF ext/session/session5.test 716bc6fafd625ce60dfa62ae128971628c1a1169\nF ext/session/session6.test 443789bc2fca12e4f7075cf692c60b8a2bea1a26\nF ext/session/session8.test 8e194b3f655d861ca36de5d4de53f702751bab3b\nF ext/session/session9.test 5409d90d8141881d08285ed1c2c0d8d10fb92069\nF ext/session/sessionA.test 1feeab0b8e03527f08f2f1defb442da25480138f\nF ext/session/sessionB.test c4fb7f8a688787111606e123a555f18ee04f65bb9f2a4bb2aa71d55ce4e6d02c\nF ext/session/sessionC.test f8a5508bc059ae646e5ec9bdbca66ad24bc92fe99fda5790ac57e1f59fce2fdf\nF ext/session/sessionD.test 4f91d0ca8afc4c3969c72c9f0b5ea9527e21de29039937d0d973f821e8470724\nF ext/session/sessionE.test b2010949c9d7415306f64e3c2072ddabc4b8250c98478d3c0c4d064bce83111d\nF ext/session/sessionF.test d37ed800881e742c208df443537bf29aa49fd56eac520d0f0c6df3e6320f3401\nF ext/session/sessionG.test 3828b944cd1285f4379340fd36f8b64c464fc84df6ff3ccbc95578fd87140b9c\nF ext/session/sessionH.test a417559f29a7e775950fc5fc82b3d01256a7cbe793ddf1180df234df823d56e2\nF ext/session/session_common.tcl 29ec9910aca1e996ca1c8531b8cecabf96eb576aa53de65a8ff03d848b9a2a8b\nF ext/session/session_speed_test.c dcf0ef58d76b70c8fbd9eab3be77cf9deb8bc1638fed8be518b62d6cbdef88b3\nF ext/session/sessionat.test efe88965e74ff1bc2af9c310b28358c02d420c1fb2705cc7a28f0c1cc142c3ec\nF ext/session/sessiondiff.test ad13dd65664bae26744e1f18eb3cbd5588349b7e9118851d8f9364248d67bcec\nF ext/session/sessionfault.test da273f2712b6411e85e71465a1733b8501dbf6f7\nF ext/session/sessionfault2.test dd593f80b6b4786f7adfe83c5939620bc505559770cc181332da26f29cddd7bb\nF ext/session/sessioninvert.test ae1a003a9ab1f8d64227dbb5c3a4c97e65b561b01e7b2953cf48683fb2724169\nF ext/session/sessionrebase.test ccfa716b23bd1d3b03217ee58cfd90c78d4b99f53e6a9a2f05e82363b9142810\nF ext/session/sessionstat1.test 218d351cf9fcd6648f125a26b607b140310160184723c2666091b54450a68fb5\nF ext/session/sessionwor.test 67b5ab91d4f93ce65ff1f58240ac5ddf73f8670facc1ffa49cef56293d52818d\nF ext/session/sqlite3session.c a4dfb372f270df93422b0dc7666fd46849e6979b62a152f11287c21eed4ac21b\nF ext/session/sqlite3session.h a2db5b72b938d12c727b4b4ec632254ca493670a9c0de597af3271a7f774fc57\nF ext/session/test_session.c 98797aba475a799376c9a42214f2d1debf2d0c3cb657d9c8bbf4f70bf3fb4aec\nF ext/userauth/sqlite3userauth.h 7f3ea8c4686db8e40b0a0e7a8e0b00fac13aa7a3\nF ext/userauth/user-auth.txt e6641021a9210364665fe625d067617d03f27b04\nF ext/userauth/userauth.c f81aa5a3ecacf406f170c62a144405858f6f6de51dbdc0920134e629edbe2648\nF install-sh 9d4de14ab9fb0facae2f48780b874848cbf2f895 x\nF ltmain.sh 3ff0879076df340d2e23ae905484d8c15d5fdea8\nF magic.txt 8273bf49ba3b0c8559cb2774495390c31fd61c60\nF main.mk 7ce055f3df31a4f7d21e38f493f907c21db1f673863a573e231f55e2ab005023\nF mkso.sh fd21c06b063bb16a5d25deea1752c2da6ac3ed83\nF mptest/config01.test 3c6adcbc50b991866855f1977ff172eb6d901271\nF mptest/config02.test 4415dfe36c48785f751e16e32c20b077c28ae504\nF mptest/crash01.test 61e61469e257df0850df4293d7d4d6c2af301421\nF mptest/crash02.subtest f4ef05adcd15d60e5d2bd654204f2c008b519df8\nF mptest/mptest.c aa41ace6dbc5050d76b02548d3521e6bbccae4f0\nF mptest/multiwrite01.test dab5c5f8f9534971efce679152c5146da265222d\nF spec.template 86a4a43b99ebb3e75e6b9a735d5fd293a24e90ca\nF sqlite.pc.in 42b7bf0d02e08b9e77734a47798d1a55a9e0716b\nF sqlite3.1 fc7ad8990fc8409983309bb80de8c811a7506786\nF sqlite3.pc.in 48fed132e7cb71ab676105d2a4dc77127d8c1f3a\nF src/alter.c 14b5516be5b3815d30bf230b619978f6158e754a1d624f70a02cfe2178348b5c\nF src/analyze.c b3ceec3fc052df8a96ca8a8c858d455dc5029ba681b4be98bb5c5a9162cfa58c\nF src/attach.c b30c44333d55a68c0a12920b5b9d40b254cbd3d4509bda77417209eeed8b3d80\nF src/auth.c a3d5bfdba83d25abed1013a8c7a5f204e2e29b0c25242a56bc02bb0c07bf1e06\nF src/backup.c f70077d40c08b7787bfe934e4d1da8030cb0cc57d46b345fba2294b7d1be23ab\nF src/bitvec.c 17ea48eff8ba979f1f5b04cc484c7bb2be632f33\nF src/btmutex.c 8acc2f464ee76324bf13310df5692a262b801808984c1b79defb2503bbafadb6\nF src/btree.c d22498af716953400e314d2d98d1dac3ea5c3b01e0fd243ef9e9b132c74114ec\nF src/btree.h f27a33c49280209a93385e218306c4ee5f46ba8d7649d2f81a7166b282232484\nF src/btreeInt.h 91806f01fd1145a9a86ba3042f25c38d8faf6002701bf5e780742cf88bcff437\nF src/build.c 358e894867394839679982d2fe320fb44fd17c94a87feb898aa066c15a8066ea\nF src/callback.c 88615dfc0a82167b65b452b4b305dbf86be77200b3343c6ffc6d03e92a01d181\nF src/complete.c a3634ab1e687055cd002e11b8f43eb75c17da23e\nF src/ctime.c 1b0724e66f95f33b160b1af85caaf9cceb325d22abf39bd24df4f54a73982251\nF src/date.c e1d8ac7102f3f283e63e13867acb0efa33861cf34f0faf4cdbaf9fa7a1eb7041\nF src/dbpage.c 135eb3b5e74f9ef74bde5cec2571192c90c86984fa534c88bf4a055076fa19b7\nF src/dbstat.c 6c407e549406c10fde9ac3987f6d734459205239ad370369bc5fcd683084a4fa\nF src/delete.c a5c59b9c0251cf7682bc52af0d64f09b1aefc6781a63592c8f1136f7b73c66e4\nF src/expr.c 5099de2d6cca77f7c3b5131e0035787fc64ca3d27c267020e7e8bec0e226336c\nF src/fault.c 460f3e55994363812d9d60844b2a6de88826e007\nF src/fkey.c 92a248ec0fa4ed8ab60c98d9b188ce173aaf218f32e7737ba77deb2a684f9847\nF src/func.c ed33e38cd642058182a31a3f518f2e34f4bbe53aa483335705c153c4d3e50b12\nF src/global.c a1a8d698762ddd9a1543aac26c1e0029b20fcc3fcb56bfa41ec8cea2368f2798\nF src/hash.c 8d7dda241d0ebdafb6ffdeda3149a412d7df75102cecfc1021c98d6219823b19\nF src/hash.h 9d56a9079d523b648774c1784b74b89bd93fac7b365210157482e4319a468f38\nF src/hwtime.h cb1d7e3e1ed94b7aa6fde95ae2c2daccc3df826be26fc9ed7fd90d1750ae6144\nF src/in-operator.md 10cd8f4bcd225a32518407c2fb2484089112fd71\nF src/insert.c 831408b14a146e93a4e02ddba54dcdfd8097463b9c00ca2ed9daed790c5d452a\nF src/legacy.c d7874bc885906868cd51e6c2156698f2754f02d9eee1bae2d687323c3ca8e5aa\nF src/loadext.c d74f5e7bd51f3c9d283442473eb65aef359664efd6513591c03f01881c4ae2da\nF src/main.c 868ae7db7a54fe859bf2ca8b7a4f24e9fa03a6134abfb7c9801d08411ef5dacb\nF src/malloc.c 550021fcae36f0ffe9f8563d83e6385f9df307a854d55d7d0abb7241ee8dbcc6\nF src/mem0.c 6a55ebe57c46ca1a7d98da93aaa07f99f1059645\nF src/mem1.c c12a42539b1ba105e3707d0e628ad70e611040d8f5e38cf942cee30c867083de\nF src/mem2.c f1940d9e91948dd6a908fbb9ce3835c36b5d83c3\nF src/mem3.c 8768ac94694f31ffaf8b4d0ea5dc08af7010a35a\nF src/mem5.c 9bf955937b07f8c32541c8a9991f33ce3173d944\nF src/memdb.c 02a5fcec19b9d40dd449ca802dc1b2e8f93f255fbf2a886277a3c3800d8d35db\nF src/memjournal.c 7561c01c90958f3ba9bc6cb2d857123d932bdfa5539ea34427a0957b2e35154d\nF src/msvc.h 3a15918220367a8876be3fa4f2abe423a861491e84b864fb2b7426bf022a28f8\nF src/mutex.c bae36f8af32c22ad80bbf0ccebec63c252b6a2b86e4d3e42672ff287ebf4a604\nF src/mutex.h a7b2293c48db5f27007c3bdb21d438873637d12658f5a0bf8ad025bb96803c4a\nF src/mutex_noop.c 9d4309c075ba9cc7249e19412d3d62f7f94839c4\nF src/mutex_unix.c aaf9ebc3f89df28483c52208497a99a02cc3650011422fc9d4c57e4392f7fe58\nF src/mutex_w32.c 7670d770c94bbfe8289bec9d7f1394c5a00a57c37f892aab6b6612d085255235\nF src/notify.c 9711a7575036f0d3040ba61bc6e217f13a9888e7\nF src/os.c 669cc3839cc35d20f81faf0be1ab6d4581cea35e9d8f3a9d48a98d6571f7c285\nF src/os.h 48388821692e87da174ea198bf96b1b2d9d83be5dfc908f673ee21fafbe0d432\nF src/os_common.h b2f4707a603e36811d9b1a13278bffd757857b85\nF src/os_setup.h 0dbaea40a7d36bf311613d31342e0b99e2536586\nF src/os_unix.c 3e0e519f27683083a465e948e056759a8340728c222b5c394a135e0c57c220bc\nF src/os_win.c 035a813cbd17f355bdcad7ab894af214a9c13a1db8aeac902365350b98cd45a7\nF src/os_win.h 7b073010f1451abe501be30d12f6bc599824944a\nF src/pager.c 30f20d2263d3717f41a0d9a40f7a3d0f48ce1cfab461b875c6187ead9d6ad1c7\nF src/pager.h 217921e81eb5fe455caa5cda96061959706bcdd29ddb57166198645ef7822ac3\nF src/parse.y c8d2de64db469fd56e0fa24da46cd8ec8523eb98626567d2708df371b47fdc3f\nF src/pcache.c 385ff064bca69789d199a98e2169445dc16e4291fa807babd61d4890c3b34177\nF src/pcache.h 4f87acd914cef5016fae3030343540d75f5b85a1877eed1a2a19b9f284248586\nF src/pcache1.c 6596e10baf3d8f84cc1585d226cf1ab26564a5f5caf85a15757a281ff977d51a\nF src/pragma.c 26e9ee514138b9697d4be6d8f9ca84655053026390cf10de838862238aa4aba9\nF src/pragma.h ec3b31eac9b1df040f1cc8cb3d89bc06605c3b4cb3d76f833de8d6d6c3f77f04\nF src/prepare.c 6049beb71385f017af6fc320d2c75a4e50b75e280c54232442b785fbb83df057\nF src/printf.c 9be6945837c839ba57837b4bc3af349eba630920fa5532aa518816defe42a7d4\nF src/random.c 80f5d666f23feb3e6665a6ce04c7197212a88384\nF src/resolve.c 86a7773d2892227ba9ad1721c41bb03c501830f1bf6de5f78dd0062b82e10c9d\nF src/rowset.c d977b011993aaea002cab3e0bb2ce50cf346000dff94e944d547b989f4b1fe93\nF src/select.c dd7e40967760b28efe274ade35043d5bf5d72774208bb75d2cb4dd59cbd59ad1\nF src/shell.c.in 4a3a9e1c11847b1904f2b01d087af1c052f660902755abab457cab1756817ded\nF src/sqlite.h.in 2a23e8161775253d9cf383c2c6aa559005dc787d350dcb0be67a6c4cc3bd1d19\nF src/sqlite3.rc 5121c9e10c3964d5755191c80dd1180c122fc3a8\nF src/sqlite3ext.h 72af51aa4e912e14cd495fb6e7fac65f0940db80ed950d90911aff292cc47ce2\nF src/sqliteInt.h 60d92fad64da7c3e77bbc35ee306340814cdaa5df32892b0ec58d306d99b5733\nF src/sqliteLimit.h 1513bfb7b20378aa0041e7022d04acb73525de35b80b252f1b83fedb4de6a76b\nF src/status.c 46e7aec11f79dad50965a5ca5fa9de009f7d6bde08be2156f1538a0a296d4d0e\nF src/table.c b46ad567748f24a326d9de40e5b9659f96ffff34\nF src/tclsqlite.c 8cd2600e8de23dff6cdf84d39f46ca57139b061b28f6f80b166bace17d52ab1c\nF src/test1.c c654981c1d86ebc90dd23fcc0969e6c85e28112f0acc2e2224a97a2a33e7c42f\nF src/test2.c 3efb99ab7f1fc8d154933e02ae1378bac9637da5\nF src/test3.c 61798bb0d38b915067a8c8e03f5a534b431181f802659a6616f9b4ff7d872644\nF src/test4.c 405834f6a93ec395cc4c9bb8ecebf7c3d8079e7ca16ae65e82d01afd229694bb\nF src/test5.c 328aae2c010c57a9829d255dc099d6899311672d\nF src/test6.c e8d839fbc552ce044bec8234561a2d5b8819b48e29548ad0ba400471697946a8\nF src/test7.c 5612e9aecf934d6df7bba6ce861fdf5ba5456010\nF src/test8.c 3f7d0cc4e12e06832ba3db4455cb16867ccadafa602eb6ff5fcf097bffce56ed\nF src/test9.c 12e5ba554d2d1cbe0158f6ab3f7ffcd7a86ee4e5\nF src/test_async.c 195ab49da082053fdb0f949c114b806a49ca770a\nF src/test_autoext.c 915d245e736652a219a907909bb6710f0d587871\nF src/test_backup.c bf5da90c9926df0a4b941f2d92825a01bbe090a0\nF src/test_bestindex.c 78809f11026f18a93fcfd798d9479cba37e1201c830260bf1edc674b2fa9b857\nF src/test_blob.c ae4a0620b478548afb67963095a7417cd06a4ec0a56adb453542203bfdcb31ce\nF src/test_btree.c 8b2dc8b8848cf3a4db93f11578f075e82252a274\nF src/test_config.c e25826d693039cdd45963de378cbf39e3af0e8aa7a8a6fc159876f4e7b5a4f8c\nF src/test_delete.c e2fe07646dff6300b48d49b2fee2fe192ed389e834dd635e3b3bac0ce0bf9f8f\nF src/test_demovfs.c 86142ba864d4297d54c5b2e972e74f3141ae4b30f05b3a95824184ed2d3d7f91\nF src/test_devsym.c 6109b45c3db3ef7b002320947ed448c027356ab8b885156ff535fd8684d4a571\nF src/test_fs.c ba1e1dc18fd3159fdba0b9c4256f14032159785320dfbd6776eb9973cb75d480\nF src/test_func.c 181f992e5495644434c4f0e3cc72362a78c295eb2cf3ff4d02498b8bde7aa276\nF src/test_hexio.c d170d0e1a6431afdeac086a250d2595078288c2257615d37949355361399bcaa\nF src/test_init.c 4413c211a94b62157ca4c145b3f27c497f03c664\nF src/test_intarray.c 39b4181662a0f33a427748d87218e7578d913e683dc27eab7098bb41617cac71\nF src/test_intarray.h d57ae92f420cda25e22790dac474d60961bd0c500cbaa3338a05152d4a669ef7\nF src/test_journal.c a0b9709b2f12b1ec819eea8a1176f283bca6d688a6d4a502bd6fd79786f4e287\nF src/test_loadext.c 337056bae59f80b9eb00ba82088b39d0f4fe6dfd\nF src/test_malloc.c dec0aa821b230773aeb3dd11d652c1193f7cedb18a20b25659bc672288115242\nF src/test_md5.c 7268e1e8c399d4a5e181b64ac20e1e6f3bc4dd9fc87abac02db145a3d951fa8c\nF src/test_multiplex.c e054459f7633f3ff8ce1245da724f9a8be189e4e\nF src/test_multiplex.h 5436d03f2d0501d04f3ed50a75819e190495b635\nF src/test_mutex.c 7f4337ba23ee6b1d2ec81c189653608cb069926a\nF src/test_onefile.c f31e52e891c5fef6709b9fcef54ce660648a34172423a9cbdf4cbce3ba0049f4\nF src/test_osinst.c 98ef31ff03d55497829ca0f6c74a9f4e1aa48690\nF src/test_pcache.c a5cd24730cb43c5b18629043314548c9169abb00\nF src/test_quota.c 6cb9297115b551f433a9ad1741817a9831abed99\nF src/test_quota.h 2a8ad1952d1d2ca9af0ce0465e56e6c023b5e15d\nF src/test_rtree.c 671f3fae50ff116ef2e32a3bf1fe21b5615b4b7b\nF src/test_schema.c f575932cb6274d12147a77e13ea4b49d52408513\nF src/test_server.c a2615049954cbb9cfb4a62e18e2f0616e4dc38fe\nF src/test_sqllog.c 11e6ce7575f489155c604ac4b439f2ac1d3d5aef\nF src/test_superlock.c 4839644b9201da822f181c5bc406c0b2385f672e\nF src/test_syscall.c 1073306ba2e9bfc886771871a13d3de281ed3939\nF src/test_tclsh.c eeafce33ad2136d57e5dec10f1e9a4347447eb72ffd504a1c7b9c6bfe2e71578\nF src/test_tclvar.c 33ff42149494a39c5fbb0df3d25d6fafb2f668888e41c0688d07273dcb268dfc\nF src/test_thread.c 911d15fb14e19c0c542bdc8aabf981c2f10a4858\nF src/test_vdbecov.c f60c6f135ec42c0de013a1d5136777aa328a776d33277f92abac648930453d43\nF src/test_vfs.c 36822d696789535bdd0260f07d2c9a46546082fea8bb1d0a7354c7f9366e37ea\nF src/test_vfstrace.c bab9594adc976cbe696ff3970728830b4c5ed698\nF src/test_windirent.c a895e2c068a06644eef91a7f0a32182445a893b9a0f33d0cdb4283dca2486ac1\nF src/test_windirent.h 90dfbe95442c9762357fe128dc7ae3dc199d006de93eb33ba3972e0a90484215\nF src/test_window.c cdae419fdcea5bad6dcd9368c685abdad6deb59e9fc8b84b153de513d394ba3f\nF src/test_wsd.c 41cadfd9d97fe8e3e4e44f61a4a8ccd6f7ca8fe9\nF src/threads.c 4ae07fa022a3dc7c5beb373cf744a85d3c5c6c3c\nF src/tokenize.c 7b17f6e2f20f6cbcb0b215025a86b7457c38451fc7622f705e553d7a488c572d\nF src/treeview.c 41d928f04d65931b15f629b4938e9f2c7dc259f02eef34cb2cc6e293f5af813f\nF src/trigger.c 681ccdb910a87243940d63f99b26190d9c5d2534c2ded3c0825b7c0e315a342e\nF src/update.c 07a50767f7d3e26d4c887c31cd66448d700d3215caea6023acf7269336097df7\nF src/upsert.c b445315c8958d8f17ec3297d06842e61dacaad0633ccaec1e4e160de7e562212\nF src/utf.c 2f0fac345c7660d5c5bd3df9e9d8d33d4c27f366bcfb09e07443064d751a0507\nF src/util.c 2c92bc706bbdb1c45a25180291e7e05a56e297aa5dd7b2bcd2b1c47e8bb05b17\nF src/vacuum.c 82dcec9e7b1afa980288718ad11bc499651c722d7b9f32933c4d694d91cb6ebf\nF src/vdbe.c ab3f6e647235fe4fa16b71496468313a1da435eb3a2125c3ffdbb0be0d1cbcba\nF src/vdbe.h fdbc0a11e5768a702b46ce63286f60e22e71351a29bd98b3666405e1fccc7802\nF src/vdbeInt.h bd589b8b7273286858950717e0e1ec5c88b18af45079a3366dc1371865cea704\nF src/vdbeapi.c 1252d80c548711e47a6d84dae88ed4e95d3fbb4e7bd0eaa1347299af7efddf02\nF src/vdbeaux.c 858bb43a9d98846cc23fa8c8d0970ada805dd75bc6a01b69e972da608f7f59b1\nF src/vdbeblob.c 253ed82894924c362a7fa3079551d3554cd1cdace39aa833da77d3bc67e7c1b1\nF src/vdbemem.c 2eb00a4d1a7d2c97510a4d1ccaf4e12c9143f2ced1c6b96b5eddc372183c9121\nF src/vdbesort.c a3be032cc3fee0e3af31773af4a7a6f931b7230a34f53282ccf1d9a2a72343be\nF src/vdbetrace.c fa3bf238002f0bbbdfb66cc8afb0cea284ff9f148d6439bc1f6f2b4c3b7143f0\nF src/vtab.c 2736f853a1bd270581f76bae8e5d2e840b6258f3d85c1fa382e9454b3c414d1d\nF src/vxworks.h d2988f4e5a61a4dfe82c6524dd3d6e4f2ce3cdb9\nF src/wal.c 15a2845769f51ba132f9cf0b2c7a6887a91fc8437892dbcce9fcdc68b66d60a1\nF src/wal.h 606292549f5a7be50b6227bd685fa76e3a4affad71bb8ac5ce4cb5c79f6a176a\nF src/walker.c a137468bf36c92e64d2275caa80c83902e3a0fc59273591b96c6416d3253d05d\nF src/where.c c51ebd505c8417285ca1db8f94933a12224bf636ad93f27d821c07f93d59c035\nF src/whereInt.h 4a296fd4fa79fdcbc2b5e8c1b898901617655811223e1082b899c23ecb092217\nF src/wherecode.c 7efa97f4dc2f95548611deba68f0210ab357725899a9bae5391a525e48271875\nF src/whereexpr.c 39b6a538804c6e1248c22b33e09d00f89ae6a099c849c4d841ce3995562287b4\nF src/window.c da010455914c81037dcb5b0c6f4273f8a32c94567865c46a60060b937b018a96\nF test/8_3_names.test ebbb5cd36741350040fd28b432ceadf495be25b2\nF test/affinity2.test ce1aafc86e110685b324e9a763eab4f2a73f737842ec3b687bd965867de90627\nF test/affinity3.test 6a101af2fc945ce2912f6fe54dd646018551710d\nF test/aggerror.test a867e273ef9e3d7919f03ef4f0e8c0d2767944f2\nF test/aggnested.test 12106f0748e8e9bfc1a8e6840e203e051eae06a26ed13fc9fd5db108a8d6db54\nF test/alias.test 4529fbc152f190268a15f9384a5651bbbabc9d87\nF test/all.test 2ecb8bbd52416642e41c9081182a8df05d42c75637afd4488aace78cc4b69e13\nF test/alter.test 16ed8d2470193f34bc711e51506ff1211ebfab8025ca3b9510ff2aef139874cb\nF test/alter2.test a966ccfcddf9ce0a4e0e6ff1aca9e6e7948e0e242cd7e43fc091948521807687\nF test/alter3.test 9351a9f0c59ff9dddecccaaa2f777ffee5369870c63d30d3a74add815254ec0f\nF test/alter4.test 74b22251c5e9c48093cfc4921ed9c11b59df84634aeeb00e501773320beb8424\nF test/alterauth.test 63442ba61ceb0c1eeb63aac1f4f5cebfa509d352276059d27106ae256bafc959\nF test/alterauth2.test c0a1ddf5b93d93cb0d15ba7acaf0c5c6fb515bbe861ede75b2d3fabad33b6499\nF test/altercol.test 54374d2ba18af25bb24e23acf18a60270d4ec120b7ec0558078b59d5aa1a31ad\nF test/alterlegacy.test 82022721ce0de29cedc9a7af63bc9fcc078b0ee000f8283b4b6ea9c3eab2f44b\nF test/altermalloc.test 167a47de41b5c638f5f5c6efb59784002b196fff70f98d9b4ed3cd74a3fb80c9\nF test/altermalloc2.test fa7b1c1139ea39b8dec407cf1feb032ca8e0076bd429574969b619175ad0174b\nF test/altertab.test 4d8b79b0b88b62b90b710390df14fe99e0a3578345526886eaa550e28e3065dc\nF test/altertab2.test 8883693952f6d7fb5f754dbf1d694ed780aa883027bef04cb1fb99a3b88c9272\nF test/altertab3.test 231881a8e9c4905a84213476c64c174a119e1ab75ce17d986dcbbacc07b2b544\nF test/amatch1.test b5ae7065f042b7f4c1c922933f4700add50cdb9f\nF test/analyze.test 547bb700f903107b38611b014ca645d6b5bb819f5210d7bf39c40802aafeb7d7\nF test/analyze3.test 01f0b122e3e54ad2544f14f7cc7dcb4c2cb8753cad5e88c6b8d49615b3fd6a2b\nF test/analyze4.test cdf88f3f72b0f0643a1ff6c730fc5af1e42464d47478d9fbac84c333f72c014e\nF test/analyze5.test fa5131952303ac4146aba101b116b9c8cb89e2637531c334a6df7f7d19dddc0d\nF test/analyze6.test 6c3f7df2996cb6872f355a6ac1eb6d5de00a5a9288214bad7ef25c97d9cc72dc\nF test/analyze7.test 6ef0b12369f61ddeadc7d8a705c40e6b52cb29f63de3a4c56581b510b46b5783\nF test/analyze8.test 36ce54947710bd44e4f9484e1ad07e725ef01a9d7078b417c1bc884356febe4d\nF test/analyze9.test 9fbf0e0101eef4f5dc149769aa14e10b76ee06e7c28598264b32173cd1999a54\nF test/analyzeC.test 489fe2ea3be3f17548e8dd895f1b41c9669b52de1b0861f5bffe6eec46eac710\nF test/analyzeD.test e50cd0b3e6063216cc0c88a1776e8645dc0bd65a6bb275769cbee33b7fd8d90c\nF test/analyzeE.test 8684e8ac5722fb97c251887ad97e5d496a98af1d\nF test/analyzeF.test 9e1a0537949eb5483642b1140a5c39e5b4025939024b935398471fa552f4dabb\nF test/analyzer1.test 459fa02c445ddbf0101a3bad47b34290a35f2e49\nF test/async.test 1d0e056ba1bb9729283a0f22718d3a25e82c277b\nF test/async2.test c0a9bd20816d7d6a2ceca7b8c03d3d69c28ffb8b\nF test/async3.test d73a062002376d7edc1fe3edff493edbec1fc2f7\nF test/async4.test 1787e3952128aa10238bf39945126de7ca23685a\nF test/async5.test 383ab533fdb9f7ad228cc99ee66e1acb34cc0dc0\nF test/atof1.test ff0b0156fd705b67c506e1f2bfe9e26102bea9bd\nF test/atomic.test 065a453dde33c77ff586d91ccaa6ed419829d492dbb1a5694b8a09f3f9d7d061\nF test/atomic2.test b6863b4aa552543874f80b42fb3063f1c8c2e3d8e56b6562f00a3cc347b5c1da\nF test/atrc.c ec92d56d8fbed9eb3e11aaf1ab98cf7dd59e69dae31f128013f1d97e54e7dfed\nF test/attach.test 21bce8681f780a8d631a5ec7ecd0d849bfe84611257b038ae4ffeccc609d8a4e\nF test/attach2.test 256bd240da1835fb8408dd59fb7ef71f8358c7a756c46662434d11d07ba3a0ce\nF test/attach3.test c59d92791070c59272e00183b7353eeb94915976\nF test/attach4.test aa05b1d8218b24eba5a7cccf4f224f514ba57ba705c9267f09d2bb63fed0eea1\nF test/attachmalloc.test 12c4f028e570acf9e0a4b0b7fe6f536e21f3d5ebddcece423603d0569beaf438\nF test/auth.test 2154625c05bc79f0e0ea72cb2358395a8041243caa0fd7ce7617d50da4331794\nF test/auth2.test 9eb7fce9f34bf1f50d3f366fb3e606be5a2000a1\nF test/auth3.test db21405b95257c24d29273b6b31d0efc59e1d337e3d5804ba2d1fd4897b1ae49\nF test/autoanalyze1.test b9cc3f32a990fa56669b668d237c6d53e983554ae80c0604992e18869a0b2dec\nF test/autoinc.test 997d6f185f138229dc4251583a1d04816423dddc2fc034871a01aeb1d728cb39\nF test/autoindex1.test 96185415f5faacd5b8d7a7f505efddd5abb1f111d58338e9c0b1dc40b87cd3cc\nF test/autoindex2.test 12ef578928102baaa0dc23ad397601a2f4ecb0df\nF test/autoindex3.test 2dd997d6590438b53e4f715f9278aa91c9299cf3f81246a0915269c35beb790e\nF test/autoindex4.test 49d3cd791a9baa16fb461d7ea3de80d019a819cf\nF test/autoindex5.test a5d72fe8c217cc0ea356dc6fa06a282a8a3fc53aa807709d79dba07a8f248102\nF test/autovacuum.test 0831cd34e14695d297187f7f6519265e3121c5b0a1720e548e86829e796129e9\nF test/autovacuum_ioerr2.test 8a367b224183ad801e0e24dcb7d1501f45f244b4\nF test/avtrans.test b7dc25459ecbd86c6fa9c606ee3068f59d81e225118617dcf2bbb6ded2ade89e\nF test/backcompat.test 3e64cedda754c778ef6bbe417b6e7a295e662a4d\nF test/backup.test dd4a5ff756e3df3931dacb1791db0584d4bad989\nF test/backup2.test 1fd1ad8c5b3d2d5b9c0cce4143a4fc610d51ddc6ae16a7a122973d43e6b50bbd\nF test/backup4.test 8f6fd48e0dfde77b9a3bb26dc471ede3e101df32\nF test/backup5.test ee5da6d7fe5082f5b9b0bbfa31d016f52412a2e4\nF test/backup_ioerr.test 4c3c7147cee85b024ecf6e150e090c32fdbb5135\nF test/backup_malloc.test 0c9abdf74c51e7bedb66d504cd684f28d4bd4027\nF test/badutf.test d5360fc31f643d37a973ab0d8b4fb85799c3169f\nF test/badutf2.test f310fd3b24a491b6b77bccdf14923b85d6ebcce751068c180d93a6b8ff854399\nF test/bc_common.tcl b5e42d80305be95697e6370e015af571e5333a1c\nF test/bestindex1.test 705b57d7f51d53ee5fd043dd9666236e1fc18f4d59abf51da0ea5ea1b4804947\nF test/bestindex2.test 9a0ccd320b6525eec3a706aae6cdab7e1b7b5abca75027e39f39f755e76e5928\nF test/bestindex3.test 7622e792ff2da16d262d3cea6ad914591ac4806d57ed128e6c940b7920b47b84\nF test/bestindex4.test 038e3d0789332f3f1d61474f9bbc9c6d08c6bd1783a978f31f38ad82688de601\nF test/bestindex5.test 67c1166131bb59f9e47c00118f7d432ca5491e6cae6ca3f87ca9db20103a78f9\nF test/bestindex6.test d856a9bb63d927493575823eed44053bc36251e241aa364e54d0f2a2d302e1d4\nF test/between.test 68137a6e941c221417c15b6fe2d55f27bb1b6ab48bdf9e2aa51efdd85bc53802\nF test/bigfile.test aa74f4e5db51c8e54a1d9de9fa65d01d1eb20b59\nF test/bigfile2.test 1b489a3a39ae90c7f027b79110d6b4e1dbc71bfc\nF test/bigmmap.test 31dad31573638bd32de866cdefd11843f75685be4ba6aec1a47918f098f1899b\nF test/bigrow.test f0aeb7573dcb8caaafea76454be3ade29b7fc747\nF test/bigsort.test 8299fa9298f4f1e02fc7d2712e8b77d6cd60e5a2\nF test/bind.test 1e136709b306f7ed3192d349c2930d89df6ab621654ad6f1a72381d3fe76f483\nF test/bindxfer.test efecd12c580c14df5f4ad3b3e83c667744a4f7e0\nF test/bitvec.test 75894a880520164d73b1305c1c3f96882615e142\nF test/blob.test e7ac6c7d3a985cc4678c64f325292529a69ae252\nF test/boundary1.tcl 6421b2d920d8b09539503a8673339d32f7609eb1\nF test/boundary1.test 66d7f4706ccdb42d58eafdb081de07b0eb42d77b\nF test/boundary2.tcl e34ef4e930cf1083150d4d2c603e146bd3b76bcb\nF test/boundary2.test 9ae758d7dab7e882c8b6cc4a6a10278385bff8fa\nF test/boundary3.tcl 23361e108a125dca9c4080c2feb884fe54d69243\nF test/boundary3.test 56ef82096b4329aca2be74fa1e2b0f762ea0eb45\nF test/boundary4.tcl 0bb4b1a94f4fc5ae59b79b9a2b7a140c405e2983\nF test/boundary4.test 89e02fa66397b8a325d5eb102b5806f961f8ec4b\nF test/btree01.test e08b3613540145b353f20c81cb18ead54ff12e0f\nF test/btree02.test 7555a5440453d900410160a52554fe6478af4faf53098f7235f1f443d5a1d6cc\nF test/btreefault.test c2bcb542685eea44621275cfedbd8a13f65201e3\nF test/busy.test 510dc6daaad18bcbbc085bcc6217d6dc418def5e73f72ce1475eea0cb7834727\nF test/cache.test 13bc046b26210471ca6f2889aceb1ea52dc717de\nF test/cacheflush.test af25bb1509df04c1da10e38d8f322d66eceedf61\nF test/cachespill.test 895997f84a25b323b166aecb69baab2d6380ea98f9e0bcc688c4493c535cfab9\nF test/capi2.test 34a1a9a96d543a2ec2c209696b11b164444f57253b1f2cba1c2e53fadede6c7b\nF test/capi3.test 3910a73c38ac76d69778dd9eb481ab7cd6ed59117fc047b4f6056a5c72529de1\nF test/capi3b.test efb2b9cfd127efa84433cd7a2d72ce0454ae0dc4\nF test/capi3c.test 54e2dc0c8fd7c34ad1590d1be6864397da2438c95a9f5aee2f8fbc60c112e44b\nF test/capi3d.test aba917805573a03deed961a21f07a5a84505ad0a616f7e3fc1508844a15bccc4\nF test/capi3e.test 3d49c01ef2a1a55f41d73cba2b23b5059ec460fe\nF test/cast.test 3619f0c58c2e4b2a94aa86e75607e497d34ef40ab74418e71aef7b4ca5155895\nF test/cffault.test 9d6b20606afe712374952eec4f8fd74b1a8097ef\nF test/check.test 25c6035302c846c7ff8e681cf8284473f6f01be94d327de60a688ad84ab01f8b\nF test/checkfault.test da6cb3d50247169efcb20bdf57863a3ccfa1d27d9e55cd324f0680096970f014\nF test/chunksize.test 427d87791743486cbf0c3b8c625002f3255cb3a89c6eba655a98923b1387b760\nF test/close.test eccbad8ecd611d974cbf47278c3d4e5874faf02d811338d5d348af42d56d647c\nF test/closure01.test 9905883f1b171a4638f98fc764879f154e214a306d3d8daf412a15e7f3a9b1e0\nF test/coalesce.test cee0dccb9fbd2d494b77234bccf9dc6c6786eb91\nF test/collate1.test 4178fda6f4cd757b7a278e6b83805868fb1eb46edafb6e3d4bcc2419f8d93202\nF test/collate2.test 9aaa410a00734e48bcb27f3872617d6f69b2a621\nF test/collate3.test 89defc49983ddfbf0a0555aca8c0521a676f56a5\nF test/collate4.test c953715fb498b87163e3e73dd94356bff1f317bd\nF test/collate5.test 65d928034d30d2d263a80f6359f7549ee1598ec6\nF test/collate6.test 8be65a182abaac8011a622131486dafb8076e907\nF test/collate7.test 8ec29d98f3ee4ccebce6e16ce3863fb6b8c7b868\nF test/collate8.test cd9b3d3f999b8520ffaa7cc1647061fc5bab1334\nF test/collate9.test 3adcc799229545940df2f25308dd1ad65869145a\nF test/collateA.test b8218ab90d1fa5c59dcf156efabb1b2599c580d6\nF test/collateB.test 1e68906951b846570f29f20102ed91d29e634854ee47454d725f2151ecac0b95\nF test/colmeta.test 2c765ea61ee37bc43bbe6d6047f89004e6508eb1\nF test/colname.test 87ad5458bb8709312dac0d6755fd30e8e4ca83298d0a9ef6e5c24277a3c3390e\nF test/conflict.test 58857e2533fb9f2e0358ea7cb191215657846be1dd9da3b3d6df3e750c02ae03\nF test/conflict2.test bb0b94cf7196c64a3cbd815c66d3ee98c2fecd9c\nF test/conflict3.test f62a2d0cad9162a60e6458fc913dff3a2208feca924120c21737cfee65a6a74a\nF test/contrib01.test 2a1cbc0f2f48955d7d073f725765da6fbceda6b4\nF test/corrupt.test d7cb0300e4a297147b6a05e92a1684bc8973635c3bcaa3d66e983c9cbdbf47a3\nF test/corrupt2.test bb50042cf9a1f1023d73af325d47eb02a6bb11e3c52f8812644b220c5d4bca35\nF test/corrupt3.test f95d7bf78109e0b84eb285a787ce91a3fd6a2dd7d0cb55882abff3bdc081a57e\nF test/corrupt4.test 8d1d86b850fcc43e417450454f2044e52d55778a\nF test/corrupt5.test 387be3250795e2a86e6234745558b80efb248a357d0cd8e53bce75c7463f545d\nF test/corrupt6.test fc6a891716139665dae0073b6945e3670bf92568\nF test/corrupt7.test b036f94bda4b0b23a2919bf717046ce9ecca4543\nF test/corrupt8.test 2399dfe40d2c0c63af86706e30f3e6302a8d0516\nF test/corrupt9.test 730a3db08d4ab9aa43392ea30d9c2b4879cbff85\nF test/corruptA.test 112f4b2ae0b95ebf3ea63718642fb969a93acea557ace3a307234d19c245989b\nF test/corruptB.test 73a8d6c0b9833697ecf16b63e3c5c05c945b5dec\nF test/corruptC.test 74d4498fd25759618b393f1e9cde111de828b88c1848ab320f6c179fd52b5a60\nF test/corruptD.test 33a37ce3ed56a20093ceee778cd2d7109c7085a59f3213d2baede11d952e8e50\nF test/corruptE.test 4143791f2dfb443aec5b7fabfa5821e6063eccc3b49b06f212c2f014715fd476\nF test/corruptF.test be9fde98e4c93648f1ba52b74e5318edc8f59fe4\nF test/corruptG.test adf79b669cbfd19e28c8191a610d083ae53a6d51\nF test/corruptH.test 79801d97ec5c2f9f3c87739aa1ec2eb786f96454\nF test/corruptI.test a17bbf54fdde78d43cf3cc34b0057719fd4a173a3d824285b67dc5257c064c7b\nF test/corruptJ.test 4d5ccc4bf959464229a836d60142831ef76a5aa4\nF test/corruptK.test 5b4212fe346699831c5ad559a62c54e11c0611bdde1ea8423a091f9c01aa32af\nF test/corruptL.test a22a7bbf8da7603960f0bfcc62a68d1c3c41963786bd832ff804ba5e2458fb9c\nF test/corruptM.test 7d574320e08c1b36caa3e47262061f186367d593a7e305d35f15289cc2c3e067\nF test/cost.test 51f4fcaae6e78ad5a57096831259ed6c760e2ac6876836e91c00030fad385b34\nF test/count.test cb2e0f934c6eb33670044520748d2ecccd46259c\nF test/countofview.test e17d6e6688cf74f22783c9ec6e788c0790ee4fbbaee713affd00b1ac0bb39b86\nF test/coveridxscan.test 5ec98719a2e2914e8908dc75f7247d9b54a26df04625f846ac7900d5483f7296\nF test/crash.test fb9dc4a02dcba30d4aa5c2c226f98b220b2b959f\nF test/crash2.test 5b14d4eb58b880e231361d3b609b216acda86651\nF test/crash3.test 8f5de9d32ab9ab95475a9efe7f47a940aa889418\nF test/crash4.test fe2821baf37168dc59dd733dcf7dba2a401487bc\nF test/crash5.test f14ff37eddc41991be4eb63568f86caa306fd9962a0ae3750db8836777bb7aae\nF test/crash6.test 4c56f1e40d0291e1110790a99807aa875b1647ba\nF test/crash7.test 1a194c4900a255258cf94b7fcbfd29536db572df\nF test/crash8.test 64366e459c28dd62edfb7ad87253a409c7533b92d16fcc479a6a8131bdcc3100\nF test/crashM.test d95f59046fa749b0d0822edf18a717788c8f318d\nF test/crashtest1.c 09c1c7d728ccf4feb9e481671e29dda5669bbcc2\nF test/createtab.test 85cdfdae5c3de331cd888d6c66e1aba575b47c2e3c3cc4a1d6f54140699f5165\nF test/cse.test 277350a26264495e86b1785f34d2d0c8600e021c\nF test/csv01.test c9c3af0d58c34e9ac970c5875a77939edb958762c8aafb95409e19a3f088b6cd\nF test/ctime.test 78749e6c9a5f0010d67985be80788f841e3cd2da18114e2ed6010399a7d807f3\nF test/cursorhint.test 7bc346788390475e77a345da2b92270d04d35856\nF test/cursorhint2.test 6f3aa9cb19e7418967a10ec6905209bcbb5968054da855fc36c8beee9ae9c42f\nF test/dataversion1.test 6e5e86ac681f0782e766ebcb56c019ae001522d114e0e111e5ebf68ccf2a7bb8\nF test/date.test 9b73bbeb1b82d9c1f44dec5cf563bf7da58d2373\nF test/date2.test 5ef8265c71460cda6b1698bf18f4bb0ffb40ac08c5092f6afe84d398c2feb5be\nF test/dbdata.test 042f49acff3438f940eeba5868d3af080ae64ddf26ae78f80c92bec3ca7d8603\nF test/dbfuzz.c 73047c920d6210e5912c87cdffd9a1c281d4252e\nF test/dbfuzz001.test 42aad1dcef6219fbee86a9b7d08832c9bbb2e41508f6f128ae91745927276292\nF test/dbfuzz2-seed1.db e6225c6f3d7b63f9c5b6867146a5f329d997ab105bee64644dc2b3a2f2aebaee\nF test/dbfuzz2.c c2c9cb40082a77b7e95ffb8b2da1e93322efadfb1c8c1e0001c95a0af1e156c2\nF test/dbpage.test 650234ba683b9d82b899c6c51439819787e7609f17a0cc40e0080a7b6443bc38\nF test/dbstatus.test 4a4221a883025ffd39696b3d1b3910b928fb097d77e671351acb35f3aed42759\nF test/dbstatus2.test f5fe0afed3fa45e57cfa70d1147606c20d2ba23feac78e9a172f2fe8ab5b78ef\nF test/default.test 3e46c421eebefd2787c2f96673efabf792d360f3a1d5073918cbe450ce672a62\nF test/delete.test 31832b0c45ecb51a54348c68db173be462985901e6ed7f403d6d7a8f70ab4ef0\nF test/delete2.test 3a03f2cca1f9a67ec469915cb8babd6485db43fa\nF test/delete3.test 555e84a00a99230b7d049d477a324a631126a6ab\nF test/delete4.test 6aa279f459f4aa792cc251435c3809415c1ecaf9f27dce91675e26f05b503db3\nF test/delete_db.test 096d828493c7907f9ea11a7098ea6a0f73edba89406487d5d6cc2228dc4ab8b0\nF test/descidx1.test edc8adee58d491b06c7157c50364eaf1c3605c9c19f8093cb1ea2b6184f3ac13\nF test/descidx2.test a0ba347037ff3b811f4c6ceca5fd0f9d5d72e74e59f2d9de346a9d2f6ad78298\nF test/descidx3.test 953c831df7ea219c73826dfbf2f6ee02d95040725aa88ccb4fa43d1a1999b926\nF test/diskfull.test 106391384780753ea6896b7b4f005d10e9866b6e\nF test/distinct.test a1783b960ad8c15a77cd9f207be072898db1026c\nF test/distinct2.test 11b0594c932098e969d084ba45ab81d5040f4d4e766db65d49146705a305ed98\nF test/distinctagg.test 1a6ef9c87a58669438fc771450d7a72577417376\nF test/e_blobbytes.test 439a945953b35cb6948a552edaec4dc31fd70a05\nF test/e_blobclose.test 4b3c8c60c2171164d472059c73e9f3c1844bb66d\nF test/e_blobopen.test e95e1d40f995056f6f322cd5e1a1b83a27e1a145\nF test/e_blobwrite.test f87ff598b67af5b3ec002a8d83e804dc8d23808e88cf0080c176612fc9ffce14\nF test/e_changes.test fd66105385153dbf21fdb35eb8ef6c3e1eade579\nF test/e_createtable.test 1c602347e73ab80b11b9fa083f47155861aaafcff8054aac9e0b76d0df33b0a7\nF test/e_delete.test ab39084f26ae1f033c940b70ebdbbd523dc4962e\nF test/e_droptrigger.test 3cd080807622c13e5bbb61fc9a57bd7754da2412\nF test/e_dropview.test 21ce09c361227ddbc9819a5608ee2700c276bdd5\nF test/e_expr.test 328d2d7c84f8e53e942a13eac771b337bcdfcf4c3569324001868b5639f3c857\nF test/e_fkey.test 2febb2084aef9b0186782421c07bc9d377abf067c9cb4efd49d9647ae31f5afe\nF test/e_fts3.test 17ba7c373aba4d4f5696ba147ee23fd1a1ef70782af050e03e262ca187c5ee07\nF test/e_insert.test f02f7f17852b2163732c6611d193f84fc67bc641fb4882c77a464076e5eba80e\nF test/e_reindex.test 2b0e29344497d9a8a999453a003cb476b6b1d2eef2d6c120f83c2d3a429f3164\nF test/e_resolve.test a61751c368b109db73df0f20fc75fb47e166b1d8\nF test/e_select.test f9474205669a7736ef725b29cc7ae9e8601919a3d0ffc0ab30745a028f2a4b61\nF test/e_select2.test aceb80ab927d46fba5ce7586ebabf23e2bb0604f\nF test/e_totalchanges.test b12ee5809d3e63aeb83238dd501a7bca7fd72c10\nF test/e_update.test f46c2554d915c9197548681e8d8c33a267e84528\nF test/e_uri.test 47eeb2960e74613f0f8722b2f13aef08fde69daa16e5380ac93df84dac8b1f72\nF test/e_vacuum.test 0d8832a2ce92350db0d0cff47b419465fd9772562e1f77ff7d9478c07a4980d2\nF test/e_wal.test ae9a593207a77d711443ee69ffe081fda9243625\nF test/e_walauto.test 248af31e73c98df23476a22bdb815524c9dc3ba8\nF test/e_walckpt.test 28c371a6bb5e5fe7f31679c1df1763a19d19e8a0\nF test/e_walhook.test 01b494287ba9e60b70f6ebf3c6c62e0ffe01788e344a4846b08e5de0b344cb66\nF test/emptytable.test a38110becbdfa6325cd65cb588dca658cd885f62\nF test/enc.test e54531cd6bf941ee6760be041dff19a104c7acea\nF test/enc2.test 83437a79ba1545a55fb549309175c683fb334473\nF test/enc3.test 6807f7a7740a00361ca8d0ccd66bc60c8dc5f2b6\nF test/enc4.test c8f1ce3618508fd0909945beb8b8831feef2c020\nF test/eqp.test 84879b63e3110552bf8ce648a3507dc3ceb72109ecec83c2aef0db37a27f6382\nF test/errmsg.test eae9f091eb39ce7e20305de45d8e5d115b68fa856fba4ea6757b6ca3705ff7f9\nF test/eval.test a64c9105d6ff163df7cf09d6ac29cdad5922078c\nF test/exclusive.test 1206b87e192497d78c7f35552e86a9d05421498da300fb1cce5ca5351ccde3c3\nF test/exclusive2.test 984090e8e9d1b331d2e8111daf6e5d61dda0bef7\nF test/exec.test e949714dc127eaa5ecc7d723efec1ec27118fdd7\nF test/exists.test 79a75323c78f02bbe9c251ea502a092f9ef63dac\nF test/expr.test 7cb55e80aeb41d65fec968c08212505123063fea60bdc355d764d747670e9eea\nF test/expr2.test c27327ae9c017a7ff6280123f67aff496f912da74d78c888926d68b46ec75fd8\nF test/extension01.test 00d13cec817f331a687a243e0e5a2d87b0e358c9\nF test/extraquick.test cb254400bd42bfb777ff675356aabf3287978f79\nF test/fallocate.test 37a62e396a68eeede8f8d2ecf23573a80faceb630788d314d0a073d862616717\nF test/filectrl.test 6e871c2d35dead1d9a88e176e8d2ca094fec6bb3\nF test/filefmt.test f393e80c4b8d493b7a7f8f3809a8425bbf4292af1f5140f01cb1427798a2bbd4\nF test/filter1.test fe7fcfeff48ca399fbc9577f55b60c8be8ccfdffc5e3b4ace21dc3c3e59f0f6a\nF test/filter2.tcl 44e525497ce07382915f01bd29ffd0fa49dab3adb87253b5e5103ba8f93393e8\nF test/filter2.test 485cf95d1f6d6ceee5632201ca52a71868599836f430cdee42e5f7f14666e30a\nF test/filterfault.test c08fb491d698e8df6c122c98f7db1c65ffcfcad2c1ab0e07fa8a5be1b34eaa8b\nF test/fkey1.test d11dbb8a93ead9b5c46ae5d02da016d61245d47662fb2d844c99214f6163f768\nF test/fkey2.test d35d1c81e7569bdd2b872e91750f7098117d2e8291369f70b7e3d50a0e523dc2\nF test/fkey3.test 76d475c80b84ee7a5d062e56ccb6ea68882e2b49\nF test/fkey4.test 86446017011273aad8f9a99c1a65019e7bd9ca9d\nF test/fkey5.test 24dd28eb3d9f1b5a174f47e9899ace5facb08373a4223593c8c631e6cf9f7d5a\nF test/fkey6.test d078a1e323a740062bed38df32b8a736fd320dc0\nF test/fkey7.test 64fb28da03da5dfe3cdef5967aa7e832c2507bf7fb8f0780cacbca1f2338d031\nF test/fkey8.test 48ef829d63f5f7b37aabd4df9363ac05f65539d1da8c4a44251631769d920579\nF test/fkey_malloc.test 594a7ea1fbab553c036c70813cd8bd9407d63749\nF test/fordelete.test eb93a2f34137bb87bdab88fcab06c0bd92719aff\nF test/format4.test eeae341953db8b6bda7f549044797c3278a6cc345d11ada81471671b654f8ef4\nF test/fts-9fd058691.test 78b887e30ae6816df0e1fed6259de4b5a64ad33c\nF test/fts1a.test 46090311f85da51bb33bd5ce84f7948359c6d8d7\nF test/fts1b.test 5d8a01aefbecc8b7442b36c94c05eb7a845462d5\nF test/fts1c.test 85a525ce7428907469b4cce13d5563ce542ce64c\nF test/fts1d.test a73deace5c18df4a549b12908bade4f05dcf1a2f\nF test/fts1e.test 77244843e925560b5a0b70069c3e7ab62f181ed2\nF test/fts1f.test 2d6cb10d8b7a4e6edc321bbdb3982f1f48774714\nF test/fts1i.test 6bfe08cdfdced063a39a50c8601da65e6274d879\nF test/fts1j.test e3797475796043a161e348c46a309664cac83f7f\nF test/fts1k.test 65d3b41487b9f738d11b0f00eca375c0ca6bd970\nF test/fts1l.test 15c119ed2362b2b28d5300c0540a6a43eab66c36\nF test/fts1m.test 2d9ca67b095d49f037a914087cc0a61e89da4f0c\nF test/fts1n.test a2317dcd27b1d087ee3878b30e0a59c593c98b7a\nF test/fts1o.test d1554caede42bba2c82fe613bcc921856c196b752449ead0470fac52a20fd3b8\nF test/fts1porter.test d86e9c3e0c7f8ff95add6582b4b585fb4e02b96d\nF test/fts2.test e3fb95f96a650411574efc136f3fb10eef479ed7\nF test/fts2a.test 473a5c8b473a4e21a8e3fddaed1e59666e0c6ab7\nF test/fts2b.test 964abc0236c849c07ca1ae496bb25c268ae94816\nF test/fts2c.test ffb5a35230ac72c4354535c547965ce6824537c0\nF test/fts2d.test b7eaa671ca9a16997f3e5b158ee777ae21052b0b\nF test/fts2e.test 2da13dbc2d009105f42196845c1e1ce136c03d38\nF test/fts2f.test cf84096235991709c1e61caa389632aa0a4f976d\nF test/fts2g.test 3d26fe171bda6133ebf5a380731d70eaa2ef2f6f73d79769cf8946e622b6d597\nF test/fts2h.test 223af921323b409d4b5b18ff4e51619541b174bb\nF test/fts2i.test 1b22451d1f13f7c509baec620dc3a4a754885dd6\nF test/fts2j.test 298fa1670aa21cd445b282d139b70c72e7ade12b\nF test/fts2k.test c7ebf4a4937594aa07459e3e1bca1251c1be8659\nF test/fts2l.test 3333336621524cf7d60bb62d6ef6ab69647866ed\nF test/fts2m.test 4b30142ead6f3ed076e880a2a464064c5ad58c51\nF test/fts2n.test 12b9c5352128cebd1c6b8395e43788d4b09087c2\nF test/fts2o.test 4054ac7433eb5440f1b1d200cfa449342dc4aabd991759139813e17c73e5bf9a\nF test/fts2p.test 4b48c35c91e6a7dbf5ac8d1e5691823cc999aafb\nF test/fts2q.test b2fbbe038b7a31a52a6079b215e71226d8c6a682\nF test/fts2r.test b154c30b63061d8725e320fba1a39e2201cadd5e\nF test/fts2token.test d8070b241a15ff13592a9ae4a8b7c171af6f445a\nF test/fts3.test 672a040ea57036fb4b6fdc09027c18d7d24ab654\nF test/fts3_common.tcl dffad248f9ce090800e272017d2898005c28ee6314fc1dd5550643a02666907a\nF test/fts3aa.test 814d60a1ba30b4a71d8f9306a6564bc7b636dd6efacd2ad80306f9b23ef3ebee\nF test/fts3ab.test 7f6cf260ae80dda064023df8e8e503e9a412b91f\nF test/fts3ac.test 636ed7486043055d4f126a0e385f2d5a82ebbf63\nF test/fts3ad.test e40570cb6f74f059129ad48bcef3d7cbc20dda49\nF test/fts3ae.test ce32a13b34b0260928e4213b4481acf801533bda\nF test/fts3af.test d394978c534eabf22dd0837e718b913fd66b499c\nF test/fts3ag.test c003672a215124df7fc6000036d896f498b26b53\nF test/fts3ah.test dc9f66c32c296f1bc8bcc4535126bddfeca62894\nF test/fts3ai.test 24058fdc6e9e5102c1fd8459591b114b6a85d285\nF test/fts3aj.test 0ed71e1dd9b03b843a857dc3eb9b15630e0104fc\nF test/fts3ak.test bd14deafe9d1586e8e9bf032411026ac4f8c925d\nF test/fts3al.test 07d64326e79bbdbab20ee87fc3328fbf01641c9f\nF test/fts3am.test 218aa6ba0dfc50c7c16b2022aac5c6be593d08d8\nF test/fts3an.test a49ccadc07a2f7d646ec1b81bc09da2d85a85b18\nF test/fts3ao.test 266989148fec6d9f1bb6c5382f7aa3dcea0e9cd444576e28dd2b9287ac7dd220\nF test/fts3atoken.test bef8a163490098a6b8a6ec5f5407269a3a15b9902c0fcf5e962825a81675b3a0\nF test/fts3auto.test bfe0857bd0b69d68dd685a931b58486411a69f5794a7f6d6fe808bfa31a99614\nF test/fts3aux1.test 7a170e172afdbceb67f5baa05941fd4fbf56af42f61daa3d140f4b4bf4cb68f6\nF test/fts3aux2.test 2459e7fa3e22734aed237d1e2ae192f5541c4d8b218956ad2d90754977bf907f\nF test/fts3b.test c15c4a9d04e210d0be67e54ce6a87b927168fbf9c1e3faec8c1a732c366fd491\nF test/fts3c.test fc723a9cf10b397fdfc2b32e73c53c8b1ec02958\nF test/fts3comp1.test a0f5b16a2df44dd0b15751787130af2183167c0c\nF test/fts3conf.test c84bbaec81281c1788aa545ac6e78a6bd6cde2bdbbce2da261690e3659f5a76b\nF test/fts3corrupt.test ce7f7b5eaeee5f1804584d061b978d85e64abf2af9adaa7577589fac6f7eae01\nF test/fts3corrupt2.test bf55c3fa0b0dc8ea1c0fe5543623bd27714585da6a129038fd6999fe3b0d25f3\nF test/fts3corrupt3.test 0d5b69a0998b4adf868cc301fc78f3d0707745f1d984ce044c205cdb764b491f\nF test/fts3corrupt4.test 00ecd7605d5b1478252a3b7c2465de2d427906b8cb73b7acb92628bab81f9903\nF test/fts3corrupt5.test 0549f85ec4bd22e992f645f13c59b99d652f2f5e643dac75568bfd23a6db7ed5\nF test/fts3cov.test 7eacdbefd756cfa4dc2241974e3db2834e9b372ca215880e00032222f32194cf\nF test/fts3d.test 2bd8c97bcb9975f2334147173b4872505b6a41359a4f9068960a36afe07a679f\nF test/fts3defer.test f4c20e4c7153d20a98ee49ee5f3faef624fefc9a067f8d8d629db380c4d9f1de\nF test/fts3defer2.test 3da52ca2114e300e9971eee2f0cc1a2e5f27e6a9ee67957d49e63e41fdfcc0e7\nF test/fts3defer3.test dd53fc13223c6d8264a98244e9b19abd35ed71cd\nF test/fts3drop.test 1b906e293d6773812587b3dc458cb9e8f3f0c297\nF test/fts3e.test 1f6c6ac9cc8b772ca256e6b22aaeed50c9350851\nF test/fts3expr.test ebae205a7a89446c32583bcd492dcb817b9f6b31819bb4dde2583bb99c77e526\nF test/fts3expr2.test 18da930352e5693eaa163a3eacf96233b7290d1a\nF test/fts3expr3.test c4d4a7d6327418428c96e0a3a1137c251b8dfbf8\nF test/fts3expr4.test f5b2832549f01b1f7f73389fa21d4b875499bc95bf7c8b36271844888c6a0938\nF test/fts3expr5.test a5b9a053becbdb8e973fbf4d6d3abaabeb42d511d1848bd57931f3e0a1cf983e\nF test/fts3fault.test 798e45af84be7978ca33d5bdc94246eb44724db24174b5d8e9b1ac46c57fb08d\nF test/fts3fault2.test 6a17a11d8034b1c4eca9f3091649273d56c49ff049e2173df8060f94341e9da0\nF test/fts3first.test dbdedd20914c8d539aa3206c9b34a23775644641\nF test/fts3fuzz001.test e3c7b0ce9b04cc02281dcc96812a277f02df03cd7dc082055d87e11eb18aaf56\nF test/fts3join.test 949b4f5ae3ae9cc2423cb865d711e32476bdb205ab2be923fdf48246e4a44166\nF test/fts3malloc.test b0e4c133b8d61d4f6d112d8110f8320e9e453ef6\nF test/fts3matchinfo.test aa66cc50615578b30f6df9984819ae5b702511cf8a94251ec7c594096a703a4a\nF test/fts3misc.test c47d2c1ea1351c51c32c688545b02c8180a3f22156d1aedc206a8c09b9d95905\nF test/fts3near.test 7e3354d46f155a822b59c0e957fd2a70c1d7e905\nF test/fts3offsets.test b85fd382abdc78ebce721d8117bd552dfb75094c\nF test/fts3prefix.test fa794eaab0bdae466494947b0b153d7844478ab2\nF test/fts3prefix2.test e1f0a822ca661dced7f12ce392e14eaf65609dce\nF test/fts3query.test ca033ff2ebcc22c69d89032fb0bc1850997d31e7e60ecd26440796ba1654e78f\nF test/fts3rank.test cd99bc83a3c923c8d52afd90d86979cf05fc41849f892faeac3988055ef37b99\nF test/fts3rnd.test 1320d8826a845e38a96e769562bf83d7a92a15d0\nF test/fts3shared.test 57e26a801f21027b7530da77db54286a6fe4997e\nF test/fts3snippet.test 430bb5ace2b31ccd99de4d71775d956da832c114c4b3e39589748f114458647c\nF test/fts3sort.test ed34c716a11cc2009a35210e84ad5f9c102362ca\nF test/fts3tok1.test a663f4cac22a9505400bc22aacb818d7055240409c28729669ea7d4cc2120d15\nF test/fts3tok_err.test 52273cd193b9036282f7bacb43da78c6be87418d\nF test/fts3varint.test 0b84a3fd4eba8a39f3687523804d18f3b322e6d4539a55bf342079c3614f2ada\nF test/fts4aa.test 4338ea7a67f7e19269bf6e6fb4a291352aa32296e7daed87f9823d57016a1ef7\nF test/fts4check.test 6259f856604445d7b684c9b306b2efb6346834c3f50e8fc4a59a2ca6d5319ad0\nF test/fts4content.test 73bbb123420d2c46ef2fb3b24761e9acdb78b0877179d3a5d7d57aada08066f6\nF test/fts4docid.test e33c383cfbdff0284685604d256f347a18fdbf01\nF test/fts4growth.test 289833c34ad45a5e6e6133b53b6a71647231fb89d36ddcb8d9c87211b6721d7f\nF test/fts4growth2.test 13ad4e76451af6e6906c95cdc725d01b00044269\nF test/fts4incr.test 4e353a0bd886ea984e56fce9e77724fc923b8d0d\nF test/fts4langid.test 2168ba330af34f8a1c8832de0aab4c4b6fa195a16419c9c0c8aad59ceb6ff714\nF test/fts4lastrowid.test 185835895948d5325c7710649824042373b2203149abe8024a9319d25234dfd7\nF test/fts4merge.test e2b2ec21e287d54ec09824ccfb41e66896eeca568fc818ba0e0eb2efd94c35d2\nF test/fts4merge2.test 5faa558d1b672f82b847d2a337465fa745e46891\nF test/fts4merge3.test 8d9ccb4a3d41c4c617a149d6c4b13ad02de797d0\nF test/fts4merge4.test d895b1057a7798b67e03455d0fa50e9ea836c47b\nF test/fts4merge5.test 69932d85cda8a1c4dcfb742865900ed8fbda51724b8cf9a45bbe226dfd06c596\nF test/fts4noti.test 5553d7bb2e20bf4a06b23e849352efc022ce6309\nF test/fts4onepass.test d69ddc4ee3415e40b0c5d1d0408488a87614d4f63ba9c44f3e52db541d6b7cc7\nF test/fts4opt.test 0fd0cc84000743ff2a883b9b84b4a5be07249f0ba790c8848a757164cdd46b2a\nF test/fts4record.test a48508f69a84c9287c8019d3a1ae712f5730d8335ffaf8e2101e691d078950bb\nF test/fts4rename.test 15fd9985c2bce6dea20da2245b22029ec89bd4710ed317c4c53abbe3cfd0c880\nF test/fts4umlaut.test fcaca4471de7e78c9d1f7e8976e3e8704d7d8ad979d57a739d00f3f757380429\nF test/fts4unicode.test ceca76422abc251818cb25dabe33d3c3970da5f7c90e1540f190824e6b3a7c95\nF test/full.test 6b3c8fb43c6beab6b95438c1675374b95fab245d\nF test/func.test 7d425f9a6eaa2c50baa751bef6b0c6c6af1751e0e0e1eb4863d426bb4c886788\nF test/func2.test 772d66227e4e6684b86053302e2d74a2500e1e0f\nF test/func3.test 2bb0f31ab7baaed690b962a88544d7be6b34fa389364bc36a44e441ed3e3f1e6\nF test/func4.test 6beacdfcb0e18c358e6c2dcacf1b65d1fa80955f\nF test/func5.test cdd224400bc3e48d891827cc913a57051a426fa4\nF test/func6.test 90e42b64c4f9fb6f04f44cb8a1da586c8542502e926b19c76504fe74ff2a9b7c\nF test/fuzz-oss1.test e58330d01cbbd8215ee636b17a03fe220b37dbfa\nF test/fuzz.test 96083052bf5765e4518c1ba686ce2bab785670d1\nF test/fuzz2.test 76dc35b32b6d6f965259508508abce75a6c4d7e1\nF test/fuzz3.test 9c813e6613b837cb7a277b0383cd66bfa07042b4cf0317157c35852f30043c31\nF test/fuzz4.test c229bcdb45518a89e1d208a21343e061503460ac69fae1539320a89f572eb634\nF test/fuzz_common.tcl a87dfbb88c2a6b08a38e9a070dabd129e617b45b\nF test/fuzz_malloc.test f348276e732e814802e39f042b1f6da6362a610af73a528d8f76898fde6b22f2\nF test/fuzzcheck.c 0df68e0df3b93a8c8fc24c9873127c7d78024b51444193545f985dbc90ac024e\nF test/fuzzdata1.db d36e88741b4f23bcbaaf55b006290669d03c6c891cf13c7b3a53bc1b097b693f\nF test/fuzzdata2.db 128b3feeb78918d075c9b14b48610145a0dd4c8d6f1ca7c2870c7e425f5bf31f\nF test/fuzzdata3.db c6586d3e3cef0fbc18108f9bb649aa77bfc38aba\nF test/fuzzdata4.db b502c7d5498261715812dd8b3c2005bad08b3a26e6489414bd13926cd3e42ed2\nF test/fuzzdata5.db e35f64af17ec48926481cfaf3b3855e436bd40d1cfe2d59a9474cb4b748a52a5\nF test/fuzzdata6.db 92a80e4afc172c24f662a10a612d188fb272de4a9bd19e017927c95f737de6d7\nF test/fuzzdata7.db e7a86fd83dda151d160445d542e32e5c6019c541b3a74c2a525b6ac640639711\nF test/fuzzdata8.db b45368bbe9f86d40d30603e8f780ac29807cbcc951a18d7a7fd9d0c0e904706e\nF test/fuzzer1.test 3d4c4b7e547aba5e5511a2991e3e3d07166cfbb8\nF test/fuzzer2.test a85ef814ce071293bce1ad8dffa217cbbaad4c14\nF test/fuzzerfault.test 8792cd77fd5bce765b05d0c8e01b9edcf8af8536\nF test/gcfault.test dd28c228a38976d6336a3fc42d7e5f1ad060cb8c\nF test/gencol1.test 69008f45faa46b7293cc6ce1236f356a7aff6061b0547334786b54a49b2f98cb\nF test/genesis.tcl 1e2e2e8e5cc4058549a154ff1892fe5c9de19f98\nF test/having.test e4098a4b8962f9596035c3b87a8928a10648acc509f1bb8d6f96413bbf79a1b3\nF test/hexlit.test 4a6a5f46e3c65c4bf1fa06f5dd5a9507a5627751\nF test/hidden.test 23c1393a79e846d68fd902d72c85d5e5dcf98711\nF test/hook.test 1604b3b2f5931430087540404555c1b6be3618600b81558657c66b533ed70b13\nF test/hook2.test b9ff3b8c6519fb67f33192f1afe86e7782ee4ac8\nF test/icu.test 41aa8847745a879b897a7febea0f8f9efc8e67fe8bf680589b6e07c7b0a1569a\nF test/ieee754.test 806fc0ce7f305f57e3331eaceeddcfec9339e607\nF test/imposter1.test c3f1db2d3db2c24611a6596a3fc0ffc14f1466c8\nF test/in.test 3e9bd58597a444123a40a9ac94cae0fec8897e17e9f519b02fc370bcf5ba5175\nF test/in2.test 5d4c61d17493c832f7d2d32bef785119e87bde75\nF test/in3.test 3cbf58c87f4052cee3a58b37b6389777505aa0c0\nF test/in4.test 0f77b0ff371549e6a119d0356be10bdba72258162e9701e83527a560482f5e98\nF test/in5.test b32ce7f4a93f44c5dee94af16886d922cc16ebe33c8e1765c73d4049d0f4b40f\nF test/in6.test 62d943a02f722948f4410ee0b53c3cb39acd7c41afb083df8d7004238fe90a20\nF test/incrblob.test c9b96afc292aeff43d6687bcb09b0280aa599822\nF test/incrblob2.test a494c9e848560039a23974b9119cfc2cf3ad3bd15cc2694ee6367ae537ef8f1f\nF test/incrblob3.test d8d036fde015d4a159cd3cbae9d29003b37227a4\nF test/incrblob4.test 21a52a6843a56cdcce968c6a86b72a7066d0e6ba\nF test/incrblob_err.test 89372a28f1d98254f03fed705f9efcd34ef61a674df16d2dbb4726944a2de5e9\nF test/incrblobfault.test 74dd8ac108304cea0b4a0df6df63a1567e558758\nF test/incrcorrupt.test 6c567fbf870aa9e91866fe52ce6f200cd548939a\nF test/incrvacuum.test 2aaee202b1f230e55779f70d155f6ba67bbdff8481d650214d256ab0f97d4a2b\nF test/incrvacuum2.test 7d26cfda66c7e55898d196de54ac4ec7d86a4e3d\nF test/incrvacuum3.test 75256fb1377e7c39ef2de62bfc42bbff67be295a\nF test/incrvacuum_ioerr.test 6ae2f783424e47a0033304808fe27789cf93e635\nF test/index.test a2e948ed949e575487b5c1d521767d4584ac42d352f2dcd8e48004638e7bc7dc\nF test/index2.test f835d5e13ca163bd78c4459ca15fd2e4ed487407\nF test/index3.test 51685f39345462b84fcf77eb8537af847fdf438cc96b05c45d6aaca4e473ade0\nF test/index4.test ab92e736d5946840236cd61ac3191f91a7856bf6\nF test/index5.test 8621491915800ec274609e42e02a97d67e9b13e7\nF test/index6.test f172653b35b20233e59200e8b92a76db61bf7285437bf777b93b306ba26a47e7\nF test/index7.test 1d764c0cca45f5a76150b08e127ccc8d52492cfa788b5fafed4be784a351b020\nF test/index8.test bc2e3db70e8e62459aaa1bd7e4a9b39664f8f9d7\nF test/index9.test 0aa3e509dddf81f93380396e40e9bb386904c1054924ba8fa9bcdfe85a8e7721\nF test/indexedby.test a52c8c6abfae4fbfb51d99440de4ca1840dbacc606b05e29328a2a8ba7cd914e\nF test/indexexpr1.test 284e119999d132cc8bf37735a928c9859b28e8e295d02b7a6a4f93977c7f9ba5\nF test/indexexpr2.test dba11dbb0a58fcba4cd694f46b4004976123b81b0501f525d43c9be59f0207b1\nF test/indexfault.test 98d78a8ff1f5335628b62f886a1cb7c7dac1ef6d48fa39c51ec871c87dce9811\nF test/init.test 15c823093fdabbf7b531fe22cf037134d09587a7\nF test/insert.test 4e3f0de67aac3c5be1f4aaedbcea11638f1b5cdc9a3115be14d19aa9db7623c6\nF test/insert2.test 4d14b8f1b810a41995f6286b64a6943215d52208\nF test/insert3.test 1b7db95a03ad9c5013fdf7d6722b6cd66ee55e30\nF test/insert4.test fb9e0f752c75f453555990250b449f6d123ae6a3ebf054d14e4470de4498dce3\nF test/insert5.test 394f96728d1258f406fe5f5aeb0aaf29487c39a6\nF test/insertfault.test ac63d14ea3b49c573673a572f4014b9117383a03e497c58f308b5c776e4a7f74\nF test/instr.test 107df2b9b74a4b59315916b575590a08f2a714de0754abe541f10a0971d0a2a4\nF test/instrfault.test 0f870b218ea17cd477bb19ed330eecdb460dd53a\nF test/intarray.test bb976b0b3df0ebb6a2eddfb61768280440e672beba5460ed49679ea984ccf440\nF test/interrupt.test 16ea879ec728cb76414c148c5f24afd5d1f91054\nF test/interrupt2.test e4408ca770a6feafbadb0801e54a0dcd1a8d108d\nF test/intpkey.test ac71107a49a06492b69b82aafaf225400598d3c8\nF test/intreal.test 2a87e85a5949bd55e41ef04c58f5800587c5380bdbc559ff1c79b614b0e6a533\nF test/io.test f95bca1783b01ea7761671560d023360d2dfa4cc\nF test/ioerr.test 470fcc78e9cd352d162baf782fe301ea807d764241f58a48fc58109c2dfcdb6b\nF test/ioerr2.test 2593563599e2cc6b6b4fcf5878b177bdd5d8df26\nF test/ioerr3.test d3cec5e1a11ad6d27527d0d38573fbff14c71bdd\nF test/ioerr4.test f130fe9e71008577b342b8874d52984bd04ede2c\nF test/ioerr5.test 2edfa4fb0f896f733071303b42224df8bedd9da4\nF test/ioerr6.test a395a6ab144b26a9e3e21059a1ab6a7149cca65b\nF test/istrue.test 75327829744e65cc8700e69340b8e6c192e10e39dfae7ccb0e970d3c4f49090a\nF test/join.test 99e1d82fada7a1df9002a7b1160bd231c91077b9372492d5e18bfa1d1694d43c\nF test/join2.test 10f7047e723ebd68b2f47189be8eed20451a6f665d8bf46f1774c640d1062417\nF test/join3.test 6f0c774ff1ba0489e6c88a3e77b9d3528fb4fda0\nF test/join4.test 1a352e4e267114444c29266ce79e941af5885916\nF test/join5.test 3a96dc62f0b45402d7207e22d1993fe0c2fce1c57644a11439891dd62b990eb7\nF test/join6.test cfe6503791ceb0cbb509966740286ec423cbf10b\nF test/journal1.test c7b768041b7f494471531e17abc2f4f5ebf9e5096984f43ed17c4eb80ba34497\nF test/journal2.test 9dac6b4ba0ca79c3b21446bbae993a462c2397c4\nF test/journal3.test 7c3cf23ffc77db06601c1fcfc9743de8441cb77db9d1aa931863d94f5ffa140e\nF test/jrnlmode.test 9b5bc01dac22223cb60ec2d5f97acf568d73820794386de5634dcadbea9e1946\nF test/jrnlmode2.test 8759a1d4657c064637f8b079592651530db738419e1d649c6df7048cd724363d\nF test/jrnlmode3.test 556b447a05be0e0963f4311e95ab1632b11c9eaa\nF test/json101.test bb71538005f2d9e18620bdd3b76839a93ca0be61903eb8d751a64e78cf99b8fb\nF test/json102.test eeb54efa221e50b74a2d6fb9259963b48d7414dca3ce2fdfdeed45cb28487bc1\nF test/json103.test aff6b7a4c17d5a20b487a7bc1a274bfdc63b829413bdfb83bedac42ec7f67e3b\nF test/json104.test 317f4ec4b2d87afbba4d2460cf5be297aea76f2285eb618d276dbcd40a50950f\nF test/json105.test 45f7d6a9a54c85f8a9589b68d3e7a1f42d02f2359911a8cdbad1f9988f571173\nF test/keyword1.test 37ef6bba5d2ed5b07ecdd6810571de2956599dff\nF test/kvtest.c 94da54bb66aae7a54e47cf7e4ea4acecc0f217560f79ad3abfcc0361d6d557ba\nF test/lastinsert.test 42e948fd6442f07d60acbd15d33fb86473e0ef63\nF test/laststmtchanges.test ae613f53819206b3222771828d024154d51db200\nF test/lemon-test01.y 58b764610fd934e189ffbb0bbfa33d171b9cb06019b55bdc04d090d6767e11d7\nF test/like.test 3d702d79bf871fa32985b1ce334294c587e3948d3ab972001e811a58577e8b3c\nF test/like2.test 3b2ee13149ba4a8a60b59756f4e5d345573852da\nF test/like3.test 4f940ad275c006319950054a7a65661f476772171b82b6fdf795e4dda36f246f\nF test/limit.test 0c99a27a87b14c646a9d583c7c89fd06c352663e\nF test/limit2.test 9409b033284642a859fafc95f29a5a6a557bd57c1f0d7c3f554bd64ed69df77e\nF test/loadext.test faa4f6eed07a5aac35d57fdd7bc07f8fc82464cfd327567c10cf0ba3c86cde04\nF test/loadext2.test 0408380b57adca04004247179837a18e866a74f7\nF test/lock.test be4fe08118fb988fed741f429b7dd5d65e1c90db\nF test/lock2.test 5242d8ac4e2d59c403aebff606af449b455aceff\nF test/lock3.test f271375930711ae044080f4fe6d6eda930870d00\nF test/lock4.test 27143363eda1622f03c133efc8db808fc331afd973486cb571ea71cd717d37b8\nF test/lock5.test c6c5e0ebcb21c61a572870cc86c0cb9f14cede38\nF test/lock6.test ad5b387a3a8096afd3c68a55b9535056431b0cf5\nF test/lock7.test 49f1eaff1cdc491cc5dee3669f3c671d9f172431\nF test/lock_common.tcl 2f3f7f2e9637f93ccf609df48ef5b27a50278b6b1cd752b445d52262e5841413\nF test/lookaside.test 5a828e7256f1ee4da8e1bdaa03373a3ccdb0f1ff98dfa82e9b76cb41a45b1083\nF test/main.test 6bbb3999fd461eb8fb335cbab97409a3d7f91bbb8da60635e8be3e4a04a77772\nF test/make-where7.tcl 05c16b5d4f5d6512881dfec560cb793915932ef9\nF test/malloc.test 18dd1c4188c81ca79cf123527c71b19ee0c31feb9947fdffb0dc6ceb1436816a\nF test/malloc3.test 6e88bae6312854a4adb4ecc2a6a5ea8c59b4db778b724ba718e1c43fc8c3c136\nF test/malloc4.test 957337613002b7058a85116493a262f679f3a261\nF test/malloc5.test 2e4ad7684a13389a44a840499cd47173a8d05f22f082d7d083eece433a7a64eb\nF test/malloc6.test 2f039d9821927eacae43e1831f815e157659a151\nF test/malloc7.test 7c68a32942858bc715284856c5507446bba88c3a\nF test/malloc8.test 9b7a3f8cb9cf0b12fff566e80a980b1767bd961d\nF test/malloc9.test 2307c6ee3703b0a21391f3ea92388b4b73f9105e\nF test/mallocA.test aea76f2dd8bcc2d19748f6b911e876cefda74a563753bf26af046e9d34bb97e6\nF test/mallocAll.test 98f1be74bc9f49a858bc4f361fc58e26486798be\nF test/mallocB.test bc475ab850cda896142ab935bbfbc74c24e51ed6\nF test/mallocC.test 3dffe16532f109293ce1ccecd0c31dca55ef08c4\nF test/mallocD.test f78c295e8e18ea3029e65ca08278690e00c22100\nF test/mallocE.test db1ed69d7eded1b080952e2a7c37f364ad241b08\nF test/mallocF.test 2d5c590ebc2fc7f0dcebdf5aa8498b9aed69107e\nF test/mallocG.test 0ff91b65c50bdaba680fb75d87fe4ad35bb7934f\nF test/mallocH.test 79b65aed612c9b3ed2dcdaa727c85895fd1bfbdb\nF test/mallocI.test 6c23a71df077fa5d387be90e7e669c5b368ca38a\nF test/mallocJ.test b5d1839da331d96223e5f458856f8ffe1366f62e\nF test/mallocK.test 1f4b5efbf61715ab79b20b38739ff4b3d110ceb53f54e5db6da1f01c083707ab\nF test/mallocL.test fb311ff80afddf3b1a75e52289081f4754d901dc\nF test/mallocM.test 78bbe9d3da84a5c679123cdb40d7b2010b18fc46e13897e4f253c6ba6fbff134\nF test/malloc_common.tcl aac62499b76be719fac31e7a3e54a7fd53272e7f\nF test/malloctraceviewer.tcl b7a54595270c1d201abf1c3f3d461f27eaf24cdef623ad08a0fe5e411264c8a9\nF test/manydb.test 28385ae2087967aa05c38624cec7d96ec74feb3e\nF test/mem5.test c6460fba403c5703141348cd90de1c294188c68f\nF test/memdb.test c1f2a343ad14398d5d6debda6ea33e80d0dafcc7\nF test/memdb1.test 58d92c2bf622cc5f0f41461e1b35cf64f3f787199544c2c1dada37d88753f9d4\nF test/memleak.test 10b9c6c57e19fc68c32941495e9ba1c50123f6e2\nF test/memsubsys1.test 9e7555a22173b8f1c96c281ce289b338fcba2abe8b157f8798ca195bbf1d347e\nF test/memsubsys2.test 3e4a8d0c05fd3e5fa92017c64666730a520c7e08\nF test/minmax.test 6751e87b409fe11b02e70a306d846fa544e25a41\nF test/minmax2.test 1edf66901ddfab26ae1e04165e8da834c8d3284e2b20aefb26b80ef217962eab\nF test/minmax3.test cc1e8b010136db0d01a6f2a29ba5a9f321034354\nF test/minmax4.test 272ca395257f05937dc96441c9dde4bc9fbf116a8d4fa02baeb0d13d50e36c87\nF test/misc1.test 7ce84b25df9872e7d7878613a96815d2ba5bc974ac4e15a50118dde8f3917599\nF test/misc2.test 00d7de54eda90e237fc9a38b9e5ccc769ebf6d4d\nF test/misc3.test cf3dda47d5dda3e53fc5804a100d3c82be736c9d\nF test/misc4.test 10cd6addb2fa9093df4751a1b92b50440175dd5468a6ec84d0386e78f087db0e\nF test/misc5.test c4aeaa0fa28faa08f2485309c38db4719e6cd1364215d5687a5b96d340a3fa58\nF test/misc6.test 953cc693924d88e6117aeba16f46f0bf5abede91\nF test/misc7.test 4f21954012e4eb0a923c54a311f38c81bf6798ccdd7b51584db46d4007f63daa\nF test/misc8.test 8fb0f31d7a8aed484d759773ab8ad12ec746a477f4a67394a4af0e677494c3ca\nF test/misuse.test 9e7f78402005e833af71dcab32d048003869eca5abcaccc985d4f8dc1d86bcc7\nF test/mjournal.test 28a08d5cb5fb5b5702a46e19176e45e964e0800d1f894677169e79f34030e152\nF test/mmap1.test fb04e0c10492455007624ade884ca0c8852ff3e4e11d95408f9709ca2ef7f626\nF test/mmap2.test 9d6dd9ddb4ad2379f29cc78f38ce1e63ed418022\nF test/mmap3.test b3c297e78e6a8520aafcc1a8f140535594c9086e\nF test/mmap4.test 2e2b4e32555b58da15176e6fe750f17c9dcf7f93\nF test/mmapfault.test d4c9eff9cd8c2dc14bc43e71e042f175b0a26fe3\nF test/mmapwarm.test 2272005969cd17a910077bd5082f70bc1fefad9a875afec7fc9af483898ecaf3\nF test/multiplex.test dc0d67b66f84b484a83cb8bbdf3f0a7f49562ccd\nF test/multiplex2.test 580ca5817c7edbe4cc68fa150609c9473393003a\nF test/multiplex3.test d228f59eac91839a977eac19f21d053f03e4d101\nF test/multiplex4.test e8ae4c4bd70606a5727743241f13b5701990abe4\nF test/mutex1.test ea2cc74d97f077b9e74c84cbd024f14d79a8126f\nF test/mutex2.test bfeaeac2e73095b2ac32285d2756e3a65e681660\nF test/nan.test 437d40e6d0778b050d7750726c0cbd2c9936b81962926e8f8c48ca698f00f4d1\nF test/nockpt.test 8c43b25af63b0bd620cf1b003529e37b6f1dc53bd22690e96a1bd73f78dde53a\nF test/nolock.test f196cf8b8fbea4e2ca345140a2b3f3b0da45c76e\nF test/normalize.test f23b6c5926c59548635fcf39678ac613e726121e073dd902a3062fbb83903b72\nF test/notify1.test 669b2b743618efdc18ca4b02f45423d5d2304abf\nF test/notify2.test 2ecabaa1305083856b7c39cf32816b612740c161\nF test/notify3.test 10ff25cde502e72a92053a2f215d64bece4ef934\nF test/notnull.test a37b663d5bb728d66fc182016613fb8e4a0a4bbf3d75b8876a7527f7d4ed3f18\nF test/null.test 0dcce4f04284ec66108c503327ad6d224c0752b3\nF test/nulls1.test c8fc1b223f06e60007e0cd3e498ccb10195cf75a18fc3312508b3cf679ecb806\nF test/numcast.test 5d126f7f581432e86a90d1e35cac625164aec4a1\nF test/numindex1.test 20a5450d4b056e48cd5db30e659f13347a099823\nF test/offset1.test f06b83657bcf26f9ce805e67450e189e282143b2\nF test/openv2.test 0d3040974bf402e19b7df4b783e447289d7ab394\nF test/optfuzz-db01.c a0c256905c8ac79f9a5de2f374a3d9f757bef0dca2a238dc7c10cc8a38031834\nF test/optfuzz-db01.txt 21f6bdeadc701cf11528276e2a55c70bfcb846ba42df327f979bd9e7b6ce7041\nF test/optfuzz.c 50e330304eb1992e15ddd11f3daaad9bcc0d9aaad09cb2bcc77f9515df2e88b1\nF test/orderby1.test e4501f54721f804ca56922e253403ac6775f88e9f07569994ce99212b3ca5b10\nF test/orderby2.test bc11009f7cd99d96b1b11e57b199b00633eb5b04\nF test/orderby3.test 8619d06a3debdcd80a27c0fdea5c40b468854b99\nF test/orderby4.test 4d39bfbaaa3ae64d026ca2ff166353d2edca4ba4\nF test/orderby5.test 5f4d6cb93cc2f6d3f4228354310a2ce1fbd95d5bbffcba8c6482eeb62a466407\nF test/orderby6.test 8b38138ab0972588240b3fca0985d2e400432859\nF test/orderby7.test 3d1383d52ade5b9eb3a173b3147fdd296f0202da\nF test/orderby8.test 23ef1a5d72bd3adcc2f65561c654295d1b8047bd\nF test/orderby9.test 87fb9548debcc2cd141c5299002dd94672fa76a3\nF test/orderbyA.test df608e59efc2ef50c1eddf1a773b272de3252e9401bfec86d04b52fd973866d5\nF test/oserror.test 1fc9746b83d778e70d115049747ba19c7fba154afce7cc165b09feb6ca6abbc5\nF test/ossfuzz.c 9636dad2092a05a32110df0ca06713038dd0c43dd89a77dabe4b8b0d71096715\nF test/ossshell.c f125c5bd16e537a2549aa579b328dd1c59905e7ab1338dfc210e755bb7b69f17\nF test/ovfl.test 199c482696defceacee8c8e0e0ef36da62726b2f\nF test/pager1.test 1e9ee778bdeaf4f7f09997d029cdaca6a42dfc2092edafe4f5e590acbf1eab13\nF test/pager2.test 67b8f40ae98112bcdba1f2b2d03ea83266418c71\nF test/pager3.test 4e9a83d6ca0838d7c602c9eb93d1357562d9059c1e02ffb138a8271020838370\nF test/pager4.test a122e9e6925d5b23b31e3dfef8c6a44bbf19590e\nF test/pagerfault.test 63c5da625562c66345ab4528790327ca63db2f6f9cbae2aba8cb7c51de3d1628\nF test/pagerfault2.test caf4c7facb914fd3b03a17b31ae2b180c8d6ca1f\nF test/pagerfault3.test 1003fcda009bf48a8e22a516e193b6ef0dd1bbd8\nF test/pageropt.test 84e4cc5cbca285357f7906e99b21be4f2bf5abc0\nF test/pagesize.test 5769fc62d8c890a83a503f67d47508dfdc543305\nF test/parser1.test 6ccdf5e459a5dc4673d3273dc311a7e9742ca952dd0551a6a6320d27035ce4b3\nF test/pcache.test c8acbedd3b6fd0f9a7ca887a83b11d24a007972b\nF test/pcache2.test af7f3deb1a819f77a6d0d81534e97d1cf62cd442\nF test/percentile.test 4243af26b8f3f4555abe166f723715a1f74c77ff\nF test/permutations.test 8587800fe1a0eb01456a3f4500b821e54e3347e78acf11dbf05f4990530f6cee\nF test/pg_common.tcl 222a1bad1c41c308fa366313cd7b51b3be7e9b21c8736a421b974ac941693b54\nF test/pragma.test 59becdfd720b80d463ab750f69f7118fde10dfd556aa5d554f3bf6b7e5ea7533\nF test/pragma2.test e5d5c176360c321344249354c0c16aec46214c9f\nF test/pragma3.test 8300aa9c63cff1027006ca34bf413a148abbd6dcd471fa9a1ded322fe18c0df9\nF test/pragma4.test 10c624e45a83c0096a82a7579a5ff658542391d3b77355192da6572c8c17c00b\nF test/pragma5.test 2be6a44c91e8585ccb4c71c5f221ccebe0692a49557215a912916ed391188959\nF test/pragmafault.test 275edaf3161771d37de60e5c2b412627ac94cef11739236bec12ed1258b240f8\nF test/prefixes.test b524a1c44bffec225b9aec98bd728480352aa8532ac4c15771fb85e8beef65d9\nF test/printf.test 0300699733e53101b2ce48800518427249edd4053bb50fa0621c6607482f0fdb\nF test/printf2.test 30b5dd0b4b992dc5626496846ecce17ff592cacbcb11c3e589f3ac4d7e129dae\nF test/progress.test ebab27f670bd0d4eb9d20d49cef96e68141d92fb\nF test/ptrchng.test ef1aa72d6cf35a2bbd0869a649b744e9d84977fc\nF test/pushdown.test 5e72c51c5e33253ed639ccee1e01ce62d62b6eee5ca893cd82334e4ee7b1d7fc\nF test/queryonly.test 5f653159e0f552f0552d43259890c1089391dcca\nF test/quick.test 1681febc928d686362d50057c642f77a02c62e57\nF test/quota-glob.test 32901e9eed6705d68ca3faee2a06b73b57cb3c26\nF test/quota.test bfb269ce81ea52f593f9648316cd5013d766dd2a\nF test/quota2.test 7dc12e08b11cbc4c16c9ba2aa2e040ea8d8ab4b8\nF test/quote.test 626149eda89ee64d81a3790de370f9f0211921b11568a49c28c861f394330508\nF test/randexpr1.tcl 40dec52119ed3a2b8b2a773bce24b63a3a746459\nF test/randexpr1.test eda062a97e60f9c38ae8d806b03b0ddf23d796df\nF test/rbu.test 168573d353cd0fd10196b87b0caa322c144ef736\nF test/rdonly.test 64e2696c322e3538df0b1ed624e21f9a23ed9ff8\nF test/recover.test ccb8c2623902a92ebb76770edd075cb4f75a4760bb7afde38026572c6e79070d\nF test/regexp1.test 497ea812f264d12b6198d6e50a76be4a1973a9d8\nF test/regexp2.test 40e894223b3d6672655481493f1be12012f2b33c\nF test/reindex.test cd9d6021729910ece82267b4f5e1b5ac2911a7566c43b43c176a6a4732e2118d\nF test/releasetest.tcl fb76d8fcc95ac29d6356cd9e52b726ab9e43a24082897618dfbcb7c2b0049153 x\nF test/releasetest_data.tcl 9919fc6ac5bc92f8878fecfd1840db15999f660a6c9f609240b41aa62b885c88\nF test/resetdb.test 8062cf10a09d8c048f8de7711e94571c38b38168db0e5877ba7561789e5eeb2b\nF test/resolver01.test f4022acafda7f4d40eca94dbf16bc5fc4ac30ceb\nF test/rollback.test 06680159bc6746d0f26276e339e3ae2f951c64812468308838e0a3362d911eaa\nF test/rollback2.test bc868d57899dc6972e2b4483faae0e03365a0556941474eec487ae21d8d38bb6\nF test/rollbackfault.test 0e646aeab8840c399cfbfa43daab46fd609cf04a\nF test/round1.test 768018b04522ca420b1aba8a24bd76091d269f3bce3902af3ec6ebcee41ab21e\nF test/rowallock.test 3f88ec6819489d0b2341c7a7528ae17c053ab7cc\nF test/rowhash.test 0bc1d31415e4575d10cacf31e1a66b5cc0f8be81\nF test/rowid.test bfbd7b97d9267660be3c8f28507c4ed7f205196b8877c0db42df347c2e8845e3\nF test/rowvalue.test c39cc0be5e33f5294fc9224216198d6709d713ea948fdf8f42d89568e97912c9\nF test/rowvalue2.test 060d238b7e5639a7c5630cb5e63e311b44efef2b\nF test/rowvalue3.test 3068f508753af69884b12125995f023da0dbb256\nF test/rowvalue4.test 02e35f7762371c2f57ebd856aa056eac56cb27ef7715a0bb31eac1895a745356\nF test/rowvalue5.test c81c7d8cf36711ab37675ad7376084ae2a359cb6\nF test/rowvalue6.test d19b54feb604d5601f8614b15e214e0774c01087\nF test/rowvalue7.test c1cbdbf407029db01f87764097c6ac02a1c5a37efd2776eff32a9cdfdf6f2dba\nF test/rowvalue8.test 5900eddad9e2c3c2e26f1a95f74aafc1232ee5e0\nF test/rowvalue9.test d8dd2c6ecac432dadaa79e41dc2434f007be1b6b\nF test/rowvaluefault.test 7cd9ccc6c2fbdd881672984087aad0491bb75504\nF test/rowvaluevtab.test d166df5b666662de1ebf40d6f3849f8a76b34e17183a6cc7f81b420c462ce447\nF test/rtree.test 0c8d9dd458d6824e59683c19ab2ffa9ef946f798\nF test/run-wordcount.sh 891e89c4c2d16e629cd45951d4ed899ad12afc09\nF test/savepoint.test 1f8a6b1aea9a0d05837adc463d4bf47bd9d0f1c842f1c2a9caccd639baf34bf9\nF test/savepoint2.test 9b8543940572a2f01a18298c3135ad0c9f4f67d7\nF test/savepoint4.test c8f8159ade6d2acd9128be61e1230f1c1edc6cc0\nF test/savepoint5.test 0735db177e0ebbaedc39812c8d065075d563c4fd\nF test/savepoint6.test f41279c5e137139fa5c21485773332c7adb98cd7\nF test/savepoint7.test cde525ea3075283eb950cdcdefe23ead4f700daa\nF test/savepointfault.test f044eac64b59f09746c7020ee261734de82bf9b2\nF test/scanstatus.test 874e35011779b07725a47dbf1dd6282b0ca04af7e028fb0b534ee544b571be42\nF test/schema.test 5dd11c96ba64744de955315d2e4f8992e447533690153b93377dffb2a5ef5431\nF test/schema2.test 906408621ea881fdb496d878b1822572a34e32c5\nF test/schema3.test 1bc1008e1f8cb5654b248c55f27249366eb7ed38\nF test/schema4.test 3b26c9fa916abb6dadf894137adcf41b7796f7b9\nF test/schema5.test 29699b4421f183c8f0e88bd28ce7d75d13ea653e\nF test/schema6.test e4bd1f23d368695eb9e7b51ef6e02ca0642ea2ab4a52579959826b5e7dce1f9b\nF test/schemafault.test 1936bceca55ac82c5efbcc9fc91a1933e45c8d1e1d106b9a7e56c972a5a2a51e\nF test/securedel.test 2f70b2449186a1921bd01ec9da407fbfa98c3a7a5521854c300c194b2ff09384\nF test/securedel2.test 2d54c28e46eb1fd6902089958b20b1b056c6f1c5\nF test/select1.test b887331202618dbdabed92446b661ebd95a55ef3923700af56ed71266e9c1157\nF test/select2.test 352480e0e9c66eda9c3044e412abdf5be0215b56\nF test/select3.test 3905450067c28766bc83ee397f6d87342de868baa60f2bcfd00f286dfbd62cb9\nF test/select4.test 5389d9895968d1196c457d59b3ee6515d771d328\nF test/select5.test df9ec0d218cedceb4fe7b63262025b547b50a55e59148c6f40b60ca25f1d4546\nF test/select6.test 319d45e414cdd321bf17cfacedaf19e3935ad64dac357c53f1492338c6e9b801\nF test/select7.test f659f231489349e8c5734e610803d7654207318f\nF test/select8.test 8c8f5ae43894c891efc5755ed905467d1d67ad5d\nF test/select9.test aebc2bb0c3bc44606125033cbcaac2c8d1f33a95\nF test/selectA.test b8a590f6493cad5b0bb4dfe1709bf7dcda0b6c40bb4caf32d1e36a89eebc8fc5\nF test/selectB.test 954e4e49cf1f896d61794e440669e03a27ceea25\nF test/selectC.test e25243f8ca503e06f252eb0218976d07cfeceac3\nF test/selectD.test fc20452847a01775710090383cfb4423275d2f745fed61f34fbf37573ac0d214\nF test/selectE.test a8730ca330fcf40ace158f134f4fe0eb00c7edbf\nF test/selectF.test 21c94e6438f76537b72532fa9fd4710cdd455fc3\nF test/selectG.test 089f7d3d7e6db91566f00b036cb353107a2cca6220eb1cb264085a836dae8840\nF test/server1.test c2b00864514a68a0e6fd518659dc95d0050307a357a08969872bef027d785dc4\nF test/session.test 78fa2365e93d3663a6e933f86e7afc395adf18be\nF test/sessionfuzz-data1.db 1f8d5def831f19b1c74571037f0d53a588ea49a6c4ca2a028fc0c27ef896dbcb\nF test/sessionfuzz.c be9c4d4afd359ce80024d8b541b9b8a880510aef5cf263df56fc0e9b947727f1\nF test/shared.test 1826673eb5eb745fb91a3bdac99a7737057742ae38dcb0fe076a384d6727578b\nF test/shared2.test 03eb4a8d372e290107d34b6ce1809919a698e879\nF test/shared3.test ab693f9b6e156b8bfb2a0ad94f29fe69602a5d38\nF test/shared4.test c75f476804e76e26bf6fa0e7b421fb0ca7d07558\nF test/shared6.test 866bb4982c45ce216c61ded5e8fde4e7e2f3ffa9\nF test/shared7.test a81e99f83e6c51b02ac99c96fb3a2a7b5978c956\nF test/shared8.test 933ed7d71f598bb6c7a8c192a3cd30f2562fdccf514df383798599c34ffa672f\nF test/shared9.test 5f2a8f79b4d6c7d107a01ffa1ed05ae7e6333e21\nF test/sharedA.test 49d87ec54ab640fbbc3786ee3c01de94aaa482a3a9f834ad3fe92770eb69e281\nF test/sharedB.test 16cc7178e20965d75278f410943109b77b2e645e\nF test/shared_err.test 32634e404a3317eeb94abc7a099c556a346fdb8fb3858dbe222a4cbb8926a939\nF test/sharedlock.test 5ede3c37439067c43b0198f580fd374ebf15d304\nF test/shell1.test 3c9707dce15e8fdca529503378660f099777d3ddcedccf801a37589a405c5942\nF test/shell2.test e242a9912f44f4c23c3d1d802a83e934e84c853b\nF test/shell3.test ac8c2b744014c3e9a0e26bfd829ab65f00923dc1a91ffd044863e9423cc91494\nF test/shell4.test 1c6aef11daaa2d6830acaba3ac9cbec93fbc1c3d5530743a637f39b3987d08ce\nF test/shell5.test 23939a4c51f0421330ea61dbd3c74f9c215f5f8d3d1a94846da6ffc777a35458\nF test/shell6.test 1ceb51b2678c472ba6cf1e5da96679ce8347889fe2c3bf93a0e0fa73f00b00d3\nF test/shell7.test 115132f66d0463417f408562cc2cf534f6bbc6d83a6d50f0072a9eb171bae97f\nF test/shell8.test 96be02ea0c21f05b24c1883d7b711a1fa8525a68ab7b636aacf6057876941013\nF test/shmlock.test 3dbf017d34ab0c60abe6a44e447d3552154bd0c87b41eaf5ceacd408dd13fda5\nF test/shortread1.test bb591ef20f0fd9ed26d0d12e80eee6d7ac8897a3\nF test/show_speedtest1_rtree.tcl 32e6c5f073d7426148a6936a0408f4b5b169aba5\nF test/shrink.test 1b4330b1fd9e818c04726d45cb28db73087535ce\nF test/sidedelete.test f0ad71abe6233e3b153100f3b8d679b19a488329\nF test/skipscan1.test 2a64ca7b3e6246bb86b47c9051bfd324603b1b60675fe606513535267713e080\nF test/skipscan2.test 3eb703ce794f139e7b83567911046298bcde29606116727f9b700ce34f559d2d\nF test/skipscan3.test ec5bab3f81c7038b43450e7b3062e04a198bdbb5\nF test/skipscan5.test 67817a4b6857c47e0e33ba3e506da6f23ef68de2\nF test/skipscan6.test 0b4cd1b4ac9f84d91454df513c99a4932fa07e8f27b8049bea605068b3e34ac7\nF test/snapshot.test a504f2e7009f512ef66c719f0ea1c55a556bdaf1e1312c80a04d46fc1a3e9632\nF test/snapshot2.test 8d6ff5dd9cc503f6e12d408a30409c3f9c653507b24408d9cd7195931c89bc54\nF test/snapshot3.test 8744313270c55f6e18574283553d3c5c5fe4c5970585663613a0e75c151e599b\nF test/snapshot4.test d4e9347ef2fcabc491fc893506c7bbaf334da3be111d6eb4f3a97cc623b78322\nF test/snapshot_fault.test f6c5ef7cb93bf92fbb4e864ecc5c87df7d3a250064838822db5b4d3a5563ede4\nF test/snapshot_up.test a0a29c4cf33475fcef07c3f8e64af795e24ab91b4cc68295863402a393cdd41c\nF test/soak.test 18944cf21b94a7fe0df02016a6ee1e9632bc4e8d095a0cb49d95e15d5cca2d5c\nF test/softheap1.test 843cd84db9891b2d01b9ab64cef3e9020f98d087\nF test/sort.test c2adc635c2564241fefec0b3a68391ef6868fd3b\nF test/sort2.test cc23b7c19d684657559e8a55b02f7fcee03851d0\nF test/sort3.test 1480ed7c4c157682542224e05e3b75faf4a149e5\nF test/sort4.test 5c34d9623a4ae5921d956dfa2b70e77ed0fc6e5c\nF test/sort5.test 6b43ae0e2169b5ceed441844492e55ba7f1ae0790528395ddf7888ab3094525d\nF test/sorterref.test a13ed207a0eea3c7898f308f979bfb518f68c598ec737d2c494dfd3deaa83506\nF test/sortfault.test d4ccf606a0c77498e2beb542764fd9394acb4d66\nF test/speed1.test f2974a91d79f58507ada01864c0e323093065452\nF test/speed1p.explain d841e650a04728b39e6740296b852dccdca9b2cb\nF test/speed1p.test b180e98609c7677382cf618c0ec9b69f789033a8\nF test/speed2.test 53177056baf6556dcbdcf032bbdfc41c1aa74ded\nF test/speed3.test 694affeb9100526007436334cf7d08f3d74b85ef\nF test/speed4.test abc0ad3399dcf9703abed2fff8705e4f8e416715\nF test/speed4p.explain 6b5f104ebeb34a038b2f714150f51d01143e59aa\nF test/speed4p.test 377a0c48e5a92e0b11c1c5ebb1bc9d83a7312c922bc0cb05970ef5d6a96d1f0c\nF test/speedtest1.c f3bfe3c6a87cbd88e4c4e38005d972bcc1019d1b2fe9569425f86629b11f6c31\nF test/spellfix.test 951a6405d49d1a23d6b78027d3877b4a33eeb8221dcab5704b499755bb4f552e\nF test/spellfix2.test dfc8f519a3fc204cb2dfa8b4f29821ae90f6f8c3\nF test/spellfix3.test 0f9efaaa502a0e0a09848028518a6fb096c8ad33\nF test/spellfix4.test 51c7c26514ade169855c66bcf130bd5acfb4d7fd090cc624645ab275ae6a41fb\nF test/sqldiff1.test 28cd737cf1b0078b1ec1bbf425e674c47785835e\nF test/sqllimits1.test 264f4b0f941800ba139d25e33ee919c5d95fea06dfbe8ac291d6811a30984ca5\nF test/sqllog.test 6af6cb0b09f4e44e1917e06ce85be7670302517a\nF test/stat.test 05669008edc5ed950e817c24e8c4b66840fda64d8c76bae27e5fc1bd23d95675\nF test/statfault.test f525a7bf633e50afd027700e9a486090684b1ac1\nF test/stmt.test 54ed2cc0764bf3e48a058331813c3dbd19fc1d0827c3d8369914a5d8f564ec75\nF test/stmtvtab1.test 6873dfb24f8e79cbb5b799b95c2e4349060eb7a3b811982749a84b359468e2d5\nF test/subjournal.test 8d4e2572c0ee9a15549f0d8e40863161295107e52f07a3e8012a2e1fdd093c49\nF test/subquery.test d7268d193dd33d5505df965399d3a594e76ae13f\nF test/subquery2.test 90cf944b9de8204569cf656028391e4af1ccc8c0cc02d4ef38ee3be8de1ffb12\nF test/subselect.test 0966aa8e720224dbd6a5e769a3ec2a723e332303\nF test/substr.test 18f57c4ca8a598805c4d64e304c418734d843c1a\nF test/subtype1.test 7fe09496352f97053af1437150751be2d0a0cae8\nF test/superlock.test ec94f0556b6488d97f71c79f9061ae08d9ab8f12\nF test/swarmvtab.test 9a3fd5ab3e9b3c976ad1b3d7646aab725114f2ac26b59395d0778b33bab6cdaf\nF test/swarmvtab2.test c948cb2fdfc5b01d85e8f6d6504854202dc1a0782ab2a0ed61538f27cbd0aa5c\nF test/swarmvtab3.test 247aa38b6ebd2b99db2075847ae47e789ac34f1c2ab5c720dfcffd990004c544\nF test/swarmvtabfault.test 8a67a9f27c61073a47990829e92bc0c64420a807cb642b15a25f6c788210ed95\nF test/symlink.test 72b22238d4405ba34df8e60b335d290a3b1129fd5c260835c944c1e4e77288a9\nF test/symlink2.test 9531f475a53d8781c4f81373f87faf2e2aff4f5fb2102ec6386e0c827916a670\nF test/sync.test 89539f4973c010eda5638407e71ca7fddbcd8e0594f4c9980229f804d4333092\nF test/sync2.test 8f9f7d4f6d5be8ca8941a8dadcc4299e558cb6a1ff653a9469146c7a76ef2039\nF test/syscall.test a39d9a36f852ae6e4800f861bc2f2e83f68bbc2112d9399931ecfadeabd2d69d\nF test/sysfault.test c9f2b0d8d677558f74de750c75e12a5454719d04\nF test/tabfunc01.test 5ca6d004157a3e886a55a9387b960cc0db41acd88753eb597ff409ec6cfb1be0\nF test/table.test eb3463b7add9f16a5bb836badf118cf391b809d09fdccd1f79684600d07ec132\nF test/tableapi.test ecbcc29c4ab62c1912c3717c48ea5c5e59f7d64e4a91034e6148bd2b82f177f4\nF test/tableopts.test dba698ba97251017b7c80d738c198d39ab747930\nF test/tclsqlite.test c4a5f5af3672fbe28a0aa322b88d9d1ce2225b6b1284ea11ede2e6d38e7c812c\nF test/tempdb.test 4cdaa23ddd8acb4d79cbb1b68ccdfd09b0537aaba909ca69a876157c2a2cbd08\nF test/tempdb2.test 353864e96fd3ae2f70773d0ffbf8b1fe48589b02c2ec05013b540879410c3440\nF test/tempfault.test 0c0d349c9a99bf5f374655742577f8712c647900\nF test/temptable.test d2c9b87a54147161bcd1822e30c1d1cd891e5b30\nF test/temptable2.test d2940417496e2b9548e01d09990763fbe88c316504033256d51493e1f1a5ce6a\nF test/temptable3.test d11a0974e52b347e45ee54ef1923c91ed91e4637\nF test/temptrigger.test 38f0ca479b1822d3117069e014daabcaacefffcc\nF test/tester.tcl abba168acd7f01dbfa3ffdbf402d151eb97e8a824d9208e845ab34c194441483\nF test/thread001.test b61a29dd87cf669f5f6ac96124a7c97d71b0c80d9012746072055877055cf9ef\nF test/thread002.test e630504f8a06c00bf8bbe68528774dd96aeb2e58\nF test/thread003.test ee4c9efc3b86a6a2767516a37bd64251272560a7\nF test/thread004.test f51dfc3936184aaf73ee85f315224baad272a87f\nF test/thread005.test 50d10b5684399676174bd96c94ad4250b1a2c8b6\nF test/thread1.test df115faa10a4ba1d456e9d4d9ec165016903eae4\nF test/thread2.test f35d2106452b77523b3a2b7d1dcde2e5ee8f9e46\nF test/thread_common.tcl 334639cadcb9f912bf82aa73f49efd5282e6cadd\nF test/threadtest1.c 6029d9c5567db28e6dc908a0c63099c3ba6c383b\nF test/threadtest2.c a70a8e94bef23339d34226eb9521015ef99f4df8\nF test/threadtest3.c 38a612ea62854349ed66372f330a40d73c5cf956\nF test/threadtest4.c c1e67136ceb6c7ec8184e56ac61db28f96bd2925\nF test/time-wordcount.sh 8e0b0f8109367827ad5d58f5cc849705731e4b90\nF test/tkt-02a8e81d44.test 6c80d9c7514e2a42d4918bf87bf6bc54f379110c\nF test/tkt-18458b1a.test 6a62cb1ee50fa3c620da59e3a6f531eb38fceaf7e2166203816b724524e6f1d6\nF test/tkt-26ff0c2d1e.test c15bec890c4d226c0da2f35ff30f9e84c169cfef90e73a8cb5cec11d723dfa96\nF test/tkt-2a5629202f.test 0521bd25658428baa26665aa53ffed9367d33af2\nF test/tkt-2d1a5c67d.test be1326f3061caec85085f4c9ee4490561ca037c0\nF test/tkt-2ea2425d34.test 1cf13e6f75d149b3209a0cb32927a82d3d79fb28\nF test/tkt-31338dca7e.test 6fb8807851964da0d24e942f2e19c7c705b9fb58\nF test/tkt-313723c356.test 4b306ad45c736cedf2f5221f6155b92143244b6d\nF test/tkt-385a5b56b9.test 5204a7cba0e28c99df0acbf95af5e1af4d32965a7a14de6eccebf949607618b1\nF test/tkt-38cb5df375.test f3cc8671f1eb604d4ae9cf886ed4366bec656678\nF test/tkt-3998683a16.test 6d1d04d551ed1704eb3396ca87bb9ccc8c5c1eb7\nF test/tkt-3a77c9714e.test 90e3e8455ee945a4076d4c44062b8845708af24a880355328fe7008f2047c9f0\nF test/tkt-3fe897352e.test 27e26eb0f1811aeba4d65aba43a4c52e99da5e70\nF test/tkt-4a03edc4c8.test 91c0e135888cdc3d4eea82406a44b05c8c1648d0\nF test/tkt-4c86b126f2.test cbcc611becd0396890169ab23102dd70048bbc9a\nF test/tkt-4dd95f6943.test 3d0ce415d2ee15d3d564121960016b9c7be79407\nF test/tkt-4ef7e3cfca.test 3965ae11cc9cf6e334f9d7d3c1e20bf8d56254b1\nF test/tkt-54844eea3f.test a12b851128f46a695e4e378cca67409b9b8f5894\nF test/tkt-5d863f876e.test 726e76d725f6fe0eb2fc8a522b721b79807380ee\nF test/tkt-5e10420e8d.test 904d1687b3c06d43e5b3555bbcf6802e7c0ffd84\nF test/tkt-5ee23731f.test 9db6e1d7209dc0794948b260d6f82b2b1de83a9f\nF test/tkt-6bfb98dfc0.test 24780633627b5cfc0635a5500c2389ebfb563336\nF test/tkt-752e1646fc.test ea78d88d14fe9866bdd991c634483334639e13bf\nF test/tkt-78e04e52ea.test cb44d0f5e7940223be740a39913a1b9b9b30d7e4a17ed3349141f893bae1b8f2\nF test/tkt-7a31705a7e6.test 9e9c057b6a9497c8f7ba7b16871029414ccf6550e7345d9085d6d71c9a56bb6f\nF test/tkt-7bbfb7d442.test 7b2cd79c7a17ae6750e75ec1a7846712a69c9d18\nF test/tkt-80ba201079.test 105a721e6aad0ae3c5946d7615d1e4d03f6145b8\nF test/tkt-80e031a00f.test 9ee36348b761bf7c14261e002b75a4c0d5a04d4c\nF test/tkt-8454a207b9.test c583a9f814a82a2b5ba95207f55001c9f0cd816c\nF test/tkt-868145d012.test a5f941107ece6a64410ca4755c6329b7eb57a356\nF test/tkt-8c63ff0ec.test 258b7fc8d7e4e1cb5362c7d65c143528b9c4cbed\nF test/tkt-91e2e8ba6f.test 08c4f94ae07696b05c9b822da0b4e5337a2f54c5\nF test/tkt-94c04eaadb.test f738c57c7f68ab8be1c054415af7774617cb6223\nF test/tkt-9a8b09f8e6.test b2ef151d0984b2ebf237760dbeaa50724e5a0667\nF test/tkt-9d68c883.test 16f7cb96781ba579bc2e19bb14b4ad609d9774b6\nF test/tkt-9f2eb3abac.test cb6123ac695a08b4454c3792fbe85108f67fabf8\nF test/tkt-a7b7803e.test 159ef554234fa1f9fb318c751b284bd1cf858da4\nF test/tkt-a7debbe0.test e295fa83cd4416a8ca37b354eb5fadefc5e81fb55253db538d35261fe9c95067\nF test/tkt-a8a0d2996a.test 002e1cde8fc30c39611b52cf981c88200b858765748556822da72e0d32fac73e\nF test/tkt-b1d3a2e531.test 8f7576e41ca179289ee1a8fee28386fd8e4b0550\nF test/tkt-b351d95f9.test d14a503c414c5c58fdde3e80f9a3cfef986498c0\nF test/tkt-b72787b1.test a95e8cdad0b98af1853ac7f0afd4ab27b77bf5f3\nF test/tkt-b75a9ca6b0.test ade89229d853a67a21bbd5e6e1e787a8f9d21f19908d1b7fca6bf3d4d5aa0767\nF test/tkt-ba7cbfaedc.test b4c0deccc12aeb55cfdb57935b16b5d67c5a9877\nF test/tkt-bd484a090c.test 60460bf946f79a79712b71f202eda501ca99b898\nF test/tkt-bdc6bbbb38.test fc38bb09bdd440e3513a1f5f98fc60a075182d7d\nF test/tkt-c48d99d690.test ba61977d62ab612fc515b3c488a6fbd6464a2447\nF test/tkt-c694113d5.test 82c461924ada5c14866c47e85535b0b0923ba16a2e907e370061a5ca77f65d77\nF test/tkt-cbd054fa6b.test 708475ef4d730a6853512c8ce363bcbd3becf0e26826e1f4cd46e2f52ff38edf\nF test/tkt-d11f09d36e.test d999b548fef885d1d1afa49a0e8544ecf436869d\nF test/tkt-d635236375.test 9d37e988b47d87505bc9445be0ca447002df5d09\nF test/tkt-d82e3f3721.test bcc0dfba658d15bab30fd4a9320c9e35d214ce30\nF test/tkt-f3e5abed55.test d5a0126118142d13e27f6ce9f4c47096e9321c00\nF test/tkt-f67b41381a.test a23bc124c981662db712167bacd0ed8ad11abac9\nF test/tkt-f777251dc7a.test d1a8fc3eefb7a9e64d19ff24d5c8c94c34a632fb\nF test/tkt-f7b4edec.test d998a08ff2b18b7f62edce8e3044317c45efe6c7\nF test/tkt-f973c7ac31.test 28ef85c7f015477916795246d8286aeda39d4ead\nF test/tkt-fa7bf5ec.test 9102dfea58aa371d78969da735f9392c57e2e035\nF test/tkt-fc62af4523.test 72825d3febdedcd5593a27989fc05accdbfc2bb4\nF test/tkt-fc7bd6358f.test 634bb4af7d661e82d6b61b80c86727bad698e08f\nF test/tkt1435.test f8c52c41de6e5ca02f1845f3a46e18e25cadac00\nF test/tkt1443.test bacc311da5c96a227bf8c167e77a30c99f8e8368\nF test/tkt1444.test a9d72f9e942708bd82dde6c707da61c489e213e9\nF test/tkt1449.test 93584a449752d52b07d2cfc280a69842b6e16ed5\nF test/tkt1473.test 9d000af3e11a4450d4c596f5e58b4b0d24eb0f8b\nF test/tkt1501.test 2064f98e00871848af4b2f517e46c1a7fb2e32db\nF test/tkt1512.test a1df1f66caf0b9122d6220c15dcee230298c2c2f\nF test/tkt1514.test ddef38e34fea72eb1ab935ded9f17a3fb71dd9df\nF test/tkt1536.test 83ff7a7b6e248016f8d682d4f7a4ae114070d466\nF test/tkt1537.test e3a14332de9770be8ff14bd15c19a49cbec10808\nF test/tkt1567.test 52f329386ac77e59260d4af1c58490d61377db20\nF test/tkt1644.test 80b6a2bb17885f3cf1cb886d97cdad13232bb869\nF test/tkt1667.test 4700d931ed19ea3983e8e703becb28079250b460\nF test/tkt1873.test 0e1b8c023050a430c2525179ed4022ddc7c31264\nF test/tkt2141.test f543d96f50d5a5dc0bc744f7db74ea166720ce46\nF test/tkt2192.test ff40157e5f42e65f844255d220fc6b290470942f\nF test/tkt2213.test a9702175601a57b61aba095a233b001d6f362474\nF test/tkt2251.test 5aab8c7898cd2df2a68fe19289cc29e8f5cf8c82\nF test/tkt2285.test cca17be61cf600b397188e77e7143844d2b977e9\nF test/tkt2332.test fc955609b958ca86dfa102832243370a0cc84070\nF test/tkt2339.test 73bd17818924cd2ac442e5fd9916b58565739450\nF test/tkt2391.test ab7a11be7402da8b51a5be603425367aa0684567\nF test/tkt2409.test be0d60e7d283f639dccea4b0b5e1cd3a4851fb5b\nF test/tkt2450.test 77ed94863f2049c1420288ddfea2d41e5e0971d6\nF test/tkt2565.test 8be666e927cb207aae88188f31c331870878b650\nF test/tkt2640.test 28134f5d1e05658ef182520cf0b680fa3de5211b\nF test/tkt2643.test 3f3ebb743da00d4fed4fcf6daed92a0e18e57813\nF test/tkt2686.test 6ee01c9b9e9c48f6d3a1fdd553b1cc4258f903d6\nF test/tkt2767.test 569000d842678f9cf2db7e0d1b27cbc9011381b0\nF test/tkt2817.test f31839e01f4243cff7399ef654d3af3558cb8d8d\nF test/tkt2820.test 39940276b3436d125deb7d8ebeee053e4cf13213\nF test/tkt2822.test f391776423a7c0d0949edfce375708bfb0f3141e\nF test/tkt2832.test a9b0b74a02dca166a04d9e37739c414b10929caa\nF test/tkt2854.test e432965db29e27e16f539b2ba7f502eb2ccc49af\nF test/tkt2920.test a8737380e4ae6424e00c0273dc12775704efbebf\nF test/tkt2927.test 4752868b9eeeb07a217f7f19f4cbaac98d6d086d\nF test/tkt2942.test c5c87d179799ca6d1fbe83c815510b87cd5ec7ce\nF test/tkt3080.test 1bca7579260920a66b4dd7e196e807c0f25ff804\nF test/tkt3093.test fbdbc5b4969244ad11f540759003e361fcaf391f\nF test/tkt3121.test 536df66a02838c26a12fe98639354ca1290ca68b\nF test/tkt3201.test f1500ccecc0d578dc4cde7d3242008297c4d59b3\nF test/tkt3292.test 7bad4423cf5eb075dbb58511d66d46fe816744754c9f0050ae60157f71a4fca7\nF test/tkt3298.test 20fd8773b825cb602e033aa04f8602e1ebdcd93c\nF test/tkt3334.test 9756631e3c4aa3c416362c279e3c0953a83b7ca8274cb81a13264bb56296d8b0\nF test/tkt3346.test 6f67c3ed7db94dfc5df4f5f0b63809a1f611e01a\nF test/tkt3357.test 77c37c6482b526fe89941ce951c22d011f5922ed\nF test/tkt3419.test 1bbf36d7ea03b638c15804251287c2391f5c1f6b\nF test/tkt3424.test 61f831bd2b071bd128fa5d00fbda57e656ca5812\nF test/tkt3442.test a1fc47c669e651d16494de3ff349bcb53281456f2ca02c8bc14220b6044bbfe8\nF test/tkt3457.test 5651e2cbb94645b677ec663160b9e192b87b7d365aecdfb24e19f749575a6fc2\nF test/tkt3461.test 228ea328a5a21e8663f80ee3d212a6ad92549a19\nF test/tkt3493.test 1686cbde85f8721fc1bdc0ee72f2ef2f63139218\nF test/tkt3508.test d75704db9501625c7f7deec119fcaf1696aefb7d\nF test/tkt3522.test 22ce2ebbcb04a6be56c0977d405c207967318fd6\nF test/tkt3527.test 1a6a48441b560bdc53aec581a868eb576234874d\nF test/tkt3541.test 5dc257bde9bc833ab9cc6844bf170b998dbb950a\nF test/tkt3554.test f599967f279077bace39220cbe76085c7b423725\nF test/tkt3581.test 1966b7193f1e3f14951cce8c66907ae69454e9a3\nF test/tkt35xx.test f38c1b03713179d414969187c941466e44945b35\nF test/tkt3630.test 9a934c58c259f89a0ae6bb6bb846c56285a6fd0f\nF test/tkt3718.test 3b59dcb5c4e7754dacd91e7fd353a61492cc402a\nF test/tkt3731.test 0c5f4cbffe102d43c3b2188af91a9e36348f974b\nF test/tkt3757.test 10cd679a88675c880533083fc79ac04324525595\nF test/tkt3761.test b95ea9c98f21cf91325f18a984887e62caceab33\nF test/tkt3762.test 4d439ff7abdc8d9323150269d182c37c2d514576\nF test/tkt3773.test 7bca904d2a647a6a4a291bd86d7fd7c73855b789\nF test/tkt3791.test a6624b9a80b216a26cf473607f42f3e51898c267\nF test/tkt3793.test d90ffd75c52413908d15e1c44fc2ea9c80fcc449\nF test/tkt3810.test 09608d81c63a6ff3aaf7bc70717909c51f5f4048\nF test/tkt3824.test 150aa00bb6220672e5f0eb14dc8eaa36750425f0\nF test/tkt3832.test 2300d10d57562b89875b72148338ac3e14f8847d\nF test/tkt3838.test 292e72489101cd1320d7278dc111c173ebf334d4\nF test/tkt3841.test 4659845bc53f809a5932c61c6ce8c5bb9d6b947f\nF test/tkt3871.test d921703d07c68f4fd5312073215a17fa34b0401d\nF test/tkt3879.test 2ad5bef2c87e9991ce941e054c31abe26ef7fb90\nF test/tkt3911.test 74cd324f3ba653040cc6d94cc4857b290d12d633\nF test/tkt3918.test ea78bf164e4d55cbde0d83c671ef6fbe930a0032\nF test/tkt3922.test f26be40ab4fe6c00795629bd2006d96e270d9b1a\nF test/tkt3929.test cdf67acf5aa936ec4ffead81db87f8a71fe40e59\nF test/tkt3935.test e15261fedb9e30a4305a311da614a5d8e693c767\nF test/tkt3992.test f3e7d548ac26f763b47bc0f750da3d03c81071da\nF test/tkt3997.test a335fa41ca3985660a139df7b734a26ef53284bd\nF test/tkt4018.test 18dbc6617f7a4b90e938d1bd6d26ad18daafaf08\nF test/tokenize.test ce430a7aed48fc98301611429595883fdfcab5d7\nF test/tpch01.test 7c4eb8cdd79c568f46d344b3e789c9fdb8a766d112871352704861f3fca32a2a\nF test/trace.test a659a9862957f4789e37a92b3bf6d2caf5c86b02cdeefc41e850ae53acf6992a\nF test/trace2.test f5cb67ad3bc09e0c58e8cca78dfd0b5639259983\nF test/trace3.test 1dff966888773ff1bfea01c080caf15417892b3f998408fe920c4791f7337144\nF test/trans.test 6e1b4c6a42dba31bd65f8fa5e61a2708e08ddde6\nF test/trans2.test 62bd045bfc7a1c14c5ba83ba64d21ade31583f76\nF test/trans3.test 91a100e5412b488e22a655fe423a14c26403ab94\nF test/transitive1.test 293300f46916569f08875cdb2fe2134be2c27677\nF test/trigger1.test 746dc327e2a0817a22bfc6f5a5e423483d3e77b3733ac20a8fe939e6541b5e53\nF test/trigger2.test d15da46f7012832faf3e0c536b47024409d5fb1722d2bb77e29c06d96d704bb1\nF test/trigger3.test aa640bb2bbb03edd5ff69c055117ea088f121945\nF test/trigger4.test 74700b76ebf3947b2f7a92405141eb2cf2a5d359\nF test/trigger5.test 619391a3e9fc194081d22cefd830d811e7badf83\nF test/trigger6.test 0e411654f122552da6590f0b4e6f781048a4a9b9\nF test/trigger7.test e7ce54bfda67a88d778aea42544e151c465547a7e617127b6914c2221a6d53c1\nF test/trigger8.test 30cb0530bd7c4728055420e3f739aa00412eafa4\nF test/trigger9.test 2226ec795a33b0460ab5cf8891e9054cc7edef41\nF test/triggerA.test 837be862d8721f903dba3f3ceff05b32e0bee5214cf6ea3da5fadf12d3650e9d\nF test/triggerB.test 56780c031b454abac2340dbb3b71ac5c56c3d7fe\nF test/triggerC.test 29f5a28d0fe39e6e2c01f6e1f53f08c0955170ae10a63ad023e33cb0a1682a51\nF test/triggerD.test 8e7f3921a92a5797d472732108109e44575fa650\nF test/triggerE.test ede2e4bce4ba802337bd69d39447fa04a938e06d84a8bfc53c76850fc36ed86d\nF test/triggerF.test 5d76f0a8c428ff87a4d5ed52da06f6096a2c787a1e21b846111dfac4123de3ad\nF test/triggerG.test d5caeef6144ede2426dd13211fd72248241ff2ebc68e12a4c0bf30f5faa21499\nF test/tt3_checkpoint.c 9e75cf7c1c364f52e1c47fd0f14c4340a9db0fe1\nF test/tt3_index.c 39eec10a35f57672225be4d182862152896dee4a\nF test/tt3_lookaside1.c 0377e202c3c2a50d688cb65ba203afeda6fafeb9\nF test/tt3_stress.c c57d804716165811d979d4a719e05baccd79277f\nF test/tt3_vacuum.c 1753f45917699c9c1f66b64c717a717c9379f776\nF test/types.test bf816ce73c7dfcfe26b700c19f97ef4050d194ff\nF test/types2.test 1aeb81976841a91eef292723649b5c4fe3bc3cac\nF test/types3.test 99e009491a54f4dc02c06bdbc0c5eea56ae3e25a\nF test/unionvtab.test e1704ab1b4c1bb3ffc9da4681f8e85a0b909fd80b937984fc94b27415ac8e5a4\nF test/unionvtabfault.test e8759f3d14fb938ce9657e2342db34aeac0fb9bc1692b0d1ebb0069630151d06\nF test/unique.test 93f8b2ef5ea51b9495f8d6493429b1fd0f465264\nF test/unique2.test 3674e9f2a3f1fbbfd4772ac74b7a97090d0f77d2\nF test/unixexcl.test d936ba2b06794018e136418addd59a2354eeae97\nF test/unordered.test ffeea7747d5ba962a8009a20b7e53d68cbae05b063604c68702c5998eb50c981\nF test/update.test 6a1193fbcb4546b4467d24635b1504b8e746b41d3b66dc6ace07581a62ce58fb\nF test/update2.test 67455bc61fcbcf96923c45b3bc4f87bc72be7d67575ad35f134906148c7b06d3\nF test/upsert1.test 0b740c8488fd2f5a06ac317c9913f7ef1eda8282f2db58b544b89480c51efab3\nF test/upsert2.test 9c3cdbb1a890227f6504ce4b0e3de68f4cdfa16bb21d8641208a9239896c5a09\nF test/upsert3.test 88d7d590a1948a9cb6eac1b54b0642f67a9f35a1fc0f19b200e97d5d39e3179c\nF test/upsert4.test 25d2a1da92f149331ae0c51ca6e3eee78189577585eab92de149900d62994fa5\nF test/upsertfault.test f21ca47740841fdb4d61acfa7b17646d773e67724fe8c185b71c018db8a94b35\nF test/uri.test 3481026f00ade6dfe8adb7acb6e1e47b04369568\nF test/uri2.test 9d3ba7a53ee167572d53a298ee4a5d38ec4a8fb7\nF test/userauth01.test e740a2697a7b40d7c5003a7d7edaee16acd349a9\nF test/utf16align.test 54cd35a27c005a9b6e7815d887718780b6a462ae\nF test/vacuum-into.test 48f4cec354fb6f27c98ef58d2fe49a11b71ff131af0cd9140efacc9858b9f670\nF test/vacuum.test ce91c39f7f91a4273bf620efad21086b5aa6ef1d\nF test/vacuum2.test aa048abee196c16c9ba308465494009057b79f9b\nF test/vacuum3.test 77ecdd54592b45a0bcb133339f99f1ae0ae94d0d\nF test/vacuum4.test 7ea76b769fffeb41f925303b04cbcf5a5bbeabe55e4c60ae754ff24eeeb7c010\nF test/vacuum5.test 263b144d537e92ad8e9ca8a73cc6e1583f41cfd0dda9432b87f7806174a2f48c\nF test/vacuummem.test 7b42abb3208bd82dd23a7536588396f295a314f2\nF test/varint.test bbce22cda8fc4d135bcc2b589574be8410614e62\nF test/veryquick.test 57ab846bacf7b90cf4e9a672721ea5c5b669b661\nF test/view.test 10ea54300a097d7c0337fd104abffe4a4786d1598b94017a37efe0e0d3e04dd5\nF test/vtab1.test c5d9e90ed02bcacd776dcbb7360199d290f7f53c26b484ddece543060c54319f\nF test/vtab2.test 14d4ab26cee13ba6cf5c5601b158e4f57552d3b055cdd9406cf7f711e9c84082\nF test/vtab3.test b45f47d20f225ccc9c28dc915d92740c2dee311e\nF test/vtab4.test 8e73ed268f3d596bc3590f45fc948fb40f28e9c3\nF test/vtab5.test 889f444970393c73f1e077e2bdc5d845e157a391\nF test/vtab6.test 8e789f526e6594cf7ae933d1adee0caa87dc9f78\nF test/vtab7.test 70c6f4a1d6177144a8236e4172d5fba92e683440374664ad1f04851fbb335d3c\nF test/vtab8.test e19fa4a538fcd1bb66c22825fa8f71618fb13583\nF test/vtab9.test ea58d2b95d61955f87226381716b2d0b1d4e4f9b\nF test/vtabA.test 1317f06a03597eee29f40a49b6c21e1aaba4285f\nF test/vtabB.test 04df5dc531b9f44d9ca65b9c1b79f12b5922a796\nF test/vtabC.test 4528f459a13136f982e75614d120aef165f17292\nF test/vtabD.test 05b3f1d77117271671089e48719524b676842e96\nF test/vtabE.test 2a143fe75a11275781d1fd1988d86b66a3f69cb98f4add62e3da8fd0f637b45f\nF test/vtabF.test 1918844c7c902f6a16c8dacf1ec8f84886d6e78b\nF test/vtabH.test 2efb5a24b0bb50796b21eca23032cfb77abfa4b0c03938e38ce5897abac404ca\nF test/vtabI.test 751b07636700dbdea328e4265b6077ccd6811a3f\nF test/vtabJ.test d7b73675708cf63cfcb9d443bb451fc01a028347275b7311e51f9fdf3ca6757f\nF test/vtab_alter.test 736e66fb5ec7b4fee58229aa3ada2f27ec58bc58c00edae4836890c3784c6783\nF test/vtab_err.test dcc8b7b9cb67522b3fe7a272c73856829dae4ab7fdb30399aea1b6981bda2b65\nF test/vtab_shared.test 5253bff2355a9a3f014c15337da7e177ab0ef8ad\nF test/vtabdrop.test 65d4cf6722972e5499bdaf0c0d70ee3b8133944a4e4bc31862563f32a7edca12\nF test/wal.test cdf0ca6cc0447520d19ef1c83287824ebeb3e82d75af856511ba96841a79fc9b\nF test/wal2.test 537f59e5c5932e3b45bf3591ae3e48a2601360c2e52821b633e222fe6ebd5b09\nF test/wal3.test 2a93004bc0fb2b5c29888964024695bade278ab2\nF test/wal4.test 4744e155cd6299c6bd99d3eab1c82f77db9cdb3c\nF test/wal5.test 9c11da7aeccd83a46d79a556ad11a18d3cb15aa9\nF test/wal6.test b602704e4b066199bc89d91ca9000f335dcf4572\nF test/wal64k.test 2a525c0f45d709bae3765c71045ccec5df7d100ccbd3a7860fdba46c9addb965\nF test/wal7.test 2ae8f427d240099cc4b2dfef63cff44e2a68a1bd\nF test/wal8.test d9df3fba4caad5854ed69ed673c68482514203c8\nF test/wal9.test 378e76a9ad09cd9bee06c172ad3547b0129a6750\nF test/wal_common.tcl a98f17fba96206122eff624db0ab13ec377be4fe\nF test/walbak.test 018d4e5a3d45c6298d11b99f09a8ef6876527946\nF test/walbig.test f437473a16cfb314867c6b5d1dbcd519e73e3434\nF test/walblock.test be48f3a75eff0b4456209f26b3ce186c2015497d\nF test/walcksum.test bb234a1bb42248b3515d992b719708015c384278\nF test/walcrash.test 21038858cc552077b0522f50b0fa87e38139306a\nF test/walcrash2.test a0edab4e5390f03b99a790de89aad15d6ec70b36\nF test/walcrash3.test e426aa58122d20f2b9fbe9a507f9eb8cab85b8af\nF test/walcrash4.test e7b6e7639a950a0cca8e210e248c8dad4d63bf20\nF test/walfault.test 09b8ad7e52d2f54bce50e31aa7ea51412bb9f70ac13c74e669ddcd8b48b0d98d\nF test/walfault2.test e039ac66c78d5561683cacde04097213cdad3b58e2b3f3fe1112862217bfd915\nF test/walhook.test ed00a40ba7255da22d6b66433ab61fab16a63483\nF test/walmode.test cd6e7cff618eaaa5910ce57c3657aa50110397f86213886a2400afb9bfec7b7b\nF test/walnoshm.test 84ca10c544632a756467336b7c3b864d493ee496\nF test/waloverwrite.test dad2f26567f1b45174e54fbf9a8dc1cb876a7f03\nF test/walpersist.test 8c6b7e3ec1ba91b5e4dc4e0921d6d3f87cd356a6\nF test/walprotocol.test a112aba0b79e3adeaa485fed09484b32c654e97df58e454aa8489ac2cd57bf84\nF test/walprotocol2.test 7d3b6b4bf0b12f8007121b1e6ef714bc99101fb3b48e46371df1db868eebc131\nF test/walro.test cb438d05ba0d191f10b688e39c4f0cd5b71569a1d1f4440e5bdf3c6880e08c20\nF test/walro2.test 0e79dd15cbdb4f482c01ea248373669c732414a726b357d04846a816afafb768\nF test/walrofault.test c70cb6e308c443867701856cce92ad8288cd99488fa52afab77cca6cfd51af68\nF test/walshared.test 0befc811dcf0b287efae21612304d15576e35417\nF test/walslow.test c05c68d4dc2700a982f89133ce103a1a84cc285f\nF test/walthread.test 14b20fcfa6ae152f5d8e12f5dc8a8a724b7ef189f5d8ef1e2ceab79f2af51747\nF test/walvfs.test ca81c9f427e0e5434076dfa948fd1d8e6d5ddd192b2fb6991635d81da5f3f5d4\nF test/wapp.tcl b440cd8cf57953d3a49e7ee81e6a18f18efdaf113b69f7d8482b0710a64566ec\nF test/wapptest.tcl 3cca775aede0591756a1fc0da55bbb3715d8c363873fd2cfdd4d555b0a4af57d x\nF test/where.test 19c709c9f0f6ed12c23f909f6592aa55fba34269d5a2898537aa27a22b9ce650\nF test/where2.test 478d2170637b9211f593120648858593bf2445a1\nF test/where3.test 2341a294e17193a6b1699ea7f192124a5286ca6acfcc3f4b06d16c931fbcda2c\nF test/where4.test 4a371bfcc607f41d233701bdec33ac2972908ba8\nF test/where5.test fdf66f96d29a064b63eb543e28da4dfdccd81ad2\nF test/where6.test 5da5a98cec820d488e82708301b96cb8c18a258b\nF test/where7.test 75722434c486ac9e74718caa6cce234f45ba34c0b6c0f9555b29eb8bb5f6ade1\nF test/where8.test 461ca40265ed996a6305da99bb024b0e41602bb586acf544c08f95922358e49f\nF test/where9.test 2c554b97bbdb2fdf26c57099f60db8a52bfcf7c147f2c256f9798fa0e267ca85\nF test/whereA.test 6c6a420ca7d313242f9b1bd471dc80e4d0f8323700ba9c78df0bb843d4daa3b4\nF test/whereB.test 0def95db3bdec220a731c7e4bec5930327c1d8c5\nF test/whereC.test cae295158703cb3fc23bf1a108a9ab730efff0f6\nF test/whereD.test 711d4df58d6d4fb9b3f5ce040b818564198be002\nF test/whereE.test b3a055eef928c992b0a33198a7b8dc10eea5ad2f\nF test/whereF.test 3d9412b1199d3e2bed34fcb76b4c48d0bf4df95d27e3f8dd27b6f8b4716d0d89\nF test/whereG.test 4cda56de49f0c7d9a4f2590a3ddc5f79a7f2a03d2229d0f5bb5d3981ce57f293\nF test/whereH.test e4b07f7a3c2f5d31195cd33710054c78667573b2\nF test/whereI.test a2874062140ed4aba9ffae76e6190a3df6fc73d1373fdfa8fd632945082a5364\nF test/whereJ.test 88287550f6ee604422403b053455b1ad894eeaa5c35d348532dfa1439286cb9a\nF test/whereK.test f8e3cf26a8513ecc7f514f54df9f0572c046c42b\nF test/whereL.test 0a19fc44cd1122040f56c934f1b14d0ca85bde28f270268a428dd9796ea0634c\nF test/wherefault.test 1374c3aa198388925246475f84ad4cd5f9528864\nF test/wherelfault.test 9012e4ef5259058b771606616bd007af5d154e64cc25fa9fd4170f6411db44e3\nF test/wherelimit.test 592081800806d297dd7449b1030c863d2883d6d42901837ccd2e5a9bd962edb0\nF test/wherelimit2.test 9bf0aa56cca40ea0e4c5e2915341355a2bbc0859ec4ce1589197fe2a9d94635f\nF test/win32heap.test 10fd891266bd00af68671e702317726375e5407561d859be1aa04696f2aeee74\nF test/win32lock.test fbf107c91d8f5512be5a5b87c4c42ab9fdd54972\nF test/win32longpath.test 169c75a3b2e43481f4a62122510210c67b08f26d\nF test/win32nolock.test ac4f08811a562e45a5755e661f45ca85892bdbbc\nF test/window1.test 6db2c38a0830af8554936a563df92e67962cc379253854cd10d0c3cf0a3120c4\nF test/window2.tcl 66db96fd9fd202bc31ee7f8ce7904cb469564864cff3f74e009bfef8102333f4\nF test/window2.test af2a001ded703bb8f2474fb0edfef170d5aba00f5c1f2aa9f65935b5da13df90\nF test/window3.tcl acea6e86a4324a210fd608d06741010ca83ded9fde438341cb978c49928faf03\nF test/window3.test e9959a993c8a71e96433be8daaa1827d78b8921e4f12debd7bdbeb3c856ef3cb\nF test/window4.tcl d732df0e81beedc0ba8a563ade68611d322d27303ad0c0c8e4444107c39e84ec\nF test/window4.test 807f3e6b15f9338e5b9742b87c5c7ca825b42b9657fde6096e890119370848e0\nF test/window5.test d328dd18221217c49c144181975eea17339eaeaf0e9aa558cee3afb84652821e\nF test/window6.test f8d674254b23289cc17c84d79dec7eda7caa1dfb7836c43122cfdf3640d1df32\nF test/window7.tcl 6a1210f05d40ec89c22960213a22cd3f98d4e2f2eb20646c83c8c30d4d76108f\nF test/window7.test 1d31276961ae7801edc72173edaf7593e3cbc79c06d1f1f09e20d8418af403cd\nF test/window8.tcl f2711aa3571e4e6b0dad98db8d95fd6cb8d9db0c92bbdf535f153b07606a1ce2\nF test/window8.test c4331b27a6f66d69fa8f8bab10cc731db1a81d293ae108a68f7c3487fa94e65b\nF test/window9.test b63f6f74d730547e63e78946f951f5d1a7d4e99f91f6d5906305469043d92a15\nF test/windowA.test 6d63dc1260daa17141a55007600581778523a8b420629f1282d2acfc36af23be\nF test/windowB.test 7a983ea1cc1cf72be7f378e4b32f6cb2d73014c5cd8b25aaee825164cd4269e5\nF test/windowerr.tcl f5acd6fbc210d7b5546c0e879d157888455cd4a17a1d3f28f07c1c8a387019e0\nF test/windowerr.test a8b752402109c15aa1c5efe1b93ccb0ce1ef84fa964ae1cd6684dd0b3cc1819b\nF test/windowfault.test a90b397837209f15e54afa62e8be39b2759a0101fae04e05a08bcc50e243a452\nF test/with1.test d32792084dcb5f6c047d77bb8a032822ef9fe050ade07d0aeffa37753a05e3c9\nF test/with2.test e0030e2f0267a910d6c0e4f46f2dfe941c1cc0d4f659ba69b3597728e7e8f1ab\nF test/with3.test 7de8dff2891aca0f9453463e4a2d6eb995baf137827d5596116fee53e22a4e29\nF test/with4.test 257be66c0c67fee1defbbac0f685c3465e2cad037f21ce65f23f86084f198205\nF test/withM.test 693b61765f2b387b5e3e24a4536e2e82de15ff64\nF test/without_rowid1.test 9cfb83705c506e3849fa7efc88a3c9a15f9a50bf9b1516b41757a7cef9bba8c3\nF test/without_rowid2.test af260339f79d13cb220288b67cd287fbcf81ad99\nF test/without_rowid3.test ea4b59dd1b0d7f5f5e4b7cca978cdb905752a9d7c57dc4344a591dba765a3691\nF test/without_rowid4.test 4e08bcbaee0399f35d58b5581881e7a6243d458a\nF test/without_rowid5.test 89b1c587bd92a0590e440da33e7666bf4891572a\nF test/without_rowid6.test 8463b20098e9f75a501a9f17dfb42fffc79068eac0b2775fe56ef2281d2df45e\nF test/without_rowid7.test d7c59a93d726b55812d620f8f284e01904a5b85f9ee9eea8f2f68571a5e8c40e\nF test/wordcount.c d721a4b6fae93e6e33449700bce1686bc23257c27425bc3ef1599dc912adec66\nF test/writecrash.test f1da7f7adfe8d7f09ea79b42e5ca6dcc41102f27f8e334ad71539501ddd910cc\nF test/zeroblob.test 07a5b11ab591d1f26c626945fb7f228f68b993533b2ada77273edf6ee29db174\nF test/zerodamage.test 9c41628db7e8d9e8a0181e59ea5f189df311a9f6ce99cc376dc461f66db6f8dc\nF test/zipfile.test daab4c9be151934fd6bbc71a0d2520351efc61719eabbf545920f953883d172a\nF test/zipfile2.test 9903388a602a3834189857a985106ff95c3bba6a3969e0134127df991889db5d\nF test/zipfilefault.test 44d4d7a7f7cca7521d569d7f71026b241d65a6b1757aa409c1a168827edbbc2c\nF tool/GetFile.cs 47852aa0d806fe47ed1ac5138bdce7f000fe87aaa7f28107d0cb1e26682aeb44\nF tool/GetTclKit.bat 8995df40c4209808b31f24de0b58f90930239a234f7591e3675d45bfbb990c5d\nF tool/Replace.cs 02c67258801c2fb5f63231e0ac0f220b4b36ba91\nF tool/build-all-msvc.bat c12328d06c45fec8baada5949e3d5af54bf8c887 x\nF tool/build-shell.sh 950f47c6174f1eea171319438b93ba67ff5bf367\nF tool/cg_anno.tcl c1f875f5a4c9caca3d59937b16aff716f8b1883935f1b4c9ae23124705bc8099 x\nF tool/checkSpacing.c 810e51703529a204fc4e1eb060e9ab663e3c06d2\nF tool/dbhash.c 19560c9a2aa2b269b6a5108259b93d26d12f8f0877c31fe9f8f61dfbd219ba63\nF tool/dbtotxt.c b2221864a20fb391c46bd31bc1fbdc4a96f5c8a89bef58f421eb9b9c36b1702c\nF tool/dbtotxt.md c9a57af8739957ef36d2cfad5c4b1443ff3688ed33e4901ee200c8b651f43f3c\nF tool/extract-sqlite3h.tcl 069ceab0cee26cba99952bfa08c0b23e35941c837acabe143f0c355d96c9e2eb x\nF tool/extract.c 054069d81b095fbdc189a6f5d4466e40380505e2\nF tool/fast_vacuum.c 5ba0d6f5963a0a63bdc42840f678bad75b2ebce1\nF tool/fragck.tcl 5265a95126abcf6ab357f7efa544787e5963f439\nF tool/fuzzershell.c e1d90a03ca790d7c331c2aae08ca46ff435f1ae1faa6cb9cc48f4687c18fdc6e\nF tool/genfkey.README cf68fddd4643bbe3ff8e31b8b6d8b0a1b85e20f4\nF tool/genfkey.test b6afd7b825d797a1e1274f519ab5695373552ecad5cd373530c63533638a5a4f\nF tool/getlock.c f4c39b651370156cae979501a7b156bdba50e7ce\nF tool/index_usage.c 9ec344d29cbeb03fdc0fce668eedfb7495792170de933adf95cf8d6904a166ad\nF tool/kvtest-speed.sh 4761a9c4b3530907562314d7757995787f7aef8f\nF tool/lemon.c a361b85fa230560b783006ac002a6a8bad214c3b9d7fa48980aecc2b691ddcad\nF tool/lempar.c e8899b28488f060d0ff931539ea6311b16b22dce068c086c788a06d5e8d01ab7\nF tool/libvers.c caafc3b689638a1d88d44bc5f526c2278760d9b9\nF tool/loadfts.c c3c64e4d5e90e8ba41159232c2189dba4be7b862\nF tool/logest.c 11346aa019e2e77a00902aa7d0cabd27bd2e8cca\nF tool/max-limits.c cbb635fbb37ae4d05f240bfb5b5270bb63c54439\nF tool/mkautoconfamal.sh 422fc365358a2e92876ffc62971a0ff28ed472fc8bcf9de0df921c736fdeca5e\nF tool/mkccode.tcl 86463e68ce9c15d3041610fedd285ce32a5cf7a58fc88b3202b8b76837650dbe x\nF tool/mkctimec.tcl dd183b73ae1c28249669741c250525f0407e579a70482371668fd5f130d9feb3\nF tool/mkkeywordhash.c 27ffc6f6e7e3ecbfc5bca1f1f11a09fc5badf6d67557a5fb2d3b069dbed90617\nF tool/mkmsvcmin.tcl cad0c7b54d7dd92bc87d59f36d4cc4f070eb2e625f14159dc2f5c4204e6a13ea\nF tool/mkopcodec.tcl d1b6362bd3aa80d5520d4d6f3765badf01f6c43c\nF tool/mkopcodeh.tcl 352a4319c0ad869eb26442bf7c3b015aa15594c21f1cce5a6420dbe999367c21\nF tool/mkopts.tcl 680f785fdb09729fd9ac50632413da4eadbdf9071535e3f26d03795828ab07fa\nF tool/mkpragmatab.tcl 70269c7013dab01c5d366b1bb4cee6e42fa1a3a8d179a052d14d6b31f11ad77f\nF tool/mkshellc.tcl 70a9978e363b0f3280ca9ce1c46d72563ff479c1930a12a7375e3881b7325712\nF tool/mksourceid.c 36aa8020014aed0836fd13c51d6dc9219b0df1761d6b5f58ff5b616211b079b9\nF tool/mkspeedsql.tcl a1a334d288f7adfe6e996f2e712becf076745c97\nF tool/mksqlite3c-noext.tcl 4f7cfef5152b0c91920355cbfc1d608a4ad242cb819f1aea07f6d0274f584a7f\nF tool/mksqlite3c.tcl 5fed3d75069d8f66f202d3b5200b0cea4aa7108481acd06732a06fdd42eb83a2\nF tool/mksqlite3h.tcl 080873e3856eceb9d289a08a00c4b30f875ea3feadcbece796bd509b1532792c\nF tool/mksqlite3internalh.tcl eb994013e833359137eb53a55acdad0b5ae1049b\nF tool/mkvsix.tcl b9e0777a213c23156b6542842c238479e496ebf5\nF tool/offsets.c fe4262fdfa378e8f5499a42136d17bf3b98f6091\nF tool/omittest.tcl 27f9413c3343bac200a28d81e8234adb0f5e141c4771893cb19b40235a91f1e0\nF tool/opcodesum.tcl 740ed206ba8c5040018988129abbf3089a0ccf4a\nF tool/pagesig.c ff0ca355fd3c2398e933da5e22439bbff89b803b\nF tool/replace.tcl 60f91e8dd06ab81f74d213ecbd9c9945f32ac048\nF tool/restore_jrnl.tcl 6957a34f8f1f0f8285e07536225ec3b292a9024a\nF tool/rollback-test.c 9fc98427d1e23e84429d7e6d07d9094fbdec65a5\nF tool/run-speed-test.sh f95d19fd669b68c4c38b6b475242841d47c66076\nF tool/showdb.c 97d14a1ce32d5edda84081a5c939bd8975abd89568a773b288940e67e4c7e3ad\nF tool/showjournal.c 5bad7ae8784a43d2b270d953060423b8bd480818\nF tool/showlocks.c 9920bcc64f58378ff1118caead34147201f48c68\nF tool/showshm.c a0ab6ec32dd1f11218ca2a4018f8fb875b59414801ab8ceed8b2e69b7b45a809\nF tool/showstat4.c 0682ebea7abf4d3657f53c4a243f2e7eab48eab344ed36a94bb75dcd19a5c2a1\nF tool/showwal.c ad9d768f96ca6199ad3a8c9562d679680bd032dd01204ea3e5ea6fb931d81847\nF tool/soak1.tcl 8d407956e1a45b485a8e072470a3e629a27037fe\nF tool/spaceanal.tcl 4bfd19aad7eb3ce0372ef0255f58035e0bba4ff5e9acfd763a10c6fb365c8dec\nF tool/speed-check.sh 2b042d703a9472f08c3b13be27afac658426f8e4fc87cd2d575953fda86f08d1\nF tool/speedtest.tcl 06c76698485ccf597b9e7dbb1ac70706eb873355\nF tool/speedtest16.c ecb6542862151c3e6509bbc00509b234562ae81e\nF tool/speedtest2.tcl ee2149167303ba8e95af97873c575c3e0fab58ff\nF tool/speedtest8.c 2902c46588c40b55661e471d7a86e4dd71a18224\nF tool/speedtest8inst1.c 7ce07da76b5e745783e703a834417d725b7d45fd\nF tool/split-sqlite3c.tcl 3efcd4240b738f6bb2b5af0aea7e1e0ef9bc1c61654f645076cec883030b710c\nF tool/sqldiff.c 7b9b7238284f02131dbb8f21a4e862409bff728045c5473139d28c67ac87580e\nF tool/sqlite3_analyzer.c.in 7eeaae8b0d7577662acaabbb11107af0659d1b41bc1dfdd4d91422de27127968\nF tool/sqltclsh.c.in 1bcc2e9da58fadf17b0bf6a50e68c1159e602ce057210b655d50bad5aaaef898\nF tool/sqltclsh.tcl 862f4cf1418df5e1315b5db3b5ebe88969e2a784525af5fbf9596592f14ed848\nF tool/srcck1.c 371de5363b70154012955544f86fdee8f6e5326f\nF tool/stack_usage.tcl f8e71b92cdb099a147dad572375595eae55eca43\nF tool/symbols-mingw.sh 4dbcea7e74768305384c9fd2ed2b41bbf9f0414d\nF tool/symbols.sh 1612bd947750e21e7b47befad5f6b3825b06cce0705441f903bf35ced65ae9b9\nF tool/varint.c 5d94cb5003db9dbbcbcc5df08d66f16071aee003\nF tool/vdbe-compress.tcl 5926c71f9c12d2ab73ef35c29376e756eb68361c\nF tool/vdbe_profile.tcl 246d0da094856d72d2c12efec03250d71639d19f\nF tool/warnings-clang.sh bbf6a1e685e534c92ec2bfba5b1745f34fb6f0bc2a362850723a9ee87c1b31a7\nF tool/warnings.sh 09311479bdc290e20ec8e35a3d1b14b096bbd96222277cfd6274c3a99b3d012f\nF tool/win/sqlite.vsix deb315d026cc8400325c5863eef847784a219a2f\nF vsixtest/App.xaml b76d3b48860e7454775c47ea38ffea9c4abe3e85\nF vsixtest/App.xaml.cpp c465147f50871165c60ca16955219f6c5812d6d8\nF vsixtest/App.xaml.h 4a9768e2983d05600ad1e1c2f1b00a132967da9f\nF vsixtest/Assets/LockScreenLogo.scale-200.png e820c9a3deb909197081b0bf3216c06e13905f0a\nF vsixtest/Assets/SplashScreen.scale-200.png cab70988ca71bebec7bfeb3b6dbafe17b9ab0b4a\nF vsixtest/Assets/Square150x150Logo.scale-200.png e17b40817db7a239fc239d83efcc951fb824e3ff\nF vsixtest/Assets/Square44x44Logo.scale-200.png 2f166237094dea94d952d10b9eeae81806844f1c\nF vsixtest/Assets/Square44x44Logo.targetsize-24_altform-unplated.png 5f6a6d391b95a3061ccca6e6fdd6955ede63b4ed\nF vsixtest/Assets/StoreLogo.png 0828b7257db74a4ecd5eeb6b7b4971f0fdc4d9d1\nF vsixtest/Assets/Wide310x150Logo.scale-200.png 04ddefe5bc5f43ae12a7433f6f236ddab101ac42\nF vsixtest/MainPage.xaml 34f49897e3ca533a7e74506ba0759b66eebce151\nF vsixtest/MainPage.xaml.cpp 7f31fc6de751b64676c0924c97a5485d950a91d7\nF vsixtest/MainPage.xaml.h cc05cca10d50a003f6c6e4448b701cdd07f52f29\nF vsixtest/Package.appxmanifest 6b6db1eb7df3a315c5d681059754d5f0e0c47a93\nF vsixtest/pch.cpp cb823cfac36f1a39a7eb0acbd7e9a0b0de8f23af\nF vsixtest/pch.h 9cab7980f2ac4baa40807d8b5e52af32a21cf78c\nF vsixtest/vsixtest.sln 77cadbe4e96c1fe1bf51cd77de9e9b0a12ada547\nF vsixtest/vsixtest.tcl 6a9a6ab600c25a91a7acc6293828957a386a8a93\nF vsixtest/vsixtest.vcxproj.data 2ed517e100c66dc455b492e1a33350c1b20fbcdc\nF vsixtest/vsixtest.vcxproj.filters 37e51ffedcdb064aad6ff33b6148725226cd608e\nF vsixtest/vsixtest_TemporaryKey.pfx e5b1b036facdb453873e7084e1cae9102ccc67a0\nP e2bddcd4c55ba3cbe0130332679ff4b048630d0ced9a8899982edb5a3569ba7f\nR af9053af10312d4307bee0a49d732fcd\nU drh\nZ 117f0e64b781f6b402ee8f8a6b6c39a1\n", "3d4c0bf8904135fa68c75801bfa738715cacc3b19dc8ad6ef550b11798d4b121", "/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains C code routines that are called by the parser\n** to handle SELECT statements in SQLite.\n*/\n#include \"sqliteInt.h\"\n\n/*\n** Trace output macros\n*/\n#if SELECTTRACE_ENABLED\n/***/ int sqlite3SelectTrace = 0;\n# define SELECTTRACE(K,P,S,X)  \\\n  if(sqlite3SelectTrace&(K))   \\\n    sqlite3DebugPrintf(\"%u/%d/%p: \",(S)->selId,(P)->addrExplain,(S)),\\\n    sqlite3DebugPrintf X\n#else\n# define SELECTTRACE(K,P,S,X)\n#endif\n\n\n/*\n** An instance of the following object is used to record information about\n** how to process the DISTINCT keyword, to simplify passing that information\n** into the selectInnerLoop() routine.\n*/\ntypedef struct DistinctCtx DistinctCtx;\nstruct DistinctCtx {\n  u8 isTnct;      /* True if the DISTINCT keyword is present */\n  u8 eTnctType;   /* One of the WHERE_DISTINCT_* operators */\n  int tabTnct;    /* Ephemeral table used for DISTINCT processing */\n  int addrTnct;   /* Address of OP_OpenEphemeral opcode for tabTnct */\n};\n\n/*\n** An instance of the following object is used to record information about\n** the ORDER BY (or GROUP BY) clause of query is being coded.\n**\n** The aDefer[] array is used by the sorter-references optimization. For\n** example, assuming there is no index that can be used for the ORDER BY,\n** for the query:\n**\n**     SELECT a, bigblob FROM t1 ORDER BY a LIMIT 10;\n**\n** it may be more efficient to add just the \"a\" values to the sorter, and\n** retrieve the associated \"bigblob\" values directly from table t1 as the\n** 10 smallest \"a\" values are extracted from the sorter.\n**\n** When the sorter-reference optimization is used, there is one entry in the\n** aDefer[] array for each database table that may be read as values are\n** extracted from the sorter.\n*/\ntypedef struct SortCtx SortCtx;\nstruct SortCtx {\n  ExprList *pOrderBy;   /* The ORDER BY (or GROUP BY clause) */\n  int nOBSat;           /* Number of ORDER BY terms satisfied by indices */\n  int iECursor;         /* Cursor number for the sorter */\n  int regReturn;        /* Register holding block-output return address */\n  int labelBkOut;       /* Start label for the block-output subroutine */\n  int addrSortIndex;    /* Address of the OP_SorterOpen or OP_OpenEphemeral */\n  int labelDone;        /* Jump here when done, ex: LIMIT reached */\n  int labelOBLopt;      /* Jump here when sorter is full */\n  u8 sortFlags;         /* Zero or more SORTFLAG_* bits */\n#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n  u8 nDefer;            /* Number of valid entries in aDefer[] */\n  struct DeferredCsr {\n    Table *pTab;        /* Table definition */\n    int iCsr;           /* Cursor number for table */\n    int nKey;           /* Number of PK columns for table pTab (>=1) */\n  } aDefer[4];\n#endif\n  struct RowLoadInfo *pDeferredRowLoad;  /* Deferred row loading info or NULL */\n};\n#define SORTFLAG_UseSorter  0x01   /* Use SorterOpen instead of OpenEphemeral */\n\n/*\n** Delete all the content of a Select structure.  Deallocate the structure\n** itself only if bFree is true.\n*/\nstatic void clearSelect(sqlite3 *db, Select *p, int bFree){\n  while( p ){\n    Select *pPrior = p->pPrior;\n    sqlite3ExprListDelete(db, p->pEList);\n    sqlite3SrcListDelete(db, p->pSrc);\n    sqlite3ExprDelete(db, p->pWhere);\n    sqlite3ExprListDelete(db, p->pGroupBy);\n    sqlite3ExprDelete(db, p->pHaving);\n    sqlite3ExprListDelete(db, p->pOrderBy);\n    sqlite3ExprDelete(db, p->pLimit);\n#ifndef SQLITE_OMIT_WINDOWFUNC\n    if( OK_IF_ALWAYS_TRUE(p->pWinDefn) ){\n      sqlite3WindowListDelete(db, p->pWinDefn);\n    }\n    assert( p->pWin==0 );\n#endif\n    if( OK_IF_ALWAYS_TRUE(p->pWith) ) sqlite3WithDelete(db, p->pWith);\n    if( bFree ) sqlite3DbFreeNN(db, p);\n    p = pPrior;\n    bFree = 1;\n  }\n}\n\n/*\n** Initialize a SelectDest structure.\n*/\nvoid sqlite3SelectDestInit(SelectDest *pDest, int eDest, int iParm){\n  pDest->eDest = (u8)eDest;\n  pDest->iSDParm = iParm;\n  pDest->zAffSdst = 0;\n  pDest->iSdst = 0;\n  pDest->nSdst = 0;\n}\n\n\n/*\n** Allocate a new Select structure and return a pointer to that\n** structure.\n*/\nSelect *sqlite3SelectNew(\n  Parse *pParse,        /* Parsing context */\n  ExprList *pEList,     /* which columns to include in the result */\n  SrcList *pSrc,        /* the FROM clause -- which tables to scan */\n  Expr *pWhere,         /* the WHERE clause */\n  ExprList *pGroupBy,   /* the GROUP BY clause */\n  Expr *pHaving,        /* the HAVING clause */\n  ExprList *pOrderBy,   /* the ORDER BY clause */\n  u32 selFlags,         /* Flag parameters, such as SF_Distinct */\n  Expr *pLimit          /* LIMIT value.  NULL means not used */\n){\n  Select *pNew;\n  Select standin;\n  pNew = sqlite3DbMallocRawNN(pParse->db, sizeof(*pNew) );\n  if( pNew==0 ){\n    assert( pParse->db->mallocFailed );\n    pNew = &standin;\n  }\n  if( pEList==0 ){\n    pEList = sqlite3ExprListAppend(pParse, 0,\n                                   sqlite3Expr(pParse->db,TK_ASTERISK,0));\n  }\n  pNew->pEList = pEList;\n  pNew->op = TK_SELECT;\n  pNew->selFlags = selFlags;\n  pNew->iLimit = 0;\n  pNew->iOffset = 0;\n  pNew->selId = ++pParse->nSelect;\n  pNew->addrOpenEphm[0] = -1;\n  pNew->addrOpenEphm[1] = -1;\n  pNew->nSelectRow = 0;\n  if( pSrc==0 ) pSrc = sqlite3DbMallocZero(pParse->db, sizeof(*pSrc));\n  pNew->pSrc = pSrc;\n  pNew->pWhere = pWhere;\n  pNew->pGroupBy = pGroupBy;\n  pNew->pHaving = pHaving;\n  pNew->pOrderBy = pOrderBy;\n  pNew->pPrior = 0;\n  pNew->pNext = 0;\n  pNew->pLimit = pLimit;\n  pNew->pWith = 0;\n#ifndef SQLITE_OMIT_WINDOWFUNC\n  pNew->pWin = 0;\n  pNew->pWinDefn = 0;\n#endif\n  if( pParse->db->mallocFailed ) {\n    clearSelect(pParse->db, pNew, pNew!=&standin);\n    pNew = 0;\n  }else{\n    assert( pNew->pSrc!=0 || pParse->nErr>0 );\n  }\n  assert( pNew!=&standin );\n  return pNew;\n}\n\n\n/*\n** Delete the given Select structure and all of its substructures.\n*/\nvoid sqlite3SelectDelete(sqlite3 *db, Select *p){\n  if( OK_IF_ALWAYS_TRUE(p) ) clearSelect(db, p, 1);\n}\n\n/*\n** Return a pointer to the right-most SELECT statement in a compound.\n*/\nstatic Select *findRightmost(Select *p){\n  while( p->pNext ) p = p->pNext;\n  return p;\n}\n\n/*\n** Given 1 to 3 identifiers preceding the JOIN keyword, determine the\n** type of join.  Return an integer constant that expresses that type\n** in terms of the following bit values:\n**\n**     JT_INNER\n**     JT_CROSS\n**     JT_OUTER\n**     JT_NATURAL\n**     JT_LEFT\n**     JT_RIGHT\n**\n** A full outer join is the combination of JT_LEFT and JT_RIGHT.\n**\n** If an illegal or unsupported join type is seen, then still return\n** a join type, but put an error in the pParse structure.\n*/\nint sqlite3JoinType(Parse *pParse, Token *pA, Token *pB, Token *pC){\n  int jointype = 0;\n  Token *apAll[3];\n  Token *p;\n                             /*   0123456789 123456789 123456789 123 */\n  static const char zKeyText[] = \"naturaleftouterightfullinnercross\";\n  static const struct {\n    u8 i;        /* Beginning of keyword text in zKeyText[] */\n    u8 nChar;    /* Length of the keyword in characters */\n    u8 code;     /* Join type mask */\n  } aKeyword[] = {\n    /* natural */ { 0,  7, JT_NATURAL                },\n    /* left    */ { 6,  4, JT_LEFT|JT_OUTER          },\n    /* outer   */ { 10, 5, JT_OUTER                  },\n    /* right   */ { 14, 5, JT_RIGHT|JT_OUTER         },\n    /* full    */ { 19, 4, JT_LEFT|JT_RIGHT|JT_OUTER },\n    /* inner   */ { 23, 5, JT_INNER                  },\n    /* cross   */ { 28, 5, JT_INNER|JT_CROSS         },\n  };\n  int i, j;\n  apAll[0] = pA;\n  apAll[1] = pB;\n  apAll[2] = pC;\n  for(i=0; i<3 && apAll[i]; i++){\n    p = apAll[i];\n    for(j=0; j<ArraySize(aKeyword); j++){\n      if( p->n==aKeyword[j].nChar \n          && sqlite3StrNICmp((char*)p->z, &zKeyText[aKeyword[j].i], p->n)==0 ){\n        jointype |= aKeyword[j].code;\n        break;\n      }\n    }\n    testcase( j==0 || j==1 || j==2 || j==3 || j==4 || j==5 || j==6 );\n    if( j>=ArraySize(aKeyword) ){\n      jointype |= JT_ERROR;\n      break;\n    }\n  }\n  if(\n     (jointype & (JT_INNER|JT_OUTER))==(JT_INNER|JT_OUTER) ||\n     (jointype & JT_ERROR)!=0\n  ){\n    const char *zSp = \" \";\n    assert( pB!=0 );\n    if( pC==0 ){ zSp++; }\n    sqlite3ErrorMsg(pParse, \"unknown or unsupported join type: \"\n       \"%T %T%s%T\", pA, pB, zSp, pC);\n    jointype = JT_INNER;\n  }else if( (jointype & JT_OUTER)!=0 \n         && (jointype & (JT_LEFT|JT_RIGHT))!=JT_LEFT ){\n    sqlite3ErrorMsg(pParse, \n      \"RIGHT and FULL OUTER JOINs are not currently supported\");\n    jointype = JT_INNER;\n  }\n  return jointype;\n}\n\n/*\n** Return the index of a column in a table.  Return -1 if the column\n** is not contained in the table.\n*/\nstatic int columnIndex(Table *pTab, const char *zCol){\n  int i;\n  for(i=0; i<pTab->nCol; i++){\n    if( sqlite3StrICmp(pTab->aCol[i].zName, zCol)==0 ) return i;\n  }\n  return -1;\n}\n\n/*\n** Search the first N tables in pSrc, from left to right, looking for a\n** table that has a column named zCol.  \n**\n** When found, set *piTab and *piCol to the table index and column index\n** of the matching column and return TRUE.\n**\n** If not found, return FALSE.\n*/\nstatic int tableAndColumnIndex(\n  SrcList *pSrc,       /* Array of tables to search */\n  int N,               /* Number of tables in pSrc->a[] to search */\n  const char *zCol,    /* Name of the column we are looking for */\n  int *piTab,          /* Write index of pSrc->a[] here */\n  int *piCol           /* Write index of pSrc->a[*piTab].pTab->aCol[] here */\n){\n  int i;               /* For looping over tables in pSrc */\n  int iCol;            /* Index of column matching zCol */\n\n  assert( (piTab==0)==(piCol==0) );  /* Both or neither are NULL */\n  for(i=0; i<N; i++){\n    iCol = columnIndex(pSrc->a[i].pTab, zCol);\n    if( iCol>=0 ){\n      if( piTab ){\n        *piTab = i;\n        *piCol = iCol;\n      }\n      return 1;\n    }\n  }\n  return 0;\n}\n\n/*\n** This function is used to add terms implied by JOIN syntax to the\n** WHERE clause expression of a SELECT statement. The new term, which\n** is ANDed with the existing WHERE clause, is of the form:\n**\n**    (tab1.col1 = tab2.col2)\n**\n** where tab1 is the iSrc'th table in SrcList pSrc and tab2 is the \n** (iSrc+1)'th. Column col1 is column iColLeft of tab1, and col2 is\n** column iColRight of tab2.\n*/\nstatic void addWhereTerm(\n  Parse *pParse,                  /* Parsing context */\n  SrcList *pSrc,                  /* List of tables in FROM clause */\n  int iLeft,                      /* Index of first table to join in pSrc */\n  int iColLeft,                   /* Index of column in first table */\n  int iRight,                     /* Index of second table in pSrc */\n  int iColRight,                  /* Index of column in second table */\n  int isOuterJoin,                /* True if this is an OUTER join */\n  Expr **ppWhere                  /* IN/OUT: The WHERE clause to add to */\n){\n  sqlite3 *db = pParse->db;\n  Expr *pE1;\n  Expr *pE2;\n  Expr *pEq;\n\n  assert( iLeft<iRight );\n  assert( pSrc->nSrc>iRight );\n  assert( pSrc->a[iLeft].pTab );\n  assert( pSrc->a[iRight].pTab );\n\n  pE1 = sqlite3CreateColumnExpr(db, pSrc, iLeft, iColLeft);\n  pE2 = sqlite3CreateColumnExpr(db, pSrc, iRight, iColRight);\n\n  pEq = sqlite3PExpr(pParse, TK_EQ, pE1, pE2);\n  if( pEq && isOuterJoin ){\n    ExprSetProperty(pEq, EP_FromJoin);\n    assert( !ExprHasProperty(pEq, EP_TokenOnly|EP_Reduced) );\n    ExprSetVVAProperty(pEq, EP_NoReduce);\n    pEq->iRightJoinTable = (i16)pE2->iTable;\n  }\n  *ppWhere = sqlite3ExprAnd(pParse, *ppWhere, pEq);\n}\n\n/*\n** Set the EP_FromJoin property on all terms of the given expression.\n** And set the Expr.iRightJoinTable to iTable for every term in the\n** expression.\n**\n** The EP_FromJoin property is used on terms of an expression to tell\n** the LEFT OUTER JOIN processing logic that this term is part of the\n** join restriction specified in the ON or USING clause and not a part\n** of the more general WHERE clause.  These terms are moved over to the\n** WHERE clause during join processing but we need to remember that they\n** originated in the ON or USING clause.\n**\n** The Expr.iRightJoinTable tells the WHERE clause processing that the\n** expression depends on table iRightJoinTable even if that table is not\n** explicitly mentioned in the expression.  That information is needed\n** for cases like this:\n**\n**    SELECT * FROM t1 LEFT JOIN t2 ON t1.a=t2.b AND t1.x=5\n**\n** The where clause needs to defer the handling of the t1.x=5\n** term until after the t2 loop of the join.  In that way, a\n** NULL t2 row will be inserted whenever t1.x!=5.  If we do not\n** defer the handling of t1.x=5, it will be processed immediately\n** after the t1 loop and rows with t1.x!=5 will never appear in\n** the output, which is incorrect.\n*/\nvoid sqlite3SetJoinExpr(Expr *p, int iTable){\n  while( p ){\n    ExprSetProperty(p, EP_FromJoin);\n    assert( !ExprHasProperty(p, EP_TokenOnly|EP_Reduced) );\n    ExprSetVVAProperty(p, EP_NoReduce);\n    p->iRightJoinTable = (i16)iTable;\n    if( p->op==TK_FUNCTION && p->x.pList ){\n      int i;\n      for(i=0; i<p->x.pList->nExpr; i++){\n        sqlite3SetJoinExpr(p->x.pList->a[i].pExpr, iTable);\n      }\n    }\n    sqlite3SetJoinExpr(p->pLeft, iTable);\n    p = p->pRight;\n  } \n}\n\n/* Undo the work of sqlite3SetJoinExpr(). In the expression p, convert every\n** term that is marked with EP_FromJoin and iRightJoinTable==iTable into\n** an ordinary term that omits the EP_FromJoin mark.\n**\n** This happens when a LEFT JOIN is simplified into an ordinary JOIN.\n*/\nstatic void unsetJoinExpr(Expr *p, int iTable){\n  while( p ){\n    if( ExprHasProperty(p, EP_FromJoin)\n     && (iTable<0 || p->iRightJoinTable==iTable) ){\n      ExprClearProperty(p, EP_FromJoin);\n    }\n    if( p->op==TK_FUNCTION && p->x.pList ){\n      int i;\n      for(i=0; i<p->x.pList->nExpr; i++){\n        unsetJoinExpr(p->x.pList->a[i].pExpr, iTable);\n      }\n    }\n    unsetJoinExpr(p->pLeft, iTable);\n    p = p->pRight;\n  } \n}\n\n/*\n** This routine processes the join information for a SELECT statement.\n** ON and USING clauses are converted into extra terms of the WHERE clause.\n** NATURAL joins also create extra WHERE clause terms.\n**\n** The terms of a FROM clause are contained in the Select.pSrc structure.\n** The left most table is the first entry in Select.pSrc.  The right-most\n** table is the last entry.  The join operator is held in the entry to\n** the left.  Thus entry 0 contains the join operator for the join between\n** entries 0 and 1.  Any ON or USING clauses associated with the join are\n** also attached to the left entry.\n**\n** This routine returns the number of errors encountered.\n*/\nstatic int sqliteProcessJoin(Parse *pParse, Select *p){\n  SrcList *pSrc;                  /* All tables in the FROM clause */\n  int i, j;                       /* Loop counters */\n  struct SrcList_item *pLeft;     /* Left table being joined */\n  struct SrcList_item *pRight;    /* Right table being joined */\n\n  pSrc = p->pSrc;\n  pLeft = &pSrc->a[0];\n  pRight = &pLeft[1];\n  for(i=0; i<pSrc->nSrc-1; i++, pRight++, pLeft++){\n    Table *pRightTab = pRight->pTab;\n    int isOuter;\n\n    if( NEVER(pLeft->pTab==0 || pRightTab==0) ) continue;\n    isOuter = (pRight->fg.jointype & JT_OUTER)!=0;\n\n    /* When the NATURAL keyword is present, add WHERE clause terms for\n    ** every column that the two tables have in common.\n    */\n    if( pRight->fg.jointype & JT_NATURAL ){\n      if( pRight->pOn || pRight->pUsing ){\n        sqlite3ErrorMsg(pParse, \"a NATURAL join may not have \"\n           \"an ON or USING clause\", 0);\n        return 1;\n      }\n      for(j=0; j<pRightTab->nCol; j++){\n        char *zName;   /* Name of column in the right table */\n        int iLeft;     /* Matching left table */\n        int iLeftCol;  /* Matching column in the left table */\n\n        zName = pRightTab->aCol[j].zName;\n        if( tableAndColumnIndex(pSrc, i+1, zName, &iLeft, &iLeftCol) ){\n          addWhereTerm(pParse, pSrc, iLeft, iLeftCol, i+1, j,\n                       isOuter, &p->pWhere);\n        }\n      }\n    }\n\n    /* Disallow both ON and USING clauses in the same join\n    */\n    if( pRight->pOn && pRight->pUsing ){\n      sqlite3ErrorMsg(pParse, \"cannot have both ON and USING \"\n        \"clauses in the same join\");\n      return 1;\n    }\n\n    /* Add the ON clause to the end of the WHERE clause, connected by\n    ** an AND operator.\n    */\n    if( pRight->pOn ){\n      if( isOuter ) sqlite3SetJoinExpr(pRight->pOn, pRight->iCursor);\n      p->pWhere = sqlite3ExprAnd(pParse, p->pWhere, pRight->pOn);\n      pRight->pOn = 0;\n    }\n\n    /* Create extra terms on the WHERE clause for each column named\n    ** in the USING clause.  Example: If the two tables to be joined are \n    ** A and B and the USING clause names X, Y, and Z, then add this\n    ** to the WHERE clause:    A.X=B.X AND A.Y=B.Y AND A.Z=B.Z\n    ** Report an error if any column mentioned in the USING clause is\n    ** not contained in both tables to be joined.\n    */\n    if( pRight->pUsing ){\n      IdList *pList = pRight->pUsing;\n      for(j=0; j<pList->nId; j++){\n        char *zName;     /* Name of the term in the USING clause */\n        int iLeft;       /* Table on the left with matching column name */\n        int iLeftCol;    /* Column number of matching column on the left */\n        int iRightCol;   /* Column number of matching column on the right */\n\n        zName = pList->a[j].zName;\n        iRightCol = columnIndex(pRightTab, zName);\n        if( iRightCol<0\n         || !tableAndColumnIndex(pSrc, i+1, zName, &iLeft, &iLeftCol)\n        ){\n          sqlite3ErrorMsg(pParse, \"cannot join using column %s - column \"\n            \"not present in both tables\", zName);\n          return 1;\n        }\n        addWhereTerm(pParse, pSrc, iLeft, iLeftCol, i+1, iRightCol,\n                     isOuter, &p->pWhere);\n      }\n    }\n  }\n  return 0;\n}\n\n/*\n** An instance of this object holds information (beyond pParse and pSelect)\n** needed to load the next result row that is to be added to the sorter.\n*/\ntypedef struct RowLoadInfo RowLoadInfo;\nstruct RowLoadInfo {\n  int regResult;               /* Store results in array of registers here */\n  u8 ecelFlags;                /* Flag argument to ExprCodeExprList() */\n#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n  ExprList *pExtra;            /* Extra columns needed by sorter refs */\n  int regExtraResult;          /* Where to load the extra columns */\n#endif\n};\n\n/*\n** This routine does the work of loading query data into an array of\n** registers so that it can be added to the sorter.\n*/\nstatic void innerLoopLoadRow(\n  Parse *pParse,             /* Statement under construction */\n  Select *pSelect,           /* The query being coded */\n  RowLoadInfo *pInfo         /* Info needed to complete the row load */\n){\n  sqlite3ExprCodeExprList(pParse, pSelect->pEList, pInfo->regResult,\n                          0, pInfo->ecelFlags);\n#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n  if( pInfo->pExtra ){\n    sqlite3ExprCodeExprList(pParse, pInfo->pExtra, pInfo->regExtraResult, 0, 0);\n    sqlite3ExprListDelete(pParse->db, pInfo->pExtra);\n  }\n#endif\n}\n\n/*\n** Code the OP_MakeRecord instruction that generates the entry to be\n** added into the sorter.\n**\n** Return the register in which the result is stored.\n*/\nstatic int makeSorterRecord(\n  Parse *pParse,\n  SortCtx *pSort,\n  Select *pSelect,\n  int regBase,\n  int nBase\n){\n  int nOBSat = pSort->nOBSat;\n  Vdbe *v = pParse->pVdbe;\n  int regOut = ++pParse->nMem;\n  if( pSort->pDeferredRowLoad ){\n    innerLoopLoadRow(pParse, pSelect, pSort->pDeferredRowLoad);\n  }\n  sqlite3VdbeAddOp3(v, OP_MakeRecord, regBase+nOBSat, nBase-nOBSat, regOut);\n  return regOut;\n}\n\n/*\n** Generate code that will push the record in registers regData\n** through regData+nData-1 onto the sorter.\n*/\nstatic void pushOntoSorter(\n  Parse *pParse,         /* Parser context */\n  SortCtx *pSort,        /* Information about the ORDER BY clause */\n  Select *pSelect,       /* The whole SELECT statement */\n  int regData,           /* First register holding data to be sorted */\n  int regOrigData,       /* First register holding data before packing */\n  int nData,             /* Number of elements in the regData data array */\n  int nPrefixReg         /* No. of reg prior to regData available for use */\n){\n  Vdbe *v = pParse->pVdbe;                         /* Stmt under construction */\n  int bSeq = ((pSort->sortFlags & SORTFLAG_UseSorter)==0);\n  int nExpr = pSort->pOrderBy->nExpr;              /* No. of ORDER BY terms */\n  int nBase = nExpr + bSeq + nData;                /* Fields in sorter record */\n  int regBase;                                     /* Regs for sorter record */\n  int regRecord = 0;                               /* Assembled sorter record */\n  int nOBSat = pSort->nOBSat;                      /* ORDER BY terms to skip */\n  int op;                            /* Opcode to add sorter record to sorter */\n  int iLimit;                        /* LIMIT counter */\n  int iSkip = 0;                     /* End of the sorter insert loop */\n\n  assert( bSeq==0 || bSeq==1 );\n\n  /* Three cases:\n  **   (1) The data to be sorted has already been packed into a Record\n  **       by a prior OP_MakeRecord.  In this case nData==1 and regData\n  **       will be completely unrelated to regOrigData.\n  **   (2) All output columns are included in the sort record.  In that\n  **       case regData==regOrigData.\n  **   (3) Some output columns are omitted from the sort record due to\n  **       the SQLITE_ENABLE_SORTER_REFERENCE optimization, or due to the\n  **       SQLITE_ECEL_OMITREF optimization, or due to the \n  **       SortCtx.pDeferredRowLoad optimiation.  In any of these cases\n  **       regOrigData is 0 to prevent this routine from trying to copy\n  **       values that might not yet exist.\n  */\n  assert( nData==1 || regData==regOrigData || regOrigData==0 );\n\n  if( nPrefixReg ){\n    assert( nPrefixReg==nExpr+bSeq );\n    regBase = regData - nPrefixReg;\n  }else{\n    regBase = pParse->nMem + 1;\n    pParse->nMem += nBase;\n  }\n  assert( pSelect->iOffset==0 || pSelect->iLimit!=0 );\n  iLimit = pSelect->iOffset ? pSelect->iOffset+1 : pSelect->iLimit;\n  pSort->labelDone = sqlite3VdbeMakeLabel(pParse);\n  sqlite3ExprCodeExprList(pParse, pSort->pOrderBy, regBase, regOrigData,\n                          SQLITE_ECEL_DUP | (regOrigData? SQLITE_ECEL_REF : 0));\n  if( bSeq ){\n    sqlite3VdbeAddOp2(v, OP_Sequence, pSort->iECursor, regBase+nExpr);\n  }\n  if( nPrefixReg==0 && nData>0 ){\n    sqlite3ExprCodeMove(pParse, regData, regBase+nExpr+bSeq, nData);\n  }\n  if( nOBSat>0 ){\n    int regPrevKey;   /* The first nOBSat columns of the previous row */\n    int addrFirst;    /* Address of the OP_IfNot opcode */\n    int addrJmp;      /* Address of the OP_Jump opcode */\n    VdbeOp *pOp;      /* Opcode that opens the sorter */\n    int nKey;         /* Number of sorting key columns, including OP_Sequence */\n    KeyInfo *pKI;     /* Original KeyInfo on the sorter table */\n\n    regRecord = makeSorterRecord(pParse, pSort, pSelect, regBase, nBase);\n    regPrevKey = pParse->nMem+1;\n    pParse->nMem += pSort->nOBSat;\n    nKey = nExpr - pSort->nOBSat + bSeq;\n    if( bSeq ){\n      addrFirst = sqlite3VdbeAddOp1(v, OP_IfNot, regBase+nExpr); \n    }else{\n      addrFirst = sqlite3VdbeAddOp1(v, OP_SequenceTest, pSort->iECursor);\n    }\n    VdbeCoverage(v);\n    sqlite3VdbeAddOp3(v, OP_Compare, regPrevKey, regBase, pSort->nOBSat);\n    pOp = sqlite3VdbeGetOp(v, pSort->addrSortIndex);\n    if( pParse->db->mallocFailed ) return;\n    pOp->p2 = nKey + nData;\n    pKI = pOp->p4.pKeyInfo;\n    memset(pKI->aSortFlags, 0, pKI->nKeyField); /* Makes OP_Jump testable */\n    sqlite3VdbeChangeP4(v, -1, (char*)pKI, P4_KEYINFO);\n    testcase( pKI->nAllField > pKI->nKeyField+2 );\n    pOp->p4.pKeyInfo = sqlite3KeyInfoFromExprList(pParse,pSort->pOrderBy,nOBSat,\n                                           pKI->nAllField-pKI->nKeyField-1);\n    pOp = 0; /* Ensure pOp not used after sqltie3VdbeAddOp3() */\n    addrJmp = sqlite3VdbeCurrentAddr(v);\n    sqlite3VdbeAddOp3(v, OP_Jump, addrJmp+1, 0, addrJmp+1); VdbeCoverage(v);\n    pSort->labelBkOut = sqlite3VdbeMakeLabel(pParse);\n    pSort->regReturn = ++pParse->nMem;\n    sqlite3VdbeAddOp2(v, OP_Gosub, pSort->regReturn, pSort->labelBkOut);\n    sqlite3VdbeAddOp1(v, OP_ResetSorter, pSort->iECursor);\n    if( iLimit ){\n      sqlite3VdbeAddOp2(v, OP_IfNot, iLimit, pSort->labelDone);\n      VdbeCoverage(v);\n    }\n    sqlite3VdbeJumpHere(v, addrFirst);\n    sqlite3ExprCodeMove(pParse, regBase, regPrevKey, pSort->nOBSat);\n    sqlite3VdbeJumpHere(v, addrJmp);\n  }\n  if( iLimit ){\n    /* At this point the values for the new sorter entry are stored\n    ** in an array of registers. They need to be composed into a record\n    ** and inserted into the sorter if either (a) there are currently\n    ** less than LIMIT+OFFSET items or (b) the new record is smaller than \n    ** the largest record currently in the sorter. If (b) is true and there\n    ** are already LIMIT+OFFSET items in the sorter, delete the largest\n    ** entry before inserting the new one. This way there are never more \n    ** than LIMIT+OFFSET items in the sorter.\n    **\n    ** If the new record does not need to be inserted into the sorter,\n    ** jump to the next iteration of the loop. If the pSort->labelOBLopt\n    ** value is not zero, then it is a label of where to jump.  Otherwise,\n    ** just bypass the row insert logic.  See the header comment on the\n    ** sqlite3WhereOrderByLimitOptLabel() function for additional info.\n    */\n    int iCsr = pSort->iECursor;\n    sqlite3VdbeAddOp2(v, OP_IfNotZero, iLimit, sqlite3VdbeCurrentAddr(v)+4);\n    VdbeCoverage(v);\n    sqlite3VdbeAddOp2(v, OP_Last, iCsr, 0);\n    iSkip = sqlite3VdbeAddOp4Int(v, OP_IdxLE,\n                                 iCsr, 0, regBase+nOBSat, nExpr-nOBSat);\n    VdbeCoverage(v);\n    sqlite3VdbeAddOp1(v, OP_Delete, iCsr);\n  }\n  if( regRecord==0 ){\n    regRecord = makeSorterRecord(pParse, pSort, pSelect, regBase, nBase);\n  }\n  if( pSort->sortFlags & SORTFLAG_UseSorter ){\n    op = OP_SorterInsert;\n  }else{\n    op = OP_IdxInsert;\n  }\n  sqlite3VdbeAddOp4Int(v, op, pSort->iECursor, regRecord,\n                       regBase+nOBSat, nBase-nOBSat);\n  if( iSkip ){\n    sqlite3VdbeChangeP2(v, iSkip,\n         pSort->labelOBLopt ? pSort->labelOBLopt : sqlite3VdbeCurrentAddr(v));\n  }\n}\n\n/*\n** Add code to implement the OFFSET\n*/\nstatic void codeOffset(\n  Vdbe *v,          /* Generate code into this VM */\n  int iOffset,      /* Register holding the offset counter */\n  int iContinue     /* Jump here to skip the current record */\n){\n  if( iOffset>0 ){\n    sqlite3VdbeAddOp3(v, OP_IfPos, iOffset, iContinue, 1); VdbeCoverage(v);\n    VdbeComment((v, \"OFFSET\"));\n  }\n}\n\n/*\n** Add code that will check to make sure the N registers starting at iMem\n** form a distinct entry.  iTab is a sorting index that holds previously\n** seen combinations of the N values.  A new entry is made in iTab\n** if the current N values are new.\n**\n** A jump to addrRepeat is made and the N+1 values are popped from the\n** stack if the top N elements are not distinct.\n*/\nstatic void codeDistinct(\n  Parse *pParse,     /* Parsing and code generating context */\n  int iTab,          /* A sorting index used to test for distinctness */\n  int addrRepeat,    /* Jump to here if not distinct */\n  int N,             /* Number of elements */\n  int iMem           /* First element */\n){\n  Vdbe *v;\n  int r1;\n\n  v = pParse->pVdbe;\n  r1 = sqlite3GetTempReg(pParse);\n  sqlite3VdbeAddOp4Int(v, OP_Found, iTab, addrRepeat, iMem, N); VdbeCoverage(v);\n  sqlite3VdbeAddOp3(v, OP_MakeRecord, iMem, N, r1);\n  sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iTab, r1, iMem, N);\n  sqlite3VdbeChangeP5(v, OPFLAG_USESEEKRESULT);\n  sqlite3ReleaseTempReg(pParse, r1);\n}\n\n#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n/*\n** This function is called as part of inner-loop generation for a SELECT\n** statement with an ORDER BY that is not optimized by an index. It \n** determines the expressions, if any, that the sorter-reference \n** optimization should be used for. The sorter-reference optimization\n** is used for SELECT queries like:\n**\n**   SELECT a, bigblob FROM t1 ORDER BY a LIMIT 10\n**\n** If the optimization is used for expression \"bigblob\", then instead of\n** storing values read from that column in the sorter records, the PK of\n** the row from table t1 is stored instead. Then, as records are extracted from\n** the sorter to return to the user, the required value of bigblob is\n** retrieved directly from table t1. If the values are very large, this \n** can be more efficient than storing them directly in the sorter records.\n**\n** The ExprList_item.bSorterRef flag is set for each expression in pEList \n** for which the sorter-reference optimization should be enabled. \n** Additionally, the pSort->aDefer[] array is populated with entries\n** for all cursors required to evaluate all selected expressions. Finally.\n** output variable (*ppExtra) is set to an expression list containing\n** expressions for all extra PK values that should be stored in the\n** sorter records.\n*/\nstatic void selectExprDefer(\n  Parse *pParse,                  /* Leave any error here */\n  SortCtx *pSort,                 /* Sorter context */\n  ExprList *pEList,               /* Expressions destined for sorter */\n  ExprList **ppExtra              /* Expressions to append to sorter record */\n){\n  int i;\n  int nDefer = 0;\n  ExprList *pExtra = 0;\n  for(i=0; i<pEList->nExpr; i++){\n    struct ExprList_item *pItem = &pEList->a[i];\n    if( pItem->u.x.iOrderByCol==0 ){\n      Expr *pExpr = pItem->pExpr;\n      Table *pTab = pExpr->y.pTab;\n      if( pExpr->op==TK_COLUMN && pExpr->iColumn>=0 && pTab && !IsVirtual(pTab)\n       && (pTab->aCol[pExpr->iColumn].colFlags & COLFLAG_SORTERREF)\n      ){\n        int j;\n        for(j=0; j<nDefer; j++){\n          if( pSort->aDefer[j].iCsr==pExpr->iTable ) break;\n        }\n        if( j==nDefer ){\n          if( nDefer==ArraySize(pSort->aDefer) ){\n            continue;\n          }else{\n            int nKey = 1;\n            int k;\n            Index *pPk = 0;\n            if( !HasRowid(pTab) ){\n              pPk = sqlite3PrimaryKeyIndex(pTab);\n              nKey = pPk->nKeyCol;\n            }\n            for(k=0; k<nKey; k++){\n              Expr *pNew = sqlite3PExpr(pParse, TK_COLUMN, 0, 0);\n              if( pNew ){\n                pNew->iTable = pExpr->iTable;\n                pNew->y.pTab = pExpr->y.pTab;\n                pNew->iColumn = pPk ? pPk->aiColumn[k] : -1;\n                pExtra = sqlite3ExprListAppend(pParse, pExtra, pNew);\n              }\n            }\n            pSort->aDefer[nDefer].pTab = pExpr->y.pTab;\n            pSort->aDefer[nDefer].iCsr = pExpr->iTable;\n            pSort->aDefer[nDefer].nKey = nKey;\n            nDefer++;\n          }\n        }\n        pItem->bSorterRef = 1;\n      }\n    }\n  }\n  pSort->nDefer = (u8)nDefer;\n  *ppExtra = pExtra;\n}\n#endif\n\n/*\n** This routine generates the code for the inside of the inner loop\n** of a SELECT.\n**\n** If srcTab is negative, then the p->pEList expressions\n** are evaluated in order to get the data for this row.  If srcTab is\n** zero or more, then data is pulled from srcTab and p->pEList is used only \n** to get the number of columns and the collation sequence for each column.\n*/\nstatic void selectInnerLoop(\n  Parse *pParse,          /* The parser context */\n  Select *p,              /* The complete select statement being coded */\n  int srcTab,             /* Pull data from this table if non-negative */\n  SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */\n  DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */\n  SelectDest *pDest,      /* How to dispose of the results */\n  int iContinue,          /* Jump here to continue with next row */\n  int iBreak              /* Jump here to break out of the inner loop */\n){\n  Vdbe *v = pParse->pVdbe;\n  int i;\n  int hasDistinct;            /* True if the DISTINCT keyword is present */\n  int eDest = pDest->eDest;   /* How to dispose of results */\n  int iParm = pDest->iSDParm; /* First argument to disposal method */\n  int nResultCol;             /* Number of result columns */\n  int nPrefixReg = 0;         /* Number of extra registers before regResult */\n  RowLoadInfo sRowLoadInfo;   /* Info for deferred row loading */\n\n  /* Usually, regResult is the first cell in an array of memory cells\n  ** containing the current result row. In this case regOrig is set to the\n  ** same value. However, if the results are being sent to the sorter, the\n  ** values for any expressions that are also part of the sort-key are omitted\n  ** from this array. In this case regOrig is set to zero.  */\n  int regResult;              /* Start of memory holding current results */\n  int regOrig;                /* Start of memory holding full result (or 0) */\n\n  assert( v );\n  assert( p->pEList!=0 );\n  hasDistinct = pDistinct ? pDistinct->eTnctType : WHERE_DISTINCT_NOOP;\n  if( pSort && pSort->pOrderBy==0 ) pSort = 0;\n  if( pSort==0 && !hasDistinct ){\n    assert( iContinue!=0 );\n    codeOffset(v, p->iOffset, iContinue);\n  }\n\n  /* Pull the requested columns.\n  */\n  nResultCol = p->pEList->nExpr;\n\n  if( pDest->iSdst==0 ){\n    if( pSort ){\n      nPrefixReg = pSort->pOrderBy->nExpr;\n      if( !(pSort->sortFlags & SORTFLAG_UseSorter) ) nPrefixReg++;\n      pParse->nMem += nPrefixReg;\n    }\n    pDest->iSdst = pParse->nMem+1;\n    pParse->nMem += nResultCol;\n  }else if( pDest->iSdst+nResultCol > pParse->nMem ){\n    /* This is an error condition that can result, for example, when a SELECT\n    ** on the right-hand side of an INSERT contains more result columns than\n    ** there are columns in the table on the left.  The error will be caught\n    ** and reported later.  But we need to make sure enough memory is allocated\n    ** to avoid other spurious errors in the meantime. */\n    pParse->nMem += nResultCol;\n  }\n  pDest->nSdst = nResultCol;\n  regOrig = regResult = pDest->iSdst;\n  if( srcTab>=0 ){\n    for(i=0; i<nResultCol; i++){\n      sqlite3VdbeAddOp3(v, OP_Column, srcTab, i, regResult+i);\n      VdbeComment((v, \"%s\", p->pEList->a[i].zName));\n    }\n  }else if( eDest!=SRT_Exists ){\n#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n    ExprList *pExtra = 0;\n#endif\n    /* If the destination is an EXISTS(...) expression, the actual\n    ** values returned by the SELECT are not required.\n    */\n    u8 ecelFlags;    /* \"ecel\" is an abbreviation of \"ExprCodeExprList\" */\n    ExprList *pEList;\n    if( eDest==SRT_Mem || eDest==SRT_Output || eDest==SRT_Coroutine ){\n      ecelFlags = SQLITE_ECEL_DUP;\n    }else{\n      ecelFlags = 0;\n    }\n    if( pSort && hasDistinct==0 && eDest!=SRT_EphemTab && eDest!=SRT_Table ){\n      /* For each expression in p->pEList that is a copy of an expression in\n      ** the ORDER BY clause (pSort->pOrderBy), set the associated \n      ** iOrderByCol value to one more than the index of the ORDER BY \n      ** expression within the sort-key that pushOntoSorter() will generate.\n      ** This allows the p->pEList field to be omitted from the sorted record,\n      ** saving space and CPU cycles.  */\n      ecelFlags |= (SQLITE_ECEL_OMITREF|SQLITE_ECEL_REF);\n\n      for(i=pSort->nOBSat; i<pSort->pOrderBy->nExpr; i++){\n        int j;\n        if( (j = pSort->pOrderBy->a[i].u.x.iOrderByCol)>0 ){\n          p->pEList->a[j-1].u.x.iOrderByCol = i+1-pSort->nOBSat;\n        }\n      }\n#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n      selectExprDefer(pParse, pSort, p->pEList, &pExtra);\n      if( pExtra && pParse->db->mallocFailed==0 ){\n        /* If there are any extra PK columns to add to the sorter records,\n        ** allocate extra memory cells and adjust the OpenEphemeral \n        ** instruction to account for the larger records. This is only\n        ** required if there are one or more WITHOUT ROWID tables with\n        ** composite primary keys in the SortCtx.aDefer[] array.  */\n        VdbeOp *pOp = sqlite3VdbeGetOp(v, pSort->addrSortIndex);\n        pOp->p2 += (pExtra->nExpr - pSort->nDefer);\n        pOp->p4.pKeyInfo->nAllField += (pExtra->nExpr - pSort->nDefer);\n        pParse->nMem += pExtra->nExpr;\n      }\n#endif\n\n      /* Adjust nResultCol to account for columns that are omitted\n      ** from the sorter by the optimizations in this branch */\n      pEList = p->pEList;\n      for(i=0; i<pEList->nExpr; i++){\n        if( pEList->a[i].u.x.iOrderByCol>0\n#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n         || pEList->a[i].bSorterRef\n#endif\n        ){\n          nResultCol--;\n          regOrig = 0;\n        }\n      }\n\n      testcase( regOrig );\n      testcase( eDest==SRT_Set );\n      testcase( eDest==SRT_Mem );\n      testcase( eDest==SRT_Coroutine );\n      testcase( eDest==SRT_Output );\n      assert( eDest==SRT_Set || eDest==SRT_Mem \n           || eDest==SRT_Coroutine || eDest==SRT_Output );\n    }\n    sRowLoadInfo.regResult = regResult;\n    sRowLoadInfo.ecelFlags = ecelFlags;\n#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n    sRowLoadInfo.pExtra = pExtra;\n    sRowLoadInfo.regExtraResult = regResult + nResultCol;\n    if( pExtra ) nResultCol += pExtra->nExpr;\n#endif\n    if( p->iLimit\n     && (ecelFlags & SQLITE_ECEL_OMITREF)!=0 \n     && nPrefixReg>0\n    ){\n      assert( pSort!=0 );\n      assert( hasDistinct==0 );\n      pSort->pDeferredRowLoad = &sRowLoadInfo;\n      regOrig = 0;\n    }else{\n      innerLoopLoadRow(pParse, p, &sRowLoadInfo);\n    }\n  }\n\n  /* If the DISTINCT keyword was present on the SELECT statement\n  ** and this row has been seen before, then do not make this row\n  ** part of the result.\n  */\n  if( hasDistinct ){\n    switch( pDistinct->eTnctType ){\n      case WHERE_DISTINCT_ORDERED: {\n        VdbeOp *pOp;            /* No longer required OpenEphemeral instr. */\n        int iJump;              /* Jump destination */\n        int regPrev;            /* Previous row content */\n\n        /* Allocate space for the previous row */\n        regPrev = pParse->nMem+1;\n        pParse->nMem += nResultCol;\n\n        /* Change the OP_OpenEphemeral coded earlier to an OP_Null\n        ** sets the MEM_Cleared bit on the first register of the\n        ** previous value.  This will cause the OP_Ne below to always\n        ** fail on the first iteration of the loop even if the first\n        ** row is all NULLs.\n        */\n        sqlite3VdbeChangeToNoop(v, pDistinct->addrTnct);\n        pOp = sqlite3VdbeGetOp(v, pDistinct->addrTnct);\n        pOp->opcode = OP_Null;\n        pOp->p1 = 1;\n        pOp->p2 = regPrev;\n        pOp = 0;  /* Ensure pOp is not used after sqlite3VdbeAddOp() */\n\n        iJump = sqlite3VdbeCurrentAddr(v) + nResultCol;\n        for(i=0; i<nResultCol; i++){\n          CollSeq *pColl = sqlite3ExprCollSeq(pParse, p->pEList->a[i].pExpr);\n          if( i<nResultCol-1 ){\n            sqlite3VdbeAddOp3(v, OP_Ne, regResult+i, iJump, regPrev+i);\n            VdbeCoverage(v);\n          }else{\n            sqlite3VdbeAddOp3(v, OP_Eq, regResult+i, iContinue, regPrev+i);\n            VdbeCoverage(v);\n           }\n          sqlite3VdbeChangeP4(v, -1, (const char *)pColl, P4_COLLSEQ);\n          sqlite3VdbeChangeP5(v, SQLITE_NULLEQ);\n        }\n        assert( sqlite3VdbeCurrentAddr(v)==iJump || pParse->db->mallocFailed );\n        sqlite3VdbeAddOp3(v, OP_Copy, regResult, regPrev, nResultCol-1);\n        break;\n      }\n\n      case WHERE_DISTINCT_UNIQUE: {\n        sqlite3VdbeChangeToNoop(v, pDistinct->addrTnct);\n        break;\n      }\n\n      default: {\n        assert( pDistinct->eTnctType==WHERE_DISTINCT_UNORDERED );\n        codeDistinct(pParse, pDistinct->tabTnct, iContinue, nResultCol,\n                     regResult);\n        break;\n      }\n    }\n    if( pSort==0 ){\n      codeOffset(v, p->iOffset, iContinue);\n    }\n  }\n\n  switch( eDest ){\n    /* In this mode, write each query result to the key of the temporary\n    ** table iParm.\n    */\n#ifndef SQLITE_OMIT_COMPOUND_SELECT\n    case SRT_Union: {\n      int r1;\n      r1 = sqlite3GetTempReg(pParse);\n      sqlite3VdbeAddOp3(v, OP_MakeRecord, regResult, nResultCol, r1);\n      sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, r1, regResult, nResultCol);\n      sqlite3ReleaseTempReg(pParse, r1);\n      break;\n    }\n\n    /* Construct a record from the query result, but instead of\n    ** saving that record, use it as a key to delete elements from\n    ** the temporary table iParm.\n    */\n    case SRT_Except: {\n      sqlite3VdbeAddOp3(v, OP_IdxDelete, iParm, regResult, nResultCol);\n      break;\n    }\n#endif /* SQLITE_OMIT_COMPOUND_SELECT */\n\n    /* Store the result as data using a unique key.\n    */\n    case SRT_Fifo:\n    case SRT_DistFifo:\n    case SRT_Table:\n    case SRT_EphemTab: {\n      int r1 = sqlite3GetTempRange(pParse, nPrefixReg+1);\n      testcase( eDest==SRT_Table );\n      testcase( eDest==SRT_EphemTab );\n      testcase( eDest==SRT_Fifo );\n      testcase( eDest==SRT_DistFifo );\n      sqlite3VdbeAddOp3(v, OP_MakeRecord, regResult, nResultCol, r1+nPrefixReg);\n#ifndef SQLITE_OMIT_CTE\n      if( eDest==SRT_DistFifo ){\n        /* If the destination is DistFifo, then cursor (iParm+1) is open\n        ** on an ephemeral index. If the current row is already present\n        ** in the index, do not write it to the output. If not, add the\n        ** current row to the index and proceed with writing it to the\n        ** output table as well.  */\n        int addr = sqlite3VdbeCurrentAddr(v) + 4;\n        sqlite3VdbeAddOp4Int(v, OP_Found, iParm+1, addr, r1, 0);\n        VdbeCoverage(v);\n        sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm+1, r1,regResult,nResultCol);\n        assert( pSort==0 );\n      }\n#endif\n      if( pSort ){\n        assert( regResult==regOrig );\n        pushOntoSorter(pParse, pSort, p, r1+nPrefixReg, regOrig, 1, nPrefixReg);\n      }else{\n        int r2 = sqlite3GetTempReg(pParse);\n        sqlite3VdbeAddOp2(v, OP_NewRowid, iParm, r2);\n        sqlite3VdbeAddOp3(v, OP_Insert, iParm, r1, r2);\n        sqlite3VdbeChangeP5(v, OPFLAG_APPEND);\n        sqlite3ReleaseTempReg(pParse, r2);\n      }\n      sqlite3ReleaseTempRange(pParse, r1, nPrefixReg+1);\n      break;\n    }\n\n#ifndef SQLITE_OMIT_SUBQUERY\n    /* If we are creating a set for an \"expr IN (SELECT ...)\" construct,\n    ** then there should be a single item on the stack.  Write this\n    ** item into the set table with bogus data.\n    */\n    case SRT_Set: {\n      if( pSort ){\n        /* At first glance you would think we could optimize out the\n        ** ORDER BY in this case since the order of entries in the set\n        ** does not matter.  But there might be a LIMIT clause, in which\n        ** case the order does matter */\n        pushOntoSorter(\n            pParse, pSort, p, regResult, regOrig, nResultCol, nPrefixReg);\n      }else{\n        int r1 = sqlite3GetTempReg(pParse);\n        assert( sqlite3Strlen30(pDest->zAffSdst)==nResultCol );\n        sqlite3VdbeAddOp4(v, OP_MakeRecord, regResult, nResultCol, \n            r1, pDest->zAffSdst, nResultCol);\n        sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, r1, regResult, nResultCol);\n        sqlite3ReleaseTempReg(pParse, r1);\n      }\n      break;\n    }\n\n    /* If any row exist in the result set, record that fact and abort.\n    */\n    case SRT_Exists: {\n      sqlite3VdbeAddOp2(v, OP_Integer, 1, iParm);\n      /* The LIMIT clause will terminate the loop for us */\n      break;\n    }\n\n    /* If this is a scalar select that is part of an expression, then\n    ** store the results in the appropriate memory cell or array of \n    ** memory cells and break out of the scan loop.\n    */\n    case SRT_Mem: {\n      if( pSort ){\n        assert( nResultCol<=pDest->nSdst );\n        pushOntoSorter(\n            pParse, pSort, p, regResult, regOrig, nResultCol, nPrefixReg);\n      }else{\n        assert( nResultCol==pDest->nSdst );\n        assert( regResult==iParm );\n        /* The LIMIT clause will jump out of the loop for us */\n      }\n      break;\n    }\n#endif /* #ifndef SQLITE_OMIT_SUBQUERY */\n\n    case SRT_Coroutine:       /* Send data to a co-routine */\n    case SRT_Output: {        /* Return the results */\n      testcase( eDest==SRT_Coroutine );\n      testcase( eDest==SRT_Output );\n      if( pSort ){\n        pushOntoSorter(pParse, pSort, p, regResult, regOrig, nResultCol,\n                       nPrefixReg);\n      }else if( eDest==SRT_Coroutine ){\n        sqlite3VdbeAddOp1(v, OP_Yield, pDest->iSDParm);\n      }else{\n        sqlite3VdbeAddOp2(v, OP_ResultRow, regResult, nResultCol);\n      }\n      break;\n    }\n\n#ifndef SQLITE_OMIT_CTE\n    /* Write the results into a priority queue that is order according to\n    ** pDest->pOrderBy (in pSO).  pDest->iSDParm (in iParm) is the cursor for an\n    ** index with pSO->nExpr+2 columns.  Build a key using pSO for the first\n    ** pSO->nExpr columns, then make sure all keys are unique by adding a\n    ** final OP_Sequence column.  The last column is the record as a blob.\n    */\n    case SRT_DistQueue:\n    case SRT_Queue: {\n      int nKey;\n      int r1, r2, r3;\n      int addrTest = 0;\n      ExprList *pSO;\n      pSO = pDest->pOrderBy;\n      assert( pSO );\n      nKey = pSO->nExpr;\n      r1 = sqlite3GetTempReg(pParse);\n      r2 = sqlite3GetTempRange(pParse, nKey+2);\n      r3 = r2+nKey+1;\n      if( eDest==SRT_DistQueue ){\n        /* If the destination is DistQueue, then cursor (iParm+1) is open\n        ** on a second ephemeral index that holds all values every previously\n        ** added to the queue. */\n        addrTest = sqlite3VdbeAddOp4Int(v, OP_Found, iParm+1, 0, \n                                        regResult, nResultCol);\n        VdbeCoverage(v);\n      }\n      sqlite3VdbeAddOp3(v, OP_MakeRecord, regResult, nResultCol, r3);\n      if( eDest==SRT_DistQueue ){\n        sqlite3VdbeAddOp2(v, OP_IdxInsert, iParm+1, r3);\n        sqlite3VdbeChangeP5(v, OPFLAG_USESEEKRESULT);\n      }\n      for(i=0; i<nKey; i++){\n        sqlite3VdbeAddOp2(v, OP_SCopy,\n                          regResult + pSO->a[i].u.x.iOrderByCol - 1,\n                          r2+i);\n      }\n      sqlite3VdbeAddOp2(v, OP_Sequence, iParm, r2+nKey);\n      sqlite3VdbeAddOp3(v, OP_MakeRecord, r2, nKey+2, r1);\n      sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, r1, r2, nKey+2);\n      if( addrTest ) sqlite3VdbeJumpHere(v, addrTest);\n      sqlite3ReleaseTempReg(pParse, r1);\n      sqlite3ReleaseTempRange(pParse, r2, nKey+2);\n      break;\n    }\n#endif /* SQLITE_OMIT_CTE */\n\n\n\n#if !defined(SQLITE_OMIT_TRIGGER)\n    /* Discard the results.  This is used for SELECT statements inside\n    ** the body of a TRIGGER.  The purpose of such selects is to call\n    ** user-defined functions that have side effects.  We do not care\n    ** about the actual results of the select.\n    */\n    default: {\n      assert( eDest==SRT_Discard );\n      break;\n    }\n#endif\n  }\n\n  /* Jump to the end of the loop if the LIMIT is reached.  Except, if\n  ** there is a sorter, in which case the sorter has already limited\n  ** the output for us.\n  */\n  if( pSort==0 && p->iLimit ){\n    sqlite3VdbeAddOp2(v, OP_DecrJumpZero, p->iLimit, iBreak); VdbeCoverage(v);\n  }\n}\n\n/*\n** Allocate a KeyInfo object sufficient for an index of N key columns and\n** X extra columns.\n*/\nKeyInfo *sqlite3KeyInfoAlloc(sqlite3 *db, int N, int X){\n  int nExtra = (N+X)*(sizeof(CollSeq*)+1) - sizeof(CollSeq*);\n  KeyInfo *p = sqlite3DbMallocRawNN(db, sizeof(KeyInfo) + nExtra);\n  if( p ){\n    p->aSortFlags = (u8*)&p->aColl[N+X];\n    p->nKeyField = (u16)N;\n    p->nAllField = (u16)(N+X);\n    p->enc = ENC(db);\n    p->db = db;\n    p->nRef = 1;\n    memset(&p[1], 0, nExtra);\n  }else{\n    sqlite3OomFault(db);\n  }\n  return p;\n}\n\n/*\n** Deallocate a KeyInfo object\n*/\nvoid sqlite3KeyInfoUnref(KeyInfo *p){\n  if( p ){\n    assert( p->nRef>0 );\n    p->nRef--;\n    if( p->nRef==0 ) sqlite3DbFreeNN(p->db, p);\n  }\n}\n\n/*\n** Make a new pointer to a KeyInfo object\n*/\nKeyInfo *sqlite3KeyInfoRef(KeyInfo *p){\n  if( p ){\n    assert( p->nRef>0 );\n    p->nRef++;\n  }\n  return p;\n}\n\n#ifdef SQLITE_DEBUG\n/*\n** Return TRUE if a KeyInfo object can be change.  The KeyInfo object\n** can only be changed if this is just a single reference to the object.\n**\n** This routine is used only inside of assert() statements.\n*/\nint sqlite3KeyInfoIsWriteable(KeyInfo *p){ return p->nRef==1; }\n#endif /* SQLITE_DEBUG */\n\n/*\n** Given an expression list, generate a KeyInfo structure that records\n** the collating sequence for each expression in that expression list.\n**\n** If the ExprList is an ORDER BY or GROUP BY clause then the resulting\n** KeyInfo structure is appropriate for initializing a virtual index to\n** implement that clause.  If the ExprList is the result set of a SELECT\n** then the KeyInfo structure is appropriate for initializing a virtual\n** index to implement a DISTINCT test.\n**\n** Space to hold the KeyInfo structure is obtained from malloc.  The calling\n** function is responsible for seeing that this structure is eventually\n** freed.\n*/\nKeyInfo *sqlite3KeyInfoFromExprList(\n  Parse *pParse,       /* Parsing context */\n  ExprList *pList,     /* Form the KeyInfo object from this ExprList */\n  int iStart,          /* Begin with this column of pList */\n  int nExtra           /* Add this many extra columns to the end */\n){\n  int nExpr;\n  KeyInfo *pInfo;\n  struct ExprList_item *pItem;\n  sqlite3 *db = pParse->db;\n  int i;\n\n  nExpr = pList->nExpr;\n  pInfo = sqlite3KeyInfoAlloc(db, nExpr-iStart, nExtra+1);\n  if( pInfo ){\n    assert( sqlite3KeyInfoIsWriteable(pInfo) );\n    for(i=iStart, pItem=pList->a+iStart; i<nExpr; i++, pItem++){\n      pInfo->aColl[i-iStart] = sqlite3ExprNNCollSeq(pParse, pItem->pExpr);\n      pInfo->aSortFlags[i-iStart] = pItem->sortFlags;\n    }\n  }\n  return pInfo;\n}\n\n/*\n** Name of the connection operator, used for error messages.\n*/\nstatic const char *selectOpName(int id){\n  char *z;\n  switch( id ){\n    case TK_ALL:       z = \"UNION ALL\";   break;\n    case TK_INTERSECT: z = \"INTERSECT\";   break;\n    case TK_EXCEPT:    z = \"EXCEPT\";      break;\n    default:           z = \"UNION\";       break;\n  }\n  return z;\n}\n\n#ifndef SQLITE_OMIT_EXPLAIN\n/*\n** Unless an \"EXPLAIN QUERY PLAN\" command is being processed, this function\n** is a no-op. Otherwise, it adds a single row of output to the EQP result,\n** where the caption is of the form:\n**\n**   \"USE TEMP B-TREE FOR xxx\"\n**\n** where xxx is one of \"DISTINCT\", \"ORDER BY\" or \"GROUP BY\". Exactly which\n** is determined by the zUsage argument.\n*/\nstatic void explainTempTable(Parse *pParse, const char *zUsage){\n  ExplainQueryPlan((pParse, 0, \"USE TEMP B-TREE FOR %s\", zUsage));\n}\n\n/*\n** Assign expression b to lvalue a. A second, no-op, version of this macro\n** is provided when SQLITE_OMIT_EXPLAIN is defined. This allows the code\n** in sqlite3Select() to assign values to structure member variables that\n** only exist if SQLITE_OMIT_EXPLAIN is not defined without polluting the\n** code with #ifndef directives.\n*/\n# define explainSetInteger(a, b) a = b\n\n#else\n/* No-op versions of the explainXXX() functions and macros. */\n# define explainTempTable(y,z)\n# define explainSetInteger(y,z)\n#endif\n\n\n/*\n** If the inner loop was generated using a non-null pOrderBy argument,\n** then the results were placed in a sorter.  After the loop is terminated\n** we need to run the sorter and output the results.  The following\n** routine generates the code needed to do that.\n*/\nstatic void generateSortTail(\n  Parse *pParse,    /* Parsing context */\n  Select *p,        /* The SELECT statement */\n  SortCtx *pSort,   /* Information on the ORDER BY clause */\n  int nColumn,      /* Number of columns of data */\n  SelectDest *pDest /* Write the sorted results here */\n){\n  Vdbe *v = pParse->pVdbe;                     /* The prepared statement */\n  int addrBreak = pSort->labelDone;            /* Jump here to exit loop */\n  int addrContinue = sqlite3VdbeMakeLabel(pParse);/* Jump here for next cycle */\n  int addr;                       /* Top of output loop. Jump for Next. */\n  int addrOnce = 0;\n  int iTab;\n  ExprList *pOrderBy = pSort->pOrderBy;\n  int eDest = pDest->eDest;\n  int iParm = pDest->iSDParm;\n  int regRow;\n  int regRowid;\n  int iCol;\n  int nKey;                       /* Number of key columns in sorter record */\n  int iSortTab;                   /* Sorter cursor to read from */\n  int i;\n  int bSeq;                       /* True if sorter record includes seq. no. */\n  int nRefKey = 0;\n  struct ExprList_item *aOutEx = p->pEList->a;\n\n  assert( addrBreak<0 );\n  if( pSort->labelBkOut ){\n    sqlite3VdbeAddOp2(v, OP_Gosub, pSort->regReturn, pSort->labelBkOut);\n    sqlite3VdbeGoto(v, addrBreak);\n    sqlite3VdbeResolveLabel(v, pSort->labelBkOut);\n  }\n\n#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n  /* Open any cursors needed for sorter-reference expressions */\n  for(i=0; i<pSort->nDefer; i++){\n    Table *pTab = pSort->aDefer[i].pTab;\n    int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n    sqlite3OpenTable(pParse, pSort->aDefer[i].iCsr, iDb, pTab, OP_OpenRead);\n    nRefKey = MAX(nRefKey, pSort->aDefer[i].nKey);\n  }\n#endif\n\n  iTab = pSort->iECursor;\n  if( eDest==SRT_Output || eDest==SRT_Coroutine || eDest==SRT_Mem ){\n    regRowid = 0;\n    regRow = pDest->iSdst;\n  }else{\n    regRowid = sqlite3GetTempReg(pParse);\n    if( eDest==SRT_EphemTab || eDest==SRT_Table ){\n      regRow = sqlite3GetTempReg(pParse);\n      nColumn = 0;\n    }else{\n      regRow = sqlite3GetTempRange(pParse, nColumn);\n    }\n  }\n  nKey = pOrderBy->nExpr - pSort->nOBSat;\n  if( pSort->sortFlags & SORTFLAG_UseSorter ){\n    int regSortOut = ++pParse->nMem;\n    iSortTab = pParse->nTab++;\n    if( pSort->labelBkOut ){\n      addrOnce = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);\n    }\n    sqlite3VdbeAddOp3(v, OP_OpenPseudo, iSortTab, regSortOut, \n        nKey+1+nColumn+nRefKey);\n    if( addrOnce ) sqlite3VdbeJumpHere(v, addrOnce);\n    addr = 1 + sqlite3VdbeAddOp2(v, OP_SorterSort, iTab, addrBreak);\n    VdbeCoverage(v);\n    codeOffset(v, p->iOffset, addrContinue);\n    sqlite3VdbeAddOp3(v, OP_SorterData, iTab, regSortOut, iSortTab);\n    bSeq = 0;\n  }else{\n    addr = 1 + sqlite3VdbeAddOp2(v, OP_Sort, iTab, addrBreak); VdbeCoverage(v);\n    codeOffset(v, p->iOffset, addrContinue);\n    iSortTab = iTab;\n    bSeq = 1;\n  }\n  for(i=0, iCol=nKey+bSeq-1; i<nColumn; i++){\n#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n    if( aOutEx[i].bSorterRef ) continue;\n#endif\n    if( aOutEx[i].u.x.iOrderByCol==0 ) iCol++;\n  }\n#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n  if( pSort->nDefer ){\n    int iKey = iCol+1;\n    int regKey = sqlite3GetTempRange(pParse, nRefKey);\n\n    for(i=0; i<pSort->nDefer; i++){\n      int iCsr = pSort->aDefer[i].iCsr;\n      Table *pTab = pSort->aDefer[i].pTab;\n      int nKey = pSort->aDefer[i].nKey;\n\n      sqlite3VdbeAddOp1(v, OP_NullRow, iCsr);\n      if( HasRowid(pTab) ){\n        sqlite3VdbeAddOp3(v, OP_Column, iSortTab, iKey++, regKey);\n        sqlite3VdbeAddOp3(v, OP_SeekRowid, iCsr, \n            sqlite3VdbeCurrentAddr(v)+1, regKey);\n      }else{\n        int k;\n        int iJmp;\n        assert( sqlite3PrimaryKeyIndex(pTab)->nKeyCol==nKey );\n        for(k=0; k<nKey; k++){\n          sqlite3VdbeAddOp3(v, OP_Column, iSortTab, iKey++, regKey+k);\n        }\n        iJmp = sqlite3VdbeCurrentAddr(v);\n        sqlite3VdbeAddOp4Int(v, OP_SeekGE, iCsr, iJmp+2, regKey, nKey);\n        sqlite3VdbeAddOp4Int(v, OP_IdxLE, iCsr, iJmp+3, regKey, nKey);\n        sqlite3VdbeAddOp1(v, OP_NullRow, iCsr);\n      }\n    }\n    sqlite3ReleaseTempRange(pParse, regKey, nRefKey);\n  }\n#endif\n  for(i=nColumn-1; i>=0; i--){\n#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n    if( aOutEx[i].bSorterRef ){\n      sqlite3ExprCode(pParse, aOutEx[i].pExpr, regRow+i);\n    }else\n#endif\n    {\n      int iRead;\n      if( aOutEx[i].u.x.iOrderByCol ){\n        iRead = aOutEx[i].u.x.iOrderByCol-1;\n      }else{\n        iRead = iCol--;\n      }\n      sqlite3VdbeAddOp3(v, OP_Column, iSortTab, iRead, regRow+i);\n      VdbeComment((v, \"%s\", aOutEx[i].zName?aOutEx[i].zName : aOutEx[i].zSpan));\n    }\n  }\n  switch( eDest ){\n    case SRT_Table:\n    case SRT_EphemTab: {\n      sqlite3VdbeAddOp3(v, OP_Column, iSortTab, nKey+bSeq, regRow);\n      sqlite3VdbeAddOp2(v, OP_NewRowid, iParm, regRowid);\n      sqlite3VdbeAddOp3(v, OP_Insert, iParm, regRow, regRowid);\n      sqlite3VdbeChangeP5(v, OPFLAG_APPEND);\n      break;\n    }\n#ifndef SQLITE_OMIT_SUBQUERY\n    case SRT_Set: {\n      assert( nColumn==sqlite3Strlen30(pDest->zAffSdst) );\n      sqlite3VdbeAddOp4(v, OP_MakeRecord, regRow, nColumn, regRowid,\n                        pDest->zAffSdst, nColumn);\n      sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, regRowid, regRow, nColumn);\n      break;\n    }\n    case SRT_Mem: {\n      /* The LIMIT clause will terminate the loop for us */\n      break;\n    }\n#endif\n    default: {\n      assert( eDest==SRT_Output || eDest==SRT_Coroutine ); \n      testcase( eDest==SRT_Output );\n      testcase( eDest==SRT_Coroutine );\n      if( eDest==SRT_Output ){\n        sqlite3VdbeAddOp2(v, OP_ResultRow, pDest->iSdst, nColumn);\n      }else{\n        sqlite3VdbeAddOp1(v, OP_Yield, pDest->iSDParm);\n      }\n      break;\n    }\n  }\n  if( regRowid ){\n    if( eDest==SRT_Set ){\n      sqlite3ReleaseTempRange(pParse, regRow, nColumn);\n    }else{\n      sqlite3ReleaseTempReg(pParse, regRow);\n    }\n    sqlite3ReleaseTempReg(pParse, regRowid);\n  }\n  /* The bottom of the loop\n  */\n  sqlite3VdbeResolveLabel(v, addrContinue);\n  if( pSort->sortFlags & SORTFLAG_UseSorter ){\n    sqlite3VdbeAddOp2(v, OP_SorterNext, iTab, addr); VdbeCoverage(v);\n  }else{\n    sqlite3VdbeAddOp2(v, OP_Next, iTab, addr); VdbeCoverage(v);\n  }\n  if( pSort->regReturn ) sqlite3VdbeAddOp1(v, OP_Return, pSort->regReturn);\n  sqlite3VdbeResolveLabel(v, addrBreak);\n}\n\n/*\n** Return a pointer to a string containing the 'declaration type' of the\n** expression pExpr. The string may be treated as static by the caller.\n**\n** Also try to estimate the size of the returned value and return that\n** result in *pEstWidth.\n**\n** The declaration type is the exact datatype definition extracted from the\n** original CREATE TABLE statement if the expression is a column. The\n** declaration type for a ROWID field is INTEGER. Exactly when an expression\n** is considered a column can be complex in the presence of subqueries. The\n** result-set expression in all of the following SELECT statements is \n** considered a column by this function.\n**\n**   SELECT col FROM tbl;\n**   SELECT (SELECT col FROM tbl;\n**   SELECT (SELECT col FROM tbl);\n**   SELECT abc FROM (SELECT col AS abc FROM tbl);\n** \n** The declaration type for any expression other than a column is NULL.\n**\n** This routine has either 3 or 6 parameters depending on whether or not\n** the SQLITE_ENABLE_COLUMN_METADATA compile-time option is used.\n*/\n#ifdef SQLITE_ENABLE_COLUMN_METADATA\n# define columnType(A,B,C,D,E) columnTypeImpl(A,B,C,D,E)\n#else /* if !defined(SQLITE_ENABLE_COLUMN_METADATA) */\n# define columnType(A,B,C,D,E) columnTypeImpl(A,B)\n#endif\nstatic const char *columnTypeImpl(\n  NameContext *pNC, \n#ifndef SQLITE_ENABLE_COLUMN_METADATA\n  Expr *pExpr\n#else\n  Expr *pExpr,\n  const char **pzOrigDb,\n  const char **pzOrigTab,\n  const char **pzOrigCol\n#endif\n){\n  char const *zType = 0;\n  int j;\n#ifdef SQLITE_ENABLE_COLUMN_METADATA\n  char const *zOrigDb = 0;\n  char const *zOrigTab = 0;\n  char const *zOrigCol = 0;\n#endif\n\n  assert( pExpr!=0 );\n  assert( pNC->pSrcList!=0 );\n  switch( pExpr->op ){\n    case TK_COLUMN: {\n      /* The expression is a column. Locate the table the column is being\n      ** extracted from in NameContext.pSrcList. This table may be real\n      ** database table or a subquery.\n      */\n      Table *pTab = 0;            /* Table structure column is extracted from */\n      Select *pS = 0;             /* Select the column is extracted from */\n      int iCol = pExpr->iColumn;  /* Index of column in pTab */\n      while( pNC && !pTab ){\n        SrcList *pTabList = pNC->pSrcList;\n        for(j=0;j<pTabList->nSrc && pTabList->a[j].iCursor!=pExpr->iTable;j++);\n        if( j<pTabList->nSrc ){\n          pTab = pTabList->a[j].pTab;\n          pS = pTabList->a[j].pSelect;\n        }else{\n          pNC = pNC->pNext;\n        }\n      }\n\n      if( pTab==0 ){\n        /* At one time, code such as \"SELECT new.x\" within a trigger would\n        ** cause this condition to run.  Since then, we have restructured how\n        ** trigger code is generated and so this condition is no longer \n        ** possible. However, it can still be true for statements like\n        ** the following:\n        **\n        **   CREATE TABLE t1(col INTEGER);\n        **   SELECT (SELECT t1.col) FROM FROM t1;\n        **\n        ** when columnType() is called on the expression \"t1.col\" in the \n        ** sub-select. In this case, set the column type to NULL, even\n        ** though it should really be \"INTEGER\".\n        **\n        ** This is not a problem, as the column type of \"t1.col\" is never\n        ** used. When columnType() is called on the expression \n        ** \"(SELECT t1.col)\", the correct type is returned (see the TK_SELECT\n        ** branch below.  */\n        break;\n      }\n\n      assert( pTab && pExpr->y.pTab==pTab );\n      if( pS ){\n        /* The \"table\" is actually a sub-select or a view in the FROM clause\n        ** of the SELECT statement. Return the declaration type and origin\n        ** data for the result-set column of the sub-select.\n        */\n        if( iCol>=0 && iCol<pS->pEList->nExpr ){\n          /* If iCol is less than zero, then the expression requests the\n          ** rowid of the sub-select or view. This expression is legal (see \n          ** test case misc2.2.2) - it always evaluates to NULL.\n          */\n          NameContext sNC;\n          Expr *p = pS->pEList->a[iCol].pExpr;\n          sNC.pSrcList = pS->pSrc;\n          sNC.pNext = pNC;\n          sNC.pParse = pNC->pParse;\n          zType = columnType(&sNC, p,&zOrigDb,&zOrigTab,&zOrigCol); \n        }\n      }else{\n        /* A real table or a CTE table */\n        assert( !pS );\n#ifdef SQLITE_ENABLE_COLUMN_METADATA\n        if( iCol<0 ) iCol = pTab->iPKey;\n        assert( iCol==XN_ROWID || (iCol>=0 && iCol<pTab->nCol) );\n        if( iCol<0 ){\n          zType = \"INTEGER\";\n          zOrigCol = \"rowid\";\n        }else{\n          zOrigCol = pTab->aCol[iCol].zName;\n          zType = sqlite3ColumnType(&pTab->aCol[iCol],0);\n        }\n        zOrigTab = pTab->zName;\n        if( pNC->pParse && pTab->pSchema ){\n          int iDb = sqlite3SchemaToIndex(pNC->pParse->db, pTab->pSchema);\n          zOrigDb = pNC->pParse->db->aDb[iDb].zDbSName;\n        }\n#else\n        assert( iCol==XN_ROWID || (iCol>=0 && iCol<pTab->nCol) );\n        if( iCol<0 ){\n          zType = \"INTEGER\";\n        }else{\n          zType = sqlite3ColumnType(&pTab->aCol[iCol],0);\n        }\n#endif\n      }\n      break;\n    }\n#ifndef SQLITE_OMIT_SUBQUERY\n    case TK_SELECT: {\n      /* The expression is a sub-select. Return the declaration type and\n      ** origin info for the single column in the result set of the SELECT\n      ** statement.\n      */\n      NameContext sNC;\n      Select *pS = pExpr->x.pSelect;\n      Expr *p = pS->pEList->a[0].pExpr;\n      assert( ExprHasProperty(pExpr, EP_xIsSelect) );\n      sNC.pSrcList = pS->pSrc;\n      sNC.pNext = pNC;\n      sNC.pParse = pNC->pParse;\n      zType = columnType(&sNC, p, &zOrigDb, &zOrigTab, &zOrigCol); \n      break;\n    }\n#endif\n  }\n\n#ifdef SQLITE_ENABLE_COLUMN_METADATA  \n  if( pzOrigDb ){\n    assert( pzOrigTab && pzOrigCol );\n    *pzOrigDb = zOrigDb;\n    *pzOrigTab = zOrigTab;\n    *pzOrigCol = zOrigCol;\n  }\n#endif\n  return zType;\n}\n\n/*\n** Generate code that will tell the VDBE the declaration types of columns\n** in the result set.\n*/\nstatic void generateColumnTypes(\n  Parse *pParse,      /* Parser context */\n  SrcList *pTabList,  /* List of tables */\n  ExprList *pEList    /* Expressions defining the result set */\n){\n#ifndef SQLITE_OMIT_DECLTYPE\n  Vdbe *v = pParse->pVdbe;\n  int i;\n  NameContext sNC;\n  sNC.pSrcList = pTabList;\n  sNC.pParse = pParse;\n  sNC.pNext = 0;\n  for(i=0; i<pEList->nExpr; i++){\n    Expr *p = pEList->a[i].pExpr;\n    const char *zType;\n#ifdef SQLITE_ENABLE_COLUMN_METADATA\n    const char *zOrigDb = 0;\n    const char *zOrigTab = 0;\n    const char *zOrigCol = 0;\n    zType = columnType(&sNC, p, &zOrigDb, &zOrigTab, &zOrigCol);\n\n    /* The vdbe must make its own copy of the column-type and other \n    ** column specific strings, in case the schema is reset before this\n    ** virtual machine is deleted.\n    */\n    sqlite3VdbeSetColName(v, i, COLNAME_DATABASE, zOrigDb, SQLITE_TRANSIENT);\n    sqlite3VdbeSetColName(v, i, COLNAME_TABLE, zOrigTab, SQLITE_TRANSIENT);\n    sqlite3VdbeSetColName(v, i, COLNAME_COLUMN, zOrigCol, SQLITE_TRANSIENT);\n#else\n    zType = columnType(&sNC, p, 0, 0, 0);\n#endif\n    sqlite3VdbeSetColName(v, i, COLNAME_DECLTYPE, zType, SQLITE_TRANSIENT);\n  }\n#endif /* !defined(SQLITE_OMIT_DECLTYPE) */\n}\n\n\n/*\n** Compute the column names for a SELECT statement.\n**\n** The only guarantee that SQLite makes about column names is that if the\n** column has an AS clause assigning it a name, that will be the name used.\n** That is the only documented guarantee.  However, countless applications\n** developed over the years have made baseless assumptions about column names\n** and will break if those assumptions changes.  Hence, use extreme caution\n** when modifying this routine to avoid breaking legacy.\n**\n** See Also: sqlite3ColumnsFromExprList()\n**\n** The PRAGMA short_column_names and PRAGMA full_column_names settings are\n** deprecated.  The default setting is short=ON, full=OFF.  99.9% of all\n** applications should operate this way.  Nevertheless, we need to support the\n** other modes for legacy:\n**\n**    short=OFF, full=OFF:      Column name is the text of the expression has it\n**                              originally appears in the SELECT statement.  In\n**                              other words, the zSpan of the result expression.\n**\n**    short=ON, full=OFF:       (This is the default setting).  If the result\n**                              refers directly to a table column, then the\n**                              result column name is just the table column\n**                              name: COLUMN.  Otherwise use zSpan.\n**\n**    full=ON, short=ANY:       If the result refers directly to a table column,\n**                              then the result column name with the table name\n**                              prefix, ex: TABLE.COLUMN.  Otherwise use zSpan.\n*/\nstatic void generateColumnNames(\n  Parse *pParse,      /* Parser context */\n  Select *pSelect     /* Generate column names for this SELECT statement */\n){\n  Vdbe *v = pParse->pVdbe;\n  int i;\n  Table *pTab;\n  SrcList *pTabList;\n  ExprList *pEList;\n  sqlite3 *db = pParse->db;\n  int fullName;    /* TABLE.COLUMN if no AS clause and is a direct table ref */\n  int srcName;     /* COLUMN or TABLE.COLUMN if no AS clause and is direct */\n\n#ifndef SQLITE_OMIT_EXPLAIN\n  /* If this is an EXPLAIN, skip this step */\n  if( pParse->explain ){\n    return;\n  }\n#endif\n\n  if( pParse->colNamesSet ) return;\n  /* Column names are determined by the left-most term of a compound select */\n  while( pSelect->pPrior ) pSelect = pSelect->pPrior;\n  SELECTTRACE(1,pParse,pSelect,(\"generating column names\\n\"));\n  pTabList = pSelect->pSrc;\n  pEList = pSelect->pEList;\n  assert( v!=0 );\n  assert( pTabList!=0 );\n  pParse->colNamesSet = 1;\n  fullName = (db->flags & SQLITE_FullColNames)!=0;\n  srcName = (db->flags & SQLITE_ShortColNames)!=0 || fullName;\n  sqlite3VdbeSetNumCols(v, pEList->nExpr);\n  for(i=0; i<pEList->nExpr; i++){\n    Expr *p = pEList->a[i].pExpr;\n\n    assert( p!=0 );\n    assert( p->op!=TK_AGG_COLUMN );  /* Agg processing has not run yet */\n    assert( p->op!=TK_COLUMN || p->y.pTab!=0 ); /* Covering idx not yet coded */\n    if( pEList->a[i].zName ){\n      /* An AS clause always takes first priority */\n      char *zName = pEList->a[i].zName;\n      sqlite3VdbeSetColName(v, i, COLNAME_NAME, zName, SQLITE_TRANSIENT);\n    }else if( srcName && p->op==TK_COLUMN ){\n      char *zCol;\n      int iCol = p->iColumn;\n      pTab = p->y.pTab;\n      assert( pTab!=0 );\n      if( iCol<0 ) iCol = pTab->iPKey;\n      assert( iCol==-1 || (iCol>=0 && iCol<pTab->nCol) );\n      if( iCol<0 ){\n        zCol = \"rowid\";\n      }else{\n        zCol = pTab->aCol[iCol].zName;\n      }\n      if( fullName ){\n        char *zName = 0;\n        zName = sqlite3MPrintf(db, \"%s.%s\", pTab->zName, zCol);\n        sqlite3VdbeSetColName(v, i, COLNAME_NAME, zName, SQLITE_DYNAMIC);\n      }else{\n        sqlite3VdbeSetColName(v, i, COLNAME_NAME, zCol, SQLITE_TRANSIENT);\n      }\n    }else{\n      const char *z = pEList->a[i].zSpan;\n      z = z==0 ? sqlite3MPrintf(db, \"column%d\", i+1) : sqlite3DbStrDup(db, z);\n      sqlite3VdbeSetColName(v, i, COLNAME_NAME, z, SQLITE_DYNAMIC);\n    }\n  }\n  generateColumnTypes(pParse, pTabList, pEList);\n}\n\n/*\n** Given an expression list (which is really the list of expressions\n** that form the result set of a SELECT statement) compute appropriate\n** column names for a table that would hold the expression list.\n**\n** All column names will be unique.\n**\n** Only the column names are computed.  Column.zType, Column.zColl,\n** and other fields of Column are zeroed.\n**\n** Return SQLITE_OK on success.  If a memory allocation error occurs,\n** store NULL in *paCol and 0 in *pnCol and return SQLITE_NOMEM.\n**\n** The only guarantee that SQLite makes about column names is that if the\n** column has an AS clause assigning it a name, that will be the name used.\n** That is the only documented guarantee.  However, countless applications\n** developed over the years have made baseless assumptions about column names\n** and will break if those assumptions changes.  Hence, use extreme caution\n** when modifying this routine to avoid breaking legacy.\n**\n** See Also: generateColumnNames()\n*/\nint sqlite3ColumnsFromExprList(\n  Parse *pParse,          /* Parsing context */\n  ExprList *pEList,       /* Expr list from which to derive column names */\n  i16 *pnCol,             /* Write the number of columns here */\n  Column **paCol          /* Write the new column list here */\n){\n  sqlite3 *db = pParse->db;   /* Database connection */\n  int i, j;                   /* Loop counters */\n  u32 cnt;                    /* Index added to make the name unique */\n  Column *aCol, *pCol;        /* For looping over result columns */\n  int nCol;                   /* Number of columns in the result set */\n  char *zName;                /* Column name */\n  int nName;                  /* Size of name in zName[] */\n  Hash ht;                    /* Hash table of column names */\n\n  sqlite3HashInit(&ht);\n  if( pEList ){\n    nCol = pEList->nExpr;\n    aCol = sqlite3DbMallocZero(db, sizeof(aCol[0])*nCol);\n    testcase( aCol==0 );\n    if( nCol>32767 ) nCol = 32767;\n  }else{\n    nCol = 0;\n    aCol = 0;\n  }\n  assert( nCol==(i16)nCol );\n  *pnCol = nCol;\n  *paCol = aCol;\n\n  for(i=0, pCol=aCol; i<nCol && !db->mallocFailed; i++, pCol++){\n    /* Get an appropriate name for the column\n    */\n    if( (zName = pEList->a[i].zName)!=0 ){\n      /* If the column contains an \"AS <name>\" phrase, use <name> as the name */\n    }else{\n      Expr *pColExpr = sqlite3ExprSkipCollateAndLikely(pEList->a[i].pExpr);\n      while( pColExpr->op==TK_DOT ){\n        pColExpr = pColExpr->pRight;\n        assert( pColExpr!=0 );\n      }\n      if( pColExpr->op==TK_COLUMN ){\n        /* For columns use the column name name */\n        int iCol = pColExpr->iColumn;\n        Table *pTab = pColExpr->y.pTab;\n        assert( pTab!=0 );\n        if( iCol<0 ) iCol = pTab->iPKey;\n        zName = iCol>=0 ? pTab->aCol[iCol].zName : \"rowid\";\n      }else if( pColExpr->op==TK_ID ){\n        assert( !ExprHasProperty(pColExpr, EP_IntValue) );\n        zName = pColExpr->u.zToken;\n      }else{\n        /* Use the original text of the column expression as its name */\n        zName = pEList->a[i].zSpan;\n      }\n    }\n    if( zName ){\n      zName = sqlite3DbStrDup(db, zName);\n    }else{\n      zName = sqlite3MPrintf(db,\"column%d\",i+1);\n    }\n\n    /* Make sure the column name is unique.  If the name is not unique,\n    ** append an integer to the name so that it becomes unique.\n    */\n    cnt = 0;\n    while( zName && sqlite3HashFind(&ht, zName)!=0 ){\n      nName = sqlite3Strlen30(zName);\n      if( nName>0 ){\n        for(j=nName-1; j>0 && sqlite3Isdigit(zName[j]); j--){}\n        if( zName[j]==':' ) nName = j;\n      }\n      zName = sqlite3MPrintf(db, \"%.*z:%u\", nName, zName, ++cnt);\n      if( cnt>3 ) sqlite3_randomness(sizeof(cnt), &cnt);\n    }\n    pCol->zName = zName;\n    sqlite3ColumnPropertiesFromName(0, pCol);\n    if( zName && sqlite3HashInsert(&ht, zName, pCol)==pCol ){\n      sqlite3OomFault(db);\n    }\n  }\n  sqlite3HashClear(&ht);\n  if( db->mallocFailed ){\n    for(j=0; j<i; j++){\n      sqlite3DbFree(db, aCol[j].zName);\n    }\n    sqlite3DbFree(db, aCol);\n    *paCol = 0;\n    *pnCol = 0;\n    return SQLITE_NOMEM_BKPT;\n  }\n  return SQLITE_OK;\n}\n\n/*\n** Add type and collation information to a column list based on\n** a SELECT statement.\n** \n** The column list presumably came from selectColumnNamesFromExprList().\n** The column list has only names, not types or collations.  This\n** routine goes through and adds the types and collations.\n**\n** This routine requires that all identifiers in the SELECT\n** statement be resolved.\n*/\nvoid sqlite3SelectAddColumnTypeAndCollation(\n  Parse *pParse,        /* Parsing contexts */\n  Table *pTab,          /* Add column type information to this table */\n  Select *pSelect,      /* SELECT used to determine types and collations */\n  char aff              /* Default affinity for columns */\n){\n  sqlite3 *db = pParse->db;\n  NameContext sNC;\n  Column *pCol;\n  CollSeq *pColl;\n  int i;\n  Expr *p;\n  struct ExprList_item *a;\n\n  assert( pSelect!=0 );\n  assert( (pSelect->selFlags & SF_Resolved)!=0 );\n  assert( pTab->nCol==pSelect->pEList->nExpr || db->mallocFailed );\n  if( db->mallocFailed ) return;\n  memset(&sNC, 0, sizeof(sNC));\n  sNC.pSrcList = pSelect->pSrc;\n  a = pSelect->pEList->a;\n  for(i=0, pCol=pTab->aCol; i<pTab->nCol; i++, pCol++){\n    const char *zType;\n    int n, m;\n    p = a[i].pExpr;\n    zType = columnType(&sNC, p, 0, 0, 0);\n    /* pCol->szEst = ... // Column size est for SELECT tables never used */\n    pCol->affinity = sqlite3ExprAffinity(p);\n    if( zType ){\n      m = sqlite3Strlen30(zType);\n      n = sqlite3Strlen30(pCol->zName);\n      pCol->zName = sqlite3DbReallocOrFree(db, pCol->zName, n+m+2);\n      if( pCol->zName ){\n        memcpy(&pCol->zName[n+1], zType, m+1);\n        pCol->colFlags |= COLFLAG_HASTYPE;\n      }\n    }\n    if( pCol->affinity<=SQLITE_AFF_NONE ) pCol->affinity = aff;\n    pColl = sqlite3ExprCollSeq(pParse, p);\n    if( pColl && pCol->zColl==0 ){\n      pCol->zColl = sqlite3DbStrDup(db, pColl->zName);\n    }\n  }\n  pTab->szTabRow = 1; /* Any non-zero value works */\n}\n\n/*\n** Given a SELECT statement, generate a Table structure that describes\n** the result set of that SELECT.\n*/\nTable *sqlite3ResultSetOfSelect(Parse *pParse, Select *pSelect, char aff){\n  Table *pTab;\n  sqlite3 *db = pParse->db;\n  u64 savedFlags;\n\n  savedFlags = db->flags;\n  db->flags &= ~(u64)SQLITE_FullColNames;\n  db->flags |= SQLITE_ShortColNames;\n  sqlite3SelectPrep(pParse, pSelect, 0);\n  db->flags = savedFlags;\n  if( pParse->nErr ) return 0;\n  while( pSelect->pPrior ) pSelect = pSelect->pPrior;\n  pTab = sqlite3DbMallocZero(db, sizeof(Table) );\n  if( pTab==0 ){\n    return 0;\n  }\n  pTab->nTabRef = 1;\n  pTab->zName = 0;\n  pTab->nRowLogEst = 200; assert( 200==sqlite3LogEst(1048576) );\n  sqlite3ColumnsFromExprList(pParse, pSelect->pEList, &pTab->nCol, &pTab->aCol);\n  sqlite3SelectAddColumnTypeAndCollation(pParse, pTab, pSelect, aff);\n  pTab->iPKey = -1;\n  if( db->mallocFailed ){\n    sqlite3DeleteTable(db, pTab);\n    return 0;\n  }\n  return pTab;\n}\n\n/*\n** Get a VDBE for the given parser context.  Create a new one if necessary.\n** If an error occurs, return NULL and leave a message in pParse.\n*/\nVdbe *sqlite3GetVdbe(Parse *pParse){\n  if( pParse->pVdbe ){\n    return pParse->pVdbe;\n  }\n  if( pParse->pToplevel==0\n   && OptimizationEnabled(pParse->db,SQLITE_FactorOutConst)\n  ){\n    pParse->okConstFactor = 1;\n  }\n  return sqlite3VdbeCreate(pParse);\n}\n\n\n/*\n** Compute the iLimit and iOffset fields of the SELECT based on the\n** pLimit expressions.  pLimit->pLeft and pLimit->pRight hold the expressions\n** that appear in the original SQL statement after the LIMIT and OFFSET\n** keywords.  Or NULL if those keywords are omitted. iLimit and iOffset \n** are the integer memory register numbers for counters used to compute \n** the limit and offset.  If there is no limit and/or offset, then \n** iLimit and iOffset are negative.\n**\n** This routine changes the values of iLimit and iOffset only if\n** a limit or offset is defined by pLimit->pLeft and pLimit->pRight.  iLimit\n** and iOffset should have been preset to appropriate default values (zero)\n** prior to calling this routine.\n**\n** The iOffset register (if it exists) is initialized to the value\n** of the OFFSET.  The iLimit register is initialized to LIMIT.  Register\n** iOffset+1 is initialized to LIMIT+OFFSET.\n**\n** Only if pLimit->pLeft!=0 do the limit registers get\n** redefined.  The UNION ALL operator uses this property to force\n** the reuse of the same limit and offset registers across multiple\n** SELECT statements.\n*/\nstatic void computeLimitRegisters(Parse *pParse, Select *p, int iBreak){\n  Vdbe *v = 0;\n  int iLimit = 0;\n  int iOffset;\n  int n;\n  Expr *pLimit = p->pLimit;\n\n  if( p->iLimit ) return;\n\n  /* \n  ** \"LIMIT -1\" always shows all rows.  There is some\n  ** controversy about what the correct behavior should be.\n  ** The current implementation interprets \"LIMIT 0\" to mean\n  ** no rows.\n  */\n  if( pLimit ){\n    assert( pLimit->op==TK_LIMIT );\n    assert( pLimit->pLeft!=0 );\n    p->iLimit = iLimit = ++pParse->nMem;\n    v = sqlite3GetVdbe(pParse);\n    assert( v!=0 );\n    if( sqlite3ExprIsInteger(pLimit->pLeft, &n) ){\n      sqlite3VdbeAddOp2(v, OP_Integer, n, iLimit);\n      VdbeComment((v, \"LIMIT counter\"));\n      if( n==0 ){\n        sqlite3VdbeGoto(v, iBreak);\n      }else if( n>=0 && p->nSelectRow>sqlite3LogEst((u64)n) ){\n        p->nSelectRow = sqlite3LogEst((u64)n);\n        p->selFlags |= SF_FixedLimit;\n      }\n    }else{\n      sqlite3ExprCode(pParse, pLimit->pLeft, iLimit);\n      sqlite3VdbeAddOp1(v, OP_MustBeInt, iLimit); VdbeCoverage(v);\n      VdbeComment((v, \"LIMIT counter\"));\n      sqlite3VdbeAddOp2(v, OP_IfNot, iLimit, iBreak); VdbeCoverage(v);\n    }\n    if( pLimit->pRight ){\n      p->iOffset = iOffset = ++pParse->nMem;\n      pParse->nMem++;   /* Allocate an extra register for limit+offset */\n      sqlite3ExprCode(pParse, pLimit->pRight, iOffset);\n      sqlite3VdbeAddOp1(v, OP_MustBeInt, iOffset); VdbeCoverage(v);\n      VdbeComment((v, \"OFFSET counter\"));\n      sqlite3VdbeAddOp3(v, OP_OffsetLimit, iLimit, iOffset+1, iOffset);\n      VdbeComment((v, \"LIMIT+OFFSET\"));\n    }\n  }\n}\n\n#ifndef SQLITE_OMIT_COMPOUND_SELECT\n/*\n** Return the appropriate collating sequence for the iCol-th column of\n** the result set for the compound-select statement \"p\".  Return NULL if\n** the column has no default collating sequence.\n**\n** The collating sequence for the compound select is taken from the\n** left-most term of the select that has a collating sequence.\n*/\nstatic CollSeq *multiSelectCollSeq(Parse *pParse, Select *p, int iCol){\n  CollSeq *pRet;\n  if( p->pPrior ){\n    pRet = multiSelectCollSeq(pParse, p->pPrior, iCol);\n  }else{\n    pRet = 0;\n  }\n  assert( iCol>=0 );\n  /* iCol must be less than p->pEList->nExpr.  Otherwise an error would\n  ** have been thrown during name resolution and we would not have gotten\n  ** this far */\n  if( pRet==0 && ALWAYS(iCol<p->pEList->nExpr) ){\n    pRet = sqlite3ExprCollSeq(pParse, p->pEList->a[iCol].pExpr);\n  }\n  return pRet;\n}\n\n/*\n** The select statement passed as the second parameter is a compound SELECT\n** with an ORDER BY clause. This function allocates and returns a KeyInfo\n** structure suitable for implementing the ORDER BY.\n**\n** Space to hold the KeyInfo structure is obtained from malloc. The calling\n** function is responsible for ensuring that this structure is eventually\n** freed.\n*/\nstatic KeyInfo *multiSelectOrderByKeyInfo(Parse *pParse, Select *p, int nExtra){\n  ExprList *pOrderBy = p->pOrderBy;\n  int nOrderBy = p->pOrderBy->nExpr;\n  sqlite3 *db = pParse->db;\n  KeyInfo *pRet = sqlite3KeyInfoAlloc(db, nOrderBy+nExtra, 1);\n  if( pRet ){\n    int i;\n    for(i=0; i<nOrderBy; i++){\n      struct ExprList_item *pItem = &pOrderBy->a[i];\n      Expr *pTerm = pItem->pExpr;\n      CollSeq *pColl;\n\n      if( pTerm->flags & EP_Collate ){\n        pColl = sqlite3ExprCollSeq(pParse, pTerm);\n      }else{\n        pColl = multiSelectCollSeq(pParse, p, pItem->u.x.iOrderByCol-1);\n        if( pColl==0 ) pColl = db->pDfltColl;\n        pOrderBy->a[i].pExpr =\n          sqlite3ExprAddCollateString(pParse, pTerm, pColl->zName);\n      }\n      assert( sqlite3KeyInfoIsWriteable(pRet) );\n      pRet->aColl[i] = pColl;\n      pRet->aSortFlags[i] = pOrderBy->a[i].sortFlags;\n    }\n  }\n\n  return pRet;\n}\n\n#ifndef SQLITE_OMIT_CTE\n/*\n** This routine generates VDBE code to compute the content of a WITH RECURSIVE\n** query of the form:\n**\n**   <recursive-table> AS (<setup-query> UNION [ALL] <recursive-query>)\n**                         \\___________/             \\_______________/\n**                           p->pPrior                      p\n**\n**\n** There is exactly one reference to the recursive-table in the FROM clause\n** of recursive-query, marked with the SrcList->a[].fg.isRecursive flag.\n**\n** The setup-query runs once to generate an initial set of rows that go\n** into a Queue table.  Rows are extracted from the Queue table one by\n** one.  Each row extracted from Queue is output to pDest.  Then the single\n** extracted row (now in the iCurrent table) becomes the content of the\n** recursive-table for a recursive-query run.  The output of the recursive-query\n** is added back into the Queue table.  Then another row is extracted from Queue\n** and the iteration continues until the Queue table is empty.\n**\n** If the compound query operator is UNION then no duplicate rows are ever\n** inserted into the Queue table.  The iDistinct table keeps a copy of all rows\n** that have ever been inserted into Queue and causes duplicates to be\n** discarded.  If the operator is UNION ALL, then duplicates are allowed.\n** \n** If the query has an ORDER BY, then entries in the Queue table are kept in\n** ORDER BY order and the first entry is extracted for each cycle.  Without\n** an ORDER BY, the Queue table is just a FIFO.\n**\n** If a LIMIT clause is provided, then the iteration stops after LIMIT rows\n** have been output to pDest.  A LIMIT of zero means to output no rows and a\n** negative LIMIT means to output all rows.  If there is also an OFFSET clause\n** with a positive value, then the first OFFSET outputs are discarded rather\n** than being sent to pDest.  The LIMIT count does not begin until after OFFSET\n** rows have been skipped.\n*/\nstatic void generateWithRecursiveQuery(\n  Parse *pParse,        /* Parsing context */\n  Select *p,            /* The recursive SELECT to be coded */\n  SelectDest *pDest     /* What to do with query results */\n){\n  SrcList *pSrc = p->pSrc;      /* The FROM clause of the recursive query */\n  int nCol = p->pEList->nExpr;  /* Number of columns in the recursive table */\n  Vdbe *v = pParse->pVdbe;      /* The prepared statement under construction */\n  Select *pSetup = p->pPrior;   /* The setup query */\n  int addrTop;                  /* Top of the loop */\n  int addrCont, addrBreak;      /* CONTINUE and BREAK addresses */\n  int iCurrent = 0;             /* The Current table */\n  int regCurrent;               /* Register holding Current table */\n  int iQueue;                   /* The Queue table */\n  int iDistinct = 0;            /* To ensure unique results if UNION */\n  int eDest = SRT_Fifo;         /* How to write to Queue */\n  SelectDest destQueue;         /* SelectDest targetting the Queue table */\n  int i;                        /* Loop counter */\n  int rc;                       /* Result code */\n  ExprList *pOrderBy;           /* The ORDER BY clause */\n  Expr *pLimit;                 /* Saved LIMIT and OFFSET */\n  int regLimit, regOffset;      /* Registers used by LIMIT and OFFSET */\n\n#ifndef SQLITE_OMIT_WINDOWFUNC\n  if( p->pWin ){\n    sqlite3ErrorMsg(pParse, \"cannot use window functions in recursive queries\");\n    return;\n  }\n#endif\n\n  /* Obtain authorization to do a recursive query */\n  if( sqlite3AuthCheck(pParse, SQLITE_RECURSIVE, 0, 0, 0) ) return;\n\n  /* Process the LIMIT and OFFSET clauses, if they exist */\n  addrBreak = sqlite3VdbeMakeLabel(pParse);\n  p->nSelectRow = 320;  /* 4 billion rows */\n  computeLimitRegisters(pParse, p, addrBreak);\n  pLimit = p->pLimit;\n  regLimit = p->iLimit;\n  regOffset = p->iOffset;\n  p->pLimit = 0;\n  p->iLimit = p->iOffset = 0;\n  pOrderBy = p->pOrderBy;\n\n  /* Locate the cursor number of the Current table */\n  for(i=0; ALWAYS(i<pSrc->nSrc); i++){\n    if( pSrc->a[i].fg.isRecursive ){\n      iCurrent = pSrc->a[i].iCursor;\n      break;\n    }\n  }\n\n  /* Allocate cursors numbers for Queue and Distinct.  The cursor number for\n  ** the Distinct table must be exactly one greater than Queue in order\n  ** for the SRT_DistFifo and SRT_DistQueue destinations to work. */\n  iQueue = pParse->nTab++;\n  if( p->op==TK_UNION ){\n    eDest = pOrderBy ? SRT_DistQueue : SRT_DistFifo;\n    iDistinct = pParse->nTab++;\n  }else{\n    eDest = pOrderBy ? SRT_Queue : SRT_Fifo;\n  }\n  sqlite3SelectDestInit(&destQueue, eDest, iQueue);\n\n  /* Allocate cursors for Current, Queue, and Distinct. */\n  regCurrent = ++pParse->nMem;\n  sqlite3VdbeAddOp3(v, OP_OpenPseudo, iCurrent, regCurrent, nCol);\n  if( pOrderBy ){\n    KeyInfo *pKeyInfo = multiSelectOrderByKeyInfo(pParse, p, 1);\n    sqlite3VdbeAddOp4(v, OP_OpenEphemeral, iQueue, pOrderBy->nExpr+2, 0,\n                      (char*)pKeyInfo, P4_KEYINFO);\n    destQueue.pOrderBy = pOrderBy;\n  }else{\n    sqlite3VdbeAddOp2(v, OP_OpenEphemeral, iQueue, nCol);\n  }\n  VdbeComment((v, \"Queue table\"));\n  if( iDistinct ){\n    p->addrOpenEphm[0] = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, iDistinct, 0);\n    p->selFlags |= SF_UsesEphemeral;\n  }\n\n  /* Detach the ORDER BY clause from the compound SELECT */\n  p->pOrderBy = 0;\n\n  /* Store the results of the setup-query in Queue. */\n  pSetup->pNext = 0;\n  ExplainQueryPlan((pParse, 1, \"SETUP\"));\n  rc = sqlite3Select(pParse, pSetup, &destQueue);\n  pSetup->pNext = p;\n  if( rc ) goto end_of_recursive_query;\n\n  /* Find the next row in the Queue and output that row */\n  addrTop = sqlite3VdbeAddOp2(v, OP_Rewind, iQueue, addrBreak); VdbeCoverage(v);\n\n  /* Transfer the next row in Queue over to Current */\n  sqlite3VdbeAddOp1(v, OP_NullRow, iCurrent); /* To reset column cache */\n  if( pOrderBy ){\n    sqlite3VdbeAddOp3(v, OP_Column, iQueue, pOrderBy->nExpr+1, regCurrent);\n  }else{\n    sqlite3VdbeAddOp2(v, OP_RowData, iQueue, regCurrent);\n  }\n  sqlite3VdbeAddOp1(v, OP_Delete, iQueue);\n\n  /* Output the single row in Current */\n  addrCont = sqlite3VdbeMakeLabel(pParse);\n  codeOffset(v, regOffset, addrCont);\n  selectInnerLoop(pParse, p, iCurrent,\n      0, 0, pDest, addrCont, addrBreak);\n  if( regLimit ){\n    sqlite3VdbeAddOp2(v, OP_DecrJumpZero, regLimit, addrBreak);\n    VdbeCoverage(v);\n  }\n  sqlite3VdbeResolveLabel(v, addrCont);\n\n  /* Execute the recursive SELECT taking the single row in Current as\n  ** the value for the recursive-table. Store the results in the Queue.\n  */\n  if( p->selFlags & SF_Aggregate ){\n    sqlite3ErrorMsg(pParse, \"recursive aggregate queries not supported\");\n  }else{\n    p->pPrior = 0;\n    ExplainQueryPlan((pParse, 1, \"RECURSIVE STEP\"));\n    sqlite3Select(pParse, p, &destQueue);\n    assert( p->pPrior==0 );\n    p->pPrior = pSetup;\n  }\n\n  /* Keep running the loop until the Queue is empty */\n  sqlite3VdbeGoto(v, addrTop);\n  sqlite3VdbeResolveLabel(v, addrBreak);\n\nend_of_recursive_query:\n  sqlite3ExprListDelete(pParse->db, p->pOrderBy);\n  p->pOrderBy = pOrderBy;\n  p->pLimit = pLimit;\n  return;\n}\n#endif /* SQLITE_OMIT_CTE */\n\n/* Forward references */\nstatic int multiSelectOrderBy(\n  Parse *pParse,        /* Parsing context */\n  Select *p,            /* The right-most of SELECTs to be coded */\n  SelectDest *pDest     /* What to do with query results */\n);\n\n/*\n** Handle the special case of a compound-select that originates from a\n** VALUES clause.  By handling this as a special case, we avoid deep\n** recursion, and thus do not need to enforce the SQLITE_LIMIT_COMPOUND_SELECT\n** on a VALUES clause.\n**\n** Because the Select object originates from a VALUES clause:\n**   (1) There is no LIMIT or OFFSET or else there is a LIMIT of exactly 1\n**   (2) All terms are UNION ALL\n**   (3) There is no ORDER BY clause\n**\n** The \"LIMIT of exactly 1\" case of condition (1) comes about when a VALUES\n** clause occurs within scalar expression (ex: \"SELECT (VALUES(1),(2),(3))\").\n** The sqlite3CodeSubselect will have added the LIMIT 1 clause in tht case.\n** Since the limit is exactly 1, we only need to evalutes the left-most VALUES.\n*/\nstatic int multiSelectValues(\n  Parse *pParse,        /* Parsing context */\n  Select *p,            /* The right-most of SELECTs to be coded */\n  SelectDest *pDest     /* What to do with query results */\n){\n  int nRow = 1;\n  int rc = 0;\n  int bShowAll = p->pLimit==0;\n  assert( p->selFlags & SF_MultiValue );\n  do{\n    assert( p->selFlags & SF_Values );\n    assert( p->op==TK_ALL || (p->op==TK_SELECT && p->pPrior==0) );\n    assert( p->pNext==0 || p->pEList->nExpr==p->pNext->pEList->nExpr );\n    if( p->pWin ) return -1;\n    if( p->pPrior==0 ) break;\n    assert( p->pPrior->pNext==p );\n    p = p->pPrior;\n    nRow += bShowAll;\n  }while(1);\n  ExplainQueryPlan((pParse, 0, \"SCAN %d CONSTANT ROW%s\", nRow,\n                    nRow==1 ? \"\" : \"S\"));\n  while( p ){\n    selectInnerLoop(pParse, p, -1, 0, 0, pDest, 1, 1);\n    if( !bShowAll ) break;\n    p->nSelectRow = nRow;\n    p = p->pNext;\n  }\n  return rc;\n}\n\n/*\n** This routine is called to process a compound query form from\n** two or more separate queries using UNION, UNION ALL, EXCEPT, or\n** INTERSECT\n**\n** \"p\" points to the right-most of the two queries.  the query on the\n** left is p->pPrior.  The left query could also be a compound query\n** in which case this routine will be called recursively. \n**\n** The results of the total query are to be written into a destination\n** of type eDest with parameter iParm.\n**\n** Example 1:  Consider a three-way compound SQL statement.\n**\n**     SELECT a FROM t1 UNION SELECT b FROM t2 UNION SELECT c FROM t3\n**\n** This statement is parsed up as follows:\n**\n**     SELECT c FROM t3\n**      |\n**      `----->  SELECT b FROM t2\n**                |\n**                `------>  SELECT a FROM t1\n**\n** The arrows in the diagram above represent the Select.pPrior pointer.\n** So if this routine is called with p equal to the t3 query, then\n** pPrior will be the t2 query.  p->op will be TK_UNION in this case.\n**\n** Notice that because of the way SQLite parses compound SELECTs, the\n** individual selects always group from left to right.\n*/\nstatic int multiSelect(\n  Parse *pParse,        /* Parsing context */\n  Select *p,            /* The right-most of SELECTs to be coded */\n  SelectDest *pDest     /* What to do with query results */\n){\n  int rc = SQLITE_OK;   /* Success code from a subroutine */\n  Select *pPrior;       /* Another SELECT immediately to our left */\n  Vdbe *v;              /* Generate code to this VDBE */\n  SelectDest dest;      /* Alternative data destination */\n  Select *pDelete = 0;  /* Chain of simple selects to delete */\n  sqlite3 *db;          /* Database connection */\n\n  /* Make sure there is no ORDER BY or LIMIT clause on prior SELECTs.  Only\n  ** the last (right-most) SELECT in the series may have an ORDER BY or LIMIT.\n  */\n  assert( p && p->pPrior );  /* Calling function guarantees this much */\n  assert( (p->selFlags & SF_Recursive)==0 || p->op==TK_ALL || p->op==TK_UNION );\n  assert( p->selFlags & SF_Compound );\n  db = pParse->db;\n  pPrior = p->pPrior;\n  dest = *pDest;\n  if( pPrior->pOrderBy || pPrior->pLimit ){\n    sqlite3ErrorMsg(pParse,\"%s clause should come after %s not before\",\n      pPrior->pOrderBy!=0 ? \"ORDER BY\" : \"LIMIT\", selectOpName(p->op));\n    rc = 1;\n    goto multi_select_end;\n  }\n\n  v = sqlite3GetVdbe(pParse);\n  assert( v!=0 );  /* The VDBE already created by calling function */\n\n  /* Create the destination temporary table if necessary\n  */\n  if( dest.eDest==SRT_EphemTab ){\n    assert( p->pEList );\n    sqlite3VdbeAddOp2(v, OP_OpenEphemeral, dest.iSDParm, p->pEList->nExpr);\n    dest.eDest = SRT_Table;\n  }\n\n  /* Special handling for a compound-select that originates as a VALUES clause.\n  */\n  if( p->selFlags & SF_MultiValue ){\n    rc = multiSelectValues(pParse, p, &dest);\n    if( rc>=0 ) goto multi_select_end;\n    rc = SQLITE_OK;\n  }\n\n  /* Make sure all SELECTs in the statement have the same number of elements\n  ** in their result sets.\n  */\n  assert( p->pEList && pPrior->pEList );\n  assert( p->pEList->nExpr==pPrior->pEList->nExpr );\n\n#ifndef SQLITE_OMIT_CTE\n  if( p->selFlags & SF_Recursive ){\n    generateWithRecursiveQuery(pParse, p, &dest);\n  }else\n#endif\n\n  /* Compound SELECTs that have an ORDER BY clause are handled separately.\n  */\n  if( p->pOrderBy ){\n    return multiSelectOrderBy(pParse, p, pDest);\n  }else{\n\n#ifndef SQLITE_OMIT_EXPLAIN\n    if( pPrior->pPrior==0 ){\n      ExplainQueryPlan((pParse, 1, \"COMPOUND QUERY\"));\n      ExplainQueryPlan((pParse, 1, \"LEFT-MOST SUBQUERY\"));\n    }\n#endif\n\n    /* Generate code for the left and right SELECT statements.\n    */\n    switch( p->op ){\n      case TK_ALL: {\n        int addr = 0;\n        int nLimit;\n        assert( !pPrior->pLimit );\n        pPrior->iLimit = p->iLimit;\n        pPrior->iOffset = p->iOffset;\n        pPrior->pLimit = p->pLimit;\n        rc = sqlite3Select(pParse, pPrior, &dest);\n        p->pLimit = 0;\n        if( rc ){\n          goto multi_select_end;\n        }\n        p->pPrior = 0;\n        p->iLimit = pPrior->iLimit;\n        p->iOffset = pPrior->iOffset;\n        if( p->iLimit ){\n          addr = sqlite3VdbeAddOp1(v, OP_IfNot, p->iLimit); VdbeCoverage(v);\n          VdbeComment((v, \"Jump ahead if LIMIT reached\"));\n          if( p->iOffset ){\n            sqlite3VdbeAddOp3(v, OP_OffsetLimit,\n                              p->iLimit, p->iOffset+1, p->iOffset);\n          }\n        }\n        ExplainQueryPlan((pParse, 1, \"UNION ALL\"));\n        rc = sqlite3Select(pParse, p, &dest);\n        testcase( rc!=SQLITE_OK );\n        pDelete = p->pPrior;\n        p->pPrior = pPrior;\n        p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);\n        if( pPrior->pLimit\n         && sqlite3ExprIsInteger(pPrior->pLimit->pLeft, &nLimit)\n         && nLimit>0 && p->nSelectRow > sqlite3LogEst((u64)nLimit) \n        ){\n          p->nSelectRow = sqlite3LogEst((u64)nLimit);\n        }\n        if( addr ){\n          sqlite3VdbeJumpHere(v, addr);\n        }\n        break;\n      }\n      case TK_EXCEPT:\n      case TK_UNION: {\n        int unionTab;    /* Cursor number of the temp table holding result */\n        u8 op = 0;       /* One of the SRT_ operations to apply to self */\n        int priorOp;     /* The SRT_ operation to apply to prior selects */\n        Expr *pLimit;    /* Saved values of p->nLimit  */\n        int addr;\n        SelectDest uniondest;\n  \n        testcase( p->op==TK_EXCEPT );\n        testcase( p->op==TK_UNION );\n        priorOp = SRT_Union;\n        if( dest.eDest==priorOp ){\n          /* We can reuse a temporary table generated by a SELECT to our\n          ** right.\n          */\n          assert( p->pLimit==0 );      /* Not allowed on leftward elements */\n          unionTab = dest.iSDParm;\n        }else{\n          /* We will need to create our own temporary table to hold the\n          ** intermediate results.\n          */\n          unionTab = pParse->nTab++;\n          assert( p->pOrderBy==0 );\n          addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, unionTab, 0);\n          assert( p->addrOpenEphm[0] == -1 );\n          p->addrOpenEphm[0] = addr;\n          findRightmost(p)->selFlags |= SF_UsesEphemeral;\n          assert( p->pEList );\n        }\n  \n        /* Code the SELECT statements to our left\n        */\n        assert( !pPrior->pOrderBy );\n        sqlite3SelectDestInit(&uniondest, priorOp, unionTab);\n        rc = sqlite3Select(pParse, pPrior, &uniondest);\n        if( rc ){\n          goto multi_select_end;\n        }\n  \n        /* Code the current SELECT statement\n        */\n        if( p->op==TK_EXCEPT ){\n          op = SRT_Except;\n        }else{\n          assert( p->op==TK_UNION );\n          op = SRT_Union;\n        }\n        p->pPrior = 0;\n        pLimit = p->pLimit;\n        p->pLimit = 0;\n        uniondest.eDest = op;\n        ExplainQueryPlan((pParse, 1, \"%s USING TEMP B-TREE\",\n                          selectOpName(p->op)));\n        rc = sqlite3Select(pParse, p, &uniondest);\n        testcase( rc!=SQLITE_OK );\n        /* Query flattening in sqlite3Select() might refill p->pOrderBy.\n        ** Be sure to delete p->pOrderBy, therefore, to avoid a memory leak. */\n        sqlite3ExprListDelete(db, p->pOrderBy);\n        pDelete = p->pPrior;\n        p->pPrior = pPrior;\n        p->pOrderBy = 0;\n        if( p->op==TK_UNION ){\n          p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);\n        }\n        sqlite3ExprDelete(db, p->pLimit);\n        p->pLimit = pLimit;\n        p->iLimit = 0;\n        p->iOffset = 0;\n  \n        /* Convert the data in the temporary table into whatever form\n        ** it is that we currently need.\n        */\n        assert( unionTab==dest.iSDParm || dest.eDest!=priorOp );\n        if( dest.eDest!=priorOp ){\n          int iCont, iBreak, iStart;\n          assert( p->pEList );\n          iBreak = sqlite3VdbeMakeLabel(pParse);\n          iCont = sqlite3VdbeMakeLabel(pParse);\n          computeLimitRegisters(pParse, p, iBreak);\n          sqlite3VdbeAddOp2(v, OP_Rewind, unionTab, iBreak); VdbeCoverage(v);\n          iStart = sqlite3VdbeCurrentAddr(v);\n          selectInnerLoop(pParse, p, unionTab,\n                          0, 0, &dest, iCont, iBreak);\n          sqlite3VdbeResolveLabel(v, iCont);\n          sqlite3VdbeAddOp2(v, OP_Next, unionTab, iStart); VdbeCoverage(v);\n          sqlite3VdbeResolveLabel(v, iBreak);\n          sqlite3VdbeAddOp2(v, OP_Close, unionTab, 0);\n        }\n        break;\n      }\n      default: assert( p->op==TK_INTERSECT ); {\n        int tab1, tab2;\n        int iCont, iBreak, iStart;\n        Expr *pLimit;\n        int addr;\n        SelectDest intersectdest;\n        int r1;\n  \n        /* INTERSECT is different from the others since it requires\n        ** two temporary tables.  Hence it has its own case.  Begin\n        ** by allocating the tables we will need.\n        */\n        tab1 = pParse->nTab++;\n        tab2 = pParse->nTab++;\n        assert( p->pOrderBy==0 );\n  \n        addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, tab1, 0);\n        assert( p->addrOpenEphm[0] == -1 );\n        p->addrOpenEphm[0] = addr;\n        findRightmost(p)->selFlags |= SF_UsesEphemeral;\n        assert( p->pEList );\n  \n        /* Code the SELECTs to our left into temporary table \"tab1\".\n        */\n        sqlite3SelectDestInit(&intersectdest, SRT_Union, tab1);\n        rc = sqlite3Select(pParse, pPrior, &intersectdest);\n        if( rc ){\n          goto multi_select_end;\n        }\n  \n        /* Code the current SELECT into temporary table \"tab2\"\n        */\n        addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, tab2, 0);\n        assert( p->addrOpenEphm[1] == -1 );\n        p->addrOpenEphm[1] = addr;\n        p->pPrior = 0;\n        pLimit = p->pLimit;\n        p->pLimit = 0;\n        intersectdest.iSDParm = tab2;\n        ExplainQueryPlan((pParse, 1, \"%s USING TEMP B-TREE\",\n                          selectOpName(p->op)));\n        rc = sqlite3Select(pParse, p, &intersectdest);\n        testcase( rc!=SQLITE_OK );\n        pDelete = p->pPrior;\n        p->pPrior = pPrior;\n        if( p->nSelectRow>pPrior->nSelectRow ){\n          p->nSelectRow = pPrior->nSelectRow;\n        }\n        sqlite3ExprDelete(db, p->pLimit);\n        p->pLimit = pLimit;\n  \n        /* Generate code to take the intersection of the two temporary\n        ** tables.\n        */\n        assert( p->pEList );\n        iBreak = sqlite3VdbeMakeLabel(pParse);\n        iCont = sqlite3VdbeMakeLabel(pParse);\n        computeLimitRegisters(pParse, p, iBreak);\n        sqlite3VdbeAddOp2(v, OP_Rewind, tab1, iBreak); VdbeCoverage(v);\n        r1 = sqlite3GetTempReg(pParse);\n        iStart = sqlite3VdbeAddOp2(v, OP_RowData, tab1, r1);\n        sqlite3VdbeAddOp4Int(v, OP_NotFound, tab2, iCont, r1, 0);\n        VdbeCoverage(v);\n        sqlite3ReleaseTempReg(pParse, r1);\n        selectInnerLoop(pParse, p, tab1,\n                        0, 0, &dest, iCont, iBreak);\n        sqlite3VdbeResolveLabel(v, iCont);\n        sqlite3VdbeAddOp2(v, OP_Next, tab1, iStart); VdbeCoverage(v);\n        sqlite3VdbeResolveLabel(v, iBreak);\n        sqlite3VdbeAddOp2(v, OP_Close, tab2, 0);\n        sqlite3VdbeAddOp2(v, OP_Close, tab1, 0);\n        break;\n      }\n    }\n  \n  #ifndef SQLITE_OMIT_EXPLAIN\n    if( p->pNext==0 ){\n      ExplainQueryPlanPop(pParse);\n    }\n  #endif\n  }\n  \n  /* Compute collating sequences used by \n  ** temporary tables needed to implement the compound select.\n  ** Attach the KeyInfo structure to all temporary tables.\n  **\n  ** This section is run by the right-most SELECT statement only.\n  ** SELECT statements to the left always skip this part.  The right-most\n  ** SELECT might also skip this part if it has no ORDER BY clause and\n  ** no temp tables are required.\n  */\n  if( p->selFlags & SF_UsesEphemeral ){\n    int i;                        /* Loop counter */\n    KeyInfo *pKeyInfo;            /* Collating sequence for the result set */\n    Select *pLoop;                /* For looping through SELECT statements */\n    CollSeq **apColl;             /* For looping through pKeyInfo->aColl[] */\n    int nCol;                     /* Number of columns in result set */\n\n    assert( p->pNext==0 );\n    nCol = p->pEList->nExpr;\n    pKeyInfo = sqlite3KeyInfoAlloc(db, nCol, 1);\n    if( !pKeyInfo ){\n      rc = SQLITE_NOMEM_BKPT;\n      goto multi_select_end;\n    }\n    for(i=0, apColl=pKeyInfo->aColl; i<nCol; i++, apColl++){\n      *apColl = multiSelectCollSeq(pParse, p, i);\n      if( 0==*apColl ){\n        *apColl = db->pDfltColl;\n      }\n    }\n\n    for(pLoop=p; pLoop; pLoop=pLoop->pPrior){\n      for(i=0; i<2; i++){\n        int addr = pLoop->addrOpenEphm[i];\n        if( addr<0 ){\n          /* If [0] is unused then [1] is also unused.  So we can\n          ** always safely abort as soon as the first unused slot is found */\n          assert( pLoop->addrOpenEphm[1]<0 );\n          break;\n        }\n        sqlite3VdbeChangeP2(v, addr, nCol);\n        sqlite3VdbeChangeP4(v, addr, (char*)sqlite3KeyInfoRef(pKeyInfo),\n                            P4_KEYINFO);\n        pLoop->addrOpenEphm[i] = -1;\n      }\n    }\n    sqlite3KeyInfoUnref(pKeyInfo);\n  }\n\nmulti_select_end:\n  pDest->iSdst = dest.iSdst;\n  pDest->nSdst = dest.nSdst;\n  sqlite3SelectDelete(db, pDelete);\n  return rc;\n}\n#endif /* SQLITE_OMIT_COMPOUND_SELECT */\n\n/*\n** Error message for when two or more terms of a compound select have different\n** size result sets.\n*/\nvoid sqlite3SelectWrongNumTermsError(Parse *pParse, Select *p){\n  if( p->selFlags & SF_Values ){\n    sqlite3ErrorMsg(pParse, \"all VALUES must have the same number of terms\");\n  }else{\n    sqlite3ErrorMsg(pParse, \"SELECTs to the left and right of %s\"\n      \" do not have the same number of result columns\", selectOpName(p->op));\n  }\n}\n\n/*\n** Code an output subroutine for a coroutine implementation of a\n** SELECT statment.\n**\n** The data to be output is contained in pIn->iSdst.  There are\n** pIn->nSdst columns to be output.  pDest is where the output should\n** be sent.\n**\n** regReturn is the number of the register holding the subroutine\n** return address.\n**\n** If regPrev>0 then it is the first register in a vector that\n** records the previous output.  mem[regPrev] is a flag that is false\n** if there has been no previous output.  If regPrev>0 then code is\n** generated to suppress duplicates.  pKeyInfo is used for comparing\n** keys.\n**\n** If the LIMIT found in p->iLimit is reached, jump immediately to\n** iBreak.\n*/\nstatic int generateOutputSubroutine(\n  Parse *pParse,          /* Parsing context */\n  Select *p,              /* The SELECT statement */\n  SelectDest *pIn,        /* Coroutine supplying data */\n  SelectDest *pDest,      /* Where to send the data */\n  int regReturn,          /* The return address register */\n  int regPrev,            /* Previous result register.  No uniqueness if 0 */\n  KeyInfo *pKeyInfo,      /* For comparing with previous entry */\n  int iBreak              /* Jump here if we hit the LIMIT */\n){\n  Vdbe *v = pParse->pVdbe;\n  int iContinue;\n  int addr;\n\n  addr = sqlite3VdbeCurrentAddr(v);\n  iContinue = sqlite3VdbeMakeLabel(pParse);\n\n  /* Suppress duplicates for UNION, EXCEPT, and INTERSECT \n  */\n  if( regPrev ){\n    int addr1, addr2;\n    addr1 = sqlite3VdbeAddOp1(v, OP_IfNot, regPrev); VdbeCoverage(v);\n    addr2 = sqlite3VdbeAddOp4(v, OP_Compare, pIn->iSdst, regPrev+1, pIn->nSdst,\n                              (char*)sqlite3KeyInfoRef(pKeyInfo), P4_KEYINFO);\n    sqlite3VdbeAddOp3(v, OP_Jump, addr2+2, iContinue, addr2+2); VdbeCoverage(v);\n    sqlite3VdbeJumpHere(v, addr1);\n    sqlite3VdbeAddOp3(v, OP_Copy, pIn->iSdst, regPrev+1, pIn->nSdst-1);\n    sqlite3VdbeAddOp2(v, OP_Integer, 1, regPrev);\n  }\n  if( pParse->db->mallocFailed ) return 0;\n\n  /* Suppress the first OFFSET entries if there is an OFFSET clause\n  */\n  codeOffset(v, p->iOffset, iContinue);\n\n  assert( pDest->eDest!=SRT_Exists );\n  assert( pDest->eDest!=SRT_Table );\n  switch( pDest->eDest ){\n    /* Store the result as data using a unique key.\n    */\n    case SRT_EphemTab: {\n      int r1 = sqlite3GetTempReg(pParse);\n      int r2 = sqlite3GetTempReg(pParse);\n      sqlite3VdbeAddOp3(v, OP_MakeRecord, pIn->iSdst, pIn->nSdst, r1);\n      sqlite3VdbeAddOp2(v, OP_NewRowid, pDest->iSDParm, r2);\n      sqlite3VdbeAddOp3(v, OP_Insert, pDest->iSDParm, r1, r2);\n      sqlite3VdbeChangeP5(v, OPFLAG_APPEND);\n      sqlite3ReleaseTempReg(pParse, r2);\n      sqlite3ReleaseTempReg(pParse, r1);\n      break;\n    }\n\n#ifndef SQLITE_OMIT_SUBQUERY\n    /* If we are creating a set for an \"expr IN (SELECT ...)\".\n    */\n    case SRT_Set: {\n      int r1;\n      testcase( pIn->nSdst>1 );\n      r1 = sqlite3GetTempReg(pParse);\n      sqlite3VdbeAddOp4(v, OP_MakeRecord, pIn->iSdst, pIn->nSdst, \n          r1, pDest->zAffSdst, pIn->nSdst);\n      sqlite3VdbeAddOp4Int(v, OP_IdxInsert, pDest->iSDParm, r1,\n                           pIn->iSdst, pIn->nSdst);\n      sqlite3ReleaseTempReg(pParse, r1);\n      break;\n    }\n\n    /* If this is a scalar select that is part of an expression, then\n    ** store the results in the appropriate memory cell and break out\n    ** of the scan loop.  Note that the select might return multiple columns\n    ** if it is the RHS of a row-value IN operator.\n    */\n    case SRT_Mem: {\n      if( pParse->nErr==0 ){\n        testcase( pIn->nSdst>1 );\n        sqlite3ExprCodeMove(pParse, pIn->iSdst, pDest->iSDParm, pIn->nSdst);\n      }\n      /* The LIMIT clause will jump out of the loop for us */\n      break;\n    }\n#endif /* #ifndef SQLITE_OMIT_SUBQUERY */\n\n    /* The results are stored in a sequence of registers\n    ** starting at pDest->iSdst.  Then the co-routine yields.\n    */\n    case SRT_Coroutine: {\n      if( pDest->iSdst==0 ){\n        pDest->iSdst = sqlite3GetTempRange(pParse, pIn->nSdst);\n        pDest->nSdst = pIn->nSdst;\n      }\n      sqlite3ExprCodeMove(pParse, pIn->iSdst, pDest->iSdst, pIn->nSdst);\n      sqlite3VdbeAddOp1(v, OP_Yield, pDest->iSDParm);\n      break;\n    }\n\n    /* If none of the above, then the result destination must be\n    ** SRT_Output.  This routine is never called with any other\n    ** destination other than the ones handled above or SRT_Output.\n    **\n    ** For SRT_Output, results are stored in a sequence of registers.  \n    ** Then the OP_ResultRow opcode is used to cause sqlite3_step() to\n    ** return the next row of result.\n    */\n    default: {\n      assert( pDest->eDest==SRT_Output );\n      sqlite3VdbeAddOp2(v, OP_ResultRow, pIn->iSdst, pIn->nSdst);\n      break;\n    }\n  }\n\n  /* Jump to the end of the loop if the LIMIT is reached.\n  */\n  if( p->iLimit ){\n    sqlite3VdbeAddOp2(v, OP_DecrJumpZero, p->iLimit, iBreak); VdbeCoverage(v);\n  }\n\n  /* Generate the subroutine return\n  */\n  sqlite3VdbeResolveLabel(v, iContinue);\n  sqlite3VdbeAddOp1(v, OP_Return, regReturn);\n\n  return addr;\n}\n\n/*\n** Alternative compound select code generator for cases when there\n** is an ORDER BY clause.\n**\n** We assume a query of the following form:\n**\n**      <selectA>  <operator>  <selectB>  ORDER BY <orderbylist>\n**\n** <operator> is one of UNION ALL, UNION, EXCEPT, or INTERSECT.  The idea\n** is to code both <selectA> and <selectB> with the ORDER BY clause as\n** co-routines.  Then run the co-routines in parallel and merge the results\n** into the output.  In addition to the two coroutines (called selectA and\n** selectB) there are 7 subroutines:\n**\n**    outA:    Move the output of the selectA coroutine into the output\n**             of the compound query.\n**\n**    outB:    Move the output of the selectB coroutine into the output\n**             of the compound query.  (Only generated for UNION and\n**             UNION ALL.  EXCEPT and INSERTSECT never output a row that\n**             appears only in B.)\n**\n**    AltB:    Called when there is data from both coroutines and A<B.\n**\n**    AeqB:    Called when there is data from both coroutines and A==B.\n**\n**    AgtB:    Called when there is data from both coroutines and A>B.\n**\n**    EofA:    Called when data is exhausted from selectA.\n**\n**    EofB:    Called when data is exhausted from selectB.\n**\n** The implementation of the latter five subroutines depend on which \n** <operator> is used:\n**\n**\n**             UNION ALL         UNION            EXCEPT          INTERSECT\n**          -------------  -----------------  --------------  -----------------\n**   AltB:   outA, nextA      outA, nextA       outA, nextA         nextA\n**\n**   AeqB:   outA, nextA         nextA             nextA         outA, nextA\n**\n**   AgtB:   outB, nextB      outB, nextB          nextB            nextB\n**\n**   EofA:   outB, nextB      outB, nextB          halt             halt\n**\n**   EofB:   outA, nextA      outA, nextA       outA, nextA         halt\n**\n** In the AltB, AeqB, and AgtB subroutines, an EOF on A following nextA\n** causes an immediate jump to EofA and an EOF on B following nextB causes\n** an immediate jump to EofB.  Within EofA and EofB, and EOF on entry or\n** following nextX causes a jump to the end of the select processing.\n**\n** Duplicate removal in the UNION, EXCEPT, and INTERSECT cases is handled\n** within the output subroutine.  The regPrev register set holds the previously\n** output value.  A comparison is made against this value and the output\n** is skipped if the next results would be the same as the previous.\n**\n** The implementation plan is to implement the two coroutines and seven\n** subroutines first, then put the control logic at the bottom.  Like this:\n**\n**          goto Init\n**     coA: coroutine for left query (A)\n**     coB: coroutine for right query (B)\n**    outA: output one row of A\n**    outB: output one row of B (UNION and UNION ALL only)\n**    EofA: ...\n**    EofB: ...\n**    AltB: ...\n**    AeqB: ...\n**    AgtB: ...\n**    Init: initialize coroutine registers\n**          yield coA\n**          if eof(A) goto EofA\n**          yield coB\n**          if eof(B) goto EofB\n**    Cmpr: Compare A, B\n**          Jump AltB, AeqB, AgtB\n**     End: ...\n**\n** We call AltB, AeqB, AgtB, EofA, and EofB \"subroutines\" but they are not\n** actually called using Gosub and they do not Return.  EofA and EofB loop\n** until all data is exhausted then jump to the \"end\" labe.  AltB, AeqB,\n** and AgtB jump to either L2 or to one of EofA or EofB.\n*/\n#ifndef SQLITE_OMIT_COMPOUND_SELECT\nstatic int multiSelectOrderBy(\n  Parse *pParse,        /* Parsing context */\n  Select *p,            /* The right-most of SELECTs to be coded */\n  SelectDest *pDest     /* What to do with query results */\n){\n  int i, j;             /* Loop counters */\n  Select *pPrior;       /* Another SELECT immediately to our left */\n  Vdbe *v;              /* Generate code to this VDBE */\n  SelectDest destA;     /* Destination for coroutine A */\n  SelectDest destB;     /* Destination for coroutine B */\n  int regAddrA;         /* Address register for select-A coroutine */\n  int regAddrB;         /* Address register for select-B coroutine */\n  int addrSelectA;      /* Address of the select-A coroutine */\n  int addrSelectB;      /* Address of the select-B coroutine */\n  int regOutA;          /* Address register for the output-A subroutine */\n  int regOutB;          /* Address register for the output-B subroutine */\n  int addrOutA;         /* Address of the output-A subroutine */\n  int addrOutB = 0;     /* Address of the output-B subroutine */\n  int addrEofA;         /* Address of the select-A-exhausted subroutine */\n  int addrEofA_noB;     /* Alternate addrEofA if B is uninitialized */\n  int addrEofB;         /* Address of the select-B-exhausted subroutine */\n  int addrAltB;         /* Address of the A<B subroutine */\n  int addrAeqB;         /* Address of the A==B subroutine */\n  int addrAgtB;         /* Address of the A>B subroutine */\n  int regLimitA;        /* Limit register for select-A */\n  int regLimitB;        /* Limit register for select-A */\n  int regPrev;          /* A range of registers to hold previous output */\n  int savedLimit;       /* Saved value of p->iLimit */\n  int savedOffset;      /* Saved value of p->iOffset */\n  int labelCmpr;        /* Label for the start of the merge algorithm */\n  int labelEnd;         /* Label for the end of the overall SELECT stmt */\n  int addr1;            /* Jump instructions that get retargetted */\n  int op;               /* One of TK_ALL, TK_UNION, TK_EXCEPT, TK_INTERSECT */\n  KeyInfo *pKeyDup = 0; /* Comparison information for duplicate removal */\n  KeyInfo *pKeyMerge;   /* Comparison information for merging rows */\n  sqlite3 *db;          /* Database connection */\n  ExprList *pOrderBy;   /* The ORDER BY clause */\n  int nOrderBy;         /* Number of terms in the ORDER BY clause */\n  int *aPermute;        /* Mapping from ORDER BY terms to result set columns */\n\n  assert( p->pOrderBy!=0 );\n  assert( pKeyDup==0 ); /* \"Managed\" code needs this.  Ticket #3382. */\n  db = pParse->db;\n  v = pParse->pVdbe;\n  assert( v!=0 );       /* Already thrown the error if VDBE alloc failed */\n  labelEnd = sqlite3VdbeMakeLabel(pParse);\n  labelCmpr = sqlite3VdbeMakeLabel(pParse);\n\n\n  /* Patch up the ORDER BY clause\n  */\n  op = p->op;  \n  pPrior = p->pPrior;\n  assert( pPrior->pOrderBy==0 );\n  pOrderBy = p->pOrderBy;\n  assert( pOrderBy );\n  nOrderBy = pOrderBy->nExpr;\n\n  /* For operators other than UNION ALL we have to make sure that\n  ** the ORDER BY clause covers every term of the result set.  Add\n  ** terms to the ORDER BY clause as necessary.\n  */\n  if( op!=TK_ALL ){\n    for(i=1; db->mallocFailed==0 && i<=p->pEList->nExpr; i++){\n      struct ExprList_item *pItem;\n      for(j=0, pItem=pOrderBy->a; j<nOrderBy; j++, pItem++){\n        assert( pItem->u.x.iOrderByCol>0 );\n        if( pItem->u.x.iOrderByCol==i ) break;\n      }\n      if( j==nOrderBy ){\n        Expr *pNew = sqlite3Expr(db, TK_INTEGER, 0);\n        if( pNew==0 ) return SQLITE_NOMEM_BKPT;\n        pNew->flags |= EP_IntValue;\n        pNew->u.iValue = i;\n        p->pOrderBy = pOrderBy = sqlite3ExprListAppend(pParse, pOrderBy, pNew);\n        if( pOrderBy ) pOrderBy->a[nOrderBy++].u.x.iOrderByCol = (u16)i;\n      }\n    }\n  }\n\n  /* Compute the comparison permutation and keyinfo that is used with\n  ** the permutation used to determine if the next\n  ** row of results comes from selectA or selectB.  Also add explicit\n  ** collations to the ORDER BY clause terms so that when the subqueries\n  ** to the right and the left are evaluated, they use the correct\n  ** collation.\n  */\n  aPermute = sqlite3DbMallocRawNN(db, sizeof(int)*(nOrderBy + 1));\n  if( aPermute ){\n    struct ExprList_item *pItem;\n    aPermute[0] = nOrderBy;\n    for(i=1, pItem=pOrderBy->a; i<=nOrderBy; i++, pItem++){\n      assert( pItem->u.x.iOrderByCol>0 );\n      assert( pItem->u.x.iOrderByCol<=p->pEList->nExpr );\n      aPermute[i] = pItem->u.x.iOrderByCol - 1;\n    }\n    pKeyMerge = multiSelectOrderByKeyInfo(pParse, p, 1);\n  }else{\n    pKeyMerge = 0;\n  }\n\n  /* Reattach the ORDER BY clause to the query.\n  */\n  p->pOrderBy = pOrderBy;\n  pPrior->pOrderBy = sqlite3ExprListDup(pParse->db, pOrderBy, 0);\n\n  /* Allocate a range of temporary registers and the KeyInfo needed\n  ** for the logic that removes duplicate result rows when the\n  ** operator is UNION, EXCEPT, or INTERSECT (but not UNION ALL).\n  */\n  if( op==TK_ALL ){\n    regPrev = 0;\n  }else{\n    int nExpr = p->pEList->nExpr;\n    assert( nOrderBy>=nExpr || db->mallocFailed );\n    regPrev = pParse->nMem+1;\n    pParse->nMem += nExpr+1;\n    sqlite3VdbeAddOp2(v, OP_Integer, 0, regPrev);\n    pKeyDup = sqlite3KeyInfoAlloc(db, nExpr, 1);\n    if( pKeyDup ){\n      assert( sqlite3KeyInfoIsWriteable(pKeyDup) );\n      for(i=0; i<nExpr; i++){\n        pKeyDup->aColl[i] = multiSelectCollSeq(pParse, p, i);\n        pKeyDup->aSortFlags[i] = 0;\n      }\n    }\n  }\n \n  /* Separate the left and the right query from one another\n  */\n  p->pPrior = 0;\n  pPrior->pNext = 0;\n  sqlite3ResolveOrderGroupBy(pParse, p, p->pOrderBy, \"ORDER\");\n  if( pPrior->pPrior==0 ){\n    sqlite3ResolveOrderGroupBy(pParse, pPrior, pPrior->pOrderBy, \"ORDER\");\n  }\n\n  /* Compute the limit registers */\n  computeLimitRegisters(pParse, p, labelEnd);\n  if( p->iLimit && op==TK_ALL ){\n    regLimitA = ++pParse->nMem;\n    regLimitB = ++pParse->nMem;\n    sqlite3VdbeAddOp2(v, OP_Copy, p->iOffset ? p->iOffset+1 : p->iLimit,\n                                  regLimitA);\n    sqlite3VdbeAddOp2(v, OP_Copy, regLimitA, regLimitB);\n  }else{\n    regLimitA = regLimitB = 0;\n  }\n  sqlite3ExprDelete(db, p->pLimit);\n  p->pLimit = 0;\n\n  regAddrA = ++pParse->nMem;\n  regAddrB = ++pParse->nMem;\n  regOutA = ++pParse->nMem;\n  regOutB = ++pParse->nMem;\n  sqlite3SelectDestInit(&destA, SRT_Coroutine, regAddrA);\n  sqlite3SelectDestInit(&destB, SRT_Coroutine, regAddrB);\n\n  ExplainQueryPlan((pParse, 1, \"MERGE (%s)\", selectOpName(p->op)));\n\n  /* Generate a coroutine to evaluate the SELECT statement to the\n  ** left of the compound operator - the \"A\" select.\n  */\n  addrSelectA = sqlite3VdbeCurrentAddr(v) + 1;\n  addr1 = sqlite3VdbeAddOp3(v, OP_InitCoroutine, regAddrA, 0, addrSelectA);\n  VdbeComment((v, \"left SELECT\"));\n  pPrior->iLimit = regLimitA;\n  ExplainQueryPlan((pParse, 1, \"LEFT\"));\n  sqlite3Select(pParse, pPrior, &destA);\n  sqlite3VdbeEndCoroutine(v, regAddrA);\n  sqlite3VdbeJumpHere(v, addr1);\n\n  /* Generate a coroutine to evaluate the SELECT statement on \n  ** the right - the \"B\" select\n  */\n  addrSelectB = sqlite3VdbeCurrentAddr(v) + 1;\n  addr1 = sqlite3VdbeAddOp3(v, OP_InitCoroutine, regAddrB, 0, addrSelectB);\n  VdbeComment((v, \"right SELECT\"));\n  savedLimit = p->iLimit;\n  savedOffset = p->iOffset;\n  p->iLimit = regLimitB;\n  p->iOffset = 0;  \n  ExplainQueryPlan((pParse, 1, \"RIGHT\"));\n  sqlite3Select(pParse, p, &destB);\n  p->iLimit = savedLimit;\n  p->iOffset = savedOffset;\n  sqlite3VdbeEndCoroutine(v, regAddrB);\n\n  /* Generate a subroutine that outputs the current row of the A\n  ** select as the next output row of the compound select.\n  */\n  VdbeNoopComment((v, \"Output routine for A\"));\n  addrOutA = generateOutputSubroutine(pParse,\n                 p, &destA, pDest, regOutA,\n                 regPrev, pKeyDup, labelEnd);\n  \n  /* Generate a subroutine that outputs the current row of the B\n  ** select as the next output row of the compound select.\n  */\n  if( op==TK_ALL || op==TK_UNION ){\n    VdbeNoopComment((v, \"Output routine for B\"));\n    addrOutB = generateOutputSubroutine(pParse,\n                 p, &destB, pDest, regOutB,\n                 regPrev, pKeyDup, labelEnd);\n  }\n  sqlite3KeyInfoUnref(pKeyDup);\n\n  /* Generate a subroutine to run when the results from select A\n  ** are exhausted and only data in select B remains.\n  */\n  if( op==TK_EXCEPT || op==TK_INTERSECT ){\n    addrEofA_noB = addrEofA = labelEnd;\n  }else{  \n    VdbeNoopComment((v, \"eof-A subroutine\"));\n    addrEofA = sqlite3VdbeAddOp2(v, OP_Gosub, regOutB, addrOutB);\n    addrEofA_noB = sqlite3VdbeAddOp2(v, OP_Yield, regAddrB, labelEnd);\n                                     VdbeCoverage(v);\n    sqlite3VdbeGoto(v, addrEofA);\n    p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);\n  }\n\n  /* Generate a subroutine to run when the results from select B\n  ** are exhausted and only data in select A remains.\n  */\n  if( op==TK_INTERSECT ){\n    addrEofB = addrEofA;\n    if( p->nSelectRow > pPrior->nSelectRow ) p->nSelectRow = pPrior->nSelectRow;\n  }else{  \n    VdbeNoopComment((v, \"eof-B subroutine\"));\n    addrEofB = sqlite3VdbeAddOp2(v, OP_Gosub, regOutA, addrOutA);\n    sqlite3VdbeAddOp2(v, OP_Yield, regAddrA, labelEnd); VdbeCoverage(v);\n    sqlite3VdbeGoto(v, addrEofB);\n  }\n\n  /* Generate code to handle the case of A<B\n  */\n  VdbeNoopComment((v, \"A-lt-B subroutine\"));\n  addrAltB = sqlite3VdbeAddOp2(v, OP_Gosub, regOutA, addrOutA);\n  sqlite3VdbeAddOp2(v, OP_Yield, regAddrA, addrEofA); VdbeCoverage(v);\n  sqlite3VdbeGoto(v, labelCmpr);\n\n  /* Generate code to handle the case of A==B\n  */\n  if( op==TK_ALL ){\n    addrAeqB = addrAltB;\n  }else if( op==TK_INTERSECT ){\n    addrAeqB = addrAltB;\n    addrAltB++;\n  }else{\n    VdbeNoopComment((v, \"A-eq-B subroutine\"));\n    addrAeqB =\n    sqlite3VdbeAddOp2(v, OP_Yield, regAddrA, addrEofA); VdbeCoverage(v);\n    sqlite3VdbeGoto(v, labelCmpr);\n  }\n\n  /* Generate code to handle the case of A>B\n  */\n  VdbeNoopComment((v, \"A-gt-B subroutine\"));\n  addrAgtB = sqlite3VdbeCurrentAddr(v);\n  if( op==TK_ALL || op==TK_UNION ){\n    sqlite3VdbeAddOp2(v, OP_Gosub, regOutB, addrOutB);\n  }\n  sqlite3VdbeAddOp2(v, OP_Yield, regAddrB, addrEofB); VdbeCoverage(v);\n  sqlite3VdbeGoto(v, labelCmpr);\n\n  /* This code runs once to initialize everything.\n  */\n  sqlite3VdbeJumpHere(v, addr1);\n  sqlite3VdbeAddOp2(v, OP_Yield, regAddrA, addrEofA_noB); VdbeCoverage(v);\n  sqlite3VdbeAddOp2(v, OP_Yield, regAddrB, addrEofB); VdbeCoverage(v);\n\n  /* Implement the main merge loop\n  */\n  sqlite3VdbeResolveLabel(v, labelCmpr);\n  sqlite3VdbeAddOp4(v, OP_Permutation, 0, 0, 0, (char*)aPermute, P4_INTARRAY);\n  sqlite3VdbeAddOp4(v, OP_Compare, destA.iSdst, destB.iSdst, nOrderBy,\n                         (char*)pKeyMerge, P4_KEYINFO);\n  sqlite3VdbeChangeP5(v, OPFLAG_PERMUTE);\n  sqlite3VdbeAddOp3(v, OP_Jump, addrAltB, addrAeqB, addrAgtB); VdbeCoverage(v);\n\n  /* Jump to the this point in order to terminate the query.\n  */\n  sqlite3VdbeResolveLabel(v, labelEnd);\n\n  /* Reassembly the compound query so that it will be freed correctly\n  ** by the calling function */\n  if( p->pPrior ){\n    sqlite3SelectDelete(db, p->pPrior);\n  }\n  p->pPrior = pPrior;\n  pPrior->pNext = p;\n\n  /*** TBD:  Insert subroutine calls to close cursors on incomplete\n  **** subqueries ****/\n  ExplainQueryPlanPop(pParse);\n  return pParse->nErr!=0;\n}\n#endif\n\n#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)\n\n/* An instance of the SubstContext object describes an substitution edit\n** to be performed on a parse tree.\n**\n** All references to columns in table iTable are to be replaced by corresponding\n** expressions in pEList.\n*/\ntypedef struct SubstContext {\n  Parse *pParse;            /* The parsing context */\n  int iTable;               /* Replace references to this table */\n  int iNewTable;            /* New table number */\n  int isLeftJoin;           /* Add TK_IF_NULL_ROW opcodes on each replacement */\n  ExprList *pEList;         /* Replacement expressions */\n} SubstContext;\n\n/* Forward Declarations */\nstatic void substExprList(SubstContext*, ExprList*);\nstatic void substSelect(SubstContext*, Select*, int);\n\n/*\n** Scan through the expression pExpr.  Replace every reference to\n** a column in table number iTable with a copy of the iColumn-th\n** entry in pEList.  (But leave references to the ROWID column \n** unchanged.)\n**\n** This routine is part of the flattening procedure.  A subquery\n** whose result set is defined by pEList appears as entry in the\n** FROM clause of a SELECT such that the VDBE cursor assigned to that\n** FORM clause entry is iTable.  This routine makes the necessary \n** changes to pExpr so that it refers directly to the source table\n** of the subquery rather the result set of the subquery.\n*/\nstatic Expr *substExpr(\n  SubstContext *pSubst,  /* Description of the substitution */\n  Expr *pExpr            /* Expr in which substitution occurs */\n){\n  if( pExpr==0 ) return 0;\n  if( ExprHasProperty(pExpr, EP_FromJoin)\n   && pExpr->iRightJoinTable==pSubst->iTable\n  ){\n    pExpr->iRightJoinTable = pSubst->iNewTable;\n  }\n  if( pExpr->op==TK_COLUMN && pExpr->iTable==pSubst->iTable ){\n    if( pExpr->iColumn<0 ){\n      pExpr->op = TK_NULL;\n    }else{\n      Expr *pNew;\n      Expr *pCopy = pSubst->pEList->a[pExpr->iColumn].pExpr;\n      Expr ifNullRow;\n      assert( pSubst->pEList!=0 && pExpr->iColumn<pSubst->pEList->nExpr );\n      assert( pExpr->pRight==0 );\n      if( sqlite3ExprIsVector(pCopy) ){\n        sqlite3VectorErrorMsg(pSubst->pParse, pCopy);\n      }else{\n        sqlite3 *db = pSubst->pParse->db;\n        if( pSubst->isLeftJoin && pCopy->op!=TK_COLUMN ){\n          memset(&ifNullRow, 0, sizeof(ifNullRow));\n          ifNullRow.op = TK_IF_NULL_ROW;\n          ifNullRow.pLeft = pCopy;\n          ifNullRow.iTable = pSubst->iNewTable;\n          pCopy = &ifNullRow;\n        }\n        testcase( ExprHasProperty(pCopy, EP_Subquery) );\n        pNew = sqlite3ExprDup(db, pCopy, 0);\n        if( pNew && pSubst->isLeftJoin ){\n          ExprSetProperty(pNew, EP_CanBeNull);\n        }\n        if( pNew && ExprHasProperty(pExpr,EP_FromJoin) ){\n          pNew->iRightJoinTable = pExpr->iRightJoinTable;\n          ExprSetProperty(pNew, EP_FromJoin);\n        }\n        sqlite3ExprDelete(db, pExpr);\n        pExpr = pNew;\n\n        /* Ensure that the expression now has an implicit collation sequence,\n        ** just as it did when it was a column of a view or sub-query. */\n        if( pExpr ){\n          if( pExpr->op!=TK_COLUMN && pExpr->op!=TK_COLLATE ){\n            CollSeq *pColl = sqlite3ExprCollSeq(pSubst->pParse, pExpr);\n            pExpr = sqlite3ExprAddCollateString(pSubst->pParse, pExpr, \n                (pColl ? pColl->zName : \"BINARY\")\n            );\n          }\n          ExprClearProperty(pExpr, EP_Collate);\n        }\n      }\n    }\n  }else{\n    if( pExpr->op==TK_IF_NULL_ROW && pExpr->iTable==pSubst->iTable ){\n      pExpr->iTable = pSubst->iNewTable;\n    }\n    pExpr->pLeft = substExpr(pSubst, pExpr->pLeft);\n    pExpr->pRight = substExpr(pSubst, pExpr->pRight);\n    if( ExprHasProperty(pExpr, EP_xIsSelect) ){\n      substSelect(pSubst, pExpr->x.pSelect, 1);\n    }else{\n      substExprList(pSubst, pExpr->x.pList);\n    }\n#ifndef SQLITE_OMIT_WINDOWFUNC\n    if( ExprHasProperty(pExpr, EP_WinFunc) ){\n      Window *pWin = pExpr->y.pWin;\n      pWin->pFilter = substExpr(pSubst, pWin->pFilter);\n      substExprList(pSubst, pWin->pPartition);\n      substExprList(pSubst, pWin->pOrderBy);\n    }\n#endif\n  }\n  return pExpr;\n}\nstatic void substExprList(\n  SubstContext *pSubst, /* Description of the substitution */\n  ExprList *pList       /* List to scan and in which to make substitutes */\n){\n  int i;\n  if( pList==0 ) return;\n  for(i=0; i<pList->nExpr; i++){\n    pList->a[i].pExpr = substExpr(pSubst, pList->a[i].pExpr);\n  }\n}\nstatic void substSelect(\n  SubstContext *pSubst, /* Description of the substitution */\n  Select *p,            /* SELECT statement in which to make substitutions */\n  int doPrior           /* Do substitutes on p->pPrior too */\n){\n  SrcList *pSrc;\n  struct SrcList_item *pItem;\n  int i;\n  if( !p ) return;\n  do{\n    substExprList(pSubst, p->pEList);\n    substExprList(pSubst, p->pGroupBy);\n    substExprList(pSubst, p->pOrderBy);\n    p->pHaving = substExpr(pSubst, p->pHaving);\n    p->pWhere = substExpr(pSubst, p->pWhere);\n    pSrc = p->pSrc;\n    assert( pSrc!=0 );\n    for(i=pSrc->nSrc, pItem=pSrc->a; i>0; i--, pItem++){\n      substSelect(pSubst, pItem->pSelect, 1);\n      if( pItem->fg.isTabFunc ){\n        substExprList(pSubst, pItem->u1.pFuncArg);\n      }\n    }\n  }while( doPrior && (p = p->pPrior)!=0 );\n}\n#endif /* !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW) */\n\n#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)\n/*\n** This routine attempts to flatten subqueries as a performance optimization.\n** This routine returns 1 if it makes changes and 0 if no flattening occurs.\n**\n** To understand the concept of flattening, consider the following\n** query:\n**\n**     SELECT a FROM (SELECT x+y AS a FROM t1 WHERE z<100) WHERE a>5\n**\n** The default way of implementing this query is to execute the\n** subquery first and store the results in a temporary table, then\n** run the outer query on that temporary table.  This requires two\n** passes over the data.  Furthermore, because the temporary table\n** has no indices, the WHERE clause on the outer query cannot be\n** optimized.\n**\n** This routine attempts to rewrite queries such as the above into\n** a single flat select, like this:\n**\n**     SELECT x+y AS a FROM t1 WHERE z<100 AND a>5\n**\n** The code generated for this simplification gives the same result\n** but only has to scan the data once.  And because indices might \n** exist on the table t1, a complete scan of the data might be\n** avoided.\n**\n** Flattening is subject to the following constraints:\n**\n**  (**)  We no longer attempt to flatten aggregate subqueries. Was:\n**        The subquery and the outer query cannot both be aggregates.\n**\n**  (**)  We no longer attempt to flatten aggregate subqueries. Was:\n**        (2) If the subquery is an aggregate then\n**        (2a) the outer query must not be a join and\n**        (2b) the outer query must not use subqueries\n**             other than the one FROM-clause subquery that is a candidate\n**             for flattening.  (This is due to ticket [2f7170d73bf9abf80]\n**             from 2015-02-09.)\n**\n**   (3)  If the subquery is the right operand of a LEFT JOIN then\n**        (3a) the subquery may not be a join and\n**        (3b) the FROM clause of the subquery may not contain a virtual\n**             table and\n**        (3c) the outer query may not be an aggregate.\n**        (3d) the outer query may not be DISTINCT.\n**\n**   (4)  The subquery can not be DISTINCT.\n**\n**  (**)  At one point restrictions (4) and (5) defined a subset of DISTINCT\n**        sub-queries that were excluded from this optimization. Restriction \n**        (4) has since been expanded to exclude all DISTINCT subqueries.\n**\n**  (**)  We no longer attempt to flatten aggregate subqueries.  Was:\n**        If the subquery is aggregate, the outer query may not be DISTINCT.\n**\n**   (7)  The subquery must have a FROM clause.  TODO:  For subqueries without\n**        A FROM clause, consider adding a FROM clause with the special\n**        table sqlite_once that consists of a single row containing a\n**        single NULL.\n**\n**   (8)  If the subquery uses LIMIT then the outer query may not be a join.\n**\n**   (9)  If the subquery uses LIMIT then the outer query may not be aggregate.\n**\n**  (**)  Restriction (10) was removed from the code on 2005-02-05 but we\n**        accidently carried the comment forward until 2014-09-15.  Original\n**        constraint: \"If the subquery is aggregate then the outer query \n**        may not use LIMIT.\"\n**\n**  (11)  The subquery and the outer query may not both have ORDER BY clauses.\n**\n**  (**)  Not implemented.  Subsumed into restriction (3).  Was previously\n**        a separate restriction deriving from ticket #350.\n**\n**  (13)  The subquery and outer query may not both use LIMIT.\n**\n**  (14)  The subquery may not use OFFSET.\n**\n**  (15)  If the outer query is part of a compound select, then the\n**        subquery may not use LIMIT.\n**        (See ticket #2339 and ticket [02a8e81d44]).\n**\n**  (16)  If the outer query is aggregate, then the subquery may not\n**        use ORDER BY.  (Ticket #2942)  This used to not matter\n**        until we introduced the group_concat() function.  \n**\n**  (17)  If the subquery is a compound select, then\n**        (17a) all compound operators must be a UNION ALL, and\n**        (17b) no terms within the subquery compound may be aggregate\n**              or DISTINCT, and\n**        (17c) every term within the subquery compound must have a FROM clause\n**        (17d) the outer query may not be\n**              (17d1) aggregate, or\n**              (17d2) DISTINCT, or\n**              (17d3) a join.\n**\n**        The parent and sub-query may contain WHERE clauses. Subject to\n**        rules (11), (13) and (14), they may also contain ORDER BY,\n**        LIMIT and OFFSET clauses.  The subquery cannot use any compound\n**        operator other than UNION ALL because all the other compound\n**        operators have an implied DISTINCT which is disallowed by\n**        restriction (4).\n**\n**        Also, each component of the sub-query must return the same number\n**        of result columns. This is actually a requirement for any compound\n**        SELECT statement, but all the code here does is make sure that no\n**        such (illegal) sub-query is flattened. The caller will detect the\n**        syntax error and return a detailed message.\n**\n**  (18)  If the sub-query is a compound select, then all terms of the\n**        ORDER BY clause of the parent must be simple references to \n**        columns of the sub-query.\n**\n**  (19)  If the subquery uses LIMIT then the outer query may not\n**        have a WHERE clause.\n**\n**  (20)  If the sub-query is a compound select, then it must not use\n**        an ORDER BY clause.  Ticket #3773.  We could relax this constraint\n**        somewhat by saying that the terms of the ORDER BY clause must\n**        appear as unmodified result columns in the outer query.  But we\n**        have other optimizations in mind to deal with that case.\n**\n**  (21)  If the subquery uses LIMIT then the outer query may not be\n**        DISTINCT.  (See ticket [752e1646fc]).\n**\n**  (22)  The subquery may not be a recursive CTE.\n**\n**  (**)  Subsumed into restriction (17d3).  Was: If the outer query is\n**        a recursive CTE, then the sub-query may not be a compound query.\n**        This restriction is because transforming the\n**        parent to a compound query confuses the code that handles\n**        recursive queries in multiSelect().\n**\n**  (**)  We no longer attempt to flatten aggregate subqueries.  Was:\n**        The subquery may not be an aggregate that uses the built-in min() or \n**        or max() functions.  (Without this restriction, a query like:\n**        \"SELECT x FROM (SELECT max(y), x FROM t1)\" would not necessarily\n**        return the value X for which Y was maximal.)\n**\n**  (25)  If either the subquery or the parent query contains a window\n**        function in the select list or ORDER BY clause, flattening\n**        is not attempted.\n**\n**\n** In this routine, the \"p\" parameter is a pointer to the outer query.\n** The subquery is p->pSrc->a[iFrom].  isAgg is true if the outer query\n** uses aggregates.\n**\n** If flattening is not attempted, this routine is a no-op and returns 0.\n** If flattening is attempted this routine returns 1.\n**\n** All of the expression analysis must occur on both the outer query and\n** the subquery before this routine runs.\n*/\nstatic int flattenSubquery(\n  Parse *pParse,       /* Parsing context */\n  Select *p,           /* The parent or outer SELECT statement */\n  int iFrom,           /* Index in p->pSrc->a[] of the inner subquery */\n  int isAgg            /* True if outer SELECT uses aggregate functions */\n){\n  const char *zSavedAuthContext = pParse->zAuthContext;\n  Select *pParent;    /* Current UNION ALL term of the other query */\n  Select *pSub;       /* The inner query or \"subquery\" */\n  Select *pSub1;      /* Pointer to the rightmost select in sub-query */\n  SrcList *pSrc;      /* The FROM clause of the outer query */\n  SrcList *pSubSrc;   /* The FROM clause of the subquery */\n  int iParent;        /* VDBE cursor number of the pSub result set temp table */\n  int iNewParent = -1;/* Replacement table for iParent */\n  int isLeftJoin = 0; /* True if pSub is the right side of a LEFT JOIN */    \n  int i;              /* Loop counter */\n  Expr *pWhere;                    /* The WHERE clause */\n  struct SrcList_item *pSubitem;   /* The subquery */\n  sqlite3 *db = pParse->db;\n\n  /* Check to see if flattening is permitted.  Return 0 if not.\n  */\n  assert( p!=0 );\n  assert( p->pPrior==0 );\n  if( OptimizationDisabled(db, SQLITE_QueryFlattener) ) return 0;\n  pSrc = p->pSrc;\n  assert( pSrc && iFrom>=0 && iFrom<pSrc->nSrc );\n  pSubitem = &pSrc->a[iFrom];\n  iParent = pSubitem->iCursor;\n  pSub = pSubitem->pSelect;\n  assert( pSub!=0 );\n\n#ifndef SQLITE_OMIT_WINDOWFUNC\n  if( p->pWin || pSub->pWin ) return 0;                  /* Restriction (25) */\n#endif\n\n  pSubSrc = pSub->pSrc;\n  assert( pSubSrc );\n  /* Prior to version 3.1.2, when LIMIT and OFFSET had to be simple constants,\n  ** not arbitrary expressions, we allowed some combining of LIMIT and OFFSET\n  ** because they could be computed at compile-time.  But when LIMIT and OFFSET\n  ** became arbitrary expressions, we were forced to add restrictions (13)\n  ** and (14). */\n  if( pSub->pLimit && p->pLimit ) return 0;              /* Restriction (13) */\n  if( pSub->pLimit && pSub->pLimit->pRight ) return 0;   /* Restriction (14) */\n  if( (p->selFlags & SF_Compound)!=0 && pSub->pLimit ){\n    return 0;                                            /* Restriction (15) */\n  }\n  if( pSubSrc->nSrc==0 ) return 0;                       /* Restriction (7)  */\n  if( pSub->selFlags & SF_Distinct ) return 0;           /* Restriction (4)  */\n  if( pSub->pLimit && (pSrc->nSrc>1 || isAgg) ){\n     return 0;         /* Restrictions (8)(9) */\n  }\n  if( p->pOrderBy && pSub->pOrderBy ){\n     return 0;                                           /* Restriction (11) */\n  }\n  if( isAgg && pSub->pOrderBy ) return 0;                /* Restriction (16) */\n  if( pSub->pLimit && p->pWhere ) return 0;              /* Restriction (19) */\n  if( pSub->pLimit && (p->selFlags & SF_Distinct)!=0 ){\n     return 0;         /* Restriction (21) */\n  }\n  if( pSub->selFlags & (SF_Recursive) ){\n    return 0; /* Restrictions (22) */\n  }\n\n  /*\n  ** If the subquery is the right operand of a LEFT JOIN, then the\n  ** subquery may not be a join itself (3a). Example of why this is not\n  ** allowed:\n  **\n  **         t1 LEFT OUTER JOIN (t2 JOIN t3)\n  **\n  ** If we flatten the above, we would get\n  **\n  **         (t1 LEFT OUTER JOIN t2) JOIN t3\n  **\n  ** which is not at all the same thing.\n  **\n  ** If the subquery is the right operand of a LEFT JOIN, then the outer\n  ** query cannot be an aggregate. (3c)  This is an artifact of the way\n  ** aggregates are processed - there is no mechanism to determine if\n  ** the LEFT JOIN table should be all-NULL.\n  **\n  ** See also tickets #306, #350, and #3300.\n  */\n  if( (pSubitem->fg.jointype & JT_OUTER)!=0 ){\n    isLeftJoin = 1;\n    if( pSubSrc->nSrc>1                   /* (3a) */\n     || isAgg                             /* (3b) */\n     || IsVirtual(pSubSrc->a[0].pTab)     /* (3c) */\n     || (p->selFlags & SF_Distinct)!=0    /* (3d) */\n    ){\n      return 0;\n    }\n  }\n#ifdef SQLITE_EXTRA_IFNULLROW\n  else if( iFrom>0 && !isAgg ){\n    /* Setting isLeftJoin to -1 causes OP_IfNullRow opcodes to be generated for\n    ** every reference to any result column from subquery in a join, even\n    ** though they are not necessary.  This will stress-test the OP_IfNullRow \n    ** opcode. */\n    isLeftJoin = -1;\n  }\n#endif\n\n  /* Restriction (17): If the sub-query is a compound SELECT, then it must\n  ** use only the UNION ALL operator. And none of the simple select queries\n  ** that make up the compound SELECT are allowed to be aggregate or distinct\n  ** queries.\n  */\n  if( pSub->pPrior ){\n    if( pSub->pOrderBy ){\n      return 0;  /* Restriction (20) */\n    }\n    if( isAgg || (p->selFlags & SF_Distinct)!=0 || pSrc->nSrc!=1 ){\n      return 0; /* (17d1), (17d2), or (17d3) */\n    }\n    for(pSub1=pSub; pSub1; pSub1=pSub1->pPrior){\n      testcase( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))==SF_Distinct );\n      testcase( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))==SF_Aggregate );\n      assert( pSub->pSrc!=0 );\n      assert( pSub->pEList->nExpr==pSub1->pEList->nExpr );\n      if( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))!=0    /* (17b) */\n       || (pSub1->pPrior && pSub1->op!=TK_ALL)                 /* (17a) */\n       || pSub1->pSrc->nSrc<1                                  /* (17c) */\n      ){\n        return 0;\n      }\n      testcase( pSub1->pSrc->nSrc>1 );\n    }\n\n    /* Restriction (18). */\n    if( p->pOrderBy ){\n      int ii;\n      for(ii=0; ii<p->pOrderBy->nExpr; ii++){\n        if( p->pOrderBy->a[ii].u.x.iOrderByCol==0 ) return 0;\n      }\n    }\n  }\n\n  /* Ex-restriction (23):\n  ** The only way that the recursive part of a CTE can contain a compound\n  ** subquery is for the subquery to be one term of a join.  But if the\n  ** subquery is a join, then the flattening has already been stopped by\n  ** restriction (17d3)\n  */\n  assert( (p->selFlags & SF_Recursive)==0 || pSub->pPrior==0 );\n\n  /***** If we reach this point, flattening is permitted. *****/\n  SELECTTRACE(1,pParse,p,(\"flatten %u.%p from term %d\\n\",\n                   pSub->selId, pSub, iFrom));\n\n  /* Authorize the subquery */\n  pParse->zAuthContext = pSubitem->zName;\n  TESTONLY(i =) sqlite3AuthCheck(pParse, SQLITE_SELECT, 0, 0, 0);\n  testcase( i==SQLITE_DENY );\n  pParse->zAuthContext = zSavedAuthContext;\n\n  /* If the sub-query is a compound SELECT statement, then (by restrictions\n  ** 17 and 18 above) it must be a UNION ALL and the parent query must \n  ** be of the form:\n  **\n  **     SELECT <expr-list> FROM (<sub-query>) <where-clause> \n  **\n  ** followed by any ORDER BY, LIMIT and/or OFFSET clauses. This block\n  ** creates N-1 copies of the parent query without any ORDER BY, LIMIT or \n  ** OFFSET clauses and joins them to the left-hand-side of the original\n  ** using UNION ALL operators. In this case N is the number of simple\n  ** select statements in the compound sub-query.\n  **\n  ** Example:\n  **\n  **     SELECT a+1 FROM (\n  **        SELECT x FROM tab\n  **        UNION ALL\n  **        SELECT y FROM tab\n  **        UNION ALL\n  **        SELECT abs(z*2) FROM tab2\n  **     ) WHERE a!=5 ORDER BY 1\n  **\n  ** Transformed into:\n  **\n  **     SELECT x+1 FROM tab WHERE x+1!=5\n  **     UNION ALL\n  **     SELECT y+1 FROM tab WHERE y+1!=5\n  **     UNION ALL\n  **     SELECT abs(z*2)+1 FROM tab2 WHERE abs(z*2)+1!=5\n  **     ORDER BY 1\n  **\n  ** We call this the \"compound-subquery flattening\".\n  */\n  for(pSub=pSub->pPrior; pSub; pSub=pSub->pPrior){\n    Select *pNew;\n    ExprList *pOrderBy = p->pOrderBy;\n    Expr *pLimit = p->pLimit;\n    Select *pPrior = p->pPrior;\n    p->pOrderBy = 0;\n    p->pSrc = 0;\n    p->pPrior = 0;\n    p->pLimit = 0;\n    pNew = sqlite3SelectDup(db, p, 0);\n    p->pLimit = pLimit;\n    p->pOrderBy = pOrderBy;\n    p->pSrc = pSrc;\n    p->op = TK_ALL;\n    if( pNew==0 ){\n      p->pPrior = pPrior;\n    }else{\n      pNew->pPrior = pPrior;\n      if( pPrior ) pPrior->pNext = pNew;\n      pNew->pNext = p;\n      p->pPrior = pNew;\n      SELECTTRACE(2,pParse,p,(\"compound-subquery flattener\"\n                              \" creates %u as peer\\n\",pNew->selId));\n    }\n    if( db->mallocFailed ) return 1;\n  }\n\n  /* Begin flattening the iFrom-th entry of the FROM clause \n  ** in the outer query.\n  */\n  pSub = pSub1 = pSubitem->pSelect;\n\n  /* Delete the transient table structure associated with the\n  ** subquery\n  */\n  sqlite3DbFree(db, pSubitem->zDatabase);\n  sqlite3DbFree(db, pSubitem->zName);\n  sqlite3DbFree(db, pSubitem->zAlias);\n  pSubitem->zDatabase = 0;\n  pSubitem->zName = 0;\n  pSubitem->zAlias = 0;\n  pSubitem->pSelect = 0;\n\n  /* Defer deleting the Table object associated with the\n  ** subquery until code generation is\n  ** complete, since there may still exist Expr.pTab entries that\n  ** refer to the subquery even after flattening.  Ticket #3346.\n  **\n  ** pSubitem->pTab is always non-NULL by test restrictions and tests above.\n  */\n  if( ALWAYS(pSubitem->pTab!=0) ){\n    Table *pTabToDel = pSubitem->pTab;\n    if( pTabToDel->nTabRef==1 ){\n      Parse *pToplevel = sqlite3ParseToplevel(pParse);\n      pTabToDel->pNextZombie = pToplevel->pZombieTab;\n      pToplevel->pZombieTab = pTabToDel;\n    }else{\n      pTabToDel->nTabRef--;\n    }\n    pSubitem->pTab = 0;\n  }\n\n  /* The following loop runs once for each term in a compound-subquery\n  ** flattening (as described above).  If we are doing a different kind\n  ** of flattening - a flattening other than a compound-subquery flattening -\n  ** then this loop only runs once.\n  **\n  ** This loop moves all of the FROM elements of the subquery into the\n  ** the FROM clause of the outer query.  Before doing this, remember\n  ** the cursor number for the original outer query FROM element in\n  ** iParent.  The iParent cursor will never be used.  Subsequent code\n  ** will scan expressions looking for iParent references and replace\n  ** those references with expressions that resolve to the subquery FROM\n  ** elements we are now copying in.\n  */\n  for(pParent=p; pParent; pParent=pParent->pPrior, pSub=pSub->pPrior){\n    int nSubSrc;\n    u8 jointype = 0;\n    assert( pSub!=0 );\n    pSubSrc = pSub->pSrc;     /* FROM clause of subquery */\n    nSubSrc = pSubSrc->nSrc;  /* Number of terms in subquery FROM clause */\n    pSrc = pParent->pSrc;     /* FROM clause of the outer query */\n\n    if( pSrc ){\n      assert( pParent==p );  /* First time through the loop */\n      jointype = pSubitem->fg.jointype;\n    }else{\n      assert( pParent!=p );  /* 2nd and subsequent times through the loop */\n      pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);\n      if( pSrc==0 ) break;\n      pParent->pSrc = pSrc;\n    }\n\n    /* The subquery uses a single slot of the FROM clause of the outer\n    ** query.  If the subquery has more than one element in its FROM clause,\n    ** then expand the outer query to make space for it to hold all elements\n    ** of the subquery.\n    **\n    ** Example:\n    **\n    **    SELECT * FROM tabA, (SELECT * FROM sub1, sub2), tabB;\n    **\n    ** The outer query has 3 slots in its FROM clause.  One slot of the\n    ** outer query (the middle slot) is used by the subquery.  The next\n    ** block of code will expand the outer query FROM clause to 4 slots.\n    ** The middle slot is expanded to two slots in order to make space\n    ** for the two elements in the FROM clause of the subquery.\n    */\n    if( nSubSrc>1 ){\n      pSrc = sqlite3SrcListEnlarge(pParse, pSrc, nSubSrc-1,iFrom+1);\n      if( pSrc==0 ) break;\n      pParent->pSrc = pSrc;\n    }\n\n    /* Transfer the FROM clause terms from the subquery into the\n    ** outer query.\n    */\n    for(i=0; i<nSubSrc; i++){\n      sqlite3IdListDelete(db, pSrc->a[i+iFrom].pUsing);\n      assert( pSrc->a[i+iFrom].fg.isTabFunc==0 );\n      pSrc->a[i+iFrom] = pSubSrc->a[i];\n      iNewParent = pSubSrc->a[i].iCursor;\n      memset(&pSubSrc->a[i], 0, sizeof(pSubSrc->a[i]));\n    }\n    pSrc->a[iFrom].fg.jointype = jointype;\n  \n    /* Now begin substituting subquery result set expressions for \n    ** references to the iParent in the outer query.\n    ** \n    ** Example:\n    **\n    **   SELECT a+5, b*10 FROM (SELECT x*3 AS a, y+10 AS b FROM t1) WHERE a>b;\n    **   \\                     \\_____________ subquery __________/          /\n    **    \\_____________________ outer query ______________________________/\n    **\n    ** We look at every expression in the outer query and every place we see\n    ** \"a\" we substitute \"x*3\" and every place we see \"b\" we substitute \"y+10\".\n    */\n    if( pSub->pOrderBy ){\n      /* At this point, any non-zero iOrderByCol values indicate that the\n      ** ORDER BY column expression is identical to the iOrderByCol'th\n      ** expression returned by SELECT statement pSub. Since these values\n      ** do not necessarily correspond to columns in SELECT statement pParent,\n      ** zero them before transfering the ORDER BY clause.\n      **\n      ** Not doing this may cause an error if a subsequent call to this\n      ** function attempts to flatten a compound sub-query into pParent\n      ** (the only way this can happen is if the compound sub-query is\n      ** currently part of pSub->pSrc). See ticket [d11a6e908f].  */\n      ExprList *pOrderBy = pSub->pOrderBy;\n      for(i=0; i<pOrderBy->nExpr; i++){\n        pOrderBy->a[i].u.x.iOrderByCol = 0;\n      }\n      assert( pParent->pOrderBy==0 );\n      pParent->pOrderBy = pOrderBy;\n      pSub->pOrderBy = 0;\n    }\n    pWhere = pSub->pWhere;\n    pSub->pWhere = 0;\n    if( isLeftJoin>0 ){\n      sqlite3SetJoinExpr(pWhere, iNewParent);\n    }\n    pParent->pWhere = sqlite3ExprAnd(pParse, pWhere, pParent->pWhere);\n    if( db->mallocFailed==0 ){\n      SubstContext x;\n      x.pParse = pParse;\n      x.iTable = iParent;\n      x.iNewTable = iNewParent;\n      x.isLeftJoin = isLeftJoin;\n      x.pEList = pSub->pEList;\n      substSelect(&x, pParent, 0);\n    }\n  \n    /* The flattened query is a compound if either the inner or the\n    ** outer query is a compound. */\n    pParent->selFlags |= pSub->selFlags & SF_Compound;\n    assert( (pSub->selFlags & SF_Distinct)==0 ); /* restriction (17b) */\n  \n    /*\n    ** SELECT ... FROM (SELECT ... LIMIT a OFFSET b) LIMIT x OFFSET y;\n    **\n    ** One is tempted to try to add a and b to combine the limits.  But this\n    ** does not work if either limit is negative.\n    */\n    if( pSub->pLimit ){\n      pParent->pLimit = pSub->pLimit;\n      pSub->pLimit = 0;\n    }\n  }\n\n  /* Finially, delete what is left of the subquery and return\n  ** success.\n  */\n  sqlite3SelectDelete(db, pSub1);\n\n#if SELECTTRACE_ENABLED\n  if( sqlite3SelectTrace & 0x100 ){\n    SELECTTRACE(0x100,pParse,p,(\"After flattening:\\n\"));\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n\n  return 1;\n}\n#endif /* !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW) */\n\n/*\n** A structure to keep track of all of the column values that are fixed to\n** a known value due to WHERE clause constraints of the form COLUMN=VALUE.\n*/\ntypedef struct WhereConst WhereConst;\nstruct WhereConst {\n  Parse *pParse;   /* Parsing context */\n  int nConst;      /* Number for COLUMN=CONSTANT terms */\n  int nChng;       /* Number of times a constant is propagated */\n  Expr **apExpr;   /* [i*2] is COLUMN and [i*2+1] is VALUE */\n};\n\n/*\n** Add a new entry to the pConst object.  Except, do not add duplicate\n** pColumn entires.\n*/\nstatic void constInsert(\n  WhereConst *pConst,      /* The WhereConst into which we are inserting */\n  Expr *pColumn,           /* The COLUMN part of the constraint */\n  Expr *pValue             /* The VALUE part of the constraint */\n){\n  int i;\n  assert( pColumn->op==TK_COLUMN );\n\n  /* 2018-10-25 ticket [cf5ed20f]\n  ** Make sure the same pColumn is not inserted more than once */\n  for(i=0; i<pConst->nConst; i++){\n    const Expr *pExpr = pConst->apExpr[i*2];\n    assert( pExpr->op==TK_COLUMN );\n    if( pExpr->iTable==pColumn->iTable\n     && pExpr->iColumn==pColumn->iColumn\n    ){\n      return;  /* Already present.  Return without doing anything. */\n    }\n  }\n\n  pConst->nConst++;\n  pConst->apExpr = sqlite3DbReallocOrFree(pConst->pParse->db, pConst->apExpr,\n                         pConst->nConst*2*sizeof(Expr*));\n  if( pConst->apExpr==0 ){\n    pConst->nConst = 0;\n  }else{\n    if( ExprHasProperty(pValue, EP_FixedCol) ) pValue = pValue->pLeft;\n    pConst->apExpr[pConst->nConst*2-2] = pColumn;\n    pConst->apExpr[pConst->nConst*2-1] = pValue;\n  }\n}\n\n/*\n** Find all terms of COLUMN=VALUE or VALUE=COLUMN in pExpr where VALUE\n** is a constant expression and where the term must be true because it\n** is part of the AND-connected terms of the expression.  For each term\n** found, add it to the pConst structure.\n*/\nstatic void findConstInWhere(WhereConst *pConst, Expr *pExpr){\n  Expr *pRight, *pLeft;\n  if( pExpr==0 ) return;\n  if( ExprHasProperty(pExpr, EP_FromJoin) ) return;\n  if( pExpr->op==TK_AND ){\n    findConstInWhere(pConst, pExpr->pRight);\n    findConstInWhere(pConst, pExpr->pLeft);\n    return;\n  }\n  if( pExpr->op!=TK_EQ ) return;\n  pRight = pExpr->pRight;\n  pLeft = pExpr->pLeft;\n  assert( pRight!=0 );\n  assert( pLeft!=0 );\n  if( pRight->op==TK_COLUMN\n   && !ExprHasProperty(pRight, EP_FixedCol)\n   && sqlite3ExprIsConstant(pLeft)\n   && sqlite3IsBinary(sqlite3ExprCompareCollSeq(pConst->pParse,pExpr))\n  ){\n    constInsert(pConst, pRight, pLeft);\n  }else\n  if( pLeft->op==TK_COLUMN\n   && !ExprHasProperty(pLeft, EP_FixedCol)\n   && sqlite3ExprIsConstant(pRight)\n   && sqlite3IsBinary(sqlite3ExprCompareCollSeq(pConst->pParse,pExpr))\n  ){\n    constInsert(pConst, pLeft, pRight);\n  }\n}\n\n/*\n** This is a Walker expression callback.  pExpr is a candidate expression\n** to be replaced by a value.  If pExpr is equivalent to one of the\n** columns named in pWalker->u.pConst, then overwrite it with its\n** corresponding value.\n*/\nstatic int propagateConstantExprRewrite(Walker *pWalker, Expr *pExpr){\n  int i;\n  WhereConst *pConst;\n  if( pExpr->op!=TK_COLUMN ) return WRC_Continue;\n  if( ExprHasProperty(pExpr, EP_FixedCol) ) return WRC_Continue;\n  pConst = pWalker->u.pConst;\n  for(i=0; i<pConst->nConst; i++){\n    Expr *pColumn = pConst->apExpr[i*2];\n    if( pColumn==pExpr ) continue;\n    if( pColumn->iTable!=pExpr->iTable ) continue;\n    if( pColumn->iColumn!=pExpr->iColumn ) continue;\n    /* A match is found.  Add the EP_FixedCol property */\n    pConst->nChng++;\n    ExprClearProperty(pExpr, EP_Leaf);\n    ExprSetProperty(pExpr, EP_FixedCol);\n    assert( pExpr->pLeft==0 );\n    pExpr->pLeft = sqlite3ExprDup(pConst->pParse->db, pConst->apExpr[i*2+1], 0);\n    break;\n  }\n  return WRC_Prune;\n}\n\n/*\n** The WHERE-clause constant propagation optimization.\n**\n** If the WHERE clause contains terms of the form COLUMN=CONSTANT or\n** CONSTANT=COLUMN that must be tree (in other words, if the terms top-level\n** AND-connected terms that are not part of a ON clause from a LEFT JOIN)\n** then throughout the query replace all other occurrences of COLUMN\n** with CONSTANT within the WHERE clause.\n**\n** For example, the query:\n**\n**      SELECT * FROM t1, t2, t3 WHERE t1.a=39 AND t2.b=t1.a AND t3.c=t2.b\n**\n** Is transformed into\n**\n**      SELECT * FROM t1, t2, t3 WHERE t1.a=39 AND t2.b=39 AND t3.c=39\n**\n** Return true if any transformations where made and false if not.\n**\n** Implementation note:  Constant propagation is tricky due to affinity\n** and collating sequence interactions.  Consider this example:\n**\n**    CREATE TABLE t1(a INT,b TEXT);\n**    INSERT INTO t1 VALUES(123,'0123');\n**    SELECT * FROM t1 WHERE a=123 AND b=a;\n**    SELECT * FROM t1 WHERE a=123 AND b=123;\n**\n** The two SELECT statements above should return different answers.  b=a\n** is alway true because the comparison uses numeric affinity, but b=123\n** is false because it uses text affinity and '0123' is not the same as '123'.\n** To work around this, the expression tree is not actually changed from\n** \"b=a\" to \"b=123\" but rather the \"a\" in \"b=a\" is tagged with EP_FixedCol\n** and the \"123\" value is hung off of the pLeft pointer.  Code generator\n** routines know to generate the constant \"123\" instead of looking up the\n** column value.  Also, to avoid collation problems, this optimization is\n** only attempted if the \"a=123\" term uses the default BINARY collation.\n*/\nstatic int propagateConstants(\n  Parse *pParse,   /* The parsing context */\n  Select *p        /* The query in which to propagate constants */\n){\n  WhereConst x;\n  Walker w;\n  int nChng = 0;\n  x.pParse = pParse;\n  do{\n    x.nConst = 0;\n    x.nChng = 0;\n    x.apExpr = 0;\n    findConstInWhere(&x, p->pWhere);\n    if( x.nConst ){\n      memset(&w, 0, sizeof(w));\n      w.pParse = pParse;\n      w.xExprCallback = propagateConstantExprRewrite;\n      w.xSelectCallback = sqlite3SelectWalkNoop;\n      w.xSelectCallback2 = 0;\n      w.walkerDepth = 0;\n      w.u.pConst = &x;\n      sqlite3WalkExpr(&w, p->pWhere);\n      sqlite3DbFree(x.pParse->db, x.apExpr);\n      nChng += x.nChng;\n    }\n  }while( x.nChng );  \n  return nChng;\n}\n\n#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)\n/*\n** Make copies of relevant WHERE clause terms of the outer query into\n** the WHERE clause of subquery.  Example:\n**\n**    SELECT * FROM (SELECT a AS x, c-d AS y FROM t1) WHERE x=5 AND y=10;\n**\n** Transformed into:\n**\n**    SELECT * FROM (SELECT a AS x, c-d AS y FROM t1 WHERE a=5 AND c-d=10)\n**     WHERE x=5 AND y=10;\n**\n** The hope is that the terms added to the inner query will make it more\n** efficient.\n**\n** Do not attempt this optimization if:\n**\n**   (1) (** This restriction was removed on 2017-09-29.  We used to\n**           disallow this optimization for aggregate subqueries, but now\n**           it is allowed by putting the extra terms on the HAVING clause.\n**           The added HAVING clause is pointless if the subquery lacks\n**           a GROUP BY clause.  But such a HAVING clause is also harmless\n**           so there does not appear to be any reason to add extra logic\n**           to suppress it. **)\n**\n**   (2) The inner query is the recursive part of a common table expression.\n**\n**   (3) The inner query has a LIMIT clause (since the changes to the WHERE\n**       clause would change the meaning of the LIMIT).\n**\n**   (4) The inner query is the right operand of a LEFT JOIN and the\n**       expression to be pushed down does not come from the ON clause\n**       on that LEFT JOIN.\n**\n**   (5) The WHERE clause expression originates in the ON or USING clause\n**       of a LEFT JOIN where iCursor is not the right-hand table of that\n**       left join.  An example:\n**\n**           SELECT *\n**           FROM (SELECT 1 AS a1 UNION ALL SELECT 2) AS aa\n**           JOIN (SELECT 1 AS b2 UNION ALL SELECT 2) AS bb ON (a1=b2)\n**           LEFT JOIN (SELECT 8 AS c3 UNION ALL SELECT 9) AS cc ON (b2=2);\n**\n**       The correct answer is three rows:  (1,1,NULL),(2,2,8),(2,2,9).\n**       But if the (b2=2) term were to be pushed down into the bb subquery,\n**       then the (1,1,NULL) row would be suppressed.\n**\n**   (6) The inner query features one or more window-functions (since \n**       changes to the WHERE clause of the inner query could change the \n**       window over which window functions are calculated).\n**\n** Return 0 if no changes are made and non-zero if one or more WHERE clause\n** terms are duplicated into the subquery.\n*/\nstatic int pushDownWhereTerms(\n  Parse *pParse,        /* Parse context (for malloc() and error reporting) */\n  Select *pSubq,        /* The subquery whose WHERE clause is to be augmented */\n  Expr *pWhere,         /* The WHERE clause of the outer query */\n  int iCursor,          /* Cursor number of the subquery */\n  int isLeftJoin        /* True if pSubq is the right term of a LEFT JOIN */\n){\n  Expr *pNew;\n  int nChng = 0;\n  if( pWhere==0 ) return 0;\n  if( pSubq->selFlags & SF_Recursive ) return 0;  /* restriction (2) */\n\n#ifndef SQLITE_OMIT_WINDOWFUNC\n  if( pSubq->pWin ) return 0;    /* restriction (6) */\n#endif\n\n#ifdef SQLITE_DEBUG\n  /* Only the first term of a compound can have a WITH clause.  But make\n  ** sure no other terms are marked SF_Recursive in case something changes\n  ** in the future.\n  */\n  {\n    Select *pX;  \n    for(pX=pSubq; pX; pX=pX->pPrior){\n      assert( (pX->selFlags & (SF_Recursive))==0 );\n    }\n  }\n#endif\n\n  if( pSubq->pLimit!=0 ){\n    return 0; /* restriction (3) */\n  }\n  while( pWhere->op==TK_AND ){\n    nChng += pushDownWhereTerms(pParse, pSubq, pWhere->pRight,\n                                iCursor, isLeftJoin);\n    pWhere = pWhere->pLeft;\n  }\n  if( isLeftJoin\n   && (ExprHasProperty(pWhere,EP_FromJoin)==0\n         || pWhere->iRightJoinTable!=iCursor)\n  ){\n    return 0; /* restriction (4) */\n  }\n  if( ExprHasProperty(pWhere,EP_FromJoin) && pWhere->iRightJoinTable!=iCursor ){\n    return 0; /* restriction (5) */\n  }\n  if( sqlite3ExprIsTableConstant(pWhere, iCursor) ){\n    nChng++;\n    while( pSubq ){\n      SubstContext x;\n      pNew = sqlite3ExprDup(pParse->db, pWhere, 0);\n      unsetJoinExpr(pNew, -1);\n      x.pParse = pParse;\n      x.iTable = iCursor;\n      x.iNewTable = iCursor;\n      x.isLeftJoin = 0;\n      x.pEList = pSubq->pEList;\n      pNew = substExpr(&x, pNew);\n      if( pSubq->selFlags & SF_Aggregate ){\n        pSubq->pHaving = sqlite3ExprAnd(pParse, pSubq->pHaving, pNew);\n      }else{\n        pSubq->pWhere = sqlite3ExprAnd(pParse, pSubq->pWhere, pNew);\n      }\n      pSubq = pSubq->pPrior;\n    }\n  }\n  return nChng;\n}\n#endif /* !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW) */\n\n/*\n** The pFunc is the only aggregate function in the query.  Check to see\n** if the query is a candidate for the min/max optimization. \n**\n** If the query is a candidate for the min/max optimization, then set\n** *ppMinMax to be an ORDER BY clause to be used for the optimization\n** and return either WHERE_ORDERBY_MIN or WHERE_ORDERBY_MAX depending on\n** whether pFunc is a min() or max() function.\n**\n** If the query is not a candidate for the min/max optimization, return\n** WHERE_ORDERBY_NORMAL (which must be zero).\n**\n** This routine must be called after aggregate functions have been\n** located but before their arguments have been subjected to aggregate\n** analysis.\n*/\nstatic u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax){\n  int eRet = WHERE_ORDERBY_NORMAL;      /* Return value */\n  ExprList *pEList = pFunc->x.pList;    /* Arguments to agg function */\n  const char *zFunc;                    /* Name of aggregate function pFunc */\n  ExprList *pOrderBy;\n  u8 sortFlags;\n\n  assert( *ppMinMax==0 );\n  assert( pFunc->op==TK_AGG_FUNCTION );\n  assert( !IsWindowFunc(pFunc) );\n  if( pEList==0 || pEList->nExpr!=1 || ExprHasProperty(pFunc, EP_WinFunc) ){\n    return eRet;\n  }\n  zFunc = pFunc->u.zToken;\n  if( sqlite3StrICmp(zFunc, \"min\")==0 ){\n    eRet = WHERE_ORDERBY_MIN;\n    sortFlags = KEYINFO_ORDER_BIGNULL;\n  }else if( sqlite3StrICmp(zFunc, \"max\")==0 ){\n    eRet = WHERE_ORDERBY_MAX;\n    sortFlags = KEYINFO_ORDER_DESC;\n  }else{\n    return eRet;\n  }\n  *ppMinMax = pOrderBy = sqlite3ExprListDup(db, pEList, 0);\n  assert( pOrderBy!=0 || db->mallocFailed );\n  if( pOrderBy ) pOrderBy->a[0].sortFlags = sortFlags;\n  return eRet;\n}\n\n/*\n** The select statement passed as the first argument is an aggregate query.\n** The second argument is the associated aggregate-info object. This \n** function tests if the SELECT is of the form:\n**\n**   SELECT count(*) FROM <tbl>\n**\n** where table is a database table, not a sub-select or view. If the query\n** does match this pattern, then a pointer to the Table object representing\n** <tbl> is returned. Otherwise, 0 is returned.\n*/\nstatic Table *isSimpleCount(Select *p, AggInfo *pAggInfo){\n  Table *pTab;\n  Expr *pExpr;\n\n  assert( !p->pGroupBy );\n\n  if( p->pWhere || p->pEList->nExpr!=1 \n   || p->pSrc->nSrc!=1 || p->pSrc->a[0].pSelect\n  ){\n    return 0;\n  }\n  pTab = p->pSrc->a[0].pTab;\n  pExpr = p->pEList->a[0].pExpr;\n  assert( pTab && !pTab->pSelect && pExpr );\n\n  if( IsVirtual(pTab) ) return 0;\n  if( pExpr->op!=TK_AGG_FUNCTION ) return 0;\n  if( NEVER(pAggInfo->nFunc==0) ) return 0;\n  if( (pAggInfo->aFunc[0].pFunc->funcFlags&SQLITE_FUNC_COUNT)==0 ) return 0;\n  if( ExprHasProperty(pExpr, EP_Distinct|EP_WinFunc) ) return 0;\n\n  return pTab;\n}\n\n/*\n** If the source-list item passed as an argument was augmented with an\n** INDEXED BY clause, then try to locate the specified index. If there\n** was such a clause and the named index cannot be found, return \n** SQLITE_ERROR and leave an error in pParse. Otherwise, populate \n** pFrom->pIndex and return SQLITE_OK.\n*/\nint sqlite3IndexedByLookup(Parse *pParse, struct SrcList_item *pFrom){\n  if( pFrom->pTab && pFrom->fg.isIndexedBy ){\n    Table *pTab = pFrom->pTab;\n    char *zIndexedBy = pFrom->u1.zIndexedBy;\n    Index *pIdx;\n    for(pIdx=pTab->pIndex; \n        pIdx && sqlite3StrICmp(pIdx->zName, zIndexedBy); \n        pIdx=pIdx->pNext\n    );\n    if( !pIdx ){\n      sqlite3ErrorMsg(pParse, \"no such index: %s\", zIndexedBy, 0);\n      pParse->checkSchema = 1;\n      return SQLITE_ERROR;\n    }\n    pFrom->pIBIndex = pIdx;\n  }\n  return SQLITE_OK;\n}\n/*\n** Detect compound SELECT statements that use an ORDER BY clause with \n** an alternative collating sequence.\n**\n**    SELECT ... FROM t1 EXCEPT SELECT ... FROM t2 ORDER BY .. COLLATE ...\n**\n** These are rewritten as a subquery:\n**\n**    SELECT * FROM (SELECT ... FROM t1 EXCEPT SELECT ... FROM t2)\n**     ORDER BY ... COLLATE ...\n**\n** This transformation is necessary because the multiSelectOrderBy() routine\n** above that generates the code for a compound SELECT with an ORDER BY clause\n** uses a merge algorithm that requires the same collating sequence on the\n** result columns as on the ORDER BY clause.  See ticket\n** http://www.sqlite.org/src/info/6709574d2a\n**\n** This transformation is only needed for EXCEPT, INTERSECT, and UNION.\n** The UNION ALL operator works fine with multiSelectOrderBy() even when\n** there are COLLATE terms in the ORDER BY.\n*/\nstatic int convertCompoundSelectToSubquery(Walker *pWalker, Select *p){\n  int i;\n  Select *pNew;\n  Select *pX;\n  sqlite3 *db;\n  struct ExprList_item *a;\n  SrcList *pNewSrc;\n  Parse *pParse;\n  Token dummy;\n\n  if( p->pPrior==0 ) return WRC_Continue;\n  if( p->pOrderBy==0 ) return WRC_Continue;\n  for(pX=p; pX && (pX->op==TK_ALL || pX->op==TK_SELECT); pX=pX->pPrior){}\n  if( pX==0 ) return WRC_Continue;\n  a = p->pOrderBy->a;\n  for(i=p->pOrderBy->nExpr-1; i>=0; i--){\n    if( a[i].pExpr->flags & EP_Collate ) break;\n  }\n  if( i<0 ) return WRC_Continue;\n\n  /* If we reach this point, that means the transformation is required. */\n\n  pParse = pWalker->pParse;\n  db = pParse->db;\n  pNew = sqlite3DbMallocZero(db, sizeof(*pNew) );\n  if( pNew==0 ) return WRC_Abort;\n  memset(&dummy, 0, sizeof(dummy));\n  pNewSrc = sqlite3SrcListAppendFromTerm(pParse,0,0,0,&dummy,pNew,0,0);\n  if( pNewSrc==0 ) return WRC_Abort;\n  *pNew = *p;\n  p->pSrc = pNewSrc;\n  p->pEList = sqlite3ExprListAppend(pParse, 0, sqlite3Expr(db, TK_ASTERISK, 0));\n  p->op = TK_SELECT;\n  p->pWhere = 0;\n  pNew->pGroupBy = 0;\n  pNew->pHaving = 0;\n  pNew->pOrderBy = 0;\n  p->pPrior = 0;\n  p->pNext = 0;\n  p->pWith = 0;\n#ifndef SQLITE_OMIT_WINDOWFUNC\n  p->pWinDefn = 0;\n#endif\n  p->selFlags &= ~SF_Compound;\n  assert( (p->selFlags & SF_Converted)==0 );\n  p->selFlags |= SF_Converted;\n  assert( pNew->pPrior!=0 );\n  pNew->pPrior->pNext = pNew;\n  pNew->pLimit = 0;\n  return WRC_Continue;\n}\n\n/*\n** Check to see if the FROM clause term pFrom has table-valued function\n** arguments.  If it does, leave an error message in pParse and return\n** non-zero, since pFrom is not allowed to be a table-valued function.\n*/\nstatic int cannotBeFunction(Parse *pParse, struct SrcList_item *pFrom){\n  if( pFrom->fg.isTabFunc ){\n    sqlite3ErrorMsg(pParse, \"'%s' is not a function\", pFrom->zName);\n    return 1;\n  }\n  return 0;\n}\n\n#ifndef SQLITE_OMIT_CTE\n/*\n** Argument pWith (which may be NULL) points to a linked list of nested \n** WITH contexts, from inner to outermost. If the table identified by \n** FROM clause element pItem is really a common-table-expression (CTE) \n** then return a pointer to the CTE definition for that table. Otherwise\n** return NULL.\n**\n** If a non-NULL value is returned, set *ppContext to point to the With\n** object that the returned CTE belongs to.\n*/\nstatic struct Cte *searchWith(\n  With *pWith,                    /* Current innermost WITH clause */\n  struct SrcList_item *pItem,     /* FROM clause element to resolve */\n  With **ppContext                /* OUT: WITH clause return value belongs to */\n){\n  const char *zName;\n  if( pItem->zDatabase==0 && (zName = pItem->zName)!=0 ){\n    With *p;\n    for(p=pWith; p; p=p->pOuter){\n      int i;\n      for(i=0; i<p->nCte; i++){\n        if( sqlite3StrICmp(zName, p->a[i].zName)==0 ){\n          *ppContext = p;\n          return &p->a[i];\n        }\n      }\n    }\n  }\n  return 0;\n}\n\n/* The code generator maintains a stack of active WITH clauses\n** with the inner-most WITH clause being at the top of the stack.\n**\n** This routine pushes the WITH clause passed as the second argument\n** onto the top of the stack. If argument bFree is true, then this\n** WITH clause will never be popped from the stack. In this case it\n** should be freed along with the Parse object. In other cases, when\n** bFree==0, the With object will be freed along with the SELECT \n** statement with which it is associated.\n*/\nvoid sqlite3WithPush(Parse *pParse, With *pWith, u8 bFree){\n  assert( bFree==0 || (pParse->pWith==0 && pParse->pWithToFree==0) );\n  if( pWith ){\n    assert( pParse->pWith!=pWith );\n    pWith->pOuter = pParse->pWith;\n    pParse->pWith = pWith;\n    if( bFree ) pParse->pWithToFree = pWith;\n  }\n}\n\n/*\n** This function checks if argument pFrom refers to a CTE declared by \n** a WITH clause on the stack currently maintained by the parser. And,\n** if currently processing a CTE expression, if it is a recursive\n** reference to the current CTE.\n**\n** If pFrom falls into either of the two categories above, pFrom->pTab\n** and other fields are populated accordingly. The caller should check\n** (pFrom->pTab!=0) to determine whether or not a successful match\n** was found.\n**\n** Whether or not a match is found, SQLITE_OK is returned if no error\n** occurs. If an error does occur, an error message is stored in the\n** parser and some error code other than SQLITE_OK returned.\n*/\nstatic int withExpand(\n  Walker *pWalker, \n  struct SrcList_item *pFrom\n){\n  Parse *pParse = pWalker->pParse;\n  sqlite3 *db = pParse->db;\n  struct Cte *pCte;               /* Matched CTE (or NULL if no match) */\n  With *pWith;                    /* WITH clause that pCte belongs to */\n\n  assert( pFrom->pTab==0 );\n  if( pParse->nErr ){\n    return SQLITE_ERROR;\n  }\n\n  pCte = searchWith(pParse->pWith, pFrom, &pWith);\n  if( pCte ){\n    Table *pTab;\n    ExprList *pEList;\n    Select *pSel;\n    Select *pLeft;                /* Left-most SELECT statement */\n    int bMayRecursive;            /* True if compound joined by UNION [ALL] */\n    With *pSavedWith;             /* Initial value of pParse->pWith */\n\n    /* If pCte->zCteErr is non-NULL at this point, then this is an illegal\n    ** recursive reference to CTE pCte. Leave an error in pParse and return\n    ** early. If pCte->zCteErr is NULL, then this is not a recursive reference.\n    ** In this case, proceed.  */\n    if( pCte->zCteErr ){\n      sqlite3ErrorMsg(pParse, pCte->zCteErr, pCte->zName);\n      return SQLITE_ERROR;\n    }\n    if( cannotBeFunction(pParse, pFrom) ) return SQLITE_ERROR;\n\n    assert( pFrom->pTab==0 );\n    pFrom->pTab = pTab = sqlite3DbMallocZero(db, sizeof(Table));\n    if( pTab==0 ) return WRC_Abort;\n    pTab->nTabRef = 1;\n    pTab->zName = sqlite3DbStrDup(db, pCte->zName);\n    pTab->iPKey = -1;\n    pTab->nRowLogEst = 200; assert( 200==sqlite3LogEst(1048576) );\n    pTab->tabFlags |= TF_Ephemeral | TF_NoVisibleRowid;\n    pFrom->pSelect = sqlite3SelectDup(db, pCte->pSelect, 0);\n    if( db->mallocFailed ) return SQLITE_NOMEM_BKPT;\n    assert( pFrom->pSelect );\n\n    /* Check if this is a recursive CTE. */\n    pSel = pFrom->pSelect;\n    bMayRecursive = ( pSel->op==TK_ALL || pSel->op==TK_UNION );\n    if( bMayRecursive ){\n      int i;\n      SrcList *pSrc = pFrom->pSelect->pSrc;\n      for(i=0; i<pSrc->nSrc; i++){\n        struct SrcList_item *pItem = &pSrc->a[i];\n        if( pItem->zDatabase==0 \n         && pItem->zName!=0 \n         && 0==sqlite3StrICmp(pItem->zName, pCte->zName)\n          ){\n          pItem->pTab = pTab;\n          pItem->fg.isRecursive = 1;\n          pTab->nTabRef++;\n          pSel->selFlags |= SF_Recursive;\n        }\n      }\n    }\n\n    /* Only one recursive reference is permitted. */ \n    if( pTab->nTabRef>2 ){\n      sqlite3ErrorMsg(\n          pParse, \"multiple references to recursive table: %s\", pCte->zName\n      );\n      return SQLITE_ERROR;\n    }\n    assert( pTab->nTabRef==1 || \n            ((pSel->selFlags&SF_Recursive) && pTab->nTabRef==2 ));\n\n    pCte->zCteErr = \"circular reference: %s\";\n    pSavedWith = pParse->pWith;\n    pParse->pWith = pWith;\n    if( bMayRecursive ){\n      Select *pPrior = pSel->pPrior;\n      assert( pPrior->pWith==0 );\n      pPrior->pWith = pSel->pWith;\n      sqlite3WalkSelect(pWalker, pPrior);\n      pPrior->pWith = 0;\n    }else{\n      sqlite3WalkSelect(pWalker, pSel);\n    }\n    pParse->pWith = pWith;\n\n    for(pLeft=pSel; pLeft->pPrior; pLeft=pLeft->pPrior);\n    pEList = pLeft->pEList;\n    if( pCte->pCols ){\n      if( pEList && pEList->nExpr!=pCte->pCols->nExpr ){\n        sqlite3ErrorMsg(pParse, \"table %s has %d values for %d columns\",\n            pCte->zName, pEList->nExpr, pCte->pCols->nExpr\n        );\n        pParse->pWith = pSavedWith;\n        return SQLITE_ERROR;\n      }\n      pEList = pCte->pCols;\n    }\n\n    sqlite3ColumnsFromExprList(pParse, pEList, &pTab->nCol, &pTab->aCol);\n    if( bMayRecursive ){\n      if( pSel->selFlags & SF_Recursive ){\n        pCte->zCteErr = \"multiple recursive references: %s\";\n      }else{\n        pCte->zCteErr = \"recursive reference in a subquery: %s\";\n      }\n      sqlite3WalkSelect(pWalker, pSel);\n    }\n    pCte->zCteErr = 0;\n    pParse->pWith = pSavedWith;\n  }\n\n  return SQLITE_OK;\n}\n#endif\n\n#ifndef SQLITE_OMIT_CTE\n/*\n** If the SELECT passed as the second argument has an associated WITH \n** clause, pop it from the stack stored as part of the Parse object.\n**\n** This function is used as the xSelectCallback2() callback by\n** sqlite3SelectExpand() when walking a SELECT tree to resolve table\n** names and other FROM clause elements. \n*/\nstatic void selectPopWith(Walker *pWalker, Select *p){\n  Parse *pParse = pWalker->pParse;\n  if( OK_IF_ALWAYS_TRUE(pParse->pWith) && p->pPrior==0 ){\n    With *pWith = findRightmost(p)->pWith;\n    if( pWith!=0 ){\n      assert( pParse->pWith==pWith );\n      pParse->pWith = pWith->pOuter;\n    }\n  }\n}\n#else\n#define selectPopWith 0\n#endif\n\n/*\n** The SrcList_item structure passed as the second argument represents a\n** sub-query in the FROM clause of a SELECT statement. This function\n** allocates and populates the SrcList_item.pTab object. If successful,\n** SQLITE_OK is returned. Otherwise, if an OOM error is encountered,\n** SQLITE_NOMEM.\n*/\nint sqlite3ExpandSubquery(Parse *pParse, struct SrcList_item *pFrom){\n  Select *pSel = pFrom->pSelect;\n  Table *pTab;\n\n  assert( pSel );\n  pFrom->pTab = pTab = sqlite3DbMallocZero(pParse->db, sizeof(Table));\n  if( pTab==0 ) return SQLITE_NOMEM;\n  pTab->nTabRef = 1;\n  if( pFrom->zAlias ){\n    pTab->zName = sqlite3DbStrDup(pParse->db, pFrom->zAlias);\n  }else{\n    pTab->zName = sqlite3MPrintf(pParse->db, \"subquery_%u\", pSel->selId);\n  }\n  while( pSel->pPrior ){ pSel = pSel->pPrior; }\n  sqlite3ColumnsFromExprList(pParse, pSel->pEList,&pTab->nCol,&pTab->aCol);\n  pTab->iPKey = -1;\n  pTab->nRowLogEst = 200; assert( 200==sqlite3LogEst(1048576) );\n  pTab->tabFlags |= TF_Ephemeral;\n\n  return pParse->nErr ? SQLITE_ERROR : SQLITE_OK;\n}\n\n/*\n** This routine is a Walker callback for \"expanding\" a SELECT statement.\n** \"Expanding\" means to do the following:\n**\n**    (1)  Make sure VDBE cursor numbers have been assigned to every\n**         element of the FROM clause.\n**\n**    (2)  Fill in the pTabList->a[].pTab fields in the SrcList that \n**         defines FROM clause.  When views appear in the FROM clause,\n**         fill pTabList->a[].pSelect with a copy of the SELECT statement\n**         that implements the view.  A copy is made of the view's SELECT\n**         statement so that we can freely modify or delete that statement\n**         without worrying about messing up the persistent representation\n**         of the view.\n**\n**    (3)  Add terms to the WHERE clause to accommodate the NATURAL keyword\n**         on joins and the ON and USING clause of joins.\n**\n**    (4)  Scan the list of columns in the result set (pEList) looking\n**         for instances of the \"*\" operator or the TABLE.* operator.\n**         If found, expand each \"*\" to be every column in every table\n**         and TABLE.* to be every column in TABLE.\n**\n*/\nstatic int selectExpander(Walker *pWalker, Select *p){\n  Parse *pParse = pWalker->pParse;\n  int i, j, k;\n  SrcList *pTabList;\n  ExprList *pEList;\n  struct SrcList_item *pFrom;\n  sqlite3 *db = pParse->db;\n  Expr *pE, *pRight, *pExpr;\n  u16 selFlags = p->selFlags;\n  u32 elistFlags = 0;\n\n  p->selFlags |= SF_Expanded;\n  if( db->mallocFailed  ){\n    return WRC_Abort;\n  }\n  assert( p->pSrc!=0 );\n  if( (selFlags & SF_Expanded)!=0 ){\n    return WRC_Prune;\n  }\n  if( pWalker->eCode ){\n    /* Renumber selId because it has been copied from a view */\n    p->selId = ++pParse->nSelect;\n  }\n  pTabList = p->pSrc;\n  pEList = p->pEList;\n  sqlite3WithPush(pParse, p->pWith, 0);\n\n  /* Make sure cursor numbers have been assigned to all entries in\n  ** the FROM clause of the SELECT statement.\n  */\n  sqlite3SrcListAssignCursors(pParse, pTabList);\n\n  /* Look up every table named in the FROM clause of the select.  If\n  ** an entry of the FROM clause is a subquery instead of a table or view,\n  ** then create a transient table structure to describe the subquery.\n  */\n  for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){\n    Table *pTab;\n    assert( pFrom->fg.isRecursive==0 || pFrom->pTab!=0 );\n    if( pFrom->fg.isRecursive ) continue;\n    assert( pFrom->pTab==0 );\n#ifndef SQLITE_OMIT_CTE\n    if( withExpand(pWalker, pFrom) ) return WRC_Abort;\n    if( pFrom->pTab ) {} else\n#endif\n    if( pFrom->zName==0 ){\n#ifndef SQLITE_OMIT_SUBQUERY\n      Select *pSel = pFrom->pSelect;\n      /* A sub-query in the FROM clause of a SELECT */\n      assert( pSel!=0 );\n      assert( pFrom->pTab==0 );\n      if( sqlite3WalkSelect(pWalker, pSel) ) return WRC_Abort;\n      if( sqlite3ExpandSubquery(pParse, pFrom) ) return WRC_Abort;\n#endif\n    }else{\n      /* An ordinary table or view name in the FROM clause */\n      assert( pFrom->pTab==0 );\n      pFrom->pTab = pTab = sqlite3LocateTableItem(pParse, 0, pFrom);\n      if( pTab==0 ) return WRC_Abort;\n      if( pTab->nTabRef>=0xffff ){\n        sqlite3ErrorMsg(pParse, \"too many references to \\\"%s\\\": max 65535\",\n           pTab->zName);\n        pFrom->pTab = 0;\n        return WRC_Abort;\n      }\n      pTab->nTabRef++;\n      if( !IsVirtual(pTab) && cannotBeFunction(pParse, pFrom) ){\n        return WRC_Abort;\n      }\n#if !defined(SQLITE_OMIT_VIEW) || !defined (SQLITE_OMIT_VIRTUALTABLE)\n      if( IsVirtual(pTab) || pTab->pSelect ){\n        i16 nCol;\n        u8 eCodeOrig = pWalker->eCode;\n        if( sqlite3ViewGetColumnNames(pParse, pTab) ) return WRC_Abort;\n        assert( pFrom->pSelect==0 );\n        if( pTab->pSelect && (db->flags & SQLITE_EnableView)==0 ){\n          sqlite3ErrorMsg(pParse, \"access to view \\\"%s\\\" prohibited\",\n              pTab->zName);\n        }\n        pFrom->pSelect = sqlite3SelectDup(db, pTab->pSelect, 0);\n        nCol = pTab->nCol;\n        pTab->nCol = -1;\n        pWalker->eCode = 1;  /* Turn on Select.selId renumbering */\n        sqlite3WalkSelect(pWalker, pFrom->pSelect);\n        pWalker->eCode = eCodeOrig;\n        pTab->nCol = nCol;\n      }\n#endif\n    }\n\n    /* Locate the index named by the INDEXED BY clause, if any. */\n    if( sqlite3IndexedByLookup(pParse, pFrom) ){\n      return WRC_Abort;\n    }\n  }\n\n  /* Process NATURAL keywords, and ON and USING clauses of joins.\n  */\n  if( db->mallocFailed || sqliteProcessJoin(pParse, p) ){\n    return WRC_Abort;\n  }\n\n  /* For every \"*\" that occurs in the column list, insert the names of\n  ** all columns in all tables.  And for every TABLE.* insert the names\n  ** of all columns in TABLE.  The parser inserted a special expression\n  ** with the TK_ASTERISK operator for each \"*\" that it found in the column\n  ** list.  The following code just has to locate the TK_ASTERISK\n  ** expressions and expand each one to the list of all columns in\n  ** all tables.\n  **\n  ** The first loop just checks to see if there are any \"*\" operators\n  ** that need expanding.\n  */\n  for(k=0; k<pEList->nExpr; k++){\n    pE = pEList->a[k].pExpr;\n    if( pE->op==TK_ASTERISK ) break;\n    assert( pE->op!=TK_DOT || pE->pRight!=0 );\n    assert( pE->op!=TK_DOT || (pE->pLeft!=0 && pE->pLeft->op==TK_ID) );\n    if( pE->op==TK_DOT && pE->pRight->op==TK_ASTERISK ) break;\n    elistFlags |= pE->flags;\n  }\n  if( k<pEList->nExpr ){\n    /*\n    ** If we get here it means the result set contains one or more \"*\"\n    ** operators that need to be expanded.  Loop through each expression\n    ** in the result set and expand them one by one.\n    */\n    struct ExprList_item *a = pEList->a;\n    ExprList *pNew = 0;\n    int flags = pParse->db->flags;\n    int longNames = (flags & SQLITE_FullColNames)!=0\n                      && (flags & SQLITE_ShortColNames)==0;\n\n    for(k=0; k<pEList->nExpr; k++){\n      pE = a[k].pExpr;\n      elistFlags |= pE->flags;\n      pRight = pE->pRight;\n      assert( pE->op!=TK_DOT || pRight!=0 );\n      if( pE->op!=TK_ASTERISK\n       && (pE->op!=TK_DOT || pRight->op!=TK_ASTERISK)\n      ){\n        /* This particular expression does not need to be expanded.\n        */\n        pNew = sqlite3ExprListAppend(pParse, pNew, a[k].pExpr);\n        if( pNew ){\n          pNew->a[pNew->nExpr-1].zName = a[k].zName;\n          pNew->a[pNew->nExpr-1].zSpan = a[k].zSpan;\n          a[k].zName = 0;\n          a[k].zSpan = 0;\n        }\n        a[k].pExpr = 0;\n      }else{\n        /* This expression is a \"*\" or a \"TABLE.*\" and needs to be\n        ** expanded. */\n        int tableSeen = 0;      /* Set to 1 when TABLE matches */\n        char *zTName = 0;       /* text of name of TABLE */\n        if( pE->op==TK_DOT ){\n          assert( pE->pLeft!=0 );\n          assert( !ExprHasProperty(pE->pLeft, EP_IntValue) );\n          zTName = pE->pLeft->u.zToken;\n        }\n        for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){\n          Table *pTab = pFrom->pTab;\n          Select *pSub = pFrom->pSelect;\n          char *zTabName = pFrom->zAlias;\n          const char *zSchemaName = 0;\n          int iDb;\n          if( zTabName==0 ){\n            zTabName = pTab->zName;\n          }\n          if( db->mallocFailed ) break;\n          if( pSub==0 || (pSub->selFlags & SF_NestedFrom)==0 ){\n            pSub = 0;\n            if( zTName && sqlite3StrICmp(zTName, zTabName)!=0 ){\n              continue;\n            }\n            iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n            zSchemaName = iDb>=0 ? db->aDb[iDb].zDbSName : \"*\";\n          }\n          for(j=0; j<pTab->nCol; j++){\n            char *zName = pTab->aCol[j].zName;\n            char *zColname;  /* The computed column name */\n            char *zToFree;   /* Malloced string that needs to be freed */\n            Token sColname;  /* Computed column name as a token */\n\n            assert( zName );\n            if( zTName && pSub\n             && sqlite3MatchSpanName(pSub->pEList->a[j].zSpan, 0, zTName, 0)==0\n            ){\n              continue;\n            }\n\n            /* If a column is marked as 'hidden', omit it from the expanded\n            ** result-set list unless the SELECT has the SF_IncludeHidden\n            ** bit set.\n            */\n            if( (p->selFlags & SF_IncludeHidden)==0\n             && IsHiddenColumn(&pTab->aCol[j]) \n            ){\n              continue;\n            }\n            tableSeen = 1;\n\n            if( i>0 && zTName==0 ){\n              if( (pFrom->fg.jointype & JT_NATURAL)!=0\n                && tableAndColumnIndex(pTabList, i, zName, 0, 0)\n              ){\n                /* In a NATURAL join, omit the join columns from the \n                ** table to the right of the join */\n                continue;\n              }\n              if( sqlite3IdListIndex(pFrom->pUsing, zName)>=0 ){\n                /* In a join with a USING clause, omit columns in the\n                ** using clause from the table on the right. */\n                continue;\n              }\n            }\n            pRight = sqlite3Expr(db, TK_ID, zName);\n            zColname = zName;\n            zToFree = 0;\n            if( longNames || pTabList->nSrc>1 ){\n              Expr *pLeft;\n              pLeft = sqlite3Expr(db, TK_ID, zTabName);\n              pExpr = sqlite3PExpr(pParse, TK_DOT, pLeft, pRight);\n              if( zSchemaName ){\n                pLeft = sqlite3Expr(db, TK_ID, zSchemaName);\n                pExpr = sqlite3PExpr(pParse, TK_DOT, pLeft, pExpr);\n              }\n              if( longNames ){\n                zColname = sqlite3MPrintf(db, \"%s.%s\", zTabName, zName);\n                zToFree = zColname;\n              }\n            }else{\n              pExpr = pRight;\n            }\n            pNew = sqlite3ExprListAppend(pParse, pNew, pExpr);\n            sqlite3TokenInit(&sColname, zColname);\n            sqlite3ExprListSetName(pParse, pNew, &sColname, 0);\n            if( pNew && (p->selFlags & SF_NestedFrom)!=0 ){\n              struct ExprList_item *pX = &pNew->a[pNew->nExpr-1];\n              if( pSub ){\n                pX->zSpan = sqlite3DbStrDup(db, pSub->pEList->a[j].zSpan);\n                testcase( pX->zSpan==0 );\n              }else{\n                pX->zSpan = sqlite3MPrintf(db, \"%s.%s.%s\",\n                                           zSchemaName, zTabName, zColname);\n                testcase( pX->zSpan==0 );\n              }\n              pX->bSpanIsTab = 1;\n            }\n            sqlite3DbFree(db, zToFree);\n          }\n        }\n        if( !tableSeen ){\n          if( zTName ){\n            sqlite3ErrorMsg(pParse, \"no such table: %s\", zTName);\n          }else{\n            sqlite3ErrorMsg(pParse, \"no tables specified\");\n          }\n        }\n      }\n    }\n    sqlite3ExprListDelete(db, pEList);\n    p->pEList = pNew;\n  }\n  if( p->pEList ){\n    if( p->pEList->nExpr>db->aLimit[SQLITE_LIMIT_COLUMN] ){\n      sqlite3ErrorMsg(pParse, \"too many columns in result set\");\n      return WRC_Abort;\n    }\n    if( (elistFlags & (EP_HasFunc|EP_Subquery))!=0 ){\n      p->selFlags |= SF_ComplexResult;\n    }\n  }\n  return WRC_Continue;\n}\n\n/*\n** No-op routine for the parse-tree walker.\n**\n** When this routine is the Walker.xExprCallback then expression trees\n** are walked without any actions being taken at each node.  Presumably,\n** when this routine is used for Walker.xExprCallback then \n** Walker.xSelectCallback is set to do something useful for every \n** subquery in the parser tree.\n*/\nint sqlite3ExprWalkNoop(Walker *NotUsed, Expr *NotUsed2){\n  UNUSED_PARAMETER2(NotUsed, NotUsed2);\n  return WRC_Continue;\n}\n\n/*\n** No-op routine for the parse-tree walker for SELECT statements.\n** subquery in the parser tree.\n*/\nint sqlite3SelectWalkNoop(Walker *NotUsed, Select *NotUsed2){\n  UNUSED_PARAMETER2(NotUsed, NotUsed2);\n  return WRC_Continue;\n}\n\n#if SQLITE_DEBUG\n/*\n** Always assert.  This xSelectCallback2 implementation proves that the\n** xSelectCallback2 is never invoked.\n*/\nvoid sqlite3SelectWalkAssert2(Walker *NotUsed, Select *NotUsed2){\n  UNUSED_PARAMETER2(NotUsed, NotUsed2);\n  assert( 0 );\n}\n#endif\n/*\n** This routine \"expands\" a SELECT statement and all of its subqueries.\n** For additional information on what it means to \"expand\" a SELECT\n** statement, see the comment on the selectExpand worker callback above.\n**\n** Expanding a SELECT statement is the first step in processing a\n** SELECT statement.  The SELECT statement must be expanded before\n** name resolution is performed.\n**\n** If anything goes wrong, an error message is written into pParse.\n** The calling function can detect the problem by looking at pParse->nErr\n** and/or pParse->db->mallocFailed.\n*/\nstatic void sqlite3SelectExpand(Parse *pParse, Select *pSelect){\n  Walker w;\n  w.xExprCallback = sqlite3ExprWalkNoop;\n  w.pParse = pParse;\n  if( OK_IF_ALWAYS_TRUE(pParse->hasCompound) ){\n    w.xSelectCallback = convertCompoundSelectToSubquery;\n    w.xSelectCallback2 = 0;\n    sqlite3WalkSelect(&w, pSelect);\n  }\n  w.xSelectCallback = selectExpander;\n  w.xSelectCallback2 = selectPopWith;\n  w.eCode = 0;\n  sqlite3WalkSelect(&w, pSelect);\n}\n\n\n#ifndef SQLITE_OMIT_SUBQUERY\n/*\n** This is a Walker.xSelectCallback callback for the sqlite3SelectTypeInfo()\n** interface.\n**\n** For each FROM-clause subquery, add Column.zType and Column.zColl\n** information to the Table structure that represents the result set\n** of that subquery.\n**\n** The Table structure that represents the result set was constructed\n** by selectExpander() but the type and collation information was omitted\n** at that point because identifiers had not yet been resolved.  This\n** routine is called after identifier resolution.\n*/\nstatic void selectAddSubqueryTypeInfo(Walker *pWalker, Select *p){\n  Parse *pParse;\n  int i;\n  SrcList *pTabList;\n  struct SrcList_item *pFrom;\n\n  assert( p->selFlags & SF_Resolved );\n  if( p->selFlags & SF_HasTypeInfo ) return;\n  p->selFlags |= SF_HasTypeInfo;\n  pParse = pWalker->pParse;\n  pTabList = p->pSrc;\n  for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){\n    Table *pTab = pFrom->pTab;\n    assert( pTab!=0 );\n    if( (pTab->tabFlags & TF_Ephemeral)!=0 ){\n      /* A sub-query in the FROM clause of a SELECT */\n      Select *pSel = pFrom->pSelect;\n      if( pSel ){\n        while( pSel->pPrior ) pSel = pSel->pPrior;\n        sqlite3SelectAddColumnTypeAndCollation(pParse, pTab, pSel,\n                                               SQLITE_AFF_NONE);\n      }\n    }\n  }\n}\n#endif\n\n\n/*\n** This routine adds datatype and collating sequence information to\n** the Table structures of all FROM-clause subqueries in a\n** SELECT statement.\n**\n** Use this routine after name resolution.\n*/\nstatic void sqlite3SelectAddTypeInfo(Parse *pParse, Select *pSelect){\n#ifndef SQLITE_OMIT_SUBQUERY\n  Walker w;\n  w.xSelectCallback = sqlite3SelectWalkNoop;\n  w.xSelectCallback2 = selectAddSubqueryTypeInfo;\n  w.xExprCallback = sqlite3ExprWalkNoop;\n  w.pParse = pParse;\n  sqlite3WalkSelect(&w, pSelect);\n#endif\n}\n\n\n/*\n** This routine sets up a SELECT statement for processing.  The\n** following is accomplished:\n**\n**     *  VDBE Cursor numbers are assigned to all FROM-clause terms.\n**     *  Ephemeral Table objects are created for all FROM-clause subqueries.\n**     *  ON and USING clauses are shifted into WHERE statements\n**     *  Wildcards \"*\" and \"TABLE.*\" in result sets are expanded.\n**     *  Identifiers in expression are matched to tables.\n**\n** This routine acts recursively on all subqueries within the SELECT.\n*/\nvoid sqlite3SelectPrep(\n  Parse *pParse,         /* The parser context */\n  Select *p,             /* The SELECT statement being coded. */\n  NameContext *pOuterNC  /* Name context for container */\n){\n  assert( p!=0 || pParse->db->mallocFailed );\n  if( pParse->db->mallocFailed ) return;\n  if( p->selFlags & SF_HasTypeInfo ) return;\n  sqlite3SelectExpand(pParse, p);\n  if( pParse->nErr || pParse->db->mallocFailed ) return;\n  sqlite3ResolveSelectNames(pParse, p, pOuterNC);\n  if( pParse->nErr || pParse->db->mallocFailed ) return;\n  sqlite3SelectAddTypeInfo(pParse, p);\n}\n\n/*\n** Reset the aggregate accumulator.\n**\n** The aggregate accumulator is a set of memory cells that hold\n** intermediate results while calculating an aggregate.  This\n** routine generates code that stores NULLs in all of those memory\n** cells.\n*/\nstatic void resetAccumulator(Parse *pParse, AggInfo *pAggInfo){\n  Vdbe *v = pParse->pVdbe;\n  int i;\n  struct AggInfo_func *pFunc;\n  int nReg = pAggInfo->nFunc + pAggInfo->nColumn;\n  if( nReg==0 ) return;\n#ifdef SQLITE_DEBUG\n  /* Verify that all AggInfo registers are within the range specified by\n  ** AggInfo.mnReg..AggInfo.mxReg */\n  assert( nReg==pAggInfo->mxReg-pAggInfo->mnReg+1 );\n  for(i=0; i<pAggInfo->nColumn; i++){\n    assert( pAggInfo->aCol[i].iMem>=pAggInfo->mnReg\n         && pAggInfo->aCol[i].iMem<=pAggInfo->mxReg );\n  }\n  for(i=0; i<pAggInfo->nFunc; i++){\n    assert( pAggInfo->aFunc[i].iMem>=pAggInfo->mnReg\n         && pAggInfo->aFunc[i].iMem<=pAggInfo->mxReg );\n  }\n#endif\n  sqlite3VdbeAddOp3(v, OP_Null, 0, pAggInfo->mnReg, pAggInfo->mxReg);\n  for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++){\n    if( pFunc->iDistinct>=0 ){\n      Expr *pE = pFunc->pExpr;\n      assert( !ExprHasProperty(pE, EP_xIsSelect) );\n      if( pE->x.pList==0 || pE->x.pList->nExpr!=1 ){\n        sqlite3ErrorMsg(pParse, \"DISTINCT aggregates must have exactly one \"\n           \"argument\");\n        pFunc->iDistinct = -1;\n      }else{\n        KeyInfo *pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pE->x.pList,0,0);\n        sqlite3VdbeAddOp4(v, OP_OpenEphemeral, pFunc->iDistinct, 0, 0,\n                          (char*)pKeyInfo, P4_KEYINFO);\n      }\n    }\n  }\n}\n\n/*\n** Invoke the OP_AggFinalize opcode for every aggregate function\n** in the AggInfo structure.\n*/\nstatic void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo){\n  Vdbe *v = pParse->pVdbe;\n  int i;\n  struct AggInfo_func *pF;\n  for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++){\n    ExprList *pList = pF->pExpr->x.pList;\n    assert( !ExprHasProperty(pF->pExpr, EP_xIsSelect) );\n    sqlite3VdbeAddOp2(v, OP_AggFinal, pF->iMem, pList ? pList->nExpr : 0);\n    sqlite3VdbeAppendP4(v, pF->pFunc, P4_FUNCDEF);\n  }\n}\n\n\n/*\n** Update the accumulator memory cells for an aggregate based on\n** the current cursor position.\n**\n** If regAcc is non-zero and there are no min() or max() aggregates\n** in pAggInfo, then only populate the pAggInfo->nAccumulator accumulator\n** registers if register regAcc contains 0. The caller will take care\n** of setting and clearing regAcc.\n*/\nstatic void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo){\n  Vdbe *v = pParse->pVdbe;\n  int i;\n  int regHit = 0;\n  int addrHitTest = 0;\n  struct AggInfo_func *pF;\n  struct AggInfo_col *pC;\n\n  pAggInfo->directMode = 1;\n  for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++){\n    int nArg;\n    int addrNext = 0;\n    int regAgg;\n    ExprList *pList = pF->pExpr->x.pList;\n    assert( !ExprHasProperty(pF->pExpr, EP_xIsSelect) );\n    assert( !IsWindowFunc(pF->pExpr) );\n    if( ExprHasProperty(pF->pExpr, EP_WinFunc) ){\n      Expr *pFilter = pF->pExpr->y.pWin->pFilter;\n      if( pAggInfo->nAccumulator \n       && (pF->pFunc->funcFlags & SQLITE_FUNC_NEEDCOLL) \n      ){\n        if( regHit==0 ) regHit = ++pParse->nMem;\n        /* If this is the first row of the group (regAcc==0), clear the\n        ** \"magnet\" register regHit so that the accumulator registers\n        ** are populated if the FILTER clause jumps over the the \n        ** invocation of min() or max() altogether. Or, if this is not\n        ** the first row (regAcc==1), set the magnet register so that the\n        ** accumulators are not populated unless the min()/max() is invoked and\n        ** indicates that they should be.  */\n        sqlite3VdbeAddOp2(v, OP_Copy, regAcc, regHit);\n      }\n      addrNext = sqlite3VdbeMakeLabel(pParse);\n      sqlite3ExprIfFalse(pParse, pFilter, addrNext, SQLITE_JUMPIFNULL);\n    }\n    if( pList ){\n      nArg = pList->nExpr;\n      regAgg = sqlite3GetTempRange(pParse, nArg);\n      sqlite3ExprCodeExprList(pParse, pList, regAgg, 0, SQLITE_ECEL_DUP);\n    }else{\n      nArg = 0;\n      regAgg = 0;\n    }\n    if( pF->iDistinct>=0 ){\n      if( addrNext==0 ){ \n        addrNext = sqlite3VdbeMakeLabel(pParse);\n      }\n      testcase( nArg==0 );  /* Error condition */\n      testcase( nArg>1 );   /* Also an error */\n      codeDistinct(pParse, pF->iDistinct, addrNext, 1, regAgg);\n    }\n    if( pF->pFunc->funcFlags & SQLITE_FUNC_NEEDCOLL ){\n      CollSeq *pColl = 0;\n      struct ExprList_item *pItem;\n      int j;\n      assert( pList!=0 );  /* pList!=0 if pF->pFunc has NEEDCOLL */\n      for(j=0, pItem=pList->a; !pColl && j<nArg; j++, pItem++){\n        pColl = sqlite3ExprCollSeq(pParse, pItem->pExpr);\n      }\n      if( !pColl ){\n        pColl = pParse->db->pDfltColl;\n      }\n      if( regHit==0 && pAggInfo->nAccumulator ) regHit = ++pParse->nMem;\n      sqlite3VdbeAddOp4(v, OP_CollSeq, regHit, 0, 0, (char *)pColl, P4_COLLSEQ);\n    }\n    sqlite3VdbeAddOp3(v, OP_AggStep, 0, regAgg, pF->iMem);\n    sqlite3VdbeAppendP4(v, pF->pFunc, P4_FUNCDEF);\n    sqlite3VdbeChangeP5(v, (u8)nArg);\n    sqlite3ReleaseTempRange(pParse, regAgg, nArg);\n    if( addrNext ){\n      sqlite3VdbeResolveLabel(v, addrNext);\n    }\n  }\n  if( regHit==0 && pAggInfo->nAccumulator ){\n    regHit = regAcc;\n  }\n  if( regHit ){\n    addrHitTest = sqlite3VdbeAddOp1(v, OP_If, regHit); VdbeCoverage(v);\n  }\n  for(i=0, pC=pAggInfo->aCol; i<pAggInfo->nAccumulator; i++, pC++){\n    sqlite3ExprCode(pParse, pC->pExpr, pC->iMem);\n  }\n\n  pAggInfo->directMode = 0;\n  if( addrHitTest ){\n    sqlite3VdbeJumpHere(v, addrHitTest);\n  }\n}\n\n/*\n** Add a single OP_Explain instruction to the VDBE to explain a simple\n** count(*) query (\"SELECT count(*) FROM pTab\").\n*/\n#ifndef SQLITE_OMIT_EXPLAIN\nstatic void explainSimpleCount(\n  Parse *pParse,                  /* Parse context */\n  Table *pTab,                    /* Table being queried */\n  Index *pIdx                     /* Index used to optimize scan, or NULL */\n){\n  if( pParse->explain==2 ){\n    int bCover = (pIdx!=0 && (HasRowid(pTab) || !IsPrimaryKeyIndex(pIdx)));\n    sqlite3VdbeExplain(pParse, 0, \"SCAN TABLE %s%s%s\",\n        pTab->zName,\n        bCover ? \" USING COVERING INDEX \" : \"\",\n        bCover ? pIdx->zName : \"\"\n    );\n  }\n}\n#else\n# define explainSimpleCount(a,b,c)\n#endif\n\n/*\n** sqlite3WalkExpr() callback used by havingToWhere().\n**\n** If the node passed to the callback is a TK_AND node, return \n** WRC_Continue to tell sqlite3WalkExpr() to iterate through child nodes.\n**\n** Otherwise, return WRC_Prune. In this case, also check if the \n** sub-expression matches the criteria for being moved to the WHERE\n** clause. If so, add it to the WHERE clause and replace the sub-expression\n** within the HAVING expression with a constant \"1\".\n*/\nstatic int havingToWhereExprCb(Walker *pWalker, Expr *pExpr){\n  if( pExpr->op!=TK_AND ){\n    Select *pS = pWalker->u.pSelect;\n    if( sqlite3ExprIsConstantOrGroupBy(pWalker->pParse, pExpr, pS->pGroupBy) ){\n      sqlite3 *db = pWalker->pParse->db;\n      Expr *pNew = sqlite3Expr(db, TK_INTEGER, \"1\");\n      if( pNew ){\n        Expr *pWhere = pS->pWhere;\n        SWAP(Expr, *pNew, *pExpr);\n        pNew = sqlite3ExprAnd(pWalker->pParse, pWhere, pNew);\n        pS->pWhere = pNew;\n        pWalker->eCode = 1;\n      }\n    }\n    return WRC_Prune;\n  }\n  return WRC_Continue;\n}\n\n/*\n** Transfer eligible terms from the HAVING clause of a query, which is\n** processed after grouping, to the WHERE clause, which is processed before\n** grouping. For example, the query:\n**\n**   SELECT * FROM <tables> WHERE a=? GROUP BY b HAVING b=? AND c=?\n**\n** can be rewritten as:\n**\n**   SELECT * FROM <tables> WHERE a=? AND b=? GROUP BY b HAVING c=?\n**\n** A term of the HAVING expression is eligible for transfer if it consists\n** entirely of constants and expressions that are also GROUP BY terms that\n** use the \"BINARY\" collation sequence.\n*/\nstatic void havingToWhere(Parse *pParse, Select *p){\n  Walker sWalker;\n  memset(&sWalker, 0, sizeof(sWalker));\n  sWalker.pParse = pParse;\n  sWalker.xExprCallback = havingToWhereExprCb;\n  sWalker.u.pSelect = p;\n  sqlite3WalkExpr(&sWalker, p->pHaving);\n#if SELECTTRACE_ENABLED\n  if( sWalker.eCode && (sqlite3SelectTrace & 0x100)!=0 ){\n    SELECTTRACE(0x100,pParse,p,(\"Move HAVING terms into WHERE:\\n\"));\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n}\n\n/*\n** Check to see if the pThis entry of pTabList is a self-join of a prior view.\n** If it is, then return the SrcList_item for the prior view.  If it is not,\n** then return 0.\n*/\nstatic struct SrcList_item *isSelfJoinView(\n  SrcList *pTabList,           /* Search for self-joins in this FROM clause */\n  struct SrcList_item *pThis   /* Search for prior reference to this subquery */\n){\n  struct SrcList_item *pItem;\n  for(pItem = pTabList->a; pItem<pThis; pItem++){\n    Select *pS1;\n    if( pItem->pSelect==0 ) continue;\n    if( pItem->fg.viaCoroutine ) continue;\n    if( pItem->zName==0 ) continue;\n    assert( pItem->pTab!=0 );\n    assert( pThis->pTab!=0 );\n    if( pItem->pTab->pSchema!=pThis->pTab->pSchema ) continue;\n    if( sqlite3_stricmp(pItem->zName, pThis->zName)!=0 ) continue;\n    pS1 = pItem->pSelect;\n    if( pItem->pTab->pSchema==0 && pThis->pSelect->selId!=pS1->selId ){\n      /* The query flattener left two different CTE tables with identical\n      ** names in the same FROM clause. */\n      continue;\n    }\n    if( sqlite3ExprCompare(0, pThis->pSelect->pWhere, pS1->pWhere, -1)\n     || sqlite3ExprCompare(0, pThis->pSelect->pHaving, pS1->pHaving, -1) \n    ){\n      /* The view was modified by some other optimization such as\n      ** pushDownWhereTerms() */\n      continue;\n    }\n    return pItem;\n  }\n  return 0;\n}\n\n#ifdef SQLITE_COUNTOFVIEW_OPTIMIZATION\n/*\n** Attempt to transform a query of the form\n**\n**    SELECT count(*) FROM (SELECT x FROM t1 UNION ALL SELECT y FROM t2)\n**\n** Into this:\n**\n**    SELECT (SELECT count(*) FROM t1)+(SELECT count(*) FROM t2)\n**\n** The transformation only works if all of the following are true:\n**\n**   *  The subquery is a UNION ALL of two or more terms\n**   *  The subquery does not have a LIMIT clause\n**   *  There is no WHERE or GROUP BY or HAVING clauses on the subqueries\n**   *  The outer query is a simple count(*) with no WHERE clause or other\n**      extraneous syntax.\n**\n** Return TRUE if the optimization is undertaken.\n*/\nstatic int countOfViewOptimization(Parse *pParse, Select *p){\n  Select *pSub, *pPrior;\n  Expr *pExpr;\n  Expr *pCount;\n  sqlite3 *db;\n  if( (p->selFlags & SF_Aggregate)==0 ) return 0;   /* This is an aggregate */\n  if( p->pEList->nExpr!=1 ) return 0;               /* Single result column */\n  if( p->pWhere ) return 0;\n  if( p->pGroupBy ) return 0;\n  pExpr = p->pEList->a[0].pExpr;\n  if( pExpr->op!=TK_AGG_FUNCTION ) return 0;        /* Result is an aggregate */\n  if( sqlite3_stricmp(pExpr->u.zToken,\"count\") ) return 0;  /* Is count() */\n  if( pExpr->x.pList!=0 ) return 0;                 /* Must be count(*) */\n  if( p->pSrc->nSrc!=1 ) return 0;                  /* One table in FROM  */\n  pSub = p->pSrc->a[0].pSelect;\n  if( pSub==0 ) return 0;                           /* The FROM is a subquery */\n  if( pSub->pPrior==0 ) return 0;                   /* Must be a compound ry */\n  do{\n    if( pSub->op!=TK_ALL && pSub->pPrior ) return 0;  /* Must be UNION ALL */\n    if( pSub->pWhere ) return 0;                      /* No WHERE clause */\n    if( pSub->pLimit ) return 0;                      /* No LIMIT clause */\n    if( pSub->selFlags & SF_Aggregate ) return 0;     /* Not an aggregate */\n    pSub = pSub->pPrior;                              /* Repeat over compound */\n  }while( pSub );\n\n  /* If we reach this point then it is OK to perform the transformation */\n\n  db = pParse->db;\n  pCount = pExpr;\n  pExpr = 0;\n  pSub = p->pSrc->a[0].pSelect;\n  p->pSrc->a[0].pSelect = 0;\n  sqlite3SrcListDelete(db, p->pSrc);\n  p->pSrc = sqlite3DbMallocZero(pParse->db, sizeof(*p->pSrc));\n  while( pSub ){\n    Expr *pTerm;\n    pPrior = pSub->pPrior;\n    pSub->pPrior = 0;\n    pSub->pNext = 0;\n    pSub->selFlags |= SF_Aggregate;\n    pSub->selFlags &= ~SF_Compound;\n    pSub->nSelectRow = 0;\n    sqlite3ExprListDelete(db, pSub->pEList);\n    pTerm = pPrior ? sqlite3ExprDup(db, pCount, 0) : pCount;\n    pSub->pEList = sqlite3ExprListAppend(pParse, 0, pTerm);\n    pTerm = sqlite3PExpr(pParse, TK_SELECT, 0, 0);\n    sqlite3PExprAddSelect(pParse, pTerm, pSub);\n    if( pExpr==0 ){\n      pExpr = pTerm;\n    }else{\n      pExpr = sqlite3PExpr(pParse, TK_PLUS, pTerm, pExpr);\n    }\n    pSub = pPrior;\n  }\n  p->pEList->a[0].pExpr = pExpr;\n  p->selFlags &= ~SF_Aggregate;\n\n#if SELECTTRACE_ENABLED\n  if( sqlite3SelectTrace & 0x400 ){\n    SELECTTRACE(0x400,pParse,p,(\"After count-of-view optimization:\\n\"));\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n  return 1;\n}\n#endif /* SQLITE_COUNTOFVIEW_OPTIMIZATION */\n\n/*\n** Generate code for the SELECT statement given in the p argument.  \n**\n** The results are returned according to the SelectDest structure.\n** See comments in sqliteInt.h for further information.\n**\n** This routine returns the number of errors.  If any errors are\n** encountered, then an appropriate error message is left in\n** pParse->zErrMsg.\n**\n** This routine does NOT free the Select structure passed in.  The\n** calling function needs to do that.\n*/\nint sqlite3Select(\n  Parse *pParse,         /* The parser context */\n  Select *p,             /* The SELECT statement being coded. */\n  SelectDest *pDest      /* What to do with the query results */\n){\n  int i, j;              /* Loop counters */\n  WhereInfo *pWInfo;     /* Return from sqlite3WhereBegin() */\n  Vdbe *v;               /* The virtual machine under construction */\n  int isAgg;             /* True for select lists like \"count(*)\" */\n  ExprList *pEList = 0;  /* List of columns to extract. */\n  SrcList *pTabList;     /* List of tables to select from */\n  Expr *pWhere;          /* The WHERE clause.  May be NULL */\n  ExprList *pGroupBy;    /* The GROUP BY clause.  May be NULL */\n  Expr *pHaving;         /* The HAVING clause.  May be NULL */\n  int rc = 1;            /* Value to return from this function */\n  DistinctCtx sDistinct; /* Info on how to code the DISTINCT keyword */\n  SortCtx sSort;         /* Info on how to code the ORDER BY clause */\n  AggInfo sAggInfo;      /* Information used by aggregate queries */\n  int iEnd;              /* Address of the end of the query */\n  sqlite3 *db;           /* The database connection */\n  ExprList *pMinMaxOrderBy = 0;  /* Added ORDER BY for min/max queries */\n  u8 minMaxFlag;                 /* Flag for min/max queries */\n\n  db = pParse->db;\n  v = sqlite3GetVdbe(pParse);\n  if( p==0 || db->mallocFailed || pParse->nErr ){\n    return 1;\n  }\n  if( sqlite3AuthCheck(pParse, SQLITE_SELECT, 0, 0, 0) ) return 1;\n  memset(&sAggInfo, 0, sizeof(sAggInfo));\n#if SELECTTRACE_ENABLED\n  SELECTTRACE(1,pParse,p, (\"begin processing:\\n\", pParse->addrExplain));\n  if( sqlite3SelectTrace & 0x100 ){\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n\n  assert( p->pOrderBy==0 || pDest->eDest!=SRT_DistFifo );\n  assert( p->pOrderBy==0 || pDest->eDest!=SRT_Fifo );\n  assert( p->pOrderBy==0 || pDest->eDest!=SRT_DistQueue );\n  assert( p->pOrderBy==0 || pDest->eDest!=SRT_Queue );\n  if( IgnorableOrderby(pDest) ){\n    assert(pDest->eDest==SRT_Exists || pDest->eDest==SRT_Union || \n           pDest->eDest==SRT_Except || pDest->eDest==SRT_Discard ||\n           pDest->eDest==SRT_Queue  || pDest->eDest==SRT_DistFifo ||\n           pDest->eDest==SRT_DistQueue || pDest->eDest==SRT_Fifo);\n    /* If ORDER BY makes no difference in the output then neither does\n    ** DISTINCT so it can be removed too. */\n    sqlite3ExprListDelete(db, p->pOrderBy);\n    p->pOrderBy = 0;\n    p->selFlags &= ~SF_Distinct;\n  }\n  sqlite3SelectPrep(pParse, p, 0);\n  if( pParse->nErr || db->mallocFailed ){\n    goto select_end;\n  }\n  assert( p->pEList!=0 );\n#if SELECTTRACE_ENABLED\n  if( sqlite3SelectTrace & 0x104 ){\n    SELECTTRACE(0x104,pParse,p, (\"after name resolution:\\n\"));\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n\n  if( pDest->eDest==SRT_Output ){\n    generateColumnNames(pParse, p);\n  }\n\n#ifndef SQLITE_OMIT_WINDOWFUNC\n  if( sqlite3WindowRewrite(pParse, p) ){\n    goto select_end;\n  }\n#if SELECTTRACE_ENABLED\n  if( p->pWin && (sqlite3SelectTrace & 0x108)!=0 ){\n    SELECTTRACE(0x104,pParse,p, (\"after window rewrite:\\n\"));\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n#endif /* SQLITE_OMIT_WINDOWFUNC */\n  pTabList = p->pSrc;\n  isAgg = (p->selFlags & SF_Aggregate)!=0;\n  memset(&sSort, 0, sizeof(sSort));\n  sSort.pOrderBy = p->pOrderBy;\n\n  /* Try to various optimizations (flattening subqueries, and strength\n  ** reduction of join operators) in the FROM clause up into the main query\n  */\n#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)\n  for(i=0; !p->pPrior && i<pTabList->nSrc; i++){\n    struct SrcList_item *pItem = &pTabList->a[i];\n    Select *pSub = pItem->pSelect;\n    Table *pTab = pItem->pTab;\n\n    /* Convert LEFT JOIN into JOIN if there are terms of the right table\n    ** of the LEFT JOIN used in the WHERE clause.\n    */\n    if( (pItem->fg.jointype & JT_LEFT)!=0\n     && sqlite3ExprImpliesNonNullRow(p->pWhere, pItem->iCursor)\n     && OptimizationEnabled(db, SQLITE_SimplifyJoin)\n    ){\n      SELECTTRACE(0x100,pParse,p,\n                (\"LEFT-JOIN simplifies to JOIN on term %d\\n\",i));\n      pItem->fg.jointype &= ~(JT_LEFT|JT_OUTER);\n      unsetJoinExpr(p->pWhere, pItem->iCursor);\n    }\n\n    /* No futher action if this term of the FROM clause is no a subquery */\n    if( pSub==0 ) continue;\n\n    /* Catch mismatch in the declared columns of a view and the number of\n    ** columns in the SELECT on the RHS */\n    if( pTab->nCol!=pSub->pEList->nExpr ){\n      sqlite3ErrorMsg(pParse, \"expected %d columns for '%s' but got %d\",\n                      pTab->nCol, pTab->zName, pSub->pEList->nExpr);\n      goto select_end;\n    }\n\n    /* Do not try to flatten an aggregate subquery.\n    **\n    ** Flattening an aggregate subquery is only possible if the outer query\n    ** is not a join.  But if the outer query is not a join, then the subquery\n    ** will be implemented as a co-routine and there is no advantage to\n    ** flattening in that case.\n    */\n    if( (pSub->selFlags & SF_Aggregate)!=0 ) continue;\n    assert( pSub->pGroupBy==0 );\n\n    /* If the outer query contains a \"complex\" result set (that is,\n    ** if the result set of the outer query uses functions or subqueries)\n    ** and if the subquery contains an ORDER BY clause and if\n    ** it will be implemented as a co-routine, then do not flatten.  This\n    ** restriction allows SQL constructs like this:\n    **\n    **  SELECT expensive_function(x)\n    **    FROM (SELECT x FROM tab ORDER BY y LIMIT 10);\n    **\n    ** The expensive_function() is only computed on the 10 rows that\n    ** are output, rather than every row of the table.\n    **\n    ** The requirement that the outer query have a complex result set\n    ** means that flattening does occur on simpler SQL constraints without\n    ** the expensive_function() like:\n    **\n    **  SELECT x FROM (SELECT x FROM tab ORDER BY y LIMIT 10);\n    */\n    if( pSub->pOrderBy!=0\n     && i==0\n     && (p->selFlags & SF_ComplexResult)!=0\n     && (pTabList->nSrc==1\n         || (pTabList->a[1].fg.jointype&(JT_LEFT|JT_CROSS))!=0)\n    ){\n      continue;\n    }\n\n    if( flattenSubquery(pParse, p, i, isAgg) ){\n      if( pParse->nErr ) goto select_end;\n      /* This subquery can be absorbed into its parent. */\n      i = -1;\n    }\n    pTabList = p->pSrc;\n    if( db->mallocFailed ) goto select_end;\n    if( !IgnorableOrderby(pDest) ){\n      sSort.pOrderBy = p->pOrderBy;\n    }\n  }\n#endif\n\n#ifndef SQLITE_OMIT_COMPOUND_SELECT\n  /* Handle compound SELECT statements using the separate multiSelect()\n  ** procedure.\n  */\n  if( p->pPrior ){\n    rc = multiSelect(pParse, p, pDest);\n#if SELECTTRACE_ENABLED\n    SELECTTRACE(0x1,pParse,p,(\"end compound-select processing\\n\"));\n    if( (sqlite3SelectTrace & 0x2000)!=0 && ExplainQueryPlanParent(pParse)==0 ){\n      sqlite3TreeViewSelect(0, p, 0);\n    }\n#endif\n    if( p->pNext==0 ) ExplainQueryPlanPop(pParse);\n    return rc;\n  }\n#endif\n\n  /* Do the WHERE-clause constant propagation optimization if this is\n  ** a join.  No need to speed time on this operation for non-join queries\n  ** as the equivalent optimization will be handled by query planner in\n  ** sqlite3WhereBegin().\n  */\n  if( pTabList->nSrc>1\n   && OptimizationEnabled(db, SQLITE_PropagateConst)\n   && propagateConstants(pParse, p)\n  ){\n#if SELECTTRACE_ENABLED\n    if( sqlite3SelectTrace & 0x100 ){\n      SELECTTRACE(0x100,pParse,p,(\"After constant propagation:\\n\"));\n      sqlite3TreeViewSelect(0, p, 0);\n    }\n#endif\n  }else{\n    SELECTTRACE(0x100,pParse,p,(\"Constant propagation not helpful\\n\"));\n  }\n\n#ifdef SQLITE_COUNTOFVIEW_OPTIMIZATION\n  if( OptimizationEnabled(db, SQLITE_QueryFlattener|SQLITE_CountOfView)\n   && countOfViewOptimization(pParse, p)\n  ){\n    if( db->mallocFailed ) goto select_end;\n    pEList = p->pEList;\n    pTabList = p->pSrc;\n  }\n#endif\n\n  /* For each term in the FROM clause, do two things:\n  ** (1) Authorized unreferenced tables\n  ** (2) Generate code for all sub-queries\n  */\n  for(i=0; i<pTabList->nSrc; i++){\n    struct SrcList_item *pItem = &pTabList->a[i];\n    SelectDest dest;\n    Select *pSub;\n#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)\n    const char *zSavedAuthContext;\n#endif\n\n    /* Issue SQLITE_READ authorizations with a fake column name for any\n    ** tables that are referenced but from which no values are extracted.\n    ** Examples of where these kinds of null SQLITE_READ authorizations\n    ** would occur:\n    **\n    **     SELECT count(*) FROM t1;   -- SQLITE_READ t1.\"\"\n    **     SELECT t1.* FROM t1, t2;   -- SQLITE_READ t2.\"\"\n    **\n    ** The fake column name is an empty string.  It is possible for a table to\n    ** have a column named by the empty string, in which case there is no way to\n    ** distinguish between an unreferenced table and an actual reference to the\n    ** \"\" column. The original design was for the fake column name to be a NULL,\n    ** which would be unambiguous.  But legacy authorization callbacks might\n    ** assume the column name is non-NULL and segfault.  The use of an empty\n    ** string for the fake column name seems safer.\n    */\n    if( pItem->colUsed==0 && pItem->zName!=0 ){\n      sqlite3AuthCheck(pParse, SQLITE_READ, pItem->zName, \"\", pItem->zDatabase);\n    }\n\n#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)\n    /* Generate code for all sub-queries in the FROM clause\n    */\n    pSub = pItem->pSelect;\n    if( pSub==0 ) continue;\n\n    /* The code for a subquery should only be generated once, though it is\n    ** technically harmless for it to be generated multiple times. The\n    ** following assert() will detect if something changes to cause\n    ** the same subquery to be coded multiple times, as a signal to the\n    ** developers to try to optimize the situation.\n    **\n    ** Update 2019-07-24:\n    ** See ticket https://sqlite.org/src/tktview/c52b09c7f38903b1311cec40.\n    ** The dbsqlfuzz fuzzer found a case where the same subquery gets\n    ** coded twice.  So this assert() now becomes a testcase().  It should\n    ** be very rare, though.\n    */\n    testcase( pItem->addrFillSub!=0 );\n\n    /* Increment Parse.nHeight by the height of the largest expression\n    ** tree referred to by this, the parent select. The child select\n    ** may contain expression trees of at most\n    ** (SQLITE_MAX_EXPR_DEPTH-Parse.nHeight) height. This is a bit\n    ** more conservative than necessary, but much easier than enforcing\n    ** an exact limit.\n    */\n    pParse->nHeight += sqlite3SelectExprHeight(p);\n\n    /* Make copies of constant WHERE-clause terms in the outer query down\n    ** inside the subquery.  This can help the subquery to run more efficiently.\n    */\n    if( OptimizationEnabled(db, SQLITE_PushDown)\n     && pushDownWhereTerms(pParse, pSub, p->pWhere, pItem->iCursor,\n                           (pItem->fg.jointype & JT_OUTER)!=0)\n    ){\n#if SELECTTRACE_ENABLED\n      if( sqlite3SelectTrace & 0x100 ){\n        SELECTTRACE(0x100,pParse,p,\n            (\"After WHERE-clause push-down into subquery %d:\\n\", pSub->selId));\n        sqlite3TreeViewSelect(0, p, 0);\n      }\n#endif\n    }else{\n      SELECTTRACE(0x100,pParse,p,(\"Push-down not possible\\n\"));\n    }\n\n    zSavedAuthContext = pParse->zAuthContext;\n    pParse->zAuthContext = pItem->zName;\n\n    /* Generate code to implement the subquery\n    **\n    ** The subquery is implemented as a co-routine if the subquery is\n    ** guaranteed to be the outer loop (so that it does not need to be\n    ** computed more than once)\n    **\n    ** TODO: Are there other reasons beside (1) to use a co-routine\n    ** implementation?\n    */\n    if( i==0\n     && (pTabList->nSrc==1\n            || (pTabList->a[1].fg.jointype&(JT_LEFT|JT_CROSS))!=0)  /* (1) */\n    ){\n      /* Implement a co-routine that will return a single row of the result\n      ** set on each invocation.\n      */\n      int addrTop = sqlite3VdbeCurrentAddr(v)+1;\n     \n      pItem->regReturn = ++pParse->nMem;\n      sqlite3VdbeAddOp3(v, OP_InitCoroutine, pItem->regReturn, 0, addrTop);\n      VdbeComment((v, \"%s\", pItem->pTab->zName));\n      pItem->addrFillSub = addrTop;\n      sqlite3SelectDestInit(&dest, SRT_Coroutine, pItem->regReturn);\n      ExplainQueryPlan((pParse, 1, \"CO-ROUTINE %u\", pSub->selId));\n      sqlite3Select(pParse, pSub, &dest);\n      pItem->pTab->nRowLogEst = pSub->nSelectRow;\n      pItem->fg.viaCoroutine = 1;\n      pItem->regResult = dest.iSdst;\n      sqlite3VdbeEndCoroutine(v, pItem->regReturn);\n      sqlite3VdbeJumpHere(v, addrTop-1);\n      sqlite3ClearTempRegCache(pParse);\n    }else{\n      /* Generate a subroutine that will fill an ephemeral table with\n      ** the content of this subquery.  pItem->addrFillSub will point\n      ** to the address of the generated subroutine.  pItem->regReturn\n      ** is a register allocated to hold the subroutine return address\n      */\n      int topAddr;\n      int onceAddr = 0;\n      int retAddr;\n      struct SrcList_item *pPrior;\n\n      testcase( pItem->addrFillSub==0 ); /* Ticket c52b09c7f38903b1311 */\n      pItem->regReturn = ++pParse->nMem;\n      topAddr = sqlite3VdbeAddOp2(v, OP_Integer, 0, pItem->regReturn);\n      pItem->addrFillSub = topAddr+1;\n      if( pItem->fg.isCorrelated==0 ){\n        /* If the subquery is not correlated and if we are not inside of\n        ** a trigger, then we only need to compute the value of the subquery\n        ** once. */\n        onceAddr = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);\n        VdbeComment((v, \"materialize \\\"%s\\\"\", pItem->pTab->zName));\n      }else{\n        VdbeNoopComment((v, \"materialize \\\"%s\\\"\", pItem->pTab->zName));\n      }\n      pPrior = isSelfJoinView(pTabList, pItem);\n      if( pPrior ){\n        sqlite3VdbeAddOp2(v, OP_OpenDup, pItem->iCursor, pPrior->iCursor);\n        assert( pPrior->pSelect!=0 );\n        pSub->nSelectRow = pPrior->pSelect->nSelectRow;\n      }else{\n        sqlite3SelectDestInit(&dest, SRT_EphemTab, pItem->iCursor);\n        ExplainQueryPlan((pParse, 1, \"MATERIALIZE %u\", pSub->selId));\n        sqlite3Select(pParse, pSub, &dest);\n      }\n      pItem->pTab->nRowLogEst = pSub->nSelectRow;\n      if( onceAddr ) sqlite3VdbeJumpHere(v, onceAddr);\n      retAddr = sqlite3VdbeAddOp1(v, OP_Return, pItem->regReturn);\n      VdbeComment((v, \"end %s\", pItem->pTab->zName));\n      sqlite3VdbeChangeP1(v, topAddr, retAddr);\n      sqlite3ClearTempRegCache(pParse);\n    }\n    if( db->mallocFailed ) goto select_end;\n    pParse->nHeight -= sqlite3SelectExprHeight(p);\n    pParse->zAuthContext = zSavedAuthContext;\n#endif\n  }\n\n  /* Various elements of the SELECT copied into local variables for\n  ** convenience */\n  pEList = p->pEList;\n  pWhere = p->pWhere;\n  pGroupBy = p->pGroupBy;\n  pHaving = p->pHaving;\n  sDistinct.isTnct = (p->selFlags & SF_Distinct)!=0;\n\n#if SELECTTRACE_ENABLED\n  if( sqlite3SelectTrace & 0x400 ){\n    SELECTTRACE(0x400,pParse,p,(\"After all FROM-clause analysis:\\n\"));\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n\n  /* If the query is DISTINCT with an ORDER BY but is not an aggregate, and \n  ** if the select-list is the same as the ORDER BY list, then this query\n  ** can be rewritten as a GROUP BY. In other words, this:\n  **\n  **     SELECT DISTINCT xyz FROM ... ORDER BY xyz\n  **\n  ** is transformed to:\n  **\n  **     SELECT xyz FROM ... GROUP BY xyz ORDER BY xyz\n  **\n  ** The second form is preferred as a single index (or temp-table) may be \n  ** used for both the ORDER BY and DISTINCT processing. As originally \n  ** written the query must use a temp-table for at least one of the ORDER \n  ** BY and DISTINCT, and an index or separate temp-table for the other.\n  */\n  if( (p->selFlags & (SF_Distinct|SF_Aggregate))==SF_Distinct \n   && sqlite3ExprListCompare(sSort.pOrderBy, pEList, -1)==0\n   && p->pWin==0\n  ){\n    p->selFlags &= ~SF_Distinct;\n    pGroupBy = p->pGroupBy = sqlite3ExprListDup(db, pEList, 0);\n    /* Notice that even thought SF_Distinct has been cleared from p->selFlags,\n    ** the sDistinct.isTnct is still set.  Hence, isTnct represents the\n    ** original setting of the SF_Distinct flag, not the current setting */\n    assert( sDistinct.isTnct );\n\n#if SELECTTRACE_ENABLED\n    if( sqlite3SelectTrace & 0x400 ){\n      SELECTTRACE(0x400,pParse,p,(\"Transform DISTINCT into GROUP BY:\\n\"));\n      sqlite3TreeViewSelect(0, p, 0);\n    }\n#endif\n  }\n\n  /* If there is an ORDER BY clause, then create an ephemeral index to\n  ** do the sorting.  But this sorting ephemeral index might end up\n  ** being unused if the data can be extracted in pre-sorted order.\n  ** If that is the case, then the OP_OpenEphemeral instruction will be\n  ** changed to an OP_Noop once we figure out that the sorting index is\n  ** not needed.  The sSort.addrSortIndex variable is used to facilitate\n  ** that change.\n  */\n  if( sSort.pOrderBy ){\n    KeyInfo *pKeyInfo;\n    pKeyInfo = sqlite3KeyInfoFromExprList(\n        pParse, sSort.pOrderBy, 0, pEList->nExpr);\n    sSort.iECursor = pParse->nTab++;\n    sSort.addrSortIndex =\n      sqlite3VdbeAddOp4(v, OP_OpenEphemeral,\n          sSort.iECursor, sSort.pOrderBy->nExpr+1+pEList->nExpr, 0,\n          (char*)pKeyInfo, P4_KEYINFO\n      );\n  }else{\n    sSort.addrSortIndex = -1;\n  }\n\n  /* If the output is destined for a temporary table, open that table.\n  */\n  if( pDest->eDest==SRT_EphemTab ){\n    sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pDest->iSDParm, pEList->nExpr);\n  }\n\n  /* Set the limiter.\n  */\n  iEnd = sqlite3VdbeMakeLabel(pParse);\n  if( (p->selFlags & SF_FixedLimit)==0 ){\n    p->nSelectRow = 320;  /* 4 billion rows */\n  }\n  computeLimitRegisters(pParse, p, iEnd);\n  if( p->iLimit==0 && sSort.addrSortIndex>=0 ){\n    sqlite3VdbeChangeOpcode(v, sSort.addrSortIndex, OP_SorterOpen);\n    sSort.sortFlags |= SORTFLAG_UseSorter;\n  }\n\n  /* Open an ephemeral index to use for the distinct set.\n  */\n  if( p->selFlags & SF_Distinct ){\n    sDistinct.tabTnct = pParse->nTab++;\n    sDistinct.addrTnct = sqlite3VdbeAddOp4(v, OP_OpenEphemeral,\n                       sDistinct.tabTnct, 0, 0,\n                       (char*)sqlite3KeyInfoFromExprList(pParse, p->pEList,0,0),\n                       P4_KEYINFO);\n    sqlite3VdbeChangeP5(v, BTREE_UNORDERED);\n    sDistinct.eTnctType = WHERE_DISTINCT_UNORDERED;\n  }else{\n    sDistinct.eTnctType = WHERE_DISTINCT_NOOP;\n  }\n\n  if( !isAgg && pGroupBy==0 ){\n    /* No aggregate functions and no GROUP BY clause */\n    u16 wctrlFlags = (sDistinct.isTnct ? WHERE_WANT_DISTINCT : 0)\n                   | (p->selFlags & SF_FixedLimit);\n#ifndef SQLITE_OMIT_WINDOWFUNC\n    Window *pWin = p->pWin;      /* Master window object (or NULL) */\n    if( pWin ){\n      sqlite3WindowCodeInit(pParse, pWin);\n    }\n#endif\n    assert( WHERE_USE_LIMIT==SF_FixedLimit );\n\n\n    /* Begin the database scan. */\n    SELECTTRACE(1,pParse,p,(\"WhereBegin\\n\"));\n    pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, sSort.pOrderBy,\n                               p->pEList, wctrlFlags, p->nSelectRow);\n    if( pWInfo==0 ) goto select_end;\n    if( sqlite3WhereOutputRowCount(pWInfo) < p->nSelectRow ){\n      p->nSelectRow = sqlite3WhereOutputRowCount(pWInfo);\n    }\n    if( sDistinct.isTnct && sqlite3WhereIsDistinct(pWInfo) ){\n      sDistinct.eTnctType = sqlite3WhereIsDistinct(pWInfo);\n    }\n    if( sSort.pOrderBy ){\n      sSort.nOBSat = sqlite3WhereIsOrdered(pWInfo);\n      sSort.labelOBLopt = sqlite3WhereOrderByLimitOptLabel(pWInfo);\n      if( sSort.nOBSat==sSort.pOrderBy->nExpr ){\n        sSort.pOrderBy = 0;\n      }\n    }\n\n    /* If sorting index that was created by a prior OP_OpenEphemeral \n    ** instruction ended up not being needed, then change the OP_OpenEphemeral\n    ** into an OP_Noop.\n    */\n    if( sSort.addrSortIndex>=0 && sSort.pOrderBy==0 ){\n      sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex);\n    }\n\n    assert( p->pEList==pEList );\n#ifndef SQLITE_OMIT_WINDOWFUNC\n    if( pWin ){\n      int addrGosub = sqlite3VdbeMakeLabel(pParse);\n      int iCont = sqlite3VdbeMakeLabel(pParse);\n      int iBreak = sqlite3VdbeMakeLabel(pParse);\n      int regGosub = ++pParse->nMem;\n\n      sqlite3WindowCodeStep(pParse, p, pWInfo, regGosub, addrGosub);\n\n      sqlite3VdbeAddOp2(v, OP_Goto, 0, iBreak);\n      sqlite3VdbeResolveLabel(v, addrGosub);\n      VdbeNoopComment((v, \"inner-loop subroutine\"));\n      sSort.labelOBLopt = 0;\n      selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest, iCont, iBreak);\n      sqlite3VdbeResolveLabel(v, iCont);\n      sqlite3VdbeAddOp1(v, OP_Return, regGosub);\n      VdbeComment((v, \"end inner-loop subroutine\"));\n      sqlite3VdbeResolveLabel(v, iBreak);\n    }else\n#endif /* SQLITE_OMIT_WINDOWFUNC */\n    {\n      /* Use the standard inner loop. */\n      selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest,\n          sqlite3WhereContinueLabel(pWInfo),\n          sqlite3WhereBreakLabel(pWInfo));\n\n      /* End the database scan loop.\n      */\n      sqlite3WhereEnd(pWInfo);\n    }\n  }else{\n    /* This case when there exist aggregate functions or a GROUP BY clause\n    ** or both */\n    NameContext sNC;    /* Name context for processing aggregate information */\n    int iAMem;          /* First Mem address for storing current GROUP BY */\n    int iBMem;          /* First Mem address for previous GROUP BY */\n    int iUseFlag;       /* Mem address holding flag indicating that at least\n                        ** one row of the input to the aggregator has been\n                        ** processed */\n    int iAbortFlag;     /* Mem address which causes query abort if positive */\n    int groupBySort;    /* Rows come from source in GROUP BY order */\n    int addrEnd;        /* End of processing for this SELECT */\n    int sortPTab = 0;   /* Pseudotable used to decode sorting results */\n    int sortOut = 0;    /* Output register from the sorter */\n    int orderByGrp = 0; /* True if the GROUP BY and ORDER BY are the same */\n\n    /* Remove any and all aliases between the result set and the\n    ** GROUP BY clause.\n    */\n    if( pGroupBy ){\n      int k;                        /* Loop counter */\n      struct ExprList_item *pItem;  /* For looping over expression in a list */\n\n      for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++){\n        pItem->u.x.iAlias = 0;\n      }\n      for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++){\n        pItem->u.x.iAlias = 0;\n      }\n      assert( 66==sqlite3LogEst(100) );\n      if( p->nSelectRow>66 ) p->nSelectRow = 66;\n\n      /* If there is both a GROUP BY and an ORDER BY clause and they are\n      ** identical, then it may be possible to disable the ORDER BY clause \n      ** on the grounds that the GROUP BY will cause elements to come out \n      ** in the correct order. It also may not - the GROUP BY might use a\n      ** database index that causes rows to be grouped together as required\n      ** but not actually sorted. Either way, record the fact that the\n      ** ORDER BY and GROUP BY clauses are the same by setting the orderByGrp\n      ** variable.  */\n      if( sSort.pOrderBy && pGroupBy->nExpr==sSort.pOrderBy->nExpr ){\n        int ii;\n        /* The GROUP BY processing doesn't care whether rows are delivered in\n        ** ASC or DESC order - only that each group is returned contiguously.\n        ** So set the ASC/DESC flags in the GROUP BY to match those in the \n        ** ORDER BY to maximize the chances of rows being delivered in an \n        ** order that makes the ORDER BY redundant.  */\n        for(ii=0; ii<pGroupBy->nExpr; ii++){\n          u8 sortFlags = sSort.pOrderBy->a[ii].sortFlags & KEYINFO_ORDER_DESC;\n          pGroupBy->a[ii].sortFlags = sortFlags;\n        }\n        if( sqlite3ExprListCompare(pGroupBy, sSort.pOrderBy, -1)==0 ){\n          orderByGrp = 1;\n        }\n      }\n    }else{\n      assert( 0==sqlite3LogEst(1) );\n      p->nSelectRow = 0;\n    }\n\n    /* Create a label to jump to when we want to abort the query */\n    addrEnd = sqlite3VdbeMakeLabel(pParse);\n\n    /* Convert TK_COLUMN nodes into TK_AGG_COLUMN and make entries in\n    ** sAggInfo for all TK_AGG_FUNCTION nodes in expressions of the\n    ** SELECT statement.\n    */\n    memset(&sNC, 0, sizeof(sNC));\n    sNC.pParse = pParse;\n    sNC.pSrcList = pTabList;\n    sNC.uNC.pAggInfo = &sAggInfo;\n    VVA_ONLY( sNC.ncFlags = NC_UAggInfo; )\n    sAggInfo.mnReg = pParse->nMem+1;\n    sAggInfo.nSortingColumn = pGroupBy ? pGroupBy->nExpr : 0;\n    sAggInfo.pGroupBy = pGroupBy;\n    sqlite3ExprAnalyzeAggList(&sNC, pEList);\n    sqlite3ExprAnalyzeAggList(&sNC, sSort.pOrderBy);\n    if( pHaving ){\n      if( pGroupBy ){\n        assert( pWhere==p->pWhere );\n        assert( pHaving==p->pHaving );\n        assert( pGroupBy==p->pGroupBy );\n        havingToWhere(pParse, p);\n        pWhere = p->pWhere;\n      }\n      sqlite3ExprAnalyzeAggregates(&sNC, pHaving);\n    }\n    sAggInfo.nAccumulator = sAggInfo.nColumn;\n    if( p->pGroupBy==0 && p->pHaving==0 && sAggInfo.nFunc==1 ){\n      minMaxFlag = minMaxQuery(db, sAggInfo.aFunc[0].pExpr, &pMinMaxOrderBy);\n    }else{\n      minMaxFlag = WHERE_ORDERBY_NORMAL;\n    }\n    for(i=0; i<sAggInfo.nFunc; i++){\n      Expr *pExpr = sAggInfo.aFunc[i].pExpr;\n      assert( !ExprHasProperty(pExpr, EP_xIsSelect) );\n      sNC.ncFlags |= NC_InAggFunc;\n      sqlite3ExprAnalyzeAggList(&sNC, pExpr->x.pList);\n#ifndef SQLITE_OMIT_WINDOWFUNC\n      assert( !IsWindowFunc(pExpr) );\n      if( ExprHasProperty(pExpr, EP_WinFunc) ){\n        sqlite3ExprAnalyzeAggregates(&sNC, pExpr->y.pWin->pFilter);\n      }\n#endif\n      sNC.ncFlags &= ~NC_InAggFunc;\n    }\n    sAggInfo.mxReg = pParse->nMem;\n    if( db->mallocFailed ) goto select_end;\n#if SELECTTRACE_ENABLED\n    if( sqlite3SelectTrace & 0x400 ){\n      int ii;\n      SELECTTRACE(0x400,pParse,p,(\"After aggregate analysis:\\n\"));\n      sqlite3TreeViewSelect(0, p, 0);\n      for(ii=0; ii<sAggInfo.nColumn; ii++){\n        sqlite3DebugPrintf(\"agg-column[%d] iMem=%d\\n\",\n            ii, sAggInfo.aCol[ii].iMem);\n        sqlite3TreeViewExpr(0, sAggInfo.aCol[ii].pExpr, 0);\n      }\n      for(ii=0; ii<sAggInfo.nFunc; ii++){\n        sqlite3DebugPrintf(\"agg-func[%d]: iMem=%d\\n\",\n            ii, sAggInfo.aFunc[ii].iMem);\n        sqlite3TreeViewExpr(0, sAggInfo.aFunc[ii].pExpr, 0);\n      }\n    }\n#endif\n\n\n    /* Processing for aggregates with GROUP BY is very different and\n    ** much more complex than aggregates without a GROUP BY.\n    */\n    if( pGroupBy ){\n      KeyInfo *pKeyInfo;  /* Keying information for the group by clause */\n      int addr1;          /* A-vs-B comparision jump */\n      int addrOutputRow;  /* Start of subroutine that outputs a result row */\n      int regOutputRow;   /* Return address register for output subroutine */\n      int addrSetAbort;   /* Set the abort flag and return */\n      int addrTopOfLoop;  /* Top of the input loop */\n      int addrSortingIdx; /* The OP_OpenEphemeral for the sorting index */\n      int addrReset;      /* Subroutine for resetting the accumulator */\n      int regReset;       /* Return address register for reset subroutine */\n\n      /* If there is a GROUP BY clause we might need a sorting index to\n      ** implement it.  Allocate that sorting index now.  If it turns out\n      ** that we do not need it after all, the OP_SorterOpen instruction\n      ** will be converted into a Noop.  \n      */\n      sAggInfo.sortingIdx = pParse->nTab++;\n      pKeyInfo = sqlite3KeyInfoFromExprList(pParse,pGroupBy,0,sAggInfo.nColumn);\n      addrSortingIdx = sqlite3VdbeAddOp4(v, OP_SorterOpen, \n          sAggInfo.sortingIdx, sAggInfo.nSortingColumn, \n          0, (char*)pKeyInfo, P4_KEYINFO);\n\n      /* Initialize memory locations used by GROUP BY aggregate processing\n      */\n      iUseFlag = ++pParse->nMem;\n      iAbortFlag = ++pParse->nMem;\n      regOutputRow = ++pParse->nMem;\n      addrOutputRow = sqlite3VdbeMakeLabel(pParse);\n      regReset = ++pParse->nMem;\n      addrReset = sqlite3VdbeMakeLabel(pParse);\n      iAMem = pParse->nMem + 1;\n      pParse->nMem += pGroupBy->nExpr;\n      iBMem = pParse->nMem + 1;\n      pParse->nMem += pGroupBy->nExpr;\n      sqlite3VdbeAddOp2(v, OP_Integer, 0, iAbortFlag);\n      VdbeComment((v, \"clear abort flag\"));\n      sqlite3VdbeAddOp3(v, OP_Null, 0, iAMem, iAMem+pGroupBy->nExpr-1);\n\n      /* Begin a loop that will extract all source rows in GROUP BY order.\n      ** This might involve two separate loops with an OP_Sort in between, or\n      ** it might be a single loop that uses an index to extract information\n      ** in the right order to begin with.\n      */\n      sqlite3VdbeAddOp2(v, OP_Gosub, regReset, addrReset);\n      SELECTTRACE(1,pParse,p,(\"WhereBegin\\n\"));\n      pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pGroupBy, 0,\n          WHERE_GROUPBY | (orderByGrp ? WHERE_SORTBYGROUP : 0), 0\n      );\n      if( pWInfo==0 ) goto select_end;\n      if( sqlite3WhereIsOrdered(pWInfo)==pGroupBy->nExpr ){\n        /* The optimizer is able to deliver rows in group by order so\n        ** we do not have to sort.  The OP_OpenEphemeral table will be\n        ** cancelled later because we still need to use the pKeyInfo\n        */\n        groupBySort = 0;\n      }else{\n        /* Rows are coming out in undetermined order.  We have to push\n        ** each row into a sorting index, terminate the first loop,\n        ** then loop over the sorting index in order to get the output\n        ** in sorted order\n        */\n        int regBase;\n        int regRecord;\n        int nCol;\n        int nGroupBy;\n\n        explainTempTable(pParse, \n            (sDistinct.isTnct && (p->selFlags&SF_Distinct)==0) ?\n                    \"DISTINCT\" : \"GROUP BY\");\n\n        groupBySort = 1;\n        nGroupBy = pGroupBy->nExpr;\n        nCol = nGroupBy;\n        j = nGroupBy;\n        for(i=0; i<sAggInfo.nColumn; i++){\n          if( sAggInfo.aCol[i].iSorterColumn>=j ){\n            nCol++;\n            j++;\n          }\n        }\n        regBase = sqlite3GetTempRange(pParse, nCol);\n        sqlite3ExprCodeExprList(pParse, pGroupBy, regBase, 0, 0);\n        j = nGroupBy;\n        for(i=0; i<sAggInfo.nColumn; i++){\n          struct AggInfo_col *pCol = &sAggInfo.aCol[i];\n          if( pCol->iSorterColumn>=j ){\n            int r1 = j + regBase;\n            sqlite3ExprCodeGetColumnOfTable(v,\n                               pCol->pTab, pCol->iTable, pCol->iColumn, r1);\n            j++;\n          }\n        }\n        regRecord = sqlite3GetTempReg(pParse);\n        sqlite3VdbeAddOp3(v, OP_MakeRecord, regBase, nCol, regRecord);\n        sqlite3VdbeAddOp2(v, OP_SorterInsert, sAggInfo.sortingIdx, regRecord);\n        sqlite3ReleaseTempReg(pParse, regRecord);\n        sqlite3ReleaseTempRange(pParse, regBase, nCol);\n        sqlite3WhereEnd(pWInfo);\n        sAggInfo.sortingIdxPTab = sortPTab = pParse->nTab++;\n        sortOut = sqlite3GetTempReg(pParse);\n        sqlite3VdbeAddOp3(v, OP_OpenPseudo, sortPTab, sortOut, nCol);\n        sqlite3VdbeAddOp2(v, OP_SorterSort, sAggInfo.sortingIdx, addrEnd);\n        VdbeComment((v, \"GROUP BY sort\")); VdbeCoverage(v);\n        sAggInfo.useSortingIdx = 1;\n      }\n\n      /* If the index or temporary table used by the GROUP BY sort\n      ** will naturally deliver rows in the order required by the ORDER BY\n      ** clause, cancel the ephemeral table open coded earlier.\n      **\n      ** This is an optimization - the correct answer should result regardless.\n      ** Use the SQLITE_GroupByOrder flag with SQLITE_TESTCTRL_OPTIMIZER to \n      ** disable this optimization for testing purposes.  */\n      if( orderByGrp && OptimizationEnabled(db, SQLITE_GroupByOrder) \n       && (groupBySort || sqlite3WhereIsSorted(pWInfo))\n      ){\n        sSort.pOrderBy = 0;\n        sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex);\n      }\n\n      /* Evaluate the current GROUP BY terms and store in b0, b1, b2...\n      ** (b0 is memory location iBMem+0, b1 is iBMem+1, and so forth)\n      ** Then compare the current GROUP BY terms against the GROUP BY terms\n      ** from the previous row currently stored in a0, a1, a2...\n      */\n      addrTopOfLoop = sqlite3VdbeCurrentAddr(v);\n      if( groupBySort ){\n        sqlite3VdbeAddOp3(v, OP_SorterData, sAggInfo.sortingIdx,\n                          sortOut, sortPTab);\n      }\n      for(j=0; j<pGroupBy->nExpr; j++){\n        if( groupBySort ){\n          sqlite3VdbeAddOp3(v, OP_Column, sortPTab, j, iBMem+j);\n        }else{\n          sAggInfo.directMode = 1;\n          sqlite3ExprCode(pParse, pGroupBy->a[j].pExpr, iBMem+j);\n        }\n      }\n      sqlite3VdbeAddOp4(v, OP_Compare, iAMem, iBMem, pGroupBy->nExpr,\n                          (char*)sqlite3KeyInfoRef(pKeyInfo), P4_KEYINFO);\n      addr1 = sqlite3VdbeCurrentAddr(v);\n      sqlite3VdbeAddOp3(v, OP_Jump, addr1+1, 0, addr1+1); VdbeCoverage(v);\n\n      /* Generate code that runs whenever the GROUP BY changes.\n      ** Changes in the GROUP BY are detected by the previous code\n      ** block.  If there were no changes, this block is skipped.\n      **\n      ** This code copies current group by terms in b0,b1,b2,...\n      ** over to a0,a1,a2.  It then calls the output subroutine\n      ** and resets the aggregate accumulator registers in preparation\n      ** for the next GROUP BY batch.\n      */\n      sqlite3ExprCodeMove(pParse, iBMem, iAMem, pGroupBy->nExpr);\n      sqlite3VdbeAddOp2(v, OP_Gosub, regOutputRow, addrOutputRow);\n      VdbeComment((v, \"output one row\"));\n      sqlite3VdbeAddOp2(v, OP_IfPos, iAbortFlag, addrEnd); VdbeCoverage(v);\n      VdbeComment((v, \"check abort flag\"));\n      sqlite3VdbeAddOp2(v, OP_Gosub, regReset, addrReset);\n      VdbeComment((v, \"reset accumulator\"));\n\n      /* Update the aggregate accumulators based on the content of\n      ** the current row\n      */\n      sqlite3VdbeJumpHere(v, addr1);\n      updateAccumulator(pParse, iUseFlag, &sAggInfo);\n      sqlite3VdbeAddOp2(v, OP_Integer, 1, iUseFlag);\n      VdbeComment((v, \"indicate data in accumulator\"));\n\n      /* End of the loop\n      */\n      if( groupBySort ){\n        sqlite3VdbeAddOp2(v, OP_SorterNext, sAggInfo.sortingIdx, addrTopOfLoop);\n        VdbeCoverage(v);\n      }else{\n        sqlite3WhereEnd(pWInfo);\n        sqlite3VdbeChangeToNoop(v, addrSortingIdx);\n      }\n\n      /* Output the final row of result\n      */\n      sqlite3VdbeAddOp2(v, OP_Gosub, regOutputRow, addrOutputRow);\n      VdbeComment((v, \"output final row\"));\n\n      /* Jump over the subroutines\n      */\n      sqlite3VdbeGoto(v, addrEnd);\n\n      /* Generate a subroutine that outputs a single row of the result\n      ** set.  This subroutine first looks at the iUseFlag.  If iUseFlag\n      ** is less than or equal to zero, the subroutine is a no-op.  If\n      ** the processing calls for the query to abort, this subroutine\n      ** increments the iAbortFlag memory location before returning in\n      ** order to signal the caller to abort.\n      */\n      addrSetAbort = sqlite3VdbeCurrentAddr(v);\n      sqlite3VdbeAddOp2(v, OP_Integer, 1, iAbortFlag);\n      VdbeComment((v, \"set abort flag\"));\n      sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);\n      sqlite3VdbeResolveLabel(v, addrOutputRow);\n      addrOutputRow = sqlite3VdbeCurrentAddr(v);\n      sqlite3VdbeAddOp2(v, OP_IfPos, iUseFlag, addrOutputRow+2);\n      VdbeCoverage(v);\n      VdbeComment((v, \"Groupby result generator entry point\"));\n      sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);\n      finalizeAggFunctions(pParse, &sAggInfo);\n      sqlite3ExprIfFalse(pParse, pHaving, addrOutputRow+1, SQLITE_JUMPIFNULL);\n      selectInnerLoop(pParse, p, -1, &sSort,\n                      &sDistinct, pDest,\n                      addrOutputRow+1, addrSetAbort);\n      sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);\n      VdbeComment((v, \"end groupby result generator\"));\n\n      /* Generate a subroutine that will reset the group-by accumulator\n      */\n      sqlite3VdbeResolveLabel(v, addrReset);\n      resetAccumulator(pParse, &sAggInfo);\n      sqlite3VdbeAddOp2(v, OP_Integer, 0, iUseFlag);\n      VdbeComment((v, \"indicate accumulator empty\"));\n      sqlite3VdbeAddOp1(v, OP_Return, regReset);\n     \n    } /* endif pGroupBy.  Begin aggregate queries without GROUP BY: */\n    else {\n#ifndef SQLITE_OMIT_BTREECOUNT\n      Table *pTab;\n      if( (pTab = isSimpleCount(p, &sAggInfo))!=0 ){\n        /* If isSimpleCount() returns a pointer to a Table structure, then\n        ** the SQL statement is of the form:\n        **\n        **   SELECT count(*) FROM <tbl>\n        **\n        ** where the Table structure returned represents table <tbl>.\n        **\n        ** This statement is so common that it is optimized specially. The\n        ** OP_Count instruction is executed either on the intkey table that\n        ** contains the data for table <tbl> or on one of its indexes. It\n        ** is better to execute the op on an index, as indexes are almost\n        ** always spread across less pages than their corresponding tables.\n        */\n        const int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n        const int iCsr = pParse->nTab++;     /* Cursor to scan b-tree */\n        Index *pIdx;                         /* Iterator variable */\n        KeyInfo *pKeyInfo = 0;               /* Keyinfo for scanned index */\n        Index *pBest = 0;                    /* Best index found so far */\n        int iRoot = pTab->tnum;              /* Root page of scanned b-tree */\n\n        sqlite3CodeVerifySchema(pParse, iDb);\n        sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);\n\n        /* Search for the index that has the lowest scan cost.\n        **\n        ** (2011-04-15) Do not do a full scan of an unordered index.\n        **\n        ** (2013-10-03) Do not count the entries in a partial index.\n        **\n        ** In practice the KeyInfo structure will not be used. It is only \n        ** passed to keep OP_OpenRead happy.\n        */\n        if( !HasRowid(pTab) ) pBest = sqlite3PrimaryKeyIndex(pTab);\n        for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n          if( pIdx->bUnordered==0\n           && pIdx->szIdxRow<pTab->szTabRow\n           && pIdx->pPartIdxWhere==0\n           && (!pBest || pIdx->szIdxRow<pBest->szIdxRow)\n          ){\n            pBest = pIdx;\n          }\n        }\n        if( pBest ){\n          iRoot = pBest->tnum;\n          pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pBest);\n        }\n\n        /* Open a read-only cursor, execute the OP_Count, close the cursor. */\n        sqlite3VdbeAddOp4Int(v, OP_OpenRead, iCsr, iRoot, iDb, 1);\n        if( pKeyInfo ){\n          sqlite3VdbeChangeP4(v, -1, (char *)pKeyInfo, P4_KEYINFO);\n        }\n        sqlite3VdbeAddOp2(v, OP_Count, iCsr, sAggInfo.aFunc[0].iMem);\n        sqlite3VdbeAddOp1(v, OP_Close, iCsr);\n        explainSimpleCount(pParse, pTab, pBest);\n      }else\n#endif /* SQLITE_OMIT_BTREECOUNT */\n      {\n        int regAcc = 0;           /* \"populate accumulators\" flag */\n\n        /* If there are accumulator registers but no min() or max() functions\n        ** without FILTER clauses, allocate register regAcc. Register regAcc\n        ** will contain 0 the first time the inner loop runs, and 1 thereafter.\n        ** The code generated by updateAccumulator() uses this to ensure\n        ** that the accumulator registers are (a) updated only once if\n        ** there are no min() or max functions or (b) always updated for the\n        ** first row visited by the aggregate, so that they are updated at\n        ** least once even if the FILTER clause means the min() or max() \n        ** function visits zero rows.  */\n        if( sAggInfo.nAccumulator ){\n          for(i=0; i<sAggInfo.nFunc; i++){\n            if( ExprHasProperty(sAggInfo.aFunc[i].pExpr, EP_WinFunc) ) continue;\n            if( sAggInfo.aFunc[i].pFunc->funcFlags&SQLITE_FUNC_NEEDCOLL ) break;\n          }\n          if( i==sAggInfo.nFunc ){\n            regAcc = ++pParse->nMem;\n            sqlite3VdbeAddOp2(v, OP_Integer, 0, regAcc);\n          }\n        }\n\n        /* This case runs if the aggregate has no GROUP BY clause.  The\n        ** processing is much simpler since there is only a single row\n        ** of output.\n        */\n        assert( p->pGroupBy==0 );\n        resetAccumulator(pParse, &sAggInfo);\n\n        /* If this query is a candidate for the min/max optimization, then\n        ** minMaxFlag will have been previously set to either\n        ** WHERE_ORDERBY_MIN or WHERE_ORDERBY_MAX and pMinMaxOrderBy will\n        ** be an appropriate ORDER BY expression for the optimization.\n        */\n        assert( minMaxFlag==WHERE_ORDERBY_NORMAL || pMinMaxOrderBy!=0 );\n        assert( pMinMaxOrderBy==0 || pMinMaxOrderBy->nExpr==1 );\n\n        SELECTTRACE(1,pParse,p,(\"WhereBegin\\n\"));\n        pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pMinMaxOrderBy,\n                                   0, minMaxFlag, 0);\n        if( pWInfo==0 ){\n          goto select_end;\n        }\n        updateAccumulator(pParse, regAcc, &sAggInfo);\n        if( regAcc ) sqlite3VdbeAddOp2(v, OP_Integer, 1, regAcc);\n        if( sqlite3WhereIsOrdered(pWInfo)>0 ){\n          sqlite3VdbeGoto(v, sqlite3WhereBreakLabel(pWInfo));\n          VdbeComment((v, \"%s() by index\",\n                (minMaxFlag==WHERE_ORDERBY_MIN?\"min\":\"max\")));\n        }\n        sqlite3WhereEnd(pWInfo);\n        finalizeAggFunctions(pParse, &sAggInfo);\n      }\n\n      sSort.pOrderBy = 0;\n      sqlite3ExprIfFalse(pParse, pHaving, addrEnd, SQLITE_JUMPIFNULL);\n      selectInnerLoop(pParse, p, -1, 0, 0, \n                      pDest, addrEnd, addrEnd);\n    }\n    sqlite3VdbeResolveLabel(v, addrEnd);\n    \n  } /* endif aggregate query */\n\n  if( sDistinct.eTnctType==WHERE_DISTINCT_UNORDERED ){\n    explainTempTable(pParse, \"DISTINCT\");\n  }\n\n  /* If there is an ORDER BY clause, then we need to sort the results\n  ** and send them to the callback one by one.\n  */\n  if( sSort.pOrderBy ){\n    explainTempTable(pParse,\n                     sSort.nOBSat>0 ? \"RIGHT PART OF ORDER BY\":\"ORDER BY\");\n    assert( p->pEList==pEList );\n    generateSortTail(pParse, p, &sSort, pEList->nExpr, pDest);\n  }\n\n  /* Jump here to skip this query\n  */\n  sqlite3VdbeResolveLabel(v, iEnd);\n\n  /* The SELECT has been coded. If there is an error in the Parse structure,\n  ** set the return code to 1. Otherwise 0. */\n  rc = (pParse->nErr>0);\n\n  /* Control jumps to here if an error is encountered above, or upon\n  ** successful coding of the SELECT.\n  */\nselect_end:\n  sqlite3ExprListDelete(db, pMinMaxOrderBy);\n  sqlite3DbFree(db, sAggInfo.aCol);\n  sqlite3DbFree(db, sAggInfo.aFunc);\n#if SELECTTRACE_ENABLED\n  SELECTTRACE(0x1,pParse,p,(\"end processing\\n\"));\n  if( (sqlite3SelectTrace & 0x2000)!=0 && ExplainQueryPlanParent(pParse)==0 ){\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n  ExplainQueryPlanPop(pParse);\n  return rc;\n}\n"], "fixing_code": ["C Continuation\\sof\\s[e2bddcd4c55ba3cb]:\\sAdd\\sanother\\sspot\\swhere\\sit\\sis\\snecessary\\nto\\sabort\\searly\\sdue\\sto\\sprior\\serrors\\sin\\ssqlite3WindowRewrite().\nD 2019-12-19T22:08:19.301\nF .fossil-settings/empty-dirs dbb81e8fc0401ac46a1491ab34a7f2c7c0452f2f06b54ebb845d024ca8283ef1\nF .fossil-settings/ignore-glob 35175cdfcf539b2318cb04a9901442804be81cd677d8b889fcc9149c21f239ea\nF LICENSE.md df5091916dbb40e6e9686186587125e1b2ff51f022cc334e886c19a0e9982724\nF Makefile.in d3a862c9742f5a08230a3b295c0a47fd3067f19356dc39935280135f90474b04\nF Makefile.linux-gcc f609543700659711fbd230eced1f01353117621dccae7b9fb70daa64236c5241\nF Makefile.msc 0b0acbf34bb238170bdf1fd343a1fd37bc81c042ce029c1cc53fe15b5d4ed07b\nF README.md 1514a365ffca3c138e00c5cc839906108a01011a6b082bad19b09781e3aa498a\nF VERSION 081500f0aeaadc989d85aafbc717af45512018aebc73d89e5c2368fe62a600ff\nF aclocal.m4 a5c22d164aff7ed549d53a90fa56d56955281f50\nF art/sqlite370.eps aa97a671332b432a54e1d74ff5e8775be34200c2\nF art/sqlite370.ico af56c1d00fee7cd4753e8631ed60703ed0fc6e90\nF art/sqlite370.jpg d512473dae7e378a67e28ff96a34da7cb331def2\nF autoconf/INSTALL 83e4a25da9fd053c7b3665eaaaf7919707915903\nF autoconf/Makefile.am e14b629addaa1ce372b72043f28f40de2e32b7e211b6e0fc18dbb87989197e40\nF autoconf/Makefile.fallback 22fe523eb36dfce31e0f6349f782eb084e86a5620b2b0b4f84a2d6133f53f5ac\nF autoconf/Makefile.msc 492ea431c411378094593a5225b9a02645455a5d87a26d018b5461b723e52125\nF autoconf/README.first 6c4f34fe115ff55d4e8dbfa3cecf04a0188292f7\nF autoconf/README.txt 4f04b0819303aabaa35fff5f7b257fb0c1ef95f1\nF autoconf/configure.ac 308de24343e76ecfbe9a67f8fcd4c5216b790d230c5d9ce10210b7d5965d6192\nF autoconf/tea/Makefile.in b438a7020446c8a8156e8d97c8914a04833da6fd\nF autoconf/tea/README 3e9a3c060f29a44344ab50aec506f4db903fb873\nF autoconf/tea/aclocal.m4 52c47aac44ce0ddb1f918b6993e8beb8eee88f43\nF autoconf/tea/configure.ac 8aa16e3f0a5ca7959d4af198f46934ec187d395f\nF autoconf/tea/doc/sqlite3.n e1fe45d4f5286ee3d0ccc877aca2a0def488e9bb\nF autoconf/tea/license.terms 13bd403c9610fd2b76ece0ab50c4c5eda933d523\nF autoconf/tea/pkgIndex.tcl.in 3ef61715cf1c7bdcff56947ffadb26bc991ca39d\nF autoconf/tea/tclconfig/install-sh bdd5e293591621ae60d9824d86a4b1c5f22c3d00\nF autoconf/tea/tclconfig/tcl.m4 66ddf0a5d5e4b1d29bff472c0985fd7fa89d0fb5\nF autoconf/tea/win/makefile.vc f89d0184d0eee5f7e356ea407964dcd139939928\nF autoconf/tea/win/nmakehlp.c 247538ad8e8c508f33c03ec1fbd67d3a07ef6291\nF autoconf/tea/win/rules.vc c511f222b80064096b705dbeb97060ee1d6b6d63\nF config.guess 883205ddf25b46f10c181818bf42c09da9888884af96f79e1719264345053bd6\nF config.h.in 6376abec766e9a0785178b1823b5a587e9f1ccbc\nF config.sub c2d0260f17f3e4bc0b6808fccf1b291cb5e9126c14fc5890efc77b9fd0175559\nF configure fdc9f8d53360170679349d8f72fb2e5c79f511424891b7bb8a2f48de41c7a6ef x\nF configure.ac 3552d3aecade98a9d4b64bceb48ffb7726cbc85902efde956812942f060fbd0a\nF contrib/sqlitecon.tcl 210a913ad63f9f991070821e599d600bd913e0ad\nF doc/F2FS.txt c1d4a0ae9711cfe0e1d8b019d154f1c29e0d3abfe820787ba1e9ed7691160fcd\nF doc/lemon.html 24956ab2995e55fe171e55bdd04f22b553957dc8bb43501dbb9311e30187e0d3\nF doc/pager-invariants.txt 27fed9a70ddad2088750c4a2b493b63853da2710\nF doc/vfs-shm.txt e101f27ea02a8387ce46a05be2b1a902a021d37a\nF ext/README.md fd5f78013b0a2bc6f0067afb19e6ad040e89a10179b4f6f03eee58fac5f169bd\nF ext/async/README.txt e12275968f6fde133a80e04387d0e839b0c51f91\nF ext/async/sqlite3async.c 0f3070cc3f5ede78f2b9361fb3b629ce200d7d74\nF ext/async/sqlite3async.h f489b080af7e72aec0e1ee6f1d98ab6cf2e4dcef\nF ext/expert/README.md b321c2762bb93c18ea102d5a5f7753a4b8bac646cb392b3b437f633caf2020c3\nF ext/expert/expert.c d548d603a4cc9e61f446cc179c120c6713511c413f82a4a32b1e1e69d3f086a4\nF ext/expert/expert1.test e2afc53a27610e8251e44c7f961806607a5490ff204b3db342740d558e052662\nF ext/expert/sqlite3expert.c 3da865f2286433588260f41e796422c611bceaca3a0bbf9139a619cf7d062c19\nF ext/expert/sqlite3expert.h ca81efc2679a92373a13a3e76a6138d0310e32be53d6c3bfaedabd158ea8969b\nF ext/expert/test_expert.c d56c194b769bdc90cf829a14c9ecbc1edca9c850b837a4d0b13be14095c32a72\nF ext/fts1/README.txt 20ac73b006a70bcfd80069bdaf59214b6cf1db5e\nF ext/fts1/ft_hash.c 3927bd880e65329bdc6f506555b228b28924921b\nF ext/fts1/ft_hash.h 06df7bba40dadd19597aa400a875dbc2fed705ea\nF ext/fts1/fts1.c a39f7d21c2994d27c959ef9c3505c81542c81432\nF ext/fts1/fts1.h 6060b8f62c1d925ea8356cb1a6598073eb9159a6\nF ext/fts1/fts1_hash.c 3196cee866edbebb1c0521e21672e6d599965114\nF ext/fts1/fts1_hash.h e7f0d761353996a8175eda351104acfde23afcb0\nF ext/fts1/fts1_porter.c b1c7304b8988ba3f764a147cdd32043b4913ea7b\nF ext/fts1/fts1_tokenizer.h fdea722c38a9f82ed921642981234f666e47919c\nF ext/fts1/fts1_tokenizer1.c fd00d1fe4dc30dfc5c64cba695ce34f4af20d2fa\nF ext/fts1/fulltext.c 37698e1909584f6d8ea67d1485e3ad39dbf42d19\nF ext/fts1/fulltext.h 08525a47852d1d62a0be81d3fc3fe2d23b094efd\nF ext/fts1/simple_tokenizer.c bbfa4e3b2a26ef17d4edc6d98cd4a3f5396d998a\nF ext/fts1/tokenizer.h 0c53421b832366d20d720d21ea3e1f6e66a36ef9\nF ext/fts2/README.tokenizers 21e3684ea5a095b55d70f6878b4ce6af5932dfb7\nF ext/fts2/README.txt 8c18f41574404623b76917b9da66fcb0ab38328d\nF ext/fts2/fts2.c 72c816a9ae448049fbbe8f18a85698765fc7956c\nF ext/fts2/fts2.h da5f76c65163301d1068a971fd32f4119e3c95fa\nF ext/fts2/fts2_hash.c 011a1d32de45bb1b519a1fd0048e857d6a843558\nF ext/fts2/fts2_hash.h 1824b99dfd8d0225facbdb26a2c87289b2e7dcf8\nF ext/fts2/fts2_icu.c 51c5cd3c04954badd329fa738c95fcdb717b5188\nF ext/fts2/fts2_porter.c 2cd4a507bf3c3085fe66f59b0f2a325f65aaacf5\nF ext/fts2/fts2_tokenizer.c b529493d55e55497213c37e1f31680a77746be26\nF ext/fts2/fts2_tokenizer.h 27a1a99ca2d615cf7e142839b8d79e8751b4529e\nF ext/fts2/fts2_tokenizer1.c 07e223eecb483d448313b5f1553a4f299a7fb7a1\nF ext/fts2/mkfts2amal.tcl 974d5d438cb3f7c4a652639262f82418c1e4cff0\nF ext/fts3/README.content fdc666a70d5257a64fee209f97cf89e0e6e32b51\nF ext/fts3/README.syntax a19711dc5458c20734b8e485e75fb1981ec2427a\nF ext/fts3/README.tokenizers b92bdeb8b46503f0dd301d364efc5ef59ef9fa8e2758b8e742f39fa93a2e422d\nF ext/fts3/README.txt 8c18f41574404623b76917b9da66fcb0ab38328d\nF ext/fts3/fts3.c a05938725571651cc9bedc63a52ede4b39277fec17884c8ff6011dab2ff78c75\nF ext/fts3/fts3.h 3a10a0af180d502cecc50df77b1b22df142817fe\nF ext/fts3/fts3Int.h f091030b976045e7df91af2337935952b477cdbd9f48058c44c965684484cb50\nF ext/fts3/fts3_aux.c 96708c8b3a7d9b8ca1b68ea2b7e503e283f20e95f145becadedfad096dbd0f34\nF ext/fts3/fts3_expr.c b132af223e90e35b9f9efa9fe63d6ae737d34153a3b6066736086df8abc78a1f\nF ext/fts3/fts3_hash.c 8b6e31bfb0844c27dc6092c2620bdb1fca17ed613072db057d96952c6bdb48b7\nF ext/fts3/fts3_hash.h 39cf6874dc239d6b4e30479b1975fe5b22a3caaf\nF ext/fts3/fts3_icu.c 305ce7fb6036484085b5556a9c8e62acdc7763f0f4cdf5fd538212a9f3720116\nF ext/fts3/fts3_porter.c 3565faf04b626cddf85f03825e86056a4562c009\nF ext/fts3/fts3_snippet.c d62e40baa6a200586c3a425478109418f44926b1c318c870b59a4286afbe2795\nF ext/fts3/fts3_term.c f45a1e7c6ef464abb1231245d123dae12266b69e05cc56e14045b76591ae92d1\nF ext/fts3/fts3_test.c 73b16e229e517c1b1f0fb8e1046182a4e5dbc8dbe6eea8a5d4353fcce7dbbf39\nF ext/fts3/fts3_tokenize_vtab.c 1de9a61acfa2a0445ed989310c31839c57f6b6086dd9d5c97177ae734a17fd8b\nF ext/fts3/fts3_tokenizer.c a1ca0ab7c9c688ccb1d605645809f74f5df2bf4ca568e4bb37fb51113fd78e45\nF ext/fts3/fts3_tokenizer.h 64c6ef6c5272c51ebe60fc607a896e84288fcbc3\nF ext/fts3/fts3_tokenizer1.c 5c98225a53705e5ee34824087478cf477bdb7004\nF ext/fts3/fts3_unicode.c 4b9af6151c29b35ed09574937083cece7c31e911f69615e168a39677569b684d\nF ext/fts3/fts3_unicode2.c 416eb7e1e81142703520d284b768ca2751d40e31fa912cae24ba74860532bf0f\nF ext/fts3/fts3_write.c 51e0a4e3782ee17b6dd5e89949b7095fc98e36e87725c53de631734535507498\nF ext/fts3/fts3speed.tcl b54caf6a18d38174f1a6e84219950d85e98bb1e9\nF ext/fts3/mkfts3amal.tcl 252ecb7fe6467854f2aa237bf2c390b74e71f100\nF ext/fts3/tool/fts3cov.sh c331d006359456cf6f8f953e37f2b9c7d568f3863f00bb5f7eb87fea4ac01b73\nF ext/fts3/tool/fts3view.c 202801a2056995b763864d60c2dee744d46f1677\nF ext/fts3/unicode/CaseFolding.txt 8c678ca52ecc95e16bc7afc2dbf6fc9ffa05db8c\nF ext/fts3/unicode/UnicodeData.txt cd07314edb62d49fde34debdaf92fa2aa69011e7\nF ext/fts3/unicode/mkunicode.tcl bf7fcaa6d68e6d38223467983785d054f1cff4d9e3905dd51f6ed8801bb590d5\nF ext/fts3/unicode/parseunicode.tcl a981bd6466d12dd17967515801c3ff23f74a281be1a03cf1e6f52a6959fc77eb\nF ext/fts5/extract_api_docs.tcl a36e54ec777172ddd3f9a88daf593b00848368e0\nF ext/fts5/fts5.h c132a9323f22a972c4c93a8d5a3d901113a6e612faf30ca8e695788438c5ca2a\nF ext/fts5/fts5Int.h d7cbc214ee167496f70905667e18f73ea0402f7ef09236ce305e117e0efc866a\nF ext/fts5/fts5_aux.c dcc627d8b6e3fc773db528ff67b39955dab7b51628f9dba8e15849e5bedfd7fa\nF ext/fts5/fts5_buffer.c 5a5fe0159752c0fb0a5a93c722e9db2662822709490769d482b76a6dc8aaca70\nF ext/fts5/fts5_config.c b447948f35ad3354e8fe5e242e0a7e7b5b941555400b9404259944e3aa570037\nF ext/fts5/fts5_expr.c 2be456484786333d559dc2987a00f2750981fab91d52db8452a8046278c5f22e\nF ext/fts5/fts5_hash.c 1cc0095646f5f3b46721aa112fb4f9bf29ae175cb5338f89dcec66ed97acfe75\nF ext/fts5/fts5_index.c 99b77ae1f503978ca76985bcfff7345c822aed8bbaa8edb3747f804f614685b5\nF ext/fts5/fts5_main.c 9db1f173d299466aeff89bd949fb1eb0a181265726fb56f11e07ea292dcc9a73\nF ext/fts5/fts5_storage.c 167e3d8f8052a71032d498e32a2f2ed5ffe489e5d4d47e298adfa02ed55c7882\nF ext/fts5/fts5_tcl.c 39bcbae507f594aad778172fa914cad0f585bf92fd3b078c686e249282db0d95\nF ext/fts5/fts5_test_mi.c 08c11ec968148d4cb4119d96d819f8c1f329812c568bac3684f5464be177d3ee\nF ext/fts5/fts5_test_tok.c f96c6e193c466711d6d7828d5f190407fe7ab897062d371426dd3036f01258e7\nF ext/fts5/fts5_tokenize.c 2e508c6a3bd8ee56c48e98a38052e1a650e49b32a484cce9b189984114bc3b88\nF ext/fts5/fts5_unicode2.c 8bd0cd07396b74c1a05590e4070d635bccfc849812c305619f109e6c0485e250\nF ext/fts5/fts5_varint.c e64d2113f6e1bfee0032972cffc1207b77af63319746951bf1d09885d1dadf80\nF ext/fts5/fts5_vocab.c c3f12188570abb423303cd193b16dd19ba54e21c2e930e9b748d743de3b385f5\nF ext/fts5/fts5parse.y eb526940f892ade5693f22ffd6c4f2702543a9059942772526eac1fde256bb05\nF ext/fts5/mkportersteps.tcl 5acf962d2e0074f701620bb5308155fa1e4a63ba\nF ext/fts5/test/fts5_common.tcl b01c584144b5064f30e6c648145a2dd6bc440841\nF ext/fts5/test/fts5aa.test 5bd43427b7d08ce2e19c488a26534be450538b9232d4d5305049e8de236e9aa9\nF ext/fts5/test/fts5ab.test 9205c839332c908aaad2b01ab8670ece8b161e8f2ec8a9fabf18ca9385880bb7\nF ext/fts5/test/fts5ac.test a7aa7e1fefc6e1918aa4d3111d5c44a09177168e962c5fd2cca9620de8a7ed6d\nF ext/fts5/test/fts5ad.test e8cf959dfcd57c8e46d6f5f25665686f3b6627130a9a981371dafdf6482790de\nF ext/fts5/test/fts5ae.test 1142d16d9cc193894dc13cc8f9c7a8a21411ac61b5567a878514df6f9f0d7bb7\nF ext/fts5/test/fts5af.test 724247405b13f8f06cc6ce464dc4f152dc5dd4e86b12c2099685d8f19747bf7b\nF ext/fts5/test/fts5ag.test 7816f25a0707578f08145ab539fc0ca025f8951e788b28a6a18a06b2099469dd\nF ext/fts5/test/fts5ah.test 27b5a33bfd0363ca8a4dc659e6e2a5df3dea1c3c5b04bc51ca6aeb1277bd9b21\nF ext/fts5/test/fts5ai.test bc97e4758cc93e06bf851d61c98fdf4e8b8f8315ee28a84fb15f916360856414\nF ext/fts5/test/fts5aj.test 745020852d85f5dd49d11cb7ad11d3cc6dafc4fe6d6d24bc0875ac8f43ee4149\nF ext/fts5/test/fts5ak.test fc3595f8e6873bb86d70c9bd4b67d0413ce577bd4793c39a2b60a7b8825b60a6\nF ext/fts5/test/fts5al.test 00c4c1c6a1366b73aa48ce2068c634520867c3cf7f5d1676ebbb775ee1f35734\nF ext/fts5/test/fts5alter.test 5565f7e4605512b69171ac18ca84398603f9f6456dbe377beeca97e83cc242cd\nF ext/fts5/test/fts5auto.test 78989e6527ce69c9eddbef7392fea5c10b0010cd2b2ae68eec7bc869c471e691\nF ext/fts5/test/fts5aux.test ebf6f2ff7cb556e83f66991b7f12bff016d3c83d4eab36704b649dd6b1437318\nF ext/fts5/test/fts5auxdata.test eacc97ff04892f1a5f3d4df5a73f8bcbc3955ea1d12c9f24137eb1fc079e7611\nF ext/fts5/test/fts5bigpl.test 6466c89b38439f0aba26ac09e232a6b963f29b1cbe1304f6a664fe1e7a8f5fd3\nF ext/fts5/test/fts5bigtok.test 541119e616c637caea925a8c028c37c2c29e94383e00aa2f9198d530724b6e36\nF ext/fts5/test/fts5cat.test daba0b80659460b0cb60bd1f40b402478a761fe7ea414c3c94c2be25568cc33a\nF ext/fts5/test/fts5circref.test f880dfd0d99f6fb73b88ccacb0927d18e833672fd906cc47d6b4e529419eaa62\nF ext/fts5/test/fts5colset.test a30473451321bbf0b6218af62e96b4ae5fa99931cfdb210b5ecc804623b30f75\nF ext/fts5/test/fts5columnsize.test 45459ce4dd9fd853b6044cdc9674921bff89e3d840f348ca8c1630f9edbf5482\nF ext/fts5/test/fts5config.test 60094712debc59286c59aef0e6cf511c37d866802776a825ce437d26afe0817f\nF ext/fts5/test/fts5conflict.test 655925678e630d3cdf145d18725a558971806416f453ac8410ca8c04d934238d\nF ext/fts5/test/fts5connect.test 08030168fc96fc278fa81f28654fb7e90566f33aff269c073e19b3ae9126b2f4\nF ext/fts5/test/fts5content.test 213506436fb2c87567b8e31f6d43ab30aab99354cec74ed679f22aad0cdbf283\nF ext/fts5/test/fts5corrupt.test 77ae6f41a7eba10620efb921cf7dbe218b0ef232b04519deb43581cb17a57ebe\nF ext/fts5/test/fts5corrupt2.test 7453752ba12ce91690c469a6449d412561cc604b1dec994e16ab132952e7805f\nF ext/fts5/test/fts5corrupt3.test 5aaa2f8b44a85246a2ea76db1695bde38a75802979f3961702afa8f322d331c8\nF ext/fts5/test/fts5corrupt4.test ea805c4d7c68b5f185b9db5d2060a7ae5875339738dd48203c92162f41e7ca91\nF ext/fts5/test/fts5delete.test cbf87e3b8867c4d5cfcaed975c7475fd3f99d072bce2075fcedf43d1f82af775\nF ext/fts5/test/fts5detail.test 31b240dbf6d44ac3507e2f8b65f29fdc12465ffd531212378c7ce1066766f54e\nF ext/fts5/test/fts5determin.test 1b77879b2ae818b5b71c859e534ee334dac088b7cf3ff3bf76a2c82b1c788d11\nF ext/fts5/test/fts5dlidx.test b90852c55881b29dbac6380b274de27beae623ac4b6d567c6c8fb9cdc315a86e\nF ext/fts5/test/fts5doclist.test e39a6001495f1dc68e20323586ac965787986c2bf6f515b9b0285627b089d9e6\nF ext/fts5/test/fts5ea.test b01e3a18cdfabbff8104a96a5242a06a68a998a0\nF ext/fts5/test/fts5eb.test 239bb2f02571f8cccfc7018d08f502df1cd8cc6a69b65ed1dde5f6a070e3f669\nF ext/fts5/test/fts5fault1.test d28a65caee75db6897c3cf1358c5230d3bb2a3bf7fb31062c19c7e5382b3d2bd\nF ext/fts5/test/fts5fault2.test 69c8fdbef830cd0d450908d4504d5bb86609e255af99c421c20a0756251fe344\nF ext/fts5/test/fts5fault3.test da2f9e3e56ff5740d68ebdd6877c97089e7ed28ddff28a0da87a6afea27e5522\nF ext/fts5/test/fts5fault4.test 1c1db5fcfe59401e7833146100f1d8de284a0a686fac31ddac9fb56c459f725b\nF ext/fts5/test/fts5fault5.test a336e4e11847de24c9497f80cce18e00bb3fab7fb11f97d04eb9af898900a762\nF ext/fts5/test/fts5fault6.test a0fc0a8f99e4b16500c31dfc7e38e1defe0f1693ac47650517ac7b723b1956f8\nF ext/fts5/test/fts5fault7.test 0acbec416edb24b8881f154e99c31e9ccf73f539cfcd164090be139e9e97ed4c\nF ext/fts5/test/fts5fault8.test 318238659d35f82ad215ecb57ca4c87486ea85d45dbeedaee42f148ff5105ee2\nF ext/fts5/test/fts5fault9.test 098e6b894bbdf9b2192f994a30f4043673fb3f338b6b8ab1624c704422f39119\nF ext/fts5/test/fts5faultA.test be4487576bff8c22cee6597d1893b312f306504a8c6ccd3c53ca85af12290c8c\nF ext/fts5/test/fts5faultB.test d606bdb8e81aaeb6f41de3fc9fc7ae315733f0903fbff05cf54f5b045b729ab5\nF ext/fts5/test/fts5faultD.test cc5d1225556e356615e719c612e845d41bff7d5a\nF ext/fts5/test/fts5first.test 3fcf2365c00a15fc9704233674789a3b95131d12de18a9b996159f6909dc8079\nF ext/fts5/test/fts5full.test e1701a112354e0ff9a1fdffb0c940c576530c33732ee20ac5e8361777070d717\nF ext/fts5/test/fts5fuzz1.test 238d8c45f3b81342aa384de3e581ff2fa330bf922a7b69e484bbc06051a1080e\nF ext/fts5/test/fts5hash.test a4cf51acad99bfc43c16fb74f9d22495dc221ae0701fc5e908ca963a9b26a02b\nF ext/fts5/test/fts5integrity.test 4317561cd25eca7df16aa1f7d1a700ee958059fa639785f94aba0a84df9ab17b\nF ext/fts5/test/fts5interrupt.test 09613247b273a99889808ef852898177e671406fe71fdde7ea00e78ea283d227\nF ext/fts5/test/fts5lastrowid.test be98fe3e03235296585b72daad7aed5717ba0062bae5e5c18dd6e04e194c6b28\nF ext/fts5/test/fts5leftjoin.test c0b4cafb9661379e576dc4405c0891d8fcc2782680740513c4d1fc114b43d4ad\nF ext/fts5/test/fts5matchinfo.test 50d86da66ec5b27603dcd90ba0227f5d9deb10351cbc52974a88e24f6fc9b076\nF ext/fts5/test/fts5merge.test e92a8db28b45931e7a9c7b1bbd36101692759d00274df74d83fd29d25d53b3a6\nF ext/fts5/test/fts5merge2.test 3ebad1a59d6ad3fb66eff6523a09e95dc6367cbefb3cd73196801dea0425c8e2\nF ext/fts5/test/fts5misc.test a5b53328b5b79275915de8f67ae85905eb2133d8dbcc808411f67c094b1bd347\nF ext/fts5/test/fts5multi.test a15bc91cdb717492e6e1b66fec1c356cb57386b980c7ba5af1915f97fe878581\nF ext/fts5/test/fts5multiclient.test 5ff811c028d6108045ffef737f1e9f05028af2458e456c0937c1d1b8dea56d45\nF ext/fts5/test/fts5near.test 211477940142d733ac04fad97cb24095513ab2507073a99c2765c3ddd2ef58bd\nF ext/fts5/test/fts5onepass.test f9b7d9b2c334900c6542a869760290e2ab5382af8fbd618834bf1fcc3e7b84da\nF ext/fts5/test/fts5optimize.test 36a752d24c818792032e4ff502936fc9cc5ef938721696396fdc79214b2717f1\nF ext/fts5/test/fts5phrase.test 13e5d8e9083077b3d9c74315b3c92ec723cc6eb37c8155e0bfe1bba00559f07b\nF ext/fts5/test/fts5plan.test 771b999d161e24fd803ce0290adb7c6e7c9b9cc2c6a0adb344813fb89473aa32\nF ext/fts5/test/fts5porter.test 8d08010c28527db66bc3feebd2b8767504aaeb9b101a986342fa7833d49d0d15\nF ext/fts5/test/fts5porter2.test 0d251a673f02fa13ca7f011654873b3add20745f7402f108600a23e52d8c7457\nF ext/fts5/test/fts5prefix.test a0fa67b06650f2deaa7bf27745899d94e0fb547ad9ecbd08bfad98c04912c056\nF ext/fts5/test/fts5query.test ac363b17a442620bb0780e93c24f16a5f963dfe2f23dc85647b869efcfada728\nF ext/fts5/test/fts5rank.test c9fd4a1e36b4fa92d572ec13d846469b97da249d1c2f7fd3ee7e017ce46f2416\nF ext/fts5/test/fts5rebuild.test 55d6f17715cddbf825680dd6551efbc72ed916d8cf1cde40a46fc5d785b451e7\nF ext/fts5/test/fts5restart.test 835ecc8f449e3919f72509ab58056d0cedca40d1fe04108ccf8ac4c2ba41f415\nF ext/fts5/test/fts5rowid.test b8790ec170a8dc1942a15aef3db926a5f3061b1ff171013003d8297203a20ad6\nF ext/fts5/test/fts5simple.test a298670508c1458b88ce6030440f26a30673931884eb5f4094ac1773b3ba217b\nF ext/fts5/test/fts5simple2.test 258a1b0c590409bfa5271e872c79572b319d2a56554d0585f68f146a0da603f0\nF ext/fts5/test/fts5simple3.test d5c74a9d3ca71bd5dd5cacb7c55b86ea12cdddfc8b1910e3de2995206898380f\nF ext/fts5/test/fts5synonym.test 1651815b8008de170e8e600dcacc17521d765482ea8f074ae82cfa870d8bb7fb\nF ext/fts5/test/fts5synonym2.test b54cce5c34ec08ed616f646635538ae82e34a0e28f947ec60b6fadbc4b3fb17a\nF ext/fts5/test/fts5tok1.test ce6551e41ff56f30b69963577324624733bed0d1753589f06120d664d9cd45c9\nF ext/fts5/test/fts5tok2.test dcacb32d4a2a3f0dd3215d4a3987f78ae4be21a2\nF ext/fts5/test/fts5tokenizer.test ac3c9112b263a639fb0508ae73a3ee886bf4866d2153771a8e8a20c721305a43\nF ext/fts5/test/fts5umlaut.test a42fe2fe6387c40c49ab27ccbd070e1ae38e07f38d05926482cc0bccac9ad602\nF ext/fts5/test/fts5unicode.test 17056f4efe6b0a5d4f41fdf7a7dc9af2873004562eaa899d40633b93dc95f5a9\nF ext/fts5/test/fts5unicode2.test 9b3df486de05fb4bde4aa7ee8de2e6dae1df6eb90e3f2e242c9383b95d314e3e\nF ext/fts5/test/fts5unicode3.test 590c72e18195bda2446133f9d82d04a4e89d094bba58c75ae10f4afc6faa0744\nF ext/fts5/test/fts5unicode4.test 6463301d669f963c83988017aa354108be0b947d325aef58d3abddf27147b687\nF ext/fts5/test/fts5unindexed.test 9021af86a0fb9fc616f7a69a996db0116e7936d0db63892db6bafabbec21af4d\nF ext/fts5/test/fts5update.test b8affd796e45c94a4d19ad5c26606ea06065a0f162a9562d9f005b5a80ccf0bc\nF ext/fts5/test/fts5version.test c8f2cc105f0abf0224965f93e584633dee3e06c91478bc67e468f7cfdf97fd6a\nF ext/fts5/test/fts5vocab.test 648fb2fe86b55e08295e34504704718d92fba3e2cf3e1f5d72fa3682df4cd0f0\nF ext/fts5/test/fts5vocab2.test e0fdc3a3095f6eda68ac9bf9a443ff929a124d46f00af19933604085712e9d47\nF ext/fts5/tool/fts5speed.tcl b0056f91a55b2d1a3684ec05729de92b042e2f85\nF ext/fts5/tool/fts5txt2db.tcl 526a9979c963f1c54fd50976a05a502e533a4c59\nF ext/fts5/tool/loadfts5.tcl 95b03429ee6b138645703c6ca192c3ac96eaf093\nF ext/fts5/tool/mkfts5c.tcl d1c2a9ab8e0ec690a52316f33dd9b1d379942f45\nF ext/fts5/tool/showfts5.tcl d54da0e067306663e2d5d523965ca487698e722c\nF ext/icu/README.txt a295e91db742b153e8dce8f7efd31d28ad1eea4df31ef4daa3eedc85be2f5138\nF ext/icu/icu.c c2c7592574c08cd1270d909b8fb8797f6ea1f49e931e71dbcc25506b9b224580\nF ext/icu/sqliteicu.h 728867a802baa5a96de7495e9689a8e01715ef37\nF ext/lsm1/Makefile a553b728bba6c11201b795188c5708915cc4290f02b7df6ba7e8c4c943fd5cd9\nF ext/lsm1/Makefile.msc f8c878b467232226de288da320e1ac71c131f5ec91e08b21f502303347260013\nF ext/lsm1/lsm-test/README 87ea529d2abe615e856d4714bfe8bb185e6c2771b8612aa6298588b7b43e6f86\nF ext/lsm1/lsm-test/lsmtest.h cf58528ffe0cfe535e91b44584e2ec5fb1caacdabecef0d8dcf83bf83168bf28\nF ext/lsm1/lsm-test/lsmtest1.c ae6ba48a0851b39be69a7d0eb220bfb9521a526e926223d5014bd385df10abb3\nF ext/lsm1/lsm-test/lsmtest2.c 188b09aec776516aeedcfd13b9c6faf85ba16b3671a0897a2c740ee00a5dc4f8\nF ext/lsm1/lsm-test/lsmtest3.c 9ab87528a36dbf4a61d7c8ad954f5ee368c0878c127b84b942b2e2abe522de26\nF ext/lsm1/lsm-test/lsmtest4.c d258d6a245db5d8eaede096e2368d23f859c5e92c80ab9122463f708514fe10c\nF ext/lsm1/lsm-test/lsmtest5.c 8d5242a0f870d65eeada191c8945781fed9cb8ece3886573790ebd373b62dac5\nF ext/lsm1/lsm-test/lsmtest6.c 869cb4a172cd07d1a75b3aeaecd61d0a477787b3b8668bad0d3ff0f43b642b7c\nF ext/lsm1/lsm-test/lsmtest7.c 7a917455a0f956a8ed3f44f5c9387ec0ea6627714874464cc3fa5c5a9cabb2f2\nF ext/lsm1/lsm-test/lsmtest8.c 589b68c44531a0f04d5e879bb1e211be5f7100f48eed7e8631e07ed5cbd68f94\nF ext/lsm1/lsm-test/lsmtest9.c dd1a0ebf41134933a744d1e00e60429a2a21fc50d587ae7dd6bdb6e96d805bdc\nF ext/lsm1/lsm-test/lsmtest_bt.c d70d9a9be5eef9360af1251dd083948d74fd30137a08f61bef995f7ac04e037f\nF ext/lsm1/lsm-test/lsmtest_datasource.c 5d770be191d0ca51315926723009b2c25c0b4b8136840494ef710ac324aa916c\nF ext/lsm1/lsm-test/lsmtest_func.c 159aa401bc8032bfa3d8cf2977bd687abebab880255895a5eb45770d626fa38d\nF ext/lsm1/lsm-test/lsmtest_io.c cf11b27b129c6bd5818fa1d440176502dc27229f0db892b4479118d61993ea20\nF ext/lsm1/lsm-test/lsmtest_main.c a9bc647738c0dcaebf205d6d194b3ce4a6ef3925801cd2d919f0a4ea33a15aeb\nF ext/lsm1/lsm-test/lsmtest_mem.c 4e63c764345ab1df59d4f13a77980c6f3643798210b10d6cdbd785b4b888fda5\nF ext/lsm1/lsm-test/lsmtest_tdb.c 618a8619183fda4f5540fcde15f9068293c5e3180e1a246e34409b0c148758b3\nF ext/lsm1/lsm-test/lsmtest_tdb.h 8733eee249b12956a9df8322994b43d19bd8c02ad2e8b0bb5164db4d6ccc1735\nF ext/lsm1/lsm-test/lsmtest_tdb2.cc 99ea7f2dd9c7536c8fb9bdd329e4cfeb76899f3ddf6f48bdd3926e016922b715\nF ext/lsm1/lsm-test/lsmtest_tdb3.c 7a7ccae189f5bb25bcd1ec3bbd740529706eded7f6729a5a0a9eeaeb57785320\nF ext/lsm1/lsm-test/lsmtest_tdb4.c 47e8bb5eba266472d690fb8264f1855ebdba0ae5a0e541e35fcda61ebf1d277f\nF ext/lsm1/lsm-test/lsmtest_util.c 241622db5a332a09c8e6e7606b617d288a37b557f7d3bce0bb97809f67cc2806\nF ext/lsm1/lsm-test/lsmtest_win32.c 0e0a224674c4d3170631c41b026b56c7e1672b151f5261e1b4cc19068641da2d\nF ext/lsm1/lsm.h 0f6f64ff071471cb87bf98beb8386566f30ea001\nF ext/lsm1/lsmInt.h 5983690e05e83653cc01ba9d8fbf8455e534ddf8349ed9adedbf46a7549760b0\nF ext/lsm1/lsm_ckpt.c 0eabfaf812ddb4ea43add38f05e430694cd054eb622c3e35af4c43118a2d5321\nF ext/lsm1/lsm_file.c 3c51841d5b3e7da162693cbac9a9f47eeedf6bcbbe2969a4d25e30c428c9fe36\nF ext/lsm1/lsm_log.c a8bf334532109bba05b09a504ee45fc393828b0d034ca61ab45e3940709d9a7c\nF ext/lsm1/lsm_main.c b5703f8042e71d3a2d65e671f6832e077e79e89e9975818f67f969922618db63\nF ext/lsm1/lsm_mem.c 4c51ea9fa285ee6e35301b33491642d071740a0a\nF ext/lsm1/lsm_mutex.c 378edf0a2b142b4f7640ee982df06d50b98788ea\nF ext/lsm1/lsm_shared.c 76adfc1ed9ffebaf92746dde4b370ccc48143ca8b05b563816eadd2aadf1c525\nF ext/lsm1/lsm_sorted.c 6f7d8cf7a7d3d3f1ab5d9ba6347e8f39f3d73c00ec48afcd0c4bcbefd806f9b8\nF ext/lsm1/lsm_str.c 65e361b488c87b10bf3e5c0070b14ffc602cf84f094880bece77bbf6678bca82\nF ext/lsm1/lsm_tree.c 682679d7ef2b8b6f2fe77aeb532c8d29695bca671c220b0abac77069de5fb9fb\nF ext/lsm1/lsm_unix.c 57361bcf5b1a1a028f5d66571ee490e9064d2cfb145a2cc9e5ddade467bb551b\nF ext/lsm1/lsm_varint.c 43f954af668a66c7928b81597c14d6ad4be9fedbc276bbd80f52fa28a02fdb62\nF ext/lsm1/lsm_vtab.c 169bfe7ef8e6c9de9c77e17c4c50c9ae55fb0167d80be3d1be82c991184b6f35\nF ext/lsm1/lsm_win32.c 0a4acbd7e8d136dd3a5753f0a9e7a9802263a9d96cef3278cf120bcaa724db7c\nF ext/lsm1/test/lsm1_common.tcl 5ed4bab07c93be2e4f300ebe46007ecf4b3e20bc5fbe1dedaf04a8774a6d8d82\nF ext/lsm1/test/lsm1_simple.test a04d08e8661ae6fc53786c67f0bd102c6692f003e859dde03ed9ac3f12e066e5\nF ext/lsm1/tool/mklsm1c.tcl f31561bbee5349f0a554d1ad7236ac1991fc09176626f529f6078e07335398b0\nF ext/misc/README.md d6dd0fe1d8af77040216798a6a2b0c46c73054d2f0ea544fbbcdccf6f238c240\nF ext/misc/amatch.c 50a9ef2d38dabfa371f8c1904097d493271e63d58ccb0e9b79a4fa4a94e66660\nF ext/misc/anycollseq.c 5ffdfde9829eeac52219136ad6aa7cd9a4edb3b15f4f2532de52f4a22525eddb\nF ext/misc/appendvfs.c 3777f22ec1057dc4e5fd89f2fbddcc7a29fbeef1ad038c736c54411bb1967af7\nF ext/misc/blobio.c a867c4c4617f6ec223a307ebfe0eabb45e0992f74dd47722b96f3e631c0edb2a\nF ext/misc/btreeinfo.c 4f0ebf278f46e68e6306c667917766cebc5550fd35d5de17847988e22892d4d2\nF ext/misc/carray.c 91e9a7f512fda934894bed30464552fffa7d3073b5be04189ae0bd0c59f26bfd\nF ext/misc/closure.c dbfd8543b2a017ae6b1a5843986b22ddf99ff126ec9634a2f4047cd14c85c243\nF ext/misc/completion.c cec672d40604075bb341a7f11ac48393efdcd90a979269b8fe7977ea62d0547f\nF ext/misc/compress.c dd4f8a6d0baccff3c694757db5b430f3bbd821d8686d1fc24df55cf9f035b189\nF ext/misc/csv.c 7f047aeb68f5802e7ce6639292095d622a488bb43526ed04810e0649faa71ceb\nF ext/misc/dbdata.c e316fba936571584e55abd5b974a32a191727a6b746053a0c9d439bd2cf93940\nF ext/misc/dbdump.c baf6e37447c9d6968417b1cd34cbedb0b0ab3f91b5329501d8a8d5be3287c336\nF ext/misc/eval.c 4b4757592d00fd32e44c7a067e6a0e4839c81a4d57abc4131ee7806d1be3104e\nF ext/misc/explain.c d5c12962d79913ef774b297006872af1fccda388f61a11d37758f9179a09551f\nF ext/misc/fileio.c 288e7230e0fe464d71b0694e2d8bdd3a353118ac2e31da3964b95f460f09915f\nF ext/misc/fossildelta.c 7708651072eb5620ab21bbfb518d184f27b2c29c0131b09b9a2d8852a8016430\nF ext/misc/fuzzer.c c4e27daf41433a64cad5265cd27dbcb891147e9994d0422200ce81ce9a54b625\nF ext/misc/ieee754.c f190d0cc5182529acb15babd177781be1ac1718c\nF ext/misc/json1.c 760107d0b97ab422952591b0d7519327dcb482954a7706ee387a54c135f8aabf\nF ext/misc/memstat.c 3017a0832c645c0f8c773435620d663855f04690172316bd127270d1a7523d4d\nF ext/misc/memtrace.c 7c0d115d2ef716ad0ba632c91e05bd119cb16c1aedf3bec9f06196ead2d5537b\nF ext/misc/memvfs.c ab36f49e02ebcdf85a1e08dc4d8599ea8f343e073ac9e0bca18a98b7e1ec9567\nF ext/misc/mmapwarm.c 8c5fe90d807a23e44a8b93e96e8b812b19b300d5fd8c1d40a4fd1d8224e33f46\nF ext/misc/nextchar.c 279f80fe8ef5ba413242e2704e246503ac601f005eefb180d19e6c920338a0ba\nF ext/misc/normalize.c b4290464f542bae7a97b43f15bd197949b833ffd668b7c313631bd5d4610212c\nF ext/misc/percentile.c 148dd07286b16e50f232bb638a47850085ad37d51f270429905bd865e595d1ca\nF ext/misc/prefixes.c 7be86d17525cfae6ed462fc3c519efc44488ac329890f77491c8f82871f57e17\nF ext/misc/regexp.c be064ad9478361e40c7b8ca460f78b3d3c9b96080d5f391126c95e14bd362fae\nF ext/misc/remember.c add730f0f7e7436cd15ea3fd6a90fd83c3f706ab44169f7f048438b7d6baa69c\nF ext/misc/rot13.c 540a169cb0d74f15522a8930b0cccdcb37a4fd071d219a5a083a319fc6e8db77\nF ext/misc/scrub.c db9fff56fed322ca587d73727c6021b11ae79ce3f31b389e1d82891d144f22ad\nF ext/misc/series.c 0c97f63378fddc9f425e82ba139b9aaf902211f24ced115c2b6ae12b425f7334\nF ext/misc/sha1.c d8125a88ee9023bc17d6f87ea8850db33f906d5701b30d4fd9bddb57f231e60a\nF ext/misc/shathree.c 22ba7ca84a433d6466a7d05dcc876910b435a715da8cc462517db9351412b8c8\nF ext/misc/showauth.c 732578f0fe4ce42d577e1c86dc89dd14a006ab52\nF ext/misc/spellfix.c f88ecb2c0294453ce8b7704b211f5350c41b085b38c8e056852e3a08b0f5e484\nF ext/misc/sqlar.c 57d5bc45cd5492208e451f697404be88f8612527d64c9d42f96b325b64983d74\nF ext/misc/stmt.c 8a8dc4675042e4551e4afe99b8d0cc7a4a2fc1a8dacc0a9ce1b1bbff145da93d\nF ext/misc/templatevtab.c 8a16a91a5ceaccfcbd6aaaa56d46828806e460dd194965b3f77bf38f14b942c4\nF ext/misc/totype.c 5b6b1eafaa993e29f8df843319b3292b029f1b5cbbbf11c8a88e05d3f714159f\nF ext/misc/unionvtab.c 36237f0607ca954ac13a4a0e2d2ac40c33bc6e032a5f55f431713061ef1625f9\nF ext/misc/uuid.c db4db81e8c6a92ad6176ebd9f81dcb6870e331e1a286d0452f4319e3ba3df812\nF ext/misc/vfslog.c 3b25c2f56ba60788db247287be6ab024b53c4afffd412b4876db563389be0d35\nF ext/misc/vfsstat.c 77b5b4235c9f7f11eddf82487c0a422944ac2f132dafd5af3be7a68a057b1cdb\nF ext/misc/vtablog.c 5538acd0c8ddaae372331bee11608d76973436b77d6a91e8635cfc9432fba5ae\nF ext/misc/vtshim.c 1976e6dd68dd0d64508c91a6dfab8e75f8aaf6cd\nF ext/misc/wholenumber.c 784b12543d60702ebdd47da936e278aa03076212\nF ext/misc/zipfile.c 8f965eb309da3ae8c30088f6c3ebdddcdbdf9e0ef24f3bc7ae0756deb93da503\nF ext/misc/zorder.c b0ff58fa643afa1d846786d51ea8d5c4b6b35aa0254ab5a82617db92f3adda64\nF ext/rbu/rbu.c 8681f6157db6adc82c34af24b14ea8a3be0146ad2a3b6c1d5da6cb8a5796c8ce\nF ext/rbu/rbu1.test 221d9c18a5e600ac9ac6b1810d99d9f99163a7909ba61597876ab6e4d4beb3d6\nF ext/rbu/rbu10.test 0a201c32202143f23c81c0144503da339786fc20acb7a2fda11601b65659f314\nF ext/rbu/rbu11.test 5c834cf491086b45e071eabf71f708febc143e86a384a92de69e0b1a4cace144\nF ext/rbu/rbu12.test 29f8b2118f6c96fac3755bd6d2b55c2db24f878b1f11fbfbe294f3a230a3dcdc\nF ext/rbu/rbu13.test 1285298e3360ec74511764841b3c174dcfe21da2f618c22febf1a20abd0365c2\nF ext/rbu/rbu14.test 4a7bf0b3a4516d3ab0bc0ba4ceb53eb7e3324147ccda152e561060f659dbba31\nF ext/rbu/rbu3.test d6c6cc7a1326e8e23b9820f30bd3054f22092e503fadfd2a660ae006653f6d80\nF ext/rbu/rbu5.test 724b38ea5f722e3d22dc76343860bd998bb676c3f78c4bc8175df5c5d7720e23\nF ext/rbu/rbu6.test 401064236d3cf86b7edc01c586d7c5554f48553946fbfa1a3af35d7e47dce9e3\nF ext/rbu/rbu7.test ae25f47b56f178197fc1098537a35a39176cc73d1629b03dc9d795929fc36ec2\nF ext/rbu/rbu8.test b98a6fc58ead84a0e6ddee775b9702cd981f318d5d4fd1d4df0fa0c40db7251b\nF ext/rbu/rbu9.test 0e4d985e25620d61920597e8ea69c871c9e8c1f5a0be2ae9fa70bb641d74378c\nF ext/rbu/rbuA.test b34a90cb495682c25b5fc03a9d5e7a4fc99541c29256f25e2e2a4f6542b4f5b3\nF ext/rbu/rbuB.test 52b07158824c6927b7e25554ace92a695cdebfc296ae3d308ac386984aded9bc\nF ext/rbu/rbuC.test 80f1cc2fb74f44b1128fd0ed8eedab3a76fefeb72a947860e2869ef76fc8dc6b\nF ext/rbu/rbu_common.tcl 60d904133ff843fe72cc0514e9dd2486707181e6e0fbab20979da28c48d21de9\nF ext/rbu/rbucollate.test cac528a9a46318cba42e61258bb42660bbbf4fdb9a8c863de5a54ad0c658d197\nF ext/rbu/rbucrash.test 000981a1fe8a6e4d9a684232f6a129e66a3ef595f5ed74655e2f9c68ffa613b4\nF ext/rbu/rbucrash2.test efa143cc94228eb0266d3f1abfbee60a5838a84cef7cc3fcb8c145b74d96fd41\nF ext/rbu/rbudiff.test 156957851136b63c143478518dc1bda6c832103cdbe8ac1d7cdd47edb3cbe0a3\nF ext/rbu/rbudor.test e3e8623926012f43eebe51fedf06a102df2640750d971596b052495f2536db20\nF ext/rbu/rbuexpr.test 10d0420537c3bc7666e576d72adeffe7e86cfbb00dcc30aa9ce096c042415190\nF ext/rbu/rbufault.test 2d7f567b79d558f6e093c58808cab4354f8a174e3802f69e7790a9689b3c09f8\nF ext/rbu/rbufault2.test c81327a3ac2c385b9b954db3644d4e0df93eeebfc3de9f1f29975a1e73fd3d0c\nF ext/rbu/rbufault3.test b2fcc9db5c982b869f67d1d4688d8cb515d5b92f58011fff95665f2e62cec179\nF ext/rbu/rbufault4.test 03d2849c3df7d7bd14a622e789ff049e5080edd34a79cd432e01204db2a5930a\nF ext/rbu/rbufts.test 0ae8d1da191c75bd776b86e24456db0fb6e97b7c944259fae5407ea55d23c31d\nF ext/rbu/rbumisc.test 329986cf5dd51890c4eb906c2f960ebb773a79a64bed90f506b7c417825b37eb\nF ext/rbu/rbumulti.test 5fb139058f37ddc5a113c5b93238de915b769b7792de41b44c983bc7c18cf5b9\nF ext/rbu/rbupartial.test f25df014b8dbe3c5345851fba6e66f79ab237f57dc201b2d5f0dbae658ae5a4c\nF ext/rbu/rbuprogress.test 857cf1f8166c83ef977edb9ef4fc42d80f71fbd798652b46ae2f3a7031870f8d\nF ext/rbu/rburesume.test dbdc4ca504e9c76375a69e5f0d91205db967dcc509a5166ca80231f8fda49eb1\nF ext/rbu/rbusave.test f4190a1a86fccf84f723af5c93813365ae33feda35845ba107b59683d1cdd926\nF ext/rbu/rbusplit.test b37e7b40b38760881dc9c854bd40b4744c6b6cd74990754eca3bda0f407051e8\nF ext/rbu/rbutemplimit.test 05ceefa90a2e26a99f40dd48282ed63a00df5e59c1f2bfd479c143e201a1b0ba\nF ext/rbu/rbuvacuum.test 55e101e90168c2b31df6c9638fe73dc7f7cc666b6142266d1563697d79f73534\nF ext/rbu/rbuvacuum2.test b8e5b51dc8b2c0153373d024c0936be3f66f9234acbd6d0baab0869d56b14e6b\nF ext/rbu/rbuvacuum3.test 8addd82e4b83b4c93fa47428eae4fd0dbf410f8512c186f38e348feb49ba03dc\nF ext/rbu/rbuvacuum4.test a78898e438a44803eb2bc897ba3323373c9f277418e2d6d76e90f2f1dbccfd10\nF ext/rbu/sqlite3rbu.c f3a3e09f575157052813be667d6ab3b54f47fb02e6e1c9f767ad7bb8f1fb90b3\nF ext/rbu/sqlite3rbu.h 1dc88ab7bd32d0f15890ea08d23476c4198d3da3056985403991f8c9cd389812\nF ext/rbu/test_rbu.c 03f6f177096a5f822d68d8e4069ad8907fe572c62ff2d19b141f59742821828a\nF ext/repair/README.md 92f5e8aae749a4dae14f02eea8e1bb42d4db2b6ce5e83dbcdd6b1446997e0c15\nF ext/repair/checkfreelist.c 0dbae18c1b552f58d64f8969e4fb1e7f11930c60a8c2a9a8d50b7f15bdfd54bd\nF ext/repair/checkindex.c 7d28c01a2e012ac64257d230fc452b2cafb78311a91a343633d01d95220f66f3\nF ext/repair/sqlite3_checker.c.in 4a5a3af3f450fe503e5a2985e98516dc2a6b9ad247449e284c1cf140fc91720f\nF ext/repair/sqlite3_checker.tcl a9a2caa9660567257c177a91124d8c0dccdfa341e25c51e6da7f1fd9e601eafa\nF ext/repair/test/README.md 34b2f542cf5be7bffe479242b33ee3492cea30711e447cc4a1a86cb5915f419e\nF ext/repair/test/checkfreelist01.test 3e8aa6aeb4007680c94a8d07b41c339aa635cc78249442da72ff3f8297398a69\nF ext/repair/test/checkindex01.test b530f141413b587c9eb78ff734de6bb79bc3515c335096108c12c01bddbadcec\nF ext/repair/test/test.tcl 686d76d888dffd021f64260abf29a55c57b2cedfa7fc69150b42b1d6119aac3c\nF ext/rtree/README 6315c0d73ebf0ec40dedb5aa0e942bc8b54e3761\nF ext/rtree/geopoly.c c591164125808f8bba9659e92665b78412cd263e654b6f05294f3a8da7cdd9fb\nF ext/rtree/rtree.c 26fcb3f7a92fda9afcf5eee684cc3188b7367da69bc9c374492d844fb8ed4e25\nF ext/rtree/rtree.h 4a690463901cb5e6127cf05eb8e642f127012fd5003830dbc974eca5802d9412\nF ext/rtree/rtree1.test 4092a8bd2b5eafc4fafe4fe9024249c12b13e4bab23c2c3eaff57412fdf805fa\nF ext/rtree/rtree2.test 9d9deddbb16fd0c30c36e6b4fdc3ee3132d765567f0f9432ee71e1303d32603d\nF ext/rtree/rtree3.test 4ee5d7df86040efe3d8d84f141f2962a7745452200a7cba1db06f86d97050499\nF ext/rtree/rtree4.test 304de65d484540111b896827e4261815e5dca4ce28eeecd58be648cd73452c4b\nF ext/rtree/rtree5.test 49c9041d713d54560b315c2c7ef7207ee287eba1b20f8266968a06f2e55d3142\nF ext/rtree/rtree6.test 1252a0439da01d2f1f5cbbdeeb80455a2d68b9bae2a9787937b167a5e3957828\nF ext/rtree/rtree7.test c8fb2e555b128dd0f0bdb520c61380014f497f8a23c40f2e820acc9f9e4fdce5\nF ext/rtree/rtree8.test 2d99006a1386663978c9e1df167554671e4f711c419175b39f332719deb1ce0e\nF ext/rtree/rtree9.test c646f12c8c1c68ef015c6c043d86a0c42488e2e68ed1bb1b0771a7ca246cbabf\nF ext/rtree/rtreeA.test ed2f1be9c06dde0b1ab93a95dd9e87eeaa02db2d30bcb4b9179b69ee3dc3319b\nF ext/rtree/rtreeB.test 4cec297f8e5c588654bbf3c6ed0903f10612be8a2878055dd25faf8c71758bc9\nF ext/rtree/rtreeC.test 6aa87eba4d9a3003b941a1ba77db259c5cabc3fd92fc5a6360f5369520eb9a4d\nF ext/rtree/rtreeD.test fe46aa7f012e137bd58294409b16c0d43976c3bb92c8f710481e577c4a1100dc\nF ext/rtree/rtreeE.test e65d3fc625da1800b412fc8785817327d43ccfec5f5973912d8c9e471928caa9\nF ext/rtree/rtreeF.test 81ffa7ef51c4e4618d497a57328c265bf576990c7070633b623b23cd450ed331\nF ext/rtree/rtreeG.test 1b9ca6e3effb48f4161edaa463ddeaa8fca4b2526d084f9cbf5dbe4e0184939c\nF ext/rtree/rtreeH.test 0885151ee8429242625600ae47142cca935332c70a06737f35af53a7bd7aaf90\nF ext/rtree/rtreeI.test 608e77f7fde9be5a12eae316baef640fffaafcfa90a3d67443e78123e19c4ca4\nF ext/rtree/rtree_perf.tcl 6c18c1f23cd48e0f948930c98dfdd37dfccb5195\nF ext/rtree/rtree_util.tcl db734b4c5e75fed6acc56d9701f2235345acfdec750b5fc7b587936f5f6bceed\nF ext/rtree/rtreecheck.test d67d5b3e9e45bfa8cd90734e8e9302144ac415b8e9176c6f02d4f92892ee8a35\nF ext/rtree/rtreecirc.test aec664eb21ae943aeb344191407afff5d392d3ae9d12b9a112ced0d9c5de298e\nF ext/rtree/rtreeconnect.test 225ad3fcb483d36cbee423a25052a6bbae762c9576ae9268332360c68c170d3d\nF ext/rtree/rtreefuzz001.test eef1ed593bb15886cd5d5367a2f2492f81e315848896cdf7afb6e21454978827\nF ext/rtree/sqlite3rtree.h 03c8db3261e435fbddcfc961471795cbf12b24e03001d0015b2636b0f3881373\nF ext/rtree/tkt3363.test 142ab96eded44a3615ec79fba98c7bde7d0f96de\nF ext/rtree/util/randomshape.tcl 54ee03d0d4a1c621806f7f44d5b78d2db8fac26e0e8687c36c4bd0203b27dbff\nF ext/rtree/viewrtree.tcl eea6224b3553599ae665b239bd827e182b466024\nF ext/rtree/visual01.txt e9c2564083bcd30ec51b07f881bffbf0e12b50a3f6fced0c222c5c1d2f94ac66\nF ext/session/changeset.c 7a1e6a14c7e92d36ca177e92e88b5281acd709f3b726298dc34ec0fb58869cb5\nF ext/session/changesetfuzz.c 227076ab0ae4447d742c01ee88a564da6478bbf26b65108bf8fac9cd8b0b24aa\nF ext/session/changesetfuzz1.test 2e1b90d888fbf0eea5e1bd2f1e527a48cc85f8e0ff75df1ec4e320b21f580b3a\nF ext/session/session1.test 0b2f88995832ea040ae8e83a1ad4afa99c00b85c779d213da73a95ea4113233e\nF ext/session/session2.test 284de45abae4cc1082bc52012ee81521d5ac58e0\nF ext/session/session3.test ce9ce3dfa489473987f899e9f6a0f2db9bde3479\nF ext/session/session4.test 6778997065b44d99c51ff9cece047ff9244a32856b328735ae27ddef68979c40\nF ext/session/session5.test 716bc6fafd625ce60dfa62ae128971628c1a1169\nF ext/session/session6.test 443789bc2fca12e4f7075cf692c60b8a2bea1a26\nF ext/session/session8.test 8e194b3f655d861ca36de5d4de53f702751bab3b\nF ext/session/session9.test 5409d90d8141881d08285ed1c2c0d8d10fb92069\nF ext/session/sessionA.test 1feeab0b8e03527f08f2f1defb442da25480138f\nF ext/session/sessionB.test c4fb7f8a688787111606e123a555f18ee04f65bb9f2a4bb2aa71d55ce4e6d02c\nF ext/session/sessionC.test f8a5508bc059ae646e5ec9bdbca66ad24bc92fe99fda5790ac57e1f59fce2fdf\nF ext/session/sessionD.test 4f91d0ca8afc4c3969c72c9f0b5ea9527e21de29039937d0d973f821e8470724\nF ext/session/sessionE.test b2010949c9d7415306f64e3c2072ddabc4b8250c98478d3c0c4d064bce83111d\nF ext/session/sessionF.test d37ed800881e742c208df443537bf29aa49fd56eac520d0f0c6df3e6320f3401\nF ext/session/sessionG.test 3828b944cd1285f4379340fd36f8b64c464fc84df6ff3ccbc95578fd87140b9c\nF ext/session/sessionH.test a417559f29a7e775950fc5fc82b3d01256a7cbe793ddf1180df234df823d56e2\nF ext/session/session_common.tcl 29ec9910aca1e996ca1c8531b8cecabf96eb576aa53de65a8ff03d848b9a2a8b\nF ext/session/session_speed_test.c dcf0ef58d76b70c8fbd9eab3be77cf9deb8bc1638fed8be518b62d6cbdef88b3\nF ext/session/sessionat.test efe88965e74ff1bc2af9c310b28358c02d420c1fb2705cc7a28f0c1cc142c3ec\nF ext/session/sessiondiff.test ad13dd65664bae26744e1f18eb3cbd5588349b7e9118851d8f9364248d67bcec\nF ext/session/sessionfault.test da273f2712b6411e85e71465a1733b8501dbf6f7\nF ext/session/sessionfault2.test dd593f80b6b4786f7adfe83c5939620bc505559770cc181332da26f29cddd7bb\nF ext/session/sessioninvert.test ae1a003a9ab1f8d64227dbb5c3a4c97e65b561b01e7b2953cf48683fb2724169\nF ext/session/sessionrebase.test ccfa716b23bd1d3b03217ee58cfd90c78d4b99f53e6a9a2f05e82363b9142810\nF ext/session/sessionstat1.test 218d351cf9fcd6648f125a26b607b140310160184723c2666091b54450a68fb5\nF ext/session/sessionwor.test 67b5ab91d4f93ce65ff1f58240ac5ddf73f8670facc1ffa49cef56293d52818d\nF ext/session/sqlite3session.c a4dfb372f270df93422b0dc7666fd46849e6979b62a152f11287c21eed4ac21b\nF ext/session/sqlite3session.h a2db5b72b938d12c727b4b4ec632254ca493670a9c0de597af3271a7f774fc57\nF ext/session/test_session.c 98797aba475a799376c9a42214f2d1debf2d0c3cb657d9c8bbf4f70bf3fb4aec\nF ext/userauth/sqlite3userauth.h 7f3ea8c4686db8e40b0a0e7a8e0b00fac13aa7a3\nF ext/userauth/user-auth.txt e6641021a9210364665fe625d067617d03f27b04\nF ext/userauth/userauth.c f81aa5a3ecacf406f170c62a144405858f6f6de51dbdc0920134e629edbe2648\nF install-sh 9d4de14ab9fb0facae2f48780b874848cbf2f895 x\nF ltmain.sh 3ff0879076df340d2e23ae905484d8c15d5fdea8\nF magic.txt 8273bf49ba3b0c8559cb2774495390c31fd61c60\nF main.mk 7ce055f3df31a4f7d21e38f493f907c21db1f673863a573e231f55e2ab005023\nF mkso.sh fd21c06b063bb16a5d25deea1752c2da6ac3ed83\nF mptest/config01.test 3c6adcbc50b991866855f1977ff172eb6d901271\nF mptest/config02.test 4415dfe36c48785f751e16e32c20b077c28ae504\nF mptest/crash01.test 61e61469e257df0850df4293d7d4d6c2af301421\nF mptest/crash02.subtest f4ef05adcd15d60e5d2bd654204f2c008b519df8\nF mptest/mptest.c aa41ace6dbc5050d76b02548d3521e6bbccae4f0\nF mptest/multiwrite01.test dab5c5f8f9534971efce679152c5146da265222d\nF spec.template 86a4a43b99ebb3e75e6b9a735d5fd293a24e90ca\nF sqlite.pc.in 42b7bf0d02e08b9e77734a47798d1a55a9e0716b\nF sqlite3.1 fc7ad8990fc8409983309bb80de8c811a7506786\nF sqlite3.pc.in 48fed132e7cb71ab676105d2a4dc77127d8c1f3a\nF src/alter.c 14b5516be5b3815d30bf230b619978f6158e754a1d624f70a02cfe2178348b5c\nF src/analyze.c b3ceec3fc052df8a96ca8a8c858d455dc5029ba681b4be98bb5c5a9162cfa58c\nF src/attach.c b30c44333d55a68c0a12920b5b9d40b254cbd3d4509bda77417209eeed8b3d80\nF src/auth.c a3d5bfdba83d25abed1013a8c7a5f204e2e29b0c25242a56bc02bb0c07bf1e06\nF src/backup.c f70077d40c08b7787bfe934e4d1da8030cb0cc57d46b345fba2294b7d1be23ab\nF src/bitvec.c 17ea48eff8ba979f1f5b04cc484c7bb2be632f33\nF src/btmutex.c 8acc2f464ee76324bf13310df5692a262b801808984c1b79defb2503bbafadb6\nF src/btree.c d22498af716953400e314d2d98d1dac3ea5c3b01e0fd243ef9e9b132c74114ec\nF src/btree.h f27a33c49280209a93385e218306c4ee5f46ba8d7649d2f81a7166b282232484\nF src/btreeInt.h 91806f01fd1145a9a86ba3042f25c38d8faf6002701bf5e780742cf88bcff437\nF src/build.c 358e894867394839679982d2fe320fb44fd17c94a87feb898aa066c15a8066ea\nF src/callback.c 88615dfc0a82167b65b452b4b305dbf86be77200b3343c6ffc6d03e92a01d181\nF src/complete.c a3634ab1e687055cd002e11b8f43eb75c17da23e\nF src/ctime.c 1b0724e66f95f33b160b1af85caaf9cceb325d22abf39bd24df4f54a73982251\nF src/date.c e1d8ac7102f3f283e63e13867acb0efa33861cf34f0faf4cdbaf9fa7a1eb7041\nF src/dbpage.c 135eb3b5e74f9ef74bde5cec2571192c90c86984fa534c88bf4a055076fa19b7\nF src/dbstat.c 6c407e549406c10fde9ac3987f6d734459205239ad370369bc5fcd683084a4fa\nF src/delete.c a5c59b9c0251cf7682bc52af0d64f09b1aefc6781a63592c8f1136f7b73c66e4\nF src/expr.c 5099de2d6cca77f7c3b5131e0035787fc64ca3d27c267020e7e8bec0e226336c\nF src/fault.c 460f3e55994363812d9d60844b2a6de88826e007\nF src/fkey.c 92a248ec0fa4ed8ab60c98d9b188ce173aaf218f32e7737ba77deb2a684f9847\nF src/func.c ed33e38cd642058182a31a3f518f2e34f4bbe53aa483335705c153c4d3e50b12\nF src/global.c a1a8d698762ddd9a1543aac26c1e0029b20fcc3fcb56bfa41ec8cea2368f2798\nF src/hash.c 8d7dda241d0ebdafb6ffdeda3149a412d7df75102cecfc1021c98d6219823b19\nF src/hash.h 9d56a9079d523b648774c1784b74b89bd93fac7b365210157482e4319a468f38\nF src/hwtime.h cb1d7e3e1ed94b7aa6fde95ae2c2daccc3df826be26fc9ed7fd90d1750ae6144\nF src/in-operator.md 10cd8f4bcd225a32518407c2fb2484089112fd71\nF src/insert.c 831408b14a146e93a4e02ddba54dcdfd8097463b9c00ca2ed9daed790c5d452a\nF src/legacy.c d7874bc885906868cd51e6c2156698f2754f02d9eee1bae2d687323c3ca8e5aa\nF src/loadext.c d74f5e7bd51f3c9d283442473eb65aef359664efd6513591c03f01881c4ae2da\nF src/main.c 868ae7db7a54fe859bf2ca8b7a4f24e9fa03a6134abfb7c9801d08411ef5dacb\nF src/malloc.c 550021fcae36f0ffe9f8563d83e6385f9df307a854d55d7d0abb7241ee8dbcc6\nF src/mem0.c 6a55ebe57c46ca1a7d98da93aaa07f99f1059645\nF src/mem1.c c12a42539b1ba105e3707d0e628ad70e611040d8f5e38cf942cee30c867083de\nF src/mem2.c f1940d9e91948dd6a908fbb9ce3835c36b5d83c3\nF src/mem3.c 8768ac94694f31ffaf8b4d0ea5dc08af7010a35a\nF src/mem5.c 9bf955937b07f8c32541c8a9991f33ce3173d944\nF src/memdb.c 02a5fcec19b9d40dd449ca802dc1b2e8f93f255fbf2a886277a3c3800d8d35db\nF src/memjournal.c 7561c01c90958f3ba9bc6cb2d857123d932bdfa5539ea34427a0957b2e35154d\nF src/msvc.h 3a15918220367a8876be3fa4f2abe423a861491e84b864fb2b7426bf022a28f8\nF src/mutex.c bae36f8af32c22ad80bbf0ccebec63c252b6a2b86e4d3e42672ff287ebf4a604\nF src/mutex.h a7b2293c48db5f27007c3bdb21d438873637d12658f5a0bf8ad025bb96803c4a\nF src/mutex_noop.c 9d4309c075ba9cc7249e19412d3d62f7f94839c4\nF src/mutex_unix.c aaf9ebc3f89df28483c52208497a99a02cc3650011422fc9d4c57e4392f7fe58\nF src/mutex_w32.c 7670d770c94bbfe8289bec9d7f1394c5a00a57c37f892aab6b6612d085255235\nF src/notify.c 9711a7575036f0d3040ba61bc6e217f13a9888e7\nF src/os.c 669cc3839cc35d20f81faf0be1ab6d4581cea35e9d8f3a9d48a98d6571f7c285\nF src/os.h 48388821692e87da174ea198bf96b1b2d9d83be5dfc908f673ee21fafbe0d432\nF src/os_common.h b2f4707a603e36811d9b1a13278bffd757857b85\nF src/os_setup.h 0dbaea40a7d36bf311613d31342e0b99e2536586\nF src/os_unix.c 3e0e519f27683083a465e948e056759a8340728c222b5c394a135e0c57c220bc\nF src/os_win.c 035a813cbd17f355bdcad7ab894af214a9c13a1db8aeac902365350b98cd45a7\nF src/os_win.h 7b073010f1451abe501be30d12f6bc599824944a\nF src/pager.c 30f20d2263d3717f41a0d9a40f7a3d0f48ce1cfab461b875c6187ead9d6ad1c7\nF src/pager.h 217921e81eb5fe455caa5cda96061959706bcdd29ddb57166198645ef7822ac3\nF src/parse.y c8d2de64db469fd56e0fa24da46cd8ec8523eb98626567d2708df371b47fdc3f\nF src/pcache.c 385ff064bca69789d199a98e2169445dc16e4291fa807babd61d4890c3b34177\nF src/pcache.h 4f87acd914cef5016fae3030343540d75f5b85a1877eed1a2a19b9f284248586\nF src/pcache1.c 6596e10baf3d8f84cc1585d226cf1ab26564a5f5caf85a15757a281ff977d51a\nF src/pragma.c 26e9ee514138b9697d4be6d8f9ca84655053026390cf10de838862238aa4aba9\nF src/pragma.h ec3b31eac9b1df040f1cc8cb3d89bc06605c3b4cb3d76f833de8d6d6c3f77f04\nF src/prepare.c 6049beb71385f017af6fc320d2c75a4e50b75e280c54232442b785fbb83df057\nF src/printf.c 9be6945837c839ba57837b4bc3af349eba630920fa5532aa518816defe42a7d4\nF src/random.c 80f5d666f23feb3e6665a6ce04c7197212a88384\nF src/resolve.c 86a7773d2892227ba9ad1721c41bb03c501830f1bf6de5f78dd0062b82e10c9d\nF src/rowset.c d977b011993aaea002cab3e0bb2ce50cf346000dff94e944d547b989f4b1fe93\nF src/select.c b895d809b93596c828c4cd79f4da96d48bf1969414877bb4313770000ea736cc\nF src/shell.c.in 4a3a9e1c11847b1904f2b01d087af1c052f660902755abab457cab1756817ded\nF src/sqlite.h.in 2a23e8161775253d9cf383c2c6aa559005dc787d350dcb0be67a6c4cc3bd1d19\nF src/sqlite3.rc 5121c9e10c3964d5755191c80dd1180c122fc3a8\nF src/sqlite3ext.h 72af51aa4e912e14cd495fb6e7fac65f0940db80ed950d90911aff292cc47ce2\nF src/sqliteInt.h 60d92fad64da7c3e77bbc35ee306340814cdaa5df32892b0ec58d306d99b5733\nF src/sqliteLimit.h 1513bfb7b20378aa0041e7022d04acb73525de35b80b252f1b83fedb4de6a76b\nF src/status.c 46e7aec11f79dad50965a5ca5fa9de009f7d6bde08be2156f1538a0a296d4d0e\nF src/table.c b46ad567748f24a326d9de40e5b9659f96ffff34\nF src/tclsqlite.c 8cd2600e8de23dff6cdf84d39f46ca57139b061b28f6f80b166bace17d52ab1c\nF src/test1.c c654981c1d86ebc90dd23fcc0969e6c85e28112f0acc2e2224a97a2a33e7c42f\nF src/test2.c 3efb99ab7f1fc8d154933e02ae1378bac9637da5\nF src/test3.c 61798bb0d38b915067a8c8e03f5a534b431181f802659a6616f9b4ff7d872644\nF src/test4.c 405834f6a93ec395cc4c9bb8ecebf7c3d8079e7ca16ae65e82d01afd229694bb\nF src/test5.c 328aae2c010c57a9829d255dc099d6899311672d\nF src/test6.c e8d839fbc552ce044bec8234561a2d5b8819b48e29548ad0ba400471697946a8\nF src/test7.c 5612e9aecf934d6df7bba6ce861fdf5ba5456010\nF src/test8.c 3f7d0cc4e12e06832ba3db4455cb16867ccadafa602eb6ff5fcf097bffce56ed\nF src/test9.c 12e5ba554d2d1cbe0158f6ab3f7ffcd7a86ee4e5\nF src/test_async.c 195ab49da082053fdb0f949c114b806a49ca770a\nF src/test_autoext.c 915d245e736652a219a907909bb6710f0d587871\nF src/test_backup.c bf5da90c9926df0a4b941f2d92825a01bbe090a0\nF src/test_bestindex.c 78809f11026f18a93fcfd798d9479cba37e1201c830260bf1edc674b2fa9b857\nF src/test_blob.c ae4a0620b478548afb67963095a7417cd06a4ec0a56adb453542203bfdcb31ce\nF src/test_btree.c 8b2dc8b8848cf3a4db93f11578f075e82252a274\nF src/test_config.c e25826d693039cdd45963de378cbf39e3af0e8aa7a8a6fc159876f4e7b5a4f8c\nF src/test_delete.c e2fe07646dff6300b48d49b2fee2fe192ed389e834dd635e3b3bac0ce0bf9f8f\nF src/test_demovfs.c 86142ba864d4297d54c5b2e972e74f3141ae4b30f05b3a95824184ed2d3d7f91\nF src/test_devsym.c 6109b45c3db3ef7b002320947ed448c027356ab8b885156ff535fd8684d4a571\nF src/test_fs.c ba1e1dc18fd3159fdba0b9c4256f14032159785320dfbd6776eb9973cb75d480\nF src/test_func.c 181f992e5495644434c4f0e3cc72362a78c295eb2cf3ff4d02498b8bde7aa276\nF src/test_hexio.c d170d0e1a6431afdeac086a250d2595078288c2257615d37949355361399bcaa\nF src/test_init.c 4413c211a94b62157ca4c145b3f27c497f03c664\nF src/test_intarray.c 39b4181662a0f33a427748d87218e7578d913e683dc27eab7098bb41617cac71\nF src/test_intarray.h d57ae92f420cda25e22790dac474d60961bd0c500cbaa3338a05152d4a669ef7\nF src/test_journal.c a0b9709b2f12b1ec819eea8a1176f283bca6d688a6d4a502bd6fd79786f4e287\nF src/test_loadext.c 337056bae59f80b9eb00ba82088b39d0f4fe6dfd\nF src/test_malloc.c dec0aa821b230773aeb3dd11d652c1193f7cedb18a20b25659bc672288115242\nF src/test_md5.c 7268e1e8c399d4a5e181b64ac20e1e6f3bc4dd9fc87abac02db145a3d951fa8c\nF src/test_multiplex.c e054459f7633f3ff8ce1245da724f9a8be189e4e\nF src/test_multiplex.h 5436d03f2d0501d04f3ed50a75819e190495b635\nF src/test_mutex.c 7f4337ba23ee6b1d2ec81c189653608cb069926a\nF src/test_onefile.c f31e52e891c5fef6709b9fcef54ce660648a34172423a9cbdf4cbce3ba0049f4\nF src/test_osinst.c 98ef31ff03d55497829ca0f6c74a9f4e1aa48690\nF src/test_pcache.c a5cd24730cb43c5b18629043314548c9169abb00\nF src/test_quota.c 6cb9297115b551f433a9ad1741817a9831abed99\nF src/test_quota.h 2a8ad1952d1d2ca9af0ce0465e56e6c023b5e15d\nF src/test_rtree.c 671f3fae50ff116ef2e32a3bf1fe21b5615b4b7b\nF src/test_schema.c f575932cb6274d12147a77e13ea4b49d52408513\nF src/test_server.c a2615049954cbb9cfb4a62e18e2f0616e4dc38fe\nF src/test_sqllog.c 11e6ce7575f489155c604ac4b439f2ac1d3d5aef\nF src/test_superlock.c 4839644b9201da822f181c5bc406c0b2385f672e\nF src/test_syscall.c 1073306ba2e9bfc886771871a13d3de281ed3939\nF src/test_tclsh.c eeafce33ad2136d57e5dec10f1e9a4347447eb72ffd504a1c7b9c6bfe2e71578\nF src/test_tclvar.c 33ff42149494a39c5fbb0df3d25d6fafb2f668888e41c0688d07273dcb268dfc\nF src/test_thread.c 911d15fb14e19c0c542bdc8aabf981c2f10a4858\nF src/test_vdbecov.c f60c6f135ec42c0de013a1d5136777aa328a776d33277f92abac648930453d43\nF src/test_vfs.c 36822d696789535bdd0260f07d2c9a46546082fea8bb1d0a7354c7f9366e37ea\nF src/test_vfstrace.c bab9594adc976cbe696ff3970728830b4c5ed698\nF src/test_windirent.c a895e2c068a06644eef91a7f0a32182445a893b9a0f33d0cdb4283dca2486ac1\nF src/test_windirent.h 90dfbe95442c9762357fe128dc7ae3dc199d006de93eb33ba3972e0a90484215\nF src/test_window.c cdae419fdcea5bad6dcd9368c685abdad6deb59e9fc8b84b153de513d394ba3f\nF src/test_wsd.c 41cadfd9d97fe8e3e4e44f61a4a8ccd6f7ca8fe9\nF src/threads.c 4ae07fa022a3dc7c5beb373cf744a85d3c5c6c3c\nF src/tokenize.c 7b17f6e2f20f6cbcb0b215025a86b7457c38451fc7622f705e553d7a488c572d\nF src/treeview.c 41d928f04d65931b15f629b4938e9f2c7dc259f02eef34cb2cc6e293f5af813f\nF src/trigger.c 681ccdb910a87243940d63f99b26190d9c5d2534c2ded3c0825b7c0e315a342e\nF src/update.c 07a50767f7d3e26d4c887c31cd66448d700d3215caea6023acf7269336097df7\nF src/upsert.c b445315c8958d8f17ec3297d06842e61dacaad0633ccaec1e4e160de7e562212\nF src/utf.c 2f0fac345c7660d5c5bd3df9e9d8d33d4c27f366bcfb09e07443064d751a0507\nF src/util.c 2c92bc706bbdb1c45a25180291e7e05a56e297aa5dd7b2bcd2b1c47e8bb05b17\nF src/vacuum.c 82dcec9e7b1afa980288718ad11bc499651c722d7b9f32933c4d694d91cb6ebf\nF src/vdbe.c ab3f6e647235fe4fa16b71496468313a1da435eb3a2125c3ffdbb0be0d1cbcba\nF src/vdbe.h fdbc0a11e5768a702b46ce63286f60e22e71351a29bd98b3666405e1fccc7802\nF src/vdbeInt.h bd589b8b7273286858950717e0e1ec5c88b18af45079a3366dc1371865cea704\nF src/vdbeapi.c 1252d80c548711e47a6d84dae88ed4e95d3fbb4e7bd0eaa1347299af7efddf02\nF src/vdbeaux.c 858bb43a9d98846cc23fa8c8d0970ada805dd75bc6a01b69e972da608f7f59b1\nF src/vdbeblob.c 253ed82894924c362a7fa3079551d3554cd1cdace39aa833da77d3bc67e7c1b1\nF src/vdbemem.c 2eb00a4d1a7d2c97510a4d1ccaf4e12c9143f2ced1c6b96b5eddc372183c9121\nF src/vdbesort.c a3be032cc3fee0e3af31773af4a7a6f931b7230a34f53282ccf1d9a2a72343be\nF src/vdbetrace.c fa3bf238002f0bbbdfb66cc8afb0cea284ff9f148d6439bc1f6f2b4c3b7143f0\nF src/vtab.c 2736f853a1bd270581f76bae8e5d2e840b6258f3d85c1fa382e9454b3c414d1d\nF src/vxworks.h d2988f4e5a61a4dfe82c6524dd3d6e4f2ce3cdb9\nF src/wal.c 15a2845769f51ba132f9cf0b2c7a6887a91fc8437892dbcce9fcdc68b66d60a1\nF src/wal.h 606292549f5a7be50b6227bd685fa76e3a4affad71bb8ac5ce4cb5c79f6a176a\nF src/walker.c a137468bf36c92e64d2275caa80c83902e3a0fc59273591b96c6416d3253d05d\nF src/where.c c51ebd505c8417285ca1db8f94933a12224bf636ad93f27d821c07f93d59c035\nF src/whereInt.h 4a296fd4fa79fdcbc2b5e8c1b898901617655811223e1082b899c23ecb092217\nF src/wherecode.c 7efa97f4dc2f95548611deba68f0210ab357725899a9bae5391a525e48271875\nF src/whereexpr.c 39b6a538804c6e1248c22b33e09d00f89ae6a099c849c4d841ce3995562287b4\nF src/window.c da010455914c81037dcb5b0c6f4273f8a32c94567865c46a60060b937b018a96\nF test/8_3_names.test ebbb5cd36741350040fd28b432ceadf495be25b2\nF test/affinity2.test ce1aafc86e110685b324e9a763eab4f2a73f737842ec3b687bd965867de90627\nF test/affinity3.test 6a101af2fc945ce2912f6fe54dd646018551710d\nF test/aggerror.test a867e273ef9e3d7919f03ef4f0e8c0d2767944f2\nF test/aggnested.test 12106f0748e8e9bfc1a8e6840e203e051eae06a26ed13fc9fd5db108a8d6db54\nF test/alias.test 4529fbc152f190268a15f9384a5651bbbabc9d87\nF test/all.test 2ecb8bbd52416642e41c9081182a8df05d42c75637afd4488aace78cc4b69e13\nF test/alter.test 16ed8d2470193f34bc711e51506ff1211ebfab8025ca3b9510ff2aef139874cb\nF test/alter2.test a966ccfcddf9ce0a4e0e6ff1aca9e6e7948e0e242cd7e43fc091948521807687\nF test/alter3.test 9351a9f0c59ff9dddecccaaa2f777ffee5369870c63d30d3a74add815254ec0f\nF test/alter4.test 74b22251c5e9c48093cfc4921ed9c11b59df84634aeeb00e501773320beb8424\nF test/alterauth.test 63442ba61ceb0c1eeb63aac1f4f5cebfa509d352276059d27106ae256bafc959\nF test/alterauth2.test c0a1ddf5b93d93cb0d15ba7acaf0c5c6fb515bbe861ede75b2d3fabad33b6499\nF test/altercol.test 54374d2ba18af25bb24e23acf18a60270d4ec120b7ec0558078b59d5aa1a31ad\nF test/alterlegacy.test 82022721ce0de29cedc9a7af63bc9fcc078b0ee000f8283b4b6ea9c3eab2f44b\nF test/altermalloc.test 167a47de41b5c638f5f5c6efb59784002b196fff70f98d9b4ed3cd74a3fb80c9\nF test/altermalloc2.test fa7b1c1139ea39b8dec407cf1feb032ca8e0076bd429574969b619175ad0174b\nF test/altertab.test 4d8b79b0b88b62b90b710390df14fe99e0a3578345526886eaa550e28e3065dc\nF test/altertab2.test 8883693952f6d7fb5f754dbf1d694ed780aa883027bef04cb1fb99a3b88c9272\nF test/altertab3.test 231881a8e9c4905a84213476c64c174a119e1ab75ce17d986dcbbacc07b2b544\nF test/amatch1.test b5ae7065f042b7f4c1c922933f4700add50cdb9f\nF test/analyze.test 547bb700f903107b38611b014ca645d6b5bb819f5210d7bf39c40802aafeb7d7\nF test/analyze3.test 01f0b122e3e54ad2544f14f7cc7dcb4c2cb8753cad5e88c6b8d49615b3fd6a2b\nF test/analyze4.test cdf88f3f72b0f0643a1ff6c730fc5af1e42464d47478d9fbac84c333f72c014e\nF test/analyze5.test fa5131952303ac4146aba101b116b9c8cb89e2637531c334a6df7f7d19dddc0d\nF test/analyze6.test 6c3f7df2996cb6872f355a6ac1eb6d5de00a5a9288214bad7ef25c97d9cc72dc\nF test/analyze7.test 6ef0b12369f61ddeadc7d8a705c40e6b52cb29f63de3a4c56581b510b46b5783\nF test/analyze8.test 36ce54947710bd44e4f9484e1ad07e725ef01a9d7078b417c1bc884356febe4d\nF test/analyze9.test 9fbf0e0101eef4f5dc149769aa14e10b76ee06e7c28598264b32173cd1999a54\nF test/analyzeC.test 489fe2ea3be3f17548e8dd895f1b41c9669b52de1b0861f5bffe6eec46eac710\nF test/analyzeD.test e50cd0b3e6063216cc0c88a1776e8645dc0bd65a6bb275769cbee33b7fd8d90c\nF test/analyzeE.test 8684e8ac5722fb97c251887ad97e5d496a98af1d\nF test/analyzeF.test 9e1a0537949eb5483642b1140a5c39e5b4025939024b935398471fa552f4dabb\nF test/analyzer1.test 459fa02c445ddbf0101a3bad47b34290a35f2e49\nF test/async.test 1d0e056ba1bb9729283a0f22718d3a25e82c277b\nF test/async2.test c0a9bd20816d7d6a2ceca7b8c03d3d69c28ffb8b\nF test/async3.test d73a062002376d7edc1fe3edff493edbec1fc2f7\nF test/async4.test 1787e3952128aa10238bf39945126de7ca23685a\nF test/async5.test 383ab533fdb9f7ad228cc99ee66e1acb34cc0dc0\nF test/atof1.test ff0b0156fd705b67c506e1f2bfe9e26102bea9bd\nF test/atomic.test 065a453dde33c77ff586d91ccaa6ed419829d492dbb1a5694b8a09f3f9d7d061\nF test/atomic2.test b6863b4aa552543874f80b42fb3063f1c8c2e3d8e56b6562f00a3cc347b5c1da\nF test/atrc.c ec92d56d8fbed9eb3e11aaf1ab98cf7dd59e69dae31f128013f1d97e54e7dfed\nF test/attach.test 21bce8681f780a8d631a5ec7ecd0d849bfe84611257b038ae4ffeccc609d8a4e\nF test/attach2.test 256bd240da1835fb8408dd59fb7ef71f8358c7a756c46662434d11d07ba3a0ce\nF test/attach3.test c59d92791070c59272e00183b7353eeb94915976\nF test/attach4.test aa05b1d8218b24eba5a7cccf4f224f514ba57ba705c9267f09d2bb63fed0eea1\nF test/attachmalloc.test 12c4f028e570acf9e0a4b0b7fe6f536e21f3d5ebddcece423603d0569beaf438\nF test/auth.test 2154625c05bc79f0e0ea72cb2358395a8041243caa0fd7ce7617d50da4331794\nF test/auth2.test 9eb7fce9f34bf1f50d3f366fb3e606be5a2000a1\nF test/auth3.test db21405b95257c24d29273b6b31d0efc59e1d337e3d5804ba2d1fd4897b1ae49\nF test/autoanalyze1.test b9cc3f32a990fa56669b668d237c6d53e983554ae80c0604992e18869a0b2dec\nF test/autoinc.test 997d6f185f138229dc4251583a1d04816423dddc2fc034871a01aeb1d728cb39\nF test/autoindex1.test 96185415f5faacd5b8d7a7f505efddd5abb1f111d58338e9c0b1dc40b87cd3cc\nF test/autoindex2.test 12ef578928102baaa0dc23ad397601a2f4ecb0df\nF test/autoindex3.test 2dd997d6590438b53e4f715f9278aa91c9299cf3f81246a0915269c35beb790e\nF test/autoindex4.test 49d3cd791a9baa16fb461d7ea3de80d019a819cf\nF test/autoindex5.test a5d72fe8c217cc0ea356dc6fa06a282a8a3fc53aa807709d79dba07a8f248102\nF test/autovacuum.test 0831cd34e14695d297187f7f6519265e3121c5b0a1720e548e86829e796129e9\nF test/autovacuum_ioerr2.test 8a367b224183ad801e0e24dcb7d1501f45f244b4\nF test/avtrans.test b7dc25459ecbd86c6fa9c606ee3068f59d81e225118617dcf2bbb6ded2ade89e\nF test/backcompat.test 3e64cedda754c778ef6bbe417b6e7a295e662a4d\nF test/backup.test dd4a5ff756e3df3931dacb1791db0584d4bad989\nF test/backup2.test 1fd1ad8c5b3d2d5b9c0cce4143a4fc610d51ddc6ae16a7a122973d43e6b50bbd\nF test/backup4.test 8f6fd48e0dfde77b9a3bb26dc471ede3e101df32\nF test/backup5.test ee5da6d7fe5082f5b9b0bbfa31d016f52412a2e4\nF test/backup_ioerr.test 4c3c7147cee85b024ecf6e150e090c32fdbb5135\nF test/backup_malloc.test 0c9abdf74c51e7bedb66d504cd684f28d4bd4027\nF test/badutf.test d5360fc31f643d37a973ab0d8b4fb85799c3169f\nF test/badutf2.test f310fd3b24a491b6b77bccdf14923b85d6ebcce751068c180d93a6b8ff854399\nF test/bc_common.tcl b5e42d80305be95697e6370e015af571e5333a1c\nF test/bestindex1.test 705b57d7f51d53ee5fd043dd9666236e1fc18f4d59abf51da0ea5ea1b4804947\nF test/bestindex2.test 9a0ccd320b6525eec3a706aae6cdab7e1b7b5abca75027e39f39f755e76e5928\nF test/bestindex3.test 7622e792ff2da16d262d3cea6ad914591ac4806d57ed128e6c940b7920b47b84\nF test/bestindex4.test 038e3d0789332f3f1d61474f9bbc9c6d08c6bd1783a978f31f38ad82688de601\nF test/bestindex5.test 67c1166131bb59f9e47c00118f7d432ca5491e6cae6ca3f87ca9db20103a78f9\nF test/bestindex6.test d856a9bb63d927493575823eed44053bc36251e241aa364e54d0f2a2d302e1d4\nF test/between.test 68137a6e941c221417c15b6fe2d55f27bb1b6ab48bdf9e2aa51efdd85bc53802\nF test/bigfile.test aa74f4e5db51c8e54a1d9de9fa65d01d1eb20b59\nF test/bigfile2.test 1b489a3a39ae90c7f027b79110d6b4e1dbc71bfc\nF test/bigmmap.test 31dad31573638bd32de866cdefd11843f75685be4ba6aec1a47918f098f1899b\nF test/bigrow.test f0aeb7573dcb8caaafea76454be3ade29b7fc747\nF test/bigsort.test 8299fa9298f4f1e02fc7d2712e8b77d6cd60e5a2\nF test/bind.test 1e136709b306f7ed3192d349c2930d89df6ab621654ad6f1a72381d3fe76f483\nF test/bindxfer.test efecd12c580c14df5f4ad3b3e83c667744a4f7e0\nF test/bitvec.test 75894a880520164d73b1305c1c3f96882615e142\nF test/blob.test e7ac6c7d3a985cc4678c64f325292529a69ae252\nF test/boundary1.tcl 6421b2d920d8b09539503a8673339d32f7609eb1\nF test/boundary1.test 66d7f4706ccdb42d58eafdb081de07b0eb42d77b\nF test/boundary2.tcl e34ef4e930cf1083150d4d2c603e146bd3b76bcb\nF test/boundary2.test 9ae758d7dab7e882c8b6cc4a6a10278385bff8fa\nF test/boundary3.tcl 23361e108a125dca9c4080c2feb884fe54d69243\nF test/boundary3.test 56ef82096b4329aca2be74fa1e2b0f762ea0eb45\nF test/boundary4.tcl 0bb4b1a94f4fc5ae59b79b9a2b7a140c405e2983\nF test/boundary4.test 89e02fa66397b8a325d5eb102b5806f961f8ec4b\nF test/btree01.test e08b3613540145b353f20c81cb18ead54ff12e0f\nF test/btree02.test 7555a5440453d900410160a52554fe6478af4faf53098f7235f1f443d5a1d6cc\nF test/btreefault.test c2bcb542685eea44621275cfedbd8a13f65201e3\nF test/busy.test 510dc6daaad18bcbbc085bcc6217d6dc418def5e73f72ce1475eea0cb7834727\nF test/cache.test 13bc046b26210471ca6f2889aceb1ea52dc717de\nF test/cacheflush.test af25bb1509df04c1da10e38d8f322d66eceedf61\nF test/cachespill.test 895997f84a25b323b166aecb69baab2d6380ea98f9e0bcc688c4493c535cfab9\nF test/capi2.test 34a1a9a96d543a2ec2c209696b11b164444f57253b1f2cba1c2e53fadede6c7b\nF test/capi3.test 3910a73c38ac76d69778dd9eb481ab7cd6ed59117fc047b4f6056a5c72529de1\nF test/capi3b.test efb2b9cfd127efa84433cd7a2d72ce0454ae0dc4\nF test/capi3c.test 54e2dc0c8fd7c34ad1590d1be6864397da2438c95a9f5aee2f8fbc60c112e44b\nF test/capi3d.test aba917805573a03deed961a21f07a5a84505ad0a616f7e3fc1508844a15bccc4\nF test/capi3e.test 3d49c01ef2a1a55f41d73cba2b23b5059ec460fe\nF test/cast.test 3619f0c58c2e4b2a94aa86e75607e497d34ef40ab74418e71aef7b4ca5155895\nF test/cffault.test 9d6b20606afe712374952eec4f8fd74b1a8097ef\nF test/check.test 25c6035302c846c7ff8e681cf8284473f6f01be94d327de60a688ad84ab01f8b\nF test/checkfault.test da6cb3d50247169efcb20bdf57863a3ccfa1d27d9e55cd324f0680096970f014\nF test/chunksize.test 427d87791743486cbf0c3b8c625002f3255cb3a89c6eba655a98923b1387b760\nF test/close.test eccbad8ecd611d974cbf47278c3d4e5874faf02d811338d5d348af42d56d647c\nF test/closure01.test 9905883f1b171a4638f98fc764879f154e214a306d3d8daf412a15e7f3a9b1e0\nF test/coalesce.test cee0dccb9fbd2d494b77234bccf9dc6c6786eb91\nF test/collate1.test 4178fda6f4cd757b7a278e6b83805868fb1eb46edafb6e3d4bcc2419f8d93202\nF test/collate2.test 9aaa410a00734e48bcb27f3872617d6f69b2a621\nF test/collate3.test 89defc49983ddfbf0a0555aca8c0521a676f56a5\nF test/collate4.test c953715fb498b87163e3e73dd94356bff1f317bd\nF test/collate5.test 65d928034d30d2d263a80f6359f7549ee1598ec6\nF test/collate6.test 8be65a182abaac8011a622131486dafb8076e907\nF test/collate7.test 8ec29d98f3ee4ccebce6e16ce3863fb6b8c7b868\nF test/collate8.test cd9b3d3f999b8520ffaa7cc1647061fc5bab1334\nF test/collate9.test 3adcc799229545940df2f25308dd1ad65869145a\nF test/collateA.test b8218ab90d1fa5c59dcf156efabb1b2599c580d6\nF test/collateB.test 1e68906951b846570f29f20102ed91d29e634854ee47454d725f2151ecac0b95\nF test/colmeta.test 2c765ea61ee37bc43bbe6d6047f89004e6508eb1\nF test/colname.test 87ad5458bb8709312dac0d6755fd30e8e4ca83298d0a9ef6e5c24277a3c3390e\nF test/conflict.test 58857e2533fb9f2e0358ea7cb191215657846be1dd9da3b3d6df3e750c02ae03\nF test/conflict2.test bb0b94cf7196c64a3cbd815c66d3ee98c2fecd9c\nF test/conflict3.test f62a2d0cad9162a60e6458fc913dff3a2208feca924120c21737cfee65a6a74a\nF test/contrib01.test 2a1cbc0f2f48955d7d073f725765da6fbceda6b4\nF test/corrupt.test d7cb0300e4a297147b6a05e92a1684bc8973635c3bcaa3d66e983c9cbdbf47a3\nF test/corrupt2.test bb50042cf9a1f1023d73af325d47eb02a6bb11e3c52f8812644b220c5d4bca35\nF test/corrupt3.test f95d7bf78109e0b84eb285a787ce91a3fd6a2dd7d0cb55882abff3bdc081a57e\nF test/corrupt4.test 8d1d86b850fcc43e417450454f2044e52d55778a\nF test/corrupt5.test 387be3250795e2a86e6234745558b80efb248a357d0cd8e53bce75c7463f545d\nF test/corrupt6.test fc6a891716139665dae0073b6945e3670bf92568\nF test/corrupt7.test b036f94bda4b0b23a2919bf717046ce9ecca4543\nF test/corrupt8.test 2399dfe40d2c0c63af86706e30f3e6302a8d0516\nF test/corrupt9.test 730a3db08d4ab9aa43392ea30d9c2b4879cbff85\nF test/corruptA.test 112f4b2ae0b95ebf3ea63718642fb969a93acea557ace3a307234d19c245989b\nF test/corruptB.test 73a8d6c0b9833697ecf16b63e3c5c05c945b5dec\nF test/corruptC.test 74d4498fd25759618b393f1e9cde111de828b88c1848ab320f6c179fd52b5a60\nF test/corruptD.test 33a37ce3ed56a20093ceee778cd2d7109c7085a59f3213d2baede11d952e8e50\nF test/corruptE.test 4143791f2dfb443aec5b7fabfa5821e6063eccc3b49b06f212c2f014715fd476\nF test/corruptF.test be9fde98e4c93648f1ba52b74e5318edc8f59fe4\nF test/corruptG.test adf79b669cbfd19e28c8191a610d083ae53a6d51\nF test/corruptH.test 79801d97ec5c2f9f3c87739aa1ec2eb786f96454\nF test/corruptI.test a17bbf54fdde78d43cf3cc34b0057719fd4a173a3d824285b67dc5257c064c7b\nF test/corruptJ.test 4d5ccc4bf959464229a836d60142831ef76a5aa4\nF test/corruptK.test 5b4212fe346699831c5ad559a62c54e11c0611bdde1ea8423a091f9c01aa32af\nF test/corruptL.test a22a7bbf8da7603960f0bfcc62a68d1c3c41963786bd832ff804ba5e2458fb9c\nF test/corruptM.test 7d574320e08c1b36caa3e47262061f186367d593a7e305d35f15289cc2c3e067\nF test/cost.test 51f4fcaae6e78ad5a57096831259ed6c760e2ac6876836e91c00030fad385b34\nF test/count.test cb2e0f934c6eb33670044520748d2ecccd46259c\nF test/countofview.test e17d6e6688cf74f22783c9ec6e788c0790ee4fbbaee713affd00b1ac0bb39b86\nF test/coveridxscan.test 5ec98719a2e2914e8908dc75f7247d9b54a26df04625f846ac7900d5483f7296\nF test/crash.test fb9dc4a02dcba30d4aa5c2c226f98b220b2b959f\nF test/crash2.test 5b14d4eb58b880e231361d3b609b216acda86651\nF test/crash3.test 8f5de9d32ab9ab95475a9efe7f47a940aa889418\nF test/crash4.test fe2821baf37168dc59dd733dcf7dba2a401487bc\nF test/crash5.test f14ff37eddc41991be4eb63568f86caa306fd9962a0ae3750db8836777bb7aae\nF test/crash6.test 4c56f1e40d0291e1110790a99807aa875b1647ba\nF test/crash7.test 1a194c4900a255258cf94b7fcbfd29536db572df\nF test/crash8.test 64366e459c28dd62edfb7ad87253a409c7533b92d16fcc479a6a8131bdcc3100\nF test/crashM.test d95f59046fa749b0d0822edf18a717788c8f318d\nF test/crashtest1.c 09c1c7d728ccf4feb9e481671e29dda5669bbcc2\nF test/createtab.test 85cdfdae5c3de331cd888d6c66e1aba575b47c2e3c3cc4a1d6f54140699f5165\nF test/cse.test 277350a26264495e86b1785f34d2d0c8600e021c\nF test/csv01.test c9c3af0d58c34e9ac970c5875a77939edb958762c8aafb95409e19a3f088b6cd\nF test/ctime.test 78749e6c9a5f0010d67985be80788f841e3cd2da18114e2ed6010399a7d807f3\nF test/cursorhint.test 7bc346788390475e77a345da2b92270d04d35856\nF test/cursorhint2.test 6f3aa9cb19e7418967a10ec6905209bcbb5968054da855fc36c8beee9ae9c42f\nF test/dataversion1.test 6e5e86ac681f0782e766ebcb56c019ae001522d114e0e111e5ebf68ccf2a7bb8\nF test/date.test 9b73bbeb1b82d9c1f44dec5cf563bf7da58d2373\nF test/date2.test 5ef8265c71460cda6b1698bf18f4bb0ffb40ac08c5092f6afe84d398c2feb5be\nF test/dbdata.test 042f49acff3438f940eeba5868d3af080ae64ddf26ae78f80c92bec3ca7d8603\nF test/dbfuzz.c 73047c920d6210e5912c87cdffd9a1c281d4252e\nF test/dbfuzz001.test 42aad1dcef6219fbee86a9b7d08832c9bbb2e41508f6f128ae91745927276292\nF test/dbfuzz2-seed1.db e6225c6f3d7b63f9c5b6867146a5f329d997ab105bee64644dc2b3a2f2aebaee\nF test/dbfuzz2.c c2c9cb40082a77b7e95ffb8b2da1e93322efadfb1c8c1e0001c95a0af1e156c2\nF test/dbpage.test 650234ba683b9d82b899c6c51439819787e7609f17a0cc40e0080a7b6443bc38\nF test/dbstatus.test 4a4221a883025ffd39696b3d1b3910b928fb097d77e671351acb35f3aed42759\nF test/dbstatus2.test f5fe0afed3fa45e57cfa70d1147606c20d2ba23feac78e9a172f2fe8ab5b78ef\nF test/default.test 3e46c421eebefd2787c2f96673efabf792d360f3a1d5073918cbe450ce672a62\nF test/delete.test 31832b0c45ecb51a54348c68db173be462985901e6ed7f403d6d7a8f70ab4ef0\nF test/delete2.test 3a03f2cca1f9a67ec469915cb8babd6485db43fa\nF test/delete3.test 555e84a00a99230b7d049d477a324a631126a6ab\nF test/delete4.test 6aa279f459f4aa792cc251435c3809415c1ecaf9f27dce91675e26f05b503db3\nF test/delete_db.test 096d828493c7907f9ea11a7098ea6a0f73edba89406487d5d6cc2228dc4ab8b0\nF test/descidx1.test edc8adee58d491b06c7157c50364eaf1c3605c9c19f8093cb1ea2b6184f3ac13\nF test/descidx2.test a0ba347037ff3b811f4c6ceca5fd0f9d5d72e74e59f2d9de346a9d2f6ad78298\nF test/descidx3.test 953c831df7ea219c73826dfbf2f6ee02d95040725aa88ccb4fa43d1a1999b926\nF test/diskfull.test 106391384780753ea6896b7b4f005d10e9866b6e\nF test/distinct.test a1783b960ad8c15a77cd9f207be072898db1026c\nF test/distinct2.test 11b0594c932098e969d084ba45ab81d5040f4d4e766db65d49146705a305ed98\nF test/distinctagg.test 1a6ef9c87a58669438fc771450d7a72577417376\nF test/e_blobbytes.test 439a945953b35cb6948a552edaec4dc31fd70a05\nF test/e_blobclose.test 4b3c8c60c2171164d472059c73e9f3c1844bb66d\nF test/e_blobopen.test e95e1d40f995056f6f322cd5e1a1b83a27e1a145\nF test/e_blobwrite.test f87ff598b67af5b3ec002a8d83e804dc8d23808e88cf0080c176612fc9ffce14\nF test/e_changes.test fd66105385153dbf21fdb35eb8ef6c3e1eade579\nF test/e_createtable.test 1c602347e73ab80b11b9fa083f47155861aaafcff8054aac9e0b76d0df33b0a7\nF test/e_delete.test ab39084f26ae1f033c940b70ebdbbd523dc4962e\nF test/e_droptrigger.test 3cd080807622c13e5bbb61fc9a57bd7754da2412\nF test/e_dropview.test 21ce09c361227ddbc9819a5608ee2700c276bdd5\nF test/e_expr.test 328d2d7c84f8e53e942a13eac771b337bcdfcf4c3569324001868b5639f3c857\nF test/e_fkey.test 2febb2084aef9b0186782421c07bc9d377abf067c9cb4efd49d9647ae31f5afe\nF test/e_fts3.test 17ba7c373aba4d4f5696ba147ee23fd1a1ef70782af050e03e262ca187c5ee07\nF test/e_insert.test f02f7f17852b2163732c6611d193f84fc67bc641fb4882c77a464076e5eba80e\nF test/e_reindex.test 2b0e29344497d9a8a999453a003cb476b6b1d2eef2d6c120f83c2d3a429f3164\nF test/e_resolve.test a61751c368b109db73df0f20fc75fb47e166b1d8\nF test/e_select.test f9474205669a7736ef725b29cc7ae9e8601919a3d0ffc0ab30745a028f2a4b61\nF test/e_select2.test aceb80ab927d46fba5ce7586ebabf23e2bb0604f\nF test/e_totalchanges.test b12ee5809d3e63aeb83238dd501a7bca7fd72c10\nF test/e_update.test f46c2554d915c9197548681e8d8c33a267e84528\nF test/e_uri.test 47eeb2960e74613f0f8722b2f13aef08fde69daa16e5380ac93df84dac8b1f72\nF test/e_vacuum.test 0d8832a2ce92350db0d0cff47b419465fd9772562e1f77ff7d9478c07a4980d2\nF test/e_wal.test ae9a593207a77d711443ee69ffe081fda9243625\nF test/e_walauto.test 248af31e73c98df23476a22bdb815524c9dc3ba8\nF test/e_walckpt.test 28c371a6bb5e5fe7f31679c1df1763a19d19e8a0\nF test/e_walhook.test 01b494287ba9e60b70f6ebf3c6c62e0ffe01788e344a4846b08e5de0b344cb66\nF test/emptytable.test a38110becbdfa6325cd65cb588dca658cd885f62\nF test/enc.test e54531cd6bf941ee6760be041dff19a104c7acea\nF test/enc2.test 83437a79ba1545a55fb549309175c683fb334473\nF test/enc3.test 6807f7a7740a00361ca8d0ccd66bc60c8dc5f2b6\nF test/enc4.test c8f1ce3618508fd0909945beb8b8831feef2c020\nF test/eqp.test 84879b63e3110552bf8ce648a3507dc3ceb72109ecec83c2aef0db37a27f6382\nF test/errmsg.test eae9f091eb39ce7e20305de45d8e5d115b68fa856fba4ea6757b6ca3705ff7f9\nF test/eval.test a64c9105d6ff163df7cf09d6ac29cdad5922078c\nF test/exclusive.test 1206b87e192497d78c7f35552e86a9d05421498da300fb1cce5ca5351ccde3c3\nF test/exclusive2.test 984090e8e9d1b331d2e8111daf6e5d61dda0bef7\nF test/exec.test e949714dc127eaa5ecc7d723efec1ec27118fdd7\nF test/exists.test 79a75323c78f02bbe9c251ea502a092f9ef63dac\nF test/expr.test 7cb55e80aeb41d65fec968c08212505123063fea60bdc355d764d747670e9eea\nF test/expr2.test c27327ae9c017a7ff6280123f67aff496f912da74d78c888926d68b46ec75fd8\nF test/extension01.test 00d13cec817f331a687a243e0e5a2d87b0e358c9\nF test/extraquick.test cb254400bd42bfb777ff675356aabf3287978f79\nF test/fallocate.test 37a62e396a68eeede8f8d2ecf23573a80faceb630788d314d0a073d862616717\nF test/filectrl.test 6e871c2d35dead1d9a88e176e8d2ca094fec6bb3\nF test/filefmt.test f393e80c4b8d493b7a7f8f3809a8425bbf4292af1f5140f01cb1427798a2bbd4\nF test/filter1.test fe7fcfeff48ca399fbc9577f55b60c8be8ccfdffc5e3b4ace21dc3c3e59f0f6a\nF test/filter2.tcl 44e525497ce07382915f01bd29ffd0fa49dab3adb87253b5e5103ba8f93393e8\nF test/filter2.test 485cf95d1f6d6ceee5632201ca52a71868599836f430cdee42e5f7f14666e30a\nF test/filterfault.test c08fb491d698e8df6c122c98f7db1c65ffcfcad2c1ab0e07fa8a5be1b34eaa8b\nF test/fkey1.test d11dbb8a93ead9b5c46ae5d02da016d61245d47662fb2d844c99214f6163f768\nF test/fkey2.test d35d1c81e7569bdd2b872e91750f7098117d2e8291369f70b7e3d50a0e523dc2\nF test/fkey3.test 76d475c80b84ee7a5d062e56ccb6ea68882e2b49\nF test/fkey4.test 86446017011273aad8f9a99c1a65019e7bd9ca9d\nF test/fkey5.test 24dd28eb3d9f1b5a174f47e9899ace5facb08373a4223593c8c631e6cf9f7d5a\nF test/fkey6.test d078a1e323a740062bed38df32b8a736fd320dc0\nF test/fkey7.test 64fb28da03da5dfe3cdef5967aa7e832c2507bf7fb8f0780cacbca1f2338d031\nF test/fkey8.test 48ef829d63f5f7b37aabd4df9363ac05f65539d1da8c4a44251631769d920579\nF test/fkey_malloc.test 594a7ea1fbab553c036c70813cd8bd9407d63749\nF test/fordelete.test eb93a2f34137bb87bdab88fcab06c0bd92719aff\nF test/format4.test eeae341953db8b6bda7f549044797c3278a6cc345d11ada81471671b654f8ef4\nF test/fts-9fd058691.test 78b887e30ae6816df0e1fed6259de4b5a64ad33c\nF test/fts1a.test 46090311f85da51bb33bd5ce84f7948359c6d8d7\nF test/fts1b.test 5d8a01aefbecc8b7442b36c94c05eb7a845462d5\nF test/fts1c.test 85a525ce7428907469b4cce13d5563ce542ce64c\nF test/fts1d.test a73deace5c18df4a549b12908bade4f05dcf1a2f\nF test/fts1e.test 77244843e925560b5a0b70069c3e7ab62f181ed2\nF test/fts1f.test 2d6cb10d8b7a4e6edc321bbdb3982f1f48774714\nF test/fts1i.test 6bfe08cdfdced063a39a50c8601da65e6274d879\nF test/fts1j.test e3797475796043a161e348c46a309664cac83f7f\nF test/fts1k.test 65d3b41487b9f738d11b0f00eca375c0ca6bd970\nF test/fts1l.test 15c119ed2362b2b28d5300c0540a6a43eab66c36\nF test/fts1m.test 2d9ca67b095d49f037a914087cc0a61e89da4f0c\nF test/fts1n.test a2317dcd27b1d087ee3878b30e0a59c593c98b7a\nF test/fts1o.test d1554caede42bba2c82fe613bcc921856c196b752449ead0470fac52a20fd3b8\nF test/fts1porter.test d86e9c3e0c7f8ff95add6582b4b585fb4e02b96d\nF test/fts2.test e3fb95f96a650411574efc136f3fb10eef479ed7\nF test/fts2a.test 473a5c8b473a4e21a8e3fddaed1e59666e0c6ab7\nF test/fts2b.test 964abc0236c849c07ca1ae496bb25c268ae94816\nF test/fts2c.test ffb5a35230ac72c4354535c547965ce6824537c0\nF test/fts2d.test b7eaa671ca9a16997f3e5b158ee777ae21052b0b\nF test/fts2e.test 2da13dbc2d009105f42196845c1e1ce136c03d38\nF test/fts2f.test cf84096235991709c1e61caa389632aa0a4f976d\nF test/fts2g.test 3d26fe171bda6133ebf5a380731d70eaa2ef2f6f73d79769cf8946e622b6d597\nF test/fts2h.test 223af921323b409d4b5b18ff4e51619541b174bb\nF test/fts2i.test 1b22451d1f13f7c509baec620dc3a4a754885dd6\nF test/fts2j.test 298fa1670aa21cd445b282d139b70c72e7ade12b\nF test/fts2k.test c7ebf4a4937594aa07459e3e1bca1251c1be8659\nF test/fts2l.test 3333336621524cf7d60bb62d6ef6ab69647866ed\nF test/fts2m.test 4b30142ead6f3ed076e880a2a464064c5ad58c51\nF test/fts2n.test 12b9c5352128cebd1c6b8395e43788d4b09087c2\nF test/fts2o.test 4054ac7433eb5440f1b1d200cfa449342dc4aabd991759139813e17c73e5bf9a\nF test/fts2p.test 4b48c35c91e6a7dbf5ac8d1e5691823cc999aafb\nF test/fts2q.test b2fbbe038b7a31a52a6079b215e71226d8c6a682\nF test/fts2r.test b154c30b63061d8725e320fba1a39e2201cadd5e\nF test/fts2token.test d8070b241a15ff13592a9ae4a8b7c171af6f445a\nF test/fts3.test 672a040ea57036fb4b6fdc09027c18d7d24ab654\nF test/fts3_common.tcl dffad248f9ce090800e272017d2898005c28ee6314fc1dd5550643a02666907a\nF test/fts3aa.test 814d60a1ba30b4a71d8f9306a6564bc7b636dd6efacd2ad80306f9b23ef3ebee\nF test/fts3ab.test 7f6cf260ae80dda064023df8e8e503e9a412b91f\nF test/fts3ac.test 636ed7486043055d4f126a0e385f2d5a82ebbf63\nF test/fts3ad.test e40570cb6f74f059129ad48bcef3d7cbc20dda49\nF test/fts3ae.test ce32a13b34b0260928e4213b4481acf801533bda\nF test/fts3af.test d394978c534eabf22dd0837e718b913fd66b499c\nF test/fts3ag.test c003672a215124df7fc6000036d896f498b26b53\nF test/fts3ah.test dc9f66c32c296f1bc8bcc4535126bddfeca62894\nF test/fts3ai.test 24058fdc6e9e5102c1fd8459591b114b6a85d285\nF test/fts3aj.test 0ed71e1dd9b03b843a857dc3eb9b15630e0104fc\nF test/fts3ak.test bd14deafe9d1586e8e9bf032411026ac4f8c925d\nF test/fts3al.test 07d64326e79bbdbab20ee87fc3328fbf01641c9f\nF test/fts3am.test 218aa6ba0dfc50c7c16b2022aac5c6be593d08d8\nF test/fts3an.test a49ccadc07a2f7d646ec1b81bc09da2d85a85b18\nF test/fts3ao.test 266989148fec6d9f1bb6c5382f7aa3dcea0e9cd444576e28dd2b9287ac7dd220\nF test/fts3atoken.test bef8a163490098a6b8a6ec5f5407269a3a15b9902c0fcf5e962825a81675b3a0\nF test/fts3auto.test bfe0857bd0b69d68dd685a931b58486411a69f5794a7f6d6fe808bfa31a99614\nF test/fts3aux1.test 7a170e172afdbceb67f5baa05941fd4fbf56af42f61daa3d140f4b4bf4cb68f6\nF test/fts3aux2.test 2459e7fa3e22734aed237d1e2ae192f5541c4d8b218956ad2d90754977bf907f\nF test/fts3b.test c15c4a9d04e210d0be67e54ce6a87b927168fbf9c1e3faec8c1a732c366fd491\nF test/fts3c.test fc723a9cf10b397fdfc2b32e73c53c8b1ec02958\nF test/fts3comp1.test a0f5b16a2df44dd0b15751787130af2183167c0c\nF test/fts3conf.test c84bbaec81281c1788aa545ac6e78a6bd6cde2bdbbce2da261690e3659f5a76b\nF test/fts3corrupt.test ce7f7b5eaeee5f1804584d061b978d85e64abf2af9adaa7577589fac6f7eae01\nF test/fts3corrupt2.test bf55c3fa0b0dc8ea1c0fe5543623bd27714585da6a129038fd6999fe3b0d25f3\nF test/fts3corrupt3.test 0d5b69a0998b4adf868cc301fc78f3d0707745f1d984ce044c205cdb764b491f\nF test/fts3corrupt4.test 00ecd7605d5b1478252a3b7c2465de2d427906b8cb73b7acb92628bab81f9903\nF test/fts3corrupt5.test 0549f85ec4bd22e992f645f13c59b99d652f2f5e643dac75568bfd23a6db7ed5\nF test/fts3cov.test 7eacdbefd756cfa4dc2241974e3db2834e9b372ca215880e00032222f32194cf\nF test/fts3d.test 2bd8c97bcb9975f2334147173b4872505b6a41359a4f9068960a36afe07a679f\nF test/fts3defer.test f4c20e4c7153d20a98ee49ee5f3faef624fefc9a067f8d8d629db380c4d9f1de\nF test/fts3defer2.test 3da52ca2114e300e9971eee2f0cc1a2e5f27e6a9ee67957d49e63e41fdfcc0e7\nF test/fts3defer3.test dd53fc13223c6d8264a98244e9b19abd35ed71cd\nF test/fts3drop.test 1b906e293d6773812587b3dc458cb9e8f3f0c297\nF test/fts3e.test 1f6c6ac9cc8b772ca256e6b22aaeed50c9350851\nF test/fts3expr.test ebae205a7a89446c32583bcd492dcb817b9f6b31819bb4dde2583bb99c77e526\nF test/fts3expr2.test 18da930352e5693eaa163a3eacf96233b7290d1a\nF test/fts3expr3.test c4d4a7d6327418428c96e0a3a1137c251b8dfbf8\nF test/fts3expr4.test f5b2832549f01b1f7f73389fa21d4b875499bc95bf7c8b36271844888c6a0938\nF test/fts3expr5.test a5b9a053becbdb8e973fbf4d6d3abaabeb42d511d1848bd57931f3e0a1cf983e\nF test/fts3fault.test 798e45af84be7978ca33d5bdc94246eb44724db24174b5d8e9b1ac46c57fb08d\nF test/fts3fault2.test 6a17a11d8034b1c4eca9f3091649273d56c49ff049e2173df8060f94341e9da0\nF test/fts3first.test dbdedd20914c8d539aa3206c9b34a23775644641\nF test/fts3fuzz001.test e3c7b0ce9b04cc02281dcc96812a277f02df03cd7dc082055d87e11eb18aaf56\nF test/fts3join.test 949b4f5ae3ae9cc2423cb865d711e32476bdb205ab2be923fdf48246e4a44166\nF test/fts3malloc.test b0e4c133b8d61d4f6d112d8110f8320e9e453ef6\nF test/fts3matchinfo.test aa66cc50615578b30f6df9984819ae5b702511cf8a94251ec7c594096a703a4a\nF test/fts3misc.test c47d2c1ea1351c51c32c688545b02c8180a3f22156d1aedc206a8c09b9d95905\nF test/fts3near.test 7e3354d46f155a822b59c0e957fd2a70c1d7e905\nF test/fts3offsets.test b85fd382abdc78ebce721d8117bd552dfb75094c\nF test/fts3prefix.test fa794eaab0bdae466494947b0b153d7844478ab2\nF test/fts3prefix2.test e1f0a822ca661dced7f12ce392e14eaf65609dce\nF test/fts3query.test ca033ff2ebcc22c69d89032fb0bc1850997d31e7e60ecd26440796ba1654e78f\nF test/fts3rank.test cd99bc83a3c923c8d52afd90d86979cf05fc41849f892faeac3988055ef37b99\nF test/fts3rnd.test 1320d8826a845e38a96e769562bf83d7a92a15d0\nF test/fts3shared.test 57e26a801f21027b7530da77db54286a6fe4997e\nF test/fts3snippet.test 430bb5ace2b31ccd99de4d71775d956da832c114c4b3e39589748f114458647c\nF test/fts3sort.test ed34c716a11cc2009a35210e84ad5f9c102362ca\nF test/fts3tok1.test a663f4cac22a9505400bc22aacb818d7055240409c28729669ea7d4cc2120d15\nF test/fts3tok_err.test 52273cd193b9036282f7bacb43da78c6be87418d\nF test/fts3varint.test 0b84a3fd4eba8a39f3687523804d18f3b322e6d4539a55bf342079c3614f2ada\nF test/fts4aa.test 4338ea7a67f7e19269bf6e6fb4a291352aa32296e7daed87f9823d57016a1ef7\nF test/fts4check.test 6259f856604445d7b684c9b306b2efb6346834c3f50e8fc4a59a2ca6d5319ad0\nF test/fts4content.test 73bbb123420d2c46ef2fb3b24761e9acdb78b0877179d3a5d7d57aada08066f6\nF test/fts4docid.test e33c383cfbdff0284685604d256f347a18fdbf01\nF test/fts4growth.test 289833c34ad45a5e6e6133b53b6a71647231fb89d36ddcb8d9c87211b6721d7f\nF test/fts4growth2.test 13ad4e76451af6e6906c95cdc725d01b00044269\nF test/fts4incr.test 4e353a0bd886ea984e56fce9e77724fc923b8d0d\nF test/fts4langid.test 2168ba330af34f8a1c8832de0aab4c4b6fa195a16419c9c0c8aad59ceb6ff714\nF test/fts4lastrowid.test 185835895948d5325c7710649824042373b2203149abe8024a9319d25234dfd7\nF test/fts4merge.test e2b2ec21e287d54ec09824ccfb41e66896eeca568fc818ba0e0eb2efd94c35d2\nF test/fts4merge2.test 5faa558d1b672f82b847d2a337465fa745e46891\nF test/fts4merge3.test 8d9ccb4a3d41c4c617a149d6c4b13ad02de797d0\nF test/fts4merge4.test d895b1057a7798b67e03455d0fa50e9ea836c47b\nF test/fts4merge5.test 69932d85cda8a1c4dcfb742865900ed8fbda51724b8cf9a45bbe226dfd06c596\nF test/fts4noti.test 5553d7bb2e20bf4a06b23e849352efc022ce6309\nF test/fts4onepass.test d69ddc4ee3415e40b0c5d1d0408488a87614d4f63ba9c44f3e52db541d6b7cc7\nF test/fts4opt.test 0fd0cc84000743ff2a883b9b84b4a5be07249f0ba790c8848a757164cdd46b2a\nF test/fts4record.test a48508f69a84c9287c8019d3a1ae712f5730d8335ffaf8e2101e691d078950bb\nF test/fts4rename.test 15fd9985c2bce6dea20da2245b22029ec89bd4710ed317c4c53abbe3cfd0c880\nF test/fts4umlaut.test fcaca4471de7e78c9d1f7e8976e3e8704d7d8ad979d57a739d00f3f757380429\nF test/fts4unicode.test ceca76422abc251818cb25dabe33d3c3970da5f7c90e1540f190824e6b3a7c95\nF test/full.test 6b3c8fb43c6beab6b95438c1675374b95fab245d\nF test/func.test 7d425f9a6eaa2c50baa751bef6b0c6c6af1751e0e0e1eb4863d426bb4c886788\nF test/func2.test 772d66227e4e6684b86053302e2d74a2500e1e0f\nF test/func3.test 2bb0f31ab7baaed690b962a88544d7be6b34fa389364bc36a44e441ed3e3f1e6\nF test/func4.test 6beacdfcb0e18c358e6c2dcacf1b65d1fa80955f\nF test/func5.test cdd224400bc3e48d891827cc913a57051a426fa4\nF test/func6.test 90e42b64c4f9fb6f04f44cb8a1da586c8542502e926b19c76504fe74ff2a9b7c\nF test/fuzz-oss1.test e58330d01cbbd8215ee636b17a03fe220b37dbfa\nF test/fuzz.test 96083052bf5765e4518c1ba686ce2bab785670d1\nF test/fuzz2.test 76dc35b32b6d6f965259508508abce75a6c4d7e1\nF test/fuzz3.test 9c813e6613b837cb7a277b0383cd66bfa07042b4cf0317157c35852f30043c31\nF test/fuzz4.test c229bcdb45518a89e1d208a21343e061503460ac69fae1539320a89f572eb634\nF test/fuzz_common.tcl a87dfbb88c2a6b08a38e9a070dabd129e617b45b\nF test/fuzz_malloc.test f348276e732e814802e39f042b1f6da6362a610af73a528d8f76898fde6b22f2\nF test/fuzzcheck.c 0df68e0df3b93a8c8fc24c9873127c7d78024b51444193545f985dbc90ac024e\nF test/fuzzdata1.db d36e88741b4f23bcbaaf55b006290669d03c6c891cf13c7b3a53bc1b097b693f\nF test/fuzzdata2.db 128b3feeb78918d075c9b14b48610145a0dd4c8d6f1ca7c2870c7e425f5bf31f\nF test/fuzzdata3.db c6586d3e3cef0fbc18108f9bb649aa77bfc38aba\nF test/fuzzdata4.db b502c7d5498261715812dd8b3c2005bad08b3a26e6489414bd13926cd3e42ed2\nF test/fuzzdata5.db e35f64af17ec48926481cfaf3b3855e436bd40d1cfe2d59a9474cb4b748a52a5\nF test/fuzzdata6.db 92a80e4afc172c24f662a10a612d188fb272de4a9bd19e017927c95f737de6d7\nF test/fuzzdata7.db e7a86fd83dda151d160445d542e32e5c6019c541b3a74c2a525b6ac640639711\nF test/fuzzdata8.db b45368bbe9f86d40d30603e8f780ac29807cbcc951a18d7a7fd9d0c0e904706e\nF test/fuzzer1.test 3d4c4b7e547aba5e5511a2991e3e3d07166cfbb8\nF test/fuzzer2.test a85ef814ce071293bce1ad8dffa217cbbaad4c14\nF test/fuzzerfault.test 8792cd77fd5bce765b05d0c8e01b9edcf8af8536\nF test/gcfault.test dd28c228a38976d6336a3fc42d7e5f1ad060cb8c\nF test/gencol1.test 69008f45faa46b7293cc6ce1236f356a7aff6061b0547334786b54a49b2f98cb\nF test/genesis.tcl 1e2e2e8e5cc4058549a154ff1892fe5c9de19f98\nF test/having.test e4098a4b8962f9596035c3b87a8928a10648acc509f1bb8d6f96413bbf79a1b3\nF test/hexlit.test 4a6a5f46e3c65c4bf1fa06f5dd5a9507a5627751\nF test/hidden.test 23c1393a79e846d68fd902d72c85d5e5dcf98711\nF test/hook.test 1604b3b2f5931430087540404555c1b6be3618600b81558657c66b533ed70b13\nF test/hook2.test b9ff3b8c6519fb67f33192f1afe86e7782ee4ac8\nF test/icu.test 41aa8847745a879b897a7febea0f8f9efc8e67fe8bf680589b6e07c7b0a1569a\nF test/ieee754.test 806fc0ce7f305f57e3331eaceeddcfec9339e607\nF test/imposter1.test c3f1db2d3db2c24611a6596a3fc0ffc14f1466c8\nF test/in.test 3e9bd58597a444123a40a9ac94cae0fec8897e17e9f519b02fc370bcf5ba5175\nF test/in2.test 5d4c61d17493c832f7d2d32bef785119e87bde75\nF test/in3.test 3cbf58c87f4052cee3a58b37b6389777505aa0c0\nF test/in4.test 0f77b0ff371549e6a119d0356be10bdba72258162e9701e83527a560482f5e98\nF test/in5.test b32ce7f4a93f44c5dee94af16886d922cc16ebe33c8e1765c73d4049d0f4b40f\nF test/in6.test 62d943a02f722948f4410ee0b53c3cb39acd7c41afb083df8d7004238fe90a20\nF test/incrblob.test c9b96afc292aeff43d6687bcb09b0280aa599822\nF test/incrblob2.test a494c9e848560039a23974b9119cfc2cf3ad3bd15cc2694ee6367ae537ef8f1f\nF test/incrblob3.test d8d036fde015d4a159cd3cbae9d29003b37227a4\nF test/incrblob4.test 21a52a6843a56cdcce968c6a86b72a7066d0e6ba\nF test/incrblob_err.test 89372a28f1d98254f03fed705f9efcd34ef61a674df16d2dbb4726944a2de5e9\nF test/incrblobfault.test 74dd8ac108304cea0b4a0df6df63a1567e558758\nF test/incrcorrupt.test 6c567fbf870aa9e91866fe52ce6f200cd548939a\nF test/incrvacuum.test 2aaee202b1f230e55779f70d155f6ba67bbdff8481d650214d256ab0f97d4a2b\nF test/incrvacuum2.test 7d26cfda66c7e55898d196de54ac4ec7d86a4e3d\nF test/incrvacuum3.test 75256fb1377e7c39ef2de62bfc42bbff67be295a\nF test/incrvacuum_ioerr.test 6ae2f783424e47a0033304808fe27789cf93e635\nF test/index.test a2e948ed949e575487b5c1d521767d4584ac42d352f2dcd8e48004638e7bc7dc\nF test/index2.test f835d5e13ca163bd78c4459ca15fd2e4ed487407\nF test/index3.test 51685f39345462b84fcf77eb8537af847fdf438cc96b05c45d6aaca4e473ade0\nF test/index4.test ab92e736d5946840236cd61ac3191f91a7856bf6\nF test/index5.test 8621491915800ec274609e42e02a97d67e9b13e7\nF test/index6.test f172653b35b20233e59200e8b92a76db61bf7285437bf777b93b306ba26a47e7\nF test/index7.test 1d764c0cca45f5a76150b08e127ccc8d52492cfa788b5fafed4be784a351b020\nF test/index8.test bc2e3db70e8e62459aaa1bd7e4a9b39664f8f9d7\nF test/index9.test 0aa3e509dddf81f93380396e40e9bb386904c1054924ba8fa9bcdfe85a8e7721\nF test/indexedby.test a52c8c6abfae4fbfb51d99440de4ca1840dbacc606b05e29328a2a8ba7cd914e\nF test/indexexpr1.test 284e119999d132cc8bf37735a928c9859b28e8e295d02b7a6a4f93977c7f9ba5\nF test/indexexpr2.test dba11dbb0a58fcba4cd694f46b4004976123b81b0501f525d43c9be59f0207b1\nF test/indexfault.test 98d78a8ff1f5335628b62f886a1cb7c7dac1ef6d48fa39c51ec871c87dce9811\nF test/init.test 15c823093fdabbf7b531fe22cf037134d09587a7\nF test/insert.test 4e3f0de67aac3c5be1f4aaedbcea11638f1b5cdc9a3115be14d19aa9db7623c6\nF test/insert2.test 4d14b8f1b810a41995f6286b64a6943215d52208\nF test/insert3.test 1b7db95a03ad9c5013fdf7d6722b6cd66ee55e30\nF test/insert4.test fb9e0f752c75f453555990250b449f6d123ae6a3ebf054d14e4470de4498dce3\nF test/insert5.test 394f96728d1258f406fe5f5aeb0aaf29487c39a6\nF test/insertfault.test ac63d14ea3b49c573673a572f4014b9117383a03e497c58f308b5c776e4a7f74\nF test/instr.test 107df2b9b74a4b59315916b575590a08f2a714de0754abe541f10a0971d0a2a4\nF test/instrfault.test 0f870b218ea17cd477bb19ed330eecdb460dd53a\nF test/intarray.test bb976b0b3df0ebb6a2eddfb61768280440e672beba5460ed49679ea984ccf440\nF test/interrupt.test 16ea879ec728cb76414c148c5f24afd5d1f91054\nF test/interrupt2.test e4408ca770a6feafbadb0801e54a0dcd1a8d108d\nF test/intpkey.test ac71107a49a06492b69b82aafaf225400598d3c8\nF test/intreal.test 2a87e85a5949bd55e41ef04c58f5800587c5380bdbc559ff1c79b614b0e6a533\nF test/io.test f95bca1783b01ea7761671560d023360d2dfa4cc\nF test/ioerr.test 470fcc78e9cd352d162baf782fe301ea807d764241f58a48fc58109c2dfcdb6b\nF test/ioerr2.test 2593563599e2cc6b6b4fcf5878b177bdd5d8df26\nF test/ioerr3.test d3cec5e1a11ad6d27527d0d38573fbff14c71bdd\nF test/ioerr4.test f130fe9e71008577b342b8874d52984bd04ede2c\nF test/ioerr5.test 2edfa4fb0f896f733071303b42224df8bedd9da4\nF test/ioerr6.test a395a6ab144b26a9e3e21059a1ab6a7149cca65b\nF test/istrue.test 75327829744e65cc8700e69340b8e6c192e10e39dfae7ccb0e970d3c4f49090a\nF test/join.test 99e1d82fada7a1df9002a7b1160bd231c91077b9372492d5e18bfa1d1694d43c\nF test/join2.test 10f7047e723ebd68b2f47189be8eed20451a6f665d8bf46f1774c640d1062417\nF test/join3.test 6f0c774ff1ba0489e6c88a3e77b9d3528fb4fda0\nF test/join4.test 1a352e4e267114444c29266ce79e941af5885916\nF test/join5.test 3a96dc62f0b45402d7207e22d1993fe0c2fce1c57644a11439891dd62b990eb7\nF test/join6.test cfe6503791ceb0cbb509966740286ec423cbf10b\nF test/journal1.test c7b768041b7f494471531e17abc2f4f5ebf9e5096984f43ed17c4eb80ba34497\nF test/journal2.test 9dac6b4ba0ca79c3b21446bbae993a462c2397c4\nF test/journal3.test 7c3cf23ffc77db06601c1fcfc9743de8441cb77db9d1aa931863d94f5ffa140e\nF test/jrnlmode.test 9b5bc01dac22223cb60ec2d5f97acf568d73820794386de5634dcadbea9e1946\nF test/jrnlmode2.test 8759a1d4657c064637f8b079592651530db738419e1d649c6df7048cd724363d\nF test/jrnlmode3.test 556b447a05be0e0963f4311e95ab1632b11c9eaa\nF test/json101.test bb71538005f2d9e18620bdd3b76839a93ca0be61903eb8d751a64e78cf99b8fb\nF test/json102.test eeb54efa221e50b74a2d6fb9259963b48d7414dca3ce2fdfdeed45cb28487bc1\nF test/json103.test aff6b7a4c17d5a20b487a7bc1a274bfdc63b829413bdfb83bedac42ec7f67e3b\nF test/json104.test 317f4ec4b2d87afbba4d2460cf5be297aea76f2285eb618d276dbcd40a50950f\nF test/json105.test 45f7d6a9a54c85f8a9589b68d3e7a1f42d02f2359911a8cdbad1f9988f571173\nF test/keyword1.test 37ef6bba5d2ed5b07ecdd6810571de2956599dff\nF test/kvtest.c 94da54bb66aae7a54e47cf7e4ea4acecc0f217560f79ad3abfcc0361d6d557ba\nF test/lastinsert.test 42e948fd6442f07d60acbd15d33fb86473e0ef63\nF test/laststmtchanges.test ae613f53819206b3222771828d024154d51db200\nF test/lemon-test01.y 58b764610fd934e189ffbb0bbfa33d171b9cb06019b55bdc04d090d6767e11d7\nF test/like.test 3d702d79bf871fa32985b1ce334294c587e3948d3ab972001e811a58577e8b3c\nF test/like2.test 3b2ee13149ba4a8a60b59756f4e5d345573852da\nF test/like3.test 4f940ad275c006319950054a7a65661f476772171b82b6fdf795e4dda36f246f\nF test/limit.test 0c99a27a87b14c646a9d583c7c89fd06c352663e\nF test/limit2.test 9409b033284642a859fafc95f29a5a6a557bd57c1f0d7c3f554bd64ed69df77e\nF test/loadext.test faa4f6eed07a5aac35d57fdd7bc07f8fc82464cfd327567c10cf0ba3c86cde04\nF test/loadext2.test 0408380b57adca04004247179837a18e866a74f7\nF test/lock.test be4fe08118fb988fed741f429b7dd5d65e1c90db\nF test/lock2.test 5242d8ac4e2d59c403aebff606af449b455aceff\nF test/lock3.test f271375930711ae044080f4fe6d6eda930870d00\nF test/lock4.test 27143363eda1622f03c133efc8db808fc331afd973486cb571ea71cd717d37b8\nF test/lock5.test c6c5e0ebcb21c61a572870cc86c0cb9f14cede38\nF test/lock6.test ad5b387a3a8096afd3c68a55b9535056431b0cf5\nF test/lock7.test 49f1eaff1cdc491cc5dee3669f3c671d9f172431\nF test/lock_common.tcl 2f3f7f2e9637f93ccf609df48ef5b27a50278b6b1cd752b445d52262e5841413\nF test/lookaside.test 5a828e7256f1ee4da8e1bdaa03373a3ccdb0f1ff98dfa82e9b76cb41a45b1083\nF test/main.test 6bbb3999fd461eb8fb335cbab97409a3d7f91bbb8da60635e8be3e4a04a77772\nF test/make-where7.tcl 05c16b5d4f5d6512881dfec560cb793915932ef9\nF test/malloc.test 18dd1c4188c81ca79cf123527c71b19ee0c31feb9947fdffb0dc6ceb1436816a\nF test/malloc3.test 6e88bae6312854a4adb4ecc2a6a5ea8c59b4db778b724ba718e1c43fc8c3c136\nF test/malloc4.test 957337613002b7058a85116493a262f679f3a261\nF test/malloc5.test 2e4ad7684a13389a44a840499cd47173a8d05f22f082d7d083eece433a7a64eb\nF test/malloc6.test 2f039d9821927eacae43e1831f815e157659a151\nF test/malloc7.test 7c68a32942858bc715284856c5507446bba88c3a\nF test/malloc8.test 9b7a3f8cb9cf0b12fff566e80a980b1767bd961d\nF test/malloc9.test 2307c6ee3703b0a21391f3ea92388b4b73f9105e\nF test/mallocA.test aea76f2dd8bcc2d19748f6b911e876cefda74a563753bf26af046e9d34bb97e6\nF test/mallocAll.test 98f1be74bc9f49a858bc4f361fc58e26486798be\nF test/mallocB.test bc475ab850cda896142ab935bbfbc74c24e51ed6\nF test/mallocC.test 3dffe16532f109293ce1ccecd0c31dca55ef08c4\nF test/mallocD.test f78c295e8e18ea3029e65ca08278690e00c22100\nF test/mallocE.test db1ed69d7eded1b080952e2a7c37f364ad241b08\nF test/mallocF.test 2d5c590ebc2fc7f0dcebdf5aa8498b9aed69107e\nF test/mallocG.test 0ff91b65c50bdaba680fb75d87fe4ad35bb7934f\nF test/mallocH.test 79b65aed612c9b3ed2dcdaa727c85895fd1bfbdb\nF test/mallocI.test 6c23a71df077fa5d387be90e7e669c5b368ca38a\nF test/mallocJ.test b5d1839da331d96223e5f458856f8ffe1366f62e\nF test/mallocK.test 1f4b5efbf61715ab79b20b38739ff4b3d110ceb53f54e5db6da1f01c083707ab\nF test/mallocL.test fb311ff80afddf3b1a75e52289081f4754d901dc\nF test/mallocM.test 78bbe9d3da84a5c679123cdb40d7b2010b18fc46e13897e4f253c6ba6fbff134\nF test/malloc_common.tcl aac62499b76be719fac31e7a3e54a7fd53272e7f\nF test/malloctraceviewer.tcl b7a54595270c1d201abf1c3f3d461f27eaf24cdef623ad08a0fe5e411264c8a9\nF test/manydb.test 28385ae2087967aa05c38624cec7d96ec74feb3e\nF test/mem5.test c6460fba403c5703141348cd90de1c294188c68f\nF test/memdb.test c1f2a343ad14398d5d6debda6ea33e80d0dafcc7\nF test/memdb1.test 58d92c2bf622cc5f0f41461e1b35cf64f3f787199544c2c1dada37d88753f9d4\nF test/memleak.test 10b9c6c57e19fc68c32941495e9ba1c50123f6e2\nF test/memsubsys1.test 9e7555a22173b8f1c96c281ce289b338fcba2abe8b157f8798ca195bbf1d347e\nF test/memsubsys2.test 3e4a8d0c05fd3e5fa92017c64666730a520c7e08\nF test/minmax.test 6751e87b409fe11b02e70a306d846fa544e25a41\nF test/minmax2.test 1edf66901ddfab26ae1e04165e8da834c8d3284e2b20aefb26b80ef217962eab\nF test/minmax3.test cc1e8b010136db0d01a6f2a29ba5a9f321034354\nF test/minmax4.test 272ca395257f05937dc96441c9dde4bc9fbf116a8d4fa02baeb0d13d50e36c87\nF test/misc1.test 7ce84b25df9872e7d7878613a96815d2ba5bc974ac4e15a50118dde8f3917599\nF test/misc2.test 00d7de54eda90e237fc9a38b9e5ccc769ebf6d4d\nF test/misc3.test cf3dda47d5dda3e53fc5804a100d3c82be736c9d\nF test/misc4.test 10cd6addb2fa9093df4751a1b92b50440175dd5468a6ec84d0386e78f087db0e\nF test/misc5.test c4aeaa0fa28faa08f2485309c38db4719e6cd1364215d5687a5b96d340a3fa58\nF test/misc6.test 953cc693924d88e6117aeba16f46f0bf5abede91\nF test/misc7.test 4f21954012e4eb0a923c54a311f38c81bf6798ccdd7b51584db46d4007f63daa\nF test/misc8.test 8fb0f31d7a8aed484d759773ab8ad12ec746a477f4a67394a4af0e677494c3ca\nF test/misuse.test 9e7f78402005e833af71dcab32d048003869eca5abcaccc985d4f8dc1d86bcc7\nF test/mjournal.test 28a08d5cb5fb5b5702a46e19176e45e964e0800d1f894677169e79f34030e152\nF test/mmap1.test fb04e0c10492455007624ade884ca0c8852ff3e4e11d95408f9709ca2ef7f626\nF test/mmap2.test 9d6dd9ddb4ad2379f29cc78f38ce1e63ed418022\nF test/mmap3.test b3c297e78e6a8520aafcc1a8f140535594c9086e\nF test/mmap4.test 2e2b4e32555b58da15176e6fe750f17c9dcf7f93\nF test/mmapfault.test d4c9eff9cd8c2dc14bc43e71e042f175b0a26fe3\nF test/mmapwarm.test 2272005969cd17a910077bd5082f70bc1fefad9a875afec7fc9af483898ecaf3\nF test/multiplex.test dc0d67b66f84b484a83cb8bbdf3f0a7f49562ccd\nF test/multiplex2.test 580ca5817c7edbe4cc68fa150609c9473393003a\nF test/multiplex3.test d228f59eac91839a977eac19f21d053f03e4d101\nF test/multiplex4.test e8ae4c4bd70606a5727743241f13b5701990abe4\nF test/mutex1.test ea2cc74d97f077b9e74c84cbd024f14d79a8126f\nF test/mutex2.test bfeaeac2e73095b2ac32285d2756e3a65e681660\nF test/nan.test 437d40e6d0778b050d7750726c0cbd2c9936b81962926e8f8c48ca698f00f4d1\nF test/nockpt.test 8c43b25af63b0bd620cf1b003529e37b6f1dc53bd22690e96a1bd73f78dde53a\nF test/nolock.test f196cf8b8fbea4e2ca345140a2b3f3b0da45c76e\nF test/normalize.test f23b6c5926c59548635fcf39678ac613e726121e073dd902a3062fbb83903b72\nF test/notify1.test 669b2b743618efdc18ca4b02f45423d5d2304abf\nF test/notify2.test 2ecabaa1305083856b7c39cf32816b612740c161\nF test/notify3.test 10ff25cde502e72a92053a2f215d64bece4ef934\nF test/notnull.test a37b663d5bb728d66fc182016613fb8e4a0a4bbf3d75b8876a7527f7d4ed3f18\nF test/null.test 0dcce4f04284ec66108c503327ad6d224c0752b3\nF test/nulls1.test c8fc1b223f06e60007e0cd3e498ccb10195cf75a18fc3312508b3cf679ecb806\nF test/numcast.test 5d126f7f581432e86a90d1e35cac625164aec4a1\nF test/numindex1.test 20a5450d4b056e48cd5db30e659f13347a099823\nF test/offset1.test f06b83657bcf26f9ce805e67450e189e282143b2\nF test/openv2.test 0d3040974bf402e19b7df4b783e447289d7ab394\nF test/optfuzz-db01.c a0c256905c8ac79f9a5de2f374a3d9f757bef0dca2a238dc7c10cc8a38031834\nF test/optfuzz-db01.txt 21f6bdeadc701cf11528276e2a55c70bfcb846ba42df327f979bd9e7b6ce7041\nF test/optfuzz.c 50e330304eb1992e15ddd11f3daaad9bcc0d9aaad09cb2bcc77f9515df2e88b1\nF test/orderby1.test e4501f54721f804ca56922e253403ac6775f88e9f07569994ce99212b3ca5b10\nF test/orderby2.test bc11009f7cd99d96b1b11e57b199b00633eb5b04\nF test/orderby3.test 8619d06a3debdcd80a27c0fdea5c40b468854b99\nF test/orderby4.test 4d39bfbaaa3ae64d026ca2ff166353d2edca4ba4\nF test/orderby5.test 5f4d6cb93cc2f6d3f4228354310a2ce1fbd95d5bbffcba8c6482eeb62a466407\nF test/orderby6.test 8b38138ab0972588240b3fca0985d2e400432859\nF test/orderby7.test 3d1383d52ade5b9eb3a173b3147fdd296f0202da\nF test/orderby8.test 23ef1a5d72bd3adcc2f65561c654295d1b8047bd\nF test/orderby9.test 87fb9548debcc2cd141c5299002dd94672fa76a3\nF test/orderbyA.test df608e59efc2ef50c1eddf1a773b272de3252e9401bfec86d04b52fd973866d5\nF test/oserror.test 1fc9746b83d778e70d115049747ba19c7fba154afce7cc165b09feb6ca6abbc5\nF test/ossfuzz.c 9636dad2092a05a32110df0ca06713038dd0c43dd89a77dabe4b8b0d71096715\nF test/ossshell.c f125c5bd16e537a2549aa579b328dd1c59905e7ab1338dfc210e755bb7b69f17\nF test/ovfl.test 199c482696defceacee8c8e0e0ef36da62726b2f\nF test/pager1.test 1e9ee778bdeaf4f7f09997d029cdaca6a42dfc2092edafe4f5e590acbf1eab13\nF test/pager2.test 67b8f40ae98112bcdba1f2b2d03ea83266418c71\nF test/pager3.test 4e9a83d6ca0838d7c602c9eb93d1357562d9059c1e02ffb138a8271020838370\nF test/pager4.test a122e9e6925d5b23b31e3dfef8c6a44bbf19590e\nF test/pagerfault.test 63c5da625562c66345ab4528790327ca63db2f6f9cbae2aba8cb7c51de3d1628\nF test/pagerfault2.test caf4c7facb914fd3b03a17b31ae2b180c8d6ca1f\nF test/pagerfault3.test 1003fcda009bf48a8e22a516e193b6ef0dd1bbd8\nF test/pageropt.test 84e4cc5cbca285357f7906e99b21be4f2bf5abc0\nF test/pagesize.test 5769fc62d8c890a83a503f67d47508dfdc543305\nF test/parser1.test 6ccdf5e459a5dc4673d3273dc311a7e9742ca952dd0551a6a6320d27035ce4b3\nF test/pcache.test c8acbedd3b6fd0f9a7ca887a83b11d24a007972b\nF test/pcache2.test af7f3deb1a819f77a6d0d81534e97d1cf62cd442\nF test/percentile.test 4243af26b8f3f4555abe166f723715a1f74c77ff\nF test/permutations.test 8587800fe1a0eb01456a3f4500b821e54e3347e78acf11dbf05f4990530f6cee\nF test/pg_common.tcl 222a1bad1c41c308fa366313cd7b51b3be7e9b21c8736a421b974ac941693b54\nF test/pragma.test 59becdfd720b80d463ab750f69f7118fde10dfd556aa5d554f3bf6b7e5ea7533\nF test/pragma2.test e5d5c176360c321344249354c0c16aec46214c9f\nF test/pragma3.test 8300aa9c63cff1027006ca34bf413a148abbd6dcd471fa9a1ded322fe18c0df9\nF test/pragma4.test 10c624e45a83c0096a82a7579a5ff658542391d3b77355192da6572c8c17c00b\nF test/pragma5.test 2be6a44c91e8585ccb4c71c5f221ccebe0692a49557215a912916ed391188959\nF test/pragmafault.test 275edaf3161771d37de60e5c2b412627ac94cef11739236bec12ed1258b240f8\nF test/prefixes.test b524a1c44bffec225b9aec98bd728480352aa8532ac4c15771fb85e8beef65d9\nF test/printf.test 0300699733e53101b2ce48800518427249edd4053bb50fa0621c6607482f0fdb\nF test/printf2.test 30b5dd0b4b992dc5626496846ecce17ff592cacbcb11c3e589f3ac4d7e129dae\nF test/progress.test ebab27f670bd0d4eb9d20d49cef96e68141d92fb\nF test/ptrchng.test ef1aa72d6cf35a2bbd0869a649b744e9d84977fc\nF test/pushdown.test 5e72c51c5e33253ed639ccee1e01ce62d62b6eee5ca893cd82334e4ee7b1d7fc\nF test/queryonly.test 5f653159e0f552f0552d43259890c1089391dcca\nF test/quick.test 1681febc928d686362d50057c642f77a02c62e57\nF test/quota-glob.test 32901e9eed6705d68ca3faee2a06b73b57cb3c26\nF test/quota.test bfb269ce81ea52f593f9648316cd5013d766dd2a\nF test/quota2.test 7dc12e08b11cbc4c16c9ba2aa2e040ea8d8ab4b8\nF test/quote.test 626149eda89ee64d81a3790de370f9f0211921b11568a49c28c861f394330508\nF test/randexpr1.tcl 40dec52119ed3a2b8b2a773bce24b63a3a746459\nF test/randexpr1.test eda062a97e60f9c38ae8d806b03b0ddf23d796df\nF test/rbu.test 168573d353cd0fd10196b87b0caa322c144ef736\nF test/rdonly.test 64e2696c322e3538df0b1ed624e21f9a23ed9ff8\nF test/recover.test ccb8c2623902a92ebb76770edd075cb4f75a4760bb7afde38026572c6e79070d\nF test/regexp1.test 497ea812f264d12b6198d6e50a76be4a1973a9d8\nF test/regexp2.test 40e894223b3d6672655481493f1be12012f2b33c\nF test/reindex.test cd9d6021729910ece82267b4f5e1b5ac2911a7566c43b43c176a6a4732e2118d\nF test/releasetest.tcl fb76d8fcc95ac29d6356cd9e52b726ab9e43a24082897618dfbcb7c2b0049153 x\nF test/releasetest_data.tcl 9919fc6ac5bc92f8878fecfd1840db15999f660a6c9f609240b41aa62b885c88\nF test/resetdb.test 8062cf10a09d8c048f8de7711e94571c38b38168db0e5877ba7561789e5eeb2b\nF test/resolver01.test f4022acafda7f4d40eca94dbf16bc5fc4ac30ceb\nF test/rollback.test 06680159bc6746d0f26276e339e3ae2f951c64812468308838e0a3362d911eaa\nF test/rollback2.test bc868d57899dc6972e2b4483faae0e03365a0556941474eec487ae21d8d38bb6\nF test/rollbackfault.test 0e646aeab8840c399cfbfa43daab46fd609cf04a\nF test/round1.test 768018b04522ca420b1aba8a24bd76091d269f3bce3902af3ec6ebcee41ab21e\nF test/rowallock.test 3f88ec6819489d0b2341c7a7528ae17c053ab7cc\nF test/rowhash.test 0bc1d31415e4575d10cacf31e1a66b5cc0f8be81\nF test/rowid.test bfbd7b97d9267660be3c8f28507c4ed7f205196b8877c0db42df347c2e8845e3\nF test/rowvalue.test c39cc0be5e33f5294fc9224216198d6709d713ea948fdf8f42d89568e97912c9\nF test/rowvalue2.test 060d238b7e5639a7c5630cb5e63e311b44efef2b\nF test/rowvalue3.test 3068f508753af69884b12125995f023da0dbb256\nF test/rowvalue4.test 02e35f7762371c2f57ebd856aa056eac56cb27ef7715a0bb31eac1895a745356\nF test/rowvalue5.test c81c7d8cf36711ab37675ad7376084ae2a359cb6\nF test/rowvalue6.test d19b54feb604d5601f8614b15e214e0774c01087\nF test/rowvalue7.test c1cbdbf407029db01f87764097c6ac02a1c5a37efd2776eff32a9cdfdf6f2dba\nF test/rowvalue8.test 5900eddad9e2c3c2e26f1a95f74aafc1232ee5e0\nF test/rowvalue9.test d8dd2c6ecac432dadaa79e41dc2434f007be1b6b\nF test/rowvaluefault.test 7cd9ccc6c2fbdd881672984087aad0491bb75504\nF test/rowvaluevtab.test d166df5b666662de1ebf40d6f3849f8a76b34e17183a6cc7f81b420c462ce447\nF test/rtree.test 0c8d9dd458d6824e59683c19ab2ffa9ef946f798\nF test/run-wordcount.sh 891e89c4c2d16e629cd45951d4ed899ad12afc09\nF test/savepoint.test 1f8a6b1aea9a0d05837adc463d4bf47bd9d0f1c842f1c2a9caccd639baf34bf9\nF test/savepoint2.test 9b8543940572a2f01a18298c3135ad0c9f4f67d7\nF test/savepoint4.test c8f8159ade6d2acd9128be61e1230f1c1edc6cc0\nF test/savepoint5.test 0735db177e0ebbaedc39812c8d065075d563c4fd\nF test/savepoint6.test f41279c5e137139fa5c21485773332c7adb98cd7\nF test/savepoint7.test cde525ea3075283eb950cdcdefe23ead4f700daa\nF test/savepointfault.test f044eac64b59f09746c7020ee261734de82bf9b2\nF test/scanstatus.test 874e35011779b07725a47dbf1dd6282b0ca04af7e028fb0b534ee544b571be42\nF test/schema.test 5dd11c96ba64744de955315d2e4f8992e447533690153b93377dffb2a5ef5431\nF test/schema2.test 906408621ea881fdb496d878b1822572a34e32c5\nF test/schema3.test 1bc1008e1f8cb5654b248c55f27249366eb7ed38\nF test/schema4.test 3b26c9fa916abb6dadf894137adcf41b7796f7b9\nF test/schema5.test 29699b4421f183c8f0e88bd28ce7d75d13ea653e\nF test/schema6.test e4bd1f23d368695eb9e7b51ef6e02ca0642ea2ab4a52579959826b5e7dce1f9b\nF test/schemafault.test 1936bceca55ac82c5efbcc9fc91a1933e45c8d1e1d106b9a7e56c972a5a2a51e\nF test/securedel.test 2f70b2449186a1921bd01ec9da407fbfa98c3a7a5521854c300c194b2ff09384\nF test/securedel2.test 2d54c28e46eb1fd6902089958b20b1b056c6f1c5\nF test/select1.test b887331202618dbdabed92446b661ebd95a55ef3923700af56ed71266e9c1157\nF test/select2.test 352480e0e9c66eda9c3044e412abdf5be0215b56\nF test/select3.test 3905450067c28766bc83ee397f6d87342de868baa60f2bcfd00f286dfbd62cb9\nF test/select4.test 5389d9895968d1196c457d59b3ee6515d771d328\nF test/select5.test df9ec0d218cedceb4fe7b63262025b547b50a55e59148c6f40b60ca25f1d4546\nF test/select6.test 319d45e414cdd321bf17cfacedaf19e3935ad64dac357c53f1492338c6e9b801\nF test/select7.test f659f231489349e8c5734e610803d7654207318f\nF test/select8.test 8c8f5ae43894c891efc5755ed905467d1d67ad5d\nF test/select9.test aebc2bb0c3bc44606125033cbcaac2c8d1f33a95\nF test/selectA.test b8a590f6493cad5b0bb4dfe1709bf7dcda0b6c40bb4caf32d1e36a89eebc8fc5\nF test/selectB.test 954e4e49cf1f896d61794e440669e03a27ceea25\nF test/selectC.test e25243f8ca503e06f252eb0218976d07cfeceac3\nF test/selectD.test fc20452847a01775710090383cfb4423275d2f745fed61f34fbf37573ac0d214\nF test/selectE.test a8730ca330fcf40ace158f134f4fe0eb00c7edbf\nF test/selectF.test 21c94e6438f76537b72532fa9fd4710cdd455fc3\nF test/selectG.test 089f7d3d7e6db91566f00b036cb353107a2cca6220eb1cb264085a836dae8840\nF test/server1.test c2b00864514a68a0e6fd518659dc95d0050307a357a08969872bef027d785dc4\nF test/session.test 78fa2365e93d3663a6e933f86e7afc395adf18be\nF test/sessionfuzz-data1.db 1f8d5def831f19b1c74571037f0d53a588ea49a6c4ca2a028fc0c27ef896dbcb\nF test/sessionfuzz.c be9c4d4afd359ce80024d8b541b9b8a880510aef5cf263df56fc0e9b947727f1\nF test/shared.test 1826673eb5eb745fb91a3bdac99a7737057742ae38dcb0fe076a384d6727578b\nF test/shared2.test 03eb4a8d372e290107d34b6ce1809919a698e879\nF test/shared3.test ab693f9b6e156b8bfb2a0ad94f29fe69602a5d38\nF test/shared4.test c75f476804e76e26bf6fa0e7b421fb0ca7d07558\nF test/shared6.test 866bb4982c45ce216c61ded5e8fde4e7e2f3ffa9\nF test/shared7.test a81e99f83e6c51b02ac99c96fb3a2a7b5978c956\nF test/shared8.test 933ed7d71f598bb6c7a8c192a3cd30f2562fdccf514df383798599c34ffa672f\nF test/shared9.test 5f2a8f79b4d6c7d107a01ffa1ed05ae7e6333e21\nF test/sharedA.test 49d87ec54ab640fbbc3786ee3c01de94aaa482a3a9f834ad3fe92770eb69e281\nF test/sharedB.test 16cc7178e20965d75278f410943109b77b2e645e\nF test/shared_err.test 32634e404a3317eeb94abc7a099c556a346fdb8fb3858dbe222a4cbb8926a939\nF test/sharedlock.test 5ede3c37439067c43b0198f580fd374ebf15d304\nF test/shell1.test 3c9707dce15e8fdca529503378660f099777d3ddcedccf801a37589a405c5942\nF test/shell2.test e242a9912f44f4c23c3d1d802a83e934e84c853b\nF test/shell3.test ac8c2b744014c3e9a0e26bfd829ab65f00923dc1a91ffd044863e9423cc91494\nF test/shell4.test 1c6aef11daaa2d6830acaba3ac9cbec93fbc1c3d5530743a637f39b3987d08ce\nF test/shell5.test 23939a4c51f0421330ea61dbd3c74f9c215f5f8d3d1a94846da6ffc777a35458\nF test/shell6.test 1ceb51b2678c472ba6cf1e5da96679ce8347889fe2c3bf93a0e0fa73f00b00d3\nF test/shell7.test 115132f66d0463417f408562cc2cf534f6bbc6d83a6d50f0072a9eb171bae97f\nF test/shell8.test 96be02ea0c21f05b24c1883d7b711a1fa8525a68ab7b636aacf6057876941013\nF test/shmlock.test 3dbf017d34ab0c60abe6a44e447d3552154bd0c87b41eaf5ceacd408dd13fda5\nF test/shortread1.test bb591ef20f0fd9ed26d0d12e80eee6d7ac8897a3\nF test/show_speedtest1_rtree.tcl 32e6c5f073d7426148a6936a0408f4b5b169aba5\nF test/shrink.test 1b4330b1fd9e818c04726d45cb28db73087535ce\nF test/sidedelete.test f0ad71abe6233e3b153100f3b8d679b19a488329\nF test/skipscan1.test 2a64ca7b3e6246bb86b47c9051bfd324603b1b60675fe606513535267713e080\nF test/skipscan2.test 3eb703ce794f139e7b83567911046298bcde29606116727f9b700ce34f559d2d\nF test/skipscan3.test ec5bab3f81c7038b43450e7b3062e04a198bdbb5\nF test/skipscan5.test 67817a4b6857c47e0e33ba3e506da6f23ef68de2\nF test/skipscan6.test 0b4cd1b4ac9f84d91454df513c99a4932fa07e8f27b8049bea605068b3e34ac7\nF test/snapshot.test a504f2e7009f512ef66c719f0ea1c55a556bdaf1e1312c80a04d46fc1a3e9632\nF test/snapshot2.test 8d6ff5dd9cc503f6e12d408a30409c3f9c653507b24408d9cd7195931c89bc54\nF test/snapshot3.test 8744313270c55f6e18574283553d3c5c5fe4c5970585663613a0e75c151e599b\nF test/snapshot4.test d4e9347ef2fcabc491fc893506c7bbaf334da3be111d6eb4f3a97cc623b78322\nF test/snapshot_fault.test f6c5ef7cb93bf92fbb4e864ecc5c87df7d3a250064838822db5b4d3a5563ede4\nF test/snapshot_up.test a0a29c4cf33475fcef07c3f8e64af795e24ab91b4cc68295863402a393cdd41c\nF test/soak.test 18944cf21b94a7fe0df02016a6ee1e9632bc4e8d095a0cb49d95e15d5cca2d5c\nF test/softheap1.test 843cd84db9891b2d01b9ab64cef3e9020f98d087\nF test/sort.test c2adc635c2564241fefec0b3a68391ef6868fd3b\nF test/sort2.test cc23b7c19d684657559e8a55b02f7fcee03851d0\nF test/sort3.test 1480ed7c4c157682542224e05e3b75faf4a149e5\nF test/sort4.test 5c34d9623a4ae5921d956dfa2b70e77ed0fc6e5c\nF test/sort5.test 6b43ae0e2169b5ceed441844492e55ba7f1ae0790528395ddf7888ab3094525d\nF test/sorterref.test a13ed207a0eea3c7898f308f979bfb518f68c598ec737d2c494dfd3deaa83506\nF test/sortfault.test d4ccf606a0c77498e2beb542764fd9394acb4d66\nF test/speed1.test f2974a91d79f58507ada01864c0e323093065452\nF test/speed1p.explain d841e650a04728b39e6740296b852dccdca9b2cb\nF test/speed1p.test b180e98609c7677382cf618c0ec9b69f789033a8\nF test/speed2.test 53177056baf6556dcbdcf032bbdfc41c1aa74ded\nF test/speed3.test 694affeb9100526007436334cf7d08f3d74b85ef\nF test/speed4.test abc0ad3399dcf9703abed2fff8705e4f8e416715\nF test/speed4p.explain 6b5f104ebeb34a038b2f714150f51d01143e59aa\nF test/speed4p.test 377a0c48e5a92e0b11c1c5ebb1bc9d83a7312c922bc0cb05970ef5d6a96d1f0c\nF test/speedtest1.c f3bfe3c6a87cbd88e4c4e38005d972bcc1019d1b2fe9569425f86629b11f6c31\nF test/spellfix.test 951a6405d49d1a23d6b78027d3877b4a33eeb8221dcab5704b499755bb4f552e\nF test/spellfix2.test dfc8f519a3fc204cb2dfa8b4f29821ae90f6f8c3\nF test/spellfix3.test 0f9efaaa502a0e0a09848028518a6fb096c8ad33\nF test/spellfix4.test 51c7c26514ade169855c66bcf130bd5acfb4d7fd090cc624645ab275ae6a41fb\nF test/sqldiff1.test 28cd737cf1b0078b1ec1bbf425e674c47785835e\nF test/sqllimits1.test 264f4b0f941800ba139d25e33ee919c5d95fea06dfbe8ac291d6811a30984ca5\nF test/sqllog.test 6af6cb0b09f4e44e1917e06ce85be7670302517a\nF test/stat.test 05669008edc5ed950e817c24e8c4b66840fda64d8c76bae27e5fc1bd23d95675\nF test/statfault.test f525a7bf633e50afd027700e9a486090684b1ac1\nF test/stmt.test 54ed2cc0764bf3e48a058331813c3dbd19fc1d0827c3d8369914a5d8f564ec75\nF test/stmtvtab1.test 6873dfb24f8e79cbb5b799b95c2e4349060eb7a3b811982749a84b359468e2d5\nF test/subjournal.test 8d4e2572c0ee9a15549f0d8e40863161295107e52f07a3e8012a2e1fdd093c49\nF test/subquery.test d7268d193dd33d5505df965399d3a594e76ae13f\nF test/subquery2.test 90cf944b9de8204569cf656028391e4af1ccc8c0cc02d4ef38ee3be8de1ffb12\nF test/subselect.test 0966aa8e720224dbd6a5e769a3ec2a723e332303\nF test/substr.test 18f57c4ca8a598805c4d64e304c418734d843c1a\nF test/subtype1.test 7fe09496352f97053af1437150751be2d0a0cae8\nF test/superlock.test ec94f0556b6488d97f71c79f9061ae08d9ab8f12\nF test/swarmvtab.test 9a3fd5ab3e9b3c976ad1b3d7646aab725114f2ac26b59395d0778b33bab6cdaf\nF test/swarmvtab2.test c948cb2fdfc5b01d85e8f6d6504854202dc1a0782ab2a0ed61538f27cbd0aa5c\nF test/swarmvtab3.test 247aa38b6ebd2b99db2075847ae47e789ac34f1c2ab5c720dfcffd990004c544\nF test/swarmvtabfault.test 8a67a9f27c61073a47990829e92bc0c64420a807cb642b15a25f6c788210ed95\nF test/symlink.test 72b22238d4405ba34df8e60b335d290a3b1129fd5c260835c944c1e4e77288a9\nF test/symlink2.test 9531f475a53d8781c4f81373f87faf2e2aff4f5fb2102ec6386e0c827916a670\nF test/sync.test 89539f4973c010eda5638407e71ca7fddbcd8e0594f4c9980229f804d4333092\nF test/sync2.test 8f9f7d4f6d5be8ca8941a8dadcc4299e558cb6a1ff653a9469146c7a76ef2039\nF test/syscall.test a39d9a36f852ae6e4800f861bc2f2e83f68bbc2112d9399931ecfadeabd2d69d\nF test/sysfault.test c9f2b0d8d677558f74de750c75e12a5454719d04\nF test/tabfunc01.test 5ca6d004157a3e886a55a9387b960cc0db41acd88753eb597ff409ec6cfb1be0\nF test/table.test eb3463b7add9f16a5bb836badf118cf391b809d09fdccd1f79684600d07ec132\nF test/tableapi.test ecbcc29c4ab62c1912c3717c48ea5c5e59f7d64e4a91034e6148bd2b82f177f4\nF test/tableopts.test dba698ba97251017b7c80d738c198d39ab747930\nF test/tclsqlite.test c4a5f5af3672fbe28a0aa322b88d9d1ce2225b6b1284ea11ede2e6d38e7c812c\nF test/tempdb.test 4cdaa23ddd8acb4d79cbb1b68ccdfd09b0537aaba909ca69a876157c2a2cbd08\nF test/tempdb2.test 353864e96fd3ae2f70773d0ffbf8b1fe48589b02c2ec05013b540879410c3440\nF test/tempfault.test 0c0d349c9a99bf5f374655742577f8712c647900\nF test/temptable.test d2c9b87a54147161bcd1822e30c1d1cd891e5b30\nF test/temptable2.test d2940417496e2b9548e01d09990763fbe88c316504033256d51493e1f1a5ce6a\nF test/temptable3.test d11a0974e52b347e45ee54ef1923c91ed91e4637\nF test/temptrigger.test 38f0ca479b1822d3117069e014daabcaacefffcc\nF test/tester.tcl abba168acd7f01dbfa3ffdbf402d151eb97e8a824d9208e845ab34c194441483\nF test/thread001.test b61a29dd87cf669f5f6ac96124a7c97d71b0c80d9012746072055877055cf9ef\nF test/thread002.test e630504f8a06c00bf8bbe68528774dd96aeb2e58\nF test/thread003.test ee4c9efc3b86a6a2767516a37bd64251272560a7\nF test/thread004.test f51dfc3936184aaf73ee85f315224baad272a87f\nF test/thread005.test 50d10b5684399676174bd96c94ad4250b1a2c8b6\nF test/thread1.test df115faa10a4ba1d456e9d4d9ec165016903eae4\nF test/thread2.test f35d2106452b77523b3a2b7d1dcde2e5ee8f9e46\nF test/thread_common.tcl 334639cadcb9f912bf82aa73f49efd5282e6cadd\nF test/threadtest1.c 6029d9c5567db28e6dc908a0c63099c3ba6c383b\nF test/threadtest2.c a70a8e94bef23339d34226eb9521015ef99f4df8\nF test/threadtest3.c 38a612ea62854349ed66372f330a40d73c5cf956\nF test/threadtest4.c c1e67136ceb6c7ec8184e56ac61db28f96bd2925\nF test/time-wordcount.sh 8e0b0f8109367827ad5d58f5cc849705731e4b90\nF test/tkt-02a8e81d44.test 6c80d9c7514e2a42d4918bf87bf6bc54f379110c\nF test/tkt-18458b1a.test 6a62cb1ee50fa3c620da59e3a6f531eb38fceaf7e2166203816b724524e6f1d6\nF test/tkt-26ff0c2d1e.test c15bec890c4d226c0da2f35ff30f9e84c169cfef90e73a8cb5cec11d723dfa96\nF test/tkt-2a5629202f.test 0521bd25658428baa26665aa53ffed9367d33af2\nF test/tkt-2d1a5c67d.test be1326f3061caec85085f4c9ee4490561ca037c0\nF test/tkt-2ea2425d34.test 1cf13e6f75d149b3209a0cb32927a82d3d79fb28\nF test/tkt-31338dca7e.test 6fb8807851964da0d24e942f2e19c7c705b9fb58\nF test/tkt-313723c356.test 4b306ad45c736cedf2f5221f6155b92143244b6d\nF test/tkt-385a5b56b9.test 5204a7cba0e28c99df0acbf95af5e1af4d32965a7a14de6eccebf949607618b1\nF test/tkt-38cb5df375.test f3cc8671f1eb604d4ae9cf886ed4366bec656678\nF test/tkt-3998683a16.test 6d1d04d551ed1704eb3396ca87bb9ccc8c5c1eb7\nF test/tkt-3a77c9714e.test 90e3e8455ee945a4076d4c44062b8845708af24a880355328fe7008f2047c9f0\nF test/tkt-3fe897352e.test 27e26eb0f1811aeba4d65aba43a4c52e99da5e70\nF test/tkt-4a03edc4c8.test 91c0e135888cdc3d4eea82406a44b05c8c1648d0\nF test/tkt-4c86b126f2.test cbcc611becd0396890169ab23102dd70048bbc9a\nF test/tkt-4dd95f6943.test 3d0ce415d2ee15d3d564121960016b9c7be79407\nF test/tkt-4ef7e3cfca.test 3965ae11cc9cf6e334f9d7d3c1e20bf8d56254b1\nF test/tkt-54844eea3f.test a12b851128f46a695e4e378cca67409b9b8f5894\nF test/tkt-5d863f876e.test 726e76d725f6fe0eb2fc8a522b721b79807380ee\nF test/tkt-5e10420e8d.test 904d1687b3c06d43e5b3555bbcf6802e7c0ffd84\nF test/tkt-5ee23731f.test 9db6e1d7209dc0794948b260d6f82b2b1de83a9f\nF test/tkt-6bfb98dfc0.test 24780633627b5cfc0635a5500c2389ebfb563336\nF test/tkt-752e1646fc.test ea78d88d14fe9866bdd991c634483334639e13bf\nF test/tkt-78e04e52ea.test cb44d0f5e7940223be740a39913a1b9b9b30d7e4a17ed3349141f893bae1b8f2\nF test/tkt-7a31705a7e6.test 9e9c057b6a9497c8f7ba7b16871029414ccf6550e7345d9085d6d71c9a56bb6f\nF test/tkt-7bbfb7d442.test 7b2cd79c7a17ae6750e75ec1a7846712a69c9d18\nF test/tkt-80ba201079.test 105a721e6aad0ae3c5946d7615d1e4d03f6145b8\nF test/tkt-80e031a00f.test 9ee36348b761bf7c14261e002b75a4c0d5a04d4c\nF test/tkt-8454a207b9.test c583a9f814a82a2b5ba95207f55001c9f0cd816c\nF test/tkt-868145d012.test a5f941107ece6a64410ca4755c6329b7eb57a356\nF test/tkt-8c63ff0ec.test 258b7fc8d7e4e1cb5362c7d65c143528b9c4cbed\nF test/tkt-91e2e8ba6f.test 08c4f94ae07696b05c9b822da0b4e5337a2f54c5\nF test/tkt-94c04eaadb.test f738c57c7f68ab8be1c054415af7774617cb6223\nF test/tkt-9a8b09f8e6.test b2ef151d0984b2ebf237760dbeaa50724e5a0667\nF test/tkt-9d68c883.test 16f7cb96781ba579bc2e19bb14b4ad609d9774b6\nF test/tkt-9f2eb3abac.test cb6123ac695a08b4454c3792fbe85108f67fabf8\nF test/tkt-a7b7803e.test 159ef554234fa1f9fb318c751b284bd1cf858da4\nF test/tkt-a7debbe0.test e295fa83cd4416a8ca37b354eb5fadefc5e81fb55253db538d35261fe9c95067\nF test/tkt-a8a0d2996a.test 002e1cde8fc30c39611b52cf981c88200b858765748556822da72e0d32fac73e\nF test/tkt-b1d3a2e531.test 8f7576e41ca179289ee1a8fee28386fd8e4b0550\nF test/tkt-b351d95f9.test d14a503c414c5c58fdde3e80f9a3cfef986498c0\nF test/tkt-b72787b1.test a95e8cdad0b98af1853ac7f0afd4ab27b77bf5f3\nF test/tkt-b75a9ca6b0.test ade89229d853a67a21bbd5e6e1e787a8f9d21f19908d1b7fca6bf3d4d5aa0767\nF test/tkt-ba7cbfaedc.test b4c0deccc12aeb55cfdb57935b16b5d67c5a9877\nF test/tkt-bd484a090c.test 60460bf946f79a79712b71f202eda501ca99b898\nF test/tkt-bdc6bbbb38.test fc38bb09bdd440e3513a1f5f98fc60a075182d7d\nF test/tkt-c48d99d690.test ba61977d62ab612fc515b3c488a6fbd6464a2447\nF test/tkt-c694113d5.test 82c461924ada5c14866c47e85535b0b0923ba16a2e907e370061a5ca77f65d77\nF test/tkt-cbd054fa6b.test 708475ef4d730a6853512c8ce363bcbd3becf0e26826e1f4cd46e2f52ff38edf\nF test/tkt-d11f09d36e.test d999b548fef885d1d1afa49a0e8544ecf436869d\nF test/tkt-d635236375.test 9d37e988b47d87505bc9445be0ca447002df5d09\nF test/tkt-d82e3f3721.test bcc0dfba658d15bab30fd4a9320c9e35d214ce30\nF test/tkt-f3e5abed55.test d5a0126118142d13e27f6ce9f4c47096e9321c00\nF test/tkt-f67b41381a.test a23bc124c981662db712167bacd0ed8ad11abac9\nF test/tkt-f777251dc7a.test d1a8fc3eefb7a9e64d19ff24d5c8c94c34a632fb\nF test/tkt-f7b4edec.test d998a08ff2b18b7f62edce8e3044317c45efe6c7\nF test/tkt-f973c7ac31.test 28ef85c7f015477916795246d8286aeda39d4ead\nF test/tkt-fa7bf5ec.test 9102dfea58aa371d78969da735f9392c57e2e035\nF test/tkt-fc62af4523.test 72825d3febdedcd5593a27989fc05accdbfc2bb4\nF test/tkt-fc7bd6358f.test 634bb4af7d661e82d6b61b80c86727bad698e08f\nF test/tkt1435.test f8c52c41de6e5ca02f1845f3a46e18e25cadac00\nF test/tkt1443.test bacc311da5c96a227bf8c167e77a30c99f8e8368\nF test/tkt1444.test a9d72f9e942708bd82dde6c707da61c489e213e9\nF test/tkt1449.test 93584a449752d52b07d2cfc280a69842b6e16ed5\nF test/tkt1473.test 9d000af3e11a4450d4c596f5e58b4b0d24eb0f8b\nF test/tkt1501.test 2064f98e00871848af4b2f517e46c1a7fb2e32db\nF test/tkt1512.test a1df1f66caf0b9122d6220c15dcee230298c2c2f\nF test/tkt1514.test ddef38e34fea72eb1ab935ded9f17a3fb71dd9df\nF test/tkt1536.test 83ff7a7b6e248016f8d682d4f7a4ae114070d466\nF test/tkt1537.test e3a14332de9770be8ff14bd15c19a49cbec10808\nF test/tkt1567.test 52f329386ac77e59260d4af1c58490d61377db20\nF test/tkt1644.test 80b6a2bb17885f3cf1cb886d97cdad13232bb869\nF test/tkt1667.test 4700d931ed19ea3983e8e703becb28079250b460\nF test/tkt1873.test 0e1b8c023050a430c2525179ed4022ddc7c31264\nF test/tkt2141.test f543d96f50d5a5dc0bc744f7db74ea166720ce46\nF test/tkt2192.test ff40157e5f42e65f844255d220fc6b290470942f\nF test/tkt2213.test a9702175601a57b61aba095a233b001d6f362474\nF test/tkt2251.test 5aab8c7898cd2df2a68fe19289cc29e8f5cf8c82\nF test/tkt2285.test cca17be61cf600b397188e77e7143844d2b977e9\nF test/tkt2332.test fc955609b958ca86dfa102832243370a0cc84070\nF test/tkt2339.test 73bd17818924cd2ac442e5fd9916b58565739450\nF test/tkt2391.test ab7a11be7402da8b51a5be603425367aa0684567\nF test/tkt2409.test be0d60e7d283f639dccea4b0b5e1cd3a4851fb5b\nF test/tkt2450.test 77ed94863f2049c1420288ddfea2d41e5e0971d6\nF test/tkt2565.test 8be666e927cb207aae88188f31c331870878b650\nF test/tkt2640.test 28134f5d1e05658ef182520cf0b680fa3de5211b\nF test/tkt2643.test 3f3ebb743da00d4fed4fcf6daed92a0e18e57813\nF test/tkt2686.test 6ee01c9b9e9c48f6d3a1fdd553b1cc4258f903d6\nF test/tkt2767.test 569000d842678f9cf2db7e0d1b27cbc9011381b0\nF test/tkt2817.test f31839e01f4243cff7399ef654d3af3558cb8d8d\nF test/tkt2820.test 39940276b3436d125deb7d8ebeee053e4cf13213\nF test/tkt2822.test f391776423a7c0d0949edfce375708bfb0f3141e\nF test/tkt2832.test a9b0b74a02dca166a04d9e37739c414b10929caa\nF test/tkt2854.test e432965db29e27e16f539b2ba7f502eb2ccc49af\nF test/tkt2920.test a8737380e4ae6424e00c0273dc12775704efbebf\nF test/tkt2927.test 4752868b9eeeb07a217f7f19f4cbaac98d6d086d\nF test/tkt2942.test c5c87d179799ca6d1fbe83c815510b87cd5ec7ce\nF test/tkt3080.test 1bca7579260920a66b4dd7e196e807c0f25ff804\nF test/tkt3093.test fbdbc5b4969244ad11f540759003e361fcaf391f\nF test/tkt3121.test 536df66a02838c26a12fe98639354ca1290ca68b\nF test/tkt3201.test f1500ccecc0d578dc4cde7d3242008297c4d59b3\nF test/tkt3292.test 7bad4423cf5eb075dbb58511d66d46fe816744754c9f0050ae60157f71a4fca7\nF test/tkt3298.test 20fd8773b825cb602e033aa04f8602e1ebdcd93c\nF test/tkt3334.test 9756631e3c4aa3c416362c279e3c0953a83b7ca8274cb81a13264bb56296d8b0\nF test/tkt3346.test 6f67c3ed7db94dfc5df4f5f0b63809a1f611e01a\nF test/tkt3357.test 77c37c6482b526fe89941ce951c22d011f5922ed\nF test/tkt3419.test 1bbf36d7ea03b638c15804251287c2391f5c1f6b\nF test/tkt3424.test 61f831bd2b071bd128fa5d00fbda57e656ca5812\nF test/tkt3442.test a1fc47c669e651d16494de3ff349bcb53281456f2ca02c8bc14220b6044bbfe8\nF test/tkt3457.test 5651e2cbb94645b677ec663160b9e192b87b7d365aecdfb24e19f749575a6fc2\nF test/tkt3461.test 228ea328a5a21e8663f80ee3d212a6ad92549a19\nF test/tkt3493.test 1686cbde85f8721fc1bdc0ee72f2ef2f63139218\nF test/tkt3508.test d75704db9501625c7f7deec119fcaf1696aefb7d\nF test/tkt3522.test 22ce2ebbcb04a6be56c0977d405c207967318fd6\nF test/tkt3527.test 1a6a48441b560bdc53aec581a868eb576234874d\nF test/tkt3541.test 5dc257bde9bc833ab9cc6844bf170b998dbb950a\nF test/tkt3554.test f599967f279077bace39220cbe76085c7b423725\nF test/tkt3581.test 1966b7193f1e3f14951cce8c66907ae69454e9a3\nF test/tkt35xx.test f38c1b03713179d414969187c941466e44945b35\nF test/tkt3630.test 9a934c58c259f89a0ae6bb6bb846c56285a6fd0f\nF test/tkt3718.test 3b59dcb5c4e7754dacd91e7fd353a61492cc402a\nF test/tkt3731.test 0c5f4cbffe102d43c3b2188af91a9e36348f974b\nF test/tkt3757.test 10cd679a88675c880533083fc79ac04324525595\nF test/tkt3761.test b95ea9c98f21cf91325f18a984887e62caceab33\nF test/tkt3762.test 4d439ff7abdc8d9323150269d182c37c2d514576\nF test/tkt3773.test 7bca904d2a647a6a4a291bd86d7fd7c73855b789\nF test/tkt3791.test a6624b9a80b216a26cf473607f42f3e51898c267\nF test/tkt3793.test d90ffd75c52413908d15e1c44fc2ea9c80fcc449\nF test/tkt3810.test 09608d81c63a6ff3aaf7bc70717909c51f5f4048\nF test/tkt3824.test 150aa00bb6220672e5f0eb14dc8eaa36750425f0\nF test/tkt3832.test 2300d10d57562b89875b72148338ac3e14f8847d\nF test/tkt3838.test 292e72489101cd1320d7278dc111c173ebf334d4\nF test/tkt3841.test 4659845bc53f809a5932c61c6ce8c5bb9d6b947f\nF test/tkt3871.test d921703d07c68f4fd5312073215a17fa34b0401d\nF test/tkt3879.test 2ad5bef2c87e9991ce941e054c31abe26ef7fb90\nF test/tkt3911.test 74cd324f3ba653040cc6d94cc4857b290d12d633\nF test/tkt3918.test ea78bf164e4d55cbde0d83c671ef6fbe930a0032\nF test/tkt3922.test f26be40ab4fe6c00795629bd2006d96e270d9b1a\nF test/tkt3929.test cdf67acf5aa936ec4ffead81db87f8a71fe40e59\nF test/tkt3935.test e15261fedb9e30a4305a311da614a5d8e693c767\nF test/tkt3992.test f3e7d548ac26f763b47bc0f750da3d03c81071da\nF test/tkt3997.test a335fa41ca3985660a139df7b734a26ef53284bd\nF test/tkt4018.test 18dbc6617f7a4b90e938d1bd6d26ad18daafaf08\nF test/tokenize.test ce430a7aed48fc98301611429595883fdfcab5d7\nF test/tpch01.test 7c4eb8cdd79c568f46d344b3e789c9fdb8a766d112871352704861f3fca32a2a\nF test/trace.test a659a9862957f4789e37a92b3bf6d2caf5c86b02cdeefc41e850ae53acf6992a\nF test/trace2.test f5cb67ad3bc09e0c58e8cca78dfd0b5639259983\nF test/trace3.test 1dff966888773ff1bfea01c080caf15417892b3f998408fe920c4791f7337144\nF test/trans.test 6e1b4c6a42dba31bd65f8fa5e61a2708e08ddde6\nF test/trans2.test 62bd045bfc7a1c14c5ba83ba64d21ade31583f76\nF test/trans3.test 91a100e5412b488e22a655fe423a14c26403ab94\nF test/transitive1.test 293300f46916569f08875cdb2fe2134be2c27677\nF test/trigger1.test 746dc327e2a0817a22bfc6f5a5e423483d3e77b3733ac20a8fe939e6541b5e53\nF test/trigger2.test d15da46f7012832faf3e0c536b47024409d5fb1722d2bb77e29c06d96d704bb1\nF test/trigger3.test aa640bb2bbb03edd5ff69c055117ea088f121945\nF test/trigger4.test 74700b76ebf3947b2f7a92405141eb2cf2a5d359\nF test/trigger5.test 619391a3e9fc194081d22cefd830d811e7badf83\nF test/trigger6.test 0e411654f122552da6590f0b4e6f781048a4a9b9\nF test/trigger7.test e7ce54bfda67a88d778aea42544e151c465547a7e617127b6914c2221a6d53c1\nF test/trigger8.test 30cb0530bd7c4728055420e3f739aa00412eafa4\nF test/trigger9.test 2226ec795a33b0460ab5cf8891e9054cc7edef41\nF test/triggerA.test 837be862d8721f903dba3f3ceff05b32e0bee5214cf6ea3da5fadf12d3650e9d\nF test/triggerB.test 56780c031b454abac2340dbb3b71ac5c56c3d7fe\nF test/triggerC.test 29f5a28d0fe39e6e2c01f6e1f53f08c0955170ae10a63ad023e33cb0a1682a51\nF test/triggerD.test 8e7f3921a92a5797d472732108109e44575fa650\nF test/triggerE.test ede2e4bce4ba802337bd69d39447fa04a938e06d84a8bfc53c76850fc36ed86d\nF test/triggerF.test 5d76f0a8c428ff87a4d5ed52da06f6096a2c787a1e21b846111dfac4123de3ad\nF test/triggerG.test d5caeef6144ede2426dd13211fd72248241ff2ebc68e12a4c0bf30f5faa21499\nF test/tt3_checkpoint.c 9e75cf7c1c364f52e1c47fd0f14c4340a9db0fe1\nF test/tt3_index.c 39eec10a35f57672225be4d182862152896dee4a\nF test/tt3_lookaside1.c 0377e202c3c2a50d688cb65ba203afeda6fafeb9\nF test/tt3_stress.c c57d804716165811d979d4a719e05baccd79277f\nF test/tt3_vacuum.c 1753f45917699c9c1f66b64c717a717c9379f776\nF test/types.test bf816ce73c7dfcfe26b700c19f97ef4050d194ff\nF test/types2.test 1aeb81976841a91eef292723649b5c4fe3bc3cac\nF test/types3.test 99e009491a54f4dc02c06bdbc0c5eea56ae3e25a\nF test/unionvtab.test e1704ab1b4c1bb3ffc9da4681f8e85a0b909fd80b937984fc94b27415ac8e5a4\nF test/unionvtabfault.test e8759f3d14fb938ce9657e2342db34aeac0fb9bc1692b0d1ebb0069630151d06\nF test/unique.test 93f8b2ef5ea51b9495f8d6493429b1fd0f465264\nF test/unique2.test 3674e9f2a3f1fbbfd4772ac74b7a97090d0f77d2\nF test/unixexcl.test d936ba2b06794018e136418addd59a2354eeae97\nF test/unordered.test ffeea7747d5ba962a8009a20b7e53d68cbae05b063604c68702c5998eb50c981\nF test/update.test 6a1193fbcb4546b4467d24635b1504b8e746b41d3b66dc6ace07581a62ce58fb\nF test/update2.test 67455bc61fcbcf96923c45b3bc4f87bc72be7d67575ad35f134906148c7b06d3\nF test/upsert1.test 0b740c8488fd2f5a06ac317c9913f7ef1eda8282f2db58b544b89480c51efab3\nF test/upsert2.test 9c3cdbb1a890227f6504ce4b0e3de68f4cdfa16bb21d8641208a9239896c5a09\nF test/upsert3.test 88d7d590a1948a9cb6eac1b54b0642f67a9f35a1fc0f19b200e97d5d39e3179c\nF test/upsert4.test 25d2a1da92f149331ae0c51ca6e3eee78189577585eab92de149900d62994fa5\nF test/upsertfault.test f21ca47740841fdb4d61acfa7b17646d773e67724fe8c185b71c018db8a94b35\nF test/uri.test 3481026f00ade6dfe8adb7acb6e1e47b04369568\nF test/uri2.test 9d3ba7a53ee167572d53a298ee4a5d38ec4a8fb7\nF test/userauth01.test e740a2697a7b40d7c5003a7d7edaee16acd349a9\nF test/utf16align.test 54cd35a27c005a9b6e7815d887718780b6a462ae\nF test/vacuum-into.test 48f4cec354fb6f27c98ef58d2fe49a11b71ff131af0cd9140efacc9858b9f670\nF test/vacuum.test ce91c39f7f91a4273bf620efad21086b5aa6ef1d\nF test/vacuum2.test aa048abee196c16c9ba308465494009057b79f9b\nF test/vacuum3.test 77ecdd54592b45a0bcb133339f99f1ae0ae94d0d\nF test/vacuum4.test 7ea76b769fffeb41f925303b04cbcf5a5bbeabe55e4c60ae754ff24eeeb7c010\nF test/vacuum5.test 263b144d537e92ad8e9ca8a73cc6e1583f41cfd0dda9432b87f7806174a2f48c\nF test/vacuummem.test 7b42abb3208bd82dd23a7536588396f295a314f2\nF test/varint.test bbce22cda8fc4d135bcc2b589574be8410614e62\nF test/veryquick.test 57ab846bacf7b90cf4e9a672721ea5c5b669b661\nF test/view.test 10ea54300a097d7c0337fd104abffe4a4786d1598b94017a37efe0e0d3e04dd5\nF test/vtab1.test c5d9e90ed02bcacd776dcbb7360199d290f7f53c26b484ddece543060c54319f\nF test/vtab2.test 14d4ab26cee13ba6cf5c5601b158e4f57552d3b055cdd9406cf7f711e9c84082\nF test/vtab3.test b45f47d20f225ccc9c28dc915d92740c2dee311e\nF test/vtab4.test 8e73ed268f3d596bc3590f45fc948fb40f28e9c3\nF test/vtab5.test 889f444970393c73f1e077e2bdc5d845e157a391\nF test/vtab6.test 8e789f526e6594cf7ae933d1adee0caa87dc9f78\nF test/vtab7.test 70c6f4a1d6177144a8236e4172d5fba92e683440374664ad1f04851fbb335d3c\nF test/vtab8.test e19fa4a538fcd1bb66c22825fa8f71618fb13583\nF test/vtab9.test ea58d2b95d61955f87226381716b2d0b1d4e4f9b\nF test/vtabA.test 1317f06a03597eee29f40a49b6c21e1aaba4285f\nF test/vtabB.test 04df5dc531b9f44d9ca65b9c1b79f12b5922a796\nF test/vtabC.test 4528f459a13136f982e75614d120aef165f17292\nF test/vtabD.test 05b3f1d77117271671089e48719524b676842e96\nF test/vtabE.test 2a143fe75a11275781d1fd1988d86b66a3f69cb98f4add62e3da8fd0f637b45f\nF test/vtabF.test 1918844c7c902f6a16c8dacf1ec8f84886d6e78b\nF test/vtabH.test 2efb5a24b0bb50796b21eca23032cfb77abfa4b0c03938e38ce5897abac404ca\nF test/vtabI.test 751b07636700dbdea328e4265b6077ccd6811a3f\nF test/vtabJ.test d7b73675708cf63cfcb9d443bb451fc01a028347275b7311e51f9fdf3ca6757f\nF test/vtab_alter.test 736e66fb5ec7b4fee58229aa3ada2f27ec58bc58c00edae4836890c3784c6783\nF test/vtab_err.test dcc8b7b9cb67522b3fe7a272c73856829dae4ab7fdb30399aea1b6981bda2b65\nF test/vtab_shared.test 5253bff2355a9a3f014c15337da7e177ab0ef8ad\nF test/vtabdrop.test 65d4cf6722972e5499bdaf0c0d70ee3b8133944a4e4bc31862563f32a7edca12\nF test/wal.test cdf0ca6cc0447520d19ef1c83287824ebeb3e82d75af856511ba96841a79fc9b\nF test/wal2.test 537f59e5c5932e3b45bf3591ae3e48a2601360c2e52821b633e222fe6ebd5b09\nF test/wal3.test 2a93004bc0fb2b5c29888964024695bade278ab2\nF test/wal4.test 4744e155cd6299c6bd99d3eab1c82f77db9cdb3c\nF test/wal5.test 9c11da7aeccd83a46d79a556ad11a18d3cb15aa9\nF test/wal6.test b602704e4b066199bc89d91ca9000f335dcf4572\nF test/wal64k.test 2a525c0f45d709bae3765c71045ccec5df7d100ccbd3a7860fdba46c9addb965\nF test/wal7.test 2ae8f427d240099cc4b2dfef63cff44e2a68a1bd\nF test/wal8.test d9df3fba4caad5854ed69ed673c68482514203c8\nF test/wal9.test 378e76a9ad09cd9bee06c172ad3547b0129a6750\nF test/wal_common.tcl a98f17fba96206122eff624db0ab13ec377be4fe\nF test/walbak.test 018d4e5a3d45c6298d11b99f09a8ef6876527946\nF test/walbig.test f437473a16cfb314867c6b5d1dbcd519e73e3434\nF test/walblock.test be48f3a75eff0b4456209f26b3ce186c2015497d\nF test/walcksum.test bb234a1bb42248b3515d992b719708015c384278\nF test/walcrash.test 21038858cc552077b0522f50b0fa87e38139306a\nF test/walcrash2.test a0edab4e5390f03b99a790de89aad15d6ec70b36\nF test/walcrash3.test e426aa58122d20f2b9fbe9a507f9eb8cab85b8af\nF test/walcrash4.test e7b6e7639a950a0cca8e210e248c8dad4d63bf20\nF test/walfault.test 09b8ad7e52d2f54bce50e31aa7ea51412bb9f70ac13c74e669ddcd8b48b0d98d\nF test/walfault2.test e039ac66c78d5561683cacde04097213cdad3b58e2b3f3fe1112862217bfd915\nF test/walhook.test ed00a40ba7255da22d6b66433ab61fab16a63483\nF test/walmode.test cd6e7cff618eaaa5910ce57c3657aa50110397f86213886a2400afb9bfec7b7b\nF test/walnoshm.test 84ca10c544632a756467336b7c3b864d493ee496\nF test/waloverwrite.test dad2f26567f1b45174e54fbf9a8dc1cb876a7f03\nF test/walpersist.test 8c6b7e3ec1ba91b5e4dc4e0921d6d3f87cd356a6\nF test/walprotocol.test a112aba0b79e3adeaa485fed09484b32c654e97df58e454aa8489ac2cd57bf84\nF test/walprotocol2.test 7d3b6b4bf0b12f8007121b1e6ef714bc99101fb3b48e46371df1db868eebc131\nF test/walro.test cb438d05ba0d191f10b688e39c4f0cd5b71569a1d1f4440e5bdf3c6880e08c20\nF test/walro2.test 0e79dd15cbdb4f482c01ea248373669c732414a726b357d04846a816afafb768\nF test/walrofault.test c70cb6e308c443867701856cce92ad8288cd99488fa52afab77cca6cfd51af68\nF test/walshared.test 0befc811dcf0b287efae21612304d15576e35417\nF test/walslow.test c05c68d4dc2700a982f89133ce103a1a84cc285f\nF test/walthread.test 14b20fcfa6ae152f5d8e12f5dc8a8a724b7ef189f5d8ef1e2ceab79f2af51747\nF test/walvfs.test ca81c9f427e0e5434076dfa948fd1d8e6d5ddd192b2fb6991635d81da5f3f5d4\nF test/wapp.tcl b440cd8cf57953d3a49e7ee81e6a18f18efdaf113b69f7d8482b0710a64566ec\nF test/wapptest.tcl 3cca775aede0591756a1fc0da55bbb3715d8c363873fd2cfdd4d555b0a4af57d x\nF test/where.test 19c709c9f0f6ed12c23f909f6592aa55fba34269d5a2898537aa27a22b9ce650\nF test/where2.test 478d2170637b9211f593120648858593bf2445a1\nF test/where3.test 2341a294e17193a6b1699ea7f192124a5286ca6acfcc3f4b06d16c931fbcda2c\nF test/where4.test 4a371bfcc607f41d233701bdec33ac2972908ba8\nF test/where5.test fdf66f96d29a064b63eb543e28da4dfdccd81ad2\nF test/where6.test 5da5a98cec820d488e82708301b96cb8c18a258b\nF test/where7.test 75722434c486ac9e74718caa6cce234f45ba34c0b6c0f9555b29eb8bb5f6ade1\nF test/where8.test 461ca40265ed996a6305da99bb024b0e41602bb586acf544c08f95922358e49f\nF test/where9.test 2c554b97bbdb2fdf26c57099f60db8a52bfcf7c147f2c256f9798fa0e267ca85\nF test/whereA.test 6c6a420ca7d313242f9b1bd471dc80e4d0f8323700ba9c78df0bb843d4daa3b4\nF test/whereB.test 0def95db3bdec220a731c7e4bec5930327c1d8c5\nF test/whereC.test cae295158703cb3fc23bf1a108a9ab730efff0f6\nF test/whereD.test 711d4df58d6d4fb9b3f5ce040b818564198be002\nF test/whereE.test b3a055eef928c992b0a33198a7b8dc10eea5ad2f\nF test/whereF.test 3d9412b1199d3e2bed34fcb76b4c48d0bf4df95d27e3f8dd27b6f8b4716d0d89\nF test/whereG.test 4cda56de49f0c7d9a4f2590a3ddc5f79a7f2a03d2229d0f5bb5d3981ce57f293\nF test/whereH.test e4b07f7a3c2f5d31195cd33710054c78667573b2\nF test/whereI.test a2874062140ed4aba9ffae76e6190a3df6fc73d1373fdfa8fd632945082a5364\nF test/whereJ.test 88287550f6ee604422403b053455b1ad894eeaa5c35d348532dfa1439286cb9a\nF test/whereK.test f8e3cf26a8513ecc7f514f54df9f0572c046c42b\nF test/whereL.test 0a19fc44cd1122040f56c934f1b14d0ca85bde28f270268a428dd9796ea0634c\nF test/wherefault.test 1374c3aa198388925246475f84ad4cd5f9528864\nF test/wherelfault.test 9012e4ef5259058b771606616bd007af5d154e64cc25fa9fd4170f6411db44e3\nF test/wherelimit.test 592081800806d297dd7449b1030c863d2883d6d42901837ccd2e5a9bd962edb0\nF test/wherelimit2.test 9bf0aa56cca40ea0e4c5e2915341355a2bbc0859ec4ce1589197fe2a9d94635f\nF test/win32heap.test 10fd891266bd00af68671e702317726375e5407561d859be1aa04696f2aeee74\nF test/win32lock.test fbf107c91d8f5512be5a5b87c4c42ab9fdd54972\nF test/win32longpath.test 169c75a3b2e43481f4a62122510210c67b08f26d\nF test/win32nolock.test ac4f08811a562e45a5755e661f45ca85892bdbbc\nF test/window1.test 6db2c38a0830af8554936a563df92e67962cc379253854cd10d0c3cf0a3120c4\nF test/window2.tcl 66db96fd9fd202bc31ee7f8ce7904cb469564864cff3f74e009bfef8102333f4\nF test/window2.test af2a001ded703bb8f2474fb0edfef170d5aba00f5c1f2aa9f65935b5da13df90\nF test/window3.tcl acea6e86a4324a210fd608d06741010ca83ded9fde438341cb978c49928faf03\nF test/window3.test e9959a993c8a71e96433be8daaa1827d78b8921e4f12debd7bdbeb3c856ef3cb\nF test/window4.tcl d732df0e81beedc0ba8a563ade68611d322d27303ad0c0c8e4444107c39e84ec\nF test/window4.test 807f3e6b15f9338e5b9742b87c5c7ca825b42b9657fde6096e890119370848e0\nF test/window5.test d328dd18221217c49c144181975eea17339eaeaf0e9aa558cee3afb84652821e\nF test/window6.test f8d674254b23289cc17c84d79dec7eda7caa1dfb7836c43122cfdf3640d1df32\nF test/window7.tcl 6a1210f05d40ec89c22960213a22cd3f98d4e2f2eb20646c83c8c30d4d76108f\nF test/window7.test 1d31276961ae7801edc72173edaf7593e3cbc79c06d1f1f09e20d8418af403cd\nF test/window8.tcl f2711aa3571e4e6b0dad98db8d95fd6cb8d9db0c92bbdf535f153b07606a1ce2\nF test/window8.test c4331b27a6f66d69fa8f8bab10cc731db1a81d293ae108a68f7c3487fa94e65b\nF test/window9.test b63f6f74d730547e63e78946f951f5d1a7d4e99f91f6d5906305469043d92a15\nF test/windowA.test 6d63dc1260daa17141a55007600581778523a8b420629f1282d2acfc36af23be\nF test/windowB.test 7a983ea1cc1cf72be7f378e4b32f6cb2d73014c5cd8b25aaee825164cd4269e5\nF test/windowerr.tcl f5acd6fbc210d7b5546c0e879d157888455cd4a17a1d3f28f07c1c8a387019e0\nF test/windowerr.test a8b752402109c15aa1c5efe1b93ccb0ce1ef84fa964ae1cd6684dd0b3cc1819b\nF test/windowfault.test a90b397837209f15e54afa62e8be39b2759a0101fae04e05a08bcc50e243a452\nF test/with1.test d32792084dcb5f6c047d77bb8a032822ef9fe050ade07d0aeffa37753a05e3c9\nF test/with2.test e0030e2f0267a910d6c0e4f46f2dfe941c1cc0d4f659ba69b3597728e7e8f1ab\nF test/with3.test 7de8dff2891aca0f9453463e4a2d6eb995baf137827d5596116fee53e22a4e29\nF test/with4.test 257be66c0c67fee1defbbac0f685c3465e2cad037f21ce65f23f86084f198205\nF test/withM.test 693b61765f2b387b5e3e24a4536e2e82de15ff64\nF test/without_rowid1.test 9cfb83705c506e3849fa7efc88a3c9a15f9a50bf9b1516b41757a7cef9bba8c3\nF test/without_rowid2.test af260339f79d13cb220288b67cd287fbcf81ad99\nF test/without_rowid3.test ea4b59dd1b0d7f5f5e4b7cca978cdb905752a9d7c57dc4344a591dba765a3691\nF test/without_rowid4.test 4e08bcbaee0399f35d58b5581881e7a6243d458a\nF test/without_rowid5.test 89b1c587bd92a0590e440da33e7666bf4891572a\nF test/without_rowid6.test 8463b20098e9f75a501a9f17dfb42fffc79068eac0b2775fe56ef2281d2df45e\nF test/without_rowid7.test d7c59a93d726b55812d620f8f284e01904a5b85f9ee9eea8f2f68571a5e8c40e\nF test/wordcount.c d721a4b6fae93e6e33449700bce1686bc23257c27425bc3ef1599dc912adec66\nF test/writecrash.test f1da7f7adfe8d7f09ea79b42e5ca6dcc41102f27f8e334ad71539501ddd910cc\nF test/zeroblob.test 07a5b11ab591d1f26c626945fb7f228f68b993533b2ada77273edf6ee29db174\nF test/zerodamage.test 9c41628db7e8d9e8a0181e59ea5f189df311a9f6ce99cc376dc461f66db6f8dc\nF test/zipfile.test daab4c9be151934fd6bbc71a0d2520351efc61719eabbf545920f953883d172a\nF test/zipfile2.test 9903388a602a3834189857a985106ff95c3bba6a3969e0134127df991889db5d\nF test/zipfilefault.test 44d4d7a7f7cca7521d569d7f71026b241d65a6b1757aa409c1a168827edbbc2c\nF tool/GetFile.cs 47852aa0d806fe47ed1ac5138bdce7f000fe87aaa7f28107d0cb1e26682aeb44\nF tool/GetTclKit.bat 8995df40c4209808b31f24de0b58f90930239a234f7591e3675d45bfbb990c5d\nF tool/Replace.cs 02c67258801c2fb5f63231e0ac0f220b4b36ba91\nF tool/build-all-msvc.bat c12328d06c45fec8baada5949e3d5af54bf8c887 x\nF tool/build-shell.sh 950f47c6174f1eea171319438b93ba67ff5bf367\nF tool/cg_anno.tcl c1f875f5a4c9caca3d59937b16aff716f8b1883935f1b4c9ae23124705bc8099 x\nF tool/checkSpacing.c 810e51703529a204fc4e1eb060e9ab663e3c06d2\nF tool/dbhash.c 19560c9a2aa2b269b6a5108259b93d26d12f8f0877c31fe9f8f61dfbd219ba63\nF tool/dbtotxt.c b2221864a20fb391c46bd31bc1fbdc4a96f5c8a89bef58f421eb9b9c36b1702c\nF tool/dbtotxt.md c9a57af8739957ef36d2cfad5c4b1443ff3688ed33e4901ee200c8b651f43f3c\nF tool/extract-sqlite3h.tcl 069ceab0cee26cba99952bfa08c0b23e35941c837acabe143f0c355d96c9e2eb x\nF tool/extract.c 054069d81b095fbdc189a6f5d4466e40380505e2\nF tool/fast_vacuum.c 5ba0d6f5963a0a63bdc42840f678bad75b2ebce1\nF tool/fragck.tcl 5265a95126abcf6ab357f7efa544787e5963f439\nF tool/fuzzershell.c e1d90a03ca790d7c331c2aae08ca46ff435f1ae1faa6cb9cc48f4687c18fdc6e\nF tool/genfkey.README cf68fddd4643bbe3ff8e31b8b6d8b0a1b85e20f4\nF tool/genfkey.test b6afd7b825d797a1e1274f519ab5695373552ecad5cd373530c63533638a5a4f\nF tool/getlock.c f4c39b651370156cae979501a7b156bdba50e7ce\nF tool/index_usage.c 9ec344d29cbeb03fdc0fce668eedfb7495792170de933adf95cf8d6904a166ad\nF tool/kvtest-speed.sh 4761a9c4b3530907562314d7757995787f7aef8f\nF tool/lemon.c a361b85fa230560b783006ac002a6a8bad214c3b9d7fa48980aecc2b691ddcad\nF tool/lempar.c e8899b28488f060d0ff931539ea6311b16b22dce068c086c788a06d5e8d01ab7\nF tool/libvers.c caafc3b689638a1d88d44bc5f526c2278760d9b9\nF tool/loadfts.c c3c64e4d5e90e8ba41159232c2189dba4be7b862\nF tool/logest.c 11346aa019e2e77a00902aa7d0cabd27bd2e8cca\nF tool/max-limits.c cbb635fbb37ae4d05f240bfb5b5270bb63c54439\nF tool/mkautoconfamal.sh 422fc365358a2e92876ffc62971a0ff28ed472fc8bcf9de0df921c736fdeca5e\nF tool/mkccode.tcl 86463e68ce9c15d3041610fedd285ce32a5cf7a58fc88b3202b8b76837650dbe x\nF tool/mkctimec.tcl dd183b73ae1c28249669741c250525f0407e579a70482371668fd5f130d9feb3\nF tool/mkkeywordhash.c 27ffc6f6e7e3ecbfc5bca1f1f11a09fc5badf6d67557a5fb2d3b069dbed90617\nF tool/mkmsvcmin.tcl cad0c7b54d7dd92bc87d59f36d4cc4f070eb2e625f14159dc2f5c4204e6a13ea\nF tool/mkopcodec.tcl d1b6362bd3aa80d5520d4d6f3765badf01f6c43c\nF tool/mkopcodeh.tcl 352a4319c0ad869eb26442bf7c3b015aa15594c21f1cce5a6420dbe999367c21\nF tool/mkopts.tcl 680f785fdb09729fd9ac50632413da4eadbdf9071535e3f26d03795828ab07fa\nF tool/mkpragmatab.tcl 70269c7013dab01c5d366b1bb4cee6e42fa1a3a8d179a052d14d6b31f11ad77f\nF tool/mkshellc.tcl 70a9978e363b0f3280ca9ce1c46d72563ff479c1930a12a7375e3881b7325712\nF tool/mksourceid.c 36aa8020014aed0836fd13c51d6dc9219b0df1761d6b5f58ff5b616211b079b9\nF tool/mkspeedsql.tcl a1a334d288f7adfe6e996f2e712becf076745c97\nF tool/mksqlite3c-noext.tcl 4f7cfef5152b0c91920355cbfc1d608a4ad242cb819f1aea07f6d0274f584a7f\nF tool/mksqlite3c.tcl 5fed3d75069d8f66f202d3b5200b0cea4aa7108481acd06732a06fdd42eb83a2\nF tool/mksqlite3h.tcl 080873e3856eceb9d289a08a00c4b30f875ea3feadcbece796bd509b1532792c\nF tool/mksqlite3internalh.tcl eb994013e833359137eb53a55acdad0b5ae1049b\nF tool/mkvsix.tcl b9e0777a213c23156b6542842c238479e496ebf5\nF tool/offsets.c fe4262fdfa378e8f5499a42136d17bf3b98f6091\nF tool/omittest.tcl 27f9413c3343bac200a28d81e8234adb0f5e141c4771893cb19b40235a91f1e0\nF tool/opcodesum.tcl 740ed206ba8c5040018988129abbf3089a0ccf4a\nF tool/pagesig.c ff0ca355fd3c2398e933da5e22439bbff89b803b\nF tool/replace.tcl 60f91e8dd06ab81f74d213ecbd9c9945f32ac048\nF tool/restore_jrnl.tcl 6957a34f8f1f0f8285e07536225ec3b292a9024a\nF tool/rollback-test.c 9fc98427d1e23e84429d7e6d07d9094fbdec65a5\nF tool/run-speed-test.sh f95d19fd669b68c4c38b6b475242841d47c66076\nF tool/showdb.c 97d14a1ce32d5edda84081a5c939bd8975abd89568a773b288940e67e4c7e3ad\nF tool/showjournal.c 5bad7ae8784a43d2b270d953060423b8bd480818\nF tool/showlocks.c 9920bcc64f58378ff1118caead34147201f48c68\nF tool/showshm.c a0ab6ec32dd1f11218ca2a4018f8fb875b59414801ab8ceed8b2e69b7b45a809\nF tool/showstat4.c 0682ebea7abf4d3657f53c4a243f2e7eab48eab344ed36a94bb75dcd19a5c2a1\nF tool/showwal.c ad9d768f96ca6199ad3a8c9562d679680bd032dd01204ea3e5ea6fb931d81847\nF tool/soak1.tcl 8d407956e1a45b485a8e072470a3e629a27037fe\nF tool/spaceanal.tcl 4bfd19aad7eb3ce0372ef0255f58035e0bba4ff5e9acfd763a10c6fb365c8dec\nF tool/speed-check.sh 2b042d703a9472f08c3b13be27afac658426f8e4fc87cd2d575953fda86f08d1\nF tool/speedtest.tcl 06c76698485ccf597b9e7dbb1ac70706eb873355\nF tool/speedtest16.c ecb6542862151c3e6509bbc00509b234562ae81e\nF tool/speedtest2.tcl ee2149167303ba8e95af97873c575c3e0fab58ff\nF tool/speedtest8.c 2902c46588c40b55661e471d7a86e4dd71a18224\nF tool/speedtest8inst1.c 7ce07da76b5e745783e703a834417d725b7d45fd\nF tool/split-sqlite3c.tcl 3efcd4240b738f6bb2b5af0aea7e1e0ef9bc1c61654f645076cec883030b710c\nF tool/sqldiff.c 7b9b7238284f02131dbb8f21a4e862409bff728045c5473139d28c67ac87580e\nF tool/sqlite3_analyzer.c.in 7eeaae8b0d7577662acaabbb11107af0659d1b41bc1dfdd4d91422de27127968\nF tool/sqltclsh.c.in 1bcc2e9da58fadf17b0bf6a50e68c1159e602ce057210b655d50bad5aaaef898\nF tool/sqltclsh.tcl 862f4cf1418df5e1315b5db3b5ebe88969e2a784525af5fbf9596592f14ed848\nF tool/srcck1.c 371de5363b70154012955544f86fdee8f6e5326f\nF tool/stack_usage.tcl f8e71b92cdb099a147dad572375595eae55eca43\nF tool/symbols-mingw.sh 4dbcea7e74768305384c9fd2ed2b41bbf9f0414d\nF tool/symbols.sh 1612bd947750e21e7b47befad5f6b3825b06cce0705441f903bf35ced65ae9b9\nF tool/varint.c 5d94cb5003db9dbbcbcc5df08d66f16071aee003\nF tool/vdbe-compress.tcl 5926c71f9c12d2ab73ef35c29376e756eb68361c\nF tool/vdbe_profile.tcl 246d0da094856d72d2c12efec03250d71639d19f\nF tool/warnings-clang.sh bbf6a1e685e534c92ec2bfba5b1745f34fb6f0bc2a362850723a9ee87c1b31a7\nF tool/warnings.sh 09311479bdc290e20ec8e35a3d1b14b096bbd96222277cfd6274c3a99b3d012f\nF tool/win/sqlite.vsix deb315d026cc8400325c5863eef847784a219a2f\nF vsixtest/App.xaml b76d3b48860e7454775c47ea38ffea9c4abe3e85\nF vsixtest/App.xaml.cpp c465147f50871165c60ca16955219f6c5812d6d8\nF vsixtest/App.xaml.h 4a9768e2983d05600ad1e1c2f1b00a132967da9f\nF vsixtest/Assets/LockScreenLogo.scale-200.png e820c9a3deb909197081b0bf3216c06e13905f0a\nF vsixtest/Assets/SplashScreen.scale-200.png cab70988ca71bebec7bfeb3b6dbafe17b9ab0b4a\nF vsixtest/Assets/Square150x150Logo.scale-200.png e17b40817db7a239fc239d83efcc951fb824e3ff\nF vsixtest/Assets/Square44x44Logo.scale-200.png 2f166237094dea94d952d10b9eeae81806844f1c\nF vsixtest/Assets/Square44x44Logo.targetsize-24_altform-unplated.png 5f6a6d391b95a3061ccca6e6fdd6955ede63b4ed\nF vsixtest/Assets/StoreLogo.png 0828b7257db74a4ecd5eeb6b7b4971f0fdc4d9d1\nF vsixtest/Assets/Wide310x150Logo.scale-200.png 04ddefe5bc5f43ae12a7433f6f236ddab101ac42\nF vsixtest/MainPage.xaml 34f49897e3ca533a7e74506ba0759b66eebce151\nF vsixtest/MainPage.xaml.cpp 7f31fc6de751b64676c0924c97a5485d950a91d7\nF vsixtest/MainPage.xaml.h cc05cca10d50a003f6c6e4448b701cdd07f52f29\nF vsixtest/Package.appxmanifest 6b6db1eb7df3a315c5d681059754d5f0e0c47a93\nF vsixtest/pch.cpp cb823cfac36f1a39a7eb0acbd7e9a0b0de8f23af\nF vsixtest/pch.h 9cab7980f2ac4baa40807d8b5e52af32a21cf78c\nF vsixtest/vsixtest.sln 77cadbe4e96c1fe1bf51cd77de9e9b0a12ada547\nF vsixtest/vsixtest.tcl 6a9a6ab600c25a91a7acc6293828957a386a8a93\nF vsixtest/vsixtest.vcxproj.data 2ed517e100c66dc455b492e1a33350c1b20fbcdc\nF vsixtest/vsixtest.vcxproj.filters 37e51ffedcdb064aad6ff33b6148725226cd608e\nF vsixtest/vsixtest_TemporaryKey.pfx e5b1b036facdb453873e7084e1cae9102ccc67a0\nP 3d4c0bf8904135fa68c75801bfa738715cacc3b19dc8ad6ef550b11798d4b121\nR 5ae11b0f596e58f50666a1f36d76218a\nU drh\nZ a0201de5777363689738ee935bfc3b28\n", "cba2a2a44cdf138a629109bb0ad088ed4ef67fc66bed3e0373554681a39615d2", "/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains C code routines that are called by the parser\n** to handle SELECT statements in SQLite.\n*/\n#include \"sqliteInt.h\"\n\n/*\n** Trace output macros\n*/\n#if SELECTTRACE_ENABLED\n/***/ int sqlite3SelectTrace = 0;\n# define SELECTTRACE(K,P,S,X)  \\\n  if(sqlite3SelectTrace&(K))   \\\n    sqlite3DebugPrintf(\"%u/%d/%p: \",(S)->selId,(P)->addrExplain,(S)),\\\n    sqlite3DebugPrintf X\n#else\n# define SELECTTRACE(K,P,S,X)\n#endif\n\n\n/*\n** An instance of the following object is used to record information about\n** how to process the DISTINCT keyword, to simplify passing that information\n** into the selectInnerLoop() routine.\n*/\ntypedef struct DistinctCtx DistinctCtx;\nstruct DistinctCtx {\n  u8 isTnct;      /* True if the DISTINCT keyword is present */\n  u8 eTnctType;   /* One of the WHERE_DISTINCT_* operators */\n  int tabTnct;    /* Ephemeral table used for DISTINCT processing */\n  int addrTnct;   /* Address of OP_OpenEphemeral opcode for tabTnct */\n};\n\n/*\n** An instance of the following object is used to record information about\n** the ORDER BY (or GROUP BY) clause of query is being coded.\n**\n** The aDefer[] array is used by the sorter-references optimization. For\n** example, assuming there is no index that can be used for the ORDER BY,\n** for the query:\n**\n**     SELECT a, bigblob FROM t1 ORDER BY a LIMIT 10;\n**\n** it may be more efficient to add just the \"a\" values to the sorter, and\n** retrieve the associated \"bigblob\" values directly from table t1 as the\n** 10 smallest \"a\" values are extracted from the sorter.\n**\n** When the sorter-reference optimization is used, there is one entry in the\n** aDefer[] array for each database table that may be read as values are\n** extracted from the sorter.\n*/\ntypedef struct SortCtx SortCtx;\nstruct SortCtx {\n  ExprList *pOrderBy;   /* The ORDER BY (or GROUP BY clause) */\n  int nOBSat;           /* Number of ORDER BY terms satisfied by indices */\n  int iECursor;         /* Cursor number for the sorter */\n  int regReturn;        /* Register holding block-output return address */\n  int labelBkOut;       /* Start label for the block-output subroutine */\n  int addrSortIndex;    /* Address of the OP_SorterOpen or OP_OpenEphemeral */\n  int labelDone;        /* Jump here when done, ex: LIMIT reached */\n  int labelOBLopt;      /* Jump here when sorter is full */\n  u8 sortFlags;         /* Zero or more SORTFLAG_* bits */\n#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n  u8 nDefer;            /* Number of valid entries in aDefer[] */\n  struct DeferredCsr {\n    Table *pTab;        /* Table definition */\n    int iCsr;           /* Cursor number for table */\n    int nKey;           /* Number of PK columns for table pTab (>=1) */\n  } aDefer[4];\n#endif\n  struct RowLoadInfo *pDeferredRowLoad;  /* Deferred row loading info or NULL */\n};\n#define SORTFLAG_UseSorter  0x01   /* Use SorterOpen instead of OpenEphemeral */\n\n/*\n** Delete all the content of a Select structure.  Deallocate the structure\n** itself only if bFree is true.\n*/\nstatic void clearSelect(sqlite3 *db, Select *p, int bFree){\n  while( p ){\n    Select *pPrior = p->pPrior;\n    sqlite3ExprListDelete(db, p->pEList);\n    sqlite3SrcListDelete(db, p->pSrc);\n    sqlite3ExprDelete(db, p->pWhere);\n    sqlite3ExprListDelete(db, p->pGroupBy);\n    sqlite3ExprDelete(db, p->pHaving);\n    sqlite3ExprListDelete(db, p->pOrderBy);\n    sqlite3ExprDelete(db, p->pLimit);\n#ifndef SQLITE_OMIT_WINDOWFUNC\n    if( OK_IF_ALWAYS_TRUE(p->pWinDefn) ){\n      sqlite3WindowListDelete(db, p->pWinDefn);\n    }\n    assert( p->pWin==0 );\n#endif\n    if( OK_IF_ALWAYS_TRUE(p->pWith) ) sqlite3WithDelete(db, p->pWith);\n    if( bFree ) sqlite3DbFreeNN(db, p);\n    p = pPrior;\n    bFree = 1;\n  }\n}\n\n/*\n** Initialize a SelectDest structure.\n*/\nvoid sqlite3SelectDestInit(SelectDest *pDest, int eDest, int iParm){\n  pDest->eDest = (u8)eDest;\n  pDest->iSDParm = iParm;\n  pDest->zAffSdst = 0;\n  pDest->iSdst = 0;\n  pDest->nSdst = 0;\n}\n\n\n/*\n** Allocate a new Select structure and return a pointer to that\n** structure.\n*/\nSelect *sqlite3SelectNew(\n  Parse *pParse,        /* Parsing context */\n  ExprList *pEList,     /* which columns to include in the result */\n  SrcList *pSrc,        /* the FROM clause -- which tables to scan */\n  Expr *pWhere,         /* the WHERE clause */\n  ExprList *pGroupBy,   /* the GROUP BY clause */\n  Expr *pHaving,        /* the HAVING clause */\n  ExprList *pOrderBy,   /* the ORDER BY clause */\n  u32 selFlags,         /* Flag parameters, such as SF_Distinct */\n  Expr *pLimit          /* LIMIT value.  NULL means not used */\n){\n  Select *pNew;\n  Select standin;\n  pNew = sqlite3DbMallocRawNN(pParse->db, sizeof(*pNew) );\n  if( pNew==0 ){\n    assert( pParse->db->mallocFailed );\n    pNew = &standin;\n  }\n  if( pEList==0 ){\n    pEList = sqlite3ExprListAppend(pParse, 0,\n                                   sqlite3Expr(pParse->db,TK_ASTERISK,0));\n  }\n  pNew->pEList = pEList;\n  pNew->op = TK_SELECT;\n  pNew->selFlags = selFlags;\n  pNew->iLimit = 0;\n  pNew->iOffset = 0;\n  pNew->selId = ++pParse->nSelect;\n  pNew->addrOpenEphm[0] = -1;\n  pNew->addrOpenEphm[1] = -1;\n  pNew->nSelectRow = 0;\n  if( pSrc==0 ) pSrc = sqlite3DbMallocZero(pParse->db, sizeof(*pSrc));\n  pNew->pSrc = pSrc;\n  pNew->pWhere = pWhere;\n  pNew->pGroupBy = pGroupBy;\n  pNew->pHaving = pHaving;\n  pNew->pOrderBy = pOrderBy;\n  pNew->pPrior = 0;\n  pNew->pNext = 0;\n  pNew->pLimit = pLimit;\n  pNew->pWith = 0;\n#ifndef SQLITE_OMIT_WINDOWFUNC\n  pNew->pWin = 0;\n  pNew->pWinDefn = 0;\n#endif\n  if( pParse->db->mallocFailed ) {\n    clearSelect(pParse->db, pNew, pNew!=&standin);\n    pNew = 0;\n  }else{\n    assert( pNew->pSrc!=0 || pParse->nErr>0 );\n  }\n  assert( pNew!=&standin );\n  return pNew;\n}\n\n\n/*\n** Delete the given Select structure and all of its substructures.\n*/\nvoid sqlite3SelectDelete(sqlite3 *db, Select *p){\n  if( OK_IF_ALWAYS_TRUE(p) ) clearSelect(db, p, 1);\n}\n\n/*\n** Return a pointer to the right-most SELECT statement in a compound.\n*/\nstatic Select *findRightmost(Select *p){\n  while( p->pNext ) p = p->pNext;\n  return p;\n}\n\n/*\n** Given 1 to 3 identifiers preceding the JOIN keyword, determine the\n** type of join.  Return an integer constant that expresses that type\n** in terms of the following bit values:\n**\n**     JT_INNER\n**     JT_CROSS\n**     JT_OUTER\n**     JT_NATURAL\n**     JT_LEFT\n**     JT_RIGHT\n**\n** A full outer join is the combination of JT_LEFT and JT_RIGHT.\n**\n** If an illegal or unsupported join type is seen, then still return\n** a join type, but put an error in the pParse structure.\n*/\nint sqlite3JoinType(Parse *pParse, Token *pA, Token *pB, Token *pC){\n  int jointype = 0;\n  Token *apAll[3];\n  Token *p;\n                             /*   0123456789 123456789 123456789 123 */\n  static const char zKeyText[] = \"naturaleftouterightfullinnercross\";\n  static const struct {\n    u8 i;        /* Beginning of keyword text in zKeyText[] */\n    u8 nChar;    /* Length of the keyword in characters */\n    u8 code;     /* Join type mask */\n  } aKeyword[] = {\n    /* natural */ { 0,  7, JT_NATURAL                },\n    /* left    */ { 6,  4, JT_LEFT|JT_OUTER          },\n    /* outer   */ { 10, 5, JT_OUTER                  },\n    /* right   */ { 14, 5, JT_RIGHT|JT_OUTER         },\n    /* full    */ { 19, 4, JT_LEFT|JT_RIGHT|JT_OUTER },\n    /* inner   */ { 23, 5, JT_INNER                  },\n    /* cross   */ { 28, 5, JT_INNER|JT_CROSS         },\n  };\n  int i, j;\n  apAll[0] = pA;\n  apAll[1] = pB;\n  apAll[2] = pC;\n  for(i=0; i<3 && apAll[i]; i++){\n    p = apAll[i];\n    for(j=0; j<ArraySize(aKeyword); j++){\n      if( p->n==aKeyword[j].nChar \n          && sqlite3StrNICmp((char*)p->z, &zKeyText[aKeyword[j].i], p->n)==0 ){\n        jointype |= aKeyword[j].code;\n        break;\n      }\n    }\n    testcase( j==0 || j==1 || j==2 || j==3 || j==4 || j==5 || j==6 );\n    if( j>=ArraySize(aKeyword) ){\n      jointype |= JT_ERROR;\n      break;\n    }\n  }\n  if(\n     (jointype & (JT_INNER|JT_OUTER))==(JT_INNER|JT_OUTER) ||\n     (jointype & JT_ERROR)!=0\n  ){\n    const char *zSp = \" \";\n    assert( pB!=0 );\n    if( pC==0 ){ zSp++; }\n    sqlite3ErrorMsg(pParse, \"unknown or unsupported join type: \"\n       \"%T %T%s%T\", pA, pB, zSp, pC);\n    jointype = JT_INNER;\n  }else if( (jointype & JT_OUTER)!=0 \n         && (jointype & (JT_LEFT|JT_RIGHT))!=JT_LEFT ){\n    sqlite3ErrorMsg(pParse, \n      \"RIGHT and FULL OUTER JOINs are not currently supported\");\n    jointype = JT_INNER;\n  }\n  return jointype;\n}\n\n/*\n** Return the index of a column in a table.  Return -1 if the column\n** is not contained in the table.\n*/\nstatic int columnIndex(Table *pTab, const char *zCol){\n  int i;\n  for(i=0; i<pTab->nCol; i++){\n    if( sqlite3StrICmp(pTab->aCol[i].zName, zCol)==0 ) return i;\n  }\n  return -1;\n}\n\n/*\n** Search the first N tables in pSrc, from left to right, looking for a\n** table that has a column named zCol.  \n**\n** When found, set *piTab and *piCol to the table index and column index\n** of the matching column and return TRUE.\n**\n** If not found, return FALSE.\n*/\nstatic int tableAndColumnIndex(\n  SrcList *pSrc,       /* Array of tables to search */\n  int N,               /* Number of tables in pSrc->a[] to search */\n  const char *zCol,    /* Name of the column we are looking for */\n  int *piTab,          /* Write index of pSrc->a[] here */\n  int *piCol           /* Write index of pSrc->a[*piTab].pTab->aCol[] here */\n){\n  int i;               /* For looping over tables in pSrc */\n  int iCol;            /* Index of column matching zCol */\n\n  assert( (piTab==0)==(piCol==0) );  /* Both or neither are NULL */\n  for(i=0; i<N; i++){\n    iCol = columnIndex(pSrc->a[i].pTab, zCol);\n    if( iCol>=0 ){\n      if( piTab ){\n        *piTab = i;\n        *piCol = iCol;\n      }\n      return 1;\n    }\n  }\n  return 0;\n}\n\n/*\n** This function is used to add terms implied by JOIN syntax to the\n** WHERE clause expression of a SELECT statement. The new term, which\n** is ANDed with the existing WHERE clause, is of the form:\n**\n**    (tab1.col1 = tab2.col2)\n**\n** where tab1 is the iSrc'th table in SrcList pSrc and tab2 is the \n** (iSrc+1)'th. Column col1 is column iColLeft of tab1, and col2 is\n** column iColRight of tab2.\n*/\nstatic void addWhereTerm(\n  Parse *pParse,                  /* Parsing context */\n  SrcList *pSrc,                  /* List of tables in FROM clause */\n  int iLeft,                      /* Index of first table to join in pSrc */\n  int iColLeft,                   /* Index of column in first table */\n  int iRight,                     /* Index of second table in pSrc */\n  int iColRight,                  /* Index of column in second table */\n  int isOuterJoin,                /* True if this is an OUTER join */\n  Expr **ppWhere                  /* IN/OUT: The WHERE clause to add to */\n){\n  sqlite3 *db = pParse->db;\n  Expr *pE1;\n  Expr *pE2;\n  Expr *pEq;\n\n  assert( iLeft<iRight );\n  assert( pSrc->nSrc>iRight );\n  assert( pSrc->a[iLeft].pTab );\n  assert( pSrc->a[iRight].pTab );\n\n  pE1 = sqlite3CreateColumnExpr(db, pSrc, iLeft, iColLeft);\n  pE2 = sqlite3CreateColumnExpr(db, pSrc, iRight, iColRight);\n\n  pEq = sqlite3PExpr(pParse, TK_EQ, pE1, pE2);\n  if( pEq && isOuterJoin ){\n    ExprSetProperty(pEq, EP_FromJoin);\n    assert( !ExprHasProperty(pEq, EP_TokenOnly|EP_Reduced) );\n    ExprSetVVAProperty(pEq, EP_NoReduce);\n    pEq->iRightJoinTable = (i16)pE2->iTable;\n  }\n  *ppWhere = sqlite3ExprAnd(pParse, *ppWhere, pEq);\n}\n\n/*\n** Set the EP_FromJoin property on all terms of the given expression.\n** And set the Expr.iRightJoinTable to iTable for every term in the\n** expression.\n**\n** The EP_FromJoin property is used on terms of an expression to tell\n** the LEFT OUTER JOIN processing logic that this term is part of the\n** join restriction specified in the ON or USING clause and not a part\n** of the more general WHERE clause.  These terms are moved over to the\n** WHERE clause during join processing but we need to remember that they\n** originated in the ON or USING clause.\n**\n** The Expr.iRightJoinTable tells the WHERE clause processing that the\n** expression depends on table iRightJoinTable even if that table is not\n** explicitly mentioned in the expression.  That information is needed\n** for cases like this:\n**\n**    SELECT * FROM t1 LEFT JOIN t2 ON t1.a=t2.b AND t1.x=5\n**\n** The where clause needs to defer the handling of the t1.x=5\n** term until after the t2 loop of the join.  In that way, a\n** NULL t2 row will be inserted whenever t1.x!=5.  If we do not\n** defer the handling of t1.x=5, it will be processed immediately\n** after the t1 loop and rows with t1.x!=5 will never appear in\n** the output, which is incorrect.\n*/\nvoid sqlite3SetJoinExpr(Expr *p, int iTable){\n  while( p ){\n    ExprSetProperty(p, EP_FromJoin);\n    assert( !ExprHasProperty(p, EP_TokenOnly|EP_Reduced) );\n    ExprSetVVAProperty(p, EP_NoReduce);\n    p->iRightJoinTable = (i16)iTable;\n    if( p->op==TK_FUNCTION && p->x.pList ){\n      int i;\n      for(i=0; i<p->x.pList->nExpr; i++){\n        sqlite3SetJoinExpr(p->x.pList->a[i].pExpr, iTable);\n      }\n    }\n    sqlite3SetJoinExpr(p->pLeft, iTable);\n    p = p->pRight;\n  } \n}\n\n/* Undo the work of sqlite3SetJoinExpr(). In the expression p, convert every\n** term that is marked with EP_FromJoin and iRightJoinTable==iTable into\n** an ordinary term that omits the EP_FromJoin mark.\n**\n** This happens when a LEFT JOIN is simplified into an ordinary JOIN.\n*/\nstatic void unsetJoinExpr(Expr *p, int iTable){\n  while( p ){\n    if( ExprHasProperty(p, EP_FromJoin)\n     && (iTable<0 || p->iRightJoinTable==iTable) ){\n      ExprClearProperty(p, EP_FromJoin);\n    }\n    if( p->op==TK_FUNCTION && p->x.pList ){\n      int i;\n      for(i=0; i<p->x.pList->nExpr; i++){\n        unsetJoinExpr(p->x.pList->a[i].pExpr, iTable);\n      }\n    }\n    unsetJoinExpr(p->pLeft, iTable);\n    p = p->pRight;\n  } \n}\n\n/*\n** This routine processes the join information for a SELECT statement.\n** ON and USING clauses are converted into extra terms of the WHERE clause.\n** NATURAL joins also create extra WHERE clause terms.\n**\n** The terms of a FROM clause are contained in the Select.pSrc structure.\n** The left most table is the first entry in Select.pSrc.  The right-most\n** table is the last entry.  The join operator is held in the entry to\n** the left.  Thus entry 0 contains the join operator for the join between\n** entries 0 and 1.  Any ON or USING clauses associated with the join are\n** also attached to the left entry.\n**\n** This routine returns the number of errors encountered.\n*/\nstatic int sqliteProcessJoin(Parse *pParse, Select *p){\n  SrcList *pSrc;                  /* All tables in the FROM clause */\n  int i, j;                       /* Loop counters */\n  struct SrcList_item *pLeft;     /* Left table being joined */\n  struct SrcList_item *pRight;    /* Right table being joined */\n\n  pSrc = p->pSrc;\n  pLeft = &pSrc->a[0];\n  pRight = &pLeft[1];\n  for(i=0; i<pSrc->nSrc-1; i++, pRight++, pLeft++){\n    Table *pRightTab = pRight->pTab;\n    int isOuter;\n\n    if( NEVER(pLeft->pTab==0 || pRightTab==0) ) continue;\n    isOuter = (pRight->fg.jointype & JT_OUTER)!=0;\n\n    /* When the NATURAL keyword is present, add WHERE clause terms for\n    ** every column that the two tables have in common.\n    */\n    if( pRight->fg.jointype & JT_NATURAL ){\n      if( pRight->pOn || pRight->pUsing ){\n        sqlite3ErrorMsg(pParse, \"a NATURAL join may not have \"\n           \"an ON or USING clause\", 0);\n        return 1;\n      }\n      for(j=0; j<pRightTab->nCol; j++){\n        char *zName;   /* Name of column in the right table */\n        int iLeft;     /* Matching left table */\n        int iLeftCol;  /* Matching column in the left table */\n\n        zName = pRightTab->aCol[j].zName;\n        if( tableAndColumnIndex(pSrc, i+1, zName, &iLeft, &iLeftCol) ){\n          addWhereTerm(pParse, pSrc, iLeft, iLeftCol, i+1, j,\n                       isOuter, &p->pWhere);\n        }\n      }\n    }\n\n    /* Disallow both ON and USING clauses in the same join\n    */\n    if( pRight->pOn && pRight->pUsing ){\n      sqlite3ErrorMsg(pParse, \"cannot have both ON and USING \"\n        \"clauses in the same join\");\n      return 1;\n    }\n\n    /* Add the ON clause to the end of the WHERE clause, connected by\n    ** an AND operator.\n    */\n    if( pRight->pOn ){\n      if( isOuter ) sqlite3SetJoinExpr(pRight->pOn, pRight->iCursor);\n      p->pWhere = sqlite3ExprAnd(pParse, p->pWhere, pRight->pOn);\n      pRight->pOn = 0;\n    }\n\n    /* Create extra terms on the WHERE clause for each column named\n    ** in the USING clause.  Example: If the two tables to be joined are \n    ** A and B and the USING clause names X, Y, and Z, then add this\n    ** to the WHERE clause:    A.X=B.X AND A.Y=B.Y AND A.Z=B.Z\n    ** Report an error if any column mentioned in the USING clause is\n    ** not contained in both tables to be joined.\n    */\n    if( pRight->pUsing ){\n      IdList *pList = pRight->pUsing;\n      for(j=0; j<pList->nId; j++){\n        char *zName;     /* Name of the term in the USING clause */\n        int iLeft;       /* Table on the left with matching column name */\n        int iLeftCol;    /* Column number of matching column on the left */\n        int iRightCol;   /* Column number of matching column on the right */\n\n        zName = pList->a[j].zName;\n        iRightCol = columnIndex(pRightTab, zName);\n        if( iRightCol<0\n         || !tableAndColumnIndex(pSrc, i+1, zName, &iLeft, &iLeftCol)\n        ){\n          sqlite3ErrorMsg(pParse, \"cannot join using column %s - column \"\n            \"not present in both tables\", zName);\n          return 1;\n        }\n        addWhereTerm(pParse, pSrc, iLeft, iLeftCol, i+1, iRightCol,\n                     isOuter, &p->pWhere);\n      }\n    }\n  }\n  return 0;\n}\n\n/*\n** An instance of this object holds information (beyond pParse and pSelect)\n** needed to load the next result row that is to be added to the sorter.\n*/\ntypedef struct RowLoadInfo RowLoadInfo;\nstruct RowLoadInfo {\n  int regResult;               /* Store results in array of registers here */\n  u8 ecelFlags;                /* Flag argument to ExprCodeExprList() */\n#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n  ExprList *pExtra;            /* Extra columns needed by sorter refs */\n  int regExtraResult;          /* Where to load the extra columns */\n#endif\n};\n\n/*\n** This routine does the work of loading query data into an array of\n** registers so that it can be added to the sorter.\n*/\nstatic void innerLoopLoadRow(\n  Parse *pParse,             /* Statement under construction */\n  Select *pSelect,           /* The query being coded */\n  RowLoadInfo *pInfo         /* Info needed to complete the row load */\n){\n  sqlite3ExprCodeExprList(pParse, pSelect->pEList, pInfo->regResult,\n                          0, pInfo->ecelFlags);\n#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n  if( pInfo->pExtra ){\n    sqlite3ExprCodeExprList(pParse, pInfo->pExtra, pInfo->regExtraResult, 0, 0);\n    sqlite3ExprListDelete(pParse->db, pInfo->pExtra);\n  }\n#endif\n}\n\n/*\n** Code the OP_MakeRecord instruction that generates the entry to be\n** added into the sorter.\n**\n** Return the register in which the result is stored.\n*/\nstatic int makeSorterRecord(\n  Parse *pParse,\n  SortCtx *pSort,\n  Select *pSelect,\n  int regBase,\n  int nBase\n){\n  int nOBSat = pSort->nOBSat;\n  Vdbe *v = pParse->pVdbe;\n  int regOut = ++pParse->nMem;\n  if( pSort->pDeferredRowLoad ){\n    innerLoopLoadRow(pParse, pSelect, pSort->pDeferredRowLoad);\n  }\n  sqlite3VdbeAddOp3(v, OP_MakeRecord, regBase+nOBSat, nBase-nOBSat, regOut);\n  return regOut;\n}\n\n/*\n** Generate code that will push the record in registers regData\n** through regData+nData-1 onto the sorter.\n*/\nstatic void pushOntoSorter(\n  Parse *pParse,         /* Parser context */\n  SortCtx *pSort,        /* Information about the ORDER BY clause */\n  Select *pSelect,       /* The whole SELECT statement */\n  int regData,           /* First register holding data to be sorted */\n  int regOrigData,       /* First register holding data before packing */\n  int nData,             /* Number of elements in the regData data array */\n  int nPrefixReg         /* No. of reg prior to regData available for use */\n){\n  Vdbe *v = pParse->pVdbe;                         /* Stmt under construction */\n  int bSeq = ((pSort->sortFlags & SORTFLAG_UseSorter)==0);\n  int nExpr = pSort->pOrderBy->nExpr;              /* No. of ORDER BY terms */\n  int nBase = nExpr + bSeq + nData;                /* Fields in sorter record */\n  int regBase;                                     /* Regs for sorter record */\n  int regRecord = 0;                               /* Assembled sorter record */\n  int nOBSat = pSort->nOBSat;                      /* ORDER BY terms to skip */\n  int op;                            /* Opcode to add sorter record to sorter */\n  int iLimit;                        /* LIMIT counter */\n  int iSkip = 0;                     /* End of the sorter insert loop */\n\n  assert( bSeq==0 || bSeq==1 );\n\n  /* Three cases:\n  **   (1) The data to be sorted has already been packed into a Record\n  **       by a prior OP_MakeRecord.  In this case nData==1 and regData\n  **       will be completely unrelated to regOrigData.\n  **   (2) All output columns are included in the sort record.  In that\n  **       case regData==regOrigData.\n  **   (3) Some output columns are omitted from the sort record due to\n  **       the SQLITE_ENABLE_SORTER_REFERENCE optimization, or due to the\n  **       SQLITE_ECEL_OMITREF optimization, or due to the \n  **       SortCtx.pDeferredRowLoad optimiation.  In any of these cases\n  **       regOrigData is 0 to prevent this routine from trying to copy\n  **       values that might not yet exist.\n  */\n  assert( nData==1 || regData==regOrigData || regOrigData==0 );\n\n  if( nPrefixReg ){\n    assert( nPrefixReg==nExpr+bSeq );\n    regBase = regData - nPrefixReg;\n  }else{\n    regBase = pParse->nMem + 1;\n    pParse->nMem += nBase;\n  }\n  assert( pSelect->iOffset==0 || pSelect->iLimit!=0 );\n  iLimit = pSelect->iOffset ? pSelect->iOffset+1 : pSelect->iLimit;\n  pSort->labelDone = sqlite3VdbeMakeLabel(pParse);\n  sqlite3ExprCodeExprList(pParse, pSort->pOrderBy, regBase, regOrigData,\n                          SQLITE_ECEL_DUP | (regOrigData? SQLITE_ECEL_REF : 0));\n  if( bSeq ){\n    sqlite3VdbeAddOp2(v, OP_Sequence, pSort->iECursor, regBase+nExpr);\n  }\n  if( nPrefixReg==0 && nData>0 ){\n    sqlite3ExprCodeMove(pParse, regData, regBase+nExpr+bSeq, nData);\n  }\n  if( nOBSat>0 ){\n    int regPrevKey;   /* The first nOBSat columns of the previous row */\n    int addrFirst;    /* Address of the OP_IfNot opcode */\n    int addrJmp;      /* Address of the OP_Jump opcode */\n    VdbeOp *pOp;      /* Opcode that opens the sorter */\n    int nKey;         /* Number of sorting key columns, including OP_Sequence */\n    KeyInfo *pKI;     /* Original KeyInfo on the sorter table */\n\n    regRecord = makeSorterRecord(pParse, pSort, pSelect, regBase, nBase);\n    regPrevKey = pParse->nMem+1;\n    pParse->nMem += pSort->nOBSat;\n    nKey = nExpr - pSort->nOBSat + bSeq;\n    if( bSeq ){\n      addrFirst = sqlite3VdbeAddOp1(v, OP_IfNot, regBase+nExpr); \n    }else{\n      addrFirst = sqlite3VdbeAddOp1(v, OP_SequenceTest, pSort->iECursor);\n    }\n    VdbeCoverage(v);\n    sqlite3VdbeAddOp3(v, OP_Compare, regPrevKey, regBase, pSort->nOBSat);\n    pOp = sqlite3VdbeGetOp(v, pSort->addrSortIndex);\n    if( pParse->db->mallocFailed ) return;\n    pOp->p2 = nKey + nData;\n    pKI = pOp->p4.pKeyInfo;\n    memset(pKI->aSortFlags, 0, pKI->nKeyField); /* Makes OP_Jump testable */\n    sqlite3VdbeChangeP4(v, -1, (char*)pKI, P4_KEYINFO);\n    testcase( pKI->nAllField > pKI->nKeyField+2 );\n    pOp->p4.pKeyInfo = sqlite3KeyInfoFromExprList(pParse,pSort->pOrderBy,nOBSat,\n                                           pKI->nAllField-pKI->nKeyField-1);\n    pOp = 0; /* Ensure pOp not used after sqltie3VdbeAddOp3() */\n    addrJmp = sqlite3VdbeCurrentAddr(v);\n    sqlite3VdbeAddOp3(v, OP_Jump, addrJmp+1, 0, addrJmp+1); VdbeCoverage(v);\n    pSort->labelBkOut = sqlite3VdbeMakeLabel(pParse);\n    pSort->regReturn = ++pParse->nMem;\n    sqlite3VdbeAddOp2(v, OP_Gosub, pSort->regReturn, pSort->labelBkOut);\n    sqlite3VdbeAddOp1(v, OP_ResetSorter, pSort->iECursor);\n    if( iLimit ){\n      sqlite3VdbeAddOp2(v, OP_IfNot, iLimit, pSort->labelDone);\n      VdbeCoverage(v);\n    }\n    sqlite3VdbeJumpHere(v, addrFirst);\n    sqlite3ExprCodeMove(pParse, regBase, regPrevKey, pSort->nOBSat);\n    sqlite3VdbeJumpHere(v, addrJmp);\n  }\n  if( iLimit ){\n    /* At this point the values for the new sorter entry are stored\n    ** in an array of registers. They need to be composed into a record\n    ** and inserted into the sorter if either (a) there are currently\n    ** less than LIMIT+OFFSET items or (b) the new record is smaller than \n    ** the largest record currently in the sorter. If (b) is true and there\n    ** are already LIMIT+OFFSET items in the sorter, delete the largest\n    ** entry before inserting the new one. This way there are never more \n    ** than LIMIT+OFFSET items in the sorter.\n    **\n    ** If the new record does not need to be inserted into the sorter,\n    ** jump to the next iteration of the loop. If the pSort->labelOBLopt\n    ** value is not zero, then it is a label of where to jump.  Otherwise,\n    ** just bypass the row insert logic.  See the header comment on the\n    ** sqlite3WhereOrderByLimitOptLabel() function for additional info.\n    */\n    int iCsr = pSort->iECursor;\n    sqlite3VdbeAddOp2(v, OP_IfNotZero, iLimit, sqlite3VdbeCurrentAddr(v)+4);\n    VdbeCoverage(v);\n    sqlite3VdbeAddOp2(v, OP_Last, iCsr, 0);\n    iSkip = sqlite3VdbeAddOp4Int(v, OP_IdxLE,\n                                 iCsr, 0, regBase+nOBSat, nExpr-nOBSat);\n    VdbeCoverage(v);\n    sqlite3VdbeAddOp1(v, OP_Delete, iCsr);\n  }\n  if( regRecord==0 ){\n    regRecord = makeSorterRecord(pParse, pSort, pSelect, regBase, nBase);\n  }\n  if( pSort->sortFlags & SORTFLAG_UseSorter ){\n    op = OP_SorterInsert;\n  }else{\n    op = OP_IdxInsert;\n  }\n  sqlite3VdbeAddOp4Int(v, op, pSort->iECursor, regRecord,\n                       regBase+nOBSat, nBase-nOBSat);\n  if( iSkip ){\n    sqlite3VdbeChangeP2(v, iSkip,\n         pSort->labelOBLopt ? pSort->labelOBLopt : sqlite3VdbeCurrentAddr(v));\n  }\n}\n\n/*\n** Add code to implement the OFFSET\n*/\nstatic void codeOffset(\n  Vdbe *v,          /* Generate code into this VM */\n  int iOffset,      /* Register holding the offset counter */\n  int iContinue     /* Jump here to skip the current record */\n){\n  if( iOffset>0 ){\n    sqlite3VdbeAddOp3(v, OP_IfPos, iOffset, iContinue, 1); VdbeCoverage(v);\n    VdbeComment((v, \"OFFSET\"));\n  }\n}\n\n/*\n** Add code that will check to make sure the N registers starting at iMem\n** form a distinct entry.  iTab is a sorting index that holds previously\n** seen combinations of the N values.  A new entry is made in iTab\n** if the current N values are new.\n**\n** A jump to addrRepeat is made and the N+1 values are popped from the\n** stack if the top N elements are not distinct.\n*/\nstatic void codeDistinct(\n  Parse *pParse,     /* Parsing and code generating context */\n  int iTab,          /* A sorting index used to test for distinctness */\n  int addrRepeat,    /* Jump to here if not distinct */\n  int N,             /* Number of elements */\n  int iMem           /* First element */\n){\n  Vdbe *v;\n  int r1;\n\n  v = pParse->pVdbe;\n  r1 = sqlite3GetTempReg(pParse);\n  sqlite3VdbeAddOp4Int(v, OP_Found, iTab, addrRepeat, iMem, N); VdbeCoverage(v);\n  sqlite3VdbeAddOp3(v, OP_MakeRecord, iMem, N, r1);\n  sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iTab, r1, iMem, N);\n  sqlite3VdbeChangeP5(v, OPFLAG_USESEEKRESULT);\n  sqlite3ReleaseTempReg(pParse, r1);\n}\n\n#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n/*\n** This function is called as part of inner-loop generation for a SELECT\n** statement with an ORDER BY that is not optimized by an index. It \n** determines the expressions, if any, that the sorter-reference \n** optimization should be used for. The sorter-reference optimization\n** is used for SELECT queries like:\n**\n**   SELECT a, bigblob FROM t1 ORDER BY a LIMIT 10\n**\n** If the optimization is used for expression \"bigblob\", then instead of\n** storing values read from that column in the sorter records, the PK of\n** the row from table t1 is stored instead. Then, as records are extracted from\n** the sorter to return to the user, the required value of bigblob is\n** retrieved directly from table t1. If the values are very large, this \n** can be more efficient than storing them directly in the sorter records.\n**\n** The ExprList_item.bSorterRef flag is set for each expression in pEList \n** for which the sorter-reference optimization should be enabled. \n** Additionally, the pSort->aDefer[] array is populated with entries\n** for all cursors required to evaluate all selected expressions. Finally.\n** output variable (*ppExtra) is set to an expression list containing\n** expressions for all extra PK values that should be stored in the\n** sorter records.\n*/\nstatic void selectExprDefer(\n  Parse *pParse,                  /* Leave any error here */\n  SortCtx *pSort,                 /* Sorter context */\n  ExprList *pEList,               /* Expressions destined for sorter */\n  ExprList **ppExtra              /* Expressions to append to sorter record */\n){\n  int i;\n  int nDefer = 0;\n  ExprList *pExtra = 0;\n  for(i=0; i<pEList->nExpr; i++){\n    struct ExprList_item *pItem = &pEList->a[i];\n    if( pItem->u.x.iOrderByCol==0 ){\n      Expr *pExpr = pItem->pExpr;\n      Table *pTab = pExpr->y.pTab;\n      if( pExpr->op==TK_COLUMN && pExpr->iColumn>=0 && pTab && !IsVirtual(pTab)\n       && (pTab->aCol[pExpr->iColumn].colFlags & COLFLAG_SORTERREF)\n      ){\n        int j;\n        for(j=0; j<nDefer; j++){\n          if( pSort->aDefer[j].iCsr==pExpr->iTable ) break;\n        }\n        if( j==nDefer ){\n          if( nDefer==ArraySize(pSort->aDefer) ){\n            continue;\n          }else{\n            int nKey = 1;\n            int k;\n            Index *pPk = 0;\n            if( !HasRowid(pTab) ){\n              pPk = sqlite3PrimaryKeyIndex(pTab);\n              nKey = pPk->nKeyCol;\n            }\n            for(k=0; k<nKey; k++){\n              Expr *pNew = sqlite3PExpr(pParse, TK_COLUMN, 0, 0);\n              if( pNew ){\n                pNew->iTable = pExpr->iTable;\n                pNew->y.pTab = pExpr->y.pTab;\n                pNew->iColumn = pPk ? pPk->aiColumn[k] : -1;\n                pExtra = sqlite3ExprListAppend(pParse, pExtra, pNew);\n              }\n            }\n            pSort->aDefer[nDefer].pTab = pExpr->y.pTab;\n            pSort->aDefer[nDefer].iCsr = pExpr->iTable;\n            pSort->aDefer[nDefer].nKey = nKey;\n            nDefer++;\n          }\n        }\n        pItem->bSorterRef = 1;\n      }\n    }\n  }\n  pSort->nDefer = (u8)nDefer;\n  *ppExtra = pExtra;\n}\n#endif\n\n/*\n** This routine generates the code for the inside of the inner loop\n** of a SELECT.\n**\n** If srcTab is negative, then the p->pEList expressions\n** are evaluated in order to get the data for this row.  If srcTab is\n** zero or more, then data is pulled from srcTab and p->pEList is used only \n** to get the number of columns and the collation sequence for each column.\n*/\nstatic void selectInnerLoop(\n  Parse *pParse,          /* The parser context */\n  Select *p,              /* The complete select statement being coded */\n  int srcTab,             /* Pull data from this table if non-negative */\n  SortCtx *pSort,         /* If not NULL, info on how to process ORDER BY */\n  DistinctCtx *pDistinct, /* If not NULL, info on how to process DISTINCT */\n  SelectDest *pDest,      /* How to dispose of the results */\n  int iContinue,          /* Jump here to continue with next row */\n  int iBreak              /* Jump here to break out of the inner loop */\n){\n  Vdbe *v = pParse->pVdbe;\n  int i;\n  int hasDistinct;            /* True if the DISTINCT keyword is present */\n  int eDest = pDest->eDest;   /* How to dispose of results */\n  int iParm = pDest->iSDParm; /* First argument to disposal method */\n  int nResultCol;             /* Number of result columns */\n  int nPrefixReg = 0;         /* Number of extra registers before regResult */\n  RowLoadInfo sRowLoadInfo;   /* Info for deferred row loading */\n\n  /* Usually, regResult is the first cell in an array of memory cells\n  ** containing the current result row. In this case regOrig is set to the\n  ** same value. However, if the results are being sent to the sorter, the\n  ** values for any expressions that are also part of the sort-key are omitted\n  ** from this array. In this case regOrig is set to zero.  */\n  int regResult;              /* Start of memory holding current results */\n  int regOrig;                /* Start of memory holding full result (or 0) */\n\n  assert( v );\n  assert( p->pEList!=0 );\n  hasDistinct = pDistinct ? pDistinct->eTnctType : WHERE_DISTINCT_NOOP;\n  if( pSort && pSort->pOrderBy==0 ) pSort = 0;\n  if( pSort==0 && !hasDistinct ){\n    assert( iContinue!=0 );\n    codeOffset(v, p->iOffset, iContinue);\n  }\n\n  /* Pull the requested columns.\n  */\n  nResultCol = p->pEList->nExpr;\n\n  if( pDest->iSdst==0 ){\n    if( pSort ){\n      nPrefixReg = pSort->pOrderBy->nExpr;\n      if( !(pSort->sortFlags & SORTFLAG_UseSorter) ) nPrefixReg++;\n      pParse->nMem += nPrefixReg;\n    }\n    pDest->iSdst = pParse->nMem+1;\n    pParse->nMem += nResultCol;\n  }else if( pDest->iSdst+nResultCol > pParse->nMem ){\n    /* This is an error condition that can result, for example, when a SELECT\n    ** on the right-hand side of an INSERT contains more result columns than\n    ** there are columns in the table on the left.  The error will be caught\n    ** and reported later.  But we need to make sure enough memory is allocated\n    ** to avoid other spurious errors in the meantime. */\n    pParse->nMem += nResultCol;\n  }\n  pDest->nSdst = nResultCol;\n  regOrig = regResult = pDest->iSdst;\n  if( srcTab>=0 ){\n    for(i=0; i<nResultCol; i++){\n      sqlite3VdbeAddOp3(v, OP_Column, srcTab, i, regResult+i);\n      VdbeComment((v, \"%s\", p->pEList->a[i].zName));\n    }\n  }else if( eDest!=SRT_Exists ){\n#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n    ExprList *pExtra = 0;\n#endif\n    /* If the destination is an EXISTS(...) expression, the actual\n    ** values returned by the SELECT are not required.\n    */\n    u8 ecelFlags;    /* \"ecel\" is an abbreviation of \"ExprCodeExprList\" */\n    ExprList *pEList;\n    if( eDest==SRT_Mem || eDest==SRT_Output || eDest==SRT_Coroutine ){\n      ecelFlags = SQLITE_ECEL_DUP;\n    }else{\n      ecelFlags = 0;\n    }\n    if( pSort && hasDistinct==0 && eDest!=SRT_EphemTab && eDest!=SRT_Table ){\n      /* For each expression in p->pEList that is a copy of an expression in\n      ** the ORDER BY clause (pSort->pOrderBy), set the associated \n      ** iOrderByCol value to one more than the index of the ORDER BY \n      ** expression within the sort-key that pushOntoSorter() will generate.\n      ** This allows the p->pEList field to be omitted from the sorted record,\n      ** saving space and CPU cycles.  */\n      ecelFlags |= (SQLITE_ECEL_OMITREF|SQLITE_ECEL_REF);\n\n      for(i=pSort->nOBSat; i<pSort->pOrderBy->nExpr; i++){\n        int j;\n        if( (j = pSort->pOrderBy->a[i].u.x.iOrderByCol)>0 ){\n          p->pEList->a[j-1].u.x.iOrderByCol = i+1-pSort->nOBSat;\n        }\n      }\n#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n      selectExprDefer(pParse, pSort, p->pEList, &pExtra);\n      if( pExtra && pParse->db->mallocFailed==0 ){\n        /* If there are any extra PK columns to add to the sorter records,\n        ** allocate extra memory cells and adjust the OpenEphemeral \n        ** instruction to account for the larger records. This is only\n        ** required if there are one or more WITHOUT ROWID tables with\n        ** composite primary keys in the SortCtx.aDefer[] array.  */\n        VdbeOp *pOp = sqlite3VdbeGetOp(v, pSort->addrSortIndex);\n        pOp->p2 += (pExtra->nExpr - pSort->nDefer);\n        pOp->p4.pKeyInfo->nAllField += (pExtra->nExpr - pSort->nDefer);\n        pParse->nMem += pExtra->nExpr;\n      }\n#endif\n\n      /* Adjust nResultCol to account for columns that are omitted\n      ** from the sorter by the optimizations in this branch */\n      pEList = p->pEList;\n      for(i=0; i<pEList->nExpr; i++){\n        if( pEList->a[i].u.x.iOrderByCol>0\n#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n         || pEList->a[i].bSorterRef\n#endif\n        ){\n          nResultCol--;\n          regOrig = 0;\n        }\n      }\n\n      testcase( regOrig );\n      testcase( eDest==SRT_Set );\n      testcase( eDest==SRT_Mem );\n      testcase( eDest==SRT_Coroutine );\n      testcase( eDest==SRT_Output );\n      assert( eDest==SRT_Set || eDest==SRT_Mem \n           || eDest==SRT_Coroutine || eDest==SRT_Output );\n    }\n    sRowLoadInfo.regResult = regResult;\n    sRowLoadInfo.ecelFlags = ecelFlags;\n#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n    sRowLoadInfo.pExtra = pExtra;\n    sRowLoadInfo.regExtraResult = regResult + nResultCol;\n    if( pExtra ) nResultCol += pExtra->nExpr;\n#endif\n    if( p->iLimit\n     && (ecelFlags & SQLITE_ECEL_OMITREF)!=0 \n     && nPrefixReg>0\n    ){\n      assert( pSort!=0 );\n      assert( hasDistinct==0 );\n      pSort->pDeferredRowLoad = &sRowLoadInfo;\n      regOrig = 0;\n    }else{\n      innerLoopLoadRow(pParse, p, &sRowLoadInfo);\n    }\n  }\n\n  /* If the DISTINCT keyword was present on the SELECT statement\n  ** and this row has been seen before, then do not make this row\n  ** part of the result.\n  */\n  if( hasDistinct ){\n    switch( pDistinct->eTnctType ){\n      case WHERE_DISTINCT_ORDERED: {\n        VdbeOp *pOp;            /* No longer required OpenEphemeral instr. */\n        int iJump;              /* Jump destination */\n        int regPrev;            /* Previous row content */\n\n        /* Allocate space for the previous row */\n        regPrev = pParse->nMem+1;\n        pParse->nMem += nResultCol;\n\n        /* Change the OP_OpenEphemeral coded earlier to an OP_Null\n        ** sets the MEM_Cleared bit on the first register of the\n        ** previous value.  This will cause the OP_Ne below to always\n        ** fail on the first iteration of the loop even if the first\n        ** row is all NULLs.\n        */\n        sqlite3VdbeChangeToNoop(v, pDistinct->addrTnct);\n        pOp = sqlite3VdbeGetOp(v, pDistinct->addrTnct);\n        pOp->opcode = OP_Null;\n        pOp->p1 = 1;\n        pOp->p2 = regPrev;\n        pOp = 0;  /* Ensure pOp is not used after sqlite3VdbeAddOp() */\n\n        iJump = sqlite3VdbeCurrentAddr(v) + nResultCol;\n        for(i=0; i<nResultCol; i++){\n          CollSeq *pColl = sqlite3ExprCollSeq(pParse, p->pEList->a[i].pExpr);\n          if( i<nResultCol-1 ){\n            sqlite3VdbeAddOp3(v, OP_Ne, regResult+i, iJump, regPrev+i);\n            VdbeCoverage(v);\n          }else{\n            sqlite3VdbeAddOp3(v, OP_Eq, regResult+i, iContinue, regPrev+i);\n            VdbeCoverage(v);\n           }\n          sqlite3VdbeChangeP4(v, -1, (const char *)pColl, P4_COLLSEQ);\n          sqlite3VdbeChangeP5(v, SQLITE_NULLEQ);\n        }\n        assert( sqlite3VdbeCurrentAddr(v)==iJump || pParse->db->mallocFailed );\n        sqlite3VdbeAddOp3(v, OP_Copy, regResult, regPrev, nResultCol-1);\n        break;\n      }\n\n      case WHERE_DISTINCT_UNIQUE: {\n        sqlite3VdbeChangeToNoop(v, pDistinct->addrTnct);\n        break;\n      }\n\n      default: {\n        assert( pDistinct->eTnctType==WHERE_DISTINCT_UNORDERED );\n        codeDistinct(pParse, pDistinct->tabTnct, iContinue, nResultCol,\n                     regResult);\n        break;\n      }\n    }\n    if( pSort==0 ){\n      codeOffset(v, p->iOffset, iContinue);\n    }\n  }\n\n  switch( eDest ){\n    /* In this mode, write each query result to the key of the temporary\n    ** table iParm.\n    */\n#ifndef SQLITE_OMIT_COMPOUND_SELECT\n    case SRT_Union: {\n      int r1;\n      r1 = sqlite3GetTempReg(pParse);\n      sqlite3VdbeAddOp3(v, OP_MakeRecord, regResult, nResultCol, r1);\n      sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, r1, regResult, nResultCol);\n      sqlite3ReleaseTempReg(pParse, r1);\n      break;\n    }\n\n    /* Construct a record from the query result, but instead of\n    ** saving that record, use it as a key to delete elements from\n    ** the temporary table iParm.\n    */\n    case SRT_Except: {\n      sqlite3VdbeAddOp3(v, OP_IdxDelete, iParm, regResult, nResultCol);\n      break;\n    }\n#endif /* SQLITE_OMIT_COMPOUND_SELECT */\n\n    /* Store the result as data using a unique key.\n    */\n    case SRT_Fifo:\n    case SRT_DistFifo:\n    case SRT_Table:\n    case SRT_EphemTab: {\n      int r1 = sqlite3GetTempRange(pParse, nPrefixReg+1);\n      testcase( eDest==SRT_Table );\n      testcase( eDest==SRT_EphemTab );\n      testcase( eDest==SRT_Fifo );\n      testcase( eDest==SRT_DistFifo );\n      sqlite3VdbeAddOp3(v, OP_MakeRecord, regResult, nResultCol, r1+nPrefixReg);\n#ifndef SQLITE_OMIT_CTE\n      if( eDest==SRT_DistFifo ){\n        /* If the destination is DistFifo, then cursor (iParm+1) is open\n        ** on an ephemeral index. If the current row is already present\n        ** in the index, do not write it to the output. If not, add the\n        ** current row to the index and proceed with writing it to the\n        ** output table as well.  */\n        int addr = sqlite3VdbeCurrentAddr(v) + 4;\n        sqlite3VdbeAddOp4Int(v, OP_Found, iParm+1, addr, r1, 0);\n        VdbeCoverage(v);\n        sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm+1, r1,regResult,nResultCol);\n        assert( pSort==0 );\n      }\n#endif\n      if( pSort ){\n        assert( regResult==regOrig );\n        pushOntoSorter(pParse, pSort, p, r1+nPrefixReg, regOrig, 1, nPrefixReg);\n      }else{\n        int r2 = sqlite3GetTempReg(pParse);\n        sqlite3VdbeAddOp2(v, OP_NewRowid, iParm, r2);\n        sqlite3VdbeAddOp3(v, OP_Insert, iParm, r1, r2);\n        sqlite3VdbeChangeP5(v, OPFLAG_APPEND);\n        sqlite3ReleaseTempReg(pParse, r2);\n      }\n      sqlite3ReleaseTempRange(pParse, r1, nPrefixReg+1);\n      break;\n    }\n\n#ifndef SQLITE_OMIT_SUBQUERY\n    /* If we are creating a set for an \"expr IN (SELECT ...)\" construct,\n    ** then there should be a single item on the stack.  Write this\n    ** item into the set table with bogus data.\n    */\n    case SRT_Set: {\n      if( pSort ){\n        /* At first glance you would think we could optimize out the\n        ** ORDER BY in this case since the order of entries in the set\n        ** does not matter.  But there might be a LIMIT clause, in which\n        ** case the order does matter */\n        pushOntoSorter(\n            pParse, pSort, p, regResult, regOrig, nResultCol, nPrefixReg);\n      }else{\n        int r1 = sqlite3GetTempReg(pParse);\n        assert( sqlite3Strlen30(pDest->zAffSdst)==nResultCol );\n        sqlite3VdbeAddOp4(v, OP_MakeRecord, regResult, nResultCol, \n            r1, pDest->zAffSdst, nResultCol);\n        sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, r1, regResult, nResultCol);\n        sqlite3ReleaseTempReg(pParse, r1);\n      }\n      break;\n    }\n\n    /* If any row exist in the result set, record that fact and abort.\n    */\n    case SRT_Exists: {\n      sqlite3VdbeAddOp2(v, OP_Integer, 1, iParm);\n      /* The LIMIT clause will terminate the loop for us */\n      break;\n    }\n\n    /* If this is a scalar select that is part of an expression, then\n    ** store the results in the appropriate memory cell or array of \n    ** memory cells and break out of the scan loop.\n    */\n    case SRT_Mem: {\n      if( pSort ){\n        assert( nResultCol<=pDest->nSdst );\n        pushOntoSorter(\n            pParse, pSort, p, regResult, regOrig, nResultCol, nPrefixReg);\n      }else{\n        assert( nResultCol==pDest->nSdst );\n        assert( regResult==iParm );\n        /* The LIMIT clause will jump out of the loop for us */\n      }\n      break;\n    }\n#endif /* #ifndef SQLITE_OMIT_SUBQUERY */\n\n    case SRT_Coroutine:       /* Send data to a co-routine */\n    case SRT_Output: {        /* Return the results */\n      testcase( eDest==SRT_Coroutine );\n      testcase( eDest==SRT_Output );\n      if( pSort ){\n        pushOntoSorter(pParse, pSort, p, regResult, regOrig, nResultCol,\n                       nPrefixReg);\n      }else if( eDest==SRT_Coroutine ){\n        sqlite3VdbeAddOp1(v, OP_Yield, pDest->iSDParm);\n      }else{\n        sqlite3VdbeAddOp2(v, OP_ResultRow, regResult, nResultCol);\n      }\n      break;\n    }\n\n#ifndef SQLITE_OMIT_CTE\n    /* Write the results into a priority queue that is order according to\n    ** pDest->pOrderBy (in pSO).  pDest->iSDParm (in iParm) is the cursor for an\n    ** index with pSO->nExpr+2 columns.  Build a key using pSO for the first\n    ** pSO->nExpr columns, then make sure all keys are unique by adding a\n    ** final OP_Sequence column.  The last column is the record as a blob.\n    */\n    case SRT_DistQueue:\n    case SRT_Queue: {\n      int nKey;\n      int r1, r2, r3;\n      int addrTest = 0;\n      ExprList *pSO;\n      pSO = pDest->pOrderBy;\n      assert( pSO );\n      nKey = pSO->nExpr;\n      r1 = sqlite3GetTempReg(pParse);\n      r2 = sqlite3GetTempRange(pParse, nKey+2);\n      r3 = r2+nKey+1;\n      if( eDest==SRT_DistQueue ){\n        /* If the destination is DistQueue, then cursor (iParm+1) is open\n        ** on a second ephemeral index that holds all values every previously\n        ** added to the queue. */\n        addrTest = sqlite3VdbeAddOp4Int(v, OP_Found, iParm+1, 0, \n                                        regResult, nResultCol);\n        VdbeCoverage(v);\n      }\n      sqlite3VdbeAddOp3(v, OP_MakeRecord, regResult, nResultCol, r3);\n      if( eDest==SRT_DistQueue ){\n        sqlite3VdbeAddOp2(v, OP_IdxInsert, iParm+1, r3);\n        sqlite3VdbeChangeP5(v, OPFLAG_USESEEKRESULT);\n      }\n      for(i=0; i<nKey; i++){\n        sqlite3VdbeAddOp2(v, OP_SCopy,\n                          regResult + pSO->a[i].u.x.iOrderByCol - 1,\n                          r2+i);\n      }\n      sqlite3VdbeAddOp2(v, OP_Sequence, iParm, r2+nKey);\n      sqlite3VdbeAddOp3(v, OP_MakeRecord, r2, nKey+2, r1);\n      sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, r1, r2, nKey+2);\n      if( addrTest ) sqlite3VdbeJumpHere(v, addrTest);\n      sqlite3ReleaseTempReg(pParse, r1);\n      sqlite3ReleaseTempRange(pParse, r2, nKey+2);\n      break;\n    }\n#endif /* SQLITE_OMIT_CTE */\n\n\n\n#if !defined(SQLITE_OMIT_TRIGGER)\n    /* Discard the results.  This is used for SELECT statements inside\n    ** the body of a TRIGGER.  The purpose of such selects is to call\n    ** user-defined functions that have side effects.  We do not care\n    ** about the actual results of the select.\n    */\n    default: {\n      assert( eDest==SRT_Discard );\n      break;\n    }\n#endif\n  }\n\n  /* Jump to the end of the loop if the LIMIT is reached.  Except, if\n  ** there is a sorter, in which case the sorter has already limited\n  ** the output for us.\n  */\n  if( pSort==0 && p->iLimit ){\n    sqlite3VdbeAddOp2(v, OP_DecrJumpZero, p->iLimit, iBreak); VdbeCoverage(v);\n  }\n}\n\n/*\n** Allocate a KeyInfo object sufficient for an index of N key columns and\n** X extra columns.\n*/\nKeyInfo *sqlite3KeyInfoAlloc(sqlite3 *db, int N, int X){\n  int nExtra = (N+X)*(sizeof(CollSeq*)+1) - sizeof(CollSeq*);\n  KeyInfo *p = sqlite3DbMallocRawNN(db, sizeof(KeyInfo) + nExtra);\n  if( p ){\n    p->aSortFlags = (u8*)&p->aColl[N+X];\n    p->nKeyField = (u16)N;\n    p->nAllField = (u16)(N+X);\n    p->enc = ENC(db);\n    p->db = db;\n    p->nRef = 1;\n    memset(&p[1], 0, nExtra);\n  }else{\n    sqlite3OomFault(db);\n  }\n  return p;\n}\n\n/*\n** Deallocate a KeyInfo object\n*/\nvoid sqlite3KeyInfoUnref(KeyInfo *p){\n  if( p ){\n    assert( p->nRef>0 );\n    p->nRef--;\n    if( p->nRef==0 ) sqlite3DbFreeNN(p->db, p);\n  }\n}\n\n/*\n** Make a new pointer to a KeyInfo object\n*/\nKeyInfo *sqlite3KeyInfoRef(KeyInfo *p){\n  if( p ){\n    assert( p->nRef>0 );\n    p->nRef++;\n  }\n  return p;\n}\n\n#ifdef SQLITE_DEBUG\n/*\n** Return TRUE if a KeyInfo object can be change.  The KeyInfo object\n** can only be changed if this is just a single reference to the object.\n**\n** This routine is used only inside of assert() statements.\n*/\nint sqlite3KeyInfoIsWriteable(KeyInfo *p){ return p->nRef==1; }\n#endif /* SQLITE_DEBUG */\n\n/*\n** Given an expression list, generate a KeyInfo structure that records\n** the collating sequence for each expression in that expression list.\n**\n** If the ExprList is an ORDER BY or GROUP BY clause then the resulting\n** KeyInfo structure is appropriate for initializing a virtual index to\n** implement that clause.  If the ExprList is the result set of a SELECT\n** then the KeyInfo structure is appropriate for initializing a virtual\n** index to implement a DISTINCT test.\n**\n** Space to hold the KeyInfo structure is obtained from malloc.  The calling\n** function is responsible for seeing that this structure is eventually\n** freed.\n*/\nKeyInfo *sqlite3KeyInfoFromExprList(\n  Parse *pParse,       /* Parsing context */\n  ExprList *pList,     /* Form the KeyInfo object from this ExprList */\n  int iStart,          /* Begin with this column of pList */\n  int nExtra           /* Add this many extra columns to the end */\n){\n  int nExpr;\n  KeyInfo *pInfo;\n  struct ExprList_item *pItem;\n  sqlite3 *db = pParse->db;\n  int i;\n\n  nExpr = pList->nExpr;\n  pInfo = sqlite3KeyInfoAlloc(db, nExpr-iStart, nExtra+1);\n  if( pInfo ){\n    assert( sqlite3KeyInfoIsWriteable(pInfo) );\n    for(i=iStart, pItem=pList->a+iStart; i<nExpr; i++, pItem++){\n      pInfo->aColl[i-iStart] = sqlite3ExprNNCollSeq(pParse, pItem->pExpr);\n      pInfo->aSortFlags[i-iStart] = pItem->sortFlags;\n    }\n  }\n  return pInfo;\n}\n\n/*\n** Name of the connection operator, used for error messages.\n*/\nstatic const char *selectOpName(int id){\n  char *z;\n  switch( id ){\n    case TK_ALL:       z = \"UNION ALL\";   break;\n    case TK_INTERSECT: z = \"INTERSECT\";   break;\n    case TK_EXCEPT:    z = \"EXCEPT\";      break;\n    default:           z = \"UNION\";       break;\n  }\n  return z;\n}\n\n#ifndef SQLITE_OMIT_EXPLAIN\n/*\n** Unless an \"EXPLAIN QUERY PLAN\" command is being processed, this function\n** is a no-op. Otherwise, it adds a single row of output to the EQP result,\n** where the caption is of the form:\n**\n**   \"USE TEMP B-TREE FOR xxx\"\n**\n** where xxx is one of \"DISTINCT\", \"ORDER BY\" or \"GROUP BY\". Exactly which\n** is determined by the zUsage argument.\n*/\nstatic void explainTempTable(Parse *pParse, const char *zUsage){\n  ExplainQueryPlan((pParse, 0, \"USE TEMP B-TREE FOR %s\", zUsage));\n}\n\n/*\n** Assign expression b to lvalue a. A second, no-op, version of this macro\n** is provided when SQLITE_OMIT_EXPLAIN is defined. This allows the code\n** in sqlite3Select() to assign values to structure member variables that\n** only exist if SQLITE_OMIT_EXPLAIN is not defined without polluting the\n** code with #ifndef directives.\n*/\n# define explainSetInteger(a, b) a = b\n\n#else\n/* No-op versions of the explainXXX() functions and macros. */\n# define explainTempTable(y,z)\n# define explainSetInteger(y,z)\n#endif\n\n\n/*\n** If the inner loop was generated using a non-null pOrderBy argument,\n** then the results were placed in a sorter.  After the loop is terminated\n** we need to run the sorter and output the results.  The following\n** routine generates the code needed to do that.\n*/\nstatic void generateSortTail(\n  Parse *pParse,    /* Parsing context */\n  Select *p,        /* The SELECT statement */\n  SortCtx *pSort,   /* Information on the ORDER BY clause */\n  int nColumn,      /* Number of columns of data */\n  SelectDest *pDest /* Write the sorted results here */\n){\n  Vdbe *v = pParse->pVdbe;                     /* The prepared statement */\n  int addrBreak = pSort->labelDone;            /* Jump here to exit loop */\n  int addrContinue = sqlite3VdbeMakeLabel(pParse);/* Jump here for next cycle */\n  int addr;                       /* Top of output loop. Jump for Next. */\n  int addrOnce = 0;\n  int iTab;\n  ExprList *pOrderBy = pSort->pOrderBy;\n  int eDest = pDest->eDest;\n  int iParm = pDest->iSDParm;\n  int regRow;\n  int regRowid;\n  int iCol;\n  int nKey;                       /* Number of key columns in sorter record */\n  int iSortTab;                   /* Sorter cursor to read from */\n  int i;\n  int bSeq;                       /* True if sorter record includes seq. no. */\n  int nRefKey = 0;\n  struct ExprList_item *aOutEx = p->pEList->a;\n\n  assert( addrBreak<0 );\n  if( pSort->labelBkOut ){\n    sqlite3VdbeAddOp2(v, OP_Gosub, pSort->regReturn, pSort->labelBkOut);\n    sqlite3VdbeGoto(v, addrBreak);\n    sqlite3VdbeResolveLabel(v, pSort->labelBkOut);\n  }\n\n#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n  /* Open any cursors needed for sorter-reference expressions */\n  for(i=0; i<pSort->nDefer; i++){\n    Table *pTab = pSort->aDefer[i].pTab;\n    int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n    sqlite3OpenTable(pParse, pSort->aDefer[i].iCsr, iDb, pTab, OP_OpenRead);\n    nRefKey = MAX(nRefKey, pSort->aDefer[i].nKey);\n  }\n#endif\n\n  iTab = pSort->iECursor;\n  if( eDest==SRT_Output || eDest==SRT_Coroutine || eDest==SRT_Mem ){\n    regRowid = 0;\n    regRow = pDest->iSdst;\n  }else{\n    regRowid = sqlite3GetTempReg(pParse);\n    if( eDest==SRT_EphemTab || eDest==SRT_Table ){\n      regRow = sqlite3GetTempReg(pParse);\n      nColumn = 0;\n    }else{\n      regRow = sqlite3GetTempRange(pParse, nColumn);\n    }\n  }\n  nKey = pOrderBy->nExpr - pSort->nOBSat;\n  if( pSort->sortFlags & SORTFLAG_UseSorter ){\n    int regSortOut = ++pParse->nMem;\n    iSortTab = pParse->nTab++;\n    if( pSort->labelBkOut ){\n      addrOnce = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);\n    }\n    sqlite3VdbeAddOp3(v, OP_OpenPseudo, iSortTab, regSortOut, \n        nKey+1+nColumn+nRefKey);\n    if( addrOnce ) sqlite3VdbeJumpHere(v, addrOnce);\n    addr = 1 + sqlite3VdbeAddOp2(v, OP_SorterSort, iTab, addrBreak);\n    VdbeCoverage(v);\n    codeOffset(v, p->iOffset, addrContinue);\n    sqlite3VdbeAddOp3(v, OP_SorterData, iTab, regSortOut, iSortTab);\n    bSeq = 0;\n  }else{\n    addr = 1 + sqlite3VdbeAddOp2(v, OP_Sort, iTab, addrBreak); VdbeCoverage(v);\n    codeOffset(v, p->iOffset, addrContinue);\n    iSortTab = iTab;\n    bSeq = 1;\n  }\n  for(i=0, iCol=nKey+bSeq-1; i<nColumn; i++){\n#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n    if( aOutEx[i].bSorterRef ) continue;\n#endif\n    if( aOutEx[i].u.x.iOrderByCol==0 ) iCol++;\n  }\n#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n  if( pSort->nDefer ){\n    int iKey = iCol+1;\n    int regKey = sqlite3GetTempRange(pParse, nRefKey);\n\n    for(i=0; i<pSort->nDefer; i++){\n      int iCsr = pSort->aDefer[i].iCsr;\n      Table *pTab = pSort->aDefer[i].pTab;\n      int nKey = pSort->aDefer[i].nKey;\n\n      sqlite3VdbeAddOp1(v, OP_NullRow, iCsr);\n      if( HasRowid(pTab) ){\n        sqlite3VdbeAddOp3(v, OP_Column, iSortTab, iKey++, regKey);\n        sqlite3VdbeAddOp3(v, OP_SeekRowid, iCsr, \n            sqlite3VdbeCurrentAddr(v)+1, regKey);\n      }else{\n        int k;\n        int iJmp;\n        assert( sqlite3PrimaryKeyIndex(pTab)->nKeyCol==nKey );\n        for(k=0; k<nKey; k++){\n          sqlite3VdbeAddOp3(v, OP_Column, iSortTab, iKey++, regKey+k);\n        }\n        iJmp = sqlite3VdbeCurrentAddr(v);\n        sqlite3VdbeAddOp4Int(v, OP_SeekGE, iCsr, iJmp+2, regKey, nKey);\n        sqlite3VdbeAddOp4Int(v, OP_IdxLE, iCsr, iJmp+3, regKey, nKey);\n        sqlite3VdbeAddOp1(v, OP_NullRow, iCsr);\n      }\n    }\n    sqlite3ReleaseTempRange(pParse, regKey, nRefKey);\n  }\n#endif\n  for(i=nColumn-1; i>=0; i--){\n#ifdef SQLITE_ENABLE_SORTER_REFERENCES\n    if( aOutEx[i].bSorterRef ){\n      sqlite3ExprCode(pParse, aOutEx[i].pExpr, regRow+i);\n    }else\n#endif\n    {\n      int iRead;\n      if( aOutEx[i].u.x.iOrderByCol ){\n        iRead = aOutEx[i].u.x.iOrderByCol-1;\n      }else{\n        iRead = iCol--;\n      }\n      sqlite3VdbeAddOp3(v, OP_Column, iSortTab, iRead, regRow+i);\n      VdbeComment((v, \"%s\", aOutEx[i].zName?aOutEx[i].zName : aOutEx[i].zSpan));\n    }\n  }\n  switch( eDest ){\n    case SRT_Table:\n    case SRT_EphemTab: {\n      sqlite3VdbeAddOp3(v, OP_Column, iSortTab, nKey+bSeq, regRow);\n      sqlite3VdbeAddOp2(v, OP_NewRowid, iParm, regRowid);\n      sqlite3VdbeAddOp3(v, OP_Insert, iParm, regRow, regRowid);\n      sqlite3VdbeChangeP5(v, OPFLAG_APPEND);\n      break;\n    }\n#ifndef SQLITE_OMIT_SUBQUERY\n    case SRT_Set: {\n      assert( nColumn==sqlite3Strlen30(pDest->zAffSdst) );\n      sqlite3VdbeAddOp4(v, OP_MakeRecord, regRow, nColumn, regRowid,\n                        pDest->zAffSdst, nColumn);\n      sqlite3VdbeAddOp4Int(v, OP_IdxInsert, iParm, regRowid, regRow, nColumn);\n      break;\n    }\n    case SRT_Mem: {\n      /* The LIMIT clause will terminate the loop for us */\n      break;\n    }\n#endif\n    default: {\n      assert( eDest==SRT_Output || eDest==SRT_Coroutine ); \n      testcase( eDest==SRT_Output );\n      testcase( eDest==SRT_Coroutine );\n      if( eDest==SRT_Output ){\n        sqlite3VdbeAddOp2(v, OP_ResultRow, pDest->iSdst, nColumn);\n      }else{\n        sqlite3VdbeAddOp1(v, OP_Yield, pDest->iSDParm);\n      }\n      break;\n    }\n  }\n  if( regRowid ){\n    if( eDest==SRT_Set ){\n      sqlite3ReleaseTempRange(pParse, regRow, nColumn);\n    }else{\n      sqlite3ReleaseTempReg(pParse, regRow);\n    }\n    sqlite3ReleaseTempReg(pParse, regRowid);\n  }\n  /* The bottom of the loop\n  */\n  sqlite3VdbeResolveLabel(v, addrContinue);\n  if( pSort->sortFlags & SORTFLAG_UseSorter ){\n    sqlite3VdbeAddOp2(v, OP_SorterNext, iTab, addr); VdbeCoverage(v);\n  }else{\n    sqlite3VdbeAddOp2(v, OP_Next, iTab, addr); VdbeCoverage(v);\n  }\n  if( pSort->regReturn ) sqlite3VdbeAddOp1(v, OP_Return, pSort->regReturn);\n  sqlite3VdbeResolveLabel(v, addrBreak);\n}\n\n/*\n** Return a pointer to a string containing the 'declaration type' of the\n** expression pExpr. The string may be treated as static by the caller.\n**\n** Also try to estimate the size of the returned value and return that\n** result in *pEstWidth.\n**\n** The declaration type is the exact datatype definition extracted from the\n** original CREATE TABLE statement if the expression is a column. The\n** declaration type for a ROWID field is INTEGER. Exactly when an expression\n** is considered a column can be complex in the presence of subqueries. The\n** result-set expression in all of the following SELECT statements is \n** considered a column by this function.\n**\n**   SELECT col FROM tbl;\n**   SELECT (SELECT col FROM tbl;\n**   SELECT (SELECT col FROM tbl);\n**   SELECT abc FROM (SELECT col AS abc FROM tbl);\n** \n** The declaration type for any expression other than a column is NULL.\n**\n** This routine has either 3 or 6 parameters depending on whether or not\n** the SQLITE_ENABLE_COLUMN_METADATA compile-time option is used.\n*/\n#ifdef SQLITE_ENABLE_COLUMN_METADATA\n# define columnType(A,B,C,D,E) columnTypeImpl(A,B,C,D,E)\n#else /* if !defined(SQLITE_ENABLE_COLUMN_METADATA) */\n# define columnType(A,B,C,D,E) columnTypeImpl(A,B)\n#endif\nstatic const char *columnTypeImpl(\n  NameContext *pNC, \n#ifndef SQLITE_ENABLE_COLUMN_METADATA\n  Expr *pExpr\n#else\n  Expr *pExpr,\n  const char **pzOrigDb,\n  const char **pzOrigTab,\n  const char **pzOrigCol\n#endif\n){\n  char const *zType = 0;\n  int j;\n#ifdef SQLITE_ENABLE_COLUMN_METADATA\n  char const *zOrigDb = 0;\n  char const *zOrigTab = 0;\n  char const *zOrigCol = 0;\n#endif\n\n  assert( pExpr!=0 );\n  assert( pNC->pSrcList!=0 );\n  switch( pExpr->op ){\n    case TK_COLUMN: {\n      /* The expression is a column. Locate the table the column is being\n      ** extracted from in NameContext.pSrcList. This table may be real\n      ** database table or a subquery.\n      */\n      Table *pTab = 0;            /* Table structure column is extracted from */\n      Select *pS = 0;             /* Select the column is extracted from */\n      int iCol = pExpr->iColumn;  /* Index of column in pTab */\n      while( pNC && !pTab ){\n        SrcList *pTabList = pNC->pSrcList;\n        for(j=0;j<pTabList->nSrc && pTabList->a[j].iCursor!=pExpr->iTable;j++);\n        if( j<pTabList->nSrc ){\n          pTab = pTabList->a[j].pTab;\n          pS = pTabList->a[j].pSelect;\n        }else{\n          pNC = pNC->pNext;\n        }\n      }\n\n      if( pTab==0 ){\n        /* At one time, code such as \"SELECT new.x\" within a trigger would\n        ** cause this condition to run.  Since then, we have restructured how\n        ** trigger code is generated and so this condition is no longer \n        ** possible. However, it can still be true for statements like\n        ** the following:\n        **\n        **   CREATE TABLE t1(col INTEGER);\n        **   SELECT (SELECT t1.col) FROM FROM t1;\n        **\n        ** when columnType() is called on the expression \"t1.col\" in the \n        ** sub-select. In this case, set the column type to NULL, even\n        ** though it should really be \"INTEGER\".\n        **\n        ** This is not a problem, as the column type of \"t1.col\" is never\n        ** used. When columnType() is called on the expression \n        ** \"(SELECT t1.col)\", the correct type is returned (see the TK_SELECT\n        ** branch below.  */\n        break;\n      }\n\n      assert( pTab && pExpr->y.pTab==pTab );\n      if( pS ){\n        /* The \"table\" is actually a sub-select or a view in the FROM clause\n        ** of the SELECT statement. Return the declaration type and origin\n        ** data for the result-set column of the sub-select.\n        */\n        if( iCol>=0 && iCol<pS->pEList->nExpr ){\n          /* If iCol is less than zero, then the expression requests the\n          ** rowid of the sub-select or view. This expression is legal (see \n          ** test case misc2.2.2) - it always evaluates to NULL.\n          */\n          NameContext sNC;\n          Expr *p = pS->pEList->a[iCol].pExpr;\n          sNC.pSrcList = pS->pSrc;\n          sNC.pNext = pNC;\n          sNC.pParse = pNC->pParse;\n          zType = columnType(&sNC, p,&zOrigDb,&zOrigTab,&zOrigCol); \n        }\n      }else{\n        /* A real table or a CTE table */\n        assert( !pS );\n#ifdef SQLITE_ENABLE_COLUMN_METADATA\n        if( iCol<0 ) iCol = pTab->iPKey;\n        assert( iCol==XN_ROWID || (iCol>=0 && iCol<pTab->nCol) );\n        if( iCol<0 ){\n          zType = \"INTEGER\";\n          zOrigCol = \"rowid\";\n        }else{\n          zOrigCol = pTab->aCol[iCol].zName;\n          zType = sqlite3ColumnType(&pTab->aCol[iCol],0);\n        }\n        zOrigTab = pTab->zName;\n        if( pNC->pParse && pTab->pSchema ){\n          int iDb = sqlite3SchemaToIndex(pNC->pParse->db, pTab->pSchema);\n          zOrigDb = pNC->pParse->db->aDb[iDb].zDbSName;\n        }\n#else\n        assert( iCol==XN_ROWID || (iCol>=0 && iCol<pTab->nCol) );\n        if( iCol<0 ){\n          zType = \"INTEGER\";\n        }else{\n          zType = sqlite3ColumnType(&pTab->aCol[iCol],0);\n        }\n#endif\n      }\n      break;\n    }\n#ifndef SQLITE_OMIT_SUBQUERY\n    case TK_SELECT: {\n      /* The expression is a sub-select. Return the declaration type and\n      ** origin info for the single column in the result set of the SELECT\n      ** statement.\n      */\n      NameContext sNC;\n      Select *pS = pExpr->x.pSelect;\n      Expr *p = pS->pEList->a[0].pExpr;\n      assert( ExprHasProperty(pExpr, EP_xIsSelect) );\n      sNC.pSrcList = pS->pSrc;\n      sNC.pNext = pNC;\n      sNC.pParse = pNC->pParse;\n      zType = columnType(&sNC, p, &zOrigDb, &zOrigTab, &zOrigCol); \n      break;\n    }\n#endif\n  }\n\n#ifdef SQLITE_ENABLE_COLUMN_METADATA  \n  if( pzOrigDb ){\n    assert( pzOrigTab && pzOrigCol );\n    *pzOrigDb = zOrigDb;\n    *pzOrigTab = zOrigTab;\n    *pzOrigCol = zOrigCol;\n  }\n#endif\n  return zType;\n}\n\n/*\n** Generate code that will tell the VDBE the declaration types of columns\n** in the result set.\n*/\nstatic void generateColumnTypes(\n  Parse *pParse,      /* Parser context */\n  SrcList *pTabList,  /* List of tables */\n  ExprList *pEList    /* Expressions defining the result set */\n){\n#ifndef SQLITE_OMIT_DECLTYPE\n  Vdbe *v = pParse->pVdbe;\n  int i;\n  NameContext sNC;\n  sNC.pSrcList = pTabList;\n  sNC.pParse = pParse;\n  sNC.pNext = 0;\n  for(i=0; i<pEList->nExpr; i++){\n    Expr *p = pEList->a[i].pExpr;\n    const char *zType;\n#ifdef SQLITE_ENABLE_COLUMN_METADATA\n    const char *zOrigDb = 0;\n    const char *zOrigTab = 0;\n    const char *zOrigCol = 0;\n    zType = columnType(&sNC, p, &zOrigDb, &zOrigTab, &zOrigCol);\n\n    /* The vdbe must make its own copy of the column-type and other \n    ** column specific strings, in case the schema is reset before this\n    ** virtual machine is deleted.\n    */\n    sqlite3VdbeSetColName(v, i, COLNAME_DATABASE, zOrigDb, SQLITE_TRANSIENT);\n    sqlite3VdbeSetColName(v, i, COLNAME_TABLE, zOrigTab, SQLITE_TRANSIENT);\n    sqlite3VdbeSetColName(v, i, COLNAME_COLUMN, zOrigCol, SQLITE_TRANSIENT);\n#else\n    zType = columnType(&sNC, p, 0, 0, 0);\n#endif\n    sqlite3VdbeSetColName(v, i, COLNAME_DECLTYPE, zType, SQLITE_TRANSIENT);\n  }\n#endif /* !defined(SQLITE_OMIT_DECLTYPE) */\n}\n\n\n/*\n** Compute the column names for a SELECT statement.\n**\n** The only guarantee that SQLite makes about column names is that if the\n** column has an AS clause assigning it a name, that will be the name used.\n** That is the only documented guarantee.  However, countless applications\n** developed over the years have made baseless assumptions about column names\n** and will break if those assumptions changes.  Hence, use extreme caution\n** when modifying this routine to avoid breaking legacy.\n**\n** See Also: sqlite3ColumnsFromExprList()\n**\n** The PRAGMA short_column_names and PRAGMA full_column_names settings are\n** deprecated.  The default setting is short=ON, full=OFF.  99.9% of all\n** applications should operate this way.  Nevertheless, we need to support the\n** other modes for legacy:\n**\n**    short=OFF, full=OFF:      Column name is the text of the expression has it\n**                              originally appears in the SELECT statement.  In\n**                              other words, the zSpan of the result expression.\n**\n**    short=ON, full=OFF:       (This is the default setting).  If the result\n**                              refers directly to a table column, then the\n**                              result column name is just the table column\n**                              name: COLUMN.  Otherwise use zSpan.\n**\n**    full=ON, short=ANY:       If the result refers directly to a table column,\n**                              then the result column name with the table name\n**                              prefix, ex: TABLE.COLUMN.  Otherwise use zSpan.\n*/\nstatic void generateColumnNames(\n  Parse *pParse,      /* Parser context */\n  Select *pSelect     /* Generate column names for this SELECT statement */\n){\n  Vdbe *v = pParse->pVdbe;\n  int i;\n  Table *pTab;\n  SrcList *pTabList;\n  ExprList *pEList;\n  sqlite3 *db = pParse->db;\n  int fullName;    /* TABLE.COLUMN if no AS clause and is a direct table ref */\n  int srcName;     /* COLUMN or TABLE.COLUMN if no AS clause and is direct */\n\n#ifndef SQLITE_OMIT_EXPLAIN\n  /* If this is an EXPLAIN, skip this step */\n  if( pParse->explain ){\n    return;\n  }\n#endif\n\n  if( pParse->colNamesSet ) return;\n  /* Column names are determined by the left-most term of a compound select */\n  while( pSelect->pPrior ) pSelect = pSelect->pPrior;\n  SELECTTRACE(1,pParse,pSelect,(\"generating column names\\n\"));\n  pTabList = pSelect->pSrc;\n  pEList = pSelect->pEList;\n  assert( v!=0 );\n  assert( pTabList!=0 );\n  pParse->colNamesSet = 1;\n  fullName = (db->flags & SQLITE_FullColNames)!=0;\n  srcName = (db->flags & SQLITE_ShortColNames)!=0 || fullName;\n  sqlite3VdbeSetNumCols(v, pEList->nExpr);\n  for(i=0; i<pEList->nExpr; i++){\n    Expr *p = pEList->a[i].pExpr;\n\n    assert( p!=0 );\n    assert( p->op!=TK_AGG_COLUMN );  /* Agg processing has not run yet */\n    assert( p->op!=TK_COLUMN || p->y.pTab!=0 ); /* Covering idx not yet coded */\n    if( pEList->a[i].zName ){\n      /* An AS clause always takes first priority */\n      char *zName = pEList->a[i].zName;\n      sqlite3VdbeSetColName(v, i, COLNAME_NAME, zName, SQLITE_TRANSIENT);\n    }else if( srcName && p->op==TK_COLUMN ){\n      char *zCol;\n      int iCol = p->iColumn;\n      pTab = p->y.pTab;\n      assert( pTab!=0 );\n      if( iCol<0 ) iCol = pTab->iPKey;\n      assert( iCol==-1 || (iCol>=0 && iCol<pTab->nCol) );\n      if( iCol<0 ){\n        zCol = \"rowid\";\n      }else{\n        zCol = pTab->aCol[iCol].zName;\n      }\n      if( fullName ){\n        char *zName = 0;\n        zName = sqlite3MPrintf(db, \"%s.%s\", pTab->zName, zCol);\n        sqlite3VdbeSetColName(v, i, COLNAME_NAME, zName, SQLITE_DYNAMIC);\n      }else{\n        sqlite3VdbeSetColName(v, i, COLNAME_NAME, zCol, SQLITE_TRANSIENT);\n      }\n    }else{\n      const char *z = pEList->a[i].zSpan;\n      z = z==0 ? sqlite3MPrintf(db, \"column%d\", i+1) : sqlite3DbStrDup(db, z);\n      sqlite3VdbeSetColName(v, i, COLNAME_NAME, z, SQLITE_DYNAMIC);\n    }\n  }\n  generateColumnTypes(pParse, pTabList, pEList);\n}\n\n/*\n** Given an expression list (which is really the list of expressions\n** that form the result set of a SELECT statement) compute appropriate\n** column names for a table that would hold the expression list.\n**\n** All column names will be unique.\n**\n** Only the column names are computed.  Column.zType, Column.zColl,\n** and other fields of Column are zeroed.\n**\n** Return SQLITE_OK on success.  If a memory allocation error occurs,\n** store NULL in *paCol and 0 in *pnCol and return SQLITE_NOMEM.\n**\n** The only guarantee that SQLite makes about column names is that if the\n** column has an AS clause assigning it a name, that will be the name used.\n** That is the only documented guarantee.  However, countless applications\n** developed over the years have made baseless assumptions about column names\n** and will break if those assumptions changes.  Hence, use extreme caution\n** when modifying this routine to avoid breaking legacy.\n**\n** See Also: generateColumnNames()\n*/\nint sqlite3ColumnsFromExprList(\n  Parse *pParse,          /* Parsing context */\n  ExprList *pEList,       /* Expr list from which to derive column names */\n  i16 *pnCol,             /* Write the number of columns here */\n  Column **paCol          /* Write the new column list here */\n){\n  sqlite3 *db = pParse->db;   /* Database connection */\n  int i, j;                   /* Loop counters */\n  u32 cnt;                    /* Index added to make the name unique */\n  Column *aCol, *pCol;        /* For looping over result columns */\n  int nCol;                   /* Number of columns in the result set */\n  char *zName;                /* Column name */\n  int nName;                  /* Size of name in zName[] */\n  Hash ht;                    /* Hash table of column names */\n\n  sqlite3HashInit(&ht);\n  if( pEList ){\n    nCol = pEList->nExpr;\n    aCol = sqlite3DbMallocZero(db, sizeof(aCol[0])*nCol);\n    testcase( aCol==0 );\n    if( nCol>32767 ) nCol = 32767;\n  }else{\n    nCol = 0;\n    aCol = 0;\n  }\n  assert( nCol==(i16)nCol );\n  *pnCol = nCol;\n  *paCol = aCol;\n\n  for(i=0, pCol=aCol; i<nCol && !db->mallocFailed; i++, pCol++){\n    /* Get an appropriate name for the column\n    */\n    if( (zName = pEList->a[i].zName)!=0 ){\n      /* If the column contains an \"AS <name>\" phrase, use <name> as the name */\n    }else{\n      Expr *pColExpr = sqlite3ExprSkipCollateAndLikely(pEList->a[i].pExpr);\n      while( pColExpr->op==TK_DOT ){\n        pColExpr = pColExpr->pRight;\n        assert( pColExpr!=0 );\n      }\n      if( pColExpr->op==TK_COLUMN ){\n        /* For columns use the column name name */\n        int iCol = pColExpr->iColumn;\n        Table *pTab = pColExpr->y.pTab;\n        assert( pTab!=0 );\n        if( iCol<0 ) iCol = pTab->iPKey;\n        zName = iCol>=0 ? pTab->aCol[iCol].zName : \"rowid\";\n      }else if( pColExpr->op==TK_ID ){\n        assert( !ExprHasProperty(pColExpr, EP_IntValue) );\n        zName = pColExpr->u.zToken;\n      }else{\n        /* Use the original text of the column expression as its name */\n        zName = pEList->a[i].zSpan;\n      }\n    }\n    if( zName ){\n      zName = sqlite3DbStrDup(db, zName);\n    }else{\n      zName = sqlite3MPrintf(db,\"column%d\",i+1);\n    }\n\n    /* Make sure the column name is unique.  If the name is not unique,\n    ** append an integer to the name so that it becomes unique.\n    */\n    cnt = 0;\n    while( zName && sqlite3HashFind(&ht, zName)!=0 ){\n      nName = sqlite3Strlen30(zName);\n      if( nName>0 ){\n        for(j=nName-1; j>0 && sqlite3Isdigit(zName[j]); j--){}\n        if( zName[j]==':' ) nName = j;\n      }\n      zName = sqlite3MPrintf(db, \"%.*z:%u\", nName, zName, ++cnt);\n      if( cnt>3 ) sqlite3_randomness(sizeof(cnt), &cnt);\n    }\n    pCol->zName = zName;\n    sqlite3ColumnPropertiesFromName(0, pCol);\n    if( zName && sqlite3HashInsert(&ht, zName, pCol)==pCol ){\n      sqlite3OomFault(db);\n    }\n  }\n  sqlite3HashClear(&ht);\n  if( db->mallocFailed ){\n    for(j=0; j<i; j++){\n      sqlite3DbFree(db, aCol[j].zName);\n    }\n    sqlite3DbFree(db, aCol);\n    *paCol = 0;\n    *pnCol = 0;\n    return SQLITE_NOMEM_BKPT;\n  }\n  return SQLITE_OK;\n}\n\n/*\n** Add type and collation information to a column list based on\n** a SELECT statement.\n** \n** The column list presumably came from selectColumnNamesFromExprList().\n** The column list has only names, not types or collations.  This\n** routine goes through and adds the types and collations.\n**\n** This routine requires that all identifiers in the SELECT\n** statement be resolved.\n*/\nvoid sqlite3SelectAddColumnTypeAndCollation(\n  Parse *pParse,        /* Parsing contexts */\n  Table *pTab,          /* Add column type information to this table */\n  Select *pSelect,      /* SELECT used to determine types and collations */\n  char aff              /* Default affinity for columns */\n){\n  sqlite3 *db = pParse->db;\n  NameContext sNC;\n  Column *pCol;\n  CollSeq *pColl;\n  int i;\n  Expr *p;\n  struct ExprList_item *a;\n\n  assert( pSelect!=0 );\n  assert( (pSelect->selFlags & SF_Resolved)!=0 );\n  assert( pTab->nCol==pSelect->pEList->nExpr || db->mallocFailed );\n  if( db->mallocFailed ) return;\n  memset(&sNC, 0, sizeof(sNC));\n  sNC.pSrcList = pSelect->pSrc;\n  a = pSelect->pEList->a;\n  for(i=0, pCol=pTab->aCol; i<pTab->nCol; i++, pCol++){\n    const char *zType;\n    int n, m;\n    p = a[i].pExpr;\n    zType = columnType(&sNC, p, 0, 0, 0);\n    /* pCol->szEst = ... // Column size est for SELECT tables never used */\n    pCol->affinity = sqlite3ExprAffinity(p);\n    if( zType ){\n      m = sqlite3Strlen30(zType);\n      n = sqlite3Strlen30(pCol->zName);\n      pCol->zName = sqlite3DbReallocOrFree(db, pCol->zName, n+m+2);\n      if( pCol->zName ){\n        memcpy(&pCol->zName[n+1], zType, m+1);\n        pCol->colFlags |= COLFLAG_HASTYPE;\n      }\n    }\n    if( pCol->affinity<=SQLITE_AFF_NONE ) pCol->affinity = aff;\n    pColl = sqlite3ExprCollSeq(pParse, p);\n    if( pColl && pCol->zColl==0 ){\n      pCol->zColl = sqlite3DbStrDup(db, pColl->zName);\n    }\n  }\n  pTab->szTabRow = 1; /* Any non-zero value works */\n}\n\n/*\n** Given a SELECT statement, generate a Table structure that describes\n** the result set of that SELECT.\n*/\nTable *sqlite3ResultSetOfSelect(Parse *pParse, Select *pSelect, char aff){\n  Table *pTab;\n  sqlite3 *db = pParse->db;\n  u64 savedFlags;\n\n  savedFlags = db->flags;\n  db->flags &= ~(u64)SQLITE_FullColNames;\n  db->flags |= SQLITE_ShortColNames;\n  sqlite3SelectPrep(pParse, pSelect, 0);\n  db->flags = savedFlags;\n  if( pParse->nErr ) return 0;\n  while( pSelect->pPrior ) pSelect = pSelect->pPrior;\n  pTab = sqlite3DbMallocZero(db, sizeof(Table) );\n  if( pTab==0 ){\n    return 0;\n  }\n  pTab->nTabRef = 1;\n  pTab->zName = 0;\n  pTab->nRowLogEst = 200; assert( 200==sqlite3LogEst(1048576) );\n  sqlite3ColumnsFromExprList(pParse, pSelect->pEList, &pTab->nCol, &pTab->aCol);\n  sqlite3SelectAddColumnTypeAndCollation(pParse, pTab, pSelect, aff);\n  pTab->iPKey = -1;\n  if( db->mallocFailed ){\n    sqlite3DeleteTable(db, pTab);\n    return 0;\n  }\n  return pTab;\n}\n\n/*\n** Get a VDBE for the given parser context.  Create a new one if necessary.\n** If an error occurs, return NULL and leave a message in pParse.\n*/\nVdbe *sqlite3GetVdbe(Parse *pParse){\n  if( pParse->pVdbe ){\n    return pParse->pVdbe;\n  }\n  if( pParse->pToplevel==0\n   && OptimizationEnabled(pParse->db,SQLITE_FactorOutConst)\n  ){\n    pParse->okConstFactor = 1;\n  }\n  return sqlite3VdbeCreate(pParse);\n}\n\n\n/*\n** Compute the iLimit and iOffset fields of the SELECT based on the\n** pLimit expressions.  pLimit->pLeft and pLimit->pRight hold the expressions\n** that appear in the original SQL statement after the LIMIT and OFFSET\n** keywords.  Or NULL if those keywords are omitted. iLimit and iOffset \n** are the integer memory register numbers for counters used to compute \n** the limit and offset.  If there is no limit and/or offset, then \n** iLimit and iOffset are negative.\n**\n** This routine changes the values of iLimit and iOffset only if\n** a limit or offset is defined by pLimit->pLeft and pLimit->pRight.  iLimit\n** and iOffset should have been preset to appropriate default values (zero)\n** prior to calling this routine.\n**\n** The iOffset register (if it exists) is initialized to the value\n** of the OFFSET.  The iLimit register is initialized to LIMIT.  Register\n** iOffset+1 is initialized to LIMIT+OFFSET.\n**\n** Only if pLimit->pLeft!=0 do the limit registers get\n** redefined.  The UNION ALL operator uses this property to force\n** the reuse of the same limit and offset registers across multiple\n** SELECT statements.\n*/\nstatic void computeLimitRegisters(Parse *pParse, Select *p, int iBreak){\n  Vdbe *v = 0;\n  int iLimit = 0;\n  int iOffset;\n  int n;\n  Expr *pLimit = p->pLimit;\n\n  if( p->iLimit ) return;\n\n  /* \n  ** \"LIMIT -1\" always shows all rows.  There is some\n  ** controversy about what the correct behavior should be.\n  ** The current implementation interprets \"LIMIT 0\" to mean\n  ** no rows.\n  */\n  if( pLimit ){\n    assert( pLimit->op==TK_LIMIT );\n    assert( pLimit->pLeft!=0 );\n    p->iLimit = iLimit = ++pParse->nMem;\n    v = sqlite3GetVdbe(pParse);\n    assert( v!=0 );\n    if( sqlite3ExprIsInteger(pLimit->pLeft, &n) ){\n      sqlite3VdbeAddOp2(v, OP_Integer, n, iLimit);\n      VdbeComment((v, \"LIMIT counter\"));\n      if( n==0 ){\n        sqlite3VdbeGoto(v, iBreak);\n      }else if( n>=0 && p->nSelectRow>sqlite3LogEst((u64)n) ){\n        p->nSelectRow = sqlite3LogEst((u64)n);\n        p->selFlags |= SF_FixedLimit;\n      }\n    }else{\n      sqlite3ExprCode(pParse, pLimit->pLeft, iLimit);\n      sqlite3VdbeAddOp1(v, OP_MustBeInt, iLimit); VdbeCoverage(v);\n      VdbeComment((v, \"LIMIT counter\"));\n      sqlite3VdbeAddOp2(v, OP_IfNot, iLimit, iBreak); VdbeCoverage(v);\n    }\n    if( pLimit->pRight ){\n      p->iOffset = iOffset = ++pParse->nMem;\n      pParse->nMem++;   /* Allocate an extra register for limit+offset */\n      sqlite3ExprCode(pParse, pLimit->pRight, iOffset);\n      sqlite3VdbeAddOp1(v, OP_MustBeInt, iOffset); VdbeCoverage(v);\n      VdbeComment((v, \"OFFSET counter\"));\n      sqlite3VdbeAddOp3(v, OP_OffsetLimit, iLimit, iOffset+1, iOffset);\n      VdbeComment((v, \"LIMIT+OFFSET\"));\n    }\n  }\n}\n\n#ifndef SQLITE_OMIT_COMPOUND_SELECT\n/*\n** Return the appropriate collating sequence for the iCol-th column of\n** the result set for the compound-select statement \"p\".  Return NULL if\n** the column has no default collating sequence.\n**\n** The collating sequence for the compound select is taken from the\n** left-most term of the select that has a collating sequence.\n*/\nstatic CollSeq *multiSelectCollSeq(Parse *pParse, Select *p, int iCol){\n  CollSeq *pRet;\n  if( p->pPrior ){\n    pRet = multiSelectCollSeq(pParse, p->pPrior, iCol);\n  }else{\n    pRet = 0;\n  }\n  assert( iCol>=0 );\n  /* iCol must be less than p->pEList->nExpr.  Otherwise an error would\n  ** have been thrown during name resolution and we would not have gotten\n  ** this far */\n  if( pRet==0 && ALWAYS(iCol<p->pEList->nExpr) ){\n    pRet = sqlite3ExprCollSeq(pParse, p->pEList->a[iCol].pExpr);\n  }\n  return pRet;\n}\n\n/*\n** The select statement passed as the second parameter is a compound SELECT\n** with an ORDER BY clause. This function allocates and returns a KeyInfo\n** structure suitable for implementing the ORDER BY.\n**\n** Space to hold the KeyInfo structure is obtained from malloc. The calling\n** function is responsible for ensuring that this structure is eventually\n** freed.\n*/\nstatic KeyInfo *multiSelectOrderByKeyInfo(Parse *pParse, Select *p, int nExtra){\n  ExprList *pOrderBy = p->pOrderBy;\n  int nOrderBy = p->pOrderBy->nExpr;\n  sqlite3 *db = pParse->db;\n  KeyInfo *pRet = sqlite3KeyInfoAlloc(db, nOrderBy+nExtra, 1);\n  if( pRet ){\n    int i;\n    for(i=0; i<nOrderBy; i++){\n      struct ExprList_item *pItem = &pOrderBy->a[i];\n      Expr *pTerm = pItem->pExpr;\n      CollSeq *pColl;\n\n      if( pTerm->flags & EP_Collate ){\n        pColl = sqlite3ExprCollSeq(pParse, pTerm);\n      }else{\n        pColl = multiSelectCollSeq(pParse, p, pItem->u.x.iOrderByCol-1);\n        if( pColl==0 ) pColl = db->pDfltColl;\n        pOrderBy->a[i].pExpr =\n          sqlite3ExprAddCollateString(pParse, pTerm, pColl->zName);\n      }\n      assert( sqlite3KeyInfoIsWriteable(pRet) );\n      pRet->aColl[i] = pColl;\n      pRet->aSortFlags[i] = pOrderBy->a[i].sortFlags;\n    }\n  }\n\n  return pRet;\n}\n\n#ifndef SQLITE_OMIT_CTE\n/*\n** This routine generates VDBE code to compute the content of a WITH RECURSIVE\n** query of the form:\n**\n**   <recursive-table> AS (<setup-query> UNION [ALL] <recursive-query>)\n**                         \\___________/             \\_______________/\n**                           p->pPrior                      p\n**\n**\n** There is exactly one reference to the recursive-table in the FROM clause\n** of recursive-query, marked with the SrcList->a[].fg.isRecursive flag.\n**\n** The setup-query runs once to generate an initial set of rows that go\n** into a Queue table.  Rows are extracted from the Queue table one by\n** one.  Each row extracted from Queue is output to pDest.  Then the single\n** extracted row (now in the iCurrent table) becomes the content of the\n** recursive-table for a recursive-query run.  The output of the recursive-query\n** is added back into the Queue table.  Then another row is extracted from Queue\n** and the iteration continues until the Queue table is empty.\n**\n** If the compound query operator is UNION then no duplicate rows are ever\n** inserted into the Queue table.  The iDistinct table keeps a copy of all rows\n** that have ever been inserted into Queue and causes duplicates to be\n** discarded.  If the operator is UNION ALL, then duplicates are allowed.\n** \n** If the query has an ORDER BY, then entries in the Queue table are kept in\n** ORDER BY order and the first entry is extracted for each cycle.  Without\n** an ORDER BY, the Queue table is just a FIFO.\n**\n** If a LIMIT clause is provided, then the iteration stops after LIMIT rows\n** have been output to pDest.  A LIMIT of zero means to output no rows and a\n** negative LIMIT means to output all rows.  If there is also an OFFSET clause\n** with a positive value, then the first OFFSET outputs are discarded rather\n** than being sent to pDest.  The LIMIT count does not begin until after OFFSET\n** rows have been skipped.\n*/\nstatic void generateWithRecursiveQuery(\n  Parse *pParse,        /* Parsing context */\n  Select *p,            /* The recursive SELECT to be coded */\n  SelectDest *pDest     /* What to do with query results */\n){\n  SrcList *pSrc = p->pSrc;      /* The FROM clause of the recursive query */\n  int nCol = p->pEList->nExpr;  /* Number of columns in the recursive table */\n  Vdbe *v = pParse->pVdbe;      /* The prepared statement under construction */\n  Select *pSetup = p->pPrior;   /* The setup query */\n  int addrTop;                  /* Top of the loop */\n  int addrCont, addrBreak;      /* CONTINUE and BREAK addresses */\n  int iCurrent = 0;             /* The Current table */\n  int regCurrent;               /* Register holding Current table */\n  int iQueue;                   /* The Queue table */\n  int iDistinct = 0;            /* To ensure unique results if UNION */\n  int eDest = SRT_Fifo;         /* How to write to Queue */\n  SelectDest destQueue;         /* SelectDest targetting the Queue table */\n  int i;                        /* Loop counter */\n  int rc;                       /* Result code */\n  ExprList *pOrderBy;           /* The ORDER BY clause */\n  Expr *pLimit;                 /* Saved LIMIT and OFFSET */\n  int regLimit, regOffset;      /* Registers used by LIMIT and OFFSET */\n\n#ifndef SQLITE_OMIT_WINDOWFUNC\n  if( p->pWin ){\n    sqlite3ErrorMsg(pParse, \"cannot use window functions in recursive queries\");\n    return;\n  }\n#endif\n\n  /* Obtain authorization to do a recursive query */\n  if( sqlite3AuthCheck(pParse, SQLITE_RECURSIVE, 0, 0, 0) ) return;\n\n  /* Process the LIMIT and OFFSET clauses, if they exist */\n  addrBreak = sqlite3VdbeMakeLabel(pParse);\n  p->nSelectRow = 320;  /* 4 billion rows */\n  computeLimitRegisters(pParse, p, addrBreak);\n  pLimit = p->pLimit;\n  regLimit = p->iLimit;\n  regOffset = p->iOffset;\n  p->pLimit = 0;\n  p->iLimit = p->iOffset = 0;\n  pOrderBy = p->pOrderBy;\n\n  /* Locate the cursor number of the Current table */\n  for(i=0; ALWAYS(i<pSrc->nSrc); i++){\n    if( pSrc->a[i].fg.isRecursive ){\n      iCurrent = pSrc->a[i].iCursor;\n      break;\n    }\n  }\n\n  /* Allocate cursors numbers for Queue and Distinct.  The cursor number for\n  ** the Distinct table must be exactly one greater than Queue in order\n  ** for the SRT_DistFifo and SRT_DistQueue destinations to work. */\n  iQueue = pParse->nTab++;\n  if( p->op==TK_UNION ){\n    eDest = pOrderBy ? SRT_DistQueue : SRT_DistFifo;\n    iDistinct = pParse->nTab++;\n  }else{\n    eDest = pOrderBy ? SRT_Queue : SRT_Fifo;\n  }\n  sqlite3SelectDestInit(&destQueue, eDest, iQueue);\n\n  /* Allocate cursors for Current, Queue, and Distinct. */\n  regCurrent = ++pParse->nMem;\n  sqlite3VdbeAddOp3(v, OP_OpenPseudo, iCurrent, regCurrent, nCol);\n  if( pOrderBy ){\n    KeyInfo *pKeyInfo = multiSelectOrderByKeyInfo(pParse, p, 1);\n    sqlite3VdbeAddOp4(v, OP_OpenEphemeral, iQueue, pOrderBy->nExpr+2, 0,\n                      (char*)pKeyInfo, P4_KEYINFO);\n    destQueue.pOrderBy = pOrderBy;\n  }else{\n    sqlite3VdbeAddOp2(v, OP_OpenEphemeral, iQueue, nCol);\n  }\n  VdbeComment((v, \"Queue table\"));\n  if( iDistinct ){\n    p->addrOpenEphm[0] = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, iDistinct, 0);\n    p->selFlags |= SF_UsesEphemeral;\n  }\n\n  /* Detach the ORDER BY clause from the compound SELECT */\n  p->pOrderBy = 0;\n\n  /* Store the results of the setup-query in Queue. */\n  pSetup->pNext = 0;\n  ExplainQueryPlan((pParse, 1, \"SETUP\"));\n  rc = sqlite3Select(pParse, pSetup, &destQueue);\n  pSetup->pNext = p;\n  if( rc ) goto end_of_recursive_query;\n\n  /* Find the next row in the Queue and output that row */\n  addrTop = sqlite3VdbeAddOp2(v, OP_Rewind, iQueue, addrBreak); VdbeCoverage(v);\n\n  /* Transfer the next row in Queue over to Current */\n  sqlite3VdbeAddOp1(v, OP_NullRow, iCurrent); /* To reset column cache */\n  if( pOrderBy ){\n    sqlite3VdbeAddOp3(v, OP_Column, iQueue, pOrderBy->nExpr+1, regCurrent);\n  }else{\n    sqlite3VdbeAddOp2(v, OP_RowData, iQueue, regCurrent);\n  }\n  sqlite3VdbeAddOp1(v, OP_Delete, iQueue);\n\n  /* Output the single row in Current */\n  addrCont = sqlite3VdbeMakeLabel(pParse);\n  codeOffset(v, regOffset, addrCont);\n  selectInnerLoop(pParse, p, iCurrent,\n      0, 0, pDest, addrCont, addrBreak);\n  if( regLimit ){\n    sqlite3VdbeAddOp2(v, OP_DecrJumpZero, regLimit, addrBreak);\n    VdbeCoverage(v);\n  }\n  sqlite3VdbeResolveLabel(v, addrCont);\n\n  /* Execute the recursive SELECT taking the single row in Current as\n  ** the value for the recursive-table. Store the results in the Queue.\n  */\n  if( p->selFlags & SF_Aggregate ){\n    sqlite3ErrorMsg(pParse, \"recursive aggregate queries not supported\");\n  }else{\n    p->pPrior = 0;\n    ExplainQueryPlan((pParse, 1, \"RECURSIVE STEP\"));\n    sqlite3Select(pParse, p, &destQueue);\n    assert( p->pPrior==0 );\n    p->pPrior = pSetup;\n  }\n\n  /* Keep running the loop until the Queue is empty */\n  sqlite3VdbeGoto(v, addrTop);\n  sqlite3VdbeResolveLabel(v, addrBreak);\n\nend_of_recursive_query:\n  sqlite3ExprListDelete(pParse->db, p->pOrderBy);\n  p->pOrderBy = pOrderBy;\n  p->pLimit = pLimit;\n  return;\n}\n#endif /* SQLITE_OMIT_CTE */\n\n/* Forward references */\nstatic int multiSelectOrderBy(\n  Parse *pParse,        /* Parsing context */\n  Select *p,            /* The right-most of SELECTs to be coded */\n  SelectDest *pDest     /* What to do with query results */\n);\n\n/*\n** Handle the special case of a compound-select that originates from a\n** VALUES clause.  By handling this as a special case, we avoid deep\n** recursion, and thus do not need to enforce the SQLITE_LIMIT_COMPOUND_SELECT\n** on a VALUES clause.\n**\n** Because the Select object originates from a VALUES clause:\n**   (1) There is no LIMIT or OFFSET or else there is a LIMIT of exactly 1\n**   (2) All terms are UNION ALL\n**   (3) There is no ORDER BY clause\n**\n** The \"LIMIT of exactly 1\" case of condition (1) comes about when a VALUES\n** clause occurs within scalar expression (ex: \"SELECT (VALUES(1),(2),(3))\").\n** The sqlite3CodeSubselect will have added the LIMIT 1 clause in tht case.\n** Since the limit is exactly 1, we only need to evalutes the left-most VALUES.\n*/\nstatic int multiSelectValues(\n  Parse *pParse,        /* Parsing context */\n  Select *p,            /* The right-most of SELECTs to be coded */\n  SelectDest *pDest     /* What to do with query results */\n){\n  int nRow = 1;\n  int rc = 0;\n  int bShowAll = p->pLimit==0;\n  assert( p->selFlags & SF_MultiValue );\n  do{\n    assert( p->selFlags & SF_Values );\n    assert( p->op==TK_ALL || (p->op==TK_SELECT && p->pPrior==0) );\n    assert( p->pNext==0 || p->pEList->nExpr==p->pNext->pEList->nExpr );\n    if( p->pWin ) return -1;\n    if( p->pPrior==0 ) break;\n    assert( p->pPrior->pNext==p );\n    p = p->pPrior;\n    nRow += bShowAll;\n  }while(1);\n  ExplainQueryPlan((pParse, 0, \"SCAN %d CONSTANT ROW%s\", nRow,\n                    nRow==1 ? \"\" : \"S\"));\n  while( p ){\n    selectInnerLoop(pParse, p, -1, 0, 0, pDest, 1, 1);\n    if( !bShowAll ) break;\n    p->nSelectRow = nRow;\n    p = p->pNext;\n  }\n  return rc;\n}\n\n/*\n** This routine is called to process a compound query form from\n** two or more separate queries using UNION, UNION ALL, EXCEPT, or\n** INTERSECT\n**\n** \"p\" points to the right-most of the two queries.  the query on the\n** left is p->pPrior.  The left query could also be a compound query\n** in which case this routine will be called recursively. \n**\n** The results of the total query are to be written into a destination\n** of type eDest with parameter iParm.\n**\n** Example 1:  Consider a three-way compound SQL statement.\n**\n**     SELECT a FROM t1 UNION SELECT b FROM t2 UNION SELECT c FROM t3\n**\n** This statement is parsed up as follows:\n**\n**     SELECT c FROM t3\n**      |\n**      `----->  SELECT b FROM t2\n**                |\n**                `------>  SELECT a FROM t1\n**\n** The arrows in the diagram above represent the Select.pPrior pointer.\n** So if this routine is called with p equal to the t3 query, then\n** pPrior will be the t2 query.  p->op will be TK_UNION in this case.\n**\n** Notice that because of the way SQLite parses compound SELECTs, the\n** individual selects always group from left to right.\n*/\nstatic int multiSelect(\n  Parse *pParse,        /* Parsing context */\n  Select *p,            /* The right-most of SELECTs to be coded */\n  SelectDest *pDest     /* What to do with query results */\n){\n  int rc = SQLITE_OK;   /* Success code from a subroutine */\n  Select *pPrior;       /* Another SELECT immediately to our left */\n  Vdbe *v;              /* Generate code to this VDBE */\n  SelectDest dest;      /* Alternative data destination */\n  Select *pDelete = 0;  /* Chain of simple selects to delete */\n  sqlite3 *db;          /* Database connection */\n\n  /* Make sure there is no ORDER BY or LIMIT clause on prior SELECTs.  Only\n  ** the last (right-most) SELECT in the series may have an ORDER BY or LIMIT.\n  */\n  assert( p && p->pPrior );  /* Calling function guarantees this much */\n  assert( (p->selFlags & SF_Recursive)==0 || p->op==TK_ALL || p->op==TK_UNION );\n  assert( p->selFlags & SF_Compound );\n  db = pParse->db;\n  pPrior = p->pPrior;\n  dest = *pDest;\n  if( pPrior->pOrderBy || pPrior->pLimit ){\n    sqlite3ErrorMsg(pParse,\"%s clause should come after %s not before\",\n      pPrior->pOrderBy!=0 ? \"ORDER BY\" : \"LIMIT\", selectOpName(p->op));\n    rc = 1;\n    goto multi_select_end;\n  }\n\n  v = sqlite3GetVdbe(pParse);\n  assert( v!=0 );  /* The VDBE already created by calling function */\n\n  /* Create the destination temporary table if necessary\n  */\n  if( dest.eDest==SRT_EphemTab ){\n    assert( p->pEList );\n    sqlite3VdbeAddOp2(v, OP_OpenEphemeral, dest.iSDParm, p->pEList->nExpr);\n    dest.eDest = SRT_Table;\n  }\n\n  /* Special handling for a compound-select that originates as a VALUES clause.\n  */\n  if( p->selFlags & SF_MultiValue ){\n    rc = multiSelectValues(pParse, p, &dest);\n    if( rc>=0 ) goto multi_select_end;\n    rc = SQLITE_OK;\n  }\n\n  /* Make sure all SELECTs in the statement have the same number of elements\n  ** in their result sets.\n  */\n  assert( p->pEList && pPrior->pEList );\n  assert( p->pEList->nExpr==pPrior->pEList->nExpr );\n\n#ifndef SQLITE_OMIT_CTE\n  if( p->selFlags & SF_Recursive ){\n    generateWithRecursiveQuery(pParse, p, &dest);\n  }else\n#endif\n\n  /* Compound SELECTs that have an ORDER BY clause are handled separately.\n  */\n  if( p->pOrderBy ){\n    return multiSelectOrderBy(pParse, p, pDest);\n  }else{\n\n#ifndef SQLITE_OMIT_EXPLAIN\n    if( pPrior->pPrior==0 ){\n      ExplainQueryPlan((pParse, 1, \"COMPOUND QUERY\"));\n      ExplainQueryPlan((pParse, 1, \"LEFT-MOST SUBQUERY\"));\n    }\n#endif\n\n    /* Generate code for the left and right SELECT statements.\n    */\n    switch( p->op ){\n      case TK_ALL: {\n        int addr = 0;\n        int nLimit;\n        assert( !pPrior->pLimit );\n        pPrior->iLimit = p->iLimit;\n        pPrior->iOffset = p->iOffset;\n        pPrior->pLimit = p->pLimit;\n        rc = sqlite3Select(pParse, pPrior, &dest);\n        p->pLimit = 0;\n        if( rc ){\n          goto multi_select_end;\n        }\n        p->pPrior = 0;\n        p->iLimit = pPrior->iLimit;\n        p->iOffset = pPrior->iOffset;\n        if( p->iLimit ){\n          addr = sqlite3VdbeAddOp1(v, OP_IfNot, p->iLimit); VdbeCoverage(v);\n          VdbeComment((v, \"Jump ahead if LIMIT reached\"));\n          if( p->iOffset ){\n            sqlite3VdbeAddOp3(v, OP_OffsetLimit,\n                              p->iLimit, p->iOffset+1, p->iOffset);\n          }\n        }\n        ExplainQueryPlan((pParse, 1, \"UNION ALL\"));\n        rc = sqlite3Select(pParse, p, &dest);\n        testcase( rc!=SQLITE_OK );\n        pDelete = p->pPrior;\n        p->pPrior = pPrior;\n        p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);\n        if( pPrior->pLimit\n         && sqlite3ExprIsInteger(pPrior->pLimit->pLeft, &nLimit)\n         && nLimit>0 && p->nSelectRow > sqlite3LogEst((u64)nLimit) \n        ){\n          p->nSelectRow = sqlite3LogEst((u64)nLimit);\n        }\n        if( addr ){\n          sqlite3VdbeJumpHere(v, addr);\n        }\n        break;\n      }\n      case TK_EXCEPT:\n      case TK_UNION: {\n        int unionTab;    /* Cursor number of the temp table holding result */\n        u8 op = 0;       /* One of the SRT_ operations to apply to self */\n        int priorOp;     /* The SRT_ operation to apply to prior selects */\n        Expr *pLimit;    /* Saved values of p->nLimit  */\n        int addr;\n        SelectDest uniondest;\n  \n        testcase( p->op==TK_EXCEPT );\n        testcase( p->op==TK_UNION );\n        priorOp = SRT_Union;\n        if( dest.eDest==priorOp ){\n          /* We can reuse a temporary table generated by a SELECT to our\n          ** right.\n          */\n          assert( p->pLimit==0 );      /* Not allowed on leftward elements */\n          unionTab = dest.iSDParm;\n        }else{\n          /* We will need to create our own temporary table to hold the\n          ** intermediate results.\n          */\n          unionTab = pParse->nTab++;\n          assert( p->pOrderBy==0 );\n          addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, unionTab, 0);\n          assert( p->addrOpenEphm[0] == -1 );\n          p->addrOpenEphm[0] = addr;\n          findRightmost(p)->selFlags |= SF_UsesEphemeral;\n          assert( p->pEList );\n        }\n  \n        /* Code the SELECT statements to our left\n        */\n        assert( !pPrior->pOrderBy );\n        sqlite3SelectDestInit(&uniondest, priorOp, unionTab);\n        rc = sqlite3Select(pParse, pPrior, &uniondest);\n        if( rc ){\n          goto multi_select_end;\n        }\n  \n        /* Code the current SELECT statement\n        */\n        if( p->op==TK_EXCEPT ){\n          op = SRT_Except;\n        }else{\n          assert( p->op==TK_UNION );\n          op = SRT_Union;\n        }\n        p->pPrior = 0;\n        pLimit = p->pLimit;\n        p->pLimit = 0;\n        uniondest.eDest = op;\n        ExplainQueryPlan((pParse, 1, \"%s USING TEMP B-TREE\",\n                          selectOpName(p->op)));\n        rc = sqlite3Select(pParse, p, &uniondest);\n        testcase( rc!=SQLITE_OK );\n        /* Query flattening in sqlite3Select() might refill p->pOrderBy.\n        ** Be sure to delete p->pOrderBy, therefore, to avoid a memory leak. */\n        sqlite3ExprListDelete(db, p->pOrderBy);\n        pDelete = p->pPrior;\n        p->pPrior = pPrior;\n        p->pOrderBy = 0;\n        if( p->op==TK_UNION ){\n          p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);\n        }\n        sqlite3ExprDelete(db, p->pLimit);\n        p->pLimit = pLimit;\n        p->iLimit = 0;\n        p->iOffset = 0;\n  \n        /* Convert the data in the temporary table into whatever form\n        ** it is that we currently need.\n        */\n        assert( unionTab==dest.iSDParm || dest.eDest!=priorOp );\n        if( dest.eDest!=priorOp ){\n          int iCont, iBreak, iStart;\n          assert( p->pEList );\n          iBreak = sqlite3VdbeMakeLabel(pParse);\n          iCont = sqlite3VdbeMakeLabel(pParse);\n          computeLimitRegisters(pParse, p, iBreak);\n          sqlite3VdbeAddOp2(v, OP_Rewind, unionTab, iBreak); VdbeCoverage(v);\n          iStart = sqlite3VdbeCurrentAddr(v);\n          selectInnerLoop(pParse, p, unionTab,\n                          0, 0, &dest, iCont, iBreak);\n          sqlite3VdbeResolveLabel(v, iCont);\n          sqlite3VdbeAddOp2(v, OP_Next, unionTab, iStart); VdbeCoverage(v);\n          sqlite3VdbeResolveLabel(v, iBreak);\n          sqlite3VdbeAddOp2(v, OP_Close, unionTab, 0);\n        }\n        break;\n      }\n      default: assert( p->op==TK_INTERSECT ); {\n        int tab1, tab2;\n        int iCont, iBreak, iStart;\n        Expr *pLimit;\n        int addr;\n        SelectDest intersectdest;\n        int r1;\n  \n        /* INTERSECT is different from the others since it requires\n        ** two temporary tables.  Hence it has its own case.  Begin\n        ** by allocating the tables we will need.\n        */\n        tab1 = pParse->nTab++;\n        tab2 = pParse->nTab++;\n        assert( p->pOrderBy==0 );\n  \n        addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, tab1, 0);\n        assert( p->addrOpenEphm[0] == -1 );\n        p->addrOpenEphm[0] = addr;\n        findRightmost(p)->selFlags |= SF_UsesEphemeral;\n        assert( p->pEList );\n  \n        /* Code the SELECTs to our left into temporary table \"tab1\".\n        */\n        sqlite3SelectDestInit(&intersectdest, SRT_Union, tab1);\n        rc = sqlite3Select(pParse, pPrior, &intersectdest);\n        if( rc ){\n          goto multi_select_end;\n        }\n  \n        /* Code the current SELECT into temporary table \"tab2\"\n        */\n        addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, tab2, 0);\n        assert( p->addrOpenEphm[1] == -1 );\n        p->addrOpenEphm[1] = addr;\n        p->pPrior = 0;\n        pLimit = p->pLimit;\n        p->pLimit = 0;\n        intersectdest.iSDParm = tab2;\n        ExplainQueryPlan((pParse, 1, \"%s USING TEMP B-TREE\",\n                          selectOpName(p->op)));\n        rc = sqlite3Select(pParse, p, &intersectdest);\n        testcase( rc!=SQLITE_OK );\n        pDelete = p->pPrior;\n        p->pPrior = pPrior;\n        if( p->nSelectRow>pPrior->nSelectRow ){\n          p->nSelectRow = pPrior->nSelectRow;\n        }\n        sqlite3ExprDelete(db, p->pLimit);\n        p->pLimit = pLimit;\n  \n        /* Generate code to take the intersection of the two temporary\n        ** tables.\n        */\n        assert( p->pEList );\n        iBreak = sqlite3VdbeMakeLabel(pParse);\n        iCont = sqlite3VdbeMakeLabel(pParse);\n        computeLimitRegisters(pParse, p, iBreak);\n        sqlite3VdbeAddOp2(v, OP_Rewind, tab1, iBreak); VdbeCoverage(v);\n        r1 = sqlite3GetTempReg(pParse);\n        iStart = sqlite3VdbeAddOp2(v, OP_RowData, tab1, r1);\n        sqlite3VdbeAddOp4Int(v, OP_NotFound, tab2, iCont, r1, 0);\n        VdbeCoverage(v);\n        sqlite3ReleaseTempReg(pParse, r1);\n        selectInnerLoop(pParse, p, tab1,\n                        0, 0, &dest, iCont, iBreak);\n        sqlite3VdbeResolveLabel(v, iCont);\n        sqlite3VdbeAddOp2(v, OP_Next, tab1, iStart); VdbeCoverage(v);\n        sqlite3VdbeResolveLabel(v, iBreak);\n        sqlite3VdbeAddOp2(v, OP_Close, tab2, 0);\n        sqlite3VdbeAddOp2(v, OP_Close, tab1, 0);\n        break;\n      }\n    }\n  \n  #ifndef SQLITE_OMIT_EXPLAIN\n    if( p->pNext==0 ){\n      ExplainQueryPlanPop(pParse);\n    }\n  #endif\n  }\n  if( pParse->nErr ) goto multi_select_end;\n  \n  /* Compute collating sequences used by \n  ** temporary tables needed to implement the compound select.\n  ** Attach the KeyInfo structure to all temporary tables.\n  **\n  ** This section is run by the right-most SELECT statement only.\n  ** SELECT statements to the left always skip this part.  The right-most\n  ** SELECT might also skip this part if it has no ORDER BY clause and\n  ** no temp tables are required.\n  */\n  if( p->selFlags & SF_UsesEphemeral ){\n    int i;                        /* Loop counter */\n    KeyInfo *pKeyInfo;            /* Collating sequence for the result set */\n    Select *pLoop;                /* For looping through SELECT statements */\n    CollSeq **apColl;             /* For looping through pKeyInfo->aColl[] */\n    int nCol;                     /* Number of columns in result set */\n\n    assert( p->pNext==0 );\n    nCol = p->pEList->nExpr;\n    pKeyInfo = sqlite3KeyInfoAlloc(db, nCol, 1);\n    if( !pKeyInfo ){\n      rc = SQLITE_NOMEM_BKPT;\n      goto multi_select_end;\n    }\n    for(i=0, apColl=pKeyInfo->aColl; i<nCol; i++, apColl++){\n      *apColl = multiSelectCollSeq(pParse, p, i);\n      if( 0==*apColl ){\n        *apColl = db->pDfltColl;\n      }\n    }\n\n    for(pLoop=p; pLoop; pLoop=pLoop->pPrior){\n      for(i=0; i<2; i++){\n        int addr = pLoop->addrOpenEphm[i];\n        if( addr<0 ){\n          /* If [0] is unused then [1] is also unused.  So we can\n          ** always safely abort as soon as the first unused slot is found */\n          assert( pLoop->addrOpenEphm[1]<0 );\n          break;\n        }\n        sqlite3VdbeChangeP2(v, addr, nCol);\n        sqlite3VdbeChangeP4(v, addr, (char*)sqlite3KeyInfoRef(pKeyInfo),\n                            P4_KEYINFO);\n        pLoop->addrOpenEphm[i] = -1;\n      }\n    }\n    sqlite3KeyInfoUnref(pKeyInfo);\n  }\n\nmulti_select_end:\n  pDest->iSdst = dest.iSdst;\n  pDest->nSdst = dest.nSdst;\n  sqlite3SelectDelete(db, pDelete);\n  return rc;\n}\n#endif /* SQLITE_OMIT_COMPOUND_SELECT */\n\n/*\n** Error message for when two or more terms of a compound select have different\n** size result sets.\n*/\nvoid sqlite3SelectWrongNumTermsError(Parse *pParse, Select *p){\n  if( p->selFlags & SF_Values ){\n    sqlite3ErrorMsg(pParse, \"all VALUES must have the same number of terms\");\n  }else{\n    sqlite3ErrorMsg(pParse, \"SELECTs to the left and right of %s\"\n      \" do not have the same number of result columns\", selectOpName(p->op));\n  }\n}\n\n/*\n** Code an output subroutine for a coroutine implementation of a\n** SELECT statment.\n**\n** The data to be output is contained in pIn->iSdst.  There are\n** pIn->nSdst columns to be output.  pDest is where the output should\n** be sent.\n**\n** regReturn is the number of the register holding the subroutine\n** return address.\n**\n** If regPrev>0 then it is the first register in a vector that\n** records the previous output.  mem[regPrev] is a flag that is false\n** if there has been no previous output.  If regPrev>0 then code is\n** generated to suppress duplicates.  pKeyInfo is used for comparing\n** keys.\n**\n** If the LIMIT found in p->iLimit is reached, jump immediately to\n** iBreak.\n*/\nstatic int generateOutputSubroutine(\n  Parse *pParse,          /* Parsing context */\n  Select *p,              /* The SELECT statement */\n  SelectDest *pIn,        /* Coroutine supplying data */\n  SelectDest *pDest,      /* Where to send the data */\n  int regReturn,          /* The return address register */\n  int regPrev,            /* Previous result register.  No uniqueness if 0 */\n  KeyInfo *pKeyInfo,      /* For comparing with previous entry */\n  int iBreak              /* Jump here if we hit the LIMIT */\n){\n  Vdbe *v = pParse->pVdbe;\n  int iContinue;\n  int addr;\n\n  addr = sqlite3VdbeCurrentAddr(v);\n  iContinue = sqlite3VdbeMakeLabel(pParse);\n\n  /* Suppress duplicates for UNION, EXCEPT, and INTERSECT \n  */\n  if( regPrev ){\n    int addr1, addr2;\n    addr1 = sqlite3VdbeAddOp1(v, OP_IfNot, regPrev); VdbeCoverage(v);\n    addr2 = sqlite3VdbeAddOp4(v, OP_Compare, pIn->iSdst, regPrev+1, pIn->nSdst,\n                              (char*)sqlite3KeyInfoRef(pKeyInfo), P4_KEYINFO);\n    sqlite3VdbeAddOp3(v, OP_Jump, addr2+2, iContinue, addr2+2); VdbeCoverage(v);\n    sqlite3VdbeJumpHere(v, addr1);\n    sqlite3VdbeAddOp3(v, OP_Copy, pIn->iSdst, regPrev+1, pIn->nSdst-1);\n    sqlite3VdbeAddOp2(v, OP_Integer, 1, regPrev);\n  }\n  if( pParse->db->mallocFailed ) return 0;\n\n  /* Suppress the first OFFSET entries if there is an OFFSET clause\n  */\n  codeOffset(v, p->iOffset, iContinue);\n\n  assert( pDest->eDest!=SRT_Exists );\n  assert( pDest->eDest!=SRT_Table );\n  switch( pDest->eDest ){\n    /* Store the result as data using a unique key.\n    */\n    case SRT_EphemTab: {\n      int r1 = sqlite3GetTempReg(pParse);\n      int r2 = sqlite3GetTempReg(pParse);\n      sqlite3VdbeAddOp3(v, OP_MakeRecord, pIn->iSdst, pIn->nSdst, r1);\n      sqlite3VdbeAddOp2(v, OP_NewRowid, pDest->iSDParm, r2);\n      sqlite3VdbeAddOp3(v, OP_Insert, pDest->iSDParm, r1, r2);\n      sqlite3VdbeChangeP5(v, OPFLAG_APPEND);\n      sqlite3ReleaseTempReg(pParse, r2);\n      sqlite3ReleaseTempReg(pParse, r1);\n      break;\n    }\n\n#ifndef SQLITE_OMIT_SUBQUERY\n    /* If we are creating a set for an \"expr IN (SELECT ...)\".\n    */\n    case SRT_Set: {\n      int r1;\n      testcase( pIn->nSdst>1 );\n      r1 = sqlite3GetTempReg(pParse);\n      sqlite3VdbeAddOp4(v, OP_MakeRecord, pIn->iSdst, pIn->nSdst, \n          r1, pDest->zAffSdst, pIn->nSdst);\n      sqlite3VdbeAddOp4Int(v, OP_IdxInsert, pDest->iSDParm, r1,\n                           pIn->iSdst, pIn->nSdst);\n      sqlite3ReleaseTempReg(pParse, r1);\n      break;\n    }\n\n    /* If this is a scalar select that is part of an expression, then\n    ** store the results in the appropriate memory cell and break out\n    ** of the scan loop.  Note that the select might return multiple columns\n    ** if it is the RHS of a row-value IN operator.\n    */\n    case SRT_Mem: {\n      if( pParse->nErr==0 ){\n        testcase( pIn->nSdst>1 );\n        sqlite3ExprCodeMove(pParse, pIn->iSdst, pDest->iSDParm, pIn->nSdst);\n      }\n      /* The LIMIT clause will jump out of the loop for us */\n      break;\n    }\n#endif /* #ifndef SQLITE_OMIT_SUBQUERY */\n\n    /* The results are stored in a sequence of registers\n    ** starting at pDest->iSdst.  Then the co-routine yields.\n    */\n    case SRT_Coroutine: {\n      if( pDest->iSdst==0 ){\n        pDest->iSdst = sqlite3GetTempRange(pParse, pIn->nSdst);\n        pDest->nSdst = pIn->nSdst;\n      }\n      sqlite3ExprCodeMove(pParse, pIn->iSdst, pDest->iSdst, pIn->nSdst);\n      sqlite3VdbeAddOp1(v, OP_Yield, pDest->iSDParm);\n      break;\n    }\n\n    /* If none of the above, then the result destination must be\n    ** SRT_Output.  This routine is never called with any other\n    ** destination other than the ones handled above or SRT_Output.\n    **\n    ** For SRT_Output, results are stored in a sequence of registers.  \n    ** Then the OP_ResultRow opcode is used to cause sqlite3_step() to\n    ** return the next row of result.\n    */\n    default: {\n      assert( pDest->eDest==SRT_Output );\n      sqlite3VdbeAddOp2(v, OP_ResultRow, pIn->iSdst, pIn->nSdst);\n      break;\n    }\n  }\n\n  /* Jump to the end of the loop if the LIMIT is reached.\n  */\n  if( p->iLimit ){\n    sqlite3VdbeAddOp2(v, OP_DecrJumpZero, p->iLimit, iBreak); VdbeCoverage(v);\n  }\n\n  /* Generate the subroutine return\n  */\n  sqlite3VdbeResolveLabel(v, iContinue);\n  sqlite3VdbeAddOp1(v, OP_Return, regReturn);\n\n  return addr;\n}\n\n/*\n** Alternative compound select code generator for cases when there\n** is an ORDER BY clause.\n**\n** We assume a query of the following form:\n**\n**      <selectA>  <operator>  <selectB>  ORDER BY <orderbylist>\n**\n** <operator> is one of UNION ALL, UNION, EXCEPT, or INTERSECT.  The idea\n** is to code both <selectA> and <selectB> with the ORDER BY clause as\n** co-routines.  Then run the co-routines in parallel and merge the results\n** into the output.  In addition to the two coroutines (called selectA and\n** selectB) there are 7 subroutines:\n**\n**    outA:    Move the output of the selectA coroutine into the output\n**             of the compound query.\n**\n**    outB:    Move the output of the selectB coroutine into the output\n**             of the compound query.  (Only generated for UNION and\n**             UNION ALL.  EXCEPT and INSERTSECT never output a row that\n**             appears only in B.)\n**\n**    AltB:    Called when there is data from both coroutines and A<B.\n**\n**    AeqB:    Called when there is data from both coroutines and A==B.\n**\n**    AgtB:    Called when there is data from both coroutines and A>B.\n**\n**    EofA:    Called when data is exhausted from selectA.\n**\n**    EofB:    Called when data is exhausted from selectB.\n**\n** The implementation of the latter five subroutines depend on which \n** <operator> is used:\n**\n**\n**             UNION ALL         UNION            EXCEPT          INTERSECT\n**          -------------  -----------------  --------------  -----------------\n**   AltB:   outA, nextA      outA, nextA       outA, nextA         nextA\n**\n**   AeqB:   outA, nextA         nextA             nextA         outA, nextA\n**\n**   AgtB:   outB, nextB      outB, nextB          nextB            nextB\n**\n**   EofA:   outB, nextB      outB, nextB          halt             halt\n**\n**   EofB:   outA, nextA      outA, nextA       outA, nextA         halt\n**\n** In the AltB, AeqB, and AgtB subroutines, an EOF on A following nextA\n** causes an immediate jump to EofA and an EOF on B following nextB causes\n** an immediate jump to EofB.  Within EofA and EofB, and EOF on entry or\n** following nextX causes a jump to the end of the select processing.\n**\n** Duplicate removal in the UNION, EXCEPT, and INTERSECT cases is handled\n** within the output subroutine.  The regPrev register set holds the previously\n** output value.  A comparison is made against this value and the output\n** is skipped if the next results would be the same as the previous.\n**\n** The implementation plan is to implement the two coroutines and seven\n** subroutines first, then put the control logic at the bottom.  Like this:\n**\n**          goto Init\n**     coA: coroutine for left query (A)\n**     coB: coroutine for right query (B)\n**    outA: output one row of A\n**    outB: output one row of B (UNION and UNION ALL only)\n**    EofA: ...\n**    EofB: ...\n**    AltB: ...\n**    AeqB: ...\n**    AgtB: ...\n**    Init: initialize coroutine registers\n**          yield coA\n**          if eof(A) goto EofA\n**          yield coB\n**          if eof(B) goto EofB\n**    Cmpr: Compare A, B\n**          Jump AltB, AeqB, AgtB\n**     End: ...\n**\n** We call AltB, AeqB, AgtB, EofA, and EofB \"subroutines\" but they are not\n** actually called using Gosub and they do not Return.  EofA and EofB loop\n** until all data is exhausted then jump to the \"end\" labe.  AltB, AeqB,\n** and AgtB jump to either L2 or to one of EofA or EofB.\n*/\n#ifndef SQLITE_OMIT_COMPOUND_SELECT\nstatic int multiSelectOrderBy(\n  Parse *pParse,        /* Parsing context */\n  Select *p,            /* The right-most of SELECTs to be coded */\n  SelectDest *pDest     /* What to do with query results */\n){\n  int i, j;             /* Loop counters */\n  Select *pPrior;       /* Another SELECT immediately to our left */\n  Vdbe *v;              /* Generate code to this VDBE */\n  SelectDest destA;     /* Destination for coroutine A */\n  SelectDest destB;     /* Destination for coroutine B */\n  int regAddrA;         /* Address register for select-A coroutine */\n  int regAddrB;         /* Address register for select-B coroutine */\n  int addrSelectA;      /* Address of the select-A coroutine */\n  int addrSelectB;      /* Address of the select-B coroutine */\n  int regOutA;          /* Address register for the output-A subroutine */\n  int regOutB;          /* Address register for the output-B subroutine */\n  int addrOutA;         /* Address of the output-A subroutine */\n  int addrOutB = 0;     /* Address of the output-B subroutine */\n  int addrEofA;         /* Address of the select-A-exhausted subroutine */\n  int addrEofA_noB;     /* Alternate addrEofA if B is uninitialized */\n  int addrEofB;         /* Address of the select-B-exhausted subroutine */\n  int addrAltB;         /* Address of the A<B subroutine */\n  int addrAeqB;         /* Address of the A==B subroutine */\n  int addrAgtB;         /* Address of the A>B subroutine */\n  int regLimitA;        /* Limit register for select-A */\n  int regLimitB;        /* Limit register for select-A */\n  int regPrev;          /* A range of registers to hold previous output */\n  int savedLimit;       /* Saved value of p->iLimit */\n  int savedOffset;      /* Saved value of p->iOffset */\n  int labelCmpr;        /* Label for the start of the merge algorithm */\n  int labelEnd;         /* Label for the end of the overall SELECT stmt */\n  int addr1;            /* Jump instructions that get retargetted */\n  int op;               /* One of TK_ALL, TK_UNION, TK_EXCEPT, TK_INTERSECT */\n  KeyInfo *pKeyDup = 0; /* Comparison information for duplicate removal */\n  KeyInfo *pKeyMerge;   /* Comparison information for merging rows */\n  sqlite3 *db;          /* Database connection */\n  ExprList *pOrderBy;   /* The ORDER BY clause */\n  int nOrderBy;         /* Number of terms in the ORDER BY clause */\n  int *aPermute;        /* Mapping from ORDER BY terms to result set columns */\n\n  assert( p->pOrderBy!=0 );\n  assert( pKeyDup==0 ); /* \"Managed\" code needs this.  Ticket #3382. */\n  db = pParse->db;\n  v = pParse->pVdbe;\n  assert( v!=0 );       /* Already thrown the error if VDBE alloc failed */\n  labelEnd = sqlite3VdbeMakeLabel(pParse);\n  labelCmpr = sqlite3VdbeMakeLabel(pParse);\n\n\n  /* Patch up the ORDER BY clause\n  */\n  op = p->op;  \n  pPrior = p->pPrior;\n  assert( pPrior->pOrderBy==0 );\n  pOrderBy = p->pOrderBy;\n  assert( pOrderBy );\n  nOrderBy = pOrderBy->nExpr;\n\n  /* For operators other than UNION ALL we have to make sure that\n  ** the ORDER BY clause covers every term of the result set.  Add\n  ** terms to the ORDER BY clause as necessary.\n  */\n  if( op!=TK_ALL ){\n    for(i=1; db->mallocFailed==0 && i<=p->pEList->nExpr; i++){\n      struct ExprList_item *pItem;\n      for(j=0, pItem=pOrderBy->a; j<nOrderBy; j++, pItem++){\n        assert( pItem->u.x.iOrderByCol>0 );\n        if( pItem->u.x.iOrderByCol==i ) break;\n      }\n      if( j==nOrderBy ){\n        Expr *pNew = sqlite3Expr(db, TK_INTEGER, 0);\n        if( pNew==0 ) return SQLITE_NOMEM_BKPT;\n        pNew->flags |= EP_IntValue;\n        pNew->u.iValue = i;\n        p->pOrderBy = pOrderBy = sqlite3ExprListAppend(pParse, pOrderBy, pNew);\n        if( pOrderBy ) pOrderBy->a[nOrderBy++].u.x.iOrderByCol = (u16)i;\n      }\n    }\n  }\n\n  /* Compute the comparison permutation and keyinfo that is used with\n  ** the permutation used to determine if the next\n  ** row of results comes from selectA or selectB.  Also add explicit\n  ** collations to the ORDER BY clause terms so that when the subqueries\n  ** to the right and the left are evaluated, they use the correct\n  ** collation.\n  */\n  aPermute = sqlite3DbMallocRawNN(db, sizeof(int)*(nOrderBy + 1));\n  if( aPermute ){\n    struct ExprList_item *pItem;\n    aPermute[0] = nOrderBy;\n    for(i=1, pItem=pOrderBy->a; i<=nOrderBy; i++, pItem++){\n      assert( pItem->u.x.iOrderByCol>0 );\n      assert( pItem->u.x.iOrderByCol<=p->pEList->nExpr );\n      aPermute[i] = pItem->u.x.iOrderByCol - 1;\n    }\n    pKeyMerge = multiSelectOrderByKeyInfo(pParse, p, 1);\n  }else{\n    pKeyMerge = 0;\n  }\n\n  /* Reattach the ORDER BY clause to the query.\n  */\n  p->pOrderBy = pOrderBy;\n  pPrior->pOrderBy = sqlite3ExprListDup(pParse->db, pOrderBy, 0);\n\n  /* Allocate a range of temporary registers and the KeyInfo needed\n  ** for the logic that removes duplicate result rows when the\n  ** operator is UNION, EXCEPT, or INTERSECT (but not UNION ALL).\n  */\n  if( op==TK_ALL ){\n    regPrev = 0;\n  }else{\n    int nExpr = p->pEList->nExpr;\n    assert( nOrderBy>=nExpr || db->mallocFailed );\n    regPrev = pParse->nMem+1;\n    pParse->nMem += nExpr+1;\n    sqlite3VdbeAddOp2(v, OP_Integer, 0, regPrev);\n    pKeyDup = sqlite3KeyInfoAlloc(db, nExpr, 1);\n    if( pKeyDup ){\n      assert( sqlite3KeyInfoIsWriteable(pKeyDup) );\n      for(i=0; i<nExpr; i++){\n        pKeyDup->aColl[i] = multiSelectCollSeq(pParse, p, i);\n        pKeyDup->aSortFlags[i] = 0;\n      }\n    }\n  }\n \n  /* Separate the left and the right query from one another\n  */\n  p->pPrior = 0;\n  pPrior->pNext = 0;\n  sqlite3ResolveOrderGroupBy(pParse, p, p->pOrderBy, \"ORDER\");\n  if( pPrior->pPrior==0 ){\n    sqlite3ResolveOrderGroupBy(pParse, pPrior, pPrior->pOrderBy, \"ORDER\");\n  }\n\n  /* Compute the limit registers */\n  computeLimitRegisters(pParse, p, labelEnd);\n  if( p->iLimit && op==TK_ALL ){\n    regLimitA = ++pParse->nMem;\n    regLimitB = ++pParse->nMem;\n    sqlite3VdbeAddOp2(v, OP_Copy, p->iOffset ? p->iOffset+1 : p->iLimit,\n                                  regLimitA);\n    sqlite3VdbeAddOp2(v, OP_Copy, regLimitA, regLimitB);\n  }else{\n    regLimitA = regLimitB = 0;\n  }\n  sqlite3ExprDelete(db, p->pLimit);\n  p->pLimit = 0;\n\n  regAddrA = ++pParse->nMem;\n  regAddrB = ++pParse->nMem;\n  regOutA = ++pParse->nMem;\n  regOutB = ++pParse->nMem;\n  sqlite3SelectDestInit(&destA, SRT_Coroutine, regAddrA);\n  sqlite3SelectDestInit(&destB, SRT_Coroutine, regAddrB);\n\n  ExplainQueryPlan((pParse, 1, \"MERGE (%s)\", selectOpName(p->op)));\n\n  /* Generate a coroutine to evaluate the SELECT statement to the\n  ** left of the compound operator - the \"A\" select.\n  */\n  addrSelectA = sqlite3VdbeCurrentAddr(v) + 1;\n  addr1 = sqlite3VdbeAddOp3(v, OP_InitCoroutine, regAddrA, 0, addrSelectA);\n  VdbeComment((v, \"left SELECT\"));\n  pPrior->iLimit = regLimitA;\n  ExplainQueryPlan((pParse, 1, \"LEFT\"));\n  sqlite3Select(pParse, pPrior, &destA);\n  sqlite3VdbeEndCoroutine(v, regAddrA);\n  sqlite3VdbeJumpHere(v, addr1);\n\n  /* Generate a coroutine to evaluate the SELECT statement on \n  ** the right - the \"B\" select\n  */\n  addrSelectB = sqlite3VdbeCurrentAddr(v) + 1;\n  addr1 = sqlite3VdbeAddOp3(v, OP_InitCoroutine, regAddrB, 0, addrSelectB);\n  VdbeComment((v, \"right SELECT\"));\n  savedLimit = p->iLimit;\n  savedOffset = p->iOffset;\n  p->iLimit = regLimitB;\n  p->iOffset = 0;  \n  ExplainQueryPlan((pParse, 1, \"RIGHT\"));\n  sqlite3Select(pParse, p, &destB);\n  p->iLimit = savedLimit;\n  p->iOffset = savedOffset;\n  sqlite3VdbeEndCoroutine(v, regAddrB);\n\n  /* Generate a subroutine that outputs the current row of the A\n  ** select as the next output row of the compound select.\n  */\n  VdbeNoopComment((v, \"Output routine for A\"));\n  addrOutA = generateOutputSubroutine(pParse,\n                 p, &destA, pDest, regOutA,\n                 regPrev, pKeyDup, labelEnd);\n  \n  /* Generate a subroutine that outputs the current row of the B\n  ** select as the next output row of the compound select.\n  */\n  if( op==TK_ALL || op==TK_UNION ){\n    VdbeNoopComment((v, \"Output routine for B\"));\n    addrOutB = generateOutputSubroutine(pParse,\n                 p, &destB, pDest, regOutB,\n                 regPrev, pKeyDup, labelEnd);\n  }\n  sqlite3KeyInfoUnref(pKeyDup);\n\n  /* Generate a subroutine to run when the results from select A\n  ** are exhausted and only data in select B remains.\n  */\n  if( op==TK_EXCEPT || op==TK_INTERSECT ){\n    addrEofA_noB = addrEofA = labelEnd;\n  }else{  \n    VdbeNoopComment((v, \"eof-A subroutine\"));\n    addrEofA = sqlite3VdbeAddOp2(v, OP_Gosub, regOutB, addrOutB);\n    addrEofA_noB = sqlite3VdbeAddOp2(v, OP_Yield, regAddrB, labelEnd);\n                                     VdbeCoverage(v);\n    sqlite3VdbeGoto(v, addrEofA);\n    p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);\n  }\n\n  /* Generate a subroutine to run when the results from select B\n  ** are exhausted and only data in select A remains.\n  */\n  if( op==TK_INTERSECT ){\n    addrEofB = addrEofA;\n    if( p->nSelectRow > pPrior->nSelectRow ) p->nSelectRow = pPrior->nSelectRow;\n  }else{  \n    VdbeNoopComment((v, \"eof-B subroutine\"));\n    addrEofB = sqlite3VdbeAddOp2(v, OP_Gosub, regOutA, addrOutA);\n    sqlite3VdbeAddOp2(v, OP_Yield, regAddrA, labelEnd); VdbeCoverage(v);\n    sqlite3VdbeGoto(v, addrEofB);\n  }\n\n  /* Generate code to handle the case of A<B\n  */\n  VdbeNoopComment((v, \"A-lt-B subroutine\"));\n  addrAltB = sqlite3VdbeAddOp2(v, OP_Gosub, regOutA, addrOutA);\n  sqlite3VdbeAddOp2(v, OP_Yield, regAddrA, addrEofA); VdbeCoverage(v);\n  sqlite3VdbeGoto(v, labelCmpr);\n\n  /* Generate code to handle the case of A==B\n  */\n  if( op==TK_ALL ){\n    addrAeqB = addrAltB;\n  }else if( op==TK_INTERSECT ){\n    addrAeqB = addrAltB;\n    addrAltB++;\n  }else{\n    VdbeNoopComment((v, \"A-eq-B subroutine\"));\n    addrAeqB =\n    sqlite3VdbeAddOp2(v, OP_Yield, regAddrA, addrEofA); VdbeCoverage(v);\n    sqlite3VdbeGoto(v, labelCmpr);\n  }\n\n  /* Generate code to handle the case of A>B\n  */\n  VdbeNoopComment((v, \"A-gt-B subroutine\"));\n  addrAgtB = sqlite3VdbeCurrentAddr(v);\n  if( op==TK_ALL || op==TK_UNION ){\n    sqlite3VdbeAddOp2(v, OP_Gosub, regOutB, addrOutB);\n  }\n  sqlite3VdbeAddOp2(v, OP_Yield, regAddrB, addrEofB); VdbeCoverage(v);\n  sqlite3VdbeGoto(v, labelCmpr);\n\n  /* This code runs once to initialize everything.\n  */\n  sqlite3VdbeJumpHere(v, addr1);\n  sqlite3VdbeAddOp2(v, OP_Yield, regAddrA, addrEofA_noB); VdbeCoverage(v);\n  sqlite3VdbeAddOp2(v, OP_Yield, regAddrB, addrEofB); VdbeCoverage(v);\n\n  /* Implement the main merge loop\n  */\n  sqlite3VdbeResolveLabel(v, labelCmpr);\n  sqlite3VdbeAddOp4(v, OP_Permutation, 0, 0, 0, (char*)aPermute, P4_INTARRAY);\n  sqlite3VdbeAddOp4(v, OP_Compare, destA.iSdst, destB.iSdst, nOrderBy,\n                         (char*)pKeyMerge, P4_KEYINFO);\n  sqlite3VdbeChangeP5(v, OPFLAG_PERMUTE);\n  sqlite3VdbeAddOp3(v, OP_Jump, addrAltB, addrAeqB, addrAgtB); VdbeCoverage(v);\n\n  /* Jump to the this point in order to terminate the query.\n  */\n  sqlite3VdbeResolveLabel(v, labelEnd);\n\n  /* Reassembly the compound query so that it will be freed correctly\n  ** by the calling function */\n  if( p->pPrior ){\n    sqlite3SelectDelete(db, p->pPrior);\n  }\n  p->pPrior = pPrior;\n  pPrior->pNext = p;\n\n  /*** TBD:  Insert subroutine calls to close cursors on incomplete\n  **** subqueries ****/\n  ExplainQueryPlanPop(pParse);\n  return pParse->nErr!=0;\n}\n#endif\n\n#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)\n\n/* An instance of the SubstContext object describes an substitution edit\n** to be performed on a parse tree.\n**\n** All references to columns in table iTable are to be replaced by corresponding\n** expressions in pEList.\n*/\ntypedef struct SubstContext {\n  Parse *pParse;            /* The parsing context */\n  int iTable;               /* Replace references to this table */\n  int iNewTable;            /* New table number */\n  int isLeftJoin;           /* Add TK_IF_NULL_ROW opcodes on each replacement */\n  ExprList *pEList;         /* Replacement expressions */\n} SubstContext;\n\n/* Forward Declarations */\nstatic void substExprList(SubstContext*, ExprList*);\nstatic void substSelect(SubstContext*, Select*, int);\n\n/*\n** Scan through the expression pExpr.  Replace every reference to\n** a column in table number iTable with a copy of the iColumn-th\n** entry in pEList.  (But leave references to the ROWID column \n** unchanged.)\n**\n** This routine is part of the flattening procedure.  A subquery\n** whose result set is defined by pEList appears as entry in the\n** FROM clause of a SELECT such that the VDBE cursor assigned to that\n** FORM clause entry is iTable.  This routine makes the necessary \n** changes to pExpr so that it refers directly to the source table\n** of the subquery rather the result set of the subquery.\n*/\nstatic Expr *substExpr(\n  SubstContext *pSubst,  /* Description of the substitution */\n  Expr *pExpr            /* Expr in which substitution occurs */\n){\n  if( pExpr==0 ) return 0;\n  if( ExprHasProperty(pExpr, EP_FromJoin)\n   && pExpr->iRightJoinTable==pSubst->iTable\n  ){\n    pExpr->iRightJoinTable = pSubst->iNewTable;\n  }\n  if( pExpr->op==TK_COLUMN && pExpr->iTable==pSubst->iTable ){\n    if( pExpr->iColumn<0 ){\n      pExpr->op = TK_NULL;\n    }else{\n      Expr *pNew;\n      Expr *pCopy = pSubst->pEList->a[pExpr->iColumn].pExpr;\n      Expr ifNullRow;\n      assert( pSubst->pEList!=0 && pExpr->iColumn<pSubst->pEList->nExpr );\n      assert( pExpr->pRight==0 );\n      if( sqlite3ExprIsVector(pCopy) ){\n        sqlite3VectorErrorMsg(pSubst->pParse, pCopy);\n      }else{\n        sqlite3 *db = pSubst->pParse->db;\n        if( pSubst->isLeftJoin && pCopy->op!=TK_COLUMN ){\n          memset(&ifNullRow, 0, sizeof(ifNullRow));\n          ifNullRow.op = TK_IF_NULL_ROW;\n          ifNullRow.pLeft = pCopy;\n          ifNullRow.iTable = pSubst->iNewTable;\n          pCopy = &ifNullRow;\n        }\n        testcase( ExprHasProperty(pCopy, EP_Subquery) );\n        pNew = sqlite3ExprDup(db, pCopy, 0);\n        if( pNew && pSubst->isLeftJoin ){\n          ExprSetProperty(pNew, EP_CanBeNull);\n        }\n        if( pNew && ExprHasProperty(pExpr,EP_FromJoin) ){\n          pNew->iRightJoinTable = pExpr->iRightJoinTable;\n          ExprSetProperty(pNew, EP_FromJoin);\n        }\n        sqlite3ExprDelete(db, pExpr);\n        pExpr = pNew;\n\n        /* Ensure that the expression now has an implicit collation sequence,\n        ** just as it did when it was a column of a view or sub-query. */\n        if( pExpr ){\n          if( pExpr->op!=TK_COLUMN && pExpr->op!=TK_COLLATE ){\n            CollSeq *pColl = sqlite3ExprCollSeq(pSubst->pParse, pExpr);\n            pExpr = sqlite3ExprAddCollateString(pSubst->pParse, pExpr, \n                (pColl ? pColl->zName : \"BINARY\")\n            );\n          }\n          ExprClearProperty(pExpr, EP_Collate);\n        }\n      }\n    }\n  }else{\n    if( pExpr->op==TK_IF_NULL_ROW && pExpr->iTable==pSubst->iTable ){\n      pExpr->iTable = pSubst->iNewTable;\n    }\n    pExpr->pLeft = substExpr(pSubst, pExpr->pLeft);\n    pExpr->pRight = substExpr(pSubst, pExpr->pRight);\n    if( ExprHasProperty(pExpr, EP_xIsSelect) ){\n      substSelect(pSubst, pExpr->x.pSelect, 1);\n    }else{\n      substExprList(pSubst, pExpr->x.pList);\n    }\n#ifndef SQLITE_OMIT_WINDOWFUNC\n    if( ExprHasProperty(pExpr, EP_WinFunc) ){\n      Window *pWin = pExpr->y.pWin;\n      pWin->pFilter = substExpr(pSubst, pWin->pFilter);\n      substExprList(pSubst, pWin->pPartition);\n      substExprList(pSubst, pWin->pOrderBy);\n    }\n#endif\n  }\n  return pExpr;\n}\nstatic void substExprList(\n  SubstContext *pSubst, /* Description of the substitution */\n  ExprList *pList       /* List to scan and in which to make substitutes */\n){\n  int i;\n  if( pList==0 ) return;\n  for(i=0; i<pList->nExpr; i++){\n    pList->a[i].pExpr = substExpr(pSubst, pList->a[i].pExpr);\n  }\n}\nstatic void substSelect(\n  SubstContext *pSubst, /* Description of the substitution */\n  Select *p,            /* SELECT statement in which to make substitutions */\n  int doPrior           /* Do substitutes on p->pPrior too */\n){\n  SrcList *pSrc;\n  struct SrcList_item *pItem;\n  int i;\n  if( !p ) return;\n  do{\n    substExprList(pSubst, p->pEList);\n    substExprList(pSubst, p->pGroupBy);\n    substExprList(pSubst, p->pOrderBy);\n    p->pHaving = substExpr(pSubst, p->pHaving);\n    p->pWhere = substExpr(pSubst, p->pWhere);\n    pSrc = p->pSrc;\n    assert( pSrc!=0 );\n    for(i=pSrc->nSrc, pItem=pSrc->a; i>0; i--, pItem++){\n      substSelect(pSubst, pItem->pSelect, 1);\n      if( pItem->fg.isTabFunc ){\n        substExprList(pSubst, pItem->u1.pFuncArg);\n      }\n    }\n  }while( doPrior && (p = p->pPrior)!=0 );\n}\n#endif /* !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW) */\n\n#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)\n/*\n** This routine attempts to flatten subqueries as a performance optimization.\n** This routine returns 1 if it makes changes and 0 if no flattening occurs.\n**\n** To understand the concept of flattening, consider the following\n** query:\n**\n**     SELECT a FROM (SELECT x+y AS a FROM t1 WHERE z<100) WHERE a>5\n**\n** The default way of implementing this query is to execute the\n** subquery first and store the results in a temporary table, then\n** run the outer query on that temporary table.  This requires two\n** passes over the data.  Furthermore, because the temporary table\n** has no indices, the WHERE clause on the outer query cannot be\n** optimized.\n**\n** This routine attempts to rewrite queries such as the above into\n** a single flat select, like this:\n**\n**     SELECT x+y AS a FROM t1 WHERE z<100 AND a>5\n**\n** The code generated for this simplification gives the same result\n** but only has to scan the data once.  And because indices might \n** exist on the table t1, a complete scan of the data might be\n** avoided.\n**\n** Flattening is subject to the following constraints:\n**\n**  (**)  We no longer attempt to flatten aggregate subqueries. Was:\n**        The subquery and the outer query cannot both be aggregates.\n**\n**  (**)  We no longer attempt to flatten aggregate subqueries. Was:\n**        (2) If the subquery is an aggregate then\n**        (2a) the outer query must not be a join and\n**        (2b) the outer query must not use subqueries\n**             other than the one FROM-clause subquery that is a candidate\n**             for flattening.  (This is due to ticket [2f7170d73bf9abf80]\n**             from 2015-02-09.)\n**\n**   (3)  If the subquery is the right operand of a LEFT JOIN then\n**        (3a) the subquery may not be a join and\n**        (3b) the FROM clause of the subquery may not contain a virtual\n**             table and\n**        (3c) the outer query may not be an aggregate.\n**        (3d) the outer query may not be DISTINCT.\n**\n**   (4)  The subquery can not be DISTINCT.\n**\n**  (**)  At one point restrictions (4) and (5) defined a subset of DISTINCT\n**        sub-queries that were excluded from this optimization. Restriction \n**        (4) has since been expanded to exclude all DISTINCT subqueries.\n**\n**  (**)  We no longer attempt to flatten aggregate subqueries.  Was:\n**        If the subquery is aggregate, the outer query may not be DISTINCT.\n**\n**   (7)  The subquery must have a FROM clause.  TODO:  For subqueries without\n**        A FROM clause, consider adding a FROM clause with the special\n**        table sqlite_once that consists of a single row containing a\n**        single NULL.\n**\n**   (8)  If the subquery uses LIMIT then the outer query may not be a join.\n**\n**   (9)  If the subquery uses LIMIT then the outer query may not be aggregate.\n**\n**  (**)  Restriction (10) was removed from the code on 2005-02-05 but we\n**        accidently carried the comment forward until 2014-09-15.  Original\n**        constraint: \"If the subquery is aggregate then the outer query \n**        may not use LIMIT.\"\n**\n**  (11)  The subquery and the outer query may not both have ORDER BY clauses.\n**\n**  (**)  Not implemented.  Subsumed into restriction (3).  Was previously\n**        a separate restriction deriving from ticket #350.\n**\n**  (13)  The subquery and outer query may not both use LIMIT.\n**\n**  (14)  The subquery may not use OFFSET.\n**\n**  (15)  If the outer query is part of a compound select, then the\n**        subquery may not use LIMIT.\n**        (See ticket #2339 and ticket [02a8e81d44]).\n**\n**  (16)  If the outer query is aggregate, then the subquery may not\n**        use ORDER BY.  (Ticket #2942)  This used to not matter\n**        until we introduced the group_concat() function.  \n**\n**  (17)  If the subquery is a compound select, then\n**        (17a) all compound operators must be a UNION ALL, and\n**        (17b) no terms within the subquery compound may be aggregate\n**              or DISTINCT, and\n**        (17c) every term within the subquery compound must have a FROM clause\n**        (17d) the outer query may not be\n**              (17d1) aggregate, or\n**              (17d2) DISTINCT, or\n**              (17d3) a join.\n**\n**        The parent and sub-query may contain WHERE clauses. Subject to\n**        rules (11), (13) and (14), they may also contain ORDER BY,\n**        LIMIT and OFFSET clauses.  The subquery cannot use any compound\n**        operator other than UNION ALL because all the other compound\n**        operators have an implied DISTINCT which is disallowed by\n**        restriction (4).\n**\n**        Also, each component of the sub-query must return the same number\n**        of result columns. This is actually a requirement for any compound\n**        SELECT statement, but all the code here does is make sure that no\n**        such (illegal) sub-query is flattened. The caller will detect the\n**        syntax error and return a detailed message.\n**\n**  (18)  If the sub-query is a compound select, then all terms of the\n**        ORDER BY clause of the parent must be simple references to \n**        columns of the sub-query.\n**\n**  (19)  If the subquery uses LIMIT then the outer query may not\n**        have a WHERE clause.\n**\n**  (20)  If the sub-query is a compound select, then it must not use\n**        an ORDER BY clause.  Ticket #3773.  We could relax this constraint\n**        somewhat by saying that the terms of the ORDER BY clause must\n**        appear as unmodified result columns in the outer query.  But we\n**        have other optimizations in mind to deal with that case.\n**\n**  (21)  If the subquery uses LIMIT then the outer query may not be\n**        DISTINCT.  (See ticket [752e1646fc]).\n**\n**  (22)  The subquery may not be a recursive CTE.\n**\n**  (**)  Subsumed into restriction (17d3).  Was: If the outer query is\n**        a recursive CTE, then the sub-query may not be a compound query.\n**        This restriction is because transforming the\n**        parent to a compound query confuses the code that handles\n**        recursive queries in multiSelect().\n**\n**  (**)  We no longer attempt to flatten aggregate subqueries.  Was:\n**        The subquery may not be an aggregate that uses the built-in min() or \n**        or max() functions.  (Without this restriction, a query like:\n**        \"SELECT x FROM (SELECT max(y), x FROM t1)\" would not necessarily\n**        return the value X for which Y was maximal.)\n**\n**  (25)  If either the subquery or the parent query contains a window\n**        function in the select list or ORDER BY clause, flattening\n**        is not attempted.\n**\n**\n** In this routine, the \"p\" parameter is a pointer to the outer query.\n** The subquery is p->pSrc->a[iFrom].  isAgg is true if the outer query\n** uses aggregates.\n**\n** If flattening is not attempted, this routine is a no-op and returns 0.\n** If flattening is attempted this routine returns 1.\n**\n** All of the expression analysis must occur on both the outer query and\n** the subquery before this routine runs.\n*/\nstatic int flattenSubquery(\n  Parse *pParse,       /* Parsing context */\n  Select *p,           /* The parent or outer SELECT statement */\n  int iFrom,           /* Index in p->pSrc->a[] of the inner subquery */\n  int isAgg            /* True if outer SELECT uses aggregate functions */\n){\n  const char *zSavedAuthContext = pParse->zAuthContext;\n  Select *pParent;    /* Current UNION ALL term of the other query */\n  Select *pSub;       /* The inner query or \"subquery\" */\n  Select *pSub1;      /* Pointer to the rightmost select in sub-query */\n  SrcList *pSrc;      /* The FROM clause of the outer query */\n  SrcList *pSubSrc;   /* The FROM clause of the subquery */\n  int iParent;        /* VDBE cursor number of the pSub result set temp table */\n  int iNewParent = -1;/* Replacement table for iParent */\n  int isLeftJoin = 0; /* True if pSub is the right side of a LEFT JOIN */    \n  int i;              /* Loop counter */\n  Expr *pWhere;                    /* The WHERE clause */\n  struct SrcList_item *pSubitem;   /* The subquery */\n  sqlite3 *db = pParse->db;\n\n  /* Check to see if flattening is permitted.  Return 0 if not.\n  */\n  assert( p!=0 );\n  assert( p->pPrior==0 );\n  if( OptimizationDisabled(db, SQLITE_QueryFlattener) ) return 0;\n  pSrc = p->pSrc;\n  assert( pSrc && iFrom>=0 && iFrom<pSrc->nSrc );\n  pSubitem = &pSrc->a[iFrom];\n  iParent = pSubitem->iCursor;\n  pSub = pSubitem->pSelect;\n  assert( pSub!=0 );\n\n#ifndef SQLITE_OMIT_WINDOWFUNC\n  if( p->pWin || pSub->pWin ) return 0;                  /* Restriction (25) */\n#endif\n\n  pSubSrc = pSub->pSrc;\n  assert( pSubSrc );\n  /* Prior to version 3.1.2, when LIMIT and OFFSET had to be simple constants,\n  ** not arbitrary expressions, we allowed some combining of LIMIT and OFFSET\n  ** because they could be computed at compile-time.  But when LIMIT and OFFSET\n  ** became arbitrary expressions, we were forced to add restrictions (13)\n  ** and (14). */\n  if( pSub->pLimit && p->pLimit ) return 0;              /* Restriction (13) */\n  if( pSub->pLimit && pSub->pLimit->pRight ) return 0;   /* Restriction (14) */\n  if( (p->selFlags & SF_Compound)!=0 && pSub->pLimit ){\n    return 0;                                            /* Restriction (15) */\n  }\n  if( pSubSrc->nSrc==0 ) return 0;                       /* Restriction (7)  */\n  if( pSub->selFlags & SF_Distinct ) return 0;           /* Restriction (4)  */\n  if( pSub->pLimit && (pSrc->nSrc>1 || isAgg) ){\n     return 0;         /* Restrictions (8)(9) */\n  }\n  if( p->pOrderBy && pSub->pOrderBy ){\n     return 0;                                           /* Restriction (11) */\n  }\n  if( isAgg && pSub->pOrderBy ) return 0;                /* Restriction (16) */\n  if( pSub->pLimit && p->pWhere ) return 0;              /* Restriction (19) */\n  if( pSub->pLimit && (p->selFlags & SF_Distinct)!=0 ){\n     return 0;         /* Restriction (21) */\n  }\n  if( pSub->selFlags & (SF_Recursive) ){\n    return 0; /* Restrictions (22) */\n  }\n\n  /*\n  ** If the subquery is the right operand of a LEFT JOIN, then the\n  ** subquery may not be a join itself (3a). Example of why this is not\n  ** allowed:\n  **\n  **         t1 LEFT OUTER JOIN (t2 JOIN t3)\n  **\n  ** If we flatten the above, we would get\n  **\n  **         (t1 LEFT OUTER JOIN t2) JOIN t3\n  **\n  ** which is not at all the same thing.\n  **\n  ** If the subquery is the right operand of a LEFT JOIN, then the outer\n  ** query cannot be an aggregate. (3c)  This is an artifact of the way\n  ** aggregates are processed - there is no mechanism to determine if\n  ** the LEFT JOIN table should be all-NULL.\n  **\n  ** See also tickets #306, #350, and #3300.\n  */\n  if( (pSubitem->fg.jointype & JT_OUTER)!=0 ){\n    isLeftJoin = 1;\n    if( pSubSrc->nSrc>1                   /* (3a) */\n     || isAgg                             /* (3b) */\n     || IsVirtual(pSubSrc->a[0].pTab)     /* (3c) */\n     || (p->selFlags & SF_Distinct)!=0    /* (3d) */\n    ){\n      return 0;\n    }\n  }\n#ifdef SQLITE_EXTRA_IFNULLROW\n  else if( iFrom>0 && !isAgg ){\n    /* Setting isLeftJoin to -1 causes OP_IfNullRow opcodes to be generated for\n    ** every reference to any result column from subquery in a join, even\n    ** though they are not necessary.  This will stress-test the OP_IfNullRow \n    ** opcode. */\n    isLeftJoin = -1;\n  }\n#endif\n\n  /* Restriction (17): If the sub-query is a compound SELECT, then it must\n  ** use only the UNION ALL operator. And none of the simple select queries\n  ** that make up the compound SELECT are allowed to be aggregate or distinct\n  ** queries.\n  */\n  if( pSub->pPrior ){\n    if( pSub->pOrderBy ){\n      return 0;  /* Restriction (20) */\n    }\n    if( isAgg || (p->selFlags & SF_Distinct)!=0 || pSrc->nSrc!=1 ){\n      return 0; /* (17d1), (17d2), or (17d3) */\n    }\n    for(pSub1=pSub; pSub1; pSub1=pSub1->pPrior){\n      testcase( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))==SF_Distinct );\n      testcase( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))==SF_Aggregate );\n      assert( pSub->pSrc!=0 );\n      assert( pSub->pEList->nExpr==pSub1->pEList->nExpr );\n      if( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))!=0    /* (17b) */\n       || (pSub1->pPrior && pSub1->op!=TK_ALL)                 /* (17a) */\n       || pSub1->pSrc->nSrc<1                                  /* (17c) */\n      ){\n        return 0;\n      }\n      testcase( pSub1->pSrc->nSrc>1 );\n    }\n\n    /* Restriction (18). */\n    if( p->pOrderBy ){\n      int ii;\n      for(ii=0; ii<p->pOrderBy->nExpr; ii++){\n        if( p->pOrderBy->a[ii].u.x.iOrderByCol==0 ) return 0;\n      }\n    }\n  }\n\n  /* Ex-restriction (23):\n  ** The only way that the recursive part of a CTE can contain a compound\n  ** subquery is for the subquery to be one term of a join.  But if the\n  ** subquery is a join, then the flattening has already been stopped by\n  ** restriction (17d3)\n  */\n  assert( (p->selFlags & SF_Recursive)==0 || pSub->pPrior==0 );\n\n  /***** If we reach this point, flattening is permitted. *****/\n  SELECTTRACE(1,pParse,p,(\"flatten %u.%p from term %d\\n\",\n                   pSub->selId, pSub, iFrom));\n\n  /* Authorize the subquery */\n  pParse->zAuthContext = pSubitem->zName;\n  TESTONLY(i =) sqlite3AuthCheck(pParse, SQLITE_SELECT, 0, 0, 0);\n  testcase( i==SQLITE_DENY );\n  pParse->zAuthContext = zSavedAuthContext;\n\n  /* If the sub-query is a compound SELECT statement, then (by restrictions\n  ** 17 and 18 above) it must be a UNION ALL and the parent query must \n  ** be of the form:\n  **\n  **     SELECT <expr-list> FROM (<sub-query>) <where-clause> \n  **\n  ** followed by any ORDER BY, LIMIT and/or OFFSET clauses. This block\n  ** creates N-1 copies of the parent query without any ORDER BY, LIMIT or \n  ** OFFSET clauses and joins them to the left-hand-side of the original\n  ** using UNION ALL operators. In this case N is the number of simple\n  ** select statements in the compound sub-query.\n  **\n  ** Example:\n  **\n  **     SELECT a+1 FROM (\n  **        SELECT x FROM tab\n  **        UNION ALL\n  **        SELECT y FROM tab\n  **        UNION ALL\n  **        SELECT abs(z*2) FROM tab2\n  **     ) WHERE a!=5 ORDER BY 1\n  **\n  ** Transformed into:\n  **\n  **     SELECT x+1 FROM tab WHERE x+1!=5\n  **     UNION ALL\n  **     SELECT y+1 FROM tab WHERE y+1!=5\n  **     UNION ALL\n  **     SELECT abs(z*2)+1 FROM tab2 WHERE abs(z*2)+1!=5\n  **     ORDER BY 1\n  **\n  ** We call this the \"compound-subquery flattening\".\n  */\n  for(pSub=pSub->pPrior; pSub; pSub=pSub->pPrior){\n    Select *pNew;\n    ExprList *pOrderBy = p->pOrderBy;\n    Expr *pLimit = p->pLimit;\n    Select *pPrior = p->pPrior;\n    p->pOrderBy = 0;\n    p->pSrc = 0;\n    p->pPrior = 0;\n    p->pLimit = 0;\n    pNew = sqlite3SelectDup(db, p, 0);\n    p->pLimit = pLimit;\n    p->pOrderBy = pOrderBy;\n    p->pSrc = pSrc;\n    p->op = TK_ALL;\n    if( pNew==0 ){\n      p->pPrior = pPrior;\n    }else{\n      pNew->pPrior = pPrior;\n      if( pPrior ) pPrior->pNext = pNew;\n      pNew->pNext = p;\n      p->pPrior = pNew;\n      SELECTTRACE(2,pParse,p,(\"compound-subquery flattener\"\n                              \" creates %u as peer\\n\",pNew->selId));\n    }\n    if( db->mallocFailed ) return 1;\n  }\n\n  /* Begin flattening the iFrom-th entry of the FROM clause \n  ** in the outer query.\n  */\n  pSub = pSub1 = pSubitem->pSelect;\n\n  /* Delete the transient table structure associated with the\n  ** subquery\n  */\n  sqlite3DbFree(db, pSubitem->zDatabase);\n  sqlite3DbFree(db, pSubitem->zName);\n  sqlite3DbFree(db, pSubitem->zAlias);\n  pSubitem->zDatabase = 0;\n  pSubitem->zName = 0;\n  pSubitem->zAlias = 0;\n  pSubitem->pSelect = 0;\n\n  /* Defer deleting the Table object associated with the\n  ** subquery until code generation is\n  ** complete, since there may still exist Expr.pTab entries that\n  ** refer to the subquery even after flattening.  Ticket #3346.\n  **\n  ** pSubitem->pTab is always non-NULL by test restrictions and tests above.\n  */\n  if( ALWAYS(pSubitem->pTab!=0) ){\n    Table *pTabToDel = pSubitem->pTab;\n    if( pTabToDel->nTabRef==1 ){\n      Parse *pToplevel = sqlite3ParseToplevel(pParse);\n      pTabToDel->pNextZombie = pToplevel->pZombieTab;\n      pToplevel->pZombieTab = pTabToDel;\n    }else{\n      pTabToDel->nTabRef--;\n    }\n    pSubitem->pTab = 0;\n  }\n\n  /* The following loop runs once for each term in a compound-subquery\n  ** flattening (as described above).  If we are doing a different kind\n  ** of flattening - a flattening other than a compound-subquery flattening -\n  ** then this loop only runs once.\n  **\n  ** This loop moves all of the FROM elements of the subquery into the\n  ** the FROM clause of the outer query.  Before doing this, remember\n  ** the cursor number for the original outer query FROM element in\n  ** iParent.  The iParent cursor will never be used.  Subsequent code\n  ** will scan expressions looking for iParent references and replace\n  ** those references with expressions that resolve to the subquery FROM\n  ** elements we are now copying in.\n  */\n  for(pParent=p; pParent; pParent=pParent->pPrior, pSub=pSub->pPrior){\n    int nSubSrc;\n    u8 jointype = 0;\n    assert( pSub!=0 );\n    pSubSrc = pSub->pSrc;     /* FROM clause of subquery */\n    nSubSrc = pSubSrc->nSrc;  /* Number of terms in subquery FROM clause */\n    pSrc = pParent->pSrc;     /* FROM clause of the outer query */\n\n    if( pSrc ){\n      assert( pParent==p );  /* First time through the loop */\n      jointype = pSubitem->fg.jointype;\n    }else{\n      assert( pParent!=p );  /* 2nd and subsequent times through the loop */\n      pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);\n      if( pSrc==0 ) break;\n      pParent->pSrc = pSrc;\n    }\n\n    /* The subquery uses a single slot of the FROM clause of the outer\n    ** query.  If the subquery has more than one element in its FROM clause,\n    ** then expand the outer query to make space for it to hold all elements\n    ** of the subquery.\n    **\n    ** Example:\n    **\n    **    SELECT * FROM tabA, (SELECT * FROM sub1, sub2), tabB;\n    **\n    ** The outer query has 3 slots in its FROM clause.  One slot of the\n    ** outer query (the middle slot) is used by the subquery.  The next\n    ** block of code will expand the outer query FROM clause to 4 slots.\n    ** The middle slot is expanded to two slots in order to make space\n    ** for the two elements in the FROM clause of the subquery.\n    */\n    if( nSubSrc>1 ){\n      pSrc = sqlite3SrcListEnlarge(pParse, pSrc, nSubSrc-1,iFrom+1);\n      if( pSrc==0 ) break;\n      pParent->pSrc = pSrc;\n    }\n\n    /* Transfer the FROM clause terms from the subquery into the\n    ** outer query.\n    */\n    for(i=0; i<nSubSrc; i++){\n      sqlite3IdListDelete(db, pSrc->a[i+iFrom].pUsing);\n      assert( pSrc->a[i+iFrom].fg.isTabFunc==0 );\n      pSrc->a[i+iFrom] = pSubSrc->a[i];\n      iNewParent = pSubSrc->a[i].iCursor;\n      memset(&pSubSrc->a[i], 0, sizeof(pSubSrc->a[i]));\n    }\n    pSrc->a[iFrom].fg.jointype = jointype;\n  \n    /* Now begin substituting subquery result set expressions for \n    ** references to the iParent in the outer query.\n    ** \n    ** Example:\n    **\n    **   SELECT a+5, b*10 FROM (SELECT x*3 AS a, y+10 AS b FROM t1) WHERE a>b;\n    **   \\                     \\_____________ subquery __________/          /\n    **    \\_____________________ outer query ______________________________/\n    **\n    ** We look at every expression in the outer query and every place we see\n    ** \"a\" we substitute \"x*3\" and every place we see \"b\" we substitute \"y+10\".\n    */\n    if( pSub->pOrderBy ){\n      /* At this point, any non-zero iOrderByCol values indicate that the\n      ** ORDER BY column expression is identical to the iOrderByCol'th\n      ** expression returned by SELECT statement pSub. Since these values\n      ** do not necessarily correspond to columns in SELECT statement pParent,\n      ** zero them before transfering the ORDER BY clause.\n      **\n      ** Not doing this may cause an error if a subsequent call to this\n      ** function attempts to flatten a compound sub-query into pParent\n      ** (the only way this can happen is if the compound sub-query is\n      ** currently part of pSub->pSrc). See ticket [d11a6e908f].  */\n      ExprList *pOrderBy = pSub->pOrderBy;\n      for(i=0; i<pOrderBy->nExpr; i++){\n        pOrderBy->a[i].u.x.iOrderByCol = 0;\n      }\n      assert( pParent->pOrderBy==0 );\n      pParent->pOrderBy = pOrderBy;\n      pSub->pOrderBy = 0;\n    }\n    pWhere = pSub->pWhere;\n    pSub->pWhere = 0;\n    if( isLeftJoin>0 ){\n      sqlite3SetJoinExpr(pWhere, iNewParent);\n    }\n    pParent->pWhere = sqlite3ExprAnd(pParse, pWhere, pParent->pWhere);\n    if( db->mallocFailed==0 ){\n      SubstContext x;\n      x.pParse = pParse;\n      x.iTable = iParent;\n      x.iNewTable = iNewParent;\n      x.isLeftJoin = isLeftJoin;\n      x.pEList = pSub->pEList;\n      substSelect(&x, pParent, 0);\n    }\n  \n    /* The flattened query is a compound if either the inner or the\n    ** outer query is a compound. */\n    pParent->selFlags |= pSub->selFlags & SF_Compound;\n    assert( (pSub->selFlags & SF_Distinct)==0 ); /* restriction (17b) */\n  \n    /*\n    ** SELECT ... FROM (SELECT ... LIMIT a OFFSET b) LIMIT x OFFSET y;\n    **\n    ** One is tempted to try to add a and b to combine the limits.  But this\n    ** does not work if either limit is negative.\n    */\n    if( pSub->pLimit ){\n      pParent->pLimit = pSub->pLimit;\n      pSub->pLimit = 0;\n    }\n  }\n\n  /* Finially, delete what is left of the subquery and return\n  ** success.\n  */\n  sqlite3SelectDelete(db, pSub1);\n\n#if SELECTTRACE_ENABLED\n  if( sqlite3SelectTrace & 0x100 ){\n    SELECTTRACE(0x100,pParse,p,(\"After flattening:\\n\"));\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n\n  return 1;\n}\n#endif /* !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW) */\n\n/*\n** A structure to keep track of all of the column values that are fixed to\n** a known value due to WHERE clause constraints of the form COLUMN=VALUE.\n*/\ntypedef struct WhereConst WhereConst;\nstruct WhereConst {\n  Parse *pParse;   /* Parsing context */\n  int nConst;      /* Number for COLUMN=CONSTANT terms */\n  int nChng;       /* Number of times a constant is propagated */\n  Expr **apExpr;   /* [i*2] is COLUMN and [i*2+1] is VALUE */\n};\n\n/*\n** Add a new entry to the pConst object.  Except, do not add duplicate\n** pColumn entires.\n*/\nstatic void constInsert(\n  WhereConst *pConst,      /* The WhereConst into which we are inserting */\n  Expr *pColumn,           /* The COLUMN part of the constraint */\n  Expr *pValue             /* The VALUE part of the constraint */\n){\n  int i;\n  assert( pColumn->op==TK_COLUMN );\n\n  /* 2018-10-25 ticket [cf5ed20f]\n  ** Make sure the same pColumn is not inserted more than once */\n  for(i=0; i<pConst->nConst; i++){\n    const Expr *pExpr = pConst->apExpr[i*2];\n    assert( pExpr->op==TK_COLUMN );\n    if( pExpr->iTable==pColumn->iTable\n     && pExpr->iColumn==pColumn->iColumn\n    ){\n      return;  /* Already present.  Return without doing anything. */\n    }\n  }\n\n  pConst->nConst++;\n  pConst->apExpr = sqlite3DbReallocOrFree(pConst->pParse->db, pConst->apExpr,\n                         pConst->nConst*2*sizeof(Expr*));\n  if( pConst->apExpr==0 ){\n    pConst->nConst = 0;\n  }else{\n    if( ExprHasProperty(pValue, EP_FixedCol) ) pValue = pValue->pLeft;\n    pConst->apExpr[pConst->nConst*2-2] = pColumn;\n    pConst->apExpr[pConst->nConst*2-1] = pValue;\n  }\n}\n\n/*\n** Find all terms of COLUMN=VALUE or VALUE=COLUMN in pExpr where VALUE\n** is a constant expression and where the term must be true because it\n** is part of the AND-connected terms of the expression.  For each term\n** found, add it to the pConst structure.\n*/\nstatic void findConstInWhere(WhereConst *pConst, Expr *pExpr){\n  Expr *pRight, *pLeft;\n  if( pExpr==0 ) return;\n  if( ExprHasProperty(pExpr, EP_FromJoin) ) return;\n  if( pExpr->op==TK_AND ){\n    findConstInWhere(pConst, pExpr->pRight);\n    findConstInWhere(pConst, pExpr->pLeft);\n    return;\n  }\n  if( pExpr->op!=TK_EQ ) return;\n  pRight = pExpr->pRight;\n  pLeft = pExpr->pLeft;\n  assert( pRight!=0 );\n  assert( pLeft!=0 );\n  if( pRight->op==TK_COLUMN\n   && !ExprHasProperty(pRight, EP_FixedCol)\n   && sqlite3ExprIsConstant(pLeft)\n   && sqlite3IsBinary(sqlite3ExprCompareCollSeq(pConst->pParse,pExpr))\n  ){\n    constInsert(pConst, pRight, pLeft);\n  }else\n  if( pLeft->op==TK_COLUMN\n   && !ExprHasProperty(pLeft, EP_FixedCol)\n   && sqlite3ExprIsConstant(pRight)\n   && sqlite3IsBinary(sqlite3ExprCompareCollSeq(pConst->pParse,pExpr))\n  ){\n    constInsert(pConst, pLeft, pRight);\n  }\n}\n\n/*\n** This is a Walker expression callback.  pExpr is a candidate expression\n** to be replaced by a value.  If pExpr is equivalent to one of the\n** columns named in pWalker->u.pConst, then overwrite it with its\n** corresponding value.\n*/\nstatic int propagateConstantExprRewrite(Walker *pWalker, Expr *pExpr){\n  int i;\n  WhereConst *pConst;\n  if( pExpr->op!=TK_COLUMN ) return WRC_Continue;\n  if( ExprHasProperty(pExpr, EP_FixedCol) ) return WRC_Continue;\n  pConst = pWalker->u.pConst;\n  for(i=0; i<pConst->nConst; i++){\n    Expr *pColumn = pConst->apExpr[i*2];\n    if( pColumn==pExpr ) continue;\n    if( pColumn->iTable!=pExpr->iTable ) continue;\n    if( pColumn->iColumn!=pExpr->iColumn ) continue;\n    /* A match is found.  Add the EP_FixedCol property */\n    pConst->nChng++;\n    ExprClearProperty(pExpr, EP_Leaf);\n    ExprSetProperty(pExpr, EP_FixedCol);\n    assert( pExpr->pLeft==0 );\n    pExpr->pLeft = sqlite3ExprDup(pConst->pParse->db, pConst->apExpr[i*2+1], 0);\n    break;\n  }\n  return WRC_Prune;\n}\n\n/*\n** The WHERE-clause constant propagation optimization.\n**\n** If the WHERE clause contains terms of the form COLUMN=CONSTANT or\n** CONSTANT=COLUMN that must be tree (in other words, if the terms top-level\n** AND-connected terms that are not part of a ON clause from a LEFT JOIN)\n** then throughout the query replace all other occurrences of COLUMN\n** with CONSTANT within the WHERE clause.\n**\n** For example, the query:\n**\n**      SELECT * FROM t1, t2, t3 WHERE t1.a=39 AND t2.b=t1.a AND t3.c=t2.b\n**\n** Is transformed into\n**\n**      SELECT * FROM t1, t2, t3 WHERE t1.a=39 AND t2.b=39 AND t3.c=39\n**\n** Return true if any transformations where made and false if not.\n**\n** Implementation note:  Constant propagation is tricky due to affinity\n** and collating sequence interactions.  Consider this example:\n**\n**    CREATE TABLE t1(a INT,b TEXT);\n**    INSERT INTO t1 VALUES(123,'0123');\n**    SELECT * FROM t1 WHERE a=123 AND b=a;\n**    SELECT * FROM t1 WHERE a=123 AND b=123;\n**\n** The two SELECT statements above should return different answers.  b=a\n** is alway true because the comparison uses numeric affinity, but b=123\n** is false because it uses text affinity and '0123' is not the same as '123'.\n** To work around this, the expression tree is not actually changed from\n** \"b=a\" to \"b=123\" but rather the \"a\" in \"b=a\" is tagged with EP_FixedCol\n** and the \"123\" value is hung off of the pLeft pointer.  Code generator\n** routines know to generate the constant \"123\" instead of looking up the\n** column value.  Also, to avoid collation problems, this optimization is\n** only attempted if the \"a=123\" term uses the default BINARY collation.\n*/\nstatic int propagateConstants(\n  Parse *pParse,   /* The parsing context */\n  Select *p        /* The query in which to propagate constants */\n){\n  WhereConst x;\n  Walker w;\n  int nChng = 0;\n  x.pParse = pParse;\n  do{\n    x.nConst = 0;\n    x.nChng = 0;\n    x.apExpr = 0;\n    findConstInWhere(&x, p->pWhere);\n    if( x.nConst ){\n      memset(&w, 0, sizeof(w));\n      w.pParse = pParse;\n      w.xExprCallback = propagateConstantExprRewrite;\n      w.xSelectCallback = sqlite3SelectWalkNoop;\n      w.xSelectCallback2 = 0;\n      w.walkerDepth = 0;\n      w.u.pConst = &x;\n      sqlite3WalkExpr(&w, p->pWhere);\n      sqlite3DbFree(x.pParse->db, x.apExpr);\n      nChng += x.nChng;\n    }\n  }while( x.nChng );  \n  return nChng;\n}\n\n#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)\n/*\n** Make copies of relevant WHERE clause terms of the outer query into\n** the WHERE clause of subquery.  Example:\n**\n**    SELECT * FROM (SELECT a AS x, c-d AS y FROM t1) WHERE x=5 AND y=10;\n**\n** Transformed into:\n**\n**    SELECT * FROM (SELECT a AS x, c-d AS y FROM t1 WHERE a=5 AND c-d=10)\n**     WHERE x=5 AND y=10;\n**\n** The hope is that the terms added to the inner query will make it more\n** efficient.\n**\n** Do not attempt this optimization if:\n**\n**   (1) (** This restriction was removed on 2017-09-29.  We used to\n**           disallow this optimization for aggregate subqueries, but now\n**           it is allowed by putting the extra terms on the HAVING clause.\n**           The added HAVING clause is pointless if the subquery lacks\n**           a GROUP BY clause.  But such a HAVING clause is also harmless\n**           so there does not appear to be any reason to add extra logic\n**           to suppress it. **)\n**\n**   (2) The inner query is the recursive part of a common table expression.\n**\n**   (3) The inner query has a LIMIT clause (since the changes to the WHERE\n**       clause would change the meaning of the LIMIT).\n**\n**   (4) The inner query is the right operand of a LEFT JOIN and the\n**       expression to be pushed down does not come from the ON clause\n**       on that LEFT JOIN.\n**\n**   (5) The WHERE clause expression originates in the ON or USING clause\n**       of a LEFT JOIN where iCursor is not the right-hand table of that\n**       left join.  An example:\n**\n**           SELECT *\n**           FROM (SELECT 1 AS a1 UNION ALL SELECT 2) AS aa\n**           JOIN (SELECT 1 AS b2 UNION ALL SELECT 2) AS bb ON (a1=b2)\n**           LEFT JOIN (SELECT 8 AS c3 UNION ALL SELECT 9) AS cc ON (b2=2);\n**\n**       The correct answer is three rows:  (1,1,NULL),(2,2,8),(2,2,9).\n**       But if the (b2=2) term were to be pushed down into the bb subquery,\n**       then the (1,1,NULL) row would be suppressed.\n**\n**   (6) The inner query features one or more window-functions (since \n**       changes to the WHERE clause of the inner query could change the \n**       window over which window functions are calculated).\n**\n** Return 0 if no changes are made and non-zero if one or more WHERE clause\n** terms are duplicated into the subquery.\n*/\nstatic int pushDownWhereTerms(\n  Parse *pParse,        /* Parse context (for malloc() and error reporting) */\n  Select *pSubq,        /* The subquery whose WHERE clause is to be augmented */\n  Expr *pWhere,         /* The WHERE clause of the outer query */\n  int iCursor,          /* Cursor number of the subquery */\n  int isLeftJoin        /* True if pSubq is the right term of a LEFT JOIN */\n){\n  Expr *pNew;\n  int nChng = 0;\n  if( pWhere==0 ) return 0;\n  if( pSubq->selFlags & SF_Recursive ) return 0;  /* restriction (2) */\n\n#ifndef SQLITE_OMIT_WINDOWFUNC\n  if( pSubq->pWin ) return 0;    /* restriction (6) */\n#endif\n\n#ifdef SQLITE_DEBUG\n  /* Only the first term of a compound can have a WITH clause.  But make\n  ** sure no other terms are marked SF_Recursive in case something changes\n  ** in the future.\n  */\n  {\n    Select *pX;  \n    for(pX=pSubq; pX; pX=pX->pPrior){\n      assert( (pX->selFlags & (SF_Recursive))==0 );\n    }\n  }\n#endif\n\n  if( pSubq->pLimit!=0 ){\n    return 0; /* restriction (3) */\n  }\n  while( pWhere->op==TK_AND ){\n    nChng += pushDownWhereTerms(pParse, pSubq, pWhere->pRight,\n                                iCursor, isLeftJoin);\n    pWhere = pWhere->pLeft;\n  }\n  if( isLeftJoin\n   && (ExprHasProperty(pWhere,EP_FromJoin)==0\n         || pWhere->iRightJoinTable!=iCursor)\n  ){\n    return 0; /* restriction (4) */\n  }\n  if( ExprHasProperty(pWhere,EP_FromJoin) && pWhere->iRightJoinTable!=iCursor ){\n    return 0; /* restriction (5) */\n  }\n  if( sqlite3ExprIsTableConstant(pWhere, iCursor) ){\n    nChng++;\n    while( pSubq ){\n      SubstContext x;\n      pNew = sqlite3ExprDup(pParse->db, pWhere, 0);\n      unsetJoinExpr(pNew, -1);\n      x.pParse = pParse;\n      x.iTable = iCursor;\n      x.iNewTable = iCursor;\n      x.isLeftJoin = 0;\n      x.pEList = pSubq->pEList;\n      pNew = substExpr(&x, pNew);\n      if( pSubq->selFlags & SF_Aggregate ){\n        pSubq->pHaving = sqlite3ExprAnd(pParse, pSubq->pHaving, pNew);\n      }else{\n        pSubq->pWhere = sqlite3ExprAnd(pParse, pSubq->pWhere, pNew);\n      }\n      pSubq = pSubq->pPrior;\n    }\n  }\n  return nChng;\n}\n#endif /* !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW) */\n\n/*\n** The pFunc is the only aggregate function in the query.  Check to see\n** if the query is a candidate for the min/max optimization. \n**\n** If the query is a candidate for the min/max optimization, then set\n** *ppMinMax to be an ORDER BY clause to be used for the optimization\n** and return either WHERE_ORDERBY_MIN or WHERE_ORDERBY_MAX depending on\n** whether pFunc is a min() or max() function.\n**\n** If the query is not a candidate for the min/max optimization, return\n** WHERE_ORDERBY_NORMAL (which must be zero).\n**\n** This routine must be called after aggregate functions have been\n** located but before their arguments have been subjected to aggregate\n** analysis.\n*/\nstatic u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax){\n  int eRet = WHERE_ORDERBY_NORMAL;      /* Return value */\n  ExprList *pEList = pFunc->x.pList;    /* Arguments to agg function */\n  const char *zFunc;                    /* Name of aggregate function pFunc */\n  ExprList *pOrderBy;\n  u8 sortFlags;\n\n  assert( *ppMinMax==0 );\n  assert( pFunc->op==TK_AGG_FUNCTION );\n  assert( !IsWindowFunc(pFunc) );\n  if( pEList==0 || pEList->nExpr!=1 || ExprHasProperty(pFunc, EP_WinFunc) ){\n    return eRet;\n  }\n  zFunc = pFunc->u.zToken;\n  if( sqlite3StrICmp(zFunc, \"min\")==0 ){\n    eRet = WHERE_ORDERBY_MIN;\n    sortFlags = KEYINFO_ORDER_BIGNULL;\n  }else if( sqlite3StrICmp(zFunc, \"max\")==0 ){\n    eRet = WHERE_ORDERBY_MAX;\n    sortFlags = KEYINFO_ORDER_DESC;\n  }else{\n    return eRet;\n  }\n  *ppMinMax = pOrderBy = sqlite3ExprListDup(db, pEList, 0);\n  assert( pOrderBy!=0 || db->mallocFailed );\n  if( pOrderBy ) pOrderBy->a[0].sortFlags = sortFlags;\n  return eRet;\n}\n\n/*\n** The select statement passed as the first argument is an aggregate query.\n** The second argument is the associated aggregate-info object. This \n** function tests if the SELECT is of the form:\n**\n**   SELECT count(*) FROM <tbl>\n**\n** where table is a database table, not a sub-select or view. If the query\n** does match this pattern, then a pointer to the Table object representing\n** <tbl> is returned. Otherwise, 0 is returned.\n*/\nstatic Table *isSimpleCount(Select *p, AggInfo *pAggInfo){\n  Table *pTab;\n  Expr *pExpr;\n\n  assert( !p->pGroupBy );\n\n  if( p->pWhere || p->pEList->nExpr!=1 \n   || p->pSrc->nSrc!=1 || p->pSrc->a[0].pSelect\n  ){\n    return 0;\n  }\n  pTab = p->pSrc->a[0].pTab;\n  pExpr = p->pEList->a[0].pExpr;\n  assert( pTab && !pTab->pSelect && pExpr );\n\n  if( IsVirtual(pTab) ) return 0;\n  if( pExpr->op!=TK_AGG_FUNCTION ) return 0;\n  if( NEVER(pAggInfo->nFunc==0) ) return 0;\n  if( (pAggInfo->aFunc[0].pFunc->funcFlags&SQLITE_FUNC_COUNT)==0 ) return 0;\n  if( ExprHasProperty(pExpr, EP_Distinct|EP_WinFunc) ) return 0;\n\n  return pTab;\n}\n\n/*\n** If the source-list item passed as an argument was augmented with an\n** INDEXED BY clause, then try to locate the specified index. If there\n** was such a clause and the named index cannot be found, return \n** SQLITE_ERROR and leave an error in pParse. Otherwise, populate \n** pFrom->pIndex and return SQLITE_OK.\n*/\nint sqlite3IndexedByLookup(Parse *pParse, struct SrcList_item *pFrom){\n  if( pFrom->pTab && pFrom->fg.isIndexedBy ){\n    Table *pTab = pFrom->pTab;\n    char *zIndexedBy = pFrom->u1.zIndexedBy;\n    Index *pIdx;\n    for(pIdx=pTab->pIndex; \n        pIdx && sqlite3StrICmp(pIdx->zName, zIndexedBy); \n        pIdx=pIdx->pNext\n    );\n    if( !pIdx ){\n      sqlite3ErrorMsg(pParse, \"no such index: %s\", zIndexedBy, 0);\n      pParse->checkSchema = 1;\n      return SQLITE_ERROR;\n    }\n    pFrom->pIBIndex = pIdx;\n  }\n  return SQLITE_OK;\n}\n/*\n** Detect compound SELECT statements that use an ORDER BY clause with \n** an alternative collating sequence.\n**\n**    SELECT ... FROM t1 EXCEPT SELECT ... FROM t2 ORDER BY .. COLLATE ...\n**\n** These are rewritten as a subquery:\n**\n**    SELECT * FROM (SELECT ... FROM t1 EXCEPT SELECT ... FROM t2)\n**     ORDER BY ... COLLATE ...\n**\n** This transformation is necessary because the multiSelectOrderBy() routine\n** above that generates the code for a compound SELECT with an ORDER BY clause\n** uses a merge algorithm that requires the same collating sequence on the\n** result columns as on the ORDER BY clause.  See ticket\n** http://www.sqlite.org/src/info/6709574d2a\n**\n** This transformation is only needed for EXCEPT, INTERSECT, and UNION.\n** The UNION ALL operator works fine with multiSelectOrderBy() even when\n** there are COLLATE terms in the ORDER BY.\n*/\nstatic int convertCompoundSelectToSubquery(Walker *pWalker, Select *p){\n  int i;\n  Select *pNew;\n  Select *pX;\n  sqlite3 *db;\n  struct ExprList_item *a;\n  SrcList *pNewSrc;\n  Parse *pParse;\n  Token dummy;\n\n  if( p->pPrior==0 ) return WRC_Continue;\n  if( p->pOrderBy==0 ) return WRC_Continue;\n  for(pX=p; pX && (pX->op==TK_ALL || pX->op==TK_SELECT); pX=pX->pPrior){}\n  if( pX==0 ) return WRC_Continue;\n  a = p->pOrderBy->a;\n  for(i=p->pOrderBy->nExpr-1; i>=0; i--){\n    if( a[i].pExpr->flags & EP_Collate ) break;\n  }\n  if( i<0 ) return WRC_Continue;\n\n  /* If we reach this point, that means the transformation is required. */\n\n  pParse = pWalker->pParse;\n  db = pParse->db;\n  pNew = sqlite3DbMallocZero(db, sizeof(*pNew) );\n  if( pNew==0 ) return WRC_Abort;\n  memset(&dummy, 0, sizeof(dummy));\n  pNewSrc = sqlite3SrcListAppendFromTerm(pParse,0,0,0,&dummy,pNew,0,0);\n  if( pNewSrc==0 ) return WRC_Abort;\n  *pNew = *p;\n  p->pSrc = pNewSrc;\n  p->pEList = sqlite3ExprListAppend(pParse, 0, sqlite3Expr(db, TK_ASTERISK, 0));\n  p->op = TK_SELECT;\n  p->pWhere = 0;\n  pNew->pGroupBy = 0;\n  pNew->pHaving = 0;\n  pNew->pOrderBy = 0;\n  p->pPrior = 0;\n  p->pNext = 0;\n  p->pWith = 0;\n#ifndef SQLITE_OMIT_WINDOWFUNC\n  p->pWinDefn = 0;\n#endif\n  p->selFlags &= ~SF_Compound;\n  assert( (p->selFlags & SF_Converted)==0 );\n  p->selFlags |= SF_Converted;\n  assert( pNew->pPrior!=0 );\n  pNew->pPrior->pNext = pNew;\n  pNew->pLimit = 0;\n  return WRC_Continue;\n}\n\n/*\n** Check to see if the FROM clause term pFrom has table-valued function\n** arguments.  If it does, leave an error message in pParse and return\n** non-zero, since pFrom is not allowed to be a table-valued function.\n*/\nstatic int cannotBeFunction(Parse *pParse, struct SrcList_item *pFrom){\n  if( pFrom->fg.isTabFunc ){\n    sqlite3ErrorMsg(pParse, \"'%s' is not a function\", pFrom->zName);\n    return 1;\n  }\n  return 0;\n}\n\n#ifndef SQLITE_OMIT_CTE\n/*\n** Argument pWith (which may be NULL) points to a linked list of nested \n** WITH contexts, from inner to outermost. If the table identified by \n** FROM clause element pItem is really a common-table-expression (CTE) \n** then return a pointer to the CTE definition for that table. Otherwise\n** return NULL.\n**\n** If a non-NULL value is returned, set *ppContext to point to the With\n** object that the returned CTE belongs to.\n*/\nstatic struct Cte *searchWith(\n  With *pWith,                    /* Current innermost WITH clause */\n  struct SrcList_item *pItem,     /* FROM clause element to resolve */\n  With **ppContext                /* OUT: WITH clause return value belongs to */\n){\n  const char *zName;\n  if( pItem->zDatabase==0 && (zName = pItem->zName)!=0 ){\n    With *p;\n    for(p=pWith; p; p=p->pOuter){\n      int i;\n      for(i=0; i<p->nCte; i++){\n        if( sqlite3StrICmp(zName, p->a[i].zName)==0 ){\n          *ppContext = p;\n          return &p->a[i];\n        }\n      }\n    }\n  }\n  return 0;\n}\n\n/* The code generator maintains a stack of active WITH clauses\n** with the inner-most WITH clause being at the top of the stack.\n**\n** This routine pushes the WITH clause passed as the second argument\n** onto the top of the stack. If argument bFree is true, then this\n** WITH clause will never be popped from the stack. In this case it\n** should be freed along with the Parse object. In other cases, when\n** bFree==0, the With object will be freed along with the SELECT \n** statement with which it is associated.\n*/\nvoid sqlite3WithPush(Parse *pParse, With *pWith, u8 bFree){\n  assert( bFree==0 || (pParse->pWith==0 && pParse->pWithToFree==0) );\n  if( pWith ){\n    assert( pParse->pWith!=pWith );\n    pWith->pOuter = pParse->pWith;\n    pParse->pWith = pWith;\n    if( bFree ) pParse->pWithToFree = pWith;\n  }\n}\n\n/*\n** This function checks if argument pFrom refers to a CTE declared by \n** a WITH clause on the stack currently maintained by the parser. And,\n** if currently processing a CTE expression, if it is a recursive\n** reference to the current CTE.\n**\n** If pFrom falls into either of the two categories above, pFrom->pTab\n** and other fields are populated accordingly. The caller should check\n** (pFrom->pTab!=0) to determine whether or not a successful match\n** was found.\n**\n** Whether or not a match is found, SQLITE_OK is returned if no error\n** occurs. If an error does occur, an error message is stored in the\n** parser and some error code other than SQLITE_OK returned.\n*/\nstatic int withExpand(\n  Walker *pWalker, \n  struct SrcList_item *pFrom\n){\n  Parse *pParse = pWalker->pParse;\n  sqlite3 *db = pParse->db;\n  struct Cte *pCte;               /* Matched CTE (or NULL if no match) */\n  With *pWith;                    /* WITH clause that pCte belongs to */\n\n  assert( pFrom->pTab==0 );\n  if( pParse->nErr ){\n    return SQLITE_ERROR;\n  }\n\n  pCte = searchWith(pParse->pWith, pFrom, &pWith);\n  if( pCte ){\n    Table *pTab;\n    ExprList *pEList;\n    Select *pSel;\n    Select *pLeft;                /* Left-most SELECT statement */\n    int bMayRecursive;            /* True if compound joined by UNION [ALL] */\n    With *pSavedWith;             /* Initial value of pParse->pWith */\n\n    /* If pCte->zCteErr is non-NULL at this point, then this is an illegal\n    ** recursive reference to CTE pCte. Leave an error in pParse and return\n    ** early. If pCte->zCteErr is NULL, then this is not a recursive reference.\n    ** In this case, proceed.  */\n    if( pCte->zCteErr ){\n      sqlite3ErrorMsg(pParse, pCte->zCteErr, pCte->zName);\n      return SQLITE_ERROR;\n    }\n    if( cannotBeFunction(pParse, pFrom) ) return SQLITE_ERROR;\n\n    assert( pFrom->pTab==0 );\n    pFrom->pTab = pTab = sqlite3DbMallocZero(db, sizeof(Table));\n    if( pTab==0 ) return WRC_Abort;\n    pTab->nTabRef = 1;\n    pTab->zName = sqlite3DbStrDup(db, pCte->zName);\n    pTab->iPKey = -1;\n    pTab->nRowLogEst = 200; assert( 200==sqlite3LogEst(1048576) );\n    pTab->tabFlags |= TF_Ephemeral | TF_NoVisibleRowid;\n    pFrom->pSelect = sqlite3SelectDup(db, pCte->pSelect, 0);\n    if( db->mallocFailed ) return SQLITE_NOMEM_BKPT;\n    assert( pFrom->pSelect );\n\n    /* Check if this is a recursive CTE. */\n    pSel = pFrom->pSelect;\n    bMayRecursive = ( pSel->op==TK_ALL || pSel->op==TK_UNION );\n    if( bMayRecursive ){\n      int i;\n      SrcList *pSrc = pFrom->pSelect->pSrc;\n      for(i=0; i<pSrc->nSrc; i++){\n        struct SrcList_item *pItem = &pSrc->a[i];\n        if( pItem->zDatabase==0 \n         && pItem->zName!=0 \n         && 0==sqlite3StrICmp(pItem->zName, pCte->zName)\n          ){\n          pItem->pTab = pTab;\n          pItem->fg.isRecursive = 1;\n          pTab->nTabRef++;\n          pSel->selFlags |= SF_Recursive;\n        }\n      }\n    }\n\n    /* Only one recursive reference is permitted. */ \n    if( pTab->nTabRef>2 ){\n      sqlite3ErrorMsg(\n          pParse, \"multiple references to recursive table: %s\", pCte->zName\n      );\n      return SQLITE_ERROR;\n    }\n    assert( pTab->nTabRef==1 || \n            ((pSel->selFlags&SF_Recursive) && pTab->nTabRef==2 ));\n\n    pCte->zCteErr = \"circular reference: %s\";\n    pSavedWith = pParse->pWith;\n    pParse->pWith = pWith;\n    if( bMayRecursive ){\n      Select *pPrior = pSel->pPrior;\n      assert( pPrior->pWith==0 );\n      pPrior->pWith = pSel->pWith;\n      sqlite3WalkSelect(pWalker, pPrior);\n      pPrior->pWith = 0;\n    }else{\n      sqlite3WalkSelect(pWalker, pSel);\n    }\n    pParse->pWith = pWith;\n\n    for(pLeft=pSel; pLeft->pPrior; pLeft=pLeft->pPrior);\n    pEList = pLeft->pEList;\n    if( pCte->pCols ){\n      if( pEList && pEList->nExpr!=pCte->pCols->nExpr ){\n        sqlite3ErrorMsg(pParse, \"table %s has %d values for %d columns\",\n            pCte->zName, pEList->nExpr, pCte->pCols->nExpr\n        );\n        pParse->pWith = pSavedWith;\n        return SQLITE_ERROR;\n      }\n      pEList = pCte->pCols;\n    }\n\n    sqlite3ColumnsFromExprList(pParse, pEList, &pTab->nCol, &pTab->aCol);\n    if( bMayRecursive ){\n      if( pSel->selFlags & SF_Recursive ){\n        pCte->zCteErr = \"multiple recursive references: %s\";\n      }else{\n        pCte->zCteErr = \"recursive reference in a subquery: %s\";\n      }\n      sqlite3WalkSelect(pWalker, pSel);\n    }\n    pCte->zCteErr = 0;\n    pParse->pWith = pSavedWith;\n  }\n\n  return SQLITE_OK;\n}\n#endif\n\n#ifndef SQLITE_OMIT_CTE\n/*\n** If the SELECT passed as the second argument has an associated WITH \n** clause, pop it from the stack stored as part of the Parse object.\n**\n** This function is used as the xSelectCallback2() callback by\n** sqlite3SelectExpand() when walking a SELECT tree to resolve table\n** names and other FROM clause elements. \n*/\nstatic void selectPopWith(Walker *pWalker, Select *p){\n  Parse *pParse = pWalker->pParse;\n  if( OK_IF_ALWAYS_TRUE(pParse->pWith) && p->pPrior==0 ){\n    With *pWith = findRightmost(p)->pWith;\n    if( pWith!=0 ){\n      assert( pParse->pWith==pWith );\n      pParse->pWith = pWith->pOuter;\n    }\n  }\n}\n#else\n#define selectPopWith 0\n#endif\n\n/*\n** The SrcList_item structure passed as the second argument represents a\n** sub-query in the FROM clause of a SELECT statement. This function\n** allocates and populates the SrcList_item.pTab object. If successful,\n** SQLITE_OK is returned. Otherwise, if an OOM error is encountered,\n** SQLITE_NOMEM.\n*/\nint sqlite3ExpandSubquery(Parse *pParse, struct SrcList_item *pFrom){\n  Select *pSel = pFrom->pSelect;\n  Table *pTab;\n\n  assert( pSel );\n  pFrom->pTab = pTab = sqlite3DbMallocZero(pParse->db, sizeof(Table));\n  if( pTab==0 ) return SQLITE_NOMEM;\n  pTab->nTabRef = 1;\n  if( pFrom->zAlias ){\n    pTab->zName = sqlite3DbStrDup(pParse->db, pFrom->zAlias);\n  }else{\n    pTab->zName = sqlite3MPrintf(pParse->db, \"subquery_%u\", pSel->selId);\n  }\n  while( pSel->pPrior ){ pSel = pSel->pPrior; }\n  sqlite3ColumnsFromExprList(pParse, pSel->pEList,&pTab->nCol,&pTab->aCol);\n  pTab->iPKey = -1;\n  pTab->nRowLogEst = 200; assert( 200==sqlite3LogEst(1048576) );\n  pTab->tabFlags |= TF_Ephemeral;\n\n  return pParse->nErr ? SQLITE_ERROR : SQLITE_OK;\n}\n\n/*\n** This routine is a Walker callback for \"expanding\" a SELECT statement.\n** \"Expanding\" means to do the following:\n**\n**    (1)  Make sure VDBE cursor numbers have been assigned to every\n**         element of the FROM clause.\n**\n**    (2)  Fill in the pTabList->a[].pTab fields in the SrcList that \n**         defines FROM clause.  When views appear in the FROM clause,\n**         fill pTabList->a[].pSelect with a copy of the SELECT statement\n**         that implements the view.  A copy is made of the view's SELECT\n**         statement so that we can freely modify or delete that statement\n**         without worrying about messing up the persistent representation\n**         of the view.\n**\n**    (3)  Add terms to the WHERE clause to accommodate the NATURAL keyword\n**         on joins and the ON and USING clause of joins.\n**\n**    (4)  Scan the list of columns in the result set (pEList) looking\n**         for instances of the \"*\" operator or the TABLE.* operator.\n**         If found, expand each \"*\" to be every column in every table\n**         and TABLE.* to be every column in TABLE.\n**\n*/\nstatic int selectExpander(Walker *pWalker, Select *p){\n  Parse *pParse = pWalker->pParse;\n  int i, j, k;\n  SrcList *pTabList;\n  ExprList *pEList;\n  struct SrcList_item *pFrom;\n  sqlite3 *db = pParse->db;\n  Expr *pE, *pRight, *pExpr;\n  u16 selFlags = p->selFlags;\n  u32 elistFlags = 0;\n\n  p->selFlags |= SF_Expanded;\n  if( db->mallocFailed  ){\n    return WRC_Abort;\n  }\n  assert( p->pSrc!=0 );\n  if( (selFlags & SF_Expanded)!=0 ){\n    return WRC_Prune;\n  }\n  if( pWalker->eCode ){\n    /* Renumber selId because it has been copied from a view */\n    p->selId = ++pParse->nSelect;\n  }\n  pTabList = p->pSrc;\n  pEList = p->pEList;\n  sqlite3WithPush(pParse, p->pWith, 0);\n\n  /* Make sure cursor numbers have been assigned to all entries in\n  ** the FROM clause of the SELECT statement.\n  */\n  sqlite3SrcListAssignCursors(pParse, pTabList);\n\n  /* Look up every table named in the FROM clause of the select.  If\n  ** an entry of the FROM clause is a subquery instead of a table or view,\n  ** then create a transient table structure to describe the subquery.\n  */\n  for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){\n    Table *pTab;\n    assert( pFrom->fg.isRecursive==0 || pFrom->pTab!=0 );\n    if( pFrom->fg.isRecursive ) continue;\n    assert( pFrom->pTab==0 );\n#ifndef SQLITE_OMIT_CTE\n    if( withExpand(pWalker, pFrom) ) return WRC_Abort;\n    if( pFrom->pTab ) {} else\n#endif\n    if( pFrom->zName==0 ){\n#ifndef SQLITE_OMIT_SUBQUERY\n      Select *pSel = pFrom->pSelect;\n      /* A sub-query in the FROM clause of a SELECT */\n      assert( pSel!=0 );\n      assert( pFrom->pTab==0 );\n      if( sqlite3WalkSelect(pWalker, pSel) ) return WRC_Abort;\n      if( sqlite3ExpandSubquery(pParse, pFrom) ) return WRC_Abort;\n#endif\n    }else{\n      /* An ordinary table or view name in the FROM clause */\n      assert( pFrom->pTab==0 );\n      pFrom->pTab = pTab = sqlite3LocateTableItem(pParse, 0, pFrom);\n      if( pTab==0 ) return WRC_Abort;\n      if( pTab->nTabRef>=0xffff ){\n        sqlite3ErrorMsg(pParse, \"too many references to \\\"%s\\\": max 65535\",\n           pTab->zName);\n        pFrom->pTab = 0;\n        return WRC_Abort;\n      }\n      pTab->nTabRef++;\n      if( !IsVirtual(pTab) && cannotBeFunction(pParse, pFrom) ){\n        return WRC_Abort;\n      }\n#if !defined(SQLITE_OMIT_VIEW) || !defined (SQLITE_OMIT_VIRTUALTABLE)\n      if( IsVirtual(pTab) || pTab->pSelect ){\n        i16 nCol;\n        u8 eCodeOrig = pWalker->eCode;\n        if( sqlite3ViewGetColumnNames(pParse, pTab) ) return WRC_Abort;\n        assert( pFrom->pSelect==0 );\n        if( pTab->pSelect && (db->flags & SQLITE_EnableView)==0 ){\n          sqlite3ErrorMsg(pParse, \"access to view \\\"%s\\\" prohibited\",\n              pTab->zName);\n        }\n        pFrom->pSelect = sqlite3SelectDup(db, pTab->pSelect, 0);\n        nCol = pTab->nCol;\n        pTab->nCol = -1;\n        pWalker->eCode = 1;  /* Turn on Select.selId renumbering */\n        sqlite3WalkSelect(pWalker, pFrom->pSelect);\n        pWalker->eCode = eCodeOrig;\n        pTab->nCol = nCol;\n      }\n#endif\n    }\n\n    /* Locate the index named by the INDEXED BY clause, if any. */\n    if( sqlite3IndexedByLookup(pParse, pFrom) ){\n      return WRC_Abort;\n    }\n  }\n\n  /* Process NATURAL keywords, and ON and USING clauses of joins.\n  */\n  if( db->mallocFailed || sqliteProcessJoin(pParse, p) ){\n    return WRC_Abort;\n  }\n\n  /* For every \"*\" that occurs in the column list, insert the names of\n  ** all columns in all tables.  And for every TABLE.* insert the names\n  ** of all columns in TABLE.  The parser inserted a special expression\n  ** with the TK_ASTERISK operator for each \"*\" that it found in the column\n  ** list.  The following code just has to locate the TK_ASTERISK\n  ** expressions and expand each one to the list of all columns in\n  ** all tables.\n  **\n  ** The first loop just checks to see if there are any \"*\" operators\n  ** that need expanding.\n  */\n  for(k=0; k<pEList->nExpr; k++){\n    pE = pEList->a[k].pExpr;\n    if( pE->op==TK_ASTERISK ) break;\n    assert( pE->op!=TK_DOT || pE->pRight!=0 );\n    assert( pE->op!=TK_DOT || (pE->pLeft!=0 && pE->pLeft->op==TK_ID) );\n    if( pE->op==TK_DOT && pE->pRight->op==TK_ASTERISK ) break;\n    elistFlags |= pE->flags;\n  }\n  if( k<pEList->nExpr ){\n    /*\n    ** If we get here it means the result set contains one or more \"*\"\n    ** operators that need to be expanded.  Loop through each expression\n    ** in the result set and expand them one by one.\n    */\n    struct ExprList_item *a = pEList->a;\n    ExprList *pNew = 0;\n    int flags = pParse->db->flags;\n    int longNames = (flags & SQLITE_FullColNames)!=0\n                      && (flags & SQLITE_ShortColNames)==0;\n\n    for(k=0; k<pEList->nExpr; k++){\n      pE = a[k].pExpr;\n      elistFlags |= pE->flags;\n      pRight = pE->pRight;\n      assert( pE->op!=TK_DOT || pRight!=0 );\n      if( pE->op!=TK_ASTERISK\n       && (pE->op!=TK_DOT || pRight->op!=TK_ASTERISK)\n      ){\n        /* This particular expression does not need to be expanded.\n        */\n        pNew = sqlite3ExprListAppend(pParse, pNew, a[k].pExpr);\n        if( pNew ){\n          pNew->a[pNew->nExpr-1].zName = a[k].zName;\n          pNew->a[pNew->nExpr-1].zSpan = a[k].zSpan;\n          a[k].zName = 0;\n          a[k].zSpan = 0;\n        }\n        a[k].pExpr = 0;\n      }else{\n        /* This expression is a \"*\" or a \"TABLE.*\" and needs to be\n        ** expanded. */\n        int tableSeen = 0;      /* Set to 1 when TABLE matches */\n        char *zTName = 0;       /* text of name of TABLE */\n        if( pE->op==TK_DOT ){\n          assert( pE->pLeft!=0 );\n          assert( !ExprHasProperty(pE->pLeft, EP_IntValue) );\n          zTName = pE->pLeft->u.zToken;\n        }\n        for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){\n          Table *pTab = pFrom->pTab;\n          Select *pSub = pFrom->pSelect;\n          char *zTabName = pFrom->zAlias;\n          const char *zSchemaName = 0;\n          int iDb;\n          if( zTabName==0 ){\n            zTabName = pTab->zName;\n          }\n          if( db->mallocFailed ) break;\n          if( pSub==0 || (pSub->selFlags & SF_NestedFrom)==0 ){\n            pSub = 0;\n            if( zTName && sqlite3StrICmp(zTName, zTabName)!=0 ){\n              continue;\n            }\n            iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n            zSchemaName = iDb>=0 ? db->aDb[iDb].zDbSName : \"*\";\n          }\n          for(j=0; j<pTab->nCol; j++){\n            char *zName = pTab->aCol[j].zName;\n            char *zColname;  /* The computed column name */\n            char *zToFree;   /* Malloced string that needs to be freed */\n            Token sColname;  /* Computed column name as a token */\n\n            assert( zName );\n            if( zTName && pSub\n             && sqlite3MatchSpanName(pSub->pEList->a[j].zSpan, 0, zTName, 0)==0\n            ){\n              continue;\n            }\n\n            /* If a column is marked as 'hidden', omit it from the expanded\n            ** result-set list unless the SELECT has the SF_IncludeHidden\n            ** bit set.\n            */\n            if( (p->selFlags & SF_IncludeHidden)==0\n             && IsHiddenColumn(&pTab->aCol[j]) \n            ){\n              continue;\n            }\n            tableSeen = 1;\n\n            if( i>0 && zTName==0 ){\n              if( (pFrom->fg.jointype & JT_NATURAL)!=0\n                && tableAndColumnIndex(pTabList, i, zName, 0, 0)\n              ){\n                /* In a NATURAL join, omit the join columns from the \n                ** table to the right of the join */\n                continue;\n              }\n              if( sqlite3IdListIndex(pFrom->pUsing, zName)>=0 ){\n                /* In a join with a USING clause, omit columns in the\n                ** using clause from the table on the right. */\n                continue;\n              }\n            }\n            pRight = sqlite3Expr(db, TK_ID, zName);\n            zColname = zName;\n            zToFree = 0;\n            if( longNames || pTabList->nSrc>1 ){\n              Expr *pLeft;\n              pLeft = sqlite3Expr(db, TK_ID, zTabName);\n              pExpr = sqlite3PExpr(pParse, TK_DOT, pLeft, pRight);\n              if( zSchemaName ){\n                pLeft = sqlite3Expr(db, TK_ID, zSchemaName);\n                pExpr = sqlite3PExpr(pParse, TK_DOT, pLeft, pExpr);\n              }\n              if( longNames ){\n                zColname = sqlite3MPrintf(db, \"%s.%s\", zTabName, zName);\n                zToFree = zColname;\n              }\n            }else{\n              pExpr = pRight;\n            }\n            pNew = sqlite3ExprListAppend(pParse, pNew, pExpr);\n            sqlite3TokenInit(&sColname, zColname);\n            sqlite3ExprListSetName(pParse, pNew, &sColname, 0);\n            if( pNew && (p->selFlags & SF_NestedFrom)!=0 ){\n              struct ExprList_item *pX = &pNew->a[pNew->nExpr-1];\n              if( pSub ){\n                pX->zSpan = sqlite3DbStrDup(db, pSub->pEList->a[j].zSpan);\n                testcase( pX->zSpan==0 );\n              }else{\n                pX->zSpan = sqlite3MPrintf(db, \"%s.%s.%s\",\n                                           zSchemaName, zTabName, zColname);\n                testcase( pX->zSpan==0 );\n              }\n              pX->bSpanIsTab = 1;\n            }\n            sqlite3DbFree(db, zToFree);\n          }\n        }\n        if( !tableSeen ){\n          if( zTName ){\n            sqlite3ErrorMsg(pParse, \"no such table: %s\", zTName);\n          }else{\n            sqlite3ErrorMsg(pParse, \"no tables specified\");\n          }\n        }\n      }\n    }\n    sqlite3ExprListDelete(db, pEList);\n    p->pEList = pNew;\n  }\n  if( p->pEList ){\n    if( p->pEList->nExpr>db->aLimit[SQLITE_LIMIT_COLUMN] ){\n      sqlite3ErrorMsg(pParse, \"too many columns in result set\");\n      return WRC_Abort;\n    }\n    if( (elistFlags & (EP_HasFunc|EP_Subquery))!=0 ){\n      p->selFlags |= SF_ComplexResult;\n    }\n  }\n  return WRC_Continue;\n}\n\n/*\n** No-op routine for the parse-tree walker.\n**\n** When this routine is the Walker.xExprCallback then expression trees\n** are walked without any actions being taken at each node.  Presumably,\n** when this routine is used for Walker.xExprCallback then \n** Walker.xSelectCallback is set to do something useful for every \n** subquery in the parser tree.\n*/\nint sqlite3ExprWalkNoop(Walker *NotUsed, Expr *NotUsed2){\n  UNUSED_PARAMETER2(NotUsed, NotUsed2);\n  return WRC_Continue;\n}\n\n/*\n** No-op routine for the parse-tree walker for SELECT statements.\n** subquery in the parser tree.\n*/\nint sqlite3SelectWalkNoop(Walker *NotUsed, Select *NotUsed2){\n  UNUSED_PARAMETER2(NotUsed, NotUsed2);\n  return WRC_Continue;\n}\n\n#if SQLITE_DEBUG\n/*\n** Always assert.  This xSelectCallback2 implementation proves that the\n** xSelectCallback2 is never invoked.\n*/\nvoid sqlite3SelectWalkAssert2(Walker *NotUsed, Select *NotUsed2){\n  UNUSED_PARAMETER2(NotUsed, NotUsed2);\n  assert( 0 );\n}\n#endif\n/*\n** This routine \"expands\" a SELECT statement and all of its subqueries.\n** For additional information on what it means to \"expand\" a SELECT\n** statement, see the comment on the selectExpand worker callback above.\n**\n** Expanding a SELECT statement is the first step in processing a\n** SELECT statement.  The SELECT statement must be expanded before\n** name resolution is performed.\n**\n** If anything goes wrong, an error message is written into pParse.\n** The calling function can detect the problem by looking at pParse->nErr\n** and/or pParse->db->mallocFailed.\n*/\nstatic void sqlite3SelectExpand(Parse *pParse, Select *pSelect){\n  Walker w;\n  w.xExprCallback = sqlite3ExprWalkNoop;\n  w.pParse = pParse;\n  if( OK_IF_ALWAYS_TRUE(pParse->hasCompound) ){\n    w.xSelectCallback = convertCompoundSelectToSubquery;\n    w.xSelectCallback2 = 0;\n    sqlite3WalkSelect(&w, pSelect);\n  }\n  w.xSelectCallback = selectExpander;\n  w.xSelectCallback2 = selectPopWith;\n  w.eCode = 0;\n  sqlite3WalkSelect(&w, pSelect);\n}\n\n\n#ifndef SQLITE_OMIT_SUBQUERY\n/*\n** This is a Walker.xSelectCallback callback for the sqlite3SelectTypeInfo()\n** interface.\n**\n** For each FROM-clause subquery, add Column.zType and Column.zColl\n** information to the Table structure that represents the result set\n** of that subquery.\n**\n** The Table structure that represents the result set was constructed\n** by selectExpander() but the type and collation information was omitted\n** at that point because identifiers had not yet been resolved.  This\n** routine is called after identifier resolution.\n*/\nstatic void selectAddSubqueryTypeInfo(Walker *pWalker, Select *p){\n  Parse *pParse;\n  int i;\n  SrcList *pTabList;\n  struct SrcList_item *pFrom;\n\n  assert( p->selFlags & SF_Resolved );\n  if( p->selFlags & SF_HasTypeInfo ) return;\n  p->selFlags |= SF_HasTypeInfo;\n  pParse = pWalker->pParse;\n  pTabList = p->pSrc;\n  for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){\n    Table *pTab = pFrom->pTab;\n    assert( pTab!=0 );\n    if( (pTab->tabFlags & TF_Ephemeral)!=0 ){\n      /* A sub-query in the FROM clause of a SELECT */\n      Select *pSel = pFrom->pSelect;\n      if( pSel ){\n        while( pSel->pPrior ) pSel = pSel->pPrior;\n        sqlite3SelectAddColumnTypeAndCollation(pParse, pTab, pSel,\n                                               SQLITE_AFF_NONE);\n      }\n    }\n  }\n}\n#endif\n\n\n/*\n** This routine adds datatype and collating sequence information to\n** the Table structures of all FROM-clause subqueries in a\n** SELECT statement.\n**\n** Use this routine after name resolution.\n*/\nstatic void sqlite3SelectAddTypeInfo(Parse *pParse, Select *pSelect){\n#ifndef SQLITE_OMIT_SUBQUERY\n  Walker w;\n  w.xSelectCallback = sqlite3SelectWalkNoop;\n  w.xSelectCallback2 = selectAddSubqueryTypeInfo;\n  w.xExprCallback = sqlite3ExprWalkNoop;\n  w.pParse = pParse;\n  sqlite3WalkSelect(&w, pSelect);\n#endif\n}\n\n\n/*\n** This routine sets up a SELECT statement for processing.  The\n** following is accomplished:\n**\n**     *  VDBE Cursor numbers are assigned to all FROM-clause terms.\n**     *  Ephemeral Table objects are created for all FROM-clause subqueries.\n**     *  ON and USING clauses are shifted into WHERE statements\n**     *  Wildcards \"*\" and \"TABLE.*\" in result sets are expanded.\n**     *  Identifiers in expression are matched to tables.\n**\n** This routine acts recursively on all subqueries within the SELECT.\n*/\nvoid sqlite3SelectPrep(\n  Parse *pParse,         /* The parser context */\n  Select *p,             /* The SELECT statement being coded. */\n  NameContext *pOuterNC  /* Name context for container */\n){\n  assert( p!=0 || pParse->db->mallocFailed );\n  if( pParse->db->mallocFailed ) return;\n  if( p->selFlags & SF_HasTypeInfo ) return;\n  sqlite3SelectExpand(pParse, p);\n  if( pParse->nErr || pParse->db->mallocFailed ) return;\n  sqlite3ResolveSelectNames(pParse, p, pOuterNC);\n  if( pParse->nErr || pParse->db->mallocFailed ) return;\n  sqlite3SelectAddTypeInfo(pParse, p);\n}\n\n/*\n** Reset the aggregate accumulator.\n**\n** The aggregate accumulator is a set of memory cells that hold\n** intermediate results while calculating an aggregate.  This\n** routine generates code that stores NULLs in all of those memory\n** cells.\n*/\nstatic void resetAccumulator(Parse *pParse, AggInfo *pAggInfo){\n  Vdbe *v = pParse->pVdbe;\n  int i;\n  struct AggInfo_func *pFunc;\n  int nReg = pAggInfo->nFunc + pAggInfo->nColumn;\n  if( nReg==0 ) return;\n#ifdef SQLITE_DEBUG\n  /* Verify that all AggInfo registers are within the range specified by\n  ** AggInfo.mnReg..AggInfo.mxReg */\n  assert( nReg==pAggInfo->mxReg-pAggInfo->mnReg+1 );\n  for(i=0; i<pAggInfo->nColumn; i++){\n    assert( pAggInfo->aCol[i].iMem>=pAggInfo->mnReg\n         && pAggInfo->aCol[i].iMem<=pAggInfo->mxReg );\n  }\n  for(i=0; i<pAggInfo->nFunc; i++){\n    assert( pAggInfo->aFunc[i].iMem>=pAggInfo->mnReg\n         && pAggInfo->aFunc[i].iMem<=pAggInfo->mxReg );\n  }\n#endif\n  sqlite3VdbeAddOp3(v, OP_Null, 0, pAggInfo->mnReg, pAggInfo->mxReg);\n  for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++){\n    if( pFunc->iDistinct>=0 ){\n      Expr *pE = pFunc->pExpr;\n      assert( !ExprHasProperty(pE, EP_xIsSelect) );\n      if( pE->x.pList==0 || pE->x.pList->nExpr!=1 ){\n        sqlite3ErrorMsg(pParse, \"DISTINCT aggregates must have exactly one \"\n           \"argument\");\n        pFunc->iDistinct = -1;\n      }else{\n        KeyInfo *pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pE->x.pList,0,0);\n        sqlite3VdbeAddOp4(v, OP_OpenEphemeral, pFunc->iDistinct, 0, 0,\n                          (char*)pKeyInfo, P4_KEYINFO);\n      }\n    }\n  }\n}\n\n/*\n** Invoke the OP_AggFinalize opcode for every aggregate function\n** in the AggInfo structure.\n*/\nstatic void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo){\n  Vdbe *v = pParse->pVdbe;\n  int i;\n  struct AggInfo_func *pF;\n  for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++){\n    ExprList *pList = pF->pExpr->x.pList;\n    assert( !ExprHasProperty(pF->pExpr, EP_xIsSelect) );\n    sqlite3VdbeAddOp2(v, OP_AggFinal, pF->iMem, pList ? pList->nExpr : 0);\n    sqlite3VdbeAppendP4(v, pF->pFunc, P4_FUNCDEF);\n  }\n}\n\n\n/*\n** Update the accumulator memory cells for an aggregate based on\n** the current cursor position.\n**\n** If regAcc is non-zero and there are no min() or max() aggregates\n** in pAggInfo, then only populate the pAggInfo->nAccumulator accumulator\n** registers if register regAcc contains 0. The caller will take care\n** of setting and clearing regAcc.\n*/\nstatic void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo){\n  Vdbe *v = pParse->pVdbe;\n  int i;\n  int regHit = 0;\n  int addrHitTest = 0;\n  struct AggInfo_func *pF;\n  struct AggInfo_col *pC;\n\n  pAggInfo->directMode = 1;\n  for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++){\n    int nArg;\n    int addrNext = 0;\n    int regAgg;\n    ExprList *pList = pF->pExpr->x.pList;\n    assert( !ExprHasProperty(pF->pExpr, EP_xIsSelect) );\n    assert( !IsWindowFunc(pF->pExpr) );\n    if( ExprHasProperty(pF->pExpr, EP_WinFunc) ){\n      Expr *pFilter = pF->pExpr->y.pWin->pFilter;\n      if( pAggInfo->nAccumulator \n       && (pF->pFunc->funcFlags & SQLITE_FUNC_NEEDCOLL) \n      ){\n        if( regHit==0 ) regHit = ++pParse->nMem;\n        /* If this is the first row of the group (regAcc==0), clear the\n        ** \"magnet\" register regHit so that the accumulator registers\n        ** are populated if the FILTER clause jumps over the the \n        ** invocation of min() or max() altogether. Or, if this is not\n        ** the first row (regAcc==1), set the magnet register so that the\n        ** accumulators are not populated unless the min()/max() is invoked and\n        ** indicates that they should be.  */\n        sqlite3VdbeAddOp2(v, OP_Copy, regAcc, regHit);\n      }\n      addrNext = sqlite3VdbeMakeLabel(pParse);\n      sqlite3ExprIfFalse(pParse, pFilter, addrNext, SQLITE_JUMPIFNULL);\n    }\n    if( pList ){\n      nArg = pList->nExpr;\n      regAgg = sqlite3GetTempRange(pParse, nArg);\n      sqlite3ExprCodeExprList(pParse, pList, regAgg, 0, SQLITE_ECEL_DUP);\n    }else{\n      nArg = 0;\n      regAgg = 0;\n    }\n    if( pF->iDistinct>=0 ){\n      if( addrNext==0 ){ \n        addrNext = sqlite3VdbeMakeLabel(pParse);\n      }\n      testcase( nArg==0 );  /* Error condition */\n      testcase( nArg>1 );   /* Also an error */\n      codeDistinct(pParse, pF->iDistinct, addrNext, 1, regAgg);\n    }\n    if( pF->pFunc->funcFlags & SQLITE_FUNC_NEEDCOLL ){\n      CollSeq *pColl = 0;\n      struct ExprList_item *pItem;\n      int j;\n      assert( pList!=0 );  /* pList!=0 if pF->pFunc has NEEDCOLL */\n      for(j=0, pItem=pList->a; !pColl && j<nArg; j++, pItem++){\n        pColl = sqlite3ExprCollSeq(pParse, pItem->pExpr);\n      }\n      if( !pColl ){\n        pColl = pParse->db->pDfltColl;\n      }\n      if( regHit==0 && pAggInfo->nAccumulator ) regHit = ++pParse->nMem;\n      sqlite3VdbeAddOp4(v, OP_CollSeq, regHit, 0, 0, (char *)pColl, P4_COLLSEQ);\n    }\n    sqlite3VdbeAddOp3(v, OP_AggStep, 0, regAgg, pF->iMem);\n    sqlite3VdbeAppendP4(v, pF->pFunc, P4_FUNCDEF);\n    sqlite3VdbeChangeP5(v, (u8)nArg);\n    sqlite3ReleaseTempRange(pParse, regAgg, nArg);\n    if( addrNext ){\n      sqlite3VdbeResolveLabel(v, addrNext);\n    }\n  }\n  if( regHit==0 && pAggInfo->nAccumulator ){\n    regHit = regAcc;\n  }\n  if( regHit ){\n    addrHitTest = sqlite3VdbeAddOp1(v, OP_If, regHit); VdbeCoverage(v);\n  }\n  for(i=0, pC=pAggInfo->aCol; i<pAggInfo->nAccumulator; i++, pC++){\n    sqlite3ExprCode(pParse, pC->pExpr, pC->iMem);\n  }\n\n  pAggInfo->directMode = 0;\n  if( addrHitTest ){\n    sqlite3VdbeJumpHere(v, addrHitTest);\n  }\n}\n\n/*\n** Add a single OP_Explain instruction to the VDBE to explain a simple\n** count(*) query (\"SELECT count(*) FROM pTab\").\n*/\n#ifndef SQLITE_OMIT_EXPLAIN\nstatic void explainSimpleCount(\n  Parse *pParse,                  /* Parse context */\n  Table *pTab,                    /* Table being queried */\n  Index *pIdx                     /* Index used to optimize scan, or NULL */\n){\n  if( pParse->explain==2 ){\n    int bCover = (pIdx!=0 && (HasRowid(pTab) || !IsPrimaryKeyIndex(pIdx)));\n    sqlite3VdbeExplain(pParse, 0, \"SCAN TABLE %s%s%s\",\n        pTab->zName,\n        bCover ? \" USING COVERING INDEX \" : \"\",\n        bCover ? pIdx->zName : \"\"\n    );\n  }\n}\n#else\n# define explainSimpleCount(a,b,c)\n#endif\n\n/*\n** sqlite3WalkExpr() callback used by havingToWhere().\n**\n** If the node passed to the callback is a TK_AND node, return \n** WRC_Continue to tell sqlite3WalkExpr() to iterate through child nodes.\n**\n** Otherwise, return WRC_Prune. In this case, also check if the \n** sub-expression matches the criteria for being moved to the WHERE\n** clause. If so, add it to the WHERE clause and replace the sub-expression\n** within the HAVING expression with a constant \"1\".\n*/\nstatic int havingToWhereExprCb(Walker *pWalker, Expr *pExpr){\n  if( pExpr->op!=TK_AND ){\n    Select *pS = pWalker->u.pSelect;\n    if( sqlite3ExprIsConstantOrGroupBy(pWalker->pParse, pExpr, pS->pGroupBy) ){\n      sqlite3 *db = pWalker->pParse->db;\n      Expr *pNew = sqlite3Expr(db, TK_INTEGER, \"1\");\n      if( pNew ){\n        Expr *pWhere = pS->pWhere;\n        SWAP(Expr, *pNew, *pExpr);\n        pNew = sqlite3ExprAnd(pWalker->pParse, pWhere, pNew);\n        pS->pWhere = pNew;\n        pWalker->eCode = 1;\n      }\n    }\n    return WRC_Prune;\n  }\n  return WRC_Continue;\n}\n\n/*\n** Transfer eligible terms from the HAVING clause of a query, which is\n** processed after grouping, to the WHERE clause, which is processed before\n** grouping. For example, the query:\n**\n**   SELECT * FROM <tables> WHERE a=? GROUP BY b HAVING b=? AND c=?\n**\n** can be rewritten as:\n**\n**   SELECT * FROM <tables> WHERE a=? AND b=? GROUP BY b HAVING c=?\n**\n** A term of the HAVING expression is eligible for transfer if it consists\n** entirely of constants and expressions that are also GROUP BY terms that\n** use the \"BINARY\" collation sequence.\n*/\nstatic void havingToWhere(Parse *pParse, Select *p){\n  Walker sWalker;\n  memset(&sWalker, 0, sizeof(sWalker));\n  sWalker.pParse = pParse;\n  sWalker.xExprCallback = havingToWhereExprCb;\n  sWalker.u.pSelect = p;\n  sqlite3WalkExpr(&sWalker, p->pHaving);\n#if SELECTTRACE_ENABLED\n  if( sWalker.eCode && (sqlite3SelectTrace & 0x100)!=0 ){\n    SELECTTRACE(0x100,pParse,p,(\"Move HAVING terms into WHERE:\\n\"));\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n}\n\n/*\n** Check to see if the pThis entry of pTabList is a self-join of a prior view.\n** If it is, then return the SrcList_item for the prior view.  If it is not,\n** then return 0.\n*/\nstatic struct SrcList_item *isSelfJoinView(\n  SrcList *pTabList,           /* Search for self-joins in this FROM clause */\n  struct SrcList_item *pThis   /* Search for prior reference to this subquery */\n){\n  struct SrcList_item *pItem;\n  for(pItem = pTabList->a; pItem<pThis; pItem++){\n    Select *pS1;\n    if( pItem->pSelect==0 ) continue;\n    if( pItem->fg.viaCoroutine ) continue;\n    if( pItem->zName==0 ) continue;\n    assert( pItem->pTab!=0 );\n    assert( pThis->pTab!=0 );\n    if( pItem->pTab->pSchema!=pThis->pTab->pSchema ) continue;\n    if( sqlite3_stricmp(pItem->zName, pThis->zName)!=0 ) continue;\n    pS1 = pItem->pSelect;\n    if( pItem->pTab->pSchema==0 && pThis->pSelect->selId!=pS1->selId ){\n      /* The query flattener left two different CTE tables with identical\n      ** names in the same FROM clause. */\n      continue;\n    }\n    if( sqlite3ExprCompare(0, pThis->pSelect->pWhere, pS1->pWhere, -1)\n     || sqlite3ExprCompare(0, pThis->pSelect->pHaving, pS1->pHaving, -1) \n    ){\n      /* The view was modified by some other optimization such as\n      ** pushDownWhereTerms() */\n      continue;\n    }\n    return pItem;\n  }\n  return 0;\n}\n\n#ifdef SQLITE_COUNTOFVIEW_OPTIMIZATION\n/*\n** Attempt to transform a query of the form\n**\n**    SELECT count(*) FROM (SELECT x FROM t1 UNION ALL SELECT y FROM t2)\n**\n** Into this:\n**\n**    SELECT (SELECT count(*) FROM t1)+(SELECT count(*) FROM t2)\n**\n** The transformation only works if all of the following are true:\n**\n**   *  The subquery is a UNION ALL of two or more terms\n**   *  The subquery does not have a LIMIT clause\n**   *  There is no WHERE or GROUP BY or HAVING clauses on the subqueries\n**   *  The outer query is a simple count(*) with no WHERE clause or other\n**      extraneous syntax.\n**\n** Return TRUE if the optimization is undertaken.\n*/\nstatic int countOfViewOptimization(Parse *pParse, Select *p){\n  Select *pSub, *pPrior;\n  Expr *pExpr;\n  Expr *pCount;\n  sqlite3 *db;\n  if( (p->selFlags & SF_Aggregate)==0 ) return 0;   /* This is an aggregate */\n  if( p->pEList->nExpr!=1 ) return 0;               /* Single result column */\n  if( p->pWhere ) return 0;\n  if( p->pGroupBy ) return 0;\n  pExpr = p->pEList->a[0].pExpr;\n  if( pExpr->op!=TK_AGG_FUNCTION ) return 0;        /* Result is an aggregate */\n  if( sqlite3_stricmp(pExpr->u.zToken,\"count\") ) return 0;  /* Is count() */\n  if( pExpr->x.pList!=0 ) return 0;                 /* Must be count(*) */\n  if( p->pSrc->nSrc!=1 ) return 0;                  /* One table in FROM  */\n  pSub = p->pSrc->a[0].pSelect;\n  if( pSub==0 ) return 0;                           /* The FROM is a subquery */\n  if( pSub->pPrior==0 ) return 0;                   /* Must be a compound ry */\n  do{\n    if( pSub->op!=TK_ALL && pSub->pPrior ) return 0;  /* Must be UNION ALL */\n    if( pSub->pWhere ) return 0;                      /* No WHERE clause */\n    if( pSub->pLimit ) return 0;                      /* No LIMIT clause */\n    if( pSub->selFlags & SF_Aggregate ) return 0;     /* Not an aggregate */\n    pSub = pSub->pPrior;                              /* Repeat over compound */\n  }while( pSub );\n\n  /* If we reach this point then it is OK to perform the transformation */\n\n  db = pParse->db;\n  pCount = pExpr;\n  pExpr = 0;\n  pSub = p->pSrc->a[0].pSelect;\n  p->pSrc->a[0].pSelect = 0;\n  sqlite3SrcListDelete(db, p->pSrc);\n  p->pSrc = sqlite3DbMallocZero(pParse->db, sizeof(*p->pSrc));\n  while( pSub ){\n    Expr *pTerm;\n    pPrior = pSub->pPrior;\n    pSub->pPrior = 0;\n    pSub->pNext = 0;\n    pSub->selFlags |= SF_Aggregate;\n    pSub->selFlags &= ~SF_Compound;\n    pSub->nSelectRow = 0;\n    sqlite3ExprListDelete(db, pSub->pEList);\n    pTerm = pPrior ? sqlite3ExprDup(db, pCount, 0) : pCount;\n    pSub->pEList = sqlite3ExprListAppend(pParse, 0, pTerm);\n    pTerm = sqlite3PExpr(pParse, TK_SELECT, 0, 0);\n    sqlite3PExprAddSelect(pParse, pTerm, pSub);\n    if( pExpr==0 ){\n      pExpr = pTerm;\n    }else{\n      pExpr = sqlite3PExpr(pParse, TK_PLUS, pTerm, pExpr);\n    }\n    pSub = pPrior;\n  }\n  p->pEList->a[0].pExpr = pExpr;\n  p->selFlags &= ~SF_Aggregate;\n\n#if SELECTTRACE_ENABLED\n  if( sqlite3SelectTrace & 0x400 ){\n    SELECTTRACE(0x400,pParse,p,(\"After count-of-view optimization:\\n\"));\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n  return 1;\n}\n#endif /* SQLITE_COUNTOFVIEW_OPTIMIZATION */\n\n/*\n** Generate code for the SELECT statement given in the p argument.  \n**\n** The results are returned according to the SelectDest structure.\n** See comments in sqliteInt.h for further information.\n**\n** This routine returns the number of errors.  If any errors are\n** encountered, then an appropriate error message is left in\n** pParse->zErrMsg.\n**\n** This routine does NOT free the Select structure passed in.  The\n** calling function needs to do that.\n*/\nint sqlite3Select(\n  Parse *pParse,         /* The parser context */\n  Select *p,             /* The SELECT statement being coded. */\n  SelectDest *pDest      /* What to do with the query results */\n){\n  int i, j;              /* Loop counters */\n  WhereInfo *pWInfo;     /* Return from sqlite3WhereBegin() */\n  Vdbe *v;               /* The virtual machine under construction */\n  int isAgg;             /* True for select lists like \"count(*)\" */\n  ExprList *pEList = 0;  /* List of columns to extract. */\n  SrcList *pTabList;     /* List of tables to select from */\n  Expr *pWhere;          /* The WHERE clause.  May be NULL */\n  ExprList *pGroupBy;    /* The GROUP BY clause.  May be NULL */\n  Expr *pHaving;         /* The HAVING clause.  May be NULL */\n  int rc = 1;            /* Value to return from this function */\n  DistinctCtx sDistinct; /* Info on how to code the DISTINCT keyword */\n  SortCtx sSort;         /* Info on how to code the ORDER BY clause */\n  AggInfo sAggInfo;      /* Information used by aggregate queries */\n  int iEnd;              /* Address of the end of the query */\n  sqlite3 *db;           /* The database connection */\n  ExprList *pMinMaxOrderBy = 0;  /* Added ORDER BY for min/max queries */\n  u8 minMaxFlag;                 /* Flag for min/max queries */\n\n  db = pParse->db;\n  v = sqlite3GetVdbe(pParse);\n  if( p==0 || db->mallocFailed || pParse->nErr ){\n    return 1;\n  }\n  if( sqlite3AuthCheck(pParse, SQLITE_SELECT, 0, 0, 0) ) return 1;\n  memset(&sAggInfo, 0, sizeof(sAggInfo));\n#if SELECTTRACE_ENABLED\n  SELECTTRACE(1,pParse,p, (\"begin processing:\\n\", pParse->addrExplain));\n  if( sqlite3SelectTrace & 0x100 ){\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n\n  assert( p->pOrderBy==0 || pDest->eDest!=SRT_DistFifo );\n  assert( p->pOrderBy==0 || pDest->eDest!=SRT_Fifo );\n  assert( p->pOrderBy==0 || pDest->eDest!=SRT_DistQueue );\n  assert( p->pOrderBy==0 || pDest->eDest!=SRT_Queue );\n  if( IgnorableOrderby(pDest) ){\n    assert(pDest->eDest==SRT_Exists || pDest->eDest==SRT_Union || \n           pDest->eDest==SRT_Except || pDest->eDest==SRT_Discard ||\n           pDest->eDest==SRT_Queue  || pDest->eDest==SRT_DistFifo ||\n           pDest->eDest==SRT_DistQueue || pDest->eDest==SRT_Fifo);\n    /* If ORDER BY makes no difference in the output then neither does\n    ** DISTINCT so it can be removed too. */\n    sqlite3ExprListDelete(db, p->pOrderBy);\n    p->pOrderBy = 0;\n    p->selFlags &= ~SF_Distinct;\n  }\n  sqlite3SelectPrep(pParse, p, 0);\n  if( pParse->nErr || db->mallocFailed ){\n    goto select_end;\n  }\n  assert( p->pEList!=0 );\n#if SELECTTRACE_ENABLED\n  if( sqlite3SelectTrace & 0x104 ){\n    SELECTTRACE(0x104,pParse,p, (\"after name resolution:\\n\"));\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n\n  if( pDest->eDest==SRT_Output ){\n    generateColumnNames(pParse, p);\n  }\n\n#ifndef SQLITE_OMIT_WINDOWFUNC\n  if( sqlite3WindowRewrite(pParse, p) ){\n    goto select_end;\n  }\n#if SELECTTRACE_ENABLED\n  if( p->pWin && (sqlite3SelectTrace & 0x108)!=0 ){\n    SELECTTRACE(0x104,pParse,p, (\"after window rewrite:\\n\"));\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n#endif /* SQLITE_OMIT_WINDOWFUNC */\n  pTabList = p->pSrc;\n  isAgg = (p->selFlags & SF_Aggregate)!=0;\n  memset(&sSort, 0, sizeof(sSort));\n  sSort.pOrderBy = p->pOrderBy;\n\n  /* Try to various optimizations (flattening subqueries, and strength\n  ** reduction of join operators) in the FROM clause up into the main query\n  */\n#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)\n  for(i=0; !p->pPrior && i<pTabList->nSrc; i++){\n    struct SrcList_item *pItem = &pTabList->a[i];\n    Select *pSub = pItem->pSelect;\n    Table *pTab = pItem->pTab;\n\n    /* Convert LEFT JOIN into JOIN if there are terms of the right table\n    ** of the LEFT JOIN used in the WHERE clause.\n    */\n    if( (pItem->fg.jointype & JT_LEFT)!=0\n     && sqlite3ExprImpliesNonNullRow(p->pWhere, pItem->iCursor)\n     && OptimizationEnabled(db, SQLITE_SimplifyJoin)\n    ){\n      SELECTTRACE(0x100,pParse,p,\n                (\"LEFT-JOIN simplifies to JOIN on term %d\\n\",i));\n      pItem->fg.jointype &= ~(JT_LEFT|JT_OUTER);\n      unsetJoinExpr(p->pWhere, pItem->iCursor);\n    }\n\n    /* No futher action if this term of the FROM clause is no a subquery */\n    if( pSub==0 ) continue;\n\n    /* Catch mismatch in the declared columns of a view and the number of\n    ** columns in the SELECT on the RHS */\n    if( pTab->nCol!=pSub->pEList->nExpr ){\n      sqlite3ErrorMsg(pParse, \"expected %d columns for '%s' but got %d\",\n                      pTab->nCol, pTab->zName, pSub->pEList->nExpr);\n      goto select_end;\n    }\n\n    /* Do not try to flatten an aggregate subquery.\n    **\n    ** Flattening an aggregate subquery is only possible if the outer query\n    ** is not a join.  But if the outer query is not a join, then the subquery\n    ** will be implemented as a co-routine and there is no advantage to\n    ** flattening in that case.\n    */\n    if( (pSub->selFlags & SF_Aggregate)!=0 ) continue;\n    assert( pSub->pGroupBy==0 );\n\n    /* If the outer query contains a \"complex\" result set (that is,\n    ** if the result set of the outer query uses functions or subqueries)\n    ** and if the subquery contains an ORDER BY clause and if\n    ** it will be implemented as a co-routine, then do not flatten.  This\n    ** restriction allows SQL constructs like this:\n    **\n    **  SELECT expensive_function(x)\n    **    FROM (SELECT x FROM tab ORDER BY y LIMIT 10);\n    **\n    ** The expensive_function() is only computed on the 10 rows that\n    ** are output, rather than every row of the table.\n    **\n    ** The requirement that the outer query have a complex result set\n    ** means that flattening does occur on simpler SQL constraints without\n    ** the expensive_function() like:\n    **\n    **  SELECT x FROM (SELECT x FROM tab ORDER BY y LIMIT 10);\n    */\n    if( pSub->pOrderBy!=0\n     && i==0\n     && (p->selFlags & SF_ComplexResult)!=0\n     && (pTabList->nSrc==1\n         || (pTabList->a[1].fg.jointype&(JT_LEFT|JT_CROSS))!=0)\n    ){\n      continue;\n    }\n\n    if( flattenSubquery(pParse, p, i, isAgg) ){\n      if( pParse->nErr ) goto select_end;\n      /* This subquery can be absorbed into its parent. */\n      i = -1;\n    }\n    pTabList = p->pSrc;\n    if( db->mallocFailed ) goto select_end;\n    if( !IgnorableOrderby(pDest) ){\n      sSort.pOrderBy = p->pOrderBy;\n    }\n  }\n#endif\n\n#ifndef SQLITE_OMIT_COMPOUND_SELECT\n  /* Handle compound SELECT statements using the separate multiSelect()\n  ** procedure.\n  */\n  if( p->pPrior ){\n    rc = multiSelect(pParse, p, pDest);\n#if SELECTTRACE_ENABLED\n    SELECTTRACE(0x1,pParse,p,(\"end compound-select processing\\n\"));\n    if( (sqlite3SelectTrace & 0x2000)!=0 && ExplainQueryPlanParent(pParse)==0 ){\n      sqlite3TreeViewSelect(0, p, 0);\n    }\n#endif\n    if( p->pNext==0 ) ExplainQueryPlanPop(pParse);\n    return rc;\n  }\n#endif\n\n  /* Do the WHERE-clause constant propagation optimization if this is\n  ** a join.  No need to speed time on this operation for non-join queries\n  ** as the equivalent optimization will be handled by query planner in\n  ** sqlite3WhereBegin().\n  */\n  if( pTabList->nSrc>1\n   && OptimizationEnabled(db, SQLITE_PropagateConst)\n   && propagateConstants(pParse, p)\n  ){\n#if SELECTTRACE_ENABLED\n    if( sqlite3SelectTrace & 0x100 ){\n      SELECTTRACE(0x100,pParse,p,(\"After constant propagation:\\n\"));\n      sqlite3TreeViewSelect(0, p, 0);\n    }\n#endif\n  }else{\n    SELECTTRACE(0x100,pParse,p,(\"Constant propagation not helpful\\n\"));\n  }\n\n#ifdef SQLITE_COUNTOFVIEW_OPTIMIZATION\n  if( OptimizationEnabled(db, SQLITE_QueryFlattener|SQLITE_CountOfView)\n   && countOfViewOptimization(pParse, p)\n  ){\n    if( db->mallocFailed ) goto select_end;\n    pEList = p->pEList;\n    pTabList = p->pSrc;\n  }\n#endif\n\n  /* For each term in the FROM clause, do two things:\n  ** (1) Authorized unreferenced tables\n  ** (2) Generate code for all sub-queries\n  */\n  for(i=0; i<pTabList->nSrc; i++){\n    struct SrcList_item *pItem = &pTabList->a[i];\n    SelectDest dest;\n    Select *pSub;\n#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)\n    const char *zSavedAuthContext;\n#endif\n\n    /* Issue SQLITE_READ authorizations with a fake column name for any\n    ** tables that are referenced but from which no values are extracted.\n    ** Examples of where these kinds of null SQLITE_READ authorizations\n    ** would occur:\n    **\n    **     SELECT count(*) FROM t1;   -- SQLITE_READ t1.\"\"\n    **     SELECT t1.* FROM t1, t2;   -- SQLITE_READ t2.\"\"\n    **\n    ** The fake column name is an empty string.  It is possible for a table to\n    ** have a column named by the empty string, in which case there is no way to\n    ** distinguish between an unreferenced table and an actual reference to the\n    ** \"\" column. The original design was for the fake column name to be a NULL,\n    ** which would be unambiguous.  But legacy authorization callbacks might\n    ** assume the column name is non-NULL and segfault.  The use of an empty\n    ** string for the fake column name seems safer.\n    */\n    if( pItem->colUsed==0 && pItem->zName!=0 ){\n      sqlite3AuthCheck(pParse, SQLITE_READ, pItem->zName, \"\", pItem->zDatabase);\n    }\n\n#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)\n    /* Generate code for all sub-queries in the FROM clause\n    */\n    pSub = pItem->pSelect;\n    if( pSub==0 ) continue;\n\n    /* The code for a subquery should only be generated once, though it is\n    ** technically harmless for it to be generated multiple times. The\n    ** following assert() will detect if something changes to cause\n    ** the same subquery to be coded multiple times, as a signal to the\n    ** developers to try to optimize the situation.\n    **\n    ** Update 2019-07-24:\n    ** See ticket https://sqlite.org/src/tktview/c52b09c7f38903b1311cec40.\n    ** The dbsqlfuzz fuzzer found a case where the same subquery gets\n    ** coded twice.  So this assert() now becomes a testcase().  It should\n    ** be very rare, though.\n    */\n    testcase( pItem->addrFillSub!=0 );\n\n    /* Increment Parse.nHeight by the height of the largest expression\n    ** tree referred to by this, the parent select. The child select\n    ** may contain expression trees of at most\n    ** (SQLITE_MAX_EXPR_DEPTH-Parse.nHeight) height. This is a bit\n    ** more conservative than necessary, but much easier than enforcing\n    ** an exact limit.\n    */\n    pParse->nHeight += sqlite3SelectExprHeight(p);\n\n    /* Make copies of constant WHERE-clause terms in the outer query down\n    ** inside the subquery.  This can help the subquery to run more efficiently.\n    */\n    if( OptimizationEnabled(db, SQLITE_PushDown)\n     && pushDownWhereTerms(pParse, pSub, p->pWhere, pItem->iCursor,\n                           (pItem->fg.jointype & JT_OUTER)!=0)\n    ){\n#if SELECTTRACE_ENABLED\n      if( sqlite3SelectTrace & 0x100 ){\n        SELECTTRACE(0x100,pParse,p,\n            (\"After WHERE-clause push-down into subquery %d:\\n\", pSub->selId));\n        sqlite3TreeViewSelect(0, p, 0);\n      }\n#endif\n    }else{\n      SELECTTRACE(0x100,pParse,p,(\"Push-down not possible\\n\"));\n    }\n\n    zSavedAuthContext = pParse->zAuthContext;\n    pParse->zAuthContext = pItem->zName;\n\n    /* Generate code to implement the subquery\n    **\n    ** The subquery is implemented as a co-routine if the subquery is\n    ** guaranteed to be the outer loop (so that it does not need to be\n    ** computed more than once)\n    **\n    ** TODO: Are there other reasons beside (1) to use a co-routine\n    ** implementation?\n    */\n    if( i==0\n     && (pTabList->nSrc==1\n            || (pTabList->a[1].fg.jointype&(JT_LEFT|JT_CROSS))!=0)  /* (1) */\n    ){\n      /* Implement a co-routine that will return a single row of the result\n      ** set on each invocation.\n      */\n      int addrTop = sqlite3VdbeCurrentAddr(v)+1;\n     \n      pItem->regReturn = ++pParse->nMem;\n      sqlite3VdbeAddOp3(v, OP_InitCoroutine, pItem->regReturn, 0, addrTop);\n      VdbeComment((v, \"%s\", pItem->pTab->zName));\n      pItem->addrFillSub = addrTop;\n      sqlite3SelectDestInit(&dest, SRT_Coroutine, pItem->regReturn);\n      ExplainQueryPlan((pParse, 1, \"CO-ROUTINE %u\", pSub->selId));\n      sqlite3Select(pParse, pSub, &dest);\n      pItem->pTab->nRowLogEst = pSub->nSelectRow;\n      pItem->fg.viaCoroutine = 1;\n      pItem->regResult = dest.iSdst;\n      sqlite3VdbeEndCoroutine(v, pItem->regReturn);\n      sqlite3VdbeJumpHere(v, addrTop-1);\n      sqlite3ClearTempRegCache(pParse);\n    }else{\n      /* Generate a subroutine that will fill an ephemeral table with\n      ** the content of this subquery.  pItem->addrFillSub will point\n      ** to the address of the generated subroutine.  pItem->regReturn\n      ** is a register allocated to hold the subroutine return address\n      */\n      int topAddr;\n      int onceAddr = 0;\n      int retAddr;\n      struct SrcList_item *pPrior;\n\n      testcase( pItem->addrFillSub==0 ); /* Ticket c52b09c7f38903b1311 */\n      pItem->regReturn = ++pParse->nMem;\n      topAddr = sqlite3VdbeAddOp2(v, OP_Integer, 0, pItem->regReturn);\n      pItem->addrFillSub = topAddr+1;\n      if( pItem->fg.isCorrelated==0 ){\n        /* If the subquery is not correlated and if we are not inside of\n        ** a trigger, then we only need to compute the value of the subquery\n        ** once. */\n        onceAddr = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);\n        VdbeComment((v, \"materialize \\\"%s\\\"\", pItem->pTab->zName));\n      }else{\n        VdbeNoopComment((v, \"materialize \\\"%s\\\"\", pItem->pTab->zName));\n      }\n      pPrior = isSelfJoinView(pTabList, pItem);\n      if( pPrior ){\n        sqlite3VdbeAddOp2(v, OP_OpenDup, pItem->iCursor, pPrior->iCursor);\n        assert( pPrior->pSelect!=0 );\n        pSub->nSelectRow = pPrior->pSelect->nSelectRow;\n      }else{\n        sqlite3SelectDestInit(&dest, SRT_EphemTab, pItem->iCursor);\n        ExplainQueryPlan((pParse, 1, \"MATERIALIZE %u\", pSub->selId));\n        sqlite3Select(pParse, pSub, &dest);\n      }\n      pItem->pTab->nRowLogEst = pSub->nSelectRow;\n      if( onceAddr ) sqlite3VdbeJumpHere(v, onceAddr);\n      retAddr = sqlite3VdbeAddOp1(v, OP_Return, pItem->regReturn);\n      VdbeComment((v, \"end %s\", pItem->pTab->zName));\n      sqlite3VdbeChangeP1(v, topAddr, retAddr);\n      sqlite3ClearTempRegCache(pParse);\n    }\n    if( db->mallocFailed ) goto select_end;\n    pParse->nHeight -= sqlite3SelectExprHeight(p);\n    pParse->zAuthContext = zSavedAuthContext;\n#endif\n  }\n\n  /* Various elements of the SELECT copied into local variables for\n  ** convenience */\n  pEList = p->pEList;\n  pWhere = p->pWhere;\n  pGroupBy = p->pGroupBy;\n  pHaving = p->pHaving;\n  sDistinct.isTnct = (p->selFlags & SF_Distinct)!=0;\n\n#if SELECTTRACE_ENABLED\n  if( sqlite3SelectTrace & 0x400 ){\n    SELECTTRACE(0x400,pParse,p,(\"After all FROM-clause analysis:\\n\"));\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n\n  /* If the query is DISTINCT with an ORDER BY but is not an aggregate, and \n  ** if the select-list is the same as the ORDER BY list, then this query\n  ** can be rewritten as a GROUP BY. In other words, this:\n  **\n  **     SELECT DISTINCT xyz FROM ... ORDER BY xyz\n  **\n  ** is transformed to:\n  **\n  **     SELECT xyz FROM ... GROUP BY xyz ORDER BY xyz\n  **\n  ** The second form is preferred as a single index (or temp-table) may be \n  ** used for both the ORDER BY and DISTINCT processing. As originally \n  ** written the query must use a temp-table for at least one of the ORDER \n  ** BY and DISTINCT, and an index or separate temp-table for the other.\n  */\n  if( (p->selFlags & (SF_Distinct|SF_Aggregate))==SF_Distinct \n   && sqlite3ExprListCompare(sSort.pOrderBy, pEList, -1)==0\n   && p->pWin==0\n  ){\n    p->selFlags &= ~SF_Distinct;\n    pGroupBy = p->pGroupBy = sqlite3ExprListDup(db, pEList, 0);\n    /* Notice that even thought SF_Distinct has been cleared from p->selFlags,\n    ** the sDistinct.isTnct is still set.  Hence, isTnct represents the\n    ** original setting of the SF_Distinct flag, not the current setting */\n    assert( sDistinct.isTnct );\n\n#if SELECTTRACE_ENABLED\n    if( sqlite3SelectTrace & 0x400 ){\n      SELECTTRACE(0x400,pParse,p,(\"Transform DISTINCT into GROUP BY:\\n\"));\n      sqlite3TreeViewSelect(0, p, 0);\n    }\n#endif\n  }\n\n  /* If there is an ORDER BY clause, then create an ephemeral index to\n  ** do the sorting.  But this sorting ephemeral index might end up\n  ** being unused if the data can be extracted in pre-sorted order.\n  ** If that is the case, then the OP_OpenEphemeral instruction will be\n  ** changed to an OP_Noop once we figure out that the sorting index is\n  ** not needed.  The sSort.addrSortIndex variable is used to facilitate\n  ** that change.\n  */\n  if( sSort.pOrderBy ){\n    KeyInfo *pKeyInfo;\n    pKeyInfo = sqlite3KeyInfoFromExprList(\n        pParse, sSort.pOrderBy, 0, pEList->nExpr);\n    sSort.iECursor = pParse->nTab++;\n    sSort.addrSortIndex =\n      sqlite3VdbeAddOp4(v, OP_OpenEphemeral,\n          sSort.iECursor, sSort.pOrderBy->nExpr+1+pEList->nExpr, 0,\n          (char*)pKeyInfo, P4_KEYINFO\n      );\n  }else{\n    sSort.addrSortIndex = -1;\n  }\n\n  /* If the output is destined for a temporary table, open that table.\n  */\n  if( pDest->eDest==SRT_EphemTab ){\n    sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pDest->iSDParm, pEList->nExpr);\n  }\n\n  /* Set the limiter.\n  */\n  iEnd = sqlite3VdbeMakeLabel(pParse);\n  if( (p->selFlags & SF_FixedLimit)==0 ){\n    p->nSelectRow = 320;  /* 4 billion rows */\n  }\n  computeLimitRegisters(pParse, p, iEnd);\n  if( p->iLimit==0 && sSort.addrSortIndex>=0 ){\n    sqlite3VdbeChangeOpcode(v, sSort.addrSortIndex, OP_SorterOpen);\n    sSort.sortFlags |= SORTFLAG_UseSorter;\n  }\n\n  /* Open an ephemeral index to use for the distinct set.\n  */\n  if( p->selFlags & SF_Distinct ){\n    sDistinct.tabTnct = pParse->nTab++;\n    sDistinct.addrTnct = sqlite3VdbeAddOp4(v, OP_OpenEphemeral,\n                       sDistinct.tabTnct, 0, 0,\n                       (char*)sqlite3KeyInfoFromExprList(pParse, p->pEList,0,0),\n                       P4_KEYINFO);\n    sqlite3VdbeChangeP5(v, BTREE_UNORDERED);\n    sDistinct.eTnctType = WHERE_DISTINCT_UNORDERED;\n  }else{\n    sDistinct.eTnctType = WHERE_DISTINCT_NOOP;\n  }\n\n  if( !isAgg && pGroupBy==0 ){\n    /* No aggregate functions and no GROUP BY clause */\n    u16 wctrlFlags = (sDistinct.isTnct ? WHERE_WANT_DISTINCT : 0)\n                   | (p->selFlags & SF_FixedLimit);\n#ifndef SQLITE_OMIT_WINDOWFUNC\n    Window *pWin = p->pWin;      /* Master window object (or NULL) */\n    if( pWin ){\n      sqlite3WindowCodeInit(pParse, pWin);\n    }\n#endif\n    assert( WHERE_USE_LIMIT==SF_FixedLimit );\n\n\n    /* Begin the database scan. */\n    SELECTTRACE(1,pParse,p,(\"WhereBegin\\n\"));\n    pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, sSort.pOrderBy,\n                               p->pEList, wctrlFlags, p->nSelectRow);\n    if( pWInfo==0 ) goto select_end;\n    if( sqlite3WhereOutputRowCount(pWInfo) < p->nSelectRow ){\n      p->nSelectRow = sqlite3WhereOutputRowCount(pWInfo);\n    }\n    if( sDistinct.isTnct && sqlite3WhereIsDistinct(pWInfo) ){\n      sDistinct.eTnctType = sqlite3WhereIsDistinct(pWInfo);\n    }\n    if( sSort.pOrderBy ){\n      sSort.nOBSat = sqlite3WhereIsOrdered(pWInfo);\n      sSort.labelOBLopt = sqlite3WhereOrderByLimitOptLabel(pWInfo);\n      if( sSort.nOBSat==sSort.pOrderBy->nExpr ){\n        sSort.pOrderBy = 0;\n      }\n    }\n\n    /* If sorting index that was created by a prior OP_OpenEphemeral \n    ** instruction ended up not being needed, then change the OP_OpenEphemeral\n    ** into an OP_Noop.\n    */\n    if( sSort.addrSortIndex>=0 && sSort.pOrderBy==0 ){\n      sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex);\n    }\n\n    assert( p->pEList==pEList );\n#ifndef SQLITE_OMIT_WINDOWFUNC\n    if( pWin ){\n      int addrGosub = sqlite3VdbeMakeLabel(pParse);\n      int iCont = sqlite3VdbeMakeLabel(pParse);\n      int iBreak = sqlite3VdbeMakeLabel(pParse);\n      int regGosub = ++pParse->nMem;\n\n      sqlite3WindowCodeStep(pParse, p, pWInfo, regGosub, addrGosub);\n\n      sqlite3VdbeAddOp2(v, OP_Goto, 0, iBreak);\n      sqlite3VdbeResolveLabel(v, addrGosub);\n      VdbeNoopComment((v, \"inner-loop subroutine\"));\n      sSort.labelOBLopt = 0;\n      selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest, iCont, iBreak);\n      sqlite3VdbeResolveLabel(v, iCont);\n      sqlite3VdbeAddOp1(v, OP_Return, regGosub);\n      VdbeComment((v, \"end inner-loop subroutine\"));\n      sqlite3VdbeResolveLabel(v, iBreak);\n    }else\n#endif /* SQLITE_OMIT_WINDOWFUNC */\n    {\n      /* Use the standard inner loop. */\n      selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest,\n          sqlite3WhereContinueLabel(pWInfo),\n          sqlite3WhereBreakLabel(pWInfo));\n\n      /* End the database scan loop.\n      */\n      sqlite3WhereEnd(pWInfo);\n    }\n  }else{\n    /* This case when there exist aggregate functions or a GROUP BY clause\n    ** or both */\n    NameContext sNC;    /* Name context for processing aggregate information */\n    int iAMem;          /* First Mem address for storing current GROUP BY */\n    int iBMem;          /* First Mem address for previous GROUP BY */\n    int iUseFlag;       /* Mem address holding flag indicating that at least\n                        ** one row of the input to the aggregator has been\n                        ** processed */\n    int iAbortFlag;     /* Mem address which causes query abort if positive */\n    int groupBySort;    /* Rows come from source in GROUP BY order */\n    int addrEnd;        /* End of processing for this SELECT */\n    int sortPTab = 0;   /* Pseudotable used to decode sorting results */\n    int sortOut = 0;    /* Output register from the sorter */\n    int orderByGrp = 0; /* True if the GROUP BY and ORDER BY are the same */\n\n    /* Remove any and all aliases between the result set and the\n    ** GROUP BY clause.\n    */\n    if( pGroupBy ){\n      int k;                        /* Loop counter */\n      struct ExprList_item *pItem;  /* For looping over expression in a list */\n\n      for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++){\n        pItem->u.x.iAlias = 0;\n      }\n      for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++){\n        pItem->u.x.iAlias = 0;\n      }\n      assert( 66==sqlite3LogEst(100) );\n      if( p->nSelectRow>66 ) p->nSelectRow = 66;\n\n      /* If there is both a GROUP BY and an ORDER BY clause and they are\n      ** identical, then it may be possible to disable the ORDER BY clause \n      ** on the grounds that the GROUP BY will cause elements to come out \n      ** in the correct order. It also may not - the GROUP BY might use a\n      ** database index that causes rows to be grouped together as required\n      ** but not actually sorted. Either way, record the fact that the\n      ** ORDER BY and GROUP BY clauses are the same by setting the orderByGrp\n      ** variable.  */\n      if( sSort.pOrderBy && pGroupBy->nExpr==sSort.pOrderBy->nExpr ){\n        int ii;\n        /* The GROUP BY processing doesn't care whether rows are delivered in\n        ** ASC or DESC order - only that each group is returned contiguously.\n        ** So set the ASC/DESC flags in the GROUP BY to match those in the \n        ** ORDER BY to maximize the chances of rows being delivered in an \n        ** order that makes the ORDER BY redundant.  */\n        for(ii=0; ii<pGroupBy->nExpr; ii++){\n          u8 sortFlags = sSort.pOrderBy->a[ii].sortFlags & KEYINFO_ORDER_DESC;\n          pGroupBy->a[ii].sortFlags = sortFlags;\n        }\n        if( sqlite3ExprListCompare(pGroupBy, sSort.pOrderBy, -1)==0 ){\n          orderByGrp = 1;\n        }\n      }\n    }else{\n      assert( 0==sqlite3LogEst(1) );\n      p->nSelectRow = 0;\n    }\n\n    /* Create a label to jump to when we want to abort the query */\n    addrEnd = sqlite3VdbeMakeLabel(pParse);\n\n    /* Convert TK_COLUMN nodes into TK_AGG_COLUMN and make entries in\n    ** sAggInfo for all TK_AGG_FUNCTION nodes in expressions of the\n    ** SELECT statement.\n    */\n    memset(&sNC, 0, sizeof(sNC));\n    sNC.pParse = pParse;\n    sNC.pSrcList = pTabList;\n    sNC.uNC.pAggInfo = &sAggInfo;\n    VVA_ONLY( sNC.ncFlags = NC_UAggInfo; )\n    sAggInfo.mnReg = pParse->nMem+1;\n    sAggInfo.nSortingColumn = pGroupBy ? pGroupBy->nExpr : 0;\n    sAggInfo.pGroupBy = pGroupBy;\n    sqlite3ExprAnalyzeAggList(&sNC, pEList);\n    sqlite3ExprAnalyzeAggList(&sNC, sSort.pOrderBy);\n    if( pHaving ){\n      if( pGroupBy ){\n        assert( pWhere==p->pWhere );\n        assert( pHaving==p->pHaving );\n        assert( pGroupBy==p->pGroupBy );\n        havingToWhere(pParse, p);\n        pWhere = p->pWhere;\n      }\n      sqlite3ExprAnalyzeAggregates(&sNC, pHaving);\n    }\n    sAggInfo.nAccumulator = sAggInfo.nColumn;\n    if( p->pGroupBy==0 && p->pHaving==0 && sAggInfo.nFunc==1 ){\n      minMaxFlag = minMaxQuery(db, sAggInfo.aFunc[0].pExpr, &pMinMaxOrderBy);\n    }else{\n      minMaxFlag = WHERE_ORDERBY_NORMAL;\n    }\n    for(i=0; i<sAggInfo.nFunc; i++){\n      Expr *pExpr = sAggInfo.aFunc[i].pExpr;\n      assert( !ExprHasProperty(pExpr, EP_xIsSelect) );\n      sNC.ncFlags |= NC_InAggFunc;\n      sqlite3ExprAnalyzeAggList(&sNC, pExpr->x.pList);\n#ifndef SQLITE_OMIT_WINDOWFUNC\n      assert( !IsWindowFunc(pExpr) );\n      if( ExprHasProperty(pExpr, EP_WinFunc) ){\n        sqlite3ExprAnalyzeAggregates(&sNC, pExpr->y.pWin->pFilter);\n      }\n#endif\n      sNC.ncFlags &= ~NC_InAggFunc;\n    }\n    sAggInfo.mxReg = pParse->nMem;\n    if( db->mallocFailed ) goto select_end;\n#if SELECTTRACE_ENABLED\n    if( sqlite3SelectTrace & 0x400 ){\n      int ii;\n      SELECTTRACE(0x400,pParse,p,(\"After aggregate analysis:\\n\"));\n      sqlite3TreeViewSelect(0, p, 0);\n      for(ii=0; ii<sAggInfo.nColumn; ii++){\n        sqlite3DebugPrintf(\"agg-column[%d] iMem=%d\\n\",\n            ii, sAggInfo.aCol[ii].iMem);\n        sqlite3TreeViewExpr(0, sAggInfo.aCol[ii].pExpr, 0);\n      }\n      for(ii=0; ii<sAggInfo.nFunc; ii++){\n        sqlite3DebugPrintf(\"agg-func[%d]: iMem=%d\\n\",\n            ii, sAggInfo.aFunc[ii].iMem);\n        sqlite3TreeViewExpr(0, sAggInfo.aFunc[ii].pExpr, 0);\n      }\n    }\n#endif\n\n\n    /* Processing for aggregates with GROUP BY is very different and\n    ** much more complex than aggregates without a GROUP BY.\n    */\n    if( pGroupBy ){\n      KeyInfo *pKeyInfo;  /* Keying information for the group by clause */\n      int addr1;          /* A-vs-B comparision jump */\n      int addrOutputRow;  /* Start of subroutine that outputs a result row */\n      int regOutputRow;   /* Return address register for output subroutine */\n      int addrSetAbort;   /* Set the abort flag and return */\n      int addrTopOfLoop;  /* Top of the input loop */\n      int addrSortingIdx; /* The OP_OpenEphemeral for the sorting index */\n      int addrReset;      /* Subroutine for resetting the accumulator */\n      int regReset;       /* Return address register for reset subroutine */\n\n      /* If there is a GROUP BY clause we might need a sorting index to\n      ** implement it.  Allocate that sorting index now.  If it turns out\n      ** that we do not need it after all, the OP_SorterOpen instruction\n      ** will be converted into a Noop.  \n      */\n      sAggInfo.sortingIdx = pParse->nTab++;\n      pKeyInfo = sqlite3KeyInfoFromExprList(pParse,pGroupBy,0,sAggInfo.nColumn);\n      addrSortingIdx = sqlite3VdbeAddOp4(v, OP_SorterOpen, \n          sAggInfo.sortingIdx, sAggInfo.nSortingColumn, \n          0, (char*)pKeyInfo, P4_KEYINFO);\n\n      /* Initialize memory locations used by GROUP BY aggregate processing\n      */\n      iUseFlag = ++pParse->nMem;\n      iAbortFlag = ++pParse->nMem;\n      regOutputRow = ++pParse->nMem;\n      addrOutputRow = sqlite3VdbeMakeLabel(pParse);\n      regReset = ++pParse->nMem;\n      addrReset = sqlite3VdbeMakeLabel(pParse);\n      iAMem = pParse->nMem + 1;\n      pParse->nMem += pGroupBy->nExpr;\n      iBMem = pParse->nMem + 1;\n      pParse->nMem += pGroupBy->nExpr;\n      sqlite3VdbeAddOp2(v, OP_Integer, 0, iAbortFlag);\n      VdbeComment((v, \"clear abort flag\"));\n      sqlite3VdbeAddOp3(v, OP_Null, 0, iAMem, iAMem+pGroupBy->nExpr-1);\n\n      /* Begin a loop that will extract all source rows in GROUP BY order.\n      ** This might involve two separate loops with an OP_Sort in between, or\n      ** it might be a single loop that uses an index to extract information\n      ** in the right order to begin with.\n      */\n      sqlite3VdbeAddOp2(v, OP_Gosub, regReset, addrReset);\n      SELECTTRACE(1,pParse,p,(\"WhereBegin\\n\"));\n      pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pGroupBy, 0,\n          WHERE_GROUPBY | (orderByGrp ? WHERE_SORTBYGROUP : 0), 0\n      );\n      if( pWInfo==0 ) goto select_end;\n      if( sqlite3WhereIsOrdered(pWInfo)==pGroupBy->nExpr ){\n        /* The optimizer is able to deliver rows in group by order so\n        ** we do not have to sort.  The OP_OpenEphemeral table will be\n        ** cancelled later because we still need to use the pKeyInfo\n        */\n        groupBySort = 0;\n      }else{\n        /* Rows are coming out in undetermined order.  We have to push\n        ** each row into a sorting index, terminate the first loop,\n        ** then loop over the sorting index in order to get the output\n        ** in sorted order\n        */\n        int regBase;\n        int regRecord;\n        int nCol;\n        int nGroupBy;\n\n        explainTempTable(pParse, \n            (sDistinct.isTnct && (p->selFlags&SF_Distinct)==0) ?\n                    \"DISTINCT\" : \"GROUP BY\");\n\n        groupBySort = 1;\n        nGroupBy = pGroupBy->nExpr;\n        nCol = nGroupBy;\n        j = nGroupBy;\n        for(i=0; i<sAggInfo.nColumn; i++){\n          if( sAggInfo.aCol[i].iSorterColumn>=j ){\n            nCol++;\n            j++;\n          }\n        }\n        regBase = sqlite3GetTempRange(pParse, nCol);\n        sqlite3ExprCodeExprList(pParse, pGroupBy, regBase, 0, 0);\n        j = nGroupBy;\n        for(i=0; i<sAggInfo.nColumn; i++){\n          struct AggInfo_col *pCol = &sAggInfo.aCol[i];\n          if( pCol->iSorterColumn>=j ){\n            int r1 = j + regBase;\n            sqlite3ExprCodeGetColumnOfTable(v,\n                               pCol->pTab, pCol->iTable, pCol->iColumn, r1);\n            j++;\n          }\n        }\n        regRecord = sqlite3GetTempReg(pParse);\n        sqlite3VdbeAddOp3(v, OP_MakeRecord, regBase, nCol, regRecord);\n        sqlite3VdbeAddOp2(v, OP_SorterInsert, sAggInfo.sortingIdx, regRecord);\n        sqlite3ReleaseTempReg(pParse, regRecord);\n        sqlite3ReleaseTempRange(pParse, regBase, nCol);\n        sqlite3WhereEnd(pWInfo);\n        sAggInfo.sortingIdxPTab = sortPTab = pParse->nTab++;\n        sortOut = sqlite3GetTempReg(pParse);\n        sqlite3VdbeAddOp3(v, OP_OpenPseudo, sortPTab, sortOut, nCol);\n        sqlite3VdbeAddOp2(v, OP_SorterSort, sAggInfo.sortingIdx, addrEnd);\n        VdbeComment((v, \"GROUP BY sort\")); VdbeCoverage(v);\n        sAggInfo.useSortingIdx = 1;\n      }\n\n      /* If the index or temporary table used by the GROUP BY sort\n      ** will naturally deliver rows in the order required by the ORDER BY\n      ** clause, cancel the ephemeral table open coded earlier.\n      **\n      ** This is an optimization - the correct answer should result regardless.\n      ** Use the SQLITE_GroupByOrder flag with SQLITE_TESTCTRL_OPTIMIZER to \n      ** disable this optimization for testing purposes.  */\n      if( orderByGrp && OptimizationEnabled(db, SQLITE_GroupByOrder) \n       && (groupBySort || sqlite3WhereIsSorted(pWInfo))\n      ){\n        sSort.pOrderBy = 0;\n        sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex);\n      }\n\n      /* Evaluate the current GROUP BY terms and store in b0, b1, b2...\n      ** (b0 is memory location iBMem+0, b1 is iBMem+1, and so forth)\n      ** Then compare the current GROUP BY terms against the GROUP BY terms\n      ** from the previous row currently stored in a0, a1, a2...\n      */\n      addrTopOfLoop = sqlite3VdbeCurrentAddr(v);\n      if( groupBySort ){\n        sqlite3VdbeAddOp3(v, OP_SorterData, sAggInfo.sortingIdx,\n                          sortOut, sortPTab);\n      }\n      for(j=0; j<pGroupBy->nExpr; j++){\n        if( groupBySort ){\n          sqlite3VdbeAddOp3(v, OP_Column, sortPTab, j, iBMem+j);\n        }else{\n          sAggInfo.directMode = 1;\n          sqlite3ExprCode(pParse, pGroupBy->a[j].pExpr, iBMem+j);\n        }\n      }\n      sqlite3VdbeAddOp4(v, OP_Compare, iAMem, iBMem, pGroupBy->nExpr,\n                          (char*)sqlite3KeyInfoRef(pKeyInfo), P4_KEYINFO);\n      addr1 = sqlite3VdbeCurrentAddr(v);\n      sqlite3VdbeAddOp3(v, OP_Jump, addr1+1, 0, addr1+1); VdbeCoverage(v);\n\n      /* Generate code that runs whenever the GROUP BY changes.\n      ** Changes in the GROUP BY are detected by the previous code\n      ** block.  If there were no changes, this block is skipped.\n      **\n      ** This code copies current group by terms in b0,b1,b2,...\n      ** over to a0,a1,a2.  It then calls the output subroutine\n      ** and resets the aggregate accumulator registers in preparation\n      ** for the next GROUP BY batch.\n      */\n      sqlite3ExprCodeMove(pParse, iBMem, iAMem, pGroupBy->nExpr);\n      sqlite3VdbeAddOp2(v, OP_Gosub, regOutputRow, addrOutputRow);\n      VdbeComment((v, \"output one row\"));\n      sqlite3VdbeAddOp2(v, OP_IfPos, iAbortFlag, addrEnd); VdbeCoverage(v);\n      VdbeComment((v, \"check abort flag\"));\n      sqlite3VdbeAddOp2(v, OP_Gosub, regReset, addrReset);\n      VdbeComment((v, \"reset accumulator\"));\n\n      /* Update the aggregate accumulators based on the content of\n      ** the current row\n      */\n      sqlite3VdbeJumpHere(v, addr1);\n      updateAccumulator(pParse, iUseFlag, &sAggInfo);\n      sqlite3VdbeAddOp2(v, OP_Integer, 1, iUseFlag);\n      VdbeComment((v, \"indicate data in accumulator\"));\n\n      /* End of the loop\n      */\n      if( groupBySort ){\n        sqlite3VdbeAddOp2(v, OP_SorterNext, sAggInfo.sortingIdx, addrTopOfLoop);\n        VdbeCoverage(v);\n      }else{\n        sqlite3WhereEnd(pWInfo);\n        sqlite3VdbeChangeToNoop(v, addrSortingIdx);\n      }\n\n      /* Output the final row of result\n      */\n      sqlite3VdbeAddOp2(v, OP_Gosub, regOutputRow, addrOutputRow);\n      VdbeComment((v, \"output final row\"));\n\n      /* Jump over the subroutines\n      */\n      sqlite3VdbeGoto(v, addrEnd);\n\n      /* Generate a subroutine that outputs a single row of the result\n      ** set.  This subroutine first looks at the iUseFlag.  If iUseFlag\n      ** is less than or equal to zero, the subroutine is a no-op.  If\n      ** the processing calls for the query to abort, this subroutine\n      ** increments the iAbortFlag memory location before returning in\n      ** order to signal the caller to abort.\n      */\n      addrSetAbort = sqlite3VdbeCurrentAddr(v);\n      sqlite3VdbeAddOp2(v, OP_Integer, 1, iAbortFlag);\n      VdbeComment((v, \"set abort flag\"));\n      sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);\n      sqlite3VdbeResolveLabel(v, addrOutputRow);\n      addrOutputRow = sqlite3VdbeCurrentAddr(v);\n      sqlite3VdbeAddOp2(v, OP_IfPos, iUseFlag, addrOutputRow+2);\n      VdbeCoverage(v);\n      VdbeComment((v, \"Groupby result generator entry point\"));\n      sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);\n      finalizeAggFunctions(pParse, &sAggInfo);\n      sqlite3ExprIfFalse(pParse, pHaving, addrOutputRow+1, SQLITE_JUMPIFNULL);\n      selectInnerLoop(pParse, p, -1, &sSort,\n                      &sDistinct, pDest,\n                      addrOutputRow+1, addrSetAbort);\n      sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);\n      VdbeComment((v, \"end groupby result generator\"));\n\n      /* Generate a subroutine that will reset the group-by accumulator\n      */\n      sqlite3VdbeResolveLabel(v, addrReset);\n      resetAccumulator(pParse, &sAggInfo);\n      sqlite3VdbeAddOp2(v, OP_Integer, 0, iUseFlag);\n      VdbeComment((v, \"indicate accumulator empty\"));\n      sqlite3VdbeAddOp1(v, OP_Return, regReset);\n     \n    } /* endif pGroupBy.  Begin aggregate queries without GROUP BY: */\n    else {\n#ifndef SQLITE_OMIT_BTREECOUNT\n      Table *pTab;\n      if( (pTab = isSimpleCount(p, &sAggInfo))!=0 ){\n        /* If isSimpleCount() returns a pointer to a Table structure, then\n        ** the SQL statement is of the form:\n        **\n        **   SELECT count(*) FROM <tbl>\n        **\n        ** where the Table structure returned represents table <tbl>.\n        **\n        ** This statement is so common that it is optimized specially. The\n        ** OP_Count instruction is executed either on the intkey table that\n        ** contains the data for table <tbl> or on one of its indexes. It\n        ** is better to execute the op on an index, as indexes are almost\n        ** always spread across less pages than their corresponding tables.\n        */\n        const int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n        const int iCsr = pParse->nTab++;     /* Cursor to scan b-tree */\n        Index *pIdx;                         /* Iterator variable */\n        KeyInfo *pKeyInfo = 0;               /* Keyinfo for scanned index */\n        Index *pBest = 0;                    /* Best index found so far */\n        int iRoot = pTab->tnum;              /* Root page of scanned b-tree */\n\n        sqlite3CodeVerifySchema(pParse, iDb);\n        sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);\n\n        /* Search for the index that has the lowest scan cost.\n        **\n        ** (2011-04-15) Do not do a full scan of an unordered index.\n        **\n        ** (2013-10-03) Do not count the entries in a partial index.\n        **\n        ** In practice the KeyInfo structure will not be used. It is only \n        ** passed to keep OP_OpenRead happy.\n        */\n        if( !HasRowid(pTab) ) pBest = sqlite3PrimaryKeyIndex(pTab);\n        for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n          if( pIdx->bUnordered==0\n           && pIdx->szIdxRow<pTab->szTabRow\n           && pIdx->pPartIdxWhere==0\n           && (!pBest || pIdx->szIdxRow<pBest->szIdxRow)\n          ){\n            pBest = pIdx;\n          }\n        }\n        if( pBest ){\n          iRoot = pBest->tnum;\n          pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pBest);\n        }\n\n        /* Open a read-only cursor, execute the OP_Count, close the cursor. */\n        sqlite3VdbeAddOp4Int(v, OP_OpenRead, iCsr, iRoot, iDb, 1);\n        if( pKeyInfo ){\n          sqlite3VdbeChangeP4(v, -1, (char *)pKeyInfo, P4_KEYINFO);\n        }\n        sqlite3VdbeAddOp2(v, OP_Count, iCsr, sAggInfo.aFunc[0].iMem);\n        sqlite3VdbeAddOp1(v, OP_Close, iCsr);\n        explainSimpleCount(pParse, pTab, pBest);\n      }else\n#endif /* SQLITE_OMIT_BTREECOUNT */\n      {\n        int regAcc = 0;           /* \"populate accumulators\" flag */\n\n        /* If there are accumulator registers but no min() or max() functions\n        ** without FILTER clauses, allocate register regAcc. Register regAcc\n        ** will contain 0 the first time the inner loop runs, and 1 thereafter.\n        ** The code generated by updateAccumulator() uses this to ensure\n        ** that the accumulator registers are (a) updated only once if\n        ** there are no min() or max functions or (b) always updated for the\n        ** first row visited by the aggregate, so that they are updated at\n        ** least once even if the FILTER clause means the min() or max() \n        ** function visits zero rows.  */\n        if( sAggInfo.nAccumulator ){\n          for(i=0; i<sAggInfo.nFunc; i++){\n            if( ExprHasProperty(sAggInfo.aFunc[i].pExpr, EP_WinFunc) ) continue;\n            if( sAggInfo.aFunc[i].pFunc->funcFlags&SQLITE_FUNC_NEEDCOLL ) break;\n          }\n          if( i==sAggInfo.nFunc ){\n            regAcc = ++pParse->nMem;\n            sqlite3VdbeAddOp2(v, OP_Integer, 0, regAcc);\n          }\n        }\n\n        /* This case runs if the aggregate has no GROUP BY clause.  The\n        ** processing is much simpler since there is only a single row\n        ** of output.\n        */\n        assert( p->pGroupBy==0 );\n        resetAccumulator(pParse, &sAggInfo);\n\n        /* If this query is a candidate for the min/max optimization, then\n        ** minMaxFlag will have been previously set to either\n        ** WHERE_ORDERBY_MIN or WHERE_ORDERBY_MAX and pMinMaxOrderBy will\n        ** be an appropriate ORDER BY expression for the optimization.\n        */\n        assert( minMaxFlag==WHERE_ORDERBY_NORMAL || pMinMaxOrderBy!=0 );\n        assert( pMinMaxOrderBy==0 || pMinMaxOrderBy->nExpr==1 );\n\n        SELECTTRACE(1,pParse,p,(\"WhereBegin\\n\"));\n        pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pMinMaxOrderBy,\n                                   0, minMaxFlag, 0);\n        if( pWInfo==0 ){\n          goto select_end;\n        }\n        updateAccumulator(pParse, regAcc, &sAggInfo);\n        if( regAcc ) sqlite3VdbeAddOp2(v, OP_Integer, 1, regAcc);\n        if( sqlite3WhereIsOrdered(pWInfo)>0 ){\n          sqlite3VdbeGoto(v, sqlite3WhereBreakLabel(pWInfo));\n          VdbeComment((v, \"%s() by index\",\n                (minMaxFlag==WHERE_ORDERBY_MIN?\"min\":\"max\")));\n        }\n        sqlite3WhereEnd(pWInfo);\n        finalizeAggFunctions(pParse, &sAggInfo);\n      }\n\n      sSort.pOrderBy = 0;\n      sqlite3ExprIfFalse(pParse, pHaving, addrEnd, SQLITE_JUMPIFNULL);\n      selectInnerLoop(pParse, p, -1, 0, 0, \n                      pDest, addrEnd, addrEnd);\n    }\n    sqlite3VdbeResolveLabel(v, addrEnd);\n    \n  } /* endif aggregate query */\n\n  if( sDistinct.eTnctType==WHERE_DISTINCT_UNORDERED ){\n    explainTempTable(pParse, \"DISTINCT\");\n  }\n\n  /* If there is an ORDER BY clause, then we need to sort the results\n  ** and send them to the callback one by one.\n  */\n  if( sSort.pOrderBy ){\n    explainTempTable(pParse,\n                     sSort.nOBSat>0 ? \"RIGHT PART OF ORDER BY\":\"ORDER BY\");\n    assert( p->pEList==pEList );\n    generateSortTail(pParse, p, &sSort, pEList->nExpr, pDest);\n  }\n\n  /* Jump here to skip this query\n  */\n  sqlite3VdbeResolveLabel(v, iEnd);\n\n  /* The SELECT has been coded. If there is an error in the Parse structure,\n  ** set the return code to 1. Otherwise 0. */\n  rc = (pParse->nErr>0);\n\n  /* Control jumps to here if an error is encountered above, or upon\n  ** successful coding of the SELECT.\n  */\nselect_end:\n  sqlite3ExprListDelete(db, pMinMaxOrderBy);\n  sqlite3DbFree(db, sAggInfo.aCol);\n  sqlite3DbFree(db, sAggInfo.aFunc);\n#if SELECTTRACE_ENABLED\n  SELECTTRACE(0x1,pParse,p,(\"end processing\\n\"));\n  if( (sqlite3SelectTrace & 0x2000)!=0 && ExplainQueryPlanParent(pParse)==0 ){\n    sqlite3TreeViewSelect(0, p, 0);\n  }\n#endif\n  ExplainQueryPlanPop(pParse);\n  return rc;\n}\n"], "filenames": ["manifest", "manifest.uuid", "src/select.c"], "buggy_code_start_loc": [1, 1, 2811], "buggy_code_end_loc": [1859, 2, 2811], "fixing_code_start_loc": [1, 1, 2812], "fixing_code_end_loc": [1859, 2, 2813], "type": "CWE-476", "message": "multiSelect in select.c in SQLite 3.30.1 mishandles certain errors during parsing, as demonstrated by errors from sqlite3WindowRewrite() calls. NOTE: this vulnerability exists because of an incomplete fix for CVE-2019-19880.", "other": {"cve": {"id": "CVE-2019-19926", "sourceIdentifier": "cve@mitre.org", "published": "2019-12-23T01:15:13.380", "lastModified": "2022-04-15T16:17:32.953", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "multiSelect in select.c in SQLite 3.30.1 mishandles certain errors during parsing, as demonstrated by errors from sqlite3WindowRewrite() calls. NOTE: this vulnerability exists because of an incomplete fix for CVE-2019-19880."}, {"lang": "es", "value": "La funci\u00f3n multiSelect en el archivo select.c en SQLite versi\u00f3n 3.30.1, maneja inapropiadamente determinados errores durante el an\u00e1lisis, como es demostrado por los errores de las llamadas de sqlite3WindowRewrite(). NOTA: esta vulnerabilidad se presenta debido a una correcci\u00f3n incompleta para CVE-2019-19880."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sqlite:sqlite:3.30.1:*:*:*:*:*:*:*", "matchCriteriaId": "0175D7DA-13DD-44A4-91BB-77489F76C878"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:siemens:sinec_infrastructure_network_services:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.1.1", "matchCriteriaId": "B0F46497-4AB0-49A7-9453-CC26837BF253"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:mysql_workbench:*:*:*:*:*:*:*:*", "versionEndIncluding": "8.0.19", "matchCriteriaId": "7B4DA1DD-9BC1-4D76-BB41-6E6D69838571"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "EE249E1B-A1FD-4E08-AA71-A0E1F10FFE97"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "9BBCD86A-E6C7-4444-9D74-F861084090F0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "E5ED5807-55B7-47C5-97A6-03233F4FBC3A"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opensuse:backports_sle:15.0:sp1:*:*:*:*:*:*", "matchCriteriaId": "40513095-7E6E-46B3-B604-C926F1BA3568"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:suse:package_hub:-:*:*:*:*:*:*:*", "matchCriteriaId": "284A8DA0-317B-4BBE-AECB-7E91BBF0DD3B"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:suse:linux_enterprise:12.0:*:*:*:*:*:*:*", "matchCriteriaId": "CBC8B78D-1131-4F21-919D-8AC79A410FB9"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:cloud_backup:-:*:*:*:*:*:*:*", "matchCriteriaId": "5C2089EE-5D7F-47EC-8EA5-0F69790564C4"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-02/msg00010.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-02/msg00015.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-02/msg00025.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2020:0514", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://cert-portal.siemens.com/productcert/pdf/ssa-389290.pdf", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/sqlite/sqlite/commit/8428b3b437569338a9d1e10c4cd8154acbe33089", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20200114-0003/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4298-1/", "source": "cve@mitre.org", "tags": ["Broken Link"]}, {"url": "https://usn.ubuntu.com/4298-2/", "source": "cve@mitre.org", "tags": ["Broken Link"]}, {"url": "https://www.debian.org/security/2020/dsa-4638", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuapr2020.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/sqlite/sqlite/commit/8428b3b437569338a9d1e10c4cd8154acbe33089"}}