{"buggy_code": ["//===----------------------------------------------------------------------===//\n//\n// This source file is part of the APNSwift open source project\n//\n// Copyright (c) 2019 the APNSwift project authors\n// Licensed under Apache License v2.0\n//\n// See LICENSE.txt for license information\n// See CONTRIBUTORS.txt for the list of APNSwift project authors\n//\n// SPDX-License-Identifier: Apache-2.0\n//\n//===----------------------------------------------------------------------===//\n\nimport Foundation\nimport CAPNSOpenSSL\nimport NIO\n\npublic struct APNSwiftSigner {\n    private let buffer: ByteBuffer\n    public init(buffer: ByteBuffer) throws {\n        self.buffer = buffer\n    }\n\n    // this is a blocking init and should be done at the start of application not on an event loop.\n    public init(filePath: String) throws {\n        guard let data = try? Data(contentsOf: URL(fileURLWithPath: filePath)) else {\n            throw APNSwiftError.SigningError.certificateFileDoesNotExist\n        }\n        var mutableByteBuffer = ByteBufferAllocator().buffer(capacity: data.count)\n        mutableByteBuffer.writeBytes(data)\n        self.buffer = mutableByteBuffer\n    }\n\n    internal func sign(digest: ByteBuffer) throws -> ByteBuffer {\n        let bio = BIO_new(BIO_s_mem())\n        defer { BIO_free(bio) }\n        let res = buffer.withUnsafeReadableBytes { ptr in\n            Int(BIO_puts(bio, ptr.baseAddress?.assumingMemoryBound(to: Int8.self)))\n        }\n        assert(res >= 0, \"BIO_puts failed\")\n\n        guard let opaquePointer = OpaquePointer.make(optional: PEM_read_bio_ECPrivateKey(bio!, nil, nil, nil)) else {\n            throw APNSwiftError.SigningError.invalidAuthKey\n        }\n        defer { EC_KEY_free(opaquePointer) }\n        \n        let sig = digest.withUnsafeReadableBytes { ptr in\n            ECDSA_do_sign(ptr.baseAddress?.assumingMemoryBound(to: UInt8.self), Int32(digest.readableBytes), opaquePointer)\n        }\n        defer { ECDSA_SIG_free(sig) }\n\n        var derEncodedSignature: UnsafeMutablePointer<UInt8>?\n        let derLength = i2d_ECDSA_SIG(sig, &derEncodedSignature)\n        guard let derCopy = derEncodedSignature, derLength > 0 else {\n            throw APNSwiftError.SigningError.invalidASN1\n        }\n\n        var derBytes = ByteBufferAllocator().buffer(capacity: Int(derLength))\n        for b in 0 ..< Int(derLength) {\n            derBytes.writeBytes([derCopy[b]])\n        }\n\n        return derBytes\n    }\n}\n"], "fixing_code": ["//===----------------------------------------------------------------------===//\n//\n// This source file is part of the APNSwift open source project\n//\n// Copyright (c) 2019 the APNSwift project authors\n// Licensed under Apache License v2.0\n//\n// See LICENSE.txt for license information\n// See CONTRIBUTORS.txt for the list of APNSwift project authors\n//\n// SPDX-License-Identifier: Apache-2.0\n//\n//===----------------------------------------------------------------------===//\n\nimport Foundation\nimport CAPNSOpenSSL\nimport NIO\n\npublic struct APNSwiftSigner {\n    private let buffer: ByteBuffer\n    public init(buffer: ByteBuffer) throws {\n        self.buffer = buffer\n    }\n\n    // this is a blocking init and should be done at the start of application not on an event loop.\n    public init(filePath: String) throws {\n        guard let data = try? Data(contentsOf: URL(fileURLWithPath: filePath)) else {\n            throw APNSwiftError.SigningError.certificateFileDoesNotExist\n        }\n        var mutableByteBuffer = ByteBufferAllocator().buffer(capacity: data.count)\n        mutableByteBuffer.writeBytes(data)\n        self.buffer = mutableByteBuffer\n    }\n\n    internal func sign(digest: ByteBuffer) throws -> ByteBuffer {\n        let bio = BIO_new(BIO_s_mem())\n        defer { BIO_free(bio) }\n        let res = buffer.withUnsafeReadableBytes { ptr in\n            BIO_write(bio, ptr.baseAddress, CInt(ptr.count))\n        }\n        assert(res >= 0, \"BIO_write failed\")\n\n        guard let opaquePointer = OpaquePointer.make(optional: PEM_read_bio_ECPrivateKey(bio!, nil, nil, nil)) else {\n            throw APNSwiftError.SigningError.invalidAuthKey\n        }\n        defer { EC_KEY_free(opaquePointer) }\n        \n        let sig = digest.withUnsafeReadableBytes { ptr in\n            ECDSA_do_sign(ptr.baseAddress?.assumingMemoryBound(to: UInt8.self), Int32(digest.readableBytes), opaquePointer)\n        }\n        defer { ECDSA_SIG_free(sig) }\n\n        var derEncodedSignature: UnsafeMutablePointer<CUnsignedChar>?\n        let derLength = i2d_ECDSA_SIG(sig, &derEncodedSignature)\n        guard let derCopy = derEncodedSignature, derLength > 0 else {\n            throw APNSwiftError.SigningError.invalidASN1\n        }\n\n        var derBytes = ByteBufferAllocator().buffer(capacity: Int(derLength))\n        derBytes.writeBytes(UnsafeBufferPointer<CUnsignedChar>(start: derCopy, count: Int(derLength)))\n        return derBytes\n    }\n}\n"], "filenames": ["Sources/APNSwift/APNSwiftSigner.swift"], "buggy_code_start_loc": [39], "buggy_code_end_loc": [64], "fixing_code_start_loc": [39], "fixing_code_end_loc": [61], "type": "CWE-122", "message": "In APNSwift 1.0.0, calling APNSwiftSigner.sign(digest:) is likely to result in a heap buffer overflow. This has been fixed in 1.0.1.", "other": {"cve": {"id": "CVE-2020-4068", "sourceIdentifier": "security-advisories@github.com", "published": "2020-06-22T16:15:11.870", "lastModified": "2020-06-30T14:22:19.767", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In APNSwift 1.0.0, calling APNSwiftSigner.sign(digest:) is likely to result in a heap buffer overflow. This has been fixed in 1.0.1."}, {"lang": "es", "value": "En APNSwift versi\u00f3n 1.0.0, llamando a APNSwiftSigner.sign(digest:) es probable que resulte en un desbordamiento del b\u00fafer de la pila. Esto se ha corregido en la versi\u00f3n 1.0.1"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:apnswift_project:apnswift:1.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "15C15C89-986E-4A2C-AB33-92A3C5417759"}]}]}], "references": [{"url": "https://github.com/kylebrowning/APNSwift/commit/97fa7f69dcdd89168fff84e0ba8f999881ee3d3f", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/kylebrowning/APNSwift/issues/31", "source": "security-advisories@github.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/kylebrowning/APNSwift/pull/32", "source": "security-advisories@github.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/kylebrowning/APNSwift/security/advisories/GHSA-qh2w-vjxg-mjcg", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/kylebrowning/APNSwift/commit/97fa7f69dcdd89168fff84e0ba8f999881ee3d3f"}}