{"buggy_code": ["/*\n * MOV demuxer\n * Copyright (c) 2001 Fabrice Bellard\n * Copyright (c) 2009 Baptiste Coudurier <baptiste dot coudurier at gmail dot com>\n *\n * first version by Francois Revol <revol@free.fr>\n * seek function by Gael Chardon <gael.dev@4now.net>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include <inttypes.h>\n#include <limits.h>\n#include <stdint.h>\n\n#include \"libavutil/attributes.h\"\n#include \"libavutil/channel_layout.h\"\n#include \"libavutil/internal.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/intfloat.h\"\n#include \"libavutil/mathematics.h\"\n#include \"libavutil/time_internal.h\"\n#include \"libavutil/avassert.h\"\n#include \"libavutil/avstring.h\"\n#include \"libavutil/dict.h\"\n#include \"libavutil/display.h\"\n#include \"libavutil/opt.h\"\n#include \"libavutil/aes.h\"\n#include \"libavutil/aes_ctr.h\"\n#include \"libavutil/pixdesc.h\"\n#include \"libavutil/sha.h\"\n#include \"libavutil/spherical.h\"\n#include \"libavutil/stereo3d.h\"\n#include \"libavutil/timecode.h\"\n#include \"libavcodec/ac3tab.h\"\n#include \"libavcodec/flac.h\"\n#include \"libavcodec/mpegaudiodecheader.h\"\n#include \"avformat.h\"\n#include \"internal.h\"\n#include \"avio_internal.h\"\n#include \"riff.h\"\n#include \"isom.h\"\n#include \"libavcodec/get_bits.h\"\n#include \"id3v1.h\"\n#include \"mov_chan.h\"\n#include \"replaygain.h\"\n\n#if CONFIG_ZLIB\n#include <zlib.h>\n#endif\n\n#include \"qtpalette.h\"\n\n/* those functions parse an atom */\n/* links atom IDs to parse functions */\ntypedef struct MOVParseTableEntry {\n    uint32_t type;\n    int (*parse)(MOVContext *ctx, AVIOContext *pb, MOVAtom atom);\n} MOVParseTableEntry;\n\nstatic int mov_read_default(MOVContext *c, AVIOContext *pb, MOVAtom atom);\nstatic int mov_read_mfra(MOVContext *c, AVIOContext *f);\nstatic int64_t add_ctts_entry(MOVStts** ctts_data, unsigned int* ctts_count, unsigned int* allocated_size,\n                              int count, int duration);\n\nstatic int mov_metadata_track_or_disc_number(MOVContext *c, AVIOContext *pb,\n                                             unsigned len, const char *key)\n{\n    char buf[16];\n\n    short current, total = 0;\n    avio_rb16(pb); // unknown\n    current = avio_rb16(pb);\n    if (len >= 6)\n        total = avio_rb16(pb);\n    if (!total)\n        snprintf(buf, sizeof(buf), \"%d\", current);\n    else\n        snprintf(buf, sizeof(buf), \"%d/%d\", current, total);\n    c->fc->event_flags |= AVFMT_EVENT_FLAG_METADATA_UPDATED;\n    av_dict_set(&c->fc->metadata, key, buf, 0);\n\n    return 0;\n}\n\nstatic int mov_metadata_int8_bypass_padding(MOVContext *c, AVIOContext *pb,\n                                            unsigned len, const char *key)\n{\n    /* bypass padding bytes */\n    avio_r8(pb);\n    avio_r8(pb);\n    avio_r8(pb);\n\n    c->fc->event_flags |= AVFMT_EVENT_FLAG_METADATA_UPDATED;\n    av_dict_set_int(&c->fc->metadata, key, avio_r8(pb), 0);\n\n    return 0;\n}\n\nstatic int mov_metadata_int8_no_padding(MOVContext *c, AVIOContext *pb,\n                                        unsigned len, const char *key)\n{\n    c->fc->event_flags |= AVFMT_EVENT_FLAG_METADATA_UPDATED;\n    av_dict_set_int(&c->fc->metadata, key, avio_r8(pb), 0);\n\n    return 0;\n}\n\nstatic int mov_metadata_gnre(MOVContext *c, AVIOContext *pb,\n                             unsigned len, const char *key)\n{\n    short genre;\n\n    avio_r8(pb); // unknown\n\n    genre = avio_r8(pb);\n    if (genre < 1 || genre > ID3v1_GENRE_MAX)\n        return 0;\n    c->fc->event_flags |= AVFMT_EVENT_FLAG_METADATA_UPDATED;\n    av_dict_set(&c->fc->metadata, key, ff_id3v1_genre_str[genre-1], 0);\n\n    return 0;\n}\n\nstatic const uint32_t mac_to_unicode[128] = {\n    0x00C4,0x00C5,0x00C7,0x00C9,0x00D1,0x00D6,0x00DC,0x00E1,\n    0x00E0,0x00E2,0x00E4,0x00E3,0x00E5,0x00E7,0x00E9,0x00E8,\n    0x00EA,0x00EB,0x00ED,0x00EC,0x00EE,0x00EF,0x00F1,0x00F3,\n    0x00F2,0x00F4,0x00F6,0x00F5,0x00FA,0x00F9,0x00FB,0x00FC,\n    0x2020,0x00B0,0x00A2,0x00A3,0x00A7,0x2022,0x00B6,0x00DF,\n    0x00AE,0x00A9,0x2122,0x00B4,0x00A8,0x2260,0x00C6,0x00D8,\n    0x221E,0x00B1,0x2264,0x2265,0x00A5,0x00B5,0x2202,0x2211,\n    0x220F,0x03C0,0x222B,0x00AA,0x00BA,0x03A9,0x00E6,0x00F8,\n    0x00BF,0x00A1,0x00AC,0x221A,0x0192,0x2248,0x2206,0x00AB,\n    0x00BB,0x2026,0x00A0,0x00C0,0x00C3,0x00D5,0x0152,0x0153,\n    0x2013,0x2014,0x201C,0x201D,0x2018,0x2019,0x00F7,0x25CA,\n    0x00FF,0x0178,0x2044,0x20AC,0x2039,0x203A,0xFB01,0xFB02,\n    0x2021,0x00B7,0x201A,0x201E,0x2030,0x00C2,0x00CA,0x00C1,\n    0x00CB,0x00C8,0x00CD,0x00CE,0x00CF,0x00CC,0x00D3,0x00D4,\n    0xF8FF,0x00D2,0x00DA,0x00DB,0x00D9,0x0131,0x02C6,0x02DC,\n    0x00AF,0x02D8,0x02D9,0x02DA,0x00B8,0x02DD,0x02DB,0x02C7,\n};\n\nstatic int mov_read_mac_string(MOVContext *c, AVIOContext *pb, int len,\n                               char *dst, int dstlen)\n{\n    char *p = dst;\n    char *end = dst+dstlen-1;\n    int i;\n\n    for (i = 0; i < len; i++) {\n        uint8_t t, c = avio_r8(pb);\n\n        if (p >= end)\n            continue;\n\n        if (c < 0x80)\n            *p++ = c;\n        else if (p < end)\n            PUT_UTF8(mac_to_unicode[c-0x80], t, if (p < end) *p++ = t;);\n    }\n    *p = 0;\n    return p - dst;\n}\n\nstatic int mov_read_covr(MOVContext *c, AVIOContext *pb, int type, int len)\n{\n    AVPacket pkt;\n    AVStream *st;\n    MOVStreamContext *sc;\n    enum AVCodecID id;\n    int ret;\n\n    switch (type) {\n    case 0xd:  id = AV_CODEC_ID_MJPEG; break;\n    case 0xe:  id = AV_CODEC_ID_PNG;   break;\n    case 0x1b: id = AV_CODEC_ID_BMP;   break;\n    default:\n        av_log(c->fc, AV_LOG_WARNING, \"Unknown cover type: 0x%x.\\n\", type);\n        avio_skip(pb, len);\n        return 0;\n    }\n\n    st = avformat_new_stream(c->fc, NULL);\n    if (!st)\n        return AVERROR(ENOMEM);\n    sc = av_mallocz(sizeof(*sc));\n    if (!sc)\n        return AVERROR(ENOMEM);\n    st->priv_data = sc;\n\n    ret = av_get_packet(pb, &pkt, len);\n    if (ret < 0)\n        return ret;\n\n    if (pkt.size >= 8 && id != AV_CODEC_ID_BMP) {\n        if (AV_RB64(pkt.data) == 0x89504e470d0a1a0a) {\n            id = AV_CODEC_ID_PNG;\n        } else {\n            id = AV_CODEC_ID_MJPEG;\n        }\n    }\n\n    st->disposition              |= AV_DISPOSITION_ATTACHED_PIC;\n\n    st->attached_pic              = pkt;\n    st->attached_pic.stream_index = st->index;\n    st->attached_pic.flags       |= AV_PKT_FLAG_KEY;\n\n    st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n    st->codecpar->codec_id   = id;\n\n    return 0;\n}\n\n// 3GPP TS 26.244\nstatic int mov_metadata_loci(MOVContext *c, AVIOContext *pb, unsigned len)\n{\n    char language[4] = { 0 };\n    char buf[200], place[100];\n    uint16_t langcode = 0;\n    double longitude, latitude, altitude;\n    const char *key = \"location\";\n\n    if (len < 4 + 2 + 1 + 1 + 4 + 4 + 4) {\n        av_log(c->fc, AV_LOG_ERROR, \"loci too short\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    avio_skip(pb, 4); // version+flags\n    langcode = avio_rb16(pb);\n    ff_mov_lang_to_iso639(langcode, language);\n    len -= 6;\n\n    len -= avio_get_str(pb, len, place, sizeof(place));\n    if (len < 1) {\n        av_log(c->fc, AV_LOG_ERROR, \"place name too long\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    avio_skip(pb, 1); // role\n    len -= 1;\n\n    if (len < 12) {\n        av_log(c->fc, AV_LOG_ERROR,\n               \"loci too short (%u bytes left, need at least %d)\\n\", len, 12);\n        return AVERROR_INVALIDDATA;\n    }\n    longitude = ((int32_t) avio_rb32(pb)) / (float) (1 << 16);\n    latitude  = ((int32_t) avio_rb32(pb)) / (float) (1 << 16);\n    altitude  = ((int32_t) avio_rb32(pb)) / (float) (1 << 16);\n\n    // Try to output in the same format as the ?xyz field\n    snprintf(buf, sizeof(buf), \"%+08.4f%+09.4f\",  latitude, longitude);\n    if (altitude)\n        av_strlcatf(buf, sizeof(buf), \"%+f\", altitude);\n    av_strlcatf(buf, sizeof(buf), \"/%s\", place);\n\n    if (*language && strcmp(language, \"und\")) {\n        char key2[16];\n        snprintf(key2, sizeof(key2), \"%s-%s\", key, language);\n        av_dict_set(&c->fc->metadata, key2, buf, 0);\n    }\n    c->fc->event_flags |= AVFMT_EVENT_FLAG_METADATA_UPDATED;\n    return av_dict_set(&c->fc->metadata, key, buf, 0);\n}\n\nstatic int mov_metadata_hmmt(MOVContext *c, AVIOContext *pb, unsigned len)\n{\n    int i, n_hmmt;\n\n    if (len < 2)\n        return 0;\n    if (c->ignore_chapters)\n        return 0;\n\n    n_hmmt = avio_rb32(pb);\n    for (i = 0; i < n_hmmt && !pb->eof_reached; i++) {\n        int moment_time = avio_rb32(pb);\n        avpriv_new_chapter(c->fc, i, av_make_q(1, 1000), moment_time, AV_NOPTS_VALUE, NULL);\n    }\n    return 0;\n}\n\nstatic int mov_read_udta_string(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    char tmp_key[5];\n    char key2[32], language[4] = {0};\n    char *str = NULL;\n    const char *key = NULL;\n    uint16_t langcode = 0;\n    uint32_t data_type = 0, str_size, str_size_alloc;\n    int (*parse)(MOVContext*, AVIOContext*, unsigned, const char*) = NULL;\n    int raw = 0;\n    int num = 0;\n\n    switch (atom.type) {\n    case MKTAG( '@','P','R','M'): key = \"premiere_version\"; raw = 1; break;\n    case MKTAG( '@','P','R','Q'): key = \"quicktime_version\"; raw = 1; break;\n    case MKTAG( 'X','M','P','_'):\n        if (c->export_xmp) { key = \"xmp\"; raw = 1; } break;\n    case MKTAG( 'a','A','R','T'): key = \"album_artist\";    break;\n    case MKTAG( 'a','k','I','D'): key = \"account_type\";\n        parse = mov_metadata_int8_no_padding; break;\n    case MKTAG( 'a','p','I','D'): key = \"account_id\"; break;\n    case MKTAG( 'c','a','t','g'): key = \"category\"; break;\n    case MKTAG( 'c','p','i','l'): key = \"compilation\";\n        parse = mov_metadata_int8_no_padding; break;\n    case MKTAG( 'c','p','r','t'): key = \"copyright\"; break;\n    case MKTAG( 'd','e','s','c'): key = \"description\"; break;\n    case MKTAG( 'd','i','s','k'): key = \"disc\";\n        parse = mov_metadata_track_or_disc_number; break;\n    case MKTAG( 'e','g','i','d'): key = \"episode_uid\";\n        parse = mov_metadata_int8_no_padding; break;\n    case MKTAG( 'F','I','R','M'): key = \"firmware\"; raw = 1; break;\n    case MKTAG( 'g','n','r','e'): key = \"genre\";\n        parse = mov_metadata_gnre; break;\n    case MKTAG( 'h','d','v','d'): key = \"hd_video\";\n        parse = mov_metadata_int8_no_padding; break;\n    case MKTAG( 'H','M','M','T'):\n        return mov_metadata_hmmt(c, pb, atom.size);\n    case MKTAG( 'k','e','y','w'): key = \"keywords\";  break;\n    case MKTAG( 'l','d','e','s'): key = \"synopsis\";  break;\n    case MKTAG( 'l','o','c','i'):\n        return mov_metadata_loci(c, pb, atom.size);\n    case MKTAG( 'p','c','s','t'): key = \"podcast\";\n        parse = mov_metadata_int8_no_padding; break;\n    case MKTAG( 'p','g','a','p'): key = \"gapless_playback\";\n        parse = mov_metadata_int8_no_padding; break;\n    case MKTAG( 'p','u','r','d'): key = \"purchase_date\"; break;\n    case MKTAG( 'r','t','n','g'): key = \"rating\";\n        parse = mov_metadata_int8_no_padding; break;\n    case MKTAG( 's','o','a','a'): key = \"sort_album_artist\"; break;\n    case MKTAG( 's','o','a','l'): key = \"sort_album\";   break;\n    case MKTAG( 's','o','a','r'): key = \"sort_artist\";  break;\n    case MKTAG( 's','o','c','o'): key = \"sort_composer\"; break;\n    case MKTAG( 's','o','n','m'): key = \"sort_name\";    break;\n    case MKTAG( 's','o','s','n'): key = \"sort_show\";    break;\n    case MKTAG( 's','t','i','k'): key = \"media_type\";\n        parse = mov_metadata_int8_no_padding; break;\n    case MKTAG( 't','r','k','n'): key = \"track\";\n        parse = mov_metadata_track_or_disc_number; break;\n    case MKTAG( 't','v','e','n'): key = \"episode_id\"; break;\n    case MKTAG( 't','v','e','s'): key = \"episode_sort\";\n        parse = mov_metadata_int8_bypass_padding; break;\n    case MKTAG( 't','v','n','n'): key = \"network\";   break;\n    case MKTAG( 't','v','s','h'): key = \"show\";      break;\n    case MKTAG( 't','v','s','n'): key = \"season_number\";\n        parse = mov_metadata_int8_bypass_padding; break;\n    case MKTAG(0xa9,'A','R','T'): key = \"artist\";    break;\n    case MKTAG(0xa9,'P','R','D'): key = \"producer\";  break;\n    case MKTAG(0xa9,'a','l','b'): key = \"album\";     break;\n    case MKTAG(0xa9,'a','u','t'): key = \"artist\";    break;\n    case MKTAG(0xa9,'c','h','p'): key = \"chapter\";   break;\n    case MKTAG(0xa9,'c','m','t'): key = \"comment\";   break;\n    case MKTAG(0xa9,'c','o','m'): key = \"composer\";  break;\n    case MKTAG(0xa9,'c','p','y'): key = \"copyright\"; break;\n    case MKTAG(0xa9,'d','a','y'): key = \"date\";      break;\n    case MKTAG(0xa9,'d','i','r'): key = \"director\";  break;\n    case MKTAG(0xa9,'d','i','s'): key = \"disclaimer\"; break;\n    case MKTAG(0xa9,'e','d','1'): key = \"edit_date\"; break;\n    case MKTAG(0xa9,'e','n','c'): key = \"encoder\";   break;\n    case MKTAG(0xa9,'f','m','t'): key = \"original_format\"; break;\n    case MKTAG(0xa9,'g','e','n'): key = \"genre\";     break;\n    case MKTAG(0xa9,'g','r','p'): key = \"grouping\";  break;\n    case MKTAG(0xa9,'h','s','t'): key = \"host_computer\"; break;\n    case MKTAG(0xa9,'i','n','f'): key = \"comment\";   break;\n    case MKTAG(0xa9,'l','y','r'): key = \"lyrics\";    break;\n    case MKTAG(0xa9,'m','a','k'): key = \"make\";      break;\n    case MKTAG(0xa9,'m','o','d'): key = \"model\";     break;\n    case MKTAG(0xa9,'n','a','m'): key = \"title\";     break;\n    case MKTAG(0xa9,'o','p','e'): key = \"original_artist\"; break;\n    case MKTAG(0xa9,'p','r','d'): key = \"producer\";  break;\n    case MKTAG(0xa9,'p','r','f'): key = \"performers\"; break;\n    case MKTAG(0xa9,'r','e','q'): key = \"playback_requirements\"; break;\n    case MKTAG(0xa9,'s','r','c'): key = \"original_source\"; break;\n    case MKTAG(0xa9,'s','t','3'): key = \"subtitle\";  break;\n    case MKTAG(0xa9,'s','w','r'): key = \"encoder\";   break;\n    case MKTAG(0xa9,'t','o','o'): key = \"encoder\";   break;\n    case MKTAG(0xa9,'t','r','k'): key = \"track\";     break;\n    case MKTAG(0xa9,'u','r','l'): key = \"URL\";       break;\n    case MKTAG(0xa9,'w','r','n'): key = \"warning\";   break;\n    case MKTAG(0xa9,'w','r','t'): key = \"composer\";  break;\n    case MKTAG(0xa9,'x','y','z'): key = \"location\";  break;\n    }\nretry:\n    if (c->itunes_metadata && atom.size > 8) {\n        int data_size = avio_rb32(pb);\n        int tag = avio_rl32(pb);\n        if (tag == MKTAG('d','a','t','a') && data_size <= atom.size) {\n            data_type = avio_rb32(pb); // type\n            avio_rb32(pb); // unknown\n            str_size = data_size - 16;\n            atom.size -= 16;\n\n            if (atom.type == MKTAG('c', 'o', 'v', 'r')) {\n                int ret = mov_read_covr(c, pb, data_type, str_size);\n                if (ret < 0) {\n                    av_log(c->fc, AV_LOG_ERROR, \"Error parsing cover art.\\n\");\n                }\n                return ret;\n            } else if (!key && c->found_hdlr_mdta && c->meta_keys) {\n                uint32_t index = AV_RB32(&atom.type);\n                if (index < c->meta_keys_count && index > 0) {\n                    key = c->meta_keys[index];\n                } else {\n                    av_log(c->fc, AV_LOG_WARNING,\n                           \"The index of 'data' is out of range: %\"PRId32\" < 1 or >= %d.\\n\",\n                           index, c->meta_keys_count);\n                }\n            }\n        } else return 0;\n    } else if (atom.size > 4 && key && !c->itunes_metadata && !raw) {\n        str_size = avio_rb16(pb); // string length\n        if (str_size > atom.size) {\n            raw = 1;\n            avio_seek(pb, -2, SEEK_CUR);\n            av_log(c->fc, AV_LOG_WARNING, \"UDTA parsing failed retrying raw\\n\");\n            goto retry;\n        }\n        langcode = avio_rb16(pb);\n        ff_mov_lang_to_iso639(langcode, language);\n        atom.size -= 4;\n    } else\n        str_size = atom.size;\n\n    if (c->export_all && !key) {\n        snprintf(tmp_key, 5, \"%.4s\", (char*)&atom.type);\n        key = tmp_key;\n    }\n\n    if (!key)\n        return 0;\n    if (atom.size < 0 || str_size >= INT_MAX/2)\n        return AVERROR_INVALIDDATA;\n\n    // Allocates enough space if data_type is a int32 or float32 number, otherwise\n    // worst-case requirement for output string in case of utf8 coded input\n    num = (data_type >= 21 && data_type <= 23);\n    str_size_alloc = (num ? 512 : (raw ? str_size : str_size * 2)) + 1;\n    str = av_mallocz(str_size_alloc);\n    if (!str)\n        return AVERROR(ENOMEM);\n\n    if (parse)\n        parse(c, pb, str_size, key);\n    else {\n        if (!raw && (data_type == 3 || (data_type == 0 && (langcode < 0x400 || langcode == 0x7fff)))) { // MAC Encoded\n            mov_read_mac_string(c, pb, str_size, str, str_size_alloc);\n        } else if (data_type == 21) { // BE signed integer, variable size\n            int val = 0;\n            if (str_size == 1)\n                val = (int8_t)avio_r8(pb);\n            else if (str_size == 2)\n                val = (int16_t)avio_rb16(pb);\n            else if (str_size == 3)\n                val = ((int32_t)(avio_rb24(pb)<<8))>>8;\n            else if (str_size == 4)\n                val = (int32_t)avio_rb32(pb);\n            if (snprintf(str, str_size_alloc, \"%d\", val) >= str_size_alloc) {\n                av_log(c->fc, AV_LOG_ERROR,\n                       \"Failed to store the number (%d) in string.\\n\", val);\n                av_free(str);\n                return AVERROR_INVALIDDATA;\n            }\n        } else if (data_type == 22) { // BE unsigned integer, variable size\n            unsigned int val = 0;\n            if (str_size == 1)\n                val = avio_r8(pb);\n            else if (str_size == 2)\n                val = avio_rb16(pb);\n            else if (str_size == 3)\n                val = avio_rb24(pb);\n            else if (str_size == 4)\n                val = avio_rb32(pb);\n            if (snprintf(str, str_size_alloc, \"%u\", val) >= str_size_alloc) {\n                av_log(c->fc, AV_LOG_ERROR,\n                       \"Failed to store the number (%u) in string.\\n\", val);\n                av_free(str);\n                return AVERROR_INVALIDDATA;\n            }\n        } else if (data_type == 23 && str_size >= 4) {  // BE float32\n            float val = av_int2float(avio_rb32(pb));\n            if (snprintf(str, str_size_alloc, \"%f\", val) >= str_size_alloc) {\n                av_log(c->fc, AV_LOG_ERROR,\n                       \"Failed to store the float32 number (%f) in string.\\n\", val);\n                av_free(str);\n                return AVERROR_INVALIDDATA;\n            }\n        } else {\n            int ret = ffio_read_size(pb, str, str_size);\n            if (ret < 0) {\n                av_free(str);\n                return ret;\n            }\n            str[str_size] = 0;\n        }\n        c->fc->event_flags |= AVFMT_EVENT_FLAG_METADATA_UPDATED;\n        av_dict_set(&c->fc->metadata, key, str, 0);\n        if (*language && strcmp(language, \"und\")) {\n            snprintf(key2, sizeof(key2), \"%s-%s\", key, language);\n            av_dict_set(&c->fc->metadata, key2, str, 0);\n        }\n        if (!strcmp(key, \"encoder\")) {\n            int major, minor, micro;\n            if (sscanf(str, \"HandBrake %d.%d.%d\", &major, &minor, &micro) == 3) {\n                c->handbrake_version = 1000000*major + 1000*minor + micro;\n            }\n        }\n    }\n\n    av_freep(&str);\n    return 0;\n}\n\nstatic int mov_read_chpl(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int64_t start;\n    int i, nb_chapters, str_len, version;\n    char str[256+1];\n    int ret;\n\n    if (c->ignore_chapters)\n        return 0;\n\n    if ((atom.size -= 5) < 0)\n        return 0;\n\n    version = avio_r8(pb);\n    avio_rb24(pb);\n    if (version)\n        avio_rb32(pb); // ???\n    nb_chapters = avio_r8(pb);\n\n    for (i = 0; i < nb_chapters; i++) {\n        if (atom.size < 9)\n            return 0;\n\n        start = avio_rb64(pb);\n        str_len = avio_r8(pb);\n\n        if ((atom.size -= 9+str_len) < 0)\n            return 0;\n\n        ret = ffio_read_size(pb, str, str_len);\n        if (ret < 0)\n            return ret;\n        str[str_len] = 0;\n        avpriv_new_chapter(c->fc, i, (AVRational){1,10000000}, start, AV_NOPTS_VALUE, str);\n    }\n    return 0;\n}\n\n#define MIN_DATA_ENTRY_BOX_SIZE 12\nstatic int mov_read_dref(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int entries, i, j;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_rb32(pb); // version + flags\n    entries = avio_rb32(pb);\n    if (!entries ||\n        entries >  (atom.size - 1) / MIN_DATA_ENTRY_BOX_SIZE + 1 ||\n        entries >= UINT_MAX / sizeof(*sc->drefs))\n        return AVERROR_INVALIDDATA;\n    sc->drefs_count = 0;\n    av_free(sc->drefs);\n    sc->drefs_count = 0;\n    sc->drefs = av_mallocz(entries * sizeof(*sc->drefs));\n    if (!sc->drefs)\n        return AVERROR(ENOMEM);\n    sc->drefs_count = entries;\n\n    for (i = 0; i < entries; i++) {\n        MOVDref *dref = &sc->drefs[i];\n        uint32_t size = avio_rb32(pb);\n        int64_t next = avio_tell(pb) + size - 4;\n\n        if (size < 12)\n            return AVERROR_INVALIDDATA;\n\n        dref->type = avio_rl32(pb);\n        avio_rb32(pb); // version + flags\n\n        if (dref->type == MKTAG('a','l','i','s') && size > 150) {\n            /* macintosh alias record */\n            uint16_t volume_len, len;\n            int16_t type;\n            int ret;\n\n            avio_skip(pb, 10);\n\n            volume_len = avio_r8(pb);\n            volume_len = FFMIN(volume_len, 27);\n            ret = ffio_read_size(pb, dref->volume, 27);\n            if (ret < 0)\n                return ret;\n            dref->volume[volume_len] = 0;\n            av_log(c->fc, AV_LOG_DEBUG, \"volume %s, len %d\\n\", dref->volume, volume_len);\n\n            avio_skip(pb, 12);\n\n            len = avio_r8(pb);\n            len = FFMIN(len, 63);\n            ret = ffio_read_size(pb, dref->filename, 63);\n            if (ret < 0)\n                return ret;\n            dref->filename[len] = 0;\n            av_log(c->fc, AV_LOG_DEBUG, \"filename %s, len %d\\n\", dref->filename, len);\n\n            avio_skip(pb, 16);\n\n            /* read next level up_from_alias/down_to_target */\n            dref->nlvl_from = avio_rb16(pb);\n            dref->nlvl_to   = avio_rb16(pb);\n            av_log(c->fc, AV_LOG_DEBUG, \"nlvl from %d, nlvl to %d\\n\",\n                   dref->nlvl_from, dref->nlvl_to);\n\n            avio_skip(pb, 16);\n\n            for (type = 0; type != -1 && avio_tell(pb) < next; ) {\n                if(avio_feof(pb))\n                    return AVERROR_EOF;\n                type = avio_rb16(pb);\n                len = avio_rb16(pb);\n                av_log(c->fc, AV_LOG_DEBUG, \"type %d, len %d\\n\", type, len);\n                if (len&1)\n                    len += 1;\n                if (type == 2) { // absolute path\n                    av_free(dref->path);\n                    dref->path = av_mallocz(len+1);\n                    if (!dref->path)\n                        return AVERROR(ENOMEM);\n\n                    ret = ffio_read_size(pb, dref->path, len);\n                    if (ret < 0) {\n                        av_freep(&dref->path);\n                        return ret;\n                    }\n                    if (len > volume_len && !strncmp(dref->path, dref->volume, volume_len)) {\n                        len -= volume_len;\n                        memmove(dref->path, dref->path+volume_len, len);\n                        dref->path[len] = 0;\n                    }\n                    // trim string of any ending zeros\n                    for (j = len - 1; j >= 0; j--) {\n                        if (dref->path[j] == 0)\n                            len--;\n                        else\n                            break;\n                    }\n                    for (j = 0; j < len; j++)\n                        if (dref->path[j] == ':' || dref->path[j] == 0)\n                            dref->path[j] = '/';\n                    av_log(c->fc, AV_LOG_DEBUG, \"path %s\\n\", dref->path);\n                } else if (type == 0) { // directory name\n                    av_free(dref->dir);\n                    dref->dir = av_malloc(len+1);\n                    if (!dref->dir)\n                        return AVERROR(ENOMEM);\n\n                    ret = ffio_read_size(pb, dref->dir, len);\n                    if (ret < 0) {\n                        av_freep(&dref->dir);\n                        return ret;\n                    }\n                    dref->dir[len] = 0;\n                    for (j = 0; j < len; j++)\n                        if (dref->dir[j] == ':')\n                            dref->dir[j] = '/';\n                    av_log(c->fc, AV_LOG_DEBUG, \"dir %s\\n\", dref->dir);\n                } else\n                    avio_skip(pb, len);\n            }\n        } else {\n            av_log(c->fc, AV_LOG_DEBUG, \"Unknown dref type 0x%08\"PRIx32\" size %\"PRIu32\"\\n\",\n                   dref->type, size);\n            entries--;\n            i--;\n        }\n        avio_seek(pb, next, SEEK_SET);\n    }\n    return 0;\n}\n\nstatic int mov_read_hdlr(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    uint32_t type;\n    uint32_t ctype;\n    int64_t title_size;\n    char *title_str;\n    int ret;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    /* component type */\n    ctype = avio_rl32(pb);\n    type = avio_rl32(pb); /* component subtype */\n\n    av_log(c->fc, AV_LOG_TRACE, \"ctype=%s\\n\", av_fourcc2str(ctype));\n    av_log(c->fc, AV_LOG_TRACE, \"stype=%s\\n\", av_fourcc2str(type));\n\n    if (c->trak_index < 0) {  // meta not inside a trak\n        if (type == MKTAG('m','d','t','a')) {\n            c->found_hdlr_mdta = 1;\n        }\n        return 0;\n    }\n\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if     (type == MKTAG('v','i','d','e'))\n        st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n    else if (type == MKTAG('s','o','u','n'))\n        st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n    else if (type == MKTAG('m','1','a',' '))\n        st->codecpar->codec_id = AV_CODEC_ID_MP2;\n    else if ((type == MKTAG('s','u','b','p')) || (type == MKTAG('c','l','c','p')))\n        st->codecpar->codec_type = AVMEDIA_TYPE_SUBTITLE;\n\n    avio_rb32(pb); /* component  manufacture */\n    avio_rb32(pb); /* component flags */\n    avio_rb32(pb); /* component flags mask */\n\n    title_size = atom.size - 24;\n    if (title_size > 0) {\n        if (title_size > FFMIN(INT_MAX, SIZE_MAX-1))\n            return AVERROR_INVALIDDATA;\n        title_str = av_malloc(title_size + 1); /* Add null terminator */\n        if (!title_str)\n            return AVERROR(ENOMEM);\n\n        ret = ffio_read_size(pb, title_str, title_size);\n        if (ret < 0) {\n            av_freep(&title_str);\n            return ret;\n        }\n        title_str[title_size] = 0;\n        if (title_str[0]) {\n            int off = (!c->isom && title_str[0] == title_size - 1);\n            av_dict_set(&st->metadata, \"handler_name\", title_str + off, 0);\n        }\n        av_freep(&title_str);\n    }\n\n    return 0;\n}\n\nint ff_mov_read_esds(AVFormatContext *fc, AVIOContext *pb)\n{\n    AVStream *st;\n    int tag;\n\n    if (fc->nb_streams < 1)\n        return 0;\n    st = fc->streams[fc->nb_streams-1];\n\n    avio_rb32(pb); /* version + flags */\n    ff_mp4_read_descr(fc, pb, &tag);\n    if (tag == MP4ESDescrTag) {\n        ff_mp4_parse_es_descr(pb, NULL);\n    } else\n        avio_rb16(pb); /* ID */\n\n    ff_mp4_read_descr(fc, pb, &tag);\n    if (tag == MP4DecConfigDescrTag)\n        ff_mp4_read_dec_config_descr(fc, st, pb);\n    return 0;\n}\n\nstatic int mov_read_esds(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    return ff_mov_read_esds(c->fc, pb);\n}\n\nstatic int mov_read_dac3(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    enum AVAudioServiceType *ast;\n    int ac3info, acmod, lfeon, bsmod;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    ast = (enum AVAudioServiceType*)av_stream_new_side_data(st, AV_PKT_DATA_AUDIO_SERVICE_TYPE,\n                                                            sizeof(*ast));\n    if (!ast)\n        return AVERROR(ENOMEM);\n\n    ac3info = avio_rb24(pb);\n    bsmod = (ac3info >> 14) & 0x7;\n    acmod = (ac3info >> 11) & 0x7;\n    lfeon = (ac3info >> 10) & 0x1;\n    st->codecpar->channels = ((int[]){2,1,2,3,3,4,4,5})[acmod] + lfeon;\n    st->codecpar->channel_layout = avpriv_ac3_channel_layout_tab[acmod];\n    if (lfeon)\n        st->codecpar->channel_layout |= AV_CH_LOW_FREQUENCY;\n    *ast = bsmod;\n    if (st->codecpar->channels > 1 && bsmod == 0x7)\n        *ast = AV_AUDIO_SERVICE_TYPE_KARAOKE;\n\n#if FF_API_LAVF_AVCTX\n    FF_DISABLE_DEPRECATION_WARNINGS\n    st->codec->audio_service_type = *ast;\n    FF_ENABLE_DEPRECATION_WARNINGS\n#endif\n\n    return 0;\n}\n\nstatic int mov_read_dec3(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    enum AVAudioServiceType *ast;\n    int eac3info, acmod, lfeon, bsmod;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    ast = (enum AVAudioServiceType*)av_stream_new_side_data(st, AV_PKT_DATA_AUDIO_SERVICE_TYPE,\n                                                            sizeof(*ast));\n    if (!ast)\n        return AVERROR(ENOMEM);\n\n    /* No need to parse fields for additional independent substreams and its\n     * associated dependent substreams since libavcodec's E-AC-3 decoder\n     * does not support them yet. */\n    avio_rb16(pb); /* data_rate and num_ind_sub */\n    eac3info = avio_rb24(pb);\n    bsmod = (eac3info >> 12) & 0x1f;\n    acmod = (eac3info >>  9) & 0x7;\n    lfeon = (eac3info >>  8) & 0x1;\n    st->codecpar->channel_layout = avpriv_ac3_channel_layout_tab[acmod];\n    if (lfeon)\n        st->codecpar->channel_layout |= AV_CH_LOW_FREQUENCY;\n    st->codecpar->channels = av_get_channel_layout_nb_channels(st->codecpar->channel_layout);\n    *ast = bsmod;\n    if (st->codecpar->channels > 1 && bsmod == 0x7)\n        *ast = AV_AUDIO_SERVICE_TYPE_KARAOKE;\n\n#if FF_API_LAVF_AVCTX\n    FF_DISABLE_DEPRECATION_WARNINGS\n    st->codec->audio_service_type = *ast;\n    FF_ENABLE_DEPRECATION_WARNINGS\n#endif\n\n    return 0;\n}\n\nstatic int mov_read_ddts(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    const uint32_t ddts_size = 20;\n    AVStream *st = NULL;\n    uint8_t *buf = NULL;\n    uint32_t frame_duration_code = 0;\n    uint32_t channel_layout_code = 0;\n    GetBitContext gb;\n\n    buf = av_malloc(ddts_size + AV_INPUT_BUFFER_PADDING_SIZE);\n    if (!buf) {\n        return AVERROR(ENOMEM);\n    }\n    if (avio_read(pb, buf, ddts_size) < ddts_size) {\n        av_free(buf);\n        return AVERROR_INVALIDDATA;\n    }\n\n    init_get_bits(&gb, buf, 8*ddts_size);\n\n    if (c->fc->nb_streams < 1) {\n        av_free(buf);\n        return 0;\n    }\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    st->codecpar->sample_rate = get_bits_long(&gb, 32);\n    if (st->codecpar->sample_rate <= 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"Invalid sample rate %d\\n\", st->codecpar->sample_rate);\n        av_free(buf);\n        return AVERROR_INVALIDDATA;\n    }\n    skip_bits_long(&gb, 32); /* max bitrate */\n    st->codecpar->bit_rate = get_bits_long(&gb, 32);\n    st->codecpar->bits_per_coded_sample = get_bits(&gb, 8);\n    frame_duration_code = get_bits(&gb, 2);\n    skip_bits(&gb, 30); /* various fields */\n    channel_layout_code = get_bits(&gb, 16);\n\n    st->codecpar->frame_size =\n            (frame_duration_code == 0) ? 512 :\n            (frame_duration_code == 1) ? 1024 :\n            (frame_duration_code == 2) ? 2048 :\n            (frame_duration_code == 3) ? 4096 : 0;\n\n    if (channel_layout_code > 0xff) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unsupported DTS audio channel layout\");\n    }\n    st->codecpar->channel_layout =\n            ((channel_layout_code & 0x1) ? AV_CH_FRONT_CENTER : 0) |\n            ((channel_layout_code & 0x2) ? AV_CH_FRONT_LEFT : 0) |\n            ((channel_layout_code & 0x2) ? AV_CH_FRONT_RIGHT : 0) |\n            ((channel_layout_code & 0x4) ? AV_CH_SIDE_LEFT : 0) |\n            ((channel_layout_code & 0x4) ? AV_CH_SIDE_RIGHT : 0) |\n            ((channel_layout_code & 0x8) ? AV_CH_LOW_FREQUENCY : 0);\n\n    st->codecpar->channels = av_get_channel_layout_nb_channels(st->codecpar->channel_layout);\n    av_free(buf);\n\n    return 0;\n}\n\nstatic int mov_read_chan(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if (atom.size < 16)\n        return 0;\n\n    /* skip version and flags */\n    avio_skip(pb, 4);\n\n    ff_mov_read_chan(c->fc, pb, st, atom.size - 4);\n\n    return 0;\n}\n\nstatic int mov_read_wfex(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int ret;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if ((ret = ff_get_wav_header(c->fc, pb, st->codecpar, atom.size, 0)) < 0)\n        av_log(c->fc, AV_LOG_WARNING, \"get_wav_header failed\\n\");\n\n    return ret;\n}\n\nstatic int mov_read_pasp(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    const int num = avio_rb32(pb);\n    const int den = avio_rb32(pb);\n    AVStream *st;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if ((st->sample_aspect_ratio.den != 1 || st->sample_aspect_ratio.num) && // default\n        (den != st->sample_aspect_ratio.den || num != st->sample_aspect_ratio.num)) {\n        av_log(c->fc, AV_LOG_WARNING,\n               \"sample aspect ratio already set to %d:%d, ignoring 'pasp' atom (%d:%d)\\n\",\n               st->sample_aspect_ratio.num, st->sample_aspect_ratio.den,\n               num, den);\n    } else if (den != 0) {\n        av_reduce(&st->sample_aspect_ratio.num, &st->sample_aspect_ratio.den,\n                  num, den, 32767);\n    }\n    return 0;\n}\n\n/* this atom contains actual media data */\nstatic int mov_read_mdat(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    if (atom.size == 0) /* wrong one (MP4) */\n        return 0;\n    c->found_mdat=1;\n    return 0; /* now go for moov */\n}\n\n#define DRM_BLOB_SIZE 56\n\nstatic int mov_read_adrm(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    uint8_t intermediate_key[20];\n    uint8_t intermediate_iv[20];\n    uint8_t input[64];\n    uint8_t output[64];\n    uint8_t file_checksum[20];\n    uint8_t calculated_checksum[20];\n    struct AVSHA *sha;\n    int i;\n    int ret = 0;\n    uint8_t *activation_bytes = c->activation_bytes;\n    uint8_t *fixed_key = c->audible_fixed_key;\n\n    c->aax_mode = 1;\n\n    sha = av_sha_alloc();\n    if (!sha)\n        return AVERROR(ENOMEM);\n    c->aes_decrypt = av_aes_alloc();\n    if (!c->aes_decrypt) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n\n    /* drm blob processing */\n    avio_read(pb, output, 8); // go to offset 8, absolute position 0x251\n    avio_read(pb, input, DRM_BLOB_SIZE);\n    avio_read(pb, output, 4); // go to offset 4, absolute position 0x28d\n    avio_read(pb, file_checksum, 20);\n\n    av_log(c->fc, AV_LOG_INFO, \"[aax] file checksum == \"); // required by external tools\n    for (i = 0; i < 20; i++)\n        av_log(c->fc, AV_LOG_INFO, \"%02x\", file_checksum[i]);\n    av_log(c->fc, AV_LOG_INFO, \"\\n\");\n\n    /* verify activation data */\n    if (!activation_bytes) {\n        av_log(c->fc, AV_LOG_WARNING, \"[aax] activation_bytes option is missing!\\n\");\n        ret = 0;  /* allow ffprobe to continue working on .aax files */\n        goto fail;\n    }\n    if (c->activation_bytes_size != 4) {\n        av_log(c->fc, AV_LOG_FATAL, \"[aax] activation_bytes value needs to be 4 bytes!\\n\");\n        ret = AVERROR(EINVAL);\n        goto fail;\n    }\n\n    /* verify fixed key */\n    if (c->audible_fixed_key_size != 16) {\n        av_log(c->fc, AV_LOG_FATAL, \"[aax] audible_fixed_key value needs to be 16 bytes!\\n\");\n        ret = AVERROR(EINVAL);\n        goto fail;\n    }\n\n    /* AAX (and AAX+) key derivation */\n    av_sha_init(sha, 160);\n    av_sha_update(sha, fixed_key, 16);\n    av_sha_update(sha, activation_bytes, 4);\n    av_sha_final(sha, intermediate_key);\n    av_sha_init(sha, 160);\n    av_sha_update(sha, fixed_key, 16);\n    av_sha_update(sha, intermediate_key, 20);\n    av_sha_update(sha, activation_bytes, 4);\n    av_sha_final(sha, intermediate_iv);\n    av_sha_init(sha, 160);\n    av_sha_update(sha, intermediate_key, 16);\n    av_sha_update(sha, intermediate_iv, 16);\n    av_sha_final(sha, calculated_checksum);\n    if (memcmp(calculated_checksum, file_checksum, 20)) { // critical error\n        av_log(c->fc, AV_LOG_ERROR, \"[aax] mismatch in checksums!\\n\");\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n    av_aes_init(c->aes_decrypt, intermediate_key, 128, 1);\n    av_aes_crypt(c->aes_decrypt, output, input, DRM_BLOB_SIZE >> 4, intermediate_iv, 1);\n    for (i = 0; i < 4; i++) {\n        // file data (in output) is stored in big-endian mode\n        if (activation_bytes[i] != output[3 - i]) { // critical error\n            av_log(c->fc, AV_LOG_ERROR, \"[aax] error in drm blob decryption!\\n\");\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n    }\n    memcpy(c->file_key, output + 8, 16);\n    memcpy(input, output + 26, 16);\n    av_sha_init(sha, 160);\n    av_sha_update(sha, input, 16);\n    av_sha_update(sha, c->file_key, 16);\n    av_sha_update(sha, fixed_key, 16);\n    av_sha_final(sha, c->file_iv);\n\nfail:\n    av_free(sha);\n\n    return ret;\n}\n\n// Audible AAX (and AAX+) bytestream decryption\nstatic int aax_filter(uint8_t *input, int size, MOVContext *c)\n{\n    int blocks = 0;\n    unsigned char iv[16];\n\n    memcpy(iv, c->file_iv, 16); // iv is overwritten\n    blocks = size >> 4; // trailing bytes are not encrypted!\n    av_aes_init(c->aes_decrypt, c->file_key, 128, 1);\n    av_aes_crypt(c->aes_decrypt, input, input, blocks, iv, 1);\n\n    return 0;\n}\n\n/* read major brand, minor version and compatible brands and store them as metadata */\nstatic int mov_read_ftyp(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    uint32_t minor_ver;\n    int comp_brand_size;\n    char* comp_brands_str;\n    uint8_t type[5] = {0};\n    int ret = ffio_read_size(pb, type, 4);\n    if (ret < 0)\n        return ret;\n\n    if (strcmp(type, \"qt  \"))\n        c->isom = 1;\n    av_log(c->fc, AV_LOG_DEBUG, \"ISO: File Type Major Brand: %.4s\\n\",(char *)&type);\n    av_dict_set(&c->fc->metadata, \"major_brand\", type, 0);\n    minor_ver = avio_rb32(pb); /* minor version */\n    av_dict_set_int(&c->fc->metadata, \"minor_version\", minor_ver, 0);\n\n    comp_brand_size = atom.size - 8;\n    if (comp_brand_size < 0)\n        return AVERROR_INVALIDDATA;\n    comp_brands_str = av_malloc(comp_brand_size + 1); /* Add null terminator */\n    if (!comp_brands_str)\n        return AVERROR(ENOMEM);\n\n    ret = ffio_read_size(pb, comp_brands_str, comp_brand_size);\n    if (ret < 0) {\n        av_freep(&comp_brands_str);\n        return ret;\n    }\n    comp_brands_str[comp_brand_size] = 0;\n    av_dict_set(&c->fc->metadata, \"compatible_brands\", comp_brands_str, 0);\n    av_freep(&comp_brands_str);\n\n    return 0;\n}\n\n/* this atom should contain all header atoms */\nstatic int mov_read_moov(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int ret;\n\n    if (c->found_moov) {\n        av_log(c->fc, AV_LOG_WARNING, \"Found duplicated MOOV Atom. Skipped it\\n\");\n        avio_skip(pb, atom.size);\n        return 0;\n    }\n\n    if ((ret = mov_read_default(c, pb, atom)) < 0)\n        return ret;\n    /* we parsed the 'moov' atom, we can terminate the parsing as soon as we find the 'mdat' */\n    /* so we don't parse the whole file if over a network */\n    c->found_moov=1;\n    return 0; /* now go for mdat */\n}\n\nstatic int mov_read_moof(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    if (!c->has_looked_for_mfra && c->use_mfra_for > 0) {\n        c->has_looked_for_mfra = 1;\n        if (pb->seekable & AVIO_SEEKABLE_NORMAL) {\n            int ret;\n            av_log(c->fc, AV_LOG_VERBOSE, \"stream has moof boxes, will look \"\n                    \"for a mfra\\n\");\n            if ((ret = mov_read_mfra(c, pb)) < 0) {\n                av_log(c->fc, AV_LOG_VERBOSE, \"found a moof box but failed to \"\n                        \"read the mfra (may be a live ismv)\\n\");\n            }\n        } else {\n            av_log(c->fc, AV_LOG_VERBOSE, \"found a moof box but stream is not \"\n                    \"seekable, can not look for mfra\\n\");\n        }\n    }\n    c->fragment.moof_offset = c->fragment.implicit_offset = avio_tell(pb) - 8;\n    av_log(c->fc, AV_LOG_TRACE, \"moof offset %\"PRIx64\"\\n\", c->fragment.moof_offset);\n    return mov_read_default(c, pb, atom);\n}\n\nstatic void mov_metadata_creation_time(AVDictionary **metadata, int64_t time)\n{\n    if (time) {\n        if(time >= 2082844800)\n            time -= 2082844800;  /* seconds between 1904-01-01 and Epoch */\n\n        if ((int64_t)(time * 1000000ULL) / 1000000 != time) {\n            av_log(NULL, AV_LOG_DEBUG, \"creation_time is not representable\\n\");\n            return;\n        }\n\n        avpriv_dict_set_timestamp(metadata, \"creation_time\", time * 1000000);\n    }\n}\n\nstatic int mov_read_mdhd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int version;\n    char language[4] = {0};\n    unsigned lang;\n    int64_t creation_time;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    if (sc->time_scale) {\n        av_log(c->fc, AV_LOG_ERROR, \"Multiple mdhd?\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    version = avio_r8(pb);\n    if (version > 1) {\n        avpriv_request_sample(c->fc, \"Version %d\", version);\n        return AVERROR_PATCHWELCOME;\n    }\n    avio_rb24(pb); /* flags */\n    if (version == 1) {\n        creation_time = avio_rb64(pb);\n        avio_rb64(pb);\n    } else {\n        creation_time = avio_rb32(pb);\n        avio_rb32(pb); /* modification time */\n    }\n    mov_metadata_creation_time(&st->metadata, creation_time);\n\n    sc->time_scale = avio_rb32(pb);\n    if (sc->time_scale <= 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"Invalid mdhd time scale %d, defaulting to 1\\n\", sc->time_scale);\n        sc->time_scale = 1;\n    }\n    st->duration = (version == 1) ? avio_rb64(pb) : avio_rb32(pb); /* duration */\n\n    lang = avio_rb16(pb); /* language */\n    if (ff_mov_lang_to_iso639(lang, language))\n        av_dict_set(&st->metadata, \"language\", language, 0);\n    avio_rb16(pb); /* quality */\n\n    return 0;\n}\n\nstatic int mov_read_mvhd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int i;\n    int64_t creation_time;\n    int version = avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    if (version == 1) {\n        creation_time = avio_rb64(pb);\n        avio_rb64(pb);\n    } else {\n        creation_time = avio_rb32(pb);\n        avio_rb32(pb); /* modification time */\n    }\n    mov_metadata_creation_time(&c->fc->metadata, creation_time);\n    c->time_scale = avio_rb32(pb); /* time scale */\n    if (c->time_scale <= 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"Invalid mvhd time scale %d, defaulting to 1\\n\", c->time_scale);\n        c->time_scale = 1;\n    }\n    av_log(c->fc, AV_LOG_TRACE, \"time scale = %i\\n\", c->time_scale);\n\n    c->duration = (version == 1) ? avio_rb64(pb) : avio_rb32(pb); /* duration */\n    // set the AVCodecContext duration because the duration of individual tracks\n    // may be inaccurate\n    if (c->time_scale > 0 && !c->trex_data)\n        c->fc->duration = av_rescale(c->duration, AV_TIME_BASE, c->time_scale);\n    avio_rb32(pb); /* preferred scale */\n\n    avio_rb16(pb); /* preferred volume */\n\n    avio_skip(pb, 10); /* reserved */\n\n    /* movie display matrix, store it in main context and use it later on */\n    for (i = 0; i < 3; i++) {\n        c->movie_display_matrix[i][0] = avio_rb32(pb); // 16.16 fixed point\n        c->movie_display_matrix[i][1] = avio_rb32(pb); // 16.16 fixed point\n        c->movie_display_matrix[i][2] = avio_rb32(pb); //  2.30 fixed point\n    }\n\n    avio_rb32(pb); /* preview time */\n    avio_rb32(pb); /* preview duration */\n    avio_rb32(pb); /* poster time */\n    avio_rb32(pb); /* selection time */\n    avio_rb32(pb); /* selection duration */\n    avio_rb32(pb); /* current time */\n    avio_rb32(pb); /* next track ID */\n\n    return 0;\n}\n\nstatic int mov_read_enda(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int little_endian;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    little_endian = avio_rb16(pb) & 0xFF;\n    av_log(c->fc, AV_LOG_TRACE, \"enda %d\\n\", little_endian);\n    if (little_endian == 1) {\n        switch (st->codecpar->codec_id) {\n        case AV_CODEC_ID_PCM_S24BE:\n            st->codecpar->codec_id = AV_CODEC_ID_PCM_S24LE;\n            break;\n        case AV_CODEC_ID_PCM_S32BE:\n            st->codecpar->codec_id = AV_CODEC_ID_PCM_S32LE;\n            break;\n        case AV_CODEC_ID_PCM_F32BE:\n            st->codecpar->codec_id = AV_CODEC_ID_PCM_F32LE;\n            break;\n        case AV_CODEC_ID_PCM_F64BE:\n            st->codecpar->codec_id = AV_CODEC_ID_PCM_F64LE;\n            break;\n        default:\n            break;\n        }\n    }\n    return 0;\n}\n\nstatic int mov_read_colr(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    char color_parameter_type[5] = { 0 };\n    uint16_t color_primaries, color_trc, color_matrix;\n    int ret;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams - 1];\n\n    ret = ffio_read_size(pb, color_parameter_type, 4);\n    if (ret < 0)\n        return ret;\n    if (strncmp(color_parameter_type, \"nclx\", 4) &&\n        strncmp(color_parameter_type, \"nclc\", 4)) {\n        av_log(c->fc, AV_LOG_WARNING, \"unsupported color_parameter_type %s\\n\",\n               color_parameter_type);\n        return 0;\n    }\n\n    color_primaries = avio_rb16(pb);\n    color_trc = avio_rb16(pb);\n    color_matrix = avio_rb16(pb);\n\n    av_log(c->fc, AV_LOG_TRACE,\n           \"%s: pri %d trc %d matrix %d\",\n           color_parameter_type, color_primaries, color_trc, color_matrix);\n\n    if (!strncmp(color_parameter_type, \"nclx\", 4)) {\n        uint8_t color_range = avio_r8(pb) >> 7;\n        av_log(c->fc, AV_LOG_TRACE, \" full %\"PRIu8\"\", color_range);\n        if (color_range)\n            st->codecpar->color_range = AVCOL_RANGE_JPEG;\n        else\n            st->codecpar->color_range = AVCOL_RANGE_MPEG;\n    }\n\n    if (!av_color_primaries_name(color_primaries))\n        color_primaries = AVCOL_PRI_UNSPECIFIED;\n    if (!av_color_transfer_name(color_trc))\n        color_trc = AVCOL_TRC_UNSPECIFIED;\n    if (!av_color_space_name(color_matrix))\n        color_matrix = AVCOL_SPC_UNSPECIFIED;\n\n    st->codecpar->color_primaries = color_primaries;\n    st->codecpar->color_trc       = color_trc;\n    st->codecpar->color_space     = color_matrix;\n    av_log(c->fc, AV_LOG_TRACE, \"\\n\");\n\n    return 0;\n}\n\nstatic int mov_read_fiel(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    unsigned mov_field_order;\n    enum AVFieldOrder decoded_field_order = AV_FIELD_UNKNOWN;\n\n    if (c->fc->nb_streams < 1) // will happen with jp2 files\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    if (atom.size < 2)\n        return AVERROR_INVALIDDATA;\n    mov_field_order = avio_rb16(pb);\n    if ((mov_field_order & 0xFF00) == 0x0100)\n        decoded_field_order = AV_FIELD_PROGRESSIVE;\n    else if ((mov_field_order & 0xFF00) == 0x0200) {\n        switch (mov_field_order & 0xFF) {\n        case 0x01: decoded_field_order = AV_FIELD_TT;\n                   break;\n        case 0x06: decoded_field_order = AV_FIELD_BB;\n                   break;\n        case 0x09: decoded_field_order = AV_FIELD_TB;\n                   break;\n        case 0x0E: decoded_field_order = AV_FIELD_BT;\n                   break;\n        }\n    }\n    if (decoded_field_order == AV_FIELD_UNKNOWN && mov_field_order) {\n        av_log(NULL, AV_LOG_ERROR, \"Unknown MOV field order 0x%04x\\n\", mov_field_order);\n    }\n    st->codecpar->field_order = decoded_field_order;\n\n    return 0;\n}\n\nstatic int mov_realloc_extradata(AVCodecParameters *par, MOVAtom atom)\n{\n    int err = 0;\n    uint64_t size = (uint64_t)par->extradata_size + atom.size + 8 + AV_INPUT_BUFFER_PADDING_SIZE;\n    if (size > INT_MAX || (uint64_t)atom.size > INT_MAX)\n        return AVERROR_INVALIDDATA;\n    if ((err = av_reallocp(&par->extradata, size)) < 0) {\n        par->extradata_size = 0;\n        return err;\n    }\n    par->extradata_size = size - AV_INPUT_BUFFER_PADDING_SIZE;\n    return 0;\n}\n\n/* Read a whole atom into the extradata return the size of the atom read, possibly truncated if != atom.size */\nstatic int64_t mov_read_atom_into_extradata(MOVContext *c, AVIOContext *pb, MOVAtom atom,\n                                        AVCodecParameters *par, uint8_t *buf)\n{\n    int64_t result = atom.size;\n    int err;\n\n    AV_WB32(buf    , atom.size + 8);\n    AV_WL32(buf + 4, atom.type);\n    err = ffio_read_size(pb, buf + 8, atom.size);\n    if (err < 0) {\n        par->extradata_size -= atom.size;\n        return err;\n    } else if (err < atom.size) {\n        av_log(c->fc, AV_LOG_WARNING, \"truncated extradata\\n\");\n        par->extradata_size -= atom.size - err;\n        result = err;\n    }\n    memset(buf + 8 + err, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n    return result;\n}\n\n/* FIXME modify QDM2/SVQ3/H.264 decoders to take full atom as extradata */\nstatic int mov_read_extradata(MOVContext *c, AVIOContext *pb, MOVAtom atom,\n                              enum AVCodecID codec_id)\n{\n    AVStream *st;\n    uint64_t original_size;\n    int err;\n\n    if (c->fc->nb_streams < 1) // will happen with jp2 files\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if (st->codecpar->codec_id != codec_id)\n        return 0; /* unexpected codec_id - don't mess with extradata */\n\n    original_size = st->codecpar->extradata_size;\n    err = mov_realloc_extradata(st->codecpar, atom);\n    if (err)\n        return err;\n\n    err =  mov_read_atom_into_extradata(c, pb, atom, st->codecpar,  st->codecpar->extradata + original_size);\n    if (err < 0)\n        return err;\n    return 0; // Note: this is the original behavior to ignore truncation.\n}\n\n/* wrapper functions for reading ALAC/AVS/MJPEG/MJPEG2000 extradata atoms only for those codecs */\nstatic int mov_read_alac(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    return mov_read_extradata(c, pb, atom, AV_CODEC_ID_ALAC);\n}\n\nstatic int mov_read_avss(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    return mov_read_extradata(c, pb, atom, AV_CODEC_ID_AVS);\n}\n\nstatic int mov_read_jp2h(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    return mov_read_extradata(c, pb, atom, AV_CODEC_ID_JPEG2000);\n}\n\nstatic int mov_read_dpxe(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    return mov_read_extradata(c, pb, atom, AV_CODEC_ID_R10K);\n}\n\nstatic int mov_read_avid(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int ret = mov_read_extradata(c, pb, atom, AV_CODEC_ID_AVUI);\n    if(ret == 0)\n        ret = mov_read_extradata(c, pb, atom, AV_CODEC_ID_DNXHD);\n    return ret;\n}\n\nstatic int mov_read_targa_y216(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int ret = mov_read_extradata(c, pb, atom, AV_CODEC_ID_TARGA_Y216);\n\n    if (!ret && c->fc->nb_streams >= 1) {\n        AVCodecParameters *par = c->fc->streams[c->fc->nb_streams-1]->codecpar;\n        if (par->extradata_size >= 40) {\n            par->height = AV_RB16(&par->extradata[36]);\n            par->width  = AV_RB16(&par->extradata[38]);\n        }\n    }\n    return ret;\n}\n\nstatic int mov_read_ares(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    if (c->fc->nb_streams >= 1) {\n        AVCodecParameters *par = c->fc->streams[c->fc->nb_streams-1]->codecpar;\n        if (par->codec_tag == MKTAG('A', 'V', 'i', 'n') &&\n            par->codec_id == AV_CODEC_ID_H264 &&\n            atom.size > 11) {\n            int cid;\n            avio_skip(pb, 10);\n            cid = avio_rb16(pb);\n            /* For AVID AVCI50, force width of 1440 to be able to select the correct SPS and PPS */\n            if (cid == 0xd4d || cid == 0xd4e)\n                par->width = 1440;\n            return 0;\n        } else if ((par->codec_tag == MKTAG('A', 'V', 'd', '1') ||\n                    par->codec_tag == MKTAG('A', 'V', 'd', 'n')) &&\n                   atom.size >= 24) {\n            int num, den;\n            avio_skip(pb, 12);\n            num = avio_rb32(pb);\n            den = avio_rb32(pb);\n            if (num <= 0 || den <= 0)\n                return 0;\n            switch (avio_rb32(pb)) {\n            case 2:\n                if (den >= INT_MAX / 2)\n                    return 0;\n                den *= 2;\n            case 1:\n                c->fc->streams[c->fc->nb_streams-1]->display_aspect_ratio.num = num;\n                c->fc->streams[c->fc->nb_streams-1]->display_aspect_ratio.den = den;\n            default:\n                return 0;\n            }\n        }\n    }\n\n    return mov_read_avid(c, pb, atom);\n}\n\nstatic int mov_read_aclr(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int ret = 0;\n    int length = 0;\n    uint64_t original_size;\n    if (c->fc->nb_streams >= 1) {\n        AVCodecParameters *par = c->fc->streams[c->fc->nb_streams-1]->codecpar;\n        if (par->codec_id == AV_CODEC_ID_H264)\n            return 0;\n        if (atom.size == 16) {\n            original_size = par->extradata_size;\n            ret = mov_realloc_extradata(par, atom);\n            if (!ret) {\n                length =  mov_read_atom_into_extradata(c, pb, atom, par, par->extradata + original_size);\n                if (length == atom.size) {\n                    const uint8_t range_value = par->extradata[original_size + 19];\n                    switch (range_value) {\n                    case 1:\n                        par->color_range = AVCOL_RANGE_MPEG;\n                        break;\n                    case 2:\n                        par->color_range = AVCOL_RANGE_JPEG;\n                        break;\n                    default:\n                        av_log(c, AV_LOG_WARNING, \"ignored unknown aclr value (%d)\\n\", range_value);\n                        break;\n                    }\n                    ff_dlog(c, \"color_range: %d\\n\", par->color_range);\n                } else {\n                  /* For some reason the whole atom was not added to the extradata */\n                  av_log(c, AV_LOG_ERROR, \"aclr not decoded - incomplete atom\\n\");\n                }\n            } else {\n                av_log(c, AV_LOG_ERROR, \"aclr not decoded - unable to add atom to extradata\\n\");\n            }\n        } else {\n            av_log(c, AV_LOG_WARNING, \"aclr not decoded - unexpected size %\"PRId64\"\\n\", atom.size);\n        }\n    }\n\n    return ret;\n}\n\nstatic int mov_read_svq3(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    return mov_read_extradata(c, pb, atom, AV_CODEC_ID_SVQ3);\n}\n\nstatic int mov_read_wave(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int ret;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if ((uint64_t)atom.size > (1<<30))\n        return AVERROR_INVALIDDATA;\n\n    if (st->codecpar->codec_id == AV_CODEC_ID_QDM2 ||\n        st->codecpar->codec_id == AV_CODEC_ID_QDMC ||\n        st->codecpar->codec_id == AV_CODEC_ID_SPEEX) {\n        // pass all frma atom to codec, needed at least for QDMC and QDM2\n        av_freep(&st->codecpar->extradata);\n        ret = ff_get_extradata(c->fc, st->codecpar, pb, atom.size);\n        if (ret < 0)\n            return ret;\n    } else if (atom.size > 8) { /* to read frma, esds atoms */\n        if (st->codecpar->codec_id == AV_CODEC_ID_ALAC && atom.size >= 24) {\n            uint64_t buffer;\n            ret = ffio_ensure_seekback(pb, 8);\n            if (ret < 0)\n                return ret;\n            buffer = avio_rb64(pb);\n            atom.size -= 8;\n            if (  (buffer & 0xFFFFFFFF) == MKBETAG('f','r','m','a')\n                && buffer >> 32 <= atom.size\n                && buffer >> 32 >= 8) {\n                avio_skip(pb, -8);\n                atom.size += 8;\n            } else if (!st->codecpar->extradata_size) {\n#define ALAC_EXTRADATA_SIZE 36\n                st->codecpar->extradata = av_mallocz(ALAC_EXTRADATA_SIZE + AV_INPUT_BUFFER_PADDING_SIZE);\n                if (!st->codecpar->extradata)\n                    return AVERROR(ENOMEM);\n                st->codecpar->extradata_size = ALAC_EXTRADATA_SIZE;\n                AV_WB32(st->codecpar->extradata    , ALAC_EXTRADATA_SIZE);\n                AV_WB32(st->codecpar->extradata + 4, MKTAG('a','l','a','c'));\n                AV_WB64(st->codecpar->extradata + 12, buffer);\n                avio_read(pb, st->codecpar->extradata + 20, 16);\n                avio_skip(pb, atom.size - 24);\n                return 0;\n            }\n        }\n        if ((ret = mov_read_default(c, pb, atom)) < 0)\n            return ret;\n    } else\n        avio_skip(pb, atom.size);\n    return 0;\n}\n\n/**\n * This function reads atom content and puts data in extradata without tag\n * nor size unlike mov_read_extradata.\n */\nstatic int mov_read_glbl(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int ret;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if ((uint64_t)atom.size > (1<<30))\n        return AVERROR_INVALIDDATA;\n\n    if (atom.size >= 10) {\n        // Broken files created by legacy versions of libavformat will\n        // wrap a whole fiel atom inside of a glbl atom.\n        unsigned size = avio_rb32(pb);\n        unsigned type = avio_rl32(pb);\n        avio_seek(pb, -8, SEEK_CUR);\n        if (type == MKTAG('f','i','e','l') && size == atom.size)\n            return mov_read_default(c, pb, atom);\n    }\n    if (st->codecpar->extradata_size > 1 && st->codecpar->extradata) {\n        av_log(c, AV_LOG_WARNING, \"ignoring multiple glbl\\n\");\n        return 0;\n    }\n    av_freep(&st->codecpar->extradata);\n    ret = ff_get_extradata(c->fc, st->codecpar, pb, atom.size);\n    if (ret < 0)\n        return ret;\n\n    return 0;\n}\n\nstatic int mov_read_dvc1(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    uint8_t profile_level;\n    int ret;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if (atom.size >= (1<<28) || atom.size < 7)\n        return AVERROR_INVALIDDATA;\n\n    profile_level = avio_r8(pb);\n    if ((profile_level & 0xf0) != 0xc0)\n        return 0;\n\n    avio_seek(pb, 6, SEEK_CUR);\n    av_freep(&st->codecpar->extradata);\n    ret = ff_get_extradata(c->fc, st->codecpar, pb, atom.size - 7);\n    if (ret < 0)\n        return ret;\n\n    return 0;\n}\n\n/**\n * An strf atom is a BITMAPINFOHEADER struct. This struct is 40 bytes itself,\n * but can have extradata appended at the end after the 40 bytes belonging\n * to the struct.\n */\nstatic int mov_read_strf(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int ret;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    if (atom.size <= 40)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if ((uint64_t)atom.size > (1<<30))\n        return AVERROR_INVALIDDATA;\n\n    avio_skip(pb, 40);\n    av_freep(&st->codecpar->extradata);\n    ret = ff_get_extradata(c->fc, st->codecpar, pb, atom.size - 40);\n    if (ret < 0)\n        return ret;\n\n    return 0;\n}\n\nstatic int mov_read_stco(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    entries = avio_rb32(pb);\n\n    if (!entries)\n        return 0;\n\n    if (sc->chunk_offsets)\n        av_log(c->fc, AV_LOG_WARNING, \"Duplicated STCO atom\\n\");\n    av_free(sc->chunk_offsets);\n    sc->chunk_count = 0;\n    sc->chunk_offsets = av_malloc_array(entries, sizeof(*sc->chunk_offsets));\n    if (!sc->chunk_offsets)\n        return AVERROR(ENOMEM);\n    sc->chunk_count = entries;\n\n    if      (atom.type == MKTAG('s','t','c','o'))\n        for (i = 0; i < entries && !pb->eof_reached; i++)\n            sc->chunk_offsets[i] = avio_rb32(pb);\n    else if (atom.type == MKTAG('c','o','6','4'))\n        for (i = 0; i < entries && !pb->eof_reached; i++)\n            sc->chunk_offsets[i] = avio_rb64(pb);\n    else\n        return AVERROR_INVALIDDATA;\n\n    sc->chunk_count = i;\n\n    if (pb->eof_reached)\n        return AVERROR_EOF;\n\n    return 0;\n}\n\n/**\n * Compute codec id for 'lpcm' tag.\n * See CoreAudioTypes and AudioStreamBasicDescription at Apple.\n */\nenum AVCodecID ff_mov_get_lpcm_codec_id(int bps, int flags)\n{\n    /* lpcm flags:\n     * 0x1 = float\n     * 0x2 = big-endian\n     * 0x4 = signed\n     */\n    return ff_get_pcm_codec_id(bps, flags & 1, flags & 2, flags & 4 ? -1 : 0);\n}\n\nstatic int mov_codec_id(AVStream *st, uint32_t format)\n{\n    int id = ff_codec_get_id(ff_codec_movaudio_tags, format);\n\n    if (id <= 0 &&\n        ((format & 0xFFFF) == 'm' + ('s' << 8) ||\n         (format & 0xFFFF) == 'T' + ('S' << 8)))\n        id = ff_codec_get_id(ff_codec_wav_tags, av_bswap32(format) & 0xFFFF);\n\n    if (st->codecpar->codec_type != AVMEDIA_TYPE_VIDEO && id > 0) {\n        st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n    } else if (st->codecpar->codec_type != AVMEDIA_TYPE_AUDIO &&\n               /* skip old ASF MPEG-4 tag */\n               format && format != MKTAG('m','p','4','s')) {\n        id = ff_codec_get_id(ff_codec_movvideo_tags, format);\n        if (id <= 0)\n            id = ff_codec_get_id(ff_codec_bmp_tags, format);\n        if (id > 0)\n            st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n        else if (st->codecpar->codec_type == AVMEDIA_TYPE_DATA ||\n                    (st->codecpar->codec_type == AVMEDIA_TYPE_SUBTITLE &&\n                    st->codecpar->codec_id == AV_CODEC_ID_NONE)) {\n            id = ff_codec_get_id(ff_codec_movsubtitle_tags, format);\n            if (id > 0)\n                st->codecpar->codec_type = AVMEDIA_TYPE_SUBTITLE;\n        }\n    }\n\n    st->codecpar->codec_tag = format;\n\n    return id;\n}\n\nstatic void mov_parse_stsd_video(MOVContext *c, AVIOContext *pb,\n                                 AVStream *st, MOVStreamContext *sc)\n{\n    uint8_t codec_name[32] = { 0 };\n    int64_t stsd_start;\n    unsigned int len;\n\n    /* The first 16 bytes of the video sample description are already\n     * read in ff_mov_read_stsd_entries() */\n    stsd_start = avio_tell(pb) - 16;\n\n    avio_rb16(pb); /* version */\n    avio_rb16(pb); /* revision level */\n    avio_rb32(pb); /* vendor */\n    avio_rb32(pb); /* temporal quality */\n    avio_rb32(pb); /* spatial quality */\n\n    st->codecpar->width  = avio_rb16(pb); /* width */\n    st->codecpar->height = avio_rb16(pb); /* height */\n\n    avio_rb32(pb); /* horiz resolution */\n    avio_rb32(pb); /* vert resolution */\n    avio_rb32(pb); /* data size, always 0 */\n    avio_rb16(pb); /* frames per samples */\n\n    len = avio_r8(pb); /* codec name, pascal string */\n    if (len > 31)\n        len = 31;\n    mov_read_mac_string(c, pb, len, codec_name, sizeof(codec_name));\n    if (len < 31)\n        avio_skip(pb, 31 - len);\n\n    if (codec_name[0])\n        av_dict_set(&st->metadata, \"encoder\", codec_name, 0);\n\n    /* codec_tag YV12 triggers an UV swap in rawdec.c */\n    if (!memcmp(codec_name, \"Planar Y'CbCr 8-bit 4:2:0\", 25)) {\n        st->codecpar->codec_tag = MKTAG('I', '4', '2', '0');\n        st->codecpar->width &= ~1;\n        st->codecpar->height &= ~1;\n    }\n    /* Flash Media Server uses tag H.263 with Sorenson Spark */\n    if (st->codecpar->codec_tag == MKTAG('H','2','6','3') &&\n        !memcmp(codec_name, \"Sorenson H263\", 13))\n        st->codecpar->codec_id = AV_CODEC_ID_FLV1;\n\n    st->codecpar->bits_per_coded_sample = avio_rb16(pb); /* depth */\n\n    avio_seek(pb, stsd_start, SEEK_SET);\n\n    if (ff_get_qtpalette(st->codecpar->codec_id, pb, sc->palette)) {\n        st->codecpar->bits_per_coded_sample &= 0x1F;\n        sc->has_palette = 1;\n    }\n}\n\nstatic void mov_parse_stsd_audio(MOVContext *c, AVIOContext *pb,\n                                 AVStream *st, MOVStreamContext *sc)\n{\n    int bits_per_sample, flags;\n    uint16_t version = avio_rb16(pb);\n    AVDictionaryEntry *compatible_brands = av_dict_get(c->fc->metadata, \"compatible_brands\", NULL, AV_DICT_MATCH_CASE);\n\n    avio_rb16(pb); /* revision level */\n    avio_rb32(pb); /* vendor */\n\n    st->codecpar->channels              = avio_rb16(pb); /* channel count */\n    st->codecpar->bits_per_coded_sample = avio_rb16(pb); /* sample size */\n    av_log(c->fc, AV_LOG_TRACE, \"audio channels %d\\n\", st->codecpar->channels);\n\n    sc->audio_cid = avio_rb16(pb);\n    avio_rb16(pb); /* packet size = 0 */\n\n    st->codecpar->sample_rate = ((avio_rb32(pb) >> 16));\n\n    // Read QT version 1 fields. In version 0 these do not exist.\n    av_log(c->fc, AV_LOG_TRACE, \"version =%d, isom =%d\\n\", version, c->isom);\n    if (!c->isom ||\n        (compatible_brands && strstr(compatible_brands->value, \"qt  \"))) {\n\n        if (version == 1) {\n            sc->samples_per_frame = avio_rb32(pb);\n            avio_rb32(pb); /* bytes per packet */\n            sc->bytes_per_frame = avio_rb32(pb);\n            avio_rb32(pb); /* bytes per sample */\n        } else if (version == 2) {\n            avio_rb32(pb); /* sizeof struct only */\n            st->codecpar->sample_rate = av_int2double(avio_rb64(pb));\n            st->codecpar->channels    = avio_rb32(pb);\n            avio_rb32(pb); /* always 0x7F000000 */\n            st->codecpar->bits_per_coded_sample = avio_rb32(pb);\n\n            flags = avio_rb32(pb); /* lpcm format specific flag */\n            sc->bytes_per_frame   = avio_rb32(pb);\n            sc->samples_per_frame = avio_rb32(pb);\n            if (st->codecpar->codec_tag == MKTAG('l','p','c','m'))\n                st->codecpar->codec_id =\n                    ff_mov_get_lpcm_codec_id(st->codecpar->bits_per_coded_sample,\n                                             flags);\n        }\n        if (version == 0 || (version == 1 && sc->audio_cid != -2)) {\n            /* can't correctly handle variable sized packet as audio unit */\n            switch (st->codecpar->codec_id) {\n            case AV_CODEC_ID_MP2:\n            case AV_CODEC_ID_MP3:\n                st->need_parsing = AVSTREAM_PARSE_FULL;\n                break;\n            }\n        }\n    }\n\n    if (sc->format == 0) {\n        if (st->codecpar->bits_per_coded_sample == 8)\n            st->codecpar->codec_id = mov_codec_id(st, MKTAG('r','a','w',' '));\n        else if (st->codecpar->bits_per_coded_sample == 16)\n            st->codecpar->codec_id = mov_codec_id(st, MKTAG('t','w','o','s'));\n    }\n\n    switch (st->codecpar->codec_id) {\n    case AV_CODEC_ID_PCM_S8:\n    case AV_CODEC_ID_PCM_U8:\n        if (st->codecpar->bits_per_coded_sample == 16)\n            st->codecpar->codec_id = AV_CODEC_ID_PCM_S16BE;\n        break;\n    case AV_CODEC_ID_PCM_S16LE:\n    case AV_CODEC_ID_PCM_S16BE:\n        if (st->codecpar->bits_per_coded_sample == 8)\n            st->codecpar->codec_id = AV_CODEC_ID_PCM_S8;\n        else if (st->codecpar->bits_per_coded_sample == 24)\n            st->codecpar->codec_id =\n                st->codecpar->codec_id == AV_CODEC_ID_PCM_S16BE ?\n                AV_CODEC_ID_PCM_S24BE : AV_CODEC_ID_PCM_S24LE;\n        else if (st->codecpar->bits_per_coded_sample == 32)\n             st->codecpar->codec_id =\n                st->codecpar->codec_id == AV_CODEC_ID_PCM_S16BE ?\n                AV_CODEC_ID_PCM_S32BE : AV_CODEC_ID_PCM_S32LE;\n        break;\n    /* set values for old format before stsd version 1 appeared */\n    case AV_CODEC_ID_MACE3:\n        sc->samples_per_frame = 6;\n        sc->bytes_per_frame   = 2 * st->codecpar->channels;\n        break;\n    case AV_CODEC_ID_MACE6:\n        sc->samples_per_frame = 6;\n        sc->bytes_per_frame   = 1 * st->codecpar->channels;\n        break;\n    case AV_CODEC_ID_ADPCM_IMA_QT:\n        sc->samples_per_frame = 64;\n        sc->bytes_per_frame   = 34 * st->codecpar->channels;\n        break;\n    case AV_CODEC_ID_GSM:\n        sc->samples_per_frame = 160;\n        sc->bytes_per_frame   = 33;\n        break;\n    default:\n        break;\n    }\n\n    bits_per_sample = av_get_bits_per_sample(st->codecpar->codec_id);\n    if (bits_per_sample) {\n        st->codecpar->bits_per_coded_sample = bits_per_sample;\n        sc->sample_size = (bits_per_sample >> 3) * st->codecpar->channels;\n    }\n}\n\nstatic void mov_parse_stsd_subtitle(MOVContext *c, AVIOContext *pb,\n                                    AVStream *st, MOVStreamContext *sc,\n                                    int64_t size)\n{\n    // ttxt stsd contains display flags, justification, background\n    // color, fonts, and default styles, so fake an atom to read it\n    MOVAtom fake_atom = { .size = size };\n    // mp4s contains a regular esds atom\n    if (st->codecpar->codec_tag != AV_RL32(\"mp4s\"))\n        mov_read_glbl(c, pb, fake_atom);\n    st->codecpar->width  = sc->width;\n    st->codecpar->height = sc->height;\n}\n\nstatic uint32_t yuv_to_rgba(uint32_t ycbcr)\n{\n    uint8_t r, g, b;\n    int y, cb, cr;\n\n    y  = (ycbcr >> 16) & 0xFF;\n    cr = (ycbcr >> 8)  & 0xFF;\n    cb =  ycbcr        & 0xFF;\n\n    b = av_clip_uint8((1164 * (y - 16)                     + 2018 * (cb - 128)) / 1000);\n    g = av_clip_uint8((1164 * (y - 16) -  813 * (cr - 128) -  391 * (cb - 128)) / 1000);\n    r = av_clip_uint8((1164 * (y - 16) + 1596 * (cr - 128)                    ) / 1000);\n\n    return (r << 16) | (g << 8) | b;\n}\n\nstatic int mov_rewrite_dvd_sub_extradata(AVStream *st)\n{\n    char buf[256] = {0};\n    uint8_t *src = st->codecpar->extradata;\n    int i;\n\n    if (st->codecpar->extradata_size != 64)\n        return 0;\n\n    if (st->codecpar->width > 0 &&  st->codecpar->height > 0)\n        snprintf(buf, sizeof(buf), \"size: %dx%d\\n\",\n                 st->codecpar->width, st->codecpar->height);\n    av_strlcat(buf, \"palette: \", sizeof(buf));\n\n    for (i = 0; i < 16; i++) {\n        uint32_t yuv = AV_RB32(src + i * 4);\n        uint32_t rgba = yuv_to_rgba(yuv);\n\n        av_strlcatf(buf, sizeof(buf), \"%06\"PRIx32\"%s\", rgba, i != 15 ? \", \" : \"\");\n    }\n\n    if (av_strlcat(buf, \"\\n\", sizeof(buf)) >= sizeof(buf))\n        return 0;\n\n    av_freep(&st->codecpar->extradata);\n    st->codecpar->extradata_size = 0;\n    st->codecpar->extradata = av_mallocz(strlen(buf) + AV_INPUT_BUFFER_PADDING_SIZE);\n    if (!st->codecpar->extradata)\n        return AVERROR(ENOMEM);\n    st->codecpar->extradata_size = strlen(buf);\n    memcpy(st->codecpar->extradata, buf, st->codecpar->extradata_size);\n\n    return 0;\n}\n\nstatic int mov_parse_stsd_data(MOVContext *c, AVIOContext *pb,\n                                AVStream *st, MOVStreamContext *sc,\n                                int64_t size)\n{\n    int ret;\n\n    if (st->codecpar->codec_tag == MKTAG('t','m','c','d')) {\n        if ((int)size != size)\n            return AVERROR(ENOMEM);\n\n        ret = ff_get_extradata(c->fc, st->codecpar, pb, size);\n        if (ret < 0)\n            return ret;\n        if (size > 16) {\n            MOVStreamContext *tmcd_ctx = st->priv_data;\n            int val;\n            val = AV_RB32(st->codecpar->extradata + 4);\n            tmcd_ctx->tmcd_flags = val;\n            st->avg_frame_rate.num = st->codecpar->extradata[16]; /* number of frame */\n            st->avg_frame_rate.den = 1;\n#if FF_API_LAVF_AVCTX\nFF_DISABLE_DEPRECATION_WARNINGS\n            st->codec->time_base = av_inv_q(st->avg_frame_rate);\nFF_ENABLE_DEPRECATION_WARNINGS\n#endif\n            /* adjust for per frame dur in counter mode */\n            if (tmcd_ctx->tmcd_flags & 0x0008) {\n                int timescale = AV_RB32(st->codecpar->extradata + 8);\n                int framedur = AV_RB32(st->codecpar->extradata + 12);\n                st->avg_frame_rate.num *= timescale;\n                st->avg_frame_rate.den *= framedur;\n#if FF_API_LAVF_AVCTX\nFF_DISABLE_DEPRECATION_WARNINGS\n                st->codec->time_base.den *= timescale;\n                st->codec->time_base.num *= framedur;\nFF_ENABLE_DEPRECATION_WARNINGS\n#endif\n            }\n            if (size > 30) {\n                uint32_t len = AV_RB32(st->codecpar->extradata + 18); /* name atom length */\n                uint32_t format = AV_RB32(st->codecpar->extradata + 22);\n                if (format == AV_RB32(\"name\") && (int64_t)size >= (int64_t)len + 18) {\n                    uint16_t str_size = AV_RB16(st->codecpar->extradata + 26); /* string length */\n                    if (str_size > 0 && size >= (int)str_size + 26) {\n                        char *reel_name = av_malloc(str_size + 1);\n                        if (!reel_name)\n                            return AVERROR(ENOMEM);\n                        memcpy(reel_name, st->codecpar->extradata + 30, str_size);\n                        reel_name[str_size] = 0; /* Add null terminator */\n                        /* don't add reel_name if emtpy string */\n                        if (*reel_name == 0) {\n                            av_free(reel_name);\n                        } else {\n                            av_dict_set(&st->metadata, \"reel_name\", reel_name,  AV_DICT_DONT_STRDUP_VAL);\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        /* other codec type, just skip (rtp, mp4s ...) */\n        avio_skip(pb, size);\n    }\n    return 0;\n}\n\nstatic int mov_finalize_stsd_codec(MOVContext *c, AVIOContext *pb,\n                                   AVStream *st, MOVStreamContext *sc)\n{\n    if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO &&\n        !st->codecpar->sample_rate && sc->time_scale > 1)\n        st->codecpar->sample_rate = sc->time_scale;\n\n    /* special codec parameters handling */\n    switch (st->codecpar->codec_id) {\n#if CONFIG_DV_DEMUXER\n    case AV_CODEC_ID_DVAUDIO:\n        c->dv_fctx = avformat_alloc_context();\n        if (!c->dv_fctx) {\n            av_log(c->fc, AV_LOG_ERROR, \"dv demux context alloc error\\n\");\n            return AVERROR(ENOMEM);\n        }\n        c->dv_demux = avpriv_dv_init_demux(c->dv_fctx);\n        if (!c->dv_demux) {\n            av_log(c->fc, AV_LOG_ERROR, \"dv demux context init error\\n\");\n            return AVERROR(ENOMEM);\n        }\n        sc->dv_audio_container = 1;\n        st->codecpar->codec_id    = AV_CODEC_ID_PCM_S16LE;\n        break;\n#endif\n    /* no ifdef since parameters are always those */\n    case AV_CODEC_ID_QCELP:\n        st->codecpar->channels = 1;\n        // force sample rate for qcelp when not stored in mov\n        if (st->codecpar->codec_tag != MKTAG('Q','c','l','p'))\n            st->codecpar->sample_rate = 8000;\n        // FIXME: Why is the following needed for some files?\n        sc->samples_per_frame = 160;\n        if (!sc->bytes_per_frame)\n            sc->bytes_per_frame = 35;\n        break;\n    case AV_CODEC_ID_AMR_NB:\n        st->codecpar->channels    = 1;\n        /* force sample rate for amr, stsd in 3gp does not store sample rate */\n        st->codecpar->sample_rate = 8000;\n        break;\n    case AV_CODEC_ID_AMR_WB:\n        st->codecpar->channels    = 1;\n        st->codecpar->sample_rate = 16000;\n        break;\n    case AV_CODEC_ID_MP2:\n    case AV_CODEC_ID_MP3:\n        /* force type after stsd for m1a hdlr */\n        st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n        break;\n    case AV_CODEC_ID_GSM:\n    case AV_CODEC_ID_ADPCM_MS:\n    case AV_CODEC_ID_ADPCM_IMA_WAV:\n    case AV_CODEC_ID_ILBC:\n    case AV_CODEC_ID_MACE3:\n    case AV_CODEC_ID_MACE6:\n    case AV_CODEC_ID_QDM2:\n        st->codecpar->block_align = sc->bytes_per_frame;\n        break;\n    case AV_CODEC_ID_ALAC:\n        if (st->codecpar->extradata_size == 36) {\n            st->codecpar->channels    = AV_RB8 (st->codecpar->extradata + 21);\n            st->codecpar->sample_rate = AV_RB32(st->codecpar->extradata + 32);\n        }\n        break;\n    case AV_CODEC_ID_AC3:\n    case AV_CODEC_ID_EAC3:\n    case AV_CODEC_ID_MPEG1VIDEO:\n    case AV_CODEC_ID_VC1:\n    case AV_CODEC_ID_VP9:\n        st->need_parsing = AVSTREAM_PARSE_FULL;\n        break;\n    default:\n        break;\n    }\n    return 0;\n}\n\nstatic int mov_skip_multiple_stsd(MOVContext *c, AVIOContext *pb,\n                                  int codec_tag, int format,\n                                  int64_t size)\n{\n    int video_codec_id = ff_codec_get_id(ff_codec_movvideo_tags, format);\n\n    if (codec_tag &&\n         (codec_tag != format &&\n          // AVID 1:1 samples with differing data format and codec tag exist\n          (codec_tag != AV_RL32(\"AV1x\") || format != AV_RL32(\"AVup\")) &&\n          // prores is allowed to have differing data format and codec tag\n          codec_tag != AV_RL32(\"apcn\") && codec_tag != AV_RL32(\"apch\") &&\n          // so is dv (sigh)\n          codec_tag != AV_RL32(\"dvpp\") && codec_tag != AV_RL32(\"dvcp\") &&\n          (c->fc->video_codec_id ? video_codec_id != c->fc->video_codec_id\n                                 : codec_tag != MKTAG('j','p','e','g')))) {\n        /* Multiple fourcc, we skip JPEG. This is not correct, we should\n         * export it as a separate AVStream but this needs a few changes\n         * in the MOV demuxer, patch welcome. */\n\n        av_log(c->fc, AV_LOG_WARNING, \"multiple fourcc not supported\\n\");\n        avio_skip(pb, size);\n        return 1;\n    }\n\n    return 0;\n}\n\nint ff_mov_read_stsd_entries(MOVContext *c, AVIOContext *pb, int entries)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int pseudo_stream_id;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    for (pseudo_stream_id = 0;\n         pseudo_stream_id < entries && !pb->eof_reached;\n         pseudo_stream_id++) {\n        //Parsing Sample description table\n        enum AVCodecID id;\n        int ret, dref_id = 1;\n        MOVAtom a = { AV_RL32(\"stsd\") };\n        int64_t start_pos = avio_tell(pb);\n        int64_t size    = avio_rb32(pb); /* size */\n        uint32_t format = avio_rl32(pb); /* data format */\n\n        if (size >= 16) {\n            avio_rb32(pb); /* reserved */\n            avio_rb16(pb); /* reserved */\n            dref_id = avio_rb16(pb);\n        } else if (size <= 7) {\n            av_log(c->fc, AV_LOG_ERROR,\n                   \"invalid size %\"PRId64\" in stsd\\n\", size);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (mov_skip_multiple_stsd(c, pb, st->codecpar->codec_tag, format,\n                                   size - (avio_tell(pb) - start_pos)))\n            continue;\n\n        sc->pseudo_stream_id = st->codecpar->codec_tag ? -1 : pseudo_stream_id;\n        sc->dref_id= dref_id;\n        sc->format = format;\n\n        id = mov_codec_id(st, format);\n\n        av_log(c->fc, AV_LOG_TRACE,\n               \"size=%\"PRId64\" 4CC=%s codec_type=%d\\n\", size,\n               av_fourcc2str(format), st->codecpar->codec_type);\n\n        if (st->codecpar->codec_type==AVMEDIA_TYPE_VIDEO) {\n            st->codecpar->codec_id = id;\n            mov_parse_stsd_video(c, pb, st, sc);\n        } else if (st->codecpar->codec_type==AVMEDIA_TYPE_AUDIO) {\n            st->codecpar->codec_id = id;\n            mov_parse_stsd_audio(c, pb, st, sc);\n            if (st->codecpar->sample_rate < 0) {\n                av_log(c->fc, AV_LOG_ERROR, \"Invalid sample rate %d\\n\", st->codecpar->sample_rate);\n                return AVERROR_INVALIDDATA;\n            }\n        } else if (st->codecpar->codec_type==AVMEDIA_TYPE_SUBTITLE){\n            st->codecpar->codec_id = id;\n            mov_parse_stsd_subtitle(c, pb, st, sc,\n                                    size - (avio_tell(pb) - start_pos));\n        } else {\n            ret = mov_parse_stsd_data(c, pb, st, sc,\n                                      size - (avio_tell(pb) - start_pos));\n            if (ret < 0)\n                return ret;\n        }\n        /* this will read extra atoms at the end (wave, alac, damr, avcC, hvcC, SMI ...) */\n        a.size = size - (avio_tell(pb) - start_pos);\n        if (a.size > 8) {\n            if ((ret = mov_read_default(c, pb, a)) < 0)\n                return ret;\n        } else if (a.size > 0)\n            avio_skip(pb, a.size);\n\n        if (sc->extradata && st->codecpar->extradata) {\n            int extra_size = st->codecpar->extradata_size;\n\n            /* Move the current stream extradata to the stream context one. */\n            sc->extradata_size[pseudo_stream_id] = extra_size;\n            sc->extradata[pseudo_stream_id] = av_malloc(extra_size + AV_INPUT_BUFFER_PADDING_SIZE);\n            if (!sc->extradata[pseudo_stream_id])\n                return AVERROR(ENOMEM);\n            memcpy(sc->extradata[pseudo_stream_id], st->codecpar->extradata, extra_size);\n            av_freep(&st->codecpar->extradata);\n            st->codecpar->extradata_size = 0;\n        }\n    }\n\n    if (pb->eof_reached)\n        return AVERROR_EOF;\n\n    return 0;\n}\n\nstatic int mov_read_stsd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int ret, entries;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    entries = avio_rb32(pb);\n\n    if (entries <= 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"invalid STSD entries %d\\n\", entries);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (sc->extradata) {\n        av_log(c->fc, AV_LOG_ERROR, \"Duplicate STSD\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    /* Prepare space for hosting multiple extradata. */\n    sc->extradata = av_mallocz_array(entries, sizeof(*sc->extradata));\n    sc->extradata_size = av_mallocz_array(entries, sizeof(*sc->extradata_size));\n    if (!sc->extradata_size || !sc->extradata) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n\n    ret = ff_mov_read_stsd_entries(c, pb, entries);\n    if (ret < 0)\n        return ret;\n\n    sc->stsd_count = entries;\n\n    /* Restore back the primary extradata. */\n    av_freep(&st->codecpar->extradata);\n    st->codecpar->extradata_size = sc->extradata_size[0];\n    if (sc->extradata_size[0]) {\n        st->codecpar->extradata = av_mallocz(sc->extradata_size[0] + AV_INPUT_BUFFER_PADDING_SIZE);\n        if (!st->codecpar->extradata)\n            return AVERROR(ENOMEM);\n        memcpy(st->codecpar->extradata, sc->extradata[0], sc->extradata_size[0]);\n    }\n\n    return mov_finalize_stsd_codec(c, pb, st, sc);\nfail:\n    av_freep(&sc->extradata);\n    av_freep(&sc->extradata_size);\n    return ret;\n}\n\nstatic int mov_read_stsc(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    entries = avio_rb32(pb);\n\n    av_log(c->fc, AV_LOG_TRACE, \"track[%u].stsc.entries = %u\\n\", c->fc->nb_streams - 1, entries);\n\n    if (!entries)\n        return 0;\n    if (sc->stsc_data)\n        av_log(c->fc, AV_LOG_WARNING, \"Duplicated STSC atom\\n\");\n    av_free(sc->stsc_data);\n    sc->stsc_count = 0;\n    sc->stsc_data = av_malloc_array(entries, sizeof(*sc->stsc_data));\n    if (!sc->stsc_data)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n        sc->stsc_data[i].first = avio_rb32(pb);\n        sc->stsc_data[i].count = avio_rb32(pb);\n        sc->stsc_data[i].id = avio_rb32(pb);\n    }\n\n    sc->stsc_count = i;\n\n    if (pb->eof_reached)\n        return AVERROR_EOF;\n\n    return 0;\n}\n\n#define mov_stsc_index_valid(index, count) ((index) < (count) - 1)\n\n/* Compute the samples value for the stsc entry at the given index. */\nstatic inline int mov_get_stsc_samples(MOVStreamContext *sc, int index)\n{\n    int chunk_count;\n\n    if (mov_stsc_index_valid(index, sc->stsc_count))\n        chunk_count = sc->stsc_data[index + 1].first - sc->stsc_data[index].first;\n    else\n        chunk_count = sc->chunk_count - (sc->stsc_data[index].first - 1);\n\n    return sc->stsc_data[index].count * chunk_count;\n}\n\nstatic int mov_read_stps(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned i, entries;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_rb32(pb); // version + flags\n\n    entries = avio_rb32(pb);\n    if (sc->stps_data)\n        av_log(c->fc, AV_LOG_WARNING, \"Duplicated STPS atom\\n\");\n    av_free(sc->stps_data);\n    sc->stps_count = 0;\n    sc->stps_data = av_malloc_array(entries, sizeof(*sc->stps_data));\n    if (!sc->stps_data)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n        sc->stps_data[i] = avio_rb32(pb);\n    }\n\n    sc->stps_count = i;\n\n    if (pb->eof_reached)\n        return AVERROR_EOF;\n\n    return 0;\n}\n\nstatic int mov_read_stss(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    entries = avio_rb32(pb);\n\n    av_log(c->fc, AV_LOG_TRACE, \"keyframe_count = %u\\n\", entries);\n\n    if (!entries)\n    {\n        sc->keyframe_absent = 1;\n        if (!st->need_parsing && st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO)\n            st->need_parsing = AVSTREAM_PARSE_HEADERS;\n        return 0;\n    }\n    if (sc->keyframes)\n        av_log(c->fc, AV_LOG_WARNING, \"Duplicated STSS atom\\n\");\n    if (entries >= UINT_MAX / sizeof(int))\n        return AVERROR_INVALIDDATA;\n    av_freep(&sc->keyframes);\n    sc->keyframe_count = 0;\n    sc->keyframes = av_malloc_array(entries, sizeof(*sc->keyframes));\n    if (!sc->keyframes)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n        sc->keyframes[i] = avio_rb32(pb);\n    }\n\n    sc->keyframe_count = i;\n\n    if (pb->eof_reached)\n        return AVERROR_EOF;\n\n    return 0;\n}\n\nstatic int mov_read_stsz(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries, sample_size, field_size, num_bytes;\n    GetBitContext gb;\n    unsigned char* buf;\n    int ret;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    if (atom.type == MKTAG('s','t','s','z')) {\n        sample_size = avio_rb32(pb);\n        if (!sc->sample_size) /* do not overwrite value computed in stsd */\n            sc->sample_size = sample_size;\n        sc->stsz_sample_size = sample_size;\n        field_size = 32;\n    } else {\n        sample_size = 0;\n        avio_rb24(pb); /* reserved */\n        field_size = avio_r8(pb);\n    }\n    entries = avio_rb32(pb);\n\n    av_log(c->fc, AV_LOG_TRACE, \"sample_size = %u sample_count = %u\\n\", sc->sample_size, entries);\n\n    sc->sample_count = entries;\n    if (sample_size)\n        return 0;\n\n    if (field_size != 4 && field_size != 8 && field_size != 16 && field_size != 32) {\n        av_log(c->fc, AV_LOG_ERROR, \"Invalid sample field size %u\\n\", field_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (!entries)\n        return 0;\n    if (entries >= (UINT_MAX - 4) / field_size)\n        return AVERROR_INVALIDDATA;\n    if (sc->sample_sizes)\n        av_log(c->fc, AV_LOG_WARNING, \"Duplicated STSZ atom\\n\");\n    av_free(sc->sample_sizes);\n    sc->sample_count = 0;\n    sc->sample_sizes = av_malloc_array(entries, sizeof(*sc->sample_sizes));\n    if (!sc->sample_sizes)\n        return AVERROR(ENOMEM);\n\n    num_bytes = (entries*field_size+4)>>3;\n\n    buf = av_malloc(num_bytes+AV_INPUT_BUFFER_PADDING_SIZE);\n    if (!buf) {\n        av_freep(&sc->sample_sizes);\n        return AVERROR(ENOMEM);\n    }\n\n    ret = ffio_read_size(pb, buf, num_bytes);\n    if (ret < 0) {\n        av_freep(&sc->sample_sizes);\n        av_free(buf);\n        return ret;\n    }\n\n    init_get_bits(&gb, buf, 8*num_bytes);\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n        sc->sample_sizes[i] = get_bits_long(&gb, field_size);\n        sc->data_size += sc->sample_sizes[i];\n    }\n\n    sc->sample_count = i;\n\n    av_free(buf);\n\n    if (pb->eof_reached)\n        return AVERROR_EOF;\n\n    return 0;\n}\n\nstatic int mov_read_stts(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries;\n    int64_t duration=0;\n    int64_t total_sample_count=0;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    entries = avio_rb32(pb);\n\n    av_log(c->fc, AV_LOG_TRACE, \"track[%u].stts.entries = %u\\n\",\n            c->fc->nb_streams-1, entries);\n\n    if (sc->stts_data)\n        av_log(c->fc, AV_LOG_WARNING, \"Duplicated STTS atom\\n\");\n    av_free(sc->stts_data);\n    sc->stts_count = 0;\n    sc->stts_data = av_malloc_array(entries, sizeof(*sc->stts_data));\n    if (!sc->stts_data)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n        int sample_duration;\n        int sample_count;\n\n        sample_count=avio_rb32(pb);\n        sample_duration = avio_rb32(pb);\n\n        if (sample_count < 0) {\n            av_log(c->fc, AV_LOG_ERROR, \"Invalid sample_count=%d\\n\", sample_count);\n            return AVERROR_INVALIDDATA;\n        }\n        sc->stts_data[i].count= sample_count;\n        sc->stts_data[i].duration= sample_duration;\n\n        av_log(c->fc, AV_LOG_TRACE, \"sample_count=%d, sample_duration=%d\\n\",\n                sample_count, sample_duration);\n\n        if (   i+1 == entries\n            && i\n            && sample_count == 1\n            && total_sample_count > 100\n            && sample_duration/10 > duration / total_sample_count)\n            sample_duration = duration / total_sample_count;\n        duration+=(int64_t)sample_duration*sample_count;\n        total_sample_count+=sample_count;\n    }\n\n    sc->stts_count = i;\n\n    sc->duration_for_fps  += duration;\n    sc->nb_frames_for_fps += total_sample_count;\n\n    if (pb->eof_reached)\n        return AVERROR_EOF;\n\n    st->nb_frames= total_sample_count;\n    if (duration)\n        st->duration= duration;\n    sc->track_end = duration;\n    return 0;\n}\n\nstatic void mov_update_dts_shift(MOVStreamContext *sc, int duration)\n{\n    if (duration < 0) {\n        if (duration == INT_MIN) {\n            av_log(NULL, AV_LOG_WARNING, \"mov_update_dts_shift(): dts_shift set to %d\\n\", INT_MAX);\n            duration++;\n        }\n        sc->dts_shift = FFMAX(sc->dts_shift, -duration);\n    }\n}\n\nstatic int mov_read_ctts(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, j, entries, ctts_count = 0;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    entries = avio_rb32(pb);\n\n    av_log(c->fc, AV_LOG_TRACE, \"track[%u].ctts.entries = %u\\n\", c->fc->nb_streams - 1, entries);\n\n    if (!entries)\n        return 0;\n    if (entries >= UINT_MAX / sizeof(*sc->ctts_data))\n        return AVERROR_INVALIDDATA;\n    av_freep(&sc->ctts_data);\n    sc->ctts_data = av_fast_realloc(NULL, &sc->ctts_allocated_size, entries * sizeof(*sc->ctts_data));\n    if (!sc->ctts_data)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n        int count    =avio_rb32(pb);\n        int duration =avio_rb32(pb);\n\n        if (count <= 0) {\n            av_log(c->fc, AV_LOG_TRACE,\n                   \"ignoring CTTS entry with count=%d duration=%d\\n\",\n                   count, duration);\n            continue;\n        }\n\n        /* Expand entries such that we have a 1-1 mapping with samples. */\n        for (j = 0; j < count; j++)\n            add_ctts_entry(&sc->ctts_data, &ctts_count, &sc->ctts_allocated_size, 1, duration);\n\n        av_log(c->fc, AV_LOG_TRACE, \"count=%d, duration=%d\\n\",\n                count, duration);\n\n        if (FFNABS(duration) < -(1<<28) && i+2<entries) {\n            av_log(c->fc, AV_LOG_WARNING, \"CTTS invalid\\n\");\n            av_freep(&sc->ctts_data);\n            sc->ctts_count = 0;\n            return 0;\n        }\n\n        if (i+2<entries)\n            mov_update_dts_shift(sc, duration);\n    }\n\n    sc->ctts_count = ctts_count;\n\n    if (pb->eof_reached)\n        return AVERROR_EOF;\n\n    av_log(c->fc, AV_LOG_TRACE, \"dts shift %d\\n\", sc->dts_shift);\n\n    return 0;\n}\n\nstatic int mov_read_sbgp(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries;\n    uint8_t version;\n    uint32_t grouping_type;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    version = avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    grouping_type = avio_rl32(pb);\n    if (grouping_type != MKTAG( 'r','a','p',' '))\n        return 0; /* only support 'rap ' grouping */\n    if (version == 1)\n        avio_rb32(pb); /* grouping_type_parameter */\n\n    entries = avio_rb32(pb);\n    if (!entries)\n        return 0;\n    if (sc->rap_group)\n        av_log(c->fc, AV_LOG_WARNING, \"Duplicated SBGP atom\\n\");\n    av_free(sc->rap_group);\n    sc->rap_group_count = 0;\n    sc->rap_group = av_malloc_array(entries, sizeof(*sc->rap_group));\n    if (!sc->rap_group)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n        sc->rap_group[i].count = avio_rb32(pb); /* sample_count */\n        sc->rap_group[i].index = avio_rb32(pb); /* group_description_index */\n    }\n\n    sc->rap_group_count = i;\n\n    return pb->eof_reached ? AVERROR_EOF : 0;\n}\n\n/**\n * Get ith edit list entry (media time, duration).\n */\nstatic int get_edit_list_entry(MOVContext *mov,\n                               const MOVStreamContext *msc,\n                               unsigned int edit_list_index,\n                               int64_t *edit_list_media_time,\n                               int64_t *edit_list_duration,\n                               int64_t global_timescale)\n{\n    if (edit_list_index == msc->elst_count) {\n        return 0;\n    }\n    *edit_list_media_time = msc->elst_data[edit_list_index].time;\n    *edit_list_duration = msc->elst_data[edit_list_index].duration;\n\n    /* duration is in global timescale units;convert to msc timescale */\n    if (global_timescale == 0) {\n      avpriv_request_sample(mov->fc, \"Support for mvhd.timescale = 0 with editlists\");\n      return 0;\n    }\n    *edit_list_duration = av_rescale(*edit_list_duration, msc->time_scale,\n                                     global_timescale);\n    return 1;\n}\n\n/**\n * Find the closest previous frame to the timestamp, in e_old index\n * entries. Searching for just any frame / just key frames can be controlled by\n * last argument 'flag'.\n * Returns the index of the entry in st->index_entries if successful,\n * else returns -1.\n */\nstatic int64_t find_prev_closest_index(AVStream *st,\n                                       AVIndexEntry *e_old,\n                                       int nb_old,\n                                       int64_t timestamp,\n                                       int flag)\n{\n    AVIndexEntry *e_keep = st->index_entries;\n    int nb_keep = st->nb_index_entries;\n    int64_t found = -1;\n    int64_t i = 0;\n\n    st->index_entries = e_old;\n    st->nb_index_entries = nb_old;\n    found = av_index_search_timestamp(st, timestamp, flag | AVSEEK_FLAG_BACKWARD);\n\n    // Keep going backwards in the index entries until the timestamp is the same.\n    if (found >= 0) {\n        for (i = found; i > 0 && e_old[i].timestamp == e_old[i - 1].timestamp;\n             i--) {\n            if ((flag & AVSEEK_FLAG_ANY) ||\n                (e_old[i - 1].flags & AVINDEX_KEYFRAME)) {\n                found = i - 1;\n            }\n        }\n    }\n\n    /* restore AVStream state*/\n    st->index_entries = e_keep;\n    st->nb_index_entries = nb_keep;\n    return found;\n}\n\n/**\n * Add index entry with the given values, to the end of st->index_entries.\n * Returns the new size st->index_entries if successful, else returns -1.\n *\n * This function is similar to ff_add_index_entry in libavformat/utils.c\n * except that here we are always unconditionally adding an index entry to\n * the end, instead of searching the entries list and skipping the add if\n * there is an existing entry with the same timestamp.\n * This is needed because the mov_fix_index calls this func with the same\n * unincremented timestamp for successive discarded frames.\n */\nstatic int64_t add_index_entry(AVStream *st, int64_t pos, int64_t timestamp,\n                               int size, int distance, int flags)\n{\n    AVIndexEntry *entries, *ie;\n    int64_t index = -1;\n    const size_t min_size_needed = (st->nb_index_entries + 1) * sizeof(AVIndexEntry);\n\n    // Double the allocation each time, to lower memory fragmentation.\n    // Another difference from ff_add_index_entry function.\n    const size_t requested_size =\n        min_size_needed > st->index_entries_allocated_size ?\n        FFMAX(min_size_needed, 2 * st->index_entries_allocated_size) :\n        min_size_needed;\n\n    if((unsigned)st->nb_index_entries + 1 >= UINT_MAX / sizeof(AVIndexEntry))\n        return -1;\n\n    entries = av_fast_realloc(st->index_entries,\n                              &st->index_entries_allocated_size,\n                              requested_size);\n    if(!entries)\n        return -1;\n\n    st->index_entries= entries;\n\n    index= st->nb_index_entries++;\n    ie= &entries[index];\n\n    ie->pos = pos;\n    ie->timestamp = timestamp;\n    ie->min_distance= distance;\n    ie->size= size;\n    ie->flags = flags;\n    return index;\n}\n\n/**\n * Rewrite timestamps of index entries in the range [end_index - frame_duration_buffer_size, end_index)\n * by subtracting end_ts successively by the amounts given in frame_duration_buffer.\n */\nstatic void fix_index_entry_timestamps(AVStream* st, int end_index, int64_t end_ts,\n                                       int64_t* frame_duration_buffer,\n                                       int frame_duration_buffer_size) {\n    int i = 0;\n    av_assert0(end_index >= 0 && end_index <= st->nb_index_entries);\n    for (i = 0; i < frame_duration_buffer_size; i++) {\n        end_ts -= frame_duration_buffer[frame_duration_buffer_size - 1 - i];\n        st->index_entries[end_index - 1 - i].timestamp = end_ts;\n    }\n}\n\n/**\n * Append a new ctts entry to ctts_data.\n * Returns the new ctts_count if successful, else returns -1.\n */\nstatic int64_t add_ctts_entry(MOVStts** ctts_data, unsigned int* ctts_count, unsigned int* allocated_size,\n                              int count, int duration)\n{\n    MOVStts *ctts_buf_new;\n    const size_t min_size_needed = (*ctts_count + 1) * sizeof(MOVStts);\n    const size_t requested_size =\n        min_size_needed > *allocated_size ?\n        FFMAX(min_size_needed, 2 * (*allocated_size)) :\n        min_size_needed;\n\n    if((unsigned)(*ctts_count) + 1 >= UINT_MAX / sizeof(MOVStts))\n        return -1;\n\n    ctts_buf_new = av_fast_realloc(*ctts_data, allocated_size, requested_size);\n\n    if(!ctts_buf_new)\n        return -1;\n\n    *ctts_data = ctts_buf_new;\n\n    ctts_buf_new[*ctts_count].count = count;\n    ctts_buf_new[*ctts_count].duration = duration;\n\n    *ctts_count = (*ctts_count) + 1;\n    return *ctts_count;\n}\n\nstatic void mov_current_sample_inc(MOVStreamContext *sc)\n{\n    sc->current_sample++;\n    sc->current_index++;\n    if (sc->index_ranges &&\n        sc->current_index >= sc->current_index_range->end &&\n        sc->current_index_range->end) {\n        sc->current_index_range++;\n        sc->current_index = sc->current_index_range->start;\n    }\n}\n\nstatic void mov_current_sample_dec(MOVStreamContext *sc)\n{\n    sc->current_sample--;\n    sc->current_index--;\n    if (sc->index_ranges &&\n        sc->current_index < sc->current_index_range->start &&\n        sc->current_index_range > sc->index_ranges) {\n        sc->current_index_range--;\n        sc->current_index = sc->current_index_range->end - 1;\n    }\n}\n\nstatic void mov_current_sample_set(MOVStreamContext *sc, int current_sample)\n{\n    int64_t range_size;\n\n    sc->current_sample = current_sample;\n    sc->current_index = current_sample;\n    if (!sc->index_ranges) {\n        return;\n    }\n\n    for (sc->current_index_range = sc->index_ranges;\n        sc->current_index_range->end;\n        sc->current_index_range++) {\n        range_size = sc->current_index_range->end - sc->current_index_range->start;\n        if (range_size > current_sample) {\n            sc->current_index = sc->current_index_range->start + current_sample;\n            break;\n        }\n        current_sample -= range_size;\n    }\n}\n\n/**\n * Fix st->index_entries, so that it contains only the entries (and the entries\n * which are needed to decode them) that fall in the edit list time ranges.\n * Also fixes the timestamps of the index entries to match the timeline\n * specified the edit lists.\n */\nstatic void mov_fix_index(MOVContext *mov, AVStream *st)\n{\n    MOVStreamContext *msc = st->priv_data;\n    AVIndexEntry *e_old = st->index_entries;\n    int nb_old = st->nb_index_entries;\n    const AVIndexEntry *e_old_end = e_old + nb_old;\n    const AVIndexEntry *current = NULL;\n    MOVStts *ctts_data_old = msc->ctts_data;\n    int64_t ctts_index_old = 0;\n    int64_t ctts_sample_old = 0;\n    int64_t ctts_count_old = msc->ctts_count;\n    int64_t edit_list_media_time = 0;\n    int64_t edit_list_duration = 0;\n    int64_t frame_duration = 0;\n    int64_t edit_list_dts_counter = 0;\n    int64_t edit_list_dts_entry_end = 0;\n    int64_t edit_list_start_ctts_sample = 0;\n    int64_t curr_cts;\n    int64_t curr_ctts = 0;\n    int64_t min_corrected_pts = -1;\n    int64_t empty_edits_sum_duration = 0;\n    int64_t edit_list_index = 0;\n    int64_t index;\n    int64_t index_ctts_count;\n    int flags;\n    int64_t start_dts = 0;\n    int64_t edit_list_media_time_dts = 0;\n    int64_t edit_list_start_encountered = 0;\n    int64_t search_timestamp = 0;\n    int64_t* frame_duration_buffer = NULL;\n    int num_discarded_begin = 0;\n    int first_non_zero_audio_edit = -1;\n    int packet_skip_samples = 0;\n    MOVIndexRange *current_index_range;\n    int i;\n\n    if (!msc->elst_data || msc->elst_count <= 0 || nb_old <= 0) {\n        return;\n    }\n\n    // allocate the index ranges array\n    msc->index_ranges = av_malloc((msc->elst_count + 1) * sizeof(msc->index_ranges[0]));\n    if (!msc->index_ranges) {\n        av_log(mov->fc, AV_LOG_ERROR, \"Cannot allocate index ranges buffer\\n\");\n        return;\n    }\n    msc->current_index_range = msc->index_ranges;\n    current_index_range = msc->index_ranges - 1;\n\n    // Clean AVStream from traces of old index\n    st->index_entries = NULL;\n    st->index_entries_allocated_size = 0;\n    st->nb_index_entries = 0;\n\n    // Clean ctts fields of MOVStreamContext\n    msc->ctts_data = NULL;\n    msc->ctts_count = 0;\n    msc->ctts_index = 0;\n    msc->ctts_sample = 0;\n    msc->ctts_allocated_size = 0;\n\n    // If the dts_shift is positive (in case of negative ctts values in mov),\n    // then negate the DTS by dts_shift\n    if (msc->dts_shift > 0) {\n        edit_list_dts_entry_end -= msc->dts_shift;\n        av_log(mov->fc, AV_LOG_DEBUG, \"Shifting DTS by %d because of negative CTTS.\\n\", msc->dts_shift);\n    }\n\n    start_dts = edit_list_dts_entry_end;\n\n    while (get_edit_list_entry(mov, msc, edit_list_index, &edit_list_media_time,\n                               &edit_list_duration, mov->time_scale)) {\n        av_log(mov->fc, AV_LOG_DEBUG, \"Processing st: %d, edit list %\"PRId64\" - media time: %\"PRId64\", duration: %\"PRId64\"\\n\",\n               st->index, edit_list_index, edit_list_media_time, edit_list_duration);\n        edit_list_index++;\n        edit_list_dts_counter = edit_list_dts_entry_end;\n        edit_list_dts_entry_end += edit_list_duration;\n        num_discarded_begin = 0;\n        if (edit_list_media_time == -1) {\n            empty_edits_sum_duration += edit_list_duration;\n            continue;\n        }\n\n        // If we encounter a non-negative edit list reset the skip_samples/start_pad fields and set them\n        // according to the edit list below.\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n            if (first_non_zero_audio_edit < 0) {\n                first_non_zero_audio_edit = 1;\n            } else {\n                first_non_zero_audio_edit = 0;\n            }\n\n            if (first_non_zero_audio_edit > 0)\n                st->skip_samples = msc->start_pad = 0;\n        }\n\n        //find closest previous key frame\n        edit_list_media_time_dts = edit_list_media_time;\n        if (msc->dts_shift > 0) {\n            edit_list_media_time_dts -= msc->dts_shift;\n        }\n\n        // While reordering frame index according to edit list we must handle properly\n        // the scenario when edit list entry starts from none key frame.\n        // We find closest previous key frame and preserve it and consequent frames in index.\n        // All frames which are outside edit list entry time boundaries will be dropped after decoding.\n        search_timestamp = edit_list_media_time_dts;\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n            // Audio decoders like AAC need need a decoder delay samples previous to the current sample,\n            // to correctly decode this frame. Hence for audio we seek to a frame 1 sec. before the\n            // edit_list_media_time to cover the decoder delay.\n            search_timestamp = FFMAX(search_timestamp - msc->time_scale, e_old[0].timestamp);\n        }\n\n        index = find_prev_closest_index(st, e_old, nb_old, search_timestamp, 0);\n        if (index == -1) {\n            av_log(mov->fc, AV_LOG_WARNING,\n                   \"st: %d edit list: %\"PRId64\" Missing key frame while searching for timestamp: %\"PRId64\"\\n\",\n                   st->index, edit_list_index, search_timestamp);\n            index = find_prev_closest_index(st, e_old, nb_old, search_timestamp, AVSEEK_FLAG_ANY);\n\n            if (index == -1) {\n                av_log(mov->fc, AV_LOG_WARNING,\n                       \"st: %d edit list %\"PRId64\" Cannot find an index entry before timestamp: %\"PRId64\".\\n\"\n                       \"Rounding edit list media time to zero.\\n\",\n                       st->index, edit_list_index, search_timestamp);\n                index = 0;\n                edit_list_media_time = 0;\n            }\n        }\n        current = e_old + index;\n\n        ctts_index_old = 0;\n        ctts_sample_old = 0;\n\n        // set ctts_index properly for the found key frame\n        for (index_ctts_count = 0; index_ctts_count < index; index_ctts_count++) {\n            if (ctts_data_old && ctts_index_old < ctts_count_old) {\n                ctts_sample_old++;\n                if (ctts_data_old[ctts_index_old].count == ctts_sample_old) {\n                    ctts_index_old++;\n                    ctts_sample_old = 0;\n                }\n            }\n        }\n\n        edit_list_start_ctts_sample = ctts_sample_old;\n\n        // Iterate over index and arrange it according to edit list\n        edit_list_start_encountered = 0;\n        for (; current < e_old_end; current++, index++) {\n            // check  if frame outside edit list mark it for discard\n            frame_duration = (current + 1 <  e_old_end) ?\n                             ((current + 1)->timestamp - current->timestamp) : edit_list_duration;\n\n            flags = current->flags;\n\n            // frames (pts) before or after edit list\n            curr_cts = current->timestamp + msc->dts_shift;\n            curr_ctts = 0;\n\n            if (ctts_data_old && ctts_index_old < ctts_count_old) {\n                curr_ctts = ctts_data_old[ctts_index_old].duration;\n                av_log(mov->fc, AV_LOG_DEBUG, \"stts: %\"PRId64\" ctts: %\"PRId64\", ctts_index: %\"PRId64\", ctts_count: %\"PRId64\"\\n\",\n                       curr_cts, curr_ctts, ctts_index_old, ctts_count_old);\n                curr_cts += curr_ctts;\n                ctts_sample_old++;\n                if (ctts_sample_old == ctts_data_old[ctts_index_old].count) {\n                    if (add_ctts_entry(&msc->ctts_data, &msc->ctts_count,\n                                       &msc->ctts_allocated_size,\n                                       ctts_data_old[ctts_index_old].count - edit_list_start_ctts_sample,\n                                       ctts_data_old[ctts_index_old].duration) == -1) {\n                        av_log(mov->fc, AV_LOG_ERROR, \"Cannot add CTTS entry %\"PRId64\" - {%\"PRId64\", %d}\\n\",\n                               ctts_index_old,\n                               ctts_data_old[ctts_index_old].count - edit_list_start_ctts_sample,\n                               ctts_data_old[ctts_index_old].duration);\n                        break;\n                    }\n                    ctts_index_old++;\n                    ctts_sample_old = 0;\n                    edit_list_start_ctts_sample = 0;\n                }\n            }\n\n            if (curr_cts < edit_list_media_time || curr_cts >= (edit_list_duration + edit_list_media_time)) {\n                if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO && st->codecpar->codec_id != AV_CODEC_ID_VORBIS &&\n                    curr_cts < edit_list_media_time && curr_cts + frame_duration > edit_list_media_time &&\n                    first_non_zero_audio_edit > 0) {\n                    packet_skip_samples = edit_list_media_time - curr_cts;\n                    st->skip_samples += packet_skip_samples;\n\n                    // Shift the index entry timestamp by packet_skip_samples to be correct.\n                    edit_list_dts_counter -= packet_skip_samples;\n                    if (edit_list_start_encountered == 0)  {\n                        edit_list_start_encountered = 1;\n                        // Make timestamps strictly monotonically increasing for audio, by rewriting timestamps for\n                        // discarded packets.\n                        if (frame_duration_buffer) {\n                            fix_index_entry_timestamps(st, st->nb_index_entries, edit_list_dts_counter,\n                                                       frame_duration_buffer, num_discarded_begin);\n                            av_freep(&frame_duration_buffer);\n                        }\n                    }\n\n                    av_log(mov->fc, AV_LOG_DEBUG, \"skip %d audio samples from curr_cts: %\"PRId64\"\\n\", packet_skip_samples, curr_cts);\n                } else {\n                    flags |= AVINDEX_DISCARD_FRAME;\n                    av_log(mov->fc, AV_LOG_DEBUG, \"drop a frame at curr_cts: %\"PRId64\" @ %\"PRId64\"\\n\", curr_cts, index);\n\n                    if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO && edit_list_start_encountered == 0) {\n                        num_discarded_begin++;\n                        frame_duration_buffer = av_realloc(frame_duration_buffer,\n                                                           num_discarded_begin * sizeof(int64_t));\n                        if (!frame_duration_buffer) {\n                            av_log(mov->fc, AV_LOG_ERROR, \"Cannot reallocate frame duration buffer\\n\");\n                            break;\n                        }\n                        frame_duration_buffer[num_discarded_begin - 1] = frame_duration;\n\n                        // Increment skip_samples for the first non-zero audio edit list\n                        if (first_non_zero_audio_edit > 0 && st->codecpar->codec_id != AV_CODEC_ID_VORBIS) {\n                            st->skip_samples += frame_duration;\n                            msc->start_pad = st->skip_samples;\n                        }\n                    }\n                }\n            } else {\n                if (min_corrected_pts < 0) {\n                    min_corrected_pts = edit_list_dts_counter + curr_ctts + msc->dts_shift;\n                } else {\n                    min_corrected_pts = FFMIN(min_corrected_pts, edit_list_dts_counter + curr_ctts + msc->dts_shift);\n                }\n                if (edit_list_start_encountered == 0) {\n                    edit_list_start_encountered = 1;\n                    // Make timestamps strictly monotonically increasing for audio, by rewriting timestamps for\n                    // discarded packets.\n                    if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO && frame_duration_buffer) {\n                        fix_index_entry_timestamps(st, st->nb_index_entries, edit_list_dts_counter,\n                                                   frame_duration_buffer, num_discarded_begin);\n                        av_freep(&frame_duration_buffer);\n                    }\n                }\n            }\n\n            if (add_index_entry(st, current->pos, edit_list_dts_counter, current->size,\n                                current->min_distance, flags) == -1) {\n                av_log(mov->fc, AV_LOG_ERROR, \"Cannot add index entry\\n\");\n                break;\n            }\n\n            // Update the index ranges array\n            if (current_index_range < msc->index_ranges || index != current_index_range->end) {\n                current_index_range++;\n                current_index_range->start = index;\n            }\n            current_index_range->end = index + 1;\n\n            // Only start incrementing DTS in frame_duration amounts, when we encounter a frame in edit list.\n            if (edit_list_start_encountered > 0) {\n                edit_list_dts_counter = edit_list_dts_counter + frame_duration;\n            }\n\n            // Break when found first key frame after edit entry completion\n            if (((curr_cts + frame_duration) >= (edit_list_duration + edit_list_media_time)) &&\n                ((flags & AVINDEX_KEYFRAME) || ((st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO)))) {\n\n                if (ctts_data_old && ctts_sample_old != 0) {\n                    if (add_ctts_entry(&msc->ctts_data, &msc->ctts_count,\n                                       &msc->ctts_allocated_size,\n                                       ctts_sample_old - edit_list_start_ctts_sample,\n                                       ctts_data_old[ctts_index_old].duration) == -1) {\n                        av_log(mov->fc, AV_LOG_ERROR, \"Cannot add CTTS entry %\"PRId64\" - {%\"PRId64\", %d}\\n\",\n                               ctts_index_old, ctts_sample_old - edit_list_start_ctts_sample,\n                               ctts_data_old[ctts_index_old].duration);\n                        break;\n                    }\n                }\n                break;\n            }\n        }\n    }\n    // If there are empty edits, then min_corrected_pts might be positive intentionally. So we subtract the\n    // sum duration of emtpy edits here.\n    min_corrected_pts -= empty_edits_sum_duration;\n\n    // If the minimum pts turns out to be greater than zero after fixing the index, then we subtract the\n    // dts by that amount to make the first pts zero.\n    if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO && min_corrected_pts > 0) {\n        av_log(mov->fc, AV_LOG_DEBUG, \"Offset DTS by %\"PRId64\" to make first pts zero.\\n\", min_corrected_pts);\n        for (i = 0; i < st->nb_index_entries; ++i) {\n            st->index_entries[i].timestamp -= min_corrected_pts;\n        }\n    }\n\n    // Update av stream length\n    st->duration = edit_list_dts_entry_end - start_dts;\n\n    // Free the old index and the old CTTS structures\n    av_free(e_old);\n    av_free(ctts_data_old);\n\n    // Null terminate the index ranges array\n    current_index_range++;\n    current_index_range->start = 0;\n    current_index_range->end = 0;\n    msc->current_index = msc->index_ranges[0].start;\n}\n\nstatic void mov_build_index(MOVContext *mov, AVStream *st)\n{\n    MOVStreamContext *sc = st->priv_data;\n    int64_t current_offset;\n    int64_t current_dts = 0;\n    unsigned int stts_index = 0;\n    unsigned int stsc_index = 0;\n    unsigned int stss_index = 0;\n    unsigned int stps_index = 0;\n    unsigned int i, j;\n    uint64_t stream_size = 0;\n\n    if (sc->elst_count) {\n        int i, edit_start_index = 0, multiple_edits = 0;\n        int64_t empty_duration = 0; // empty duration of the first edit list entry\n        int64_t start_time = 0; // start time of the media\n\n        for (i = 0; i < sc->elst_count; i++) {\n            const MOVElst *e = &sc->elst_data[i];\n            if (i == 0 && e->time == -1) {\n                /* if empty, the first entry is the start time of the stream\n                 * relative to the presentation itself */\n                empty_duration = e->duration;\n                edit_start_index = 1;\n            } else if (i == edit_start_index && e->time >= 0) {\n                start_time = e->time;\n            } else {\n                multiple_edits = 1;\n            }\n        }\n\n        if (multiple_edits && !mov->advanced_editlist)\n            av_log(mov->fc, AV_LOG_WARNING, \"multiple edit list entries, \"\n                   \"Use -advanced_editlist to correctly decode otherwise \"\n                   \"a/v desync might occur\\n\");\n\n        /* adjust first dts according to edit list */\n        if ((empty_duration || start_time) && mov->time_scale > 0) {\n            if (empty_duration)\n                empty_duration = av_rescale(empty_duration, sc->time_scale, mov->time_scale);\n            sc->time_offset = start_time - empty_duration;\n            if (!mov->advanced_editlist)\n                current_dts = -sc->time_offset;\n        }\n\n        if (!multiple_edits && !mov->advanced_editlist &&\n            st->codecpar->codec_id == AV_CODEC_ID_AAC && start_time > 0)\n            sc->start_pad = start_time;\n    }\n\n    /* only use old uncompressed audio chunk demuxing when stts specifies it */\n    if (!(st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO &&\n          sc->stts_count == 1 && sc->stts_data[0].duration == 1)) {\n        unsigned int current_sample = 0;\n        unsigned int stts_sample = 0;\n        unsigned int sample_size;\n        unsigned int distance = 0;\n        unsigned int rap_group_index = 0;\n        unsigned int rap_group_sample = 0;\n        int64_t last_dts = 0;\n        int64_t dts_correction = 0;\n        int rap_group_present = sc->rap_group_count && sc->rap_group;\n        int key_off = (sc->keyframe_count && sc->keyframes[0] > 0) || (sc->stps_count && sc->stps_data[0] > 0);\n\n        current_dts -= sc->dts_shift;\n        last_dts     = current_dts;\n\n        if (!sc->sample_count || st->nb_index_entries)\n            return;\n        if (sc->sample_count >= UINT_MAX / sizeof(*st->index_entries) - st->nb_index_entries)\n            return;\n        if (av_reallocp_array(&st->index_entries,\n                              st->nb_index_entries + sc->sample_count,\n                              sizeof(*st->index_entries)) < 0) {\n            st->nb_index_entries = 0;\n            return;\n        }\n        st->index_entries_allocated_size = (st->nb_index_entries + sc->sample_count) * sizeof(*st->index_entries);\n\n        for (i = 0; i < sc->chunk_count; i++) {\n            int64_t next_offset = i+1 < sc->chunk_count ? sc->chunk_offsets[i+1] : INT64_MAX;\n            current_offset = sc->chunk_offsets[i];\n            while (mov_stsc_index_valid(stsc_index, sc->stsc_count) &&\n                i + 1 == sc->stsc_data[stsc_index + 1].first)\n                stsc_index++;\n\n            if (next_offset > current_offset && sc->sample_size>0 && sc->sample_size < sc->stsz_sample_size &&\n                sc->stsc_data[stsc_index].count * (int64_t)sc->stsz_sample_size > next_offset - current_offset) {\n                av_log(mov->fc, AV_LOG_WARNING, \"STSZ sample size %d invalid (too large), ignoring\\n\", sc->stsz_sample_size);\n                sc->stsz_sample_size = sc->sample_size;\n            }\n            if (sc->stsz_sample_size>0 && sc->stsz_sample_size < sc->sample_size) {\n                av_log(mov->fc, AV_LOG_WARNING, \"STSZ sample size %d invalid (too small), ignoring\\n\", sc->stsz_sample_size);\n                sc->stsz_sample_size = sc->sample_size;\n            }\n\n            for (j = 0; j < sc->stsc_data[stsc_index].count; j++) {\n                int keyframe = 0;\n                if (current_sample >= sc->sample_count) {\n                    av_log(mov->fc, AV_LOG_ERROR, \"wrong sample count\\n\");\n                    return;\n                }\n\n                if (!sc->keyframe_absent && (!sc->keyframe_count || current_sample+key_off == sc->keyframes[stss_index])) {\n                    keyframe = 1;\n                    if (stss_index + 1 < sc->keyframe_count)\n                        stss_index++;\n                } else if (sc->stps_count && current_sample+key_off == sc->stps_data[stps_index]) {\n                    keyframe = 1;\n                    if (stps_index + 1 < sc->stps_count)\n                        stps_index++;\n                }\n                if (rap_group_present && rap_group_index < sc->rap_group_count) {\n                    if (sc->rap_group[rap_group_index].index > 0)\n                        keyframe = 1;\n                    if (++rap_group_sample == sc->rap_group[rap_group_index].count) {\n                        rap_group_sample = 0;\n                        rap_group_index++;\n                    }\n                }\n                if (sc->keyframe_absent\n                    && !sc->stps_count\n                    && !rap_group_present\n                    && (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO || (i==0 && j==0)))\n                     keyframe = 1;\n                if (keyframe)\n                    distance = 0;\n                sample_size = sc->stsz_sample_size > 0 ? sc->stsz_sample_size : sc->sample_sizes[current_sample];\n                if (sc->pseudo_stream_id == -1 ||\n                   sc->stsc_data[stsc_index].id - 1 == sc->pseudo_stream_id) {\n                    AVIndexEntry *e;\n                    if (sample_size > 0x3FFFFFFF) {\n                        av_log(mov->fc, AV_LOG_ERROR, \"Sample size %u is too large\\n\", sample_size);\n                        return;\n                    }\n                    e = &st->index_entries[st->nb_index_entries++];\n                    e->pos = current_offset;\n                    e->timestamp = current_dts;\n                    e->size = sample_size;\n                    e->min_distance = distance;\n                    e->flags = keyframe ? AVINDEX_KEYFRAME : 0;\n                    av_log(mov->fc, AV_LOG_TRACE, \"AVIndex stream %d, sample %u, offset %\"PRIx64\", dts %\"PRId64\", \"\n                            \"size %u, distance %u, keyframe %d\\n\", st->index, current_sample,\n                            current_offset, current_dts, sample_size, distance, keyframe);\n                    if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO && st->nb_index_entries < 100)\n                        ff_rfps_add_frame(mov->fc, st, current_dts);\n                }\n\n                current_offset += sample_size;\n                stream_size += sample_size;\n\n                /* A negative sample duration is invalid based on the spec,\n                 * but some samples need it to correct the DTS. */\n                if (sc->stts_data[stts_index].duration < 0) {\n                    av_log(mov->fc, AV_LOG_WARNING,\n                           \"Invalid SampleDelta %d in STTS, at %d st:%d\\n\",\n                           sc->stts_data[stts_index].duration, stts_index,\n                           st->index);\n                    dts_correction += sc->stts_data[stts_index].duration - 1;\n                    sc->stts_data[stts_index].duration = 1;\n                }\n                current_dts += sc->stts_data[stts_index].duration;\n                if (!dts_correction || current_dts + dts_correction > last_dts) {\n                    current_dts += dts_correction;\n                    dts_correction = 0;\n                } else {\n                    /* Avoid creating non-monotonous DTS */\n                    dts_correction += current_dts - last_dts - 1;\n                    current_dts = last_dts + 1;\n                }\n                last_dts = current_dts;\n                distance++;\n                stts_sample++;\n                current_sample++;\n                if (stts_index + 1 < sc->stts_count && stts_sample == sc->stts_data[stts_index].count) {\n                    stts_sample = 0;\n                    stts_index++;\n                }\n            }\n        }\n        if (st->duration > 0)\n            st->codecpar->bit_rate = stream_size*8*sc->time_scale/st->duration;\n    } else {\n        unsigned chunk_samples, total = 0;\n\n        // compute total chunk count\n        for (i = 0; i < sc->stsc_count; i++) {\n            unsigned count, chunk_count;\n\n            chunk_samples = sc->stsc_data[i].count;\n            if (i != sc->stsc_count - 1 &&\n                sc->samples_per_frame && chunk_samples % sc->samples_per_frame) {\n                av_log(mov->fc, AV_LOG_ERROR, \"error unaligned chunk\\n\");\n                return;\n            }\n\n            if (sc->samples_per_frame >= 160) { // gsm\n                count = chunk_samples / sc->samples_per_frame;\n            } else if (sc->samples_per_frame > 1) {\n                unsigned samples = (1024/sc->samples_per_frame)*sc->samples_per_frame;\n                count = (chunk_samples+samples-1) / samples;\n            } else {\n                count = (chunk_samples+1023) / 1024;\n            }\n\n            if (mov_stsc_index_valid(i, sc->stsc_count))\n                chunk_count = sc->stsc_data[i+1].first - sc->stsc_data[i].first;\n            else\n                chunk_count = sc->chunk_count - (sc->stsc_data[i].first - 1);\n            total += chunk_count * count;\n        }\n\n        av_log(mov->fc, AV_LOG_TRACE, \"chunk count %u\\n\", total);\n        if (total >= UINT_MAX / sizeof(*st->index_entries) - st->nb_index_entries)\n            return;\n        if (av_reallocp_array(&st->index_entries,\n                              st->nb_index_entries + total,\n                              sizeof(*st->index_entries)) < 0) {\n            st->nb_index_entries = 0;\n            return;\n        }\n        st->index_entries_allocated_size = (st->nb_index_entries + total) * sizeof(*st->index_entries);\n\n        // populate index\n        for (i = 0; i < sc->chunk_count; i++) {\n            current_offset = sc->chunk_offsets[i];\n            if (mov_stsc_index_valid(stsc_index, sc->stsc_count) &&\n                i + 1 == sc->stsc_data[stsc_index + 1].first)\n                stsc_index++;\n            chunk_samples = sc->stsc_data[stsc_index].count;\n\n            while (chunk_samples > 0) {\n                AVIndexEntry *e;\n                unsigned size, samples;\n\n                if (sc->samples_per_frame > 1 && !sc->bytes_per_frame) {\n                    avpriv_request_sample(mov->fc,\n                           \"Zero bytes per frame, but %d samples per frame\",\n                           sc->samples_per_frame);\n                    return;\n                }\n\n                if (sc->samples_per_frame >= 160) { // gsm\n                    samples = sc->samples_per_frame;\n                    size = sc->bytes_per_frame;\n                } else {\n                    if (sc->samples_per_frame > 1) {\n                        samples = FFMIN((1024 / sc->samples_per_frame)*\n                                        sc->samples_per_frame, chunk_samples);\n                        size = (samples / sc->samples_per_frame) * sc->bytes_per_frame;\n                    } else {\n                        samples = FFMIN(1024, chunk_samples);\n                        size = samples * sc->sample_size;\n                    }\n                }\n\n                if (st->nb_index_entries >= total) {\n                    av_log(mov->fc, AV_LOG_ERROR, \"wrong chunk count %u\\n\", total);\n                    return;\n                }\n                if (size > 0x3FFFFFFF) {\n                    av_log(mov->fc, AV_LOG_ERROR, \"Sample size %u is too large\\n\", size);\n                    return;\n                }\n                e = &st->index_entries[st->nb_index_entries++];\n                e->pos = current_offset;\n                e->timestamp = current_dts;\n                e->size = size;\n                e->min_distance = 0;\n                e->flags = AVINDEX_KEYFRAME;\n                av_log(mov->fc, AV_LOG_TRACE, \"AVIndex stream %d, chunk %u, offset %\"PRIx64\", dts %\"PRId64\", \"\n                       \"size %u, duration %u\\n\", st->index, i, current_offset, current_dts,\n                       size, samples);\n\n                current_offset += size;\n                current_dts += samples;\n                chunk_samples -= samples;\n            }\n        }\n    }\n\n    if (!mov->ignore_editlist && mov->advanced_editlist) {\n        // Fix index according to edit lists.\n        mov_fix_index(mov, st);\n    }\n}\n\nstatic int test_same_origin(const char *src, const char *ref) {\n    char src_proto[64];\n    char ref_proto[64];\n    char src_auth[256];\n    char ref_auth[256];\n    char src_host[256];\n    char ref_host[256];\n    int src_port=-1;\n    int ref_port=-1;\n\n    av_url_split(src_proto, sizeof(src_proto), src_auth, sizeof(src_auth), src_host, sizeof(src_host), &src_port, NULL, 0, src);\n    av_url_split(ref_proto, sizeof(ref_proto), ref_auth, sizeof(ref_auth), ref_host, sizeof(ref_host), &ref_port, NULL, 0, ref);\n\n    if (strlen(src) == 0) {\n        return -1;\n    } else if (strlen(src_auth) + 1 >= sizeof(src_auth) ||\n        strlen(ref_auth) + 1 >= sizeof(ref_auth) ||\n        strlen(src_host) + 1 >= sizeof(src_host) ||\n        strlen(ref_host) + 1 >= sizeof(ref_host)) {\n        return 0;\n    } else if (strcmp(src_proto, ref_proto) ||\n               strcmp(src_auth, ref_auth) ||\n               strcmp(src_host, ref_host) ||\n               src_port != ref_port) {\n        return 0;\n    } else\n        return 1;\n}\n\nstatic int mov_open_dref(MOVContext *c, AVIOContext **pb, const char *src, MOVDref *ref)\n{\n    /* try relative path, we do not try the absolute because it can leak information about our\n       system to an attacker */\n    if (ref->nlvl_to > 0 && ref->nlvl_from > 0) {\n        char filename[1025];\n        const char *src_path;\n        int i, l;\n\n        /* find a source dir */\n        src_path = strrchr(src, '/');\n        if (src_path)\n            src_path++;\n        else\n            src_path = src;\n\n        /* find a next level down to target */\n        for (i = 0, l = strlen(ref->path) - 1; l >= 0; l--)\n            if (ref->path[l] == '/') {\n                if (i == ref->nlvl_to - 1)\n                    break;\n                else\n                    i++;\n            }\n\n        /* compose filename if next level down to target was found */\n        if (i == ref->nlvl_to - 1 && src_path - src  < sizeof(filename)) {\n            memcpy(filename, src, src_path - src);\n            filename[src_path - src] = 0;\n\n            for (i = 1; i < ref->nlvl_from; i++)\n                av_strlcat(filename, \"../\", sizeof(filename));\n\n            av_strlcat(filename, ref->path + l + 1, sizeof(filename));\n            if (!c->use_absolute_path) {\n                int same_origin = test_same_origin(src, filename);\n\n                if (!same_origin) {\n                    av_log(c->fc, AV_LOG_ERROR,\n                        \"Reference with mismatching origin, %s not tried for security reasons, \"\n                        \"set demuxer option use_absolute_path to allow it anyway\\n\",\n                        ref->path);\n                    return AVERROR(ENOENT);\n                }\n\n                if(strstr(ref->path + l + 1, \"..\") ||\n                   strstr(ref->path + l + 1, \":\") ||\n                   (ref->nlvl_from > 1 && same_origin < 0) ||\n                   (filename[0] == '/' && src_path == src))\n                    return AVERROR(ENOENT);\n            }\n\n            if (strlen(filename) + 1 == sizeof(filename))\n                return AVERROR(ENOENT);\n            if (!c->fc->io_open(c->fc, pb, filename, AVIO_FLAG_READ, NULL))\n                return 0;\n        }\n    } else if (c->use_absolute_path) {\n        av_log(c->fc, AV_LOG_WARNING, \"Using absolute path on user request, \"\n               \"this is a possible security issue\\n\");\n        if (!c->fc->io_open(c->fc, pb, ref->path, AVIO_FLAG_READ, NULL))\n            return 0;\n    } else {\n        av_log(c->fc, AV_LOG_ERROR,\n               \"Absolute path %s not tried for security reasons, \"\n               \"set demuxer option use_absolute_path to allow absolute paths\\n\",\n               ref->path);\n    }\n\n    return AVERROR(ENOENT);\n}\n\nstatic void fix_timescale(MOVContext *c, MOVStreamContext *sc)\n{\n    if (sc->time_scale <= 0) {\n        av_log(c->fc, AV_LOG_WARNING, \"stream %d, timescale not set\\n\", sc->ffindex);\n        sc->time_scale = c->time_scale;\n        if (sc->time_scale <= 0)\n            sc->time_scale = 1;\n    }\n}\n\nstatic int mov_read_trak(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int ret;\n\n    st = avformat_new_stream(c->fc, NULL);\n    if (!st) return AVERROR(ENOMEM);\n    st->id = c->fc->nb_streams;\n    sc = av_mallocz(sizeof(MOVStreamContext));\n    if (!sc) return AVERROR(ENOMEM);\n\n    st->priv_data = sc;\n    st->codecpar->codec_type = AVMEDIA_TYPE_DATA;\n    sc->ffindex = st->index;\n    c->trak_index = st->index;\n\n    if ((ret = mov_read_default(c, pb, atom)) < 0)\n        return ret;\n\n    c->trak_index = -1;\n\n    /* sanity checks */\n    if ((sc->chunk_count && (!sc->stts_count || !sc->stsc_count ||\n                            (!sc->sample_size && !sc->sample_count))) ||\n        (!sc->chunk_count && sc->sample_count)) {\n        av_log(c->fc, AV_LOG_ERROR, \"stream %d, missing mandatory atoms, broken header\\n\",\n               st->index);\n        return 0;\n    }\n\n    fix_timescale(c, sc);\n\n    avpriv_set_pts_info(st, 64, 1, sc->time_scale);\n\n    mov_build_index(c, st);\n\n    if (sc->dref_id-1 < sc->drefs_count && sc->drefs[sc->dref_id-1].path) {\n        MOVDref *dref = &sc->drefs[sc->dref_id - 1];\n        if (c->enable_drefs) {\n            if (mov_open_dref(c, &sc->pb, c->fc->filename, dref) < 0)\n                av_log(c->fc, AV_LOG_ERROR,\n                       \"stream %d, error opening alias: path='%s', dir='%s', \"\n                       \"filename='%s', volume='%s', nlvl_from=%d, nlvl_to=%d\\n\",\n                       st->index, dref->path, dref->dir, dref->filename,\n                       dref->volume, dref->nlvl_from, dref->nlvl_to);\n        } else {\n            av_log(c->fc, AV_LOG_WARNING,\n                   \"Skipped opening external track: \"\n                   \"stream %d, alias: path='%s', dir='%s', \"\n                   \"filename='%s', volume='%s', nlvl_from=%d, nlvl_to=%d.\"\n                   \"Set enable_drefs to allow this.\\n\",\n                   st->index, dref->path, dref->dir, dref->filename,\n                   dref->volume, dref->nlvl_from, dref->nlvl_to);\n        }\n    } else {\n        sc->pb = c->fc->pb;\n        sc->pb_is_copied = 1;\n    }\n\n    if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n        if (!st->sample_aspect_ratio.num && st->codecpar->width && st->codecpar->height &&\n            sc->height && sc->width &&\n            (st->codecpar->width != sc->width || st->codecpar->height != sc->height)) {\n            st->sample_aspect_ratio = av_d2q(((double)st->codecpar->height * sc->width) /\n                                             ((double)st->codecpar->width * sc->height), INT_MAX);\n        }\n\n#if FF_API_R_FRAME_RATE\n        if (sc->stts_count == 1 || (sc->stts_count == 2 && sc->stts_data[1].count == 1))\n            av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den,\n                      sc->time_scale, sc->stts_data[0].duration, INT_MAX);\n#endif\n    }\n\n    // done for ai5q, ai52, ai55, ai1q, ai12 and ai15.\n    if (!st->codecpar->extradata_size && st->codecpar->codec_id == AV_CODEC_ID_H264 &&\n        TAG_IS_AVCI(st->codecpar->codec_tag)) {\n        ret = ff_generate_avci_extradata(st);\n        if (ret < 0)\n            return ret;\n    }\n\n    switch (st->codecpar->codec_id) {\n#if CONFIG_H261_DECODER\n    case AV_CODEC_ID_H261:\n#endif\n#if CONFIG_H263_DECODER\n    case AV_CODEC_ID_H263:\n#endif\n#if CONFIG_MPEG4_DECODER\n    case AV_CODEC_ID_MPEG4:\n#endif\n        st->codecpar->width = 0; /* let decoder init width/height */\n        st->codecpar->height= 0;\n        break;\n    }\n\n    // If the duration of the mp3 packets is not constant, then they could need a parser\n    if (st->codecpar->codec_id == AV_CODEC_ID_MP3\n        && sc->stts_count > 3\n        && sc->stts_count*10 > st->nb_frames\n        && sc->time_scale == st->codecpar->sample_rate) {\n            st->need_parsing = AVSTREAM_PARSE_FULL;\n    }\n    /* Do not need those anymore. */\n    av_freep(&sc->chunk_offsets);\n    av_freep(&sc->sample_sizes);\n    av_freep(&sc->keyframes);\n    av_freep(&sc->stts_data);\n    av_freep(&sc->stps_data);\n    av_freep(&sc->elst_data);\n    av_freep(&sc->rap_group);\n\n    return 0;\n}\n\nstatic int mov_read_ilst(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int ret;\n    c->itunes_metadata = 1;\n    ret = mov_read_default(c, pb, atom);\n    c->itunes_metadata = 0;\n    return ret;\n}\n\nstatic int mov_read_keys(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    uint32_t count;\n    uint32_t i;\n\n    if (atom.size < 8)\n        return 0;\n\n    avio_skip(pb, 4);\n    count = avio_rb32(pb);\n    if (count > UINT_MAX / sizeof(*c->meta_keys) - 1) {\n        av_log(c->fc, AV_LOG_ERROR,\n               \"The 'keys' atom with the invalid key count: %\"PRIu32\"\\n\", count);\n        return AVERROR_INVALIDDATA;\n    }\n\n    c->meta_keys_count = count + 1;\n    c->meta_keys = av_mallocz(c->meta_keys_count * sizeof(*c->meta_keys));\n    if (!c->meta_keys)\n        return AVERROR(ENOMEM);\n\n    for (i = 1; i <= count; ++i) {\n        uint32_t key_size = avio_rb32(pb);\n        uint32_t type = avio_rl32(pb);\n        if (key_size < 8) {\n            av_log(c->fc, AV_LOG_ERROR,\n                   \"The key# %\"PRIu32\" in meta has invalid size:\"\n                   \"%\"PRIu32\"\\n\", i, key_size);\n            return AVERROR_INVALIDDATA;\n        }\n        key_size -= 8;\n        if (type != MKTAG('m','d','t','a')) {\n            avio_skip(pb, key_size);\n        }\n        c->meta_keys[i] = av_mallocz(key_size + 1);\n        if (!c->meta_keys[i])\n            return AVERROR(ENOMEM);\n        avio_read(pb, c->meta_keys[i], key_size);\n    }\n\n    return 0;\n}\n\nstatic int mov_read_custom(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int64_t end = avio_tell(pb) + atom.size;\n    uint8_t *key = NULL, *val = NULL, *mean = NULL;\n    int i;\n    int ret = 0;\n    AVStream *st;\n    MOVStreamContext *sc;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    for (i = 0; i < 3; i++) {\n        uint8_t **p;\n        uint32_t len, tag;\n\n        if (end - avio_tell(pb) <= 12)\n            break;\n\n        len = avio_rb32(pb);\n        tag = avio_rl32(pb);\n        avio_skip(pb, 4); // flags\n\n        if (len < 12 || len - 12 > end - avio_tell(pb))\n            break;\n        len -= 12;\n\n        if (tag == MKTAG('m', 'e', 'a', 'n'))\n            p = &mean;\n        else if (tag == MKTAG('n', 'a', 'm', 'e'))\n            p = &key;\n        else if (tag == MKTAG('d', 'a', 't', 'a') && len > 4) {\n            avio_skip(pb, 4);\n            len -= 4;\n            p = &val;\n        } else\n            break;\n\n        *p = av_malloc(len + 1);\n        if (!*p)\n            break;\n        ret = ffio_read_size(pb, *p, len);\n        if (ret < 0) {\n            av_freep(p);\n            break;\n        }\n        (*p)[len] = 0;\n    }\n\n    if (mean && key && val) {\n        if (strcmp(key, \"iTunSMPB\") == 0) {\n            int priming, remainder, samples;\n            if(sscanf(val, \"%*X %X %X %X\", &priming, &remainder, &samples) == 3){\n                if(priming>0 && priming<16384)\n                    sc->start_pad = priming;\n            }\n        }\n        if (strcmp(key, \"cdec\") != 0) {\n            av_dict_set(&c->fc->metadata, key, val,\n                        AV_DICT_DONT_STRDUP_KEY | AV_DICT_DONT_STRDUP_VAL);\n            key = val = NULL;\n        }\n    } else {\n        av_log(c->fc, AV_LOG_VERBOSE,\n               \"Unhandled or malformed custom metadata of size %\"PRId64\"\\n\", atom.size);\n    }\n\n    avio_seek(pb, end, SEEK_SET);\n    av_freep(&key);\n    av_freep(&val);\n    av_freep(&mean);\n    return ret;\n}\n\nstatic int mov_read_meta(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    while (atom.size > 8) {\n        uint32_t tag = avio_rl32(pb);\n        atom.size -= 4;\n        if (tag == MKTAG('h','d','l','r')) {\n            avio_seek(pb, -8, SEEK_CUR);\n            atom.size += 8;\n            return mov_read_default(c, pb, atom);\n        }\n    }\n    return 0;\n}\n\n// return 1 when matrix is identity, 0 otherwise\n#define IS_MATRIX_IDENT(matrix)            \\\n    ( (matrix)[0][0] == (1 << 16) &&       \\\n      (matrix)[1][1] == (1 << 16) &&       \\\n      (matrix)[2][2] == (1 << 30) &&       \\\n     !(matrix)[0][1] && !(matrix)[0][2] && \\\n     !(matrix)[1][0] && !(matrix)[1][2] && \\\n     !(matrix)[2][0] && !(matrix)[2][1])\n\nstatic int mov_read_tkhd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int i, j, e;\n    int width;\n    int height;\n    int display_matrix[3][3];\n    int res_display_matrix[3][3] = { { 0 } };\n    AVStream *st;\n    MOVStreamContext *sc;\n    int version;\n    int flags;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    version = avio_r8(pb);\n    flags = avio_rb24(pb);\n    st->disposition |= (flags & MOV_TKHD_FLAG_ENABLED) ? AV_DISPOSITION_DEFAULT : 0;\n\n    if (version == 1) {\n        avio_rb64(pb);\n        avio_rb64(pb);\n    } else {\n        avio_rb32(pb); /* creation time */\n        avio_rb32(pb); /* modification time */\n    }\n    st->id = (int)avio_rb32(pb); /* track id (NOT 0 !)*/\n    avio_rb32(pb); /* reserved */\n\n    /* highlevel (considering edits) duration in movie timebase */\n    (version == 1) ? avio_rb64(pb) : avio_rb32(pb);\n    avio_rb32(pb); /* reserved */\n    avio_rb32(pb); /* reserved */\n\n    avio_rb16(pb); /* layer */\n    avio_rb16(pb); /* alternate group */\n    avio_rb16(pb); /* volume */\n    avio_rb16(pb); /* reserved */\n\n    //read in the display matrix (outlined in ISO 14496-12, Section 6.2.2)\n    // they're kept in fixed point format through all calculations\n    // save u,v,z to store the whole matrix in the AV_PKT_DATA_DISPLAYMATRIX\n    // side data, but the scale factor is not needed to calculate aspect ratio\n    for (i = 0; i < 3; i++) {\n        display_matrix[i][0] = avio_rb32(pb);   // 16.16 fixed point\n        display_matrix[i][1] = avio_rb32(pb);   // 16.16 fixed point\n        display_matrix[i][2] = avio_rb32(pb);   //  2.30 fixed point\n    }\n\n    width = avio_rb32(pb);       // 16.16 fixed point track width\n    height = avio_rb32(pb);      // 16.16 fixed point track height\n    sc->width = width >> 16;\n    sc->height = height >> 16;\n\n    // apply the moov display matrix (after the tkhd one)\n    for (i = 0; i < 3; i++) {\n        const int sh[3] = { 16, 16, 30 };\n        for (j = 0; j < 3; j++) {\n            for (e = 0; e < 3; e++) {\n                res_display_matrix[i][j] +=\n                    ((int64_t) display_matrix[i][e] *\n                     c->movie_display_matrix[e][j]) >> sh[e];\n            }\n        }\n    }\n\n    // save the matrix when it is not the default identity\n    if (!IS_MATRIX_IDENT(res_display_matrix)) {\n        double rotate;\n\n        av_freep(&sc->display_matrix);\n        sc->display_matrix = av_malloc(sizeof(int32_t) * 9);\n        if (!sc->display_matrix)\n            return AVERROR(ENOMEM);\n\n        for (i = 0; i < 3; i++)\n            for (j = 0; j < 3; j++)\n                sc->display_matrix[i * 3 + j] = res_display_matrix[i][j];\n\n#if FF_API_OLD_ROTATE_API\n        rotate = av_display_rotation_get(sc->display_matrix);\n        if (!isnan(rotate)) {\n            char rotate_buf[64];\n            rotate = -rotate;\n            if (rotate < 0) // for backward compatibility\n                rotate += 360;\n            snprintf(rotate_buf, sizeof(rotate_buf), \"%g\", rotate);\n            av_dict_set(&st->metadata, \"rotate\", rotate_buf, 0);\n        }\n#endif\n    }\n\n    // transform the display width/height according to the matrix\n    // to keep the same scale, use [width height 1<<16]\n    if (width && height && sc->display_matrix) {\n        double disp_transform[2];\n\n        for (i = 0; i < 2; i++)\n            disp_transform[i] = hypot(sc->display_matrix[0 + i],\n                                      sc->display_matrix[3 + i]);\n\n        if (disp_transform[0] > 0       && disp_transform[1] > 0 &&\n            disp_transform[0] < (1<<24) && disp_transform[1] < (1<<24) &&\n            fabs((disp_transform[0] / disp_transform[1]) - 1.0) > 0.01)\n            st->sample_aspect_ratio = av_d2q(\n                disp_transform[0] / disp_transform[1],\n                INT_MAX);\n    }\n    return 0;\n}\n\nstatic int mov_read_tfhd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVFragment *frag = &c->fragment;\n    MOVTrackExt *trex = NULL;\n    MOVFragmentIndex* index = NULL;\n    int flags, track_id, i, found = 0;\n\n    avio_r8(pb); /* version */\n    flags = avio_rb24(pb);\n\n    track_id = avio_rb32(pb);\n    if (!track_id)\n        return AVERROR_INVALIDDATA;\n    frag->track_id = track_id;\n    for (i = 0; i < c->trex_count; i++)\n        if (c->trex_data[i].track_id == frag->track_id) {\n            trex = &c->trex_data[i];\n            break;\n        }\n    if (!trex) {\n        av_log(c->fc, AV_LOG_ERROR, \"could not find corresponding trex\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    frag->base_data_offset = flags & MOV_TFHD_BASE_DATA_OFFSET ?\n                             avio_rb64(pb) : flags & MOV_TFHD_DEFAULT_BASE_IS_MOOF ?\n                             frag->moof_offset : frag->implicit_offset;\n    frag->stsd_id  = flags & MOV_TFHD_STSD_ID ? avio_rb32(pb) : trex->stsd_id;\n\n    frag->duration = flags & MOV_TFHD_DEFAULT_DURATION ?\n                     avio_rb32(pb) : trex->duration;\n    frag->size     = flags & MOV_TFHD_DEFAULT_SIZE ?\n                     avio_rb32(pb) : trex->size;\n    frag->flags    = flags & MOV_TFHD_DEFAULT_FLAGS ?\n                     avio_rb32(pb) : trex->flags;\n    frag->time     = AV_NOPTS_VALUE;\n    for (i = 0; i < c->fragment_index_count; i++) {\n        int j;\n        MOVFragmentIndex* candidate = c->fragment_index_data[i];\n        if (candidate->track_id == frag->track_id) {\n            av_log(c->fc, AV_LOG_DEBUG,\n                   \"found fragment index for track %u\\n\", frag->track_id);\n            index = candidate;\n            for (j = index->current_item; j < index->item_count; j++) {\n                if (frag->implicit_offset == index->items[j].moof_offset) {\n                    av_log(c->fc, AV_LOG_DEBUG, \"found fragment index entry \"\n                            \"for track %u and moof_offset %\"PRId64\"\\n\",\n                            frag->track_id, index->items[j].moof_offset);\n                    frag->time = index->items[j].time;\n                    index->current_item = j + 1;\n                    found = 1;\n                    break;\n                }\n            }\n            if (found)\n                break;\n        }\n    }\n    if (index && !found) {\n        av_log(c->fc, AV_LOG_DEBUG, \"track %u has a fragment index but \"\n               \"it doesn't have an (in-order) entry for moof_offset \"\n               \"%\"PRId64\"\\n\", frag->track_id, frag->implicit_offset);\n    }\n    av_log(c->fc, AV_LOG_TRACE, \"frag flags 0x%x\\n\", frag->flags);\n    return 0;\n}\n\nstatic int mov_read_chap(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    unsigned i, num;\n    void *new_tracks;\n\n    num = atom.size / 4;\n    if (!(new_tracks = av_malloc_array(num, sizeof(int))))\n        return AVERROR(ENOMEM);\n\n    av_free(c->chapter_tracks);\n    c->chapter_tracks = new_tracks;\n    c->nb_chapter_tracks = num;\n\n    for (i = 0; i < num && !pb->eof_reached; i++)\n        c->chapter_tracks[i] = avio_rb32(pb);\n\n    return 0;\n}\n\nstatic int mov_read_trex(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVTrackExt *trex;\n    int err;\n\n    if ((uint64_t)c->trex_count+1 >= UINT_MAX / sizeof(*c->trex_data))\n        return AVERROR_INVALIDDATA;\n    if ((err = av_reallocp_array(&c->trex_data, c->trex_count + 1,\n                                 sizeof(*c->trex_data))) < 0) {\n        c->trex_count = 0;\n        return err;\n    }\n\n    c->fc->duration = AV_NOPTS_VALUE; // the duration from mvhd is not representing the whole file when fragments are used.\n\n    trex = &c->trex_data[c->trex_count++];\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    trex->track_id = avio_rb32(pb);\n    trex->stsd_id  = avio_rb32(pb);\n    trex->duration = avio_rb32(pb);\n    trex->size     = avio_rb32(pb);\n    trex->flags    = avio_rb32(pb);\n    return 0;\n}\n\nstatic int mov_read_tfdt(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVFragment *frag = &c->fragment;\n    AVStream *st = NULL;\n    MOVStreamContext *sc;\n    int version, i;\n\n    for (i = 0; i < c->fc->nb_streams; i++) {\n        if (c->fc->streams[i]->id == frag->track_id) {\n            st = c->fc->streams[i];\n            break;\n        }\n    }\n    if (!st) {\n        av_log(c->fc, AV_LOG_ERROR, \"could not find corresponding track id %u\\n\", frag->track_id);\n        return AVERROR_INVALIDDATA;\n    }\n    sc = st->priv_data;\n    if (sc->pseudo_stream_id + 1 != frag->stsd_id)\n        return 0;\n    version = avio_r8(pb);\n    avio_rb24(pb); /* flags */\n    if (version) {\n        sc->track_end = avio_rb64(pb);\n    } else {\n        sc->track_end = avio_rb32(pb);\n    }\n    return 0;\n}\n\nstatic int mov_read_trun(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVFragment *frag = &c->fragment;\n    AVStream *st = NULL;\n    MOVStreamContext *sc;\n    MOVStts *ctts_data;\n    uint64_t offset;\n    int64_t dts;\n    int data_offset = 0;\n    unsigned entries, first_sample_flags = frag->flags;\n    int flags, distance, i;\n\n    for (i = 0; i < c->fc->nb_streams; i++) {\n        if (c->fc->streams[i]->id == frag->track_id) {\n            st = c->fc->streams[i];\n            break;\n        }\n    }\n    if (!st) {\n        av_log(c->fc, AV_LOG_ERROR, \"could not find corresponding track id %u\\n\", frag->track_id);\n        return AVERROR_INVALIDDATA;\n    }\n    sc = st->priv_data;\n    if (sc->pseudo_stream_id+1 != frag->stsd_id && sc->pseudo_stream_id != -1)\n        return 0;\n    avio_r8(pb); /* version */\n    flags = avio_rb24(pb);\n    entries = avio_rb32(pb);\n    av_log(c->fc, AV_LOG_TRACE, \"flags 0x%x entries %u\\n\", flags, entries);\n\n    if ((uint64_t)entries+sc->ctts_count >= UINT_MAX/sizeof(*sc->ctts_data))\n        return AVERROR_INVALIDDATA;\n    if (flags & MOV_TRUN_DATA_OFFSET)        data_offset        = avio_rb32(pb);\n    if (flags & MOV_TRUN_FIRST_SAMPLE_FLAGS) first_sample_flags = avio_rb32(pb);\n    dts    = sc->track_end - sc->time_offset;\n    offset = frag->base_data_offset + data_offset;\n    distance = 0;\n    av_log(c->fc, AV_LOG_TRACE, \"first sample flags 0x%x\\n\", first_sample_flags);\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n        unsigned sample_size = frag->size;\n        int sample_flags = i ? frag->flags : first_sample_flags;\n        unsigned sample_duration = frag->duration;\n        unsigned ctts_duration = 0;\n        int keyframe = 0;\n        int ctts_index = 0;\n        int old_nb_index_entries = st->nb_index_entries;\n\n        if (flags & MOV_TRUN_SAMPLE_DURATION) sample_duration = avio_rb32(pb);\n        if (flags & MOV_TRUN_SAMPLE_SIZE)     sample_size     = avio_rb32(pb);\n        if (flags & MOV_TRUN_SAMPLE_FLAGS)    sample_flags    = avio_rb32(pb);\n        if (flags & MOV_TRUN_SAMPLE_CTS)      ctts_duration   = avio_rb32(pb);\n\n        mov_update_dts_shift(sc, ctts_duration);\n        if (frag->time != AV_NOPTS_VALUE) {\n            if (c->use_mfra_for == FF_MOV_FLAG_MFRA_PTS) {\n                int64_t pts = frag->time;\n                av_log(c->fc, AV_LOG_DEBUG, \"found frag time %\"PRId64\n                        \" sc->dts_shift %d ctts.duration %d\"\n                        \" sc->time_offset %\"PRId64\" flags & MOV_TRUN_SAMPLE_CTS %d\\n\", pts,\n                        sc->dts_shift, ctts_duration,\n                        sc->time_offset, flags & MOV_TRUN_SAMPLE_CTS);\n                dts = pts - sc->dts_shift;\n                if (flags & MOV_TRUN_SAMPLE_CTS) {\n                    dts -= ctts_duration;\n                } else {\n                    dts -= sc->time_offset;\n                }\n                av_log(c->fc, AV_LOG_DEBUG, \"calculated into dts %\"PRId64\"\\n\", dts);\n            } else {\n                dts = frag->time - sc->time_offset;\n                av_log(c->fc, AV_LOG_DEBUG, \"found frag time %\"PRId64\n                        \", using it for dts\\n\", dts);\n            }\n            frag->time = AV_NOPTS_VALUE;\n        }\n\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO)\n            keyframe = 1;\n        else\n            keyframe =\n                !(sample_flags & (MOV_FRAG_SAMPLE_FLAG_IS_NON_SYNC |\n                                  MOV_FRAG_SAMPLE_FLAG_DEPENDS_YES));\n        if (keyframe)\n            distance = 0;\n        ctts_index = av_add_index_entry(st, offset, dts, sample_size, distance,\n                                        keyframe ? AVINDEX_KEYFRAME : 0);\n        if (ctts_index >= 0 && old_nb_index_entries < st->nb_index_entries) {\n            unsigned int size_needed = st->nb_index_entries * sizeof(*sc->ctts_data);\n            unsigned int request_size = size_needed > sc->ctts_allocated_size ?\n                FFMAX(size_needed, 2 * sc->ctts_allocated_size) : size_needed;\n            unsigned int old_ctts_size = sc->ctts_allocated_size;\n            ctts_data = av_fast_realloc(sc->ctts_data, &sc->ctts_allocated_size, request_size);\n            if (!ctts_data) {\n                av_freep(&sc->ctts_data);\n                return AVERROR(ENOMEM);\n            }\n            sc->ctts_data = ctts_data;\n\n            // In case there were samples without ctts entries, ensure they get\n            // zero valued entries. This ensures clips which mix boxes with and\n            // without ctts entries don't pickup uninitialized data.\n            memset((uint8_t*)(sc->ctts_data) + old_ctts_size, 0, sc->ctts_allocated_size - old_ctts_size);\n\n            if (ctts_index != old_nb_index_entries) {\n                memmove(sc->ctts_data + ctts_index + 1, sc->ctts_data + ctts_index,\n                        sizeof(*sc->ctts_data) * (sc->ctts_count - ctts_index));\n                if (ctts_index <= sc->current_sample) {\n                    // if we inserted a new item before the current sample, move the\n                    // counter ahead so it is still pointing to the same sample.\n                    sc->current_sample++;\n                }\n            }\n\n            sc->ctts_data[ctts_index].count = 1;\n            sc->ctts_data[ctts_index].duration = ctts_duration;\n            sc->ctts_count++;\n        } else {\n            av_log(c->fc, AV_LOG_ERROR, \"Failed to add index entry\\n\");\n        }\n\n        av_log(c->fc, AV_LOG_TRACE, \"AVIndex stream %d, sample %d, offset %\"PRIx64\", dts %\"PRId64\", \"\n                \"size %u, distance %d, keyframe %d\\n\", st->index, ctts_index,\n                offset, dts, sample_size, distance, keyframe);\n        distance++;\n        dts += sample_duration;\n        offset += sample_size;\n        sc->data_size += sample_size;\n        sc->duration_for_fps += sample_duration;\n        sc->nb_frames_for_fps ++;\n    }\n\n    if (pb->eof_reached)\n        return AVERROR_EOF;\n\n    frag->implicit_offset = offset;\n\n    sc->track_end = dts + sc->time_offset;\n    if (st->duration < sc->track_end)\n        st->duration = sc->track_end;\n\n    return 0;\n}\n\nstatic int mov_read_sidx(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int64_t offset = avio_tell(pb) + atom.size, pts;\n    uint8_t version;\n    unsigned i, track_id;\n    AVStream *st = NULL;\n    AVStream *ref_st = NULL;\n    MOVStreamContext *sc, *ref_sc = NULL;\n    MOVFragmentIndex *index = NULL;\n    MOVFragmentIndex **tmp;\n    AVRational timescale;\n\n    version = avio_r8(pb);\n    if (version > 1) {\n        avpriv_request_sample(c->fc, \"sidx version %u\", version);\n        return 0;\n    }\n\n    avio_rb24(pb); // flags\n\n    track_id = avio_rb32(pb); // Reference ID\n    for (i = 0; i < c->fc->nb_streams; i++) {\n        if (c->fc->streams[i]->id == track_id) {\n            st = c->fc->streams[i];\n            break;\n        }\n    }\n    if (!st) {\n        av_log(c->fc, AV_LOG_WARNING, \"could not find corresponding track id %d\\n\", track_id);\n        return 0;\n    }\n\n    sc = st->priv_data;\n\n    timescale = av_make_q(1, avio_rb32(pb));\n\n    if (timescale.den <= 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"Invalid sidx timescale 1/%d\\n\", timescale.den);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (version == 0) {\n        pts = avio_rb32(pb);\n        offset += avio_rb32(pb);\n    } else {\n        pts = avio_rb64(pb);\n        offset += avio_rb64(pb);\n    }\n\n    avio_rb16(pb); // reserved\n\n    index = av_mallocz(sizeof(MOVFragmentIndex));\n    if (!index)\n        return AVERROR(ENOMEM);\n\n    index->track_id = track_id;\n\n    index->item_count = avio_rb16(pb);\n    index->items = av_mallocz_array(index->item_count, sizeof(MOVFragmentIndexItem));\n\n    if (!index->items) {\n        av_freep(&index);\n        return AVERROR(ENOMEM);\n    }\n\n    for (i = 0; i < index->item_count; i++) {\n        uint32_t size = avio_rb32(pb);\n        uint32_t duration = avio_rb32(pb);\n        if (size & 0x80000000) {\n            avpriv_request_sample(c->fc, \"sidx reference_type 1\");\n            av_freep(&index->items);\n            av_freep(&index);\n            return AVERROR_PATCHWELCOME;\n        }\n        avio_rb32(pb); // sap_flags\n        index->items[i].moof_offset = offset;\n        index->items[i].time = av_rescale_q(pts, st->time_base, timescale);\n        offset += size;\n        pts += duration;\n    }\n\n    st->duration = sc->track_end = pts;\n\n    tmp = av_realloc_array(c->fragment_index_data,\n                           c->fragment_index_count + 1,\n                           sizeof(MOVFragmentIndex*));\n    if (!tmp) {\n        av_freep(&index->items);\n        av_freep(&index);\n        return AVERROR(ENOMEM);\n    }\n\n    c->fragment_index_data = tmp;\n    c->fragment_index_data[c->fragment_index_count++] = index;\n    sc->has_sidx = 1;\n\n    if (offset == avio_size(pb)) {\n        for (i = 0; i < c->fc->nb_streams; i++) {\n            if (c->fc->streams[i]->id == c->fragment_index_data[0]->track_id) {\n                ref_st = c->fc->streams[i];\n                ref_sc = ref_st->priv_data;\n                break;\n            }\n        }\n        for (i = 0; i < c->fc->nb_streams; i++) {\n            st = c->fc->streams[i];\n            sc = st->priv_data;\n            if (!sc->has_sidx) {\n                st->duration = sc->track_end = av_rescale(ref_st->duration, sc->time_scale, ref_sc->time_scale);\n            }\n        }\n\n        c->fragment_index_complete = 1;\n    }\n\n    return 0;\n}\n\n/* this atom should be null (from specs), but some buggy files put the 'moov' atom inside it... */\n/* like the files created with Adobe Premiere 5.0, for samples see */\n/* http://graphics.tudelft.nl/~wouter/publications/soundtests/ */\nstatic int mov_read_wide(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int err;\n\n    if (atom.size < 8)\n        return 0; /* continue */\n    if (avio_rb32(pb) != 0) { /* 0 sized mdat atom... use the 'wide' atom size */\n        avio_skip(pb, atom.size - 4);\n        return 0;\n    }\n    atom.type = avio_rl32(pb);\n    atom.size -= 8;\n    if (atom.type != MKTAG('m','d','a','t')) {\n        avio_skip(pb, atom.size);\n        return 0;\n    }\n    err = mov_read_mdat(c, pb, atom);\n    return err;\n}\n\nstatic int mov_read_cmov(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n#if CONFIG_ZLIB\n    AVIOContext ctx;\n    uint8_t *cmov_data;\n    uint8_t *moov_data; /* uncompressed data */\n    long cmov_len, moov_len;\n    int ret = -1;\n\n    avio_rb32(pb); /* dcom atom */\n    if (avio_rl32(pb) != MKTAG('d','c','o','m'))\n        return AVERROR_INVALIDDATA;\n    if (avio_rl32(pb) != MKTAG('z','l','i','b')) {\n        av_log(c->fc, AV_LOG_ERROR, \"unknown compression for cmov atom !\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    avio_rb32(pb); /* cmvd atom */\n    if (avio_rl32(pb) != MKTAG('c','m','v','d'))\n        return AVERROR_INVALIDDATA;\n    moov_len = avio_rb32(pb); /* uncompressed size */\n    cmov_len = atom.size - 6 * 4;\n\n    cmov_data = av_malloc(cmov_len);\n    if (!cmov_data)\n        return AVERROR(ENOMEM);\n    moov_data = av_malloc(moov_len);\n    if (!moov_data) {\n        av_free(cmov_data);\n        return AVERROR(ENOMEM);\n    }\n    ret = ffio_read_size(pb, cmov_data, cmov_len);\n    if (ret < 0)\n        goto free_and_return;\n\n    if (uncompress (moov_data, (uLongf *) &moov_len, (const Bytef *)cmov_data, cmov_len) != Z_OK)\n        goto free_and_return;\n    if (ffio_init_context(&ctx, moov_data, moov_len, 0, NULL, NULL, NULL, NULL) != 0)\n        goto free_and_return;\n    ctx.seekable = AVIO_SEEKABLE_NORMAL;\n    atom.type = MKTAG('m','o','o','v');\n    atom.size = moov_len;\n    ret = mov_read_default(c, &ctx, atom);\nfree_and_return:\n    av_free(moov_data);\n    av_free(cmov_data);\n    return ret;\n#else\n    av_log(c->fc, AV_LOG_ERROR, \"this file requires zlib support compiled in\\n\");\n    return AVERROR(ENOSYS);\n#endif\n}\n\n/* edit list atom */\nstatic int mov_read_elst(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVStreamContext *sc;\n    int i, edit_count, version;\n\n    if (c->fc->nb_streams < 1 || c->ignore_editlist)\n        return 0;\n    sc = c->fc->streams[c->fc->nb_streams-1]->priv_data;\n\n    version = avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    edit_count = avio_rb32(pb); /* entries */\n\n    if (!edit_count)\n        return 0;\n    if (sc->elst_data)\n        av_log(c->fc, AV_LOG_WARNING, \"Duplicated ELST atom\\n\");\n    av_free(sc->elst_data);\n    sc->elst_count = 0;\n    sc->elst_data = av_malloc_array(edit_count, sizeof(*sc->elst_data));\n    if (!sc->elst_data)\n        return AVERROR(ENOMEM);\n\n    av_log(c->fc, AV_LOG_TRACE, \"track[%u].edit_count = %i\\n\", c->fc->nb_streams - 1, edit_count);\n    for (i = 0; i < edit_count && !pb->eof_reached; i++) {\n        MOVElst *e = &sc->elst_data[i];\n\n        if (version == 1) {\n            e->duration = avio_rb64(pb);\n            e->time     = avio_rb64(pb);\n        } else {\n            e->duration = avio_rb32(pb); /* segment duration */\n            e->time     = (int32_t)avio_rb32(pb); /* media time */\n        }\n        e->rate = avio_rb32(pb) / 65536.0;\n        av_log(c->fc, AV_LOG_TRACE, \"duration=%\"PRId64\" time=%\"PRId64\" rate=%f\\n\",\n               e->duration, e->time, e->rate);\n\n        if (e->time < 0 && e->time != -1 &&\n            c->fc->strict_std_compliance >= FF_COMPLIANCE_STRICT) {\n            av_log(c->fc, AV_LOG_ERROR, \"Track %d, edit %d: Invalid edit list media time=%\"PRId64\"\\n\",\n                   c->fc->nb_streams-1, i, e->time);\n            return AVERROR_INVALIDDATA;\n        }\n    }\n    sc->elst_count = i;\n\n    return 0;\n}\n\nstatic int mov_read_tmcd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVStreamContext *sc;\n\n    if (c->fc->nb_streams < 1)\n        return AVERROR_INVALIDDATA;\n    sc = c->fc->streams[c->fc->nb_streams - 1]->priv_data;\n    sc->timecode_track = avio_rb32(pb);\n    return 0;\n}\n\nstatic int mov_read_vpcc(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int version, color_range, color_primaries, color_trc, color_space;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams - 1];\n\n    if (atom.size < 5) {\n        av_log(c->fc, AV_LOG_ERROR, \"Empty VP Codec Configuration box\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    version = avio_r8(pb);\n    if (version != 1) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unsupported VP Codec Configuration box version %d\\n\", version);\n        return 0;\n    }\n    avio_skip(pb, 3); /* flags */\n\n    avio_skip(pb, 2); /* profile + level */\n    color_range     = avio_r8(pb); /* bitDepth, chromaSubsampling, videoFullRangeFlag */\n    color_primaries = avio_r8(pb);\n    color_trc       = avio_r8(pb);\n    color_space     = avio_r8(pb);\n    if (avio_rb16(pb)) /* codecIntializationDataSize */\n        return AVERROR_INVALIDDATA;\n\n    if (!av_color_primaries_name(color_primaries))\n        color_primaries = AVCOL_PRI_UNSPECIFIED;\n    if (!av_color_transfer_name(color_trc))\n        color_trc = AVCOL_TRC_UNSPECIFIED;\n    if (!av_color_space_name(color_space))\n        color_space = AVCOL_SPC_UNSPECIFIED;\n\n    st->codecpar->color_range     = (color_range & 1) ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG;\n    st->codecpar->color_primaries = color_primaries;\n    st->codecpar->color_trc       = color_trc;\n    st->codecpar->color_space     = color_space;\n\n    return 0;\n}\n\nstatic int mov_read_smdm(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVStreamContext *sc;\n    const int chroma_den = 50000;\n    const int luma_den = 10000;\n    int i, j, version;\n\n    if (c->fc->nb_streams < 1)\n        return AVERROR_INVALIDDATA;\n\n    sc = c->fc->streams[c->fc->nb_streams - 1]->priv_data;\n\n    if (atom.size < 5) {\n        av_log(c->fc, AV_LOG_ERROR, \"Empty Mastering Display Metadata box\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    version = avio_r8(pb);\n    if (version) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unsupported Mastering Display Metadata box version %d\\n\", version);\n        return 0;\n    }\n    avio_skip(pb, 3); /* flags */\n\n    sc->mastering = av_mastering_display_metadata_alloc();\n    if (!sc->mastering)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < 3; i++)\n        for (j = 0; j < 2; j++)\n            sc->mastering->display_primaries[i][j] =\n                av_make_q(lrint(((double)avio_rb16(pb) / (1 << 16)) * chroma_den), chroma_den);\n    for (i = 0; i < 2; i++)\n        sc->mastering->white_point[i] =\n            av_make_q(lrint(((double)avio_rb16(pb) / (1 << 16)) * chroma_den), chroma_den);\n    sc->mastering->max_luminance =\n        av_make_q(lrint(((double)avio_rb32(pb) / (1 <<  8)) * luma_den), luma_den);\n    sc->mastering->min_luminance =\n        av_make_q(lrint(((double)avio_rb32(pb) / (1 << 14)) * luma_den), luma_den);\n\n    sc->mastering->has_primaries = 1;\n    sc->mastering->has_luminance = 1;\n\n    return 0;\n}\n\nstatic int mov_read_coll(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVStreamContext *sc;\n    int version;\n\n    if (c->fc->nb_streams < 1)\n        return AVERROR_INVALIDDATA;\n\n    sc = c->fc->streams[c->fc->nb_streams - 1]->priv_data;\n\n    if (atom.size < 5) {\n        av_log(c->fc, AV_LOG_ERROR, \"Empty Content Light Level box\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    version = avio_r8(pb);\n    if (version) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unsupported Content Light Level box version %d\\n\", version);\n        return 0;\n    }\n    avio_skip(pb, 3); /* flags */\n\n    sc->coll = av_content_light_metadata_alloc(&sc->coll_size);\n    if (!sc->coll)\n        return AVERROR(ENOMEM);\n\n    sc->coll->MaxCLL  = avio_rb16(pb);\n    sc->coll->MaxFALL = avio_rb16(pb);\n\n    return 0;\n}\n\nstatic int mov_read_st3d(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    enum AVStereo3DType type;\n    int mode;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    sc = st->priv_data;\n\n    if (atom.size < 5) {\n        av_log(c->fc, AV_LOG_ERROR, \"Empty stereoscopic video box\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    avio_skip(pb, 4); /* version + flags */\n\n    mode = avio_r8(pb);\n    switch (mode) {\n    case 0:\n        type = AV_STEREO3D_2D;\n        break;\n    case 1:\n        type = AV_STEREO3D_TOPBOTTOM;\n        break;\n    case 2:\n        type = AV_STEREO3D_SIDEBYSIDE;\n        break;\n    default:\n        av_log(c->fc, AV_LOG_WARNING, \"Unknown st3d mode value %d\\n\", mode);\n        return 0;\n    }\n\n    sc->stereo3d = av_stereo3d_alloc();\n    if (!sc->stereo3d)\n        return AVERROR(ENOMEM);\n\n    sc->stereo3d->type = type;\n    return 0;\n}\n\nstatic int mov_read_sv3d(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int size, layout;\n    int32_t yaw, pitch, roll;\n    uint32_t l = 0, t = 0, r = 0, b = 0;\n    uint32_t tag, padding = 0;\n    enum AVSphericalProjection projection;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    sc = st->priv_data;\n\n    if (atom.size < 8) {\n        av_log(c->fc, AV_LOG_ERROR, \"Empty spherical video box\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    size = avio_rb32(pb);\n    if (size <= 12 || size > atom.size)\n        return AVERROR_INVALIDDATA;\n\n    tag = avio_rl32(pb);\n    if (tag != MKTAG('s','v','h','d')) {\n        av_log(c->fc, AV_LOG_ERROR, \"Missing spherical video header\\n\");\n        return 0;\n    }\n    avio_skip(pb, 4); /*  version + flags */\n    avio_skip(pb, size - 12); /* metadata_source */\n\n    size = avio_rb32(pb);\n    if (size > atom.size)\n        return AVERROR_INVALIDDATA;\n\n    tag = avio_rl32(pb);\n    if (tag != MKTAG('p','r','o','j')) {\n        av_log(c->fc, AV_LOG_ERROR, \"Missing projection box\\n\");\n        return 0;\n    }\n\n    size = avio_rb32(pb);\n    if (size > atom.size)\n        return AVERROR_INVALIDDATA;\n\n    tag = avio_rl32(pb);\n    if (tag != MKTAG('p','r','h','d')) {\n        av_log(c->fc, AV_LOG_ERROR, \"Missing projection header box\\n\");\n        return 0;\n    }\n    avio_skip(pb, 4); /*  version + flags */\n\n    /* 16.16 fixed point */\n    yaw   = avio_rb32(pb);\n    pitch = avio_rb32(pb);\n    roll  = avio_rb32(pb);\n\n    size = avio_rb32(pb);\n    if (size > atom.size)\n        return AVERROR_INVALIDDATA;\n\n    tag = avio_rl32(pb);\n    avio_skip(pb, 4); /*  version + flags */\n    switch (tag) {\n    case MKTAG('c','b','m','p'):\n        layout = avio_rb32(pb);\n        if (layout) {\n            av_log(c->fc, AV_LOG_WARNING,\n                   \"Unsupported cubemap layout %d\\n\", layout);\n            return 0;\n        }\n        projection = AV_SPHERICAL_CUBEMAP;\n        padding = avio_rb32(pb);\n        break;\n    case MKTAG('e','q','u','i'):\n        t = avio_rb32(pb);\n        b = avio_rb32(pb);\n        l = avio_rb32(pb);\n        r = avio_rb32(pb);\n\n        if (b >= UINT_MAX - t || r >= UINT_MAX - l) {\n            av_log(c->fc, AV_LOG_ERROR,\n                   \"Invalid bounding rectangle coordinates \"\n                   \"%\"PRIu32\",%\"PRIu32\",%\"PRIu32\",%\"PRIu32\"\\n\", l, t, r, b);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (l || t || r || b)\n            projection = AV_SPHERICAL_EQUIRECTANGULAR_TILE;\n        else\n            projection = AV_SPHERICAL_EQUIRECTANGULAR;\n        break;\n    default:\n        av_log(c->fc, AV_LOG_ERROR, \"Unknown projection type\\n\");\n        return 0;\n    }\n\n    sc->spherical = av_spherical_alloc(&sc->spherical_size);\n    if (!sc->spherical)\n        return AVERROR(ENOMEM);\n\n    sc->spherical->projection = projection;\n\n    sc->spherical->yaw   = yaw;\n    sc->spherical->pitch = pitch;\n    sc->spherical->roll  = roll;\n\n    sc->spherical->padding = padding;\n\n    sc->spherical->bound_left   = l;\n    sc->spherical->bound_top    = t;\n    sc->spherical->bound_right  = r;\n    sc->spherical->bound_bottom = b;\n\n    return 0;\n}\n\nstatic int mov_parse_uuid_spherical(MOVStreamContext *sc, AVIOContext *pb, size_t len)\n{\n    int ret = 0;\n    uint8_t *buffer = av_malloc(len + 1);\n    const char *val;\n\n    if (!buffer)\n        return AVERROR(ENOMEM);\n    buffer[len] = '\\0';\n\n    ret = ffio_read_size(pb, buffer, len);\n    if (ret < 0)\n        goto out;\n\n    /* Check for mandatory keys and values, try to support XML as best-effort */\n    if (av_stristr(buffer, \"<GSpherical:StitchingSoftware>\") &&\n        (val = av_stristr(buffer, \"<GSpherical:Spherical>\")) &&\n        av_stristr(val, \"true\") &&\n        (val = av_stristr(buffer, \"<GSpherical:Stitched>\")) &&\n        av_stristr(val, \"true\") &&\n        (val = av_stristr(buffer, \"<GSpherical:ProjectionType>\")) &&\n        av_stristr(val, \"equirectangular\")) {\n        sc->spherical = av_spherical_alloc(&sc->spherical_size);\n        if (!sc->spherical)\n            goto out;\n\n        sc->spherical->projection = AV_SPHERICAL_EQUIRECTANGULAR;\n\n        if (av_stristr(buffer, \"<GSpherical:StereoMode>\")) {\n            enum AVStereo3DType mode;\n\n            if (av_stristr(buffer, \"left-right\"))\n                mode = AV_STEREO3D_SIDEBYSIDE;\n            else if (av_stristr(buffer, \"top-bottom\"))\n                mode = AV_STEREO3D_TOPBOTTOM;\n            else\n                mode = AV_STEREO3D_2D;\n\n            sc->stereo3d = av_stereo3d_alloc();\n            if (!sc->stereo3d)\n                goto out;\n\n            sc->stereo3d->type = mode;\n        }\n\n        /* orientation */\n        val = av_stristr(buffer, \"<GSpherical:InitialViewHeadingDegrees>\");\n        if (val)\n            sc->spherical->yaw = strtol(val, NULL, 10) * (1 << 16);\n        val = av_stristr(buffer, \"<GSpherical:InitialViewPitchDegrees>\");\n        if (val)\n            sc->spherical->pitch = strtol(val, NULL, 10) * (1 << 16);\n        val = av_stristr(buffer, \"<GSpherical:InitialViewRollDegrees>\");\n        if (val)\n            sc->spherical->roll = strtol(val, NULL, 10) * (1 << 16);\n    }\n\nout:\n    av_free(buffer);\n    return ret;\n}\n\nstatic int mov_read_uuid(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int64_t ret;\n    uint8_t uuid[16];\n    static const uint8_t uuid_isml_manifest[] = {\n        0xa5, 0xd4, 0x0b, 0x30, 0xe8, 0x14, 0x11, 0xdd,\n        0xba, 0x2f, 0x08, 0x00, 0x20, 0x0c, 0x9a, 0x66\n    };\n    static const uint8_t uuid_xmp[] = {\n        0xbe, 0x7a, 0xcf, 0xcb, 0x97, 0xa9, 0x42, 0xe8,\n        0x9c, 0x71, 0x99, 0x94, 0x91, 0xe3, 0xaf, 0xac\n    };\n    static const uint8_t uuid_spherical[] = {\n        0xff, 0xcc, 0x82, 0x63, 0xf8, 0x55, 0x4a, 0x93,\n        0x88, 0x14, 0x58, 0x7a, 0x02, 0x52, 0x1f, 0xdd,\n    };\n\n    if (atom.size < sizeof(uuid) || atom.size >= FFMIN(INT_MAX, SIZE_MAX))\n        return AVERROR_INVALIDDATA;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    sc = st->priv_data;\n\n    ret = avio_read(pb, uuid, sizeof(uuid));\n    if (ret < 0) {\n        return ret;\n    } else if (ret != sizeof(uuid)) {\n        return AVERROR_INVALIDDATA;\n    }\n    if (!memcmp(uuid, uuid_isml_manifest, sizeof(uuid))) {\n        uint8_t *buffer, *ptr;\n        char *endptr;\n        size_t len = atom.size - sizeof(uuid);\n\n        if (len < 4) {\n            return AVERROR_INVALIDDATA;\n        }\n        ret = avio_skip(pb, 4); // zeroes\n        len -= 4;\n\n        buffer = av_mallocz(len + 1);\n        if (!buffer) {\n            return AVERROR(ENOMEM);\n        }\n        ret = avio_read(pb, buffer, len);\n        if (ret < 0) {\n            av_free(buffer);\n            return ret;\n        } else if (ret != len) {\n            av_free(buffer);\n            return AVERROR_INVALIDDATA;\n        }\n\n        ptr = buffer;\n        while ((ptr = av_stristr(ptr, \"systemBitrate=\\\"\"))) {\n            ptr += sizeof(\"systemBitrate=\\\"\") - 1;\n            c->bitrates_count++;\n            c->bitrates = av_realloc_f(c->bitrates, c->bitrates_count, sizeof(*c->bitrates));\n            if (!c->bitrates) {\n                c->bitrates_count = 0;\n                av_free(buffer);\n                return AVERROR(ENOMEM);\n            }\n            errno = 0;\n            ret = strtol(ptr, &endptr, 10);\n            if (ret < 0 || errno || *endptr != '\"') {\n                c->bitrates[c->bitrates_count - 1] = 0;\n            } else {\n                c->bitrates[c->bitrates_count - 1] = ret;\n            }\n        }\n\n        av_free(buffer);\n    } else if (!memcmp(uuid, uuid_xmp, sizeof(uuid))) {\n        uint8_t *buffer;\n        size_t len = atom.size - sizeof(uuid);\n        if (c->export_xmp) {\n            buffer = av_mallocz(len + 1);\n            if (!buffer) {\n                return AVERROR(ENOMEM);\n            }\n            ret = avio_read(pb, buffer, len);\n            if (ret < 0) {\n                av_free(buffer);\n                return ret;\n            } else if (ret != len) {\n                av_free(buffer);\n                return AVERROR_INVALIDDATA;\n            }\n            buffer[len] = '\\0';\n            av_dict_set(&c->fc->metadata, \"xmp\", buffer, 0);\n            av_free(buffer);\n        } else {\n            // skip all uuid atom, which makes it fast for long uuid-xmp file\n            ret = avio_skip(pb, len);\n            if (ret < 0)\n                return ret;\n        }\n    } else if (!memcmp(uuid, uuid_spherical, sizeof(uuid))) {\n        size_t len = atom.size - sizeof(uuid);\n        ret = mov_parse_uuid_spherical(sc, pb, len);\n        if (ret < 0)\n            return ret;\n        if (!sc->spherical)\n            av_log(c->fc, AV_LOG_WARNING, \"Invalid spherical metadata found\\n\");    }\n\n    return 0;\n}\n\nstatic int mov_read_free(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int ret;\n    uint8_t content[16];\n\n    if (atom.size < 8)\n        return 0;\n\n    ret = avio_read(pb, content, FFMIN(sizeof(content), atom.size));\n    if (ret < 0)\n        return ret;\n\n    if (   !c->found_moov\n        && !c->found_mdat\n        && !memcmp(content, \"Anevia\\x1A\\x1A\", 8)\n        && c->use_mfra_for == FF_MOV_FLAG_MFRA_AUTO) {\n        c->use_mfra_for = FF_MOV_FLAG_MFRA_PTS;\n    }\n\n    return 0;\n}\n\nstatic int mov_read_frma(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    uint32_t format = avio_rl32(pb);\n    MOVStreamContext *sc;\n    enum AVCodecID id;\n    AVStream *st;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    sc = st->priv_data;\n\n    switch (sc->format)\n    {\n    case MKTAG('e','n','c','v'):        // encrypted video\n    case MKTAG('e','n','c','a'):        // encrypted audio\n        id = mov_codec_id(st, format);\n        if (st->codecpar->codec_id != AV_CODEC_ID_NONE &&\n            st->codecpar->codec_id != id) {\n            av_log(c->fc, AV_LOG_WARNING,\n                   \"ignoring 'frma' atom of '%.4s', stream has codec id %d\\n\",\n                   (char*)&format, st->codecpar->codec_id);\n            break;\n        }\n\n        st->codecpar->codec_id = id;\n        sc->format = format;\n        break;\n\n    default:\n        if (format != sc->format) {\n            av_log(c->fc, AV_LOG_WARNING,\n                   \"ignoring 'frma' atom of '%.4s', stream format is '%.4s'\\n\",\n                   (char*)&format, (char*)&sc->format);\n        }\n        break;\n    }\n\n    return 0;\n}\n\nstatic int mov_read_senc(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    size_t auxiliary_info_size;\n\n    if (c->decryption_key_len == 0 || c->fc->nb_streams < 1)\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    sc = st->priv_data;\n\n    if (sc->cenc.aes_ctr) {\n        av_log(c->fc, AV_LOG_ERROR, \"duplicate senc atom\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    avio_r8(pb); /* version */\n    sc->cenc.use_subsamples = avio_rb24(pb) & 0x02; /* flags */\n\n    avio_rb32(pb);        /* entries */\n\n    if (atom.size < 8 || atom.size > FFMIN(INT_MAX, SIZE_MAX)) {\n        av_log(c->fc, AV_LOG_ERROR, \"senc atom size %\"PRId64\" invalid\\n\", atom.size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* save the auxiliary info as is */\n    auxiliary_info_size = atom.size - 8;\n\n    sc->cenc.auxiliary_info = av_malloc(auxiliary_info_size);\n    if (!sc->cenc.auxiliary_info) {\n        return AVERROR(ENOMEM);\n    }\n\n    sc->cenc.auxiliary_info_end = sc->cenc.auxiliary_info + auxiliary_info_size;\n    sc->cenc.auxiliary_info_pos = sc->cenc.auxiliary_info;\n    sc->cenc.auxiliary_info_index = 0;\n\n    if (avio_read(pb, sc->cenc.auxiliary_info, auxiliary_info_size) != auxiliary_info_size) {\n        av_log(c->fc, AV_LOG_ERROR, \"failed to read the auxiliary info\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* initialize the cipher */\n    sc->cenc.aes_ctr = av_aes_ctr_alloc();\n    if (!sc->cenc.aes_ctr) {\n        return AVERROR(ENOMEM);\n    }\n\n    return av_aes_ctr_init(sc->cenc.aes_ctr, c->decryption_key);\n}\n\nstatic int mov_read_saiz(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    size_t data_size;\n    int atom_header_size;\n    int flags;\n\n    if (c->decryption_key_len == 0 || c->fc->nb_streams < 1)\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    sc = st->priv_data;\n\n    if (sc->cenc.auxiliary_info_sizes || sc->cenc.auxiliary_info_default_size) {\n        av_log(c->fc, AV_LOG_ERROR, \"duplicate saiz atom\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    atom_header_size = 9;\n\n    avio_r8(pb); /* version */\n    flags = avio_rb24(pb);\n\n    if ((flags & 0x01) != 0) {\n        atom_header_size += 8;\n\n        avio_rb32(pb);    /* info type */\n        avio_rb32(pb);    /* info type param */\n    }\n\n    sc->cenc.auxiliary_info_default_size = avio_r8(pb);\n    avio_rb32(pb);    /* entries */\n\n    if (atom.size <= atom_header_size) {\n        return 0;\n    }\n\n    if (atom.size > FFMIN(INT_MAX, SIZE_MAX)) {\n        av_log(c->fc, AV_LOG_ERROR, \"saiz atom auxiliary_info_sizes size %\"PRId64\" invalid\\n\", atom.size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* save the auxiliary info sizes as is */\n    data_size = atom.size - atom_header_size;\n\n    sc->cenc.auxiliary_info_sizes = av_malloc(data_size);\n    if (!sc->cenc.auxiliary_info_sizes) {\n        return AVERROR(ENOMEM);\n    }\n\n    sc->cenc.auxiliary_info_sizes_count = data_size;\n\n    if (avio_read(pb, sc->cenc.auxiliary_info_sizes, data_size) != data_size) {\n        av_log(c->fc, AV_LOG_ERROR, \"failed to read the auxiliary info sizes\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    return 0;\n}\n\nstatic int mov_read_dfla(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int last, type, size, ret;\n    uint8_t buf[4];\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if ((uint64_t)atom.size > (1<<30) || atom.size < 42)\n        return AVERROR_INVALIDDATA;\n\n    /* Check FlacSpecificBox version. */\n    if (avio_r8(pb) != 0)\n        return AVERROR_INVALIDDATA;\n\n    avio_rb24(pb); /* Flags */\n\n    avio_read(pb, buf, sizeof(buf));\n    flac_parse_block_header(buf, &last, &type, &size);\n\n    if (type != FLAC_METADATA_TYPE_STREAMINFO || size != FLAC_STREAMINFO_SIZE) {\n        av_log(c->fc, AV_LOG_ERROR, \"STREAMINFO must be first FLACMetadataBlock\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    ret = ff_get_extradata(c->fc, st->codecpar, pb, size);\n    if (ret < 0)\n        return ret;\n\n    if (!last)\n        av_log(c->fc, AV_LOG_WARNING, \"non-STREAMINFO FLACMetadataBlock(s) ignored\\n\");\n\n    return 0;\n}\n\nstatic int mov_seek_auxiliary_info(MOVContext *c, MOVStreamContext *sc, int64_t index)\n{\n    size_t auxiliary_info_seek_offset = 0;\n    int i;\n\n    if (sc->cenc.auxiliary_info_default_size) {\n        auxiliary_info_seek_offset = (size_t)sc->cenc.auxiliary_info_default_size * index;\n    } else if (sc->cenc.auxiliary_info_sizes) {\n        if (index > sc->cenc.auxiliary_info_sizes_count) {\n            av_log(c, AV_LOG_ERROR, \"current sample %\"PRId64\" greater than the number of auxiliary info sample sizes %\"SIZE_SPECIFIER\"\\n\",\n                index, sc->cenc.auxiliary_info_sizes_count);\n            return AVERROR_INVALIDDATA;\n        }\n\n        for (i = 0; i < index; i++) {\n            auxiliary_info_seek_offset += sc->cenc.auxiliary_info_sizes[i];\n        }\n    }\n\n    if (auxiliary_info_seek_offset > sc->cenc.auxiliary_info_end - sc->cenc.auxiliary_info) {\n        av_log(c, AV_LOG_ERROR, \"auxiliary info offset %\"SIZE_SPECIFIER\" greater than auxiliary info size %\"SIZE_SPECIFIER\"\\n\",\n            auxiliary_info_seek_offset, (size_t)(sc->cenc.auxiliary_info_end - sc->cenc.auxiliary_info));\n        return AVERROR_INVALIDDATA;\n    }\n\n    sc->cenc.auxiliary_info_pos = sc->cenc.auxiliary_info + auxiliary_info_seek_offset;\n    sc->cenc.auxiliary_info_index = index;\n    return 0;\n}\n\nstatic int cenc_filter(MOVContext *c, MOVStreamContext *sc, int64_t index, uint8_t *input, int size)\n{\n    uint32_t encrypted_bytes;\n    uint16_t subsample_count;\n    uint16_t clear_bytes;\n    uint8_t* input_end = input + size;\n    int ret;\n\n    if (index != sc->cenc.auxiliary_info_index) {\n        ret = mov_seek_auxiliary_info(c, sc, index);\n        if (ret < 0) {\n            return ret;\n        }\n    }\n\n    /* read the iv */\n    if (AES_CTR_IV_SIZE > sc->cenc.auxiliary_info_end - sc->cenc.auxiliary_info_pos) {\n        av_log(c->fc, AV_LOG_ERROR, \"failed to read iv from the auxiliary info\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    av_aes_ctr_set_iv(sc->cenc.aes_ctr, sc->cenc.auxiliary_info_pos);\n    sc->cenc.auxiliary_info_pos += AES_CTR_IV_SIZE;\n\n    if (!sc->cenc.use_subsamples)\n    {\n        /* decrypt the whole packet */\n        av_aes_ctr_crypt(sc->cenc.aes_ctr, input, input, size);\n        return 0;\n    }\n\n    /* read the subsample count */\n    if (sizeof(uint16_t) > sc->cenc.auxiliary_info_end - sc->cenc.auxiliary_info_pos) {\n        av_log(c->fc, AV_LOG_ERROR, \"failed to read subsample count from the auxiliary info\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    subsample_count = AV_RB16(sc->cenc.auxiliary_info_pos);\n    sc->cenc.auxiliary_info_pos += sizeof(uint16_t);\n\n    for (; subsample_count > 0; subsample_count--)\n    {\n        if (6 > sc->cenc.auxiliary_info_end - sc->cenc.auxiliary_info_pos) {\n            av_log(c->fc, AV_LOG_ERROR, \"failed to read subsample from the auxiliary info\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        /* read the number of clear / encrypted bytes */\n        clear_bytes = AV_RB16(sc->cenc.auxiliary_info_pos);\n        sc->cenc.auxiliary_info_pos += sizeof(uint16_t);\n        encrypted_bytes = AV_RB32(sc->cenc.auxiliary_info_pos);\n        sc->cenc.auxiliary_info_pos += sizeof(uint32_t);\n\n        if ((uint64_t)clear_bytes + encrypted_bytes > input_end - input) {\n            av_log(c->fc, AV_LOG_ERROR, \"subsample size exceeds the packet size left\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        /* skip the clear bytes */\n        input += clear_bytes;\n\n        /* decrypt the encrypted bytes */\n        av_aes_ctr_crypt(sc->cenc.aes_ctr, input, input, encrypted_bytes);\n        input += encrypted_bytes;\n    }\n\n    if (input < input_end) {\n        av_log(c->fc, AV_LOG_ERROR, \"leftover packet bytes after subsample processing\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    sc->cenc.auxiliary_info_index++;\n    return 0;\n}\n\nstatic int mov_read_dops(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    const int OPUS_SEEK_PREROLL_MS = 80;\n    AVStream *st;\n    size_t size;\n    int16_t pre_skip;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if ((uint64_t)atom.size > (1<<30) || atom.size < 11)\n        return AVERROR_INVALIDDATA;\n\n    /* Check OpusSpecificBox version. */\n    if (avio_r8(pb) != 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"unsupported OpusSpecificBox version\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* OpusSpecificBox size plus magic for Ogg OpusHead header. */\n    size = atom.size + 8;\n\n    if (ff_alloc_extradata(st->codecpar, size))\n        return AVERROR(ENOMEM);\n\n    AV_WL32(st->codecpar->extradata, MKTAG('O','p','u','s'));\n    AV_WL32(st->codecpar->extradata + 4, MKTAG('H','e','a','d'));\n    AV_WB8(st->codecpar->extradata + 8, 1); /* OpusHead version */\n    avio_read(pb, st->codecpar->extradata + 9, size - 9);\n\n    /* OpusSpecificBox is stored in big-endian, but OpusHead is\n       little-endian; aside from the preceeding magic and version they're\n       otherwise currently identical.  Data after output gain at offset 16\n       doesn't need to be bytewapped. */\n    pre_skip = AV_RB16(st->codecpar->extradata + 10);\n    AV_WL16(st->codecpar->extradata + 10, pre_skip);\n    AV_WL32(st->codecpar->extradata + 12, AV_RB32(st->codecpar->extradata + 12));\n    AV_WL16(st->codecpar->extradata + 16, AV_RB16(st->codecpar->extradata + 16));\n\n    st->codecpar->initial_padding = pre_skip;\n    st->codecpar->seek_preroll = av_rescale_q(OPUS_SEEK_PREROLL_MS,\n                                              (AVRational){1, 1000},\n                                              (AVRational){1, 48000});\n\n    return 0;\n}\n\nstatic const MOVParseTableEntry mov_default_parse_table[] = {\n{ MKTAG('A','C','L','R'), mov_read_aclr },\n{ MKTAG('A','P','R','G'), mov_read_avid },\n{ MKTAG('A','A','L','P'), mov_read_avid },\n{ MKTAG('A','R','E','S'), mov_read_ares },\n{ MKTAG('a','v','s','s'), mov_read_avss },\n{ MKTAG('c','h','p','l'), mov_read_chpl },\n{ MKTAG('c','o','6','4'), mov_read_stco },\n{ MKTAG('c','o','l','r'), mov_read_colr },\n{ MKTAG('c','t','t','s'), mov_read_ctts }, /* composition time to sample */\n{ MKTAG('d','i','n','f'), mov_read_default },\n{ MKTAG('D','p','x','E'), mov_read_dpxe },\n{ MKTAG('d','r','e','f'), mov_read_dref },\n{ MKTAG('e','d','t','s'), mov_read_default },\n{ MKTAG('e','l','s','t'), mov_read_elst },\n{ MKTAG('e','n','d','a'), mov_read_enda },\n{ MKTAG('f','i','e','l'), mov_read_fiel },\n{ MKTAG('a','d','r','m'), mov_read_adrm },\n{ MKTAG('f','t','y','p'), mov_read_ftyp },\n{ MKTAG('g','l','b','l'), mov_read_glbl },\n{ MKTAG('h','d','l','r'), mov_read_hdlr },\n{ MKTAG('i','l','s','t'), mov_read_ilst },\n{ MKTAG('j','p','2','h'), mov_read_jp2h },\n{ MKTAG('m','d','a','t'), mov_read_mdat },\n{ MKTAG('m','d','h','d'), mov_read_mdhd },\n{ MKTAG('m','d','i','a'), mov_read_default },\n{ MKTAG('m','e','t','a'), mov_read_meta },\n{ MKTAG('m','i','n','f'), mov_read_default },\n{ MKTAG('m','o','o','f'), mov_read_moof },\n{ MKTAG('m','o','o','v'), mov_read_moov },\n{ MKTAG('m','v','e','x'), mov_read_default },\n{ MKTAG('m','v','h','d'), mov_read_mvhd },\n{ MKTAG('S','M','I',' '), mov_read_svq3 },\n{ MKTAG('a','l','a','c'), mov_read_alac }, /* alac specific atom */\n{ MKTAG('a','v','c','C'), mov_read_glbl },\n{ MKTAG('p','a','s','p'), mov_read_pasp },\n{ MKTAG('s','i','d','x'), mov_read_sidx },\n{ MKTAG('s','t','b','l'), mov_read_default },\n{ MKTAG('s','t','c','o'), mov_read_stco },\n{ MKTAG('s','t','p','s'), mov_read_stps },\n{ MKTAG('s','t','r','f'), mov_read_strf },\n{ MKTAG('s','t','s','c'), mov_read_stsc },\n{ MKTAG('s','t','s','d'), mov_read_stsd }, /* sample description */\n{ MKTAG('s','t','s','s'), mov_read_stss }, /* sync sample */\n{ MKTAG('s','t','s','z'), mov_read_stsz }, /* sample size */\n{ MKTAG('s','t','t','s'), mov_read_stts },\n{ MKTAG('s','t','z','2'), mov_read_stsz }, /* compact sample size */\n{ MKTAG('t','k','h','d'), mov_read_tkhd }, /* track header */\n{ MKTAG('t','f','d','t'), mov_read_tfdt },\n{ MKTAG('t','f','h','d'), mov_read_tfhd }, /* track fragment header */\n{ MKTAG('t','r','a','k'), mov_read_trak },\n{ MKTAG('t','r','a','f'), mov_read_default },\n{ MKTAG('t','r','e','f'), mov_read_default },\n{ MKTAG('t','m','c','d'), mov_read_tmcd },\n{ MKTAG('c','h','a','p'), mov_read_chap },\n{ MKTAG('t','r','e','x'), mov_read_trex },\n{ MKTAG('t','r','u','n'), mov_read_trun },\n{ MKTAG('u','d','t','a'), mov_read_default },\n{ MKTAG('w','a','v','e'), mov_read_wave },\n{ MKTAG('e','s','d','s'), mov_read_esds },\n{ MKTAG('d','a','c','3'), mov_read_dac3 }, /* AC-3 info */\n{ MKTAG('d','e','c','3'), mov_read_dec3 }, /* EAC-3 info */\n{ MKTAG('d','d','t','s'), mov_read_ddts }, /* DTS audio descriptor */\n{ MKTAG('w','i','d','e'), mov_read_wide }, /* place holder */\n{ MKTAG('w','f','e','x'), mov_read_wfex },\n{ MKTAG('c','m','o','v'), mov_read_cmov },\n{ MKTAG('c','h','a','n'), mov_read_chan }, /* channel layout */\n{ MKTAG('d','v','c','1'), mov_read_dvc1 },\n{ MKTAG('s','b','g','p'), mov_read_sbgp },\n{ MKTAG('h','v','c','C'), mov_read_glbl },\n{ MKTAG('u','u','i','d'), mov_read_uuid },\n{ MKTAG('C','i','n', 0x8e), mov_read_targa_y216 },\n{ MKTAG('f','r','e','e'), mov_read_free },\n{ MKTAG('-','-','-','-'), mov_read_custom },\n{ MKTAG('s','i','n','f'), mov_read_default },\n{ MKTAG('f','r','m','a'), mov_read_frma },\n{ MKTAG('s','e','n','c'), mov_read_senc },\n{ MKTAG('s','a','i','z'), mov_read_saiz },\n{ MKTAG('d','f','L','a'), mov_read_dfla },\n{ MKTAG('s','t','3','d'), mov_read_st3d }, /* stereoscopic 3D video box */\n{ MKTAG('s','v','3','d'), mov_read_sv3d }, /* spherical video box */\n{ MKTAG('d','O','p','s'), mov_read_dops },\n{ MKTAG('S','m','D','m'), mov_read_smdm },\n{ MKTAG('C','o','L','L'), mov_read_coll },\n{ MKTAG('v','p','c','C'), mov_read_vpcc },\n{ 0, NULL }\n};\n\nstatic int mov_read_default(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int64_t total_size = 0;\n    MOVAtom a;\n    int i;\n\n    if (c->atom_depth > 10) {\n        av_log(c->fc, AV_LOG_ERROR, \"Atoms too deeply nested\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    c->atom_depth ++;\n\n    if (atom.size < 0)\n        atom.size = INT64_MAX;\n    while (total_size <= atom.size - 8 && !avio_feof(pb)) {\n        int (*parse)(MOVContext*, AVIOContext*, MOVAtom) = NULL;\n        a.size = atom.size;\n        a.type=0;\n        if (atom.size >= 8) {\n            a.size = avio_rb32(pb);\n            a.type = avio_rl32(pb);\n            if (a.type == MKTAG('f','r','e','e') &&\n                a.size >= 8 &&\n                c->fc->strict_std_compliance < FF_COMPLIANCE_STRICT &&\n                c->moov_retry) {\n                uint8_t buf[8];\n                uint32_t *type = (uint32_t *)buf + 1;\n                if (avio_read(pb, buf, 8) != 8)\n                    return AVERROR_INVALIDDATA;\n                avio_seek(pb, -8, SEEK_CUR);\n                if (*type == MKTAG('m','v','h','d') ||\n                    *type == MKTAG('c','m','o','v')) {\n                    av_log(c->fc, AV_LOG_ERROR, \"Detected moov in a free atom.\\n\");\n                    a.type = MKTAG('m','o','o','v');\n                }\n            }\n            if (atom.type != MKTAG('r','o','o','t') &&\n                atom.type != MKTAG('m','o','o','v'))\n            {\n                if (a.type == MKTAG('t','r','a','k') || a.type == MKTAG('m','d','a','t'))\n                {\n                    av_log(c->fc, AV_LOG_ERROR, \"Broken file, trak/mdat not at top-level\\n\");\n                    avio_skip(pb, -8);\n                    c->atom_depth --;\n                    return 0;\n                }\n            }\n            total_size += 8;\n            if (a.size == 1 && total_size + 8 <= atom.size) { /* 64 bit extended size */\n                a.size = avio_rb64(pb) - 8;\n                total_size += 8;\n            }\n        }\n        av_log(c->fc, AV_LOG_TRACE, \"type:'%s' parent:'%s' sz: %\"PRId64\" %\"PRId64\" %\"PRId64\"\\n\",\n               av_fourcc2str(a.type), av_fourcc2str(atom.type), a.size, total_size, atom.size);\n        if (a.size == 0) {\n            a.size = atom.size - total_size + 8;\n        }\n        a.size -= 8;\n        if (a.size < 0)\n            break;\n        a.size = FFMIN(a.size, atom.size - total_size);\n\n        for (i = 0; mov_default_parse_table[i].type; i++)\n            if (mov_default_parse_table[i].type == a.type) {\n                parse = mov_default_parse_table[i].parse;\n                break;\n            }\n\n        // container is user data\n        if (!parse && (atom.type == MKTAG('u','d','t','a') ||\n                       atom.type == MKTAG('i','l','s','t')))\n            parse = mov_read_udta_string;\n\n        // Supports parsing the QuickTime Metadata Keys.\n        // https://developer.apple.com/library/mac/documentation/QuickTime/QTFF/Metadata/Metadata.html\n        if (!parse && c->found_hdlr_mdta &&\n            atom.type == MKTAG('m','e','t','a') &&\n            a.type == MKTAG('k','e','y','s')) {\n            parse = mov_read_keys;\n        }\n\n        if (!parse) { /* skip leaf atoms data */\n            avio_skip(pb, a.size);\n        } else {\n            int64_t start_pos = avio_tell(pb);\n            int64_t left;\n            int err = parse(c, pb, a);\n            if (err < 0) {\n                c->atom_depth --;\n                return err;\n            }\n            if (c->found_moov && c->found_mdat &&\n                ((!(pb->seekable & AVIO_SEEKABLE_NORMAL) || c->fc->flags & AVFMT_FLAG_IGNIDX || c->fragment_index_complete) ||\n                 start_pos + a.size == avio_size(pb))) {\n                if (!(pb->seekable & AVIO_SEEKABLE_NORMAL) || c->fc->flags & AVFMT_FLAG_IGNIDX || c->fragment_index_complete)\n                    c->next_root_atom = start_pos + a.size;\n                c->atom_depth --;\n                return 0;\n            }\n            left = a.size - avio_tell(pb) + start_pos;\n            if (left > 0) /* skip garbage at atom end */\n                avio_skip(pb, left);\n            else if (left < 0) {\n                av_log(c->fc, AV_LOG_WARNING,\n                       \"overread end of atom '%.4s' by %\"PRId64\" bytes\\n\",\n                       (char*)&a.type, -left);\n                avio_seek(pb, left, SEEK_CUR);\n            }\n        }\n\n        total_size += a.size;\n    }\n\n    if (total_size < atom.size && atom.size < 0x7ffff)\n        avio_skip(pb, atom.size - total_size);\n\n    c->atom_depth --;\n    return 0;\n}\n\nstatic int mov_probe(AVProbeData *p)\n{\n    int64_t offset;\n    uint32_t tag;\n    int score = 0;\n    int moov_offset = -1;\n\n    /* check file header */\n    offset = 0;\n    for (;;) {\n        /* ignore invalid offset */\n        if ((offset + 8) > (unsigned int)p->buf_size)\n            break;\n        tag = AV_RL32(p->buf + offset + 4);\n        switch(tag) {\n        /* check for obvious tags */\n        case MKTAG('m','o','o','v'):\n            moov_offset = offset + 4;\n        case MKTAG('m','d','a','t'):\n        case MKTAG('p','n','o','t'): /* detect movs with preview pics like ew.mov and april.mov */\n        case MKTAG('u','d','t','a'): /* Packet Video PVAuthor adds this and a lot of more junk */\n        case MKTAG('f','t','y','p'):\n            if (AV_RB32(p->buf+offset) < 8 &&\n                (AV_RB32(p->buf+offset) != 1 ||\n                 offset + 12 > (unsigned int)p->buf_size ||\n                 AV_RB64(p->buf+offset + 8) == 0)) {\n                score = FFMAX(score, AVPROBE_SCORE_EXTENSION);\n            } else if (tag == MKTAG('f','t','y','p') &&\n                       (   AV_RL32(p->buf + offset + 8) == MKTAG('j','p','2',' ')\n                        || AV_RL32(p->buf + offset + 8) == MKTAG('j','p','x',' ')\n                    )) {\n                score = FFMAX(score, 5);\n            } else {\n                score = AVPROBE_SCORE_MAX;\n            }\n            offset = FFMAX(4, AV_RB32(p->buf+offset)) + offset;\n            break;\n        /* those are more common words, so rate then a bit less */\n        case MKTAG('e','d','i','w'): /* xdcam files have reverted first tags */\n        case MKTAG('w','i','d','e'):\n        case MKTAG('f','r','e','e'):\n        case MKTAG('j','u','n','k'):\n        case MKTAG('p','i','c','t'):\n            score  = FFMAX(score, AVPROBE_SCORE_MAX - 5);\n            offset = FFMAX(4, AV_RB32(p->buf+offset)) + offset;\n            break;\n        case MKTAG(0x82,0x82,0x7f,0x7d):\n        case MKTAG('s','k','i','p'):\n        case MKTAG('u','u','i','d'):\n        case MKTAG('p','r','f','l'):\n            /* if we only find those cause probedata is too small at least rate them */\n            score  = FFMAX(score, AVPROBE_SCORE_EXTENSION);\n            offset = FFMAX(4, AV_RB32(p->buf+offset)) + offset;\n            break;\n        default:\n            offset = FFMAX(4, AV_RB32(p->buf+offset)) + offset;\n        }\n    }\n    if(score > AVPROBE_SCORE_MAX - 50 && moov_offset != -1) {\n        /* moov atom in the header - we should make sure that this is not a\n         * MOV-packed MPEG-PS */\n        offset = moov_offset;\n\n        while(offset < (p->buf_size - 16)){ /* Sufficient space */\n               /* We found an actual hdlr atom */\n            if(AV_RL32(p->buf + offset     ) == MKTAG('h','d','l','r') &&\n               AV_RL32(p->buf + offset +  8) == MKTAG('m','h','l','r') &&\n               AV_RL32(p->buf + offset + 12) == MKTAG('M','P','E','G')){\n                av_log(NULL, AV_LOG_WARNING, \"Found media data tag MPEG indicating this is a MOV-packed MPEG-PS.\\n\");\n                /* We found a media handler reference atom describing an\n                 * MPEG-PS-in-MOV, return a\n                 * low score to force expanding the probe window until\n                 * mpegps_probe finds what it needs */\n                return 5;\n            }else\n                /* Keep looking */\n                offset+=2;\n        }\n    }\n\n    return score;\n}\n\n// must be done after parsing all trak because there's no order requirement\nstatic void mov_read_chapters(AVFormatContext *s)\n{\n    MOVContext *mov = s->priv_data;\n    AVStream *st;\n    MOVStreamContext *sc;\n    int64_t cur_pos;\n    int i, j;\n    int chapter_track;\n\n    for (j = 0; j < mov->nb_chapter_tracks; j++) {\n        chapter_track = mov->chapter_tracks[j];\n        st = NULL;\n        for (i = 0; i < s->nb_streams; i++)\n            if (s->streams[i]->id == chapter_track) {\n                st = s->streams[i];\n                break;\n            }\n        if (!st) {\n            av_log(s, AV_LOG_ERROR, \"Referenced QT chapter track not found\\n\");\n            continue;\n        }\n\n        sc = st->priv_data;\n        cur_pos = avio_tell(sc->pb);\n\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n            st->disposition |= AV_DISPOSITION_ATTACHED_PIC | AV_DISPOSITION_TIMED_THUMBNAILS;\n            if (st->nb_index_entries) {\n                // Retrieve the first frame, if possible\n                AVPacket pkt;\n                AVIndexEntry *sample = &st->index_entries[0];\n                if (avio_seek(sc->pb, sample->pos, SEEK_SET) != sample->pos) {\n                    av_log(s, AV_LOG_ERROR, \"Failed to retrieve first frame\\n\");\n                    goto finish;\n                }\n\n                if (av_get_packet(sc->pb, &pkt, sample->size) < 0)\n                    goto finish;\n\n                st->attached_pic              = pkt;\n                st->attached_pic.stream_index = st->index;\n                st->attached_pic.flags       |= AV_PKT_FLAG_KEY;\n            }\n        } else {\n            st->codecpar->codec_type = AVMEDIA_TYPE_DATA;\n            st->codecpar->codec_id = AV_CODEC_ID_BIN_DATA;\n            st->discard = AVDISCARD_ALL;\n            for (i = 0; i < st->nb_index_entries; i++) {\n                AVIndexEntry *sample = &st->index_entries[i];\n                int64_t end = i+1 < st->nb_index_entries ? st->index_entries[i+1].timestamp : st->duration;\n                uint8_t *title;\n                uint16_t ch;\n                int len, title_len;\n\n                if (end < sample->timestamp) {\n                    av_log(s, AV_LOG_WARNING, \"ignoring stream duration which is shorter than chapters\\n\");\n                    end = AV_NOPTS_VALUE;\n                }\n\n                if (avio_seek(sc->pb, sample->pos, SEEK_SET) != sample->pos) {\n                    av_log(s, AV_LOG_ERROR, \"Chapter %d not found in file\\n\", i);\n                    goto finish;\n                }\n\n                // the first two bytes are the length of the title\n                len = avio_rb16(sc->pb);\n                if (len > sample->size-2)\n                    continue;\n                title_len = 2*len + 1;\n                if (!(title = av_mallocz(title_len)))\n                    goto finish;\n\n                // The samples could theoretically be in any encoding if there's an encd\n                // atom following, but in practice are only utf-8 or utf-16, distinguished\n                // instead by the presence of a BOM\n                if (!len) {\n                    title[0] = 0;\n                } else {\n                    ch = avio_rb16(sc->pb);\n                    if (ch == 0xfeff)\n                        avio_get_str16be(sc->pb, len, title, title_len);\n                    else if (ch == 0xfffe)\n                        avio_get_str16le(sc->pb, len, title, title_len);\n                    else {\n                        AV_WB16(title, ch);\n                        if (len == 1 || len == 2)\n                            title[len] = 0;\n                        else\n                            avio_get_str(sc->pb, INT_MAX, title + 2, len - 1);\n                    }\n                }\n\n                avpriv_new_chapter(s, i, st->time_base, sample->timestamp, end, title);\n                av_freep(&title);\n            }\n        }\nfinish:\n        avio_seek(sc->pb, cur_pos, SEEK_SET);\n    }\n}\n\nstatic int parse_timecode_in_framenum_format(AVFormatContext *s, AVStream *st,\n                                             uint32_t value, int flags)\n{\n    AVTimecode tc;\n    char buf[AV_TIMECODE_STR_SIZE];\n    AVRational rate = st->avg_frame_rate;\n    int ret = av_timecode_init(&tc, rate, flags, 0, s);\n    if (ret < 0)\n        return ret;\n    av_dict_set(&st->metadata, \"timecode\",\n                av_timecode_make_string(&tc, buf, value), 0);\n    return 0;\n}\n\nstatic int mov_read_rtmd_track(AVFormatContext *s, AVStream *st)\n{\n    MOVStreamContext *sc = st->priv_data;\n    char buf[AV_TIMECODE_STR_SIZE];\n    int64_t cur_pos = avio_tell(sc->pb);\n    int hh, mm, ss, ff, drop;\n\n    if (!st->nb_index_entries)\n        return -1;\n\n    avio_seek(sc->pb, st->index_entries->pos, SEEK_SET);\n    avio_skip(s->pb, 13);\n    hh = avio_r8(s->pb);\n    mm = avio_r8(s->pb);\n    ss = avio_r8(s->pb);\n    drop = avio_r8(s->pb);\n    ff = avio_r8(s->pb);\n    snprintf(buf, AV_TIMECODE_STR_SIZE, \"%02d:%02d:%02d%c%02d\",\n             hh, mm, ss, drop ? ';' : ':', ff);\n    av_dict_set(&st->metadata, \"timecode\", buf, 0);\n\n    avio_seek(sc->pb, cur_pos, SEEK_SET);\n    return 0;\n}\n\nstatic int mov_read_timecode_track(AVFormatContext *s, AVStream *st)\n{\n    MOVStreamContext *sc = st->priv_data;\n    int flags = 0;\n    int64_t cur_pos = avio_tell(sc->pb);\n    uint32_t value;\n\n    if (!st->nb_index_entries)\n        return -1;\n\n    avio_seek(sc->pb, st->index_entries->pos, SEEK_SET);\n    value = avio_rb32(s->pb);\n\n    if (sc->tmcd_flags & 0x0001) flags |= AV_TIMECODE_FLAG_DROPFRAME;\n    if (sc->tmcd_flags & 0x0002) flags |= AV_TIMECODE_FLAG_24HOURSMAX;\n    if (sc->tmcd_flags & 0x0004) flags |= AV_TIMECODE_FLAG_ALLOWNEGATIVE;\n\n    /* Assume Counter flag is set to 1 in tmcd track (even though it is likely\n     * not the case) and thus assume \"frame number format\" instead of QT one.\n     * No sample with tmcd track can be found with a QT timecode at the moment,\n     * despite what the tmcd track \"suggests\" (Counter flag set to 0 means QT\n     * format). */\n    parse_timecode_in_framenum_format(s, st, value, flags);\n\n    avio_seek(sc->pb, cur_pos, SEEK_SET);\n    return 0;\n}\n\nstatic int mov_read_close(AVFormatContext *s)\n{\n    MOVContext *mov = s->priv_data;\n    int i, j;\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n        MOVStreamContext *sc = st->priv_data;\n\n        if (!sc)\n            continue;\n\n        av_freep(&sc->ctts_data);\n        for (j = 0; j < sc->drefs_count; j++) {\n            av_freep(&sc->drefs[j].path);\n            av_freep(&sc->drefs[j].dir);\n        }\n        av_freep(&sc->drefs);\n\n        sc->drefs_count = 0;\n\n        if (!sc->pb_is_copied)\n            ff_format_io_close(s, &sc->pb);\n\n        sc->pb = NULL;\n        av_freep(&sc->chunk_offsets);\n        av_freep(&sc->stsc_data);\n        av_freep(&sc->sample_sizes);\n        av_freep(&sc->keyframes);\n        av_freep(&sc->stts_data);\n        av_freep(&sc->stps_data);\n        av_freep(&sc->elst_data);\n        av_freep(&sc->rap_group);\n        av_freep(&sc->display_matrix);\n        av_freep(&sc->index_ranges);\n\n        if (sc->extradata)\n            for (j = 0; j < sc->stsd_count; j++)\n                av_free(sc->extradata[j]);\n        av_freep(&sc->extradata);\n        av_freep(&sc->extradata_size);\n\n        av_freep(&sc->cenc.auxiliary_info);\n        av_freep(&sc->cenc.auxiliary_info_sizes);\n        av_aes_ctr_free(sc->cenc.aes_ctr);\n\n        av_freep(&sc->stereo3d);\n        av_freep(&sc->spherical);\n        av_freep(&sc->mastering);\n        av_freep(&sc->coll);\n    }\n\n    if (mov->dv_demux) {\n        avformat_free_context(mov->dv_fctx);\n        mov->dv_fctx = NULL;\n    }\n\n    if (mov->meta_keys) {\n        for (i = 1; i < mov->meta_keys_count; i++) {\n            av_freep(&mov->meta_keys[i]);\n        }\n        av_freep(&mov->meta_keys);\n    }\n\n    av_freep(&mov->trex_data);\n    av_freep(&mov->bitrates);\n\n    for (i = 0; i < mov->fragment_index_count; i++) {\n        MOVFragmentIndex* index = mov->fragment_index_data[i];\n        av_freep(&index->items);\n        av_freep(&mov->fragment_index_data[i]);\n    }\n    av_freep(&mov->fragment_index_data);\n\n    av_freep(&mov->aes_decrypt);\n    av_freep(&mov->chapter_tracks);\n\n    return 0;\n}\n\nstatic int tmcd_is_referenced(AVFormatContext *s, int tmcd_id)\n{\n    int i;\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n        MOVStreamContext *sc = st->priv_data;\n\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO &&\n            sc->timecode_track == tmcd_id)\n            return 1;\n    }\n    return 0;\n}\n\n/* look for a tmcd track not referenced by any video track, and export it globally */\nstatic void export_orphan_timecode(AVFormatContext *s)\n{\n    int i;\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n\n        if (st->codecpar->codec_tag  == MKTAG('t','m','c','d') &&\n            !tmcd_is_referenced(s, i + 1)) {\n            AVDictionaryEntry *tcr = av_dict_get(st->metadata, \"timecode\", NULL, 0);\n            if (tcr) {\n                av_dict_set(&s->metadata, \"timecode\", tcr->value, 0);\n                break;\n            }\n        }\n    }\n}\n\nstatic int read_tfra(MOVContext *mov, AVIOContext *f)\n{\n    MOVFragmentIndex* index = NULL;\n    int version, fieldlength, i, j;\n    int64_t pos = avio_tell(f);\n    uint32_t size = avio_rb32(f);\n    void *tmp;\n\n    if (avio_rb32(f) != MKBETAG('t', 'f', 'r', 'a')) {\n        return 1;\n    }\n    av_log(mov->fc, AV_LOG_VERBOSE, \"found tfra\\n\");\n    index = av_mallocz(sizeof(MOVFragmentIndex));\n    if (!index) {\n        return AVERROR(ENOMEM);\n    }\n\n    tmp = av_realloc_array(mov->fragment_index_data,\n                           mov->fragment_index_count + 1,\n                           sizeof(MOVFragmentIndex*));\n    if (!tmp) {\n        av_freep(&index);\n        return AVERROR(ENOMEM);\n    }\n    mov->fragment_index_data = tmp;\n    mov->fragment_index_data[mov->fragment_index_count++] = index;\n\n    version = avio_r8(f);\n    avio_rb24(f);\n    index->track_id = avio_rb32(f);\n    fieldlength = avio_rb32(f);\n    index->item_count = avio_rb32(f);\n    index->items = av_mallocz_array(\n            index->item_count, sizeof(MOVFragmentIndexItem));\n    if (!index->items) {\n        index->item_count = 0;\n        return AVERROR(ENOMEM);\n    }\n    for (i = 0; i < index->item_count; i++) {\n        int64_t time, offset;\n        if (version == 1) {\n            time   = avio_rb64(f);\n            offset = avio_rb64(f);\n        } else {\n            time   = avio_rb32(f);\n            offset = avio_rb32(f);\n        }\n        index->items[i].time = time;\n        index->items[i].moof_offset = offset;\n        for (j = 0; j < ((fieldlength >> 4) & 3) + 1; j++)\n            avio_r8(f);\n        for (j = 0; j < ((fieldlength >> 2) & 3) + 1; j++)\n            avio_r8(f);\n        for (j = 0; j < ((fieldlength >> 0) & 3) + 1; j++)\n            avio_r8(f);\n    }\n\n    avio_seek(f, pos + size, SEEK_SET);\n    return 0;\n}\n\nstatic int mov_read_mfra(MOVContext *c, AVIOContext *f)\n{\n    int64_t stream_size = avio_size(f);\n    int64_t original_pos = avio_tell(f);\n    int64_t seek_ret;\n    int32_t mfra_size;\n    int ret = -1;\n    if ((seek_ret = avio_seek(f, stream_size - 4, SEEK_SET)) < 0) {\n        ret = seek_ret;\n        goto fail;\n    }\n    mfra_size = avio_rb32(f);\n    if (mfra_size < 0 || mfra_size > stream_size) {\n        av_log(c->fc, AV_LOG_DEBUG, \"doesn't look like mfra (unreasonable size)\\n\");\n        goto fail;\n    }\n    if ((seek_ret = avio_seek(f, -mfra_size, SEEK_CUR)) < 0) {\n        ret = seek_ret;\n        goto fail;\n    }\n    if (avio_rb32(f) != mfra_size) {\n        av_log(c->fc, AV_LOG_DEBUG, \"doesn't look like mfra (size mismatch)\\n\");\n        goto fail;\n    }\n    if (avio_rb32(f) != MKBETAG('m', 'f', 'r', 'a')) {\n        av_log(c->fc, AV_LOG_DEBUG, \"doesn't look like mfra (tag mismatch)\\n\");\n        goto fail;\n    }\n    av_log(c->fc, AV_LOG_VERBOSE, \"stream has mfra\\n\");\n    do {\n        ret = read_tfra(c, f);\n        if (ret < 0)\n            goto fail;\n    } while (!ret);\n    ret = 0;\nfail:\n    seek_ret = avio_seek(f, original_pos, SEEK_SET);\n    if (seek_ret < 0) {\n        av_log(c->fc, AV_LOG_ERROR,\n               \"failed to seek back after looking for mfra\\n\");\n        ret = seek_ret;\n    }\n    return ret;\n}\n\nstatic int mov_read_header(AVFormatContext *s)\n{\n    MOVContext *mov = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int j, err;\n    MOVAtom atom = { AV_RL32(\"root\") };\n    int i;\n\n    if (mov->decryption_key_len != 0 && mov->decryption_key_len != AES_CTR_KEY_SIZE) {\n        av_log(s, AV_LOG_ERROR, \"Invalid decryption key len %d expected %d\\n\",\n            mov->decryption_key_len, AES_CTR_KEY_SIZE);\n        return AVERROR(EINVAL);\n    }\n\n    mov->fc = s;\n    mov->trak_index = -1;\n    /* .mov and .mp4 aren't streamable anyway (only progressive download if moov is before mdat) */\n    if (pb->seekable & AVIO_SEEKABLE_NORMAL)\n        atom.size = avio_size(pb);\n    else\n        atom.size = INT64_MAX;\n\n    /* check MOV header */\n    do {\n    if (mov->moov_retry)\n        avio_seek(pb, 0, SEEK_SET);\n    if ((err = mov_read_default(mov, pb, atom)) < 0) {\n        av_log(s, AV_LOG_ERROR, \"error reading header\\n\");\n        mov_read_close(s);\n        return err;\n    }\n    } while ((pb->seekable & AVIO_SEEKABLE_NORMAL) && !mov->found_moov && !mov->moov_retry++);\n    if (!mov->found_moov) {\n        av_log(s, AV_LOG_ERROR, \"moov atom not found\\n\");\n        mov_read_close(s);\n        return AVERROR_INVALIDDATA;\n    }\n    av_log(mov->fc, AV_LOG_TRACE, \"on_parse_exit_offset=%\"PRId64\"\\n\", avio_tell(pb));\n\n    if (pb->seekable & AVIO_SEEKABLE_NORMAL) {\n        if (mov->nb_chapter_tracks > 0 && !mov->ignore_chapters)\n            mov_read_chapters(s);\n        for (i = 0; i < s->nb_streams; i++)\n            if (s->streams[i]->codecpar->codec_tag == AV_RL32(\"tmcd\")) {\n                mov_read_timecode_track(s, s->streams[i]);\n            } else if (s->streams[i]->codecpar->codec_tag == AV_RL32(\"rtmd\")) {\n                mov_read_rtmd_track(s, s->streams[i]);\n            }\n    }\n\n    /* copy timecode metadata from tmcd tracks to the related video streams */\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n        MOVStreamContext *sc = st->priv_data;\n        if (sc->timecode_track > 0) {\n            AVDictionaryEntry *tcr;\n            int tmcd_st_id = -1;\n\n            for (j = 0; j < s->nb_streams; j++)\n                if (s->streams[j]->id == sc->timecode_track)\n                    tmcd_st_id = j;\n\n            if (tmcd_st_id < 0 || tmcd_st_id == i)\n                continue;\n            tcr = av_dict_get(s->streams[tmcd_st_id]->metadata, \"timecode\", NULL, 0);\n            if (tcr)\n                av_dict_set(&st->metadata, \"timecode\", tcr->value, 0);\n        }\n    }\n    export_orphan_timecode(s);\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n        MOVStreamContext *sc = st->priv_data;\n        fix_timescale(mov, sc);\n        if(st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO && st->codecpar->codec_id == AV_CODEC_ID_AAC) {\n            st->skip_samples = sc->start_pad;\n        }\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO && sc->nb_frames_for_fps > 0 && sc->duration_for_fps > 0)\n            av_reduce(&st->avg_frame_rate.num, &st->avg_frame_rate.den,\n                      sc->time_scale*(int64_t)sc->nb_frames_for_fps, sc->duration_for_fps, INT_MAX);\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n            if (st->codecpar->width <= 0 || st->codecpar->height <= 0) {\n                st->codecpar->width  = sc->width;\n                st->codecpar->height = sc->height;\n            }\n            if (st->codecpar->codec_id == AV_CODEC_ID_DVD_SUBTITLE) {\n                if ((err = mov_rewrite_dvd_sub_extradata(st)) < 0)\n                    return err;\n            }\n        }\n        if (mov->handbrake_version &&\n            mov->handbrake_version <= 1000000*0 + 1000*10 + 2 &&  // 0.10.2\n            st->codecpar->codec_id == AV_CODEC_ID_MP3\n        ) {\n            av_log(s, AV_LOG_VERBOSE, \"Forcing full parsing for mp3 stream\\n\");\n            st->need_parsing = AVSTREAM_PARSE_FULL;\n        }\n    }\n\n    if (mov->trex_data) {\n        for (i = 0; i < s->nb_streams; i++) {\n            AVStream *st = s->streams[i];\n            MOVStreamContext *sc = st->priv_data;\n            if (st->duration > 0) {\n                if (sc->data_size > INT64_MAX / sc->time_scale / 8) {\n                    av_log(s, AV_LOG_ERROR, \"Overflow during bit rate calculation %\"PRId64\" * 8 * %d\\n\",\n                           sc->data_size, sc->time_scale);\n                    mov_read_close(s);\n                    return AVERROR_INVALIDDATA;\n                }\n                st->codecpar->bit_rate = sc->data_size * 8 * sc->time_scale / st->duration;\n            }\n        }\n    }\n\n    if (mov->use_mfra_for > 0) {\n        for (i = 0; i < s->nb_streams; i++) {\n            AVStream *st = s->streams[i];\n            MOVStreamContext *sc = st->priv_data;\n            if (sc->duration_for_fps > 0) {\n                if (sc->data_size > INT64_MAX / sc->time_scale / 8) {\n                    av_log(s, AV_LOG_ERROR, \"Overflow during bit rate calculation %\"PRId64\" * 8 * %d\\n\",\n                           sc->data_size, sc->time_scale);\n                    mov_read_close(s);\n                    return AVERROR_INVALIDDATA;\n                }\n                st->codecpar->bit_rate = sc->data_size * 8 * sc->time_scale /\n                    sc->duration_for_fps;\n            }\n        }\n    }\n\n    for (i = 0; i < mov->bitrates_count && i < s->nb_streams; i++) {\n        if (mov->bitrates[i]) {\n            s->streams[i]->codecpar->bit_rate = mov->bitrates[i];\n        }\n    }\n\n    ff_rfps_calculate(s);\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n        MOVStreamContext *sc = st->priv_data;\n\n        switch (st->codecpar->codec_type) {\n        case AVMEDIA_TYPE_AUDIO:\n            err = ff_replaygain_export(st, s->metadata);\n            if (err < 0) {\n                mov_read_close(s);\n                return err;\n            }\n            break;\n        case AVMEDIA_TYPE_VIDEO:\n            if (sc->display_matrix) {\n                err = av_stream_add_side_data(st, AV_PKT_DATA_DISPLAYMATRIX, (uint8_t*)sc->display_matrix,\n                                              sizeof(int32_t) * 9);\n                if (err < 0)\n                    return err;\n\n                sc->display_matrix = NULL;\n            }\n            if (sc->stereo3d) {\n                err = av_stream_add_side_data(st, AV_PKT_DATA_STEREO3D,\n                                              (uint8_t *)sc->stereo3d,\n                                              sizeof(*sc->stereo3d));\n                if (err < 0)\n                    return err;\n\n                sc->stereo3d = NULL;\n            }\n            if (sc->spherical) {\n                err = av_stream_add_side_data(st, AV_PKT_DATA_SPHERICAL,\n                                              (uint8_t *)sc->spherical,\n                                              sc->spherical_size);\n                if (err < 0)\n                    return err;\n\n                sc->spherical = NULL;\n            }\n            if (sc->mastering) {\n                err = av_stream_add_side_data(st, AV_PKT_DATA_MASTERING_DISPLAY_METADATA,\n                                              (uint8_t *)sc->mastering,\n                                              sizeof(*sc->mastering));\n                if (err < 0)\n                    return err;\n\n                sc->mastering = NULL;\n            }\n            if (sc->coll) {\n                err = av_stream_add_side_data(st, AV_PKT_DATA_CONTENT_LIGHT_LEVEL,\n                                              (uint8_t *)sc->coll,\n                                              sc->coll_size);\n                if (err < 0)\n                    return err;\n\n                sc->coll = NULL;\n            }\n            break;\n        }\n    }\n    ff_configure_buffers_for_index(s, AV_TIME_BASE);\n\n    for (i = 0; i < mov->fragment_index_count; i++) {\n        MOVFragmentIndex *idx = mov->fragment_index_data[i];\n        for (j = 0; j < idx->item_count; j++)\n            if (idx->items[j].moof_offset <= mov->fragment.moof_offset)\n                idx->items[j].headers_read = 1;\n    }\n\n    return 0;\n}\n\nstatic AVIndexEntry *mov_find_next_sample(AVFormatContext *s, AVStream **st)\n{\n    AVIndexEntry *sample = NULL;\n    int64_t best_dts = INT64_MAX;\n    int i;\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *avst = s->streams[i];\n        MOVStreamContext *msc = avst->priv_data;\n        if (msc->pb && msc->current_sample < avst->nb_index_entries) {\n            AVIndexEntry *current_sample = &avst->index_entries[msc->current_sample];\n            int64_t dts = av_rescale(current_sample->timestamp, AV_TIME_BASE, msc->time_scale);\n            av_log(s, AV_LOG_TRACE, \"stream %d, sample %d, dts %\"PRId64\"\\n\", i, msc->current_sample, dts);\n            if (!sample || (!(s->pb->seekable & AVIO_SEEKABLE_NORMAL) && current_sample->pos < sample->pos) ||\n                ((s->pb->seekable & AVIO_SEEKABLE_NORMAL) &&\n                 ((msc->pb != s->pb && dts < best_dts) || (msc->pb == s->pb &&\n                 ((FFABS(best_dts - dts) <= AV_TIME_BASE && current_sample->pos < sample->pos) ||\n                  (FFABS(best_dts - dts) > AV_TIME_BASE && dts < best_dts)))))) {\n                sample = current_sample;\n                best_dts = dts;\n                *st = avst;\n            }\n        }\n    }\n    return sample;\n}\n\nstatic int should_retry(AVIOContext *pb, int error_code) {\n    if (error_code == AVERROR_EOF || avio_feof(pb))\n        return 0;\n\n    return 1;\n}\n\nstatic int mov_switch_root(AVFormatContext *s, int64_t target)\n{\n    MOVContext *mov = s->priv_data;\n    int i, j;\n    int already_read = 0;\n\n    if (avio_seek(s->pb, target, SEEK_SET) != target) {\n        av_log(mov->fc, AV_LOG_ERROR, \"root atom offset 0x%\"PRIx64\": partial file\\n\", target);\n        return AVERROR_INVALIDDATA;\n    }\n\n    mov->next_root_atom = 0;\n\n    for (i = 0; i < mov->fragment_index_count; i++) {\n        MOVFragmentIndex *index = mov->fragment_index_data[i];\n        int found = 0;\n        for (j = 0; j < index->item_count; j++) {\n            MOVFragmentIndexItem *item = &index->items[j];\n            if (found) {\n                mov->next_root_atom = item->moof_offset;\n                break; // Advance to next index in outer loop\n            } else if (item->moof_offset == target) {\n                index->current_item = FFMIN(j, index->current_item);\n                if (item->headers_read)\n                    already_read = 1;\n                item->headers_read = 1;\n                found = 1;\n            }\n        }\n        if (!found)\n            index->current_item = 0;\n    }\n\n    if (already_read)\n        return 0;\n\n    mov->found_mdat = 0;\n\n    if (mov_read_default(mov, s->pb, (MOVAtom){ AV_RL32(\"root\"), INT64_MAX }) < 0 ||\n        avio_feof(s->pb))\n        return AVERROR_EOF;\n    av_log(s, AV_LOG_TRACE, \"read fragments, offset 0x%\"PRIx64\"\\n\", avio_tell(s->pb));\n\n    return 1;\n}\n\nstatic int mov_change_extradata(MOVStreamContext *sc, AVPacket *pkt)\n{\n    uint8_t *side, *extradata;\n    int extradata_size;\n\n    /* Save the current index. */\n    sc->last_stsd_index = sc->stsc_data[sc->stsc_index].id - 1;\n\n    /* Notify the decoder that extradata changed. */\n    extradata_size = sc->extradata_size[sc->last_stsd_index];\n    extradata = sc->extradata[sc->last_stsd_index];\n    if (extradata_size > 0 && extradata) {\n        side = av_packet_new_side_data(pkt,\n                                       AV_PKT_DATA_NEW_EXTRADATA,\n                                       extradata_size);\n        if (!side)\n            return AVERROR(ENOMEM);\n        memcpy(side, extradata, extradata_size);\n    }\n\n    return 0;\n}\n\nstatic int mov_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    MOVContext *mov = s->priv_data;\n    MOVStreamContext *sc;\n    AVIndexEntry *sample;\n    AVStream *st = NULL;\n    int64_t current_index;\n    int ret;\n    mov->fc = s;\n retry:\n    sample = mov_find_next_sample(s, &st);\n    if (!sample || (mov->next_root_atom && sample->pos > mov->next_root_atom)) {\n        if (!mov->next_root_atom)\n            return AVERROR_EOF;\n        if ((ret = mov_switch_root(s, mov->next_root_atom)) < 0)\n            return ret;\n        goto retry;\n    }\n    sc = st->priv_data;\n    /* must be done just before reading, to avoid infinite loop on sample */\n    current_index = sc->current_index;\n    mov_current_sample_inc(sc);\n\n    if (mov->next_root_atom) {\n        sample->pos = FFMIN(sample->pos, mov->next_root_atom);\n        sample->size = FFMIN(sample->size, (mov->next_root_atom - sample->pos));\n    }\n\n    if (st->discard != AVDISCARD_ALL) {\n        int64_t ret64 = avio_seek(sc->pb, sample->pos, SEEK_SET);\n        if (ret64 != sample->pos) {\n            av_log(mov->fc, AV_LOG_ERROR, \"stream %d, offset 0x%\"PRIx64\": partial file\\n\",\n                   sc->ffindex, sample->pos);\n            if (should_retry(sc->pb, ret64)) {\n                mov_current_sample_dec(sc);\n            }\n            return AVERROR_INVALIDDATA;\n        }\n\n        if( st->discard == AVDISCARD_NONKEY && 0==(sample->flags & AVINDEX_KEYFRAME) ) {\n            av_log(mov->fc, AV_LOG_DEBUG, \"Nonkey frame from stream %d discarded due to AVDISCARD_NONKEY\\n\", sc->ffindex);\n            goto retry;\n        }\n\n        ret = av_get_packet(sc->pb, pkt, sample->size);\n        if (ret < 0) {\n            if (should_retry(sc->pb, ret)) {\n                mov_current_sample_dec(sc);\n            }\n            return ret;\n        }\n        if (sc->has_palette) {\n            uint8_t *pal;\n\n            pal = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE, AVPALETTE_SIZE);\n            if (!pal) {\n                av_log(mov->fc, AV_LOG_ERROR, \"Cannot append palette to packet\\n\");\n            } else {\n                memcpy(pal, sc->palette, AVPALETTE_SIZE);\n                sc->has_palette = 0;\n            }\n        }\n#if CONFIG_DV_DEMUXER\n        if (mov->dv_demux && sc->dv_audio_container) {\n            avpriv_dv_produce_packet(mov->dv_demux, pkt, pkt->data, pkt->size, pkt->pos);\n            av_freep(&pkt->data);\n            pkt->size = 0;\n            ret = avpriv_dv_get_packet(mov->dv_demux, pkt);\n            if (ret < 0)\n                return ret;\n        }\n#endif\n        if (st->codecpar->codec_id == AV_CODEC_ID_MP3 && !st->need_parsing && pkt->size > 4) {\n            if (ff_mpa_check_header(AV_RB32(pkt->data)) < 0)\n                st->need_parsing = AVSTREAM_PARSE_FULL;\n        }\n    }\n\n    pkt->stream_index = sc->ffindex;\n    pkt->dts = sample->timestamp;\n    if (sample->flags & AVINDEX_DISCARD_FRAME) {\n        pkt->flags |= AV_PKT_FLAG_DISCARD;\n    }\n    if (sc->ctts_data && sc->ctts_index < sc->ctts_count) {\n        pkt->pts = pkt->dts + sc->dts_shift + sc->ctts_data[sc->ctts_index].duration;\n        /* update ctts context */\n        sc->ctts_sample++;\n        if (sc->ctts_index < sc->ctts_count &&\n            sc->ctts_data[sc->ctts_index].count == sc->ctts_sample) {\n            sc->ctts_index++;\n            sc->ctts_sample = 0;\n        }\n    } else {\n        int64_t next_dts = (sc->current_sample < st->nb_index_entries) ?\n            st->index_entries[sc->current_sample].timestamp : st->duration;\n        pkt->duration = next_dts - pkt->dts;\n        pkt->pts = pkt->dts;\n    }\n    if (st->discard == AVDISCARD_ALL)\n        goto retry;\n    pkt->flags |= sample->flags & AVINDEX_KEYFRAME ? AV_PKT_FLAG_KEY : 0;\n    pkt->pos = sample->pos;\n\n    /* Multiple stsd handling. */\n    if (sc->stsc_data) {\n        /* Keep track of the stsc index for the given sample, then check\n        * if the stsd index is different from the last used one. */\n        sc->stsc_sample++;\n        if (mov_stsc_index_valid(sc->stsc_index, sc->stsc_count) &&\n            mov_get_stsc_samples(sc, sc->stsc_index) == sc->stsc_sample) {\n            sc->stsc_index++;\n            sc->stsc_sample = 0;\n        /* Do not check indexes after a switch. */\n        } else if (sc->stsc_data[sc->stsc_index].id > 0 &&\n                   sc->stsc_data[sc->stsc_index].id - 1 < sc->stsd_count &&\n                   sc->stsc_data[sc->stsc_index].id - 1 != sc->last_stsd_index) {\n            ret = mov_change_extradata(sc, pkt);\n            if (ret < 0)\n                return ret;\n        }\n    }\n\n    if (mov->aax_mode)\n        aax_filter(pkt->data, pkt->size, mov);\n\n    if (sc->cenc.aes_ctr) {\n        ret = cenc_filter(mov, sc, current_index, pkt->data, pkt->size);\n        if (ret) {\n            return ret;\n        }\n    }\n\n    return 0;\n}\n\nstatic int mov_seek_fragment(AVFormatContext *s, AVStream *st, int64_t timestamp)\n{\n    MOVContext *mov = s->priv_data;\n    MOVStreamContext *sc = st->priv_data;\n    int i, j;\n\n    if (!mov->fragment_index_complete)\n        return 0;\n\n    for (i = 0; i < mov->fragment_index_count; i++) {\n        if (mov->fragment_index_data[i]->track_id == st->id || !sc->has_sidx) {\n            MOVFragmentIndex *index = mov->fragment_index_data[i];\n            for (j = index->item_count - 1; j >= 0; j--) {\n                if (index->items[j].time <= timestamp) {\n                    if (index->items[j].headers_read)\n                        return 0;\n\n                    return mov_switch_root(s, index->items[j].moof_offset);\n                }\n            }\n        }\n    }\n\n    return 0;\n}\n\nstatic int mov_seek_stream(AVFormatContext *s, AVStream *st, int64_t timestamp, int flags)\n{\n    MOVStreamContext *sc = st->priv_data;\n    int sample, time_sample;\n    int i;\n\n    int ret = mov_seek_fragment(s, st, timestamp);\n    if (ret < 0)\n        return ret;\n\n    sample = av_index_search_timestamp(st, timestamp, flags);\n    av_log(s, AV_LOG_TRACE, \"stream %d, timestamp %\"PRId64\", sample %d\\n\", st->index, timestamp, sample);\n    if (sample < 0 && st->nb_index_entries && timestamp < st->index_entries[0].timestamp)\n        sample = 0;\n    if (sample < 0) /* not sure what to do */\n        return AVERROR_INVALIDDATA;\n    mov_current_sample_set(sc, sample);\n    av_log(s, AV_LOG_TRACE, \"stream %d, found sample %d\\n\", st->index, sc->current_sample);\n    /* adjust ctts index */\n    if (sc->ctts_data) {\n        time_sample = 0;\n        for (i = 0; i < sc->ctts_count; i++) {\n            int next = time_sample + sc->ctts_data[i].count;\n            if (next > sc->current_sample) {\n                sc->ctts_index = i;\n                sc->ctts_sample = sc->current_sample - time_sample;\n                break;\n            }\n            time_sample = next;\n        }\n    }\n\n    /* adjust stsd index */\n    time_sample = 0;\n    for (i = 0; i < sc->stsc_count; i++) {\n        int next = time_sample + mov_get_stsc_samples(sc, i);\n        if (next > sc->current_sample) {\n            sc->stsc_index = i;\n            sc->stsc_sample = sc->current_sample - time_sample;\n            break;\n        }\n        time_sample = next;\n    }\n\n    return sample;\n}\n\nstatic int mov_read_seek(AVFormatContext *s, int stream_index, int64_t sample_time, int flags)\n{\n    MOVContext *mc = s->priv_data;\n    AVStream *st;\n    int sample;\n    int i;\n\n    if (stream_index >= s->nb_streams)\n        return AVERROR_INVALIDDATA;\n\n    st = s->streams[stream_index];\n    sample = mov_seek_stream(s, st, sample_time, flags);\n    if (sample < 0)\n        return sample;\n\n    if (mc->seek_individually) {\n        /* adjust seek timestamp to found sample timestamp */\n        int64_t seek_timestamp = st->index_entries[sample].timestamp;\n\n        for (i = 0; i < s->nb_streams; i++) {\n            int64_t timestamp;\n            MOVStreamContext *sc = s->streams[i]->priv_data;\n            st = s->streams[i];\n            st->skip_samples = (sample_time <= 0) ? sc->start_pad : 0;\n\n            if (stream_index == i)\n                continue;\n\n            timestamp = av_rescale_q(seek_timestamp, s->streams[stream_index]->time_base, st->time_base);\n            mov_seek_stream(s, st, timestamp, flags);\n        }\n    } else {\n        for (i = 0; i < s->nb_streams; i++) {\n            MOVStreamContext *sc;\n            st = s->streams[i];\n            sc = st->priv_data;\n            mov_current_sample_set(sc, 0);\n        }\n        while (1) {\n            MOVStreamContext *sc;\n            AVIndexEntry *entry = mov_find_next_sample(s, &st);\n            if (!entry)\n                return AVERROR_INVALIDDATA;\n            sc = st->priv_data;\n            if (sc->ffindex == stream_index && sc->current_sample == sample)\n                break;\n            mov_current_sample_inc(sc);\n        }\n    }\n    return 0;\n}\n\n#define OFFSET(x) offsetof(MOVContext, x)\n#define FLAGS AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM\nstatic const AVOption mov_options[] = {\n    {\"use_absolute_path\",\n        \"allow using absolute path when opening alias, this is a possible security issue\",\n        OFFSET(use_absolute_path), AV_OPT_TYPE_BOOL, {.i64 = 0},\n        0, 1, FLAGS},\n    {\"seek_streams_individually\",\n        \"Seek each stream individually to the to the closest point\",\n        OFFSET(seek_individually), AV_OPT_TYPE_BOOL, { .i64 = 1 },\n        0, 1, FLAGS},\n    {\"ignore_editlist\", \"Ignore the edit list atom.\", OFFSET(ignore_editlist), AV_OPT_TYPE_BOOL, {.i64 = 0},\n        0, 1, FLAGS},\n    {\"advanced_editlist\",\n        \"Modify the AVIndex according to the editlists. Use this option to decode in the order specified by the edits.\",\n        OFFSET(advanced_editlist), AV_OPT_TYPE_BOOL, {.i64 = 1},\n        0, 1, FLAGS},\n    {\"ignore_chapters\", \"\", OFFSET(ignore_chapters), AV_OPT_TYPE_BOOL, {.i64 = 0},\n        0, 1, FLAGS},\n    {\"use_mfra_for\",\n        \"use mfra for fragment timestamps\",\n        OFFSET(use_mfra_for), AV_OPT_TYPE_INT, {.i64 = FF_MOV_FLAG_MFRA_AUTO},\n        -1, FF_MOV_FLAG_MFRA_PTS, FLAGS,\n        \"use_mfra_for\"},\n    {\"auto\", \"auto\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_MFRA_AUTO}, 0, 0,\n        FLAGS, \"use_mfra_for\" },\n    {\"dts\", \"dts\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_MFRA_DTS}, 0, 0,\n        FLAGS, \"use_mfra_for\" },\n    {\"pts\", \"pts\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_MFRA_PTS}, 0, 0,\n        FLAGS, \"use_mfra_for\" },\n    { \"export_all\", \"Export unrecognized metadata entries\", OFFSET(export_all),\n        AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, .flags = FLAGS },\n    { \"export_xmp\", \"Export full XMP metadata\", OFFSET(export_xmp),\n        AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, .flags = FLAGS },\n    { \"activation_bytes\", \"Secret bytes for Audible AAX files\", OFFSET(activation_bytes),\n        AV_OPT_TYPE_BINARY, .flags = AV_OPT_FLAG_DECODING_PARAM },\n    { \"audible_fixed_key\", // extracted from libAAX_SDK.so and AAXSDKWin.dll files!\n        \"Fixed key used for handling Audible AAX files\", OFFSET(audible_fixed_key),\n        AV_OPT_TYPE_BINARY, {.str=\"77214d4b196a87cd520045fd20a51d67\"},\n        .flags = AV_OPT_FLAG_DECODING_PARAM },\n    { \"decryption_key\", \"The media decryption key (hex)\", OFFSET(decryption_key), AV_OPT_TYPE_BINARY, .flags = AV_OPT_FLAG_DECODING_PARAM },\n    { \"enable_drefs\", \"Enable external track support.\", OFFSET(enable_drefs), AV_OPT_TYPE_BOOL,\n        {.i64 = 0}, 0, 1, FLAGS },\n\n    { NULL },\n};\n\nstatic const AVClass mov_class = {\n    .class_name = \"mov,mp4,m4a,3gp,3g2,mj2\",\n    .item_name  = av_default_item_name,\n    .option     = mov_options,\n    .version    = LIBAVUTIL_VERSION_INT,\n};\n\nAVInputFormat ff_mov_demuxer = {\n    .name           = \"mov,mp4,m4a,3gp,3g2,mj2\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"QuickTime / MOV\"),\n    .priv_class     = &mov_class,\n    .priv_data_size = sizeof(MOVContext),\n    .extensions     = \"mov,mp4,m4a,3gp,3g2,mj2\",\n    .read_probe     = mov_probe,\n    .read_header    = mov_read_header,\n    .read_packet    = mov_read_packet,\n    .read_close     = mov_read_close,\n    .read_seek      = mov_read_seek,\n    .flags          = AVFMT_NO_BYTE_SEEK,\n};\n"], "fixing_code": ["/*\n * MOV demuxer\n * Copyright (c) 2001 Fabrice Bellard\n * Copyright (c) 2009 Baptiste Coudurier <baptiste dot coudurier at gmail dot com>\n *\n * first version by Francois Revol <revol@free.fr>\n * seek function by Gael Chardon <gael.dev@4now.net>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include <inttypes.h>\n#include <limits.h>\n#include <stdint.h>\n\n#include \"libavutil/attributes.h\"\n#include \"libavutil/channel_layout.h\"\n#include \"libavutil/internal.h\"\n#include \"libavutil/intreadwrite.h\"\n#include \"libavutil/intfloat.h\"\n#include \"libavutil/mathematics.h\"\n#include \"libavutil/time_internal.h\"\n#include \"libavutil/avassert.h\"\n#include \"libavutil/avstring.h\"\n#include \"libavutil/dict.h\"\n#include \"libavutil/display.h\"\n#include \"libavutil/opt.h\"\n#include \"libavutil/aes.h\"\n#include \"libavutil/aes_ctr.h\"\n#include \"libavutil/pixdesc.h\"\n#include \"libavutil/sha.h\"\n#include \"libavutil/spherical.h\"\n#include \"libavutil/stereo3d.h\"\n#include \"libavutil/timecode.h\"\n#include \"libavcodec/ac3tab.h\"\n#include \"libavcodec/flac.h\"\n#include \"libavcodec/mpegaudiodecheader.h\"\n#include \"avformat.h\"\n#include \"internal.h\"\n#include \"avio_internal.h\"\n#include \"riff.h\"\n#include \"isom.h\"\n#include \"libavcodec/get_bits.h\"\n#include \"id3v1.h\"\n#include \"mov_chan.h\"\n#include \"replaygain.h\"\n\n#if CONFIG_ZLIB\n#include <zlib.h>\n#endif\n\n#include \"qtpalette.h\"\n\n/* those functions parse an atom */\n/* links atom IDs to parse functions */\ntypedef struct MOVParseTableEntry {\n    uint32_t type;\n    int (*parse)(MOVContext *ctx, AVIOContext *pb, MOVAtom atom);\n} MOVParseTableEntry;\n\nstatic int mov_read_default(MOVContext *c, AVIOContext *pb, MOVAtom atom);\nstatic int mov_read_mfra(MOVContext *c, AVIOContext *f);\nstatic int64_t add_ctts_entry(MOVStts** ctts_data, unsigned int* ctts_count, unsigned int* allocated_size,\n                              int count, int duration);\n\nstatic int mov_metadata_track_or_disc_number(MOVContext *c, AVIOContext *pb,\n                                             unsigned len, const char *key)\n{\n    char buf[16];\n\n    short current, total = 0;\n    avio_rb16(pb); // unknown\n    current = avio_rb16(pb);\n    if (len >= 6)\n        total = avio_rb16(pb);\n    if (!total)\n        snprintf(buf, sizeof(buf), \"%d\", current);\n    else\n        snprintf(buf, sizeof(buf), \"%d/%d\", current, total);\n    c->fc->event_flags |= AVFMT_EVENT_FLAG_METADATA_UPDATED;\n    av_dict_set(&c->fc->metadata, key, buf, 0);\n\n    return 0;\n}\n\nstatic int mov_metadata_int8_bypass_padding(MOVContext *c, AVIOContext *pb,\n                                            unsigned len, const char *key)\n{\n    /* bypass padding bytes */\n    avio_r8(pb);\n    avio_r8(pb);\n    avio_r8(pb);\n\n    c->fc->event_flags |= AVFMT_EVENT_FLAG_METADATA_UPDATED;\n    av_dict_set_int(&c->fc->metadata, key, avio_r8(pb), 0);\n\n    return 0;\n}\n\nstatic int mov_metadata_int8_no_padding(MOVContext *c, AVIOContext *pb,\n                                        unsigned len, const char *key)\n{\n    c->fc->event_flags |= AVFMT_EVENT_FLAG_METADATA_UPDATED;\n    av_dict_set_int(&c->fc->metadata, key, avio_r8(pb), 0);\n\n    return 0;\n}\n\nstatic int mov_metadata_gnre(MOVContext *c, AVIOContext *pb,\n                             unsigned len, const char *key)\n{\n    short genre;\n\n    avio_r8(pb); // unknown\n\n    genre = avio_r8(pb);\n    if (genre < 1 || genre > ID3v1_GENRE_MAX)\n        return 0;\n    c->fc->event_flags |= AVFMT_EVENT_FLAG_METADATA_UPDATED;\n    av_dict_set(&c->fc->metadata, key, ff_id3v1_genre_str[genre-1], 0);\n\n    return 0;\n}\n\nstatic const uint32_t mac_to_unicode[128] = {\n    0x00C4,0x00C5,0x00C7,0x00C9,0x00D1,0x00D6,0x00DC,0x00E1,\n    0x00E0,0x00E2,0x00E4,0x00E3,0x00E5,0x00E7,0x00E9,0x00E8,\n    0x00EA,0x00EB,0x00ED,0x00EC,0x00EE,0x00EF,0x00F1,0x00F3,\n    0x00F2,0x00F4,0x00F6,0x00F5,0x00FA,0x00F9,0x00FB,0x00FC,\n    0x2020,0x00B0,0x00A2,0x00A3,0x00A7,0x2022,0x00B6,0x00DF,\n    0x00AE,0x00A9,0x2122,0x00B4,0x00A8,0x2260,0x00C6,0x00D8,\n    0x221E,0x00B1,0x2264,0x2265,0x00A5,0x00B5,0x2202,0x2211,\n    0x220F,0x03C0,0x222B,0x00AA,0x00BA,0x03A9,0x00E6,0x00F8,\n    0x00BF,0x00A1,0x00AC,0x221A,0x0192,0x2248,0x2206,0x00AB,\n    0x00BB,0x2026,0x00A0,0x00C0,0x00C3,0x00D5,0x0152,0x0153,\n    0x2013,0x2014,0x201C,0x201D,0x2018,0x2019,0x00F7,0x25CA,\n    0x00FF,0x0178,0x2044,0x20AC,0x2039,0x203A,0xFB01,0xFB02,\n    0x2021,0x00B7,0x201A,0x201E,0x2030,0x00C2,0x00CA,0x00C1,\n    0x00CB,0x00C8,0x00CD,0x00CE,0x00CF,0x00CC,0x00D3,0x00D4,\n    0xF8FF,0x00D2,0x00DA,0x00DB,0x00D9,0x0131,0x02C6,0x02DC,\n    0x00AF,0x02D8,0x02D9,0x02DA,0x00B8,0x02DD,0x02DB,0x02C7,\n};\n\nstatic int mov_read_mac_string(MOVContext *c, AVIOContext *pb, int len,\n                               char *dst, int dstlen)\n{\n    char *p = dst;\n    char *end = dst+dstlen-1;\n    int i;\n\n    for (i = 0; i < len; i++) {\n        uint8_t t, c = avio_r8(pb);\n\n        if (p >= end)\n            continue;\n\n        if (c < 0x80)\n            *p++ = c;\n        else if (p < end)\n            PUT_UTF8(mac_to_unicode[c-0x80], t, if (p < end) *p++ = t;);\n    }\n    *p = 0;\n    return p - dst;\n}\n\nstatic int mov_read_covr(MOVContext *c, AVIOContext *pb, int type, int len)\n{\n    AVPacket pkt;\n    AVStream *st;\n    MOVStreamContext *sc;\n    enum AVCodecID id;\n    int ret;\n\n    switch (type) {\n    case 0xd:  id = AV_CODEC_ID_MJPEG; break;\n    case 0xe:  id = AV_CODEC_ID_PNG;   break;\n    case 0x1b: id = AV_CODEC_ID_BMP;   break;\n    default:\n        av_log(c->fc, AV_LOG_WARNING, \"Unknown cover type: 0x%x.\\n\", type);\n        avio_skip(pb, len);\n        return 0;\n    }\n\n    st = avformat_new_stream(c->fc, NULL);\n    if (!st)\n        return AVERROR(ENOMEM);\n    sc = av_mallocz(sizeof(*sc));\n    if (!sc)\n        return AVERROR(ENOMEM);\n    st->priv_data = sc;\n\n    ret = av_get_packet(pb, &pkt, len);\n    if (ret < 0)\n        return ret;\n\n    if (pkt.size >= 8 && id != AV_CODEC_ID_BMP) {\n        if (AV_RB64(pkt.data) == 0x89504e470d0a1a0a) {\n            id = AV_CODEC_ID_PNG;\n        } else {\n            id = AV_CODEC_ID_MJPEG;\n        }\n    }\n\n    st->disposition              |= AV_DISPOSITION_ATTACHED_PIC;\n\n    st->attached_pic              = pkt;\n    st->attached_pic.stream_index = st->index;\n    st->attached_pic.flags       |= AV_PKT_FLAG_KEY;\n\n    st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n    st->codecpar->codec_id   = id;\n\n    return 0;\n}\n\n// 3GPP TS 26.244\nstatic int mov_metadata_loci(MOVContext *c, AVIOContext *pb, unsigned len)\n{\n    char language[4] = { 0 };\n    char buf[200], place[100];\n    uint16_t langcode = 0;\n    double longitude, latitude, altitude;\n    const char *key = \"location\";\n\n    if (len < 4 + 2 + 1 + 1 + 4 + 4 + 4) {\n        av_log(c->fc, AV_LOG_ERROR, \"loci too short\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    avio_skip(pb, 4); // version+flags\n    langcode = avio_rb16(pb);\n    ff_mov_lang_to_iso639(langcode, language);\n    len -= 6;\n\n    len -= avio_get_str(pb, len, place, sizeof(place));\n    if (len < 1) {\n        av_log(c->fc, AV_LOG_ERROR, \"place name too long\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    avio_skip(pb, 1); // role\n    len -= 1;\n\n    if (len < 12) {\n        av_log(c->fc, AV_LOG_ERROR,\n               \"loci too short (%u bytes left, need at least %d)\\n\", len, 12);\n        return AVERROR_INVALIDDATA;\n    }\n    longitude = ((int32_t) avio_rb32(pb)) / (float) (1 << 16);\n    latitude  = ((int32_t) avio_rb32(pb)) / (float) (1 << 16);\n    altitude  = ((int32_t) avio_rb32(pb)) / (float) (1 << 16);\n\n    // Try to output in the same format as the ?xyz field\n    snprintf(buf, sizeof(buf), \"%+08.4f%+09.4f\",  latitude, longitude);\n    if (altitude)\n        av_strlcatf(buf, sizeof(buf), \"%+f\", altitude);\n    av_strlcatf(buf, sizeof(buf), \"/%s\", place);\n\n    if (*language && strcmp(language, \"und\")) {\n        char key2[16];\n        snprintf(key2, sizeof(key2), \"%s-%s\", key, language);\n        av_dict_set(&c->fc->metadata, key2, buf, 0);\n    }\n    c->fc->event_flags |= AVFMT_EVENT_FLAG_METADATA_UPDATED;\n    return av_dict_set(&c->fc->metadata, key, buf, 0);\n}\n\nstatic int mov_metadata_hmmt(MOVContext *c, AVIOContext *pb, unsigned len)\n{\n    int i, n_hmmt;\n\n    if (len < 2)\n        return 0;\n    if (c->ignore_chapters)\n        return 0;\n\n    n_hmmt = avio_rb32(pb);\n    for (i = 0; i < n_hmmt && !pb->eof_reached; i++) {\n        int moment_time = avio_rb32(pb);\n        avpriv_new_chapter(c->fc, i, av_make_q(1, 1000), moment_time, AV_NOPTS_VALUE, NULL);\n    }\n    return 0;\n}\n\nstatic int mov_read_udta_string(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    char tmp_key[5];\n    char key2[32], language[4] = {0};\n    char *str = NULL;\n    const char *key = NULL;\n    uint16_t langcode = 0;\n    uint32_t data_type = 0, str_size, str_size_alloc;\n    int (*parse)(MOVContext*, AVIOContext*, unsigned, const char*) = NULL;\n    int raw = 0;\n    int num = 0;\n\n    switch (atom.type) {\n    case MKTAG( '@','P','R','M'): key = \"premiere_version\"; raw = 1; break;\n    case MKTAG( '@','P','R','Q'): key = \"quicktime_version\"; raw = 1; break;\n    case MKTAG( 'X','M','P','_'):\n        if (c->export_xmp) { key = \"xmp\"; raw = 1; } break;\n    case MKTAG( 'a','A','R','T'): key = \"album_artist\";    break;\n    case MKTAG( 'a','k','I','D'): key = \"account_type\";\n        parse = mov_metadata_int8_no_padding; break;\n    case MKTAG( 'a','p','I','D'): key = \"account_id\"; break;\n    case MKTAG( 'c','a','t','g'): key = \"category\"; break;\n    case MKTAG( 'c','p','i','l'): key = \"compilation\";\n        parse = mov_metadata_int8_no_padding; break;\n    case MKTAG( 'c','p','r','t'): key = \"copyright\"; break;\n    case MKTAG( 'd','e','s','c'): key = \"description\"; break;\n    case MKTAG( 'd','i','s','k'): key = \"disc\";\n        parse = mov_metadata_track_or_disc_number; break;\n    case MKTAG( 'e','g','i','d'): key = \"episode_uid\";\n        parse = mov_metadata_int8_no_padding; break;\n    case MKTAG( 'F','I','R','M'): key = \"firmware\"; raw = 1; break;\n    case MKTAG( 'g','n','r','e'): key = \"genre\";\n        parse = mov_metadata_gnre; break;\n    case MKTAG( 'h','d','v','d'): key = \"hd_video\";\n        parse = mov_metadata_int8_no_padding; break;\n    case MKTAG( 'H','M','M','T'):\n        return mov_metadata_hmmt(c, pb, atom.size);\n    case MKTAG( 'k','e','y','w'): key = \"keywords\";  break;\n    case MKTAG( 'l','d','e','s'): key = \"synopsis\";  break;\n    case MKTAG( 'l','o','c','i'):\n        return mov_metadata_loci(c, pb, atom.size);\n    case MKTAG( 'p','c','s','t'): key = \"podcast\";\n        parse = mov_metadata_int8_no_padding; break;\n    case MKTAG( 'p','g','a','p'): key = \"gapless_playback\";\n        parse = mov_metadata_int8_no_padding; break;\n    case MKTAG( 'p','u','r','d'): key = \"purchase_date\"; break;\n    case MKTAG( 'r','t','n','g'): key = \"rating\";\n        parse = mov_metadata_int8_no_padding; break;\n    case MKTAG( 's','o','a','a'): key = \"sort_album_artist\"; break;\n    case MKTAG( 's','o','a','l'): key = \"sort_album\";   break;\n    case MKTAG( 's','o','a','r'): key = \"sort_artist\";  break;\n    case MKTAG( 's','o','c','o'): key = \"sort_composer\"; break;\n    case MKTAG( 's','o','n','m'): key = \"sort_name\";    break;\n    case MKTAG( 's','o','s','n'): key = \"sort_show\";    break;\n    case MKTAG( 's','t','i','k'): key = \"media_type\";\n        parse = mov_metadata_int8_no_padding; break;\n    case MKTAG( 't','r','k','n'): key = \"track\";\n        parse = mov_metadata_track_or_disc_number; break;\n    case MKTAG( 't','v','e','n'): key = \"episode_id\"; break;\n    case MKTAG( 't','v','e','s'): key = \"episode_sort\";\n        parse = mov_metadata_int8_bypass_padding; break;\n    case MKTAG( 't','v','n','n'): key = \"network\";   break;\n    case MKTAG( 't','v','s','h'): key = \"show\";      break;\n    case MKTAG( 't','v','s','n'): key = \"season_number\";\n        parse = mov_metadata_int8_bypass_padding; break;\n    case MKTAG(0xa9,'A','R','T'): key = \"artist\";    break;\n    case MKTAG(0xa9,'P','R','D'): key = \"producer\";  break;\n    case MKTAG(0xa9,'a','l','b'): key = \"album\";     break;\n    case MKTAG(0xa9,'a','u','t'): key = \"artist\";    break;\n    case MKTAG(0xa9,'c','h','p'): key = \"chapter\";   break;\n    case MKTAG(0xa9,'c','m','t'): key = \"comment\";   break;\n    case MKTAG(0xa9,'c','o','m'): key = \"composer\";  break;\n    case MKTAG(0xa9,'c','p','y'): key = \"copyright\"; break;\n    case MKTAG(0xa9,'d','a','y'): key = \"date\";      break;\n    case MKTAG(0xa9,'d','i','r'): key = \"director\";  break;\n    case MKTAG(0xa9,'d','i','s'): key = \"disclaimer\"; break;\n    case MKTAG(0xa9,'e','d','1'): key = \"edit_date\"; break;\n    case MKTAG(0xa9,'e','n','c'): key = \"encoder\";   break;\n    case MKTAG(0xa9,'f','m','t'): key = \"original_format\"; break;\n    case MKTAG(0xa9,'g','e','n'): key = \"genre\";     break;\n    case MKTAG(0xa9,'g','r','p'): key = \"grouping\";  break;\n    case MKTAG(0xa9,'h','s','t'): key = \"host_computer\"; break;\n    case MKTAG(0xa9,'i','n','f'): key = \"comment\";   break;\n    case MKTAG(0xa9,'l','y','r'): key = \"lyrics\";    break;\n    case MKTAG(0xa9,'m','a','k'): key = \"make\";      break;\n    case MKTAG(0xa9,'m','o','d'): key = \"model\";     break;\n    case MKTAG(0xa9,'n','a','m'): key = \"title\";     break;\n    case MKTAG(0xa9,'o','p','e'): key = \"original_artist\"; break;\n    case MKTAG(0xa9,'p','r','d'): key = \"producer\";  break;\n    case MKTAG(0xa9,'p','r','f'): key = \"performers\"; break;\n    case MKTAG(0xa9,'r','e','q'): key = \"playback_requirements\"; break;\n    case MKTAG(0xa9,'s','r','c'): key = \"original_source\"; break;\n    case MKTAG(0xa9,'s','t','3'): key = \"subtitle\";  break;\n    case MKTAG(0xa9,'s','w','r'): key = \"encoder\";   break;\n    case MKTAG(0xa9,'t','o','o'): key = \"encoder\";   break;\n    case MKTAG(0xa9,'t','r','k'): key = \"track\";     break;\n    case MKTAG(0xa9,'u','r','l'): key = \"URL\";       break;\n    case MKTAG(0xa9,'w','r','n'): key = \"warning\";   break;\n    case MKTAG(0xa9,'w','r','t'): key = \"composer\";  break;\n    case MKTAG(0xa9,'x','y','z'): key = \"location\";  break;\n    }\nretry:\n    if (c->itunes_metadata && atom.size > 8) {\n        int data_size = avio_rb32(pb);\n        int tag = avio_rl32(pb);\n        if (tag == MKTAG('d','a','t','a') && data_size <= atom.size) {\n            data_type = avio_rb32(pb); // type\n            avio_rb32(pb); // unknown\n            str_size = data_size - 16;\n            atom.size -= 16;\n\n            if (atom.type == MKTAG('c', 'o', 'v', 'r')) {\n                int ret = mov_read_covr(c, pb, data_type, str_size);\n                if (ret < 0) {\n                    av_log(c->fc, AV_LOG_ERROR, \"Error parsing cover art.\\n\");\n                }\n                return ret;\n            } else if (!key && c->found_hdlr_mdta && c->meta_keys) {\n                uint32_t index = AV_RB32(&atom.type);\n                if (index < c->meta_keys_count && index > 0) {\n                    key = c->meta_keys[index];\n                } else {\n                    av_log(c->fc, AV_LOG_WARNING,\n                           \"The index of 'data' is out of range: %\"PRId32\" < 1 or >= %d.\\n\",\n                           index, c->meta_keys_count);\n                }\n            }\n        } else return 0;\n    } else if (atom.size > 4 && key && !c->itunes_metadata && !raw) {\n        str_size = avio_rb16(pb); // string length\n        if (str_size > atom.size) {\n            raw = 1;\n            avio_seek(pb, -2, SEEK_CUR);\n            av_log(c->fc, AV_LOG_WARNING, \"UDTA parsing failed retrying raw\\n\");\n            goto retry;\n        }\n        langcode = avio_rb16(pb);\n        ff_mov_lang_to_iso639(langcode, language);\n        atom.size -= 4;\n    } else\n        str_size = atom.size;\n\n    if (c->export_all && !key) {\n        snprintf(tmp_key, 5, \"%.4s\", (char*)&atom.type);\n        key = tmp_key;\n    }\n\n    if (!key)\n        return 0;\n    if (atom.size < 0 || str_size >= INT_MAX/2)\n        return AVERROR_INVALIDDATA;\n\n    // Allocates enough space if data_type is a int32 or float32 number, otherwise\n    // worst-case requirement for output string in case of utf8 coded input\n    num = (data_type >= 21 && data_type <= 23);\n    str_size_alloc = (num ? 512 : (raw ? str_size : str_size * 2)) + 1;\n    str = av_mallocz(str_size_alloc);\n    if (!str)\n        return AVERROR(ENOMEM);\n\n    if (parse)\n        parse(c, pb, str_size, key);\n    else {\n        if (!raw && (data_type == 3 || (data_type == 0 && (langcode < 0x400 || langcode == 0x7fff)))) { // MAC Encoded\n            mov_read_mac_string(c, pb, str_size, str, str_size_alloc);\n        } else if (data_type == 21) { // BE signed integer, variable size\n            int val = 0;\n            if (str_size == 1)\n                val = (int8_t)avio_r8(pb);\n            else if (str_size == 2)\n                val = (int16_t)avio_rb16(pb);\n            else if (str_size == 3)\n                val = ((int32_t)(avio_rb24(pb)<<8))>>8;\n            else if (str_size == 4)\n                val = (int32_t)avio_rb32(pb);\n            if (snprintf(str, str_size_alloc, \"%d\", val) >= str_size_alloc) {\n                av_log(c->fc, AV_LOG_ERROR,\n                       \"Failed to store the number (%d) in string.\\n\", val);\n                av_free(str);\n                return AVERROR_INVALIDDATA;\n            }\n        } else if (data_type == 22) { // BE unsigned integer, variable size\n            unsigned int val = 0;\n            if (str_size == 1)\n                val = avio_r8(pb);\n            else if (str_size == 2)\n                val = avio_rb16(pb);\n            else if (str_size == 3)\n                val = avio_rb24(pb);\n            else if (str_size == 4)\n                val = avio_rb32(pb);\n            if (snprintf(str, str_size_alloc, \"%u\", val) >= str_size_alloc) {\n                av_log(c->fc, AV_LOG_ERROR,\n                       \"Failed to store the number (%u) in string.\\n\", val);\n                av_free(str);\n                return AVERROR_INVALIDDATA;\n            }\n        } else if (data_type == 23 && str_size >= 4) {  // BE float32\n            float val = av_int2float(avio_rb32(pb));\n            if (snprintf(str, str_size_alloc, \"%f\", val) >= str_size_alloc) {\n                av_log(c->fc, AV_LOG_ERROR,\n                       \"Failed to store the float32 number (%f) in string.\\n\", val);\n                av_free(str);\n                return AVERROR_INVALIDDATA;\n            }\n        } else {\n            int ret = ffio_read_size(pb, str, str_size);\n            if (ret < 0) {\n                av_free(str);\n                return ret;\n            }\n            str[str_size] = 0;\n        }\n        c->fc->event_flags |= AVFMT_EVENT_FLAG_METADATA_UPDATED;\n        av_dict_set(&c->fc->metadata, key, str, 0);\n        if (*language && strcmp(language, \"und\")) {\n            snprintf(key2, sizeof(key2), \"%s-%s\", key, language);\n            av_dict_set(&c->fc->metadata, key2, str, 0);\n        }\n        if (!strcmp(key, \"encoder\")) {\n            int major, minor, micro;\n            if (sscanf(str, \"HandBrake %d.%d.%d\", &major, &minor, &micro) == 3) {\n                c->handbrake_version = 1000000*major + 1000*minor + micro;\n            }\n        }\n    }\n\n    av_freep(&str);\n    return 0;\n}\n\nstatic int mov_read_chpl(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int64_t start;\n    int i, nb_chapters, str_len, version;\n    char str[256+1];\n    int ret;\n\n    if (c->ignore_chapters)\n        return 0;\n\n    if ((atom.size -= 5) < 0)\n        return 0;\n\n    version = avio_r8(pb);\n    avio_rb24(pb);\n    if (version)\n        avio_rb32(pb); // ???\n    nb_chapters = avio_r8(pb);\n\n    for (i = 0; i < nb_chapters; i++) {\n        if (atom.size < 9)\n            return 0;\n\n        start = avio_rb64(pb);\n        str_len = avio_r8(pb);\n\n        if ((atom.size -= 9+str_len) < 0)\n            return 0;\n\n        ret = ffio_read_size(pb, str, str_len);\n        if (ret < 0)\n            return ret;\n        str[str_len] = 0;\n        avpriv_new_chapter(c->fc, i, (AVRational){1,10000000}, start, AV_NOPTS_VALUE, str);\n    }\n    return 0;\n}\n\n#define MIN_DATA_ENTRY_BOX_SIZE 12\nstatic int mov_read_dref(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int entries, i, j;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_rb32(pb); // version + flags\n    entries = avio_rb32(pb);\n    if (!entries ||\n        entries >  (atom.size - 1) / MIN_DATA_ENTRY_BOX_SIZE + 1 ||\n        entries >= UINT_MAX / sizeof(*sc->drefs))\n        return AVERROR_INVALIDDATA;\n    sc->drefs_count = 0;\n    av_free(sc->drefs);\n    sc->drefs_count = 0;\n    sc->drefs = av_mallocz(entries * sizeof(*sc->drefs));\n    if (!sc->drefs)\n        return AVERROR(ENOMEM);\n    sc->drefs_count = entries;\n\n    for (i = 0; i < entries; i++) {\n        MOVDref *dref = &sc->drefs[i];\n        uint32_t size = avio_rb32(pb);\n        int64_t next = avio_tell(pb) + size - 4;\n\n        if (size < 12)\n            return AVERROR_INVALIDDATA;\n\n        dref->type = avio_rl32(pb);\n        avio_rb32(pb); // version + flags\n\n        if (dref->type == MKTAG('a','l','i','s') && size > 150) {\n            /* macintosh alias record */\n            uint16_t volume_len, len;\n            int16_t type;\n            int ret;\n\n            avio_skip(pb, 10);\n\n            volume_len = avio_r8(pb);\n            volume_len = FFMIN(volume_len, 27);\n            ret = ffio_read_size(pb, dref->volume, 27);\n            if (ret < 0)\n                return ret;\n            dref->volume[volume_len] = 0;\n            av_log(c->fc, AV_LOG_DEBUG, \"volume %s, len %d\\n\", dref->volume, volume_len);\n\n            avio_skip(pb, 12);\n\n            len = avio_r8(pb);\n            len = FFMIN(len, 63);\n            ret = ffio_read_size(pb, dref->filename, 63);\n            if (ret < 0)\n                return ret;\n            dref->filename[len] = 0;\n            av_log(c->fc, AV_LOG_DEBUG, \"filename %s, len %d\\n\", dref->filename, len);\n\n            avio_skip(pb, 16);\n\n            /* read next level up_from_alias/down_to_target */\n            dref->nlvl_from = avio_rb16(pb);\n            dref->nlvl_to   = avio_rb16(pb);\n            av_log(c->fc, AV_LOG_DEBUG, \"nlvl from %d, nlvl to %d\\n\",\n                   dref->nlvl_from, dref->nlvl_to);\n\n            avio_skip(pb, 16);\n\n            for (type = 0; type != -1 && avio_tell(pb) < next; ) {\n                if(avio_feof(pb))\n                    return AVERROR_EOF;\n                type = avio_rb16(pb);\n                len = avio_rb16(pb);\n                av_log(c->fc, AV_LOG_DEBUG, \"type %d, len %d\\n\", type, len);\n                if (len&1)\n                    len += 1;\n                if (type == 2) { // absolute path\n                    av_free(dref->path);\n                    dref->path = av_mallocz(len+1);\n                    if (!dref->path)\n                        return AVERROR(ENOMEM);\n\n                    ret = ffio_read_size(pb, dref->path, len);\n                    if (ret < 0) {\n                        av_freep(&dref->path);\n                        return ret;\n                    }\n                    if (len > volume_len && !strncmp(dref->path, dref->volume, volume_len)) {\n                        len -= volume_len;\n                        memmove(dref->path, dref->path+volume_len, len);\n                        dref->path[len] = 0;\n                    }\n                    // trim string of any ending zeros\n                    for (j = len - 1; j >= 0; j--) {\n                        if (dref->path[j] == 0)\n                            len--;\n                        else\n                            break;\n                    }\n                    for (j = 0; j < len; j++)\n                        if (dref->path[j] == ':' || dref->path[j] == 0)\n                            dref->path[j] = '/';\n                    av_log(c->fc, AV_LOG_DEBUG, \"path %s\\n\", dref->path);\n                } else if (type == 0) { // directory name\n                    av_free(dref->dir);\n                    dref->dir = av_malloc(len+1);\n                    if (!dref->dir)\n                        return AVERROR(ENOMEM);\n\n                    ret = ffio_read_size(pb, dref->dir, len);\n                    if (ret < 0) {\n                        av_freep(&dref->dir);\n                        return ret;\n                    }\n                    dref->dir[len] = 0;\n                    for (j = 0; j < len; j++)\n                        if (dref->dir[j] == ':')\n                            dref->dir[j] = '/';\n                    av_log(c->fc, AV_LOG_DEBUG, \"dir %s\\n\", dref->dir);\n                } else\n                    avio_skip(pb, len);\n            }\n        } else {\n            av_log(c->fc, AV_LOG_DEBUG, \"Unknown dref type 0x%08\"PRIx32\" size %\"PRIu32\"\\n\",\n                   dref->type, size);\n            entries--;\n            i--;\n        }\n        avio_seek(pb, next, SEEK_SET);\n    }\n    return 0;\n}\n\nstatic int mov_read_hdlr(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    uint32_t type;\n    uint32_t ctype;\n    int64_t title_size;\n    char *title_str;\n    int ret;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    /* component type */\n    ctype = avio_rl32(pb);\n    type = avio_rl32(pb); /* component subtype */\n\n    av_log(c->fc, AV_LOG_TRACE, \"ctype=%s\\n\", av_fourcc2str(ctype));\n    av_log(c->fc, AV_LOG_TRACE, \"stype=%s\\n\", av_fourcc2str(type));\n\n    if (c->trak_index < 0) {  // meta not inside a trak\n        if (type == MKTAG('m','d','t','a')) {\n            c->found_hdlr_mdta = 1;\n        }\n        return 0;\n    }\n\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if     (type == MKTAG('v','i','d','e'))\n        st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n    else if (type == MKTAG('s','o','u','n'))\n        st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n    else if (type == MKTAG('m','1','a',' '))\n        st->codecpar->codec_id = AV_CODEC_ID_MP2;\n    else if ((type == MKTAG('s','u','b','p')) || (type == MKTAG('c','l','c','p')))\n        st->codecpar->codec_type = AVMEDIA_TYPE_SUBTITLE;\n\n    avio_rb32(pb); /* component  manufacture */\n    avio_rb32(pb); /* component flags */\n    avio_rb32(pb); /* component flags mask */\n\n    title_size = atom.size - 24;\n    if (title_size > 0) {\n        if (title_size > FFMIN(INT_MAX, SIZE_MAX-1))\n            return AVERROR_INVALIDDATA;\n        title_str = av_malloc(title_size + 1); /* Add null terminator */\n        if (!title_str)\n            return AVERROR(ENOMEM);\n\n        ret = ffio_read_size(pb, title_str, title_size);\n        if (ret < 0) {\n            av_freep(&title_str);\n            return ret;\n        }\n        title_str[title_size] = 0;\n        if (title_str[0]) {\n            int off = (!c->isom && title_str[0] == title_size - 1);\n            av_dict_set(&st->metadata, \"handler_name\", title_str + off, 0);\n        }\n        av_freep(&title_str);\n    }\n\n    return 0;\n}\n\nint ff_mov_read_esds(AVFormatContext *fc, AVIOContext *pb)\n{\n    AVStream *st;\n    int tag;\n\n    if (fc->nb_streams < 1)\n        return 0;\n    st = fc->streams[fc->nb_streams-1];\n\n    avio_rb32(pb); /* version + flags */\n    ff_mp4_read_descr(fc, pb, &tag);\n    if (tag == MP4ESDescrTag) {\n        ff_mp4_parse_es_descr(pb, NULL);\n    } else\n        avio_rb16(pb); /* ID */\n\n    ff_mp4_read_descr(fc, pb, &tag);\n    if (tag == MP4DecConfigDescrTag)\n        ff_mp4_read_dec_config_descr(fc, st, pb);\n    return 0;\n}\n\nstatic int mov_read_esds(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    return ff_mov_read_esds(c->fc, pb);\n}\n\nstatic int mov_read_dac3(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    enum AVAudioServiceType *ast;\n    int ac3info, acmod, lfeon, bsmod;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    ast = (enum AVAudioServiceType*)av_stream_new_side_data(st, AV_PKT_DATA_AUDIO_SERVICE_TYPE,\n                                                            sizeof(*ast));\n    if (!ast)\n        return AVERROR(ENOMEM);\n\n    ac3info = avio_rb24(pb);\n    bsmod = (ac3info >> 14) & 0x7;\n    acmod = (ac3info >> 11) & 0x7;\n    lfeon = (ac3info >> 10) & 0x1;\n    st->codecpar->channels = ((int[]){2,1,2,3,3,4,4,5})[acmod] + lfeon;\n    st->codecpar->channel_layout = avpriv_ac3_channel_layout_tab[acmod];\n    if (lfeon)\n        st->codecpar->channel_layout |= AV_CH_LOW_FREQUENCY;\n    *ast = bsmod;\n    if (st->codecpar->channels > 1 && bsmod == 0x7)\n        *ast = AV_AUDIO_SERVICE_TYPE_KARAOKE;\n\n#if FF_API_LAVF_AVCTX\n    FF_DISABLE_DEPRECATION_WARNINGS\n    st->codec->audio_service_type = *ast;\n    FF_ENABLE_DEPRECATION_WARNINGS\n#endif\n\n    return 0;\n}\n\nstatic int mov_read_dec3(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    enum AVAudioServiceType *ast;\n    int eac3info, acmod, lfeon, bsmod;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    ast = (enum AVAudioServiceType*)av_stream_new_side_data(st, AV_PKT_DATA_AUDIO_SERVICE_TYPE,\n                                                            sizeof(*ast));\n    if (!ast)\n        return AVERROR(ENOMEM);\n\n    /* No need to parse fields for additional independent substreams and its\n     * associated dependent substreams since libavcodec's E-AC-3 decoder\n     * does not support them yet. */\n    avio_rb16(pb); /* data_rate and num_ind_sub */\n    eac3info = avio_rb24(pb);\n    bsmod = (eac3info >> 12) & 0x1f;\n    acmod = (eac3info >>  9) & 0x7;\n    lfeon = (eac3info >>  8) & 0x1;\n    st->codecpar->channel_layout = avpriv_ac3_channel_layout_tab[acmod];\n    if (lfeon)\n        st->codecpar->channel_layout |= AV_CH_LOW_FREQUENCY;\n    st->codecpar->channels = av_get_channel_layout_nb_channels(st->codecpar->channel_layout);\n    *ast = bsmod;\n    if (st->codecpar->channels > 1 && bsmod == 0x7)\n        *ast = AV_AUDIO_SERVICE_TYPE_KARAOKE;\n\n#if FF_API_LAVF_AVCTX\n    FF_DISABLE_DEPRECATION_WARNINGS\n    st->codec->audio_service_type = *ast;\n    FF_ENABLE_DEPRECATION_WARNINGS\n#endif\n\n    return 0;\n}\n\nstatic int mov_read_ddts(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    const uint32_t ddts_size = 20;\n    AVStream *st = NULL;\n    uint8_t *buf = NULL;\n    uint32_t frame_duration_code = 0;\n    uint32_t channel_layout_code = 0;\n    GetBitContext gb;\n\n    buf = av_malloc(ddts_size + AV_INPUT_BUFFER_PADDING_SIZE);\n    if (!buf) {\n        return AVERROR(ENOMEM);\n    }\n    if (avio_read(pb, buf, ddts_size) < ddts_size) {\n        av_free(buf);\n        return AVERROR_INVALIDDATA;\n    }\n\n    init_get_bits(&gb, buf, 8*ddts_size);\n\n    if (c->fc->nb_streams < 1) {\n        av_free(buf);\n        return 0;\n    }\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    st->codecpar->sample_rate = get_bits_long(&gb, 32);\n    if (st->codecpar->sample_rate <= 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"Invalid sample rate %d\\n\", st->codecpar->sample_rate);\n        av_free(buf);\n        return AVERROR_INVALIDDATA;\n    }\n    skip_bits_long(&gb, 32); /* max bitrate */\n    st->codecpar->bit_rate = get_bits_long(&gb, 32);\n    st->codecpar->bits_per_coded_sample = get_bits(&gb, 8);\n    frame_duration_code = get_bits(&gb, 2);\n    skip_bits(&gb, 30); /* various fields */\n    channel_layout_code = get_bits(&gb, 16);\n\n    st->codecpar->frame_size =\n            (frame_duration_code == 0) ? 512 :\n            (frame_duration_code == 1) ? 1024 :\n            (frame_duration_code == 2) ? 2048 :\n            (frame_duration_code == 3) ? 4096 : 0;\n\n    if (channel_layout_code > 0xff) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unsupported DTS audio channel layout\");\n    }\n    st->codecpar->channel_layout =\n            ((channel_layout_code & 0x1) ? AV_CH_FRONT_CENTER : 0) |\n            ((channel_layout_code & 0x2) ? AV_CH_FRONT_LEFT : 0) |\n            ((channel_layout_code & 0x2) ? AV_CH_FRONT_RIGHT : 0) |\n            ((channel_layout_code & 0x4) ? AV_CH_SIDE_LEFT : 0) |\n            ((channel_layout_code & 0x4) ? AV_CH_SIDE_RIGHT : 0) |\n            ((channel_layout_code & 0x8) ? AV_CH_LOW_FREQUENCY : 0);\n\n    st->codecpar->channels = av_get_channel_layout_nb_channels(st->codecpar->channel_layout);\n    av_free(buf);\n\n    return 0;\n}\n\nstatic int mov_read_chan(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if (atom.size < 16)\n        return 0;\n\n    /* skip version and flags */\n    avio_skip(pb, 4);\n\n    ff_mov_read_chan(c->fc, pb, st, atom.size - 4);\n\n    return 0;\n}\n\nstatic int mov_read_wfex(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int ret;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if ((ret = ff_get_wav_header(c->fc, pb, st->codecpar, atom.size, 0)) < 0)\n        av_log(c->fc, AV_LOG_WARNING, \"get_wav_header failed\\n\");\n\n    return ret;\n}\n\nstatic int mov_read_pasp(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    const int num = avio_rb32(pb);\n    const int den = avio_rb32(pb);\n    AVStream *st;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if ((st->sample_aspect_ratio.den != 1 || st->sample_aspect_ratio.num) && // default\n        (den != st->sample_aspect_ratio.den || num != st->sample_aspect_ratio.num)) {\n        av_log(c->fc, AV_LOG_WARNING,\n               \"sample aspect ratio already set to %d:%d, ignoring 'pasp' atom (%d:%d)\\n\",\n               st->sample_aspect_ratio.num, st->sample_aspect_ratio.den,\n               num, den);\n    } else if (den != 0) {\n        av_reduce(&st->sample_aspect_ratio.num, &st->sample_aspect_ratio.den,\n                  num, den, 32767);\n    }\n    return 0;\n}\n\n/* this atom contains actual media data */\nstatic int mov_read_mdat(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    if (atom.size == 0) /* wrong one (MP4) */\n        return 0;\n    c->found_mdat=1;\n    return 0; /* now go for moov */\n}\n\n#define DRM_BLOB_SIZE 56\n\nstatic int mov_read_adrm(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    uint8_t intermediate_key[20];\n    uint8_t intermediate_iv[20];\n    uint8_t input[64];\n    uint8_t output[64];\n    uint8_t file_checksum[20];\n    uint8_t calculated_checksum[20];\n    struct AVSHA *sha;\n    int i;\n    int ret = 0;\n    uint8_t *activation_bytes = c->activation_bytes;\n    uint8_t *fixed_key = c->audible_fixed_key;\n\n    c->aax_mode = 1;\n\n    sha = av_sha_alloc();\n    if (!sha)\n        return AVERROR(ENOMEM);\n    c->aes_decrypt = av_aes_alloc();\n    if (!c->aes_decrypt) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n\n    /* drm blob processing */\n    avio_read(pb, output, 8); // go to offset 8, absolute position 0x251\n    avio_read(pb, input, DRM_BLOB_SIZE);\n    avio_read(pb, output, 4); // go to offset 4, absolute position 0x28d\n    avio_read(pb, file_checksum, 20);\n\n    av_log(c->fc, AV_LOG_INFO, \"[aax] file checksum == \"); // required by external tools\n    for (i = 0; i < 20; i++)\n        av_log(c->fc, AV_LOG_INFO, \"%02x\", file_checksum[i]);\n    av_log(c->fc, AV_LOG_INFO, \"\\n\");\n\n    /* verify activation data */\n    if (!activation_bytes) {\n        av_log(c->fc, AV_LOG_WARNING, \"[aax] activation_bytes option is missing!\\n\");\n        ret = 0;  /* allow ffprobe to continue working on .aax files */\n        goto fail;\n    }\n    if (c->activation_bytes_size != 4) {\n        av_log(c->fc, AV_LOG_FATAL, \"[aax] activation_bytes value needs to be 4 bytes!\\n\");\n        ret = AVERROR(EINVAL);\n        goto fail;\n    }\n\n    /* verify fixed key */\n    if (c->audible_fixed_key_size != 16) {\n        av_log(c->fc, AV_LOG_FATAL, \"[aax] audible_fixed_key value needs to be 16 bytes!\\n\");\n        ret = AVERROR(EINVAL);\n        goto fail;\n    }\n\n    /* AAX (and AAX+) key derivation */\n    av_sha_init(sha, 160);\n    av_sha_update(sha, fixed_key, 16);\n    av_sha_update(sha, activation_bytes, 4);\n    av_sha_final(sha, intermediate_key);\n    av_sha_init(sha, 160);\n    av_sha_update(sha, fixed_key, 16);\n    av_sha_update(sha, intermediate_key, 20);\n    av_sha_update(sha, activation_bytes, 4);\n    av_sha_final(sha, intermediate_iv);\n    av_sha_init(sha, 160);\n    av_sha_update(sha, intermediate_key, 16);\n    av_sha_update(sha, intermediate_iv, 16);\n    av_sha_final(sha, calculated_checksum);\n    if (memcmp(calculated_checksum, file_checksum, 20)) { // critical error\n        av_log(c->fc, AV_LOG_ERROR, \"[aax] mismatch in checksums!\\n\");\n        ret = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n    av_aes_init(c->aes_decrypt, intermediate_key, 128, 1);\n    av_aes_crypt(c->aes_decrypt, output, input, DRM_BLOB_SIZE >> 4, intermediate_iv, 1);\n    for (i = 0; i < 4; i++) {\n        // file data (in output) is stored in big-endian mode\n        if (activation_bytes[i] != output[3 - i]) { // critical error\n            av_log(c->fc, AV_LOG_ERROR, \"[aax] error in drm blob decryption!\\n\");\n            ret = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n    }\n    memcpy(c->file_key, output + 8, 16);\n    memcpy(input, output + 26, 16);\n    av_sha_init(sha, 160);\n    av_sha_update(sha, input, 16);\n    av_sha_update(sha, c->file_key, 16);\n    av_sha_update(sha, fixed_key, 16);\n    av_sha_final(sha, c->file_iv);\n\nfail:\n    av_free(sha);\n\n    return ret;\n}\n\n// Audible AAX (and AAX+) bytestream decryption\nstatic int aax_filter(uint8_t *input, int size, MOVContext *c)\n{\n    int blocks = 0;\n    unsigned char iv[16];\n\n    memcpy(iv, c->file_iv, 16); // iv is overwritten\n    blocks = size >> 4; // trailing bytes are not encrypted!\n    av_aes_init(c->aes_decrypt, c->file_key, 128, 1);\n    av_aes_crypt(c->aes_decrypt, input, input, blocks, iv, 1);\n\n    return 0;\n}\n\n/* read major brand, minor version and compatible brands and store them as metadata */\nstatic int mov_read_ftyp(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    uint32_t minor_ver;\n    int comp_brand_size;\n    char* comp_brands_str;\n    uint8_t type[5] = {0};\n    int ret = ffio_read_size(pb, type, 4);\n    if (ret < 0)\n        return ret;\n\n    if (strcmp(type, \"qt  \"))\n        c->isom = 1;\n    av_log(c->fc, AV_LOG_DEBUG, \"ISO: File Type Major Brand: %.4s\\n\",(char *)&type);\n    av_dict_set(&c->fc->metadata, \"major_brand\", type, 0);\n    minor_ver = avio_rb32(pb); /* minor version */\n    av_dict_set_int(&c->fc->metadata, \"minor_version\", minor_ver, 0);\n\n    comp_brand_size = atom.size - 8;\n    if (comp_brand_size < 0)\n        return AVERROR_INVALIDDATA;\n    comp_brands_str = av_malloc(comp_brand_size + 1); /* Add null terminator */\n    if (!comp_brands_str)\n        return AVERROR(ENOMEM);\n\n    ret = ffio_read_size(pb, comp_brands_str, comp_brand_size);\n    if (ret < 0) {\n        av_freep(&comp_brands_str);\n        return ret;\n    }\n    comp_brands_str[comp_brand_size] = 0;\n    av_dict_set(&c->fc->metadata, \"compatible_brands\", comp_brands_str, 0);\n    av_freep(&comp_brands_str);\n\n    return 0;\n}\n\n/* this atom should contain all header atoms */\nstatic int mov_read_moov(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int ret;\n\n    if (c->found_moov) {\n        av_log(c->fc, AV_LOG_WARNING, \"Found duplicated MOOV Atom. Skipped it\\n\");\n        avio_skip(pb, atom.size);\n        return 0;\n    }\n\n    if ((ret = mov_read_default(c, pb, atom)) < 0)\n        return ret;\n    /* we parsed the 'moov' atom, we can terminate the parsing as soon as we find the 'mdat' */\n    /* so we don't parse the whole file if over a network */\n    c->found_moov=1;\n    return 0; /* now go for mdat */\n}\n\nstatic int mov_read_moof(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    if (!c->has_looked_for_mfra && c->use_mfra_for > 0) {\n        c->has_looked_for_mfra = 1;\n        if (pb->seekable & AVIO_SEEKABLE_NORMAL) {\n            int ret;\n            av_log(c->fc, AV_LOG_VERBOSE, \"stream has moof boxes, will look \"\n                    \"for a mfra\\n\");\n            if ((ret = mov_read_mfra(c, pb)) < 0) {\n                av_log(c->fc, AV_LOG_VERBOSE, \"found a moof box but failed to \"\n                        \"read the mfra (may be a live ismv)\\n\");\n            }\n        } else {\n            av_log(c->fc, AV_LOG_VERBOSE, \"found a moof box but stream is not \"\n                    \"seekable, can not look for mfra\\n\");\n        }\n    }\n    c->fragment.moof_offset = c->fragment.implicit_offset = avio_tell(pb) - 8;\n    av_log(c->fc, AV_LOG_TRACE, \"moof offset %\"PRIx64\"\\n\", c->fragment.moof_offset);\n    return mov_read_default(c, pb, atom);\n}\n\nstatic void mov_metadata_creation_time(AVDictionary **metadata, int64_t time)\n{\n    if (time) {\n        if(time >= 2082844800)\n            time -= 2082844800;  /* seconds between 1904-01-01 and Epoch */\n\n        if ((int64_t)(time * 1000000ULL) / 1000000 != time) {\n            av_log(NULL, AV_LOG_DEBUG, \"creation_time is not representable\\n\");\n            return;\n        }\n\n        avpriv_dict_set_timestamp(metadata, \"creation_time\", time * 1000000);\n    }\n}\n\nstatic int mov_read_mdhd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int version;\n    char language[4] = {0};\n    unsigned lang;\n    int64_t creation_time;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    if (sc->time_scale) {\n        av_log(c->fc, AV_LOG_ERROR, \"Multiple mdhd?\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    version = avio_r8(pb);\n    if (version > 1) {\n        avpriv_request_sample(c->fc, \"Version %d\", version);\n        return AVERROR_PATCHWELCOME;\n    }\n    avio_rb24(pb); /* flags */\n    if (version == 1) {\n        creation_time = avio_rb64(pb);\n        avio_rb64(pb);\n    } else {\n        creation_time = avio_rb32(pb);\n        avio_rb32(pb); /* modification time */\n    }\n    mov_metadata_creation_time(&st->metadata, creation_time);\n\n    sc->time_scale = avio_rb32(pb);\n    if (sc->time_scale <= 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"Invalid mdhd time scale %d, defaulting to 1\\n\", sc->time_scale);\n        sc->time_scale = 1;\n    }\n    st->duration = (version == 1) ? avio_rb64(pb) : avio_rb32(pb); /* duration */\n\n    lang = avio_rb16(pb); /* language */\n    if (ff_mov_lang_to_iso639(lang, language))\n        av_dict_set(&st->metadata, \"language\", language, 0);\n    avio_rb16(pb); /* quality */\n\n    return 0;\n}\n\nstatic int mov_read_mvhd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int i;\n    int64_t creation_time;\n    int version = avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    if (version == 1) {\n        creation_time = avio_rb64(pb);\n        avio_rb64(pb);\n    } else {\n        creation_time = avio_rb32(pb);\n        avio_rb32(pb); /* modification time */\n    }\n    mov_metadata_creation_time(&c->fc->metadata, creation_time);\n    c->time_scale = avio_rb32(pb); /* time scale */\n    if (c->time_scale <= 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"Invalid mvhd time scale %d, defaulting to 1\\n\", c->time_scale);\n        c->time_scale = 1;\n    }\n    av_log(c->fc, AV_LOG_TRACE, \"time scale = %i\\n\", c->time_scale);\n\n    c->duration = (version == 1) ? avio_rb64(pb) : avio_rb32(pb); /* duration */\n    // set the AVCodecContext duration because the duration of individual tracks\n    // may be inaccurate\n    if (c->time_scale > 0 && !c->trex_data)\n        c->fc->duration = av_rescale(c->duration, AV_TIME_BASE, c->time_scale);\n    avio_rb32(pb); /* preferred scale */\n\n    avio_rb16(pb); /* preferred volume */\n\n    avio_skip(pb, 10); /* reserved */\n\n    /* movie display matrix, store it in main context and use it later on */\n    for (i = 0; i < 3; i++) {\n        c->movie_display_matrix[i][0] = avio_rb32(pb); // 16.16 fixed point\n        c->movie_display_matrix[i][1] = avio_rb32(pb); // 16.16 fixed point\n        c->movie_display_matrix[i][2] = avio_rb32(pb); //  2.30 fixed point\n    }\n\n    avio_rb32(pb); /* preview time */\n    avio_rb32(pb); /* preview duration */\n    avio_rb32(pb); /* poster time */\n    avio_rb32(pb); /* selection time */\n    avio_rb32(pb); /* selection duration */\n    avio_rb32(pb); /* current time */\n    avio_rb32(pb); /* next track ID */\n\n    return 0;\n}\n\nstatic int mov_read_enda(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int little_endian;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    little_endian = avio_rb16(pb) & 0xFF;\n    av_log(c->fc, AV_LOG_TRACE, \"enda %d\\n\", little_endian);\n    if (little_endian == 1) {\n        switch (st->codecpar->codec_id) {\n        case AV_CODEC_ID_PCM_S24BE:\n            st->codecpar->codec_id = AV_CODEC_ID_PCM_S24LE;\n            break;\n        case AV_CODEC_ID_PCM_S32BE:\n            st->codecpar->codec_id = AV_CODEC_ID_PCM_S32LE;\n            break;\n        case AV_CODEC_ID_PCM_F32BE:\n            st->codecpar->codec_id = AV_CODEC_ID_PCM_F32LE;\n            break;\n        case AV_CODEC_ID_PCM_F64BE:\n            st->codecpar->codec_id = AV_CODEC_ID_PCM_F64LE;\n            break;\n        default:\n            break;\n        }\n    }\n    return 0;\n}\n\nstatic int mov_read_colr(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    char color_parameter_type[5] = { 0 };\n    uint16_t color_primaries, color_trc, color_matrix;\n    int ret;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams - 1];\n\n    ret = ffio_read_size(pb, color_parameter_type, 4);\n    if (ret < 0)\n        return ret;\n    if (strncmp(color_parameter_type, \"nclx\", 4) &&\n        strncmp(color_parameter_type, \"nclc\", 4)) {\n        av_log(c->fc, AV_LOG_WARNING, \"unsupported color_parameter_type %s\\n\",\n               color_parameter_type);\n        return 0;\n    }\n\n    color_primaries = avio_rb16(pb);\n    color_trc = avio_rb16(pb);\n    color_matrix = avio_rb16(pb);\n\n    av_log(c->fc, AV_LOG_TRACE,\n           \"%s: pri %d trc %d matrix %d\",\n           color_parameter_type, color_primaries, color_trc, color_matrix);\n\n    if (!strncmp(color_parameter_type, \"nclx\", 4)) {\n        uint8_t color_range = avio_r8(pb) >> 7;\n        av_log(c->fc, AV_LOG_TRACE, \" full %\"PRIu8\"\", color_range);\n        if (color_range)\n            st->codecpar->color_range = AVCOL_RANGE_JPEG;\n        else\n            st->codecpar->color_range = AVCOL_RANGE_MPEG;\n    }\n\n    if (!av_color_primaries_name(color_primaries))\n        color_primaries = AVCOL_PRI_UNSPECIFIED;\n    if (!av_color_transfer_name(color_trc))\n        color_trc = AVCOL_TRC_UNSPECIFIED;\n    if (!av_color_space_name(color_matrix))\n        color_matrix = AVCOL_SPC_UNSPECIFIED;\n\n    st->codecpar->color_primaries = color_primaries;\n    st->codecpar->color_trc       = color_trc;\n    st->codecpar->color_space     = color_matrix;\n    av_log(c->fc, AV_LOG_TRACE, \"\\n\");\n\n    return 0;\n}\n\nstatic int mov_read_fiel(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    unsigned mov_field_order;\n    enum AVFieldOrder decoded_field_order = AV_FIELD_UNKNOWN;\n\n    if (c->fc->nb_streams < 1) // will happen with jp2 files\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    if (atom.size < 2)\n        return AVERROR_INVALIDDATA;\n    mov_field_order = avio_rb16(pb);\n    if ((mov_field_order & 0xFF00) == 0x0100)\n        decoded_field_order = AV_FIELD_PROGRESSIVE;\n    else if ((mov_field_order & 0xFF00) == 0x0200) {\n        switch (mov_field_order & 0xFF) {\n        case 0x01: decoded_field_order = AV_FIELD_TT;\n                   break;\n        case 0x06: decoded_field_order = AV_FIELD_BB;\n                   break;\n        case 0x09: decoded_field_order = AV_FIELD_TB;\n                   break;\n        case 0x0E: decoded_field_order = AV_FIELD_BT;\n                   break;\n        }\n    }\n    if (decoded_field_order == AV_FIELD_UNKNOWN && mov_field_order) {\n        av_log(NULL, AV_LOG_ERROR, \"Unknown MOV field order 0x%04x\\n\", mov_field_order);\n    }\n    st->codecpar->field_order = decoded_field_order;\n\n    return 0;\n}\n\nstatic int mov_realloc_extradata(AVCodecParameters *par, MOVAtom atom)\n{\n    int err = 0;\n    uint64_t size = (uint64_t)par->extradata_size + atom.size + 8 + AV_INPUT_BUFFER_PADDING_SIZE;\n    if (size > INT_MAX || (uint64_t)atom.size > INT_MAX)\n        return AVERROR_INVALIDDATA;\n    if ((err = av_reallocp(&par->extradata, size)) < 0) {\n        par->extradata_size = 0;\n        return err;\n    }\n    par->extradata_size = size - AV_INPUT_BUFFER_PADDING_SIZE;\n    return 0;\n}\n\n/* Read a whole atom into the extradata return the size of the atom read, possibly truncated if != atom.size */\nstatic int64_t mov_read_atom_into_extradata(MOVContext *c, AVIOContext *pb, MOVAtom atom,\n                                        AVCodecParameters *par, uint8_t *buf)\n{\n    int64_t result = atom.size;\n    int err;\n\n    AV_WB32(buf    , atom.size + 8);\n    AV_WL32(buf + 4, atom.type);\n    err = ffio_read_size(pb, buf + 8, atom.size);\n    if (err < 0) {\n        par->extradata_size -= atom.size;\n        return err;\n    } else if (err < atom.size) {\n        av_log(c->fc, AV_LOG_WARNING, \"truncated extradata\\n\");\n        par->extradata_size -= atom.size - err;\n        result = err;\n    }\n    memset(buf + 8 + err, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n    return result;\n}\n\n/* FIXME modify QDM2/SVQ3/H.264 decoders to take full atom as extradata */\nstatic int mov_read_extradata(MOVContext *c, AVIOContext *pb, MOVAtom atom,\n                              enum AVCodecID codec_id)\n{\n    AVStream *st;\n    uint64_t original_size;\n    int err;\n\n    if (c->fc->nb_streams < 1) // will happen with jp2 files\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if (st->codecpar->codec_id != codec_id)\n        return 0; /* unexpected codec_id - don't mess with extradata */\n\n    original_size = st->codecpar->extradata_size;\n    err = mov_realloc_extradata(st->codecpar, atom);\n    if (err)\n        return err;\n\n    err =  mov_read_atom_into_extradata(c, pb, atom, st->codecpar,  st->codecpar->extradata + original_size);\n    if (err < 0)\n        return err;\n    return 0; // Note: this is the original behavior to ignore truncation.\n}\n\n/* wrapper functions for reading ALAC/AVS/MJPEG/MJPEG2000 extradata atoms only for those codecs */\nstatic int mov_read_alac(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    return mov_read_extradata(c, pb, atom, AV_CODEC_ID_ALAC);\n}\n\nstatic int mov_read_avss(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    return mov_read_extradata(c, pb, atom, AV_CODEC_ID_AVS);\n}\n\nstatic int mov_read_jp2h(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    return mov_read_extradata(c, pb, atom, AV_CODEC_ID_JPEG2000);\n}\n\nstatic int mov_read_dpxe(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    return mov_read_extradata(c, pb, atom, AV_CODEC_ID_R10K);\n}\n\nstatic int mov_read_avid(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int ret = mov_read_extradata(c, pb, atom, AV_CODEC_ID_AVUI);\n    if(ret == 0)\n        ret = mov_read_extradata(c, pb, atom, AV_CODEC_ID_DNXHD);\n    return ret;\n}\n\nstatic int mov_read_targa_y216(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int ret = mov_read_extradata(c, pb, atom, AV_CODEC_ID_TARGA_Y216);\n\n    if (!ret && c->fc->nb_streams >= 1) {\n        AVCodecParameters *par = c->fc->streams[c->fc->nb_streams-1]->codecpar;\n        if (par->extradata_size >= 40) {\n            par->height = AV_RB16(&par->extradata[36]);\n            par->width  = AV_RB16(&par->extradata[38]);\n        }\n    }\n    return ret;\n}\n\nstatic int mov_read_ares(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    if (c->fc->nb_streams >= 1) {\n        AVCodecParameters *par = c->fc->streams[c->fc->nb_streams-1]->codecpar;\n        if (par->codec_tag == MKTAG('A', 'V', 'i', 'n') &&\n            par->codec_id == AV_CODEC_ID_H264 &&\n            atom.size > 11) {\n            int cid;\n            avio_skip(pb, 10);\n            cid = avio_rb16(pb);\n            /* For AVID AVCI50, force width of 1440 to be able to select the correct SPS and PPS */\n            if (cid == 0xd4d || cid == 0xd4e)\n                par->width = 1440;\n            return 0;\n        } else if ((par->codec_tag == MKTAG('A', 'V', 'd', '1') ||\n                    par->codec_tag == MKTAG('A', 'V', 'd', 'n')) &&\n                   atom.size >= 24) {\n            int num, den;\n            avio_skip(pb, 12);\n            num = avio_rb32(pb);\n            den = avio_rb32(pb);\n            if (num <= 0 || den <= 0)\n                return 0;\n            switch (avio_rb32(pb)) {\n            case 2:\n                if (den >= INT_MAX / 2)\n                    return 0;\n                den *= 2;\n            case 1:\n                c->fc->streams[c->fc->nb_streams-1]->display_aspect_ratio.num = num;\n                c->fc->streams[c->fc->nb_streams-1]->display_aspect_ratio.den = den;\n            default:\n                return 0;\n            }\n        }\n    }\n\n    return mov_read_avid(c, pb, atom);\n}\n\nstatic int mov_read_aclr(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int ret = 0;\n    int length = 0;\n    uint64_t original_size;\n    if (c->fc->nb_streams >= 1) {\n        AVCodecParameters *par = c->fc->streams[c->fc->nb_streams-1]->codecpar;\n        if (par->codec_id == AV_CODEC_ID_H264)\n            return 0;\n        if (atom.size == 16) {\n            original_size = par->extradata_size;\n            ret = mov_realloc_extradata(par, atom);\n            if (!ret) {\n                length =  mov_read_atom_into_extradata(c, pb, atom, par, par->extradata + original_size);\n                if (length == atom.size) {\n                    const uint8_t range_value = par->extradata[original_size + 19];\n                    switch (range_value) {\n                    case 1:\n                        par->color_range = AVCOL_RANGE_MPEG;\n                        break;\n                    case 2:\n                        par->color_range = AVCOL_RANGE_JPEG;\n                        break;\n                    default:\n                        av_log(c, AV_LOG_WARNING, \"ignored unknown aclr value (%d)\\n\", range_value);\n                        break;\n                    }\n                    ff_dlog(c, \"color_range: %d\\n\", par->color_range);\n                } else {\n                  /* For some reason the whole atom was not added to the extradata */\n                  av_log(c, AV_LOG_ERROR, \"aclr not decoded - incomplete atom\\n\");\n                }\n            } else {\n                av_log(c, AV_LOG_ERROR, \"aclr not decoded - unable to add atom to extradata\\n\");\n            }\n        } else {\n            av_log(c, AV_LOG_WARNING, \"aclr not decoded - unexpected size %\"PRId64\"\\n\", atom.size);\n        }\n    }\n\n    return ret;\n}\n\nstatic int mov_read_svq3(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    return mov_read_extradata(c, pb, atom, AV_CODEC_ID_SVQ3);\n}\n\nstatic int mov_read_wave(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int ret;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if ((uint64_t)atom.size > (1<<30))\n        return AVERROR_INVALIDDATA;\n\n    if (st->codecpar->codec_id == AV_CODEC_ID_QDM2 ||\n        st->codecpar->codec_id == AV_CODEC_ID_QDMC ||\n        st->codecpar->codec_id == AV_CODEC_ID_SPEEX) {\n        // pass all frma atom to codec, needed at least for QDMC and QDM2\n        av_freep(&st->codecpar->extradata);\n        ret = ff_get_extradata(c->fc, st->codecpar, pb, atom.size);\n        if (ret < 0)\n            return ret;\n    } else if (atom.size > 8) { /* to read frma, esds atoms */\n        if (st->codecpar->codec_id == AV_CODEC_ID_ALAC && atom.size >= 24) {\n            uint64_t buffer;\n            ret = ffio_ensure_seekback(pb, 8);\n            if (ret < 0)\n                return ret;\n            buffer = avio_rb64(pb);\n            atom.size -= 8;\n            if (  (buffer & 0xFFFFFFFF) == MKBETAG('f','r','m','a')\n                && buffer >> 32 <= atom.size\n                && buffer >> 32 >= 8) {\n                avio_skip(pb, -8);\n                atom.size += 8;\n            } else if (!st->codecpar->extradata_size) {\n#define ALAC_EXTRADATA_SIZE 36\n                st->codecpar->extradata = av_mallocz(ALAC_EXTRADATA_SIZE + AV_INPUT_BUFFER_PADDING_SIZE);\n                if (!st->codecpar->extradata)\n                    return AVERROR(ENOMEM);\n                st->codecpar->extradata_size = ALAC_EXTRADATA_SIZE;\n                AV_WB32(st->codecpar->extradata    , ALAC_EXTRADATA_SIZE);\n                AV_WB32(st->codecpar->extradata + 4, MKTAG('a','l','a','c'));\n                AV_WB64(st->codecpar->extradata + 12, buffer);\n                avio_read(pb, st->codecpar->extradata + 20, 16);\n                avio_skip(pb, atom.size - 24);\n                return 0;\n            }\n        }\n        if ((ret = mov_read_default(c, pb, atom)) < 0)\n            return ret;\n    } else\n        avio_skip(pb, atom.size);\n    return 0;\n}\n\n/**\n * This function reads atom content and puts data in extradata without tag\n * nor size unlike mov_read_extradata.\n */\nstatic int mov_read_glbl(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int ret;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if ((uint64_t)atom.size > (1<<30))\n        return AVERROR_INVALIDDATA;\n\n    if (atom.size >= 10) {\n        // Broken files created by legacy versions of libavformat will\n        // wrap a whole fiel atom inside of a glbl atom.\n        unsigned size = avio_rb32(pb);\n        unsigned type = avio_rl32(pb);\n        avio_seek(pb, -8, SEEK_CUR);\n        if (type == MKTAG('f','i','e','l') && size == atom.size)\n            return mov_read_default(c, pb, atom);\n    }\n    if (st->codecpar->extradata_size > 1 && st->codecpar->extradata) {\n        av_log(c, AV_LOG_WARNING, \"ignoring multiple glbl\\n\");\n        return 0;\n    }\n    av_freep(&st->codecpar->extradata);\n    ret = ff_get_extradata(c->fc, st->codecpar, pb, atom.size);\n    if (ret < 0)\n        return ret;\n\n    return 0;\n}\n\nstatic int mov_read_dvc1(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    uint8_t profile_level;\n    int ret;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if (atom.size >= (1<<28) || atom.size < 7)\n        return AVERROR_INVALIDDATA;\n\n    profile_level = avio_r8(pb);\n    if ((profile_level & 0xf0) != 0xc0)\n        return 0;\n\n    avio_seek(pb, 6, SEEK_CUR);\n    av_freep(&st->codecpar->extradata);\n    ret = ff_get_extradata(c->fc, st->codecpar, pb, atom.size - 7);\n    if (ret < 0)\n        return ret;\n\n    return 0;\n}\n\n/**\n * An strf atom is a BITMAPINFOHEADER struct. This struct is 40 bytes itself,\n * but can have extradata appended at the end after the 40 bytes belonging\n * to the struct.\n */\nstatic int mov_read_strf(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int ret;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    if (atom.size <= 40)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if ((uint64_t)atom.size > (1<<30))\n        return AVERROR_INVALIDDATA;\n\n    avio_skip(pb, 40);\n    av_freep(&st->codecpar->extradata);\n    ret = ff_get_extradata(c->fc, st->codecpar, pb, atom.size - 40);\n    if (ret < 0)\n        return ret;\n\n    return 0;\n}\n\nstatic int mov_read_stco(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    entries = avio_rb32(pb);\n\n    if (!entries)\n        return 0;\n\n    if (sc->chunk_offsets)\n        av_log(c->fc, AV_LOG_WARNING, \"Duplicated STCO atom\\n\");\n    av_free(sc->chunk_offsets);\n    sc->chunk_count = 0;\n    sc->chunk_offsets = av_malloc_array(entries, sizeof(*sc->chunk_offsets));\n    if (!sc->chunk_offsets)\n        return AVERROR(ENOMEM);\n    sc->chunk_count = entries;\n\n    if      (atom.type == MKTAG('s','t','c','o'))\n        for (i = 0; i < entries && !pb->eof_reached; i++)\n            sc->chunk_offsets[i] = avio_rb32(pb);\n    else if (atom.type == MKTAG('c','o','6','4'))\n        for (i = 0; i < entries && !pb->eof_reached; i++)\n            sc->chunk_offsets[i] = avio_rb64(pb);\n    else\n        return AVERROR_INVALIDDATA;\n\n    sc->chunk_count = i;\n\n    if (pb->eof_reached)\n        return AVERROR_EOF;\n\n    return 0;\n}\n\n/**\n * Compute codec id for 'lpcm' tag.\n * See CoreAudioTypes and AudioStreamBasicDescription at Apple.\n */\nenum AVCodecID ff_mov_get_lpcm_codec_id(int bps, int flags)\n{\n    /* lpcm flags:\n     * 0x1 = float\n     * 0x2 = big-endian\n     * 0x4 = signed\n     */\n    return ff_get_pcm_codec_id(bps, flags & 1, flags & 2, flags & 4 ? -1 : 0);\n}\n\nstatic int mov_codec_id(AVStream *st, uint32_t format)\n{\n    int id = ff_codec_get_id(ff_codec_movaudio_tags, format);\n\n    if (id <= 0 &&\n        ((format & 0xFFFF) == 'm' + ('s' << 8) ||\n         (format & 0xFFFF) == 'T' + ('S' << 8)))\n        id = ff_codec_get_id(ff_codec_wav_tags, av_bswap32(format) & 0xFFFF);\n\n    if (st->codecpar->codec_type != AVMEDIA_TYPE_VIDEO && id > 0) {\n        st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n    } else if (st->codecpar->codec_type != AVMEDIA_TYPE_AUDIO &&\n               /* skip old ASF MPEG-4 tag */\n               format && format != MKTAG('m','p','4','s')) {\n        id = ff_codec_get_id(ff_codec_movvideo_tags, format);\n        if (id <= 0)\n            id = ff_codec_get_id(ff_codec_bmp_tags, format);\n        if (id > 0)\n            st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;\n        else if (st->codecpar->codec_type == AVMEDIA_TYPE_DATA ||\n                    (st->codecpar->codec_type == AVMEDIA_TYPE_SUBTITLE &&\n                    st->codecpar->codec_id == AV_CODEC_ID_NONE)) {\n            id = ff_codec_get_id(ff_codec_movsubtitle_tags, format);\n            if (id > 0)\n                st->codecpar->codec_type = AVMEDIA_TYPE_SUBTITLE;\n        }\n    }\n\n    st->codecpar->codec_tag = format;\n\n    return id;\n}\n\nstatic void mov_parse_stsd_video(MOVContext *c, AVIOContext *pb,\n                                 AVStream *st, MOVStreamContext *sc)\n{\n    uint8_t codec_name[32] = { 0 };\n    int64_t stsd_start;\n    unsigned int len;\n\n    /* The first 16 bytes of the video sample description are already\n     * read in ff_mov_read_stsd_entries() */\n    stsd_start = avio_tell(pb) - 16;\n\n    avio_rb16(pb); /* version */\n    avio_rb16(pb); /* revision level */\n    avio_rb32(pb); /* vendor */\n    avio_rb32(pb); /* temporal quality */\n    avio_rb32(pb); /* spatial quality */\n\n    st->codecpar->width  = avio_rb16(pb); /* width */\n    st->codecpar->height = avio_rb16(pb); /* height */\n\n    avio_rb32(pb); /* horiz resolution */\n    avio_rb32(pb); /* vert resolution */\n    avio_rb32(pb); /* data size, always 0 */\n    avio_rb16(pb); /* frames per samples */\n\n    len = avio_r8(pb); /* codec name, pascal string */\n    if (len > 31)\n        len = 31;\n    mov_read_mac_string(c, pb, len, codec_name, sizeof(codec_name));\n    if (len < 31)\n        avio_skip(pb, 31 - len);\n\n    if (codec_name[0])\n        av_dict_set(&st->metadata, \"encoder\", codec_name, 0);\n\n    /* codec_tag YV12 triggers an UV swap in rawdec.c */\n    if (!memcmp(codec_name, \"Planar Y'CbCr 8-bit 4:2:0\", 25)) {\n        st->codecpar->codec_tag = MKTAG('I', '4', '2', '0');\n        st->codecpar->width &= ~1;\n        st->codecpar->height &= ~1;\n    }\n    /* Flash Media Server uses tag H.263 with Sorenson Spark */\n    if (st->codecpar->codec_tag == MKTAG('H','2','6','3') &&\n        !memcmp(codec_name, \"Sorenson H263\", 13))\n        st->codecpar->codec_id = AV_CODEC_ID_FLV1;\n\n    st->codecpar->bits_per_coded_sample = avio_rb16(pb); /* depth */\n\n    avio_seek(pb, stsd_start, SEEK_SET);\n\n    if (ff_get_qtpalette(st->codecpar->codec_id, pb, sc->palette)) {\n        st->codecpar->bits_per_coded_sample &= 0x1F;\n        sc->has_palette = 1;\n    }\n}\n\nstatic void mov_parse_stsd_audio(MOVContext *c, AVIOContext *pb,\n                                 AVStream *st, MOVStreamContext *sc)\n{\n    int bits_per_sample, flags;\n    uint16_t version = avio_rb16(pb);\n    AVDictionaryEntry *compatible_brands = av_dict_get(c->fc->metadata, \"compatible_brands\", NULL, AV_DICT_MATCH_CASE);\n\n    avio_rb16(pb); /* revision level */\n    avio_rb32(pb); /* vendor */\n\n    st->codecpar->channels              = avio_rb16(pb); /* channel count */\n    st->codecpar->bits_per_coded_sample = avio_rb16(pb); /* sample size */\n    av_log(c->fc, AV_LOG_TRACE, \"audio channels %d\\n\", st->codecpar->channels);\n\n    sc->audio_cid = avio_rb16(pb);\n    avio_rb16(pb); /* packet size = 0 */\n\n    st->codecpar->sample_rate = ((avio_rb32(pb) >> 16));\n\n    // Read QT version 1 fields. In version 0 these do not exist.\n    av_log(c->fc, AV_LOG_TRACE, \"version =%d, isom =%d\\n\", version, c->isom);\n    if (!c->isom ||\n        (compatible_brands && strstr(compatible_brands->value, \"qt  \"))) {\n\n        if (version == 1) {\n            sc->samples_per_frame = avio_rb32(pb);\n            avio_rb32(pb); /* bytes per packet */\n            sc->bytes_per_frame = avio_rb32(pb);\n            avio_rb32(pb); /* bytes per sample */\n        } else if (version == 2) {\n            avio_rb32(pb); /* sizeof struct only */\n            st->codecpar->sample_rate = av_int2double(avio_rb64(pb));\n            st->codecpar->channels    = avio_rb32(pb);\n            avio_rb32(pb); /* always 0x7F000000 */\n            st->codecpar->bits_per_coded_sample = avio_rb32(pb);\n\n            flags = avio_rb32(pb); /* lpcm format specific flag */\n            sc->bytes_per_frame   = avio_rb32(pb);\n            sc->samples_per_frame = avio_rb32(pb);\n            if (st->codecpar->codec_tag == MKTAG('l','p','c','m'))\n                st->codecpar->codec_id =\n                    ff_mov_get_lpcm_codec_id(st->codecpar->bits_per_coded_sample,\n                                             flags);\n        }\n        if (version == 0 || (version == 1 && sc->audio_cid != -2)) {\n            /* can't correctly handle variable sized packet as audio unit */\n            switch (st->codecpar->codec_id) {\n            case AV_CODEC_ID_MP2:\n            case AV_CODEC_ID_MP3:\n                st->need_parsing = AVSTREAM_PARSE_FULL;\n                break;\n            }\n        }\n    }\n\n    if (sc->format == 0) {\n        if (st->codecpar->bits_per_coded_sample == 8)\n            st->codecpar->codec_id = mov_codec_id(st, MKTAG('r','a','w',' '));\n        else if (st->codecpar->bits_per_coded_sample == 16)\n            st->codecpar->codec_id = mov_codec_id(st, MKTAG('t','w','o','s'));\n    }\n\n    switch (st->codecpar->codec_id) {\n    case AV_CODEC_ID_PCM_S8:\n    case AV_CODEC_ID_PCM_U8:\n        if (st->codecpar->bits_per_coded_sample == 16)\n            st->codecpar->codec_id = AV_CODEC_ID_PCM_S16BE;\n        break;\n    case AV_CODEC_ID_PCM_S16LE:\n    case AV_CODEC_ID_PCM_S16BE:\n        if (st->codecpar->bits_per_coded_sample == 8)\n            st->codecpar->codec_id = AV_CODEC_ID_PCM_S8;\n        else if (st->codecpar->bits_per_coded_sample == 24)\n            st->codecpar->codec_id =\n                st->codecpar->codec_id == AV_CODEC_ID_PCM_S16BE ?\n                AV_CODEC_ID_PCM_S24BE : AV_CODEC_ID_PCM_S24LE;\n        else if (st->codecpar->bits_per_coded_sample == 32)\n             st->codecpar->codec_id =\n                st->codecpar->codec_id == AV_CODEC_ID_PCM_S16BE ?\n                AV_CODEC_ID_PCM_S32BE : AV_CODEC_ID_PCM_S32LE;\n        break;\n    /* set values for old format before stsd version 1 appeared */\n    case AV_CODEC_ID_MACE3:\n        sc->samples_per_frame = 6;\n        sc->bytes_per_frame   = 2 * st->codecpar->channels;\n        break;\n    case AV_CODEC_ID_MACE6:\n        sc->samples_per_frame = 6;\n        sc->bytes_per_frame   = 1 * st->codecpar->channels;\n        break;\n    case AV_CODEC_ID_ADPCM_IMA_QT:\n        sc->samples_per_frame = 64;\n        sc->bytes_per_frame   = 34 * st->codecpar->channels;\n        break;\n    case AV_CODEC_ID_GSM:\n        sc->samples_per_frame = 160;\n        sc->bytes_per_frame   = 33;\n        break;\n    default:\n        break;\n    }\n\n    bits_per_sample = av_get_bits_per_sample(st->codecpar->codec_id);\n    if (bits_per_sample) {\n        st->codecpar->bits_per_coded_sample = bits_per_sample;\n        sc->sample_size = (bits_per_sample >> 3) * st->codecpar->channels;\n    }\n}\n\nstatic void mov_parse_stsd_subtitle(MOVContext *c, AVIOContext *pb,\n                                    AVStream *st, MOVStreamContext *sc,\n                                    int64_t size)\n{\n    // ttxt stsd contains display flags, justification, background\n    // color, fonts, and default styles, so fake an atom to read it\n    MOVAtom fake_atom = { .size = size };\n    // mp4s contains a regular esds atom\n    if (st->codecpar->codec_tag != AV_RL32(\"mp4s\"))\n        mov_read_glbl(c, pb, fake_atom);\n    st->codecpar->width  = sc->width;\n    st->codecpar->height = sc->height;\n}\n\nstatic uint32_t yuv_to_rgba(uint32_t ycbcr)\n{\n    uint8_t r, g, b;\n    int y, cb, cr;\n\n    y  = (ycbcr >> 16) & 0xFF;\n    cr = (ycbcr >> 8)  & 0xFF;\n    cb =  ycbcr        & 0xFF;\n\n    b = av_clip_uint8((1164 * (y - 16)                     + 2018 * (cb - 128)) / 1000);\n    g = av_clip_uint8((1164 * (y - 16) -  813 * (cr - 128) -  391 * (cb - 128)) / 1000);\n    r = av_clip_uint8((1164 * (y - 16) + 1596 * (cr - 128)                    ) / 1000);\n\n    return (r << 16) | (g << 8) | b;\n}\n\nstatic int mov_rewrite_dvd_sub_extradata(AVStream *st)\n{\n    char buf[256] = {0};\n    uint8_t *src = st->codecpar->extradata;\n    int i;\n\n    if (st->codecpar->extradata_size != 64)\n        return 0;\n\n    if (st->codecpar->width > 0 &&  st->codecpar->height > 0)\n        snprintf(buf, sizeof(buf), \"size: %dx%d\\n\",\n                 st->codecpar->width, st->codecpar->height);\n    av_strlcat(buf, \"palette: \", sizeof(buf));\n\n    for (i = 0; i < 16; i++) {\n        uint32_t yuv = AV_RB32(src + i * 4);\n        uint32_t rgba = yuv_to_rgba(yuv);\n\n        av_strlcatf(buf, sizeof(buf), \"%06\"PRIx32\"%s\", rgba, i != 15 ? \", \" : \"\");\n    }\n\n    if (av_strlcat(buf, \"\\n\", sizeof(buf)) >= sizeof(buf))\n        return 0;\n\n    av_freep(&st->codecpar->extradata);\n    st->codecpar->extradata_size = 0;\n    st->codecpar->extradata = av_mallocz(strlen(buf) + AV_INPUT_BUFFER_PADDING_SIZE);\n    if (!st->codecpar->extradata)\n        return AVERROR(ENOMEM);\n    st->codecpar->extradata_size = strlen(buf);\n    memcpy(st->codecpar->extradata, buf, st->codecpar->extradata_size);\n\n    return 0;\n}\n\nstatic int mov_parse_stsd_data(MOVContext *c, AVIOContext *pb,\n                                AVStream *st, MOVStreamContext *sc,\n                                int64_t size)\n{\n    int ret;\n\n    if (st->codecpar->codec_tag == MKTAG('t','m','c','d')) {\n        if ((int)size != size)\n            return AVERROR(ENOMEM);\n\n        ret = ff_get_extradata(c->fc, st->codecpar, pb, size);\n        if (ret < 0)\n            return ret;\n        if (size > 16) {\n            MOVStreamContext *tmcd_ctx = st->priv_data;\n            int val;\n            val = AV_RB32(st->codecpar->extradata + 4);\n            tmcd_ctx->tmcd_flags = val;\n            st->avg_frame_rate.num = st->codecpar->extradata[16]; /* number of frame */\n            st->avg_frame_rate.den = 1;\n#if FF_API_LAVF_AVCTX\nFF_DISABLE_DEPRECATION_WARNINGS\n            st->codec->time_base = av_inv_q(st->avg_frame_rate);\nFF_ENABLE_DEPRECATION_WARNINGS\n#endif\n            /* adjust for per frame dur in counter mode */\n            if (tmcd_ctx->tmcd_flags & 0x0008) {\n                int timescale = AV_RB32(st->codecpar->extradata + 8);\n                int framedur = AV_RB32(st->codecpar->extradata + 12);\n                st->avg_frame_rate.num *= timescale;\n                st->avg_frame_rate.den *= framedur;\n#if FF_API_LAVF_AVCTX\nFF_DISABLE_DEPRECATION_WARNINGS\n                st->codec->time_base.den *= timescale;\n                st->codec->time_base.num *= framedur;\nFF_ENABLE_DEPRECATION_WARNINGS\n#endif\n            }\n            if (size > 30) {\n                uint32_t len = AV_RB32(st->codecpar->extradata + 18); /* name atom length */\n                uint32_t format = AV_RB32(st->codecpar->extradata + 22);\n                if (format == AV_RB32(\"name\") && (int64_t)size >= (int64_t)len + 18) {\n                    uint16_t str_size = AV_RB16(st->codecpar->extradata + 26); /* string length */\n                    if (str_size > 0 && size >= (int)str_size + 26) {\n                        char *reel_name = av_malloc(str_size + 1);\n                        if (!reel_name)\n                            return AVERROR(ENOMEM);\n                        memcpy(reel_name, st->codecpar->extradata + 30, str_size);\n                        reel_name[str_size] = 0; /* Add null terminator */\n                        /* don't add reel_name if emtpy string */\n                        if (*reel_name == 0) {\n                            av_free(reel_name);\n                        } else {\n                            av_dict_set(&st->metadata, \"reel_name\", reel_name,  AV_DICT_DONT_STRDUP_VAL);\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        /* other codec type, just skip (rtp, mp4s ...) */\n        avio_skip(pb, size);\n    }\n    return 0;\n}\n\nstatic int mov_finalize_stsd_codec(MOVContext *c, AVIOContext *pb,\n                                   AVStream *st, MOVStreamContext *sc)\n{\n    if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO &&\n        !st->codecpar->sample_rate && sc->time_scale > 1)\n        st->codecpar->sample_rate = sc->time_scale;\n\n    /* special codec parameters handling */\n    switch (st->codecpar->codec_id) {\n#if CONFIG_DV_DEMUXER\n    case AV_CODEC_ID_DVAUDIO:\n        c->dv_fctx = avformat_alloc_context();\n        if (!c->dv_fctx) {\n            av_log(c->fc, AV_LOG_ERROR, \"dv demux context alloc error\\n\");\n            return AVERROR(ENOMEM);\n        }\n        c->dv_demux = avpriv_dv_init_demux(c->dv_fctx);\n        if (!c->dv_demux) {\n            av_log(c->fc, AV_LOG_ERROR, \"dv demux context init error\\n\");\n            return AVERROR(ENOMEM);\n        }\n        sc->dv_audio_container = 1;\n        st->codecpar->codec_id    = AV_CODEC_ID_PCM_S16LE;\n        break;\n#endif\n    /* no ifdef since parameters are always those */\n    case AV_CODEC_ID_QCELP:\n        st->codecpar->channels = 1;\n        // force sample rate for qcelp when not stored in mov\n        if (st->codecpar->codec_tag != MKTAG('Q','c','l','p'))\n            st->codecpar->sample_rate = 8000;\n        // FIXME: Why is the following needed for some files?\n        sc->samples_per_frame = 160;\n        if (!sc->bytes_per_frame)\n            sc->bytes_per_frame = 35;\n        break;\n    case AV_CODEC_ID_AMR_NB:\n        st->codecpar->channels    = 1;\n        /* force sample rate for amr, stsd in 3gp does not store sample rate */\n        st->codecpar->sample_rate = 8000;\n        break;\n    case AV_CODEC_ID_AMR_WB:\n        st->codecpar->channels    = 1;\n        st->codecpar->sample_rate = 16000;\n        break;\n    case AV_CODEC_ID_MP2:\n    case AV_CODEC_ID_MP3:\n        /* force type after stsd for m1a hdlr */\n        st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n        break;\n    case AV_CODEC_ID_GSM:\n    case AV_CODEC_ID_ADPCM_MS:\n    case AV_CODEC_ID_ADPCM_IMA_WAV:\n    case AV_CODEC_ID_ILBC:\n    case AV_CODEC_ID_MACE3:\n    case AV_CODEC_ID_MACE6:\n    case AV_CODEC_ID_QDM2:\n        st->codecpar->block_align = sc->bytes_per_frame;\n        break;\n    case AV_CODEC_ID_ALAC:\n        if (st->codecpar->extradata_size == 36) {\n            st->codecpar->channels    = AV_RB8 (st->codecpar->extradata + 21);\n            st->codecpar->sample_rate = AV_RB32(st->codecpar->extradata + 32);\n        }\n        break;\n    case AV_CODEC_ID_AC3:\n    case AV_CODEC_ID_EAC3:\n    case AV_CODEC_ID_MPEG1VIDEO:\n    case AV_CODEC_ID_VC1:\n    case AV_CODEC_ID_VP9:\n        st->need_parsing = AVSTREAM_PARSE_FULL;\n        break;\n    default:\n        break;\n    }\n    return 0;\n}\n\nstatic int mov_skip_multiple_stsd(MOVContext *c, AVIOContext *pb,\n                                  int codec_tag, int format,\n                                  int64_t size)\n{\n    int video_codec_id = ff_codec_get_id(ff_codec_movvideo_tags, format);\n\n    if (codec_tag &&\n         (codec_tag != format &&\n          // AVID 1:1 samples with differing data format and codec tag exist\n          (codec_tag != AV_RL32(\"AV1x\") || format != AV_RL32(\"AVup\")) &&\n          // prores is allowed to have differing data format and codec tag\n          codec_tag != AV_RL32(\"apcn\") && codec_tag != AV_RL32(\"apch\") &&\n          // so is dv (sigh)\n          codec_tag != AV_RL32(\"dvpp\") && codec_tag != AV_RL32(\"dvcp\") &&\n          (c->fc->video_codec_id ? video_codec_id != c->fc->video_codec_id\n                                 : codec_tag != MKTAG('j','p','e','g')))) {\n        /* Multiple fourcc, we skip JPEG. This is not correct, we should\n         * export it as a separate AVStream but this needs a few changes\n         * in the MOV demuxer, patch welcome. */\n\n        av_log(c->fc, AV_LOG_WARNING, \"multiple fourcc not supported\\n\");\n        avio_skip(pb, size);\n        return 1;\n    }\n\n    return 0;\n}\n\nint ff_mov_read_stsd_entries(MOVContext *c, AVIOContext *pb, int entries)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int pseudo_stream_id;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    for (pseudo_stream_id = 0;\n         pseudo_stream_id < entries && !pb->eof_reached;\n         pseudo_stream_id++) {\n        //Parsing Sample description table\n        enum AVCodecID id;\n        int ret, dref_id = 1;\n        MOVAtom a = { AV_RL32(\"stsd\") };\n        int64_t start_pos = avio_tell(pb);\n        int64_t size    = avio_rb32(pb); /* size */\n        uint32_t format = avio_rl32(pb); /* data format */\n\n        if (size >= 16) {\n            avio_rb32(pb); /* reserved */\n            avio_rb16(pb); /* reserved */\n            dref_id = avio_rb16(pb);\n        } else if (size <= 7) {\n            av_log(c->fc, AV_LOG_ERROR,\n                   \"invalid size %\"PRId64\" in stsd\\n\", size);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (mov_skip_multiple_stsd(c, pb, st->codecpar->codec_tag, format,\n                                   size - (avio_tell(pb) - start_pos)))\n            continue;\n\n        sc->pseudo_stream_id = st->codecpar->codec_tag ? -1 : pseudo_stream_id;\n        sc->dref_id= dref_id;\n        sc->format = format;\n\n        id = mov_codec_id(st, format);\n\n        av_log(c->fc, AV_LOG_TRACE,\n               \"size=%\"PRId64\" 4CC=%s codec_type=%d\\n\", size,\n               av_fourcc2str(format), st->codecpar->codec_type);\n\n        if (st->codecpar->codec_type==AVMEDIA_TYPE_VIDEO) {\n            st->codecpar->codec_id = id;\n            mov_parse_stsd_video(c, pb, st, sc);\n        } else if (st->codecpar->codec_type==AVMEDIA_TYPE_AUDIO) {\n            st->codecpar->codec_id = id;\n            mov_parse_stsd_audio(c, pb, st, sc);\n            if (st->codecpar->sample_rate < 0) {\n                av_log(c->fc, AV_LOG_ERROR, \"Invalid sample rate %d\\n\", st->codecpar->sample_rate);\n                return AVERROR_INVALIDDATA;\n            }\n        } else if (st->codecpar->codec_type==AVMEDIA_TYPE_SUBTITLE){\n            st->codecpar->codec_id = id;\n            mov_parse_stsd_subtitle(c, pb, st, sc,\n                                    size - (avio_tell(pb) - start_pos));\n        } else {\n            ret = mov_parse_stsd_data(c, pb, st, sc,\n                                      size - (avio_tell(pb) - start_pos));\n            if (ret < 0)\n                return ret;\n        }\n        /* this will read extra atoms at the end (wave, alac, damr, avcC, hvcC, SMI ...) */\n        a.size = size - (avio_tell(pb) - start_pos);\n        if (a.size > 8) {\n            if ((ret = mov_read_default(c, pb, a)) < 0)\n                return ret;\n        } else if (a.size > 0)\n            avio_skip(pb, a.size);\n\n        if (sc->extradata && st->codecpar->extradata) {\n            int extra_size = st->codecpar->extradata_size;\n\n            /* Move the current stream extradata to the stream context one. */\n            sc->extradata_size[pseudo_stream_id] = extra_size;\n            sc->extradata[pseudo_stream_id] = av_malloc(extra_size + AV_INPUT_BUFFER_PADDING_SIZE);\n            if (!sc->extradata[pseudo_stream_id])\n                return AVERROR(ENOMEM);\n            memcpy(sc->extradata[pseudo_stream_id], st->codecpar->extradata, extra_size);\n            av_freep(&st->codecpar->extradata);\n            st->codecpar->extradata_size = 0;\n        }\n    }\n\n    if (pb->eof_reached)\n        return AVERROR_EOF;\n\n    return 0;\n}\n\nstatic int mov_read_stsd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int ret, entries;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    entries = avio_rb32(pb);\n\n    if (entries <= 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"invalid STSD entries %d\\n\", entries);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (sc->extradata) {\n        av_log(c->fc, AV_LOG_ERROR, \"Duplicate STSD\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    /* Prepare space for hosting multiple extradata. */\n    sc->extradata = av_mallocz_array(entries, sizeof(*sc->extradata));\n    sc->extradata_size = av_mallocz_array(entries, sizeof(*sc->extradata_size));\n    if (!sc->extradata_size || !sc->extradata) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    }\n\n    ret = ff_mov_read_stsd_entries(c, pb, entries);\n    if (ret < 0)\n        return ret;\n\n    sc->stsd_count = entries;\n\n    /* Restore back the primary extradata. */\n    av_freep(&st->codecpar->extradata);\n    st->codecpar->extradata_size = sc->extradata_size[0];\n    if (sc->extradata_size[0]) {\n        st->codecpar->extradata = av_mallocz(sc->extradata_size[0] + AV_INPUT_BUFFER_PADDING_SIZE);\n        if (!st->codecpar->extradata)\n            return AVERROR(ENOMEM);\n        memcpy(st->codecpar->extradata, sc->extradata[0], sc->extradata_size[0]);\n    }\n\n    return mov_finalize_stsd_codec(c, pb, st, sc);\nfail:\n    av_freep(&sc->extradata);\n    av_freep(&sc->extradata_size);\n    return ret;\n}\n\nstatic int mov_read_stsc(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    entries = avio_rb32(pb);\n\n    av_log(c->fc, AV_LOG_TRACE, \"track[%u].stsc.entries = %u\\n\", c->fc->nb_streams - 1, entries);\n\n    if (!entries)\n        return 0;\n    if (sc->stsc_data)\n        av_log(c->fc, AV_LOG_WARNING, \"Duplicated STSC atom\\n\");\n    av_free(sc->stsc_data);\n    sc->stsc_count = 0;\n    sc->stsc_data = av_malloc_array(entries, sizeof(*sc->stsc_data));\n    if (!sc->stsc_data)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n        sc->stsc_data[i].first = avio_rb32(pb);\n        sc->stsc_data[i].count = avio_rb32(pb);\n        sc->stsc_data[i].id = avio_rb32(pb);\n    }\n\n    sc->stsc_count = i;\n\n    if (pb->eof_reached)\n        return AVERROR_EOF;\n\n    return 0;\n}\n\n#define mov_stsc_index_valid(index, count) ((index) < (count) - 1)\n\n/* Compute the samples value for the stsc entry at the given index. */\nstatic inline int mov_get_stsc_samples(MOVStreamContext *sc, int index)\n{\n    int chunk_count;\n\n    if (mov_stsc_index_valid(index, sc->stsc_count))\n        chunk_count = sc->stsc_data[index + 1].first - sc->stsc_data[index].first;\n    else\n        chunk_count = sc->chunk_count - (sc->stsc_data[index].first - 1);\n\n    return sc->stsc_data[index].count * chunk_count;\n}\n\nstatic int mov_read_stps(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned i, entries;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_rb32(pb); // version + flags\n\n    entries = avio_rb32(pb);\n    if (sc->stps_data)\n        av_log(c->fc, AV_LOG_WARNING, \"Duplicated STPS atom\\n\");\n    av_free(sc->stps_data);\n    sc->stps_count = 0;\n    sc->stps_data = av_malloc_array(entries, sizeof(*sc->stps_data));\n    if (!sc->stps_data)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n        sc->stps_data[i] = avio_rb32(pb);\n    }\n\n    sc->stps_count = i;\n\n    if (pb->eof_reached)\n        return AVERROR_EOF;\n\n    return 0;\n}\n\nstatic int mov_read_stss(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    entries = avio_rb32(pb);\n\n    av_log(c->fc, AV_LOG_TRACE, \"keyframe_count = %u\\n\", entries);\n\n    if (!entries)\n    {\n        sc->keyframe_absent = 1;\n        if (!st->need_parsing && st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO)\n            st->need_parsing = AVSTREAM_PARSE_HEADERS;\n        return 0;\n    }\n    if (sc->keyframes)\n        av_log(c->fc, AV_LOG_WARNING, \"Duplicated STSS atom\\n\");\n    if (entries >= UINT_MAX / sizeof(int))\n        return AVERROR_INVALIDDATA;\n    av_freep(&sc->keyframes);\n    sc->keyframe_count = 0;\n    sc->keyframes = av_malloc_array(entries, sizeof(*sc->keyframes));\n    if (!sc->keyframes)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n        sc->keyframes[i] = avio_rb32(pb);\n    }\n\n    sc->keyframe_count = i;\n\n    if (pb->eof_reached)\n        return AVERROR_EOF;\n\n    return 0;\n}\n\nstatic int mov_read_stsz(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries, sample_size, field_size, num_bytes;\n    GetBitContext gb;\n    unsigned char* buf;\n    int ret;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n\n    if (atom.type == MKTAG('s','t','s','z')) {\n        sample_size = avio_rb32(pb);\n        if (!sc->sample_size) /* do not overwrite value computed in stsd */\n            sc->sample_size = sample_size;\n        sc->stsz_sample_size = sample_size;\n        field_size = 32;\n    } else {\n        sample_size = 0;\n        avio_rb24(pb); /* reserved */\n        field_size = avio_r8(pb);\n    }\n    entries = avio_rb32(pb);\n\n    av_log(c->fc, AV_LOG_TRACE, \"sample_size = %u sample_count = %u\\n\", sc->sample_size, entries);\n\n    sc->sample_count = entries;\n    if (sample_size)\n        return 0;\n\n    if (field_size != 4 && field_size != 8 && field_size != 16 && field_size != 32) {\n        av_log(c->fc, AV_LOG_ERROR, \"Invalid sample field size %u\\n\", field_size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (!entries)\n        return 0;\n    if (entries >= (UINT_MAX - 4) / field_size)\n        return AVERROR_INVALIDDATA;\n    if (sc->sample_sizes)\n        av_log(c->fc, AV_LOG_WARNING, \"Duplicated STSZ atom\\n\");\n    av_free(sc->sample_sizes);\n    sc->sample_count = 0;\n    sc->sample_sizes = av_malloc_array(entries, sizeof(*sc->sample_sizes));\n    if (!sc->sample_sizes)\n        return AVERROR(ENOMEM);\n\n    num_bytes = (entries*field_size+4)>>3;\n\n    buf = av_malloc(num_bytes+AV_INPUT_BUFFER_PADDING_SIZE);\n    if (!buf) {\n        av_freep(&sc->sample_sizes);\n        return AVERROR(ENOMEM);\n    }\n\n    ret = ffio_read_size(pb, buf, num_bytes);\n    if (ret < 0) {\n        av_freep(&sc->sample_sizes);\n        av_free(buf);\n        return ret;\n    }\n\n    init_get_bits(&gb, buf, 8*num_bytes);\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n        sc->sample_sizes[i] = get_bits_long(&gb, field_size);\n        sc->data_size += sc->sample_sizes[i];\n    }\n\n    sc->sample_count = i;\n\n    av_free(buf);\n\n    if (pb->eof_reached)\n        return AVERROR_EOF;\n\n    return 0;\n}\n\nstatic int mov_read_stts(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries;\n    int64_t duration=0;\n    int64_t total_sample_count=0;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    entries = avio_rb32(pb);\n\n    av_log(c->fc, AV_LOG_TRACE, \"track[%u].stts.entries = %u\\n\",\n            c->fc->nb_streams-1, entries);\n\n    if (sc->stts_data)\n        av_log(c->fc, AV_LOG_WARNING, \"Duplicated STTS atom\\n\");\n    av_free(sc->stts_data);\n    sc->stts_count = 0;\n    sc->stts_data = av_malloc_array(entries, sizeof(*sc->stts_data));\n    if (!sc->stts_data)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n        int sample_duration;\n        int sample_count;\n\n        sample_count=avio_rb32(pb);\n        sample_duration = avio_rb32(pb);\n\n        if (sample_count < 0) {\n            av_log(c->fc, AV_LOG_ERROR, \"Invalid sample_count=%d\\n\", sample_count);\n            return AVERROR_INVALIDDATA;\n        }\n        sc->stts_data[i].count= sample_count;\n        sc->stts_data[i].duration= sample_duration;\n\n        av_log(c->fc, AV_LOG_TRACE, \"sample_count=%d, sample_duration=%d\\n\",\n                sample_count, sample_duration);\n\n        if (   i+1 == entries\n            && i\n            && sample_count == 1\n            && total_sample_count > 100\n            && sample_duration/10 > duration / total_sample_count)\n            sample_duration = duration / total_sample_count;\n        duration+=(int64_t)sample_duration*sample_count;\n        total_sample_count+=sample_count;\n    }\n\n    sc->stts_count = i;\n\n    sc->duration_for_fps  += duration;\n    sc->nb_frames_for_fps += total_sample_count;\n\n    if (pb->eof_reached)\n        return AVERROR_EOF;\n\n    st->nb_frames= total_sample_count;\n    if (duration)\n        st->duration= duration;\n    sc->track_end = duration;\n    return 0;\n}\n\nstatic void mov_update_dts_shift(MOVStreamContext *sc, int duration)\n{\n    if (duration < 0) {\n        if (duration == INT_MIN) {\n            av_log(NULL, AV_LOG_WARNING, \"mov_update_dts_shift(): dts_shift set to %d\\n\", INT_MAX);\n            duration++;\n        }\n        sc->dts_shift = FFMAX(sc->dts_shift, -duration);\n    }\n}\n\nstatic int mov_read_ctts(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, j, entries, ctts_count = 0;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    entries = avio_rb32(pb);\n\n    av_log(c->fc, AV_LOG_TRACE, \"track[%u].ctts.entries = %u\\n\", c->fc->nb_streams - 1, entries);\n\n    if (!entries)\n        return 0;\n    if (entries >= UINT_MAX / sizeof(*sc->ctts_data))\n        return AVERROR_INVALIDDATA;\n    av_freep(&sc->ctts_data);\n    sc->ctts_data = av_fast_realloc(NULL, &sc->ctts_allocated_size, entries * sizeof(*sc->ctts_data));\n    if (!sc->ctts_data)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n        int count    =avio_rb32(pb);\n        int duration =avio_rb32(pb);\n\n        if (count <= 0) {\n            av_log(c->fc, AV_LOG_TRACE,\n                   \"ignoring CTTS entry with count=%d duration=%d\\n\",\n                   count, duration);\n            continue;\n        }\n\n        /* Expand entries such that we have a 1-1 mapping with samples. */\n        for (j = 0; j < count; j++)\n            add_ctts_entry(&sc->ctts_data, &ctts_count, &sc->ctts_allocated_size, 1, duration);\n\n        av_log(c->fc, AV_LOG_TRACE, \"count=%d, duration=%d\\n\",\n                count, duration);\n\n        if (FFNABS(duration) < -(1<<28) && i+2<entries) {\n            av_log(c->fc, AV_LOG_WARNING, \"CTTS invalid\\n\");\n            av_freep(&sc->ctts_data);\n            sc->ctts_count = 0;\n            return 0;\n        }\n\n        if (i+2<entries)\n            mov_update_dts_shift(sc, duration);\n    }\n\n    sc->ctts_count = ctts_count;\n\n    if (pb->eof_reached)\n        return AVERROR_EOF;\n\n    av_log(c->fc, AV_LOG_TRACE, \"dts shift %d\\n\", sc->dts_shift);\n\n    return 0;\n}\n\nstatic int mov_read_sbgp(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    unsigned int i, entries;\n    uint8_t version;\n    uint32_t grouping_type;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    version = avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    grouping_type = avio_rl32(pb);\n    if (grouping_type != MKTAG( 'r','a','p',' '))\n        return 0; /* only support 'rap ' grouping */\n    if (version == 1)\n        avio_rb32(pb); /* grouping_type_parameter */\n\n    entries = avio_rb32(pb);\n    if (!entries)\n        return 0;\n    if (sc->rap_group)\n        av_log(c->fc, AV_LOG_WARNING, \"Duplicated SBGP atom\\n\");\n    av_free(sc->rap_group);\n    sc->rap_group_count = 0;\n    sc->rap_group = av_malloc_array(entries, sizeof(*sc->rap_group));\n    if (!sc->rap_group)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n        sc->rap_group[i].count = avio_rb32(pb); /* sample_count */\n        sc->rap_group[i].index = avio_rb32(pb); /* group_description_index */\n    }\n\n    sc->rap_group_count = i;\n\n    return pb->eof_reached ? AVERROR_EOF : 0;\n}\n\n/**\n * Get ith edit list entry (media time, duration).\n */\nstatic int get_edit_list_entry(MOVContext *mov,\n                               const MOVStreamContext *msc,\n                               unsigned int edit_list_index,\n                               int64_t *edit_list_media_time,\n                               int64_t *edit_list_duration,\n                               int64_t global_timescale)\n{\n    if (edit_list_index == msc->elst_count) {\n        return 0;\n    }\n    *edit_list_media_time = msc->elst_data[edit_list_index].time;\n    *edit_list_duration = msc->elst_data[edit_list_index].duration;\n\n    /* duration is in global timescale units;convert to msc timescale */\n    if (global_timescale == 0) {\n      avpriv_request_sample(mov->fc, \"Support for mvhd.timescale = 0 with editlists\");\n      return 0;\n    }\n    *edit_list_duration = av_rescale(*edit_list_duration, msc->time_scale,\n                                     global_timescale);\n    return 1;\n}\n\n/**\n * Find the closest previous frame to the timestamp, in e_old index\n * entries. Searching for just any frame / just key frames can be controlled by\n * last argument 'flag'.\n * Returns the index of the entry in st->index_entries if successful,\n * else returns -1.\n */\nstatic int64_t find_prev_closest_index(AVStream *st,\n                                       AVIndexEntry *e_old,\n                                       int nb_old,\n                                       int64_t timestamp,\n                                       int flag)\n{\n    AVIndexEntry *e_keep = st->index_entries;\n    int nb_keep = st->nb_index_entries;\n    int64_t found = -1;\n    int64_t i = 0;\n\n    st->index_entries = e_old;\n    st->nb_index_entries = nb_old;\n    found = av_index_search_timestamp(st, timestamp, flag | AVSEEK_FLAG_BACKWARD);\n\n    // Keep going backwards in the index entries until the timestamp is the same.\n    if (found >= 0) {\n        for (i = found; i > 0 && e_old[i].timestamp == e_old[i - 1].timestamp;\n             i--) {\n            if ((flag & AVSEEK_FLAG_ANY) ||\n                (e_old[i - 1].flags & AVINDEX_KEYFRAME)) {\n                found = i - 1;\n            }\n        }\n    }\n\n    /* restore AVStream state*/\n    st->index_entries = e_keep;\n    st->nb_index_entries = nb_keep;\n    return found;\n}\n\n/**\n * Add index entry with the given values, to the end of st->index_entries.\n * Returns the new size st->index_entries if successful, else returns -1.\n *\n * This function is similar to ff_add_index_entry in libavformat/utils.c\n * except that here we are always unconditionally adding an index entry to\n * the end, instead of searching the entries list and skipping the add if\n * there is an existing entry with the same timestamp.\n * This is needed because the mov_fix_index calls this func with the same\n * unincremented timestamp for successive discarded frames.\n */\nstatic int64_t add_index_entry(AVStream *st, int64_t pos, int64_t timestamp,\n                               int size, int distance, int flags)\n{\n    AVIndexEntry *entries, *ie;\n    int64_t index = -1;\n    const size_t min_size_needed = (st->nb_index_entries + 1) * sizeof(AVIndexEntry);\n\n    // Double the allocation each time, to lower memory fragmentation.\n    // Another difference from ff_add_index_entry function.\n    const size_t requested_size =\n        min_size_needed > st->index_entries_allocated_size ?\n        FFMAX(min_size_needed, 2 * st->index_entries_allocated_size) :\n        min_size_needed;\n\n    if((unsigned)st->nb_index_entries + 1 >= UINT_MAX / sizeof(AVIndexEntry))\n        return -1;\n\n    entries = av_fast_realloc(st->index_entries,\n                              &st->index_entries_allocated_size,\n                              requested_size);\n    if(!entries)\n        return -1;\n\n    st->index_entries= entries;\n\n    index= st->nb_index_entries++;\n    ie= &entries[index];\n\n    ie->pos = pos;\n    ie->timestamp = timestamp;\n    ie->min_distance= distance;\n    ie->size= size;\n    ie->flags = flags;\n    return index;\n}\n\n/**\n * Rewrite timestamps of index entries in the range [end_index - frame_duration_buffer_size, end_index)\n * by subtracting end_ts successively by the amounts given in frame_duration_buffer.\n */\nstatic void fix_index_entry_timestamps(AVStream* st, int end_index, int64_t end_ts,\n                                       int64_t* frame_duration_buffer,\n                                       int frame_duration_buffer_size) {\n    int i = 0;\n    av_assert0(end_index >= 0 && end_index <= st->nb_index_entries);\n    for (i = 0; i < frame_duration_buffer_size; i++) {\n        end_ts -= frame_duration_buffer[frame_duration_buffer_size - 1 - i];\n        st->index_entries[end_index - 1 - i].timestamp = end_ts;\n    }\n}\n\n/**\n * Append a new ctts entry to ctts_data.\n * Returns the new ctts_count if successful, else returns -1.\n */\nstatic int64_t add_ctts_entry(MOVStts** ctts_data, unsigned int* ctts_count, unsigned int* allocated_size,\n                              int count, int duration)\n{\n    MOVStts *ctts_buf_new;\n    const size_t min_size_needed = (*ctts_count + 1) * sizeof(MOVStts);\n    const size_t requested_size =\n        min_size_needed > *allocated_size ?\n        FFMAX(min_size_needed, 2 * (*allocated_size)) :\n        min_size_needed;\n\n    if((unsigned)(*ctts_count) + 1 >= UINT_MAX / sizeof(MOVStts))\n        return -1;\n\n    ctts_buf_new = av_fast_realloc(*ctts_data, allocated_size, requested_size);\n\n    if(!ctts_buf_new)\n        return -1;\n\n    *ctts_data = ctts_buf_new;\n\n    ctts_buf_new[*ctts_count].count = count;\n    ctts_buf_new[*ctts_count].duration = duration;\n\n    *ctts_count = (*ctts_count) + 1;\n    return *ctts_count;\n}\n\nstatic void mov_current_sample_inc(MOVStreamContext *sc)\n{\n    sc->current_sample++;\n    sc->current_index++;\n    if (sc->index_ranges &&\n        sc->current_index >= sc->current_index_range->end &&\n        sc->current_index_range->end) {\n        sc->current_index_range++;\n        sc->current_index = sc->current_index_range->start;\n    }\n}\n\nstatic void mov_current_sample_dec(MOVStreamContext *sc)\n{\n    sc->current_sample--;\n    sc->current_index--;\n    if (sc->index_ranges &&\n        sc->current_index < sc->current_index_range->start &&\n        sc->current_index_range > sc->index_ranges) {\n        sc->current_index_range--;\n        sc->current_index = sc->current_index_range->end - 1;\n    }\n}\n\nstatic void mov_current_sample_set(MOVStreamContext *sc, int current_sample)\n{\n    int64_t range_size;\n\n    sc->current_sample = current_sample;\n    sc->current_index = current_sample;\n    if (!sc->index_ranges) {\n        return;\n    }\n\n    for (sc->current_index_range = sc->index_ranges;\n        sc->current_index_range->end;\n        sc->current_index_range++) {\n        range_size = sc->current_index_range->end - sc->current_index_range->start;\n        if (range_size > current_sample) {\n            sc->current_index = sc->current_index_range->start + current_sample;\n            break;\n        }\n        current_sample -= range_size;\n    }\n}\n\n/**\n * Fix st->index_entries, so that it contains only the entries (and the entries\n * which are needed to decode them) that fall in the edit list time ranges.\n * Also fixes the timestamps of the index entries to match the timeline\n * specified the edit lists.\n */\nstatic void mov_fix_index(MOVContext *mov, AVStream *st)\n{\n    MOVStreamContext *msc = st->priv_data;\n    AVIndexEntry *e_old = st->index_entries;\n    int nb_old = st->nb_index_entries;\n    const AVIndexEntry *e_old_end = e_old + nb_old;\n    const AVIndexEntry *current = NULL;\n    MOVStts *ctts_data_old = msc->ctts_data;\n    int64_t ctts_index_old = 0;\n    int64_t ctts_sample_old = 0;\n    int64_t ctts_count_old = msc->ctts_count;\n    int64_t edit_list_media_time = 0;\n    int64_t edit_list_duration = 0;\n    int64_t frame_duration = 0;\n    int64_t edit_list_dts_counter = 0;\n    int64_t edit_list_dts_entry_end = 0;\n    int64_t edit_list_start_ctts_sample = 0;\n    int64_t curr_cts;\n    int64_t curr_ctts = 0;\n    int64_t min_corrected_pts = -1;\n    int64_t empty_edits_sum_duration = 0;\n    int64_t edit_list_index = 0;\n    int64_t index;\n    int64_t index_ctts_count;\n    int flags;\n    int64_t start_dts = 0;\n    int64_t edit_list_media_time_dts = 0;\n    int64_t edit_list_start_encountered = 0;\n    int64_t search_timestamp = 0;\n    int64_t* frame_duration_buffer = NULL;\n    int num_discarded_begin = 0;\n    int first_non_zero_audio_edit = -1;\n    int packet_skip_samples = 0;\n    MOVIndexRange *current_index_range;\n    int i;\n\n    if (!msc->elst_data || msc->elst_count <= 0 || nb_old <= 0) {\n        return;\n    }\n\n    // allocate the index ranges array\n    msc->index_ranges = av_malloc((msc->elst_count + 1) * sizeof(msc->index_ranges[0]));\n    if (!msc->index_ranges) {\n        av_log(mov->fc, AV_LOG_ERROR, \"Cannot allocate index ranges buffer\\n\");\n        return;\n    }\n    msc->current_index_range = msc->index_ranges;\n    current_index_range = msc->index_ranges - 1;\n\n    // Clean AVStream from traces of old index\n    st->index_entries = NULL;\n    st->index_entries_allocated_size = 0;\n    st->nb_index_entries = 0;\n\n    // Clean ctts fields of MOVStreamContext\n    msc->ctts_data = NULL;\n    msc->ctts_count = 0;\n    msc->ctts_index = 0;\n    msc->ctts_sample = 0;\n    msc->ctts_allocated_size = 0;\n\n    // If the dts_shift is positive (in case of negative ctts values in mov),\n    // then negate the DTS by dts_shift\n    if (msc->dts_shift > 0) {\n        edit_list_dts_entry_end -= msc->dts_shift;\n        av_log(mov->fc, AV_LOG_DEBUG, \"Shifting DTS by %d because of negative CTTS.\\n\", msc->dts_shift);\n    }\n\n    start_dts = edit_list_dts_entry_end;\n\n    while (get_edit_list_entry(mov, msc, edit_list_index, &edit_list_media_time,\n                               &edit_list_duration, mov->time_scale)) {\n        av_log(mov->fc, AV_LOG_DEBUG, \"Processing st: %d, edit list %\"PRId64\" - media time: %\"PRId64\", duration: %\"PRId64\"\\n\",\n               st->index, edit_list_index, edit_list_media_time, edit_list_duration);\n        edit_list_index++;\n        edit_list_dts_counter = edit_list_dts_entry_end;\n        edit_list_dts_entry_end += edit_list_duration;\n        num_discarded_begin = 0;\n        if (edit_list_media_time == -1) {\n            empty_edits_sum_duration += edit_list_duration;\n            continue;\n        }\n\n        // If we encounter a non-negative edit list reset the skip_samples/start_pad fields and set them\n        // according to the edit list below.\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n            if (first_non_zero_audio_edit < 0) {\n                first_non_zero_audio_edit = 1;\n            } else {\n                first_non_zero_audio_edit = 0;\n            }\n\n            if (first_non_zero_audio_edit > 0)\n                st->skip_samples = msc->start_pad = 0;\n        }\n\n        //find closest previous key frame\n        edit_list_media_time_dts = edit_list_media_time;\n        if (msc->dts_shift > 0) {\n            edit_list_media_time_dts -= msc->dts_shift;\n        }\n\n        // While reordering frame index according to edit list we must handle properly\n        // the scenario when edit list entry starts from none key frame.\n        // We find closest previous key frame and preserve it and consequent frames in index.\n        // All frames which are outside edit list entry time boundaries will be dropped after decoding.\n        search_timestamp = edit_list_media_time_dts;\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {\n            // Audio decoders like AAC need need a decoder delay samples previous to the current sample,\n            // to correctly decode this frame. Hence for audio we seek to a frame 1 sec. before the\n            // edit_list_media_time to cover the decoder delay.\n            search_timestamp = FFMAX(search_timestamp - msc->time_scale, e_old[0].timestamp);\n        }\n\n        index = find_prev_closest_index(st, e_old, nb_old, search_timestamp, 0);\n        if (index == -1) {\n            av_log(mov->fc, AV_LOG_WARNING,\n                   \"st: %d edit list: %\"PRId64\" Missing key frame while searching for timestamp: %\"PRId64\"\\n\",\n                   st->index, edit_list_index, search_timestamp);\n            index = find_prev_closest_index(st, e_old, nb_old, search_timestamp, AVSEEK_FLAG_ANY);\n\n            if (index == -1) {\n                av_log(mov->fc, AV_LOG_WARNING,\n                       \"st: %d edit list %\"PRId64\" Cannot find an index entry before timestamp: %\"PRId64\".\\n\"\n                       \"Rounding edit list media time to zero.\\n\",\n                       st->index, edit_list_index, search_timestamp);\n                index = 0;\n                edit_list_media_time = 0;\n            }\n        }\n        current = e_old + index;\n\n        ctts_index_old = 0;\n        ctts_sample_old = 0;\n\n        // set ctts_index properly for the found key frame\n        for (index_ctts_count = 0; index_ctts_count < index; index_ctts_count++) {\n            if (ctts_data_old && ctts_index_old < ctts_count_old) {\n                ctts_sample_old++;\n                if (ctts_data_old[ctts_index_old].count == ctts_sample_old) {\n                    ctts_index_old++;\n                    ctts_sample_old = 0;\n                }\n            }\n        }\n\n        edit_list_start_ctts_sample = ctts_sample_old;\n\n        // Iterate over index and arrange it according to edit list\n        edit_list_start_encountered = 0;\n        for (; current < e_old_end; current++, index++) {\n            // check  if frame outside edit list mark it for discard\n            frame_duration = (current + 1 <  e_old_end) ?\n                             ((current + 1)->timestamp - current->timestamp) : edit_list_duration;\n\n            flags = current->flags;\n\n            // frames (pts) before or after edit list\n            curr_cts = current->timestamp + msc->dts_shift;\n            curr_ctts = 0;\n\n            if (ctts_data_old && ctts_index_old < ctts_count_old) {\n                curr_ctts = ctts_data_old[ctts_index_old].duration;\n                av_log(mov->fc, AV_LOG_DEBUG, \"stts: %\"PRId64\" ctts: %\"PRId64\", ctts_index: %\"PRId64\", ctts_count: %\"PRId64\"\\n\",\n                       curr_cts, curr_ctts, ctts_index_old, ctts_count_old);\n                curr_cts += curr_ctts;\n                ctts_sample_old++;\n                if (ctts_sample_old == ctts_data_old[ctts_index_old].count) {\n                    if (add_ctts_entry(&msc->ctts_data, &msc->ctts_count,\n                                       &msc->ctts_allocated_size,\n                                       ctts_data_old[ctts_index_old].count - edit_list_start_ctts_sample,\n                                       ctts_data_old[ctts_index_old].duration) == -1) {\n                        av_log(mov->fc, AV_LOG_ERROR, \"Cannot add CTTS entry %\"PRId64\" - {%\"PRId64\", %d}\\n\",\n                               ctts_index_old,\n                               ctts_data_old[ctts_index_old].count - edit_list_start_ctts_sample,\n                               ctts_data_old[ctts_index_old].duration);\n                        break;\n                    }\n                    ctts_index_old++;\n                    ctts_sample_old = 0;\n                    edit_list_start_ctts_sample = 0;\n                }\n            }\n\n            if (curr_cts < edit_list_media_time || curr_cts >= (edit_list_duration + edit_list_media_time)) {\n                if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO && st->codecpar->codec_id != AV_CODEC_ID_VORBIS &&\n                    curr_cts < edit_list_media_time && curr_cts + frame_duration > edit_list_media_time &&\n                    first_non_zero_audio_edit > 0) {\n                    packet_skip_samples = edit_list_media_time - curr_cts;\n                    st->skip_samples += packet_skip_samples;\n\n                    // Shift the index entry timestamp by packet_skip_samples to be correct.\n                    edit_list_dts_counter -= packet_skip_samples;\n                    if (edit_list_start_encountered == 0)  {\n                        edit_list_start_encountered = 1;\n                        // Make timestamps strictly monotonically increasing for audio, by rewriting timestamps for\n                        // discarded packets.\n                        if (frame_duration_buffer) {\n                            fix_index_entry_timestamps(st, st->nb_index_entries, edit_list_dts_counter,\n                                                       frame_duration_buffer, num_discarded_begin);\n                            av_freep(&frame_duration_buffer);\n                        }\n                    }\n\n                    av_log(mov->fc, AV_LOG_DEBUG, \"skip %d audio samples from curr_cts: %\"PRId64\"\\n\", packet_skip_samples, curr_cts);\n                } else {\n                    flags |= AVINDEX_DISCARD_FRAME;\n                    av_log(mov->fc, AV_LOG_DEBUG, \"drop a frame at curr_cts: %\"PRId64\" @ %\"PRId64\"\\n\", curr_cts, index);\n\n                    if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO && edit_list_start_encountered == 0) {\n                        num_discarded_begin++;\n                        frame_duration_buffer = av_realloc(frame_duration_buffer,\n                                                           num_discarded_begin * sizeof(int64_t));\n                        if (!frame_duration_buffer) {\n                            av_log(mov->fc, AV_LOG_ERROR, \"Cannot reallocate frame duration buffer\\n\");\n                            break;\n                        }\n                        frame_duration_buffer[num_discarded_begin - 1] = frame_duration;\n\n                        // Increment skip_samples for the first non-zero audio edit list\n                        if (first_non_zero_audio_edit > 0 && st->codecpar->codec_id != AV_CODEC_ID_VORBIS) {\n                            st->skip_samples += frame_duration;\n                            msc->start_pad = st->skip_samples;\n                        }\n                    }\n                }\n            } else {\n                if (min_corrected_pts < 0) {\n                    min_corrected_pts = edit_list_dts_counter + curr_ctts + msc->dts_shift;\n                } else {\n                    min_corrected_pts = FFMIN(min_corrected_pts, edit_list_dts_counter + curr_ctts + msc->dts_shift);\n                }\n                if (edit_list_start_encountered == 0) {\n                    edit_list_start_encountered = 1;\n                    // Make timestamps strictly monotonically increasing for audio, by rewriting timestamps for\n                    // discarded packets.\n                    if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO && frame_duration_buffer) {\n                        fix_index_entry_timestamps(st, st->nb_index_entries, edit_list_dts_counter,\n                                                   frame_duration_buffer, num_discarded_begin);\n                        av_freep(&frame_duration_buffer);\n                    }\n                }\n            }\n\n            if (add_index_entry(st, current->pos, edit_list_dts_counter, current->size,\n                                current->min_distance, flags) == -1) {\n                av_log(mov->fc, AV_LOG_ERROR, \"Cannot add index entry\\n\");\n                break;\n            }\n\n            // Update the index ranges array\n            if (current_index_range < msc->index_ranges || index != current_index_range->end) {\n                current_index_range++;\n                current_index_range->start = index;\n            }\n            current_index_range->end = index + 1;\n\n            // Only start incrementing DTS in frame_duration amounts, when we encounter a frame in edit list.\n            if (edit_list_start_encountered > 0) {\n                edit_list_dts_counter = edit_list_dts_counter + frame_duration;\n            }\n\n            // Break when found first key frame after edit entry completion\n            if (((curr_cts + frame_duration) >= (edit_list_duration + edit_list_media_time)) &&\n                ((flags & AVINDEX_KEYFRAME) || ((st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO)))) {\n\n                if (ctts_data_old && ctts_sample_old != 0) {\n                    if (add_ctts_entry(&msc->ctts_data, &msc->ctts_count,\n                                       &msc->ctts_allocated_size,\n                                       ctts_sample_old - edit_list_start_ctts_sample,\n                                       ctts_data_old[ctts_index_old].duration) == -1) {\n                        av_log(mov->fc, AV_LOG_ERROR, \"Cannot add CTTS entry %\"PRId64\" - {%\"PRId64\", %d}\\n\",\n                               ctts_index_old, ctts_sample_old - edit_list_start_ctts_sample,\n                               ctts_data_old[ctts_index_old].duration);\n                        break;\n                    }\n                }\n                break;\n            }\n        }\n    }\n    // If there are empty edits, then min_corrected_pts might be positive intentionally. So we subtract the\n    // sum duration of emtpy edits here.\n    min_corrected_pts -= empty_edits_sum_duration;\n\n    // If the minimum pts turns out to be greater than zero after fixing the index, then we subtract the\n    // dts by that amount to make the first pts zero.\n    if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO && min_corrected_pts > 0) {\n        av_log(mov->fc, AV_LOG_DEBUG, \"Offset DTS by %\"PRId64\" to make first pts zero.\\n\", min_corrected_pts);\n        for (i = 0; i < st->nb_index_entries; ++i) {\n            st->index_entries[i].timestamp -= min_corrected_pts;\n        }\n    }\n\n    // Update av stream length\n    st->duration = edit_list_dts_entry_end - start_dts;\n\n    // Free the old index and the old CTTS structures\n    av_free(e_old);\n    av_free(ctts_data_old);\n\n    // Null terminate the index ranges array\n    current_index_range++;\n    current_index_range->start = 0;\n    current_index_range->end = 0;\n    msc->current_index = msc->index_ranges[0].start;\n}\n\nstatic void mov_build_index(MOVContext *mov, AVStream *st)\n{\n    MOVStreamContext *sc = st->priv_data;\n    int64_t current_offset;\n    int64_t current_dts = 0;\n    unsigned int stts_index = 0;\n    unsigned int stsc_index = 0;\n    unsigned int stss_index = 0;\n    unsigned int stps_index = 0;\n    unsigned int i, j;\n    uint64_t stream_size = 0;\n\n    if (sc->elst_count) {\n        int i, edit_start_index = 0, multiple_edits = 0;\n        int64_t empty_duration = 0; // empty duration of the first edit list entry\n        int64_t start_time = 0; // start time of the media\n\n        for (i = 0; i < sc->elst_count; i++) {\n            const MOVElst *e = &sc->elst_data[i];\n            if (i == 0 && e->time == -1) {\n                /* if empty, the first entry is the start time of the stream\n                 * relative to the presentation itself */\n                empty_duration = e->duration;\n                edit_start_index = 1;\n            } else if (i == edit_start_index && e->time >= 0) {\n                start_time = e->time;\n            } else {\n                multiple_edits = 1;\n            }\n        }\n\n        if (multiple_edits && !mov->advanced_editlist)\n            av_log(mov->fc, AV_LOG_WARNING, \"multiple edit list entries, \"\n                   \"Use -advanced_editlist to correctly decode otherwise \"\n                   \"a/v desync might occur\\n\");\n\n        /* adjust first dts according to edit list */\n        if ((empty_duration || start_time) && mov->time_scale > 0) {\n            if (empty_duration)\n                empty_duration = av_rescale(empty_duration, sc->time_scale, mov->time_scale);\n            sc->time_offset = start_time - empty_duration;\n            if (!mov->advanced_editlist)\n                current_dts = -sc->time_offset;\n        }\n\n        if (!multiple_edits && !mov->advanced_editlist &&\n            st->codecpar->codec_id == AV_CODEC_ID_AAC && start_time > 0)\n            sc->start_pad = start_time;\n    }\n\n    /* only use old uncompressed audio chunk demuxing when stts specifies it */\n    if (!(st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO &&\n          sc->stts_count == 1 && sc->stts_data[0].duration == 1)) {\n        unsigned int current_sample = 0;\n        unsigned int stts_sample = 0;\n        unsigned int sample_size;\n        unsigned int distance = 0;\n        unsigned int rap_group_index = 0;\n        unsigned int rap_group_sample = 0;\n        int64_t last_dts = 0;\n        int64_t dts_correction = 0;\n        int rap_group_present = sc->rap_group_count && sc->rap_group;\n        int key_off = (sc->keyframe_count && sc->keyframes[0] > 0) || (sc->stps_count && sc->stps_data[0] > 0);\n\n        current_dts -= sc->dts_shift;\n        last_dts     = current_dts;\n\n        if (!sc->sample_count || st->nb_index_entries)\n            return;\n        if (sc->sample_count >= UINT_MAX / sizeof(*st->index_entries) - st->nb_index_entries)\n            return;\n        if (av_reallocp_array(&st->index_entries,\n                              st->nb_index_entries + sc->sample_count,\n                              sizeof(*st->index_entries)) < 0) {\n            st->nb_index_entries = 0;\n            return;\n        }\n        st->index_entries_allocated_size = (st->nb_index_entries + sc->sample_count) * sizeof(*st->index_entries);\n\n        for (i = 0; i < sc->chunk_count; i++) {\n            int64_t next_offset = i+1 < sc->chunk_count ? sc->chunk_offsets[i+1] : INT64_MAX;\n            current_offset = sc->chunk_offsets[i];\n            while (mov_stsc_index_valid(stsc_index, sc->stsc_count) &&\n                i + 1 == sc->stsc_data[stsc_index + 1].first)\n                stsc_index++;\n\n            if (next_offset > current_offset && sc->sample_size>0 && sc->sample_size < sc->stsz_sample_size &&\n                sc->stsc_data[stsc_index].count * (int64_t)sc->stsz_sample_size > next_offset - current_offset) {\n                av_log(mov->fc, AV_LOG_WARNING, \"STSZ sample size %d invalid (too large), ignoring\\n\", sc->stsz_sample_size);\n                sc->stsz_sample_size = sc->sample_size;\n            }\n            if (sc->stsz_sample_size>0 && sc->stsz_sample_size < sc->sample_size) {\n                av_log(mov->fc, AV_LOG_WARNING, \"STSZ sample size %d invalid (too small), ignoring\\n\", sc->stsz_sample_size);\n                sc->stsz_sample_size = sc->sample_size;\n            }\n\n            for (j = 0; j < sc->stsc_data[stsc_index].count; j++) {\n                int keyframe = 0;\n                if (current_sample >= sc->sample_count) {\n                    av_log(mov->fc, AV_LOG_ERROR, \"wrong sample count\\n\");\n                    return;\n                }\n\n                if (!sc->keyframe_absent && (!sc->keyframe_count || current_sample+key_off == sc->keyframes[stss_index])) {\n                    keyframe = 1;\n                    if (stss_index + 1 < sc->keyframe_count)\n                        stss_index++;\n                } else if (sc->stps_count && current_sample+key_off == sc->stps_data[stps_index]) {\n                    keyframe = 1;\n                    if (stps_index + 1 < sc->stps_count)\n                        stps_index++;\n                }\n                if (rap_group_present && rap_group_index < sc->rap_group_count) {\n                    if (sc->rap_group[rap_group_index].index > 0)\n                        keyframe = 1;\n                    if (++rap_group_sample == sc->rap_group[rap_group_index].count) {\n                        rap_group_sample = 0;\n                        rap_group_index++;\n                    }\n                }\n                if (sc->keyframe_absent\n                    && !sc->stps_count\n                    && !rap_group_present\n                    && (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO || (i==0 && j==0)))\n                     keyframe = 1;\n                if (keyframe)\n                    distance = 0;\n                sample_size = sc->stsz_sample_size > 0 ? sc->stsz_sample_size : sc->sample_sizes[current_sample];\n                if (sc->pseudo_stream_id == -1 ||\n                   sc->stsc_data[stsc_index].id - 1 == sc->pseudo_stream_id) {\n                    AVIndexEntry *e;\n                    if (sample_size > 0x3FFFFFFF) {\n                        av_log(mov->fc, AV_LOG_ERROR, \"Sample size %u is too large\\n\", sample_size);\n                        return;\n                    }\n                    e = &st->index_entries[st->nb_index_entries++];\n                    e->pos = current_offset;\n                    e->timestamp = current_dts;\n                    e->size = sample_size;\n                    e->min_distance = distance;\n                    e->flags = keyframe ? AVINDEX_KEYFRAME : 0;\n                    av_log(mov->fc, AV_LOG_TRACE, \"AVIndex stream %d, sample %u, offset %\"PRIx64\", dts %\"PRId64\", \"\n                            \"size %u, distance %u, keyframe %d\\n\", st->index, current_sample,\n                            current_offset, current_dts, sample_size, distance, keyframe);\n                    if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO && st->nb_index_entries < 100)\n                        ff_rfps_add_frame(mov->fc, st, current_dts);\n                }\n\n                current_offset += sample_size;\n                stream_size += sample_size;\n\n                /* A negative sample duration is invalid based on the spec,\n                 * but some samples need it to correct the DTS. */\n                if (sc->stts_data[stts_index].duration < 0) {\n                    av_log(mov->fc, AV_LOG_WARNING,\n                           \"Invalid SampleDelta %d in STTS, at %d st:%d\\n\",\n                           sc->stts_data[stts_index].duration, stts_index,\n                           st->index);\n                    dts_correction += sc->stts_data[stts_index].duration - 1;\n                    sc->stts_data[stts_index].duration = 1;\n                }\n                current_dts += sc->stts_data[stts_index].duration;\n                if (!dts_correction || current_dts + dts_correction > last_dts) {\n                    current_dts += dts_correction;\n                    dts_correction = 0;\n                } else {\n                    /* Avoid creating non-monotonous DTS */\n                    dts_correction += current_dts - last_dts - 1;\n                    current_dts = last_dts + 1;\n                }\n                last_dts = current_dts;\n                distance++;\n                stts_sample++;\n                current_sample++;\n                if (stts_index + 1 < sc->stts_count && stts_sample == sc->stts_data[stts_index].count) {\n                    stts_sample = 0;\n                    stts_index++;\n                }\n            }\n        }\n        if (st->duration > 0)\n            st->codecpar->bit_rate = stream_size*8*sc->time_scale/st->duration;\n    } else {\n        unsigned chunk_samples, total = 0;\n\n        // compute total chunk count\n        for (i = 0; i < sc->stsc_count; i++) {\n            unsigned count, chunk_count;\n\n            chunk_samples = sc->stsc_data[i].count;\n            if (i != sc->stsc_count - 1 &&\n                sc->samples_per_frame && chunk_samples % sc->samples_per_frame) {\n                av_log(mov->fc, AV_LOG_ERROR, \"error unaligned chunk\\n\");\n                return;\n            }\n\n            if (sc->samples_per_frame >= 160) { // gsm\n                count = chunk_samples / sc->samples_per_frame;\n            } else if (sc->samples_per_frame > 1) {\n                unsigned samples = (1024/sc->samples_per_frame)*sc->samples_per_frame;\n                count = (chunk_samples+samples-1) / samples;\n            } else {\n                count = (chunk_samples+1023) / 1024;\n            }\n\n            if (mov_stsc_index_valid(i, sc->stsc_count))\n                chunk_count = sc->stsc_data[i+1].first - sc->stsc_data[i].first;\n            else\n                chunk_count = sc->chunk_count - (sc->stsc_data[i].first - 1);\n            total += chunk_count * count;\n        }\n\n        av_log(mov->fc, AV_LOG_TRACE, \"chunk count %u\\n\", total);\n        if (total >= UINT_MAX / sizeof(*st->index_entries) - st->nb_index_entries)\n            return;\n        if (av_reallocp_array(&st->index_entries,\n                              st->nb_index_entries + total,\n                              sizeof(*st->index_entries)) < 0) {\n            st->nb_index_entries = 0;\n            return;\n        }\n        st->index_entries_allocated_size = (st->nb_index_entries + total) * sizeof(*st->index_entries);\n\n        // populate index\n        for (i = 0; i < sc->chunk_count; i++) {\n            current_offset = sc->chunk_offsets[i];\n            if (mov_stsc_index_valid(stsc_index, sc->stsc_count) &&\n                i + 1 == sc->stsc_data[stsc_index + 1].first)\n                stsc_index++;\n            chunk_samples = sc->stsc_data[stsc_index].count;\n\n            while (chunk_samples > 0) {\n                AVIndexEntry *e;\n                unsigned size, samples;\n\n                if (sc->samples_per_frame > 1 && !sc->bytes_per_frame) {\n                    avpriv_request_sample(mov->fc,\n                           \"Zero bytes per frame, but %d samples per frame\",\n                           sc->samples_per_frame);\n                    return;\n                }\n\n                if (sc->samples_per_frame >= 160) { // gsm\n                    samples = sc->samples_per_frame;\n                    size = sc->bytes_per_frame;\n                } else {\n                    if (sc->samples_per_frame > 1) {\n                        samples = FFMIN((1024 / sc->samples_per_frame)*\n                                        sc->samples_per_frame, chunk_samples);\n                        size = (samples / sc->samples_per_frame) * sc->bytes_per_frame;\n                    } else {\n                        samples = FFMIN(1024, chunk_samples);\n                        size = samples * sc->sample_size;\n                    }\n                }\n\n                if (st->nb_index_entries >= total) {\n                    av_log(mov->fc, AV_LOG_ERROR, \"wrong chunk count %u\\n\", total);\n                    return;\n                }\n                if (size > 0x3FFFFFFF) {\n                    av_log(mov->fc, AV_LOG_ERROR, \"Sample size %u is too large\\n\", size);\n                    return;\n                }\n                e = &st->index_entries[st->nb_index_entries++];\n                e->pos = current_offset;\n                e->timestamp = current_dts;\n                e->size = size;\n                e->min_distance = 0;\n                e->flags = AVINDEX_KEYFRAME;\n                av_log(mov->fc, AV_LOG_TRACE, \"AVIndex stream %d, chunk %u, offset %\"PRIx64\", dts %\"PRId64\", \"\n                       \"size %u, duration %u\\n\", st->index, i, current_offset, current_dts,\n                       size, samples);\n\n                current_offset += size;\n                current_dts += samples;\n                chunk_samples -= samples;\n            }\n        }\n    }\n\n    if (!mov->ignore_editlist && mov->advanced_editlist) {\n        // Fix index according to edit lists.\n        mov_fix_index(mov, st);\n    }\n}\n\nstatic int test_same_origin(const char *src, const char *ref) {\n    char src_proto[64];\n    char ref_proto[64];\n    char src_auth[256];\n    char ref_auth[256];\n    char src_host[256];\n    char ref_host[256];\n    int src_port=-1;\n    int ref_port=-1;\n\n    av_url_split(src_proto, sizeof(src_proto), src_auth, sizeof(src_auth), src_host, sizeof(src_host), &src_port, NULL, 0, src);\n    av_url_split(ref_proto, sizeof(ref_proto), ref_auth, sizeof(ref_auth), ref_host, sizeof(ref_host), &ref_port, NULL, 0, ref);\n\n    if (strlen(src) == 0) {\n        return -1;\n    } else if (strlen(src_auth) + 1 >= sizeof(src_auth) ||\n        strlen(ref_auth) + 1 >= sizeof(ref_auth) ||\n        strlen(src_host) + 1 >= sizeof(src_host) ||\n        strlen(ref_host) + 1 >= sizeof(ref_host)) {\n        return 0;\n    } else if (strcmp(src_proto, ref_proto) ||\n               strcmp(src_auth, ref_auth) ||\n               strcmp(src_host, ref_host) ||\n               src_port != ref_port) {\n        return 0;\n    } else\n        return 1;\n}\n\nstatic int mov_open_dref(MOVContext *c, AVIOContext **pb, const char *src, MOVDref *ref)\n{\n    /* try relative path, we do not try the absolute because it can leak information about our\n       system to an attacker */\n    if (ref->nlvl_to > 0 && ref->nlvl_from > 0) {\n        char filename[1025];\n        const char *src_path;\n        int i, l;\n\n        /* find a source dir */\n        src_path = strrchr(src, '/');\n        if (src_path)\n            src_path++;\n        else\n            src_path = src;\n\n        /* find a next level down to target */\n        for (i = 0, l = strlen(ref->path) - 1; l >= 0; l--)\n            if (ref->path[l] == '/') {\n                if (i == ref->nlvl_to - 1)\n                    break;\n                else\n                    i++;\n            }\n\n        /* compose filename if next level down to target was found */\n        if (i == ref->nlvl_to - 1 && src_path - src  < sizeof(filename)) {\n            memcpy(filename, src, src_path - src);\n            filename[src_path - src] = 0;\n\n            for (i = 1; i < ref->nlvl_from; i++)\n                av_strlcat(filename, \"../\", sizeof(filename));\n\n            av_strlcat(filename, ref->path + l + 1, sizeof(filename));\n            if (!c->use_absolute_path) {\n                int same_origin = test_same_origin(src, filename);\n\n                if (!same_origin) {\n                    av_log(c->fc, AV_LOG_ERROR,\n                        \"Reference with mismatching origin, %s not tried for security reasons, \"\n                        \"set demuxer option use_absolute_path to allow it anyway\\n\",\n                        ref->path);\n                    return AVERROR(ENOENT);\n                }\n\n                if(strstr(ref->path + l + 1, \"..\") ||\n                   strstr(ref->path + l + 1, \":\") ||\n                   (ref->nlvl_from > 1 && same_origin < 0) ||\n                   (filename[0] == '/' && src_path == src))\n                    return AVERROR(ENOENT);\n            }\n\n            if (strlen(filename) + 1 == sizeof(filename))\n                return AVERROR(ENOENT);\n            if (!c->fc->io_open(c->fc, pb, filename, AVIO_FLAG_READ, NULL))\n                return 0;\n        }\n    } else if (c->use_absolute_path) {\n        av_log(c->fc, AV_LOG_WARNING, \"Using absolute path on user request, \"\n               \"this is a possible security issue\\n\");\n        if (!c->fc->io_open(c->fc, pb, ref->path, AVIO_FLAG_READ, NULL))\n            return 0;\n    } else {\n        av_log(c->fc, AV_LOG_ERROR,\n               \"Absolute path %s not tried for security reasons, \"\n               \"set demuxer option use_absolute_path to allow absolute paths\\n\",\n               ref->path);\n    }\n\n    return AVERROR(ENOENT);\n}\n\nstatic void fix_timescale(MOVContext *c, MOVStreamContext *sc)\n{\n    if (sc->time_scale <= 0) {\n        av_log(c->fc, AV_LOG_WARNING, \"stream %d, timescale not set\\n\", sc->ffindex);\n        sc->time_scale = c->time_scale;\n        if (sc->time_scale <= 0)\n            sc->time_scale = 1;\n    }\n}\n\nstatic int mov_read_trak(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int ret;\n\n    st = avformat_new_stream(c->fc, NULL);\n    if (!st) return AVERROR(ENOMEM);\n    st->id = c->fc->nb_streams;\n    sc = av_mallocz(sizeof(MOVStreamContext));\n    if (!sc) return AVERROR(ENOMEM);\n\n    st->priv_data = sc;\n    st->codecpar->codec_type = AVMEDIA_TYPE_DATA;\n    sc->ffindex = st->index;\n    c->trak_index = st->index;\n\n    if ((ret = mov_read_default(c, pb, atom)) < 0)\n        return ret;\n\n    c->trak_index = -1;\n\n    /* sanity checks */\n    if ((sc->chunk_count && (!sc->stts_count || !sc->stsc_count ||\n                            (!sc->sample_size && !sc->sample_count))) ||\n        (!sc->chunk_count && sc->sample_count)) {\n        av_log(c->fc, AV_LOG_ERROR, \"stream %d, missing mandatory atoms, broken header\\n\",\n               st->index);\n        return 0;\n    }\n\n    fix_timescale(c, sc);\n\n    avpriv_set_pts_info(st, 64, 1, sc->time_scale);\n\n    mov_build_index(c, st);\n\n    if (sc->dref_id-1 < sc->drefs_count && sc->drefs[sc->dref_id-1].path) {\n        MOVDref *dref = &sc->drefs[sc->dref_id - 1];\n        if (c->enable_drefs) {\n            if (mov_open_dref(c, &sc->pb, c->fc->filename, dref) < 0)\n                av_log(c->fc, AV_LOG_ERROR,\n                       \"stream %d, error opening alias: path='%s', dir='%s', \"\n                       \"filename='%s', volume='%s', nlvl_from=%d, nlvl_to=%d\\n\",\n                       st->index, dref->path, dref->dir, dref->filename,\n                       dref->volume, dref->nlvl_from, dref->nlvl_to);\n        } else {\n            av_log(c->fc, AV_LOG_WARNING,\n                   \"Skipped opening external track: \"\n                   \"stream %d, alias: path='%s', dir='%s', \"\n                   \"filename='%s', volume='%s', nlvl_from=%d, nlvl_to=%d.\"\n                   \"Set enable_drefs to allow this.\\n\",\n                   st->index, dref->path, dref->dir, dref->filename,\n                   dref->volume, dref->nlvl_from, dref->nlvl_to);\n        }\n    } else {\n        sc->pb = c->fc->pb;\n        sc->pb_is_copied = 1;\n    }\n\n    if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n        if (!st->sample_aspect_ratio.num && st->codecpar->width && st->codecpar->height &&\n            sc->height && sc->width &&\n            (st->codecpar->width != sc->width || st->codecpar->height != sc->height)) {\n            st->sample_aspect_ratio = av_d2q(((double)st->codecpar->height * sc->width) /\n                                             ((double)st->codecpar->width * sc->height), INT_MAX);\n        }\n\n#if FF_API_R_FRAME_RATE\n        if (sc->stts_count == 1 || (sc->stts_count == 2 && sc->stts_data[1].count == 1))\n            av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den,\n                      sc->time_scale, sc->stts_data[0].duration, INT_MAX);\n#endif\n    }\n\n    // done for ai5q, ai52, ai55, ai1q, ai12 and ai15.\n    if (!st->codecpar->extradata_size && st->codecpar->codec_id == AV_CODEC_ID_H264 &&\n        TAG_IS_AVCI(st->codecpar->codec_tag)) {\n        ret = ff_generate_avci_extradata(st);\n        if (ret < 0)\n            return ret;\n    }\n\n    switch (st->codecpar->codec_id) {\n#if CONFIG_H261_DECODER\n    case AV_CODEC_ID_H261:\n#endif\n#if CONFIG_H263_DECODER\n    case AV_CODEC_ID_H263:\n#endif\n#if CONFIG_MPEG4_DECODER\n    case AV_CODEC_ID_MPEG4:\n#endif\n        st->codecpar->width = 0; /* let decoder init width/height */\n        st->codecpar->height= 0;\n        break;\n    }\n\n    // If the duration of the mp3 packets is not constant, then they could need a parser\n    if (st->codecpar->codec_id == AV_CODEC_ID_MP3\n        && sc->stts_count > 3\n        && sc->stts_count*10 > st->nb_frames\n        && sc->time_scale == st->codecpar->sample_rate) {\n            st->need_parsing = AVSTREAM_PARSE_FULL;\n    }\n    /* Do not need those anymore. */\n    av_freep(&sc->chunk_offsets);\n    av_freep(&sc->sample_sizes);\n    av_freep(&sc->keyframes);\n    av_freep(&sc->stts_data);\n    av_freep(&sc->stps_data);\n    av_freep(&sc->elst_data);\n    av_freep(&sc->rap_group);\n\n    return 0;\n}\n\nstatic int mov_read_ilst(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int ret;\n    c->itunes_metadata = 1;\n    ret = mov_read_default(c, pb, atom);\n    c->itunes_metadata = 0;\n    return ret;\n}\n\nstatic int mov_read_keys(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    uint32_t count;\n    uint32_t i;\n\n    if (atom.size < 8)\n        return 0;\n\n    avio_skip(pb, 4);\n    count = avio_rb32(pb);\n    if (count > UINT_MAX / sizeof(*c->meta_keys) - 1) {\n        av_log(c->fc, AV_LOG_ERROR,\n               \"The 'keys' atom with the invalid key count: %\"PRIu32\"\\n\", count);\n        return AVERROR_INVALIDDATA;\n    }\n\n    c->meta_keys_count = count + 1;\n    c->meta_keys = av_mallocz(c->meta_keys_count * sizeof(*c->meta_keys));\n    if (!c->meta_keys)\n        return AVERROR(ENOMEM);\n\n    for (i = 1; i <= count; ++i) {\n        uint32_t key_size = avio_rb32(pb);\n        uint32_t type = avio_rl32(pb);\n        if (key_size < 8) {\n            av_log(c->fc, AV_LOG_ERROR,\n                   \"The key# %\"PRIu32\" in meta has invalid size:\"\n                   \"%\"PRIu32\"\\n\", i, key_size);\n            return AVERROR_INVALIDDATA;\n        }\n        key_size -= 8;\n        if (type != MKTAG('m','d','t','a')) {\n            avio_skip(pb, key_size);\n        }\n        c->meta_keys[i] = av_mallocz(key_size + 1);\n        if (!c->meta_keys[i])\n            return AVERROR(ENOMEM);\n        avio_read(pb, c->meta_keys[i], key_size);\n    }\n\n    return 0;\n}\n\nstatic int mov_read_custom(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int64_t end = avio_tell(pb) + atom.size;\n    uint8_t *key = NULL, *val = NULL, *mean = NULL;\n    int i;\n    int ret = 0;\n    AVStream *st;\n    MOVStreamContext *sc;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    for (i = 0; i < 3; i++) {\n        uint8_t **p;\n        uint32_t len, tag;\n\n        if (end - avio_tell(pb) <= 12)\n            break;\n\n        len = avio_rb32(pb);\n        tag = avio_rl32(pb);\n        avio_skip(pb, 4); // flags\n\n        if (len < 12 || len - 12 > end - avio_tell(pb))\n            break;\n        len -= 12;\n\n        if (tag == MKTAG('m', 'e', 'a', 'n'))\n            p = &mean;\n        else if (tag == MKTAG('n', 'a', 'm', 'e'))\n            p = &key;\n        else if (tag == MKTAG('d', 'a', 't', 'a') && len > 4) {\n            avio_skip(pb, 4);\n            len -= 4;\n            p = &val;\n        } else\n            break;\n\n        *p = av_malloc(len + 1);\n        if (!*p)\n            break;\n        ret = ffio_read_size(pb, *p, len);\n        if (ret < 0) {\n            av_freep(p);\n            break;\n        }\n        (*p)[len] = 0;\n    }\n\n    if (mean && key && val) {\n        if (strcmp(key, \"iTunSMPB\") == 0) {\n            int priming, remainder, samples;\n            if(sscanf(val, \"%*X %X %X %X\", &priming, &remainder, &samples) == 3){\n                if(priming>0 && priming<16384)\n                    sc->start_pad = priming;\n            }\n        }\n        if (strcmp(key, \"cdec\") != 0) {\n            av_dict_set(&c->fc->metadata, key, val,\n                        AV_DICT_DONT_STRDUP_KEY | AV_DICT_DONT_STRDUP_VAL);\n            key = val = NULL;\n        }\n    } else {\n        av_log(c->fc, AV_LOG_VERBOSE,\n               \"Unhandled or malformed custom metadata of size %\"PRId64\"\\n\", atom.size);\n    }\n\n    avio_seek(pb, end, SEEK_SET);\n    av_freep(&key);\n    av_freep(&val);\n    av_freep(&mean);\n    return ret;\n}\n\nstatic int mov_read_meta(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    while (atom.size > 8) {\n        uint32_t tag = avio_rl32(pb);\n        atom.size -= 4;\n        if (tag == MKTAG('h','d','l','r')) {\n            avio_seek(pb, -8, SEEK_CUR);\n            atom.size += 8;\n            return mov_read_default(c, pb, atom);\n        }\n    }\n    return 0;\n}\n\n// return 1 when matrix is identity, 0 otherwise\n#define IS_MATRIX_IDENT(matrix)            \\\n    ( (matrix)[0][0] == (1 << 16) &&       \\\n      (matrix)[1][1] == (1 << 16) &&       \\\n      (matrix)[2][2] == (1 << 30) &&       \\\n     !(matrix)[0][1] && !(matrix)[0][2] && \\\n     !(matrix)[1][0] && !(matrix)[1][2] && \\\n     !(matrix)[2][0] && !(matrix)[2][1])\n\nstatic int mov_read_tkhd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int i, j, e;\n    int width;\n    int height;\n    int display_matrix[3][3];\n    int res_display_matrix[3][3] = { { 0 } };\n    AVStream *st;\n    MOVStreamContext *sc;\n    int version;\n    int flags;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n    sc = st->priv_data;\n\n    version = avio_r8(pb);\n    flags = avio_rb24(pb);\n    st->disposition |= (flags & MOV_TKHD_FLAG_ENABLED) ? AV_DISPOSITION_DEFAULT : 0;\n\n    if (version == 1) {\n        avio_rb64(pb);\n        avio_rb64(pb);\n    } else {\n        avio_rb32(pb); /* creation time */\n        avio_rb32(pb); /* modification time */\n    }\n    st->id = (int)avio_rb32(pb); /* track id (NOT 0 !)*/\n    avio_rb32(pb); /* reserved */\n\n    /* highlevel (considering edits) duration in movie timebase */\n    (version == 1) ? avio_rb64(pb) : avio_rb32(pb);\n    avio_rb32(pb); /* reserved */\n    avio_rb32(pb); /* reserved */\n\n    avio_rb16(pb); /* layer */\n    avio_rb16(pb); /* alternate group */\n    avio_rb16(pb); /* volume */\n    avio_rb16(pb); /* reserved */\n\n    //read in the display matrix (outlined in ISO 14496-12, Section 6.2.2)\n    // they're kept in fixed point format through all calculations\n    // save u,v,z to store the whole matrix in the AV_PKT_DATA_DISPLAYMATRIX\n    // side data, but the scale factor is not needed to calculate aspect ratio\n    for (i = 0; i < 3; i++) {\n        display_matrix[i][0] = avio_rb32(pb);   // 16.16 fixed point\n        display_matrix[i][1] = avio_rb32(pb);   // 16.16 fixed point\n        display_matrix[i][2] = avio_rb32(pb);   //  2.30 fixed point\n    }\n\n    width = avio_rb32(pb);       // 16.16 fixed point track width\n    height = avio_rb32(pb);      // 16.16 fixed point track height\n    sc->width = width >> 16;\n    sc->height = height >> 16;\n\n    // apply the moov display matrix (after the tkhd one)\n    for (i = 0; i < 3; i++) {\n        const int sh[3] = { 16, 16, 30 };\n        for (j = 0; j < 3; j++) {\n            for (e = 0; e < 3; e++) {\n                res_display_matrix[i][j] +=\n                    ((int64_t) display_matrix[i][e] *\n                     c->movie_display_matrix[e][j]) >> sh[e];\n            }\n        }\n    }\n\n    // save the matrix when it is not the default identity\n    if (!IS_MATRIX_IDENT(res_display_matrix)) {\n        double rotate;\n\n        av_freep(&sc->display_matrix);\n        sc->display_matrix = av_malloc(sizeof(int32_t) * 9);\n        if (!sc->display_matrix)\n            return AVERROR(ENOMEM);\n\n        for (i = 0; i < 3; i++)\n            for (j = 0; j < 3; j++)\n                sc->display_matrix[i * 3 + j] = res_display_matrix[i][j];\n\n#if FF_API_OLD_ROTATE_API\n        rotate = av_display_rotation_get(sc->display_matrix);\n        if (!isnan(rotate)) {\n            char rotate_buf[64];\n            rotate = -rotate;\n            if (rotate < 0) // for backward compatibility\n                rotate += 360;\n            snprintf(rotate_buf, sizeof(rotate_buf), \"%g\", rotate);\n            av_dict_set(&st->metadata, \"rotate\", rotate_buf, 0);\n        }\n#endif\n    }\n\n    // transform the display width/height according to the matrix\n    // to keep the same scale, use [width height 1<<16]\n    if (width && height && sc->display_matrix) {\n        double disp_transform[2];\n\n        for (i = 0; i < 2; i++)\n            disp_transform[i] = hypot(sc->display_matrix[0 + i],\n                                      sc->display_matrix[3 + i]);\n\n        if (disp_transform[0] > 0       && disp_transform[1] > 0 &&\n            disp_transform[0] < (1<<24) && disp_transform[1] < (1<<24) &&\n            fabs((disp_transform[0] / disp_transform[1]) - 1.0) > 0.01)\n            st->sample_aspect_ratio = av_d2q(\n                disp_transform[0] / disp_transform[1],\n                INT_MAX);\n    }\n    return 0;\n}\n\nstatic int mov_read_tfhd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVFragment *frag = &c->fragment;\n    MOVTrackExt *trex = NULL;\n    MOVFragmentIndex* index = NULL;\n    int flags, track_id, i, found = 0;\n\n    avio_r8(pb); /* version */\n    flags = avio_rb24(pb);\n\n    track_id = avio_rb32(pb);\n    if (!track_id)\n        return AVERROR_INVALIDDATA;\n    frag->track_id = track_id;\n    for (i = 0; i < c->trex_count; i++)\n        if (c->trex_data[i].track_id == frag->track_id) {\n            trex = &c->trex_data[i];\n            break;\n        }\n    if (!trex) {\n        av_log(c->fc, AV_LOG_ERROR, \"could not find corresponding trex\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    frag->base_data_offset = flags & MOV_TFHD_BASE_DATA_OFFSET ?\n                             avio_rb64(pb) : flags & MOV_TFHD_DEFAULT_BASE_IS_MOOF ?\n                             frag->moof_offset : frag->implicit_offset;\n    frag->stsd_id  = flags & MOV_TFHD_STSD_ID ? avio_rb32(pb) : trex->stsd_id;\n\n    frag->duration = flags & MOV_TFHD_DEFAULT_DURATION ?\n                     avio_rb32(pb) : trex->duration;\n    frag->size     = flags & MOV_TFHD_DEFAULT_SIZE ?\n                     avio_rb32(pb) : trex->size;\n    frag->flags    = flags & MOV_TFHD_DEFAULT_FLAGS ?\n                     avio_rb32(pb) : trex->flags;\n    frag->time     = AV_NOPTS_VALUE;\n    for (i = 0; i < c->fragment_index_count; i++) {\n        int j;\n        MOVFragmentIndex* candidate = c->fragment_index_data[i];\n        if (candidate->track_id == frag->track_id) {\n            av_log(c->fc, AV_LOG_DEBUG,\n                   \"found fragment index for track %u\\n\", frag->track_id);\n            index = candidate;\n            for (j = index->current_item; j < index->item_count; j++) {\n                if (frag->implicit_offset == index->items[j].moof_offset) {\n                    av_log(c->fc, AV_LOG_DEBUG, \"found fragment index entry \"\n                            \"for track %u and moof_offset %\"PRId64\"\\n\",\n                            frag->track_id, index->items[j].moof_offset);\n                    frag->time = index->items[j].time;\n                    index->current_item = j + 1;\n                    found = 1;\n                    break;\n                }\n            }\n            if (found)\n                break;\n        }\n    }\n    if (index && !found) {\n        av_log(c->fc, AV_LOG_DEBUG, \"track %u has a fragment index but \"\n               \"it doesn't have an (in-order) entry for moof_offset \"\n               \"%\"PRId64\"\\n\", frag->track_id, frag->implicit_offset);\n    }\n    av_log(c->fc, AV_LOG_TRACE, \"frag flags 0x%x\\n\", frag->flags);\n    return 0;\n}\n\nstatic int mov_read_chap(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    unsigned i, num;\n    void *new_tracks;\n\n    num = atom.size / 4;\n    if (!(new_tracks = av_malloc_array(num, sizeof(int))))\n        return AVERROR(ENOMEM);\n\n    av_free(c->chapter_tracks);\n    c->chapter_tracks = new_tracks;\n    c->nb_chapter_tracks = num;\n\n    for (i = 0; i < num && !pb->eof_reached; i++)\n        c->chapter_tracks[i] = avio_rb32(pb);\n\n    return 0;\n}\n\nstatic int mov_read_trex(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVTrackExt *trex;\n    int err;\n\n    if ((uint64_t)c->trex_count+1 >= UINT_MAX / sizeof(*c->trex_data))\n        return AVERROR_INVALIDDATA;\n    if ((err = av_reallocp_array(&c->trex_data, c->trex_count + 1,\n                                 sizeof(*c->trex_data))) < 0) {\n        c->trex_count = 0;\n        return err;\n    }\n\n    c->fc->duration = AV_NOPTS_VALUE; // the duration from mvhd is not representing the whole file when fragments are used.\n\n    trex = &c->trex_data[c->trex_count++];\n    avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    trex->track_id = avio_rb32(pb);\n    trex->stsd_id  = avio_rb32(pb);\n    trex->duration = avio_rb32(pb);\n    trex->size     = avio_rb32(pb);\n    trex->flags    = avio_rb32(pb);\n    return 0;\n}\n\nstatic int mov_read_tfdt(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVFragment *frag = &c->fragment;\n    AVStream *st = NULL;\n    MOVStreamContext *sc;\n    int version, i;\n\n    for (i = 0; i < c->fc->nb_streams; i++) {\n        if (c->fc->streams[i]->id == frag->track_id) {\n            st = c->fc->streams[i];\n            break;\n        }\n    }\n    if (!st) {\n        av_log(c->fc, AV_LOG_ERROR, \"could not find corresponding track id %u\\n\", frag->track_id);\n        return AVERROR_INVALIDDATA;\n    }\n    sc = st->priv_data;\n    if (sc->pseudo_stream_id + 1 != frag->stsd_id)\n        return 0;\n    version = avio_r8(pb);\n    avio_rb24(pb); /* flags */\n    if (version) {\n        sc->track_end = avio_rb64(pb);\n    } else {\n        sc->track_end = avio_rb32(pb);\n    }\n    return 0;\n}\n\nstatic int mov_read_trun(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVFragment *frag = &c->fragment;\n    AVStream *st = NULL;\n    MOVStreamContext *sc;\n    MOVStts *ctts_data;\n    uint64_t offset;\n    int64_t dts;\n    int data_offset = 0;\n    unsigned entries, first_sample_flags = frag->flags;\n    int flags, distance, i;\n\n    for (i = 0; i < c->fc->nb_streams; i++) {\n        if (c->fc->streams[i]->id == frag->track_id) {\n            st = c->fc->streams[i];\n            break;\n        }\n    }\n    if (!st) {\n        av_log(c->fc, AV_LOG_ERROR, \"could not find corresponding track id %u\\n\", frag->track_id);\n        return AVERROR_INVALIDDATA;\n    }\n    sc = st->priv_data;\n    if (sc->pseudo_stream_id+1 != frag->stsd_id && sc->pseudo_stream_id != -1)\n        return 0;\n    avio_r8(pb); /* version */\n    flags = avio_rb24(pb);\n    entries = avio_rb32(pb);\n    av_log(c->fc, AV_LOG_TRACE, \"flags 0x%x entries %u\\n\", flags, entries);\n\n    if ((uint64_t)entries+sc->ctts_count >= UINT_MAX/sizeof(*sc->ctts_data))\n        return AVERROR_INVALIDDATA;\n    if (flags & MOV_TRUN_DATA_OFFSET)        data_offset        = avio_rb32(pb);\n    if (flags & MOV_TRUN_FIRST_SAMPLE_FLAGS) first_sample_flags = avio_rb32(pb);\n    dts    = sc->track_end - sc->time_offset;\n    offset = frag->base_data_offset + data_offset;\n    distance = 0;\n    av_log(c->fc, AV_LOG_TRACE, \"first sample flags 0x%x\\n\", first_sample_flags);\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n        unsigned sample_size = frag->size;\n        int sample_flags = i ? frag->flags : first_sample_flags;\n        unsigned sample_duration = frag->duration;\n        unsigned ctts_duration = 0;\n        int keyframe = 0;\n        int ctts_index = 0;\n        int old_nb_index_entries = st->nb_index_entries;\n\n        if (flags & MOV_TRUN_SAMPLE_DURATION) sample_duration = avio_rb32(pb);\n        if (flags & MOV_TRUN_SAMPLE_SIZE)     sample_size     = avio_rb32(pb);\n        if (flags & MOV_TRUN_SAMPLE_FLAGS)    sample_flags    = avio_rb32(pb);\n        if (flags & MOV_TRUN_SAMPLE_CTS)      ctts_duration   = avio_rb32(pb);\n\n        mov_update_dts_shift(sc, ctts_duration);\n        if (frag->time != AV_NOPTS_VALUE) {\n            if (c->use_mfra_for == FF_MOV_FLAG_MFRA_PTS) {\n                int64_t pts = frag->time;\n                av_log(c->fc, AV_LOG_DEBUG, \"found frag time %\"PRId64\n                        \" sc->dts_shift %d ctts.duration %d\"\n                        \" sc->time_offset %\"PRId64\" flags & MOV_TRUN_SAMPLE_CTS %d\\n\", pts,\n                        sc->dts_shift, ctts_duration,\n                        sc->time_offset, flags & MOV_TRUN_SAMPLE_CTS);\n                dts = pts - sc->dts_shift;\n                if (flags & MOV_TRUN_SAMPLE_CTS) {\n                    dts -= ctts_duration;\n                } else {\n                    dts -= sc->time_offset;\n                }\n                av_log(c->fc, AV_LOG_DEBUG, \"calculated into dts %\"PRId64\"\\n\", dts);\n            } else {\n                dts = frag->time - sc->time_offset;\n                av_log(c->fc, AV_LOG_DEBUG, \"found frag time %\"PRId64\n                        \", using it for dts\\n\", dts);\n            }\n            frag->time = AV_NOPTS_VALUE;\n        }\n\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO)\n            keyframe = 1;\n        else\n            keyframe =\n                !(sample_flags & (MOV_FRAG_SAMPLE_FLAG_IS_NON_SYNC |\n                                  MOV_FRAG_SAMPLE_FLAG_DEPENDS_YES));\n        if (keyframe)\n            distance = 0;\n        ctts_index = av_add_index_entry(st, offset, dts, sample_size, distance,\n                                        keyframe ? AVINDEX_KEYFRAME : 0);\n        if (ctts_index >= 0 && old_nb_index_entries < st->nb_index_entries) {\n            unsigned int size_needed = st->nb_index_entries * sizeof(*sc->ctts_data);\n            unsigned int request_size = size_needed > sc->ctts_allocated_size ?\n                FFMAX(size_needed, 2 * sc->ctts_allocated_size) : size_needed;\n            unsigned int old_ctts_size = sc->ctts_allocated_size;\n            ctts_data = av_fast_realloc(sc->ctts_data, &sc->ctts_allocated_size, request_size);\n            if (!ctts_data) {\n                av_freep(&sc->ctts_data);\n                return AVERROR(ENOMEM);\n            }\n            sc->ctts_data = ctts_data;\n\n            // In case there were samples without ctts entries, ensure they get\n            // zero valued entries. This ensures clips which mix boxes with and\n            // without ctts entries don't pickup uninitialized data.\n            memset((uint8_t*)(sc->ctts_data) + old_ctts_size, 0, sc->ctts_allocated_size - old_ctts_size);\n\n            if (ctts_index != old_nb_index_entries) {\n                memmove(sc->ctts_data + ctts_index + 1, sc->ctts_data + ctts_index,\n                        sizeof(*sc->ctts_data) * (sc->ctts_count - ctts_index));\n                if (ctts_index <= sc->current_sample) {\n                    // if we inserted a new item before the current sample, move the\n                    // counter ahead so it is still pointing to the same sample.\n                    sc->current_sample++;\n                }\n            }\n\n            sc->ctts_data[ctts_index].count = 1;\n            sc->ctts_data[ctts_index].duration = ctts_duration;\n            sc->ctts_count++;\n        } else {\n            av_log(c->fc, AV_LOG_ERROR, \"Failed to add index entry\\n\");\n        }\n\n        av_log(c->fc, AV_LOG_TRACE, \"AVIndex stream %d, sample %d, offset %\"PRIx64\", dts %\"PRId64\", \"\n                \"size %u, distance %d, keyframe %d\\n\", st->index, ctts_index,\n                offset, dts, sample_size, distance, keyframe);\n        distance++;\n        dts += sample_duration;\n        offset += sample_size;\n        sc->data_size += sample_size;\n        sc->duration_for_fps += sample_duration;\n        sc->nb_frames_for_fps ++;\n    }\n\n    if (pb->eof_reached)\n        return AVERROR_EOF;\n\n    frag->implicit_offset = offset;\n\n    sc->track_end = dts + sc->time_offset;\n    if (st->duration < sc->track_end)\n        st->duration = sc->track_end;\n\n    return 0;\n}\n\nstatic int mov_read_sidx(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int64_t offset = avio_tell(pb) + atom.size, pts;\n    uint8_t version;\n    unsigned i, track_id;\n    AVStream *st = NULL;\n    AVStream *ref_st = NULL;\n    MOVStreamContext *sc, *ref_sc = NULL;\n    MOVFragmentIndex *index = NULL;\n    MOVFragmentIndex **tmp;\n    AVRational timescale;\n\n    version = avio_r8(pb);\n    if (version > 1) {\n        avpriv_request_sample(c->fc, \"sidx version %u\", version);\n        return 0;\n    }\n\n    avio_rb24(pb); // flags\n\n    track_id = avio_rb32(pb); // Reference ID\n    for (i = 0; i < c->fc->nb_streams; i++) {\n        if (c->fc->streams[i]->id == track_id) {\n            st = c->fc->streams[i];\n            break;\n        }\n    }\n    if (!st) {\n        av_log(c->fc, AV_LOG_WARNING, \"could not find corresponding track id %d\\n\", track_id);\n        return 0;\n    }\n\n    sc = st->priv_data;\n\n    timescale = av_make_q(1, avio_rb32(pb));\n\n    if (timescale.den <= 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"Invalid sidx timescale 1/%d\\n\", timescale.den);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (version == 0) {\n        pts = avio_rb32(pb);\n        offset += avio_rb32(pb);\n    } else {\n        pts = avio_rb64(pb);\n        offset += avio_rb64(pb);\n    }\n\n    avio_rb16(pb); // reserved\n\n    index = av_mallocz(sizeof(MOVFragmentIndex));\n    if (!index)\n        return AVERROR(ENOMEM);\n\n    index->track_id = track_id;\n\n    index->item_count = avio_rb16(pb);\n    index->items = av_mallocz_array(index->item_count, sizeof(MOVFragmentIndexItem));\n\n    if (!index->items) {\n        av_freep(&index);\n        return AVERROR(ENOMEM);\n    }\n\n    for (i = 0; i < index->item_count; i++) {\n        uint32_t size = avio_rb32(pb);\n        uint32_t duration = avio_rb32(pb);\n        if (size & 0x80000000) {\n            avpriv_request_sample(c->fc, \"sidx reference_type 1\");\n            av_freep(&index->items);\n            av_freep(&index);\n            return AVERROR_PATCHWELCOME;\n        }\n        avio_rb32(pb); // sap_flags\n        index->items[i].moof_offset = offset;\n        index->items[i].time = av_rescale_q(pts, st->time_base, timescale);\n        offset += size;\n        pts += duration;\n    }\n\n    st->duration = sc->track_end = pts;\n\n    tmp = av_realloc_array(c->fragment_index_data,\n                           c->fragment_index_count + 1,\n                           sizeof(MOVFragmentIndex*));\n    if (!tmp) {\n        av_freep(&index->items);\n        av_freep(&index);\n        return AVERROR(ENOMEM);\n    }\n\n    c->fragment_index_data = tmp;\n    c->fragment_index_data[c->fragment_index_count++] = index;\n    sc->has_sidx = 1;\n\n    if (offset == avio_size(pb)) {\n        for (i = 0; i < c->fc->nb_streams; i++) {\n            if (c->fc->streams[i]->id == c->fragment_index_data[0]->track_id) {\n                ref_st = c->fc->streams[i];\n                ref_sc = ref_st->priv_data;\n                break;\n            }\n        }\n        for (i = 0; i < c->fc->nb_streams; i++) {\n            st = c->fc->streams[i];\n            sc = st->priv_data;\n            if (!sc->has_sidx) {\n                st->duration = sc->track_end = av_rescale(ref_st->duration, sc->time_scale, ref_sc->time_scale);\n            }\n        }\n\n        c->fragment_index_complete = 1;\n    }\n\n    return 0;\n}\n\n/* this atom should be null (from specs), but some buggy files put the 'moov' atom inside it... */\n/* like the files created with Adobe Premiere 5.0, for samples see */\n/* http://graphics.tudelft.nl/~wouter/publications/soundtests/ */\nstatic int mov_read_wide(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int err;\n\n    if (atom.size < 8)\n        return 0; /* continue */\n    if (avio_rb32(pb) != 0) { /* 0 sized mdat atom... use the 'wide' atom size */\n        avio_skip(pb, atom.size - 4);\n        return 0;\n    }\n    atom.type = avio_rl32(pb);\n    atom.size -= 8;\n    if (atom.type != MKTAG('m','d','a','t')) {\n        avio_skip(pb, atom.size);\n        return 0;\n    }\n    err = mov_read_mdat(c, pb, atom);\n    return err;\n}\n\nstatic int mov_read_cmov(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n#if CONFIG_ZLIB\n    AVIOContext ctx;\n    uint8_t *cmov_data;\n    uint8_t *moov_data; /* uncompressed data */\n    long cmov_len, moov_len;\n    int ret = -1;\n\n    avio_rb32(pb); /* dcom atom */\n    if (avio_rl32(pb) != MKTAG('d','c','o','m'))\n        return AVERROR_INVALIDDATA;\n    if (avio_rl32(pb) != MKTAG('z','l','i','b')) {\n        av_log(c->fc, AV_LOG_ERROR, \"unknown compression for cmov atom !\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    avio_rb32(pb); /* cmvd atom */\n    if (avio_rl32(pb) != MKTAG('c','m','v','d'))\n        return AVERROR_INVALIDDATA;\n    moov_len = avio_rb32(pb); /* uncompressed size */\n    cmov_len = atom.size - 6 * 4;\n\n    cmov_data = av_malloc(cmov_len);\n    if (!cmov_data)\n        return AVERROR(ENOMEM);\n    moov_data = av_malloc(moov_len);\n    if (!moov_data) {\n        av_free(cmov_data);\n        return AVERROR(ENOMEM);\n    }\n    ret = ffio_read_size(pb, cmov_data, cmov_len);\n    if (ret < 0)\n        goto free_and_return;\n\n    if (uncompress (moov_data, (uLongf *) &moov_len, (const Bytef *)cmov_data, cmov_len) != Z_OK)\n        goto free_and_return;\n    if (ffio_init_context(&ctx, moov_data, moov_len, 0, NULL, NULL, NULL, NULL) != 0)\n        goto free_and_return;\n    ctx.seekable = AVIO_SEEKABLE_NORMAL;\n    atom.type = MKTAG('m','o','o','v');\n    atom.size = moov_len;\n    ret = mov_read_default(c, &ctx, atom);\nfree_and_return:\n    av_free(moov_data);\n    av_free(cmov_data);\n    return ret;\n#else\n    av_log(c->fc, AV_LOG_ERROR, \"this file requires zlib support compiled in\\n\");\n    return AVERROR(ENOSYS);\n#endif\n}\n\n/* edit list atom */\nstatic int mov_read_elst(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVStreamContext *sc;\n    int i, edit_count, version;\n\n    if (c->fc->nb_streams < 1 || c->ignore_editlist)\n        return 0;\n    sc = c->fc->streams[c->fc->nb_streams-1]->priv_data;\n\n    version = avio_r8(pb); /* version */\n    avio_rb24(pb); /* flags */\n    edit_count = avio_rb32(pb); /* entries */\n\n    if (!edit_count)\n        return 0;\n    if (sc->elst_data)\n        av_log(c->fc, AV_LOG_WARNING, \"Duplicated ELST atom\\n\");\n    av_free(sc->elst_data);\n    sc->elst_count = 0;\n    sc->elst_data = av_malloc_array(edit_count, sizeof(*sc->elst_data));\n    if (!sc->elst_data)\n        return AVERROR(ENOMEM);\n\n    av_log(c->fc, AV_LOG_TRACE, \"track[%u].edit_count = %i\\n\", c->fc->nb_streams - 1, edit_count);\n    for (i = 0; i < edit_count && !pb->eof_reached; i++) {\n        MOVElst *e = &sc->elst_data[i];\n\n        if (version == 1) {\n            e->duration = avio_rb64(pb);\n            e->time     = avio_rb64(pb);\n        } else {\n            e->duration = avio_rb32(pb); /* segment duration */\n            e->time     = (int32_t)avio_rb32(pb); /* media time */\n        }\n        e->rate = avio_rb32(pb) / 65536.0;\n        av_log(c->fc, AV_LOG_TRACE, \"duration=%\"PRId64\" time=%\"PRId64\" rate=%f\\n\",\n               e->duration, e->time, e->rate);\n\n        if (e->time < 0 && e->time != -1 &&\n            c->fc->strict_std_compliance >= FF_COMPLIANCE_STRICT) {\n            av_log(c->fc, AV_LOG_ERROR, \"Track %d, edit %d: Invalid edit list media time=%\"PRId64\"\\n\",\n                   c->fc->nb_streams-1, i, e->time);\n            return AVERROR_INVALIDDATA;\n        }\n    }\n    sc->elst_count = i;\n\n    return 0;\n}\n\nstatic int mov_read_tmcd(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVStreamContext *sc;\n\n    if (c->fc->nb_streams < 1)\n        return AVERROR_INVALIDDATA;\n    sc = c->fc->streams[c->fc->nb_streams - 1]->priv_data;\n    sc->timecode_track = avio_rb32(pb);\n    return 0;\n}\n\nstatic int mov_read_vpcc(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int version, color_range, color_primaries, color_trc, color_space;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams - 1];\n\n    if (atom.size < 5) {\n        av_log(c->fc, AV_LOG_ERROR, \"Empty VP Codec Configuration box\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    version = avio_r8(pb);\n    if (version != 1) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unsupported VP Codec Configuration box version %d\\n\", version);\n        return 0;\n    }\n    avio_skip(pb, 3); /* flags */\n\n    avio_skip(pb, 2); /* profile + level */\n    color_range     = avio_r8(pb); /* bitDepth, chromaSubsampling, videoFullRangeFlag */\n    color_primaries = avio_r8(pb);\n    color_trc       = avio_r8(pb);\n    color_space     = avio_r8(pb);\n    if (avio_rb16(pb)) /* codecIntializationDataSize */\n        return AVERROR_INVALIDDATA;\n\n    if (!av_color_primaries_name(color_primaries))\n        color_primaries = AVCOL_PRI_UNSPECIFIED;\n    if (!av_color_transfer_name(color_trc))\n        color_trc = AVCOL_TRC_UNSPECIFIED;\n    if (!av_color_space_name(color_space))\n        color_space = AVCOL_SPC_UNSPECIFIED;\n\n    st->codecpar->color_range     = (color_range & 1) ? AVCOL_RANGE_JPEG : AVCOL_RANGE_MPEG;\n    st->codecpar->color_primaries = color_primaries;\n    st->codecpar->color_trc       = color_trc;\n    st->codecpar->color_space     = color_space;\n\n    return 0;\n}\n\nstatic int mov_read_smdm(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVStreamContext *sc;\n    const int chroma_den = 50000;\n    const int luma_den = 10000;\n    int i, j, version;\n\n    if (c->fc->nb_streams < 1)\n        return AVERROR_INVALIDDATA;\n\n    sc = c->fc->streams[c->fc->nb_streams - 1]->priv_data;\n\n    if (atom.size < 5) {\n        av_log(c->fc, AV_LOG_ERROR, \"Empty Mastering Display Metadata box\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    version = avio_r8(pb);\n    if (version) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unsupported Mastering Display Metadata box version %d\\n\", version);\n        return 0;\n    }\n    avio_skip(pb, 3); /* flags */\n\n    sc->mastering = av_mastering_display_metadata_alloc();\n    if (!sc->mastering)\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < 3; i++)\n        for (j = 0; j < 2; j++)\n            sc->mastering->display_primaries[i][j] =\n                av_make_q(lrint(((double)avio_rb16(pb) / (1 << 16)) * chroma_den), chroma_den);\n    for (i = 0; i < 2; i++)\n        sc->mastering->white_point[i] =\n            av_make_q(lrint(((double)avio_rb16(pb) / (1 << 16)) * chroma_den), chroma_den);\n    sc->mastering->max_luminance =\n        av_make_q(lrint(((double)avio_rb32(pb) / (1 <<  8)) * luma_den), luma_den);\n    sc->mastering->min_luminance =\n        av_make_q(lrint(((double)avio_rb32(pb) / (1 << 14)) * luma_den), luma_den);\n\n    sc->mastering->has_primaries = 1;\n    sc->mastering->has_luminance = 1;\n\n    return 0;\n}\n\nstatic int mov_read_coll(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    MOVStreamContext *sc;\n    int version;\n\n    if (c->fc->nb_streams < 1)\n        return AVERROR_INVALIDDATA;\n\n    sc = c->fc->streams[c->fc->nb_streams - 1]->priv_data;\n\n    if (atom.size < 5) {\n        av_log(c->fc, AV_LOG_ERROR, \"Empty Content Light Level box\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    version = avio_r8(pb);\n    if (version) {\n        av_log(c->fc, AV_LOG_WARNING, \"Unsupported Content Light Level box version %d\\n\", version);\n        return 0;\n    }\n    avio_skip(pb, 3); /* flags */\n\n    sc->coll = av_content_light_metadata_alloc(&sc->coll_size);\n    if (!sc->coll)\n        return AVERROR(ENOMEM);\n\n    sc->coll->MaxCLL  = avio_rb16(pb);\n    sc->coll->MaxFALL = avio_rb16(pb);\n\n    return 0;\n}\n\nstatic int mov_read_st3d(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    enum AVStereo3DType type;\n    int mode;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    sc = st->priv_data;\n\n    if (atom.size < 5) {\n        av_log(c->fc, AV_LOG_ERROR, \"Empty stereoscopic video box\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    avio_skip(pb, 4); /* version + flags */\n\n    mode = avio_r8(pb);\n    switch (mode) {\n    case 0:\n        type = AV_STEREO3D_2D;\n        break;\n    case 1:\n        type = AV_STEREO3D_TOPBOTTOM;\n        break;\n    case 2:\n        type = AV_STEREO3D_SIDEBYSIDE;\n        break;\n    default:\n        av_log(c->fc, AV_LOG_WARNING, \"Unknown st3d mode value %d\\n\", mode);\n        return 0;\n    }\n\n    sc->stereo3d = av_stereo3d_alloc();\n    if (!sc->stereo3d)\n        return AVERROR(ENOMEM);\n\n    sc->stereo3d->type = type;\n    return 0;\n}\n\nstatic int mov_read_sv3d(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int size, layout;\n    int32_t yaw, pitch, roll;\n    uint32_t l = 0, t = 0, r = 0, b = 0;\n    uint32_t tag, padding = 0;\n    enum AVSphericalProjection projection;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    sc = st->priv_data;\n\n    if (atom.size < 8) {\n        av_log(c->fc, AV_LOG_ERROR, \"Empty spherical video box\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    size = avio_rb32(pb);\n    if (size <= 12 || size > atom.size)\n        return AVERROR_INVALIDDATA;\n\n    tag = avio_rl32(pb);\n    if (tag != MKTAG('s','v','h','d')) {\n        av_log(c->fc, AV_LOG_ERROR, \"Missing spherical video header\\n\");\n        return 0;\n    }\n    avio_skip(pb, 4); /*  version + flags */\n    avio_skip(pb, size - 12); /* metadata_source */\n\n    size = avio_rb32(pb);\n    if (size > atom.size)\n        return AVERROR_INVALIDDATA;\n\n    tag = avio_rl32(pb);\n    if (tag != MKTAG('p','r','o','j')) {\n        av_log(c->fc, AV_LOG_ERROR, \"Missing projection box\\n\");\n        return 0;\n    }\n\n    size = avio_rb32(pb);\n    if (size > atom.size)\n        return AVERROR_INVALIDDATA;\n\n    tag = avio_rl32(pb);\n    if (tag != MKTAG('p','r','h','d')) {\n        av_log(c->fc, AV_LOG_ERROR, \"Missing projection header box\\n\");\n        return 0;\n    }\n    avio_skip(pb, 4); /*  version + flags */\n\n    /* 16.16 fixed point */\n    yaw   = avio_rb32(pb);\n    pitch = avio_rb32(pb);\n    roll  = avio_rb32(pb);\n\n    size = avio_rb32(pb);\n    if (size > atom.size)\n        return AVERROR_INVALIDDATA;\n\n    tag = avio_rl32(pb);\n    avio_skip(pb, 4); /*  version + flags */\n    switch (tag) {\n    case MKTAG('c','b','m','p'):\n        layout = avio_rb32(pb);\n        if (layout) {\n            av_log(c->fc, AV_LOG_WARNING,\n                   \"Unsupported cubemap layout %d\\n\", layout);\n            return 0;\n        }\n        projection = AV_SPHERICAL_CUBEMAP;\n        padding = avio_rb32(pb);\n        break;\n    case MKTAG('e','q','u','i'):\n        t = avio_rb32(pb);\n        b = avio_rb32(pb);\n        l = avio_rb32(pb);\n        r = avio_rb32(pb);\n\n        if (b >= UINT_MAX - t || r >= UINT_MAX - l) {\n            av_log(c->fc, AV_LOG_ERROR,\n                   \"Invalid bounding rectangle coordinates \"\n                   \"%\"PRIu32\",%\"PRIu32\",%\"PRIu32\",%\"PRIu32\"\\n\", l, t, r, b);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (l || t || r || b)\n            projection = AV_SPHERICAL_EQUIRECTANGULAR_TILE;\n        else\n            projection = AV_SPHERICAL_EQUIRECTANGULAR;\n        break;\n    default:\n        av_log(c->fc, AV_LOG_ERROR, \"Unknown projection type\\n\");\n        return 0;\n    }\n\n    sc->spherical = av_spherical_alloc(&sc->spherical_size);\n    if (!sc->spherical)\n        return AVERROR(ENOMEM);\n\n    sc->spherical->projection = projection;\n\n    sc->spherical->yaw   = yaw;\n    sc->spherical->pitch = pitch;\n    sc->spherical->roll  = roll;\n\n    sc->spherical->padding = padding;\n\n    sc->spherical->bound_left   = l;\n    sc->spherical->bound_top    = t;\n    sc->spherical->bound_right  = r;\n    sc->spherical->bound_bottom = b;\n\n    return 0;\n}\n\nstatic int mov_parse_uuid_spherical(MOVStreamContext *sc, AVIOContext *pb, size_t len)\n{\n    int ret = 0;\n    uint8_t *buffer = av_malloc(len + 1);\n    const char *val;\n\n    if (!buffer)\n        return AVERROR(ENOMEM);\n    buffer[len] = '\\0';\n\n    ret = ffio_read_size(pb, buffer, len);\n    if (ret < 0)\n        goto out;\n\n    /* Check for mandatory keys and values, try to support XML as best-effort */\n    if (av_stristr(buffer, \"<GSpherical:StitchingSoftware>\") &&\n        (val = av_stristr(buffer, \"<GSpherical:Spherical>\")) &&\n        av_stristr(val, \"true\") &&\n        (val = av_stristr(buffer, \"<GSpherical:Stitched>\")) &&\n        av_stristr(val, \"true\") &&\n        (val = av_stristr(buffer, \"<GSpherical:ProjectionType>\")) &&\n        av_stristr(val, \"equirectangular\")) {\n        sc->spherical = av_spherical_alloc(&sc->spherical_size);\n        if (!sc->spherical)\n            goto out;\n\n        sc->spherical->projection = AV_SPHERICAL_EQUIRECTANGULAR;\n\n        if (av_stristr(buffer, \"<GSpherical:StereoMode>\")) {\n            enum AVStereo3DType mode;\n\n            if (av_stristr(buffer, \"left-right\"))\n                mode = AV_STEREO3D_SIDEBYSIDE;\n            else if (av_stristr(buffer, \"top-bottom\"))\n                mode = AV_STEREO3D_TOPBOTTOM;\n            else\n                mode = AV_STEREO3D_2D;\n\n            sc->stereo3d = av_stereo3d_alloc();\n            if (!sc->stereo3d)\n                goto out;\n\n            sc->stereo3d->type = mode;\n        }\n\n        /* orientation */\n        val = av_stristr(buffer, \"<GSpherical:InitialViewHeadingDegrees>\");\n        if (val)\n            sc->spherical->yaw = strtol(val, NULL, 10) * (1 << 16);\n        val = av_stristr(buffer, \"<GSpherical:InitialViewPitchDegrees>\");\n        if (val)\n            sc->spherical->pitch = strtol(val, NULL, 10) * (1 << 16);\n        val = av_stristr(buffer, \"<GSpherical:InitialViewRollDegrees>\");\n        if (val)\n            sc->spherical->roll = strtol(val, NULL, 10) * (1 << 16);\n    }\n\nout:\n    av_free(buffer);\n    return ret;\n}\n\nstatic int mov_read_uuid(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    int64_t ret;\n    uint8_t uuid[16];\n    static const uint8_t uuid_isml_manifest[] = {\n        0xa5, 0xd4, 0x0b, 0x30, 0xe8, 0x14, 0x11, 0xdd,\n        0xba, 0x2f, 0x08, 0x00, 0x20, 0x0c, 0x9a, 0x66\n    };\n    static const uint8_t uuid_xmp[] = {\n        0xbe, 0x7a, 0xcf, 0xcb, 0x97, 0xa9, 0x42, 0xe8,\n        0x9c, 0x71, 0x99, 0x94, 0x91, 0xe3, 0xaf, 0xac\n    };\n    static const uint8_t uuid_spherical[] = {\n        0xff, 0xcc, 0x82, 0x63, 0xf8, 0x55, 0x4a, 0x93,\n        0x88, 0x14, 0x58, 0x7a, 0x02, 0x52, 0x1f, 0xdd,\n    };\n\n    if (atom.size < sizeof(uuid) || atom.size >= FFMIN(INT_MAX, SIZE_MAX))\n        return AVERROR_INVALIDDATA;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    sc = st->priv_data;\n\n    ret = avio_read(pb, uuid, sizeof(uuid));\n    if (ret < 0) {\n        return ret;\n    } else if (ret != sizeof(uuid)) {\n        return AVERROR_INVALIDDATA;\n    }\n    if (!memcmp(uuid, uuid_isml_manifest, sizeof(uuid))) {\n        uint8_t *buffer, *ptr;\n        char *endptr;\n        size_t len = atom.size - sizeof(uuid);\n\n        if (len < 4) {\n            return AVERROR_INVALIDDATA;\n        }\n        ret = avio_skip(pb, 4); // zeroes\n        len -= 4;\n\n        buffer = av_mallocz(len + 1);\n        if (!buffer) {\n            return AVERROR(ENOMEM);\n        }\n        ret = avio_read(pb, buffer, len);\n        if (ret < 0) {\n            av_free(buffer);\n            return ret;\n        } else if (ret != len) {\n            av_free(buffer);\n            return AVERROR_INVALIDDATA;\n        }\n\n        ptr = buffer;\n        while ((ptr = av_stristr(ptr, \"systemBitrate=\\\"\"))) {\n            ptr += sizeof(\"systemBitrate=\\\"\") - 1;\n            c->bitrates_count++;\n            c->bitrates = av_realloc_f(c->bitrates, c->bitrates_count, sizeof(*c->bitrates));\n            if (!c->bitrates) {\n                c->bitrates_count = 0;\n                av_free(buffer);\n                return AVERROR(ENOMEM);\n            }\n            errno = 0;\n            ret = strtol(ptr, &endptr, 10);\n            if (ret < 0 || errno || *endptr != '\"') {\n                c->bitrates[c->bitrates_count - 1] = 0;\n            } else {\n                c->bitrates[c->bitrates_count - 1] = ret;\n            }\n        }\n\n        av_free(buffer);\n    } else if (!memcmp(uuid, uuid_xmp, sizeof(uuid))) {\n        uint8_t *buffer;\n        size_t len = atom.size - sizeof(uuid);\n        if (c->export_xmp) {\n            buffer = av_mallocz(len + 1);\n            if (!buffer) {\n                return AVERROR(ENOMEM);\n            }\n            ret = avio_read(pb, buffer, len);\n            if (ret < 0) {\n                av_free(buffer);\n                return ret;\n            } else if (ret != len) {\n                av_free(buffer);\n                return AVERROR_INVALIDDATA;\n            }\n            buffer[len] = '\\0';\n            av_dict_set(&c->fc->metadata, \"xmp\", buffer, 0);\n            av_free(buffer);\n        } else {\n            // skip all uuid atom, which makes it fast for long uuid-xmp file\n            ret = avio_skip(pb, len);\n            if (ret < 0)\n                return ret;\n        }\n    } else if (!memcmp(uuid, uuid_spherical, sizeof(uuid))) {\n        size_t len = atom.size - sizeof(uuid);\n        ret = mov_parse_uuid_spherical(sc, pb, len);\n        if (ret < 0)\n            return ret;\n        if (!sc->spherical)\n            av_log(c->fc, AV_LOG_WARNING, \"Invalid spherical metadata found\\n\");    }\n\n    return 0;\n}\n\nstatic int mov_read_free(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int ret;\n    uint8_t content[16];\n\n    if (atom.size < 8)\n        return 0;\n\n    ret = avio_read(pb, content, FFMIN(sizeof(content), atom.size));\n    if (ret < 0)\n        return ret;\n\n    if (   !c->found_moov\n        && !c->found_mdat\n        && !memcmp(content, \"Anevia\\x1A\\x1A\", 8)\n        && c->use_mfra_for == FF_MOV_FLAG_MFRA_AUTO) {\n        c->use_mfra_for = FF_MOV_FLAG_MFRA_PTS;\n    }\n\n    return 0;\n}\n\nstatic int mov_read_frma(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    uint32_t format = avio_rl32(pb);\n    MOVStreamContext *sc;\n    enum AVCodecID id;\n    AVStream *st;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    sc = st->priv_data;\n\n    switch (sc->format)\n    {\n    case MKTAG('e','n','c','v'):        // encrypted video\n    case MKTAG('e','n','c','a'):        // encrypted audio\n        id = mov_codec_id(st, format);\n        if (st->codecpar->codec_id != AV_CODEC_ID_NONE &&\n            st->codecpar->codec_id != id) {\n            av_log(c->fc, AV_LOG_WARNING,\n                   \"ignoring 'frma' atom of '%.4s', stream has codec id %d\\n\",\n                   (char*)&format, st->codecpar->codec_id);\n            break;\n        }\n\n        st->codecpar->codec_id = id;\n        sc->format = format;\n        break;\n\n    default:\n        if (format != sc->format) {\n            av_log(c->fc, AV_LOG_WARNING,\n                   \"ignoring 'frma' atom of '%.4s', stream format is '%.4s'\\n\",\n                   (char*)&format, (char*)&sc->format);\n        }\n        break;\n    }\n\n    return 0;\n}\n\nstatic int mov_read_senc(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    size_t auxiliary_info_size;\n\n    if (c->decryption_key_len == 0 || c->fc->nb_streams < 1)\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    sc = st->priv_data;\n\n    if (sc->cenc.aes_ctr) {\n        av_log(c->fc, AV_LOG_ERROR, \"duplicate senc atom\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    avio_r8(pb); /* version */\n    sc->cenc.use_subsamples = avio_rb24(pb) & 0x02; /* flags */\n\n    avio_rb32(pb);        /* entries */\n\n    if (atom.size < 8 || atom.size > FFMIN(INT_MAX, SIZE_MAX)) {\n        av_log(c->fc, AV_LOG_ERROR, \"senc atom size %\"PRId64\" invalid\\n\", atom.size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* save the auxiliary info as is */\n    auxiliary_info_size = atom.size - 8;\n\n    sc->cenc.auxiliary_info = av_malloc(auxiliary_info_size);\n    if (!sc->cenc.auxiliary_info) {\n        return AVERROR(ENOMEM);\n    }\n\n    sc->cenc.auxiliary_info_end = sc->cenc.auxiliary_info + auxiliary_info_size;\n    sc->cenc.auxiliary_info_pos = sc->cenc.auxiliary_info;\n    sc->cenc.auxiliary_info_index = 0;\n\n    if (avio_read(pb, sc->cenc.auxiliary_info, auxiliary_info_size) != auxiliary_info_size) {\n        av_log(c->fc, AV_LOG_ERROR, \"failed to read the auxiliary info\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* initialize the cipher */\n    sc->cenc.aes_ctr = av_aes_ctr_alloc();\n    if (!sc->cenc.aes_ctr) {\n        return AVERROR(ENOMEM);\n    }\n\n    return av_aes_ctr_init(sc->cenc.aes_ctr, c->decryption_key);\n}\n\nstatic int mov_read_saiz(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    MOVStreamContext *sc;\n    size_t data_size;\n    int atom_header_size;\n    int flags;\n\n    if (c->decryption_key_len == 0 || c->fc->nb_streams < 1)\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams - 1];\n    sc = st->priv_data;\n\n    if (sc->cenc.auxiliary_info_sizes || sc->cenc.auxiliary_info_default_size) {\n        av_log(c->fc, AV_LOG_ERROR, \"duplicate saiz atom\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    atom_header_size = 9;\n\n    avio_r8(pb); /* version */\n    flags = avio_rb24(pb);\n\n    if ((flags & 0x01) != 0) {\n        atom_header_size += 8;\n\n        avio_rb32(pb);    /* info type */\n        avio_rb32(pb);    /* info type param */\n    }\n\n    sc->cenc.auxiliary_info_default_size = avio_r8(pb);\n    avio_rb32(pb);    /* entries */\n\n    if (atom.size <= atom_header_size) {\n        return 0;\n    }\n\n    if (atom.size > FFMIN(INT_MAX, SIZE_MAX)) {\n        av_log(c->fc, AV_LOG_ERROR, \"saiz atom auxiliary_info_sizes size %\"PRId64\" invalid\\n\", atom.size);\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* save the auxiliary info sizes as is */\n    data_size = atom.size - atom_header_size;\n\n    sc->cenc.auxiliary_info_sizes = av_malloc(data_size);\n    if (!sc->cenc.auxiliary_info_sizes) {\n        return AVERROR(ENOMEM);\n    }\n\n    sc->cenc.auxiliary_info_sizes_count = data_size;\n\n    if (avio_read(pb, sc->cenc.auxiliary_info_sizes, data_size) != data_size) {\n        av_log(c->fc, AV_LOG_ERROR, \"failed to read the auxiliary info sizes\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    return 0;\n}\n\nstatic int mov_read_dfla(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    AVStream *st;\n    int last, type, size, ret;\n    uint8_t buf[4];\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if ((uint64_t)atom.size > (1<<30) || atom.size < 42)\n        return AVERROR_INVALIDDATA;\n\n    /* Check FlacSpecificBox version. */\n    if (avio_r8(pb) != 0)\n        return AVERROR_INVALIDDATA;\n\n    avio_rb24(pb); /* Flags */\n\n    avio_read(pb, buf, sizeof(buf));\n    flac_parse_block_header(buf, &last, &type, &size);\n\n    if (type != FLAC_METADATA_TYPE_STREAMINFO || size != FLAC_STREAMINFO_SIZE) {\n        av_log(c->fc, AV_LOG_ERROR, \"STREAMINFO must be first FLACMetadataBlock\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    ret = ff_get_extradata(c->fc, st->codecpar, pb, size);\n    if (ret < 0)\n        return ret;\n\n    if (!last)\n        av_log(c->fc, AV_LOG_WARNING, \"non-STREAMINFO FLACMetadataBlock(s) ignored\\n\");\n\n    return 0;\n}\n\nstatic int mov_seek_auxiliary_info(MOVContext *c, MOVStreamContext *sc, int64_t index)\n{\n    size_t auxiliary_info_seek_offset = 0;\n    int i;\n\n    if (sc->cenc.auxiliary_info_default_size) {\n        auxiliary_info_seek_offset = (size_t)sc->cenc.auxiliary_info_default_size * index;\n    } else if (sc->cenc.auxiliary_info_sizes) {\n        if (index > sc->cenc.auxiliary_info_sizes_count) {\n            av_log(c, AV_LOG_ERROR, \"current sample %\"PRId64\" greater than the number of auxiliary info sample sizes %\"SIZE_SPECIFIER\"\\n\",\n                index, sc->cenc.auxiliary_info_sizes_count);\n            return AVERROR_INVALIDDATA;\n        }\n\n        for (i = 0; i < index; i++) {\n            auxiliary_info_seek_offset += sc->cenc.auxiliary_info_sizes[i];\n        }\n    }\n\n    if (auxiliary_info_seek_offset > sc->cenc.auxiliary_info_end - sc->cenc.auxiliary_info) {\n        av_log(c, AV_LOG_ERROR, \"auxiliary info offset %\"SIZE_SPECIFIER\" greater than auxiliary info size %\"SIZE_SPECIFIER\"\\n\",\n            auxiliary_info_seek_offset, (size_t)(sc->cenc.auxiliary_info_end - sc->cenc.auxiliary_info));\n        return AVERROR_INVALIDDATA;\n    }\n\n    sc->cenc.auxiliary_info_pos = sc->cenc.auxiliary_info + auxiliary_info_seek_offset;\n    sc->cenc.auxiliary_info_index = index;\n    return 0;\n}\n\nstatic int cenc_filter(MOVContext *c, MOVStreamContext *sc, int64_t index, uint8_t *input, int size)\n{\n    uint32_t encrypted_bytes;\n    uint16_t subsample_count;\n    uint16_t clear_bytes;\n    uint8_t* input_end = input + size;\n    int ret;\n\n    if (index != sc->cenc.auxiliary_info_index) {\n        ret = mov_seek_auxiliary_info(c, sc, index);\n        if (ret < 0) {\n            return ret;\n        }\n    }\n\n    /* read the iv */\n    if (AES_CTR_IV_SIZE > sc->cenc.auxiliary_info_end - sc->cenc.auxiliary_info_pos) {\n        av_log(c->fc, AV_LOG_ERROR, \"failed to read iv from the auxiliary info\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    av_aes_ctr_set_iv(sc->cenc.aes_ctr, sc->cenc.auxiliary_info_pos);\n    sc->cenc.auxiliary_info_pos += AES_CTR_IV_SIZE;\n\n    if (!sc->cenc.use_subsamples)\n    {\n        /* decrypt the whole packet */\n        av_aes_ctr_crypt(sc->cenc.aes_ctr, input, input, size);\n        return 0;\n    }\n\n    /* read the subsample count */\n    if (sizeof(uint16_t) > sc->cenc.auxiliary_info_end - sc->cenc.auxiliary_info_pos) {\n        av_log(c->fc, AV_LOG_ERROR, \"failed to read subsample count from the auxiliary info\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    subsample_count = AV_RB16(sc->cenc.auxiliary_info_pos);\n    sc->cenc.auxiliary_info_pos += sizeof(uint16_t);\n\n    for (; subsample_count > 0; subsample_count--)\n    {\n        if (6 > sc->cenc.auxiliary_info_end - sc->cenc.auxiliary_info_pos) {\n            av_log(c->fc, AV_LOG_ERROR, \"failed to read subsample from the auxiliary info\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        /* read the number of clear / encrypted bytes */\n        clear_bytes = AV_RB16(sc->cenc.auxiliary_info_pos);\n        sc->cenc.auxiliary_info_pos += sizeof(uint16_t);\n        encrypted_bytes = AV_RB32(sc->cenc.auxiliary_info_pos);\n        sc->cenc.auxiliary_info_pos += sizeof(uint32_t);\n\n        if ((uint64_t)clear_bytes + encrypted_bytes > input_end - input) {\n            av_log(c->fc, AV_LOG_ERROR, \"subsample size exceeds the packet size left\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n\n        /* skip the clear bytes */\n        input += clear_bytes;\n\n        /* decrypt the encrypted bytes */\n        av_aes_ctr_crypt(sc->cenc.aes_ctr, input, input, encrypted_bytes);\n        input += encrypted_bytes;\n    }\n\n    if (input < input_end) {\n        av_log(c->fc, AV_LOG_ERROR, \"leftover packet bytes after subsample processing\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    sc->cenc.auxiliary_info_index++;\n    return 0;\n}\n\nstatic int mov_read_dops(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    const int OPUS_SEEK_PREROLL_MS = 80;\n    AVStream *st;\n    size_t size;\n    int16_t pre_skip;\n\n    if (c->fc->nb_streams < 1)\n        return 0;\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    if ((uint64_t)atom.size > (1<<30) || atom.size < 11)\n        return AVERROR_INVALIDDATA;\n\n    /* Check OpusSpecificBox version. */\n    if (avio_r8(pb) != 0) {\n        av_log(c->fc, AV_LOG_ERROR, \"unsupported OpusSpecificBox version\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n\n    /* OpusSpecificBox size plus magic for Ogg OpusHead header. */\n    size = atom.size + 8;\n\n    if (ff_alloc_extradata(st->codecpar, size))\n        return AVERROR(ENOMEM);\n\n    AV_WL32(st->codecpar->extradata, MKTAG('O','p','u','s'));\n    AV_WL32(st->codecpar->extradata + 4, MKTAG('H','e','a','d'));\n    AV_WB8(st->codecpar->extradata + 8, 1); /* OpusHead version */\n    avio_read(pb, st->codecpar->extradata + 9, size - 9);\n\n    /* OpusSpecificBox is stored in big-endian, but OpusHead is\n       little-endian; aside from the preceeding magic and version they're\n       otherwise currently identical.  Data after output gain at offset 16\n       doesn't need to be bytewapped. */\n    pre_skip = AV_RB16(st->codecpar->extradata + 10);\n    AV_WL16(st->codecpar->extradata + 10, pre_skip);\n    AV_WL32(st->codecpar->extradata + 12, AV_RB32(st->codecpar->extradata + 12));\n    AV_WL16(st->codecpar->extradata + 16, AV_RB16(st->codecpar->extradata + 16));\n\n    st->codecpar->initial_padding = pre_skip;\n    st->codecpar->seek_preroll = av_rescale_q(OPUS_SEEK_PREROLL_MS,\n                                              (AVRational){1, 1000},\n                                              (AVRational){1, 48000});\n\n    return 0;\n}\n\nstatic const MOVParseTableEntry mov_default_parse_table[] = {\n{ MKTAG('A','C','L','R'), mov_read_aclr },\n{ MKTAG('A','P','R','G'), mov_read_avid },\n{ MKTAG('A','A','L','P'), mov_read_avid },\n{ MKTAG('A','R','E','S'), mov_read_ares },\n{ MKTAG('a','v','s','s'), mov_read_avss },\n{ MKTAG('c','h','p','l'), mov_read_chpl },\n{ MKTAG('c','o','6','4'), mov_read_stco },\n{ MKTAG('c','o','l','r'), mov_read_colr },\n{ MKTAG('c','t','t','s'), mov_read_ctts }, /* composition time to sample */\n{ MKTAG('d','i','n','f'), mov_read_default },\n{ MKTAG('D','p','x','E'), mov_read_dpxe },\n{ MKTAG('d','r','e','f'), mov_read_dref },\n{ MKTAG('e','d','t','s'), mov_read_default },\n{ MKTAG('e','l','s','t'), mov_read_elst },\n{ MKTAG('e','n','d','a'), mov_read_enda },\n{ MKTAG('f','i','e','l'), mov_read_fiel },\n{ MKTAG('a','d','r','m'), mov_read_adrm },\n{ MKTAG('f','t','y','p'), mov_read_ftyp },\n{ MKTAG('g','l','b','l'), mov_read_glbl },\n{ MKTAG('h','d','l','r'), mov_read_hdlr },\n{ MKTAG('i','l','s','t'), mov_read_ilst },\n{ MKTAG('j','p','2','h'), mov_read_jp2h },\n{ MKTAG('m','d','a','t'), mov_read_mdat },\n{ MKTAG('m','d','h','d'), mov_read_mdhd },\n{ MKTAG('m','d','i','a'), mov_read_default },\n{ MKTAG('m','e','t','a'), mov_read_meta },\n{ MKTAG('m','i','n','f'), mov_read_default },\n{ MKTAG('m','o','o','f'), mov_read_moof },\n{ MKTAG('m','o','o','v'), mov_read_moov },\n{ MKTAG('m','v','e','x'), mov_read_default },\n{ MKTAG('m','v','h','d'), mov_read_mvhd },\n{ MKTAG('S','M','I',' '), mov_read_svq3 },\n{ MKTAG('a','l','a','c'), mov_read_alac }, /* alac specific atom */\n{ MKTAG('a','v','c','C'), mov_read_glbl },\n{ MKTAG('p','a','s','p'), mov_read_pasp },\n{ MKTAG('s','i','d','x'), mov_read_sidx },\n{ MKTAG('s','t','b','l'), mov_read_default },\n{ MKTAG('s','t','c','o'), mov_read_stco },\n{ MKTAG('s','t','p','s'), mov_read_stps },\n{ MKTAG('s','t','r','f'), mov_read_strf },\n{ MKTAG('s','t','s','c'), mov_read_stsc },\n{ MKTAG('s','t','s','d'), mov_read_stsd }, /* sample description */\n{ MKTAG('s','t','s','s'), mov_read_stss }, /* sync sample */\n{ MKTAG('s','t','s','z'), mov_read_stsz }, /* sample size */\n{ MKTAG('s','t','t','s'), mov_read_stts },\n{ MKTAG('s','t','z','2'), mov_read_stsz }, /* compact sample size */\n{ MKTAG('t','k','h','d'), mov_read_tkhd }, /* track header */\n{ MKTAG('t','f','d','t'), mov_read_tfdt },\n{ MKTAG('t','f','h','d'), mov_read_tfhd }, /* track fragment header */\n{ MKTAG('t','r','a','k'), mov_read_trak },\n{ MKTAG('t','r','a','f'), mov_read_default },\n{ MKTAG('t','r','e','f'), mov_read_default },\n{ MKTAG('t','m','c','d'), mov_read_tmcd },\n{ MKTAG('c','h','a','p'), mov_read_chap },\n{ MKTAG('t','r','e','x'), mov_read_trex },\n{ MKTAG('t','r','u','n'), mov_read_trun },\n{ MKTAG('u','d','t','a'), mov_read_default },\n{ MKTAG('w','a','v','e'), mov_read_wave },\n{ MKTAG('e','s','d','s'), mov_read_esds },\n{ MKTAG('d','a','c','3'), mov_read_dac3 }, /* AC-3 info */\n{ MKTAG('d','e','c','3'), mov_read_dec3 }, /* EAC-3 info */\n{ MKTAG('d','d','t','s'), mov_read_ddts }, /* DTS audio descriptor */\n{ MKTAG('w','i','d','e'), mov_read_wide }, /* place holder */\n{ MKTAG('w','f','e','x'), mov_read_wfex },\n{ MKTAG('c','m','o','v'), mov_read_cmov },\n{ MKTAG('c','h','a','n'), mov_read_chan }, /* channel layout */\n{ MKTAG('d','v','c','1'), mov_read_dvc1 },\n{ MKTAG('s','b','g','p'), mov_read_sbgp },\n{ MKTAG('h','v','c','C'), mov_read_glbl },\n{ MKTAG('u','u','i','d'), mov_read_uuid },\n{ MKTAG('C','i','n', 0x8e), mov_read_targa_y216 },\n{ MKTAG('f','r','e','e'), mov_read_free },\n{ MKTAG('-','-','-','-'), mov_read_custom },\n{ MKTAG('s','i','n','f'), mov_read_default },\n{ MKTAG('f','r','m','a'), mov_read_frma },\n{ MKTAG('s','e','n','c'), mov_read_senc },\n{ MKTAG('s','a','i','z'), mov_read_saiz },\n{ MKTAG('d','f','L','a'), mov_read_dfla },\n{ MKTAG('s','t','3','d'), mov_read_st3d }, /* stereoscopic 3D video box */\n{ MKTAG('s','v','3','d'), mov_read_sv3d }, /* spherical video box */\n{ MKTAG('d','O','p','s'), mov_read_dops },\n{ MKTAG('S','m','D','m'), mov_read_smdm },\n{ MKTAG('C','o','L','L'), mov_read_coll },\n{ MKTAG('v','p','c','C'), mov_read_vpcc },\n{ 0, NULL }\n};\n\nstatic int mov_read_default(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n{\n    int64_t total_size = 0;\n    MOVAtom a;\n    int i;\n\n    if (c->atom_depth > 10) {\n        av_log(c->fc, AV_LOG_ERROR, \"Atoms too deeply nested\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    c->atom_depth ++;\n\n    if (atom.size < 0)\n        atom.size = INT64_MAX;\n    while (total_size <= atom.size - 8 && !avio_feof(pb)) {\n        int (*parse)(MOVContext*, AVIOContext*, MOVAtom) = NULL;\n        a.size = atom.size;\n        a.type=0;\n        if (atom.size >= 8) {\n            a.size = avio_rb32(pb);\n            a.type = avio_rl32(pb);\n            if (a.type == MKTAG('f','r','e','e') &&\n                a.size >= 8 &&\n                c->fc->strict_std_compliance < FF_COMPLIANCE_STRICT &&\n                c->moov_retry) {\n                uint8_t buf[8];\n                uint32_t *type = (uint32_t *)buf + 1;\n                if (avio_read(pb, buf, 8) != 8)\n                    return AVERROR_INVALIDDATA;\n                avio_seek(pb, -8, SEEK_CUR);\n                if (*type == MKTAG('m','v','h','d') ||\n                    *type == MKTAG('c','m','o','v')) {\n                    av_log(c->fc, AV_LOG_ERROR, \"Detected moov in a free atom.\\n\");\n                    a.type = MKTAG('m','o','o','v');\n                }\n            }\n            if (atom.type != MKTAG('r','o','o','t') &&\n                atom.type != MKTAG('m','o','o','v'))\n            {\n                if (a.type == MKTAG('t','r','a','k') || a.type == MKTAG('m','d','a','t'))\n                {\n                    av_log(c->fc, AV_LOG_ERROR, \"Broken file, trak/mdat not at top-level\\n\");\n                    avio_skip(pb, -8);\n                    c->atom_depth --;\n                    return 0;\n                }\n            }\n            total_size += 8;\n            if (a.size == 1 && total_size + 8 <= atom.size) { /* 64 bit extended size */\n                a.size = avio_rb64(pb) - 8;\n                total_size += 8;\n            }\n        }\n        av_log(c->fc, AV_LOG_TRACE, \"type:'%s' parent:'%s' sz: %\"PRId64\" %\"PRId64\" %\"PRId64\"\\n\",\n               av_fourcc2str(a.type), av_fourcc2str(atom.type), a.size, total_size, atom.size);\n        if (a.size == 0) {\n            a.size = atom.size - total_size + 8;\n        }\n        a.size -= 8;\n        if (a.size < 0)\n            break;\n        a.size = FFMIN(a.size, atom.size - total_size);\n\n        for (i = 0; mov_default_parse_table[i].type; i++)\n            if (mov_default_parse_table[i].type == a.type) {\n                parse = mov_default_parse_table[i].parse;\n                break;\n            }\n\n        // container is user data\n        if (!parse && (atom.type == MKTAG('u','d','t','a') ||\n                       atom.type == MKTAG('i','l','s','t')))\n            parse = mov_read_udta_string;\n\n        // Supports parsing the QuickTime Metadata Keys.\n        // https://developer.apple.com/library/mac/documentation/QuickTime/QTFF/Metadata/Metadata.html\n        if (!parse && c->found_hdlr_mdta &&\n            atom.type == MKTAG('m','e','t','a') &&\n            a.type == MKTAG('k','e','y','s')) {\n            parse = mov_read_keys;\n        }\n\n        if (!parse) { /* skip leaf atoms data */\n            avio_skip(pb, a.size);\n        } else {\n            int64_t start_pos = avio_tell(pb);\n            int64_t left;\n            int err = parse(c, pb, a);\n            if (err < 0) {\n                c->atom_depth --;\n                return err;\n            }\n            if (c->found_moov && c->found_mdat &&\n                ((!(pb->seekable & AVIO_SEEKABLE_NORMAL) || c->fc->flags & AVFMT_FLAG_IGNIDX || c->fragment_index_complete) ||\n                 start_pos + a.size == avio_size(pb))) {\n                if (!(pb->seekable & AVIO_SEEKABLE_NORMAL) || c->fc->flags & AVFMT_FLAG_IGNIDX || c->fragment_index_complete)\n                    c->next_root_atom = start_pos + a.size;\n                c->atom_depth --;\n                return 0;\n            }\n            left = a.size - avio_tell(pb) + start_pos;\n            if (left > 0) /* skip garbage at atom end */\n                avio_skip(pb, left);\n            else if (left < 0) {\n                av_log(c->fc, AV_LOG_WARNING,\n                       \"overread end of atom '%.4s' by %\"PRId64\" bytes\\n\",\n                       (char*)&a.type, -left);\n                avio_seek(pb, left, SEEK_CUR);\n            }\n        }\n\n        total_size += a.size;\n    }\n\n    if (total_size < atom.size && atom.size < 0x7ffff)\n        avio_skip(pb, atom.size - total_size);\n\n    c->atom_depth --;\n    return 0;\n}\n\nstatic int mov_probe(AVProbeData *p)\n{\n    int64_t offset;\n    uint32_t tag;\n    int score = 0;\n    int moov_offset = -1;\n\n    /* check file header */\n    offset = 0;\n    for (;;) {\n        /* ignore invalid offset */\n        if ((offset + 8) > (unsigned int)p->buf_size)\n            break;\n        tag = AV_RL32(p->buf + offset + 4);\n        switch(tag) {\n        /* check for obvious tags */\n        case MKTAG('m','o','o','v'):\n            moov_offset = offset + 4;\n        case MKTAG('m','d','a','t'):\n        case MKTAG('p','n','o','t'): /* detect movs with preview pics like ew.mov and april.mov */\n        case MKTAG('u','d','t','a'): /* Packet Video PVAuthor adds this and a lot of more junk */\n        case MKTAG('f','t','y','p'):\n            if (AV_RB32(p->buf+offset) < 8 &&\n                (AV_RB32(p->buf+offset) != 1 ||\n                 offset + 12 > (unsigned int)p->buf_size ||\n                 AV_RB64(p->buf+offset + 8) == 0)) {\n                score = FFMAX(score, AVPROBE_SCORE_EXTENSION);\n            } else if (tag == MKTAG('f','t','y','p') &&\n                       (   AV_RL32(p->buf + offset + 8) == MKTAG('j','p','2',' ')\n                        || AV_RL32(p->buf + offset + 8) == MKTAG('j','p','x',' ')\n                    )) {\n                score = FFMAX(score, 5);\n            } else {\n                score = AVPROBE_SCORE_MAX;\n            }\n            offset = FFMAX(4, AV_RB32(p->buf+offset)) + offset;\n            break;\n        /* those are more common words, so rate then a bit less */\n        case MKTAG('e','d','i','w'): /* xdcam files have reverted first tags */\n        case MKTAG('w','i','d','e'):\n        case MKTAG('f','r','e','e'):\n        case MKTAG('j','u','n','k'):\n        case MKTAG('p','i','c','t'):\n            score  = FFMAX(score, AVPROBE_SCORE_MAX - 5);\n            offset = FFMAX(4, AV_RB32(p->buf+offset)) + offset;\n            break;\n        case MKTAG(0x82,0x82,0x7f,0x7d):\n        case MKTAG('s','k','i','p'):\n        case MKTAG('u','u','i','d'):\n        case MKTAG('p','r','f','l'):\n            /* if we only find those cause probedata is too small at least rate them */\n            score  = FFMAX(score, AVPROBE_SCORE_EXTENSION);\n            offset = FFMAX(4, AV_RB32(p->buf+offset)) + offset;\n            break;\n        default:\n            offset = FFMAX(4, AV_RB32(p->buf+offset)) + offset;\n        }\n    }\n    if(score > AVPROBE_SCORE_MAX - 50 && moov_offset != -1) {\n        /* moov atom in the header - we should make sure that this is not a\n         * MOV-packed MPEG-PS */\n        offset = moov_offset;\n\n        while(offset < (p->buf_size - 16)){ /* Sufficient space */\n               /* We found an actual hdlr atom */\n            if(AV_RL32(p->buf + offset     ) == MKTAG('h','d','l','r') &&\n               AV_RL32(p->buf + offset +  8) == MKTAG('m','h','l','r') &&\n               AV_RL32(p->buf + offset + 12) == MKTAG('M','P','E','G')){\n                av_log(NULL, AV_LOG_WARNING, \"Found media data tag MPEG indicating this is a MOV-packed MPEG-PS.\\n\");\n                /* We found a media handler reference atom describing an\n                 * MPEG-PS-in-MOV, return a\n                 * low score to force expanding the probe window until\n                 * mpegps_probe finds what it needs */\n                return 5;\n            }else\n                /* Keep looking */\n                offset+=2;\n        }\n    }\n\n    return score;\n}\n\n// must be done after parsing all trak because there's no order requirement\nstatic void mov_read_chapters(AVFormatContext *s)\n{\n    MOVContext *mov = s->priv_data;\n    AVStream *st;\n    MOVStreamContext *sc;\n    int64_t cur_pos;\n    int i, j;\n    int chapter_track;\n\n    for (j = 0; j < mov->nb_chapter_tracks; j++) {\n        chapter_track = mov->chapter_tracks[j];\n        st = NULL;\n        for (i = 0; i < s->nb_streams; i++)\n            if (s->streams[i]->id == chapter_track) {\n                st = s->streams[i];\n                break;\n            }\n        if (!st) {\n            av_log(s, AV_LOG_ERROR, \"Referenced QT chapter track not found\\n\");\n            continue;\n        }\n\n        sc = st->priv_data;\n        cur_pos = avio_tell(sc->pb);\n\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {\n            st->disposition |= AV_DISPOSITION_ATTACHED_PIC | AV_DISPOSITION_TIMED_THUMBNAILS;\n            if (st->nb_index_entries) {\n                // Retrieve the first frame, if possible\n                AVPacket pkt;\n                AVIndexEntry *sample = &st->index_entries[0];\n                if (avio_seek(sc->pb, sample->pos, SEEK_SET) != sample->pos) {\n                    av_log(s, AV_LOG_ERROR, \"Failed to retrieve first frame\\n\");\n                    goto finish;\n                }\n\n                if (av_get_packet(sc->pb, &pkt, sample->size) < 0)\n                    goto finish;\n\n                st->attached_pic              = pkt;\n                st->attached_pic.stream_index = st->index;\n                st->attached_pic.flags       |= AV_PKT_FLAG_KEY;\n            }\n        } else {\n            st->codecpar->codec_type = AVMEDIA_TYPE_DATA;\n            st->codecpar->codec_id = AV_CODEC_ID_BIN_DATA;\n            st->discard = AVDISCARD_ALL;\n            for (i = 0; i < st->nb_index_entries; i++) {\n                AVIndexEntry *sample = &st->index_entries[i];\n                int64_t end = i+1 < st->nb_index_entries ? st->index_entries[i+1].timestamp : st->duration;\n                uint8_t *title;\n                uint16_t ch;\n                int len, title_len;\n\n                if (end < sample->timestamp) {\n                    av_log(s, AV_LOG_WARNING, \"ignoring stream duration which is shorter than chapters\\n\");\n                    end = AV_NOPTS_VALUE;\n                }\n\n                if (avio_seek(sc->pb, sample->pos, SEEK_SET) != sample->pos) {\n                    av_log(s, AV_LOG_ERROR, \"Chapter %d not found in file\\n\", i);\n                    goto finish;\n                }\n\n                // the first two bytes are the length of the title\n                len = avio_rb16(sc->pb);\n                if (len > sample->size-2)\n                    continue;\n                title_len = 2*len + 1;\n                if (!(title = av_mallocz(title_len)))\n                    goto finish;\n\n                // The samples could theoretically be in any encoding if there's an encd\n                // atom following, but in practice are only utf-8 or utf-16, distinguished\n                // instead by the presence of a BOM\n                if (!len) {\n                    title[0] = 0;\n                } else {\n                    ch = avio_rb16(sc->pb);\n                    if (ch == 0xfeff)\n                        avio_get_str16be(sc->pb, len, title, title_len);\n                    else if (ch == 0xfffe)\n                        avio_get_str16le(sc->pb, len, title, title_len);\n                    else {\n                        AV_WB16(title, ch);\n                        if (len == 1 || len == 2)\n                            title[len] = 0;\n                        else\n                            avio_get_str(sc->pb, INT_MAX, title + 2, len - 1);\n                    }\n                }\n\n                avpriv_new_chapter(s, i, st->time_base, sample->timestamp, end, title);\n                av_freep(&title);\n            }\n        }\nfinish:\n        avio_seek(sc->pb, cur_pos, SEEK_SET);\n    }\n}\n\nstatic int parse_timecode_in_framenum_format(AVFormatContext *s, AVStream *st,\n                                             uint32_t value, int flags)\n{\n    AVTimecode tc;\n    char buf[AV_TIMECODE_STR_SIZE];\n    AVRational rate = st->avg_frame_rate;\n    int ret = av_timecode_init(&tc, rate, flags, 0, s);\n    if (ret < 0)\n        return ret;\n    av_dict_set(&st->metadata, \"timecode\",\n                av_timecode_make_string(&tc, buf, value), 0);\n    return 0;\n}\n\nstatic int mov_read_rtmd_track(AVFormatContext *s, AVStream *st)\n{\n    MOVStreamContext *sc = st->priv_data;\n    char buf[AV_TIMECODE_STR_SIZE];\n    int64_t cur_pos = avio_tell(sc->pb);\n    int hh, mm, ss, ff, drop;\n\n    if (!st->nb_index_entries)\n        return -1;\n\n    avio_seek(sc->pb, st->index_entries->pos, SEEK_SET);\n    avio_skip(s->pb, 13);\n    hh = avio_r8(s->pb);\n    mm = avio_r8(s->pb);\n    ss = avio_r8(s->pb);\n    drop = avio_r8(s->pb);\n    ff = avio_r8(s->pb);\n    snprintf(buf, AV_TIMECODE_STR_SIZE, \"%02d:%02d:%02d%c%02d\",\n             hh, mm, ss, drop ? ';' : ':', ff);\n    av_dict_set(&st->metadata, \"timecode\", buf, 0);\n\n    avio_seek(sc->pb, cur_pos, SEEK_SET);\n    return 0;\n}\n\nstatic int mov_read_timecode_track(AVFormatContext *s, AVStream *st)\n{\n    MOVStreamContext *sc = st->priv_data;\n    int flags = 0;\n    int64_t cur_pos = avio_tell(sc->pb);\n    uint32_t value;\n\n    if (!st->nb_index_entries)\n        return -1;\n\n    avio_seek(sc->pb, st->index_entries->pos, SEEK_SET);\n    value = avio_rb32(s->pb);\n\n    if (sc->tmcd_flags & 0x0001) flags |= AV_TIMECODE_FLAG_DROPFRAME;\n    if (sc->tmcd_flags & 0x0002) flags |= AV_TIMECODE_FLAG_24HOURSMAX;\n    if (sc->tmcd_flags & 0x0004) flags |= AV_TIMECODE_FLAG_ALLOWNEGATIVE;\n\n    /* Assume Counter flag is set to 1 in tmcd track (even though it is likely\n     * not the case) and thus assume \"frame number format\" instead of QT one.\n     * No sample with tmcd track can be found with a QT timecode at the moment,\n     * despite what the tmcd track \"suggests\" (Counter flag set to 0 means QT\n     * format). */\n    parse_timecode_in_framenum_format(s, st, value, flags);\n\n    avio_seek(sc->pb, cur_pos, SEEK_SET);\n    return 0;\n}\n\nstatic int mov_read_close(AVFormatContext *s)\n{\n    MOVContext *mov = s->priv_data;\n    int i, j;\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n        MOVStreamContext *sc = st->priv_data;\n\n        if (!sc)\n            continue;\n\n        av_freep(&sc->ctts_data);\n        for (j = 0; j < sc->drefs_count; j++) {\n            av_freep(&sc->drefs[j].path);\n            av_freep(&sc->drefs[j].dir);\n        }\n        av_freep(&sc->drefs);\n\n        sc->drefs_count = 0;\n\n        if (!sc->pb_is_copied)\n            ff_format_io_close(s, &sc->pb);\n\n        sc->pb = NULL;\n        av_freep(&sc->chunk_offsets);\n        av_freep(&sc->stsc_data);\n        av_freep(&sc->sample_sizes);\n        av_freep(&sc->keyframes);\n        av_freep(&sc->stts_data);\n        av_freep(&sc->stps_data);\n        av_freep(&sc->elst_data);\n        av_freep(&sc->rap_group);\n        av_freep(&sc->display_matrix);\n        av_freep(&sc->index_ranges);\n\n        if (sc->extradata)\n            for (j = 0; j < sc->stsd_count; j++)\n                av_free(sc->extradata[j]);\n        av_freep(&sc->extradata);\n        av_freep(&sc->extradata_size);\n\n        av_freep(&sc->cenc.auxiliary_info);\n        av_freep(&sc->cenc.auxiliary_info_sizes);\n        av_aes_ctr_free(sc->cenc.aes_ctr);\n\n        av_freep(&sc->stereo3d);\n        av_freep(&sc->spherical);\n        av_freep(&sc->mastering);\n        av_freep(&sc->coll);\n    }\n\n    if (mov->dv_demux) {\n        avformat_free_context(mov->dv_fctx);\n        mov->dv_fctx = NULL;\n    }\n\n    if (mov->meta_keys) {\n        for (i = 1; i < mov->meta_keys_count; i++) {\n            av_freep(&mov->meta_keys[i]);\n        }\n        av_freep(&mov->meta_keys);\n    }\n\n    av_freep(&mov->trex_data);\n    av_freep(&mov->bitrates);\n\n    for (i = 0; i < mov->fragment_index_count; i++) {\n        MOVFragmentIndex* index = mov->fragment_index_data[i];\n        av_freep(&index->items);\n        av_freep(&mov->fragment_index_data[i]);\n    }\n    av_freep(&mov->fragment_index_data);\n\n    av_freep(&mov->aes_decrypt);\n    av_freep(&mov->chapter_tracks);\n\n    return 0;\n}\n\nstatic int tmcd_is_referenced(AVFormatContext *s, int tmcd_id)\n{\n    int i;\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n        MOVStreamContext *sc = st->priv_data;\n\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO &&\n            sc->timecode_track == tmcd_id)\n            return 1;\n    }\n    return 0;\n}\n\n/* look for a tmcd track not referenced by any video track, and export it globally */\nstatic void export_orphan_timecode(AVFormatContext *s)\n{\n    int i;\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n\n        if (st->codecpar->codec_tag  == MKTAG('t','m','c','d') &&\n            !tmcd_is_referenced(s, i + 1)) {\n            AVDictionaryEntry *tcr = av_dict_get(st->metadata, \"timecode\", NULL, 0);\n            if (tcr) {\n                av_dict_set(&s->metadata, \"timecode\", tcr->value, 0);\n                break;\n            }\n        }\n    }\n}\n\nstatic int read_tfra(MOVContext *mov, AVIOContext *f)\n{\n    MOVFragmentIndex* index = NULL;\n    int version, fieldlength, i, j;\n    int64_t pos = avio_tell(f);\n    uint32_t size = avio_rb32(f);\n    void *tmp;\n\n    if (avio_rb32(f) != MKBETAG('t', 'f', 'r', 'a')) {\n        return 1;\n    }\n    av_log(mov->fc, AV_LOG_VERBOSE, \"found tfra\\n\");\n    index = av_mallocz(sizeof(MOVFragmentIndex));\n    if (!index) {\n        return AVERROR(ENOMEM);\n    }\n\n    tmp = av_realloc_array(mov->fragment_index_data,\n                           mov->fragment_index_count + 1,\n                           sizeof(MOVFragmentIndex*));\n    if (!tmp) {\n        av_freep(&index);\n        return AVERROR(ENOMEM);\n    }\n    mov->fragment_index_data = tmp;\n    mov->fragment_index_data[mov->fragment_index_count++] = index;\n\n    version = avio_r8(f);\n    avio_rb24(f);\n    index->track_id = avio_rb32(f);\n    fieldlength = avio_rb32(f);\n    index->item_count = avio_rb32(f);\n    index->items = av_mallocz_array(\n            index->item_count, sizeof(MOVFragmentIndexItem));\n    if (!index->items) {\n        index->item_count = 0;\n        return AVERROR(ENOMEM);\n    }\n    for (i = 0; i < index->item_count; i++) {\n        int64_t time, offset;\n\n        if (avio_feof(f)) {\n            index->item_count = 0;\n            av_freep(&index->items);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (version == 1) {\n            time   = avio_rb64(f);\n            offset = avio_rb64(f);\n        } else {\n            time   = avio_rb32(f);\n            offset = avio_rb32(f);\n        }\n        index->items[i].time = time;\n        index->items[i].moof_offset = offset;\n        for (j = 0; j < ((fieldlength >> 4) & 3) + 1; j++)\n            avio_r8(f);\n        for (j = 0; j < ((fieldlength >> 2) & 3) + 1; j++)\n            avio_r8(f);\n        for (j = 0; j < ((fieldlength >> 0) & 3) + 1; j++)\n            avio_r8(f);\n    }\n\n    avio_seek(f, pos + size, SEEK_SET);\n    return 0;\n}\n\nstatic int mov_read_mfra(MOVContext *c, AVIOContext *f)\n{\n    int64_t stream_size = avio_size(f);\n    int64_t original_pos = avio_tell(f);\n    int64_t seek_ret;\n    int32_t mfra_size;\n    int ret = -1;\n    if ((seek_ret = avio_seek(f, stream_size - 4, SEEK_SET)) < 0) {\n        ret = seek_ret;\n        goto fail;\n    }\n    mfra_size = avio_rb32(f);\n    if (mfra_size < 0 || mfra_size > stream_size) {\n        av_log(c->fc, AV_LOG_DEBUG, \"doesn't look like mfra (unreasonable size)\\n\");\n        goto fail;\n    }\n    if ((seek_ret = avio_seek(f, -mfra_size, SEEK_CUR)) < 0) {\n        ret = seek_ret;\n        goto fail;\n    }\n    if (avio_rb32(f) != mfra_size) {\n        av_log(c->fc, AV_LOG_DEBUG, \"doesn't look like mfra (size mismatch)\\n\");\n        goto fail;\n    }\n    if (avio_rb32(f) != MKBETAG('m', 'f', 'r', 'a')) {\n        av_log(c->fc, AV_LOG_DEBUG, \"doesn't look like mfra (tag mismatch)\\n\");\n        goto fail;\n    }\n    av_log(c->fc, AV_LOG_VERBOSE, \"stream has mfra\\n\");\n    do {\n        ret = read_tfra(c, f);\n        if (ret < 0)\n            goto fail;\n    } while (!ret);\n    ret = 0;\nfail:\n    seek_ret = avio_seek(f, original_pos, SEEK_SET);\n    if (seek_ret < 0) {\n        av_log(c->fc, AV_LOG_ERROR,\n               \"failed to seek back after looking for mfra\\n\");\n        ret = seek_ret;\n    }\n    return ret;\n}\n\nstatic int mov_read_header(AVFormatContext *s)\n{\n    MOVContext *mov = s->priv_data;\n    AVIOContext *pb = s->pb;\n    int j, err;\n    MOVAtom atom = { AV_RL32(\"root\") };\n    int i;\n\n    if (mov->decryption_key_len != 0 && mov->decryption_key_len != AES_CTR_KEY_SIZE) {\n        av_log(s, AV_LOG_ERROR, \"Invalid decryption key len %d expected %d\\n\",\n            mov->decryption_key_len, AES_CTR_KEY_SIZE);\n        return AVERROR(EINVAL);\n    }\n\n    mov->fc = s;\n    mov->trak_index = -1;\n    /* .mov and .mp4 aren't streamable anyway (only progressive download if moov is before mdat) */\n    if (pb->seekable & AVIO_SEEKABLE_NORMAL)\n        atom.size = avio_size(pb);\n    else\n        atom.size = INT64_MAX;\n\n    /* check MOV header */\n    do {\n    if (mov->moov_retry)\n        avio_seek(pb, 0, SEEK_SET);\n    if ((err = mov_read_default(mov, pb, atom)) < 0) {\n        av_log(s, AV_LOG_ERROR, \"error reading header\\n\");\n        mov_read_close(s);\n        return err;\n    }\n    } while ((pb->seekable & AVIO_SEEKABLE_NORMAL) && !mov->found_moov && !mov->moov_retry++);\n    if (!mov->found_moov) {\n        av_log(s, AV_LOG_ERROR, \"moov atom not found\\n\");\n        mov_read_close(s);\n        return AVERROR_INVALIDDATA;\n    }\n    av_log(mov->fc, AV_LOG_TRACE, \"on_parse_exit_offset=%\"PRId64\"\\n\", avio_tell(pb));\n\n    if (pb->seekable & AVIO_SEEKABLE_NORMAL) {\n        if (mov->nb_chapter_tracks > 0 && !mov->ignore_chapters)\n            mov_read_chapters(s);\n        for (i = 0; i < s->nb_streams; i++)\n            if (s->streams[i]->codecpar->codec_tag == AV_RL32(\"tmcd\")) {\n                mov_read_timecode_track(s, s->streams[i]);\n            } else if (s->streams[i]->codecpar->codec_tag == AV_RL32(\"rtmd\")) {\n                mov_read_rtmd_track(s, s->streams[i]);\n            }\n    }\n\n    /* copy timecode metadata from tmcd tracks to the related video streams */\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n        MOVStreamContext *sc = st->priv_data;\n        if (sc->timecode_track > 0) {\n            AVDictionaryEntry *tcr;\n            int tmcd_st_id = -1;\n\n            for (j = 0; j < s->nb_streams; j++)\n                if (s->streams[j]->id == sc->timecode_track)\n                    tmcd_st_id = j;\n\n            if (tmcd_st_id < 0 || tmcd_st_id == i)\n                continue;\n            tcr = av_dict_get(s->streams[tmcd_st_id]->metadata, \"timecode\", NULL, 0);\n            if (tcr)\n                av_dict_set(&st->metadata, \"timecode\", tcr->value, 0);\n        }\n    }\n    export_orphan_timecode(s);\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n        MOVStreamContext *sc = st->priv_data;\n        fix_timescale(mov, sc);\n        if(st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO && st->codecpar->codec_id == AV_CODEC_ID_AAC) {\n            st->skip_samples = sc->start_pad;\n        }\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO && sc->nb_frames_for_fps > 0 && sc->duration_for_fps > 0)\n            av_reduce(&st->avg_frame_rate.num, &st->avg_frame_rate.den,\n                      sc->time_scale*(int64_t)sc->nb_frames_for_fps, sc->duration_for_fps, INT_MAX);\n        if (st->codecpar->codec_type == AVMEDIA_TYPE_SUBTITLE) {\n            if (st->codecpar->width <= 0 || st->codecpar->height <= 0) {\n                st->codecpar->width  = sc->width;\n                st->codecpar->height = sc->height;\n            }\n            if (st->codecpar->codec_id == AV_CODEC_ID_DVD_SUBTITLE) {\n                if ((err = mov_rewrite_dvd_sub_extradata(st)) < 0)\n                    return err;\n            }\n        }\n        if (mov->handbrake_version &&\n            mov->handbrake_version <= 1000000*0 + 1000*10 + 2 &&  // 0.10.2\n            st->codecpar->codec_id == AV_CODEC_ID_MP3\n        ) {\n            av_log(s, AV_LOG_VERBOSE, \"Forcing full parsing for mp3 stream\\n\");\n            st->need_parsing = AVSTREAM_PARSE_FULL;\n        }\n    }\n\n    if (mov->trex_data) {\n        for (i = 0; i < s->nb_streams; i++) {\n            AVStream *st = s->streams[i];\n            MOVStreamContext *sc = st->priv_data;\n            if (st->duration > 0) {\n                if (sc->data_size > INT64_MAX / sc->time_scale / 8) {\n                    av_log(s, AV_LOG_ERROR, \"Overflow during bit rate calculation %\"PRId64\" * 8 * %d\\n\",\n                           sc->data_size, sc->time_scale);\n                    mov_read_close(s);\n                    return AVERROR_INVALIDDATA;\n                }\n                st->codecpar->bit_rate = sc->data_size * 8 * sc->time_scale / st->duration;\n            }\n        }\n    }\n\n    if (mov->use_mfra_for > 0) {\n        for (i = 0; i < s->nb_streams; i++) {\n            AVStream *st = s->streams[i];\n            MOVStreamContext *sc = st->priv_data;\n            if (sc->duration_for_fps > 0) {\n                if (sc->data_size > INT64_MAX / sc->time_scale / 8) {\n                    av_log(s, AV_LOG_ERROR, \"Overflow during bit rate calculation %\"PRId64\" * 8 * %d\\n\",\n                           sc->data_size, sc->time_scale);\n                    mov_read_close(s);\n                    return AVERROR_INVALIDDATA;\n                }\n                st->codecpar->bit_rate = sc->data_size * 8 * sc->time_scale /\n                    sc->duration_for_fps;\n            }\n        }\n    }\n\n    for (i = 0; i < mov->bitrates_count && i < s->nb_streams; i++) {\n        if (mov->bitrates[i]) {\n            s->streams[i]->codecpar->bit_rate = mov->bitrates[i];\n        }\n    }\n\n    ff_rfps_calculate(s);\n\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *st = s->streams[i];\n        MOVStreamContext *sc = st->priv_data;\n\n        switch (st->codecpar->codec_type) {\n        case AVMEDIA_TYPE_AUDIO:\n            err = ff_replaygain_export(st, s->metadata);\n            if (err < 0) {\n                mov_read_close(s);\n                return err;\n            }\n            break;\n        case AVMEDIA_TYPE_VIDEO:\n            if (sc->display_matrix) {\n                err = av_stream_add_side_data(st, AV_PKT_DATA_DISPLAYMATRIX, (uint8_t*)sc->display_matrix,\n                                              sizeof(int32_t) * 9);\n                if (err < 0)\n                    return err;\n\n                sc->display_matrix = NULL;\n            }\n            if (sc->stereo3d) {\n                err = av_stream_add_side_data(st, AV_PKT_DATA_STEREO3D,\n                                              (uint8_t *)sc->stereo3d,\n                                              sizeof(*sc->stereo3d));\n                if (err < 0)\n                    return err;\n\n                sc->stereo3d = NULL;\n            }\n            if (sc->spherical) {\n                err = av_stream_add_side_data(st, AV_PKT_DATA_SPHERICAL,\n                                              (uint8_t *)sc->spherical,\n                                              sc->spherical_size);\n                if (err < 0)\n                    return err;\n\n                sc->spherical = NULL;\n            }\n            if (sc->mastering) {\n                err = av_stream_add_side_data(st, AV_PKT_DATA_MASTERING_DISPLAY_METADATA,\n                                              (uint8_t *)sc->mastering,\n                                              sizeof(*sc->mastering));\n                if (err < 0)\n                    return err;\n\n                sc->mastering = NULL;\n            }\n            if (sc->coll) {\n                err = av_stream_add_side_data(st, AV_PKT_DATA_CONTENT_LIGHT_LEVEL,\n                                              (uint8_t *)sc->coll,\n                                              sc->coll_size);\n                if (err < 0)\n                    return err;\n\n                sc->coll = NULL;\n            }\n            break;\n        }\n    }\n    ff_configure_buffers_for_index(s, AV_TIME_BASE);\n\n    for (i = 0; i < mov->fragment_index_count; i++) {\n        MOVFragmentIndex *idx = mov->fragment_index_data[i];\n        for (j = 0; j < idx->item_count; j++)\n            if (idx->items[j].moof_offset <= mov->fragment.moof_offset)\n                idx->items[j].headers_read = 1;\n    }\n\n    return 0;\n}\n\nstatic AVIndexEntry *mov_find_next_sample(AVFormatContext *s, AVStream **st)\n{\n    AVIndexEntry *sample = NULL;\n    int64_t best_dts = INT64_MAX;\n    int i;\n    for (i = 0; i < s->nb_streams; i++) {\n        AVStream *avst = s->streams[i];\n        MOVStreamContext *msc = avst->priv_data;\n        if (msc->pb && msc->current_sample < avst->nb_index_entries) {\n            AVIndexEntry *current_sample = &avst->index_entries[msc->current_sample];\n            int64_t dts = av_rescale(current_sample->timestamp, AV_TIME_BASE, msc->time_scale);\n            av_log(s, AV_LOG_TRACE, \"stream %d, sample %d, dts %\"PRId64\"\\n\", i, msc->current_sample, dts);\n            if (!sample || (!(s->pb->seekable & AVIO_SEEKABLE_NORMAL) && current_sample->pos < sample->pos) ||\n                ((s->pb->seekable & AVIO_SEEKABLE_NORMAL) &&\n                 ((msc->pb != s->pb && dts < best_dts) || (msc->pb == s->pb &&\n                 ((FFABS(best_dts - dts) <= AV_TIME_BASE && current_sample->pos < sample->pos) ||\n                  (FFABS(best_dts - dts) > AV_TIME_BASE && dts < best_dts)))))) {\n                sample = current_sample;\n                best_dts = dts;\n                *st = avst;\n            }\n        }\n    }\n    return sample;\n}\n\nstatic int should_retry(AVIOContext *pb, int error_code) {\n    if (error_code == AVERROR_EOF || avio_feof(pb))\n        return 0;\n\n    return 1;\n}\n\nstatic int mov_switch_root(AVFormatContext *s, int64_t target)\n{\n    MOVContext *mov = s->priv_data;\n    int i, j;\n    int already_read = 0;\n\n    if (avio_seek(s->pb, target, SEEK_SET) != target) {\n        av_log(mov->fc, AV_LOG_ERROR, \"root atom offset 0x%\"PRIx64\": partial file\\n\", target);\n        return AVERROR_INVALIDDATA;\n    }\n\n    mov->next_root_atom = 0;\n\n    for (i = 0; i < mov->fragment_index_count; i++) {\n        MOVFragmentIndex *index = mov->fragment_index_data[i];\n        int found = 0;\n        for (j = 0; j < index->item_count; j++) {\n            MOVFragmentIndexItem *item = &index->items[j];\n            if (found) {\n                mov->next_root_atom = item->moof_offset;\n                break; // Advance to next index in outer loop\n            } else if (item->moof_offset == target) {\n                index->current_item = FFMIN(j, index->current_item);\n                if (item->headers_read)\n                    already_read = 1;\n                item->headers_read = 1;\n                found = 1;\n            }\n        }\n        if (!found)\n            index->current_item = 0;\n    }\n\n    if (already_read)\n        return 0;\n\n    mov->found_mdat = 0;\n\n    if (mov_read_default(mov, s->pb, (MOVAtom){ AV_RL32(\"root\"), INT64_MAX }) < 0 ||\n        avio_feof(s->pb))\n        return AVERROR_EOF;\n    av_log(s, AV_LOG_TRACE, \"read fragments, offset 0x%\"PRIx64\"\\n\", avio_tell(s->pb));\n\n    return 1;\n}\n\nstatic int mov_change_extradata(MOVStreamContext *sc, AVPacket *pkt)\n{\n    uint8_t *side, *extradata;\n    int extradata_size;\n\n    /* Save the current index. */\n    sc->last_stsd_index = sc->stsc_data[sc->stsc_index].id - 1;\n\n    /* Notify the decoder that extradata changed. */\n    extradata_size = sc->extradata_size[sc->last_stsd_index];\n    extradata = sc->extradata[sc->last_stsd_index];\n    if (extradata_size > 0 && extradata) {\n        side = av_packet_new_side_data(pkt,\n                                       AV_PKT_DATA_NEW_EXTRADATA,\n                                       extradata_size);\n        if (!side)\n            return AVERROR(ENOMEM);\n        memcpy(side, extradata, extradata_size);\n    }\n\n    return 0;\n}\n\nstatic int mov_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    MOVContext *mov = s->priv_data;\n    MOVStreamContext *sc;\n    AVIndexEntry *sample;\n    AVStream *st = NULL;\n    int64_t current_index;\n    int ret;\n    mov->fc = s;\n retry:\n    sample = mov_find_next_sample(s, &st);\n    if (!sample || (mov->next_root_atom && sample->pos > mov->next_root_atom)) {\n        if (!mov->next_root_atom)\n            return AVERROR_EOF;\n        if ((ret = mov_switch_root(s, mov->next_root_atom)) < 0)\n            return ret;\n        goto retry;\n    }\n    sc = st->priv_data;\n    /* must be done just before reading, to avoid infinite loop on sample */\n    current_index = sc->current_index;\n    mov_current_sample_inc(sc);\n\n    if (mov->next_root_atom) {\n        sample->pos = FFMIN(sample->pos, mov->next_root_atom);\n        sample->size = FFMIN(sample->size, (mov->next_root_atom - sample->pos));\n    }\n\n    if (st->discard != AVDISCARD_ALL) {\n        int64_t ret64 = avio_seek(sc->pb, sample->pos, SEEK_SET);\n        if (ret64 != sample->pos) {\n            av_log(mov->fc, AV_LOG_ERROR, \"stream %d, offset 0x%\"PRIx64\": partial file\\n\",\n                   sc->ffindex, sample->pos);\n            if (should_retry(sc->pb, ret64)) {\n                mov_current_sample_dec(sc);\n            }\n            return AVERROR_INVALIDDATA;\n        }\n\n        if( st->discard == AVDISCARD_NONKEY && 0==(sample->flags & AVINDEX_KEYFRAME) ) {\n            av_log(mov->fc, AV_LOG_DEBUG, \"Nonkey frame from stream %d discarded due to AVDISCARD_NONKEY\\n\", sc->ffindex);\n            goto retry;\n        }\n\n        ret = av_get_packet(sc->pb, pkt, sample->size);\n        if (ret < 0) {\n            if (should_retry(sc->pb, ret)) {\n                mov_current_sample_dec(sc);\n            }\n            return ret;\n        }\n        if (sc->has_palette) {\n            uint8_t *pal;\n\n            pal = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE, AVPALETTE_SIZE);\n            if (!pal) {\n                av_log(mov->fc, AV_LOG_ERROR, \"Cannot append palette to packet\\n\");\n            } else {\n                memcpy(pal, sc->palette, AVPALETTE_SIZE);\n                sc->has_palette = 0;\n            }\n        }\n#if CONFIG_DV_DEMUXER\n        if (mov->dv_demux && sc->dv_audio_container) {\n            avpriv_dv_produce_packet(mov->dv_demux, pkt, pkt->data, pkt->size, pkt->pos);\n            av_freep(&pkt->data);\n            pkt->size = 0;\n            ret = avpriv_dv_get_packet(mov->dv_demux, pkt);\n            if (ret < 0)\n                return ret;\n        }\n#endif\n        if (st->codecpar->codec_id == AV_CODEC_ID_MP3 && !st->need_parsing && pkt->size > 4) {\n            if (ff_mpa_check_header(AV_RB32(pkt->data)) < 0)\n                st->need_parsing = AVSTREAM_PARSE_FULL;\n        }\n    }\n\n    pkt->stream_index = sc->ffindex;\n    pkt->dts = sample->timestamp;\n    if (sample->flags & AVINDEX_DISCARD_FRAME) {\n        pkt->flags |= AV_PKT_FLAG_DISCARD;\n    }\n    if (sc->ctts_data && sc->ctts_index < sc->ctts_count) {\n        pkt->pts = pkt->dts + sc->dts_shift + sc->ctts_data[sc->ctts_index].duration;\n        /* update ctts context */\n        sc->ctts_sample++;\n        if (sc->ctts_index < sc->ctts_count &&\n            sc->ctts_data[sc->ctts_index].count == sc->ctts_sample) {\n            sc->ctts_index++;\n            sc->ctts_sample = 0;\n        }\n    } else {\n        int64_t next_dts = (sc->current_sample < st->nb_index_entries) ?\n            st->index_entries[sc->current_sample].timestamp : st->duration;\n        pkt->duration = next_dts - pkt->dts;\n        pkt->pts = pkt->dts;\n    }\n    if (st->discard == AVDISCARD_ALL)\n        goto retry;\n    pkt->flags |= sample->flags & AVINDEX_KEYFRAME ? AV_PKT_FLAG_KEY : 0;\n    pkt->pos = sample->pos;\n\n    /* Multiple stsd handling. */\n    if (sc->stsc_data) {\n        /* Keep track of the stsc index for the given sample, then check\n        * if the stsd index is different from the last used one. */\n        sc->stsc_sample++;\n        if (mov_stsc_index_valid(sc->stsc_index, sc->stsc_count) &&\n            mov_get_stsc_samples(sc, sc->stsc_index) == sc->stsc_sample) {\n            sc->stsc_index++;\n            sc->stsc_sample = 0;\n        /* Do not check indexes after a switch. */\n        } else if (sc->stsc_data[sc->stsc_index].id > 0 &&\n                   sc->stsc_data[sc->stsc_index].id - 1 < sc->stsd_count &&\n                   sc->stsc_data[sc->stsc_index].id - 1 != sc->last_stsd_index) {\n            ret = mov_change_extradata(sc, pkt);\n            if (ret < 0)\n                return ret;\n        }\n    }\n\n    if (mov->aax_mode)\n        aax_filter(pkt->data, pkt->size, mov);\n\n    if (sc->cenc.aes_ctr) {\n        ret = cenc_filter(mov, sc, current_index, pkt->data, pkt->size);\n        if (ret) {\n            return ret;\n        }\n    }\n\n    return 0;\n}\n\nstatic int mov_seek_fragment(AVFormatContext *s, AVStream *st, int64_t timestamp)\n{\n    MOVContext *mov = s->priv_data;\n    MOVStreamContext *sc = st->priv_data;\n    int i, j;\n\n    if (!mov->fragment_index_complete)\n        return 0;\n\n    for (i = 0; i < mov->fragment_index_count; i++) {\n        if (mov->fragment_index_data[i]->track_id == st->id || !sc->has_sidx) {\n            MOVFragmentIndex *index = mov->fragment_index_data[i];\n            for (j = index->item_count - 1; j >= 0; j--) {\n                if (index->items[j].time <= timestamp) {\n                    if (index->items[j].headers_read)\n                        return 0;\n\n                    return mov_switch_root(s, index->items[j].moof_offset);\n                }\n            }\n        }\n    }\n\n    return 0;\n}\n\nstatic int mov_seek_stream(AVFormatContext *s, AVStream *st, int64_t timestamp, int flags)\n{\n    MOVStreamContext *sc = st->priv_data;\n    int sample, time_sample;\n    int i;\n\n    int ret = mov_seek_fragment(s, st, timestamp);\n    if (ret < 0)\n        return ret;\n\n    sample = av_index_search_timestamp(st, timestamp, flags);\n    av_log(s, AV_LOG_TRACE, \"stream %d, timestamp %\"PRId64\", sample %d\\n\", st->index, timestamp, sample);\n    if (sample < 0 && st->nb_index_entries && timestamp < st->index_entries[0].timestamp)\n        sample = 0;\n    if (sample < 0) /* not sure what to do */\n        return AVERROR_INVALIDDATA;\n    mov_current_sample_set(sc, sample);\n    av_log(s, AV_LOG_TRACE, \"stream %d, found sample %d\\n\", st->index, sc->current_sample);\n    /* adjust ctts index */\n    if (sc->ctts_data) {\n        time_sample = 0;\n        for (i = 0; i < sc->ctts_count; i++) {\n            int next = time_sample + sc->ctts_data[i].count;\n            if (next > sc->current_sample) {\n                sc->ctts_index = i;\n                sc->ctts_sample = sc->current_sample - time_sample;\n                break;\n            }\n            time_sample = next;\n        }\n    }\n\n    /* adjust stsd index */\n    time_sample = 0;\n    for (i = 0; i < sc->stsc_count; i++) {\n        int next = time_sample + mov_get_stsc_samples(sc, i);\n        if (next > sc->current_sample) {\n            sc->stsc_index = i;\n            sc->stsc_sample = sc->current_sample - time_sample;\n            break;\n        }\n        time_sample = next;\n    }\n\n    return sample;\n}\n\nstatic int mov_read_seek(AVFormatContext *s, int stream_index, int64_t sample_time, int flags)\n{\n    MOVContext *mc = s->priv_data;\n    AVStream *st;\n    int sample;\n    int i;\n\n    if (stream_index >= s->nb_streams)\n        return AVERROR_INVALIDDATA;\n\n    st = s->streams[stream_index];\n    sample = mov_seek_stream(s, st, sample_time, flags);\n    if (sample < 0)\n        return sample;\n\n    if (mc->seek_individually) {\n        /* adjust seek timestamp to found sample timestamp */\n        int64_t seek_timestamp = st->index_entries[sample].timestamp;\n\n        for (i = 0; i < s->nb_streams; i++) {\n            int64_t timestamp;\n            MOVStreamContext *sc = s->streams[i]->priv_data;\n            st = s->streams[i];\n            st->skip_samples = (sample_time <= 0) ? sc->start_pad : 0;\n\n            if (stream_index == i)\n                continue;\n\n            timestamp = av_rescale_q(seek_timestamp, s->streams[stream_index]->time_base, st->time_base);\n            mov_seek_stream(s, st, timestamp, flags);\n        }\n    } else {\n        for (i = 0; i < s->nb_streams; i++) {\n            MOVStreamContext *sc;\n            st = s->streams[i];\n            sc = st->priv_data;\n            mov_current_sample_set(sc, 0);\n        }\n        while (1) {\n            MOVStreamContext *sc;\n            AVIndexEntry *entry = mov_find_next_sample(s, &st);\n            if (!entry)\n                return AVERROR_INVALIDDATA;\n            sc = st->priv_data;\n            if (sc->ffindex == stream_index && sc->current_sample == sample)\n                break;\n            mov_current_sample_inc(sc);\n        }\n    }\n    return 0;\n}\n\n#define OFFSET(x) offsetof(MOVContext, x)\n#define FLAGS AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_DECODING_PARAM\nstatic const AVOption mov_options[] = {\n    {\"use_absolute_path\",\n        \"allow using absolute path when opening alias, this is a possible security issue\",\n        OFFSET(use_absolute_path), AV_OPT_TYPE_BOOL, {.i64 = 0},\n        0, 1, FLAGS},\n    {\"seek_streams_individually\",\n        \"Seek each stream individually to the to the closest point\",\n        OFFSET(seek_individually), AV_OPT_TYPE_BOOL, { .i64 = 1 },\n        0, 1, FLAGS},\n    {\"ignore_editlist\", \"Ignore the edit list atom.\", OFFSET(ignore_editlist), AV_OPT_TYPE_BOOL, {.i64 = 0},\n        0, 1, FLAGS},\n    {\"advanced_editlist\",\n        \"Modify the AVIndex according to the editlists. Use this option to decode in the order specified by the edits.\",\n        OFFSET(advanced_editlist), AV_OPT_TYPE_BOOL, {.i64 = 1},\n        0, 1, FLAGS},\n    {\"ignore_chapters\", \"\", OFFSET(ignore_chapters), AV_OPT_TYPE_BOOL, {.i64 = 0},\n        0, 1, FLAGS},\n    {\"use_mfra_for\",\n        \"use mfra for fragment timestamps\",\n        OFFSET(use_mfra_for), AV_OPT_TYPE_INT, {.i64 = FF_MOV_FLAG_MFRA_AUTO},\n        -1, FF_MOV_FLAG_MFRA_PTS, FLAGS,\n        \"use_mfra_for\"},\n    {\"auto\", \"auto\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_MFRA_AUTO}, 0, 0,\n        FLAGS, \"use_mfra_for\" },\n    {\"dts\", \"dts\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_MFRA_DTS}, 0, 0,\n        FLAGS, \"use_mfra_for\" },\n    {\"pts\", \"pts\", 0, AV_OPT_TYPE_CONST, {.i64 = FF_MOV_FLAG_MFRA_PTS}, 0, 0,\n        FLAGS, \"use_mfra_for\" },\n    { \"export_all\", \"Export unrecognized metadata entries\", OFFSET(export_all),\n        AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, .flags = FLAGS },\n    { \"export_xmp\", \"Export full XMP metadata\", OFFSET(export_xmp),\n        AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, .flags = FLAGS },\n    { \"activation_bytes\", \"Secret bytes for Audible AAX files\", OFFSET(activation_bytes),\n        AV_OPT_TYPE_BINARY, .flags = AV_OPT_FLAG_DECODING_PARAM },\n    { \"audible_fixed_key\", // extracted from libAAX_SDK.so and AAXSDKWin.dll files!\n        \"Fixed key used for handling Audible AAX files\", OFFSET(audible_fixed_key),\n        AV_OPT_TYPE_BINARY, {.str=\"77214d4b196a87cd520045fd20a51d67\"},\n        .flags = AV_OPT_FLAG_DECODING_PARAM },\n    { \"decryption_key\", \"The media decryption key (hex)\", OFFSET(decryption_key), AV_OPT_TYPE_BINARY, .flags = AV_OPT_FLAG_DECODING_PARAM },\n    { \"enable_drefs\", \"Enable external track support.\", OFFSET(enable_drefs), AV_OPT_TYPE_BOOL,\n        {.i64 = 0}, 0, 1, FLAGS },\n\n    { NULL },\n};\n\nstatic const AVClass mov_class = {\n    .class_name = \"mov,mp4,m4a,3gp,3g2,mj2\",\n    .item_name  = av_default_item_name,\n    .option     = mov_options,\n    .version    = LIBAVUTIL_VERSION_INT,\n};\n\nAVInputFormat ff_mov_demuxer = {\n    .name           = \"mov,mp4,m4a,3gp,3g2,mj2\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"QuickTime / MOV\"),\n    .priv_class     = &mov_class,\n    .priv_data_size = sizeof(MOVContext),\n    .extensions     = \"mov,mp4,m4a,3gp,3g2,mj2\",\n    .read_probe     = mov_probe,\n    .read_header    = mov_read_header,\n    .read_packet    = mov_read_packet,\n    .read_close     = mov_read_close,\n    .read_seek      = mov_read_seek,\n    .flags          = AVFMT_NO_BYTE_SEEK,\n};\n"], "filenames": ["libavformat/mov.c"], "buggy_code_start_loc": [6096], "buggy_code_end_loc": [6096], "fixing_code_start_loc": [6097], "fixing_code_end_loc": [6104], "type": "CWE-834", "message": "In libavformat/mov.c in FFmpeg 3.3.3, a DoS in read_tfra() due to lack of an EOF (End of File) check might cause huge CPU and memory consumption. When a crafted MOV file, which claims a large \"item_count\" field in the header but does not contain sufficient backing data, is provided, the loop would consume huge CPU and memory resources, since there is no EOF check inside the loop.", "other": {"cve": {"id": "CVE-2017-14222", "sourceIdentifier": "cve@mitre.org", "published": "2017-09-09T01:29:02.737", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In libavformat/mov.c in FFmpeg 3.3.3, a DoS in read_tfra() due to lack of an EOF (End of File) check might cause huge CPU and memory consumption. When a crafted MOV file, which claims a large \"item_count\" field in the header but does not contain sufficient backing data, is provided, the loop would consume huge CPU and memory resources, since there is no EOF check inside the loop."}, {"lang": "es", "value": "En libavformat/mov.c en FFmpeg 3.3.3, una denegaci\u00f3n de servicio en read_tfra() debido a una falta de comprobaci\u00f3n EOE (End of File) podr\u00eda provocar un gran consumo de CPU y memoria. Cuando se proporciona un archivo MOV manipulado, que reclama un gran campo \"item_count\" en el encabezado pero que no contiene datos de respaldo suficientes, el bucle consumir\u00eda una gran cantidad de recursos de CPU y de memoria, ya que no existe una comprobaci\u00f3n EOF dentro del bucle."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.1}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-834"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:3.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "A97A44A7-DFB8-4DA8-8A4A-DBC1FF255D9A"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3996", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/100701", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/9cb4eb772839c5e1de2855d126bf74ff16d13382", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/9cb4eb772839c5e1de2855d126bf74ff16d13382"}}