{"buggy_code": ["const Promise = require('bluebird');\nconst tpl = require('@tryghost/tpl');\nconst errors = require('@tryghost/errors');\nconst models = require('../../models');\nconst ALLOWED_INCLUDES = ['count.posts'];\n\nconst messages = {\n    notFound: 'Author not found.'\n};\n\nmodule.exports = {\n    docName: 'authors',\n\n    browse: {\n        options: [\n            'include',\n            'filter',\n            'fields',\n            'limit',\n            'order',\n            'page'\n        ],\n        validation: {\n            options: {\n                include: {\n                    values: ALLOWED_INCLUDES\n                }\n            }\n        },\n        permissions: true,\n        query(frame) {\n            return models.Author.findPage(frame.options);\n        }\n    },\n\n    read: {\n        options: [\n            'include',\n            'filter',\n            'fields'\n        ],\n        data: [\n            'id',\n            'slug',\n            'email',\n            'role'\n        ],\n        validation: {\n            options: {\n                include: {\n                    values: ALLOWED_INCLUDES\n                }\n            }\n        },\n        permissions: true,\n        query(frame) {\n            return models.Author.findOne(frame.data, frame.options)\n                .then((model) => {\n                    if (!model) {\n                        return Promise.reject(new errors.NotFoundError({\n                            message: tpl(messages.notFound)\n                        }));\n                    }\n\n                    return model;\n                });\n        }\n    }\n};\n", "const tpl = require('@tryghost/tpl');\nconst errors = require('@tryghost/errors');\nconst models = require('../../models');\n\nconst ALLOWED_INCLUDES = ['tags', 'authors', 'tiers'];\n\nconst messages = {\n    pageNotFound: 'Page not found.'\n};\n\nmodule.exports = {\n    docName: 'pages',\n\n    browse: {\n        options: [\n            'include',\n            'filter',\n            'fields',\n            'formats',\n            'absolute_urls',\n            'page',\n            'limit',\n            'order',\n            'debug'\n        ],\n        validation: {\n            options: {\n                include: {\n                    values: ALLOWED_INCLUDES\n                },\n                formats: {\n                    values: models.Post.allowedFormats\n                }\n            }\n        },\n        permissions: true,\n        query(frame) {\n            return models.Post.findPage(frame.options);\n        }\n    },\n\n    read: {\n        options: [\n            'include',\n            'fields',\n            'formats',\n            'debug',\n            'absolute_urls'\n        ],\n        data: [\n            'id',\n            'slug',\n            'uuid'\n        ],\n        validation: {\n            options: {\n                include: {\n                    values: ALLOWED_INCLUDES\n                },\n                formats: {\n                    values: models.Post.allowedFormats\n                }\n            }\n        },\n        permissions: true,\n        query(frame) {\n            return models.Post.findOne(frame.data, frame.options)\n                .then((model) => {\n                    if (!model) {\n                        throw new errors.NotFoundError({\n                            message: tpl(messages.pageNotFound)\n                        });\n                    }\n\n                    return model;\n                });\n        }\n    }\n};\n", "const models = require('../../models');\nconst tpl = require('@tryghost/tpl');\nconst errors = require('@tryghost/errors');\nconst postsPublicService = require('../../services/posts-public');\n\nconst allowedIncludes = ['tags', 'authors', 'tiers', 'sentiment'];\n\nconst messages = {\n    postNotFound: 'Post not found.'\n};\n\nmodule.exports = {\n    docName: 'posts',\n\n    browse: {\n        cache: postsPublicService.api?.cache,\n        options: [\n            'include',\n            'filter',\n            'fields',\n            'formats',\n            'limit',\n            'order',\n            'page',\n            'debug',\n            'absolute_urls'\n        ],\n        validation: {\n            options: {\n                include: {\n                    values: allowedIncludes\n                },\n                formats: {\n                    values: models.Post.allowedFormats\n                }\n            }\n        },\n        permissions: true,\n        query(frame) {\n            return models.Post.findPage(frame.options);\n        }\n    },\n\n    read: {\n        options: [\n            'include',\n            'fields',\n            'formats',\n            'debug',\n            'absolute_urls'\n        ],\n        data: [\n            'id',\n            'slug',\n            'uuid'\n        ],\n        validation: {\n            options: {\n                include: {\n                    values: allowedIncludes\n                },\n                formats: {\n                    values: models.Post.allowedFormats\n                }\n            }\n        },\n        permissions: true,\n        query(frame) {\n            return models.Post.findOne(frame.data, frame.options)\n                .then((model) => {\n                    if (!model) {\n                        throw new errors.NotFoundError({\n                            message: tpl(messages.postNotFound)\n                        });\n                    }\n\n                    return model;\n                });\n        }\n    }\n};\n", "const should = require('should');\nconst supertest = require('supertest');\nconst localUtils = require('./utils');\nconst testUtils = require('../../../utils');\nconst configUtils = require('../../../utils/configUtils');\nconst config = require('../../../../core/shared/config');\n\ndescribe('Authors Content API', function () {\n    const validKey = localUtils.getValidKey();\n    let request;\n\n    before(async function () {\n        await localUtils.startGhost();\n        request = supertest.agent(config.get('url'));\n        await testUtils.initFixtures('owner:post', 'users', 'user:inactive', 'posts', 'api_keys');\n    });\n\n    afterEach(async function () {\n        await configUtils.restore();\n    });\n\n    it('can read authors with fields', function () {\n        return request.get(localUtils.API.getApiQuery(`authors/1/?key=${validKey}&fields=name`))\n            .set('Origin', testUtils.API.getURL())\n            .expect('Content-Type', /json/)\n            .expect('Cache-Control', testUtils.cacheRules.public)\n            .expect(200)\n            .then((res) => {\n                should.not.exist(res.headers['x-cache-invalidate']);\n\n                // We don't expose any other attrs.\n                localUtils.API.checkResponse(res.body.authors[0], 'author', null, null, ['id', 'name']);\n            });\n    });\n\n    it('browse authors with slug filter, should order in slug order', function () {\n        return request.get(localUtils.API.getApiQuery(`authors/?key=${validKey}&filter=slug:[joe-bloggs,ghost,slimer-mcectoplasm]`))\n            .expect('Content-Type', /json/)\n            .expect('Cache-Control', testUtils.cacheRules.public)\n            .expect(200)\n            .then((res) => {\n                const jsonResponse = res.body;\n\n                jsonResponse.authors.should.be.an.Array().with.lengthOf(3);\n                jsonResponse.authors[0].slug.should.equal('joe-bloggs');\n                jsonResponse.authors[1].slug.should.equal('ghost');\n                jsonResponse.authors[2].slug.should.equal('slimer-mcectoplasm');\n            });\n    });\n});\n", "const should = require('should');\nconst supertest = require('supertest');\nconst testUtils = require('../../../utils');\nconst localUtils = require('./utils');\nconst configUtils = require('../../../utils/configUtils');\nconst config = require('../../../../core/shared/config');\n\nlet request;\n\ndescribe('api/endpoints/content/pages', function () {\n    const key = localUtils.getValidKey();\n\n    before(async function () {\n        await localUtils.startGhost();\n        request = supertest.agent(config.get('url'));\n        await testUtils.initFixtures('users', 'user:inactive', 'posts', 'tags:extra', 'api_keys');\n    });\n\n    afterEach(async function () {\n        await configUtils.restore();\n    });\n\n    it('Returns a validation error when unsupported \"page\" filter is used', function () {\n        return request.get(localUtils.API.getApiQuery(`pages/?key=${key}&filter=page:false`))\n            .set('Origin', testUtils.API.getURL())\n            .expect('Content-Type', /json/)\n            .expect('Cache-Control', testUtils.cacheRules.private)\n            .expect(400);\n    });\n\n    it('browse pages with slug filter, should order in slug order', function () {\n        return request.get(localUtils.API.getApiQuery(`pages/?key=${key}&filter=slug:[static-page-test]`))\n            .expect('Content-Type', /json/)\n            .expect('Cache-Control', testUtils.cacheRules.public)\n            .expect(200)\n            .then((res) => {\n                const jsonResponse = res.body;\n\n                jsonResponse.pages.should.be.an.Array().with.lengthOf(1);\n                jsonResponse.pages[0].slug.should.equal('static-page-test');\n            });\n    });\n\n    it('can\\'t read post', function () {\n        return request\n            .get(localUtils.API.getApiQuery(`pages/${testUtils.DataGenerator.Content.posts[0].id}/?key=${key}`))\n            .set('Origin', testUtils.API.getURL())\n            .expect('Content-Type', /json/)\n            .expect('Cache-Control', testUtils.cacheRules.noCache)\n            .expect(404);\n    });\n});\n", "const should = require('should');\nconst supertest = require('supertest');\nconst _ = require('lodash');\nconst testUtils = require('../../../utils');\nconst localUtils = require('./utils');\nconst configUtils = require('../../../utils/configUtils');\nconst urlUtils = require('../../../utils/urlUtils');\nconst config = require('../../../../core/shared/config');\n\ndescribe('api/endpoints/content/posts', function () {\n    let request;\n\n    before(async function () {\n        await localUtils.startGhost();\n        request = supertest.agent(config.get('url'));\n        await testUtils.initFixtures('users', 'user:inactive', 'posts', 'tags:extra', 'api_keys');\n    });\n\n    afterEach(async function () {\n        await configUtils.restore();\n        urlUtils.restore();\n    });\n\n    const validKey = localUtils.getValidKey();\n\n    it('browse posts', function (done) {\n        request.get(localUtils.API.getApiQuery(`posts/?key=${validKey}`))\n            .set('Origin', testUtils.API.getURL())\n            .expect('Content-Type', /json/)\n            .expect('Cache-Control', testUtils.cacheRules.public)\n            .expect(200)\n            .end(function (err, res) {\n                if (err) {\n                    return done(err);\n                }\n\n                res.headers.vary.should.eql('Accept-Version, Accept-Encoding');\n                should.exist(res.headers['access-control-allow-origin']);\n                should.not.exist(res.headers['x-cache-invalidate']);\n\n                const jsonResponse = res.body;\n                should.exist(jsonResponse.posts);\n                localUtils.API.checkResponse(jsonResponse, 'posts');\n                jsonResponse.posts.should.have.length(11);\n                localUtils.API.checkResponse(jsonResponse.posts[0], 'post');\n                localUtils.API.checkResponse(jsonResponse.meta.pagination, 'pagination');\n                _.isBoolean(jsonResponse.posts[0].featured).should.eql(true);\n\n                // Default order 'published_at desc' check\n                jsonResponse.posts[0].slug.should.eql('welcome');\n                jsonResponse.posts[6].slug.should.eql('integrations');\n\n                // check meta response for this test\n                jsonResponse.meta.pagination.page.should.eql(1);\n                jsonResponse.meta.pagination.limit.should.eql(15);\n                jsonResponse.meta.pagination.pages.should.eql(1);\n                jsonResponse.meta.pagination.total.should.eql(11);\n                jsonResponse.meta.pagination.hasOwnProperty('next').should.be.true();\n                jsonResponse.meta.pagination.hasOwnProperty('prev').should.be.true();\n                should.not.exist(jsonResponse.meta.pagination.next);\n                should.not.exist(jsonResponse.meta.pagination.prev);\n\n                done();\n            });\n    });\n\n    it('browse posts with related authors/tags also returns primary_author/primary_tag', function (done) {\n        request.get(localUtils.API.getApiQuery(`posts/?key=${validKey}&include=authors,tags`))\n            .set('Origin', testUtils.API.getURL())\n            .expect('Content-Type', /json/)\n            .expect('Cache-Control', testUtils.cacheRules.public)\n            .expect(200)\n            .end(function (err, res) {\n                if (err) {\n                    return done(err);\n                }\n\n                res.headers.vary.should.eql('Accept-Version, Accept-Encoding');\n                should.exist(res.headers['access-control-allow-origin']);\n                should.not.exist(res.headers['x-cache-invalidate']);\n\n                const jsonResponse = res.body;\n                should.exist(jsonResponse.posts);\n                localUtils.API.checkResponse(jsonResponse, 'posts');\n                jsonResponse.posts.should.have.length(11);\n                localUtils.API.checkResponse(\n                    jsonResponse.posts[0],\n                    'post',\n                    ['authors', 'tags', 'primary_tag', 'primary_author'],\n                    null\n                );\n\n                localUtils.API.checkResponse(jsonResponse.meta.pagination, 'pagination');\n                _.isBoolean(jsonResponse.posts[0].featured).should.eql(true);\n\n                // Default order 'published_at desc' check\n                jsonResponse.posts[0].slug.should.eql('welcome');\n                jsonResponse.posts[6].slug.should.eql('integrations');\n\n                // check meta response for this test\n                jsonResponse.meta.pagination.page.should.eql(1);\n                jsonResponse.meta.pagination.limit.should.eql(15);\n                jsonResponse.meta.pagination.pages.should.eql(1);\n                jsonResponse.meta.pagination.total.should.eql(11);\n                jsonResponse.meta.pagination.hasOwnProperty('next').should.be.true();\n                jsonResponse.meta.pagination.hasOwnProperty('prev').should.be.true();\n                should.not.exist(jsonResponse.meta.pagination.next);\n                should.not.exist(jsonResponse.meta.pagination.prev);\n\n                done();\n            });\n    });\n\n    it('browse posts with unsupported \"page\" filter returns a request validation error', function () {\n        return request.get(localUtils.API.getApiQuery(`posts/?key=${validKey}&filter=page:true,featured:true`))\n            .expect('Content-Type', /json/)\n            .expect('Cache-Control', testUtils.cacheRules.private)\n            .expect(400);\n    });\n\n    it('browse posts with published and draft status, should not return drafts', function (done) {\n        request.get(localUtils.API.getApiQuery(`posts/?key=${validKey}&filter=status:published,status:draft`))\n            .expect('Content-Type', /json/)\n            .expect('Cache-Control', testUtils.cacheRules.public)\n            .expect(200)\n            .end(function (err, res) {\n                if (err) {\n                    return done(err);\n                }\n                const jsonResponse = res.body;\n\n                jsonResponse.posts.should.be.an.Array().with.lengthOf(11);\n\n                done();\n            });\n    });\n\n    it('browse posts with slug filter, should order in slug order', function () {\n        return request.get(localUtils.API.getApiQuery(`posts/?key=${validKey}&filter=slug:[write,ghostly-kitchen-sink,grow]`))\n            .expect('Content-Type', /json/)\n            .expect('Cache-Control', testUtils.cacheRules.public)\n            .expect(200)\n            .then((res) => {\n                const jsonResponse = res.body;\n\n                jsonResponse.posts.should.be.an.Array().with.lengthOf(3);\n                jsonResponse.posts[0].slug.should.equal('write');\n                jsonResponse.posts[1].slug.should.equal('ghostly-kitchen-sink');\n                jsonResponse.posts[2].slug.should.equal('grow');\n            });\n    });\n\n    it('browse posts with slug filter should order taking order parameter into account', function () {\n        return request.get(localUtils.API.getApiQuery(`posts/?key=${validKey}&order=slug%20DESC&filter=slug:[write,ghostly-kitchen-sink,grow]`))\n            .expect('Content-Type', /json/)\n            .expect('Cache-Control', testUtils.cacheRules.public)\n            .expect(200)\n            .then((res) => {\n                const jsonResponse = res.body;\n\n                jsonResponse.posts.should.be.an.Array().with.lengthOf(3);\n                jsonResponse.posts[0].slug.should.equal('write');\n                jsonResponse.posts[1].slug.should.equal('grow');\n                jsonResponse.posts[2].slug.should.equal('ghostly-kitchen-sink');\n            });\n    });\n\n    it('ensure origin header on redirect is not getting lost', function (done) {\n        // NOTE: force a redirect to the admin url\n        configUtils.set('admin:url', 'http://localhost:9999');\n        urlUtils.stubUrlUtilsFromConfig();\n\n        request.get(localUtils.API.getApiQuery(`posts?key=${validKey}`))\n            .set('Origin', 'https://example.com')\n            // 301 Redirects _should_ be cached\n            .expect('Cache-Control', testUtils.cacheRules.year)\n            .expect(301)\n            .end(function (err, res) {\n                if (err) {\n                    return done(err);\n                }\n\n                res.headers.vary.should.eql('Accept-Version, Accept, Accept-Encoding');\n                res.headers.location.should.eql(`http://localhost:9999/ghost/api/content/posts/?key=${validKey}`);\n                should.exist(res.headers['access-control-allow-origin']);\n                should.not.exist(res.headers['x-cache-invalidate']);\n                done();\n            });\n    });\n\n    it('can\\'t read page', function () {\n        return request\n            .get(localUtils.API.getApiQuery(`posts/${testUtils.DataGenerator.Content.posts[5].id}/?key=${validKey}`))\n            .set('Origin', testUtils.API.getURL())\n            .expect('Content-Type', /json/)\n            .expect('Cache-Control', testUtils.cacheRules.noCache)\n            .expect(404);\n    });\n\n    it('can read post with fields', function () {\n        const complexPostId = testUtils.DataGenerator.Content.posts.find(p => p.slug === 'not-so-short-bit-complex').id;\n\n        return request\n            .get(localUtils.API.getApiQuery(`posts/${complexPostId}/?key=${validKey}&fields=title,slug,excerpt&formats=plaintext`))\n            .set('Origin', testUtils.API.getURL())\n            .expect('Content-Type', /json/)\n            .expect('Cache-Control', testUtils.cacheRules.public)\n            .expect(200)\n            .then((res) => {\n                localUtils.API.checkResponse(res.body.posts[0], 'post', null, null, ['id', 'title', 'slug', 'excerpt', 'plaintext']);\n\n                // excerpt should transform links to absolute URLs\n                res.body.posts[0].excerpt.should.match(/\\* Aliquam/);\n            });\n    });\n\n    describe('content gating', function () {\n        let publicPost;\n        let membersPost;\n        let paidPost;\n        let membersPostWithPaywallCard;\n\n        before (function () {\n            publicPost = testUtils.DataGenerator.forKnex.createPost({\n                slug: 'free-to-see',\n                visibility: 'public'\n            });\n\n            membersPost = testUtils.DataGenerator.forKnex.createPost({\n                slug: 'thou-shalt-not-be-seen',\n                visibility: 'members'\n            });\n\n            paidPost = testUtils.DataGenerator.forKnex.createPost({\n                slug: 'thou-shalt-be-paid-for',\n                visibility: 'paid'\n            });\n\n            membersPostWithPaywallCard = testUtils.DataGenerator.forKnex.createPost({\n                slug: 'thou-shalt-have-a-taste',\n                visibility: 'members',\n                mobiledoc: '{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"paywall\",{}]],\"sections\":[[1,\"p\",[[0,[],0,\"Free content\"]]],[10,0],[1,\"p\",[[0,[],0,\"Members content\"]]]]}',\n                html: '<p>Free content</p><!--members-only--><p>Members content</p>'\n            });\n\n            return testUtils.fixtures.insertPosts([\n                publicPost,\n                membersPost,\n                paidPost,\n                membersPostWithPaywallCard\n            ]);\n        });\n\n        it('public post fields are always visible', function () {\n            return request\n                .get(localUtils.API.getApiQuery(`posts/${publicPost.id}/?key=${validKey}&fields=slug,html,plaintext&formats=html,plaintext`))\n                .set('Origin', testUtils.API.getURL())\n                .expect('Content-Type', /json/)\n                .expect('Cache-Control', testUtils.cacheRules.public)\n                .expect(200)\n                .then((res) => {\n                    const jsonResponse = res.body;\n                    should.exist(jsonResponse.posts);\n                    const post = jsonResponse.posts[0];\n\n                    localUtils.API.checkResponse(post, 'post', null, null, ['id', 'slug', 'html', 'plaintext']);\n                    post.slug.should.eql('free-to-see');\n                    post.html.should.not.eql('');\n                    post.plaintext.should.not.eql('');\n                });\n        });\n\n        it('cannot read members only post content', function () {\n            return request\n                .get(localUtils.API.getApiQuery(`posts/${membersPost.id}/?key=${validKey}`))\n                .set('Origin', testUtils.API.getURL())\n                .expect('Content-Type', /json/)\n                .expect('Cache-Control', testUtils.cacheRules.public)\n                .expect(200)\n                .then((res) => {\n                    const jsonResponse = res.body;\n                    should.exist(jsonResponse.posts);\n                    const post = jsonResponse.posts[0];\n\n                    localUtils.API.checkResponse(post, 'post', null, null);\n                    post.slug.should.eql('thou-shalt-not-be-seen');\n                    post.html.should.eql('');\n                    post.excerpt.should.eql('');\n                });\n        });\n\n        it('cannot read paid only post content', function () {\n            return request\n                .get(localUtils.API.getApiQuery(`posts/${paidPost.id}/?key=${validKey}`))\n                .set('Origin', testUtils.API.getURL())\n                .expect('Content-Type', /json/)\n                .expect('Cache-Control', testUtils.cacheRules.public)\n                .expect(200)\n                .then((res) => {\n                    const jsonResponse = res.body;\n                    should.exist(jsonResponse.posts);\n                    const post = jsonResponse.posts[0];\n\n                    localUtils.API.checkResponse(post, 'post', null, null);\n                    post.slug.should.eql('thou-shalt-be-paid-for');\n                    post.html.should.eql('');\n                    post.excerpt.should.eql('');\n                });\n        });\n\n        it('cannot read members only post plaintext', function () {\n            return request\n                .get(localUtils.API.getApiQuery(`posts/${membersPost.id}/?key=${validKey}&formats=html,plaintext&fields=html,plaintext`))\n                .set('Origin', testUtils.API.getURL())\n                .expect('Content-Type', /json/)\n                .expect('Cache-Control', testUtils.cacheRules.public)\n                .expect(200)\n                .then((res) => {\n                    const jsonResponse = res.body;\n                    should.exist(jsonResponse.posts);\n                    const post = jsonResponse.posts[0];\n\n                    localUtils.API.checkResponse(post, 'post', null, null, ['id', 'html', 'plaintext']);\n                    post.html.should.eql('');\n                    post.plaintext.should.eql('');\n                });\n        });\n\n        it('can read \"free\" html and plaintext content of members post when using paywall card', function () {\n            return request\n                .get(localUtils.API.getApiQuery(`posts/${membersPostWithPaywallCard.id}/?key=${validKey}&formats=html,plaintext`))\n                .set('Origin', testUtils.API.getURL())\n                .expect('Content-Type', /json/)\n                .expect('Cache-Control', testUtils.cacheRules.public)\n                .expect(200)\n                .then((res) => {\n                    const jsonResponse = res.body;\n                    should.exist(jsonResponse.posts);\n                    const post = jsonResponse.posts[0];\n\n                    localUtils.API.checkResponse(post, 'post', ['plaintext']);\n                    post.html.should.eql('<p>Free content</p>');\n                    post.plaintext.should.eql('Free content');\n                    post.excerpt.should.eql('Free content');\n                });\n        });\n\n        it('cannot browse members only posts content', function () {\n            return request.get(localUtils.API.getApiQuery(`posts/?key=${validKey}`))\n                .set('Origin', testUtils.API.getURL())\n                .expect('Content-Type', /json/)\n                .expect('Cache-Control', testUtils.cacheRules.public)\n                .expect(200)\n                .then((res) => {\n                    res.headers.vary.should.eql('Accept-Version, Accept-Encoding');\n                    should.exist(res.headers['access-control-allow-origin']);\n                    should.not.exist(res.headers['x-cache-invalidate']);\n\n                    const jsonResponse = res.body;\n                    should.exist(jsonResponse.posts);\n                    localUtils.API.checkResponse(jsonResponse, 'posts');\n                    jsonResponse.posts.should.have.length(15);\n                    localUtils.API.checkResponse(jsonResponse.posts[0], 'post', null, null);\n                    localUtils.API.checkResponse(jsonResponse.meta.pagination, 'pagination');\n                    _.isBoolean(jsonResponse.posts[0].featured).should.eql(true);\n\n                    const membersOnlySlugs = [\n                        'thou-shalt-not-be-seen',\n                        'thou-shalt-be-paid-for'\n                    ];\n\n                    const freeToSeeSlugs = [\n                        'free-to-see',\n                        'thou-shalt-have-a-taste',\n                        'sell'\n                    ];\n\n                    let seen = 0;\n\n                    jsonResponse.posts.forEach((post) => {\n                        if (membersOnlySlugs.indexOf(post.slug) > -1) {\n                            post.html.should.eql('');\n                            post.excerpt.should.eql('');\n                            seen += 1;\n                        } else if (freeToSeeSlugs.indexOf(post.slug) > -1) {\n                            post.html.should.not.eql('');\n                            post.excerpt.should.not.eql('');\n                            seen += 1;\n                        }\n                    });\n\n                    seen.should.eql(membersOnlySlugs.length + freeToSeeSlugs.length);\n\n                    // check meta response for this test\n                    jsonResponse.meta.pagination.page.should.eql(1);\n                    jsonResponse.meta.pagination.limit.should.eql(15);\n                    jsonResponse.meta.pagination.pages.should.eql(1);\n                    jsonResponse.meta.pagination.total.should.eql(15);\n                    jsonResponse.meta.pagination.hasOwnProperty('next').should.be.true();\n                    jsonResponse.meta.pagination.hasOwnProperty('prev').should.be.true();\n                    should.not.exist(jsonResponse.meta.pagination.next);\n                    should.not.exist(jsonResponse.meta.pagination.prev);\n                });\n        });\n    });\n});\n", "require('../../core/server/overrides');\n\n// Utility Packages\nconst {sequence} = require('@tryghost/promise');\nconst debug = require('@tryghost/debug')('test:utils');\n\nconst _ = require('lodash');\n\n// Ghost Internals\nconst models = require('../../core/server/models');\n\n// Other Test Utilities\nconst e2eUtils = require('./e2e-utils');\nconst APIUtils = require('./api');\nconst dbUtils = require('./db-utils');\nconst fixtureUtils = require('./fixture-utils');\nconst redirects = require('./redirects');\nconst cacheRules = require('./fixtures/cache-rules');\nconst context = require('./fixtures/context');\nconst DataGenerator = require('./fixtures/data-generator');\nconst filterData = require('./fixtures/filter-param');\n\n// Require additional assertions which help us keep our tests small and clear\nrequire('./assertions');\n\n// ## Test Setup and Teardown\n\nconst initFixtures = function initFixtures() {\n    const options = _.merge({init: true}, _.transform(arguments, function (result, val) {\n        result[val] = true;\n    }));\n\n    const fixtureOps = fixtureUtils.getFixtureOps(options);\n\n    return sequence(fixtureOps);\n};\n\n/**\n * ## Setup Integration Tests\n * Setup takes a list of arguments like: 'default', 'tag', 'perms:tag', 'perms:init'\n * Setup does 'init' (DB) by default\n */\nconst setup = function setup() {\n    /*eslint no-invalid-this: \"off\"*/\n    const self = this;\n\n    const args = arguments;\n\n    return function innerSetup() {\n        debug('Setup start');\n        models.init();\n        return initFixtures\n            .apply(self, args)\n            .finally(() => {\n                debug('Setup end');\n            });\n    };\n};\n\nconst createUser = function createUser(options) {\n    const user = options.user;\n    const role = options.role;\n\n    return models.Role.fetchAll(context.internal)\n        .then(function (roles) {\n            roles = roles.toJSON();\n            user.roles = [_.find(roles, {name: role})];\n\n            return models.User.add(user, context.internal)\n                .then(function () {\n                    return user;\n                });\n        });\n};\n\nconst createPost = function createPost(options) {\n    const post = DataGenerator.forKnex.createPost(options.post);\n\n    return models.Post.add(post, context.internal);\n};\n\nconst createEmail = function createEmail(options) {\n    const email = DataGenerator.forKnex.createEmail(options.email);\n    return models.Email.add(email, context.internal);\n};\n\nconst createEmailedPost = async function createEmailedPost({postOptions, emailOptions}) {\n    const post = await createPost(postOptions);\n    emailOptions.email.post_id = post.id;\n    const email = await createEmail(emailOptions);\n\n    return {post, email};\n};\n\nmodule.exports = {\n    startGhost: e2eUtils.startGhost,\n    stopGhost: e2eUtils.stopGhost,\n    getExistingData: e2eUtils.getExistingData,\n\n    teardownDb: dbUtils.teardown,\n    truncate: dbUtils.truncate,\n    setup: setup,\n    createUser: createUser,\n    createPost: createPost,\n    createEmailedPost,\n\n    /**\n     * renderObject:    res.render(view, dbResponse)\n     * templateOptions: hbs.updateTemplateOptions(...)\n     */\n    createHbsResponse: function createHbsResponse(options) {\n        const renderObject = options.renderObject || {};\n        const templateOptions = options.templateOptions;\n        const locals = options.locals || {};\n\n        const hbsStructure = {\n            data: {\n                site: {},\n                config: {},\n                labs: {},\n                root: {\n                    _locals: {}\n                }\n            }\n        };\n\n        _.merge(hbsStructure.data, templateOptions);\n        _.merge(hbsStructure.data.root, renderObject);\n        _.merge(hbsStructure.data.root, locals);\n        hbsStructure.data.root._locals = locals;\n\n        return hbsStructure;\n    },\n\n    initFixtures: initFixtures,\n    initData: dbUtils.initData,\n    clearData: dbUtils.clearData,\n    setupRedirectsFile: redirects.setupFile,\n\n    fixtures: fixtureUtils.fixtures,\n\n    DataGenerator: DataGenerator,\n    filterData: filterData,\n    API: APIUtils({getFixtureOps: fixtureUtils.getFixtureOps}),\n\n    // Helpers to make it easier to write tests which are easy to read\n    context: context,\n    permissions: {\n        owner: {user: {roles: [DataGenerator.Content.roles[3]]}},\n        admin: {user: {roles: [DataGenerator.Content.roles[0]]}},\n        editor: {user: {roles: [DataGenerator.Content.roles[1]]}},\n        author: {user: {roles: [DataGenerator.Content.roles[2]]}},\n        contributor: {user: {roles: [DataGenerator.Content.roles[4]]}}\n    },\n    roles: {\n        ids: {\n            owner: DataGenerator.Content.roles[3].id,\n            admin: DataGenerator.Content.roles[0].id,\n            editor: DataGenerator.Content.roles[1].id,\n            author: DataGenerator.Content.roles[2].id,\n            contributor: DataGenerator.Content.roles[4].id\n        }\n    },\n    cacheRules: cacheRules\n};\n"], "fixing_code": ["const Promise = require('bluebird');\nconst tpl = require('@tryghost/tpl');\nconst errors = require('@tryghost/errors');\nconst {mapQuery} = require('@tryghost/mongo-utils');\nconst models = require('../../models');\nconst ALLOWED_INCLUDES = ['count.posts'];\n\nconst messages = {\n    notFound: 'Author not found.'\n};\n\nconst rejectPrivateFieldsTransformer = input => mapQuery(input, function (value, key) {\n    const lowerCaseKey = key.toLowerCase();\n    if (lowerCaseKey.startsWith('password') || lowerCaseKey.startsWith('email')) {\n        return;\n    }\n\n    return {\n        [key]: value\n    };\n});\n\nmodule.exports = {\n    docName: 'authors',\n\n    browse: {\n        options: [\n            'include',\n            'filter',\n            'fields',\n            'limit',\n            'order',\n            'page'\n        ],\n        validation: {\n            options: {\n                include: {\n                    values: ALLOWED_INCLUDES\n                }\n            }\n        },\n        permissions: true,\n        query(frame) {\n            const options = {\n                ...frame.options,\n                mongoTransformer: rejectPrivateFieldsTransformer\n            };\n            return models.Author.findPage(options);\n        }\n    },\n\n    read: {\n        options: [\n            'include',\n            'filter',\n            'fields'\n        ],\n        data: [\n            'id',\n            'slug',\n            'email',\n            'role'\n        ],\n        validation: {\n            options: {\n                include: {\n                    values: ALLOWED_INCLUDES\n                }\n            }\n        },\n        permissions: true,\n        query(frame) {\n            const options = {\n                ...frame.options,\n                mongoTransformer: rejectPrivateFieldsTransformer\n            };\n            return models.Author.findOne(frame.data, options)\n                .then((model) => {\n                    if (!model) {\n                        return Promise.reject(new errors.NotFoundError({\n                            message: tpl(messages.notFound)\n                        }));\n                    }\n\n                    return model;\n                });\n        }\n    }\n};\n", "const tpl = require('@tryghost/tpl');\nconst errors = require('@tryghost/errors');\nconst {mapQuery} = require('@tryghost/mongo-utils');\nconst models = require('../../models');\n\nconst ALLOWED_INCLUDES = ['tags', 'authors', 'tiers'];\n\nconst messages = {\n    pageNotFound: 'Page not found.'\n};\n\nconst rejectPrivateFieldsTransformer = input => mapQuery(input, function (value, key) {\n    let lowerCaseKey = key.toLowerCase();\n    if (lowerCaseKey.startsWith('authors.password') || lowerCaseKey.startsWith('authors.email')) {\n        return;\n    }\n\n    return {\n        [key]: value\n    };\n});\n\nmodule.exports = {\n    docName: 'pages',\n\n    browse: {\n        options: [\n            'include',\n            'filter',\n            'fields',\n            'formats',\n            'absolute_urls',\n            'page',\n            'limit',\n            'order',\n            'debug'\n        ],\n        validation: {\n            options: {\n                include: {\n                    values: ALLOWED_INCLUDES\n                },\n                formats: {\n                    values: models.Post.allowedFormats\n                }\n            }\n        },\n        permissions: true,\n        query(frame) {\n            const options = {\n                ...frame.options,\n                mongoTransformer: rejectPrivateFieldsTransformer\n            };\n            return models.Post.findPage(options);\n        }\n    },\n\n    read: {\n        options: [\n            'include',\n            'fields',\n            'formats',\n            'debug',\n            'absolute_urls'\n        ],\n        data: [\n            'id',\n            'slug',\n            'uuid'\n        ],\n        validation: {\n            options: {\n                include: {\n                    values: ALLOWED_INCLUDES\n                },\n                formats: {\n                    values: models.Post.allowedFormats\n                }\n            }\n        },\n        permissions: true,\n        query(frame) {\n            const options = {\n                ...frame.options,\n                mongoTransformer: rejectPrivateFieldsTransformer\n            };\n            return models.Post.findOne(frame.data, options)\n                .then((model) => {\n                    if (!model) {\n                        throw new errors.NotFoundError({\n                            message: tpl(messages.pageNotFound)\n                        });\n                    }\n\n                    return model;\n                });\n        }\n    }\n};\n", "const models = require('../../models');\nconst tpl = require('@tryghost/tpl');\nconst errors = require('@tryghost/errors');\nconst {mapQuery} = require('@tryghost/mongo-utils');\nconst postsPublicService = require('../../services/posts-public');\n\nconst allowedIncludes = ['tags', 'authors', 'tiers', 'sentiment'];\n\nconst messages = {\n    postNotFound: 'Post not found.'\n};\n\nconst rejectPrivateFieldsTransformer = input => mapQuery(input, function (value, key) {\n    const lowerCaseKey = key.toLowerCase();\n    if (lowerCaseKey.startsWith('authors.password') || lowerCaseKey.startsWith('authors.email')) {\n        return;\n    }\n\n    return {\n        [key]: value\n    };\n});\n\nmodule.exports = {\n    docName: 'posts',\n\n    browse: {\n        cache: postsPublicService.api?.cache,\n        options: [\n            'include',\n            'filter',\n            'fields',\n            'formats',\n            'limit',\n            'order',\n            'page',\n            'debug',\n            'absolute_urls'\n        ],\n        validation: {\n            options: {\n                include: {\n                    values: allowedIncludes\n                },\n                formats: {\n                    values: models.Post.allowedFormats\n                }\n            }\n        },\n        permissions: true,\n        query(frame) {\n            const options = {\n                ...frame.options,\n                mongoTransformer: rejectPrivateFieldsTransformer\n            };\n            return models.Post.findPage(options);\n        }\n    },\n\n    read: {\n        options: [\n            'include',\n            'fields',\n            'formats',\n            'debug',\n            'absolute_urls'\n        ],\n        data: [\n            'id',\n            'slug',\n            'uuid'\n        ],\n        validation: {\n            options: {\n                include: {\n                    values: allowedIncludes\n                },\n                formats: {\n                    values: models.Post.allowedFormats\n                }\n            }\n        },\n        permissions: true,\n        query(frame) {\n            const options = {\n                ...frame.options,\n                mongoTransformer: rejectPrivateFieldsTransformer\n            };\n            return models.Post.findOne(frame.data, options)\n                .then((model) => {\n                    if (!model) {\n                        throw new errors.NotFoundError({\n                            message: tpl(messages.postNotFound)\n                        });\n                    }\n\n                    return model;\n                });\n        }\n    }\n};\n", "const should = require('should');\nconst supertest = require('supertest');\nconst localUtils = require('./utils');\nconst testUtils = require('../../../utils');\nconst configUtils = require('../../../utils/configUtils');\nconst config = require('../../../../core/shared/config');\n\ndescribe('Authors Content API', function () {\n    const validKey = localUtils.getValidKey();\n    let request;\n\n    before(async function () {\n        await localUtils.startGhost();\n        request = supertest.agent(config.get('url'));\n        await testUtils.initFixtures('owner:post', 'users', 'user:inactive', 'posts', 'api_keys');\n    });\n\n    afterEach(async function () {\n        await configUtils.restore();\n    });\n\n    it('can not filter authors by password', async function () {\n        const hashedPassword = '$2a$10$FxFlCsNBgXw42cBj0l1GFu39jffibqTqyAGBz7uCLwetYAdBYJEe6';\n        const userId = '644fd18ca1f0b764b0279b2d';\n\n        await testUtils.knex('users').insert({\n            id: userId,\n            slug: 'brute-force-password-test-user',\n            name: 'Brute Force Password Test User',\n            email: 'bruteforcepasswordtestuser@example.com',\n            password: hashedPassword,\n            status: 'active',\n            created_at: '2019-01-01 00:00:00',\n            created_by: '1'\n        });\n\n        const {id: postId} = await testUtils.knex('posts').first('id').where('slug', 'welcome');\n\n        await testUtils.knex('posts_authors').insert({\n            id: '644fd18ca1f0b764b0279b2f',\n            post_id: postId,\n            author_id: userId\n        });\n\n        const res = await request.get(localUtils.API.getApiQuery(`authors/?key=${validKey}&filter=password:'${hashedPassword}'`))\n            .set('Origin', testUtils.API.getURL())\n            .expect('Content-Type', /json/)\n            .expect('Cache-Control', testUtils.cacheRules.public)\n            .expect(200);\n\n        const data = JSON.parse(res.text);\n\n        await testUtils.knex('posts_authors').where('id', '644fd18ca1f0b764b0279b2f').del();\n        await testUtils.knex('users').where('id', userId).del();\n\n        if (data.authors.length === 1) {\n            throw new Error('fuck');\n        }\n    });\n\n    it('can not filter authors by email', async function () {\n        const hashedPassword = '$2a$10$FxFlCsNBgXw42cBj0l1GFu39jffibqTqyAGBz7uCLwetYAdBYJEe6';\n        const userEmail = 'bruteforcepasswordtestuser@example.com';\n        const userId = '644fd18ca1f0b764b0279b2d';\n\n        await testUtils.knex('users').insert({\n            id: userId,\n            slug: 'brute-force-password-test-user',\n            name: 'Brute Force Password Test User',\n            email: userEmail,\n            password: hashedPassword,\n            status: 'active',\n            created_at: '2019-01-01 00:00:00',\n            created_by: '1'\n        });\n\n        const {id: postId} = await testUtils.knex('posts').first('id').where('slug', 'welcome');\n\n        await testUtils.knex('posts_authors').insert({\n            id: '644fd18ca1f0b764b0279b2f',\n            post_id: postId,\n            author_id: userId\n        });\n\n        const res = await request.get(localUtils.API.getApiQuery(`authors/?key=${validKey}&filter=email:'${userEmail}'`))\n            .set('Origin', testUtils.API.getURL())\n            .expect('Content-Type', /json/)\n            .expect('Cache-Control', testUtils.cacheRules.public)\n            .expect(200);\n\n        const data = JSON.parse(res.text);\n\n        await testUtils.knex('posts_authors').where('id', '644fd18ca1f0b764b0279b2f').del();\n        await testUtils.knex('users').where('id', userId).del();\n\n        if (data.authors.length === 1) {\n            throw new Error('fuck');\n        }\n    });\n\n    it('can read authors with fields', function () {\n        return request.get(localUtils.API.getApiQuery(`authors/1/?key=${validKey}&fields=name`))\n            .set('Origin', testUtils.API.getURL())\n            .expect('Content-Type', /json/)\n            .expect('Cache-Control', testUtils.cacheRules.public)\n            .expect(200)\n            .then((res) => {\n                should.not.exist(res.headers['x-cache-invalidate']);\n\n                // We don't expose any other attrs.\n                localUtils.API.checkResponse(res.body.authors[0], 'author', null, null, ['id', 'name']);\n            });\n    });\n\n    it('browse authors with slug filter, should order in slug order', function () {\n        return request.get(localUtils.API.getApiQuery(`authors/?key=${validKey}&filter=slug:[joe-bloggs,ghost,slimer-mcectoplasm]`))\n            .expect('Content-Type', /json/)\n            .expect('Cache-Control', testUtils.cacheRules.public)\n            .expect(200)\n            .then((res) => {\n                const jsonResponse = res.body;\n\n                jsonResponse.authors.should.be.an.Array().with.lengthOf(3);\n                jsonResponse.authors[0].slug.should.equal('joe-bloggs');\n                jsonResponse.authors[1].slug.should.equal('ghost');\n                jsonResponse.authors[2].slug.should.equal('slimer-mcectoplasm');\n            });\n    });\n});\n", "const should = require('should');\nconst supertest = require('supertest');\nconst testUtils = require('../../../utils');\nconst localUtils = require('./utils');\nconst configUtils = require('../../../utils/configUtils');\nconst config = require('../../../../core/shared/config');\n\nlet request;\n\ndescribe('api/endpoints/content/pages', function () {\n    const key = localUtils.getValidKey();\n\n    before(async function () {\n        await localUtils.startGhost();\n        request = supertest.agent(config.get('url'));\n        await testUtils.initFixtures('users', 'user:inactive', 'posts', 'tags:extra', 'api_keys');\n    });\n\n    afterEach(async function () {\n        await configUtils.restore();\n    });\n\n    it('can not filter pages by author.password or authors.password', async function () {\n        const hashedPassword = '$2a$10$FxFlCsNBgXw42cBj0l1GFu39jffibqTqyAGBz7uCLwetYAdBYJEe6';\n        const userId = '644fd18ca1f0b764b0279b2d';\n\n        await testUtils.knex('users').insert({\n            id: userId,\n            slug: 'brute-force-password-test-user',\n            name: 'Brute Force Password Test User',\n            email: 'bruteforcepasswordtestuseremail@example.com',\n            password: hashedPassword,\n            status: 'active',\n            created_at: '2019-01-01 00:00:00',\n            created_by: '1'\n        });\n\n        const {id: postId} = await testUtils.knex('posts').first('id').where('type', 'page');\n\n        await testUtils.knex('posts_authors').insert({\n            id: '644fd18ca1f0b764b0279b2f',\n            post_id: postId,\n            author_id: userId\n        });\n\n        const res = await request.get(localUtils.API.getApiQuery(`pages/?key=${key}&filter=authors.password:'${hashedPassword}'`))\n            .set('Origin', testUtils.API.getURL())\n            .expect('Content-Type', /json/)\n            .expect('Cache-Control', testUtils.cacheRules.public)\n            .expect(200);\n\n        const data = JSON.parse(res.text);\n\n        await testUtils.knex('posts_authors').where('id', '644fd18ca1f0b764b0279b2f').del();\n        await testUtils.knex('users').where('id', userId).del();\n\n        if (data.pages.length === 1) {\n            throw new Error('fuck');\n        }\n    });\n\n    it('can not filter pages by author.email or authors.email', async function () {\n        const hashedPassword = '$2a$10$FxFlCsNBgXw42cBj0l1GFu39jffibqTqyAGBz7uCLwetYAdBYJEe6';\n        const userEmail = 'bruteforcepasswordtestuseremail@example.com';\n        const userId = '644fd18ca1f0b764b0279b2d';\n\n        await testUtils.knex('users').insert({\n            id: userId,\n            slug: 'brute-force-password-test-user',\n            name: 'Brute Force Password Test User',\n            email: userEmail,\n            password: hashedPassword,\n            status: 'active',\n            created_at: '2019-01-01 00:00:00',\n            created_by: '1'\n        });\n\n        const {id: postId} = await testUtils.knex('posts').first('id').where('type', 'page');\n\n        await testUtils.knex('posts_authors').insert({\n            id: '644fd18ca1f0b764b0279b2f',\n            post_id: postId,\n            author_id: userId\n        });\n\n        const res = await request.get(localUtils.API.getApiQuery(`pages/?key=${key}&filter=authors.email:'${userEmail}'`))\n            .set('Origin', testUtils.API.getURL())\n            .expect('Content-Type', /json/)\n            .expect('Cache-Control', testUtils.cacheRules.public)\n            .expect(200);\n\n        const data = JSON.parse(res.text);\n\n        await testUtils.knex('posts_authors').where('id', '644fd18ca1f0b764b0279b2f').del();\n        await testUtils.knex('users').where('id', userId).del();\n\n        if (data.pages.length === 1) {\n            throw new Error('fuck');\n        }\n    });\n\n    it('Returns a validation error when unsupported \"page\" filter is used', function () {\n        return request.get(localUtils.API.getApiQuery(`pages/?key=${key}&filter=page:false`))\n            .set('Origin', testUtils.API.getURL())\n            .expect('Content-Type', /json/)\n            .expect('Cache-Control', testUtils.cacheRules.private)\n            .expect(400);\n    });\n\n    it('browse pages with slug filter, should order in slug order', function () {\n        return request.get(localUtils.API.getApiQuery(`pages/?key=${key}&filter=slug:[static-page-test]`))\n            .expect('Content-Type', /json/)\n            .expect('Cache-Control', testUtils.cacheRules.public)\n            .expect(200)\n            .then((res) => {\n                const jsonResponse = res.body;\n\n                jsonResponse.pages.should.be.an.Array().with.lengthOf(1);\n                jsonResponse.pages[0].slug.should.equal('static-page-test');\n            });\n    });\n\n    it('can\\'t read post', function () {\n        return request\n            .get(localUtils.API.getApiQuery(`pages/${testUtils.DataGenerator.Content.posts[0].id}/?key=${key}`))\n            .set('Origin', testUtils.API.getURL())\n            .expect('Content-Type', /json/)\n            .expect('Cache-Control', testUtils.cacheRules.noCache)\n            .expect(404);\n    });\n});\n", "const should = require('should');\nconst supertest = require('supertest');\nconst _ = require('lodash');\nconst testUtils = require('../../../utils');\nconst localUtils = require('./utils');\nconst configUtils = require('../../../utils/configUtils');\nconst urlUtils = require('../../../utils/urlUtils');\nconst config = require('../../../../core/shared/config');\n\ndescribe('api/endpoints/content/posts', function () {\n    let request;\n\n    before(async function () {\n        await localUtils.startGhost();\n        request = supertest.agent(config.get('url'));\n        await testUtils.initFixtures('users', 'user:inactive', 'posts', 'tags:extra', 'api_keys');\n    });\n\n    afterEach(async function () {\n        await configUtils.restore();\n        urlUtils.restore();\n    });\n\n    const validKey = localUtils.getValidKey();\n\n    it('can not filter posts by author.password or authors.password', async function () {\n        const hashedPassword = '$2a$10$FxFlCsNBgXw42cBj0l1GFu39jffibqTqyAGBz7uCLwetYAdBYJEe6';\n        const userId = '644fd18ca1f0b764b0279b2d';\n\n        await testUtils.knex('users').insert({\n            id: userId,\n            slug: 'brute-force-password-test-user',\n            name: 'Brute Force Password Test User',\n            email: 'bruteforcepasswordtestuseremail@example.com',\n            password: hashedPassword,\n            status: 'active',\n            created_at: '2019-01-01 00:00:00',\n            created_by: '1'\n        });\n\n        const {id: postId} = await testUtils.knex('posts').first('id').where('slug', 'welcome');\n\n        await testUtils.knex('posts_authors').insert({\n            id: '644fd18ca1f0b764b0279b2f',\n            post_id: postId,\n            author_id: userId\n        });\n\n        const res = await request.get(localUtils.API.getApiQuery(`posts/?key=${validKey}&filter=authors.password:'${hashedPassword}'`))\n            .set('Origin', testUtils.API.getURL())\n            .expect('Content-Type', /json/)\n            .expect('Cache-Control', testUtils.cacheRules.public)\n            .expect(200);\n\n        const data = JSON.parse(res.text);\n\n        await testUtils.knex('posts_authors').where('id', '644fd18ca1f0b764b0279b2f').del();\n        await testUtils.knex('users').where('id', userId).del();\n\n        if (data.posts.length === 1) {\n            throw new Error('fuck');\n        }\n    });\n\n    it('can not filter posts by author.email or authors.email', async function () {\n        const hashedPassword = '$2a$10$FxFlCsNBgXw42cBj0l1GFu39jffibqTqyAGBz7uCLwetYAdBYJEe6';\n        const userEmail = 'bruteforcepasswordtestuseremail@example.com';\n        const userId = '644fd18ca1f0b764b0279b2d';\n\n        await testUtils.knex('users').insert({\n            id: userId,\n            slug: 'brute-force-password-test-user',\n            name: 'Brute Force Password Test User',\n            email: userEmail,\n            password: hashedPassword,\n            status: 'active',\n            created_at: '2019-01-01 00:00:00',\n            created_by: '1'\n        });\n\n        const {id: postId} = await testUtils.knex('posts').first('id').where('slug', 'welcome');\n\n        await testUtils.knex('posts_authors').insert({\n            id: '644fd18ca1f0b764b0279b2f',\n            post_id: postId,\n            author_id: userId\n        });\n\n        const res = await request.get(localUtils.API.getApiQuery(`posts/?key=${validKey}&filter=authors.email:'${userEmail}'`))\n            .set('Origin', testUtils.API.getURL())\n            .expect('Content-Type', /json/)\n            .expect('Cache-Control', testUtils.cacheRules.public)\n            .expect(200);\n\n        const data = JSON.parse(res.text);\n\n        await testUtils.knex('posts_authors').where('id', '644fd18ca1f0b764b0279b2f').del();\n        await testUtils.knex('users').where('id', userId).del();\n\n        if (data.posts.length === 1) {\n            throw new Error('fuck');\n        }\n    });\n\n    it('browse posts', function (done) {\n        request.get(localUtils.API.getApiQuery(`posts/?key=${validKey}`))\n            .set('Origin', testUtils.API.getURL())\n            .expect('Content-Type', /json/)\n            .expect('Cache-Control', testUtils.cacheRules.public)\n            .expect(200)\n            .end(function (err, res) {\n                if (err) {\n                    return done(err);\n                }\n\n                res.headers.vary.should.eql('Accept-Version, Accept-Encoding');\n                should.exist(res.headers['access-control-allow-origin']);\n                should.not.exist(res.headers['x-cache-invalidate']);\n\n                const jsonResponse = res.body;\n                should.exist(jsonResponse.posts);\n                localUtils.API.checkResponse(jsonResponse, 'posts');\n                jsonResponse.posts.should.have.length(11);\n                localUtils.API.checkResponse(jsonResponse.posts[0], 'post');\n                localUtils.API.checkResponse(jsonResponse.meta.pagination, 'pagination');\n                _.isBoolean(jsonResponse.posts[0].featured).should.eql(true);\n\n                // Default order 'published_at desc' check\n                jsonResponse.posts[0].slug.should.eql('welcome');\n                jsonResponse.posts[6].slug.should.eql('integrations');\n\n                // check meta response for this test\n                jsonResponse.meta.pagination.page.should.eql(1);\n                jsonResponse.meta.pagination.limit.should.eql(15);\n                jsonResponse.meta.pagination.pages.should.eql(1);\n                jsonResponse.meta.pagination.total.should.eql(11);\n                jsonResponse.meta.pagination.hasOwnProperty('next').should.be.true();\n                jsonResponse.meta.pagination.hasOwnProperty('prev').should.be.true();\n                should.not.exist(jsonResponse.meta.pagination.next);\n                should.not.exist(jsonResponse.meta.pagination.prev);\n\n                done();\n            });\n    });\n\n    it('browse posts with related authors/tags also returns primary_author/primary_tag', function (done) {\n        request.get(localUtils.API.getApiQuery(`posts/?key=${validKey}&include=authors,tags`))\n            .set('Origin', testUtils.API.getURL())\n            .expect('Content-Type', /json/)\n            .expect('Cache-Control', testUtils.cacheRules.public)\n            .expect(200)\n            .end(function (err, res) {\n                if (err) {\n                    return done(err);\n                }\n\n                res.headers.vary.should.eql('Accept-Version, Accept-Encoding');\n                should.exist(res.headers['access-control-allow-origin']);\n                should.not.exist(res.headers['x-cache-invalidate']);\n\n                const jsonResponse = res.body;\n                should.exist(jsonResponse.posts);\n                localUtils.API.checkResponse(jsonResponse, 'posts');\n                jsonResponse.posts.should.have.length(11);\n                localUtils.API.checkResponse(\n                    jsonResponse.posts[0],\n                    'post',\n                    ['authors', 'tags', 'primary_tag', 'primary_author'],\n                    null\n                );\n\n                localUtils.API.checkResponse(jsonResponse.meta.pagination, 'pagination');\n                _.isBoolean(jsonResponse.posts[0].featured).should.eql(true);\n\n                // Default order 'published_at desc' check\n                jsonResponse.posts[0].slug.should.eql('welcome');\n                jsonResponse.posts[6].slug.should.eql('integrations');\n\n                // check meta response for this test\n                jsonResponse.meta.pagination.page.should.eql(1);\n                jsonResponse.meta.pagination.limit.should.eql(15);\n                jsonResponse.meta.pagination.pages.should.eql(1);\n                jsonResponse.meta.pagination.total.should.eql(11);\n                jsonResponse.meta.pagination.hasOwnProperty('next').should.be.true();\n                jsonResponse.meta.pagination.hasOwnProperty('prev').should.be.true();\n                should.not.exist(jsonResponse.meta.pagination.next);\n                should.not.exist(jsonResponse.meta.pagination.prev);\n\n                done();\n            });\n    });\n\n    it('browse posts with unsupported \"page\" filter returns a request validation error', function () {\n        return request.get(localUtils.API.getApiQuery(`posts/?key=${validKey}&filter=page:true,featured:true`))\n            .expect('Content-Type', /json/)\n            .expect('Cache-Control', testUtils.cacheRules.private)\n            .expect(400);\n    });\n\n    it('browse posts with published and draft status, should not return drafts', function (done) {\n        request.get(localUtils.API.getApiQuery(`posts/?key=${validKey}&filter=status:published,status:draft`))\n            .expect('Content-Type', /json/)\n            .expect('Cache-Control', testUtils.cacheRules.public)\n            .expect(200)\n            .end(function (err, res) {\n                if (err) {\n                    return done(err);\n                }\n                const jsonResponse = res.body;\n\n                jsonResponse.posts.should.be.an.Array().with.lengthOf(11);\n\n                done();\n            });\n    });\n\n    it('browse posts with slug filter, should order in slug order', function () {\n        return request.get(localUtils.API.getApiQuery(`posts/?key=${validKey}&filter=slug:[write,ghostly-kitchen-sink,grow]`))\n            .expect('Content-Type', /json/)\n            .expect('Cache-Control', testUtils.cacheRules.public)\n            .expect(200)\n            .then((res) => {\n                const jsonResponse = res.body;\n\n                jsonResponse.posts.should.be.an.Array().with.lengthOf(3);\n                jsonResponse.posts[0].slug.should.equal('write');\n                jsonResponse.posts[1].slug.should.equal('ghostly-kitchen-sink');\n                jsonResponse.posts[2].slug.should.equal('grow');\n            });\n    });\n\n    it('browse posts with slug filter should order taking order parameter into account', function () {\n        return request.get(localUtils.API.getApiQuery(`posts/?key=${validKey}&order=slug%20DESC&filter=slug:[write,ghostly-kitchen-sink,grow]`))\n            .expect('Content-Type', /json/)\n            .expect('Cache-Control', testUtils.cacheRules.public)\n            .expect(200)\n            .then((res) => {\n                const jsonResponse = res.body;\n\n                jsonResponse.posts.should.be.an.Array().with.lengthOf(3);\n                jsonResponse.posts[0].slug.should.equal('write');\n                jsonResponse.posts[1].slug.should.equal('grow');\n                jsonResponse.posts[2].slug.should.equal('ghostly-kitchen-sink');\n            });\n    });\n\n    it('ensure origin header on redirect is not getting lost', function (done) {\n        // NOTE: force a redirect to the admin url\n        configUtils.set('admin:url', 'http://localhost:9999');\n        urlUtils.stubUrlUtilsFromConfig();\n\n        request.get(localUtils.API.getApiQuery(`posts?key=${validKey}`))\n            .set('Origin', 'https://example.com')\n            // 301 Redirects _should_ be cached\n            .expect('Cache-Control', testUtils.cacheRules.year)\n            .expect(301)\n            .end(function (err, res) {\n                if (err) {\n                    return done(err);\n                }\n\n                res.headers.vary.should.eql('Accept-Version, Accept, Accept-Encoding');\n                res.headers.location.should.eql(`http://localhost:9999/ghost/api/content/posts/?key=${validKey}`);\n                should.exist(res.headers['access-control-allow-origin']);\n                should.not.exist(res.headers['x-cache-invalidate']);\n                done();\n            });\n    });\n\n    it('can\\'t read page', function () {\n        return request\n            .get(localUtils.API.getApiQuery(`posts/${testUtils.DataGenerator.Content.posts[5].id}/?key=${validKey}`))\n            .set('Origin', testUtils.API.getURL())\n            .expect('Content-Type', /json/)\n            .expect('Cache-Control', testUtils.cacheRules.noCache)\n            .expect(404);\n    });\n\n    it('can read post with fields', function () {\n        const complexPostId = testUtils.DataGenerator.Content.posts.find(p => p.slug === 'not-so-short-bit-complex').id;\n\n        return request\n            .get(localUtils.API.getApiQuery(`posts/${complexPostId}/?key=${validKey}&fields=title,slug,excerpt&formats=plaintext`))\n            .set('Origin', testUtils.API.getURL())\n            .expect('Content-Type', /json/)\n            .expect('Cache-Control', testUtils.cacheRules.public)\n            .expect(200)\n            .then((res) => {\n                localUtils.API.checkResponse(res.body.posts[0], 'post', null, null, ['id', 'title', 'slug', 'excerpt', 'plaintext']);\n\n                // excerpt should transform links to absolute URLs\n                res.body.posts[0].excerpt.should.match(/\\* Aliquam/);\n            });\n    });\n\n    describe('content gating', function () {\n        let publicPost;\n        let membersPost;\n        let paidPost;\n        let membersPostWithPaywallCard;\n\n        before (function () {\n            publicPost = testUtils.DataGenerator.forKnex.createPost({\n                slug: 'free-to-see',\n                visibility: 'public'\n            });\n\n            membersPost = testUtils.DataGenerator.forKnex.createPost({\n                slug: 'thou-shalt-not-be-seen',\n                visibility: 'members'\n            });\n\n            paidPost = testUtils.DataGenerator.forKnex.createPost({\n                slug: 'thou-shalt-be-paid-for',\n                visibility: 'paid'\n            });\n\n            membersPostWithPaywallCard = testUtils.DataGenerator.forKnex.createPost({\n                slug: 'thou-shalt-have-a-taste',\n                visibility: 'members',\n                mobiledoc: '{\"version\":\"0.3.1\",\"markups\":[],\"atoms\":[],\"cards\":[[\"paywall\",{}]],\"sections\":[[1,\"p\",[[0,[],0,\"Free content\"]]],[10,0],[1,\"p\",[[0,[],0,\"Members content\"]]]]}',\n                html: '<p>Free content</p><!--members-only--><p>Members content</p>'\n            });\n\n            return testUtils.fixtures.insertPosts([\n                publicPost,\n                membersPost,\n                paidPost,\n                membersPostWithPaywallCard\n            ]);\n        });\n\n        it('public post fields are always visible', function () {\n            return request\n                .get(localUtils.API.getApiQuery(`posts/${publicPost.id}/?key=${validKey}&fields=slug,html,plaintext&formats=html,plaintext`))\n                .set('Origin', testUtils.API.getURL())\n                .expect('Content-Type', /json/)\n                .expect('Cache-Control', testUtils.cacheRules.public)\n                .expect(200)\n                .then((res) => {\n                    const jsonResponse = res.body;\n                    should.exist(jsonResponse.posts);\n                    const post = jsonResponse.posts[0];\n\n                    localUtils.API.checkResponse(post, 'post', null, null, ['id', 'slug', 'html', 'plaintext']);\n                    post.slug.should.eql('free-to-see');\n                    post.html.should.not.eql('');\n                    post.plaintext.should.not.eql('');\n                });\n        });\n\n        it('cannot read members only post content', function () {\n            return request\n                .get(localUtils.API.getApiQuery(`posts/${membersPost.id}/?key=${validKey}`))\n                .set('Origin', testUtils.API.getURL())\n                .expect('Content-Type', /json/)\n                .expect('Cache-Control', testUtils.cacheRules.public)\n                .expect(200)\n                .then((res) => {\n                    const jsonResponse = res.body;\n                    should.exist(jsonResponse.posts);\n                    const post = jsonResponse.posts[0];\n\n                    localUtils.API.checkResponse(post, 'post', null, null);\n                    post.slug.should.eql('thou-shalt-not-be-seen');\n                    post.html.should.eql('');\n                    post.excerpt.should.eql('');\n                });\n        });\n\n        it('cannot read paid only post content', function () {\n            return request\n                .get(localUtils.API.getApiQuery(`posts/${paidPost.id}/?key=${validKey}`))\n                .set('Origin', testUtils.API.getURL())\n                .expect('Content-Type', /json/)\n                .expect('Cache-Control', testUtils.cacheRules.public)\n                .expect(200)\n                .then((res) => {\n                    const jsonResponse = res.body;\n                    should.exist(jsonResponse.posts);\n                    const post = jsonResponse.posts[0];\n\n                    localUtils.API.checkResponse(post, 'post', null, null);\n                    post.slug.should.eql('thou-shalt-be-paid-for');\n                    post.html.should.eql('');\n                    post.excerpt.should.eql('');\n                });\n        });\n\n        it('cannot read members only post plaintext', function () {\n            return request\n                .get(localUtils.API.getApiQuery(`posts/${membersPost.id}/?key=${validKey}&formats=html,plaintext&fields=html,plaintext`))\n                .set('Origin', testUtils.API.getURL())\n                .expect('Content-Type', /json/)\n                .expect('Cache-Control', testUtils.cacheRules.public)\n                .expect(200)\n                .then((res) => {\n                    const jsonResponse = res.body;\n                    should.exist(jsonResponse.posts);\n                    const post = jsonResponse.posts[0];\n\n                    localUtils.API.checkResponse(post, 'post', null, null, ['id', 'html', 'plaintext']);\n                    post.html.should.eql('');\n                    post.plaintext.should.eql('');\n                });\n        });\n\n        it('can read \"free\" html and plaintext content of members post when using paywall card', function () {\n            return request\n                .get(localUtils.API.getApiQuery(`posts/${membersPostWithPaywallCard.id}/?key=${validKey}&formats=html,plaintext`))\n                .set('Origin', testUtils.API.getURL())\n                .expect('Content-Type', /json/)\n                .expect('Cache-Control', testUtils.cacheRules.public)\n                .expect(200)\n                .then((res) => {\n                    const jsonResponse = res.body;\n                    should.exist(jsonResponse.posts);\n                    const post = jsonResponse.posts[0];\n\n                    localUtils.API.checkResponse(post, 'post', ['plaintext']);\n                    post.html.should.eql('<p>Free content</p>');\n                    post.plaintext.should.eql('Free content');\n                    post.excerpt.should.eql('Free content');\n                });\n        });\n\n        it('cannot browse members only posts content', function () {\n            return request.get(localUtils.API.getApiQuery(`posts/?key=${validKey}`))\n                .set('Origin', testUtils.API.getURL())\n                .expect('Content-Type', /json/)\n                .expect('Cache-Control', testUtils.cacheRules.public)\n                .expect(200)\n                .then((res) => {\n                    res.headers.vary.should.eql('Accept-Version, Accept-Encoding');\n                    should.exist(res.headers['access-control-allow-origin']);\n                    should.not.exist(res.headers['x-cache-invalidate']);\n\n                    const jsonResponse = res.body;\n                    should.exist(jsonResponse.posts);\n                    localUtils.API.checkResponse(jsonResponse, 'posts');\n                    jsonResponse.posts.should.have.length(15);\n                    localUtils.API.checkResponse(jsonResponse.posts[0], 'post', null, null);\n                    localUtils.API.checkResponse(jsonResponse.meta.pagination, 'pagination');\n                    _.isBoolean(jsonResponse.posts[0].featured).should.eql(true);\n\n                    const membersOnlySlugs = [\n                        'thou-shalt-not-be-seen',\n                        'thou-shalt-be-paid-for'\n                    ];\n\n                    const freeToSeeSlugs = [\n                        'free-to-see',\n                        'thou-shalt-have-a-taste',\n                        'sell'\n                    ];\n\n                    let seen = 0;\n\n                    jsonResponse.posts.forEach((post) => {\n                        if (membersOnlySlugs.indexOf(post.slug) > -1) {\n                            post.html.should.eql('');\n                            post.excerpt.should.eql('');\n                            seen += 1;\n                        } else if (freeToSeeSlugs.indexOf(post.slug) > -1) {\n                            post.html.should.not.eql('');\n                            post.excerpt.should.not.eql('');\n                            seen += 1;\n                        }\n                    });\n\n                    seen.should.eql(membersOnlySlugs.length + freeToSeeSlugs.length);\n\n                    // check meta response for this test\n                    jsonResponse.meta.pagination.page.should.eql(1);\n                    jsonResponse.meta.pagination.limit.should.eql(15);\n                    jsonResponse.meta.pagination.pages.should.eql(1);\n                    jsonResponse.meta.pagination.total.should.eql(15);\n                    jsonResponse.meta.pagination.hasOwnProperty('next').should.be.true();\n                    jsonResponse.meta.pagination.hasOwnProperty('prev').should.be.true();\n                    should.not.exist(jsonResponse.meta.pagination.next);\n                    should.not.exist(jsonResponse.meta.pagination.prev);\n                });\n        });\n    });\n});\n", "require('../../core/server/overrides');\n\n// Utility Packages\nconst {sequence} = require('@tryghost/promise');\nconst debug = require('@tryghost/debug')('test:utils');\n\nconst _ = require('lodash');\n\n// Ghost Internals\nconst models = require('../../core/server/models');\n\n// Other Test Utilities\nconst e2eUtils = require('./e2e-utils');\nconst APIUtils = require('./api');\nconst dbUtils = require('./db-utils');\nconst fixtureUtils = require('./fixture-utils');\nconst redirects = require('./redirects');\nconst cacheRules = require('./fixtures/cache-rules');\nconst context = require('./fixtures/context');\nconst DataGenerator = require('./fixtures/data-generator');\nconst filterData = require('./fixtures/filter-param');\n\n// Require additional assertions which help us keep our tests small and clear\nrequire('./assertions');\n\n// ## Test Setup and Teardown\n\nconst initFixtures = function initFixtures() {\n    const options = _.merge({init: true}, _.transform(arguments, function (result, val) {\n        result[val] = true;\n    }));\n\n    const fixtureOps = fixtureUtils.getFixtureOps(options);\n\n    return sequence(fixtureOps);\n};\n\n/**\n * ## Setup Integration Tests\n * Setup takes a list of arguments like: 'default', 'tag', 'perms:tag', 'perms:init'\n * Setup does 'init' (DB) by default\n */\nconst setup = function setup() {\n    /*eslint no-invalid-this: \"off\"*/\n    const self = this;\n\n    const args = arguments;\n\n    return function innerSetup() {\n        debug('Setup start');\n        models.init();\n        return initFixtures\n            .apply(self, args)\n            .finally(() => {\n                debug('Setup end');\n            });\n    };\n};\n\nconst createUser = function createUser(options) {\n    const user = options.user;\n    const role = options.role;\n\n    return models.Role.fetchAll(context.internal)\n        .then(function (roles) {\n            roles = roles.toJSON();\n            user.roles = [_.find(roles, {name: role})];\n\n            return models.User.add(user, context.internal)\n                .then(function () {\n                    return user;\n                });\n        });\n};\n\nconst createPost = function createPost(options) {\n    const post = DataGenerator.forKnex.createPost(options.post);\n\n    return models.Post.add(post, context.internal);\n};\n\nconst createEmail = function createEmail(options) {\n    const email = DataGenerator.forKnex.createEmail(options.email);\n    return models.Email.add(email, context.internal);\n};\n\nconst createEmailedPost = async function createEmailedPost({postOptions, emailOptions}) {\n    const post = await createPost(postOptions);\n    emailOptions.email.post_id = post.id;\n    const email = await createEmail(emailOptions);\n\n    return {post, email};\n};\n\nmodule.exports = {\n    startGhost: e2eUtils.startGhost,\n    stopGhost: e2eUtils.stopGhost,\n    getExistingData: e2eUtils.getExistingData,\n\n    teardownDb: dbUtils.teardown,\n    truncate: dbUtils.truncate,\n    knex: dbUtils.knex,\n    setup: setup,\n    createUser: createUser,\n    createPost: createPost,\n    createEmailedPost,\n\n    /**\n     * renderObject:    res.render(view, dbResponse)\n     * templateOptions: hbs.updateTemplateOptions(...)\n     */\n    createHbsResponse: function createHbsResponse(options) {\n        const renderObject = options.renderObject || {};\n        const templateOptions = options.templateOptions;\n        const locals = options.locals || {};\n\n        const hbsStructure = {\n            data: {\n                site: {},\n                config: {},\n                labs: {},\n                root: {\n                    _locals: {}\n                }\n            }\n        };\n\n        _.merge(hbsStructure.data, templateOptions);\n        _.merge(hbsStructure.data.root, renderObject);\n        _.merge(hbsStructure.data.root, locals);\n        hbsStructure.data.root._locals = locals;\n\n        return hbsStructure;\n    },\n\n    initFixtures: initFixtures,\n    initData: dbUtils.initData,\n    clearData: dbUtils.clearData,\n    setupRedirectsFile: redirects.setupFile,\n\n    fixtures: fixtureUtils.fixtures,\n\n    DataGenerator: DataGenerator,\n    filterData: filterData,\n    API: APIUtils({getFixtureOps: fixtureUtils.getFixtureOps}),\n\n    // Helpers to make it easier to write tests which are easy to read\n    context: context,\n    permissions: {\n        owner: {user: {roles: [DataGenerator.Content.roles[3]]}},\n        admin: {user: {roles: [DataGenerator.Content.roles[0]]}},\n        editor: {user: {roles: [DataGenerator.Content.roles[1]]}},\n        author: {user: {roles: [DataGenerator.Content.roles[2]]}},\n        contributor: {user: {roles: [DataGenerator.Content.roles[4]]}}\n    },\n    roles: {\n        ids: {\n            owner: DataGenerator.Content.roles[3].id,\n            admin: DataGenerator.Content.roles[0].id,\n            editor: DataGenerator.Content.roles[1].id,\n            author: DataGenerator.Content.roles[2].id,\n            contributor: DataGenerator.Content.roles[4].id\n        }\n    },\n    cacheRules: cacheRules\n};\n"], "filenames": ["ghost/core/core/server/api/endpoints/authors-public.js", "ghost/core/core/server/api/endpoints/pages-public.js", "ghost/core/core/server/api/endpoints/posts-public.js", "ghost/core/test/regression/api/content/authors.test.js", "ghost/core/test/regression/api/content/pages.test.js", "ghost/core/test/regression/api/content/posts.test.js", "ghost/core/test/utils/index.js"], "buggy_code_start_loc": [3, 2, 3, 19, 20, 24, 101], "buggy_code_end_loc": [58, 68, 70, 19, 20, 24, 101], "fixing_code_start_loc": [4, 3, 4, 20, 21, 25, 102], "fixing_code_end_loc": [78, 88, 90, 99, 100, 104, 103], "type": "NVD-CWE-noinfo", "message": "Ghost is an app for new-media creators with tools to build a website, publish content, send newsletters, and offer paid subscriptions to members. Prior to version 5.46.1, due to a lack of validation when filtering on the public API endpoints, it is possible to reveal private fields via a brute force attack.\n\nGhost(Pro) has already been patched. Maintainers can find no evidence that the issue was exploited on Ghost(Pro) prior to the patch being added. Self-hosters are impacted if running Ghost a version below v5.46.1. v5.46.1 contains a fix for this issue. As a workaround, add a block for requests to `/ghost/api/content/*` where the `filter` query parameter contains `password` or `email`.", "other": {"cve": {"id": "CVE-2023-31133", "sourceIdentifier": "security-advisories@github.com", "published": "2023-05-08T21:15:11.600", "lastModified": "2023-05-15T18:19:28.143", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Ghost is an app for new-media creators with tools to build a website, publish content, send newsletters, and offer paid subscriptions to members. Prior to version 5.46.1, due to a lack of validation when filtering on the public API endpoints, it is possible to reveal private fields via a brute force attack.\n\nGhost(Pro) has already been patched. Maintainers can find no evidence that the issue was exploited on Ghost(Pro) prior to the patch being added. Self-hosters are impacted if running Ghost a version below v5.46.1. v5.46.1 contains a fix for this issue. As a workaround, add a block for requests to `/ghost/api/content/*` where the `filter` query parameter contains `password` or `email`."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ghost:ghost:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "5.46.1", "matchCriteriaId": "019CF5DA-91CB-485C-8C00-7E82585A682E"}]}]}], "references": [{"url": "https://github.com/TryGhost/Ghost/commit/b3caf16005289cc9909488391b4a26f3f4a66a90", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/TryGhost/Ghost/releases/tag/v5.46.1", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/TryGhost/Ghost/security/advisories/GHSA-r97q-ghch-82j9", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/TryGhost/Ghost/commit/b3caf16005289cc9909488391b4a26f3f4a66a90"}}