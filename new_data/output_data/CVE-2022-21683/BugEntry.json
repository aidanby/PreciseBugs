{"buggy_code": ["import datetime\nimport os\n\nfrom unittest import mock\n\nfrom django.conf import settings\nfrom django.contrib.auth.models import Group, Permission\nfrom django.core import mail\nfrom django.core.files.base import ContentFile\nfrom django.http import HttpRequest, HttpResponse\nfrom django.test import TestCase, modify_settings, override_settings\nfrom django.urls import reverse\nfrom django.utils import timezone\nfrom django.utils.translation import gettext_lazy as _\n\nfrom wagtail.admin.admin_url_finder import AdminURLFinder\nfrom wagtail.admin.tests.pages.timestamps import submittable_timestamp\nfrom wagtail.core.exceptions import PageClassNotFoundError\nfrom wagtail.core.models import (\n    Comment, CommentReply, GroupPagePermission, Locale, Page, PageLogEntry, PageRevision,\n    PageSubscription, Site)\nfrom wagtail.core.signals import page_published\nfrom wagtail.tests.testapp.models import (\n    EVENT_AUDIENCE_CHOICES, Advert, AdvertPlacement, EventCategory, EventPage,\n    EventPageCarouselItem, FilePage, ManyToManyBlogPage, SimplePage, SingleEventPage, StandardIndex,\n    TaggedPage)\nfrom wagtail.tests.utils import WagtailTestUtils\nfrom wagtail.tests.utils.form_data import inline_formset, nested_form_data\nfrom wagtail.users.models import UserProfile\n\n\nclass TestPageEdit(TestCase, WagtailTestUtils):\n    def setUp(self):\n        # Find root page\n        self.root_page = Page.objects.get(id=2)\n\n        # Add child page\n        child_page = SimplePage(\n            title=\"Hello world!\",\n            slug=\"hello-world\",\n            content=\"hello\",\n        )\n        self.root_page.add_child(instance=child_page)\n        child_page.save_revision().publish()\n        self.child_page = SimplePage.objects.get(id=child_page.id)\n\n        # Add file page\n        fake_file = ContentFile(\"File for testing multipart\")\n        fake_file.name = 'test.txt'\n        file_page = FilePage(\n            title=\"File Page\",\n            slug=\"file-page\",\n            file_field=fake_file,\n        )\n        self.root_page.add_child(instance=file_page)\n        file_page.save_revision().publish()\n        self.file_page = FilePage.objects.get(id=file_page.id)\n\n        # Add event page (to test edit handlers)\n        self.event_page = EventPage(\n            title=\"Event page\", slug=\"event-page\",\n            location='the moon', audience='public',\n            cost='free', date_from='2001-01-01',\n        )\n        self.root_page.add_child(instance=self.event_page)\n\n        # Add single event page (to test custom URL routes)\n        self.single_event_page = SingleEventPage(\n            title=\"Mars landing\", slug=\"mars-landing\",\n            location='mars', audience='public',\n            cost='free', date_from='2001-01-01',\n        )\n        self.root_page.add_child(instance=self.single_event_page)\n\n        self.unpublished_page = SimplePage(\n            title=\"Hello unpublished world!\",\n            slug=\"hello-unpublished-world\",\n            content=\"hello\",\n            live=False,\n            has_unpublished_changes=True,\n        )\n        self.root_page.add_child(instance=self.unpublished_page)\n\n        # Login\n        self.user = self.login()\n\n    def test_page_edit(self):\n        # Tests that the edit page loads\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.event_page.id, )))\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response['Content-Type'], \"text/html; charset=utf-8\")\n        self.assertContains(response, '<li class=\"header-meta--status\">Published</li>', html=True)\n\n        # Test InlinePanel labels/headings\n        self.assertContains(response, '<legend>Speaker lineup</legend>')\n        self.assertContains(response, 'Add speakers')\n\n        # test register_page_action_menu_item hook\n        self.assertContains(response,\n                            '<button type=\"submit\" name=\"action-panic\" value=\"Panic!\" class=\"button\">Panic!</button>')\n        self.assertContains(response, 'testapp/js/siren.js')\n\n        # test construct_page_action_menu hook\n        self.assertContains(response,\n                            '<button type=\"submit\" name=\"action-relax\" value=\"Relax.\" class=\"button\">Relax.</button>')\n\n        # test that workflow actions are shown\n        self.assertContains(\n            response, '<button type=\"submit\" name=\"action-submit\" value=\"Submit to Moderators approval\" class=\"button\">'\n        )\n\n        # test that AdminURLFinder returns the edit view for the page\n        url_finder = AdminURLFinder(self.user)\n        expected_url = '/admin/pages/%d/edit/' % self.event_page.id\n        self.assertEqual(url_finder.get_edit_url(self.event_page), expected_url)\n\n    @override_settings(WAGTAIL_WORKFLOW_ENABLED=False)\n    def test_workflow_buttons_not_shown_when_workflow_disabled(self):\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.event_page.id, )))\n        self.assertEqual(response.status_code, 200)\n        self.assertNotContains(\n            response, 'value=\"Submit to Moderators approval\"'\n        )\n\n    def test_edit_draft_page_with_no_revisions(self):\n        # Tests that the edit page loads\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.unpublished_page.id, )))\n        self.assertEqual(response.status_code, 200)\n        self.assertContains(response, '<li class=\"header-meta--status\">Draft</li>', html=True)\n\n    def test_edit_multipart(self):\n        \"\"\"\n        Test checks if 'enctype=\"multipart/form-data\"' is added and only to forms that require multipart encoding.\n        \"\"\"\n        # check for SimplePage where is no file field\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.event_page.id, )))\n        self.assertEqual(response.status_code, 200)\n        self.assertNotContains(response, 'enctype=\"multipart/form-data\"')\n        self.assertTemplateUsed(response, 'wagtailadmin/pages/edit.html')\n\n        # check for FilePage which has file field\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.file_page.id, )))\n        self.assertEqual(response.status_code, 200)\n        self.assertContains(response, 'enctype=\"multipart/form-data\"')\n\n    @mock.patch('wagtail.core.models.ContentType.model_class', return_value=None)\n    def test_edit_when_specific_class_cannot_be_found(self, mocked_method):\n        with self.assertRaises(PageClassNotFoundError):\n            self.client.get(reverse('wagtailadmin_pages:edit', args=(self.event_page.id, )))\n\n    def test_upload_file_publish(self):\n        \"\"\"\n        Check that file uploads work when directly publishing\n        \"\"\"\n        file_upload = ContentFile(b\"A new file\", name='published-file.txt')\n        post_data = {\n            'title': 'New file',\n            'slug': 'new-file',\n            'file_field': file_upload,\n            'action-publish': \"Publish\",\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.file_page.id]), post_data)\n\n        # Should be redirected to explorer\n        self.assertRedirects(response, reverse('wagtailadmin_explore', args=[self.root_page.id]))\n\n        # Check the new file exists\n        file_page = FilePage.objects.get()\n\n        self.assertEqual(file_page.file_field.name, file_upload.name)\n        self.assertTrue(os.path.exists(file_page.file_field.path))\n        self.assertEqual(file_page.file_field.read(), b\"A new file\")\n\n    def test_upload_file_draft(self):\n        \"\"\"\n        Check that file uploads work when saving a draft\n        \"\"\"\n        file_upload = ContentFile(b\"A new file\", name='draft-file.txt')\n        post_data = {\n            'title': 'New file',\n            'slug': 'new-file',\n            'file_field': file_upload,\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.file_page.id]), post_data)\n\n        # Should be redirected to edit page\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[self.file_page.id]))\n\n        # Check the file was uploaded\n        file_path = os.path.join(settings.MEDIA_ROOT, file_upload.name)\n        self.assertTrue(os.path.exists(file_path))\n        with open(file_path, 'rb') as saved_file:\n            self.assertEqual(saved_file.read(), b\"A new file\")\n\n        # Publish the draft just created\n        FilePage.objects.get().get_latest_revision().publish()\n\n        # Get the file page, check the file is set\n        file_page = FilePage.objects.get()\n        self.assertEqual(file_page.file_field.name, file_upload.name)\n        self.assertTrue(os.path.exists(file_page.file_field.path))\n        self.assertEqual(file_page.file_field.read(), b\"A new file\")\n\n    def test_page_edit_bad_permissions(self):\n        # Remove privileges from user\n        self.user.is_superuser = False\n        self.user.user_permissions.add(\n            Permission.objects.get(content_type__app_label='wagtailadmin', codename='access_admin')\n        )\n        self.user.save()\n\n        # Get edit page\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )))\n\n        # Check that the user received a 302 redirected response\n        self.assertEqual(response.status_code, 302)\n\n        url_finder = AdminURLFinder(self.user)\n        self.assertEqual(url_finder.get_edit_url(self.event_page), None)\n\n    def test_page_edit_post(self):\n        # Tests simple editing\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)\n\n        # Should be redirected to edit page\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )))\n\n        # The page should have \"has_unpublished_changes\" flag set\n        child_page_new = SimplePage.objects.get(id=self.child_page.id)\n        self.assertTrue(child_page_new.has_unpublished_changes)\n\n        # Page fields should not be changed (because we just created a new draft)\n        self.assertEqual(child_page_new.title, self.child_page.title)\n        self.assertEqual(child_page_new.content, self.child_page.content)\n        self.assertEqual(child_page_new.slug, self.child_page.slug)\n\n        # The draft_title should have a new title\n        self.assertEqual(child_page_new.draft_title, post_data['title'])\n\n    def test_page_edit_post_when_locked(self):\n        # Tests that trying to edit a locked page results in an error\n\n        # Lock the page\n        self.child_page.locked = True\n        self.child_page.save()\n\n        # Post\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)\n\n        # Shouldn't be redirected\n        self.assertContains(response, \"The page could not be saved as it is locked\")\n\n        # The page shouldn't have \"has_unpublished_changes\" flag set\n        child_page_new = SimplePage.objects.get(id=self.child_page.id)\n        self.assertFalse(child_page_new.has_unpublished_changes)\n\n    def test_edit_post_scheduled(self):\n        # put go_live_at and expire_at several days away from the current date, to avoid\n        # false matches in content_json__contains tests\n        go_live_at = timezone.now() + datetime.timedelta(days=10)\n        expire_at = timezone.now() + datetime.timedelta(days=20)\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'go_live_at': submittable_timestamp(go_live_at),\n            'expire_at': submittable_timestamp(expire_at),\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)\n\n        # Should be redirected to explorer page\n        self.assertEqual(response.status_code, 302)\n\n        child_page_new = SimplePage.objects.get(id=self.child_page.id)\n\n        # The page will still be live\n        self.assertTrue(child_page_new.live)\n\n        # A revision with approved_go_live_at should not exist\n        self.assertFalse(PageRevision.objects.filter(\n            page=child_page_new).exclude(approved_go_live_at__isnull=True).exists()\n        )\n\n        # But a revision with go_live_at and expire_at in their content json *should* exist\n        self.assertTrue(PageRevision.objects.filter(\n            page=child_page_new, content_json__contains=str(go_live_at.date())).exists()\n        )\n        self.assertTrue(\n            PageRevision.objects.filter(page=child_page_new, content_json__contains=str(expire_at.date())).exists()\n        )\n\n    def test_edit_scheduled_go_live_before_expiry(self):\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'go_live_at': submittable_timestamp(timezone.now() + datetime.timedelta(days=2)),\n            'expire_at': submittable_timestamp(timezone.now() + datetime.timedelta(days=1)),\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)\n\n        self.assertEqual(response.status_code, 200)\n\n        # Check that a form error was raised\n        self.assertFormError(response, 'form', 'go_live_at', \"Go live date/time must be before expiry date/time\")\n        self.assertFormError(response, 'form', 'expire_at', \"Go live date/time must be before expiry date/time\")\n\n        # form should be marked as having unsaved changes for the purposes of the dirty-forms warning\n        self.assertContains(response, \"alwaysDirty: true\")\n\n    def test_edit_scheduled_expire_in_the_past(self):\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'expire_at': submittable_timestamp(timezone.now() + datetime.timedelta(days=-1)),\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)\n\n        self.assertEqual(response.status_code, 200)\n\n        # Check that a form error was raised\n        self.assertFormError(response, 'form', 'expire_at', \"Expiry date/time must be in the future\")\n\n        # form should be marked as having unsaved changes for the purposes of the dirty-forms warning\n        self.assertContains(response, \"alwaysDirty: true\")\n\n    def test_page_edit_post_publish(self):\n        # Connect a mock signal handler to page_published signal\n        mock_handler = mock.MagicMock()\n        page_published.connect(mock_handler)\n\n        # Set has_unpublished_changes=True on the existing record to confirm that the publish action\n        # is resetting it (and not just leaving it alone)\n        self.child_page.has_unpublished_changes = True\n        self.child_page.save()\n\n        # Save current value of first_published_at so we can check that it doesn't change\n        first_published_at = SimplePage.objects.get(id=self.child_page.id).first_published_at\n\n        # Tests publish from edit page\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world-new',\n            'action-publish': \"Publish\",\n        }\n        response = self.client.post(\n            reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data, follow=True\n        )\n\n        # Should be redirected to explorer\n        self.assertRedirects(response, reverse('wagtailadmin_explore', args=(self.root_page.id, )))\n\n        # Check that the page was edited\n        child_page_new = SimplePage.objects.get(id=self.child_page.id)\n        self.assertEqual(child_page_new.title, post_data['title'])\n        self.assertEqual(child_page_new.draft_title, post_data['title'])\n\n        # Check that the page_published signal was fired\n        self.assertEqual(mock_handler.call_count, 1)\n        mock_call = mock_handler.mock_calls[0][2]\n\n        self.assertEqual(mock_call['sender'], child_page_new.specific_class)\n        self.assertEqual(mock_call['instance'], child_page_new)\n        self.assertIsInstance(mock_call['instance'], child_page_new.specific_class)\n\n        # The page shouldn't have \"has_unpublished_changes\" flag set\n        self.assertFalse(child_page_new.has_unpublished_changes)\n\n        # first_published_at should not change as it was already set\n        self.assertEqual(first_published_at, child_page_new.first_published_at)\n\n        # The \"View Live\" button should have the updated slug.\n        for message in response.context['messages']:\n            self.assertIn('hello-world-new', message.message)\n            break\n\n    def test_first_published_at_editable(self):\n        \"\"\"Test that we can update the first_published_at via the Page edit form,\n        for page models that expose it.\"\"\"\n\n        # Add child page, of a type which has first_published_at in its form\n        child_page = ManyToManyBlogPage(\n            title=\"Hello world!\",\n            slug=\"hello-again-world\",\n            body=\"hello\",\n        )\n        self.root_page.add_child(instance=child_page)\n        child_page.save_revision().publish()\n        self.child_page = ManyToManyBlogPage.objects.get(id=child_page.id)\n\n        initial_delta = self.child_page.first_published_at - timezone.now()\n\n        first_published_at = timezone.now() - datetime.timedelta(days=2)\n\n        post_data = {\n            'title': \"I've been edited!\",\n            'body': \"Some content\",\n            'slug': 'hello-again-world',\n            'action-publish': \"Publish\",\n            'first_published_at': submittable_timestamp(first_published_at),\n            'comments-TOTAL_FORMS': 0,\n            'comments-INITIAL_FORMS': 0,\n            'comments-MIN_NUM_FORMS': 0,\n            'comments-MAX_NUM_FORMS': 1000,\n        }\n        self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)\n\n        # Get the edited page.\n        child_page_new = ManyToManyBlogPage.objects.get(id=self.child_page.id)\n\n        # first_published_at should have changed.\n        new_delta = child_page_new.first_published_at - timezone.now()\n        self.assertNotEqual(new_delta.days, initial_delta.days)\n        # first_published_at should be 3 days ago.\n        self.assertEqual(new_delta.days, -3)\n\n    def test_edit_post_publish_scheduled_unpublished_page(self):\n        # Unpublish the page\n        self.child_page.live = False\n        self.child_page.save()\n\n        go_live_at = timezone.now() + datetime.timedelta(days=1)\n        expire_at = timezone.now() + datetime.timedelta(days=2)\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'action-publish': \"Publish\",\n            'go_live_at': submittable_timestamp(go_live_at),\n            'expire_at': submittable_timestamp(expire_at),\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)\n\n        # Should be redirected to explorer page\n        self.assertEqual(response.status_code, 302)\n\n        child_page_new = SimplePage.objects.get(id=self.child_page.id)\n\n        # The page should not be live anymore\n        self.assertFalse(child_page_new.live)\n\n        # Instead a revision with approved_go_live_at should now exist\n        self.assertTrue(\n            PageRevision.objects.filter(page=child_page_new).exclude(approved_go_live_at__isnull=True).exists()\n        )\n\n        # The page SHOULD have the \"has_unpublished_changes\" flag set,\n        # because the changes are not visible as a live page yet\n        self.assertTrue(\n            child_page_new.has_unpublished_changes,\n            \"A page scheduled for future publishing should have has_unpublished_changes=True\"\n        )\n\n        self.assertEqual(child_page_new.status_string, \"scheduled\")\n\n    def test_edit_post_publish_now_an_already_scheduled_unpublished_page(self):\n        # Unpublish the page\n        self.child_page.live = False\n        self.child_page.save()\n\n        # First let's publish a page with a go_live_at in the future\n        go_live_at = timezone.now() + datetime.timedelta(days=1)\n        expire_at = timezone.now() + datetime.timedelta(days=2)\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'action-publish': \"Publish\",\n            'go_live_at': submittable_timestamp(go_live_at),\n            'expire_at': submittable_timestamp(expire_at),\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)\n\n        # Should be redirected to edit page\n        self.assertEqual(response.status_code, 302)\n\n        child_page_new = SimplePage.objects.get(id=self.child_page.id)\n\n        # The page should not be live\n        self.assertFalse(child_page_new.live)\n\n        self.assertEqual(child_page_new.status_string, \"scheduled\")\n\n        # Instead a revision with approved_go_live_at should now exist\n        self.assertTrue(\n            PageRevision.objects.filter(page=child_page_new).exclude(approved_go_live_at__isnull=True).exists()\n        )\n\n        # Now, let's edit it and publish it right now\n        go_live_at = timezone.now()\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'action-publish': \"Publish\",\n            'go_live_at': \"\",\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)\n\n        # Should be redirected to edit page\n        self.assertEqual(response.status_code, 302)\n\n        child_page_new = SimplePage.objects.get(id=self.child_page.id)\n\n        # The page should be live now\n        self.assertTrue(child_page_new.live)\n\n        # And a revision with approved_go_live_at should not exist\n        self.assertFalse(\n            PageRevision.objects.filter(page=child_page_new).exclude(approved_go_live_at__isnull=True).exists()\n        )\n\n    def test_edit_post_publish_scheduled_published_page(self):\n        # Page is live\n        self.child_page.live = True\n        self.child_page.save()\n\n        live_revision = self.child_page.live_revision\n        original_title = self.child_page.title\n\n        go_live_at = timezone.now() + datetime.timedelta(days=1)\n        expire_at = timezone.now() + datetime.timedelta(days=2)\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'action-publish': \"Publish\",\n            'go_live_at': submittable_timestamp(go_live_at),\n            'expire_at': submittable_timestamp(expire_at),\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)\n\n        # Should be redirected to explorer page\n        self.assertEqual(response.status_code, 302)\n\n        child_page_new = SimplePage.objects.get(id=self.child_page.id)\n\n        # The page should still be live\n        self.assertTrue(child_page_new.live)\n\n        self.assertEqual(child_page_new.status_string, \"live + scheduled\")\n\n        # Instead a revision with approved_go_live_at should now exist\n        self.assertTrue(\n            PageRevision.objects.filter(page=child_page_new).exclude(approved_go_live_at__isnull=True).exists()\n        )\n\n        # The page SHOULD have the \"has_unpublished_changes\" flag set,\n        # because the changes are not visible as a live page yet\n        self.assertTrue(\n            child_page_new.has_unpublished_changes,\n            \"A page scheduled for future publishing should have has_unpublished_changes=True\"\n        )\n\n        self.assertNotEqual(\n            child_page_new.get_latest_revision(), live_revision,\n            \"A page scheduled for future publishing should have a new revision, that is not the live revision\"\n        )\n\n        self.assertEqual(\n            child_page_new.title, original_title,\n            \"A live page with scheduled revisions should still have original content\"\n        )\n\n    def test_edit_post_publish_now_an_already_scheduled_published_page(self):\n        # Unpublish the page\n        self.child_page.live = True\n        self.child_page.save()\n\n        original_title = self.child_page.title\n        # First let's publish a page with a go_live_at in the future\n        go_live_at = timezone.now() + datetime.timedelta(days=1)\n        expire_at = timezone.now() + datetime.timedelta(days=2)\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'action-publish': \"Publish\",\n            'go_live_at': submittable_timestamp(go_live_at),\n            'expire_at': submittable_timestamp(expire_at),\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)\n\n        # Should be redirected to edit page\n        self.assertEqual(response.status_code, 302)\n\n        child_page_new = SimplePage.objects.get(id=self.child_page.id)\n\n        # The page should still be live\n        self.assertTrue(child_page_new.live)\n\n        # Instead a revision with approved_go_live_at should now exist\n        self.assertTrue(\n            PageRevision.objects.filter(page=child_page_new).exclude(approved_go_live_at__isnull=True).exists()\n        )\n\n        self.assertEqual(\n            child_page_new.title, original_title,\n            \"A live page with scheduled revisions should still have original content\"\n        )\n\n        # Now, let's edit it and publish it right now\n        go_live_at = timezone.now()\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'action-publish': \"Publish\",\n            'go_live_at': \"\",\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)\n\n        # Should be redirected to edit page\n        self.assertEqual(response.status_code, 302)\n\n        child_page_new = SimplePage.objects.get(id=self.child_page.id)\n\n        # The page should be live now\n        self.assertTrue(child_page_new.live)\n\n        # And a revision with approved_go_live_at should not exist\n        self.assertFalse(\n            PageRevision.objects.filter(page=child_page_new).exclude(approved_go_live_at__isnull=True).exists()\n        )\n\n        self.assertEqual(\n            child_page_new.title, post_data['title'],\n            \"A published page should have the new title\"\n        )\n\n    def test_page_edit_post_submit(self):\n        # Create a moderator user for testing email\n        self.create_superuser('moderator', 'moderator@email.com', 'password')\n\n        # Tests submitting from edit page\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'action-submit': \"Submit\",\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)\n\n        # Should be redirected to explorer\n        self.assertRedirects(response, reverse('wagtailadmin_explore', args=(self.root_page.id, )))\n\n        # The page should have \"has_unpublished_changes\" flag set\n        child_page_new = SimplePage.objects.get(id=self.child_page.id)\n        self.assertTrue(child_page_new.has_unpublished_changes)\n\n        # The latest revision for the page should now be in moderation\n        self.assertEqual(child_page_new.current_workflow_state.status, child_page_new.current_workflow_state.STATUS_IN_PROGRESS)\n\n    def test_page_edit_post_existing_slug(self):\n        # This tests the existing slug checking on page edit\n\n        # Create a page\n        self.child_page = SimplePage(title=\"Hello world 2\", slug=\"hello-world2\", content=\"hello\")\n        self.root_page.add_child(instance=self.child_page)\n\n        # Attempt to change the slug to one that's already in use\n        post_data = {\n            'title': \"Hello world 2\",\n            'slug': 'hello-world',\n            'action-submit': \"Submit\",\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)\n\n        # Should not be redirected (as the save should fail)\n        self.assertEqual(response.status_code, 200)\n\n        # Check that a form error was raised\n        self.assertFormError(response, 'form', 'slug', \"This slug is already in use\")\n\n    def test_preview_on_edit(self):\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'action-submit': \"Submit\",\n        }\n        preview_url = reverse('wagtailadmin_pages:preview_on_edit',\n                              args=(self.child_page.id,))\n        response = self.client.post(preview_url, post_data)\n\n        # Check the JSON response\n        self.assertEqual(response.status_code, 200)\n        self.assertJSONEqual(response.content.decode(), {'is_valid': True})\n\n        response = self.client.get(preview_url)\n\n        # Check the HTML response\n        self.assertEqual(response.status_code, 200)\n        self.assertTemplateUsed(response, 'tests/simple_page.html')\n        self.assertContains(response, \"I&#39;ve been edited!\", html=True)\n\n    def test_preview_on_edit_no_session_key(self):\n        preview_url = reverse('wagtailadmin_pages:preview_on_edit',\n                              args=(self.child_page.id,))\n\n        # get() without corresponding post(), key not set.\n        response = self.client.get(preview_url)\n\n        # Check the HTML response\n        self.assertEqual(response.status_code, 200)\n\n        # We should have an error page because we are unable to\n        # preview; the page key was not in the session.\n        self.assertContains(\n            response,\n            \"<title>Wagtail - Preview error</title>\",\n            html=True\n        )\n        self.assertContains(\n            response,\n            \"<h1>Preview error</h1>\",\n            html=True\n        )\n\n    @override_settings(CACHES={\n        'default': {\n            'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',\n        }})\n    @modify_settings(MIDDLEWARE={\n        'append': 'django.middleware.cache.FetchFromCacheMiddleware',\n        'prepend': 'django.middleware.cache.UpdateCacheMiddleware',\n    })\n    def test_preview_does_not_cache(self):\n        '''\n        Tests solution to issue #5975\n        '''\n        post_data = {\n            'title': \"I've been edited one time!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'action-submit': \"Submit\",\n        }\n        preview_url = reverse('wagtailadmin_pages:preview_on_edit',\n                              args=(self.child_page.id,))\n        self.client.post(preview_url, post_data)\n        response = self.client.get(preview_url)\n        self.assertContains(response, \"I&#39;ve been edited one time!\", html=True)\n\n        post_data['title'] = \"I've been edited two times!\"\n        self.client.post(preview_url, post_data)\n        response = self.client.get(preview_url)\n        self.assertContains(response, \"I&#39;ve been edited two times!\", html=True)\n\n    @modify_settings(ALLOWED_HOSTS={'append': 'childpage.example.com'})\n    def test_preview_uses_correct_site(self):\n        # create a Site record for the child page\n        Site.objects.create(hostname='childpage.example.com', root_page=self.child_page)\n\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'action-submit': \"Submit\",\n        }\n        preview_url = reverse('wagtailadmin_pages:preview_on_edit',\n                              args=(self.child_page.id,))\n        response = self.client.post(preview_url, post_data)\n\n        # Check the JSON response\n        self.assertEqual(response.status_code, 200)\n        self.assertJSONEqual(response.content.decode(), {'is_valid': True})\n\n        response = self.client.get(preview_url)\n\n        # Check that the correct site object has been selected by the site middleware\n        self.assertEqual(response.status_code, 200)\n        self.assertTemplateUsed(response, 'tests/simple_page.html')\n        self.assertEqual(Site.find_for_request(response.context['request']).hostname, 'childpage.example.com')\n\n    def test_editor_picks_up_direct_model_edits(self):\n        # If a page has no draft edits, the editor should show the version from the live database\n        # record rather than the latest revision record. This ensures that the edit interface\n        # reflects any changes made directly on the model.\n        self.child_page.title = \"This title only exists on the live database record\"\n        self.child_page.save()\n\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )))\n        self.assertEqual(response.status_code, 200)\n        self.assertContains(response, \"This title only exists on the live database record\")\n\n    def test_editor_does_not_pick_up_direct_model_edits_when_draft_edits_exist(self):\n        # If a page has draft edits, we should always show those in the editor, not the live\n        # database record\n        self.child_page.content = \"Some content with a draft edit\"\n        self.child_page.save_revision()\n\n        # make an independent change to the live database record\n        self.child_page = SimplePage.objects.get(id=self.child_page.id)\n        self.child_page.title = \"This title only exists on the live database record\"\n        self.child_page.save()\n\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )))\n        self.assertEqual(response.status_code, 200)\n        self.assertNotContains(response, \"This title only exists on the live database record\")\n        self.assertContains(response, \"Some content with a draft edit\")\n\n    def test_editor_page_shows_live_url_in_status_when_draft_edits_exist(self):\n        # If a page has draft edits (ie. page has unpublished changes)\n        # that affect the URL (eg. slug) we  should still ensure the\n        # status button at the top of the page links to the live URL\n\n        self.child_page.content = \"Some content with a draft edit\"\n        self.child_page.slug = \"revised-slug-in-draft-only\"  # live version contains 'hello-world'\n        self.child_page.save_revision()\n\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )))\n\n        link_to_live = '<a href=\"/hello-world/\" target=\"_blank\" rel=\"noopener noreferrer\" class=\"button button-nostroke button--live\" title=\"Visit the live page\">\\n' \\\n                       '<svg class=\"icon icon-link-external initial\" aria-hidden=\"true\" focusable=\"false\"><use href=\"#icon-link-external\"></use></svg>\\n\\n        ' \\\n                       'Live\\n        <span class=\"privacy-indicator-tag u-hidden\" aria-hidden=\"true\" title=\"This page is live but only available to certain users\">(restricted)</span>'\n        input_field_for_draft_slug = '<input type=\"text\" name=\"slug\" value=\"revised-slug-in-draft-only\" id=\"id_slug\" maxlength=\"255\" required />'\n        input_field_for_live_slug = '<input type=\"text\" name=\"slug\" value=\"hello-world\" id=\"id_slug\" maxlength=\"255\" required />'\n\n        # Status Link should be the live page (not revision)\n        self.assertContains(response, link_to_live, html=True)\n        self.assertNotContains(response, 'href=\"/revised-slug-in-draft-only/\"', html=True)\n\n        # Editing input for slug should be the draft revision\n        self.assertContains(response, input_field_for_draft_slug, html=True)\n        self.assertNotContains(response, input_field_for_live_slug, html=True)\n\n    def test_editor_page_shows_custom_live_url_in_status_when_draft_edits_exist(self):\n        # When showing a live URL in the status button that differs from the draft one,\n        # ensure that we pick up any custom URL logic defined on the specific page model\n\n        self.single_event_page.location = \"The other side of Mars\"\n        self.single_event_page.slug = \"revised-slug-in-draft-only\"  # live version contains 'hello-world'\n        self.single_event_page.save_revision()\n\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.single_event_page.id, )))\n\n        link_to_live = '<a href=\"/mars-landing/pointless-suffix/\" target=\"_blank\" rel=\"noopener noreferrer\" class=\"button button-nostroke button--live\" title=\"Visit the live page\">\\n' \\\n                       '<svg class=\"icon icon-link-external initial\" aria-hidden=\"true\" focusable=\"false\"><use href=\"#icon-link-external\"></use></svg>\\n\\n        ' \\\n                       'Live\\n        <span class=\"privacy-indicator-tag u-hidden\" aria-hidden=\"true\" title=\"This page is live but only available to certain users\">(restricted)</span>'\n        input_field_for_draft_slug = '<input type=\"text\" name=\"slug\" value=\"revised-slug-in-draft-only\" id=\"id_slug\" maxlength=\"255\" required />'\n        input_field_for_live_slug = '<input type=\"text\" name=\"slug\" value=\"mars-landing\" id=\"id_slug\" maxlength=\"255\" required />'\n\n        # Status Link should be the live page (not revision)\n        self.assertContains(response, link_to_live, html=True)\n        self.assertNotContains(response, 'href=\"/revised-slug-in-draft-only/pointless-suffix/\"', html=True)\n\n        # Editing input for slug should be the draft revision\n        self.assertContains(response, input_field_for_draft_slug, html=True)\n        self.assertNotContains(response, input_field_for_live_slug, html=True)\n\n    def test_before_edit_page_hook(self):\n        def hook_func(request, page):\n            self.assertIsInstance(request, HttpRequest)\n            self.assertEqual(page.id, self.child_page.id)\n\n            return HttpResponse(\"Overridden!\")\n\n        with self.register_hook('before_edit_page', hook_func):\n            response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )))\n\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b\"Overridden!\")\n\n    def test_before_edit_page_hook_post(self):\n        def hook_func(request, page):\n            self.assertIsInstance(request, HttpRequest)\n            self.assertEqual(page.id, self.child_page.id)\n\n            return HttpResponse(\"Overridden!\")\n\n        with self.register_hook('before_edit_page', hook_func):\n            post_data = {\n                'title': \"I've been edited!\",\n                'content': \"Some content\",\n                'slug': 'hello-world-new',\n                'action-publish': \"Publish\",\n            }\n            response = self.client.post(\n                reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data\n            )\n\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b\"Overridden!\")\n\n        # page should not be edited\n        self.assertEqual(Page.objects.get(id=self.child_page.id).title, \"Hello world!\")\n\n    def test_after_edit_page_hook(self):\n        def hook_func(request, page):\n            self.assertIsInstance(request, HttpRequest)\n            self.assertEqual(page.id, self.child_page.id)\n\n            return HttpResponse(\"Overridden!\")\n\n        with self.register_hook('after_edit_page', hook_func):\n            post_data = {\n                'title': \"I've been edited!\",\n                'content': \"Some content\",\n                'slug': 'hello-world-new',\n                'action-publish': \"Publish\",\n            }\n            response = self.client.post(\n                reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data\n            )\n\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b\"Overridden!\")\n\n        # page should be edited\n        self.assertEqual(Page.objects.get(id=self.child_page.id).title, \"I've been edited!\")\n\n    def test_after_publish_page(self):\n        def hook_func(request, page):\n            self.assertIsInstance(request, HttpRequest)\n            self.assertEqual(page.id, self.child_page.id)\n\n            return HttpResponse(\"Overridden!\")\n\n        with self.register_hook(\"after_publish_page\", hook_func):\n            post_data = {\n                'title': \"I've been edited!\",\n                'content': \"Some content\",\n                'slug': 'hello-world-new',\n                'action-publish': \"Publish\",\n            }\n            response = self.client.post(\n                reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data\n            )\n\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b\"Overridden!\")\n        self.child_page.refresh_from_db()\n        self.assertEqual(self.child_page.status_string, _(\"live\"))\n\n    def test_before_publish_page(self):\n        def hook_func(request, page):\n            self.assertIsInstance(request, HttpRequest)\n            self.assertEqual(page.id, self.child_page.id)\n\n            return HttpResponse(\"Overridden!\")\n\n        with self.register_hook(\"before_publish_page\", hook_func):\n            post_data = {\n                'title': \"I've been edited!\",\n                'content': \"Some content\",\n                'slug': 'hello-world-new',\n                'action-publish': \"Publish\",\n            }\n            response = self.client.post(\n                reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data\n            )\n\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b\"Overridden!\")\n        self.child_page.refresh_from_db()\n        self.assertEqual(self.child_page.status_string, _(\"live + draft\"))\n\n    def test_override_default_action_menu_item(self):\n        def hook_func(menu_items, request, context):\n            for (index, item) in enumerate(menu_items):\n                if item.name == 'action-publish':\n                    # move to top of list\n                    menu_items.pop(index)\n                    menu_items.insert(0, item)\n                    break\n\n        with self.register_hook('construct_page_action_menu', hook_func):\n            response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.single_event_page.id, )))\n\n        publish_button = '''\n            <button type=\"submit\" name=\"action-publish\" value=\"action-publish\" class=\"button button-longrunning \" data-clicked-text=\"Publishing\u2026\">\n                <svg class=\"icon icon-upload button-longrunning__icon\" aria-hidden=\"true\" focusable=\"false\"><use href=\"#icon-upload\"></use></svg>\n\n                <svg class=\"icon icon-spinner icon\" aria-hidden=\"true\" focusable=\"false\"><use href=\"#icon-spinner\"></use></svg><em>Publish</em>\n            </button>\n        '''\n        save_button = '''\n            <button type=\"submit\" class=\"button action-save button-longrunning \" data-clicked-text=\"Saving\u2026\" >\n                <svg class=\"icon icon-draft button-longrunning__icon\" aria-hidden=\"true\" focusable=\"false\"><use href=\"#icon-draft\"></use></svg>\n\n                <svg class=\"icon icon-spinner icon\" aria-hidden=\"true\" focusable=\"false\"><use href=\"#icon-spinner\"></use></svg>\n                <em>Save draft</em>\n            </button>\n        '''\n\n        # save button should be in a <li>\n        self.assertContains(response, \"<li>%s</li>\" % save_button, html=True)\n\n        # publish button should be present, but not in a <li>\n        self.assertContains(response, publish_button, html=True)\n        self.assertNotContains(response, \"<li>%s</li>\" % publish_button, html=True)\n\n    def test_edit_alias_page(self):\n        alias_page = self.event_page.create_alias(update_slug='new-event-page')\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=[alias_page.id]))\n\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response['Content-Type'], \"text/html; charset=utf-8\")\n\n        # Should still have status in the header\n        self.assertContains(response, '<li class=\"header-meta--status\">Published</li>', html=True)\n\n        # Check the edit_alias.html template was used instead\n        self.assertTemplateUsed(response, 'wagtailadmin/pages/edit_alias.html')\n        original_page_edit_url = reverse('wagtailadmin_pages:edit', args=[self.event_page.id])\n        self.assertContains(response, f'<a class=\"button button-secondary\" href=\"{original_page_edit_url}\">Edit original page</a>', html=True)\n\n    def test_post_edit_alias_page(self):\n        alias_page = self.child_page.create_alias(update_slug='new-child-page')\n\n        # Tests simple editing\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[alias_page.id]), post_data)\n\n        self.assertEqual(response.status_code, 405)\n\n    def test_edit_after_change_language_code(self):\n        \"\"\"\n        Verify that changing LANGUAGE_CODE with no corresponding database change does not break editing\n        \"\"\"\n        # Add a draft revision\n        self.child_page.title = \"Hello world updated\"\n        self.child_page.save_revision()\n\n        # Hack the Locale model to simulate a page tree that was created with LANGUAGE_CODE = 'de'\n        # (which is not a valid content language under the current configuration)\n        Locale.objects.update(language_code='de')\n\n        # Tests that the edit page loads\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )))\n        self.assertEqual(response.status_code, 200)\n\n        # Tests simple editing\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)\n\n        # Should be redirected to edit page\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )))\n\n    def test_edit_after_change_language_code_without_revisions(self):\n        \"\"\"\n        Verify that changing LANGUAGE_CODE with no corresponding database change does not break editing\n        \"\"\"\n        # Hack the Locale model to simulate a page tree that was created with LANGUAGE_CODE = 'de'\n        # (which is not a valid content language under the current configuration)\n        Locale.objects.update(language_code='de')\n\n        PageRevision.objects.filter(page_id=self.child_page.id).delete()\n\n        # Tests that the edit page loads\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )))\n        self.assertEqual(response.status_code, 200)\n\n        # Tests simple editing\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)\n\n        # Should be redirected to edit page\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )))\n\n\nclass TestPageEditReordering(TestCase, WagtailTestUtils):\n    def setUp(self):\n        # Find root page\n        self.root_page = Page.objects.get(id=2)\n\n        # Add event page\n        self.event_page = EventPage(\n            title=\"Event page\", slug=\"event-page\",\n            location='the moon', audience='public',\n            cost='free', date_from='2001-01-01',\n        )\n        self.event_page.carousel_items = [\n            EventPageCarouselItem(caption='1234567', sort_order=1),\n            EventPageCarouselItem(caption='7654321', sort_order=2),\n            EventPageCarouselItem(caption='abcdefg', sort_order=3),\n        ]\n        self.root_page.add_child(instance=self.event_page)\n\n        # Login\n        self.user = self.login()\n\n    def check_order(self, response, expected_order):\n        inline_panel = response.context['edit_handler'].children[0].children[9]\n        order = [child.form.instance.caption for child in inline_panel.children]\n        self.assertEqual(order, expected_order)\n\n    def test_order(self):\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.event_page.id, )))\n\n        self.assertEqual(response.status_code, 200)\n        self.check_order(response, ['1234567', '7654321', 'abcdefg'])\n\n    def test_reorder(self):\n        post_data = {\n            'title': \"Event page\",\n            'slug': 'event-page',\n\n            'date_from': '01/01/2014',\n            'cost': '$10',\n            'audience': 'public',\n            'location': 'somewhere',\n\n            'related_links-INITIAL_FORMS': 0,\n            'related_links-MAX_NUM_FORMS': 1000,\n            'related_links-TOTAL_FORMS': 0,\n\n            'speakers-INITIAL_FORMS': 0,\n            'speakers-MAX_NUM_FORMS': 1000,\n            'speakers-TOTAL_FORMS': 0,\n\n            'head_counts-INITIAL_FORMS': 0,\n            'head_counts-MAX_NUM_FORMS': 1000,\n            'head_counts-TOTAL_FORMS': 0,\n\n            'carousel_items-INITIAL_FORMS': 3,\n            'carousel_items-MAX_NUM_FORMS': 1000,\n            'carousel_items-TOTAL_FORMS': 3,\n            'carousel_items-0-id': self.event_page.carousel_items.all()[0].id,\n            'carousel_items-0-caption': self.event_page.carousel_items.all()[0].caption,\n            'carousel_items-0-ORDER': 2,\n            'carousel_items-1-id': self.event_page.carousel_items.all()[1].id,\n            'carousel_items-1-caption': self.event_page.carousel_items.all()[1].caption,\n            'carousel_items-1-ORDER': 3,\n            'carousel_items-2-id': self.event_page.carousel_items.all()[2].id,\n            'carousel_items-2-caption': self.event_page.carousel_items.all()[2].caption,\n            'carousel_items-2-ORDER': 1,\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.event_page.id, )), post_data)\n\n        # Should be redirected back to same page\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=(self.event_page.id, )))\n\n        # Check order\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.event_page.id, )))\n\n        self.assertEqual(response.status_code, 200)\n        self.check_order(response, ['abcdefg', '1234567', '7654321'])\n\n    def test_reorder_with_validation_error(self):\n        post_data = {\n            'title': \"\",  # Validation error\n            'slug': 'event-page',\n\n            'date_from': '01/01/2014',\n            'cost': '$10',\n            'audience': 'public',\n            'location': 'somewhere',\n\n            'related_links-INITIAL_FORMS': 0,\n            'related_links-MAX_NUM_FORMS': 1000,\n            'related_links-TOTAL_FORMS': 0,\n\n            'speakers-INITIAL_FORMS': 0,\n            'speakers-MAX_NUM_FORMS': 1000,\n            'speakers-TOTAL_FORMS': 0,\n\n            'head_counts-INITIAL_FORMS': 0,\n            'head_counts-MAX_NUM_FORMS': 1000,\n            'head_counts-TOTAL_FORMS': 0,\n\n            'carousel_items-INITIAL_FORMS': 3,\n            'carousel_items-MAX_NUM_FORMS': 1000,\n            'carousel_items-TOTAL_FORMS': 3,\n            'carousel_items-0-id': self.event_page.carousel_items.all()[0].id,\n            'carousel_items-0-caption': self.event_page.carousel_items.all()[0].caption,\n            'carousel_items-0-ORDER': 2,\n            'carousel_items-1-id': self.event_page.carousel_items.all()[1].id,\n            'carousel_items-1-caption': self.event_page.carousel_items.all()[1].caption,\n            'carousel_items-1-ORDER': 3,\n            'carousel_items-2-id': self.event_page.carousel_items.all()[2].id,\n            'carousel_items-2-caption': self.event_page.carousel_items.all()[2].caption,\n            'carousel_items-2-ORDER': 1,\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.event_page.id, )), post_data)\n\n        self.assertEqual(response.status_code, 200)\n        self.check_order(response, ['abcdefg', '1234567', '7654321'])\n\n\nclass TestIssue197(TestCase, WagtailTestUtils):\n    def test_issue_197(self):\n        # Find root page\n        self.root_page = Page.objects.get(id=2)\n\n        # Create a tagged page with no tags\n        self.tagged_page = self.root_page.add_child(instance=TaggedPage(\n            title=\"Tagged page\",\n            slug='tagged-page',\n            live=False,\n        ))\n\n        # Login\n        self.user = self.login()\n\n        # Add some tags and publish using edit view\n        post_data = {\n            'title': \"Tagged page\",\n            'slug': 'tagged-page',\n            'tags': \"hello, world\",\n            'action-publish': \"Publish\",\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.tagged_page.id, )), post_data)\n\n        # Should be redirected to explorer\n        self.assertRedirects(response, reverse('wagtailadmin_explore', args=(self.root_page.id, )))\n\n        # Check that both tags are in the pages tag set\n        page = TaggedPage.objects.get(id=self.tagged_page.id)\n        self.assertIn('hello', page.tags.slugs())\n        self.assertIn('world', page.tags.slugs())\n\n\nclass TestChildRelationsOnSuperclass(TestCase, WagtailTestUtils):\n    # In our test models we define AdvertPlacement as a child relation on the Page model.\n    # Here we check that this behaves correctly when exposed on the edit form of a Page\n    # subclass (StandardIndex here).\n    fixtures = ['test.json']\n\n    def setUp(self):\n        # Find root page\n        self.root_page = Page.objects.get(id=2)\n        self.test_advert = Advert.objects.get(id=1)\n\n        # Add child page\n        self.index_page = StandardIndex(\n            title=\"My lovely index\",\n            slug=\"my-lovely-index\",\n            advert_placements=[AdvertPlacement(advert=self.test_advert)]\n        )\n        self.root_page.add_child(instance=self.index_page)\n\n        # Login\n        self.login()\n\n    def test_get_create_form(self):\n        response = self.client.get(\n            reverse('wagtailadmin_pages:add', args=('tests', 'standardindex', self.root_page.id))\n        )\n        self.assertEqual(response.status_code, 200)\n        # Response should include an advert_placements formset labelled Adverts\n        self.assertContains(response, \"Adverts\")\n        self.assertContains(response, \"id_advert_placements-TOTAL_FORMS\")\n\n    def test_post_create_form(self):\n        post_data = {\n            'title': \"New index!\",\n            'slug': 'new-index',\n            'advert_placements-TOTAL_FORMS': '1',\n            'advert_placements-INITIAL_FORMS': '0',\n            'advert_placements-MAX_NUM_FORMS': '1000',\n            'advert_placements-0-advert': '1',\n            'advert_placements-0-colour': 'yellow',\n            'advert_placements-0-id': '',\n        }\n        response = self.client.post(\n            reverse('wagtailadmin_pages:add', args=('tests', 'standardindex', self.root_page.id)), post_data\n        )\n\n        # Find the page and check it\n        page = Page.objects.get(path__startswith=self.root_page.path, slug='new-index').specific\n\n        # Should be redirected to edit page\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=(page.id, )))\n\n        self.assertEqual(page.advert_placements.count(), 1)\n        self.assertEqual(page.advert_placements.first().advert.text, 'test_advert')\n\n    def test_post_create_form_with_validation_error_in_formset(self):\n        post_data = {\n            'title': \"New index!\",\n            'slug': 'new-index',\n            'advert_placements-TOTAL_FORMS': '1',\n            'advert_placements-INITIAL_FORMS': '0',\n            'advert_placements-MAX_NUM_FORMS': '1000',\n            'advert_placements-0-advert': '1',\n            'advert_placements-0-colour': '',  # should fail as colour is a required field\n            'advert_placements-0-id': '',\n        }\n        response = self.client.post(\n            reverse('wagtailadmin_pages:add', args=('tests', 'standardindex', self.root_page.id)), post_data\n        )\n\n        # Should remain on the edit page with a validation error\n        self.assertEqual(response.status_code, 200)\n        self.assertContains(response, \"This field is required.\")\n        # form should be marked as having unsaved changes\n        self.assertContains(response, \"alwaysDirty: true\")\n\n    def test_get_edit_form(self):\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.index_page.id, )))\n        self.assertEqual(response.status_code, 200)\n\n        # Response should include an advert_placements formset labelled Adverts\n        self.assertContains(response, \"Adverts\")\n        self.assertContains(response, \"id_advert_placements-TOTAL_FORMS\")\n        # the formset should be populated with an existing form\n        self.assertContains(response, \"id_advert_placements-0-advert\")\n        self.assertContains(\n            response, '<option value=\"1\" selected=\"selected\">test_advert</option>', html=True\n        )\n\n    def test_post_edit_form(self):\n        post_data = {\n            'title': \"My lovely index\",\n            'slug': 'my-lovely-index',\n            'advert_placements-TOTAL_FORMS': '2',\n            'advert_placements-INITIAL_FORMS': '1',\n            'advert_placements-MAX_NUM_FORMS': '1000',\n            'advert_placements-0-advert': '1',\n            'advert_placements-0-colour': 'yellow',\n            'advert_placements-0-id': self.index_page.advert_placements.first().id,\n            'advert_placements-1-advert': '1',\n            'advert_placements-1-colour': 'purple',\n            'advert_placements-1-id': '',\n            'action-publish': \"Publish\",\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.index_page.id, )), post_data)\n\n        # Should be redirected to explorer\n        self.assertRedirects(response, reverse('wagtailadmin_explore', args=(self.root_page.id, )))\n\n        # Find the page and check it\n        page = Page.objects.get(id=self.index_page.id).specific\n        self.assertEqual(page.advert_placements.count(), 2)\n        self.assertEqual(page.advert_placements.all()[0].advert.text, 'test_advert')\n        self.assertEqual(page.advert_placements.all()[1].advert.text, 'test_advert')\n\n    def test_post_edit_form_with_validation_error_in_formset(self):\n        post_data = {\n            'title': \"My lovely index\",\n            'slug': 'my-lovely-index',\n            'advert_placements-TOTAL_FORMS': '1',\n            'advert_placements-INITIAL_FORMS': '1',\n            'advert_placements-MAX_NUM_FORMS': '1000',\n            'advert_placements-0-advert': '1',\n            'advert_placements-0-colour': '',\n            'advert_placements-0-id': self.index_page.advert_placements.first().id,\n            'action-publish': \"Publish\",\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.index_page.id, )), post_data)\n\n        # Should remain on the edit page with a validation error\n        self.assertEqual(response.status_code, 200)\n        self.assertContains(response, \"This field is required.\")\n        # form should be marked as having unsaved changes\n        self.assertContains(response, \"alwaysDirty: true\")\n\n\nclass TestIssue2492(TestCase, WagtailTestUtils):\n    \"\"\"\n    The publication submission message generation was performed using\n    the Page class, as opposed to the specific_class for that Page.\n    This test ensures that the specific_class url method is called\n    when the 'view live' message button is created.\n    \"\"\"\n\n    def setUp(self):\n        self.root_page = Page.objects.get(id=2)\n        child_page = SingleEventPage(\n            title=\"Test Event\", slug=\"test-event\", location=\"test location\",\n            cost=\"10\", date_from=datetime.datetime.now(),\n            audience=EVENT_AUDIENCE_CHOICES[0][0])\n        self.root_page.add_child(instance=child_page)\n        child_page.save_revision().publish()\n        self.child_page = SingleEventPage.objects.get(id=child_page.id)\n        self.user = self.login()\n\n    def test_page_edit_post_publish_url(self):\n        post_data = {\n            'action-publish': \"Publish\",\n            'title': self.child_page.title,\n            'date_from': self.child_page.date_from,\n            'slug': self.child_page.slug,\n            'audience': self.child_page.audience,\n            'location': self.child_page.location,\n            'cost': self.child_page.cost,\n            'carousel_items-TOTAL_FORMS': 0,\n            'carousel_items-INITIAL_FORMS': 0,\n            'carousel_items-MIN_NUM_FORMS': 0,\n            'carousel_items-MAX_NUM_FORMS': 0,\n            'speakers-TOTAL_FORMS': 0,\n            'speakers-INITIAL_FORMS': 0,\n            'speakers-MIN_NUM_FORMS': 0,\n            'speakers-MAX_NUM_FORMS': 0,\n            'related_links-TOTAL_FORMS': 0,\n            'related_links-INITIAL_FORMS': 0,\n            'related_links-MIN_NUM_FORMS': 0,\n            'related_links-MAX_NUM_FORMS': 0,\n            'head_counts-TOTAL_FORMS': 0,\n            'head_counts-INITIAL_FORMS': 0,\n            'head_counts-MIN_NUM_FORMS': 0,\n            'head_counts-MAX_NUM_FORMS': 0,\n        }\n        response = self.client.post(\n            reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )),\n            post_data, follow=True)\n\n        # Grab a fresh copy's URL\n        new_url = SingleEventPage.objects.get(id=self.child_page.id).url\n\n        # The \"View Live\" button should have the custom URL.\n        for message in response.context['messages']:\n            self.assertIn('\"{}\"'.format(new_url), message.message)\n            break\n\n\nclass TestIssue3982(TestCase, WagtailTestUtils):\n    \"\"\"\n    Pages that are not associated with a site, and thus do not have a live URL,\n    should not display a \"View live\" link in the flash message after being\n    edited.\n    \"\"\"\n\n    def setUp(self):\n        super().setUp()\n        self.login()\n\n    def _create_page(self, parent):\n        response = self.client.post(\n            reverse('wagtailadmin_pages:add', args=('tests', 'simplepage', parent.pk)),\n            {'title': \"Hello, world!\", 'content': \"Some content\", 'slug': 'hello-world', 'action-publish': \"publish\"},\n            follow=True)\n        self.assertRedirects(response, reverse('wagtailadmin_explore', args=(parent.pk,)))\n        page = SimplePage.objects.get()\n        self.assertTrue(page.live)\n        return response, page\n\n    def test_create_accessible(self):\n        \"\"\"\n        Create a page under the site root, check the flash message has a valid\n        \"View live\" button.\n        \"\"\"\n        response, page = self._create_page(Page.objects.get(pk=2))\n        self.assertIsNotNone(page.url)\n        self.assertTrue(any(\n            'View live' in message.message and page.url in message.message\n            for message in response.context['messages']))\n\n    def test_create_inaccessible(self):\n        \"\"\"\n        Create a page outside of the site root, check the flash message does\n        not have a \"View live\" button.\n        \"\"\"\n        response, page = self._create_page(Page.objects.get(pk=1))\n        self.assertIsNone(page.url)\n        self.assertFalse(any(\n            'View live' in message.message\n            for message in response.context['messages']))\n\n    def _edit_page(self, parent):\n        page = parent.add_child(instance=SimplePage(title='Hello, world!', content='Some content'))\n        response = self.client.post(\n            reverse('wagtailadmin_pages:edit', args=(page.pk,)),\n            {'title': \"Hello, world!\", 'content': \"Some content\", 'slug': 'hello-world', 'action-publish': \"publish\"},\n            follow=True)\n        self.assertRedirects(response, reverse('wagtailadmin_explore', args=(parent.pk,)))\n        page = SimplePage.objects.get(pk=page.pk)\n        self.assertTrue(page.live)\n        return response, page\n\n    def test_edit_accessible(self):\n        \"\"\"\n        Edit a page under the site root, check the flash message has a valid\n        \"View live\" button.\n        \"\"\"\n        response, page = self._edit_page(Page.objects.get(pk=2))\n        self.assertIsNotNone(page.url)\n        self.assertTrue(any(\n            'View live' in message.message and page.url in message.message\n            for message in response.context['messages']))\n\n    def test_edit_inaccessible(self):\n        \"\"\"\n        Edit a page outside of the site root, check the flash message does\n        not have a \"View live\" button.\n        \"\"\"\n        response, page = self._edit_page(Page.objects.get(pk=1))\n        self.assertIsNone(page.url)\n        self.assertFalse(any(\n            'View live' in message.message\n            for message in response.context['messages']))\n\n    def _approve_page(self, parent):\n        response = self.client.post(\n            reverse('wagtailadmin_pages:add', args=('tests', 'simplepage', parent.pk)),\n            {'title': \"Hello, world!\", 'content': \"Some content\", 'slug': 'hello-world'},\n            follow=True)\n        page = SimplePage.objects.get()\n        self.assertFalse(page.live)\n        revision = PageRevision.objects.get(page=page)\n        revision.submitted_for_moderation = True\n        revision.save()\n        response = self.client.post(reverse('wagtailadmin_pages:approve_moderation', args=(revision.pk,)), follow=True)\n        page = SimplePage.objects.get()\n        self.assertTrue(page.live)\n        self.assertRedirects(response, reverse('wagtailadmin_home'))\n        return response, page\n\n    def test_approve_accessible(self):\n        \"\"\"\n        Edit a page under the site root, check the flash message has a valid\n        \"View live\" button.\n        \"\"\"\n        response, page = self._approve_page(Page.objects.get(pk=2))\n        self.assertIsNotNone(page.url)\n        self.assertTrue(any(\n            'View live' in message.message and page.url in message.message\n            for message in response.context['messages']))\n\n    def test_approve_inaccessible(self):\n        \"\"\"\n        Edit a page outside of the site root, check the flash message does\n        not have a \"View live\" button.\n        \"\"\"\n        response, page = self._approve_page(Page.objects.get(pk=1))\n        self.assertIsNone(page.url)\n        self.assertFalse(any(\n            'View live' in message.message\n            for message in response.context['messages']))\n\n\nclass TestParentalM2M(TestCase, WagtailTestUtils):\n    fixtures = ['test.json']\n\n    def setUp(self):\n        self.events_index = Page.objects.get(url_path='/home/events/')\n        self.christmas_page = Page.objects.get(url_path='/home/events/christmas/')\n        self.user = self.login()\n        self.holiday_category = EventCategory.objects.create(name='Holiday')\n        self.men_with_beards_category = EventCategory.objects.create(name='Men with beards')\n\n    def test_create_and_save(self):\n        post_data = {\n            'title': \"Presidents' Day\",\n            'date_from': \"2017-02-20\",\n            'slug': \"presidents-day\",\n            'audience': \"public\",\n            'location': \"America\",\n            'cost': \"$1\",\n            'carousel_items-TOTAL_FORMS': 0,\n            'carousel_items-INITIAL_FORMS': 0,\n            'carousel_items-MIN_NUM_FORMS': 0,\n            'carousel_items-MAX_NUM_FORMS': 0,\n            'speakers-TOTAL_FORMS': 0,\n            'speakers-INITIAL_FORMS': 0,\n            'speakers-MIN_NUM_FORMS': 0,\n            'speakers-MAX_NUM_FORMS': 0,\n            'related_links-TOTAL_FORMS': 0,\n            'related_links-INITIAL_FORMS': 0,\n            'related_links-MIN_NUM_FORMS': 0,\n            'related_links-MAX_NUM_FORMS': 0,\n            'head_counts-TOTAL_FORMS': 0,\n            'head_counts-INITIAL_FORMS': 0,\n            'head_counts-MIN_NUM_FORMS': 0,\n            'head_counts-MAX_NUM_FORMS': 0,\n            'categories': [self.holiday_category.id, self.men_with_beards_category.id]\n        }\n        response = self.client.post(\n            reverse('wagtailadmin_pages:add', args=('tests', 'eventpage', self.events_index.id)),\n            post_data\n        )\n        created_page = EventPage.objects.get(url_path='/home/events/presidents-day/')\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=(created_page.id, )))\n        created_revision = created_page.get_latest_revision_as_page()\n\n        self.assertIn(self.holiday_category, created_revision.categories.all())\n        self.assertIn(self.men_with_beards_category, created_revision.categories.all())\n\n    def test_create_and_publish(self):\n        post_data = {\n            'action-publish': \"Publish\",\n            'title': \"Presidents' Day\",\n            'date_from': \"2017-02-20\",\n            'slug': \"presidents-day\",\n            'audience': \"public\",\n            'location': \"America\",\n            'cost': \"$1\",\n            'carousel_items-TOTAL_FORMS': 0,\n            'carousel_items-INITIAL_FORMS': 0,\n            'carousel_items-MIN_NUM_FORMS': 0,\n            'carousel_items-MAX_NUM_FORMS': 0,\n            'speakers-TOTAL_FORMS': 0,\n            'speakers-INITIAL_FORMS': 0,\n            'speakers-MIN_NUM_FORMS': 0,\n            'speakers-MAX_NUM_FORMS': 0,\n            'related_links-TOTAL_FORMS': 0,\n            'related_links-INITIAL_FORMS': 0,\n            'related_links-MIN_NUM_FORMS': 0,\n            'related_links-MAX_NUM_FORMS': 0,\n            'head_counts-TOTAL_FORMS': 0,\n            'head_counts-INITIAL_FORMS': 0,\n            'head_counts-MIN_NUM_FORMS': 0,\n            'head_counts-MAX_NUM_FORMS': 0,\n            'categories': [self.holiday_category.id, self.men_with_beards_category.id]\n        }\n        response = self.client.post(\n            reverse('wagtailadmin_pages:add', args=('tests', 'eventpage', self.events_index.id)),\n            post_data\n        )\n        self.assertRedirects(response, reverse('wagtailadmin_explore', args=(self.events_index.id, )))\n\n        created_page = EventPage.objects.get(url_path='/home/events/presidents-day/')\n        self.assertIn(self.holiday_category, created_page.categories.all())\n        self.assertIn(self.men_with_beards_category, created_page.categories.all())\n\n    def test_edit_and_save(self):\n        post_data = {\n            'title': \"Christmas\",\n            'date_from': \"2017-12-25\",\n            'slug': \"christmas\",\n            'audience': \"public\",\n            'location': \"The North Pole\",\n            'cost': \"Free\",\n            'carousel_items-TOTAL_FORMS': 0,\n            'carousel_items-INITIAL_FORMS': 0,\n            'carousel_items-MIN_NUM_FORMS': 0,\n            'carousel_items-MAX_NUM_FORMS': 0,\n            'speakers-TOTAL_FORMS': 0,\n            'speakers-INITIAL_FORMS': 0,\n            'speakers-MIN_NUM_FORMS': 0,\n            'speakers-MAX_NUM_FORMS': 0,\n            'related_links-TOTAL_FORMS': 0,\n            'related_links-INITIAL_FORMS': 0,\n            'related_links-MIN_NUM_FORMS': 0,\n            'related_links-MAX_NUM_FORMS': 0,\n            'head_counts-TOTAL_FORMS': 0,\n            'head_counts-INITIAL_FORMS': 0,\n            'head_counts-MIN_NUM_FORMS': 0,\n            'head_counts-MAX_NUM_FORMS': 0,\n            'categories': [self.holiday_category.id, self.men_with_beards_category.id]\n        }\n        response = self.client.post(\n            reverse('wagtailadmin_pages:edit', args=(self.christmas_page.id, )),\n            post_data\n        )\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=(self.christmas_page.id, )))\n        updated_page = EventPage.objects.get(id=self.christmas_page.id)\n        created_revision = updated_page.get_latest_revision_as_page()\n\n        self.assertIn(self.holiday_category, created_revision.categories.all())\n        self.assertIn(self.men_with_beards_category, created_revision.categories.all())\n\n        # no change to live page record yet\n        self.assertEqual(0, updated_page.categories.count())\n\n    def test_edit_and_publish(self):\n        post_data = {\n            'action-publish': \"Publish\",\n            'title': \"Christmas\",\n            'date_from': \"2017-12-25\",\n            'slug': \"christmas\",\n            'audience': \"public\",\n            'location': \"The North Pole\",\n            'cost': \"Free\",\n            'carousel_items-TOTAL_FORMS': 0,\n            'carousel_items-INITIAL_FORMS': 0,\n            'carousel_items-MIN_NUM_FORMS': 0,\n            'carousel_items-MAX_NUM_FORMS': 0,\n            'speakers-TOTAL_FORMS': 0,\n            'speakers-INITIAL_FORMS': 0,\n            'speakers-MIN_NUM_FORMS': 0,\n            'speakers-MAX_NUM_FORMS': 0,\n            'related_links-TOTAL_FORMS': 0,\n            'related_links-INITIAL_FORMS': 0,\n            'related_links-MIN_NUM_FORMS': 0,\n            'related_links-MAX_NUM_FORMS': 0,\n            'head_counts-TOTAL_FORMS': 0,\n            'head_counts-INITIAL_FORMS': 0,\n            'head_counts-MIN_NUM_FORMS': 0,\n            'head_counts-MAX_NUM_FORMS': 0,\n            'categories': [self.holiday_category.id, self.men_with_beards_category.id]\n        }\n        response = self.client.post(\n            reverse('wagtailadmin_pages:edit', args=(self.christmas_page.id, )),\n            post_data\n        )\n        self.assertRedirects(response, reverse('wagtailadmin_explore', args=(self.events_index.id, )))\n        updated_page = EventPage.objects.get(id=self.christmas_page.id)\n        self.assertEqual(2, updated_page.categories.count())\n        self.assertIn(self.holiday_category, updated_page.categories.all())\n        self.assertIn(self.men_with_beards_category, updated_page.categories.all())\n\n\nclass TestValidationErrorMessages(TestCase, WagtailTestUtils):\n    fixtures = ['test.json']\n\n    def setUp(self):\n        self.events_index = Page.objects.get(url_path='/home/events/')\n        self.christmas_page = Page.objects.get(url_path='/home/events/christmas/')\n        self.user = self.login()\n\n    def test_field_error(self):\n        \"\"\"Field errors should be shown against the relevant fields, not in the header message\"\"\"\n        post_data = {\n            'title': \"\",\n            'date_from': \"2017-12-25\",\n            'slug': \"christmas\",\n            'audience': \"public\",\n            'location': \"The North Pole\",\n            'cost': \"Free\",\n            'carousel_items-TOTAL_FORMS': 0,\n            'carousel_items-INITIAL_FORMS': 0,\n            'carousel_items-MIN_NUM_FORMS': 0,\n            'carousel_items-MAX_NUM_FORMS': 0,\n            'speakers-TOTAL_FORMS': 0,\n            'speakers-INITIAL_FORMS': 0,\n            'speakers-MIN_NUM_FORMS': 0,\n            'speakers-MAX_NUM_FORMS': 0,\n            'related_links-TOTAL_FORMS': 0,\n            'related_links-INITIAL_FORMS': 0,\n            'related_links-MIN_NUM_FORMS': 0,\n            'related_links-MAX_NUM_FORMS': 0,\n            'head_counts-TOTAL_FORMS': 0,\n            'head_counts-INITIAL_FORMS': 0,\n            'head_counts-MIN_NUM_FORMS': 0,\n            'head_counts-MAX_NUM_FORMS': 0,\n        }\n        response = self.client.post(\n            reverse('wagtailadmin_pages:edit', args=(self.christmas_page.id, )),\n            post_data\n        )\n        self.assertEqual(response.status_code, 200)\n\n        self.assertContains(response, \"The page could not be saved due to validation errors\")\n        # the error should only appear once: against the field, not in the header message\n        self.assertContains(response, \"\"\"<p class=\"error-message\"><span>This field is required.</span></p>\"\"\", count=1, html=True)\n        self.assertContains(response, \"This field is required\", count=1)\n\n    def test_non_field_error(self):\n        \"\"\"Non-field errors should be shown in the header message\"\"\"\n        post_data = {\n            'title': \"Christmas\",\n            'date_from': \"2017-12-25\",\n            'date_to': \"2017-12-24\",\n            'slug': \"christmas\",\n            'audience': \"public\",\n            'location': \"The North Pole\",\n            'cost': \"Free\",\n            'carousel_items-TOTAL_FORMS': 0,\n            'carousel_items-INITIAL_FORMS': 0,\n            'carousel_items-MIN_NUM_FORMS': 0,\n            'carousel_items-MAX_NUM_FORMS': 0,\n            'speakers-TOTAL_FORMS': 0,\n            'speakers-INITIAL_FORMS': 0,\n            'speakers-MIN_NUM_FORMS': 0,\n            'speakers-MAX_NUM_FORMS': 0,\n            'related_links-TOTAL_FORMS': 0,\n            'related_links-INITIAL_FORMS': 0,\n            'related_links-MIN_NUM_FORMS': 0,\n            'related_links-MAX_NUM_FORMS': 0,\n            'head_counts-TOTAL_FORMS': 0,\n            'head_counts-INITIAL_FORMS': 0,\n            'head_counts-MIN_NUM_FORMS': 0,\n            'head_counts-MAX_NUM_FORMS': 0,\n        }\n        response = self.client.post(\n            reverse('wagtailadmin_pages:edit', args=(self.christmas_page.id, )),\n            post_data\n        )\n        self.assertEqual(response.status_code, 200)\n\n        self.assertContains(response, \"The page could not be saved due to validation errors\")\n        self.assertContains(response, \"<li>The end date must be after the start date</li>\", count=1)\n\n    def test_field_and_non_field_error(self):\n        \"\"\"\n        If both field and non-field errors exist, all errors should be shown in the header message\n        with appropriate context to identify the field; and field errors should also be shown\n        against the relevant fields.\n        \"\"\"\n        post_data = {\n            'title': \"\",\n            'date_from': \"2017-12-25\",\n            'date_to': \"2017-12-24\",\n            'slug': \"christmas\",\n            'audience': \"public\",\n            'location': \"The North Pole\",\n            'cost': \"Free\",\n            'carousel_items-TOTAL_FORMS': 0,\n            'carousel_items-INITIAL_FORMS': 0,\n            'carousel_items-MIN_NUM_FORMS': 0,\n            'carousel_items-MAX_NUM_FORMS': 0,\n            'speakers-TOTAL_FORMS': 0,\n            'speakers-INITIAL_FORMS': 0,\n            'speakers-MIN_NUM_FORMS': 0,\n            'speakers-MAX_NUM_FORMS': 0,\n            'related_links-TOTAL_FORMS': 0,\n            'related_links-INITIAL_FORMS': 0,\n            'related_links-MIN_NUM_FORMS': 0,\n            'related_links-MAX_NUM_FORMS': 0,\n            'head_counts-TOTAL_FORMS': 0,\n            'head_counts-INITIAL_FORMS': 0,\n            'head_counts-MIN_NUM_FORMS': 0,\n            'head_counts-MAX_NUM_FORMS': 0,\n        }\n        response = self.client.post(\n            reverse('wagtailadmin_pages:edit', args=(self.christmas_page.id, )),\n            post_data\n        )\n        self.assertEqual(response.status_code, 200)\n\n        self.assertContains(response, \"The page could not be saved due to validation errors\")\n        self.assertContains(response, \"<li>The end date must be after the start date</li>\", count=1)\n\n        # Error on title shown against the title field\n        self.assertContains(response, \"\"\"<p class=\"error-message\"><span>This field is required.</span></p>\"\"\", count=1, html=True)\n        # Error on title shown in the header message\n        self.assertContains(response, \"<li>Title: This field is required.</li>\", count=1)\n\n\nclass TestNestedInlinePanel(TestCase, WagtailTestUtils):\n    fixtures = ['test.json']\n\n    def setUp(self):\n        self.events_index = Page.objects.get(url_path='/home/events/')\n        self.christmas_page = EventPage.objects.get(url_path='/home/events/christmas/')\n        self.speaker = self.christmas_page.speakers.first()\n        self.speaker.awards.create(\n            name=\"Beard Of The Year\", date_awarded=datetime.date(1997, 12, 25)\n        )\n        self.speaker.save()\n        self.user = self.login()\n\n    def test_get_edit_form(self):\n        response = self.client.get(\n            reverse('wagtailadmin_pages:edit', args=(self.christmas_page.id, ))\n        )\n        self.assertEqual(response.status_code, 200)\n        self.assertContains(\n            response,\n            \"\"\"<input type=\"text\" name=\"speakers-0-awards-0-name\" value=\"Beard Of The Year\" maxlength=\"255\" id=\"id_speakers-0-awards-0-name\">\"\"\",\n            count=1, html=True\n        )\n\n        # there should be no \"extra\" forms, as the nested formset should respect the extra_form_count=0 set on WagtailAdminModelForm\n        self.assertContains(\n            response,\n            \"\"\"<input type=\"hidden\" name=\"speakers-0-awards-TOTAL_FORMS\" value=\"1\" id=\"id_speakers-0-awards-TOTAL_FORMS\">\"\"\",\n            count=1, html=True\n        )\n        self.assertContains(\n            response,\n            \"\"\"<input type=\"text\" name=\"speakers-0-awards-1-name\" value=\"\" maxlength=\"255\" id=\"id_speakers-0-awards-1-name\">\"\"\",\n            count=0, html=True\n        )\n\n        # date field should use AdminDatePicker\n        self.assertContains(\n            response,\n            \"\"\"<input type=\"text\" name=\"speakers-0-awards-0-date_awarded\" value=\"1997-12-25\" autocomplete=\"off\" id=\"id_speakers-0-awards-0-date_awarded\">\"\"\",\n            count=1, html=True\n        )\n\n    def test_post_edit(self):\n        post_data = nested_form_data({\n            'title': \"Christmas\",\n            'date_from': \"2017-12-25\",\n            'date_to': \"2017-12-25\",\n            'slug': \"christmas\",\n            'audience': \"public\",\n            'location': \"The North Pole\",\n            'cost': \"Free\",\n            'carousel_items': inline_formset([]),\n            'speakers': inline_formset([\n                {\n                    'id': self.speaker.id,\n                    'first_name': \"Jeff\",\n                    'last_name': \"Christmas\",\n                    'awards': inline_formset([\n                        {\n                            'id': self.speaker.awards.first().id,\n                            'name': \"Beard Of The Century\",\n                            'date_awarded': \"1997-12-25\",\n                        },\n                        {\n                            'name': \"Bobsleigh Olympic gold medallist\",\n                            'date_awarded': \"2018-02-01\",\n                        },\n                    ], initial=1)\n                },\n            ], initial=1),\n            'related_links': inline_formset([]),\n            'head_counts': inline_formset([]),\n            'action-publish': \"Publish\",\n        })\n        response = self.client.post(\n            reverse('wagtailadmin_pages:edit', args=(self.christmas_page.id, )),\n            post_data\n        )\n        self.assertRedirects(response, reverse('wagtailadmin_explore', args=(self.events_index.id, )))\n\n        new_christmas_page = EventPage.objects.get(url_path='/home/events/christmas/')\n        self.assertEqual(new_christmas_page.speakers.first().first_name, \"Jeff\")\n        awards = new_christmas_page.speakers.first().awards.all()\n        self.assertEqual(len(awards), 2)\n        self.assertEqual(awards[0].name, \"Beard Of The Century\")\n        self.assertEqual(awards[1].name, \"Bobsleigh Olympic gold medallist\")\n\n\n@override_settings(WAGTAIL_I18N_ENABLED=True)\nclass TestLocaleSelector(TestCase, WagtailTestUtils):\n    fixtures = ['test.json']\n\n    def setUp(self):\n        self.christmas_page = EventPage.objects.get(url_path='/home/events/christmas/')\n        self.fr_locale = Locale.objects.create(language_code='fr')\n        self.translated_christmas_page = self.christmas_page.copy_for_translation(self.fr_locale, copy_parents=True)\n        self.user = self.login()\n\n    def test_locale_selector(self):\n        response = self.client.get(\n            reverse('wagtailadmin_pages:edit', args=[self.christmas_page.id])\n        )\n\n        self.assertContains(response, '<li class=\"header-meta--locale\">')\n\n        edit_translation_url = reverse('wagtailadmin_pages:edit', args=[self.translated_christmas_page.id])\n        self.assertContains(response, f'<a href=\"{edit_translation_url}\" aria-label=\"French\" class=\"u-link is-live\">')\n\n    @override_settings(WAGTAIL_I18N_ENABLED=False)\n    def test_locale_selector_not_present_when_i18n_disabled(self):\n        response = self.client.get(\n            reverse('wagtailadmin_pages:edit', args=[self.christmas_page.id])\n        )\n\n        self.assertNotContains(response, '<li class=\"header-meta--locale\">')\n\n        edit_translation_url = reverse('wagtailadmin_pages:edit', args=[self.translated_christmas_page.id])\n        self.assertNotContains(response, f'<a href=\"{edit_translation_url}\" aria-label=\"French\" class=\"u-link is-live\">')\n\n    def test_locale_dropdown_not_present_without_permission_to_edit(self):\n        # Remove user's permissions to edit French tree\n        en_events_index = Page.objects.get(url_path='/home/events/')\n        group = Group.objects.get(name='Moderators')\n        GroupPagePermission.objects.create(\n            group=group,\n            page=en_events_index,\n            permission_type='edit',\n        )\n        self.user.is_superuser = False\n        self.user.user_permissions.add(\n            Permission.objects.get(content_type__app_label='wagtailadmin', codename='access_admin')\n        )\n        self.user.groups.add(group)\n        self.user.save()\n\n        # Locale indicator should exist, but the \"French\" option should be hidden\n        response = self.client.get(\n            reverse('wagtailadmin_pages:edit', args=[self.christmas_page.id])\n        )\n\n        self.assertContains(response, '<li class=\"header-meta--locale\">')\n\n        edit_translation_url = reverse('wagtailadmin_pages:edit', args=[self.translated_christmas_page.id])\n        self.assertNotContains(response, f'<a href=\"{edit_translation_url}\" aria-label=\"French\" class=\"u-link is-live\">')\n\n\nclass TestPageSubscriptionSettings(TestCase, WagtailTestUtils):\n    def setUp(self):\n        # Find root page\n        self.root_page = Page.objects.get(id=2)\n\n        # Add child page\n        child_page = SimplePage(\n            title=\"Hello world!\",\n            slug=\"hello-world\",\n            content=\"hello\",\n        )\n        self.root_page.add_child(instance=child_page)\n        child_page.save_revision().publish()\n        self.child_page = SimplePage.objects.get(id=child_page.id)\n\n        # Login\n        self.user = self.login()\n\n    def test_commment_notifications_switched_off(self):\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))\n\n        self.assertEqual(response.status_code, 200)\n        self.assertContains(response, '<input type=\"checkbox\" name=\"comment_notifications\" id=\"id_comment_notifications\">')\n\n    def test_commment_notifications_switched_on(self):\n        PageSubscription.objects.create(\n            page=self.child_page,\n            user=self.user,\n            comment_notifications=True\n        )\n\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))\n\n        self.assertEqual(response.status_code, 200)\n        self.assertContains(response, '<input type=\"checkbox\" name=\"comment_notifications\" id=\"id_comment_notifications\" checked>')\n\n    def test_post_with_comment_notifications_switched_on(self):\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'comment_notifications': 'on'\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]), post_data)\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))\n\n        # Check the subscription\n        page = Page.objects.get(path__startswith=self.root_page.path, slug='hello-world').specific\n        subscription = page.subscribers.get()\n\n        self.assertEqual(subscription.user, self.user)\n        self.assertTrue(subscription.comment_notifications)\n\n    def test_post_with_comment_notifications_switched_off(self):\n        # Switch on comment notifications so we can test switching them off\n        subscription = PageSubscription.objects.create(\n            page=self.child_page,\n            user=self.user,\n            comment_notifications=True\n        )\n\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]), post_data)\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))\n\n        # Check the subscription\n        subscription.refresh_from_db()\n        self.assertFalse(subscription.comment_notifications)\n\n    @override_settings(WAGTAILADMIN_COMMENTS_ENABLED=False)\n    def test_comments_disabled(self):\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))\n\n        self.assertEqual(response.status_code, 200)\n        self.assertNotContains(response, '<input type=\"checkbox\" name=\"comment_notifications\" id=\"id_comment_notifications\">')\n\n    @override_settings(WAGTAILADMIN_COMMENTS_ENABLED=False)\n    def test_post_comments_disabled(self):\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'comment_notifications': 'on'  # Testing that this gets ignored\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]), post_data)\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))\n\n        # Check the subscription\n        self.assertFalse(PageSubscription.objects.get().comment_notifications)\n\n\nclass TestCommenting(TestCase, WagtailTestUtils):\n    \"\"\"\n    Tests both the comment notification and audit logging logic of the edit page view.\n    \"\"\"\n    def setUp(self):\n        # Find root page\n        self.root_page = Page.objects.get(id=2)\n\n        # Add child page\n        child_page = SimplePage(\n            title=\"Hello world!\",\n            slug=\"hello-world\",\n            content=\"hello\",\n        )\n        self.root_page.add_child(instance=child_page)\n        child_page.save_revision().publish()\n        self.child_page = SimplePage.objects.get(id=child_page.id)\n\n        # Login\n        self.user = self.login()\n\n        # Add a couple more users\n        self.subscriber = self.create_user('subscriber')\n        self.non_subscriber = self.create_user('non-subscriber')\n        self.non_subscriber_2 = self.create_user('non-subscriber-2')\n\n        PageSubscription.objects.create(\n            page=self.child_page,\n            user=self.user,\n            comment_notifications=True\n        )\n\n        PageSubscription.objects.create(\n            page=self.child_page,\n            user=self.subscriber,\n            comment_notifications=True\n        )\n\n    def test_new_comment(self):\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'comments-TOTAL_FORMS': '1',\n            'comments-INITIAL_FORMS': '0',\n            'comments-MIN_NUM_FORMS': '0',\n            'comments-MAX_NUM_FORMS': '',\n            'comments-0-DELETE': '',\n            'comments-0-resolved': '',\n            'comments-0-id': '',\n            'comments-0-contentpath': 'title',\n            'comments-0-text': 'A test comment',\n            'comments-0-position': '',\n            'comments-0-replies-TOTAL_FORMS': '0',\n            'comments-0-replies-INITIAL_FORMS': '0',\n            'comments-0-replies-MIN_NUM_FORMS': '0',\n            'comments-0-replies-MAX_NUM_FORMS': '0'\n        }\n\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]), post_data)\n\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))\n\n        # Check the comment was added\n        comment = self.child_page.wagtail_admin_comments.get()\n        self.assertEqual(comment.text, 'A test comment')\n\n        # Check notification email\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertEqual(mail.outbox[0].to, [self.subscriber.email])\n        self.assertEqual(mail.outbox[0].subject, 'test@email.com has updated comments on \"I\\'ve been edited! (simple page)\"')\n        self.assertIn('New comments:\\n - \"A test comment\"\\n\\n', mail.outbox[0].body)\n\n        # Check audit log\n        log_entry = PageLogEntry.objects.get(action='wagtail.comments.create')\n        self.assertEqual(log_entry.page, self.child_page.page_ptr)\n        self.assertEqual(log_entry.user, self.user)\n        self.assertEqual(log_entry.revision, self.child_page.get_latest_revision())\n        self.assertEqual(log_entry.data['comment']['id'], comment.id)\n        self.assertEqual(log_entry.data['comment']['contentpath'], comment.contentpath)\n        self.assertEqual(log_entry.data['comment']['text'], comment.text)\n\n    def test_edit_comment(self):\n        comment = Comment.objects.create(\n            page=self.child_page,\n            user=self.user,\n            text=\"A test comment\",\n            contentpath=\"title\",\n        )\n\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'comments-TOTAL_FORMS': '1',\n            'comments-INITIAL_FORMS': '1',\n            'comments-MIN_NUM_FORMS': '0',\n            'comments-MAX_NUM_FORMS': '',\n            'comments-0-DELETE': '',\n            'comments-0-resolved': '',\n            'comments-0-id': str(comment.id),\n            'comments-0-contentpath': 'title',\n            'comments-0-text': 'Edited',\n            'comments-0-position': '',\n            'comments-0-replies-TOTAL_FORMS': '0',\n            'comments-0-replies-INITIAL_FORMS': '0',\n            'comments-0-replies-MIN_NUM_FORMS': '0',\n            'comments-0-replies-MAX_NUM_FORMS': '0'\n        }\n\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]), post_data)\n\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))\n\n        # Check the comment was edited\n        comment.refresh_from_db()\n        self.assertEqual(comment.text, 'Edited')\n\n        # No emails should be sent for edited comments\n        self.assertEqual(len(mail.outbox), 0)\n\n        # Check audit log\n        log_entry = PageLogEntry.objects.get(action='wagtail.comments.edit')\n        self.assertEqual(log_entry.page, self.child_page.page_ptr)\n        self.assertEqual(log_entry.user, self.user)\n        self.assertEqual(log_entry.revision, self.child_page.get_latest_revision())\n        self.assertEqual(log_entry.data['comment']['id'], comment.id)\n        self.assertEqual(log_entry.data['comment']['contentpath'], comment.contentpath)\n        self.assertEqual(log_entry.data['comment']['text'], comment.text)\n\n    def test_edit_another_users_comment(self):\n        comment = Comment.objects.create(\n            page=self.child_page,\n            user=self.subscriber,\n            text=\"A test comment\",\n            contentpath=\"title\",\n        )\n\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'comments-TOTAL_FORMS': '1',\n            'comments-INITIAL_FORMS': '1',\n            'comments-MIN_NUM_FORMS': '0',\n            'comments-MAX_NUM_FORMS': '',\n            'comments-0-DELETE': '',\n            'comments-0-resolved': '',\n            'comments-0-id': str(comment.id),\n            'comments-0-contentpath': 'title',\n            'comments-0-text': 'Edited',\n            'comments-0-position': '',\n            'comments-0-replies-TOTAL_FORMS': '0',\n            'comments-0-replies-INITIAL_FORMS': '0',\n            'comments-0-replies-MIN_NUM_FORMS': '0',\n            'comments-0-replies-MAX_NUM_FORMS': '0'\n        }\n\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]), post_data)\n\n        self.assertEqual(response.context['form'].formsets['comments'].errors, [{'__all__': [\"You cannot edit another user's comment.\"]}])\n\n        # Check the comment was not edited\n        comment.refresh_from_db()\n        self.assertNotEqual(comment.text, 'Edited')\n\n        # Check no log entry was created\n        self.assertFalse(PageLogEntry.objects.filter(action='wagtail.comments.edit').exists())\n\n    def test_resolve_comment(self):\n        comment = Comment.objects.create(\n            page=self.child_page,\n            user=self.non_subscriber,\n            text=\"A test comment\",\n            contentpath=\"title\",\n        )\n\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'comments-TOTAL_FORMS': '1',\n            'comments-INITIAL_FORMS': '1',\n            'comments-MIN_NUM_FORMS': '0',\n            'comments-MAX_NUM_FORMS': '',\n            'comments-0-DELETE': '',\n            'comments-0-resolved': 'on',\n            'comments-0-id': str(comment.id),\n            'comments-0-contentpath': 'title',\n            'comments-0-text': 'A test comment',\n            'comments-0-position': '',\n            'comments-0-replies-TOTAL_FORMS': '0',\n            'comments-0-replies-INITIAL_FORMS': '0',\n            'comments-0-replies-MIN_NUM_FORMS': '0',\n            'comments-0-replies-MAX_NUM_FORMS': '0'\n        }\n\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]), post_data)\n\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))\n\n        # Check the comment was resolved\n        comment.refresh_from_db()\n        self.assertTrue(comment.resolved_at)\n        self.assertEqual(comment.resolved_by, self.user)\n\n        # Check notification email\n        self.assertEqual(len(mail.outbox), 2)\n        # The non subscriber created the comment, so should also get an email\n        self.assertEqual(mail.outbox[0].to, [self.non_subscriber.email])\n        self.assertEqual(mail.outbox[0].subject, 'test@email.com has updated comments on \"I\\'ve been edited! (simple page)\"')\n        self.assertIn('Resolved comments:\\n - \"A test comment\"\\n\\n', mail.outbox[0].body)\n        self.assertEqual(mail.outbox[1].to, [self.subscriber.email])\n        self.assertEqual(mail.outbox[1].subject, 'test@email.com has updated comments on \"I\\'ve been edited! (simple page)\"')\n        self.assertIn('Resolved comments:\\n - \"A test comment\"\\n\\n', mail.outbox[1].body)\n\n        # Check audit log\n        log_entry = PageLogEntry.objects.get(action='wagtail.comments.resolve')\n        self.assertEqual(log_entry.page, self.child_page.page_ptr)\n        self.assertEqual(log_entry.user, self.user)\n        self.assertEqual(log_entry.revision, self.child_page.get_latest_revision())\n        self.assertEqual(log_entry.data['comment']['id'], comment.id)\n        self.assertEqual(log_entry.data['comment']['contentpath'], comment.contentpath)\n        self.assertEqual(log_entry.data['comment']['text'], comment.text)\n\n    def test_delete_comment(self):\n        comment = Comment.objects.create(\n            page=self.child_page,\n            user=self.user,\n            text=\"A test comment\",\n            contentpath=\"title\",\n        )\n\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'comments-TOTAL_FORMS': '1',\n            'comments-INITIAL_FORMS': '1',\n            'comments-MIN_NUM_FORMS': '0',\n            'comments-MAX_NUM_FORMS': '',\n            'comments-0-DELETE': 'on',\n            'comments-0-resolved': '',\n            'comments-0-id': str(comment.id),\n            'comments-0-contentpath': 'title',\n            'comments-0-text': 'A test comment',\n            'comments-0-position': '',\n            'comments-0-replies-TOTAL_FORMS': '0',\n            'comments-0-replies-INITIAL_FORMS': '0',\n            'comments-0-replies-MIN_NUM_FORMS': '0',\n            'comments-0-replies-MAX_NUM_FORMS': '0'\n        }\n\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]), post_data)\n\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))\n\n        # Check the comment was deleted\n        self.assertFalse(self.child_page.wagtail_admin_comments.exists())\n\n        # Check notification email\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertEqual(mail.outbox[0].to, [self.subscriber.email])\n        self.assertEqual(mail.outbox[0].subject, 'test@email.com has updated comments on \"I\\'ve been edited! (simple page)\"')\n        self.assertIn('Deleted comments:\\n - \"A test comment\"\\n\\n', mail.outbox[0].body)\n\n        # Check audit log\n        log_entry = PageLogEntry.objects.get(action='wagtail.comments.delete')\n        self.assertEqual(log_entry.page, self.child_page.page_ptr)\n        self.assertEqual(log_entry.user, self.user)\n        self.assertEqual(log_entry.revision, self.child_page.get_latest_revision())\n        self.assertEqual(log_entry.data['comment']['id'], comment.id)\n        self.assertEqual(log_entry.data['comment']['contentpath'], comment.contentpath)\n        self.assertEqual(log_entry.data['comment']['text'], comment.text)\n\n    def test_new_reply(self):\n        comment = Comment.objects.create(\n            page=self.child_page,\n            user=self.non_subscriber,\n            text=\"A test comment\",\n            contentpath=\"title\",\n        )\n\n        reply = CommentReply.objects.create(\n            comment=comment,\n            user=self.non_subscriber_2,\n            text='an old reply'\n        )\n\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'comments-TOTAL_FORMS': '1',\n            'comments-INITIAL_FORMS': '1',\n            'comments-MIN_NUM_FORMS': '0',\n            'comments-MAX_NUM_FORMS': '',\n            'comments-0-DELETE': '',\n            'comments-0-resolved': '',\n            'comments-0-id': str(comment.id),\n            'comments-0-contentpath': 'title',\n            'comments-0-text': 'A test comment',\n            'comments-0-position': '',\n            'comments-0-replies-TOTAL_FORMS': '2',\n            'comments-0-replies-INITIAL_FORMS': '1',\n            'comments-0-replies-MIN_NUM_FORMS': '0',\n            'comments-0-replies-MAX_NUM_FORMS': '',\n            'comments-0-replies-0-id': str(reply.id),\n            'comments-0-replies-0-text': 'an old reply',\n            'comments-0-replies-1-id': '',\n            'comments-0-replies-1-text': 'a new reply'\n        }\n\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]), post_data)\n\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))\n\n        # Check the comment reply was added\n        comment.refresh_from_db()\n        self.assertEqual(comment.replies.last().text, 'a new reply')\n\n        # Check notification email\n        self.assertEqual(len(mail.outbox), 3)\n\n        recipients = [mail.to for mail in mail.outbox]\n        # The other non subscriber replied in the thread, so should get an email\n        self.assertIn([self.non_subscriber_2.email], recipients)\n\n        # The non subscriber created the comment, so should get an email\n        self.assertIn([self.non_subscriber.email], recipients)\n\n        self.assertIn([self.subscriber.email], recipients)\n        self.assertEqual(mail.outbox[2].subject, 'test@email.com has updated comments on \"I\\'ve been edited! (simple page)\"')\n        self.assertIn('  New replies to: \"A test comment\"\\n   - \"a new reply\"', mail.outbox[2].body)\n\n        # Check audit log\n        log_entry = PageLogEntry.objects.get(action='wagtail.comments.create_reply')\n        self.assertEqual(log_entry.page, self.child_page.page_ptr)\n        self.assertEqual(log_entry.user, self.user)\n        self.assertEqual(log_entry.revision, self.child_page.get_latest_revision())\n        self.assertEqual(log_entry.data['comment']['id'], comment.id)\n        self.assertEqual(log_entry.data['comment']['contentpath'], comment.contentpath)\n        self.assertEqual(log_entry.data['comment']['text'], comment.text)\n        self.assertNotEqual(log_entry.data['reply']['id'], reply.id)\n        self.assertEqual(log_entry.data['reply']['text'], 'a new reply')\n\n    def test_edit_reply(self):\n        comment = Comment.objects.create(\n            page=self.child_page,\n            user=self.non_subscriber,\n            text=\"A test comment\",\n            contentpath=\"title\",\n        )\n\n        reply = CommentReply.objects.create(\n            comment=comment,\n            user=self.user,\n            text='an old reply'\n        )\n\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'comments-TOTAL_FORMS': '1',\n            'comments-INITIAL_FORMS': '1',\n            'comments-MIN_NUM_FORMS': '0',\n            'comments-MAX_NUM_FORMS': '',\n            'comments-0-DELETE': '',\n            'comments-0-resolved': '',\n            'comments-0-id': str(comment.id),\n            'comments-0-contentpath': 'title',\n            'comments-0-text': 'A test comment',\n            'comments-0-position': '',\n            'comments-0-replies-TOTAL_FORMS': '1',\n            'comments-0-replies-INITIAL_FORMS': '1',\n            'comments-0-replies-MIN_NUM_FORMS': '0',\n            'comments-0-replies-MAX_NUM_FORMS': '',\n            'comments-0-replies-0-id': str(reply.id),\n            'comments-0-replies-0-text': 'an edited reply',\n        }\n\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]), post_data)\n\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))\n\n        # Check the comment reply was edited\n        reply.refresh_from_db()\n        self.assertEqual(reply.text, 'an edited reply')\n\n        # Check no notification was sent\n        self.assertEqual(len(mail.outbox), 0)\n\n        # Check audit log\n        log_entry = PageLogEntry.objects.get(action='wagtail.comments.edit_reply')\n        self.assertEqual(log_entry.page, self.child_page.page_ptr)\n        self.assertEqual(log_entry.user, self.user)\n        self.assertEqual(log_entry.revision, self.child_page.get_latest_revision())\n        self.assertEqual(log_entry.data['comment']['id'], comment.id)\n        self.assertEqual(log_entry.data['comment']['contentpath'], comment.contentpath)\n        self.assertEqual(log_entry.data['comment']['text'], comment.text)\n        self.assertEqual(log_entry.data['reply']['id'], reply.id)\n        self.assertEqual(log_entry.data['reply']['text'], 'an edited reply')\n\n    def test_delete_reply(self):\n        comment = Comment.objects.create(\n            page=self.child_page,\n            user=self.non_subscriber,\n            text=\"A test comment\",\n            contentpath=\"title\",\n        )\n\n        reply = CommentReply.objects.create(\n            comment=comment,\n            user=self.user,\n            text='an old reply'\n        )\n\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'comments-TOTAL_FORMS': '1',\n            'comments-INITIAL_FORMS': '1',\n            'comments-MIN_NUM_FORMS': '0',\n            'comments-MAX_NUM_FORMS': '',\n            'comments-0-DELETE': '',\n            'comments-0-resolved': '',\n            'comments-0-id': str(comment.id),\n            'comments-0-contentpath': 'title',\n            'comments-0-text': 'A test comment',\n            'comments-0-position': '',\n            'comments-0-replies-TOTAL_FORMS': '1',\n            'comments-0-replies-INITIAL_FORMS': '1',\n            'comments-0-replies-MIN_NUM_FORMS': '0',\n            'comments-0-replies-MAX_NUM_FORMS': '',\n            'comments-0-replies-0-id': str(reply.id),\n            'comments-0-replies-0-text': 'an old reply',\n            'comments-0-replies-0-DELETE': 'on',\n        }\n\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]), post_data)\n\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))\n\n        # Check the comment reply was deleted\n        self.assertFalse(comment.replies.exists())\n\n        # Check no notification was sent\n        self.assertEqual(len(mail.outbox), 0)\n\n        # Check audit log\n        log_entry = PageLogEntry.objects.get(action='wagtail.comments.delete_reply')\n        self.assertEqual(log_entry.page, self.child_page.page_ptr)\n        self.assertEqual(log_entry.user, self.user)\n        self.assertEqual(log_entry.revision, self.child_page.get_latest_revision())\n        self.assertEqual(log_entry.data['comment']['id'], comment.id)\n        self.assertEqual(log_entry.data['comment']['contentpath'], comment.contentpath)\n        self.assertEqual(log_entry.data['comment']['text'], comment.text)\n        self.assertEqual(log_entry.data['reply']['id'], reply.id)\n        self.assertEqual(log_entry.data['reply']['text'], reply.text)\n\n    def test_updated_comments_notifications_profile_setting(self):\n        # Users can disable commenting notifications globally from account settings\n        profile = UserProfile.get_for_user(self.subscriber)\n        profile.updated_comments_notifications = False\n        profile.save()\n\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'comments-TOTAL_FORMS': '1',\n            'comments-INITIAL_FORMS': '0',\n            'comments-MIN_NUM_FORMS': '0',\n            'comments-MAX_NUM_FORMS': '',\n            'comments-0-DELETE': '',\n            'comments-0-resolved': '',\n            'comments-0-id': '',\n            'comments-0-contentpath': 'title',\n            'comments-0-text': 'A test comment',\n            'comments-0-position': '',\n            'comments-0-replies-TOTAL_FORMS': '0',\n            'comments-0-replies-INITIAL_FORMS': '0',\n            'comments-0-replies-MIN_NUM_FORMS': '0',\n            'comments-0-replies-MAX_NUM_FORMS': '0'\n        }\n\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]), post_data)\n\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))\n\n        # Check the comment was added\n        comment = self.child_page.wagtail_admin_comments.get()\n        self.assertEqual(comment.text, 'A test comment')\n\n        # This time, no emails should be submitted because the only subscriber has disabled these emails globally\n        self.assertEqual(len(mail.outbox), 0)\n\n    def test_updated_comments_notifications_active_users_only(self):\n        # subscriber is inactive\n        self.subscriber.is_active = False\n        self.subscriber.save()\n\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'comments-TOTAL_FORMS': '1',\n            'comments-INITIAL_FORMS': '0',\n            'comments-MIN_NUM_FORMS': '0',\n            'comments-MAX_NUM_FORMS': '',\n            'comments-0-DELETE': '',\n            'comments-0-resolved': '',\n            'comments-0-id': '',\n            'comments-0-contentpath': 'title',\n            'comments-0-text': 'A test comment',\n            'comments-0-position': '',\n            'comments-0-replies-TOTAL_FORMS': '0',\n            'comments-0-replies-INITIAL_FORMS': '0',\n            'comments-0-replies-MIN_NUM_FORMS': '0',\n            'comments-0-replies-MAX_NUM_FORMS': '0'\n        }\n\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]), post_data)\n\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))\n\n        # Check the comment was added\n        comment = self.child_page.wagtail_admin_comments.get()\n        self.assertEqual(comment.text, 'A test comment')\n\n        # No emails should be submitted because subscriber is inactive\n        self.assertEqual(len(mail.outbox), 0)\n", "import json\n\nfrom urllib.parse import quote\n\nfrom django.conf import settings\nfrom django.contrib.auth import get_user_model\nfrom django.core.exceptions import PermissionDenied\nfrom django.db.models import Prefetch, Q\nfrom django.http import HttpResponse\nfrom django.shortcuts import get_object_or_404, redirect\nfrom django.urls import reverse\nfrom django.utils import timezone\nfrom django.utils.html import format_html\nfrom django.utils.safestring import mark_safe\nfrom django.utils.translation import gettext as _\nfrom django.views.generic.base import ContextMixin, TemplateResponseMixin, View\n\nfrom wagtail.admin import messages\nfrom wagtail.admin.action_menu import PageActionMenu\nfrom wagtail.admin.mail import send_notification\nfrom wagtail.admin.views.generic import HookResponseMixin\nfrom wagtail.admin.views.pages.utils import get_valid_next_url_from_request\nfrom wagtail.core.actions.publish_page_revision import PublishPageRevisionAction\nfrom wagtail.core.exceptions import PageClassNotFoundError\nfrom wagtail.core.models import (\n    COMMENTS_RELATION_NAME, Comment, CommentReply, Page, PageSubscription, UserPagePermissionsProxy,\n    WorkflowState)\n\n\nclass EditView(TemplateResponseMixin, ContextMixin, HookResponseMixin, View):\n    def get_template_names(self):\n        if self.page.alias_of_id:\n            return ['wagtailadmin/pages/edit_alias.html']\n\n        else:\n            return ['wagtailadmin/pages/edit.html']\n\n    def add_legacy_moderation_warning(self):\n        # Check for revisions still undergoing moderation and warn - this is for the old moderation system\n        if self.latest_revision and self.latest_revision.submitted_for_moderation:\n            buttons = []\n\n            if self.page.live:\n                buttons.append(self.get_compare_with_live_message_button())\n\n            messages.warning(self.request, _(\"This page is currently awaiting moderation\"), buttons=buttons)\n\n    def add_save_confirmation_message(self):\n        if self.is_reverting:\n            message = _(\n                \"Page '{0}' has been replaced with version from {1}.\"\n            ).format(\n                self.page.get_admin_display_title(),\n                self.previous_revision.created_at.strftime(\"%d %b %Y %H:%M\")\n            )\n        else:\n            message = _(\n                \"Page '{0}' has been updated.\"\n            ).format(\n                self.page.get_admin_display_title()\n            )\n\n        messages.success(self.request, message)\n\n    def get_commenting_changes(self):\n        \"\"\"\n        Finds comments that have been changed during this request.\n\n        Returns a tuple of 5 lists:\n         - New comments\n         - Deleted comments\n         - Resolved comments\n         - Edited comments\n         - Replied comments (dict containing the instance and list of replies)\n        \"\"\"\n        # Get changes\n        comments_formset = self.form.formsets['comments']\n        new_comments = comments_formset.new_objects\n        deleted_comments = comments_formset.deleted_objects\n\n        # Assume any changed comments that are resolved were only just resolved\n        resolved_comments = []\n        edited_comments = []\n        for changed_comment, changed_fields in comments_formset.changed_objects:\n            if changed_comment.resolved_at and 'resolved' in changed_fields:\n                resolved_comments.append(changed_comment)\n\n            if 'text' in changed_fields:\n                edited_comments.append(changed_comment)\n\n        new_replies = []\n        deleted_replies = []\n        edited_replies = []\n        for comment_form in comments_formset.forms:\n            # New\n            replies = getattr(comment_form.formsets['replies'], 'new_objects', [])\n            if replies:\n                new_replies.append((comment_form.instance, replies))\n\n            # Deleted\n            replies = getattr(comment_form.formsets['replies'], 'deleted_objects', [])\n            if replies:\n                deleted_replies.append((comment_form.instance, replies))\n\n            # Edited\n            replies = getattr(comment_form.formsets['replies'], 'changed_objects', [])\n            replies = [reply for reply, changed_fields in replies if 'text' in changed_fields]\n            if replies:\n                edited_replies.append((comment_form.instance, replies))\n\n        return {\n            'new_comments': new_comments,\n            'deleted_comments': deleted_comments,\n            'resolved_comments': resolved_comments,\n            'edited_comments': edited_comments,\n            'new_replies': new_replies,\n            'deleted_replies': deleted_replies,\n            'edited_replies': edited_replies,\n        }\n\n    def send_commenting_notifications(self, changes):\n        \"\"\"\n        Sends notifications about any changes to comments to anyone who is subscribed.\n        \"\"\"\n        relevant_comment_ids = []\n        relevant_comment_ids.extend(comment.pk for comment in changes['resolved_comments'])\n        relevant_comment_ids.extend(comment.pk for comment, replies in changes['new_replies'])\n\n        # Skip if no changes were made\n        # Note: We don't email about edited comments so ignore those here\n        if (not changes['new_comments']\n                and not changes['deleted_comments']\n                and not changes['resolved_comments']\n                and not changes['new_replies']):\n            return\n\n        # Get global page comment subscribers\n        subscribers = PageSubscription.objects.filter(page=self.page, comment_notifications=True).select_related('user')\n        global_recipient_users = [subscriber.user for subscriber in subscribers if subscriber.user != self.request.user]\n\n        # Get subscribers to individual threads\n        replies = CommentReply.objects.filter(comment_id__in=relevant_comment_ids)\n        comments = Comment.objects.filter(id__in=relevant_comment_ids)\n        thread_users = get_user_model().objects.exclude(pk=self.request.user.pk).exclude(pk__in=subscribers.values_list('user_id', flat=True)).prefetch_related(\n            Prefetch('comment_replies', queryset=replies),\n            Prefetch(COMMENTS_RELATION_NAME, queryset=comments)\n        ).exclude(\n            Q(comment_replies__isnull=True) & Q(**{('%s__isnull' % COMMENTS_RELATION_NAME): True})\n        )\n\n        # Skip if no recipients\n        if not (global_recipient_users or thread_users):\n            return\n        thread_users = [(user, set(list(user.comment_replies.values_list('comment_id', flat=True)) + list(getattr(user, COMMENTS_RELATION_NAME).values_list('pk', flat=True)))) for user in thread_users]\n        mailed_users = set()\n\n        for current_user, current_threads in thread_users:\n            # We are trying to avoid calling send_notification for each user for performance reasons\n            # so group the users receiving the same thread notifications together here\n            if current_user in mailed_users:\n                continue\n            users = [current_user]\n            mailed_users.add(current_user)\n            for user, threads in thread_users:\n                if user not in mailed_users and threads == current_threads:\n                    users.append(user)\n                    mailed_users.add(user)\n            send_notification(users, 'updated_comments', {\n                'page': self.page,\n                'editor': self.request.user,\n                'new_comments': [comment for comment in changes['new_comments'] if comment.pk in threads],\n                'resolved_comments': [comment for comment in changes['resolved_comments'] if comment.pk in threads],\n                'deleted_comments': [],\n                'replied_comments': [\n                    {\n                        'comment': comment,\n                        'replies': replies,\n                    }\n                    for comment, replies in changes['new_replies']\n                    if comment.pk in threads\n                ]\n            })\n\n        return send_notification(global_recipient_users, 'updated_comments', {\n            'page': self.page,\n            'editor': self.request.user,\n            'new_comments': changes['new_comments'],\n            'resolved_comments': changes['resolved_comments'],\n            'deleted_comments': changes['deleted_comments'],\n            'replied_comments': [\n                {\n                    'comment': comment,\n                    'replies': replies,\n                }\n                for comment, replies in changes['new_replies']\n            ]\n        })\n\n    def log_commenting_changes(self, changes, revision):\n        \"\"\"\n        Generates log entries for any changes made to comments or replies.\n        \"\"\"\n        for comment in changes['new_comments']:\n            comment.log_create(\n                page_revision=revision,\n                user=self.request.user\n            )\n\n        for comment in changes['edited_comments']:\n            comment.log_edit(\n                page_revision=revision,\n                user=self.request.user\n            )\n\n        for comment in changes['resolved_comments']:\n            comment.log_resolve(\n                page_revision=revision,\n                user=self.request.user\n            )\n\n        for comment in changes['deleted_comments']:\n            comment.log_delete(\n                page_revision=revision,\n                user=self.request.user\n            )\n\n        for comment, replies in changes['new_replies']:\n            for reply in replies:\n                reply.log_create(\n                    page_revision=revision,\n                    user=self.request.user\n                )\n\n        for comment, replies in changes['edited_replies']:\n            for reply in replies:\n                reply.log_edit(\n                    page_revision=revision,\n                    user=self.request.user\n                )\n\n        for comment, replies in changes['deleted_replies']:\n            for reply in replies:\n                reply.log_delete(\n                    page_revision=revision,\n                    user=self.request.user\n                )\n\n    def get_edit_message_button(self):\n        return messages.button(\n            reverse('wagtailadmin_pages:edit', args=(self.page.id,)),\n            _('Edit')\n        )\n\n    def get_view_draft_message_button(self):\n        return messages.button(\n            reverse('wagtailadmin_pages:view_draft', args=(self.page.id,)),\n            _('View draft'),\n            new_window=False\n        )\n\n    def get_view_live_message_button(self):\n        return messages.button(self.page.url, _('View live'), new_window=False)\n\n    def get_compare_with_live_message_button(self):\n        return messages.button(\n            reverse('wagtailadmin_pages:revisions_compare', args=(self.page.id, 'live', self.latest_revision.id)),\n            _('Compare with live version')\n        )\n\n    def get_page_for_status(self):\n        if self.page.live and self.page.has_unpublished_changes:\n            # Page status needs to present the version of the page containing the correct live URL\n            return self.real_page_record.specific\n        else:\n            return self.page\n\n    def dispatch(self, request, page_id):\n        self.real_page_record = get_object_or_404(Page, id=page_id)\n        self.latest_revision = self.real_page_record.get_latest_revision()\n        self.page_content_type = self.real_page_record.cached_content_type\n        self.page_class = self.real_page_record.specific_class\n\n        if self.page_class is None:\n            raise PageClassNotFoundError(\n                f\"The page '{self.real_page_record}' cannot be edited because the \"\n                f\"model class used to create it ({self.page_content_type.app_label}.\"\n                f\"{self.page_content_type.model}) can no longer be found in the codebase. \"\n                \"This usually happens as a result of switching between git \"\n                \"branches without running migrations to trigger the removal of \"\n                \"unused ContentTypes. To edit the page, you will need to switch \"\n                \"back to a branch where the model class is still present.\"\n            )\n\n        self.page = self.real_page_record.get_latest_revision_as_page()\n        self.parent = self.page.get_parent()\n\n        self.page_perms = self.page.permissions_for_user(self.request.user)\n\n        if not self.page_perms.can_edit():\n            raise PermissionDenied\n\n        self.next_url = get_valid_next_url_from_request(self.request)\n\n        response = self.run_hook('before_edit_page', self.request, self.page)\n        if response:\n            return response\n\n        try:\n            self.subscription = PageSubscription.objects.get(page=self.page, user=self.request.user)\n        except PageSubscription.DoesNotExist:\n            self.subscription = PageSubscription(page=self.page, user=self.request.user, comment_notifications=False)\n\n        self.edit_handler = self.page_class.get_edit_handler()\n        self.edit_handler = self.edit_handler.bind_to(instance=self.page, request=self.request)\n        self.form_class = self.edit_handler.get_form_class()\n\n        if getattr(settings, 'WAGTAIL_WORKFLOW_ENABLED', True):\n            # Retrieve current workflow state if set, default to last workflow state\n            self.workflow_state = self.page.current_workflow_state or self.page.workflow_states.order_by('created_at').last()\n        else:\n            self.workflow_state = None\n\n        if self.workflow_state:\n            self.workflow_tasks = self.workflow_state.all_tasks_with_status()\n        else:\n            self.workflow_tasks = []\n\n        self.errors_debug = None\n\n        return super().dispatch(request)\n\n    def get(self, request):\n        if self.page_perms.user_has_lock():\n            if self.page.locked_at:\n                lock_message = format_html(_(\"<b>Page '{}' was locked</b> by <b>you</b> on <b>{}</b>.\"), self.page.get_admin_display_title(), self.page.locked_at.strftime(\"%d %b %Y %H:%M\"))\n            else:\n                lock_message = format_html(_(\"<b>Page '{}' is locked</b> by <b>you</b>.\"), self.page.get_admin_display_title())\n\n            lock_message += format_html(\n                '<span class=\"buttons\"><button class=\"button button-small button-secondary\" data-locking-action=\"{}\">{}</button></span>',\n                reverse('wagtailadmin_pages:unlock', args=(self.page.id,)),\n                _(\"Unlock\")\n            )\n            messages.warning(self.request, lock_message, extra_tags='lock')\n\n        elif self.page.locked and self.page_perms.page_locked():\n            # the page can also be locked at a permissions level if in a workflow, on a task the user is not a reviewer for\n            # this should be indicated separately\n            if self.page.locked_by and self.page.locked_at:\n                lock_message = format_html(_(\"<b>Page '{}' was locked</b> by <b>{}</b> on <b>{}</b>.\"), self.page.get_admin_display_title(), str(self.page.locked_by), self.page.locked_at.strftime(\"%d %b %Y %H:%M\"))\n            else:\n                # Page was probably locked with an old version of Wagtail, or a script\n                lock_message = format_html(_(\"<b>Page '{}' is locked</b>.\"), self.page.get_admin_display_title())\n\n            if self.page_perms.can_unlock():\n                lock_message += format_html(\n                    '<span class=\"buttons\"><button class=\"button button-small button-secondary\" data-locking-action=\"{}\">{}</button></span>',\n                    reverse('wagtailadmin_pages:unlock', args=(self.page.id,)),\n                    _(\"Unlock\")\n                )\n            messages.error(self.request, lock_message, extra_tags='lock')\n\n        if self.page.current_workflow_state:\n            workflow = self.workflow_state.workflow\n            task = self.workflow_state.current_task_state.task\n            if (\n                self.workflow_state.status != WorkflowState.STATUS_NEEDS_CHANGES\n                and task.specific.page_locked_for_user(self.page, self.request.user)\n            ):\n                # Check for revisions still undergoing moderation and warn\n                if len(self.workflow_tasks) == 1:\n                    # If only one task in workflow, show simple message\n                    workflow_info = _(\"This page is currently awaiting moderation.\")\n                else:\n                    workflow_info = format_html(\n                        _(\"This page is awaiting <b>'{}'</b> in the <b>'{}'</b> workflow.\"),\n                        task.name, workflow.name\n                    )\n                messages.error(\n                    self.request, mark_safe(workflow_info + \" \" + _(\"Only reviewers for this task can edit the page.\")),\n                    extra_tags=\"lock\"\n                )\n\n        self.form = self.form_class(instance=self.page, subscription=self.subscription, parent_page=self.parent)\n        self.has_unsaved_changes = False\n        self.edit_handler = self.edit_handler.bind_to(form=self.form)\n        self.add_legacy_moderation_warning()\n        self.page_for_status = self.get_page_for_status()\n\n        return self.render_to_response(self.get_context_data())\n\n    def add_cancel_workflow_confirmation_message(self):\n        message = _(\n            \"Workflow on page '{0}' has been cancelled.\"\n        ).format(\n            self.page.get_admin_display_title()\n        )\n\n        messages.success(self.request, message, buttons=[\n            self.get_view_draft_message_button(),\n            self.get_edit_message_button(),\n        ])\n\n    def post(self, request):\n        # Don't allow POST requests if the page is an alias\n        if self.page.alias_of_id:\n            # Return 405 \"Method Not Allowed\" response\n            return HttpResponse(status=405)\n\n        self.form = self.form_class(\n            self.request.POST, self.request.FILES, instance=self.page, subscription=self.subscription, parent_page=self.parent\n        )\n\n        self.is_cancelling_workflow = bool(self.request.POST.get('action-cancel-workflow')) and self.workflow_state and self.workflow_state.user_can_cancel(self.request.user)\n\n        if self.form.is_valid() and not self.page_perms.page_locked():\n            return self.form_valid(self.form)\n        else:\n            return self.form_invalid(self.form)\n\n    def workflow_action_is_valid(self):\n        self.workflow_action = self.request.POST['workflow-action-name']\n        available_actions = self.page.current_workflow_task.get_actions(self.page, self.request.user)\n        available_action_names = [name for name, verbose_name, modal in available_actions]\n        return (self.workflow_action in available_action_names)\n\n    def form_valid(self, form):\n        self.is_reverting = bool(self.request.POST.get('revision'))\n        # If a revision ID was passed in the form, get that revision so its\n        # date can be referenced in notification messages\n        if self.is_reverting:\n            self.previous_revision = get_object_or_404(self.page.revisions, id=self.request.POST.get('revision'))\n\n        self.has_content_changes = self.form.has_changed()\n\n        if self.request.POST.get('action-publish') and self.page_perms.can_publish():\n            return self.publish_action()\n        elif self.request.POST.get('action-submit') and self.page_perms.can_submit_for_moderation():\n            return self.submit_action()\n        elif self.request.POST.get('action-restart-workflow') and self.page_perms.can_submit_for_moderation() and self.workflow_state and self.workflow_state.user_can_cancel(self.request.user):\n            return self.restart_workflow_action()\n        elif self.request.POST.get('action-workflow-action') and self.workflow_action_is_valid():\n            return self.perform_workflow_action()\n        elif self.is_cancelling_workflow:\n            return self.cancel_workflow_action()\n        else:\n            return self.save_action()\n\n    def save_action(self):\n        self.page = self.form.save(commit=False)\n        self.subscription.save()\n\n        # Save revision\n        revision = self.page.save_revision(\n            user=self.request.user,\n            log_action=True,  # Always log the new revision on edit\n            previous_revision=(self.previous_revision if self.is_reverting else None)\n        )\n\n        self.add_save_confirmation_message()\n\n        if self.has_content_changes and 'comments' in self.form.formsets:\n            changes = self.get_commenting_changes()\n            self.log_commenting_changes(changes, revision)\n            self.send_commenting_notifications(changes)\n\n        response = self.run_hook('after_edit_page', self.request, self.page)\n        if response:\n            return response\n\n        # Just saving - remain on edit page for further edits\n        return self.redirect_and_remain()\n\n    def publish_action(self):\n        self.page = self.form.save(commit=False)\n        self.subscription.save()\n\n        # Save revision\n        revision = self.page.save_revision(\n            user=self.request.user,\n            log_action=True,  # Always log the new revision on edit\n            previous_revision=(self.previous_revision if self.is_reverting else None)\n        )\n\n        # store submitted go_live_at for messaging below\n        go_live_at = self.page.go_live_at\n\n        response = self.run_hook('before_publish_page', self.request, self.page)\n        if response:\n            return response\n\n        action = PublishPageRevisionAction(\n            revision,\n            user=self.request.user,\n            changed=self.has_content_changes,\n            previous_revision=(self.previous_revision if self.is_reverting else None)\n        )\n        action.execute(skip_permission_checks=True)\n\n        if self.has_content_changes and 'comments' in self.form.formsets:\n            changes = self.get_commenting_changes()\n            self.log_commenting_changes(changes, revision)\n            self.send_commenting_notifications(changes)\n\n        # Need to reload the page because the URL may have changed, and we\n        # need the up-to-date URL for the \"View Live\" button.\n        self.page = self.page.specific_class.objects.get(pk=self.page.pk)\n\n        response = self.run_hook('after_publish_page', self.request, self.page)\n        if response:\n            return response\n\n        # Notifications\n        if go_live_at and go_live_at > timezone.now():\n            # Page has been scheduled for publishing in the future\n\n            if self.is_reverting:\n                message = _(\n                    \"Version from {0} of page '{1}' has been scheduled for publishing.\"\n                ).format(\n                    self.previous_revision.created_at.strftime(\"%d %b %Y %H:%M\"),\n                    self.page.get_admin_display_title()\n                )\n            else:\n                if self.page.live:\n                    message = _(\n                        \"Page '{0}' is live and this version has been scheduled for publishing.\"\n                    ).format(\n                        self.page.get_admin_display_title()\n                    )\n\n                else:\n                    message = _(\n                        \"Page '{0}' has been scheduled for publishing.\"\n                    ).format(\n                        self.page.get_admin_display_title()\n                    )\n\n            messages.success(self.request, message, buttons=[self.get_edit_message_button()])\n\n        else:\n            # Page is being published now\n\n            if self.is_reverting:\n                message = _(\n                    \"Version from {0} of page '{1}' has been published.\"\n                ).format(\n                    self.previous_revision.created_at.strftime(\"%d %b %Y %H:%M\"),\n                    self.page.get_admin_display_title()\n                )\n            else:\n                message = _(\n                    \"Page '{0}' has been published.\"\n                ).format(\n                    self.page.get_admin_display_title()\n                )\n\n            buttons = []\n            if self.page.url is not None:\n                buttons.append(self.get_view_live_message_button())\n            buttons.append(self.get_edit_message_button())\n            messages.success(self.request, message, buttons=buttons)\n\n        response = self.run_hook('after_edit_page', self.request, self.page)\n        if response:\n            return response\n\n        # we're done here - redirect back to the explorer\n        return self.redirect_away()\n\n    def submit_action(self):\n        self.page = self.form.save(commit=False)\n        self.subscription.save()\n\n        # Save revision\n        revision = self.page.save_revision(\n            user=self.request.user,\n            log_action=True,  # Always log the new revision on edit\n            previous_revision=(self.previous_revision if self.is_reverting else None)\n        )\n\n        if self.has_content_changes and 'comments' in self.form.formsets:\n            changes = self.get_commenting_changes()\n            self.log_commenting_changes(changes, revision)\n            self.send_commenting_notifications(changes)\n\n        if self.workflow_state and self.workflow_state.status == WorkflowState.STATUS_NEEDS_CHANGES:\n            # If the workflow was in the needs changes state, resume the existing workflow on submission\n            self.workflow_state.resume(self.request.user)\n        else:\n            # Otherwise start a new workflow\n            workflow = self.page.get_workflow()\n            workflow.start(self.page, self.request.user)\n\n        message = _(\n            \"Page '{0}' has been submitted for moderation.\"\n        ).format(\n            self.page.get_admin_display_title()\n        )\n\n        messages.success(self.request, message, buttons=[\n            self.get_view_draft_message_button(),\n            self.get_edit_message_button(),\n        ])\n\n        response = self.run_hook('after_edit_page', self.request, self.page)\n        if response:\n            return response\n\n        # we're done here - redirect back to the explorer\n        return self.redirect_away()\n\n    def restart_workflow_action(self):\n        self.page = self.form.save(commit=False)\n        self.subscription.save()\n\n        # save revision\n        revision = self.page.save_revision(\n            user=self.request.user,\n            log_action=True,  # Always log the new revision on edit\n            previous_revision=(self.previous_revision if self.is_reverting else None)\n        )\n\n        if self.has_content_changes and 'comments' in self.form.formsets:\n            changes = self.get_commenting_changes()\n            self.log_commenting_changes(changes, revision)\n            self.send_commenting_notifications(changes)\n\n        # cancel workflow\n        self.workflow_state.cancel(user=self.request.user)\n        # start new workflow\n        workflow = self.page.get_workflow()\n        workflow.start(self.page, self.request.user)\n\n        message = _(\n            \"Workflow on page '{0}' has been restarted.\"\n        ).format(\n            self.page.get_admin_display_title()\n        )\n\n        messages.success(self.request, message, buttons=[\n            self.get_view_draft_message_button(),\n            self.get_edit_message_button(),\n        ])\n\n        response = self.run_hook('after_edit_page', self.request, self.page)\n        if response:\n            return response\n\n        # we're done here - redirect back to the explorer\n        return self.redirect_away()\n\n    def perform_workflow_action(self):\n        self.page = self.form.save(commit=False)\n        self.subscription.save()\n\n        if self.has_content_changes:\n            # Save revision\n            revision = self.page.save_revision(\n                user=self.request.user,\n                log_action=True,  # Always log the new revision on edit\n                previous_revision=(self.previous_revision if self.is_reverting else None)\n            )\n\n            if 'comments' in self.form.formsets:\n                changes = self.get_commenting_changes()\n                self.log_commenting_changes(changes, revision)\n                self.send_commenting_notifications(changes)\n\n        extra_workflow_data_json = self.request.POST.get('workflow-action-extra-data', '{}')\n        extra_workflow_data = json.loads(extra_workflow_data_json)\n        self.page.current_workflow_task.on_action(self.page.current_workflow_task_state, self.request.user, self.workflow_action, **extra_workflow_data)\n\n        self.add_save_confirmation_message()\n\n        response = self.run_hook('after_edit_page', self.request, self.page)\n        if response:\n            return response\n\n        # we're done here - redirect back to the explorer\n        return self.redirect_away()\n\n    def cancel_workflow_action(self):\n        self.workflow_state.cancel(user=self.request.user)\n        self.page = self.form.save(commit=False)\n        self.subscription.save()\n\n        # Save revision\n        revision = self.page.save_revision(\n            user=self.request.user,\n            log_action=True,  # Always log the new revision on edit\n            previous_revision=(self.previous_revision if self.is_reverting else None)\n        )\n\n        if self.has_content_changes and 'comments' in self.form.formsets:\n            changes = self.get_commenting_changes()\n            self.log_commenting_changes(changes, revision)\n            self.send_commenting_notifications(changes)\n\n        # Notifications\n        self.add_cancel_workflow_confirmation_message()\n\n        response = self.run_hook('after_edit_page', self.request, self.page)\n        if response:\n            return response\n\n        # Just saving - remain on edit page for further edits\n        return self.redirect_and_remain()\n\n    def redirect_away(self):\n        if self.next_url:\n            # redirect back to 'next' url if present\n            return redirect(self.next_url)\n        else:\n            # redirect back to the explorer\n            return redirect('wagtailadmin_explore', self.page.get_parent().id)\n\n    def redirect_and_remain(self):\n        target_url = reverse('wagtailadmin_pages:edit', args=[self.page.id])\n        if self.next_url:\n            # Ensure the 'next' url is passed through again if present\n            target_url += '?next=%s' % quote(self.next_url)\n        return redirect(target_url)\n\n    def form_invalid(self, form):\n        # even if the page is locked due to not having permissions, the original submitter can still cancel the workflow\n        if self.is_cancelling_workflow:\n            self.workflow_state.cancel(user=self.request.user)\n            self.add_cancel_workflow_confirmation_message()\n\n        if self.page_perms.page_locked():\n            messages.error(self.request, _(\"The page could not be saved as it is locked\"))\n        else:\n            messages.validation_error(\n                self.request, _(\"The page could not be saved due to validation errors\"), self.form\n            )\n        self.errors_debug = (\n            repr(self.form.errors)\n            + repr([\n                (name, formset.errors)\n                for (name, formset) in self.form.formsets.items()\n                if formset.errors\n            ])\n        )\n        self.has_unsaved_changes = True\n\n        self.edit_handler = self.edit_handler.bind_to(form=self.form)\n        self.add_legacy_moderation_warning()\n        self.page_for_status = self.get_page_for_status()\n\n        return self.render_to_response(self.get_context_data())\n\n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n        context.update({\n            'page': self.page,\n            'page_for_status': self.page_for_status,\n            'content_type': self.page_content_type,\n            'edit_handler': self.edit_handler,\n            'errors_debug': self.errors_debug,\n            'action_menu': PageActionMenu(self.request, view='edit', page=self.page),\n            'preview_modes': self.page.preview_modes,\n            'form': self.form,\n            'next': self.next_url,\n            'has_unsaved_changes': self.has_unsaved_changes,\n            'page_locked': self.page_perms.page_locked(),\n            'workflow_state': self.workflow_state if self.workflow_state and self.workflow_state.is_active else None,\n            'current_task_state': self.page.current_workflow_task_state,\n            'publishing_will_cancel_workflow': self.workflow_tasks and getattr(settings, 'WAGTAIL_WORKFLOW_CANCEL_ON_PUBLISH', True),\n            'locale': None,\n            'translations': [],\n        })\n\n        if getattr(settings, 'WAGTAIL_I18N_ENABLED', False):\n            user_perms = UserPagePermissionsProxy(self.request.user)\n\n            context.update({\n                'locale': self.page.locale,\n                'translations': [\n                    {\n                        'locale': translation.locale,\n                        'url': reverse('wagtailadmin_pages:edit', args=[translation.id]),\n                    }\n                    for translation in self.page.get_translations().only('id', 'locale', 'depth').select_related('locale')\n                    if user_perms.for_page(translation).can_edit()\n                ],\n            })\n\n        return context\n"], "fixing_code": ["import datetime\nimport os\n\nfrom unittest import mock\n\nfrom django.conf import settings\nfrom django.contrib.auth.models import Group, Permission\nfrom django.core import mail\nfrom django.core.files.base import ContentFile\nfrom django.http import HttpRequest, HttpResponse\nfrom django.test import TestCase, modify_settings, override_settings\nfrom django.urls import reverse\nfrom django.utils import timezone\nfrom django.utils.translation import gettext_lazy as _\n\nfrom wagtail.admin.admin_url_finder import AdminURLFinder\nfrom wagtail.admin.tests.pages.timestamps import submittable_timestamp\nfrom wagtail.core.exceptions import PageClassNotFoundError\nfrom wagtail.core.models import (\n    Comment, CommentReply, GroupPagePermission, Locale, Page, PageLogEntry, PageRevision,\n    PageSubscription, Site)\nfrom wagtail.core.signals import page_published\nfrom wagtail.tests.testapp.models import (\n    EVENT_AUDIENCE_CHOICES, Advert, AdvertPlacement, EventCategory, EventPage,\n    EventPageCarouselItem, FilePage, ManyToManyBlogPage, SimplePage, SingleEventPage, StandardIndex,\n    TaggedPage)\nfrom wagtail.tests.utils import WagtailTestUtils\nfrom wagtail.tests.utils.form_data import inline_formset, nested_form_data\nfrom wagtail.users.models import UserProfile\n\n\nclass TestPageEdit(TestCase, WagtailTestUtils):\n    def setUp(self):\n        # Find root page\n        self.root_page = Page.objects.get(id=2)\n\n        # Add child page\n        child_page = SimplePage(\n            title=\"Hello world!\",\n            slug=\"hello-world\",\n            content=\"hello\",\n        )\n        self.root_page.add_child(instance=child_page)\n        child_page.save_revision().publish()\n        self.child_page = SimplePage.objects.get(id=child_page.id)\n\n        # Add file page\n        fake_file = ContentFile(\"File for testing multipart\")\n        fake_file.name = 'test.txt'\n        file_page = FilePage(\n            title=\"File Page\",\n            slug=\"file-page\",\n            file_field=fake_file,\n        )\n        self.root_page.add_child(instance=file_page)\n        file_page.save_revision().publish()\n        self.file_page = FilePage.objects.get(id=file_page.id)\n\n        # Add event page (to test edit handlers)\n        self.event_page = EventPage(\n            title=\"Event page\", slug=\"event-page\",\n            location='the moon', audience='public',\n            cost='free', date_from='2001-01-01',\n        )\n        self.root_page.add_child(instance=self.event_page)\n\n        # Add single event page (to test custom URL routes)\n        self.single_event_page = SingleEventPage(\n            title=\"Mars landing\", slug=\"mars-landing\",\n            location='mars', audience='public',\n            cost='free', date_from='2001-01-01',\n        )\n        self.root_page.add_child(instance=self.single_event_page)\n\n        self.unpublished_page = SimplePage(\n            title=\"Hello unpublished world!\",\n            slug=\"hello-unpublished-world\",\n            content=\"hello\",\n            live=False,\n            has_unpublished_changes=True,\n        )\n        self.root_page.add_child(instance=self.unpublished_page)\n\n        # Login\n        self.user = self.login()\n\n    def test_page_edit(self):\n        # Tests that the edit page loads\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.event_page.id, )))\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response['Content-Type'], \"text/html; charset=utf-8\")\n        self.assertContains(response, '<li class=\"header-meta--status\">Published</li>', html=True)\n\n        # Test InlinePanel labels/headings\n        self.assertContains(response, '<legend>Speaker lineup</legend>')\n        self.assertContains(response, 'Add speakers')\n\n        # test register_page_action_menu_item hook\n        self.assertContains(response,\n                            '<button type=\"submit\" name=\"action-panic\" value=\"Panic!\" class=\"button\">Panic!</button>')\n        self.assertContains(response, 'testapp/js/siren.js')\n\n        # test construct_page_action_menu hook\n        self.assertContains(response,\n                            '<button type=\"submit\" name=\"action-relax\" value=\"Relax.\" class=\"button\">Relax.</button>')\n\n        # test that workflow actions are shown\n        self.assertContains(\n            response, '<button type=\"submit\" name=\"action-submit\" value=\"Submit to Moderators approval\" class=\"button\">'\n        )\n\n        # test that AdminURLFinder returns the edit view for the page\n        url_finder = AdminURLFinder(self.user)\n        expected_url = '/admin/pages/%d/edit/' % self.event_page.id\n        self.assertEqual(url_finder.get_edit_url(self.event_page), expected_url)\n\n    @override_settings(WAGTAIL_WORKFLOW_ENABLED=False)\n    def test_workflow_buttons_not_shown_when_workflow_disabled(self):\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.event_page.id, )))\n        self.assertEqual(response.status_code, 200)\n        self.assertNotContains(\n            response, 'value=\"Submit to Moderators approval\"'\n        )\n\n    def test_edit_draft_page_with_no_revisions(self):\n        # Tests that the edit page loads\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.unpublished_page.id, )))\n        self.assertEqual(response.status_code, 200)\n        self.assertContains(response, '<li class=\"header-meta--status\">Draft</li>', html=True)\n\n    def test_edit_multipart(self):\n        \"\"\"\n        Test checks if 'enctype=\"multipart/form-data\"' is added and only to forms that require multipart encoding.\n        \"\"\"\n        # check for SimplePage where is no file field\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.event_page.id, )))\n        self.assertEqual(response.status_code, 200)\n        self.assertNotContains(response, 'enctype=\"multipart/form-data\"')\n        self.assertTemplateUsed(response, 'wagtailadmin/pages/edit.html')\n\n        # check for FilePage which has file field\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.file_page.id, )))\n        self.assertEqual(response.status_code, 200)\n        self.assertContains(response, 'enctype=\"multipart/form-data\"')\n\n    @mock.patch('wagtail.core.models.ContentType.model_class', return_value=None)\n    def test_edit_when_specific_class_cannot_be_found(self, mocked_method):\n        with self.assertRaises(PageClassNotFoundError):\n            self.client.get(reverse('wagtailadmin_pages:edit', args=(self.event_page.id, )))\n\n    def test_upload_file_publish(self):\n        \"\"\"\n        Check that file uploads work when directly publishing\n        \"\"\"\n        file_upload = ContentFile(b\"A new file\", name='published-file.txt')\n        post_data = {\n            'title': 'New file',\n            'slug': 'new-file',\n            'file_field': file_upload,\n            'action-publish': \"Publish\",\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.file_page.id]), post_data)\n\n        # Should be redirected to explorer\n        self.assertRedirects(response, reverse('wagtailadmin_explore', args=[self.root_page.id]))\n\n        # Check the new file exists\n        file_page = FilePage.objects.get()\n\n        self.assertEqual(file_page.file_field.name, file_upload.name)\n        self.assertTrue(os.path.exists(file_page.file_field.path))\n        self.assertEqual(file_page.file_field.read(), b\"A new file\")\n\n    def test_upload_file_draft(self):\n        \"\"\"\n        Check that file uploads work when saving a draft\n        \"\"\"\n        file_upload = ContentFile(b\"A new file\", name='draft-file.txt')\n        post_data = {\n            'title': 'New file',\n            'slug': 'new-file',\n            'file_field': file_upload,\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.file_page.id]), post_data)\n\n        # Should be redirected to edit page\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[self.file_page.id]))\n\n        # Check the file was uploaded\n        file_path = os.path.join(settings.MEDIA_ROOT, file_upload.name)\n        self.assertTrue(os.path.exists(file_path))\n        with open(file_path, 'rb') as saved_file:\n            self.assertEqual(saved_file.read(), b\"A new file\")\n\n        # Publish the draft just created\n        FilePage.objects.get().get_latest_revision().publish()\n\n        # Get the file page, check the file is set\n        file_page = FilePage.objects.get()\n        self.assertEqual(file_page.file_field.name, file_upload.name)\n        self.assertTrue(os.path.exists(file_page.file_field.path))\n        self.assertEqual(file_page.file_field.read(), b\"A new file\")\n\n    def test_page_edit_bad_permissions(self):\n        # Remove privileges from user\n        self.user.is_superuser = False\n        self.user.user_permissions.add(\n            Permission.objects.get(content_type__app_label='wagtailadmin', codename='access_admin')\n        )\n        self.user.save()\n\n        # Get edit page\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )))\n\n        # Check that the user received a 302 redirected response\n        self.assertEqual(response.status_code, 302)\n\n        url_finder = AdminURLFinder(self.user)\n        self.assertEqual(url_finder.get_edit_url(self.event_page), None)\n\n    def test_page_edit_post(self):\n        # Tests simple editing\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)\n\n        # Should be redirected to edit page\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )))\n\n        # The page should have \"has_unpublished_changes\" flag set\n        child_page_new = SimplePage.objects.get(id=self.child_page.id)\n        self.assertTrue(child_page_new.has_unpublished_changes)\n\n        # Page fields should not be changed (because we just created a new draft)\n        self.assertEqual(child_page_new.title, self.child_page.title)\n        self.assertEqual(child_page_new.content, self.child_page.content)\n        self.assertEqual(child_page_new.slug, self.child_page.slug)\n\n        # The draft_title should have a new title\n        self.assertEqual(child_page_new.draft_title, post_data['title'])\n\n    def test_page_edit_post_when_locked(self):\n        # Tests that trying to edit a locked page results in an error\n\n        # Lock the page\n        self.child_page.locked = True\n        self.child_page.save()\n\n        # Post\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)\n\n        # Shouldn't be redirected\n        self.assertContains(response, \"The page could not be saved as it is locked\")\n\n        # The page shouldn't have \"has_unpublished_changes\" flag set\n        child_page_new = SimplePage.objects.get(id=self.child_page.id)\n        self.assertFalse(child_page_new.has_unpublished_changes)\n\n    def test_edit_post_scheduled(self):\n        # put go_live_at and expire_at several days away from the current date, to avoid\n        # false matches in content_json__contains tests\n        go_live_at = timezone.now() + datetime.timedelta(days=10)\n        expire_at = timezone.now() + datetime.timedelta(days=20)\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'go_live_at': submittable_timestamp(go_live_at),\n            'expire_at': submittable_timestamp(expire_at),\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)\n\n        # Should be redirected to explorer page\n        self.assertEqual(response.status_code, 302)\n\n        child_page_new = SimplePage.objects.get(id=self.child_page.id)\n\n        # The page will still be live\n        self.assertTrue(child_page_new.live)\n\n        # A revision with approved_go_live_at should not exist\n        self.assertFalse(PageRevision.objects.filter(\n            page=child_page_new).exclude(approved_go_live_at__isnull=True).exists()\n        )\n\n        # But a revision with go_live_at and expire_at in their content json *should* exist\n        self.assertTrue(PageRevision.objects.filter(\n            page=child_page_new, content_json__contains=str(go_live_at.date())).exists()\n        )\n        self.assertTrue(\n            PageRevision.objects.filter(page=child_page_new, content_json__contains=str(expire_at.date())).exists()\n        )\n\n    def test_edit_scheduled_go_live_before_expiry(self):\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'go_live_at': submittable_timestamp(timezone.now() + datetime.timedelta(days=2)),\n            'expire_at': submittable_timestamp(timezone.now() + datetime.timedelta(days=1)),\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)\n\n        self.assertEqual(response.status_code, 200)\n\n        # Check that a form error was raised\n        self.assertFormError(response, 'form', 'go_live_at', \"Go live date/time must be before expiry date/time\")\n        self.assertFormError(response, 'form', 'expire_at', \"Go live date/time must be before expiry date/time\")\n\n        # form should be marked as having unsaved changes for the purposes of the dirty-forms warning\n        self.assertContains(response, \"alwaysDirty: true\")\n\n    def test_edit_scheduled_expire_in_the_past(self):\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'expire_at': submittable_timestamp(timezone.now() + datetime.timedelta(days=-1)),\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)\n\n        self.assertEqual(response.status_code, 200)\n\n        # Check that a form error was raised\n        self.assertFormError(response, 'form', 'expire_at', \"Expiry date/time must be in the future\")\n\n        # form should be marked as having unsaved changes for the purposes of the dirty-forms warning\n        self.assertContains(response, \"alwaysDirty: true\")\n\n    def test_page_edit_post_publish(self):\n        # Connect a mock signal handler to page_published signal\n        mock_handler = mock.MagicMock()\n        page_published.connect(mock_handler)\n\n        # Set has_unpublished_changes=True on the existing record to confirm that the publish action\n        # is resetting it (and not just leaving it alone)\n        self.child_page.has_unpublished_changes = True\n        self.child_page.save()\n\n        # Save current value of first_published_at so we can check that it doesn't change\n        first_published_at = SimplePage.objects.get(id=self.child_page.id).first_published_at\n\n        # Tests publish from edit page\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world-new',\n            'action-publish': \"Publish\",\n        }\n        response = self.client.post(\n            reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data, follow=True\n        )\n\n        # Should be redirected to explorer\n        self.assertRedirects(response, reverse('wagtailadmin_explore', args=(self.root_page.id, )))\n\n        # Check that the page was edited\n        child_page_new = SimplePage.objects.get(id=self.child_page.id)\n        self.assertEqual(child_page_new.title, post_data['title'])\n        self.assertEqual(child_page_new.draft_title, post_data['title'])\n\n        # Check that the page_published signal was fired\n        self.assertEqual(mock_handler.call_count, 1)\n        mock_call = mock_handler.mock_calls[0][2]\n\n        self.assertEqual(mock_call['sender'], child_page_new.specific_class)\n        self.assertEqual(mock_call['instance'], child_page_new)\n        self.assertIsInstance(mock_call['instance'], child_page_new.specific_class)\n\n        # The page shouldn't have \"has_unpublished_changes\" flag set\n        self.assertFalse(child_page_new.has_unpublished_changes)\n\n        # first_published_at should not change as it was already set\n        self.assertEqual(first_published_at, child_page_new.first_published_at)\n\n        # The \"View Live\" button should have the updated slug.\n        for message in response.context['messages']:\n            self.assertIn('hello-world-new', message.message)\n            break\n\n    def test_first_published_at_editable(self):\n        \"\"\"Test that we can update the first_published_at via the Page edit form,\n        for page models that expose it.\"\"\"\n\n        # Add child page, of a type which has first_published_at in its form\n        child_page = ManyToManyBlogPage(\n            title=\"Hello world!\",\n            slug=\"hello-again-world\",\n            body=\"hello\",\n        )\n        self.root_page.add_child(instance=child_page)\n        child_page.save_revision().publish()\n        self.child_page = ManyToManyBlogPage.objects.get(id=child_page.id)\n\n        initial_delta = self.child_page.first_published_at - timezone.now()\n\n        first_published_at = timezone.now() - datetime.timedelta(days=2)\n\n        post_data = {\n            'title': \"I've been edited!\",\n            'body': \"Some content\",\n            'slug': 'hello-again-world',\n            'action-publish': \"Publish\",\n            'first_published_at': submittable_timestamp(first_published_at),\n            'comments-TOTAL_FORMS': 0,\n            'comments-INITIAL_FORMS': 0,\n            'comments-MIN_NUM_FORMS': 0,\n            'comments-MAX_NUM_FORMS': 1000,\n        }\n        self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)\n\n        # Get the edited page.\n        child_page_new = ManyToManyBlogPage.objects.get(id=self.child_page.id)\n\n        # first_published_at should have changed.\n        new_delta = child_page_new.first_published_at - timezone.now()\n        self.assertNotEqual(new_delta.days, initial_delta.days)\n        # first_published_at should be 3 days ago.\n        self.assertEqual(new_delta.days, -3)\n\n    def test_edit_post_publish_scheduled_unpublished_page(self):\n        # Unpublish the page\n        self.child_page.live = False\n        self.child_page.save()\n\n        go_live_at = timezone.now() + datetime.timedelta(days=1)\n        expire_at = timezone.now() + datetime.timedelta(days=2)\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'action-publish': \"Publish\",\n            'go_live_at': submittable_timestamp(go_live_at),\n            'expire_at': submittable_timestamp(expire_at),\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)\n\n        # Should be redirected to explorer page\n        self.assertEqual(response.status_code, 302)\n\n        child_page_new = SimplePage.objects.get(id=self.child_page.id)\n\n        # The page should not be live anymore\n        self.assertFalse(child_page_new.live)\n\n        # Instead a revision with approved_go_live_at should now exist\n        self.assertTrue(\n            PageRevision.objects.filter(page=child_page_new).exclude(approved_go_live_at__isnull=True).exists()\n        )\n\n        # The page SHOULD have the \"has_unpublished_changes\" flag set,\n        # because the changes are not visible as a live page yet\n        self.assertTrue(\n            child_page_new.has_unpublished_changes,\n            \"A page scheduled for future publishing should have has_unpublished_changes=True\"\n        )\n\n        self.assertEqual(child_page_new.status_string, \"scheduled\")\n\n    def test_edit_post_publish_now_an_already_scheduled_unpublished_page(self):\n        # Unpublish the page\n        self.child_page.live = False\n        self.child_page.save()\n\n        # First let's publish a page with a go_live_at in the future\n        go_live_at = timezone.now() + datetime.timedelta(days=1)\n        expire_at = timezone.now() + datetime.timedelta(days=2)\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'action-publish': \"Publish\",\n            'go_live_at': submittable_timestamp(go_live_at),\n            'expire_at': submittable_timestamp(expire_at),\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)\n\n        # Should be redirected to edit page\n        self.assertEqual(response.status_code, 302)\n\n        child_page_new = SimplePage.objects.get(id=self.child_page.id)\n\n        # The page should not be live\n        self.assertFalse(child_page_new.live)\n\n        self.assertEqual(child_page_new.status_string, \"scheduled\")\n\n        # Instead a revision with approved_go_live_at should now exist\n        self.assertTrue(\n            PageRevision.objects.filter(page=child_page_new).exclude(approved_go_live_at__isnull=True).exists()\n        )\n\n        # Now, let's edit it and publish it right now\n        go_live_at = timezone.now()\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'action-publish': \"Publish\",\n            'go_live_at': \"\",\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)\n\n        # Should be redirected to edit page\n        self.assertEqual(response.status_code, 302)\n\n        child_page_new = SimplePage.objects.get(id=self.child_page.id)\n\n        # The page should be live now\n        self.assertTrue(child_page_new.live)\n\n        # And a revision with approved_go_live_at should not exist\n        self.assertFalse(\n            PageRevision.objects.filter(page=child_page_new).exclude(approved_go_live_at__isnull=True).exists()\n        )\n\n    def test_edit_post_publish_scheduled_published_page(self):\n        # Page is live\n        self.child_page.live = True\n        self.child_page.save()\n\n        live_revision = self.child_page.live_revision\n        original_title = self.child_page.title\n\n        go_live_at = timezone.now() + datetime.timedelta(days=1)\n        expire_at = timezone.now() + datetime.timedelta(days=2)\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'action-publish': \"Publish\",\n            'go_live_at': submittable_timestamp(go_live_at),\n            'expire_at': submittable_timestamp(expire_at),\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)\n\n        # Should be redirected to explorer page\n        self.assertEqual(response.status_code, 302)\n\n        child_page_new = SimplePage.objects.get(id=self.child_page.id)\n\n        # The page should still be live\n        self.assertTrue(child_page_new.live)\n\n        self.assertEqual(child_page_new.status_string, \"live + scheduled\")\n\n        # Instead a revision with approved_go_live_at should now exist\n        self.assertTrue(\n            PageRevision.objects.filter(page=child_page_new).exclude(approved_go_live_at__isnull=True).exists()\n        )\n\n        # The page SHOULD have the \"has_unpublished_changes\" flag set,\n        # because the changes are not visible as a live page yet\n        self.assertTrue(\n            child_page_new.has_unpublished_changes,\n            \"A page scheduled for future publishing should have has_unpublished_changes=True\"\n        )\n\n        self.assertNotEqual(\n            child_page_new.get_latest_revision(), live_revision,\n            \"A page scheduled for future publishing should have a new revision, that is not the live revision\"\n        )\n\n        self.assertEqual(\n            child_page_new.title, original_title,\n            \"A live page with scheduled revisions should still have original content\"\n        )\n\n    def test_edit_post_publish_now_an_already_scheduled_published_page(self):\n        # Unpublish the page\n        self.child_page.live = True\n        self.child_page.save()\n\n        original_title = self.child_page.title\n        # First let's publish a page with a go_live_at in the future\n        go_live_at = timezone.now() + datetime.timedelta(days=1)\n        expire_at = timezone.now() + datetime.timedelta(days=2)\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'action-publish': \"Publish\",\n            'go_live_at': submittable_timestamp(go_live_at),\n            'expire_at': submittable_timestamp(expire_at),\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)\n\n        # Should be redirected to edit page\n        self.assertEqual(response.status_code, 302)\n\n        child_page_new = SimplePage.objects.get(id=self.child_page.id)\n\n        # The page should still be live\n        self.assertTrue(child_page_new.live)\n\n        # Instead a revision with approved_go_live_at should now exist\n        self.assertTrue(\n            PageRevision.objects.filter(page=child_page_new).exclude(approved_go_live_at__isnull=True).exists()\n        )\n\n        self.assertEqual(\n            child_page_new.title, original_title,\n            \"A live page with scheduled revisions should still have original content\"\n        )\n\n        # Now, let's edit it and publish it right now\n        go_live_at = timezone.now()\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'action-publish': \"Publish\",\n            'go_live_at': \"\",\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)\n\n        # Should be redirected to edit page\n        self.assertEqual(response.status_code, 302)\n\n        child_page_new = SimplePage.objects.get(id=self.child_page.id)\n\n        # The page should be live now\n        self.assertTrue(child_page_new.live)\n\n        # And a revision with approved_go_live_at should not exist\n        self.assertFalse(\n            PageRevision.objects.filter(page=child_page_new).exclude(approved_go_live_at__isnull=True).exists()\n        )\n\n        self.assertEqual(\n            child_page_new.title, post_data['title'],\n            \"A published page should have the new title\"\n        )\n\n    def test_page_edit_post_submit(self):\n        # Create a moderator user for testing email\n        self.create_superuser('moderator', 'moderator@email.com', 'password')\n\n        # Tests submitting from edit page\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'action-submit': \"Submit\",\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)\n\n        # Should be redirected to explorer\n        self.assertRedirects(response, reverse('wagtailadmin_explore', args=(self.root_page.id, )))\n\n        # The page should have \"has_unpublished_changes\" flag set\n        child_page_new = SimplePage.objects.get(id=self.child_page.id)\n        self.assertTrue(child_page_new.has_unpublished_changes)\n\n        # The latest revision for the page should now be in moderation\n        self.assertEqual(child_page_new.current_workflow_state.status, child_page_new.current_workflow_state.STATUS_IN_PROGRESS)\n\n    def test_page_edit_post_existing_slug(self):\n        # This tests the existing slug checking on page edit\n\n        # Create a page\n        self.child_page = SimplePage(title=\"Hello world 2\", slug=\"hello-world2\", content=\"hello\")\n        self.root_page.add_child(instance=self.child_page)\n\n        # Attempt to change the slug to one that's already in use\n        post_data = {\n            'title': \"Hello world 2\",\n            'slug': 'hello-world',\n            'action-submit': \"Submit\",\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)\n\n        # Should not be redirected (as the save should fail)\n        self.assertEqual(response.status_code, 200)\n\n        # Check that a form error was raised\n        self.assertFormError(response, 'form', 'slug', \"This slug is already in use\")\n\n    def test_preview_on_edit(self):\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'action-submit': \"Submit\",\n        }\n        preview_url = reverse('wagtailadmin_pages:preview_on_edit',\n                              args=(self.child_page.id,))\n        response = self.client.post(preview_url, post_data)\n\n        # Check the JSON response\n        self.assertEqual(response.status_code, 200)\n        self.assertJSONEqual(response.content.decode(), {'is_valid': True})\n\n        response = self.client.get(preview_url)\n\n        # Check the HTML response\n        self.assertEqual(response.status_code, 200)\n        self.assertTemplateUsed(response, 'tests/simple_page.html')\n        self.assertContains(response, \"I&#39;ve been edited!\", html=True)\n\n    def test_preview_on_edit_no_session_key(self):\n        preview_url = reverse('wagtailadmin_pages:preview_on_edit',\n                              args=(self.child_page.id,))\n\n        # get() without corresponding post(), key not set.\n        response = self.client.get(preview_url)\n\n        # Check the HTML response\n        self.assertEqual(response.status_code, 200)\n\n        # We should have an error page because we are unable to\n        # preview; the page key was not in the session.\n        self.assertContains(\n            response,\n            \"<title>Wagtail - Preview error</title>\",\n            html=True\n        )\n        self.assertContains(\n            response,\n            \"<h1>Preview error</h1>\",\n            html=True\n        )\n\n    @override_settings(CACHES={\n        'default': {\n            'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',\n        }})\n    @modify_settings(MIDDLEWARE={\n        'append': 'django.middleware.cache.FetchFromCacheMiddleware',\n        'prepend': 'django.middleware.cache.UpdateCacheMiddleware',\n    })\n    def test_preview_does_not_cache(self):\n        '''\n        Tests solution to issue #5975\n        '''\n        post_data = {\n            'title': \"I've been edited one time!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'action-submit': \"Submit\",\n        }\n        preview_url = reverse('wagtailadmin_pages:preview_on_edit',\n                              args=(self.child_page.id,))\n        self.client.post(preview_url, post_data)\n        response = self.client.get(preview_url)\n        self.assertContains(response, \"I&#39;ve been edited one time!\", html=True)\n\n        post_data['title'] = \"I've been edited two times!\"\n        self.client.post(preview_url, post_data)\n        response = self.client.get(preview_url)\n        self.assertContains(response, \"I&#39;ve been edited two times!\", html=True)\n\n    @modify_settings(ALLOWED_HOSTS={'append': 'childpage.example.com'})\n    def test_preview_uses_correct_site(self):\n        # create a Site record for the child page\n        Site.objects.create(hostname='childpage.example.com', root_page=self.child_page)\n\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'action-submit': \"Submit\",\n        }\n        preview_url = reverse('wagtailadmin_pages:preview_on_edit',\n                              args=(self.child_page.id,))\n        response = self.client.post(preview_url, post_data)\n\n        # Check the JSON response\n        self.assertEqual(response.status_code, 200)\n        self.assertJSONEqual(response.content.decode(), {'is_valid': True})\n\n        response = self.client.get(preview_url)\n\n        # Check that the correct site object has been selected by the site middleware\n        self.assertEqual(response.status_code, 200)\n        self.assertTemplateUsed(response, 'tests/simple_page.html')\n        self.assertEqual(Site.find_for_request(response.context['request']).hostname, 'childpage.example.com')\n\n    def test_editor_picks_up_direct_model_edits(self):\n        # If a page has no draft edits, the editor should show the version from the live database\n        # record rather than the latest revision record. This ensures that the edit interface\n        # reflects any changes made directly on the model.\n        self.child_page.title = \"This title only exists on the live database record\"\n        self.child_page.save()\n\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )))\n        self.assertEqual(response.status_code, 200)\n        self.assertContains(response, \"This title only exists on the live database record\")\n\n    def test_editor_does_not_pick_up_direct_model_edits_when_draft_edits_exist(self):\n        # If a page has draft edits, we should always show those in the editor, not the live\n        # database record\n        self.child_page.content = \"Some content with a draft edit\"\n        self.child_page.save_revision()\n\n        # make an independent change to the live database record\n        self.child_page = SimplePage.objects.get(id=self.child_page.id)\n        self.child_page.title = \"This title only exists on the live database record\"\n        self.child_page.save()\n\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )))\n        self.assertEqual(response.status_code, 200)\n        self.assertNotContains(response, \"This title only exists on the live database record\")\n        self.assertContains(response, \"Some content with a draft edit\")\n\n    def test_editor_page_shows_live_url_in_status_when_draft_edits_exist(self):\n        # If a page has draft edits (ie. page has unpublished changes)\n        # that affect the URL (eg. slug) we  should still ensure the\n        # status button at the top of the page links to the live URL\n\n        self.child_page.content = \"Some content with a draft edit\"\n        self.child_page.slug = \"revised-slug-in-draft-only\"  # live version contains 'hello-world'\n        self.child_page.save_revision()\n\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )))\n\n        link_to_live = '<a href=\"/hello-world/\" target=\"_blank\" rel=\"noopener noreferrer\" class=\"button button-nostroke button--live\" title=\"Visit the live page\">\\n' \\\n                       '<svg class=\"icon icon-link-external initial\" aria-hidden=\"true\" focusable=\"false\"><use href=\"#icon-link-external\"></use></svg>\\n\\n        ' \\\n                       'Live\\n        <span class=\"privacy-indicator-tag u-hidden\" aria-hidden=\"true\" title=\"This page is live but only available to certain users\">(restricted)</span>'\n        input_field_for_draft_slug = '<input type=\"text\" name=\"slug\" value=\"revised-slug-in-draft-only\" id=\"id_slug\" maxlength=\"255\" required />'\n        input_field_for_live_slug = '<input type=\"text\" name=\"slug\" value=\"hello-world\" id=\"id_slug\" maxlength=\"255\" required />'\n\n        # Status Link should be the live page (not revision)\n        self.assertContains(response, link_to_live, html=True)\n        self.assertNotContains(response, 'href=\"/revised-slug-in-draft-only/\"', html=True)\n\n        # Editing input for slug should be the draft revision\n        self.assertContains(response, input_field_for_draft_slug, html=True)\n        self.assertNotContains(response, input_field_for_live_slug, html=True)\n\n    def test_editor_page_shows_custom_live_url_in_status_when_draft_edits_exist(self):\n        # When showing a live URL in the status button that differs from the draft one,\n        # ensure that we pick up any custom URL logic defined on the specific page model\n\n        self.single_event_page.location = \"The other side of Mars\"\n        self.single_event_page.slug = \"revised-slug-in-draft-only\"  # live version contains 'hello-world'\n        self.single_event_page.save_revision()\n\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.single_event_page.id, )))\n\n        link_to_live = '<a href=\"/mars-landing/pointless-suffix/\" target=\"_blank\" rel=\"noopener noreferrer\" class=\"button button-nostroke button--live\" title=\"Visit the live page\">\\n' \\\n                       '<svg class=\"icon icon-link-external initial\" aria-hidden=\"true\" focusable=\"false\"><use href=\"#icon-link-external\"></use></svg>\\n\\n        ' \\\n                       'Live\\n        <span class=\"privacy-indicator-tag u-hidden\" aria-hidden=\"true\" title=\"This page is live but only available to certain users\">(restricted)</span>'\n        input_field_for_draft_slug = '<input type=\"text\" name=\"slug\" value=\"revised-slug-in-draft-only\" id=\"id_slug\" maxlength=\"255\" required />'\n        input_field_for_live_slug = '<input type=\"text\" name=\"slug\" value=\"mars-landing\" id=\"id_slug\" maxlength=\"255\" required />'\n\n        # Status Link should be the live page (not revision)\n        self.assertContains(response, link_to_live, html=True)\n        self.assertNotContains(response, 'href=\"/revised-slug-in-draft-only/pointless-suffix/\"', html=True)\n\n        # Editing input for slug should be the draft revision\n        self.assertContains(response, input_field_for_draft_slug, html=True)\n        self.assertNotContains(response, input_field_for_live_slug, html=True)\n\n    def test_before_edit_page_hook(self):\n        def hook_func(request, page):\n            self.assertIsInstance(request, HttpRequest)\n            self.assertEqual(page.id, self.child_page.id)\n\n            return HttpResponse(\"Overridden!\")\n\n        with self.register_hook('before_edit_page', hook_func):\n            response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )))\n\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b\"Overridden!\")\n\n    def test_before_edit_page_hook_post(self):\n        def hook_func(request, page):\n            self.assertIsInstance(request, HttpRequest)\n            self.assertEqual(page.id, self.child_page.id)\n\n            return HttpResponse(\"Overridden!\")\n\n        with self.register_hook('before_edit_page', hook_func):\n            post_data = {\n                'title': \"I've been edited!\",\n                'content': \"Some content\",\n                'slug': 'hello-world-new',\n                'action-publish': \"Publish\",\n            }\n            response = self.client.post(\n                reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data\n            )\n\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b\"Overridden!\")\n\n        # page should not be edited\n        self.assertEqual(Page.objects.get(id=self.child_page.id).title, \"Hello world!\")\n\n    def test_after_edit_page_hook(self):\n        def hook_func(request, page):\n            self.assertIsInstance(request, HttpRequest)\n            self.assertEqual(page.id, self.child_page.id)\n\n            return HttpResponse(\"Overridden!\")\n\n        with self.register_hook('after_edit_page', hook_func):\n            post_data = {\n                'title': \"I've been edited!\",\n                'content': \"Some content\",\n                'slug': 'hello-world-new',\n                'action-publish': \"Publish\",\n            }\n            response = self.client.post(\n                reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data\n            )\n\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b\"Overridden!\")\n\n        # page should be edited\n        self.assertEqual(Page.objects.get(id=self.child_page.id).title, \"I've been edited!\")\n\n    def test_after_publish_page(self):\n        def hook_func(request, page):\n            self.assertIsInstance(request, HttpRequest)\n            self.assertEqual(page.id, self.child_page.id)\n\n            return HttpResponse(\"Overridden!\")\n\n        with self.register_hook(\"after_publish_page\", hook_func):\n            post_data = {\n                'title': \"I've been edited!\",\n                'content': \"Some content\",\n                'slug': 'hello-world-new',\n                'action-publish': \"Publish\",\n            }\n            response = self.client.post(\n                reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data\n            )\n\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b\"Overridden!\")\n        self.child_page.refresh_from_db()\n        self.assertEqual(self.child_page.status_string, _(\"live\"))\n\n    def test_before_publish_page(self):\n        def hook_func(request, page):\n            self.assertIsInstance(request, HttpRequest)\n            self.assertEqual(page.id, self.child_page.id)\n\n            return HttpResponse(\"Overridden!\")\n\n        with self.register_hook(\"before_publish_page\", hook_func):\n            post_data = {\n                'title': \"I've been edited!\",\n                'content': \"Some content\",\n                'slug': 'hello-world-new',\n                'action-publish': \"Publish\",\n            }\n            response = self.client.post(\n                reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data\n            )\n\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response.content, b\"Overridden!\")\n        self.child_page.refresh_from_db()\n        self.assertEqual(self.child_page.status_string, _(\"live + draft\"))\n\n    def test_override_default_action_menu_item(self):\n        def hook_func(menu_items, request, context):\n            for (index, item) in enumerate(menu_items):\n                if item.name == 'action-publish':\n                    # move to top of list\n                    menu_items.pop(index)\n                    menu_items.insert(0, item)\n                    break\n\n        with self.register_hook('construct_page_action_menu', hook_func):\n            response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.single_event_page.id, )))\n\n        publish_button = '''\n            <button type=\"submit\" name=\"action-publish\" value=\"action-publish\" class=\"button button-longrunning \" data-clicked-text=\"Publishing\u2026\">\n                <svg class=\"icon icon-upload button-longrunning__icon\" aria-hidden=\"true\" focusable=\"false\"><use href=\"#icon-upload\"></use></svg>\n\n                <svg class=\"icon icon-spinner icon\" aria-hidden=\"true\" focusable=\"false\"><use href=\"#icon-spinner\"></use></svg><em>Publish</em>\n            </button>\n        '''\n        save_button = '''\n            <button type=\"submit\" class=\"button action-save button-longrunning \" data-clicked-text=\"Saving\u2026\" >\n                <svg class=\"icon icon-draft button-longrunning__icon\" aria-hidden=\"true\" focusable=\"false\"><use href=\"#icon-draft\"></use></svg>\n\n                <svg class=\"icon icon-spinner icon\" aria-hidden=\"true\" focusable=\"false\"><use href=\"#icon-spinner\"></use></svg>\n                <em>Save draft</em>\n            </button>\n        '''\n\n        # save button should be in a <li>\n        self.assertContains(response, \"<li>%s</li>\" % save_button, html=True)\n\n        # publish button should be present, but not in a <li>\n        self.assertContains(response, publish_button, html=True)\n        self.assertNotContains(response, \"<li>%s</li>\" % publish_button, html=True)\n\n    def test_edit_alias_page(self):\n        alias_page = self.event_page.create_alias(update_slug='new-event-page')\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=[alias_page.id]))\n\n        self.assertEqual(response.status_code, 200)\n        self.assertEqual(response['Content-Type'], \"text/html; charset=utf-8\")\n\n        # Should still have status in the header\n        self.assertContains(response, '<li class=\"header-meta--status\">Published</li>', html=True)\n\n        # Check the edit_alias.html template was used instead\n        self.assertTemplateUsed(response, 'wagtailadmin/pages/edit_alias.html')\n        original_page_edit_url = reverse('wagtailadmin_pages:edit', args=[self.event_page.id])\n        self.assertContains(response, f'<a class=\"button button-secondary\" href=\"{original_page_edit_url}\">Edit original page</a>', html=True)\n\n    def test_post_edit_alias_page(self):\n        alias_page = self.child_page.create_alias(update_slug='new-child-page')\n\n        # Tests simple editing\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[alias_page.id]), post_data)\n\n        self.assertEqual(response.status_code, 405)\n\n    def test_edit_after_change_language_code(self):\n        \"\"\"\n        Verify that changing LANGUAGE_CODE with no corresponding database change does not break editing\n        \"\"\"\n        # Add a draft revision\n        self.child_page.title = \"Hello world updated\"\n        self.child_page.save_revision()\n\n        # Hack the Locale model to simulate a page tree that was created with LANGUAGE_CODE = 'de'\n        # (which is not a valid content language under the current configuration)\n        Locale.objects.update(language_code='de')\n\n        # Tests that the edit page loads\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )))\n        self.assertEqual(response.status_code, 200)\n\n        # Tests simple editing\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)\n\n        # Should be redirected to edit page\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )))\n\n    def test_edit_after_change_language_code_without_revisions(self):\n        \"\"\"\n        Verify that changing LANGUAGE_CODE with no corresponding database change does not break editing\n        \"\"\"\n        # Hack the Locale model to simulate a page tree that was created with LANGUAGE_CODE = 'de'\n        # (which is not a valid content language under the current configuration)\n        Locale.objects.update(language_code='de')\n\n        PageRevision.objects.filter(page_id=self.child_page.id).delete()\n\n        # Tests that the edit page loads\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )))\n        self.assertEqual(response.status_code, 200)\n\n        # Tests simple editing\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )), post_data)\n\n        # Should be redirected to edit page\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )))\n\n\nclass TestPageEditReordering(TestCase, WagtailTestUtils):\n    def setUp(self):\n        # Find root page\n        self.root_page = Page.objects.get(id=2)\n\n        # Add event page\n        self.event_page = EventPage(\n            title=\"Event page\", slug=\"event-page\",\n            location='the moon', audience='public',\n            cost='free', date_from='2001-01-01',\n        )\n        self.event_page.carousel_items = [\n            EventPageCarouselItem(caption='1234567', sort_order=1),\n            EventPageCarouselItem(caption='7654321', sort_order=2),\n            EventPageCarouselItem(caption='abcdefg', sort_order=3),\n        ]\n        self.root_page.add_child(instance=self.event_page)\n\n        # Login\n        self.user = self.login()\n\n    def check_order(self, response, expected_order):\n        inline_panel = response.context['edit_handler'].children[0].children[9]\n        order = [child.form.instance.caption for child in inline_panel.children]\n        self.assertEqual(order, expected_order)\n\n    def test_order(self):\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.event_page.id, )))\n\n        self.assertEqual(response.status_code, 200)\n        self.check_order(response, ['1234567', '7654321', 'abcdefg'])\n\n    def test_reorder(self):\n        post_data = {\n            'title': \"Event page\",\n            'slug': 'event-page',\n\n            'date_from': '01/01/2014',\n            'cost': '$10',\n            'audience': 'public',\n            'location': 'somewhere',\n\n            'related_links-INITIAL_FORMS': 0,\n            'related_links-MAX_NUM_FORMS': 1000,\n            'related_links-TOTAL_FORMS': 0,\n\n            'speakers-INITIAL_FORMS': 0,\n            'speakers-MAX_NUM_FORMS': 1000,\n            'speakers-TOTAL_FORMS': 0,\n\n            'head_counts-INITIAL_FORMS': 0,\n            'head_counts-MAX_NUM_FORMS': 1000,\n            'head_counts-TOTAL_FORMS': 0,\n\n            'carousel_items-INITIAL_FORMS': 3,\n            'carousel_items-MAX_NUM_FORMS': 1000,\n            'carousel_items-TOTAL_FORMS': 3,\n            'carousel_items-0-id': self.event_page.carousel_items.all()[0].id,\n            'carousel_items-0-caption': self.event_page.carousel_items.all()[0].caption,\n            'carousel_items-0-ORDER': 2,\n            'carousel_items-1-id': self.event_page.carousel_items.all()[1].id,\n            'carousel_items-1-caption': self.event_page.carousel_items.all()[1].caption,\n            'carousel_items-1-ORDER': 3,\n            'carousel_items-2-id': self.event_page.carousel_items.all()[2].id,\n            'carousel_items-2-caption': self.event_page.carousel_items.all()[2].caption,\n            'carousel_items-2-ORDER': 1,\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.event_page.id, )), post_data)\n\n        # Should be redirected back to same page\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=(self.event_page.id, )))\n\n        # Check order\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.event_page.id, )))\n\n        self.assertEqual(response.status_code, 200)\n        self.check_order(response, ['abcdefg', '1234567', '7654321'])\n\n    def test_reorder_with_validation_error(self):\n        post_data = {\n            'title': \"\",  # Validation error\n            'slug': 'event-page',\n\n            'date_from': '01/01/2014',\n            'cost': '$10',\n            'audience': 'public',\n            'location': 'somewhere',\n\n            'related_links-INITIAL_FORMS': 0,\n            'related_links-MAX_NUM_FORMS': 1000,\n            'related_links-TOTAL_FORMS': 0,\n\n            'speakers-INITIAL_FORMS': 0,\n            'speakers-MAX_NUM_FORMS': 1000,\n            'speakers-TOTAL_FORMS': 0,\n\n            'head_counts-INITIAL_FORMS': 0,\n            'head_counts-MAX_NUM_FORMS': 1000,\n            'head_counts-TOTAL_FORMS': 0,\n\n            'carousel_items-INITIAL_FORMS': 3,\n            'carousel_items-MAX_NUM_FORMS': 1000,\n            'carousel_items-TOTAL_FORMS': 3,\n            'carousel_items-0-id': self.event_page.carousel_items.all()[0].id,\n            'carousel_items-0-caption': self.event_page.carousel_items.all()[0].caption,\n            'carousel_items-0-ORDER': 2,\n            'carousel_items-1-id': self.event_page.carousel_items.all()[1].id,\n            'carousel_items-1-caption': self.event_page.carousel_items.all()[1].caption,\n            'carousel_items-1-ORDER': 3,\n            'carousel_items-2-id': self.event_page.carousel_items.all()[2].id,\n            'carousel_items-2-caption': self.event_page.carousel_items.all()[2].caption,\n            'carousel_items-2-ORDER': 1,\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.event_page.id, )), post_data)\n\n        self.assertEqual(response.status_code, 200)\n        self.check_order(response, ['abcdefg', '1234567', '7654321'])\n\n\nclass TestIssue197(TestCase, WagtailTestUtils):\n    def test_issue_197(self):\n        # Find root page\n        self.root_page = Page.objects.get(id=2)\n\n        # Create a tagged page with no tags\n        self.tagged_page = self.root_page.add_child(instance=TaggedPage(\n            title=\"Tagged page\",\n            slug='tagged-page',\n            live=False,\n        ))\n\n        # Login\n        self.user = self.login()\n\n        # Add some tags and publish using edit view\n        post_data = {\n            'title': \"Tagged page\",\n            'slug': 'tagged-page',\n            'tags': \"hello, world\",\n            'action-publish': \"Publish\",\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.tagged_page.id, )), post_data)\n\n        # Should be redirected to explorer\n        self.assertRedirects(response, reverse('wagtailadmin_explore', args=(self.root_page.id, )))\n\n        # Check that both tags are in the pages tag set\n        page = TaggedPage.objects.get(id=self.tagged_page.id)\n        self.assertIn('hello', page.tags.slugs())\n        self.assertIn('world', page.tags.slugs())\n\n\nclass TestChildRelationsOnSuperclass(TestCase, WagtailTestUtils):\n    # In our test models we define AdvertPlacement as a child relation on the Page model.\n    # Here we check that this behaves correctly when exposed on the edit form of a Page\n    # subclass (StandardIndex here).\n    fixtures = ['test.json']\n\n    def setUp(self):\n        # Find root page\n        self.root_page = Page.objects.get(id=2)\n        self.test_advert = Advert.objects.get(id=1)\n\n        # Add child page\n        self.index_page = StandardIndex(\n            title=\"My lovely index\",\n            slug=\"my-lovely-index\",\n            advert_placements=[AdvertPlacement(advert=self.test_advert)]\n        )\n        self.root_page.add_child(instance=self.index_page)\n\n        # Login\n        self.login()\n\n    def test_get_create_form(self):\n        response = self.client.get(\n            reverse('wagtailadmin_pages:add', args=('tests', 'standardindex', self.root_page.id))\n        )\n        self.assertEqual(response.status_code, 200)\n        # Response should include an advert_placements formset labelled Adverts\n        self.assertContains(response, \"Adverts\")\n        self.assertContains(response, \"id_advert_placements-TOTAL_FORMS\")\n\n    def test_post_create_form(self):\n        post_data = {\n            'title': \"New index!\",\n            'slug': 'new-index',\n            'advert_placements-TOTAL_FORMS': '1',\n            'advert_placements-INITIAL_FORMS': '0',\n            'advert_placements-MAX_NUM_FORMS': '1000',\n            'advert_placements-0-advert': '1',\n            'advert_placements-0-colour': 'yellow',\n            'advert_placements-0-id': '',\n        }\n        response = self.client.post(\n            reverse('wagtailadmin_pages:add', args=('tests', 'standardindex', self.root_page.id)), post_data\n        )\n\n        # Find the page and check it\n        page = Page.objects.get(path__startswith=self.root_page.path, slug='new-index').specific\n\n        # Should be redirected to edit page\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=(page.id, )))\n\n        self.assertEqual(page.advert_placements.count(), 1)\n        self.assertEqual(page.advert_placements.first().advert.text, 'test_advert')\n\n    def test_post_create_form_with_validation_error_in_formset(self):\n        post_data = {\n            'title': \"New index!\",\n            'slug': 'new-index',\n            'advert_placements-TOTAL_FORMS': '1',\n            'advert_placements-INITIAL_FORMS': '0',\n            'advert_placements-MAX_NUM_FORMS': '1000',\n            'advert_placements-0-advert': '1',\n            'advert_placements-0-colour': '',  # should fail as colour is a required field\n            'advert_placements-0-id': '',\n        }\n        response = self.client.post(\n            reverse('wagtailadmin_pages:add', args=('tests', 'standardindex', self.root_page.id)), post_data\n        )\n\n        # Should remain on the edit page with a validation error\n        self.assertEqual(response.status_code, 200)\n        self.assertContains(response, \"This field is required.\")\n        # form should be marked as having unsaved changes\n        self.assertContains(response, \"alwaysDirty: true\")\n\n    def test_get_edit_form(self):\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=(self.index_page.id, )))\n        self.assertEqual(response.status_code, 200)\n\n        # Response should include an advert_placements formset labelled Adverts\n        self.assertContains(response, \"Adverts\")\n        self.assertContains(response, \"id_advert_placements-TOTAL_FORMS\")\n        # the formset should be populated with an existing form\n        self.assertContains(response, \"id_advert_placements-0-advert\")\n        self.assertContains(\n            response, '<option value=\"1\" selected=\"selected\">test_advert</option>', html=True\n        )\n\n    def test_post_edit_form(self):\n        post_data = {\n            'title': \"My lovely index\",\n            'slug': 'my-lovely-index',\n            'advert_placements-TOTAL_FORMS': '2',\n            'advert_placements-INITIAL_FORMS': '1',\n            'advert_placements-MAX_NUM_FORMS': '1000',\n            'advert_placements-0-advert': '1',\n            'advert_placements-0-colour': 'yellow',\n            'advert_placements-0-id': self.index_page.advert_placements.first().id,\n            'advert_placements-1-advert': '1',\n            'advert_placements-1-colour': 'purple',\n            'advert_placements-1-id': '',\n            'action-publish': \"Publish\",\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.index_page.id, )), post_data)\n\n        # Should be redirected to explorer\n        self.assertRedirects(response, reverse('wagtailadmin_explore', args=(self.root_page.id, )))\n\n        # Find the page and check it\n        page = Page.objects.get(id=self.index_page.id).specific\n        self.assertEqual(page.advert_placements.count(), 2)\n        self.assertEqual(page.advert_placements.all()[0].advert.text, 'test_advert')\n        self.assertEqual(page.advert_placements.all()[1].advert.text, 'test_advert')\n\n    def test_post_edit_form_with_validation_error_in_formset(self):\n        post_data = {\n            'title': \"My lovely index\",\n            'slug': 'my-lovely-index',\n            'advert_placements-TOTAL_FORMS': '1',\n            'advert_placements-INITIAL_FORMS': '1',\n            'advert_placements-MAX_NUM_FORMS': '1000',\n            'advert_placements-0-advert': '1',\n            'advert_placements-0-colour': '',\n            'advert_placements-0-id': self.index_page.advert_placements.first().id,\n            'action-publish': \"Publish\",\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=(self.index_page.id, )), post_data)\n\n        # Should remain on the edit page with a validation error\n        self.assertEqual(response.status_code, 200)\n        self.assertContains(response, \"This field is required.\")\n        # form should be marked as having unsaved changes\n        self.assertContains(response, \"alwaysDirty: true\")\n\n\nclass TestIssue2492(TestCase, WagtailTestUtils):\n    \"\"\"\n    The publication submission message generation was performed using\n    the Page class, as opposed to the specific_class for that Page.\n    This test ensures that the specific_class url method is called\n    when the 'view live' message button is created.\n    \"\"\"\n\n    def setUp(self):\n        self.root_page = Page.objects.get(id=2)\n        child_page = SingleEventPage(\n            title=\"Test Event\", slug=\"test-event\", location=\"test location\",\n            cost=\"10\", date_from=datetime.datetime.now(),\n            audience=EVENT_AUDIENCE_CHOICES[0][0])\n        self.root_page.add_child(instance=child_page)\n        child_page.save_revision().publish()\n        self.child_page = SingleEventPage.objects.get(id=child_page.id)\n        self.user = self.login()\n\n    def test_page_edit_post_publish_url(self):\n        post_data = {\n            'action-publish': \"Publish\",\n            'title': self.child_page.title,\n            'date_from': self.child_page.date_from,\n            'slug': self.child_page.slug,\n            'audience': self.child_page.audience,\n            'location': self.child_page.location,\n            'cost': self.child_page.cost,\n            'carousel_items-TOTAL_FORMS': 0,\n            'carousel_items-INITIAL_FORMS': 0,\n            'carousel_items-MIN_NUM_FORMS': 0,\n            'carousel_items-MAX_NUM_FORMS': 0,\n            'speakers-TOTAL_FORMS': 0,\n            'speakers-INITIAL_FORMS': 0,\n            'speakers-MIN_NUM_FORMS': 0,\n            'speakers-MAX_NUM_FORMS': 0,\n            'related_links-TOTAL_FORMS': 0,\n            'related_links-INITIAL_FORMS': 0,\n            'related_links-MIN_NUM_FORMS': 0,\n            'related_links-MAX_NUM_FORMS': 0,\n            'head_counts-TOTAL_FORMS': 0,\n            'head_counts-INITIAL_FORMS': 0,\n            'head_counts-MIN_NUM_FORMS': 0,\n            'head_counts-MAX_NUM_FORMS': 0,\n        }\n        response = self.client.post(\n            reverse('wagtailadmin_pages:edit', args=(self.child_page.id, )),\n            post_data, follow=True)\n\n        # Grab a fresh copy's URL\n        new_url = SingleEventPage.objects.get(id=self.child_page.id).url\n\n        # The \"View Live\" button should have the custom URL.\n        for message in response.context['messages']:\n            self.assertIn('\"{}\"'.format(new_url), message.message)\n            break\n\n\nclass TestIssue3982(TestCase, WagtailTestUtils):\n    \"\"\"\n    Pages that are not associated with a site, and thus do not have a live URL,\n    should not display a \"View live\" link in the flash message after being\n    edited.\n    \"\"\"\n\n    def setUp(self):\n        super().setUp()\n        self.login()\n\n    def _create_page(self, parent):\n        response = self.client.post(\n            reverse('wagtailadmin_pages:add', args=('tests', 'simplepage', parent.pk)),\n            {'title': \"Hello, world!\", 'content': \"Some content\", 'slug': 'hello-world', 'action-publish': \"publish\"},\n            follow=True)\n        self.assertRedirects(response, reverse('wagtailadmin_explore', args=(parent.pk,)))\n        page = SimplePage.objects.get()\n        self.assertTrue(page.live)\n        return response, page\n\n    def test_create_accessible(self):\n        \"\"\"\n        Create a page under the site root, check the flash message has a valid\n        \"View live\" button.\n        \"\"\"\n        response, page = self._create_page(Page.objects.get(pk=2))\n        self.assertIsNotNone(page.url)\n        self.assertTrue(any(\n            'View live' in message.message and page.url in message.message\n            for message in response.context['messages']))\n\n    def test_create_inaccessible(self):\n        \"\"\"\n        Create a page outside of the site root, check the flash message does\n        not have a \"View live\" button.\n        \"\"\"\n        response, page = self._create_page(Page.objects.get(pk=1))\n        self.assertIsNone(page.url)\n        self.assertFalse(any(\n            'View live' in message.message\n            for message in response.context['messages']))\n\n    def _edit_page(self, parent):\n        page = parent.add_child(instance=SimplePage(title='Hello, world!', content='Some content'))\n        response = self.client.post(\n            reverse('wagtailadmin_pages:edit', args=(page.pk,)),\n            {'title': \"Hello, world!\", 'content': \"Some content\", 'slug': 'hello-world', 'action-publish': \"publish\"},\n            follow=True)\n        self.assertRedirects(response, reverse('wagtailadmin_explore', args=(parent.pk,)))\n        page = SimplePage.objects.get(pk=page.pk)\n        self.assertTrue(page.live)\n        return response, page\n\n    def test_edit_accessible(self):\n        \"\"\"\n        Edit a page under the site root, check the flash message has a valid\n        \"View live\" button.\n        \"\"\"\n        response, page = self._edit_page(Page.objects.get(pk=2))\n        self.assertIsNotNone(page.url)\n        self.assertTrue(any(\n            'View live' in message.message and page.url in message.message\n            for message in response.context['messages']))\n\n    def test_edit_inaccessible(self):\n        \"\"\"\n        Edit a page outside of the site root, check the flash message does\n        not have a \"View live\" button.\n        \"\"\"\n        response, page = self._edit_page(Page.objects.get(pk=1))\n        self.assertIsNone(page.url)\n        self.assertFalse(any(\n            'View live' in message.message\n            for message in response.context['messages']))\n\n    def _approve_page(self, parent):\n        response = self.client.post(\n            reverse('wagtailadmin_pages:add', args=('tests', 'simplepage', parent.pk)),\n            {'title': \"Hello, world!\", 'content': \"Some content\", 'slug': 'hello-world'},\n            follow=True)\n        page = SimplePage.objects.get()\n        self.assertFalse(page.live)\n        revision = PageRevision.objects.get(page=page)\n        revision.submitted_for_moderation = True\n        revision.save()\n        response = self.client.post(reverse('wagtailadmin_pages:approve_moderation', args=(revision.pk,)), follow=True)\n        page = SimplePage.objects.get()\n        self.assertTrue(page.live)\n        self.assertRedirects(response, reverse('wagtailadmin_home'))\n        return response, page\n\n    def test_approve_accessible(self):\n        \"\"\"\n        Edit a page under the site root, check the flash message has a valid\n        \"View live\" button.\n        \"\"\"\n        response, page = self._approve_page(Page.objects.get(pk=2))\n        self.assertIsNotNone(page.url)\n        self.assertTrue(any(\n            'View live' in message.message and page.url in message.message\n            for message in response.context['messages']))\n\n    def test_approve_inaccessible(self):\n        \"\"\"\n        Edit a page outside of the site root, check the flash message does\n        not have a \"View live\" button.\n        \"\"\"\n        response, page = self._approve_page(Page.objects.get(pk=1))\n        self.assertIsNone(page.url)\n        self.assertFalse(any(\n            'View live' in message.message\n            for message in response.context['messages']))\n\n\nclass TestParentalM2M(TestCase, WagtailTestUtils):\n    fixtures = ['test.json']\n\n    def setUp(self):\n        self.events_index = Page.objects.get(url_path='/home/events/')\n        self.christmas_page = Page.objects.get(url_path='/home/events/christmas/')\n        self.user = self.login()\n        self.holiday_category = EventCategory.objects.create(name='Holiday')\n        self.men_with_beards_category = EventCategory.objects.create(name='Men with beards')\n\n    def test_create_and_save(self):\n        post_data = {\n            'title': \"Presidents' Day\",\n            'date_from': \"2017-02-20\",\n            'slug': \"presidents-day\",\n            'audience': \"public\",\n            'location': \"America\",\n            'cost': \"$1\",\n            'carousel_items-TOTAL_FORMS': 0,\n            'carousel_items-INITIAL_FORMS': 0,\n            'carousel_items-MIN_NUM_FORMS': 0,\n            'carousel_items-MAX_NUM_FORMS': 0,\n            'speakers-TOTAL_FORMS': 0,\n            'speakers-INITIAL_FORMS': 0,\n            'speakers-MIN_NUM_FORMS': 0,\n            'speakers-MAX_NUM_FORMS': 0,\n            'related_links-TOTAL_FORMS': 0,\n            'related_links-INITIAL_FORMS': 0,\n            'related_links-MIN_NUM_FORMS': 0,\n            'related_links-MAX_NUM_FORMS': 0,\n            'head_counts-TOTAL_FORMS': 0,\n            'head_counts-INITIAL_FORMS': 0,\n            'head_counts-MIN_NUM_FORMS': 0,\n            'head_counts-MAX_NUM_FORMS': 0,\n            'categories': [self.holiday_category.id, self.men_with_beards_category.id]\n        }\n        response = self.client.post(\n            reverse('wagtailadmin_pages:add', args=('tests', 'eventpage', self.events_index.id)),\n            post_data\n        )\n        created_page = EventPage.objects.get(url_path='/home/events/presidents-day/')\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=(created_page.id, )))\n        created_revision = created_page.get_latest_revision_as_page()\n\n        self.assertIn(self.holiday_category, created_revision.categories.all())\n        self.assertIn(self.men_with_beards_category, created_revision.categories.all())\n\n    def test_create_and_publish(self):\n        post_data = {\n            'action-publish': \"Publish\",\n            'title': \"Presidents' Day\",\n            'date_from': \"2017-02-20\",\n            'slug': \"presidents-day\",\n            'audience': \"public\",\n            'location': \"America\",\n            'cost': \"$1\",\n            'carousel_items-TOTAL_FORMS': 0,\n            'carousel_items-INITIAL_FORMS': 0,\n            'carousel_items-MIN_NUM_FORMS': 0,\n            'carousel_items-MAX_NUM_FORMS': 0,\n            'speakers-TOTAL_FORMS': 0,\n            'speakers-INITIAL_FORMS': 0,\n            'speakers-MIN_NUM_FORMS': 0,\n            'speakers-MAX_NUM_FORMS': 0,\n            'related_links-TOTAL_FORMS': 0,\n            'related_links-INITIAL_FORMS': 0,\n            'related_links-MIN_NUM_FORMS': 0,\n            'related_links-MAX_NUM_FORMS': 0,\n            'head_counts-TOTAL_FORMS': 0,\n            'head_counts-INITIAL_FORMS': 0,\n            'head_counts-MIN_NUM_FORMS': 0,\n            'head_counts-MAX_NUM_FORMS': 0,\n            'categories': [self.holiday_category.id, self.men_with_beards_category.id]\n        }\n        response = self.client.post(\n            reverse('wagtailadmin_pages:add', args=('tests', 'eventpage', self.events_index.id)),\n            post_data\n        )\n        self.assertRedirects(response, reverse('wagtailadmin_explore', args=(self.events_index.id, )))\n\n        created_page = EventPage.objects.get(url_path='/home/events/presidents-day/')\n        self.assertIn(self.holiday_category, created_page.categories.all())\n        self.assertIn(self.men_with_beards_category, created_page.categories.all())\n\n    def test_edit_and_save(self):\n        post_data = {\n            'title': \"Christmas\",\n            'date_from': \"2017-12-25\",\n            'slug': \"christmas\",\n            'audience': \"public\",\n            'location': \"The North Pole\",\n            'cost': \"Free\",\n            'carousel_items-TOTAL_FORMS': 0,\n            'carousel_items-INITIAL_FORMS': 0,\n            'carousel_items-MIN_NUM_FORMS': 0,\n            'carousel_items-MAX_NUM_FORMS': 0,\n            'speakers-TOTAL_FORMS': 0,\n            'speakers-INITIAL_FORMS': 0,\n            'speakers-MIN_NUM_FORMS': 0,\n            'speakers-MAX_NUM_FORMS': 0,\n            'related_links-TOTAL_FORMS': 0,\n            'related_links-INITIAL_FORMS': 0,\n            'related_links-MIN_NUM_FORMS': 0,\n            'related_links-MAX_NUM_FORMS': 0,\n            'head_counts-TOTAL_FORMS': 0,\n            'head_counts-INITIAL_FORMS': 0,\n            'head_counts-MIN_NUM_FORMS': 0,\n            'head_counts-MAX_NUM_FORMS': 0,\n            'categories': [self.holiday_category.id, self.men_with_beards_category.id]\n        }\n        response = self.client.post(\n            reverse('wagtailadmin_pages:edit', args=(self.christmas_page.id, )),\n            post_data\n        )\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=(self.christmas_page.id, )))\n        updated_page = EventPage.objects.get(id=self.christmas_page.id)\n        created_revision = updated_page.get_latest_revision_as_page()\n\n        self.assertIn(self.holiday_category, created_revision.categories.all())\n        self.assertIn(self.men_with_beards_category, created_revision.categories.all())\n\n        # no change to live page record yet\n        self.assertEqual(0, updated_page.categories.count())\n\n    def test_edit_and_publish(self):\n        post_data = {\n            'action-publish': \"Publish\",\n            'title': \"Christmas\",\n            'date_from': \"2017-12-25\",\n            'slug': \"christmas\",\n            'audience': \"public\",\n            'location': \"The North Pole\",\n            'cost': \"Free\",\n            'carousel_items-TOTAL_FORMS': 0,\n            'carousel_items-INITIAL_FORMS': 0,\n            'carousel_items-MIN_NUM_FORMS': 0,\n            'carousel_items-MAX_NUM_FORMS': 0,\n            'speakers-TOTAL_FORMS': 0,\n            'speakers-INITIAL_FORMS': 0,\n            'speakers-MIN_NUM_FORMS': 0,\n            'speakers-MAX_NUM_FORMS': 0,\n            'related_links-TOTAL_FORMS': 0,\n            'related_links-INITIAL_FORMS': 0,\n            'related_links-MIN_NUM_FORMS': 0,\n            'related_links-MAX_NUM_FORMS': 0,\n            'head_counts-TOTAL_FORMS': 0,\n            'head_counts-INITIAL_FORMS': 0,\n            'head_counts-MIN_NUM_FORMS': 0,\n            'head_counts-MAX_NUM_FORMS': 0,\n            'categories': [self.holiday_category.id, self.men_with_beards_category.id]\n        }\n        response = self.client.post(\n            reverse('wagtailadmin_pages:edit', args=(self.christmas_page.id, )),\n            post_data\n        )\n        self.assertRedirects(response, reverse('wagtailadmin_explore', args=(self.events_index.id, )))\n        updated_page = EventPage.objects.get(id=self.christmas_page.id)\n        self.assertEqual(2, updated_page.categories.count())\n        self.assertIn(self.holiday_category, updated_page.categories.all())\n        self.assertIn(self.men_with_beards_category, updated_page.categories.all())\n\n\nclass TestValidationErrorMessages(TestCase, WagtailTestUtils):\n    fixtures = ['test.json']\n\n    def setUp(self):\n        self.events_index = Page.objects.get(url_path='/home/events/')\n        self.christmas_page = Page.objects.get(url_path='/home/events/christmas/')\n        self.user = self.login()\n\n    def test_field_error(self):\n        \"\"\"Field errors should be shown against the relevant fields, not in the header message\"\"\"\n        post_data = {\n            'title': \"\",\n            'date_from': \"2017-12-25\",\n            'slug': \"christmas\",\n            'audience': \"public\",\n            'location': \"The North Pole\",\n            'cost': \"Free\",\n            'carousel_items-TOTAL_FORMS': 0,\n            'carousel_items-INITIAL_FORMS': 0,\n            'carousel_items-MIN_NUM_FORMS': 0,\n            'carousel_items-MAX_NUM_FORMS': 0,\n            'speakers-TOTAL_FORMS': 0,\n            'speakers-INITIAL_FORMS': 0,\n            'speakers-MIN_NUM_FORMS': 0,\n            'speakers-MAX_NUM_FORMS': 0,\n            'related_links-TOTAL_FORMS': 0,\n            'related_links-INITIAL_FORMS': 0,\n            'related_links-MIN_NUM_FORMS': 0,\n            'related_links-MAX_NUM_FORMS': 0,\n            'head_counts-TOTAL_FORMS': 0,\n            'head_counts-INITIAL_FORMS': 0,\n            'head_counts-MIN_NUM_FORMS': 0,\n            'head_counts-MAX_NUM_FORMS': 0,\n        }\n        response = self.client.post(\n            reverse('wagtailadmin_pages:edit', args=(self.christmas_page.id, )),\n            post_data\n        )\n        self.assertEqual(response.status_code, 200)\n\n        self.assertContains(response, \"The page could not be saved due to validation errors\")\n        # the error should only appear once: against the field, not in the header message\n        self.assertContains(response, \"\"\"<p class=\"error-message\"><span>This field is required.</span></p>\"\"\", count=1, html=True)\n        self.assertContains(response, \"This field is required\", count=1)\n\n    def test_non_field_error(self):\n        \"\"\"Non-field errors should be shown in the header message\"\"\"\n        post_data = {\n            'title': \"Christmas\",\n            'date_from': \"2017-12-25\",\n            'date_to': \"2017-12-24\",\n            'slug': \"christmas\",\n            'audience': \"public\",\n            'location': \"The North Pole\",\n            'cost': \"Free\",\n            'carousel_items-TOTAL_FORMS': 0,\n            'carousel_items-INITIAL_FORMS': 0,\n            'carousel_items-MIN_NUM_FORMS': 0,\n            'carousel_items-MAX_NUM_FORMS': 0,\n            'speakers-TOTAL_FORMS': 0,\n            'speakers-INITIAL_FORMS': 0,\n            'speakers-MIN_NUM_FORMS': 0,\n            'speakers-MAX_NUM_FORMS': 0,\n            'related_links-TOTAL_FORMS': 0,\n            'related_links-INITIAL_FORMS': 0,\n            'related_links-MIN_NUM_FORMS': 0,\n            'related_links-MAX_NUM_FORMS': 0,\n            'head_counts-TOTAL_FORMS': 0,\n            'head_counts-INITIAL_FORMS': 0,\n            'head_counts-MIN_NUM_FORMS': 0,\n            'head_counts-MAX_NUM_FORMS': 0,\n        }\n        response = self.client.post(\n            reverse('wagtailadmin_pages:edit', args=(self.christmas_page.id, )),\n            post_data\n        )\n        self.assertEqual(response.status_code, 200)\n\n        self.assertContains(response, \"The page could not be saved due to validation errors\")\n        self.assertContains(response, \"<li>The end date must be after the start date</li>\", count=1)\n\n    def test_field_and_non_field_error(self):\n        \"\"\"\n        If both field and non-field errors exist, all errors should be shown in the header message\n        with appropriate context to identify the field; and field errors should also be shown\n        against the relevant fields.\n        \"\"\"\n        post_data = {\n            'title': \"\",\n            'date_from': \"2017-12-25\",\n            'date_to': \"2017-12-24\",\n            'slug': \"christmas\",\n            'audience': \"public\",\n            'location': \"The North Pole\",\n            'cost': \"Free\",\n            'carousel_items-TOTAL_FORMS': 0,\n            'carousel_items-INITIAL_FORMS': 0,\n            'carousel_items-MIN_NUM_FORMS': 0,\n            'carousel_items-MAX_NUM_FORMS': 0,\n            'speakers-TOTAL_FORMS': 0,\n            'speakers-INITIAL_FORMS': 0,\n            'speakers-MIN_NUM_FORMS': 0,\n            'speakers-MAX_NUM_FORMS': 0,\n            'related_links-TOTAL_FORMS': 0,\n            'related_links-INITIAL_FORMS': 0,\n            'related_links-MIN_NUM_FORMS': 0,\n            'related_links-MAX_NUM_FORMS': 0,\n            'head_counts-TOTAL_FORMS': 0,\n            'head_counts-INITIAL_FORMS': 0,\n            'head_counts-MIN_NUM_FORMS': 0,\n            'head_counts-MAX_NUM_FORMS': 0,\n        }\n        response = self.client.post(\n            reverse('wagtailadmin_pages:edit', args=(self.christmas_page.id, )),\n            post_data\n        )\n        self.assertEqual(response.status_code, 200)\n\n        self.assertContains(response, \"The page could not be saved due to validation errors\")\n        self.assertContains(response, \"<li>The end date must be after the start date</li>\", count=1)\n\n        # Error on title shown against the title field\n        self.assertContains(response, \"\"\"<p class=\"error-message\"><span>This field is required.</span></p>\"\"\", count=1, html=True)\n        # Error on title shown in the header message\n        self.assertContains(response, \"<li>Title: This field is required.</li>\", count=1)\n\n\nclass TestNestedInlinePanel(TestCase, WagtailTestUtils):\n    fixtures = ['test.json']\n\n    def setUp(self):\n        self.events_index = Page.objects.get(url_path='/home/events/')\n        self.christmas_page = EventPage.objects.get(url_path='/home/events/christmas/')\n        self.speaker = self.christmas_page.speakers.first()\n        self.speaker.awards.create(\n            name=\"Beard Of The Year\", date_awarded=datetime.date(1997, 12, 25)\n        )\n        self.speaker.save()\n        self.user = self.login()\n\n    def test_get_edit_form(self):\n        response = self.client.get(\n            reverse('wagtailadmin_pages:edit', args=(self.christmas_page.id, ))\n        )\n        self.assertEqual(response.status_code, 200)\n        self.assertContains(\n            response,\n            \"\"\"<input type=\"text\" name=\"speakers-0-awards-0-name\" value=\"Beard Of The Year\" maxlength=\"255\" id=\"id_speakers-0-awards-0-name\">\"\"\",\n            count=1, html=True\n        )\n\n        # there should be no \"extra\" forms, as the nested formset should respect the extra_form_count=0 set on WagtailAdminModelForm\n        self.assertContains(\n            response,\n            \"\"\"<input type=\"hidden\" name=\"speakers-0-awards-TOTAL_FORMS\" value=\"1\" id=\"id_speakers-0-awards-TOTAL_FORMS\">\"\"\",\n            count=1, html=True\n        )\n        self.assertContains(\n            response,\n            \"\"\"<input type=\"text\" name=\"speakers-0-awards-1-name\" value=\"\" maxlength=\"255\" id=\"id_speakers-0-awards-1-name\">\"\"\",\n            count=0, html=True\n        )\n\n        # date field should use AdminDatePicker\n        self.assertContains(\n            response,\n            \"\"\"<input type=\"text\" name=\"speakers-0-awards-0-date_awarded\" value=\"1997-12-25\" autocomplete=\"off\" id=\"id_speakers-0-awards-0-date_awarded\">\"\"\",\n            count=1, html=True\n        )\n\n    def test_post_edit(self):\n        post_data = nested_form_data({\n            'title': \"Christmas\",\n            'date_from': \"2017-12-25\",\n            'date_to': \"2017-12-25\",\n            'slug': \"christmas\",\n            'audience': \"public\",\n            'location': \"The North Pole\",\n            'cost': \"Free\",\n            'carousel_items': inline_formset([]),\n            'speakers': inline_formset([\n                {\n                    'id': self.speaker.id,\n                    'first_name': \"Jeff\",\n                    'last_name': \"Christmas\",\n                    'awards': inline_formset([\n                        {\n                            'id': self.speaker.awards.first().id,\n                            'name': \"Beard Of The Century\",\n                            'date_awarded': \"1997-12-25\",\n                        },\n                        {\n                            'name': \"Bobsleigh Olympic gold medallist\",\n                            'date_awarded': \"2018-02-01\",\n                        },\n                    ], initial=1)\n                },\n            ], initial=1),\n            'related_links': inline_formset([]),\n            'head_counts': inline_formset([]),\n            'action-publish': \"Publish\",\n        })\n        response = self.client.post(\n            reverse('wagtailadmin_pages:edit', args=(self.christmas_page.id, )),\n            post_data\n        )\n        self.assertRedirects(response, reverse('wagtailadmin_explore', args=(self.events_index.id, )))\n\n        new_christmas_page = EventPage.objects.get(url_path='/home/events/christmas/')\n        self.assertEqual(new_christmas_page.speakers.first().first_name, \"Jeff\")\n        awards = new_christmas_page.speakers.first().awards.all()\n        self.assertEqual(len(awards), 2)\n        self.assertEqual(awards[0].name, \"Beard Of The Century\")\n        self.assertEqual(awards[1].name, \"Bobsleigh Olympic gold medallist\")\n\n\n@override_settings(WAGTAIL_I18N_ENABLED=True)\nclass TestLocaleSelector(TestCase, WagtailTestUtils):\n    fixtures = ['test.json']\n\n    def setUp(self):\n        self.christmas_page = EventPage.objects.get(url_path='/home/events/christmas/')\n        self.fr_locale = Locale.objects.create(language_code='fr')\n        self.translated_christmas_page = self.christmas_page.copy_for_translation(self.fr_locale, copy_parents=True)\n        self.user = self.login()\n\n    def test_locale_selector(self):\n        response = self.client.get(\n            reverse('wagtailadmin_pages:edit', args=[self.christmas_page.id])\n        )\n\n        self.assertContains(response, '<li class=\"header-meta--locale\">')\n\n        edit_translation_url = reverse('wagtailadmin_pages:edit', args=[self.translated_christmas_page.id])\n        self.assertContains(response, f'<a href=\"{edit_translation_url}\" aria-label=\"French\" class=\"u-link is-live\">')\n\n    @override_settings(WAGTAIL_I18N_ENABLED=False)\n    def test_locale_selector_not_present_when_i18n_disabled(self):\n        response = self.client.get(\n            reverse('wagtailadmin_pages:edit', args=[self.christmas_page.id])\n        )\n\n        self.assertNotContains(response, '<li class=\"header-meta--locale\">')\n\n        edit_translation_url = reverse('wagtailadmin_pages:edit', args=[self.translated_christmas_page.id])\n        self.assertNotContains(response, f'<a href=\"{edit_translation_url}\" aria-label=\"French\" class=\"u-link is-live\">')\n\n    def test_locale_dropdown_not_present_without_permission_to_edit(self):\n        # Remove user's permissions to edit French tree\n        en_events_index = Page.objects.get(url_path='/home/events/')\n        group = Group.objects.get(name='Moderators')\n        GroupPagePermission.objects.create(\n            group=group,\n            page=en_events_index,\n            permission_type='edit',\n        )\n        self.user.is_superuser = False\n        self.user.user_permissions.add(\n            Permission.objects.get(content_type__app_label='wagtailadmin', codename='access_admin')\n        )\n        self.user.groups.add(group)\n        self.user.save()\n\n        # Locale indicator should exist, but the \"French\" option should be hidden\n        response = self.client.get(\n            reverse('wagtailadmin_pages:edit', args=[self.christmas_page.id])\n        )\n\n        self.assertContains(response, '<li class=\"header-meta--locale\">')\n\n        edit_translation_url = reverse('wagtailadmin_pages:edit', args=[self.translated_christmas_page.id])\n        self.assertNotContains(response, f'<a href=\"{edit_translation_url}\" aria-label=\"French\" class=\"u-link is-live\">')\n\n\nclass TestPageSubscriptionSettings(TestCase, WagtailTestUtils):\n    def setUp(self):\n        # Find root page\n        self.root_page = Page.objects.get(id=2)\n\n        # Add child page\n        child_page = SimplePage(\n            title=\"Hello world!\",\n            slug=\"hello-world\",\n            content=\"hello\",\n        )\n        self.root_page.add_child(instance=child_page)\n        child_page.save_revision().publish()\n        self.child_page = SimplePage.objects.get(id=child_page.id)\n\n        # Login\n        self.user = self.login()\n\n    def test_commment_notifications_switched_off(self):\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))\n\n        self.assertEqual(response.status_code, 200)\n        self.assertContains(response, '<input type=\"checkbox\" name=\"comment_notifications\" id=\"id_comment_notifications\">')\n\n    def test_commment_notifications_switched_on(self):\n        PageSubscription.objects.create(\n            page=self.child_page,\n            user=self.user,\n            comment_notifications=True\n        )\n\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))\n\n        self.assertEqual(response.status_code, 200)\n        self.assertContains(response, '<input type=\"checkbox\" name=\"comment_notifications\" id=\"id_comment_notifications\" checked>')\n\n    def test_post_with_comment_notifications_switched_on(self):\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'comment_notifications': 'on'\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]), post_data)\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))\n\n        # Check the subscription\n        page = Page.objects.get(path__startswith=self.root_page.path, slug='hello-world').specific\n        subscription = page.subscribers.get()\n\n        self.assertEqual(subscription.user, self.user)\n        self.assertTrue(subscription.comment_notifications)\n\n    def test_post_with_comment_notifications_switched_off(self):\n        # Switch on comment notifications so we can test switching them off\n        subscription = PageSubscription.objects.create(\n            page=self.child_page,\n            user=self.user,\n            comment_notifications=True\n        )\n\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]), post_data)\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))\n\n        # Check the subscription\n        subscription.refresh_from_db()\n        self.assertFalse(subscription.comment_notifications)\n\n    @override_settings(WAGTAILADMIN_COMMENTS_ENABLED=False)\n    def test_comments_disabled(self):\n        response = self.client.get(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))\n\n        self.assertEqual(response.status_code, 200)\n        self.assertNotContains(response, '<input type=\"checkbox\" name=\"comment_notifications\" id=\"id_comment_notifications\">')\n\n    @override_settings(WAGTAILADMIN_COMMENTS_ENABLED=False)\n    def test_post_comments_disabled(self):\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'comment_notifications': 'on'  # Testing that this gets ignored\n        }\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]), post_data)\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))\n\n        # Check the subscription\n        self.assertFalse(PageSubscription.objects.get().comment_notifications)\n\n\nclass TestCommenting(TestCase, WagtailTestUtils):\n    \"\"\"\n    Tests both the comment notification and audit logging logic of the edit page view.\n    \"\"\"\n    def setUp(self):\n        # Find root page\n        self.root_page = Page.objects.get(id=2)\n\n        # Add child page\n        child_page = SimplePage(\n            title=\"Hello world!\",\n            slug=\"hello-world\",\n            content=\"hello\",\n        )\n        self.root_page.add_child(instance=child_page)\n        child_page.save_revision().publish()\n        self.child_page = SimplePage.objects.get(id=child_page.id)\n\n        # Login\n        self.user = self.login()\n\n        # Add a couple more users\n        self.subscriber = self.create_user('subscriber')\n        self.non_subscriber = self.create_user('non-subscriber')\n        self.non_subscriber_2 = self.create_user('non-subscriber-2')\n        self.never_emailed_user = self.create_user('never-emailed')\n\n        PageSubscription.objects.create(\n            page=self.child_page,\n            user=self.user,\n            comment_notifications=True\n        )\n\n        PageSubscription.objects.create(\n            page=self.child_page,\n            user=self.subscriber,\n            comment_notifications=True\n        )\n\n        # Add comment and reply on a different page for the never_emailed_user\n        # They should never be notified\n        comment_on_other_page = Comment.objects.create(\n            page=self.root_page,\n            user=self.never_emailed_user,\n            text='a comment'\n        )\n\n        CommentReply.objects.create(\n            user=self.never_emailed_user,\n            comment=comment_on_other_page,\n            text='a reply'\n        )\n\n    def assertNeverEmailedWrongUser(self):\n        self.assertNotIn(self.never_emailed_user.email, [to for email in mail.outbox for to in email.to])\n\n    def test_new_comment(self):\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'comments-TOTAL_FORMS': '1',\n            'comments-INITIAL_FORMS': '0',\n            'comments-MIN_NUM_FORMS': '0',\n            'comments-MAX_NUM_FORMS': '',\n            'comments-0-DELETE': '',\n            'comments-0-resolved': '',\n            'comments-0-id': '',\n            'comments-0-contentpath': 'title',\n            'comments-0-text': 'A test comment',\n            'comments-0-position': '',\n            'comments-0-replies-TOTAL_FORMS': '0',\n            'comments-0-replies-INITIAL_FORMS': '0',\n            'comments-0-replies-MIN_NUM_FORMS': '0',\n            'comments-0-replies-MAX_NUM_FORMS': '0'\n        }\n\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]), post_data)\n\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))\n\n        # Check the comment was added\n        comment = self.child_page.wagtail_admin_comments.get()\n        self.assertEqual(comment.text, 'A test comment')\n\n        # Check notification email\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertNeverEmailedWrongUser()\n        self.assertEqual(mail.outbox[0].to, [self.subscriber.email])\n        self.assertEqual(mail.outbox[0].subject, 'test@email.com has updated comments on \"I\\'ve been edited! (simple page)\"')\n        self.assertIn('New comments:\\n - \"A test comment\"\\n\\n', mail.outbox[0].body)\n\n        # Check audit log\n        log_entry = PageLogEntry.objects.get(action='wagtail.comments.create')\n        self.assertEqual(log_entry.page, self.child_page.page_ptr)\n        self.assertEqual(log_entry.user, self.user)\n        self.assertEqual(log_entry.revision, self.child_page.get_latest_revision())\n        self.assertEqual(log_entry.data['comment']['id'], comment.id)\n        self.assertEqual(log_entry.data['comment']['contentpath'], comment.contentpath)\n        self.assertEqual(log_entry.data['comment']['text'], comment.text)\n\n    def test_edit_comment(self):\n        comment = Comment.objects.create(\n            page=self.child_page,\n            user=self.user,\n            text=\"A test comment\",\n            contentpath=\"title\",\n        )\n\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'comments-TOTAL_FORMS': '1',\n            'comments-INITIAL_FORMS': '1',\n            'comments-MIN_NUM_FORMS': '0',\n            'comments-MAX_NUM_FORMS': '',\n            'comments-0-DELETE': '',\n            'comments-0-resolved': '',\n            'comments-0-id': str(comment.id),\n            'comments-0-contentpath': 'title',\n            'comments-0-text': 'Edited',\n            'comments-0-position': '',\n            'comments-0-replies-TOTAL_FORMS': '0',\n            'comments-0-replies-INITIAL_FORMS': '0',\n            'comments-0-replies-MIN_NUM_FORMS': '0',\n            'comments-0-replies-MAX_NUM_FORMS': '0'\n        }\n\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]), post_data)\n\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))\n\n        # Check the comment was edited\n        comment.refresh_from_db()\n        self.assertEqual(comment.text, 'Edited')\n\n        # No emails should be sent for edited comments\n        self.assertEqual(len(mail.outbox), 0)\n\n        # Check audit log\n        log_entry = PageLogEntry.objects.get(action='wagtail.comments.edit')\n        self.assertEqual(log_entry.page, self.child_page.page_ptr)\n        self.assertEqual(log_entry.user, self.user)\n        self.assertEqual(log_entry.revision, self.child_page.get_latest_revision())\n        self.assertEqual(log_entry.data['comment']['id'], comment.id)\n        self.assertEqual(log_entry.data['comment']['contentpath'], comment.contentpath)\n        self.assertEqual(log_entry.data['comment']['text'], comment.text)\n\n    def test_edit_another_users_comment(self):\n        comment = Comment.objects.create(\n            page=self.child_page,\n            user=self.subscriber,\n            text=\"A test comment\",\n            contentpath=\"title\",\n        )\n\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'comments-TOTAL_FORMS': '1',\n            'comments-INITIAL_FORMS': '1',\n            'comments-MIN_NUM_FORMS': '0',\n            'comments-MAX_NUM_FORMS': '',\n            'comments-0-DELETE': '',\n            'comments-0-resolved': '',\n            'comments-0-id': str(comment.id),\n            'comments-0-contentpath': 'title',\n            'comments-0-text': 'Edited',\n            'comments-0-position': '',\n            'comments-0-replies-TOTAL_FORMS': '0',\n            'comments-0-replies-INITIAL_FORMS': '0',\n            'comments-0-replies-MIN_NUM_FORMS': '0',\n            'comments-0-replies-MAX_NUM_FORMS': '0'\n        }\n\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]), post_data)\n\n        self.assertEqual(response.context['form'].formsets['comments'].errors, [{'__all__': [\"You cannot edit another user's comment.\"]}])\n\n        # Check the comment was not edited\n        comment.refresh_from_db()\n        self.assertNotEqual(comment.text, 'Edited')\n\n        # Check no log entry was created\n        self.assertFalse(PageLogEntry.objects.filter(action='wagtail.comments.edit').exists())\n\n    def test_resolve_comment(self):\n        comment = Comment.objects.create(\n            page=self.child_page,\n            user=self.non_subscriber,\n            text=\"A test comment\",\n            contentpath=\"title\",\n        )\n\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'comments-TOTAL_FORMS': '1',\n            'comments-INITIAL_FORMS': '1',\n            'comments-MIN_NUM_FORMS': '0',\n            'comments-MAX_NUM_FORMS': '',\n            'comments-0-DELETE': '',\n            'comments-0-resolved': 'on',\n            'comments-0-id': str(comment.id),\n            'comments-0-contentpath': 'title',\n            'comments-0-text': 'A test comment',\n            'comments-0-position': '',\n            'comments-0-replies-TOTAL_FORMS': '0',\n            'comments-0-replies-INITIAL_FORMS': '0',\n            'comments-0-replies-MIN_NUM_FORMS': '0',\n            'comments-0-replies-MAX_NUM_FORMS': '0'\n        }\n\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]), post_data)\n\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))\n\n        # Check the comment was resolved\n        comment.refresh_from_db()\n        self.assertTrue(comment.resolved_at)\n        self.assertEqual(comment.resolved_by, self.user)\n\n        # Check notification email\n        self.assertEqual(len(mail.outbox), 2)\n        self.assertNeverEmailedWrongUser()\n        # The non subscriber created the comment, so should also get an email\n        self.assertEqual(mail.outbox[0].to, [self.non_subscriber.email])\n        self.assertEqual(mail.outbox[0].subject, 'test@email.com has updated comments on \"I\\'ve been edited! (simple page)\"')\n        self.assertIn('Resolved comments:\\n - \"A test comment\"\\n\\n', mail.outbox[0].body)\n        self.assertEqual(mail.outbox[1].to, [self.subscriber.email])\n        self.assertEqual(mail.outbox[1].subject, 'test@email.com has updated comments on \"I\\'ve been edited! (simple page)\"')\n        self.assertIn('Resolved comments:\\n - \"A test comment\"\\n\\n', mail.outbox[1].body)\n\n        # Check audit log\n        log_entry = PageLogEntry.objects.get(action='wagtail.comments.resolve')\n        self.assertEqual(log_entry.page, self.child_page.page_ptr)\n        self.assertEqual(log_entry.user, self.user)\n        self.assertEqual(log_entry.revision, self.child_page.get_latest_revision())\n        self.assertEqual(log_entry.data['comment']['id'], comment.id)\n        self.assertEqual(log_entry.data['comment']['contentpath'], comment.contentpath)\n        self.assertEqual(log_entry.data['comment']['text'], comment.text)\n\n    def test_delete_comment(self):\n        comment = Comment.objects.create(\n            page=self.child_page,\n            user=self.user,\n            text=\"A test comment\",\n            contentpath=\"title\",\n        )\n\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'comments-TOTAL_FORMS': '1',\n            'comments-INITIAL_FORMS': '1',\n            'comments-MIN_NUM_FORMS': '0',\n            'comments-MAX_NUM_FORMS': '',\n            'comments-0-DELETE': 'on',\n            'comments-0-resolved': '',\n            'comments-0-id': str(comment.id),\n            'comments-0-contentpath': 'title',\n            'comments-0-text': 'A test comment',\n            'comments-0-position': '',\n            'comments-0-replies-TOTAL_FORMS': '0',\n            'comments-0-replies-INITIAL_FORMS': '0',\n            'comments-0-replies-MIN_NUM_FORMS': '0',\n            'comments-0-replies-MAX_NUM_FORMS': '0'\n        }\n\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]), post_data)\n\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))\n\n        # Check the comment was deleted\n        self.assertFalse(self.child_page.wagtail_admin_comments.exists())\n\n        # Check notification email\n        self.assertEqual(len(mail.outbox), 1)\n        self.assertNeverEmailedWrongUser()\n        self.assertEqual(mail.outbox[0].to, [self.subscriber.email])\n        self.assertEqual(mail.outbox[0].subject, 'test@email.com has updated comments on \"I\\'ve been edited! (simple page)\"')\n        self.assertIn('Deleted comments:\\n - \"A test comment\"\\n\\n', mail.outbox[0].body)\n\n        # Check audit log\n        log_entry = PageLogEntry.objects.get(action='wagtail.comments.delete')\n        self.assertEqual(log_entry.page, self.child_page.page_ptr)\n        self.assertEqual(log_entry.user, self.user)\n        self.assertEqual(log_entry.revision, self.child_page.get_latest_revision())\n        self.assertEqual(log_entry.data['comment']['id'], comment.id)\n        self.assertEqual(log_entry.data['comment']['contentpath'], comment.contentpath)\n        self.assertEqual(log_entry.data['comment']['text'], comment.text)\n\n    def test_new_reply(self):\n        comment = Comment.objects.create(\n            page=self.child_page,\n            user=self.non_subscriber,\n            text=\"A test comment\",\n            contentpath=\"title\",\n        )\n\n        reply = CommentReply.objects.create(\n            comment=comment,\n            user=self.non_subscriber_2,\n            text='an old reply'\n        )\n\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'comments-TOTAL_FORMS': '1',\n            'comments-INITIAL_FORMS': '1',\n            'comments-MIN_NUM_FORMS': '0',\n            'comments-MAX_NUM_FORMS': '',\n            'comments-0-DELETE': '',\n            'comments-0-resolved': '',\n            'comments-0-id': str(comment.id),\n            'comments-0-contentpath': 'title',\n            'comments-0-text': 'A test comment',\n            'comments-0-position': '',\n            'comments-0-replies-TOTAL_FORMS': '2',\n            'comments-0-replies-INITIAL_FORMS': '1',\n            'comments-0-replies-MIN_NUM_FORMS': '0',\n            'comments-0-replies-MAX_NUM_FORMS': '',\n            'comments-0-replies-0-id': str(reply.id),\n            'comments-0-replies-0-text': 'an old reply',\n            'comments-0-replies-1-id': '',\n            'comments-0-replies-1-text': 'a new reply'\n        }\n\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]), post_data)\n\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))\n\n        # Check the comment reply was added\n        comment.refresh_from_db()\n        self.assertEqual(comment.replies.last().text, 'a new reply')\n\n        # Check notification email\n        self.assertEqual(len(mail.outbox), 3)\n        self.assertNeverEmailedWrongUser()\n\n        recipients = [mail.to for mail in mail.outbox]\n        # The other non subscriber replied in the thread, so should get an email\n        self.assertIn([self.non_subscriber_2.email], recipients)\n\n        # The non subscriber created the comment, so should get an email\n        self.assertIn([self.non_subscriber.email], recipients)\n\n        self.assertIn([self.subscriber.email], recipients)\n        self.assertEqual(mail.outbox[2].subject, 'test@email.com has updated comments on \"I\\'ve been edited! (simple page)\"')\n        self.assertIn('  New replies to: \"A test comment\"\\n   - \"a new reply\"', mail.outbox[2].body)\n\n        # Check audit log\n        log_entry = PageLogEntry.objects.get(action='wagtail.comments.create_reply')\n        self.assertEqual(log_entry.page, self.child_page.page_ptr)\n        self.assertEqual(log_entry.user, self.user)\n        self.assertEqual(log_entry.revision, self.child_page.get_latest_revision())\n        self.assertEqual(log_entry.data['comment']['id'], comment.id)\n        self.assertEqual(log_entry.data['comment']['contentpath'], comment.contentpath)\n        self.assertEqual(log_entry.data['comment']['text'], comment.text)\n        self.assertNotEqual(log_entry.data['reply']['id'], reply.id)\n        self.assertEqual(log_entry.data['reply']['text'], 'a new reply')\n\n    def test_edit_reply(self):\n        comment = Comment.objects.create(\n            page=self.child_page,\n            user=self.non_subscriber,\n            text=\"A test comment\",\n            contentpath=\"title\",\n        )\n\n        reply = CommentReply.objects.create(\n            comment=comment,\n            user=self.user,\n            text='an old reply'\n        )\n\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'comments-TOTAL_FORMS': '1',\n            'comments-INITIAL_FORMS': '1',\n            'comments-MIN_NUM_FORMS': '0',\n            'comments-MAX_NUM_FORMS': '',\n            'comments-0-DELETE': '',\n            'comments-0-resolved': '',\n            'comments-0-id': str(comment.id),\n            'comments-0-contentpath': 'title',\n            'comments-0-text': 'A test comment',\n            'comments-0-position': '',\n            'comments-0-replies-TOTAL_FORMS': '1',\n            'comments-0-replies-INITIAL_FORMS': '1',\n            'comments-0-replies-MIN_NUM_FORMS': '0',\n            'comments-0-replies-MAX_NUM_FORMS': '',\n            'comments-0-replies-0-id': str(reply.id),\n            'comments-0-replies-0-text': 'an edited reply',\n        }\n\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]), post_data)\n\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))\n\n        # Check the comment reply was edited\n        reply.refresh_from_db()\n        self.assertEqual(reply.text, 'an edited reply')\n\n        # Check no notification was sent\n        self.assertEqual(len(mail.outbox), 0)\n\n        # Check audit log\n        log_entry = PageLogEntry.objects.get(action='wagtail.comments.edit_reply')\n        self.assertEqual(log_entry.page, self.child_page.page_ptr)\n        self.assertEqual(log_entry.user, self.user)\n        self.assertEqual(log_entry.revision, self.child_page.get_latest_revision())\n        self.assertEqual(log_entry.data['comment']['id'], comment.id)\n        self.assertEqual(log_entry.data['comment']['contentpath'], comment.contentpath)\n        self.assertEqual(log_entry.data['comment']['text'], comment.text)\n        self.assertEqual(log_entry.data['reply']['id'], reply.id)\n        self.assertEqual(log_entry.data['reply']['text'], 'an edited reply')\n\n    def test_delete_reply(self):\n        comment = Comment.objects.create(\n            page=self.child_page,\n            user=self.non_subscriber,\n            text=\"A test comment\",\n            contentpath=\"title\",\n        )\n\n        reply = CommentReply.objects.create(\n            comment=comment,\n            user=self.user,\n            text='an old reply'\n        )\n\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'comments-TOTAL_FORMS': '1',\n            'comments-INITIAL_FORMS': '1',\n            'comments-MIN_NUM_FORMS': '0',\n            'comments-MAX_NUM_FORMS': '',\n            'comments-0-DELETE': '',\n            'comments-0-resolved': '',\n            'comments-0-id': str(comment.id),\n            'comments-0-contentpath': 'title',\n            'comments-0-text': 'A test comment',\n            'comments-0-position': '',\n            'comments-0-replies-TOTAL_FORMS': '1',\n            'comments-0-replies-INITIAL_FORMS': '1',\n            'comments-0-replies-MIN_NUM_FORMS': '0',\n            'comments-0-replies-MAX_NUM_FORMS': '',\n            'comments-0-replies-0-id': str(reply.id),\n            'comments-0-replies-0-text': 'an old reply',\n            'comments-0-replies-0-DELETE': 'on',\n        }\n\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]), post_data)\n\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))\n\n        # Check the comment reply was deleted\n        self.assertFalse(comment.replies.exists())\n\n        # Check no notification was sent\n        self.assertEqual(len(mail.outbox), 0)\n\n        # Check audit log\n        log_entry = PageLogEntry.objects.get(action='wagtail.comments.delete_reply')\n        self.assertEqual(log_entry.page, self.child_page.page_ptr)\n        self.assertEqual(log_entry.user, self.user)\n        self.assertEqual(log_entry.revision, self.child_page.get_latest_revision())\n        self.assertEqual(log_entry.data['comment']['id'], comment.id)\n        self.assertEqual(log_entry.data['comment']['contentpath'], comment.contentpath)\n        self.assertEqual(log_entry.data['comment']['text'], comment.text)\n        self.assertEqual(log_entry.data['reply']['id'], reply.id)\n        self.assertEqual(log_entry.data['reply']['text'], reply.text)\n\n    def test_updated_comments_notifications_profile_setting(self):\n        # Users can disable commenting notifications globally from account settings\n        profile = UserProfile.get_for_user(self.subscriber)\n        profile.updated_comments_notifications = False\n        profile.save()\n\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'comments-TOTAL_FORMS': '1',\n            'comments-INITIAL_FORMS': '0',\n            'comments-MIN_NUM_FORMS': '0',\n            'comments-MAX_NUM_FORMS': '',\n            'comments-0-DELETE': '',\n            'comments-0-resolved': '',\n            'comments-0-id': '',\n            'comments-0-contentpath': 'title',\n            'comments-0-text': 'A test comment',\n            'comments-0-position': '',\n            'comments-0-replies-TOTAL_FORMS': '0',\n            'comments-0-replies-INITIAL_FORMS': '0',\n            'comments-0-replies-MIN_NUM_FORMS': '0',\n            'comments-0-replies-MAX_NUM_FORMS': '0'\n        }\n\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]), post_data)\n\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))\n\n        # Check the comment was added\n        comment = self.child_page.wagtail_admin_comments.get()\n        self.assertEqual(comment.text, 'A test comment')\n\n        # This time, no emails should be submitted because the only subscriber has disabled these emails globally\n        self.assertEqual(len(mail.outbox), 0)\n\n    def test_updated_comments_notifications_active_users_only(self):\n        # subscriber is inactive\n        self.subscriber.is_active = False\n        self.subscriber.save()\n\n        post_data = {\n            'title': \"I've been edited!\",\n            'content': \"Some content\",\n            'slug': 'hello-world',\n            'comments-TOTAL_FORMS': '1',\n            'comments-INITIAL_FORMS': '0',\n            'comments-MIN_NUM_FORMS': '0',\n            'comments-MAX_NUM_FORMS': '',\n            'comments-0-DELETE': '',\n            'comments-0-resolved': '',\n            'comments-0-id': '',\n            'comments-0-contentpath': 'title',\n            'comments-0-text': 'A test comment',\n            'comments-0-position': '',\n            'comments-0-replies-TOTAL_FORMS': '0',\n            'comments-0-replies-INITIAL_FORMS': '0',\n            'comments-0-replies-MIN_NUM_FORMS': '0',\n            'comments-0-replies-MAX_NUM_FORMS': '0'\n        }\n\n        response = self.client.post(reverse('wagtailadmin_pages:edit', args=[self.child_page.id]), post_data)\n\n        self.assertRedirects(response, reverse('wagtailadmin_pages:edit', args=[self.child_page.id]))\n\n        # Check the comment was added\n        comment = self.child_page.wagtail_admin_comments.get()\n        self.assertEqual(comment.text, 'A test comment')\n\n        # No emails should be submitted because subscriber is inactive\n        self.assertEqual(len(mail.outbox), 0)\n", "import json\n\nfrom urllib.parse import quote\n\nfrom django.conf import settings\nfrom django.contrib.auth import get_user_model\nfrom django.core.exceptions import PermissionDenied\nfrom django.db.models import Prefetch, Q\nfrom django.http import HttpResponse\nfrom django.shortcuts import get_object_or_404, redirect\nfrom django.urls import reverse\nfrom django.utils import timezone\nfrom django.utils.html import format_html\nfrom django.utils.safestring import mark_safe\nfrom django.utils.translation import gettext as _\nfrom django.views.generic.base import ContextMixin, TemplateResponseMixin, View\n\nfrom wagtail.admin import messages\nfrom wagtail.admin.action_menu import PageActionMenu\nfrom wagtail.admin.mail import send_notification\nfrom wagtail.admin.views.generic import HookResponseMixin\nfrom wagtail.admin.views.pages.utils import get_valid_next_url_from_request\nfrom wagtail.core.actions.publish_page_revision import PublishPageRevisionAction\nfrom wagtail.core.exceptions import PageClassNotFoundError\nfrom wagtail.core.models import (\n    COMMENTS_RELATION_NAME, Comment, CommentReply, Page, PageSubscription, UserPagePermissionsProxy,\n    WorkflowState)\n\n\nclass EditView(TemplateResponseMixin, ContextMixin, HookResponseMixin, View):\n    def get_template_names(self):\n        if self.page.alias_of_id:\n            return ['wagtailadmin/pages/edit_alias.html']\n\n        else:\n            return ['wagtailadmin/pages/edit.html']\n\n    def add_legacy_moderation_warning(self):\n        # Check for revisions still undergoing moderation and warn - this is for the old moderation system\n        if self.latest_revision and self.latest_revision.submitted_for_moderation:\n            buttons = []\n\n            if self.page.live:\n                buttons.append(self.get_compare_with_live_message_button())\n\n            messages.warning(self.request, _(\"This page is currently awaiting moderation\"), buttons=buttons)\n\n    def add_save_confirmation_message(self):\n        if self.is_reverting:\n            message = _(\n                \"Page '{0}' has been replaced with version from {1}.\"\n            ).format(\n                self.page.get_admin_display_title(),\n                self.previous_revision.created_at.strftime(\"%d %b %Y %H:%M\")\n            )\n        else:\n            message = _(\n                \"Page '{0}' has been updated.\"\n            ).format(\n                self.page.get_admin_display_title()\n            )\n\n        messages.success(self.request, message)\n\n    def get_commenting_changes(self):\n        \"\"\"\n        Finds comments that have been changed during this request.\n\n        Returns a tuple of 5 lists:\n         - New comments\n         - Deleted comments\n         - Resolved comments\n         - Edited comments\n         - Replied comments (dict containing the instance and list of replies)\n        \"\"\"\n        # Get changes\n        comments_formset = self.form.formsets['comments']\n        new_comments = comments_formset.new_objects\n        deleted_comments = comments_formset.deleted_objects\n\n        # Assume any changed comments that are resolved were only just resolved\n        resolved_comments = []\n        edited_comments = []\n        for changed_comment, changed_fields in comments_formset.changed_objects:\n            if changed_comment.resolved_at and 'resolved' in changed_fields:\n                resolved_comments.append(changed_comment)\n\n            if 'text' in changed_fields:\n                edited_comments.append(changed_comment)\n\n        new_replies = []\n        deleted_replies = []\n        edited_replies = []\n        for comment_form in comments_formset.forms:\n            # New\n            replies = getattr(comment_form.formsets['replies'], 'new_objects', [])\n            if replies:\n                new_replies.append((comment_form.instance, replies))\n\n            # Deleted\n            replies = getattr(comment_form.formsets['replies'], 'deleted_objects', [])\n            if replies:\n                deleted_replies.append((comment_form.instance, replies))\n\n            # Edited\n            replies = getattr(comment_form.formsets['replies'], 'changed_objects', [])\n            replies = [reply for reply, changed_fields in replies if 'text' in changed_fields]\n            if replies:\n                edited_replies.append((comment_form.instance, replies))\n\n        return {\n            'new_comments': new_comments,\n            'deleted_comments': deleted_comments,\n            'resolved_comments': resolved_comments,\n            'edited_comments': edited_comments,\n            'new_replies': new_replies,\n            'deleted_replies': deleted_replies,\n            'edited_replies': edited_replies,\n        }\n\n    def send_commenting_notifications(self, changes):\n        \"\"\"\n        Sends notifications about any changes to comments to anyone who is subscribed.\n        \"\"\"\n        relevant_comment_ids = []\n        relevant_comment_ids.extend(comment.pk for comment in changes['resolved_comments'])\n        relevant_comment_ids.extend(comment.pk for comment, replies in changes['new_replies'])\n\n        # Skip if no changes were made\n        # Note: We don't email about edited comments so ignore those here\n        if (not changes['new_comments']\n                and not changes['deleted_comments']\n                and not changes['resolved_comments']\n                and not changes['new_replies']):\n            return\n\n        # Get global page comment subscribers\n        subscribers = PageSubscription.objects.filter(page=self.page, comment_notifications=True).select_related('user')\n        global_recipient_users = [subscriber.user for subscriber in subscribers if subscriber.user != self.request.user]\n\n        # Get subscribers to individual threads\n        replies = CommentReply.objects.filter(comment_id__in=relevant_comment_ids)\n        comments = Comment.objects.filter(id__in=relevant_comment_ids)\n        thread_users = get_user_model().objects.exclude(pk=self.request.user.pk).exclude(pk__in=subscribers.values_list('user_id', flat=True)).filter(\n            Q(comment_replies__comment_id__in=relevant_comment_ids) | Q(**{('%s__pk__in' % COMMENTS_RELATION_NAME): relevant_comment_ids})\n        ).prefetch_related(\n            Prefetch('comment_replies', queryset=replies),\n            Prefetch(COMMENTS_RELATION_NAME, queryset=comments)\n        )\n\n        # Skip if no recipients\n        if not (global_recipient_users or thread_users):\n            return\n        thread_users = [(user, set(list(user.comment_replies.values_list('comment_id', flat=True)) + list(getattr(user, COMMENTS_RELATION_NAME).values_list('pk', flat=True)))) for user in thread_users]\n        mailed_users = set()\n\n        for current_user, current_threads in thread_users:\n            # We are trying to avoid calling send_notification for each user for performance reasons\n            # so group the users receiving the same thread notifications together here\n            if current_user in mailed_users:\n                continue\n            users = [current_user]\n            mailed_users.add(current_user)\n            for user, threads in thread_users:\n                if user not in mailed_users and threads == current_threads:\n                    users.append(user)\n                    mailed_users.add(user)\n            send_notification(users, 'updated_comments', {\n                'page': self.page,\n                'editor': self.request.user,\n                'new_comments': [comment for comment in changes['new_comments'] if comment.pk in threads],\n                'resolved_comments': [comment for comment in changes['resolved_comments'] if comment.pk in threads],\n                'deleted_comments': [],\n                'replied_comments': [\n                    {\n                        'comment': comment,\n                        'replies': replies,\n                    }\n                    for comment, replies in changes['new_replies']\n                    if comment.pk in threads\n                ]\n            })\n\n        return send_notification(global_recipient_users, 'updated_comments', {\n            'page': self.page,\n            'editor': self.request.user,\n            'new_comments': changes['new_comments'],\n            'resolved_comments': changes['resolved_comments'],\n            'deleted_comments': changes['deleted_comments'],\n            'replied_comments': [\n                {\n                    'comment': comment,\n                    'replies': replies,\n                }\n                for comment, replies in changes['new_replies']\n            ]\n        })\n\n    def log_commenting_changes(self, changes, revision):\n        \"\"\"\n        Generates log entries for any changes made to comments or replies.\n        \"\"\"\n        for comment in changes['new_comments']:\n            comment.log_create(\n                page_revision=revision,\n                user=self.request.user\n            )\n\n        for comment in changes['edited_comments']:\n            comment.log_edit(\n                page_revision=revision,\n                user=self.request.user\n            )\n\n        for comment in changes['resolved_comments']:\n            comment.log_resolve(\n                page_revision=revision,\n                user=self.request.user\n            )\n\n        for comment in changes['deleted_comments']:\n            comment.log_delete(\n                page_revision=revision,\n                user=self.request.user\n            )\n\n        for comment, replies in changes['new_replies']:\n            for reply in replies:\n                reply.log_create(\n                    page_revision=revision,\n                    user=self.request.user\n                )\n\n        for comment, replies in changes['edited_replies']:\n            for reply in replies:\n                reply.log_edit(\n                    page_revision=revision,\n                    user=self.request.user\n                )\n\n        for comment, replies in changes['deleted_replies']:\n            for reply in replies:\n                reply.log_delete(\n                    page_revision=revision,\n                    user=self.request.user\n                )\n\n    def get_edit_message_button(self):\n        return messages.button(\n            reverse('wagtailadmin_pages:edit', args=(self.page.id,)),\n            _('Edit')\n        )\n\n    def get_view_draft_message_button(self):\n        return messages.button(\n            reverse('wagtailadmin_pages:view_draft', args=(self.page.id,)),\n            _('View draft'),\n            new_window=False\n        )\n\n    def get_view_live_message_button(self):\n        return messages.button(self.page.url, _('View live'), new_window=False)\n\n    def get_compare_with_live_message_button(self):\n        return messages.button(\n            reverse('wagtailadmin_pages:revisions_compare', args=(self.page.id, 'live', self.latest_revision.id)),\n            _('Compare with live version')\n        )\n\n    def get_page_for_status(self):\n        if self.page.live and self.page.has_unpublished_changes:\n            # Page status needs to present the version of the page containing the correct live URL\n            return self.real_page_record.specific\n        else:\n            return self.page\n\n    def dispatch(self, request, page_id):\n        self.real_page_record = get_object_or_404(Page, id=page_id)\n        self.latest_revision = self.real_page_record.get_latest_revision()\n        self.page_content_type = self.real_page_record.cached_content_type\n        self.page_class = self.real_page_record.specific_class\n\n        if self.page_class is None:\n            raise PageClassNotFoundError(\n                f\"The page '{self.real_page_record}' cannot be edited because the \"\n                f\"model class used to create it ({self.page_content_type.app_label}.\"\n                f\"{self.page_content_type.model}) can no longer be found in the codebase. \"\n                \"This usually happens as a result of switching between git \"\n                \"branches without running migrations to trigger the removal of \"\n                \"unused ContentTypes. To edit the page, you will need to switch \"\n                \"back to a branch where the model class is still present.\"\n            )\n\n        self.page = self.real_page_record.get_latest_revision_as_page()\n        self.parent = self.page.get_parent()\n\n        self.page_perms = self.page.permissions_for_user(self.request.user)\n\n        if not self.page_perms.can_edit():\n            raise PermissionDenied\n\n        self.next_url = get_valid_next_url_from_request(self.request)\n\n        response = self.run_hook('before_edit_page', self.request, self.page)\n        if response:\n            return response\n\n        try:\n            self.subscription = PageSubscription.objects.get(page=self.page, user=self.request.user)\n        except PageSubscription.DoesNotExist:\n            self.subscription = PageSubscription(page=self.page, user=self.request.user, comment_notifications=False)\n\n        self.edit_handler = self.page_class.get_edit_handler()\n        self.edit_handler = self.edit_handler.bind_to(instance=self.page, request=self.request)\n        self.form_class = self.edit_handler.get_form_class()\n\n        if getattr(settings, 'WAGTAIL_WORKFLOW_ENABLED', True):\n            # Retrieve current workflow state if set, default to last workflow state\n            self.workflow_state = self.page.current_workflow_state or self.page.workflow_states.order_by('created_at').last()\n        else:\n            self.workflow_state = None\n\n        if self.workflow_state:\n            self.workflow_tasks = self.workflow_state.all_tasks_with_status()\n        else:\n            self.workflow_tasks = []\n\n        self.errors_debug = None\n\n        return super().dispatch(request)\n\n    def get(self, request):\n        if self.page_perms.user_has_lock():\n            if self.page.locked_at:\n                lock_message = format_html(_(\"<b>Page '{}' was locked</b> by <b>you</b> on <b>{}</b>.\"), self.page.get_admin_display_title(), self.page.locked_at.strftime(\"%d %b %Y %H:%M\"))\n            else:\n                lock_message = format_html(_(\"<b>Page '{}' is locked</b> by <b>you</b>.\"), self.page.get_admin_display_title())\n\n            lock_message += format_html(\n                '<span class=\"buttons\"><button class=\"button button-small button-secondary\" data-locking-action=\"{}\">{}</button></span>',\n                reverse('wagtailadmin_pages:unlock', args=(self.page.id,)),\n                _(\"Unlock\")\n            )\n            messages.warning(self.request, lock_message, extra_tags='lock')\n\n        elif self.page.locked and self.page_perms.page_locked():\n            # the page can also be locked at a permissions level if in a workflow, on a task the user is not a reviewer for\n            # this should be indicated separately\n            if self.page.locked_by and self.page.locked_at:\n                lock_message = format_html(_(\"<b>Page '{}' was locked</b> by <b>{}</b> on <b>{}</b>.\"), self.page.get_admin_display_title(), str(self.page.locked_by), self.page.locked_at.strftime(\"%d %b %Y %H:%M\"))\n            else:\n                # Page was probably locked with an old version of Wagtail, or a script\n                lock_message = format_html(_(\"<b>Page '{}' is locked</b>.\"), self.page.get_admin_display_title())\n\n            if self.page_perms.can_unlock():\n                lock_message += format_html(\n                    '<span class=\"buttons\"><button class=\"button button-small button-secondary\" data-locking-action=\"{}\">{}</button></span>',\n                    reverse('wagtailadmin_pages:unlock', args=(self.page.id,)),\n                    _(\"Unlock\")\n                )\n            messages.error(self.request, lock_message, extra_tags='lock')\n\n        if self.page.current_workflow_state:\n            workflow = self.workflow_state.workflow\n            task = self.workflow_state.current_task_state.task\n            if (\n                self.workflow_state.status != WorkflowState.STATUS_NEEDS_CHANGES\n                and task.specific.page_locked_for_user(self.page, self.request.user)\n            ):\n                # Check for revisions still undergoing moderation and warn\n                if len(self.workflow_tasks) == 1:\n                    # If only one task in workflow, show simple message\n                    workflow_info = _(\"This page is currently awaiting moderation.\")\n                else:\n                    workflow_info = format_html(\n                        _(\"This page is awaiting <b>'{}'</b> in the <b>'{}'</b> workflow.\"),\n                        task.name, workflow.name\n                    )\n                messages.error(\n                    self.request, mark_safe(workflow_info + \" \" + _(\"Only reviewers for this task can edit the page.\")),\n                    extra_tags=\"lock\"\n                )\n\n        self.form = self.form_class(instance=self.page, subscription=self.subscription, parent_page=self.parent)\n        self.has_unsaved_changes = False\n        self.edit_handler = self.edit_handler.bind_to(form=self.form)\n        self.add_legacy_moderation_warning()\n        self.page_for_status = self.get_page_for_status()\n\n        return self.render_to_response(self.get_context_data())\n\n    def add_cancel_workflow_confirmation_message(self):\n        message = _(\n            \"Workflow on page '{0}' has been cancelled.\"\n        ).format(\n            self.page.get_admin_display_title()\n        )\n\n        messages.success(self.request, message, buttons=[\n            self.get_view_draft_message_button(),\n            self.get_edit_message_button(),\n        ])\n\n    def post(self, request):\n        # Don't allow POST requests if the page is an alias\n        if self.page.alias_of_id:\n            # Return 405 \"Method Not Allowed\" response\n            return HttpResponse(status=405)\n\n        self.form = self.form_class(\n            self.request.POST, self.request.FILES, instance=self.page, subscription=self.subscription, parent_page=self.parent\n        )\n\n        self.is_cancelling_workflow = bool(self.request.POST.get('action-cancel-workflow')) and self.workflow_state and self.workflow_state.user_can_cancel(self.request.user)\n\n        if self.form.is_valid() and not self.page_perms.page_locked():\n            return self.form_valid(self.form)\n        else:\n            return self.form_invalid(self.form)\n\n    def workflow_action_is_valid(self):\n        self.workflow_action = self.request.POST['workflow-action-name']\n        available_actions = self.page.current_workflow_task.get_actions(self.page, self.request.user)\n        available_action_names = [name for name, verbose_name, modal in available_actions]\n        return (self.workflow_action in available_action_names)\n\n    def form_valid(self, form):\n        self.is_reverting = bool(self.request.POST.get('revision'))\n        # If a revision ID was passed in the form, get that revision so its\n        # date can be referenced in notification messages\n        if self.is_reverting:\n            self.previous_revision = get_object_or_404(self.page.revisions, id=self.request.POST.get('revision'))\n\n        self.has_content_changes = self.form.has_changed()\n\n        if self.request.POST.get('action-publish') and self.page_perms.can_publish():\n            return self.publish_action()\n        elif self.request.POST.get('action-submit') and self.page_perms.can_submit_for_moderation():\n            return self.submit_action()\n        elif self.request.POST.get('action-restart-workflow') and self.page_perms.can_submit_for_moderation() and self.workflow_state and self.workflow_state.user_can_cancel(self.request.user):\n            return self.restart_workflow_action()\n        elif self.request.POST.get('action-workflow-action') and self.workflow_action_is_valid():\n            return self.perform_workflow_action()\n        elif self.is_cancelling_workflow:\n            return self.cancel_workflow_action()\n        else:\n            return self.save_action()\n\n    def save_action(self):\n        self.page = self.form.save(commit=False)\n        self.subscription.save()\n\n        # Save revision\n        revision = self.page.save_revision(\n            user=self.request.user,\n            log_action=True,  # Always log the new revision on edit\n            previous_revision=(self.previous_revision if self.is_reverting else None)\n        )\n\n        self.add_save_confirmation_message()\n\n        if self.has_content_changes and 'comments' in self.form.formsets:\n            changes = self.get_commenting_changes()\n            self.log_commenting_changes(changes, revision)\n            self.send_commenting_notifications(changes)\n\n        response = self.run_hook('after_edit_page', self.request, self.page)\n        if response:\n            return response\n\n        # Just saving - remain on edit page for further edits\n        return self.redirect_and_remain()\n\n    def publish_action(self):\n        self.page = self.form.save(commit=False)\n        self.subscription.save()\n\n        # Save revision\n        revision = self.page.save_revision(\n            user=self.request.user,\n            log_action=True,  # Always log the new revision on edit\n            previous_revision=(self.previous_revision if self.is_reverting else None)\n        )\n\n        # store submitted go_live_at for messaging below\n        go_live_at = self.page.go_live_at\n\n        response = self.run_hook('before_publish_page', self.request, self.page)\n        if response:\n            return response\n\n        action = PublishPageRevisionAction(\n            revision,\n            user=self.request.user,\n            changed=self.has_content_changes,\n            previous_revision=(self.previous_revision if self.is_reverting else None)\n        )\n        action.execute(skip_permission_checks=True)\n\n        if self.has_content_changes and 'comments' in self.form.formsets:\n            changes = self.get_commenting_changes()\n            self.log_commenting_changes(changes, revision)\n            self.send_commenting_notifications(changes)\n\n        # Need to reload the page because the URL may have changed, and we\n        # need the up-to-date URL for the \"View Live\" button.\n        self.page = self.page.specific_class.objects.get(pk=self.page.pk)\n\n        response = self.run_hook('after_publish_page', self.request, self.page)\n        if response:\n            return response\n\n        # Notifications\n        if go_live_at and go_live_at > timezone.now():\n            # Page has been scheduled for publishing in the future\n\n            if self.is_reverting:\n                message = _(\n                    \"Version from {0} of page '{1}' has been scheduled for publishing.\"\n                ).format(\n                    self.previous_revision.created_at.strftime(\"%d %b %Y %H:%M\"),\n                    self.page.get_admin_display_title()\n                )\n            else:\n                if self.page.live:\n                    message = _(\n                        \"Page '{0}' is live and this version has been scheduled for publishing.\"\n                    ).format(\n                        self.page.get_admin_display_title()\n                    )\n\n                else:\n                    message = _(\n                        \"Page '{0}' has been scheduled for publishing.\"\n                    ).format(\n                        self.page.get_admin_display_title()\n                    )\n\n            messages.success(self.request, message, buttons=[self.get_edit_message_button()])\n\n        else:\n            # Page is being published now\n\n            if self.is_reverting:\n                message = _(\n                    \"Version from {0} of page '{1}' has been published.\"\n                ).format(\n                    self.previous_revision.created_at.strftime(\"%d %b %Y %H:%M\"),\n                    self.page.get_admin_display_title()\n                )\n            else:\n                message = _(\n                    \"Page '{0}' has been published.\"\n                ).format(\n                    self.page.get_admin_display_title()\n                )\n\n            buttons = []\n            if self.page.url is not None:\n                buttons.append(self.get_view_live_message_button())\n            buttons.append(self.get_edit_message_button())\n            messages.success(self.request, message, buttons=buttons)\n\n        response = self.run_hook('after_edit_page', self.request, self.page)\n        if response:\n            return response\n\n        # we're done here - redirect back to the explorer\n        return self.redirect_away()\n\n    def submit_action(self):\n        self.page = self.form.save(commit=False)\n        self.subscription.save()\n\n        # Save revision\n        revision = self.page.save_revision(\n            user=self.request.user,\n            log_action=True,  # Always log the new revision on edit\n            previous_revision=(self.previous_revision if self.is_reverting else None)\n        )\n\n        if self.has_content_changes and 'comments' in self.form.formsets:\n            changes = self.get_commenting_changes()\n            self.log_commenting_changes(changes, revision)\n            self.send_commenting_notifications(changes)\n\n        if self.workflow_state and self.workflow_state.status == WorkflowState.STATUS_NEEDS_CHANGES:\n            # If the workflow was in the needs changes state, resume the existing workflow on submission\n            self.workflow_state.resume(self.request.user)\n        else:\n            # Otherwise start a new workflow\n            workflow = self.page.get_workflow()\n            workflow.start(self.page, self.request.user)\n\n        message = _(\n            \"Page '{0}' has been submitted for moderation.\"\n        ).format(\n            self.page.get_admin_display_title()\n        )\n\n        messages.success(self.request, message, buttons=[\n            self.get_view_draft_message_button(),\n            self.get_edit_message_button(),\n        ])\n\n        response = self.run_hook('after_edit_page', self.request, self.page)\n        if response:\n            return response\n\n        # we're done here - redirect back to the explorer\n        return self.redirect_away()\n\n    def restart_workflow_action(self):\n        self.page = self.form.save(commit=False)\n        self.subscription.save()\n\n        # save revision\n        revision = self.page.save_revision(\n            user=self.request.user,\n            log_action=True,  # Always log the new revision on edit\n            previous_revision=(self.previous_revision if self.is_reverting else None)\n        )\n\n        if self.has_content_changes and 'comments' in self.form.formsets:\n            changes = self.get_commenting_changes()\n            self.log_commenting_changes(changes, revision)\n            self.send_commenting_notifications(changes)\n\n        # cancel workflow\n        self.workflow_state.cancel(user=self.request.user)\n        # start new workflow\n        workflow = self.page.get_workflow()\n        workflow.start(self.page, self.request.user)\n\n        message = _(\n            \"Workflow on page '{0}' has been restarted.\"\n        ).format(\n            self.page.get_admin_display_title()\n        )\n\n        messages.success(self.request, message, buttons=[\n            self.get_view_draft_message_button(),\n            self.get_edit_message_button(),\n        ])\n\n        response = self.run_hook('after_edit_page', self.request, self.page)\n        if response:\n            return response\n\n        # we're done here - redirect back to the explorer\n        return self.redirect_away()\n\n    def perform_workflow_action(self):\n        self.page = self.form.save(commit=False)\n        self.subscription.save()\n\n        if self.has_content_changes:\n            # Save revision\n            revision = self.page.save_revision(\n                user=self.request.user,\n                log_action=True,  # Always log the new revision on edit\n                previous_revision=(self.previous_revision if self.is_reverting else None)\n            )\n\n            if 'comments' in self.form.formsets:\n                changes = self.get_commenting_changes()\n                self.log_commenting_changes(changes, revision)\n                self.send_commenting_notifications(changes)\n\n        extra_workflow_data_json = self.request.POST.get('workflow-action-extra-data', '{}')\n        extra_workflow_data = json.loads(extra_workflow_data_json)\n        self.page.current_workflow_task.on_action(self.page.current_workflow_task_state, self.request.user, self.workflow_action, **extra_workflow_data)\n\n        self.add_save_confirmation_message()\n\n        response = self.run_hook('after_edit_page', self.request, self.page)\n        if response:\n            return response\n\n        # we're done here - redirect back to the explorer\n        return self.redirect_away()\n\n    def cancel_workflow_action(self):\n        self.workflow_state.cancel(user=self.request.user)\n        self.page = self.form.save(commit=False)\n        self.subscription.save()\n\n        # Save revision\n        revision = self.page.save_revision(\n            user=self.request.user,\n            log_action=True,  # Always log the new revision on edit\n            previous_revision=(self.previous_revision if self.is_reverting else None)\n        )\n\n        if self.has_content_changes and 'comments' in self.form.formsets:\n            changes = self.get_commenting_changes()\n            self.log_commenting_changes(changes, revision)\n            self.send_commenting_notifications(changes)\n\n        # Notifications\n        self.add_cancel_workflow_confirmation_message()\n\n        response = self.run_hook('after_edit_page', self.request, self.page)\n        if response:\n            return response\n\n        # Just saving - remain on edit page for further edits\n        return self.redirect_and_remain()\n\n    def redirect_away(self):\n        if self.next_url:\n            # redirect back to 'next' url if present\n            return redirect(self.next_url)\n        else:\n            # redirect back to the explorer\n            return redirect('wagtailadmin_explore', self.page.get_parent().id)\n\n    def redirect_and_remain(self):\n        target_url = reverse('wagtailadmin_pages:edit', args=[self.page.id])\n        if self.next_url:\n            # Ensure the 'next' url is passed through again if present\n            target_url += '?next=%s' % quote(self.next_url)\n        return redirect(target_url)\n\n    def form_invalid(self, form):\n        # even if the page is locked due to not having permissions, the original submitter can still cancel the workflow\n        if self.is_cancelling_workflow:\n            self.workflow_state.cancel(user=self.request.user)\n            self.add_cancel_workflow_confirmation_message()\n\n        if self.page_perms.page_locked():\n            messages.error(self.request, _(\"The page could not be saved as it is locked\"))\n        else:\n            messages.validation_error(\n                self.request, _(\"The page could not be saved due to validation errors\"), self.form\n            )\n        self.errors_debug = (\n            repr(self.form.errors)\n            + repr([\n                (name, formset.errors)\n                for (name, formset) in self.form.formsets.items()\n                if formset.errors\n            ])\n        )\n        self.has_unsaved_changes = True\n\n        self.edit_handler = self.edit_handler.bind_to(form=self.form)\n        self.add_legacy_moderation_warning()\n        self.page_for_status = self.get_page_for_status()\n\n        return self.render_to_response(self.get_context_data())\n\n    def get_context_data(self, **kwargs):\n        context = super().get_context_data(**kwargs)\n        context.update({\n            'page': self.page,\n            'page_for_status': self.page_for_status,\n            'content_type': self.page_content_type,\n            'edit_handler': self.edit_handler,\n            'errors_debug': self.errors_debug,\n            'action_menu': PageActionMenu(self.request, view='edit', page=self.page),\n            'preview_modes': self.page.preview_modes,\n            'form': self.form,\n            'next': self.next_url,\n            'has_unsaved_changes': self.has_unsaved_changes,\n            'page_locked': self.page_perms.page_locked(),\n            'workflow_state': self.workflow_state if self.workflow_state and self.workflow_state.is_active else None,\n            'current_task_state': self.page.current_workflow_task_state,\n            'publishing_will_cancel_workflow': self.workflow_tasks and getattr(settings, 'WAGTAIL_WORKFLOW_CANCEL_ON_PUBLISH', True),\n            'locale': None,\n            'translations': [],\n        })\n\n        if getattr(settings, 'WAGTAIL_I18N_ENABLED', False):\n            user_perms = UserPagePermissionsProxy(self.request.user)\n\n            context.update({\n                'locale': self.page.locale,\n                'translations': [\n                    {\n                        'locale': translation.locale,\n                        'url': reverse('wagtailadmin_pages:edit', args=[translation.id]),\n                    }\n                    for translation in self.page.get_translations().only('id', 'locale', 'depth').select_related('locale')\n                    if user_perms.for_page(translation).can_edit()\n                ],\n            })\n\n        return context\n"], "filenames": ["wagtail/admin/tests/pages/test_edit_page.py", "wagtail/admin/views/pages/edit.py"], "buggy_code_start_loc": [2102, 144], "buggy_code_end_loc": [2400, 149], "fixing_code_start_loc": [2103, 144], "fixing_code_end_loc": [2423, 148], "type": "CWE-200", "message": "Wagtail is a Django based content management system focused on flexibility and user experience. When notifications for new replies in comment threads are sent, they are sent to all users who have replied or commented anywhere on the site, rather than only in the relevant threads. This means that a user could listen in to new comment replies on pages they have not have editing access to, as long as they have left a comment or reply somewhere on the site. A patched version has been released as Wagtail 2.15.2, which restores the intended behaviour - to send notifications for new replies to the participants in the active thread only (editing permissions are not considered). New comments can be disabled by setting `WAGTAILADMIN_COMMENTS_ENABLED = False` in the Django settings file.", "other": {"cve": {"id": "CVE-2022-21683", "sourceIdentifier": "security-advisories@github.com", "published": "2022-01-18T18:15:08.430", "lastModified": "2022-01-26T18:16:27.387", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Wagtail is a Django based content management system focused on flexibility and user experience. When notifications for new replies in comment threads are sent, they are sent to all users who have replied or commented anywhere on the site, rather than only in the relevant threads. This means that a user could listen in to new comment replies on pages they have not have editing access to, as long as they have left a comment or reply somewhere on the site. A patched version has been released as Wagtail 2.15.2, which restores the intended behaviour - to send notifications for new replies to the participants in the active thread only (editing permissions are not considered). New comments can be disabled by setting `WAGTAILADMIN_COMMENTS_ENABLED = False` in the Django settings file."}, {"lang": "es", "value": "Wagtail es un sistema de administraci\u00f3n de contenidos basado en Django y centrado en la flexibilidad y la experiencia del usuario. Cuando son enviadas notificaciones de nuevas respuestas en los hilos de comentarios, son enviados a todos los usuarios que han respondido o comentado en cualquier parte del sitio, en lugar de hacerlo s\u00f3lo en los hilos correspondientes. Esto significa que un usuario puede escuchar las respuestas a nuevos comentarios en p\u00e1ginas a las que no presenta acceso de edici\u00f3n, siempre que haya dejado un comentario o respuesta en alg\u00fan lugar del sitio. Ha sido publicada una versi\u00f3n parcheada como Wagtail 2.15.2, que restablece el comportamiento previsto: enviar notificaciones de nuevas respuestas s\u00f3lo a participantes en el hilo activo (no es tomado en cuenta los permisos de edici\u00f3n). Los nuevos comentarios pueden deshabilitarse al establecer \"WAGTAILADMIN_COMMENTS_ENABLED = False\" en el archivo de configuraci\u00f3n de Django"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:torchbox:wagtail:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.13", "versionEndExcluding": "2.15.2", "matchCriteriaId": "522C2111-60D9-42BB-804F-EE8648453A53"}]}]}], "references": [{"url": "https://github.com/wagtail/wagtail/commit/5fe901e5d86ed02dbbb63039a897582951266afd", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/wagtail/wagtail/releases/tag/v2.15.2", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/wagtail/wagtail/security/advisories/GHSA-xqxm-2rpm-3889", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/wagtail/wagtail/commit/5fe901e5d86ed02dbbb63039a897582951266afd"}}