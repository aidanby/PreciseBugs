{"buggy_code": ["<?php namespace Winter\\Storm\\Database\\Attach;\n\nuse Exception;\nuse Illuminate\\Filesystem\\FilesystemAdapter;\nuse Illuminate\\Support\\Facades\\Cache;\nuse Illuminate\\Support\\Facades\\Log;\nuse Illuminate\\Support\\Facades\\Storage;\nuse Symfony\\Component\\HttpFoundation\\File\\File as FileObj;\nuse Symfony\\Component\\HttpFoundation\\File\\UploadedFile;\nuse Winter\\Storm\\Database\\Model;\nuse Winter\\Storm\\Exception\\ApplicationException;\nuse Winter\\Storm\\Network\\Http;\nuse Winter\\Storm\\Support\\Facades\\File as FileHelper;\n\n/**\n * File attachment model\n *\n * @author Alexey Bobkov, Samuel Georges\n *\n * @property string $file_name The name of the file\n * @property int $file_size The size of the file\n * @property string $content_type The MIME type of the file\n * @property string $disk_name The generated disk name of the file\n */\nclass File extends Model\n{\n    use \\Winter\\Storm\\Database\\Traits\\Sortable;\n\n    /**\n     * @var string The table associated with the model.\n     */\n    protected $table = 'files';\n\n    /**\n     * @var array Relations\n     */\n    public $morphTo = [\n        'attachment' => [],\n    ];\n\n    /**\n     * @var string[] The attributes that are mass assignable.\n     */\n    protected $fillable = [\n        'file_name',\n        'title',\n        'description',\n        'field',\n        'attachment_id',\n        'attachment_type',\n        'is_public',\n        'sort_order',\n        'data',\n    ];\n\n    /**\n     * @var string[] The attributes that aren't mass assignable.\n     */\n    protected $guarded = [];\n\n    /**\n     * @var string[] Known image extensions.\n     */\n    public static $imageExtensions = ['jpg', 'jpeg', 'png', 'gif', 'webp'];\n\n    /**\n     * @var array<int, string> Hidden fields from array/json access\n     */\n    protected $hidden = ['attachment_type', 'attachment_id', 'is_public'];\n\n    /**\n     * @var array Add fields to array/json access\n     */\n    protected $appends = ['path', 'extension'];\n\n    /**\n     * @var mixed A local file name or an instance of an uploaded file,\n     * objects of the \\Symfony\\Component\\HttpFoundation\\File\\UploadedFile class.\n     */\n    public $data = null;\n\n    /**\n     * @var array Mime types\n     */\n    protected $autoMimeTypes = [\n        'docx' => 'application/msword',\n        'xlsx' => 'application/excel',\n        'gif'  => 'image/gif',\n        'png'  => 'image/png',\n        'jpg'  => 'image/jpeg',\n        'jpeg' => 'image/jpeg',\n        'webp' => 'image/webp',\n        'pdf'  => 'application/pdf',\n        'svg'  => 'image/svg+xml',\n    ];\n\n    //\n    // Constructors\n    //\n\n    /**\n     * Creates a file object from a file an uploaded file.\n     *\n     * @param UploadedFile $uploadedFile The uploaded file.\n     * @return static\n     */\n    public function fromPost($uploadedFile)\n    {\n        $this->file_name = $uploadedFile->getClientOriginalName();\n        $this->file_size = $uploadedFile->getSize();\n        $this->content_type = $uploadedFile->getMimeType();\n        $this->disk_name = $this->getDiskName();\n\n        /*\n         * getRealPath() can be empty for some environments (IIS)\n         */\n        $realPath = empty(trim($uploadedFile->getRealPath()))\n            ? $uploadedFile->getPath() . DIRECTORY_SEPARATOR . $uploadedFile->getFileName()\n            : $uploadedFile->getRealPath();\n\n        $this->putFile($realPath, $this->disk_name);\n\n        return $this;\n    }\n\n    /**\n     * Creates a file object from a file on the local filesystem.\n     *\n     * @param string $filePath The path to the file.\n     * @return static\n     */\n    public function fromFile($filePath, $filename = null)\n    {\n        $file = new FileObj($filePath);\n        $this->file_name = empty($filename) ? $file->getFilename() : $filename;\n        $this->file_size = $file->getSize();\n        $this->content_type = $file->getMimeType();\n        $this->disk_name = $this->getDiskName();\n\n        $this->putFile($file->getRealPath(), $this->disk_name);\n\n        return $this;\n    }\n\n    /**\n     * Creates a file object from a file on the disk returned by $this->getDisk()\n     */\n    public function fromStorage(string $filePath): static\n    {\n        $disk = $this->getDisk();\n\n        if (!$disk->exists($filePath)) {\n            throw new \\InvalidArgumentException(sprintf('File `%s` was not found on the storage disk', $filePath));\n        }\n\n        if (empty($this->file_name)) {\n            $this->file_name = basename($filePath);\n        }\n        if (empty($this->content_type)) {\n            $this->content_type = $disk->mimeType($filePath);\n        }\n\n        $this->file_size = $disk->size($filePath);\n        $this->disk_name = $this->getDiskName();\n\n        if (!$disk->copy($filePath, $this->getDiskPath())) {\n            throw new ApplicationException(sprintf('Unable to copy `%s` to `%s`', $filePath, $this->getDiskPath()));\n        }\n\n        return $this;\n    }\n\n    /**\n     * Creates a file object from raw data.\n     *\n     * @param string $data The raw data.\n     * @param string $filename The name of the file.\n     * @return static\n     */\n    public function fromData($data, $filename)\n    {\n        $tempName = str_replace('.', '', uniqid('', true)) . '.tmp';\n        $tempPath = temp_path($tempName);\n        FileHelper::put($tempPath, $data);\n\n        $file = $this->fromFile($tempPath, basename($filename));\n        FileHelper::delete($tempPath);\n\n        return $file;\n    }\n\n    /**\n     * Creates a file object from url\n     *\n     * @param string $url The URL to retrieve and store.\n     * @param string|null $filename The name of the file. If null, the filename will be extracted from the URL.\n     * @return static\n     */\n    public function fromUrl($url, $filename = null)\n    {\n        $data = Http::get($url);\n\n        if ($data->code != 200) {\n            throw new Exception(sprintf('Error getting file \"%s\", error code: %d', $data->url, $data->code));\n        }\n\n        if (empty($filename)) {\n            // Parse the URL to get the path info\n            $filePath = parse_url($data->url, PHP_URL_PATH);\n\n            // Get the filename from the path\n            $filename = pathinfo($filePath)['filename'];\n\n            // Attempt to detect the extension from the reported Content-Type, fall back to the original path extension\n            // if not able to guess\n            $mimesToExt = array_flip($this->autoMimeTypes);\n            $headers = array_change_key_case($data->headers, CASE_LOWER);\n            if (!empty($headers['content-type']) && isset($mimesToExt[$headers['content-type']])) {\n                $ext = $mimesToExt[$headers['content-type']];\n            } else {\n                $ext = pathinfo($filePath)['extension'] ?? '';\n            }\n\n            if (!empty($ext)) {\n                $ext = '.' . $ext;\n            }\n\n            // Generate the filename\n            $filename = \"{$filename}{$ext}\";\n        }\n\n        return $this->fromData($data, $filename);\n    }\n\n    //\n    // Attribute mutators\n    //\n\n    /**\n     * Helper attribute for getPath.\n     *\n     * @return string\n     */\n    public function getPathAttribute()\n    {\n        return $this->getPath();\n    }\n\n    /**\n     * Helper attribute for getExtension.\n     *\n     * @return string\n     */\n    public function getExtensionAttribute()\n    {\n        return $this->getExtension();\n    }\n\n    /**\n     * Used only when filling attributes.\n     *\n     * @param mixed $value\n     * @return void\n     */\n    public function setDataAttribute($value)\n    {\n        $this->data = $value;\n    }\n\n    /**\n     * Helper attribute for get image width.\n     *\n     * Returns `null` if this file is not an image.\n     *\n     * @return string|int|null\n     */\n    public function getWidthAttribute()\n    {\n        if ($this->isImage()) {\n            $dimensions = $this->getImageDimensions();\n\n            return $dimensions[0];\n        }\n\n        return null;\n    }\n\n    /**\n     * Helper attribute for get image height.\n     *\n     * Returns `null` if this file is not an image.\n     *\n     * @return string|int|null\n     */\n    public function getHeightAttribute()\n    {\n        if ($this->isImage()) {\n            $dimensions = $this->getImageDimensions();\n\n            return $dimensions[1];\n        }\n\n        return null;\n    }\n\n    /**\n     * Helper attribute for file size in human format.\n     *\n     * @return string\n     */\n    public function getSizeAttribute()\n    {\n        return $this->sizeToString();\n    }\n\n    //\n    // Raw output\n    //\n\n    /**\n     * Outputs the raw file contents.\n     *\n     * @param string $disposition The Content-Disposition to set, defaults to `inline`\n     * @param bool $returnResponse Defaults to `false`, returns a Response object instead of directly outputting to the\n     *  browser\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    public function output($disposition = 'inline', $returnResponse = false)\n    {\n        $response = response($this->getContents())->withHeaders([\n            'Content-type'        => $this->getContentType(),\n            'Content-Disposition' => $disposition . '; filename=\"' . $this->file_name . '\"',\n            'Cache-Control'       => 'private, no-store, no-cache, must-revalidate, max-age=0',\n            'Accept-Ranges'       => 'bytes',\n            'Content-Length'      => $this->file_size,\n        ]);\n\n        if ($returnResponse) {\n            return $response;\n        }\n\n        $response->sendHeaders();\n        $response->sendContent();\n    }\n\n    /**\n     * Outputs the raw thumbfile contents.\n     *\n     * @param int $width\n     * @param int $height\n     * @param array $options [\n     *                  'mode'      => 'auto',\n     *                  'offset'    => [0, 0],\n     *                  'quality'   => 90,\n     *                  'sharpen'   => 0,\n     *                  'interlace' => false,\n     *                  'extension' => 'auto',\n     *                  'disposition' => 'inline',\n     *              ]\n     * @param bool $returnResponse Defaults to `false`, returns a Response object instead of directly outputting to the\n     *  browser\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    public function outputThumb($width, $height, $options = [], $returnResponse = false)\n    {\n        $disposition = array_get($options, 'disposition', 'inline');\n        $options = $this->getDefaultThumbOptions($options);\n        $this->getThumb($width, $height, $options);\n        $thumbFile = $this->getThumbFilename($width, $height, $options);\n        $contents = $this->getContents($thumbFile);\n\n        $response = response($contents)->withHeaders([\n            'Content-type'        => $this->getContentType(),\n            'Content-Disposition' => $disposition . '; filename=\"' . basename($thumbFile) . '\"',\n            'Cache-Control'       => 'private, no-store, no-cache, must-revalidate, max-age=0',\n            'Accept-Ranges'       => 'bytes',\n            'Content-Length'      => mb_strlen($contents, '8bit'),\n        ]);\n\n        if ($returnResponse) {\n            return $response;\n        }\n\n        $response->sendHeaders();\n        $response->sendContent();\n    }\n\n    //\n    // Getters\n    //\n\n    /**\n     * Returns the cache key used for the hasFile method\n     *\n     * @param string|null $path The path to get the cache key for\n     * @return string\n     */\n    public function getCacheKey($path = null)\n    {\n        if (empty($path)) {\n            $path = $this->getDiskPath();\n        }\n\n        return 'file_exists::' . $path;\n    }\n\n    /**\n     * Returns the file name without path\n     *\n     * @return string\n     */\n    public function getFilename()\n    {\n        return $this->file_name;\n    }\n\n    /**\n     * Returns the file extension.\n     *\n     * @return string\n     */\n    public function getExtension()\n    {\n        return FileHelper::extension($this->file_name);\n    }\n\n    /**\n     * Returns the last modification date as a UNIX timestamp.\n     *\n     * @param string|null $fileName\n     * @return int\n     */\n    public function getLastModified($fileName = null)\n    {\n        return $this->storageCmd('lastModified', $this->getDiskPath($fileName));\n    }\n\n    /**\n     * Returns the file content type.\n     *\n     * Returns `null` if the file content type cannot be determined.\n     *\n     * @return string|null\n     */\n    public function getContentType()\n    {\n        if ($this->content_type !== null) {\n            return $this->content_type;\n        }\n\n        $ext = $this->getExtension();\n        if (isset($this->autoMimeTypes[$ext])) {\n            return $this->content_type = $this->autoMimeTypes[$ext];\n        }\n\n        return null;\n    }\n\n    /**\n     * Get file contents from storage device.\n     *\n     * @param string|null $fileName\n     * @return string\n     */\n    public function getContents($fileName = null)\n    {\n        return $this->storageCmd('get', $this->getDiskPath($fileName));\n    }\n\n    /**\n     * Returns the public address to access the file.\n     *\n     * @param string|null $fileName\n     * @return string\n     */\n    public function getPath($fileName = null)\n    {\n        if (empty($fileName)) {\n            $fileName = $this->disk_name;\n        }\n        return $this->getPublicPath() . $this->getPartitionDirectory() . $fileName;\n    }\n\n    /**\n     * Returns a local path to this file. If the file is stored remotely,\n     * it will be downloaded to a temporary directory.\n     *\n     * @return string\n     */\n    public function getLocalPath()\n    {\n        if ($this->isLocalStorage()) {\n            return $this->getLocalRootPath() . '/' . $this->getDiskPath();\n        }\n\n        $itemSignature = md5($this->getPath()) . $this->getLastModified();\n\n        $cachePath = $this->getLocalTempPath($itemSignature . '.' . $this->getExtension());\n\n        if (!FileHelper::exists($cachePath)) {\n            $this->copyStorageToLocal($this->getDiskPath(), $cachePath);\n        }\n\n        return $cachePath;\n    }\n\n    /**\n     * Returns the path to the file, relative to the storage disk.\n     *\n     * @param string|null $fileName\n     * @return string\n     */\n    public function getDiskPath($fileName = null)\n    {\n        if (empty($fileName)) {\n            $fileName = $this->disk_name;\n        }\n        return $this->getStorageDirectory() . $this->getPartitionDirectory() . $fileName;\n    }\n\n    /**\n     * Determines if the file is flagged \"public\" or not.\n     *\n     * @return bool\n     */\n    public function isPublic()\n    {\n        if (array_key_exists('is_public', $this->attributes)) {\n            return (bool) $this->attributes['is_public'];\n        }\n\n        if (isset($this->is_public)) {\n            return (bool) $this->is_public;\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns the file size as string.\n     *\n     * @return string\n     */\n    public function sizeToString()\n    {\n        return FileHelper::sizeToString($this->file_size);\n    }\n\n    //\n    // Events\n    //\n\n    /**\n     * Before the model is saved\n     * - check if new file data has been supplied, eg: $model->data = Input::file('something');\n     *\n     * @return void\n     */\n    public function beforeSave()\n    {\n        /*\n         * Process the data property\n         */\n        if ($this->data !== null) {\n            if ($this->data instanceof UploadedFile) {\n                $this->fromPost($this->data);\n            } elseif (file_exists($this->data)) {\n                $this->fromFile($this->data);\n            } else {\n                $this->fromStorage($this->data);\n            }\n\n            $this->data = null;\n        }\n    }\n\n    /**\n     * After model is deleted\n     * - clean up it's thumbnails\n     *\n     * @return void\n     */\n    public function afterDelete()\n    {\n        try {\n            $this->deleteThumbs();\n            $this->deleteFile();\n        } catch (Exception $ex) {\n        }\n    }\n\n    //\n    // Image handling\n    //\n\n    /**\n     * Checks if the file extension is an image and returns true or false.\n     *\n     * @return bool\n     */\n    public function isImage()\n    {\n        return in_array(strtolower($this->getExtension()), static::$imageExtensions);\n    }\n\n    /**\n     * Get image dimensions\n     *\n     * @return array|false\n     */\n    protected function getImageDimensions()\n    {\n        return getimagesize($this->getLocalPath());\n    }\n\n    /**\n     * Generates and returns a thumbnail path.\n     *\n     * @param integer $width\n     * @param integer $height\n     * @param array $options [\n     *                  'mode'      => 'auto',\n     *                  'offset'    => [0, 0],\n     *                  'quality'   => 90,\n     *                  'sharpen'   => 0,\n     *                  'interlace' => false,\n     *                  'extension' => 'auto',\n     *              ]\n     * @return string The URL to the generated thumbnail\n     */\n    public function getThumb($width, $height, $options = [])\n    {\n        if (!$this->isImage()) {\n            return $this->getPath();\n        }\n\n        $width = (int) $width;\n        $height = (int) $height;\n\n        $options = $this->getDefaultThumbOptions($options);\n\n        $thumbFile = $this->getThumbFilename($width, $height, $options);\n        $thumbPath = $this->getDiskPath($thumbFile);\n        $thumbPublic = $this->getPath($thumbFile);\n\n        if (!$this->hasFile($thumbFile)) {\n            $this->makeThumb($thumbFile, $thumbPath, $width, $height, $options);\n        }\n\n        return $thumbPublic;\n    }\n\n    /**\n     * Generates a thumbnail filename.\n     *\n     * @param integer $width\n     * @param integer $height\n     * @param array $options [\n     *                  'mode'      => 'auto',\n     *                  'offset'    => [0, 0],\n     *                  'quality'   => 90,\n     *                  'sharpen'   => 0,\n     *                  'interlace' => false,\n     *                  'extension' => 'auto',\n     *              ]\n     * @return string The filename of the thumbnail\n     */\n    public function getThumbFilename($width, $height, $options = [])\n    {\n        $options = $this->getDefaultThumbOptions($options);\n        return implode('_', [\n            'thumb',\n            (string) $this->id,\n            (string) $width,\n            (string) $height,\n            (string) $options['offset'][0],\n            (string) $options['offset'][1],\n            (string) $options['mode'] . '.' . (string) $options['extension'],\n        ]);\n    }\n\n    /**\n     * Returns the default thumbnail options.\n     */\n    protected function getDefaultThumbOptions(array|string $override = []): array\n    {\n        $defaultOptions = [\n            'mode'      => 'auto',\n            'offset'    => [0, 0],\n            'quality'   => 90,\n            'sharpen'   => 0,\n            'interlace' => false,\n            'extension' => 'auto',\n        ];\n\n        if (!is_array($override)) {\n            $override = ['mode' => $override];\n        }\n\n        $options = array_merge($defaultOptions, $override);\n\n        $options['mode'] = strtolower($options['mode']);\n\n        if (strtolower($options['extension']) == 'auto') {\n            $options['extension'] = strtolower($this->getExtension());\n        }\n\n        return $options;\n    }\n\n    /**\n     * Generate a thumbnail\n     */\n    protected function makeThumb(string $thumbFile, string $thumbPath, int $width, int $height, array $options = []): void\n    {\n        // Get the local path to the source image\n        $sourceImage = $this->getLocalPath();\n\n        // Get the local path to the generated thumbnail\n        $resizedImage = $this->isLocalStorage()\n            ? $this->getLocalRootPath() . '/' . $thumbPath\n            : $this->getLocalTempPath($thumbFile);\n\n        /*\n         * Handle a broken source image\n         */\n        if (!$this->hasFile($this->disk_name)) {\n            BrokenImage::copyTo($resizedImage);\n        } else {\n            /*\n            * Generate thumbnail\n            */\n            try {\n                Resizer::open($sourceImage)\n                    ->resize($width, $height, $options)\n                    ->save($resizedImage)\n                ;\n            } catch (Exception $ex) {\n                Log::error($ex);\n                BrokenImage::copyTo($resizedImage);\n            }\n        }\n\n        // Handle cleanup based on the storage disk location, local or remote\n        if ($this->isLocalStorage()) {\n            // Ensure that the generated thumbnail has the correct permissions on local\n            FileHelper::chmod($resizedImage);\n        } else {\n            // Copy the generated thumbnail to the remote disk\n            $this->copyLocalToStorage($resizedImage, $thumbPath);\n\n            // Remove the temporary generated thumbnail\n            FileHelper::delete($resizedImage);\n        }\n    }\n\n    /**\n     * Delete all thumbnails for this file.\n     *\n     * @return void\n     */\n    public function deleteThumbs()\n    {\n        $pattern = 'thumb_'.$this->id.'_';\n\n        $directory = $this->getStorageDirectory() . $this->getPartitionDirectory();\n        $allFiles = $this->storageCmd('files', $directory);\n        $collection = [];\n        foreach ($allFiles as $file) {\n            if (starts_with(basename($file), $pattern)) {\n                $collection[] = $file;\n            }\n        }\n\n        /*\n         * Delete the collection of files\n         */\n        if (!empty($collection)) {\n            if ($this->isLocalStorage()) {\n                FileHelper::delete($collection);\n            } else {\n                $this->getDisk()->delete($collection);\n            }\n        }\n    }\n\n    //\n    // File handling\n    //\n\n    /**\n     * Generates a disk name from the supplied file name.\n     */\n    protected function getDiskName(): string\n    {\n        if ($this->disk_name !== null) {\n            return $this->disk_name;\n        }\n\n        $ext = strtolower($this->getExtension());\n\n        // If file was uploaded without extension, attempt to guess it\n        if (!$ext && $this->data instanceof UploadedFile) {\n            $ext = $this->data->guessExtension();\n        }\n\n        $name = str_replace('.', '', uniqid('', true));\n\n        return $this->disk_name = !empty($ext) ? $name.'.'.$ext : $name;\n    }\n\n    /**\n     * Returns a temporary local path to work from.\n     */\n    protected function getLocalTempPath(?string $path = null): string\n    {\n        if (!$path) {\n            return $this->getTempPath() . '/' . md5($this->getDiskPath()) . '.' . $this->getExtension();\n        }\n\n        return $this->getTempPath() . '/' . $path;\n    }\n\n    /**\n     * Saves a file\n     *\n     * @param string $sourcePath An absolute local path to a file name to read from.\n     * @param string|null $destinationFileName A storage file name to save to.\n     * @return bool\n     */\n    protected function putFile($sourcePath, $destinationFileName = null)\n    {\n        if (!$destinationFileName) {\n            $destinationFileName = $this->disk_name;\n        }\n\n        $destinationPath = $this->getStorageDirectory() . $this->getPartitionDirectory();\n\n        if (!$this->isLocalStorage()) {\n            return $this->copyLocalToStorage($sourcePath, $destinationPath . $destinationFileName);\n        }\n\n        /*\n         * Using local storage, tack on the root path and work locally\n         * this will ensure the correct permissions are used.\n         */\n        $destinationPath = $this->getLocalRootPath() . '/' . $destinationPath;\n\n        /*\n         * Verify the directory exists, if not try to create it. If creation fails\n         * because the directory was created by a concurrent process then proceed,\n         * otherwise trigger the error.\n         */\n        if (\n            !FileHelper::isDirectory($destinationPath) &&\n            !FileHelper::makeDirectory($destinationPath, 0777, true, true)\n        ) {\n            trigger_error(error_get_last()['message'], E_USER_WARNING);\n        }\n\n        return FileHelper::copy($sourcePath, $destinationPath . $destinationFileName);\n    }\n\n    /**\n     * Delete file contents from storage device.\n     *\n     * @param string|null $fileName\n     * @return void\n     */\n    protected function deleteFile($fileName = null)\n    {\n        if (!$fileName) {\n            $fileName = $this->disk_name;\n        }\n\n        $directory = $this->getStorageDirectory() . $this->getPartitionDirectory();\n        $filePath = $directory . $fileName;\n\n        if ($this->storageCmd('exists', $filePath)) {\n            $this->storageCmd('delete', $filePath);\n        }\n\n        Cache::forget($this->getCacheKey($filePath));\n        $this->deleteEmptyDirectory($directory);\n    }\n\n    /**\n     * Check file exists on storage device.\n     *\n     * @param string|null $fileName\n     * @return bool\n     */\n    protected function hasFile($fileName = null)\n    {\n        $filePath = $this->getDiskPath($fileName);\n\n        $result = Cache::rememberForever($this->getCacheKey($filePath), function () use ($filePath) {\n            return $this->storageCmd('exists', $filePath);\n        });\n\n        // Forget negative results\n        if (!$result) {\n            Cache::forget($this->getCacheKey($filePath));\n        }\n\n        return $result;\n    }\n\n    /**\n     * Checks if directory is empty then deletes it, three levels up to match the partition directory.\n     *\n     * @param string|null $dir Directory to check and delete if empty.\n     * @return void\n     */\n    protected function deleteEmptyDirectory($dir = null)\n    {\n        if (!$this->isDirectoryEmpty($dir)) {\n            return;\n        }\n\n        $this->storageCmd('deleteDirectory', $dir);\n\n        $dir = dirname($dir);\n        if (!$this->isDirectoryEmpty($dir)) {\n            return;\n        }\n\n        $this->storageCmd('deleteDirectory', $dir);\n\n        $dir = dirname($dir);\n        if (!$this->isDirectoryEmpty($dir)) {\n            return;\n        }\n\n        $this->storageCmd('deleteDirectory', $dir);\n    }\n\n    /**\n     * Returns true if a directory contains no files.\n     *\n     * @param string|null $dir Directory to check.\n     * @return bool\n     */\n    protected function isDirectoryEmpty($dir = null)\n    {\n        return count($this->storageCmd('allFiles', $dir)) === 0;\n    }\n\n    //\n    // Storage interface\n    //\n\n    /**\n     * Calls a method against File or Storage depending on local storage.\n     *\n     * This allows local storage outside the storage/app folder and is also good for performance. For local storage,\n     * *every* argument is prefixed with the local root path. Props to Laravel for the unified interface.\n     *\n     * @return mixed\n     */\n    protected function storageCmd()\n    {\n        $args = func_get_args();\n        $command = array_shift($args);\n        $result = null;\n\n        if ($this->isLocalStorage()) {\n            $interface = 'File';\n            $path = $this->getLocalRootPath();\n            $args = array_map(function ($value) use ($path) {\n                return $path . '/' . $value;\n            }, $args);\n\n            $result = forward_static_call_array([$interface, $command], $args);\n        } else {\n            $result = call_user_func_array([$this->getDisk(), $command], $args);\n        }\n\n        return $result;\n    }\n\n    /**\n     * Copy the Storage to local file\n     *\n     * @param string $storagePath\n     * @param string $localPath\n     * @return int The filesize of the copied file.\n     */\n    protected function copyStorageToLocal($storagePath, $localPath)\n    {\n        return FileHelper::put($localPath, $this->getDisk()->get($storagePath));\n    }\n\n    /**\n     * Copy the local file to Storage\n     *\n     * @param string $storagePath\n     * @param string $localPath\n     * @return string|bool\n     */\n    protected function copyLocalToStorage($localPath, $storagePath)\n    {\n        return $this->getDisk()->put($storagePath, FileHelper::get($localPath), $this->isPublic() ? 'public' : null);\n    }\n\n    //\n    // Configuration\n    //\n\n    /**\n     * Returns the maximum size of an uploaded file as configured in php.ini in kilobytes (rounded)\n     *\n     * @return float\n     */\n    public static function getMaxFilesize()\n    {\n        return round(UploadedFile::getMaxFilesize() / 1024);\n    }\n\n    /**\n     * Define the internal storage path, override this method to define.\n     *\n     * @return string\n     */\n    public function getStorageDirectory()\n    {\n        if ($this->isPublic()) {\n            return 'uploads/public/';\n        }\n\n        return 'uploads/protected/';\n    }\n\n    /**\n     * Define the public address for the storage path.\n     *\n     * @return string\n     */\n    public function getPublicPath()\n    {\n        if ($this->isPublic()) {\n            return 'http://localhost/uploads/public/';\n        }\n\n        return 'http://localhost/uploads/protected/';\n    }\n\n    /**\n     * Define the internal working path, override this method to define.\n     *\n     * @return string\n     */\n    public function getTempPath()\n    {\n        $path = temp_path() . '/uploads';\n\n        if (!FileHelper::isDirectory($path)) {\n            FileHelper::makeDirectory($path, 0777, true, true);\n        }\n\n        return $path;\n    }\n\n    /**\n     * Returns the storage disk the file is stored on\n     *\n     * @return FilesystemAdapter\n     */\n    public function getDisk()\n    {\n        return Storage::disk();\n    }\n\n    /**\n     * Returns true if the storage engine is local.\n     *\n     * @return bool\n     */\n    protected function isLocalStorage()\n    {\n        return FileHelper::isLocalDisk($this->getDisk());\n    }\n\n    /**\n     * Generates a partition for the file.\n     *\n     * For example, returns `/ABC/DE1/234` for an name of `ABCDE1234`.\n     *\n     * @return string\n     */\n    protected function getPartitionDirectory()\n    {\n        return implode('/', array_slice(str_split($this->disk_name, 3), 0, 3)) . '/';\n    }\n\n    /**\n     * If working with local storage, determine the absolute local path.\n     */\n    protected function getLocalRootPath(): string\n    {\n        $path = null;\n\n        if ($this->isLocalStorage()) {\n            $path = $this->getDisk()->getConfig()['root'] ?? null;\n        }\n\n        if (is_null($path)) {\n            $path = storage_path('app');\n        }\n\n        return $path;\n    }\n}\n", "<?php namespace Winter\\Storm\\Filesystem;\n\nuse Winter\\Storm\\Support\\Facades\\Config;\nuse Exception;\n\n/**\n * File definitions helper.\n * Contains file extensions for common use cases.\n *\n * @author Alexey Bobkov, Samuel Georges\n */\nclass Definitions\n{\n\n    /**\n     * Lock down the constructor for this class.\n     */\n    final public function __construct()\n    {\n    }\n\n    /**\n     * Entry point to request a definition set.\n     */\n    public static function get(string $type): array\n    {\n        return (new static)->getDefinitions($type);\n    }\n\n    /**\n     * Returns a definition set from config or from the default sets.\n     *\n     * @throws Exception If the provided definition type does not exist.\n     */\n    public function getDefinitions(string $type): array\n    {\n        if (!method_exists($this, $type)) {\n            throw new Exception(sprintf('No such definition set exists for \"%s\"', $type));\n        }\n\n        return (array) Config::get('cms.fileDefinitions.'.$type, $this->$type());\n    }\n\n    /**\n     * Determines if a path should be ignored based on the ignoreFiles and ignorePatterns definitions.\n     *\n     * Returns `true` if the path is ignored, `false` otherwise.\n     *\n     * @todo Efficiency of this method can be improved.\n     */\n    public static function isPathIgnored(string $path): bool\n    {\n        $ignoreNames = self::get('ignoreFiles');\n        $ignorePatterns = self::get('ignorePatterns');\n\n        if (in_array($path, $ignoreNames)) {\n            return true;\n        }\n\n        foreach ($ignorePatterns as $pattern) {\n            if (preg_match('/'.$pattern.'/', $path)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Files that can be safely ignored.\n     *\n     * This list can be customized with the config:\n     *\n     * `cms.fileDefinitions.ignoreFiles`\n     */\n    protected function ignoreFiles(): array\n    {\n        return [\n            '.svn',\n            '.git',\n            '.DS_Store',\n            '.AppleDouble'\n        ];\n    }\n\n    /**\n     * File patterns that can be safely ignored.\n     *\n     * This list can be customized with the config:\n     *\n     * `cms.fileDefinitions.ignorePatterns`\n     */\n    protected function ignorePatterns(): array\n    {\n        return [\n            '^\\..*'\n        ];\n    }\n\n    /**\n     * Extensions that are particularly benign.\n     *\n     * This list can be customized with config:\n     *\n     * `cms.fileDefinitions.defaultExtensions`\n     */\n    protected function defaultExtensions(): array\n    {\n        return [\n            'jpg',\n            'jpeg',\n            'bmp',\n            'png',\n            'webp',\n            'gif',\n            'js',\n            'map',\n            'ico',\n            'css',\n            'less',\n            'scss',\n            'ics',\n            'odt',\n            'doc',\n            'docx',\n            'ppt',\n            'pptx',\n            'pdf',\n            'swf',\n            'txt',\n            'ods',\n            'xls',\n            'xlsx',\n            'eot',\n            'woff',\n            'woff2',\n            'ttf',\n            'flv',\n            'wmv',\n            'mp3',\n            'ogg',\n            'wav',\n            'avi',\n            'mov',\n            'mp4',\n            'mpeg',\n            'webm',\n            'mkv',\n            'rar',\n            'zip'\n        ];\n    }\n\n    /**\n     * Extensions seen as public assets.\n     *\n     * This list can be customized with config:\n     *\n     * `cms.fileDefinitions.assetExtensions`\n     */\n    protected function assetExtensions(): array\n    {\n        return [\n            'jpg',\n            'jpeg',\n            'bmp',\n            'png',\n            'webp',\n            'gif',\n            'ico',\n            'css',\n            'js',\n            'woff',\n            'woff2',\n            'ttf',\n            'eot',\n            'json',\n            'md',\n            'less',\n            'sass',\n            'scss'\n        ];\n    }\n\n    /**\n     * Extensions typically used as images.\n     *\n     * This list can be customized with config:\n     *\n     * `cms.fileDefinitions.imageExtensions`\n     */\n    protected function imageExtensions(): array\n    {\n        return [\n            'jpg',\n            'jpeg',\n            'bmp',\n            'png',\n            'webp',\n            'gif'\n        ];\n    }\n\n    /**\n     * Extensions typically used as video files.\n     *\n     * This list can be customized with config:\n     *\n     * `cms.fileDefinitions.videoExtensions`\n     */\n    protected function videoExtensions(): array\n    {\n        return [\n            'mp4',\n            'avi',\n            'mov',\n            'mpg',\n            'mpeg',\n            'mkv',\n            'webm'\n        ];\n    }\n\n    /**\n     * Extensions typically used as audio files.\n     *\n     * This list can be customized with config:\n     *\n     * `cms.fileDefinitions.audioExtensions`\n     */\n    protected function audioExtensions(): array\n    {\n        return [\n            'mp3',\n            'wav',\n            'wma',\n            'm4a',\n            'ogg'\n        ];\n    }\n}\n"], "fixing_code": ["<?php namespace Winter\\Storm\\Database\\Attach;\n\nuse Exception;\nuse Illuminate\\Filesystem\\FilesystemAdapter;\nuse Illuminate\\Support\\Facades\\Cache;\nuse Illuminate\\Support\\Facades\\Log;\nuse Illuminate\\Support\\Facades\\Storage;\nuse Symfony\\Component\\HttpFoundation\\File\\File as FileObj;\nuse Symfony\\Component\\HttpFoundation\\File\\UploadedFile;\nuse Winter\\Storm\\Database\\Model;\nuse Winter\\Storm\\Exception\\ApplicationException;\nuse Winter\\Storm\\Network\\Http;\nuse Winter\\Storm\\Support\\Facades\\File as FileHelper;\nuse Winter\\Storm\\Support\\Svg;\n\n/**\n * File attachment model\n *\n * @author Alexey Bobkov, Samuel Georges\n *\n * @property string $file_name The name of the file\n * @property int $file_size The size of the file\n * @property string $content_type The MIME type of the file\n * @property string $disk_name The generated disk name of the file\n */\nclass File extends Model\n{\n    use \\Winter\\Storm\\Database\\Traits\\Sortable;\n\n    /**\n     * @var string The table associated with the model.\n     */\n    protected $table = 'files';\n\n    /**\n     * @var array Relations\n     */\n    public $morphTo = [\n        'attachment' => [],\n    ];\n\n    /**\n     * @var string[] The attributes that are mass assignable.\n     */\n    protected $fillable = [\n        'file_name',\n        'title',\n        'description',\n        'field',\n        'attachment_id',\n        'attachment_type',\n        'is_public',\n        'sort_order',\n        'data',\n    ];\n\n    /**\n     * @var string[] The attributes that aren't mass assignable.\n     */\n    protected $guarded = [];\n\n    /**\n     * @var string[] Known image extensions.\n     */\n    public static $imageExtensions = ['jpg', 'jpeg', 'png', 'gif', 'webp'];\n\n    /**\n     * @var array<int, string> Hidden fields from array/json access\n     */\n    protected $hidden = ['attachment_type', 'attachment_id', 'is_public'];\n\n    /**\n     * @var array Add fields to array/json access\n     */\n    protected $appends = ['path', 'extension'];\n\n    /**\n     * @var mixed A local file name or an instance of an uploaded file,\n     * objects of the \\Symfony\\Component\\HttpFoundation\\File\\UploadedFile class.\n     */\n    public $data = null;\n\n    /**\n     * @var array Mime types\n     */\n    protected $autoMimeTypes = [\n        'docx' => 'application/msword',\n        'xlsx' => 'application/excel',\n        'gif'  => 'image/gif',\n        'png'  => 'image/png',\n        'jpg'  => 'image/jpeg',\n        'jpeg' => 'image/jpeg',\n        'webp' => 'image/webp',\n        'pdf'  => 'application/pdf',\n        'svg'  => 'image/svg+xml',\n    ];\n\n    //\n    // Constructors\n    //\n\n    /**\n     * Creates a file object from a file an uploaded file.\n     *\n     * @param UploadedFile $uploadedFile The uploaded file.\n     * @return static\n     */\n    public function fromPost($uploadedFile)\n    {\n        $this->file_name = $uploadedFile->getClientOriginalName();\n        $this->file_size = $uploadedFile->getSize();\n        $this->content_type = $uploadedFile->getMimeType();\n        $this->disk_name = $this->getDiskName();\n\n        /*\n         * getRealPath() can be empty for some environments (IIS)\n         */\n        $realPath = empty(trim($uploadedFile->getRealPath()))\n            ? $uploadedFile->getPath() . DIRECTORY_SEPARATOR . $uploadedFile->getFileName()\n            : $uploadedFile->getRealPath();\n\n        $this->putFile($realPath, $this->disk_name);\n\n        return $this;\n    }\n\n    /**\n     * Creates a file object from a file on the local filesystem.\n     *\n     * @param string $filePath The path to the file.\n     * @return static\n     */\n    public function fromFile($filePath, $filename = null)\n    {\n        $file = new FileObj($filePath);\n        $this->file_name = empty($filename) ? $file->getFilename() : $filename;\n        $this->file_size = $file->getSize();\n        $this->content_type = $file->getMimeType();\n        $this->disk_name = $this->getDiskName();\n\n        $this->putFile($file->getRealPath(), $this->disk_name);\n\n        return $this;\n    }\n\n    /**\n     * Creates a file object from a file on the disk returned by $this->getDisk()\n     */\n    public function fromStorage(string $filePath): static\n    {\n        $disk = $this->getDisk();\n\n        if (!$disk->exists($filePath)) {\n            throw new \\InvalidArgumentException(sprintf('File `%s` was not found on the storage disk', $filePath));\n        }\n\n        if (empty($this->file_name)) {\n            $this->file_name = basename($filePath);\n        }\n        if (empty($this->content_type)) {\n            $this->content_type = $disk->mimeType($filePath);\n        }\n\n        $this->file_size = $disk->size($filePath);\n        $this->disk_name = $this->getDiskName();\n\n        if (!$disk->copy($filePath, $this->getDiskPath())) {\n            throw new ApplicationException(sprintf('Unable to copy `%s` to `%s`', $filePath, $this->getDiskPath()));\n        }\n\n        return $this;\n    }\n\n    /**\n     * Creates a file object from raw data.\n     *\n     * @param string $data The raw data.\n     * @param string $filename The name of the file.\n     * @return static\n     */\n    public function fromData($data, $filename)\n    {\n        $tempName = str_replace('.', '', uniqid('', true)) . '.tmp';\n        $tempPath = temp_path($tempName);\n        FileHelper::put($tempPath, $data);\n\n        $file = $this->fromFile($tempPath, basename($filename));\n        FileHelper::delete($tempPath);\n\n        return $file;\n    }\n\n    /**\n     * Creates a file object from url\n     *\n     * @param string $url The URL to retrieve and store.\n     * @param string|null $filename The name of the file. If null, the filename will be extracted from the URL.\n     * @return static\n     */\n    public function fromUrl($url, $filename = null)\n    {\n        $data = Http::get($url);\n\n        if ($data->code != 200) {\n            throw new Exception(sprintf('Error getting file \"%s\", error code: %d', $data->url, $data->code));\n        }\n\n        if (empty($filename)) {\n            // Parse the URL to get the path info\n            $filePath = parse_url($data->url, PHP_URL_PATH);\n\n            // Get the filename from the path\n            $filename = pathinfo($filePath)['filename'];\n\n            // Attempt to detect the extension from the reported Content-Type, fall back to the original path extension\n            // if not able to guess\n            $mimesToExt = array_flip($this->autoMimeTypes);\n            $headers = array_change_key_case($data->headers, CASE_LOWER);\n            if (!empty($headers['content-type']) && isset($mimesToExt[$headers['content-type']])) {\n                $ext = $mimesToExt[$headers['content-type']];\n            } else {\n                $ext = pathinfo($filePath)['extension'] ?? '';\n            }\n\n            if (!empty($ext)) {\n                $ext = '.' . $ext;\n            }\n\n            // Generate the filename\n            $filename = \"{$filename}{$ext}\";\n        }\n\n        return $this->fromData($data, $filename);\n    }\n\n    //\n    // Attribute mutators\n    //\n\n    /**\n     * Helper attribute for getPath.\n     *\n     * @return string\n     */\n    public function getPathAttribute()\n    {\n        return $this->getPath();\n    }\n\n    /**\n     * Helper attribute for getExtension.\n     *\n     * @return string\n     */\n    public function getExtensionAttribute()\n    {\n        return $this->getExtension();\n    }\n\n    /**\n     * Used only when filling attributes.\n     *\n     * @param mixed $value\n     * @return void\n     */\n    public function setDataAttribute($value)\n    {\n        $this->data = $value;\n    }\n\n    /**\n     * Helper attribute for get image width.\n     *\n     * Returns `null` if this file is not an image.\n     *\n     * @return string|int|null\n     */\n    public function getWidthAttribute()\n    {\n        if ($this->isImage()) {\n            $dimensions = $this->getImageDimensions();\n\n            return $dimensions[0];\n        }\n\n        return null;\n    }\n\n    /**\n     * Helper attribute for get image height.\n     *\n     * Returns `null` if this file is not an image.\n     *\n     * @return string|int|null\n     */\n    public function getHeightAttribute()\n    {\n        if ($this->isImage()) {\n            $dimensions = $this->getImageDimensions();\n\n            return $dimensions[1];\n        }\n\n        return null;\n    }\n\n    /**\n     * Helper attribute for file size in human format.\n     *\n     * @return string\n     */\n    public function getSizeAttribute()\n    {\n        return $this->sizeToString();\n    }\n\n    //\n    // Raw output\n    //\n\n    /**\n     * Outputs the raw file contents.\n     *\n     * @param string $disposition The Content-Disposition to set, defaults to `inline`\n     * @param bool $returnResponse Defaults to `false`, returns a Response object instead of directly outputting to the\n     *  browser\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    public function output($disposition = 'inline', $returnResponse = false)\n    {\n        $response = response($this->getContents())->withHeaders([\n            'Content-type'        => $this->getContentType(),\n            'Content-Disposition' => $disposition . '; filename=\"' . $this->file_name . '\"',\n            'Cache-Control'       => 'private, no-store, no-cache, must-revalidate, max-age=0',\n            'Accept-Ranges'       => 'bytes',\n            'Content-Length'      => $this->file_size,\n        ]);\n\n        if ($returnResponse) {\n            return $response;\n        }\n\n        $response->sendHeaders();\n        $response->sendContent();\n    }\n\n    /**\n     * Outputs the raw thumbfile contents.\n     *\n     * @param int $width\n     * @param int $height\n     * @param array $options [\n     *                  'mode'      => 'auto',\n     *                  'offset'    => [0, 0],\n     *                  'quality'   => 90,\n     *                  'sharpen'   => 0,\n     *                  'interlace' => false,\n     *                  'extension' => 'auto',\n     *                  'disposition' => 'inline',\n     *              ]\n     * @param bool $returnResponse Defaults to `false`, returns a Response object instead of directly outputting to the\n     *  browser\n     * @return \\Illuminate\\Http\\Response|void\n     */\n    public function outputThumb($width, $height, $options = [], $returnResponse = false)\n    {\n        $disposition = array_get($options, 'disposition', 'inline');\n        $options = $this->getDefaultThumbOptions($options);\n        $this->getThumb($width, $height, $options);\n        $thumbFile = $this->getThumbFilename($width, $height, $options);\n        $contents = $this->getContents($thumbFile);\n\n        $response = response($contents)->withHeaders([\n            'Content-type'        => $this->getContentType(),\n            'Content-Disposition' => $disposition . '; filename=\"' . basename($thumbFile) . '\"',\n            'Cache-Control'       => 'private, no-store, no-cache, must-revalidate, max-age=0',\n            'Accept-Ranges'       => 'bytes',\n            'Content-Length'      => mb_strlen($contents, '8bit'),\n        ]);\n\n        if ($returnResponse) {\n            return $response;\n        }\n\n        $response->sendHeaders();\n        $response->sendContent();\n    }\n\n    //\n    // Getters\n    //\n\n    /**\n     * Returns the cache key used for the hasFile method\n     *\n     * @param string|null $path The path to get the cache key for\n     * @return string\n     */\n    public function getCacheKey($path = null)\n    {\n        if (empty($path)) {\n            $path = $this->getDiskPath();\n        }\n\n        return 'file_exists::' . $path;\n    }\n\n    /**\n     * Returns the file name without path\n     *\n     * @return string\n     */\n    public function getFilename()\n    {\n        return $this->file_name;\n    }\n\n    /**\n     * Returns the file extension.\n     *\n     * @return string\n     */\n    public function getExtension()\n    {\n        return FileHelper::extension($this->file_name);\n    }\n\n    /**\n     * Returns the last modification date as a UNIX timestamp.\n     *\n     * @param string|null $fileName\n     * @return int\n     */\n    public function getLastModified($fileName = null)\n    {\n        return $this->storageCmd('lastModified', $this->getDiskPath($fileName));\n    }\n\n    /**\n     * Returns the file content type.\n     *\n     * Returns `null` if the file content type cannot be determined.\n     *\n     * @return string|null\n     */\n    public function getContentType()\n    {\n        if ($this->content_type !== null) {\n            return $this->content_type;\n        }\n\n        $ext = $this->getExtension();\n        if (isset($this->autoMimeTypes[$ext])) {\n            return $this->content_type = $this->autoMimeTypes[$ext];\n        }\n\n        return null;\n    }\n\n    /**\n     * Get file contents from storage device.\n     *\n     * @param string|null $fileName\n     * @return string\n     */\n    public function getContents($fileName = null)\n    {\n        return $this->storageCmd('get', $this->getDiskPath($fileName));\n    }\n\n    /**\n     * Returns the public address to access the file.\n     *\n     * @param string|null $fileName\n     * @return string\n     */\n    public function getPath($fileName = null)\n    {\n        if (empty($fileName)) {\n            $fileName = $this->disk_name;\n        }\n        return $this->getPublicPath() . $this->getPartitionDirectory() . $fileName;\n    }\n\n    /**\n     * Returns a local path to this file. If the file is stored remotely,\n     * it will be downloaded to a temporary directory.\n     *\n     * @return string\n     */\n    public function getLocalPath()\n    {\n        if ($this->isLocalStorage()) {\n            return $this->getLocalRootPath() . '/' . $this->getDiskPath();\n        }\n\n        $itemSignature = md5($this->getPath()) . $this->getLastModified();\n\n        $cachePath = $this->getLocalTempPath($itemSignature . '.' . $this->getExtension());\n\n        if (!FileHelper::exists($cachePath)) {\n            $this->copyStorageToLocal($this->getDiskPath(), $cachePath);\n        }\n\n        return $cachePath;\n    }\n\n    /**\n     * Returns the path to the file, relative to the storage disk.\n     *\n     * @param string|null $fileName\n     * @return string\n     */\n    public function getDiskPath($fileName = null)\n    {\n        if (empty($fileName)) {\n            $fileName = $this->disk_name;\n        }\n        return $this->getStorageDirectory() . $this->getPartitionDirectory() . $fileName;\n    }\n\n    /**\n     * Determines if the file is flagged \"public\" or not.\n     *\n     * @return bool\n     */\n    public function isPublic()\n    {\n        if (array_key_exists('is_public', $this->attributes)) {\n            return (bool) $this->attributes['is_public'];\n        }\n\n        if (isset($this->is_public)) {\n            return (bool) $this->is_public;\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns the file size as string.\n     *\n     * @return string\n     */\n    public function sizeToString()\n    {\n        return FileHelper::sizeToString($this->file_size);\n    }\n\n    //\n    // Events\n    //\n\n    /**\n     * Before the model is saved\n     * - check if new file data has been supplied, eg: $model->data = Input::file('something');\n     *\n     * @return void\n     */\n    public function beforeSave()\n    {\n        /*\n         * Process the data property\n         */\n        if ($this->data !== null) {\n            if ($this->data instanceof UploadedFile) {\n                $this->fromPost($this->data);\n            } elseif (file_exists($this->data)) {\n                $this->fromFile($this->data);\n            } else {\n                $this->fromStorage($this->data);\n            }\n\n            $this->data = null;\n        }\n    }\n\n    /**\n     * After model is deleted\n     * - clean up it's thumbnails\n     *\n     * @return void\n     */\n    public function afterDelete()\n    {\n        try {\n            $this->deleteThumbs();\n            $this->deleteFile();\n        } catch (Exception $ex) {\n        }\n    }\n\n    //\n    // Image handling\n    //\n\n    /**\n     * Checks if the file extension is an image and returns true or false.\n     *\n     * @return bool\n     */\n    public function isImage()\n    {\n        return in_array(strtolower($this->getExtension()), static::$imageExtensions);\n    }\n\n    /**\n     * Get image dimensions\n     *\n     * @return array|false\n     */\n    protected function getImageDimensions()\n    {\n        return getimagesize($this->getLocalPath());\n    }\n\n    /**\n     * Generates and returns a thumbnail path.\n     *\n     * @param integer $width\n     * @param integer $height\n     * @param array $options [\n     *                  'mode'      => 'auto',\n     *                  'offset'    => [0, 0],\n     *                  'quality'   => 90,\n     *                  'sharpen'   => 0,\n     *                  'interlace' => false,\n     *                  'extension' => 'auto',\n     *              ]\n     * @return string The URL to the generated thumbnail\n     */\n    public function getThumb($width, $height, $options = [])\n    {\n        if (!$this->isImage()) {\n            return $this->getPath();\n        }\n\n        $width = (int) $width;\n        $height = (int) $height;\n\n        $options = $this->getDefaultThumbOptions($options);\n\n        $thumbFile = $this->getThumbFilename($width, $height, $options);\n        $thumbPath = $this->getDiskPath($thumbFile);\n        $thumbPublic = $this->getPath($thumbFile);\n\n        if (!$this->hasFile($thumbFile)) {\n            $this->makeThumb($thumbFile, $thumbPath, $width, $height, $options);\n        }\n\n        return $thumbPublic;\n    }\n\n    /**\n     * Generates a thumbnail filename.\n     *\n     * @param integer $width\n     * @param integer $height\n     * @param array $options [\n     *                  'mode'      => 'auto',\n     *                  'offset'    => [0, 0],\n     *                  'quality'   => 90,\n     *                  'sharpen'   => 0,\n     *                  'interlace' => false,\n     *                  'extension' => 'auto',\n     *              ]\n     * @return string The filename of the thumbnail\n     */\n    public function getThumbFilename($width, $height, $options = [])\n    {\n        $options = $this->getDefaultThumbOptions($options);\n        return implode('_', [\n            'thumb',\n            (string) $this->id,\n            (string) $width,\n            (string) $height,\n            (string) $options['offset'][0],\n            (string) $options['offset'][1],\n            (string) $options['mode'] . '.' . (string) $options['extension'],\n        ]);\n    }\n\n    /**\n     * Returns the default thumbnail options.\n     */\n    protected function getDefaultThumbOptions(array|string $override = []): array\n    {\n        $defaultOptions = [\n            'mode'      => 'auto',\n            'offset'    => [0, 0],\n            'quality'   => 90,\n            'sharpen'   => 0,\n            'interlace' => false,\n            'extension' => 'auto',\n        ];\n\n        if (!is_array($override)) {\n            $override = ['mode' => $override];\n        }\n\n        $options = array_merge($defaultOptions, $override);\n\n        $options['mode'] = strtolower($options['mode']);\n\n        if (strtolower($options['extension']) == 'auto') {\n            $options['extension'] = strtolower($this->getExtension());\n        }\n\n        return $options;\n    }\n\n    /**\n     * Generate a thumbnail\n     */\n    protected function makeThumb(string $thumbFile, string $thumbPath, int $width, int $height, array $options = []): void\n    {\n        // Get the local path to the source image\n        $sourceImage = $this->getLocalPath();\n\n        // Get the local path to the generated thumbnail\n        $resizedImage = $this->isLocalStorage()\n            ? $this->getLocalRootPath() . '/' . $thumbPath\n            : $this->getLocalTempPath($thumbFile);\n\n        /*\n         * Handle a broken source image\n         */\n        if (!$this->hasFile($this->disk_name)) {\n            BrokenImage::copyTo($resizedImage);\n        } else {\n            /*\n            * Generate thumbnail\n            */\n            try {\n                Resizer::open($sourceImage)\n                    ->resize($width, $height, $options)\n                    ->save($resizedImage)\n                ;\n            } catch (Exception $ex) {\n                Log::error($ex);\n                BrokenImage::copyTo($resizedImage);\n            }\n        }\n\n        // Handle cleanup based on the storage disk location, local or remote\n        if ($this->isLocalStorage()) {\n            // Ensure that the generated thumbnail has the correct permissions on local\n            FileHelper::chmod($resizedImage);\n        } else {\n            // Copy the generated thumbnail to the remote disk\n            $this->copyLocalToStorage($resizedImage, $thumbPath);\n\n            // Remove the temporary generated thumbnail\n            FileHelper::delete($resizedImage);\n        }\n    }\n\n    /**\n     * Delete all thumbnails for this file.\n     *\n     * @return void\n     */\n    public function deleteThumbs()\n    {\n        $pattern = 'thumb_'.$this->id.'_';\n\n        $directory = $this->getStorageDirectory() . $this->getPartitionDirectory();\n        $allFiles = $this->storageCmd('files', $directory);\n        $collection = [];\n        foreach ($allFiles as $file) {\n            if (starts_with(basename($file), $pattern)) {\n                $collection[] = $file;\n            }\n        }\n\n        /*\n         * Delete the collection of files\n         */\n        if (!empty($collection)) {\n            if ($this->isLocalStorage()) {\n                FileHelper::delete($collection);\n            } else {\n                $this->getDisk()->delete($collection);\n            }\n        }\n    }\n\n    //\n    // File handling\n    //\n\n    /**\n     * Generates a disk name from the supplied file name.\n     */\n    protected function getDiskName(): string\n    {\n        if ($this->disk_name !== null) {\n            return $this->disk_name;\n        }\n\n        $ext = strtolower($this->getExtension());\n\n        // If file was uploaded without extension, attempt to guess it\n        if (!$ext && $this->data instanceof UploadedFile) {\n            $ext = $this->data->guessExtension();\n        }\n\n        $name = str_replace('.', '', uniqid('', true));\n\n        return $this->disk_name = !empty($ext) ? $name.'.'.$ext : $name;\n    }\n\n    /**\n     * Returns a temporary local path to work from.\n     */\n    protected function getLocalTempPath(?string $path = null): string\n    {\n        if (!$path) {\n            return $this->getTempPath() . '/' . md5($this->getDiskPath()) . '.' . $this->getExtension();\n        }\n\n        return $this->getTempPath() . '/' . $path;\n    }\n\n    /**\n     * Saves a file\n     *\n     * @param string $sourcePath An absolute local path to a file name to read from.\n     * @param string|null $destinationFileName A storage file name to save to.\n     * @return bool\n     */\n    protected function putFile($sourcePath, $destinationFileName = null)\n    {\n        if (!$destinationFileName) {\n            $destinationFileName = $this->disk_name;\n        }\n\n        $destinationFolder = $this->getStorageDirectory() . $this->getPartitionDirectory();\n        $destinationPath = $destinationFolder . $destinationFileName;\n\n        // Filter SVG files\n        if (pathinfo($destinationPath, PATHINFO_EXTENSION) === 'svg') {\n            file_put_contents($sourcePath, Svg::extract($sourcePath));\n        }\n\n        pathinfo($destinationPath, PATHINFO_EXTENSION);\n\n        if (!$this->isLocalStorage()) {\n            return $this->copyLocalToStorage($sourcePath, $destinationPath);\n        }\n\n        /*\n         * Using local storage, tack on the root path and work locally\n         * this will ensure the correct permissions are used.\n         */\n        $destinationFolder = $this->getLocalRootPath() . '/' . $destinationFolder;\n        $destinationPath = $destinationFolder . $destinationFileName;\n\n        /*\n         * Verify the directory exists, if not try to create it. If creation fails\n         * because the directory was created by a concurrent process then proceed,\n         * otherwise trigger the error.\n         */\n        if (\n            !FileHelper::isDirectory($destinationFolder) &&\n            !FileHelper::makeDirectory($destinationFolder, 0777, true, true)\n        ) {\n            trigger_error(error_get_last()['message'], E_USER_WARNING);\n        }\n\n        return FileHelper::copy($sourcePath, $destinationPath);\n    }\n\n    /**\n     * Delete file contents from storage device.\n     *\n     * @param string|null $fileName\n     * @return void\n     */\n    protected function deleteFile($fileName = null)\n    {\n        if (!$fileName) {\n            $fileName = $this->disk_name;\n        }\n\n        $directory = $this->getStorageDirectory() . $this->getPartitionDirectory();\n        $filePath = $directory . $fileName;\n\n        if ($this->storageCmd('exists', $filePath)) {\n            $this->storageCmd('delete', $filePath);\n        }\n\n        Cache::forget($this->getCacheKey($filePath));\n        $this->deleteEmptyDirectory($directory);\n    }\n\n    /**\n     * Check file exists on storage device.\n     *\n     * @param string|null $fileName\n     * @return bool\n     */\n    protected function hasFile($fileName = null)\n    {\n        $filePath = $this->getDiskPath($fileName);\n\n        $result = Cache::rememberForever($this->getCacheKey($filePath), function () use ($filePath) {\n            return $this->storageCmd('exists', $filePath);\n        });\n\n        // Forget negative results\n        if (!$result) {\n            Cache::forget($this->getCacheKey($filePath));\n        }\n\n        return $result;\n    }\n\n    /**\n     * Checks if directory is empty then deletes it, three levels up to match the partition directory.\n     *\n     * @param string|null $dir Directory to check and delete if empty.\n     * @return void\n     */\n    protected function deleteEmptyDirectory($dir = null)\n    {\n        if (!$this->isDirectoryEmpty($dir)) {\n            return;\n        }\n\n        $this->storageCmd('deleteDirectory', $dir);\n\n        $dir = dirname($dir);\n        if (!$this->isDirectoryEmpty($dir)) {\n            return;\n        }\n\n        $this->storageCmd('deleteDirectory', $dir);\n\n        $dir = dirname($dir);\n        if (!$this->isDirectoryEmpty($dir)) {\n            return;\n        }\n\n        $this->storageCmd('deleteDirectory', $dir);\n    }\n\n    /**\n     * Returns true if a directory contains no files.\n     *\n     * @param string|null $dir Directory to check.\n     * @return bool\n     */\n    protected function isDirectoryEmpty($dir = null)\n    {\n        return count($this->storageCmd('allFiles', $dir)) === 0;\n    }\n\n    //\n    // Storage interface\n    //\n\n    /**\n     * Calls a method against File or Storage depending on local storage.\n     *\n     * This allows local storage outside the storage/app folder and is also good for performance. For local storage,\n     * *every* argument is prefixed with the local root path. Props to Laravel for the unified interface.\n     *\n     * @return mixed\n     */\n    protected function storageCmd()\n    {\n        $args = func_get_args();\n        $command = array_shift($args);\n        $result = null;\n\n        if ($this->isLocalStorage()) {\n            $interface = 'File';\n            $path = $this->getLocalRootPath();\n            $args = array_map(function ($value) use ($path) {\n                return $path . '/' . $value;\n            }, $args);\n\n            $result = forward_static_call_array([$interface, $command], $args);\n        } else {\n            $result = call_user_func_array([$this->getDisk(), $command], $args);\n        }\n\n        return $result;\n    }\n\n    /**\n     * Copy the Storage to local file\n     *\n     * @param string $storagePath\n     * @param string $localPath\n     * @return int The filesize of the copied file.\n     */\n    protected function copyStorageToLocal($storagePath, $localPath)\n    {\n        return FileHelper::put($localPath, $this->getDisk()->get($storagePath));\n    }\n\n    /**\n     * Copy the local file to Storage\n     *\n     * @param string $storagePath\n     * @param string $localPath\n     * @return string|bool\n     */\n    protected function copyLocalToStorage($localPath, $storagePath)\n    {\n        return $this->getDisk()->put($storagePath, FileHelper::get($localPath), $this->isPublic() ? 'public' : null);\n    }\n\n    //\n    // Configuration\n    //\n\n    /**\n     * Returns the maximum size of an uploaded file as configured in php.ini in kilobytes (rounded)\n     *\n     * @return float\n     */\n    public static function getMaxFilesize()\n    {\n        return round(UploadedFile::getMaxFilesize() / 1024);\n    }\n\n    /**\n     * Define the internal storage path, override this method to define.\n     *\n     * @return string\n     */\n    public function getStorageDirectory()\n    {\n        if ($this->isPublic()) {\n            return 'uploads/public/';\n        }\n\n        return 'uploads/protected/';\n    }\n\n    /**\n     * Define the public address for the storage path.\n     *\n     * @return string\n     */\n    public function getPublicPath()\n    {\n        if ($this->isPublic()) {\n            return 'http://localhost/uploads/public/';\n        }\n\n        return 'http://localhost/uploads/protected/';\n    }\n\n    /**\n     * Define the internal working path, override this method to define.\n     *\n     * @return string\n     */\n    public function getTempPath()\n    {\n        $path = temp_path() . '/uploads';\n\n        if (!FileHelper::isDirectory($path)) {\n            FileHelper::makeDirectory($path, 0777, true, true);\n        }\n\n        return $path;\n    }\n\n    /**\n     * Returns the storage disk the file is stored on\n     *\n     * @return FilesystemAdapter\n     */\n    public function getDisk()\n    {\n        return Storage::disk();\n    }\n\n    /**\n     * Returns true if the storage engine is local.\n     *\n     * @return bool\n     */\n    protected function isLocalStorage()\n    {\n        return FileHelper::isLocalDisk($this->getDisk());\n    }\n\n    /**\n     * Generates a partition for the file.\n     *\n     * For example, returns `/ABC/DE1/234` for an name of `ABCDE1234`.\n     *\n     * @return string\n     */\n    protected function getPartitionDirectory()\n    {\n        return implode('/', array_slice(str_split($this->disk_name, 3), 0, 3)) . '/';\n    }\n\n    /**\n     * If working with local storage, determine the absolute local path.\n     */\n    protected function getLocalRootPath(): string\n    {\n        $path = null;\n\n        if ($this->isLocalStorage()) {\n            $path = $this->getDisk()->getConfig()['root'] ?? null;\n        }\n\n        if (is_null($path)) {\n            $path = storage_path('app');\n        }\n\n        return $path;\n    }\n}\n", "<?php namespace Winter\\Storm\\Filesystem;\n\nuse Winter\\Storm\\Support\\Facades\\Config;\nuse Exception;\n\n/**\n * File definitions helper.\n * Contains file extensions for common use cases.\n *\n * @author Alexey Bobkov, Samuel Georges\n */\nclass Definitions\n{\n\n    /**\n     * Lock down the constructor for this class.\n     */\n    final public function __construct()\n    {\n    }\n\n    /**\n     * Entry point to request a definition set.\n     */\n    public static function get(string $type): array\n    {\n        return (new static)->getDefinitions($type);\n    }\n\n    /**\n     * Returns a definition set from config or from the default sets.\n     *\n     * @throws Exception If the provided definition type does not exist.\n     */\n    public function getDefinitions(string $type): array\n    {\n        if (!method_exists($this, $type)) {\n            throw new Exception(sprintf('No such definition set exists for \"%s\"', $type));\n        }\n\n        return (array) Config::get('cms.fileDefinitions.'.$type, $this->$type());\n    }\n\n    /**\n     * Determines if a path should be ignored based on the ignoreFiles and ignorePatterns definitions.\n     *\n     * Returns `true` if the path is ignored, `false` otherwise.\n     *\n     * @todo Efficiency of this method can be improved.\n     */\n    public static function isPathIgnored(string $path): bool\n    {\n        $ignoreNames = self::get('ignoreFiles');\n        $ignorePatterns = self::get('ignorePatterns');\n\n        if (in_array($path, $ignoreNames)) {\n            return true;\n        }\n\n        foreach ($ignorePatterns as $pattern) {\n            if (preg_match('/'.$pattern.'/', $path)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Files that can be safely ignored.\n     *\n     * This list can be customized with the config:\n     *\n     * `cms.fileDefinitions.ignoreFiles`\n     */\n    protected function ignoreFiles(): array\n    {\n        return [\n            '.svn',\n            '.git',\n            '.DS_Store',\n            '.AppleDouble'\n        ];\n    }\n\n    /**\n     * File patterns that can be safely ignored.\n     *\n     * This list can be customized with the config:\n     *\n     * `cms.fileDefinitions.ignorePatterns`\n     */\n    protected function ignorePatterns(): array\n    {\n        return [\n            '^\\..*'\n        ];\n    }\n\n    /**\n     * Extensions that are particularly benign.\n     *\n     * This list can be customized with config:\n     *\n     * `cms.fileDefinitions.defaultExtensions`\n     */\n    protected function defaultExtensions(): array\n    {\n        return [\n            'jpg',\n            'jpeg',\n            'bmp',\n            'png',\n            'webp',\n            'gif',\n            'svg',\n            'js',\n            'map',\n            'ico',\n            'css',\n            'less',\n            'scss',\n            'ics',\n            'odt',\n            'doc',\n            'docx',\n            'ppt',\n            'pptx',\n            'pdf',\n            'swf',\n            'txt',\n            'ods',\n            'xls',\n            'xlsx',\n            'eot',\n            'woff',\n            'woff2',\n            'ttf',\n            'flv',\n            'wmv',\n            'mp3',\n            'ogg',\n            'wav',\n            'avi',\n            'mov',\n            'mp4',\n            'mpeg',\n            'webm',\n            'mkv',\n            'rar',\n            'zip',\n        ];\n    }\n\n    /**\n     * Extensions seen as public assets.\n     *\n     * This list can be customized with config:\n     *\n     * `cms.fileDefinitions.assetExtensions`\n     */\n    protected function assetExtensions(): array\n    {\n        return [\n            'jpg',\n            'jpeg',\n            'bmp',\n            'png',\n            'webp',\n            'gif',\n            'svg',\n            'ico',\n            'css',\n            'js',\n            'woff',\n            'woff2',\n            'ttf',\n            'eot',\n            'json',\n            'md',\n            'less',\n            'sass',\n            'scss',\n        ];\n    }\n\n    /**\n     * Extensions typically used as images.\n     *\n     * This list can be customized with config:\n     *\n     * `cms.fileDefinitions.imageExtensions`\n     */\n    protected function imageExtensions(): array\n    {\n        return [\n            'jpg',\n            'jpeg',\n            'bmp',\n            'png',\n            'webp',\n            'gif',\n            'svg',\n        ];\n    }\n\n    /**\n     * Extensions typically used as video files.\n     *\n     * This list can be customized with config:\n     *\n     * `cms.fileDefinitions.videoExtensions`\n     */\n    protected function videoExtensions(): array\n    {\n        return [\n            'mp4',\n            'avi',\n            'mov',\n            'mpg',\n            'mpeg',\n            'mkv',\n            'webm',\n        ];\n    }\n\n    /**\n     * Extensions typically used as audio files.\n     *\n     * This list can be customized with config:\n     *\n     * `cms.fileDefinitions.audioExtensions`\n     */\n    protected function audioExtensions(): array\n    {\n        return [\n            'mp3',\n            'wav',\n            'wma',\n            'm4a',\n            'ogg',\n        ];\n    }\n}\n"], "filenames": ["src/Database/Attach/File.php", "src/Filesystem/Definitions.php"], "buggy_code_start_loc": [13, 115], "buggy_code_end_loc": [862, 239], "fixing_code_start_loc": [14, 116], "fixing_code_end_loc": [872, 242], "type": "CWE-79", "message": "Winter is a free, open-source content management system (CMS) based on the Laravel PHP framework. Users with the `backend.manage_branding` permission can upload SVGs as the application logo. Prior to version 1.2.3, SVG uploads were not sanitized, which could have allowed a stored cross-site scripting (XSS) attack. To exploit the vulnerability, an attacker would already need to have developer or super user level permissions in Winter CMS. This means they would already have extensive access and control within the system. Additionally, to execute the XSS, the attacker would need to convince the victim to directly visit the URL of the maliciously uploaded SVG, and the application would have to be using local storage where uploaded files are served under the same domain as the application itself instead of a CDN. This is because all SVGs in Winter CMS are rendered through an `img` tag, which prevents any payloads from being executed directly. These two factors significantly limit the potential harm of this vulnerability. This issue has been patched in v1.2.3 through the inclusion of full support for SVG uploads and automatic sanitization of uploaded SVG files. As a workaround, one may apply the patches manually.", "other": {"cve": {"id": "CVE-2023-37269", "sourceIdentifier": "security-advisories@github.com", "published": "2023-07-07T22:15:09.483", "lastModified": "2024-01-25T21:02:15.633", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Winter is a free, open-source content management system (CMS) based on the Laravel PHP framework. Users with the `backend.manage_branding` permission can upload SVGs as the application logo. Prior to version 1.2.3, SVG uploads were not sanitized, which could have allowed a stored cross-site scripting (XSS) attack. To exploit the vulnerability, an attacker would already need to have developer or super user level permissions in Winter CMS. This means they would already have extensive access and control within the system. Additionally, to execute the XSS, the attacker would need to convince the victim to directly visit the URL of the maliciously uploaded SVG, and the application would have to be using local storage where uploaded files are served under the same domain as the application itself instead of a CDN. This is because all SVGs in Winter CMS are rendered through an `img` tag, which prevents any payloads from being executed directly. These two factors significantly limit the potential harm of this vulnerability. This issue has been patched in v1.2.3 through the inclusion of full support for SVG uploads and automatic sanitization of uploaded SVG files. As a workaround, one may apply the patches manually."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.7, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:H/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 2.0, "baseSeverity": "LOW"}, "exploitabilityScore": 0.5, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wintercms:winter:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.3", "matchCriteriaId": "F876B358-C52D-448E-A902-D2FF56361DC1"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/173520/WinterCMS-1.2.2-Cross-Site-Scripting.html", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/wintercms/storm/commit/186d85d8fea2cae43afc807d39f68553c24e56be", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/wintercms/winter/commit/fa50b4c7489b67ea80072f8ac9fe5294fce1df1c", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/wintercms/winter/releases/tag/v1.2.3", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/wintercms/winter/security/advisories/GHSA-wjw2-4j7j-6gc3", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/wintercms/storm/commit/186d85d8fea2cae43afc807d39f68553c24e56be"}}