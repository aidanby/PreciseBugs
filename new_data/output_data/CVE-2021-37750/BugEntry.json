{"buggy_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* kdc/do_tgs_req.c - KDC Routines to deal with TGS_REQ's */\n/*\n * Copyright 1990, 1991, 2001, 2007, 2008, 2009, 2013, 2014 by the\n * Massachusetts Institute of Technology.  All Rights Reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n/*\n * Copyright (c) 2006-2008, Novell, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *   * The copyright holder's name is not used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"k5-int.h\"\n\n#include <syslog.h>\n#ifdef HAVE_NETINET_IN_H\n#include <sys/types.h>\n#include <netinet/in.h>\n#ifndef hpux\n#include <arpa/inet.h>\n#endif\n#endif\n\n#include \"kdc_util.h\"\n#include \"kdc_audit.h\"\n#include \"policy.h\"\n#include \"extern.h\"\n#include \"adm_proto.h\"\n#include <ctype.h>\n\nstatic krb5_error_code\nfind_alternate_tgs(kdc_realm_t *, krb5_principal, krb5_db_entry **,\n                   const char**);\n\nstatic krb5_error_code\nprepare_error_tgs(struct kdc_request_state *, krb5_kdc_req *,krb5_ticket *,int,\n                  krb5_principal,krb5_data **,const char *, krb5_pa_data **);\n\nstatic krb5_error_code\ndecrypt_2ndtkt(kdc_realm_t *, krb5_kdc_req *, krb5_flags, const krb5_ticket **,\n               krb5_db_entry **, krb5_keyblock **, const char **);\n\nstatic krb5_error_code\ngen_session_key(kdc_realm_t *, krb5_kdc_req *, krb5_db_entry *,\n                krb5_keyblock *, const char **);\n\nstatic krb5_int32\nfind_referral_tgs(kdc_realm_t *, krb5_kdc_req *, krb5_principal *);\n\nstatic krb5_error_code\ndb_get_svc_princ(krb5_context, krb5_principal, krb5_flags,\n                 krb5_db_entry **, const char **);\n\nstatic krb5_error_code\nsearch_sprinc(kdc_realm_t *, krb5_kdc_req *, krb5_flags,\n              krb5_db_entry **, const char **);\n\n/*ARGSUSED*/\nkrb5_error_code\nprocess_tgs_req(krb5_kdc_req *request, krb5_data *pkt,\n                const krb5_fulladdr *from, kdc_realm_t *kdc_active_realm,\n                krb5_data **response)\n{\n    krb5_keyblock * subkey = 0;\n    krb5_keyblock *header_key = NULL;\n    krb5_keyblock *stkt_server_key = NULL;\n    krb5_keyblock *subject_key;\n    krb5_db_entry *server = NULL;\n    krb5_db_entry *stkt_server = NULL;\n    krb5_db_entry *subject_server;\n    krb5_kdc_rep reply;\n    krb5_enc_kdc_rep_part reply_encpart;\n    krb5_ticket ticket_reply, *header_ticket = 0;\n    const krb5_ticket *stkt = NULL;\n    krb5_enc_tkt_part enc_tkt_reply;\n    int newtransited = 0;\n    krb5_error_code retval = 0;\n    krb5_keyblock server_keyblock, *encrypting_key;\n    krb5_timestamp kdc_time, authtime = 0;\n    krb5_keyblock session_key, local_tgt_key;\n    krb5_keyblock *reply_key = NULL;\n    krb5_principal cprinc = NULL, sprinc = NULL, altcprinc = NULL;\n    krb5_const_principal authdata_client;\n    krb5_principal stkt_authdata_client = NULL;\n    krb5_last_req_entry *nolrarray[2], nolrentry;\n    int errcode;\n    const char        *status = 0;\n    krb5_enc_tkt_part *header_enc_tkt = NULL; /* TGT */\n    krb5_enc_tkt_part *subject_tkt = NULL; /* TGT or evidence ticket */\n    krb5_db_entry *client = NULL, *header_server = NULL;\n    krb5_db_entry *local_tgt, *local_tgt_storage = NULL;\n    krb5_pa_s4u_x509_user *s4u_x509_user = NULL; /* protocol transition request */\n    krb5_authdata **kdc_issued_auth_data = NULL; /* auth data issued by KDC */\n    unsigned int c_flags = 0, s_flags = 0;       /* client/server KDB flags */\n    krb5_boolean is_referral, is_crossrealm;\n    const char *emsg = NULL;\n    krb5_kvno ticket_kvno = 0;\n    struct kdc_request_state *state = NULL;\n    krb5_pa_data *pa_tgs_req; /*points into request*/\n    krb5_data scratch;\n    krb5_pa_data **e_data = NULL;\n    krb5_audit_state *au_state = NULL;\n    krb5_data **auth_indicators = NULL;\n    void *ad_info = NULL, *stkt_ad_info = NULL;\n\n    memset(&reply, 0, sizeof(reply));\n    memset(&reply_encpart, 0, sizeof(reply_encpart));\n    memset(&ticket_reply, 0, sizeof(ticket_reply));\n    memset(&enc_tkt_reply, 0, sizeof(enc_tkt_reply));\n    memset(&server_keyblock, 0, sizeof(server_keyblock));\n    memset(&local_tgt_key, 0, sizeof(local_tgt_key));\n    session_key.contents = NULL;\n\n    /* Save pointer to client-requested service principal, in case of\n     * errors before a successful call to search_sprinc(). */\n    sprinc = request->server;\n\n    if (request->msg_type != KRB5_TGS_REQ) {\n        krb5_free_kdc_req(kdc_context, request);\n        return KRB5_BADMSGTYPE;\n    }\n\n    errcode = kdc_make_rstate(kdc_active_realm, &state);\n    if (errcode != 0)\n        goto cleanup;\n\n    /* Initialize audit state. */\n    errcode = kau_init_kdc_req(kdc_context, request, from, &au_state);\n    if (errcode)\n        goto cleanup;\n\n    /* Seed the audit trail with the request ID and basic information. */\n    kau_tgs_req(kdc_context, TRUE, au_state);\n\n    errcode = kdc_process_tgs_req(kdc_active_realm,\n                                  request, from, pkt, &header_ticket,\n                                  &header_server, &header_key, &subkey,\n                                  &pa_tgs_req);\n    if (header_ticket && header_ticket->enc_part2)\n        cprinc = header_ticket->enc_part2->client;\n\n    if (errcode) {\n        status = \"PROCESS_TGS\";\n        goto cleanup;\n    }\n\n    if (!header_ticket) {\n        errcode = KRB5_NO_TKT_SUPPLIED;        /* XXX? */\n        goto cleanup;\n    }\n    errcode = kau_make_tkt_id(kdc_context, header_ticket,\n                              &au_state->tkt_in_id);\n    if (errcode)\n        goto cleanup;\n\n    scratch.length = pa_tgs_req->length;\n    scratch.data = (char *) pa_tgs_req->contents;\n    errcode = kdc_find_fast(&request, &scratch, subkey,\n                            header_ticket->enc_part2->session, state, NULL);\n    /* Reset sprinc because kdc_find_fast() can replace request. */\n    sprinc = request->server;\n    if (errcode !=0) {\n        status = \"FIND_FAST\";\n        goto cleanup;\n    }\n\n    errcode = get_local_tgt(kdc_context, &sprinc->realm, header_server,\n                            &local_tgt, &local_tgt_storage, &local_tgt_key);\n    if (errcode) {\n        status = \"GET_LOCAL_TGT\";\n        goto cleanup;\n    }\n\n    /* Ignore (for now) the request modification due to FAST processing. */\n    au_state->request = request;\n\n    /*\n     * Pointer to the encrypted part of the header ticket, which may be\n     * replaced to point to the encrypted part of the evidence ticket\n     * if constrained delegation is used. This simplifies the number of\n     * special cases for constrained delegation.\n     */\n    header_enc_tkt = header_ticket->enc_part2;\n\n    /*\n     * We've already dealt with the AP_REQ authentication, so we can\n     * use header_ticket freely.  The encrypted part (if any) has been\n     * decrypted with the session key.\n     */\n\n    au_state->stage = SRVC_PRINC;\n\n    /* XXX make sure server here has the proper realm...taken from AP_REQ\n       header? */\n\n    if (isflagset(request->kdc_options, KDC_OPT_CANONICALIZE)) {\n        setflag(c_flags, KRB5_KDB_FLAG_CANONICALIZE);\n        setflag(s_flags, KRB5_KDB_FLAG_CANONICALIZE);\n    }\n\n    errcode = search_sprinc(kdc_active_realm, request, s_flags, &server,\n                            &status);\n    if (errcode != 0)\n        goto cleanup;\n    sprinc = server->princ;\n\n    /* If we got a cross-realm TGS which is not the requested server, we are\n     * issuing a referral (or alternate TGT, which we treat similarly). */\n    is_referral = is_cross_tgs_principal(server->princ) &&\n        !krb5_principal_compare(kdc_context, request->server, server->princ);\n\n    au_state->stage = VALIDATE_POL;\n\n    if ((errcode = krb5_timeofday(kdc_context, &kdc_time)))\n        goto cleanup;\n\n    is_crossrealm = !data_eq(header_server->princ->realm, sprinc->realm);\n    if (is_crossrealm)\n        setflag(c_flags, KRB5_KDB_FLAG_CROSS_REALM);\n    if (is_referral)\n        setflag(c_flags, KRB5_KDB_FLAG_ISSUING_REFERRAL);\n\n    /* Check for protocol transition */\n    errcode = kdc_process_s4u2self_req(kdc_active_realm, request, server,\n                                       subkey, header_enc_tkt->session,\n                                       &s4u_x509_user, &client, &status);\n    if (s4u_x509_user != NULL || errcode != 0) {\n        if (s4u_x509_user != NULL)\n            au_state->s4u2self_user = s4u_x509_user->user_id.user;\n        au_state->status = status;\n        kau_s4u2self(kdc_context, errcode ? FALSE : TRUE, au_state);\n        au_state->s4u2self_user = NULL;\n    }\n\n    /* For user-to-user and S4U2Proxy requests, decrypt the second ticket. */\n    errcode = decrypt_2ndtkt(kdc_active_realm, request, c_flags,\n                             &stkt, &stkt_server, &stkt_server_key, &status);\n    if (errcode)\n        goto cleanup;\n\n    retval = validate_tgs_request(kdc_active_realm, request, server,\n                                  header_ticket, stkt, stkt_server, kdc_time,\n                                  s4u_x509_user, client, is_crossrealm,\n                                  is_referral, &status, &e_data);\n    if (retval) {\n        if (retval == KDC_ERR_POLICY || retval == KDC_ERR_BADOPTION)\n            au_state->violation = PROT_CONSTRAINT;\n        errcode = retval + ERROR_TABLE_BASE_krb5;\n        goto cleanup;\n    }\n\n    if (errcode)\n        goto cleanup;\n\n    if (s4u_x509_user != NULL && client == NULL) {\n        /*\n         * For an S4U2Self referral request (the requesting service is\n         * following a referral back to its own realm), the authdata in the\n         * header ticket should be for the requested client.\n         */\n        setflag(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION);\n        authdata_client = s4u_x509_user->user_id.user;\n    } else {\n        /* Otherwise (including for initial S4U2Self requests), the authdata\n         * should be for the header ticket client. */\n        authdata_client = header_enc_tkt->client;\n    }\n    errcode = krb5_db_get_authdata_info(kdc_context, c_flags,\n                                        header_enc_tkt->authorization_data,\n                                        authdata_client, request->server,\n                                        header_key, &local_tgt_key, local_tgt,\n                                        header_enc_tkt->times.authtime,\n                                        &ad_info, NULL);\n    if (errcode && errcode != KRB5_PLUGIN_OP_NOTSUPP)\n        goto cleanup;\n\n    /* Flag all S4U2Self requests now that we have checked the authdata. */\n    if (s4u_x509_user != NULL)\n        setflag(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION);\n\n    if (isflagset(request->kdc_options, KDC_OPT_CNAME_IN_ADDL_TKT)) {\n        /* Do constrained delegation protocol and authorization checks. */\n        setflag(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION);\n\n        errcode = kdc_process_s4u2proxy_req(kdc_active_realm, c_flags, request,\n                                            stkt->enc_part2, local_tgt,\n                                            &local_tgt_key, stkt_server,\n                                            stkt_server_key,\n                                            header_ticket->enc_part2->client,\n                                            server, request->server, ad_info,\n                                            &stkt_ad_info,\n                                            &stkt_authdata_client,\n                                            &status);\n        if (errcode == KDC_ERR_POLICY || errcode == KDC_ERR_BADOPTION)\n            au_state->violation = PROT_CONSTRAINT;\n        else if (errcode)\n            au_state->violation = LOCAL_POLICY;\n        au_state->status = status;\n        retval = kau_make_tkt_id(kdc_context, stkt, &au_state->evid_tkt_id);\n        if (retval) {\n            errcode = retval;\n            goto cleanup;\n        }\n        kau_s4u2proxy(kdc_context, errcode ? FALSE : TRUE, au_state);\n        if (errcode)\n            goto cleanup;\n\n        assert(krb5_is_tgs_principal(header_ticket->server));\n\n        /* Use the parsed authdata from the second ticket during authdata\n         * handling. */\n        krb5_db_free_authdata_info(kdc_context, ad_info);\n        ad_info = stkt_ad_info;\n        stkt_ad_info = NULL;\n    }\n\n    au_state->stage = ISSUE_TKT;\n\n    errcode = gen_session_key(kdc_active_realm, request, server, &session_key,\n                              &status);\n    if (errcode)\n        goto cleanup;\n\n    /*\n     * subject_tkt will refer to the evidence ticket (for constrained\n     * delegation) or the TGT. The distinction from header_enc_tkt is\n     * necessary because the TGS signature only protects some fields:\n     * the others could be forged by a malicious server.\n     */\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        subject_tkt = stkt->enc_part2;\n        subject_server = stkt_server;\n        subject_key = stkt_server_key;\n    } else {\n        subject_tkt = header_enc_tkt;\n        subject_server = header_server;\n        subject_key = header_key;\n    }\n    authtime = subject_tkt->times.authtime;\n\n    /* Extract and check auth indicators from the subject ticket, except for\n     * S4U2Self requests (where the client didn't authenticate). */\n    if (s4u_x509_user == NULL) {\n        errcode = get_auth_indicators(kdc_context, subject_tkt, local_tgt,\n                                      &local_tgt_key, &auth_indicators);\n        if (errcode) {\n            status = \"GET_AUTH_INDICATORS\";\n            goto cleanup;\n        }\n\n        errcode = check_indicators(kdc_context, server, auth_indicators);\n        if (errcode) {\n            status = \"HIGHER_AUTHENTICATION_REQUIRED\";\n            goto cleanup;\n        }\n    }\n\n    if (is_referral)\n        ticket_reply.server = server->princ;\n    else\n        ticket_reply.server = request->server; /* XXX careful for realm... */\n\n    enc_tkt_reply.flags = get_ticket_flags(request->kdc_options, client,\n                                           server, header_enc_tkt);\n    enc_tkt_reply.times.starttime = 0;\n\n    /* OK_TO_AUTH_AS_DELEGATE must be set on the service requesting S4U2Self\n     * for forwardable tickets to be issued. */\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&\n        !is_referral &&\n        !isflagset(server->attributes, KRB5_KDB_OK_TO_AUTH_AS_DELEGATE))\n        clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n\n    /* don't use new addresses unless forwarded, see below */\n\n    enc_tkt_reply.caddrs = header_enc_tkt->caddrs;\n    /* noaddrarray[0] = 0; */\n    reply_encpart.caddrs = 0;/* optional...don't put it in */\n    reply_encpart.enc_padata = NULL;\n\n    /*\n     * It should be noted that local policy may affect the\n     * processing of any of these flags.  For example, some\n     * realms may refuse to issue renewable tickets\n     */\n\n    if (isflagset(request->kdc_options, KDC_OPT_FORWARDED) ||\n        isflagset(request->kdc_options, KDC_OPT_PROXY)) {\n\n        /* include new addresses in ticket & reply */\n\n        enc_tkt_reply.caddrs = request->addresses;\n        reply_encpart.caddrs = request->addresses;\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_POSTDATED))\n        enc_tkt_reply.times.starttime = request->from;\n    else\n        enc_tkt_reply.times.starttime = kdc_time;\n\n    if (isflagset(request->kdc_options, KDC_OPT_VALIDATE)) {\n        assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);\n        /* BEWARE of allocation hanging off of ticket & enc_part2, it belongs\n           to the caller */\n        ticket_reply = *(header_ticket);\n        enc_tkt_reply = *(header_ticket->enc_part2);\n        enc_tkt_reply.authorization_data = NULL;\n        clear(enc_tkt_reply.flags, TKT_FLG_INVALID);\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_RENEW)) {\n        krb5_timestamp old_starttime;\n        krb5_deltat old_life;\n\n        assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);\n        /* BEWARE of allocation hanging off of ticket & enc_part2, it belongs\n           to the caller */\n        ticket_reply = *(header_ticket);\n        enc_tkt_reply = *(header_ticket->enc_part2);\n        enc_tkt_reply.authorization_data = NULL;\n\n        old_starttime = enc_tkt_reply.times.starttime ?\n            enc_tkt_reply.times.starttime : enc_tkt_reply.times.authtime;\n        old_life = ts_delta(enc_tkt_reply.times.endtime, old_starttime);\n\n        enc_tkt_reply.times.starttime = kdc_time;\n        enc_tkt_reply.times.endtime =\n            ts_min(header_ticket->enc_part2->times.renew_till,\n                   ts_incr(kdc_time, old_life));\n    } else {\n        /* not a renew request */\n        enc_tkt_reply.times.starttime = kdc_time;\n\n        kdc_get_ticket_endtime(kdc_active_realm, enc_tkt_reply.times.starttime,\n                               header_enc_tkt->times.endtime, request->till,\n                               client, server, &enc_tkt_reply.times.endtime);\n    }\n\n    kdc_get_ticket_renewtime(kdc_active_realm, request, header_enc_tkt, client,\n                             server, &enc_tkt_reply);\n\n    errcode = check_kdcpolicy_tgs(kdc_context, request, server, header_ticket,\n                                  auth_indicators, kdc_time,\n                                  &enc_tkt_reply.times, &status);\n    if (errcode)\n        goto cleanup;\n\n    /*\n     * Set authtime to be the same as header or evidence ticket's\n     */\n    enc_tkt_reply.times.authtime = authtime;\n\n    /* starttime is optional, and treated as authtime if not present.\n       so we can nuke it if it matches */\n    if (enc_tkt_reply.times.starttime == enc_tkt_reply.times.authtime)\n        enc_tkt_reply.times.starttime = 0;\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {\n        altcprinc = s4u_x509_user->user_id.user;\n    } else if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        /* kdc_process_s4u2proxy_req() only allows cross-realm requests if\n         * stkt_authdata_client is set. */\n        altcprinc = is_crossrealm ? stkt_authdata_client : subject_tkt->client;\n    } else {\n        altcprinc = NULL;\n    }\n    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {\n        encrypting_key = stkt->enc_part2->session;\n    } else {\n        errcode = get_first_current_key(kdc_context, server, &server_keyblock);\n        if (errcode) {\n            status = \"FINDING_SERVER_KEY\";\n            goto cleanup;\n        }\n        encrypting_key = &server_keyblock;\n    }\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        /*\n         * Don't allow authorization data to be disabled if constrained\n         * delegation is requested. We don't want to deny the server\n         * the ability to validate that delegation was used.\n         */\n        clear(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED);\n    }\n    if (isflagset(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED) == 0) {\n        /* If we are not doing protocol transition, try to look up the subject\n         * principal so that KDB modules can add additional authdata. */\n        if (!isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {\n            /* Generate authorization data so we can include it in ticket */\n            setflag(c_flags, KRB5_KDB_FLAG_INCLUDE_PAC);\n            /* Map principals from foreign (possibly non-AD) realms */\n            setflag(c_flags, KRB5_KDB_FLAG_MAP_PRINCIPALS);\n\n            assert(client == NULL); /* should not have been set already */\n\n            errcode = krb5_db_get_principal(kdc_context, subject_tkt->client,\n                                            c_flags, &client);\n        }\n    }\n\n    if (isflagset(c_flags, KRB5_KDB_FLAGS_S4U) && !is_referral)\n        enc_tkt_reply.client = altcprinc;\n    else\n        enc_tkt_reply.client = header_enc_tkt->client;\n\n    enc_tkt_reply.session = &session_key;\n    enc_tkt_reply.transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n    enc_tkt_reply.transited.tr_contents = empty_string; /* equivalent of \"\" */\n\n    /*\n     * Only add the realm of the presented tgt to the transited list if\n     * it is different than the server realm (cross-realm) and it is different\n     * than the realm of the client (since the realm of the client is already\n     * implicitly part of the transited list and should not be explicitly\n     * listed).\n     */\n    if (!is_crossrealm ||\n        krb5_realm_compare(kdc_context, header_ticket->server,\n                           enc_tkt_reply.client)) {\n        /* tgt issued by local realm or issued by realm of client */\n        enc_tkt_reply.transited = header_enc_tkt->transited;\n    } else {\n        /* tgt issued by some other realm and not the realm of the client */\n        /* assemble new transited field into allocated storage */\n        if (header_enc_tkt->transited.tr_type !=\n            KRB5_DOMAIN_X500_COMPRESS) {\n            status = \"VALIDATE_TRANSIT_TYPE\";\n            errcode = KRB5KDC_ERR_TRTYPE_NOSUPP;\n            goto cleanup;\n        }\n        memset(&enc_tkt_reply.transited, 0, sizeof(enc_tkt_reply.transited));\n        enc_tkt_reply.transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n        if ((errcode =\n             add_to_transited(&header_enc_tkt->transited.tr_contents,\n                              &enc_tkt_reply.transited.tr_contents,\n                              header_ticket->server,\n                              enc_tkt_reply.client,\n                              request->server))) {\n            status = \"ADD_TO_TRANSITED_LIST\";\n            goto cleanup;\n        }\n        newtransited = 1;\n    }\n    if (!isflagset (request->kdc_options, KDC_OPT_DISABLE_TRANSITED_CHECK)) {\n        errcode = kdc_check_transited_list (kdc_active_realm,\n                                            &enc_tkt_reply.transited.tr_contents,\n                                            krb5_princ_realm (kdc_context, header_enc_tkt->client),\n                                            krb5_princ_realm (kdc_context, request->server));\n        if (errcode == 0) {\n            setflag (enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED);\n        } else {\n            log_tgs_badtrans(kdc_context, cprinc, sprinc,\n                             &enc_tkt_reply.transited.tr_contents, errcode);\n        }\n    } else\n        krb5_klog_syslog(LOG_INFO, _(\"not checking transit path\"));\n    if (kdc_active_realm->realm_reject_bad_transit &&\n        !isflagset(enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED)) {\n        errcode = KRB5KDC_ERR_POLICY;\n        status = \"BAD_TRANSIT\";\n        au_state->violation = LOCAL_POLICY;\n        goto cleanup;\n    }\n\n    errcode = handle_authdata(kdc_context, c_flags, client, server,\n                              subject_server, local_tgt, &local_tgt_key,\n                              subkey != NULL ? subkey :\n                              header_ticket->enc_part2->session,\n                              encrypting_key, subject_key, pkt, request,\n                              altcprinc, ad_info, subject_tkt,\n                              &auth_indicators, &enc_tkt_reply);\n    if (errcode) {\n        krb5_klog_syslog(LOG_INFO, _(\"TGS_REQ : handle_authdata (%d)\"),\n                         errcode);\n        status = \"HANDLE_AUTHDATA\";\n        goto cleanup;\n    }\n\n    ticket_reply.enc_part2 = &enc_tkt_reply;\n\n    /* If we are doing user-to-user authentication, encrypt the ticket using\n     * the session key of the second ticket. */\n    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {\n        ticket_kvno = 0;\n        ticket_reply.enc_part.enctype = stkt->enc_part2->session->enctype;\n        kau_u2u(kdc_context, TRUE, au_state);\n    } else {\n        ticket_kvno = current_kvno(server);\n    }\n\n    errcode = krb5_encrypt_tkt_part(kdc_context, encrypting_key,\n                                    &ticket_reply);\n    if (errcode)\n        goto cleanup;\n    ticket_reply.enc_part.kvno = ticket_kvno;\n    /* Start assembling the response */\n    au_state->stage = ENCR_REP;\n    reply.msg_type = KRB5_TGS_REP;\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&\n        krb5int_find_pa_data(kdc_context, request->padata,\n                             KRB5_PADATA_S4U_X509_USER) != NULL) {\n        errcode = kdc_make_s4u2self_rep(kdc_context,\n                                        subkey,\n                                        header_ticket->enc_part2->session,\n                                        s4u_x509_user,\n                                        &reply,\n                                        &reply_encpart);\n        if (errcode)\n            au_state->status = status;\n        kau_s4u2self(kdc_context, errcode ? FALSE : TRUE, au_state);\n        if (errcode)\n            goto cleanup;\n    }\n\n    reply.client = enc_tkt_reply.client;\n    reply.enc_part.kvno = 0;/* We are using the session key */\n    reply.ticket = &ticket_reply;\n\n    reply_encpart.session = &session_key;\n    reply_encpart.nonce = request->nonce;\n\n    /* copy the time fields */\n    reply_encpart.times = enc_tkt_reply.times;\n\n    nolrentry.lr_type = KRB5_LRQ_NONE;\n    nolrentry.value = 0;\n    nolrentry.magic = 0;\n    nolrarray[0] = &nolrentry;\n    nolrarray[1] = 0;\n    reply_encpart.last_req = nolrarray;        /* not available for TGS reqs */\n    reply_encpart.key_exp = 0;/* ditto */\n    reply_encpart.flags = enc_tkt_reply.flags;\n    reply_encpart.server = ticket_reply.server;\n\n    /* use the session key in the ticket, unless there's a subsession key\n       in the AP_REQ */\n    reply.enc_part.enctype = subkey ? subkey->enctype :\n        header_ticket->enc_part2->session->enctype;\n    errcode  = kdc_fast_response_handle_padata(state, request, &reply,\n                                               subkey ? subkey->enctype : header_ticket->enc_part2->session->enctype);\n    if (errcode)\n        goto cleanup;\n    errcode =kdc_fast_handle_reply_key(state,\n                                       subkey?subkey:header_ticket->enc_part2->session, &reply_key);\n    if (errcode)\n        goto cleanup;\n    errcode = return_enc_padata(kdc_context, pkt, request,\n                                reply_key, server, &reply_encpart,\n                                is_referral &&\n                                isflagset(s_flags,\n                                          KRB5_KDB_FLAG_CANONICALIZE));\n    if (errcode) {\n        status = \"KDC_RETURN_ENC_PADATA\";\n        goto cleanup;\n    }\n\n    errcode = kau_make_tkt_id(kdc_context, &ticket_reply, &au_state->tkt_out_id);\n    if (errcode)\n        goto cleanup;\n\n    if (kdc_fast_hide_client(state))\n        reply.client = (krb5_principal)krb5_anonymous_principal();\n    errcode = krb5_encode_kdc_rep(kdc_context, KRB5_TGS_REP, &reply_encpart,\n                                  subkey ? 1 : 0,\n                                  reply_key,\n                                  &reply, response);\n    if (!errcode)\n        status = \"ISSUE\";\n\n    memset(ticket_reply.enc_part.ciphertext.data, 0,\n           ticket_reply.enc_part.ciphertext.length);\n    free(ticket_reply.enc_part.ciphertext.data);\n    /* these parts are left on as a courtesy from krb5_encode_kdc_rep so we\n       can use them in raw form if needed.  But, we don't... */\n    memset(reply.enc_part.ciphertext.data, 0,\n           reply.enc_part.ciphertext.length);\n    free(reply.enc_part.ciphertext.data);\n\ncleanup:\n    if (status == NULL)\n        status = \"UNKNOWN_REASON\";\n    krb5_free_keyblock_contents(kdc_context, &server_keyblock);\n    if (reply_key)\n        krb5_free_keyblock(kdc_context, reply_key);\n    if (stkt_server_key)\n        krb5_free_keyblock(kdc_context, stkt_server_key);\n    if (errcode)\n        emsg = krb5_get_error_message (kdc_context, errcode);\n\n    if (au_state != NULL) {\n        au_state->status = status;\n        if (!errcode)\n            au_state->reply = &reply;\n        kau_tgs_req(kdc_context, errcode ? FALSE : TRUE, au_state);\n        kau_free_kdc_req(au_state);\n    }\n\n    log_tgs_req(kdc_context, from, request, &reply, cprinc,\n                sprinc, altcprinc, authtime,\n                c_flags, status, errcode, emsg);\n    if (errcode) {\n        krb5_free_error_message (kdc_context, emsg);\n        emsg = NULL;\n    }\n\n    if (errcode && state != NULL) {\n        int got_err = 0;\n        if (status == 0) {\n            status = krb5_get_error_message (kdc_context, errcode);\n            got_err = 1;\n        }\n        errcode -= ERROR_TABLE_BASE_krb5;\n        if (errcode < 0 || errcode > KRB_ERR_MAX)\n            errcode = KRB_ERR_GENERIC;\n\n        retval = prepare_error_tgs(state, request, header_ticket, errcode,\n                                   (server != NULL) ? server->princ : NULL,\n                                   response, status, e_data);\n        if (got_err) {\n            krb5_free_error_message (kdc_context, status);\n            status = 0;\n        }\n    }\n\n    if (header_ticket != NULL)\n        krb5_free_ticket(kdc_context, header_ticket);\n    if (request != NULL)\n        krb5_free_kdc_req(kdc_context, request);\n    if (state)\n        kdc_free_rstate(state);\n    krb5_db_free_principal(kdc_context, server);\n    krb5_db_free_principal(kdc_context, stkt_server);\n    krb5_db_free_principal(kdc_context, header_server);\n    krb5_db_free_principal(kdc_context, client);\n    krb5_db_free_principal(kdc_context, local_tgt_storage);\n    if (local_tgt_key.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &local_tgt_key);\n    if (session_key.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &session_key);\n    if (newtransited)\n        free(enc_tkt_reply.transited.tr_contents.data);\n    if (s4u_x509_user != NULL)\n        krb5_free_pa_s4u_x509_user(kdc_context, s4u_x509_user);\n    if (kdc_issued_auth_data != NULL)\n        krb5_free_authdata(kdc_context, kdc_issued_auth_data);\n    if (subkey != NULL)\n        krb5_free_keyblock(kdc_context, subkey);\n    if (header_key != NULL)\n        krb5_free_keyblock(kdc_context, header_key);\n    if (reply.padata)\n        krb5_free_pa_data(kdc_context, reply.padata);\n    if (reply_encpart.enc_padata)\n        krb5_free_pa_data(kdc_context, reply_encpart.enc_padata);\n    if (enc_tkt_reply.authorization_data != NULL)\n        krb5_free_authdata(kdc_context, enc_tkt_reply.authorization_data);\n    krb5_free_pa_data(kdc_context, e_data);\n    k5_free_data_ptr_list(auth_indicators);\n    krb5_db_free_authdata_info(kdc_context, ad_info);\n    krb5_db_free_authdata_info(kdc_context, stkt_ad_info);\n    krb5_free_principal(kdc_context, stkt_authdata_client);\n\n    return retval;\n}\n\nstatic krb5_error_code\nprepare_error_tgs (struct kdc_request_state *state,\n                   krb5_kdc_req *request, krb5_ticket *ticket, int error,\n                   krb5_principal canon_server,\n                   krb5_data **response, const char *status,\n                   krb5_pa_data **e_data)\n{\n    krb5_error errpkt;\n    krb5_error_code retval = 0;\n    krb5_data *scratch, *e_data_asn1 = NULL, *fast_edata = NULL;\n    kdc_realm_t *kdc_active_realm = state->realm_data;\n\n    errpkt.magic = KV5M_ERROR;\n    errpkt.ctime = 0;\n    errpkt.cusec = 0;\n\n    if ((retval = krb5_us_timeofday(kdc_context, &errpkt.stime,\n                                    &errpkt.susec)))\n        return(retval);\n    errpkt.error = error;\n    errpkt.server = request->server;\n    if (ticket && ticket->enc_part2)\n        errpkt.client = ticket->enc_part2->client;\n    else\n        errpkt.client = NULL;\n    errpkt.text.length = strlen(status);\n    if (!(errpkt.text.data = strdup(status)))\n        return ENOMEM;\n\n    if (!(scratch = (krb5_data *)malloc(sizeof(*scratch)))) {\n        free(errpkt.text.data);\n        return ENOMEM;\n    }\n\n    if (e_data != NULL) {\n        retval = encode_krb5_padata_sequence(e_data, &e_data_asn1);\n        if (retval) {\n            free(scratch);\n            free(errpkt.text.data);\n            return retval;\n        }\n        errpkt.e_data = *e_data_asn1;\n    } else\n        errpkt.e_data = empty_data();\n\n    retval = kdc_fast_handle_error(kdc_context, state, request, e_data,\n                                   &errpkt, &fast_edata);\n    if (retval) {\n        free(scratch);\n        free(errpkt.text.data);\n        krb5_free_data(kdc_context, e_data_asn1);\n        return retval;\n    }\n    if (fast_edata)\n        errpkt.e_data = *fast_edata;\n    if (kdc_fast_hide_client(state) && errpkt.client != NULL)\n        errpkt.client = (krb5_principal)krb5_anonymous_principal();\n    retval = krb5_mk_error(kdc_context, &errpkt, scratch);\n    free(errpkt.text.data);\n    krb5_free_data(kdc_context, e_data_asn1);\n    krb5_free_data(kdc_context, fast_edata);\n    if (retval)\n        free(scratch);\n    else\n        *response = scratch;\n\n    return retval;\n}\n\n/* KDC options that require a second ticket */\n#define STKT_OPTIONS (KDC_OPT_CNAME_IN_ADDL_TKT | KDC_OPT_ENC_TKT_IN_SKEY)\n/*\n * If req is a second-ticket request and a second ticket is present, decrypt\n * it.  Set *stkt_out to an alias to the ticket with populated enc_part2.  Set\n * *server_out to the server DB entry and *key_out to the ticket decryption\n * key.\n */\nstatic krb5_error_code\ndecrypt_2ndtkt(kdc_realm_t *kdc_active_realm, krb5_kdc_req *req,\n               krb5_flags flags, const krb5_ticket **stkt_out,\n               krb5_db_entry **server_out, krb5_keyblock **key_out,\n               const char **status)\n{\n    krb5_error_code retval;\n    krb5_db_entry *server = NULL;\n    krb5_keyblock *key = NULL;\n    krb5_kvno kvno;\n    krb5_ticket *stkt;\n\n    *stkt_out = NULL;\n    *server_out = NULL;\n    *key_out = NULL;\n\n    if (!(req->kdc_options & STKT_OPTIONS) || req->second_ticket == NULL ||\n        req->second_ticket[0] == NULL)\n        return 0;\n\n    stkt = req->second_ticket[0];\n    retval = kdc_get_server_key(kdc_context, stkt, flags, TRUE,\n                                &server, &key, &kvno);\n    if (retval != 0) {\n        *status = \"2ND_TKT_SERVER\";\n        goto cleanup;\n    }\n    retval = krb5_decrypt_tkt_part(kdc_context, key, stkt);\n    if (retval != 0) {\n        *status = \"2ND_TKT_DECRYPT\";\n        goto cleanup;\n    }\n    *stkt_out = stkt;\n    *server_out = server;\n    *key_out = key;\n    server = NULL;\n    key = NULL;\n\ncleanup:\n    krb5_db_free_principal(kdc_context, server);\n    krb5_free_keyblock(kdc_context, key);\n    return retval;\n}\n\nstatic krb5_error_code\nget_2ndtkt_enctype(kdc_realm_t *kdc_active_realm, krb5_kdc_req *req,\n                   krb5_enctype *useenctype, const char **status)\n{\n    krb5_enctype etype;\n    krb5_ticket *stkt = req->second_ticket[0];\n    int i;\n\n    etype = stkt->enc_part2->session->enctype;\n    if (!krb5_c_valid_enctype(etype)) {\n        *status = \"BAD_ETYPE_IN_2ND_TKT\";\n        return KRB5KDC_ERR_ETYPE_NOSUPP;\n    }\n    for (i = 0; i < req->nktypes; i++) {\n        if (req->ktype[i] == etype) {\n            *useenctype = etype;\n            break;\n        }\n    }\n    return 0;\n}\n\nstatic krb5_error_code\ngen_session_key(kdc_realm_t *kdc_active_realm, krb5_kdc_req *req,\n                krb5_db_entry *server, krb5_keyblock *skey,\n                const char **status)\n{\n    krb5_error_code retval;\n    krb5_enctype useenctype = 0;\n\n    /*\n     * Some special care needs to be taken in the user-to-user\n     * case, since we don't know what keytypes the application server\n     * which is doing user-to-user authentication can support.  We\n     * know that it at least must be able to support the encryption\n     * type of the session key in the TGT, since otherwise it won't be\n     * able to decrypt the U2U ticket!  So we use that in preference\n     * to anything else.\n     */\n    if (req->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        retval = get_2ndtkt_enctype(kdc_active_realm, req, &useenctype,\n                                    status);\n        if (retval != 0)\n            return retval;\n    }\n    if (useenctype == 0) {\n        useenctype = select_session_keytype(kdc_active_realm, server,\n                                            req->nktypes,\n                                            req->ktype);\n    }\n    if (useenctype == 0) {\n        /* unsupported ktype */\n        *status = \"BAD_ENCRYPTION_TYPE\";\n        return KRB5KDC_ERR_ETYPE_NOSUPP;\n    }\n\n    return krb5_c_make_random_key(kdc_context, useenctype, skey);\n}\n\n/*\n * The request seems to be for a ticket-granting service somewhere else,\n * but we don't have a ticket for the final TGS.  Try to give the requestor\n * some intermediate realm.\n */\nstatic krb5_error_code\nfind_alternate_tgs(kdc_realm_t *kdc_active_realm, krb5_principal princ,\n                   krb5_db_entry **server_ptr, const char **status)\n{\n    krb5_error_code retval;\n    krb5_principal *plist = NULL, *pl2;\n    krb5_data tmp;\n    krb5_db_entry *server = NULL;\n\n    *server_ptr = NULL;\n    assert(is_cross_tgs_principal(princ));\n    if ((retval = krb5_walk_realm_tree(kdc_context,\n                                       krb5_princ_realm(kdc_context, princ),\n                                       krb5_princ_component(kdc_context, princ, 1),\n                                       &plist, KRB5_REALM_BRANCH_CHAR))) {\n        goto cleanup;\n    }\n    /* move to the end */\n    for (pl2 = plist; *pl2; pl2++);\n\n    /* the first entry in this array is for krbtgt/local@local, so we\n       ignore it */\n    while (--pl2 > plist) {\n        tmp = *krb5_princ_realm(kdc_context, *pl2);\n        krb5_princ_set_realm(kdc_context, *pl2,\n                             krb5_princ_realm(kdc_context, princ));\n        retval = db_get_svc_princ(kdc_context, *pl2, 0, &server, status);\n        krb5_princ_set_realm(kdc_context, *pl2, &tmp);\n        if (retval == KRB5_KDB_NOENTRY)\n            continue;\n        else if (retval)\n            goto cleanup;\n\n        log_tgs_alt_tgt(kdc_context, server->princ);\n        *server_ptr = server;\n        server = NULL;\n        goto cleanup;\n    }\ncleanup:\n    if (retval == 0 && *server_ptr == NULL)\n        retval = KRB5_KDB_NOENTRY;\n    if (retval != 0)\n        *status = \"UNKNOWN_SERVER\";\n\n    krb5_free_realm_tree(kdc_context, plist);\n    krb5_db_free_principal(kdc_context, server);\n    return retval;\n}\n\n/* Return true if item is an element of the space/comma-separated list. */\nstatic krb5_boolean\nin_list(const char *list, const char *item)\n{\n    const char *p;\n    int len = strlen(item);\n\n    if (list == NULL)\n        return FALSE;\n    for (p = strstr(list, item); p != NULL; p = strstr(p + 1, item)) {\n        if ((p == list || isspace((unsigned char)p[-1]) || p[-1] == ',') &&\n            (p[len] == '\\0' || isspace((unsigned char)p[len]) ||\n             p[len] == ','))\n                return TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Check whether the request satisfies the conditions for generating a referral\n * TGT.  The caller checks whether the hostname component looks like a FQDN.\n */\nstatic krb5_boolean\nis_referral_req(kdc_realm_t *kdc_active_realm, krb5_kdc_req *request)\n{\n    krb5_boolean ret = FALSE;\n    char *stype = NULL;\n    char *hostbased = kdc_active_realm->realm_hostbased;\n    char *no_referral = kdc_active_realm->realm_no_referral;\n\n    if (!(request->kdc_options & KDC_OPT_CANONICALIZE))\n        return FALSE;\n\n    if (request->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY)\n        return FALSE;\n\n    if (krb5_princ_size(kdc_context, request->server) != 2)\n        return FALSE;\n\n    stype = data2string(krb5_princ_component(kdc_context, request->server, 0));\n    if (stype == NULL)\n        return FALSE;\n    switch (krb5_princ_type(kdc_context, request->server)) {\n    case KRB5_NT_UNKNOWN:\n        /* Allow referrals for NT-UNKNOWN principals, if configured. */\n        if (!in_list(hostbased, stype) && !in_list(hostbased, \"*\"))\n            goto cleanup;\n        /* FALLTHROUGH */\n    case KRB5_NT_SRV_HST:\n    case KRB5_NT_SRV_INST:\n        /* Deny referrals for specific service types, if configured. */\n        if (in_list(no_referral, stype) || in_list(no_referral, \"*\"))\n            goto cleanup;\n        ret = TRUE;\n        break;\n    default:\n        goto cleanup;\n    }\ncleanup:\n    free(stype);\n    return ret;\n}\n\n/*\n * Find a remote realm TGS principal for an unknown host-based service\n * principal.\n */\nstatic krb5_int32\nfind_referral_tgs(kdc_realm_t *kdc_active_realm, krb5_kdc_req *request,\n                  krb5_principal *krbtgt_princ)\n{\n    krb5_error_code retval = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n    char **realms = NULL, *hostname = NULL;\n    krb5_data srealm = request->server->realm;\n\n    if (!is_referral_req(kdc_active_realm, request))\n        goto cleanup;\n\n    hostname = data2string(krb5_princ_component(kdc_context,\n                                                request->server, 1));\n    if (hostname == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    /* If the hostname doesn't contain a '.', it's not a FQDN. */\n    if (strchr(hostname, '.') == NULL)\n        goto cleanup;\n    retval = krb5_get_host_realm(kdc_context, hostname, &realms);\n    if (retval) {\n        /* no match found */\n        kdc_err(kdc_context, retval, \"unable to find realm of host\");\n        goto cleanup;\n    }\n    /* Don't return a referral to the empty realm or the service realm. */\n    if (realms == NULL || realms[0] == NULL || *realms[0] == '\\0' ||\n        data_eq_string(srealm, realms[0])) {\n        retval = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        goto cleanup;\n    }\n    retval = krb5_build_principal(kdc_context, krbtgt_princ,\n                                  srealm.length, srealm.data,\n                                  \"krbtgt\", realms[0], (char *)0);\ncleanup:\n    krb5_free_host_realm(kdc_context, realms);\n    free(hostname);\n\n    return retval;\n}\n\nstatic krb5_error_code\ndb_get_svc_princ(krb5_context ctx, krb5_principal princ,\n                 krb5_flags flags, krb5_db_entry **server,\n                 const char **status)\n{\n    krb5_error_code ret;\n\n    ret = krb5_db_get_principal(ctx, princ, flags, server);\n    if (ret == KRB5_KDB_CANTLOCK_DB)\n        ret = KRB5KDC_ERR_SVC_UNAVAILABLE;\n    if (ret != 0) {\n        *status = \"LOOKING_UP_SERVER\";\n    }\n    return ret;\n}\n\nstatic krb5_error_code\nsearch_sprinc(kdc_realm_t *kdc_active_realm, krb5_kdc_req *req,\n              krb5_flags flags, krb5_db_entry **server, const char **status)\n{\n    krb5_error_code ret;\n    krb5_principal princ = req->server;\n    krb5_principal reftgs = NULL;\n    krb5_boolean allow_referral;\n\n    /* Do not allow referrals for u2u or ticket modification requests, because\n     * the server is supposed to match an already-issued ticket. */\n    allow_referral = !(req->kdc_options & NO_REFERRAL_OPTION);\n    if (!allow_referral)\n        flags &= ~KRB5_KDB_FLAG_CANONICALIZE;\n\n    ret = db_get_svc_princ(kdc_context, princ, flags, server, status);\n    if (ret == 0 || ret != KRB5_KDB_NOENTRY || !allow_referral)\n        goto cleanup;\n\n    if (!is_cross_tgs_principal(req->server)) {\n        ret = find_referral_tgs(kdc_active_realm, req, &reftgs);\n        if (ret != 0)\n            goto cleanup;\n        ret = db_get_svc_princ(kdc_context, reftgs, flags, server, status);\n        if (ret == 0 || ret != KRB5_KDB_NOENTRY)\n            goto cleanup;\n\n        princ = reftgs;\n    }\n    ret = find_alternate_tgs(kdc_active_realm, princ, server, status);\n\ncleanup:\n    if (ret != 0 && ret != KRB5KDC_ERR_SVC_UNAVAILABLE) {\n        ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        if (*status == NULL)\n            *status = \"LOOKING_UP_SERVER\";\n    }\n    krb5_free_principal(kdc_context, reftgs);\n    return ret;\n}\n"], "fixing_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* kdc/do_tgs_req.c - KDC Routines to deal with TGS_REQ's */\n/*\n * Copyright 1990, 1991, 2001, 2007, 2008, 2009, 2013, 2014 by the\n * Massachusetts Institute of Technology.  All Rights Reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n/*\n * Copyright (c) 2006-2008, Novell, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *   * The copyright holder's name is not used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"k5-int.h\"\n\n#include <syslog.h>\n#ifdef HAVE_NETINET_IN_H\n#include <sys/types.h>\n#include <netinet/in.h>\n#ifndef hpux\n#include <arpa/inet.h>\n#endif\n#endif\n\n#include \"kdc_util.h\"\n#include \"kdc_audit.h\"\n#include \"policy.h\"\n#include \"extern.h\"\n#include \"adm_proto.h\"\n#include <ctype.h>\n\nstatic krb5_error_code\nfind_alternate_tgs(kdc_realm_t *, krb5_principal, krb5_db_entry **,\n                   const char**);\n\nstatic krb5_error_code\nprepare_error_tgs(struct kdc_request_state *, krb5_kdc_req *,krb5_ticket *,int,\n                  krb5_principal,krb5_data **,const char *, krb5_pa_data **);\n\nstatic krb5_error_code\ndecrypt_2ndtkt(kdc_realm_t *, krb5_kdc_req *, krb5_flags, const krb5_ticket **,\n               krb5_db_entry **, krb5_keyblock **, const char **);\n\nstatic krb5_error_code\ngen_session_key(kdc_realm_t *, krb5_kdc_req *, krb5_db_entry *,\n                krb5_keyblock *, const char **);\n\nstatic krb5_int32\nfind_referral_tgs(kdc_realm_t *, krb5_kdc_req *, krb5_principal *);\n\nstatic krb5_error_code\ndb_get_svc_princ(krb5_context, krb5_principal, krb5_flags,\n                 krb5_db_entry **, const char **);\n\nstatic krb5_error_code\nsearch_sprinc(kdc_realm_t *, krb5_kdc_req *, krb5_flags,\n              krb5_db_entry **, const char **);\n\n/*ARGSUSED*/\nkrb5_error_code\nprocess_tgs_req(krb5_kdc_req *request, krb5_data *pkt,\n                const krb5_fulladdr *from, kdc_realm_t *kdc_active_realm,\n                krb5_data **response)\n{\n    krb5_keyblock * subkey = 0;\n    krb5_keyblock *header_key = NULL;\n    krb5_keyblock *stkt_server_key = NULL;\n    krb5_keyblock *subject_key;\n    krb5_db_entry *server = NULL;\n    krb5_db_entry *stkt_server = NULL;\n    krb5_db_entry *subject_server;\n    krb5_kdc_rep reply;\n    krb5_enc_kdc_rep_part reply_encpart;\n    krb5_ticket ticket_reply, *header_ticket = 0;\n    const krb5_ticket *stkt = NULL;\n    krb5_enc_tkt_part enc_tkt_reply;\n    int newtransited = 0;\n    krb5_error_code retval = 0;\n    krb5_keyblock server_keyblock, *encrypting_key;\n    krb5_timestamp kdc_time, authtime = 0;\n    krb5_keyblock session_key, local_tgt_key;\n    krb5_keyblock *reply_key = NULL;\n    krb5_principal cprinc = NULL, sprinc = NULL, altcprinc = NULL;\n    krb5_const_principal authdata_client;\n    krb5_principal stkt_authdata_client = NULL;\n    krb5_last_req_entry *nolrarray[2], nolrentry;\n    int errcode;\n    const char        *status = 0;\n    krb5_enc_tkt_part *header_enc_tkt = NULL; /* TGT */\n    krb5_enc_tkt_part *subject_tkt = NULL; /* TGT or evidence ticket */\n    krb5_db_entry *client = NULL, *header_server = NULL;\n    krb5_db_entry *local_tgt, *local_tgt_storage = NULL;\n    krb5_pa_s4u_x509_user *s4u_x509_user = NULL; /* protocol transition request */\n    krb5_authdata **kdc_issued_auth_data = NULL; /* auth data issued by KDC */\n    unsigned int c_flags = 0, s_flags = 0;       /* client/server KDB flags */\n    krb5_boolean is_referral, is_crossrealm;\n    const char *emsg = NULL;\n    krb5_kvno ticket_kvno = 0;\n    struct kdc_request_state *state = NULL;\n    krb5_pa_data *pa_tgs_req; /*points into request*/\n    krb5_data scratch;\n    krb5_pa_data **e_data = NULL;\n    krb5_audit_state *au_state = NULL;\n    krb5_data **auth_indicators = NULL;\n    void *ad_info = NULL, *stkt_ad_info = NULL;\n\n    memset(&reply, 0, sizeof(reply));\n    memset(&reply_encpart, 0, sizeof(reply_encpart));\n    memset(&ticket_reply, 0, sizeof(ticket_reply));\n    memset(&enc_tkt_reply, 0, sizeof(enc_tkt_reply));\n    memset(&server_keyblock, 0, sizeof(server_keyblock));\n    memset(&local_tgt_key, 0, sizeof(local_tgt_key));\n    session_key.contents = NULL;\n\n    /* Save pointer to client-requested service principal, in case of\n     * errors before a successful call to search_sprinc(). */\n    sprinc = request->server;\n\n    if (request->msg_type != KRB5_TGS_REQ) {\n        krb5_free_kdc_req(kdc_context, request);\n        return KRB5_BADMSGTYPE;\n    }\n\n    errcode = kdc_make_rstate(kdc_active_realm, &state);\n    if (errcode != 0)\n        goto cleanup;\n\n    /* Initialize audit state. */\n    errcode = kau_init_kdc_req(kdc_context, request, from, &au_state);\n    if (errcode)\n        goto cleanup;\n\n    /* Seed the audit trail with the request ID and basic information. */\n    kau_tgs_req(kdc_context, TRUE, au_state);\n\n    errcode = kdc_process_tgs_req(kdc_active_realm,\n                                  request, from, pkt, &header_ticket,\n                                  &header_server, &header_key, &subkey,\n                                  &pa_tgs_req);\n    if (header_ticket && header_ticket->enc_part2)\n        cprinc = header_ticket->enc_part2->client;\n\n    if (errcode) {\n        status = \"PROCESS_TGS\";\n        goto cleanup;\n    }\n\n    if (!header_ticket) {\n        errcode = KRB5_NO_TKT_SUPPLIED;        /* XXX? */\n        goto cleanup;\n    }\n    errcode = kau_make_tkt_id(kdc_context, header_ticket,\n                              &au_state->tkt_in_id);\n    if (errcode)\n        goto cleanup;\n\n    scratch.length = pa_tgs_req->length;\n    scratch.data = (char *) pa_tgs_req->contents;\n    errcode = kdc_find_fast(&request, &scratch, subkey,\n                            header_ticket->enc_part2->session, state, NULL);\n    /* Reset sprinc because kdc_find_fast() can replace request. */\n    sprinc = request->server;\n    if (errcode !=0) {\n        status = \"FIND_FAST\";\n        goto cleanup;\n    }\n    if (sprinc == NULL) {\n        status = \"NULL_SERVER\";\n        errcode = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        goto cleanup;\n    }\n\n    errcode = get_local_tgt(kdc_context, &sprinc->realm, header_server,\n                            &local_tgt, &local_tgt_storage, &local_tgt_key);\n    if (errcode) {\n        status = \"GET_LOCAL_TGT\";\n        goto cleanup;\n    }\n\n    /* Ignore (for now) the request modification due to FAST processing. */\n    au_state->request = request;\n\n    /*\n     * Pointer to the encrypted part of the header ticket, which may be\n     * replaced to point to the encrypted part of the evidence ticket\n     * if constrained delegation is used. This simplifies the number of\n     * special cases for constrained delegation.\n     */\n    header_enc_tkt = header_ticket->enc_part2;\n\n    /*\n     * We've already dealt with the AP_REQ authentication, so we can\n     * use header_ticket freely.  The encrypted part (if any) has been\n     * decrypted with the session key.\n     */\n\n    au_state->stage = SRVC_PRINC;\n\n    /* XXX make sure server here has the proper realm...taken from AP_REQ\n       header? */\n\n    if (isflagset(request->kdc_options, KDC_OPT_CANONICALIZE)) {\n        setflag(c_flags, KRB5_KDB_FLAG_CANONICALIZE);\n        setflag(s_flags, KRB5_KDB_FLAG_CANONICALIZE);\n    }\n\n    errcode = search_sprinc(kdc_active_realm, request, s_flags, &server,\n                            &status);\n    if (errcode != 0)\n        goto cleanup;\n    sprinc = server->princ;\n\n    /* If we got a cross-realm TGS which is not the requested server, we are\n     * issuing a referral (or alternate TGT, which we treat similarly). */\n    is_referral = is_cross_tgs_principal(server->princ) &&\n        !krb5_principal_compare(kdc_context, request->server, server->princ);\n\n    au_state->stage = VALIDATE_POL;\n\n    if ((errcode = krb5_timeofday(kdc_context, &kdc_time)))\n        goto cleanup;\n\n    is_crossrealm = !data_eq(header_server->princ->realm, sprinc->realm);\n    if (is_crossrealm)\n        setflag(c_flags, KRB5_KDB_FLAG_CROSS_REALM);\n    if (is_referral)\n        setflag(c_flags, KRB5_KDB_FLAG_ISSUING_REFERRAL);\n\n    /* Check for protocol transition */\n    errcode = kdc_process_s4u2self_req(kdc_active_realm, request, server,\n                                       subkey, header_enc_tkt->session,\n                                       &s4u_x509_user, &client, &status);\n    if (s4u_x509_user != NULL || errcode != 0) {\n        if (s4u_x509_user != NULL)\n            au_state->s4u2self_user = s4u_x509_user->user_id.user;\n        au_state->status = status;\n        kau_s4u2self(kdc_context, errcode ? FALSE : TRUE, au_state);\n        au_state->s4u2self_user = NULL;\n    }\n\n    /* For user-to-user and S4U2Proxy requests, decrypt the second ticket. */\n    errcode = decrypt_2ndtkt(kdc_active_realm, request, c_flags,\n                             &stkt, &stkt_server, &stkt_server_key, &status);\n    if (errcode)\n        goto cleanup;\n\n    retval = validate_tgs_request(kdc_active_realm, request, server,\n                                  header_ticket, stkt, stkt_server, kdc_time,\n                                  s4u_x509_user, client, is_crossrealm,\n                                  is_referral, &status, &e_data);\n    if (retval) {\n        if (retval == KDC_ERR_POLICY || retval == KDC_ERR_BADOPTION)\n            au_state->violation = PROT_CONSTRAINT;\n        errcode = retval + ERROR_TABLE_BASE_krb5;\n        goto cleanup;\n    }\n\n    if (errcode)\n        goto cleanup;\n\n    if (s4u_x509_user != NULL && client == NULL) {\n        /*\n         * For an S4U2Self referral request (the requesting service is\n         * following a referral back to its own realm), the authdata in the\n         * header ticket should be for the requested client.\n         */\n        setflag(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION);\n        authdata_client = s4u_x509_user->user_id.user;\n    } else {\n        /* Otherwise (including for initial S4U2Self requests), the authdata\n         * should be for the header ticket client. */\n        authdata_client = header_enc_tkt->client;\n    }\n    errcode = krb5_db_get_authdata_info(kdc_context, c_flags,\n                                        header_enc_tkt->authorization_data,\n                                        authdata_client, request->server,\n                                        header_key, &local_tgt_key, local_tgt,\n                                        header_enc_tkt->times.authtime,\n                                        &ad_info, NULL);\n    if (errcode && errcode != KRB5_PLUGIN_OP_NOTSUPP)\n        goto cleanup;\n\n    /* Flag all S4U2Self requests now that we have checked the authdata. */\n    if (s4u_x509_user != NULL)\n        setflag(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION);\n\n    if (isflagset(request->kdc_options, KDC_OPT_CNAME_IN_ADDL_TKT)) {\n        /* Do constrained delegation protocol and authorization checks. */\n        setflag(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION);\n\n        errcode = kdc_process_s4u2proxy_req(kdc_active_realm, c_flags, request,\n                                            stkt->enc_part2, local_tgt,\n                                            &local_tgt_key, stkt_server,\n                                            stkt_server_key,\n                                            header_ticket->enc_part2->client,\n                                            server, request->server, ad_info,\n                                            &stkt_ad_info,\n                                            &stkt_authdata_client,\n                                            &status);\n        if (errcode == KDC_ERR_POLICY || errcode == KDC_ERR_BADOPTION)\n            au_state->violation = PROT_CONSTRAINT;\n        else if (errcode)\n            au_state->violation = LOCAL_POLICY;\n        au_state->status = status;\n        retval = kau_make_tkt_id(kdc_context, stkt, &au_state->evid_tkt_id);\n        if (retval) {\n            errcode = retval;\n            goto cleanup;\n        }\n        kau_s4u2proxy(kdc_context, errcode ? FALSE : TRUE, au_state);\n        if (errcode)\n            goto cleanup;\n\n        assert(krb5_is_tgs_principal(header_ticket->server));\n\n        /* Use the parsed authdata from the second ticket during authdata\n         * handling. */\n        krb5_db_free_authdata_info(kdc_context, ad_info);\n        ad_info = stkt_ad_info;\n        stkt_ad_info = NULL;\n    }\n\n    au_state->stage = ISSUE_TKT;\n\n    errcode = gen_session_key(kdc_active_realm, request, server, &session_key,\n                              &status);\n    if (errcode)\n        goto cleanup;\n\n    /*\n     * subject_tkt will refer to the evidence ticket (for constrained\n     * delegation) or the TGT. The distinction from header_enc_tkt is\n     * necessary because the TGS signature only protects some fields:\n     * the others could be forged by a malicious server.\n     */\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        subject_tkt = stkt->enc_part2;\n        subject_server = stkt_server;\n        subject_key = stkt_server_key;\n    } else {\n        subject_tkt = header_enc_tkt;\n        subject_server = header_server;\n        subject_key = header_key;\n    }\n    authtime = subject_tkt->times.authtime;\n\n    /* Extract and check auth indicators from the subject ticket, except for\n     * S4U2Self requests (where the client didn't authenticate). */\n    if (s4u_x509_user == NULL) {\n        errcode = get_auth_indicators(kdc_context, subject_tkt, local_tgt,\n                                      &local_tgt_key, &auth_indicators);\n        if (errcode) {\n            status = \"GET_AUTH_INDICATORS\";\n            goto cleanup;\n        }\n\n        errcode = check_indicators(kdc_context, server, auth_indicators);\n        if (errcode) {\n            status = \"HIGHER_AUTHENTICATION_REQUIRED\";\n            goto cleanup;\n        }\n    }\n\n    if (is_referral)\n        ticket_reply.server = server->princ;\n    else\n        ticket_reply.server = request->server; /* XXX careful for realm... */\n\n    enc_tkt_reply.flags = get_ticket_flags(request->kdc_options, client,\n                                           server, header_enc_tkt);\n    enc_tkt_reply.times.starttime = 0;\n\n    /* OK_TO_AUTH_AS_DELEGATE must be set on the service requesting S4U2Self\n     * for forwardable tickets to be issued. */\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&\n        !is_referral &&\n        !isflagset(server->attributes, KRB5_KDB_OK_TO_AUTH_AS_DELEGATE))\n        clear(enc_tkt_reply.flags, TKT_FLG_FORWARDABLE);\n\n    /* don't use new addresses unless forwarded, see below */\n\n    enc_tkt_reply.caddrs = header_enc_tkt->caddrs;\n    /* noaddrarray[0] = 0; */\n    reply_encpart.caddrs = 0;/* optional...don't put it in */\n    reply_encpart.enc_padata = NULL;\n\n    /*\n     * It should be noted that local policy may affect the\n     * processing of any of these flags.  For example, some\n     * realms may refuse to issue renewable tickets\n     */\n\n    if (isflagset(request->kdc_options, KDC_OPT_FORWARDED) ||\n        isflagset(request->kdc_options, KDC_OPT_PROXY)) {\n\n        /* include new addresses in ticket & reply */\n\n        enc_tkt_reply.caddrs = request->addresses;\n        reply_encpart.caddrs = request->addresses;\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_POSTDATED))\n        enc_tkt_reply.times.starttime = request->from;\n    else\n        enc_tkt_reply.times.starttime = kdc_time;\n\n    if (isflagset(request->kdc_options, KDC_OPT_VALIDATE)) {\n        assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);\n        /* BEWARE of allocation hanging off of ticket & enc_part2, it belongs\n           to the caller */\n        ticket_reply = *(header_ticket);\n        enc_tkt_reply = *(header_ticket->enc_part2);\n        enc_tkt_reply.authorization_data = NULL;\n        clear(enc_tkt_reply.flags, TKT_FLG_INVALID);\n    }\n\n    if (isflagset(request->kdc_options, KDC_OPT_RENEW)) {\n        krb5_timestamp old_starttime;\n        krb5_deltat old_life;\n\n        assert(isflagset(c_flags, KRB5_KDB_FLAGS_S4U) == 0);\n        /* BEWARE of allocation hanging off of ticket & enc_part2, it belongs\n           to the caller */\n        ticket_reply = *(header_ticket);\n        enc_tkt_reply = *(header_ticket->enc_part2);\n        enc_tkt_reply.authorization_data = NULL;\n\n        old_starttime = enc_tkt_reply.times.starttime ?\n            enc_tkt_reply.times.starttime : enc_tkt_reply.times.authtime;\n        old_life = ts_delta(enc_tkt_reply.times.endtime, old_starttime);\n\n        enc_tkt_reply.times.starttime = kdc_time;\n        enc_tkt_reply.times.endtime =\n            ts_min(header_ticket->enc_part2->times.renew_till,\n                   ts_incr(kdc_time, old_life));\n    } else {\n        /* not a renew request */\n        enc_tkt_reply.times.starttime = kdc_time;\n\n        kdc_get_ticket_endtime(kdc_active_realm, enc_tkt_reply.times.starttime,\n                               header_enc_tkt->times.endtime, request->till,\n                               client, server, &enc_tkt_reply.times.endtime);\n    }\n\n    kdc_get_ticket_renewtime(kdc_active_realm, request, header_enc_tkt, client,\n                             server, &enc_tkt_reply);\n\n    errcode = check_kdcpolicy_tgs(kdc_context, request, server, header_ticket,\n                                  auth_indicators, kdc_time,\n                                  &enc_tkt_reply.times, &status);\n    if (errcode)\n        goto cleanup;\n\n    /*\n     * Set authtime to be the same as header or evidence ticket's\n     */\n    enc_tkt_reply.times.authtime = authtime;\n\n    /* starttime is optional, and treated as authtime if not present.\n       so we can nuke it if it matches */\n    if (enc_tkt_reply.times.starttime == enc_tkt_reply.times.authtime)\n        enc_tkt_reply.times.starttime = 0;\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {\n        altcprinc = s4u_x509_user->user_id.user;\n    } else if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        /* kdc_process_s4u2proxy_req() only allows cross-realm requests if\n         * stkt_authdata_client is set. */\n        altcprinc = is_crossrealm ? stkt_authdata_client : subject_tkt->client;\n    } else {\n        altcprinc = NULL;\n    }\n    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {\n        encrypting_key = stkt->enc_part2->session;\n    } else {\n        errcode = get_first_current_key(kdc_context, server, &server_keyblock);\n        if (errcode) {\n            status = \"FINDING_SERVER_KEY\";\n            goto cleanup;\n        }\n        encrypting_key = &server_keyblock;\n    }\n\n    if (isflagset(c_flags, KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)) {\n        /*\n         * Don't allow authorization data to be disabled if constrained\n         * delegation is requested. We don't want to deny the server\n         * the ability to validate that delegation was used.\n         */\n        clear(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED);\n    }\n    if (isflagset(server->attributes, KRB5_KDB_NO_AUTH_DATA_REQUIRED) == 0) {\n        /* If we are not doing protocol transition, try to look up the subject\n         * principal so that KDB modules can add additional authdata. */\n        if (!isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION)) {\n            /* Generate authorization data so we can include it in ticket */\n            setflag(c_flags, KRB5_KDB_FLAG_INCLUDE_PAC);\n            /* Map principals from foreign (possibly non-AD) realms */\n            setflag(c_flags, KRB5_KDB_FLAG_MAP_PRINCIPALS);\n\n            assert(client == NULL); /* should not have been set already */\n\n            errcode = krb5_db_get_principal(kdc_context, subject_tkt->client,\n                                            c_flags, &client);\n        }\n    }\n\n    if (isflagset(c_flags, KRB5_KDB_FLAGS_S4U) && !is_referral)\n        enc_tkt_reply.client = altcprinc;\n    else\n        enc_tkt_reply.client = header_enc_tkt->client;\n\n    enc_tkt_reply.session = &session_key;\n    enc_tkt_reply.transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n    enc_tkt_reply.transited.tr_contents = empty_string; /* equivalent of \"\" */\n\n    /*\n     * Only add the realm of the presented tgt to the transited list if\n     * it is different than the server realm (cross-realm) and it is different\n     * than the realm of the client (since the realm of the client is already\n     * implicitly part of the transited list and should not be explicitly\n     * listed).\n     */\n    if (!is_crossrealm ||\n        krb5_realm_compare(kdc_context, header_ticket->server,\n                           enc_tkt_reply.client)) {\n        /* tgt issued by local realm or issued by realm of client */\n        enc_tkt_reply.transited = header_enc_tkt->transited;\n    } else {\n        /* tgt issued by some other realm and not the realm of the client */\n        /* assemble new transited field into allocated storage */\n        if (header_enc_tkt->transited.tr_type !=\n            KRB5_DOMAIN_X500_COMPRESS) {\n            status = \"VALIDATE_TRANSIT_TYPE\";\n            errcode = KRB5KDC_ERR_TRTYPE_NOSUPP;\n            goto cleanup;\n        }\n        memset(&enc_tkt_reply.transited, 0, sizeof(enc_tkt_reply.transited));\n        enc_tkt_reply.transited.tr_type = KRB5_DOMAIN_X500_COMPRESS;\n        if ((errcode =\n             add_to_transited(&header_enc_tkt->transited.tr_contents,\n                              &enc_tkt_reply.transited.tr_contents,\n                              header_ticket->server,\n                              enc_tkt_reply.client,\n                              request->server))) {\n            status = \"ADD_TO_TRANSITED_LIST\";\n            goto cleanup;\n        }\n        newtransited = 1;\n    }\n    if (!isflagset (request->kdc_options, KDC_OPT_DISABLE_TRANSITED_CHECK)) {\n        errcode = kdc_check_transited_list (kdc_active_realm,\n                                            &enc_tkt_reply.transited.tr_contents,\n                                            krb5_princ_realm (kdc_context, header_enc_tkt->client),\n                                            krb5_princ_realm (kdc_context, request->server));\n        if (errcode == 0) {\n            setflag (enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED);\n        } else {\n            log_tgs_badtrans(kdc_context, cprinc, sprinc,\n                             &enc_tkt_reply.transited.tr_contents, errcode);\n        }\n    } else\n        krb5_klog_syslog(LOG_INFO, _(\"not checking transit path\"));\n    if (kdc_active_realm->realm_reject_bad_transit &&\n        !isflagset(enc_tkt_reply.flags, TKT_FLG_TRANSIT_POLICY_CHECKED)) {\n        errcode = KRB5KDC_ERR_POLICY;\n        status = \"BAD_TRANSIT\";\n        au_state->violation = LOCAL_POLICY;\n        goto cleanup;\n    }\n\n    errcode = handle_authdata(kdc_context, c_flags, client, server,\n                              subject_server, local_tgt, &local_tgt_key,\n                              subkey != NULL ? subkey :\n                              header_ticket->enc_part2->session,\n                              encrypting_key, subject_key, pkt, request,\n                              altcprinc, ad_info, subject_tkt,\n                              &auth_indicators, &enc_tkt_reply);\n    if (errcode) {\n        krb5_klog_syslog(LOG_INFO, _(\"TGS_REQ : handle_authdata (%d)\"),\n                         errcode);\n        status = \"HANDLE_AUTHDATA\";\n        goto cleanup;\n    }\n\n    ticket_reply.enc_part2 = &enc_tkt_reply;\n\n    /* If we are doing user-to-user authentication, encrypt the ticket using\n     * the session key of the second ticket. */\n    if (isflagset(request->kdc_options, KDC_OPT_ENC_TKT_IN_SKEY)) {\n        ticket_kvno = 0;\n        ticket_reply.enc_part.enctype = stkt->enc_part2->session->enctype;\n        kau_u2u(kdc_context, TRUE, au_state);\n    } else {\n        ticket_kvno = current_kvno(server);\n    }\n\n    errcode = krb5_encrypt_tkt_part(kdc_context, encrypting_key,\n                                    &ticket_reply);\n    if (errcode)\n        goto cleanup;\n    ticket_reply.enc_part.kvno = ticket_kvno;\n    /* Start assembling the response */\n    au_state->stage = ENCR_REP;\n    reply.msg_type = KRB5_TGS_REP;\n    if (isflagset(c_flags, KRB5_KDB_FLAG_PROTOCOL_TRANSITION) &&\n        krb5int_find_pa_data(kdc_context, request->padata,\n                             KRB5_PADATA_S4U_X509_USER) != NULL) {\n        errcode = kdc_make_s4u2self_rep(kdc_context,\n                                        subkey,\n                                        header_ticket->enc_part2->session,\n                                        s4u_x509_user,\n                                        &reply,\n                                        &reply_encpart);\n        if (errcode)\n            au_state->status = status;\n        kau_s4u2self(kdc_context, errcode ? FALSE : TRUE, au_state);\n        if (errcode)\n            goto cleanup;\n    }\n\n    reply.client = enc_tkt_reply.client;\n    reply.enc_part.kvno = 0;/* We are using the session key */\n    reply.ticket = &ticket_reply;\n\n    reply_encpart.session = &session_key;\n    reply_encpart.nonce = request->nonce;\n\n    /* copy the time fields */\n    reply_encpart.times = enc_tkt_reply.times;\n\n    nolrentry.lr_type = KRB5_LRQ_NONE;\n    nolrentry.value = 0;\n    nolrentry.magic = 0;\n    nolrarray[0] = &nolrentry;\n    nolrarray[1] = 0;\n    reply_encpart.last_req = nolrarray;        /* not available for TGS reqs */\n    reply_encpart.key_exp = 0;/* ditto */\n    reply_encpart.flags = enc_tkt_reply.flags;\n    reply_encpart.server = ticket_reply.server;\n\n    /* use the session key in the ticket, unless there's a subsession key\n       in the AP_REQ */\n    reply.enc_part.enctype = subkey ? subkey->enctype :\n        header_ticket->enc_part2->session->enctype;\n    errcode  = kdc_fast_response_handle_padata(state, request, &reply,\n                                               subkey ? subkey->enctype : header_ticket->enc_part2->session->enctype);\n    if (errcode)\n        goto cleanup;\n    errcode =kdc_fast_handle_reply_key(state,\n                                       subkey?subkey:header_ticket->enc_part2->session, &reply_key);\n    if (errcode)\n        goto cleanup;\n    errcode = return_enc_padata(kdc_context, pkt, request,\n                                reply_key, server, &reply_encpart,\n                                is_referral &&\n                                isflagset(s_flags,\n                                          KRB5_KDB_FLAG_CANONICALIZE));\n    if (errcode) {\n        status = \"KDC_RETURN_ENC_PADATA\";\n        goto cleanup;\n    }\n\n    errcode = kau_make_tkt_id(kdc_context, &ticket_reply, &au_state->tkt_out_id);\n    if (errcode)\n        goto cleanup;\n\n    if (kdc_fast_hide_client(state))\n        reply.client = (krb5_principal)krb5_anonymous_principal();\n    errcode = krb5_encode_kdc_rep(kdc_context, KRB5_TGS_REP, &reply_encpart,\n                                  subkey ? 1 : 0,\n                                  reply_key,\n                                  &reply, response);\n    if (!errcode)\n        status = \"ISSUE\";\n\n    memset(ticket_reply.enc_part.ciphertext.data, 0,\n           ticket_reply.enc_part.ciphertext.length);\n    free(ticket_reply.enc_part.ciphertext.data);\n    /* these parts are left on as a courtesy from krb5_encode_kdc_rep so we\n       can use them in raw form if needed.  But, we don't... */\n    memset(reply.enc_part.ciphertext.data, 0,\n           reply.enc_part.ciphertext.length);\n    free(reply.enc_part.ciphertext.data);\n\ncleanup:\n    if (status == NULL)\n        status = \"UNKNOWN_REASON\";\n    krb5_free_keyblock_contents(kdc_context, &server_keyblock);\n    if (reply_key)\n        krb5_free_keyblock(kdc_context, reply_key);\n    if (stkt_server_key)\n        krb5_free_keyblock(kdc_context, stkt_server_key);\n    if (errcode)\n        emsg = krb5_get_error_message (kdc_context, errcode);\n\n    if (au_state != NULL) {\n        au_state->status = status;\n        if (!errcode)\n            au_state->reply = &reply;\n        kau_tgs_req(kdc_context, errcode ? FALSE : TRUE, au_state);\n        kau_free_kdc_req(au_state);\n    }\n\n    log_tgs_req(kdc_context, from, request, &reply, cprinc,\n                sprinc, altcprinc, authtime,\n                c_flags, status, errcode, emsg);\n    if (errcode) {\n        krb5_free_error_message (kdc_context, emsg);\n        emsg = NULL;\n    }\n\n    if (errcode && state != NULL) {\n        int got_err = 0;\n        if (status == 0) {\n            status = krb5_get_error_message (kdc_context, errcode);\n            got_err = 1;\n        }\n        errcode -= ERROR_TABLE_BASE_krb5;\n        if (errcode < 0 || errcode > KRB_ERR_MAX)\n            errcode = KRB_ERR_GENERIC;\n\n        retval = prepare_error_tgs(state, request, header_ticket, errcode,\n                                   (server != NULL) ? server->princ : NULL,\n                                   response, status, e_data);\n        if (got_err) {\n            krb5_free_error_message (kdc_context, status);\n            status = 0;\n        }\n    }\n\n    if (header_ticket != NULL)\n        krb5_free_ticket(kdc_context, header_ticket);\n    if (request != NULL)\n        krb5_free_kdc_req(kdc_context, request);\n    if (state)\n        kdc_free_rstate(state);\n    krb5_db_free_principal(kdc_context, server);\n    krb5_db_free_principal(kdc_context, stkt_server);\n    krb5_db_free_principal(kdc_context, header_server);\n    krb5_db_free_principal(kdc_context, client);\n    krb5_db_free_principal(kdc_context, local_tgt_storage);\n    if (local_tgt_key.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &local_tgt_key);\n    if (session_key.contents != NULL)\n        krb5_free_keyblock_contents(kdc_context, &session_key);\n    if (newtransited)\n        free(enc_tkt_reply.transited.tr_contents.data);\n    if (s4u_x509_user != NULL)\n        krb5_free_pa_s4u_x509_user(kdc_context, s4u_x509_user);\n    if (kdc_issued_auth_data != NULL)\n        krb5_free_authdata(kdc_context, kdc_issued_auth_data);\n    if (subkey != NULL)\n        krb5_free_keyblock(kdc_context, subkey);\n    if (header_key != NULL)\n        krb5_free_keyblock(kdc_context, header_key);\n    if (reply.padata)\n        krb5_free_pa_data(kdc_context, reply.padata);\n    if (reply_encpart.enc_padata)\n        krb5_free_pa_data(kdc_context, reply_encpart.enc_padata);\n    if (enc_tkt_reply.authorization_data != NULL)\n        krb5_free_authdata(kdc_context, enc_tkt_reply.authorization_data);\n    krb5_free_pa_data(kdc_context, e_data);\n    k5_free_data_ptr_list(auth_indicators);\n    krb5_db_free_authdata_info(kdc_context, ad_info);\n    krb5_db_free_authdata_info(kdc_context, stkt_ad_info);\n    krb5_free_principal(kdc_context, stkt_authdata_client);\n\n    return retval;\n}\n\nstatic krb5_error_code\nprepare_error_tgs (struct kdc_request_state *state,\n                   krb5_kdc_req *request, krb5_ticket *ticket, int error,\n                   krb5_principal canon_server,\n                   krb5_data **response, const char *status,\n                   krb5_pa_data **e_data)\n{\n    krb5_error errpkt;\n    krb5_error_code retval = 0;\n    krb5_data *scratch, *e_data_asn1 = NULL, *fast_edata = NULL;\n    kdc_realm_t *kdc_active_realm = state->realm_data;\n\n    errpkt.magic = KV5M_ERROR;\n    errpkt.ctime = 0;\n    errpkt.cusec = 0;\n\n    if ((retval = krb5_us_timeofday(kdc_context, &errpkt.stime,\n                                    &errpkt.susec)))\n        return(retval);\n    errpkt.error = error;\n    errpkt.server = request->server;\n    if (ticket && ticket->enc_part2)\n        errpkt.client = ticket->enc_part2->client;\n    else\n        errpkt.client = NULL;\n    errpkt.text.length = strlen(status);\n    if (!(errpkt.text.data = strdup(status)))\n        return ENOMEM;\n\n    if (!(scratch = (krb5_data *)malloc(sizeof(*scratch)))) {\n        free(errpkt.text.data);\n        return ENOMEM;\n    }\n\n    if (e_data != NULL) {\n        retval = encode_krb5_padata_sequence(e_data, &e_data_asn1);\n        if (retval) {\n            free(scratch);\n            free(errpkt.text.data);\n            return retval;\n        }\n        errpkt.e_data = *e_data_asn1;\n    } else\n        errpkt.e_data = empty_data();\n\n    retval = kdc_fast_handle_error(kdc_context, state, request, e_data,\n                                   &errpkt, &fast_edata);\n    if (retval) {\n        free(scratch);\n        free(errpkt.text.data);\n        krb5_free_data(kdc_context, e_data_asn1);\n        return retval;\n    }\n    if (fast_edata)\n        errpkt.e_data = *fast_edata;\n    if (kdc_fast_hide_client(state) && errpkt.client != NULL)\n        errpkt.client = (krb5_principal)krb5_anonymous_principal();\n    retval = krb5_mk_error(kdc_context, &errpkt, scratch);\n    free(errpkt.text.data);\n    krb5_free_data(kdc_context, e_data_asn1);\n    krb5_free_data(kdc_context, fast_edata);\n    if (retval)\n        free(scratch);\n    else\n        *response = scratch;\n\n    return retval;\n}\n\n/* KDC options that require a second ticket */\n#define STKT_OPTIONS (KDC_OPT_CNAME_IN_ADDL_TKT | KDC_OPT_ENC_TKT_IN_SKEY)\n/*\n * If req is a second-ticket request and a second ticket is present, decrypt\n * it.  Set *stkt_out to an alias to the ticket with populated enc_part2.  Set\n * *server_out to the server DB entry and *key_out to the ticket decryption\n * key.\n */\nstatic krb5_error_code\ndecrypt_2ndtkt(kdc_realm_t *kdc_active_realm, krb5_kdc_req *req,\n               krb5_flags flags, const krb5_ticket **stkt_out,\n               krb5_db_entry **server_out, krb5_keyblock **key_out,\n               const char **status)\n{\n    krb5_error_code retval;\n    krb5_db_entry *server = NULL;\n    krb5_keyblock *key = NULL;\n    krb5_kvno kvno;\n    krb5_ticket *stkt;\n\n    *stkt_out = NULL;\n    *server_out = NULL;\n    *key_out = NULL;\n\n    if (!(req->kdc_options & STKT_OPTIONS) || req->second_ticket == NULL ||\n        req->second_ticket[0] == NULL)\n        return 0;\n\n    stkt = req->second_ticket[0];\n    retval = kdc_get_server_key(kdc_context, stkt, flags, TRUE,\n                                &server, &key, &kvno);\n    if (retval != 0) {\n        *status = \"2ND_TKT_SERVER\";\n        goto cleanup;\n    }\n    retval = krb5_decrypt_tkt_part(kdc_context, key, stkt);\n    if (retval != 0) {\n        *status = \"2ND_TKT_DECRYPT\";\n        goto cleanup;\n    }\n    *stkt_out = stkt;\n    *server_out = server;\n    *key_out = key;\n    server = NULL;\n    key = NULL;\n\ncleanup:\n    krb5_db_free_principal(kdc_context, server);\n    krb5_free_keyblock(kdc_context, key);\n    return retval;\n}\n\nstatic krb5_error_code\nget_2ndtkt_enctype(kdc_realm_t *kdc_active_realm, krb5_kdc_req *req,\n                   krb5_enctype *useenctype, const char **status)\n{\n    krb5_enctype etype;\n    krb5_ticket *stkt = req->second_ticket[0];\n    int i;\n\n    etype = stkt->enc_part2->session->enctype;\n    if (!krb5_c_valid_enctype(etype)) {\n        *status = \"BAD_ETYPE_IN_2ND_TKT\";\n        return KRB5KDC_ERR_ETYPE_NOSUPP;\n    }\n    for (i = 0; i < req->nktypes; i++) {\n        if (req->ktype[i] == etype) {\n            *useenctype = etype;\n            break;\n        }\n    }\n    return 0;\n}\n\nstatic krb5_error_code\ngen_session_key(kdc_realm_t *kdc_active_realm, krb5_kdc_req *req,\n                krb5_db_entry *server, krb5_keyblock *skey,\n                const char **status)\n{\n    krb5_error_code retval;\n    krb5_enctype useenctype = 0;\n\n    /*\n     * Some special care needs to be taken in the user-to-user\n     * case, since we don't know what keytypes the application server\n     * which is doing user-to-user authentication can support.  We\n     * know that it at least must be able to support the encryption\n     * type of the session key in the TGT, since otherwise it won't be\n     * able to decrypt the U2U ticket!  So we use that in preference\n     * to anything else.\n     */\n    if (req->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        retval = get_2ndtkt_enctype(kdc_active_realm, req, &useenctype,\n                                    status);\n        if (retval != 0)\n            return retval;\n    }\n    if (useenctype == 0) {\n        useenctype = select_session_keytype(kdc_active_realm, server,\n                                            req->nktypes,\n                                            req->ktype);\n    }\n    if (useenctype == 0) {\n        /* unsupported ktype */\n        *status = \"BAD_ENCRYPTION_TYPE\";\n        return KRB5KDC_ERR_ETYPE_NOSUPP;\n    }\n\n    return krb5_c_make_random_key(kdc_context, useenctype, skey);\n}\n\n/*\n * The request seems to be for a ticket-granting service somewhere else,\n * but we don't have a ticket for the final TGS.  Try to give the requestor\n * some intermediate realm.\n */\nstatic krb5_error_code\nfind_alternate_tgs(kdc_realm_t *kdc_active_realm, krb5_principal princ,\n                   krb5_db_entry **server_ptr, const char **status)\n{\n    krb5_error_code retval;\n    krb5_principal *plist = NULL, *pl2;\n    krb5_data tmp;\n    krb5_db_entry *server = NULL;\n\n    *server_ptr = NULL;\n    assert(is_cross_tgs_principal(princ));\n    if ((retval = krb5_walk_realm_tree(kdc_context,\n                                       krb5_princ_realm(kdc_context, princ),\n                                       krb5_princ_component(kdc_context, princ, 1),\n                                       &plist, KRB5_REALM_BRANCH_CHAR))) {\n        goto cleanup;\n    }\n    /* move to the end */\n    for (pl2 = plist; *pl2; pl2++);\n\n    /* the first entry in this array is for krbtgt/local@local, so we\n       ignore it */\n    while (--pl2 > plist) {\n        tmp = *krb5_princ_realm(kdc_context, *pl2);\n        krb5_princ_set_realm(kdc_context, *pl2,\n                             krb5_princ_realm(kdc_context, princ));\n        retval = db_get_svc_princ(kdc_context, *pl2, 0, &server, status);\n        krb5_princ_set_realm(kdc_context, *pl2, &tmp);\n        if (retval == KRB5_KDB_NOENTRY)\n            continue;\n        else if (retval)\n            goto cleanup;\n\n        log_tgs_alt_tgt(kdc_context, server->princ);\n        *server_ptr = server;\n        server = NULL;\n        goto cleanup;\n    }\ncleanup:\n    if (retval == 0 && *server_ptr == NULL)\n        retval = KRB5_KDB_NOENTRY;\n    if (retval != 0)\n        *status = \"UNKNOWN_SERVER\";\n\n    krb5_free_realm_tree(kdc_context, plist);\n    krb5_db_free_principal(kdc_context, server);\n    return retval;\n}\n\n/* Return true if item is an element of the space/comma-separated list. */\nstatic krb5_boolean\nin_list(const char *list, const char *item)\n{\n    const char *p;\n    int len = strlen(item);\n\n    if (list == NULL)\n        return FALSE;\n    for (p = strstr(list, item); p != NULL; p = strstr(p + 1, item)) {\n        if ((p == list || isspace((unsigned char)p[-1]) || p[-1] == ',') &&\n            (p[len] == '\\0' || isspace((unsigned char)p[len]) ||\n             p[len] == ','))\n                return TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Check whether the request satisfies the conditions for generating a referral\n * TGT.  The caller checks whether the hostname component looks like a FQDN.\n */\nstatic krb5_boolean\nis_referral_req(kdc_realm_t *kdc_active_realm, krb5_kdc_req *request)\n{\n    krb5_boolean ret = FALSE;\n    char *stype = NULL;\n    char *hostbased = kdc_active_realm->realm_hostbased;\n    char *no_referral = kdc_active_realm->realm_no_referral;\n\n    if (!(request->kdc_options & KDC_OPT_CANONICALIZE))\n        return FALSE;\n\n    if (request->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY)\n        return FALSE;\n\n    if (krb5_princ_size(kdc_context, request->server) != 2)\n        return FALSE;\n\n    stype = data2string(krb5_princ_component(kdc_context, request->server, 0));\n    if (stype == NULL)\n        return FALSE;\n    switch (krb5_princ_type(kdc_context, request->server)) {\n    case KRB5_NT_UNKNOWN:\n        /* Allow referrals for NT-UNKNOWN principals, if configured. */\n        if (!in_list(hostbased, stype) && !in_list(hostbased, \"*\"))\n            goto cleanup;\n        /* FALLTHROUGH */\n    case KRB5_NT_SRV_HST:\n    case KRB5_NT_SRV_INST:\n        /* Deny referrals for specific service types, if configured. */\n        if (in_list(no_referral, stype) || in_list(no_referral, \"*\"))\n            goto cleanup;\n        ret = TRUE;\n        break;\n    default:\n        goto cleanup;\n    }\ncleanup:\n    free(stype);\n    return ret;\n}\n\n/*\n * Find a remote realm TGS principal for an unknown host-based service\n * principal.\n */\nstatic krb5_int32\nfind_referral_tgs(kdc_realm_t *kdc_active_realm, krb5_kdc_req *request,\n                  krb5_principal *krbtgt_princ)\n{\n    krb5_error_code retval = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n    char **realms = NULL, *hostname = NULL;\n    krb5_data srealm = request->server->realm;\n\n    if (!is_referral_req(kdc_active_realm, request))\n        goto cleanup;\n\n    hostname = data2string(krb5_princ_component(kdc_context,\n                                                request->server, 1));\n    if (hostname == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    /* If the hostname doesn't contain a '.', it's not a FQDN. */\n    if (strchr(hostname, '.') == NULL)\n        goto cleanup;\n    retval = krb5_get_host_realm(kdc_context, hostname, &realms);\n    if (retval) {\n        /* no match found */\n        kdc_err(kdc_context, retval, \"unable to find realm of host\");\n        goto cleanup;\n    }\n    /* Don't return a referral to the empty realm or the service realm. */\n    if (realms == NULL || realms[0] == NULL || *realms[0] == '\\0' ||\n        data_eq_string(srealm, realms[0])) {\n        retval = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        goto cleanup;\n    }\n    retval = krb5_build_principal(kdc_context, krbtgt_princ,\n                                  srealm.length, srealm.data,\n                                  \"krbtgt\", realms[0], (char *)0);\ncleanup:\n    krb5_free_host_realm(kdc_context, realms);\n    free(hostname);\n\n    return retval;\n}\n\nstatic krb5_error_code\ndb_get_svc_princ(krb5_context ctx, krb5_principal princ,\n                 krb5_flags flags, krb5_db_entry **server,\n                 const char **status)\n{\n    krb5_error_code ret;\n\n    ret = krb5_db_get_principal(ctx, princ, flags, server);\n    if (ret == KRB5_KDB_CANTLOCK_DB)\n        ret = KRB5KDC_ERR_SVC_UNAVAILABLE;\n    if (ret != 0) {\n        *status = \"LOOKING_UP_SERVER\";\n    }\n    return ret;\n}\n\nstatic krb5_error_code\nsearch_sprinc(kdc_realm_t *kdc_active_realm, krb5_kdc_req *req,\n              krb5_flags flags, krb5_db_entry **server, const char **status)\n{\n    krb5_error_code ret;\n    krb5_principal princ = req->server;\n    krb5_principal reftgs = NULL;\n    krb5_boolean allow_referral;\n\n    /* Do not allow referrals for u2u or ticket modification requests, because\n     * the server is supposed to match an already-issued ticket. */\n    allow_referral = !(req->kdc_options & NO_REFERRAL_OPTION);\n    if (!allow_referral)\n        flags &= ~KRB5_KDB_FLAG_CANONICALIZE;\n\n    ret = db_get_svc_princ(kdc_context, princ, flags, server, status);\n    if (ret == 0 || ret != KRB5_KDB_NOENTRY || !allow_referral)\n        goto cleanup;\n\n    if (!is_cross_tgs_principal(req->server)) {\n        ret = find_referral_tgs(kdc_active_realm, req, &reftgs);\n        if (ret != 0)\n            goto cleanup;\n        ret = db_get_svc_princ(kdc_context, reftgs, flags, server, status);\n        if (ret == 0 || ret != KRB5_KDB_NOENTRY)\n            goto cleanup;\n\n        princ = reftgs;\n    }\n    ret = find_alternate_tgs(kdc_active_realm, princ, server, status);\n\ncleanup:\n    if (ret != 0 && ret != KRB5KDC_ERR_SVC_UNAVAILABLE) {\n        ret = KRB5KDC_ERR_S_PRINCIPAL_UNKNOWN;\n        if (*status == NULL)\n            *status = \"LOOKING_UP_SERVER\";\n    }\n    krb5_free_principal(kdc_context, reftgs);\n    return ret;\n}\n"], "filenames": ["src/kdc/do_tgs_req.c"], "buggy_code_start_loc": [206], "buggy_code_end_loc": [206], "fixing_code_start_loc": [207], "fixing_code_end_loc": [212], "type": "CWE-476", "message": "The Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.18.5 and 1.19.x before 1.19.3 has a NULL pointer dereference in kdc/do_tgs_req.c via a FAST inner body that lacks a server field.", "other": {"cve": {"id": "CVE-2021-37750", "sourceIdentifier": "cve@mitre.org", "published": "2021-08-23T05:15:08.063", "lastModified": "2022-10-25T16:57:32.723", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The Key Distribution Center (KDC) in MIT Kerberos 5 (aka krb5) before 1.18.5 and 1.19.x before 1.19.3 has a NULL pointer dereference in kdc/do_tgs_req.c via a FAST inner body that lacks a server field."}, {"lang": "es", "value": "El Centro de Distribuci\u00f3n de Claves (KDC) en MIT Kerberos 5 (tambi\u00e9n se conoce como krb5) versiones anteriores a 1.18.5 y 1.19.x versiones anteriores a  1.19.3, presenta una desreferencia de puntero NULL en el archivo kdc/do_tgs_req.c por medio de un cuerpo interno FAST que carece de un campo de servidor."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.18.5", "matchCriteriaId": "BF5D8B08-B0D6-4586-90E9-699344F5FDF5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.19.0", "versionEndExcluding": "1.19.3", "matchCriteriaId": "500DB7B1-F8ED-4C89-8CDE-26DD02CB5A18"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:starwindsoftware:starwind_virtual_san:v8r13:14338:*:*:*:*:*:*", "matchCriteriaId": "69561727-6405-4EAF-905E-6D5C9761E6EB"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_network_slice_selection_function:22.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "D6577F14-36B6-46A5-A1B1-FCCADA61A23B"}]}]}], "references": [{"url": "https://github.com/krb5/krb5/commit/d775c95af7606a51bf79547a94fa52ddd1cb7f49", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/krb5/krb5/releases", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/09/msg00019.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/MFCLW7D46E4VCREKKH453T5DA4XOLHU2/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20210923-0002/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://web.mit.edu/kerberos/advisories/", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujul2022.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.starwindsoftware.com/security/sw-20220817-0004/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/krb5/krb5/commit/d775c95af7606a51bf79547a94fa52ddd1cb7f49"}}