{"buggy_code": ["/* #pragma ident\t\"@(#)g_accept_sec_context.c\t1.19\t04/02/23 SMI\" */\n\n/*\n * Copyright 1996 by Sun Microsystems, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of Sun Microsystems not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. Sun Microsystems makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n *  glue routine for gss_accept_sec_context\n */\n\n#include \"mglueP.h\"\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#include <string.h>\n#include <errno.h>\n#include <time.h>\n\n#ifndef LEAN_CLIENT\nstatic OM_uint32\nval_acc_sec_ctx_args(\n    OM_uint32 *minor_status,\n    gss_ctx_id_t *context_handle,\n    gss_cred_id_t verifier_cred_handle,\n    gss_buffer_t input_token_buffer,\n    gss_channel_bindings_t input_chan_bindings,\n    gss_name_t *src_name,\n    gss_OID *mech_type,\n    gss_buffer_t output_token,\n    OM_uint32 *ret_flags,\n    OM_uint32 *time_rec,\n    gss_cred_id_t *d_cred)\n{\n\n    /* Initialize outputs. */\n\n    if (minor_status != NULL)\n\t*minor_status = 0;\n\n    if (src_name != NULL)\n\t*src_name = GSS_C_NO_NAME;\n\n    if (mech_type != NULL)\n\t*mech_type = GSS_C_NO_OID;\n\n    if (output_token != GSS_C_NO_BUFFER) {\n\toutput_token->length = 0;\n\toutput_token->value = NULL;\n    }\n\n    if (d_cred != NULL)\n\t*d_cred = GSS_C_NO_CREDENTIAL;\n\n    /* Validate arguments. */\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (context_handle == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (input_token_buffer == GSS_C_NO_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n\n    if (output_token == GSS_C_NO_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    return (GSS_S_COMPLETE);\n}\n\n/* Return true if mech should be accepted with no acceptor credential. */\nstatic int\nallow_mech_by_default(gss_OID mech)\n{\n    OM_uint32 status, minor;\n    gss_OID_set attrs;\n    int reject = 0, p;\n\n    /* Whether we accept an interposer mech depends on whether we accept the\n     * mech it interposes. */\n    mech = gssint_get_public_oid(mech);\n    if (mech == GSS_C_NO_OID)\n\treturn 0;\n\n    status = gss_inquire_attrs_for_mech(&minor, mech, &attrs, NULL);\n    if (status)\n\treturn 0;\n\n    /* Check for each attribute which would cause us to exclude this mech from\n     * the default credential. */\n    if (generic_gss_test_oid_set_member(&minor, GSS_C_MA_DEPRECATED,\n\t\t\t\t\tattrs, &p) != GSS_S_COMPLETE || p)\n\treject = 1;\n    else if (generic_gss_test_oid_set_member(&minor, GSS_C_MA_NOT_DFLT_MECH,\n\t\t\t\t\t     attrs, &p) != GSS_S_COMPLETE || p)\n\treject = 1;\n\n    (void) gss_release_oid_set(&minor, &attrs);\n    return !reject;\n}\n\nOM_uint32 KRB5_CALLCONV\ngss_accept_sec_context (minor_status,\n                        context_handle,\n                        verifier_cred_handle,\n                        input_token_buffer,\n                        input_chan_bindings,\n                        src_name,\n                        mech_type,\n                        output_token,\n                        ret_flags,\n                        time_rec,\n                        d_cred)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t *\t\tcontext_handle;\ngss_cred_id_t\t\tverifier_cred_handle;\ngss_buffer_t\t\tinput_token_buffer;\ngss_channel_bindings_t\tinput_chan_bindings;\ngss_name_t *\t\tsrc_name;\ngss_OID *\t\tmech_type;\ngss_buffer_t\t\toutput_token;\nOM_uint32 *\t\tret_flags;\nOM_uint32 *\t\ttime_rec;\ngss_cred_id_t *\t\td_cred;\n\n{\n    OM_uint32\t\tstatus, temp_status, temp_minor_status;\n    OM_uint32\t\ttemp_ret_flags = 0;\n    gss_union_ctx_id_t\tunion_ctx_id = NULL;\n    gss_cred_id_t\tinput_cred_handle = GSS_C_NO_CREDENTIAL;\n    gss_cred_id_t\ttmp_d_cred = GSS_C_NO_CREDENTIAL;\n    gss_name_t\t\tinternal_name = GSS_C_NO_NAME;\n    gss_name_t\t\ttmp_src_name = GSS_C_NO_NAME;\n    gss_OID_desc\ttoken_mech_type_desc;\n    gss_OID\t\ttoken_mech_type = &token_mech_type_desc;\n    gss_OID\t\tactual_mech = GSS_C_NO_OID;\n    gss_OID\t\tselected_mech = GSS_C_NO_OID;\n    gss_OID\t\tpublic_mech;\n    gss_mechanism\tmech = NULL;\n    gss_union_cred_t\tuc;\n    int\t\t\ti;\n\n    status = val_acc_sec_ctx_args(minor_status,\n\t\t\t\t  context_handle,\n\t\t\t\t  verifier_cred_handle,\n\t\t\t\t  input_token_buffer,\n\t\t\t\t  input_chan_bindings,\n\t\t\t\t  src_name,\n\t\t\t\t  mech_type,\n\t\t\t\t  output_token,\n\t\t\t\t  ret_flags,\n\t\t\t\t  time_rec,\n\t\t\t\t  d_cred);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * if context_handle is GSS_C_NO_CONTEXT, allocate a union context\n     * descriptor to hold the mech type information as well as the\n     * underlying mechanism context handle. Otherwise, cast the\n     * value of *context_handle to the union context variable.\n     */\n\n    if(*context_handle == GSS_C_NO_CONTEXT) {\n\n\tif (input_token_buffer == GSS_C_NO_BUFFER)\n\t    return (GSS_S_CALL_INACCESSIBLE_READ);\n\n\t/* Get the token mech type */\n\tstatus = gssint_get_mech_type(token_mech_type, input_token_buffer);\n\tif (status)\n\t    return status;\n\n\t/*\n\t * An interposer calling back into the mechglue can't pass in a special\n\t * mech, so we have to recognize it using verifier_cred_handle.  Use\n\t * the mechanism for which we have matching creds, if available.\n\t */\n\tif (verifier_cred_handle != GSS_C_NO_CREDENTIAL) {\n\t    uc = (gss_union_cred_t)verifier_cred_handle;\n\t    for (i = 0; i < uc->count; i++) {\n\t\tpublic_mech = gssint_get_public_oid(&uc->mechs_array[i]);\n\t\tif (public_mech && g_OID_equal(token_mech_type, public_mech)) {\n\t\t    selected_mech = &uc->mechs_array[i];\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\n\tif (selected_mech == GSS_C_NO_OID) {\n\t    status = gssint_select_mech_type(minor_status, token_mech_type,\n\t\t\t\t\t     &selected_mech);\n\t    if (status)\n\t\treturn status;\n\t}\n\n    } else {\n\tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n\tselected_mech = union_ctx_id->mech_type;\n    }\n\n    /* Now create a new context if we didn't get one. */\n    if (*context_handle == GSS_C_NO_CONTEXT) {\n\tstatus = GSS_S_FAILURE;\n\tunion_ctx_id = (gss_union_ctx_id_t)\n\t    malloc(sizeof(gss_union_ctx_id_desc));\n\tif (!union_ctx_id)\n\t    return (GSS_S_FAILURE);\n\n\tunion_ctx_id->loopback = union_ctx_id;\n\tunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\n\tstatus = generic_gss_copy_oid(&temp_minor_status, selected_mech,\n\t\t\t\t      &union_ctx_id->mech_type);\n\tif (status != GSS_S_COMPLETE) {\n\t    free(union_ctx_id);\n\t    return (status);\n\t}\n\n\t/* set the new context handle to caller's data */\n\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n    }\n\n    /*\n     * get the appropriate cred handle from the union cred struct.\n     */\n    if (verifier_cred_handle != GSS_C_NO_CREDENTIAL) {\n\tinput_cred_handle =\n\t    gssint_get_mechanism_cred((gss_union_cred_t)verifier_cred_handle,\n\t\t\t\t      selected_mech);\n\tif (input_cred_handle == GSS_C_NO_CREDENTIAL) {\n\t    /* verifier credential specified but no acceptor credential found */\n\t    status = GSS_S_NO_CRED;\n\t    goto error_out;\n\t}\n    } else if (!allow_mech_by_default(selected_mech)) {\n\tstatus = GSS_S_NO_CRED;\n\tgoto error_out;\n    }\n\n    /*\n     * now select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    mech = gssint_get_mechanism(selected_mech);\n    if (mech && mech->gss_accept_sec_context) {\n\n\t    status = mech->gss_accept_sec_context(minor_status,\n\t\t\t\t\t\t  &union_ctx_id->internal_ctx_id,\n\t\t\t\t\t\t  input_cred_handle,\n\t\t\t\t\t\t  input_token_buffer,\n\t\t\t\t\t\t  input_chan_bindings,\n\t\t\t\t\t\t  src_name ? &internal_name : NULL,\n\t\t\t\t\t\t  &actual_mech,\n\t\t\t\t\t\t  output_token,\n\t\t\t\t\t\t  &temp_ret_flags,\n\t\t\t\t\t\t  time_rec,\n\t\t\t\t\td_cred ? &tmp_d_cred : NULL);\n\n\t    /* If there's more work to do, keep going... */\n\t    if (status == GSS_S_CONTINUE_NEEDED)\n\t\treturn GSS_S_CONTINUE_NEEDED;\n\n\t    /* if the call failed, return with failure */\n\t    if (status != GSS_S_COMPLETE) {\n\t\tmap_error(minor_status, mech);\n\t\tgoto error_out;\n\t    }\n\n\t    /*\n\t     * if src_name is non-NULL,\n\t     * convert internal_name into a union name equivalent\n\t     * First call the mechanism specific display_name()\n\t     * then call gss_import_name() to create\n\t     * the union name struct cast to src_name\n\t     */\n\t    if (src_name != NULL) {\n\t\tif (internal_name != GSS_C_NO_NAME) {\n\t\t    /* consumes internal_name regardless of success */\n\t\t    temp_status = gssint_convert_name_to_union_name(\n\t\t\t    &temp_minor_status, mech,\n\t\t\t    internal_name, &tmp_src_name);\n\t\t    if (temp_status != GSS_S_COMPLETE) {\n\t\t\tstatus = temp_status;\n\t\t\t*minor_status = temp_minor_status;\n\t\t\tmap_error(minor_status, mech);\n\t\t\tif (output_token->length)\n\t\t\t    (void) gss_release_buffer(&temp_minor_status,\n\t\t\t\t\t\t      output_token);\n\t\t\tgoto error_out;\n\t\t    }\n\t\t    *src_name = tmp_src_name;\n\t\t} else\n\t\t    *src_name = GSS_C_NO_NAME;\n\t    }\n\n#define g_OID_prefix_equal(o1, o2) \\\n        (((o1)->length >= (o2)->length) && \\\n        (memcmp((o1)->elements, (o2)->elements, (o2)->length) == 0))\n\n\t    /* Ensure we're returning correct creds format */\n\t    if ((temp_ret_flags & GSS_C_DELEG_FLAG) &&\n\t\ttmp_d_cred != GSS_C_NO_CREDENTIAL) {\n\t\tpublic_mech = gssint_get_public_oid(selected_mech);\n\t\tif (actual_mech != GSS_C_NO_OID &&\n\t\t    public_mech != GSS_C_NO_OID &&\n\t\t    !g_OID_prefix_equal(actual_mech, public_mech)) {\n\t\t    *d_cred = tmp_d_cred; /* unwrapped pseudo-mech */\n\t\t} else {\n\t\t    gss_union_cred_t d_u_cred = NULL;\n\n\t\t    d_u_cred = malloc(sizeof (gss_union_cred_desc));\n\t\t    if (d_u_cred == NULL) {\n\t\t\tstatus = GSS_S_FAILURE;\n\t\t\tgoto error_out;\n\t\t    }\n\t\t    (void) memset(d_u_cred, 0, sizeof (gss_union_cred_desc));\n\n\t\t    d_u_cred->count = 1;\n\n\t\t    status = generic_gss_copy_oid(&temp_minor_status,\n\t\t\t\t\t\t  selected_mech,\n\t\t\t\t\t\t  &d_u_cred->mechs_array);\n\n\t\t    if (status != GSS_S_COMPLETE) {\n\t\t\tfree(d_u_cred);\n\t\t\tgoto error_out;\n\t\t    }\n\n\t\t    d_u_cred->cred_array = malloc(sizeof(gss_cred_id_t));\n\t\t    if (d_u_cred->cred_array != NULL) {\n\t\t\td_u_cred->cred_array[0] = tmp_d_cred;\n\t\t    } else {\n\t\t\tfree(d_u_cred);\n\t\t\tstatus = GSS_S_FAILURE;\n\t\t\tgoto error_out;\n\t\t    }\n\n\t\t    d_u_cred->loopback = d_u_cred;\n\t\t    *d_cred = (gss_cred_id_t)d_u_cred;\n\t\t}\n\t    }\n\n\t    if (mech_type != NULL)\n\t\t*mech_type = gssint_get_public_oid(actual_mech);\n\t    if (ret_flags != NULL)\n\t\t*ret_flags = temp_ret_flags;\n\t    return\t(status);\n    } else {\n\n\tstatus = GSS_S_BAD_MECH;\n    }\n\nerror_out:\n    if (union_ctx_id) {\n\tif (union_ctx_id->mech_type) {\n\t    if (union_ctx_id->mech_type->elements)\n\t\tfree(union_ctx_id->mech_type->elements);\n\t    free(union_ctx_id->mech_type);\n\t}\n\tif (union_ctx_id->internal_ctx_id && mech &&\n\t    mech->gss_delete_sec_context) {\n\t    mech->gss_delete_sec_context(&temp_minor_status,\n\t\t\t\t\t &union_ctx_id->internal_ctx_id,\n\t\t\t\t\t GSS_C_NO_BUFFER);\n\t}\n\tfree(union_ctx_id);\n\t*context_handle = GSS_C_NO_CONTEXT;\n    }\n\n    if (src_name)\n\t*src_name = GSS_C_NO_NAME;\n\n    if (tmp_src_name != GSS_C_NO_NAME)\n\t(void) gss_release_buffer(&temp_minor_status,\n\t\t\t\t  (gss_buffer_t)tmp_src_name);\n\n    return (status);\n}\n#endif /* LEAN_CLIENT */\n", "/* #ident  \"@(#)gss_seal.c 1.10     95/08/07 SMI\" */\n\n/*\n * Copyright 1996 by Sun Microsystems, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of Sun Microsystems not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. Sun Microsystems makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n *  glue routine for gss_complete_auth_token\n */\n\n#include \"mglueP.h\"\n#include <stdio.h>\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#include <string.h>\n#include <errno.h>\n\nOM_uint32 KRB5_CALLCONV\ngss_complete_auth_token (OM_uint32 *minor_status,\n\t                 const gss_ctx_id_t context_handle,\n\t                 gss_buffer_t input_message_buffer)\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech != NULL) {\n\tif (mech->gss_complete_auth_token != NULL) {\n\t    status = mech->gss_complete_auth_token(minor_status,\n\t\t\t\t\t\t   ctx->internal_ctx_id,\n\t\t\t\t\t\t   input_message_buffer);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_COMPLETE;\n    } else\n\tstatus = GSS_S_BAD_MECH;\n\n    return status;\n}\n", "/* #pragma ident\t\"@(#)g_context_time.c\t1.12\t98/01/22 SMI\" */\n\n/*\n * Copyright 1996 by Sun Microsystems, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of Sun Microsystems not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. Sun Microsystems makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n *  glue routines for gss_context_time\n */\n\n#include \"mglueP.h\"\n\nOM_uint32 KRB5_CALLCONV\ngss_context_time (minor_status,\n                  context_handle,\n                  time_rec)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nOM_uint32 *\t\ttime_rec;\n\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n    *minor_status = 0;\n\n    if (time_rec == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech) {\n\n\tif (mech->gss_context_time) {\n\t    status = mech->gss_context_time(\n\t\t\t\t\t    minor_status,\n\t\t\t\t\t    ctx->internal_ctx_id,\n\t\t\t\t\t    time_rec);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn(status);\n    }\n\n    return (GSS_S_BAD_MECH);\n}\n", "/* #pragma ident\t\"@(#)g_delete_sec_context.c\t1.11\t97/11/09 SMI\" */\n\n/*\n * Copyright 1996 by Sun Microsystems, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of Sun Microsystems not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. Sun Microsystems makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n *  glue routine for gss_delete_sec_context\n */\n\n#include \"mglueP.h\"\n#include <stdio.h>\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n\nstatic OM_uint32\nval_del_sec_ctx_args(\n    OM_uint32 *minor_status,\n    gss_ctx_id_t *context_handle,\n    gss_buffer_t output_token)\n{\n\n    /* Initialize outputs. */\n\n    if (minor_status != NULL)\n\t*minor_status = 0;\n\n    if (output_token != GSS_C_NO_BUFFER) {\n\toutput_token->length = 0;\n\toutput_token->value = NULL;\n    }\n\n    /* Validate arguments. */\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (context_handle == NULL || *context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE | GSS_S_NO_CONTEXT);\n\n    return (GSS_S_COMPLETE);\n}\n\n\nOM_uint32 KRB5_CALLCONV\ngss_delete_sec_context (minor_status,\n                        context_handle,\n                        output_token)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t *\t\tcontext_handle;\ngss_buffer_t\t\toutput_token;\n\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n\n    status = val_del_sec_ctx_args(minor_status, context_handle, output_token);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) *context_handle;\n    if (GSSINT_CHK_LOOP(ctx))\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    status = gssint_delete_internal_sec_context(minor_status,\n\t\t\t\t\t\tctx->mech_type,\n\t\t\t\t\t\t&ctx->internal_ctx_id,\n\t\t\t\t\t\toutput_token);\n    if (status)\n\treturn status;\n\n    /* now free up the space for the union context structure */\n    free(ctx->mech_type->elements);\n    free(ctx->mech_type);\n    free(*context_handle);\n    *context_handle = GSS_C_NO_CONTEXT;\n\n    return (GSS_S_COMPLETE);\n}\n", "/* #pragma ident\t\"@(#)g_exp_sec_context.c\t1.14\t04/02/23 SMI\" */\n\n/*\n * Copyright 1996 by Sun Microsystems, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of Sun Microsystems not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. Sun Microsystems makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n *  glue routine for gss_export_sec_context\n */\n#ifndef LEAN_CLIENT\n\n#include \"mglueP.h\"\n#include <stdio.h>\n#include <errno.h>\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#include <string.h>\n\nstatic OM_uint32\nval_exp_sec_ctx_args(\n    OM_uint32 *minor_status,\n    gss_ctx_id_t *context_handle,\n    gss_buffer_t interprocess_token)\n{\n\n    /* Initialize outputs. */\n\n    if (minor_status != NULL)\n\t*minor_status = 0;\n\n    if (interprocess_token != GSS_C_NO_BUFFER) {\n\tinterprocess_token->length = 0;\n\tinterprocess_token->value = NULL;\n    }\n\n    /* Validate arguments. */\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (context_handle == NULL || *context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (interprocess_token == GSS_C_NO_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    return (GSS_S_COMPLETE);\n}\n\n\nOM_uint32 KRB5_CALLCONV\ngss_export_sec_context(minor_status,\n                       context_handle,\n                       interprocess_token)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t *\t\tcontext_handle;\ngss_buffer_t\t\tinterprocess_token;\n\n{\n    OM_uint32\t\tstatus;\n    OM_uint32 \t\tlength;\n    gss_union_ctx_id_t\tctx = NULL;\n    gss_mechanism\tmech;\n    gss_buffer_desc\ttoken = GSS_C_EMPTY_BUFFER;\n    char\t\t*buf;\n\n    status = val_exp_sec_ctx_args(minor_status,\n\t\t\t\t  context_handle, interprocess_token);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) *context_handle;\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (!mech)\n\treturn GSS_S_BAD_MECH;\n    if (!mech->gss_export_sec_context)\n\treturn (GSS_S_UNAVAILABLE);\n\n    status = mech->gss_export_sec_context(minor_status,\n\t\t\t\t\t  &ctx->internal_ctx_id, &token);\n    if (status != GSS_S_COMPLETE) {\n\tmap_error(minor_status, mech);\n\tgoto cleanup;\n    }\n\n    length = token.length + 4 + ctx->mech_type->length;\n    interprocess_token->length = length;\n    interprocess_token->value = malloc(length);\n    if (interprocess_token->value == 0) {\n\t*minor_status = ENOMEM;\n\tstatus = GSS_S_FAILURE;\n\tgoto cleanup;\n    }\n    buf = interprocess_token->value;\n    length = ctx->mech_type->length;\n    buf[3] = (unsigned char) (length & 0xFF);\n    length >>= 8;\n    buf[2] = (unsigned char) (length & 0xFF);\n    length >>= 8;\n    buf[1] = (unsigned char) (length & 0xFF);\n    length >>= 8;\n    buf[0] = (unsigned char) (length & 0xFF);\n    memcpy(buf+4, ctx->mech_type->elements, (size_t) ctx->mech_type->length);\n    memcpy(buf+4+ctx->mech_type->length, token.value, token.length);\n\n    status = GSS_S_COMPLETE;\n\ncleanup:\n    (void) gss_release_buffer(minor_status, &token);\n    if (ctx != NULL && ctx->internal_ctx_id == GSS_C_NO_CONTEXT) {\n\t/* If the mech deleted its context, delete the union context. */\n\tfree(ctx->mech_type->elements);\n\tfree(ctx->mech_type);\n\tfree(ctx);\n\t*context_handle = GSS_C_NO_CONTEXT;\n    }\n    return status;\n}\n#endif /*LEAN_CLIENT */\n", "/* #pragma ident\t\"@(#)g_init_sec_context.c\t1.20\t03/10/24 SMI\" */\n\n/*\n * Copyright 1996 by Sun Microsystems, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of Sun Microsystems not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. Sun Microsystems makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n *  glue routine for gss_init_sec_context\n */\n\n#include \"mglueP.h\"\n#include <stdio.h>\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#include <string.h>\n\nstatic OM_uint32\nval_init_sec_ctx_args(\n    OM_uint32 *minor_status,\n    gss_cred_id_t claimant_cred_handle,\n    gss_ctx_id_t *context_handle,\n    gss_name_t target_name,\n    gss_OID req_mech_type,\n    OM_uint32 req_flags,\n    OM_uint32 time_req,\n    gss_channel_bindings_t input_chan_bindings,\n    gss_buffer_t input_token,\n    gss_OID *actual_mech_type,\n    gss_buffer_t output_token,\n    OM_uint32 *ret_flags,\n    OM_uint32 *time_rec)\n{\n\n    /* Initialize outputs. */\n\n    if (minor_status != NULL)\n\t*minor_status = 0;\n\n    if (actual_mech_type != NULL)\n\t*actual_mech_type = GSS_C_NO_OID;\n\n    if (output_token != GSS_C_NO_BUFFER) {\n\toutput_token->length = 0;\n\toutput_token->value = NULL;\n    }\n\n    /* Validate arguments. */\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (context_handle == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE | GSS_S_NO_CONTEXT);\n\n    if (target_name == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_BAD_NAME);\n\n    if (output_token == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    return (GSS_S_COMPLETE);\n}\n\n\nOM_uint32 KRB5_CALLCONV\ngss_init_sec_context (minor_status,\n                      claimant_cred_handle,\n                      context_handle,\n                      target_name,\n                      req_mech_type,\n                      req_flags,\n                      time_req,\n                      input_chan_bindings,\n                      input_token,\n                      actual_mech_type,\n                      output_token,\n                      ret_flags,\n                      time_rec)\n\nOM_uint32 *\t\tminor_status;\ngss_cred_id_t\t\tclaimant_cred_handle;\ngss_ctx_id_t *\t\tcontext_handle;\ngss_name_t\t\ttarget_name;\ngss_OID\t\t\treq_mech_type;\nOM_uint32\t\treq_flags;\nOM_uint32\t\ttime_req;\ngss_channel_bindings_t\tinput_chan_bindings;\ngss_buffer_t\t\tinput_token;\ngss_OID *\t\tactual_mech_type;\ngss_buffer_t\t\toutput_token;\nOM_uint32 *\t\tret_flags;\nOM_uint32 *\t\ttime_rec;\n\n{\n    OM_uint32\t\tstatus, temp_minor_status;\n    gss_union_name_t\tunion_name;\n    gss_union_cred_t\tunion_cred;\n    gss_name_t\t\tinternal_name;\n    gss_union_ctx_id_t\tunion_ctx_id;\n    gss_OID\t\tselected_mech;\n    gss_mechanism\tmech;\n    gss_cred_id_t\tinput_cred_handle;\n\n    status = val_init_sec_ctx_args(minor_status,\n\t\t\t\t   claimant_cred_handle,\n\t\t\t\t   context_handle,\n\t\t\t\t   target_name,\n\t\t\t\t   req_mech_type,\n\t\t\t\t   req_flags,\n\t\t\t\t   time_req,\n\t\t\t\t   input_chan_bindings,\n\t\t\t\t   input_token,\n\t\t\t\t   actual_mech_type,\n\t\t\t\t   output_token,\n\t\t\t\t   ret_flags,\n\t\t\t\t   time_rec);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    status = gssint_select_mech_type(minor_status, req_mech_type,\n\t\t\t\t     &selected_mech);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    union_name = (gss_union_name_t)target_name;\n\n    /*\n     * obtain the gss mechanism information for the requested\n     * mechanism.  If mech_type is NULL, set it to the resultant\n     * mechanism\n     */\n    mech = gssint_get_mechanism(selected_mech);\n    if (mech == NULL)\n\treturn (GSS_S_BAD_MECH);\n\n    if (mech->gss_init_sec_context == NULL)\n\treturn (GSS_S_UNAVAILABLE);\n\n    /*\n     * If target_name is mechanism_specific, then it must match the\n     * mech_type that we're about to use.  Otherwise, do an import on\n     * the external_name form of the target name.\n     */\n    if (union_name->mech_type &&\n\tg_OID_equal(union_name->mech_type, selected_mech)) {\n\tinternal_name = union_name->mech_name;\n    } else {\n\tif ((status = gssint_import_internal_name(minor_status, selected_mech,\n\t\t\t\t\t\t union_name,\n\t\t\t\t\t\t &internal_name)) != GSS_S_COMPLETE)\n\t    return (status);\n    }\n\n    /*\n     * if context_handle is GSS_C_NO_CONTEXT, allocate a union context\n     * descriptor to hold the mech type information as well as the\n     * underlying mechanism context handle. Otherwise, cast the\n     * value of *context_handle to the union context variable.\n     */\n\n    if(*context_handle == GSS_C_NO_CONTEXT) {\n\tstatus = GSS_S_FAILURE;\n\tunion_ctx_id = (gss_union_ctx_id_t)\n\t    malloc(sizeof(gss_union_ctx_id_desc));\n\tif (union_ctx_id == NULL)\n\t    goto end;\n\n\tif (generic_gss_copy_oid(&temp_minor_status, selected_mech,\n\t\t\t\t &union_ctx_id->mech_type) != GSS_S_COMPLETE) {\n\t    free(union_ctx_id);\n\t    goto end;\n\t}\n\n\t/* copy the supplied context handle */\n\tunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\n    } else\n\tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n\n    /*\n     * get the appropriate cred handle from the union cred struct.\n     * defaults to GSS_C_NO_CREDENTIAL if there is no cred, which will\n     * use the default credential.\n     */\n    union_cred = (gss_union_cred_t) claimant_cred_handle;\n    input_cred_handle = gssint_get_mechanism_cred(union_cred, selected_mech);\n\n    /*\n     * now call the approprate underlying mechanism routine\n     */\n\n    status = mech->gss_init_sec_context(\n\tminor_status,\n\tinput_cred_handle,\n\t&union_ctx_id->internal_ctx_id,\n\tinternal_name,\n\tgssint_get_public_oid(selected_mech),\n\treq_flags,\n\ttime_req,\n\tinput_chan_bindings,\n\tinput_token,\n\tactual_mech_type,\n\toutput_token,\n\tret_flags,\n\ttime_rec);\n\n    if (status != GSS_S_COMPLETE && status != GSS_S_CONTINUE_NEEDED) {\n\t/*\n\t * The spec says the preferred method is to delete all context info on\n\t * the first call to init, and on all subsequent calls make the caller\n\t * responsible for calling gss_delete_sec_context.  However, if the\n\t * mechanism decided to delete the internal context, we should also\n\t * delete the union context.\n\t */\n\tmap_error(minor_status, mech);\n\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n\t    *context_handle = GSS_C_NO_CONTEXT;\n\tif (*context_handle == GSS_C_NO_CONTEXT) {\n\t    free(union_ctx_id->mech_type->elements);\n\t    free(union_ctx_id->mech_type);\n\t    free(union_ctx_id);\n\t}\n    } else if (*context_handle == GSS_C_NO_CONTEXT) {\n\tunion_ctx_id->loopback = union_ctx_id;\n\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n    }\n\nend:\n    if (union_name->mech_name == NULL ||\n\tunion_name->mech_name != internal_name) {\n\t(void) gssint_release_internal_name(&temp_minor_status,\n\t\t\t\t\t    selected_mech, &internal_name);\n    }\n\n    return(status);\n}\n", "/* #pragma ident\t\"@(#)g_inquire_context.c\t1.15\t04/02/23 SMI\" */\n\n/*\n * Copyright 1996 by Sun Microsystems, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of Sun Microsystems not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. Sun Microsystems makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n *  glue routine for gss_inquire_context\n */\n\n#include \"mglueP.h\"\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n\nstatic OM_uint32\nval_inq_ctx_args(\n    OM_uint32 *minor_status,\n    gss_ctx_id_t context_handle,\n    gss_name_t *src_name,\n    gss_name_t *targ_name,\n    OM_uint32 *lifetime_rec,\n    gss_OID *mech_type,\n    OM_uint32 *ctx_flags,\n    int *locally_initiated,\n    int *opened)\n{\n\n    /* Initialize outputs. */\n\n    if (minor_status != NULL)\n\t*minor_status = 0;\n\n    if (src_name != NULL)\n\t*src_name = GSS_C_NO_NAME;\n\n    if (targ_name != NULL)\n\t*targ_name = GSS_C_NO_NAME;\n\n    if (mech_type != NULL)\n\t*mech_type = GSS_C_NO_OID;\n\n    /* Validate arguments. */\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    return (GSS_S_COMPLETE);\n}\n\n\n/* Last argument new for V2 */\nOM_uint32 KRB5_CALLCONV\ngss_inquire_context(\n\t    OM_uint32 *minor_status,\n\t    gss_ctx_id_t context_handle,\n\t    gss_name_t *src_name,\n\t    gss_name_t *targ_name,\n\t    OM_uint32 *lifetime_rec,\n\t    gss_OID *mech_type,\n\t    OM_uint32 *ctx_flags,\n\t    int *locally_initiated,\n\t    int *opened)\n{\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    OM_uint32\t\tstatus, temp_minor;\n    gss_OID\t\tactual_mech;\n    gss_name_t localTargName = NULL, localSourceName = NULL;\n\n    status = val_inq_ctx_args(minor_status,\n\t\t\t      context_handle,\n\t\t\t      src_name, targ_name,\n\t\t\t      lifetime_rec,\n\t\t\t      mech_type, ctx_flags,\n\t\t\t      locally_initiated, opened);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (!mech || !mech->gss_inquire_context || !mech->gss_display_name ||\n\t!mech->gss_release_name) {\n\treturn (GSS_S_UNAVAILABLE);\n    }\n\n    status = mech->gss_inquire_context(\n\t\t\tminor_status,\n\t\t\tctx->internal_ctx_id,\n\t\t\t(src_name ? &localSourceName : NULL),\n\t\t\t(targ_name ? &localTargName : NULL),\n\t\t\tlifetime_rec,\n\t\t\t&actual_mech,\n\t\t\tctx_flags,\n\t\t\tlocally_initiated,\n\t\t\topened);\n\n    if (status != GSS_S_COMPLETE) {\n\tmap_error(minor_status, mech);\n\treturn status;\n    }\n\n    /* need to convert names */\n\n    if (src_name) {\n\tif (localSourceName) {\n\t    status = gssint_convert_name_to_union_name(minor_status, mech,\n\t\t\t\t\t\t      localSourceName, src_name);\n\n\t    if (status != GSS_S_COMPLETE) {\n\t\tif (localTargName)\n\t\t    mech->gss_release_name(&temp_minor, &localTargName);\n\t\treturn (status);\n\t    }\n\t} else {\n\t    *src_name = GSS_C_NO_NAME;\n\t}\n    }\n\n    if (targ_name) {\n        if (localTargName) {\n\t    status = gssint_convert_name_to_union_name(minor_status, mech,\n\t\t\t\t\t\t      localTargName, targ_name);\n\n\t    if (status != GSS_S_COMPLETE) {\n\t\tif (src_name)\n\t\t    (void) gss_release_name(&temp_minor, src_name);\n\n\t\treturn (status);\n\t    }\n        }\n        else {\n            *targ_name = GSS_C_NO_NAME;\n        }\n    }\n\n    if (mech_type)\n\t*mech_type = gssint_get_public_oid(actual_mech);\n\n    return(GSS_S_COMPLETE);\n}\n", "/*\n * Copyright 2009 by the Massachusetts Institute of Technology.\n * All Rights Reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n\n/* Glue routine for gss_pseudo_random */\n\n#include \"mglueP.h\"\n\nOM_uint32 KRB5_CALLCONV\ngss_pseudo_random (OM_uint32 *minor_status,\n\t           gss_ctx_id_t context_handle,\n\t           int prf_key,\n\t           const gss_buffer_t prf_in,\n\t           ssize_t desired_output_len,\n\t           gss_buffer_t prf_out)\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    if (minor_status == NULL)\n\treturn GSS_S_CALL_INACCESSIBLE_WRITE;\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT;\n\n    if (prf_in == GSS_C_NO_BUFFER)\n\treturn GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT;\n\n    if (prf_out == GSS_C_NO_BUFFER)\n\treturn GSS_S_CALL_INACCESSIBLE_WRITE | GSS_S_NO_CONTEXT;\n\n    prf_out->length = 0;\n    prf_out->value = NULL;\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech != NULL) {\n\tif (mech->gss_pseudo_random != NULL) {\n\t    status = mech->gss_pseudo_random(minor_status,\n\t\t\t\t\t     ctx->internal_ctx_id,\n\t\t\t\t\t     prf_key,\n\t\t\t\t\t     prf_in,\n\t\t\t\t\t     desired_output_len,\n\t\t\t\t\t     prf_out);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn status;\n    }\n\n    return GSS_S_BAD_MECH;\n}\n", "/* #pragma ident\t\"@(#)g_process_context.c\t1.12\t98/01/22 SMI\" */\n\n/*\n * Copyright 1996 by Sun Microsystems, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of Sun Microsystems not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. Sun Microsystems makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n *  glue routine gss_process_context\n */\n\n#include \"mglueP.h\"\n\nOM_uint32 KRB5_CALLCONV\ngss_process_context_token (minor_status,\n                           context_handle,\n                           token_buffer)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_buffer_t\t\ttoken_buffer;\n\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n    *minor_status = 0;\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (token_buffer == GSS_C_NO_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n\n    if (GSS_EMPTY_BUFFER(token_buffer))\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech) {\n\n\tif (mech->gss_process_context_token) {\n\t    status = mech->gss_process_context_token(\n\t\t\t\t\t\t    minor_status,\n\t\t\t\t\t\t    ctx->internal_ctx_id,\n\t\t\t\t\t\t    token_buffer);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn(status);\n    }\n\n    return (GSS_S_BAD_MECH);\n}\n", "/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/*\n * Copyright 1996 by Sun Microsystems, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of Sun Microsystems not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. Sun Microsystems makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n *  glue routine for gss_wrap\n */\n\n#include \"mglueP.h\"\n\nstatic OM_uint32\nval_wrap_args(OM_uint32 *minor_status,\n              gss_ctx_id_t context_handle,\n              int conf_req_flag,\n              gss_qop_t qop_req,\n              gss_buffer_t input_message_buffer,\n              int *conf_state,\n              gss_buffer_t output_message_buffer)\n{\n    /* Initialize outputs. */\n\n    if (minor_status != NULL)\n        *minor_status = 0;\n\n    if (output_message_buffer != GSS_C_NO_BUFFER) {\n        output_message_buffer->length = 0;\n        output_message_buffer->value = NULL;\n    }\n\n    /* Validate arguments. */\n\n    if (minor_status == NULL)\n        return (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n        return (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (input_message_buffer == GSS_C_NO_BUFFER)\n        return (GSS_S_CALL_INACCESSIBLE_READ);\n\n    if (output_message_buffer == GSS_C_NO_BUFFER)\n        return (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    return (GSS_S_COMPLETE);\n}\n\nOM_uint32 KRB5_CALLCONV\ngss_wrap( OM_uint32 *minor_status,\n          gss_ctx_id_t context_handle,\n          int conf_req_flag,\n          gss_qop_t qop_req,\n          gss_buffer_t input_message_buffer,\n          int *conf_state,\n          gss_buffer_t output_message_buffer)\n{\n\n    /* EXPORT DELETE START */\n\n    OM_uint32           status;\n    gss_union_ctx_id_t  ctx;\n    gss_mechanism       mech;\n\n    status = val_wrap_args(minor_status, context_handle,\n                           conf_req_flag, qop_req,\n                           input_message_buffer, conf_state,\n                           output_message_buffer);\n    if (status != GSS_S_COMPLETE)\n        return (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech) {\n        if (mech->gss_wrap) {\n            status = mech->gss_wrap(minor_status,\n                                    ctx->internal_ctx_id,\n                                    conf_req_flag,\n                                    qop_req,\n                                    input_message_buffer,\n                                    conf_state,\n                                    output_message_buffer);\n            if (status != GSS_S_COMPLETE)\n                map_error(minor_status, mech);\n        } else if (mech->gss_wrap_aead ||\n                   (mech->gss_wrap_iov && mech->gss_wrap_iov_length)) {\n            status = gssint_wrap_aead(mech,\n                                      minor_status,\n                                      ctx,\n                                      conf_req_flag,\n                                      (gss_qop_t)qop_req,\n                                      GSS_C_NO_BUFFER,\n                                      input_message_buffer,\n                                      conf_state,\n                                      output_message_buffer);\n        } else\n            status = GSS_S_UNAVAILABLE;\n\n        return(status);\n    }\n    /* EXPORT DELETE END */\n\n    return (GSS_S_BAD_MECH);\n}\n\nOM_uint32 KRB5_CALLCONV\ngss_seal(OM_uint32 *minor_status,\n         gss_ctx_id_t context_handle,\n         int conf_req_flag,\n         int qop_req,\n         gss_buffer_t input_message_buffer,\n         int *conf_state,\n         gss_buffer_t output_message_buffer)\n{\n\n    return gss_wrap(minor_status, context_handle,\n                    conf_req_flag, (gss_qop_t) qop_req,\n                    input_message_buffer, conf_state,\n                    output_message_buffer);\n}\n\n/*\n * It is only possible to implement gss_wrap_size_limit() on top\n * of gss_wrap_iov_length() for mechanisms that do not use any\n * padding and have fixed length headers/trailers.\n */\nstatic OM_uint32\ngssint_wrap_size_limit_iov_shim(gss_mechanism mech,\n                                OM_uint32 *minor_status,\n                                gss_ctx_id_t context_handle,\n                                int conf_req_flag,\n                                gss_qop_t qop_req,\n                                OM_uint32 req_output_size,\n                                OM_uint32 *max_input_size)\n{\n    gss_iov_buffer_desc iov[4];\n    OM_uint32           status;\n    OM_uint32           ohlen;\n\n    iov[0].type = GSS_IOV_BUFFER_TYPE_HEADER;\n    iov[0].buffer.value = NULL;\n    iov[0].buffer.length = 0;\n\n    iov[1].type = GSS_IOV_BUFFER_TYPE_DATA;\n    iov[1].buffer.length = req_output_size;\n    iov[1].buffer.value = NULL;\n\n    iov[2].type = GSS_IOV_BUFFER_TYPE_PADDING;\n    iov[2].buffer.value = NULL;\n    iov[2].buffer.length = 0;\n\n    iov[3].type = GSS_IOV_BUFFER_TYPE_TRAILER;\n    iov[3].buffer.value = NULL;\n    iov[3].buffer.length = 0;\n\n    assert(mech->gss_wrap_iov_length);\n\n    status = mech->gss_wrap_iov_length(minor_status, context_handle,\n                                       conf_req_flag, qop_req,\n                                       NULL, iov,\n                                       sizeof(iov)/sizeof(iov[0]));\n    if (status != GSS_S_COMPLETE) {\n        map_error(minor_status, mech);\n        return status;\n    }\n\n    ohlen = iov[0].buffer.length + iov[3].buffer.length;\n\n    if (iov[2].buffer.length == 0 && ohlen < req_output_size)\n        *max_input_size = req_output_size - ohlen;\n    else\n        *max_input_size = 0;\n\n    return GSS_S_COMPLETE;\n}\n\n/*\n * New for V2\n */\nOM_uint32 KRB5_CALLCONV\ngss_wrap_size_limit(OM_uint32  *minor_status,\n                    gss_ctx_id_t context_handle,\n                    int conf_req_flag,\n                    gss_qop_t qop_req, OM_uint32 req_output_size, OM_uint32 *max_input_size)\n{\n    gss_union_ctx_id_t  ctx;\n    gss_mechanism       mech;\n    OM_uint32           major_status;\n\n    if (minor_status == NULL)\n        return (GSS_S_CALL_INACCESSIBLE_WRITE);\n    *minor_status = 0;\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n        return (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (max_input_size == NULL)\n        return (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (!mech)\n        return (GSS_S_BAD_MECH);\n\n    if (mech->gss_wrap_size_limit)\n        major_status = mech->gss_wrap_size_limit(minor_status,\n                                                 ctx->internal_ctx_id,\n                                                 conf_req_flag, qop_req,\n                                                 req_output_size, max_input_size);\n    else if (mech->gss_wrap_iov_length)\n        major_status = gssint_wrap_size_limit_iov_shim(mech, minor_status,\n                                                       ctx->internal_ctx_id,\n                                                       conf_req_flag, qop_req,\n                                                       req_output_size, max_input_size);\n    else\n        major_status = GSS_S_UNAVAILABLE;\n    if (major_status != GSS_S_COMPLETE)\n        map_error(minor_status, mech);\n    return major_status;\n}\n", "/* #pragma ident\t\"@(#)g_sign.c\t1.14\t98/04/23 SMI\" */\n\n/*\n * Copyright 1996 by Sun Microsystems, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of Sun Microsystems not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. Sun Microsystems makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n *  glue routine gss_get_mic\n */\n\n#include \"mglueP.h\"\n\nstatic OM_uint32\nval_get_mic_args(\n    OM_uint32 *minor_status,\n    gss_ctx_id_t context_handle,\n    gss_qop_t qop_req,\n    gss_buffer_t message_buffer,\n    gss_buffer_t msg_token)\n{\n\n    /* Initialize outputs. */\n\n    if (minor_status != NULL)\n\t*minor_status = 0;\n\n    if (msg_token != GSS_C_NO_BUFFER) {\n\tmsg_token->value = NULL;\n\tmsg_token->length = 0;\n    }\n\n    /* Validate arguments. */\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (message_buffer == GSS_C_NO_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n\n    if (msg_token == GSS_C_NO_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    return (GSS_S_COMPLETE);\n}\n\n\nOM_uint32 KRB5_CALLCONV\ngss_get_mic (minor_status,\n\t     context_handle,\n\t     qop_req,\n\t     message_buffer,\n\t     msg_token)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_qop_t\t\tqop_req;\ngss_buffer_t\t\tmessage_buffer;\ngss_buffer_t\t\tmsg_token;\n\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    status = val_get_mic_args(minor_status, context_handle,\n\t\t\t      qop_req, message_buffer, msg_token);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech) {\n\tif (mech->gss_get_mic) {\n\t    status = mech->gss_get_mic(\n\t\t\t\t    minor_status,\n\t\t\t\t    ctx->internal_ctx_id,\n\t\t\t\t    qop_req,\n\t\t\t\t    message_buffer,\n\t\t\t\t    msg_token);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn(status);\n    }\n\n    return (GSS_S_BAD_MECH);\n}\n\nOM_uint32 KRB5_CALLCONV\ngss_sign (minor_status,\n          context_handle,\n          qop_req,\n          message_buffer,\n          msg_token)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nint\t\t\tqop_req;\ngss_buffer_t\t\tmessage_buffer;\ngss_buffer_t\t\tmsg_token;\n\n{\n\treturn (gss_get_mic(minor_status, context_handle, (gss_qop_t) qop_req,\n\t\t\t    message_buffer, msg_token));\n}\n", "/* #pragma ident\t\"@(#)g_unseal.c\t1.13\t98/01/22 SMI\" */\n\n/*\n * Copyright 1996 by Sun Microsystems, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of Sun Microsystems not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. Sun Microsystems makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n *  glue routine gss_unwrap\n */\n\n#include \"mglueP.h\"\n\nOM_uint32 KRB5_CALLCONV\ngss_unwrap (minor_status,\n            context_handle,\n            input_message_buffer,\n            output_message_buffer,\n            conf_state,\n            qop_state)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_buffer_t\t\tinput_message_buffer;\ngss_buffer_t\t\toutput_message_buffer;\nint *\t\t\tconf_state;\ngss_qop_t *\t\tqop_state;\n\n{\n/* EXPORT DELETE START */\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    if (minor_status != NULL)\n\t*minor_status = 0;\n\n    if (output_message_buffer != GSS_C_NO_BUFFER) {\n\toutput_message_buffer->length = 0;\n\toutput_message_buffer->value = NULL;\n    }\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (input_message_buffer == GSS_C_NO_BUFFER ||\n\tGSS_EMPTY_BUFFER(input_message_buffer))\n\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n\n    if (output_message_buffer == GSS_C_NO_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n    ctx = (gss_union_ctx_id_t) context_handle;\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech) {\n\tif (mech->gss_unwrap) {\n\t    status = mech->gss_unwrap(minor_status,\n\t\t\t\t      ctx->internal_ctx_id,\n\t\t\t\t      input_message_buffer,\n\t\t\t\t      output_message_buffer,\n\t\t\t\t      conf_state,\n\t\t\t\t      qop_state);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else if (mech->gss_unwrap_aead || mech->gss_unwrap_iov) {\n\t    status = gssint_unwrap_aead(mech,\n\t\t\t\t\tminor_status,\n\t\t\t\t\tctx,\n\t\t\t\t\tinput_message_buffer,\n\t\t\t\t\tGSS_C_NO_BUFFER,\n\t\t\t\t\toutput_message_buffer,\n\t\t\t\t\tconf_state,\n\t\t\t\t\t(gss_qop_t *)qop_state);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn(status);\n    }\n\n/* EXPORT DELETE END */\n\n    return (GSS_S_BAD_MECH);\n}\n\nOM_uint32 KRB5_CALLCONV\ngss_unseal (minor_status,\n            context_handle,\n            input_message_buffer,\n            output_message_buffer,\n            conf_state,\n            qop_state)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_buffer_t\t\tinput_message_buffer;\ngss_buffer_t\t\toutput_message_buffer;\nint *\t\t\tconf_state;\nint *\t\t\tqop_state;\n\n{\n    return (gss_unwrap(minor_status, context_handle,\n\t\t       input_message_buffer,\n\t\t       output_message_buffer, conf_state, (gss_qop_t *) qop_state));\n}\n", "/* #pragma ident\t\"@(#)g_seal.c\t1.19\t98/04/21 SMI\" */\n\n/*\n * Copyright 1996 by Sun Microsystems, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of Sun Microsystems not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. Sun Microsystems makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n *  glue routine for gss_unwrap_aead\n */\n\n#include \"mglueP.h\"\n\nstatic OM_uint32\nval_unwrap_aead_args(\n    OM_uint32 *minor_status,\n    gss_ctx_id_t context_handle,\n    gss_buffer_t input_message_buffer,\n    gss_buffer_t input_assoc_buffer,\n    gss_buffer_t output_payload_buffer,\n    int *conf_state,\n    gss_qop_t *qop_state)\n{\n\n    /* Initialize outputs. */\n\n    if (minor_status != NULL)\n\t*minor_status = 0;\n\n    /* Validate arguments. */\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (input_message_buffer == GSS_C_NO_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n\n    if (output_payload_buffer == GSS_C_NO_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    return (GSS_S_COMPLETE);\n}\n\nstatic OM_uint32\ngssint_unwrap_aead_iov_shim(gss_mechanism mech,\n\t\t\t    OM_uint32 *minor_status,\n\t\t\t    gss_ctx_id_t context_handle,\n\t\t\t    gss_buffer_t input_message_buffer,\n\t\t\t    gss_buffer_t input_assoc_buffer,\n\t\t\t    gss_buffer_t output_payload_buffer,\n\t\t\t    int *conf_state,\n\t\t\t    gss_qop_t *qop_state)\n{\n    OM_uint32\t\t    status;\n    gss_iov_buffer_desc\t    iov[3];\n    int\t\t\t    i = 0;\n\n    iov[i].type = GSS_IOV_BUFFER_TYPE_STREAM;\n    iov[i].buffer = *input_message_buffer;\n    i++;\n\n    if (input_assoc_buffer != NULL) {\n\tiov[i].type = GSS_IOV_BUFFER_TYPE_SIGN_ONLY;\n\tiov[i].buffer = *input_assoc_buffer;\n\ti++;\n    }\n\n    iov[i].type = GSS_IOV_BUFFER_TYPE_DATA | GSS_IOV_BUFFER_FLAG_ALLOCATE;\n    iov[i].buffer.value = NULL;\n    iov[i].buffer.length = 0;\n    i++;\n\n    assert(mech->gss_unwrap_iov);\n\n    status = mech->gss_unwrap_iov(minor_status, context_handle, conf_state,\n\t\t\t\t  qop_state, iov, i);\n    if (status == GSS_S_COMPLETE) {\n\t*output_payload_buffer = iov[i - 1].buffer;\n    } else {\n\tOM_uint32 minor;\n\n\tmap_error(minor_status, mech);\n\n\tif (iov[i - 1].type & GSS_IOV_BUFFER_FLAG_ALLOCATED) {\n\t    gss_release_buffer(&minor, &iov[i - 1].buffer);\n\t    iov[i - 1].type &= ~(GSS_IOV_BUFFER_FLAG_ALLOCATED);\n\t}\n    }\n\n    return status;\n}\n\nOM_uint32\ngssint_unwrap_aead (gss_mechanism mech,\n\t\t    OM_uint32 *minor_status,\n\t\t    gss_union_ctx_id_t ctx,\n\t\t    gss_buffer_t input_message_buffer,\n\t\t    gss_buffer_t input_assoc_buffer,\n\t\t    gss_buffer_t output_payload_buffer,\n\t\t    int *conf_state,\n\t\t    gss_qop_t *qop_state)\n{\n    OM_uint32\t\t    status;\n\n    assert(mech != NULL);\n    assert(ctx != NULL);\n\n /* EXPORT DELETE START */\n\n    if (mech->gss_unwrap_aead) {\n\tstatus = mech->gss_unwrap_aead(minor_status,\n\t\t\t\t       ctx->internal_ctx_id,\n\t\t\t\t       input_message_buffer,\n\t\t\t\t       input_assoc_buffer,\n\t\t\t\t       output_payload_buffer,\n\t\t\t\t       conf_state,\n\t\t\t\t       qop_state);\n\tif (status != GSS_S_COMPLETE)\n\t    map_error(minor_status, mech);\n    } else if (mech->gss_unwrap_iov) {\n\tstatus = gssint_unwrap_aead_iov_shim(mech,\n\t\t\t\t\t     minor_status,\n\t\t\t\t\t     ctx->internal_ctx_id,\n\t\t\t\t\t     input_message_buffer,\n\t\t\t\t\t     input_assoc_buffer,\n\t\t\t\t\t     output_payload_buffer,\n\t\t\t\t\t     conf_state,\n\t\t\t\t\t     qop_state);\n    } else\n\tstatus = GSS_S_UNAVAILABLE;\n /* EXPORT DELETE END */\n\n    return (status);\n}\n\nOM_uint32 KRB5_CALLCONV\ngss_unwrap_aead (minor_status,\n                 context_handle,\n\t\t input_message_buffer,\n\t\t input_assoc_buffer,\n\t\t output_payload_buffer,\n                 conf_state,\n                 qop_state)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_buffer_t\t\tinput_message_buffer;\ngss_buffer_t\t\tinput_assoc_buffer;\ngss_buffer_t\t\toutput_payload_buffer;\nint \t\t\t*conf_state;\ngss_qop_t\t\t*qop_state;\n{\n\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    status = val_unwrap_aead_args(minor_status, context_handle,\n\t\t\t\t  input_message_buffer, input_assoc_buffer,\n\t\t\t\t  output_payload_buffer,\n\t\t\t\t  conf_state, qop_state);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n    ctx = (gss_union_ctx_id_t) context_handle;\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (!mech)\n\treturn (GSS_S_BAD_MECH);\n\n    return gssint_unwrap_aead(mech, minor_status, ctx,\n\t\t\t      input_message_buffer, input_assoc_buffer,\n\t\t\t      output_payload_buffer, conf_state, qop_state);\n}\n", "/* #pragma ident\t\"@(#)g_seal.c\t1.19\t98/04/21 SMI\" */\n\n/*\n * Copyright 1996 by Sun Microsystems, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of Sun Microsystems not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. Sun Microsystems makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n *  glue routine for gss_unwrap_iov\n */\n\n#include \"mglueP.h\"\n\nstatic OM_uint32\nval_unwrap_iov_args(\n    OM_uint32 *minor_status,\n    gss_ctx_id_t context_handle,\n    int *conf_state,\n    gss_qop_t *qop_state,\n    gss_iov_buffer_desc *iov,\n    int iov_count)\n{\n\n    /* Initialize outputs. */\n\n    if (minor_status != NULL)\n\t*minor_status = 0;\n\n    /* Validate arguments. */\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (iov == GSS_C_NO_IOV_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n\n    return (GSS_S_COMPLETE);\n}\n\n\nOM_uint32 KRB5_CALLCONV\ngss_unwrap_iov (minor_status,\n                context_handle,\n                conf_state,\n                qop_state,\n                iov,\n                iov_count)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nint *\t\t\tconf_state;\ngss_qop_t\t\t*qop_state;\ngss_iov_buffer_desc  *\tiov;\nint\t\t\tiov_count;\n{\n /* EXPORT DELETE START */\n\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    status = val_unwrap_iov_args(minor_status, context_handle,\n\t\t\t\t conf_state, qop_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech) {\n\tif (mech->gss_unwrap_iov) {\n\t    status = mech->gss_unwrap_iov(\n\t\t\t\t \t  minor_status,\n\t\t\t\t\t  ctx->internal_ctx_id,\n\t\t\t\t\t  conf_state,\n\t\t\t\t\t  qop_state,\n\t\t\t\t\t  iov,\n\t\t\t\t\t  iov_count);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn(status);\n    }\n /* EXPORT DELETE END */\n\n    return (GSS_S_BAD_MECH);\n}\n\nOM_uint32 KRB5_CALLCONV\ngss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t   gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n\t\t   int iov_count)\n{\n    OM_uint32 status;\n    gss_union_ctx_id_t ctx;\n    gss_mechanism mech;\n\n    status = val_unwrap_iov_args(minor_status, context_handle, NULL,\n\t\t\t\t qop_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn status;\n\n    /* Select the approprate underlying mechanism routine and call it. */\n    ctx = (gss_union_ctx_id_t)context_handle;\n    mech = gssint_get_mechanism(ctx->mech_type);\n    if (mech == NULL)\n\treturn GSS_S_BAD_MECH;\n    if (mech->gss_verify_mic_iov == NULL)\n\treturn GSS_S_UNAVAILABLE;\n    status = mech->gss_verify_mic_iov(minor_status, ctx->internal_ctx_id,\n\t\t\t\t      qop_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\tmap_error(minor_status, mech);\n    return status;\n}\n", "/* #pragma ident\t\"@(#)g_verify.c\t1.13\t98/04/23 SMI\" */\n\n/*\n * Copyright 1996 by Sun Microsystems, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of Sun Microsystems not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. Sun Microsystems makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n *  glue routine for gss_verify_mic\n */\n\n#include \"mglueP.h\"\n\nOM_uint32 KRB5_CALLCONV\ngss_verify_mic (minor_status,\n\t\tcontext_handle,\n\t\tmessage_buffer,\n\t\ttoken_buffer,\n\t\tqop_state)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_buffer_t\t\tmessage_buffer;\ngss_buffer_t\t\ttoken_buffer;\ngss_qop_t *\t\tqop_state;\n\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n    *minor_status = 0;\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if ((message_buffer == GSS_C_NO_BUFFER) ||\n\tGSS_EMPTY_BUFFER(token_buffer))\n\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech) {\n\tif (mech->gss_verify_mic) {\n\t    status = mech->gss_verify_mic(\n\t\t\t\t\t  minor_status,\n\t\t\t\t\t  ctx->internal_ctx_id,\n\t\t\t\t\t  message_buffer,\n\t\t\t\t\t  token_buffer,\n\t\t\t\t\t  qop_state);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn(status);\n    }\n\n    return (GSS_S_BAD_MECH);\n}\n\nOM_uint32 KRB5_CALLCONV\ngss_verify (minor_status,\n            context_handle,\n            message_buffer,\n            token_buffer,\n            qop_state)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_buffer_t\t\tmessage_buffer;\ngss_buffer_t\t\ttoken_buffer;\nint *\t\t\tqop_state;\n\n{\n\treturn (gss_verify_mic(minor_status, context_handle,\n\t\t\t       message_buffer, token_buffer,\n\t\t\t       (gss_qop_t *) qop_state));\n}\n", "/* #pragma ident\t\"@(#)g_seal.c\t1.19\t98/04/21 SMI\" */\n\n/*\n * Copyright 1996 by Sun Microsystems, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of Sun Microsystems not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. Sun Microsystems makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n *  glue routine for gss_wrap_aead\n */\n\n#include \"mglueP.h\"\n\nstatic OM_uint32\nval_wrap_aead_args(\n    OM_uint32 *minor_status,\n    gss_ctx_id_t context_handle,\n    int conf_req_flag,\n    gss_qop_t qop_req,\n    gss_buffer_t input_assoc_buffer,\n    gss_buffer_t input_payload_buffer,\n    int *conf_state,\n    gss_buffer_t output_message_buffer)\n{\n\n    /* Initialize outputs. */\n\n    if (minor_status != NULL)\n\t*minor_status = 0;\n\n    /* Validate arguments. */\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (input_payload_buffer == GSS_C_NO_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n\n    if (output_message_buffer == GSS_C_NO_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    return (GSS_S_COMPLETE);\n}\n\nstatic OM_uint32\ngssint_wrap_aead_iov_shim(gss_mechanism mech,\n\t\t\t  OM_uint32 *minor_status,\n\t\t\t  gss_ctx_id_t context_handle,\n\t\t\t  int conf_req_flag,\n\t\t\t  gss_qop_t qop_req,\n\t\t\t  gss_buffer_t input_assoc_buffer,\n\t\t\t  gss_buffer_t input_payload_buffer,\n\t\t\t  int *conf_state,\n\t\t\t  gss_buffer_t output_message_buffer)\n{\n    gss_iov_buffer_desc\tiov[5];\n    OM_uint32\t\tstatus;\n    size_t\t\toffset;\n    int\t\t\ti = 0, iov_count;\n\n    /* HEADER | SIGN_ONLY_DATA | DATA | PADDING | TRAILER */\n\n    iov[i].type = GSS_IOV_BUFFER_TYPE_HEADER;\n    iov[i].buffer.value = NULL;\n    iov[i].buffer.length = 0;\n    i++;\n\n    if (input_assoc_buffer != GSS_C_NO_BUFFER) {\n\tiov[i].type = GSS_IOV_BUFFER_TYPE_SIGN_ONLY;\n\tiov[i].buffer = *input_assoc_buffer;\n\ti++;\n    }\n\n    iov[i].type = GSS_IOV_BUFFER_TYPE_DATA;\n    iov[i].buffer = *input_payload_buffer;\n    i++;\n\n    iov[i].type = GSS_IOV_BUFFER_TYPE_PADDING;\n    iov[i].buffer.value = NULL;\n    iov[i].buffer.length = 0;\n    i++;\n\n    iov[i].type = GSS_IOV_BUFFER_TYPE_TRAILER;\n    iov[i].buffer.value = NULL;\n    iov[i].buffer.length = 0;\n    i++;\n\n    iov_count = i;\n\n    assert(mech->gss_wrap_iov_length);\n\n    status = mech->gss_wrap_iov_length(minor_status, context_handle,\n\t\t\t\t       conf_req_flag, qop_req,\n\t\t\t\t       NULL, iov, iov_count);\n    if (status != GSS_S_COMPLETE) {\n\tmap_error(minor_status, mech);\n\treturn status;\n    }\n\n    /* Format output token (does not include associated data) */\n    for (i = 0, output_message_buffer->length = 0; i < iov_count; i++) {\n\tif (GSS_IOV_BUFFER_TYPE(iov[i].type) == GSS_IOV_BUFFER_TYPE_SIGN_ONLY)\n\t    continue;\n\n\toutput_message_buffer->length += iov[i].buffer.length;\n    }\n\n    output_message_buffer->value = gssalloc_malloc(output_message_buffer->length);\n    if (output_message_buffer->value == NULL) {\n\t*minor_status = ENOMEM;\n\treturn GSS_S_FAILURE;\n    }\n\n    i = 0, offset = 0;\n\n    /* HEADER */\n    iov[i].buffer.value = (unsigned char *)output_message_buffer->value + offset;\n    offset += iov[i].buffer.length;\n    i++;\n\n    /* SIGN_ONLY_DATA */\n    if (input_assoc_buffer != GSS_C_NO_BUFFER)\n\ti++;\n\n    /* DATA */\n    iov[i].buffer.value = (unsigned char *)output_message_buffer->value + offset;\n    offset += iov[i].buffer.length;\n\n    memcpy(iov[i].buffer.value, input_payload_buffer->value, iov[i].buffer.length);\n    i++;\n\n    /* PADDING */\n    iov[i].buffer.value = (unsigned char *)output_message_buffer->value + offset;\n    offset += iov[i].buffer.length;\n    i++;\n\n    /* TRAILER */\n    iov[i].buffer.value = (unsigned char *)output_message_buffer->value + offset;\n    offset += iov[i].buffer.length;\n    i++;\n\n    assert(offset == output_message_buffer->length);\n\n    assert(mech->gss_wrap_iov);\n\n    status = mech->gss_wrap_iov(minor_status, context_handle,\n\t\t\t\tconf_req_flag, qop_req,\n\t\t\t\tconf_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE) {\n\tOM_uint32 minor;\n\n\tmap_error(minor_status, mech);\n\tgss_release_buffer(&minor, output_message_buffer);\n    }\n\n    return status;\n}\n\nOM_uint32\ngssint_wrap_aead (gss_mechanism mech,\n\t\t  OM_uint32 *minor_status,\n\t\t  gss_union_ctx_id_t ctx,\n\t\t  int conf_req_flag,\n\t\t  gss_qop_t qop_req,\n\t\t  gss_buffer_t input_assoc_buffer,\n\t\t  gss_buffer_t input_payload_buffer,\n\t\t  int *conf_state,\n\t\t  gss_buffer_t output_message_buffer)\n{\n /* EXPORT DELETE START */\n    OM_uint32\t\tstatus;\n\n    assert(ctx != NULL);\n    assert(mech != NULL);\n\n    if (mech->gss_wrap_aead) {\n\tstatus = mech->gss_wrap_aead(minor_status,\n\t\t\t\t     ctx->internal_ctx_id,\n\t\t\t\t     conf_req_flag,\n\t\t\t\t     qop_req,\n\t\t\t\t     input_assoc_buffer,\n\t\t\t\t     input_payload_buffer,\n\t\t\t\t     conf_state,\n\t\t\t\t     output_message_buffer);\n\tif (status != GSS_S_COMPLETE)\n\t    map_error(minor_status, mech);\n    } else if (mech->gss_wrap_iov && mech->gss_wrap_iov_length) {\n\tstatus = gssint_wrap_aead_iov_shim(mech,\n\t\t\t\t\t   minor_status,\n\t\t\t\t\t   ctx->internal_ctx_id,\n\t\t\t\t\t   conf_req_flag,\n\t\t\t\t\t   qop_req,\n\t\t\t\t\t   input_assoc_buffer,\n\t\t\t\t\t   input_payload_buffer,\n\t\t\t\t\t   conf_state,\n\t\t\t\t\t   output_message_buffer);\n    } else\n\tstatus = GSS_S_UNAVAILABLE;\n\n /* EXPORT DELETE END */\n\n    return status;\n}\n\nOM_uint32 KRB5_CALLCONV\ngss_wrap_aead (minor_status,\n               context_handle,\n               conf_req_flag,\n               qop_req,\n\t       input_assoc_buffer,\n\t       input_payload_buffer,\n               conf_state,\n               output_message_buffer)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nint\t\t\tconf_req_flag;\ngss_qop_t\t\tqop_req;\ngss_buffer_t\t\tinput_assoc_buffer;\ngss_buffer_t\t\tinput_payload_buffer;\nint *\t\t\tconf_state;\ngss_buffer_t\t\toutput_message_buffer;\n{\n    OM_uint32\t\tstatus;\n    gss_mechanism\tmech;\n    gss_union_ctx_id_t\tctx;\n\n    status = val_wrap_aead_args(minor_status, context_handle,\n\t\t\t\tconf_req_flag, qop_req,\n\t\t\t\tinput_assoc_buffer, input_payload_buffer,\n\t\t\t\tconf_state, output_message_buffer);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n    ctx = (gss_union_ctx_id_t)context_handle;\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (!mech)\n\treturn (GSS_S_BAD_MECH);\n\n    return gssint_wrap_aead(mech, minor_status, ctx,\n\t\t\t    conf_req_flag, qop_req,\n\t\t\t    input_assoc_buffer, input_payload_buffer,\n\t\t\t    conf_state, output_message_buffer);\n}\n", "/* #pragma ident\t\"@(#)g_seal.c\t1.19\t98/04/21 SMI\" */\n\n/*\n * Copyright 1996 by Sun Microsystems, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of Sun Microsystems not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. Sun Microsystems makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n *  glue routine for gss_wrap_iov\n */\n\n#include \"mglueP.h\"\n\nstatic OM_uint32\nval_wrap_iov_args(\n    OM_uint32 *minor_status,\n    gss_ctx_id_t context_handle,\n    int conf_req_flag,\n    gss_qop_t qop_req,\n    int *conf_state,\n    gss_iov_buffer_desc *iov,\n    int iov_count)\n{\n\n    /* Initialize outputs. */\n\n    if (minor_status != NULL)\n\t*minor_status = 0;\n\n    /* Validate arguments. */\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (iov == GSS_C_NO_IOV_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n\n    return (GSS_S_COMPLETE);\n}\n\n\nOM_uint32 KRB5_CALLCONV\ngss_wrap_iov (minor_status,\n              context_handle,\n              conf_req_flag,\n              qop_req,\n              conf_state,\n              iov,\n              iov_count)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nint\t\t\tconf_req_flag;\ngss_qop_t\t\tqop_req;\nint *\t\t\tconf_state;\ngss_iov_buffer_desc  *\tiov;\nint\t\t\tiov_count;\n{\n /* EXPORT DELETE START */\n\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    status = val_wrap_iov_args(minor_status, context_handle,\n\t\t\t       conf_req_flag, qop_req,\n\t\t\t       conf_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech) {\n\tif (mech->gss_wrap_iov) {\n\t    status = mech->gss_wrap_iov(\n\t\t\t\t\tminor_status,\n\t\t\t\t\tctx->internal_ctx_id,\n\t\t\t\t\tconf_req_flag,\n\t\t\t\t\tqop_req,\n\t\t\t\t\tconf_state,\n\t\t\t\t\tiov,\n\t\t\t\t\tiov_count);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn(status);\n    }\n /* EXPORT DELETE END */\n\n    return (GSS_S_BAD_MECH);\n}\n\nOM_uint32 KRB5_CALLCONV\ngss_wrap_iov_length (minor_status,\n                     context_handle,\n                     conf_req_flag,\n                     qop_req,\n                     conf_state,\n                     iov,\n                     iov_count)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nint\t\t\tconf_req_flag;\ngss_qop_t\t\tqop_req;\nint *\t\t\tconf_state;\ngss_iov_buffer_desc  *\tiov;\nint\t\t\tiov_count;\n{\n /* EXPORT DELETE START */\n\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    status = val_wrap_iov_args(minor_status, context_handle,\n\t\t\t       conf_req_flag, qop_req,\n\t\t\t       conf_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech) {\n\tif (mech->gss_wrap_iov_length) {\n\t    status = mech->gss_wrap_iov_length(\n\t\t\t\t\t      minor_status,\n\t\t\t\t\t      ctx->internal_ctx_id,\n\t\t\t\t\t      conf_req_flag,\n\t\t\t\t\t      qop_req,\n\t\t\t\t\t      conf_state,\n\t\t\t\t\t      iov,\n\t\t\t\t\t      iov_count);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn(status);\n    }\n /* EXPORT DELETE END */\n\n    return (GSS_S_BAD_MECH);\n}\n\nOM_uint32 KRB5_CALLCONV\ngss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\tgss_qop_t qop_req, gss_iov_buffer_desc *iov, int iov_count)\n{\n    OM_uint32 status;\n    gss_union_ctx_id_t ctx;\n    gss_mechanism mech;\n\n    status = val_wrap_iov_args(minor_status, context_handle, 0, qop_req, NULL,\n\t\t\t       iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn status;\n\n    /* Select the approprate underlying mechanism routine and call it. */\n    ctx = (gss_union_ctx_id_t)context_handle;\n    mech = gssint_get_mechanism(ctx->mech_type);\n    if (mech == NULL)\n\treturn GSS_S_BAD_MECH;\n    if (mech->gss_get_mic_iov == NULL)\n\treturn GSS_S_UNAVAILABLE;\n    status = mech->gss_get_mic_iov(minor_status, ctx->internal_ctx_id, qop_req,\n\t\t\t\t   iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\tmap_error(minor_status, mech);\n    return status;\n}\n\nOM_uint32 KRB5_CALLCONV\ngss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n\t\t       int iov_count)\n{\n    OM_uint32 status;\n    gss_union_ctx_id_t ctx;\n    gss_mechanism mech;\n\n    status = val_wrap_iov_args(minor_status, context_handle, 0, qop_req, NULL,\n\t\t\t       iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn status;\n\n    /* Select the approprate underlying mechanism routine and call it. */\n    ctx = (gss_union_ctx_id_t)context_handle;\n    mech = gssint_get_mechanism(ctx->mech_type);\n    if (mech == NULL)\n\treturn GSS_S_BAD_MECH;\n    if (mech->gss_get_mic_iov_length == NULL)\n\treturn GSS_S_UNAVAILABLE;\n    status = mech->gss_get_mic_iov_length(minor_status, ctx->internal_ctx_id,\n\t\t\t\t\t  qop_req, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\tmap_error(minor_status, mech);\n    return status;\n}\n\nOM_uint32 KRB5_CALLCONV\ngss_release_iov_buffer (minor_status,\n\t\t\tiov,\n\t\t\tiov_count)\nOM_uint32 *\t\tminor_status;\ngss_iov_buffer_desc *\tiov;\nint\t\t\tiov_count;\n{\n    OM_uint32\t\tstatus = GSS_S_COMPLETE;\n    int\t\t\ti;\n\n    if (minor_status)\n\t*minor_status = 0;\n\n    if (iov == GSS_C_NO_IOV_BUFFER)\n\treturn GSS_S_COMPLETE;\n\n    for (i = 0; i < iov_count; i++) {\n\tif (iov[i].type & GSS_IOV_BUFFER_FLAG_ALLOCATED) {\n\t    status = gss_release_buffer(minor_status, &iov[i].buffer);\n\t    if (status != GSS_S_COMPLETE)\n\t\tbreak;\n\n\t    iov[i].type &= ~(GSS_IOV_BUFFER_FLAG_ALLOCATED);\n\t}\n    }\n\n    return status;\n}\n"], "fixing_code": ["/* #pragma ident\t\"@(#)g_accept_sec_context.c\t1.19\t04/02/23 SMI\" */\n\n/*\n * Copyright 1996 by Sun Microsystems, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of Sun Microsystems not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. Sun Microsystems makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n *  glue routine for gss_accept_sec_context\n */\n\n#include \"mglueP.h\"\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#include <string.h>\n#include <errno.h>\n#include <time.h>\n\n#ifndef LEAN_CLIENT\nstatic OM_uint32\nval_acc_sec_ctx_args(\n    OM_uint32 *minor_status,\n    gss_ctx_id_t *context_handle,\n    gss_cred_id_t verifier_cred_handle,\n    gss_buffer_t input_token_buffer,\n    gss_channel_bindings_t input_chan_bindings,\n    gss_name_t *src_name,\n    gss_OID *mech_type,\n    gss_buffer_t output_token,\n    OM_uint32 *ret_flags,\n    OM_uint32 *time_rec,\n    gss_cred_id_t *d_cred)\n{\n\n    /* Initialize outputs. */\n\n    if (minor_status != NULL)\n\t*minor_status = 0;\n\n    if (src_name != NULL)\n\t*src_name = GSS_C_NO_NAME;\n\n    if (mech_type != NULL)\n\t*mech_type = GSS_C_NO_OID;\n\n    if (output_token != GSS_C_NO_BUFFER) {\n\toutput_token->length = 0;\n\toutput_token->value = NULL;\n    }\n\n    if (d_cred != NULL)\n\t*d_cred = GSS_C_NO_CREDENTIAL;\n\n    /* Validate arguments. */\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (context_handle == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (input_token_buffer == GSS_C_NO_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n\n    if (output_token == GSS_C_NO_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    return (GSS_S_COMPLETE);\n}\n\n/* Return true if mech should be accepted with no acceptor credential. */\nstatic int\nallow_mech_by_default(gss_OID mech)\n{\n    OM_uint32 status, minor;\n    gss_OID_set attrs;\n    int reject = 0, p;\n\n    /* Whether we accept an interposer mech depends on whether we accept the\n     * mech it interposes. */\n    mech = gssint_get_public_oid(mech);\n    if (mech == GSS_C_NO_OID)\n\treturn 0;\n\n    status = gss_inquire_attrs_for_mech(&minor, mech, &attrs, NULL);\n    if (status)\n\treturn 0;\n\n    /* Check for each attribute which would cause us to exclude this mech from\n     * the default credential. */\n    if (generic_gss_test_oid_set_member(&minor, GSS_C_MA_DEPRECATED,\n\t\t\t\t\tattrs, &p) != GSS_S_COMPLETE || p)\n\treject = 1;\n    else if (generic_gss_test_oid_set_member(&minor, GSS_C_MA_NOT_DFLT_MECH,\n\t\t\t\t\t     attrs, &p) != GSS_S_COMPLETE || p)\n\treject = 1;\n\n    (void) gss_release_oid_set(&minor, &attrs);\n    return !reject;\n}\n\nOM_uint32 KRB5_CALLCONV\ngss_accept_sec_context (minor_status,\n                        context_handle,\n                        verifier_cred_handle,\n                        input_token_buffer,\n                        input_chan_bindings,\n                        src_name,\n                        mech_type,\n                        output_token,\n                        ret_flags,\n                        time_rec,\n                        d_cred)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t *\t\tcontext_handle;\ngss_cred_id_t\t\tverifier_cred_handle;\ngss_buffer_t\t\tinput_token_buffer;\ngss_channel_bindings_t\tinput_chan_bindings;\ngss_name_t *\t\tsrc_name;\ngss_OID *\t\tmech_type;\ngss_buffer_t\t\toutput_token;\nOM_uint32 *\t\tret_flags;\nOM_uint32 *\t\ttime_rec;\ngss_cred_id_t *\t\td_cred;\n\n{\n    OM_uint32\t\tstatus, temp_status, temp_minor_status;\n    OM_uint32\t\ttemp_ret_flags = 0;\n    gss_union_ctx_id_t\tunion_ctx_id = NULL;\n    gss_cred_id_t\tinput_cred_handle = GSS_C_NO_CREDENTIAL;\n    gss_cred_id_t\ttmp_d_cred = GSS_C_NO_CREDENTIAL;\n    gss_name_t\t\tinternal_name = GSS_C_NO_NAME;\n    gss_name_t\t\ttmp_src_name = GSS_C_NO_NAME;\n    gss_OID_desc\ttoken_mech_type_desc;\n    gss_OID\t\ttoken_mech_type = &token_mech_type_desc;\n    gss_OID\t\tactual_mech = GSS_C_NO_OID;\n    gss_OID\t\tselected_mech = GSS_C_NO_OID;\n    gss_OID\t\tpublic_mech;\n    gss_mechanism\tmech = NULL;\n    gss_union_cred_t\tuc;\n    int\t\t\ti;\n\n    status = val_acc_sec_ctx_args(minor_status,\n\t\t\t\t  context_handle,\n\t\t\t\t  verifier_cred_handle,\n\t\t\t\t  input_token_buffer,\n\t\t\t\t  input_chan_bindings,\n\t\t\t\t  src_name,\n\t\t\t\t  mech_type,\n\t\t\t\t  output_token,\n\t\t\t\t  ret_flags,\n\t\t\t\t  time_rec,\n\t\t\t\t  d_cred);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * if context_handle is GSS_C_NO_CONTEXT, allocate a union context\n     * descriptor to hold the mech type information as well as the\n     * underlying mechanism context handle. Otherwise, cast the\n     * value of *context_handle to the union context variable.\n     */\n\n    if(*context_handle == GSS_C_NO_CONTEXT) {\n\n\tif (input_token_buffer == GSS_C_NO_BUFFER)\n\t    return (GSS_S_CALL_INACCESSIBLE_READ);\n\n\t/* Get the token mech type */\n\tstatus = gssint_get_mech_type(token_mech_type, input_token_buffer);\n\tif (status)\n\t    return status;\n\n\t/*\n\t * An interposer calling back into the mechglue can't pass in a special\n\t * mech, so we have to recognize it using verifier_cred_handle.  Use\n\t * the mechanism for which we have matching creds, if available.\n\t */\n\tif (verifier_cred_handle != GSS_C_NO_CREDENTIAL) {\n\t    uc = (gss_union_cred_t)verifier_cred_handle;\n\t    for (i = 0; i < uc->count; i++) {\n\t\tpublic_mech = gssint_get_public_oid(&uc->mechs_array[i]);\n\t\tif (public_mech && g_OID_equal(token_mech_type, public_mech)) {\n\t\t    selected_mech = &uc->mechs_array[i];\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\n\tif (selected_mech == GSS_C_NO_OID) {\n\t    status = gssint_select_mech_type(minor_status, token_mech_type,\n\t\t\t\t\t     &selected_mech);\n\t    if (status)\n\t\treturn status;\n\t}\n\n    } else {\n\tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n\tselected_mech = union_ctx_id->mech_type;\n\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT)\n\t    return (GSS_S_NO_CONTEXT);\n    }\n\n    /* Now create a new context if we didn't get one. */\n    if (*context_handle == GSS_C_NO_CONTEXT) {\n\tstatus = GSS_S_FAILURE;\n\tunion_ctx_id = (gss_union_ctx_id_t)\n\t    malloc(sizeof(gss_union_ctx_id_desc));\n\tif (!union_ctx_id)\n\t    return (GSS_S_FAILURE);\n\n\tunion_ctx_id->loopback = union_ctx_id;\n\tunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\n\tstatus = generic_gss_copy_oid(&temp_minor_status, selected_mech,\n\t\t\t\t      &union_ctx_id->mech_type);\n\tif (status != GSS_S_COMPLETE) {\n\t    free(union_ctx_id);\n\t    return (status);\n\t}\n    }\n\n    /*\n     * get the appropriate cred handle from the union cred struct.\n     */\n    if (verifier_cred_handle != GSS_C_NO_CREDENTIAL) {\n\tinput_cred_handle =\n\t    gssint_get_mechanism_cred((gss_union_cred_t)verifier_cred_handle,\n\t\t\t\t      selected_mech);\n\tif (input_cred_handle == GSS_C_NO_CREDENTIAL) {\n\t    /* verifier credential specified but no acceptor credential found */\n\t    status = GSS_S_NO_CRED;\n\t    goto error_out;\n\t}\n    } else if (!allow_mech_by_default(selected_mech)) {\n\tstatus = GSS_S_NO_CRED;\n\tgoto error_out;\n    }\n\n    /*\n     * now select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    mech = gssint_get_mechanism(selected_mech);\n    if (mech && mech->gss_accept_sec_context) {\n\n\t    status = mech->gss_accept_sec_context(minor_status,\n\t\t\t\t\t\t  &union_ctx_id->internal_ctx_id,\n\t\t\t\t\t\t  input_cred_handle,\n\t\t\t\t\t\t  input_token_buffer,\n\t\t\t\t\t\t  input_chan_bindings,\n\t\t\t\t\t\t  src_name ? &internal_name : NULL,\n\t\t\t\t\t\t  &actual_mech,\n\t\t\t\t\t\t  output_token,\n\t\t\t\t\t\t  &temp_ret_flags,\n\t\t\t\t\t\t  time_rec,\n\t\t\t\t\td_cred ? &tmp_d_cred : NULL);\n\n\t    /* If there's more work to do, keep going... */\n\t    if (status == GSS_S_CONTINUE_NEEDED) {\n\t\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n\t\treturn GSS_S_CONTINUE_NEEDED;\n\t    }\n\n\t    /* if the call failed, return with failure */\n\t    if (status != GSS_S_COMPLETE) {\n\t\tmap_error(minor_status, mech);\n\t\tgoto error_out;\n\t    }\n\n\t    /*\n\t     * if src_name is non-NULL,\n\t     * convert internal_name into a union name equivalent\n\t     * First call the mechanism specific display_name()\n\t     * then call gss_import_name() to create\n\t     * the union name struct cast to src_name\n\t     */\n\t    if (src_name != NULL) {\n\t\tif (internal_name != GSS_C_NO_NAME) {\n\t\t    /* consumes internal_name regardless of success */\n\t\t    temp_status = gssint_convert_name_to_union_name(\n\t\t\t    &temp_minor_status, mech,\n\t\t\t    internal_name, &tmp_src_name);\n\t\t    if (temp_status != GSS_S_COMPLETE) {\n\t\t\tstatus = temp_status;\n\t\t\t*minor_status = temp_minor_status;\n\t\t\tmap_error(minor_status, mech);\n\t\t\tif (output_token->length)\n\t\t\t    (void) gss_release_buffer(&temp_minor_status,\n\t\t\t\t\t\t      output_token);\n\t\t\tgoto error_out;\n\t\t    }\n\t\t    *src_name = tmp_src_name;\n\t\t} else\n\t\t    *src_name = GSS_C_NO_NAME;\n\t    }\n\n#define g_OID_prefix_equal(o1, o2) \\\n        (((o1)->length >= (o2)->length) && \\\n        (memcmp((o1)->elements, (o2)->elements, (o2)->length) == 0))\n\n\t    /* Ensure we're returning correct creds format */\n\t    if ((temp_ret_flags & GSS_C_DELEG_FLAG) &&\n\t\ttmp_d_cred != GSS_C_NO_CREDENTIAL) {\n\t\tpublic_mech = gssint_get_public_oid(selected_mech);\n\t\tif (actual_mech != GSS_C_NO_OID &&\n\t\t    public_mech != GSS_C_NO_OID &&\n\t\t    !g_OID_prefix_equal(actual_mech, public_mech)) {\n\t\t    *d_cred = tmp_d_cred; /* unwrapped pseudo-mech */\n\t\t} else {\n\t\t    gss_union_cred_t d_u_cred = NULL;\n\n\t\t    d_u_cred = malloc(sizeof (gss_union_cred_desc));\n\t\t    if (d_u_cred == NULL) {\n\t\t\tstatus = GSS_S_FAILURE;\n\t\t\tgoto error_out;\n\t\t    }\n\t\t    (void) memset(d_u_cred, 0, sizeof (gss_union_cred_desc));\n\n\t\t    d_u_cred->count = 1;\n\n\t\t    status = generic_gss_copy_oid(&temp_minor_status,\n\t\t\t\t\t\t  selected_mech,\n\t\t\t\t\t\t  &d_u_cred->mechs_array);\n\n\t\t    if (status != GSS_S_COMPLETE) {\n\t\t\tfree(d_u_cred);\n\t\t\tgoto error_out;\n\t\t    }\n\n\t\t    d_u_cred->cred_array = malloc(sizeof(gss_cred_id_t));\n\t\t    if (d_u_cred->cred_array != NULL) {\n\t\t\td_u_cred->cred_array[0] = tmp_d_cred;\n\t\t    } else {\n\t\t\tfree(d_u_cred);\n\t\t\tstatus = GSS_S_FAILURE;\n\t\t\tgoto error_out;\n\t\t    }\n\n\t\t    d_u_cred->loopback = d_u_cred;\n\t\t    *d_cred = (gss_cred_id_t)d_u_cred;\n\t\t}\n\t    }\n\n\t    if (mech_type != NULL)\n\t\t*mech_type = gssint_get_public_oid(actual_mech);\n\t    if (ret_flags != NULL)\n\t\t*ret_flags = temp_ret_flags;\n\t    *context_handle = (gss_ctx_id_t)union_ctx_id;\n\t    return GSS_S_COMPLETE;\n    } else {\n\n\tstatus = GSS_S_BAD_MECH;\n    }\n\nerror_out:\n\t/*\n\t * RFC 2744 5.1 requires that we not create a context on a failed first\n\t * call to accept, and recommends that on a failed subsequent call we\n\t * make the caller responsible for calling gss_delete_sec_context.\n\t * Even if the mech deleted its context, keep the union context around\n\t * for the caller to delete.\n\t */\n    if (union_ctx_id && *context_handle == GSS_C_NO_CONTEXT) {\n\tif (union_ctx_id->mech_type) {\n\t    if (union_ctx_id->mech_type->elements)\n\t\tfree(union_ctx_id->mech_type->elements);\n\t    free(union_ctx_id->mech_type);\n\t}\n\tif (union_ctx_id->internal_ctx_id && mech &&\n\t    mech->gss_delete_sec_context) {\n\t    mech->gss_delete_sec_context(&temp_minor_status,\n\t\t\t\t\t &union_ctx_id->internal_ctx_id,\n\t\t\t\t\t GSS_C_NO_BUFFER);\n\t}\n\tfree(union_ctx_id);\n    }\n\n    if (src_name)\n\t*src_name = GSS_C_NO_NAME;\n\n    if (tmp_src_name != GSS_C_NO_NAME)\n\t(void) gss_release_buffer(&temp_minor_status,\n\t\t\t\t  (gss_buffer_t)tmp_src_name);\n\n    return (status);\n}\n#endif /* LEAN_CLIENT */\n", "/* #ident  \"@(#)gss_seal.c 1.10     95/08/07 SMI\" */\n\n/*\n * Copyright 1996 by Sun Microsystems, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of Sun Microsystems not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. Sun Microsystems makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n *  glue routine for gss_complete_auth_token\n */\n\n#include \"mglueP.h\"\n#include <stdio.h>\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#include <string.h>\n#include <errno.h>\n\nOM_uint32 KRB5_CALLCONV\ngss_complete_auth_token (OM_uint32 *minor_status,\n\t                 const gss_ctx_id_t context_handle,\n\t                 gss_buffer_t input_message_buffer)\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech != NULL) {\n\tif (mech->gss_complete_auth_token != NULL) {\n\t    status = mech->gss_complete_auth_token(minor_status,\n\t\t\t\t\t\t   ctx->internal_ctx_id,\n\t\t\t\t\t\t   input_message_buffer);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_COMPLETE;\n    } else\n\tstatus = GSS_S_BAD_MECH;\n\n    return status;\n}\n", "/* #pragma ident\t\"@(#)g_context_time.c\t1.12\t98/01/22 SMI\" */\n\n/*\n * Copyright 1996 by Sun Microsystems, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of Sun Microsystems not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. Sun Microsystems makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n *  glue routines for gss_context_time\n */\n\n#include \"mglueP.h\"\n\nOM_uint32 KRB5_CALLCONV\ngss_context_time (minor_status,\n                  context_handle,\n                  time_rec)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nOM_uint32 *\t\ttime_rec;\n\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n    *minor_status = 0;\n\n    if (time_rec == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech) {\n\n\tif (mech->gss_context_time) {\n\t    status = mech->gss_context_time(\n\t\t\t\t\t    minor_status,\n\t\t\t\t\t    ctx->internal_ctx_id,\n\t\t\t\t\t    time_rec);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn(status);\n    }\n\n    return (GSS_S_BAD_MECH);\n}\n", "/* #pragma ident\t\"@(#)g_delete_sec_context.c\t1.11\t97/11/09 SMI\" */\n\n/*\n * Copyright 1996 by Sun Microsystems, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of Sun Microsystems not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. Sun Microsystems makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n *  glue routine for gss_delete_sec_context\n */\n\n#include \"mglueP.h\"\n#include <stdio.h>\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n\nstatic OM_uint32\nval_del_sec_ctx_args(\n    OM_uint32 *minor_status,\n    gss_ctx_id_t *context_handle,\n    gss_buffer_t output_token)\n{\n\n    /* Initialize outputs. */\n\n    if (minor_status != NULL)\n\t*minor_status = 0;\n\n    if (output_token != GSS_C_NO_BUFFER) {\n\toutput_token->length = 0;\n\toutput_token->value = NULL;\n    }\n\n    /* Validate arguments. */\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (context_handle == NULL || *context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE | GSS_S_NO_CONTEXT);\n\n    return (GSS_S_COMPLETE);\n}\n\n\nOM_uint32 KRB5_CALLCONV\ngss_delete_sec_context (minor_status,\n                        context_handle,\n                        output_token)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t *\t\tcontext_handle;\ngss_buffer_t\t\toutput_token;\n\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n\n    status = val_del_sec_ctx_args(minor_status, context_handle, output_token);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) *context_handle;\n    if (GSSINT_CHK_LOOP(ctx))\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (ctx->internal_ctx_id != GSS_C_NO_CONTEXT) {\n\tstatus = gssint_delete_internal_sec_context(minor_status,\n\t\t\t\t\t\t    ctx->mech_type,\n\t\t\t\t\t\t    &ctx->internal_ctx_id,\n\t\t\t\t\t\t    output_token);\n\tif (status)\n\t    return status;\n    }\n\n    /* now free up the space for the union context structure */\n    free(ctx->mech_type->elements);\n    free(ctx->mech_type);\n    free(*context_handle);\n    *context_handle = GSS_C_NO_CONTEXT;\n\n    return (GSS_S_COMPLETE);\n}\n", "/* #pragma ident\t\"@(#)g_exp_sec_context.c\t1.14\t04/02/23 SMI\" */\n\n/*\n * Copyright 1996 by Sun Microsystems, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of Sun Microsystems not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. Sun Microsystems makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n *  glue routine for gss_export_sec_context\n */\n#ifndef LEAN_CLIENT\n\n#include \"mglueP.h\"\n#include <stdio.h>\n#include <errno.h>\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#include <string.h>\n\nstatic OM_uint32\nval_exp_sec_ctx_args(\n    OM_uint32 *minor_status,\n    gss_ctx_id_t *context_handle,\n    gss_buffer_t interprocess_token)\n{\n\n    /* Initialize outputs. */\n\n    if (minor_status != NULL)\n\t*minor_status = 0;\n\n    if (interprocess_token != GSS_C_NO_BUFFER) {\n\tinterprocess_token->length = 0;\n\tinterprocess_token->value = NULL;\n    }\n\n    /* Validate arguments. */\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (context_handle == NULL || *context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (interprocess_token == GSS_C_NO_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    return (GSS_S_COMPLETE);\n}\n\n\nOM_uint32 KRB5_CALLCONV\ngss_export_sec_context(minor_status,\n                       context_handle,\n                       interprocess_token)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t *\t\tcontext_handle;\ngss_buffer_t\t\tinterprocess_token;\n\n{\n    OM_uint32\t\tstatus;\n    OM_uint32 \t\tlength;\n    gss_union_ctx_id_t\tctx = NULL;\n    gss_mechanism\tmech;\n    gss_buffer_desc\ttoken = GSS_C_EMPTY_BUFFER;\n    char\t\t*buf;\n\n    status = val_exp_sec_ctx_args(minor_status,\n\t\t\t\t  context_handle, interprocess_token);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) *context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (!mech)\n\treturn GSS_S_BAD_MECH;\n    if (!mech->gss_export_sec_context)\n\treturn (GSS_S_UNAVAILABLE);\n\n    status = mech->gss_export_sec_context(minor_status,\n\t\t\t\t\t  &ctx->internal_ctx_id, &token);\n    if (status != GSS_S_COMPLETE) {\n\tmap_error(minor_status, mech);\n\tgoto cleanup;\n    }\n\n    length = token.length + 4 + ctx->mech_type->length;\n    interprocess_token->length = length;\n    interprocess_token->value = malloc(length);\n    if (interprocess_token->value == 0) {\n\t*minor_status = ENOMEM;\n\tstatus = GSS_S_FAILURE;\n\tgoto cleanup;\n    }\n    buf = interprocess_token->value;\n    length = ctx->mech_type->length;\n    buf[3] = (unsigned char) (length & 0xFF);\n    length >>= 8;\n    buf[2] = (unsigned char) (length & 0xFF);\n    length >>= 8;\n    buf[1] = (unsigned char) (length & 0xFF);\n    length >>= 8;\n    buf[0] = (unsigned char) (length & 0xFF);\n    memcpy(buf+4, ctx->mech_type->elements, (size_t) ctx->mech_type->length);\n    memcpy(buf+4+ctx->mech_type->length, token.value, token.length);\n\n    status = GSS_S_COMPLETE;\n\ncleanup:\n    (void) gss_release_buffer(minor_status, &token);\n    if (ctx != NULL && ctx->internal_ctx_id == GSS_C_NO_CONTEXT) {\n\t/* If the mech deleted its context, delete the union context. */\n\tfree(ctx->mech_type->elements);\n\tfree(ctx->mech_type);\n\tfree(ctx);\n\t*context_handle = GSS_C_NO_CONTEXT;\n    }\n    return status;\n}\n#endif /*LEAN_CLIENT */\n", "/* #pragma ident\t\"@(#)g_init_sec_context.c\t1.20\t03/10/24 SMI\" */\n\n/*\n * Copyright 1996 by Sun Microsystems, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of Sun Microsystems not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. Sun Microsystems makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n *  glue routine for gss_init_sec_context\n */\n\n#include \"mglueP.h\"\n#include <stdio.h>\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#include <string.h>\n\nstatic OM_uint32\nval_init_sec_ctx_args(\n    OM_uint32 *minor_status,\n    gss_cred_id_t claimant_cred_handle,\n    gss_ctx_id_t *context_handle,\n    gss_name_t target_name,\n    gss_OID req_mech_type,\n    OM_uint32 req_flags,\n    OM_uint32 time_req,\n    gss_channel_bindings_t input_chan_bindings,\n    gss_buffer_t input_token,\n    gss_OID *actual_mech_type,\n    gss_buffer_t output_token,\n    OM_uint32 *ret_flags,\n    OM_uint32 *time_rec)\n{\n\n    /* Initialize outputs. */\n\n    if (minor_status != NULL)\n\t*minor_status = 0;\n\n    if (actual_mech_type != NULL)\n\t*actual_mech_type = GSS_C_NO_OID;\n\n    if (output_token != GSS_C_NO_BUFFER) {\n\toutput_token->length = 0;\n\toutput_token->value = NULL;\n    }\n\n    /* Validate arguments. */\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (context_handle == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE | GSS_S_NO_CONTEXT);\n\n    if (target_name == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_BAD_NAME);\n\n    if (output_token == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    return (GSS_S_COMPLETE);\n}\n\n\nOM_uint32 KRB5_CALLCONV\ngss_init_sec_context (minor_status,\n                      claimant_cred_handle,\n                      context_handle,\n                      target_name,\n                      req_mech_type,\n                      req_flags,\n                      time_req,\n                      input_chan_bindings,\n                      input_token,\n                      actual_mech_type,\n                      output_token,\n                      ret_flags,\n                      time_rec)\n\nOM_uint32 *\t\tminor_status;\ngss_cred_id_t\t\tclaimant_cred_handle;\ngss_ctx_id_t *\t\tcontext_handle;\ngss_name_t\t\ttarget_name;\ngss_OID\t\t\treq_mech_type;\nOM_uint32\t\treq_flags;\nOM_uint32\t\ttime_req;\ngss_channel_bindings_t\tinput_chan_bindings;\ngss_buffer_t\t\tinput_token;\ngss_OID *\t\tactual_mech_type;\ngss_buffer_t\t\toutput_token;\nOM_uint32 *\t\tret_flags;\nOM_uint32 *\t\ttime_rec;\n\n{\n    OM_uint32\t\tstatus, temp_minor_status;\n    gss_union_name_t\tunion_name;\n    gss_union_cred_t\tunion_cred;\n    gss_name_t\t\tinternal_name;\n    gss_union_ctx_id_t\tunion_ctx_id;\n    gss_OID\t\tselected_mech;\n    gss_mechanism\tmech;\n    gss_cred_id_t\tinput_cred_handle;\n\n    status = val_init_sec_ctx_args(minor_status,\n\t\t\t\t   claimant_cred_handle,\n\t\t\t\t   context_handle,\n\t\t\t\t   target_name,\n\t\t\t\t   req_mech_type,\n\t\t\t\t   req_flags,\n\t\t\t\t   time_req,\n\t\t\t\t   input_chan_bindings,\n\t\t\t\t   input_token,\n\t\t\t\t   actual_mech_type,\n\t\t\t\t   output_token,\n\t\t\t\t   ret_flags,\n\t\t\t\t   time_rec);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    status = gssint_select_mech_type(minor_status, req_mech_type,\n\t\t\t\t     &selected_mech);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    union_name = (gss_union_name_t)target_name;\n\n    /*\n     * obtain the gss mechanism information for the requested\n     * mechanism.  If mech_type is NULL, set it to the resultant\n     * mechanism\n     */\n    mech = gssint_get_mechanism(selected_mech);\n    if (mech == NULL)\n\treturn (GSS_S_BAD_MECH);\n\n    if (mech->gss_init_sec_context == NULL)\n\treturn (GSS_S_UNAVAILABLE);\n\n    /*\n     * If target_name is mechanism_specific, then it must match the\n     * mech_type that we're about to use.  Otherwise, do an import on\n     * the external_name form of the target name.\n     */\n    if (union_name->mech_type &&\n\tg_OID_equal(union_name->mech_type, selected_mech)) {\n\tinternal_name = union_name->mech_name;\n    } else {\n\tif ((status = gssint_import_internal_name(minor_status, selected_mech,\n\t\t\t\t\t\t union_name,\n\t\t\t\t\t\t &internal_name)) != GSS_S_COMPLETE)\n\t    return (status);\n    }\n\n    /*\n     * if context_handle is GSS_C_NO_CONTEXT, allocate a union context\n     * descriptor to hold the mech type information as well as the\n     * underlying mechanism context handle. Otherwise, cast the\n     * value of *context_handle to the union context variable.\n     */\n\n    if(*context_handle == GSS_C_NO_CONTEXT) {\n\tstatus = GSS_S_FAILURE;\n\tunion_ctx_id = (gss_union_ctx_id_t)\n\t    malloc(sizeof(gss_union_ctx_id_desc));\n\tif (union_ctx_id == NULL)\n\t    goto end;\n\n\tif (generic_gss_copy_oid(&temp_minor_status, selected_mech,\n\t\t\t\t &union_ctx_id->mech_type) != GSS_S_COMPLETE) {\n\t    free(union_ctx_id);\n\t    goto end;\n\t}\n\n\t/* copy the supplied context handle */\n\tunion_ctx_id->internal_ctx_id = GSS_C_NO_CONTEXT;\n    } else {\n\tunion_ctx_id = (gss_union_ctx_id_t)*context_handle;\n\tif (union_ctx_id->internal_ctx_id == GSS_C_NO_CONTEXT) {\n\t    status = GSS_S_NO_CONTEXT;\n\t    goto end;\n\t}\n    }\n\n    /*\n     * get the appropriate cred handle from the union cred struct.\n     * defaults to GSS_C_NO_CREDENTIAL if there is no cred, which will\n     * use the default credential.\n     */\n    union_cred = (gss_union_cred_t) claimant_cred_handle;\n    input_cred_handle = gssint_get_mechanism_cred(union_cred, selected_mech);\n\n    /*\n     * now call the approprate underlying mechanism routine\n     */\n\n    status = mech->gss_init_sec_context(\n\tminor_status,\n\tinput_cred_handle,\n\t&union_ctx_id->internal_ctx_id,\n\tinternal_name,\n\tgssint_get_public_oid(selected_mech),\n\treq_flags,\n\ttime_req,\n\tinput_chan_bindings,\n\tinput_token,\n\tactual_mech_type,\n\toutput_token,\n\tret_flags,\n\ttime_rec);\n\n    if (status != GSS_S_COMPLETE && status != GSS_S_CONTINUE_NEEDED) {\n\t/*\n\t * RFC 2744 5.19 requires that we not create a context on a failed\n\t * first call to init, and recommends that on a failed subsequent call\n\t * we make the caller responsible for calling gss_delete_sec_context.\n\t * Even if the mech deleted its context, keep the union context around\n\t * for the caller to delete.\n\t */\n\tmap_error(minor_status, mech);\n\tif (*context_handle == GSS_C_NO_CONTEXT) {\n\t    free(union_ctx_id->mech_type->elements);\n\t    free(union_ctx_id->mech_type);\n\t    free(union_ctx_id);\n\t}\n    } else if (*context_handle == GSS_C_NO_CONTEXT) {\n\tunion_ctx_id->loopback = union_ctx_id;\n\t*context_handle = (gss_ctx_id_t)union_ctx_id;\n    }\n\nend:\n    if (union_name->mech_name == NULL ||\n\tunion_name->mech_name != internal_name) {\n\t(void) gssint_release_internal_name(&temp_minor_status,\n\t\t\t\t\t    selected_mech, &internal_name);\n    }\n\n    return(status);\n}\n", "/* #pragma ident\t\"@(#)g_inquire_context.c\t1.15\t04/02/23 SMI\" */\n\n/*\n * Copyright 1996 by Sun Microsystems, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of Sun Microsystems not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. Sun Microsystems makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n *  glue routine for gss_inquire_context\n */\n\n#include \"mglueP.h\"\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n\nstatic OM_uint32\nval_inq_ctx_args(\n    OM_uint32 *minor_status,\n    gss_ctx_id_t context_handle,\n    gss_name_t *src_name,\n    gss_name_t *targ_name,\n    OM_uint32 *lifetime_rec,\n    gss_OID *mech_type,\n    OM_uint32 *ctx_flags,\n    int *locally_initiated,\n    int *opened)\n{\n\n    /* Initialize outputs. */\n\n    if (minor_status != NULL)\n\t*minor_status = 0;\n\n    if (src_name != NULL)\n\t*src_name = GSS_C_NO_NAME;\n\n    if (targ_name != NULL)\n\t*targ_name = GSS_C_NO_NAME;\n\n    if (mech_type != NULL)\n\t*mech_type = GSS_C_NO_OID;\n\n    /* Validate arguments. */\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    return (GSS_S_COMPLETE);\n}\n\n\n/* Last argument new for V2 */\nOM_uint32 KRB5_CALLCONV\ngss_inquire_context(\n\t    OM_uint32 *minor_status,\n\t    gss_ctx_id_t context_handle,\n\t    gss_name_t *src_name,\n\t    gss_name_t *targ_name,\n\t    OM_uint32 *lifetime_rec,\n\t    gss_OID *mech_type,\n\t    OM_uint32 *ctx_flags,\n\t    int *locally_initiated,\n\t    int *opened)\n{\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    OM_uint32\t\tstatus, temp_minor;\n    gss_OID\t\tactual_mech;\n    gss_name_t localTargName = NULL, localSourceName = NULL;\n\n    status = val_inq_ctx_args(minor_status,\n\t\t\t      context_handle,\n\t\t\t      src_name, targ_name,\n\t\t\t      lifetime_rec,\n\t\t\t      mech_type, ctx_flags,\n\t\t\t      locally_initiated, opened);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (!mech || !mech->gss_inquire_context || !mech->gss_display_name ||\n\t!mech->gss_release_name) {\n\treturn (GSS_S_UNAVAILABLE);\n    }\n\n    status = mech->gss_inquire_context(\n\t\t\tminor_status,\n\t\t\tctx->internal_ctx_id,\n\t\t\t(src_name ? &localSourceName : NULL),\n\t\t\t(targ_name ? &localTargName : NULL),\n\t\t\tlifetime_rec,\n\t\t\t&actual_mech,\n\t\t\tctx_flags,\n\t\t\tlocally_initiated,\n\t\t\topened);\n\n    if (status != GSS_S_COMPLETE) {\n\tmap_error(minor_status, mech);\n\treturn status;\n    }\n\n    /* need to convert names */\n\n    if (src_name) {\n\tif (localSourceName) {\n\t    status = gssint_convert_name_to_union_name(minor_status, mech,\n\t\t\t\t\t\t      localSourceName, src_name);\n\n\t    if (status != GSS_S_COMPLETE) {\n\t\tif (localTargName)\n\t\t    mech->gss_release_name(&temp_minor, &localTargName);\n\t\treturn (status);\n\t    }\n\t} else {\n\t    *src_name = GSS_C_NO_NAME;\n\t}\n    }\n\n    if (targ_name) {\n        if (localTargName) {\n\t    status = gssint_convert_name_to_union_name(minor_status, mech,\n\t\t\t\t\t\t      localTargName, targ_name);\n\n\t    if (status != GSS_S_COMPLETE) {\n\t\tif (src_name)\n\t\t    (void) gss_release_name(&temp_minor, src_name);\n\n\t\treturn (status);\n\t    }\n        }\n        else {\n            *targ_name = GSS_C_NO_NAME;\n        }\n    }\n\n    if (mech_type)\n\t*mech_type = gssint_get_public_oid(actual_mech);\n\n    return(GSS_S_COMPLETE);\n}\n", "/*\n * Copyright 2009 by the Massachusetts Institute of Technology.\n * All Rights Reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n\n/* Glue routine for gss_pseudo_random */\n\n#include \"mglueP.h\"\n\nOM_uint32 KRB5_CALLCONV\ngss_pseudo_random (OM_uint32 *minor_status,\n\t           gss_ctx_id_t context_handle,\n\t           int prf_key,\n\t           const gss_buffer_t prf_in,\n\t           ssize_t desired_output_len,\n\t           gss_buffer_t prf_out)\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    if (minor_status == NULL)\n\treturn GSS_S_CALL_INACCESSIBLE_WRITE;\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT;\n\n    if (prf_in == GSS_C_NO_BUFFER)\n\treturn GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT;\n\n    if (prf_out == GSS_C_NO_BUFFER)\n\treturn GSS_S_CALL_INACCESSIBLE_WRITE | GSS_S_NO_CONTEXT;\n\n    prf_out->length = 0;\n    prf_out->value = NULL;\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech != NULL) {\n\tif (mech->gss_pseudo_random != NULL) {\n\t    status = mech->gss_pseudo_random(minor_status,\n\t\t\t\t\t     ctx->internal_ctx_id,\n\t\t\t\t\t     prf_key,\n\t\t\t\t\t     prf_in,\n\t\t\t\t\t     desired_output_len,\n\t\t\t\t\t     prf_out);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn status;\n    }\n\n    return GSS_S_BAD_MECH;\n}\n", "/* #pragma ident\t\"@(#)g_process_context.c\t1.12\t98/01/22 SMI\" */\n\n/*\n * Copyright 1996 by Sun Microsystems, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of Sun Microsystems not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. Sun Microsystems makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n *  glue routine gss_process_context\n */\n\n#include \"mglueP.h\"\n\nOM_uint32 KRB5_CALLCONV\ngss_process_context_token (minor_status,\n                           context_handle,\n                           token_buffer)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_buffer_t\t\ttoken_buffer;\n\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n    *minor_status = 0;\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (token_buffer == GSS_C_NO_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n\n    if (GSS_EMPTY_BUFFER(token_buffer))\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech) {\n\n\tif (mech->gss_process_context_token) {\n\t    status = mech->gss_process_context_token(\n\t\t\t\t\t\t    minor_status,\n\t\t\t\t\t\t    ctx->internal_ctx_id,\n\t\t\t\t\t\t    token_buffer);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn(status);\n    }\n\n    return (GSS_S_BAD_MECH);\n}\n", "/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/*\n * Copyright 1996 by Sun Microsystems, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of Sun Microsystems not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. Sun Microsystems makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n *  glue routine for gss_wrap\n */\n\n#include \"mglueP.h\"\n\nstatic OM_uint32\nval_wrap_args(OM_uint32 *minor_status,\n              gss_ctx_id_t context_handle,\n              int conf_req_flag,\n              gss_qop_t qop_req,\n              gss_buffer_t input_message_buffer,\n              int *conf_state,\n              gss_buffer_t output_message_buffer)\n{\n    /* Initialize outputs. */\n\n    if (minor_status != NULL)\n        *minor_status = 0;\n\n    if (output_message_buffer != GSS_C_NO_BUFFER) {\n        output_message_buffer->length = 0;\n        output_message_buffer->value = NULL;\n    }\n\n    /* Validate arguments. */\n\n    if (minor_status == NULL)\n        return (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n        return (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (input_message_buffer == GSS_C_NO_BUFFER)\n        return (GSS_S_CALL_INACCESSIBLE_READ);\n\n    if (output_message_buffer == GSS_C_NO_BUFFER)\n        return (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    return (GSS_S_COMPLETE);\n}\n\nOM_uint32 KRB5_CALLCONV\ngss_wrap( OM_uint32 *minor_status,\n          gss_ctx_id_t context_handle,\n          int conf_req_flag,\n          gss_qop_t qop_req,\n          gss_buffer_t input_message_buffer,\n          int *conf_state,\n          gss_buffer_t output_message_buffer)\n{\n\n    /* EXPORT DELETE START */\n\n    OM_uint32           status;\n    gss_union_ctx_id_t  ctx;\n    gss_mechanism       mech;\n\n    status = val_wrap_args(minor_status, context_handle,\n                           conf_req_flag, qop_req,\n                           input_message_buffer, conf_state,\n                           output_message_buffer);\n    if (status != GSS_S_COMPLETE)\n        return (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n        return (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech) {\n        if (mech->gss_wrap) {\n            status = mech->gss_wrap(minor_status,\n                                    ctx->internal_ctx_id,\n                                    conf_req_flag,\n                                    qop_req,\n                                    input_message_buffer,\n                                    conf_state,\n                                    output_message_buffer);\n            if (status != GSS_S_COMPLETE)\n                map_error(minor_status, mech);\n        } else if (mech->gss_wrap_aead ||\n                   (mech->gss_wrap_iov && mech->gss_wrap_iov_length)) {\n            status = gssint_wrap_aead(mech,\n                                      minor_status,\n                                      ctx,\n                                      conf_req_flag,\n                                      (gss_qop_t)qop_req,\n                                      GSS_C_NO_BUFFER,\n                                      input_message_buffer,\n                                      conf_state,\n                                      output_message_buffer);\n        } else\n            status = GSS_S_UNAVAILABLE;\n\n        return(status);\n    }\n    /* EXPORT DELETE END */\n\n    return (GSS_S_BAD_MECH);\n}\n\nOM_uint32 KRB5_CALLCONV\ngss_seal(OM_uint32 *minor_status,\n         gss_ctx_id_t context_handle,\n         int conf_req_flag,\n         int qop_req,\n         gss_buffer_t input_message_buffer,\n         int *conf_state,\n         gss_buffer_t output_message_buffer)\n{\n\n    return gss_wrap(minor_status, context_handle,\n                    conf_req_flag, (gss_qop_t) qop_req,\n                    input_message_buffer, conf_state,\n                    output_message_buffer);\n}\n\n/*\n * It is only possible to implement gss_wrap_size_limit() on top\n * of gss_wrap_iov_length() for mechanisms that do not use any\n * padding and have fixed length headers/trailers.\n */\nstatic OM_uint32\ngssint_wrap_size_limit_iov_shim(gss_mechanism mech,\n                                OM_uint32 *minor_status,\n                                gss_ctx_id_t context_handle,\n                                int conf_req_flag,\n                                gss_qop_t qop_req,\n                                OM_uint32 req_output_size,\n                                OM_uint32 *max_input_size)\n{\n    gss_iov_buffer_desc iov[4];\n    OM_uint32           status;\n    OM_uint32           ohlen;\n\n    iov[0].type = GSS_IOV_BUFFER_TYPE_HEADER;\n    iov[0].buffer.value = NULL;\n    iov[0].buffer.length = 0;\n\n    iov[1].type = GSS_IOV_BUFFER_TYPE_DATA;\n    iov[1].buffer.length = req_output_size;\n    iov[1].buffer.value = NULL;\n\n    iov[2].type = GSS_IOV_BUFFER_TYPE_PADDING;\n    iov[2].buffer.value = NULL;\n    iov[2].buffer.length = 0;\n\n    iov[3].type = GSS_IOV_BUFFER_TYPE_TRAILER;\n    iov[3].buffer.value = NULL;\n    iov[3].buffer.length = 0;\n\n    assert(mech->gss_wrap_iov_length);\n\n    status = mech->gss_wrap_iov_length(minor_status, context_handle,\n                                       conf_req_flag, qop_req,\n                                       NULL, iov,\n                                       sizeof(iov)/sizeof(iov[0]));\n    if (status != GSS_S_COMPLETE) {\n        map_error(minor_status, mech);\n        return status;\n    }\n\n    ohlen = iov[0].buffer.length + iov[3].buffer.length;\n\n    if (iov[2].buffer.length == 0 && ohlen < req_output_size)\n        *max_input_size = req_output_size - ohlen;\n    else\n        *max_input_size = 0;\n\n    return GSS_S_COMPLETE;\n}\n\n/*\n * New for V2\n */\nOM_uint32 KRB5_CALLCONV\ngss_wrap_size_limit(OM_uint32  *minor_status,\n                    gss_ctx_id_t context_handle,\n                    int conf_req_flag,\n                    gss_qop_t qop_req, OM_uint32 req_output_size, OM_uint32 *max_input_size)\n{\n    gss_union_ctx_id_t  ctx;\n    gss_mechanism       mech;\n    OM_uint32           major_status;\n\n    if (minor_status == NULL)\n        return (GSS_S_CALL_INACCESSIBLE_WRITE);\n    *minor_status = 0;\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n        return (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (max_input_size == NULL)\n        return (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n        return (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (!mech)\n        return (GSS_S_BAD_MECH);\n\n    if (mech->gss_wrap_size_limit)\n        major_status = mech->gss_wrap_size_limit(minor_status,\n                                                 ctx->internal_ctx_id,\n                                                 conf_req_flag, qop_req,\n                                                 req_output_size, max_input_size);\n    else if (mech->gss_wrap_iov_length)\n        major_status = gssint_wrap_size_limit_iov_shim(mech, minor_status,\n                                                       ctx->internal_ctx_id,\n                                                       conf_req_flag, qop_req,\n                                                       req_output_size, max_input_size);\n    else\n        major_status = GSS_S_UNAVAILABLE;\n    if (major_status != GSS_S_COMPLETE)\n        map_error(minor_status, mech);\n    return major_status;\n}\n", "/* #pragma ident\t\"@(#)g_sign.c\t1.14\t98/04/23 SMI\" */\n\n/*\n * Copyright 1996 by Sun Microsystems, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of Sun Microsystems not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. Sun Microsystems makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n *  glue routine gss_get_mic\n */\n\n#include \"mglueP.h\"\n\nstatic OM_uint32\nval_get_mic_args(\n    OM_uint32 *minor_status,\n    gss_ctx_id_t context_handle,\n    gss_qop_t qop_req,\n    gss_buffer_t message_buffer,\n    gss_buffer_t msg_token)\n{\n\n    /* Initialize outputs. */\n\n    if (minor_status != NULL)\n\t*minor_status = 0;\n\n    if (msg_token != GSS_C_NO_BUFFER) {\n\tmsg_token->value = NULL;\n\tmsg_token->length = 0;\n    }\n\n    /* Validate arguments. */\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (message_buffer == GSS_C_NO_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n\n    if (msg_token == GSS_C_NO_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    return (GSS_S_COMPLETE);\n}\n\n\nOM_uint32 KRB5_CALLCONV\ngss_get_mic (minor_status,\n\t     context_handle,\n\t     qop_req,\n\t     message_buffer,\n\t     msg_token)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_qop_t\t\tqop_req;\ngss_buffer_t\t\tmessage_buffer;\ngss_buffer_t\t\tmsg_token;\n\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    status = val_get_mic_args(minor_status, context_handle,\n\t\t\t      qop_req, message_buffer, msg_token);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech) {\n\tif (mech->gss_get_mic) {\n\t    status = mech->gss_get_mic(\n\t\t\t\t    minor_status,\n\t\t\t\t    ctx->internal_ctx_id,\n\t\t\t\t    qop_req,\n\t\t\t\t    message_buffer,\n\t\t\t\t    msg_token);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn(status);\n    }\n\n    return (GSS_S_BAD_MECH);\n}\n\nOM_uint32 KRB5_CALLCONV\ngss_sign (minor_status,\n          context_handle,\n          qop_req,\n          message_buffer,\n          msg_token)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nint\t\t\tqop_req;\ngss_buffer_t\t\tmessage_buffer;\ngss_buffer_t\t\tmsg_token;\n\n{\n\treturn (gss_get_mic(minor_status, context_handle, (gss_qop_t) qop_req,\n\t\t\t    message_buffer, msg_token));\n}\n", "/* #pragma ident\t\"@(#)g_unseal.c\t1.13\t98/01/22 SMI\" */\n\n/*\n * Copyright 1996 by Sun Microsystems, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of Sun Microsystems not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. Sun Microsystems makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n *  glue routine gss_unwrap\n */\n\n#include \"mglueP.h\"\n\nOM_uint32 KRB5_CALLCONV\ngss_unwrap (minor_status,\n            context_handle,\n            input_message_buffer,\n            output_message_buffer,\n            conf_state,\n            qop_state)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_buffer_t\t\tinput_message_buffer;\ngss_buffer_t\t\toutput_message_buffer;\nint *\t\t\tconf_state;\ngss_qop_t *\t\tqop_state;\n\n{\n/* EXPORT DELETE START */\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    if (minor_status != NULL)\n\t*minor_status = 0;\n\n    if (output_message_buffer != GSS_C_NO_BUFFER) {\n\toutput_message_buffer->length = 0;\n\toutput_message_buffer->value = NULL;\n    }\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (input_message_buffer == GSS_C_NO_BUFFER ||\n\tGSS_EMPTY_BUFFER(input_message_buffer))\n\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n\n    if (output_message_buffer == GSS_C_NO_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech) {\n\tif (mech->gss_unwrap) {\n\t    status = mech->gss_unwrap(minor_status,\n\t\t\t\t      ctx->internal_ctx_id,\n\t\t\t\t      input_message_buffer,\n\t\t\t\t      output_message_buffer,\n\t\t\t\t      conf_state,\n\t\t\t\t      qop_state);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else if (mech->gss_unwrap_aead || mech->gss_unwrap_iov) {\n\t    status = gssint_unwrap_aead(mech,\n\t\t\t\t\tminor_status,\n\t\t\t\t\tctx,\n\t\t\t\t\tinput_message_buffer,\n\t\t\t\t\tGSS_C_NO_BUFFER,\n\t\t\t\t\toutput_message_buffer,\n\t\t\t\t\tconf_state,\n\t\t\t\t\t(gss_qop_t *)qop_state);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn(status);\n    }\n\n/* EXPORT DELETE END */\n\n    return (GSS_S_BAD_MECH);\n}\n\nOM_uint32 KRB5_CALLCONV\ngss_unseal (minor_status,\n            context_handle,\n            input_message_buffer,\n            output_message_buffer,\n            conf_state,\n            qop_state)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_buffer_t\t\tinput_message_buffer;\ngss_buffer_t\t\toutput_message_buffer;\nint *\t\t\tconf_state;\nint *\t\t\tqop_state;\n\n{\n    return (gss_unwrap(minor_status, context_handle,\n\t\t       input_message_buffer,\n\t\t       output_message_buffer, conf_state, (gss_qop_t *) qop_state));\n}\n", "/* #pragma ident\t\"@(#)g_seal.c\t1.19\t98/04/21 SMI\" */\n\n/*\n * Copyright 1996 by Sun Microsystems, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of Sun Microsystems not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. Sun Microsystems makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n *  glue routine for gss_unwrap_aead\n */\n\n#include \"mglueP.h\"\n\nstatic OM_uint32\nval_unwrap_aead_args(\n    OM_uint32 *minor_status,\n    gss_ctx_id_t context_handle,\n    gss_buffer_t input_message_buffer,\n    gss_buffer_t input_assoc_buffer,\n    gss_buffer_t output_payload_buffer,\n    int *conf_state,\n    gss_qop_t *qop_state)\n{\n\n    /* Initialize outputs. */\n\n    if (minor_status != NULL)\n\t*minor_status = 0;\n\n    /* Validate arguments. */\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (input_message_buffer == GSS_C_NO_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n\n    if (output_payload_buffer == GSS_C_NO_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    return (GSS_S_COMPLETE);\n}\n\nstatic OM_uint32\ngssint_unwrap_aead_iov_shim(gss_mechanism mech,\n\t\t\t    OM_uint32 *minor_status,\n\t\t\t    gss_ctx_id_t context_handle,\n\t\t\t    gss_buffer_t input_message_buffer,\n\t\t\t    gss_buffer_t input_assoc_buffer,\n\t\t\t    gss_buffer_t output_payload_buffer,\n\t\t\t    int *conf_state,\n\t\t\t    gss_qop_t *qop_state)\n{\n    OM_uint32\t\t    status;\n    gss_iov_buffer_desc\t    iov[3];\n    int\t\t\t    i = 0;\n\n    iov[i].type = GSS_IOV_BUFFER_TYPE_STREAM;\n    iov[i].buffer = *input_message_buffer;\n    i++;\n\n    if (input_assoc_buffer != NULL) {\n\tiov[i].type = GSS_IOV_BUFFER_TYPE_SIGN_ONLY;\n\tiov[i].buffer = *input_assoc_buffer;\n\ti++;\n    }\n\n    iov[i].type = GSS_IOV_BUFFER_TYPE_DATA | GSS_IOV_BUFFER_FLAG_ALLOCATE;\n    iov[i].buffer.value = NULL;\n    iov[i].buffer.length = 0;\n    i++;\n\n    assert(mech->gss_unwrap_iov);\n\n    status = mech->gss_unwrap_iov(minor_status, context_handle, conf_state,\n\t\t\t\t  qop_state, iov, i);\n    if (status == GSS_S_COMPLETE) {\n\t*output_payload_buffer = iov[i - 1].buffer;\n    } else {\n\tOM_uint32 minor;\n\n\tmap_error(minor_status, mech);\n\n\tif (iov[i - 1].type & GSS_IOV_BUFFER_FLAG_ALLOCATED) {\n\t    gss_release_buffer(&minor, &iov[i - 1].buffer);\n\t    iov[i - 1].type &= ~(GSS_IOV_BUFFER_FLAG_ALLOCATED);\n\t}\n    }\n\n    return status;\n}\n\nOM_uint32\ngssint_unwrap_aead (gss_mechanism mech,\n\t\t    OM_uint32 *minor_status,\n\t\t    gss_union_ctx_id_t ctx,\n\t\t    gss_buffer_t input_message_buffer,\n\t\t    gss_buffer_t input_assoc_buffer,\n\t\t    gss_buffer_t output_payload_buffer,\n\t\t    int *conf_state,\n\t\t    gss_qop_t *qop_state)\n{\n    OM_uint32\t\t    status;\n\n    assert(mech != NULL);\n    assert(ctx != NULL);\n\n /* EXPORT DELETE START */\n\n    if (mech->gss_unwrap_aead) {\n\tstatus = mech->gss_unwrap_aead(minor_status,\n\t\t\t\t       ctx->internal_ctx_id,\n\t\t\t\t       input_message_buffer,\n\t\t\t\t       input_assoc_buffer,\n\t\t\t\t       output_payload_buffer,\n\t\t\t\t       conf_state,\n\t\t\t\t       qop_state);\n\tif (status != GSS_S_COMPLETE)\n\t    map_error(minor_status, mech);\n    } else if (mech->gss_unwrap_iov) {\n\tstatus = gssint_unwrap_aead_iov_shim(mech,\n\t\t\t\t\t     minor_status,\n\t\t\t\t\t     ctx->internal_ctx_id,\n\t\t\t\t\t     input_message_buffer,\n\t\t\t\t\t     input_assoc_buffer,\n\t\t\t\t\t     output_payload_buffer,\n\t\t\t\t\t     conf_state,\n\t\t\t\t\t     qop_state);\n    } else\n\tstatus = GSS_S_UNAVAILABLE;\n /* EXPORT DELETE END */\n\n    return (status);\n}\n\nOM_uint32 KRB5_CALLCONV\ngss_unwrap_aead (minor_status,\n                 context_handle,\n\t\t input_message_buffer,\n\t\t input_assoc_buffer,\n\t\t output_payload_buffer,\n                 conf_state,\n                 qop_state)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_buffer_t\t\tinput_message_buffer;\ngss_buffer_t\t\tinput_assoc_buffer;\ngss_buffer_t\t\toutput_payload_buffer;\nint \t\t\t*conf_state;\ngss_qop_t\t\t*qop_state;\n{\n\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    status = val_unwrap_aead_args(minor_status, context_handle,\n\t\t\t\t  input_message_buffer, input_assoc_buffer,\n\t\t\t\t  output_payload_buffer,\n\t\t\t\t  conf_state, qop_state);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (!mech)\n\treturn (GSS_S_BAD_MECH);\n\n    return gssint_unwrap_aead(mech, minor_status, ctx,\n\t\t\t      input_message_buffer, input_assoc_buffer,\n\t\t\t      output_payload_buffer, conf_state, qop_state);\n}\n", "/* #pragma ident\t\"@(#)g_seal.c\t1.19\t98/04/21 SMI\" */\n\n/*\n * Copyright 1996 by Sun Microsystems, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of Sun Microsystems not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. Sun Microsystems makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n *  glue routine for gss_unwrap_iov\n */\n\n#include \"mglueP.h\"\n\nstatic OM_uint32\nval_unwrap_iov_args(\n    OM_uint32 *minor_status,\n    gss_ctx_id_t context_handle,\n    int *conf_state,\n    gss_qop_t *qop_state,\n    gss_iov_buffer_desc *iov,\n    int iov_count)\n{\n\n    /* Initialize outputs. */\n\n    if (minor_status != NULL)\n\t*minor_status = 0;\n\n    /* Validate arguments. */\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (iov == GSS_C_NO_IOV_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n\n    return (GSS_S_COMPLETE);\n}\n\n\nOM_uint32 KRB5_CALLCONV\ngss_unwrap_iov (minor_status,\n                context_handle,\n                conf_state,\n                qop_state,\n                iov,\n                iov_count)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nint *\t\t\tconf_state;\ngss_qop_t\t\t*qop_state;\ngss_iov_buffer_desc  *\tiov;\nint\t\t\tiov_count;\n{\n /* EXPORT DELETE START */\n\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    status = val_unwrap_iov_args(minor_status, context_handle,\n\t\t\t\t conf_state, qop_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech) {\n\tif (mech->gss_unwrap_iov) {\n\t    status = mech->gss_unwrap_iov(\n\t\t\t\t \t  minor_status,\n\t\t\t\t\t  ctx->internal_ctx_id,\n\t\t\t\t\t  conf_state,\n\t\t\t\t\t  qop_state,\n\t\t\t\t\t  iov,\n\t\t\t\t\t  iov_count);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn(status);\n    }\n /* EXPORT DELETE END */\n\n    return (GSS_S_BAD_MECH);\n}\n\nOM_uint32 KRB5_CALLCONV\ngss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t   gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n\t\t   int iov_count)\n{\n    OM_uint32 status;\n    gss_union_ctx_id_t ctx;\n    gss_mechanism mech;\n\n    status = val_unwrap_iov_args(minor_status, context_handle, NULL,\n\t\t\t\t qop_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn status;\n\n    /* Select the approprate underlying mechanism routine and call it. */\n    ctx = (gss_union_ctx_id_t)context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism(ctx->mech_type);\n    if (mech == NULL)\n\treturn GSS_S_BAD_MECH;\n    if (mech->gss_verify_mic_iov == NULL)\n\treturn GSS_S_UNAVAILABLE;\n    status = mech->gss_verify_mic_iov(minor_status, ctx->internal_ctx_id,\n\t\t\t\t      qop_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\tmap_error(minor_status, mech);\n    return status;\n}\n", "/* #pragma ident\t\"@(#)g_verify.c\t1.13\t98/04/23 SMI\" */\n\n/*\n * Copyright 1996 by Sun Microsystems, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of Sun Microsystems not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. Sun Microsystems makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n *  glue routine for gss_verify_mic\n */\n\n#include \"mglueP.h\"\n\nOM_uint32 KRB5_CALLCONV\ngss_verify_mic (minor_status,\n\t\tcontext_handle,\n\t\tmessage_buffer,\n\t\ttoken_buffer,\n\t\tqop_state)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_buffer_t\t\tmessage_buffer;\ngss_buffer_t\t\ttoken_buffer;\ngss_qop_t *\t\tqop_state;\n\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n    *minor_status = 0;\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if ((message_buffer == GSS_C_NO_BUFFER) ||\n\tGSS_EMPTY_BUFFER(token_buffer))\n\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech) {\n\tif (mech->gss_verify_mic) {\n\t    status = mech->gss_verify_mic(\n\t\t\t\t\t  minor_status,\n\t\t\t\t\t  ctx->internal_ctx_id,\n\t\t\t\t\t  message_buffer,\n\t\t\t\t\t  token_buffer,\n\t\t\t\t\t  qop_state);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn(status);\n    }\n\n    return (GSS_S_BAD_MECH);\n}\n\nOM_uint32 KRB5_CALLCONV\ngss_verify (minor_status,\n            context_handle,\n            message_buffer,\n            token_buffer,\n            qop_state)\n\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\ngss_buffer_t\t\tmessage_buffer;\ngss_buffer_t\t\ttoken_buffer;\nint *\t\t\tqop_state;\n\n{\n\treturn (gss_verify_mic(minor_status, context_handle,\n\t\t\t       message_buffer, token_buffer,\n\t\t\t       (gss_qop_t *) qop_state));\n}\n", "/* #pragma ident\t\"@(#)g_seal.c\t1.19\t98/04/21 SMI\" */\n\n/*\n * Copyright 1996 by Sun Microsystems, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of Sun Microsystems not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. Sun Microsystems makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n *  glue routine for gss_wrap_aead\n */\n\n#include \"mglueP.h\"\n\nstatic OM_uint32\nval_wrap_aead_args(\n    OM_uint32 *minor_status,\n    gss_ctx_id_t context_handle,\n    int conf_req_flag,\n    gss_qop_t qop_req,\n    gss_buffer_t input_assoc_buffer,\n    gss_buffer_t input_payload_buffer,\n    int *conf_state,\n    gss_buffer_t output_message_buffer)\n{\n\n    /* Initialize outputs. */\n\n    if (minor_status != NULL)\n\t*minor_status = 0;\n\n    /* Validate arguments. */\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (input_payload_buffer == GSS_C_NO_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n\n    if (output_message_buffer == GSS_C_NO_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    return (GSS_S_COMPLETE);\n}\n\nstatic OM_uint32\ngssint_wrap_aead_iov_shim(gss_mechanism mech,\n\t\t\t  OM_uint32 *minor_status,\n\t\t\t  gss_ctx_id_t context_handle,\n\t\t\t  int conf_req_flag,\n\t\t\t  gss_qop_t qop_req,\n\t\t\t  gss_buffer_t input_assoc_buffer,\n\t\t\t  gss_buffer_t input_payload_buffer,\n\t\t\t  int *conf_state,\n\t\t\t  gss_buffer_t output_message_buffer)\n{\n    gss_iov_buffer_desc\tiov[5];\n    OM_uint32\t\tstatus;\n    size_t\t\toffset;\n    int\t\t\ti = 0, iov_count;\n\n    /* HEADER | SIGN_ONLY_DATA | DATA | PADDING | TRAILER */\n\n    iov[i].type = GSS_IOV_BUFFER_TYPE_HEADER;\n    iov[i].buffer.value = NULL;\n    iov[i].buffer.length = 0;\n    i++;\n\n    if (input_assoc_buffer != GSS_C_NO_BUFFER) {\n\tiov[i].type = GSS_IOV_BUFFER_TYPE_SIGN_ONLY;\n\tiov[i].buffer = *input_assoc_buffer;\n\ti++;\n    }\n\n    iov[i].type = GSS_IOV_BUFFER_TYPE_DATA;\n    iov[i].buffer = *input_payload_buffer;\n    i++;\n\n    iov[i].type = GSS_IOV_BUFFER_TYPE_PADDING;\n    iov[i].buffer.value = NULL;\n    iov[i].buffer.length = 0;\n    i++;\n\n    iov[i].type = GSS_IOV_BUFFER_TYPE_TRAILER;\n    iov[i].buffer.value = NULL;\n    iov[i].buffer.length = 0;\n    i++;\n\n    iov_count = i;\n\n    assert(mech->gss_wrap_iov_length);\n\n    status = mech->gss_wrap_iov_length(minor_status, context_handle,\n\t\t\t\t       conf_req_flag, qop_req,\n\t\t\t\t       NULL, iov, iov_count);\n    if (status != GSS_S_COMPLETE) {\n\tmap_error(minor_status, mech);\n\treturn status;\n    }\n\n    /* Format output token (does not include associated data) */\n    for (i = 0, output_message_buffer->length = 0; i < iov_count; i++) {\n\tif (GSS_IOV_BUFFER_TYPE(iov[i].type) == GSS_IOV_BUFFER_TYPE_SIGN_ONLY)\n\t    continue;\n\n\toutput_message_buffer->length += iov[i].buffer.length;\n    }\n\n    output_message_buffer->value = gssalloc_malloc(output_message_buffer->length);\n    if (output_message_buffer->value == NULL) {\n\t*minor_status = ENOMEM;\n\treturn GSS_S_FAILURE;\n    }\n\n    i = 0, offset = 0;\n\n    /* HEADER */\n    iov[i].buffer.value = (unsigned char *)output_message_buffer->value + offset;\n    offset += iov[i].buffer.length;\n    i++;\n\n    /* SIGN_ONLY_DATA */\n    if (input_assoc_buffer != GSS_C_NO_BUFFER)\n\ti++;\n\n    /* DATA */\n    iov[i].buffer.value = (unsigned char *)output_message_buffer->value + offset;\n    offset += iov[i].buffer.length;\n\n    memcpy(iov[i].buffer.value, input_payload_buffer->value, iov[i].buffer.length);\n    i++;\n\n    /* PADDING */\n    iov[i].buffer.value = (unsigned char *)output_message_buffer->value + offset;\n    offset += iov[i].buffer.length;\n    i++;\n\n    /* TRAILER */\n    iov[i].buffer.value = (unsigned char *)output_message_buffer->value + offset;\n    offset += iov[i].buffer.length;\n    i++;\n\n    assert(offset == output_message_buffer->length);\n\n    assert(mech->gss_wrap_iov);\n\n    status = mech->gss_wrap_iov(minor_status, context_handle,\n\t\t\t\tconf_req_flag, qop_req,\n\t\t\t\tconf_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE) {\n\tOM_uint32 minor;\n\n\tmap_error(minor_status, mech);\n\tgss_release_buffer(&minor, output_message_buffer);\n    }\n\n    return status;\n}\n\nOM_uint32\ngssint_wrap_aead (gss_mechanism mech,\n\t\t  OM_uint32 *minor_status,\n\t\t  gss_union_ctx_id_t ctx,\n\t\t  int conf_req_flag,\n\t\t  gss_qop_t qop_req,\n\t\t  gss_buffer_t input_assoc_buffer,\n\t\t  gss_buffer_t input_payload_buffer,\n\t\t  int *conf_state,\n\t\t  gss_buffer_t output_message_buffer)\n{\n /* EXPORT DELETE START */\n    OM_uint32\t\tstatus;\n\n    assert(ctx != NULL);\n    assert(mech != NULL);\n\n    if (mech->gss_wrap_aead) {\n\tstatus = mech->gss_wrap_aead(minor_status,\n\t\t\t\t     ctx->internal_ctx_id,\n\t\t\t\t     conf_req_flag,\n\t\t\t\t     qop_req,\n\t\t\t\t     input_assoc_buffer,\n\t\t\t\t     input_payload_buffer,\n\t\t\t\t     conf_state,\n\t\t\t\t     output_message_buffer);\n\tif (status != GSS_S_COMPLETE)\n\t    map_error(minor_status, mech);\n    } else if (mech->gss_wrap_iov && mech->gss_wrap_iov_length) {\n\tstatus = gssint_wrap_aead_iov_shim(mech,\n\t\t\t\t\t   minor_status,\n\t\t\t\t\t   ctx->internal_ctx_id,\n\t\t\t\t\t   conf_req_flag,\n\t\t\t\t\t   qop_req,\n\t\t\t\t\t   input_assoc_buffer,\n\t\t\t\t\t   input_payload_buffer,\n\t\t\t\t\t   conf_state,\n\t\t\t\t\t   output_message_buffer);\n    } else\n\tstatus = GSS_S_UNAVAILABLE;\n\n /* EXPORT DELETE END */\n\n    return status;\n}\n\nOM_uint32 KRB5_CALLCONV\ngss_wrap_aead (minor_status,\n               context_handle,\n               conf_req_flag,\n               qop_req,\n\t       input_assoc_buffer,\n\t       input_payload_buffer,\n               conf_state,\n               output_message_buffer)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nint\t\t\tconf_req_flag;\ngss_qop_t\t\tqop_req;\ngss_buffer_t\t\tinput_assoc_buffer;\ngss_buffer_t\t\tinput_payload_buffer;\nint *\t\t\tconf_state;\ngss_buffer_t\t\toutput_message_buffer;\n{\n    OM_uint32\t\tstatus;\n    gss_mechanism\tmech;\n    gss_union_ctx_id_t\tctx;\n\n    status = val_wrap_aead_args(minor_status, context_handle,\n\t\t\t\tconf_req_flag, qop_req,\n\t\t\t\tinput_assoc_buffer, input_payload_buffer,\n\t\t\t\tconf_state, output_message_buffer);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n    ctx = (gss_union_ctx_id_t)context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n    if (!mech)\n\treturn (GSS_S_BAD_MECH);\n\n    return gssint_wrap_aead(mech, minor_status, ctx,\n\t\t\t    conf_req_flag, qop_req,\n\t\t\t    input_assoc_buffer, input_payload_buffer,\n\t\t\t    conf_state, output_message_buffer);\n}\n", "/* #pragma ident\t\"@(#)g_seal.c\t1.19\t98/04/21 SMI\" */\n\n/*\n * Copyright 1996 by Sun Microsystems, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of Sun Microsystems not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. Sun Microsystems makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n *  glue routine for gss_wrap_iov\n */\n\n#include \"mglueP.h\"\n\nstatic OM_uint32\nval_wrap_iov_args(\n    OM_uint32 *minor_status,\n    gss_ctx_id_t context_handle,\n    int conf_req_flag,\n    gss_qop_t qop_req,\n    int *conf_state,\n    gss_iov_buffer_desc *iov,\n    int iov_count)\n{\n\n    /* Initialize outputs. */\n\n    if (minor_status != NULL)\n\t*minor_status = 0;\n\n    /* Validate arguments. */\n\n    if (minor_status == NULL)\n\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (iov == GSS_C_NO_IOV_BUFFER)\n\treturn (GSS_S_CALL_INACCESSIBLE_READ);\n\n    return (GSS_S_COMPLETE);\n}\n\n\nOM_uint32 KRB5_CALLCONV\ngss_wrap_iov (minor_status,\n              context_handle,\n              conf_req_flag,\n              qop_req,\n              conf_state,\n              iov,\n              iov_count)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nint\t\t\tconf_req_flag;\ngss_qop_t\t\tqop_req;\nint *\t\t\tconf_state;\ngss_iov_buffer_desc  *\tiov;\nint\t\t\tiov_count;\n{\n /* EXPORT DELETE START */\n\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    status = val_wrap_iov_args(minor_status, context_handle,\n\t\t\t       conf_req_flag, qop_req,\n\t\t\t       conf_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech) {\n\tif (mech->gss_wrap_iov) {\n\t    status = mech->gss_wrap_iov(\n\t\t\t\t\tminor_status,\n\t\t\t\t\tctx->internal_ctx_id,\n\t\t\t\t\tconf_req_flag,\n\t\t\t\t\tqop_req,\n\t\t\t\t\tconf_state,\n\t\t\t\t\tiov,\n\t\t\t\t\tiov_count);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn(status);\n    }\n /* EXPORT DELETE END */\n\n    return (GSS_S_BAD_MECH);\n}\n\nOM_uint32 KRB5_CALLCONV\ngss_wrap_iov_length (minor_status,\n                     context_handle,\n                     conf_req_flag,\n                     qop_req,\n                     conf_state,\n                     iov,\n                     iov_count)\nOM_uint32 *\t\tminor_status;\ngss_ctx_id_t\t\tcontext_handle;\nint\t\t\tconf_req_flag;\ngss_qop_t\t\tqop_req;\nint *\t\t\tconf_state;\ngss_iov_buffer_desc  *\tiov;\nint\t\t\tiov_count;\n{\n /* EXPORT DELETE START */\n\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    status = val_wrap_iov_args(minor_status, context_handle,\n\t\t\t       conf_req_flag, qop_req,\n\t\t\t       conf_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech) {\n\tif (mech->gss_wrap_iov_length) {\n\t    status = mech->gss_wrap_iov_length(\n\t\t\t\t\t      minor_status,\n\t\t\t\t\t      ctx->internal_ctx_id,\n\t\t\t\t\t      conf_req_flag,\n\t\t\t\t\t      qop_req,\n\t\t\t\t\t      conf_state,\n\t\t\t\t\t      iov,\n\t\t\t\t\t      iov_count);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn(status);\n    }\n /* EXPORT DELETE END */\n\n    return (GSS_S_BAD_MECH);\n}\n\nOM_uint32 KRB5_CALLCONV\ngss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\tgss_qop_t qop_req, gss_iov_buffer_desc *iov, int iov_count)\n{\n    OM_uint32 status;\n    gss_union_ctx_id_t ctx;\n    gss_mechanism mech;\n\n    status = val_wrap_iov_args(minor_status, context_handle, 0, qop_req, NULL,\n\t\t\t       iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn status;\n\n    /* Select the approprate underlying mechanism routine and call it. */\n    ctx = (gss_union_ctx_id_t)context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism(ctx->mech_type);\n    if (mech == NULL)\n\treturn GSS_S_BAD_MECH;\n    if (mech->gss_get_mic_iov == NULL)\n\treturn GSS_S_UNAVAILABLE;\n    status = mech->gss_get_mic_iov(minor_status, ctx->internal_ctx_id, qop_req,\n\t\t\t\t   iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\tmap_error(minor_status, mech);\n    return status;\n}\n\nOM_uint32 KRB5_CALLCONV\ngss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n\t\t       int iov_count)\n{\n    OM_uint32 status;\n    gss_union_ctx_id_t ctx;\n    gss_mechanism mech;\n\n    status = val_wrap_iov_args(minor_status, context_handle, 0, qop_req, NULL,\n\t\t\t       iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn status;\n\n    /* Select the approprate underlying mechanism routine and call it. */\n    ctx = (gss_union_ctx_id_t)context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism(ctx->mech_type);\n    if (mech == NULL)\n\treturn GSS_S_BAD_MECH;\n    if (mech->gss_get_mic_iov_length == NULL)\n\treturn GSS_S_UNAVAILABLE;\n    status = mech->gss_get_mic_iov_length(minor_status, ctx->internal_ctx_id,\n\t\t\t\t\t  qop_req, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\tmap_error(minor_status, mech);\n    return status;\n}\n\nOM_uint32 KRB5_CALLCONV\ngss_release_iov_buffer (minor_status,\n\t\t\tiov,\n\t\t\tiov_count)\nOM_uint32 *\t\tminor_status;\ngss_iov_buffer_desc *\tiov;\nint\t\t\tiov_count;\n{\n    OM_uint32\t\tstatus = GSS_S_COMPLETE;\n    int\t\t\ti;\n\n    if (minor_status)\n\t*minor_status = 0;\n\n    if (iov == GSS_C_NO_IOV_BUFFER)\n\treturn GSS_S_COMPLETE;\n\n    for (i = 0; i < iov_count; i++) {\n\tif (iov[i].type & GSS_IOV_BUFFER_FLAG_ALLOCATED) {\n\t    status = gss_release_buffer(minor_status, &iov[i].buffer);\n\t    if (status != GSS_S_COMPLETE)\n\t\tbreak;\n\n\t    iov[i].type &= ~(GSS_IOV_BUFFER_FLAG_ALLOCATED);\n\t}\n    }\n\n    return status;\n}\n"], "filenames": ["src/lib/gssapi/mechglue/g_accept_sec_context.c", "src/lib/gssapi/mechglue/g_complete_auth_token.c", "src/lib/gssapi/mechglue/g_context_time.c", "src/lib/gssapi/mechglue/g_delete_sec_context.c", "src/lib/gssapi/mechglue/g_exp_sec_context.c", "src/lib/gssapi/mechglue/g_init_sec_context.c", "src/lib/gssapi/mechglue/g_inq_context.c", "src/lib/gssapi/mechglue/g_prf.c", "src/lib/gssapi/mechglue/g_process_context.c", "src/lib/gssapi/mechglue/g_seal.c", "src/lib/gssapi/mechglue/g_sign.c", "src/lib/gssapi/mechglue/g_unseal.c", "src/lib/gssapi/mechglue/g_unwrap_aead.c", "src/lib/gssapi/mechglue/g_unwrap_iov.c", "src/lib/gssapi/mechglue/g_verify.c", "src/lib/gssapi/mechglue/g_wrap_aead.c", "src/lib/gssapi/mechglue/g_wrap_iov.c"], "buggy_code_start_loc": [218, 54, 60, 90, 97, 195, 106, 61, 63, 94, 96, 78, 188, 91, 67, 258, 95], "buggy_code_end_loc": [388, 54, 60, 96, 97, 236, 106, 61, 63, 228, 96, 78, 188, 130, 67, 258, 220], "fixing_code_start_loc": [219, 55, 61, 90, 98, 195, 107, 62, 64, 95, 97, 79, 189, 92, 68, 259, 96], "fixing_code_end_loc": [395, 57, 63, 98, 100, 238, 109, 64, 66, 233, 99, 81, 191, 135, 70, 261, 229], "type": "CWE-415", "message": "Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.", "other": {"cve": {"id": "CVE-2017-11462", "sourceIdentifier": "cve@mitre.org", "published": "2017-09-13T16:29:00.430", "lastModified": "2020-01-21T15:47:29.447", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error."}, {"lang": "es", "value": "Existe una vulnerabilidad de doble liberaci\u00f3n (double free) en MIT Kerberos 5 (tambi\u00e9n conocido como krb5) que permite que atacantes provoquen un impacto no especificado mediante vectores que causen borrados autom\u00e1ticos de contextos de seguridad por error."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.14:*:*:*:*:*:*:*", "matchCriteriaId": "6E30B176-1FE5-4C53-8B79-2E6D87DF05B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.14:alpha1:*:*:*:*:*:*", "matchCriteriaId": "EC81822F-DC8C-4889-AD53-33216B66A109"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.14:beta1:*:*:*:*:*:*", "matchCriteriaId": "C1B23EE0-35EB-46FC-8620-AC0059498D9B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.14:beta2:*:*:*:*:*:*", "matchCriteriaId": "70831CB8-695D-45E8-A829-2E888823E8A5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.14.1:*:*:*:*:*:*:*", "matchCriteriaId": "E650B5A3-99CA-491B-A1FB-259EF548D92E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.14.2:*:*:*:*:*:*:*", "matchCriteriaId": "091F3C51-980E-482F-9882-0A555A8F74BC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.14.3:*:*:*:*:*:*:*", "matchCriteriaId": "A00BDDDC-3D5D-4D63-A8D8-63BF2F4C7329"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.14.4:*:*:*:*:*:*:*", "matchCriteriaId": "42505BC2-12A0-43E9-8561-80270D7CA74D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.14.5:*:*:*:*:*:*:*", "matchCriteriaId": "AF0496EF-F0F9-4A5D-92F4-E50C5F3DCA12"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.15:*:*:*:*:*:*:*", "matchCriteriaId": "79EEC80F-9E4F-4A6D-BB8D-6AB7764AD8E3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.15.1:*:*:*:*:*:*:*", "matchCriteriaId": "DB427FE4-CC39-43EE-A27B-69C5B18056FA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.15.1:beta1:*:*:*:*:*:*", "matchCriteriaId": "14A2F0C0-91E0-4DD9-851E-67CE8A5EAE0B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:1.15.1:beta2:*:*:*:*:*:*", "matchCriteriaId": "C1770120-B3B2-4B5A-9785-162399A47989"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:25:*:*:*:*:*:*:*", "matchCriteriaId": "772E9557-A371-4664-AE2D-4135AAEB89AA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:26:*:*:*:*:*:*:*", "matchCriteriaId": "6E4D8269-B407-4C24-AAB0-02F885C7D752"}]}]}], "references": [{"url": "http://krbdev.mit.edu/rt/Ticket/Display.html?id=8598", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1488873", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/krb5/krb5/commit/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/2FPRUP4YVOEBGEROUYWZFEQ64HTMGNED/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/krb5/krb5/commit/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf"}}