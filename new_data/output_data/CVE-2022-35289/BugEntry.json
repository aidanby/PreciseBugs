{"buggy_code": ["/*\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include \"hermes/VM/detail/IdentifierHashTable.h\"\n\n#include \"hermes/VM/StringPrimitive.h\"\n\nusing namespace hermes::vm::detail;\n// In GCC/CLANG, method definitions can refer to ancestor namespaces of\n// the namespace that the class is declared in without namespace qualifiers.\n// This is not allowed in MSVC.\nusing hermes::vm::StringPrimitive;\nusing hermes::vm::SymbolID;\n\ntemplate <typename T>\nuint32_t IdentifierHashTable::lookupString(\n    llvh::ArrayRef<T> str,\n    uint32_t hash,\n    bool mustBeNew) const {\n  assert(identifierTable_ && \"identifier table pointer is not initialized\");\n\n  auto cap = capacity();\n  assert(llvh::isPowerOf2_32(cap) && \"capacity must be power of 2\");\n  assert(size_ < cap && \"The hash table can never be full\");\n\n#ifdef HERMES_SLOW_DEBUG\n  assert(hash == hashString(str) && \"invalid hash\");\n#endif\n  uint32_t idx = hash & (cap - 1);\n  uint32_t base = 1;\n  // deletedIndex tracks the index of a deleted entry found in the conflict\n  // chain. If we could not find an entry that matches str, we would return\n  // the deleted slot for insertion to be able to reuse deleted space.\n  OptValue<uint32_t> deletedIndex;\n  // The loop will always terminate as long as the hash table is not full.\n  while (1) {\n    if (table_.isEmpty(idx)) {\n      // Found an empty entry, meaning that str does not exist in the table.\n      // If deletedIndex is available, return it, otherwise return idx.\n      return deletedIndex ? *deletedIndex : idx;\n    } else if (table_.isDeleted(idx)) {\n      assert(\n          !mustBeNew &&\n          \"mustBeNew should never be set if there are deleted entries\");\n      deletedIndex = idx;\n    } else if (!mustBeNew) {\n      // If mustBeNew is set, we know this string does not exist in the table.\n      // There is no need to compare.\n\n      auto &lookupTableEntry =\n          identifierTable_->getLookupTableEntry(table_.get(idx));\n      if (lookupTableEntry.getHash() == hash) {\n        if (lookupTableEntry.isStringPrim()) {\n          const StringPrimitive *strPrim = lookupTableEntry.getStringPrim();\n          if (strPrim->isASCII()) {\n            if (stringRefEquals(str, strPrim->castToASCIIRef())) {\n              return idx;\n            }\n          } else {\n            if (stringRefEquals(str, strPrim->castToUTF16Ref())) {\n              return idx;\n            }\n          }\n        } else if (lookupTableEntry.isLazyASCII()) {\n          // Lazy ASCII string.\n          if (stringRefEquals(str, lookupTableEntry.getLazyASCIIRef())) {\n            return idx;\n          }\n        } else {\n          // UTF16 string.\n          if (stringRefEquals(str, lookupTableEntry.getLazyUTF16Ref())) {\n            return idx;\n          }\n        }\n      }\n    }\n    /// Use quadratic probing to find next probe index in the hash table.\n    /// h(k, i) = (h(k) + 1/2 * i + 1/2 * i^2) mod m.\n    /// This guarantees the values of h(k,i) for i in [0,m-1] are all distinct.\n    idx = (idx + base) & (cap - 1);\n    ++base;\n  }\n}\n\n// Instantiate the templated method so it can be called from other files.\n\ntemplate uint32_t IdentifierHashTable::lookupString(\n    llvh::ArrayRef<char> str,\n    uint32_t hash,\n    bool mustBeNew) const;\n\ntemplate uint32_t IdentifierHashTable::lookupString(\n    llvh::ArrayRef<char16_t> str,\n    uint32_t hash,\n    bool mustBeNew) const;\n\nuint32_t IdentifierHashTable::lookupString(\n    const StringPrimitive *str,\n    bool mustBeNew) const {\n  if (str->isASCII()) {\n    return lookupString(str->castToASCIIRef(), mustBeNew);\n  } else {\n    return lookupString(str->castToUTF16Ref(), mustBeNew);\n  }\n}\n\nuint32_t IdentifierHashTable::lookupString(\n    const StringPrimitive *str,\n    uint32_t hash,\n    bool mustBeNew) const {\n  if (str->isASCII()) {\n    return lookupString(str->castToASCIIRef(), hash, mustBeNew);\n  } else {\n    return lookupString(str->castToUTF16Ref(), hash, mustBeNew);\n  }\n}\n\nvoid IdentifierHashTable::insert(uint32_t idx, SymbolID id) {\n  table_.set(idx, id.unsafeGetIndex());\n  ++size_;\n  ++nonEmptyEntryCount_;\n\n  if (shouldGrow()) {\n    growAndRehash(capacity() * 2);\n  }\n}\n\nvoid IdentifierHashTable::remove(const StringPrimitive *str) {\n  if (str->isASCII()) {\n    remove(str->castToASCIIRef());\n  } else {\n    remove(str->castToUTF16Ref());\n  }\n}\n\nvoid IdentifierHashTable::growAndRehash(uint32_t newCapacity) {\n  assert(llvh::isPowerOf2_32(newCapacity) && \"capacity must be power of 2\");\n  CompactTable tmpTable(newCapacity, table_.getCurrentScale());\n  tmpTable.swap(table_);\n  for (uint32_t oldIdx = 0; oldIdx < tmpTable.size(); ++oldIdx) {\n    if (!tmpTable.isValid(oldIdx)) {\n      continue;\n    }\n    // Pass true as second argument as we know this string is not in the table.\n    uint32_t idx = 0;\n    uint32_t oldVal = tmpTable.get(oldIdx);\n    auto &lookupTableEntry = identifierTable_->getLookupTableEntry(oldVal);\n    uint32_t hash = lookupTableEntry.getHash();\n    if (lookupTableEntry.isStringPrim()) {\n      idx = lookupString(lookupTableEntry.getStringPrim(), hash, true);\n    } else if (lookupTableEntry.isLazyASCII()) {\n      idx = lookupString(lookupTableEntry.getLazyASCIIRef(), hash, true);\n    } else if (lookupTableEntry.isLazyUTF16()) {\n      idx = lookupString(lookupTableEntry.getLazyUTF16Ref(), hash, true);\n    }\n    table_.set(idx, oldVal);\n  }\n  nonEmptyEntryCount_ = size_;\n}\n"], "fixing_code": ["/*\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n#include \"hermes/VM/detail/IdentifierHashTable.h\"\n\n#include \"hermes/VM/StringPrimitive.h\"\n\nusing namespace hermes::vm::detail;\n// In GCC/CLANG, method definitions can refer to ancestor namespaces of\n// the namespace that the class is declared in without namespace qualifiers.\n// This is not allowed in MSVC.\nusing hermes::vm::StringPrimitive;\nusing hermes::vm::SymbolID;\n\ntemplate <typename T>\nuint32_t IdentifierHashTable::lookupString(\n    llvh::ArrayRef<T> str,\n    uint32_t hash,\n    bool mustBeNew) const {\n  assert(identifierTable_ && \"identifier table pointer is not initialized\");\n\n  auto cap = capacity();\n  assert(llvh::isPowerOf2_32(cap) && \"capacity must be power of 2\");\n  assert(size_ < cap && \"The hash table can never be full\");\n\n#ifdef HERMES_SLOW_DEBUG\n  assert(hash == hashString(str) && \"invalid hash\");\n#endif\n  uint32_t idx = hash & (cap - 1);\n  uint32_t base = 1;\n  // deletedIndex tracks the index of a deleted entry found in the conflict\n  // chain. If we could not find an entry that matches str, we would return\n  // the deleted slot for insertion to be able to reuse deleted space.\n  OptValue<uint32_t> deletedIndex;\n  // The loop will always terminate as long as the hash table is not full.\n  while (1) {\n    if (table_.isEmpty(idx)) {\n      // Found an empty entry, meaning that str does not exist in the table.\n      // If deletedIndex is available, return it, otherwise return idx.\n      return deletedIndex ? *deletedIndex : idx;\n    } else if (table_.isDeleted(idx)) {\n      assert(\n          !mustBeNew &&\n          \"mustBeNew should never be set if there are deleted entries\");\n      deletedIndex = idx;\n    } else if (!mustBeNew) {\n      // If mustBeNew is set, we know this string does not exist in the table.\n      // There is no need to compare.\n\n      auto &lookupTableEntry =\n          identifierTable_->getLookupTableEntry(table_.get(idx));\n      if (lookupTableEntry.getHash() == hash) {\n        if (lookupTableEntry.isStringPrim()) {\n          const StringPrimitive *strPrim = lookupTableEntry.getStringPrim();\n          if (strPrim->isASCII()) {\n            if (stringRefEquals(str, strPrim->castToASCIIRef())) {\n              return idx;\n            }\n          } else {\n            if (stringRefEquals(str, strPrim->castToUTF16Ref())) {\n              return idx;\n            }\n          }\n        } else if (lookupTableEntry.isLazyASCII()) {\n          // Lazy ASCII string.\n          if (stringRefEquals(str, lookupTableEntry.getLazyASCIIRef())) {\n            return idx;\n          }\n        } else {\n          // UTF16 string.\n          if (stringRefEquals(str, lookupTableEntry.getLazyUTF16Ref())) {\n            return idx;\n          }\n        }\n      }\n    }\n    /// Use quadratic probing to find next probe index in the hash table.\n    /// h(k, i) = (h(k) + 1/2 * i + 1/2 * i^2) mod m.\n    /// This guarantees the values of h(k,i) for i in [0,m-1] are all distinct.\n    idx = (idx + base) & (cap - 1);\n    ++base;\n  }\n}\n\n// Instantiate the templated method so it can be called from other files.\n\ntemplate uint32_t IdentifierHashTable::lookupString(\n    llvh::ArrayRef<char> str,\n    uint32_t hash,\n    bool mustBeNew) const;\n\ntemplate uint32_t IdentifierHashTable::lookupString(\n    llvh::ArrayRef<char16_t> str,\n    uint32_t hash,\n    bool mustBeNew) const;\n\nuint32_t IdentifierHashTable::lookupString(\n    const StringPrimitive *str,\n    bool mustBeNew) const {\n  if (str->isASCII()) {\n    return lookupString(str->castToASCIIRef(), mustBeNew);\n  } else {\n    return lookupString(str->castToUTF16Ref(), mustBeNew);\n  }\n}\n\nuint32_t IdentifierHashTable::lookupString(\n    const StringPrimitive *str,\n    uint32_t hash,\n    bool mustBeNew) const {\n  if (str->isASCII()) {\n    return lookupString(str->castToASCIIRef(), hash, mustBeNew);\n  } else {\n    return lookupString(str->castToUTF16Ref(), hash, mustBeNew);\n  }\n}\n\nvoid IdentifierHashTable::insert(uint32_t idx, SymbolID id) {\n  table_.set(idx, id.unsafeGetIndex());\n  ++size_;\n  ++nonEmptyEntryCount_;\n\n  if (shouldGrow()) {\n    growAndRehash(capacity() * 2);\n  }\n}\n\nvoid IdentifierHashTable::remove(const StringPrimitive *str) {\n  if (str->isASCII()) {\n    remove(str->castToASCIIRef());\n  } else {\n    remove(str->castToUTF16Ref());\n  }\n}\n\nvoid IdentifierHashTable::growAndRehash(uint32_t newCapacity) {\n  // Guard against potential overflow in the calculation of new capacity.\n  if (LLVM_UNLIKELY(newCapacity <= capacity())) {\n    hermes_fatal(\"too many identifiers created\");\n  }\n  assert(llvh::isPowerOf2_32(newCapacity) && \"capacity must be power of 2\");\n  CompactTable tmpTable(newCapacity, table_.getCurrentScale());\n  tmpTable.swap(table_);\n  for (uint32_t oldIdx = 0; oldIdx < tmpTable.size(); ++oldIdx) {\n    if (!tmpTable.isValid(oldIdx)) {\n      continue;\n    }\n    // Pass true as second argument as we know this string is not in the table.\n    uint32_t idx = 0;\n    uint32_t oldVal = tmpTable.get(oldIdx);\n    auto &lookupTableEntry = identifierTable_->getLookupTableEntry(oldVal);\n    uint32_t hash = lookupTableEntry.getHash();\n    if (lookupTableEntry.isStringPrim()) {\n      idx = lookupString(lookupTableEntry.getStringPrim(), hash, true);\n    } else if (lookupTableEntry.isLazyASCII()) {\n      idx = lookupString(lookupTableEntry.getLazyASCIIRef(), hash, true);\n    } else if (lookupTableEntry.isLazyUTF16()) {\n      idx = lookupString(lookupTableEntry.getLazyUTF16Ref(), hash, true);\n    }\n    table_.set(idx, oldVal);\n  }\n  nonEmptyEntryCount_ = size_;\n}\n"], "filenames": ["lib/VM/detail/IdentifierHashTable.cpp"], "buggy_code_start_loc": [140], "buggy_code_end_loc": [140], "fixing_code_start_loc": [141], "fixing_code_end_loc": [145], "type": "CWE-190", "message": "A write-what-where condition in hermes caused by an integer overflow, prior to commit 5b6255ae049fa4641791e47fad994e8e8c4da374 allows attackers to potentially execute arbitrary code via crafted JavaScript. Note that this is only exploitable if the application using Hermes permits evaluation of untrusted JavaScript. Hence, most React Native applications are not affected.", "other": {"cve": {"id": "CVE-2022-35289", "sourceIdentifier": "cve-assign@fb.com", "published": "2022-10-11T02:15:08.787", "lastModified": "2022-10-11T19:09:50.227", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A write-what-where condition in hermes caused by an integer overflow, prior to commit 5b6255ae049fa4641791e47fad994e8e8c4da374 allows attackers to potentially execute arbitrary code via crafted JavaScript. Note that this is only exploitable if the application using Hermes permits evaluation of untrusted JavaScript. Hence, most React Native applications are not affected."}, {"lang": "es", "value": "Una condici\u00f3n write-what-where en Hermes causada por un desbordamiento de enteros, versiones anteriores al commit 5b6255ae049fa4641791e47fad994e8e8c4da374 permite a atacantes ejecutar potencialmente c\u00f3digo arbitrario por medio de JavaScript dise\u00f1ado. Tenga en cuenta que esto s\u00f3lo es explotable si la aplicaci\u00f3n que usa Hermes permite la evaluaci\u00f3n de JavaScript no confiable. Por lo tanto, la mayor\u00eda de las aplicaciones React Native no est\u00e1n afectadas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}, {"source": "cve-assign@fb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-680"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:facebook:hermes:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.12.0", "matchCriteriaId": "AD57D241-3E0D-490F-B160-C3E8FDD0BCBE"}]}]}], "references": [{"url": "https://github.com/facebook/hermes/commit/5b6255ae049fa4641791e47fad994e8e8c4da374", "source": "cve-assign@fb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.facebook.com/security/advisories/CVE-2022-35289", "source": "cve-assign@fb.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/facebook/hermes/commit/5b6255ae049fa4641791e47fad994e8e8c4da374"}}