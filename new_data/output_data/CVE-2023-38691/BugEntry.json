{"buggy_code": ["import { Application, default as express, NextFunction, Request, Response, Router, Router as router } from \"express\";\nimport { ProvisioningStore } from \"./store\";\nimport { Server } from \"http\";\nimport { v4 as uuid } from \"uuid\";\nimport axios from \"axios\";\nimport { ErrCode, IApiError, ProvisioningRequest, ApiError } from \".\";\nimport { URL } from \"url\";\nimport { MatrixHostResolver } from \"../utils/matrix-host-resolver\";\nimport IPCIDR from \"ip-cidr\";\nimport { isIP } from \"net\";\nimport { promises as dns } from \"dns\";\nimport ratelimiter, { Options as RatelimitOptions } from \"express-rate-limit\";\nimport { Methods } from \"./request\";\nimport { Logger } from \"..\";\n\n// Borrowed from\n// https://github.com/matrix-org/synapse/blob/91221b696156e9f1f9deecd425ae58af03ebb5d3/docs/sample_config.yaml#L215\nexport const DefaultDisallowedIpRanges = [\n    '127.0.0.0/8',\n    '10.0.0.0/8',\n    '172.16.0.0/12',\n    '192.168.0.0/16',\n    '100.64.0.0/10',\n    '192.0.0.0/24',\n    '169.254.0.0/16',\n    '192.88.99.0/24',\n    '198.18.0.0/15',\n    '192.0.2.0/24',\n    '198.51.100.0/24',\n    '203.0.113.0/24',\n    '224.0.0.0/4',\n    '::1/128',\n    'fe80::/10',\n    'fc00::/7',\n    '2001:db8::/32',\n    'ff00::/8',\n    'fec0::/10'\n]\n\nconst log = new Logger(\"ProvisioningApi\");\n\ninterface ExpRequestProvisioner extends Request {\n    matrixWidgetToken?: string;\n    matrixUserId: string|null;\n}\n\nexport interface ExchangeOpenAPIRequestBody {\n    openIdToken: string;\n    matrixServer: string;\n}\n\nexport interface ExchangeOpenAPIResponseBody {\n    token: string;\n    userId: string;\n}\n\nexport interface ProvisioningApiOpts {\n    /**\n     * A set of Matrix server names to override the well known response to. Should\n     * only be used for testing.\n     */\n    openIdOverride?: {[serverName: string]: URL},\n    /**\n     * Allow these IP ranges to be hit when handling OpenID requests even if they are within\n     * `disallowedIpRanges`. This allows specific sub-ranges of `disallowedIpRanges` to be\n     * used without having to carefully construct the ranges that still should be disallowed.\n     *\n     * If the IP the OpenID request would be made to isn't in either list it is implicitly allowed.\n     *\n     * Defaults to the empty list.\n     */\n    allowedIpRanges?: string[];\n    /**\n     * Disallow these IP ranges from being hit when handling OpenID requests. By default, a number of\n     * intenal ranges are blocked.\n     * @see DefaultDisallowedIpRanges\n     */\n    disallowedIpRanges?: string[];\n    /**\n     * Secret token for provisioning requests\n     */\n    provisioningToken?: string;\n    /**\n     * For widget tokens, use this prefix.\n     */\n    widgetTokenPrefix?: string;\n    /**\n     * How long should a widget token last for?\n     */\n    widgetTokenLifetimeMs?: number;\n    /**\n     * Where are the files stored for the widget frontend. If undefined, do not host a frontend.\n     */\n    widgetFrontendLocation?: string;\n    /**\n     * Provide an existing express app to bind to.\n     *\n     * Note: start() and close() will no-op when this is used.\n     */\n    expressApp?: Application;\n    /**\n     * Prefix to use for the API. E.g. `/api` in `/api/v1/session`\n     *\n     * Default is `/api`.\n     */\n    apiPrefix?: string;\n\n    /**\n     * Options for ratelimiting requests to the api server. Does not affect\n     * static content loading.\n     */\n    ratelimit?: boolean|Partial<RatelimitOptions>;\n}\n\n\nconst DEFAULT_WIDGET_TOKEN_PREFIX = \"br-sdk-utoken-\";\nconst DEFAULT_WIDGET_TOKEN_LIFETIME_MS = 24 * 60 * 60 * 1000; // One day\n\n/**\n * The provisioning API serves two classes of clients:\n *  - Integration managers which provide a unique secret token, and a userId\n *  - Widget users which provide a openId token.\n */\nexport class ProvisioningApi {\n    private app: Application;\n    private server?: Server;\n    protected baseRoute: Router;\n    private readonly widgetTokenPrefix: string;\n    private readonly widgetTokenLifetimeMs: number;\n    private readonly wellknown = new MatrixHostResolver();\n    private readonly allowedIpRanges: IPCIDR[];\n    private readonly disallowedIpRanges: IPCIDR[];\n    constructor(protected store: ProvisioningStore, private opts: ProvisioningApiOpts = {}) {\n        this.app = express();\n        this.app.use((req, _res, next) => {\n            log.info(`${req.method} ${req.path} ${req.ip || ''} ${req.headers[\"user-agent\"] || ''}`);\n            next();\n        });\n\n        this.widgetTokenPrefix = opts.widgetTokenPrefix || DEFAULT_WIDGET_TOKEN_PREFIX;\n        this.widgetTokenLifetimeMs = opts.widgetTokenLifetimeMs || DEFAULT_WIDGET_TOKEN_LIFETIME_MS;\n        this.opts.apiPrefix = opts.apiPrefix || \"/provisioning\";\n        this.allowedIpRanges = (opts.allowedIpRanges || []).map(ip => new IPCIDR(ip));\n        this.disallowedIpRanges = (opts.disallowedIpRanges || DefaultDisallowedIpRanges).map(ip => new IPCIDR(ip));\n        this.app.get('/health', this.getHealth.bind(this));\n\n        const limiter = this.opts.ratelimit && ratelimiter({\n            handler: (req, _res, next, options) => {\n                next(new ApiError(\n                    \"Too many requests\",\n                    ErrCode.Ratelimited,\n                    429,\n                    {\n                        retry_after_ms: options.windowMs,\n                    }\n                ));\n            },\n            windowMs: 1 * 60 * 1000, // 1 minute\n            max: 30, // Limit per window\n            standardHeaders: true,\n            legacyHeaders: false,\n            ...(typeof this.opts.ratelimit === \"object\" ? this.opts.ratelimit : {})\n        });\n\n        this.baseRoute = router();\n        if (opts.widgetFrontendLocation) {\n            this.baseRoute.use('/v1/static', express.static(opts.widgetFrontendLocation));\n        }\n\n        if (limiter) {\n            this.baseRoute.use(limiter);\n        }\n\n        this.baseRoute.use((req: express.Request, res: express.Response, next: NextFunction) => {\n            res.header('Access-Control-Allow-Origin', '*');\n            res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE');\n            next();\n        });\n\n        this.baseRoute.use(express.json());\n        // Unsecured requests\n        this.baseRoute.post(\n            `/v1/exchange_openid`,\n            (req, res, next) => this.postExchangeOpenId(req, res).catch(ex => next(ex))\n        );\n\n        // Secure requests\n        // addRoute ensures all successful requests are of type ProvisioningRequest\n        this.baseRoute.use((req, res, next) => this.authenticateRequest(req, res, next).catch(ex => next([ex, req])));\n        this.addRoute(\"get\", \"/v1/session\", this.getSession.bind(this));\n        this.addRoute(\"delete\", \"/v1/session\", this.deleteSession.bind(this));\n        this.addRoute(\"delete\", \"/v1/session/all\", this.deleteAllSessions.bind(this));\n        this.baseRoute.use(this.onError);\n\n        if (this.opts.expressApp) {\n            this.opts.expressApp.use(this.opts.apiPrefix, this.baseRoute);\n        }\n        else {\n            this.app.use(this.opts.apiPrefix, this.baseRoute);\n        }\n    }\n\n    public async start(port: number, hostname = \"0.0.0.0\", backlog = 10): Promise<void> {\n        if (this.opts.expressApp) {\n            log.warn(`Ignoring call to start(), api configured to use parent express app`);\n            return undefined;\n        }\n        return new Promise<void>((res) => {\n            this.server = this.app.listen(port, hostname, backlog, () => res());\n            log.info(`Widget API listening on port ${port}`);\n        });\n    }\n\n    public close(): Promise<void> {\n        return new Promise((res, rej) => this.server?.close(e => e ? rej(e) : res()));\n    }\n\n    public addRoute(\n        method: Methods,\n        path: string,\n        handler: (req: ProvisioningRequest, res: Response, next?: NextFunction) => void|Promise<void>,\n        fnName?: string): void {\n        this.baseRoute[method](path, async (req: Express.Request, res: Response, next: NextFunction) => {\n            const expRequest = req as ExpRequestProvisioner;\n            const provisioningRequest = new ProvisioningRequest(\n                expRequest,\n                expRequest.matrixUserId,\n                expRequest.matrixWidgetToken ? \"widget\" : \"provisioner\",\n                expRequest.matrixWidgetToken,\n                fnName,\n            );\n            try {\n                await handler(provisioningRequest, res, next);\n            }\n            catch (ex) {\n                // Pass to error handler.\n                next([ex, provisioningRequest]);\n            }\n            // Always add an error handler\n        }, this.onError);\n    }\n\n    private async authenticateRequest(\n        // Historically, user_id has been used. The bridge library supports either.\n        // eslint-disable-next-line camelcase\n        req: Request<unknown, unknown, {userId?: string, user_id?: string}>, res: Response, next: NextFunction) {\n        const authHeader = req.header(\"Authorization\");\n        if (!authHeader) {\n            throw new ApiError('No Authorization header', ErrCode.BadToken);\n        }\n        const token = authHeader.replace(\"Bearer \", \"\").replace(\"bearer \", \"\");\n        if (!token) {\n            throw new ApiError('Invalid Authorization header format', ErrCode.BadToken);\n        }\n        const requestProv = (req as ExpRequestProvisioner);\n        if (!this.opts.provisioningToken && req.body.userId) {\n            throw new ApiError('Provisioning feature disabled', ErrCode.DisabledFeature);\n        }\n        if (token === this.opts.provisioningToken) {\n            // Integration managers splice in the user_id in the body.\n            // Sometimes it's not required though.\n            requestProv.matrixUserId = req.body?.userId || req.body?.user_id || null;\n            requestProv.matrixWidgetToken = undefined;\n            next();\n            return;\n        }\n        const session = await this.store.getSessionForToken(token);\n        if (!session) {\n            throw new ApiError('Token not found', ErrCode.BadToken);\n        }\n        if (session.expiresTs < Date.now()) {\n            await this.store.deleteSession(token);\n            throw new ApiError('Token expired', ErrCode.BadToken);\n        }\n\n        requestProv.matrixUserId = session.userId;\n        requestProv.matrixWidgetToken = token;\n        next();\n    }\n\n    private getHealth(req: Request, res: Response) {\n        res.send({ok: true});\n    }\n\n    private getSession(req: ProvisioningRequest, res: Response) {\n        res.send({\n            userId: req.userId,\n            type: req.requestSource,\n        });\n    }\n\n    private async deleteSession(req: ProvisioningRequest, res: Response) {\n        if (!req.widgetToken) {\n            req.log.debug(\"tried to delete non-existent session\");\n            throw new ApiError(\"Session cannot be deleted\", ErrCode.UnsupportedOperation);\n        }\n        try {\n            await this.store.deleteSession(req.widgetToken);\n        }\n        catch (ex) {\n            req.log.error(\"Failed to delete session\", ex);\n            throw new ApiError(\"Session could not be deleted\", ErrCode.Unknown);\n        }\n        res.send({ok: true});\n    }\n\n    private async deleteAllSessions(req: ProvisioningRequest, res: Response) {\n        if (!req.widgetToken) {\n            req.log.debug(\"tried to delete non-existent session\");\n            throw new ApiError(\"Session cannot be deleted\", ErrCode.UnsupportedOperation);\n        }\n        if (!req.userId) {\n            throw new ApiError(\"\")\n        }\n        try {\n            await this.store.deleteAllSessions(req.userId);\n        }\n        catch (ex) {\n            req.log.error(\"Failed to delete all sessions\", ex);\n            throw new ApiError(\"Sessions could not be deleted\", ErrCode.Unknown);\n        }\n        res.send({ok: true});\n    }\n\n    private async checkIpBlacklist(url: URL) {\n        const host = url.hostname;\n        let ip: string;\n        if (isIP(host)) {\n            ip = host;\n        }\n        else {\n            const record = await dns.lookup(host);\n            ip = record.address;\n        }\n\n        if (this.allowedIpRanges.find(d => d.contains(ip))) {\n            return;\n        }\n\n        if (this.disallowedIpRanges.find(d => d.contains(ip))) {\n            throw new ApiError('Server is disallowed', ErrCode.BadOpenID);\n        }\n    }\n\n    private async postExchangeOpenId(\n        req: Request<unknown, unknown, ExchangeOpenAPIRequestBody>, res: Response<ExchangeOpenAPIResponseBody>) {\n        const server = req.body?.matrixServer;\n        const openIdToken = req.body?.openIdToken;\n        if (typeof server !== \"string\") {\n            throw new ApiError(\"Missing/invalid matrixServer in body\", ErrCode.BadValue);\n        }\n        if (typeof openIdToken !== \"string\") {\n            throw new ApiError(\"Missing/invalid openIdToken in body\", ErrCode.BadValue);\n        }\n        let url: URL;\n        let hostHeader: string;\n        try {\n            const overrideUrl = this.opts.openIdOverride?.[server];\n            if (overrideUrl) {\n                url = overrideUrl;\n                hostHeader = server;\n            }\n            else {\n                const urlRes = await this.wellknown.resolveMatrixServer(server);\n                hostHeader = urlRes.hostHeader;\n                url = urlRes.url;\n                await this.checkIpBlacklist(url);\n            }\n        }\n        catch (ex) {\n            log.warn(`Failed to fetch the server URL for ${server}`, ex);\n            throw new ApiError(\"Could not identify server url\", ErrCode.BadOpenID);\n        }\n\n        // Now do the token exchange\n        try {\n            const requestUrl = new URL(\"/_matrix/federation/v1/openid/userinfo\", url);\n            const response = await axios.get<{sub: string}>(requestUrl.toString(), {\n                params: {\n                    access_token: openIdToken,\n                },\n                headers: {\n                    'Host': hostHeader,\n                }\n            });\n            if (!response.data.sub) {\n                log.warn(`Server responded with invalid sub information for ${server}`, response.data);\n                throw new ApiError(\"Server did not respond with the correct sub information\", ErrCode.BadOpenID);\n            }\n            const userId = response.data.sub;\n            const token = this.widgetTokenPrefix + uuid().replace(/-/g, \"\");\n            const expiresTs = Date.now() + this.widgetTokenLifetimeMs;\n            await this.store.createSession({\n                userId,\n                token,\n                expiresTs,\n            });\n            res.send({ token, userId });\n        }\n        catch (ex) {\n            log.warn(`Failed to exchange the token for ${server}`, ex);\n            throw new ApiError(\"Failed to exchange token\", ErrCode.BadOpenID);\n        }\n    }\n\n    // Needed so that _next can be defined in order to preserve signature.\n    protected onError(\n        err: [IApiError|Error, ProvisioningRequest|Request]|IApiError|Error,\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        _req: Request, res: Response, _next: NextFunction) {\n        if (!err) {\n            return;\n        }\n        const [error, request] = Array.isArray(err) ? err : [err, undefined];\n        if (request instanceof ProvisioningRequest) {\n            request.log.error(error);\n        }\n        else {\n            log.error(error);\n        }\n        if (res.headersSent) {\n            return;\n        }\n        if (\"apply\" in error && typeof error.apply === \"function\") {\n            error.apply(res);\n        }\n        else {\n            new ApiError(\"An internal error occured\").apply(res);\n        }\n    }\n}\n"], "fixing_code": ["import { Application, default as express, NextFunction, Request, Response, Router, Router as router } from \"express\";\nimport { ProvisioningStore } from \"./store\";\nimport { Server } from \"http\";\nimport { v4 as uuid } from \"uuid\";\nimport axios from \"axios\";\nimport { ErrCode, IApiError, ProvisioningRequest, ApiError } from \".\";\nimport { URL } from \"url\";\nimport { MatrixHostResolver } from \"../utils/matrix-host-resolver\";\nimport IPCIDR from \"ip-cidr\";\nimport { isIP } from \"net\";\nimport { promises as dns } from \"dns\";\nimport ratelimiter, { Options as RatelimitOptions } from \"express-rate-limit\";\nimport { Methods } from \"./request\";\nimport { Logger } from \"..\";\n\n// Borrowed from\n// https://github.com/matrix-org/synapse/blob/91221b696156e9f1f9deecd425ae58af03ebb5d3/docs/sample_config.yaml#L215\nexport const DefaultDisallowedIpRanges = [\n    '127.0.0.0/8',\n    '10.0.0.0/8',\n    '172.16.0.0/12',\n    '192.168.0.0/16',\n    '100.64.0.0/10',\n    '192.0.0.0/24',\n    '169.254.0.0/16',\n    '192.88.99.0/24',\n    '198.18.0.0/15',\n    '192.0.2.0/24',\n    '198.51.100.0/24',\n    '203.0.113.0/24',\n    '224.0.0.0/4',\n    '::1/128',\n    'fe80::/10',\n    'fc00::/7',\n    '2001:db8::/32',\n    'ff00::/8',\n    'fec0::/10'\n]\n\nconst log = new Logger(\"ProvisioningApi\");\n\ninterface ExpRequestProvisioner extends Request {\n    matrixWidgetToken?: string;\n    matrixUserId: string|null;\n}\n\nexport interface ExchangeOpenAPIRequestBody {\n    openIdToken: string;\n    matrixServer: string;\n}\n\nexport interface ExchangeOpenAPIResponseBody {\n    token: string;\n    userId: string;\n}\n\nexport interface ProvisioningApiOpts {\n    /**\n     * A set of Matrix server names to override the well known response to. Should\n     * only be used for testing.\n     */\n    openIdOverride?: {[serverName: string]: URL},\n    /**\n     * Allow these IP ranges to be hit when handling OpenID requests even if they are within\n     * `disallowedIpRanges`. This allows specific sub-ranges of `disallowedIpRanges` to be\n     * used without having to carefully construct the ranges that still should be disallowed.\n     *\n     * If the IP the OpenID request would be made to isn't in either list it is implicitly allowed.\n     *\n     * Defaults to the empty list.\n     */\n    allowedIpRanges?: string[];\n    /**\n     * Disallow these IP ranges from being hit when handling OpenID requests. By default, a number of\n     * intenal ranges are blocked.\n     * @see DefaultDisallowedIpRanges\n     */\n    disallowedIpRanges?: string[];\n    /**\n     * Secret token for provisioning requests\n     */\n    provisioningToken?: string;\n    /**\n     * For widget tokens, use this prefix.\n     */\n    widgetTokenPrefix?: string;\n    /**\n     * How long should a widget token last for?\n     */\n    widgetTokenLifetimeMs?: number;\n    /**\n     * Where are the files stored for the widget frontend. If undefined, do not host a frontend.\n     */\n    widgetFrontendLocation?: string;\n    /**\n     * Provide an existing express app to bind to.\n     *\n     * Note: start() and close() will no-op when this is used.\n     */\n    expressApp?: Application;\n    /**\n     * Prefix to use for the API. E.g. `/api` in `/api/v1/session`\n     *\n     * Default is `/api`.\n     */\n    apiPrefix?: string;\n\n    /**\n     * Options for ratelimiting requests to the api server. Does not affect\n     * static content loading.\n     */\n    ratelimit?: boolean|Partial<RatelimitOptions>;\n}\n\n\nconst DEFAULT_WIDGET_TOKEN_PREFIX = \"br-sdk-utoken-\";\nconst DEFAULT_WIDGET_TOKEN_LIFETIME_MS = 24 * 60 * 60 * 1000; // One day\n\n/**\n * The provisioning API serves two classes of clients:\n *  - Integration managers which provide a unique secret token, and a userId\n *  - Widget users which provide a openId token.\n */\nexport class ProvisioningApi {\n    private app: Application;\n    private server?: Server;\n    protected baseRoute: Router;\n    private readonly widgetTokenPrefix: string;\n    private readonly widgetTokenLifetimeMs: number;\n    private readonly wellknown = new MatrixHostResolver();\n    private readonly allowedIpRanges: IPCIDR[];\n    private readonly disallowedIpRanges: IPCIDR[];\n    constructor(protected store: ProvisioningStore, private opts: ProvisioningApiOpts = {}) {\n        this.app = express();\n        this.app.use((req, _res, next) => {\n            log.info(`${req.method} ${req.path} ${req.ip || ''} ${req.headers[\"user-agent\"] || ''}`);\n            next();\n        });\n\n        this.widgetTokenPrefix = opts.widgetTokenPrefix || DEFAULT_WIDGET_TOKEN_PREFIX;\n        this.widgetTokenLifetimeMs = opts.widgetTokenLifetimeMs || DEFAULT_WIDGET_TOKEN_LIFETIME_MS;\n        this.opts.apiPrefix = opts.apiPrefix || \"/provisioning\";\n        this.allowedIpRanges = (opts.allowedIpRanges || []).map(ip => new IPCIDR(ip));\n        this.disallowedIpRanges = (opts.disallowedIpRanges || DefaultDisallowedIpRanges).map(ip => new IPCIDR(ip));\n        this.app.get('/health', this.getHealth.bind(this));\n\n        const limiter = this.opts.ratelimit && ratelimiter({\n            handler: (req, _res, next, options) => {\n                next(new ApiError(\n                    \"Too many requests\",\n                    ErrCode.Ratelimited,\n                    429,\n                    {\n                        retry_after_ms: options.windowMs,\n                    }\n                ));\n            },\n            windowMs: 1 * 60 * 1000, // 1 minute\n            max: 30, // Limit per window\n            standardHeaders: true,\n            legacyHeaders: false,\n            ...(typeof this.opts.ratelimit === \"object\" ? this.opts.ratelimit : {})\n        });\n\n        this.baseRoute = router();\n        if (opts.widgetFrontendLocation) {\n            this.baseRoute.use('/v1/static', express.static(opts.widgetFrontendLocation));\n        }\n\n        if (limiter) {\n            this.baseRoute.use(limiter);\n        }\n\n        this.baseRoute.use((req: express.Request, res: express.Response, next: NextFunction) => {\n            res.header('Access-Control-Allow-Origin', '*');\n            res.header('Access-Control-Allow-Methods', 'GET,PUT,POST,DELETE');\n            next();\n        });\n\n        this.baseRoute.use(express.json());\n        // Unsecured requests\n        this.baseRoute.post(\n            `/v1/exchange_openid`,\n            (req, res, next) => this.postExchangeOpenId(req, res).catch(ex => next(ex))\n        );\n\n        // Secure requests\n        // addRoute ensures all successful requests are of type ProvisioningRequest\n        this.baseRoute.use((req, res, next) => this.authenticateRequest(req, res, next).catch(ex => next([ex, req])));\n        this.addRoute(\"get\", \"/v1/session\", this.getSession.bind(this));\n        this.addRoute(\"delete\", \"/v1/session\", this.deleteSession.bind(this));\n        this.addRoute(\"delete\", \"/v1/session/all\", this.deleteAllSessions.bind(this));\n        this.baseRoute.use(this.onError);\n\n        if (this.opts.expressApp) {\n            this.opts.expressApp.use(this.opts.apiPrefix, this.baseRoute);\n        }\n        else {\n            this.app.use(this.opts.apiPrefix, this.baseRoute);\n        }\n    }\n\n    public async start(port: number, hostname = \"0.0.0.0\", backlog = 10): Promise<void> {\n        if (this.opts.expressApp) {\n            log.warn(`Ignoring call to start(), api configured to use parent express app`);\n            return undefined;\n        }\n        return new Promise<void>((res) => {\n            this.server = this.app.listen(port, hostname, backlog, () => res());\n            log.info(`Widget API listening on port ${port}`);\n        });\n    }\n\n    public close(): Promise<void> {\n        return new Promise((res, rej) => this.server?.close(e => e ? rej(e) : res()));\n    }\n\n    public addRoute(\n        method: Methods,\n        path: string,\n        handler: (req: ProvisioningRequest, res: Response, next?: NextFunction) => void|Promise<void>,\n        fnName?: string): void {\n        this.baseRoute[method](path, async (req: Express.Request, res: Response, next: NextFunction) => {\n            const expRequest = req as ExpRequestProvisioner;\n            const provisioningRequest = new ProvisioningRequest(\n                expRequest,\n                expRequest.matrixUserId,\n                expRequest.matrixWidgetToken ? \"widget\" : \"provisioner\",\n                expRequest.matrixWidgetToken,\n                fnName,\n            );\n            try {\n                await handler(provisioningRequest, res, next);\n            }\n            catch (ex) {\n                // Pass to error handler.\n                next([ex, provisioningRequest]);\n            }\n            // Always add an error handler\n        }, this.onError);\n    }\n\n    private async authenticateRequest(\n        // Historically, user_id has been used. The bridge library supports either.\n        // eslint-disable-next-line camelcase\n        req: Request<unknown, unknown, {userId?: string, user_id?: string}>, res: Response, next: NextFunction) {\n        const authHeader = req.header(\"Authorization\");\n        if (!authHeader) {\n            throw new ApiError('No Authorization header', ErrCode.BadToken);\n        }\n        const token = authHeader.replace(\"Bearer \", \"\").replace(\"bearer \", \"\");\n        if (!token) {\n            throw new ApiError('Invalid Authorization header format', ErrCode.BadToken);\n        }\n        const requestProv = (req as ExpRequestProvisioner);\n        if (!this.opts.provisioningToken && req.body.userId) {\n            throw new ApiError('Provisioning feature disabled', ErrCode.DisabledFeature);\n        }\n        if (token === this.opts.provisioningToken) {\n            // Integration managers splice in the user_id in the body.\n            // Sometimes it's not required though.\n            requestProv.matrixUserId = req.body?.userId || req.body?.user_id || null;\n            requestProv.matrixWidgetToken = undefined;\n            next();\n            return;\n        }\n        const session = await this.store.getSessionForToken(token);\n        if (!session) {\n            throw new ApiError('Token not found', ErrCode.BadToken);\n        }\n        if (session.expiresTs < Date.now()) {\n            await this.store.deleteSession(token);\n            throw new ApiError('Token expired', ErrCode.BadToken);\n        }\n\n        requestProv.matrixUserId = session.userId;\n        requestProv.matrixWidgetToken = token;\n        next();\n    }\n\n    private getHealth(req: Request, res: Response) {\n        res.send({ok: true});\n    }\n\n    private getSession(req: ProvisioningRequest, res: Response) {\n        res.send({\n            userId: req.userId,\n            type: req.requestSource,\n        });\n    }\n\n    private async deleteSession(req: ProvisioningRequest, res: Response) {\n        if (!req.widgetToken) {\n            req.log.debug(\"tried to delete non-existent session\");\n            throw new ApiError(\"Session cannot be deleted\", ErrCode.UnsupportedOperation);\n        }\n        try {\n            await this.store.deleteSession(req.widgetToken);\n        }\n        catch (ex) {\n            req.log.error(\"Failed to delete session\", ex);\n            throw new ApiError(\"Session could not be deleted\", ErrCode.Unknown);\n        }\n        res.send({ok: true});\n    }\n\n    private async deleteAllSessions(req: ProvisioningRequest, res: Response) {\n        if (!req.widgetToken) {\n            req.log.debug(\"tried to delete non-existent session\");\n            throw new ApiError(\"Session cannot be deleted\", ErrCode.UnsupportedOperation);\n        }\n        if (!req.userId) {\n            throw new ApiError(\"\")\n        }\n        try {\n            await this.store.deleteAllSessions(req.userId);\n        }\n        catch (ex) {\n            req.log.error(\"Failed to delete all sessions\", ex);\n            throw new ApiError(\"Sessions could not be deleted\", ErrCode.Unknown);\n        }\n        res.send({ok: true});\n    }\n\n    private async checkIpBlacklist(url: URL) {\n        const host = url.hostname;\n        let ip: string;\n        if (isIP(host)) {\n            ip = host;\n        }\n        else {\n            const record = await dns.lookup(host);\n            ip = record.address;\n        }\n\n        if (this.allowedIpRanges.find(d => d.contains(ip))) {\n            return;\n        }\n\n        if (this.disallowedIpRanges.find(d => d.contains(ip))) {\n            throw new ApiError('Server is disallowed', ErrCode.BadOpenID);\n        }\n    }\n\n    private async postExchangeOpenId(\n        req: Request<unknown, unknown, ExchangeOpenAPIRequestBody>, res: Response<ExchangeOpenAPIResponseBody>) {\n        const server = req.body?.matrixServer;\n        const openIdToken = req.body?.openIdToken;\n        if (typeof server !== \"string\") {\n            throw new ApiError(\"Missing/invalid matrixServer in body\", ErrCode.BadValue);\n        }\n        if (typeof openIdToken !== \"string\") {\n            throw new ApiError(\"Missing/invalid openIdToken in body\", ErrCode.BadValue);\n        }\n        let url: URL;\n        let hostHeader: string;\n        try {\n            const overrideUrl = this.opts.openIdOverride?.[server];\n            if (overrideUrl) {\n                url = overrideUrl;\n                hostHeader = server;\n            }\n            else {\n                const urlRes = await this.wellknown.resolveMatrixServer(server);\n                hostHeader = urlRes.hostHeader;\n                url = urlRes.url;\n                await this.checkIpBlacklist(url);\n            }\n        }\n        catch (ex) {\n            log.warn(`Failed to fetch the server URL for ${server}`, ex);\n            throw new ApiError(\"Could not identify server url\", ErrCode.BadOpenID);\n        }\n\n        // Now do the token exchange\n        try {\n            const requestUrl = new URL(\"/_matrix/federation/v1/openid/userinfo\", url);\n            const response = await axios.get<{sub: string}>(requestUrl.toString(), {\n                params: {\n                    access_token: openIdToken,\n                },\n                headers: {\n                    'Host': hostHeader,\n                }\n            });\n            if (!response.data.sub) {\n                log.warn(`Server responded with invalid sub information for ${server}`, response.data);\n                throw new ApiError(\"Server did not respond with the correct sub information\", ErrCode.BadOpenID);\n            }\n            const userId = response.data.sub;\n\n            const mxidMatch = userId.match(/([^:]+):(.+)/);\n            if (!mxidMatch) {\n                throw new ApiError(\"Server did not respond with a valid MXID\", ErrCode.BadOpenID);\n            }\n            const [, _localpart, serverName] = mxidMatch;\n            if (serverName !== server) {\n                throw new ApiError(\"Server returned a MXID belonging to another homeserver\", ErrCode.BadOpenID);\n            }\n\n            const token = this.widgetTokenPrefix + uuid().replace(/-/g, \"\");\n            const expiresTs = Date.now() + this.widgetTokenLifetimeMs;\n            await this.store.createSession({\n                userId,\n                token,\n                expiresTs,\n            });\n            res.send({ token, userId });\n        }\n        catch (ex) {\n            log.warn(`Failed to exchange the token for ${server}`, ex);\n            throw new ApiError(\"Failed to exchange token\", ErrCode.BadOpenID);\n        }\n    }\n\n    // Needed so that _next can be defined in order to preserve signature.\n    protected onError(\n        err: [IApiError|Error, ProvisioningRequest|Request]|IApiError|Error,\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        _req: Request, res: Response, _next: NextFunction) {\n        if (!err) {\n            return;\n        }\n        const [error, request] = Array.isArray(err) ? err : [err, undefined];\n        if (request instanceof ProvisioningRequest) {\n            request.log.error(error);\n        }\n        else {\n            log.error(error);\n        }\n        if (res.headersSent) {\n            return;\n        }\n        if (\"apply\" in error && typeof error.apply === \"function\") {\n            error.apply(res);\n        }\n        else {\n            new ApiError(\"An internal error occured\").apply(res);\n        }\n    }\n}\n"], "filenames": ["src/provisioning/api.ts"], "buggy_code_start_loc": [390], "buggy_code_end_loc": [390], "fixing_code_start_loc": [391], "fixing_code_end_loc": [401], "type": "CWE-287", "message": "matrix-appservice-bridge provides an API for setting up bridges. Starting in version 4.0.0 and prior to versions 8.1.2 and 9.0.1, a malicious Matrix server can use a foreign user's MXID in an OpenID exchange, allowing a bad actor to impersonate users when using the provisioning API. The library does not check that the servername part of the `sub` parameter (containing the user's *claimed* MXID) is the the same as the servername we are talking to. A malicious actor could spin up a server on any given domain, respond with a `sub` parameter according to the user they want to act as and use the resulting token to perform provisioning requests. Versions 8.1.2 and 9.0.1 contain a patch. As a workaround, disable the provisioning API.", "other": {"cve": {"id": "CVE-2023-38691", "sourceIdentifier": "security-advisories@github.com", "published": "2023-08-04T17:15:11.063", "lastModified": "2023-08-11T19:34:52.207", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "matrix-appservice-bridge provides an API for setting up bridges. Starting in version 4.0.0 and prior to versions 8.1.2 and 9.0.1, a malicious Matrix server can use a foreign user's MXID in an OpenID exchange, allowing a bad actor to impersonate users when using the provisioning API. The library does not check that the servername part of the `sub` parameter (containing the user's *claimed* MXID) is the the same as the servername we are talking to. A malicious actor could spin up a server on any given domain, respond with a `sub` parameter according to the user they want to act as and use the resulting token to perform provisioning requests. Versions 8.1.2 and 9.0.1 contain a patch. As a workaround, disable the provisioning API."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.1, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:matrix:matrix-appservice-bridge:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "4.0.0", "versionEndExcluding": "8.1.2", "matchCriteriaId": "DC6F33A1-2DFE-4F73-8C67-45C4782AC792"}, {"vulnerable": true, "criteria": "cpe:2.3:a:matrix:matrix-appservice-bridge:9.0.0:*:*:*:*:node.js:*:*", "matchCriteriaId": "40415786-C971-407F-9E51-9C5203B4F2CB"}]}]}], "references": [{"url": "https://github.com/matrix-org/matrix-appservice-bridge/commit/4c6723a5e7beda65cdf1ae5dbb882e8beaac8552", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/matrix-org/matrix-appservice-bridge/security/advisories/GHSA-vc7j-h8xg-fv5x", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/matrix-org/matrix-appservice-bridge/commit/4c6723a5e7beda65cdf1ae5dbb882e8beaac8552"}}