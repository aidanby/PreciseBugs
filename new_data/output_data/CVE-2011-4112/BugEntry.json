{"buggy_code": ["/* $Id: isdn_net.c,v 1.1.2.2 2004/01/12 22:37:19 keil Exp $\n *\n * Linux ISDN subsystem, network interfaces and related functions (linklevel).\n *\n * Copyright 1994-1998  by Fritz Elfert (fritz@isdn4linux.de)\n * Copyright 1995,96    by Thinking Objects Software GmbH Wuerzburg\n * Copyright 1995,96    by Michael Hipp (Michael.Hipp@student.uni-tuebingen.de)\n *\n * This software may be used and distributed according to the terms\n * of the GNU General Public License, incorporated herein by reference.\n *\n * Data Over Voice (DOV) support added - Guy Ellis 23-Mar-02 \n *                                       guy@traverse.com.au\n * Outgoing calls - looks for a 'V' in first char of dialed number\n * Incoming calls - checks first character of eaz as follows:\n *   Numeric - accept DATA only - original functionality\n *   'V'     - accept VOICE (DOV) only\n *   'B'     - accept BOTH DATA and DOV types\n *\n * Jan 2001: fix CISCO HDLC      Bjoern A. Zeeb <i4l@zabbadoz.net>\n *           for info on the protocol, see \n *           http://i4l.zabbadoz.net/i4l/cisco-hdlc.txt\n */\n\n#include <linux/isdn.h>\n#include <linux/slab.h>\n#include <net/arp.h>\n#include <net/dst.h>\n#include <net/pkt_sched.h>\n#include <linux/inetdevice.h>\n#include \"isdn_common.h\"\n#include \"isdn_net.h\"\n#ifdef CONFIG_ISDN_PPP\n#include \"isdn_ppp.h\"\n#endif\n#ifdef CONFIG_ISDN_X25\n#include <linux/concap.h>\n#include \"isdn_concap.h\"\n#endif\n\n\n/*\n * Outline of new tbusy handling: \n *\n * Old method, roughly spoken, consisted of setting tbusy when entering\n * isdn_net_start_xmit() and at several other locations and clearing\n * it from isdn_net_start_xmit() thread when sending was successful.\n *\n * With 2.3.x multithreaded network core, to prevent problems, tbusy should\n * only be set by the isdn_net_start_xmit() thread and only when a tx-busy\n * condition is detected. Other threads (in particular isdn_net_stat_callb())\n * are only allowed to clear tbusy.\n *\n * -HE\n */\n\n/*\n * About SOFTNET:\n * Most of the changes were pretty obvious and basically done by HE already.\n *\n * One problem of the isdn net device code is that is uses struct net_device\n * for masters and slaves. However, only master interface are registered to \n * the network layer, and therefore, it only makes sense to call netif_* \n * functions on them.\n *\n * --KG\n */\n\n/* \n * Find out if the netdevice has been ifup-ed yet.\n * For slaves, look at the corresponding master.\n */\nstatic __inline__ int isdn_net_device_started(isdn_net_dev *n)\n{\n\tisdn_net_local *lp = n->local;\n\tstruct net_device *dev;\n\t\n\tif (lp->master) \n\t\tdev = lp->master;\n\telse\n\t\tdev = n->dev;\n\treturn netif_running(dev);\n}\n\n/*\n * wake up the network -> net_device queue.\n * For slaves, wake the corresponding master interface.\n */\nstatic __inline__ void isdn_net_device_wake_queue(isdn_net_local *lp)\n{\n\tif (lp->master) \n\t\tnetif_wake_queue(lp->master);\n\telse\n\t\tnetif_wake_queue(lp->netdev->dev);\n}\n\n/*\n * stop the network -> net_device queue.\n * For slaves, stop the corresponding master interface.\n */\nstatic __inline__ void isdn_net_device_stop_queue(isdn_net_local *lp)\n{\n\tif (lp->master)\n\t\tnetif_stop_queue(lp->master);\n\telse\n\t\tnetif_stop_queue(lp->netdev->dev);\n}\n\n/*\n * find out if the net_device which this lp belongs to (lp can be\n * master or slave) is busy. It's busy iff all (master and slave) \n * queues are busy\n */\nstatic __inline__ int isdn_net_device_busy(isdn_net_local *lp)\n{\n\tisdn_net_local *nlp;\n\tisdn_net_dev *nd;\n\tunsigned long flags;\n\n\tif (!isdn_net_lp_busy(lp))\n\t\treturn 0;\n\n\tif (lp->master)\n\t\tnd = ISDN_MASTER_PRIV(lp)->netdev;\n\telse\n\t\tnd = lp->netdev;\n\t\n\tspin_lock_irqsave(&nd->queue_lock, flags);\n\tnlp = lp->next;\n\twhile (nlp != lp) {\n\t\tif (!isdn_net_lp_busy(nlp)) {\n\t\t\tspin_unlock_irqrestore(&nd->queue_lock, flags);\n\t\t\treturn 0;\n\t\t}\n\t\tnlp = nlp->next;\n\t}\n\tspin_unlock_irqrestore(&nd->queue_lock, flags);\n\treturn 1;\n}\n\nstatic __inline__ void isdn_net_inc_frame_cnt(isdn_net_local *lp)\n{\n\tatomic_inc(&lp->frame_cnt);\n\tif (isdn_net_device_busy(lp))\n\t\tisdn_net_device_stop_queue(lp);\n}\n\nstatic __inline__ void isdn_net_dec_frame_cnt(isdn_net_local *lp)\n{\n\tatomic_dec(&lp->frame_cnt);\n\n\tif (!(isdn_net_device_busy(lp))) {\n\t\tif (!skb_queue_empty(&lp->super_tx_queue)) {\n\t\t\tschedule_work(&lp->tqueue);\n\t\t} else {\n\t\t\tisdn_net_device_wake_queue(lp);\n\t\t}\n       }                                                                      \n}\n\nstatic __inline__ void isdn_net_zero_frame_cnt(isdn_net_local *lp)\n{\n\tatomic_set(&lp->frame_cnt, 0);\n}\n\n/* For 2.2.x we leave the transmitter busy timeout at 2 secs, just \n * to be safe.\n * For 2.3.x we push it up to 20 secs, because call establishment\n * (in particular callback) may take such a long time, and we \n * don't want confusing messages in the log. However, there is a slight\n * possibility that this large timeout will break other things like MPPP,\n * which might rely on the tx timeout. If so, we'll find out this way...\n */\n\n#define ISDN_NET_TX_TIMEOUT (20*HZ) \n\n/* Prototypes */\n\nstatic int isdn_net_force_dial_lp(isdn_net_local *);\nstatic netdev_tx_t isdn_net_start_xmit(struct sk_buff *,\n\t\t\t\t\t     struct net_device *);\n\nstatic void isdn_net_ciscohdlck_connected(isdn_net_local *lp);\nstatic void isdn_net_ciscohdlck_disconnected(isdn_net_local *lp);\n\nchar *isdn_net_revision = \"$Revision: 1.1.2.2 $\";\n\n /*\n  * Code for raw-networking over ISDN\n  */\n\nstatic void\nisdn_net_unreachable(struct net_device *dev, struct sk_buff *skb, char *reason)\n{\n\tif(skb) {\n\n\t\tu_short proto = ntohs(skb->protocol);\n\n\t\tprintk(KERN_DEBUG \"isdn_net: %s: %s, signalling dst_link_failure %s\\n\",\n\t\t       dev->name,\n\t\t       (reason != NULL) ? reason : \"unknown\",\n\t\t       (proto != ETH_P_IP) ? \"Protocol != ETH_P_IP\" : \"\");\n\t\t\n\t\tdst_link_failure(skb);\n\t}\n\telse {  /* dial not triggered by rawIP packet */\n\t\tprintk(KERN_DEBUG \"isdn_net: %s: %s\\n\",\n\t\t\t   dev->name,\n\t\t\t   (reason != NULL) ? reason : \"reason unknown\");\n\t}\n}\n\nstatic void\nisdn_net_reset(struct net_device *dev)\n{\n#ifdef CONFIG_ISDN_X25\n\tstruct concap_device_ops * dops =\n\t\t((isdn_net_local *) netdev_priv(dev))->dops;\n\tstruct concap_proto * cprot =\n\t\t((isdn_net_local *) netdev_priv(dev))->netdev->cprot;\n#endif\n#ifdef CONFIG_ISDN_X25\n\tif( cprot && cprot -> pops && dops )\n\t\tcprot -> pops -> restart ( cprot, dev, dops );\n#endif\n}\n\n/* Open/initialize the board. */\nstatic int\nisdn_net_open(struct net_device *dev)\n{\n\tint i;\n\tstruct net_device *p;\n\tstruct in_device *in_dev;\n\n\t/* moved here from isdn_net_reset, because only the master has an\n\t   interface associated which is supposed to be started. BTW:\n\t   we need to call netif_start_queue, not netif_wake_queue here */\n\tnetif_start_queue(dev);\n\n\tisdn_net_reset(dev);\n\t/* Fill in the MAC-level header (not needed, but for compatibility... */\n\tfor (i = 0; i < ETH_ALEN - sizeof(u32); i++)\n\t\tdev->dev_addr[i] = 0xfc;\n\tif ((in_dev = dev->ip_ptr) != NULL) {\n\t\t/*\n\t\t *      Any address will do - we take the first\n\t\t */\n\t\tstruct in_ifaddr *ifa = in_dev->ifa_list;\n\t\tif (ifa != NULL)\n\t\t\tmemcpy(dev->dev_addr+2, &ifa->ifa_local, 4);\n\t}\n\n\t/* If this interface has slaves, start them also */\n\tp = MASTER_TO_SLAVE(dev);\n\tif (p) {\n\t\twhile (p) {\n\t\t\tisdn_net_reset(p);\n\t\t\tp = MASTER_TO_SLAVE(p);\n\t\t}\n\t}\n\tisdn_lock_drivers();\n\treturn 0;\n}\n\n/*\n * Assign an ISDN-channel to a net-interface\n */\nstatic void\nisdn_net_bind_channel(isdn_net_local * lp, int idx)\n{\n\tlp->flags |= ISDN_NET_CONNECTED;\n\tlp->isdn_device = dev->drvmap[idx];\n\tlp->isdn_channel = dev->chanmap[idx];\n\tdev->rx_netdev[idx] = lp->netdev;\n\tdev->st_netdev[idx] = lp->netdev;\n}\n\n/*\n * unbind a net-interface (resets interface after an error)\n */\nstatic void\nisdn_net_unbind_channel(isdn_net_local * lp)\n{\n\tskb_queue_purge(&lp->super_tx_queue);\n\n\tif (!lp->master) {\t/* reset only master device */\n\t\t/* Moral equivalent of dev_purge_queues():\n\t\t   BEWARE! This chunk of code cannot be called from hardware\n\t\t   interrupt handler. I hope it is true. --ANK\n\t\t */\n\t\tqdisc_reset_all_tx(lp->netdev->dev);\n\t}\n\tlp->dialstate = 0;\n\tdev->rx_netdev[isdn_dc2minor(lp->isdn_device, lp->isdn_channel)] = NULL;\n\tdev->st_netdev[isdn_dc2minor(lp->isdn_device, lp->isdn_channel)] = NULL;\n\tif (lp->isdn_device != -1 && lp->isdn_channel != -1)\n\t\tisdn_free_channel(lp->isdn_device, lp->isdn_channel,\n\t\t\t\t  ISDN_USAGE_NET);\n\tlp->flags &= ~ISDN_NET_CONNECTED;\n\tlp->isdn_device = -1;\n\tlp->isdn_channel = -1;\n}\n\n/*\n * Perform auto-hangup and cps-calculation for net-interfaces.\n *\n * auto-hangup:\n * Increment idle-counter (this counter is reset on any incoming or\n * outgoing packet), if counter exceeds configured limit either do a\n * hangup immediately or - if configured - wait until just before the next\n * charge-info.\n *\n * cps-calculation (needed for dynamic channel-bundling):\n * Since this function is called every second, simply reset the\n * byte-counter of the interface after copying it to the cps-variable.\n */\nstatic unsigned long last_jiffies = -HZ;\n\nvoid\nisdn_net_autohup(void)\n{\n\tisdn_net_dev *p = dev->netdev;\n\tint anymore;\n\n\tanymore = 0;\n\twhile (p) {\n\t\tisdn_net_local *l = p->local;\n\t\tif (jiffies == last_jiffies)\n\t\t\tl->cps = l->transcount;\n\t\telse\n\t\t\tl->cps = (l->transcount * HZ) / (jiffies - last_jiffies);\n\t\tl->transcount = 0;\n\t\tif (dev->net_verbose > 3)\n\t\t\tprintk(KERN_DEBUG \"%s: %d bogocps\\n\", p->dev->name, l->cps);\n\t\tif ((l->flags & ISDN_NET_CONNECTED) && (!l->dialstate)) {\n\t\t\tanymore = 1;\n\t\t\tl->huptimer++;\n\t\t\t/*\n\t\t\t * if there is some dialmode where timeout-hangup\n\t\t\t * should _not_ be done, check for that here\n\t\t\t */\n\t\t\tif ((l->onhtime) &&\n\t\t\t    (l->huptimer > l->onhtime))\n\t\t\t{\n\t\t\t\tif (l->hupflags & ISDN_MANCHARGE &&\n\t\t\t\t    l->hupflags & ISDN_CHARGEHUP) {\n\t\t\t\t\twhile (time_after(jiffies, l->chargetime + l->chargeint))\n\t\t\t\t\t\tl->chargetime += l->chargeint;\n\t\t\t\t\tif (time_after(jiffies, l->chargetime + l->chargeint - 2 * HZ))\n\t\t\t\t\t\tif (l->outgoing || l->hupflags & ISDN_INHUP)\n\t\t\t\t\t\t\tisdn_net_hangup(p->dev);\n\t\t\t\t} else if (l->outgoing) {\n\t\t\t\t\tif (l->hupflags & ISDN_CHARGEHUP) {\n\t\t\t\t\t\tif (l->hupflags & ISDN_WAITCHARGE) {\n\t\t\t\t\t\t\tprintk(KERN_DEBUG \"isdn_net: Hupflags of %s are %X\\n\",\n\t\t\t\t\t\t\t       p->dev->name, l->hupflags);\n\t\t\t\t\t\t\tisdn_net_hangup(p->dev);\n\t\t\t\t\t\t} else if (time_after(jiffies, l->chargetime + l->chargeint)) {\n\t\t\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t\t\t       \"isdn_net: %s: chtime = %lu, chint = %d\\n\",\n\t\t\t\t\t\t\t       p->dev->name, l->chargetime, l->chargeint);\n\t\t\t\t\t\t\tisdn_net_hangup(p->dev);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t\tisdn_net_hangup(p->dev);\n\t\t\t\t} else if (l->hupflags & ISDN_INHUP)\n\t\t\t\t\tisdn_net_hangup(p->dev);\n\t\t\t}\n\n\t\t\tif(dev->global_flags & ISDN_GLOBAL_STOPPED || (ISDN_NET_DIALMODE(*l) == ISDN_NET_DM_OFF)) {\n\t\t\t\tisdn_net_hangup(p->dev);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tp = (isdn_net_dev *) p->next;\n\t}\n\tlast_jiffies = jiffies;\n\tisdn_timer_ctrl(ISDN_TIMER_NETHANGUP, anymore);\n}\n\nstatic void isdn_net_lp_disconnected(isdn_net_local *lp)\n{\n\tisdn_net_rm_from_bundle(lp);\n}\n\n/*\n * Handle status-messages from ISDN-interfacecard.\n * This function is called from within the main-status-dispatcher\n * isdn_status_callback, which itself is called from the low-level driver.\n * Return: 1 = Event handled, 0 = not for us or unknown Event.\n */\nint\nisdn_net_stat_callback(int idx, isdn_ctrl *c)\n{\n\tisdn_net_dev *p = dev->st_netdev[idx];\n\tint cmd = c->command;\n\n\tif (p) {\n\t\tisdn_net_local *lp = p->local;\n#ifdef CONFIG_ISDN_X25\n\t\tstruct concap_proto *cprot = lp->netdev->cprot;\n\t\tstruct concap_proto_ops *pops = cprot ? cprot->pops : NULL;\n#endif\n\t\tswitch (cmd) {\n\t\t\tcase ISDN_STAT_BSENT:\n\t\t\t\t/* A packet has successfully been sent out */\n\t\t\t\tif ((lp->flags & ISDN_NET_CONNECTED) &&\n\t\t\t\t    (!lp->dialstate)) {\n\t\t\t\t\tisdn_net_dec_frame_cnt(lp);\n\t\t\t\t\tlp->stats.tx_packets++;\n\t\t\t\t\tlp->stats.tx_bytes += c->parm.length;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\tcase ISDN_STAT_DCONN:\n\t\t\t\t/* D-Channel is up */\n\t\t\t\tswitch (lp->dialstate) {\n\t\t\t\t\tcase 4:\n\t\t\t\t\tcase 7:\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\tlp->dialstate++;\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\tcase 12:\n\t\t\t\t\t\tlp->dialstate = 5;\n\t\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ISDN_STAT_DHUP:\n\t\t\t\t/* Either D-Channel-hangup or error during dialout */\n#ifdef CONFIG_ISDN_X25\n\t\t\t\t/* If we are not connencted then dialing had\n\t\t\t\t   failed. If there are generic encap protocol\n\t\t\t\t   receiver routines signal the closure of\n\t\t\t\t   the link*/\n\n\t\t\t\tif( !(lp->flags & ISDN_NET_CONNECTED)\n\t\t\t\t    && pops && pops -> disconn_ind )\n\t\t\t\t\tpops -> disconn_ind(cprot);\n#endif /* CONFIG_ISDN_X25 */\n\t\t\t\tif ((!lp->dialstate) && (lp->flags & ISDN_NET_CONNECTED)) {\n\t\t\t\t\tif (lp->p_encap == ISDN_NET_ENCAP_CISCOHDLCK)\n\t\t\t\t\t\tisdn_net_ciscohdlck_disconnected(lp);\n#ifdef CONFIG_ISDN_PPP\n\t\t\t\t\tif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP)\n\t\t\t\t\t\tisdn_ppp_free(lp);\n#endif\n\t\t\t\t\tisdn_net_lp_disconnected(lp);\n\t\t\t\t\tisdn_all_eaz(lp->isdn_device, lp->isdn_channel);\n\t\t\t\t\tprintk(KERN_INFO \"%s: remote hangup\\n\", p->dev->name);\n\t\t\t\t\tprintk(KERN_INFO \"%s: Chargesum is %d\\n\", p->dev->name,\n\t\t\t\t\t       lp->charge);\n\t\t\t\t\tisdn_net_unbind_channel(lp);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n#ifdef CONFIG_ISDN_X25\n\t\t\tcase ISDN_STAT_BHUP:\n\t\t\t\t/* B-Channel-hangup */\n\t\t\t\t/* try if there are generic encap protocol\n\t\t\t\t   receiver routines and signal the closure of\n\t\t\t\t   the link */\n\t\t\t\tif( pops  &&  pops -> disconn_ind ){\n\t\t\t\t\t\tpops -> disconn_ind(cprot);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\tbreak;\n#endif /* CONFIG_ISDN_X25 */\n\t\t\tcase ISDN_STAT_BCONN:\n\t\t\t\t/* B-Channel is up */\n\t\t\t\tisdn_net_zero_frame_cnt(lp);\n\t\t\t\tswitch (lp->dialstate) {\n\t\t\t\t\tcase 5:\n\t\t\t\t\tcase 6:\n\t\t\t\t\tcase 7:\n\t\t\t\t\tcase 8:\n\t\t\t\t\tcase 9:\n\t\t\t\t\tcase 10:\n\t\t\t\t\tcase 12:\n\t\t\t\t\t\tif (lp->dialstate <= 6) {\n\t\t\t\t\t\t\tdev->usage[idx] |= ISDN_USAGE_OUTGOING;\n\t\t\t\t\t\t\tisdn_info_update();\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tdev->rx_netdev[idx] = p;\n\t\t\t\t\t\tlp->dialstate = 0;\n\t\t\t\t\t\tisdn_timer_ctrl(ISDN_TIMER_NETHANGUP, 1);\n\t\t\t\t\t\tif (lp->p_encap == ISDN_NET_ENCAP_CISCOHDLCK)\n\t\t\t\t\t\t\tisdn_net_ciscohdlck_connected(lp);\n\t\t\t\t\t\tif (lp->p_encap != ISDN_NET_ENCAP_SYNCPPP) {\n\t\t\t\t\t\t\tif (lp->master) { /* is lp a slave? */\n\t\t\t\t\t\t\t\tisdn_net_dev *nd = ISDN_MASTER_PRIV(lp)->netdev;\n\t\t\t\t\t\t\t\tisdn_net_add_to_bundle(nd, lp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprintk(KERN_INFO \"isdn_net: %s connected\\n\", p->dev->name);\n\t\t\t\t\t\t/* If first Chargeinfo comes before B-Channel connect,\n\t\t\t\t\t\t * we correct the timestamp here.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tlp->chargetime = jiffies;\n\n\t\t\t\t\t\t/* reset dial-timeout */\n\t\t\t\t\t\tlp->dialstarted = 0;\n\t\t\t\t\t\tlp->dialwait_timer = 0;\n\n#ifdef CONFIG_ISDN_PPP\n\t\t\t\t\t\tif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP)\n\t\t\t\t\t\t\tisdn_ppp_wakeup_daemon(lp);\n#endif\n#ifdef CONFIG_ISDN_X25\n\t\t\t\t\t\t/* try if there are generic concap receiver routines */\n\t\t\t\t\t\tif( pops )\n\t\t\t\t\t\t\tif( pops->connect_ind)\n\t\t\t\t\t\t\t\tpops->connect_ind(cprot);\n#endif /* CONFIG_ISDN_X25 */\n\t\t\t\t\t\t/* ppp needs to do negotiations first */\n\t\t\t\t\t\tif (lp->p_encap != ISDN_NET_ENCAP_SYNCPPP)\n\t\t\t\t\t\t\tisdn_net_device_wake_queue(lp);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ISDN_STAT_NODCH:\n\t\t\t\t/* No D-Channel avail. */\n\t\t\t\tif (lp->dialstate == 4) {\n\t\t\t\t\tlp->dialstate--;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ISDN_STAT_CINF:\n\t\t\t\t/* Charge-info from TelCo. Calculate interval between\n\t\t\t\t * charge-infos and set timestamp for last info for\n\t\t\t\t * usage by isdn_net_autohup()\n\t\t\t\t */\n\t\t\t\tlp->charge++;\n\t\t\t\tif (lp->hupflags & ISDN_HAVECHARGE) {\n\t\t\t\t\tlp->hupflags &= ~ISDN_WAITCHARGE;\n\t\t\t\t\tlp->chargeint = jiffies - lp->chargetime - (2 * HZ);\n\t\t\t\t}\n\t\t\t\tif (lp->hupflags & ISDN_WAITCHARGE)\n\t\t\t\t\tlp->hupflags |= ISDN_HAVECHARGE;\n\t\t\t\tlp->chargetime = jiffies;\n\t\t\t\tprintk(KERN_DEBUG \"isdn_net: Got CINF chargetime of %s now %lu\\n\",\n\t\t\t\t       p->dev->name, lp->chargetime);\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * Perform dialout for net-interfaces and timeout-handling for\n * D-Channel-up and B-Channel-up Messages.\n * This function is initially called from within isdn_net_start_xmit() or\n * or isdn_net_find_icall() after initializing the dialstate for an\n * interface. If further calls are needed, the function schedules itself\n * for a timer-callback via isdn_timer_function().\n * The dialstate is also affected by incoming status-messages from\n * the ISDN-Channel which are handled in isdn_net_stat_callback() above.\n */\nvoid\nisdn_net_dial(void)\n{\n\tisdn_net_dev *p = dev->netdev;\n\tint anymore = 0;\n\tint i;\n\tisdn_ctrl cmd;\n        u_char *phone_number;\n\n\twhile (p) {\n\t\tisdn_net_local *lp = p->local;\n\n#ifdef ISDN_DEBUG_NET_DIAL\n\t\tif (lp->dialstate)\n\t\t\tprintk(KERN_DEBUG \"%s: dialstate=%d\\n\", p->dev->name, lp->dialstate);\n#endif\n\t\tswitch (lp->dialstate) {\n\t\t\tcase 0:\n\t\t\t\t/* Nothing to do for this interface */\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t/* Initiate dialout. Set phone-number-pointer to first number\n\t\t\t\t * of interface.\n\t\t\t\t */\n\t\t\t\tlp->dial = lp->phone[1];\n\t\t\t\tif (!lp->dial) {\n\t\t\t\t\tprintk(KERN_WARNING \"%s: phone number deleted?\\n\",\n\t\t\t\t\t       p->dev->name);\n\t\t\t\t\tisdn_net_hangup(p->dev);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tanymore = 1;\n\n\t\t\t\tif(lp->dialtimeout > 0)\n\t\t\t\t\tif(lp->dialstarted == 0 || time_after(jiffies, lp->dialstarted + lp->dialtimeout + lp->dialwait)) {\n\t\t\t\t\t\tlp->dialstarted = jiffies;\n\t\t\t\t\t\tlp->dialwait_timer = 0;\n\t\t\t\t\t}\n\n\t\t\t\tlp->dialstate++;\n\t\t\t\t/* Fall through */\n\t\t\tcase 2:\n\t\t\t\t/* Prepare dialing. Clear EAZ, then set EAZ. */\n\t\t\t\tcmd.driver = lp->isdn_device;\n\t\t\t\tcmd.arg = lp->isdn_channel;\n\t\t\t\tcmd.command = ISDN_CMD_CLREAZ;\n\t\t\t\tisdn_command(&cmd);\n\t\t\t\tsprintf(cmd.parm.num, \"%s\", isdn_map_eaz2msn(lp->msn, cmd.driver));\n\t\t\t\tcmd.command = ISDN_CMD_SETEAZ;\n\t\t\t\tisdn_command(&cmd);\n\t\t\t\tlp->dialretry = 0;\n\t\t\t\tanymore = 1;\n\t\t\t\tlp->dialstate++;\n\t\t\t\t/* Fall through */\n\t\t\tcase 3:\n\t\t\t\t/* Setup interface, dial current phone-number, switch to next number.\n\t\t\t\t * If list of phone-numbers is exhausted, increment\n\t\t\t\t * retry-counter.\n\t\t\t\t */\n\t\t\t\tif(dev->global_flags & ISDN_GLOBAL_STOPPED || (ISDN_NET_DIALMODE(*lp) == ISDN_NET_DM_OFF)) {\n\t\t\t\t\tchar *s;\n\t\t\t\t\tif (dev->global_flags & ISDN_GLOBAL_STOPPED)\n\t\t\t\t\t\ts = \"dial suppressed: isdn system stopped\";\n\t\t\t\t\telse\n\t\t\t\t\t\ts = \"dial suppressed: dialmode `off'\";\n\t\t\t\t\tisdn_net_unreachable(p->dev, NULL, s);\n\t\t\t\t\tisdn_net_hangup(p->dev);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcmd.driver = lp->isdn_device;\n\t\t\t\tcmd.command = ISDN_CMD_SETL2;\n\t\t\t\tcmd.arg = lp->isdn_channel + (lp->l2_proto << 8);\n\t\t\t\tisdn_command(&cmd);\n\t\t\t\tcmd.driver = lp->isdn_device;\n\t\t\t\tcmd.command = ISDN_CMD_SETL3;\n\t\t\t\tcmd.arg = lp->isdn_channel + (lp->l3_proto << 8);\n\t\t\t\tisdn_command(&cmd);\n\t\t\t\tcmd.driver = lp->isdn_device;\n\t\t\t\tcmd.arg = lp->isdn_channel;\n\t\t\t\tif (!lp->dial) {\n\t\t\t\t\tprintk(KERN_WARNING \"%s: phone number deleted?\\n\",\n\t\t\t\t\t       p->dev->name);\n\t\t\t\t\tisdn_net_hangup(p->dev);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!strncmp(lp->dial->num, \"LEASED\", strlen(\"LEASED\"))) {\n\t\t\t\t\tlp->dialstate = 4;\n\t\t\t\t\tprintk(KERN_INFO \"%s: Open leased line ...\\n\", p->dev->name);\n\t\t\t\t} else {\n\t\t\t\t\tif(lp->dialtimeout > 0)\n\t\t\t\t\t\tif (time_after(jiffies, lp->dialstarted + lp->dialtimeout)) {\n\t\t\t\t\t\t\tlp->dialwait_timer = jiffies + lp->dialwait;\n\t\t\t\t\t\t\tlp->dialstarted = 0;\n\t\t\t\t\t\t\tisdn_net_unreachable(p->dev, NULL, \"dial: timed out\");\n\t\t\t\t\t\t\tisdn_net_hangup(p->dev);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\tcmd.driver = lp->isdn_device;\n\t\t\t\t\tcmd.command = ISDN_CMD_DIAL;\n\t\t\t\t\tcmd.parm.setup.si2 = 0;\n\n                                        /* check for DOV */\n                                        phone_number = lp->dial->num;\n                                        if ((*phone_number == 'v') ||\n\t\t\t\t\t    (*phone_number == 'V')) { /* DOV call */\n                                                cmd.parm.setup.si1 = 1;\n                                        } else { /* DATA call */\n                                                cmd.parm.setup.si1 = 7;\n\t\t\t\t\t}\n\n\t\t\t\t\tstrcpy(cmd.parm.setup.phone, phone_number);\n\t\t\t\t\t/*\n\t\t\t\t\t * Switch to next number or back to start if at end of list.\n\t\t\t\t\t */\n\t\t\t\t\tif (!(lp->dial = (isdn_net_phone *) lp->dial->next)) {\n\t\t\t\t\t\tlp->dial = lp->phone[1];\n\t\t\t\t\t\tlp->dialretry++;\n\n\t\t\t\t\t\tif (lp->dialretry > lp->dialmax) {\n\t\t\t\t\t\t\tif (lp->dialtimeout == 0) {\n\t\t\t\t\t\t\t\tlp->dialwait_timer = jiffies + lp->dialwait;\n\t\t\t\t\t\t\t\tlp->dialstarted = 0;\n\t\t\t\t\t\t\t\tisdn_net_unreachable(p->dev, NULL, \"dial: tried all numbers dialmax times\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tisdn_net_hangup(p->dev);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsprintf(cmd.parm.setup.eazmsn, \"%s\",\n\t\t\t\t\t\tisdn_map_eaz2msn(lp->msn, cmd.driver));\n\t\t\t\t\ti = isdn_dc2minor(lp->isdn_device, lp->isdn_channel);\n\t\t\t\t\tif (i >= 0) {\n\t\t\t\t\t\tstrcpy(dev->num[i], cmd.parm.setup.phone);\n\t\t\t\t\t\tdev->usage[i] |= ISDN_USAGE_OUTGOING;\n\t\t\t\t\t\tisdn_info_update();\n\t\t\t\t\t}\n\t\t\t\t\tprintk(KERN_INFO \"%s: dialing %d %s... %s\\n\", p->dev->name,\n\t\t\t\t\t       lp->dialretry, cmd.parm.setup.phone,\n\t\t\t\t\t       (cmd.parm.setup.si1 == 1) ? \"DOV\" : \"\");\n\t\t\t\t\tlp->dtimer = 0;\n#ifdef ISDN_DEBUG_NET_DIAL\n\t\t\t\t\tprintk(KERN_DEBUG \"dial: d=%d c=%d\\n\", lp->isdn_device,\n\t\t\t\t\t       lp->isdn_channel);\n#endif\n\t\t\t\t\tisdn_command(&cmd);\n\t\t\t\t}\n\t\t\t\tlp->huptimer = 0;\n\t\t\t\tlp->outgoing = 1;\n\t\t\t\tif (lp->chargeint) {\n\t\t\t\t\tlp->hupflags |= ISDN_HAVECHARGE;\n\t\t\t\t\tlp->hupflags &= ~ISDN_WAITCHARGE;\n\t\t\t\t} else {\n\t\t\t\t\tlp->hupflags |= ISDN_WAITCHARGE;\n\t\t\t\t\tlp->hupflags &= ~ISDN_HAVECHARGE;\n\t\t\t\t}\n\t\t\t\tanymore = 1;\n\t\t\t\tlp->dialstate =\n\t\t\t\t    (lp->cbdelay &&\n\t\t\t\t     (lp->flags & ISDN_NET_CBOUT)) ? 12 : 4;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\t/* Wait for D-Channel-connect.\n\t\t\t\t * If timeout, switch back to state 3.\n\t\t\t\t * Dialmax-handling moved to state 3.\n\t\t\t\t */\n\t\t\t\tif (lp->dtimer++ > ISDN_TIMER_DTIMEOUT10)\n\t\t\t\t\tlp->dialstate = 3;\n\t\t\t\tanymore = 1;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\t/* Got D-Channel-Connect, send B-Channel-request */\n\t\t\t\tcmd.driver = lp->isdn_device;\n\t\t\t\tcmd.arg = lp->isdn_channel;\n\t\t\t\tcmd.command = ISDN_CMD_ACCEPTB;\n\t\t\t\tanymore = 1;\n\t\t\t\tlp->dtimer = 0;\n\t\t\t\tlp->dialstate++;\n\t\t\t\tisdn_command(&cmd);\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\t/* Wait for B- or D-Channel-connect. If timeout,\n\t\t\t\t * switch back to state 3.\n\t\t\t\t */\n#ifdef ISDN_DEBUG_NET_DIAL\n\t\t\t\tprintk(KERN_DEBUG \"dialtimer2: %d\\n\", lp->dtimer);\n#endif\n\t\t\t\tif (lp->dtimer++ > ISDN_TIMER_DTIMEOUT10)\n\t\t\t\t\tlp->dialstate = 3;\n\t\t\t\tanymore = 1;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\t/* Got incoming Call, setup L2 and L3 protocols,\n\t\t\t\t * then wait for D-Channel-connect\n\t\t\t\t */\n#ifdef ISDN_DEBUG_NET_DIAL\n\t\t\t\tprintk(KERN_DEBUG \"dialtimer4: %d\\n\", lp->dtimer);\n#endif\n\t\t\t\tcmd.driver = lp->isdn_device;\n\t\t\t\tcmd.command = ISDN_CMD_SETL2;\n\t\t\t\tcmd.arg = lp->isdn_channel + (lp->l2_proto << 8);\n\t\t\t\tisdn_command(&cmd);\n\t\t\t\tcmd.driver = lp->isdn_device;\n\t\t\t\tcmd.command = ISDN_CMD_SETL3;\n\t\t\t\tcmd.arg = lp->isdn_channel + (lp->l3_proto << 8);\n\t\t\t\tisdn_command(&cmd);\n\t\t\t\tif (lp->dtimer++ > ISDN_TIMER_DTIMEOUT15)\n\t\t\t\t\tisdn_net_hangup(p->dev);\n\t\t\t\telse {\n\t\t\t\t\tanymore = 1;\n\t\t\t\t\tlp->dialstate++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\t/* Got incoming D-Channel-Connect, send B-Channel-request */\n\t\t\t\tcmd.driver = lp->isdn_device;\n\t\t\t\tcmd.arg = lp->isdn_channel;\n\t\t\t\tcmd.command = ISDN_CMD_ACCEPTB;\n\t\t\t\tisdn_command(&cmd);\n\t\t\t\tanymore = 1;\n\t\t\t\tlp->dtimer = 0;\n\t\t\t\tlp->dialstate++;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\tcase 10:\n\t\t\t\t/*  Wait for B- or D-channel-connect */\n#ifdef ISDN_DEBUG_NET_DIAL\n\t\t\t\tprintk(KERN_DEBUG \"dialtimer4: %d\\n\", lp->dtimer);\n#endif\n\t\t\t\tif (lp->dtimer++ > ISDN_TIMER_DTIMEOUT10)\n\t\t\t\t\tisdn_net_hangup(p->dev);\n\t\t\t\telse\n\t\t\t\t\tanymore = 1;\n\t\t\t\tbreak;\n\t\t\tcase 11:\n\t\t\t\t/* Callback Delay */\n\t\t\t\tif (lp->dtimer++ > lp->cbdelay)\n\t\t\t\t\tlp->dialstate = 1;\n\t\t\t\tanymore = 1;\n\t\t\t\tbreak;\n\t\t\tcase 12:\n\t\t\t\t/* Remote does callback. Hangup after cbdelay, then wait for incoming\n\t\t\t\t * call (in state 4).\n\t\t\t\t */\n\t\t\t\tif (lp->dtimer++ > lp->cbdelay)\n\t\t\t\t{\n\t\t\t\t\tprintk(KERN_INFO \"%s: hangup waiting for callback ...\\n\", p->dev->name);\n\t\t\t\t\tlp->dtimer = 0;\n\t\t\t\t\tlp->dialstate = 4;\n\t\t\t\t\tcmd.driver = lp->isdn_device;\n\t\t\t\t\tcmd.command = ISDN_CMD_HANGUP;\n\t\t\t\t\tcmd.arg = lp->isdn_channel;\n\t\t\t\t\tisdn_command(&cmd);\n\t\t\t\t\tisdn_all_eaz(lp->isdn_device, lp->isdn_channel);\n\t\t\t\t}\n\t\t\t\tanymore = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintk(KERN_WARNING \"isdn_net: Illegal dialstate %d for device %s\\n\",\n\t\t\t\t       lp->dialstate, p->dev->name);\n\t\t}\n\t\tp = (isdn_net_dev *) p->next;\n\t}\n\tisdn_timer_ctrl(ISDN_TIMER_NETDIAL, anymore);\n}\n\n/*\n * Perform hangup for a net-interface.\n */\nvoid\nisdn_net_hangup(struct net_device *d)\n{\n\tisdn_net_local *lp = netdev_priv(d);\n\tisdn_ctrl cmd;\n#ifdef CONFIG_ISDN_X25\n\tstruct concap_proto *cprot = lp->netdev->cprot;\n\tstruct concap_proto_ops *pops = cprot ? cprot->pops : NULL;\n#endif\n\n\tif (lp->flags & ISDN_NET_CONNECTED) {\n\t\tif (lp->slave != NULL) {\n\t\t\tisdn_net_local *slp = ISDN_SLAVE_PRIV(lp);\n\t\t\tif (slp->flags & ISDN_NET_CONNECTED) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t\t\"isdn_net: hang up slave %s before %s\\n\",\n\t\t\t\t\tlp->slave->name, d->name);\n\t\t\t\tisdn_net_hangup(lp->slave);\n\t\t\t}\n\t\t}\n\t\tprintk(KERN_INFO \"isdn_net: local hangup %s\\n\", d->name);\n#ifdef CONFIG_ISDN_PPP\n\t\tif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP)\n\t\t\tisdn_ppp_free(lp);\n#endif\n\t\tisdn_net_lp_disconnected(lp);\n#ifdef CONFIG_ISDN_X25\n\t\t/* try if there are generic encap protocol\n\t\t   receiver routines and signal the closure of\n\t\t   the link */\n\t\tif( pops && pops -> disconn_ind )\n\t\t  pops -> disconn_ind(cprot);\n#endif /* CONFIG_ISDN_X25 */\n\n\t\tcmd.driver = lp->isdn_device;\n\t\tcmd.command = ISDN_CMD_HANGUP;\n\t\tcmd.arg = lp->isdn_channel;\n\t\tisdn_command(&cmd);\n\t\tprintk(KERN_INFO \"%s: Chargesum is %d\\n\", d->name, lp->charge);\n\t\tisdn_all_eaz(lp->isdn_device, lp->isdn_channel);\n\t}\n\tisdn_net_unbind_channel(lp);\n}\n\ntypedef struct {\n\t__be16 source;\n\t__be16 dest;\n} ip_ports;\n\nstatic void\nisdn_net_log_skb(struct sk_buff * skb, isdn_net_local * lp)\n{\n\t/* hopefully, this was set correctly */\n\tconst u_char *p = skb_network_header(skb);\n\tunsigned short proto = ntohs(skb->protocol);\n\tint data_ofs;\n\tip_ports *ipp;\n\tchar addinfo[100];\n\n\taddinfo[0] = '\\0';\n\t/* This check stolen from 2.1.72 dev_queue_xmit_nit() */\n\tif (p < skb->data || skb->network_header >= skb->tail) {\n\t\t/* fall back to old isdn_net_log_packet method() */\n\t\tchar * buf = skb->data;\n\n\t\tprintk(KERN_DEBUG \"isdn_net: protocol %04x is buggy, dev %s\\n\", skb->protocol, lp->netdev->dev->name);\n\t\tp = buf;\n\t\tproto = ETH_P_IP;\n\t\tswitch (lp->p_encap) {\n\t\t\tcase ISDN_NET_ENCAP_IPTYP:\n\t\t\t\tproto = ntohs(*(__be16 *)&buf[0]);\n\t\t\t\tp = &buf[2];\n\t\t\t\tbreak;\n\t\t\tcase ISDN_NET_ENCAP_ETHER:\n\t\t\t\tproto = ntohs(*(__be16 *)&buf[12]);\n\t\t\t\tp = &buf[14];\n\t\t\t\tbreak;\n\t\t\tcase ISDN_NET_ENCAP_CISCOHDLC:\n\t\t\t\tproto = ntohs(*(__be16 *)&buf[2]);\n\t\t\t\tp = &buf[4];\n\t\t\t\tbreak;\n#ifdef CONFIG_ISDN_PPP\n\t\t\tcase ISDN_NET_ENCAP_SYNCPPP:\n\t\t\t\tproto = ntohs(skb->protocol);\n\t\t\t\tp = &buf[IPPP_MAX_HEADER];\n\t\t\t\tbreak;\n#endif\n\t\t}\n\t}\n\tdata_ofs = ((p[0] & 15) * 4);\n\tswitch (proto) {\n\t\tcase ETH_P_IP:\n\t\t\tswitch (p[9]) {\n\t\t\t\tcase 1:\n\t\t\t\t\tstrcpy(addinfo, \" ICMP\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tstrcpy(addinfo, \" IGMP\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tstrcpy(addinfo, \" IPIP\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\tipp = (ip_ports *) (&p[data_ofs]);\n\t\t\t\t\tsprintf(addinfo, \" TCP, port: %d -> %d\", ntohs(ipp->source),\n\t\t\t\t\t\tntohs(ipp->dest));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\n\t\t\t\t\tstrcpy(addinfo, \" EGP\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 12:\n\t\t\t\t\tstrcpy(addinfo, \" PUP\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 17:\n\t\t\t\t\tipp = (ip_ports *) (&p[data_ofs]);\n\t\t\t\t\tsprintf(addinfo, \" UDP, port: %d -> %d\", ntohs(ipp->source),\n\t\t\t\t\t\tntohs(ipp->dest));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 22:\n\t\t\t\t\tstrcpy(addinfo, \" IDP\");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprintk(KERN_INFO \"OPEN: %pI4 -> %pI4%s\\n\",\n\t\t\t       p + 12, p + 16, addinfo);\n\t\t\tbreak;\n\t\tcase ETH_P_ARP:\n\t\t\tprintk(KERN_INFO \"OPEN: ARP %pI4 -> *.*.*.* ?%pI4\\n\",\n\t\t\t       p + 14, p + 24);\n\t\t\tbreak;\n\t}\n}\n\n/*\n * this function is used to send supervisory data, i.e. data which was\n * not received from the network layer, but e.g. frames from ipppd, CCP\n * reset frames etc.\n */\nvoid isdn_net_write_super(isdn_net_local *lp, struct sk_buff *skb)\n{\n\tif (in_irq()) {\n\t\t// we can't grab the lock from irq context, \n\t\t// so we just queue the packet\n\t\tskb_queue_tail(&lp->super_tx_queue, skb);\n\t\tschedule_work(&lp->tqueue);\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&lp->xmit_lock);\n\tif (!isdn_net_lp_busy(lp)) {\n\t\tisdn_net_writebuf_skb(lp, skb);\n\t} else {\n\t\tskb_queue_tail(&lp->super_tx_queue, skb);\n\t}\n\tspin_unlock_bh(&lp->xmit_lock);\n}\n\n/*\n * called from tq_immediate\n */\nstatic void isdn_net_softint(struct work_struct *work)\n{\n\tisdn_net_local *lp = container_of(work, isdn_net_local, tqueue);\n\tstruct sk_buff *skb;\n\n\tspin_lock_bh(&lp->xmit_lock);\n\twhile (!isdn_net_lp_busy(lp)) {\n\t\tskb = skb_dequeue(&lp->super_tx_queue);\n\t\tif (!skb)\n\t\t\tbreak;\n\t\tisdn_net_writebuf_skb(lp, skb);                                \n\t}\n\tspin_unlock_bh(&lp->xmit_lock);\n}\n\n/* \n * all frames sent from the (net) LL to a HL driver should go via this function\n * it's serialized by the caller holding the lp->xmit_lock spinlock\n */\nvoid isdn_net_writebuf_skb(isdn_net_local *lp, struct sk_buff *skb)\n{\n\tint ret;\n\tint len = skb->len;     /* save len */\n\n\t/* before obtaining the lock the caller should have checked that\n\t   the lp isn't busy */\n\tif (isdn_net_lp_busy(lp)) {\n\t\tprintk(\"isdn BUG at %s:%d!\\n\", __FILE__, __LINE__);\n\t\tgoto error;\n\t}\n\n\tif (!(lp->flags & ISDN_NET_CONNECTED)) {\n\t\tprintk(\"isdn BUG at %s:%d!\\n\", __FILE__, __LINE__);\n\t\tgoto error;\n\t}\n\tret = isdn_writebuf_skb_stub(lp->isdn_device, lp->isdn_channel, 1, skb);\n\tif (ret != len) {\n\t\t/* we should never get here */\n\t\tprintk(KERN_WARNING \"%s: HL driver queue full\\n\", lp->netdev->dev->name);\n\t\tgoto error;\n\t}\n\t\n\tlp->transcount += len;\n\tisdn_net_inc_frame_cnt(lp);\n\treturn;\n\n error:\n\tdev_kfree_skb(skb);\n\tlp->stats.tx_errors++;\n\n}\n\n\n/*\n *  Helper function for isdn_net_start_xmit.\n *  When called, the connection is already established.\n *  Based on cps-calculation, check if device is overloaded.\n *  If so, and if a slave exists, trigger dialing for it.\n *  If any slave is online, deliver packets using a simple round robin\n *  scheme.\n *\n *  Return: 0 on success, !0 on failure.\n */\n\nstatic int\nisdn_net_xmit(struct net_device *ndev, struct sk_buff *skb)\n{\n\tisdn_net_dev *nd;\n\tisdn_net_local *slp;\n\tisdn_net_local *lp = netdev_priv(ndev);\n\tint retv = NETDEV_TX_OK;\n\n\tif (((isdn_net_local *) netdev_priv(ndev))->master) {\n\t\tprintk(\"isdn BUG at %s:%d!\\n\", __FILE__, __LINE__);\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\t/* For the other encaps the header has already been built */\n#ifdef CONFIG_ISDN_PPP\n\tif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP) {\n\t\treturn isdn_ppp_xmit(skb, ndev);\n\t}\n#endif\n\tnd = ((isdn_net_local *) netdev_priv(ndev))->netdev;\n\tlp = isdn_net_get_locked_lp(nd);\n\tif (!lp) {\n\t\tprintk(KERN_WARNING \"%s: all channels busy - requeuing!\\n\", ndev->name);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\t/* we have our lp locked from now on */\n\n\t/* Reset hangup-timeout */\n\tlp->huptimer = 0; // FIXME?\n\tisdn_net_writebuf_skb(lp, skb);\n\tspin_unlock_bh(&lp->xmit_lock);\n\n\t/* the following stuff is here for backwards compatibility.\n\t * in future, start-up and hangup of slaves (based on current load)\n\t * should move to userspace and get based on an overall cps\n\t * calculation\n\t */\n\tif (lp->cps > lp->triggercps) {\n\t\tif (lp->slave) {\n\t\t\tif (!lp->sqfull) {\n\t\t\t\t/* First time overload: set timestamp only */\n\t\t\t\tlp->sqfull = 1;\n\t\t\t\tlp->sqfull_stamp = jiffies;\n\t\t\t} else {\n\t\t\t\t/* subsequent overload: if slavedelay exceeded, start dialing */\n\t\t\t\tif (time_after(jiffies, lp->sqfull_stamp + lp->slavedelay)) {\n\t\t\t\t\tslp = ISDN_SLAVE_PRIV(lp);\n\t\t\t\t\tif (!(slp->flags & ISDN_NET_CONNECTED)) {\n\t\t\t\t\t\tisdn_net_force_dial_lp(ISDN_SLAVE_PRIV(lp));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (lp->sqfull && time_after(jiffies, lp->sqfull_stamp + lp->slavedelay + (10 * HZ))) {\n\t\t\tlp->sqfull = 0;\n\t\t}\n\t\t/* this is a hack to allow auto-hangup for slaves on moderate loads */\n\t\tnd->queue = nd->local;\n\t}\n\n\treturn retv;\n\n}\n\nstatic void\nisdn_net_adjust_hdr(struct sk_buff *skb, struct net_device *dev)\n{\n\tisdn_net_local *lp = netdev_priv(dev);\n\tif (!skb)\n\t\treturn;\n\tif (lp->p_encap == ISDN_NET_ENCAP_ETHER) {\n\t\tconst int pullsize = skb_network_offset(skb) - ETH_HLEN;\n\t\tif (pullsize > 0) {\n\t\t\tprintk(KERN_DEBUG \"isdn_net: Pull junk %d\\n\", pullsize);\n\t\t\tskb_pull(skb, pullsize);\n\t\t}\n\t}\n}\n\n\nstatic void isdn_net_tx_timeout(struct net_device * ndev)\n{\n\tisdn_net_local *lp = netdev_priv(ndev);\n\n\tprintk(KERN_WARNING \"isdn_tx_timeout dev %s dialstate %d\\n\", ndev->name, lp->dialstate);\n\tif (!lp->dialstate){\n\t\tlp->stats.tx_errors++;\n                /*\n\t\t * There is a certain probability that this currently\n\t\t * works at all because if we always wake up the interface,\n\t\t * then upper layer will try to send the next packet\n\t\t * immediately. And then, the old clean_up logic in the\n\t\t * driver will hopefully continue to work as it used to do.\n\t\t *\n\t\t * This is rather primitive right know, we better should\n\t\t * clean internal queues here, in particular for multilink and\n\t\t * ppp, and reset HL driver's channel, too.   --HE\n\t\t *\n\t\t * actually, this may not matter at all, because ISDN hardware\n\t\t * should not see transmitter hangs at all IMO\n\t\t * changed KERN_DEBUG to KERN_WARNING to find out if this is \n\t\t * ever called   --KG\n\t\t */\n\t}\n\tndev->trans_start = jiffies;\n\tnetif_wake_queue(ndev);\n}\n\n/*\n * Try sending a packet.\n * If this interface isn't connected to a ISDN-Channel, find a free channel,\n * and start dialing.\n */\nstatic netdev_tx_t\nisdn_net_start_xmit(struct sk_buff *skb, struct net_device *ndev)\n{\n\tisdn_net_local *lp = netdev_priv(ndev);\n#ifdef CONFIG_ISDN_X25\n\tstruct concap_proto * cprot = lp -> netdev -> cprot;\n/* At this point hard_start_xmit() passes control to the encapsulation\n   protocol (if present).\n   For X.25 auto-dialing is completly bypassed because:\n   - It does not conform with the semantics of a reliable datalink\n     service as needed by X.25 PLP.\n   - I don't want that the interface starts dialing when the network layer\n     sends a message which requests to disconnect the lapb link (or if it\n     sends any other message not resulting in data transmission).\n   Instead, dialing will be initiated by the encapsulation protocol entity\n   when a dl_establish request is received from the upper layer.\n*/\n\tif (cprot && cprot -> pops) {\n\t\tint ret = cprot -> pops -> encap_and_xmit ( cprot , skb);\n\n\t\tif (ret)\n\t\t\tnetif_stop_queue(ndev);\n\t\treturn ret;\n\t} else\n#endif\n\t/* auto-dialing xmit function */\n\t{\n#ifdef ISDN_DEBUG_NET_DUMP\n\t\tu_char *buf;\n#endif\n\t\tisdn_net_adjust_hdr(skb, ndev);\n#ifdef ISDN_DEBUG_NET_DUMP\n\t\tbuf = skb->data;\n\t\tisdn_dumppkt(\"S:\", buf, skb->len, 40);\n#endif\n\n\t\tif (!(lp->flags & ISDN_NET_CONNECTED)) {\n\t\t\tint chi;\n\t\t\t/* only do autodial if allowed by config */\n\t\t\tif (!(ISDN_NET_DIALMODE(*lp) == ISDN_NET_DM_AUTO)) {\n\t\t\t\tisdn_net_unreachable(ndev, skb, \"dial rejected: interface not in dialmode `auto'\");\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\treturn NETDEV_TX_OK;\n\t\t\t}\n\t\t\tif (lp->phone[1]) {\n\t\t\t\tulong flags;\n\n\t\t\t\tif(lp->dialwait_timer <= 0)\n\t\t\t\t\tif(lp->dialstarted > 0 && lp->dialtimeout > 0 && time_before(jiffies, lp->dialstarted + lp->dialtimeout + lp->dialwait))\n\t\t\t\t\t\tlp->dialwait_timer = lp->dialstarted + lp->dialtimeout + lp->dialwait;\n\n\t\t\t\tif(lp->dialwait_timer > 0) {\n\t\t\t\t\tif(time_before(jiffies, lp->dialwait_timer)) {\n\t\t\t\t\t\tisdn_net_unreachable(ndev, skb, \"dial rejected: retry-time not reached\");\n\t\t\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\t\t\treturn NETDEV_TX_OK;\n\t\t\t\t\t} else\n\t\t\t\t\t\tlp->dialwait_timer = 0;\n\t\t\t\t}\n\t\t\t\t/* Grab a free ISDN-Channel */\n\t\t\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\t\t\tif (((chi =\n\t\t\t\t     isdn_get_free_channel(\n\t\t\t\t\t \t\tISDN_USAGE_NET,\n\t\t\t\t\t\t\tlp->l2_proto,\n\t\t\t\t\t\t\tlp->l3_proto,\n\t\t\t\t\t\t\tlp->pre_device,\n\t\t\t\t\t\t \tlp->pre_channel,\n\t\t\t\t\t\t\tlp->msn)\n\t\t\t\t\t\t\t) < 0) &&\n\t\t\t\t\t((chi =\n\t\t\t\t     isdn_get_free_channel(\n\t\t\t\t\t \t\tISDN_USAGE_NET,\n\t\t\t\t\t\t\tlp->l2_proto,\n\t\t\t\t\t\t\tlp->l3_proto,\n\t\t\t\t\t\t\tlp->pre_device,\n\t\t\t\t\t\t\tlp->pre_channel^1,\n\t\t\t\t\t\t\tlp->msn)\n\t\t\t\t\t\t\t) < 0)) {\n\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\tisdn_net_unreachable(ndev, skb,\n\t\t\t\t\t\t\t   \"No channel\");\n\t\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\t\treturn NETDEV_TX_OK;\n\t\t\t\t}\n\t\t\t\t/* Log packet, which triggered dialing */\n\t\t\t\tif (dev->net_verbose)\n\t\t\t\t\tisdn_net_log_skb(skb, lp);\n\t\t\t\tlp->dialstate = 1;\n\t\t\t\t/* Connect interface with channel */\n\t\t\t\tisdn_net_bind_channel(lp, chi);\n#ifdef CONFIG_ISDN_PPP\n\t\t\t\tif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP) {\n\t\t\t\t\t/* no 'first_skb' handling for syncPPP */\n\t\t\t\t\tif (isdn_ppp_bind(lp) < 0) {\n\t\t\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\t\t\tisdn_net_unbind_channel(lp);\n\t\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\t\treturn NETDEV_TX_OK;\t/* STN (skb to nirvana) ;) */\n\t\t\t\t\t}\n#ifdef CONFIG_IPPP_FILTER\n\t\t\t\t\tif (isdn_ppp_autodial_filter(skb, lp)) {\n\t\t\t\t\t\tisdn_ppp_free(lp);\n\t\t\t\t\t\tisdn_net_unbind_channel(lp);\n\t\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\t\tisdn_net_unreachable(ndev, skb, \"dial rejected: packet filtered\");\n\t\t\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\t\t\treturn NETDEV_TX_OK;\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\tisdn_net_dial();\t/* Initiate dialing */\n\t\t\t\t\tnetif_stop_queue(ndev);\n\t\t\t\t\treturn NETDEV_TX_BUSY;\t/* let upper layer requeue skb packet */\n\t\t\t\t}\n#endif\n\t\t\t\t/* Initiate dialing */\n\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\tisdn_net_dial();\n\t\t\t\tisdn_net_device_stop_queue(lp);\n\t\t\t\treturn NETDEV_TX_BUSY;\n\t\t\t} else {\n\t\t\t\tisdn_net_unreachable(ndev, skb,\n\t\t\t\t\t\t     \"No phone number\");\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\treturn NETDEV_TX_OK;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Device is connected to an ISDN channel */ \n\t\t\tndev->trans_start = jiffies;\n\t\t\tif (!lp->dialstate) {\n\t\t\t\t/* ISDN connection is established, try sending */\n\t\t\t\tint ret;\n\t\t\t\tret = (isdn_net_xmit(ndev, skb));\n\t\t\t\tif(ret) netif_stop_queue(ndev);\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\tnetif_stop_queue(ndev);\n\t\t}\n\t}\n\treturn NETDEV_TX_BUSY;\n}\n\n/*\n * Shutdown a net-interface.\n */\nstatic int\nisdn_net_close(struct net_device *dev)\n{\n\tstruct net_device *p;\n#ifdef CONFIG_ISDN_X25\n\tstruct concap_proto * cprot =\n\t\t((isdn_net_local *) netdev_priv(dev))->netdev->cprot;\n\t/* printk(KERN_DEBUG \"isdn_net_close %s\\n\" , dev-> name ); */\n#endif\n\n#ifdef CONFIG_ISDN_X25\n\tif( cprot && cprot -> pops ) cprot -> pops -> close( cprot );\n#endif\n\tnetif_stop_queue(dev);\n\tp = MASTER_TO_SLAVE(dev);\n\tif (p) {\n\t\t/* If this interface has slaves, stop them also */\n\t\twhile (p) {\n#ifdef CONFIG_ISDN_X25\n\t\t\tcprot = ((isdn_net_local *) netdev_priv(p))\n\t\t\t\t-> netdev -> cprot;\n\t\t\tif( cprot && cprot -> pops )\n\t\t\t\tcprot -> pops -> close( cprot );\n#endif\n\t\t\tisdn_net_hangup(p);\n\t\t\tp = MASTER_TO_SLAVE(p);\n\t\t}\n\t}\n\tisdn_net_hangup(dev);\n\tisdn_unlock_drivers();\n\treturn 0;\n}\n\n/*\n * Get statistics\n */\nstatic struct net_device_stats *\nisdn_net_get_stats(struct net_device *dev)\n{\n\tisdn_net_local *lp = netdev_priv(dev);\n\treturn &lp->stats;\n}\n\n/*      This is simply a copy from std. eth.c EXCEPT we pull ETH_HLEN\n *      instead of dev->hard_header_len off. This is done because the\n *      lowlevel-driver has already pulled off its stuff when we get\n *      here and this routine only gets called with p_encap == ETHER.\n *      Determine the packet's protocol ID. The rule here is that we\n *      assume 802.3 if the type field is short enough to be a length.\n *      This is normal practice and works for any 'now in use' protocol.\n */\n\nstatic __be16\nisdn_net_type_trans(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ethhdr *eth;\n\tunsigned char *rawp;\n\n\tskb_reset_mac_header(skb);\n\tskb_pull(skb, ETH_HLEN);\n\teth = eth_hdr(skb);\n\n\tif (*eth->h_dest & 1) {\n\t\tif (memcmp(eth->h_dest, dev->broadcast, ETH_ALEN) == 0)\n\t\t\tskb->pkt_type = PACKET_BROADCAST;\n\t\telse\n\t\t\tskb->pkt_type = PACKET_MULTICAST;\n\t}\n\t/*\n\t *      This ALLMULTI check should be redundant by 1.4\n\t *      so don't forget to remove it.\n\t */\n\n\telse if (dev->flags & (IFF_PROMISC /*| IFF_ALLMULTI*/)) {\n\t\tif (memcmp(eth->h_dest, dev->dev_addr, ETH_ALEN))\n\t\t\tskb->pkt_type = PACKET_OTHERHOST;\n\t}\n\tif (ntohs(eth->h_proto) >= 1536)\n\t\treturn eth->h_proto;\n\n\trawp = skb->data;\n\n\t/*\n\t *      This is a magic hack to spot IPX packets. Older Novell breaks\n\t *      the protocol design and runs IPX over 802.3 without an 802.2 LLC\n\t *      layer. We look for FFFF which isn't a used 802.2 SSAP/DSAP. This\n\t *      won't work for fault tolerant netware but does for the rest.\n\t */\n\tif (*(unsigned short *) rawp == 0xFFFF)\n\t\treturn htons(ETH_P_802_3);\n\t/*\n\t *      Real 802.2 LLC\n\t */\n\treturn htons(ETH_P_802_2);\n}\n\n\n/* \n * CISCO HDLC keepalive specific stuff\n */\nstatic struct sk_buff*\nisdn_net_ciscohdlck_alloc_skb(isdn_net_local *lp, int len)\n{\n\tunsigned short hl = dev->drv[lp->isdn_device]->interface->hl_hdrlen;\n\tstruct sk_buff *skb;\n\n\tskb = alloc_skb(hl + len, GFP_ATOMIC);\n\tif (skb)\n\t\tskb_reserve(skb, hl);\n\telse \n\t\tprintk(\"isdn out of mem at %s:%d!\\n\", __FILE__, __LINE__);\n\treturn skb;\n}\n\n/* cisco hdlck device private ioctls */\nstatic int\nisdn_ciscohdlck_dev_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tisdn_net_local *lp = netdev_priv(dev);\n\tunsigned long len = 0;\n\tunsigned long expires = 0;\n\tint tmp = 0;\n\tint period = lp->cisco_keepalive_period;\n\ts8 debserint = lp->cisco_debserint;\n\tint rc = 0;\n\n\tif (lp->p_encap != ISDN_NET_ENCAP_CISCOHDLCK)\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\t\t/* get/set keepalive period */\n\t\tcase SIOCGKEEPPERIOD:\n\t\t\tlen = (unsigned long)sizeof(lp->cisco_keepalive_period);\n\t\t\tif (copy_to_user(ifr->ifr_data,\n\t\t\t\t&lp->cisco_keepalive_period, len))\n\t\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\tcase SIOCSKEEPPERIOD:\n\t\t\ttmp = lp->cisco_keepalive_period;\n\t\t\tlen = (unsigned long)sizeof(lp->cisco_keepalive_period);\n\t\t\tif (copy_from_user(&period, ifr->ifr_data, len))\n\t\t\t\trc = -EFAULT;\n\t\t\tif ((period > 0) && (period <= 32767))\n\t\t\t\tlp->cisco_keepalive_period = period;\n\t\t\telse\n\t\t\t\trc = -EINVAL;\n\t\t\tif (!rc && (tmp != lp->cisco_keepalive_period)) {\n\t\t\t\texpires = (unsigned long)(jiffies +\n\t\t\t\t\tlp->cisco_keepalive_period * HZ);\n\t\t\t\tmod_timer(&lp->cisco_timer, expires);\n\t\t\t\tprintk(KERN_INFO \"%s: Keepalive period set \"\n\t\t\t\t\t\"to %d seconds.\\n\",\n\t\t\t\t\tdev->name, lp->cisco_keepalive_period);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t/* get/set debugging */\n\t\tcase SIOCGDEBSERINT:\n\t\t\tlen = (unsigned long)sizeof(lp->cisco_debserint);\n\t\t\tif (copy_to_user(ifr->ifr_data,\n\t\t\t\t&lp->cisco_debserint, len))\n\t\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\tcase SIOCSDEBSERINT:\n\t\t\tlen = (unsigned long)sizeof(lp->cisco_debserint);\n\t\t\tif (copy_from_user(&debserint,\n\t\t\t\tifr->ifr_data, len))\n\t\t\t\trc = -EFAULT;\n\t\t\tif ((debserint >= 0) && (debserint <= 64))\n\t\t\t\tlp->cisco_debserint = debserint;\n\t\t\telse\n\t\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t}\n\treturn (rc);\n}\n\n\nstatic int isdn_net_ioctl(struct net_device *dev,\n\t\t\t  struct ifreq *ifr, int cmd)\n{\n\tisdn_net_local *lp = netdev_priv(dev);\n\n\tswitch (lp->p_encap) {\n#ifdef CONFIG_ISDN_PPP\n\tcase ISDN_NET_ENCAP_SYNCPPP:\n\t\treturn isdn_ppp_dev_ioctl(dev, ifr, cmd);\n#endif\n\tcase ISDN_NET_ENCAP_CISCOHDLCK:\n\t\treturn isdn_ciscohdlck_dev_ioctl(dev, ifr, cmd);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n/* called via cisco_timer.function */\nstatic void\nisdn_net_ciscohdlck_slarp_send_keepalive(unsigned long data)\n{\n\tisdn_net_local *lp = (isdn_net_local *) data;\n\tstruct sk_buff *skb;\n\tunsigned char *p;\n\tunsigned long last_cisco_myseq = lp->cisco_myseq;\n\tint myseq_diff = 0;\n\n\tif (!(lp->flags & ISDN_NET_CONNECTED) || lp->dialstate) {\n\t\tprintk(\"isdn BUG at %s:%d!\\n\", __FILE__, __LINE__);\n\t\treturn;\n\t}\n\tlp->cisco_myseq++;\n\n\tmyseq_diff = (lp->cisco_myseq - lp->cisco_mineseen);\n\tif ((lp->cisco_line_state) && ((myseq_diff >= 3)||(myseq_diff <= -3))) {\n\t\t/* line up -> down */\n\t\tlp->cisco_line_state = 0;\n\t\tprintk (KERN_WARNING\n\t\t\t\t\"UPDOWN: Line protocol on Interface %s,\"\n\t\t\t\t\" changed state to down\\n\", lp->netdev->dev->name);\n\t\t/* should stop routing higher-level data across */\n\t} else if ((!lp->cisco_line_state) &&\n\t\t(myseq_diff >= 0) && (myseq_diff <= 2)) {\n\t\t/* line down -> up */\n\t\tlp->cisco_line_state = 1;\n\t\tprintk (KERN_WARNING\n\t\t\t\t\"UPDOWN: Line protocol on Interface %s,\"\n\t\t\t\t\" changed state to up\\n\", lp->netdev->dev->name);\n\t\t/* restart routing higher-level data across */\n\t}\n\n\tif (lp->cisco_debserint)\n\t\tprintk (KERN_DEBUG \"%s: HDLC \"\n\t\t\t\"myseq %lu, mineseen %lu%c, yourseen %lu, %s\\n\",\n\t\t\tlp->netdev->dev->name, last_cisco_myseq, lp->cisco_mineseen,\n\t\t\t((last_cisco_myseq == lp->cisco_mineseen) ? '*' : 040),\n\t\t\tlp->cisco_yourseq,\n\t\t\t((lp->cisco_line_state) ? \"line up\" : \"line down\"));\n\n\tskb = isdn_net_ciscohdlck_alloc_skb(lp, 4 + 14);\n\tif (!skb)\n\t\treturn;\n\n\tp = skb_put(skb, 4 + 14);\n\n\t/* cisco header */\n\t*(u8 *)(p + 0) = CISCO_ADDR_UNICAST;\n\t*(u8 *)(p + 1) = CISCO_CTRL;\n\t*(__be16 *)(p + 2) = cpu_to_be16(CISCO_TYPE_SLARP);\n\n\t/* slarp keepalive */\n\t*(__be32 *)(p +  4) = cpu_to_be32(CISCO_SLARP_KEEPALIVE);\n\t*(__be32 *)(p +  8) = cpu_to_be32(lp->cisco_myseq);\n\t*(__be32 *)(p + 12) = cpu_to_be32(lp->cisco_yourseq);\n\t*(__be16 *)(p + 16) = cpu_to_be16(0xffff); // reliability, always 0xffff\n\tp += 18;\n\n\tisdn_net_write_super(lp, skb);\n\n\tlp->cisco_timer.expires = jiffies + lp->cisco_keepalive_period * HZ;\n\t\n\tadd_timer(&lp->cisco_timer);\n}\n\nstatic void\nisdn_net_ciscohdlck_slarp_send_request(isdn_net_local *lp)\n{\n\tstruct sk_buff *skb;\n\tunsigned char *p;\n\n\tskb = isdn_net_ciscohdlck_alloc_skb(lp, 4 + 14);\n\tif (!skb)\n\t\treturn;\n\n\tp = skb_put(skb, 4 + 14);\n\n\t/* cisco header */\n\t*(u8 *)(p + 0) = CISCO_ADDR_UNICAST;\n\t*(u8 *)(p + 1) = CISCO_CTRL;\n\t*(__be16 *)(p + 2) = cpu_to_be16(CISCO_TYPE_SLARP);\n\n\t/* slarp request */\n\t*(__be32 *)(p +  4) = cpu_to_be32(CISCO_SLARP_REQUEST);\n\t*(__be32 *)(p +  8) = cpu_to_be32(0); // address\n\t*(__be32 *)(p + 12) = cpu_to_be32(0); // netmask\n\t*(__be16 *)(p + 16) = cpu_to_be16(0); // unused\n\tp += 18;\n\n\tisdn_net_write_super(lp, skb);\n}\n\nstatic void \nisdn_net_ciscohdlck_connected(isdn_net_local *lp)\n{\n\tlp->cisco_myseq = 0;\n\tlp->cisco_mineseen = 0;\n\tlp->cisco_yourseq = 0;\n\tlp->cisco_keepalive_period = ISDN_TIMER_KEEPINT;\n\tlp->cisco_last_slarp_in = 0;\n\tlp->cisco_line_state = 0;\n\tlp->cisco_debserint = 0;\n\n\t/* send slarp request because interface/seq.no.s reset */\n\tisdn_net_ciscohdlck_slarp_send_request(lp);\n\n\tinit_timer(&lp->cisco_timer);\n\tlp->cisco_timer.data = (unsigned long) lp;\n\tlp->cisco_timer.function = isdn_net_ciscohdlck_slarp_send_keepalive;\n\tlp->cisco_timer.expires = jiffies + lp->cisco_keepalive_period * HZ;\n\tadd_timer(&lp->cisco_timer);\n}\n\nstatic void \nisdn_net_ciscohdlck_disconnected(isdn_net_local *lp)\n{\n\tdel_timer(&lp->cisco_timer);\n}\n\nstatic void\nisdn_net_ciscohdlck_slarp_send_reply(isdn_net_local *lp)\n{\n\tstruct sk_buff *skb;\n\tunsigned char *p;\n\tstruct in_device *in_dev = NULL;\n\t__be32 addr = 0;\t\t/* local ipv4 address */\n\t__be32 mask = 0;\t\t/* local netmask */\n\n\tif ((in_dev = lp->netdev->dev->ip_ptr) != NULL) {\n\t\t/* take primary(first) address of interface */\n\t\tstruct in_ifaddr *ifa = in_dev->ifa_list;\n\t\tif (ifa != NULL) {\n\t\t\taddr = ifa->ifa_local;\n\t\t\tmask = ifa->ifa_mask;\n\t\t}\n\t}\n\n\tskb = isdn_net_ciscohdlck_alloc_skb(lp, 4 + 14);\n\tif (!skb)\n\t\treturn;\n\n\tp = skb_put(skb, 4 + 14);\n\n\t/* cisco header */\n\t*(u8 *)(p + 0) = CISCO_ADDR_UNICAST;\n\t*(u8 *)(p + 1) = CISCO_CTRL;\n\t*(__be16 *)(p + 2) = cpu_to_be16(CISCO_TYPE_SLARP);\n\n\t/* slarp reply, send own ip/netmask; if values are nonsense remote\n\t * should think we are unable to provide it with an address via SLARP */\n\t*(__be32 *)(p +  4) = cpu_to_be32(CISCO_SLARP_REPLY);\n\t*(__be32 *)(p +  8) = addr; // address\n\t*(__be32 *)(p + 12) = mask; // netmask\n\t*(__be16 *)(p + 16) = cpu_to_be16(0); // unused\n\tp += 18;\n\n\tisdn_net_write_super(lp, skb);\n}\n\nstatic void\nisdn_net_ciscohdlck_slarp_in(isdn_net_local *lp, struct sk_buff *skb)\n{\n\tunsigned char *p;\n\tint period;\n\tu32 code;\n\tu32 my_seq;\n\tu32 your_seq;\n\t__be32 local;\n\t__be32 *addr, *mask;\n\n\tif (skb->len < 14)\n\t\treturn;\n\n\tp = skb->data;\n\tcode = be32_to_cpup((__be32 *)p);\n\tp += 4;\n\n\tswitch (code) {\n\tcase CISCO_SLARP_REQUEST:\n\t\tlp->cisco_yourseq = 0;\n\t\tisdn_net_ciscohdlck_slarp_send_reply(lp);\n\t\tbreak;\n\tcase CISCO_SLARP_REPLY:\n\t\taddr = (__be32 *)p;\n\t\tmask = (__be32 *)(p + 4);\n\t\tif (*mask != cpu_to_be32(0xfffffffc))\n\t\t\tgoto slarp_reply_out;\n\t\tif ((*addr & cpu_to_be32(3)) == cpu_to_be32(0) ||\n\t\t    (*addr & cpu_to_be32(3)) == cpu_to_be32(3))\n\t\t\tgoto slarp_reply_out;\n\t\tlocal = *addr ^ cpu_to_be32(3);\n\t\tprintk(KERN_INFO \"%s: got slarp reply: remote ip: %pI4, local ip: %pI4 mask: %pI4\\n\",\n\t\t       lp->netdev->dev->name, addr, &local, mask);\n\t\tbreak;\n  slarp_reply_out:\n\t\tprintk(KERN_INFO \"%s: got invalid slarp reply (%pI4/%pI4) - ignored\\n\",\n\t\t       lp->netdev->dev->name, addr, mask);\n\t\tbreak;\n\tcase CISCO_SLARP_KEEPALIVE:\n\t\tperiod = (int)((jiffies - lp->cisco_last_slarp_in\n\t\t\t\t+ HZ/2 - 1) / HZ);\n\t\tif (lp->cisco_debserint &&\n\t\t\t\t(period != lp->cisco_keepalive_period) &&\n\t\t\t\tlp->cisco_last_slarp_in) {\n\t\t\tprintk(KERN_DEBUG \"%s: Keepalive period mismatch - \"\n\t\t\t\t\"is %d but should be %d.\\n\",\n\t\t\t\tlp->netdev->dev->name, period,\n\t\t\t\tlp->cisco_keepalive_period);\n\t\t}\n\t\tlp->cisco_last_slarp_in = jiffies;\n\t\tmy_seq = be32_to_cpup((__be32 *)(p + 0));\n\t\tyour_seq = be32_to_cpup((__be32 *)(p + 4));\n\t\tp += 10;\n\t\tlp->cisco_yourseq = my_seq;\n\t\tlp->cisco_mineseen = your_seq;\n\t\tbreak;\n\t}\n}\n\nstatic void\nisdn_net_ciscohdlck_receive(isdn_net_local *lp, struct sk_buff *skb)\n{\n\tunsigned char *p;\n \tu8 addr;\n \tu8 ctrl;\n \tu16 type;\n\t\n\tif (skb->len < 4)\n\t\tgoto out_free;\n\n\tp = skb->data;\n\taddr = *(u8 *)(p + 0);\n\tctrl = *(u8 *)(p + 1);\n\ttype = be16_to_cpup((__be16 *)(p + 2));\n\tp += 4;\n\tskb_pull(skb, 4);\n\t\n\tif (addr != CISCO_ADDR_UNICAST && addr != CISCO_ADDR_BROADCAST) {\n\t\tprintk(KERN_WARNING \"%s: Unknown Cisco addr 0x%02x\\n\",\n\t\t       lp->netdev->dev->name, addr);\n\t\tgoto out_free;\n\t}\n\tif (ctrl != CISCO_CTRL) {\n\t\tprintk(KERN_WARNING \"%s: Unknown Cisco ctrl 0x%02x\\n\",\n\t\t       lp->netdev->dev->name, ctrl);\n\t\tgoto out_free;\n\t}\n\n\tswitch (type) {\n\tcase CISCO_TYPE_SLARP:\n\t\tisdn_net_ciscohdlck_slarp_in(lp, skb);\n\t\tgoto out_free;\n\tcase CISCO_TYPE_CDP:\n\t\tif (lp->cisco_debserint)\n\t\t\tprintk(KERN_DEBUG \"%s: Received CDP packet. use \"\n\t\t\t\t\"\\\"no cdp enable\\\" on cisco.\\n\",\n\t\t\t\tlp->netdev->dev->name);\n\t\tgoto out_free;\n\tdefault:\n\t\t/* no special cisco protocol */\n\t\tskb->protocol = htons(type);\n\t\tnetif_rx(skb);\n\t\treturn;\n\t}\n\n out_free:\n\tkfree_skb(skb);\n}\n\n/*\n * Got a packet from ISDN-Channel.\n */\nstatic void\nisdn_net_receive(struct net_device *ndev, struct sk_buff *skb)\n{\n\tisdn_net_local *lp = netdev_priv(ndev);\n\tisdn_net_local *olp = lp;\t/* original 'lp' */\n#ifdef CONFIG_ISDN_X25\n\tstruct concap_proto *cprot = lp -> netdev -> cprot;\n#endif\n\tlp->transcount += skb->len;\n\n\tlp->stats.rx_packets++;\n\tlp->stats.rx_bytes += skb->len;\n\tif (lp->master) {\n\t\t/* Bundling: If device is a slave-device, deliver to master, also\n\t\t * handle master's statistics and hangup-timeout\n\t\t */\n\t\tndev = lp->master;\n\t\tlp = netdev_priv(ndev);\n\t\tlp->stats.rx_packets++;\n\t\tlp->stats.rx_bytes += skb->len;\n\t}\n\tskb->dev = ndev;\n\tskb->pkt_type = PACKET_HOST;\n\tskb_reset_mac_header(skb);\n#ifdef ISDN_DEBUG_NET_DUMP\n\tisdn_dumppkt(\"R:\", skb->data, skb->len, 40);\n#endif\n\tswitch (lp->p_encap) {\n\t\tcase ISDN_NET_ENCAP_ETHER:\n\t\t\t/* Ethernet over ISDN */\n\t\t\tolp->huptimer = 0;\n\t\t\tlp->huptimer = 0;\n\t\t\tskb->protocol = isdn_net_type_trans(skb, ndev);\n\t\t\tbreak;\n\t\tcase ISDN_NET_ENCAP_UIHDLC:\n\t\t\t/* HDLC with UI-frame (for ispa with -h1 option) */\n\t\t\tolp->huptimer = 0;\n\t\t\tlp->huptimer = 0;\n\t\t\tskb_pull(skb, 2);\n\t\t\t/* Fall through */\n\t\tcase ISDN_NET_ENCAP_RAWIP:\n\t\t\t/* RAW-IP without MAC-Header */\n\t\t\tolp->huptimer = 0;\n\t\t\tlp->huptimer = 0;\n\t\t\tskb->protocol = htons(ETH_P_IP);\n\t\t\tbreak;\n\t\tcase ISDN_NET_ENCAP_CISCOHDLCK:\n\t\t\tisdn_net_ciscohdlck_receive(lp, skb);\n\t\t\treturn;\n\t\tcase ISDN_NET_ENCAP_CISCOHDLC:\n\t\t\t/* CISCO-HDLC IP with type field and  fake I-frame-header */\n\t\t\tskb_pull(skb, 2);\n\t\t\t/* Fall through */\n\t\tcase ISDN_NET_ENCAP_IPTYP:\n\t\t\t/* IP with type field */\n\t\t\tolp->huptimer = 0;\n\t\t\tlp->huptimer = 0;\n\t\t\tskb->protocol = *(__be16 *)&(skb->data[0]);\n\t\t\tskb_pull(skb, 2);\n\t\t\tif (*(unsigned short *) skb->data == 0xFFFF)\n\t\t\t\tskb->protocol = htons(ETH_P_802_3);\n\t\t\tbreak;\n#ifdef CONFIG_ISDN_PPP\n\t\tcase ISDN_NET_ENCAP_SYNCPPP:\n\t\t\t/* huptimer is done in isdn_ppp_push_higher */\n\t\t\tisdn_ppp_receive(lp->netdev, olp, skb);\n\t\t\treturn;\n#endif\n\n\t\tdefault:\n#ifdef CONFIG_ISDN_X25\n\t\t  /* try if there are generic sync_device receiver routines */\n\t\t\tif(cprot) if(cprot -> pops)\n\t\t\t\tif( cprot -> pops -> data_ind){\n\t\t\t\t\tcprot -> pops -> data_ind(cprot,skb);\n\t\t\t\t\treturn;\n\t\t\t\t};\n#endif /* CONFIG_ISDN_X25 */\n\t\t\tprintk(KERN_WARNING \"%s: unknown encapsulation, dropping\\n\",\n\t\t\t       lp->netdev->dev->name);\n\t\t\tkfree_skb(skb);\n\t\t\treturn;\n\t}\n\n\tnetif_rx(skb);\n\treturn;\n}\n\n/*\n * A packet arrived via ISDN. Search interface-chain for a corresponding\n * interface. If found, deliver packet to receiver-function and return 1,\n * else return 0.\n */\nint\nisdn_net_rcv_skb(int idx, struct sk_buff *skb)\n{\n\tisdn_net_dev *p = dev->rx_netdev[idx];\n\n\tif (p) {\n\t\tisdn_net_local *lp = p->local;\n\t\tif ((lp->flags & ISDN_NET_CONNECTED) &&\n\t\t    (!lp->dialstate)) {\n\t\t\tisdn_net_receive(p->dev, skb);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n *  build an header\n *  depends on encaps that is being used.\n */\n\nstatic int isdn_net_header(struct sk_buff *skb, struct net_device *dev,\n\t\t\t   unsigned short type,\n\t\t\t   const void *daddr, const void *saddr, unsigned plen)\n{\n\tisdn_net_local *lp = netdev_priv(dev);\n\tunsigned char *p;\n\tushort len = 0;\n\n\tswitch (lp->p_encap) {\n\t\tcase ISDN_NET_ENCAP_ETHER:\n\t\t\tlen = eth_header(skb, dev, type, daddr, saddr, plen);\n\t\t\tbreak;\n#ifdef CONFIG_ISDN_PPP\n\t\tcase ISDN_NET_ENCAP_SYNCPPP:\n\t\t\t/* stick on a fake header to keep fragmentation code happy. */\n\t\t\tlen = IPPP_MAX_HEADER;\n\t\t\tskb_push(skb,len);\n\t\t\tbreak;\n#endif\n\t\tcase ISDN_NET_ENCAP_RAWIP:\n\t\t\tprintk(KERN_WARNING \"isdn_net_header called with RAW_IP!\\n\");\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\tcase ISDN_NET_ENCAP_IPTYP:\n\t\t\t/* ethernet type field */\n\t\t\t*((__be16 *)skb_push(skb, 2)) = htons(type);\n\t\t\tlen = 2;\n\t\t\tbreak;\n\t\tcase ISDN_NET_ENCAP_UIHDLC:\n\t\t\t/* HDLC with UI-Frames (for ispa with -h1 option) */\n\t\t\t*((__be16 *)skb_push(skb, 2)) = htons(0x0103);\n\t\t\tlen = 2;\n\t\t\tbreak;\n\t\tcase ISDN_NET_ENCAP_CISCOHDLC:\n\t\tcase ISDN_NET_ENCAP_CISCOHDLCK:\n\t\t\tp = skb_push(skb, 4);\n\t\t\t*(u8 *)(p + 0) = CISCO_ADDR_UNICAST;\n\t\t\t*(u8 *)(p + 1) = CISCO_CTRL;\n\t\t\t*(__be16 *)(p + 2) = cpu_to_be16(type);\n\t\t\tp += 4;\n\t\t\tlen = 4;\n\t\t\tbreak;\n#ifdef CONFIG_ISDN_X25\n\t\tdefault:\n\t\t  /* try if there are generic concap protocol routines */\n\t\t\tif( lp-> netdev -> cprot ){\n\t\t\t\tprintk(KERN_WARNING \"isdn_net_header called with concap_proto!\\n\");\n\t\t\t\tlen = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n#endif /* CONFIG_ISDN_X25 */\n\t}\n\treturn len;\n}\n\n/* We don't need to send arp, because we have point-to-point connections. */\nstatic int\nisdn_net_rebuild_header(struct sk_buff *skb)\n{\n\tstruct net_device *dev = skb->dev;\n\tisdn_net_local *lp = netdev_priv(dev);\n\tint ret = 0;\n\n\tif (lp->p_encap == ISDN_NET_ENCAP_ETHER) {\n\t\tstruct ethhdr *eth = (struct ethhdr *) skb->data;\n\n\t\t/*\n\t\t *      Only ARP/IP is currently supported\n\t\t */\n\n\t\tif (eth->h_proto != htons(ETH_P_IP)) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"isdn_net: %s don't know how to resolve type %d addresses?\\n\",\n\t\t\t       dev->name, (int) eth->h_proto);\n\t\t\tmemcpy(eth->h_source, dev->dev_addr, dev->addr_len);\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t *      Try to get ARP to resolve the header.\n\t\t */\n#ifdef CONFIG_INET\n\t\tret = arp_find(eth->h_dest, skb);\n#endif\n\t}\n\treturn ret;\n}\n\nstatic int isdn_header_cache(const struct neighbour *neigh, struct hh_cache *hh,\n\t\t\t     __be16 type)\n{\n\tconst struct net_device *dev = neigh->dev;\n\tisdn_net_local *lp = netdev_priv(dev);\n\n\tif (lp->p_encap == ISDN_NET_ENCAP_ETHER)\n\t\treturn eth_header_cache(neigh, hh, type);\n\treturn -1;\n}\n\nstatic void isdn_header_cache_update(struct hh_cache *hh,\n\t\t\t\t     const struct net_device *dev,\n\t\t\t\t     const unsigned char *haddr)\n{\n\tisdn_net_local *lp = netdev_priv(dev);\n\tif (lp->p_encap == ISDN_NET_ENCAP_ETHER)\n\t\teth_header_cache_update(hh, dev, haddr);\n}\n\nstatic const struct header_ops isdn_header_ops = {\n\t.create = isdn_net_header,\n\t.rebuild = isdn_net_rebuild_header,\n\t.cache = isdn_header_cache,\n\t.cache_update = isdn_header_cache_update,\n};\n\n/*\n * Interface-setup. (just after registering a new interface)\n */\nstatic int\nisdn_net_init(struct net_device *ndev)\n{\n\tushort max_hlhdr_len = 0;\n\tint drvidx;\n\n\t/*\n\t *  up till binding we ask the protocol layer to reserve as much\n\t *  as we might need for HL layer\n\t */\n\n\tfor (drvidx = 0; drvidx < ISDN_MAX_DRIVERS; drvidx++)\n\t\tif (dev->drv[drvidx])\n\t\t\tif (max_hlhdr_len < dev->drv[drvidx]->interface->hl_hdrlen)\n\t\t\t\tmax_hlhdr_len = dev->drv[drvidx]->interface->hl_hdrlen;\n\n\tndev->hard_header_len = ETH_HLEN + max_hlhdr_len;\n\treturn 0;\n}\n\nstatic void\nisdn_net_swapbind(int drvidx)\n{\n\tisdn_net_dev *p;\n\n#ifdef ISDN_DEBUG_NET_ICALL\n\tprintk(KERN_DEBUG \"n_fi: swapping ch of %d\\n\", drvidx);\n#endif\n\tp = dev->netdev;\n\twhile (p) {\n\t\tif (p->local->pre_device == drvidx)\n\t\t\tswitch (p->local->pre_channel) {\n\t\t\t\tcase 0:\n\t\t\t\t\tp->local->pre_channel = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tp->local->pre_channel = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\tp = (isdn_net_dev *) p->next;\n\t}\n}\n\nstatic void\nisdn_net_swap_usage(int i1, int i2)\n{\n\tint u1 = dev->usage[i1] & ISDN_USAGE_EXCLUSIVE;\n\tint u2 = dev->usage[i2] & ISDN_USAGE_EXCLUSIVE;\n\n#ifdef ISDN_DEBUG_NET_ICALL\n\tprintk(KERN_DEBUG \"n_fi: usage of %d and %d\\n\", i1, i2);\n#endif\n\tdev->usage[i1] &= ~ISDN_USAGE_EXCLUSIVE;\n\tdev->usage[i1] |= u2;\n\tdev->usage[i2] &= ~ISDN_USAGE_EXCLUSIVE;\n\tdev->usage[i2] |= u1;\n\tisdn_info_update();\n}\n\n/*\n * An incoming call-request has arrived.\n * Search the interface-chain for an appropriate interface.\n * If found, connect the interface to the ISDN-channel and initiate\n * D- and B-Channel-setup. If secure-flag is set, accept only\n * configured phone-numbers. If callback-flag is set, initiate\n * callback-dialing.\n *\n * Return-Value: 0 = No appropriate interface for this call.\n *               1 = Call accepted\n *               2 = Reject call, wait cbdelay, then call back\n *               3 = Reject call\n *               4 = Wait cbdelay, then call back\n *               5 = No appropriate interface for this call,\n *                   would eventually match if CID was longer.\n */\n\nint\nisdn_net_find_icall(int di, int ch, int idx, setup_parm *setup)\n{\n\tchar *eaz;\n\tint si1;\n\tint si2;\n\tint ematch;\n\tint wret;\n\tint swapped;\n\tint sidx = 0;\n\tu_long flags;\n\tisdn_net_dev *p;\n\tisdn_net_phone *n;\n\tchar nr[ISDN_MSNLEN];\n\tchar *my_eaz;\n\n\t/* Search name in netdev-chain */\n\tif (!setup->phone[0]) {\n\t\tnr[0] = '0';\n\t\tnr[1] = '\\0';\n\t\tprintk(KERN_INFO \"isdn_net: Incoming call without OAD, assuming '0'\\n\");\n\t} else\n\t\tstrlcpy(nr, setup->phone, ISDN_MSNLEN);\n\tsi1 = (int) setup->si1;\n\tsi2 = (int) setup->si2;\n\tif (!setup->eazmsn[0]) {\n\t\tprintk(KERN_WARNING \"isdn_net: Incoming call without CPN, assuming '0'\\n\");\n\t\teaz = \"0\";\n\t} else\n\t\teaz = setup->eazmsn;\n\tif (dev->net_verbose > 1)\n\t\tprintk(KERN_INFO \"isdn_net: call from %s,%d,%d -> %s\\n\", nr, si1, si2, eaz);\n\t/* Accept DATA and VOICE calls at this stage\n\t * local eaz is checked later for allowed call types\n\t */\n\tif ((si1 != 7) && (si1 != 1)) {\n\t\tif (dev->net_verbose > 1)\n\t\t\tprintk(KERN_INFO \"isdn_net: Service-Indicator not 1 or 7, ignored\\n\");\n\t\treturn 0;\n\t}\n\tn = (isdn_net_phone *) 0;\n\tp = dev->netdev;\n\tematch = wret = swapped = 0;\n#ifdef ISDN_DEBUG_NET_ICALL\n\tprintk(KERN_DEBUG \"n_fi: di=%d ch=%d idx=%d usg=%d\\n\", di, ch, idx,\n\t\tdev->usage[idx]);\n#endif\n\twhile (p) {\n\t\tint matchret;\n\t\tisdn_net_local *lp = p->local;\n\n\t\t/* If last check has triggered as binding-swap, revert it */\n\t\tswitch (swapped) {\n\t\t\tcase 2:\n\t\t\t\tisdn_net_swap_usage(idx, sidx);\n\t\t\t\t/* fall through */\n\t\t\tcase 1:\n\t\t\t\tisdn_net_swapbind(di);\n\t\t\t\tbreak;\n\t\t}\n\t\tswapped = 0;\n                /* check acceptable call types for DOV */\n                my_eaz = isdn_map_eaz2msn(lp->msn, di);\n                if (si1 == 1) { /* it's a DOV call, check if we allow it */\n                        if (*my_eaz == 'v' || *my_eaz == 'V' ||\n\t\t\t    *my_eaz == 'b' || *my_eaz == 'B')\n                                my_eaz++; /* skip to allow a match */\n                        else\n                                my_eaz = NULL; /* force non match */\n                } else { /* it's a DATA call, check if we allow it */\n                        if (*my_eaz == 'b' || *my_eaz == 'B')\n                                my_eaz++; /* skip to allow a match */\n                }\n                if (my_eaz)\n                        matchret = isdn_msncmp(eaz, my_eaz);\n                else\n                        matchret = 1;\n                if (!matchret)\n                        ematch = 1;\n\n\t\t/* Remember if more numbers eventually can match */\n\t\tif (matchret > wret)\n\t\t\twret = matchret;\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\tprintk(KERN_DEBUG \"n_fi: if='%s', l.msn=%s, l.flags=%d, l.dstate=%d\\n\",\n\t\t       p->dev->name, lp->msn, lp->flags, lp->dialstate);\n#endif\n\t\tif ((!matchret) &&                                        /* EAZ is matching   */\n\t\t    (((!(lp->flags & ISDN_NET_CONNECTED)) &&              /* but not connected */\n\t\t      (USG_NONE(dev->usage[idx]))) ||                     /* and ch. unused or */\n\t\t     ((((lp->dialstate == 4) || (lp->dialstate == 12)) && /* if dialing        */\n\t\t       (!(lp->flags & ISDN_NET_CALLBACK)))                /* but no callback   */\n\t\t     )))\n\t\t\t {\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\tprintk(KERN_DEBUG \"n_fi: match1, pdev=%d pch=%d\\n\",\n\t\t\t       lp->pre_device, lp->pre_channel);\n#endif\n\t\t\tif (dev->usage[idx] & ISDN_USAGE_EXCLUSIVE) {\n\t\t\t\tif ((lp->pre_channel != ch) ||\n\t\t\t\t    (lp->pre_device != di)) {\n\t\t\t\t\t/* Here we got a problem:\n\t\t\t\t\t * If using an ICN-Card, an incoming call is always signaled on\n\t\t\t\t\t * on the first channel of the card, if both channels are\n\t\t\t\t\t * down. However this channel may be bound exclusive. If the\n\t\t\t\t\t * second channel is free, this call should be accepted.\n\t\t\t\t\t * The solution is horribly but it runs, so what:\n\t\t\t\t\t * We exchange the exclusive bindings of the two channels, the\n\t\t\t\t\t * corresponding variables in the interface-structs.\n\t\t\t\t\t */\n\t\t\t\t\tif (ch == 0) {\n\t\t\t\t\t\tsidx = isdn_dc2minor(di, 1);\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\t\t\tprintk(KERN_DEBUG \"n_fi: ch is 0\\n\");\n#endif\n\t\t\t\t\t\tif (USG_NONE(dev->usage[sidx])) {\n\t\t\t\t\t\t\t/* Second Channel is free, now see if it is bound\n\t\t\t\t\t\t\t * exclusive too. */\n\t\t\t\t\t\t\tif (dev->usage[sidx] & ISDN_USAGE_EXCLUSIVE) {\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\t\t\t\t\tprintk(KERN_DEBUG \"n_fi: 2nd channel is down and bound\\n\");\n#endif\n\t\t\t\t\t\t\t\t/* Yes, swap bindings only, if the original\n\t\t\t\t\t\t\t\t * binding is bound to channel 1 of this driver */\n\t\t\t\t\t\t\t\tif ((lp->pre_device == di) &&\n\t\t\t\t\t\t\t\t    (lp->pre_channel == 1)) {\n\t\t\t\t\t\t\t\t\tisdn_net_swapbind(di);\n\t\t\t\t\t\t\t\t\tswapped = 1;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t/* ... else iterate next device */\n\t\t\t\t\t\t\t\t\tp = (isdn_net_dev *) p->next;\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\t\t\t\t\tprintk(KERN_DEBUG \"n_fi: 2nd channel is down and unbound\\n\");\n#endif\n\t\t\t\t\t\t\t\t/* No, swap always and swap excl-usage also */\n\t\t\t\t\t\t\t\tisdn_net_swap_usage(idx, sidx);\n\t\t\t\t\t\t\t\tisdn_net_swapbind(di);\n\t\t\t\t\t\t\t\tswapped = 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/* Now check for exclusive binding again */\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\t\t\t\tprintk(KERN_DEBUG \"n_fi: final check\\n\");\n#endif\n\t\t\t\t\t\t\tif ((dev->usage[idx] & ISDN_USAGE_EXCLUSIVE) &&\n\t\t\t\t\t\t\t    ((lp->pre_channel != ch) ||\n\t\t\t\t\t\t\t     (lp->pre_device != di))) {\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\t\t\t\t\tprintk(KERN_DEBUG \"n_fi: final check failed\\n\");\n#endif\n\t\t\t\t\t\t\t\tp = (isdn_net_dev *) p->next;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* We are already on the second channel, so nothing to do */\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\t\t\tprintk(KERN_DEBUG \"n_fi: already on 2nd channel\\n\");\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\tprintk(KERN_DEBUG \"n_fi: match2\\n\");\n#endif\n\t\t\tn = lp->phone[0];\n\t\t\tif (lp->flags & ISDN_NET_SECURE) {\n\t\t\t\twhile (n) {\n\t\t\t\t\tif (!isdn_msncmp(nr, n->num))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tn = (isdn_net_phone *) n->next;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n || (!(lp->flags & ISDN_NET_SECURE))) {\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\tprintk(KERN_DEBUG \"n_fi: match3\\n\");\n#endif\n\t\t\t\t/* matching interface found */\n\n\t\t\t\t/*\n\t\t\t\t * Is the state STOPPED?\n\t\t\t\t * If so, no dialin is allowed,\n\t\t\t\t * so reject actively.\n\t\t\t\t * */\n\t\t\t\tif (ISDN_NET_DIALMODE(*lp) == ISDN_NET_DM_OFF) {\n\t\t\t\t\tprintk(KERN_INFO \"incoming call, interface %s `stopped' -> rejected\\n\",\n\t\t\t\t\t       p->dev->name);\n\t\t\t\t\treturn 3;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Is the interface up?\n\t\t\t\t * If not, reject the call actively.\n\t\t\t\t */\n\t\t\t\tif (!isdn_net_device_started(p)) {\n\t\t\t\t\tprintk(KERN_INFO \"%s: incoming call, interface down -> rejected\\n\",\n\t\t\t\t\t       p->dev->name);\n\t\t\t\t\treturn 3;\n\t\t\t\t}\n\t\t\t\t/* Interface is up, now see if it's a slave. If so, see if\n\t\t\t\t * it's master and parent slave is online. If not, reject the call.\n\t\t\t\t */\n\t\t\t\tif (lp->master) {\n\t\t\t\t\tisdn_net_local *mlp = ISDN_MASTER_PRIV(lp);\n\t\t\t\t\tprintk(KERN_DEBUG \"ICALLslv: %s\\n\", p->dev->name);\n\t\t\t\t\tprintk(KERN_DEBUG \"master=%s\\n\", lp->master->name);\n\t\t\t\t\tif (mlp->flags & ISDN_NET_CONNECTED) {\n\t\t\t\t\t\tprintk(KERN_DEBUG \"master online\\n\");\n\t\t\t\t\t\t/* Master is online, find parent-slave (master if first slave) */\n\t\t\t\t\t\twhile (mlp->slave) {\n\t\t\t\t\t\t\tif (ISDN_SLAVE_PRIV(mlp) == lp)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tmlp = ISDN_SLAVE_PRIV(mlp);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t\tprintk(KERN_DEBUG \"master offline\\n\");\n\t\t\t\t\t/* Found parent, if it's offline iterate next device */\n\t\t\t\t\tprintk(KERN_DEBUG \"mlpf: %d\\n\", mlp->flags & ISDN_NET_CONNECTED);\n\t\t\t\t\tif (!(mlp->flags & ISDN_NET_CONNECTED)) {\n\t\t\t\t\t\tp = (isdn_net_dev *) p->next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t\tif (lp->flags & ISDN_NET_CALLBACK) {\n\t\t\t\t\tint chi;\n\t\t\t\t\t/*\n\t\t\t\t\t * Is the state MANUAL?\n\t\t\t\t\t * If so, no callback can be made,\n\t\t\t\t\t * so reject actively.\n\t\t\t\t\t * */\n\t\t\t\t\tif (ISDN_NET_DIALMODE(*lp) == ISDN_NET_DM_OFF) {\n\t\t\t\t\t\tprintk(KERN_INFO \"incoming call for callback, interface %s `off' -> rejected\\n\",\n\t\t\t\t\t\t       p->dev->name);\n\t\t\t\t\t\treturn 3;\n\t\t\t\t\t}\n\t\t\t\t\tprintk(KERN_DEBUG \"%s: call from %s -> %s, start callback\\n\",\n\t\t\t\t\t       p->dev->name, nr, eaz);\n\t\t\t\t\tif (lp->phone[1]) {\n\t\t\t\t\t\t/* Grab a free ISDN-Channel */\n\t\t\t\t\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\t\t\t\t\tif ((chi = \n\t\t\t\t\t\t\tisdn_get_free_channel(\n\t\t\t\t\t\t\t\tISDN_USAGE_NET,\n\t\t\t\t\t\t\t\tlp->l2_proto,\n\t\t\t\t\t\t\t\tlp->l3_proto,\n\t\t\t\t\t\t\t  \tlp->pre_device,\n\t\t\t\t\t\t \t\tlp->pre_channel,\n\t\t\t\t\t\t \t\tlp->msn)\n\t\t\t\t\t\t\t\t) < 0) {\n\n\t\t\t\t\t\t\tprintk(KERN_WARNING \"isdn_net_find_icall: No channel for %s\\n\",\n\t\t\t\t\t\t\t\tp->dev->name);\n\t\t\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* Setup dialstate. */\n\t\t\t\t\t\tlp->dtimer = 0;\n\t\t\t\t\t\tlp->dialstate = 11;\n\t\t\t\t\t\t/* Connect interface with channel */\n\t\t\t\t\t\tisdn_net_bind_channel(lp, chi);\n#ifdef CONFIG_ISDN_PPP\n\t\t\t\t\t\tif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP)\n\t\t\t\t\t\t\tif (isdn_ppp_bind(lp) < 0) {\n\t\t\t\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\t\t\t\tisdn_net_unbind_channel(lp);\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\t\t/* Initiate dialing by returning 2 or 4 */\n\t\t\t\t\t\treturn (lp->flags & ISDN_NET_CBHUP) ? 2 : 4;\n\t\t\t\t\t} else\n\t\t\t\t\t\tprintk(KERN_WARNING \"isdn_net: %s: No phone number\\n\",\n\t\t\t\t\t\t\tp->dev->name);\n\t\t\t\t\treturn 0;\n\t\t\t\t} else {\n\t\t\t\t\tprintk(KERN_DEBUG \"%s: call from %s -> %s accepted\\n\",\n\t\t\t\t\t\tp->dev->name, nr, eaz);\n\t\t\t\t\t/* if this interface is dialing, it does it probably on a different\n\t\t\t\t\t   device, so free this device */\n\t\t\t\t\tif ((lp->dialstate == 4) || (lp->dialstate == 12)) {\n#ifdef CONFIG_ISDN_PPP\n\t\t\t\t\t\tif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP)\n\t\t\t\t\t\t\tisdn_ppp_free(lp);\n#endif\n\t\t\t\t\t\tisdn_net_lp_disconnected(lp);\n\t\t\t\t\t\tisdn_free_channel(lp->isdn_device, lp->isdn_channel,\n\t\t\t\t\t\t\t ISDN_USAGE_NET);\n\t\t\t\t\t}\n\t\t\t\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\t\t\t\tdev->usage[idx] &= ISDN_USAGE_EXCLUSIVE;\n\t\t\t\t\tdev->usage[idx] |= ISDN_USAGE_NET;\n\t\t\t\t\tstrcpy(dev->num[idx], nr);\n\t\t\t\t\tisdn_info_update();\n\t\t\t\t\tdev->st_netdev[idx] = lp->netdev;\n\t\t\t\t\tlp->isdn_device = di;\n\t\t\t\t\tlp->isdn_channel = ch;\n\t\t\t\t\tlp->ppp_slot = -1;\n\t\t\t\t\tlp->flags |= ISDN_NET_CONNECTED;\n\t\t\t\t\tlp->dialstate = 7;\n\t\t\t\t\tlp->dtimer = 0;\n\t\t\t\t\tlp->outgoing = 0;\n\t\t\t\t\tlp->huptimer = 0;\n\t\t\t\t\tlp->hupflags |= ISDN_WAITCHARGE;\n\t\t\t\t\tlp->hupflags &= ~ISDN_HAVECHARGE;\n#ifdef CONFIG_ISDN_PPP\n\t\t\t\t\tif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP) {\n\t\t\t\t\t\tif (isdn_ppp_bind(lp) < 0) {\n\t\t\t\t\t\t\tisdn_net_unbind_channel(lp);\n\t\t\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp = (isdn_net_dev *) p->next;\n\t}\n\t/* If none of configured EAZ/MSN matched and not verbose, be silent */\n\tif (!ematch || dev->net_verbose)\n\t\tprintk(KERN_INFO \"isdn_net: call from %s -> %d %s ignored\\n\", nr, di, eaz);\n\treturn (wret == 2)?5:0;\n}\n\n/*\n * Search list of net-interfaces for an interface with given name.\n */\nisdn_net_dev *\nisdn_net_findif(char *name)\n{\n\tisdn_net_dev *p = dev->netdev;\n\n\twhile (p) {\n\t\tif (!strcmp(p->dev->name, name))\n\t\t\treturn p;\n\t\tp = (isdn_net_dev *) p->next;\n\t}\n\treturn (isdn_net_dev *) NULL;\n}\n\n/*\n * Force a net-interface to dial out.\n * This is called from the userlevel-routine below or\n * from isdn_net_start_xmit().\n */\nstatic int\nisdn_net_force_dial_lp(isdn_net_local * lp)\n{\n\tif ((!(lp->flags & ISDN_NET_CONNECTED)) && !lp->dialstate) {\n\t\tint chi;\n\t\tif (lp->phone[1]) {\n\t\t\tulong flags;\n\n\t\t\t/* Grab a free ISDN-Channel */\n\t\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\t\tif ((chi = isdn_get_free_channel(\n\t\t\t\t\tISDN_USAGE_NET,\n\t\t\t\t\tlp->l2_proto,\n\t\t\t\t\tlp->l3_proto,\n\t\t\t\t\tlp->pre_device,\n\t\t\t\t\tlp->pre_channel,\n\t\t\t\t\tlp->msn)) < 0) {\n\t\t\t\tprintk(KERN_WARNING \"isdn_net_force_dial: No channel for %s\\n\",\n\t\t\t\t\tlp->netdev->dev->name);\n\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\t\t\tlp->dialstate = 1;\n\t\t\t/* Connect interface with channel */\n\t\t\tisdn_net_bind_channel(lp, chi);\n#ifdef CONFIG_ISDN_PPP\n\t\t\tif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP)\n\t\t\t\tif (isdn_ppp_bind(lp) < 0) {\n\t\t\t\t\tisdn_net_unbind_channel(lp);\n\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\treturn -EAGAIN;\n\t\t\t\t}\n#endif\n\t\t\t/* Initiate dialing */\n\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\tisdn_net_dial();\n\t\t\treturn 0;\n\t\t} else\n\t\t\treturn -EINVAL;\n\t} else\n\t\treturn -EBUSY;\n}\n\n/*\n * This is called from certain upper protocol layers (multilink ppp\n * and x25iface encapsulation module) that want to initiate dialing\n * themselves.\n */\nint\nisdn_net_dial_req(isdn_net_local * lp)\n{\n\t/* is there a better error code? */\n\tif (!(ISDN_NET_DIALMODE(*lp) == ISDN_NET_DM_AUTO)) return -EBUSY;\n\n\treturn isdn_net_force_dial_lp(lp);\n}\n\n/*\n * Force a net-interface to dial out.\n * This is always called from within userspace (ISDN_IOCTL_NET_DIAL).\n */\nint\nisdn_net_force_dial(char *name)\n{\n\tisdn_net_dev *p = isdn_net_findif(name);\n\n\tif (!p)\n\t\treturn -ENODEV;\n\treturn (isdn_net_force_dial_lp(p->local));\n}\n\n/* The ISDN-specific entries in the device structure. */\nstatic const struct net_device_ops isdn_netdev_ops = {\n\t.ndo_init\t      = isdn_net_init,\n\t.ndo_open\t      = isdn_net_open,\n\t.ndo_stop\t      = isdn_net_close,\n\t.ndo_do_ioctl\t      = isdn_net_ioctl,\n\n\t.ndo_start_xmit\t      = isdn_net_start_xmit,\n\t.ndo_get_stats\t      = isdn_net_get_stats,\n\t.ndo_tx_timeout\t      = isdn_net_tx_timeout,\n};\n\n/*\n * Helper for alloc_netdev()\n */\nstatic void _isdn_setup(struct net_device *dev)\n{\n\tisdn_net_local *lp = netdev_priv(dev);\n\n\tether_setup(dev);\n\n\t/* Setup the generic properties */\n\tdev->flags = IFF_NOARP|IFF_POINTOPOINT;\n\tdev->header_ops = NULL;\n\tdev->netdev_ops = &isdn_netdev_ops;\n\n\t/* for clients with MPPP maybe higher values better */\n\tdev->tx_queue_len = 30;\n\n\tlp->p_encap = ISDN_NET_ENCAP_RAWIP;\n\tlp->magic = ISDN_NET_MAGIC;\n\tlp->last = lp;\n\tlp->next = lp;\n\tlp->isdn_device = -1;\n\tlp->isdn_channel = -1;\n\tlp->pre_device = -1;\n\tlp->pre_channel = -1;\n\tlp->exclusive = -1;\n\tlp->ppp_slot = -1;\n\tlp->pppbind = -1;\n\tskb_queue_head_init(&lp->super_tx_queue);\n\tlp->l2_proto = ISDN_PROTO_L2_X75I;\n\tlp->l3_proto = ISDN_PROTO_L3_TRANS;\n\tlp->triggercps = 6000;\n\tlp->slavedelay = 10 * HZ;\n\tlp->hupflags = ISDN_INHUP;\t/* Do hangup even on incoming calls */\n\tlp->onhtime = 10;\t/* Default hangup-time for saving costs */\n\tlp->dialmax = 1;\n\t/* Hangup before Callback, manual dial */\n\tlp->flags = ISDN_NET_CBHUP | ISDN_NET_DM_MANUAL;\n\tlp->cbdelay = 25;\t/* Wait 5 secs before Callback */\n\tlp->dialtimeout = -1;  /* Infinite Dial-Timeout */\n\tlp->dialwait = 5 * HZ; /* Wait 5 sec. after failed dial */\n\tlp->dialstarted = 0;   /* Jiffies of last dial-start */\n\tlp->dialwait_timer = 0;  /* Jiffies of earliest next dial-start */\n}\n\n/*\n * Allocate a new network-interface and initialize its data structures.\n */\nchar *\nisdn_net_new(char *name, struct net_device *master)\n{\n\tisdn_net_dev *netdev;\n\n\t/* Avoid creating an existing interface */\n\tif (isdn_net_findif(name)) {\n\t\tprintk(KERN_WARNING \"isdn_net: interface %s already exists\\n\", name);\n\t\treturn NULL;\n\t}\n\tif (name == NULL)\n\t\treturn NULL;\n\tif (!(netdev = kzalloc(sizeof(isdn_net_dev), GFP_KERNEL))) {\n\t\tprintk(KERN_WARNING \"isdn_net: Could not allocate net-device\\n\");\n\t\treturn NULL;\n\t}\n\tnetdev->dev = alloc_netdev(sizeof(isdn_net_local), name, _isdn_setup);\n\tif (!netdev->dev) {\n\t\tprintk(KERN_WARNING \"isdn_net: Could not allocate network device\\n\");\n\t\tkfree(netdev);\n\t\treturn NULL;\n\t}\n\tnetdev->local = netdev_priv(netdev->dev);\n\n\tif (master) {\n\t\t/* Device shall be a slave */\n\t\tstruct net_device *p = MASTER_TO_SLAVE(master);\n\t\tstruct net_device *q = master;\n\n\t\tnetdev->local->master = master;\n\t\t/* Put device at end of slave-chain */\n\t\twhile (p) {\n\t\t\tq = p;\n\t\t\tp = MASTER_TO_SLAVE(p);\n\t\t}\n\t\tMASTER_TO_SLAVE(q) = netdev->dev;\n\t} else {\n\t\t/* Device shall be a master */\n\t\t/*\n\t\t * Watchdog timer (currently) for master only.\n\t\t */\n\t\tnetdev->dev->watchdog_timeo = ISDN_NET_TX_TIMEOUT;\n\t\tif (register_netdev(netdev->dev) != 0) {\n\t\t\tprintk(KERN_WARNING \"isdn_net: Could not register net-device\\n\");\n\t\t\tfree_netdev(netdev->dev);\n\t\t\tkfree(netdev);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tnetdev->queue = netdev->local;\n\tspin_lock_init(&netdev->queue_lock);\n\n\tnetdev->local->netdev = netdev;\n\n\tINIT_WORK(&netdev->local->tqueue, isdn_net_softint);\n\tspin_lock_init(&netdev->local->xmit_lock);\n\n\t/* Put into to netdev-chain */\n\tnetdev->next = (void *) dev->netdev;\n\tdev->netdev = netdev;\n\treturn netdev->dev->name;\n}\n\nchar *\nisdn_net_newslave(char *parm)\n{\n\tchar *p = strchr(parm, ',');\n\tisdn_net_dev *n;\n\tchar newname[10];\n\n\tif (p) {\n\t\t/* Slave-Name MUST not be empty */\n\t\tif (!strlen(p + 1))\n\t\t\treturn NULL;\n\t\tstrcpy(newname, p + 1);\n\t\t*p = 0;\n\t\t/* Master must already exist */\n\t\tif (!(n = isdn_net_findif(parm)))\n\t\t\treturn NULL;\n\t\t/* Master must be a real interface, not a slave */\n\t\tif (n->local->master)\n\t\t\treturn NULL;\n\t\t/* Master must not be started yet */\n\t\tif (isdn_net_device_started(n)) \n\t\t\treturn NULL;\n\t\treturn (isdn_net_new(newname, n->dev));\n\t}\n\treturn NULL;\n}\n\n/*\n * Set interface-parameters.\n * Always set all parameters, so the user-level application is responsible\n * for not overwriting existing setups. It has to get the current\n * setup first, if only selected parameters are to be changed.\n */\nint\nisdn_net_setcfg(isdn_net_ioctl_cfg * cfg)\n{\n\tisdn_net_dev *p = isdn_net_findif(cfg->name);\n\tulong features;\n\tint i;\n\tint drvidx;\n\tint chidx;\n\tchar drvid[25];\n\n\tif (p) {\n\t\tisdn_net_local *lp = p->local;\n\n\t\t/* See if any registered driver supports the features we want */\n\t\tfeatures = ((1 << cfg->l2_proto) << ISDN_FEATURE_L2_SHIFT) |\n\t\t\t((1 << cfg->l3_proto) << ISDN_FEATURE_L3_SHIFT);\n\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\tif (dev->drv[i])\n\t\t\t\tif ((dev->drv[i]->interface->features & features) == features)\n\t\t\t\t\tbreak;\n\t\tif (i == ISDN_MAX_DRIVERS) {\n\t\t\tprintk(KERN_WARNING \"isdn_net: No driver with selected features\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tif (lp->p_encap != cfg->p_encap){\n#ifdef CONFIG_ISDN_X25\n\t\t\tstruct concap_proto * cprot = p -> cprot;\n#endif\n\t\t\tif (isdn_net_device_started(p)) {\n\t\t\t\tprintk(KERN_WARNING \"%s: cannot change encap when if is up\\n\",\n\t\t\t\t       p->dev->name);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n#ifdef CONFIG_ISDN_X25\n\t\t\tif( cprot && cprot -> pops )\n\t\t\t\tcprot -> pops -> proto_del ( cprot );\n\t\t\tp -> cprot = NULL;\n\t\t\tlp -> dops = NULL;\n\t\t\t/* ... ,  prepare for configuration of new one ... */\n\t\t\tswitch ( cfg -> p_encap ){\n\t\t\tcase ISDN_NET_ENCAP_X25IFACE:\n\t\t\t\tlp -> dops = &isdn_concap_reliable_dl_dops;\n\t\t\t}\n\t\t\t/* ... and allocate new one ... */\n\t\t\tp -> cprot = isdn_concap_new( cfg -> p_encap );\n\t\t\t/* p -> cprot == NULL now if p_encap is not supported\n\t\t\t   by means of the concap_proto mechanism */\n\t\t\t/* the protocol is not configured yet; this will\n\t\t\t   happen later when isdn_net_reset() is called */\n#endif\n\t\t}\n\t\tswitch ( cfg->p_encap ) {\n\t\tcase ISDN_NET_ENCAP_SYNCPPP:\n#ifndef CONFIG_ISDN_PPP\n\t\t\tprintk(KERN_WARNING \"%s: SyncPPP support not configured\\n\",\n\t\t\t       p->dev->name);\n\t\t\treturn -EINVAL;\n#else\n\t\t\tp->dev->type = ARPHRD_PPP;\t/* change ARP type */\n\t\t\tp->dev->addr_len = 0;\n#endif\n\t\t\tbreak;\n\t\tcase ISDN_NET_ENCAP_X25IFACE:\n#ifndef CONFIG_ISDN_X25\n\t\t\tprintk(KERN_WARNING \"%s: isdn-x25 support not configured\\n\",\n\t\t\t       p->dev->name);\n\t\t\treturn -EINVAL;\n#else\n\t\t\tp->dev->type = ARPHRD_X25;\t/* change ARP type */\n\t\t\tp->dev->addr_len = 0;\n#endif\n\t\t\tbreak;\n\t\tcase ISDN_NET_ENCAP_CISCOHDLCK:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif( cfg->p_encap >= 0 &&\n\t\t\t    cfg->p_encap <= ISDN_NET_ENCAP_MAX_ENCAP )\n\t\t\t\tbreak;\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s: encapsulation protocol %d not supported\\n\",\n\t\t\t       p->dev->name, cfg->p_encap);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (strlen(cfg->drvid)) {\n\t\t\t/* A bind has been requested ... */\n\t\t\tchar *c,\n\t\t\t*e;\n\n\t\t\tdrvidx = -1;\n\t\t\tchidx = -1;\n\t\t\tstrcpy(drvid, cfg->drvid);\n\t\t\tif ((c = strchr(drvid, ','))) {\n\t\t\t\t/* The channel-number is appended to the driver-Id with a comma */\n\t\t\t\tchidx = (int) simple_strtoul(c + 1, &e, 10);\n\t\t\t\tif (e == c)\n\t\t\t\t\tchidx = -1;\n\t\t\t\t*c = '\\0';\n\t\t\t}\n\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t/* Lookup driver-Id in array */\n\t\t\t\tif (!(strcmp(dev->drvid[i], drvid))) {\n\t\t\t\t\tdrvidx = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif ((drvidx == -1) || (chidx == -1))\n\t\t\t\t/* Either driver-Id or channel-number invalid */\n\t\t\t\treturn -ENODEV;\n\t\t} else {\n\t\t\t/* Parameters are valid, so get them */\n\t\t\tdrvidx = lp->pre_device;\n\t\t\tchidx = lp->pre_channel;\n\t\t}\n\t\tif (cfg->exclusive > 0) {\n\t\t\tunsigned long flags;\n\n\t\t\t/* If binding is exclusive, try to grab the channel */\n\t\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\t\tif ((i = isdn_get_free_channel(ISDN_USAGE_NET,\n\t\t\t\tlp->l2_proto, lp->l3_proto, drvidx,\n\t\t\t\tchidx, lp->msn)) < 0) {\n\t\t\t\t/* Grab failed, because desired channel is in use */\n\t\t\t\tlp->exclusive = -1;\n\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t\t/* All went ok, so update isdninfo */\n\t\t\tdev->usage[i] = ISDN_USAGE_EXCLUSIVE;\n\t\t\tisdn_info_update();\n\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\tlp->exclusive = i;\n\t\t} else {\n\t\t\t/* Non-exclusive binding or unbind. */\n\t\t\tlp->exclusive = -1;\n\t\t\tif ((lp->pre_device != -1) && (cfg->exclusive == -1)) {\n\t\t\t\tisdn_unexclusive_channel(lp->pre_device, lp->pre_channel);\n\t\t\t\tisdn_free_channel(lp->pre_device, lp->pre_channel, ISDN_USAGE_NET);\n\t\t\t\tdrvidx = -1;\n\t\t\t\tchidx = -1;\n\t\t\t}\n\t\t}\n\t\tstrlcpy(lp->msn, cfg->eaz, sizeof(lp->msn));\n\t\tlp->pre_device = drvidx;\n\t\tlp->pre_channel = chidx;\n\t\tlp->onhtime = cfg->onhtime;\n\t\tlp->charge = cfg->charge;\n\t\tlp->l2_proto = cfg->l2_proto;\n\t\tlp->l3_proto = cfg->l3_proto;\n\t\tlp->cbdelay = cfg->cbdelay;\n\t\tlp->dialmax = cfg->dialmax;\n\t\tlp->triggercps = cfg->triggercps;\n\t\tlp->slavedelay = cfg->slavedelay * HZ;\n\t\tlp->pppbind = cfg->pppbind;\n\t\tlp->dialtimeout = cfg->dialtimeout >= 0 ? cfg->dialtimeout * HZ : -1;\n\t\tlp->dialwait = cfg->dialwait * HZ;\n\t\tif (cfg->secure)\n\t\t\tlp->flags |= ISDN_NET_SECURE;\n\t\telse\n\t\t\tlp->flags &= ~ISDN_NET_SECURE;\n\t\tif (cfg->cbhup)\n\t\t\tlp->flags |= ISDN_NET_CBHUP;\n\t\telse\n\t\t\tlp->flags &= ~ISDN_NET_CBHUP;\n\t\tswitch (cfg->callback) {\n\t\t\tcase 0:\n\t\t\t\tlp->flags &= ~(ISDN_NET_CALLBACK | ISDN_NET_CBOUT);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tlp->flags |= ISDN_NET_CALLBACK;\n\t\t\t\tlp->flags &= ~ISDN_NET_CBOUT;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tlp->flags |= ISDN_NET_CBOUT;\n\t\t\t\tlp->flags &= ~ISDN_NET_CALLBACK;\n\t\t\t\tbreak;\n\t\t}\n\t\tlp->flags &= ~ISDN_NET_DIALMODE_MASK;\t/* first all bits off */\n\t\tif (cfg->dialmode && !(cfg->dialmode & ISDN_NET_DIALMODE_MASK)) {\n\t\t\t/* old isdnctrl version, where only 0 or 1 is given */\n\t\t\tprintk(KERN_WARNING\n\t\t\t     \"Old isdnctrl version detected! Please update.\\n\");\n\t\t\tlp->flags |= ISDN_NET_DM_OFF; /* turn on `off' bit */\n\t\t}\n\t\telse {\n\t\t\tlp->flags |= cfg->dialmode;  /* turn on selected bits */\n\t\t}\n\t\tif (cfg->chargehup)\n\t\t\tlp->hupflags |= ISDN_CHARGEHUP;\n\t\telse\n\t\t\tlp->hupflags &= ~ISDN_CHARGEHUP;\n\t\tif (cfg->ihup)\n\t\t\tlp->hupflags |= ISDN_INHUP;\n\t\telse\n\t\t\tlp->hupflags &= ~ISDN_INHUP;\n\t\tif (cfg->chargeint > 10) {\n\t\t\tlp->hupflags |= ISDN_CHARGEHUP | ISDN_HAVECHARGE | ISDN_MANCHARGE;\n\t\t\tlp->chargeint = cfg->chargeint * HZ;\n\t\t}\n\t\tif (cfg->p_encap != lp->p_encap) {\n\t\t\tif (cfg->p_encap == ISDN_NET_ENCAP_RAWIP) {\n\t\t\t\tp->dev->header_ops = NULL;\n\t\t\t\tp->dev->flags = IFF_NOARP|IFF_POINTOPOINT;\n\t\t\t} else {\n\t\t\t\tp->dev->header_ops = &isdn_header_ops;\n\t\t\t\tif (cfg->p_encap == ISDN_NET_ENCAP_ETHER)\n\t\t\t\t\tp->dev->flags = IFF_BROADCAST | IFF_MULTICAST;\n\t\t\t\telse\n\t\t\t\t\tp->dev->flags = IFF_NOARP|IFF_POINTOPOINT;\n\t\t\t}\n\t\t}\n\t\tlp->p_encap = cfg->p_encap;\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}\n\n/*\n * Perform get-interface-parameters.ioctl\n */\nint\nisdn_net_getcfg(isdn_net_ioctl_cfg * cfg)\n{\n\tisdn_net_dev *p = isdn_net_findif(cfg->name);\n\n\tif (p) {\n\t\tisdn_net_local *lp = p->local;\n\n\t\tstrcpy(cfg->eaz, lp->msn);\n\t\tcfg->exclusive = lp->exclusive;\n\t\tif (lp->pre_device >= 0) {\n\t\t\tsprintf(cfg->drvid, \"%s,%d\", dev->drvid[lp->pre_device],\n\t\t\t\tlp->pre_channel);\n\t\t} else\n\t\t\tcfg->drvid[0] = '\\0';\n\t\tcfg->onhtime = lp->onhtime;\n\t\tcfg->charge = lp->charge;\n\t\tcfg->l2_proto = lp->l2_proto;\n\t\tcfg->l3_proto = lp->l3_proto;\n\t\tcfg->p_encap = lp->p_encap;\n\t\tcfg->secure = (lp->flags & ISDN_NET_SECURE) ? 1 : 0;\n\t\tcfg->callback = 0;\n\t\tif (lp->flags & ISDN_NET_CALLBACK)\n\t\t\tcfg->callback = 1;\n\t\tif (lp->flags & ISDN_NET_CBOUT)\n\t\t\tcfg->callback = 2;\n\t\tcfg->cbhup = (lp->flags & ISDN_NET_CBHUP) ? 1 : 0;\n\t\tcfg->dialmode = lp->flags & ISDN_NET_DIALMODE_MASK;\n\t\tcfg->chargehup = (lp->hupflags & 4) ? 1 : 0;\n\t\tcfg->ihup = (lp->hupflags & 8) ? 1 : 0;\n\t\tcfg->cbdelay = lp->cbdelay;\n\t\tcfg->dialmax = lp->dialmax;\n\t\tcfg->triggercps = lp->triggercps;\n\t\tcfg->slavedelay = lp->slavedelay / HZ;\n\t\tcfg->chargeint = (lp->hupflags & ISDN_CHARGEHUP) ?\n\t\t    (lp->chargeint / HZ) : 0;\n\t\tcfg->pppbind = lp->pppbind;\n\t\tcfg->dialtimeout = lp->dialtimeout >= 0 ? lp->dialtimeout / HZ : -1;\n\t\tcfg->dialwait = lp->dialwait / HZ;\n\t\tif (lp->slave) {\n\t\t\tif (strlen(lp->slave->name) >= 10)\n\t\t\t\tstrcpy(cfg->slave, \"too-long\");\n\t\t\telse\n\t\t\t\tstrcpy(cfg->slave, lp->slave->name);\n\t\t} else\n\t\t\tcfg->slave[0] = '\\0';\n\t\tif (lp->master) {\n\t\t\tif (strlen(lp->master->name) >= 10)\n\t\t\t\tstrcpy(cfg->master, \"too-long\");\n\t\t\telse\n\t\t\t\tstrcpy(cfg->master, lp->master->name);\n\t\t} else\n\t\t\tcfg->master[0] = '\\0';\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}\n\n/*\n * Add a phone-number to an interface.\n */\nint\nisdn_net_addphone(isdn_net_ioctl_phone * phone)\n{\n\tisdn_net_dev *p = isdn_net_findif(phone->name);\n\tisdn_net_phone *n;\n\n\tif (p) {\n\t\tif (!(n = kmalloc(sizeof(isdn_net_phone), GFP_KERNEL)))\n\t\t\treturn -ENOMEM;\n\t\tstrlcpy(n->num, phone->phone, sizeof(n->num));\n\t\tn->next = p->local->phone[phone->outgoing & 1];\n\t\tp->local->phone[phone->outgoing & 1] = n;\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}\n\n/*\n * Copy a string of all phone-numbers of an interface to user space.\n * This might sleep and must be called with the isdn semaphore down.\n */\nint\nisdn_net_getphones(isdn_net_ioctl_phone * phone, char __user *phones)\n{\n\tisdn_net_dev *p = isdn_net_findif(phone->name);\n\tint inout = phone->outgoing & 1;\n\tint more = 0;\n\tint count = 0;\n\tisdn_net_phone *n;\n\n\tif (!p)\n\t\treturn -ENODEV;\n\tinout &= 1;\n\tfor (n = p->local->phone[inout]; n; n = n->next) {\n\t\tif (more) {\n\t\t\tput_user(' ', phones++);\n\t\t\tcount++;\n\t\t}\n\t\tif (copy_to_user(phones, n->num, strlen(n->num) + 1)) {\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tphones += strlen(n->num);\n\t\tcount += strlen(n->num);\n\t\tmore = 1;\n\t}\n\tput_user(0, phones);\n\tcount++;\n\treturn count;\n}\n\n/*\n * Copy a string containing the peer's phone number of a connected interface\n * to user space.\n */\nint\nisdn_net_getpeer(isdn_net_ioctl_phone *phone, isdn_net_ioctl_phone __user *peer)\n{\n\tisdn_net_dev *p = isdn_net_findif(phone->name);\n\tint ch, dv, idx;\n\n\tif (!p)\n\t\treturn -ENODEV;\n\t/*\n\t * Theoretical race: while this executes, the remote number might\n\t * become invalid (hang up) or change (new connection), resulting\n         * in (partially) wrong number copied to user. This race\n\t * currently ignored.\n\t */\n\tch = p->local->isdn_channel;\n\tdv = p->local->isdn_device;\n\tif(ch < 0 && dv < 0)\n\t\treturn -ENOTCONN;\n\tidx = isdn_dc2minor(dv, ch);\n\tif (idx <0 )\n\t\treturn -ENODEV;\n\t/* for pre-bound channels, we need this extra check */\n\tif (strncmp(dev->num[idx], \"???\", 3) == 0)\n\t\treturn -ENOTCONN;\n\tstrncpy(phone->phone, dev->num[idx], ISDN_MSNLEN);\n\tphone->outgoing = USG_OUTGOING(dev->usage[idx]);\n\tif (copy_to_user(peer, phone, sizeof(*peer)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n/*\n * Delete a phone-number from an interface.\n */\nint\nisdn_net_delphone(isdn_net_ioctl_phone * phone)\n{\n\tisdn_net_dev *p = isdn_net_findif(phone->name);\n\tint inout = phone->outgoing & 1;\n\tisdn_net_phone *n;\n\tisdn_net_phone *m;\n\n\tif (p) {\n\t\tn = p->local->phone[inout];\n\t\tm = NULL;\n\t\twhile (n) {\n\t\t\tif (!strcmp(n->num, phone->phone)) {\n\t\t\t\tif (p->local->dial == n)\n\t\t\t\t\tp->local->dial = n->next;\n\t\t\t\tif (m)\n\t\t\t\t\tm->next = n->next;\n\t\t\t\telse\n\t\t\t\t\tp->local->phone[inout] = n->next;\n\t\t\t\tkfree(n);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tm = n;\n\t\t\tn = (isdn_net_phone *) n->next;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\treturn -ENODEV;\n}\n\n/*\n * Delete all phone-numbers of an interface.\n */\nstatic int\nisdn_net_rmallphone(isdn_net_dev * p)\n{\n\tisdn_net_phone *n;\n\tisdn_net_phone *m;\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tn = p->local->phone[i];\n\t\twhile (n) {\n\t\t\tm = n->next;\n\t\t\tkfree(n);\n\t\t\tn = m;\n\t\t}\n\t\tp->local->phone[i] = NULL;\n\t}\n\tp->local->dial = NULL;\n\treturn 0;\n}\n\n/*\n * Force a hangup of a network-interface.\n */\nint\nisdn_net_force_hangup(char *name)\n{\n\tisdn_net_dev *p = isdn_net_findif(name);\n\tstruct net_device *q;\n\n\tif (p) {\n\t\tif (p->local->isdn_device < 0)\n\t\t\treturn 1;\n\t\tq = p->local->slave;\n\t\t/* If this interface has slaves, do a hangup for them also. */\n\t\twhile (q) {\n\t\t\tisdn_net_hangup(q);\n\t\t\tq = MASTER_TO_SLAVE(q);\n\t\t}\n\t\tisdn_net_hangup(p->dev);\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}\n\n/*\n * Helper-function for isdn_net_rm: Do the real work.\n */\nstatic int\nisdn_net_realrm(isdn_net_dev * p, isdn_net_dev * q)\n{\n\tu_long flags;\n\n\tif (isdn_net_device_started(p)) {\n\t\treturn -EBUSY;\n\t}\n#ifdef CONFIG_ISDN_X25\n\tif( p -> cprot && p -> cprot -> pops )\n\t\tp -> cprot -> pops -> proto_del ( p -> cprot );\n#endif\n\t/* Free all phone-entries */\n\tisdn_net_rmallphone(p);\n\t/* If interface is bound exclusive, free channel-usage */\n\tif (p->local->exclusive != -1)\n\t\tisdn_unexclusive_channel(p->local->pre_device, p->local->pre_channel);\n\tif (p->local->master) {\n\t\t/* It's a slave-device, so update master's slave-pointer if necessary */\n\t\tif (((isdn_net_local *) ISDN_MASTER_PRIV(p->local))->slave ==\n\t\t    p->dev)\n\t\t\t((isdn_net_local *)ISDN_MASTER_PRIV(p->local))->slave =\n\t\t\t\tp->local->slave;\n\t} else {\n\t\t/* Unregister only if it's a master-device */\n\t\tunregister_netdev(p->dev);\n\t}\n\t/* Unlink device from chain */\n\tspin_lock_irqsave(&dev->lock, flags);\n\tif (q)\n\t\tq->next = p->next;\n\telse\n\t\tdev->netdev = p->next;\n\tif (p->local->slave) {\n\t\t/* If this interface has a slave, remove it also */\n\t\tchar *slavename = p->local->slave->name;\n\t\tisdn_net_dev *n = dev->netdev;\n\t\tq = NULL;\n\t\twhile (n) {\n\t\t\tif (!strcmp(n->dev->name, slavename)) {\n\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\tisdn_net_realrm(n, q);\n\t\t\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tq = n;\n\t\t\tn = (isdn_net_dev *)n->next;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\t/* If no more net-devices remain, disable auto-hangup timer */\n\tif (dev->netdev == NULL)\n\t\tisdn_timer_ctrl(ISDN_TIMER_NETHANGUP, 0);\n\tfree_netdev(p->dev);\n\tkfree(p);\n\n\treturn 0;\n}\n\n/*\n * Remove a single network-interface.\n */\nint\nisdn_net_rm(char *name)\n{\n\tu_long flags;\n\tisdn_net_dev *p;\n\tisdn_net_dev *q;\n\n\t/* Search name in netdev-chain */\n\tspin_lock_irqsave(&dev->lock, flags);\n\tp = dev->netdev;\n\tq = NULL;\n\twhile (p) {\n\t\tif (!strcmp(p->dev->name, name)) {\n\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\treturn (isdn_net_realrm(p, q));\n\t\t}\n\t\tq = p;\n\t\tp = (isdn_net_dev *) p->next;\n\t}\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\t/* If no more net-devices remain, disable auto-hangup timer */\n\tif (dev->netdev == NULL)\n\t\tisdn_timer_ctrl(ISDN_TIMER_NETHANGUP, 0);\n\treturn -ENODEV;\n}\n\n/*\n * Remove all network-interfaces\n */\nint\nisdn_net_rmall(void)\n{\n\tu_long flags;\n\tint ret;\n\n\t/* Walk through netdev-chain */\n\tspin_lock_irqsave(&dev->lock, flags);\n\twhile (dev->netdev) {\n\t\tif (!dev->netdev->local->master) {\n\t\t\t/* Remove master-devices only, slaves get removed with their master */\n\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\tif ((ret = isdn_net_realrm(dev->netdev, NULL))) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\t}\n\t}\n\tdev->netdev = NULL;\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn 0;\n}\n", "/*\n * originally based on the dummy device.\n *\n * Copyright 1999, Thomas Davis, tadavis@lbl.gov.\n * Licensed under the GPL. Based on dummy.c, and eql.c devices.\n *\n * bonding.c: an Ethernet Bonding driver\n *\n * This is useful to talk to a Cisco EtherChannel compatible equipment:\n *\tCisco 5500\n *\tSun Trunking (Solaris)\n *\tAlteon AceDirector Trunks\n *\tLinux Bonding\n *\tand probably many L2 switches ...\n *\n * How it works:\n *    ifconfig bond0 ipaddress netmask up\n *      will setup a network device, with an ip address.  No mac address\n *\twill be assigned at this time.  The hw mac address will come from\n *\tthe first slave bonded to the channel.  All slaves will then use\n *\tthis hw mac address.\n *\n *    ifconfig bond0 down\n *         will release all slaves, marking them as down.\n *\n *    ifenslave bond0 eth0\n *\twill attach eth0 to bond0 as a slave.  eth0 hw mac address will either\n *\ta: be used as initial mac address\n *\tb: if a hw mac address already is there, eth0's hw mac address\n *\t   will then be set from bond0.\n *\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/interrupt.h>\n#include <linux/ptrace.h>\n#include <linux/ioport.h>\n#include <linux/in.h>\n#include <net/ip.h>\n#include <linux/ip.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/timer.h>\n#include <linux/socket.h>\n#include <linux/ctype.h>\n#include <linux/inet.h>\n#include <linux/bitops.h>\n#include <linux/io.h>\n#include <asm/system.h>\n#include <asm/dma.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/netdevice.h>\n#include <linux/inetdevice.h>\n#include <linux/igmp.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <linux/rtnetlink.h>\n#include <linux/smp.h>\n#include <linux/if_ether.h>\n#include <net/arp.h>\n#include <linux/mii.h>\n#include <linux/ethtool.h>\n#include <linux/if_vlan.h>\n#include <linux/if_bonding.h>\n#include <linux/jiffies.h>\n#include <linux/preempt.h>\n#include <net/route.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include \"bonding.h\"\n#include \"bond_3ad.h\"\n#include \"bond_alb.h\"\n\n/*---------------------------- Module parameters ----------------------------*/\n\n/* monitor all links that often (in milliseconds). <=0 disables monitoring */\n#define BOND_LINK_MON_INTERV\t0\n#define BOND_LINK_ARP_INTERV\t0\n\nstatic int max_bonds\t= BOND_DEFAULT_MAX_BONDS;\nstatic int tx_queues\t= BOND_DEFAULT_TX_QUEUES;\nstatic int num_peer_notif = 1;\nstatic int miimon\t= BOND_LINK_MON_INTERV;\nstatic int updelay;\nstatic int downdelay;\nstatic int use_carrier\t= 1;\nstatic char *mode;\nstatic char *primary;\nstatic char *primary_reselect;\nstatic char *lacp_rate;\nstatic int min_links;\nstatic char *ad_select;\nstatic char *xmit_hash_policy;\nstatic int arp_interval = BOND_LINK_ARP_INTERV;\nstatic char *arp_ip_target[BOND_MAX_ARP_TARGETS];\nstatic char *arp_validate;\nstatic char *fail_over_mac;\nstatic int all_slaves_active = 0;\nstatic struct bond_params bonding_defaults;\nstatic int resend_igmp = BOND_DEFAULT_RESEND_IGMP;\n\nmodule_param(max_bonds, int, 0);\nMODULE_PARM_DESC(max_bonds, \"Max number of bonded devices\");\nmodule_param(tx_queues, int, 0);\nMODULE_PARM_DESC(tx_queues, \"Max number of transmit queues (default = 16)\");\nmodule_param_named(num_grat_arp, num_peer_notif, int, 0644);\nMODULE_PARM_DESC(num_grat_arp, \"Number of peer notifications to send on \"\n\t\t\t       \"failover event (alias of num_unsol_na)\");\nmodule_param_named(num_unsol_na, num_peer_notif, int, 0644);\nMODULE_PARM_DESC(num_unsol_na, \"Number of peer notifications to send on \"\n\t\t\t       \"failover event (alias of num_grat_arp)\");\nmodule_param(miimon, int, 0);\nMODULE_PARM_DESC(miimon, \"Link check interval in milliseconds\");\nmodule_param(updelay, int, 0);\nMODULE_PARM_DESC(updelay, \"Delay before considering link up, in milliseconds\");\nmodule_param(downdelay, int, 0);\nMODULE_PARM_DESC(downdelay, \"Delay before considering link down, \"\n\t\t\t    \"in milliseconds\");\nmodule_param(use_carrier, int, 0);\nMODULE_PARM_DESC(use_carrier, \"Use netif_carrier_ok (vs MII ioctls) in miimon; \"\n\t\t\t      \"0 for off, 1 for on (default)\");\nmodule_param(mode, charp, 0);\nMODULE_PARM_DESC(mode, \"Mode of operation; 0 for balance-rr, \"\n\t\t       \"1 for active-backup, 2 for balance-xor, \"\n\t\t       \"3 for broadcast, 4 for 802.3ad, 5 for balance-tlb, \"\n\t\t       \"6 for balance-alb\");\nmodule_param(primary, charp, 0);\nMODULE_PARM_DESC(primary, \"Primary network device to use\");\nmodule_param(primary_reselect, charp, 0);\nMODULE_PARM_DESC(primary_reselect, \"Reselect primary slave \"\n\t\t\t\t   \"once it comes up; \"\n\t\t\t\t   \"0 for always (default), \"\n\t\t\t\t   \"1 for only if speed of primary is \"\n\t\t\t\t   \"better, \"\n\t\t\t\t   \"2 for only on active slave \"\n\t\t\t\t   \"failure\");\nmodule_param(lacp_rate, charp, 0);\nMODULE_PARM_DESC(lacp_rate, \"LACPDU tx rate to request from 802.3ad partner; \"\n\t\t\t    \"0 for slow, 1 for fast\");\nmodule_param(ad_select, charp, 0);\nMODULE_PARM_DESC(ad_select, \"803.ad aggregation selection logic; \"\n\t\t\t    \"0 for stable (default), 1 for bandwidth, \"\n\t\t\t    \"2 for count\");\nmodule_param(min_links, int, 0);\nMODULE_PARM_DESC(min_links, \"Minimum number of available links before turning on carrier\");\n\nmodule_param(xmit_hash_policy, charp, 0);\nMODULE_PARM_DESC(xmit_hash_policy, \"balance-xor and 802.3ad hashing method; \"\n\t\t\t\t   \"0 for layer 2 (default), 1 for layer 3+4, \"\n\t\t\t\t   \"2 for layer 2+3\");\nmodule_param(arp_interval, int, 0);\nMODULE_PARM_DESC(arp_interval, \"arp interval in milliseconds\");\nmodule_param_array(arp_ip_target, charp, NULL, 0);\nMODULE_PARM_DESC(arp_ip_target, \"arp targets in n.n.n.n form\");\nmodule_param(arp_validate, charp, 0);\nMODULE_PARM_DESC(arp_validate, \"validate src/dst of ARP probes; \"\n\t\t\t       \"0 for none (default), 1 for active, \"\n\t\t\t       \"2 for backup, 3 for all\");\nmodule_param(fail_over_mac, charp, 0);\nMODULE_PARM_DESC(fail_over_mac, \"For active-backup, do not set all slaves to \"\n\t\t\t\t\"the same MAC; 0 for none (default), \"\n\t\t\t\t\"1 for active, 2 for follow\");\nmodule_param(all_slaves_active, int, 0);\nMODULE_PARM_DESC(all_slaves_active, \"Keep all frames received on an interface\"\n\t\t\t\t     \"by setting active flag for all slaves; \"\n\t\t\t\t     \"0 for never (default), 1 for always.\");\nmodule_param(resend_igmp, int, 0);\nMODULE_PARM_DESC(resend_igmp, \"Number of IGMP membership reports to send on \"\n\t\t\t      \"link failure\");\n\n/*----------------------------- Global variables ----------------------------*/\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\natomic_t netpoll_block_tx = ATOMIC_INIT(0);\n#endif\n\nint bond_net_id __read_mostly;\n\nstatic __be32 arp_target[BOND_MAX_ARP_TARGETS];\nstatic int arp_ip_count;\nstatic int bond_mode\t= BOND_MODE_ROUNDROBIN;\nstatic int xmit_hashtype = BOND_XMIT_POLICY_LAYER2;\nstatic int lacp_fast;\n\nconst struct bond_parm_tbl bond_lacp_tbl[] = {\n{\t\"slow\",\t\tAD_LACP_SLOW},\n{\t\"fast\",\t\tAD_LACP_FAST},\n{\tNULL,\t\t-1},\n};\n\nconst struct bond_parm_tbl bond_mode_tbl[] = {\n{\t\"balance-rr\",\t\tBOND_MODE_ROUNDROBIN},\n{\t\"active-backup\",\tBOND_MODE_ACTIVEBACKUP},\n{\t\"balance-xor\",\t\tBOND_MODE_XOR},\n{\t\"broadcast\",\t\tBOND_MODE_BROADCAST},\n{\t\"802.3ad\",\t\tBOND_MODE_8023AD},\n{\t\"balance-tlb\",\t\tBOND_MODE_TLB},\n{\t\"balance-alb\",\t\tBOND_MODE_ALB},\n{\tNULL,\t\t\t-1},\n};\n\nconst struct bond_parm_tbl xmit_hashtype_tbl[] = {\n{\t\"layer2\",\t\tBOND_XMIT_POLICY_LAYER2},\n{\t\"layer3+4\",\t\tBOND_XMIT_POLICY_LAYER34},\n{\t\"layer2+3\",\t\tBOND_XMIT_POLICY_LAYER23},\n{\tNULL,\t\t\t-1},\n};\n\nconst struct bond_parm_tbl arp_validate_tbl[] = {\n{\t\"none\",\t\t\tBOND_ARP_VALIDATE_NONE},\n{\t\"active\",\t\tBOND_ARP_VALIDATE_ACTIVE},\n{\t\"backup\",\t\tBOND_ARP_VALIDATE_BACKUP},\n{\t\"all\",\t\t\tBOND_ARP_VALIDATE_ALL},\n{\tNULL,\t\t\t-1},\n};\n\nconst struct bond_parm_tbl fail_over_mac_tbl[] = {\n{\t\"none\",\t\t\tBOND_FOM_NONE},\n{\t\"active\",\t\tBOND_FOM_ACTIVE},\n{\t\"follow\",\t\tBOND_FOM_FOLLOW},\n{\tNULL,\t\t\t-1},\n};\n\nconst struct bond_parm_tbl pri_reselect_tbl[] = {\n{\t\"always\",\t\tBOND_PRI_RESELECT_ALWAYS},\n{\t\"better\",\t\tBOND_PRI_RESELECT_BETTER},\n{\t\"failure\",\t\tBOND_PRI_RESELECT_FAILURE},\n{\tNULL,\t\t\t-1},\n};\n\nstruct bond_parm_tbl ad_select_tbl[] = {\n{\t\"stable\",\tBOND_AD_STABLE},\n{\t\"bandwidth\",\tBOND_AD_BANDWIDTH},\n{\t\"count\",\tBOND_AD_COUNT},\n{\tNULL,\t\t-1},\n};\n\n/*-------------------------- Forward declarations ---------------------------*/\n\nstatic int bond_init(struct net_device *bond_dev);\nstatic void bond_uninit(struct net_device *bond_dev);\n\n/*---------------------------- General routines -----------------------------*/\n\nconst char *bond_mode_name(int mode)\n{\n\tstatic const char *names[] = {\n\t\t[BOND_MODE_ROUNDROBIN] = \"load balancing (round-robin)\",\n\t\t[BOND_MODE_ACTIVEBACKUP] = \"fault-tolerance (active-backup)\",\n\t\t[BOND_MODE_XOR] = \"load balancing (xor)\",\n\t\t[BOND_MODE_BROADCAST] = \"fault-tolerance (broadcast)\",\n\t\t[BOND_MODE_8023AD] = \"IEEE 802.3ad Dynamic link aggregation\",\n\t\t[BOND_MODE_TLB] = \"transmit load balancing\",\n\t\t[BOND_MODE_ALB] = \"adaptive load balancing\",\n\t};\n\n\tif (mode < 0 || mode > BOND_MODE_ALB)\n\t\treturn \"unknown\";\n\n\treturn names[mode];\n}\n\n/*---------------------------------- VLAN -----------------------------------*/\n\n/**\n * bond_add_vlan - add a new vlan id on bond\n * @bond: bond that got the notification\n * @vlan_id: the vlan id to add\n *\n * Returns -ENOMEM if allocation failed.\n */\nstatic int bond_add_vlan(struct bonding *bond, unsigned short vlan_id)\n{\n\tstruct vlan_entry *vlan;\n\n\tpr_debug(\"bond: %s, vlan id %d\\n\",\n\t\t (bond ? bond->dev->name : \"None\"), vlan_id);\n\n\tvlan = kzalloc(sizeof(struct vlan_entry), GFP_KERNEL);\n\tif (!vlan)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&vlan->vlan_list);\n\tvlan->vlan_id = vlan_id;\n\n\twrite_lock_bh(&bond->lock);\n\n\tlist_add_tail(&vlan->vlan_list, &bond->vlan_list);\n\n\twrite_unlock_bh(&bond->lock);\n\n\tpr_debug(\"added VLAN ID %d on bond %s\\n\", vlan_id, bond->dev->name);\n\n\treturn 0;\n}\n\n/**\n * bond_del_vlan - delete a vlan id from bond\n * @bond: bond that got the notification\n * @vlan_id: the vlan id to delete\n *\n * returns -ENODEV if @vlan_id was not found in @bond.\n */\nstatic int bond_del_vlan(struct bonding *bond, unsigned short vlan_id)\n{\n\tstruct vlan_entry *vlan;\n\tint res = -ENODEV;\n\n\tpr_debug(\"bond: %s, vlan id %d\\n\", bond->dev->name, vlan_id);\n\n\tblock_netpoll_tx();\n\twrite_lock_bh(&bond->lock);\n\n\tlist_for_each_entry(vlan, &bond->vlan_list, vlan_list) {\n\t\tif (vlan->vlan_id == vlan_id) {\n\t\t\tlist_del(&vlan->vlan_list);\n\n\t\t\tif (bond_is_lb(bond))\n\t\t\t\tbond_alb_clear_vlan(bond, vlan_id);\n\n\t\t\tpr_debug(\"removed VLAN ID %d from bond %s\\n\",\n\t\t\t\t vlan_id, bond->dev->name);\n\n\t\t\tkfree(vlan);\n\n\t\t\tres = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tpr_debug(\"couldn't find VLAN ID %d in bond %s\\n\",\n\t\t vlan_id, bond->dev->name);\n\nout:\n\twrite_unlock_bh(&bond->lock);\n\tunblock_netpoll_tx();\n\treturn res;\n}\n\n/**\n * bond_next_vlan - safely skip to the next item in the vlans list.\n * @bond: the bond we're working on\n * @curr: item we're advancing from\n *\n * Returns %NULL if list is empty, bond->next_vlan if @curr is %NULL,\n * or @curr->next otherwise (even if it is @curr itself again).\n *\n * Caller must hold bond->lock\n */\nstruct vlan_entry *bond_next_vlan(struct bonding *bond, struct vlan_entry *curr)\n{\n\tstruct vlan_entry *next, *last;\n\n\tif (list_empty(&bond->vlan_list))\n\t\treturn NULL;\n\n\tif (!curr) {\n\t\tnext = list_entry(bond->vlan_list.next,\n\t\t\t\t  struct vlan_entry, vlan_list);\n\t} else {\n\t\tlast = list_entry(bond->vlan_list.prev,\n\t\t\t\t  struct vlan_entry, vlan_list);\n\t\tif (last == curr) {\n\t\t\tnext = list_entry(bond->vlan_list.next,\n\t\t\t\t\t  struct vlan_entry, vlan_list);\n\t\t} else {\n\t\t\tnext = list_entry(curr->vlan_list.next,\n\t\t\t\t\t  struct vlan_entry, vlan_list);\n\t\t}\n\t}\n\n\treturn next;\n}\n\n#define bond_queue_mapping(skb) (*(u16 *)((skb)->cb))\n\n/**\n * bond_dev_queue_xmit - Prepare skb for xmit.\n *\n * @bond: bond device that got this skb for tx.\n * @skb: hw accel VLAN tagged skb to transmit\n * @slave_dev: slave that is supposed to xmit this skbuff\n */\nint bond_dev_queue_xmit(struct bonding *bond, struct sk_buff *skb,\n\t\t\tstruct net_device *slave_dev)\n{\n\tskb->dev = slave_dev;\n\tskb->priority = 1;\n\n\tskb->queue_mapping = bond_queue_mapping(skb);\n\n\tif (unlikely(netpoll_tx_running(slave_dev)))\n\t\tbond_netpoll_send_skb(bond_get_slave_by_dev(bond, slave_dev), skb);\n\telse\n\t\tdev_queue_xmit(skb);\n\n\treturn 0;\n}\n\n/*\n * In the following 2 functions, bond_vlan_rx_add_vid and bond_vlan_rx_kill_vid,\n * We don't protect the slave list iteration with a lock because:\n * a. This operation is performed in IOCTL context,\n * b. The operation is protected by the RTNL semaphore in the 8021q code,\n * c. Holding a lock with BH disabled while directly calling a base driver\n *    entry point is generally a BAD idea.\n *\n * The design of synchronization/protection for this operation in the 8021q\n * module is good for one or more VLAN devices over a single physical device\n * and cannot be extended for a teaming solution like bonding, so there is a\n * potential race condition here where a net device from the vlan group might\n * be referenced (either by a base driver or the 8021q code) while it is being\n * removed from the system. However, it turns out we're not making matters\n * worse, and if it works for regular VLAN usage it will work here too.\n*/\n\n/**\n * bond_vlan_rx_add_vid - Propagates adding an id to slaves\n * @bond_dev: bonding net device that got called\n * @vid: vlan id being added\n */\nstatic void bond_vlan_rx_add_vid(struct net_device *bond_dev, uint16_t vid)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct slave *slave;\n\tint i, res;\n\n\tbond_for_each_slave(bond, slave, i) {\n\t\tstruct net_device *slave_dev = slave->dev;\n\t\tconst struct net_device_ops *slave_ops = slave_dev->netdev_ops;\n\n\t\tif ((slave_dev->features & NETIF_F_HW_VLAN_FILTER) &&\n\t\t    slave_ops->ndo_vlan_rx_add_vid) {\n\t\t\tslave_ops->ndo_vlan_rx_add_vid(slave_dev, vid);\n\t\t}\n\t}\n\n\tres = bond_add_vlan(bond, vid);\n\tif (res) {\n\t\tpr_err(\"%s: Error: Failed to add vlan id %d\\n\",\n\t\t       bond_dev->name, vid);\n\t}\n}\n\n/**\n * bond_vlan_rx_kill_vid - Propagates deleting an id to slaves\n * @bond_dev: bonding net device that got called\n * @vid: vlan id being removed\n */\nstatic void bond_vlan_rx_kill_vid(struct net_device *bond_dev, uint16_t vid)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct slave *slave;\n\tint i, res;\n\n\tbond_for_each_slave(bond, slave, i) {\n\t\tstruct net_device *slave_dev = slave->dev;\n\t\tconst struct net_device_ops *slave_ops = slave_dev->netdev_ops;\n\n\t\tif ((slave_dev->features & NETIF_F_HW_VLAN_FILTER) &&\n\t\t    slave_ops->ndo_vlan_rx_kill_vid) {\n\t\t\tslave_ops->ndo_vlan_rx_kill_vid(slave_dev, vid);\n\t\t}\n\t}\n\n\tres = bond_del_vlan(bond, vid);\n\tif (res) {\n\t\tpr_err(\"%s: Error: Failed to remove vlan id %d\\n\",\n\t\t       bond_dev->name, vid);\n\t}\n}\n\nstatic void bond_add_vlans_on_slave(struct bonding *bond, struct net_device *slave_dev)\n{\n\tstruct vlan_entry *vlan;\n\tconst struct net_device_ops *slave_ops = slave_dev->netdev_ops;\n\n\tif (!(slave_dev->features & NETIF_F_HW_VLAN_FILTER) ||\n\t    !(slave_ops->ndo_vlan_rx_add_vid))\n\t\treturn;\n\n\tlist_for_each_entry(vlan, &bond->vlan_list, vlan_list)\n\t\tslave_ops->ndo_vlan_rx_add_vid(slave_dev, vlan->vlan_id);\n}\n\nstatic void bond_del_vlans_from_slave(struct bonding *bond,\n\t\t\t\t      struct net_device *slave_dev)\n{\n\tconst struct net_device_ops *slave_ops = slave_dev->netdev_ops;\n\tstruct vlan_entry *vlan;\n\n\tif (!(slave_dev->features & NETIF_F_HW_VLAN_FILTER) ||\n\t    !(slave_ops->ndo_vlan_rx_kill_vid))\n\t\treturn;\n\n\tlist_for_each_entry(vlan, &bond->vlan_list, vlan_list) {\n\t\tif (!vlan->vlan_id)\n\t\t\tcontinue;\n\t\tslave_ops->ndo_vlan_rx_kill_vid(slave_dev, vlan->vlan_id);\n\t}\n}\n\n/*------------------------------- Link status -------------------------------*/\n\n/*\n * Set the carrier state for the master according to the state of its\n * slaves.  If any slaves are up, the master is up.  In 802.3ad mode,\n * do special 802.3ad magic.\n *\n * Returns zero if carrier state does not change, nonzero if it does.\n */\nstatic int bond_set_carrier(struct bonding *bond)\n{\n\tstruct slave *slave;\n\tint i;\n\n\tif (bond->slave_cnt == 0)\n\t\tgoto down;\n\n\tif (bond->params.mode == BOND_MODE_8023AD)\n\t\treturn bond_3ad_set_carrier(bond);\n\n\tbond_for_each_slave(bond, slave, i) {\n\t\tif (slave->link == BOND_LINK_UP) {\n\t\t\tif (!netif_carrier_ok(bond->dev)) {\n\t\t\t\tnetif_carrier_on(bond->dev);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\ndown:\n\tif (netif_carrier_ok(bond->dev)) {\n\t\tnetif_carrier_off(bond->dev);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * Get link speed and duplex from the slave's base driver\n * using ethtool. If for some reason the call fails or the\n * values are invalid, fake speed and duplex to 100/Full\n * and return error.\n */\nstatic int bond_update_speed_duplex(struct slave *slave)\n{\n\tstruct net_device *slave_dev = slave->dev;\n\tstruct ethtool_cmd etool = { .cmd = ETHTOOL_GSET };\n\tu32 slave_speed;\n\tint res;\n\n\t/* Fake speed and duplex */\n\tslave->speed = SPEED_100;\n\tslave->duplex = DUPLEX_FULL;\n\n\tif (!slave_dev->ethtool_ops || !slave_dev->ethtool_ops->get_settings)\n\t\treturn -1;\n\n\tres = slave_dev->ethtool_ops->get_settings(slave_dev, &etool);\n\tif (res < 0)\n\t\treturn -1;\n\n\tslave_speed = ethtool_cmd_speed(&etool);\n\tif (slave_speed == 0 || slave_speed == ((__u32) -1))\n\t\treturn -1;\n\n\tswitch (etool.duplex) {\n\tcase DUPLEX_FULL:\n\tcase DUPLEX_HALF:\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\tslave->speed = slave_speed;\n\tslave->duplex = etool.duplex;\n\n\treturn 0;\n}\n\n/*\n * if <dev> supports MII link status reporting, check its link status.\n *\n * We either do MII/ETHTOOL ioctls, or check netif_carrier_ok(),\n * depending upon the setting of the use_carrier parameter.\n *\n * Return either BMSR_LSTATUS, meaning that the link is up (or we\n * can't tell and just pretend it is), or 0, meaning that the link is\n * down.\n *\n * If reporting is non-zero, instead of faking link up, return -1 if\n * both ETHTOOL and MII ioctls fail (meaning the device does not\n * support them).  If use_carrier is set, return whatever it says.\n * It'd be nice if there was a good way to tell if a driver supports\n * netif_carrier, but there really isn't.\n */\nstatic int bond_check_dev_link(struct bonding *bond,\n\t\t\t       struct net_device *slave_dev, int reporting)\n{\n\tconst struct net_device_ops *slave_ops = slave_dev->netdev_ops;\n\tint (*ioctl)(struct net_device *, struct ifreq *, int);\n\tstruct ifreq ifr;\n\tstruct mii_ioctl_data *mii;\n\n\tif (!reporting && !netif_running(slave_dev))\n\t\treturn 0;\n\n\tif (bond->params.use_carrier)\n\t\treturn netif_carrier_ok(slave_dev) ? BMSR_LSTATUS : 0;\n\n\t/* Try to get link status using Ethtool first. */\n\tif (slave_dev->ethtool_ops) {\n\t\tif (slave_dev->ethtool_ops->get_link) {\n\t\t\tu32 link;\n\n\t\t\tlink = slave_dev->ethtool_ops->get_link(slave_dev);\n\n\t\t\treturn link ? BMSR_LSTATUS : 0;\n\t\t}\n\t}\n\n\t/* Ethtool can't be used, fallback to MII ioctls. */\n\tioctl = slave_ops->ndo_do_ioctl;\n\tif (ioctl) {\n\t\t/* TODO: set pointer to correct ioctl on a per team member */\n\t\t/*       bases to make this more efficient. that is, once  */\n\t\t/*       we determine the correct ioctl, we will always    */\n\t\t/*       call it and not the others for that team          */\n\t\t/*       member.                                           */\n\n\t\t/*\n\t\t * We cannot assume that SIOCGMIIPHY will also read a\n\t\t * register; not all network drivers (e.g., e100)\n\t\t * support that.\n\t\t */\n\n\t\t/* Yes, the mii is overlaid on the ifreq.ifr_ifru */\n\t\tstrncpy(ifr.ifr_name, slave_dev->name, IFNAMSIZ);\n\t\tmii = if_mii(&ifr);\n\t\tif (IOCTL(slave_dev, &ifr, SIOCGMIIPHY) == 0) {\n\t\t\tmii->reg_num = MII_BMSR;\n\t\t\tif (IOCTL(slave_dev, &ifr, SIOCGMIIREG) == 0)\n\t\t\t\treturn mii->val_out & BMSR_LSTATUS;\n\t\t}\n\t}\n\n\t/*\n\t * If reporting, report that either there's no dev->do_ioctl,\n\t * or both SIOCGMIIREG and get_link failed (meaning that we\n\t * cannot report link status).  If not reporting, pretend\n\t * we're ok.\n\t */\n\treturn reporting ? -1 : BMSR_LSTATUS;\n}\n\n/*----------------------------- Multicast list ------------------------------*/\n\n/*\n * Push the promiscuity flag down to appropriate slaves\n */\nstatic int bond_set_promiscuity(struct bonding *bond, int inc)\n{\n\tint err = 0;\n\tif (USES_PRIMARY(bond->params.mode)) {\n\t\t/* write lock already acquired */\n\t\tif (bond->curr_active_slave) {\n\t\t\terr = dev_set_promiscuity(bond->curr_active_slave->dev,\n\t\t\t\t\t\t  inc);\n\t\t}\n\t} else {\n\t\tstruct slave *slave;\n\t\tint i;\n\t\tbond_for_each_slave(bond, slave, i) {\n\t\t\terr = dev_set_promiscuity(slave->dev, inc);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn err;\n}\n\n/*\n * Push the allmulti flag down to all slaves\n */\nstatic int bond_set_allmulti(struct bonding *bond, int inc)\n{\n\tint err = 0;\n\tif (USES_PRIMARY(bond->params.mode)) {\n\t\t/* write lock already acquired */\n\t\tif (bond->curr_active_slave) {\n\t\t\terr = dev_set_allmulti(bond->curr_active_slave->dev,\n\t\t\t\t\t       inc);\n\t\t}\n\t} else {\n\t\tstruct slave *slave;\n\t\tint i;\n\t\tbond_for_each_slave(bond, slave, i) {\n\t\t\terr = dev_set_allmulti(slave->dev, inc);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn err;\n}\n\n/*\n * Add a Multicast address to slaves\n * according to mode\n */\nstatic void bond_mc_add(struct bonding *bond, void *addr)\n{\n\tif (USES_PRIMARY(bond->params.mode)) {\n\t\t/* write lock already acquired */\n\t\tif (bond->curr_active_slave)\n\t\t\tdev_mc_add(bond->curr_active_slave->dev, addr);\n\t} else {\n\t\tstruct slave *slave;\n\t\tint i;\n\n\t\tbond_for_each_slave(bond, slave, i)\n\t\t\tdev_mc_add(slave->dev, addr);\n\t}\n}\n\n/*\n * Remove a multicast address from slave\n * according to mode\n */\nstatic void bond_mc_del(struct bonding *bond, void *addr)\n{\n\tif (USES_PRIMARY(bond->params.mode)) {\n\t\t/* write lock already acquired */\n\t\tif (bond->curr_active_slave)\n\t\t\tdev_mc_del(bond->curr_active_slave->dev, addr);\n\t} else {\n\t\tstruct slave *slave;\n\t\tint i;\n\t\tbond_for_each_slave(bond, slave, i) {\n\t\t\tdev_mc_del(slave->dev, addr);\n\t\t}\n\t}\n}\n\n\nstatic void __bond_resend_igmp_join_requests(struct net_device *dev)\n{\n\tstruct in_device *in_dev;\n\n\trcu_read_lock();\n\tin_dev = __in_dev_get_rcu(dev);\n\tif (in_dev)\n\t\tip_mc_rejoin_groups(in_dev);\n\trcu_read_unlock();\n}\n\n/*\n * Retrieve the list of registered multicast addresses for the bonding\n * device and retransmit an IGMP JOIN request to the current active\n * slave.\n */\nstatic void bond_resend_igmp_join_requests(struct bonding *bond)\n{\n\tstruct net_device *vlan_dev;\n\tstruct vlan_entry *vlan;\n\n\tread_lock(&bond->lock);\n\n\t/* rejoin all groups on bond device */\n\t__bond_resend_igmp_join_requests(bond->dev);\n\n\t/* rejoin all groups on vlan devices */\n\tlist_for_each_entry(vlan, &bond->vlan_list, vlan_list) {\n\t\trcu_read_lock();\n\t\tvlan_dev = __vlan_find_dev_deep(bond->dev,\n\t\t\t\t\t\tvlan->vlan_id);\n\t\trcu_read_unlock();\n\t\tif (vlan_dev)\n\t\t\t__bond_resend_igmp_join_requests(vlan_dev);\n\t}\n\n\tif (--bond->igmp_retrans > 0)\n\t\tqueue_delayed_work(bond->wq, &bond->mcast_work, HZ/5);\n\n\tread_unlock(&bond->lock);\n}\n\nstatic void bond_resend_igmp_join_requests_delayed(struct work_struct *work)\n{\n\tstruct bonding *bond = container_of(work, struct bonding,\n\t\t\t\t\t    mcast_work.work);\n\tbond_resend_igmp_join_requests(bond);\n}\n\n/*\n * flush all members of flush->mc_list from device dev->mc_list\n */\nstatic void bond_mc_list_flush(struct net_device *bond_dev,\n\t\t\t       struct net_device *slave_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct netdev_hw_addr *ha;\n\n\tnetdev_for_each_mc_addr(ha, bond_dev)\n\t\tdev_mc_del(slave_dev, ha->addr);\n\n\tif (bond->params.mode == BOND_MODE_8023AD) {\n\t\t/* del lacpdu mc addr from mc list */\n\t\tu8 lacpdu_multicast[ETH_ALEN] = MULTICAST_LACPDU_ADDR;\n\n\t\tdev_mc_del(slave_dev, lacpdu_multicast);\n\t}\n}\n\n/*--------------------------- Active slave change ---------------------------*/\n\n/*\n * Update the mc list and multicast-related flags for the new and\n * old active slaves (if any) according to the multicast mode, and\n * promiscuous flags unconditionally.\n */\nstatic void bond_mc_swap(struct bonding *bond, struct slave *new_active,\n\t\t\t struct slave *old_active)\n{\n\tstruct netdev_hw_addr *ha;\n\n\tif (!USES_PRIMARY(bond->params.mode))\n\t\t/* nothing to do -  mc list is already up-to-date on\n\t\t * all slaves\n\t\t */\n\t\treturn;\n\n\tif (old_active) {\n\t\tif (bond->dev->flags & IFF_PROMISC)\n\t\t\tdev_set_promiscuity(old_active->dev, -1);\n\n\t\tif (bond->dev->flags & IFF_ALLMULTI)\n\t\t\tdev_set_allmulti(old_active->dev, -1);\n\n\t\tnetdev_for_each_mc_addr(ha, bond->dev)\n\t\t\tdev_mc_del(old_active->dev, ha->addr);\n\t}\n\n\tif (new_active) {\n\t\t/* FIXME: Signal errors upstream. */\n\t\tif (bond->dev->flags & IFF_PROMISC)\n\t\t\tdev_set_promiscuity(new_active->dev, 1);\n\n\t\tif (bond->dev->flags & IFF_ALLMULTI)\n\t\t\tdev_set_allmulti(new_active->dev, 1);\n\n\t\tnetdev_for_each_mc_addr(ha, bond->dev)\n\t\t\tdev_mc_add(new_active->dev, ha->addr);\n\t}\n}\n\n/*\n * bond_do_fail_over_mac\n *\n * Perform special MAC address swapping for fail_over_mac settings\n *\n * Called with RTNL, bond->lock for read, curr_slave_lock for write_bh.\n */\nstatic void bond_do_fail_over_mac(struct bonding *bond,\n\t\t\t\t  struct slave *new_active,\n\t\t\t\t  struct slave *old_active)\n\t__releases(&bond->curr_slave_lock)\n\t__releases(&bond->lock)\n\t__acquires(&bond->lock)\n\t__acquires(&bond->curr_slave_lock)\n{\n\tu8 tmp_mac[ETH_ALEN];\n\tstruct sockaddr saddr;\n\tint rv;\n\n\tswitch (bond->params.fail_over_mac) {\n\tcase BOND_FOM_ACTIVE:\n\t\tif (new_active)\n\t\t\tmemcpy(bond->dev->dev_addr,  new_active->dev->dev_addr,\n\t\t\t       new_active->dev->addr_len);\n\t\tbreak;\n\tcase BOND_FOM_FOLLOW:\n\t\t/*\n\t\t * if new_active && old_active, swap them\n\t\t * if just old_active, do nothing (going to no active slave)\n\t\t * if just new_active, set new_active to bond's MAC\n\t\t */\n\t\tif (!new_active)\n\t\t\treturn;\n\n\t\twrite_unlock_bh(&bond->curr_slave_lock);\n\t\tread_unlock(&bond->lock);\n\n\t\tif (old_active) {\n\t\t\tmemcpy(tmp_mac, new_active->dev->dev_addr, ETH_ALEN);\n\t\t\tmemcpy(saddr.sa_data, old_active->dev->dev_addr,\n\t\t\t       ETH_ALEN);\n\t\t\tsaddr.sa_family = new_active->dev->type;\n\t\t} else {\n\t\t\tmemcpy(saddr.sa_data, bond->dev->dev_addr, ETH_ALEN);\n\t\t\tsaddr.sa_family = bond->dev->type;\n\t\t}\n\n\t\trv = dev_set_mac_address(new_active->dev, &saddr);\n\t\tif (rv) {\n\t\t\tpr_err(\"%s: Error %d setting MAC of slave %s\\n\",\n\t\t\t       bond->dev->name, -rv, new_active->dev->name);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!old_active)\n\t\t\tgoto out;\n\n\t\tmemcpy(saddr.sa_data, tmp_mac, ETH_ALEN);\n\t\tsaddr.sa_family = old_active->dev->type;\n\n\t\trv = dev_set_mac_address(old_active->dev, &saddr);\n\t\tif (rv)\n\t\t\tpr_err(\"%s: Error %d setting MAC of slave %s\\n\",\n\t\t\t       bond->dev->name, -rv, new_active->dev->name);\nout:\n\t\tread_lock(&bond->lock);\n\t\twrite_lock_bh(&bond->curr_slave_lock);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: bond_do_fail_over_mac impossible: bad policy %d\\n\",\n\t\t       bond->dev->name, bond->params.fail_over_mac);\n\t\tbreak;\n\t}\n\n}\n\nstatic bool bond_should_change_active(struct bonding *bond)\n{\n\tstruct slave *prim = bond->primary_slave;\n\tstruct slave *curr = bond->curr_active_slave;\n\n\tif (!prim || !curr || curr->link != BOND_LINK_UP)\n\t\treturn true;\n\tif (bond->force_primary) {\n\t\tbond->force_primary = false;\n\t\treturn true;\n\t}\n\tif (bond->params.primary_reselect == BOND_PRI_RESELECT_BETTER &&\n\t    (prim->speed < curr->speed ||\n\t     (prim->speed == curr->speed && prim->duplex <= curr->duplex)))\n\t\treturn false;\n\tif (bond->params.primary_reselect == BOND_PRI_RESELECT_FAILURE)\n\t\treturn false;\n\treturn true;\n}\n\n/**\n * find_best_interface - select the best available slave to be the active one\n * @bond: our bonding struct\n *\n * Warning: Caller must hold curr_slave_lock for writing.\n */\nstatic struct slave *bond_find_best_slave(struct bonding *bond)\n{\n\tstruct slave *new_active, *old_active;\n\tstruct slave *bestslave = NULL;\n\tint mintime = bond->params.updelay;\n\tint i;\n\n\tnew_active = bond->curr_active_slave;\n\n\tif (!new_active) { /* there were no active slaves left */\n\t\tif (bond->slave_cnt > 0)   /* found one slave */\n\t\t\tnew_active = bond->first_slave;\n\t\telse\n\t\t\treturn NULL; /* still no slave, return NULL */\n\t}\n\n\tif ((bond->primary_slave) &&\n\t    bond->primary_slave->link == BOND_LINK_UP &&\n\t    bond_should_change_active(bond)) {\n\t\tnew_active = bond->primary_slave;\n\t}\n\n\t/* remember where to stop iterating over the slaves */\n\told_active = new_active;\n\n\tbond_for_each_slave_from(bond, new_active, i, old_active) {\n\t\tif (new_active->link == BOND_LINK_UP) {\n\t\t\treturn new_active;\n\t\t} else if (new_active->link == BOND_LINK_BACK &&\n\t\t\t   IS_UP(new_active->dev)) {\n\t\t\t/* link up, but waiting for stabilization */\n\t\t\tif (new_active->delay < mintime) {\n\t\t\t\tmintime = new_active->delay;\n\t\t\t\tbestslave = new_active;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn bestslave;\n}\n\nstatic bool bond_should_notify_peers(struct bonding *bond)\n{\n\tstruct slave *slave = bond->curr_active_slave;\n\n\tpr_debug(\"bond_should_notify_peers: bond %s slave %s\\n\",\n\t\t bond->dev->name, slave ? slave->dev->name : \"NULL\");\n\n\tif (!slave || !bond->send_peer_notif ||\n\t    test_bit(__LINK_STATE_LINKWATCH_PENDING, &slave->dev->state))\n\t\treturn false;\n\n\tbond->send_peer_notif--;\n\treturn true;\n}\n\n/**\n * change_active_interface - change the active slave into the specified one\n * @bond: our bonding struct\n * @new: the new slave to make the active one\n *\n * Set the new slave to the bond's settings and unset them on the old\n * curr_active_slave.\n * Setting include flags, mc-list, promiscuity, allmulti, etc.\n *\n * If @new's link state is %BOND_LINK_BACK we'll set it to %BOND_LINK_UP,\n * because it is apparently the best available slave we have, even though its\n * updelay hasn't timed out yet.\n *\n * If new_active is not NULL, caller must hold bond->lock for read and\n * curr_slave_lock for write_bh.\n */\nvoid bond_change_active_slave(struct bonding *bond, struct slave *new_active)\n{\n\tstruct slave *old_active = bond->curr_active_slave;\n\n\tif (old_active == new_active)\n\t\treturn;\n\n\tif (new_active) {\n\t\tnew_active->jiffies = jiffies;\n\n\t\tif (new_active->link == BOND_LINK_BACK) {\n\t\t\tif (USES_PRIMARY(bond->params.mode)) {\n\t\t\t\tpr_info(\"%s: making interface %s the new active one %d ms earlier.\\n\",\n\t\t\t\t\tbond->dev->name, new_active->dev->name,\n\t\t\t\t\t(bond->params.updelay - new_active->delay) * bond->params.miimon);\n\t\t\t}\n\n\t\t\tnew_active->delay = 0;\n\t\t\tnew_active->link = BOND_LINK_UP;\n\n\t\t\tif (bond->params.mode == BOND_MODE_8023AD)\n\t\t\t\tbond_3ad_handle_link_change(new_active, BOND_LINK_UP);\n\n\t\t\tif (bond_is_lb(bond))\n\t\t\t\tbond_alb_handle_link_change(bond, new_active, BOND_LINK_UP);\n\t\t} else {\n\t\t\tif (USES_PRIMARY(bond->params.mode)) {\n\t\t\t\tpr_info(\"%s: making interface %s the new active one.\\n\",\n\t\t\t\t\tbond->dev->name, new_active->dev->name);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (USES_PRIMARY(bond->params.mode))\n\t\tbond_mc_swap(bond, new_active, old_active);\n\n\tif (bond_is_lb(bond)) {\n\t\tbond_alb_handle_active_change(bond, new_active);\n\t\tif (old_active)\n\t\t\tbond_set_slave_inactive_flags(old_active);\n\t\tif (new_active)\n\t\t\tbond_set_slave_active_flags(new_active);\n\t} else {\n\t\tbond->curr_active_slave = new_active;\n\t}\n\n\tif (bond->params.mode == BOND_MODE_ACTIVEBACKUP) {\n\t\tif (old_active)\n\t\t\tbond_set_slave_inactive_flags(old_active);\n\n\t\tif (new_active) {\n\t\t\tbool should_notify_peers = false;\n\n\t\t\tbond_set_slave_active_flags(new_active);\n\n\t\t\tif (bond->params.fail_over_mac)\n\t\t\t\tbond_do_fail_over_mac(bond, new_active,\n\t\t\t\t\t\t      old_active);\n\n\t\t\tif (netif_running(bond->dev)) {\n\t\t\t\tbond->send_peer_notif =\n\t\t\t\t\tbond->params.num_peer_notif;\n\t\t\t\tshould_notify_peers =\n\t\t\t\t\tbond_should_notify_peers(bond);\n\t\t\t}\n\n\t\t\twrite_unlock_bh(&bond->curr_slave_lock);\n\t\t\tread_unlock(&bond->lock);\n\n\t\t\tnetdev_bonding_change(bond->dev, NETDEV_BONDING_FAILOVER);\n\t\t\tif (should_notify_peers)\n\t\t\t\tnetdev_bonding_change(bond->dev,\n\t\t\t\t\t\t      NETDEV_NOTIFY_PEERS);\n\n\t\t\tread_lock(&bond->lock);\n\t\t\twrite_lock_bh(&bond->curr_slave_lock);\n\t\t}\n\t}\n\n\t/* resend IGMP joins since active slave has changed or\n\t * all were sent on curr_active_slave.\n\t * resend only if bond is brought up with the affected\n\t * bonding modes and the retransmission is enabled */\n\tif (netif_running(bond->dev) && (bond->params.resend_igmp > 0) &&\n\t    ((USES_PRIMARY(bond->params.mode) && new_active) ||\n\t     bond->params.mode == BOND_MODE_ROUNDROBIN)) {\n\t\tbond->igmp_retrans = bond->params.resend_igmp;\n\t\tqueue_delayed_work(bond->wq, &bond->mcast_work, 0);\n\t}\n}\n\n/**\n * bond_select_active_slave - select a new active slave, if needed\n * @bond: our bonding struct\n *\n * This functions should be called when one of the following occurs:\n * - The old curr_active_slave has been released or lost its link.\n * - The primary_slave has got its link back.\n * - A slave has got its link back and there's no old curr_active_slave.\n *\n * Caller must hold bond->lock for read and curr_slave_lock for write_bh.\n */\nvoid bond_select_active_slave(struct bonding *bond)\n{\n\tstruct slave *best_slave;\n\tint rv;\n\n\tbest_slave = bond_find_best_slave(bond);\n\tif (best_slave != bond->curr_active_slave) {\n\t\tbond_change_active_slave(bond, best_slave);\n\t\trv = bond_set_carrier(bond);\n\t\tif (!rv)\n\t\t\treturn;\n\n\t\tif (netif_carrier_ok(bond->dev)) {\n\t\t\tpr_info(\"%s: first active interface up!\\n\",\n\t\t\t\tbond->dev->name);\n\t\t} else {\n\t\t\tpr_info(\"%s: now running without any active interface !\\n\",\n\t\t\t\tbond->dev->name);\n\t\t}\n\t}\n}\n\n/*--------------------------- slave list handling ---------------------------*/\n\n/*\n * This function attaches the slave to the end of list.\n *\n * bond->lock held for writing by caller.\n */\nstatic void bond_attach_slave(struct bonding *bond, struct slave *new_slave)\n{\n\tif (bond->first_slave == NULL) { /* attaching the first slave */\n\t\tnew_slave->next = new_slave;\n\t\tnew_slave->prev = new_slave;\n\t\tbond->first_slave = new_slave;\n\t} else {\n\t\tnew_slave->next = bond->first_slave;\n\t\tnew_slave->prev = bond->first_slave->prev;\n\t\tnew_slave->next->prev = new_slave;\n\t\tnew_slave->prev->next = new_slave;\n\t}\n\n\tbond->slave_cnt++;\n}\n\n/*\n * This function detaches the slave from the list.\n * WARNING: no check is made to verify if the slave effectively\n * belongs to <bond>.\n * Nothing is freed on return, structures are just unchained.\n * If any slave pointer in bond was pointing to <slave>,\n * it should be changed by the calling function.\n *\n * bond->lock held for writing by caller.\n */\nstatic void bond_detach_slave(struct bonding *bond, struct slave *slave)\n{\n\tif (slave->next)\n\t\tslave->next->prev = slave->prev;\n\n\tif (slave->prev)\n\t\tslave->prev->next = slave->next;\n\n\tif (bond->first_slave == slave) { /* slave is the first slave */\n\t\tif (bond->slave_cnt > 1) { /* there are more slave */\n\t\t\tbond->first_slave = slave->next;\n\t\t} else {\n\t\t\tbond->first_slave = NULL; /* slave was the last one */\n\t\t}\n\t}\n\n\tslave->next = NULL;\n\tslave->prev = NULL;\n\tbond->slave_cnt--;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic inline int slave_enable_netpoll(struct slave *slave)\n{\n\tstruct netpoll *np;\n\tint err = 0;\n\n\tnp = kzalloc(sizeof(*np), GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!np)\n\t\tgoto out;\n\n\tnp->dev = slave->dev;\n\tstrlcpy(np->dev_name, slave->dev->name, IFNAMSIZ);\n\terr = __netpoll_setup(np);\n\tif (err) {\n\t\tkfree(np);\n\t\tgoto out;\n\t}\n\tslave->np = np;\nout:\n\treturn err;\n}\nstatic inline void slave_disable_netpoll(struct slave *slave)\n{\n\tstruct netpoll *np = slave->np;\n\n\tif (!np)\n\t\treturn;\n\n\tslave->np = NULL;\n\tsynchronize_rcu_bh();\n\t__netpoll_cleanup(np);\n\tkfree(np);\n}\nstatic inline bool slave_dev_support_netpoll(struct net_device *slave_dev)\n{\n\tif (slave_dev->priv_flags & IFF_DISABLE_NETPOLL)\n\t\treturn false;\n\tif (!slave_dev->netdev_ops->ndo_poll_controller)\n\t\treturn false;\n\treturn true;\n}\n\nstatic void bond_poll_controller(struct net_device *bond_dev)\n{\n}\n\nstatic void __bond_netpoll_cleanup(struct bonding *bond)\n{\n\tstruct slave *slave;\n\tint i;\n\n\tbond_for_each_slave(bond, slave, i)\n\t\tif (IS_UP(slave->dev))\n\t\t\tslave_disable_netpoll(slave);\n}\nstatic void bond_netpoll_cleanup(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\n\tread_lock(&bond->lock);\n\t__bond_netpoll_cleanup(bond);\n\tread_unlock(&bond->lock);\n}\n\nstatic int bond_netpoll_setup(struct net_device *dev, struct netpoll_info *ni)\n{\n\tstruct bonding *bond = netdev_priv(dev);\n\tstruct slave *slave;\n\tint i, err = 0;\n\n\tread_lock(&bond->lock);\n\tbond_for_each_slave(bond, slave, i) {\n\t\terr = slave_enable_netpoll(slave);\n\t\tif (err) {\n\t\t\t__bond_netpoll_cleanup(bond);\n\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock(&bond->lock);\n\treturn err;\n}\n\nstatic struct netpoll_info *bond_netpoll_info(struct bonding *bond)\n{\n\treturn bond->dev->npinfo;\n}\n\n#else\nstatic inline int slave_enable_netpoll(struct slave *slave)\n{\n\treturn 0;\n}\nstatic inline void slave_disable_netpoll(struct slave *slave)\n{\n}\nstatic void bond_netpoll_cleanup(struct net_device *bond_dev)\n{\n}\n#endif\n\n/*---------------------------------- IOCTL ----------------------------------*/\n\nstatic int bond_sethwaddr(struct net_device *bond_dev,\n\t\t\t  struct net_device *slave_dev)\n{\n\tpr_debug(\"bond_dev=%p\\n\", bond_dev);\n\tpr_debug(\"slave_dev=%p\\n\", slave_dev);\n\tpr_debug(\"slave_dev->addr_len=%d\\n\", slave_dev->addr_len);\n\tmemcpy(bond_dev->dev_addr, slave_dev->dev_addr, slave_dev->addr_len);\n\treturn 0;\n}\n\nstatic u32 bond_fix_features(struct net_device *dev, u32 features)\n{\n\tstruct slave *slave;\n\tstruct bonding *bond = netdev_priv(dev);\n\tu32 mask;\n\tint i;\n\n\tread_lock(&bond->lock);\n\n\tif (!bond->first_slave) {\n\t\t/* Disable adding VLANs to empty bond. But why? --mq */\n\t\tfeatures |= NETIF_F_VLAN_CHALLENGED;\n\t\tgoto out;\n\t}\n\n\tmask = features;\n\tfeatures &= ~NETIF_F_ONE_FOR_ALL;\n\tfeatures |= NETIF_F_ALL_FOR_ALL;\n\n\tbond_for_each_slave(bond, slave, i) {\n\t\tfeatures = netdev_increment_features(features,\n\t\t\t\t\t\t     slave->dev->features,\n\t\t\t\t\t\t     mask);\n\t}\n\nout:\n\tread_unlock(&bond->lock);\n\treturn features;\n}\n\n#define BOND_VLAN_FEATURES\t(NETIF_F_ALL_CSUM | NETIF_F_SG | \\\n\t\t\t\t NETIF_F_FRAGLIST | NETIF_F_ALL_TSO | \\\n\t\t\t\t NETIF_F_HIGHDMA | NETIF_F_LRO)\n\nstatic void bond_compute_features(struct bonding *bond)\n{\n\tstruct slave *slave;\n\tstruct net_device *bond_dev = bond->dev;\n\tu32 vlan_features = BOND_VLAN_FEATURES;\n\tunsigned short max_hard_header_len = ETH_HLEN;\n\tint i;\n\n\tread_lock(&bond->lock);\n\n\tif (!bond->first_slave)\n\t\tgoto done;\n\n\tbond_for_each_slave(bond, slave, i) {\n\t\tvlan_features = netdev_increment_features(vlan_features,\n\t\t\tslave->dev->vlan_features, BOND_VLAN_FEATURES);\n\n\t\tif (slave->dev->hard_header_len > max_hard_header_len)\n\t\t\tmax_hard_header_len = slave->dev->hard_header_len;\n\t}\n\ndone:\n\tbond_dev->vlan_features = vlan_features;\n\tbond_dev->hard_header_len = max_hard_header_len;\n\n\tread_unlock(&bond->lock);\n\n\tnetdev_change_features(bond_dev);\n}\n\nstatic void bond_setup_by_slave(struct net_device *bond_dev,\n\t\t\t\tstruct net_device *slave_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\n\tbond_dev->header_ops\t    = slave_dev->header_ops;\n\n\tbond_dev->type\t\t    = slave_dev->type;\n\tbond_dev->hard_header_len   = slave_dev->hard_header_len;\n\tbond_dev->addr_len\t    = slave_dev->addr_len;\n\n\tmemcpy(bond_dev->broadcast, slave_dev->broadcast,\n\t\tslave_dev->addr_len);\n\tbond->setup_by_slave = 1;\n}\n\n/* On bonding slaves other than the currently active slave, suppress\n * duplicates except for alb non-mcast/bcast.\n */\nstatic bool bond_should_deliver_exact_match(struct sk_buff *skb,\n\t\t\t\t\t    struct slave *slave,\n\t\t\t\t\t    struct bonding *bond)\n{\n\tif (bond_is_slave_inactive(slave)) {\n\t\tif (bond->params.mode == BOND_MODE_ALB &&\n\t\t    skb->pkt_type != PACKET_BROADCAST &&\n\t\t    skb->pkt_type != PACKET_MULTICAST)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic rx_handler_result_t bond_handle_frame(struct sk_buff **pskb)\n{\n\tstruct sk_buff *skb = *pskb;\n\tstruct slave *slave;\n\tstruct bonding *bond;\n\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (unlikely(!skb))\n\t\treturn RX_HANDLER_CONSUMED;\n\n\t*pskb = skb;\n\n\tslave = bond_slave_get_rcu(skb->dev);\n\tbond = slave->bond;\n\n\tif (bond->params.arp_interval)\n\t\tslave->dev->last_rx = jiffies;\n\n\tif (bond->recv_probe) {\n\t\tstruct sk_buff *nskb = skb_clone(skb, GFP_ATOMIC);\n\n\t\tif (likely(nskb)) {\n\t\t\tbond->recv_probe(nskb, bond, slave);\n\t\t\tdev_kfree_skb(nskb);\n\t\t}\n\t}\n\n\tif (bond_should_deliver_exact_match(skb, slave, bond)) {\n\t\treturn RX_HANDLER_EXACT;\n\t}\n\n\tskb->dev = bond->dev;\n\n\tif (bond->params.mode == BOND_MODE_ALB &&\n\t    bond->dev->priv_flags & IFF_BRIDGE_PORT &&\n\t    skb->pkt_type == PACKET_HOST) {\n\n\t\tif (unlikely(skb_cow_head(skb,\n\t\t\t\t\t  skb->data - skb_mac_header(skb)))) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn RX_HANDLER_CONSUMED;\n\t\t}\n\t\tmemcpy(eth_hdr(skb)->h_dest, bond->dev->dev_addr, ETH_ALEN);\n\t}\n\n\treturn RX_HANDLER_ANOTHER;\n}\n\n/* enslave device <slave> to bond device <master> */\nint bond_enslave(struct net_device *bond_dev, struct net_device *slave_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tconst struct net_device_ops *slave_ops = slave_dev->netdev_ops;\n\tstruct slave *new_slave = NULL;\n\tstruct netdev_hw_addr *ha;\n\tstruct sockaddr addr;\n\tint link_reporting;\n\tint res = 0;\n\n\tif (!bond->params.use_carrier && slave_dev->ethtool_ops == NULL &&\n\t\tslave_ops->ndo_do_ioctl == NULL) {\n\t\tpr_warning(\"%s: Warning: no link monitoring support for %s\\n\",\n\t\t\t   bond_dev->name, slave_dev->name);\n\t}\n\n\t/* already enslaved */\n\tif (slave_dev->flags & IFF_SLAVE) {\n\t\tpr_debug(\"Error, Device was already enslaved\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t/* vlan challenged mutual exclusion */\n\t/* no need to lock since we're protected by rtnl_lock */\n\tif (slave_dev->features & NETIF_F_VLAN_CHALLENGED) {\n\t\tpr_debug(\"%s: NETIF_F_VLAN_CHALLENGED\\n\", slave_dev->name);\n\t\tif (bond_vlan_used(bond)) {\n\t\t\tpr_err(\"%s: Error: cannot enslave VLAN challenged slave %s on VLAN enabled bond %s\\n\",\n\t\t\t       bond_dev->name, slave_dev->name, bond_dev->name);\n\t\t\treturn -EPERM;\n\t\t} else {\n\t\t\tpr_warning(\"%s: Warning: enslaved VLAN challenged slave %s. Adding VLANs will be blocked as long as %s is part of bond %s\\n\",\n\t\t\t\t   bond_dev->name, slave_dev->name,\n\t\t\t\t   slave_dev->name, bond_dev->name);\n\t\t}\n\t} else {\n\t\tpr_debug(\"%s: ! NETIF_F_VLAN_CHALLENGED\\n\", slave_dev->name);\n\t}\n\n\t/*\n\t * Old ifenslave binaries are no longer supported.  These can\n\t * be identified with moderate accuracy by the state of the slave:\n\t * the current ifenslave will set the interface down prior to\n\t * enslaving it; the old ifenslave will not.\n\t */\n\tif ((slave_dev->flags & IFF_UP)) {\n\t\tpr_err(\"%s is up. This may be due to an out of date ifenslave.\\n\",\n\t\t       slave_dev->name);\n\t\tres = -EPERM;\n\t\tgoto err_undo_flags;\n\t}\n\n\t/* set bonding device ether type by slave - bonding netdevices are\n\t * created with ether_setup, so when the slave type is not ARPHRD_ETHER\n\t * there is a need to override some of the type dependent attribs/funcs.\n\t *\n\t * bond ether type mutual exclusion - don't allow slaves of dissimilar\n\t * ether type (eg ARPHRD_ETHER and ARPHRD_INFINIBAND) share the same bond\n\t */\n\tif (bond->slave_cnt == 0) {\n\t\tif (bond_dev->type != slave_dev->type) {\n\t\t\tpr_debug(\"%s: change device type from %d to %d\\n\",\n\t\t\t\t bond_dev->name,\n\t\t\t\t bond_dev->type, slave_dev->type);\n\n\t\t\tres = netdev_bonding_change(bond_dev,\n\t\t\t\t\t\t    NETDEV_PRE_TYPE_CHANGE);\n\t\t\tres = notifier_to_errno(res);\n\t\t\tif (res) {\n\t\t\t\tpr_err(\"%s: refused to change device type\\n\",\n\t\t\t\t       bond_dev->name);\n\t\t\t\tres = -EBUSY;\n\t\t\t\tgoto err_undo_flags;\n\t\t\t}\n\n\t\t\t/* Flush unicast and multicast addresses */\n\t\t\tdev_uc_flush(bond_dev);\n\t\t\tdev_mc_flush(bond_dev);\n\n\t\t\tif (slave_dev->type != ARPHRD_ETHER)\n\t\t\t\tbond_setup_by_slave(bond_dev, slave_dev);\n\t\t\telse\n\t\t\t\tether_setup(bond_dev);\n\n\t\t\tnetdev_bonding_change(bond_dev,\n\t\t\t\t\t      NETDEV_POST_TYPE_CHANGE);\n\t\t}\n\t} else if (bond_dev->type != slave_dev->type) {\n\t\tpr_err(\"%s ether type (%d) is different from other slaves (%d), can not enslave it.\\n\",\n\t\t       slave_dev->name,\n\t\t       slave_dev->type, bond_dev->type);\n\t\tres = -EINVAL;\n\t\tgoto err_undo_flags;\n\t}\n\n\tif (slave_ops->ndo_set_mac_address == NULL) {\n\t\tif (bond->slave_cnt == 0) {\n\t\t\tpr_warning(\"%s: Warning: The first slave device specified does not support setting the MAC address. Setting fail_over_mac to active.\",\n\t\t\t\t   bond_dev->name);\n\t\t\tbond->params.fail_over_mac = BOND_FOM_ACTIVE;\n\t\t} else if (bond->params.fail_over_mac != BOND_FOM_ACTIVE) {\n\t\t\tpr_err(\"%s: Error: The slave device specified does not support setting the MAC address, but fail_over_mac is not set to active.\\n\",\n\t\t\t       bond_dev->name);\n\t\t\tres = -EOPNOTSUPP;\n\t\t\tgoto err_undo_flags;\n\t\t}\n\t}\n\n\tcall_netdevice_notifiers(NETDEV_JOIN, slave_dev);\n\n\t/* If this is the first slave, then we need to set the master's hardware\n\t * address to be the same as the slave's. */\n\tif (is_zero_ether_addr(bond->dev->dev_addr))\n\t\tmemcpy(bond->dev->dev_addr, slave_dev->dev_addr,\n\t\t       slave_dev->addr_len);\n\n\n\tnew_slave = kzalloc(sizeof(struct slave), GFP_KERNEL);\n\tif (!new_slave) {\n\t\tres = -ENOMEM;\n\t\tgoto err_undo_flags;\n\t}\n\n\t/*\n\t * Set the new_slave's queue_id to be zero.  Queue ID mapping\n\t * is set via sysfs or module option if desired.\n\t */\n\tnew_slave->queue_id = 0;\n\n\t/* Save slave's original mtu and then set it to match the bond */\n\tnew_slave->original_mtu = slave_dev->mtu;\n\tres = dev_set_mtu(slave_dev, bond->dev->mtu);\n\tif (res) {\n\t\tpr_debug(\"Error %d calling dev_set_mtu\\n\", res);\n\t\tgoto err_free;\n\t}\n\n\t/*\n\t * Save slave's original (\"permanent\") mac address for modes\n\t * that need it, and for restoring it upon release, and then\n\t * set it to the master's address\n\t */\n\tmemcpy(new_slave->perm_hwaddr, slave_dev->dev_addr, ETH_ALEN);\n\n\tif (!bond->params.fail_over_mac) {\n\t\t/*\n\t\t * Set slave to master's mac address.  The application already\n\t\t * set the master's mac address to that of the first slave\n\t\t */\n\t\tmemcpy(addr.sa_data, bond_dev->dev_addr, bond_dev->addr_len);\n\t\taddr.sa_family = slave_dev->type;\n\t\tres = dev_set_mac_address(slave_dev, &addr);\n\t\tif (res) {\n\t\t\tpr_debug(\"Error %d calling set_mac_address\\n\", res);\n\t\t\tgoto err_restore_mtu;\n\t\t}\n\t}\n\n\tres = netdev_set_bond_master(slave_dev, bond_dev);\n\tif (res) {\n\t\tpr_debug(\"Error %d calling netdev_set_bond_master\\n\", res);\n\t\tgoto err_restore_mac;\n\t}\n\n\t/* open the slave since the application closed it */\n\tres = dev_open(slave_dev);\n\tif (res) {\n\t\tpr_debug(\"Opening slave %s failed\\n\", slave_dev->name);\n\t\tgoto err_unset_master;\n\t}\n\n\tnew_slave->bond = bond;\n\tnew_slave->dev = slave_dev;\n\tslave_dev->priv_flags |= IFF_BONDING;\n\n\tif (bond_is_lb(bond)) {\n\t\t/* bond_alb_init_slave() must be called before all other stages since\n\t\t * it might fail and we do not want to have to undo everything\n\t\t */\n\t\tres = bond_alb_init_slave(bond, new_slave);\n\t\tif (res)\n\t\t\tgoto err_close;\n\t}\n\n\t/* If the mode USES_PRIMARY, then the new slave gets the\n\t * master's promisc (and mc) settings only if it becomes the\n\t * curr_active_slave, and that is taken care of later when calling\n\t * bond_change_active()\n\t */\n\tif (!USES_PRIMARY(bond->params.mode)) {\n\t\t/* set promiscuity level to new slave */\n\t\tif (bond_dev->flags & IFF_PROMISC) {\n\t\t\tres = dev_set_promiscuity(slave_dev, 1);\n\t\t\tif (res)\n\t\t\t\tgoto err_close;\n\t\t}\n\n\t\t/* set allmulti level to new slave */\n\t\tif (bond_dev->flags & IFF_ALLMULTI) {\n\t\t\tres = dev_set_allmulti(slave_dev, 1);\n\t\t\tif (res)\n\t\t\t\tgoto err_close;\n\t\t}\n\n\t\tnetif_addr_lock_bh(bond_dev);\n\t\t/* upload master's mc_list to new slave */\n\t\tnetdev_for_each_mc_addr(ha, bond_dev)\n\t\t\tdev_mc_add(slave_dev, ha->addr);\n\t\tnetif_addr_unlock_bh(bond_dev);\n\t}\n\n\tif (bond->params.mode == BOND_MODE_8023AD) {\n\t\t/* add lacpdu mc addr to mc list */\n\t\tu8 lacpdu_multicast[ETH_ALEN] = MULTICAST_LACPDU_ADDR;\n\n\t\tdev_mc_add(slave_dev, lacpdu_multicast);\n\t}\n\n\tbond_add_vlans_on_slave(bond, slave_dev);\n\n\twrite_lock_bh(&bond->lock);\n\n\tbond_attach_slave(bond, new_slave);\n\n\tnew_slave->delay = 0;\n\tnew_slave->link_failure_count = 0;\n\n\twrite_unlock_bh(&bond->lock);\n\n\tbond_compute_features(bond);\n\n\tread_lock(&bond->lock);\n\n\tnew_slave->last_arp_rx = jiffies;\n\n\tif (bond->params.miimon && !bond->params.use_carrier) {\n\t\tlink_reporting = bond_check_dev_link(bond, slave_dev, 1);\n\n\t\tif ((link_reporting == -1) && !bond->params.arp_interval) {\n\t\t\t/*\n\t\t\t * miimon is set but a bonded network driver\n\t\t\t * does not support ETHTOOL/MII and\n\t\t\t * arp_interval is not set.  Note: if\n\t\t\t * use_carrier is enabled, we will never go\n\t\t\t * here (because netif_carrier is always\n\t\t\t * supported); thus, we don't need to change\n\t\t\t * the messages for netif_carrier.\n\t\t\t */\n\t\t\tpr_warning(\"%s: Warning: MII and ETHTOOL support not available for interface %s, and arp_interval/arp_ip_target module parameters not specified, thus bonding will not detect link failures! see bonding.txt for details.\\n\",\n\t\t\t       bond_dev->name, slave_dev->name);\n\t\t} else if (link_reporting == -1) {\n\t\t\t/* unable get link status using mii/ethtool */\n\t\t\tpr_warning(\"%s: Warning: can't get link status from interface %s; the network driver associated with this interface does not support MII or ETHTOOL link status reporting, thus miimon has no effect on this interface.\\n\",\n\t\t\t\t   bond_dev->name, slave_dev->name);\n\t\t}\n\t}\n\n\t/* check for initial state */\n\tif (!bond->params.miimon ||\n\t    (bond_check_dev_link(bond, slave_dev, 0) == BMSR_LSTATUS)) {\n\t\tif (bond->params.updelay) {\n\t\t\tpr_debug(\"Initial state of slave_dev is BOND_LINK_BACK\\n\");\n\t\t\tnew_slave->link  = BOND_LINK_BACK;\n\t\t\tnew_slave->delay = bond->params.updelay;\n\t\t} else {\n\t\t\tpr_debug(\"Initial state of slave_dev is BOND_LINK_UP\\n\");\n\t\t\tnew_slave->link  = BOND_LINK_UP;\n\t\t}\n\t\tnew_slave->jiffies = jiffies;\n\t} else {\n\t\tpr_debug(\"Initial state of slave_dev is BOND_LINK_DOWN\\n\");\n\t\tnew_slave->link  = BOND_LINK_DOWN;\n\t}\n\n\tif (bond_update_speed_duplex(new_slave) &&\n\t    (new_slave->link != BOND_LINK_DOWN)) {\n\t\tpr_warning(\"%s: Warning: failed to get speed and duplex from %s, assumed to be 100Mb/sec and Full.\\n\",\n\t\t\t   bond_dev->name, new_slave->dev->name);\n\n\t\tif (bond->params.mode == BOND_MODE_8023AD) {\n\t\t\tpr_warning(\"%s: Warning: Operation of 802.3ad mode requires ETHTOOL support in base driver for proper aggregator selection.\\n\",\n\t\t\t\t   bond_dev->name);\n\t\t}\n\t}\n\n\tif (USES_PRIMARY(bond->params.mode) && bond->params.primary[0]) {\n\t\t/* if there is a primary slave, remember it */\n\t\tif (strcmp(bond->params.primary, new_slave->dev->name) == 0) {\n\t\t\tbond->primary_slave = new_slave;\n\t\t\tbond->force_primary = true;\n\t\t}\n\t}\n\n\twrite_lock_bh(&bond->curr_slave_lock);\n\n\tswitch (bond->params.mode) {\n\tcase BOND_MODE_ACTIVEBACKUP:\n\t\tbond_set_slave_inactive_flags(new_slave);\n\t\tbond_select_active_slave(bond);\n\t\tbreak;\n\tcase BOND_MODE_8023AD:\n\t\t/* in 802.3ad mode, the internal mechanism\n\t\t * will activate the slaves in the selected\n\t\t * aggregator\n\t\t */\n\t\tbond_set_slave_inactive_flags(new_slave);\n\t\t/* if this is the first slave */\n\t\tif (bond->slave_cnt == 1) {\n\t\t\tSLAVE_AD_INFO(new_slave).id = 1;\n\t\t\t/* Initialize AD with the number of times that the AD timer is called in 1 second\n\t\t\t * can be called only after the mac address of the bond is set\n\t\t\t */\n\t\t\tbond_3ad_initialize(bond, 1000/AD_TIMER_INTERVAL);\n\t\t} else {\n\t\t\tSLAVE_AD_INFO(new_slave).id =\n\t\t\t\tSLAVE_AD_INFO(new_slave->prev).id + 1;\n\t\t}\n\n\t\tbond_3ad_bind_slave(new_slave);\n\t\tbreak;\n\tcase BOND_MODE_TLB:\n\tcase BOND_MODE_ALB:\n\t\tbond_set_active_slave(new_slave);\n\t\tbond_set_slave_inactive_flags(new_slave);\n\t\tbond_select_active_slave(bond);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"This slave is always active in trunk mode\\n\");\n\n\t\t/* always active in trunk mode */\n\t\tbond_set_active_slave(new_slave);\n\n\t\t/* In trunking mode there is little meaning to curr_active_slave\n\t\t * anyway (it holds no special properties of the bond device),\n\t\t * so we can change it without calling change_active_interface()\n\t\t */\n\t\tif (!bond->curr_active_slave)\n\t\t\tbond->curr_active_slave = new_slave;\n\n\t\tbreak;\n\t} /* switch(bond_mode) */\n\n\twrite_unlock_bh(&bond->curr_slave_lock);\n\n\tbond_set_carrier(bond);\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\tslave_dev->npinfo = bond_netpoll_info(bond);\n\tif (slave_dev->npinfo) {\n\t\tif (slave_enable_netpoll(new_slave)) {\n\t\t\tread_unlock(&bond->lock);\n\t\t\tpr_info(\"Error, %s: master_dev is using netpoll, \"\n\t\t\t\t \"but new slave device does not support netpoll.\\n\",\n\t\t\t\t bond_dev->name);\n\t\t\tres = -EBUSY;\n\t\t\tgoto err_close;\n\t\t}\n\t}\n#endif\n\n\tread_unlock(&bond->lock);\n\n\tres = bond_create_slave_symlinks(bond_dev, slave_dev);\n\tif (res)\n\t\tgoto err_close;\n\n\tres = netdev_rx_handler_register(slave_dev, bond_handle_frame,\n\t\t\t\t\t new_slave);\n\tif (res) {\n\t\tpr_debug(\"Error %d calling netdev_rx_handler_register\\n\", res);\n\t\tgoto err_dest_symlinks;\n\t}\n\n\tpr_info(\"%s: enslaving %s as a%s interface with a%s link.\\n\",\n\t\tbond_dev->name, slave_dev->name,\n\t\tbond_is_active_slave(new_slave) ? \"n active\" : \" backup\",\n\t\tnew_slave->link != BOND_LINK_DOWN ? \"n up\" : \" down\");\n\n\t/* enslave is successful */\n\treturn 0;\n\n/* Undo stages on error */\nerr_dest_symlinks:\n\tbond_destroy_slave_symlinks(bond_dev, slave_dev);\n\nerr_close:\n\tdev_close(slave_dev);\n\nerr_unset_master:\n\tnetdev_set_bond_master(slave_dev, NULL);\n\nerr_restore_mac:\n\tif (!bond->params.fail_over_mac) {\n\t\t/* XXX TODO - fom follow mode needs to change master's\n\t\t * MAC if this slave's MAC is in use by the bond, or at\n\t\t * least print a warning.\n\t\t */\n\t\tmemcpy(addr.sa_data, new_slave->perm_hwaddr, ETH_ALEN);\n\t\taddr.sa_family = slave_dev->type;\n\t\tdev_set_mac_address(slave_dev, &addr);\n\t}\n\nerr_restore_mtu:\n\tdev_set_mtu(slave_dev, new_slave->original_mtu);\n\nerr_free:\n\tkfree(new_slave);\n\nerr_undo_flags:\n\tbond_compute_features(bond);\n\n\treturn res;\n}\n\n/*\n * Try to release the slave device <slave> from the bond device <master>\n * It is legal to access curr_active_slave without a lock because all the function\n * is write-locked.\n *\n * The rules for slave state should be:\n *   for Active/Backup:\n *     Active stays on all backups go down\n *   for Bonded connections:\n *     The first up interface should be left on and all others downed.\n */\nint bond_release(struct net_device *bond_dev, struct net_device *slave_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct slave *slave, *oldcurrent;\n\tstruct sockaddr addr;\n\tu32 old_features = bond_dev->features;\n\n\t/* slave is not a slave or master is not master of this slave */\n\tif (!(slave_dev->flags & IFF_SLAVE) ||\n\t    (slave_dev->master != bond_dev)) {\n\t\tpr_err(\"%s: Error: cannot release %s.\\n\",\n\t\t       bond_dev->name, slave_dev->name);\n\t\treturn -EINVAL;\n\t}\n\n\tblock_netpoll_tx();\n\tnetdev_bonding_change(bond_dev, NETDEV_RELEASE);\n\twrite_lock_bh(&bond->lock);\n\n\tslave = bond_get_slave_by_dev(bond, slave_dev);\n\tif (!slave) {\n\t\t/* not a slave of this bond */\n\t\tpr_info(\"%s: %s not enslaved\\n\",\n\t\t\tbond_dev->name, slave_dev->name);\n\t\twrite_unlock_bh(&bond->lock);\n\t\tunblock_netpoll_tx();\n\t\treturn -EINVAL;\n\t}\n\n\t/* unregister rx_handler early so bond_handle_frame wouldn't be called\n\t * for this slave anymore.\n\t */\n\tnetdev_rx_handler_unregister(slave_dev);\n\twrite_unlock_bh(&bond->lock);\n\tsynchronize_net();\n\twrite_lock_bh(&bond->lock);\n\n\tif (!bond->params.fail_over_mac) {\n\t\tif (!compare_ether_addr(bond_dev->dev_addr, slave->perm_hwaddr) &&\n\t\t    bond->slave_cnt > 1)\n\t\t\tpr_warning(\"%s: Warning: the permanent HWaddr of %s - %pM - is still in use by %s. Set the HWaddr of %s to a different address to avoid conflicts.\\n\",\n\t\t\t\t   bond_dev->name, slave_dev->name,\n\t\t\t\t   slave->perm_hwaddr,\n\t\t\t\t   bond_dev->name, slave_dev->name);\n\t}\n\n\t/* Inform AD package of unbinding of slave. */\n\tif (bond->params.mode == BOND_MODE_8023AD) {\n\t\t/* must be called before the slave is\n\t\t * detached from the list\n\t\t */\n\t\tbond_3ad_unbind_slave(slave);\n\t}\n\n\tpr_info(\"%s: releasing %s interface %s\\n\",\n\t\tbond_dev->name,\n\t\tbond_is_active_slave(slave) ? \"active\" : \"backup\",\n\t\tslave_dev->name);\n\n\toldcurrent = bond->curr_active_slave;\n\n\tbond->current_arp_slave = NULL;\n\n\t/* release the slave from its bond */\n\tbond_detach_slave(bond, slave);\n\n\tif (bond->primary_slave == slave)\n\t\tbond->primary_slave = NULL;\n\n\tif (oldcurrent == slave)\n\t\tbond_change_active_slave(bond, NULL);\n\n\tif (bond_is_lb(bond)) {\n\t\t/* Must be called only after the slave has been\n\t\t * detached from the list and the curr_active_slave\n\t\t * has been cleared (if our_slave == old_current),\n\t\t * but before a new active slave is selected.\n\t\t */\n\t\twrite_unlock_bh(&bond->lock);\n\t\tbond_alb_deinit_slave(bond, slave);\n\t\twrite_lock_bh(&bond->lock);\n\t}\n\n\tif (oldcurrent == slave) {\n\t\t/*\n\t\t * Note that we hold RTNL over this sequence, so there\n\t\t * is no concern that another slave add/remove event\n\t\t * will interfere.\n\t\t */\n\t\twrite_unlock_bh(&bond->lock);\n\t\tread_lock(&bond->lock);\n\t\twrite_lock_bh(&bond->curr_slave_lock);\n\n\t\tbond_select_active_slave(bond);\n\n\t\twrite_unlock_bh(&bond->curr_slave_lock);\n\t\tread_unlock(&bond->lock);\n\t\twrite_lock_bh(&bond->lock);\n\t}\n\n\tif (bond->slave_cnt == 0) {\n\t\tbond_set_carrier(bond);\n\n\t\t/* if the last slave was removed, zero the mac address\n\t\t * of the master so it will be set by the application\n\t\t * to the mac address of the first slave\n\t\t */\n\t\tmemset(bond_dev->dev_addr, 0, bond_dev->addr_len);\n\n\t\tif (bond_vlan_used(bond)) {\n\t\t\tpr_warning(\"%s: Warning: clearing HW address of %s while it still has VLANs.\\n\",\n\t\t\t\t   bond_dev->name, bond_dev->name);\n\t\t\tpr_warning(\"%s: When re-adding slaves, make sure the bond's HW address matches its VLANs'.\\n\",\n\t\t\t\t   bond_dev->name);\n\t\t}\n\t}\n\n\twrite_unlock_bh(&bond->lock);\n\tunblock_netpoll_tx();\n\n\tbond_compute_features(bond);\n\tif (!(bond_dev->features & NETIF_F_VLAN_CHALLENGED) &&\n\t    (old_features & NETIF_F_VLAN_CHALLENGED))\n\t\tpr_info(\"%s: last VLAN challenged slave %s left bond %s. VLAN blocking is removed\\n\",\n\t\t\tbond_dev->name, slave_dev->name, bond_dev->name);\n\n\t/* must do this from outside any spinlocks */\n\tbond_destroy_slave_symlinks(bond_dev, slave_dev);\n\n\tbond_del_vlans_from_slave(bond, slave_dev);\n\n\t/* If the mode USES_PRIMARY, then we should only remove its\n\t * promisc and mc settings if it was the curr_active_slave, but that was\n\t * already taken care of above when we detached the slave\n\t */\n\tif (!USES_PRIMARY(bond->params.mode)) {\n\t\t/* unset promiscuity level from slave */\n\t\tif (bond_dev->flags & IFF_PROMISC)\n\t\t\tdev_set_promiscuity(slave_dev, -1);\n\n\t\t/* unset allmulti level from slave */\n\t\tif (bond_dev->flags & IFF_ALLMULTI)\n\t\t\tdev_set_allmulti(slave_dev, -1);\n\n\t\t/* flush master's mc_list from slave */\n\t\tnetif_addr_lock_bh(bond_dev);\n\t\tbond_mc_list_flush(bond_dev, slave_dev);\n\t\tnetif_addr_unlock_bh(bond_dev);\n\t}\n\n\tnetdev_set_bond_master(slave_dev, NULL);\n\n\tslave_disable_netpoll(slave);\n\n\t/* close slave before restoring its mac address */\n\tdev_close(slave_dev);\n\n\tif (bond->params.fail_over_mac != BOND_FOM_ACTIVE) {\n\t\t/* restore original (\"permanent\") mac address */\n\t\tmemcpy(addr.sa_data, slave->perm_hwaddr, ETH_ALEN);\n\t\taddr.sa_family = slave_dev->type;\n\t\tdev_set_mac_address(slave_dev, &addr);\n\t}\n\n\tdev_set_mtu(slave_dev, slave->original_mtu);\n\n\tslave_dev->priv_flags &= ~IFF_BONDING;\n\n\tkfree(slave);\n\n\treturn 0;  /* deletion OK */\n}\n\n/*\n* First release a slave and then destroy the bond if no more slaves are left.\n* Must be under rtnl_lock when this function is called.\n*/\nstatic int  bond_release_and_destroy(struct net_device *bond_dev,\n\t\t\t\t     struct net_device *slave_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tint ret;\n\n\tret = bond_release(bond_dev, slave_dev);\n\tif ((ret == 0) && (bond->slave_cnt == 0)) {\n\t\tbond_dev->priv_flags |= IFF_DISABLE_NETPOLL;\n\t\tpr_info(\"%s: destroying bond %s.\\n\",\n\t\t\tbond_dev->name, bond_dev->name);\n\t\tunregister_netdevice(bond_dev);\n\t}\n\treturn ret;\n}\n\n/*\n * This function releases all slaves.\n */\nstatic int bond_release_all(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct slave *slave;\n\tstruct net_device *slave_dev;\n\tstruct sockaddr addr;\n\n\twrite_lock_bh(&bond->lock);\n\n\tnetif_carrier_off(bond_dev);\n\n\tif (bond->slave_cnt == 0)\n\t\tgoto out;\n\n\tbond->current_arp_slave = NULL;\n\tbond->primary_slave = NULL;\n\tbond_change_active_slave(bond, NULL);\n\n\twhile ((slave = bond->first_slave) != NULL) {\n\t\t/* Inform AD package of unbinding of slave\n\t\t * before slave is detached from the list.\n\t\t */\n\t\tif (bond->params.mode == BOND_MODE_8023AD)\n\t\t\tbond_3ad_unbind_slave(slave);\n\n\t\tslave_dev = slave->dev;\n\t\tbond_detach_slave(bond, slave);\n\n\t\t/* now that the slave is detached, unlock and perform\n\t\t * all the undo steps that should not be called from\n\t\t * within a lock.\n\t\t */\n\t\twrite_unlock_bh(&bond->lock);\n\n\t\t/* unregister rx_handler early so bond_handle_frame wouldn't\n\t\t * be called for this slave anymore.\n\t\t */\n\t\tnetdev_rx_handler_unregister(slave_dev);\n\t\tsynchronize_net();\n\n\t\tif (bond_is_lb(bond)) {\n\t\t\t/* must be called only after the slave\n\t\t\t * has been detached from the list\n\t\t\t */\n\t\t\tbond_alb_deinit_slave(bond, slave);\n\t\t}\n\n\t\tbond_destroy_slave_symlinks(bond_dev, slave_dev);\n\t\tbond_del_vlans_from_slave(bond, slave_dev);\n\n\t\t/* If the mode USES_PRIMARY, then we should only remove its\n\t\t * promisc and mc settings if it was the curr_active_slave, but that was\n\t\t * already taken care of above when we detached the slave\n\t\t */\n\t\tif (!USES_PRIMARY(bond->params.mode)) {\n\t\t\t/* unset promiscuity level from slave */\n\t\t\tif (bond_dev->flags & IFF_PROMISC)\n\t\t\t\tdev_set_promiscuity(slave_dev, -1);\n\n\t\t\t/* unset allmulti level from slave */\n\t\t\tif (bond_dev->flags & IFF_ALLMULTI)\n\t\t\t\tdev_set_allmulti(slave_dev, -1);\n\n\t\t\t/* flush master's mc_list from slave */\n\t\t\tnetif_addr_lock_bh(bond_dev);\n\t\t\tbond_mc_list_flush(bond_dev, slave_dev);\n\t\t\tnetif_addr_unlock_bh(bond_dev);\n\t\t}\n\n\t\tnetdev_set_bond_master(slave_dev, NULL);\n\n\t\tslave_disable_netpoll(slave);\n\n\t\t/* close slave before restoring its mac address */\n\t\tdev_close(slave_dev);\n\n\t\tif (!bond->params.fail_over_mac) {\n\t\t\t/* restore original (\"permanent\") mac address*/\n\t\t\tmemcpy(addr.sa_data, slave->perm_hwaddr, ETH_ALEN);\n\t\t\taddr.sa_family = slave_dev->type;\n\t\t\tdev_set_mac_address(slave_dev, &addr);\n\t\t}\n\n\t\tkfree(slave);\n\n\t\t/* re-acquire the lock before getting the next slave */\n\t\twrite_lock_bh(&bond->lock);\n\t}\n\n\t/* zero the mac address of the master so it will be\n\t * set by the application to the mac address of the\n\t * first slave\n\t */\n\tmemset(bond_dev->dev_addr, 0, bond_dev->addr_len);\n\n\tif (bond_vlan_used(bond)) {\n\t\tpr_warning(\"%s: Warning: clearing HW address of %s while it still has VLANs.\\n\",\n\t\t\t   bond_dev->name, bond_dev->name);\n\t\tpr_warning(\"%s: When re-adding slaves, make sure the bond's HW address matches its VLANs'.\\n\",\n\t\t\t   bond_dev->name);\n\t}\n\n\tpr_info(\"%s: released all slaves\\n\", bond_dev->name);\n\nout:\n\twrite_unlock_bh(&bond->lock);\n\n\tbond_compute_features(bond);\n\n\treturn 0;\n}\n\n/*\n * This function changes the active slave to slave <slave_dev>.\n * It returns -EINVAL in the following cases.\n *  - <slave_dev> is not found in the list.\n *  - There is not active slave now.\n *  - <slave_dev> is already active.\n *  - The link state of <slave_dev> is not BOND_LINK_UP.\n *  - <slave_dev> is not running.\n * In these cases, this function does nothing.\n * In the other cases, current_slave pointer is changed and 0 is returned.\n */\nstatic int bond_ioctl_change_active(struct net_device *bond_dev, struct net_device *slave_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct slave *old_active = NULL;\n\tstruct slave *new_active = NULL;\n\tint res = 0;\n\n\tif (!USES_PRIMARY(bond->params.mode))\n\t\treturn -EINVAL;\n\n\t/* Verify that master_dev is indeed the master of slave_dev */\n\tif (!(slave_dev->flags & IFF_SLAVE) || (slave_dev->master != bond_dev))\n\t\treturn -EINVAL;\n\n\tread_lock(&bond->lock);\n\n\tread_lock(&bond->curr_slave_lock);\n\told_active = bond->curr_active_slave;\n\tread_unlock(&bond->curr_slave_lock);\n\n\tnew_active = bond_get_slave_by_dev(bond, slave_dev);\n\n\t/*\n\t * Changing to the current active: do nothing; return success.\n\t */\n\tif (new_active && (new_active == old_active)) {\n\t\tread_unlock(&bond->lock);\n\t\treturn 0;\n\t}\n\n\tif ((new_active) &&\n\t    (old_active) &&\n\t    (new_active->link == BOND_LINK_UP) &&\n\t    IS_UP(new_active->dev)) {\n\t\tblock_netpoll_tx();\n\t\twrite_lock_bh(&bond->curr_slave_lock);\n\t\tbond_change_active_slave(bond, new_active);\n\t\twrite_unlock_bh(&bond->curr_slave_lock);\n\t\tunblock_netpoll_tx();\n\t} else\n\t\tres = -EINVAL;\n\n\tread_unlock(&bond->lock);\n\n\treturn res;\n}\n\nstatic int bond_info_query(struct net_device *bond_dev, struct ifbond *info)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\n\tinfo->bond_mode = bond->params.mode;\n\tinfo->miimon = bond->params.miimon;\n\n\tread_lock(&bond->lock);\n\tinfo->num_slaves = bond->slave_cnt;\n\tread_unlock(&bond->lock);\n\n\treturn 0;\n}\n\nstatic int bond_slave_info_query(struct net_device *bond_dev, struct ifslave *info)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct slave *slave;\n\tint i, res = -ENODEV;\n\n\tread_lock(&bond->lock);\n\n\tbond_for_each_slave(bond, slave, i) {\n\t\tif (i == (int)info->slave_id) {\n\t\t\tres = 0;\n\t\t\tstrcpy(info->slave_name, slave->dev->name);\n\t\t\tinfo->link = slave->link;\n\t\t\tinfo->state = bond_slave_state(slave);\n\t\t\tinfo->link_failure_count = slave->link_failure_count;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tread_unlock(&bond->lock);\n\n\treturn res;\n}\n\n/*-------------------------------- Monitoring -------------------------------*/\n\n\nstatic int bond_miimon_inspect(struct bonding *bond)\n{\n\tstruct slave *slave;\n\tint i, link_state, commit = 0;\n\tbool ignore_updelay;\n\n\tignore_updelay = !bond->curr_active_slave ? true : false;\n\n\tbond_for_each_slave(bond, slave, i) {\n\t\tslave->new_link = BOND_LINK_NOCHANGE;\n\n\t\tlink_state = bond_check_dev_link(bond, slave->dev, 0);\n\n\t\tswitch (slave->link) {\n\t\tcase BOND_LINK_UP:\n\t\t\tif (link_state)\n\t\t\t\tcontinue;\n\n\t\t\tslave->link = BOND_LINK_FAIL;\n\t\t\tslave->delay = bond->params.downdelay;\n\t\t\tif (slave->delay) {\n\t\t\t\tpr_info(\"%s: link status down for %sinterface %s, disabling it in %d ms.\\n\",\n\t\t\t\t\tbond->dev->name,\n\t\t\t\t\t(bond->params.mode ==\n\t\t\t\t\t BOND_MODE_ACTIVEBACKUP) ?\n\t\t\t\t\t(bond_is_active_slave(slave) ?\n\t\t\t\t\t \"active \" : \"backup \") : \"\",\n\t\t\t\t\tslave->dev->name,\n\t\t\t\t\tbond->params.downdelay * bond->params.miimon);\n\t\t\t}\n\t\t\t/*FALLTHRU*/\n\t\tcase BOND_LINK_FAIL:\n\t\t\tif (link_state) {\n\t\t\t\t/*\n\t\t\t\t * recovered before downdelay expired\n\t\t\t\t */\n\t\t\t\tslave->link = BOND_LINK_UP;\n\t\t\t\tslave->jiffies = jiffies;\n\t\t\t\tpr_info(\"%s: link status up again after %d ms for interface %s.\\n\",\n\t\t\t\t\tbond->dev->name,\n\t\t\t\t\t(bond->params.downdelay - slave->delay) *\n\t\t\t\t\tbond->params.miimon,\n\t\t\t\t\tslave->dev->name);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (slave->delay <= 0) {\n\t\t\t\tslave->new_link = BOND_LINK_DOWN;\n\t\t\t\tcommit++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tslave->delay--;\n\t\t\tbreak;\n\n\t\tcase BOND_LINK_DOWN:\n\t\t\tif (!link_state)\n\t\t\t\tcontinue;\n\n\t\t\tslave->link = BOND_LINK_BACK;\n\t\t\tslave->delay = bond->params.updelay;\n\n\t\t\tif (slave->delay) {\n\t\t\t\tpr_info(\"%s: link status up for interface %s, enabling it in %d ms.\\n\",\n\t\t\t\t\tbond->dev->name, slave->dev->name,\n\t\t\t\t\tignore_updelay ? 0 :\n\t\t\t\t\tbond->params.updelay *\n\t\t\t\t\tbond->params.miimon);\n\t\t\t}\n\t\t\t/*FALLTHRU*/\n\t\tcase BOND_LINK_BACK:\n\t\t\tif (!link_state) {\n\t\t\t\tslave->link = BOND_LINK_DOWN;\n\t\t\t\tpr_info(\"%s: link status down again after %d ms for interface %s.\\n\",\n\t\t\t\t\tbond->dev->name,\n\t\t\t\t\t(bond->params.updelay - slave->delay) *\n\t\t\t\t\tbond->params.miimon,\n\t\t\t\t\tslave->dev->name);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (ignore_updelay)\n\t\t\t\tslave->delay = 0;\n\n\t\t\tif (slave->delay <= 0) {\n\t\t\t\tslave->new_link = BOND_LINK_UP;\n\t\t\t\tcommit++;\n\t\t\t\tignore_updelay = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tslave->delay--;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn commit;\n}\n\nstatic void bond_miimon_commit(struct bonding *bond)\n{\n\tstruct slave *slave;\n\tint i;\n\n\tbond_for_each_slave(bond, slave, i) {\n\t\tswitch (slave->new_link) {\n\t\tcase BOND_LINK_NOCHANGE:\n\t\t\tcontinue;\n\n\t\tcase BOND_LINK_UP:\n\t\t\tslave->link = BOND_LINK_UP;\n\t\t\tslave->jiffies = jiffies;\n\n\t\t\tif (bond->params.mode == BOND_MODE_8023AD) {\n\t\t\t\t/* prevent it from being the active one */\n\t\t\t\tbond_set_backup_slave(slave);\n\t\t\t} else if (bond->params.mode != BOND_MODE_ACTIVEBACKUP) {\n\t\t\t\t/* make it immediately active */\n\t\t\t\tbond_set_active_slave(slave);\n\t\t\t} else if (slave != bond->primary_slave) {\n\t\t\t\t/* prevent it from being the active one */\n\t\t\t\tbond_set_backup_slave(slave);\n\t\t\t}\n\n\t\t\tbond_update_speed_duplex(slave);\n\n\t\t\tpr_info(\"%s: link status definitely up for interface %s, %u Mbps %s duplex.\\n\",\n\t\t\t\tbond->dev->name, slave->dev->name,\n\t\t\t\tslave->speed, slave->duplex ? \"full\" : \"half\");\n\n\t\t\t/* notify ad that the link status has changed */\n\t\t\tif (bond->params.mode == BOND_MODE_8023AD)\n\t\t\t\tbond_3ad_handle_link_change(slave, BOND_LINK_UP);\n\n\t\t\tif (bond_is_lb(bond))\n\t\t\t\tbond_alb_handle_link_change(bond, slave,\n\t\t\t\t\t\t\t    BOND_LINK_UP);\n\n\t\t\tif (!bond->curr_active_slave ||\n\t\t\t    (slave == bond->primary_slave))\n\t\t\t\tgoto do_failover;\n\n\t\t\tcontinue;\n\n\t\tcase BOND_LINK_DOWN:\n\t\t\tif (slave->link_failure_count < UINT_MAX)\n\t\t\t\tslave->link_failure_count++;\n\n\t\t\tslave->link = BOND_LINK_DOWN;\n\n\t\t\tif (bond->params.mode == BOND_MODE_ACTIVEBACKUP ||\n\t\t\t    bond->params.mode == BOND_MODE_8023AD)\n\t\t\t\tbond_set_slave_inactive_flags(slave);\n\n\t\t\tpr_info(\"%s: link status definitely down for interface %s, disabling it\\n\",\n\t\t\t\tbond->dev->name, slave->dev->name);\n\n\t\t\tif (bond->params.mode == BOND_MODE_8023AD)\n\t\t\t\tbond_3ad_handle_link_change(slave,\n\t\t\t\t\t\t\t    BOND_LINK_DOWN);\n\n\t\t\tif (bond_is_lb(bond))\n\t\t\t\tbond_alb_handle_link_change(bond, slave,\n\t\t\t\t\t\t\t    BOND_LINK_DOWN);\n\n\t\t\tif (slave == bond->curr_active_slave)\n\t\t\t\tgoto do_failover;\n\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\tpr_err(\"%s: invalid new link %d on slave %s\\n\",\n\t\t\t       bond->dev->name, slave->new_link,\n\t\t\t       slave->dev->name);\n\t\t\tslave->new_link = BOND_LINK_NOCHANGE;\n\n\t\t\tcontinue;\n\t\t}\n\ndo_failover:\n\t\tASSERT_RTNL();\n\t\tblock_netpoll_tx();\n\t\twrite_lock_bh(&bond->curr_slave_lock);\n\t\tbond_select_active_slave(bond);\n\t\twrite_unlock_bh(&bond->curr_slave_lock);\n\t\tunblock_netpoll_tx();\n\t}\n\n\tbond_set_carrier(bond);\n}\n\n/*\n * bond_mii_monitor\n *\n * Really a wrapper that splits the mii monitor into two phases: an\n * inspection, then (if inspection indicates something needs to be done)\n * an acquisition of appropriate locks followed by a commit phase to\n * implement whatever link state changes are indicated.\n */\nvoid bond_mii_monitor(struct work_struct *work)\n{\n\tstruct bonding *bond = container_of(work, struct bonding,\n\t\t\t\t\t    mii_work.work);\n\tbool should_notify_peers = false;\n\n\tread_lock(&bond->lock);\n\tif (bond->kill_timers)\n\t\tgoto out;\n\n\tif (bond->slave_cnt == 0)\n\t\tgoto re_arm;\n\n\tshould_notify_peers = bond_should_notify_peers(bond);\n\n\tif (bond_miimon_inspect(bond)) {\n\t\tread_unlock(&bond->lock);\n\t\trtnl_lock();\n\t\tread_lock(&bond->lock);\n\n\t\tbond_miimon_commit(bond);\n\n\t\tread_unlock(&bond->lock);\n\t\trtnl_unlock();\t/* might sleep, hold no other locks */\n\t\tread_lock(&bond->lock);\n\t}\n\nre_arm:\n\tif (bond->params.miimon)\n\t\tqueue_delayed_work(bond->wq, &bond->mii_work,\n\t\t\t\t   msecs_to_jiffies(bond->params.miimon));\nout:\n\tread_unlock(&bond->lock);\n\n\tif (should_notify_peers) {\n\t\trtnl_lock();\n\t\tnetdev_bonding_change(bond->dev, NETDEV_NOTIFY_PEERS);\n\t\trtnl_unlock();\n\t}\n}\n\nstatic __be32 bond_glean_dev_ip(struct net_device *dev)\n{\n\tstruct in_device *idev;\n\tstruct in_ifaddr *ifa;\n\t__be32 addr = 0;\n\n\tif (!dev)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tidev = __in_dev_get_rcu(dev);\n\tif (!idev)\n\t\tgoto out;\n\n\tifa = idev->ifa_list;\n\tif (!ifa)\n\t\tgoto out;\n\n\taddr = ifa->ifa_local;\nout:\n\trcu_read_unlock();\n\treturn addr;\n}\n\nstatic int bond_has_this_ip(struct bonding *bond, __be32 ip)\n{\n\tstruct vlan_entry *vlan;\n\n\tif (ip == bond->master_ip)\n\t\treturn 1;\n\n\tlist_for_each_entry(vlan, &bond->vlan_list, vlan_list) {\n\t\tif (ip == vlan->vlan_ip)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n/*\n * We go to the (large) trouble of VLAN tagging ARP frames because\n * switches in VLAN mode (especially if ports are configured as\n * \"native\" to a VLAN) might not pass non-tagged frames.\n */\nstatic void bond_arp_send(struct net_device *slave_dev, int arp_op, __be32 dest_ip, __be32 src_ip, unsigned short vlan_id)\n{\n\tstruct sk_buff *skb;\n\n\tpr_debug(\"arp %d on slave %s: dst %x src %x vid %d\\n\", arp_op,\n\t\t slave_dev->name, dest_ip, src_ip, vlan_id);\n\n\tskb = arp_create(arp_op, ETH_P_ARP, dest_ip, slave_dev, src_ip,\n\t\t\t NULL, slave_dev->dev_addr, NULL);\n\n\tif (!skb) {\n\t\tpr_err(\"ARP packet allocation failed\\n\");\n\t\treturn;\n\t}\n\tif (vlan_id) {\n\t\tskb = vlan_put_tag(skb, vlan_id);\n\t\tif (!skb) {\n\t\t\tpr_err(\"failed to insert VLAN tag\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\tarp_xmit(skb);\n}\n\n\nstatic void bond_arp_send_all(struct bonding *bond, struct slave *slave)\n{\n\tint i, vlan_id;\n\t__be32 *targets = bond->params.arp_targets;\n\tstruct vlan_entry *vlan;\n\tstruct net_device *vlan_dev;\n\tstruct rtable *rt;\n\n\tfor (i = 0; (i < BOND_MAX_ARP_TARGETS); i++) {\n\t\tif (!targets[i])\n\t\t\tbreak;\n\t\tpr_debug(\"basa: target %x\\n\", targets[i]);\n\t\tif (!bond_vlan_used(bond)) {\n\t\t\tpr_debug(\"basa: empty vlan: arp_send\\n\");\n\t\t\tbond_arp_send(slave->dev, ARPOP_REQUEST, targets[i],\n\t\t\t\t      bond->master_ip, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If VLANs are configured, we do a route lookup to\n\t\t * determine which VLAN interface would be used, so we\n\t\t * can tag the ARP with the proper VLAN tag.\n\t\t */\n\t\trt = ip_route_output(dev_net(bond->dev), targets[i], 0,\n\t\t\t\t     RTO_ONLINK, 0);\n\t\tif (IS_ERR(rt)) {\n\t\t\tif (net_ratelimit()) {\n\t\t\t\tpr_warning(\"%s: no route to arp_ip_target %pI4\\n\",\n\t\t\t\t\t   bond->dev->name, &targets[i]);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * This target is not on a VLAN\n\t\t */\n\t\tif (rt->dst.dev == bond->dev) {\n\t\t\tip_rt_put(rt);\n\t\t\tpr_debug(\"basa: rtdev == bond->dev: arp_send\\n\");\n\t\t\tbond_arp_send(slave->dev, ARPOP_REQUEST, targets[i],\n\t\t\t\t      bond->master_ip, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\tvlan_id = 0;\n\t\tlist_for_each_entry(vlan, &bond->vlan_list, vlan_list) {\n\t\t\trcu_read_lock();\n\t\t\tvlan_dev = __vlan_find_dev_deep(bond->dev,\n\t\t\t\t\t\t\tvlan->vlan_id);\n\t\t\trcu_read_unlock();\n\t\t\tif (vlan_dev == rt->dst.dev) {\n\t\t\t\tvlan_id = vlan->vlan_id;\n\t\t\t\tpr_debug(\"basa: vlan match on %s %d\\n\",\n\t\t\t\t       vlan_dev->name, vlan_id);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (vlan_id) {\n\t\t\tip_rt_put(rt);\n\t\t\tbond_arp_send(slave->dev, ARPOP_REQUEST, targets[i],\n\t\t\t\t      vlan->vlan_ip, vlan_id);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (net_ratelimit()) {\n\t\t\tpr_warning(\"%s: no path to arp_ip_target %pI4 via rt.dev %s\\n\",\n\t\t\t\t   bond->dev->name, &targets[i],\n\t\t\t\t   rt->dst.dev ? rt->dst.dev->name : \"NULL\");\n\t\t}\n\t\tip_rt_put(rt);\n\t}\n}\n\nstatic void bond_validate_arp(struct bonding *bond, struct slave *slave, __be32 sip, __be32 tip)\n{\n\tint i;\n\t__be32 *targets = bond->params.arp_targets;\n\n\tfor (i = 0; (i < BOND_MAX_ARP_TARGETS) && targets[i]; i++) {\n\t\tpr_debug(\"bva: sip %pI4 tip %pI4 t[%d] %pI4 bhti(tip) %d\\n\",\n\t\t\t &sip, &tip, i, &targets[i],\n\t\t\t bond_has_this_ip(bond, tip));\n\t\tif (sip == targets[i]) {\n\t\t\tif (bond_has_this_ip(bond, tip))\n\t\t\t\tslave->last_arp_rx = jiffies;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void bond_arp_rcv(struct sk_buff *skb, struct bonding *bond,\n\t\t\t struct slave *slave)\n{\n\tstruct arphdr *arp;\n\tunsigned char *arp_ptr;\n\t__be32 sip, tip;\n\n\tif (skb->protocol != __cpu_to_be16(ETH_P_ARP))\n\t\treturn;\n\n\tread_lock(&bond->lock);\n\n\tpr_debug(\"bond_arp_rcv: bond %s skb->dev %s\\n\",\n\t\t bond->dev->name, skb->dev->name);\n\n\tif (!pskb_may_pull(skb, arp_hdr_len(bond->dev)))\n\t\tgoto out_unlock;\n\n\tarp = arp_hdr(skb);\n\tif (arp->ar_hln != bond->dev->addr_len ||\n\t    skb->pkt_type == PACKET_OTHERHOST ||\n\t    skb->pkt_type == PACKET_LOOPBACK ||\n\t    arp->ar_hrd != htons(ARPHRD_ETHER) ||\n\t    arp->ar_pro != htons(ETH_P_IP) ||\n\t    arp->ar_pln != 4)\n\t\tgoto out_unlock;\n\n\tarp_ptr = (unsigned char *)(arp + 1);\n\tarp_ptr += bond->dev->addr_len;\n\tmemcpy(&sip, arp_ptr, 4);\n\tarp_ptr += 4 + bond->dev->addr_len;\n\tmemcpy(&tip, arp_ptr, 4);\n\n\tpr_debug(\"bond_arp_rcv: %s %s/%d av %d sv %d sip %pI4 tip %pI4\\n\",\n\t\t bond->dev->name, slave->dev->name, bond_slave_state(slave),\n\t\t bond->params.arp_validate, slave_do_arp_validate(bond, slave),\n\t\t &sip, &tip);\n\n\t/*\n\t * Backup slaves won't see the ARP reply, but do come through\n\t * here for each ARP probe (so we swap the sip/tip to validate\n\t * the probe).  In a \"redundant switch, common router\" type of\n\t * configuration, the ARP probe will (hopefully) travel from\n\t * the active, through one switch, the router, then the other\n\t * switch before reaching the backup.\n\t */\n\tif (bond_is_active_slave(slave))\n\t\tbond_validate_arp(bond, slave, sip, tip);\n\telse\n\t\tbond_validate_arp(bond, slave, tip, sip);\n\nout_unlock:\n\tread_unlock(&bond->lock);\n}\n\n/*\n * this function is called regularly to monitor each slave's link\n * ensuring that traffic is being sent and received when arp monitoring\n * is used in load-balancing mode. if the adapter has been dormant, then an\n * arp is transmitted to generate traffic. see activebackup_arp_monitor for\n * arp monitoring in active backup mode.\n */\nvoid bond_loadbalance_arp_mon(struct work_struct *work)\n{\n\tstruct bonding *bond = container_of(work, struct bonding,\n\t\t\t\t\t    arp_work.work);\n\tstruct slave *slave, *oldcurrent;\n\tint do_failover = 0;\n\tint delta_in_ticks;\n\tint i;\n\n\tread_lock(&bond->lock);\n\n\tdelta_in_ticks = msecs_to_jiffies(bond->params.arp_interval);\n\n\tif (bond->kill_timers)\n\t\tgoto out;\n\n\tif (bond->slave_cnt == 0)\n\t\tgoto re_arm;\n\n\tread_lock(&bond->curr_slave_lock);\n\toldcurrent = bond->curr_active_slave;\n\tread_unlock(&bond->curr_slave_lock);\n\n\t/* see if any of the previous devices are up now (i.e. they have\n\t * xmt and rcv traffic). the curr_active_slave does not come into\n\t * the picture unless it is null. also, slave->jiffies is not needed\n\t * here because we send an arp on each slave and give a slave as\n\t * long as it needs to get the tx/rx within the delta.\n\t * TODO: what about up/down delay in arp mode? it wasn't here before\n\t *       so it can wait\n\t */\n\tbond_for_each_slave(bond, slave, i) {\n\t\tunsigned long trans_start = dev_trans_start(slave->dev);\n\n\t\tif (slave->link != BOND_LINK_UP) {\n\t\t\tif (time_in_range(jiffies,\n\t\t\t\ttrans_start - delta_in_ticks,\n\t\t\t\ttrans_start + delta_in_ticks) &&\n\t\t\t    time_in_range(jiffies,\n\t\t\t\tslave->dev->last_rx - delta_in_ticks,\n\t\t\t\tslave->dev->last_rx + delta_in_ticks)) {\n\n\t\t\t\tslave->link  = BOND_LINK_UP;\n\t\t\t\tbond_set_active_slave(slave);\n\n\t\t\t\t/* primary_slave has no meaning in round-robin\n\t\t\t\t * mode. the window of a slave being up and\n\t\t\t\t * curr_active_slave being null after enslaving\n\t\t\t\t * is closed.\n\t\t\t\t */\n\t\t\t\tif (!oldcurrent) {\n\t\t\t\t\tpr_info(\"%s: link status definitely up for interface %s, \",\n\t\t\t\t\t\tbond->dev->name,\n\t\t\t\t\t\tslave->dev->name);\n\t\t\t\t\tdo_failover = 1;\n\t\t\t\t} else {\n\t\t\t\t\tpr_info(\"%s: interface %s is now up\\n\",\n\t\t\t\t\t\tbond->dev->name,\n\t\t\t\t\t\tslave->dev->name);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/* slave->link == BOND_LINK_UP */\n\n\t\t\t/* not all switches will respond to an arp request\n\t\t\t * when the source ip is 0, so don't take the link down\n\t\t\t * if we don't know our ip yet\n\t\t\t */\n\t\t\tif (!time_in_range(jiffies,\n\t\t\t\ttrans_start - delta_in_ticks,\n\t\t\t\ttrans_start + 2 * delta_in_ticks) ||\n\t\t\t    !time_in_range(jiffies,\n\t\t\t\tslave->dev->last_rx - delta_in_ticks,\n\t\t\t\tslave->dev->last_rx + 2 * delta_in_ticks)) {\n\n\t\t\t\tslave->link  = BOND_LINK_DOWN;\n\t\t\t\tbond_set_backup_slave(slave);\n\n\t\t\t\tif (slave->link_failure_count < UINT_MAX)\n\t\t\t\t\tslave->link_failure_count++;\n\n\t\t\t\tpr_info(\"%s: interface %s is now down.\\n\",\n\t\t\t\t\tbond->dev->name,\n\t\t\t\t\tslave->dev->name);\n\n\t\t\t\tif (slave == oldcurrent)\n\t\t\t\t\tdo_failover = 1;\n\t\t\t}\n\t\t}\n\n\t\t/* note: if switch is in round-robin mode, all links\n\t\t * must tx arp to ensure all links rx an arp - otherwise\n\t\t * links may oscillate or not come up at all; if switch is\n\t\t * in something like xor mode, there is nothing we can\n\t\t * do - all replies will be rx'ed on same link causing slaves\n\t\t * to be unstable during low/no traffic periods\n\t\t */\n\t\tif (IS_UP(slave->dev))\n\t\t\tbond_arp_send_all(bond, slave);\n\t}\n\n\tif (do_failover) {\n\t\tblock_netpoll_tx();\n\t\twrite_lock_bh(&bond->curr_slave_lock);\n\n\t\tbond_select_active_slave(bond);\n\n\t\twrite_unlock_bh(&bond->curr_slave_lock);\n\t\tunblock_netpoll_tx();\n\t}\n\nre_arm:\n\tif (bond->params.arp_interval)\n\t\tqueue_delayed_work(bond->wq, &bond->arp_work, delta_in_ticks);\nout:\n\tread_unlock(&bond->lock);\n}\n\n/*\n * Called to inspect slaves for active-backup mode ARP monitor link state\n * changes.  Sets new_link in slaves to specify what action should take\n * place for the slave.  Returns 0 if no changes are found, >0 if changes\n * to link states must be committed.\n *\n * Called with bond->lock held for read.\n */\nstatic int bond_ab_arp_inspect(struct bonding *bond, int delta_in_ticks)\n{\n\tstruct slave *slave;\n\tint i, commit = 0;\n\tunsigned long trans_start;\n\n\tbond_for_each_slave(bond, slave, i) {\n\t\tslave->new_link = BOND_LINK_NOCHANGE;\n\n\t\tif (slave->link != BOND_LINK_UP) {\n\t\t\tif (time_in_range(jiffies,\n\t\t\t\tslave_last_rx(bond, slave) - delta_in_ticks,\n\t\t\t\tslave_last_rx(bond, slave) + delta_in_ticks)) {\n\n\t\t\t\tslave->new_link = BOND_LINK_UP;\n\t\t\t\tcommit++;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Give slaves 2*delta after being enslaved or made\n\t\t * active.  This avoids bouncing, as the last receive\n\t\t * times need a full ARP monitor cycle to be updated.\n\t\t */\n\t\tif (time_in_range(jiffies,\n\t\t\t\t  slave->jiffies - delta_in_ticks,\n\t\t\t\t  slave->jiffies + 2 * delta_in_ticks))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Backup slave is down if:\n\t\t * - No current_arp_slave AND\n\t\t * - more than 3*delta since last receive AND\n\t\t * - the bond has an IP address\n\t\t *\n\t\t * Note: a non-null current_arp_slave indicates\n\t\t * the curr_active_slave went down and we are\n\t\t * searching for a new one; under this condition\n\t\t * we only take the curr_active_slave down - this\n\t\t * gives each slave a chance to tx/rx traffic\n\t\t * before being taken out\n\t\t */\n\t\tif (!bond_is_active_slave(slave) &&\n\t\t    !bond->current_arp_slave &&\n\t\t    !time_in_range(jiffies,\n\t\t\tslave_last_rx(bond, slave) - delta_in_ticks,\n\t\t\tslave_last_rx(bond, slave) + 3 * delta_in_ticks)) {\n\n\t\t\tslave->new_link = BOND_LINK_DOWN;\n\t\t\tcommit++;\n\t\t}\n\n\t\t/*\n\t\t * Active slave is down if:\n\t\t * - more than 2*delta since transmitting OR\n\t\t * - (more than 2*delta since receive AND\n\t\t *    the bond has an IP address)\n\t\t */\n\t\ttrans_start = dev_trans_start(slave->dev);\n\t\tif (bond_is_active_slave(slave) &&\n\t\t    (!time_in_range(jiffies,\n\t\t\ttrans_start - delta_in_ticks,\n\t\t\ttrans_start + 2 * delta_in_ticks) ||\n\t\t     !time_in_range(jiffies,\n\t\t\tslave_last_rx(bond, slave) - delta_in_ticks,\n\t\t\tslave_last_rx(bond, slave) + 2 * delta_in_ticks))) {\n\n\t\t\tslave->new_link = BOND_LINK_DOWN;\n\t\t\tcommit++;\n\t\t}\n\t}\n\n\treturn commit;\n}\n\n/*\n * Called to commit link state changes noted by inspection step of\n * active-backup mode ARP monitor.\n *\n * Called with RTNL and bond->lock for read.\n */\nstatic void bond_ab_arp_commit(struct bonding *bond, int delta_in_ticks)\n{\n\tstruct slave *slave;\n\tint i;\n\tunsigned long trans_start;\n\n\tbond_for_each_slave(bond, slave, i) {\n\t\tswitch (slave->new_link) {\n\t\tcase BOND_LINK_NOCHANGE:\n\t\t\tcontinue;\n\n\t\tcase BOND_LINK_UP:\n\t\t\ttrans_start = dev_trans_start(slave->dev);\n\t\t\tif ((!bond->curr_active_slave &&\n\t\t\t     time_in_range(jiffies,\n\t\t\t\t\t   trans_start - delta_in_ticks,\n\t\t\t\t\t   trans_start + delta_in_ticks)) ||\n\t\t\t    bond->curr_active_slave != slave) {\n\t\t\t\tslave->link = BOND_LINK_UP;\n\t\t\t\tbond->current_arp_slave = NULL;\n\n\t\t\t\tpr_info(\"%s: link status definitely up for interface %s.\\n\",\n\t\t\t\t\tbond->dev->name, slave->dev->name);\n\n\t\t\t\tif (!bond->curr_active_slave ||\n\t\t\t\t    (slave == bond->primary_slave))\n\t\t\t\t\tgoto do_failover;\n\n\t\t\t}\n\n\t\t\tcontinue;\n\n\t\tcase BOND_LINK_DOWN:\n\t\t\tif (slave->link_failure_count < UINT_MAX)\n\t\t\t\tslave->link_failure_count++;\n\n\t\t\tslave->link = BOND_LINK_DOWN;\n\t\t\tbond_set_slave_inactive_flags(slave);\n\n\t\t\tpr_info(\"%s: link status definitely down for interface %s, disabling it\\n\",\n\t\t\t\tbond->dev->name, slave->dev->name);\n\n\t\t\tif (slave == bond->curr_active_slave) {\n\t\t\t\tbond->current_arp_slave = NULL;\n\t\t\t\tgoto do_failover;\n\t\t\t}\n\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\tpr_err(\"%s: impossible: new_link %d on slave %s\\n\",\n\t\t\t       bond->dev->name, slave->new_link,\n\t\t\t       slave->dev->name);\n\t\t\tcontinue;\n\t\t}\n\ndo_failover:\n\t\tASSERT_RTNL();\n\t\tblock_netpoll_tx();\n\t\twrite_lock_bh(&bond->curr_slave_lock);\n\t\tbond_select_active_slave(bond);\n\t\twrite_unlock_bh(&bond->curr_slave_lock);\n\t\tunblock_netpoll_tx();\n\t}\n\n\tbond_set_carrier(bond);\n}\n\n/*\n * Send ARP probes for active-backup mode ARP monitor.\n *\n * Called with bond->lock held for read.\n */\nstatic void bond_ab_arp_probe(struct bonding *bond)\n{\n\tstruct slave *slave;\n\tint i;\n\n\tread_lock(&bond->curr_slave_lock);\n\n\tif (bond->current_arp_slave && bond->curr_active_slave)\n\t\tpr_info(\"PROBE: c_arp %s && cas %s BAD\\n\",\n\t\t\tbond->current_arp_slave->dev->name,\n\t\t\tbond->curr_active_slave->dev->name);\n\n\tif (bond->curr_active_slave) {\n\t\tbond_arp_send_all(bond, bond->curr_active_slave);\n\t\tread_unlock(&bond->curr_slave_lock);\n\t\treturn;\n\t}\n\n\tread_unlock(&bond->curr_slave_lock);\n\n\t/* if we don't have a curr_active_slave, search for the next available\n\t * backup slave from the current_arp_slave and make it the candidate\n\t * for becoming the curr_active_slave\n\t */\n\n\tif (!bond->current_arp_slave) {\n\t\tbond->current_arp_slave = bond->first_slave;\n\t\tif (!bond->current_arp_slave)\n\t\t\treturn;\n\t}\n\n\tbond_set_slave_inactive_flags(bond->current_arp_slave);\n\n\t/* search for next candidate */\n\tbond_for_each_slave_from(bond, slave, i, bond->current_arp_slave->next) {\n\t\tif (IS_UP(slave->dev)) {\n\t\t\tslave->link = BOND_LINK_BACK;\n\t\t\tbond_set_slave_active_flags(slave);\n\t\t\tbond_arp_send_all(bond, slave);\n\t\t\tslave->jiffies = jiffies;\n\t\t\tbond->current_arp_slave = slave;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* if the link state is up at this point, we\n\t\t * mark it down - this can happen if we have\n\t\t * simultaneous link failures and\n\t\t * reselect_active_interface doesn't make this\n\t\t * one the current slave so it is still marked\n\t\t * up when it is actually down\n\t\t */\n\t\tif (slave->link == BOND_LINK_UP) {\n\t\t\tslave->link = BOND_LINK_DOWN;\n\t\t\tif (slave->link_failure_count < UINT_MAX)\n\t\t\t\tslave->link_failure_count++;\n\n\t\t\tbond_set_slave_inactive_flags(slave);\n\n\t\t\tpr_info(\"%s: backup interface %s is now down.\\n\",\n\t\t\t\tbond->dev->name, slave->dev->name);\n\t\t}\n\t}\n}\n\nvoid bond_activebackup_arp_mon(struct work_struct *work)\n{\n\tstruct bonding *bond = container_of(work, struct bonding,\n\t\t\t\t\t    arp_work.work);\n\tbool should_notify_peers = false;\n\tint delta_in_ticks;\n\n\tread_lock(&bond->lock);\n\n\tif (bond->kill_timers)\n\t\tgoto out;\n\n\tdelta_in_ticks = msecs_to_jiffies(bond->params.arp_interval);\n\n\tif (bond->slave_cnt == 0)\n\t\tgoto re_arm;\n\n\tshould_notify_peers = bond_should_notify_peers(bond);\n\n\tif (bond_ab_arp_inspect(bond, delta_in_ticks)) {\n\t\tread_unlock(&bond->lock);\n\t\trtnl_lock();\n\t\tread_lock(&bond->lock);\n\n\t\tbond_ab_arp_commit(bond, delta_in_ticks);\n\n\t\tread_unlock(&bond->lock);\n\t\trtnl_unlock();\n\t\tread_lock(&bond->lock);\n\t}\n\n\tbond_ab_arp_probe(bond);\n\nre_arm:\n\tif (bond->params.arp_interval)\n\t\tqueue_delayed_work(bond->wq, &bond->arp_work, delta_in_ticks);\nout:\n\tread_unlock(&bond->lock);\n\n\tif (should_notify_peers) {\n\t\trtnl_lock();\n\t\tnetdev_bonding_change(bond->dev, NETDEV_NOTIFY_PEERS);\n\t\trtnl_unlock();\n\t}\n}\n\n/*-------------------------- netdev event handling --------------------------*/\n\n/*\n * Change device name\n */\nstatic int bond_event_changename(struct bonding *bond)\n{\n\tbond_remove_proc_entry(bond);\n\tbond_create_proc_entry(bond);\n\n\tbond_debug_reregister(bond);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int bond_master_netdev_event(unsigned long event,\n\t\t\t\t    struct net_device *bond_dev)\n{\n\tstruct bonding *event_bond = netdev_priv(bond_dev);\n\n\tswitch (event) {\n\tcase NETDEV_CHANGENAME:\n\t\treturn bond_event_changename(event_bond);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int bond_slave_netdev_event(unsigned long event,\n\t\t\t\t   struct net_device *slave_dev)\n{\n\tstruct net_device *bond_dev = slave_dev->master;\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\n\tswitch (event) {\n\tcase NETDEV_UNREGISTER:\n\t\tif (bond_dev) {\n\t\t\tif (bond->setup_by_slave)\n\t\t\t\tbond_release_and_destroy(bond_dev, slave_dev);\n\t\t\telse\n\t\t\t\tbond_release(bond_dev, slave_dev);\n\t\t}\n\t\tbreak;\n\tcase NETDEV_CHANGE:\n\t\tif (bond->params.mode == BOND_MODE_8023AD || bond_is_lb(bond)) {\n\t\t\tstruct slave *slave;\n\n\t\t\tslave = bond_get_slave_by_dev(bond, slave_dev);\n\t\t\tif (slave) {\n\t\t\t\tu32 old_speed = slave->speed;\n\t\t\t\tu8  old_duplex = slave->duplex;\n\n\t\t\t\tbond_update_speed_duplex(slave);\n\n\t\t\t\tif (bond_is_lb(bond))\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (old_speed != slave->speed)\n\t\t\t\t\tbond_3ad_adapter_speed_changed(slave);\n\t\t\t\tif (old_duplex != slave->duplex)\n\t\t\t\t\tbond_3ad_adapter_duplex_changed(slave);\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\t\t/*\n\t\t * ... Or is it this?\n\t\t */\n\t\tbreak;\n\tcase NETDEV_CHANGEMTU:\n\t\t/*\n\t\t * TODO: Should slaves be allowed to\n\t\t * independently alter their MTU?  For\n\t\t * an active-backup bond, slaves need\n\t\t * not be the same type of device, so\n\t\t * MTUs may vary.  For other modes,\n\t\t * slaves arguably should have the\n\t\t * same MTUs. To do this, we'd need to\n\t\t * take over the slave's change_mtu\n\t\t * function for the duration of their\n\t\t * servitude.\n\t\t */\n\t\tbreak;\n\tcase NETDEV_CHANGENAME:\n\t\t/*\n\t\t * TODO: handle changing the primary's name\n\t\t */\n\t\tbreak;\n\tcase NETDEV_FEAT_CHANGE:\n\t\tbond_compute_features(bond);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\n/*\n * bond_netdev_event: handle netdev notifier chain events.\n *\n * This function receives events for the netdev chain.  The caller (an\n * ioctl handler calling blocking_notifier_call_chain) holds the necessary\n * locks for us to safely manipulate the slave devices (RTNL lock,\n * dev_probe_lock).\n */\nstatic int bond_netdev_event(struct notifier_block *this,\n\t\t\t     unsigned long event, void *ptr)\n{\n\tstruct net_device *event_dev = (struct net_device *)ptr;\n\n\tpr_debug(\"event_dev: %s, event: %lx\\n\",\n\t\t event_dev ? event_dev->name : \"None\",\n\t\t event);\n\n\tif (!(event_dev->priv_flags & IFF_BONDING))\n\t\treturn NOTIFY_DONE;\n\n\tif (event_dev->flags & IFF_MASTER) {\n\t\tpr_debug(\"IFF_MASTER\\n\");\n\t\treturn bond_master_netdev_event(event, event_dev);\n\t}\n\n\tif (event_dev->flags & IFF_SLAVE) {\n\t\tpr_debug(\"IFF_SLAVE\\n\");\n\t\treturn bond_slave_netdev_event(event, event_dev);\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\n/*\n * bond_inetaddr_event: handle inetaddr notifier chain events.\n *\n * We keep track of device IPs primarily to use as source addresses in\n * ARP monitor probes (rather than spewing out broadcasts all the time).\n *\n * We track one IP for the main device (if it has one), plus one per VLAN.\n */\nstatic int bond_inetaddr_event(struct notifier_block *this, unsigned long event, void *ptr)\n{\n\tstruct in_ifaddr *ifa = ptr;\n\tstruct net_device *vlan_dev, *event_dev = ifa->ifa_dev->dev;\n\tstruct bond_net *bn = net_generic(dev_net(event_dev), bond_net_id);\n\tstruct bonding *bond;\n\tstruct vlan_entry *vlan;\n\n\tlist_for_each_entry(bond, &bn->dev_list, bond_list) {\n\t\tif (bond->dev == event_dev) {\n\t\t\tswitch (event) {\n\t\t\tcase NETDEV_UP:\n\t\t\t\tbond->master_ip = ifa->ifa_local;\n\t\t\t\treturn NOTIFY_OK;\n\t\t\tcase NETDEV_DOWN:\n\t\t\t\tbond->master_ip = bond_glean_dev_ip(bond->dev);\n\t\t\t\treturn NOTIFY_OK;\n\t\t\tdefault:\n\t\t\t\treturn NOTIFY_DONE;\n\t\t\t}\n\t\t}\n\n\t\tlist_for_each_entry(vlan, &bond->vlan_list, vlan_list) {\n\t\t\tvlan_dev = __vlan_find_dev_deep(bond->dev,\n\t\t\t\t\t\t\tvlan->vlan_id);\n\t\t\tif (vlan_dev == event_dev) {\n\t\t\t\tswitch (event) {\n\t\t\t\tcase NETDEV_UP:\n\t\t\t\t\tvlan->vlan_ip = ifa->ifa_local;\n\t\t\t\t\treturn NOTIFY_OK;\n\t\t\t\tcase NETDEV_DOWN:\n\t\t\t\t\tvlan->vlan_ip =\n\t\t\t\t\t\tbond_glean_dev_ip(vlan_dev);\n\t\t\t\t\treturn NOTIFY_OK;\n\t\t\t\tdefault:\n\t\t\t\t\treturn NOTIFY_DONE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block bond_netdev_notifier = {\n\t.notifier_call = bond_netdev_event,\n};\n\nstatic struct notifier_block bond_inetaddr_notifier = {\n\t.notifier_call = bond_inetaddr_event,\n};\n\n/*---------------------------- Hashing Policies -----------------------------*/\n\n/*\n * Hash for the output device based upon layer 2 and layer 3 data. If\n * the packet is not IP mimic bond_xmit_hash_policy_l2()\n */\nstatic int bond_xmit_hash_policy_l23(struct sk_buff *skb, int count)\n{\n\tstruct ethhdr *data = (struct ethhdr *)skb->data;\n\tstruct iphdr *iph = ip_hdr(skb);\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\treturn ((ntohl(iph->saddr ^ iph->daddr) & 0xffff) ^\n\t\t\t(data->h_dest[5] ^ data->h_source[5])) % count;\n\t}\n\n\treturn (data->h_dest[5] ^ data->h_source[5]) % count;\n}\n\n/*\n * Hash for the output device based upon layer 3 and layer 4 data. If\n * the packet is a frag or not TCP or UDP, just use layer 3 data.  If it is\n * altogether not IP, mimic bond_xmit_hash_policy_l2()\n */\nstatic int bond_xmit_hash_policy_l34(struct sk_buff *skb, int count)\n{\n\tstruct ethhdr *data = (struct ethhdr *)skb->data;\n\tstruct iphdr *iph = ip_hdr(skb);\n\t__be16 *layer4hdr = (__be16 *)((u32 *)iph + iph->ihl);\n\tint layer4_xor = 0;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\tif (!ip_is_fragment(iph) &&\n\t\t    (iph->protocol == IPPROTO_TCP ||\n\t\t     iph->protocol == IPPROTO_UDP)) {\n\t\t\tlayer4_xor = ntohs((*layer4hdr ^ *(layer4hdr + 1)));\n\t\t}\n\t\treturn (layer4_xor ^\n\t\t\t((ntohl(iph->saddr ^ iph->daddr)) & 0xffff)) % count;\n\n\t}\n\n\treturn (data->h_dest[5] ^ data->h_source[5]) % count;\n}\n\n/*\n * Hash for the output device based upon layer 2 data\n */\nstatic int bond_xmit_hash_policy_l2(struct sk_buff *skb, int count)\n{\n\tstruct ethhdr *data = (struct ethhdr *)skb->data;\n\n\treturn (data->h_dest[5] ^ data->h_source[5]) % count;\n}\n\n/*-------------------------- Device entry points ----------------------------*/\n\nstatic int bond_open(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\n\tbond->kill_timers = 0;\n\n\tINIT_DELAYED_WORK(&bond->mcast_work, bond_resend_igmp_join_requests_delayed);\n\n\tif (bond_is_lb(bond)) {\n\t\t/* bond_alb_initialize must be called before the timer\n\t\t * is started.\n\t\t */\n\t\tif (bond_alb_initialize(bond, (bond->params.mode == BOND_MODE_ALB))) {\n\t\t\t/* something went wrong - fail the open operation */\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tINIT_DELAYED_WORK(&bond->alb_work, bond_alb_monitor);\n\t\tqueue_delayed_work(bond->wq, &bond->alb_work, 0);\n\t}\n\n\tif (bond->params.miimon) {  /* link check interval, in milliseconds. */\n\t\tINIT_DELAYED_WORK(&bond->mii_work, bond_mii_monitor);\n\t\tqueue_delayed_work(bond->wq, &bond->mii_work, 0);\n\t}\n\n\tif (bond->params.arp_interval) {  /* arp interval, in milliseconds. */\n\t\tif (bond->params.mode == BOND_MODE_ACTIVEBACKUP)\n\t\t\tINIT_DELAYED_WORK(&bond->arp_work,\n\t\t\t\t\t  bond_activebackup_arp_mon);\n\t\telse\n\t\t\tINIT_DELAYED_WORK(&bond->arp_work,\n\t\t\t\t\t  bond_loadbalance_arp_mon);\n\n\t\tqueue_delayed_work(bond->wq, &bond->arp_work, 0);\n\t\tif (bond->params.arp_validate)\n\t\t\tbond->recv_probe = bond_arp_rcv;\n\t}\n\n\tif (bond->params.mode == BOND_MODE_8023AD) {\n\t\tINIT_DELAYED_WORK(&bond->ad_work, bond_3ad_state_machine_handler);\n\t\tqueue_delayed_work(bond->wq, &bond->ad_work, 0);\n\t\t/* register to receive LACPDUs */\n\t\tbond->recv_probe = bond_3ad_lacpdu_recv;\n\t\tbond_3ad_initiate_agg_selection(bond, 1);\n\t}\n\n\treturn 0;\n}\n\nstatic int bond_close(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\n\twrite_lock_bh(&bond->lock);\n\n\tbond->send_peer_notif = 0;\n\n\t/* signal timers not to re-arm */\n\tbond->kill_timers = 1;\n\n\twrite_unlock_bh(&bond->lock);\n\n\tif (bond->params.miimon) {  /* link check interval, in milliseconds. */\n\t\tcancel_delayed_work(&bond->mii_work);\n\t}\n\n\tif (bond->params.arp_interval) {  /* arp interval, in milliseconds. */\n\t\tcancel_delayed_work(&bond->arp_work);\n\t}\n\n\tswitch (bond->params.mode) {\n\tcase BOND_MODE_8023AD:\n\t\tcancel_delayed_work(&bond->ad_work);\n\t\tbreak;\n\tcase BOND_MODE_TLB:\n\tcase BOND_MODE_ALB:\n\t\tcancel_delayed_work(&bond->alb_work);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (delayed_work_pending(&bond->mcast_work))\n\t\tcancel_delayed_work(&bond->mcast_work);\n\n\tif (bond_is_lb(bond)) {\n\t\t/* Must be called only after all\n\t\t * slaves have been released\n\t\t */\n\t\tbond_alb_deinitialize(bond);\n\t}\n\tbond->recv_probe = NULL;\n\n\treturn 0;\n}\n\nstatic struct rtnl_link_stats64 *bond_get_stats(struct net_device *bond_dev,\n\t\t\t\t\t\tstruct rtnl_link_stats64 *stats)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct rtnl_link_stats64 temp;\n\tstruct slave *slave;\n\tint i;\n\n\tmemset(stats, 0, sizeof(*stats));\n\n\tread_lock_bh(&bond->lock);\n\n\tbond_for_each_slave(bond, slave, i) {\n\t\tconst struct rtnl_link_stats64 *sstats =\n\t\t\tdev_get_stats(slave->dev, &temp);\n\n\t\tstats->rx_packets += sstats->rx_packets;\n\t\tstats->rx_bytes += sstats->rx_bytes;\n\t\tstats->rx_errors += sstats->rx_errors;\n\t\tstats->rx_dropped += sstats->rx_dropped;\n\n\t\tstats->tx_packets += sstats->tx_packets;\n\t\tstats->tx_bytes += sstats->tx_bytes;\n\t\tstats->tx_errors += sstats->tx_errors;\n\t\tstats->tx_dropped += sstats->tx_dropped;\n\n\t\tstats->multicast += sstats->multicast;\n\t\tstats->collisions += sstats->collisions;\n\n\t\tstats->rx_length_errors += sstats->rx_length_errors;\n\t\tstats->rx_over_errors += sstats->rx_over_errors;\n\t\tstats->rx_crc_errors += sstats->rx_crc_errors;\n\t\tstats->rx_frame_errors += sstats->rx_frame_errors;\n\t\tstats->rx_fifo_errors += sstats->rx_fifo_errors;\n\t\tstats->rx_missed_errors += sstats->rx_missed_errors;\n\n\t\tstats->tx_aborted_errors += sstats->tx_aborted_errors;\n\t\tstats->tx_carrier_errors += sstats->tx_carrier_errors;\n\t\tstats->tx_fifo_errors += sstats->tx_fifo_errors;\n\t\tstats->tx_heartbeat_errors += sstats->tx_heartbeat_errors;\n\t\tstats->tx_window_errors += sstats->tx_window_errors;\n\t}\n\n\tread_unlock_bh(&bond->lock);\n\n\treturn stats;\n}\n\nstatic int bond_do_ioctl(struct net_device *bond_dev, struct ifreq *ifr, int cmd)\n{\n\tstruct net_device *slave_dev = NULL;\n\tstruct ifbond k_binfo;\n\tstruct ifbond __user *u_binfo = NULL;\n\tstruct ifslave k_sinfo;\n\tstruct ifslave __user *u_sinfo = NULL;\n\tstruct mii_ioctl_data *mii = NULL;\n\tint res = 0;\n\n\tpr_debug(\"bond_ioctl: master=%s, cmd=%d\\n\", bond_dev->name, cmd);\n\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\t\tmii = if_mii(ifr);\n\t\tif (!mii)\n\t\t\treturn -EINVAL;\n\n\t\tmii->phy_id = 0;\n\t\t/* Fall Through */\n\tcase SIOCGMIIREG:\n\t\t/*\n\t\t * We do this again just in case we were called by SIOCGMIIREG\n\t\t * instead of SIOCGMIIPHY.\n\t\t */\n\t\tmii = if_mii(ifr);\n\t\tif (!mii)\n\t\t\treturn -EINVAL;\n\n\n\t\tif (mii->reg_num == 1) {\n\t\t\tstruct bonding *bond = netdev_priv(bond_dev);\n\t\t\tmii->val_out = 0;\n\t\t\tread_lock(&bond->lock);\n\t\t\tread_lock(&bond->curr_slave_lock);\n\t\t\tif (netif_carrier_ok(bond->dev))\n\t\t\t\tmii->val_out = BMSR_LSTATUS;\n\n\t\t\tread_unlock(&bond->curr_slave_lock);\n\t\t\tread_unlock(&bond->lock);\n\t\t}\n\n\t\treturn 0;\n\tcase BOND_INFO_QUERY_OLD:\n\tcase SIOCBONDINFOQUERY:\n\t\tu_binfo = (struct ifbond __user *)ifr->ifr_data;\n\n\t\tif (copy_from_user(&k_binfo, u_binfo, sizeof(ifbond)))\n\t\t\treturn -EFAULT;\n\n\t\tres = bond_info_query(bond_dev, &k_binfo);\n\t\tif (res == 0 &&\n\t\t    copy_to_user(u_binfo, &k_binfo, sizeof(ifbond)))\n\t\t\treturn -EFAULT;\n\n\t\treturn res;\n\tcase BOND_SLAVE_INFO_QUERY_OLD:\n\tcase SIOCBONDSLAVEINFOQUERY:\n\t\tu_sinfo = (struct ifslave __user *)ifr->ifr_data;\n\n\t\tif (copy_from_user(&k_sinfo, u_sinfo, sizeof(ifslave)))\n\t\t\treturn -EFAULT;\n\n\t\tres = bond_slave_info_query(bond_dev, &k_sinfo);\n\t\tif (res == 0 &&\n\t\t    copy_to_user(u_sinfo, &k_sinfo, sizeof(ifslave)))\n\t\t\treturn -EFAULT;\n\n\t\treturn res;\n\tdefault:\n\t\t/* Go on */\n\t\tbreak;\n\t}\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tslave_dev = dev_get_by_name(dev_net(bond_dev), ifr->ifr_slave);\n\n\tpr_debug(\"slave_dev=%p:\\n\", slave_dev);\n\n\tif (!slave_dev)\n\t\tres = -ENODEV;\n\telse {\n\t\tpr_debug(\"slave_dev->name=%s:\\n\", slave_dev->name);\n\t\tswitch (cmd) {\n\t\tcase BOND_ENSLAVE_OLD:\n\t\tcase SIOCBONDENSLAVE:\n\t\t\tres = bond_enslave(bond_dev, slave_dev);\n\t\t\tbreak;\n\t\tcase BOND_RELEASE_OLD:\n\t\tcase SIOCBONDRELEASE:\n\t\t\tres = bond_release(bond_dev, slave_dev);\n\t\t\tbreak;\n\t\tcase BOND_SETHWADDR_OLD:\n\t\tcase SIOCBONDSETHWADDR:\n\t\t\tres = bond_sethwaddr(bond_dev, slave_dev);\n\t\t\tbreak;\n\t\tcase BOND_CHANGE_ACTIVE_OLD:\n\t\tcase SIOCBONDCHANGEACTIVE:\n\t\t\tres = bond_ioctl_change_active(bond_dev, slave_dev);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tres = -EOPNOTSUPP;\n\t\t}\n\n\t\tdev_put(slave_dev);\n\t}\n\n\treturn res;\n}\n\nstatic bool bond_addr_in_mc_list(unsigned char *addr,\n\t\t\t\t struct netdev_hw_addr_list *list,\n\t\t\t\t int addrlen)\n{\n\tstruct netdev_hw_addr *ha;\n\n\tnetdev_hw_addr_list_for_each(ha, list)\n\t\tif (!memcmp(ha->addr, addr, addrlen))\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic void bond_set_multicast_list(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct netdev_hw_addr *ha;\n\tbool found;\n\n\t/*\n\t * Do promisc before checking multicast_mode\n\t */\n\tif ((bond_dev->flags & IFF_PROMISC) && !(bond->flags & IFF_PROMISC))\n\t\t/*\n\t\t * FIXME: Need to handle the error when one of the multi-slaves\n\t\t * encounters error.\n\t\t */\n\t\tbond_set_promiscuity(bond, 1);\n\n\n\tif (!(bond_dev->flags & IFF_PROMISC) && (bond->flags & IFF_PROMISC))\n\t\tbond_set_promiscuity(bond, -1);\n\n\n\t/* set allmulti flag to slaves */\n\tif ((bond_dev->flags & IFF_ALLMULTI) && !(bond->flags & IFF_ALLMULTI))\n\t\t/*\n\t\t * FIXME: Need to handle the error when one of the multi-slaves\n\t\t * encounters error.\n\t\t */\n\t\tbond_set_allmulti(bond, 1);\n\n\n\tif (!(bond_dev->flags & IFF_ALLMULTI) && (bond->flags & IFF_ALLMULTI))\n\t\tbond_set_allmulti(bond, -1);\n\n\n\tread_lock(&bond->lock);\n\n\tbond->flags = bond_dev->flags;\n\n\t/* looking for addresses to add to slaves' mc list */\n\tnetdev_for_each_mc_addr(ha, bond_dev) {\n\t\tfound = bond_addr_in_mc_list(ha->addr, &bond->mc_list,\n\t\t\t\t\t     bond_dev->addr_len);\n\t\tif (!found)\n\t\t\tbond_mc_add(bond, ha->addr);\n\t}\n\n\t/* looking for addresses to delete from slaves' list */\n\tnetdev_hw_addr_list_for_each(ha, &bond->mc_list) {\n\t\tfound = bond_addr_in_mc_list(ha->addr, &bond_dev->mc,\n\t\t\t\t\t     bond_dev->addr_len);\n\t\tif (!found)\n\t\t\tbond_mc_del(bond, ha->addr);\n\t}\n\n\t/* save master's multicast list */\n\t__hw_addr_flush(&bond->mc_list);\n\t__hw_addr_add_multiple(&bond->mc_list, &bond_dev->mc,\n\t\t\t       bond_dev->addr_len, NETDEV_HW_ADDR_T_MULTICAST);\n\n\tread_unlock(&bond->lock);\n}\n\nstatic int bond_neigh_setup(struct net_device *dev, struct neigh_parms *parms)\n{\n\tstruct bonding *bond = netdev_priv(dev);\n\tstruct slave *slave = bond->first_slave;\n\n\tif (slave) {\n\t\tconst struct net_device_ops *slave_ops\n\t\t\t= slave->dev->netdev_ops;\n\t\tif (slave_ops->ndo_neigh_setup)\n\t\t\treturn slave_ops->ndo_neigh_setup(slave->dev, parms);\n\t}\n\treturn 0;\n}\n\n/*\n * Change the MTU of all of a master's slaves to match the master\n */\nstatic int bond_change_mtu(struct net_device *bond_dev, int new_mtu)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct slave *slave, *stop_at;\n\tint res = 0;\n\tint i;\n\n\tpr_debug(\"bond=%p, name=%s, new_mtu=%d\\n\", bond,\n\t\t (bond_dev ? bond_dev->name : \"None\"), new_mtu);\n\n\t/* Can't hold bond->lock with bh disabled here since\n\t * some base drivers panic. On the other hand we can't\n\t * hold bond->lock without bh disabled because we'll\n\t * deadlock. The only solution is to rely on the fact\n\t * that we're under rtnl_lock here, and the slaves\n\t * list won't change. This doesn't solve the problem\n\t * of setting the slave's MTU while it is\n\t * transmitting, but the assumption is that the base\n\t * driver can handle that.\n\t *\n\t * TODO: figure out a way to safely iterate the slaves\n\t * list, but without holding a lock around the actual\n\t * call to the base driver.\n\t */\n\n\tbond_for_each_slave(bond, slave, i) {\n\t\tpr_debug(\"s %p s->p %p c_m %p\\n\",\n\t\t\t slave,\n\t\t\t slave->prev,\n\t\t\t slave->dev->netdev_ops->ndo_change_mtu);\n\n\t\tres = dev_set_mtu(slave->dev, new_mtu);\n\n\t\tif (res) {\n\t\t\t/* If we failed to set the slave's mtu to the new value\n\t\t\t * we must abort the operation even in ACTIVE_BACKUP\n\t\t\t * mode, because if we allow the backup slaves to have\n\t\t\t * different mtu values than the active slave we'll\n\t\t\t * need to change their mtu when doing a failover. That\n\t\t\t * means changing their mtu from timer context, which\n\t\t\t * is probably not a good idea.\n\t\t\t */\n\t\t\tpr_debug(\"err %d %s\\n\", res, slave->dev->name);\n\t\t\tgoto unwind;\n\t\t}\n\t}\n\n\tbond_dev->mtu = new_mtu;\n\n\treturn 0;\n\nunwind:\n\t/* unwind from head to the slave that failed */\n\tstop_at = slave;\n\tbond_for_each_slave_from_to(bond, slave, i, bond->first_slave, stop_at) {\n\t\tint tmp_res;\n\n\t\ttmp_res = dev_set_mtu(slave->dev, bond_dev->mtu);\n\t\tif (tmp_res) {\n\t\t\tpr_debug(\"unwind err %d dev %s\\n\",\n\t\t\t\t tmp_res, slave->dev->name);\n\t\t}\n\t}\n\n\treturn res;\n}\n\n/*\n * Change HW address\n *\n * Note that many devices must be down to change the HW address, and\n * downing the master releases all slaves.  We can make bonds full of\n * bonding devices to test this, however.\n */\nstatic int bond_set_mac_address(struct net_device *bond_dev, void *addr)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct sockaddr *sa = addr, tmp_sa;\n\tstruct slave *slave, *stop_at;\n\tint res = 0;\n\tint i;\n\n\tif (bond->params.mode == BOND_MODE_ALB)\n\t\treturn bond_alb_set_mac_address(bond_dev, addr);\n\n\n\tpr_debug(\"bond=%p, name=%s\\n\",\n\t\t bond, bond_dev ? bond_dev->name : \"None\");\n\n\t/*\n\t * If fail_over_mac is set to active, do nothing and return\n\t * success.  Returning an error causes ifenslave to fail.\n\t */\n\tif (bond->params.fail_over_mac == BOND_FOM_ACTIVE)\n\t\treturn 0;\n\n\tif (!is_valid_ether_addr(sa->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\t/* Can't hold bond->lock with bh disabled here since\n\t * some base drivers panic. On the other hand we can't\n\t * hold bond->lock without bh disabled because we'll\n\t * deadlock. The only solution is to rely on the fact\n\t * that we're under rtnl_lock here, and the slaves\n\t * list won't change. This doesn't solve the problem\n\t * of setting the slave's hw address while it is\n\t * transmitting, but the assumption is that the base\n\t * driver can handle that.\n\t *\n\t * TODO: figure out a way to safely iterate the slaves\n\t * list, but without holding a lock around the actual\n\t * call to the base driver.\n\t */\n\n\tbond_for_each_slave(bond, slave, i) {\n\t\tconst struct net_device_ops *slave_ops = slave->dev->netdev_ops;\n\t\tpr_debug(\"slave %p %s\\n\", slave, slave->dev->name);\n\n\t\tif (slave_ops->ndo_set_mac_address == NULL) {\n\t\t\tres = -EOPNOTSUPP;\n\t\t\tpr_debug(\"EOPNOTSUPP %s\\n\", slave->dev->name);\n\t\t\tgoto unwind;\n\t\t}\n\n\t\tres = dev_set_mac_address(slave->dev, addr);\n\t\tif (res) {\n\t\t\t/* TODO: consider downing the slave\n\t\t\t * and retry ?\n\t\t\t * User should expect communications\n\t\t\t * breakage anyway until ARP finish\n\t\t\t * updating, so...\n\t\t\t */\n\t\t\tpr_debug(\"err %d %s\\n\", res, slave->dev->name);\n\t\t\tgoto unwind;\n\t\t}\n\t}\n\n\t/* success */\n\tmemcpy(bond_dev->dev_addr, sa->sa_data, bond_dev->addr_len);\n\treturn 0;\n\nunwind:\n\tmemcpy(tmp_sa.sa_data, bond_dev->dev_addr, bond_dev->addr_len);\n\ttmp_sa.sa_family = bond_dev->type;\n\n\t/* unwind from head to the slave that failed */\n\tstop_at = slave;\n\tbond_for_each_slave_from_to(bond, slave, i, bond->first_slave, stop_at) {\n\t\tint tmp_res;\n\n\t\ttmp_res = dev_set_mac_address(slave->dev, &tmp_sa);\n\t\tif (tmp_res) {\n\t\t\tpr_debug(\"unwind err %d dev %s\\n\",\n\t\t\t\t tmp_res, slave->dev->name);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic int bond_xmit_roundrobin(struct sk_buff *skb, struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct slave *slave, *start_at;\n\tint i, slave_no, res = 1;\n\tstruct iphdr *iph = ip_hdr(skb);\n\n\t/*\n\t * Start with the curr_active_slave that joined the bond as the\n\t * default for sending IGMP traffic.  For failover purposes one\n\t * needs to maintain some consistency for the interface that will\n\t * send the join/membership reports.  The curr_active_slave found\n\t * will send all of this type of traffic.\n\t */\n\tif ((iph->protocol == IPPROTO_IGMP) &&\n\t    (skb->protocol == htons(ETH_P_IP))) {\n\n\t\tread_lock(&bond->curr_slave_lock);\n\t\tslave = bond->curr_active_slave;\n\t\tread_unlock(&bond->curr_slave_lock);\n\n\t\tif (!slave)\n\t\t\tgoto out;\n\t} else {\n\t\t/*\n\t\t * Concurrent TX may collide on rr_tx_counter; we accept\n\t\t * that as being rare enough not to justify using an\n\t\t * atomic op here.\n\t\t */\n\t\tslave_no = bond->rr_tx_counter++ % bond->slave_cnt;\n\n\t\tbond_for_each_slave(bond, slave, i) {\n\t\t\tslave_no--;\n\t\t\tif (slave_no < 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tstart_at = slave;\n\tbond_for_each_slave_from(bond, slave, i, start_at) {\n\t\tif (IS_UP(slave->dev) &&\n\t\t    (slave->link == BOND_LINK_UP) &&\n\t\t    bond_is_active_slave(slave)) {\n\t\t\tres = bond_dev_queue_xmit(bond, skb, slave->dev);\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tif (res) {\n\t\t/* no suitable interface, frame not sent */\n\t\tdev_kfree_skb(skb);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\n\n/*\n * in active-backup mode, we know that bond->curr_active_slave is always valid if\n * the bond has a usable interface.\n */\nstatic int bond_xmit_activebackup(struct sk_buff *skb, struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tint res = 1;\n\n\tread_lock(&bond->curr_slave_lock);\n\n\tif (bond->curr_active_slave)\n\t\tres = bond_dev_queue_xmit(bond, skb,\n\t\t\tbond->curr_active_slave->dev);\n\n\tif (res)\n\t\t/* no suitable interface, frame not sent */\n\t\tdev_kfree_skb(skb);\n\n\tread_unlock(&bond->curr_slave_lock);\n\n\treturn NETDEV_TX_OK;\n}\n\n/*\n * In bond_xmit_xor() , we determine the output device by using a pre-\n * determined xmit_hash_policy(), If the selected device is not enabled,\n * find the next active slave.\n */\nstatic int bond_xmit_xor(struct sk_buff *skb, struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct slave *slave, *start_at;\n\tint slave_no;\n\tint i;\n\tint res = 1;\n\n\tslave_no = bond->xmit_hash_policy(skb, bond->slave_cnt);\n\n\tbond_for_each_slave(bond, slave, i) {\n\t\tslave_no--;\n\t\tif (slave_no < 0)\n\t\t\tbreak;\n\t}\n\n\tstart_at = slave;\n\n\tbond_for_each_slave_from(bond, slave, i, start_at) {\n\t\tif (IS_UP(slave->dev) &&\n\t\t    (slave->link == BOND_LINK_UP) &&\n\t\t    bond_is_active_slave(slave)) {\n\t\t\tres = bond_dev_queue_xmit(bond, skb, slave->dev);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (res) {\n\t\t/* no suitable interface, frame not sent */\n\t\tdev_kfree_skb(skb);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\n/*\n * in broadcast mode, we send everything to all usable interfaces.\n */\nstatic int bond_xmit_broadcast(struct sk_buff *skb, struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct slave *slave, *start_at;\n\tstruct net_device *tx_dev = NULL;\n\tint i;\n\tint res = 1;\n\n\tread_lock(&bond->curr_slave_lock);\n\tstart_at = bond->curr_active_slave;\n\tread_unlock(&bond->curr_slave_lock);\n\n\tif (!start_at)\n\t\tgoto out;\n\n\tbond_for_each_slave_from(bond, slave, i, start_at) {\n\t\tif (IS_UP(slave->dev) &&\n\t\t    (slave->link == BOND_LINK_UP) &&\n\t\t    bond_is_active_slave(slave)) {\n\t\t\tif (tx_dev) {\n\t\t\t\tstruct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);\n\t\t\t\tif (!skb2) {\n\t\t\t\t\tpr_err(\"%s: Error: bond_xmit_broadcast(): skb_clone() failed\\n\",\n\t\t\t\t\t       bond_dev->name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tres = bond_dev_queue_xmit(bond, skb2, tx_dev);\n\t\t\t\tif (res) {\n\t\t\t\t\tdev_kfree_skb(skb2);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttx_dev = slave->dev;\n\t\t}\n\t}\n\n\tif (tx_dev)\n\t\tres = bond_dev_queue_xmit(bond, skb, tx_dev);\n\nout:\n\tif (res)\n\t\t/* no suitable interface, frame not sent */\n\t\tdev_kfree_skb(skb);\n\n\t/* frame sent to all suitable interfaces */\n\treturn NETDEV_TX_OK;\n}\n\n/*------------------------- Device initialization ---------------------------*/\n\nstatic void bond_set_xmit_hash_policy(struct bonding *bond)\n{\n\tswitch (bond->params.xmit_policy) {\n\tcase BOND_XMIT_POLICY_LAYER23:\n\t\tbond->xmit_hash_policy = bond_xmit_hash_policy_l23;\n\t\tbreak;\n\tcase BOND_XMIT_POLICY_LAYER34:\n\t\tbond->xmit_hash_policy = bond_xmit_hash_policy_l34;\n\t\tbreak;\n\tcase BOND_XMIT_POLICY_LAYER2:\n\tdefault:\n\t\tbond->xmit_hash_policy = bond_xmit_hash_policy_l2;\n\t\tbreak;\n\t}\n}\n\n/*\n * Lookup the slave that corresponds to a qid\n */\nstatic inline int bond_slave_override(struct bonding *bond,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tint i, res = 1;\n\tstruct slave *slave = NULL;\n\tstruct slave *check_slave;\n\n\tif (!skb->queue_mapping)\n\t\treturn 1;\n\n\t/* Find out if any slaves have the same mapping as this skb. */\n\tbond_for_each_slave(bond, check_slave, i) {\n\t\tif (check_slave->queue_id == skb->queue_mapping) {\n\t\t\tslave = check_slave;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* If the slave isn't UP, use default transmit policy. */\n\tif (slave && slave->queue_id && IS_UP(slave->dev) &&\n\t    (slave->link == BOND_LINK_UP)) {\n\t\tres = bond_dev_queue_xmit(bond, skb, slave->dev);\n\t}\n\n\treturn res;\n}\n\n\nstatic u16 bond_select_queue(struct net_device *dev, struct sk_buff *skb)\n{\n\t/*\n\t * This helper function exists to help dev_pick_tx get the correct\n\t * destination queue.  Using a helper function skips a call to\n\t * skb_tx_hash and will put the skbs in the queue we expect on their\n\t * way down to the bonding driver.\n\t */\n\tu16 txq = skb_rx_queue_recorded(skb) ? skb_get_rx_queue(skb) : 0;\n\n\t/*\n\t * Save the original txq to restore before passing to the driver\n\t */\n\tbond_queue_mapping(skb) = skb->queue_mapping;\n\n\tif (unlikely(txq >= dev->real_num_tx_queues)) {\n\t\tdo {\n\t\t\ttxq -= dev->real_num_tx_queues;\n\t\t} while (txq >= dev->real_num_tx_queues);\n\t}\n\treturn txq;\n}\n\nstatic netdev_tx_t __bond_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct bonding *bond = netdev_priv(dev);\n\n\tif (TX_QUEUE_OVERRIDE(bond->params.mode)) {\n\t\tif (!bond_slave_override(bond, skb))\n\t\t\treturn NETDEV_TX_OK;\n\t}\n\n\tswitch (bond->params.mode) {\n\tcase BOND_MODE_ROUNDROBIN:\n\t\treturn bond_xmit_roundrobin(skb, dev);\n\tcase BOND_MODE_ACTIVEBACKUP:\n\t\treturn bond_xmit_activebackup(skb, dev);\n\tcase BOND_MODE_XOR:\n\t\treturn bond_xmit_xor(skb, dev);\n\tcase BOND_MODE_BROADCAST:\n\t\treturn bond_xmit_broadcast(skb, dev);\n\tcase BOND_MODE_8023AD:\n\t\treturn bond_3ad_xmit_xor(skb, dev);\n\tcase BOND_MODE_ALB:\n\tcase BOND_MODE_TLB:\n\t\treturn bond_alb_xmit(skb, dev);\n\tdefault:\n\t\t/* Should never happen, mode already checked */\n\t\tpr_err(\"%s: Error: Unknown bonding mode %d\\n\",\n\t\t       dev->name, bond->params.mode);\n\t\tWARN_ON_ONCE(1);\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n}\n\nstatic netdev_tx_t bond_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct bonding *bond = netdev_priv(dev);\n\tnetdev_tx_t ret = NETDEV_TX_OK;\n\n\t/*\n\t * If we risk deadlock from transmitting this in the\n\t * netpoll path, tell netpoll to queue the frame for later tx\n\t */\n\tif (is_netpoll_tx_blocked(dev))\n\t\treturn NETDEV_TX_BUSY;\n\n\tread_lock(&bond->lock);\n\n\tif (bond->slave_cnt)\n\t\tret = __bond_start_xmit(skb, dev);\n\telse\n\t\tdev_kfree_skb(skb);\n\n\tread_unlock(&bond->lock);\n\n\treturn ret;\n}\n\n/*\n * set bond mode specific net device operations\n */\nvoid bond_set_mode_ops(struct bonding *bond, int mode)\n{\n\tstruct net_device *bond_dev = bond->dev;\n\n\tswitch (mode) {\n\tcase BOND_MODE_ROUNDROBIN:\n\t\tbreak;\n\tcase BOND_MODE_ACTIVEBACKUP:\n\t\tbreak;\n\tcase BOND_MODE_XOR:\n\t\tbond_set_xmit_hash_policy(bond);\n\t\tbreak;\n\tcase BOND_MODE_BROADCAST:\n\t\tbreak;\n\tcase BOND_MODE_8023AD:\n\t\tbond_set_xmit_hash_policy(bond);\n\t\tbreak;\n\tcase BOND_MODE_ALB:\n\t\t/* FALLTHRU */\n\tcase BOND_MODE_TLB:\n\t\tbreak;\n\tdefault:\n\t\t/* Should never happen, mode already checked */\n\t\tpr_err(\"%s: Error: Unknown bonding mode %d\\n\",\n\t\t       bond_dev->name, mode);\n\t\tbreak;\n\t}\n}\n\nstatic void bond_ethtool_get_drvinfo(struct net_device *bond_dev,\n\t\t\t\t    struct ethtool_drvinfo *drvinfo)\n{\n\tstrncpy(drvinfo->driver, DRV_NAME, 32);\n\tstrncpy(drvinfo->version, DRV_VERSION, 32);\n\tsnprintf(drvinfo->fw_version, 32, \"%d\", BOND_ABI_VERSION);\n}\n\nstatic const struct ethtool_ops bond_ethtool_ops = {\n\t.get_drvinfo\t\t= bond_ethtool_get_drvinfo,\n\t.get_link\t\t= ethtool_op_get_link,\n};\n\nstatic const struct net_device_ops bond_netdev_ops = {\n\t.ndo_init\t\t= bond_init,\n\t.ndo_uninit\t\t= bond_uninit,\n\t.ndo_open\t\t= bond_open,\n\t.ndo_stop\t\t= bond_close,\n\t.ndo_start_xmit\t\t= bond_start_xmit,\n\t.ndo_select_queue\t= bond_select_queue,\n\t.ndo_get_stats64\t= bond_get_stats,\n\t.ndo_do_ioctl\t\t= bond_do_ioctl,\n\t.ndo_set_multicast_list\t= bond_set_multicast_list,\n\t.ndo_change_mtu\t\t= bond_change_mtu,\n\t.ndo_set_mac_address\t= bond_set_mac_address,\n\t.ndo_neigh_setup\t= bond_neigh_setup,\n\t.ndo_vlan_rx_add_vid\t= bond_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid\t= bond_vlan_rx_kill_vid,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_netpoll_setup\t= bond_netpoll_setup,\n\t.ndo_netpoll_cleanup\t= bond_netpoll_cleanup,\n\t.ndo_poll_controller\t= bond_poll_controller,\n#endif\n\t.ndo_add_slave\t\t= bond_enslave,\n\t.ndo_del_slave\t\t= bond_release,\n\t.ndo_fix_features\t= bond_fix_features,\n};\n\nstatic void bond_destructor(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tif (bond->wq)\n\t\tdestroy_workqueue(bond->wq);\n\tfree_netdev(bond_dev);\n}\n\nstatic void bond_setup(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\n\t/* initialize rwlocks */\n\trwlock_init(&bond->lock);\n\trwlock_init(&bond->curr_slave_lock);\n\n\tbond->params = bonding_defaults;\n\n\t/* Initialize pointers */\n\tbond->dev = bond_dev;\n\tINIT_LIST_HEAD(&bond->vlan_list);\n\n\t/* Initialize the device entry points */\n\tether_setup(bond_dev);\n\tbond_dev->netdev_ops = &bond_netdev_ops;\n\tbond_dev->ethtool_ops = &bond_ethtool_ops;\n\tbond_set_mode_ops(bond, bond->params.mode);\n\n\tbond_dev->destructor = bond_destructor;\n\n\t/* Initialize the device options */\n\tbond_dev->tx_queue_len = 0;\n\tbond_dev->flags |= IFF_MASTER|IFF_MULTICAST;\n\tbond_dev->priv_flags |= IFF_BONDING;\n\tbond_dev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n\n\t/* At first, we block adding VLANs. That's the only way to\n\t * prevent problems that occur when adding VLANs over an\n\t * empty bond. The block will be removed once non-challenged\n\t * slaves are enslaved.\n\t */\n\tbond_dev->features |= NETIF_F_VLAN_CHALLENGED;\n\n\t/* don't acquire bond device's netif_tx_lock when\n\t * transmitting */\n\tbond_dev->features |= NETIF_F_LLTX;\n\n\t/* By default, we declare the bond to be fully\n\t * VLAN hardware accelerated capable. Special\n\t * care is taken in the various xmit functions\n\t * when there are slaves that are not hw accel\n\t * capable\n\t */\n\n\tbond_dev->hw_features = BOND_VLAN_FEATURES |\n\t\t\t\tNETIF_F_HW_VLAN_TX |\n\t\t\t\tNETIF_F_HW_VLAN_RX |\n\t\t\t\tNETIF_F_HW_VLAN_FILTER;\n\n\tbond_dev->hw_features &= ~(NETIF_F_ALL_CSUM & ~NETIF_F_NO_CSUM);\n\tbond_dev->features |= bond_dev->hw_features;\n}\n\nstatic void bond_work_cancel_all(struct bonding *bond)\n{\n\twrite_lock_bh(&bond->lock);\n\tbond->kill_timers = 1;\n\twrite_unlock_bh(&bond->lock);\n\n\tif (bond->params.miimon && delayed_work_pending(&bond->mii_work))\n\t\tcancel_delayed_work(&bond->mii_work);\n\n\tif (bond->params.arp_interval && delayed_work_pending(&bond->arp_work))\n\t\tcancel_delayed_work(&bond->arp_work);\n\n\tif (bond->params.mode == BOND_MODE_ALB &&\n\t    delayed_work_pending(&bond->alb_work))\n\t\tcancel_delayed_work(&bond->alb_work);\n\n\tif (bond->params.mode == BOND_MODE_8023AD &&\n\t    delayed_work_pending(&bond->ad_work))\n\t\tcancel_delayed_work(&bond->ad_work);\n\n\tif (delayed_work_pending(&bond->mcast_work))\n\t\tcancel_delayed_work(&bond->mcast_work);\n}\n\n/*\n* Destroy a bonding device.\n* Must be under rtnl_lock when this function is called.\n*/\nstatic void bond_uninit(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct vlan_entry *vlan, *tmp;\n\n\tbond_netpoll_cleanup(bond_dev);\n\n\t/* Release the bonded slaves */\n\tbond_release_all(bond_dev);\n\n\tlist_del(&bond->bond_list);\n\n\tbond_work_cancel_all(bond);\n\n\tbond_remove_proc_entry(bond);\n\n\tbond_debug_unregister(bond);\n\n\t__hw_addr_flush(&bond->mc_list);\n\n\tlist_for_each_entry_safe(vlan, tmp, &bond->vlan_list, vlan_list) {\n\t\tlist_del(&vlan->vlan_list);\n\t\tkfree(vlan);\n\t}\n}\n\n/*------------------------- Module initialization ---------------------------*/\n\n/*\n * Convert string input module parms.  Accept either the\n * number of the mode or its string name.  A bit complicated because\n * some mode names are substrings of other names, and calls from sysfs\n * may have whitespace in the name (trailing newlines, for example).\n */\nint bond_parse_parm(const char *buf, const struct bond_parm_tbl *tbl)\n{\n\tint modeint = -1, i, rv;\n\tchar *p, modestr[BOND_MAX_MODENAME_LEN + 1] = { 0, };\n\n\tfor (p = (char *)buf; *p; p++)\n\t\tif (!(isdigit(*p) || isspace(*p)))\n\t\t\tbreak;\n\n\tif (*p)\n\t\trv = sscanf(buf, \"%20s\", modestr);\n\telse\n\t\trv = sscanf(buf, \"%d\", &modeint);\n\n\tif (!rv)\n\t\treturn -1;\n\n\tfor (i = 0; tbl[i].modename; i++) {\n\t\tif (modeint == tbl[i].mode)\n\t\t\treturn tbl[i].mode;\n\t\tif (strcmp(modestr, tbl[i].modename) == 0)\n\t\t\treturn tbl[i].mode;\n\t}\n\n\treturn -1;\n}\n\nstatic int bond_check_params(struct bond_params *params)\n{\n\tint arp_validate_value, fail_over_mac_value, primary_reselect_value;\n\n\t/*\n\t * Convert string parameters.\n\t */\n\tif (mode) {\n\t\tbond_mode = bond_parse_parm(mode, bond_mode_tbl);\n\t\tif (bond_mode == -1) {\n\t\t\tpr_err(\"Error: Invalid bonding mode \\\"%s\\\"\\n\",\n\t\t\t       mode == NULL ? \"NULL\" : mode);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (xmit_hash_policy) {\n\t\tif ((bond_mode != BOND_MODE_XOR) &&\n\t\t    (bond_mode != BOND_MODE_8023AD)) {\n\t\t\tpr_info(\"xmit_hash_policy param is irrelevant in mode %s\\n\",\n\t\t\t       bond_mode_name(bond_mode));\n\t\t} else {\n\t\t\txmit_hashtype = bond_parse_parm(xmit_hash_policy,\n\t\t\t\t\t\t\txmit_hashtype_tbl);\n\t\t\tif (xmit_hashtype == -1) {\n\t\t\t\tpr_err(\"Error: Invalid xmit_hash_policy \\\"%s\\\"\\n\",\n\t\t\t\t       xmit_hash_policy == NULL ? \"NULL\" :\n\t\t\t\t       xmit_hash_policy);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (lacp_rate) {\n\t\tif (bond_mode != BOND_MODE_8023AD) {\n\t\t\tpr_info(\"lacp_rate param is irrelevant in mode %s\\n\",\n\t\t\t\tbond_mode_name(bond_mode));\n\t\t} else {\n\t\t\tlacp_fast = bond_parse_parm(lacp_rate, bond_lacp_tbl);\n\t\t\tif (lacp_fast == -1) {\n\t\t\t\tpr_err(\"Error: Invalid lacp rate \\\"%s\\\"\\n\",\n\t\t\t\t       lacp_rate == NULL ? \"NULL\" : lacp_rate);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ad_select) {\n\t\tparams->ad_select = bond_parse_parm(ad_select, ad_select_tbl);\n\t\tif (params->ad_select == -1) {\n\t\t\tpr_err(\"Error: Invalid ad_select \\\"%s\\\"\\n\",\n\t\t\t       ad_select == NULL ? \"NULL\" : ad_select);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (bond_mode != BOND_MODE_8023AD) {\n\t\t\tpr_warning(\"ad_select param only affects 802.3ad mode\\n\");\n\t\t}\n\t} else {\n\t\tparams->ad_select = BOND_AD_STABLE;\n\t}\n\n\tif (max_bonds < 0) {\n\t\tpr_warning(\"Warning: max_bonds (%d) not in range %d-%d, so it was reset to BOND_DEFAULT_MAX_BONDS (%d)\\n\",\n\t\t\t   max_bonds, 0, INT_MAX, BOND_DEFAULT_MAX_BONDS);\n\t\tmax_bonds = BOND_DEFAULT_MAX_BONDS;\n\t}\n\n\tif (miimon < 0) {\n\t\tpr_warning(\"Warning: miimon module parameter (%d), not in range 0-%d, so it was reset to %d\\n\",\n\t\t\t   miimon, INT_MAX, BOND_LINK_MON_INTERV);\n\t\tmiimon = BOND_LINK_MON_INTERV;\n\t}\n\n\tif (updelay < 0) {\n\t\tpr_warning(\"Warning: updelay module parameter (%d), not in range 0-%d, so it was reset to 0\\n\",\n\t\t\t   updelay, INT_MAX);\n\t\tupdelay = 0;\n\t}\n\n\tif (downdelay < 0) {\n\t\tpr_warning(\"Warning: downdelay module parameter (%d), not in range 0-%d, so it was reset to 0\\n\",\n\t\t\t   downdelay, INT_MAX);\n\t\tdowndelay = 0;\n\t}\n\n\tif ((use_carrier != 0) && (use_carrier != 1)) {\n\t\tpr_warning(\"Warning: use_carrier module parameter (%d), not of valid value (0/1), so it was set to 1\\n\",\n\t\t\t   use_carrier);\n\t\tuse_carrier = 1;\n\t}\n\n\tif (num_peer_notif < 0 || num_peer_notif > 255) {\n\t\tpr_warning(\"Warning: num_grat_arp/num_unsol_na (%d) not in range 0-255 so it was reset to 1\\n\",\n\t\t\t   num_peer_notif);\n\t\tnum_peer_notif = 1;\n\t}\n\n\t/* reset values for 802.3ad */\n\tif (bond_mode == BOND_MODE_8023AD) {\n\t\tif (!miimon) {\n\t\t\tpr_warning(\"Warning: miimon must be specified, otherwise bonding will not detect link failure, speed and duplex which are essential for 802.3ad operation\\n\");\n\t\t\tpr_warning(\"Forcing miimon to 100msec\\n\");\n\t\t\tmiimon = 100;\n\t\t}\n\t}\n\n\tif (tx_queues < 1 || tx_queues > 255) {\n\t\tpr_warning(\"Warning: tx_queues (%d) should be between \"\n\t\t\t   \"1 and 255, resetting to %d\\n\",\n\t\t\t   tx_queues, BOND_DEFAULT_TX_QUEUES);\n\t\ttx_queues = BOND_DEFAULT_TX_QUEUES;\n\t}\n\n\tif ((all_slaves_active != 0) && (all_slaves_active != 1)) {\n\t\tpr_warning(\"Warning: all_slaves_active module parameter (%d), \"\n\t\t\t   \"not of valid value (0/1), so it was set to \"\n\t\t\t   \"0\\n\", all_slaves_active);\n\t\tall_slaves_active = 0;\n\t}\n\n\tif (resend_igmp < 0 || resend_igmp > 255) {\n\t\tpr_warning(\"Warning: resend_igmp (%d) should be between \"\n\t\t\t   \"0 and 255, resetting to %d\\n\",\n\t\t\t   resend_igmp, BOND_DEFAULT_RESEND_IGMP);\n\t\tresend_igmp = BOND_DEFAULT_RESEND_IGMP;\n\t}\n\n\t/* reset values for TLB/ALB */\n\tif ((bond_mode == BOND_MODE_TLB) ||\n\t    (bond_mode == BOND_MODE_ALB)) {\n\t\tif (!miimon) {\n\t\t\tpr_warning(\"Warning: miimon must be specified, otherwise bonding will not detect link failure and link speed which are essential for TLB/ALB load balancing\\n\");\n\t\t\tpr_warning(\"Forcing miimon to 100msec\\n\");\n\t\t\tmiimon = 100;\n\t\t}\n\t}\n\n\tif (bond_mode == BOND_MODE_ALB) {\n\t\tpr_notice(\"In ALB mode you might experience client disconnections upon reconnection of a link if the bonding module updelay parameter (%d msec) is incompatible with the forwarding delay time of the switch\\n\",\n\t\t\t  updelay);\n\t}\n\n\tif (!miimon) {\n\t\tif (updelay || downdelay) {\n\t\t\t/* just warn the user the up/down delay will have\n\t\t\t * no effect since miimon is zero...\n\t\t\t */\n\t\t\tpr_warning(\"Warning: miimon module parameter not set and updelay (%d) or downdelay (%d) module parameter is set; updelay and downdelay have no effect unless miimon is set\\n\",\n\t\t\t\t   updelay, downdelay);\n\t\t}\n\t} else {\n\t\t/* don't allow arp monitoring */\n\t\tif (arp_interval) {\n\t\t\tpr_warning(\"Warning: miimon (%d) and arp_interval (%d) can't be used simultaneously, disabling ARP monitoring\\n\",\n\t\t\t\t   miimon, arp_interval);\n\t\t\tarp_interval = 0;\n\t\t}\n\n\t\tif ((updelay % miimon) != 0) {\n\t\t\tpr_warning(\"Warning: updelay (%d) is not a multiple of miimon (%d), updelay rounded to %d ms\\n\",\n\t\t\t\t   updelay, miimon,\n\t\t\t\t   (updelay / miimon) * miimon);\n\t\t}\n\n\t\tupdelay /= miimon;\n\n\t\tif ((downdelay % miimon) != 0) {\n\t\t\tpr_warning(\"Warning: downdelay (%d) is not a multiple of miimon (%d), downdelay rounded to %d ms\\n\",\n\t\t\t\t   downdelay, miimon,\n\t\t\t\t   (downdelay / miimon) * miimon);\n\t\t}\n\n\t\tdowndelay /= miimon;\n\t}\n\n\tif (arp_interval < 0) {\n\t\tpr_warning(\"Warning: arp_interval module parameter (%d) , not in range 0-%d, so it was reset to %d\\n\",\n\t\t\t   arp_interval, INT_MAX, BOND_LINK_ARP_INTERV);\n\t\tarp_interval = BOND_LINK_ARP_INTERV;\n\t}\n\n\tfor (arp_ip_count = 0;\n\t     (arp_ip_count < BOND_MAX_ARP_TARGETS) && arp_ip_target[arp_ip_count];\n\t     arp_ip_count++) {\n\t\t/* not complete check, but should be good enough to\n\t\t   catch mistakes */\n\t\tif (!isdigit(arp_ip_target[arp_ip_count][0])) {\n\t\t\tpr_warning(\"Warning: bad arp_ip_target module parameter (%s), ARP monitoring will not be performed\\n\",\n\t\t\t\t   arp_ip_target[arp_ip_count]);\n\t\t\tarp_interval = 0;\n\t\t} else {\n\t\t\t__be32 ip = in_aton(arp_ip_target[arp_ip_count]);\n\t\t\tarp_target[arp_ip_count] = ip;\n\t\t}\n\t}\n\n\tif (arp_interval && !arp_ip_count) {\n\t\t/* don't allow arping if no arp_ip_target given... */\n\t\tpr_warning(\"Warning: arp_interval module parameter (%d) specified without providing an arp_ip_target parameter, arp_interval was reset to 0\\n\",\n\t\t\t   arp_interval);\n\t\tarp_interval = 0;\n\t}\n\n\tif (arp_validate) {\n\t\tif (bond_mode != BOND_MODE_ACTIVEBACKUP) {\n\t\t\tpr_err(\"arp_validate only supported in active-backup mode\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!arp_interval) {\n\t\t\tpr_err(\"arp_validate requires arp_interval\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tarp_validate_value = bond_parse_parm(arp_validate,\n\t\t\t\t\t\t     arp_validate_tbl);\n\t\tif (arp_validate_value == -1) {\n\t\t\tpr_err(\"Error: invalid arp_validate \\\"%s\\\"\\n\",\n\t\t\t       arp_validate == NULL ? \"NULL\" : arp_validate);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else\n\t\tarp_validate_value = 0;\n\n\tif (miimon) {\n\t\tpr_info(\"MII link monitoring set to %d ms\\n\", miimon);\n\t} else if (arp_interval) {\n\t\tint i;\n\n\t\tpr_info(\"ARP monitoring set to %d ms, validate %s, with %d target(s):\",\n\t\t\tarp_interval,\n\t\t\tarp_validate_tbl[arp_validate_value].modename,\n\t\t\tarp_ip_count);\n\n\t\tfor (i = 0; i < arp_ip_count; i++)\n\t\t\tpr_info(\" %s\", arp_ip_target[i]);\n\n\t\tpr_info(\"\\n\");\n\n\t} else if (max_bonds) {\n\t\t/* miimon and arp_interval not set, we need one so things\n\t\t * work as expected, see bonding.txt for details\n\t\t */\n\t\tpr_warning(\"Warning: either miimon or arp_interval and arp_ip_target module parameters must be specified, otherwise bonding will not detect link failures! see bonding.txt for details.\\n\");\n\t}\n\n\tif (primary && !USES_PRIMARY(bond_mode)) {\n\t\t/* currently, using a primary only makes sense\n\t\t * in active backup, TLB or ALB modes\n\t\t */\n\t\tpr_warning(\"Warning: %s primary device specified but has no effect in %s mode\\n\",\n\t\t\t   primary, bond_mode_name(bond_mode));\n\t\tprimary = NULL;\n\t}\n\n\tif (primary && primary_reselect) {\n\t\tprimary_reselect_value = bond_parse_parm(primary_reselect,\n\t\t\t\t\t\t\t pri_reselect_tbl);\n\t\tif (primary_reselect_value == -1) {\n\t\t\tpr_err(\"Error: Invalid primary_reselect \\\"%s\\\"\\n\",\n\t\t\t       primary_reselect ==\n\t\t\t\t\tNULL ? \"NULL\" : primary_reselect);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tprimary_reselect_value = BOND_PRI_RESELECT_ALWAYS;\n\t}\n\n\tif (fail_over_mac) {\n\t\tfail_over_mac_value = bond_parse_parm(fail_over_mac,\n\t\t\t\t\t\t      fail_over_mac_tbl);\n\t\tif (fail_over_mac_value == -1) {\n\t\t\tpr_err(\"Error: invalid fail_over_mac \\\"%s\\\"\\n\",\n\t\t\t       arp_validate == NULL ? \"NULL\" : arp_validate);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (bond_mode != BOND_MODE_ACTIVEBACKUP)\n\t\t\tpr_warning(\"Warning: fail_over_mac only affects active-backup mode.\\n\");\n\t} else {\n\t\tfail_over_mac_value = BOND_FOM_NONE;\n\t}\n\n\t/* fill params struct with the proper values */\n\tparams->mode = bond_mode;\n\tparams->xmit_policy = xmit_hashtype;\n\tparams->miimon = miimon;\n\tparams->num_peer_notif = num_peer_notif;\n\tparams->arp_interval = arp_interval;\n\tparams->arp_validate = arp_validate_value;\n\tparams->updelay = updelay;\n\tparams->downdelay = downdelay;\n\tparams->use_carrier = use_carrier;\n\tparams->lacp_fast = lacp_fast;\n\tparams->primary[0] = 0;\n\tparams->primary_reselect = primary_reselect_value;\n\tparams->fail_over_mac = fail_over_mac_value;\n\tparams->tx_queues = tx_queues;\n\tparams->all_slaves_active = all_slaves_active;\n\tparams->resend_igmp = resend_igmp;\n\tparams->min_links = min_links;\n\n\tif (primary) {\n\t\tstrncpy(params->primary, primary, IFNAMSIZ);\n\t\tparams->primary[IFNAMSIZ - 1] = 0;\n\t}\n\n\tmemcpy(params->arp_targets, arp_target, sizeof(arp_target));\n\n\treturn 0;\n}\n\nstatic struct lock_class_key bonding_netdev_xmit_lock_key;\nstatic struct lock_class_key bonding_netdev_addr_lock_key;\n\nstatic void bond_set_lockdep_class_one(struct net_device *dev,\n\t\t\t\t       struct netdev_queue *txq,\n\t\t\t\t       void *_unused)\n{\n\tlockdep_set_class(&txq->_xmit_lock,\n\t\t\t  &bonding_netdev_xmit_lock_key);\n}\n\nstatic void bond_set_lockdep_class(struct net_device *dev)\n{\n\tlockdep_set_class(&dev->addr_list_lock,\n\t\t\t  &bonding_netdev_addr_lock_key);\n\tnetdev_for_each_tx_queue(dev, bond_set_lockdep_class_one, NULL);\n}\n\n/*\n * Called from registration process\n */\nstatic int bond_init(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct bond_net *bn = net_generic(dev_net(bond_dev), bond_net_id);\n\tstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\n\n\tpr_debug(\"Begin bond_init for %s\\n\", bond_dev->name);\n\n\t/*\n\t * Initialize locks that may be required during\n\t * en/deslave operations.  All of the bond_open work\n\t * (of which this is part) should really be moved to\n\t * a phase prior to dev_open\n\t */\n\tspin_lock_init(&(bond_info->tx_hashtbl_lock));\n\tspin_lock_init(&(bond_info->rx_hashtbl_lock));\n\n\tbond->wq = create_singlethread_workqueue(bond_dev->name);\n\tif (!bond->wq)\n\t\treturn -ENOMEM;\n\n\tbond_set_lockdep_class(bond_dev);\n\n\tbond_create_proc_entry(bond);\n\tlist_add_tail(&bond->bond_list, &bn->dev_list);\n\n\tbond_prepare_sysfs_group(bond);\n\n\tbond_debug_register(bond);\n\n\t__hw_addr_init(&bond->mc_list);\n\treturn 0;\n}\n\nstatic int bond_validate(struct nlattr *tb[], struct nlattr *data[])\n{\n\tif (tb[IFLA_ADDRESS]) {\n\t\tif (nla_len(tb[IFLA_ADDRESS]) != ETH_ALEN)\n\t\t\treturn -EINVAL;\n\t\tif (!is_valid_ether_addr(nla_data(tb[IFLA_ADDRESS])))\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\treturn 0;\n}\n\nstatic struct rtnl_link_ops bond_link_ops __read_mostly = {\n\t.kind\t\t= \"bond\",\n\t.priv_size\t= sizeof(struct bonding),\n\t.setup\t\t= bond_setup,\n\t.validate\t= bond_validate,\n};\n\n/* Create a new bond based on the specified name and bonding parameters.\n * If name is NULL, obtain a suitable \"bond%d\" name for us.\n * Caller must NOT hold rtnl_lock; we need to release it here before we\n * set up our sysfs entries.\n */\nint bond_create(struct net *net, const char *name)\n{\n\tstruct net_device *bond_dev;\n\tint res;\n\n\trtnl_lock();\n\n\tbond_dev = alloc_netdev_mq(sizeof(struct bonding),\n\t\t\t\t   name ? name : \"bond%d\",\n\t\t\t\t   bond_setup, tx_queues);\n\tif (!bond_dev) {\n\t\tpr_err(\"%s: eek! can't alloc netdev!\\n\", name);\n\t\trtnl_unlock();\n\t\treturn -ENOMEM;\n\t}\n\n\tdev_net_set(bond_dev, net);\n\tbond_dev->rtnl_link_ops = &bond_link_ops;\n\n\tres = register_netdevice(bond_dev);\n\n\tnetif_carrier_off(bond_dev);\n\n\trtnl_unlock();\n\tif (res < 0)\n\t\tbond_destructor(bond_dev);\n\treturn res;\n}\n\nstatic int __net_init bond_net_init(struct net *net)\n{\n\tstruct bond_net *bn = net_generic(net, bond_net_id);\n\n\tbn->net = net;\n\tINIT_LIST_HEAD(&bn->dev_list);\n\n\tbond_create_proc_dir(bn);\n\t\n\treturn 0;\n}\n\nstatic void __net_exit bond_net_exit(struct net *net)\n{\n\tstruct bond_net *bn = net_generic(net, bond_net_id);\n\n\tbond_destroy_proc_dir(bn);\n}\n\nstatic struct pernet_operations bond_net_ops = {\n\t.init = bond_net_init,\n\t.exit = bond_net_exit,\n\t.id   = &bond_net_id,\n\t.size = sizeof(struct bond_net),\n};\n\nstatic int __init bonding_init(void)\n{\n\tint i;\n\tint res;\n\n\tpr_info(\"%s\", bond_version);\n\n\tres = bond_check_params(&bonding_defaults);\n\tif (res)\n\t\tgoto out;\n\n\tres = register_pernet_subsys(&bond_net_ops);\n\tif (res)\n\t\tgoto out;\n\n\tres = rtnl_link_register(&bond_link_ops);\n\tif (res)\n\t\tgoto err_link;\n\n\tbond_create_debugfs();\n\n\tfor (i = 0; i < max_bonds; i++) {\n\t\tres = bond_create(&init_net, NULL);\n\t\tif (res)\n\t\t\tgoto err;\n\t}\n\n\tres = bond_create_sysfs();\n\tif (res)\n\t\tgoto err;\n\n\tregister_netdevice_notifier(&bond_netdev_notifier);\n\tregister_inetaddr_notifier(&bond_inetaddr_notifier);\nout:\n\treturn res;\nerr:\n\trtnl_link_unregister(&bond_link_ops);\nerr_link:\n\tunregister_pernet_subsys(&bond_net_ops);\n\tgoto out;\n\n}\n\nstatic void __exit bonding_exit(void)\n{\n\tunregister_netdevice_notifier(&bond_netdev_notifier);\n\tunregister_inetaddr_notifier(&bond_inetaddr_notifier);\n\n\tbond_destroy_sysfs();\n\tbond_destroy_debugfs();\n\n\trtnl_link_unregister(&bond_link_ops);\n\tunregister_pernet_subsys(&bond_net_ops);\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t/*\n\t * Make sure we don't have an imbalance on our netpoll blocking\n\t */\n\tWARN_ON(atomic_read(&netpoll_block_tx));\n#endif\n}\n\nmodule_init(bonding_init);\nmodule_exit(bonding_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_VERSION);\nMODULE_DESCRIPTION(DRV_DESCRIPTION \", v\" DRV_VERSION);\nMODULE_AUTHOR(\"Thomas Davis, tadavis@lbl.gov and many others\");\nMODULE_ALIAS_RTNL_LINK(\"bond\");\n", "/* drivers/net/ifb.c:\n\n\tThe purpose of this driver is to provide a device that allows\n\tfor sharing of resources:\n\n\t1) qdiscs/policies that are per device as opposed to system wide.\n\tifb allows for a device which can be redirected to thus providing\n\tan impression of sharing.\n\n\t2) Allows for queueing incoming traffic for shaping instead of\n\tdropping.\n\n\tThe original concept is based on what is known as the IMQ\n\tdriver initially written by Martin Devera, later rewritten\n\tby Patrick McHardy and then maintained by Andre Correa.\n\n\tYou need the tc action  mirror or redirect to feed this device\n       \tpackets.\n\n\tThis program is free software; you can redistribute it and/or\n\tmodify it under the terms of the GNU General Public License\n\tas published by the Free Software Foundation; either version\n\t2 of the License, or (at your option) any later version.\n\n  \tAuthors:\tJamal Hadi Salim (2005)\n\n*/\n\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/moduleparam.h>\n#include <net/pkt_sched.h>\n#include <net/net_namespace.h>\n\n#define TX_Q_LIMIT    32\nstruct ifb_private {\n\tstruct tasklet_struct   ifb_tasklet;\n\tint     tasklet_pending;\n\n\tstruct u64_stats_sync\trsync;\n\tstruct sk_buff_head     rq;\n\tu64 rx_packets;\n\tu64 rx_bytes;\n\n\tstruct u64_stats_sync\ttsync;\n\tstruct sk_buff_head     tq;\n\tu64 tx_packets;\n\tu64 tx_bytes;\n};\n\nstatic int numifbs = 2;\n\nstatic void ri_tasklet(unsigned long dev);\nstatic netdev_tx_t ifb_xmit(struct sk_buff *skb, struct net_device *dev);\nstatic int ifb_open(struct net_device *dev);\nstatic int ifb_close(struct net_device *dev);\n\nstatic void ri_tasklet(unsigned long dev)\n{\n\tstruct net_device *_dev = (struct net_device *)dev;\n\tstruct ifb_private *dp = netdev_priv(_dev);\n\tstruct netdev_queue *txq;\n\tstruct sk_buff *skb;\n\n\ttxq = netdev_get_tx_queue(_dev, 0);\n\tif ((skb = skb_peek(&dp->tq)) == NULL) {\n\t\tif (__netif_tx_trylock(txq)) {\n\t\t\tskb_queue_splice_tail_init(&dp->rq, &dp->tq);\n\t\t\t__netif_tx_unlock(txq);\n\t\t} else {\n\t\t\t/* reschedule */\n\t\t\tgoto resched;\n\t\t}\n\t}\n\n\twhile ((skb = __skb_dequeue(&dp->tq)) != NULL) {\n\t\tu32 from = G_TC_FROM(skb->tc_verd);\n\n\t\tskb->tc_verd = 0;\n\t\tskb->tc_verd = SET_TC_NCLS(skb->tc_verd);\n\n\t\tu64_stats_update_begin(&dp->tsync);\n\t\tdp->tx_packets++;\n\t\tdp->tx_bytes += skb->len;\n\t\tu64_stats_update_end(&dp->tsync);\n\n\t\trcu_read_lock();\n\t\tskb->dev = dev_get_by_index_rcu(&init_net, skb->skb_iif);\n\t\tif (!skb->dev) {\n\t\t\trcu_read_unlock();\n\t\t\tdev_kfree_skb(skb);\n\t\t\t_dev->stats.tx_dropped++;\n\t\t\tif (skb_queue_len(&dp->tq) != 0)\n\t\t\t\tgoto resched;\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t\tskb->skb_iif = _dev->ifindex;\n\n\t\tif (from & AT_EGRESS) {\n\t\t\tdev_queue_xmit(skb);\n\t\t} else if (from & AT_INGRESS) {\n\t\t\tskb_pull(skb, skb->dev->hard_header_len);\n\t\t\tnetif_receive_skb(skb);\n\t\t} else\n\t\t\tBUG();\n\t}\n\n\tif (__netif_tx_trylock(txq)) {\n\t\tif ((skb = skb_peek(&dp->rq)) == NULL) {\n\t\t\tdp->tasklet_pending = 0;\n\t\t\tif (netif_queue_stopped(_dev))\n\t\t\t\tnetif_wake_queue(_dev);\n\t\t} else {\n\t\t\t__netif_tx_unlock(txq);\n\t\t\tgoto resched;\n\t\t}\n\t\t__netif_tx_unlock(txq);\n\t} else {\nresched:\n\t\tdp->tasklet_pending = 1;\n\t\ttasklet_schedule(&dp->ifb_tasklet);\n\t}\n\n}\n\nstatic struct rtnl_link_stats64 *ifb_stats64(struct net_device *dev,\n\t\t\t\t\t     struct rtnl_link_stats64 *stats)\n{\n\tstruct ifb_private *dp = netdev_priv(dev);\n\tunsigned int start;\n\n\tdo {\n\t\tstart = u64_stats_fetch_begin_bh(&dp->rsync);\n\t\tstats->rx_packets = dp->rx_packets;\n\t\tstats->rx_bytes = dp->rx_bytes;\n\t} while (u64_stats_fetch_retry_bh(&dp->rsync, start));\n\n\tdo {\n\t\tstart = u64_stats_fetch_begin_bh(&dp->tsync);\n\n\t\tstats->tx_packets = dp->tx_packets;\n\t\tstats->tx_bytes = dp->tx_bytes;\n\n\t} while (u64_stats_fetch_retry_bh(&dp->tsync, start));\n\n\tstats->rx_dropped = dev->stats.rx_dropped;\n\tstats->tx_dropped = dev->stats.tx_dropped;\n\n\treturn stats;\n}\n\n\nstatic const struct net_device_ops ifb_netdev_ops = {\n\t.ndo_open\t= ifb_open,\n\t.ndo_stop\t= ifb_close,\n\t.ndo_get_stats64 = ifb_stats64,\n\t.ndo_start_xmit\t= ifb_xmit,\n\t.ndo_validate_addr = eth_validate_addr,\n};\n\n#define IFB_FEATURES (NETIF_F_NO_CSUM | NETIF_F_SG  | NETIF_F_FRAGLIST\t| \\\n\t\t      NETIF_F_TSO_ECN | NETIF_F_TSO | NETIF_F_TSO6\t| \\\n\t\t      NETIF_F_HIGHDMA | NETIF_F_HW_VLAN_TX)\n\nstatic void ifb_setup(struct net_device *dev)\n{\n\t/* Initialize the device structure. */\n\tdev->destructor = free_netdev;\n\tdev->netdev_ops = &ifb_netdev_ops;\n\n\t/* Fill in device structure with ethernet-generic values. */\n\tether_setup(dev);\n\tdev->tx_queue_len = TX_Q_LIMIT;\n\n\tdev->features |= IFB_FEATURES;\n\tdev->vlan_features |= IFB_FEATURES;\n\n\tdev->flags |= IFF_NOARP;\n\tdev->flags &= ~IFF_MULTICAST;\n\tdev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n\trandom_ether_addr(dev->dev_addr);\n}\n\nstatic netdev_tx_t ifb_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ifb_private *dp = netdev_priv(dev);\n\tu32 from = G_TC_FROM(skb->tc_verd);\n\n\tu64_stats_update_begin(&dp->rsync);\n\tdp->rx_packets++;\n\tdp->rx_bytes += skb->len;\n\tu64_stats_update_end(&dp->rsync);\n\n\tif (!(from & (AT_INGRESS|AT_EGRESS)) || !skb->skb_iif) {\n\t\tdev_kfree_skb(skb);\n\t\tdev->stats.rx_dropped++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tif (skb_queue_len(&dp->rq) >= dev->tx_queue_len) {\n\t\tnetif_stop_queue(dev);\n\t}\n\n\t__skb_queue_tail(&dp->rq, skb);\n\tif (!dp->tasklet_pending) {\n\t\tdp->tasklet_pending = 1;\n\t\ttasklet_schedule(&dp->ifb_tasklet);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int ifb_close(struct net_device *dev)\n{\n\tstruct ifb_private *dp = netdev_priv(dev);\n\n\ttasklet_kill(&dp->ifb_tasklet);\n\tnetif_stop_queue(dev);\n\t__skb_queue_purge(&dp->rq);\n\t__skb_queue_purge(&dp->tq);\n\treturn 0;\n}\n\nstatic int ifb_open(struct net_device *dev)\n{\n\tstruct ifb_private *dp = netdev_priv(dev);\n\n\ttasklet_init(&dp->ifb_tasklet, ri_tasklet, (unsigned long)dev);\n\t__skb_queue_head_init(&dp->rq);\n\t__skb_queue_head_init(&dp->tq);\n\tnetif_start_queue(dev);\n\n\treturn 0;\n}\n\nstatic int ifb_validate(struct nlattr *tb[], struct nlattr *data[])\n{\n\tif (tb[IFLA_ADDRESS]) {\n\t\tif (nla_len(tb[IFLA_ADDRESS]) != ETH_ALEN)\n\t\t\treturn -EINVAL;\n\t\tif (!is_valid_ether_addr(nla_data(tb[IFLA_ADDRESS])))\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\treturn 0;\n}\n\nstatic struct rtnl_link_ops ifb_link_ops __read_mostly = {\n\t.kind\t\t= \"ifb\",\n\t.priv_size\t= sizeof(struct ifb_private),\n\t.setup\t\t= ifb_setup,\n\t.validate\t= ifb_validate,\n};\n\n/* Number of ifb devices to be set up by this module. */\nmodule_param(numifbs, int, 0);\nMODULE_PARM_DESC(numifbs, \"Number of ifb devices\");\n\nstatic int __init ifb_init_one(int index)\n{\n\tstruct net_device *dev_ifb;\n\tint err;\n\n\tdev_ifb = alloc_netdev(sizeof(struct ifb_private),\n\t\t\t\t \"ifb%d\", ifb_setup);\n\n\tif (!dev_ifb)\n\t\treturn -ENOMEM;\n\n\tdev_ifb->rtnl_link_ops = &ifb_link_ops;\n\terr = register_netdevice(dev_ifb);\n\tif (err < 0)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tfree_netdev(dev_ifb);\n\treturn err;\n}\n\nstatic int __init ifb_init_module(void)\n{\n\tint i, err;\n\n\trtnl_lock();\n\terr = __rtnl_link_register(&ifb_link_ops);\n\n\tfor (i = 0; i < numifbs && !err; i++)\n\t\terr = ifb_init_one(i);\n\tif (err)\n\t\t__rtnl_link_unregister(&ifb_link_ops);\n\trtnl_unlock();\n\n\treturn err;\n}\n\nstatic void __exit ifb_cleanup_module(void)\n{\n\trtnl_link_unregister(&ifb_link_ops);\n}\n\nmodule_init(ifb_init_module);\nmodule_exit(ifb_cleanup_module);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Jamal Hadi Salim\");\nMODULE_ALIAS_RTNL_LINK(\"ifb\");\n", "/*\n * Copyright (c) 2007 Patrick McHardy <kaber@trash.net>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of\n * the License, or (at your option) any later version.\n *\n * The code this is based on carried the following copyright notice:\n * ---\n * (C) Copyright 2001-2006\n * Alex Zeffertt, Cambridge Broadband Ltd, ajz@cambridgebroadband.com\n * Re-worked by Ben Greear <greearb@candelatech.com>\n * ---\n */\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/rculist.h>\n#include <linux/notifier.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/if_arp.h>\n#include <linux/if_link.h>\n#include <linux/if_macvlan.h>\n#include <net/rtnetlink.h>\n#include <net/xfrm.h>\n\n#define MACVLAN_HASH_SIZE\t(1 << BITS_PER_BYTE)\n\nstruct macvlan_port {\n\tstruct net_device\t*dev;\n\tstruct hlist_head\tvlan_hash[MACVLAN_HASH_SIZE];\n\tstruct list_head\tvlans;\n\tstruct rcu_head\t\trcu;\n\tbool \t\t\tpassthru;\n\tint\t\t\tcount;\n};\n\nstatic void macvlan_port_destroy(struct net_device *dev);\n\n#define macvlan_port_get_rcu(dev) \\\n\t((struct macvlan_port *) rcu_dereference(dev->rx_handler_data))\n#define macvlan_port_get(dev) ((struct macvlan_port *) dev->rx_handler_data)\n#define macvlan_port_exists(dev) (dev->priv_flags & IFF_MACVLAN_PORT)\n\nstatic struct macvlan_dev *macvlan_hash_lookup(const struct macvlan_port *port,\n\t\t\t\t\t       const unsigned char *addr)\n{\n\tstruct macvlan_dev *vlan;\n\tstruct hlist_node *n;\n\n\thlist_for_each_entry_rcu(vlan, n, &port->vlan_hash[addr[5]], hlist) {\n\t\tif (!compare_ether_addr_64bits(vlan->dev->dev_addr, addr))\n\t\t\treturn vlan;\n\t}\n\treturn NULL;\n}\n\nstatic void macvlan_hash_add(struct macvlan_dev *vlan)\n{\n\tstruct macvlan_port *port = vlan->port;\n\tconst unsigned char *addr = vlan->dev->dev_addr;\n\n\thlist_add_head_rcu(&vlan->hlist, &port->vlan_hash[addr[5]]);\n}\n\nstatic void macvlan_hash_del(struct macvlan_dev *vlan, bool sync)\n{\n\thlist_del_rcu(&vlan->hlist);\n\tif (sync)\n\t\tsynchronize_rcu();\n}\n\nstatic void macvlan_hash_change_addr(struct macvlan_dev *vlan,\n\t\t\t\t\tconst unsigned char *addr)\n{\n\tmacvlan_hash_del(vlan, true);\n\t/* Now that we are unhashed it is safe to change the device\n\t * address without confusing packet delivery.\n\t */\n\tmemcpy(vlan->dev->dev_addr, addr, ETH_ALEN);\n\tmacvlan_hash_add(vlan);\n}\n\nstatic int macvlan_addr_busy(const struct macvlan_port *port,\n\t\t\t\tconst unsigned char *addr)\n{\n\t/* Test to see if the specified multicast address is\n\t * currently in use by the underlying device or\n\t * another macvlan.\n\t */\n\tif (!compare_ether_addr_64bits(port->dev->dev_addr, addr))\n\t\treturn 1;\n\n\tif (macvlan_hash_lookup(port, addr))\n\t\treturn 1;\n\n\treturn 0;\n}\n\n\nstatic int macvlan_broadcast_one(struct sk_buff *skb,\n\t\t\t\t const struct macvlan_dev *vlan,\n\t\t\t\t const struct ethhdr *eth, bool local)\n{\n\tstruct net_device *dev = vlan->dev;\n\tif (!skb)\n\t\treturn NET_RX_DROP;\n\n\tif (local)\n\t\treturn vlan->forward(dev, skb);\n\n\tskb->dev = dev;\n\tif (!compare_ether_addr_64bits(eth->h_dest,\n\t\t\t\t       dev->broadcast))\n\t\tskb->pkt_type = PACKET_BROADCAST;\n\telse\n\t\tskb->pkt_type = PACKET_MULTICAST;\n\n\treturn vlan->receive(skb);\n}\n\nstatic void macvlan_broadcast(struct sk_buff *skb,\n\t\t\t      const struct macvlan_port *port,\n\t\t\t      struct net_device *src,\n\t\t\t      enum macvlan_mode mode)\n{\n\tconst struct ethhdr *eth = eth_hdr(skb);\n\tconst struct macvlan_dev *vlan;\n\tstruct hlist_node *n;\n\tstruct sk_buff *nskb;\n\tunsigned int i;\n\tint err;\n\n\tif (skb->protocol == htons(ETH_P_PAUSE))\n\t\treturn;\n\n\tfor (i = 0; i < MACVLAN_HASH_SIZE; i++) {\n\t\thlist_for_each_entry_rcu(vlan, n, &port->vlan_hash[i], hlist) {\n\t\t\tif (vlan->dev == src || !(vlan->mode & mode))\n\t\t\t\tcontinue;\n\n\t\t\tnskb = skb_clone(skb, GFP_ATOMIC);\n\t\t\terr = macvlan_broadcast_one(nskb, vlan, eth,\n\t\t\t\t\t mode == MACVLAN_MODE_BRIDGE);\n\t\t\tmacvlan_count_rx(vlan, skb->len + ETH_HLEN,\n\t\t\t\t\t err == NET_RX_SUCCESS, 1);\n\t\t}\n\t}\n}\n\n/* called under rcu_read_lock() from netif_receive_skb */\nstatic rx_handler_result_t macvlan_handle_frame(struct sk_buff **pskb)\n{\n\tstruct macvlan_port *port;\n\tstruct sk_buff *skb = *pskb;\n\tconst struct ethhdr *eth = eth_hdr(skb);\n\tconst struct macvlan_dev *vlan;\n\tconst struct macvlan_dev *src;\n\tstruct net_device *dev;\n\tunsigned int len = 0;\n\tint ret = NET_RX_DROP;\n\n\tport = macvlan_port_get_rcu(skb->dev);\n\tif (is_multicast_ether_addr(eth->h_dest)) {\n\t\tsrc = macvlan_hash_lookup(port, eth->h_source);\n\t\tif (!src)\n\t\t\t/* frame comes from an external address */\n\t\t\tmacvlan_broadcast(skb, port, NULL,\n\t\t\t\t\t  MACVLAN_MODE_PRIVATE |\n\t\t\t\t\t  MACVLAN_MODE_VEPA    |\n\t\t\t\t\t  MACVLAN_MODE_PASSTHRU|\n\t\t\t\t\t  MACVLAN_MODE_BRIDGE);\n\t\telse if (src->mode == MACVLAN_MODE_VEPA)\n\t\t\t/* flood to everyone except source */\n\t\t\tmacvlan_broadcast(skb, port, src->dev,\n\t\t\t\t\t  MACVLAN_MODE_VEPA |\n\t\t\t\t\t  MACVLAN_MODE_BRIDGE);\n\t\telse if (src->mode == MACVLAN_MODE_BRIDGE)\n\t\t\t/*\n\t\t\t * flood only to VEPA ports, bridge ports\n\t\t\t * already saw the frame on the way out.\n\t\t\t */\n\t\t\tmacvlan_broadcast(skb, port, src->dev,\n\t\t\t\t\t  MACVLAN_MODE_VEPA);\n\t\treturn RX_HANDLER_PASS;\n\t}\n\n\tif (port->passthru)\n\t\tvlan = list_first_entry(&port->vlans, struct macvlan_dev, list);\n\telse\n\t\tvlan = macvlan_hash_lookup(port, eth->h_dest);\n\tif (vlan == NULL)\n\t\treturn RX_HANDLER_PASS;\n\n\tdev = vlan->dev;\n\tif (unlikely(!(dev->flags & IFF_UP))) {\n\t\tkfree_skb(skb);\n\t\treturn RX_HANDLER_CONSUMED;\n\t}\n\tlen = skb->len + ETH_HLEN;\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto out;\n\n\tskb->dev = dev;\n\tskb->pkt_type = PACKET_HOST;\n\n\tret = vlan->receive(skb);\n\nout:\n\tmacvlan_count_rx(vlan, len, ret == NET_RX_SUCCESS, 0);\n\treturn RX_HANDLER_CONSUMED;\n}\n\nstatic int macvlan_queue_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tconst struct macvlan_dev *vlan = netdev_priv(dev);\n\tconst struct macvlan_port *port = vlan->port;\n\tconst struct macvlan_dev *dest;\n\t__u8 ip_summed = skb->ip_summed;\n\n\tif (vlan->mode == MACVLAN_MODE_BRIDGE) {\n\t\tconst struct ethhdr *eth = (void *)skb->data;\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\t\t/* send to other bridge ports directly */\n\t\tif (is_multicast_ether_addr(eth->h_dest)) {\n\t\t\tmacvlan_broadcast(skb, port, dev, MACVLAN_MODE_BRIDGE);\n\t\t\tgoto xmit_world;\n\t\t}\n\n\t\tdest = macvlan_hash_lookup(port, eth->h_dest);\n\t\tif (dest && dest->mode == MACVLAN_MODE_BRIDGE) {\n\t\t\t/* send to lowerdev first for its network taps */\n\t\t\tvlan->forward(vlan->lowerdev, skb);\n\n\t\t\treturn NET_XMIT_SUCCESS;\n\t\t}\n\t}\n\nxmit_world:\n\tskb->ip_summed = ip_summed;\n\tskb_set_dev(skb, vlan->lowerdev);\n\treturn dev_queue_xmit(skb);\n}\n\nnetdev_tx_t macvlan_start_xmit(struct sk_buff *skb,\n\t\t\t       struct net_device *dev)\n{\n\tunsigned int len = skb->len;\n\tint ret;\n\tconst struct macvlan_dev *vlan = netdev_priv(dev);\n\n\tret = macvlan_queue_xmit(skb, dev);\n\tif (likely(ret == NET_XMIT_SUCCESS || ret == NET_XMIT_CN)) {\n\t\tstruct macvlan_pcpu_stats *pcpu_stats;\n\n\t\tpcpu_stats = this_cpu_ptr(vlan->pcpu_stats);\n\t\tu64_stats_update_begin(&pcpu_stats->syncp);\n\t\tpcpu_stats->tx_packets++;\n\t\tpcpu_stats->tx_bytes += len;\n\t\tu64_stats_update_end(&pcpu_stats->syncp);\n\t} else {\n\t\tthis_cpu_inc(vlan->pcpu_stats->tx_dropped);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(macvlan_start_xmit);\n\nstatic int macvlan_hard_header(struct sk_buff *skb, struct net_device *dev,\n\t\t\t       unsigned short type, const void *daddr,\n\t\t\t       const void *saddr, unsigned len)\n{\n\tconst struct macvlan_dev *vlan = netdev_priv(dev);\n\tstruct net_device *lowerdev = vlan->lowerdev;\n\n\treturn dev_hard_header(skb, lowerdev, type, daddr,\n\t\t\t       saddr ? : dev->dev_addr, len);\n}\n\nstatic const struct header_ops macvlan_hard_header_ops = {\n\t.create  \t= macvlan_hard_header,\n\t.rebuild\t= eth_rebuild_header,\n\t.parse\t\t= eth_header_parse,\n\t.cache\t\t= eth_header_cache,\n\t.cache_update\t= eth_header_cache_update,\n};\n\nstatic int macvlan_open(struct net_device *dev)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tstruct net_device *lowerdev = vlan->lowerdev;\n\tint err;\n\n\tif (vlan->port->passthru) {\n\t\tdev_set_promiscuity(lowerdev, 1);\n\t\tgoto hash_add;\n\t}\n\n\terr = -EBUSY;\n\tif (macvlan_addr_busy(vlan->port, dev->dev_addr))\n\t\tgoto out;\n\n\terr = dev_uc_add(lowerdev, dev->dev_addr);\n\tif (err < 0)\n\t\tgoto out;\n\tif (dev->flags & IFF_ALLMULTI) {\n\t\terr = dev_set_allmulti(lowerdev, 1);\n\t\tif (err < 0)\n\t\t\tgoto del_unicast;\n\t}\n\nhash_add:\n\tmacvlan_hash_add(vlan);\n\treturn 0;\n\ndel_unicast:\n\tdev_uc_del(lowerdev, dev->dev_addr);\nout:\n\treturn err;\n}\n\nstatic int macvlan_stop(struct net_device *dev)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tstruct net_device *lowerdev = vlan->lowerdev;\n\n\tif (vlan->port->passthru) {\n\t\tdev_set_promiscuity(lowerdev, -1);\n\t\tgoto hash_del;\n\t}\n\n\tdev_mc_unsync(lowerdev, dev);\n\tif (dev->flags & IFF_ALLMULTI)\n\t\tdev_set_allmulti(lowerdev, -1);\n\n\tdev_uc_del(lowerdev, dev->dev_addr);\n\nhash_del:\n\tmacvlan_hash_del(vlan, !dev->dismantle);\n\treturn 0;\n}\n\nstatic int macvlan_set_mac_address(struct net_device *dev, void *p)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tstruct net_device *lowerdev = vlan->lowerdev;\n\tstruct sockaddr *addr = p;\n\tint err;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\tif (!(dev->flags & IFF_UP)) {\n\t\t/* Just copy in the new address */\n\t\tmemcpy(dev->dev_addr, addr->sa_data, ETH_ALEN);\n\t} else {\n\t\t/* Rehash and update the device filters */\n\t\tif (macvlan_addr_busy(vlan->port, addr->sa_data))\n\t\t\treturn -EBUSY;\n\n\t\terr = dev_uc_add(lowerdev, addr->sa_data);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tdev_uc_del(lowerdev, dev->dev_addr);\n\n\t\tmacvlan_hash_change_addr(vlan, addr->sa_data);\n\t}\n\treturn 0;\n}\n\nstatic void macvlan_change_rx_flags(struct net_device *dev, int change)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tstruct net_device *lowerdev = vlan->lowerdev;\n\n\tif (change & IFF_ALLMULTI)\n\t\tdev_set_allmulti(lowerdev, dev->flags & IFF_ALLMULTI ? 1 : -1);\n}\n\nstatic void macvlan_set_multicast_list(struct net_device *dev)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\n\tdev_mc_sync(vlan->lowerdev, dev);\n}\n\nstatic int macvlan_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\n\tif (new_mtu < 68 || vlan->lowerdev->mtu < new_mtu)\n\t\treturn -EINVAL;\n\tdev->mtu = new_mtu;\n\treturn 0;\n}\n\n/*\n * macvlan network devices have devices nesting below it and are a special\n * \"super class\" of normal network devices; split their locks off into a\n * separate class since they always nest.\n */\nstatic struct lock_class_key macvlan_netdev_xmit_lock_key;\nstatic struct lock_class_key macvlan_netdev_addr_lock_key;\n\n#define MACVLAN_FEATURES \\\n\t(NETIF_F_SG | NETIF_F_ALL_CSUM | NETIF_F_HIGHDMA | NETIF_F_FRAGLIST | \\\n\t NETIF_F_GSO | NETIF_F_TSO | NETIF_F_UFO | NETIF_F_GSO_ROBUST | \\\n\t NETIF_F_TSO_ECN | NETIF_F_TSO6 | NETIF_F_GRO | NETIF_F_RXCSUM | \\\n\t NETIF_F_HW_VLAN_FILTER)\n\n#define MACVLAN_STATE_MASK \\\n\t((1<<__LINK_STATE_NOCARRIER) | (1<<__LINK_STATE_DORMANT))\n\nstatic void macvlan_set_lockdep_class_one(struct net_device *dev,\n\t\t\t\t\t  struct netdev_queue *txq,\n\t\t\t\t\t  void *_unused)\n{\n\tlockdep_set_class(&txq->_xmit_lock,\n\t\t\t  &macvlan_netdev_xmit_lock_key);\n}\n\nstatic void macvlan_set_lockdep_class(struct net_device *dev)\n{\n\tlockdep_set_class(&dev->addr_list_lock,\n\t\t\t  &macvlan_netdev_addr_lock_key);\n\tnetdev_for_each_tx_queue(dev, macvlan_set_lockdep_class_one, NULL);\n}\n\nstatic int macvlan_init(struct net_device *dev)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tconst struct net_device *lowerdev = vlan->lowerdev;\n\n\tdev->state\t\t= (dev->state & ~MACVLAN_STATE_MASK) |\n\t\t\t\t  (lowerdev->state & MACVLAN_STATE_MASK);\n\tdev->features \t\t= lowerdev->features & MACVLAN_FEATURES;\n\tdev->features\t\t|= NETIF_F_LLTX;\n\tdev->gso_max_size\t= lowerdev->gso_max_size;\n\tdev->iflink\t\t= lowerdev->ifindex;\n\tdev->hard_header_len\t= lowerdev->hard_header_len;\n\n\tmacvlan_set_lockdep_class(dev);\n\n\tvlan->pcpu_stats = alloc_percpu(struct macvlan_pcpu_stats);\n\tif (!vlan->pcpu_stats)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void macvlan_uninit(struct net_device *dev)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tstruct macvlan_port *port = vlan->port;\n\n\tfree_percpu(vlan->pcpu_stats);\n\n\tport->count -= 1;\n\tif (!port->count)\n\t\tmacvlan_port_destroy(port->dev);\n}\n\nstatic struct rtnl_link_stats64 *macvlan_dev_get_stats64(struct net_device *dev,\n\t\t\t\t\t\t\t struct rtnl_link_stats64 *stats)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\n\tif (vlan->pcpu_stats) {\n\t\tstruct macvlan_pcpu_stats *p;\n\t\tu64 rx_packets, rx_bytes, rx_multicast, tx_packets, tx_bytes;\n\t\tu32 rx_errors = 0, tx_dropped = 0;\n\t\tunsigned int start;\n\t\tint i;\n\n\t\tfor_each_possible_cpu(i) {\n\t\t\tp = per_cpu_ptr(vlan->pcpu_stats, i);\n\t\t\tdo {\n\t\t\t\tstart = u64_stats_fetch_begin_bh(&p->syncp);\n\t\t\t\trx_packets\t= p->rx_packets;\n\t\t\t\trx_bytes\t= p->rx_bytes;\n\t\t\t\trx_multicast\t= p->rx_multicast;\n\t\t\t\ttx_packets\t= p->tx_packets;\n\t\t\t\ttx_bytes\t= p->tx_bytes;\n\t\t\t} while (u64_stats_fetch_retry_bh(&p->syncp, start));\n\n\t\t\tstats->rx_packets\t+= rx_packets;\n\t\t\tstats->rx_bytes\t\t+= rx_bytes;\n\t\t\tstats->multicast\t+= rx_multicast;\n\t\t\tstats->tx_packets\t+= tx_packets;\n\t\t\tstats->tx_bytes\t\t+= tx_bytes;\n\t\t\t/* rx_errors & tx_dropped are u32, updated\n\t\t\t * without syncp protection.\n\t\t\t */\n\t\t\trx_errors\t+= p->rx_errors;\n\t\t\ttx_dropped\t+= p->tx_dropped;\n\t\t}\n\t\tstats->rx_errors\t= rx_errors;\n\t\tstats->rx_dropped\t= rx_errors;\n\t\tstats->tx_dropped\t= tx_dropped;\n\t}\n\treturn stats;\n}\n\nstatic void macvlan_vlan_rx_add_vid(struct net_device *dev,\n\t\t\t\t    unsigned short vid)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tstruct net_device *lowerdev = vlan->lowerdev;\n\tconst struct net_device_ops *ops = lowerdev->netdev_ops;\n\n\tif (ops->ndo_vlan_rx_add_vid)\n\t\tops->ndo_vlan_rx_add_vid(lowerdev, vid);\n}\n\nstatic void macvlan_vlan_rx_kill_vid(struct net_device *dev,\n\t\t\t\t     unsigned short vid)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tstruct net_device *lowerdev = vlan->lowerdev;\n\tconst struct net_device_ops *ops = lowerdev->netdev_ops;\n\n\tif (ops->ndo_vlan_rx_kill_vid)\n\t\tops->ndo_vlan_rx_kill_vid(lowerdev, vid);\n}\n\nstatic void macvlan_ethtool_get_drvinfo(struct net_device *dev,\n\t\t\t\t\tstruct ethtool_drvinfo *drvinfo)\n{\n\tsnprintf(drvinfo->driver, 32, \"macvlan\");\n\tsnprintf(drvinfo->version, 32, \"0.1\");\n}\n\nstatic int macvlan_ethtool_get_settings(struct net_device *dev,\n\t\t\t\t\tstruct ethtool_cmd *cmd)\n{\n\tconst struct macvlan_dev *vlan = netdev_priv(dev);\n\treturn dev_ethtool_get_settings(vlan->lowerdev, cmd);\n}\n\nstatic const struct ethtool_ops macvlan_ethtool_ops = {\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_settings\t\t= macvlan_ethtool_get_settings,\n\t.get_drvinfo\t\t= macvlan_ethtool_get_drvinfo,\n};\n\nstatic const struct net_device_ops macvlan_netdev_ops = {\n\t.ndo_init\t\t= macvlan_init,\n\t.ndo_uninit\t\t= macvlan_uninit,\n\t.ndo_open\t\t= macvlan_open,\n\t.ndo_stop\t\t= macvlan_stop,\n\t.ndo_start_xmit\t\t= macvlan_start_xmit,\n\t.ndo_change_mtu\t\t= macvlan_change_mtu,\n\t.ndo_change_rx_flags\t= macvlan_change_rx_flags,\n\t.ndo_set_mac_address\t= macvlan_set_mac_address,\n\t.ndo_set_multicast_list\t= macvlan_set_multicast_list,\n\t.ndo_get_stats64\t= macvlan_dev_get_stats64,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_vlan_rx_add_vid\t= macvlan_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid\t= macvlan_vlan_rx_kill_vid,\n};\n\nvoid macvlan_common_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\n\tdev->priv_flags\t       &= ~IFF_XMIT_DST_RELEASE;\n\tdev->netdev_ops\t\t= &macvlan_netdev_ops;\n\tdev->destructor\t\t= free_netdev;\n\tdev->header_ops\t\t= &macvlan_hard_header_ops,\n\tdev->ethtool_ops\t= &macvlan_ethtool_ops;\n}\nEXPORT_SYMBOL_GPL(macvlan_common_setup);\n\nstatic void macvlan_setup(struct net_device *dev)\n{\n\tmacvlan_common_setup(dev);\n\tdev->tx_queue_len\t= 0;\n}\n\nstatic int macvlan_port_create(struct net_device *dev)\n{\n\tstruct macvlan_port *port;\n\tunsigned int i;\n\tint err;\n\n\tif (dev->type != ARPHRD_ETHER || dev->flags & IFF_LOOPBACK)\n\t\treturn -EINVAL;\n\n\tport = kzalloc(sizeof(*port), GFP_KERNEL);\n\tif (port == NULL)\n\t\treturn -ENOMEM;\n\n\tport->passthru = false;\n\tport->dev = dev;\n\tINIT_LIST_HEAD(&port->vlans);\n\tfor (i = 0; i < MACVLAN_HASH_SIZE; i++)\n\t\tINIT_HLIST_HEAD(&port->vlan_hash[i]);\n\n\terr = netdev_rx_handler_register(dev, macvlan_handle_frame, port);\n\tif (err)\n\t\tkfree(port);\n\telse\n\t\tdev->priv_flags |= IFF_MACVLAN_PORT;\n\treturn err;\n}\n\nstatic void macvlan_port_destroy(struct net_device *dev)\n{\n\tstruct macvlan_port *port = macvlan_port_get(dev);\n\n\tdev->priv_flags &= ~IFF_MACVLAN_PORT;\n\tnetdev_rx_handler_unregister(dev);\n\tkfree_rcu(port, rcu);\n}\n\nstatic int macvlan_validate(struct nlattr *tb[], struct nlattr *data[])\n{\n\tif (tb[IFLA_ADDRESS]) {\n\t\tif (nla_len(tb[IFLA_ADDRESS]) != ETH_ALEN)\n\t\t\treturn -EINVAL;\n\t\tif (!is_valid_ether_addr(nla_data(tb[IFLA_ADDRESS])))\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\tif (data && data[IFLA_MACVLAN_MODE]) {\n\t\tswitch (nla_get_u32(data[IFLA_MACVLAN_MODE])) {\n\t\tcase MACVLAN_MODE_PRIVATE:\n\t\tcase MACVLAN_MODE_VEPA:\n\t\tcase MACVLAN_MODE_BRIDGE:\n\t\tcase MACVLAN_MODE_PASSTHRU:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint macvlan_common_newlink(struct net *src_net, struct net_device *dev,\n\t\t\t   struct nlattr *tb[], struct nlattr *data[],\n\t\t\t   int (*receive)(struct sk_buff *skb),\n\t\t\t   int (*forward)(struct net_device *dev,\n\t\t\t\t\t  struct sk_buff *skb))\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tstruct macvlan_port *port;\n\tstruct net_device *lowerdev;\n\tint err;\n\n\tif (!tb[IFLA_LINK])\n\t\treturn -EINVAL;\n\n\tlowerdev = __dev_get_by_index(src_net, nla_get_u32(tb[IFLA_LINK]));\n\tif (lowerdev == NULL)\n\t\treturn -ENODEV;\n\n\t/* When creating macvlans on top of other macvlans - use\n\t * the real device as the lowerdev.\n\t */\n\tif (lowerdev->rtnl_link_ops == dev->rtnl_link_ops) {\n\t\tstruct macvlan_dev *lowervlan = netdev_priv(lowerdev);\n\t\tlowerdev = lowervlan->lowerdev;\n\t}\n\n\tif (!tb[IFLA_MTU])\n\t\tdev->mtu = lowerdev->mtu;\n\telse if (dev->mtu > lowerdev->mtu)\n\t\treturn -EINVAL;\n\n\tif (!tb[IFLA_ADDRESS])\n\t\trandom_ether_addr(dev->dev_addr);\n\n\tif (!macvlan_port_exists(lowerdev)) {\n\t\terr = macvlan_port_create(lowerdev);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tport = macvlan_port_get(lowerdev);\n\n\t/* Only 1 macvlan device can be created in passthru mode */\n\tif (port->passthru)\n\t\treturn -EINVAL;\n\n\tvlan->lowerdev = lowerdev;\n\tvlan->dev      = dev;\n\tvlan->port     = port;\n\tvlan->receive  = receive;\n\tvlan->forward  = forward;\n\n\tvlan->mode     = MACVLAN_MODE_VEPA;\n\tif (data && data[IFLA_MACVLAN_MODE])\n\t\tvlan->mode = nla_get_u32(data[IFLA_MACVLAN_MODE]);\n\n\tif (vlan->mode == MACVLAN_MODE_PASSTHRU) {\n\t\tif (port->count)\n\t\t\treturn -EINVAL;\n\t\tport->passthru = true;\n\t\tmemcpy(dev->dev_addr, lowerdev->dev_addr, ETH_ALEN);\n\t}\n\n\tport->count += 1;\n\terr = register_netdevice(dev);\n\tif (err < 0)\n\t\tgoto destroy_port;\n\n\tlist_add_tail(&vlan->list, &port->vlans);\n\tnetif_stacked_transfer_operstate(lowerdev, dev);\n\n\treturn 0;\n\ndestroy_port:\n\tport->count -= 1;\n\tif (!port->count)\n\t\tmacvlan_port_destroy(lowerdev);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(macvlan_common_newlink);\n\nstatic int macvlan_newlink(struct net *src_net, struct net_device *dev,\n\t\t\t   struct nlattr *tb[], struct nlattr *data[])\n{\n\treturn macvlan_common_newlink(src_net, dev, tb, data,\n\t\t\t\t      netif_rx,\n\t\t\t\t      dev_forward_skb);\n}\n\nvoid macvlan_dellink(struct net_device *dev, struct list_head *head)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\n\tlist_del(&vlan->list);\n\tunregister_netdevice_queue(dev, head);\n}\nEXPORT_SYMBOL_GPL(macvlan_dellink);\n\nstatic int macvlan_changelink(struct net_device *dev,\n\t\tstruct nlattr *tb[], struct nlattr *data[])\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tif (data && data[IFLA_MACVLAN_MODE])\n\t\tvlan->mode = nla_get_u32(data[IFLA_MACVLAN_MODE]);\n\treturn 0;\n}\n\nstatic size_t macvlan_get_size(const struct net_device *dev)\n{\n\treturn nla_total_size(4);\n}\n\nstatic int macvlan_fill_info(struct sk_buff *skb,\n\t\t\t\tconst struct net_device *dev)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\n\tNLA_PUT_U32(skb, IFLA_MACVLAN_MODE, vlan->mode);\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic const struct nla_policy macvlan_policy[IFLA_MACVLAN_MAX + 1] = {\n\t[IFLA_MACVLAN_MODE] = { .type = NLA_U32 },\n};\n\nint macvlan_link_register(struct rtnl_link_ops *ops)\n{\n\t/* common fields */\n\tops->priv_size\t\t= sizeof(struct macvlan_dev);\n\tops->validate\t\t= macvlan_validate;\n\tops->maxtype\t\t= IFLA_MACVLAN_MAX;\n\tops->policy\t\t= macvlan_policy;\n\tops->changelink\t\t= macvlan_changelink;\n\tops->get_size\t\t= macvlan_get_size;\n\tops->fill_info\t\t= macvlan_fill_info;\n\n\treturn rtnl_link_register(ops);\n};\nEXPORT_SYMBOL_GPL(macvlan_link_register);\n\nstatic struct rtnl_link_ops macvlan_link_ops = {\n\t.kind\t\t= \"macvlan\",\n\t.setup\t\t= macvlan_setup,\n\t.newlink\t= macvlan_newlink,\n\t.dellink\t= macvlan_dellink,\n};\n\nstatic int macvlan_device_event(struct notifier_block *unused,\n\t\t\t\tunsigned long event, void *ptr)\n{\n\tstruct net_device *dev = ptr;\n\tstruct macvlan_dev *vlan, *next;\n\tstruct macvlan_port *port;\n\tLIST_HEAD(list_kill);\n\n\tif (!macvlan_port_exists(dev))\n\t\treturn NOTIFY_DONE;\n\n\tport = macvlan_port_get(dev);\n\n\tswitch (event) {\n\tcase NETDEV_CHANGE:\n\t\tlist_for_each_entry(vlan, &port->vlans, list)\n\t\t\tnetif_stacked_transfer_operstate(vlan->lowerdev,\n\t\t\t\t\t\t\t vlan->dev);\n\t\tbreak;\n\tcase NETDEV_FEAT_CHANGE:\n\t\tlist_for_each_entry(vlan, &port->vlans, list) {\n\t\t\tvlan->dev->features = dev->features & MACVLAN_FEATURES;\n\t\t\tvlan->dev->gso_max_size = dev->gso_max_size;\n\t\t\tnetdev_features_change(vlan->dev);\n\t\t}\n\t\tbreak;\n\tcase NETDEV_UNREGISTER:\n\t\t/* twiddle thumbs on netns device moves */\n\t\tif (dev->reg_state != NETREG_UNREGISTERING)\n\t\t\tbreak;\n\n\t\tlist_for_each_entry_safe(vlan, next, &port->vlans, list)\n\t\t\tvlan->dev->rtnl_link_ops->dellink(vlan->dev, &list_kill);\n\t\tunregister_netdevice_many(&list_kill);\n\t\tlist_del(&list_kill);\n\t\tbreak;\n\tcase NETDEV_PRE_TYPE_CHANGE:\n\t\t/* Forbid underlaying device to change its type. */\n\t\treturn NOTIFY_BAD;\n\t}\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block macvlan_notifier_block __read_mostly = {\n\t.notifier_call\t= macvlan_device_event,\n};\n\nstatic int __init macvlan_init_module(void)\n{\n\tint err;\n\n\tregister_netdevice_notifier(&macvlan_notifier_block);\n\n\terr = macvlan_link_register(&macvlan_link_ops);\n\tif (err < 0)\n\t\tgoto err1;\n\treturn 0;\nerr1:\n\tunregister_netdevice_notifier(&macvlan_notifier_block);\n\treturn err;\n}\n\nstatic void __exit macvlan_cleanup_module(void)\n{\n\trtnl_link_unregister(&macvlan_link_ops);\n\tunregister_netdevice_notifier(&macvlan_notifier_block);\n}\n\nmodule_init(macvlan_init_module);\nmodule_exit(macvlan_cleanup_module);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Patrick McHardy <kaber@trash.net>\");\nMODULE_DESCRIPTION(\"Driver for MAC address based VLANs\");\nMODULE_ALIAS_RTNL_LINK(\"macvlan\");\n", "/*\n *  TUN - Universal TUN/TAP device driver.\n *  Copyright (C) 1999-2002 Maxim Krasnyansky <maxk@qualcomm.com>\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n *  GNU General Public License for more details.\n *\n *  $Id: tun.c,v 1.15 2002/03/01 02:44:24 maxk Exp $\n */\n\n/*\n *  Changes:\n *\n *  Mike Kershaw <dragorn@kismetwireless.net> 2005/08/14\n *    Add TUNSETLINK ioctl to set the link encapsulation\n *\n *  Mark Smith <markzzzsmith@yahoo.com.au>\n *    Use random_ether_addr() for tap MAC address.\n *\n *  Harald Roelle <harald.roelle@ifi.lmu.de>  2004/04/20\n *    Fixes in packet dropping, queue length setting and queue wakeup.\n *    Increased default tx queue length.\n *    Added ethtool API.\n *    Minor cleanups\n *\n *  Daniel Podlejski <underley@underley.eu.org>\n *    Modifications for 2.3.99-pre5 kernel.\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define DRV_NAME\t\"tun\"\n#define DRV_VERSION\t\"1.6\"\n#define DRV_DESCRIPTION\t\"Universal TUN/TAP device driver\"\n#define DRV_COPYRIGHT\t\"(C) 1999-2004 Max Krasnyansky <maxk@qualcomm.com>\"\n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/major.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/fcntl.h>\n#include <linux/init.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/miscdevice.h>\n#include <linux/ethtool.h>\n#include <linux/rtnetlink.h>\n#include <linux/compat.h>\n#include <linux/if.h>\n#include <linux/if_arp.h>\n#include <linux/if_ether.h>\n#include <linux/if_tun.h>\n#include <linux/crc32.h>\n#include <linux/nsproxy.h>\n#include <linux/virtio_net.h>\n#include <linux/rcupdate.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <net/rtnetlink.h>\n#include <net/sock.h>\n\n#include <asm/system.h>\n#include <asm/uaccess.h>\n\n/* Uncomment to enable debugging */\n/* #define TUN_DEBUG 1 */\n\n#ifdef TUN_DEBUG\nstatic int debug;\n\n#define tun_debug(level, tun, fmt, args...)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (tun->debug)\t\t\t\t\t\t\\\n\t\tnetdev_printk(level, tun->dev, fmt, ##args);\t\\\n} while (0)\n#define DBG1(level, fmt, args...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (debug == 2)\t\t\t\t\t\t\\\n\t\tprintk(level fmt, ##args);\t\t\t\\\n} while (0)\n#else\n#define tun_debug(level, tun, fmt, args...)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (0)\t\t\t\t\t\t\t\\\n\t\tnetdev_printk(level, tun->dev, fmt, ##args);\t\\\n} while (0)\n#define DBG1(level, fmt, args...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (0)\t\t\t\t\t\t\t\\\n\t\tprintk(level fmt, ##args);\t\t\t\\\n} while (0)\n#endif\n\n#define FLT_EXACT_COUNT 8\nstruct tap_filter {\n\tunsigned int    count;    /* Number of addrs. Zero means disabled */\n\tu32             mask[2];  /* Mask of the hashed addrs */\n\tunsigned char\taddr[FLT_EXACT_COUNT][ETH_ALEN];\n};\n\nstruct tun_file {\n\tatomic_t count;\n\tstruct tun_struct *tun;\n\tstruct net *net;\n};\n\nstruct tun_sock;\n\nstruct tun_struct {\n\tstruct tun_file\t\t*tfile;\n\tunsigned int \t\tflags;\n\tuid_t\t\t\towner;\n\tgid_t\t\t\tgroup;\n\n\tstruct net_device\t*dev;\n\tu32\t\t\tset_features;\n#define TUN_USER_FEATURES (NETIF_F_HW_CSUM|NETIF_F_TSO_ECN|NETIF_F_TSO| \\\n\t\t\t  NETIF_F_TSO6|NETIF_F_UFO)\n\tstruct fasync_struct\t*fasync;\n\n\tstruct tap_filter       txflt;\n\tstruct socket\t\tsocket;\n\tstruct socket_wq\twq;\n\n\tint\t\t\tvnet_hdr_sz;\n\n#ifdef TUN_DEBUG\n\tint debug;\n#endif\n};\n\nstruct tun_sock {\n\tstruct sock\t\tsk;\n\tstruct tun_struct\t*tun;\n};\n\nstatic inline struct tun_sock *tun_sk(struct sock *sk)\n{\n\treturn container_of(sk, struct tun_sock, sk);\n}\n\nstatic int tun_attach(struct tun_struct *tun, struct file *file)\n{\n\tstruct tun_file *tfile = file->private_data;\n\tint err;\n\n\tASSERT_RTNL();\n\n\tnetif_tx_lock_bh(tun->dev);\n\n\terr = -EINVAL;\n\tif (tfile->tun)\n\t\tgoto out;\n\n\terr = -EBUSY;\n\tif (tun->tfile)\n\t\tgoto out;\n\n\terr = 0;\n\ttfile->tun = tun;\n\ttun->tfile = tfile;\n\ttun->socket.file = file;\n\tnetif_carrier_on(tun->dev);\n\tdev_hold(tun->dev);\n\tsock_hold(tun->socket.sk);\n\tatomic_inc(&tfile->count);\n\nout:\n\tnetif_tx_unlock_bh(tun->dev);\n\treturn err;\n}\n\nstatic void __tun_detach(struct tun_struct *tun)\n{\n\t/* Detach from net device */\n\tnetif_tx_lock_bh(tun->dev);\n\tnetif_carrier_off(tun->dev);\n\ttun->tfile = NULL;\n\ttun->socket.file = NULL;\n\tnetif_tx_unlock_bh(tun->dev);\n\n\t/* Drop read queue */\n\tskb_queue_purge(&tun->socket.sk->sk_receive_queue);\n\n\t/* Drop the extra count on the net device */\n\tdev_put(tun->dev);\n}\n\nstatic void tun_detach(struct tun_struct *tun)\n{\n\trtnl_lock();\n\t__tun_detach(tun);\n\trtnl_unlock();\n}\n\nstatic struct tun_struct *__tun_get(struct tun_file *tfile)\n{\n\tstruct tun_struct *tun = NULL;\n\n\tif (atomic_inc_not_zero(&tfile->count))\n\t\ttun = tfile->tun;\n\n\treturn tun;\n}\n\nstatic struct tun_struct *tun_get(struct file *file)\n{\n\treturn __tun_get(file->private_data);\n}\n\nstatic void tun_put(struct tun_struct *tun)\n{\n\tstruct tun_file *tfile = tun->tfile;\n\n\tif (atomic_dec_and_test(&tfile->count))\n\t\ttun_detach(tfile->tun);\n}\n\n/* TAP filtering */\nstatic void addr_hash_set(u32 *mask, const u8 *addr)\n{\n\tint n = ether_crc(ETH_ALEN, addr) >> 26;\n\tmask[n >> 5] |= (1 << (n & 31));\n}\n\nstatic unsigned int addr_hash_test(const u32 *mask, const u8 *addr)\n{\n\tint n = ether_crc(ETH_ALEN, addr) >> 26;\n\treturn mask[n >> 5] & (1 << (n & 31));\n}\n\nstatic int update_filter(struct tap_filter *filter, void __user *arg)\n{\n\tstruct { u8 u[ETH_ALEN]; } *addr;\n\tstruct tun_filter uf;\n\tint err, alen, n, nexact;\n\n\tif (copy_from_user(&uf, arg, sizeof(uf)))\n\t\treturn -EFAULT;\n\n\tif (!uf.count) {\n\t\t/* Disabled */\n\t\tfilter->count = 0;\n\t\treturn 0;\n\t}\n\n\talen = ETH_ALEN * uf.count;\n\taddr = kmalloc(alen, GFP_KERNEL);\n\tif (!addr)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(addr, arg + sizeof(uf), alen)) {\n\t\terr = -EFAULT;\n\t\tgoto done;\n\t}\n\n\t/* The filter is updated without holding any locks. Which is\n\t * perfectly safe. We disable it first and in the worst\n\t * case we'll accept a few undesired packets. */\n\tfilter->count = 0;\n\twmb();\n\n\t/* Use first set of addresses as an exact filter */\n\tfor (n = 0; n < uf.count && n < FLT_EXACT_COUNT; n++)\n\t\tmemcpy(filter->addr[n], addr[n].u, ETH_ALEN);\n\n\tnexact = n;\n\n\t/* Remaining multicast addresses are hashed,\n\t * unicast will leave the filter disabled. */\n\tmemset(filter->mask, 0, sizeof(filter->mask));\n\tfor (; n < uf.count; n++) {\n\t\tif (!is_multicast_ether_addr(addr[n].u)) {\n\t\t\terr = 0; /* no filter */\n\t\t\tgoto done;\n\t\t}\n\t\taddr_hash_set(filter->mask, addr[n].u);\n\t}\n\n\t/* For ALLMULTI just set the mask to all ones.\n\t * This overrides the mask populated above. */\n\tif ((uf.flags & TUN_FLT_ALLMULTI))\n\t\tmemset(filter->mask, ~0, sizeof(filter->mask));\n\n\t/* Now enable the filter */\n\twmb();\n\tfilter->count = nexact;\n\n\t/* Return the number of exact filters */\n\terr = nexact;\n\ndone:\n\tkfree(addr);\n\treturn err;\n}\n\n/* Returns: 0 - drop, !=0 - accept */\nstatic int run_filter(struct tap_filter *filter, const struct sk_buff *skb)\n{\n\t/* Cannot use eth_hdr(skb) here because skb_mac_hdr() is incorrect\n\t * at this point. */\n\tstruct ethhdr *eh = (struct ethhdr *) skb->data;\n\tint i;\n\n\t/* Exact match */\n\tfor (i = 0; i < filter->count; i++)\n\t\tif (!compare_ether_addr(eh->h_dest, filter->addr[i]))\n\t\t\treturn 1;\n\n\t/* Inexact match (multicast only) */\n\tif (is_multicast_ether_addr(eh->h_dest))\n\t\treturn addr_hash_test(filter->mask, eh->h_dest);\n\n\treturn 0;\n}\n\n/*\n * Checks whether the packet is accepted or not.\n * Returns: 0 - drop, !=0 - accept\n */\nstatic int check_filter(struct tap_filter *filter, const struct sk_buff *skb)\n{\n\tif (!filter->count)\n\t\treturn 1;\n\n\treturn run_filter(filter, skb);\n}\n\n/* Network device part of the driver */\n\nstatic const struct ethtool_ops tun_ethtool_ops;\n\n/* Net device detach from fd. */\nstatic void tun_net_uninit(struct net_device *dev)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\tstruct tun_file *tfile = tun->tfile;\n\n\t/* Inform the methods they need to stop using the dev.\n\t */\n\tif (tfile) {\n\t\twake_up_all(&tun->wq.wait);\n\t\tif (atomic_dec_and_test(&tfile->count))\n\t\t\t__tun_detach(tun);\n\t}\n}\n\nstatic void tun_free_netdev(struct net_device *dev)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\n\tsock_put(tun->socket.sk);\n}\n\n/* Net device open. */\nstatic int tun_net_open(struct net_device *dev)\n{\n\tnetif_start_queue(dev);\n\treturn 0;\n}\n\n/* Net device close. */\nstatic int tun_net_close(struct net_device *dev)\n{\n\tnetif_stop_queue(dev);\n\treturn 0;\n}\n\n/* Net device start xmit */\nstatic netdev_tx_t tun_net_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\n\ttun_debug(KERN_INFO, tun, \"tun_net_xmit %d\\n\", skb->len);\n\n\t/* Drop packet if interface is not attached */\n\tif (!tun->tfile)\n\t\tgoto drop;\n\n\t/* Drop if the filter does not like it.\n\t * This is a noop if the filter is disabled.\n\t * Filter can be enabled only for the TAP devices. */\n\tif (!check_filter(&tun->txflt, skb))\n\t\tgoto drop;\n\n\tif (tun->socket.sk->sk_filter &&\n\t    sk_filter(tun->socket.sk, skb))\n\t\tgoto drop;\n\n\tif (skb_queue_len(&tun->socket.sk->sk_receive_queue) >= dev->tx_queue_len) {\n\t\tif (!(tun->flags & TUN_ONE_QUEUE)) {\n\t\t\t/* Normal queueing mode. */\n\t\t\t/* Packet scheduler handles dropping of further packets. */\n\t\t\tnetif_stop_queue(dev);\n\n\t\t\t/* We won't see all dropped packets individually, so overrun\n\t\t\t * error is more appropriate. */\n\t\t\tdev->stats.tx_fifo_errors++;\n\t\t} else {\n\t\t\t/* Single queue mode.\n\t\t\t * Driver handles dropping of all packets itself. */\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\t/* Orphan the skb - required as we might hang on to it\n\t * for indefinite time. */\n\tskb_orphan(skb);\n\n\t/* Enqueue packet */\n\tskb_queue_tail(&tun->socket.sk->sk_receive_queue, skb);\n\n\t/* Notify and wake up reader process */\n\tif (tun->flags & TUN_FASYNC)\n\t\tkill_fasync(&tun->fasync, SIGIO, POLL_IN);\n\twake_up_interruptible_poll(&tun->wq.wait, POLLIN |\n\t\t\t\t   POLLRDNORM | POLLRDBAND);\n\treturn NETDEV_TX_OK;\n\ndrop:\n\tdev->stats.tx_dropped++;\n\tkfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic void tun_net_mclist(struct net_device *dev)\n{\n\t/*\n\t * This callback is supposed to deal with mc filter in\n\t * _rx_ path and has nothing to do with the _tx_ path.\n\t * In rx path we always accept everything userspace gives us.\n\t */\n}\n\n#define MIN_MTU 68\n#define MAX_MTU 65535\n\nstatic int\ntun_net_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tif (new_mtu < MIN_MTU || new_mtu + dev->hard_header_len > MAX_MTU)\n\t\treturn -EINVAL;\n\tdev->mtu = new_mtu;\n\treturn 0;\n}\n\nstatic u32 tun_net_fix_features(struct net_device *dev, u32 features)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\n\treturn (features & tun->set_features) | (features & ~TUN_USER_FEATURES);\n}\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void tun_poll_controller(struct net_device *dev)\n{\n\t/*\n\t * Tun only receives frames when:\n\t * 1) the char device endpoint gets data from user space\n\t * 2) the tun socket gets a sendmsg call from user space\n\t * Since both of those are syncronous operations, we are guaranteed\n\t * never to have pending data when we poll for it\n\t * so theres nothing to do here but return.\n\t * We need this though so netpoll recognizes us as an interface that\n\t * supports polling, which enables bridge devices in virt setups to\n\t * still use netconsole\n\t */\n\treturn;\n}\n#endif\nstatic const struct net_device_ops tun_netdev_ops = {\n\t.ndo_uninit\t\t= tun_net_uninit,\n\t.ndo_open\t\t= tun_net_open,\n\t.ndo_stop\t\t= tun_net_close,\n\t.ndo_start_xmit\t\t= tun_net_xmit,\n\t.ndo_change_mtu\t\t= tun_net_change_mtu,\n\t.ndo_fix_features\t= tun_net_fix_features,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= tun_poll_controller,\n#endif\n};\n\nstatic const struct net_device_ops tap_netdev_ops = {\n\t.ndo_uninit\t\t= tun_net_uninit,\n\t.ndo_open\t\t= tun_net_open,\n\t.ndo_stop\t\t= tun_net_close,\n\t.ndo_start_xmit\t\t= tun_net_xmit,\n\t.ndo_change_mtu\t\t= tun_net_change_mtu,\n\t.ndo_fix_features\t= tun_net_fix_features,\n\t.ndo_set_multicast_list\t= tun_net_mclist,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= tun_poll_controller,\n#endif\n};\n\n/* Initialize net device. */\nstatic void tun_net_init(struct net_device *dev)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\n\tswitch (tun->flags & TUN_TYPE_MASK) {\n\tcase TUN_TUN_DEV:\n\t\tdev->netdev_ops = &tun_netdev_ops;\n\n\t\t/* Point-to-Point TUN Device */\n\t\tdev->hard_header_len = 0;\n\t\tdev->addr_len = 0;\n\t\tdev->mtu = 1500;\n\n\t\t/* Zero header length */\n\t\tdev->type = ARPHRD_NONE;\n\t\tdev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;\n\t\tdev->tx_queue_len = TUN_READQ_SIZE;  /* We prefer our own queue length */\n\t\tbreak;\n\n\tcase TUN_TAP_DEV:\n\t\tdev->netdev_ops = &tap_netdev_ops;\n\t\t/* Ethernet TAP Device */\n\t\tether_setup(dev);\n\n\t\trandom_ether_addr(dev->dev_addr);\n\n\t\tdev->tx_queue_len = TUN_READQ_SIZE;  /* We prefer our own queue length */\n\t\tbreak;\n\t}\n}\n\n/* Character device part */\n\n/* Poll */\nstatic unsigned int tun_chr_poll(struct file *file, poll_table * wait)\n{\n\tstruct tun_file *tfile = file->private_data;\n\tstruct tun_struct *tun = __tun_get(tfile);\n\tstruct sock *sk;\n\tunsigned int mask = 0;\n\n\tif (!tun)\n\t\treturn POLLERR;\n\n\tsk = tun->socket.sk;\n\n\ttun_debug(KERN_INFO, tun, \"tun_chr_poll\\n\");\n\n\tpoll_wait(file, &tun->wq.wait, wait);\n\n\tif (!skb_queue_empty(&sk->sk_receive_queue))\n\t\tmask |= POLLIN | POLLRDNORM;\n\n\tif (sock_writeable(sk) ||\n\t    (!test_and_set_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags) &&\n\t     sock_writeable(sk)))\n\t\tmask |= POLLOUT | POLLWRNORM;\n\n\tif (tun->dev->reg_state != NETREG_REGISTERED)\n\t\tmask = POLLERR;\n\n\ttun_put(tun);\n\treturn mask;\n}\n\n/* prepad is the amount to reserve at front.  len is length after that.\n * linear is a hint as to how much to copy (usually headers). */\nstatic struct sk_buff *tun_alloc_skb(struct tun_struct *tun,\n\t\t\t\t     size_t prepad, size_t len,\n\t\t\t\t     size_t linear, int noblock)\n{\n\tstruct sock *sk = tun->socket.sk;\n\tstruct sk_buff *skb;\n\tint err;\n\n\tsock_update_classid(sk);\n\n\t/* Under a page?  Don't bother with paged skb. */\n\tif (prepad + len < PAGE_SIZE || !linear)\n\t\tlinear = len;\n\n\tskb = sock_alloc_send_pskb(sk, prepad + linear, len - linear, noblock,\n\t\t\t\t   &err);\n\tif (!skb)\n\t\treturn ERR_PTR(err);\n\n\tskb_reserve(skb, prepad);\n\tskb_put(skb, linear);\n\tskb->data_len = len - linear;\n\tskb->len += len - linear;\n\n\treturn skb;\n}\n\n/* Get packet from user space buffer */\nstatic ssize_t tun_get_user(struct tun_struct *tun,\n\t\t\t    const struct iovec *iv, size_t count,\n\t\t\t    int noblock)\n{\n\tstruct tun_pi pi = { 0, cpu_to_be16(ETH_P_IP) };\n\tstruct sk_buff *skb;\n\tsize_t len = count, align = NET_SKB_PAD;\n\tstruct virtio_net_hdr gso = { 0 };\n\tint offset = 0;\n\n\tif (!(tun->flags & TUN_NO_PI)) {\n\t\tif ((len -= sizeof(pi)) > count)\n\t\t\treturn -EINVAL;\n\n\t\tif (memcpy_fromiovecend((void *)&pi, iv, 0, sizeof(pi)))\n\t\t\treturn -EFAULT;\n\t\toffset += sizeof(pi);\n\t}\n\n\tif (tun->flags & TUN_VNET_HDR) {\n\t\tif ((len -= tun->vnet_hdr_sz) > count)\n\t\t\treturn -EINVAL;\n\n\t\tif (memcpy_fromiovecend((void *)&gso, iv, offset, sizeof(gso)))\n\t\t\treturn -EFAULT;\n\n\t\tif ((gso.flags & VIRTIO_NET_HDR_F_NEEDS_CSUM) &&\n\t\t    gso.csum_start + gso.csum_offset + 2 > gso.hdr_len)\n\t\t\tgso.hdr_len = gso.csum_start + gso.csum_offset + 2;\n\n\t\tif (gso.hdr_len > len)\n\t\t\treturn -EINVAL;\n\t\toffset += tun->vnet_hdr_sz;\n\t}\n\n\tif ((tun->flags & TUN_TYPE_MASK) == TUN_TAP_DEV) {\n\t\talign += NET_IP_ALIGN;\n\t\tif (unlikely(len < ETH_HLEN ||\n\t\t\t     (gso.hdr_len && gso.hdr_len < ETH_HLEN)))\n\t\t\treturn -EINVAL;\n\t}\n\n\tskb = tun_alloc_skb(tun, align, len, gso.hdr_len, noblock);\n\tif (IS_ERR(skb)) {\n\t\tif (PTR_ERR(skb) != -EAGAIN)\n\t\t\ttun->dev->stats.rx_dropped++;\n\t\treturn PTR_ERR(skb);\n\t}\n\n\tif (skb_copy_datagram_from_iovec(skb, 0, iv, offset, len)) {\n\t\ttun->dev->stats.rx_dropped++;\n\t\tkfree_skb(skb);\n\t\treturn -EFAULT;\n\t}\n\n\tif (gso.flags & VIRTIO_NET_HDR_F_NEEDS_CSUM) {\n\t\tif (!skb_partial_csum_set(skb, gso.csum_start,\n\t\t\t\t\t  gso.csum_offset)) {\n\t\t\ttun->dev->stats.rx_frame_errors++;\n\t\t\tkfree_skb(skb);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tswitch (tun->flags & TUN_TYPE_MASK) {\n\tcase TUN_TUN_DEV:\n\t\tif (tun->flags & TUN_NO_PI) {\n\t\t\tswitch (skb->data[0] & 0xf0) {\n\t\t\tcase 0x40:\n\t\t\t\tpi.proto = htons(ETH_P_IP);\n\t\t\t\tbreak;\n\t\t\tcase 0x60:\n\t\t\t\tpi.proto = htons(ETH_P_IPV6);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttun->dev->stats.rx_dropped++;\n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tskb_reset_mac_header(skb);\n\t\tskb->protocol = pi.proto;\n\t\tskb->dev = tun->dev;\n\t\tbreak;\n\tcase TUN_TAP_DEV:\n\t\tskb->protocol = eth_type_trans(skb, tun->dev);\n\t\tbreak;\n\t}\n\n\tif (gso.gso_type != VIRTIO_NET_HDR_GSO_NONE) {\n\t\tpr_debug(\"GSO!\\n\");\n\t\tswitch (gso.gso_type & ~VIRTIO_NET_HDR_GSO_ECN) {\n\t\tcase VIRTIO_NET_HDR_GSO_TCPV4:\n\t\t\tskb_shinfo(skb)->gso_type = SKB_GSO_TCPV4;\n\t\t\tbreak;\n\t\tcase VIRTIO_NET_HDR_GSO_TCPV6:\n\t\t\tskb_shinfo(skb)->gso_type = SKB_GSO_TCPV6;\n\t\t\tbreak;\n\t\tcase VIRTIO_NET_HDR_GSO_UDP:\n\t\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttun->dev->stats.rx_frame_errors++;\n\t\t\tkfree_skb(skb);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (gso.gso_type & VIRTIO_NET_HDR_GSO_ECN)\n\t\t\tskb_shinfo(skb)->gso_type |= SKB_GSO_TCP_ECN;\n\n\t\tskb_shinfo(skb)->gso_size = gso.gso_size;\n\t\tif (skb_shinfo(skb)->gso_size == 0) {\n\t\t\ttun->dev->stats.rx_frame_errors++;\n\t\t\tkfree_skb(skb);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Header must be checked, and gso_segs computed. */\n\t\tskb_shinfo(skb)->gso_type |= SKB_GSO_DODGY;\n\t\tskb_shinfo(skb)->gso_segs = 0;\n\t}\n\n\tnetif_rx_ni(skb);\n\n\ttun->dev->stats.rx_packets++;\n\ttun->dev->stats.rx_bytes += len;\n\n\treturn count;\n}\n\nstatic ssize_t tun_chr_aio_write(struct kiocb *iocb, const struct iovec *iv,\n\t\t\t      unsigned long count, loff_t pos)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct tun_struct *tun = tun_get(file);\n\tssize_t result;\n\n\tif (!tun)\n\t\treturn -EBADFD;\n\n\ttun_debug(KERN_INFO, tun, \"tun_chr_write %ld\\n\", count);\n\n\tresult = tun_get_user(tun, iv, iov_length(iv, count),\n\t\t\t      file->f_flags & O_NONBLOCK);\n\n\ttun_put(tun);\n\treturn result;\n}\n\n/* Put packet to the user space buffer */\nstatic ssize_t tun_put_user(struct tun_struct *tun,\n\t\t\t    struct sk_buff *skb,\n\t\t\t    const struct iovec *iv, int len)\n{\n\tstruct tun_pi pi = { 0, skb->protocol };\n\tssize_t total = 0;\n\n\tif (!(tun->flags & TUN_NO_PI)) {\n\t\tif ((len -= sizeof(pi)) < 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (len < skb->len) {\n\t\t\t/* Packet will be striped */\n\t\t\tpi.flags |= TUN_PKT_STRIP;\n\t\t}\n\n\t\tif (memcpy_toiovecend(iv, (void *) &pi, 0, sizeof(pi)))\n\t\t\treturn -EFAULT;\n\t\ttotal += sizeof(pi);\n\t}\n\n\tif (tun->flags & TUN_VNET_HDR) {\n\t\tstruct virtio_net_hdr gso = { 0 }; /* no info leak */\n\t\tif ((len -= tun->vnet_hdr_sz) < 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (skb_is_gso(skb)) {\n\t\t\tstruct skb_shared_info *sinfo = skb_shinfo(skb);\n\n\t\t\t/* This is a hint as to how much should be linear. */\n\t\t\tgso.hdr_len = skb_headlen(skb);\n\t\t\tgso.gso_size = sinfo->gso_size;\n\t\t\tif (sinfo->gso_type & SKB_GSO_TCPV4)\n\t\t\t\tgso.gso_type = VIRTIO_NET_HDR_GSO_TCPV4;\n\t\t\telse if (sinfo->gso_type & SKB_GSO_TCPV6)\n\t\t\t\tgso.gso_type = VIRTIO_NET_HDR_GSO_TCPV6;\n\t\t\telse if (sinfo->gso_type & SKB_GSO_UDP)\n\t\t\t\tgso.gso_type = VIRTIO_NET_HDR_GSO_UDP;\n\t\t\telse {\n\t\t\t\tpr_err(\"unexpected GSO type: \"\n\t\t\t\t       \"0x%x, gso_size %d, hdr_len %d\\n\",\n\t\t\t\t       sinfo->gso_type, gso.gso_size,\n\t\t\t\t       gso.hdr_len);\n\t\t\t\tprint_hex_dump(KERN_ERR, \"tun: \",\n\t\t\t\t\t       DUMP_PREFIX_NONE,\n\t\t\t\t\t       16, 1, skb->head,\n\t\t\t\t\t       min((int)gso.hdr_len, 64), true);\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (sinfo->gso_type & SKB_GSO_TCP_ECN)\n\t\t\t\tgso.gso_type |= VIRTIO_NET_HDR_GSO_ECN;\n\t\t} else\n\t\t\tgso.gso_type = VIRTIO_NET_HDR_GSO_NONE;\n\n\t\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\t\tgso.flags = VIRTIO_NET_HDR_F_NEEDS_CSUM;\n\t\t\tgso.csum_start = skb_checksum_start_offset(skb);\n\t\t\tgso.csum_offset = skb->csum_offset;\n\t\t} else if (skb->ip_summed == CHECKSUM_UNNECESSARY) {\n\t\t\tgso.flags = VIRTIO_NET_HDR_F_DATA_VALID;\n\t\t} /* else everything is zero */\n\n\t\tif (unlikely(memcpy_toiovecend(iv, (void *)&gso, total,\n\t\t\t\t\t       sizeof(gso))))\n\t\t\treturn -EFAULT;\n\t\ttotal += tun->vnet_hdr_sz;\n\t}\n\n\tlen = min_t(int, skb->len, len);\n\n\tskb_copy_datagram_const_iovec(skb, 0, iv, total, len);\n\ttotal += skb->len;\n\n\ttun->dev->stats.tx_packets++;\n\ttun->dev->stats.tx_bytes += len;\n\n\treturn total;\n}\n\nstatic ssize_t tun_do_read(struct tun_struct *tun,\n\t\t\t   struct kiocb *iocb, const struct iovec *iv,\n\t\t\t   ssize_t len, int noblock)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct sk_buff *skb;\n\tssize_t ret = 0;\n\n\ttun_debug(KERN_INFO, tun, \"tun_chr_read\\n\");\n\n\tif (unlikely(!noblock))\n\t\tadd_wait_queue(&tun->wq.wait, &wait);\n\twhile (len) {\n\t\tcurrent->state = TASK_INTERRUPTIBLE;\n\n\t\t/* Read frames from the queue */\n\t\tif (!(skb=skb_dequeue(&tun->socket.sk->sk_receive_queue))) {\n\t\t\tif (noblock) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tret = -ERESTARTSYS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (tun->dev->reg_state != NETREG_REGISTERED) {\n\t\t\t\tret = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Nothing to read, let's sleep */\n\t\t\tschedule();\n\t\t\tcontinue;\n\t\t}\n\t\tnetif_wake_queue(tun->dev);\n\n\t\tret = tun_put_user(tun, skb, iv, len);\n\t\tkfree_skb(skb);\n\t\tbreak;\n\t}\n\n\tcurrent->state = TASK_RUNNING;\n\tif (unlikely(!noblock))\n\t\tremove_wait_queue(&tun->wq.wait, &wait);\n\n\treturn ret;\n}\n\nstatic ssize_t tun_chr_aio_read(struct kiocb *iocb, const struct iovec *iv,\n\t\t\t    unsigned long count, loff_t pos)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct tun_file *tfile = file->private_data;\n\tstruct tun_struct *tun = __tun_get(tfile);\n\tssize_t len, ret;\n\n\tif (!tun)\n\t\treturn -EBADFD;\n\tlen = iov_length(iv, count);\n\tif (len < 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = tun_do_read(tun, iocb, iv, len, file->f_flags & O_NONBLOCK);\n\tret = min_t(ssize_t, ret, len);\nout:\n\ttun_put(tun);\n\treturn ret;\n}\n\nstatic void tun_setup(struct net_device *dev)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\n\ttun->owner = -1;\n\ttun->group = -1;\n\n\tdev->ethtool_ops = &tun_ethtool_ops;\n\tdev->destructor = tun_free_netdev;\n}\n\n/* Trivial set of netlink ops to allow deleting tun or tap\n * device with netlink.\n */\nstatic int tun_validate(struct nlattr *tb[], struct nlattr *data[])\n{\n\treturn -EINVAL;\n}\n\nstatic struct rtnl_link_ops tun_link_ops __read_mostly = {\n\t.kind\t\t= DRV_NAME,\n\t.priv_size\t= sizeof(struct tun_struct),\n\t.setup\t\t= tun_setup,\n\t.validate\t= tun_validate,\n};\n\nstatic void tun_sock_write_space(struct sock *sk)\n{\n\tstruct tun_struct *tun;\n\twait_queue_head_t *wqueue;\n\n\tif (!sock_writeable(sk))\n\t\treturn;\n\n\tif (!test_and_clear_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags))\n\t\treturn;\n\n\twqueue = sk_sleep(sk);\n\tif (wqueue && waitqueue_active(wqueue))\n\t\twake_up_interruptible_sync_poll(wqueue, POLLOUT |\n\t\t\t\t\t\tPOLLWRNORM | POLLWRBAND);\n\n\ttun = tun_sk(sk)->tun;\n\tkill_fasync(&tun->fasync, SIGIO, POLL_OUT);\n}\n\nstatic void tun_sock_destruct(struct sock *sk)\n{\n\tfree_netdev(tun_sk(sk)->tun->dev);\n}\n\nstatic int tun_sendmsg(struct kiocb *iocb, struct socket *sock,\n\t\t       struct msghdr *m, size_t total_len)\n{\n\tstruct tun_struct *tun = container_of(sock, struct tun_struct, socket);\n\treturn tun_get_user(tun, m->msg_iov, total_len,\n\t\t\t    m->msg_flags & MSG_DONTWAIT);\n}\n\nstatic int tun_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t       struct msghdr *m, size_t total_len,\n\t\t       int flags)\n{\n\tstruct tun_struct *tun = container_of(sock, struct tun_struct, socket);\n\tint ret;\n\tif (flags & ~(MSG_DONTWAIT|MSG_TRUNC))\n\t\treturn -EINVAL;\n\tret = tun_do_read(tun, iocb, m->msg_iov, total_len,\n\t\t\t  flags & MSG_DONTWAIT);\n\tif (ret > total_len) {\n\t\tm->msg_flags |= MSG_TRUNC;\n\t\tret = flags & MSG_TRUNC ? ret : total_len;\n\t}\n\treturn ret;\n}\n\n/* Ops structure to mimic raw sockets with tun */\nstatic const struct proto_ops tun_socket_ops = {\n\t.sendmsg = tun_sendmsg,\n\t.recvmsg = tun_recvmsg,\n};\n\nstatic struct proto tun_proto = {\n\t.name\t\t= \"tun\",\n\t.owner\t\t= THIS_MODULE,\n\t.obj_size\t= sizeof(struct tun_sock),\n};\n\nstatic int tun_flags(struct tun_struct *tun)\n{\n\tint flags = 0;\n\n\tif (tun->flags & TUN_TUN_DEV)\n\t\tflags |= IFF_TUN;\n\telse\n\t\tflags |= IFF_TAP;\n\n\tif (tun->flags & TUN_NO_PI)\n\t\tflags |= IFF_NO_PI;\n\n\tif (tun->flags & TUN_ONE_QUEUE)\n\t\tflags |= IFF_ONE_QUEUE;\n\n\tif (tun->flags & TUN_VNET_HDR)\n\t\tflags |= IFF_VNET_HDR;\n\n\treturn flags;\n}\n\nstatic ssize_t tun_show_flags(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct tun_struct *tun = netdev_priv(to_net_dev(dev));\n\treturn sprintf(buf, \"0x%x\\n\", tun_flags(tun));\n}\n\nstatic ssize_t tun_show_owner(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct tun_struct *tun = netdev_priv(to_net_dev(dev));\n\treturn sprintf(buf, \"%d\\n\", tun->owner);\n}\n\nstatic ssize_t tun_show_group(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct tun_struct *tun = netdev_priv(to_net_dev(dev));\n\treturn sprintf(buf, \"%d\\n\", tun->group);\n}\n\nstatic DEVICE_ATTR(tun_flags, 0444, tun_show_flags, NULL);\nstatic DEVICE_ATTR(owner, 0444, tun_show_owner, NULL);\nstatic DEVICE_ATTR(group, 0444, tun_show_group, NULL);\n\nstatic int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr)\n{\n\tstruct sock *sk;\n\tstruct tun_struct *tun;\n\tstruct net_device *dev;\n\tint err;\n\n\tdev = __dev_get_by_name(net, ifr->ifr_name);\n\tif (dev) {\n\t\tconst struct cred *cred = current_cred();\n\n\t\tif (ifr->ifr_flags & IFF_TUN_EXCL)\n\t\t\treturn -EBUSY;\n\t\tif ((ifr->ifr_flags & IFF_TUN) && dev->netdev_ops == &tun_netdev_ops)\n\t\t\ttun = netdev_priv(dev);\n\t\telse if ((ifr->ifr_flags & IFF_TAP) && dev->netdev_ops == &tap_netdev_ops)\n\t\t\ttun = netdev_priv(dev);\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\tif (((tun->owner != -1 && cred->euid != tun->owner) ||\n\t\t     (tun->group != -1 && !in_egroup_p(tun->group))) &&\n\t\t    !capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\terr = security_tun_dev_attach(tun->socket.sk);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = tun_attach(tun, file);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\telse {\n\t\tchar *name;\n\t\tunsigned long flags = 0;\n\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\terr = security_tun_dev_create();\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t/* Set dev type */\n\t\tif (ifr->ifr_flags & IFF_TUN) {\n\t\t\t/* TUN device */\n\t\t\tflags |= TUN_TUN_DEV;\n\t\t\tname = \"tun%d\";\n\t\t} else if (ifr->ifr_flags & IFF_TAP) {\n\t\t\t/* TAP device */\n\t\t\tflags |= TUN_TAP_DEV;\n\t\t\tname = \"tap%d\";\n\t\t} else\n\t\t\treturn -EINVAL;\n\n\t\tif (*ifr->ifr_name)\n\t\t\tname = ifr->ifr_name;\n\n\t\tdev = alloc_netdev(sizeof(struct tun_struct), name,\n\t\t\t\t   tun_setup);\n\t\tif (!dev)\n\t\t\treturn -ENOMEM;\n\n\t\tdev_net_set(dev, net);\n\t\tdev->rtnl_link_ops = &tun_link_ops;\n\n\t\ttun = netdev_priv(dev);\n\t\ttun->dev = dev;\n\t\ttun->flags = flags;\n\t\ttun->txflt.count = 0;\n\t\ttun->vnet_hdr_sz = sizeof(struct virtio_net_hdr);\n\n\t\terr = -ENOMEM;\n\t\tsk = sk_alloc(net, AF_UNSPEC, GFP_KERNEL, &tun_proto);\n\t\tif (!sk)\n\t\t\tgoto err_free_dev;\n\n\t\ttun->socket.wq = &tun->wq;\n\t\tinit_waitqueue_head(&tun->wq.wait);\n\t\ttun->socket.ops = &tun_socket_ops;\n\t\tsock_init_data(&tun->socket, sk);\n\t\tsk->sk_write_space = tun_sock_write_space;\n\t\tsk->sk_sndbuf = INT_MAX;\n\n\t\ttun_sk(sk)->tun = tun;\n\n\t\tsecurity_tun_dev_post_create(sk);\n\n\t\ttun_net_init(dev);\n\n\t\tdev->hw_features = NETIF_F_SG | NETIF_F_FRAGLIST |\n\t\t\tTUN_USER_FEATURES;\n\t\tdev->features = dev->hw_features;\n\n\t\terr = register_netdevice(tun->dev);\n\t\tif (err < 0)\n\t\t\tgoto err_free_sk;\n\n\t\tif (device_create_file(&tun->dev->dev, &dev_attr_tun_flags) ||\n\t\t    device_create_file(&tun->dev->dev, &dev_attr_owner) ||\n\t\t    device_create_file(&tun->dev->dev, &dev_attr_group))\n\t\t\tpr_err(\"Failed to create tun sysfs files\\n\");\n\n\t\tsk->sk_destruct = tun_sock_destruct;\n\n\t\terr = tun_attach(tun, file);\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\t}\n\n\ttun_debug(KERN_INFO, tun, \"tun_set_iff\\n\");\n\n\tif (ifr->ifr_flags & IFF_NO_PI)\n\t\ttun->flags |= TUN_NO_PI;\n\telse\n\t\ttun->flags &= ~TUN_NO_PI;\n\n\tif (ifr->ifr_flags & IFF_ONE_QUEUE)\n\t\ttun->flags |= TUN_ONE_QUEUE;\n\telse\n\t\ttun->flags &= ~TUN_ONE_QUEUE;\n\n\tif (ifr->ifr_flags & IFF_VNET_HDR)\n\t\ttun->flags |= TUN_VNET_HDR;\n\telse\n\t\ttun->flags &= ~TUN_VNET_HDR;\n\n\t/* Make sure persistent devices do not get stuck in\n\t * xoff state.\n\t */\n\tif (netif_running(tun->dev))\n\t\tnetif_wake_queue(tun->dev);\n\n\tstrcpy(ifr->ifr_name, tun->dev->name);\n\treturn 0;\n\n err_free_sk:\n\tsock_put(sk);\n err_free_dev:\n\tfree_netdev(dev);\n failed:\n\treturn err;\n}\n\nstatic int tun_get_iff(struct net *net, struct tun_struct *tun,\n\t\t       struct ifreq *ifr)\n{\n\ttun_debug(KERN_INFO, tun, \"tun_get_iff\\n\");\n\n\tstrcpy(ifr->ifr_name, tun->dev->name);\n\n\tifr->ifr_flags = tun_flags(tun);\n\n\treturn 0;\n}\n\n/* This is like a cut-down ethtool ops, except done via tun fd so no\n * privs required. */\nstatic int set_offload(struct tun_struct *tun, unsigned long arg)\n{\n\tu32 features = 0;\n\n\tif (arg & TUN_F_CSUM) {\n\t\tfeatures |= NETIF_F_HW_CSUM;\n\t\targ &= ~TUN_F_CSUM;\n\n\t\tif (arg & (TUN_F_TSO4|TUN_F_TSO6)) {\n\t\t\tif (arg & TUN_F_TSO_ECN) {\n\t\t\t\tfeatures |= NETIF_F_TSO_ECN;\n\t\t\t\targ &= ~TUN_F_TSO_ECN;\n\t\t\t}\n\t\t\tif (arg & TUN_F_TSO4)\n\t\t\t\tfeatures |= NETIF_F_TSO;\n\t\t\tif (arg & TUN_F_TSO6)\n\t\t\t\tfeatures |= NETIF_F_TSO6;\n\t\t\targ &= ~(TUN_F_TSO4|TUN_F_TSO6);\n\t\t}\n\n\t\tif (arg & TUN_F_UFO) {\n\t\t\tfeatures |= NETIF_F_UFO;\n\t\t\targ &= ~TUN_F_UFO;\n\t\t}\n\t}\n\n\t/* This gives the user a way to test for new features in future by\n\t * trying to set them. */\n\tif (arg)\n\t\treturn -EINVAL;\n\n\ttun->set_features = features;\n\tnetdev_update_features(tun->dev);\n\n\treturn 0;\n}\n\nstatic long __tun_chr_ioctl(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg, int ifreq_len)\n{\n\tstruct tun_file *tfile = file->private_data;\n\tstruct tun_struct *tun;\n\tvoid __user* argp = (void __user*)arg;\n\tstruct sock_fprog fprog;\n\tstruct ifreq ifr;\n\tint sndbuf;\n\tint vnet_hdr_sz;\n\tint ret;\n\n\tif (cmd == TUNSETIFF || _IOC_TYPE(cmd) == 0x89)\n\t\tif (copy_from_user(&ifr, argp, ifreq_len))\n\t\t\treturn -EFAULT;\n\n\tif (cmd == TUNGETFEATURES) {\n\t\t/* Currently this just means: \"what IFF flags are valid?\".\n\t\t * This is needed because we never checked for invalid flags on\n\t\t * TUNSETIFF. */\n\t\treturn put_user(IFF_TUN | IFF_TAP | IFF_NO_PI | IFF_ONE_QUEUE |\n\t\t\t\tIFF_VNET_HDR,\n\t\t\t\t(unsigned int __user*)argp);\n\t}\n\n\trtnl_lock();\n\n\ttun = __tun_get(tfile);\n\tif (cmd == TUNSETIFF && !tun) {\n\t\tifr.ifr_name[IFNAMSIZ-1] = '\\0';\n\n\t\tret = tun_set_iff(tfile->net, file, &ifr);\n\n\t\tif (ret)\n\t\t\tgoto unlock;\n\n\t\tif (copy_to_user(argp, &ifr, ifreq_len))\n\t\t\tret = -EFAULT;\n\t\tgoto unlock;\n\t}\n\n\tret = -EBADFD;\n\tif (!tun)\n\t\tgoto unlock;\n\n\ttun_debug(KERN_INFO, tun, \"tun_chr_ioctl cmd %d\\n\", cmd);\n\n\tret = 0;\n\tswitch (cmd) {\n\tcase TUNGETIFF:\n\t\tret = tun_get_iff(current->nsproxy->net_ns, tun, &ifr);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (copy_to_user(argp, &ifr, ifreq_len))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase TUNSETNOCSUM:\n\t\t/* Disable/Enable checksum */\n\n\t\t/* [unimplemented] */\n\t\ttun_debug(KERN_INFO, tun, \"ignored: set checksum %s\\n\",\n\t\t\t  arg ? \"disabled\" : \"enabled\");\n\t\tbreak;\n\n\tcase TUNSETPERSIST:\n\t\t/* Disable/Enable persist mode */\n\t\tif (arg)\n\t\t\ttun->flags |= TUN_PERSIST;\n\t\telse\n\t\t\ttun->flags &= ~TUN_PERSIST;\n\n\t\ttun_debug(KERN_INFO, tun, \"persist %s\\n\",\n\t\t\t  arg ? \"enabled\" : \"disabled\");\n\t\tbreak;\n\n\tcase TUNSETOWNER:\n\t\t/* Set owner of the device */\n\t\ttun->owner = (uid_t) arg;\n\n\t\ttun_debug(KERN_INFO, tun, \"owner set to %d\\n\", tun->owner);\n\t\tbreak;\n\n\tcase TUNSETGROUP:\n\t\t/* Set group of the device */\n\t\ttun->group= (gid_t) arg;\n\n\t\ttun_debug(KERN_INFO, tun, \"group set to %d\\n\", tun->group);\n\t\tbreak;\n\n\tcase TUNSETLINK:\n\t\t/* Only allow setting the type when the interface is down */\n\t\tif (tun->dev->flags & IFF_UP) {\n\t\t\ttun_debug(KERN_INFO, tun,\n\t\t\t\t  \"Linktype set failed because interface is up\\n\");\n\t\t\tret = -EBUSY;\n\t\t} else {\n\t\t\ttun->dev->type = (int) arg;\n\t\t\ttun_debug(KERN_INFO, tun, \"linktype set to %d\\n\",\n\t\t\t\t  tun->dev->type);\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\n#ifdef TUN_DEBUG\n\tcase TUNSETDEBUG:\n\t\ttun->debug = arg;\n\t\tbreak;\n#endif\n\tcase TUNSETOFFLOAD:\n\t\tret = set_offload(tun, arg);\n\t\tbreak;\n\n\tcase TUNSETTXFILTER:\n\t\t/* Can be set only for TAPs */\n\t\tret = -EINVAL;\n\t\tif ((tun->flags & TUN_TYPE_MASK) != TUN_TAP_DEV)\n\t\t\tbreak;\n\t\tret = update_filter(&tun->txflt, (void __user *)arg);\n\t\tbreak;\n\n\tcase SIOCGIFHWADDR:\n\t\t/* Get hw address */\n\t\tmemcpy(ifr.ifr_hwaddr.sa_data, tun->dev->dev_addr, ETH_ALEN);\n\t\tifr.ifr_hwaddr.sa_family = tun->dev->type;\n\t\tif (copy_to_user(argp, &ifr, ifreq_len))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase SIOCSIFHWADDR:\n\t\t/* Set hw address */\n\t\ttun_debug(KERN_DEBUG, tun, \"set hw address: %pM\\n\",\n\t\t\t  ifr.ifr_hwaddr.sa_data);\n\n\t\tret = dev_set_mac_address(tun->dev, &ifr.ifr_hwaddr);\n\t\tbreak;\n\n\tcase TUNGETSNDBUF:\n\t\tsndbuf = tun->socket.sk->sk_sndbuf;\n\t\tif (copy_to_user(argp, &sndbuf, sizeof(sndbuf)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase TUNSETSNDBUF:\n\t\tif (copy_from_user(&sndbuf, argp, sizeof(sndbuf))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\ttun->socket.sk->sk_sndbuf = sndbuf;\n\t\tbreak;\n\n\tcase TUNGETVNETHDRSZ:\n\t\tvnet_hdr_sz = tun->vnet_hdr_sz;\n\t\tif (copy_to_user(argp, &vnet_hdr_sz, sizeof(vnet_hdr_sz)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase TUNSETVNETHDRSZ:\n\t\tif (copy_from_user(&vnet_hdr_sz, argp, sizeof(vnet_hdr_sz))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (vnet_hdr_sz < (int)sizeof(struct virtio_net_hdr)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\ttun->vnet_hdr_sz = vnet_hdr_sz;\n\t\tbreak;\n\n\tcase TUNATTACHFILTER:\n\t\t/* Can be set only for TAPs */\n\t\tret = -EINVAL;\n\t\tif ((tun->flags & TUN_TYPE_MASK) != TUN_TAP_DEV)\n\t\t\tbreak;\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(&fprog, argp, sizeof(fprog)))\n\t\t\tbreak;\n\n\t\tret = sk_attach_filter(&fprog, tun->socket.sk);\n\t\tbreak;\n\n\tcase TUNDETACHFILTER:\n\t\t/* Can be set only for TAPs */\n\t\tret = -EINVAL;\n\t\tif ((tun->flags & TUN_TYPE_MASK) != TUN_TAP_DEV)\n\t\t\tbreak;\n\t\tret = sk_detach_filter(tun->socket.sk);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nunlock:\n\trtnl_unlock();\n\tif (tun)\n\t\ttun_put(tun);\n\treturn ret;\n}\n\nstatic long tun_chr_ioctl(struct file *file,\n\t\t\t  unsigned int cmd, unsigned long arg)\n{\n\treturn __tun_chr_ioctl(file, cmd, arg, sizeof (struct ifreq));\n}\n\n#ifdef CONFIG_COMPAT\nstatic long tun_chr_compat_ioctl(struct file *file,\n\t\t\t unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase TUNSETIFF:\n\tcase TUNGETIFF:\n\tcase TUNSETTXFILTER:\n\tcase TUNGETSNDBUF:\n\tcase TUNSETSNDBUF:\n\tcase SIOCGIFHWADDR:\n\tcase SIOCSIFHWADDR:\n\t\targ = (unsigned long)compat_ptr(arg);\n\t\tbreak;\n\tdefault:\n\t\targ = (compat_ulong_t)arg;\n\t\tbreak;\n\t}\n\n\t/*\n\t * compat_ifreq is shorter than ifreq, so we must not access beyond\n\t * the end of that structure. All fields that are used in this\n\t * driver are compatible though, we don't need to convert the\n\t * contents.\n\t */\n\treturn __tun_chr_ioctl(file, cmd, arg, sizeof(struct compat_ifreq));\n}\n#endif /* CONFIG_COMPAT */\n\nstatic int tun_chr_fasync(int fd, struct file *file, int on)\n{\n\tstruct tun_struct *tun = tun_get(file);\n\tint ret;\n\n\tif (!tun)\n\t\treturn -EBADFD;\n\n\ttun_debug(KERN_INFO, tun, \"tun_chr_fasync %d\\n\", on);\n\n\tif ((ret = fasync_helper(fd, file, on, &tun->fasync)) < 0)\n\t\tgoto out;\n\n\tif (on) {\n\t\tret = __f_setown(file, task_pid(current), PIDTYPE_PID, 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\ttun->flags |= TUN_FASYNC;\n\t} else\n\t\ttun->flags &= ~TUN_FASYNC;\n\tret = 0;\nout:\n\ttun_put(tun);\n\treturn ret;\n}\n\nstatic int tun_chr_open(struct inode *inode, struct file * file)\n{\n\tstruct tun_file *tfile;\n\n\tDBG1(KERN_INFO, \"tunX: tun_chr_open\\n\");\n\n\ttfile = kmalloc(sizeof(*tfile), GFP_KERNEL);\n\tif (!tfile)\n\t\treturn -ENOMEM;\n\tatomic_set(&tfile->count, 0);\n\ttfile->tun = NULL;\n\ttfile->net = get_net(current->nsproxy->net_ns);\n\tfile->private_data = tfile;\n\treturn 0;\n}\n\nstatic int tun_chr_close(struct inode *inode, struct file *file)\n{\n\tstruct tun_file *tfile = file->private_data;\n\tstruct tun_struct *tun;\n\n\ttun = __tun_get(tfile);\n\tif (tun) {\n\t\tstruct net_device *dev = tun->dev;\n\n\t\ttun_debug(KERN_INFO, tun, \"tun_chr_close\\n\");\n\n\t\t__tun_detach(tun);\n\n\t\t/* If desirable, unregister the netdevice. */\n\t\tif (!(tun->flags & TUN_PERSIST)) {\n\t\t\trtnl_lock();\n\t\t\tif (dev->reg_state == NETREG_REGISTERED)\n\t\t\t\tunregister_netdevice(dev);\n\t\t\trtnl_unlock();\n\t\t}\n\t}\n\n\ttun = tfile->tun;\n\tif (tun)\n\t\tsock_put(tun->socket.sk);\n\n\tput_net(tfile->net);\n\tkfree(tfile);\n\n\treturn 0;\n}\n\nstatic const struct file_operations tun_fops = {\n\t.owner\t= THIS_MODULE,\n\t.llseek = no_llseek,\n\t.read  = do_sync_read,\n\t.aio_read  = tun_chr_aio_read,\n\t.write = do_sync_write,\n\t.aio_write = tun_chr_aio_write,\n\t.poll\t= tun_chr_poll,\n\t.unlocked_ioctl\t= tun_chr_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = tun_chr_compat_ioctl,\n#endif\n\t.open\t= tun_chr_open,\n\t.release = tun_chr_close,\n\t.fasync = tun_chr_fasync\n};\n\nstatic struct miscdevice tun_miscdev = {\n\t.minor = TUN_MINOR,\n\t.name = \"tun\",\n\t.nodename = \"net/tun\",\n\t.fops = &tun_fops,\n};\n\n/* ethtool interface */\n\nstatic int tun_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\n{\n\tcmd->supported\t\t= 0;\n\tcmd->advertising\t= 0;\n\tethtool_cmd_speed_set(cmd, SPEED_10);\n\tcmd->duplex\t\t= DUPLEX_FULL;\n\tcmd->port\t\t= PORT_TP;\n\tcmd->phy_address\t= 0;\n\tcmd->transceiver\t= XCVR_INTERNAL;\n\tcmd->autoneg\t\t= AUTONEG_DISABLE;\n\tcmd->maxtxpkt\t\t= 0;\n\tcmd->maxrxpkt\t\t= 0;\n\treturn 0;\n}\n\nstatic void tun_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\n\tstrcpy(info->driver, DRV_NAME);\n\tstrcpy(info->version, DRV_VERSION);\n\tstrcpy(info->fw_version, \"N/A\");\n\n\tswitch (tun->flags & TUN_TYPE_MASK) {\n\tcase TUN_TUN_DEV:\n\t\tstrcpy(info->bus_info, \"tun\");\n\t\tbreak;\n\tcase TUN_TAP_DEV:\n\t\tstrcpy(info->bus_info, \"tap\");\n\t\tbreak;\n\t}\n}\n\nstatic u32 tun_get_msglevel(struct net_device *dev)\n{\n#ifdef TUN_DEBUG\n\tstruct tun_struct *tun = netdev_priv(dev);\n\treturn tun->debug;\n#else\n\treturn -EOPNOTSUPP;\n#endif\n}\n\nstatic void tun_set_msglevel(struct net_device *dev, u32 value)\n{\n#ifdef TUN_DEBUG\n\tstruct tun_struct *tun = netdev_priv(dev);\n\ttun->debug = value;\n#endif\n}\n\nstatic const struct ethtool_ops tun_ethtool_ops = {\n\t.get_settings\t= tun_get_settings,\n\t.get_drvinfo\t= tun_get_drvinfo,\n\t.get_msglevel\t= tun_get_msglevel,\n\t.set_msglevel\t= tun_set_msglevel,\n\t.get_link\t= ethtool_op_get_link,\n};\n\n\nstatic int __init tun_init(void)\n{\n\tint ret = 0;\n\n\tpr_info(\"%s, %s\\n\", DRV_DESCRIPTION, DRV_VERSION);\n\tpr_info(\"%s\\n\", DRV_COPYRIGHT);\n\n\tret = rtnl_link_register(&tun_link_ops);\n\tif (ret) {\n\t\tpr_err(\"Can't register link_ops\\n\");\n\t\tgoto err_linkops;\n\t}\n\n\tret = misc_register(&tun_miscdev);\n\tif (ret) {\n\t\tpr_err(\"Can't register misc device %d\\n\", TUN_MINOR);\n\t\tgoto err_misc;\n\t}\n\treturn  0;\nerr_misc:\n\trtnl_link_unregister(&tun_link_ops);\nerr_linkops:\n\treturn ret;\n}\n\nstatic void tun_cleanup(void)\n{\n\tmisc_deregister(&tun_miscdev);\n\trtnl_link_unregister(&tun_link_ops);\n}\n\n/* Get an underlying socket object from tun file.  Returns error unless file is\n * attached to a device.  The returned object works like a packet socket, it\n * can be used for sock_sendmsg/sock_recvmsg.  The caller is responsible for\n * holding a reference to the file for as long as the socket is in use. */\nstruct socket *tun_get_socket(struct file *file)\n{\n\tstruct tun_struct *tun;\n\tif (file->f_op != &tun_fops)\n\t\treturn ERR_PTR(-EINVAL);\n\ttun = tun_get(file);\n\tif (!tun)\n\t\treturn ERR_PTR(-EBADFD);\n\ttun_put(tun);\n\treturn &tun->socket;\n}\nEXPORT_SYMBOL_GPL(tun_get_socket);\n\nmodule_init(tun_init);\nmodule_exit(tun_cleanup);\nMODULE_DESCRIPTION(DRV_DESCRIPTION);\nMODULE_AUTHOR(DRV_COPYRIGHT);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_MISCDEV(TUN_MINOR);\nMODULE_ALIAS(\"devname:net/tun\");\n", "/*\n *  drivers/net/veth.c\n *\n *  Copyright (C) 2007 OpenVZ http://openvz.org, SWsoft Inc\n *\n * Author: Pavel Emelianov <xemul@openvz.org>\n * Ethtool interface from: Eric W. Biederman <ebiederm@xmission.com>\n *\n */\n\n#include <linux/netdevice.h>\n#include <linux/slab.h>\n#include <linux/ethtool.h>\n#include <linux/etherdevice.h>\n#include <linux/u64_stats_sync.h>\n\n#include <net/dst.h>\n#include <net/xfrm.h>\n#include <linux/veth.h>\n\n#define DRV_NAME\t\"veth\"\n#define DRV_VERSION\t\"1.0\"\n\n#define MIN_MTU 68\t\t/* Min L3 MTU */\n#define MAX_MTU 65535\t\t/* Max L3 MTU (arbitrary) */\n\nstruct veth_net_stats {\n\tu64\t\t\trx_packets;\n\tu64\t\t\ttx_packets;\n\tu64\t\t\trx_bytes;\n\tu64\t\t\ttx_bytes;\n\tu64\t\t\trx_dropped;\n\tstruct u64_stats_sync\tsyncp;\n};\n\nstruct veth_priv {\n\tstruct net_device *peer;\n\tstruct veth_net_stats __percpu *stats;\n};\n\n/*\n * ethtool interface\n */\n\nstatic struct {\n\tconst char string[ETH_GSTRING_LEN];\n} ethtool_stats_keys[] = {\n\t{ \"peer_ifindex\" },\n};\n\nstatic int veth_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\n{\n\tcmd->supported\t\t= 0;\n\tcmd->advertising\t= 0;\n\tethtool_cmd_speed_set(cmd, SPEED_10000);\n\tcmd->duplex\t\t= DUPLEX_FULL;\n\tcmd->port\t\t= PORT_TP;\n\tcmd->phy_address\t= 0;\n\tcmd->transceiver\t= XCVR_INTERNAL;\n\tcmd->autoneg\t\t= AUTONEG_DISABLE;\n\tcmd->maxtxpkt\t\t= 0;\n\tcmd->maxrxpkt\t\t= 0;\n\treturn 0;\n}\n\nstatic void veth_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstrcpy(info->driver, DRV_NAME);\n\tstrcpy(info->version, DRV_VERSION);\n\tstrcpy(info->fw_version, \"N/A\");\n}\n\nstatic void veth_get_strings(struct net_device *dev, u32 stringset, u8 *buf)\n{\n\tswitch(stringset) {\n\tcase ETH_SS_STATS:\n\t\tmemcpy(buf, &ethtool_stats_keys, sizeof(ethtool_stats_keys));\n\t\tbreak;\n\t}\n}\n\nstatic int veth_get_sset_count(struct net_device *dev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn ARRAY_SIZE(ethtool_stats_keys);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void veth_get_ethtool_stats(struct net_device *dev,\n\t\tstruct ethtool_stats *stats, u64 *data)\n{\n\tstruct veth_priv *priv;\n\n\tpriv = netdev_priv(dev);\n\tdata[0] = priv->peer->ifindex;\n}\n\nstatic const struct ethtool_ops veth_ethtool_ops = {\n\t.get_settings\t\t= veth_get_settings,\n\t.get_drvinfo\t\t= veth_get_drvinfo,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_strings\t\t= veth_get_strings,\n\t.get_sset_count\t\t= veth_get_sset_count,\n\t.get_ethtool_stats\t= veth_get_ethtool_stats,\n};\n\n/*\n * xmit\n */\n\nstatic netdev_tx_t veth_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct net_device *rcv = NULL;\n\tstruct veth_priv *priv, *rcv_priv;\n\tstruct veth_net_stats *stats, *rcv_stats;\n\tint length;\n\n\tpriv = netdev_priv(dev);\n\trcv = priv->peer;\n\trcv_priv = netdev_priv(rcv);\n\n\tstats = this_cpu_ptr(priv->stats);\n\trcv_stats = this_cpu_ptr(rcv_priv->stats);\n\n\t/* don't change ip_summed == CHECKSUM_PARTIAL, as that\n\t   will cause bad checksum on forwarded packets */\n\tif (skb->ip_summed == CHECKSUM_NONE &&\n\t    rcv->features & NETIF_F_RXCSUM)\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\tlength = skb->len;\n\tif (dev_forward_skb(rcv, skb) != NET_RX_SUCCESS)\n\t\tgoto rx_drop;\n\n\tu64_stats_update_begin(&stats->syncp);\n\tstats->tx_bytes += length;\n\tstats->tx_packets++;\n\tu64_stats_update_end(&stats->syncp);\n\n\tu64_stats_update_begin(&rcv_stats->syncp);\n\trcv_stats->rx_bytes += length;\n\trcv_stats->rx_packets++;\n\tu64_stats_update_end(&rcv_stats->syncp);\n\n\treturn NETDEV_TX_OK;\n\nrx_drop:\n\tu64_stats_update_begin(&rcv_stats->syncp);\n\trcv_stats->rx_dropped++;\n\tu64_stats_update_end(&rcv_stats->syncp);\n\treturn NETDEV_TX_OK;\n}\n\n/*\n * general routines\n */\n\nstatic struct rtnl_link_stats64 *veth_get_stats64(struct net_device *dev,\n\t\t\t\t\t\t  struct rtnl_link_stats64 *tot)\n{\n\tstruct veth_priv *priv = netdev_priv(dev);\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct veth_net_stats *stats = per_cpu_ptr(priv->stats, cpu);\n\t\tu64 rx_packets, rx_bytes, rx_dropped;\n\t\tu64 tx_packets, tx_bytes;\n\t\tunsigned int start;\n\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin_bh(&stats->syncp);\n\t\t\trx_packets = stats->rx_packets;\n\t\t\ttx_packets = stats->tx_packets;\n\t\t\trx_bytes = stats->rx_bytes;\n\t\t\ttx_bytes = stats->tx_bytes;\n\t\t\trx_dropped = stats->rx_dropped;\n\t\t} while (u64_stats_fetch_retry_bh(&stats->syncp, start));\n\t\ttot->rx_packets += rx_packets;\n\t\ttot->tx_packets += tx_packets;\n\t\ttot->rx_bytes   += rx_bytes;\n\t\ttot->tx_bytes   += tx_bytes;\n\t\ttot->rx_dropped += rx_dropped;\n\t}\n\n\treturn tot;\n}\n\nstatic int veth_open(struct net_device *dev)\n{\n\tstruct veth_priv *priv;\n\n\tpriv = netdev_priv(dev);\n\tif (priv->peer == NULL)\n\t\treturn -ENOTCONN;\n\n\tif (priv->peer->flags & IFF_UP) {\n\t\tnetif_carrier_on(dev);\n\t\tnetif_carrier_on(priv->peer);\n\t}\n\treturn 0;\n}\n\nstatic int veth_close(struct net_device *dev)\n{\n\tstruct veth_priv *priv = netdev_priv(dev);\n\n\tnetif_carrier_off(dev);\n\tnetif_carrier_off(priv->peer);\n\n\treturn 0;\n}\n\nstatic int is_valid_veth_mtu(int new_mtu)\n{\n\treturn new_mtu >= MIN_MTU && new_mtu <= MAX_MTU;\n}\n\nstatic int veth_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tif (!is_valid_veth_mtu(new_mtu))\n\t\treturn -EINVAL;\n\tdev->mtu = new_mtu;\n\treturn 0;\n}\n\nstatic int veth_dev_init(struct net_device *dev)\n{\n\tstruct veth_net_stats __percpu *stats;\n\tstruct veth_priv *priv;\n\n\tstats = alloc_percpu(struct veth_net_stats);\n\tif (stats == NULL)\n\t\treturn -ENOMEM;\n\n\tpriv = netdev_priv(dev);\n\tpriv->stats = stats;\n\treturn 0;\n}\n\nstatic void veth_dev_free(struct net_device *dev)\n{\n\tstruct veth_priv *priv;\n\n\tpriv = netdev_priv(dev);\n\tfree_percpu(priv->stats);\n\tfree_netdev(dev);\n}\n\nstatic const struct net_device_ops veth_netdev_ops = {\n\t.ndo_init            = veth_dev_init,\n\t.ndo_open            = veth_open,\n\t.ndo_stop            = veth_close,\n\t.ndo_start_xmit      = veth_xmit,\n\t.ndo_change_mtu      = veth_change_mtu,\n\t.ndo_get_stats64     = veth_get_stats64,\n\t.ndo_set_mac_address = eth_mac_addr,\n};\n\nstatic void veth_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\n\tdev->netdev_ops = &veth_netdev_ops;\n\tdev->ethtool_ops = &veth_ethtool_ops;\n\tdev->features |= NETIF_F_LLTX;\n\tdev->destructor = veth_dev_free;\n\n\tdev->hw_features = NETIF_F_NO_CSUM | NETIF_F_SG | NETIF_F_RXCSUM;\n}\n\n/*\n * netlink interface\n */\n\nstatic int veth_validate(struct nlattr *tb[], struct nlattr *data[])\n{\n\tif (tb[IFLA_ADDRESS]) {\n\t\tif (nla_len(tb[IFLA_ADDRESS]) != ETH_ALEN)\n\t\t\treturn -EINVAL;\n\t\tif (!is_valid_ether_addr(nla_data(tb[IFLA_ADDRESS])))\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\tif (tb[IFLA_MTU]) {\n\t\tif (!is_valid_veth_mtu(nla_get_u32(tb[IFLA_MTU])))\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic struct rtnl_link_ops veth_link_ops;\n\nstatic int veth_newlink(struct net *src_net, struct net_device *dev,\n\t\t\t struct nlattr *tb[], struct nlattr *data[])\n{\n\tint err;\n\tstruct net_device *peer;\n\tstruct veth_priv *priv;\n\tchar ifname[IFNAMSIZ];\n\tstruct nlattr *peer_tb[IFLA_MAX + 1], **tbp;\n\tstruct ifinfomsg *ifmp;\n\tstruct net *net;\n\n\t/*\n\t * create and register peer first\n\t */\n\tif (data != NULL && data[VETH_INFO_PEER] != NULL) {\n\t\tstruct nlattr *nla_peer;\n\n\t\tnla_peer = data[VETH_INFO_PEER];\n\t\tifmp = nla_data(nla_peer);\n\t\terr = nla_parse(peer_tb, IFLA_MAX,\n\t\t\t\tnla_data(nla_peer) + sizeof(struct ifinfomsg),\n\t\t\t\tnla_len(nla_peer) - sizeof(struct ifinfomsg),\n\t\t\t\tifla_policy);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = veth_validate(peer_tb, NULL);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\ttbp = peer_tb;\n\t} else {\n\t\tifmp = NULL;\n\t\ttbp = tb;\n\t}\n\n\tif (tbp[IFLA_IFNAME])\n\t\tnla_strlcpy(ifname, tbp[IFLA_IFNAME], IFNAMSIZ);\n\telse\n\t\tsnprintf(ifname, IFNAMSIZ, DRV_NAME \"%%d\");\n\n\tnet = rtnl_link_get_net(src_net, tbp);\n\tif (IS_ERR(net))\n\t\treturn PTR_ERR(net);\n\n\tpeer = rtnl_create_link(src_net, net, ifname, &veth_link_ops, tbp);\n\tif (IS_ERR(peer)) {\n\t\tput_net(net);\n\t\treturn PTR_ERR(peer);\n\t}\n\n\tif (tbp[IFLA_ADDRESS] == NULL)\n\t\trandom_ether_addr(peer->dev_addr);\n\n\terr = register_netdevice(peer);\n\tput_net(net);\n\tnet = NULL;\n\tif (err < 0)\n\t\tgoto err_register_peer;\n\n\tnetif_carrier_off(peer);\n\n\terr = rtnl_configure_link(peer, ifmp);\n\tif (err < 0)\n\t\tgoto err_configure_peer;\n\n\t/*\n\t * register dev last\n\t *\n\t * note, that since we've registered new device the dev's name\n\t * should be re-allocated\n\t */\n\n\tif (tb[IFLA_ADDRESS] == NULL)\n\t\trandom_ether_addr(dev->dev_addr);\n\n\tif (tb[IFLA_IFNAME])\n\t\tnla_strlcpy(dev->name, tb[IFLA_IFNAME], IFNAMSIZ);\n\telse\n\t\tsnprintf(dev->name, IFNAMSIZ, DRV_NAME \"%%d\");\n\n\tif (strchr(dev->name, '%')) {\n\t\terr = dev_alloc_name(dev, dev->name);\n\t\tif (err < 0)\n\t\t\tgoto err_alloc_name;\n\t}\n\n\terr = register_netdevice(dev);\n\tif (err < 0)\n\t\tgoto err_register_dev;\n\n\tnetif_carrier_off(dev);\n\n\t/*\n\t * tie the deviced together\n\t */\n\n\tpriv = netdev_priv(dev);\n\tpriv->peer = peer;\n\n\tpriv = netdev_priv(peer);\n\tpriv->peer = dev;\n\treturn 0;\n\nerr_register_dev:\n\t/* nothing to do */\nerr_alloc_name:\nerr_configure_peer:\n\tunregister_netdevice(peer);\n\treturn err;\n\nerr_register_peer:\n\tfree_netdev(peer);\n\treturn err;\n}\n\nstatic void veth_dellink(struct net_device *dev, struct list_head *head)\n{\n\tstruct veth_priv *priv;\n\tstruct net_device *peer;\n\n\tpriv = netdev_priv(dev);\n\tpeer = priv->peer;\n\n\tunregister_netdevice_queue(dev, head);\n\tunregister_netdevice_queue(peer, head);\n}\n\nstatic const struct nla_policy veth_policy[VETH_INFO_MAX + 1];\n\nstatic struct rtnl_link_ops veth_link_ops = {\n\t.kind\t\t= DRV_NAME,\n\t.priv_size\t= sizeof(struct veth_priv),\n\t.setup\t\t= veth_setup,\n\t.validate\t= veth_validate,\n\t.newlink\t= veth_newlink,\n\t.dellink\t= veth_dellink,\n\t.policy\t\t= veth_policy,\n\t.maxtype\t= VETH_INFO_MAX,\n};\n\n/*\n * init/fini\n */\n\nstatic __init int veth_init(void)\n{\n\treturn rtnl_link_register(&veth_link_ops);\n}\n\nstatic __exit void veth_exit(void)\n{\n\trtnl_link_unregister(&veth_link_ops);\n}\n\nmodule_init(veth_init);\nmodule_exit(veth_exit);\n\nMODULE_DESCRIPTION(\"Virtual Ethernet Tunnel\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS_RTNL_LINK(DRV_NAME);\n", "/*\n * Generic HDLC support routines for Linux\n * Frame Relay support\n *\n * Copyright (C) 1999 - 2006 Krzysztof Halasa <khc@pm.waw.pl>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of version 2 of the GNU General Public License\n * as published by the Free Software Foundation.\n *\n\n            Theory of PVC state\n\n DCE mode:\n\n (exist,new) -> 0,0 when \"PVC create\" or if \"link unreliable\"\n         0,x -> 1,1 if \"link reliable\" when sending FULL STATUS\n         1,1 -> 1,0 if received FULL STATUS ACK\n\n (active)    -> 0 when \"ifconfig PVC down\" or \"link unreliable\" or \"PVC create\"\n             -> 1 when \"PVC up\" and (exist,new) = 1,0\n\n DTE mode:\n (exist,new,active) = FULL STATUS if \"link reliable\"\n\t\t    = 0, 0, 0 if \"link unreliable\"\n No LMI:\n active = open and \"link reliable\"\n exist = new = not used\n\n CCITT LMI: ITU-T Q.933 Annex A\n ANSI LMI: ANSI T1.617 Annex D\n CISCO LMI: the original, aka \"Gang of Four\" LMI\n\n*/\n\n#include <linux/errno.h>\n#include <linux/etherdevice.h>\n#include <linux/hdlc.h>\n#include <linux/if_arp.h>\n#include <linux/inetdevice.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pkt_sched.h>\n#include <linux/poll.h>\n#include <linux/rtnetlink.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n\n#undef DEBUG_PKT\n#undef DEBUG_ECN\n#undef DEBUG_LINK\n#undef DEBUG_PROTO\n#undef DEBUG_PVC\n\n#define FR_UI\t\t\t0x03\n#define FR_PAD\t\t\t0x00\n\n#define NLPID_IP\t\t0xCC\n#define NLPID_IPV6\t\t0x8E\n#define NLPID_SNAP\t\t0x80\n#define NLPID_PAD\t\t0x00\n#define NLPID_CCITT_ANSI_LMI\t0x08\n#define NLPID_CISCO_LMI\t\t0x09\n\n\n#define LMI_CCITT_ANSI_DLCI\t   0 /* LMI DLCI */\n#define LMI_CISCO_DLCI\t\t1023\n\n#define LMI_CALLREF\t\t0x00 /* Call Reference */\n#define LMI_ANSI_LOCKSHIFT\t0x95 /* ANSI locking shift */\n#define LMI_ANSI_CISCO_REPTYPE\t0x01 /* report type */\n#define LMI_CCITT_REPTYPE\t0x51\n#define LMI_ANSI_CISCO_ALIVE\t0x03 /* keep alive */\n#define LMI_CCITT_ALIVE\t\t0x53\n#define LMI_ANSI_CISCO_PVCSTAT\t0x07 /* PVC status */\n#define LMI_CCITT_PVCSTAT\t0x57\n\n#define LMI_FULLREP\t\t0x00 /* full report  */\n#define LMI_INTEGRITY\t\t0x01 /* link integrity report */\n#define LMI_SINGLE\t\t0x02 /* single PVC report */\n\n#define LMI_STATUS_ENQUIRY      0x75\n#define LMI_STATUS              0x7D /* reply */\n\n#define LMI_REPT_LEN               1 /* report type element length */\n#define LMI_INTEG_LEN              2 /* link integrity element length */\n\n#define LMI_CCITT_CISCO_LENGTH\t  13 /* LMI frame lengths */\n#define LMI_ANSI_LENGTH\t\t  14\n\n\ntypedef struct {\n#if defined(__LITTLE_ENDIAN_BITFIELD)\n\tunsigned ea1:\t1;\n\tunsigned cr:\t1;\n\tunsigned dlcih:\t6;\n\n\tunsigned ea2:\t1;\n\tunsigned de:\t1;\n\tunsigned becn:\t1;\n\tunsigned fecn:\t1;\n\tunsigned dlcil:\t4;\n#else\n\tunsigned dlcih:\t6;\n\tunsigned cr:\t1;\n\tunsigned ea1:\t1;\n\n\tunsigned dlcil:\t4;\n\tunsigned fecn:\t1;\n\tunsigned becn:\t1;\n\tunsigned de:\t1;\n\tunsigned ea2:\t1;\n#endif\n}__packed fr_hdr;\n\n\ntypedef struct pvc_device_struct {\n\tstruct net_device *frad;\n\tstruct net_device *main;\n\tstruct net_device *ether;\t/* bridged Ethernet interface\t*/\n\tstruct pvc_device_struct *next;\t/* Sorted in ascending DLCI order */\n\tint dlci;\n\tint open_count;\n\n\tstruct {\n\t\tunsigned int new: 1;\n\t\tunsigned int active: 1;\n\t\tunsigned int exist: 1;\n\t\tunsigned int deleted: 1;\n\t\tunsigned int fecn: 1;\n\t\tunsigned int becn: 1;\n\t\tunsigned int bandwidth;\t/* Cisco LMI reporting only */\n\t}state;\n}pvc_device;\n\nstruct frad_state {\n\tfr_proto settings;\n\tpvc_device *first_pvc;\n\tint dce_pvc_count;\n\n\tstruct timer_list timer;\n\tunsigned long last_poll;\n\tint reliable;\n\tint dce_changed;\n\tint request;\n\tint fullrep_sent;\n\tu32 last_errors; /* last errors bit list */\n\tu8 n391cnt;\n\tu8 txseq; /* TX sequence number */\n\tu8 rxseq; /* RX sequence number */\n};\n\n\nstatic int fr_ioctl(struct net_device *dev, struct ifreq *ifr);\n\n\nstatic inline u16 q922_to_dlci(u8 *hdr)\n{\n\treturn ((hdr[0] & 0xFC) << 2) | ((hdr[1] & 0xF0) >> 4);\n}\n\n\nstatic inline void dlci_to_q922(u8 *hdr, u16 dlci)\n{\n\thdr[0] = (dlci >> 2) & 0xFC;\n\thdr[1] = ((dlci << 4) & 0xF0) | 0x01;\n}\n\n\nstatic inline struct frad_state* state(hdlc_device *hdlc)\n{\n\treturn(struct frad_state *)(hdlc->state);\n}\n\n\nstatic inline pvc_device* find_pvc(hdlc_device *hdlc, u16 dlci)\n{\n\tpvc_device *pvc = state(hdlc)->first_pvc;\n\n\twhile (pvc) {\n\t\tif (pvc->dlci == dlci)\n\t\t\treturn pvc;\n\t\tif (pvc->dlci > dlci)\n\t\t\treturn NULL; /* the list is sorted */\n\t\tpvc = pvc->next;\n\t}\n\n\treturn NULL;\n}\n\n\nstatic pvc_device* add_pvc(struct net_device *dev, u16 dlci)\n{\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\tpvc_device *pvc, **pvc_p = &state(hdlc)->first_pvc;\n\n\twhile (*pvc_p) {\n\t\tif ((*pvc_p)->dlci == dlci)\n\t\t\treturn *pvc_p;\n\t\tif ((*pvc_p)->dlci > dlci)\n\t\t\tbreak;\t/* the list is sorted */\n\t\tpvc_p = &(*pvc_p)->next;\n\t}\n\n\tpvc = kzalloc(sizeof(pvc_device), GFP_ATOMIC);\n#ifdef DEBUG_PVC\n\tprintk(KERN_DEBUG \"add_pvc: allocated pvc %p, frad %p\\n\", pvc, dev);\n#endif\n\tif (!pvc)\n\t\treturn NULL;\n\n\tpvc->dlci = dlci;\n\tpvc->frad = dev;\n\tpvc->next = *pvc_p;\t/* Put it in the chain */\n\t*pvc_p = pvc;\n\treturn pvc;\n}\n\n\nstatic inline int pvc_is_used(pvc_device *pvc)\n{\n\treturn pvc->main || pvc->ether;\n}\n\n\nstatic inline void pvc_carrier(int on, pvc_device *pvc)\n{\n\tif (on) {\n\t\tif (pvc->main)\n\t\t\tif (!netif_carrier_ok(pvc->main))\n\t\t\t\tnetif_carrier_on(pvc->main);\n\t\tif (pvc->ether)\n\t\t\tif (!netif_carrier_ok(pvc->ether))\n\t\t\t\tnetif_carrier_on(pvc->ether);\n\t} else {\n\t\tif (pvc->main)\n\t\t\tif (netif_carrier_ok(pvc->main))\n\t\t\t\tnetif_carrier_off(pvc->main);\n\t\tif (pvc->ether)\n\t\t\tif (netif_carrier_ok(pvc->ether))\n\t\t\t\tnetif_carrier_off(pvc->ether);\n\t}\n}\n\n\nstatic inline void delete_unused_pvcs(hdlc_device *hdlc)\n{\n\tpvc_device **pvc_p = &state(hdlc)->first_pvc;\n\n\twhile (*pvc_p) {\n\t\tif (!pvc_is_used(*pvc_p)) {\n\t\t\tpvc_device *pvc = *pvc_p;\n#ifdef DEBUG_PVC\n\t\t\tprintk(KERN_DEBUG \"freeing unused pvc: %p\\n\", pvc);\n#endif\n\t\t\t*pvc_p = pvc->next;\n\t\t\tkfree(pvc);\n\t\t\tcontinue;\n\t\t}\n\t\tpvc_p = &(*pvc_p)->next;\n\t}\n}\n\n\nstatic inline struct net_device** get_dev_p(pvc_device *pvc, int type)\n{\n\tif (type == ARPHRD_ETHER)\n\t\treturn &pvc->ether;\n\telse\n\t\treturn &pvc->main;\n}\n\n\nstatic int fr_hard_header(struct sk_buff **skb_p, u16 dlci)\n{\n\tu16 head_len;\n\tstruct sk_buff *skb = *skb_p;\n\n\tswitch (skb->protocol) {\n\tcase cpu_to_be16(NLPID_CCITT_ANSI_LMI):\n\t\thead_len = 4;\n\t\tskb_push(skb, head_len);\n\t\tskb->data[3] = NLPID_CCITT_ANSI_LMI;\n\t\tbreak;\n\n\tcase cpu_to_be16(NLPID_CISCO_LMI):\n\t\thead_len = 4;\n\t\tskb_push(skb, head_len);\n\t\tskb->data[3] = NLPID_CISCO_LMI;\n\t\tbreak;\n\n\tcase cpu_to_be16(ETH_P_IP):\n\t\thead_len = 4;\n\t\tskb_push(skb, head_len);\n\t\tskb->data[3] = NLPID_IP;\n\t\tbreak;\n\n\tcase cpu_to_be16(ETH_P_IPV6):\n\t\thead_len = 4;\n\t\tskb_push(skb, head_len);\n\t\tskb->data[3] = NLPID_IPV6;\n\t\tbreak;\n\n\tcase cpu_to_be16(ETH_P_802_3):\n\t\thead_len = 10;\n\t\tif (skb_headroom(skb) < head_len) {\n\t\t\tstruct sk_buff *skb2 = skb_realloc_headroom(skb,\n\t\t\t\t\t\t\t\t    head_len);\n\t\t\tif (!skb2)\n\t\t\t\treturn -ENOBUFS;\n\t\t\tdev_kfree_skb(skb);\n\t\t\tskb = *skb_p = skb2;\n\t\t}\n\t\tskb_push(skb, head_len);\n\t\tskb->data[3] = FR_PAD;\n\t\tskb->data[4] = NLPID_SNAP;\n\t\tskb->data[5] = FR_PAD;\n\t\tskb->data[6] = 0x80;\n\t\tskb->data[7] = 0xC2;\n\t\tskb->data[8] = 0x00;\n\t\tskb->data[9] = 0x07; /* bridged Ethernet frame w/out FCS */\n\t\tbreak;\n\n\tdefault:\n\t\thead_len = 10;\n\t\tskb_push(skb, head_len);\n\t\tskb->data[3] = FR_PAD;\n\t\tskb->data[4] = NLPID_SNAP;\n\t\tskb->data[5] = FR_PAD;\n\t\tskb->data[6] = FR_PAD;\n\t\tskb->data[7] = FR_PAD;\n\t\t*(__be16*)(skb->data + 8) = skb->protocol;\n\t}\n\n\tdlci_to_q922(skb->data, dlci);\n\tskb->data[2] = FR_UI;\n\treturn 0;\n}\n\n\n\nstatic int pvc_open(struct net_device *dev)\n{\n\tpvc_device *pvc = dev->ml_priv;\n\n\tif ((pvc->frad->flags & IFF_UP) == 0)\n\t\treturn -EIO;  /* Frad must be UP in order to activate PVC */\n\n\tif (pvc->open_count++ == 0) {\n\t\thdlc_device *hdlc = dev_to_hdlc(pvc->frad);\n\t\tif (state(hdlc)->settings.lmi == LMI_NONE)\n\t\t\tpvc->state.active = netif_carrier_ok(pvc->frad);\n\n\t\tpvc_carrier(pvc->state.active, pvc);\n\t\tstate(hdlc)->dce_changed = 1;\n\t}\n\treturn 0;\n}\n\n\n\nstatic int pvc_close(struct net_device *dev)\n{\n\tpvc_device *pvc = dev->ml_priv;\n\n\tif (--pvc->open_count == 0) {\n\t\thdlc_device *hdlc = dev_to_hdlc(pvc->frad);\n\t\tif (state(hdlc)->settings.lmi == LMI_NONE)\n\t\t\tpvc->state.active = 0;\n\n\t\tif (state(hdlc)->settings.dce) {\n\t\t\tstate(hdlc)->dce_changed = 1;\n\t\t\tpvc->state.active = 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n\nstatic int pvc_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tpvc_device *pvc = dev->ml_priv;\n\tfr_proto_pvc_info info;\n\n\tif (ifr->ifr_settings.type == IF_GET_PROTO) {\n\t\tif (dev->type == ARPHRD_ETHER)\n\t\t\tifr->ifr_settings.type = IF_PROTO_FR_ETH_PVC;\n\t\telse\n\t\t\tifr->ifr_settings.type = IF_PROTO_FR_PVC;\n\n\t\tif (ifr->ifr_settings.size < sizeof(info)) {\n\t\t\t/* data size wanted */\n\t\t\tifr->ifr_settings.size = sizeof(info);\n\t\t\treturn -ENOBUFS;\n\t\t}\n\n\t\tinfo.dlci = pvc->dlci;\n\t\tmemcpy(info.master, pvc->frad->name, IFNAMSIZ);\n\t\tif (copy_to_user(ifr->ifr_settings.ifs_ifsu.fr_pvc_info,\n\t\t\t\t &info, sizeof(info)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic netdev_tx_t pvc_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tpvc_device *pvc = dev->ml_priv;\n\n\tif (pvc->state.active) {\n\t\tif (dev->type == ARPHRD_ETHER) {\n\t\t\tint pad = ETH_ZLEN - skb->len;\n\t\t\tif (pad > 0) { /* Pad the frame with zeros */\n\t\t\t\tint len = skb->len;\n\t\t\t\tif (skb_tailroom(skb) < pad)\n\t\t\t\t\tif (pskb_expand_head(skb, 0, pad,\n\t\t\t\t\t\t\t     GFP_ATOMIC)) {\n\t\t\t\t\t\tdev->stats.tx_dropped++;\n\t\t\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\t\t\treturn NETDEV_TX_OK;\n\t\t\t\t\t}\n\t\t\t\tskb_put(skb, pad);\n\t\t\t\tmemset(skb->data + len, 0, pad);\n\t\t\t}\n\t\t\tskb->protocol = cpu_to_be16(ETH_P_802_3);\n\t\t}\n\t\tif (!fr_hard_header(&skb, pvc->dlci)) {\n\t\t\tdev->stats.tx_bytes += skb->len;\n\t\t\tdev->stats.tx_packets++;\n\t\t\tif (pvc->state.fecn) /* TX Congestion counter */\n\t\t\t\tdev->stats.tx_compressed++;\n\t\t\tskb->dev = pvc->frad;\n\t\t\tdev_queue_xmit(skb);\n\t\t\treturn NETDEV_TX_OK;\n\t\t}\n\t}\n\n\tdev->stats.tx_dropped++;\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic inline void fr_log_dlci_active(pvc_device *pvc)\n{\n\tnetdev_info(pvc->frad, \"DLCI %d [%s%s%s]%s %s\\n\",\n\t\t    pvc->dlci,\n\t\t    pvc->main ? pvc->main->name : \"\",\n\t\t    pvc->main && pvc->ether ? \" \" : \"\",\n\t\t    pvc->ether ? pvc->ether->name : \"\",\n\t\t    pvc->state.new ? \" new\" : \"\",\n\t\t    !pvc->state.exist ? \"deleted\" :\n\t\t    pvc->state.active ? \"active\" : \"inactive\");\n}\n\n\n\nstatic inline u8 fr_lmi_nextseq(u8 x)\n{\n\tx++;\n\treturn x ? x : 1;\n}\n\n\nstatic void fr_lmi_send(struct net_device *dev, int fullrep)\n{\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\tstruct sk_buff *skb;\n\tpvc_device *pvc = state(hdlc)->first_pvc;\n\tint lmi = state(hdlc)->settings.lmi;\n\tint dce = state(hdlc)->settings.dce;\n\tint len = lmi == LMI_ANSI ? LMI_ANSI_LENGTH : LMI_CCITT_CISCO_LENGTH;\n\tint stat_len = (lmi == LMI_CISCO) ? 6 : 3;\n\tu8 *data;\n\tint i = 0;\n\n\tif (dce && fullrep) {\n\t\tlen += state(hdlc)->dce_pvc_count * (2 + stat_len);\n\t\tif (len > HDLC_MAX_MRU) {\n\t\t\tnetdev_warn(dev, \"Too many PVCs while sending LMI full report\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tskb = dev_alloc_skb(len);\n\tif (!skb) {\n\t\tnetdev_warn(dev, \"Memory squeeze on fr_lmi_send()\\n\");\n\t\treturn;\n\t}\n\tmemset(skb->data, 0, len);\n\tskb_reserve(skb, 4);\n\tif (lmi == LMI_CISCO) {\n\t\tskb->protocol = cpu_to_be16(NLPID_CISCO_LMI);\n\t\tfr_hard_header(&skb, LMI_CISCO_DLCI);\n\t} else {\n\t\tskb->protocol = cpu_to_be16(NLPID_CCITT_ANSI_LMI);\n\t\tfr_hard_header(&skb, LMI_CCITT_ANSI_DLCI);\n\t}\n\tdata = skb_tail_pointer(skb);\n\tdata[i++] = LMI_CALLREF;\n\tdata[i++] = dce ? LMI_STATUS : LMI_STATUS_ENQUIRY;\n\tif (lmi == LMI_ANSI)\n\t\tdata[i++] = LMI_ANSI_LOCKSHIFT;\n\tdata[i++] = lmi == LMI_CCITT ? LMI_CCITT_REPTYPE :\n\t\tLMI_ANSI_CISCO_REPTYPE;\n\tdata[i++] = LMI_REPT_LEN;\n\tdata[i++] = fullrep ? LMI_FULLREP : LMI_INTEGRITY;\n\tdata[i++] = lmi == LMI_CCITT ? LMI_CCITT_ALIVE : LMI_ANSI_CISCO_ALIVE;\n\tdata[i++] = LMI_INTEG_LEN;\n\tdata[i++] = state(hdlc)->txseq =\n\t\tfr_lmi_nextseq(state(hdlc)->txseq);\n\tdata[i++] = state(hdlc)->rxseq;\n\n\tif (dce && fullrep) {\n\t\twhile (pvc) {\n\t\t\tdata[i++] = lmi == LMI_CCITT ? LMI_CCITT_PVCSTAT :\n\t\t\t\tLMI_ANSI_CISCO_PVCSTAT;\n\t\t\tdata[i++] = stat_len;\n\n\t\t\t/* LMI start/restart */\n\t\t\tif (state(hdlc)->reliable && !pvc->state.exist) {\n\t\t\t\tpvc->state.exist = pvc->state.new = 1;\n\t\t\t\tfr_log_dlci_active(pvc);\n\t\t\t}\n\n\t\t\t/* ifconfig PVC up */\n\t\t\tif (pvc->open_count && !pvc->state.active &&\n\t\t\t    pvc->state.exist && !pvc->state.new) {\n\t\t\t\tpvc_carrier(1, pvc);\n\t\t\t\tpvc->state.active = 1;\n\t\t\t\tfr_log_dlci_active(pvc);\n\t\t\t}\n\n\t\t\tif (lmi == LMI_CISCO) {\n\t\t\t\tdata[i] = pvc->dlci >> 8;\n\t\t\t\tdata[i + 1] = pvc->dlci & 0xFF;\n\t\t\t} else {\n\t\t\t\tdata[i] = (pvc->dlci >> 4) & 0x3F;\n\t\t\t\tdata[i + 1] = ((pvc->dlci << 3) & 0x78) | 0x80;\n\t\t\t\tdata[i + 2] = 0x80;\n\t\t\t}\n\n\t\t\tif (pvc->state.new)\n\t\t\t\tdata[i + 2] |= 0x08;\n\t\t\telse if (pvc->state.active)\n\t\t\t\tdata[i + 2] |= 0x02;\n\n\t\t\ti += stat_len;\n\t\t\tpvc = pvc->next;\n\t\t}\n\t}\n\n\tskb_put(skb, i);\n\tskb->priority = TC_PRIO_CONTROL;\n\tskb->dev = dev;\n\tskb_reset_network_header(skb);\n\n\tdev_queue_xmit(skb);\n}\n\n\n\nstatic void fr_set_link_state(int reliable, struct net_device *dev)\n{\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\tpvc_device *pvc = state(hdlc)->first_pvc;\n\n\tstate(hdlc)->reliable = reliable;\n\tif (reliable) {\n\t\tnetif_dormant_off(dev);\n\t\tstate(hdlc)->n391cnt = 0; /* Request full status */\n\t\tstate(hdlc)->dce_changed = 1;\n\n\t\tif (state(hdlc)->settings.lmi == LMI_NONE) {\n\t\t\twhile (pvc) {\t/* Activate all PVCs */\n\t\t\t\tpvc_carrier(1, pvc);\n\t\t\t\tpvc->state.exist = pvc->state.active = 1;\n\t\t\t\tpvc->state.new = 0;\n\t\t\t\tpvc = pvc->next;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tnetif_dormant_on(dev);\n\t\twhile (pvc) {\t\t/* Deactivate all PVCs */\n\t\t\tpvc_carrier(0, pvc);\n\t\t\tpvc->state.exist = pvc->state.active = 0;\n\t\t\tpvc->state.new = 0;\n\t\t\tif (!state(hdlc)->settings.dce)\n\t\t\t\tpvc->state.bandwidth = 0;\n\t\t\tpvc = pvc->next;\n\t\t}\n\t}\n}\n\n\nstatic void fr_timer(unsigned long arg)\n{\n\tstruct net_device *dev = (struct net_device *)arg;\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\tint i, cnt = 0, reliable;\n\tu32 list;\n\n\tif (state(hdlc)->settings.dce) {\n\t\treliable = state(hdlc)->request &&\n\t\t\ttime_before(jiffies, state(hdlc)->last_poll +\n\t\t\t\t    state(hdlc)->settings.t392 * HZ);\n\t\tstate(hdlc)->request = 0;\n\t} else {\n\t\tstate(hdlc)->last_errors <<= 1; /* Shift the list */\n\t\tif (state(hdlc)->request) {\n\t\t\tif (state(hdlc)->reliable)\n\t\t\t\tnetdev_info(dev, \"No LMI status reply received\\n\");\n\t\t\tstate(hdlc)->last_errors |= 1;\n\t\t}\n\n\t\tlist = state(hdlc)->last_errors;\n\t\tfor (i = 0; i < state(hdlc)->settings.n393; i++, list >>= 1)\n\t\t\tcnt += (list & 1);\t/* errors count */\n\n\t\treliable = (cnt < state(hdlc)->settings.n392);\n\t}\n\n\tif (state(hdlc)->reliable != reliable) {\n\t\tnetdev_info(dev, \"Link %sreliable\\n\", reliable ? \"\" : \"un\");\n\t\tfr_set_link_state(reliable, dev);\n\t}\n\n\tif (state(hdlc)->settings.dce)\n\t\tstate(hdlc)->timer.expires = jiffies +\n\t\t\tstate(hdlc)->settings.t392 * HZ;\n\telse {\n\t\tif (state(hdlc)->n391cnt)\n\t\t\tstate(hdlc)->n391cnt--;\n\n\t\tfr_lmi_send(dev, state(hdlc)->n391cnt == 0);\n\n\t\tstate(hdlc)->last_poll = jiffies;\n\t\tstate(hdlc)->request = 1;\n\t\tstate(hdlc)->timer.expires = jiffies +\n\t\t\tstate(hdlc)->settings.t391 * HZ;\n\t}\n\n\tstate(hdlc)->timer.function = fr_timer;\n\tstate(hdlc)->timer.data = arg;\n\tadd_timer(&state(hdlc)->timer);\n}\n\n\nstatic int fr_lmi_recv(struct net_device *dev, struct sk_buff *skb)\n{\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\tpvc_device *pvc;\n\tu8 rxseq, txseq;\n\tint lmi = state(hdlc)->settings.lmi;\n\tint dce = state(hdlc)->settings.dce;\n\tint stat_len = (lmi == LMI_CISCO) ? 6 : 3, reptype, error, no_ram, i;\n\n\tif (skb->len < (lmi == LMI_ANSI ? LMI_ANSI_LENGTH :\n\t\t\tLMI_CCITT_CISCO_LENGTH)) {\n\t\tnetdev_info(dev, \"Short LMI frame\\n\");\n\t\treturn 1;\n\t}\n\n\tif (skb->data[3] != (lmi == LMI_CISCO ? NLPID_CISCO_LMI :\n\t\t\t     NLPID_CCITT_ANSI_LMI)) {\n\t\tnetdev_info(dev, \"Received non-LMI frame with LMI DLCI\\n\");\n\t\treturn 1;\n\t}\n\n\tif (skb->data[4] != LMI_CALLREF) {\n\t\tnetdev_info(dev, \"Invalid LMI Call reference (0x%02X)\\n\",\n\t\t\t    skb->data[4]);\n\t\treturn 1;\n\t}\n\n\tif (skb->data[5] != (dce ? LMI_STATUS_ENQUIRY : LMI_STATUS)) {\n\t\tnetdev_info(dev, \"Invalid LMI Message type (0x%02X)\\n\",\n\t\t\t    skb->data[5]);\n\t\treturn 1;\n\t}\n\n\tif (lmi == LMI_ANSI) {\n\t\tif (skb->data[6] != LMI_ANSI_LOCKSHIFT) {\n\t\t\tnetdev_info(dev, \"Not ANSI locking shift in LMI message (0x%02X)\\n\",\n\t\t\t\t    skb->data[6]);\n\t\t\treturn 1;\n\t\t}\n\t\ti = 7;\n\t} else\n\t\ti = 6;\n\n\tif (skb->data[i] != (lmi == LMI_CCITT ? LMI_CCITT_REPTYPE :\n\t\t\t     LMI_ANSI_CISCO_REPTYPE)) {\n\t\tnetdev_info(dev, \"Not an LMI Report type IE (0x%02X)\\n\",\n\t\t\t    skb->data[i]);\n\t\treturn 1;\n\t}\n\n\tif (skb->data[++i] != LMI_REPT_LEN) {\n\t\tnetdev_info(dev, \"Invalid LMI Report type IE length (%u)\\n\",\n\t\t\t    skb->data[i]);\n\t\treturn 1;\n\t}\n\n\treptype = skb->data[++i];\n\tif (reptype != LMI_INTEGRITY && reptype != LMI_FULLREP) {\n\t\tnetdev_info(dev, \"Unsupported LMI Report type (0x%02X)\\n\",\n\t\t\t    reptype);\n\t\treturn 1;\n\t}\n\n\tif (skb->data[++i] != (lmi == LMI_CCITT ? LMI_CCITT_ALIVE :\n\t\t\t       LMI_ANSI_CISCO_ALIVE)) {\n\t\tnetdev_info(dev, \"Not an LMI Link integrity verification IE (0x%02X)\\n\",\n\t\t\t    skb->data[i]);\n\t\treturn 1;\n\t}\n\n\tif (skb->data[++i] != LMI_INTEG_LEN) {\n\t\tnetdev_info(dev, \"Invalid LMI Link integrity verification IE length (%u)\\n\",\n\t\t\t    skb->data[i]);\n\t\treturn 1;\n\t}\n\ti++;\n\n\tstate(hdlc)->rxseq = skb->data[i++]; /* TX sequence from peer */\n\trxseq = skb->data[i++];\t/* Should confirm our sequence */\n\n\ttxseq = state(hdlc)->txseq;\n\n\tif (dce)\n\t\tstate(hdlc)->last_poll = jiffies;\n\n\terror = 0;\n\tif (!state(hdlc)->reliable)\n\t\terror = 1;\n\n\tif (rxseq == 0 || rxseq != txseq) { /* Ask for full report next time */\n\t\tstate(hdlc)->n391cnt = 0;\n\t\terror = 1;\n\t}\n\n\tif (dce) {\n\t\tif (state(hdlc)->fullrep_sent && !error) {\n/* Stop sending full report - the last one has been confirmed by DTE */\n\t\t\tstate(hdlc)->fullrep_sent = 0;\n\t\t\tpvc = state(hdlc)->first_pvc;\n\t\t\twhile (pvc) {\n\t\t\t\tif (pvc->state.new) {\n\t\t\t\t\tpvc->state.new = 0;\n\n/* Tell DTE that new PVC is now active */\n\t\t\t\t\tstate(hdlc)->dce_changed = 1;\n\t\t\t\t}\n\t\t\t\tpvc = pvc->next;\n\t\t\t}\n\t\t}\n\n\t\tif (state(hdlc)->dce_changed) {\n\t\t\treptype = LMI_FULLREP;\n\t\t\tstate(hdlc)->fullrep_sent = 1;\n\t\t\tstate(hdlc)->dce_changed = 0;\n\t\t}\n\n\t\tstate(hdlc)->request = 1; /* got request */\n\t\tfr_lmi_send(dev, reptype == LMI_FULLREP ? 1 : 0);\n\t\treturn 0;\n\t}\n\n\t/* DTE */\n\n\tstate(hdlc)->request = 0; /* got response, no request pending */\n\n\tif (error)\n\t\treturn 0;\n\n\tif (reptype != LMI_FULLREP)\n\t\treturn 0;\n\n\tpvc = state(hdlc)->first_pvc;\n\n\twhile (pvc) {\n\t\tpvc->state.deleted = 1;\n\t\tpvc = pvc->next;\n\t}\n\n\tno_ram = 0;\n\twhile (skb->len >= i + 2 + stat_len) {\n\t\tu16 dlci;\n\t\tu32 bw;\n\t\tunsigned int active, new;\n\n\t\tif (skb->data[i] != (lmi == LMI_CCITT ? LMI_CCITT_PVCSTAT :\n\t\t\t\t       LMI_ANSI_CISCO_PVCSTAT)) {\n\t\t\tnetdev_info(dev, \"Not an LMI PVC status IE (0x%02X)\\n\",\n\t\t\t\t    skb->data[i]);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (skb->data[++i] != stat_len) {\n\t\t\tnetdev_info(dev, \"Invalid LMI PVC status IE length (%u)\\n\",\n\t\t\t\t    skb->data[i]);\n\t\t\treturn 1;\n\t\t}\n\t\ti++;\n\n\t\tnew = !! (skb->data[i + 2] & 0x08);\n\t\tactive = !! (skb->data[i + 2] & 0x02);\n\t\tif (lmi == LMI_CISCO) {\n\t\t\tdlci = (skb->data[i] << 8) | skb->data[i + 1];\n\t\t\tbw = (skb->data[i + 3] << 16) |\n\t\t\t\t(skb->data[i + 4] << 8) |\n\t\t\t\t(skb->data[i + 5]);\n\t\t} else {\n\t\t\tdlci = ((skb->data[i] & 0x3F) << 4) |\n\t\t\t\t((skb->data[i + 1] & 0x78) >> 3);\n\t\t\tbw = 0;\n\t\t}\n\n\t\tpvc = add_pvc(dev, dlci);\n\n\t\tif (!pvc && !no_ram) {\n\t\t\tnetdev_warn(dev, \"Memory squeeze on fr_lmi_recv()\\n\");\n\t\t\tno_ram = 1;\n\t\t}\n\n\t\tif (pvc) {\n\t\t\tpvc->state.exist = 1;\n\t\t\tpvc->state.deleted = 0;\n\t\t\tif (active != pvc->state.active ||\n\t\t\t    new != pvc->state.new ||\n\t\t\t    bw != pvc->state.bandwidth ||\n\t\t\t    !pvc->state.exist) {\n\t\t\t\tpvc->state.new = new;\n\t\t\t\tpvc->state.active = active;\n\t\t\t\tpvc->state.bandwidth = bw;\n\t\t\t\tpvc_carrier(active, pvc);\n\t\t\t\tfr_log_dlci_active(pvc);\n\t\t\t}\n\t\t}\n\n\t\ti += stat_len;\n\t}\n\n\tpvc = state(hdlc)->first_pvc;\n\n\twhile (pvc) {\n\t\tif (pvc->state.deleted && pvc->state.exist) {\n\t\t\tpvc_carrier(0, pvc);\n\t\t\tpvc->state.active = pvc->state.new = 0;\n\t\t\tpvc->state.exist = 0;\n\t\t\tpvc->state.bandwidth = 0;\n\t\t\tfr_log_dlci_active(pvc);\n\t\t}\n\t\tpvc = pvc->next;\n\t}\n\n\t/* Next full report after N391 polls */\n\tstate(hdlc)->n391cnt = state(hdlc)->settings.n391;\n\n\treturn 0;\n}\n\n\nstatic int fr_rx(struct sk_buff *skb)\n{\n\tstruct net_device *frad = skb->dev;\n\thdlc_device *hdlc = dev_to_hdlc(frad);\n\tfr_hdr *fh = (fr_hdr*)skb->data;\n\tu8 *data = skb->data;\n\tu16 dlci;\n\tpvc_device *pvc;\n\tstruct net_device *dev = NULL;\n\n\tif (skb->len <= 4 || fh->ea1 || data[2] != FR_UI)\n\t\tgoto rx_error;\n\n\tdlci = q922_to_dlci(skb->data);\n\n\tif ((dlci == LMI_CCITT_ANSI_DLCI &&\n\t     (state(hdlc)->settings.lmi == LMI_ANSI ||\n\t      state(hdlc)->settings.lmi == LMI_CCITT)) ||\n\t    (dlci == LMI_CISCO_DLCI &&\n\t     state(hdlc)->settings.lmi == LMI_CISCO)) {\n\t\tif (fr_lmi_recv(frad, skb))\n\t\t\tgoto rx_error;\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NET_RX_SUCCESS;\n\t}\n\n\tpvc = find_pvc(hdlc, dlci);\n\tif (!pvc) {\n#ifdef DEBUG_PKT\n\t\tnetdev_info(frad, \"No PVC for received frame's DLCI %d\\n\",\n\t\t\t    dlci);\n#endif\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NET_RX_DROP;\n\t}\n\n\tif (pvc->state.fecn != fh->fecn) {\n#ifdef DEBUG_ECN\n\t\tprintk(KERN_DEBUG \"%s: DLCI %d FECN O%s\\n\", frad->name,\n\t\t       dlci, fh->fecn ? \"N\" : \"FF\");\n#endif\n\t\tpvc->state.fecn ^= 1;\n\t}\n\n\tif (pvc->state.becn != fh->becn) {\n#ifdef DEBUG_ECN\n\t\tprintk(KERN_DEBUG \"%s: DLCI %d BECN O%s\\n\", frad->name,\n\t\t       dlci, fh->becn ? \"N\" : \"FF\");\n#endif\n\t\tpvc->state.becn ^= 1;\n\t}\n\n\n\tif ((skb = skb_share_check(skb, GFP_ATOMIC)) == NULL) {\n\t\tfrad->stats.rx_dropped++;\n\t\treturn NET_RX_DROP;\n\t}\n\n\tif (data[3] == NLPID_IP) {\n\t\tskb_pull(skb, 4); /* Remove 4-byte header (hdr, UI, NLPID) */\n\t\tdev = pvc->main;\n\t\tskb->protocol = htons(ETH_P_IP);\n\n\t} else if (data[3] == NLPID_IPV6) {\n\t\tskb_pull(skb, 4); /* Remove 4-byte header (hdr, UI, NLPID) */\n\t\tdev = pvc->main;\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\n\t} else if (skb->len > 10 && data[3] == FR_PAD &&\n\t\t   data[4] == NLPID_SNAP && data[5] == FR_PAD) {\n\t\tu16 oui = ntohs(*(__be16*)(data + 6));\n\t\tu16 pid = ntohs(*(__be16*)(data + 8));\n\t\tskb_pull(skb, 10);\n\n\t\tswitch ((((u32)oui) << 16) | pid) {\n\t\tcase ETH_P_ARP: /* routed frame with SNAP */\n\t\tcase ETH_P_IPX:\n\t\tcase ETH_P_IP:\t/* a long variant */\n\t\tcase ETH_P_IPV6:\n\t\t\tdev = pvc->main;\n\t\t\tskb->protocol = htons(pid);\n\t\t\tbreak;\n\n\t\tcase 0x80C20007: /* bridged Ethernet frame */\n\t\t\tif ((dev = pvc->ether) != NULL)\n\t\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tnetdev_info(frad, \"Unsupported protocol, OUI=%x PID=%x\\n\",\n\t\t\t\t    oui, pid);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\treturn NET_RX_DROP;\n\t\t}\n\t} else {\n\t\tnetdev_info(frad, \"Unsupported protocol, NLPID=%x length=%i\\n\",\n\t\t\t    data[3], skb->len);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NET_RX_DROP;\n\t}\n\n\tif (dev) {\n\t\tdev->stats.rx_packets++; /* PVC traffic */\n\t\tdev->stats.rx_bytes += skb->len;\n\t\tif (pvc->state.becn)\n\t\t\tdev->stats.rx_compressed++;\n\t\tskb->dev = dev;\n\t\tnetif_rx(skb);\n\t\treturn NET_RX_SUCCESS;\n\t} else {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NET_RX_DROP;\n\t}\n\n rx_error:\n\tfrad->stats.rx_errors++; /* Mark error */\n\tdev_kfree_skb_any(skb);\n\treturn NET_RX_DROP;\n}\n\n\n\nstatic void fr_start(struct net_device *dev)\n{\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n#ifdef DEBUG_LINK\n\tprintk(KERN_DEBUG \"fr_start\\n\");\n#endif\n\tif (state(hdlc)->settings.lmi != LMI_NONE) {\n\t\tstate(hdlc)->reliable = 0;\n\t\tstate(hdlc)->dce_changed = 1;\n\t\tstate(hdlc)->request = 0;\n\t\tstate(hdlc)->fullrep_sent = 0;\n\t\tstate(hdlc)->last_errors = 0xFFFFFFFF;\n\t\tstate(hdlc)->n391cnt = 0;\n\t\tstate(hdlc)->txseq = state(hdlc)->rxseq = 0;\n\n\t\tinit_timer(&state(hdlc)->timer);\n\t\t/* First poll after 1 s */\n\t\tstate(hdlc)->timer.expires = jiffies + HZ;\n\t\tstate(hdlc)->timer.function = fr_timer;\n\t\tstate(hdlc)->timer.data = (unsigned long)dev;\n\t\tadd_timer(&state(hdlc)->timer);\n\t} else\n\t\tfr_set_link_state(1, dev);\n}\n\n\nstatic void fr_stop(struct net_device *dev)\n{\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n#ifdef DEBUG_LINK\n\tprintk(KERN_DEBUG \"fr_stop\\n\");\n#endif\n\tif (state(hdlc)->settings.lmi != LMI_NONE)\n\t\tdel_timer_sync(&state(hdlc)->timer);\n\tfr_set_link_state(0, dev);\n}\n\n\nstatic void fr_close(struct net_device *dev)\n{\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\tpvc_device *pvc = state(hdlc)->first_pvc;\n\n\twhile (pvc) {\t\t/* Shutdown all PVCs for this FRAD */\n\t\tif (pvc->main)\n\t\t\tdev_close(pvc->main);\n\t\tif (pvc->ether)\n\t\t\tdev_close(pvc->ether);\n\t\tpvc = pvc->next;\n\t}\n}\n\n\nstatic void pvc_setup(struct net_device *dev)\n{\n\tdev->type = ARPHRD_DLCI;\n\tdev->flags = IFF_POINTOPOINT;\n\tdev->hard_header_len = 10;\n\tdev->addr_len = 2;\n\tdev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n}\n\nstatic const struct net_device_ops pvc_ops = {\n\t.ndo_open       = pvc_open,\n\t.ndo_stop       = pvc_close,\n\t.ndo_change_mtu = hdlc_change_mtu,\n\t.ndo_start_xmit = pvc_xmit,\n\t.ndo_do_ioctl   = pvc_ioctl,\n};\n\nstatic int fr_add_pvc(struct net_device *frad, unsigned int dlci, int type)\n{\n\thdlc_device *hdlc = dev_to_hdlc(frad);\n\tpvc_device *pvc;\n\tstruct net_device *dev;\n\tint used;\n\n\tif ((pvc = add_pvc(frad, dlci)) == NULL) {\n\t\tnetdev_warn(frad, \"Memory squeeze on fr_add_pvc()\\n\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tif (*get_dev_p(pvc, type))\n\t\treturn -EEXIST;\n\n\tused = pvc_is_used(pvc);\n\n\tif (type == ARPHRD_ETHER)\n\t\tdev = alloc_netdev(0, \"pvceth%d\", ether_setup);\n\telse\n\t\tdev = alloc_netdev(0, \"pvc%d\", pvc_setup);\n\n\tif (!dev) {\n\t\tnetdev_warn(frad, \"Memory squeeze on fr_pvc()\\n\");\n\t\tdelete_unused_pvcs(hdlc);\n\t\treturn -ENOBUFS;\n\t}\n\n\tif (type == ARPHRD_ETHER)\n\t\trandom_ether_addr(dev->dev_addr);\n\telse {\n\t\t*(__be16*)dev->dev_addr = htons(dlci);\n\t\tdlci_to_q922(dev->broadcast, dlci);\n\t}\n\tdev->netdev_ops = &pvc_ops;\n\tdev->mtu = HDLC_MAX_MTU;\n\tdev->tx_queue_len = 0;\n\tdev->ml_priv = pvc;\n\n\tif (register_netdevice(dev) != 0) {\n\t\tfree_netdev(dev);\n\t\tdelete_unused_pvcs(hdlc);\n\t\treturn -EIO;\n\t}\n\n\tdev->destructor = free_netdev;\n\t*get_dev_p(pvc, type) = dev;\n\tif (!used) {\n\t\tstate(hdlc)->dce_changed = 1;\n\t\tstate(hdlc)->dce_pvc_count++;\n\t}\n\treturn 0;\n}\n\n\n\nstatic int fr_del_pvc(hdlc_device *hdlc, unsigned int dlci, int type)\n{\n\tpvc_device *pvc;\n\tstruct net_device *dev;\n\n\tif ((pvc = find_pvc(hdlc, dlci)) == NULL)\n\t\treturn -ENOENT;\n\n\tif ((dev = *get_dev_p(pvc, type)) == NULL)\n\t\treturn -ENOENT;\n\n\tif (dev->flags & IFF_UP)\n\t\treturn -EBUSY;\t\t/* PVC in use */\n\n\tunregister_netdevice(dev); /* the destructor will free_netdev(dev) */\n\t*get_dev_p(pvc, type) = NULL;\n\n\tif (!pvc_is_used(pvc)) {\n\t\tstate(hdlc)->dce_pvc_count--;\n\t\tstate(hdlc)->dce_changed = 1;\n\t}\n\tdelete_unused_pvcs(hdlc);\n\treturn 0;\n}\n\n\n\nstatic void fr_destroy(struct net_device *frad)\n{\n\thdlc_device *hdlc = dev_to_hdlc(frad);\n\tpvc_device *pvc = state(hdlc)->first_pvc;\n\tstate(hdlc)->first_pvc = NULL; /* All PVCs destroyed */\n\tstate(hdlc)->dce_pvc_count = 0;\n\tstate(hdlc)->dce_changed = 1;\n\n\twhile (pvc) {\n\t\tpvc_device *next = pvc->next;\n\t\t/* destructors will free_netdev() main and ether */\n\t\tif (pvc->main)\n\t\t\tunregister_netdevice(pvc->main);\n\n\t\tif (pvc->ether)\n\t\t\tunregister_netdevice(pvc->ether);\n\n\t\tkfree(pvc);\n\t\tpvc = next;\n\t}\n}\n\n\nstatic struct hdlc_proto proto = {\n\t.close\t\t= fr_close,\n\t.start\t\t= fr_start,\n\t.stop\t\t= fr_stop,\n\t.detach\t\t= fr_destroy,\n\t.ioctl\t\t= fr_ioctl,\n\t.netif_rx\t= fr_rx,\n\t.module\t\t= THIS_MODULE,\n};\n\n\nstatic int fr_ioctl(struct net_device *dev, struct ifreq *ifr)\n{\n\tfr_proto __user *fr_s = ifr->ifr_settings.ifs_ifsu.fr;\n\tconst size_t size = sizeof(fr_proto);\n\tfr_proto new_settings;\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\tfr_proto_pvc pvc;\n\tint result;\n\n\tswitch (ifr->ifr_settings.type) {\n\tcase IF_GET_PROTO:\n\t\tif (dev_to_hdlc(dev)->proto != &proto) /* Different proto */\n\t\t\treturn -EINVAL;\n\t\tifr->ifr_settings.type = IF_PROTO_FR;\n\t\tif (ifr->ifr_settings.size < size) {\n\t\t\tifr->ifr_settings.size = size; /* data size wanted */\n\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tif (copy_to_user(fr_s, &state(hdlc)->settings, size))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase IF_PROTO_FR:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (dev->flags & IFF_UP)\n\t\t\treturn -EBUSY;\n\n\t\tif (copy_from_user(&new_settings, fr_s, size))\n\t\t\treturn -EFAULT;\n\n\t\tif (new_settings.lmi == LMI_DEFAULT)\n\t\t\tnew_settings.lmi = LMI_ANSI;\n\n\t\tif ((new_settings.lmi != LMI_NONE &&\n\t\t     new_settings.lmi != LMI_ANSI &&\n\t\t     new_settings.lmi != LMI_CCITT &&\n\t\t     new_settings.lmi != LMI_CISCO) ||\n\t\t    new_settings.t391 < 1 ||\n\t\t    new_settings.t392 < 2 ||\n\t\t    new_settings.n391 < 1 ||\n\t\t    new_settings.n392 < 1 ||\n\t\t    new_settings.n393 < new_settings.n392 ||\n\t\t    new_settings.n393 > 32 ||\n\t\t    (new_settings.dce != 0 &&\n\t\t     new_settings.dce != 1))\n\t\t\treturn -EINVAL;\n\n\t\tresult=hdlc->attach(dev, ENCODING_NRZ,PARITY_CRC16_PR1_CCITT);\n\t\tif (result)\n\t\t\treturn result;\n\n\t\tif (dev_to_hdlc(dev)->proto != &proto) { /* Different proto */\n\t\t\tresult = attach_hdlc_protocol(dev, &proto,\n\t\t\t\t\t\t      sizeof(struct frad_state));\n\t\t\tif (result)\n\t\t\t\treturn result;\n\t\t\tstate(hdlc)->first_pvc = NULL;\n\t\t\tstate(hdlc)->dce_pvc_count = 0;\n\t\t}\n\t\tmemcpy(&state(hdlc)->settings, &new_settings, size);\n\t\tdev->type = ARPHRD_FRAD;\n\t\treturn 0;\n\n\tcase IF_PROTO_FR_ADD_PVC:\n\tcase IF_PROTO_FR_DEL_PVC:\n\tcase IF_PROTO_FR_ADD_ETH_PVC:\n\tcase IF_PROTO_FR_DEL_ETH_PVC:\n\t\tif (dev_to_hdlc(dev)->proto != &proto) /* Different proto */\n\t\t\treturn -EINVAL;\n\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&pvc, ifr->ifr_settings.ifs_ifsu.fr_pvc,\n\t\t\t\t   sizeof(fr_proto_pvc)))\n\t\t\treturn -EFAULT;\n\n\t\tif (pvc.dlci <= 0 || pvc.dlci >= 1024)\n\t\t\treturn -EINVAL;\t/* Only 10 bits, DLCI 0 reserved */\n\n\t\tif (ifr->ifr_settings.type == IF_PROTO_FR_ADD_ETH_PVC ||\n\t\t    ifr->ifr_settings.type == IF_PROTO_FR_DEL_ETH_PVC)\n\t\t\tresult = ARPHRD_ETHER; /* bridged Ethernet device */\n\t\telse\n\t\t\tresult = ARPHRD_DLCI;\n\n\t\tif (ifr->ifr_settings.type == IF_PROTO_FR_ADD_PVC ||\n\t\t    ifr->ifr_settings.type == IF_PROTO_FR_ADD_ETH_PVC)\n\t\t\treturn fr_add_pvc(dev, pvc.dlci, result);\n\t\telse\n\t\t\treturn fr_del_pvc(hdlc, pvc.dlci, result);\n\t}\n\n\treturn -EINVAL;\n}\n\n\nstatic int __init mod_init(void)\n{\n\tregister_hdlc_protocol(&proto);\n\treturn 0;\n}\n\n\nstatic void __exit mod_exit(void)\n{\n\tunregister_hdlc_protocol(&proto);\n}\n\n\nmodule_init(mod_init);\nmodule_exit(mod_exit);\n\nMODULE_AUTHOR(\"Krzysztof Halasa <khc@pm.waw.pl>\");\nMODULE_DESCRIPTION(\"Frame-Relay protocol support for generic HDLC\");\nMODULE_LICENSE(\"GPL v2\");\n", "/*======================================================================\n\n    Aironet driver for 4500 and 4800 series cards\n\n    This code is released under both the GPL version 2 and BSD licenses.\n    Either license may be used.  The respective licenses are found at\n    the end of this file.\n\n    This code was developed by Benjamin Reed <breed@users.sourceforge.net>\n    including portions of which come from the Aironet PC4500\n    Developer's Reference Manual and used with permission.  Copyright\n    (C) 1999 Benjamin Reed.  All Rights Reserved.  Permission to use\n    code in the Developer's manual was granted for this driver by\n    Aironet.  Major code contributions were received from Javier Achirica\n    <achirica@users.sourceforge.net> and Jean Tourrilhes <jt@hpl.hp.com>.\n    Code was also integrated from the Cisco Aironet driver for Linux.\n    Support for MPI350 cards was added by Fabrice Bellet\n    <fabrice@bellet.info>.\n\n======================================================================*/\n\n#include <linux/err.h>\n#include <linux/init.h>\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\n#include <linux/sched.h>\n#include <linux/ptrace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/interrupt.h>\n#include <linux/in.h>\n#include <linux/bitops.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <asm/io.h>\n#include <asm/system.h>\n#include <asm/unaligned.h>\n\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/if_arp.h>\n#include <linux/ioport.h>\n#include <linux/pci.h>\n#include <asm/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n\n#include <linux/ieee80211.h>\n#include <net/iw_handler.h>\n\n#include \"airo.h\"\n\n#define DRV_NAME \"airo\"\n\n#ifdef CONFIG_PCI\nstatic DEFINE_PCI_DEVICE_TABLE(card_ids) = {\n\t{ 0x14b9, 1, PCI_ANY_ID, PCI_ANY_ID, },\n\t{ 0x14b9, 0x4500, PCI_ANY_ID, PCI_ANY_ID },\n\t{ 0x14b9, 0x4800, PCI_ANY_ID, PCI_ANY_ID, },\n\t{ 0x14b9, 0x0340, PCI_ANY_ID, PCI_ANY_ID, },\n\t{ 0x14b9, 0x0350, PCI_ANY_ID, PCI_ANY_ID, },\n\t{ 0x14b9, 0x5000, PCI_ANY_ID, PCI_ANY_ID, },\n\t{ 0x14b9, 0xa504, PCI_ANY_ID, PCI_ANY_ID, },\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, card_ids);\n\nstatic int airo_pci_probe(struct pci_dev *, const struct pci_device_id *);\nstatic void airo_pci_remove(struct pci_dev *);\nstatic int airo_pci_suspend(struct pci_dev *pdev, pm_message_t state);\nstatic int airo_pci_resume(struct pci_dev *pdev);\n\nstatic struct pci_driver airo_driver = {\n\t.name     = DRV_NAME,\n\t.id_table = card_ids,\n\t.probe    = airo_pci_probe,\n\t.remove   = __devexit_p(airo_pci_remove),\n\t.suspend  = airo_pci_suspend,\n\t.resume   = airo_pci_resume,\n};\n#endif /* CONFIG_PCI */\n\n/* Include Wireless Extension definition and check version - Jean II */\n#include <linux/wireless.h>\n#define WIRELESS_SPY\t\t/* enable iwspy support */\n#include <net/iw_handler.h>\t/* New driver API */\n\n#define CISCO_EXT\t\t/* enable Cisco extensions */\n#ifdef CISCO_EXT\n#include <linux/delay.h>\n#endif\n\n/* Hack to do some power saving */\n#define POWER_ON_DOWN\n\n/* As you can see this list is HUGH!\n   I really don't know what a lot of these counts are about, but they\n   are all here for completeness.  If the IGNLABEL macro is put in\n   infront of the label, that statistic will not be included in the list\n   of statistics in the /proc filesystem */\n\n#define IGNLABEL(comment) NULL\nstatic const char *statsLabels[] = {\n\t\"RxOverrun\",\n\tIGNLABEL(\"RxPlcpCrcErr\"),\n\tIGNLABEL(\"RxPlcpFormatErr\"),\n\tIGNLABEL(\"RxPlcpLengthErr\"),\n\t\"RxMacCrcErr\",\n\t\"RxMacCrcOk\",\n\t\"RxWepErr\",\n\t\"RxWepOk\",\n\t\"RetryLong\",\n\t\"RetryShort\",\n\t\"MaxRetries\",\n\t\"NoAck\",\n\t\"NoCts\",\n\t\"RxAck\",\n\t\"RxCts\",\n\t\"TxAck\",\n\t\"TxRts\",\n\t\"TxCts\",\n\t\"TxMc\",\n\t\"TxBc\",\n\t\"TxUcFrags\",\n\t\"TxUcPackets\",\n\t\"TxBeacon\",\n\t\"RxBeacon\",\n\t\"TxSinColl\",\n\t\"TxMulColl\",\n\t\"DefersNo\",\n\t\"DefersProt\",\n\t\"DefersEngy\",\n\t\"DupFram\",\n\t\"RxFragDisc\",\n\t\"TxAged\",\n\t\"RxAged\",\n\t\"LostSync-MaxRetry\",\n\t\"LostSync-MissedBeacons\",\n\t\"LostSync-ArlExceeded\",\n\t\"LostSync-Deauth\",\n\t\"LostSync-Disassoced\",\n\t\"LostSync-TsfTiming\",\n\t\"HostTxMc\",\n\t\"HostTxBc\",\n\t\"HostTxUc\",\n\t\"HostTxFail\",\n\t\"HostRxMc\",\n\t\"HostRxBc\",\n\t\"HostRxUc\",\n\t\"HostRxDiscard\",\n\tIGNLABEL(\"HmacTxMc\"),\n\tIGNLABEL(\"HmacTxBc\"),\n\tIGNLABEL(\"HmacTxUc\"),\n\tIGNLABEL(\"HmacTxFail\"),\n\tIGNLABEL(\"HmacRxMc\"),\n\tIGNLABEL(\"HmacRxBc\"),\n\tIGNLABEL(\"HmacRxUc\"),\n\tIGNLABEL(\"HmacRxDiscard\"),\n\tIGNLABEL(\"HmacRxAccepted\"),\n\t\"SsidMismatch\",\n\t\"ApMismatch\",\n\t\"RatesMismatch\",\n\t\"AuthReject\",\n\t\"AuthTimeout\",\n\t\"AssocReject\",\n\t\"AssocTimeout\",\n\tIGNLABEL(\"ReasonOutsideTable\"),\n\tIGNLABEL(\"ReasonStatus1\"),\n\tIGNLABEL(\"ReasonStatus2\"),\n\tIGNLABEL(\"ReasonStatus3\"),\n\tIGNLABEL(\"ReasonStatus4\"),\n\tIGNLABEL(\"ReasonStatus5\"),\n\tIGNLABEL(\"ReasonStatus6\"),\n\tIGNLABEL(\"ReasonStatus7\"),\n\tIGNLABEL(\"ReasonStatus8\"),\n\tIGNLABEL(\"ReasonStatus9\"),\n\tIGNLABEL(\"ReasonStatus10\"),\n\tIGNLABEL(\"ReasonStatus11\"),\n\tIGNLABEL(\"ReasonStatus12\"),\n\tIGNLABEL(\"ReasonStatus13\"),\n\tIGNLABEL(\"ReasonStatus14\"),\n\tIGNLABEL(\"ReasonStatus15\"),\n\tIGNLABEL(\"ReasonStatus16\"),\n\tIGNLABEL(\"ReasonStatus17\"),\n\tIGNLABEL(\"ReasonStatus18\"),\n\tIGNLABEL(\"ReasonStatus19\"),\n\t\"RxMan\",\n\t\"TxMan\",\n\t\"RxRefresh\",\n\t\"TxRefresh\",\n\t\"RxPoll\",\n\t\"TxPoll\",\n\t\"HostRetries\",\n\t\"LostSync-HostReq\",\n\t\"HostTxBytes\",\n\t\"HostRxBytes\",\n\t\"ElapsedUsec\",\n\t\"ElapsedSec\",\n\t\"LostSyncBetterAP\",\n\t\"PrivacyMismatch\",\n\t\"Jammed\",\n\t\"DiscRxNotWepped\",\n\t\"PhyEleMismatch\",\n\t(char*)-1 };\n#ifndef RUN_AT\n#define RUN_AT(x) (jiffies+(x))\n#endif\n\n\n/* These variables are for insmod, since it seems that the rates\n   can only be set in setup_card.  Rates should be a comma separated\n   (no spaces) list of rates (up to 8). */\n\nstatic int rates[8];\nstatic char *ssids[3];\n\nstatic int io[4];\nstatic int irq[4];\n\nstatic\nint maxencrypt /* = 0 */; /* The highest rate that the card can encrypt at.\n\t\t       0 means no limit.  For old cards this was 4 */\n\nstatic int auto_wep /* = 0 */; /* If set, it tries to figure out the wep mode */\nstatic int aux_bap /* = 0 */; /* Checks to see if the aux ports are needed to read\n\t\t    the bap, needed on some older cards and buses. */\nstatic int adhoc;\n\nstatic int probe = 1;\n\nstatic int proc_uid /* = 0 */;\n\nstatic int proc_gid /* = 0 */;\n\nstatic int airo_perm = 0555;\n\nstatic int proc_perm = 0644;\n\nMODULE_AUTHOR(\"Benjamin Reed\");\nMODULE_DESCRIPTION(\"Support for Cisco/Aironet 802.11 wireless ethernet cards.  \"\n\t\t   \"Direct support for ISA/PCI/MPI cards and support for PCMCIA when used with airo_cs.\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_SUPPORTED_DEVICE(\"Aironet 4500, 4800 and Cisco 340/350\");\nmodule_param_array(io, int, NULL, 0);\nmodule_param_array(irq, int, NULL, 0);\nmodule_param_array(rates, int, NULL, 0);\nmodule_param_array(ssids, charp, NULL, 0);\nmodule_param(auto_wep, int, 0);\nMODULE_PARM_DESC(auto_wep,\n\t\t \"If non-zero, the driver will keep looping through the authentication options until an association is made.  \"\n\t\t \"The value of auto_wep is number of the wep keys to check.  \"\n\t\t \"A value of 2 will try using the key at index 0 and index 1.\");\nmodule_param(aux_bap, int, 0);\nMODULE_PARM_DESC(aux_bap,\n\t\t \"If non-zero, the driver will switch into a mode that seems to work better for older cards with some older buses.  \"\n\t\t \"Before switching it checks that the switch is needed.\");\nmodule_param(maxencrypt, int, 0);\nMODULE_PARM_DESC(maxencrypt,\n\t\t \"The maximum speed that the card can do encryption.  \"\n\t\t \"Units are in 512kbs.  \"\n\t\t \"Zero (default) means there is no limit.  \"\n\t\t \"Older cards used to be limited to 2mbs (4).\");\nmodule_param(adhoc, int, 0);\nMODULE_PARM_DESC(adhoc, \"If non-zero, the card will start in adhoc mode.\");\nmodule_param(probe, int, 0);\nMODULE_PARM_DESC(probe, \"If zero, the driver won't start the card.\");\n\nmodule_param(proc_uid, int, 0);\nMODULE_PARM_DESC(proc_uid, \"The uid that the /proc files will belong to.\");\nmodule_param(proc_gid, int, 0);\nMODULE_PARM_DESC(proc_gid, \"The gid that the /proc files will belong to.\");\nmodule_param(airo_perm, int, 0);\nMODULE_PARM_DESC(airo_perm, \"The permission bits of /proc/[driver/]aironet.\");\nmodule_param(proc_perm, int, 0);\nMODULE_PARM_DESC(proc_perm, \"The permission bits of the files in /proc\");\n\n/* This is a kind of sloppy hack to get this information to OUT4500 and\n   IN4500.  I would be extremely interested in the situation where this\n   doesn't work though!!! */\nstatic int do8bitIO /* = 0 */;\n\n/* Return codes */\n#define SUCCESS 0\n#define ERROR -1\n#define NO_PACKET -2\n\n/* Commands */\n#define NOP2\t\t0x0000\n#define MAC_ENABLE\t0x0001\n#define MAC_DISABLE\t0x0002\n#define CMD_LOSE_SYNC\t0x0003 /* Not sure what this does... */\n#define CMD_SOFTRESET\t0x0004\n#define HOSTSLEEP\t0x0005\n#define CMD_MAGIC_PKT\t0x0006\n#define CMD_SETWAKEMASK\t0x0007\n#define CMD_READCFG\t0x0008\n#define CMD_SETMODE\t0x0009\n#define CMD_ALLOCATETX\t0x000a\n#define CMD_TRANSMIT\t0x000b\n#define CMD_DEALLOCATETX 0x000c\n#define NOP\t\t0x0010\n#define CMD_WORKAROUND\t0x0011\n#define CMD_ALLOCATEAUX 0x0020\n#define CMD_ACCESS\t0x0021\n#define CMD_PCIBAP\t0x0022\n#define CMD_PCIAUX\t0x0023\n#define CMD_ALLOCBUF\t0x0028\n#define CMD_GETTLV\t0x0029\n#define CMD_PUTTLV\t0x002a\n#define CMD_DELTLV\t0x002b\n#define CMD_FINDNEXTTLV\t0x002c\n#define CMD_PSPNODES\t0x0030\n#define CMD_SETCW\t0x0031    \n#define CMD_SETPCF\t0x0032    \n#define CMD_SETPHYREG\t0x003e\n#define CMD_TXTEST\t0x003f\n#define MAC_ENABLETX\t0x0101\n#define CMD_LISTBSS\t0x0103\n#define CMD_SAVECFG\t0x0108\n#define CMD_ENABLEAUX\t0x0111\n#define CMD_WRITERID\t0x0121\n#define CMD_USEPSPNODES\t0x0130\n#define MAC_ENABLERX\t0x0201\n\n/* Command errors */\n#define ERROR_QUALIF 0x00\n#define ERROR_ILLCMD 0x01\n#define ERROR_ILLFMT 0x02\n#define ERROR_INVFID 0x03\n#define ERROR_INVRID 0x04\n#define ERROR_LARGE 0x05\n#define ERROR_NDISABL 0x06\n#define ERROR_ALLOCBSY 0x07\n#define ERROR_NORD 0x0B\n#define ERROR_NOWR 0x0C\n#define ERROR_INVFIDTX 0x0D\n#define ERROR_TESTACT 0x0E\n#define ERROR_TAGNFND 0x12\n#define ERROR_DECODE 0x20\n#define ERROR_DESCUNAV 0x21\n#define ERROR_BADLEN 0x22\n#define ERROR_MODE 0x80\n#define ERROR_HOP 0x81\n#define ERROR_BINTER 0x82\n#define ERROR_RXMODE 0x83\n#define ERROR_MACADDR 0x84\n#define ERROR_RATES 0x85\n#define ERROR_ORDER 0x86\n#define ERROR_SCAN 0x87\n#define ERROR_AUTH 0x88\n#define ERROR_PSMODE 0x89\n#define ERROR_RTYPE 0x8A\n#define ERROR_DIVER 0x8B\n#define ERROR_SSID 0x8C\n#define ERROR_APLIST 0x8D\n#define ERROR_AUTOWAKE 0x8E\n#define ERROR_LEAP 0x8F\n\n/* Registers */\n#define COMMAND 0x00\n#define PARAM0 0x02\n#define PARAM1 0x04\n#define PARAM2 0x06\n#define STATUS 0x08\n#define RESP0 0x0a\n#define RESP1 0x0c\n#define RESP2 0x0e\n#define LINKSTAT 0x10\n#define SELECT0 0x18\n#define OFFSET0 0x1c\n#define RXFID 0x20\n#define TXALLOCFID 0x22\n#define TXCOMPLFID 0x24\n#define DATA0 0x36\n#define EVSTAT 0x30\n#define EVINTEN 0x32\n#define EVACK 0x34\n#define SWS0 0x28\n#define SWS1 0x2a\n#define SWS2 0x2c\n#define SWS3 0x2e\n#define AUXPAGE 0x3A\n#define AUXOFF 0x3C\n#define AUXDATA 0x3E\n\n#define FID_TX 1\n#define FID_RX 2\n/* Offset into aux memory for descriptors */\n#define AUX_OFFSET 0x800\n/* Size of allocated packets */\n#define PKTSIZE 1840\n#define RIDSIZE 2048\n/* Size of the transmit queue */\n#define MAXTXQ 64\n\n/* BAP selectors */\n#define BAP0 0 /* Used for receiving packets */\n#define BAP1 2 /* Used for xmiting packets and working with RIDS */\n\n/* Flags */\n#define COMMAND_BUSY 0x8000\n\n#define BAP_BUSY 0x8000\n#define BAP_ERR 0x4000\n#define BAP_DONE 0x2000\n\n#define PROMISC 0xffff\n#define NOPROMISC 0x0000\n\n#define EV_CMD 0x10\n#define EV_CLEARCOMMANDBUSY 0x4000\n#define EV_RX 0x01\n#define EV_TX 0x02\n#define EV_TXEXC 0x04\n#define EV_ALLOC 0x08\n#define EV_LINK 0x80\n#define EV_AWAKE 0x100\n#define EV_TXCPY 0x400\n#define EV_UNKNOWN 0x800\n#define EV_MIC 0x1000 /* Message Integrity Check Interrupt */\n#define EV_AWAKEN 0x2000\n#define STATUS_INTS (EV_AWAKE|EV_LINK|EV_TXEXC|EV_TX|EV_TXCPY|EV_RX|EV_MIC)\n\n#ifdef CHECK_UNKNOWN_INTS\n#define IGNORE_INTS ( EV_CMD | EV_UNKNOWN)\n#else\n#define IGNORE_INTS (~STATUS_INTS)\n#endif\n\n/* RID TYPES */\n#define RID_RW 0x20\n\n/* The RIDs */\n#define RID_CAPABILITIES 0xFF00\n#define RID_APINFO     0xFF01\n#define RID_RADIOINFO  0xFF02\n#define RID_UNKNOWN3   0xFF03\n#define RID_RSSI       0xFF04\n#define RID_CONFIG     0xFF10\n#define RID_SSID       0xFF11\n#define RID_APLIST     0xFF12\n#define RID_DRVNAME    0xFF13\n#define RID_ETHERENCAP 0xFF14\n#define RID_WEP_TEMP   0xFF15\n#define RID_WEP_PERM   0xFF16\n#define RID_MODULATION 0xFF17\n#define RID_OPTIONS    0xFF18\n#define RID_ACTUALCONFIG 0xFF20 /*readonly*/\n#define RID_FACTORYCONFIG 0xFF21\n#define RID_UNKNOWN22  0xFF22\n#define RID_LEAPUSERNAME 0xFF23\n#define RID_LEAPPASSWORD 0xFF24\n#define RID_STATUS     0xFF50\n#define RID_BEACON_HST 0xFF51\n#define RID_BUSY_HST   0xFF52\n#define RID_RETRIES_HST 0xFF53\n#define RID_UNKNOWN54  0xFF54\n#define RID_UNKNOWN55  0xFF55\n#define RID_UNKNOWN56  0xFF56\n#define RID_MIC        0xFF57\n#define RID_STATS16    0xFF60\n#define RID_STATS16DELTA 0xFF61\n#define RID_STATS16DELTACLEAR 0xFF62\n#define RID_STATS      0xFF68\n#define RID_STATSDELTA 0xFF69\n#define RID_STATSDELTACLEAR 0xFF6A\n#define RID_ECHOTEST_RID 0xFF70\n#define RID_ECHOTEST_RESULTS 0xFF71\n#define RID_BSSLISTFIRST 0xFF72\n#define RID_BSSLISTNEXT  0xFF73\n#define RID_WPA_BSSLISTFIRST 0xFF74\n#define RID_WPA_BSSLISTNEXT  0xFF75\n\ntypedef struct {\n\tu16 cmd;\n\tu16 parm0;\n\tu16 parm1;\n\tu16 parm2;\n} Cmd;\n\ntypedef struct {\n\tu16 status;\n\tu16 rsp0;\n\tu16 rsp1;\n\tu16 rsp2;\n} Resp;\n\n/*\n * Rids and endian-ness:  The Rids will always be in cpu endian, since\n * this all the patches from the big-endian guys end up doing that.\n * so all rid access should use the read/writeXXXRid routines.\n */\n\n/* This structure came from an email sent to me from an engineer at\n   aironet for inclusion into this driver */\ntypedef struct WepKeyRid WepKeyRid;\nstruct WepKeyRid {\n\t__le16 len;\n\t__le16 kindex;\n\tu8 mac[ETH_ALEN];\n\t__le16 klen;\n\tu8 key[16];\n} __packed;\n\n/* These structures are from the Aironet's PC4500 Developers Manual */\ntypedef struct Ssid Ssid;\nstruct Ssid {\n\t__le16 len;\n\tu8 ssid[32];\n} __packed;\n\ntypedef struct SsidRid SsidRid;\nstruct SsidRid {\n\t__le16 len;\n\tSsid ssids[3];\n} __packed;\n\ntypedef struct ModulationRid ModulationRid;\nstruct ModulationRid {\n        __le16 len;\n        __le16 modulation;\n#define MOD_DEFAULT cpu_to_le16(0)\n#define MOD_CCK cpu_to_le16(1)\n#define MOD_MOK cpu_to_le16(2)\n} __packed;\n\ntypedef struct ConfigRid ConfigRid;\nstruct ConfigRid {\n\t__le16 len; /* sizeof(ConfigRid) */\n\t__le16 opmode; /* operating mode */\n#define MODE_STA_IBSS cpu_to_le16(0)\n#define MODE_STA_ESS cpu_to_le16(1)\n#define MODE_AP cpu_to_le16(2)\n#define MODE_AP_RPTR cpu_to_le16(3)\n#define MODE_CFG_MASK cpu_to_le16(0xff)\n#define MODE_ETHERNET_HOST cpu_to_le16(0<<8) /* rx payloads converted */\n#define MODE_LLC_HOST cpu_to_le16(1<<8) /* rx payloads left as is */\n#define MODE_AIRONET_EXTEND cpu_to_le16(1<<9) /* enable Aironet extenstions */\n#define MODE_AP_INTERFACE cpu_to_le16(1<<10) /* enable ap interface extensions */\n#define MODE_ANTENNA_ALIGN cpu_to_le16(1<<11) /* enable antenna alignment */\n#define MODE_ETHER_LLC cpu_to_le16(1<<12) /* enable ethernet LLC */\n#define MODE_LEAF_NODE cpu_to_le16(1<<13) /* enable leaf node bridge */\n#define MODE_CF_POLLABLE cpu_to_le16(1<<14) /* enable CF pollable */\n#define MODE_MIC cpu_to_le16(1<<15) /* enable MIC */\n\t__le16 rmode; /* receive mode */\n#define RXMODE_BC_MC_ADDR cpu_to_le16(0)\n#define RXMODE_BC_ADDR cpu_to_le16(1) /* ignore multicasts */\n#define RXMODE_ADDR cpu_to_le16(2) /* ignore multicast and broadcast */\n#define RXMODE_RFMON cpu_to_le16(3) /* wireless monitor mode */\n#define RXMODE_RFMON_ANYBSS cpu_to_le16(4)\n#define RXMODE_LANMON cpu_to_le16(5) /* lan style monitor -- data packets only */\n#define RXMODE_MASK cpu_to_le16(255)\n#define RXMODE_DISABLE_802_3_HEADER cpu_to_le16(1<<8) /* disables 802.3 header on rx */\n#define RXMODE_FULL_MASK (RXMODE_MASK | RXMODE_DISABLE_802_3_HEADER)\n#define RXMODE_NORMALIZED_RSSI cpu_to_le16(1<<9) /* return normalized RSSI */\n\t__le16 fragThresh;\n\t__le16 rtsThres;\n\tu8 macAddr[ETH_ALEN];\n\tu8 rates[8];\n\t__le16 shortRetryLimit;\n\t__le16 longRetryLimit;\n\t__le16 txLifetime; /* in kusec */\n\t__le16 rxLifetime; /* in kusec */\n\t__le16 stationary;\n\t__le16 ordering;\n\t__le16 u16deviceType; /* for overriding device type */\n\t__le16 cfpRate;\n\t__le16 cfpDuration;\n\t__le16 _reserved1[3];\n\t/*---------- Scanning/Associating ----------*/\n\t__le16 scanMode;\n#define SCANMODE_ACTIVE cpu_to_le16(0)\n#define SCANMODE_PASSIVE cpu_to_le16(1)\n#define SCANMODE_AIROSCAN cpu_to_le16(2)\n\t__le16 probeDelay; /* in kusec */\n\t__le16 probeEnergyTimeout; /* in kusec */\n        __le16 probeResponseTimeout;\n\t__le16 beaconListenTimeout;\n\t__le16 joinNetTimeout;\n\t__le16 authTimeout;\n\t__le16 authType;\n#define AUTH_OPEN cpu_to_le16(0x1)\n#define AUTH_ENCRYPT cpu_to_le16(0x101)\n#define AUTH_SHAREDKEY cpu_to_le16(0x102)\n#define AUTH_ALLOW_UNENCRYPTED cpu_to_le16(0x200)\n\t__le16 associationTimeout;\n\t__le16 specifiedApTimeout;\n\t__le16 offlineScanInterval;\n\t__le16 offlineScanDuration;\n\t__le16 linkLossDelay;\n\t__le16 maxBeaconLostTime;\n\t__le16 refreshInterval;\n#define DISABLE_REFRESH cpu_to_le16(0xFFFF)\n\t__le16 _reserved1a[1];\n\t/*---------- Power save operation ----------*/\n\t__le16 powerSaveMode;\n#define POWERSAVE_CAM cpu_to_le16(0)\n#define POWERSAVE_PSP cpu_to_le16(1)\n#define POWERSAVE_PSPCAM cpu_to_le16(2)\n\t__le16 sleepForDtims;\n\t__le16 listenInterval;\n\t__le16 fastListenInterval;\n\t__le16 listenDecay;\n\t__le16 fastListenDelay;\n\t__le16 _reserved2[2];\n\t/*---------- Ap/Ibss config items ----------*/\n\t__le16 beaconPeriod;\n\t__le16 atimDuration;\n\t__le16 hopPeriod;\n\t__le16 channelSet;\n\t__le16 channel;\n\t__le16 dtimPeriod;\n\t__le16 bridgeDistance;\n\t__le16 radioID;\n\t/*---------- Radio configuration ----------*/\n\t__le16 radioType;\n#define RADIOTYPE_DEFAULT cpu_to_le16(0)\n#define RADIOTYPE_802_11 cpu_to_le16(1)\n#define RADIOTYPE_LEGACY cpu_to_le16(2)\n\tu8 rxDiversity;\n\tu8 txDiversity;\n\t__le16 txPower;\n#define TXPOWER_DEFAULT 0\n\t__le16 rssiThreshold;\n#define RSSI_DEFAULT 0\n        __le16 modulation;\n#define PREAMBLE_AUTO cpu_to_le16(0)\n#define PREAMBLE_LONG cpu_to_le16(1)\n#define PREAMBLE_SHORT cpu_to_le16(2)\n\t__le16 preamble;\n\t__le16 homeProduct;\n\t__le16 radioSpecific;\n\t/*---------- Aironet Extensions ----------*/\n\tu8 nodeName[16];\n\t__le16 arlThreshold;\n\t__le16 arlDecay;\n\t__le16 arlDelay;\n\t__le16 _reserved4[1];\n\t/*---------- Aironet Extensions ----------*/\n\tu8 magicAction;\n#define MAGIC_ACTION_STSCHG 1\n#define MAGIC_ACTION_RESUME 2\n#define MAGIC_IGNORE_MCAST (1<<8)\n#define MAGIC_IGNORE_BCAST (1<<9)\n#define MAGIC_SWITCH_TO_PSP (0<<10)\n#define MAGIC_STAY_IN_CAM (1<<10)\n\tu8 magicControl;\n\t__le16 autoWake;\n} __packed;\n\ntypedef struct StatusRid StatusRid;\nstruct StatusRid {\n\t__le16 len;\n\tu8 mac[ETH_ALEN];\n\t__le16 mode;\n\t__le16 errorCode;\n\t__le16 sigQuality;\n\t__le16 SSIDlen;\n\tchar SSID[32];\n\tchar apName[16];\n\tu8 bssid[4][ETH_ALEN];\n\t__le16 beaconPeriod;\n\t__le16 dimPeriod;\n\t__le16 atimDuration;\n\t__le16 hopPeriod;\n\t__le16 channelSet;\n\t__le16 channel;\n\t__le16 hopsToBackbone;\n\t__le16 apTotalLoad;\n\t__le16 generatedLoad;\n\t__le16 accumulatedArl;\n\t__le16 signalQuality;\n\t__le16 currentXmitRate;\n\t__le16 apDevExtensions;\n\t__le16 normalizedSignalStrength;\n\t__le16 shortPreamble;\n\tu8 apIP[4];\n\tu8 noisePercent; /* Noise percent in last second */\n\tu8 noisedBm; /* Noise dBm in last second */\n\tu8 noiseAvePercent; /* Noise percent in last minute */\n\tu8 noiseAvedBm; /* Noise dBm in last minute */\n\tu8 noiseMaxPercent; /* Highest noise percent in last minute */\n\tu8 noiseMaxdBm; /* Highest noise dbm in last minute */\n\t__le16 load;\n\tu8 carrier[4];\n\t__le16 assocStatus;\n#define STAT_NOPACKETS 0\n#define STAT_NOCARRIERSET 10\n#define STAT_GOTCARRIERSET 11\n#define STAT_WRONGSSID 20\n#define STAT_BADCHANNEL 25\n#define STAT_BADBITRATES 30\n#define STAT_BADPRIVACY 35\n#define STAT_APFOUND 40\n#define STAT_APREJECTED 50\n#define STAT_AUTHENTICATING 60\n#define STAT_DEAUTHENTICATED 61\n#define STAT_AUTHTIMEOUT 62\n#define STAT_ASSOCIATING 70\n#define STAT_DEASSOCIATED 71\n#define STAT_ASSOCTIMEOUT 72\n#define STAT_NOTAIROAP 73\n#define STAT_ASSOCIATED 80\n#define STAT_LEAPING 90\n#define STAT_LEAPFAILED 91\n#define STAT_LEAPTIMEDOUT 92\n#define STAT_LEAPCOMPLETE 93\n} __packed;\n\ntypedef struct StatsRid StatsRid;\nstruct StatsRid {\n\t__le16 len;\n\t__le16 spacer;\n\t__le32 vals[100];\n} __packed;\n\ntypedef struct APListRid APListRid;\nstruct APListRid {\n\t__le16 len;\n\tu8 ap[4][ETH_ALEN];\n} __packed;\n\ntypedef struct CapabilityRid CapabilityRid;\nstruct CapabilityRid {\n\t__le16 len;\n\tchar oui[3];\n\tchar zero;\n\t__le16 prodNum;\n\tchar manName[32];\n\tchar prodName[16];\n\tchar prodVer[8];\n\tchar factoryAddr[ETH_ALEN];\n\tchar aironetAddr[ETH_ALEN];\n\t__le16 radioType;\n\t__le16 country;\n\tchar callid[ETH_ALEN];\n\tchar supportedRates[8];\n\tchar rxDiversity;\n\tchar txDiversity;\n\t__le16 txPowerLevels[8];\n\t__le16 hardVer;\n\t__le16 hardCap;\n\t__le16 tempRange;\n\t__le16 softVer;\n\t__le16 softSubVer;\n\t__le16 interfaceVer;\n\t__le16 softCap;\n\t__le16 bootBlockVer;\n\t__le16 requiredHard;\n\t__le16 extSoftCap;\n} __packed;\n\n/* Only present on firmware >= 5.30.17 */\ntypedef struct BSSListRidExtra BSSListRidExtra;\nstruct BSSListRidExtra {\n  __le16 unknown[4];\n  u8 fixed[12]; /* WLAN management frame */\n  u8 iep[624];\n} __packed;\n\ntypedef struct BSSListRid BSSListRid;\nstruct BSSListRid {\n  __le16 len;\n  __le16 index; /* First is 0 and 0xffff means end of list */\n#define RADIO_FH 1 /* Frequency hopping radio type */\n#define RADIO_DS 2 /* Direct sequence radio type */\n#define RADIO_TMA 4 /* Proprietary radio used in old cards (2500) */\n  __le16 radioType;\n  u8 bssid[ETH_ALEN]; /* Mac address of the BSS */\n  u8 zero;\n  u8 ssidLen;\n  u8 ssid[32];\n  __le16 dBm;\n#define CAP_ESS cpu_to_le16(1<<0)\n#define CAP_IBSS cpu_to_le16(1<<1)\n#define CAP_PRIVACY cpu_to_le16(1<<4)\n#define CAP_SHORTHDR cpu_to_le16(1<<5)\n  __le16 cap;\n  __le16 beaconInterval;\n  u8 rates[8]; /* Same as rates for config rid */\n  struct { /* For frequency hopping only */\n    __le16 dwell;\n    u8 hopSet;\n    u8 hopPattern;\n    u8 hopIndex;\n    u8 fill;\n  } fh;\n  __le16 dsChannel;\n  __le16 atimWindow;\n\n  /* Only present on firmware >= 5.30.17 */\n  BSSListRidExtra extra;\n} __packed;\n\ntypedef struct {\n  BSSListRid bss;\n  struct list_head list;\n} BSSListElement;\n\ntypedef struct tdsRssiEntry tdsRssiEntry;\nstruct tdsRssiEntry {\n  u8 rssipct;\n  u8 rssidBm;\n} __packed;\n\ntypedef struct tdsRssiRid tdsRssiRid;\nstruct tdsRssiRid {\n  u16 len;\n  tdsRssiEntry x[256];\n} __packed;\n\ntypedef struct MICRid MICRid;\nstruct MICRid {\n\t__le16 len;\n\t__le16 state;\n\t__le16 multicastValid;\n\tu8  multicast[16];\n\t__le16 unicastValid;\n\tu8  unicast[16];\n} __packed;\n\ntypedef struct MICBuffer MICBuffer;\nstruct MICBuffer {\n\t__be16 typelen;\n\n\tunion {\n\t    u8 snap[8];\n\t    struct {\n\t\tu8 dsap;\n\t\tu8 ssap;\n\t\tu8 control;\n\t\tu8 orgcode[3];\n\t\tu8 fieldtype[2];\n\t    } llc;\n\t} u;\n\t__be32 mic;\n\t__be32 seq;\n} __packed;\n\ntypedef struct {\n\tu8 da[ETH_ALEN];\n\tu8 sa[ETH_ALEN];\n} etherHead;\n\n#define TXCTL_TXOK (1<<1) /* report if tx is ok */\n#define TXCTL_TXEX (1<<2) /* report if tx fails */\n#define TXCTL_802_3 (0<<3) /* 802.3 packet */\n#define TXCTL_802_11 (1<<3) /* 802.11 mac packet */\n#define TXCTL_ETHERNET (0<<4) /* payload has ethertype */\n#define TXCTL_LLC (1<<4) /* payload is llc */\n#define TXCTL_RELEASE (0<<5) /* release after completion */\n#define TXCTL_NORELEASE (1<<5) /* on completion returns to host */\n\n#define BUSY_FID 0x10000\n\n#ifdef CISCO_EXT\n#define AIROMAGIC\t0xa55a\n/* Warning : SIOCDEVPRIVATE may disapear during 2.5.X - Jean II */\n#ifdef SIOCIWFIRSTPRIV\n#ifdef SIOCDEVPRIVATE\n#define AIROOLDIOCTL\tSIOCDEVPRIVATE\n#define AIROOLDIDIFC \tAIROOLDIOCTL + 1\n#endif /* SIOCDEVPRIVATE */\n#else /* SIOCIWFIRSTPRIV */\n#define SIOCIWFIRSTPRIV SIOCDEVPRIVATE\n#endif /* SIOCIWFIRSTPRIV */\n/* This may be wrong. When using the new SIOCIWFIRSTPRIV range, we probably\n * should use only \"GET\" ioctls (last bit set to 1). \"SET\" ioctls are root\n * only and don't return the modified struct ifreq to the application which\n * is usually a problem. - Jean II */\n#define AIROIOCTL\tSIOCIWFIRSTPRIV\n#define AIROIDIFC \tAIROIOCTL + 1\n\n/* Ioctl constants to be used in airo_ioctl.command */\n\n#define\tAIROGCAP  \t\t0\t// Capability rid\n#define AIROGCFG\t\t1       // USED A LOT\n#define AIROGSLIST\t\t2\t// System ID list\n#define AIROGVLIST\t\t3       // List of specified AP's\n#define AIROGDRVNAM\t\t4\t//  NOTUSED\n#define AIROGEHTENC\t\t5\t// NOTUSED\n#define AIROGWEPKTMP\t\t6\n#define AIROGWEPKNV\t\t7\n#define AIROGSTAT\t\t8\n#define AIROGSTATSC32\t\t9\n#define AIROGSTATSD32\t\t10\n#define AIROGMICRID\t\t11\n#define AIROGMICSTATS\t\t12\n#define AIROGFLAGS\t\t13\n#define AIROGID\t\t\t14\n#define AIRORRID\t\t15\n#define AIRORSWVERSION\t\t17\n\n/* Leave gap of 40 commands after AIROGSTATSD32 for future */\n\n#define AIROPCAP               \tAIROGSTATSD32 + 40\n#define AIROPVLIST              AIROPCAP      + 1\n#define AIROPSLIST\t\tAIROPVLIST    + 1\n#define AIROPCFG\t\tAIROPSLIST    + 1\n#define AIROPSIDS\t\tAIROPCFG      + 1\n#define AIROPAPLIST\t\tAIROPSIDS     + 1\n#define AIROPMACON\t\tAIROPAPLIST   + 1\t/* Enable mac  */\n#define AIROPMACOFF\t\tAIROPMACON    + 1 \t/* Disable mac */\n#define AIROPSTCLR\t\tAIROPMACOFF   + 1\n#define AIROPWEPKEY\t\tAIROPSTCLR    + 1\n#define AIROPWEPKEYNV\t\tAIROPWEPKEY   + 1\n#define AIROPLEAPPWD            AIROPWEPKEYNV + 1\n#define AIROPLEAPUSR            AIROPLEAPPWD  + 1\n\n/* Flash codes */\n\n#define AIROFLSHRST\t       AIROPWEPKEYNV  + 40\n#define AIROFLSHGCHR           AIROFLSHRST    + 1\n#define AIROFLSHSTFL           AIROFLSHGCHR   + 1\n#define AIROFLSHPCHR           AIROFLSHSTFL   + 1\n#define AIROFLPUTBUF           AIROFLSHPCHR   + 1\n#define AIRORESTART            AIROFLPUTBUF   + 1\n\n#define FLASHSIZE\t32768\n#define AUXMEMSIZE\t(256 * 1024)\n\ntypedef struct aironet_ioctl {\n\tunsigned short command;\t\t// What to do\n\tunsigned short len;\t\t// Len of data\n\tunsigned short ridnum;\t\t// rid number\n\tunsigned char __user *data;\t// d-data\n} aironet_ioctl;\n\nstatic const char swversion[] = \"2.1\";\n#endif /* CISCO_EXT */\n\n#define NUM_MODULES       2\n#define MIC_MSGLEN_MAX    2400\n#define EMMH32_MSGLEN_MAX MIC_MSGLEN_MAX\n#define AIRO_DEF_MTU      2312\n\ntypedef struct {\n\tu32   size;            // size\n\tu8    enabled;         // MIC enabled or not\n\tu32   rxSuccess;       // successful packets received\n\tu32   rxIncorrectMIC;  // pkts dropped due to incorrect MIC comparison\n\tu32   rxNotMICed;      // pkts dropped due to not being MIC'd\n\tu32   rxMICPlummed;    // pkts dropped due to not having a MIC plummed\n\tu32   rxWrongSequence; // pkts dropped due to sequence number violation\n\tu32   reserve[32];\n} mic_statistics;\n\ntypedef struct {\n\tu32 coeff[((EMMH32_MSGLEN_MAX)+3)>>2];\n\tu64 accum;\t// accumulated mic, reduced to u32 in final()\n\tint position;\t// current position (byte offset) in message\n\tunion {\n\t\tu8  d8[4];\n\t\t__be32 d32;\n\t} part;\t// saves partial message word across update() calls\n} emmh32_context;\n\ntypedef struct {\n\temmh32_context seed;\t    // Context - the seed\n\tu32\t\t rx;\t    // Received sequence number\n\tu32\t\t tx;\t    // Tx sequence number\n\tu32\t\t window;    // Start of window\n\tu8\t\t valid;\t    // Flag to say if context is valid or not\n\tu8\t\t key[16];\n} miccntx;\n\ntypedef struct {\n\tmiccntx mCtx;\t\t// Multicast context\n\tmiccntx uCtx;\t\t// Unicast context\n} mic_module;\n\ntypedef struct {\n\tunsigned int  rid: 16;\n\tunsigned int  len: 15;\n\tunsigned int  valid: 1;\n\tdma_addr_t host_addr;\n} Rid;\n\ntypedef struct {\n\tunsigned int  offset: 15;\n\tunsigned int  eoc: 1;\n\tunsigned int  len: 15;\n\tunsigned int  valid: 1;\n\tdma_addr_t host_addr;\n} TxFid;\n\nstruct rx_hdr {\n\t__le16 status, len;\n\tu8 rssi[2];\n\tu8 rate;\n\tu8 freq;\n\t__le16 tmp[4];\n} __packed;\n\ntypedef struct {\n\tunsigned int  ctl: 15;\n\tunsigned int  rdy: 1;\n\tunsigned int  len: 15;\n\tunsigned int  valid: 1;\n\tdma_addr_t host_addr;\n} RxFid;\n\n/*\n * Host receive descriptor\n */\ntypedef struct {\n\tunsigned char __iomem *card_ram_off; /* offset into card memory of the\n\t\t\t\t\t\tdesc */\n\tRxFid         rx_desc;\t\t     /* card receive descriptor */\n\tchar          *virtual_host_addr;    /* virtual address of host receive\n\t\t\t\t\t        buffer */\n\tint           pending;\n} HostRxDesc;\n\n/*\n * Host transmit descriptor\n */\ntypedef struct {\n\tunsigned char __iomem *card_ram_off;\t     /* offset into card memory of the\n\t\t\t\t\t\tdesc */\n\tTxFid         tx_desc;\t\t     /* card transmit descriptor */\n\tchar          *virtual_host_addr;    /* virtual address of host receive\n\t\t\t\t\t        buffer */\n\tint           pending;\n} HostTxDesc;\n\n/*\n * Host RID descriptor\n */\ntypedef struct {\n\tunsigned char __iomem *card_ram_off;      /* offset into card memory of the\n\t\t\t\t\t     descriptor */\n\tRid           rid_desc;\t\t  /* card RID descriptor */\n\tchar          *virtual_host_addr; /* virtual address of host receive\n\t\t\t\t\t     buffer */\n} HostRidDesc;\n\ntypedef struct {\n\tu16 sw0;\n\tu16 sw1;\n\tu16 status;\n\tu16 len;\n#define HOST_SET (1 << 0)\n#define HOST_INT_TX (1 << 1) /* Interrupt on successful TX */\n#define HOST_INT_TXERR (1 << 2) /* Interrupt on unseccessful TX */\n#define HOST_LCC_PAYLOAD (1 << 4) /* LLC payload, 0 = Ethertype */\n#define HOST_DONT_RLSE (1 << 5) /* Don't release buffer when done */\n#define HOST_DONT_RETRY (1 << 6) /* Don't retry trasmit */\n#define HOST_CLR_AID (1 << 7) /* clear AID failure */\n#define HOST_RTS (1 << 9) /* Force RTS use */\n#define HOST_SHORT (1 << 10) /* Do short preamble */\n\tu16 ctl;\n\tu16 aid;\n\tu16 retries;\n\tu16 fill;\n} TxCtlHdr;\n\ntypedef struct {\n        u16 ctl;\n        u16 duration;\n        char addr1[6];\n        char addr2[6];\n        char addr3[6];\n        u16 seq;\n        char addr4[6];\n} WifiHdr;\n\n\ntypedef struct {\n\tTxCtlHdr ctlhdr;\n\tu16 fill1;\n\tu16 fill2;\n\tWifiHdr wifihdr;\n\tu16 gaplen;\n\tu16 status;\n} WifiCtlHdr;\n\nstatic WifiCtlHdr wifictlhdr8023 = {\n\t.ctlhdr = {\n\t\t.ctl\t= HOST_DONT_RLSE,\n\t}\n};\n\n// A few details needed for WEP (Wireless Equivalent Privacy)\n#define MAX_KEY_SIZE 13\t\t\t// 128 (?) bits\n#define MIN_KEY_SIZE  5\t\t\t// 40 bits RC4 - WEP\ntypedef struct wep_key_t {\n\tu16\tlen;\n\tu8\tkey[16];\t/* 40-bit and 104-bit keys */\n} wep_key_t;\n\n/* List of Wireless Handlers (new API) */\nstatic const struct iw_handler_def\tairo_handler_def;\n\nstatic const char version[] = \"airo.c 0.6 (Ben Reed & Javier Achirica)\";\n\nstruct airo_info;\n\nstatic int get_dec_u16( char *buffer, int *start, int limit );\nstatic void OUT4500( struct airo_info *, u16 register, u16 value );\nstatic unsigned short IN4500( struct airo_info *, u16 register );\nstatic u16 setup_card(struct airo_info*, u8 *mac, int lock);\nstatic int enable_MAC(struct airo_info *ai, int lock);\nstatic void disable_MAC(struct airo_info *ai, int lock);\nstatic void enable_interrupts(struct airo_info*);\nstatic void disable_interrupts(struct airo_info*);\nstatic u16 issuecommand(struct airo_info*, Cmd *pCmd, Resp *pRsp);\nstatic int bap_setup(struct airo_info*, u16 rid, u16 offset, int whichbap);\nstatic int aux_bap_read(struct airo_info*, __le16 *pu16Dst, int bytelen,\n\t\t\tint whichbap);\nstatic int fast_bap_read(struct airo_info*, __le16 *pu16Dst, int bytelen,\n\t\t\t int whichbap);\nstatic int bap_write(struct airo_info*, const __le16 *pu16Src, int bytelen,\n\t\t     int whichbap);\nstatic int PC4500_accessrid(struct airo_info*, u16 rid, u16 accmd);\nstatic int PC4500_readrid(struct airo_info*, u16 rid, void *pBuf, int len, int lock);\nstatic int PC4500_writerid(struct airo_info*, u16 rid, const void\n\t\t\t   *pBuf, int len, int lock);\nstatic int do_writerid( struct airo_info*, u16 rid, const void *rid_data,\n\t\t\tint len, int dummy );\nstatic u16 transmit_allocate(struct airo_info*, int lenPayload, int raw);\nstatic int transmit_802_3_packet(struct airo_info*, int len, char *pPacket);\nstatic int transmit_802_11_packet(struct airo_info*, int len, char *pPacket);\n\nstatic int mpi_send_packet (struct net_device *dev);\nstatic void mpi_unmap_card(struct pci_dev *pci);\nstatic void mpi_receive_802_3(struct airo_info *ai);\nstatic void mpi_receive_802_11(struct airo_info *ai);\nstatic int waitbusy (struct airo_info *ai);\n\nstatic irqreturn_t airo_interrupt( int irq, void* dev_id);\nstatic int airo_thread(void *data);\nstatic void timer_func( struct net_device *dev );\nstatic int airo_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);\nstatic struct iw_statistics *airo_get_wireless_stats (struct net_device *dev);\nstatic void airo_read_wireless_stats (struct airo_info *local);\n#ifdef CISCO_EXT\nstatic int readrids(struct net_device *dev, aironet_ioctl *comp);\nstatic int writerids(struct net_device *dev, aironet_ioctl *comp);\nstatic int flashcard(struct net_device *dev, aironet_ioctl *comp);\n#endif /* CISCO_EXT */\nstatic void micinit(struct airo_info *ai);\nstatic int micsetup(struct airo_info *ai);\nstatic int encapsulate(struct airo_info *ai, etherHead *pPacket, MICBuffer *buffer, int len);\nstatic int decapsulate(struct airo_info *ai, MICBuffer *mic, etherHead *pPacket, u16 payLen);\n\nstatic u8 airo_rssi_to_dbm (tdsRssiEntry *rssi_rid, u8 rssi);\nstatic u8 airo_dbm_to_pct (tdsRssiEntry *rssi_rid, u8 dbm);\n\nstatic void airo_networks_free(struct airo_info *ai);\n\nstruct airo_info {\n\tstruct net_device             *dev;\n\tstruct list_head              dev_list;\n\t/* Note, we can have MAX_FIDS outstanding.  FIDs are 16-bits, so we\n\t   use the high bit to mark whether it is in use. */\n#define MAX_FIDS 6\n#define MPI_MAX_FIDS 1\n\tu32                           fids[MAX_FIDS];\n\tConfigRid config;\n\tchar keyindex; // Used with auto wep\n\tchar defindex; // Used with auto wep\n\tstruct proc_dir_entry *proc_entry;\n        spinlock_t aux_lock;\n#define FLAG_RADIO_OFF\t0\t/* User disabling of MAC */\n#define FLAG_RADIO_DOWN\t1\t/* ifup/ifdown disabling of MAC */\n#define FLAG_RADIO_MASK 0x03\n#define FLAG_ENABLED\t2\n#define FLAG_ADHOC\t3\t/* Needed by MIC */\n#define FLAG_MIC_CAPABLE 4\n#define FLAG_UPDATE_MULTI 5\n#define FLAG_UPDATE_UNI 6\n#define FLAG_802_11\t7\n#define FLAG_PROMISC\t8\t/* IFF_PROMISC 0x100 - include/linux/if.h */\n#define FLAG_PENDING_XMIT 9\n#define FLAG_PENDING_XMIT11 10\n#define FLAG_MPI\t11\n#define FLAG_REGISTERED\t12\n#define FLAG_COMMIT\t13\n#define FLAG_RESET\t14\n#define FLAG_FLASHING\t15\n#define FLAG_WPA_CAPABLE\t16\n\tunsigned long flags;\n#define JOB_DIE\t0\n#define JOB_XMIT\t1\n#define JOB_XMIT11\t2\n#define JOB_STATS\t3\n#define JOB_PROMISC\t4\n#define JOB_MIC\t5\n#define JOB_EVENT\t6\n#define JOB_AUTOWEP\t7\n#define JOB_WSTATS\t8\n#define JOB_SCAN_RESULTS  9\n\tunsigned long jobs;\n\tint (*bap_read)(struct airo_info*, __le16 *pu16Dst, int bytelen,\n\t\t\tint whichbap);\n\tunsigned short *flash;\n\ttdsRssiEntry *rssi;\n\tstruct task_struct *list_bss_task;\n\tstruct task_struct *airo_thread_task;\n\tstruct semaphore sem;\n\twait_queue_head_t thr_wait;\n\tunsigned long expires;\n\tstruct {\n\t\tstruct sk_buff *skb;\n\t\tint fid;\n\t} xmit, xmit11;\n\tstruct net_device *wifidev;\n\tstruct iw_statistics\twstats;\t\t// wireless stats\n\tunsigned long\t\tscan_timeout;\t/* Time scan should be read */\n\tstruct iw_spy_data\tspy_data;\n\tstruct iw_public_data\twireless_data;\n\t/* MIC stuff */\n\tstruct crypto_cipher\t*tfm;\n\tmic_module\t\tmod[2];\n\tmic_statistics\t\tmicstats;\n\tHostRxDesc rxfids[MPI_MAX_FIDS]; // rx/tx/config MPI350 descriptors\n\tHostTxDesc txfids[MPI_MAX_FIDS];\n\tHostRidDesc config_desc;\n\tunsigned long ridbus; // phys addr of config_desc\n\tstruct sk_buff_head txq;// tx queue used by mpi350 code\n\tstruct pci_dev          *pci;\n\tunsigned char\t\t__iomem *pcimem;\n\tunsigned char\t\t__iomem *pciaux;\n\tunsigned char\t\t*shared;\n\tdma_addr_t\t\tshared_dma;\n\tpm_message_t\t\tpower;\n\tSsidRid\t\t\t*SSID;\n\tAPListRid\t\t*APList;\n#define\tPCI_SHARED_LEN\t\t2*MPI_MAX_FIDS*PKTSIZE+RIDSIZE\n\tchar\t\t\tproc_name[IFNAMSIZ];\n\n\tint\t\t\twep_capable;\n\tint\t\t\tmax_wep_idx;\n\n\t/* WPA-related stuff */\n\tunsigned int bssListFirst;\n\tunsigned int bssListNext;\n\tunsigned int bssListRidLen;\n\n\tstruct list_head network_list;\n\tstruct list_head network_free_list;\n\tBSSListElement *networks;\n};\n\nstatic inline int bap_read(struct airo_info *ai, __le16 *pu16Dst, int bytelen,\n\t\t\t   int whichbap)\n{\n\treturn ai->bap_read(ai, pu16Dst, bytelen, whichbap);\n}\n\nstatic int setup_proc_entry( struct net_device *dev,\n\t\t\t     struct airo_info *apriv );\nstatic int takedown_proc_entry( struct net_device *dev,\n\t\t\t\tstruct airo_info *apriv );\n\nstatic int cmdreset(struct airo_info *ai);\nstatic int setflashmode (struct airo_info *ai);\nstatic int flashgchar(struct airo_info *ai,int matchbyte,int dwelltime);\nstatic int flashputbuf(struct airo_info *ai);\nstatic int flashrestart(struct airo_info *ai,struct net_device *dev);\n\n#define airo_print(type, name, fmt, args...) \\\n\tprintk(type DRV_NAME \"(%s): \" fmt \"\\n\", name, ##args)\n\n#define airo_print_info(name, fmt, args...) \\\n\tairo_print(KERN_INFO, name, fmt, ##args)\n\n#define airo_print_dbg(name, fmt, args...) \\\n\tairo_print(KERN_DEBUG, name, fmt, ##args)\n\n#define airo_print_warn(name, fmt, args...) \\\n\tairo_print(KERN_WARNING, name, fmt, ##args)\n\n#define airo_print_err(name, fmt, args...) \\\n\tairo_print(KERN_ERR, name, fmt, ##args)\n\n#define AIRO_FLASH(dev) (((struct airo_info *)dev->ml_priv)->flash)\n\n/***********************************************************************\n *                              MIC ROUTINES                           *\n ***********************************************************************\n */\n\nstatic int RxSeqValid (struct airo_info *ai,miccntx *context,int mcast,u32 micSeq);\nstatic void MoveWindow(miccntx *context, u32 micSeq);\nstatic void emmh32_setseed(emmh32_context *context, u8 *pkey, int keylen,\n\t\t\t   struct crypto_cipher *tfm);\nstatic void emmh32_init(emmh32_context *context);\nstatic void emmh32_update(emmh32_context *context, u8 *pOctets, int len);\nstatic void emmh32_final(emmh32_context *context, u8 digest[4]);\nstatic int flashpchar(struct airo_info *ai,int byte,int dwelltime);\n\nstatic void age_mic_context(miccntx *cur, miccntx *old, u8 *key, int key_len,\n\t\t\t    struct crypto_cipher *tfm)\n{\n\t/* If the current MIC context is valid and its key is the same as\n\t * the MIC register, there's nothing to do.\n\t */\n\tif (cur->valid && (memcmp(cur->key, key, key_len) == 0))\n\t\treturn;\n\n\t/* Age current mic Context */\n\tmemcpy(old, cur, sizeof(*cur));\n\n\t/* Initialize new context */\n\tmemcpy(cur->key, key, key_len);\n\tcur->window  = 33; /* Window always points to the middle */\n\tcur->rx      = 0;  /* Rx Sequence numbers */\n\tcur->tx      = 0;  /* Tx sequence numbers */\n\tcur->valid   = 1;  /* Key is now valid */\n\n\t/* Give key to mic seed */\n\temmh32_setseed(&cur->seed, key, key_len, tfm);\n}\n\n/* micinit - Initialize mic seed */\n\nstatic void micinit(struct airo_info *ai)\n{\n\tMICRid mic_rid;\n\n\tclear_bit(JOB_MIC, &ai->jobs);\n\tPC4500_readrid(ai, RID_MIC, &mic_rid, sizeof(mic_rid), 0);\n\tup(&ai->sem);\n\n\tai->micstats.enabled = (le16_to_cpu(mic_rid.state) & 0x00FF) ? 1 : 0;\n\tif (!ai->micstats.enabled) {\n\t\t/* So next time we have a valid key and mic is enabled, we will\n\t\t * update the sequence number if the key is the same as before.\n\t\t */\n\t\tai->mod[0].uCtx.valid = 0;\n\t\tai->mod[0].mCtx.valid = 0;\n\t\treturn;\n\t}\n\n\tif (mic_rid.multicastValid) {\n\t\tage_mic_context(&ai->mod[0].mCtx, &ai->mod[1].mCtx,\n\t\t                mic_rid.multicast, sizeof(mic_rid.multicast),\n\t\t                ai->tfm);\n\t}\n\n\tif (mic_rid.unicastValid) {\n\t\tage_mic_context(&ai->mod[0].uCtx, &ai->mod[1].uCtx,\n\t\t\t\tmic_rid.unicast, sizeof(mic_rid.unicast),\n\t\t\t\tai->tfm);\n\t}\n}\n\n/* micsetup - Get ready for business */\n\nstatic int micsetup(struct airo_info *ai) {\n\tint i;\n\n\tif (ai->tfm == NULL)\n\t        ai->tfm = crypto_alloc_cipher(\"aes\", 0, CRYPTO_ALG_ASYNC);\n\n        if (IS_ERR(ai->tfm)) {\n                airo_print_err(ai->dev->name, \"failed to load transform for AES\");\n                ai->tfm = NULL;\n                return ERROR;\n        }\n\n\tfor (i=0; i < NUM_MODULES; i++) {\n\t\tmemset(&ai->mod[i].mCtx,0,sizeof(miccntx));\n\t\tmemset(&ai->mod[i].uCtx,0,sizeof(miccntx));\n\t}\n\treturn SUCCESS;\n}\n\nstatic const u8 micsnap[] = {0xAA,0xAA,0x03,0x00,0x40,0x96,0x00,0x02};\n\n/*===========================================================================\n * Description: Mic a packet\n *    \n *      Inputs: etherHead * pointer to an 802.3 frame\n *    \n *     Returns: BOOLEAN if successful, otherwise false.\n *             PacketTxLen will be updated with the mic'd packets size.\n *\n *    Caveats: It is assumed that the frame buffer will already\n *             be big enough to hold the largets mic message possible.\n *            (No memory allocation is done here).\n *  \n *    Author: sbraneky (10/15/01)\n *    Merciless hacks by rwilcher (1/14/02)\n */\n\nstatic int encapsulate(struct airo_info *ai ,etherHead *frame, MICBuffer *mic, int payLen)\n{\n\tmiccntx   *context;\n\n\t// Determine correct context\n\t// If not adhoc, always use unicast key\n\n\tif (test_bit(FLAG_ADHOC, &ai->flags) && (frame->da[0] & 0x1))\n\t\tcontext = &ai->mod[0].mCtx;\n\telse\n\t\tcontext = &ai->mod[0].uCtx;\n  \n\tif (!context->valid)\n\t\treturn ERROR;\n\n\tmic->typelen = htons(payLen + 16); //Length of Mic'd packet\n\n\tmemcpy(&mic->u.snap, micsnap, sizeof(micsnap)); // Add Snap\n\n\t// Add Tx sequence\n\tmic->seq = htonl(context->tx);\n\tcontext->tx += 2;\n\n\temmh32_init(&context->seed); // Mic the packet\n\temmh32_update(&context->seed,frame->da,ETH_ALEN * 2); // DA,SA\n\temmh32_update(&context->seed,(u8*)&mic->typelen,10); // Type/Length and Snap\n\temmh32_update(&context->seed,(u8*)&mic->seq,sizeof(mic->seq)); //SEQ\n\temmh32_update(&context->seed,frame->da + ETH_ALEN * 2,payLen); //payload\n\temmh32_final(&context->seed, (u8*)&mic->mic);\n\n\t/*    New Type/length ?????????? */\n\tmic->typelen = 0; //Let NIC know it could be an oversized packet\n\treturn SUCCESS;\n}\n\ntypedef enum {\n    NONE,\n    NOMIC,\n    NOMICPLUMMED,\n    SEQUENCE,\n    INCORRECTMIC,\n} mic_error;\n\n/*===========================================================================\n *  Description: Decapsulates a MIC'd packet and returns the 802.3 packet\n *               (removes the MIC stuff) if packet is a valid packet.\n *      \n *       Inputs: etherHead  pointer to the 802.3 packet             \n *     \n *      Returns: BOOLEAN - TRUE if packet should be dropped otherwise FALSE\n *     \n *      Author: sbraneky (10/15/01)\n *    Merciless hacks by rwilcher (1/14/02)\n *---------------------------------------------------------------------------\n */\n\nstatic int decapsulate(struct airo_info *ai, MICBuffer *mic, etherHead *eth, u16 payLen)\n{\n\tint      i;\n\tu32      micSEQ;\n\tmiccntx  *context;\n\tu8       digest[4];\n\tmic_error micError = NONE;\n\n\t// Check if the packet is a Mic'd packet\n\n\tif (!ai->micstats.enabled) {\n\t\t//No Mic set or Mic OFF but we received a MIC'd packet.\n\t\tif (memcmp ((u8*)eth + 14, micsnap, sizeof(micsnap)) == 0) {\n\t\t\tai->micstats.rxMICPlummed++;\n\t\t\treturn ERROR;\n\t\t}\n\t\treturn SUCCESS;\n\t}\n\n\tif (ntohs(mic->typelen) == 0x888E)\n\t\treturn SUCCESS;\n\n\tif (memcmp (mic->u.snap, micsnap, sizeof(micsnap)) != 0) {\n\t    // Mic enabled but packet isn't Mic'd\n\t\tai->micstats.rxMICPlummed++;\n\t    \treturn ERROR;\n\t}\n\n\tmicSEQ = ntohl(mic->seq);            //store SEQ as CPU order\n\n\t//At this point we a have a mic'd packet and mic is enabled\n\t//Now do the mic error checking.\n\n\t//Receive seq must be odd\n\tif ( (micSEQ & 1) == 0 ) {\n\t\tai->micstats.rxWrongSequence++;\n\t\treturn ERROR;\n\t}\n\n\tfor (i = 0; i < NUM_MODULES; i++) {\n\t\tint mcast = eth->da[0] & 1;\n\t\t//Determine proper context \n\t\tcontext = mcast ? &ai->mod[i].mCtx : &ai->mod[i].uCtx;\n\t\n\t\t//Make sure context is valid\n\t\tif (!context->valid) {\n\t\t\tif (i == 0)\n\t\t\t\tmicError = NOMICPLUMMED;\n\t\t\tcontinue;                \n\t\t}\n\t       \t//DeMic it \n\n\t\tif (!mic->typelen)\n\t\t\tmic->typelen = htons(payLen + sizeof(MICBuffer) - 2);\n\t\n\t\temmh32_init(&context->seed);\n\t\temmh32_update(&context->seed, eth->da, ETH_ALEN*2); \n\t\temmh32_update(&context->seed, (u8 *)&mic->typelen, sizeof(mic->typelen)+sizeof(mic->u.snap)); \n\t\temmh32_update(&context->seed, (u8 *)&mic->seq,sizeof(mic->seq));\t\n\t\temmh32_update(&context->seed, eth->da + ETH_ALEN*2,payLen);\t\n\t\t//Calculate MIC\n\t\temmh32_final(&context->seed, digest);\n\t\n\t\tif (memcmp(digest, &mic->mic, 4)) { //Make sure the mics match\n\t\t  //Invalid Mic\n\t\t\tif (i == 0)\n\t\t\t\tmicError = INCORRECTMIC;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//Check Sequence number if mics pass\n\t\tif (RxSeqValid(ai, context, mcast, micSEQ) == SUCCESS) {\n\t\t\tai->micstats.rxSuccess++;\n\t\t\treturn SUCCESS;\n\t\t}\n\t\tif (i == 0)\n\t\t\tmicError = SEQUENCE;\n\t}\n\n\t// Update statistics\n\tswitch (micError) {\n\t\tcase NOMICPLUMMED: ai->micstats.rxMICPlummed++;   break;\n\t\tcase SEQUENCE:    ai->micstats.rxWrongSequence++; break;\n\t\tcase INCORRECTMIC: ai->micstats.rxIncorrectMIC++; break;\n\t\tcase NONE:  break;\n\t\tcase NOMIC: break;\n\t}\n\treturn ERROR;\n}\n\n/*===========================================================================\n * Description:  Checks the Rx Seq number to make sure it is valid\n *               and hasn't already been received\n *   \n *     Inputs: miccntx - mic context to check seq against\n *             micSeq  - the Mic seq number\n *   \n *    Returns: TRUE if valid otherwise FALSE. \n *\n *    Author: sbraneky (10/15/01)\n *    Merciless hacks by rwilcher (1/14/02)\n *---------------------------------------------------------------------------\n */\n\nstatic int RxSeqValid (struct airo_info *ai,miccntx *context,int mcast,u32 micSeq)\n{\n\tu32 seq,index;\n\n\t//Allow for the ap being rebooted - if it is then use the next \n\t//sequence number of the current sequence number - might go backwards\n\n\tif (mcast) {\n\t\tif (test_bit(FLAG_UPDATE_MULTI, &ai->flags)) {\n\t\t\tclear_bit (FLAG_UPDATE_MULTI, &ai->flags);\n\t\t\tcontext->window = (micSeq > 33) ? micSeq : 33;\n\t\t\tcontext->rx     = 0;        // Reset rx\n\t\t}\n\t} else if (test_bit(FLAG_UPDATE_UNI, &ai->flags)) {\n\t\tclear_bit (FLAG_UPDATE_UNI, &ai->flags);\n\t\tcontext->window = (micSeq > 33) ? micSeq : 33; // Move window\n\t\tcontext->rx     = 0;        // Reset rx\n\t}\n\n\t//Make sequence number relative to START of window\n\tseq = micSeq - (context->window - 33);\n\n\t//Too old of a SEQ number to check.\n\tif ((s32)seq < 0)\n\t\treturn ERROR;\n    \n\tif ( seq > 64 ) {\n\t\t//Window is infinite forward\n\t\tMoveWindow(context,micSeq);\n\t\treturn SUCCESS;\n\t}\n\n\t// We are in the window. Now check the context rx bit to see if it was already sent\n\tseq >>= 1;         //divide by 2 because we only have odd numbers\n\tindex = 1 << seq;  //Get an index number\n\n\tif (!(context->rx & index)) {\n\t\t//micSEQ falls inside the window.\n\t\t//Add seqence number to the list of received numbers.\n\t\tcontext->rx |= index;\n\n\t\tMoveWindow(context,micSeq);\n\n\t\treturn SUCCESS;\n\t}\n\treturn ERROR;\n}\n\nstatic void MoveWindow(miccntx *context, u32 micSeq)\n{\n\tu32 shift;\n\n\t//Move window if seq greater than the middle of the window\n\tif (micSeq > context->window) {\n\t\tshift = (micSeq - context->window) >> 1;\n    \n\t\t    //Shift out old\n\t\tif (shift < 32)\n\t\t\tcontext->rx >>= shift;\n\t\telse\n\t\t\tcontext->rx = 0;\n\n\t\tcontext->window = micSeq;      //Move window\n\t}\n}\n\n/*==============================================*/\n/*========== EMMH ROUTINES  ====================*/\n/*==============================================*/\n\n/* mic accumulate */\n#define MIC_ACCUM(val)\t\\\n\tcontext->accum += (u64)(val) * context->coeff[coeff_position++];\n\nstatic unsigned char aes_counter[16];\n\n/* expand the key to fill the MMH coefficient array */\nstatic void emmh32_setseed(emmh32_context *context, u8 *pkey, int keylen,\n\t\t\t   struct crypto_cipher *tfm)\n{\n  /* take the keying material, expand if necessary, truncate at 16-bytes */\n  /* run through AES counter mode to generate context->coeff[] */\n  \n\tint i,j;\n\tu32 counter;\n\tu8 *cipher, plain[16];\n\n\tcrypto_cipher_setkey(tfm, pkey, 16);\n\tcounter = 0;\n\tfor (i = 0; i < ARRAY_SIZE(context->coeff); ) {\n\t\taes_counter[15] = (u8)(counter >> 0);\n\t\taes_counter[14] = (u8)(counter >> 8);\n\t\taes_counter[13] = (u8)(counter >> 16);\n\t\taes_counter[12] = (u8)(counter >> 24);\n\t\tcounter++;\n\t\tmemcpy (plain, aes_counter, 16);\n\t\tcrypto_cipher_encrypt_one(tfm, plain, plain);\n\t\tcipher = plain;\n\t\tfor (j = 0; (j < 16) && (i < ARRAY_SIZE(context->coeff)); ) {\n\t\t\tcontext->coeff[i++] = ntohl(*(__be32 *)&cipher[j]);\n\t\t\tj += 4;\n\t\t}\n\t}\n}\n\n/* prepare for calculation of a new mic */\nstatic void emmh32_init(emmh32_context *context)\n{\n\t/* prepare for new mic calculation */\n\tcontext->accum = 0;\n\tcontext->position = 0;\n}\n\n/* add some bytes to the mic calculation */\nstatic void emmh32_update(emmh32_context *context, u8 *pOctets, int len)\n{\n\tint\tcoeff_position, byte_position;\n  \n\tif (len == 0) return;\n  \n\tcoeff_position = context->position >> 2;\n  \n\t/* deal with partial 32-bit word left over from last update */\n\tbyte_position = context->position & 3;\n\tif (byte_position) {\n\t\t/* have a partial word in part to deal with */\n\t\tdo {\n\t\t\tif (len == 0) return;\n\t\t\tcontext->part.d8[byte_position++] = *pOctets++;\n\t\t\tcontext->position++;\n\t\t\tlen--;\n\t\t} while (byte_position < 4);\n\t\tMIC_ACCUM(ntohl(context->part.d32));\n\t}\n\n\t/* deal with full 32-bit words */\n\twhile (len >= 4) {\n\t\tMIC_ACCUM(ntohl(*(__be32 *)pOctets));\n\t\tcontext->position += 4;\n\t\tpOctets += 4;\n\t\tlen -= 4;\n\t}\n\n\t/* deal with partial 32-bit word that will be left over from this update */\n\tbyte_position = 0;\n\twhile (len > 0) {\n\t\tcontext->part.d8[byte_position++] = *pOctets++;\n\t\tcontext->position++;\n\t\tlen--;\n\t}\n}\n\n/* mask used to zero empty bytes for final partial word */\nstatic u32 mask32[4] = { 0x00000000L, 0xFF000000L, 0xFFFF0000L, 0xFFFFFF00L };\n\n/* calculate the mic */\nstatic void emmh32_final(emmh32_context *context, u8 digest[4])\n{\n\tint\tcoeff_position, byte_position;\n\tu32\tval;\n  \n\tu64 sum, utmp;\n\ts64 stmp;\n\n\tcoeff_position = context->position >> 2;\n  \n\t/* deal with partial 32-bit word left over from last update */\n\tbyte_position = context->position & 3;\n\tif (byte_position) {\n\t\t/* have a partial word in part to deal with */\n\t\tval = ntohl(context->part.d32);\n\t\tMIC_ACCUM(val & mask32[byte_position]);\t/* zero empty bytes */\n\t}\n\n\t/* reduce the accumulated u64 to a 32-bit MIC */\n\tsum = context->accum;\n\tstmp = (sum  & 0xffffffffLL) - ((sum >> 32)  * 15);\n\tutmp = (stmp & 0xffffffffLL) - ((stmp >> 32) * 15);\n\tsum = utmp & 0xffffffffLL;\n\tif (utmp > 0x10000000fLL)\n\t\tsum -= 15;\n\n\tval = (u32)sum;\n\tdigest[0] = (val>>24) & 0xFF;\n\tdigest[1] = (val>>16) & 0xFF;\n\tdigest[2] = (val>>8) & 0xFF;\n\tdigest[3] = val & 0xFF;\n}\n\nstatic int readBSSListRid(struct airo_info *ai, int first,\n\t\t      BSSListRid *list)\n{\n\tCmd cmd;\n\tResp rsp;\n\n\tif (first == 1) {\n\t\tif (ai->flags & FLAG_RADIO_MASK) return -ENETDOWN;\n\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\tcmd.cmd=CMD_LISTBSS;\n\t\tif (down_interruptible(&ai->sem))\n\t\t\treturn -ERESTARTSYS;\n\t\tai->list_bss_task = current;\n\t\tissuecommand(ai, &cmd, &rsp);\n\t\tup(&ai->sem);\n\t\t/* Let the command take effect */\n\t\tschedule_timeout_uninterruptible(3 * HZ);\n\t\tai->list_bss_task = NULL;\n\t}\n\treturn PC4500_readrid(ai, first ? ai->bssListFirst : ai->bssListNext,\n\t\t\t    list, ai->bssListRidLen, 1);\n}\n\nstatic int readWepKeyRid(struct airo_info *ai, WepKeyRid *wkr, int temp, int lock)\n{\n\treturn PC4500_readrid(ai, temp ? RID_WEP_TEMP : RID_WEP_PERM,\n\t\t\t\twkr, sizeof(*wkr), lock);\n}\n\nstatic int writeWepKeyRid(struct airo_info *ai, WepKeyRid *wkr, int perm, int lock)\n{\n\tint rc;\n\trc = PC4500_writerid(ai, RID_WEP_TEMP, wkr, sizeof(*wkr), lock);\n\tif (rc!=SUCCESS)\n\t\tairo_print_err(ai->dev->name, \"WEP_TEMP set %x\", rc);\n\tif (perm) {\n\t\trc = PC4500_writerid(ai, RID_WEP_PERM, wkr, sizeof(*wkr), lock);\n\t\tif (rc!=SUCCESS)\n\t\t\tairo_print_err(ai->dev->name, \"WEP_PERM set %x\", rc);\n\t}\n\treturn rc;\n}\n\nstatic int readSsidRid(struct airo_info*ai, SsidRid *ssidr)\n{\n\treturn PC4500_readrid(ai, RID_SSID, ssidr, sizeof(*ssidr), 1);\n}\n\nstatic int writeSsidRid(struct airo_info*ai, SsidRid *pssidr, int lock)\n{\n\treturn PC4500_writerid(ai, RID_SSID, pssidr, sizeof(*pssidr), lock);\n}\n\nstatic int readConfigRid(struct airo_info *ai, int lock)\n{\n\tint rc;\n\tConfigRid cfg;\n\n\tif (ai->config.len)\n\t\treturn SUCCESS;\n\n\trc = PC4500_readrid(ai, RID_ACTUALCONFIG, &cfg, sizeof(cfg), lock);\n\tif (rc != SUCCESS)\n\t\treturn rc;\n\n\tai->config = cfg;\n\treturn SUCCESS;\n}\n\nstatic inline void checkThrottle(struct airo_info *ai)\n{\n\tint i;\n/* Old hardware had a limit on encryption speed */\n\tif (ai->config.authType != AUTH_OPEN && maxencrypt) {\n\t\tfor(i=0; i<8; i++) {\n\t\t\tif (ai->config.rates[i] > maxencrypt) {\n\t\t\t\tai->config.rates[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int writeConfigRid(struct airo_info *ai, int lock)\n{\n\tConfigRid cfgr;\n\n\tif (!test_bit (FLAG_COMMIT, &ai->flags))\n\t\treturn SUCCESS;\n\n\tclear_bit (FLAG_COMMIT, &ai->flags);\n\tclear_bit (FLAG_RESET, &ai->flags);\n\tcheckThrottle(ai);\n\tcfgr = ai->config;\n\n\tif ((cfgr.opmode & MODE_CFG_MASK) == MODE_STA_IBSS)\n\t\tset_bit(FLAG_ADHOC, &ai->flags);\n\telse\n\t\tclear_bit(FLAG_ADHOC, &ai->flags);\n\n\treturn PC4500_writerid( ai, RID_CONFIG, &cfgr, sizeof(cfgr), lock);\n}\n\nstatic int readStatusRid(struct airo_info *ai, StatusRid *statr, int lock)\n{\n\treturn PC4500_readrid(ai, RID_STATUS, statr, sizeof(*statr), lock);\n}\n\nstatic int readAPListRid(struct airo_info *ai, APListRid *aplr)\n{\n\treturn PC4500_readrid(ai, RID_APLIST, aplr, sizeof(*aplr), 1);\n}\n\nstatic int writeAPListRid(struct airo_info *ai, APListRid *aplr, int lock)\n{\n\treturn PC4500_writerid(ai, RID_APLIST, aplr, sizeof(*aplr), lock);\n}\n\nstatic int readCapabilityRid(struct airo_info *ai, CapabilityRid *capr, int lock)\n{\n\treturn PC4500_readrid(ai, RID_CAPABILITIES, capr, sizeof(*capr), lock);\n}\n\nstatic int readStatsRid(struct airo_info*ai, StatsRid *sr, int rid, int lock)\n{\n\treturn PC4500_readrid(ai, rid, sr, sizeof(*sr), lock);\n}\n\nstatic void try_auto_wep(struct airo_info *ai)\n{\n\tif (auto_wep && !(ai->flags & FLAG_RADIO_DOWN)) {\n\t\tai->expires = RUN_AT(3*HZ);\n\t\twake_up_interruptible(&ai->thr_wait);\n\t}\n}\n\nstatic int airo_open(struct net_device *dev) {\n\tstruct airo_info *ai = dev->ml_priv;\n\tint rc = 0;\n\n\tif (test_bit(FLAG_FLASHING, &ai->flags))\n\t\treturn -EIO;\n\n\t/* Make sure the card is configured.\n\t * Wireless Extensions may postpone config changes until the card\n\t * is open (to pipeline changes and speed-up card setup). If\n\t * those changes are not yet committed, do it now - Jean II */\n\tif (test_bit(FLAG_COMMIT, &ai->flags)) {\n\t\tdisable_MAC(ai, 1);\n\t\twriteConfigRid(ai, 1);\n\t}\n\n\tif (ai->wifidev != dev) {\n\t\tclear_bit(JOB_DIE, &ai->jobs);\n\t\tai->airo_thread_task = kthread_run(airo_thread, dev, dev->name);\n\t\tif (IS_ERR(ai->airo_thread_task))\n\t\t\treturn (int)PTR_ERR(ai->airo_thread_task);\n\n\t\trc = request_irq(dev->irq, airo_interrupt, IRQF_SHARED,\n\t\t\tdev->name, dev);\n\t\tif (rc) {\n\t\t\tairo_print_err(dev->name,\n\t\t\t\t\"register interrupt %d failed, rc %d\",\n\t\t\t\tdev->irq, rc);\n\t\t\tset_bit(JOB_DIE, &ai->jobs);\n\t\t\tkthread_stop(ai->airo_thread_task);\n\t\t\treturn rc;\n\t\t}\n\n\t\t/* Power on the MAC controller (which may have been disabled) */\n\t\tclear_bit(FLAG_RADIO_DOWN, &ai->flags);\n\t\tenable_interrupts(ai);\n\n\t\ttry_auto_wep(ai);\n\t}\n\tenable_MAC(ai, 1);\n\n\tnetif_start_queue(dev);\n\treturn 0;\n}\n\nstatic netdev_tx_t mpi_start_xmit(struct sk_buff *skb,\n\t\t\t\t\tstruct net_device *dev)\n{\n\tint npacks, pending;\n\tunsigned long flags;\n\tstruct airo_info *ai = dev->ml_priv;\n\n\tif (!skb) {\n\t\tairo_print_err(dev->name, \"%s: skb == NULL!\",__func__);\n\t\treturn NETDEV_TX_OK;\n\t}\n\tnpacks = skb_queue_len (&ai->txq);\n\n\tif (npacks >= MAXTXQ - 1) {\n\t\tnetif_stop_queue (dev);\n\t\tif (npacks > MAXTXQ) {\n\t\t\tdev->stats.tx_fifo_errors++;\n\t\t\treturn NETDEV_TX_BUSY;\n\t\t}\n\t\tskb_queue_tail (&ai->txq, skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tspin_lock_irqsave(&ai->aux_lock, flags);\n\tskb_queue_tail (&ai->txq, skb);\n\tpending = test_bit(FLAG_PENDING_XMIT, &ai->flags);\n\tspin_unlock_irqrestore(&ai->aux_lock,flags);\n\tnetif_wake_queue (dev);\n\n\tif (pending == 0) {\n\t\tset_bit(FLAG_PENDING_XMIT, &ai->flags);\n\t\tmpi_send_packet (dev);\n\t}\n\treturn NETDEV_TX_OK;\n}\n\n/*\n * @mpi_send_packet\n *\n * Attempt to transmit a packet. Can be called from interrupt\n * or transmit . return number of packets we tried to send\n */\n\nstatic int mpi_send_packet (struct net_device *dev)\n{\n\tstruct sk_buff *skb;\n\tunsigned char *buffer;\n\ts16 len;\n\t__le16 *payloadLen;\n\tstruct airo_info *ai = dev->ml_priv;\n\tu8 *sendbuf;\n\n\t/* get a packet to send */\n\n\tif ((skb = skb_dequeue(&ai->txq)) == NULL) {\n\t\tairo_print_err(dev->name,\n\t\t\t\"%s: Dequeue'd zero in send_packet()\",\n\t\t\t__func__);\n\t\treturn 0;\n\t}\n\n\t/* check min length*/\n\tlen = ETH_ZLEN < skb->len ? skb->len : ETH_ZLEN;\n\tbuffer = skb->data;\n\n\tai->txfids[0].tx_desc.offset = 0;\n\tai->txfids[0].tx_desc.valid = 1;\n\tai->txfids[0].tx_desc.eoc = 1;\n\tai->txfids[0].tx_desc.len =len+sizeof(WifiHdr);\n\n/*\n * Magic, the cards firmware needs a length count (2 bytes) in the host buffer\n * right after  TXFID_HDR.The TXFID_HDR contains the status short so payloadlen\n * is immediately after it. ------------------------------------------------\n *                         |TXFIDHDR+STATUS|PAYLOADLEN|802.3HDR|PACKETDATA|\n *                         ------------------------------------------------\n */\n\n\tmemcpy((char *)ai->txfids[0].virtual_host_addr,\n\t\t(char *)&wifictlhdr8023, sizeof(wifictlhdr8023));\n\n\tpayloadLen = (__le16 *)(ai->txfids[0].virtual_host_addr +\n\t\tsizeof(wifictlhdr8023));\n\tsendbuf = ai->txfids[0].virtual_host_addr +\n\t\tsizeof(wifictlhdr8023) + 2 ;\n\n\t/*\n\t * Firmware automatically puts 802 header on so\n\t * we don't need to account for it in the length\n\t */\n\tif (test_bit(FLAG_MIC_CAPABLE, &ai->flags) && ai->micstats.enabled &&\n\t\t(ntohs(((__be16 *)buffer)[6]) != 0x888E)) {\n\t\tMICBuffer pMic;\n\n\t\tif (encapsulate(ai, (etherHead *)buffer, &pMic, len - sizeof(etherHead)) != SUCCESS)\n\t\t\treturn ERROR;\n\n\t\t*payloadLen = cpu_to_le16(len-sizeof(etherHead)+sizeof(pMic));\n\t\tai->txfids[0].tx_desc.len += sizeof(pMic);\n\t\t/* copy data into airo dma buffer */\n\t\tmemcpy (sendbuf, buffer, sizeof(etherHead));\n\t\tbuffer += sizeof(etherHead);\n\t\tsendbuf += sizeof(etherHead);\n\t\tmemcpy (sendbuf, &pMic, sizeof(pMic));\n\t\tsendbuf += sizeof(pMic);\n\t\tmemcpy (sendbuf, buffer, len - sizeof(etherHead));\n\t} else {\n\t\t*payloadLen = cpu_to_le16(len - sizeof(etherHead));\n\n\t\tdev->trans_start = jiffies;\n\n\t\t/* copy data into airo dma buffer */\n\t\tmemcpy(sendbuf, buffer, len);\n\t}\n\n\tmemcpy_toio(ai->txfids[0].card_ram_off,\n\t\t&ai->txfids[0].tx_desc, sizeof(TxFid));\n\n\tOUT4500(ai, EVACK, 8);\n\n\tdev_kfree_skb_any(skb);\n\treturn 1;\n}\n\nstatic void get_tx_error(struct airo_info *ai, s32 fid)\n{\n\t__le16 status;\n\n\tif (fid < 0)\n\t\tstatus = ((WifiCtlHdr *)ai->txfids[0].virtual_host_addr)->ctlhdr.status;\n\telse {\n\t\tif (bap_setup(ai, ai->fids[fid] & 0xffff, 4, BAP0) != SUCCESS)\n\t\t\treturn;\n\t\tbap_read(ai, &status, 2, BAP0);\n\t}\n\tif (le16_to_cpu(status) & 2) /* Too many retries */\n\t\tai->dev->stats.tx_aborted_errors++;\n\tif (le16_to_cpu(status) & 4) /* Transmit lifetime exceeded */\n\t\tai->dev->stats.tx_heartbeat_errors++;\n\tif (le16_to_cpu(status) & 8) /* Aid fail */\n\t\t{ }\n\tif (le16_to_cpu(status) & 0x10) /* MAC disabled */\n\t\tai->dev->stats.tx_carrier_errors++;\n\tif (le16_to_cpu(status) & 0x20) /* Association lost */\n\t\t{ }\n\t/* We produce a TXDROP event only for retry or lifetime\n\t * exceeded, because that's the only status that really mean\n\t * that this particular node went away.\n\t * Other errors means that *we* screwed up. - Jean II */\n\tif ((le16_to_cpu(status) & 2) ||\n\t     (le16_to_cpu(status) & 4)) {\n\t\tunion iwreq_data\twrqu;\n\t\tchar junk[0x18];\n\n\t\t/* Faster to skip over useless data than to do\n\t\t * another bap_setup(). We are at offset 0x6 and\n\t\t * need to go to 0x18 and read 6 bytes - Jean II */\n\t\tbap_read(ai, (__le16 *) junk, 0x18, BAP0);\n\n\t\t/* Copy 802.11 dest address.\n\t\t * We use the 802.11 header because the frame may\n\t\t * not be 802.3 or may be mangled...\n\t\t * In Ad-Hoc mode, it will be the node address.\n\t\t * In managed mode, it will be most likely the AP addr\n\t\t * User space will figure out how to convert it to\n\t\t * whatever it needs (IP address or else).\n\t\t * - Jean II */\n\t\tmemcpy(wrqu.addr.sa_data, junk + 0x12, ETH_ALEN);\n\t\twrqu.addr.sa_family = ARPHRD_ETHER;\n\n\t\t/* Send event to user space */\n\t\twireless_send_event(ai->dev, IWEVTXDROP, &wrqu, NULL);\n\t}\n}\n\nstatic void airo_end_xmit(struct net_device *dev) {\n\tu16 status;\n\tint i;\n\tstruct airo_info *priv = dev->ml_priv;\n\tstruct sk_buff *skb = priv->xmit.skb;\n\tint fid = priv->xmit.fid;\n\tu32 *fids = priv->fids;\n\n\tclear_bit(JOB_XMIT, &priv->jobs);\n\tclear_bit(FLAG_PENDING_XMIT, &priv->flags);\n\tstatus = transmit_802_3_packet (priv, fids[fid], skb->data);\n\tup(&priv->sem);\n\n\ti = 0;\n\tif ( status == SUCCESS ) {\n\t\tdev->trans_start = jiffies;\n\t\tfor (; i < MAX_FIDS / 2 && (priv->fids[i] & 0xffff0000); i++);\n\t} else {\n\t\tpriv->fids[fid] &= 0xffff;\n\t\tdev->stats.tx_window_errors++;\n\t}\n\tif (i < MAX_FIDS / 2)\n\t\tnetif_wake_queue(dev);\n\tdev_kfree_skb(skb);\n}\n\nstatic netdev_tx_t airo_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *dev)\n{\n\ts16 len;\n\tint i, j;\n\tstruct airo_info *priv = dev->ml_priv;\n\tu32 *fids = priv->fids;\n\n\tif ( skb == NULL ) {\n\t\tairo_print_err(dev->name, \"%s: skb == NULL!\", __func__);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\t/* Find a vacant FID */\n\tfor( i = 0; i < MAX_FIDS / 2 && (fids[i] & 0xffff0000); i++ );\n\tfor( j = i + 1; j < MAX_FIDS / 2 && (fids[j] & 0xffff0000); j++ );\n\n\tif ( j >= MAX_FIDS / 2 ) {\n\t\tnetif_stop_queue(dev);\n\n\t\tif (i == MAX_FIDS / 2) {\n\t\t\tdev->stats.tx_fifo_errors++;\n\t\t\treturn NETDEV_TX_BUSY;\n\t\t}\n\t}\n\t/* check min length*/\n\tlen = ETH_ZLEN < skb->len ? skb->len : ETH_ZLEN;\n        /* Mark fid as used & save length for later */\n\tfids[i] |= (len << 16);\n\tpriv->xmit.skb = skb;\n\tpriv->xmit.fid = i;\n\tif (down_trylock(&priv->sem) != 0) {\n\t\tset_bit(FLAG_PENDING_XMIT, &priv->flags);\n\t\tnetif_stop_queue(dev);\n\t\tset_bit(JOB_XMIT, &priv->jobs);\n\t\twake_up_interruptible(&priv->thr_wait);\n\t} else\n\t\tairo_end_xmit(dev);\n\treturn NETDEV_TX_OK;\n}\n\nstatic void airo_end_xmit11(struct net_device *dev) {\n\tu16 status;\n\tint i;\n\tstruct airo_info *priv = dev->ml_priv;\n\tstruct sk_buff *skb = priv->xmit11.skb;\n\tint fid = priv->xmit11.fid;\n\tu32 *fids = priv->fids;\n\n\tclear_bit(JOB_XMIT11, &priv->jobs);\n\tclear_bit(FLAG_PENDING_XMIT11, &priv->flags);\n\tstatus = transmit_802_11_packet (priv, fids[fid], skb->data);\n\tup(&priv->sem);\n\n\ti = MAX_FIDS / 2;\n\tif ( status == SUCCESS ) {\n\t\tdev->trans_start = jiffies;\n\t\tfor (; i < MAX_FIDS && (priv->fids[i] & 0xffff0000); i++);\n\t} else {\n\t\tpriv->fids[fid] &= 0xffff;\n\t\tdev->stats.tx_window_errors++;\n\t}\n\tif (i < MAX_FIDS)\n\t\tnetif_wake_queue(dev);\n\tdev_kfree_skb(skb);\n}\n\nstatic netdev_tx_t airo_start_xmit11(struct sk_buff *skb,\n\t\t\t\t\t   struct net_device *dev)\n{\n\ts16 len;\n\tint i, j;\n\tstruct airo_info *priv = dev->ml_priv;\n\tu32 *fids = priv->fids;\n\n\tif (test_bit(FLAG_MPI, &priv->flags)) {\n\t\t/* Not implemented yet for MPI350 */\n\t\tnetif_stop_queue(dev);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tif ( skb == NULL ) {\n\t\tairo_print_err(dev->name, \"%s: skb == NULL!\", __func__);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\t/* Find a vacant FID */\n\tfor( i = MAX_FIDS / 2; i < MAX_FIDS && (fids[i] & 0xffff0000); i++ );\n\tfor( j = i + 1; j < MAX_FIDS && (fids[j] & 0xffff0000); j++ );\n\n\tif ( j >= MAX_FIDS ) {\n\t\tnetif_stop_queue(dev);\n\n\t\tif (i == MAX_FIDS) {\n\t\t\tdev->stats.tx_fifo_errors++;\n\t\t\treturn NETDEV_TX_BUSY;\n\t\t}\n\t}\n\t/* check min length*/\n\tlen = ETH_ZLEN < skb->len ? skb->len : ETH_ZLEN;\n        /* Mark fid as used & save length for later */\n\tfids[i] |= (len << 16);\n\tpriv->xmit11.skb = skb;\n\tpriv->xmit11.fid = i;\n\tif (down_trylock(&priv->sem) != 0) {\n\t\tset_bit(FLAG_PENDING_XMIT11, &priv->flags);\n\t\tnetif_stop_queue(dev);\n\t\tset_bit(JOB_XMIT11, &priv->jobs);\n\t\twake_up_interruptible(&priv->thr_wait);\n\t} else\n\t\tairo_end_xmit11(dev);\n\treturn NETDEV_TX_OK;\n}\n\nstatic void airo_read_stats(struct net_device *dev)\n{\n\tstruct airo_info *ai = dev->ml_priv;\n\tStatsRid stats_rid;\n\t__le32 *vals = stats_rid.vals;\n\n\tclear_bit(JOB_STATS, &ai->jobs);\n\tif (ai->power.event) {\n\t\tup(&ai->sem);\n\t\treturn;\n\t}\n\treadStatsRid(ai, &stats_rid, RID_STATS, 0);\n\tup(&ai->sem);\n\n\tdev->stats.rx_packets = le32_to_cpu(vals[43]) + le32_to_cpu(vals[44]) +\n\t\t\t       le32_to_cpu(vals[45]);\n\tdev->stats.tx_packets = le32_to_cpu(vals[39]) + le32_to_cpu(vals[40]) +\n\t\t\t       le32_to_cpu(vals[41]);\n\tdev->stats.rx_bytes = le32_to_cpu(vals[92]);\n\tdev->stats.tx_bytes = le32_to_cpu(vals[91]);\n\tdev->stats.rx_errors = le32_to_cpu(vals[0]) + le32_to_cpu(vals[2]) +\n\t\t\t      le32_to_cpu(vals[3]) + le32_to_cpu(vals[4]);\n\tdev->stats.tx_errors = le32_to_cpu(vals[42]) +\n\t\t\t      dev->stats.tx_fifo_errors;\n\tdev->stats.multicast = le32_to_cpu(vals[43]);\n\tdev->stats.collisions = le32_to_cpu(vals[89]);\n\n\t/* detailed rx_errors: */\n\tdev->stats.rx_length_errors = le32_to_cpu(vals[3]);\n\tdev->stats.rx_crc_errors = le32_to_cpu(vals[4]);\n\tdev->stats.rx_frame_errors = le32_to_cpu(vals[2]);\n\tdev->stats.rx_fifo_errors = le32_to_cpu(vals[0]);\n}\n\nstatic struct net_device_stats *airo_get_stats(struct net_device *dev)\n{\n\tstruct airo_info *local =  dev->ml_priv;\n\n\tif (!test_bit(JOB_STATS, &local->jobs)) {\n\t\t/* Get stats out of the card if available */\n\t\tif (down_trylock(&local->sem) != 0) {\n\t\t\tset_bit(JOB_STATS, &local->jobs);\n\t\t\twake_up_interruptible(&local->thr_wait);\n\t\t} else\n\t\t\tairo_read_stats(dev);\n\t}\n\n\treturn &dev->stats;\n}\n\nstatic void airo_set_promisc(struct airo_info *ai) {\n\tCmd cmd;\n\tResp rsp;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.cmd=CMD_SETMODE;\n\tclear_bit(JOB_PROMISC, &ai->jobs);\n\tcmd.parm0=(ai->flags&IFF_PROMISC) ? PROMISC : NOPROMISC;\n\tissuecommand(ai, &cmd, &rsp);\n\tup(&ai->sem);\n}\n\nstatic void airo_set_multicast_list(struct net_device *dev) {\n\tstruct airo_info *ai = dev->ml_priv;\n\n\tif ((dev->flags ^ ai->flags) & IFF_PROMISC) {\n\t\tchange_bit(FLAG_PROMISC, &ai->flags);\n\t\tif (down_trylock(&ai->sem) != 0) {\n\t\t\tset_bit(JOB_PROMISC, &ai->jobs);\n\t\t\twake_up_interruptible(&ai->thr_wait);\n\t\t} else\n\t\t\tairo_set_promisc(ai);\n\t}\n\n\tif ((dev->flags&IFF_ALLMULTI) || !netdev_mc_empty(dev)) {\n\t\t/* Turn on multicast.  (Should be already setup...) */\n\t}\n}\n\nstatic int airo_set_mac_address(struct net_device *dev, void *p)\n{\n\tstruct airo_info *ai = dev->ml_priv;\n\tstruct sockaddr *addr = p;\n\n\treadConfigRid(ai, 1);\n\tmemcpy (ai->config.macAddr, addr->sa_data, dev->addr_len);\n\tset_bit (FLAG_COMMIT, &ai->flags);\n\tdisable_MAC(ai, 1);\n\twriteConfigRid (ai, 1);\n\tenable_MAC(ai, 1);\n\tmemcpy (ai->dev->dev_addr, addr->sa_data, dev->addr_len);\n\tif (ai->wifidev)\n\t\tmemcpy (ai->wifidev->dev_addr, addr->sa_data, dev->addr_len);\n\treturn 0;\n}\n\nstatic int airo_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tif ((new_mtu < 68) || (new_mtu > 2400))\n\t\treturn -EINVAL;\n\tdev->mtu = new_mtu;\n\treturn 0;\n}\n\nstatic LIST_HEAD(airo_devices);\n\nstatic void add_airo_dev(struct airo_info *ai)\n{\n\t/* Upper layers already keep track of PCI devices,\n\t * so we only need to remember our non-PCI cards. */\n\tif (!ai->pci)\n\t\tlist_add_tail(&ai->dev_list, &airo_devices);\n}\n\nstatic void del_airo_dev(struct airo_info *ai)\n{\n\tif (!ai->pci)\n\t\tlist_del(&ai->dev_list);\n}\n\nstatic int airo_close(struct net_device *dev) {\n\tstruct airo_info *ai = dev->ml_priv;\n\n\tnetif_stop_queue(dev);\n\n\tif (ai->wifidev != dev) {\n#ifdef POWER_ON_DOWN\n\t\t/* Shut power to the card. The idea is that the user can save\n\t\t * power when he doesn't need the card with \"ifconfig down\".\n\t\t * That's the method that is most friendly towards the network\n\t\t * stack (i.e. the network stack won't try to broadcast\n\t\t * anything on the interface and routes are gone. Jean II */\n\t\tset_bit(FLAG_RADIO_DOWN, &ai->flags);\n\t\tdisable_MAC(ai, 1);\n#endif\n\t\tdisable_interrupts( ai );\n\n\t\tfree_irq(dev->irq, dev);\n\n\t\tset_bit(JOB_DIE, &ai->jobs);\n\t\tkthread_stop(ai->airo_thread_task);\n\t}\n\treturn 0;\n}\n\nvoid stop_airo_card( struct net_device *dev, int freeres )\n{\n\tstruct airo_info *ai = dev->ml_priv;\n\n\tset_bit(FLAG_RADIO_DOWN, &ai->flags);\n\tdisable_MAC(ai, 1);\n\tdisable_interrupts(ai);\n\ttakedown_proc_entry( dev, ai );\n\tif (test_bit(FLAG_REGISTERED, &ai->flags)) {\n\t\tunregister_netdev( dev );\n\t\tif (ai->wifidev) {\n\t\t\tunregister_netdev(ai->wifidev);\n\t\t\tfree_netdev(ai->wifidev);\n\t\t\tai->wifidev = NULL;\n\t\t}\n\t\tclear_bit(FLAG_REGISTERED, &ai->flags);\n\t}\n\t/*\n\t * Clean out tx queue\n\t */\n\tif (test_bit(FLAG_MPI, &ai->flags) && !skb_queue_empty(&ai->txq)) {\n\t\tstruct sk_buff *skb = NULL;\n\t\tfor (;(skb = skb_dequeue(&ai->txq));)\n\t\t\tdev_kfree_skb(skb);\n\t}\n\n\tairo_networks_free (ai);\n\n\tkfree(ai->flash);\n\tkfree(ai->rssi);\n\tkfree(ai->APList);\n\tkfree(ai->SSID);\n\tif (freeres) {\n\t\t/* PCMCIA frees this stuff, so only for PCI and ISA */\n\t        release_region( dev->base_addr, 64 );\n\t\tif (test_bit(FLAG_MPI, &ai->flags)) {\n\t\t\tif (ai->pci)\n\t\t\t\tmpi_unmap_card(ai->pci);\n\t\t\tif (ai->pcimem)\n\t\t\t\tiounmap(ai->pcimem);\n\t\t\tif (ai->pciaux)\n\t\t\t\tiounmap(ai->pciaux);\n\t\t\tpci_free_consistent(ai->pci, PCI_SHARED_LEN,\n\t\t\t\tai->shared, ai->shared_dma);\n\t\t}\n        }\n\tcrypto_free_cipher(ai->tfm);\n\tdel_airo_dev(ai);\n\tfree_netdev( dev );\n}\n\nEXPORT_SYMBOL(stop_airo_card);\n\nstatic int wll_header_parse(const struct sk_buff *skb, unsigned char *haddr)\n{\n\tmemcpy(haddr, skb_mac_header(skb) + 10, ETH_ALEN);\n\treturn ETH_ALEN;\n}\n\nstatic void mpi_unmap_card(struct pci_dev *pci)\n{\n\tunsigned long mem_start = pci_resource_start(pci, 1);\n\tunsigned long mem_len = pci_resource_len(pci, 1);\n\tunsigned long aux_start = pci_resource_start(pci, 2);\n\tunsigned long aux_len = AUXMEMSIZE;\n\n\trelease_mem_region(aux_start, aux_len);\n\trelease_mem_region(mem_start, mem_len);\n}\n\n/*************************************************************\n *  This routine assumes that descriptors have been setup .\n *  Run at insmod time or after reset  when the decriptors\n *  have been initialized . Returns 0 if all is well nz\n *  otherwise . Does not allocate memory but sets up card\n *  using previously allocated descriptors.\n */\nstatic int mpi_init_descriptors (struct airo_info *ai)\n{\n\tCmd cmd;\n\tResp rsp;\n\tint i;\n\tint rc = SUCCESS;\n\n\t/* Alloc  card RX descriptors */\n\tnetif_stop_queue(ai->dev);\n\n\tmemset(&rsp,0,sizeof(rsp));\n\tmemset(&cmd,0,sizeof(cmd));\n\n\tcmd.cmd = CMD_ALLOCATEAUX;\n\tcmd.parm0 = FID_RX;\n\tcmd.parm1 = (ai->rxfids[0].card_ram_off - ai->pciaux);\n\tcmd.parm2 = MPI_MAX_FIDS;\n\trc=issuecommand(ai, &cmd, &rsp);\n\tif (rc != SUCCESS) {\n\t\tairo_print_err(ai->dev->name, \"Couldn't allocate RX FID\");\n\t\treturn rc;\n\t}\n\n\tfor (i=0; i<MPI_MAX_FIDS; i++) {\n\t\tmemcpy_toio(ai->rxfids[i].card_ram_off,\n\t\t\t&ai->rxfids[i].rx_desc, sizeof(RxFid));\n\t}\n\n\t/* Alloc card TX descriptors */\n\n\tmemset(&rsp,0,sizeof(rsp));\n\tmemset(&cmd,0,sizeof(cmd));\n\n\tcmd.cmd = CMD_ALLOCATEAUX;\n\tcmd.parm0 = FID_TX;\n\tcmd.parm1 = (ai->txfids[0].card_ram_off - ai->pciaux);\n\tcmd.parm2 = MPI_MAX_FIDS;\n\n\tfor (i=0; i<MPI_MAX_FIDS; i++) {\n\t\tai->txfids[i].tx_desc.valid = 1;\n\t\tmemcpy_toio(ai->txfids[i].card_ram_off,\n\t\t\t&ai->txfids[i].tx_desc, sizeof(TxFid));\n\t}\n\tai->txfids[i-1].tx_desc.eoc = 1; /* Last descriptor has EOC set */\n\n\trc=issuecommand(ai, &cmd, &rsp);\n\tif (rc != SUCCESS) {\n\t\tairo_print_err(ai->dev->name, \"Couldn't allocate TX FID\");\n\t\treturn rc;\n\t}\n\n\t/* Alloc card Rid descriptor */\n\tmemset(&rsp,0,sizeof(rsp));\n\tmemset(&cmd,0,sizeof(cmd));\n\n\tcmd.cmd = CMD_ALLOCATEAUX;\n\tcmd.parm0 = RID_RW;\n\tcmd.parm1 = (ai->config_desc.card_ram_off - ai->pciaux);\n\tcmd.parm2 = 1; /* Magic number... */\n\trc=issuecommand(ai, &cmd, &rsp);\n\tif (rc != SUCCESS) {\n\t\tairo_print_err(ai->dev->name, \"Couldn't allocate RID\");\n\t\treturn rc;\n\t}\n\n\tmemcpy_toio(ai->config_desc.card_ram_off,\n\t\t&ai->config_desc.rid_desc, sizeof(Rid));\n\n\treturn rc;\n}\n\n/*\n * We are setting up three things here:\n * 1) Map AUX memory for descriptors: Rid, TxFid, or RxFid.\n * 2) Map PCI memory for issuing commands.\n * 3) Allocate memory (shared) to send and receive ethernet frames.\n */\nstatic int mpi_map_card(struct airo_info *ai, struct pci_dev *pci)\n{\n\tunsigned long mem_start, mem_len, aux_start, aux_len;\n\tint rc = -1;\n\tint i;\n\tdma_addr_t busaddroff;\n\tunsigned char *vpackoff;\n\tunsigned char __iomem *pciaddroff;\n\n\tmem_start = pci_resource_start(pci, 1);\n\tmem_len = pci_resource_len(pci, 1);\n\taux_start = pci_resource_start(pci, 2);\n\taux_len = AUXMEMSIZE;\n\n\tif (!request_mem_region(mem_start, mem_len, DRV_NAME)) {\n\t\tairo_print_err(\"\", \"Couldn't get region %x[%x]\",\n\t\t\t(int)mem_start, (int)mem_len);\n\t\tgoto out;\n\t}\n\tif (!request_mem_region(aux_start, aux_len, DRV_NAME)) {\n\t\tairo_print_err(\"\", \"Couldn't get region %x[%x]\",\n\t\t\t(int)aux_start, (int)aux_len);\n\t\tgoto free_region1;\n\t}\n\n\tai->pcimem = ioremap(mem_start, mem_len);\n\tif (!ai->pcimem) {\n\t\tairo_print_err(\"\", \"Couldn't map region %x[%x]\",\n\t\t\t(int)mem_start, (int)mem_len);\n\t\tgoto free_region2;\n\t}\n\tai->pciaux = ioremap(aux_start, aux_len);\n\tif (!ai->pciaux) {\n\t\tairo_print_err(\"\", \"Couldn't map region %x[%x]\",\n\t\t\t(int)aux_start, (int)aux_len);\n\t\tgoto free_memmap;\n\t}\n\n\t/* Reserve PKTSIZE for each fid and 2K for the Rids */\n\tai->shared = pci_alloc_consistent(pci, PCI_SHARED_LEN, &ai->shared_dma);\n\tif (!ai->shared) {\n\t\tairo_print_err(\"\", \"Couldn't alloc_consistent %d\",\n\t\t\tPCI_SHARED_LEN);\n\t\tgoto free_auxmap;\n\t}\n\n\t/*\n\t * Setup descriptor RX, TX, CONFIG\n\t */\n\tbusaddroff = ai->shared_dma;\n\tpciaddroff = ai->pciaux + AUX_OFFSET;\n\tvpackoff   = ai->shared;\n\n\t/* RX descriptor setup */\n\tfor(i = 0; i < MPI_MAX_FIDS; i++) {\n\t\tai->rxfids[i].pending = 0;\n\t\tai->rxfids[i].card_ram_off = pciaddroff;\n\t\tai->rxfids[i].virtual_host_addr = vpackoff;\n\t\tai->rxfids[i].rx_desc.host_addr = busaddroff;\n\t\tai->rxfids[i].rx_desc.valid = 1;\n\t\tai->rxfids[i].rx_desc.len = PKTSIZE;\n\t\tai->rxfids[i].rx_desc.rdy = 0;\n\n\t\tpciaddroff += sizeof(RxFid);\n\t\tbusaddroff += PKTSIZE;\n\t\tvpackoff   += PKTSIZE;\n\t}\n\n\t/* TX descriptor setup */\n\tfor(i = 0; i < MPI_MAX_FIDS; i++) {\n\t\tai->txfids[i].card_ram_off = pciaddroff;\n\t\tai->txfids[i].virtual_host_addr = vpackoff;\n\t\tai->txfids[i].tx_desc.valid = 1;\n\t\tai->txfids[i].tx_desc.host_addr = busaddroff;\n\t\tmemcpy(ai->txfids[i].virtual_host_addr,\n\t\t\t&wifictlhdr8023, sizeof(wifictlhdr8023));\n\n\t\tpciaddroff += sizeof(TxFid);\n\t\tbusaddroff += PKTSIZE;\n\t\tvpackoff   += PKTSIZE;\n\t}\n\tai->txfids[i-1].tx_desc.eoc = 1; /* Last descriptor has EOC set */\n\n\t/* Rid descriptor setup */\n\tai->config_desc.card_ram_off = pciaddroff;\n\tai->config_desc.virtual_host_addr = vpackoff;\n\tai->config_desc.rid_desc.host_addr = busaddroff;\n\tai->ridbus = busaddroff;\n\tai->config_desc.rid_desc.rid = 0;\n\tai->config_desc.rid_desc.len = RIDSIZE;\n\tai->config_desc.rid_desc.valid = 1;\n\tpciaddroff += sizeof(Rid);\n\tbusaddroff += RIDSIZE;\n\tvpackoff   += RIDSIZE;\n\n\t/* Tell card about descriptors */\n\tif (mpi_init_descriptors (ai) != SUCCESS)\n\t\tgoto free_shared;\n\n\treturn 0;\n free_shared:\n\tpci_free_consistent(pci, PCI_SHARED_LEN, ai->shared, ai->shared_dma);\n free_auxmap:\n\tiounmap(ai->pciaux);\n free_memmap:\n\tiounmap(ai->pcimem);\n free_region2:\n\trelease_mem_region(aux_start, aux_len);\n free_region1:\n\trelease_mem_region(mem_start, mem_len);\n out:\n\treturn rc;\n}\n\nstatic const struct header_ops airo_header_ops = {\n\t.parse = wll_header_parse,\n};\n\nstatic const struct net_device_ops airo11_netdev_ops = {\n\t.ndo_open \t\t= airo_open,\n\t.ndo_stop \t\t= airo_close,\n\t.ndo_start_xmit \t= airo_start_xmit11,\n\t.ndo_get_stats \t\t= airo_get_stats,\n\t.ndo_set_mac_address\t= airo_set_mac_address,\n\t.ndo_do_ioctl\t\t= airo_ioctl,\n\t.ndo_change_mtu\t\t= airo_change_mtu,\n};\n\nstatic void wifi_setup(struct net_device *dev)\n{\n\tdev->netdev_ops = &airo11_netdev_ops;\n\tdev->header_ops = &airo_header_ops;\n\tdev->wireless_handlers = &airo_handler_def;\n\n\tdev->type               = ARPHRD_IEEE80211;\n\tdev->hard_header_len    = ETH_HLEN;\n\tdev->mtu                = AIRO_DEF_MTU;\n\tdev->addr_len           = ETH_ALEN;\n\tdev->tx_queue_len       = 100; \n\n\tmemset(dev->broadcast,0xFF, ETH_ALEN);\n\n\tdev->flags              = IFF_BROADCAST|IFF_MULTICAST;\n}\n\nstatic struct net_device *init_wifidev(struct airo_info *ai,\n\t\t\t\t\tstruct net_device *ethdev)\n{\n\tint err;\n\tstruct net_device *dev = alloc_netdev(0, \"wifi%d\", wifi_setup);\n\tif (!dev)\n\t\treturn NULL;\n\tdev->ml_priv = ethdev->ml_priv;\n\tdev->irq = ethdev->irq;\n\tdev->base_addr = ethdev->base_addr;\n\tdev->wireless_data = ethdev->wireless_data;\n\tSET_NETDEV_DEV(dev, ethdev->dev.parent);\n\tmemcpy(dev->dev_addr, ethdev->dev_addr, dev->addr_len);\n\terr = register_netdev(dev);\n\tif (err<0) {\n\t\tfree_netdev(dev);\n\t\treturn NULL;\n\t}\n\treturn dev;\n}\n\nstatic int reset_card( struct net_device *dev , int lock) {\n\tstruct airo_info *ai = dev->ml_priv;\n\n\tif (lock && down_interruptible(&ai->sem))\n\t\treturn -1;\n\twaitbusy (ai);\n\tOUT4500(ai,COMMAND,CMD_SOFTRESET);\n\tmsleep(200);\n\twaitbusy (ai);\n\tmsleep(200);\n\tif (lock)\n\t\tup(&ai->sem);\n\treturn 0;\n}\n\n#define AIRO_MAX_NETWORK_COUNT\t64\nstatic int airo_networks_allocate(struct airo_info *ai)\n{\n\tif (ai->networks)\n\t\treturn 0;\n\n\tai->networks = kcalloc(AIRO_MAX_NETWORK_COUNT, sizeof(BSSListElement),\n\t\t\t       GFP_KERNEL);\n\tif (!ai->networks) {\n\t\tairo_print_warn(\"\", \"Out of memory allocating beacons\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void airo_networks_free(struct airo_info *ai)\n{\n\tkfree(ai->networks);\n\tai->networks = NULL;\n}\n\nstatic void airo_networks_initialize(struct airo_info *ai)\n{\n\tint i;\n\n\tINIT_LIST_HEAD(&ai->network_free_list);\n\tINIT_LIST_HEAD(&ai->network_list);\n\tfor (i = 0; i < AIRO_MAX_NETWORK_COUNT; i++)\n\t\tlist_add_tail(&ai->networks[i].list,\n\t\t\t      &ai->network_free_list);\n}\n\nstatic const struct net_device_ops airo_netdev_ops = {\n\t.ndo_open\t\t= airo_open,\n\t.ndo_stop\t\t= airo_close,\n\t.ndo_start_xmit\t\t= airo_start_xmit,\n\t.ndo_get_stats\t\t= airo_get_stats,\n\t.ndo_set_multicast_list\t= airo_set_multicast_list,\n\t.ndo_set_mac_address\t= airo_set_mac_address,\n\t.ndo_do_ioctl\t\t= airo_ioctl,\n\t.ndo_change_mtu\t\t= airo_change_mtu,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic const struct net_device_ops mpi_netdev_ops = {\n\t.ndo_open\t\t= airo_open,\n\t.ndo_stop\t\t= airo_close,\n\t.ndo_start_xmit\t\t= mpi_start_xmit,\n\t.ndo_get_stats\t\t= airo_get_stats,\n\t.ndo_set_multicast_list\t= airo_set_multicast_list,\n\t.ndo_set_mac_address\t= airo_set_mac_address,\n\t.ndo_do_ioctl\t\t= airo_ioctl,\n\t.ndo_change_mtu\t\t= airo_change_mtu,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\n\nstatic struct net_device *_init_airo_card( unsigned short irq, int port,\n\t\t\t\t\t   int is_pcmcia, struct pci_dev *pci,\n\t\t\t\t\t   struct device *dmdev )\n{\n\tstruct net_device *dev;\n\tstruct airo_info *ai;\n\tint i, rc;\n\tCapabilityRid cap_rid;\n\n\t/* Create the network device object. */\n\tdev = alloc_netdev(sizeof(*ai), \"\", ether_setup);\n\tif (!dev) {\n\t\tairo_print_err(\"\", \"Couldn't alloc_etherdev\");\n\t\treturn NULL;\n\t}\n\n\tai = dev->ml_priv = netdev_priv(dev);\n\tai->wifidev = NULL;\n\tai->flags = 1 << FLAG_RADIO_DOWN;\n\tai->jobs = 0;\n\tai->dev = dev;\n\tif (pci && (pci->device == 0x5000 || pci->device == 0xa504)) {\n\t\tairo_print_dbg(\"\", \"Found an MPI350 card\");\n\t\tset_bit(FLAG_MPI, &ai->flags);\n\t}\n\tspin_lock_init(&ai->aux_lock);\n\tsema_init(&ai->sem, 1);\n\tai->config.len = 0;\n\tai->pci = pci;\n\tinit_waitqueue_head (&ai->thr_wait);\n\tai->tfm = NULL;\n\tadd_airo_dev(ai);\n\n\tif (airo_networks_allocate (ai))\n\t\tgoto err_out_free;\n\tairo_networks_initialize (ai);\n\n\tskb_queue_head_init (&ai->txq);\n\n\t/* The Airo-specific entries in the device structure. */\n\tif (test_bit(FLAG_MPI,&ai->flags))\n\t\tdev->netdev_ops = &mpi_netdev_ops;\n\telse\n\t\tdev->netdev_ops = &airo_netdev_ops;\n\tdev->wireless_handlers = &airo_handler_def;\n\tai->wireless_data.spy_data = &ai->spy_data;\n\tdev->wireless_data = &ai->wireless_data;\n\tdev->irq = irq;\n\tdev->base_addr = port;\n\n\tSET_NETDEV_DEV(dev, dmdev);\n\n\treset_card (dev, 1);\n\tmsleep(400);\n\n\tif (!is_pcmcia) {\n\t\tif (!request_region(dev->base_addr, 64, DRV_NAME)) {\n\t\t\trc = -EBUSY;\n\t\t\tairo_print_err(dev->name, \"Couldn't request region\");\n\t\t\tgoto err_out_nets;\n\t\t}\n\t}\n\n\tif (test_bit(FLAG_MPI,&ai->flags)) {\n\t\tif (mpi_map_card(ai, pci)) {\n\t\t\tairo_print_err(\"\", \"Could not map memory\");\n\t\t\tgoto err_out_res;\n\t\t}\n\t}\n\n\tif (probe) {\n\t\tif (setup_card(ai, dev->dev_addr, 1) != SUCCESS) {\n\t\t\tairo_print_err(dev->name, \"MAC could not be enabled\" );\n\t\t\trc = -EIO;\n\t\t\tgoto err_out_map;\n\t\t}\n\t} else if (!test_bit(FLAG_MPI,&ai->flags)) {\n\t\tai->bap_read = fast_bap_read;\n\t\tset_bit(FLAG_FLASHING, &ai->flags);\n\t}\n\n\tstrcpy(dev->name, \"eth%d\");\n\trc = register_netdev(dev);\n\tif (rc) {\n\t\tairo_print_err(dev->name, \"Couldn't register_netdev\");\n\t\tgoto err_out_map;\n\t}\n\tai->wifidev = init_wifidev(ai, dev);\n\tif (!ai->wifidev)\n\t\tgoto err_out_reg;\n\n\trc = readCapabilityRid(ai, &cap_rid, 1);\n\tif (rc != SUCCESS) {\n\t\trc = -EIO;\n\t\tgoto err_out_wifi;\n\t}\n\t/* WEP capability discovery */\n\tai->wep_capable = (cap_rid.softCap & cpu_to_le16(0x02)) ? 1 : 0;\n\tai->max_wep_idx = (cap_rid.softCap & cpu_to_le16(0x80)) ? 3 : 0;\n\n\tairo_print_info(dev->name, \"Firmware version %x.%x.%02d\",\n\t                ((le16_to_cpu(cap_rid.softVer) >> 8) & 0xF),\n\t                (le16_to_cpu(cap_rid.softVer) & 0xFF),\n\t                le16_to_cpu(cap_rid.softSubVer));\n\n\t/* Test for WPA support */\n\t/* Only firmware versions 5.30.17 or better can do WPA */\n\tif (le16_to_cpu(cap_rid.softVer) > 0x530\n\t || (le16_to_cpu(cap_rid.softVer) == 0x530\n\t      && le16_to_cpu(cap_rid.softSubVer) >= 17)) {\n\t\tairo_print_info(ai->dev->name, \"WPA supported.\");\n\n\t\tset_bit(FLAG_WPA_CAPABLE, &ai->flags);\n\t\tai->bssListFirst = RID_WPA_BSSLISTFIRST;\n\t\tai->bssListNext = RID_WPA_BSSLISTNEXT;\n\t\tai->bssListRidLen = sizeof(BSSListRid);\n\t} else {\n\t\tairo_print_info(ai->dev->name, \"WPA unsupported with firmware \"\n\t\t\t\"versions older than 5.30.17.\");\n\n\t\tai->bssListFirst = RID_BSSLISTFIRST;\n\t\tai->bssListNext = RID_BSSLISTNEXT;\n\t\tai->bssListRidLen = sizeof(BSSListRid) - sizeof(BSSListRidExtra);\n\t}\n\n\tset_bit(FLAG_REGISTERED,&ai->flags);\n\tairo_print_info(dev->name, \"MAC enabled %pM\", dev->dev_addr);\n\n\t/* Allocate the transmit buffers */\n\tif (probe && !test_bit(FLAG_MPI,&ai->flags))\n\t\tfor( i = 0; i < MAX_FIDS; i++ )\n\t\t\tai->fids[i] = transmit_allocate(ai,AIRO_DEF_MTU,i>=MAX_FIDS/2);\n\n\tif (setup_proc_entry(dev, dev->ml_priv) < 0)\n\t\tgoto err_out_wifi;\n\n\treturn dev;\n\nerr_out_wifi:\n\tunregister_netdev(ai->wifidev);\n\tfree_netdev(ai->wifidev);\nerr_out_reg:\n\tunregister_netdev(dev);\nerr_out_map:\n\tif (test_bit(FLAG_MPI,&ai->flags) && pci) {\n\t\tpci_free_consistent(pci, PCI_SHARED_LEN, ai->shared, ai->shared_dma);\n\t\tiounmap(ai->pciaux);\n\t\tiounmap(ai->pcimem);\n\t\tmpi_unmap_card(ai->pci);\n\t}\nerr_out_res:\n\tif (!is_pcmcia)\n\t        release_region( dev->base_addr, 64 );\nerr_out_nets:\n\tairo_networks_free(ai);\nerr_out_free:\n\tdel_airo_dev(ai);\n\tfree_netdev(dev);\n\treturn NULL;\n}\n\nstruct net_device *init_airo_card( unsigned short irq, int port, int is_pcmcia,\n\t\t\t\t  struct device *dmdev)\n{\n\treturn _init_airo_card ( irq, port, is_pcmcia, NULL, dmdev);\n}\n\nEXPORT_SYMBOL(init_airo_card);\n\nstatic int waitbusy (struct airo_info *ai) {\n\tint delay = 0;\n\twhile ((IN4500(ai, COMMAND) & COMMAND_BUSY) && (delay < 10000)) {\n\t\tudelay (10);\n\t\tif ((++delay % 20) == 0)\n\t\t\tOUT4500(ai, EVACK, EV_CLEARCOMMANDBUSY);\n\t}\n\treturn delay < 10000;\n}\n\nint reset_airo_card( struct net_device *dev )\n{\n\tint i;\n\tstruct airo_info *ai = dev->ml_priv;\n\n\tif (reset_card (dev, 1))\n\t\treturn -1;\n\n\tif ( setup_card(ai, dev->dev_addr, 1 ) != SUCCESS ) {\n\t\tairo_print_err(dev->name, \"MAC could not be enabled\");\n\t\treturn -1;\n\t}\n\tairo_print_info(dev->name, \"MAC enabled %pM\", dev->dev_addr);\n\t/* Allocate the transmit buffers if needed */\n\tif (!test_bit(FLAG_MPI,&ai->flags))\n\t\tfor( i = 0; i < MAX_FIDS; i++ )\n\t\t\tai->fids[i] = transmit_allocate (ai,AIRO_DEF_MTU,i>=MAX_FIDS/2);\n\n\tenable_interrupts( ai );\n\tnetif_wake_queue(dev);\n\treturn 0;\n}\n\nEXPORT_SYMBOL(reset_airo_card);\n\nstatic void airo_send_event(struct net_device *dev) {\n\tstruct airo_info *ai = dev->ml_priv;\n\tunion iwreq_data wrqu;\n\tStatusRid status_rid;\n\n\tclear_bit(JOB_EVENT, &ai->jobs);\n\tPC4500_readrid(ai, RID_STATUS, &status_rid, sizeof(status_rid), 0);\n\tup(&ai->sem);\n\twrqu.data.length = 0;\n\twrqu.data.flags = 0;\n\tmemcpy(wrqu.ap_addr.sa_data, status_rid.bssid[0], ETH_ALEN);\n\twrqu.ap_addr.sa_family = ARPHRD_ETHER;\n\n\t/* Send event to user space */\n\twireless_send_event(dev, SIOCGIWAP, &wrqu, NULL);\n}\n\nstatic void airo_process_scan_results (struct airo_info *ai) {\n\tunion iwreq_data\twrqu;\n\tBSSListRid bss;\n\tint rc;\n\tBSSListElement * loop_net;\n\tBSSListElement * tmp_net;\n\n\t/* Blow away current list of scan results */\n\tlist_for_each_entry_safe (loop_net, tmp_net, &ai->network_list, list) {\n\t\tlist_move_tail (&loop_net->list, &ai->network_free_list);\n\t\t/* Don't blow away ->list, just BSS data */\n\t\tmemset (loop_net, 0, sizeof (loop_net->bss));\n\t}\n\n\t/* Try to read the first entry of the scan result */\n\trc = PC4500_readrid(ai, ai->bssListFirst, &bss, ai->bssListRidLen, 0);\n\tif((rc) || (bss.index == cpu_to_le16(0xffff))) {\n\t\t/* No scan results */\n\t\tgoto out;\n\t}\n\n\t/* Read and parse all entries */\n\ttmp_net = NULL;\n\twhile((!rc) && (bss.index != cpu_to_le16(0xffff))) {\n\t\t/* Grab a network off the free list */\n\t\tif (!list_empty(&ai->network_free_list)) {\n\t\t\ttmp_net = list_entry(ai->network_free_list.next,\n\t\t\t\t\t    BSSListElement, list);\n\t\t\tlist_del(ai->network_free_list.next);\n\t\t}\n\n\t\tif (tmp_net != NULL) {\n\t\t\tmemcpy(tmp_net, &bss, sizeof(tmp_net->bss));\n\t\t\tlist_add_tail(&tmp_net->list, &ai->network_list);\n\t\t\ttmp_net = NULL;\n\t\t}\n\n\t\t/* Read next entry */\n\t\trc = PC4500_readrid(ai, ai->bssListNext,\n\t\t\t\t    &bss, ai->bssListRidLen, 0);\n\t}\n\nout:\n\tai->scan_timeout = 0;\n\tclear_bit(JOB_SCAN_RESULTS, &ai->jobs);\n\tup(&ai->sem);\n\n\t/* Send an empty event to user space.\n\t * We don't send the received data on\n\t * the event because it would require\n\t * us to do complex transcoding, and\n\t * we want to minimise the work done in\n\t * the irq handler. Use a request to\n\t * extract the data - Jean II */\n\twrqu.data.length = 0;\n\twrqu.data.flags = 0;\n\twireless_send_event(ai->dev, SIOCGIWSCAN, &wrqu, NULL);\n}\n\nstatic int airo_thread(void *data) {\n\tstruct net_device *dev = data;\n\tstruct airo_info *ai = dev->ml_priv;\n\tint locked;\n\n\tset_freezable();\n\twhile(1) {\n\t\t/* make swsusp happy with our thread */\n\t\ttry_to_freeze();\n\n\t\tif (test_bit(JOB_DIE, &ai->jobs))\n\t\t\tbreak;\n\n\t\tif (ai->jobs) {\n\t\t\tlocked = down_interruptible(&ai->sem);\n\t\t} else {\n\t\t\twait_queue_t wait;\n\n\t\t\tinit_waitqueue_entry(&wait, current);\n\t\t\tadd_wait_queue(&ai->thr_wait, &wait);\n\t\t\tfor (;;) {\n\t\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\t\tif (ai->jobs)\n\t\t\t\t\tbreak;\n\t\t\t\tif (ai->expires || ai->scan_timeout) {\n\t\t\t\t\tif (ai->scan_timeout &&\n\t\t\t\t\t\t\ttime_after_eq(jiffies,ai->scan_timeout)){\n\t\t\t\t\t\tset_bit(JOB_SCAN_RESULTS, &ai->jobs);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (ai->expires &&\n\t\t\t\t\t\t\ttime_after_eq(jiffies,ai->expires)){\n\t\t\t\t\t\tset_bit(JOB_AUTOWEP, &ai->jobs);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (!kthread_should_stop() &&\n\t\t\t\t\t    !freezing(current)) {\n\t\t\t\t\t\tunsigned long wake_at;\n\t\t\t\t\t\tif (!ai->expires || !ai->scan_timeout) {\n\t\t\t\t\t\t\twake_at = max(ai->expires,\n\t\t\t\t\t\t\t\tai->scan_timeout);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twake_at = min(ai->expires,\n\t\t\t\t\t\t\t\tai->scan_timeout);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tschedule_timeout(wake_at - jiffies);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else if (!kthread_should_stop() &&\n\t\t\t\t\t   !freezing(current)) {\n\t\t\t\t\tschedule();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent->state = TASK_RUNNING;\n\t\t\tremove_wait_queue(&ai->thr_wait, &wait);\n\t\t\tlocked = 1;\n\t\t}\n\n\t\tif (locked)\n\t\t\tcontinue;\n\n\t\tif (test_bit(JOB_DIE, &ai->jobs)) {\n\t\t\tup(&ai->sem);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ai->power.event || test_bit(FLAG_FLASHING, &ai->flags)) {\n\t\t\tup(&ai->sem);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (test_bit(JOB_XMIT, &ai->jobs))\n\t\t\tairo_end_xmit(dev);\n\t\telse if (test_bit(JOB_XMIT11, &ai->jobs))\n\t\t\tairo_end_xmit11(dev);\n\t\telse if (test_bit(JOB_STATS, &ai->jobs))\n\t\t\tairo_read_stats(dev);\n\t\telse if (test_bit(JOB_WSTATS, &ai->jobs))\n\t\t\tairo_read_wireless_stats(ai);\n\t\telse if (test_bit(JOB_PROMISC, &ai->jobs))\n\t\t\tairo_set_promisc(ai);\n\t\telse if (test_bit(JOB_MIC, &ai->jobs))\n\t\t\tmicinit(ai);\n\t\telse if (test_bit(JOB_EVENT, &ai->jobs))\n\t\t\tairo_send_event(dev);\n\t\telse if (test_bit(JOB_AUTOWEP, &ai->jobs))\n\t\t\ttimer_func(dev);\n\t\telse if (test_bit(JOB_SCAN_RESULTS, &ai->jobs))\n\t\t\tairo_process_scan_results(ai);\n\t\telse  /* Shouldn't get here, but we make sure to unlock */\n\t\t\tup(&ai->sem);\n\t}\n\n\treturn 0;\n}\n\nstatic int header_len(__le16 ctl)\n{\n\tu16 fc = le16_to_cpu(ctl);\n\tswitch (fc & 0xc) {\n\tcase 4:\n\t\tif ((fc & 0xe0) == 0xc0)\n\t\t\treturn 10;\t/* one-address control packet */\n\t\treturn 16;\t/* two-address control packet */\n\tcase 8:\n\t\tif ((fc & 0x300) == 0x300)\n\t\t\treturn 30;\t/* WDS packet */\n\t}\n\treturn 24;\n}\n\nstatic void airo_handle_cisco_mic(struct airo_info *ai)\n{\n\tif (test_bit(FLAG_MIC_CAPABLE, &ai->flags)) {\n\t\tset_bit(JOB_MIC, &ai->jobs);\n\t\twake_up_interruptible(&ai->thr_wait);\n\t}\n}\n\n/* Airo Status codes */\n#define STAT_NOBEACON\t0x8000 /* Loss of sync - missed beacons */\n#define STAT_MAXRETRIES\t0x8001 /* Loss of sync - max retries */\n#define STAT_MAXARL\t0x8002 /* Loss of sync - average retry level exceeded*/\n#define STAT_FORCELOSS\t0x8003 /* Loss of sync - host request */\n#define STAT_TSFSYNC\t0x8004 /* Loss of sync - TSF synchronization */\n#define STAT_DEAUTH\t0x8100 /* low byte is 802.11 reason code */\n#define STAT_DISASSOC\t0x8200 /* low byte is 802.11 reason code */\n#define STAT_ASSOC_FAIL\t0x8400 /* low byte is 802.11 reason code */\n#define STAT_AUTH_FAIL\t0x0300 /* low byte is 802.11 reason code */\n#define STAT_ASSOC\t0x0400 /* Associated */\n#define STAT_REASSOC    0x0600 /* Reassociated?  Only on firmware >= 5.30.17 */\n\nstatic void airo_print_status(const char *devname, u16 status)\n{\n\tu8 reason = status & 0xFF;\n\n\tswitch (status & 0xFF00) {\n\tcase STAT_NOBEACON:\n\t\tswitch (status) {\n\t\tcase STAT_NOBEACON:\n\t\t\tairo_print_dbg(devname, \"link lost (missed beacons)\");\n\t\t\tbreak;\n\t\tcase STAT_MAXRETRIES:\n\t\tcase STAT_MAXARL:\n\t\t\tairo_print_dbg(devname, \"link lost (max retries)\");\n\t\t\tbreak;\n\t\tcase STAT_FORCELOSS:\n\t\t\tairo_print_dbg(devname, \"link lost (local choice)\");\n\t\t\tbreak;\n\t\tcase STAT_TSFSYNC:\n\t\t\tairo_print_dbg(devname, \"link lost (TSF sync lost)\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tairo_print_dbg(devname, \"unknow status %x\\n\", status);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase STAT_DEAUTH:\n\t\tairo_print_dbg(devname, \"deauthenticated (reason: %d)\", reason);\n\t\tbreak;\n\tcase STAT_DISASSOC:\n\t\tairo_print_dbg(devname, \"disassociated (reason: %d)\", reason);\n\t\tbreak;\n\tcase STAT_ASSOC_FAIL:\n\t\tairo_print_dbg(devname, \"association failed (reason: %d)\",\n\t\t\t       reason);\n\t\tbreak;\n\tcase STAT_AUTH_FAIL:\n\t\tairo_print_dbg(devname, \"authentication failed (reason: %d)\",\n\t\t\t       reason);\n\t\tbreak;\n\tcase STAT_ASSOC:\n\tcase STAT_REASSOC:\n\t\tbreak;\n\tdefault:\n\t\tairo_print_dbg(devname, \"unknow status %x\\n\", status);\n\t\tbreak;\n\t}\n}\n\nstatic void airo_handle_link(struct airo_info *ai)\n{\n\tunion iwreq_data wrqu;\n\tint scan_forceloss = 0;\n\tu16 status;\n\n\t/* Get new status and acknowledge the link change */\n\tstatus = le16_to_cpu(IN4500(ai, LINKSTAT));\n\tOUT4500(ai, EVACK, EV_LINK);\n\n\tif ((status == STAT_FORCELOSS) && (ai->scan_timeout > 0))\n\t\tscan_forceloss = 1;\n\n\tairo_print_status(ai->dev->name, status);\n\n\tif ((status == STAT_ASSOC) || (status == STAT_REASSOC)) {\n\t\tif (auto_wep)\n\t\t\tai->expires = 0;\n\t\tif (ai->list_bss_task)\n\t\t\twake_up_process(ai->list_bss_task);\n\t\tset_bit(FLAG_UPDATE_UNI, &ai->flags);\n\t\tset_bit(FLAG_UPDATE_MULTI, &ai->flags);\n\n\t\tif (down_trylock(&ai->sem) != 0) {\n\t\t\tset_bit(JOB_EVENT, &ai->jobs);\n\t\t\twake_up_interruptible(&ai->thr_wait);\n\t\t} else\n\t\t\tairo_send_event(ai->dev);\n\t} else if (!scan_forceloss) {\n\t\tif (auto_wep && !ai->expires) {\n\t\t\tai->expires = RUN_AT(3*HZ);\n\t\t\twake_up_interruptible(&ai->thr_wait);\n\t\t}\n\n\t\t/* Send event to user space */\n\t\tmemset(wrqu.ap_addr.sa_data, '\\0', ETH_ALEN);\n\t\twrqu.ap_addr.sa_family = ARPHRD_ETHER;\n\t\twireless_send_event(ai->dev, SIOCGIWAP, &wrqu, NULL);\n\t}\n}\n\nstatic void airo_handle_rx(struct airo_info *ai)\n{\n\tstruct sk_buff *skb = NULL;\n\t__le16 fc, v, *buffer, tmpbuf[4];\n\tu16 len, hdrlen = 0, gap, fid;\n\tstruct rx_hdr hdr;\n\tint success = 0;\n\n\tif (test_bit(FLAG_MPI, &ai->flags)) {\n\t\tif (test_bit(FLAG_802_11, &ai->flags))\n\t\t\tmpi_receive_802_11(ai);\n\t\telse\n\t\t\tmpi_receive_802_3(ai);\n\t\tOUT4500(ai, EVACK, EV_RX);\n\t\treturn;\n\t}\n\n\tfid = IN4500(ai, RXFID);\n\n\t/* Get the packet length */\n\tif (test_bit(FLAG_802_11, &ai->flags)) {\n\t\tbap_setup (ai, fid, 4, BAP0);\n\t\tbap_read (ai, (__le16*)&hdr, sizeof(hdr), BAP0);\n\t\t/* Bad CRC. Ignore packet */\n\t\tif (le16_to_cpu(hdr.status) & 2)\n\t\t\thdr.len = 0;\n\t\tif (ai->wifidev == NULL)\n\t\t\thdr.len = 0;\n\t} else {\n\t\tbap_setup(ai, fid, 0x36, BAP0);\n\t\tbap_read(ai, &hdr.len, 2, BAP0);\n\t}\n\tlen = le16_to_cpu(hdr.len);\n\n\tif (len > AIRO_DEF_MTU) {\n\t\tairo_print_err(ai->dev->name, \"Bad size %d\", len);\n\t\tgoto done;\n\t}\n\tif (len == 0)\n\t\tgoto done;\n\n\tif (test_bit(FLAG_802_11, &ai->flags)) {\n\t\tbap_read(ai, &fc, sizeof (fc), BAP0);\n\t\thdrlen = header_len(fc);\n\t} else\n\t\thdrlen = ETH_ALEN * 2;\n\n\tskb = dev_alloc_skb(len + hdrlen + 2 + 2);\n\tif (!skb) {\n\t\tai->dev->stats.rx_dropped++;\n\t\tgoto done;\n\t}\n\n\tskb_reserve(skb, 2); /* This way the IP header is aligned */\n\tbuffer = (__le16 *) skb_put(skb, len + hdrlen);\n\tif (test_bit(FLAG_802_11, &ai->flags)) {\n\t\tbuffer[0] = fc;\n\t\tbap_read(ai, buffer + 1, hdrlen - 2, BAP0);\n\t\tif (hdrlen == 24)\n\t\t\tbap_read(ai, tmpbuf, 6, BAP0);\n\n\t\tbap_read(ai, &v, sizeof(v), BAP0);\n\t\tgap = le16_to_cpu(v);\n\t\tif (gap) {\n\t\t\tif (gap <= 8) {\n\t\t\t\tbap_read(ai, tmpbuf, gap, BAP0);\n\t\t\t} else {\n\t\t\t\tairo_print_err(ai->dev->name, \"gaplen too \"\n\t\t\t\t\t\"big. Problems will follow...\");\n\t\t\t}\n\t\t}\n\t\tbap_read(ai, buffer + hdrlen/2, len, BAP0);\n\t} else {\n\t\tMICBuffer micbuf;\n\n\t\tbap_read(ai, buffer, ETH_ALEN * 2, BAP0);\n\t\tif (ai->micstats.enabled) {\n\t\t\tbap_read(ai, (__le16 *) &micbuf, sizeof (micbuf), BAP0);\n\t\t\tif (ntohs(micbuf.typelen) > 0x05DC)\n\t\t\t\tbap_setup(ai, fid, 0x44, BAP0);\n\t\t\telse {\n\t\t\t\tif (len <= sizeof (micbuf)) {\n\t\t\t\t\tdev_kfree_skb_irq(skb);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tlen -= sizeof(micbuf);\n\t\t\t\tskb_trim(skb, len + hdrlen);\n\t\t\t}\n\t\t}\n\n\t\tbap_read(ai, buffer + ETH_ALEN, len, BAP0);\n\t\tif (decapsulate(ai, &micbuf, (etherHead*) buffer, len))\n\t\t\tdev_kfree_skb_irq (skb);\n\t\telse\n\t\t\tsuccess = 1;\n\t}\n\n#ifdef WIRELESS_SPY\n\tif (success && (ai->spy_data.spy_number > 0)) {\n\t\tchar *sa;\n\t\tstruct iw_quality wstats;\n\n\t\t/* Prepare spy data : addr + qual */\n\t\tif (!test_bit(FLAG_802_11, &ai->flags)) {\n\t\t\tsa = (char *) buffer + 6;\n\t\t\tbap_setup(ai, fid, 8, BAP0);\n\t\t\tbap_read(ai, (__le16 *) hdr.rssi, 2, BAP0);\n\t\t} else\n\t\t\tsa = (char *) buffer + 10;\n\t\twstats.qual = hdr.rssi[0];\n\t\tif (ai->rssi)\n\t\t\twstats.level = 0x100 - ai->rssi[hdr.rssi[1]].rssidBm;\n\t\telse\n\t\t\twstats.level = (hdr.rssi[1] + 321) / 2;\n\t\twstats.noise = ai->wstats.qual.noise;\n\t\twstats.updated =  IW_QUAL_LEVEL_UPDATED\n\t\t\t\t| IW_QUAL_QUAL_UPDATED\n\t\t\t\t| IW_QUAL_DBM;\n\t\t/* Update spy records */\n\t\twireless_spy_update(ai->dev, sa, &wstats);\n\t}\n#endif /* WIRELESS_SPY */\n\ndone:\n\tOUT4500(ai, EVACK, EV_RX);\n\n\tif (success) {\n\t\tif (test_bit(FLAG_802_11, &ai->flags)) {\n\t\t\tskb_reset_mac_header(skb);\n\t\t\tskb->pkt_type = PACKET_OTHERHOST;\n\t\t\tskb->dev = ai->wifidev;\n\t\t\tskb->protocol = htons(ETH_P_802_2);\n\t\t} else\n\t\t\tskb->protocol = eth_type_trans(skb, ai->dev);\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\n\t\tnetif_rx(skb);\n\t}\n}\n\nstatic void airo_handle_tx(struct airo_info *ai, u16 status)\n{\n\tint i, len = 0, index = -1;\n\tu16 fid;\n\n\tif (test_bit(FLAG_MPI, &ai->flags)) {\n\t\tunsigned long flags;\n\n\t\tif (status & EV_TXEXC)\n\t\t\tget_tx_error(ai, -1);\n\n\t\tspin_lock_irqsave(&ai->aux_lock, flags);\n\t\tif (!skb_queue_empty(&ai->txq)) {\n\t\t\tspin_unlock_irqrestore(&ai->aux_lock,flags);\n\t\t\tmpi_send_packet(ai->dev);\n\t\t} else {\n\t\t\tclear_bit(FLAG_PENDING_XMIT, &ai->flags);\n\t\t\tspin_unlock_irqrestore(&ai->aux_lock,flags);\n\t\t\tnetif_wake_queue(ai->dev);\n\t\t}\n\t\tOUT4500(ai, EVACK, status & (EV_TX | EV_TXCPY | EV_TXEXC));\n\t\treturn;\n\t}\n\n\tfid = IN4500(ai, TXCOMPLFID);\n\n\tfor(i = 0; i < MAX_FIDS; i++) {\n\t\tif ((ai->fids[i] & 0xffff) == fid) {\n\t\t\tlen = ai->fids[i] >> 16;\n\t\t\tindex = i;\n\t\t}\n\t}\n\n\tif (index != -1) {\n\t\tif (status & EV_TXEXC)\n\t\t\tget_tx_error(ai, index);\n\n\t\tOUT4500(ai, EVACK, status & (EV_TX | EV_TXEXC));\n\n\t\t/* Set up to be used again */\n\t\tai->fids[index] &= 0xffff;\n\t\tif (index < MAX_FIDS / 2) {\n\t\t\tif (!test_bit(FLAG_PENDING_XMIT, &ai->flags))\n\t\t\t\tnetif_wake_queue(ai->dev);\n\t\t} else {\n\t\t\tif (!test_bit(FLAG_PENDING_XMIT11, &ai->flags))\n\t\t\t\tnetif_wake_queue(ai->wifidev);\n\t\t}\n\t} else {\n\t\tOUT4500(ai, EVACK, status & (EV_TX | EV_TXCPY | EV_TXEXC));\n\t\tairo_print_err(ai->dev->name, \"Unallocated FID was used to xmit\");\n\t}\n}\n\nstatic irqreturn_t airo_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tu16 status, savedInterrupts = 0;\n\tstruct airo_info *ai = dev->ml_priv;\n\tint handled = 0;\n\n\tif (!netif_device_present(dev))\n\t\treturn IRQ_NONE;\n\n\tfor (;;) {\n\t\tstatus = IN4500(ai, EVSTAT);\n\t\tif (!(status & STATUS_INTS) || (status == 0xffff))\n\t\t\tbreak;\n\n\t\thandled = 1;\n\n\t\tif (status & EV_AWAKE) {\n\t\t\tOUT4500(ai, EVACK, EV_AWAKE);\n\t\t\tOUT4500(ai, EVACK, EV_AWAKE);\n\t\t}\n\n\t\tif (!savedInterrupts) {\n\t\t\tsavedInterrupts = IN4500(ai, EVINTEN);\n\t\t\tOUT4500(ai, EVINTEN, 0);\n\t\t}\n\n\t\tif (status & EV_MIC) {\n\t\t\tOUT4500(ai, EVACK, EV_MIC);\n\t\t\tairo_handle_cisco_mic(ai);\n\t\t}\n\n\t\tif (status & EV_LINK) {\n\t\t\t/* Link status changed */\n\t\t\tairo_handle_link(ai);\n\t\t}\n\n\t\t/* Check to see if there is something to receive */\n\t\tif (status & EV_RX)\n\t\t\tairo_handle_rx(ai);\n\n\t\t/* Check to see if a packet has been transmitted */\n\t\tif (status & (EV_TX | EV_TXCPY | EV_TXEXC))\n\t\t\tairo_handle_tx(ai, status);\n\n\t\tif ( status & ~STATUS_INTS & ~IGNORE_INTS ) {\n\t\t\tairo_print_warn(ai->dev->name, \"Got weird status %x\",\n\t\t\t\tstatus & ~STATUS_INTS & ~IGNORE_INTS );\n\t\t}\n\t}\n\n\tif (savedInterrupts)\n\t\tOUT4500(ai, EVINTEN, savedInterrupts);\n\n\treturn IRQ_RETVAL(handled);\n}\n\n/*\n *  Routines to talk to the card\n */\n\n/*\n *  This was originally written for the 4500, hence the name\n *  NOTE:  If use with 8bit mode and SMP bad things will happen!\n *         Why would some one do 8 bit IO in an SMP machine?!?\n */\nstatic void OUT4500( struct airo_info *ai, u16 reg, u16 val ) {\n\tif (test_bit(FLAG_MPI,&ai->flags))\n\t\treg <<= 1;\n\tif ( !do8bitIO )\n\t\toutw( val, ai->dev->base_addr + reg );\n\telse {\n\t\toutb( val & 0xff, ai->dev->base_addr + reg );\n\t\toutb( val >> 8, ai->dev->base_addr + reg + 1 );\n\t}\n}\n\nstatic u16 IN4500( struct airo_info *ai, u16 reg ) {\n\tunsigned short rc;\n\n\tif (test_bit(FLAG_MPI,&ai->flags))\n\t\treg <<= 1;\n\tif ( !do8bitIO )\n\t\trc = inw( ai->dev->base_addr + reg );\n\telse {\n\t\trc = inb( ai->dev->base_addr + reg );\n\t\trc += ((int)inb( ai->dev->base_addr + reg + 1 )) << 8;\n\t}\n\treturn rc;\n}\n\nstatic int enable_MAC(struct airo_info *ai, int lock)\n{\n\tint rc;\n\tCmd cmd;\n\tResp rsp;\n\n\t/* FLAG_RADIO_OFF : Radio disabled via /proc or Wireless Extensions\n\t * FLAG_RADIO_DOWN : Radio disabled via \"ifconfig ethX down\"\n\t * Note : we could try to use !netif_running(dev) in enable_MAC()\n\t * instead of this flag, but I don't trust it *within* the\n\t * open/close functions, and testing both flags together is\n\t * \"cheaper\" - Jean II */\n\tif (ai->flags & FLAG_RADIO_MASK) return SUCCESS;\n\n\tif (lock && down_interruptible(&ai->sem))\n\t\treturn -ERESTARTSYS;\n\n\tif (!test_bit(FLAG_ENABLED, &ai->flags)) {\n\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\tcmd.cmd = MAC_ENABLE;\n\t\trc = issuecommand(ai, &cmd, &rsp);\n\t\tif (rc == SUCCESS)\n\t\t\tset_bit(FLAG_ENABLED, &ai->flags);\n\t} else\n\t\trc = SUCCESS;\n\n\tif (lock)\n\t    up(&ai->sem);\n\n\tif (rc)\n\t\tairo_print_err(ai->dev->name, \"Cannot enable MAC\");\n\telse if ((rsp.status & 0xFF00) != 0) {\n\t\tairo_print_err(ai->dev->name, \"Bad MAC enable reason=%x, \"\n\t\t\t\"rid=%x, offset=%d\", rsp.rsp0, rsp.rsp1, rsp.rsp2);\n\t\trc = ERROR;\n\t}\n\treturn rc;\n}\n\nstatic void disable_MAC( struct airo_info *ai, int lock ) {\n        Cmd cmd;\n\tResp rsp;\n\n\tif (lock && down_interruptible(&ai->sem))\n\t\treturn;\n\n\tif (test_bit(FLAG_ENABLED, &ai->flags)) {\n\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\tcmd.cmd = MAC_DISABLE; // disable in case already enabled\n\t\tissuecommand(ai, &cmd, &rsp);\n\t\tclear_bit(FLAG_ENABLED, &ai->flags);\n\t}\n\tif (lock)\n\t\tup(&ai->sem);\n}\n\nstatic void enable_interrupts( struct airo_info *ai ) {\n\t/* Enable the interrupts */\n\tOUT4500( ai, EVINTEN, STATUS_INTS );\n}\n\nstatic void disable_interrupts( struct airo_info *ai ) {\n\tOUT4500( ai, EVINTEN, 0 );\n}\n\nstatic void mpi_receive_802_3(struct airo_info *ai)\n{\n\tRxFid rxd;\n\tint len = 0;\n\tstruct sk_buff *skb;\n\tchar *buffer;\n\tint off = 0;\n\tMICBuffer micbuf;\n\n\tmemcpy_fromio(&rxd, ai->rxfids[0].card_ram_off, sizeof(rxd));\n\t/* Make sure we got something */\n\tif (rxd.rdy && rxd.valid == 0) {\n\t\tlen = rxd.len + 12;\n\t\tif (len < 12 || len > 2048)\n\t\t\tgoto badrx;\n\n\t\tskb = dev_alloc_skb(len);\n\t\tif (!skb) {\n\t\t\tai->dev->stats.rx_dropped++;\n\t\t\tgoto badrx;\n\t\t}\n\t\tbuffer = skb_put(skb,len);\n\t\tmemcpy(buffer, ai->rxfids[0].virtual_host_addr, ETH_ALEN * 2);\n\t\tif (ai->micstats.enabled) {\n\t\t\tmemcpy(&micbuf,\n\t\t\t\tai->rxfids[0].virtual_host_addr + ETH_ALEN * 2,\n\t\t\t\tsizeof(micbuf));\n\t\t\tif (ntohs(micbuf.typelen) <= 0x05DC) {\n\t\t\t\tif (len <= sizeof(micbuf) + ETH_ALEN * 2)\n\t\t\t\t\tgoto badmic;\n\n\t\t\t\toff = sizeof(micbuf);\n\t\t\t\tskb_trim (skb, len - off);\n\t\t\t}\n\t\t}\n\t\tmemcpy(buffer + ETH_ALEN * 2,\n\t\t\tai->rxfids[0].virtual_host_addr + ETH_ALEN * 2 + off,\n\t\t\tlen - ETH_ALEN * 2 - off);\n\t\tif (decapsulate (ai, &micbuf, (etherHead*)buffer, len - off - ETH_ALEN * 2)) {\nbadmic:\n\t\t\tdev_kfree_skb_irq (skb);\n\t\t\tgoto badrx;\n\t\t}\n#ifdef WIRELESS_SPY\n\t\tif (ai->spy_data.spy_number > 0) {\n\t\t\tchar *sa;\n\t\t\tstruct iw_quality wstats;\n\t\t\t/* Prepare spy data : addr + qual */\n\t\t\tsa = buffer + ETH_ALEN;\n\t\t\twstats.qual = 0; /* XXX Where do I get that info from ??? */\n\t\t\twstats.level = 0;\n\t\t\twstats.updated = 0;\n\t\t\t/* Update spy records */\n\t\t\twireless_spy_update(ai->dev, sa, &wstats);\n\t\t}\n#endif /* WIRELESS_SPY */\n\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\tskb->protocol = eth_type_trans(skb, ai->dev);\n\t\tnetif_rx(skb);\n\t}\nbadrx:\n\tif (rxd.valid == 0) {\n\t\trxd.valid = 1;\n\t\trxd.rdy = 0;\n\t\trxd.len = PKTSIZE;\n\t\tmemcpy_toio(ai->rxfids[0].card_ram_off, &rxd, sizeof(rxd));\n\t}\n}\n\nstatic void mpi_receive_802_11(struct airo_info *ai)\n{\n\tRxFid rxd;\n\tstruct sk_buff *skb = NULL;\n\tu16 len, hdrlen = 0;\n\t__le16 fc;\n\tstruct rx_hdr hdr;\n\tu16 gap;\n\tu16 *buffer;\n\tchar *ptr = ai->rxfids[0].virtual_host_addr + 4;\n\n\tmemcpy_fromio(&rxd, ai->rxfids[0].card_ram_off, sizeof(rxd));\n\tmemcpy ((char *)&hdr, ptr, sizeof(hdr));\n\tptr += sizeof(hdr);\n\t/* Bad CRC. Ignore packet */\n\tif (le16_to_cpu(hdr.status) & 2)\n\t\thdr.len = 0;\n\tif (ai->wifidev == NULL)\n\t\thdr.len = 0;\n\tlen = le16_to_cpu(hdr.len);\n\tif (len > AIRO_DEF_MTU) {\n\t\tairo_print_err(ai->dev->name, \"Bad size %d\", len);\n\t\tgoto badrx;\n\t}\n\tif (len == 0)\n\t\tgoto badrx;\n\n\tfc = get_unaligned((__le16 *)ptr);\n\thdrlen = header_len(fc);\n\n\tskb = dev_alloc_skb( len + hdrlen + 2 );\n\tif ( !skb ) {\n\t\tai->dev->stats.rx_dropped++;\n\t\tgoto badrx;\n\t}\n\tbuffer = (u16*)skb_put (skb, len + hdrlen);\n\tmemcpy ((char *)buffer, ptr, hdrlen);\n\tptr += hdrlen;\n\tif (hdrlen == 24)\n\t\tptr += 6;\n\tgap = get_unaligned_le16(ptr);\n\tptr += sizeof(__le16);\n\tif (gap) {\n\t\tif (gap <= 8)\n\t\t\tptr += gap;\n\t\telse\n\t\t\tairo_print_err(ai->dev->name,\n\t\t\t    \"gaplen too big. Problems will follow...\");\n\t}\n\tmemcpy ((char *)buffer + hdrlen, ptr, len);\n\tptr += len;\n#ifdef IW_WIRELESS_SPY\t  /* defined in iw_handler.h */\n\tif (ai->spy_data.spy_number > 0) {\n\t\tchar *sa;\n\t\tstruct iw_quality wstats;\n\t\t/* Prepare spy data : addr + qual */\n\t\tsa = (char*)buffer + 10;\n\t\twstats.qual = hdr.rssi[0];\n\t\tif (ai->rssi)\n\t\t\twstats.level = 0x100 - ai->rssi[hdr.rssi[1]].rssidBm;\n\t\telse\n\t\t\twstats.level = (hdr.rssi[1] + 321) / 2;\n\t\twstats.noise = ai->wstats.qual.noise;\n\t\twstats.updated = IW_QUAL_QUAL_UPDATED\n\t\t\t| IW_QUAL_LEVEL_UPDATED\n\t\t\t| IW_QUAL_DBM;\n\t\t/* Update spy records */\n\t\twireless_spy_update(ai->dev, sa, &wstats);\n\t}\n#endif /* IW_WIRELESS_SPY */\n\tskb_reset_mac_header(skb);\n\tskb->pkt_type = PACKET_OTHERHOST;\n\tskb->dev = ai->wifidev;\n\tskb->protocol = htons(ETH_P_802_2);\n\tskb->ip_summed = CHECKSUM_NONE;\n\tnetif_rx( skb );\n\nbadrx:\n\tif (rxd.valid == 0) {\n\t\trxd.valid = 1;\n\t\trxd.rdy = 0;\n\t\trxd.len = PKTSIZE;\n\t\tmemcpy_toio(ai->rxfids[0].card_ram_off, &rxd, sizeof(rxd));\n\t}\n}\n\nstatic u16 setup_card(struct airo_info *ai, u8 *mac, int lock)\n{\n\tCmd cmd;\n\tResp rsp;\n\tint status;\n\tSsidRid mySsid;\n\t__le16 lastindex;\n\tWepKeyRid wkr;\n\tint rc;\n\n\tmemset( &mySsid, 0, sizeof( mySsid ) );\n\tkfree (ai->flash);\n\tai->flash = NULL;\n\n\t/* The NOP is the first step in getting the card going */\n\tcmd.cmd = NOP;\n\tcmd.parm0 = cmd.parm1 = cmd.parm2 = 0;\n\tif (lock && down_interruptible(&ai->sem))\n\t\treturn ERROR;\n\tif ( issuecommand( ai, &cmd, &rsp ) != SUCCESS ) {\n\t\tif (lock)\n\t\t\tup(&ai->sem);\n\t\treturn ERROR;\n\t}\n\tdisable_MAC( ai, 0);\n\n\t// Let's figure out if we need to use the AUX port\n\tif (!test_bit(FLAG_MPI,&ai->flags)) {\n\t\tcmd.cmd = CMD_ENABLEAUX;\n\t\tif (issuecommand(ai, &cmd, &rsp) != SUCCESS) {\n\t\t\tif (lock)\n\t\t\t\tup(&ai->sem);\n\t\t\tairo_print_err(ai->dev->name, \"Error checking for AUX port\");\n\t\t\treturn ERROR;\n\t\t}\n\t\tif (!aux_bap || rsp.status & 0xff00) {\n\t\t\tai->bap_read = fast_bap_read;\n\t\t\tairo_print_dbg(ai->dev->name, \"Doing fast bap_reads\");\n\t\t} else {\n\t\t\tai->bap_read = aux_bap_read;\n\t\t\tairo_print_dbg(ai->dev->name, \"Doing AUX bap_reads\");\n\t\t}\n\t}\n\tif (lock)\n\t\tup(&ai->sem);\n\tif (ai->config.len == 0) {\n\t\tint i;\n\t\ttdsRssiRid rssi_rid;\n\t\tCapabilityRid cap_rid;\n\n\t\tkfree(ai->APList);\n\t\tai->APList = NULL;\n\t\tkfree(ai->SSID);\n\t\tai->SSID = NULL;\n\t\t// general configuration (read/modify/write)\n\t\tstatus = readConfigRid(ai, lock);\n\t\tif ( status != SUCCESS ) return ERROR;\n\n\t\tstatus = readCapabilityRid(ai, &cap_rid, lock);\n\t\tif ( status != SUCCESS ) return ERROR;\n\n\t\tstatus = PC4500_readrid(ai,RID_RSSI,&rssi_rid,sizeof(rssi_rid),lock);\n\t\tif ( status == SUCCESS ) {\n\t\t\tif (ai->rssi || (ai->rssi = kmalloc(512, GFP_KERNEL)) != NULL)\n\t\t\t\tmemcpy(ai->rssi, (u8*)&rssi_rid + 2, 512); /* Skip RID length member */\n\t\t}\n\t\telse {\n\t\t\tkfree(ai->rssi);\n\t\t\tai->rssi = NULL;\n\t\t\tif (cap_rid.softCap & cpu_to_le16(8))\n\t\t\t\tai->config.rmode |= RXMODE_NORMALIZED_RSSI;\n\t\t\telse\n\t\t\t\tairo_print_warn(ai->dev->name, \"unknown received signal \"\n\t\t\t\t\t\t\"level scale\");\n\t\t}\n\t\tai->config.opmode = adhoc ? MODE_STA_IBSS : MODE_STA_ESS;\n\t\tai->config.authType = AUTH_OPEN;\n\t\tai->config.modulation = MOD_CCK;\n\n\t\tif (le16_to_cpu(cap_rid.len) >= sizeof(cap_rid) &&\n\t\t    (cap_rid.extSoftCap & cpu_to_le16(1)) &&\n\t\t    micsetup(ai) == SUCCESS) {\n\t\t\tai->config.opmode |= MODE_MIC;\n\t\t\tset_bit(FLAG_MIC_CAPABLE, &ai->flags);\n\t\t}\n\n\t\t/* Save off the MAC */\n\t\tfor( i = 0; i < ETH_ALEN; i++ ) {\n\t\t\tmac[i] = ai->config.macAddr[i];\n\t\t}\n\n\t\t/* Check to see if there are any insmod configured\n\t\t   rates to add */\n\t\tif ( rates[0] ) {\n\t\t\tmemset(ai->config.rates,0,sizeof(ai->config.rates));\n\t\t\tfor( i = 0; i < 8 && rates[i]; i++ ) {\n\t\t\t\tai->config.rates[i] = rates[i];\n\t\t\t}\n\t\t}\n\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t}\n\n\t/* Setup the SSIDs if present */\n\tif ( ssids[0] ) {\n\t\tint i;\n\t\tfor( i = 0; i < 3 && ssids[i]; i++ ) {\n\t\t\tsize_t len = strlen(ssids[i]);\n\t\t\tif (len > 32)\n\t\t\t\tlen = 32;\n\t\t\tmySsid.ssids[i].len = cpu_to_le16(len);\n\t\t\tmemcpy(mySsid.ssids[i].ssid, ssids[i], len);\n\t\t}\n\t\tmySsid.len = cpu_to_le16(sizeof(mySsid));\n\t}\n\n\tstatus = writeConfigRid(ai, lock);\n\tif ( status != SUCCESS ) return ERROR;\n\n\t/* Set up the SSID list */\n\tif ( ssids[0] ) {\n\t\tstatus = writeSsidRid(ai, &mySsid, lock);\n\t\tif ( status != SUCCESS ) return ERROR;\n\t}\n\n\tstatus = enable_MAC(ai, lock);\n\tif (status != SUCCESS)\n\t\treturn ERROR;\n\n\t/* Grab the initial wep key, we gotta save it for auto_wep */\n\trc = readWepKeyRid(ai, &wkr, 1, lock);\n\tif (rc == SUCCESS) do {\n\t\tlastindex = wkr.kindex;\n\t\tif (wkr.kindex == cpu_to_le16(0xffff)) {\n\t\t\tai->defindex = wkr.mac[0];\n\t\t}\n\t\trc = readWepKeyRid(ai, &wkr, 0, lock);\n\t} while(lastindex != wkr.kindex);\n\n\ttry_auto_wep(ai);\n\n\treturn SUCCESS;\n}\n\nstatic u16 issuecommand(struct airo_info *ai, Cmd *pCmd, Resp *pRsp) {\n        // Im really paranoid about letting it run forever!\n\tint max_tries = 600000;\n\n\tif (IN4500(ai, EVSTAT) & EV_CMD)\n\t\tOUT4500(ai, EVACK, EV_CMD);\n\n\tOUT4500(ai, PARAM0, pCmd->parm0);\n\tOUT4500(ai, PARAM1, pCmd->parm1);\n\tOUT4500(ai, PARAM2, pCmd->parm2);\n\tOUT4500(ai, COMMAND, pCmd->cmd);\n\n\twhile (max_tries-- && (IN4500(ai, EVSTAT) & EV_CMD) == 0) {\n\t\tif ((IN4500(ai, COMMAND)) == pCmd->cmd)\n\t\t\t// PC4500 didn't notice command, try again\n\t\t\tOUT4500(ai, COMMAND, pCmd->cmd);\n\t\tif (!in_atomic() && (max_tries & 255) == 0)\n\t\t\tschedule();\n\t}\n\n\tif ( max_tries == -1 ) {\n\t\tairo_print_err(ai->dev->name,\n\t\t\t\"Max tries exceeded when issuing command\");\n\t\tif (IN4500(ai, COMMAND) & COMMAND_BUSY)\n\t\t\tOUT4500(ai, EVACK, EV_CLEARCOMMANDBUSY);\n\t\treturn ERROR;\n\t}\n\n\t// command completed\n\tpRsp->status = IN4500(ai, STATUS);\n\tpRsp->rsp0 = IN4500(ai, RESP0);\n\tpRsp->rsp1 = IN4500(ai, RESP1);\n\tpRsp->rsp2 = IN4500(ai, RESP2);\n\tif ((pRsp->status & 0xff00)!=0 && pCmd->cmd != CMD_SOFTRESET)\n\t\tairo_print_err(ai->dev->name,\n\t\t\t\"cmd:%x status:%x rsp0:%x rsp1:%x rsp2:%x\",\n\t\t\tpCmd->cmd, pRsp->status, pRsp->rsp0, pRsp->rsp1,\n\t\t\tpRsp->rsp2);\n\n\t// clear stuck command busy if necessary\n\tif (IN4500(ai, COMMAND) & COMMAND_BUSY) {\n\t\tOUT4500(ai, EVACK, EV_CLEARCOMMANDBUSY);\n\t}\n\t// acknowledge processing the status/response\n\tOUT4500(ai, EVACK, EV_CMD);\n\n\treturn SUCCESS;\n}\n\n/* Sets up the bap to start exchange data.  whichbap should\n * be one of the BAP0 or BAP1 defines.  Locks should be held before\n * calling! */\nstatic int bap_setup(struct airo_info *ai, u16 rid, u16 offset, int whichbap )\n{\n\tint timeout = 50;\n\tint max_tries = 3;\n\n\tOUT4500(ai, SELECT0+whichbap, rid);\n\tOUT4500(ai, OFFSET0+whichbap, offset);\n\twhile (1) {\n\t\tint status = IN4500(ai, OFFSET0+whichbap);\n\t\tif (status & BAP_BUSY) {\n                        /* This isn't really a timeout, but its kinda\n\t\t\t   close */\n\t\t\tif (timeout--) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if ( status & BAP_ERR ) {\n\t\t\t/* invalid rid or offset */\n\t\t\tairo_print_err(ai->dev->name, \"BAP error %x %d\",\n\t\t\t\tstatus, whichbap );\n\t\t\treturn ERROR;\n\t\t} else if (status & BAP_DONE) { // success\n\t\t\treturn SUCCESS;\n\t\t}\n\t\tif ( !(max_tries--) ) {\n\t\t\tairo_print_err(ai->dev->name,\n\t\t\t\t\"BAP setup error too many retries\\n\");\n\t\t\treturn ERROR;\n\t\t}\n\t\t// -- PC4500 missed it, try again\n\t\tOUT4500(ai, SELECT0+whichbap, rid);\n\t\tOUT4500(ai, OFFSET0+whichbap, offset);\n\t\ttimeout = 50;\n\t}\n}\n\n/* should only be called by aux_bap_read.  This aux function and the\n   following use concepts not documented in the developers guide.  I\n   got them from a patch given to my by Aironet */\nstatic u16 aux_setup(struct airo_info *ai, u16 page,\n\t\t     u16 offset, u16 *len)\n{\n\tu16 next;\n\n\tOUT4500(ai, AUXPAGE, page);\n\tOUT4500(ai, AUXOFF, 0);\n\tnext = IN4500(ai, AUXDATA);\n\t*len = IN4500(ai, AUXDATA)&0xff;\n\tif (offset != 4) OUT4500(ai, AUXOFF, offset);\n\treturn next;\n}\n\n/* requires call to bap_setup() first */\nstatic int aux_bap_read(struct airo_info *ai, __le16 *pu16Dst,\n\t\t\tint bytelen, int whichbap)\n{\n\tu16 len;\n\tu16 page;\n\tu16 offset;\n\tu16 next;\n\tint words;\n\tint i;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ai->aux_lock, flags);\n\tpage = IN4500(ai, SWS0+whichbap);\n\toffset = IN4500(ai, SWS2+whichbap);\n\tnext = aux_setup(ai, page, offset, &len);\n\twords = (bytelen+1)>>1;\n\n\tfor (i=0; i<words;) {\n\t\tint count;\n\t\tcount = (len>>1) < (words-i) ? (len>>1) : (words-i);\n\t\tif ( !do8bitIO )\n\t\t\tinsw( ai->dev->base_addr+DATA0+whichbap,\n\t\t\t      pu16Dst+i,count );\n\t\telse\n\t\t\tinsb( ai->dev->base_addr+DATA0+whichbap,\n\t\t\t      pu16Dst+i, count << 1 );\n\t\ti += count;\n\t\tif (i<words) {\n\t\t\tnext = aux_setup(ai, next, 4, &len);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ai->aux_lock, flags);\n\treturn SUCCESS;\n}\n\n\n/* requires call to bap_setup() first */\nstatic int fast_bap_read(struct airo_info *ai, __le16 *pu16Dst,\n\t\t\t int bytelen, int whichbap)\n{\n\tbytelen = (bytelen + 1) & (~1); // round up to even value\n\tif ( !do8bitIO )\n\t\tinsw( ai->dev->base_addr+DATA0+whichbap, pu16Dst, bytelen>>1 );\n\telse\n\t\tinsb( ai->dev->base_addr+DATA0+whichbap, pu16Dst, bytelen );\n\treturn SUCCESS;\n}\n\n/* requires call to bap_setup() first */\nstatic int bap_write(struct airo_info *ai, const __le16 *pu16Src,\n\t\t     int bytelen, int whichbap)\n{\n\tbytelen = (bytelen + 1) & (~1); // round up to even value\n\tif ( !do8bitIO )\n\t\toutsw( ai->dev->base_addr+DATA0+whichbap,\n\t\t       pu16Src, bytelen>>1 );\n\telse\n\t\toutsb( ai->dev->base_addr+DATA0+whichbap, pu16Src, bytelen );\n\treturn SUCCESS;\n}\n\nstatic int PC4500_accessrid(struct airo_info *ai, u16 rid, u16 accmd)\n{\n\tCmd cmd; /* for issuing commands */\n\tResp rsp; /* response from commands */\n\tu16 status;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.cmd = accmd;\n\tcmd.parm0 = rid;\n\tstatus = issuecommand(ai, &cmd, &rsp);\n\tif (status != 0) return status;\n\tif ( (rsp.status & 0x7F00) != 0) {\n\t\treturn (accmd << 8) + (rsp.rsp0 & 0xFF);\n\t}\n\treturn 0;\n}\n\n/*  Note, that we are using BAP1 which is also used by transmit, so\n *  we must get a lock. */\nstatic int PC4500_readrid(struct airo_info *ai, u16 rid, void *pBuf, int len, int lock)\n{\n\tu16 status;\n        int rc = SUCCESS;\n\n\tif (lock) {\n\t\tif (down_interruptible(&ai->sem))\n\t\t\treturn ERROR;\n\t}\n\tif (test_bit(FLAG_MPI,&ai->flags)) {\n\t\tCmd cmd;\n\t\tResp rsp;\n\n\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\tmemset(&rsp, 0, sizeof(rsp));\n\t\tai->config_desc.rid_desc.valid = 1;\n\t\tai->config_desc.rid_desc.len = RIDSIZE;\n\t\tai->config_desc.rid_desc.rid = 0;\n\t\tai->config_desc.rid_desc.host_addr = ai->ridbus;\n\n\t\tcmd.cmd = CMD_ACCESS;\n\t\tcmd.parm0 = rid;\n\n\t\tmemcpy_toio(ai->config_desc.card_ram_off,\n\t\t\t&ai->config_desc.rid_desc, sizeof(Rid));\n\n\t\trc = issuecommand(ai, &cmd, &rsp);\n\n\t\tif (rsp.status & 0x7f00)\n\t\t\trc = rsp.rsp0;\n\t\tif (!rc)\n\t\t\tmemcpy(pBuf, ai->config_desc.virtual_host_addr, len);\n\t\tgoto done;\n\t} else {\n\t\tif ((status = PC4500_accessrid(ai, rid, CMD_ACCESS))!=SUCCESS) {\n\t                rc = status;\n\t                goto done;\n\t        }\n\t\tif (bap_setup(ai, rid, 0, BAP1) != SUCCESS) {\n\t\t\trc = ERROR;\n\t                goto done;\n\t        }\n\t\t// read the rid length field\n\t\tbap_read(ai, pBuf, 2, BAP1);\n\t\t// length for remaining part of rid\n\t\tlen = min(len, (int)le16_to_cpu(*(__le16*)pBuf)) - 2;\n\n\t\tif ( len <= 2 ) {\n\t\t\tairo_print_err(ai->dev->name,\n\t\t\t\t\"Rid %x has a length of %d which is too short\",\n\t\t\t\t(int)rid, (int)len );\n\t\t\trc = ERROR;\n\t                goto done;\n\t\t}\n\t\t// read remainder of the rid\n\t\trc = bap_read(ai, ((__le16*)pBuf)+1, len, BAP1);\n\t}\ndone:\n\tif (lock)\n\t\tup(&ai->sem);\n\treturn rc;\n}\n\n/*  Note, that we are using BAP1 which is also used by transmit, so\n *  make sure this isn't called when a transmit is happening */\nstatic int PC4500_writerid(struct airo_info *ai, u16 rid,\n\t\t\t   const void *pBuf, int len, int lock)\n{\n\tu16 status;\n\tint rc = SUCCESS;\n\n\t*(__le16*)pBuf = cpu_to_le16((u16)len);\n\n\tif (lock) {\n\t\tif (down_interruptible(&ai->sem))\n\t\t\treturn ERROR;\n\t}\n\tif (test_bit(FLAG_MPI,&ai->flags)) {\n\t\tCmd cmd;\n\t\tResp rsp;\n\n\t\tif (test_bit(FLAG_ENABLED, &ai->flags) && (RID_WEP_TEMP != rid))\n\t\t\tairo_print_err(ai->dev->name,\n\t\t\t\t\"%s: MAC should be disabled (rid=%04x)\",\n\t\t\t\t__func__, rid);\n\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\tmemset(&rsp, 0, sizeof(rsp));\n\n\t\tai->config_desc.rid_desc.valid = 1;\n\t\tai->config_desc.rid_desc.len = *((u16 *)pBuf);\n\t\tai->config_desc.rid_desc.rid = 0;\n\n\t\tcmd.cmd = CMD_WRITERID;\n\t\tcmd.parm0 = rid;\n\n\t\tmemcpy_toio(ai->config_desc.card_ram_off,\n\t\t\t&ai->config_desc.rid_desc, sizeof(Rid));\n\n\t\tif (len < 4 || len > 2047) {\n\t\t\tairo_print_err(ai->dev->name, \"%s: len=%d\", __func__, len);\n\t\t\trc = -1;\n\t\t} else {\n\t\t\tmemcpy((char *)ai->config_desc.virtual_host_addr,\n\t\t\t\tpBuf, len);\n\n\t\t\trc = issuecommand(ai, &cmd, &rsp);\n\t\t\tif ((rc & 0xff00) != 0) {\n\t\t\t\tairo_print_err(ai->dev->name, \"%s: Write rid Error %d\",\n\t\t\t\t\t\t__func__, rc);\n\t\t\t\tairo_print_err(ai->dev->name, \"%s: Cmd=%04x\",\n\t\t\t\t\t\t__func__, cmd.cmd);\n\t\t\t}\n\n\t\t\tif ((rsp.status & 0x7f00))\n\t\t\t\trc = rsp.rsp0;\n\t\t}\n\t} else {\n\t\t// --- first access so that we can write the rid data\n\t\tif ( (status = PC4500_accessrid(ai, rid, CMD_ACCESS)) != 0) {\n\t                rc = status;\n\t                goto done;\n\t        }\n\t\t// --- now write the rid data\n\t\tif (bap_setup(ai, rid, 0, BAP1) != SUCCESS) {\n\t                rc = ERROR;\n\t                goto done;\n\t        }\n\t\tbap_write(ai, pBuf, len, BAP1);\n\t\t// ---now commit the rid data\n\t\trc = PC4500_accessrid(ai, rid, 0x100|CMD_ACCESS);\n\t}\ndone:\n\tif (lock)\n\t\tup(&ai->sem);\n        return rc;\n}\n\n/* Allocates a FID to be used for transmitting packets.  We only use\n   one for now. */\nstatic u16 transmit_allocate(struct airo_info *ai, int lenPayload, int raw)\n{\n\tunsigned int loop = 3000;\n\tCmd cmd;\n\tResp rsp;\n\tu16 txFid;\n\t__le16 txControl;\n\n\tcmd.cmd = CMD_ALLOCATETX;\n\tcmd.parm0 = lenPayload;\n\tif (down_interruptible(&ai->sem))\n\t\treturn ERROR;\n\tif (issuecommand(ai, &cmd, &rsp) != SUCCESS) {\n\t\ttxFid = ERROR;\n\t\tgoto done;\n\t}\n\tif ( (rsp.status & 0xFF00) != 0) {\n\t\ttxFid = ERROR;\n\t\tgoto done;\n\t}\n\t/* wait for the allocate event/indication\n\t * It makes me kind of nervous that this can just sit here and spin,\n\t * but in practice it only loops like four times. */\n\twhile (((IN4500(ai, EVSTAT) & EV_ALLOC) == 0) && --loop);\n\tif (!loop) {\n\t\ttxFid = ERROR;\n\t\tgoto done;\n\t}\n\n\t// get the allocated fid and acknowledge\n\ttxFid = IN4500(ai, TXALLOCFID);\n\tOUT4500(ai, EVACK, EV_ALLOC);\n\n\t/*  The CARD is pretty cool since it converts the ethernet packet\n\t *  into 802.11.  Also note that we don't release the FID since we\n\t *  will be using the same one over and over again. */\n\t/*  We only have to setup the control once since we are not\n\t *  releasing the fid. */\n\tif (raw)\n\t\ttxControl = cpu_to_le16(TXCTL_TXOK | TXCTL_TXEX | TXCTL_802_11\n\t\t\t| TXCTL_ETHERNET | TXCTL_NORELEASE);\n\telse\n\t\ttxControl = cpu_to_le16(TXCTL_TXOK | TXCTL_TXEX | TXCTL_802_3\n\t\t\t| TXCTL_ETHERNET | TXCTL_NORELEASE);\n\tif (bap_setup(ai, txFid, 0x0008, BAP1) != SUCCESS)\n\t\ttxFid = ERROR;\n\telse\n\t\tbap_write(ai, &txControl, sizeof(txControl), BAP1);\n\ndone:\n\tup(&ai->sem);\n\n\treturn txFid;\n}\n\n/* In general BAP1 is dedicated to transmiting packets.  However,\n   since we need a BAP when accessing RIDs, we also use BAP1 for that.\n   Make sure the BAP1 spinlock is held when this is called. */\nstatic int transmit_802_3_packet(struct airo_info *ai, int len, char *pPacket)\n{\n\t__le16 payloadLen;\n\tCmd cmd;\n\tResp rsp;\n\tint miclen = 0;\n\tu16 txFid = len;\n\tMICBuffer pMic;\n\n\tlen >>= 16;\n\n\tif (len <= ETH_ALEN * 2) {\n\t\tairo_print_warn(ai->dev->name, \"Short packet %d\", len);\n\t\treturn ERROR;\n\t}\n\tlen -= ETH_ALEN * 2;\n\n\tif (test_bit(FLAG_MIC_CAPABLE, &ai->flags) && ai->micstats.enabled && \n\t    (ntohs(((__be16 *)pPacket)[6]) != 0x888E)) {\n\t\tif (encapsulate(ai,(etherHead *)pPacket,&pMic,len) != SUCCESS)\n\t\t\treturn ERROR;\n\t\tmiclen = sizeof(pMic);\n\t}\n\t// packet is destination[6], source[6], payload[len-12]\n\t// write the payload length and dst/src/payload\n\tif (bap_setup(ai, txFid, 0x0036, BAP1) != SUCCESS) return ERROR;\n\t/* The hardware addresses aren't counted as part of the payload, so\n\t * we have to subtract the 12 bytes for the addresses off */\n\tpayloadLen = cpu_to_le16(len + miclen);\n\tbap_write(ai, &payloadLen, sizeof(payloadLen),BAP1);\n\tbap_write(ai, (__le16*)pPacket, sizeof(etherHead), BAP1);\n\tif (miclen)\n\t\tbap_write(ai, (__le16*)&pMic, miclen, BAP1);\n\tbap_write(ai, (__le16*)(pPacket + sizeof(etherHead)), len, BAP1);\n\t// issue the transmit command\n\tmemset( &cmd, 0, sizeof( cmd ) );\n\tcmd.cmd = CMD_TRANSMIT;\n\tcmd.parm0 = txFid;\n\tif (issuecommand(ai, &cmd, &rsp) != SUCCESS) return ERROR;\n\tif ( (rsp.status & 0xFF00) != 0) return ERROR;\n\treturn SUCCESS;\n}\n\nstatic int transmit_802_11_packet(struct airo_info *ai, int len, char *pPacket)\n{\n\t__le16 fc, payloadLen;\n\tCmd cmd;\n\tResp rsp;\n\tint hdrlen;\n\tstatic u8 tail[(30-10) + 2 + 6] = {[30-10] = 6};\n\t/* padding of header to full size + le16 gaplen (6) + gaplen bytes */\n\tu16 txFid = len;\n\tlen >>= 16;\n\n\tfc = *(__le16*)pPacket;\n\thdrlen = header_len(fc);\n\n\tif (len < hdrlen) {\n\t\tairo_print_warn(ai->dev->name, \"Short packet %d\", len);\n\t\treturn ERROR;\n\t}\n\n\t/* packet is 802.11 header +  payload\n\t * write the payload length and dst/src/payload */\n\tif (bap_setup(ai, txFid, 6, BAP1) != SUCCESS) return ERROR;\n\t/* The 802.11 header aren't counted as part of the payload, so\n\t * we have to subtract the header bytes off */\n\tpayloadLen = cpu_to_le16(len-hdrlen);\n\tbap_write(ai, &payloadLen, sizeof(payloadLen),BAP1);\n\tif (bap_setup(ai, txFid, 0x0014, BAP1) != SUCCESS) return ERROR;\n\tbap_write(ai, (__le16 *)pPacket, hdrlen, BAP1);\n\tbap_write(ai, (__le16 *)(tail + (hdrlen - 10)), 38 - hdrlen, BAP1);\n\n\tbap_write(ai, (__le16 *)(pPacket + hdrlen), len - hdrlen, BAP1);\n\t// issue the transmit command\n\tmemset( &cmd, 0, sizeof( cmd ) );\n\tcmd.cmd = CMD_TRANSMIT;\n\tcmd.parm0 = txFid;\n\tif (issuecommand(ai, &cmd, &rsp) != SUCCESS) return ERROR;\n\tif ( (rsp.status & 0xFF00) != 0) return ERROR;\n\treturn SUCCESS;\n}\n\n/*\n *  This is the proc_fs routines.  It is a bit messier than I would\n *  like!  Feel free to clean it up!\n */\n\nstatic ssize_t proc_read( struct file *file,\n\t\t\t  char __user *buffer,\n\t\t\t  size_t len,\n\t\t\t  loff_t *offset);\n\nstatic ssize_t proc_write( struct file *file,\n\t\t\t   const char __user *buffer,\n\t\t\t   size_t len,\n\t\t\t   loff_t *offset );\nstatic int proc_close( struct inode *inode, struct file *file );\n\nstatic int proc_stats_open( struct inode *inode, struct file *file );\nstatic int proc_statsdelta_open( struct inode *inode, struct file *file );\nstatic int proc_status_open( struct inode *inode, struct file *file );\nstatic int proc_SSID_open( struct inode *inode, struct file *file );\nstatic int proc_APList_open( struct inode *inode, struct file *file );\nstatic int proc_BSSList_open( struct inode *inode, struct file *file );\nstatic int proc_config_open( struct inode *inode, struct file *file );\nstatic int proc_wepkey_open( struct inode *inode, struct file *file );\n\nstatic const struct file_operations proc_statsdelta_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= proc_read,\n\t.open\t\t= proc_statsdelta_open,\n\t.release\t= proc_close,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic const struct file_operations proc_stats_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= proc_read,\n\t.open\t\t= proc_stats_open,\n\t.release\t= proc_close,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic const struct file_operations proc_status_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= proc_read,\n\t.open\t\t= proc_status_open,\n\t.release\t= proc_close,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic const struct file_operations proc_SSID_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= proc_read,\n\t.write\t\t= proc_write,\n\t.open\t\t= proc_SSID_open,\n\t.release\t= proc_close,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic const struct file_operations proc_BSSList_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= proc_read,\n\t.write\t\t= proc_write,\n\t.open\t\t= proc_BSSList_open,\n\t.release\t= proc_close,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic const struct file_operations proc_APList_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= proc_read,\n\t.write\t\t= proc_write,\n\t.open\t\t= proc_APList_open,\n\t.release\t= proc_close,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic const struct file_operations proc_config_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= proc_read,\n\t.write\t\t= proc_write,\n\t.open\t\t= proc_config_open,\n\t.release\t= proc_close,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic const struct file_operations proc_wepkey_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= proc_read,\n\t.write\t\t= proc_write,\n\t.open\t\t= proc_wepkey_open,\n\t.release\t= proc_close,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic struct proc_dir_entry *airo_entry;\n\nstruct proc_data {\n\tint release_buffer;\n\tint readlen;\n\tchar *rbuffer;\n\tint writelen;\n\tint maxwritelen;\n\tchar *wbuffer;\n\tvoid (*on_close) (struct inode *, struct file *);\n};\n\nstatic int setup_proc_entry( struct net_device *dev,\n\t\t\t     struct airo_info *apriv ) {\n\tstruct proc_dir_entry *entry;\n\t/* First setup the device directory */\n\tstrcpy(apriv->proc_name,dev->name);\n\tapriv->proc_entry = proc_mkdir_mode(apriv->proc_name, airo_perm,\n\t\t\t\t\t    airo_entry);\n\tif (!apriv->proc_entry)\n\t\tgoto fail;\n\tapriv->proc_entry->uid = proc_uid;\n\tapriv->proc_entry->gid = proc_gid;\n\n\t/* Setup the StatsDelta */\n\tentry = proc_create_data(\"StatsDelta\", S_IRUGO & proc_perm,\n\t\t\t\t apriv->proc_entry, &proc_statsdelta_ops, dev);\n\tif (!entry)\n\t\tgoto fail_stats_delta;\n\tentry->uid = proc_uid;\n\tentry->gid = proc_gid;\n\n\t/* Setup the Stats */\n\tentry = proc_create_data(\"Stats\", S_IRUGO & proc_perm,\n\t\t\t\t apriv->proc_entry, &proc_stats_ops, dev);\n\tif (!entry)\n\t\tgoto fail_stats;\n\tentry->uid = proc_uid;\n\tentry->gid = proc_gid;\n\n\t/* Setup the Status */\n\tentry = proc_create_data(\"Status\", S_IRUGO & proc_perm,\n\t\t\t\t apriv->proc_entry, &proc_status_ops, dev);\n\tif (!entry)\n\t\tgoto fail_status;\n\tentry->uid = proc_uid;\n\tentry->gid = proc_gid;\n\n\t/* Setup the Config */\n\tentry = proc_create_data(\"Config\", proc_perm,\n\t\t\t\t apriv->proc_entry, &proc_config_ops, dev);\n\tif (!entry)\n\t\tgoto fail_config;\n\tentry->uid = proc_uid;\n\tentry->gid = proc_gid;\n\n\t/* Setup the SSID */\n\tentry = proc_create_data(\"SSID\", proc_perm,\n\t\t\t\t apriv->proc_entry, &proc_SSID_ops, dev);\n\tif (!entry)\n\t\tgoto fail_ssid;\n\tentry->uid = proc_uid;\n\tentry->gid = proc_gid;\n\n\t/* Setup the APList */\n\tentry = proc_create_data(\"APList\", proc_perm,\n\t\t\t\t apriv->proc_entry, &proc_APList_ops, dev);\n\tif (!entry)\n\t\tgoto fail_aplist;\n\tentry->uid = proc_uid;\n\tentry->gid = proc_gid;\n\n\t/* Setup the BSSList */\n\tentry = proc_create_data(\"BSSList\", proc_perm,\n\t\t\t\t apriv->proc_entry, &proc_BSSList_ops, dev);\n\tif (!entry)\n\t\tgoto fail_bsslist;\n\tentry->uid = proc_uid;\n\tentry->gid = proc_gid;\n\n\t/* Setup the WepKey */\n\tentry = proc_create_data(\"WepKey\", proc_perm,\n\t\t\t\t apriv->proc_entry, &proc_wepkey_ops, dev);\n\tif (!entry)\n\t\tgoto fail_wepkey;\n\tentry->uid = proc_uid;\n\tentry->gid = proc_gid;\n\n\treturn 0;\n\nfail_wepkey:\n\tremove_proc_entry(\"BSSList\", apriv->proc_entry);\nfail_bsslist:\n\tremove_proc_entry(\"APList\", apriv->proc_entry);\nfail_aplist:\n\tremove_proc_entry(\"SSID\", apriv->proc_entry);\nfail_ssid:\n\tremove_proc_entry(\"Config\", apriv->proc_entry);\nfail_config:\n\tremove_proc_entry(\"Status\", apriv->proc_entry);\nfail_status:\n\tremove_proc_entry(\"Stats\", apriv->proc_entry);\nfail_stats:\n\tremove_proc_entry(\"StatsDelta\", apriv->proc_entry);\nfail_stats_delta:\n\tremove_proc_entry(apriv->proc_name, airo_entry);\nfail:\n\treturn -ENOMEM;\n}\n\nstatic int takedown_proc_entry( struct net_device *dev,\n\t\t\t\tstruct airo_info *apriv ) {\n\tif ( !apriv->proc_entry->namelen ) return 0;\n\tremove_proc_entry(\"Stats\",apriv->proc_entry);\n\tremove_proc_entry(\"StatsDelta\",apriv->proc_entry);\n\tremove_proc_entry(\"Status\",apriv->proc_entry);\n\tremove_proc_entry(\"Config\",apriv->proc_entry);\n\tremove_proc_entry(\"SSID\",apriv->proc_entry);\n\tremove_proc_entry(\"APList\",apriv->proc_entry);\n\tremove_proc_entry(\"BSSList\",apriv->proc_entry);\n\tremove_proc_entry(\"WepKey\",apriv->proc_entry);\n\tremove_proc_entry(apriv->proc_name,airo_entry);\n\treturn 0;\n}\n\n/*\n *  What we want from the proc_fs is to be able to efficiently read\n *  and write the configuration.  To do this, we want to read the\n *  configuration when the file is opened and write it when the file is\n *  closed.  So basically we allocate a read buffer at open and fill it\n *  with data, and allocate a write buffer and read it at close.\n */\n\n/*\n *  The read routine is generic, it relies on the preallocated rbuffer\n *  to supply the data.\n */\nstatic ssize_t proc_read( struct file *file,\n\t\t\t  char __user *buffer,\n\t\t\t  size_t len,\n\t\t\t  loff_t *offset )\n{\n\tstruct proc_data *priv = file->private_data;\n\n\tif (!priv->rbuffer)\n\t\treturn -EINVAL;\n\n\treturn simple_read_from_buffer(buffer, len, offset, priv->rbuffer,\n\t\t\t\t\tpriv->readlen);\n}\n\n/*\n *  The write routine is generic, it fills in a preallocated rbuffer\n *  to supply the data.\n */\nstatic ssize_t proc_write( struct file *file,\n\t\t\t   const char __user *buffer,\n\t\t\t   size_t len,\n\t\t\t   loff_t *offset )\n{\n\tssize_t ret;\n\tstruct proc_data *priv = file->private_data;\n\n\tif (!priv->wbuffer)\n\t\treturn -EINVAL;\n\n\tret = simple_write_to_buffer(priv->wbuffer, priv->maxwritelen, offset,\n\t\t\t\t\tbuffer, len);\n\tif (ret > 0)\n\t\tpriv->writelen = max_t(int, priv->writelen, *offset);\n\n\treturn ret;\n}\n\nstatic int proc_status_open(struct inode *inode, struct file *file)\n{\n\tstruct proc_data *data;\n\tstruct proc_dir_entry *dp = PDE(inode);\n\tstruct net_device *dev = dp->data;\n\tstruct airo_info *apriv = dev->ml_priv;\n\tCapabilityRid cap_rid;\n\tStatusRid status_rid;\n\tu16 mode;\n\tint i;\n\n\tif ((file->private_data = kzalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)\n\t\treturn -ENOMEM;\n\tdata = file->private_data;\n\tif ((data->rbuffer = kmalloc( 2048, GFP_KERNEL )) == NULL) {\n\t\tkfree (file->private_data);\n\t\treturn -ENOMEM;\n\t}\n\n\treadStatusRid(apriv, &status_rid, 1);\n\treadCapabilityRid(apriv, &cap_rid, 1);\n\n\tmode = le16_to_cpu(status_rid.mode);\n\n        i = sprintf(data->rbuffer, \"Status: %s%s%s%s%s%s%s%s%s\\n\",\n                    mode & 1 ? \"CFG \": \"\",\n                    mode & 2 ? \"ACT \": \"\",\n                    mode & 0x10 ? \"SYN \": \"\",\n                    mode & 0x20 ? \"LNK \": \"\",\n                    mode & 0x40 ? \"LEAP \": \"\",\n                    mode & 0x80 ? \"PRIV \": \"\",\n                    mode & 0x100 ? \"KEY \": \"\",\n                    mode & 0x200 ? \"WEP \": \"\",\n                    mode & 0x8000 ? \"ERR \": \"\");\n\tsprintf( data->rbuffer+i, \"Mode: %x\\n\"\n\t\t \"Signal Strength: %d\\n\"\n\t\t \"Signal Quality: %d\\n\"\n\t\t \"SSID: %-.*s\\n\"\n\t\t \"AP: %-.16s\\n\"\n\t\t \"Freq: %d\\n\"\n\t\t \"BitRate: %dmbs\\n\"\n\t\t \"Driver Version: %s\\n\"\n\t\t \"Device: %s\\nManufacturer: %s\\nFirmware Version: %s\\n\"\n\t\t \"Radio type: %x\\nCountry: %x\\nHardware Version: %x\\n\"\n\t\t \"Software Version: %x\\nSoftware Subversion: %x\\n\"\n\t\t \"Boot block version: %x\\n\",\n\t\t le16_to_cpu(status_rid.mode),\n\t\t le16_to_cpu(status_rid.normalizedSignalStrength),\n\t\t le16_to_cpu(status_rid.signalQuality),\n\t\t le16_to_cpu(status_rid.SSIDlen),\n\t\t status_rid.SSID,\n\t\t status_rid.apName,\n\t\t le16_to_cpu(status_rid.channel),\n\t\t le16_to_cpu(status_rid.currentXmitRate) / 2,\n\t\t version,\n\t\t cap_rid.prodName,\n\t\t cap_rid.manName,\n\t\t cap_rid.prodVer,\n\t\t le16_to_cpu(cap_rid.radioType),\n\t\t le16_to_cpu(cap_rid.country),\n\t\t le16_to_cpu(cap_rid.hardVer),\n\t\t le16_to_cpu(cap_rid.softVer),\n\t\t le16_to_cpu(cap_rid.softSubVer),\n\t\t le16_to_cpu(cap_rid.bootBlockVer));\n\tdata->readlen = strlen( data->rbuffer );\n\treturn 0;\n}\n\nstatic int proc_stats_rid_open(struct inode*, struct file*, u16);\nstatic int proc_statsdelta_open( struct inode *inode,\n\t\t\t\t struct file *file ) {\n\tif (file->f_mode&FMODE_WRITE) {\n\t\treturn proc_stats_rid_open(inode, file, RID_STATSDELTACLEAR);\n\t}\n\treturn proc_stats_rid_open(inode, file, RID_STATSDELTA);\n}\n\nstatic int proc_stats_open( struct inode *inode, struct file *file ) {\n\treturn proc_stats_rid_open(inode, file, RID_STATS);\n}\n\nstatic int proc_stats_rid_open( struct inode *inode,\n\t\t\t\tstruct file *file,\n\t\t\t\tu16 rid )\n{\n\tstruct proc_data *data;\n\tstruct proc_dir_entry *dp = PDE(inode);\n\tstruct net_device *dev = dp->data;\n\tstruct airo_info *apriv = dev->ml_priv;\n\tStatsRid stats;\n\tint i, j;\n\t__le32 *vals = stats.vals;\n\tint len;\n\n\tif ((file->private_data = kzalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)\n\t\treturn -ENOMEM;\n\tdata = file->private_data;\n\tif ((data->rbuffer = kmalloc( 4096, GFP_KERNEL )) == NULL) {\n\t\tkfree (file->private_data);\n\t\treturn -ENOMEM;\n\t}\n\n\treadStatsRid(apriv, &stats, rid, 1);\n\tlen = le16_to_cpu(stats.len);\n\n        j = 0;\n\tfor(i=0; statsLabels[i]!=(char *)-1 && i*4<len; i++) {\n\t\tif (!statsLabels[i]) continue;\n\t\tif (j+strlen(statsLabels[i])+16>4096) {\n\t\t\tairo_print_warn(apriv->dev->name,\n\t\t\t       \"Potentially disastrous buffer overflow averted!\");\n\t\t\tbreak;\n\t\t}\n\t\tj+=sprintf(data->rbuffer+j, \"%s: %u\\n\", statsLabels[i],\n\t\t\t\tle32_to_cpu(vals[i]));\n\t}\n\tif (i*4 >= len) {\n\t\tairo_print_warn(apriv->dev->name, \"Got a short rid\");\n\t}\n\tdata->readlen = j;\n\treturn 0;\n}\n\nstatic int get_dec_u16( char *buffer, int *start, int limit ) {\n\tu16 value;\n\tint valid = 0;\n\tfor (value = 0; *start < limit && buffer[*start] >= '0' &&\n\t\t\tbuffer[*start] <= '9'; (*start)++) {\n\t\tvalid = 1;\n\t\tvalue *= 10;\n\t\tvalue += buffer[*start] - '0';\n\t}\n\tif ( !valid ) return -1;\n\treturn value;\n}\n\nstatic int airo_config_commit(struct net_device *dev,\n\t\t\t      struct iw_request_info *info, void *zwrq,\n\t\t\t      char *extra);\n\nstatic inline int sniffing_mode(struct airo_info *ai)\n{\n\treturn (le16_to_cpu(ai->config.rmode) & le16_to_cpu(RXMODE_MASK)) >=\n\t\tle16_to_cpu(RXMODE_RFMON);\n}\n\nstatic void proc_config_on_close(struct inode *inode, struct file *file)\n{\n\tstruct proc_data *data = file->private_data;\n\tstruct proc_dir_entry *dp = PDE(inode);\n\tstruct net_device *dev = dp->data;\n\tstruct airo_info *ai = dev->ml_priv;\n\tchar *line;\n\n\tif ( !data->writelen ) return;\n\n\treadConfigRid(ai, 1);\n\tset_bit (FLAG_COMMIT, &ai->flags);\n\n\tline = data->wbuffer;\n\twhile( line[0] ) {\n/*** Mode processing */\n\t\tif ( !strncmp( line, \"Mode: \", 6 ) ) {\n\t\t\tline += 6;\n\t\t\tif (sniffing_mode(ai))\n\t\t\t\tset_bit (FLAG_RESET, &ai->flags);\n\t\t\tai->config.rmode &= ~RXMODE_FULL_MASK;\n\t\t\tclear_bit (FLAG_802_11, &ai->flags);\n\t\t\tai->config.opmode &= ~MODE_CFG_MASK;\n\t\t\tai->config.scanMode = SCANMODE_ACTIVE;\n\t\t\tif ( line[0] == 'a' ) {\n\t\t\t\tai->config.opmode |= MODE_STA_IBSS;\n\t\t\t} else {\n\t\t\t\tai->config.opmode |= MODE_STA_ESS;\n\t\t\t\tif ( line[0] == 'r' ) {\n\t\t\t\t\tai->config.rmode |= RXMODE_RFMON | RXMODE_DISABLE_802_3_HEADER;\n\t\t\t\t\tai->config.scanMode = SCANMODE_PASSIVE;\n\t\t\t\t\tset_bit (FLAG_802_11, &ai->flags);\n\t\t\t\t} else if ( line[0] == 'y' ) {\n\t\t\t\t\tai->config.rmode |= RXMODE_RFMON_ANYBSS | RXMODE_DISABLE_802_3_HEADER;\n\t\t\t\t\tai->config.scanMode = SCANMODE_PASSIVE;\n\t\t\t\t\tset_bit (FLAG_802_11, &ai->flags);\n\t\t\t\t} else if ( line[0] == 'l' )\n\t\t\t\t\tai->config.rmode |= RXMODE_LANMON;\n\t\t\t}\n\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t}\n\n/*** Radio status */\n\t\telse if (!strncmp(line,\"Radio: \", 7)) {\n\t\t\tline += 7;\n\t\t\tif (!strncmp(line,\"off\",3)) {\n\t\t\t\tset_bit (FLAG_RADIO_OFF, &ai->flags);\n\t\t\t} else {\n\t\t\t\tclear_bit (FLAG_RADIO_OFF, &ai->flags);\n\t\t\t}\n\t\t}\n/*** NodeName processing */\n\t\telse if ( !strncmp( line, \"NodeName: \", 10 ) ) {\n\t\t\tint j;\n\n\t\t\tline += 10;\n\t\t\tmemset( ai->config.nodeName, 0, 16 );\n/* Do the name, assume a space between the mode and node name */\n\t\t\tfor( j = 0; j < 16 && line[j] != '\\n'; j++ ) {\n\t\t\t\tai->config.nodeName[j] = line[j];\n\t\t\t}\n\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t}\n\n/*** PowerMode processing */\n\t\telse if ( !strncmp( line, \"PowerMode: \", 11 ) ) {\n\t\t\tline += 11;\n\t\t\tif ( !strncmp( line, \"PSPCAM\", 6 ) ) {\n\t\t\t\tai->config.powerSaveMode = POWERSAVE_PSPCAM;\n\t\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t\t} else if ( !strncmp( line, \"PSP\", 3 ) ) {\n\t\t\t\tai->config.powerSaveMode = POWERSAVE_PSP;\n\t\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t\t} else {\n\t\t\t\tai->config.powerSaveMode = POWERSAVE_CAM;\n\t\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t\t}\n\t\t} else if ( !strncmp( line, \"DataRates: \", 11 ) ) {\n\t\t\tint v, i = 0, k = 0; /* i is index into line,\n\t\t\t\t\t\tk is index to rates */\n\n\t\t\tline += 11;\n\t\t\twhile((v = get_dec_u16(line, &i, 3))!=-1) {\n\t\t\t\tai->config.rates[k++] = (u8)v;\n\t\t\t\tline += i + 1;\n\t\t\t\ti = 0;\n\t\t\t}\n\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t} else if ( !strncmp( line, \"Channel: \", 9 ) ) {\n\t\t\tint v, i = 0;\n\t\t\tline += 9;\n\t\t\tv = get_dec_u16(line, &i, i+3);\n\t\t\tif ( v != -1 ) {\n\t\t\t\tai->config.channelSet = cpu_to_le16(v);\n\t\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t\t}\n\t\t} else if ( !strncmp( line, \"XmitPower: \", 11 ) ) {\n\t\t\tint v, i = 0;\n\t\t\tline += 11;\n\t\t\tv = get_dec_u16(line, &i, i+3);\n\t\t\tif ( v != -1 ) {\n\t\t\t\tai->config.txPower = cpu_to_le16(v);\n\t\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t\t}\n\t\t} else if ( !strncmp( line, \"WEP: \", 5 ) ) {\n\t\t\tline += 5;\n\t\t\tswitch( line[0] ) {\n\t\t\tcase 's':\n\t\t\t\tai->config.authType = AUTH_SHAREDKEY;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tai->config.authType = AUTH_ENCRYPT;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tai->config.authType = AUTH_OPEN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t} else if ( !strncmp( line, \"LongRetryLimit: \", 16 ) ) {\n\t\t\tint v, i = 0;\n\n\t\t\tline += 16;\n\t\t\tv = get_dec_u16(line, &i, 3);\n\t\t\tv = (v<0) ? 0 : ((v>255) ? 255 : v);\n\t\t\tai->config.longRetryLimit = cpu_to_le16(v);\n\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t} else if ( !strncmp( line, \"ShortRetryLimit: \", 17 ) ) {\n\t\t\tint v, i = 0;\n\n\t\t\tline += 17;\n\t\t\tv = get_dec_u16(line, &i, 3);\n\t\t\tv = (v<0) ? 0 : ((v>255) ? 255 : v);\n\t\t\tai->config.shortRetryLimit = cpu_to_le16(v);\n\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t} else if ( !strncmp( line, \"RTSThreshold: \", 14 ) ) {\n\t\t\tint v, i = 0;\n\n\t\t\tline += 14;\n\t\t\tv = get_dec_u16(line, &i, 4);\n\t\t\tv = (v<0) ? 0 : ((v>AIRO_DEF_MTU) ? AIRO_DEF_MTU : v);\n\t\t\tai->config.rtsThres = cpu_to_le16(v);\n\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t} else if ( !strncmp( line, \"TXMSDULifetime: \", 16 ) ) {\n\t\t\tint v, i = 0;\n\n\t\t\tline += 16;\n\t\t\tv = get_dec_u16(line, &i, 5);\n\t\t\tv = (v<0) ? 0 : v;\n\t\t\tai->config.txLifetime = cpu_to_le16(v);\n\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t} else if ( !strncmp( line, \"RXMSDULifetime: \", 16 ) ) {\n\t\t\tint v, i = 0;\n\n\t\t\tline += 16;\n\t\t\tv = get_dec_u16(line, &i, 5);\n\t\t\tv = (v<0) ? 0 : v;\n\t\t\tai->config.rxLifetime = cpu_to_le16(v);\n\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t} else if ( !strncmp( line, \"TXDiversity: \", 13 ) ) {\n\t\t\tai->config.txDiversity =\n\t\t\t\t(line[13]=='l') ? 1 :\n\t\t\t\t((line[13]=='r')? 2: 3);\n\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t} else if ( !strncmp( line, \"RXDiversity: \", 13 ) ) {\n\t\t\tai->config.rxDiversity =\n\t\t\t\t(line[13]=='l') ? 1 :\n\t\t\t\t((line[13]=='r')? 2: 3);\n\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t} else if ( !strncmp( line, \"FragThreshold: \", 15 ) ) {\n\t\t\tint v, i = 0;\n\n\t\t\tline += 15;\n\t\t\tv = get_dec_u16(line, &i, 4);\n\t\t\tv = (v<256) ? 256 : ((v>AIRO_DEF_MTU) ? AIRO_DEF_MTU : v);\n\t\t\tv = v & 0xfffe; /* Make sure its even */\n\t\t\tai->config.fragThresh = cpu_to_le16(v);\n\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t} else if (!strncmp(line, \"Modulation: \", 12)) {\n\t\t\tline += 12;\n\t\t\tswitch(*line) {\n\t\t\tcase 'd':  ai->config.modulation=MOD_DEFAULT; set_bit(FLAG_COMMIT, &ai->flags); break;\n\t\t\tcase 'c':  ai->config.modulation=MOD_CCK; set_bit(FLAG_COMMIT, &ai->flags); break;\n\t\t\tcase 'm':  ai->config.modulation=MOD_MOK; set_bit(FLAG_COMMIT, &ai->flags); break;\n\t\t\tdefault: airo_print_warn(ai->dev->name, \"Unknown modulation\");\n\t\t\t}\n\t\t} else if (!strncmp(line, \"Preamble: \", 10)) {\n\t\t\tline += 10;\n\t\t\tswitch(*line) {\n\t\t\tcase 'a': ai->config.preamble=PREAMBLE_AUTO; set_bit(FLAG_COMMIT, &ai->flags); break;\n\t\t\tcase 'l': ai->config.preamble=PREAMBLE_LONG; set_bit(FLAG_COMMIT, &ai->flags); break;\n\t\t\tcase 's': ai->config.preamble=PREAMBLE_SHORT; set_bit(FLAG_COMMIT, &ai->flags); break;\n\t\t\tdefault: airo_print_warn(ai->dev->name, \"Unknown preamble\");\n\t\t\t}\n\t\t} else {\n\t\t\tairo_print_warn(ai->dev->name, \"Couldn't figure out %s\", line);\n\t\t}\n\t\twhile( line[0] && line[0] != '\\n' ) line++;\n\t\tif ( line[0] ) line++;\n\t}\n\tairo_config_commit(dev, NULL, NULL, NULL);\n}\n\nstatic const char *get_rmode(__le16 mode)\n{\n        switch(mode & RXMODE_MASK) {\n        case RXMODE_RFMON:  return \"rfmon\";\n        case RXMODE_RFMON_ANYBSS:  return \"yna (any) bss rfmon\";\n        case RXMODE_LANMON:  return \"lanmon\";\n        }\n        return \"ESS\";\n}\n\nstatic int proc_config_open(struct inode *inode, struct file *file)\n{\n\tstruct proc_data *data;\n\tstruct proc_dir_entry *dp = PDE(inode);\n\tstruct net_device *dev = dp->data;\n\tstruct airo_info *ai = dev->ml_priv;\n\tint i;\n\t__le16 mode;\n\n\tif ((file->private_data = kzalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)\n\t\treturn -ENOMEM;\n\tdata = file->private_data;\n\tif ((data->rbuffer = kmalloc( 2048, GFP_KERNEL )) == NULL) {\n\t\tkfree (file->private_data);\n\t\treturn -ENOMEM;\n\t}\n\tif ((data->wbuffer = kzalloc( 2048, GFP_KERNEL )) == NULL) {\n\t\tkfree (data->rbuffer);\n\t\tkfree (file->private_data);\n\t\treturn -ENOMEM;\n\t}\n\tdata->maxwritelen = 2048;\n\tdata->on_close = proc_config_on_close;\n\n\treadConfigRid(ai, 1);\n\n\tmode = ai->config.opmode & MODE_CFG_MASK;\n\ti = sprintf( data->rbuffer,\n\t\t     \"Mode: %s\\n\"\n\t\t     \"Radio: %s\\n\"\n\t\t     \"NodeName: %-16s\\n\"\n\t\t     \"PowerMode: %s\\n\"\n\t\t     \"DataRates: %d %d %d %d %d %d %d %d\\n\"\n\t\t     \"Channel: %d\\n\"\n\t\t     \"XmitPower: %d\\n\",\n\t\t     mode == MODE_STA_IBSS ? \"adhoc\" :\n\t\t     mode == MODE_STA_ESS ? get_rmode(ai->config.rmode):\n\t\t     mode == MODE_AP ? \"AP\" :\n\t\t     mode == MODE_AP_RPTR ? \"AP RPTR\" : \"Error\",\n\t\t     test_bit(FLAG_RADIO_OFF, &ai->flags) ? \"off\" : \"on\",\n\t\t     ai->config.nodeName,\n\t\t     ai->config.powerSaveMode == POWERSAVE_CAM ? \"CAM\" :\n\t\t     ai->config.powerSaveMode == POWERSAVE_PSP ? \"PSP\" :\n\t\t     ai->config.powerSaveMode == POWERSAVE_PSPCAM ? \"PSPCAM\" :\n\t\t     \"Error\",\n\t\t     (int)ai->config.rates[0],\n\t\t     (int)ai->config.rates[1],\n\t\t     (int)ai->config.rates[2],\n\t\t     (int)ai->config.rates[3],\n\t\t     (int)ai->config.rates[4],\n\t\t     (int)ai->config.rates[5],\n\t\t     (int)ai->config.rates[6],\n\t\t     (int)ai->config.rates[7],\n\t\t     le16_to_cpu(ai->config.channelSet),\n\t\t     le16_to_cpu(ai->config.txPower)\n\t\t);\n\tsprintf( data->rbuffer + i,\n\t\t \"LongRetryLimit: %d\\n\"\n\t\t \"ShortRetryLimit: %d\\n\"\n\t\t \"RTSThreshold: %d\\n\"\n\t\t \"TXMSDULifetime: %d\\n\"\n\t\t \"RXMSDULifetime: %d\\n\"\n\t\t \"TXDiversity: %s\\n\"\n\t\t \"RXDiversity: %s\\n\"\n\t\t \"FragThreshold: %d\\n\"\n\t\t \"WEP: %s\\n\"\n\t\t \"Modulation: %s\\n\"\n\t\t \"Preamble: %s\\n\",\n\t\t le16_to_cpu(ai->config.longRetryLimit),\n\t\t le16_to_cpu(ai->config.shortRetryLimit),\n\t\t le16_to_cpu(ai->config.rtsThres),\n\t\t le16_to_cpu(ai->config.txLifetime),\n\t\t le16_to_cpu(ai->config.rxLifetime),\n\t\t ai->config.txDiversity == 1 ? \"left\" :\n\t\t ai->config.txDiversity == 2 ? \"right\" : \"both\",\n\t\t ai->config.rxDiversity == 1 ? \"left\" :\n\t\t ai->config.rxDiversity == 2 ? \"right\" : \"both\",\n\t\t le16_to_cpu(ai->config.fragThresh),\n\t\t ai->config.authType == AUTH_ENCRYPT ? \"encrypt\" :\n\t\t ai->config.authType == AUTH_SHAREDKEY ? \"shared\" : \"open\",\n\t\t ai->config.modulation == MOD_DEFAULT ? \"default\" :\n\t\t ai->config.modulation == MOD_CCK ? \"cck\" :\n\t\t ai->config.modulation == MOD_MOK ? \"mok\" : \"error\",\n\t\t ai->config.preamble == PREAMBLE_AUTO ? \"auto\" :\n\t\t ai->config.preamble == PREAMBLE_LONG ? \"long\" :\n\t\t ai->config.preamble == PREAMBLE_SHORT ? \"short\" : \"error\"\n\t\t);\n\tdata->readlen = strlen( data->rbuffer );\n\treturn 0;\n}\n\nstatic void proc_SSID_on_close(struct inode *inode, struct file *file)\n{\n\tstruct proc_data *data = file->private_data;\n\tstruct proc_dir_entry *dp = PDE(inode);\n\tstruct net_device *dev = dp->data;\n\tstruct airo_info *ai = dev->ml_priv;\n\tSsidRid SSID_rid;\n\tint i;\n\tchar *p = data->wbuffer;\n\tchar *end = p + data->writelen;\n\n\tif (!data->writelen)\n\t\treturn;\n\n\t*end = '\\n'; /* sentinel; we have space for it */\n\n\tmemset(&SSID_rid, 0, sizeof(SSID_rid));\n\n\tfor (i = 0; i < 3 && p < end; i++) {\n\t\tint j = 0;\n\t\t/* copy up to 32 characters from this line */\n\t\twhile (*p != '\\n' && j < 32)\n\t\t\tSSID_rid.ssids[i].ssid[j++] = *p++;\n\t\tif (j == 0)\n\t\t\tbreak;\n\t\tSSID_rid.ssids[i].len = cpu_to_le16(j);\n\t\t/* skip to the beginning of the next line */\n\t\twhile (*p++ != '\\n')\n\t\t\t;\n\t}\n\tif (i)\n\t\tSSID_rid.len = cpu_to_le16(sizeof(SSID_rid));\n\tdisable_MAC(ai, 1);\n\twriteSsidRid(ai, &SSID_rid, 1);\n\tenable_MAC(ai, 1);\n}\n\nstatic void proc_APList_on_close( struct inode *inode, struct file *file ) {\n\tstruct proc_data *data = file->private_data;\n\tstruct proc_dir_entry *dp = PDE(inode);\n\tstruct net_device *dev = dp->data;\n\tstruct airo_info *ai = dev->ml_priv;\n\tAPListRid APList_rid;\n\tint i;\n\n\tif ( !data->writelen ) return;\n\n\tmemset( &APList_rid, 0, sizeof(APList_rid) );\n\tAPList_rid.len = cpu_to_le16(sizeof(APList_rid));\n\n\tfor( i = 0; i < 4 && data->writelen >= (i+1)*6*3; i++ ) {\n\t\tint j;\n\t\tfor( j = 0; j < 6*3 && data->wbuffer[j+i*6*3]; j++ ) {\n\t\t\tswitch(j%3) {\n\t\t\tcase 0:\n\t\t\t\tAPList_rid.ap[i][j/3]=\n\t\t\t\t\thex_to_bin(data->wbuffer[j+i*6*3])<<4;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tAPList_rid.ap[i][j/3]|=\n\t\t\t\t\thex_to_bin(data->wbuffer[j+i*6*3]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tdisable_MAC(ai, 1);\n\twriteAPListRid(ai, &APList_rid, 1);\n\tenable_MAC(ai, 1);\n}\n\n/* This function wraps PC4500_writerid with a MAC disable */\nstatic int do_writerid( struct airo_info *ai, u16 rid, const void *rid_data,\n\t\t\tint len, int dummy ) {\n\tint rc;\n\n\tdisable_MAC(ai, 1);\n\trc = PC4500_writerid(ai, rid, rid_data, len, 1);\n\tenable_MAC(ai, 1);\n\treturn rc;\n}\n\n/* Returns the WEP key at the specified index, or -1 if that key does\n * not exist.  The buffer is assumed to be at least 16 bytes in length.\n */\nstatic int get_wep_key(struct airo_info *ai, u16 index, char *buf, u16 buflen)\n{\n\tWepKeyRid wkr;\n\tint rc;\n\t__le16 lastindex;\n\n\trc = readWepKeyRid(ai, &wkr, 1, 1);\n\tif (rc != SUCCESS)\n\t\treturn -1;\n\tdo {\n\t\tlastindex = wkr.kindex;\n\t\tif (le16_to_cpu(wkr.kindex) == index) {\n\t\t\tint klen = min_t(int, buflen, le16_to_cpu(wkr.klen));\n\t\t\tmemcpy(buf, wkr.key, klen);\n\t\t\treturn klen;\n\t\t}\n\t\trc = readWepKeyRid(ai, &wkr, 0, 1);\n\t\tif (rc != SUCCESS)\n\t\t\treturn -1;\n\t} while (lastindex != wkr.kindex);\n\treturn -1;\n}\n\nstatic int get_wep_tx_idx(struct airo_info *ai)\n{\n\tWepKeyRid wkr;\n\tint rc;\n\t__le16 lastindex;\n\n\trc = readWepKeyRid(ai, &wkr, 1, 1);\n\tif (rc != SUCCESS)\n\t\treturn -1;\n\tdo {\n\t\tlastindex = wkr.kindex;\n\t\tif (wkr.kindex == cpu_to_le16(0xffff))\n\t\t\treturn wkr.mac[0];\n\t\trc = readWepKeyRid(ai, &wkr, 0, 1);\n\t\tif (rc != SUCCESS)\n\t\t\treturn -1;\n\t} while (lastindex != wkr.kindex);\n\treturn -1;\n}\n\nstatic int set_wep_key(struct airo_info *ai, u16 index, const char *key,\n\t\t       u16 keylen, int perm, int lock)\n{\n\tstatic const unsigned char macaddr[ETH_ALEN] = { 0x01, 0, 0, 0, 0, 0 };\n\tWepKeyRid wkr;\n\tint rc;\n\n\tif (WARN_ON(keylen == 0))\n\t\treturn -1;\n\n\tmemset(&wkr, 0, sizeof(wkr));\n\twkr.len = cpu_to_le16(sizeof(wkr));\n\twkr.kindex = cpu_to_le16(index);\n\twkr.klen = cpu_to_le16(keylen);\n\tmemcpy(wkr.key, key, keylen);\n\tmemcpy(wkr.mac, macaddr, ETH_ALEN);\n\n\tif (perm) disable_MAC(ai, lock);\n\trc = writeWepKeyRid(ai, &wkr, perm, lock);\n\tif (perm) enable_MAC(ai, lock);\n\treturn rc;\n}\n\nstatic int set_wep_tx_idx(struct airo_info *ai, u16 index, int perm, int lock)\n{\n\tWepKeyRid wkr;\n\tint rc;\n\n\tmemset(&wkr, 0, sizeof(wkr));\n\twkr.len = cpu_to_le16(sizeof(wkr));\n\twkr.kindex = cpu_to_le16(0xffff);\n\twkr.mac[0] = (char)index;\n\n\tif (perm) {\n\t\tai->defindex = (char)index;\n\t\tdisable_MAC(ai, lock);\n\t}\n\n\trc = writeWepKeyRid(ai, &wkr, perm, lock);\n\n\tif (perm)\n\t\tenable_MAC(ai, lock);\n\treturn rc;\n}\n\nstatic void proc_wepkey_on_close( struct inode *inode, struct file *file ) {\n\tstruct proc_data *data;\n\tstruct proc_dir_entry *dp = PDE(inode);\n\tstruct net_device *dev = dp->data;\n\tstruct airo_info *ai = dev->ml_priv;\n\tint i, rc;\n\tchar key[16];\n\tu16 index = 0;\n\tint j = 0;\n\n\tmemset(key, 0, sizeof(key));\n\n\tdata = file->private_data;\n\tif ( !data->writelen ) return;\n\n\tif (data->wbuffer[0] >= '0' && data->wbuffer[0] <= '3' &&\n\t    (data->wbuffer[1] == ' ' || data->wbuffer[1] == '\\n')) {\n\t\tindex = data->wbuffer[0] - '0';\n\t\tif (data->wbuffer[1] == '\\n') {\n\t\t\trc = set_wep_tx_idx(ai, index, 1, 1);\n\t\t\tif (rc < 0) {\n\t\t\t\tairo_print_err(ai->dev->name, \"failed to set \"\n\t\t\t\t               \"WEP transmit index to %d: %d.\",\n\t\t\t\t               index, rc);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tj = 2;\n\t} else {\n\t\tairo_print_err(ai->dev->name, \"WepKey passed invalid key index\");\n\t\treturn;\n\t}\n\n\tfor( i = 0; i < 16*3 && data->wbuffer[i+j]; i++ ) {\n\t\tswitch(i%3) {\n\t\tcase 0:\n\t\t\tkey[i/3] = hex_to_bin(data->wbuffer[i+j])<<4;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tkey[i/3] |= hex_to_bin(data->wbuffer[i+j]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trc = set_wep_key(ai, index, key, i/3, 1, 1);\n\tif (rc < 0) {\n\t\tairo_print_err(ai->dev->name, \"failed to set WEP key at index \"\n\t\t               \"%d: %d.\", index, rc);\n\t}\n}\n\nstatic int proc_wepkey_open( struct inode *inode, struct file *file )\n{\n\tstruct proc_data *data;\n\tstruct proc_dir_entry *dp = PDE(inode);\n\tstruct net_device *dev = dp->data;\n\tstruct airo_info *ai = dev->ml_priv;\n\tchar *ptr;\n\tWepKeyRid wkr;\n\t__le16 lastindex;\n\tint j=0;\n\tint rc;\n\n\tif ((file->private_data = kzalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)\n\t\treturn -ENOMEM;\n\tmemset(&wkr, 0, sizeof(wkr));\n\tdata = file->private_data;\n\tif ((data->rbuffer = kzalloc( 180, GFP_KERNEL )) == NULL) {\n\t\tkfree (file->private_data);\n\t\treturn -ENOMEM;\n\t}\n\tdata->writelen = 0;\n\tdata->maxwritelen = 80;\n\tif ((data->wbuffer = kzalloc( 80, GFP_KERNEL )) == NULL) {\n\t\tkfree (data->rbuffer);\n\t\tkfree (file->private_data);\n\t\treturn -ENOMEM;\n\t}\n\tdata->on_close = proc_wepkey_on_close;\n\n\tptr = data->rbuffer;\n\tstrcpy(ptr, \"No wep keys\\n\");\n\trc = readWepKeyRid(ai, &wkr, 1, 1);\n\tif (rc == SUCCESS) do {\n\t\tlastindex = wkr.kindex;\n\t\tif (wkr.kindex == cpu_to_le16(0xffff)) {\n\t\t\tj += sprintf(ptr+j, \"Tx key = %d\\n\",\n\t\t\t\t     (int)wkr.mac[0]);\n\t\t} else {\n\t\t\tj += sprintf(ptr+j, \"Key %d set with length = %d\\n\",\n\t\t\t\t     le16_to_cpu(wkr.kindex),\n\t\t\t\t     le16_to_cpu(wkr.klen));\n\t\t}\n\t\treadWepKeyRid(ai, &wkr, 0, 1);\n\t} while((lastindex != wkr.kindex) && (j < 180-30));\n\n\tdata->readlen = strlen( data->rbuffer );\n\treturn 0;\n}\n\nstatic int proc_SSID_open(struct inode *inode, struct file *file)\n{\n\tstruct proc_data *data;\n\tstruct proc_dir_entry *dp = PDE(inode);\n\tstruct net_device *dev = dp->data;\n\tstruct airo_info *ai = dev->ml_priv;\n\tint i;\n\tchar *ptr;\n\tSsidRid SSID_rid;\n\n\tif ((file->private_data = kzalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)\n\t\treturn -ENOMEM;\n\tdata = file->private_data;\n\tif ((data->rbuffer = kmalloc( 104, GFP_KERNEL )) == NULL) {\n\t\tkfree (file->private_data);\n\t\treturn -ENOMEM;\n\t}\n\tdata->writelen = 0;\n\tdata->maxwritelen = 33*3;\n\t/* allocate maxwritelen + 1; we'll want a sentinel */\n\tif ((data->wbuffer = kzalloc(33*3 + 1, GFP_KERNEL)) == NULL) {\n\t\tkfree (data->rbuffer);\n\t\tkfree (file->private_data);\n\t\treturn -ENOMEM;\n\t}\n\tdata->on_close = proc_SSID_on_close;\n\n\treadSsidRid(ai, &SSID_rid);\n\tptr = data->rbuffer;\n\tfor (i = 0; i < 3; i++) {\n\t\tint j;\n\t\tsize_t len = le16_to_cpu(SSID_rid.ssids[i].len);\n\t\tif (!len)\n\t\t\tbreak;\n\t\tif (len > 32)\n\t\t\tlen = 32;\n\t\tfor (j = 0; j < len && SSID_rid.ssids[i].ssid[j]; j++)\n\t\t\t*ptr++ = SSID_rid.ssids[i].ssid[j];\n\t\t*ptr++ = '\\n';\n\t}\n\t*ptr = '\\0';\n\tdata->readlen = strlen( data->rbuffer );\n\treturn 0;\n}\n\nstatic int proc_APList_open( struct inode *inode, struct file *file ) {\n\tstruct proc_data *data;\n\tstruct proc_dir_entry *dp = PDE(inode);\n\tstruct net_device *dev = dp->data;\n\tstruct airo_info *ai = dev->ml_priv;\n\tint i;\n\tchar *ptr;\n\tAPListRid APList_rid;\n\n\tif ((file->private_data = kzalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)\n\t\treturn -ENOMEM;\n\tdata = file->private_data;\n\tif ((data->rbuffer = kmalloc( 104, GFP_KERNEL )) == NULL) {\n\t\tkfree (file->private_data);\n\t\treturn -ENOMEM;\n\t}\n\tdata->writelen = 0;\n\tdata->maxwritelen = 4*6*3;\n\tif ((data->wbuffer = kzalloc( data->maxwritelen, GFP_KERNEL )) == NULL) {\n\t\tkfree (data->rbuffer);\n\t\tkfree (file->private_data);\n\t\treturn -ENOMEM;\n\t}\n\tdata->on_close = proc_APList_on_close;\n\n\treadAPListRid(ai, &APList_rid);\n\tptr = data->rbuffer;\n\tfor( i = 0; i < 4; i++ ) {\n// We end when we find a zero MAC\n\t\tif ( !*(int*)APList_rid.ap[i] &&\n\t\t     !*(int*)&APList_rid.ap[i][2]) break;\n\t\tptr += sprintf(ptr, \"%pM\\n\", APList_rid.ap[i]);\n\t}\n\tif (i==0) ptr += sprintf(ptr, \"Not using specific APs\\n\");\n\n\t*ptr = '\\0';\n\tdata->readlen = strlen( data->rbuffer );\n\treturn 0;\n}\n\nstatic int proc_BSSList_open( struct inode *inode, struct file *file ) {\n\tstruct proc_data *data;\n\tstruct proc_dir_entry *dp = PDE(inode);\n\tstruct net_device *dev = dp->data;\n\tstruct airo_info *ai = dev->ml_priv;\n\tchar *ptr;\n\tBSSListRid BSSList_rid;\n\tint rc;\n\t/* If doLoseSync is not 1, we won't do a Lose Sync */\n\tint doLoseSync = -1;\n\n\tif ((file->private_data = kzalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)\n\t\treturn -ENOMEM;\n\tdata = file->private_data;\n\tif ((data->rbuffer = kmalloc( 1024, GFP_KERNEL )) == NULL) {\n\t\tkfree (file->private_data);\n\t\treturn -ENOMEM;\n\t}\n\tdata->writelen = 0;\n\tdata->maxwritelen = 0;\n\tdata->wbuffer = NULL;\n\tdata->on_close = NULL;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tif (!(file->f_mode & FMODE_READ)) {\n\t\t\tCmd cmd;\n\t\t\tResp rsp;\n\n\t\t\tif (ai->flags & FLAG_RADIO_MASK) return -ENETDOWN;\n\t\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\t\tcmd.cmd=CMD_LISTBSS;\n\t\t\tif (down_interruptible(&ai->sem))\n\t\t\t\treturn -ERESTARTSYS;\n\t\t\tissuecommand(ai, &cmd, &rsp);\n\t\t\tup(&ai->sem);\n\t\t\tdata->readlen = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tdoLoseSync = 1;\n\t}\n\tptr = data->rbuffer;\n\t/* There is a race condition here if there are concurrent opens.\n           Since it is a rare condition, we'll just live with it, otherwise\n           we have to add a spin lock... */\n\trc = readBSSListRid(ai, doLoseSync, &BSSList_rid);\n\twhile(rc == 0 && BSSList_rid.index != cpu_to_le16(0xffff)) {\n\t\tptr += sprintf(ptr, \"%pM %*s rssi = %d\",\n\t\t\t       BSSList_rid.bssid,\n\t\t\t\t(int)BSSList_rid.ssidLen,\n\t\t\t\tBSSList_rid.ssid,\n\t\t\t\tle16_to_cpu(BSSList_rid.dBm));\n\t\tptr += sprintf(ptr, \" channel = %d %s %s %s %s\\n\",\n\t\t\t\tle16_to_cpu(BSSList_rid.dsChannel),\n\t\t\t\tBSSList_rid.cap & CAP_ESS ? \"ESS\" : \"\",\n\t\t\t\tBSSList_rid.cap & CAP_IBSS ? \"adhoc\" : \"\",\n\t\t\t\tBSSList_rid.cap & CAP_PRIVACY ? \"wep\" : \"\",\n\t\t\t\tBSSList_rid.cap & CAP_SHORTHDR ? \"shorthdr\" : \"\");\n\t\trc = readBSSListRid(ai, 0, &BSSList_rid);\n\t}\n\t*ptr = '\\0';\n\tdata->readlen = strlen( data->rbuffer );\n\treturn 0;\n}\n\nstatic int proc_close( struct inode *inode, struct file *file )\n{\n\tstruct proc_data *data = file->private_data;\n\n\tif (data->on_close != NULL)\n\t\tdata->on_close(inode, file);\n\tkfree(data->rbuffer);\n\tkfree(data->wbuffer);\n\tkfree(data);\n\treturn 0;\n}\n\n/* Since the card doesn't automatically switch to the right WEP mode,\n   we will make it do it.  If the card isn't associated, every secs we\n   will switch WEP modes to see if that will help.  If the card is\n   associated we will check every minute to see if anything has\n   changed. */\nstatic void timer_func( struct net_device *dev ) {\n\tstruct airo_info *apriv = dev->ml_priv;\n\n/* We don't have a link so try changing the authtype */\n\treadConfigRid(apriv, 0);\n\tdisable_MAC(apriv, 0);\n\tswitch(apriv->config.authType) {\n\t\tcase AUTH_ENCRYPT:\n/* So drop to OPEN */\n\t\t\tapriv->config.authType = AUTH_OPEN;\n\t\t\tbreak;\n\t\tcase AUTH_SHAREDKEY:\n\t\t\tif (apriv->keyindex < auto_wep) {\n\t\t\t\tset_wep_tx_idx(apriv, apriv->keyindex, 0, 0);\n\t\t\t\tapriv->config.authType = AUTH_SHAREDKEY;\n\t\t\t\tapriv->keyindex++;\n\t\t\t} else {\n\t\t\t        /* Drop to ENCRYPT */\n\t\t\t\tapriv->keyindex = 0;\n\t\t\t\tset_wep_tx_idx(apriv, apriv->defindex, 0, 0);\n\t\t\t\tapriv->config.authType = AUTH_ENCRYPT;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:  /* We'll escalate to SHAREDKEY */\n\t\t\tapriv->config.authType = AUTH_SHAREDKEY;\n\t}\n\tset_bit (FLAG_COMMIT, &apriv->flags);\n\twriteConfigRid(apriv, 0);\n\tenable_MAC(apriv, 0);\n\tup(&apriv->sem);\n\n/* Schedule check to see if the change worked */\n\tclear_bit(JOB_AUTOWEP, &apriv->jobs);\n\tapriv->expires = RUN_AT(HZ*3);\n}\n\n#ifdef CONFIG_PCI\nstatic int __devinit airo_pci_probe(struct pci_dev *pdev,\n\t\t\t\t    const struct pci_device_id *pent)\n{\n\tstruct net_device *dev;\n\n\tif (pci_enable_device(pdev))\n\t\treturn -ENODEV;\n\tpci_set_master(pdev);\n\n\tif (pdev->device == 0x5000 || pdev->device == 0xa504)\n\t\t\tdev = _init_airo_card(pdev->irq, pdev->resource[0].start, 0, pdev, &pdev->dev);\n\telse\n\t\t\tdev = _init_airo_card(pdev->irq, pdev->resource[2].start, 0, pdev, &pdev->dev);\n\tif (!dev) {\n\t\tpci_disable_device(pdev);\n\t\treturn -ENODEV;\n\t}\n\n\tpci_set_drvdata(pdev, dev);\n\treturn 0;\n}\n\nstatic void __devexit airo_pci_remove(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\n\tairo_print_info(dev->name, \"Unregistering...\");\n\tstop_airo_card(dev, 1);\n\tpci_disable_device(pdev);\n\tpci_set_drvdata(pdev, NULL);\n}\n\nstatic int airo_pci_suspend(struct pci_dev *pdev, pm_message_t state)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct airo_info *ai = dev->ml_priv;\n\tCmd cmd;\n\tResp rsp;\n\n\tif (!ai->APList)\n\t\tai->APList = kmalloc(sizeof(APListRid), GFP_KERNEL);\n\tif (!ai->APList)\n\t\treturn -ENOMEM;\n\tif (!ai->SSID)\n\t\tai->SSID = kmalloc(sizeof(SsidRid), GFP_KERNEL);\n\tif (!ai->SSID)\n\t\treturn -ENOMEM;\n\treadAPListRid(ai, ai->APList);\n\treadSsidRid(ai, ai->SSID);\n\tmemset(&cmd, 0, sizeof(cmd));\n\t/* the lock will be released at the end of the resume callback */\n\tif (down_interruptible(&ai->sem))\n\t\treturn -EAGAIN;\n\tdisable_MAC(ai, 0);\n\tnetif_device_detach(dev);\n\tai->power = state;\n\tcmd.cmd = HOSTSLEEP;\n\tissuecommand(ai, &cmd, &rsp);\n\n\tpci_enable_wake(pdev, pci_choose_state(pdev, state), 1);\n\tpci_save_state(pdev);\n\tpci_set_power_state(pdev, pci_choose_state(pdev, state));\n\treturn 0;\n}\n\nstatic int airo_pci_resume(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct airo_info *ai = dev->ml_priv;\n\tpci_power_t prev_state = pdev->current_state;\n\n\tpci_set_power_state(pdev, PCI_D0);\n\tpci_restore_state(pdev);\n\tpci_enable_wake(pdev, PCI_D0, 0);\n\n\tif (prev_state != PCI_D1) {\n\t\treset_card(dev, 0);\n\t\tmpi_init_descriptors(ai);\n\t\tsetup_card(ai, dev->dev_addr, 0);\n\t\tclear_bit(FLAG_RADIO_OFF, &ai->flags);\n\t\tclear_bit(FLAG_PENDING_XMIT, &ai->flags);\n\t} else {\n\t\tOUT4500(ai, EVACK, EV_AWAKEN);\n\t\tOUT4500(ai, EVACK, EV_AWAKEN);\n\t\tmsleep(100);\n\t}\n\n\tset_bit(FLAG_COMMIT, &ai->flags);\n\tdisable_MAC(ai, 0);\n        msleep(200);\n\tif (ai->SSID) {\n\t\twriteSsidRid(ai, ai->SSID, 0);\n\t\tkfree(ai->SSID);\n\t\tai->SSID = NULL;\n\t}\n\tif (ai->APList) {\n\t\twriteAPListRid(ai, ai->APList, 0);\n\t\tkfree(ai->APList);\n\t\tai->APList = NULL;\n\t}\n\twriteConfigRid(ai, 0);\n\tenable_MAC(ai, 0);\n\tai->power = PMSG_ON;\n\tnetif_device_attach(dev);\n\tnetif_wake_queue(dev);\n\tenable_interrupts(ai);\n\tup(&ai->sem);\n\treturn 0;\n}\n#endif\n\nstatic int __init airo_init_module( void )\n{\n\tint i;\n\n\tairo_entry = proc_mkdir_mode(\"driver/aironet\", airo_perm, NULL);\n\n\tif (airo_entry) {\n\t\tairo_entry->uid = proc_uid;\n\t\tairo_entry->gid = proc_gid;\n\t}\n\n\tfor (i = 0; i < 4 && io[i] && irq[i]; i++) {\n\t\tairo_print_info(\"\", \"Trying to configure ISA adapter at irq=%d \"\n\t\t\t\"io=0x%x\", irq[i], io[i] );\n\t\tif (init_airo_card( irq[i], io[i], 0, NULL ))\n\t\t\t/* do nothing */ ;\n\t}\n\n#ifdef CONFIG_PCI\n\tairo_print_info(\"\", \"Probing for PCI adapters\");\n\ti = pci_register_driver(&airo_driver);\n\tairo_print_info(\"\", \"Finished probing for PCI adapters\");\n\n\tif (i) {\n\t\tremove_proc_entry(\"driver/aironet\", NULL);\n\t\treturn i;\n\t}\n#endif\n\n\t/* Always exit with success, as we are a library module\n\t * as well as a driver module\n\t */\n\treturn 0;\n}\n\nstatic void __exit airo_cleanup_module( void )\n{\n\tstruct airo_info *ai;\n\twhile(!list_empty(&airo_devices)) {\n\t\tai = list_entry(airo_devices.next, struct airo_info, dev_list);\n\t\tairo_print_info(ai->dev->name, \"Unregistering...\");\n\t\tstop_airo_card(ai->dev, 1);\n\t}\n#ifdef CONFIG_PCI\n\tpci_unregister_driver(&airo_driver);\n#endif\n\tremove_proc_entry(\"driver/aironet\", NULL);\n}\n\n/*\n * Initial Wireless Extension code for Aironet driver by :\n *\tJean Tourrilhes <jt@hpl.hp.com> - HPL - 17 November 00\n * Conversion to new driver API by :\n *\tJean Tourrilhes <jt@hpl.hp.com> - HPL - 26 March 02\n * Javier also did a good amount of work here, adding some new extensions\n * and fixing my code. Let's just say that without him this code just\n * would not work at all... - Jean II\n */\n\nstatic u8 airo_rssi_to_dbm (tdsRssiEntry *rssi_rid, u8 rssi)\n{\n\tif (!rssi_rid)\n\t\treturn 0;\n\n\treturn (0x100 - rssi_rid[rssi].rssidBm);\n}\n\nstatic u8 airo_dbm_to_pct (tdsRssiEntry *rssi_rid, u8 dbm)\n{\n\tint i;\n\n\tif (!rssi_rid)\n\t\treturn 0;\n\n\tfor (i = 0; i < 256; i++)\n\t\tif (rssi_rid[i].rssidBm == dbm)\n\t\t\treturn rssi_rid[i].rssipct;\n\n\treturn 0;\n}\n\n\nstatic int airo_get_quality (StatusRid *status_rid, CapabilityRid *cap_rid)\n{\n\tint quality = 0;\n\tu16 sq;\n\n\tif ((status_rid->mode & cpu_to_le16(0x3f)) != cpu_to_le16(0x3f))\n\t\treturn 0;\n\n\tif (!(cap_rid->hardCap & cpu_to_le16(8)))\n\t\treturn 0;\n\n\tsq = le16_to_cpu(status_rid->signalQuality);\n\tif (memcmp(cap_rid->prodName, \"350\", 3))\n\t\tif (sq > 0x20)\n\t\t\tquality = 0;\n\t\telse\n\t\t\tquality = 0x20 - sq;\n\telse\n\t\tif (sq > 0xb0)\n\t\t\tquality = 0;\n\t\telse if (sq < 0x10)\n\t\t\tquality = 0xa0;\n\t\telse\n\t\t\tquality = 0xb0 - sq;\n\treturn quality;\n}\n\n#define airo_get_max_quality(cap_rid) (memcmp((cap_rid)->prodName, \"350\", 3) ? 0x20 : 0xa0)\n#define airo_get_avg_quality(cap_rid) (memcmp((cap_rid)->prodName, \"350\", 3) ? 0x10 : 0x50);\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : get protocol name\n */\nstatic int airo_get_name(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t char *cwrq,\n\t\t\t char *extra)\n{\n\tstrcpy(cwrq, \"IEEE 802.11-DS\");\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : set frequency\n */\nstatic int airo_set_freq(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t struct iw_freq *fwrq,\n\t\t\t char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tint rc = -EINPROGRESS;\t\t/* Call commit handler */\n\n\t/* If setting by frequency, convert to a channel */\n\tif(fwrq->e == 1) {\n\t\tint f = fwrq->m / 100000;\n\n\t\t/* Hack to fall through... */\n\t\tfwrq->e = 0;\n\t\tfwrq->m = ieee80211_freq_to_dsss_chan(f);\n\t}\n\t/* Setting by channel number */\n\tif((fwrq->m > 1000) || (fwrq->e > 0))\n\t\trc = -EOPNOTSUPP;\n\telse {\n\t\tint channel = fwrq->m;\n\t\t/* We should do a better check than that,\n\t\t * based on the card capability !!! */\n\t\tif((channel < 1) || (channel > 14)) {\n\t\t\tairo_print_dbg(dev->name, \"New channel value of %d is invalid!\",\n\t\t\t\tfwrq->m);\n\t\t\trc = -EINVAL;\n\t\t} else {\n\t\t\treadConfigRid(local, 1);\n\t\t\t/* Yes ! We can set it !!! */\n\t\t\tlocal->config.channelSet = cpu_to_le16(channel);\n\t\t\tset_bit (FLAG_COMMIT, &local->flags);\n\t\t}\n\t}\n\treturn rc;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : get frequency\n */\nstatic int airo_get_freq(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t struct iw_freq *fwrq,\n\t\t\t char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tStatusRid status_rid;\t\t/* Card status info */\n\tint ch;\n\n\treadConfigRid(local, 1);\n\tif ((local->config.opmode & MODE_CFG_MASK) == MODE_STA_ESS)\n\t\tstatus_rid.channel = local->config.channelSet;\n\telse\n\t\treadStatusRid(local, &status_rid, 1);\n\n\tch = le16_to_cpu(status_rid.channel);\n\tif((ch > 0) && (ch < 15)) {\n\t\tfwrq->m = ieee80211_dsss_chan_to_freq(ch) * 100000;\n\t\tfwrq->e = 1;\n\t} else {\n\t\tfwrq->m = ch;\n\t\tfwrq->e = 0;\n\t}\n\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : set ESSID\n */\nstatic int airo_set_essid(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  struct iw_point *dwrq,\n\t\t\t  char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tSsidRid SSID_rid;\t\t/* SSIDs */\n\n\t/* Reload the list of current SSID */\n\treadSsidRid(local, &SSID_rid);\n\n\t/* Check if we asked for `any' */\n\tif (dwrq->flags == 0) {\n\t\t/* Just send an empty SSID list */\n\t\tmemset(&SSID_rid, 0, sizeof(SSID_rid));\n\t} else {\n\t\tunsigned index = (dwrq->flags & IW_ENCODE_INDEX) - 1;\n\n\t\t/* Check the size of the string */\n\t\tif (dwrq->length > IW_ESSID_MAX_SIZE)\n\t\t\treturn -E2BIG ;\n\n\t\t/* Check if index is valid */\n\t\tif (index >= ARRAY_SIZE(SSID_rid.ssids))\n\t\t\treturn -EINVAL;\n\n\t\t/* Set the SSID */\n\t\tmemset(SSID_rid.ssids[index].ssid, 0,\n\t\t       sizeof(SSID_rid.ssids[index].ssid));\n\t\tmemcpy(SSID_rid.ssids[index].ssid, extra, dwrq->length);\n\t\tSSID_rid.ssids[index].len = cpu_to_le16(dwrq->length);\n\t}\n\tSSID_rid.len = cpu_to_le16(sizeof(SSID_rid));\n\t/* Write it to the card */\n\tdisable_MAC(local, 1);\n\twriteSsidRid(local, &SSID_rid, 1);\n\tenable_MAC(local, 1);\n\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : get ESSID\n */\nstatic int airo_get_essid(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  struct iw_point *dwrq,\n\t\t\t  char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tStatusRid status_rid;\t\t/* Card status info */\n\n\treadStatusRid(local, &status_rid, 1);\n\n\t/* Note : if dwrq->flags != 0, we should\n\t * get the relevant SSID from the SSID list... */\n\n\t/* Get the current SSID */\n\tmemcpy(extra, status_rid.SSID, le16_to_cpu(status_rid.SSIDlen));\n\t/* If none, we may want to get the one that was set */\n\n\t/* Push it out ! */\n\tdwrq->length = le16_to_cpu(status_rid.SSIDlen);\n\tdwrq->flags = 1; /* active */\n\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : set AP address\n */\nstatic int airo_set_wap(struct net_device *dev,\n\t\t\tstruct iw_request_info *info,\n\t\t\tstruct sockaddr *awrq,\n\t\t\tchar *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tCmd cmd;\n\tResp rsp;\n\tAPListRid APList_rid;\n\tstatic const u8 any[ETH_ALEN] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };\n\tstatic const u8 off[ETH_ALEN] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\n\tif (awrq->sa_family != ARPHRD_ETHER)\n\t\treturn -EINVAL;\n\telse if (!memcmp(any, awrq->sa_data, ETH_ALEN) ||\n\t         !memcmp(off, awrq->sa_data, ETH_ALEN)) {\n\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\tcmd.cmd=CMD_LOSE_SYNC;\n\t\tif (down_interruptible(&local->sem))\n\t\t\treturn -ERESTARTSYS;\n\t\tissuecommand(local, &cmd, &rsp);\n\t\tup(&local->sem);\n\t} else {\n\t\tmemset(&APList_rid, 0, sizeof(APList_rid));\n\t\tAPList_rid.len = cpu_to_le16(sizeof(APList_rid));\n\t\tmemcpy(APList_rid.ap[0], awrq->sa_data, ETH_ALEN);\n\t\tdisable_MAC(local, 1);\n\t\twriteAPListRid(local, &APList_rid, 1);\n\t\tenable_MAC(local, 1);\n\t}\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : get AP address\n */\nstatic int airo_get_wap(struct net_device *dev,\n\t\t\tstruct iw_request_info *info,\n\t\t\tstruct sockaddr *awrq,\n\t\t\tchar *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tStatusRid status_rid;\t\t/* Card status info */\n\n\treadStatusRid(local, &status_rid, 1);\n\n\t/* Tentative. This seems to work, wow, I'm lucky !!! */\n\tmemcpy(awrq->sa_data, status_rid.bssid[0], ETH_ALEN);\n\tawrq->sa_family = ARPHRD_ETHER;\n\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : set Nickname\n */\nstatic int airo_set_nick(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t struct iw_point *dwrq,\n\t\t\t char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\n\t/* Check the size of the string */\n\tif(dwrq->length > 16) {\n\t\treturn -E2BIG;\n\t}\n\treadConfigRid(local, 1);\n\tmemset(local->config.nodeName, 0, sizeof(local->config.nodeName));\n\tmemcpy(local->config.nodeName, extra, dwrq->length);\n\tset_bit (FLAG_COMMIT, &local->flags);\n\n\treturn -EINPROGRESS;\t\t/* Call commit handler */\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : get Nickname\n */\nstatic int airo_get_nick(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t struct iw_point *dwrq,\n\t\t\t char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\n\treadConfigRid(local, 1);\n\tstrncpy(extra, local->config.nodeName, 16);\n\textra[16] = '\\0';\n\tdwrq->length = strlen(extra);\n\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : set Bit-Rate\n */\nstatic int airo_set_rate(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t struct iw_param *vwrq,\n\t\t\t char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tCapabilityRid cap_rid;\t\t/* Card capability info */\n\tu8\tbrate = 0;\n\tint\ti;\n\n\t/* First : get a valid bit rate value */\n\treadCapabilityRid(local, &cap_rid, 1);\n\n\t/* Which type of value ? */\n\tif((vwrq->value < 8) && (vwrq->value >= 0)) {\n\t\t/* Setting by rate index */\n\t\t/* Find value in the magic rate table */\n\t\tbrate = cap_rid.supportedRates[vwrq->value];\n\t} else {\n\t\t/* Setting by frequency value */\n\t\tu8\tnormvalue = (u8) (vwrq->value/500000);\n\n\t\t/* Check if rate is valid */\n\t\tfor(i = 0 ; i < 8 ; i++) {\n\t\t\tif(normvalue == cap_rid.supportedRates[i]) {\n\t\t\t\tbrate = normvalue;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t/* -1 designed the max rate (mostly auto mode) */\n\tif(vwrq->value == -1) {\n\t\t/* Get the highest available rate */\n\t\tfor(i = 0 ; i < 8 ; i++) {\n\t\t\tif(cap_rid.supportedRates[i] == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif(i != 0)\n\t\t\tbrate = cap_rid.supportedRates[i - 1];\n\t}\n\t/* Check that it is valid */\n\tif(brate == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\treadConfigRid(local, 1);\n\t/* Now, check if we want a fixed or auto value */\n\tif(vwrq->fixed == 0) {\n\t\t/* Fill all the rates up to this max rate */\n\t\tmemset(local->config.rates, 0, 8);\n\t\tfor(i = 0 ; i < 8 ; i++) {\n\t\t\tlocal->config.rates[i] = cap_rid.supportedRates[i];\n\t\t\tif(local->config.rates[i] == brate)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t/* Fixed mode */\n\t\t/* One rate, fixed */\n\t\tmemset(local->config.rates, 0, 8);\n\t\tlocal->config.rates[0] = brate;\n\t}\n\tset_bit (FLAG_COMMIT, &local->flags);\n\n\treturn -EINPROGRESS;\t\t/* Call commit handler */\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : get Bit-Rate\n */\nstatic int airo_get_rate(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t struct iw_param *vwrq,\n\t\t\t char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tStatusRid status_rid;\t\t/* Card status info */\n\n\treadStatusRid(local, &status_rid, 1);\n\n\tvwrq->value = le16_to_cpu(status_rid.currentXmitRate) * 500000;\n\t/* If more than one rate, set auto */\n\treadConfigRid(local, 1);\n\tvwrq->fixed = (local->config.rates[1] == 0);\n\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : set RTS threshold\n */\nstatic int airo_set_rts(struct net_device *dev,\n\t\t\tstruct iw_request_info *info,\n\t\t\tstruct iw_param *vwrq,\n\t\t\tchar *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tint rthr = vwrq->value;\n\n\tif(vwrq->disabled)\n\t\trthr = AIRO_DEF_MTU;\n\tif((rthr < 0) || (rthr > AIRO_DEF_MTU)) {\n\t\treturn -EINVAL;\n\t}\n\treadConfigRid(local, 1);\n\tlocal->config.rtsThres = cpu_to_le16(rthr);\n\tset_bit (FLAG_COMMIT, &local->flags);\n\n\treturn -EINPROGRESS;\t\t/* Call commit handler */\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : get RTS threshold\n */\nstatic int airo_get_rts(struct net_device *dev,\n\t\t\tstruct iw_request_info *info,\n\t\t\tstruct iw_param *vwrq,\n\t\t\tchar *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\n\treadConfigRid(local, 1);\n\tvwrq->value = le16_to_cpu(local->config.rtsThres);\n\tvwrq->disabled = (vwrq->value >= AIRO_DEF_MTU);\n\tvwrq->fixed = 1;\n\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : set Fragmentation threshold\n */\nstatic int airo_set_frag(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t struct iw_param *vwrq,\n\t\t\t char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tint fthr = vwrq->value;\n\n\tif(vwrq->disabled)\n\t\tfthr = AIRO_DEF_MTU;\n\tif((fthr < 256) || (fthr > AIRO_DEF_MTU)) {\n\t\treturn -EINVAL;\n\t}\n\tfthr &= ~0x1;\t/* Get an even value - is it really needed ??? */\n\treadConfigRid(local, 1);\n\tlocal->config.fragThresh = cpu_to_le16(fthr);\n\tset_bit (FLAG_COMMIT, &local->flags);\n\n\treturn -EINPROGRESS;\t\t/* Call commit handler */\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : get Fragmentation threshold\n */\nstatic int airo_get_frag(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t struct iw_param *vwrq,\n\t\t\t char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\n\treadConfigRid(local, 1);\n\tvwrq->value = le16_to_cpu(local->config.fragThresh);\n\tvwrq->disabled = (vwrq->value >= AIRO_DEF_MTU);\n\tvwrq->fixed = 1;\n\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : set Mode of Operation\n */\nstatic int airo_set_mode(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t __u32 *uwrq,\n\t\t\t char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tint reset = 0;\n\n\treadConfigRid(local, 1);\n\tif (sniffing_mode(local))\n\t\treset = 1;\n\n\tswitch(*uwrq) {\n\t\tcase IW_MODE_ADHOC:\n\t\t\tlocal->config.opmode &= ~MODE_CFG_MASK;\n\t\t\tlocal->config.opmode |= MODE_STA_IBSS;\n\t\t\tlocal->config.rmode &= ~RXMODE_FULL_MASK;\n\t\t\tlocal->config.scanMode = SCANMODE_ACTIVE;\n\t\t\tclear_bit (FLAG_802_11, &local->flags);\n\t\t\tbreak;\n\t\tcase IW_MODE_INFRA:\n\t\t\tlocal->config.opmode &= ~MODE_CFG_MASK;\n\t\t\tlocal->config.opmode |= MODE_STA_ESS;\n\t\t\tlocal->config.rmode &= ~RXMODE_FULL_MASK;\n\t\t\tlocal->config.scanMode = SCANMODE_ACTIVE;\n\t\t\tclear_bit (FLAG_802_11, &local->flags);\n\t\t\tbreak;\n\t\tcase IW_MODE_MASTER:\n\t\t\tlocal->config.opmode &= ~MODE_CFG_MASK;\n\t\t\tlocal->config.opmode |= MODE_AP;\n\t\t\tlocal->config.rmode &= ~RXMODE_FULL_MASK;\n\t\t\tlocal->config.scanMode = SCANMODE_ACTIVE;\n\t\t\tclear_bit (FLAG_802_11, &local->flags);\n\t\t\tbreak;\n\t\tcase IW_MODE_REPEAT:\n\t\t\tlocal->config.opmode &= ~MODE_CFG_MASK;\n\t\t\tlocal->config.opmode |= MODE_AP_RPTR;\n\t\t\tlocal->config.rmode &= ~RXMODE_FULL_MASK;\n\t\t\tlocal->config.scanMode = SCANMODE_ACTIVE;\n\t\t\tclear_bit (FLAG_802_11, &local->flags);\n\t\t\tbreak;\n\t\tcase IW_MODE_MONITOR:\n\t\t\tlocal->config.opmode &= ~MODE_CFG_MASK;\n\t\t\tlocal->config.opmode |= MODE_STA_ESS;\n\t\t\tlocal->config.rmode &= ~RXMODE_FULL_MASK;\n\t\t\tlocal->config.rmode |= RXMODE_RFMON | RXMODE_DISABLE_802_3_HEADER;\n\t\t\tlocal->config.scanMode = SCANMODE_PASSIVE;\n\t\t\tset_bit (FLAG_802_11, &local->flags);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\tif (reset)\n\t\tset_bit (FLAG_RESET, &local->flags);\n\tset_bit (FLAG_COMMIT, &local->flags);\n\n\treturn -EINPROGRESS;\t\t/* Call commit handler */\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : get Mode of Operation\n */\nstatic int airo_get_mode(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t __u32 *uwrq,\n\t\t\t char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\n\treadConfigRid(local, 1);\n\t/* If not managed, assume it's ad-hoc */\n\tswitch (local->config.opmode & MODE_CFG_MASK) {\n\t\tcase MODE_STA_ESS:\n\t\t\t*uwrq = IW_MODE_INFRA;\n\t\t\tbreak;\n\t\tcase MODE_AP:\n\t\t\t*uwrq = IW_MODE_MASTER;\n\t\t\tbreak;\n\t\tcase MODE_AP_RPTR:\n\t\t\t*uwrq = IW_MODE_REPEAT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*uwrq = IW_MODE_ADHOC;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int valid_index(struct airo_info *ai, int index)\n{\n\treturn (index >= 0) && (index <= ai->max_wep_idx);\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : set Encryption Key\n */\nstatic int airo_set_encode(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   struct iw_point *dwrq,\n\t\t\t   char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tint perm = (dwrq->flags & IW_ENCODE_TEMP ? 0 : 1);\n\t__le16 currentAuthType = local->config.authType;\n\tint rc = 0;\n\n\tif (!local->wep_capable)\n\t\treturn -EOPNOTSUPP;\n\n\treadConfigRid(local, 1);\n\n\t/* Basic checking: do we have a key to set ?\n\t * Note : with the new API, it's impossible to get a NULL pointer.\n\t * Therefore, we need to check a key size == 0 instead.\n\t * New version of iwconfig properly set the IW_ENCODE_NOKEY flag\n\t * when no key is present (only change flags), but older versions\n\t * don't do it. - Jean II */\n\tif (dwrq->length > 0) {\n\t\twep_key_t key;\n\t\tint index = (dwrq->flags & IW_ENCODE_INDEX) - 1;\n\t\tint current_index;\n\n\t\t/* Check the size of the key */\n\t\tif (dwrq->length > MAX_KEY_SIZE) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcurrent_index = get_wep_tx_idx(local);\n\t\tif (current_index < 0)\n\t\t\tcurrent_index = 0;\n\n\t\t/* Check the index (none -> use current) */\n\t\tif (!valid_index(local, index))\n\t\t\tindex = current_index;\n\n\t\t/* Set the length */\n\t\tif (dwrq->length > MIN_KEY_SIZE)\n\t\t\tkey.len = MAX_KEY_SIZE;\n\t\telse\n\t\t\tkey.len = MIN_KEY_SIZE;\n\t\t/* Check if the key is not marked as invalid */\n\t\tif(!(dwrq->flags & IW_ENCODE_NOKEY)) {\n\t\t\t/* Cleanup */\n\t\t\tmemset(key.key, 0, MAX_KEY_SIZE);\n\t\t\t/* Copy the key in the driver */\n\t\t\tmemcpy(key.key, extra, dwrq->length);\n\t\t\t/* Send the key to the card */\n\t\t\trc = set_wep_key(local, index, key.key, key.len, perm, 1);\n\t\t\tif (rc < 0) {\n\t\t\t\tairo_print_err(local->dev->name, \"failed to set\"\n\t\t\t\t               \" WEP key at index %d: %d.\",\n\t\t\t\t               index, rc);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t\t/* WE specify that if a valid key is set, encryption\n\t\t * should be enabled (user may turn it off later)\n\t\t * This is also how \"iwconfig ethX key on\" works */\n\t\tif((index == current_index) && (key.len > 0) &&\n\t\t   (local->config.authType == AUTH_OPEN)) {\n\t\t\tlocal->config.authType = AUTH_ENCRYPT;\n\t\t}\n\t} else {\n\t\t/* Do we want to just set the transmit key index ? */\n\t\tint index = (dwrq->flags & IW_ENCODE_INDEX) - 1;\n\t\tif (valid_index(local, index)) {\n\t\t\trc = set_wep_tx_idx(local, index, perm, 1);\n\t\t\tif (rc < 0) {\n\t\t\t\tairo_print_err(local->dev->name, \"failed to set\"\n\t\t\t\t               \" WEP transmit index to %d: %d.\",\n\t\t\t\t               index, rc);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Don't complain if only change the mode */\n\t\t\tif (!(dwrq->flags & IW_ENCODE_MODE))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\t/* Read the flags */\n\tif(dwrq->flags & IW_ENCODE_DISABLED)\n\t\tlocal->config.authType = AUTH_OPEN;\t// disable encryption\n\tif(dwrq->flags & IW_ENCODE_RESTRICTED)\n\t\tlocal->config.authType = AUTH_SHAREDKEY;\t// Only Both\n\tif(dwrq->flags & IW_ENCODE_OPEN)\n\t\tlocal->config.authType = AUTH_ENCRYPT;\t// Only Wep\n\t/* Commit the changes to flags if needed */\n\tif (local->config.authType != currentAuthType)\n\t\tset_bit (FLAG_COMMIT, &local->flags);\n\treturn -EINPROGRESS;\t\t/* Call commit handler */\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : get Encryption Key\n */\nstatic int airo_get_encode(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   struct iw_point *dwrq,\n\t\t\t   char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tint index = (dwrq->flags & IW_ENCODE_INDEX) - 1;\n\tint wep_key_len;\n\tu8 buf[16];\n\n\tif (!local->wep_capable)\n\t\treturn -EOPNOTSUPP;\n\n\treadConfigRid(local, 1);\n\n\t/* Check encryption mode */\n\tswitch(local->config.authType)\t{\n\t\tcase AUTH_ENCRYPT:\n\t\t\tdwrq->flags = IW_ENCODE_OPEN;\n\t\t\tbreak;\n\t\tcase AUTH_SHAREDKEY:\n\t\t\tdwrq->flags = IW_ENCODE_RESTRICTED;\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase AUTH_OPEN:\n\t\t\tdwrq->flags = IW_ENCODE_DISABLED;\n\t\t\tbreak;\n\t}\n\t/* We can't return the key, so set the proper flag and return zero */\n\tdwrq->flags |= IW_ENCODE_NOKEY;\n\tmemset(extra, 0, 16);\n\n\t/* Which key do we want ? -1 -> tx index */\n\tif (!valid_index(local, index)) {\n\t\tindex = get_wep_tx_idx(local);\n\t\tif (index < 0)\n\t\t\tindex = 0;\n\t}\n\tdwrq->flags |= index + 1;\n\n\t/* Copy the key to the user buffer */\n\twep_key_len = get_wep_key(local, index, &buf[0], sizeof(buf));\n\tif (wep_key_len < 0) {\n\t\tdwrq->length = 0;\n\t} else {\n\t\tdwrq->length = wep_key_len;\n\t\tmemcpy(extra, buf, dwrq->length);\n\t}\n\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : set extended Encryption parameters\n */\nstatic int airo_set_encodeext(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu,\n\t\t\t    char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tstruct iw_point *encoding = &wrqu->encoding;\n\tstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\n\tint perm = ( encoding->flags & IW_ENCODE_TEMP ? 0 : 1 );\n\t__le16 currentAuthType = local->config.authType;\n\tint idx, key_len, alg = ext->alg, set_key = 1, rc;\n\twep_key_t key;\n\n\tif (!local->wep_capable)\n\t\treturn -EOPNOTSUPP;\n\n\treadConfigRid(local, 1);\n\n\t/* Determine and validate the key index */\n\tidx = encoding->flags & IW_ENCODE_INDEX;\n\tif (idx) {\n\t\tif (!valid_index(local, idx - 1))\n\t\t\treturn -EINVAL;\n\t\tidx--;\n\t} else {\n\t\tidx = get_wep_tx_idx(local);\n\t\tif (idx < 0)\n\t\t\tidx = 0;\n\t}\n\n\tif (encoding->flags & IW_ENCODE_DISABLED)\n\t\talg = IW_ENCODE_ALG_NONE;\n\n\tif (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {\n\t\t/* Only set transmit key index here, actual\n\t\t * key is set below if needed.\n\t\t */\n\t\trc = set_wep_tx_idx(local, idx, perm, 1);\n\t\tif (rc < 0) {\n\t\t\tairo_print_err(local->dev->name, \"failed to set \"\n\t\t\t               \"WEP transmit index to %d: %d.\",\n\t\t\t               idx, rc);\n\t\t\treturn rc;\n\t\t}\n\t\tset_key = ext->key_len > 0 ? 1 : 0;\n\t}\n\n\tif (set_key) {\n\t\t/* Set the requested key first */\n\t\tmemset(key.key, 0, MAX_KEY_SIZE);\n\t\tswitch (alg) {\n\t\tcase IW_ENCODE_ALG_NONE:\n\t\t\tkey.len = 0;\n\t\t\tbreak;\n\t\tcase IW_ENCODE_ALG_WEP:\n\t\t\tif (ext->key_len > MIN_KEY_SIZE) {\n\t\t\t\tkey.len = MAX_KEY_SIZE;\n\t\t\t} else if (ext->key_len > 0) {\n\t\t\t\tkey.len = MIN_KEY_SIZE;\n\t\t\t} else {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tkey_len = min (ext->key_len, key.len);\n\t\t\tmemcpy(key.key, ext->key, key_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (key.len == 0) {\n\t\t\trc = set_wep_tx_idx(local, idx, perm, 1);\n\t\t\tif (rc < 0) {\n\t\t\t\tairo_print_err(local->dev->name,\n\t\t\t\t\t       \"failed to set WEP transmit index to %d: %d.\",\n\t\t\t\t\t       idx, rc);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t} else {\n\t\t\trc = set_wep_key(local, idx, key.key, key.len, perm, 1);\n\t\t\tif (rc < 0) {\n\t\t\t\tairo_print_err(local->dev->name,\n\t\t\t\t\t       \"failed to set WEP key at index %d: %d.\",\n\t\t\t\t\t       idx, rc);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Read the flags */\n\tif(encoding->flags & IW_ENCODE_DISABLED)\n\t\tlocal->config.authType = AUTH_OPEN;\t// disable encryption\n\tif(encoding->flags & IW_ENCODE_RESTRICTED)\n\t\tlocal->config.authType = AUTH_SHAREDKEY;\t// Only Both\n\tif(encoding->flags & IW_ENCODE_OPEN)\n\t\tlocal->config.authType = AUTH_ENCRYPT;\t// Only Wep\n\t/* Commit the changes to flags if needed */\n\tif (local->config.authType != currentAuthType)\n\t\tset_bit (FLAG_COMMIT, &local->flags);\n\n\treturn -EINPROGRESS;\n}\n\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : get extended Encryption parameters\n */\nstatic int airo_get_encodeext(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu,\n\t\t\t    char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tstruct iw_point *encoding = &wrqu->encoding;\n\tstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\n\tint idx, max_key_len, wep_key_len;\n\tu8 buf[16];\n\n\tif (!local->wep_capable)\n\t\treturn -EOPNOTSUPP;\n\n\treadConfigRid(local, 1);\n\n\tmax_key_len = encoding->length - sizeof(*ext);\n\tif (max_key_len < 0)\n\t\treturn -EINVAL;\n\n\tidx = encoding->flags & IW_ENCODE_INDEX;\n\tif (idx) {\n\t\tif (!valid_index(local, idx - 1))\n\t\t\treturn -EINVAL;\n\t\tidx--;\n\t} else {\n\t\tidx = get_wep_tx_idx(local);\n\t\tif (idx < 0)\n\t\t\tidx = 0;\n\t}\n\n\tencoding->flags = idx + 1;\n\tmemset(ext, 0, sizeof(*ext));\n\n\t/* Check encryption mode */\n\tswitch(local->config.authType) {\n\t\tcase AUTH_ENCRYPT:\n\t\t\tencoding->flags = IW_ENCODE_ALG_WEP | IW_ENCODE_ENABLED;\n\t\t\tbreak;\n\t\tcase AUTH_SHAREDKEY:\n\t\t\tencoding->flags = IW_ENCODE_ALG_WEP | IW_ENCODE_ENABLED;\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase AUTH_OPEN:\n\t\t\tencoding->flags = IW_ENCODE_ALG_NONE | IW_ENCODE_DISABLED;\n\t\t\tbreak;\n\t}\n\t/* We can't return the key, so set the proper flag and return zero */\n\tencoding->flags |= IW_ENCODE_NOKEY;\n\tmemset(extra, 0, 16);\n\t\n\t/* Copy the key to the user buffer */\n\twep_key_len = get_wep_key(local, idx, &buf[0], sizeof(buf));\n\tif (wep_key_len < 0) {\n\t\text->key_len = 0;\n\t} else {\n\t\text->key_len = wep_key_len;\n\t\tmemcpy(extra, buf, ext->key_len);\n\t}\n\n\treturn 0;\n}\n\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : set extended authentication parameters\n */\nstatic int airo_set_auth(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tstruct iw_param *param = &wrqu->param;\n\t__le16 currentAuthType = local->config.authType;\n\n\tswitch (param->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_WPA_VERSION:\n\tcase IW_AUTH_CIPHER_PAIRWISE:\n\tcase IW_AUTH_CIPHER_GROUP:\n\tcase IW_AUTH_KEY_MGMT:\n\tcase IW_AUTH_RX_UNENCRYPTED_EAPOL:\n\tcase IW_AUTH_PRIVACY_INVOKED:\n\t\t/*\n\t\t * airo does not use these parameters\n\t\t */\n\t\tbreak;\n\n\tcase IW_AUTH_DROP_UNENCRYPTED:\n\t\tif (param->value) {\n\t\t\t/* Only change auth type if unencrypted */\n\t\t\tif (currentAuthType == AUTH_OPEN)\n\t\t\t\tlocal->config.authType = AUTH_ENCRYPT;\n\t\t} else {\n\t\t\tlocal->config.authType = AUTH_OPEN;\n\t\t}\n\n\t\t/* Commit the changes to flags if needed */\n\t\tif (local->config.authType != currentAuthType)\n\t\t\tset_bit (FLAG_COMMIT, &local->flags);\n\t\tbreak;\n\n\tcase IW_AUTH_80211_AUTH_ALG: {\n\t\t\t/* FIXME: What about AUTH_OPEN?  This API seems to\n\t\t\t * disallow setting our auth to AUTH_OPEN.\n\t\t\t */\n\t\t\tif (param->value & IW_AUTH_ALG_SHARED_KEY) {\n\t\t\t\tlocal->config.authType = AUTH_SHAREDKEY;\n\t\t\t} else if (param->value & IW_AUTH_ALG_OPEN_SYSTEM) {\n\t\t\t\tlocal->config.authType = AUTH_ENCRYPT;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\n\t\t\t/* Commit the changes to flags if needed */\n\t\t\tif (local->config.authType != currentAuthType)\n\t\t\t\tset_bit (FLAG_COMMIT, &local->flags);\n\t\t\tbreak;\n\t\t}\n\n\tcase IW_AUTH_WPA_ENABLED:\n\t\t/* Silently accept disable of WPA */\n\t\tif (param->value > 0)\n\t\t\treturn -EOPNOTSUPP;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn -EINPROGRESS;\n}\n\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : get extended authentication parameters\n */\nstatic int airo_get_auth(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tstruct iw_param *param = &wrqu->param;\n\t__le16 currentAuthType = local->config.authType;\n\n\tswitch (param->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_DROP_UNENCRYPTED:\n\t\tswitch (currentAuthType) {\n\t\tcase AUTH_SHAREDKEY:\n\t\tcase AUTH_ENCRYPT:\n\t\t\tparam->value = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparam->value = 0;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tswitch (currentAuthType) {\n\t\tcase AUTH_SHAREDKEY:\n\t\t\tparam->value = IW_AUTH_ALG_SHARED_KEY;\n\t\t\tbreak;\n\t\tcase AUTH_ENCRYPT:\n\t\tdefault:\n\t\t\tparam->value = IW_AUTH_ALG_OPEN_SYSTEM;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase IW_AUTH_WPA_ENABLED:\n\t\tparam->value = 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : set Tx-Power\n */\nstatic int airo_set_txpow(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  struct iw_param *vwrq,\n\t\t\t  char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tCapabilityRid cap_rid;\t\t/* Card capability info */\n\tint i;\n\tint rc = -EINVAL;\n\t__le16 v = cpu_to_le16(vwrq->value);\n\n\treadCapabilityRid(local, &cap_rid, 1);\n\n\tif (vwrq->disabled) {\n\t\tset_bit (FLAG_RADIO_OFF, &local->flags);\n\t\tset_bit (FLAG_COMMIT, &local->flags);\n\t\treturn -EINPROGRESS;\t\t/* Call commit handler */\n\t}\n\tif (vwrq->flags != IW_TXPOW_MWATT) {\n\t\treturn -EINVAL;\n\t}\n\tclear_bit (FLAG_RADIO_OFF, &local->flags);\n\tfor (i = 0; i < 8 && cap_rid.txPowerLevels[i]; i++)\n\t\tif (v == cap_rid.txPowerLevels[i]) {\n\t\t\treadConfigRid(local, 1);\n\t\t\tlocal->config.txPower = v;\n\t\t\tset_bit (FLAG_COMMIT, &local->flags);\n\t\t\trc = -EINPROGRESS;\t/* Call commit handler */\n\t\t\tbreak;\n\t\t}\n\treturn rc;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : get Tx-Power\n */\nstatic int airo_get_txpow(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  struct iw_param *vwrq,\n\t\t\t  char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\n\treadConfigRid(local, 1);\n\tvwrq->value = le16_to_cpu(local->config.txPower);\n\tvwrq->fixed = 1;\t/* No power control */\n\tvwrq->disabled = test_bit(FLAG_RADIO_OFF, &local->flags);\n\tvwrq->flags = IW_TXPOW_MWATT;\n\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : set Retry limits\n */\nstatic int airo_set_retry(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  struct iw_param *vwrq,\n\t\t\t  char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tint rc = -EINVAL;\n\n\tif(vwrq->disabled) {\n\t\treturn -EINVAL;\n\t}\n\treadConfigRid(local, 1);\n\tif(vwrq->flags & IW_RETRY_LIMIT) {\n\t\t__le16 v = cpu_to_le16(vwrq->value);\n\t\tif(vwrq->flags & IW_RETRY_LONG)\n\t\t\tlocal->config.longRetryLimit = v;\n\t\telse if (vwrq->flags & IW_RETRY_SHORT)\n\t\t\tlocal->config.shortRetryLimit = v;\n\t\telse {\n\t\t\t/* No modifier : set both */\n\t\t\tlocal->config.longRetryLimit = v;\n\t\t\tlocal->config.shortRetryLimit = v;\n\t\t}\n\t\tset_bit (FLAG_COMMIT, &local->flags);\n\t\trc = -EINPROGRESS;\t\t/* Call commit handler */\n\t}\n\tif(vwrq->flags & IW_RETRY_LIFETIME) {\n\t\tlocal->config.txLifetime = cpu_to_le16(vwrq->value / 1024);\n\t\tset_bit (FLAG_COMMIT, &local->flags);\n\t\trc = -EINPROGRESS;\t\t/* Call commit handler */\n\t}\n\treturn rc;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : get Retry limits\n */\nstatic int airo_get_retry(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  struct iw_param *vwrq,\n\t\t\t  char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\n\tvwrq->disabled = 0;      /* Can't be disabled */\n\n\treadConfigRid(local, 1);\n\t/* Note : by default, display the min retry number */\n\tif((vwrq->flags & IW_RETRY_TYPE) == IW_RETRY_LIFETIME) {\n\t\tvwrq->flags = IW_RETRY_LIFETIME;\n\t\tvwrq->value = le16_to_cpu(local->config.txLifetime) * 1024;\n\t} else if((vwrq->flags & IW_RETRY_LONG)) {\n\t\tvwrq->flags = IW_RETRY_LIMIT | IW_RETRY_LONG;\n\t\tvwrq->value = le16_to_cpu(local->config.longRetryLimit);\n\t} else {\n\t\tvwrq->flags = IW_RETRY_LIMIT;\n\t\tvwrq->value = le16_to_cpu(local->config.shortRetryLimit);\n\t\tif(local->config.shortRetryLimit != local->config.longRetryLimit)\n\t\t\tvwrq->flags |= IW_RETRY_SHORT;\n\t}\n\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : get range info\n */\nstatic int airo_get_range(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  struct iw_point *dwrq,\n\t\t\t  char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tstruct iw_range *range = (struct iw_range *) extra;\n\tCapabilityRid cap_rid;\t\t/* Card capability info */\n\tint\t\ti;\n\tint\t\tk;\n\n\treadCapabilityRid(local, &cap_rid, 1);\n\n\tdwrq->length = sizeof(struct iw_range);\n\tmemset(range, 0, sizeof(*range));\n\trange->min_nwid = 0x0000;\n\trange->max_nwid = 0x0000;\n\trange->num_channels = 14;\n\t/* Should be based on cap_rid.country to give only\n\t * what the current card support */\n\tk = 0;\n\tfor(i = 0; i < 14; i++) {\n\t\trange->freq[k].i = i + 1; /* List index */\n\t\trange->freq[k].m = ieee80211_dsss_chan_to_freq(i + 1) * 100000;\n\t\trange->freq[k++].e = 1;\t/* Values in MHz -> * 10^5 * 10 */\n\t}\n\trange->num_frequency = k;\n\n\trange->sensitivity = 65535;\n\n\t/* Hum... Should put the right values there */\n\tif (local->rssi)\n\t\trange->max_qual.qual = 100;\t/* % */\n\telse\n\t\trange->max_qual.qual = airo_get_max_quality(&cap_rid);\n\trange->max_qual.level = 0x100 - 120;\t/* -120 dBm */\n\trange->max_qual.noise = 0x100 - 120;\t/* -120 dBm */\n\n\t/* Experimental measurements - boundary 11/5.5 Mb/s */\n\t/* Note : with or without the (local->rssi), results\n\t * are somewhat different. - Jean II */\n\tif (local->rssi) {\n\t\trange->avg_qual.qual = 50;\t\t/* % */\n\t\trange->avg_qual.level = 0x100 - 70;\t/* -70 dBm */\n\t} else {\n\t\trange->avg_qual.qual = airo_get_avg_quality(&cap_rid);\n\t\trange->avg_qual.level = 0x100 - 80;\t/* -80 dBm */\n\t}\n\trange->avg_qual.noise = 0x100 - 85;\t\t/* -85 dBm */\n\n\tfor(i = 0 ; i < 8 ; i++) {\n\t\trange->bitrate[i] = cap_rid.supportedRates[i] * 500000;\n\t\tif(range->bitrate[i] == 0)\n\t\t\tbreak;\n\t}\n\trange->num_bitrates = i;\n\n\t/* Set an indication of the max TCP throughput\n\t * in bit/s that we can expect using this interface.\n\t * May be use for QoS stuff... Jean II */\n\tif(i > 2)\n\t\trange->throughput = 5000 * 1000;\n\telse\n\t\trange->throughput = 1500 * 1000;\n\n\trange->min_rts = 0;\n\trange->max_rts = AIRO_DEF_MTU;\n\trange->min_frag = 256;\n\trange->max_frag = AIRO_DEF_MTU;\n\n\tif(cap_rid.softCap & cpu_to_le16(2)) {\n\t\t// WEP: RC4 40 bits\n\t\trange->encoding_size[0] = 5;\n\t\t// RC4 ~128 bits\n\t\tif (cap_rid.softCap & cpu_to_le16(0x100)) {\n\t\t\trange->encoding_size[1] = 13;\n\t\t\trange->num_encoding_sizes = 2;\n\t\t} else\n\t\t\trange->num_encoding_sizes = 1;\n\t\trange->max_encoding_tokens =\n\t\t\tcap_rid.softCap & cpu_to_le16(0x80) ? 4 : 1;\n\t} else {\n\t\trange->num_encoding_sizes = 0;\n\t\trange->max_encoding_tokens = 0;\n\t}\n\trange->min_pmp = 0;\n\trange->max_pmp = 5000000;\t/* 5 secs */\n\trange->min_pmt = 0;\n\trange->max_pmt = 65535 * 1024;\t/* ??? */\n\trange->pmp_flags = IW_POWER_PERIOD;\n\trange->pmt_flags = IW_POWER_TIMEOUT;\n\trange->pm_capa = IW_POWER_PERIOD | IW_POWER_TIMEOUT | IW_POWER_ALL_R;\n\n\t/* Transmit Power - values are in mW */\n\tfor(i = 0 ; i < 8 ; i++) {\n\t\trange->txpower[i] = le16_to_cpu(cap_rid.txPowerLevels[i]);\n\t\tif(range->txpower[i] == 0)\n\t\t\tbreak;\n\t}\n\trange->num_txpower = i;\n\trange->txpower_capa = IW_TXPOW_MWATT;\n\trange->we_version_source = 19;\n\trange->we_version_compiled = WIRELESS_EXT;\n\trange->retry_capa = IW_RETRY_LIMIT | IW_RETRY_LIFETIME;\n\trange->retry_flags = IW_RETRY_LIMIT;\n\trange->r_time_flags = IW_RETRY_LIFETIME;\n\trange->min_retry = 1;\n\trange->max_retry = 65535;\n\trange->min_r_time = 1024;\n\trange->max_r_time = 65535 * 1024;\n\n\t/* Event capability (kernel + driver) */\n\trange->event_capa[0] = (IW_EVENT_CAPA_K_0 |\n\t\t\t\tIW_EVENT_CAPA_MASK(SIOCGIWTHRSPY) |\n\t\t\t\tIW_EVENT_CAPA_MASK(SIOCGIWAP) |\n\t\t\t\tIW_EVENT_CAPA_MASK(SIOCGIWSCAN));\n\trange->event_capa[1] = IW_EVENT_CAPA_K_1;\n\trange->event_capa[4] = IW_EVENT_CAPA_MASK(IWEVTXDROP);\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : set Power Management\n */\nstatic int airo_set_power(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  struct iw_param *vwrq,\n\t\t\t  char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\n\treadConfigRid(local, 1);\n\tif (vwrq->disabled) {\n\t\tif (sniffing_mode(local))\n\t\t\treturn -EINVAL;\n\t\tlocal->config.powerSaveMode = POWERSAVE_CAM;\n\t\tlocal->config.rmode &= ~RXMODE_MASK;\n\t\tlocal->config.rmode |= RXMODE_BC_MC_ADDR;\n\t\tset_bit (FLAG_COMMIT, &local->flags);\n\t\treturn -EINPROGRESS;\t\t/* Call commit handler */\n\t}\n\tif ((vwrq->flags & IW_POWER_TYPE) == IW_POWER_TIMEOUT) {\n\t\tlocal->config.fastListenDelay = cpu_to_le16((vwrq->value + 500) / 1024);\n\t\tlocal->config.powerSaveMode = POWERSAVE_PSPCAM;\n\t\tset_bit (FLAG_COMMIT, &local->flags);\n\t} else if ((vwrq->flags & IW_POWER_TYPE) == IW_POWER_PERIOD) {\n\t\tlocal->config.fastListenInterval =\n\t\tlocal->config.listenInterval =\n\t\t\tcpu_to_le16((vwrq->value + 500) / 1024);\n\t\tlocal->config.powerSaveMode = POWERSAVE_PSPCAM;\n\t\tset_bit (FLAG_COMMIT, &local->flags);\n\t}\n\tswitch (vwrq->flags & IW_POWER_MODE) {\n\t\tcase IW_POWER_UNICAST_R:\n\t\t\tif (sniffing_mode(local))\n\t\t\t\treturn -EINVAL;\n\t\t\tlocal->config.rmode &= ~RXMODE_MASK;\n\t\t\tlocal->config.rmode |= RXMODE_ADDR;\n\t\t\tset_bit (FLAG_COMMIT, &local->flags);\n\t\t\tbreak;\n\t\tcase IW_POWER_ALL_R:\n\t\t\tif (sniffing_mode(local))\n\t\t\t\treturn -EINVAL;\n\t\t\tlocal->config.rmode &= ~RXMODE_MASK;\n\t\t\tlocal->config.rmode |= RXMODE_BC_MC_ADDR;\n\t\t\tset_bit (FLAG_COMMIT, &local->flags);\n\t\tcase IW_POWER_ON:\n\t\t\t/* This is broken, fixme ;-) */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\t// Note : we may want to factor local->need_commit here\n\t// Note2 : may also want to factor RXMODE_RFMON test\n\treturn -EINPROGRESS;\t\t/* Call commit handler */\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : get Power Management\n */\nstatic int airo_get_power(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  struct iw_param *vwrq,\n\t\t\t  char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\t__le16 mode;\n\n\treadConfigRid(local, 1);\n\tmode = local->config.powerSaveMode;\n\tif ((vwrq->disabled = (mode == POWERSAVE_CAM)))\n\t\treturn 0;\n\tif ((vwrq->flags & IW_POWER_TYPE) == IW_POWER_TIMEOUT) {\n\t\tvwrq->value = le16_to_cpu(local->config.fastListenDelay) * 1024;\n\t\tvwrq->flags = IW_POWER_TIMEOUT;\n\t} else {\n\t\tvwrq->value = le16_to_cpu(local->config.fastListenInterval) * 1024;\n\t\tvwrq->flags = IW_POWER_PERIOD;\n\t}\n\tif ((local->config.rmode & RXMODE_MASK) == RXMODE_ADDR)\n\t\tvwrq->flags |= IW_POWER_UNICAST_R;\n\telse\n\t\tvwrq->flags |= IW_POWER_ALL_R;\n\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : set Sensitivity\n */\nstatic int airo_set_sens(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t struct iw_param *vwrq,\n\t\t\t char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\n\treadConfigRid(local, 1);\n\tlocal->config.rssiThreshold =\n\t\tcpu_to_le16(vwrq->disabled ? RSSI_DEFAULT : vwrq->value);\n\tset_bit (FLAG_COMMIT, &local->flags);\n\n\treturn -EINPROGRESS;\t\t/* Call commit handler */\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : get Sensitivity\n */\nstatic int airo_get_sens(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t struct iw_param *vwrq,\n\t\t\t char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\n\treadConfigRid(local, 1);\n\tvwrq->value = le16_to_cpu(local->config.rssiThreshold);\n\tvwrq->disabled = (vwrq->value == 0);\n\tvwrq->fixed = 1;\n\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : get AP List\n * Note : this is deprecated in favor of IWSCAN\n */\nstatic int airo_get_aplist(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   struct iw_point *dwrq,\n\t\t\t   char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tstruct sockaddr *address = (struct sockaddr *) extra;\n\tstruct iw_quality *qual;\n\tBSSListRid BSSList;\n\tint i;\n\tint loseSync = capable(CAP_NET_ADMIN) ? 1: -1;\n\n\tqual = kmalloc(IW_MAX_AP * sizeof(*qual), GFP_KERNEL);\n\tif (!qual)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < IW_MAX_AP; i++) {\n\t\tu16 dBm;\n\t\tif (readBSSListRid(local, loseSync, &BSSList))\n\t\t\tbreak;\n\t\tloseSync = 0;\n\t\tmemcpy(address[i].sa_data, BSSList.bssid, ETH_ALEN);\n\t\taddress[i].sa_family = ARPHRD_ETHER;\n\t\tdBm = le16_to_cpu(BSSList.dBm);\n\t\tif (local->rssi) {\n\t\t\tqual[i].level = 0x100 - dBm;\n\t\t\tqual[i].qual = airo_dbm_to_pct(local->rssi, dBm);\n\t\t\tqual[i].updated = IW_QUAL_QUAL_UPDATED\n\t\t\t\t\t| IW_QUAL_LEVEL_UPDATED\n\t\t\t\t\t| IW_QUAL_DBM;\n\t\t} else {\n\t\t\tqual[i].level = (dBm + 321) / 2;\n\t\t\tqual[i].qual = 0;\n\t\t\tqual[i].updated = IW_QUAL_QUAL_INVALID\n\t\t\t\t\t| IW_QUAL_LEVEL_UPDATED\n\t\t\t\t\t| IW_QUAL_DBM;\n\t\t}\n\t\tqual[i].noise = local->wstats.qual.noise;\n\t\tif (BSSList.index == cpu_to_le16(0xffff))\n\t\t\tbreak;\n\t}\n\tif (!i) {\n\t\tStatusRid status_rid;\t\t/* Card status info */\n\t\treadStatusRid(local, &status_rid, 1);\n\t\tfor (i = 0;\n\t\t     i < min(IW_MAX_AP, 4) &&\n\t\t\t     (status_rid.bssid[i][0]\n\t\t\t      & status_rid.bssid[i][1]\n\t\t\t      & status_rid.bssid[i][2]\n\t\t\t      & status_rid.bssid[i][3]\n\t\t\t      & status_rid.bssid[i][4]\n\t\t\t      & status_rid.bssid[i][5])!=0xff &&\n\t\t\t     (status_rid.bssid[i][0]\n\t\t\t      | status_rid.bssid[i][1]\n\t\t\t      | status_rid.bssid[i][2]\n\t\t\t      | status_rid.bssid[i][3]\n\t\t\t      | status_rid.bssid[i][4]\n\t\t\t      | status_rid.bssid[i][5]);\n\t\t     i++) {\n\t\t\tmemcpy(address[i].sa_data,\n\t\t\t       status_rid.bssid[i], ETH_ALEN);\n\t\t\taddress[i].sa_family = ARPHRD_ETHER;\n\t\t}\n\t} else {\n\t\tdwrq->flags = 1; /* Should be define'd */\n\t\tmemcpy(extra + sizeof(struct sockaddr)*i,\n\t\t       &qual,  sizeof(struct iw_quality)*i);\n\t}\n\tdwrq->length = i;\n\n\tkfree(qual);\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : Initiate Scan\n */\nstatic int airo_set_scan(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t struct iw_point *dwrq,\n\t\t\t char *extra)\n{\n\tstruct airo_info *ai = dev->ml_priv;\n\tCmd cmd;\n\tResp rsp;\n\tint wake = 0;\n\n\t/* Note : you may have realised that, as this is a SET operation,\n\t * this is privileged and therefore a normal user can't\n\t * perform scanning.\n\t * This is not an error, while the device perform scanning,\n\t * traffic doesn't flow, so it's a perfect DoS...\n\t * Jean II */\n\tif (ai->flags & FLAG_RADIO_MASK) return -ENETDOWN;\n\n\tif (down_interruptible(&ai->sem))\n\t\treturn -ERESTARTSYS;\n\n\t/* If there's already a scan in progress, don't\n\t * trigger another one. */\n\tif (ai->scan_timeout > 0)\n\t\tgoto out;\n\n\t/* Initiate a scan command */\n\tai->scan_timeout = RUN_AT(3*HZ);\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.cmd=CMD_LISTBSS;\n\tissuecommand(ai, &cmd, &rsp);\n\twake = 1;\n\nout:\n\tup(&ai->sem);\n\tif (wake)\n\t\twake_up_interruptible(&ai->thr_wait);\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Translate scan data returned from the card to a card independent\n * format that the Wireless Tools will understand - Jean II\n */\nstatic inline char *airo_translate_scan(struct net_device *dev,\n\t\t\t\t\tstruct iw_request_info *info,\n\t\t\t\t\tchar *current_ev,\n\t\t\t\t\tchar *end_buf,\n\t\t\t\t\tBSSListRid *bss)\n{\n\tstruct airo_info *ai = dev->ml_priv;\n\tstruct iw_event\t\tiwe;\t\t/* Temporary buffer */\n\t__le16\t\t\tcapabilities;\n\tchar *\t\t\tcurrent_val;\t/* For rates */\n\tint\t\t\ti;\n\tchar *\t\tbuf;\n\tu16 dBm;\n\n\t/* First entry *MUST* be the AP MAC address */\n\tiwe.cmd = SIOCGIWAP;\n\tiwe.u.ap_addr.sa_family = ARPHRD_ETHER;\n\tmemcpy(iwe.u.ap_addr.sa_data, bss->bssid, ETH_ALEN);\n\tcurrent_ev = iwe_stream_add_event(info, current_ev, end_buf,\n\t\t\t\t\t  &iwe, IW_EV_ADDR_LEN);\n\n\t/* Other entries will be displayed in the order we give them */\n\n\t/* Add the ESSID */\n\tiwe.u.data.length = bss->ssidLen;\n\tif(iwe.u.data.length > 32)\n\t\tiwe.u.data.length = 32;\n\tiwe.cmd = SIOCGIWESSID;\n\tiwe.u.data.flags = 1;\n\tcurrent_ev = iwe_stream_add_point(info, current_ev, end_buf,\n\t\t\t\t\t  &iwe, bss->ssid);\n\n\t/* Add mode */\n\tiwe.cmd = SIOCGIWMODE;\n\tcapabilities = bss->cap;\n\tif(capabilities & (CAP_ESS | CAP_IBSS)) {\n\t\tif(capabilities & CAP_ESS)\n\t\t\tiwe.u.mode = IW_MODE_MASTER;\n\t\telse\n\t\t\tiwe.u.mode = IW_MODE_ADHOC;\n\t\tcurrent_ev = iwe_stream_add_event(info, current_ev, end_buf,\n\t\t\t\t\t\t  &iwe, IW_EV_UINT_LEN);\n\t}\n\n\t/* Add frequency */\n\tiwe.cmd = SIOCGIWFREQ;\n\tiwe.u.freq.m = le16_to_cpu(bss->dsChannel);\n\tiwe.u.freq.m = ieee80211_dsss_chan_to_freq(iwe.u.freq.m) * 100000;\n\tiwe.u.freq.e = 1;\n\tcurrent_ev = iwe_stream_add_event(info, current_ev, end_buf,\n\t\t\t\t\t  &iwe, IW_EV_FREQ_LEN);\n\n\tdBm = le16_to_cpu(bss->dBm);\n\n\t/* Add quality statistics */\n\tiwe.cmd = IWEVQUAL;\n\tif (ai->rssi) {\n\t\tiwe.u.qual.level = 0x100 - dBm;\n\t\tiwe.u.qual.qual = airo_dbm_to_pct(ai->rssi, dBm);\n\t\tiwe.u.qual.updated = IW_QUAL_QUAL_UPDATED\n\t\t\t\t| IW_QUAL_LEVEL_UPDATED\n\t\t\t\t| IW_QUAL_DBM;\n\t} else {\n\t\tiwe.u.qual.level = (dBm + 321) / 2;\n\t\tiwe.u.qual.qual = 0;\n\t\tiwe.u.qual.updated = IW_QUAL_QUAL_INVALID\n\t\t\t\t| IW_QUAL_LEVEL_UPDATED\n\t\t\t\t| IW_QUAL_DBM;\n\t}\n\tiwe.u.qual.noise = ai->wstats.qual.noise;\n\tcurrent_ev = iwe_stream_add_event(info, current_ev, end_buf,\n\t\t\t\t\t  &iwe, IW_EV_QUAL_LEN);\n\n\t/* Add encryption capability */\n\tiwe.cmd = SIOCGIWENCODE;\n\tif(capabilities & CAP_PRIVACY)\n\t\tiwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;\n\telse\n\t\tiwe.u.data.flags = IW_ENCODE_DISABLED;\n\tiwe.u.data.length = 0;\n\tcurrent_ev = iwe_stream_add_point(info, current_ev, end_buf,\n\t\t\t\t\t  &iwe, bss->ssid);\n\n\t/* Rate : stuffing multiple values in a single event require a bit\n\t * more of magic - Jean II */\n\tcurrent_val = current_ev + iwe_stream_lcp_len(info);\n\n\tiwe.cmd = SIOCGIWRATE;\n\t/* Those two flags are ignored... */\n\tiwe.u.bitrate.fixed = iwe.u.bitrate.disabled = 0;\n\t/* Max 8 values */\n\tfor(i = 0 ; i < 8 ; i++) {\n\t\t/* NULL terminated */\n\t\tif(bss->rates[i] == 0)\n\t\t\tbreak;\n\t\t/* Bit rate given in 500 kb/s units (+ 0x80) */\n\t\tiwe.u.bitrate.value = ((bss->rates[i] & 0x7f) * 500000);\n\t\t/* Add new value to event */\n\t\tcurrent_val = iwe_stream_add_value(info, current_ev,\n\t\t\t\t\t\t   current_val, end_buf,\n\t\t\t\t\t\t   &iwe, IW_EV_PARAM_LEN);\n\t}\n\t/* Check if we added any event */\n\tif ((current_val - current_ev) > iwe_stream_lcp_len(info))\n\t\tcurrent_ev = current_val;\n\n\t/* Beacon interval */\n\tbuf = kmalloc(30, GFP_KERNEL);\n\tif (buf) {\n\t\tiwe.cmd = IWEVCUSTOM;\n\t\tsprintf(buf, \"bcn_int=%d\", bss->beaconInterval);\n\t\tiwe.u.data.length = strlen(buf);\n\t\tcurrent_ev = iwe_stream_add_point(info, current_ev, end_buf,\n\t\t\t\t\t\t  &iwe, buf);\n\t\tkfree(buf);\n\t}\n\n\t/* Put WPA/RSN Information Elements into the event stream */\n\tif (test_bit(FLAG_WPA_CAPABLE, &ai->flags)) {\n\t\tunsigned int num_null_ies = 0;\n\t\tu16 length = sizeof (bss->extra.iep);\n\t\tu8 *ie = (void *)&bss->extra.iep;\n\n\t\twhile ((length >= 2) && (num_null_ies < 2)) {\n\t\t\tif (2 + ie[1] > length) {\n\t\t\t\t/* Invalid element, don't continue parsing IE */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (ie[0]) {\n\t\t\tcase WLAN_EID_SSID:\n\t\t\t\t/* Two zero-length SSID elements\n\t\t\t\t * mean we're done parsing elements */\n\t\t\t\tif (!ie[1])\n\t\t\t\t\tnum_null_ies++;\n\t\t\t\tbreak;\n\n\t\t\tcase WLAN_EID_GENERIC:\n\t\t\t\tif (ie[1] >= 4 &&\n\t\t\t\t    ie[2] == 0x00 &&\n\t\t\t\t    ie[3] == 0x50 &&\n\t\t\t\t    ie[4] == 0xf2 &&\n\t\t\t\t    ie[5] == 0x01) {\n\t\t\t\t\tiwe.cmd = IWEVGENIE;\n\t\t\t\t\t/* 64 is an arbitrary cut-off */\n\t\t\t\t\tiwe.u.data.length = min(ie[1] + 2,\n\t\t\t\t\t\t\t\t64);\n\t\t\t\t\tcurrent_ev = iwe_stream_add_point(\n\t\t\t\t\t\t\tinfo, current_ev,\n\t\t\t\t\t\t\tend_buf, &iwe, ie);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase WLAN_EID_RSN:\n\t\t\t\tiwe.cmd = IWEVGENIE;\n\t\t\t\t/* 64 is an arbitrary cut-off */\n\t\t\t\tiwe.u.data.length = min(ie[1] + 2, 64);\n\t\t\t\tcurrent_ev = iwe_stream_add_point(\n\t\t\t\t\tinfo, current_ev, end_buf,\n\t\t\t\t\t&iwe, ie);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlength -= 2 + ie[1];\n\t\t\tie += 2 + ie[1];\n\t\t}\n\t}\n\treturn current_ev;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : Read Scan Results\n */\nstatic int airo_get_scan(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t struct iw_point *dwrq,\n\t\t\t char *extra)\n{\n\tstruct airo_info *ai = dev->ml_priv;\n\tBSSListElement *net;\n\tint err = 0;\n\tchar *current_ev = extra;\n\n\t/* If a scan is in-progress, return -EAGAIN */\n\tif (ai->scan_timeout > 0)\n\t\treturn -EAGAIN;\n\n\tif (down_interruptible(&ai->sem))\n\t\treturn -EAGAIN;\n\n\tlist_for_each_entry (net, &ai->network_list, list) {\n\t\t/* Translate to WE format this entry */\n\t\tcurrent_ev = airo_translate_scan(dev, info, current_ev,\n\t\t\t\t\t\t extra + dwrq->length,\n\t\t\t\t\t\t &net->bss);\n\n\t\t/* Check if there is space for one more entry */\n\t\tif((extra + dwrq->length - current_ev) <= IW_EV_ADDR_LEN) {\n\t\t\t/* Ask user space to try again with a bigger buffer */\n\t\t\terr = -E2BIG;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Length of data */\n\tdwrq->length = (current_ev - extra);\n\tdwrq->flags = 0;\t/* todo */\n\nout:\n\tup(&ai->sem);\n\treturn err;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Commit handler : called after a bunch of SET operations\n */\nstatic int airo_config_commit(struct net_device *dev,\n\t\t\t      struct iw_request_info *info,\t/* NULL */\n\t\t\t      void *zwrq,\t\t\t/* NULL */\n\t\t\t      char *extra)\t\t\t/* NULL */\n{\n\tstruct airo_info *local = dev->ml_priv;\n\n\tif (!test_bit (FLAG_COMMIT, &local->flags))\n\t\treturn 0;\n\n\t/* Some of the \"SET\" function may have modified some of the\n\t * parameters. It's now time to commit them in the card */\n\tdisable_MAC(local, 1);\n\tif (test_bit (FLAG_RESET, &local->flags)) {\n\t\tAPListRid APList_rid;\n\t\tSsidRid SSID_rid;\n\n\t\treadAPListRid(local, &APList_rid);\n\t\treadSsidRid(local, &SSID_rid);\n\t\tif (test_bit(FLAG_MPI,&local->flags))\n\t\t\tsetup_card(local, dev->dev_addr, 1 );\n\t\telse\n\t\t\treset_airo_card(dev);\n\t\tdisable_MAC(local, 1);\n\t\twriteSsidRid(local, &SSID_rid, 1);\n\t\twriteAPListRid(local, &APList_rid, 1);\n\t}\n\tif (down_interruptible(&local->sem))\n\t\treturn -ERESTARTSYS;\n\twriteConfigRid(local, 0);\n\tenable_MAC(local, 0);\n\tif (test_bit (FLAG_RESET, &local->flags))\n\t\tairo_set_promisc(local);\n\telse\n\t\tup(&local->sem);\n\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Structures to export the Wireless Handlers\n */\n\nstatic const struct iw_priv_args airo_private_args[] = {\n/*{ cmd,         set_args,                            get_args, name } */\n  { AIROIOCTL, IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | sizeof (aironet_ioctl),\n    IW_PRIV_TYPE_BYTE | 2047, \"airoioctl\" },\n  { AIROIDIFC, IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | sizeof (aironet_ioctl),\n    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"airoidifc\" },\n};\n\nstatic const iw_handler\t\tairo_handler[] =\n{\n\t(iw_handler) airo_config_commit,\t/* SIOCSIWCOMMIT */\n\t(iw_handler) airo_get_name,\t\t/* SIOCGIWNAME */\n\t(iw_handler) NULL,\t\t\t/* SIOCSIWNWID */\n\t(iw_handler) NULL,\t\t\t/* SIOCGIWNWID */\n\t(iw_handler) airo_set_freq,\t\t/* SIOCSIWFREQ */\n\t(iw_handler) airo_get_freq,\t\t/* SIOCGIWFREQ */\n\t(iw_handler) airo_set_mode,\t\t/* SIOCSIWMODE */\n\t(iw_handler) airo_get_mode,\t\t/* SIOCGIWMODE */\n\t(iw_handler) airo_set_sens,\t\t/* SIOCSIWSENS */\n\t(iw_handler) airo_get_sens,\t\t/* SIOCGIWSENS */\n\t(iw_handler) NULL,\t\t\t/* SIOCSIWRANGE */\n\t(iw_handler) airo_get_range,\t\t/* SIOCGIWRANGE */\n\t(iw_handler) NULL,\t\t\t/* SIOCSIWPRIV */\n\t(iw_handler) NULL,\t\t\t/* SIOCGIWPRIV */\n\t(iw_handler) NULL,\t\t\t/* SIOCSIWSTATS */\n\t(iw_handler) NULL,\t\t\t/* SIOCGIWSTATS */\n\tiw_handler_set_spy,\t\t\t/* SIOCSIWSPY */\n\tiw_handler_get_spy,\t\t\t/* SIOCGIWSPY */\n\tiw_handler_set_thrspy,\t\t\t/* SIOCSIWTHRSPY */\n\tiw_handler_get_thrspy,\t\t\t/* SIOCGIWTHRSPY */\n\t(iw_handler) airo_set_wap,\t\t/* SIOCSIWAP */\n\t(iw_handler) airo_get_wap,\t\t/* SIOCGIWAP */\n\t(iw_handler) NULL,\t\t\t/* -- hole -- */\n\t(iw_handler) airo_get_aplist,\t\t/* SIOCGIWAPLIST */\n\t(iw_handler) airo_set_scan,\t\t/* SIOCSIWSCAN */\n\t(iw_handler) airo_get_scan,\t\t/* SIOCGIWSCAN */\n\t(iw_handler) airo_set_essid,\t\t/* SIOCSIWESSID */\n\t(iw_handler) airo_get_essid,\t\t/* SIOCGIWESSID */\n\t(iw_handler) airo_set_nick,\t\t/* SIOCSIWNICKN */\n\t(iw_handler) airo_get_nick,\t\t/* SIOCGIWNICKN */\n\t(iw_handler) NULL,\t\t\t/* -- hole -- */\n\t(iw_handler) NULL,\t\t\t/* -- hole -- */\n\t(iw_handler) airo_set_rate,\t\t/* SIOCSIWRATE */\n\t(iw_handler) airo_get_rate,\t\t/* SIOCGIWRATE */\n\t(iw_handler) airo_set_rts,\t\t/* SIOCSIWRTS */\n\t(iw_handler) airo_get_rts,\t\t/* SIOCGIWRTS */\n\t(iw_handler) airo_set_frag,\t\t/* SIOCSIWFRAG */\n\t(iw_handler) airo_get_frag,\t\t/* SIOCGIWFRAG */\n\t(iw_handler) airo_set_txpow,\t\t/* SIOCSIWTXPOW */\n\t(iw_handler) airo_get_txpow,\t\t/* SIOCGIWTXPOW */\n\t(iw_handler) airo_set_retry,\t\t/* SIOCSIWRETRY */\n\t(iw_handler) airo_get_retry,\t\t/* SIOCGIWRETRY */\n\t(iw_handler) airo_set_encode,\t\t/* SIOCSIWENCODE */\n\t(iw_handler) airo_get_encode,\t\t/* SIOCGIWENCODE */\n\t(iw_handler) airo_set_power,\t\t/* SIOCSIWPOWER */\n\t(iw_handler) airo_get_power,\t\t/* SIOCGIWPOWER */\n\t(iw_handler) NULL,\t\t\t/* -- hole -- */\n\t(iw_handler) NULL,\t\t\t/* -- hole -- */\n\t(iw_handler) NULL,\t\t\t/* SIOCSIWGENIE */\n\t(iw_handler) NULL,\t\t\t/* SIOCGIWGENIE */\n\t(iw_handler) airo_set_auth,\t\t/* SIOCSIWAUTH */\n\t(iw_handler) airo_get_auth,\t\t/* SIOCGIWAUTH */\n\t(iw_handler) airo_set_encodeext,\t/* SIOCSIWENCODEEXT */\n\t(iw_handler) airo_get_encodeext,\t/* SIOCGIWENCODEEXT */\n\t(iw_handler) NULL,\t\t\t/* SIOCSIWPMKSA */\n};\n\n/* Note : don't describe AIROIDIFC and AIROOLDIDIFC in here.\n * We want to force the use of the ioctl code, because those can't be\n * won't work the iw_handler code (because they simultaneously read\n * and write data and iw_handler can't do that).\n * Note that it's perfectly legal to read/write on a single ioctl command,\n * you just can't use iwpriv and need to force it via the ioctl handler.\n * Jean II */\nstatic const iw_handler\t\tairo_private_handler[] =\n{\n\tNULL,\t\t\t\t/* SIOCIWFIRSTPRIV */\n};\n\nstatic const struct iw_handler_def\tairo_handler_def =\n{\n\t.num_standard\t= ARRAY_SIZE(airo_handler),\n\t.num_private\t= ARRAY_SIZE(airo_private_handler),\n\t.num_private_args = ARRAY_SIZE(airo_private_args),\n\t.standard\t= airo_handler,\n\t.private\t= airo_private_handler,\n\t.private_args\t= airo_private_args,\n\t.get_wireless_stats = airo_get_wireless_stats,\n};\n\n/*\n * This defines the configuration part of the Wireless Extensions\n * Note : irq and spinlock protection will occur in the subroutines\n *\n * TODO :\n *\to Check input value more carefully and fill correct values in range\n *\to Test and shakeout the bugs (if any)\n *\n * Jean II\n *\n * Javier Achirica did a great job of merging code from the unnamed CISCO\n * developer that added support for flashing the card.\n */\nstatic int airo_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tint rc = 0;\n\tstruct airo_info *ai = dev->ml_priv;\n\n\tif (ai->power.event)\n\t\treturn 0;\n\n\tswitch (cmd) {\n#ifdef CISCO_EXT\n\tcase AIROIDIFC:\n#ifdef AIROOLDIDIFC\n\tcase AIROOLDIDIFC:\n#endif\n\t{\n\t\tint val = AIROMAGIC;\n\t\taironet_ioctl com;\n\t\tif (copy_from_user(&com,rq->ifr_data,sizeof(com)))\n\t\t\trc = -EFAULT;\n\t\telse if (copy_to_user(com.data,(char *)&val,sizeof(val)))\n\t\t\trc = -EFAULT;\n\t}\n\tbreak;\n\n\tcase AIROIOCTL:\n#ifdef AIROOLDIOCTL\n\tcase AIROOLDIOCTL:\n#endif\n\t\t/* Get the command struct and hand it off for evaluation by\n\t\t * the proper subfunction\n\t\t */\n\t{\n\t\taironet_ioctl com;\n\t\tif (copy_from_user(&com,rq->ifr_data,sizeof(com))) {\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Separate R/W functions bracket legality here\n\t\t */\n\t\tif ( com.command == AIRORSWVERSION ) {\n\t\t\tif (copy_to_user(com.data, swversion, sizeof(swversion)))\n\t\t\t\trc = -EFAULT;\n\t\t\telse\n\t\t\t\trc = 0;\n\t\t}\n\t\telse if ( com.command <= AIRORRID)\n\t\t\trc = readrids(dev,&com);\n\t\telse if ( com.command >= AIROPCAP && com.command <= (AIROPLEAPUSR+2) )\n\t\t\trc = writerids(dev,&com);\n\t\telse if ( com.command >= AIROFLSHRST && com.command <= AIRORESTART )\n\t\t\trc = flashcard(dev,&com);\n\t\telse\n\t\t\trc = -EINVAL;      /* Bad command in ioctl */\n\t}\n\tbreak;\n#endif /* CISCO_EXT */\n\n\t// All other calls are currently unsupported\n\tdefault:\n\t\trc = -EOPNOTSUPP;\n\t}\n\treturn rc;\n}\n\n/*\n * Get the Wireless stats out of the driver\n * Note : irq and spinlock protection will occur in the subroutines\n *\n * TODO :\n *\to Check if work in Ad-Hoc mode (otherwise, use SPY, as in wvlan_cs)\n *\n * Jean\n */\nstatic void airo_read_wireless_stats(struct airo_info *local)\n{\n\tStatusRid status_rid;\n\tStatsRid stats_rid;\n\tCapabilityRid cap_rid;\n\t__le32 *vals = stats_rid.vals;\n\n\t/* Get stats out of the card */\n\tclear_bit(JOB_WSTATS, &local->jobs);\n\tif (local->power.event) {\n\t\tup(&local->sem);\n\t\treturn;\n\t}\n\treadCapabilityRid(local, &cap_rid, 0);\n\treadStatusRid(local, &status_rid, 0);\n\treadStatsRid(local, &stats_rid, RID_STATS, 0);\n\tup(&local->sem);\n\n\t/* The status */\n\tlocal->wstats.status = le16_to_cpu(status_rid.mode);\n\n\t/* Signal quality and co */\n\tif (local->rssi) {\n\t\tlocal->wstats.qual.level =\n\t\t\tairo_rssi_to_dbm(local->rssi,\n\t\t\t\t\t le16_to_cpu(status_rid.sigQuality));\n\t\t/* normalizedSignalStrength appears to be a percentage */\n\t\tlocal->wstats.qual.qual =\n\t\t\tle16_to_cpu(status_rid.normalizedSignalStrength);\n\t} else {\n\t\tlocal->wstats.qual.level =\n\t\t\t(le16_to_cpu(status_rid.normalizedSignalStrength) + 321) / 2;\n\t\tlocal->wstats.qual.qual = airo_get_quality(&status_rid, &cap_rid);\n\t}\n\tif (le16_to_cpu(status_rid.len) >= 124) {\n\t\tlocal->wstats.qual.noise = 0x100 - status_rid.noisedBm;\n\t\tlocal->wstats.qual.updated = IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;\n\t} else {\n\t\tlocal->wstats.qual.noise = 0;\n\t\tlocal->wstats.qual.updated = IW_QUAL_QUAL_UPDATED | IW_QUAL_LEVEL_UPDATED | IW_QUAL_NOISE_INVALID | IW_QUAL_DBM;\n\t}\n\n\t/* Packets discarded in the wireless adapter due to wireless\n\t * specific problems */\n\tlocal->wstats.discard.nwid = le32_to_cpu(vals[56]) +\n\t\t\t\t     le32_to_cpu(vals[57]) +\n\t\t\t\t     le32_to_cpu(vals[58]); /* SSID Mismatch */\n\tlocal->wstats.discard.code = le32_to_cpu(vals[6]);/* RxWepErr */\n\tlocal->wstats.discard.fragment = le32_to_cpu(vals[30]);\n\tlocal->wstats.discard.retries = le32_to_cpu(vals[10]);\n\tlocal->wstats.discard.misc = le32_to_cpu(vals[1]) +\n\t\t\t\t     le32_to_cpu(vals[32]);\n\tlocal->wstats.miss.beacon = le32_to_cpu(vals[34]);\n}\n\nstatic struct iw_statistics *airo_get_wireless_stats(struct net_device *dev)\n{\n\tstruct airo_info *local =  dev->ml_priv;\n\n\tif (!test_bit(JOB_WSTATS, &local->jobs)) {\n\t\t/* Get stats out of the card if available */\n\t\tif (down_trylock(&local->sem) != 0) {\n\t\t\tset_bit(JOB_WSTATS, &local->jobs);\n\t\t\twake_up_interruptible(&local->thr_wait);\n\t\t} else\n\t\t\tairo_read_wireless_stats(local);\n\t}\n\n\treturn &local->wstats;\n}\n\n#ifdef CISCO_EXT\n/*\n * This just translates from driver IOCTL codes to the command codes to\n * feed to the radio's host interface. Things can be added/deleted\n * as needed.  This represents the READ side of control I/O to\n * the card\n */\nstatic int readrids(struct net_device *dev, aironet_ioctl *comp) {\n\tunsigned short ridcode;\n\tunsigned char *iobuf;\n\tint len;\n\tstruct airo_info *ai = dev->ml_priv;\n\n\tif (test_bit(FLAG_FLASHING, &ai->flags))\n\t\treturn -EIO;\n\n\tswitch(comp->command)\n\t{\n\tcase AIROGCAP:      ridcode = RID_CAPABILITIES; break;\n\tcase AIROGCFG:      ridcode = RID_CONFIG;\n\t\tif (test_bit(FLAG_COMMIT, &ai->flags)) {\n\t\t\tdisable_MAC (ai, 1);\n\t\t\twriteConfigRid (ai, 1);\n\t\t\tenable_MAC(ai, 1);\n\t\t}\n\t\tbreak;\n\tcase AIROGSLIST:    ridcode = RID_SSID;         break;\n\tcase AIROGVLIST:    ridcode = RID_APLIST;       break;\n\tcase AIROGDRVNAM:   ridcode = RID_DRVNAME;      break;\n\tcase AIROGEHTENC:   ridcode = RID_ETHERENCAP;   break;\n\tcase AIROGWEPKTMP:  ridcode = RID_WEP_TEMP;\n\t\t/* Only super-user can read WEP keys */\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tbreak;\n\tcase AIROGWEPKNV:   ridcode = RID_WEP_PERM;\n\t\t/* Only super-user can read WEP keys */\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tbreak;\n\tcase AIROGSTAT:     ridcode = RID_STATUS;       break;\n\tcase AIROGSTATSD32: ridcode = RID_STATSDELTA;   break;\n\tcase AIROGSTATSC32: ridcode = RID_STATS;        break;\n\tcase AIROGMICSTATS:\n\t\tif (copy_to_user(comp->data, &ai->micstats,\n\t\t\t\t min((int)comp->len,(int)sizeof(ai->micstats))))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase AIRORRID:      ridcode = comp->ridnum;     break;\n\tdefault:\n\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\tif ((iobuf = kmalloc(RIDSIZE, GFP_KERNEL)) == NULL)\n\t\treturn -ENOMEM;\n\n\tPC4500_readrid(ai,ridcode,iobuf,RIDSIZE, 1);\n\t/* get the count of bytes in the rid  docs say 1st 2 bytes is it.\n\t * then return it to the user\n\t * 9/22/2000 Honor user given length\n\t */\n\tlen = comp->len;\n\n\tif (copy_to_user(comp->data, iobuf, min(len, (int)RIDSIZE))) {\n\t\tkfree (iobuf);\n\t\treturn -EFAULT;\n\t}\n\tkfree (iobuf);\n\treturn 0;\n}\n\n/*\n * Danger Will Robinson write the rids here\n */\n\nstatic int writerids(struct net_device *dev, aironet_ioctl *comp) {\n\tstruct airo_info *ai = dev->ml_priv;\n\tint  ridcode;\n        int  enabled;\n\tstatic int (* writer)(struct airo_info *, u16 rid, const void *, int, int);\n\tunsigned char *iobuf;\n\n\t/* Only super-user can write RIDs */\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (test_bit(FLAG_FLASHING, &ai->flags))\n\t\treturn -EIO;\n\n\tridcode = 0;\n\twriter = do_writerid;\n\n\tswitch(comp->command)\n\t{\n\tcase AIROPSIDS:     ridcode = RID_SSID;         break;\n\tcase AIROPCAP:      ridcode = RID_CAPABILITIES; break;\n\tcase AIROPAPLIST:   ridcode = RID_APLIST;       break;\n\tcase AIROPCFG: ai->config.len = 0;\n\t\t\t    clear_bit(FLAG_COMMIT, &ai->flags);\n\t\t\t    ridcode = RID_CONFIG;       break;\n\tcase AIROPWEPKEYNV: ridcode = RID_WEP_PERM;     break;\n\tcase AIROPLEAPUSR:  ridcode = RID_LEAPUSERNAME; break;\n\tcase AIROPLEAPPWD:  ridcode = RID_LEAPPASSWORD; break;\n\tcase AIROPWEPKEY:   ridcode = RID_WEP_TEMP; writer = PC4500_writerid;\n\t\tbreak;\n\tcase AIROPLEAPUSR+1: ridcode = 0xFF2A;          break;\n\tcase AIROPLEAPUSR+2: ridcode = 0xFF2B;          break;\n\n\t\t/* this is not really a rid but a command given to the card\n\t\t * same with MAC off\n\t\t */\n\tcase AIROPMACON:\n\t\tif (enable_MAC(ai, 1) != 0)\n\t\t\treturn -EIO;\n\t\treturn 0;\n\n\t\t/*\n\t\t * Evidently this code in the airo driver does not get a symbol\n\t\t * as disable_MAC. it's probably so short the compiler does not gen one.\n\t\t */\n\tcase AIROPMACOFF:\n\t\tdisable_MAC(ai, 1);\n\t\treturn 0;\n\n\t\t/* This command merely clears the counts does not actually store any data\n\t\t * only reads rid. But as it changes the cards state, I put it in the\n\t\t * writerid routines.\n\t\t */\n\tcase AIROPSTCLR:\n\t\tif ((iobuf = kmalloc(RIDSIZE, GFP_KERNEL)) == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tPC4500_readrid(ai,RID_STATSDELTACLEAR,iobuf,RIDSIZE, 1);\n\n\t\tenabled = ai->micstats.enabled;\n\t\tmemset(&ai->micstats,0,sizeof(ai->micstats));\n\t\tai->micstats.enabled = enabled;\n\n\t\tif (copy_to_user(comp->data, iobuf,\n\t\t\t\t min((int)comp->len, (int)RIDSIZE))) {\n\t\t\tkfree (iobuf);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tkfree (iobuf);\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\t/* Blarg! */\n\t}\n\tif(comp->len > RIDSIZE)\n\t\treturn -EINVAL;\n\n\tif ((iobuf = kmalloc(RIDSIZE, GFP_KERNEL)) == NULL)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(iobuf,comp->data,comp->len)) {\n\t\tkfree (iobuf);\n\t\treturn -EFAULT;\n\t}\n\n\tif (comp->command == AIROPCFG) {\n\t\tConfigRid *cfg = (ConfigRid *)iobuf;\n\n\t\tif (test_bit(FLAG_MIC_CAPABLE, &ai->flags))\n\t\t\tcfg->opmode |= MODE_MIC;\n\n\t\tif ((cfg->opmode & MODE_CFG_MASK) == MODE_STA_IBSS)\n\t\t\tset_bit (FLAG_ADHOC, &ai->flags);\n\t\telse\n\t\t\tclear_bit (FLAG_ADHOC, &ai->flags);\n\t}\n\n\tif((*writer)(ai, ridcode, iobuf,comp->len,1)) {\n\t\tkfree (iobuf);\n\t\treturn -EIO;\n\t}\n\tkfree (iobuf);\n\treturn 0;\n}\n\n/*****************************************************************************\n * Ancillary flash / mod functions much black magic lurkes here              *\n *****************************************************************************\n */\n\n/*\n * Flash command switch table\n */\n\nstatic int flashcard(struct net_device *dev, aironet_ioctl *comp) {\n\tint z;\n\n\t/* Only super-user can modify flash */\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch(comp->command)\n\t{\n\tcase AIROFLSHRST:\n\t\treturn cmdreset((struct airo_info *)dev->ml_priv);\n\n\tcase AIROFLSHSTFL:\n\t\tif (!AIRO_FLASH(dev) &&\n\t\t    (AIRO_FLASH(dev) = kmalloc(FLASHSIZE, GFP_KERNEL)) == NULL)\n\t\t\treturn -ENOMEM;\n\t\treturn setflashmode((struct airo_info *)dev->ml_priv);\n\n\tcase AIROFLSHGCHR: /* Get char from aux */\n\t\tif(comp->len != sizeof(int))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&z,comp->data,comp->len))\n\t\t\treturn -EFAULT;\n\t\treturn flashgchar((struct airo_info *)dev->ml_priv, z, 8000);\n\n\tcase AIROFLSHPCHR: /* Send char to card. */\n\t\tif(comp->len != sizeof(int))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&z,comp->data,comp->len))\n\t\t\treturn -EFAULT;\n\t\treturn flashpchar((struct airo_info *)dev->ml_priv, z, 8000);\n\n\tcase AIROFLPUTBUF: /* Send 32k to card */\n\t\tif (!AIRO_FLASH(dev))\n\t\t\treturn -ENOMEM;\n\t\tif(comp->len > FLASHSIZE)\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(AIRO_FLASH(dev), comp->data, comp->len))\n\t\t\treturn -EFAULT;\n\n\t\tflashputbuf((struct airo_info *)dev->ml_priv);\n\t\treturn 0;\n\n\tcase AIRORESTART:\n\t\tif (flashrestart((struct airo_info *)dev->ml_priv, dev))\n\t\t\treturn -EIO;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\n#define FLASH_COMMAND  0x7e7e\n\n/*\n * STEP 1)\n * Disable MAC and do soft reset on\n * card.\n */\n\nstatic int cmdreset(struct airo_info *ai) {\n\tdisable_MAC(ai, 1);\n\n\tif(!waitbusy (ai)){\n\t\tairo_print_info(ai->dev->name, \"Waitbusy hang before RESET\");\n\t\treturn -EBUSY;\n\t}\n\n\tOUT4500(ai,COMMAND,CMD_SOFTRESET);\n\n\tssleep(1);\t\t\t/* WAS 600 12/7/00 */\n\n\tif(!waitbusy (ai)){\n\t\tairo_print_info(ai->dev->name, \"Waitbusy hang AFTER RESET\");\n\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}\n\n/* STEP 2)\n * Put the card in legendary flash\n * mode\n */\n\nstatic int setflashmode (struct airo_info *ai) {\n\tset_bit (FLAG_FLASHING, &ai->flags);\n\n\tOUT4500(ai, SWS0, FLASH_COMMAND);\n\tOUT4500(ai, SWS1, FLASH_COMMAND);\n\tif (probe) {\n\t\tOUT4500(ai, SWS0, FLASH_COMMAND);\n\t\tOUT4500(ai, COMMAND,0x10);\n\t} else {\n\t\tOUT4500(ai, SWS2, FLASH_COMMAND);\n\t\tOUT4500(ai, SWS3, FLASH_COMMAND);\n\t\tOUT4500(ai, COMMAND,0);\n\t}\n\tmsleep(500);\t\t/* 500ms delay */\n\n\tif(!waitbusy(ai)) {\n\t\tclear_bit (FLAG_FLASHING, &ai->flags);\n\t\tairo_print_info(ai->dev->name, \"Waitbusy hang after setflash mode\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n/* Put character to SWS0 wait for dwelltime\n * x 50us for  echo .\n */\n\nstatic int flashpchar(struct airo_info *ai,int byte,int dwelltime) {\n\tint echo;\n\tint waittime;\n\n\tbyte |= 0x8000;\n\n\tif(dwelltime == 0 )\n\t\tdwelltime = 200;\n\n\twaittime=dwelltime;\n\n\t/* Wait for busy bit d15 to go false indicating buffer empty */\n\twhile ((IN4500 (ai, SWS0) & 0x8000) && waittime > 0) {\n\t\tudelay (50);\n\t\twaittime -= 50;\n\t}\n\n\t/* timeout for busy clear wait */\n\tif(waittime <= 0 ){\n\t\tairo_print_info(ai->dev->name, \"flash putchar busywait timeout!\");\n\t\treturn -EBUSY;\n\t}\n\n\t/* Port is clear now write byte and wait for it to echo back */\n\tdo {\n\t\tOUT4500(ai,SWS0,byte);\n\t\tudelay(50);\n\t\tdwelltime -= 50;\n\t\techo = IN4500(ai,SWS1);\n\t} while (dwelltime >= 0 && echo != byte);\n\n\tOUT4500(ai,SWS1,0);\n\n\treturn (echo == byte) ? 0 : -EIO;\n}\n\n/*\n * Get a character from the card matching matchbyte\n * Step 3)\n */\nstatic int flashgchar(struct airo_info *ai,int matchbyte,int dwelltime){\n\tint           rchar;\n\tunsigned char rbyte=0;\n\n\tdo {\n\t\trchar = IN4500(ai,SWS1);\n\n\t\tif(dwelltime && !(0x8000 & rchar)){\n\t\t\tdwelltime -= 10;\n\t\t\tmdelay(10);\n\t\t\tcontinue;\n\t\t}\n\t\trbyte = 0xff & rchar;\n\n\t\tif( (rbyte == matchbyte) && (0x8000 & rchar) ){\n\t\t\tOUT4500(ai,SWS1,0);\n\t\t\treturn 0;\n\t\t}\n\t\tif( rbyte == 0x81 || rbyte == 0x82 || rbyte == 0x83 || rbyte == 0x1a || 0xffff == rchar)\n\t\t\tbreak;\n\t\tOUT4500(ai,SWS1,0);\n\n\t}while(dwelltime > 0);\n\treturn -EIO;\n}\n\n/*\n * Transfer 32k of firmware data from user buffer to our buffer and\n * send to the card\n */\n\nstatic int flashputbuf(struct airo_info *ai){\n\tint            nwords;\n\n\t/* Write stuff */\n\tif (test_bit(FLAG_MPI,&ai->flags))\n\t\tmemcpy_toio(ai->pciaux + 0x8000, ai->flash, FLASHSIZE);\n\telse {\n\t\tOUT4500(ai,AUXPAGE,0x100);\n\t\tOUT4500(ai,AUXOFF,0);\n\n\t\tfor(nwords=0;nwords != FLASHSIZE / 2;nwords++){\n\t\t\tOUT4500(ai,AUXDATA,ai->flash[nwords] & 0xffff);\n\t\t}\n\t}\n\tOUT4500(ai,SWS0,0x8000);\n\n\treturn 0;\n}\n\n/*\n *\n */\nstatic int flashrestart(struct airo_info *ai,struct net_device *dev){\n\tint    i,status;\n\n\tssleep(1);\t\t\t/* Added 12/7/00 */\n\tclear_bit (FLAG_FLASHING, &ai->flags);\n\tif (test_bit(FLAG_MPI, &ai->flags)) {\n\t\tstatus = mpi_init_descriptors(ai);\n\t\tif (status != SUCCESS)\n\t\t\treturn status;\n\t}\n\tstatus = setup_card(ai, dev->dev_addr, 1);\n\n\tif (!test_bit(FLAG_MPI,&ai->flags))\n\t\tfor( i = 0; i < MAX_FIDS; i++ ) {\n\t\t\tai->fids[i] = transmit_allocate\n\t\t\t\t( ai, AIRO_DEF_MTU, i >= MAX_FIDS / 2 );\n\t\t}\n\n\tssleep(1);\t\t\t/* Added 12/7/00 */\n\treturn status;\n}\n#endif /* CISCO_EXT */\n\n/*\n    This program is free software; you can redistribute it and/or\n    modify it under the terms of the GNU General Public License\n    as published by the Free Software Foundation; either version 2\n    of the License, or (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    In addition:\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n    1. Redistributions of source code must retain the above copyright\n       notice, this list of conditions and the following disclaimer.\n    2. Redistributions in binary form must reproduce the above copyright\n       notice, this list of conditions and the following disclaimer in the\n       documentation and/or other materials provided with the distribution.\n    3. The name of the author may not be used to endorse or promote\n       products derived from this software without specific prior written\n       permission.\n\n    THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n    ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n    POSSIBILITY OF SUCH DAMAGE.\n*/\n\nmodule_init(airo_init_module);\nmodule_exit(airo_cleanup_module);\n", "/*\n * Host AP (software wireless LAN access point) driver for\n * Intersil Prism2/2.5/3 - hostap.o module, common routines\n *\n * Copyright (c) 2001-2002, SSH Communications Security Corp and Jouni Malinen\n * <j@w1.fi>\n * Copyright (c) 2002-2005, Jouni Malinen <j@w1.fi>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation. See README and COPYING for\n * more details.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/proc_fs.h>\n#include <linux/if_arp.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/kmod.h>\n#include <linux/rtnetlink.h>\n#include <linux/wireless.h>\n#include <linux/etherdevice.h>\n#include <net/net_namespace.h>\n#include <net/iw_handler.h>\n#include <net/lib80211.h>\n#include <asm/uaccess.h>\n\n#include \"hostap_wlan.h\"\n#include \"hostap_80211.h\"\n#include \"hostap_ap.h\"\n#include \"hostap.h\"\n\nMODULE_AUTHOR(\"Jouni Malinen\");\nMODULE_DESCRIPTION(\"Host AP common routines\");\nMODULE_LICENSE(\"GPL\");\n\n#define TX_TIMEOUT (2 * HZ)\n\n#define PRISM2_MAX_FRAME_SIZE 2304\n#define PRISM2_MIN_MTU 256\n/* FIX: */\n#define PRISM2_MAX_MTU (PRISM2_MAX_FRAME_SIZE - (6 /* LLC */ + 8 /* WEP */))\n\n\nstruct net_device * hostap_add_interface(struct local_info *local,\n\t\t\t\t\t int type, int rtnl_locked,\n\t\t\t\t\t const char *prefix,\n\t\t\t\t\t const char *name)\n{\n\tstruct net_device *dev, *mdev;\n\tstruct hostap_interface *iface;\n\tint ret;\n\n\tdev = alloc_etherdev(sizeof(struct hostap_interface));\n\tif (dev == NULL)\n\t\treturn NULL;\n\n\tiface = netdev_priv(dev);\n\tiface->dev = dev;\n\tiface->local = local;\n\tiface->type = type;\n\tlist_add(&iface->list, &local->hostap_interfaces);\n\n\tmdev = local->dev;\n\tmemcpy(dev->dev_addr, mdev->dev_addr, ETH_ALEN);\n\tdev->base_addr = mdev->base_addr;\n\tdev->irq = mdev->irq;\n\tdev->mem_start = mdev->mem_start;\n\tdev->mem_end = mdev->mem_end;\n\n\thostap_setup_dev(dev, local, type);\n\tdev->destructor = free_netdev;\n\n\tsprintf(dev->name, \"%s%s\", prefix, name);\n\tif (!rtnl_locked)\n\t\trtnl_lock();\n\n\tSET_NETDEV_DEV(dev, mdev->dev.parent);\n\tret = register_netdevice(dev);\n\n\tif (!rtnl_locked)\n\t\trtnl_unlock();\n\n\tif (ret < 0) {\n\t\tprintk(KERN_WARNING \"%s: failed to add new netdevice!\\n\",\n\t\t       dev->name);\n\t\tfree_netdev(dev);\n\t\treturn NULL;\n\t}\n\n\tprintk(KERN_DEBUG \"%s: registered netdevice %s\\n\",\n\t       mdev->name, dev->name);\n\n\treturn dev;\n}\n\n\nvoid hostap_remove_interface(struct net_device *dev, int rtnl_locked,\n\t\t\t     int remove_from_list)\n{\n\tstruct hostap_interface *iface;\n\n\tif (!dev)\n\t\treturn;\n\n\tiface = netdev_priv(dev);\n\n\tif (remove_from_list) {\n\t\tlist_del(&iface->list);\n\t}\n\n\tif (dev == iface->local->ddev)\n\t\tiface->local->ddev = NULL;\n\telse if (dev == iface->local->apdev)\n\t\tiface->local->apdev = NULL;\n\telse if (dev == iface->local->stadev)\n\t\tiface->local->stadev = NULL;\n\n\tif (rtnl_locked)\n\t\tunregister_netdevice(dev);\n\telse\n\t\tunregister_netdev(dev);\n\n\t/* dev->destructor = free_netdev() will free the device data, including\n\t * private data, when removing the device */\n}\n\n\nstatic inline int prism2_wds_special_addr(u8 *addr)\n{\n\tif (addr[0] || addr[1] || addr[2] || addr[3] || addr[4] || addr[5])\n\t\treturn 0;\n\n\treturn 1;\n}\n\n\nint prism2_wds_add(local_info_t *local, u8 *remote_addr,\n\t\t   int rtnl_locked)\n{\n\tstruct net_device *dev;\n\tstruct list_head *ptr;\n\tstruct hostap_interface *iface, *empty, *match;\n\n\tempty = match = NULL;\n\tread_lock_bh(&local->iface_lock);\n\tlist_for_each(ptr, &local->hostap_interfaces) {\n\t\tiface = list_entry(ptr, struct hostap_interface, list);\n\t\tif (iface->type != HOSTAP_INTERFACE_WDS)\n\t\t\tcontinue;\n\n\t\tif (prism2_wds_special_addr(iface->u.wds.remote_addr))\n\t\t\tempty = iface;\n\t\telse if (memcmp(iface->u.wds.remote_addr, remote_addr,\n\t\t\t\tETH_ALEN) == 0) {\n\t\t\tmatch = iface;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!match && empty && !prism2_wds_special_addr(remote_addr)) {\n\t\t/* take pre-allocated entry into use */\n\t\tmemcpy(empty->u.wds.remote_addr, remote_addr, ETH_ALEN);\n\t\tread_unlock_bh(&local->iface_lock);\n\t\tprintk(KERN_DEBUG \"%s: using pre-allocated WDS netdevice %s\\n\",\n\t\t       local->dev->name, empty->dev->name);\n\t\treturn 0;\n\t}\n\tread_unlock_bh(&local->iface_lock);\n\n\tif (!prism2_wds_special_addr(remote_addr)) {\n\t\tif (match)\n\t\t\treturn -EEXIST;\n\t\thostap_add_sta(local->ap, remote_addr);\n\t}\n\n\tif (local->wds_connections >= local->wds_max_connections)\n\t\treturn -ENOBUFS;\n\n\t/* verify that there is room for wds# postfix in the interface name */\n\tif (strlen(local->dev->name) >= IFNAMSIZ - 5) {\n\t\tprintk(KERN_DEBUG \"'%s' too long base device name\\n\",\n\t\t       local->dev->name);\n\t\treturn -EINVAL;\n\t}\n\n\tdev = hostap_add_interface(local, HOSTAP_INTERFACE_WDS, rtnl_locked,\n\t\t\t\t   local->ddev->name, \"wds%d\");\n\tif (dev == NULL)\n\t\treturn -ENOMEM;\n\n\tiface = netdev_priv(dev);\n\tmemcpy(iface->u.wds.remote_addr, remote_addr, ETH_ALEN);\n\n\tlocal->wds_connections++;\n\n\treturn 0;\n}\n\n\nint prism2_wds_del(local_info_t *local, u8 *remote_addr,\n\t\t   int rtnl_locked, int do_not_remove)\n{\n\tunsigned long flags;\n\tstruct list_head *ptr;\n\tstruct hostap_interface *iface, *selected = NULL;\n\n\twrite_lock_irqsave(&local->iface_lock, flags);\n\tlist_for_each(ptr, &local->hostap_interfaces) {\n\t\tiface = list_entry(ptr, struct hostap_interface, list);\n\t\tif (iface->type != HOSTAP_INTERFACE_WDS)\n\t\t\tcontinue;\n\n\t\tif (memcmp(iface->u.wds.remote_addr, remote_addr,\n\t\t\t   ETH_ALEN) == 0) {\n\t\t\tselected = iface;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (selected && !do_not_remove)\n\t\tlist_del(&selected->list);\n\twrite_unlock_irqrestore(&local->iface_lock, flags);\n\n\tif (selected) {\n\t\tif (do_not_remove)\n\t\t\tmemset(selected->u.wds.remote_addr, 0, ETH_ALEN);\n\t\telse {\n\t\t\thostap_remove_interface(selected->dev, rtnl_locked, 0);\n\t\t\tlocal->wds_connections--;\n\t\t}\n\t}\n\n\treturn selected ? 0 : -ENODEV;\n}\n\n\nu16 hostap_tx_callback_register(local_info_t *local,\n\t\t\t\tvoid (*func)(struct sk_buff *, int ok, void *),\n\t\t\t\tvoid *data)\n{\n\tunsigned long flags;\n\tstruct hostap_tx_callback_info *entry;\n\n\tentry = kmalloc(sizeof(*entry),\n\t\t\t\t\t\t\t   GFP_ATOMIC);\n\tif (entry == NULL)\n\t\treturn 0;\n\n\tentry->func = func;\n\tentry->data = data;\n\n\tspin_lock_irqsave(&local->lock, flags);\n\tentry->idx = local->tx_callback ? local->tx_callback->idx + 1 : 1;\n\tentry->next = local->tx_callback;\n\tlocal->tx_callback = entry;\n\tspin_unlock_irqrestore(&local->lock, flags);\n\n\treturn entry->idx;\n}\n\n\nint hostap_tx_callback_unregister(local_info_t *local, u16 idx)\n{\n\tunsigned long flags;\n\tstruct hostap_tx_callback_info *cb, *prev = NULL;\n\n\tspin_lock_irqsave(&local->lock, flags);\n\tcb = local->tx_callback;\n\twhile (cb != NULL && cb->idx != idx) {\n\t\tprev = cb;\n\t\tcb = cb->next;\n\t}\n\tif (cb) {\n\t\tif (prev == NULL)\n\t\t\tlocal->tx_callback = cb->next;\n\t\telse\n\t\t\tprev->next = cb->next;\n\t\tkfree(cb);\n\t}\n\tspin_unlock_irqrestore(&local->lock, flags);\n\n\treturn cb ? 0 : -1;\n}\n\n\n/* val is in host byte order */\nint hostap_set_word(struct net_device *dev, int rid, u16 val)\n{\n\tstruct hostap_interface *iface;\n\t__le16 tmp = cpu_to_le16(val);\n\tiface = netdev_priv(dev);\n\treturn iface->local->func->set_rid(dev, rid, &tmp, 2);\n}\n\n\nint hostap_set_string(struct net_device *dev, int rid, const char *val)\n{\n\tstruct hostap_interface *iface;\n\tchar buf[MAX_SSID_LEN + 2];\n\tint len;\n\n\tiface = netdev_priv(dev);\n\tlen = strlen(val);\n\tif (len > MAX_SSID_LEN)\n\t\treturn -1;\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[0] = len; /* little endian 16 bit word */\n\tmemcpy(buf + 2, val, len);\n\n\treturn iface->local->func->set_rid(dev, rid, &buf, MAX_SSID_LEN + 2);\n}\n\n\nu16 hostap_get_porttype(local_info_t *local)\n{\n\tif (local->iw_mode == IW_MODE_ADHOC && local->pseudo_adhoc)\n\t\treturn HFA384X_PORTTYPE_PSEUDO_IBSS;\n\tif (local->iw_mode == IW_MODE_ADHOC)\n\t\treturn HFA384X_PORTTYPE_IBSS;\n\tif (local->iw_mode == IW_MODE_INFRA)\n\t\treturn HFA384X_PORTTYPE_BSS;\n\tif (local->iw_mode == IW_MODE_REPEAT)\n\t\treturn HFA384X_PORTTYPE_WDS;\n\tif (local->iw_mode == IW_MODE_MONITOR)\n\t\treturn HFA384X_PORTTYPE_PSEUDO_IBSS;\n\treturn HFA384X_PORTTYPE_HOSTAP;\n}\n\n\nint hostap_set_encryption(local_info_t *local)\n{\n\tu16 val, old_val;\n\tint i, keylen, len, idx;\n\tchar keybuf[WEP_KEY_LEN + 1];\n\tenum { NONE, WEP, OTHER } encrypt_type;\n\n\tidx = local->crypt_info.tx_keyidx;\n\tif (local->crypt_info.crypt[idx] == NULL ||\n\t    local->crypt_info.crypt[idx]->ops == NULL)\n\t\tencrypt_type = NONE;\n\telse if (strcmp(local->crypt_info.crypt[idx]->ops->name, \"WEP\") == 0)\n\t\tencrypt_type = WEP;\n\telse\n\t\tencrypt_type = OTHER;\n\n\tif (local->func->get_rid(local->dev, HFA384X_RID_CNFWEPFLAGS, &val, 2,\n\t\t\t\t 1) < 0) {\n\t\tprintk(KERN_DEBUG \"Could not read current WEP flags.\\n\");\n\t\tgoto fail;\n\t}\n\tle16_to_cpus(&val);\n\told_val = val;\n\n\tif (encrypt_type != NONE || local->privacy_invoked)\n\t\tval |= HFA384X_WEPFLAGS_PRIVACYINVOKED;\n\telse\n\t\tval &= ~HFA384X_WEPFLAGS_PRIVACYINVOKED;\n\n\tif (local->open_wep || encrypt_type == NONE ||\n\t    ((local->ieee_802_1x || local->wpa) && local->host_decrypt))\n\t\tval &= ~HFA384X_WEPFLAGS_EXCLUDEUNENCRYPTED;\n\telse\n\t\tval |= HFA384X_WEPFLAGS_EXCLUDEUNENCRYPTED;\n\n\tif ((encrypt_type != NONE || local->privacy_invoked) &&\n\t    (encrypt_type == OTHER || local->host_encrypt))\n\t\tval |= HFA384X_WEPFLAGS_HOSTENCRYPT;\n\telse\n\t\tval &= ~HFA384X_WEPFLAGS_HOSTENCRYPT;\n\tif ((encrypt_type != NONE || local->privacy_invoked) &&\n\t    (encrypt_type == OTHER || local->host_decrypt))\n\t\tval |= HFA384X_WEPFLAGS_HOSTDECRYPT;\n\telse\n\t\tval &= ~HFA384X_WEPFLAGS_HOSTDECRYPT;\n\n\tif (val != old_val &&\n\t    hostap_set_word(local->dev, HFA384X_RID_CNFWEPFLAGS, val)) {\n\t\tprintk(KERN_DEBUG \"Could not write new WEP flags (0x%x)\\n\",\n\t\t       val);\n\t\tgoto fail;\n\t}\n\n\tif (encrypt_type != WEP)\n\t\treturn 0;\n\n\t/* 104-bit support seems to require that all the keys are set to the\n\t * same keylen */\n\tkeylen = 6; /* first 5 octets */\n\tlen = local->crypt_info.crypt[idx]->ops->get_key(keybuf, sizeof(keybuf), NULL,\n\t\t\t\t\t\t\t   local->crypt_info.crypt[idx]->priv);\n\tif (idx >= 0 && idx < WEP_KEYS && len > 5)\n\t\tkeylen = WEP_KEY_LEN + 1; /* first 13 octets */\n\n\tfor (i = 0; i < WEP_KEYS; i++) {\n\t\tmemset(keybuf, 0, sizeof(keybuf));\n\t\tif (local->crypt_info.crypt[i]) {\n\t\t\t(void) local->crypt_info.crypt[i]->ops->get_key(\n\t\t\t\tkeybuf, sizeof(keybuf),\n\t\t\t\tNULL, local->crypt_info.crypt[i]->priv);\n\t\t}\n\t\tif (local->func->set_rid(local->dev,\n\t\t\t\t\t HFA384X_RID_CNFDEFAULTKEY0 + i,\n\t\t\t\t\t keybuf, keylen)) {\n\t\t\tprintk(KERN_DEBUG \"Could not set key %d (len=%d)\\n\",\n\t\t\t       i, keylen);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (hostap_set_word(local->dev, HFA384X_RID_CNFWEPDEFAULTKEYID, idx)) {\n\t\tprintk(KERN_DEBUG \"Could not set default keyid %d\\n\", idx);\n\t\tgoto fail;\n\t}\n\n\treturn 0;\n\n fail:\n\tprintk(KERN_DEBUG \"%s: encryption setup failed\\n\", local->dev->name);\n\treturn -1;\n}\n\n\nint hostap_set_antsel(local_info_t *local)\n{\n\tu16 val;\n\tint ret = 0;\n\n\tif (local->antsel_tx != HOSTAP_ANTSEL_DO_NOT_TOUCH &&\n\t    local->func->cmd(local->dev, HFA384X_CMDCODE_READMIF,\n\t\t\t     HFA386X_CR_TX_CONFIGURE,\n\t\t\t     NULL, &val) == 0) {\n\t\tval &= ~(BIT(2) | BIT(1));\n\t\tswitch (local->antsel_tx) {\n\t\tcase HOSTAP_ANTSEL_DIVERSITY:\n\t\t\tval |= BIT(1);\n\t\t\tbreak;\n\t\tcase HOSTAP_ANTSEL_LOW:\n\t\t\tbreak;\n\t\tcase HOSTAP_ANTSEL_HIGH:\n\t\t\tval |= BIT(2);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (local->func->cmd(local->dev, HFA384X_CMDCODE_WRITEMIF,\n\t\t\t\t     HFA386X_CR_TX_CONFIGURE, &val, NULL)) {\n\t\t\tprintk(KERN_INFO \"%s: setting TX AntSel failed\\n\",\n\t\t\t       local->dev->name);\n\t\t\tret = -1;\n\t\t}\n\t}\n\n\tif (local->antsel_rx != HOSTAP_ANTSEL_DO_NOT_TOUCH &&\n\t    local->func->cmd(local->dev, HFA384X_CMDCODE_READMIF,\n\t\t\t     HFA386X_CR_RX_CONFIGURE,\n\t\t\t     NULL, &val) == 0) {\n\t\tval &= ~(BIT(1) | BIT(0));\n\t\tswitch (local->antsel_rx) {\n\t\tcase HOSTAP_ANTSEL_DIVERSITY:\n\t\t\tbreak;\n\t\tcase HOSTAP_ANTSEL_LOW:\n\t\t\tval |= BIT(0);\n\t\t\tbreak;\n\t\tcase HOSTAP_ANTSEL_HIGH:\n\t\t\tval |= BIT(0) | BIT(1);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (local->func->cmd(local->dev, HFA384X_CMDCODE_WRITEMIF,\n\t\t\t\t     HFA386X_CR_RX_CONFIGURE, &val, NULL)) {\n\t\t\tprintk(KERN_INFO \"%s: setting RX AntSel failed\\n\",\n\t\t\t       local->dev->name);\n\t\t\tret = -1;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n\nint hostap_set_roaming(local_info_t *local)\n{\n\tu16 val;\n\n\tswitch (local->host_roaming) {\n\tcase 1:\n\t\tval = HFA384X_ROAMING_HOST;\n\t\tbreak;\n\tcase 2:\n\t\tval = HFA384X_ROAMING_DISABLED;\n\t\tbreak;\n\tcase 0:\n\tdefault:\n\t\tval = HFA384X_ROAMING_FIRMWARE;\n\t\tbreak;\n\t}\n\n\treturn hostap_set_word(local->dev, HFA384X_RID_CNFROAMINGMODE, val);\n}\n\n\nint hostap_set_auth_algs(local_info_t *local)\n{\n\tint val = local->auth_algs;\n\t/* At least STA f/w v0.6.2 seems to have issues with cnfAuthentication\n\t * set to include both Open and Shared Key flags. It tries to use\n\t * Shared Key authentication in that case even if WEP keys are not\n\t * configured.. STA f/w v0.7.6 is able to handle such configuration,\n\t * but it is unknown when this was fixed between 0.6.2 .. 0.7.6. */\n\tif (local->sta_fw_ver < PRISM2_FW_VER(0,7,0) &&\n\t    val != PRISM2_AUTH_OPEN && val != PRISM2_AUTH_SHARED_KEY)\n\t\tval = PRISM2_AUTH_OPEN;\n\n\tif (hostap_set_word(local->dev, HFA384X_RID_CNFAUTHENTICATION, val)) {\n\t\tprintk(KERN_INFO \"%s: cnfAuthentication setting to 0x%x \"\n\t\t       \"failed\\n\", local->dev->name, local->auth_algs);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n\nvoid hostap_dump_rx_header(const char *name, const struct hfa384x_rx_frame *rx)\n{\n\tu16 status, fc;\n\n\tstatus = __le16_to_cpu(rx->status);\n\n\tprintk(KERN_DEBUG \"%s: RX status=0x%04x (port=%d, type=%d, \"\n\t       \"fcserr=%d) silence=%d signal=%d rate=%d rxflow=%d; \"\n\t       \"jiffies=%ld\\n\",\n\t       name, status, (status >> 8) & 0x07, status >> 13, status & 1,\n\t       rx->silence, rx->signal, rx->rate, rx->rxflow, jiffies);\n\n\tfc = __le16_to_cpu(rx->frame_control);\n\tprintk(KERN_DEBUG \"   FC=0x%04x (type=%d:%d) dur=0x%04x seq=0x%04x \"\n\t       \"data_len=%d%s%s\\n\",\n\t       fc, (fc & IEEE80211_FCTL_FTYPE) >> 2,\n\t       (fc & IEEE80211_FCTL_STYPE) >> 4,\n\t       __le16_to_cpu(rx->duration_id), __le16_to_cpu(rx->seq_ctrl),\n\t       __le16_to_cpu(rx->data_len),\n\t       fc & IEEE80211_FCTL_TODS ? \" [ToDS]\" : \"\",\n\t       fc & IEEE80211_FCTL_FROMDS ? \" [FromDS]\" : \"\");\n\n\tprintk(KERN_DEBUG \"   A1=%pM A2=%pM A3=%pM A4=%pM\\n\",\n\t       rx->addr1, rx->addr2, rx->addr3, rx->addr4);\n\n\tprintk(KERN_DEBUG \"   dst=%pM src=%pM len=%d\\n\",\n\t       rx->dst_addr, rx->src_addr,\n\t       __be16_to_cpu(rx->len));\n}\n\n\nvoid hostap_dump_tx_header(const char *name, const struct hfa384x_tx_frame *tx)\n{\n\tu16 fc;\n\n\tprintk(KERN_DEBUG \"%s: TX status=0x%04x retry_count=%d tx_rate=%d \"\n\t       \"tx_control=0x%04x; jiffies=%ld\\n\",\n\t       name, __le16_to_cpu(tx->status), tx->retry_count, tx->tx_rate,\n\t       __le16_to_cpu(tx->tx_control), jiffies);\n\n\tfc = __le16_to_cpu(tx->frame_control);\n\tprintk(KERN_DEBUG \"   FC=0x%04x (type=%d:%d) dur=0x%04x seq=0x%04x \"\n\t       \"data_len=%d%s%s\\n\",\n\t       fc, (fc & IEEE80211_FCTL_FTYPE) >> 2,\n\t       (fc & IEEE80211_FCTL_STYPE) >> 4,\n\t       __le16_to_cpu(tx->duration_id), __le16_to_cpu(tx->seq_ctrl),\n\t       __le16_to_cpu(tx->data_len),\n\t       fc & IEEE80211_FCTL_TODS ? \" [ToDS]\" : \"\",\n\t       fc & IEEE80211_FCTL_FROMDS ? \" [FromDS]\" : \"\");\n\n\tprintk(KERN_DEBUG \"   A1=%pM A2=%pM A3=%pM A4=%pM\\n\",\n\t       tx->addr1, tx->addr2, tx->addr3, tx->addr4);\n\n\tprintk(KERN_DEBUG \"   dst=%pM src=%pM len=%d\\n\",\n\t       tx->dst_addr, tx->src_addr,\n\t       __be16_to_cpu(tx->len));\n}\n\n\nstatic int hostap_80211_header_parse(const struct sk_buff *skb,\n\t\t\t\t     unsigned char *haddr)\n{\n\tmemcpy(haddr, skb_mac_header(skb) + 10, ETH_ALEN); /* addr2 */\n\treturn ETH_ALEN;\n}\n\n\nint hostap_80211_get_hdrlen(__le16 fc)\n{\n\tif (ieee80211_is_data(fc) && ieee80211_has_a4 (fc))\n\t\treturn 30; /* Addr4 */\n\telse if (ieee80211_is_cts(fc) || ieee80211_is_ack(fc))\n\t\treturn 10;\n\telse if (ieee80211_is_ctl(fc))\n\t\treturn 16;\n\n\treturn 24;\n}\n\n\nstatic int prism2_close(struct net_device *dev)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\n\tPDEBUG(DEBUG_FLOW, \"%s: prism2_close\\n\", dev->name);\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (dev == local->ddev) {\n\t\tprism2_sta_deauth(local, WLAN_REASON_DEAUTH_LEAVING);\n\t}\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\n\tif (!local->hostapd && dev == local->dev &&\n\t    (!local->func->card_present || local->func->card_present(local)) &&\n\t    local->hw_ready && local->ap && local->iw_mode == IW_MODE_MASTER)\n\t\thostap_deauth_all_stas(dev, local->ap, 1);\n#endif /* PRISM2_NO_KERNEL_IEEE80211_MGMT */\n\n\tif (dev == local->dev) {\n\t\tlocal->func->hw_shutdown(dev, HOSTAP_HW_ENABLE_CMDCOMPL);\n\t}\n\n\tif (netif_running(dev)) {\n\t\tnetif_stop_queue(dev);\n\t\tnetif_device_detach(dev);\n\t}\n\n\tcancel_work_sync(&local->reset_queue);\n\tcancel_work_sync(&local->set_multicast_list_queue);\n\tcancel_work_sync(&local->set_tim_queue);\n#ifndef PRISM2_NO_STATION_MODES\n\tcancel_work_sync(&local->info_queue);\n#endif\n\tcancel_work_sync(&local->comms_qual_update);\n\n\tmodule_put(local->hw_module);\n\n\tlocal->num_dev_open--;\n\n\tif (dev != local->dev && local->dev->flags & IFF_UP &&\n\t    local->master_dev_auto_open && local->num_dev_open == 1) {\n\t\t/* Close master radio interface automatically if it was also\n\t\t * opened automatically and we are now closing the last\n\t\t * remaining non-master device. */\n\t\tdev_close(local->dev);\n\t}\n\n\treturn 0;\n}\n\n\nstatic int prism2_open(struct net_device *dev)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\n\tPDEBUG(DEBUG_FLOW, \"%s: prism2_open\\n\", dev->name);\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (local->no_pri) {\n\t\tprintk(KERN_DEBUG \"%s: could not set interface UP - no PRI \"\n\t\t       \"f/w\\n\", dev->name);\n\t\treturn 1;\n\t}\n\n\tif ((local->func->card_present && !local->func->card_present(local)) ||\n\t    local->hw_downloading)\n\t\treturn -ENODEV;\n\n\tif (!try_module_get(local->hw_module))\n\t\treturn -ENODEV;\n\tlocal->num_dev_open++;\n\n\tif (!local->dev_enabled && local->func->hw_enable(dev, 1)) {\n\t\tprintk(KERN_WARNING \"%s: could not enable MAC port\\n\",\n\t\t       dev->name);\n\t\tprism2_close(dev);\n\t\treturn 1;\n\t}\n\tif (!local->dev_enabled)\n\t\tprism2_callback(local, PRISM2_CALLBACK_ENABLE);\n\tlocal->dev_enabled = 1;\n\n\tif (dev != local->dev && !(local->dev->flags & IFF_UP)) {\n\t\t/* Master radio interface is needed for all operation, so open\n\t\t * it automatically when any virtual net_device is opened. */\n\t\tlocal->master_dev_auto_open = 1;\n\t\tdev_open(local->dev);\n\t}\n\n\tnetif_device_attach(dev);\n\tnetif_start_queue(dev);\n\n\treturn 0;\n}\n\n\nstatic int prism2_set_mac_address(struct net_device *dev, void *p)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tstruct list_head *ptr;\n\tstruct sockaddr *addr = p;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (local->func->set_rid(dev, HFA384X_RID_CNFOWNMACADDR, addr->sa_data,\n\t\t\t\t ETH_ALEN) < 0 || local->func->reset_port(dev))\n\t\treturn -EINVAL;\n\n\tread_lock_bh(&local->iface_lock);\n\tlist_for_each(ptr, &local->hostap_interfaces) {\n\t\tiface = list_entry(ptr, struct hostap_interface, list);\n\t\tmemcpy(iface->dev->dev_addr, addr->sa_data, ETH_ALEN);\n\t}\n\tmemcpy(local->dev->dev_addr, addr->sa_data, ETH_ALEN);\n\tread_unlock_bh(&local->iface_lock);\n\n\treturn 0;\n}\n\n\n/* TODO: to be further implemented as soon as Prism2 fully supports\n *       GroupAddresses and correct documentation is available */\nvoid hostap_set_multicast_list_queue(struct work_struct *work)\n{\n\tlocal_info_t *local =\n\t\tcontainer_of(work, local_info_t, set_multicast_list_queue);\n\tstruct net_device *dev = local->dev;\n\n\tif (hostap_set_word(dev, HFA384X_RID_PROMISCUOUSMODE,\n\t\t\t    local->is_promisc)) {\n\t\tprintk(KERN_INFO \"%s: %sabling promiscuous mode failed\\n\",\n\t\t       dev->name, local->is_promisc ? \"en\" : \"dis\");\n\t}\n}\n\n\nstatic void hostap_set_multicast_list(struct net_device *dev)\n{\n#if 0\n\t/* FIX: promiscuous mode seems to be causing a lot of problems with\n\t * some station firmware versions (FCSErr frames, invalid MACPort, etc.\n\t * corrupted incoming frames). This code is now commented out while the\n\t * problems are investigated. */\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\tif ((dev->flags & IFF_ALLMULTI) || (dev->flags & IFF_PROMISC)) {\n\t\tlocal->is_promisc = 1;\n\t} else {\n\t\tlocal->is_promisc = 0;\n\t}\n\n\tschedule_work(&local->set_multicast_list_queue);\n#endif\n}\n\n\nstatic int prism2_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tif (new_mtu < PRISM2_MIN_MTU || new_mtu > PRISM2_MAX_MTU)\n\t\treturn -EINVAL;\n\n\tdev->mtu = new_mtu;\n\treturn 0;\n}\n\n\nstatic void prism2_tx_timeout(struct net_device *dev)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tstruct hfa384x_regs regs;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tprintk(KERN_WARNING \"%s Tx timed out! Resetting card\\n\", dev->name);\n\tnetif_stop_queue(local->dev);\n\n\tlocal->func->read_regs(dev, &regs);\n\tprintk(KERN_DEBUG \"%s: CMD=%04x EVSTAT=%04x \"\n\t       \"OFFSET0=%04x OFFSET1=%04x SWSUPPORT0=%04x\\n\",\n\t       dev->name, regs.cmd, regs.evstat, regs.offset0, regs.offset1,\n\t       regs.swsupport0);\n\n\tlocal->func->schedule_reset(local);\n}\n\nconst struct header_ops hostap_80211_ops = {\n\t.create\t\t= eth_header,\n\t.rebuild\t= eth_rebuild_header,\n\t.cache\t\t= eth_header_cache,\n\t.cache_update\t= eth_header_cache_update,\n\t.parse\t\t= hostap_80211_header_parse,\n};\nEXPORT_SYMBOL(hostap_80211_ops);\n\n\nstatic const struct net_device_ops hostap_netdev_ops = {\n\t.ndo_start_xmit\t\t= hostap_data_start_xmit,\n\n\t.ndo_open\t\t= prism2_open,\n\t.ndo_stop\t\t= prism2_close,\n\t.ndo_do_ioctl\t\t= hostap_ioctl,\n\t.ndo_set_mac_address\t= prism2_set_mac_address,\n\t.ndo_set_multicast_list = hostap_set_multicast_list,\n\t.ndo_change_mtu \t= prism2_change_mtu,\n\t.ndo_tx_timeout \t= prism2_tx_timeout,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic const struct net_device_ops hostap_mgmt_netdev_ops = {\n\t.ndo_start_xmit\t\t= hostap_mgmt_start_xmit,\n\n\t.ndo_open\t\t= prism2_open,\n\t.ndo_stop\t\t= prism2_close,\n\t.ndo_do_ioctl\t\t= hostap_ioctl,\n\t.ndo_set_mac_address\t= prism2_set_mac_address,\n\t.ndo_set_multicast_list = hostap_set_multicast_list,\n\t.ndo_change_mtu \t= prism2_change_mtu,\n\t.ndo_tx_timeout \t= prism2_tx_timeout,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic const struct net_device_ops hostap_master_ops = {\n\t.ndo_start_xmit \t= hostap_master_start_xmit,\n\n\t.ndo_open\t\t= prism2_open,\n\t.ndo_stop\t\t= prism2_close,\n\t.ndo_do_ioctl\t\t= hostap_ioctl,\n\t.ndo_set_mac_address\t= prism2_set_mac_address,\n\t.ndo_set_multicast_list = hostap_set_multicast_list,\n\t.ndo_change_mtu \t= prism2_change_mtu,\n\t.ndo_tx_timeout \t= prism2_tx_timeout,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nvoid hostap_setup_dev(struct net_device *dev, local_info_t *local,\n\t\t      int type)\n{\n\tstruct hostap_interface *iface;\n\n\tiface = netdev_priv(dev);\n\tether_setup(dev);\n\n\t/* kernel callbacks */\n\tif (iface) {\n\t\t/* Currently, we point to the proper spy_data only on\n\t\t * the main_dev. This could be fixed. Jean II */\n\t\tiface->wireless_data.spy_data = &iface->spy_data;\n\t\tdev->wireless_data = &iface->wireless_data;\n\t}\n\tdev->wireless_handlers = &hostap_iw_handler_def;\n\tdev->watchdog_timeo = TX_TIMEOUT;\n\n\tswitch(type) {\n\tcase HOSTAP_INTERFACE_AP:\n\t\tdev->tx_queue_len = 0;\t/* use main radio device queue */\n\t\tdev->netdev_ops = &hostap_mgmt_netdev_ops;\n\t\tdev->type = ARPHRD_IEEE80211;\n\t\tdev->header_ops = &hostap_80211_ops;\n\t\tbreak;\n\tcase HOSTAP_INTERFACE_MASTER:\n\t\tdev->netdev_ops = &hostap_master_ops;\n\t\tbreak;\n\tdefault:\n\t\tdev->tx_queue_len = 0;\t/* use main radio device queue */\n\t\tdev->netdev_ops = &hostap_netdev_ops;\n\t}\n\n\tdev->mtu = local->mtu;\n\n\n\tSET_ETHTOOL_OPS(dev, &prism2_ethtool_ops);\n\n}\n\nstatic int hostap_enable_hostapd(local_info_t *local, int rtnl_locked)\n{\n\tstruct net_device *dev = local->dev;\n\n\tif (local->apdev)\n\t\treturn -EEXIST;\n\n\tprintk(KERN_DEBUG \"%s: enabling hostapd mode\\n\", dev->name);\n\n\tlocal->apdev = hostap_add_interface(local, HOSTAP_INTERFACE_AP,\n\t\t\t\t\t    rtnl_locked, local->ddev->name,\n\t\t\t\t\t    \"ap\");\n\tif (local->apdev == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n\nstatic int hostap_disable_hostapd(local_info_t *local, int rtnl_locked)\n{\n\tstruct net_device *dev = local->dev;\n\n\tprintk(KERN_DEBUG \"%s: disabling hostapd mode\\n\", dev->name);\n\n\thostap_remove_interface(local->apdev, rtnl_locked, 1);\n\tlocal->apdev = NULL;\n\n\treturn 0;\n}\n\n\nstatic int hostap_enable_hostapd_sta(local_info_t *local, int rtnl_locked)\n{\n\tstruct net_device *dev = local->dev;\n\n\tif (local->stadev)\n\t\treturn -EEXIST;\n\n\tprintk(KERN_DEBUG \"%s: enabling hostapd STA mode\\n\", dev->name);\n\n\tlocal->stadev = hostap_add_interface(local, HOSTAP_INTERFACE_STA,\n\t\t\t\t\t     rtnl_locked, local->ddev->name,\n\t\t\t\t\t     \"sta\");\n\tif (local->stadev == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n\nstatic int hostap_disable_hostapd_sta(local_info_t *local, int rtnl_locked)\n{\n\tstruct net_device *dev = local->dev;\n\n\tprintk(KERN_DEBUG \"%s: disabling hostapd mode\\n\", dev->name);\n\n\thostap_remove_interface(local->stadev, rtnl_locked, 1);\n\tlocal->stadev = NULL;\n\n\treturn 0;\n}\n\n\nint hostap_set_hostapd(local_info_t *local, int val, int rtnl_locked)\n{\n\tint ret;\n\n\tif (val < 0 || val > 1)\n\t\treturn -EINVAL;\n\n\tif (local->hostapd == val)\n\t\treturn 0;\n\n\tif (val) {\n\t\tret = hostap_enable_hostapd(local, rtnl_locked);\n\t\tif (ret == 0)\n\t\t\tlocal->hostapd = 1;\n\t} else {\n\t\tlocal->hostapd = 0;\n\t\tret = hostap_disable_hostapd(local, rtnl_locked);\n\t\tif (ret != 0)\n\t\t\tlocal->hostapd = 1;\n\t}\n\n\treturn ret;\n}\n\n\nint hostap_set_hostapd_sta(local_info_t *local, int val, int rtnl_locked)\n{\n\tint ret;\n\n\tif (val < 0 || val > 1)\n\t\treturn -EINVAL;\n\n\tif (local->hostapd_sta == val)\n\t\treturn 0;\n\n\tif (val) {\n\t\tret = hostap_enable_hostapd_sta(local, rtnl_locked);\n\t\tif (ret == 0)\n\t\t\tlocal->hostapd_sta = 1;\n\t} else {\n\t\tlocal->hostapd_sta = 0;\n\t\tret = hostap_disable_hostapd_sta(local, rtnl_locked);\n\t\tif (ret != 0)\n\t\t\tlocal->hostapd_sta = 1;\n\t}\n\n\n\treturn ret;\n}\n\n\nint prism2_update_comms_qual(struct net_device *dev)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tint ret = 0;\n\tstruct hfa384x_comms_quality sq;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\tif (!local->sta_fw_ver)\n\t\tret = -1;\n\telse if (local->sta_fw_ver >= PRISM2_FW_VER(1,3,1)) {\n\t\tif (local->func->get_rid(local->dev,\n\t\t\t\t\t HFA384X_RID_DBMCOMMSQUALITY,\n\t\t\t\t\t &sq, sizeof(sq), 1) >= 0) {\n\t\t\tlocal->comms_qual = (s16) le16_to_cpu(sq.comm_qual);\n\t\t\tlocal->avg_signal = (s16) le16_to_cpu(sq.signal_level);\n\t\t\tlocal->avg_noise = (s16) le16_to_cpu(sq.noise_level);\n\t\t\tlocal->last_comms_qual_update = jiffies;\n\t\t} else\n\t\t\tret = -1;\n\t} else {\n\t\tif (local->func->get_rid(local->dev, HFA384X_RID_COMMSQUALITY,\n\t\t\t\t\t &sq, sizeof(sq), 1) >= 0) {\n\t\t\tlocal->comms_qual = le16_to_cpu(sq.comm_qual);\n\t\t\tlocal->avg_signal = HFA384X_LEVEL_TO_dBm(\n\t\t\t\tle16_to_cpu(sq.signal_level));\n\t\t\tlocal->avg_noise = HFA384X_LEVEL_TO_dBm(\n\t\t\t\tle16_to_cpu(sq.noise_level));\n\t\t\tlocal->last_comms_qual_update = jiffies;\n\t\t} else\n\t\t\tret = -1;\n\t}\n\n\treturn ret;\n}\n\n\nint prism2_sta_send_mgmt(local_info_t *local, u8 *dst, u16 stype,\n\t\t\t u8 *body, size_t bodylen)\n{\n\tstruct sk_buff *skb;\n\tstruct hostap_ieee80211_mgmt *mgmt;\n\tstruct hostap_skb_tx_data *meta;\n\tstruct net_device *dev = local->dev;\n\n\tskb = dev_alloc_skb(IEEE80211_MGMT_HDR_LEN + bodylen);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tmgmt = (struct hostap_ieee80211_mgmt *)\n\t\tskb_put(skb, IEEE80211_MGMT_HDR_LEN);\n\tmemset(mgmt, 0, IEEE80211_MGMT_HDR_LEN);\n\tmgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT | stype);\n\tmemcpy(mgmt->da, dst, ETH_ALEN);\n\tmemcpy(mgmt->sa, dev->dev_addr, ETH_ALEN);\n\tmemcpy(mgmt->bssid, dst, ETH_ALEN);\n\tif (body)\n\t\tmemcpy(skb_put(skb, bodylen), body, bodylen);\n\n\tmeta = (struct hostap_skb_tx_data *) skb->cb;\n\tmemset(meta, 0, sizeof(*meta));\n\tmeta->magic = HOSTAP_SKB_TX_DATA_MAGIC;\n\tmeta->iface = netdev_priv(dev);\n\n\tskb->dev = dev;\n\tskb_reset_mac_header(skb);\n\tskb_reset_network_header(skb);\n\tdev_queue_xmit(skb);\n\n\treturn 0;\n}\n\n\nint prism2_sta_deauth(local_info_t *local, u16 reason)\n{\n\tunion iwreq_data wrqu;\n\tint ret;\n\t__le16 val = cpu_to_le16(reason);\n\n\tif (local->iw_mode != IW_MODE_INFRA ||\n\t    memcmp(local->bssid, \"\\x00\\x00\\x00\\x00\\x00\\x00\", ETH_ALEN) == 0 ||\n\t    memcmp(local->bssid, \"\\x44\\x44\\x44\\x44\\x44\\x44\", ETH_ALEN) == 0)\n\t\treturn 0;\n\n\tret = prism2_sta_send_mgmt(local, local->bssid, IEEE80211_STYPE_DEAUTH,\n\t\t\t\t   (u8 *) &val, 2);\n\tmemset(wrqu.ap_addr.sa_data, 0, ETH_ALEN);\n\twireless_send_event(local->dev, SIOCGIWAP, &wrqu, NULL);\n\treturn ret;\n}\n\n\nstruct proc_dir_entry *hostap_proc;\n\nstatic int __init hostap_init(void)\n{\n\tif (init_net.proc_net != NULL) {\n\t\thostap_proc = proc_mkdir(\"hostap\", init_net.proc_net);\n\t\tif (!hostap_proc)\n\t\t\tprintk(KERN_WARNING \"Failed to mkdir \"\n\t\t\t       \"/proc/net/hostap\\n\");\n\t} else\n\t\thostap_proc = NULL;\n\n\treturn 0;\n}\n\n\nstatic void __exit hostap_exit(void)\n{\n\tif (hostap_proc != NULL) {\n\t\thostap_proc = NULL;\n\t\tremove_proc_entry(\"hostap\", init_net.proc_net);\n\t}\n}\n\n\nEXPORT_SYMBOL(hostap_set_word);\nEXPORT_SYMBOL(hostap_set_string);\nEXPORT_SYMBOL(hostap_get_porttype);\nEXPORT_SYMBOL(hostap_set_encryption);\nEXPORT_SYMBOL(hostap_set_antsel);\nEXPORT_SYMBOL(hostap_set_roaming);\nEXPORT_SYMBOL(hostap_set_auth_algs);\nEXPORT_SYMBOL(hostap_dump_rx_header);\nEXPORT_SYMBOL(hostap_dump_tx_header);\nEXPORT_SYMBOL(hostap_80211_get_hdrlen);\nEXPORT_SYMBOL(hostap_setup_dev);\nEXPORT_SYMBOL(hostap_set_multicast_list_queue);\nEXPORT_SYMBOL(hostap_set_hostapd);\nEXPORT_SYMBOL(hostap_set_hostapd_sta);\nEXPORT_SYMBOL(hostap_add_interface);\nEXPORT_SYMBOL(hostap_remove_interface);\nEXPORT_SYMBOL(prism2_update_comms_qual);\n\nmodule_init(hostap_init);\nmodule_exit(hostap_exit);\n", "//------------------------------------------------------------------------------\n// Copyright (c) 2004-2010 Atheros Communications Inc.\n// All rights reserved.\n//\n// \n//\n// Permission to use, copy, modify, and/or distribute this software for any\n// purpose with or without fee is hereby granted, provided that the above\n// copyright notice and this permission notice appear in all copies.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n//\n//\n//\n// Author(s): =\"Atheros\"\n//------------------------------------------------------------------------------\n\n/*\n * This driver is a pseudo ethernet driver to access the Atheros AR6000\n * WLAN Device\n */\n\n#include \"ar6000_drv.h\"\n#include \"cfg80211.h\"\n#include \"htc.h\"\n#include \"wmi_filter_linux.h\"\n#include \"epping_test.h\"\n#include \"wlan_config.h\"\n#include \"ar3kconfig.h\"\n#include \"ar6k_pal.h\"\n#include \"AR6002/addrs.h\"\n\n\n/* LINUX_HACK_FUDGE_FACTOR -- this is used to provide a workaround for linux behavior.  When\n *  the meta data was added to the header it was found that linux did not correctly provide\n *  enough headroom.  However when more headroom was requested beyond what was truly needed\n *  Linux gave the requested headroom. Therefore to get the necessary headroom from Linux\n *  the driver requests more than is needed by the amount = LINUX_HACK_FUDGE_FACTOR */\n#define LINUX_HACK_FUDGE_FACTOR 16\n#define BDATA_BDADDR_OFFSET     28\n\nu8 bcast_mac[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\nu8 null_mac[] = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0};\n\n#ifdef DEBUG\n\n#define  ATH_DEBUG_DBG_LOG       ATH_DEBUG_MAKE_MODULE_MASK(0)\n#define  ATH_DEBUG_WLAN_CONNECT  ATH_DEBUG_MAKE_MODULE_MASK(1)\n#define  ATH_DEBUG_WLAN_SCAN     ATH_DEBUG_MAKE_MODULE_MASK(2)\n#define  ATH_DEBUG_WLAN_TX       ATH_DEBUG_MAKE_MODULE_MASK(3)\n#define  ATH_DEBUG_WLAN_RX       ATH_DEBUG_MAKE_MODULE_MASK(4)\n#define  ATH_DEBUG_HTC_RAW       ATH_DEBUG_MAKE_MODULE_MASK(5)\n#define  ATH_DEBUG_HCI_BRIDGE    ATH_DEBUG_MAKE_MODULE_MASK(6)\n\nstatic struct ath_debug_mask_description driver_debug_desc[] = {\n    { ATH_DEBUG_DBG_LOG      , \"Target Debug Logs\"},\n    { ATH_DEBUG_WLAN_CONNECT , \"WLAN connect\"},\n    { ATH_DEBUG_WLAN_SCAN    , \"WLAN scan\"},\n    { ATH_DEBUG_WLAN_TX      , \"WLAN Tx\"},\n    { ATH_DEBUG_WLAN_RX      , \"WLAN Rx\"},\n    { ATH_DEBUG_HTC_RAW      , \"HTC Raw IF tracing\"},\n    { ATH_DEBUG_HCI_BRIDGE   , \"HCI Bridge Setup\"},\n    { ATH_DEBUG_HCI_RECV     , \"HCI Recv tracing\"},\n    { ATH_DEBUG_HCI_DUMP     , \"HCI Packet dumps\"},\n};\n\nATH_DEBUG_INSTANTIATE_MODULE_VAR(driver,\n                                 \"driver\",\n                                 \"Linux Driver Interface\",\n                                 ATH_DEBUG_MASK_DEFAULTS | ATH_DEBUG_WLAN_SCAN |\n                                 ATH_DEBUG_HCI_BRIDGE,\n                                 ATH_DEBUG_DESCRIPTION_COUNT(driver_debug_desc),\n                                 driver_debug_desc);\n\n#endif\n\n\n#define IS_MAC_NULL(mac) (mac[0]==0 && mac[1]==0 && mac[2]==0 && mac[3]==0 && mac[4]==0 && mac[5]==0)\n#define IS_MAC_BCAST(mac) (*mac==0xff)\n\n#define DESCRIPTION \"Driver to access the Atheros AR600x Device, version \" __stringify(__VER_MAJOR_) \".\" __stringify(__VER_MINOR_) \".\" __stringify(__VER_PATCH_) \".\" __stringify(__BUILD_NUMBER_)\n\nMODULE_AUTHOR(\"Atheros Communications, Inc.\");\nMODULE_DESCRIPTION(DESCRIPTION);\nMODULE_LICENSE(\"Dual BSD/GPL\");\n\n#ifndef REORG_APTC_HEURISTICS\n#undef ADAPTIVE_POWER_THROUGHPUT_CONTROL\n#endif /* REORG_APTC_HEURISTICS */\n\n#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL\n#define APTC_TRAFFIC_SAMPLING_INTERVAL     100  /* msec */\n#define APTC_UPPER_THROUGHPUT_THRESHOLD    3000 /* Kbps */\n#define APTC_LOWER_THROUGHPUT_THRESHOLD    2000 /* Kbps */\n\ntypedef struct aptc_traffic_record {\n    bool timerScheduled;\n    struct timeval samplingTS;\n    unsigned long bytesReceived;\n    unsigned long bytesTransmitted;\n} APTC_TRAFFIC_RECORD;\n\nA_TIMER aptcTimer;\nAPTC_TRAFFIC_RECORD aptcTR;\n#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */\n\n#ifdef EXPORT_HCI_BRIDGE_INTERFACE\n// callbacks registered by HCI transport driver\nstruct hci_transport_callbacks ar6kHciTransCallbacks = { NULL };\n#endif\n\nunsigned int processDot11Hdr = 0;\n\nchar ifname[IFNAMSIZ] = {0,};\n\nint wlaninitmode = WLAN_INIT_MODE_DEFAULT;\nstatic bool bypasswmi;\nunsigned int debuglevel = 0;\nint tspecCompliance = ATHEROS_COMPLIANCE;\nunsigned int busspeedlow = 0;\nunsigned int onebitmode = 0;\nunsigned int skipflash = 0;\nunsigned int wmitimeout = 2;\nunsigned int wlanNodeCaching = 1;\nunsigned int enableuartprint = ENABLEUARTPRINT_DEFAULT;\nunsigned int logWmiRawMsgs = 0;\nunsigned int enabletimerwar = 0;\nunsigned int num_device = 1;\nunsigned int regscanmode;\nunsigned int fwmode = 1;\nunsigned int mbox_yield_limit = 99;\nunsigned int enablerssicompensation = 0;\nint reduce_credit_dribble = 1 + HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_ONE_HALF;\nint allow_trace_signal = 0;\n#ifdef CONFIG_HOST_TCMD_SUPPORT\nunsigned int testmode =0;\n#endif\n\nunsigned int irqprocmode = HIF_DEVICE_IRQ_SYNC_ONLY;//HIF_DEVICE_IRQ_ASYNC_SYNC;\nunsigned int panic_on_assert = 1;\nunsigned int nohifscattersupport = NOHIFSCATTERSUPPORT_DEFAULT;\n\nunsigned int setuphci = SETUPHCI_DEFAULT;\nunsigned int loghci = 0;\nunsigned int setupbtdev = SETUPBTDEV_DEFAULT;\n#ifndef EXPORT_HCI_BRIDGE_INTERFACE\nunsigned int ar3khcibaud = AR3KHCIBAUD_DEFAULT;\nunsigned int hciuartscale = HCIUARTSCALE_DEFAULT;\nunsigned int hciuartstep = HCIUARTSTEP_DEFAULT;\n#endif\nunsigned int csumOffload=0;\nunsigned int csumOffloadTest=0;\nunsigned int eppingtest=0;\nunsigned int mac_addr_method;\nunsigned int firmware_bridge;\n\nmodule_param_string(ifname, ifname, sizeof(ifname), 0644);\nmodule_param(wlaninitmode, int, 0644);\nmodule_param(bypasswmi, bool, 0644);\nmodule_param(debuglevel, uint, 0644);\nmodule_param(tspecCompliance, int, 0644);\nmodule_param(onebitmode, uint, 0644);\nmodule_param(busspeedlow, uint, 0644);\nmodule_param(skipflash, uint, 0644);\nmodule_param(wmitimeout, uint, 0644);\nmodule_param(wlanNodeCaching, uint, 0644);\nmodule_param(logWmiRawMsgs, uint, 0644);\nmodule_param(enableuartprint, uint, 0644);\nmodule_param(enabletimerwar, uint, 0644);\nmodule_param(fwmode, uint, 0644);\nmodule_param(mbox_yield_limit, uint, 0644);\nmodule_param(reduce_credit_dribble, int, 0644);\nmodule_param(allow_trace_signal, int, 0644);\nmodule_param(enablerssicompensation, uint, 0644);\nmodule_param(processDot11Hdr, uint, 0644);\nmodule_param(csumOffload, uint, 0644);\n#ifdef CONFIG_HOST_TCMD_SUPPORT\nmodule_param(testmode, uint, 0644);\n#endif\nmodule_param(irqprocmode, uint, 0644);\nmodule_param(nohifscattersupport, uint, 0644);\nmodule_param(panic_on_assert, uint, 0644);\nmodule_param(setuphci, uint, 0644);\nmodule_param(loghci, uint, 0644);\nmodule_param(setupbtdev, uint, 0644);\n#ifndef EXPORT_HCI_BRIDGE_INTERFACE\nmodule_param(ar3khcibaud, uint, 0644);\nmodule_param(hciuartscale, uint, 0644);\nmodule_param(hciuartstep, uint, 0644);\n#endif\nmodule_param(eppingtest, uint, 0644);\n\n/* in 2.6.10 and later this is now a pointer to a uint */\nunsigned int _mboxnum = HTC_MAILBOX_NUM_MAX;\n#define mboxnum &_mboxnum\n\n#ifdef DEBUG\nu32 g_dbg_flags = DBG_DEFAULTS;\nunsigned int debugflags = 0;\nint debugdriver = 0;\nunsigned int debughtc = 0;\nunsigned int debugbmi = 0;\nunsigned int debughif = 0;\nunsigned int txcreditsavailable[HTC_MAILBOX_NUM_MAX] = {0};\nunsigned int txcreditsconsumed[HTC_MAILBOX_NUM_MAX] = {0};\nunsigned int txcreditintrenable[HTC_MAILBOX_NUM_MAX] = {0};\nunsigned int txcreditintrenableaggregate[HTC_MAILBOX_NUM_MAX] = {0};\nmodule_param(debugflags, uint, 0644);\nmodule_param(debugdriver, int, 0644);\nmodule_param(debughtc, uint, 0644);\nmodule_param(debugbmi, uint, 0644);\nmodule_param(debughif, uint, 0644);\nmodule_param_array(txcreditsavailable, uint, mboxnum, 0644);\nmodule_param_array(txcreditsconsumed, uint, mboxnum, 0644);\nmodule_param_array(txcreditintrenable, uint, mboxnum, 0644);\nmodule_param_array(txcreditintrenableaggregate, uint, mboxnum, 0644);\n\n#endif /* DEBUG */\n\nunsigned int resetok = 1;\nunsigned int tx_attempt[HTC_MAILBOX_NUM_MAX] = {0};\nunsigned int tx_post[HTC_MAILBOX_NUM_MAX] = {0};\nunsigned int tx_complete[HTC_MAILBOX_NUM_MAX] = {0};\nunsigned int hifBusRequestNumMax = 40;\nunsigned int war23838_disabled = 0;\n#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL\nunsigned int enableAPTCHeuristics = 1;\n#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */\nmodule_param_array(tx_attempt, uint, mboxnum, 0644);\nmodule_param_array(tx_post, uint, mboxnum, 0644);\nmodule_param_array(tx_complete, uint, mboxnum, 0644);\nmodule_param(hifBusRequestNumMax, uint, 0644);\nmodule_param(war23838_disabled, uint, 0644);\nmodule_param(resetok, uint, 0644);\n#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL\nmodule_param(enableAPTCHeuristics, uint, 0644);\n#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */\n\n#ifdef BLOCK_TX_PATH_FLAG\nint blocktx = 0;\nmodule_param(blocktx, int, 0644);\n#endif /* BLOCK_TX_PATH_FLAG */\n\ntypedef struct user_rssi_compensation_t {\n    u16 customerID;\n    union {\n    u16 a_enable;\n    u16 bg_enable;\n    u16 enable;\n    };\n    s16 bg_param_a;\n    s16 bg_param_b;\n    s16 a_param_a;\n    s16 a_param_b;\n    u32 reserved;\n} USER_RSSI_CPENSATION;\n\nstatic USER_RSSI_CPENSATION rssi_compensation_param;\n\nstatic s16 rssi_compensation_table[96];\n\nint reconnect_flag = 0;\nstatic ar6k_pal_config_t ar6k_pal_config_g;\n\n/* Function declarations */\nstatic int ar6000_init_module(void);\nstatic void ar6000_cleanup_module(void);\n\nint ar6000_init(struct net_device *dev);\nstatic int ar6000_open(struct net_device *dev);\nstatic int ar6000_close(struct net_device *dev);\nstatic void ar6000_init_control_info(struct ar6_softc *ar);\nstatic int ar6000_data_tx(struct sk_buff *skb, struct net_device *dev);\n\nvoid ar6000_destroy(struct net_device *dev, unsigned int unregister);\nstatic void ar6000_detect_error(unsigned long ptr);\nstatic void\tar6000_set_multicast_list(struct net_device *dev);\nstatic struct net_device_stats *ar6000_get_stats(struct net_device *dev);\n\nstatic void disconnect_timer_handler(unsigned long ptr);\n\nvoid read_rssi_compensation_param(struct ar6_softc *ar);\n\n/*\n * HTC service connection handlers\n */\nstatic int ar6000_avail_ev(void *context, void *hif_handle);\n\nstatic int ar6000_unavail_ev(void *context, void *hif_handle);\n\nint ar6000_configure_target(struct ar6_softc *ar);\n\nstatic void ar6000_target_failure(void *Instance, int Status);\n\nstatic void ar6000_rx(void *Context, struct htc_packet *pPacket);\n\nstatic void ar6000_rx_refill(void *Context,HTC_ENDPOINT_ID Endpoint);\n\nstatic void ar6000_tx_complete(void *Context, struct htc_packet_queue *pPackets);\n\nstatic HTC_SEND_FULL_ACTION ar6000_tx_queue_full(void *Context, struct htc_packet *pPacket);\n\nstatic void ar6000_alloc_netbufs(A_NETBUF_QUEUE_T *q, u16 num);\nstatic void ar6000_deliver_frames_to_nw_stack(void * dev, void *osbuf);\n//static void ar6000_deliver_frames_to_bt_stack(void * dev, void *osbuf);\n\nstatic struct htc_packet *ar6000_alloc_amsdu_rxbuf(void *Context, HTC_ENDPOINT_ID Endpoint, int Length);\n\nstatic void ar6000_refill_amsdu_rxbufs(struct ar6_softc *ar, int Count);\n\nstatic void ar6000_cleanup_amsdu_rxbufs(struct ar6_softc *ar);\n\nstatic ssize_t\nar6000_sysfs_bmi_read(struct file *fp, struct kobject *kobj,\n                      struct bin_attribute *bin_attr,\n                      char *buf, loff_t pos, size_t count);\n\nstatic ssize_t\nar6000_sysfs_bmi_write(struct file *fp, struct kobject *kobj,\n                       struct bin_attribute *bin_attr,\n                       char *buf, loff_t pos, size_t count);\n\nstatic int\nar6000_sysfs_bmi_init(struct ar6_softc *ar);\n\nvoid  ar6k_cleanup_hci_pal(struct ar6_softc *ar);\n\nstatic void\nar6000_sysfs_bmi_deinit(struct ar6_softc *ar);\n\nint\nar6000_sysfs_bmi_get_config(struct ar6_softc *ar, u32 mode);\n\n/*\n * Static variables\n */\n\nstruct net_device *ar6000_devices[MAX_AR6000];\nstatic int is_netdev_registered;\nDECLARE_WAIT_QUEUE_HEAD(arEvent);\nstatic void ar6000_cookie_init(struct ar6_softc *ar);\nstatic void ar6000_cookie_cleanup(struct ar6_softc *ar);\nstatic void ar6000_free_cookie(struct ar6_softc *ar, struct ar_cookie * cookie);\nstatic struct ar_cookie *ar6000_alloc_cookie(struct ar6_softc *ar);\n\nstatic int ar6000_reinstall_keys(struct ar6_softc *ar,u8 key_op_ctrl);\n\n#ifdef CONFIG_AP_VIRTUAL_ADAPTER_SUPPORT\nstruct net_device *arApNetDev;\n#endif /* CONFIG_AP_VIRTUAL_ADAPTER_SUPPORT */\n\nstatic struct ar_cookie s_ar_cookie_mem[MAX_COOKIE_NUM];\n\n#define HOST_INTEREST_ITEM_ADDRESS(ar, item) \\\n        (((ar)->arTargetType == TARGET_TYPE_AR6002) ? AR6002_HOST_INTEREST_ITEM_ADDRESS(item) : \\\n        (((ar)->arTargetType == TARGET_TYPE_AR6003) ? AR6003_HOST_INTEREST_ITEM_ADDRESS(item) : 0))\n\n\nstatic struct net_device_ops ar6000_netdev_ops = {\n    .ndo_init               = NULL,\n    .ndo_open               = ar6000_open,\n    .ndo_stop               = ar6000_close,\n    .ndo_get_stats          = ar6000_get_stats,\n    .ndo_start_xmit         = ar6000_data_tx,\n    .ndo_set_multicast_list = ar6000_set_multicast_list,\n};\n\n/* Debug log support */\n\n/*\n * Flag to govern whether the debug logs should be parsed in the kernel\n * or reported to the application.\n */\n#define REPORT_DEBUG_LOGS_TO_APP\n\nint\nar6000_set_host_app_area(struct ar6_softc *ar)\n{\n    u32 address, data;\n    struct host_app_area_s host_app_area;\n\n    /* Fetch the address of the host_app_area_s instance in the host interest area */\n    address = TARG_VTOP(ar->arTargetType, HOST_INTEREST_ITEM_ADDRESS(ar, hi_app_host_interest));\n    if (ar6000_ReadRegDiag(ar->arHifDevice, &address, &data) != 0) {\n        return A_ERROR;\n    }\n    address = TARG_VTOP(ar->arTargetType, data);\n    host_app_area.wmi_protocol_ver = WMI_PROTOCOL_VERSION;\n    if (ar6000_WriteDataDiag(ar->arHifDevice, address,\n                             (u8 *)&host_app_area,\n                             sizeof(struct host_app_area_s)) != 0)\n    {\n        return A_ERROR;\n    }\n\n    return 0;\n}\n\nu32 dbglog_get_debug_hdr_ptr(struct ar6_softc *ar)\n{\n    u32 param;\n    u32 address;\n    int status;\n\n    address = TARG_VTOP(ar->arTargetType, HOST_INTEREST_ITEM_ADDRESS(ar, hi_dbglog_hdr));\n    if ((status = ar6000_ReadDataDiag(ar->arHifDevice, address,\n                                      (u8 *)&param, 4)) != 0)\n    {\n        param = 0;\n    }\n\n    return param;\n}\n\n/*\n * The dbglog module has been initialized. Its ok to access the relevant\n * data stuctures over the diagnostic window.\n */\nvoid\nar6000_dbglog_init_done(struct ar6_softc *ar)\n{\n    ar->dbglog_init_done = true;\n}\n\nu32 dbglog_get_debug_fragment(s8 *datap, u32 len, u32 limit)\n{\n    s32 *buffer;\n    u32 count;\n    u32 numargs;\n    u32 length;\n    u32 fraglen;\n\n    count = fraglen = 0;\n    buffer = (s32 *)datap;\n    length = (limit >> 2);\n\n    if (len <= limit) {\n        fraglen = len;\n    } else {\n        while (count < length) {\n            numargs = DBGLOG_GET_NUMARGS(buffer[count]);\n            fraglen = (count << 2);\n            count += numargs + 1;\n        }\n    }\n\n    return fraglen;\n}\n\nvoid\ndbglog_parse_debug_logs(s8 *datap, u32 len)\n{\n    s32 *buffer;\n    u32 count;\n    u32 timestamp;\n    u32 debugid;\n    u32 moduleid;\n    u32 numargs;\n    u32 length;\n\n    count = 0;\n    buffer = (s32 *)datap;\n    length = (len >> 2);\n    while (count < length) {\n        debugid = DBGLOG_GET_DBGID(buffer[count]);\n        moduleid = DBGLOG_GET_MODULEID(buffer[count]);\n        numargs = DBGLOG_GET_NUMARGS(buffer[count]);\n        timestamp = DBGLOG_GET_TIMESTAMP(buffer[count]);\n        switch (numargs) {\n            case 0:\n            AR_DEBUG_PRINTF(ATH_DEBUG_DBG_LOG,(\"%d %d (%d)\\n\", moduleid, debugid, timestamp));\n            break;\n\n            case 1:\n            AR_DEBUG_PRINTF(ATH_DEBUG_DBG_LOG,(\"%d %d (%d): 0x%x\\n\", moduleid, debugid,\n                            timestamp, buffer[count+1]));\n            break;\n\n            case 2:\n            AR_DEBUG_PRINTF(ATH_DEBUG_DBG_LOG,(\"%d %d (%d): 0x%x, 0x%x\\n\", moduleid, debugid,\n                            timestamp, buffer[count+1], buffer[count+2]));\n            break;\n\n            default:\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"Invalid args: %d\\n\", numargs));\n        }\n        count += numargs + 1;\n    }\n}\n\nint\nar6000_dbglog_get_debug_logs(struct ar6_softc *ar)\n{\n    u32 data[8]; /* Should be able to accommodate struct dbglog_buf_s */\n    u32 address;\n    u32 length;\n    u32 dropped;\n    u32 firstbuf;\n    u32 debug_hdr_ptr;\n\n    if (!ar->dbglog_init_done) return A_ERROR;\n\n\n    AR6000_SPIN_LOCK(&ar->arLock, 0);\n\n    if (ar->dbgLogFetchInProgress) {\n        AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n        return A_EBUSY;\n    }\n\n        /* block out others */\n    ar->dbgLogFetchInProgress = true;\n\n    AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n\n    debug_hdr_ptr = dbglog_get_debug_hdr_ptr(ar);\n    printk(\"debug_hdr_ptr: 0x%x\\n\", debug_hdr_ptr);\n\n    /* Get the contents of the ring buffer */\n    if (debug_hdr_ptr) {\n        address = TARG_VTOP(ar->arTargetType, debug_hdr_ptr);\n        length = 4 /* sizeof(dbuf) */ + 4 /* sizeof(dropped) */;\n        A_MEMZERO(data, sizeof(data));\n        ar6000_ReadDataDiag(ar->arHifDevice, address, (u8 *)data, length);\n        address = TARG_VTOP(ar->arTargetType, data[0] /* dbuf */);\n        firstbuf = address;\n        dropped = data[1]; /* dropped */\n        length = 4 /* sizeof(next) */ + 4 /* sizeof(buffer) */ + 4 /* sizeof(bufsize) */ + 4 /* sizeof(length) */ + 4 /* sizeof(count) */ + 4 /* sizeof(free) */;\n        A_MEMZERO(data, sizeof(data));\n        ar6000_ReadDataDiag(ar->arHifDevice, address, (u8 *)&data, length);\n\n        do {\n            address = TARG_VTOP(ar->arTargetType, data[1] /* buffer*/);\n            length = data[3]; /* length */\n            if ((length) && (length <= data[2] /* bufsize*/)) {\n                /* Rewind the index if it is about to overrun the buffer */\n                if (ar->log_cnt > (DBGLOG_HOST_LOG_BUFFER_SIZE - length)) {\n                    ar->log_cnt = 0;\n                }\n                if(0 != ar6000_ReadDataDiag(ar->arHifDevice, address,\n                                    (u8 *)&ar->log_buffer[ar->log_cnt], length))\n                {\n                    break;\n                }\n                ar6000_dbglog_event(ar, dropped, (s8 *)&ar->log_buffer[ar->log_cnt], length);\n                ar->log_cnt += length;\n            } else {\n                AR_DEBUG_PRINTF(ATH_DEBUG_DBG_LOG,(\"Length: %d (Total size: %d)\\n\",\n                                data[3], data[2]));\n            }\n\n            address = TARG_VTOP(ar->arTargetType, data[0] /* next */);\n            length = 4 /* sizeof(next) */ + 4 /* sizeof(buffer) */ + 4 /* sizeof(bufsize) */ + 4 /* sizeof(length) */ + 4 /* sizeof(count) */ + 4 /* sizeof(free) */;\n            A_MEMZERO(data, sizeof(data));\n            if(0 != ar6000_ReadDataDiag(ar->arHifDevice, address,\n                                (u8 *)&data, length))\n            {\n                break;\n            }\n\n        } while (address != firstbuf);\n    }\n\n    ar->dbgLogFetchInProgress = false;\n\n    return 0;\n}\n\nvoid\nar6000_dbglog_event(struct ar6_softc *ar, u32 dropped,\n                    s8 *buffer, u32 length)\n{\n#ifdef REPORT_DEBUG_LOGS_TO_APP\n    #define MAX_WIRELESS_EVENT_SIZE 252\n    /*\n     * Break it up into chunks of MAX_WIRELESS_EVENT_SIZE bytes of messages.\n     * There seems to be a limitation on the length of message that could be\n     * transmitted to the user app via this mechanism.\n     */\n    u32 send, sent;\n\n    sent = 0;\n    send = dbglog_get_debug_fragment(&buffer[sent], length - sent,\n                                     MAX_WIRELESS_EVENT_SIZE);\n    while (send) {\n        sent += send;\n        send = dbglog_get_debug_fragment(&buffer[sent], length - sent,\n                                         MAX_WIRELESS_EVENT_SIZE);\n    }\n#else\n    AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"Dropped logs: 0x%x\\nDebug info length: %d\\n\",\n                    dropped, length));\n\n    /* Interpret the debug logs */\n    dbglog_parse_debug_logs((s8 *)buffer, length);\n#endif /* REPORT_DEBUG_LOGS_TO_APP */\n}\n\n\nstatic int __init\nar6000_init_module(void)\n{\n    static int probed = 0;\n    int r;\n    OSDRV_CALLBACKS osdrvCallbacks;\n\n    a_module_debug_support_init();\n\n#ifdef DEBUG\n        /* check for debug mask overrides */\n    if (debughtc != 0) {\n        ATH_DEBUG_SET_DEBUG_MASK(htc,debughtc);\n    }\n    if (debugbmi != 0) {\n        ATH_DEBUG_SET_DEBUG_MASK(bmi,debugbmi);\n    }\n    if (debughif != 0) {\n        ATH_DEBUG_SET_DEBUG_MASK(hif,debughif);\n    }\n    if (debugdriver != 0) {\n        ATH_DEBUG_SET_DEBUG_MASK(driver,debugdriver);\n    }\n\n#endif\n\n    A_REGISTER_MODULE_DEBUG_INFO(driver);\n\n    A_MEMZERO(&osdrvCallbacks,sizeof(osdrvCallbacks));\n    osdrvCallbacks.deviceInsertedHandler = ar6000_avail_ev;\n    osdrvCallbacks.deviceRemovedHandler = ar6000_unavail_ev;\n#ifdef CONFIG_PM\n    osdrvCallbacks.deviceSuspendHandler = ar6000_suspend_ev;\n    osdrvCallbacks.deviceResumeHandler = ar6000_resume_ev;\n    osdrvCallbacks.devicePowerChangeHandler = ar6000_power_change_ev;\n#endif\n\n#ifdef DEBUG\n    /* Set the debug flags if specified at load time */\n    if(debugflags != 0)\n    {\n        g_dbg_flags = debugflags;\n    }\n#endif\n\n    if (probed) {\n        return -ENODEV;\n    }\n    probed++;\n\n#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL\n    memset(&aptcTR, 0, sizeof(APTC_TRAFFIC_RECORD));\n#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */\n\n    r = HIFInit(&osdrvCallbacks);\n    if (r)\n        return r;\n\n    return 0;\n}\n\nstatic void __exit\nar6000_cleanup_module(void)\n{\n    int i = 0;\n    struct net_device *ar6000_netdev;\n\n#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL\n    /* Delete the Adaptive Power Control timer */\n    if (timer_pending(&aptcTimer)) {\n        del_timer_sync(&aptcTimer);\n    }\n#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */\n\n    for (i=0; i < MAX_AR6000; i++) {\n        if (ar6000_devices[i] != NULL) {\n            ar6000_netdev = ar6000_devices[i];\n            ar6000_devices[i] = NULL;\n            ar6000_destroy(ar6000_netdev, 1);\n        }\n    }\n\n    HIFShutDownDevice(NULL);\n\n    a_module_debug_support_cleanup();\n\n    AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"ar6000_cleanup: success\\n\"));\n}\n\n#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL\nvoid\naptcTimerHandler(unsigned long arg)\n{\n    u32 numbytes;\n    u32 throughput;\n    struct ar6_softc *ar;\n    int status;\n\n    ar = (struct ar6_softc *)arg;\n    A_ASSERT(ar != NULL);\n    A_ASSERT(!timer_pending(&aptcTimer));\n\n    AR6000_SPIN_LOCK(&ar->arLock, 0);\n\n    /* Get the number of bytes transferred */\n    numbytes = aptcTR.bytesTransmitted + aptcTR.bytesReceived;\n    aptcTR.bytesTransmitted = aptcTR.bytesReceived = 0;\n\n    /* Calculate and decide based on throughput thresholds */\n    throughput = ((numbytes * 8)/APTC_TRAFFIC_SAMPLING_INTERVAL); /* Kbps */\n    if (throughput < APTC_LOWER_THROUGHPUT_THRESHOLD) {\n        /* Enable Sleep and delete the timer */\n        A_ASSERT(ar->arWmiReady == true);\n        AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n        status = wmi_powermode_cmd(ar->arWmi, REC_POWER);\n        AR6000_SPIN_LOCK(&ar->arLock, 0);\n        A_ASSERT(status == 0);\n        aptcTR.timerScheduled = false;\n    } else {\n        A_TIMEOUT_MS(&aptcTimer, APTC_TRAFFIC_SAMPLING_INTERVAL, 0);\n    }\n\n    AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n}\n#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */\n\nstatic void\nar6000_alloc_netbufs(A_NETBUF_QUEUE_T *q, u16 num)\n{\n    void * osbuf;\n\n    while(num) {\n        if((osbuf = A_NETBUF_ALLOC(AR6000_BUFFER_SIZE))) {\n            A_NETBUF_ENQUEUE(q, osbuf);\n        } else {\n            break;\n        }\n        num--;\n    }\n\n    if(num) {\n        A_PRINTF(\"%s(), allocation of netbuf failed\", __func__);\n    }\n}\n\nstatic struct bin_attribute bmi_attr = {\n    .attr = {.name = \"bmi\", .mode = 0600},\n    .read = ar6000_sysfs_bmi_read,\n    .write = ar6000_sysfs_bmi_write,\n};\n\nstatic ssize_t\nar6000_sysfs_bmi_read(struct file *fp, struct kobject *kobj,\n                      struct bin_attribute *bin_attr,\n                      char *buf, loff_t pos, size_t count)\n{\n    int index;\n    struct ar6_softc *ar;\n    struct hif_device_os_device_info   *osDevInfo;\n\n    AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"BMI: Read %d bytes\\n\", (u32)count));\n    for (index=0; index < MAX_AR6000; index++) {\n        ar = (struct ar6_softc *)ar6k_priv(ar6000_devices[index]);\n        osDevInfo = &ar->osDevInfo;\n        if (kobj == (&(((struct device *)osDevInfo->pOSDevice)->kobj))) {\n            break;\n        }\n    }\n\n    if (index == MAX_AR6000) return 0;\n\n    if ((BMIRawRead(ar->arHifDevice, (u8*)buf, count, true)) != 0) {\n        return 0;\n    }\n\n    return count;\n}\n\nstatic ssize_t\nar6000_sysfs_bmi_write(struct file *fp, struct kobject *kobj,\n                       struct bin_attribute *bin_attr,\n                       char *buf, loff_t pos, size_t count)\n{\n    int index;\n    struct ar6_softc *ar;\n    struct hif_device_os_device_info   *osDevInfo;\n\n    AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"BMI: Write %d bytes\\n\", (u32)count));\n    for (index=0; index < MAX_AR6000; index++) {\n        ar = (struct ar6_softc *)ar6k_priv(ar6000_devices[index]);\n        osDevInfo = &ar->osDevInfo;\n        if (kobj == (&(((struct device *)osDevInfo->pOSDevice)->kobj))) {\n            break;\n        }\n    }\n\n    if (index == MAX_AR6000) return 0;\n\n    if ((BMIRawWrite(ar->arHifDevice, (u8*)buf, count)) != 0) {\n        return 0;\n    }\n\n    return count;\n}\n\nstatic int\nar6000_sysfs_bmi_init(struct ar6_softc *ar)\n{\n    int status;\n\n    AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"BMI: Creating sysfs entry\\n\"));\n    A_MEMZERO(&ar->osDevInfo, sizeof(struct hif_device_os_device_info));\n\n    /* Get the underlying OS device */\n    status = HIFConfigureDevice(ar->arHifDevice,\n                                HIF_DEVICE_GET_OS_DEVICE,\n                                &ar->osDevInfo,\n                                sizeof(struct hif_device_os_device_info));\n\n    if (status) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"BMI: Failed to get OS device info from HIF\\n\"));\n        return A_ERROR;\n    }\n\n    /* Create a bmi entry in the sysfs filesystem */\n    if ((sysfs_create_bin_file(&(((struct device *)ar->osDevInfo.pOSDevice)->kobj), &bmi_attr)) < 0)\n    {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"BMI: Failed to create entry for bmi in sysfs filesystem\\n\"));\n        return A_ERROR;\n    }\n\n    return 0;\n}\n\nstatic void\nar6000_sysfs_bmi_deinit(struct ar6_softc *ar)\n{\n    AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"BMI: Deleting sysfs entry\\n\"));\n\n    sysfs_remove_bin_file(&(((struct device *)ar->osDevInfo.pOSDevice)->kobj), &bmi_attr);\n}\n\n#define bmifn(fn) do { \\\n    if ((fn) < 0) { \\\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"BMI operation failed: %d\\n\", __LINE__)); \\\n        return A_ERROR; \\\n    } \\\n} while(0)\n\n#ifdef SOFTMAC_FILE_USED\n#define AR6002_MAC_ADDRESS_OFFSET     0x0A\n#define AR6003_MAC_ADDRESS_OFFSET     0x16\nstatic\nvoid calculate_crc(u32 TargetType, u8 *eeprom_data)\n{\n    u16 *ptr_crc;\n    u16 *ptr16_eeprom;\n    u16 checksum;\n    u32 i;\n    u32 eeprom_size;\n\n    if (TargetType == TARGET_TYPE_AR6001)\n    {\n        eeprom_size = 512;\n        ptr_crc = (u16 *)eeprom_data;\n    }\n    else if (TargetType == TARGET_TYPE_AR6003)\n    {\n        eeprom_size = 1024;\n        ptr_crc = (u16 *)((u8 *)eeprom_data + 0x04);\n    }\n    else\n    {\n        eeprom_size = 768;\n        ptr_crc = (u16 *)((u8 *)eeprom_data + 0x04);\n    }\n\n\n    // Clear the crc\n    *ptr_crc = 0;\n\n    // Recalculate new CRC\n    checksum = 0;\n    ptr16_eeprom = (u16 *)eeprom_data;\n    for (i = 0;i < eeprom_size; i += 2)\n    {\n        checksum = checksum ^ (*ptr16_eeprom);\n        ptr16_eeprom++;\n    }\n    checksum = 0xFFFF ^ checksum;\n    *ptr_crc = checksum;\n}\n\nstatic void \nar6000_softmac_update(struct ar6_softc *ar, u8 *eeprom_data, size_t size)\n{\n    const char *source = \"random generated\";\n    const struct firmware *softmac_entry;\n    u8 *ptr_mac;\n    switch (ar->arTargetType) {\n    case TARGET_TYPE_AR6002:\n        ptr_mac = (u8 *)((u8 *)eeprom_data + AR6002_MAC_ADDRESS_OFFSET);\n        break;\n    case TARGET_TYPE_AR6003:\n        ptr_mac = (u8 *)((u8 *)eeprom_data + AR6003_MAC_ADDRESS_OFFSET);\n        break;\n    default:\n\tAR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"Invalid Target Type\\n\"));\n        return;\n    }\n\tprintk(KERN_DEBUG \"MAC from EEPROM %pM\\n\", ptr_mac);\n\n    /* create a random MAC in case we cannot read file from system */\n    ptr_mac[0] = 0;\n    ptr_mac[1] = 0x03;\n    ptr_mac[2] = 0x7F;\n    ptr_mac[3] = random32() & 0xff; \n    ptr_mac[4] = random32() & 0xff; \n    ptr_mac[5] = random32() & 0xff; \n    if ((A_REQUEST_FIRMWARE(&softmac_entry, \"softmac\", ((struct device *)ar->osDevInfo.pOSDevice))) == 0)\n    {\n        char *macbuf = A_MALLOC_NOWAIT(softmac_entry->size+1);\n        if (macbuf) {            \n            unsigned int softmac[6];\n            memcpy(macbuf, softmac_entry->data, softmac_entry->size);\n            macbuf[softmac_entry->size] = '\\0';\n            if (sscanf(macbuf, \"%02x:%02x:%02x:%02x:%02x:%02x\", \n                        &softmac[0], &softmac[1], &softmac[2],\n                        &softmac[3], &softmac[4], &softmac[5])==6) {\n                int i;\n                for (i=0; i<6; ++i) {\n                    ptr_mac[i] = softmac[i] & 0xff;\n                }\n                source = \"softmac file\";\n            }\n            kfree(macbuf);\n        }\n        A_RELEASE_FIRMWARE(softmac_entry);\n    }\n\tprintk(KERN_DEBUG \"MAC from %s %pM\\n\", source, ptr_mac);\n   calculate_crc(ar->arTargetType, eeprom_data);\n}\n#endif /* SOFTMAC_FILE_USED */\n\nstatic int\nar6000_transfer_bin_file(struct ar6_softc *ar, AR6K_BIN_FILE file, u32 address, bool compressed)\n{\n    int status;\n    const char *filename;\n    const struct firmware *fw_entry;\n    u32 fw_entry_size;\n\n    switch (file) {\n        case AR6K_OTP_FILE:\n            if (ar->arVersion.target_ver == AR6003_REV1_VERSION) {\n                filename = AR6003_REV1_OTP_FILE;\n            } else if (ar->arVersion.target_ver == AR6003_REV2_VERSION) {\n                filename = AR6003_REV2_OTP_FILE;\n                } else if (ar->arVersion.target_ver == AR6003_REV3_VERSION) {\n                        filename = AR6003_REV3_OTP_FILE;\n            } else {\n                AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"Unknown firmware revision: %d\\n\", ar->arVersion.target_ver));\n                return A_ERROR;\n            }\n            break;\n\n        case AR6K_FIRMWARE_FILE:\n            if (ar->arVersion.target_ver == AR6003_REV1_VERSION) {\n                filename = AR6003_REV1_FIRMWARE_FILE;\n            } else if (ar->arVersion.target_ver == AR6003_REV2_VERSION) {\n                filename = AR6003_REV2_FIRMWARE_FILE;\n                } else if (ar->arVersion.target_ver == AR6003_REV3_VERSION) {\n                        filename = AR6003_REV3_FIRMWARE_FILE;\n            } else {\n                AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"Unknown firmware revision: %d\\n\", ar->arVersion.target_ver));\n                return A_ERROR;\n            }\n            \n            if (eppingtest) {\n                bypasswmi = true;\n                if (ar->arVersion.target_ver == AR6003_REV1_VERSION) {\n                    filename = AR6003_REV1_EPPING_FIRMWARE_FILE;\n                } else if (ar->arVersion.target_ver == AR6003_REV2_VERSION) {\n                    filename = AR6003_REV2_EPPING_FIRMWARE_FILE;\n                } else if (ar->arVersion.target_ver == AR6003_REV3_VERSION) {\n                        filename = AR6003_REV3_EPPING_FIRMWARE_FILE;\n                } else {\n                    AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"eppingtest : unsupported firmware revision: %d\\n\", \n                        ar->arVersion.target_ver));\n                    return A_ERROR;\n                }\n                compressed = false;\n            }\n            \n#ifdef CONFIG_HOST_TCMD_SUPPORT\n            if(testmode) {\n                if (ar->arVersion.target_ver == AR6003_REV1_VERSION) {\n                    filename = AR6003_REV1_TCMD_FIRMWARE_FILE;\n                } else if (ar->arVersion.target_ver == AR6003_REV2_VERSION) {\n                    filename = AR6003_REV2_TCMD_FIRMWARE_FILE;\n                } else if (ar->arVersion.target_ver == AR6003_REV3_VERSION) {\n                        filename = AR6003_REV3_TCMD_FIRMWARE_FILE;\n                } else {\n                    AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"Unknown firmware revision: %d\\n\", ar->arVersion.target_ver));\n                    return A_ERROR;\n                }\n                compressed = false;\n            }\n#endif \n#ifdef HTC_RAW_INTERFACE\n            if (!eppingtest && bypasswmi) {\n                if (ar->arVersion.target_ver == AR6003_REV1_VERSION) {\n                    filename = AR6003_REV1_ART_FIRMWARE_FILE;\n                } else if (ar->arVersion.target_ver == AR6003_REV2_VERSION) {\n                    filename = AR6003_REV2_ART_FIRMWARE_FILE;\n                } else {\n                    AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"Unknown firmware revision: %d\\n\", ar->arVersion.target_ver));\n                    return A_ERROR;\n                }\n                compressed = false;\n            }\n#endif \n            break;\n\n        case AR6K_PATCH_FILE:\n            if (ar->arVersion.target_ver == AR6003_REV1_VERSION) {\n                filename = AR6003_REV1_PATCH_FILE;\n            } else if (ar->arVersion.target_ver == AR6003_REV2_VERSION) {\n                filename = AR6003_REV2_PATCH_FILE;\n                } else if (ar->arVersion.target_ver == AR6003_REV3_VERSION) {\n                        filename = AR6003_REV3_PATCH_FILE;\n            } else {\n                AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"Unknown firmware revision: %d\\n\", ar->arVersion.target_ver));\n                return A_ERROR;\n            }\n            break;\n\n        case AR6K_BOARD_DATA_FILE:\n            if (ar->arVersion.target_ver == AR6003_REV1_VERSION) {\n                filename = AR6003_REV1_BOARD_DATA_FILE;\n            } else if (ar->arVersion.target_ver == AR6003_REV2_VERSION) {\n                filename = AR6003_REV2_BOARD_DATA_FILE;\n                } else if (ar->arVersion.target_ver == AR6003_REV3_VERSION) {\n                        filename = AR6003_REV3_BOARD_DATA_FILE;\n            } else {\n                AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"Unknown firmware revision: %d\\n\", ar->arVersion.target_ver));\n                return A_ERROR;\n            }\n            break;\n\n        default:\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"Unknown file type: %d\\n\", file));\n            return A_ERROR;\n    }\n    if ((A_REQUEST_FIRMWARE(&fw_entry, filename, ((struct device *)ar->osDevInfo.pOSDevice))) != 0)\n    {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"Failed to get %s\\n\", filename));\n        return A_ENOENT;\n    }\n\n#ifdef SOFTMAC_FILE_USED\n    if (file==AR6K_BOARD_DATA_FILE && fw_entry->data) {\n        ar6000_softmac_update(ar, (u8 *)fw_entry->data, fw_entry->size);\n    }\n#endif \n\n\n    fw_entry_size = fw_entry->size;\n\n    /* Load extended board data for AR6003 */\n    if ((file==AR6K_BOARD_DATA_FILE) && (fw_entry->data)) {\n        u32 board_ext_address;\n        u32 board_ext_data_size;\n        u32 board_data_size;\n\n        board_ext_data_size = (((ar)->arTargetType == TARGET_TYPE_AR6002) ? AR6002_BOARD_EXT_DATA_SZ : \\\n                               (((ar)->arTargetType == TARGET_TYPE_AR6003) ? AR6003_BOARD_EXT_DATA_SZ : 0));\n\n        board_data_size = (((ar)->arTargetType == TARGET_TYPE_AR6002) ? AR6002_BOARD_DATA_SZ : \\\n                          (((ar)->arTargetType == TARGET_TYPE_AR6003) ? AR6003_BOARD_DATA_SZ : 0));\n        \n        /* Determine where in Target RAM to write Board Data */\n        bmifn(BMIReadMemory(ar->arHifDevice, HOST_INTEREST_ITEM_ADDRESS(ar, hi_board_ext_data), (u8 *)&board_ext_address, 4));\n        AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\"Board extended Data download address: 0x%x\\n\", board_ext_address));\n\n        /* check whether the target has allocated memory for extended board data and file contains extended board data */\n        if ((board_ext_address) && (fw_entry->size == (board_data_size + board_ext_data_size))) {\n            u32 param;\n\n            status = BMIWriteMemory(ar->arHifDevice, board_ext_address, (u8 *)(fw_entry->data + board_data_size), board_ext_data_size);\n\n            if (status) {\n                AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"BMI operation failed: %d\\n\", __LINE__));\n                A_RELEASE_FIRMWARE(fw_entry);\n                return A_ERROR;\n            }\n\n            /* Record the fact that extended board Data IS initialized */\n            param = (board_ext_data_size << 16) | 1;\n            bmifn(BMIWriteMemory(ar->arHifDevice,\n            HOST_INTEREST_ITEM_ADDRESS(ar, hi_board_ext_data_config),\n\t\t\t\t       (unsigned char *)&param, 4));\n        }\n        fw_entry_size = board_data_size;\n    }\n\n    if (compressed) {\n        status = BMIFastDownload(ar->arHifDevice, address, (u8 *)fw_entry->data, fw_entry_size);\n    } else {\n        status = BMIWriteMemory(ar->arHifDevice, address, (u8 *)fw_entry->data, fw_entry_size);\n    }\n\n    if (status) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"BMI operation failed: %d\\n\", __LINE__));\n        A_RELEASE_FIRMWARE(fw_entry);\n        return A_ERROR;\n    }\n    A_RELEASE_FIRMWARE(fw_entry);\n    return 0;\n}\n\nint\nar6000_update_bdaddr(struct ar6_softc *ar)\n{\n\n        if (setupbtdev != 0) {\n            u32 address;\n\n           if (BMIReadMemory(ar->arHifDevice,\n\t\tHOST_INTEREST_ITEM_ADDRESS(ar, hi_board_data), (u8 *)&address, 4) != 0)\n           {\n    \t      \tAR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"BMIReadMemory for hi_board_data failed\\n\"));\n           \treturn A_ERROR;\n           }\n\n           if (BMIReadMemory(ar->arHifDevice, address + BDATA_BDADDR_OFFSET, (u8 *)ar->bdaddr, 6) != 0)\n           {\n    \t    \tAR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"BMIReadMemory for BD address failed\\n\"));\n           \treturn A_ERROR;\n           }\n\t   AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"BDADDR 0x%x:0x%x:0x%x:0x%x:0x%x:0x%x\\n\", ar->bdaddr[0],\n\t\t\t\t\t\t\t\tar->bdaddr[1], ar->bdaddr[2], ar->bdaddr[3],\n\t\t\t\t\t\t\t\tar->bdaddr[4], ar->bdaddr[5]));\n        }\n\nreturn 0;\n}\n\nint\nar6000_sysfs_bmi_get_config(struct ar6_softc *ar, u32 mode)\n{\n    AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"BMI: Requesting device specific configuration\\n\"));\n\n    if (mode == WLAN_INIT_MODE_UDEV) {\n        char version[16];\n        const struct firmware *fw_entry;\n\n        /* Get config using udev through a script in user space */\n        sprintf(version, \"%2.2x\", ar->arVersion.target_ver);\n        if ((A_REQUEST_FIRMWARE(&fw_entry, version, ((struct device *)ar->osDevInfo.pOSDevice))) != 0)\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"BMI: Failure to get configuration for target version: %s\\n\", version));\n            return A_ERROR;\n        }\n\n        A_RELEASE_FIRMWARE(fw_entry);\n    } else {\n        /* The config is contained within the driver itself */\n        int status;\n        u32 param, options, sleep, address;\n\n        /* Temporarily disable system sleep */\n        address = MBOX_BASE_ADDRESS + LOCAL_SCRATCH_ADDRESS;\n        bmifn(BMIReadSOCRegister(ar->arHifDevice, address, &param));\n        options = param;\n        param |= AR6K_OPTION_SLEEP_DISABLE;\n        bmifn(BMIWriteSOCRegister(ar->arHifDevice, address, param));\n\n        address = RTC_BASE_ADDRESS + SYSTEM_SLEEP_ADDRESS;\n        bmifn(BMIReadSOCRegister(ar->arHifDevice, address, &param));\n        sleep = param;\n        param |= WLAN_SYSTEM_SLEEP_DISABLE_SET(1);\n        bmifn(BMIWriteSOCRegister(ar->arHifDevice, address, param));\n        AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\"old options: %d, old sleep: %d\\n\", options, sleep));\n\n        if (ar->arTargetType == TARGET_TYPE_AR6003) {\n            /* Program analog PLL register */\n            bmifn(BMIWriteSOCRegister(ar->arHifDevice, ANALOG_INTF_BASE_ADDRESS + 0x284, 0xF9104001));\n            /* Run at 80/88MHz by default */\n            param = CPU_CLOCK_STANDARD_SET(1);\n        } else {\n            /* Run at 40/44MHz by default */\n            param = CPU_CLOCK_STANDARD_SET(0);\n        }\n        address = RTC_BASE_ADDRESS + CPU_CLOCK_ADDRESS;\n        bmifn(BMIWriteSOCRegister(ar->arHifDevice, address, param));\n\n        param = 0;\n        if (ar->arTargetType == TARGET_TYPE_AR6002) {\n            bmifn(BMIReadMemory(ar->arHifDevice, HOST_INTEREST_ITEM_ADDRESS(ar, hi_ext_clk_detected), (u8 *)&param, 4));\n        }\n\n        /* LPO_CAL.ENABLE = 1 if no external clk is detected */\n        if (param != 1) {\n            address = RTC_BASE_ADDRESS + LPO_CAL_ADDRESS;\n            param = LPO_CAL_ENABLE_SET(1);\n            bmifn(BMIWriteSOCRegister(ar->arHifDevice, address, param));\n        }\n\n        /* Venus2.0: Lower SDIO pad drive strength,\n         * temporary WAR to avoid SDIO CRC error */\n        if (ar->arVersion.target_ver == AR6003_REV2_VERSION) {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"AR6K: Temporary WAR to avoid SDIO CRC error\\n\"));\n            param = 0x20;\n            address = GPIO_BASE_ADDRESS + GPIO_PIN10_ADDRESS;\n            bmifn(BMIWriteSOCRegister(ar->arHifDevice, address, param));\n\n            address = GPIO_BASE_ADDRESS + GPIO_PIN11_ADDRESS;\n            bmifn(BMIWriteSOCRegister(ar->arHifDevice, address, param));\n\n            address = GPIO_BASE_ADDRESS + GPIO_PIN12_ADDRESS;\n            bmifn(BMIWriteSOCRegister(ar->arHifDevice, address, param));\n\n            address = GPIO_BASE_ADDRESS + GPIO_PIN13_ADDRESS;\n            bmifn(BMIWriteSOCRegister(ar->arHifDevice, address, param));\n        }\n\n#ifdef FORCE_INTERNAL_CLOCK\n        /* Ignore external clock, if any, and force use of internal clock */\n        if (ar->arTargetType == TARGET_TYPE_AR6003) {\n            /* hi_ext_clk_detected = 0 */\n            param = 0;\n            bmifn(BMIWriteMemory(ar->arHifDevice, HOST_INTEREST_ITEM_ADDRESS(ar, hi_ext_clk_detected), (u8 *)&param, 4));\n\n            /* CLOCK_CONTROL &= ~LF_CLK32 */\n            address = RTC_BASE_ADDRESS + CLOCK_CONTROL_ADDRESS;\n            bmifn(BMIReadSOCRegister(ar->arHifDevice, address, &param));\n            param &= (~CLOCK_CONTROL_LF_CLK32_SET(1));\n            bmifn(BMIWriteSOCRegister(ar->arHifDevice, address, param));\n        }\n#endif /* FORCE_INTERNAL_CLOCK */\n\n        /* Transfer Board Data from Target EEPROM to Target RAM */\n        if (ar->arTargetType == TARGET_TYPE_AR6003) {\n            /* Determine where in Target RAM to write Board Data */\n            bmifn(BMIReadMemory(ar->arHifDevice, HOST_INTEREST_ITEM_ADDRESS(ar, hi_board_data), (u8 *)&address, 4));\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\"Board Data download address: 0x%x\\n\", address));\n\n            /* Write EEPROM data to Target RAM */\n            if ((ar6000_transfer_bin_file(ar, AR6K_BOARD_DATA_FILE, address, false)) != 0) {\n                return A_ERROR;\n            }\n\n            /* Record the fact that Board Data IS initialized */\n            param = 1;\n            bmifn(BMIWriteMemory(ar->arHifDevice, HOST_INTEREST_ITEM_ADDRESS(ar, hi_board_data_initialized), (u8 *)&param, 4));\n\n            /* Transfer One time Programmable data */\n\t    AR6K_APP_LOAD_ADDRESS(address, ar->arVersion.target_ver);\n\t    if (ar->arVersion.target_ver == AR6003_REV3_VERSION)\n\t\t  address = 0x1234;\n            status = ar6000_transfer_bin_file(ar, AR6K_OTP_FILE, address, true);\n            if (status == 0) {\n                /* Execute the OTP code */\n                param = 0;\n                AR6K_APP_START_OVERRIDE_ADDRESS(address, ar->arVersion.target_ver);\n                bmifn(BMIExecute(ar->arHifDevice, address, &param));\n            } else if (status != A_ENOENT) {\n                return A_ERROR;\n            } \n        } else {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"Programming of board data for chip %d not supported\\n\", ar->arTargetType));\n            return A_ERROR;\n        }\n\n        /* Download Target firmware */\n        AR6K_APP_LOAD_ADDRESS(address, ar->arVersion.target_ver);\n        if (ar->arVersion.target_ver == AR6003_REV3_VERSION)\n                address = 0x1234;\n        if ((ar6000_transfer_bin_file(ar, AR6K_FIRMWARE_FILE, address, true)) != 0) {\n            return A_ERROR;\n        }\n\n        /* Set starting address for firmware */\n        AR6K_APP_START_OVERRIDE_ADDRESS(address, ar->arVersion.target_ver);\n        bmifn(BMISetAppStart(ar->arHifDevice, address));\n\n\tif(ar->arTargetType == TARGET_TYPE_AR6003) {\n\t\tAR6K_DATASET_PATCH_ADDRESS(address, ar->arVersion.target_ver);\n\t\tif ((ar6000_transfer_bin_file(ar, AR6K_PATCH_FILE,\n\t\t\t\t\t      address, false)) != 0)\n\t\t\treturn A_ERROR;\n\t\tparam = address;\n\t\tbmifn(BMIWriteMemory(ar->arHifDevice,\n\t\tHOST_INTEREST_ITEM_ADDRESS(ar, hi_dset_list_head),\n\t\t\t\t\t   (unsigned char *)&param, 4));\n\t}\n\n        /* Restore system sleep */\n        address = RTC_BASE_ADDRESS + SYSTEM_SLEEP_ADDRESS;\n        bmifn(BMIWriteSOCRegister(ar->arHifDevice, address, sleep));\n\n        address = MBOX_BASE_ADDRESS + LOCAL_SCRATCH_ADDRESS;\n        param = options | 0x20;\n        bmifn(BMIWriteSOCRegister(ar->arHifDevice, address, param));\n\n        if (ar->arTargetType == TARGET_TYPE_AR6003) {\n            /* Configure GPIO AR6003 UART */\n#ifndef CONFIG_AR600x_DEBUG_UART_TX_PIN\n#define CONFIG_AR600x_DEBUG_UART_TX_PIN 8\n#endif\n            param = CONFIG_AR600x_DEBUG_UART_TX_PIN;\n            bmifn(BMIWriteMemory(ar->arHifDevice, HOST_INTEREST_ITEM_ADDRESS(ar, hi_dbg_uart_txpin), (u8 *)&param, 4));\n\n#if (CONFIG_AR600x_DEBUG_UART_TX_PIN == 23)\n            {\n                address = GPIO_BASE_ADDRESS + CLOCK_GPIO_ADDRESS;\n                bmifn(BMIReadSOCRegister(ar->arHifDevice, address, &param));\n                param |= CLOCK_GPIO_BT_CLK_OUT_EN_SET(1);\n                bmifn(BMIWriteSOCRegister(ar->arHifDevice, address, param));\n            }\n#endif\n\n            /* Configure GPIO for BT Reset */\n#ifdef ATH6KL_CONFIG_GPIO_BT_RESET\n#define CONFIG_AR600x_BT_RESET_PIN\t0x16\n            param = CONFIG_AR600x_BT_RESET_PIN;\n            bmifn(BMIWriteMemory(ar->arHifDevice, HOST_INTEREST_ITEM_ADDRESS(ar, hi_hci_uart_support_pins), (u8 *)&param, 4));\n#endif /* ATH6KL_CONFIG_GPIO_BT_RESET */\n\n            /* Configure UART flow control polarity */\n#ifndef CONFIG_ATH6KL_BT_UART_FC_POLARITY\n#define CONFIG_ATH6KL_BT_UART_FC_POLARITY 0\n#endif\n\n#if (CONFIG_ATH6KL_BT_UART_FC_POLARITY == 1)\n            if (ar->arVersion.target_ver == AR6003_REV2_VERSION) {\n                param = ((CONFIG_ATH6KL_BT_UART_FC_POLARITY << 1) & 0x2);\n                bmifn(BMIWriteMemory(ar->arHifDevice, HOST_INTEREST_ITEM_ADDRESS(ar, hi_hci_uart_pwr_mgmt_params), (u8 *)&param, 4));\n            }\n#endif /* CONFIG_ATH6KL_BT_UART_FC_POLARITY */\n        }\n\n#ifdef HTC_RAW_INTERFACE\n        if (!eppingtest && bypasswmi) {\n            /* Don't run BMIDone for ART mode and force resetok=0 */\n            resetok = 0;\n            msleep(1000);\n        }\n#endif /* HTC_RAW_INTERFACE */\n    }\n\n    return 0;\n}\n\nint\nar6000_configure_target(struct ar6_softc *ar)\n{\n    u32 param;\n    if (enableuartprint) {\n        param = 1;\n        if (BMIWriteMemory(ar->arHifDevice,\n                           HOST_INTEREST_ITEM_ADDRESS(ar, hi_serial_enable),\n                           (u8 *)&param,\n                           4)!= 0)\n        {\n             AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"BMIWriteMemory for enableuartprint failed \\n\"));\n             return A_ERROR;\n        }\n        AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"Serial console prints enabled\\n\"));\n    }\n\n    /* Tell target which HTC version it is used*/\n    param = HTC_PROTOCOL_VERSION;\n    if (BMIWriteMemory(ar->arHifDevice,\n                       HOST_INTEREST_ITEM_ADDRESS(ar, hi_app_host_interest),\n                       (u8 *)&param,\n                       4)!= 0)\n    {\n         AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"BMIWriteMemory for htc version failed \\n\"));\n         return A_ERROR;\n    }\n\n#ifdef CONFIG_HOST_TCMD_SUPPORT\n    if(testmode) {\n        ar->arTargetMode = AR6000_TCMD_MODE;\n    }else {\n        ar->arTargetMode = AR6000_WLAN_MODE;\n    }\n#endif\n    if (enabletimerwar) {\n        u32 param;\n\n        if (BMIReadMemory(ar->arHifDevice,\n            HOST_INTEREST_ITEM_ADDRESS(ar, hi_option_flag),\n            (u8 *)&param,\n            4)!= 0)\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"BMIReadMemory for enabletimerwar failed \\n\"));\n            return A_ERROR;\n        }\n\n        param |= HI_OPTION_TIMER_WAR;\n\n        if (BMIWriteMemory(ar->arHifDevice,\n            HOST_INTEREST_ITEM_ADDRESS(ar, hi_option_flag),\n            (u8 *)&param,\n            4) != 0)\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"BMIWriteMemory for enabletimerwar failed \\n\"));\n            return A_ERROR;\n        }\n        AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"Timer WAR enabled\\n\"));\n    }\n\n    /* set the firmware mode to STA/IBSS/AP */\n    {\n        u32 param;\n\n        if (BMIReadMemory(ar->arHifDevice,\n            HOST_INTEREST_ITEM_ADDRESS(ar, hi_option_flag),\n            (u8 *)&param,\n            4)!= 0)\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"BMIReadMemory for setting fwmode failed \\n\"));\n            return A_ERROR;\n        }\n\n        param |= (num_device << HI_OPTION_NUM_DEV_SHIFT);\n        param |= (fwmode << HI_OPTION_FW_MODE_SHIFT);\n        param |= (mac_addr_method << HI_OPTION_MAC_ADDR_METHOD_SHIFT);\n        param |= (firmware_bridge << HI_OPTION_FW_BRIDGE_SHIFT);\n\n\n        if (BMIWriteMemory(ar->arHifDevice,\n            HOST_INTEREST_ITEM_ADDRESS(ar, hi_option_flag),\n            (u8 *)&param,\n            4) != 0)\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"BMIWriteMemory for setting fwmode failed \\n\"));\n            return A_ERROR;\n        }\n        AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"Firmware mode set\\n\"));\n    }\n\n#ifdef ATH6KL_DISABLE_TARGET_DBGLOGS\n    {\n        u32 param;\n\n        if (BMIReadMemory(ar->arHifDevice,\n            HOST_INTEREST_ITEM_ADDRESS(ar, hi_option_flag),\n            (u8 *)&param,\n            4)!= 0)\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"BMIReadMemory for disabling debug logs failed\\n\"));\n            return A_ERROR;\n        }\n\n        param |= HI_OPTION_DISABLE_DBGLOG;\n\n        if (BMIWriteMemory(ar->arHifDevice,\n            HOST_INTEREST_ITEM_ADDRESS(ar, hi_option_flag),\n            (u8 *)&param,\n            4) != 0)\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"BMIWriteMemory for HI_OPTION_DISABLE_DBGLOG\\n\"));\n            return A_ERROR;\n        }\n        AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"Firmware mode set\\n\"));\n    }\n#endif /* ATH6KL_DISABLE_TARGET_DBGLOGS */\n\n    /* \n     * Hardcode the address use for the extended board data \n     * Ideally this should be pre-allocate by the OS at boot time\n     * But since it is a new feature and board data is loaded \n     * at init time, we have to workaround this from host.\n     * It is difficult to patch the firmware boot code,\n     * but possible in theory.\n     */\n\n\tif (ar->arTargetType == TARGET_TYPE_AR6003) {\n\t\tu32 ramReservedSz;\n\t\tif (ar->arVersion.target_ver == AR6003_REV2_VERSION) {\n\t\t\tparam = AR6003_REV2_BOARD_EXT_DATA_ADDRESS;\n\t\t\tramReservedSz =  AR6003_REV2_RAM_RESERVE_SIZE;\n                } else {\n\t\t\tparam = AR6003_REV3_BOARD_EXT_DATA_ADDRESS;\n\t\t\tramReservedSz =  AR6003_REV3_RAM_RESERVE_SIZE;\n\t\t}\n\t\tif (BMIWriteMemory(ar->arHifDevice,\n\t\t\tHOST_INTEREST_ITEM_ADDRESS(ar, hi_board_ext_data),\n\t\t\t\t\t\t   (u8 *)&param, 4) != 0) {\n\t\t\t\tAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\n\t\t\t\t\t\t(\"BMIWriteMemory for \"\n\t\t\t\t\t\t \"hi_board_ext_data failed\\n\"));\n\t\t\t\treturn A_ERROR;\n\t\t}\n\t\tif (BMIWriteMemory(ar->arHifDevice,\n\t\t\t\t   HOST_INTEREST_ITEM_ADDRESS(ar,\n\t\t\t\t   hi_end_RAM_reserve_sz),\n\t\t\t\t   (u8 *)&ramReservedSz, 4) != 0) {\n\t\t\tAR_DEBUG_PRINTF(ATH_DEBUG_ERR ,\n\t\t\t\t\t(\"BMIWriteMemory for \"\n\t\t\t\t\t \"hi_end_RAM_reserve_sz failed\\n\"));\n\t\t\treturn A_ERROR;\n\t\t}\n\t}\n\n        /* since BMIInit is called in the driver layer, we have to set the block\n         * size here for the target */\n\n    if (ar6000_set_htc_params(ar->arHifDevice, ar->arTargetType,\n\t\t\t      mbox_yield_limit, 0)) {\n\t\t\t\t/* use default number of control buffers */\n        return A_ERROR;\n    }\n\n    if (setupbtdev != 0) {\n        if (ar6000_set_hci_bridge_flags(ar->arHifDevice,\n\t\t\t\t\tar->arTargetType,\n\t\t\t\t\tsetupbtdev)) {\n            return A_ERROR;\n        }\n    }\n    return 0;\n}\n\nstatic void\ninit_netdev(struct net_device *dev, char *name)\n{\n    dev->netdev_ops = &ar6000_netdev_ops;\n    dev->watchdog_timeo = AR6000_TX_TIMEOUT;\n\n   /*\n    * We need the OS to provide us with more headroom in order to\n    * perform dix to 802.3, WMI header encap, and the HTC header\n    */\n    if (processDot11Hdr) {\n        dev->hard_header_len = sizeof(struct ieee80211_qosframe) + sizeof(ATH_LLC_SNAP_HDR) + sizeof(WMI_DATA_HDR) + HTC_HEADER_LEN + WMI_MAX_TX_META_SZ + LINUX_HACK_FUDGE_FACTOR;\n    } else {\n        dev->hard_header_len = ETH_HLEN + sizeof(ATH_LLC_SNAP_HDR) +\n            sizeof(WMI_DATA_HDR) + HTC_HEADER_LEN + WMI_MAX_TX_META_SZ + LINUX_HACK_FUDGE_FACTOR;\n    }\n\n    if (name[0])\n    {\n        strcpy(dev->name, name);\n    }\n\n#ifdef CONFIG_CHECKSUM_OFFLOAD\n    if(csumOffload){\n        dev->features |= NETIF_F_IP_CSUM; /*advertise kernel capability to do TCP/UDP CSUM offload for IPV4*/\n    }\n#endif\n\n    return;\n}\n\nstatic int __ath6kl_init_netdev(struct net_device *dev)\n{\n\tint r;\n\n\trtnl_lock();\n\tr = ar6000_init(dev);\n\trtnl_unlock();\n\n\tif (r) {\n\t\tAR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_avail: ar6000_init\\n\"));\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\n#ifdef HTC_RAW_INTERFACE\nstatic int ath6kl_init_netdev_wmi(struct net_device *dev)\n{\n\tif (!eppingtest && bypasswmi)\n\t\treturn 0;\n\n\treturn __ath6kl_init_netdev(dev);\n}\n#else\nstatic int ath6kl_init_netdev_wmi(struct net_device *dev)\n{\n\treturn __ath6kl_init_netdev(dev);\n}\n#endif\n\nstatic int ath6kl_init_netdev(struct ar6_softc *ar)\n{\n\tint r;\n\n        r = ar6000_sysfs_bmi_get_config(ar, wlaninitmode);\n        if (r) {\n\t\tAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\n\t\t\t\t(\"ar6000_avail: \"\n\t\t\t\t \"ar6000_sysfs_bmi_get_config failed\\n\"));\n\t\treturn r;\n        }\n\n\treturn ath6kl_init_netdev_wmi(ar->arNetDev);\n}\n\n/*\n * HTC Event handlers\n */\nstatic int\nar6000_avail_ev(void *context, void *hif_handle)\n{\n    int i;\n    struct net_device *dev;\n    void *ar_netif;\n    struct ar6_softc *ar;\n    int device_index = 0;\n    struct htc_init_info  htcInfo;\n    struct wireless_dev *wdev;\n    int r = 0;\n    struct hif_device_os_device_info osDevInfo;\n\n    memset(&osDevInfo, 0, sizeof(osDevInfo));\n    if (HIFConfigureDevice(hif_handle, HIF_DEVICE_GET_OS_DEVICE,\n        &osDevInfo, sizeof(osDevInfo))) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"%s: Failed to get OS device instance\\n\", __func__));\n        return A_ERROR;\n    }\n\n    AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"ar6000_available\\n\"));\n\n    for (i=0; i < MAX_AR6000; i++) {\n        if (ar6000_devices[i] == NULL) {\n            break;\n        }\n    }\n\n    if (i == MAX_AR6000) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_available: max devices reached\\n\"));\n        return A_ERROR;\n    }\n\n    /* Save this. It gives a bit better readability especially since */\n    /* we use another local \"i\" variable below.                      */\n    device_index = i;\n\n    wdev = ar6k_cfg80211_init(osDevInfo.pOSDevice);\n    if (IS_ERR(wdev)) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"%s: ar6k_cfg80211_init failed\\n\", __func__));\n        return A_ERROR;\n    }\n    ar_netif = wdev_priv(wdev);\n\n    if (ar_netif == NULL) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"%s: Can't allocate ar6k priv memory\\n\", __func__));\n        return A_ERROR;\n    }\n\n    A_MEMZERO(ar_netif, sizeof(struct ar6_softc));\n    ar = (struct ar6_softc *)ar_netif;\n\n    ar->wdev = wdev;\n    wdev->iftype = NL80211_IFTYPE_STATION;\n\n    dev = alloc_netdev_mq(0, \"wlan%d\", ether_setup, 1);\n    if (!dev) {\n        printk(KERN_CRIT \"AR6K: no memory for network device instance\\n\");\n        ar6k_cfg80211_deinit(ar);\n        return A_ERROR;\n    }\n\n    dev->ieee80211_ptr = wdev;\n    SET_NETDEV_DEV(dev, wiphy_dev(wdev->wiphy));\n    wdev->netdev = dev;\n    ar->arNetworkType = INFRA_NETWORK;\n    ar->smeState = SME_DISCONNECTED;\n    ar->arAutoAuthStage = AUTH_IDLE;\n\n    init_netdev(dev, ifname);\n\n\n    ar->arNetDev             = dev;\n    ar->arHifDevice          = hif_handle;\n    ar->arWlanState          = WLAN_ENABLED;\n    ar->arDeviceIndex        = device_index;\n\n    ar->arWlanPowerState     = WLAN_POWER_STATE_ON;\n    ar->arWlanOff            = false;   /* We are in ON state */\n#ifdef CONFIG_PM\n    ar->arWowState           = WLAN_WOW_STATE_NONE;\n    ar->arBTOff              = true;   /* BT chip assumed to be OFF */\n    ar->arBTSharing          = WLAN_CONFIG_BT_SHARING; \n    ar->arWlanOffConfig      = WLAN_CONFIG_WLAN_OFF;\n    ar->arSuspendConfig      = WLAN_CONFIG_PM_SUSPEND;\n    ar->arWow2Config         = WLAN_CONFIG_PM_WOW2;\n#endif /* CONFIG_PM */\n\n    A_INIT_TIMER(&ar->arHBChallengeResp.timer, ar6000_detect_error, dev);\n    ar->arHBChallengeResp.seqNum = 0;\n    ar->arHBChallengeResp.outstanding = false;\n    ar->arHBChallengeResp.missCnt = 0;\n    ar->arHBChallengeResp.frequency = AR6000_HB_CHALLENGE_RESP_FREQ_DEFAULT;\n    ar->arHBChallengeResp.missThres = AR6000_HB_CHALLENGE_RESP_MISS_THRES_DEFAULT;\n\n    ar6000_init_control_info(ar);\n    init_waitqueue_head(&arEvent);\n    sema_init(&ar->arSem, 1);\n    ar->bIsDestroyProgress = false;\n\n    INIT_HTC_PACKET_QUEUE(&ar->amsdu_rx_buffer_queue);\n\n#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL\n    A_INIT_TIMER(&aptcTimer, aptcTimerHandler, ar);\n#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */\n\n    A_INIT_TIMER(&ar->disconnect_timer, disconnect_timer_handler, dev);\n\n    BMIInit();\n\n    ar6000_sysfs_bmi_init(ar);\n\n    {\n        struct bmi_target_info targ_info;\n\n        r = BMIGetTargetInfo(ar->arHifDevice, &targ_info);\n        if (r)\n            goto avail_ev_failed;\n\n        ar->arVersion.target_ver = targ_info.target_ver;\n        ar->arTargetType = targ_info.target_type;\n\twdev->wiphy->hw_version = targ_info.target_ver;\n    }\n\n    r = ar6000_configure_target(ar);\n    if (r)\n            goto avail_ev_failed;\n\n    A_MEMZERO(&htcInfo,sizeof(htcInfo));\n    htcInfo.pContext = ar;\n    htcInfo.TargetFailure = ar6000_target_failure;\n\n    ar->arHtcTarget = HTCCreate(ar->arHifDevice,&htcInfo);\n\n    if (!ar->arHtcTarget) {\n        r = -ENOMEM;\n        goto avail_ev_failed;\n    }\n\n    spin_lock_init(&ar->arLock);\n\n#ifdef WAPI_ENABLE\n    ar->arWapiEnable = 0;\n#endif\n\n\n    if(csumOffload){\n        /*if external frame work is also needed, change and use an extended rxMetaVerion*/\n        ar->rxMetaVersion=WMI_META_VERSION_2;\n    }\n\n    ar->aggr_cntxt = aggr_init(ar6000_alloc_netbufs);\n    if (!ar->aggr_cntxt) {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"%s() Failed to initialize aggr.\\n\", __func__));\n            r = -ENOMEM;\n            goto avail_ev_failed;\n    }\n\n    aggr_register_rx_dispatcher(ar->aggr_cntxt, (void *)dev, ar6000_deliver_frames_to_nw_stack);\n\n    HIFClaimDevice(ar->arHifDevice, ar);\n\n    /* We only register the device in the global list if we succeed. */\n    /* If the device is in the global list, it will be destroyed     */\n    /* when the module is unloaded.                                  */\n    ar6000_devices[device_index] = dev;\n\n    AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\"BMI enabled: %d\\n\", wlaninitmode));\n    if ((wlaninitmode == WLAN_INIT_MODE_UDEV) ||\n        (wlaninitmode == WLAN_INIT_MODE_DRV)) {\n\tr = ath6kl_init_netdev(ar);\n\tif (r)\n            goto avail_ev_failed;\n    }\n\n    /* This runs the init function if registered */\n    r = register_netdev(dev);\n    if (r) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_avail: register_netdev failed\\n\"));\n        ar6000_destroy(dev, 0);\n        return r;\n    }\n\n\tis_netdev_registered = 1;\n\n#ifdef CONFIG_AP_VIRTUAL_ADAPTER_SUPPORT\n    arApNetDev = NULL;\n#endif /* CONFIG_AP_VIRTUAL_ADAPTER_SUPPORT */\n    AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"ar6000_avail: name=%s hifdevice=0x%lx, dev=0x%lx (%d), ar=0x%lx\\n\",\n                    dev->name, (unsigned long)ar->arHifDevice, (unsigned long)dev, device_index,\n                    (unsigned long)ar));\n\navail_ev_failed :\n    if (r)\n        ar6000_sysfs_bmi_deinit(ar);  \n\n    return r;\n}\n\nstatic void ar6000_target_failure(void *Instance, int Status)\n{\n    struct ar6_softc *ar = (struct ar6_softc *)Instance;\n    WMI_TARGET_ERROR_REPORT_EVENT errEvent;\n    static bool sip = false;\n\n    if (Status != 0) {\n\n        printk(KERN_ERR \"ar6000_target_failure: target asserted \\n\");\n\n        if (timer_pending(&ar->arHBChallengeResp.timer)) {\n            A_UNTIMEOUT(&ar->arHBChallengeResp.timer);\n        }\n\n        /* try dumping target assertion information (if any) */\n        ar6000_dump_target_assert_info(ar->arHifDevice,ar->arTargetType);\n\n        /*\n         * Fetch the logs from the target via the diagnostic\n         * window.\n         */\n        ar6000_dbglog_get_debug_logs(ar);\n\n        /* Report the error only once */\n        if (!sip) {\n            sip = true;\n            errEvent.errorVal = WMI_TARGET_COM_ERR |\n                                WMI_TARGET_FATAL_ERR;\n        }\n    }\n}\n\nstatic int\nar6000_unavail_ev(void *context, void *hif_handle)\n{\n    struct ar6_softc *ar = (struct ar6_softc *)context;\n        /* NULL out it's entry in the global list */\n    ar6000_devices[ar->arDeviceIndex] = NULL;\n    ar6000_destroy(ar->arNetDev, 1);\n\n    return 0;\n}\n\nvoid\nar6000_restart_endpoint(struct net_device *dev)\n{\n    int status = 0;\n    struct ar6_softc *ar = (struct ar6_softc *)ar6k_priv(dev);\n\n    BMIInit();\n    do {\n        if ( (status=ar6000_configure_target(ar))!= 0)\n            break;\n        if ( (status=ar6000_sysfs_bmi_get_config(ar, wlaninitmode)) != 0)\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_avail: ar6000_sysfs_bmi_get_config failed\\n\"));\n            break;\n        }\n        rtnl_lock();\n        status = (ar6000_init(dev)==0) ? 0 : A_ERROR;\n        rtnl_unlock();\n\n        if (status) {\n            break;\n        }\n        if (ar->arSsidLen && ar->arWlanState == WLAN_ENABLED) {\n            ar6000_connect_to_ap(ar);\n        }  \n    } while (0);\n\n    if (status== 0) {\n        return;\n    }\n\n    ar6000_devices[ar->arDeviceIndex] = NULL;\n    ar6000_destroy(ar->arNetDev, 1);\n}\n\nvoid\nar6000_stop_endpoint(struct net_device *dev, bool keepprofile, bool getdbglogs)\n{\n    struct ar6_softc *ar = (struct ar6_softc *)ar6k_priv(dev);\n\n    /* Stop the transmit queues */\n    netif_stop_queue(dev);\n\n    /* Disable the target and the interrupts associated with it */\n    if (ar->arWmiReady == true)\n    {\n        if (!bypasswmi)\n        {\n            bool disconnectIssued;\n \n            disconnectIssued = (ar->arConnected) || (ar->arConnectPending);\n            ar6000_disconnect(ar);\n            if (!keepprofile) {\n                ar6000_init_profile_info(ar);\n            }\n\n            A_UNTIMEOUT(&ar->disconnect_timer);\n\n            if (getdbglogs) {\n                ar6000_dbglog_get_debug_logs(ar);\n            }\n\n            ar->arWmiReady  = false;\n            wmi_shutdown(ar->arWmi);\n            ar->arWmiEnabled = false;\n            ar->arWmi = NULL;\n            /* \n             * After wmi_shudown all WMI events will be dropped.\n             * We need to cleanup the buffers allocated in AP mode\n             * and give disconnect notification to stack, which usually\n             * happens in the disconnect_event. \n             * Simulate the disconnect_event by calling the function directly.\n             * Sometimes disconnect_event will be received when the debug logs \n             * are collected.\n             */\n            if (disconnectIssued) {\n                if(ar->arNetworkType & AP_NETWORK) {\n                    ar6000_disconnect_event(ar, DISCONNECT_CMD, bcast_mac, 0, NULL, 0);\n                } else {\n                    ar6000_disconnect_event(ar, DISCONNECT_CMD, ar->arBssid, 0, NULL, 0);\n                }\n            }\n            ar->user_savedkeys_stat = USER_SAVEDKEYS_STAT_INIT;\n            ar->user_key_ctrl      = 0;\n        }\n\n         AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"%s(): WMI stopped\\n\", __func__));\n    }\n    else\n    {\n        AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"%s(): WMI not ready 0x%lx 0x%lx\\n\",\n            __func__, (unsigned long) ar, (unsigned long) ar->arWmi));\n\n        /* Shut down WMI if we have started it */\n        if(ar->arWmiEnabled == true)\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"%s(): Shut down WMI\\n\", __func__));\n            wmi_shutdown(ar->arWmi);\n            ar->arWmiEnabled = false;\n            ar->arWmi = NULL;\n        }\n    }\n\n    if (ar->arHtcTarget != NULL) {\n#ifdef EXPORT_HCI_BRIDGE_INTERFACE\n        if (NULL != ar6kHciTransCallbacks.cleanupTransport) {\n            ar6kHciTransCallbacks.cleanupTransport(NULL);\n        }\n#else\n        // FIXME: workaround to reset BT's UART baud rate to default\n        if (NULL != ar->exitCallback) {\n            struct ar3k_config_info ar3kconfig;\n            int status;\n\n            A_MEMZERO(&ar3kconfig,sizeof(ar3kconfig));\n            ar6000_set_default_ar3kconfig(ar, (void *)&ar3kconfig);\n            status = ar->exitCallback(&ar3kconfig);\n            if (0 != status) {\n                AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"Failed to reset AR3K baud rate! \\n\"));\n            }\n        }\n        // END workaround\n        if (setuphci)\n        \tar6000_cleanup_hci(ar);\n#endif\n        AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\" Shutting down HTC .... \\n\"));\n        /* stop HTC */\n        HTCStop(ar->arHtcTarget);\n    }\n\n    if (resetok) {\n        /* try to reset the device if we can\n         * The driver may have been configure NOT to reset the target during\n         * a debug session */\n        AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\" Attempting to reset target on instance destroy.... \\n\"));\n        if (ar->arHifDevice != NULL) {\n            bool coldReset = (ar->arTargetType == TARGET_TYPE_AR6003) ? true: false;\n            ar6000_reset_device(ar->arHifDevice, ar->arTargetType, true, coldReset);\n        }\n    } else {\n        AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\" Host does not want target reset. \\n\"));\n    }\n       /* Done with cookies */\n    ar6000_cookie_cleanup(ar);\n\n    /* cleanup any allocated AMSDU buffers */\n    ar6000_cleanup_amsdu_rxbufs(ar);\n}\n/*\n * We need to differentiate between the surprise and planned removal of the\n * device because of the following consideration:\n * - In case of surprise removal, the hcd already frees up the pending\n *   for the device and hence there is no need to unregister the function\n *   driver inorder to get these requests. For planned removal, the function\n *   driver has to explicitly unregister itself to have the hcd return all the\n *   pending requests before the data structures for the devices are freed up.\n *   Note that as per the current implementation, the function driver will\n *   end up releasing all the devices since there is no API to selectively\n *   release a particular device.\n * - Certain commands issued to the target can be skipped for surprise\n *   removal since they will anyway not go through.\n */\nvoid\nar6000_destroy(struct net_device *dev, unsigned int unregister)\n{\n    struct ar6_softc *ar;\n\n    AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"+ar6000_destroy \\n\"));\n    \n    if((dev == NULL) || ((ar = ar6k_priv(dev)) == NULL))\n    {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"%s(): Failed to get device structure.\\n\", __func__));\n        return;\n    }\n\n    ar->bIsDestroyProgress = true;\n\n    if (down_interruptible(&ar->arSem)) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"%s(): down_interruptible failed \\n\", __func__));\n        return;\n    }\n\n    if (ar->arWlanPowerState != WLAN_POWER_STATE_CUT_PWR) {\n        /* only stop endpoint if we are not stop it in suspend_ev */\n        ar6000_stop_endpoint(dev, false, true);\n    }\n\n    ar->arWlanState = WLAN_DISABLED;\n    if (ar->arHtcTarget != NULL) {\n        /* destroy HTC */\n        HTCDestroy(ar->arHtcTarget);\n    }\n    if (ar->arHifDevice != NULL) {\n        /*release the device so we do not get called back on remove incase we\n         * we're explicity destroyed by module unload */\n        HIFReleaseDevice(ar->arHifDevice);\n        HIFShutDownDevice(ar->arHifDevice);\n    }\n    aggr_module_destroy(ar->aggr_cntxt);\n\n       /* Done with cookies */\n    ar6000_cookie_cleanup(ar);\n\n        /* cleanup any allocated AMSDU buffers */\n    ar6000_cleanup_amsdu_rxbufs(ar);\n\n    ar6000_sysfs_bmi_deinit(ar);\n\n    /* Cleanup BMI */\n    BMICleanup();\n\n    /* Clear the tx counters */\n    memset(tx_attempt, 0, sizeof(tx_attempt));\n    memset(tx_post, 0, sizeof(tx_post));\n    memset(tx_complete, 0, sizeof(tx_complete));\n\n#ifdef HTC_RAW_INTERFACE\n    if (ar->arRawHtc) {\n        kfree(ar->arRawHtc);\n        ar->arRawHtc = NULL;\n    }\n#endif \n    /* Free up the device data structure */\n    if (unregister && is_netdev_registered) {\t\t\n        unregister_netdev(dev);\n        is_netdev_registered = 0;\n    }\n    free_netdev(dev);\n\n    ar6k_cfg80211_deinit(ar);\n\n#ifdef CONFIG_AP_VIRTUL_ADAPTER_SUPPORT\n    ar6000_remove_ap_interface();\n#endif /*CONFIG_AP_VIRTUAL_ADAPTER_SUPPORT */\n\n    AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"-ar6000_destroy \\n\"));\n}\n\nstatic void disconnect_timer_handler(unsigned long ptr)\n{\n    struct net_device *dev = (struct net_device *)ptr;\n    struct ar6_softc *ar = (struct ar6_softc *)ar6k_priv(dev);\n\n    A_UNTIMEOUT(&ar->disconnect_timer);\n\n    ar6000_init_profile_info(ar);\n    ar6000_disconnect(ar);\n}\n\nstatic void ar6000_detect_error(unsigned long ptr)\n{\n    struct net_device *dev = (struct net_device *)ptr;\n    struct ar6_softc *ar = (struct ar6_softc *)ar6k_priv(dev);\n    WMI_TARGET_ERROR_REPORT_EVENT errEvent;\n\n    AR6000_SPIN_LOCK(&ar->arLock, 0);\n\n    if (ar->arHBChallengeResp.outstanding) {\n        ar->arHBChallengeResp.missCnt++;\n    } else {\n        ar->arHBChallengeResp.missCnt = 0;\n    }\n\n    if (ar->arHBChallengeResp.missCnt > ar->arHBChallengeResp.missThres) {\n        /* Send Error Detect event to the application layer and do not reschedule the error detection module timer */\n        ar->arHBChallengeResp.missCnt = 0;\n        ar->arHBChallengeResp.seqNum = 0;\n        errEvent.errorVal = WMI_TARGET_COM_ERR | WMI_TARGET_FATAL_ERR;\n        AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n        return;\n    }\n\n    /* Generate the sequence number for the next challenge */\n    ar->arHBChallengeResp.seqNum++;\n    ar->arHBChallengeResp.outstanding = true;\n\n    AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n\n    /* Send the challenge on the control channel */\n    if (wmi_get_challenge_resp_cmd(ar->arWmi, ar->arHBChallengeResp.seqNum, DRV_HB_CHALLENGE) != 0) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"Unable to send heart beat challenge\\n\"));\n    }\n\n\n    /* Reschedule the timer for the next challenge */\n    A_TIMEOUT_MS(&ar->arHBChallengeResp.timer, ar->arHBChallengeResp.frequency * 1000, 0);\n}\n\nvoid ar6000_init_profile_info(struct ar6_softc *ar)\n{\n    ar->arSsidLen            = 0;\n    A_MEMZERO(ar->arSsid, sizeof(ar->arSsid));\n\n    switch(fwmode) {\n        case HI_OPTION_FW_MODE_IBSS:\n            ar->arNetworkType = ar->arNextMode = ADHOC_NETWORK;\n            break;\n        case HI_OPTION_FW_MODE_BSS_STA:\n            ar->arNetworkType = ar->arNextMode = INFRA_NETWORK;\n            break;\n        case HI_OPTION_FW_MODE_AP:\n            ar->arNetworkType = ar->arNextMode = AP_NETWORK;\n            break;\n    }\n\n    ar->arDot11AuthMode      = OPEN_AUTH;\n    ar->arAuthMode           = NONE_AUTH;\n    ar->arPairwiseCrypto     = NONE_CRYPT;\n    ar->arPairwiseCryptoLen  = 0;\n    ar->arGroupCrypto        = NONE_CRYPT;\n    ar->arGroupCryptoLen     = 0;\n    A_MEMZERO(ar->arWepKeyList, sizeof(ar->arWepKeyList));\n    A_MEMZERO(ar->arReqBssid, sizeof(ar->arReqBssid));\n    A_MEMZERO(ar->arBssid, sizeof(ar->arBssid));\n    ar->arBssChannel = 0;\n}\n\nstatic void\nar6000_init_control_info(struct ar6_softc *ar)\n{\n    ar->arWmiEnabled         = false;\n    ar6000_init_profile_info(ar);\n    ar->arDefTxKeyIndex      = 0;\n    A_MEMZERO(ar->arWepKeyList, sizeof(ar->arWepKeyList));\n    ar->arChannelHint        = 0;\n    ar->arListenIntervalT    = A_DEFAULT_LISTEN_INTERVAL;\n    ar->arListenIntervalB    = 0;\n    ar->arVersion.host_ver   = AR6K_SW_VERSION;\n    ar->arRssi               = 0;\n    ar->arTxPwr              = 0;\n    ar->arTxPwrSet           = false;\n    ar->arSkipScan           = 0;\n    ar->arBeaconInterval     = 0;\n    ar->arBitRate            = 0;\n    ar->arMaxRetries         = 0;\n    ar->arWmmEnabled         = true;\n    ar->intra_bss            = 1;\n    ar->scan_triggered       = 0;\n    A_MEMZERO(&ar->scParams, sizeof(ar->scParams));\n    ar->scParams.shortScanRatio = WMI_SHORTSCANRATIO_DEFAULT;\n    ar->scParams.scanCtrlFlags = DEFAULT_SCAN_CTRL_FLAGS;\n\n    /* Initialize the AP mode state info */\n    {\n        u8 ctr;\n        A_MEMZERO((u8 *)ar->sta_list, AP_MAX_NUM_STA * sizeof(sta_t));\n\n        /* init the Mutexes */\n        A_MUTEX_INIT(&ar->mcastpsqLock);\n\n        /* Init the PS queues */\n        for (ctr=0; ctr < AP_MAX_NUM_STA ; ctr++) {\n            A_MUTEX_INIT(&ar->sta_list[ctr].psqLock);\n            A_NETBUF_QUEUE_INIT(&ar->sta_list[ctr].psq);\n        }\n\n        ar->ap_profile_flag = 0;\n        A_NETBUF_QUEUE_INIT(&ar->mcastpsq);\n\n        memcpy(ar->ap_country_code, DEF_AP_COUNTRY_CODE, 3);\n        ar->ap_wmode = DEF_AP_WMODE_G;\n        ar->ap_dtim_period = DEF_AP_DTIM;\n        ar->ap_beacon_interval = DEF_BEACON_INTERVAL;\n    }\n}\n\nstatic int\nar6000_open(struct net_device *dev)\n{\n    unsigned long  flags;\n    struct ar6_softc    *ar = (struct ar6_softc *)ar6k_priv(dev);\n\n    spin_lock_irqsave(&ar->arLock, flags);\n\n    if(ar->arWlanState == WLAN_DISABLED) {\n        ar->arWlanState = WLAN_ENABLED;\n    }\n\n    if( ar->arConnected || bypasswmi) {\n        netif_carrier_on(dev);\n        /* Wake up the queues */\n        netif_wake_queue(dev);\n    }\n    else\n        netif_carrier_off(dev);\n\n    spin_unlock_irqrestore(&ar->arLock, flags);\n    return 0;\n}\n\nstatic int\nar6000_close(struct net_device *dev)\n{\n    struct ar6_softc    *ar = (struct ar6_softc *)ar6k_priv(dev);\n    netif_stop_queue(dev);\n\n    ar6000_disconnect(ar);\n\n    if(ar->arWmiReady == true) {\n        if (wmi_scanparams_cmd(ar->arWmi, 0xFFFF, 0,\n                               0, 0, 0, 0, 0, 0, 0, 0) != 0) {\n            return -EIO;\n        }\n        ar->arWlanState = WLAN_DISABLED;\n    }\n\tar6k_cfg80211_scanComplete_event(ar, A_ECANCELED);\n\n    return 0;\n}\n\n/* connect to a service */\nstatic int ar6000_connectservice(struct ar6_softc               *ar,\n                                      struct htc_service_connect_req  *pConnect,\n                                      char *pDesc)\n{\n    int                 status;\n    struct htc_service_connect_resp response;\n\n    do {\n\n        A_MEMZERO(&response,sizeof(response));\n\n        status = HTCConnectService(ar->arHtcTarget,\n                                   pConnect,\n                                   &response);\n\n        if (status) {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\" Failed to connect to %s service status:%d \\n\",\n                              pDesc, status));\n            break;\n        }\n        switch (pConnect->ServiceID) {\n            case WMI_CONTROL_SVC :\n                if (ar->arWmiEnabled) {\n                        /* set control endpoint for WMI use */\n                    wmi_set_control_ep(ar->arWmi, response.Endpoint);\n                }\n                    /* save EP for fast lookup */\n                ar->arControlEp = response.Endpoint;\n                break;\n            case WMI_DATA_BE_SVC :\n                arSetAc2EndpointIDMap(ar, WMM_AC_BE, response.Endpoint);\n                break;\n            case WMI_DATA_BK_SVC :\n                arSetAc2EndpointIDMap(ar, WMM_AC_BK, response.Endpoint);\n                break;\n            case WMI_DATA_VI_SVC :\n                arSetAc2EndpointIDMap(ar, WMM_AC_VI, response.Endpoint);\n                 break;\n           case WMI_DATA_VO_SVC :\n                arSetAc2EndpointIDMap(ar, WMM_AC_VO, response.Endpoint);\n                break;\n           default:\n                AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ServiceID not mapped %d\\n\", pConnect->ServiceID));\n                status = A_EINVAL;\n            break;\n        }\n\n    } while (false);\n\n    return status;\n}\n\nvoid ar6000_TxDataCleanup(struct ar6_softc *ar)\n{\n        /* flush all the data (non-control) streams\n         * we only flush packets that are tagged as data, we leave any control packets that\n         * were in the TX queues alone */\n    HTCFlushEndpoint(ar->arHtcTarget,\n                     arAc2EndpointID(ar, WMM_AC_BE),\n                     AR6K_DATA_PKT_TAG);\n    HTCFlushEndpoint(ar->arHtcTarget,\n                     arAc2EndpointID(ar, WMM_AC_BK),\n                     AR6K_DATA_PKT_TAG);\n    HTCFlushEndpoint(ar->arHtcTarget,\n                     arAc2EndpointID(ar, WMM_AC_VI),\n                     AR6K_DATA_PKT_TAG);\n    HTCFlushEndpoint(ar->arHtcTarget,\n                     arAc2EndpointID(ar, WMM_AC_VO),\n                     AR6K_DATA_PKT_TAG);\n}\n\nHTC_ENDPOINT_ID\nar6000_ac2_endpoint_id ( void * devt, u8 ac)\n{\n    struct ar6_softc *ar = (struct ar6_softc *) devt;\n    return(arAc2EndpointID(ar, ac));\n}\n\nu8 ar6000_endpoint_id2_ac(void * devt, HTC_ENDPOINT_ID ep )\n{\n    struct ar6_softc *ar = (struct ar6_softc *) devt;\n    return(arEndpoint2Ac(ar, ep ));\n}\n\n#if defined(CONFIG_ATH6KL_ENABLE_COEXISTENCE)\nstatic int ath6kl_config_btcoex_params(struct ar6_softc *ar)\n{\n\tint r;\n\tWMI_SET_BTCOEX_COLOCATED_BT_DEV_CMD sbcb_cmd;\n\tWMI_SET_BTCOEX_FE_ANT_CMD sbfa_cmd;\n\n\t/* Configure the type of BT collocated with WLAN */\n\tmemset(&sbcb_cmd, 0, sizeof(WMI_SET_BTCOEX_COLOCATED_BT_DEV_CMD));\n\tsbcb_cmd.btcoexCoLocatedBTdev = ATH6KL_BT_DEV;\n\n\tr = wmi_set_btcoex_colocated_bt_dev_cmd(ar->arWmi, &sbcb_cmd);\n\n\tif (r) {\n\t\tAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\n\t\t\t\t(\"Unable to set collocated BT type\\n\"));\n\t\treturn r;\n\t}\n\n\t/* Configure the type of BT collocated with WLAN */\n\tmemset(&sbfa_cmd, 0, sizeof(WMI_SET_BTCOEX_FE_ANT_CMD));\n\n\tsbfa_cmd.btcoexFeAntType = ATH6KL_BT_ANTENNA;\n\n\tr = wmi_set_btcoex_fe_ant_cmd(ar->arWmi, &sbfa_cmd);\n\tif (r) {\n\t\tAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\n\t\t\t\t(\"Unable to set fornt end antenna configuration\\n\"));\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n#else\nstatic int ath6kl_config_btcoex_params(struct ar6_softc *ar)\n{\n\treturn 0;\n}\n#endif /* CONFIG_ATH6KL_ENABLE_COEXISTENCE */\n\n/*\n * This function applies WLAN specific configuration defined in wlan_config.h\n */\nint ar6000_target_config_wlan_params(struct ar6_softc *ar)\n{\n    int status = 0;\n\n#ifdef CONFIG_HOST_TCMD_SUPPORT\n    if (ar->arTargetMode != AR6000_WLAN_MODE) {\n        return 0;\n    }\n#endif /* CONFIG_HOST_TCMD_SUPPORT */\n\n    /* \n     * configure the device for rx dot11 header rules 0,0 are the default values\n     * therefore this command can be skipped if the inputs are 0,FALSE,FALSE.Required\n     * if checksum offload is needed. Set RxMetaVersion to 2\n     */\n    if ((wmi_set_rx_frame_format_cmd(ar->arWmi,ar->rxMetaVersion, processDot11Hdr, processDot11Hdr)) != 0) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"Unable to set the rx frame format.\\n\"));\n        status = A_ERROR;\n    }\n\n    status = ath6kl_config_btcoex_params(ar);\n    if (status)\n\treturn status;\n\n#if WLAN_CONFIG_IGNORE_POWER_SAVE_FAIL_EVENT_DURING_SCAN\n    if ((wmi_pmparams_cmd(ar->arWmi, 0, 1, 0, 0, 1, IGNORE_POWER_SAVE_FAIL_EVENT_DURING_SCAN)) != 0) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"Unable to set power save fail event policy\\n\"));\n        status = A_ERROR;\n    }\n#endif\n\n#if WLAN_CONFIG_DONOT_IGNORE_BARKER_IN_ERP\n    if ((wmi_set_lpreamble_cmd(ar->arWmi, 0, WMI_DONOT_IGNORE_BARKER_IN_ERP)) != 0) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"Unable to set barker preamble policy\\n\"));\n        status = A_ERROR;\n    }\n#endif\n\n    if ((wmi_set_keepalive_cmd(ar->arWmi, WLAN_CONFIG_KEEP_ALIVE_INTERVAL)) != 0) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"Unable to set keep alive interval\\n\"));\n        status = A_ERROR;\n    }\n\n#if WLAN_CONFIG_DISABLE_11N\n    {\n        WMI_SET_HT_CAP_CMD htCap;\n\n        memset(&htCap, 0, sizeof(WMI_SET_HT_CAP_CMD));\n        htCap.band = 0;\n        if ((wmi_set_ht_cap_cmd(ar->arWmi, &htCap)) != 0) {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"Unable to set ht capabilities \\n\"));\n            status = A_ERROR;\n        }\n\n        htCap.band = 1;\n        if ((wmi_set_ht_cap_cmd(ar->arWmi, &htCap)) != 0) {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"Unable to set ht capabilities \\n\"));\n            status = A_ERROR;\n        }\n    }\n#endif /* WLAN_CONFIG_DISABLE_11N */\n\n#ifdef ATH6K_CONFIG_OTA_MODE\n    if ((wmi_powermode_cmd(ar->arWmi, MAX_PERF_POWER)) != 0) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"Unable to set power mode \\n\"));\n        status = A_ERROR;\n    }\n#endif\n\n    if ((wmi_disctimeout_cmd(ar->arWmi, WLAN_CONFIG_DISCONNECT_TIMEOUT)) != 0) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"Unable to set disconnect timeout \\n\"));\n        status = A_ERROR;\n    }\n\n#if WLAN_CONFIG_DISABLE_TX_BURSTING  \n    if ((wmi_set_wmm_txop(ar->arWmi, WMI_TXOP_DISABLED)) != 0) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"Unable to set txop bursting \\n\"));\n        status = A_ERROR;\n    }\n#endif \n\n    return status;\n}\n\n/* This function does one time initialization for the lifetime of the device */\nint ar6000_init(struct net_device *dev)\n{\n    struct ar6_softc *ar;\n    int    status;\n    s32 timeleft;\n    s16 i;\n    int         ret = 0;\n\n    if((ar = ar6k_priv(dev)) == NULL)\n    {\n        return -EIO;\n    }\n\n    if (wlaninitmode == WLAN_INIT_MODE_USR || wlaninitmode == WLAN_INIT_MODE_DRV) {\n    \n        ar6000_update_bdaddr(ar);\n\n        if (enablerssicompensation) {\n            ar6000_copy_cust_data_from_target(ar->arHifDevice, ar->arTargetType);\n            read_rssi_compensation_param(ar);\n            for (i=-95; i<=0; i++) {\n                rssi_compensation_table[0-i] = rssi_compensation_calc(ar,i);\n            }\n        }\n    }\n\n    dev_hold(dev);\n    rtnl_unlock();\n\n    /* Do we need to finish the BMI phase */\n    if ((wlaninitmode == WLAN_INIT_MODE_USR || wlaninitmode == WLAN_INIT_MODE_DRV) && \n        (BMIDone(ar->arHifDevice) != 0))\n    {\n        ret = -EIO;\n        goto ar6000_init_done;\n    }\n\n    if (!bypasswmi)\n    {\n#if 0 /* TBDXXX */\n        if (ar->arVersion.host_ver != ar->arVersion.target_ver) {\n            A_PRINTF(\"WARNING: Host version 0x%x does not match Target \"\n                    \" version 0x%x!\\n\",\n                    ar->arVersion.host_ver, ar->arVersion.target_ver);\n        }\n#endif\n\n        /* Indicate that WMI is enabled (although not ready yet) */\n        ar->arWmiEnabled = true;\n        if ((ar->arWmi = wmi_init((void *) ar)) == NULL)\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"%s() Failed to initialize WMI.\\n\", __func__));\n            ret = -EIO;\n            goto ar6000_init_done;\n        }\n\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"%s() Got WMI @ 0x%lx.\\n\", __func__,\n            (unsigned long) ar->arWmi));\n    }\n\n    do {\n        struct htc_service_connect_req connect;\n\n            /* the reason we have to wait for the target here is that the driver layer\n             * has to init BMI in order to set the host block size,\n             */\n        status = HTCWaitTarget(ar->arHtcTarget);\n\n        if (status) {\n            break;\n        }\n\n        A_MEMZERO(&connect,sizeof(connect));\n            /* meta data is unused for now */\n        connect.pMetaData = NULL;\n        connect.MetaDataLength = 0;\n            /* these fields are the same for all service endpoints */\n        connect.EpCallbacks.pContext = ar;\n        connect.EpCallbacks.EpTxCompleteMultiple = ar6000_tx_complete;\n        connect.EpCallbacks.EpRecv = ar6000_rx;\n        connect.EpCallbacks.EpRecvRefill = ar6000_rx_refill;\n        connect.EpCallbacks.EpSendFull = ar6000_tx_queue_full;\n            /* set the max queue depth so that our ar6000_tx_queue_full handler gets called.\n             * Linux has the peculiarity of not providing flow control between the\n             * NIC and the network stack. There is no API to indicate that a TX packet\n             * was sent which could provide some back pressure to the network stack.\n             * Under linux you would have to wait till the network stack consumed all sk_buffs\n             * before any back-flow kicked in. Which isn't very friendly.\n             * So we have to manage this ourselves */\n        connect.MaxSendQueueDepth = MAX_DEFAULT_SEND_QUEUE_DEPTH;\n        connect.EpCallbacks.RecvRefillWaterMark = AR6000_MAX_RX_BUFFERS / 4; /* set to 25 % */\n        if (0 == connect.EpCallbacks.RecvRefillWaterMark) {\n            connect.EpCallbacks.RecvRefillWaterMark++;\n        }\n            /* connect to control service */\n        connect.ServiceID = WMI_CONTROL_SVC;\n        status = ar6000_connectservice(ar,\n                                       &connect,\n                                       \"WMI CONTROL\");\n        if (status) {\n            break;\n        }\n\n        connect.LocalConnectionFlags |= HTC_LOCAL_CONN_FLAGS_ENABLE_SEND_BUNDLE_PADDING;\n            /* limit the HTC message size on the send path, although we can receive A-MSDU frames of\n             * 4K, we will only send ethernet-sized (802.3) frames on the send path. */\n        connect.MaxSendMsgSize = WMI_MAX_TX_DATA_FRAME_LENGTH;\n\n            /* to reduce the amount of committed memory for larger A_MSDU frames, use the recv-alloc threshold\n             * mechanism for larger packets */\n        connect.EpCallbacks.RecvAllocThreshold = AR6000_BUFFER_SIZE;\n        connect.EpCallbacks.EpRecvAllocThresh = ar6000_alloc_amsdu_rxbuf;\n\n            /* for the remaining data services set the connection flag to reduce dribbling,\n             * if configured to do so */\n        if (reduce_credit_dribble) {\n            connect.ConnectionFlags |= HTC_CONNECT_FLAGS_REDUCE_CREDIT_DRIBBLE;\n            /* the credit dribble trigger threshold is (reduce_credit_dribble - 1) for a value\n             * of 0-3 */\n            connect.ConnectionFlags &= ~HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_MASK;\n            connect.ConnectionFlags |=\n                        ((u16)reduce_credit_dribble - 1) & HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_MASK;\n        }\n            /* connect to best-effort service */\n        connect.ServiceID = WMI_DATA_BE_SVC;\n\n        status = ar6000_connectservice(ar,\n                                       &connect,\n                                       \"WMI DATA BE\");\n        if (status) {\n            break;\n        }\n\n            /* connect to back-ground\n             * map this to WMI LOW_PRI */\n        connect.ServiceID = WMI_DATA_BK_SVC;\n        status = ar6000_connectservice(ar,\n                                       &connect,\n                                       \"WMI DATA BK\");\n        if (status) {\n            break;\n        }\n\n            /* connect to Video service, map this to\n             * to HI PRI */\n        connect.ServiceID = WMI_DATA_VI_SVC;\n        status = ar6000_connectservice(ar,\n                                       &connect,\n                                       \"WMI DATA VI\");\n        if (status) {\n            break;\n        }\n\n            /* connect to VO service, this is currently not\n             * mapped to a WMI priority stream due to historical reasons.\n             * WMI originally defined 3 priorities over 3 mailboxes\n             * We can change this when WMI is reworked so that priorities are not\n             * dependent on mailboxes */\n        connect.ServiceID = WMI_DATA_VO_SVC;\n        status = ar6000_connectservice(ar,\n                                       &connect,\n                                       \"WMI DATA VO\");\n        if (status) {\n            break;\n        }\n\n        A_ASSERT(arAc2EndpointID(ar,WMM_AC_BE) != 0);\n        A_ASSERT(arAc2EndpointID(ar,WMM_AC_BK) != 0);\n        A_ASSERT(arAc2EndpointID(ar,WMM_AC_VI) != 0);\n        A_ASSERT(arAc2EndpointID(ar,WMM_AC_VO) != 0);\n\n            /* setup access class priority mappings */\n        ar->arAcStreamPriMap[WMM_AC_BK] = 0; /* lowest  */\n        ar->arAcStreamPriMap[WMM_AC_BE] = 1; /*         */\n        ar->arAcStreamPriMap[WMM_AC_VI] = 2; /*         */\n        ar->arAcStreamPriMap[WMM_AC_VO] = 3; /* highest */\n\n#ifdef EXPORT_HCI_BRIDGE_INTERFACE\n        if (setuphci && (NULL != ar6kHciTransCallbacks.setupTransport)) {\n            struct hci_transport_misc_handles hciHandles;\n\n            hciHandles.netDevice = ar->arNetDev;\n            hciHandles.hifDevice = ar->arHifDevice;\n            hciHandles.htcHandle = ar->arHtcTarget;\n            status = (int)(ar6kHciTransCallbacks.setupTransport(&hciHandles));\n        }\n#else\n        if (setuphci) {\n                /* setup HCI */\n            status = ar6000_setup_hci(ar);\n        }\n#endif\n\n    } while (false);\n\n    if (status) {\n        ret = -EIO;\n        goto ar6000_init_done;\n    }\n\n\tif (regscanmode) {\n\t\tu32 param;\n\n\t\tif (BMIReadMemory(ar->arHifDevice,\n\t\t\t\t  HOST_INTEREST_ITEM_ADDRESS(ar,\n\t\t\t\t\t\t\t     hi_option_flag),\n\t\t\t\t\t\t\t     (u8 *)&param,\n\t\t\t\t\t\t\t     4) != 0) {\n\t\t\tAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\n\t\t\t\t\t(\"BMIReadMemory forsetting \"\n\t\t\t\t\t \"regscanmode failed\\n\"));\n\t\t\treturn A_ERROR;\n\t\t}\n\n\t\tif (regscanmode == 1)\n\t\t\tparam |= HI_OPTION_SKIP_REG_SCAN;\n\t\telse if (regscanmode == 2)\n\t\t\tparam |= HI_OPTION_INIT_REG_SCAN;\n\n\t\tif (BMIWriteMemory(ar->arHifDevice,\n\t\t\t\t   HOST_INTEREST_ITEM_ADDRESS(ar,\n\t\t\t\t\t\t\t      hi_option_flag),\n\t\t\t\t\t\t\t      (u8 *)&param,\n\t\t\t\t\t\t\t      4) != 0) {\n\t\t\tAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\n\t\t\t\t\t(\"BMIWriteMemory forsetting \"\n\t\t\t\t\t\"regscanmode failed\\n\"));\n\t\t\treturn A_ERROR;\n\t\t}\n\t\tAR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\"Regulatory scan mode set\\n\"));\n\t}\n\n    /*\n     * give our connected endpoints some buffers\n     */\n\n    ar6000_rx_refill(ar, ar->arControlEp);\n    ar6000_rx_refill(ar, arAc2EndpointID(ar,WMM_AC_BE));\n\n    /*\n     * We will post the receive buffers only for SPE or endpoint ping testing so we are\n     * making it conditional on the 'bypasswmi' flag.\n     */\n    if (bypasswmi) {\n        ar6000_rx_refill(ar,arAc2EndpointID(ar,WMM_AC_BK));\n        ar6000_rx_refill(ar,arAc2EndpointID(ar,WMM_AC_VI));\n        ar6000_rx_refill(ar,arAc2EndpointID(ar,WMM_AC_VO));\n    }\n\n    /* allocate some buffers that handle larger AMSDU frames */\n    ar6000_refill_amsdu_rxbufs(ar,AR6000_MAX_AMSDU_RX_BUFFERS);\n\n        /* setup credit distribution */\n    ar6000_setup_credit_dist(ar->arHtcTarget, &ar->arCreditStateInfo);\n\n    /* Since cookies are used for HTC transports, they should be */\n    /* initialized prior to enabling HTC.                        */\n    ar6000_cookie_init(ar);\n\n    /* start HTC */\n    status = HTCStart(ar->arHtcTarget);\n\n    if (status) {\n        if (ar->arWmiEnabled == true) {\n            wmi_shutdown(ar->arWmi);\n            ar->arWmiEnabled = false;\n            ar->arWmi = NULL;\n        }\n        ar6000_cookie_cleanup(ar);\n        ret = -EIO;\n        goto ar6000_init_done;\n    }\n\n    if (!bypasswmi) {\n        /* Wait for Wmi event to be ready */\n        timeleft = wait_event_interruptible_timeout(arEvent,\n            (ar->arWmiReady == true), wmitimeout * HZ);\n\n        if (ar->arVersion.abi_ver != AR6K_ABI_VERSION) {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ABI Version mismatch: Host(0x%x), Target(0x%x)\\n\", AR6K_ABI_VERSION, ar->arVersion.abi_ver));\n#ifndef ATH6K_SKIP_ABI_VERSION_CHECK\n            ret = -EIO;\n            goto ar6000_init_done;\n#endif /* ATH6K_SKIP_ABI_VERSION_CHECK */\n        }\n\n        if(!timeleft || signal_pending(current))\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"WMI is not ready or wait was interrupted\\n\"));\n            ret = -EIO;\n            goto ar6000_init_done;\n        }\n\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"%s() WMI is ready\\n\", __func__));\n\n        /* Communicate the wmi protocol verision to the target */\n        if ((ar6000_set_host_app_area(ar)) != 0) {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"Unable to set the host app area\\n\"));\n        }\n        ar6000_target_config_wlan_params(ar);\n    }\n\n    ar->arNumDataEndPts = 1;\n\n    if (bypasswmi) {\n            /* for tests like endpoint ping, the MAC address needs to be non-zero otherwise\n             * the data path through a raw socket is disabled */\n        dev->dev_addr[0] = 0x00;\n        dev->dev_addr[1] = 0x01;\n        dev->dev_addr[2] = 0x02;\n        dev->dev_addr[3] = 0xAA;\n        dev->dev_addr[4] = 0xBB;\n        dev->dev_addr[5] = 0xCC;\n    }\n\nar6000_init_done:\n    rtnl_lock();\n    dev_put(dev);\n\n    return ret;\n}\n\n\nvoid\nar6000_bitrate_rx(void *devt, s32 rateKbps)\n{\n    struct ar6_softc *ar = (struct ar6_softc *)devt;\n\n    ar->arBitRate = rateKbps;\n    wake_up(&arEvent);\n}\n\nvoid\nar6000_ratemask_rx(void *devt, u32 ratemask)\n{\n    struct ar6_softc *ar = (struct ar6_softc *)devt;\n\n    ar->arRateMask = ratemask;\n    wake_up(&arEvent);\n}\n\nvoid\nar6000_txPwr_rx(void *devt, u8 txPwr)\n{\n    struct ar6_softc *ar = (struct ar6_softc *)devt;\n\n    ar->arTxPwr = txPwr;\n    wake_up(&arEvent);\n}\n\n\nvoid\nar6000_channelList_rx(void *devt, s8 numChan, u16 *chanList)\n{\n    struct ar6_softc *ar = (struct ar6_softc *)devt;\n\n    memcpy(ar->arChannelList, chanList, numChan * sizeof (u16));\n    ar->arNumChannels = numChan;\n\n    wake_up(&arEvent);\n}\n\nu8 ar6000_ibss_map_epid(struct sk_buff *skb, struct net_device *dev, u32 *mapNo)\n{\n    struct ar6_softc      *ar = (struct ar6_softc *)ar6k_priv(dev);\n    u8 *datap;\n    ATH_MAC_HDR     *macHdr;\n    u32 i, eptMap;\n\n    (*mapNo) = 0;\n    datap = A_NETBUF_DATA(skb);\n    macHdr = (ATH_MAC_HDR *)(datap + sizeof(WMI_DATA_HDR));\n    if (IEEE80211_IS_MULTICAST(macHdr->dstMac)) {\n        return ENDPOINT_2;\n    }\n\n    eptMap = -1;\n    for (i = 0; i < ar->arNodeNum; i ++) {\n        if (IEEE80211_ADDR_EQ(macHdr->dstMac, ar->arNodeMap[i].macAddress)) {\n            (*mapNo) = i + 1;\n            ar->arNodeMap[i].txPending ++;\n            return ar->arNodeMap[i].epId;\n        }\n\n        if ((eptMap == -1) && !ar->arNodeMap[i].txPending) {\n            eptMap = i;\n        }\n    }\n\n    if (eptMap == -1) {\n        eptMap = ar->arNodeNum;\n        ar->arNodeNum ++;\n        A_ASSERT(ar->arNodeNum <= MAX_NODE_NUM);\n    }\n\n    memcpy(ar->arNodeMap[eptMap].macAddress, macHdr->dstMac, IEEE80211_ADDR_LEN);\n\n    for (i = ENDPOINT_2; i <= ENDPOINT_5; i ++) {\n        if (!ar->arTxPending[i]) {\n            ar->arNodeMap[eptMap].epId = i;\n            break;\n        }\n        // No free endpoint is available, start redistribution on the inuse endpoints.\n        if (i == ENDPOINT_5) {\n            ar->arNodeMap[eptMap].epId = ar->arNexEpId;\n            ar->arNexEpId ++;\n            if (ar->arNexEpId > ENDPOINT_5) {\n                ar->arNexEpId = ENDPOINT_2;\n            }\n        }\n    }\n\n    (*mapNo) = eptMap + 1;\n    ar->arNodeMap[eptMap].txPending ++;\n\n    return ar->arNodeMap[eptMap].epId;\n}\n\n#ifdef DEBUG\nstatic void ar6000_dump_skb(struct sk_buff *skb)\n{\n   u_char *ch;\n   for (ch = A_NETBUF_DATA(skb);\n        (unsigned long)ch < ((unsigned long)A_NETBUF_DATA(skb) +\n        A_NETBUF_LEN(skb)); ch++)\n    {\n         AR_DEBUG_PRINTF(ATH_DEBUG_WARN,(\"%2.2x \", *ch));\n    }\n    AR_DEBUG_PRINTF(ATH_DEBUG_WARN,(\"\\n\"));\n}\n#endif\n\n#ifdef HTC_TEST_SEND_PKTS\nstatic void DoHTCSendPktsTest(struct ar6_softc *ar, int MapNo, HTC_ENDPOINT_ID eid, struct sk_buff *skb);\n#endif\n\nstatic int\nar6000_data_tx(struct sk_buff *skb, struct net_device *dev)\n{\n#define AC_NOT_MAPPED   99\n    struct ar6_softc        *ar = (struct ar6_softc *)ar6k_priv(dev);\n    u8 ac = AC_NOT_MAPPED;\n    HTC_ENDPOINT_ID    eid = ENDPOINT_UNUSED;\n    u32 mapNo = 0;\n    int               len;\n    struct ar_cookie *cookie;\n    bool            checkAdHocPsMapping = false,bMoreData = false;\n    HTC_TX_TAG        htc_tag = AR6K_DATA_PKT_TAG;\n    u8 dot11Hdr = processDot11Hdr;\n#ifdef CONFIG_PM\n    if (ar->arWowState != WLAN_WOW_STATE_NONE) {\n        A_NETBUF_FREE(skb);\n        return 0;\n    }\n#endif /* CONFIG_PM */\n\n    AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_TX,(\"ar6000_data_tx start - skb=0x%lx, data=0x%lx, len=0x%x\\n\",\n                     (unsigned long)skb, (unsigned long)A_NETBUF_DATA(skb),\n                     A_NETBUF_LEN(skb)));\n\n    /* If target is not associated */\n    if( (!ar->arConnected && !bypasswmi)\n#ifdef CONFIG_HOST_TCMD_SUPPORT\n     /* TCMD doesn't support any data, free the buf and return */\n    || (ar->arTargetMode == AR6000_TCMD_MODE)\n#endif\n                                            ) {\n        A_NETBUF_FREE(skb);\n        return 0;\n    }\n\n    do {\n\n        if (ar->arWmiReady == false && bypasswmi == 0) {\n            break;\n        }\n\n#ifdef BLOCK_TX_PATH_FLAG\n        if (blocktx) {\n            break;\n        }\n#endif /* BLOCK_TX_PATH_FLAG */\n\n        /* AP mode Power save processing */\n        /* If the dst STA is in sleep state, queue the pkt in its PS queue */\n\n        if (ar->arNetworkType == AP_NETWORK) {\n            ATH_MAC_HDR *datap = (ATH_MAC_HDR *)A_NETBUF_DATA(skb);\n            sta_t *conn = NULL;\n\n            /* If the dstMac is a Multicast address & atleast one of the\n             * associated STA is in PS mode, then queue the pkt to the\n             * mcastq\n             */\n            if (IEEE80211_IS_MULTICAST(datap->dstMac)) {\n                u8 ctr=0;\n                bool qMcast=false;\n\n\n                for (ctr=0; ctr<AP_MAX_NUM_STA; ctr++) {\n                    if (STA_IS_PWR_SLEEP((&ar->sta_list[ctr]))) {\n                        qMcast = true;\n                    }\n                }\n                if(qMcast) {\n\n                    /* If this transmit is not because of a Dtim Expiry q it */\n                    if (ar->DTIMExpired == false) {\n                        bool isMcastqEmpty = false;\n\n                        A_MUTEX_LOCK(&ar->mcastpsqLock);\n                        isMcastqEmpty = A_NETBUF_QUEUE_EMPTY(&ar->mcastpsq);\n                        A_NETBUF_ENQUEUE(&ar->mcastpsq, skb);\n                        A_MUTEX_UNLOCK(&ar->mcastpsqLock);\n\n                        /* If this is the first Mcast pkt getting queued\n                         * indicate to the target to set the BitmapControl LSB\n                         * of the TIM IE.\n                         */\n                        if (isMcastqEmpty) {\n                             wmi_set_pvb_cmd(ar->arWmi, MCAST_AID, 1);\n                        }\n                        return 0;\n                    } else {\n                     /* This transmit is because of Dtim expiry. Determine if\n                      * MoreData bit has to be set.\n                      */\n                         A_MUTEX_LOCK(&ar->mcastpsqLock);\n                         if(!A_NETBUF_QUEUE_EMPTY(&ar->mcastpsq)) {\n                             bMoreData = true;\n                         }\n                         A_MUTEX_UNLOCK(&ar->mcastpsqLock);\n                    }\n                }\n            } else {\n                conn = ieee80211_find_conn(ar, datap->dstMac);\n                if (conn) {\n                    if (STA_IS_PWR_SLEEP(conn)) {\n                        /* If this transmit is not because of a PsPoll q it*/\n                        if (!STA_IS_PS_POLLED(conn)) {\n                            bool isPsqEmpty = false;\n                            /* Queue the frames if the STA is sleeping */\n                            A_MUTEX_LOCK(&conn->psqLock);\n                            isPsqEmpty = A_NETBUF_QUEUE_EMPTY(&conn->psq);\n                            A_NETBUF_ENQUEUE(&conn->psq, skb);\n                            A_MUTEX_UNLOCK(&conn->psqLock);\n\n                            /* If this is the first pkt getting queued\n                             * for this STA, update the PVB for this STA\n                             */\n                            if (isPsqEmpty) {\n                                wmi_set_pvb_cmd(ar->arWmi, conn->aid, 1);\n                            }\n\n                            return 0;\n                         } else {\n                         /* This tx is because of a PsPoll. Determine if\n                          * MoreData bit has to be set\n                          */\n                             A_MUTEX_LOCK(&conn->psqLock);\n                             if (!A_NETBUF_QUEUE_EMPTY(&conn->psq)) {\n                                 bMoreData = true;\n                             }\n                             A_MUTEX_UNLOCK(&conn->psqLock);\n                         }\n                    }\n                } else {\n\n                    /* non existent STA. drop the frame */\n                    A_NETBUF_FREE(skb);\n                    return 0;\n                }\n            }\n        }\n\n        if (ar->arWmiEnabled) {\n        u8 csumStart=0;\n        u8 csumDest=0;\n        u8 csum=skb->ip_summed;\n        if(csumOffload && (csum==CHECKSUM_PARTIAL)){\n            csumStart = (skb->head + skb->csum_start - skb_network_header(skb) +\n\t\t\t sizeof(ATH_LLC_SNAP_HDR));\n            csumDest=skb->csum_offset+csumStart;\n        }\n            if (A_NETBUF_HEADROOM(skb) < dev->hard_header_len - LINUX_HACK_FUDGE_FACTOR) {\n                struct sk_buff  *newbuf;\n\n                /*\n                 * We really should have gotten enough headroom but sometimes\n                 * we still get packets with not enough headroom.  Copy the packet.\n                 */\n                len = A_NETBUF_LEN(skb);\n                newbuf = A_NETBUF_ALLOC(len);\n                if (newbuf == NULL) {\n                    break;\n                }\n                A_NETBUF_PUT(newbuf, len);\n                memcpy(A_NETBUF_DATA(newbuf), A_NETBUF_DATA(skb), len);\n                A_NETBUF_FREE(skb);\n                skb = newbuf;\n                /* fall through and assemble header */\n            }\n\n            if (dot11Hdr) {\n                if (wmi_dot11_hdr_add(ar->arWmi,skb,ar->arNetworkType) != 0) {\n                    AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_data_tx-wmi_dot11_hdr_add failed\\n\"));\n                    break;\n                }\n            } else {\n                if (wmi_dix_2_dot3(ar->arWmi, skb) != 0) {\n                    AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_data_tx - wmi_dix_2_dot3 failed\\n\"));\n                    break;\n                }\n            }\n            if(csumOffload && (csum ==CHECKSUM_PARTIAL)){\n                WMI_TX_META_V2  metaV2;\n                metaV2.csumStart =csumStart;\n                metaV2.csumDest = csumDest;\n                metaV2.csumFlags = 0x1;/*instruct target to calculate checksum*/\n                if (wmi_data_hdr_add(ar->arWmi, skb, DATA_MSGTYPE, bMoreData, dot11Hdr,\n                                        WMI_META_VERSION_2,&metaV2) != 0) {\n                    AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_data_tx - wmi_data_hdr_add failed\\n\"));\n                    break;\n                }\n\n            }\n            else\n            {\n                if (wmi_data_hdr_add(ar->arWmi, skb, DATA_MSGTYPE, bMoreData, dot11Hdr,0,NULL) != 0) {\n                    AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_data_tx - wmi_data_hdr_add failed\\n\"));\n                    break;\n                }\n            }\n\n\n            if ((ar->arNetworkType == ADHOC_NETWORK) &&\n                ar->arIbssPsEnable && ar->arConnected) {\n                    /* flag to check adhoc mapping once we take the lock below: */\n                checkAdHocPsMapping = true;\n\n            } else {\n                    /* get the stream mapping */\n                ac  =  wmi_implicit_create_pstream(ar->arWmi, skb, 0, ar->arWmmEnabled);\n            }\n\n        } else {\n            EPPING_HEADER    *eppingHdr;\n\n            eppingHdr = A_NETBUF_DATA(skb);\n\n            if (IS_EPPING_PACKET(eppingHdr)) {\n                    /* the stream ID is mapped to an access class */\n                ac = eppingHdr->StreamNo_h;\n                    /* some EPPING packets cannot be dropped no matter what access class it was\n                     * sent on.  We can change the packet tag to guarantee it will not get dropped */\n                if (IS_EPING_PACKET_NO_DROP(eppingHdr)) {\n                    htc_tag = AR6K_CONTROL_PKT_TAG;\n                }\n\n                if (ac == HCI_TRANSPORT_STREAM_NUM) {\n                        /* pass this to HCI */\n#ifndef EXPORT_HCI_BRIDGE_INTERFACE\n                    if (!hci_test_send(ar,skb)) {\n                        return 0;\n                    }\n#endif\n                        /* set AC to discard this skb */\n                    ac = AC_NOT_MAPPED;\n                } else {\n                    /* a quirk of linux, the payload of the frame is 32-bit aligned and thus the addition\n                     * of the HTC header will mis-align the start of the HTC frame, so we add some\n                     * padding which will be stripped off in the target */\n                    if (EPPING_ALIGNMENT_PAD > 0) {\n                        A_NETBUF_PUSH(skb, EPPING_ALIGNMENT_PAD);\n                    }\n                }\n\n            } else {\n                    /* not a ping packet, drop it */\n                ac = AC_NOT_MAPPED;\n            }\n        }\n\n    } while (false);\n\n        /* did we succeed ? */\n    if ((ac == AC_NOT_MAPPED) && !checkAdHocPsMapping) {\n            /* cleanup and exit */\n        A_NETBUF_FREE(skb);\n        AR6000_STAT_INC(ar, tx_dropped);\n        AR6000_STAT_INC(ar, tx_aborted_errors);\n        return 0;\n    }\n\n    cookie = NULL;\n\n        /* take the lock to protect driver data */\n    AR6000_SPIN_LOCK(&ar->arLock, 0);\n\n    do {\n\n        if (checkAdHocPsMapping) {\n            eid = ar6000_ibss_map_epid(skb, dev, &mapNo);\n        }else {\n            eid = arAc2EndpointID (ar, ac);\n        }\n            /* validate that the endpoint is connected */\n        if (eid == 0 || eid == ENDPOINT_UNUSED ) {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\" eid %d is NOT mapped!\\n\", eid));\n            break;\n        }\n            /* allocate resource for this packet */\n        cookie = ar6000_alloc_cookie(ar);\n\n        if (cookie != NULL) {\n                /* update counts while the lock is held */\n            ar->arTxPending[eid]++;\n            ar->arTotalTxDataPending++;\n        }\n\n    } while (false);\n\n    AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n\n    if (cookie != NULL) {\n        cookie->arc_bp[0] = (unsigned long)skb;\n        cookie->arc_bp[1] = mapNo;\n        SET_HTC_PACKET_INFO_TX(&cookie->HtcPkt,\n                               cookie,\n                               A_NETBUF_DATA(skb),\n                               A_NETBUF_LEN(skb),\n                               eid,\n                               htc_tag);\n\n#ifdef DEBUG\n        if (debugdriver >= 3) {\n            ar6000_dump_skb(skb);\n        }\n#endif\n#ifdef HTC_TEST_SEND_PKTS\n        DoHTCSendPktsTest(ar,mapNo,eid,skb);\n#endif\n            /* HTC interface is asynchronous, if this fails, cleanup will happen in\n             * the ar6000_tx_complete callback */\n        HTCSendPkt(ar->arHtcTarget, &cookie->HtcPkt);\n    } else {\n            /* no packet to send, cleanup */\n        A_NETBUF_FREE(skb);\n        AR6000_STAT_INC(ar, tx_dropped);\n        AR6000_STAT_INC(ar, tx_aborted_errors);\n    }\n\n    return 0;\n}\n\nint\nar6000_acl_data_tx(struct sk_buff *skb, struct net_device *dev)\n{\n    struct ar6_softc        *ar = (struct ar6_softc *)ar6k_priv(dev);\n    struct ar_cookie *cookie;\n    HTC_ENDPOINT_ID    eid = ENDPOINT_UNUSED;\n\n    cookie = NULL;\n    AR6000_SPIN_LOCK(&ar->arLock, 0);\n\n        /* For now we send ACL on BE endpoint: We can also have a dedicated EP */\n        eid = arAc2EndpointID (ar, 0);\n        /* allocate resource for this packet */\n        cookie = ar6000_alloc_cookie(ar);\n\n        if (cookie != NULL) {\n            /* update counts while the lock is held */\n            ar->arTxPending[eid]++;\n            ar->arTotalTxDataPending++;\n        }\n\n\n    AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n\n        if (cookie != NULL) {\n            cookie->arc_bp[0] = (unsigned long)skb;\n            cookie->arc_bp[1] = 0;\n            SET_HTC_PACKET_INFO_TX(&cookie->HtcPkt,\n                            cookie,\n                            A_NETBUF_DATA(skb),\n                            A_NETBUF_LEN(skb),\n                            eid,\n                            AR6K_DATA_PKT_TAG);\n\n            /* HTC interface is asynchronous, if this fails, cleanup will happen in\n             * the ar6000_tx_complete callback */\n            HTCSendPkt(ar->arHtcTarget, &cookie->HtcPkt);\n        } else {\n            /* no packet to send, cleanup */\n            A_NETBUF_FREE(skb);\n            AR6000_STAT_INC(ar, tx_dropped);\n            AR6000_STAT_INC(ar, tx_aborted_errors);\n        }\n    return 0;\n}\n\n\n#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL\nstatic void\ntvsub(register struct timeval *out, register struct timeval *in)\n{\n    if((out->tv_usec -= in->tv_usec) < 0) {\n        out->tv_sec--;\n        out->tv_usec += 1000000;\n    }\n    out->tv_sec -= in->tv_sec;\n}\n\nvoid\napplyAPTCHeuristics(struct ar6_softc *ar)\n{\n    u32 duration;\n    u32 numbytes;\n    u32 throughput;\n    struct timeval ts;\n    int status;\n\n    AR6000_SPIN_LOCK(&ar->arLock, 0);\n\n    if ((enableAPTCHeuristics) && (!aptcTR.timerScheduled)) {\n        do_gettimeofday(&ts);\n        tvsub(&ts, &aptcTR.samplingTS);\n        duration = ts.tv_sec * 1000 + ts.tv_usec / 1000; /* ms */\n        numbytes = aptcTR.bytesTransmitted + aptcTR.bytesReceived;\n\n        if (duration > APTC_TRAFFIC_SAMPLING_INTERVAL) {\n            /* Initialize the time stamp and byte count */\n            aptcTR.bytesTransmitted = aptcTR.bytesReceived = 0;\n            do_gettimeofday(&aptcTR.samplingTS);\n\n            /* Calculate and decide based on throughput thresholds */\n            throughput = ((numbytes * 8) / duration);\n            if (throughput > APTC_UPPER_THROUGHPUT_THRESHOLD) {\n                /* Disable Sleep and schedule a timer */\n                A_ASSERT(ar->arWmiReady == true);\n                AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n                status = wmi_powermode_cmd(ar->arWmi, MAX_PERF_POWER);\n                AR6000_SPIN_LOCK(&ar->arLock, 0);\n                A_TIMEOUT_MS(&aptcTimer, APTC_TRAFFIC_SAMPLING_INTERVAL, 0);\n                aptcTR.timerScheduled = true;\n            }\n        }\n    }\n\n    AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n}\n#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */\n\nstatic HTC_SEND_FULL_ACTION ar6000_tx_queue_full(void *Context, struct htc_packet *pPacket)\n{\n    struct ar6_softc     *ar = (struct ar6_softc *)Context;\n    HTC_SEND_FULL_ACTION    action = HTC_SEND_FULL_KEEP;\n    bool                  stopNet = false;\n    HTC_ENDPOINT_ID         Endpoint = HTC_GET_ENDPOINT_FROM_PKT(pPacket);\n\n    do {\n\n        if (bypasswmi) {\n            int accessClass;\n\n            if (HTC_GET_TAG_FROM_PKT(pPacket) == AR6K_CONTROL_PKT_TAG) {\n                    /* don't drop special control packets */\n                break;\n            }\n\n            accessClass = arEndpoint2Ac(ar,Endpoint);\n                /* for endpoint ping testing drop Best Effort and Background */\n            if ((accessClass == WMM_AC_BE) || (accessClass == WMM_AC_BK)) {\n                action = HTC_SEND_FULL_DROP;\n                stopNet = false;\n            } else {\n                    /* keep but stop the netqueues */\n                stopNet = true;\n            }\n            break;\n        }\n\n        if (Endpoint == ar->arControlEp) {\n                /* under normal WMI if this is getting full, then something is running rampant\n                 * the host should not be exhausting the WMI queue with too many commands\n                 * the only exception to this is during testing using endpointping */\n            AR6000_SPIN_LOCK(&ar->arLock, 0);\n                /* set flag to handle subsequent messages */\n            ar->arWMIControlEpFull = true;\n            AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"WMI Control Endpoint is FULL!!! \\n\"));\n                /* no need to stop the network */\n            stopNet = false;\n            break;\n        }\n\n        /* if we get here, we are dealing with data endpoints getting full */\n\n        if (HTC_GET_TAG_FROM_PKT(pPacket) == AR6K_CONTROL_PKT_TAG) {\n            /* don't drop control packets issued on ANY data endpoint */\n            break;\n        }\n\n        if (ar->arNetworkType == ADHOC_NETWORK) {\n            /* in adhoc mode, we cannot differentiate traffic priorities so there is no need to\n             * continue, however we should stop the network */\n            stopNet = true;\n            break;\n        }\n        /* the last MAX_HI_COOKIE_NUM \"batch\" of cookies are reserved for the highest\n         * active stream */\n        if (ar->arAcStreamPriMap[arEndpoint2Ac(ar,Endpoint)] < ar->arHiAcStreamActivePri &&\n            ar->arCookieCount <= MAX_HI_COOKIE_NUM) {\n                /* this stream's priority is less than the highest active priority, we\n                 * give preference to the highest priority stream by directing\n                 * HTC to drop the packet that overflowed */\n            action = HTC_SEND_FULL_DROP;\n                /* since we are dropping packets, no need to stop the network */\n            stopNet = false;\n            break;\n        }\n\n    } while (false);\n\n    if (stopNet) {\n        AR6000_SPIN_LOCK(&ar->arLock, 0);\n        ar->arNetQueueStopped = true;\n        AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n        /* one of the data endpoints queues is getting full..need to stop network stack\n         * the queue will resume in ar6000_tx_complete() */\n        netif_stop_queue(ar->arNetDev);\n    }\n\n    return action;\n}\n\n\nstatic void\nar6000_tx_complete(void *Context, struct htc_packet_queue *pPacketQueue)\n{\n    struct ar6_softc     *ar = (struct ar6_softc *)Context;\n    u32 mapNo = 0;\n    int        status;\n    struct ar_cookie * ar_cookie;\n    HTC_ENDPOINT_ID   eid;\n    bool          wakeEvent = false;\n    struct sk_buff_head  skb_queue;\n    struct htc_packet      *pPacket;\n    struct sk_buff  *pktSkb;\n    bool          flushing = false;\n\n    skb_queue_head_init(&skb_queue);\n\n        /* lock the driver as we update internal state */\n    AR6000_SPIN_LOCK(&ar->arLock, 0);\n\n        /* reap completed packets */\n    while (!HTC_QUEUE_EMPTY(pPacketQueue)) {\n\n        pPacket = HTC_PACKET_DEQUEUE(pPacketQueue);\n\n        ar_cookie = (struct ar_cookie *)pPacket->pPktContext;\n        A_ASSERT(ar_cookie);\n\n        status = pPacket->Status;\n        pktSkb = (struct sk_buff *)ar_cookie->arc_bp[0];\n        eid = pPacket->Endpoint;\n        mapNo = ar_cookie->arc_bp[1];\n\n        A_ASSERT(pktSkb);\n        A_ASSERT(pPacket->pBuffer == A_NETBUF_DATA(pktSkb));\n\n            /* add this to the list, use faster non-lock API */\n        __skb_queue_tail(&skb_queue,pktSkb);\n\n        if (!status) {\n            A_ASSERT(pPacket->ActualLength == A_NETBUF_LEN(pktSkb));\n        }\n\n        AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_TX,(\"ar6000_tx_complete skb=0x%lx data=0x%lx len=0x%x eid=%d \",\n                         (unsigned long)pktSkb, (unsigned long)pPacket->pBuffer,\n                         pPacket->ActualLength,\n                         eid));\n\n        ar->arTxPending[eid]--;\n\n        if ((eid  != ar->arControlEp) || bypasswmi) {\n            ar->arTotalTxDataPending--;\n        }\n\n        if (eid == ar->arControlEp)\n        {\n            if (ar->arWMIControlEpFull) {\n                    /* since this packet completed, the WMI EP is no longer full */\n                ar->arWMIControlEpFull = false;\n            }\n\n            if (ar->arTxPending[eid] == 0) {\n                wakeEvent = true;\n            }\n        }\n\n        if (status) {\n            if (status == A_ECANCELED) {\n                    /* a packet was flushed  */\n                flushing = true;\n            }\n            AR6000_STAT_INC(ar, tx_errors);\n            if (status != A_NO_RESOURCE) {\n                AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"%s() -TX ERROR, status: 0x%x\\n\", __func__,\n                            status));\n            }\n        } else {\n            AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_TX,(\"OK\\n\"));\n            flushing = false;\n            AR6000_STAT_INC(ar, tx_packets);\n            ar->arNetStats.tx_bytes += A_NETBUF_LEN(pktSkb);\n#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL\n            aptcTR.bytesTransmitted += a_netbuf_to_len(pktSkb);\n            applyAPTCHeuristics(ar);\n#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */\n        }\n\n        // TODO this needs to be looked at\n        if ((ar->arNetworkType == ADHOC_NETWORK) && ar->arIbssPsEnable\n            && (eid != ar->arControlEp) && mapNo)\n        {\n            mapNo --;\n            ar->arNodeMap[mapNo].txPending --;\n\n            if (!ar->arNodeMap[mapNo].txPending && (mapNo == (ar->arNodeNum - 1))) {\n                u32 i;\n                for (i = ar->arNodeNum; i > 0; i --) {\n                    if (!ar->arNodeMap[i - 1].txPending) {\n                        A_MEMZERO(&ar->arNodeMap[i - 1], sizeof(struct ar_node_mapping));\n                        ar->arNodeNum --;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n\n        ar6000_free_cookie(ar, ar_cookie);\n\n        if (ar->arNetQueueStopped) {\n            ar->arNetQueueStopped = false;\n        }\n    }\n\n    AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n\n    /* lock is released, we can freely call other kernel APIs */\n\n        /* free all skbs in our local list */\n    while (!skb_queue_empty(&skb_queue)) {\n            /* use non-lock version */\n        pktSkb = __skb_dequeue(&skb_queue);\n        A_NETBUF_FREE(pktSkb);\n    }\n\n    if ((ar->arConnected == true) || bypasswmi) {\n        if (!flushing) {\n                /* don't wake the queue if we are flushing, other wise it will just\n                 * keep queueing packets, which will keep failing */\n            netif_wake_queue(ar->arNetDev);\n        }\n    }\n\n    if (wakeEvent) {\n        wake_up(&arEvent);\n    }\n\n}\n\nsta_t *\nieee80211_find_conn(struct ar6_softc *ar, u8 *node_addr)\n{\n    sta_t *conn = NULL;\n    u8 i, max_conn;\n\n    switch(ar->arNetworkType) {\n        case AP_NETWORK:\n            max_conn = AP_MAX_NUM_STA;\n            break;\n        default:\n            max_conn=0;\n            break;\n    }\n\n    for (i = 0; i < max_conn; i++) {\n        if (IEEE80211_ADDR_EQ(node_addr, ar->sta_list[i].mac)) {\n            conn = &ar->sta_list[i];\n            break;\n        }\n    }\n\n    return conn;\n}\n\nsta_t *ieee80211_find_conn_for_aid(struct ar6_softc *ar, u8 aid)\n{\n    sta_t *conn = NULL;\n    u8 ctr;\n\n    for (ctr = 0; ctr < AP_MAX_NUM_STA; ctr++) {\n        if (ar->sta_list[ctr].aid == aid) {\n            conn = &ar->sta_list[ctr];\n            break;\n        }\n    }\n    return conn;\n}\n\n/*\n * Receive event handler.  This is called by HTC when a packet is received\n */\nint pktcount;\nstatic void\nar6000_rx(void *Context, struct htc_packet *pPacket)\n{\n    struct ar6_softc *ar = (struct ar6_softc *)Context;\n    struct sk_buff *skb = (struct sk_buff *)pPacket->pPktContext;\n    int minHdrLen;\n    u8 containsDot11Hdr = 0;\n    int        status = pPacket->Status;\n    HTC_ENDPOINT_ID   ept = pPacket->Endpoint;\n\n    A_ASSERT((status) ||\n             (pPacket->pBuffer == (A_NETBUF_DATA(skb) + HTC_HEADER_LEN)));\n\n    AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_RX,(\"ar6000_rx ar=0x%lx eid=%d, skb=0x%lx, data=0x%lx, len=0x%x status:%d\",\n                    (unsigned long)ar, ept, (unsigned long)skb, (unsigned long)pPacket->pBuffer,\n                    pPacket->ActualLength, status));\n    if (status) {\n        if (status != A_ECANCELED) {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"RX ERR (%d) \\n\",status));\n        }\n    }\n\n        /* take lock to protect buffer counts\n         * and adaptive power throughput state */\n    AR6000_SPIN_LOCK(&ar->arLock, 0);\n\n    if (!status) {\n        AR6000_STAT_INC(ar, rx_packets);\n        ar->arNetStats.rx_bytes += pPacket->ActualLength;\n#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL\n        aptcTR.bytesReceived += a_netbuf_to_len(skb);\n        applyAPTCHeuristics(ar);\n#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */\n\n        A_NETBUF_PUT(skb, pPacket->ActualLength +  HTC_HEADER_LEN);\n        A_NETBUF_PULL(skb, HTC_HEADER_LEN);\n\n#ifdef DEBUG\n        if (debugdriver >= 2) {\n            ar6000_dump_skb(skb);\n        }\n#endif /* DEBUG */\n    }\n\n    AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n\n    skb->dev = ar->arNetDev;\n    if (status) {\n        AR6000_STAT_INC(ar, rx_errors);\n        A_NETBUF_FREE(skb);\n    } else if (ar->arWmiEnabled == true) {\n        if (ept == ar->arControlEp) {\n           /*\n            * this is a wmi control msg\n            */\n#ifdef CONFIG_PM \n            ar6000_check_wow_status(ar, skb, true);\n#endif /* CONFIG_PM */\n            wmi_control_rx(ar->arWmi, skb);\n        } else {\n                WMI_DATA_HDR *dhdr = (WMI_DATA_HDR *)A_NETBUF_DATA(skb);\n                bool is_amsdu;\n                u8 tid;\n\n\t\t/*\n\t\t * This check can be removed if after a while we do not\n\t\t * see the warning. For now we leave it to ensure\n\t\t * we drop these frames accordingly in case the\n\t\t * target generates them for some reason. These\n\t\t * were used for an internal PAL but that's not\n\t\t * used or supported anymore. These frames should\n\t\t * not come up from the target.\n\t\t */\n                if (WARN_ON(WMI_DATA_HDR_GET_DATA_TYPE(dhdr) ==\n\t\t\t    WMI_DATA_HDR_DATA_TYPE_ACL)) {\n\t\t\tAR6000_STAT_INC(ar, rx_errors);\n\t\t\tA_NETBUF_FREE(skb);\n\t\t\treturn;\n\t\t}\n\n#ifdef CONFIG_PM \n                ar6000_check_wow_status(ar, NULL, false);\n#endif /* CONFIG_PM */\n                /*\n                 * this is a wmi data packet\n                 */\n                 // NWF\n\n                if (processDot11Hdr) {\n                    minHdrLen = sizeof(WMI_DATA_HDR) + sizeof(struct ieee80211_frame) + sizeof(ATH_LLC_SNAP_HDR);\n                } else {\n                    minHdrLen = sizeof (WMI_DATA_HDR) + sizeof(ATH_MAC_HDR) +\n                          sizeof(ATH_LLC_SNAP_HDR);\n                }\n\n                /* In the case of AP mode we may receive NULL data frames\n                 * that do not have LLC hdr. They are 16 bytes in size.\n                 * Allow these frames in the AP mode.\n                 * ACL data frames don't follow ethernet frame bounds for\n                 * min length\n                 */\n                if (ar->arNetworkType != AP_NETWORK &&\n                    ((pPacket->ActualLength < minHdrLen) ||\n                    (pPacket->ActualLength > AR6000_MAX_RX_MESSAGE_SIZE)))\n                {\n                    /*\n                     * packet is too short or too long\n                     */\n                    AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"TOO SHORT or TOO LONG\\n\"));\n                    AR6000_STAT_INC(ar, rx_errors);\n                    AR6000_STAT_INC(ar, rx_length_errors);\n                    A_NETBUF_FREE(skb);\n                } else {\n                    u16 seq_no;\n                    u8 meta_type;\n\n#if 0\n                    /* Access RSSI values here */\n                    AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"RSSI %d\\n\",\n                        ((WMI_DATA_HDR *) A_NETBUF_DATA(skb))->rssi));\n#endif\n                    /* Get the Power save state of the STA */\n                    if (ar->arNetworkType == AP_NETWORK) {\n                        sta_t *conn = NULL;\n                        u8 psState=0,prevPsState;\n                        ATH_MAC_HDR *datap=NULL;\n                        u16 offset;\n\n                        meta_type = WMI_DATA_HDR_GET_META(dhdr);\n\n                        psState = (((WMI_DATA_HDR *)A_NETBUF_DATA(skb))->info\n                                     >> WMI_DATA_HDR_PS_SHIFT) & WMI_DATA_HDR_PS_MASK;\n\n                        offset = sizeof(WMI_DATA_HDR);\n\n                        switch (meta_type) {\n                            case 0:\n                                break;\n                            case WMI_META_VERSION_1:\n                                offset += sizeof(WMI_RX_META_V1);\n                                break;\n                            case WMI_META_VERSION_2:\n                                offset += sizeof(WMI_RX_META_V2);\n                                break;\n                            default:\n                                break;\n                        }\n\n                        datap = (ATH_MAC_HDR *)(A_NETBUF_DATA(skb)+offset);\n                        conn = ieee80211_find_conn(ar, datap->srcMac);\n\n                        if (conn) {\n                            /* if there is a change in PS state of the STA,\n                             * take appropriate steps.\n                             * 1. If Sleep-->Awake, flush the psq for the STA\n                             *    Clear the PVB for the STA.\n                             * 2. If Awake-->Sleep, Starting queueing frames\n                             * the STA.\n                             */\n                            prevPsState = STA_IS_PWR_SLEEP(conn);\n                            if (psState) {\n                                STA_SET_PWR_SLEEP(conn);\n                            } else {\n                                STA_CLR_PWR_SLEEP(conn);\n                            }\n\n                            if (prevPsState ^ STA_IS_PWR_SLEEP(conn)) {\n\n                                if (!STA_IS_PWR_SLEEP(conn)) {\n\n                                    A_MUTEX_LOCK(&conn->psqLock);\n                                    while (!A_NETBUF_QUEUE_EMPTY(&conn->psq)) {\n                                        struct sk_buff *skb=NULL;\n\n                                        skb = A_NETBUF_DEQUEUE(&conn->psq);\n                                        A_MUTEX_UNLOCK(&conn->psqLock);\n                                        ar6000_data_tx(skb,ar->arNetDev);\n                                        A_MUTEX_LOCK(&conn->psqLock);\n                                    }\n                                    A_MUTEX_UNLOCK(&conn->psqLock);\n                                    /* Clear the PVB for this STA */\n                                    wmi_set_pvb_cmd(ar->arWmi, conn->aid, 0);\n                                }\n                            }\n                        } else {\n                            /* This frame is from a STA that is not associated*/\n                            A_ASSERT(false);\n                        }\n\n                        /* Drop NULL data frames here */\n                        if((pPacket->ActualLength < minHdrLen) ||\n                                (pPacket->ActualLength > AR6000_MAX_RX_MESSAGE_SIZE)) {\n                            A_NETBUF_FREE(skb);\n                            goto rx_done;\n                        }\n                    }\n\n                    is_amsdu = WMI_DATA_HDR_IS_AMSDU(dhdr) ? true : false;\n                    tid = WMI_DATA_HDR_GET_UP(dhdr);\n                    seq_no = WMI_DATA_HDR_GET_SEQNO(dhdr);\n                    meta_type = WMI_DATA_HDR_GET_META(dhdr);\n                    containsDot11Hdr = WMI_DATA_HDR_GET_DOT11(dhdr);\n\n                    wmi_data_hdr_remove(ar->arWmi, skb);\n\n                    switch (meta_type) {\n                        case WMI_META_VERSION_1:\n                            {\n                                WMI_RX_META_V1 *pMeta = (WMI_RX_META_V1 *)A_NETBUF_DATA(skb);\n                                A_PRINTF(\"META %d %d %d %d %x\\n\", pMeta->status, pMeta->rix, pMeta->rssi, pMeta->channel, pMeta->flags);\n                                A_NETBUF_PULL((void*)skb, sizeof(WMI_RX_META_V1));\n                                break;\n                            }\n                        case WMI_META_VERSION_2:\n                            {\n                                WMI_RX_META_V2 *pMeta = (WMI_RX_META_V2 *)A_NETBUF_DATA(skb);\n                                if(pMeta->csumFlags & 0x1){\n                                    skb->ip_summed=CHECKSUM_COMPLETE;\n                                    skb->csum=(pMeta->csum);\n                                }\n                                A_NETBUF_PULL((void*)skb, sizeof(WMI_RX_META_V2));\n                                break;\n                            }\n                        default:\n                            break;\n                    }\n\n                    A_ASSERT(status == 0);\n\n                    /* NWF: print the 802.11 hdr bytes */\n                    if(containsDot11Hdr) {\n                        status = wmi_dot11_hdr_remove(ar->arWmi,skb);\n                    } else if(!is_amsdu) {\n                        status = wmi_dot3_2_dix(skb);\n                    }\n\n                    if (status) {\n                        /* Drop frames that could not be processed (lack of memory, etc.) */\n                        A_NETBUF_FREE(skb);\n                        goto rx_done;\n                    }\n\n                    if ((ar->arNetDev->flags & IFF_UP) == IFF_UP) {\n                        if (ar->arNetworkType == AP_NETWORK) {\n                            struct sk_buff *skb1 = NULL;\n                            ATH_MAC_HDR *datap;\n\n                            datap = (ATH_MAC_HDR *)A_NETBUF_DATA(skb);\n                            if (IEEE80211_IS_MULTICAST(datap->dstMac)) {\n                                /* Bcast/Mcast frames should be sent to the OS\n                                 * stack as well as on the air.\n                                 */\n                                skb1 = skb_copy(skb,GFP_ATOMIC);\n                            } else {\n                                /* Search for a connected STA with dstMac as\n                                 * the Mac address. If found send the frame to\n                                 * it on the air else send the frame up the\n                                 * stack\n                                 */\n                                sta_t *conn = NULL;\n                                conn = ieee80211_find_conn(ar, datap->dstMac);\n\n                                if (conn && ar->intra_bss) {\n                                    skb1 = skb;\n                                    skb = NULL;\n                                } else if(conn && !ar->intra_bss) {\n                                    A_NETBUF_FREE(skb);\n                                    skb = NULL;\n                                }\n                            }\n                            if (skb1) {\n                                ar6000_data_tx(skb1, ar->arNetDev);\n                            }\n                        }\n                    }\n                    aggr_process_recv_frm(ar->aggr_cntxt, tid, seq_no, is_amsdu, (void **)&skb);\n                    ar6000_deliver_frames_to_nw_stack((void *) ar->arNetDev, (void *)skb);\n                }\n            }\n    } else {\n        if (EPPING_ALIGNMENT_PAD > 0) {\n            A_NETBUF_PULL(skb, EPPING_ALIGNMENT_PAD);\n        }\n        ar6000_deliver_frames_to_nw_stack((void *)ar->arNetDev, (void *)skb);\n    }\n\nrx_done:\n\n    return;\n}\n\nstatic void\nar6000_deliver_frames_to_nw_stack(void *dev, void *osbuf)\n{\n    struct sk_buff *skb = (struct sk_buff *)osbuf;\n\n    if(skb) {\n        skb->dev = dev;\n        if ((skb->dev->flags & IFF_UP) == IFF_UP) {\n#ifdef CONFIG_PM \n            ar6000_check_wow_status((struct ar6_softc *)ar6k_priv(dev), skb, false);\n#endif /* CONFIG_PM */\n            skb->protocol = eth_type_trans(skb, skb->dev);\n        /*\n         * If this routine is called on a ISR (Hard IRQ) or DSR (Soft IRQ)\n         * or tasklet use the netif_rx to deliver the packet to the stack\n         * netif_rx will queue the packet onto the receive queue and mark\n         * the softirq thread has a pending action to complete. Kernel will \n         * schedule the softIrq kernel thread after processing the DSR.\n         *\n         * If this routine is called on a process context, use netif_rx_ni\n         * which will schedle the softIrq kernel thread after queuing the packet.\n         */\n            if (in_interrupt()) {\n                netif_rx(skb);\n            } else {\n                netif_rx_ni(skb);\n            }\n        } else {\n            A_NETBUF_FREE(skb);\n        }\n    }\n}\n\n#if 0\nstatic void\nar6000_deliver_frames_to_bt_stack(void *dev, void *osbuf)\n{\n    struct sk_buff *skb = (struct sk_buff *)osbuf;\n\n    if(skb) {\n        skb->dev = dev;\n        if ((skb->dev->flags & IFF_UP) == IFF_UP) {\n            skb->protocol = htons(ETH_P_CONTROL);\n            netif_rx(skb);\n        } else {\n            A_NETBUF_FREE(skb);\n        }\n    }\n}\n#endif\n\nstatic void\nar6000_rx_refill(void *Context, HTC_ENDPOINT_ID Endpoint)\n{\n    struct ar6_softc  *ar = (struct ar6_softc *)Context;\n    void        *osBuf;\n    int         RxBuffers;\n    int         buffersToRefill;\n    struct htc_packet  *pPacket;\n    struct htc_packet_queue queue;\n\n    buffersToRefill = (int)AR6000_MAX_RX_BUFFERS -\n                                    HTCGetNumRecvBuffers(ar->arHtcTarget, Endpoint);\n\n    if (buffersToRefill <= 0) {\n            /* fast return, nothing to fill */\n        return;\n    }\n\n    INIT_HTC_PACKET_QUEUE(&queue);\n\n    AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_RX,(\"ar6000_rx_refill: providing htc with %d buffers at eid=%d\\n\",\n                    buffersToRefill, Endpoint));\n\n    for (RxBuffers = 0; RxBuffers < buffersToRefill; RxBuffers++) {\n        osBuf = A_NETBUF_ALLOC(AR6000_BUFFER_SIZE);\n        if (NULL == osBuf) {\n            break;\n        }\n            /* the HTC packet wrapper is at the head of the reserved area\n             * in the skb */\n        pPacket = (struct htc_packet *)(A_NETBUF_HEAD(osBuf));\n            /* set re-fill info */\n        SET_HTC_PACKET_INFO_RX_REFILL(pPacket,osBuf,A_NETBUF_DATA(osBuf),AR6000_BUFFER_SIZE,Endpoint);\n            /* add to queue */\n        HTC_PACKET_ENQUEUE(&queue,pPacket);\n    }\n\n    if (!HTC_QUEUE_EMPTY(&queue)) {\n            /* add packets */\n        HTCAddReceivePktMultiple(ar->arHtcTarget, &queue);\n    }\n\n}\n\n  /* clean up our amsdu buffer list */\nstatic void ar6000_cleanup_amsdu_rxbufs(struct ar6_softc *ar)\n{\n    struct htc_packet  *pPacket;\n    void        *osBuf;\n\n        /* empty AMSDU buffer queue and free OS bufs */\n    while (true) {\n\n        AR6000_SPIN_LOCK(&ar->arLock, 0);\n        pPacket = HTC_PACKET_DEQUEUE(&ar->amsdu_rx_buffer_queue);\n        AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n\n        if (NULL == pPacket) {\n            break;\n        }\n\n        osBuf = pPacket->pPktContext;\n        if (NULL == osBuf) {\n            A_ASSERT(false);\n            break;\n        }\n\n        A_NETBUF_FREE(osBuf);\n    }\n\n}\n\n\n    /* refill the amsdu buffer list */\nstatic void ar6000_refill_amsdu_rxbufs(struct ar6_softc *ar, int Count)\n{\n    struct htc_packet  *pPacket;\n    void        *osBuf;\n\n    while (Count > 0) {\n        osBuf = A_NETBUF_ALLOC(AR6000_AMSDU_BUFFER_SIZE);\n        if (NULL == osBuf) {\n            break;\n        }\n            /* the HTC packet wrapper is at the head of the reserved area\n             * in the skb */\n        pPacket = (struct htc_packet *)(A_NETBUF_HEAD(osBuf));\n            /* set re-fill info */\n        SET_HTC_PACKET_INFO_RX_REFILL(pPacket,osBuf,A_NETBUF_DATA(osBuf),AR6000_AMSDU_BUFFER_SIZE,0);\n\n        AR6000_SPIN_LOCK(&ar->arLock, 0);\n            /* put it in the list */\n        HTC_PACKET_ENQUEUE(&ar->amsdu_rx_buffer_queue,pPacket);\n        AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n        Count--;\n    }\n\n}\n\n    /* callback to allocate a large receive buffer for a pending packet.  This function is called when\n     * an HTC packet arrives whose length exceeds a threshold value\n     *\n     * We use a pre-allocated list of buffers of maximum AMSDU size (4K).  Under linux it is more optimal to\n     * keep the allocation size the same to optimize cached-slab allocations.\n     *\n     * */\nstatic struct htc_packet *ar6000_alloc_amsdu_rxbuf(void *Context, HTC_ENDPOINT_ID Endpoint, int Length)\n{\n    struct htc_packet  *pPacket = NULL;\n    struct ar6_softc  *ar = (struct ar6_softc *)Context;\n    int         refillCount = 0;\n\n    AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_RX,(\"ar6000_alloc_amsdu_rxbuf: eid=%d, Length:%d\\n\",Endpoint,Length));\n\n    do {\n\n        if (Length <= AR6000_BUFFER_SIZE) {\n                /* shouldn't be getting called on normal sized packets */\n            A_ASSERT(false);\n            break;\n        }\n\n        if (Length > AR6000_AMSDU_BUFFER_SIZE) {\n            A_ASSERT(false);\n            break;\n        }\n\n        AR6000_SPIN_LOCK(&ar->arLock, 0);\n            /* allocate a packet from the list */\n        pPacket = HTC_PACKET_DEQUEUE(&ar->amsdu_rx_buffer_queue);\n            /* see if we need to refill again */\n        refillCount = AR6000_MAX_AMSDU_RX_BUFFERS - HTC_PACKET_QUEUE_DEPTH(&ar->amsdu_rx_buffer_queue);\n        AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n\n        if (NULL == pPacket) {\n            break;\n        }\n            /* set actual endpoint ID */\n        pPacket->Endpoint = Endpoint;\n\n    } while (false);\n\n    if (refillCount >= AR6000_AMSDU_REFILL_THRESHOLD) {\n        ar6000_refill_amsdu_rxbufs(ar,refillCount);\n    }\n\n    return pPacket;\n}\n\nstatic void\t\nar6000_set_multicast_list(struct net_device *dev)\n{\n    AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000: Multicast filter not supported\\n\"));\n}\n\nstatic struct net_device_stats *\nar6000_get_stats(struct net_device *dev)\n{\n    struct ar6_softc *ar = (struct ar6_softc *)ar6k_priv(dev);\n    return &ar->arNetStats;\n}\n\nvoid\nar6000_ready_event(void *devt, u8 *datap, u8 phyCap, u32 sw_ver, u32 abi_ver)\n{\n    struct ar6_softc *ar = (struct ar6_softc *)devt;\n    struct net_device *dev = ar->arNetDev;\n\n    memcpy(dev->dev_addr, datap, AR6000_ETH_ADDR_LEN);\n    AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"mac address = %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x\\n\",\n        dev->dev_addr[0], dev->dev_addr[1],\n        dev->dev_addr[2], dev->dev_addr[3],\n        dev->dev_addr[4], dev->dev_addr[5]));\n\n    ar->arPhyCapability = phyCap;\n    ar->arVersion.wlan_ver = sw_ver;\n    ar->arVersion.abi_ver = abi_ver;\n\n    /* Indicate to the waiting thread that the ready event was received */\n    ar->arWmiReady = true;\n    wake_up(&arEvent);\n}\n\nvoid ar6000_install_static_wep_keys(struct ar6_softc *ar)\n{\n    u8 index;\n    u8 keyUsage;\n\n    for (index = WMI_MIN_KEY_INDEX; index <= WMI_MAX_KEY_INDEX; index++) {\n        if (ar->arWepKeyList[index].arKeyLen) {\n            keyUsage = GROUP_USAGE;\n            if (index == ar->arDefTxKeyIndex) {\n                keyUsage |= TX_USAGE;\n            }\n            wmi_addKey_cmd(ar->arWmi,\n                           index,\n                           WEP_CRYPT,\n                           keyUsage,\n                           ar->arWepKeyList[index].arKeyLen,\n                           NULL,\n                           ar->arWepKeyList[index].arKey, KEY_OP_INIT_VAL, NULL,\n                           NO_SYNC_WMIFLAG);\n        }\n    }\n}\n\nvoid\nadd_new_sta(struct ar6_softc *ar, u8 *mac, u16 aid, u8 *wpaie,\n            u8 ielen, u8 keymgmt, u8 ucipher, u8 auth)\n{\n    u8 free_slot=aid-1;\n\n        memcpy(ar->sta_list[free_slot].mac, mac, ATH_MAC_LEN);\n        memcpy(ar->sta_list[free_slot].wpa_ie, wpaie, ielen);\n        ar->sta_list[free_slot].aid = aid;\n        ar->sta_list[free_slot].keymgmt = keymgmt;\n        ar->sta_list[free_slot].ucipher = ucipher;\n        ar->sta_list[free_slot].auth = auth;\n        ar->sta_list_index = ar->sta_list_index | (1 << free_slot);\n    ar->arAPStats.sta[free_slot].aid = aid;\n}\n\nvoid\nar6000_connect_event(struct ar6_softc *ar, u16 channel, u8 *bssid,\n                     u16 listenInterval, u16 beaconInterval,\n                     NETWORK_TYPE networkType, u8 beaconIeLen,\n                     u8 assocReqLen, u8 assocRespLen,\n                     u8 *assocInfo)\n{\n    union iwreq_data wrqu;\n    int i, beacon_ie_pos, assoc_resp_ie_pos, assoc_req_ie_pos;\n    static const char *tag1 = \"ASSOCINFO(ReqIEs=\";\n    static const char *tag2 = \"ASSOCRESPIE=\";\n    static const char *beaconIetag = \"BEACONIE=\";\n    char buf[WMI_CONTROL_MSG_MAX_LEN * 2 + strlen(tag1) + 1];\n    char *pos;\n    u8 key_op_ctrl;\n    unsigned long flags;\n    struct ieee80211req_key *ik;\n    CRYPTO_TYPE keyType = NONE_CRYPT;\n\n    if(ar->arNetworkType & AP_NETWORK) {\n        struct net_device *dev = ar->arNetDev;\n        if(memcmp(dev->dev_addr, bssid, ATH_MAC_LEN)==0) {\n            ar->arACS = channel;\n            ik = &ar->ap_mode_bkey;\n\n            switch(ar->arAuthMode) {\n            case NONE_AUTH:\n                if(ar->arPairwiseCrypto == WEP_CRYPT) {\n                    ar6000_install_static_wep_keys(ar);\n                }\n#ifdef WAPI_ENABLE\n                else if(ar->arPairwiseCrypto == WAPI_CRYPT) {\n                    ap_set_wapi_key(ar, ik);\n                }\n#endif\n                break;\n            case WPA_PSK_AUTH:\n            case WPA2_PSK_AUTH:\n            case (WPA_PSK_AUTH|WPA2_PSK_AUTH):\n                switch (ik->ik_type) {\n                    case IEEE80211_CIPHER_TKIP:\n                        keyType = TKIP_CRYPT;\n                        break;\n                    case IEEE80211_CIPHER_AES_CCM:\n                        keyType = AES_CRYPT;\n                        break;\n                    default:\n                       goto skip_key;\n                }\n                wmi_addKey_cmd(ar->arWmi, ik->ik_keyix, keyType, GROUP_USAGE,\n                                ik->ik_keylen, (u8 *)&ik->ik_keyrsc,\n                                ik->ik_keydata, KEY_OP_INIT_VAL, ik->ik_macaddr,\n                                SYNC_BOTH_WMIFLAG);\n\n                break;\n            }\nskip_key:\n            ar->arConnected  = true;\n            return;\n        }\n\n        A_PRINTF(\"NEW STA %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x \\n \"\n            \" AID=%d \\n\", bssid[0], bssid[1], bssid[2],\n             bssid[3], bssid[4], bssid[5], channel);\n        switch ((listenInterval>>8)&0xFF) {\n            case OPEN_AUTH:\n                A_PRINTF(\"AUTH: OPEN\\n\");\n                break;\n            case SHARED_AUTH:\n                A_PRINTF(\"AUTH: SHARED\\n\");\n                break;\n            default:\n                A_PRINTF(\"AUTH: Unknown\\n\");\n                break;\n        }\n        switch (listenInterval&0xFF) {\n            case WPA_PSK_AUTH:\n                A_PRINTF(\"KeyMgmt: WPA-PSK\\n\");\n                break;\n            case WPA2_PSK_AUTH:\n                A_PRINTF(\"KeyMgmt: WPA2-PSK\\n\");\n                break;\n            default:\n                A_PRINTF(\"KeyMgmt: NONE\\n\");\n                break;\n        }\n        switch (beaconInterval) {\n            case AES_CRYPT:\n                A_PRINTF(\"Cipher: AES\\n\");\n                break;\n            case TKIP_CRYPT:\n                A_PRINTF(\"Cipher: TKIP\\n\");\n                break;\n            case WEP_CRYPT:\n                A_PRINTF(\"Cipher: WEP\\n\");\n                break;\n#ifdef WAPI_ENABLE\n            case WAPI_CRYPT:\n                A_PRINTF(\"Cipher: WAPI\\n\");\n                break;\n#endif\n            default:\n                A_PRINTF(\"Cipher: NONE\\n\");\n                break;\n        }\n\n        add_new_sta(ar, bssid, channel /*aid*/,\n            assocInfo /* WPA IE */, assocRespLen /* IE len */,\n            listenInterval&0xFF /* Keymgmt */, beaconInterval /* cipher */,\n            (listenInterval>>8)&0xFF /* auth alg */);\n\n        /* Send event to application */\n        A_MEMZERO(&wrqu, sizeof(wrqu));\n        memcpy(wrqu.addr.sa_data, bssid, ATH_MAC_LEN);\n        wireless_send_event(ar->arNetDev, IWEVREGISTERED, &wrqu, NULL);\n        /* In case the queue is stopped when we switch modes, this will\n         * wake it up\n         */\n        netif_wake_queue(ar->arNetDev);\n        return;\n    }\n\n    ar6k_cfg80211_connect_event(ar, channel, bssid,\n                                listenInterval, beaconInterval,\n                                networkType, beaconIeLen,\n                                assocReqLen, assocRespLen,\n                                assocInfo);\n\n    memcpy(ar->arBssid, bssid, sizeof(ar->arBssid));\n    ar->arBssChannel = channel;\n\n    A_PRINTF(\"AR6000 connected event on freq %d \", channel);\n    A_PRINTF(\"with bssid %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x \"\n            \" listenInterval=%d, beaconInterval = %d, beaconIeLen = %d assocReqLen=%d\"\n            \" assocRespLen =%d\\n\",\n             bssid[0], bssid[1], bssid[2],\n             bssid[3], bssid[4], bssid[5],\n             listenInterval, beaconInterval,\n             beaconIeLen, assocReqLen, assocRespLen);\n    if (networkType & ADHOC_NETWORK) {\n        if (networkType & ADHOC_CREATOR) {\n            A_PRINTF(\"Network: Adhoc (Creator)\\n\");\n        } else {\n            A_PRINTF(\"Network: Adhoc (Joiner)\\n\");\n        }\n    } else {\n        A_PRINTF(\"Network: Infrastructure\\n\");\n    }\n\n    if ((ar->arNetworkType == INFRA_NETWORK)) {\n        wmi_listeninterval_cmd(ar->arWmi, ar->arListenIntervalT, ar->arListenIntervalB);\n    }\n\n    if (beaconIeLen && (sizeof(buf) > (9 + beaconIeLen * 2))) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"\\nBeaconIEs= \"));\n\n        beacon_ie_pos = 0;\n        A_MEMZERO(buf, sizeof(buf));\n        sprintf(buf, \"%s\", beaconIetag);\n        pos = buf + 9;\n        for (i = beacon_ie_pos; i < beacon_ie_pos + beaconIeLen; i++) {\n            AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"%2.2x \", assocInfo[i]));\n            sprintf(pos, \"%2.2x\", assocInfo[i]);\n            pos += 2;\n        }\n        AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"\\n\"));\n\n        A_MEMZERO(&wrqu, sizeof(wrqu));\n        wrqu.data.length = strlen(buf);\n        wireless_send_event(ar->arNetDev, IWEVCUSTOM, &wrqu, buf);\n    }\n\n    if (assocRespLen && (sizeof(buf) > (12 + (assocRespLen * 2))))\n    {\n        assoc_resp_ie_pos = beaconIeLen + assocReqLen +\n                            sizeof(u16)  +  /* capinfo*/\n                            sizeof(u16)  +  /* status Code */\n                            sizeof(u16)  ;  /* associd */\n        A_MEMZERO(buf, sizeof(buf));\n        sprintf(buf, \"%s\", tag2);\n        pos = buf + 12;\n        AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"\\nAssocRespIEs= \"));\n        /*\n         * The Association Response Frame w.o. the WLAN header is delivered to\n         * the host, so skip over to the IEs\n         */\n        for (i = assoc_resp_ie_pos; i < assoc_resp_ie_pos + assocRespLen - 6; i++)\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"%2.2x \", assocInfo[i]));\n            sprintf(pos, \"%2.2x\", assocInfo[i]);\n            pos += 2;\n        }\n        AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"\\n\"));\n\n        A_MEMZERO(&wrqu, sizeof(wrqu));\n        wrqu.data.length = strlen(buf);\n        wireless_send_event(ar->arNetDev, IWEVCUSTOM, &wrqu, buf);\n    }\n\n    if (assocReqLen && (sizeof(buf) > (17 + (assocReqLen * 2)))) {\n        /*\n         * assoc Request includes capability and listen interval. Skip these.\n         */\n        assoc_req_ie_pos =  beaconIeLen +\n                            sizeof(u16)  +  /* capinfo*/\n                            sizeof(u16);    /* listen interval */\n\n        A_MEMZERO(buf, sizeof(buf));\n        sprintf(buf, \"%s\", tag1);\n        pos = buf + 17;\n        AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"AssocReqIEs= \"));\n        for (i = assoc_req_ie_pos; i < assoc_req_ie_pos + assocReqLen - 4; i++) {\n            AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"%2.2x \", assocInfo[i]));\n            sprintf(pos, \"%2.2x\", assocInfo[i]);\n            pos += 2;\n        }\n        AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"\\n\"));\n\n        A_MEMZERO(&wrqu, sizeof(wrqu));\n        wrqu.data.length = strlen(buf);\n        wireless_send_event(ar->arNetDev, IWEVCUSTOM, &wrqu, buf);\n    }\n\n    if (ar->user_savedkeys_stat == USER_SAVEDKEYS_STAT_RUN &&\n        ar->user_saved_keys.keyOk == true)\n    {\n        key_op_ctrl = KEY_OP_VALID_MASK & ~KEY_OP_INIT_TSC;\n\n        if (ar->user_key_ctrl & AR6000_USER_SETKEYS_RSC_UNCHANGED) {\n            key_op_ctrl &= ~KEY_OP_INIT_RSC;\n        } else {\n            key_op_ctrl |= KEY_OP_INIT_RSC;\n        }\n        ar6000_reinstall_keys(ar, key_op_ctrl);\n    }\n\n    netif_wake_queue(ar->arNetDev);\n\n    /* Update connect & link status atomically */\n    spin_lock_irqsave(&ar->arLock, flags);\n    ar->arConnected  = true;\n    ar->arConnectPending = false;\n    netif_carrier_on(ar->arNetDev);\n    spin_unlock_irqrestore(&ar->arLock, flags);\n    /* reset the rx aggr state */\n    aggr_reset_state(ar->aggr_cntxt);\n    reconnect_flag = 0;\n\n    A_MEMZERO(&wrqu, sizeof(wrqu));\n    memcpy(wrqu.addr.sa_data, bssid, IEEE80211_ADDR_LEN);\n    wrqu.addr.sa_family = ARPHRD_ETHER;\n    wireless_send_event(ar->arNetDev, SIOCGIWAP, &wrqu, NULL);\n    if ((ar->arNetworkType == ADHOC_NETWORK) && ar->arIbssPsEnable) {\n        A_MEMZERO(ar->arNodeMap, sizeof(ar->arNodeMap));\n        ar->arNodeNum = 0;\n        ar->arNexEpId = ENDPOINT_2;\n    }\n   if (!ar->arUserBssFilter) {\n        wmi_bssfilter_cmd(ar->arWmi, NONE_BSS_FILTER, 0);\n   }\n\n}\n\nvoid ar6000_set_numdataendpts(struct ar6_softc *ar, u32 num)\n{\n    A_ASSERT(num <= (HTC_MAILBOX_NUM_MAX - 1));\n    ar->arNumDataEndPts = num;\n}\n\nvoid\nsta_cleanup(struct ar6_softc *ar, u8 i)\n{\n    struct sk_buff *skb;\n\n    /* empty the queued pkts in the PS queue if any */\n    A_MUTEX_LOCK(&ar->sta_list[i].psqLock);\n    while (!A_NETBUF_QUEUE_EMPTY(&ar->sta_list[i].psq)) {\n        skb = A_NETBUF_DEQUEUE(&ar->sta_list[i].psq);\n        A_NETBUF_FREE(skb);\n    }\n    A_MUTEX_UNLOCK(&ar->sta_list[i].psqLock);\n\n    /* Zero out the state fields */\n    A_MEMZERO(&ar->arAPStats.sta[ar->sta_list[i].aid-1], sizeof(WMI_PER_STA_STAT));\n    A_MEMZERO(&ar->sta_list[i].mac, ATH_MAC_LEN);\n    A_MEMZERO(&ar->sta_list[i].wpa_ie, IEEE80211_MAX_IE);\n    ar->sta_list[i].aid = 0;\n    ar->sta_list[i].flags = 0;\n\n    ar->sta_list_index = ar->sta_list_index & ~(1 << i);\n\n}\n\nu8 remove_sta(struct ar6_softc *ar, u8 *mac, u16 reason)\n{\n    u8 i, removed=0;\n\n    if(IS_MAC_NULL(mac)) {\n        return removed;\n    }\n\n    if(IS_MAC_BCAST(mac)) {\n        A_PRINTF(\"DEL ALL STA\\n\");\n        for(i=0; i < AP_MAX_NUM_STA; i++) {\n            if(!IS_MAC_NULL(ar->sta_list[i].mac)) {\n                sta_cleanup(ar, i);\n                removed = 1;\n            }\n        }\n    } else {\n        for(i=0; i < AP_MAX_NUM_STA; i++) {\n            if(memcmp(ar->sta_list[i].mac, mac, ATH_MAC_LEN)==0) {\n                A_PRINTF(\"DEL STA %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x \"\n                \" aid=%d REASON=%d\\n\", mac[0], mac[1], mac[2],\n                 mac[3], mac[4], mac[5], ar->sta_list[i].aid, reason);\n\n                sta_cleanup(ar, i);\n                removed = 1;\n                break;\n            }\n        }\n    }\n    return removed;\n}\n\nvoid\nar6000_disconnect_event(struct ar6_softc *ar, u8 reason, u8 *bssid,\n                        u8 assocRespLen, u8 *assocInfo, u16 protocolReasonStatus)\n{\n    u8 i;\n    unsigned long flags;\n    union iwreq_data wrqu;\n\n    if(ar->arNetworkType & AP_NETWORK) {\n        union iwreq_data wrqu;\n        struct sk_buff *skb;\n\n        if(!remove_sta(ar, bssid, protocolReasonStatus)) {\n            return;\n        }\n\n        /* If there are no more associated STAs, empty the mcast PS q */\n        if (ar->sta_list_index == 0) {\n            A_MUTEX_LOCK(&ar->mcastpsqLock);\n            while (!A_NETBUF_QUEUE_EMPTY(&ar->mcastpsq)) {\n                skb = A_NETBUF_DEQUEUE(&ar->mcastpsq);\n                A_NETBUF_FREE(skb);\n            }\n            A_MUTEX_UNLOCK(&ar->mcastpsqLock);\n\n            /* Clear the LSB of the BitMapCtl field of the TIM IE */\n            if (ar->arWmiReady) {\n                wmi_set_pvb_cmd(ar->arWmi, MCAST_AID, 0);\n            }\n        }\n\n        if(!IS_MAC_BCAST(bssid)) {\n            /* Send event to application */\n            A_MEMZERO(&wrqu, sizeof(wrqu));\n            memcpy(wrqu.addr.sa_data, bssid, ATH_MAC_LEN);\n            wireless_send_event(ar->arNetDev, IWEVEXPIRED, &wrqu, NULL);\n        }\n\n        ar->arConnected = false;\n        return;\n    }\n\n    ar6k_cfg80211_disconnect_event(ar, reason, bssid,\n                                   assocRespLen, assocInfo,\n                                   protocolReasonStatus);\n\n    /* Send disconnect event to supplicant */\n    A_MEMZERO(&wrqu, sizeof(wrqu));\n    wrqu.addr.sa_family = ARPHRD_ETHER;\n    wireless_send_event(ar->arNetDev, SIOCGIWAP, &wrqu, NULL);\n\n    /* it is necessary to clear the host-side rx aggregation state */\n    aggr_reset_state(ar->aggr_cntxt);\n\n    A_UNTIMEOUT(&ar->disconnect_timer);\n\n    A_PRINTF(\"AR6000 disconnected\");\n    if (bssid[0] || bssid[1] || bssid[2] || bssid[3] || bssid[4] || bssid[5]) {\n        A_PRINTF(\" from %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x \",\n                 bssid[0], bssid[1], bssid[2], bssid[3], bssid[4], bssid[5]);\n    }\n\n    AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"\\nDisconnect Reason is %d\", reason));\n    AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"\\nProtocol Reason/Status Code is %d\", protocolReasonStatus));\n    AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"\\nAssocResp Frame = %s\",\n                    assocRespLen ? \" \" : \"NULL\"));\n    for (i = 0; i < assocRespLen; i++) {\n        if (!(i % 0x10)) {\n            AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"\\n\"));\n        }\n        AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"%2.2x \", assocInfo[i]));\n    }\n    AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"\\n\"));\n    /*\n     * If the event is due to disconnect cmd from the host, only they the target\n     * would stop trying to connect. Under any other condition, target would\n     * keep trying to connect.\n     *\n     */\n    if( reason == DISCONNECT_CMD)\n    {\n        if ((!ar->arUserBssFilter) && (ar->arWmiReady)) {\n            wmi_bssfilter_cmd(ar->arWmi, NONE_BSS_FILTER, 0);\n        }\n    } else {\n        ar->arConnectPending = true;\n        if (((reason == ASSOC_FAILED) && (protocolReasonStatus == 0x11)) ||\n            ((reason == ASSOC_FAILED) && (protocolReasonStatus == 0x0) && (reconnect_flag == 1))) {\n            ar->arConnected = true;\n            return;\n        }\n    }\n\n    if ((reason == NO_NETWORK_AVAIL) && (ar->arWmiReady)) \n    {\n        bss_t *pWmiSsidnode = NULL;\n\n        /* remove the current associated bssid node */\n        wmi_free_node (ar->arWmi, bssid);\n\n        /*\n         * In case any other same SSID nodes are present\n         * remove it, since those nodes also not available now\n         */\n        do\n        {\n            /*\n             * Find the nodes based on SSID and remove it\n             * NOTE :: This case will not work out for Hidden-SSID\n             */\n            pWmiSsidnode = wmi_find_Ssidnode (ar->arWmi, ar->arSsid, ar->arSsidLen, false, true);\n\n            if (pWmiSsidnode)\n            {\n                wmi_free_node (ar->arWmi, pWmiSsidnode->ni_macaddr);\n            }\n\n        } while (pWmiSsidnode);\n    }\n\n    /* Update connect & link status atomically */\n    spin_lock_irqsave(&ar->arLock, flags);\n    ar->arConnected = false;\n    netif_carrier_off(ar->arNetDev);\n    spin_unlock_irqrestore(&ar->arLock, flags);\n\n    if( (reason != CSERV_DISCONNECT) || (reconnect_flag != 1) ) {\n        reconnect_flag = 0;\n    }\n\n    if (reason != CSERV_DISCONNECT)\n    {\n        ar->user_savedkeys_stat = USER_SAVEDKEYS_STAT_INIT;\n        ar->user_key_ctrl      = 0;\n    }\n\n    netif_stop_queue(ar->arNetDev);\n    A_MEMZERO(ar->arBssid, sizeof(ar->arBssid));\n    ar->arBssChannel = 0;\n    ar->arBeaconInterval = 0;\n\n    ar6000_TxDataCleanup(ar);\n}\n\nvoid\nar6000_regDomain_event(struct ar6_softc *ar, u32 regCode)\n{\n    A_PRINTF(\"AR6000 Reg Code = 0x%x\\n\", regCode);\n    ar->arRegCode = regCode;\n}\n\nvoid\nar6000_aggr_rcv_addba_req_evt(struct ar6_softc *ar, WMI_ADDBA_REQ_EVENT *evt)\n{\n    if(evt->status == 0) {\n        aggr_recv_addba_req_evt(ar->aggr_cntxt, evt->tid, evt->st_seq_no, evt->win_sz);\n    }\n}\n\nvoid\nar6000_aggr_rcv_addba_resp_evt(struct ar6_softc *ar, WMI_ADDBA_RESP_EVENT *evt)\n{\n    A_PRINTF(\"ADDBA RESP. tid %d status %d, sz %d\\n\", evt->tid, evt->status, evt->amsdu_sz);\n    if(evt->status == 0) {\n    }\n}\n\nvoid\nar6000_aggr_rcv_delba_req_evt(struct ar6_softc *ar, WMI_DELBA_EVENT *evt)\n{\n    aggr_recv_delba_req_evt(ar->aggr_cntxt, evt->tid);\n}\n\nvoid register_pal_cb(ar6k_pal_config_t *palConfig_p)\n{\n  ar6k_pal_config_g = *palConfig_p;\n}\n\nvoid\nar6000_hci_event_rcv_evt(struct ar6_softc *ar, WMI_HCI_EVENT *cmd)\n{\n    void *osbuf = NULL;\n    s8 i;\n    u8 size, *buf;\n    int ret = 0;\n\n    size = cmd->evt_buf_sz + 4;\n    osbuf = A_NETBUF_ALLOC(size);\n    if (osbuf == NULL) {\n       ret = A_NO_MEMORY;\n       A_PRINTF(\"Error in allocating netbuf \\n\");\n       return;\n    }\n\n    A_NETBUF_PUT(osbuf, size);\n    buf = (u8 *)A_NETBUF_DATA(osbuf);\n    /* First 2-bytes carry HCI event/ACL data type\n     * the next 2 are free\n     */\n    *((short *)buf) = WMI_HCI_EVENT_EVENTID;\n    buf += sizeof(int);\n    memcpy(buf, cmd->buf, cmd->evt_buf_sz);\n\n    ar6000_deliver_frames_to_nw_stack(ar->arNetDev, osbuf);\n    if(loghci) {\n        A_PRINTF_LOG(\"HCI Event From PAL <-- \\n\");\n        for(i = 0; i < cmd->evt_buf_sz; i++) {\n           A_PRINTF_LOG(\"0x%02x \", cmd->buf[i]);\n           if((i % 10) == 0) {\n               A_PRINTF_LOG(\"\\n\");\n           }\n        }\n        A_PRINTF_LOG(\"\\n\");\n        A_PRINTF_LOG(\"==================================\\n\");\n    }\n}\n\nvoid\nar6000_neighborReport_event(struct ar6_softc *ar, int numAps, WMI_NEIGHBOR_INFO *info)\n{\n#if WIRELESS_EXT >= 18\n    struct iw_pmkid_cand *pmkcand;\n#else /* WIRELESS_EXT >= 18 */\n    static const char *tag = \"PRE-AUTH\";\n    char buf[128];\n#endif /* WIRELESS_EXT >= 18 */\n\n    union iwreq_data wrqu;\n    int i;\n\n    AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_SCAN,(\"AR6000 Neighbor Report Event\\n\"));\n    for (i=0; i < numAps; info++, i++) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_SCAN,(\"bssid %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x \",\n            info->bssid[0], info->bssid[1], info->bssid[2],\n            info->bssid[3], info->bssid[4], info->bssid[5]));\n        if (info->bssFlags & WMI_PREAUTH_CAPABLE_BSS) {\n            AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_SCAN,(\"preauth-cap\"));\n        }\n        if (info->bssFlags & WMI_PMKID_VALID_BSS) {\n            AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_SCAN,(\" pmkid-valid\\n\"));\n            continue;           /* we skip bss if the pmkid is already valid */\n        }\n        AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_SCAN,(\"\\n\"));\n        A_MEMZERO(&wrqu, sizeof(wrqu));\n#if WIRELESS_EXT >= 18\n        pmkcand = A_MALLOC_NOWAIT(sizeof(struct iw_pmkid_cand));\n        A_MEMZERO(pmkcand, sizeof(struct iw_pmkid_cand));\n        pmkcand->index = i;\n        pmkcand->flags = info->bssFlags;\n        memcpy(pmkcand->bssid.sa_data, info->bssid, ATH_MAC_LEN);\n        wrqu.data.length = sizeof(struct iw_pmkid_cand);\n        wireless_send_event(ar->arNetDev, IWEVPMKIDCAND, &wrqu, (char *)pmkcand);\n        kfree(pmkcand);\n#else /* WIRELESS_EXT >= 18 */\n        snprintf(buf, sizeof(buf), \"%s%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x\",\n                 tag,\n                 info->bssid[0], info->bssid[1], info->bssid[2],\n                 info->bssid[3], info->bssid[4], info->bssid[5],\n                 i, info->bssFlags);\n        wrqu.data.length = strlen(buf);\n        wireless_send_event(ar->arNetDev, IWEVCUSTOM, &wrqu, buf);\n#endif /* WIRELESS_EXT >= 18 */\n    }\n}\n\nvoid\nar6000_tkip_micerr_event(struct ar6_softc *ar, u8 keyid, bool ismcast)\n{\n    static const char *tag = \"MLME-MICHAELMICFAILURE.indication\";\n    char buf[128];\n    union iwreq_data wrqu;\n\n    /*\n     * For AP case, keyid will have aid of STA which sent pkt with\n     * MIC error. Use this aid to get MAC & send it to hostapd.\n     */\n    if (ar->arNetworkType == AP_NETWORK) {\n        sta_t *s = ieee80211_find_conn_for_aid(ar, (keyid >> 2));\n        if(!s){\n            A_PRINTF(\"AP TKIP MIC error received from Invalid aid / STA not found =%d\\n\", keyid);\n            return;\n        }\n        A_PRINTF(\"AP TKIP MIC error received from aid=%d\\n\", keyid);\n        snprintf(buf,sizeof(buf), \"%s addr=%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x\",\n            tag, s->mac[0],s->mac[1],s->mac[2],s->mac[3],s->mac[4],s->mac[5]);\n    } else {\n\n    ar6k_cfg80211_tkip_micerr_event(ar, keyid, ismcast);\n\n        A_PRINTF(\"AR6000 TKIP MIC error received for keyid %d %scast\\n\",\n             keyid & 0x3, ismcast ? \"multi\": \"uni\");\n        snprintf(buf, sizeof(buf), \"%s(keyid=%d %sicast)\", tag, keyid & 0x3,\n             ismcast ? \"mult\" : \"un\");\n    }\n\n    memset(&wrqu, 0, sizeof(wrqu));\n    wrqu.data.length = strlen(buf);\n    wireless_send_event(ar->arNetDev, IWEVCUSTOM, &wrqu, buf);\n}\n\nvoid\nar6000_scanComplete_event(struct ar6_softc *ar, int status)\n{\n\n    ar6k_cfg80211_scanComplete_event(ar, status);\n\n    if (!ar->arUserBssFilter) {\n        wmi_bssfilter_cmd(ar->arWmi, NONE_BSS_FILTER, 0);\n    }\n    if (ar->scan_triggered) {\n        if (status== 0) {\n            union iwreq_data wrqu;\n            A_MEMZERO(&wrqu, sizeof(wrqu));\n            wireless_send_event(ar->arNetDev, SIOCGIWSCAN, &wrqu, NULL);\n        }\n        ar->scan_triggered = 0;\n    }\n\n    AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_SCAN,( \"AR6000 scan complete: %d\\n\", status));\n}\n\nvoid\nar6000_targetStats_event(struct ar6_softc *ar,  u8 *ptr, u32 len)\n{\n    u8 ac;\n\n    if(ar->arNetworkType == AP_NETWORK) {\n        WMI_AP_MODE_STAT *p = (WMI_AP_MODE_STAT *)ptr;\n        WMI_AP_MODE_STAT *ap = &ar->arAPStats;\n\n        if (len < sizeof(*p)) {\n            return;\n        }\n\n        for(ac=0;ac<AP_MAX_NUM_STA;ac++) {\n            ap->sta[ac].tx_bytes   += p->sta[ac].tx_bytes;\n            ap->sta[ac].tx_pkts    += p->sta[ac].tx_pkts;\n            ap->sta[ac].tx_error   += p->sta[ac].tx_error;\n            ap->sta[ac].tx_discard += p->sta[ac].tx_discard;\n            ap->sta[ac].rx_bytes   += p->sta[ac].rx_bytes;\n            ap->sta[ac].rx_pkts    += p->sta[ac].rx_pkts;\n            ap->sta[ac].rx_error   += p->sta[ac].rx_error;\n            ap->sta[ac].rx_discard += p->sta[ac].rx_discard;\n        }\n\n    } else {\n        WMI_TARGET_STATS *pTarget = (WMI_TARGET_STATS *)ptr;\n         TARGET_STATS *pStats = &ar->arTargetStats;\n\n        if (len < sizeof(*pTarget)) {\n            return;\n        }\n\n        // Update the RSSI of the connected bss.\n        if (ar->arConnected) {\n            bss_t *pConnBss = NULL;\n\n            pConnBss = wmi_find_node(ar->arWmi,ar->arBssid);\n            if (pConnBss)\n            {\n                pConnBss->ni_rssi = pTarget->cservStats.cs_aveBeacon_rssi;\n                pConnBss->ni_snr = pTarget->cservStats.cs_aveBeacon_snr;\n                wmi_node_return(ar->arWmi, pConnBss);\n            }\n        }\n\n        AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"AR6000 updating target stats\\n\"));\n        pStats->tx_packets          += pTarget->txrxStats.tx_stats.tx_packets;\n        pStats->tx_bytes            += pTarget->txrxStats.tx_stats.tx_bytes;\n        pStats->tx_unicast_pkts     += pTarget->txrxStats.tx_stats.tx_unicast_pkts;\n        pStats->tx_unicast_bytes    += pTarget->txrxStats.tx_stats.tx_unicast_bytes;\n        pStats->tx_multicast_pkts   += pTarget->txrxStats.tx_stats.tx_multicast_pkts;\n        pStats->tx_multicast_bytes  += pTarget->txrxStats.tx_stats.tx_multicast_bytes;\n        pStats->tx_broadcast_pkts   += pTarget->txrxStats.tx_stats.tx_broadcast_pkts;\n        pStats->tx_broadcast_bytes  += pTarget->txrxStats.tx_stats.tx_broadcast_bytes;\n        pStats->tx_rts_success_cnt  += pTarget->txrxStats.tx_stats.tx_rts_success_cnt;\n        for(ac = 0; ac < WMM_NUM_AC; ac++)\n            pStats->tx_packet_per_ac[ac] += pTarget->txrxStats.tx_stats.tx_packet_per_ac[ac];\n        pStats->tx_errors           += pTarget->txrxStats.tx_stats.tx_errors;\n        pStats->tx_failed_cnt       += pTarget->txrxStats.tx_stats.tx_failed_cnt;\n        pStats->tx_retry_cnt        += pTarget->txrxStats.tx_stats.tx_retry_cnt;\n        pStats->tx_mult_retry_cnt   += pTarget->txrxStats.tx_stats.tx_mult_retry_cnt;\n        pStats->tx_rts_fail_cnt     += pTarget->txrxStats.tx_stats.tx_rts_fail_cnt;\n        pStats->tx_unicast_rate      = wmi_get_rate(pTarget->txrxStats.tx_stats.tx_unicast_rate);\n\n        pStats->rx_packets          += pTarget->txrxStats.rx_stats.rx_packets;\n        pStats->rx_bytes            += pTarget->txrxStats.rx_stats.rx_bytes;\n        pStats->rx_unicast_pkts     += pTarget->txrxStats.rx_stats.rx_unicast_pkts;\n        pStats->rx_unicast_bytes    += pTarget->txrxStats.rx_stats.rx_unicast_bytes;\n        pStats->rx_multicast_pkts   += pTarget->txrxStats.rx_stats.rx_multicast_pkts;\n        pStats->rx_multicast_bytes  += pTarget->txrxStats.rx_stats.rx_multicast_bytes;\n        pStats->rx_broadcast_pkts   += pTarget->txrxStats.rx_stats.rx_broadcast_pkts;\n        pStats->rx_broadcast_bytes  += pTarget->txrxStats.rx_stats.rx_broadcast_bytes;\n        pStats->rx_fragment_pkt     += pTarget->txrxStats.rx_stats.rx_fragment_pkt;\n        pStats->rx_errors           += pTarget->txrxStats.rx_stats.rx_errors;\n        pStats->rx_crcerr           += pTarget->txrxStats.rx_stats.rx_crcerr;\n        pStats->rx_key_cache_miss   += pTarget->txrxStats.rx_stats.rx_key_cache_miss;\n        pStats->rx_decrypt_err      += pTarget->txrxStats.rx_stats.rx_decrypt_err;\n        pStats->rx_duplicate_frames += pTarget->txrxStats.rx_stats.rx_duplicate_frames;\n        pStats->rx_unicast_rate      = wmi_get_rate(pTarget->txrxStats.rx_stats.rx_unicast_rate);\n\n\n        pStats->tkip_local_mic_failure\n                                += pTarget->txrxStats.tkipCcmpStats.tkip_local_mic_failure;\n        pStats->tkip_counter_measures_invoked\n                                += pTarget->txrxStats.tkipCcmpStats.tkip_counter_measures_invoked;\n        pStats->tkip_replays        += pTarget->txrxStats.tkipCcmpStats.tkip_replays;\n        pStats->tkip_format_errors  += pTarget->txrxStats.tkipCcmpStats.tkip_format_errors;\n        pStats->ccmp_format_errors  += pTarget->txrxStats.tkipCcmpStats.ccmp_format_errors;\n        pStats->ccmp_replays        += pTarget->txrxStats.tkipCcmpStats.ccmp_replays;\n\n        pStats->power_save_failure_cnt += pTarget->pmStats.power_save_failure_cnt;\n        pStats->noise_floor_calibation = pTarget->noise_floor_calibation;\n\n        pStats->cs_bmiss_cnt        += pTarget->cservStats.cs_bmiss_cnt;\n        pStats->cs_lowRssi_cnt      += pTarget->cservStats.cs_lowRssi_cnt;\n        pStats->cs_connect_cnt      += pTarget->cservStats.cs_connect_cnt;\n        pStats->cs_disconnect_cnt   += pTarget->cservStats.cs_disconnect_cnt;\n        pStats->cs_aveBeacon_snr    = pTarget->cservStats.cs_aveBeacon_snr;\n        pStats->cs_aveBeacon_rssi   = pTarget->cservStats.cs_aveBeacon_rssi;\n\n        if (enablerssicompensation) {\n            pStats->cs_aveBeacon_rssi =\n                    rssi_compensation_calc(ar, pStats->cs_aveBeacon_rssi);\n        }\n        pStats->cs_lastRoam_msec    = pTarget->cservStats.cs_lastRoam_msec;\n        pStats->cs_snr              = pTarget->cservStats.cs_snr;\n        pStats->cs_rssi             = pTarget->cservStats.cs_rssi;\n\n        pStats->lq_val              = pTarget->lqVal;\n\n        pStats->wow_num_pkts_dropped += pTarget->wowStats.wow_num_pkts_dropped;\n        pStats->wow_num_host_pkt_wakeups += pTarget->wowStats.wow_num_host_pkt_wakeups;\n        pStats->wow_num_host_event_wakeups += pTarget->wowStats.wow_num_host_event_wakeups;\n        pStats->wow_num_events_discarded += pTarget->wowStats.wow_num_events_discarded;\n        pStats->arp_received += pTarget->arpStats.arp_received;\n        pStats->arp_matched  += pTarget->arpStats.arp_matched;\n        pStats->arp_replied  += pTarget->arpStats.arp_replied;\n\n        if (ar->statsUpdatePending) {\n            ar->statsUpdatePending = false;\n            wake_up(&arEvent);\n        }\n    }\n}\n\nvoid\nar6000_rssiThreshold_event(struct ar6_softc *ar,  WMI_RSSI_THRESHOLD_VAL newThreshold, s16 rssi)\n{\n    USER_RSSI_THOLD userRssiThold;\n\n    rssi = rssi + SIGNAL_QUALITY_NOISE_FLOOR;\n\n    if (enablerssicompensation) {\n        rssi = rssi_compensation_calc(ar, rssi);\n    }\n\n    /* Send an event to the app */\n    userRssiThold.tag = ar->rssi_map[newThreshold].tag;\n    userRssiThold.rssi = rssi;\n    A_PRINTF(\"rssi Threshold range = %d tag = %d  rssi = %d\\n\", newThreshold,\n             userRssiThold.tag, userRssiThold.rssi);\n}\n\n\nvoid\nar6000_hbChallengeResp_event(struct ar6_softc *ar, u32 cookie, u32 source)\n{\n    if (source != APP_HB_CHALLENGE) {\n        /* This would ignore the replys that come in after their due time */\n        if (cookie == ar->arHBChallengeResp.seqNum) {\n            ar->arHBChallengeResp.outstanding = false;\n        }\n    }\n}\n\n\nvoid\nar6000_reportError_event(struct ar6_softc *ar, WMI_TARGET_ERROR_VAL errorVal)\n{\n\tstatic const char * const errString[] = {\n\t\t[WMI_TARGET_PM_ERR_FAIL]    \"WMI_TARGET_PM_ERR_FAIL\",\n\t\t[WMI_TARGET_KEY_NOT_FOUND]  \"WMI_TARGET_KEY_NOT_FOUND\",\n\t\t[WMI_TARGET_DECRYPTION_ERR] \"WMI_TARGET_DECRYPTION_ERR\",\n\t\t[WMI_TARGET_BMISS]          \"WMI_TARGET_BMISS\",\n\t\t[WMI_PSDISABLE_NODE_JOIN]   \"WMI_PSDISABLE_NODE_JOIN\"\n\t};\n\n    A_PRINTF(\"AR6000 Error on Target. Error = 0x%x\\n\", errorVal);\n\n    /* One error is reported at a time, and errorval is a bitmask */\n    if(errorVal & (errorVal - 1))\n       return;\n\n    A_PRINTF(\"AR6000 Error type = \");\n    switch(errorVal)\n    {\n        case WMI_TARGET_PM_ERR_FAIL:\n        case WMI_TARGET_KEY_NOT_FOUND:\n        case WMI_TARGET_DECRYPTION_ERR:\n        case WMI_TARGET_BMISS:\n        case WMI_PSDISABLE_NODE_JOIN:\n            A_PRINTF(\"%s\\n\", errString[errorVal]);\n            break;\n        default:\n            A_PRINTF(\"INVALID\\n\");\n            break;\n    }\n\n}\n\n\nvoid\nar6000_cac_event(struct ar6_softc *ar, u8 ac, u8 cacIndication,\n                 u8 statusCode, u8 *tspecSuggestion)\n{\n    WMM_TSPEC_IE    *tspecIe;\n\n    /*\n     * This is the TSPEC IE suggestion from AP.\n     * Suggestion provided by AP under some error\n     * cases, could be helpful for the host app.\n     * Check documentation.\n     */\n    tspecIe = (WMM_TSPEC_IE *)tspecSuggestion;\n\n    /*\n     * What do we do, if we get TSPEC rejection? One thought\n     * that comes to mind is implictly delete the pstream...\n     */\n    A_PRINTF(\"AR6000 CAC notification. \"\n                \"AC = %d, cacIndication = 0x%x, statusCode = 0x%x\\n\",\n                 ac, cacIndication, statusCode);\n}\n\nvoid\nar6000_channel_change_event(struct ar6_softc *ar, u16 oldChannel,\n                            u16 newChannel)\n{\n    A_PRINTF(\"Channel Change notification\\nOld Channel: %d, New Channel: %d\\n\",\n             oldChannel, newChannel);\n}\n\n#define AR6000_PRINT_BSSID(_pBss)  do {     \\\n        A_PRINTF(\"%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x \",\\\n                 (_pBss)[0],(_pBss)[1],(_pBss)[2],(_pBss)[3],\\\n                 (_pBss)[4],(_pBss)[5]);  \\\n} while(0)\n\nvoid\nar6000_roam_tbl_event(struct ar6_softc *ar, WMI_TARGET_ROAM_TBL *pTbl)\n{\n    u8 i;\n\n    A_PRINTF(\"ROAM TABLE NO OF ENTRIES is %d ROAM MODE is %d\\n\",\n              pTbl->numEntries, pTbl->roamMode);\n    for (i= 0; i < pTbl->numEntries; i++) {\n        A_PRINTF(\"[%d]bssid %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x \", i,\n            pTbl->bssRoamInfo[i].bssid[0], pTbl->bssRoamInfo[i].bssid[1],\n            pTbl->bssRoamInfo[i].bssid[2],\n            pTbl->bssRoamInfo[i].bssid[3],\n            pTbl->bssRoamInfo[i].bssid[4],\n            pTbl->bssRoamInfo[i].bssid[5]);\n        A_PRINTF(\"RSSI %d RSSIDT %d LAST RSSI %d UTIL %d ROAM_UTIL %d\"\n                 \" BIAS %d\\n\",\n            pTbl->bssRoamInfo[i].rssi,\n            pTbl->bssRoamInfo[i].rssidt,\n            pTbl->bssRoamInfo[i].last_rssi,\n            pTbl->bssRoamInfo[i].util,\n            pTbl->bssRoamInfo[i].roam_util,\n            pTbl->bssRoamInfo[i].bias);\n    }\n}\n\nvoid\nar6000_wow_list_event(struct ar6_softc *ar, u8 num_filters, WMI_GET_WOW_LIST_REPLY *wow_reply)\n{\n    u8 i,j;\n\n    /*Each event now contains exactly one filter, see bug 26613*/\n    A_PRINTF(\"WOW pattern %d of %d patterns\\n\", wow_reply->this_filter_num,                 wow_reply->num_filters);\n    A_PRINTF(\"wow mode = %s host mode = %s\\n\",\n            (wow_reply->wow_mode == 0? \"disabled\":\"enabled\"),\n            (wow_reply->host_mode == 1 ? \"awake\":\"asleep\"));\n\n\n    /*If there are no patterns, the reply will only contain generic\n      WoW information. Pattern information will exist only if there are\n      patterns present. Bug 26716*/\n\n   /* If this event contains pattern information, display it*/\n    if (wow_reply->this_filter_num) {\n        i=0;\n        A_PRINTF(\"id=%d size=%d offset=%d\\n\",\n                    wow_reply->wow_filters[i].wow_filter_id,\n                    wow_reply->wow_filters[i].wow_filter_size,\n                    wow_reply->wow_filters[i].wow_filter_offset);\n       A_PRINTF(\"wow pattern = \");\n       for (j=0; j< wow_reply->wow_filters[i].wow_filter_size; j++) {\n             A_PRINTF(\"%2.2x\",wow_reply->wow_filters[i].wow_filter_pattern[j]);\n        }\n\n        A_PRINTF(\"\\nwow mask = \");\n        for (j=0; j< wow_reply->wow_filters[i].wow_filter_size; j++) {\n            A_PRINTF(\"%2.2x\",wow_reply->wow_filters[i].wow_filter_mask[j]);\n        }\n        A_PRINTF(\"\\n\");\n    }\n}\n\n/*\n * Report the Roaming related data collected on the target\n */\nvoid\nar6000_display_roam_time(WMI_TARGET_ROAM_TIME *p)\n{\n    A_PRINTF(\"Disconnect Data : BSSID: \");\n    AR6000_PRINT_BSSID(p->disassoc_bssid);\n    A_PRINTF(\" RSSI %d DISASSOC Time %d NO_TXRX_TIME %d\\n\",\n             p->disassoc_bss_rssi,p->disassoc_time,\n             p->no_txrx_time);\n    A_PRINTF(\"Connect Data: BSSID: \");\n    AR6000_PRINT_BSSID(p->assoc_bssid);\n    A_PRINTF(\" RSSI %d ASSOC Time %d TXRX_TIME %d\\n\",\n             p->assoc_bss_rssi,p->assoc_time,\n             p->allow_txrx_time);\n}\n\nvoid\nar6000_roam_data_event(struct ar6_softc *ar, WMI_TARGET_ROAM_DATA *p)\n{\n    switch (p->roamDataType) {\n        case ROAM_DATA_TIME:\n            ar6000_display_roam_time(&p->u.roamTime);\n            break;\n        default:\n            break;\n    }\n}\n\nvoid\nar6000_bssInfo_event_rx(struct ar6_softc *ar, u8 *datap, int len)\n{\n    struct sk_buff *skb;\n    WMI_BSS_INFO_HDR *bih = (WMI_BSS_INFO_HDR *)datap;\n\n\n    if (!ar->arMgmtFilter) {\n        return;\n    }\n    if (((ar->arMgmtFilter & IEEE80211_FILTER_TYPE_BEACON) &&\n        (bih->frameType != BEACON_FTYPE))  ||\n        ((ar->arMgmtFilter & IEEE80211_FILTER_TYPE_PROBE_RESP) &&\n        (bih->frameType != PROBERESP_FTYPE)))\n    {\n        return;\n    }\n\n    if ((skb = A_NETBUF_ALLOC_RAW(len)) != NULL) {\n\n        A_NETBUF_PUT(skb, len);\n        memcpy(A_NETBUF_DATA(skb), datap, len);\n        skb->dev = ar->arNetDev;\n        memcpy(skb_mac_header(skb), A_NETBUF_DATA(skb), 6);\n        skb->ip_summed = CHECKSUM_NONE;\n        skb->pkt_type = PACKET_OTHERHOST;\n        skb->protocol = __constant_htons(0x0019);\n        netif_rx(skb);\n    }\n}\n\nu32 wmiSendCmdNum;\n\nint\nar6000_control_tx(void *devt, void *osbuf, HTC_ENDPOINT_ID eid)\n{\n    struct ar6_softc       *ar = (struct ar6_softc *)devt;\n    int         status = 0;\n    struct ar_cookie *cookie = NULL;\n    int i;\n#ifdef CONFIG_PM\n    if (ar->arWowState != WLAN_WOW_STATE_NONE) {\n        A_NETBUF_FREE(osbuf);\n        return A_EACCES;\n    }\n#endif /* CONFIG_PM */\n        /* take lock to protect ar6000_alloc_cookie() */\n    AR6000_SPIN_LOCK(&ar->arLock, 0);\n\n    do {\n\n        AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_TX,(\"ar_contrstatus = ol_tx: skb=0x%lx, len=0x%x eid =%d\\n\",\n                         (unsigned long)osbuf, A_NETBUF_LEN(osbuf), eid));\n\n        if (ar->arWMIControlEpFull && (eid == ar->arControlEp)) {\n                /* control endpoint is full, don't allocate resources, we\n                 * are just going to drop this packet */\n            cookie = NULL;\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\" WMI Control EP full, dropping packet : 0x%lX, len:%d \\n\",\n                    (unsigned long)osbuf, A_NETBUF_LEN(osbuf)));\n        } else {\n            cookie = ar6000_alloc_cookie(ar);\n        }\n\n        if (cookie == NULL) {\n            status = A_NO_MEMORY;\n            break;\n        }\n\n        if(logWmiRawMsgs) {\n            A_PRINTF(\"WMI cmd send, msgNo %d :\", wmiSendCmdNum);\n            for(i = 0; i < a_netbuf_to_len(osbuf); i++)\n                A_PRINTF(\"%x \", ((u8 *)a_netbuf_to_data(osbuf))[i]);\n            A_PRINTF(\"\\n\");\n        }\n\n        wmiSendCmdNum++;\n\n    } while (false);\n\n    if (cookie != NULL) {\n            /* got a structure to send it out on */\n        ar->arTxPending[eid]++;\n\n        if (eid != ar->arControlEp) {\n            ar->arTotalTxDataPending++;\n        }\n    }\n\n    AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n\n    if (cookie != NULL) {\n        cookie->arc_bp[0] = (unsigned long)osbuf;\n        cookie->arc_bp[1] = 0;\n        SET_HTC_PACKET_INFO_TX(&cookie->HtcPkt,\n                               cookie,\n                               A_NETBUF_DATA(osbuf),\n                               A_NETBUF_LEN(osbuf),\n                               eid,\n                               AR6K_CONTROL_PKT_TAG);\n            /* this interface is asynchronous, if there is an error, cleanup will happen in the\n             * TX completion callback */\n        HTCSendPkt(ar->arHtcTarget, &cookie->HtcPkt);\n        status = 0;\n    }\n\n    if (status) {\n        A_NETBUF_FREE(osbuf);\n    }\n    return status;\n}\n\n/* indicate tx activity or inactivity on a WMI stream */\nvoid ar6000_indicate_tx_activity(void *devt, u8 TrafficClass, bool Active)\n{\n    struct ar6_softc  *ar = (struct ar6_softc *)devt;\n    HTC_ENDPOINT_ID eid ;\n    int i;\n\n    if (ar->arWmiEnabled) {\n        eid = arAc2EndpointID(ar, TrafficClass);\n\n        AR6000_SPIN_LOCK(&ar->arLock, 0);\n\n        ar->arAcStreamActive[TrafficClass] = Active;\n\n        if (Active) {\n            /* when a stream goes active, keep track of the active stream with the highest priority */\n\n            if (ar->arAcStreamPriMap[TrafficClass] > ar->arHiAcStreamActivePri) {\n                    /* set the new highest active priority */\n                ar->arHiAcStreamActivePri = ar->arAcStreamPriMap[TrafficClass];\n            }\n\n        } else {\n            /* when a stream goes inactive, we may have to search for the next active stream\n             * that is the highest priority */\n\n            if (ar->arHiAcStreamActivePri == ar->arAcStreamPriMap[TrafficClass]) {\n\n                /* the highest priority stream just went inactive */\n\n                    /* reset and search for the \"next\" highest \"active\" priority stream */\n                ar->arHiAcStreamActivePri = 0;\n                for (i = 0; i < WMM_NUM_AC; i++) {\n                    if (ar->arAcStreamActive[i]) {\n                        if (ar->arAcStreamPriMap[i] > ar->arHiAcStreamActivePri) {\n                            /* set the new highest active priority */\n                            ar->arHiAcStreamActivePri = ar->arAcStreamPriMap[i];\n                        }\n                    }\n                }\n            }\n        }\n\n        AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n\n    } else {\n            /* for mbox ping testing, the traffic class is mapped directly as a stream ID,\n             * see handling of AR6000_XIOCTL_TRAFFIC_ACTIVITY_CHANGE in ioctl.c\n             * convert the stream ID to a endpoint */\n        eid = arAc2EndpointID(ar, TrafficClass);\n    }\n\n        /* notify HTC, this may cause credit distribution changes */\n\n    HTCIndicateActivityChange(ar->arHtcTarget,\n                              eid,\n                              Active);\n\n}\n\nvoid\nar6000_btcoex_config_event(struct ar6_softc *ar,  u8 *ptr, u32 len)\n{\n\n    WMI_BTCOEX_CONFIG_EVENT *pBtcoexConfig = (WMI_BTCOEX_CONFIG_EVENT *)ptr;\n    WMI_BTCOEX_CONFIG_EVENT *pArbtcoexConfig =&ar->arBtcoexConfig;\n\n    AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"AR6000 BTCOEX CONFIG EVENT \\n\"));\n\n    A_PRINTF(\"received config event\\n\");\n    pArbtcoexConfig->btProfileType = pBtcoexConfig->btProfileType;\n    pArbtcoexConfig->linkId = pBtcoexConfig->linkId;\n\n    switch (pBtcoexConfig->btProfileType) {\n        case WMI_BTCOEX_BT_PROFILE_SCO:\n            memcpy(&pArbtcoexConfig->info.scoConfigCmd, &pBtcoexConfig->info.scoConfigCmd,\n                                        sizeof(WMI_SET_BTCOEX_SCO_CONFIG_CMD));\n            break;\n        case WMI_BTCOEX_BT_PROFILE_A2DP:\n            memcpy(&pArbtcoexConfig->info.a2dpConfigCmd, &pBtcoexConfig->info.a2dpConfigCmd,\n                                        sizeof(WMI_SET_BTCOEX_A2DP_CONFIG_CMD));\n            break;\n        case WMI_BTCOEX_BT_PROFILE_ACLCOEX:\n            memcpy(&pArbtcoexConfig->info.aclcoexConfig, &pBtcoexConfig->info.aclcoexConfig,\n                                        sizeof(WMI_SET_BTCOEX_ACLCOEX_CONFIG_CMD));\n            break;\n        case WMI_BTCOEX_BT_PROFILE_INQUIRY_PAGE:\n           memcpy(&pArbtcoexConfig->info.btinquiryPageConfigCmd, &pBtcoexConfig->info.btinquiryPageConfigCmd,\n                                        sizeof(WMI_SET_BTCOEX_ACLCOEX_CONFIG_CMD));\n            break;\n    }\n    if (ar->statsUpdatePending) {\n         ar->statsUpdatePending = false;\n          wake_up(&arEvent);\n    }\n}\n\nvoid\nar6000_btcoex_stats_event(struct ar6_softc *ar,  u8 *ptr, u32 len)\n{\n    WMI_BTCOEX_STATS_EVENT *pBtcoexStats = (WMI_BTCOEX_STATS_EVENT *)ptr;\n\n    AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"AR6000 BTCOEX CONFIG EVENT \\n\"));\n\n    memcpy(&ar->arBtcoexStats, pBtcoexStats, sizeof(WMI_BTCOEX_STATS_EVENT));\n\n    if (ar->statsUpdatePending) {\n         ar->statsUpdatePending = false;\n        wake_up(&arEvent);\n    }\n\n}\nmodule_init(ar6000_init_module);\nmodule_exit(ar6000_cleanup_module);\n\n/* Init cookie queue */\nstatic void\nar6000_cookie_init(struct ar6_softc *ar)\n{\n    u32 i;\n\n    ar->arCookieList = NULL;\n    ar->arCookieCount = 0;\n\n    A_MEMZERO(s_ar_cookie_mem, sizeof(s_ar_cookie_mem));\n\n    for (i = 0; i < MAX_COOKIE_NUM; i++) {\n        ar6000_free_cookie(ar, &s_ar_cookie_mem[i]);\n    }\n}\n\n/* cleanup cookie queue */\nstatic void\nar6000_cookie_cleanup(struct ar6_softc *ar)\n{\n    /* It is gone .... */\n    ar->arCookieList = NULL;\n    ar->arCookieCount = 0;\n}\n\n/* Init cookie queue */\nstatic void\nar6000_free_cookie(struct ar6_softc *ar, struct ar_cookie * cookie)\n{\n    /* Insert first */\n    A_ASSERT(ar != NULL);\n    A_ASSERT(cookie != NULL);\n\n    cookie->arc_list_next = ar->arCookieList;\n    ar->arCookieList = cookie;\n    ar->arCookieCount++;\n}\n\n/* cleanup cookie queue */\nstatic struct ar_cookie *\nar6000_alloc_cookie(struct ar6_softc  *ar)\n{\n    struct ar_cookie   *cookie;\n\n    cookie = ar->arCookieList;\n    if(cookie != NULL)\n    {\n        ar->arCookieList = cookie->arc_list_next;\n        ar->arCookieCount--;\n    }\n\n    return cookie;\n}\n\nvoid\nar6000_tx_retry_err_event(void *devt)\n{\n    AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"Tx retries reach maximum!\\n\"));\n}\n\nvoid\nar6000_snrThresholdEvent_rx(void *devt, WMI_SNR_THRESHOLD_VAL newThreshold, u8 snr)\n{\n    WMI_SNR_THRESHOLD_EVENT event;\n\n    event.range = newThreshold;\n    event.snr = snr;\n}\n\nvoid\nar6000_lqThresholdEvent_rx(void *devt, WMI_LQ_THRESHOLD_VAL newThreshold, u8 lq)\n{\n    AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"lq threshold range %d, lq %d\\n\", newThreshold, lq));\n}\n\n\n\nu32 a_copy_to_user(void *to, const void *from, u32 n)\n{\n    return(copy_to_user(to, from, n));\n}\n\nu32 a_copy_from_user(void *to, const void *from, u32 n)\n{\n    return(copy_from_user(to, from, n));\n}\n\n\nint\nar6000_get_driver_cfg(struct net_device *dev,\n                        u16 cfgParam,\n                        void *result)\n{\n\n    int    ret = 0;\n\n    switch(cfgParam)\n    {\n        case AR6000_DRIVER_CFG_GET_WLANNODECACHING:\n           *((u32 *)result) = wlanNodeCaching;\n           break;\n        case AR6000_DRIVER_CFG_LOG_RAW_WMI_MSGS:\n           *((u32 *)result) = logWmiRawMsgs;\n            break;\n        default:\n           ret = EINVAL;\n           break;\n    }\n\n    return ret;\n}\n\nvoid\nar6000_keepalive_rx(void *devt, u8 configured)\n{\n    struct ar6_softc *ar = (struct ar6_softc *)devt;\n\n    ar->arKeepaliveConfigured = configured;\n    wake_up(&arEvent);\n}\n\nvoid\nar6000_pmkid_list_event(void *devt, u8 numPMKID, WMI_PMKID *pmkidList,\n                        u8 *bssidList)\n{\n    u8 i, j;\n\n    A_PRINTF(\"Number of Cached PMKIDs is %d\\n\", numPMKID);\n\n    for (i = 0; i < numPMKID; i++) {\n        A_PRINTF(\"\\nBSSID %d \", i);\n            for (j = 0; j < ATH_MAC_LEN; j++) {\n                A_PRINTF(\"%2.2x\", bssidList[j]);\n            }\n        bssidList += (ATH_MAC_LEN + WMI_PMKID_LEN);\n        A_PRINTF(\"\\nPMKID %d \", i);\n            for (j = 0; j < WMI_PMKID_LEN; j++) {\n                A_PRINTF(\"%2.2x\", pmkidList->pmkid[j]);\n            }\n        pmkidList = (WMI_PMKID *)((u8 *)pmkidList + ATH_MAC_LEN +\n                                  WMI_PMKID_LEN);\n    }\n}\n\nvoid ar6000_pspoll_event(struct ar6_softc *ar,u8 aid)\n{\n    sta_t *conn=NULL;\n    bool isPsqEmpty = false;\n\n    conn = ieee80211_find_conn_for_aid(ar, aid);\n\n    /* If the PS q for this STA is not empty, dequeue and send a pkt from\n     * the head of the q. Also update the More data bit in the WMI_DATA_HDR\n     * if there are more pkts for this STA in the PS q. If there are no more\n     * pkts for this STA, update the PVB for this STA.\n     */\n    A_MUTEX_LOCK(&conn->psqLock);\n    isPsqEmpty  = A_NETBUF_QUEUE_EMPTY(&conn->psq);\n    A_MUTEX_UNLOCK(&conn->psqLock);\n\n    if (isPsqEmpty) {\n        /* TODO:No buffered pkts for this STA. Send out a NULL data frame */\n    } else {\n        struct sk_buff *skb = NULL;\n\n        A_MUTEX_LOCK(&conn->psqLock);\n        skb = A_NETBUF_DEQUEUE(&conn->psq);\n        A_MUTEX_UNLOCK(&conn->psqLock);\n        /* Set the STA flag to PSPolled, so that the frame will go out */\n        STA_SET_PS_POLLED(conn);\n        ar6000_data_tx(skb, ar->arNetDev);\n        STA_CLR_PS_POLLED(conn);\n\n        /* Clear the PVB for this STA if the queue has become empty */\n        A_MUTEX_LOCK(&conn->psqLock);\n        isPsqEmpty  = A_NETBUF_QUEUE_EMPTY(&conn->psq);\n        A_MUTEX_UNLOCK(&conn->psqLock);\n\n        if (isPsqEmpty) {\n            wmi_set_pvb_cmd(ar->arWmi, conn->aid, 0);\n        }\n    }\n}\n\nvoid ar6000_dtimexpiry_event(struct ar6_softc *ar)\n{\n    bool isMcastQueued = false;\n    struct sk_buff *skb = NULL;\n\n    /* If there are no associated STAs, ignore the DTIM expiry event.\n     * There can be potential race conditions where the last associated\n     * STA may disconnect & before the host could clear the 'Indicate DTIM'\n     * request to the firmware, the firmware would have just indicated a DTIM\n     * expiry event. The race is between 'clear DTIM expiry cmd' going\n     * from the host to the firmware & the DTIM expiry event happening from\n     * the firmware to the host.\n     */\n    if (ar->sta_list_index == 0) {\n        return;\n    }\n\n    A_MUTEX_LOCK(&ar->mcastpsqLock);\n    isMcastQueued = A_NETBUF_QUEUE_EMPTY(&ar->mcastpsq);\n    A_MUTEX_UNLOCK(&ar->mcastpsqLock);\n\n    A_ASSERT(isMcastQueued == false);\n\n    /* Flush the mcast psq to the target */\n    /* Set the STA flag to DTIMExpired, so that the frame will go out */\n    ar->DTIMExpired = true;\n\n    A_MUTEX_LOCK(&ar->mcastpsqLock);\n    while (!A_NETBUF_QUEUE_EMPTY(&ar->mcastpsq)) {\n        skb = A_NETBUF_DEQUEUE(&ar->mcastpsq);\n        A_MUTEX_UNLOCK(&ar->mcastpsqLock);\n\n        ar6000_data_tx(skb, ar->arNetDev);\n\n        A_MUTEX_LOCK(&ar->mcastpsqLock);\n    }\n    A_MUTEX_UNLOCK(&ar->mcastpsqLock);\n\n    /* Reset the DTIMExpired flag back to 0 */\n    ar->DTIMExpired = false;\n\n    /* Clear the LSB of the BitMapCtl field of the TIM IE */\n    wmi_set_pvb_cmd(ar->arWmi, MCAST_AID, 0);\n}\n\nvoid\nread_rssi_compensation_param(struct ar6_softc *ar)\n{\n    u8 *cust_data_ptr;\n\n//#define RSSICOMPENSATION_PRINT\n\n#ifdef RSSICOMPENSATION_PRINT\n    s16 i;\n    cust_data_ptr = ar6000_get_cust_data_buffer(ar->arTargetType);\n    for (i=0; i<16; i++) {\n        A_PRINTF(\"cust_data_%d = %x \\n\", i, *(u8 *)cust_data_ptr);\n        cust_data_ptr += 1;\n    }\n#endif\n\n    cust_data_ptr = ar6000_get_cust_data_buffer(ar->arTargetType);\n\n    rssi_compensation_param.customerID = *(u16 *)cust_data_ptr & 0xffff;\n    rssi_compensation_param.enable = *(u16 *)(cust_data_ptr+2) & 0xffff;\n    rssi_compensation_param.bg_param_a = *(u16 *)(cust_data_ptr+4) & 0xffff;\n    rssi_compensation_param.bg_param_b = *(u16 *)(cust_data_ptr+6) & 0xffff;\n    rssi_compensation_param.a_param_a = *(u16 *)(cust_data_ptr+8) & 0xffff;\n    rssi_compensation_param.a_param_b = *(u16 *)(cust_data_ptr+10) &0xffff;\n    rssi_compensation_param.reserved = *(u32 *)(cust_data_ptr+12);\n\n#ifdef RSSICOMPENSATION_PRINT\n    A_PRINTF(\"customerID = 0x%x \\n\", rssi_compensation_param.customerID);\n    A_PRINTF(\"enable = 0x%x \\n\", rssi_compensation_param.enable);\n    A_PRINTF(\"bg_param_a = 0x%x and %d \\n\", rssi_compensation_param.bg_param_a, rssi_compensation_param.bg_param_a);\n    A_PRINTF(\"bg_param_b = 0x%x and %d \\n\", rssi_compensation_param.bg_param_b, rssi_compensation_param.bg_param_b);\n    A_PRINTF(\"a_param_a = 0x%x and %d \\n\", rssi_compensation_param.a_param_a, rssi_compensation_param.a_param_a);\n    A_PRINTF(\"a_param_b = 0x%x and %d \\n\", rssi_compensation_param.a_param_b, rssi_compensation_param.a_param_b);\n    A_PRINTF(\"Last 4 bytes = 0x%x \\n\", rssi_compensation_param.reserved);\n#endif\n\n    if (rssi_compensation_param.enable != 0x1) {\n        rssi_compensation_param.enable = 0;\n    }\n\n   return;\n}\n\ns32 rssi_compensation_calc_tcmd(u32 freq, s32 rssi, u32 totalPkt)\n{\n\n    if (freq > 5000)\n    {\n        if (rssi_compensation_param.enable)\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\">>> 11a\\n\"));\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\"rssi before compensation  = %d, totalPkt = %d\\n\", rssi,totalPkt));\n            rssi = rssi * rssi_compensation_param.a_param_a + totalPkt * rssi_compensation_param.a_param_b;\n            rssi = (rssi-50) /100;\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\"rssi after compensation = %d\\n\", rssi));\n        }\n    }\n    else\n    {\n        if (rssi_compensation_param.enable)\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\">>> 11bg\\n\"));\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\"rssi before compensation  = %d, totalPkt = %d\\n\", rssi,totalPkt));\n            rssi = rssi * rssi_compensation_param.bg_param_a + totalPkt * rssi_compensation_param.bg_param_b;\n            rssi = (rssi-50) /100;\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\"rssi after compensation = %d\\n\", rssi));\n        }\n    }\n\n    return rssi;\n}\n\ns16 rssi_compensation_calc(struct ar6_softc *ar, s16 rssi)\n{\n    if (ar->arBssChannel > 5000)\n    {\n        if (rssi_compensation_param.enable)\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\">>> 11a\\n\"));\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\"rssi before compensation  = %d\\n\", rssi));\n            rssi = rssi * rssi_compensation_param.a_param_a + rssi_compensation_param.a_param_b;\n            rssi = (rssi-50) /100;\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\"rssi after compensation = %d\\n\", rssi));\n        }\n    }\n    else\n    {\n        if (rssi_compensation_param.enable)\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\">>> 11bg\\n\"));\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\"rssi before compensation  = %d\\n\", rssi));\n            rssi = rssi * rssi_compensation_param.bg_param_a + rssi_compensation_param.bg_param_b;\n            rssi = (rssi-50) /100;\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\"rssi after compensation = %d\\n\", rssi));\n        }\n    }\n\n    return rssi;\n}\n\ns16 rssi_compensation_reverse_calc(struct ar6_softc *ar, s16 rssi, bool Above)\n{\n    s16 i;\n\n    if (ar->arBssChannel > 5000)\n    {\n        if (rssi_compensation_param.enable)\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\">>> 11a\\n\"));\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\"rssi before rev compensation  = %d\\n\", rssi));\n            rssi = rssi * 100;\n            rssi = (rssi - rssi_compensation_param.a_param_b) / rssi_compensation_param.a_param_a;\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\"rssi after rev compensation = %d\\n\", rssi));\n        }\n    }\n    else\n    {\n        if (rssi_compensation_param.enable)\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\">>> 11bg\\n\"));\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\"rssi before rev compensation  = %d\\n\", rssi));\n\n            if (Above) {\n                for (i=95; i>=0; i--) {\n                    if (rssi <=  rssi_compensation_table[i]) {\n                        rssi = 0 - i;\n                        break;\n                    }\n                }\n            } else {\n                for (i=0; i<=95; i++) {\n                    if (rssi >=  rssi_compensation_table[i]) {\n                        rssi = 0 - i;\n                        break;\n                    }\n                }\n            }\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\"rssi after rev compensation = %d\\n\", rssi));\n        }\n    }\n\n    return rssi;\n}\n\n#ifdef WAPI_ENABLE\nvoid ap_wapi_rekey_event(struct ar6_softc *ar, u8 type, u8 *mac)\n{\n    union iwreq_data wrqu;\n    char buf[20];\n\n    A_MEMZERO(buf, sizeof(buf));\n\n    strcpy(buf, \"WAPI_REKEY\");\n    buf[10] = type;\n    memcpy(&buf[11], mac, ATH_MAC_LEN);\n\n    A_MEMZERO(&wrqu, sizeof(wrqu));\n    wrqu.data.length = 10+1+ATH_MAC_LEN;\n    wireless_send_event(ar->arNetDev, IWEVCUSTOM, &wrqu, buf);\n\n    A_PRINTF(\"WAPI REKEY - %d - %02x:%02x\\n\", type, mac[4], mac[5]);\n}\n#endif\n\nstatic int\nar6000_reinstall_keys(struct ar6_softc *ar, u8 key_op_ctrl)\n{\n    int status = 0;\n    struct ieee80211req_key *uik = &ar->user_saved_keys.ucast_ik;\n    struct ieee80211req_key *bik = &ar->user_saved_keys.bcast_ik;\n    CRYPTO_TYPE  keyType = ar->user_saved_keys.keyType;\n\n    if (IEEE80211_CIPHER_CCKM_KRK != uik->ik_type) {\n        if (NONE_CRYPT == keyType) {\n            goto _reinstall_keys_out;\n        }\n\n        if (uik->ik_keylen) {\n            status = wmi_addKey_cmd(ar->arWmi, uik->ik_keyix,\n                    ar->user_saved_keys.keyType, PAIRWISE_USAGE,\n                    uik->ik_keylen, (u8 *)&uik->ik_keyrsc,\n                    uik->ik_keydata, key_op_ctrl, uik->ik_macaddr, SYNC_BEFORE_WMIFLAG);\n        }\n\n    } else {\n        status = wmi_add_krk_cmd(ar->arWmi, uik->ik_keydata);\n    }\n\n    if (IEEE80211_CIPHER_CCKM_KRK != bik->ik_type) {\n        if (NONE_CRYPT == keyType) {\n            goto _reinstall_keys_out;\n        }\n\n        if (bik->ik_keylen) {\n            status = wmi_addKey_cmd(ar->arWmi, bik->ik_keyix,\n                    ar->user_saved_keys.keyType, GROUP_USAGE,\n                    bik->ik_keylen, (u8 *)&bik->ik_keyrsc,\n                    bik->ik_keydata, key_op_ctrl, bik->ik_macaddr, NO_SYNC_WMIFLAG);\n        }\n    } else {\n        status = wmi_add_krk_cmd(ar->arWmi, bik->ik_keydata);\n    }\n\n_reinstall_keys_out:\n    ar->user_savedkeys_stat = USER_SAVEDKEYS_STAT_INIT;\n    ar->user_key_ctrl      = 0;\n\n    return status;\n}\n\n\nvoid\nar6000_dset_open_req(\n    void *context,\n    u32 id,\n    u32 targHandle,\n    u32 targReplyFn,\n    u32 targReplyArg)\n{\n}\n\nvoid\nar6000_dset_close(\n    void *context,\n    u32 access_cookie)\n{\n    return;\n}\n\nvoid\nar6000_dset_data_req(\n   void *context,\n   u32 accessCookie,\n   u32 offset,\n   u32 length,\n   u32 targBuf,\n   u32 targReplyFn,\n   u32 targReplyArg)\n{\n}\n\nint\nar6000_ap_mode_profile_commit(struct ar6_softc *ar)\n{\n    WMI_CONNECT_CMD p;\n    unsigned long  flags;\n\n    /* No change in AP's profile configuration */\n    if(ar->ap_profile_flag==0) {\n        A_PRINTF(\"COMMIT: No change in profile!!!\\n\");\n        return -ENODATA;\n    }\n\n    if(!ar->arSsidLen) {\n        A_PRINTF(\"SSID not set!!!\\n\");\n        return -ECHRNG;\n    }\n\n    switch(ar->arAuthMode) {\n    case NONE_AUTH:\n        if((ar->arPairwiseCrypto != NONE_CRYPT) &&\n#ifdef WAPI_ENABLE\n           (ar->arPairwiseCrypto != WAPI_CRYPT) &&\n#endif\n           (ar->arPairwiseCrypto != WEP_CRYPT)) {\n            A_PRINTF(\"Cipher not supported in AP mode Open auth\\n\");\n            return -EOPNOTSUPP;\n        }\n        break;\n    case WPA_PSK_AUTH:\n    case WPA2_PSK_AUTH:\n    case (WPA_PSK_AUTH|WPA2_PSK_AUTH):\n        break;\n    default:\n        A_PRINTF(\"This key mgmt type not supported in AP mode\\n\");\n        return -EOPNOTSUPP;\n    }\n\n    /* Update the arNetworkType */\n    ar->arNetworkType = ar->arNextMode;\n\n    A_MEMZERO(&p,sizeof(p));\n    p.ssidLength = ar->arSsidLen;\n    memcpy(p.ssid,ar->arSsid,p.ssidLength);\n    p.channel = ar->arChannelHint;\n    p.networkType = ar->arNetworkType;\n\n    p.dot11AuthMode = ar->arDot11AuthMode;\n    p.authMode = ar->arAuthMode;\n    p.pairwiseCryptoType = ar->arPairwiseCrypto;\n    p.pairwiseCryptoLen = ar->arPairwiseCryptoLen;\n    p.groupCryptoType = ar->arGroupCrypto;\n    p.groupCryptoLen = ar->arGroupCryptoLen;\n    p.ctrl_flags = ar->arConnectCtrlFlags;\n\n    wmi_ap_profile_commit(ar->arWmi, &p);\n    spin_lock_irqsave(&ar->arLock, flags);\n    ar->arConnected  = true;\n    netif_carrier_on(ar->arNetDev);\n    spin_unlock_irqrestore(&ar->arLock, flags);\n    ar->ap_profile_flag = 0;\n    return 0;\n}\n\nint\nar6000_connect_to_ap(struct ar6_softc *ar)\n{\n    /* The ssid length check prevents second \"essid off\" from the user,\n       to be treated as a connect cmd. The second \"essid off\" is ignored.\n    */\n    if((ar->arWmiReady == true) && (ar->arSsidLen > 0) && ar->arNetworkType!=AP_NETWORK)\n    {\n        int status;\n        if((ADHOC_NETWORK != ar->arNetworkType) &&\n           (NONE_AUTH==ar->arAuthMode)          &&\n           (WEP_CRYPT==ar->arPairwiseCrypto)) {\n                ar6000_install_static_wep_keys(ar);\n        }\n\n        if (!ar->arUserBssFilter) {\n            if (wmi_bssfilter_cmd(ar->arWmi, ALL_BSS_FILTER, 0) != 0) {\n                return -EIO;\n            }\n        }\n#ifdef WAPI_ENABLE\n        if (ar->arWapiEnable)  {\n            ar->arPairwiseCrypto = WAPI_CRYPT;\n            ar->arPairwiseCryptoLen = 0;\n            ar->arGroupCrypto = WAPI_CRYPT;\n            ar->arGroupCryptoLen = 0;\n            ar->arAuthMode = NONE_AUTH;\n            ar->arConnectCtrlFlags |= CONNECT_IGNORE_WPAx_GROUP_CIPHER;\n        }\n#endif\n        AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"Connect called with authmode %d dot11 auth %d\"\\\n                        \" PW crypto %d PW crypto Len %d GRP crypto %d\"\\\n                        \" GRP crypto Len %d\\n\",\n                        ar->arAuthMode, ar->arDot11AuthMode,\n                        ar->arPairwiseCrypto, ar->arPairwiseCryptoLen,\n                        ar->arGroupCrypto, ar->arGroupCryptoLen));\n        reconnect_flag = 0;\n        /* Set the listen interval into 1000TUs or more. This value will be indicated to Ap in the conn.\n           later set it back locally at the STA to 100/1000 TUs depending on the power mode */\n        if ((ar->arNetworkType == INFRA_NETWORK)) {\n            wmi_listeninterval_cmd(ar->arWmi, max(ar->arListenIntervalT, (u16)A_MAX_WOW_LISTEN_INTERVAL), 0);\n        }\n        status = wmi_connect_cmd(ar->arWmi, ar->arNetworkType,\n                                 ar->arDot11AuthMode, ar->arAuthMode,\n                                 ar->arPairwiseCrypto, ar->arPairwiseCryptoLen,\n                                 ar->arGroupCrypto,ar->arGroupCryptoLen,\n                                 ar->arSsidLen, ar->arSsid,\n                                 ar->arReqBssid, ar->arChannelHint,\n                                 ar->arConnectCtrlFlags);\n        if (status) {\n            wmi_listeninterval_cmd(ar->arWmi, ar->arListenIntervalT, ar->arListenIntervalB);\n            if (!ar->arUserBssFilter) {\n                wmi_bssfilter_cmd(ar->arWmi, NONE_BSS_FILTER, 0);\n            }\n            return status;\n        }\n\n        if ((!(ar->arConnectCtrlFlags & CONNECT_DO_WPA_OFFLOAD)) &&\n            ((WPA_PSK_AUTH == ar->arAuthMode) || (WPA2_PSK_AUTH == ar->arAuthMode)))\n        {\n            A_TIMEOUT_MS(&ar->disconnect_timer, A_DISCONNECT_TIMER_INTERVAL, 0);\n        }\n\n        ar->arConnectCtrlFlags &= ~CONNECT_DO_WPA_OFFLOAD;\n        \n        ar->arConnectPending = true;\n        return status;    \n    }\n    return A_ERROR;\n}\n\nint\nar6000_disconnect(struct ar6_softc *ar)\n{\n    if ((ar->arConnected == true) || (ar->arConnectPending == true)) {\n        wmi_disconnect_cmd(ar->arWmi);\n        /* \n         * Disconnect cmd is issued, clear connectPending.\n         * arConnected will be cleard in disconnect_event notification.\n         */\n        ar->arConnectPending = false;\n    }\n\n    return 0;\n}\n\nint\nar6000_ap_mode_get_wpa_ie(struct ar6_softc *ar, struct ieee80211req_wpaie *wpaie)\n{\n    sta_t *conn = NULL;\n    conn = ieee80211_find_conn(ar, wpaie->wpa_macaddr);\n\n    A_MEMZERO(wpaie->wpa_ie, IEEE80211_MAX_IE);\n    A_MEMZERO(wpaie->rsn_ie, IEEE80211_MAX_IE);\n\n    if(conn) {\n        memcpy(wpaie->wpa_ie, conn->wpa_ie, IEEE80211_MAX_IE);\n    }\n\n    return 0;\n}\n\nint\nis_iwioctl_allowed(u8 mode, u16 cmd)\n{\n    if(cmd >= SIOCSIWCOMMIT && cmd <= SIOCGIWPOWER) {\n        cmd -= SIOCSIWCOMMIT;\n        if(sioctl_filter[cmd] == 0xFF) return 0;\n        if(sioctl_filter[cmd] & mode) return 0;\n    } else if(cmd >= SIOCIWFIRSTPRIV && cmd <= (SIOCIWFIRSTPRIV+30)) {\n        cmd -= SIOCIWFIRSTPRIV;\n        if(pioctl_filter[cmd] == 0xFF) return 0;\n        if(pioctl_filter[cmd] & mode) return 0;\n    } else {\n        return A_ERROR;\n    }\n    return A_ENOTSUP;\n}\n\nint\nis_xioctl_allowed(u8 mode, int cmd)\n{\n    if(sizeof(xioctl_filter)-1 < cmd) {\n        A_PRINTF(\"Filter for this cmd=%d not defined\\n\",cmd);\n        return 0;\n    }\n    if(xioctl_filter[cmd] == 0xFF) return 0;\n    if(xioctl_filter[cmd] & mode) return 0;\n    return A_ERROR;\n}\n\n#ifdef WAPI_ENABLE\nint\nap_set_wapi_key(struct ar6_softc *ar, void *ikey)\n{\n    struct ieee80211req_key *ik = (struct ieee80211req_key *)ikey;\n    KEY_USAGE   keyUsage = 0;\n    int    status;\n\n    if (memcmp(ik->ik_macaddr, bcast_mac, IEEE80211_ADDR_LEN) == 0) {\n        keyUsage = GROUP_USAGE;\n    } else {\n        keyUsage = PAIRWISE_USAGE;\n    }\n    A_PRINTF(\"WAPI_KEY: Type:%d ix:%d mac:%02x:%02x len:%d\\n\",\n        keyUsage, ik->ik_keyix, ik->ik_macaddr[4], ik->ik_macaddr[5],\n        ik->ik_keylen);\n\n    status = wmi_addKey_cmd(ar->arWmi, ik->ik_keyix, WAPI_CRYPT, keyUsage,\n                            ik->ik_keylen, (u8 *)&ik->ik_keyrsc,\n                            ik->ik_keydata, KEY_OP_INIT_VAL, ik->ik_macaddr,\n                            SYNC_BOTH_WMIFLAG);\n\n    if (0 != status) {\n        return -EIO;\n    }\n    return 0;\n}\n#endif\n\nvoid ar6000_peer_event(\n    void *context,\n    u8 eventCode,\n    u8 *macAddr)\n{\n    u8 pos;\n\n    for (pos=0;pos<6;pos++)\n        printk(\"%02x: \",*(macAddr+pos));\n    printk(\"\\n\");\n}\n\n#ifdef HTC_TEST_SEND_PKTS\n#define HTC_TEST_DUPLICATE 8\nstatic void DoHTCSendPktsTest(struct ar6_softc *ar, int MapNo, HTC_ENDPOINT_ID eid, struct sk_buff *dupskb)\n{\n    struct ar_cookie *cookie;\n    struct ar_cookie *cookieArray[HTC_TEST_DUPLICATE];\n    struct sk_buff   *new_skb;\n    int    i;\n    int    pkts = 0;\n    struct htc_packet_queue pktQueue;\n    EPPING_HEADER    *eppingHdr;\n\n    eppingHdr = A_NETBUF_DATA(dupskb);\n\n    if (eppingHdr->Cmd_h == EPPING_CMD_NO_ECHO) {\n        /* skip test if this is already a tx perf test */\n        return;\n    }\n\n    for (i = 0; i < HTC_TEST_DUPLICATE; i++,pkts++) {\n        AR6000_SPIN_LOCK(&ar->arLock, 0);\n        cookie = ar6000_alloc_cookie(ar);\n        if (cookie != NULL) {\n            ar->arTxPending[eid]++;\n            ar->arTotalTxDataPending++;\n        }\n\n        AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n\n        if (NULL == cookie) {\n            break;\n        }\n\n        new_skb = A_NETBUF_ALLOC(A_NETBUF_LEN(dupskb));\n\n        if (new_skb == NULL) {\n            AR6000_SPIN_LOCK(&ar->arLock, 0);\n            ar6000_free_cookie(ar,cookie);\n            AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n            break;\n        }\n\n        A_NETBUF_PUT_DATA(new_skb, A_NETBUF_DATA(dupskb), A_NETBUF_LEN(dupskb));\n        cookie->arc_bp[0] = (unsigned long)new_skb;\n        cookie->arc_bp[1] = MapNo;\n        SET_HTC_PACKET_INFO_TX(&cookie->HtcPkt,\n                               cookie,\n                               A_NETBUF_DATA(new_skb),\n                               A_NETBUF_LEN(new_skb),\n                               eid,\n                               AR6K_DATA_PKT_TAG);\n\n        cookieArray[i] = cookie;\n\n        {\n            EPPING_HEADER *pHdr = (EPPING_HEADER *)A_NETBUF_DATA(new_skb);\n            pHdr->Cmd_h = EPPING_CMD_NO_ECHO;  /* do not echo the packet */\n        }\n    }\n\n    if (pkts == 0) {\n        return;\n    }\n\n    INIT_HTC_PACKET_QUEUE(&pktQueue);\n\n    for (i = 0; i < pkts; i++) {\n        HTC_PACKET_ENQUEUE(&pktQueue,&cookieArray[i]->HtcPkt);\n    }\n\n    HTCSendPktsMultiple(ar->arHtcTarget, &pktQueue);\n\n}\n#endif\n\n#ifdef CONFIG_AP_VIRTUAL_ADAPTER_SUPPORT\n/*\n * Add support for adding and removing a virtual adapter for soft AP.\n * Some OS requires different adapters names for station and soft AP mode.\n * To support these requirement, create and destroy a netdevice  instance\n * when the AP mode is operational. A full fledged support for virual device\n * is not implemented. Rather a virtual interface is created and is linked\n * with the existing physical device instance during the operation of the \n * AP mode.\n */\n\nint ar6000_start_ap_interface(struct ar6_softc *ar)\n{\n    struct ar_virtual_interface *arApDev;\n\n    /* Change net_device to point to AP instance */\n    arApDev = (struct ar_virtual_interface *)ar->arApDev;\n    ar->arNetDev = arApDev->arNetDev;\n\n    return 0;\n}\n\nint ar6000_stop_ap_interface(struct ar6_softc *ar)\n{\n    struct ar_virtual_interface *arApDev;\n\n    /* Change net_device to point to sta instance */\n    arApDev = (struct ar_virtual_interface *)ar->arApDev;\n    if (arApDev) {\n        ar->arNetDev = arApDev->arStaNetDev;\n    }\n\n    return 0;\n}\n\n\nint ar6000_create_ap_interface(struct ar6_softc *ar, char *ap_ifname)\n{\n    struct net_device *dev;\n    struct ar_virtual_interface *arApDev;\n\n    dev = alloc_etherdev(sizeof(struct ar_virtual_interface));\n    if (dev == NULL) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_create_ap_interface: can't alloc etherdev\\n\"));\n        return A_ERROR;\n    } \n    \n    ether_setup(dev);\n    init_netdev(dev, ap_ifname);\n\n    if (register_netdev(dev)) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_create_ap_interface: register_netdev failed\\n\"));\n        return A_ERROR;\n    }\n\n    arApDev = netdev_priv(dev);\n    arApDev->arDev = ar;\n    arApDev->arNetDev = dev;\n    arApDev->arStaNetDev = ar->arNetDev;\n\n    ar->arApDev = arApDev;\n    arApNetDev = dev;\n\n    /* Copy the MAC address */\n    memcpy(dev->dev_addr, ar->arNetDev->dev_addr, AR6000_ETH_ADDR_LEN);\n\n    return 0;\n}\n\nint ar6000_add_ap_interface(struct ar6_softc *ar, char *ap_ifname)\n{\n    /* Interface already added, need not proceed further */\n    if (ar->arApDev != NULL) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_add_ap_interface: interface already present \\n\"));\n        return 0;\n    }\n\n    if (ar6000_create_ap_interface(ar, ap_ifname) != 0) {\n        return A_ERROR;\n    }\n\n    A_PRINTF(\"Add AP interface %s \\n\",ap_ifname);\n\n    return ar6000_start_ap_interface(ar);\n}\n\nint ar6000_remove_ap_interface(struct ar6_softc *ar)\n{\n    if (arApNetDev) {\n        ar6000_stop_ap_interface(ar);\n\n        unregister_netdev(arApNetDev);\n        free_netdev(apApNetDev);\n\n        A_PRINTF(\"Remove AP interface\\n\");\n    }\n    ar->arApDev = NULL;\n    arApNetDev = NULL;\n\n    \n    return 0;\n}\n#endif /* CONFIG_AP_VIRTUAL_ADAPTER_SUPPORT */\n\n\n#ifdef EXPORT_HCI_BRIDGE_INTERFACE\nEXPORT_SYMBOL(setupbtdev);\n#endif\n", "/* -*- linux-c -*-\n * INET\t\t802.1Q VLAN\n *\t\tEthernet-type device handling.\n *\n * Authors:\tBen Greear <greearb@candelatech.com>\n *              Please send support related email to: netdev@vger.kernel.org\n *              VLAN Home Page: http://www.candelatech.com/~greear/vlan.html\n *\n * Fixes:       Mar 22 2001: Martin Bokaemper <mbokaemper@unispherenetworks.com>\n *                - reset skb->pkt_type on incoming packets when MAC was changed\n *                - see that changed MAC is saddr for outgoing packets\n *              Oct 20, 2001:  Ard van Breeman:\n *                - Fix MC-list, finally.\n *                - Flush MC-list on VLAN destroy.\n *\n *\n *\t\tThis program is free software; you can redistribute it and/or\n *\t\tmodify it under the terms of the GNU General Public License\n *\t\tas published by the Free Software Foundation; either version\n *\t\t2 of the License, or (at your option) any later version.\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <net/arp.h>\n\n#include \"vlan.h\"\n#include \"vlanproc.h\"\n#include <linux/if_vlan.h>\n\n/*\n *\tRebuild the Ethernet MAC header. This is called after an ARP\n *\t(or in future other address resolution) has completed on this\n *\tsk_buff. We now let ARP fill in the other fields.\n *\n *\tThis routine CANNOT use cached dst->neigh!\n *\tReally, it is used only when dst->neigh is wrong.\n *\n * TODO:  This needs a checkup, I'm ignorant here. --BLG\n */\nstatic int vlan_dev_rebuild_header(struct sk_buff *skb)\n{\n\tstruct net_device *dev = skb->dev;\n\tstruct vlan_ethhdr *veth = (struct vlan_ethhdr *)(skb->data);\n\n\tswitch (veth->h_vlan_encapsulated_proto) {\n#ifdef CONFIG_INET\n\tcase htons(ETH_P_IP):\n\n\t\t/* TODO:  Confirm this will work with VLAN headers... */\n\t\treturn arp_find(veth->h_dest, skb);\n#endif\n\tdefault:\n\t\tpr_debug(\"%s: unable to resolve type %X addresses\\n\",\n\t\t\t dev->name, ntohs(veth->h_vlan_encapsulated_proto));\n\n\t\tmemcpy(veth->h_source, dev->dev_addr, ETH_ALEN);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic inline u16\nvlan_dev_get_egress_qos_mask(struct net_device *dev, struct sk_buff *skb)\n{\n\tstruct vlan_priority_tci_mapping *mp;\n\n\tmp = vlan_dev_info(dev)->egress_priority_map[(skb->priority & 0xF)];\n\twhile (mp) {\n\t\tif (mp->priority == skb->priority) {\n\t\t\treturn mp->vlan_qos; /* This should already be shifted\n\t\t\t\t\t      * to mask correctly with the\n\t\t\t\t\t      * VLAN's TCI */\n\t\t}\n\t\tmp = mp->next;\n\t}\n\treturn 0;\n}\n\n/*\n *\tCreate the VLAN header for an arbitrary protocol layer\n *\n *\tsaddr=NULL\tmeans use device source address\n *\tdaddr=NULL\tmeans leave destination address (eg unresolved arp)\n *\n *  This is called when the SKB is moving down the stack towards the\n *  physical devices.\n */\nstatic int vlan_dev_hard_header(struct sk_buff *skb, struct net_device *dev,\n\t\t\t\tunsigned short type,\n\t\t\t\tconst void *daddr, const void *saddr,\n\t\t\t\tunsigned int len)\n{\n\tstruct vlan_hdr *vhdr;\n\tunsigned int vhdrlen = 0;\n\tu16 vlan_tci = 0;\n\tint rc;\n\n\tif (!(vlan_dev_info(dev)->flags & VLAN_FLAG_REORDER_HDR)) {\n\t\tvhdr = (struct vlan_hdr *) skb_push(skb, VLAN_HLEN);\n\n\t\tvlan_tci = vlan_dev_info(dev)->vlan_id;\n\t\tvlan_tci |= vlan_dev_get_egress_qos_mask(dev, skb);\n\t\tvhdr->h_vlan_TCI = htons(vlan_tci);\n\n\t\t/*\n\t\t *  Set the protocol type. For a packet of type ETH_P_802_3/2 we\n\t\t *  put the length in here instead.\n\t\t */\n\t\tif (type != ETH_P_802_3 && type != ETH_P_802_2)\n\t\t\tvhdr->h_vlan_encapsulated_proto = htons(type);\n\t\telse\n\t\t\tvhdr->h_vlan_encapsulated_proto = htons(len);\n\n\t\tskb->protocol = htons(ETH_P_8021Q);\n\t\ttype = ETH_P_8021Q;\n\t\tvhdrlen = VLAN_HLEN;\n\t}\n\n\t/* Before delegating work to the lower layer, enter our MAC-address */\n\tif (saddr == NULL)\n\t\tsaddr = dev->dev_addr;\n\n\t/* Now make the underlying real hard header */\n\tdev = vlan_dev_info(dev)->real_dev;\n\trc = dev_hard_header(skb, dev, type, daddr, saddr, len + vhdrlen);\n\tif (rc > 0)\n\t\trc += vhdrlen;\n\treturn rc;\n}\n\nstatic netdev_tx_t vlan_dev_hard_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t    struct net_device *dev)\n{\n\tstruct vlan_ethhdr *veth = (struct vlan_ethhdr *)(skb->data);\n\tunsigned int len;\n\tint ret;\n\n\t/* Handle non-VLAN frames if they are sent to us, for example by DHCP.\n\t *\n\t * NOTE: THIS ASSUMES DIX ETHERNET, SPECIFICALLY NOT SUPPORTING\n\t * OTHER THINGS LIKE FDDI/TokenRing/802.3 SNAPs...\n\t */\n\tif (veth->h_vlan_proto != htons(ETH_P_8021Q) ||\n\t    vlan_dev_info(dev)->flags & VLAN_FLAG_REORDER_HDR) {\n\t\tu16 vlan_tci;\n\t\tvlan_tci = vlan_dev_info(dev)->vlan_id;\n\t\tvlan_tci |= vlan_dev_get_egress_qos_mask(dev, skb);\n\t\tskb = __vlan_hwaccel_put_tag(skb, vlan_tci);\n\t}\n\n\tskb_set_dev(skb, vlan_dev_info(dev)->real_dev);\n\tlen = skb->len;\n\tret = dev_queue_xmit(skb);\n\n\tif (likely(ret == NET_XMIT_SUCCESS || ret == NET_XMIT_CN)) {\n\t\tstruct vlan_pcpu_stats *stats;\n\n\t\tstats = this_cpu_ptr(vlan_dev_info(dev)->vlan_pcpu_stats);\n\t\tu64_stats_update_begin(&stats->syncp);\n\t\tstats->tx_packets++;\n\t\tstats->tx_bytes += len;\n\t\tu64_stats_update_end(&stats->syncp);\n\t} else {\n\t\tthis_cpu_inc(vlan_dev_info(dev)->vlan_pcpu_stats->tx_dropped);\n\t}\n\n\treturn ret;\n}\n\nstatic int vlan_dev_change_mtu(struct net_device *dev, int new_mtu)\n{\n\t/* TODO: gotta make sure the underlying layer can handle it,\n\t * maybe an IFF_VLAN_CAPABLE flag for devices?\n\t */\n\tif (vlan_dev_info(dev)->real_dev->mtu < new_mtu)\n\t\treturn -ERANGE;\n\n\tdev->mtu = new_mtu;\n\n\treturn 0;\n}\n\nvoid vlan_dev_set_ingress_priority(const struct net_device *dev,\n\t\t\t\t   u32 skb_prio, u16 vlan_prio)\n{\n\tstruct vlan_dev_info *vlan = vlan_dev_info(dev);\n\n\tif (vlan->ingress_priority_map[vlan_prio & 0x7] && !skb_prio)\n\t\tvlan->nr_ingress_mappings--;\n\telse if (!vlan->ingress_priority_map[vlan_prio & 0x7] && skb_prio)\n\t\tvlan->nr_ingress_mappings++;\n\n\tvlan->ingress_priority_map[vlan_prio & 0x7] = skb_prio;\n}\n\nint vlan_dev_set_egress_priority(const struct net_device *dev,\n\t\t\t\t u32 skb_prio, u16 vlan_prio)\n{\n\tstruct vlan_dev_info *vlan = vlan_dev_info(dev);\n\tstruct vlan_priority_tci_mapping *mp = NULL;\n\tstruct vlan_priority_tci_mapping *np;\n\tu32 vlan_qos = (vlan_prio << VLAN_PRIO_SHIFT) & VLAN_PRIO_MASK;\n\n\t/* See if a priority mapping exists.. */\n\tmp = vlan->egress_priority_map[skb_prio & 0xF];\n\twhile (mp) {\n\t\tif (mp->priority == skb_prio) {\n\t\t\tif (mp->vlan_qos && !vlan_qos)\n\t\t\t\tvlan->nr_egress_mappings--;\n\t\t\telse if (!mp->vlan_qos && vlan_qos)\n\t\t\t\tvlan->nr_egress_mappings++;\n\t\t\tmp->vlan_qos = vlan_qos;\n\t\t\treturn 0;\n\t\t}\n\t\tmp = mp->next;\n\t}\n\n\t/* Create a new mapping then. */\n\tmp = vlan->egress_priority_map[skb_prio & 0xF];\n\tnp = kmalloc(sizeof(struct vlan_priority_tci_mapping), GFP_KERNEL);\n\tif (!np)\n\t\treturn -ENOBUFS;\n\n\tnp->next = mp;\n\tnp->priority = skb_prio;\n\tnp->vlan_qos = vlan_qos;\n\tvlan->egress_priority_map[skb_prio & 0xF] = np;\n\tif (vlan_qos)\n\t\tvlan->nr_egress_mappings++;\n\treturn 0;\n}\n\n/* Flags are defined in the vlan_flags enum in include/linux/if_vlan.h file. */\nint vlan_dev_change_flags(const struct net_device *dev, u32 flags, u32 mask)\n{\n\tstruct vlan_dev_info *vlan = vlan_dev_info(dev);\n\tu32 old_flags = vlan->flags;\n\n\tif (mask & ~(VLAN_FLAG_REORDER_HDR | VLAN_FLAG_GVRP |\n\t\t     VLAN_FLAG_LOOSE_BINDING))\n\t\treturn -EINVAL;\n\n\tvlan->flags = (old_flags & ~mask) | (flags & mask);\n\n\tif (netif_running(dev) && (vlan->flags ^ old_flags) & VLAN_FLAG_GVRP) {\n\t\tif (vlan->flags & VLAN_FLAG_GVRP)\n\t\t\tvlan_gvrp_request_join(dev);\n\t\telse\n\t\t\tvlan_gvrp_request_leave(dev);\n\t}\n\treturn 0;\n}\n\nvoid vlan_dev_get_realdev_name(const struct net_device *dev, char *result)\n{\n\tstrncpy(result, vlan_dev_info(dev)->real_dev->name, 23);\n}\n\nstatic int vlan_dev_open(struct net_device *dev)\n{\n\tstruct vlan_dev_info *vlan = vlan_dev_info(dev);\n\tstruct net_device *real_dev = vlan->real_dev;\n\tint err;\n\n\tif (!(real_dev->flags & IFF_UP) &&\n\t    !(vlan->flags & VLAN_FLAG_LOOSE_BINDING))\n\t\treturn -ENETDOWN;\n\n\tif (compare_ether_addr(dev->dev_addr, real_dev->dev_addr)) {\n\t\terr = dev_uc_add(real_dev, dev->dev_addr);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (dev->flags & IFF_ALLMULTI) {\n\t\terr = dev_set_allmulti(real_dev, 1);\n\t\tif (err < 0)\n\t\t\tgoto del_unicast;\n\t}\n\tif (dev->flags & IFF_PROMISC) {\n\t\terr = dev_set_promiscuity(real_dev, 1);\n\t\tif (err < 0)\n\t\t\tgoto clear_allmulti;\n\t}\n\n\tmemcpy(vlan->real_dev_addr, real_dev->dev_addr, ETH_ALEN);\n\n\tif (vlan->flags & VLAN_FLAG_GVRP)\n\t\tvlan_gvrp_request_join(dev);\n\n\tif (netif_carrier_ok(real_dev))\n\t\tnetif_carrier_on(dev);\n\treturn 0;\n\nclear_allmulti:\n\tif (dev->flags & IFF_ALLMULTI)\n\t\tdev_set_allmulti(real_dev, -1);\ndel_unicast:\n\tif (compare_ether_addr(dev->dev_addr, real_dev->dev_addr))\n\t\tdev_uc_del(real_dev, dev->dev_addr);\nout:\n\tnetif_carrier_off(dev);\n\treturn err;\n}\n\nstatic int vlan_dev_stop(struct net_device *dev)\n{\n\tstruct vlan_dev_info *vlan = vlan_dev_info(dev);\n\tstruct net_device *real_dev = vlan->real_dev;\n\n\tdev_mc_unsync(real_dev, dev);\n\tdev_uc_unsync(real_dev, dev);\n\tif (dev->flags & IFF_ALLMULTI)\n\t\tdev_set_allmulti(real_dev, -1);\n\tif (dev->flags & IFF_PROMISC)\n\t\tdev_set_promiscuity(real_dev, -1);\n\n\tif (compare_ether_addr(dev->dev_addr, real_dev->dev_addr))\n\t\tdev_uc_del(real_dev, dev->dev_addr);\n\n\tnetif_carrier_off(dev);\n\treturn 0;\n}\n\nstatic int vlan_dev_set_mac_address(struct net_device *dev, void *p)\n{\n\tstruct net_device *real_dev = vlan_dev_info(dev)->real_dev;\n\tstruct sockaddr *addr = p;\n\tint err;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\tif (!(dev->flags & IFF_UP))\n\t\tgoto out;\n\n\tif (compare_ether_addr(addr->sa_data, real_dev->dev_addr)) {\n\t\terr = dev_uc_add(real_dev, addr->sa_data);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (compare_ether_addr(dev->dev_addr, real_dev->dev_addr))\n\t\tdev_uc_del(real_dev, dev->dev_addr);\n\nout:\n\tmemcpy(dev->dev_addr, addr->sa_data, ETH_ALEN);\n\treturn 0;\n}\n\nstatic int vlan_dev_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tstruct net_device *real_dev = vlan_dev_info(dev)->real_dev;\n\tconst struct net_device_ops *ops = real_dev->netdev_ops;\n\tstruct ifreq ifrr;\n\tint err = -EOPNOTSUPP;\n\n\tstrncpy(ifrr.ifr_name, real_dev->name, IFNAMSIZ);\n\tifrr.ifr_ifru = ifr->ifr_ifru;\n\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\tcase SIOCGMIIREG:\n\tcase SIOCSMIIREG:\n\t\tif (netif_device_present(real_dev) && ops->ndo_do_ioctl)\n\t\t\terr = ops->ndo_do_ioctl(real_dev, &ifrr, cmd);\n\t\tbreak;\n\t}\n\n\tif (!err)\n\t\tifr->ifr_ifru = ifrr.ifr_ifru;\n\n\treturn err;\n}\n\nstatic int vlan_dev_neigh_setup(struct net_device *dev, struct neigh_parms *pa)\n{\n\tstruct net_device *real_dev = vlan_dev_info(dev)->real_dev;\n\tconst struct net_device_ops *ops = real_dev->netdev_ops;\n\tint err = 0;\n\n\tif (netif_device_present(real_dev) && ops->ndo_neigh_setup)\n\t\terr = ops->ndo_neigh_setup(real_dev, pa);\n\n\treturn err;\n}\n\n#if defined(CONFIG_FCOE) || defined(CONFIG_FCOE_MODULE)\nstatic int vlan_dev_fcoe_ddp_setup(struct net_device *dev, u16 xid,\n\t\t\t\t   struct scatterlist *sgl, unsigned int sgc)\n{\n\tstruct net_device *real_dev = vlan_dev_info(dev)->real_dev;\n\tconst struct net_device_ops *ops = real_dev->netdev_ops;\n\tint rc = 0;\n\n\tif (ops->ndo_fcoe_ddp_setup)\n\t\trc = ops->ndo_fcoe_ddp_setup(real_dev, xid, sgl, sgc);\n\n\treturn rc;\n}\n\nstatic int vlan_dev_fcoe_ddp_done(struct net_device *dev, u16 xid)\n{\n\tstruct net_device *real_dev = vlan_dev_info(dev)->real_dev;\n\tconst struct net_device_ops *ops = real_dev->netdev_ops;\n\tint len = 0;\n\n\tif (ops->ndo_fcoe_ddp_done)\n\t\tlen = ops->ndo_fcoe_ddp_done(real_dev, xid);\n\n\treturn len;\n}\n\nstatic int vlan_dev_fcoe_enable(struct net_device *dev)\n{\n\tstruct net_device *real_dev = vlan_dev_info(dev)->real_dev;\n\tconst struct net_device_ops *ops = real_dev->netdev_ops;\n\tint rc = -EINVAL;\n\n\tif (ops->ndo_fcoe_enable)\n\t\trc = ops->ndo_fcoe_enable(real_dev);\n\treturn rc;\n}\n\nstatic int vlan_dev_fcoe_disable(struct net_device *dev)\n{\n\tstruct net_device *real_dev = vlan_dev_info(dev)->real_dev;\n\tconst struct net_device_ops *ops = real_dev->netdev_ops;\n\tint rc = -EINVAL;\n\n\tif (ops->ndo_fcoe_disable)\n\t\trc = ops->ndo_fcoe_disable(real_dev);\n\treturn rc;\n}\n\nstatic int vlan_dev_fcoe_get_wwn(struct net_device *dev, u64 *wwn, int type)\n{\n\tstruct net_device *real_dev = vlan_dev_info(dev)->real_dev;\n\tconst struct net_device_ops *ops = real_dev->netdev_ops;\n\tint rc = -EINVAL;\n\n\tif (ops->ndo_fcoe_get_wwn)\n\t\trc = ops->ndo_fcoe_get_wwn(real_dev, wwn, type);\n\treturn rc;\n}\n\nstatic int vlan_dev_fcoe_ddp_target(struct net_device *dev, u16 xid,\n\t\t\t\t    struct scatterlist *sgl, unsigned int sgc)\n{\n\tstruct net_device *real_dev = vlan_dev_info(dev)->real_dev;\n\tconst struct net_device_ops *ops = real_dev->netdev_ops;\n\tint rc = 0;\n\n\tif (ops->ndo_fcoe_ddp_target)\n\t\trc = ops->ndo_fcoe_ddp_target(real_dev, xid, sgl, sgc);\n\n\treturn rc;\n}\n#endif\n\nstatic void vlan_dev_change_rx_flags(struct net_device *dev, int change)\n{\n\tstruct net_device *real_dev = vlan_dev_info(dev)->real_dev;\n\n\tif (change & IFF_ALLMULTI)\n\t\tdev_set_allmulti(real_dev, dev->flags & IFF_ALLMULTI ? 1 : -1);\n\tif (change & IFF_PROMISC)\n\t\tdev_set_promiscuity(real_dev, dev->flags & IFF_PROMISC ? 1 : -1);\n}\n\nstatic void vlan_dev_set_rx_mode(struct net_device *vlan_dev)\n{\n\tdev_mc_sync(vlan_dev_info(vlan_dev)->real_dev, vlan_dev);\n\tdev_uc_sync(vlan_dev_info(vlan_dev)->real_dev, vlan_dev);\n}\n\n/*\n * vlan network devices have devices nesting below it, and are a special\n * \"super class\" of normal network devices; split their locks off into a\n * separate class since they always nest.\n */\nstatic struct lock_class_key vlan_netdev_xmit_lock_key;\nstatic struct lock_class_key vlan_netdev_addr_lock_key;\n\nstatic void vlan_dev_set_lockdep_one(struct net_device *dev,\n\t\t\t\t     struct netdev_queue *txq,\n\t\t\t\t     void *_subclass)\n{\n\tlockdep_set_class_and_subclass(&txq->_xmit_lock,\n\t\t\t\t       &vlan_netdev_xmit_lock_key,\n\t\t\t\t       *(int *)_subclass);\n}\n\nstatic void vlan_dev_set_lockdep_class(struct net_device *dev, int subclass)\n{\n\tlockdep_set_class_and_subclass(&dev->addr_list_lock,\n\t\t\t\t       &vlan_netdev_addr_lock_key,\n\t\t\t\t       subclass);\n\tnetdev_for_each_tx_queue(dev, vlan_dev_set_lockdep_one, &subclass);\n}\n\nstatic const struct header_ops vlan_header_ops = {\n\t.create\t = vlan_dev_hard_header,\n\t.rebuild = vlan_dev_rebuild_header,\n\t.parse\t = eth_header_parse,\n};\n\nstatic const struct net_device_ops vlan_netdev_ops;\n\nstatic int vlan_dev_init(struct net_device *dev)\n{\n\tstruct net_device *real_dev = vlan_dev_info(dev)->real_dev;\n\tint subclass = 0;\n\n\tnetif_carrier_off(dev);\n\n\t/* IFF_BROADCAST|IFF_MULTICAST; ??? */\n\tdev->flags  = real_dev->flags & ~(IFF_UP | IFF_PROMISC | IFF_ALLMULTI |\n\t\t\t\t\t  IFF_MASTER | IFF_SLAVE);\n\tdev->iflink = real_dev->ifindex;\n\tdev->state  = (real_dev->state & ((1<<__LINK_STATE_NOCARRIER) |\n\t\t\t\t\t  (1<<__LINK_STATE_DORMANT))) |\n\t\t      (1<<__LINK_STATE_PRESENT);\n\n\tdev->hw_features = NETIF_F_ALL_CSUM | NETIF_F_SG |\n\t\t\t   NETIF_F_FRAGLIST | NETIF_F_ALL_TSO |\n\t\t\t   NETIF_F_HIGHDMA | NETIF_F_SCTP_CSUM |\n\t\t\t   NETIF_F_ALL_FCOE;\n\n\tdev->features |= real_dev->vlan_features | NETIF_F_LLTX;\n\tdev->gso_max_size = real_dev->gso_max_size;\n\n\t/* ipv6 shared card related stuff */\n\tdev->dev_id = real_dev->dev_id;\n\n\tif (is_zero_ether_addr(dev->dev_addr))\n\t\tmemcpy(dev->dev_addr, real_dev->dev_addr, dev->addr_len);\n\tif (is_zero_ether_addr(dev->broadcast))\n\t\tmemcpy(dev->broadcast, real_dev->broadcast, dev->addr_len);\n\n#if defined(CONFIG_FCOE) || defined(CONFIG_FCOE_MODULE)\n\tdev->fcoe_ddp_xid = real_dev->fcoe_ddp_xid;\n#endif\n\n\tdev->needed_headroom = real_dev->needed_headroom;\n\tif (real_dev->features & NETIF_F_HW_VLAN_TX) {\n\t\tdev->header_ops      = real_dev->header_ops;\n\t\tdev->hard_header_len = real_dev->hard_header_len;\n\t} else {\n\t\tdev->header_ops      = &vlan_header_ops;\n\t\tdev->hard_header_len = real_dev->hard_header_len + VLAN_HLEN;\n\t}\n\n\tdev->netdev_ops = &vlan_netdev_ops;\n\n\tif (is_vlan_dev(real_dev))\n\t\tsubclass = 1;\n\n\tvlan_dev_set_lockdep_class(dev, subclass);\n\n\tvlan_dev_info(dev)->vlan_pcpu_stats = alloc_percpu(struct vlan_pcpu_stats);\n\tif (!vlan_dev_info(dev)->vlan_pcpu_stats)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void vlan_dev_uninit(struct net_device *dev)\n{\n\tstruct vlan_priority_tci_mapping *pm;\n\tstruct vlan_dev_info *vlan = vlan_dev_info(dev);\n\tint i;\n\n\tfree_percpu(vlan->vlan_pcpu_stats);\n\tvlan->vlan_pcpu_stats = NULL;\n\tfor (i = 0; i < ARRAY_SIZE(vlan->egress_priority_map); i++) {\n\t\twhile ((pm = vlan->egress_priority_map[i]) != NULL) {\n\t\t\tvlan->egress_priority_map[i] = pm->next;\n\t\t\tkfree(pm);\n\t\t}\n\t}\n}\n\nstatic u32 vlan_dev_fix_features(struct net_device *dev, u32 features)\n{\n\tstruct net_device *real_dev = vlan_dev_info(dev)->real_dev;\n\tu32 old_features = features;\n\n\tfeatures &= real_dev->features;\n\tfeatures &= real_dev->vlan_features;\n\n\tfeatures |= old_features & NETIF_F_SOFT_FEATURES;\n\n\tif (dev_ethtool_get_rx_csum(real_dev))\n\t\tfeatures |= NETIF_F_RXCSUM;\n\tfeatures |= NETIF_F_LLTX;\n\n\treturn features;\n}\n\nstatic int vlan_ethtool_get_settings(struct net_device *dev,\n\t\t\t\t     struct ethtool_cmd *cmd)\n{\n\tconst struct vlan_dev_info *vlan = vlan_dev_info(dev);\n\treturn dev_ethtool_get_settings(vlan->real_dev, cmd);\n}\n\nstatic void vlan_ethtool_get_drvinfo(struct net_device *dev,\n\t\t\t\t     struct ethtool_drvinfo *info)\n{\n\tstrcpy(info->driver, vlan_fullname);\n\tstrcpy(info->version, vlan_version);\n\tstrcpy(info->fw_version, \"N/A\");\n}\n\nstatic struct rtnl_link_stats64 *vlan_dev_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)\n{\n\n\tif (vlan_dev_info(dev)->vlan_pcpu_stats) {\n\t\tstruct vlan_pcpu_stats *p;\n\t\tu32 rx_errors = 0, tx_dropped = 0;\n\t\tint i;\n\n\t\tfor_each_possible_cpu(i) {\n\t\t\tu64 rxpackets, rxbytes, rxmulticast, txpackets, txbytes;\n\t\t\tunsigned int start;\n\n\t\t\tp = per_cpu_ptr(vlan_dev_info(dev)->vlan_pcpu_stats, i);\n\t\t\tdo {\n\t\t\t\tstart = u64_stats_fetch_begin_bh(&p->syncp);\n\t\t\t\trxpackets\t= p->rx_packets;\n\t\t\t\trxbytes\t\t= p->rx_bytes;\n\t\t\t\trxmulticast\t= p->rx_multicast;\n\t\t\t\ttxpackets\t= p->tx_packets;\n\t\t\t\ttxbytes\t\t= p->tx_bytes;\n\t\t\t} while (u64_stats_fetch_retry_bh(&p->syncp, start));\n\n\t\t\tstats->rx_packets\t+= rxpackets;\n\t\t\tstats->rx_bytes\t\t+= rxbytes;\n\t\t\tstats->multicast\t+= rxmulticast;\n\t\t\tstats->tx_packets\t+= txpackets;\n\t\t\tstats->tx_bytes\t\t+= txbytes;\n\t\t\t/* rx_errors & tx_dropped are u32 */\n\t\t\trx_errors\t+= p->rx_errors;\n\t\t\ttx_dropped\t+= p->tx_dropped;\n\t\t}\n\t\tstats->rx_errors  = rx_errors;\n\t\tstats->tx_dropped = tx_dropped;\n\t}\n\treturn stats;\n}\n\nstatic const struct ethtool_ops vlan_ethtool_ops = {\n\t.get_settings\t        = vlan_ethtool_get_settings,\n\t.get_drvinfo\t        = vlan_ethtool_get_drvinfo,\n\t.get_link\t\t= ethtool_op_get_link,\n};\n\nstatic const struct net_device_ops vlan_netdev_ops = {\n\t.ndo_change_mtu\t\t= vlan_dev_change_mtu,\n\t.ndo_init\t\t= vlan_dev_init,\n\t.ndo_uninit\t\t= vlan_dev_uninit,\n\t.ndo_open\t\t= vlan_dev_open,\n\t.ndo_stop\t\t= vlan_dev_stop,\n\t.ndo_start_xmit =  vlan_dev_hard_start_xmit,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= vlan_dev_set_mac_address,\n\t.ndo_set_rx_mode\t= vlan_dev_set_rx_mode,\n\t.ndo_set_multicast_list\t= vlan_dev_set_rx_mode,\n\t.ndo_change_rx_flags\t= vlan_dev_change_rx_flags,\n\t.ndo_do_ioctl\t\t= vlan_dev_ioctl,\n\t.ndo_neigh_setup\t= vlan_dev_neigh_setup,\n\t.ndo_get_stats64\t= vlan_dev_get_stats64,\n#if defined(CONFIG_FCOE) || defined(CONFIG_FCOE_MODULE)\n\t.ndo_fcoe_ddp_setup\t= vlan_dev_fcoe_ddp_setup,\n\t.ndo_fcoe_ddp_done\t= vlan_dev_fcoe_ddp_done,\n\t.ndo_fcoe_enable\t= vlan_dev_fcoe_enable,\n\t.ndo_fcoe_disable\t= vlan_dev_fcoe_disable,\n\t.ndo_fcoe_get_wwn\t= vlan_dev_fcoe_get_wwn,\n\t.ndo_fcoe_ddp_target\t= vlan_dev_fcoe_ddp_target,\n#endif\n\t.ndo_fix_features\t= vlan_dev_fix_features,\n};\n\nvoid vlan_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\n\tdev->priv_flags\t\t|= IFF_802_1Q_VLAN;\n\tdev->priv_flags\t\t&= ~IFF_XMIT_DST_RELEASE;\n\tdev->tx_queue_len\t= 0;\n\n\tdev->netdev_ops\t\t= &vlan_netdev_ops;\n\tdev->destructor\t\t= free_netdev;\n\tdev->ethtool_ops\t= &vlan_ethtool_ops;\n\n\tmemset(dev->broadcast, 0, ETH_ALEN);\n}\n", "/*\n   BNEP implementation for Linux Bluetooth stack (BlueZ).\n   Copyright (C) 2001-2002 Inventel Systemes\n   Written 2001-2002 by\n\tCl\u00e9ment Moreau <clement.moreau@inventel.fr>\n\tDavid Libault  <david.libault@inventel.fr>\n\n   Copyright (C) 2002 Maxim Krasnyansky <maxk@qualcomm.com>\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License version 2 as\n   published by the Free Software Foundation;\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.\n   IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY\n   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES\n   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS,\n   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS\n   SOFTWARE IS DISCLAIMED.\n*/\n\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <linux/socket.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/wait.h>\n\n#include <asm/unaligned.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <net/bluetooth/l2cap.h>\n\n#include \"bnep.h\"\n\n#define BNEP_TX_QUEUE_LEN 20\n\nstatic int bnep_net_open(struct net_device *dev)\n{\n\tnetif_start_queue(dev);\n\treturn 0;\n}\n\nstatic int bnep_net_close(struct net_device *dev)\n{\n\tnetif_stop_queue(dev);\n\treturn 0;\n}\n\nstatic void bnep_net_set_mc_list(struct net_device *dev)\n{\n#ifdef CONFIG_BT_BNEP_MC_FILTER\n\tstruct bnep_session *s = netdev_priv(dev);\n\tstruct sock *sk = s->sock->sk;\n\tstruct bnep_set_filter_req *r;\n\tstruct sk_buff *skb;\n\tint size;\n\n\tBT_DBG(\"%s mc_count %d\", dev->name, netdev_mc_count(dev));\n\n\tsize = sizeof(*r) + (BNEP_MAX_MULTICAST_FILTERS + 1) * ETH_ALEN * 2;\n\tskb  = alloc_skb(size, GFP_ATOMIC);\n\tif (!skb) {\n\t\tBT_ERR(\"%s Multicast list allocation failed\", dev->name);\n\t\treturn;\n\t}\n\n\tr = (void *) skb->data;\n\t__skb_put(skb, sizeof(*r));\n\n\tr->type = BNEP_CONTROL;\n\tr->ctrl = BNEP_FILTER_MULTI_ADDR_SET;\n\n\tif (dev->flags & (IFF_PROMISC | IFF_ALLMULTI)) {\n\t\tu8 start[ETH_ALEN] = { 0x01 };\n\n\t\t/* Request all addresses */\n\t\tmemcpy(__skb_put(skb, ETH_ALEN), start, ETH_ALEN);\n\t\tmemcpy(__skb_put(skb, ETH_ALEN), dev->broadcast, ETH_ALEN);\n\t\tr->len = htons(ETH_ALEN * 2);\n\t} else {\n\t\tstruct netdev_hw_addr *ha;\n\t\tint i, len = skb->len;\n\n\t\tif (dev->flags & IFF_BROADCAST) {\n\t\t\tmemcpy(__skb_put(skb, ETH_ALEN), dev->broadcast, ETH_ALEN);\n\t\t\tmemcpy(__skb_put(skb, ETH_ALEN), dev->broadcast, ETH_ALEN);\n\t\t}\n\n\t\t/* FIXME: We should group addresses here. */\n\n\t\ti = 0;\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tif (i == BNEP_MAX_MULTICAST_FILTERS)\n\t\t\t\tbreak;\n\t\t\tmemcpy(__skb_put(skb, ETH_ALEN), ha->addr, ETH_ALEN);\n\t\t\tmemcpy(__skb_put(skb, ETH_ALEN), ha->addr, ETH_ALEN);\n\n\t\t\ti++;\n\t\t}\n\t\tr->len = htons(skb->len - len);\n\t}\n\n\tskb_queue_tail(&sk->sk_write_queue, skb);\n\twake_up_interruptible(sk_sleep(sk));\n#endif\n}\n\nstatic int bnep_net_set_mac_addr(struct net_device *dev, void *arg)\n{\n\tBT_DBG(\"%s\", dev->name);\n\treturn 0;\n}\n\nstatic void bnep_net_timeout(struct net_device *dev)\n{\n\tBT_DBG(\"net_timeout\");\n\tnetif_wake_queue(dev);\n}\n\n#ifdef CONFIG_BT_BNEP_MC_FILTER\nstatic inline int bnep_net_mc_filter(struct sk_buff *skb, struct bnep_session *s)\n{\n\tstruct ethhdr *eh = (void *) skb->data;\n\n\tif ((eh->h_dest[0] & 1) && !test_bit(bnep_mc_hash(eh->h_dest), (ulong *) &s->mc_filter))\n\t\treturn 1;\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_BT_BNEP_PROTO_FILTER\n/* Determine ether protocol. Based on eth_type_trans. */\nstatic inline u16 bnep_net_eth_proto(struct sk_buff *skb)\n{\n\tstruct ethhdr *eh = (void *) skb->data;\n\tu16 proto = ntohs(eh->h_proto);\n\n\tif (proto >= 1536)\n\t\treturn proto;\n\n\tif (get_unaligned((__be16 *) skb->data) == htons(0xFFFF))\n\t\treturn ETH_P_802_3;\n\n\treturn ETH_P_802_2;\n}\n\nstatic inline int bnep_net_proto_filter(struct sk_buff *skb, struct bnep_session *s)\n{\n\tu16 proto = bnep_net_eth_proto(skb);\n\tstruct bnep_proto_filter *f = s->proto_filter;\n\tint i;\n\n\tfor (i = 0; i < BNEP_MAX_PROTO_FILTERS && f[i].end; i++) {\n\t\tif (proto >= f[i].start && proto <= f[i].end)\n\t\t\treturn 0;\n\t}\n\n\tBT_DBG(\"BNEP: filtered skb %p, proto 0x%.4x\", skb, proto);\n\treturn 1;\n}\n#endif\n\nstatic netdev_tx_t bnep_net_xmit(struct sk_buff *skb,\n\t\t\t\t struct net_device *dev)\n{\n\tstruct bnep_session *s = netdev_priv(dev);\n\tstruct sock *sk = s->sock->sk;\n\n\tBT_DBG(\"skb %p, dev %p\", skb, dev);\n\n#ifdef CONFIG_BT_BNEP_MC_FILTER\n\tif (bnep_net_mc_filter(skb, s)) {\n\t\tkfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n#endif\n\n#ifdef CONFIG_BT_BNEP_PROTO_FILTER\n\tif (bnep_net_proto_filter(skb, s)) {\n\t\tkfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n#endif\n\n\t/*\n\t * We cannot send L2CAP packets from here as we are potentially in a bh.\n\t * So we have to queue them and wake up session thread which is sleeping\n\t * on the sk_sleep(sk).\n\t */\n\tdev->trans_start = jiffies;\n\tskb_queue_tail(&sk->sk_write_queue, skb);\n\twake_up_interruptible(sk_sleep(sk));\n\n\tif (skb_queue_len(&sk->sk_write_queue) >= BNEP_TX_QUEUE_LEN) {\n\t\tBT_DBG(\"tx queue is full\");\n\n\t\t/* Stop queuing.\n\t\t * Session thread will do netif_wake_queue() */\n\t\tnetif_stop_queue(dev);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic const struct net_device_ops bnep_netdev_ops = {\n\t.ndo_open            = bnep_net_open,\n\t.ndo_stop            = bnep_net_close,\n\t.ndo_start_xmit\t     = bnep_net_xmit,\n\t.ndo_validate_addr   = eth_validate_addr,\n\t.ndo_set_multicast_list = bnep_net_set_mc_list,\n\t.ndo_set_mac_address = bnep_net_set_mac_addr,\n\t.ndo_tx_timeout      = bnep_net_timeout,\n\t.ndo_change_mtu\t     = eth_change_mtu,\n\n};\n\nvoid bnep_net_setup(struct net_device *dev)\n{\n\n\tmemset(dev->broadcast, 0xff, ETH_ALEN);\n\tdev->addr_len = ETH_ALEN;\n\n\tether_setup(dev);\n\tdev->netdev_ops = &bnep_netdev_ops;\n\n\tdev->watchdog_timeo  = HZ * 2;\n}\n", "/*\n * L2TPv3 ethernet pseudowire driver\n *\n * Copyright (c) 2008,2009,2010 Katalix Systems Ltd\n *\n *\tThis program is free software; you can redistribute it and/or\n *\tmodify it under the terms of the GNU General Public License\n *\tas published by the Free Software Foundation; either version\n *\t2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/socket.h>\n#include <linux/hash.h>\n#include <linux/l2tp.h>\n#include <linux/in.h>\n#include <linux/etherdevice.h>\n#include <linux/spinlock.h>\n#include <net/sock.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/udp.h>\n#include <net/inet_common.h>\n#include <net/inet_hashtables.h>\n#include <net/tcp_states.h>\n#include <net/protocol.h>\n#include <net/xfrm.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n\n#include \"l2tp_core.h\"\n\n/* Default device name. May be overridden by name specified by user */\n#define L2TP_ETH_DEV_NAME\t\"l2tpeth%d\"\n\n/* via netdev_priv() */\nstruct l2tp_eth {\n\tstruct net_device\t*dev;\n\tstruct sock\t\t*tunnel_sock;\n\tstruct l2tp_session\t*session;\n\tstruct list_head\tlist;\n};\n\n/* via l2tp_session_priv() */\nstruct l2tp_eth_sess {\n\tstruct net_device\t*dev;\n};\n\n/* per-net private data for this module */\nstatic unsigned int l2tp_eth_net_id;\nstruct l2tp_eth_net {\n\tstruct list_head l2tp_eth_dev_list;\n\tspinlock_t l2tp_eth_lock;\n};\n\nstatic inline struct l2tp_eth_net *l2tp_eth_pernet(struct net *net)\n{\n\treturn net_generic(net, l2tp_eth_net_id);\n}\n\nstatic int l2tp_eth_dev_init(struct net_device *dev)\n{\n\tstruct l2tp_eth *priv = netdev_priv(dev);\n\n\tpriv->dev = dev;\n\trandom_ether_addr(dev->dev_addr);\n\tmemset(&dev->broadcast[0], 0xff, 6);\n\n\treturn 0;\n}\n\nstatic void l2tp_eth_dev_uninit(struct net_device *dev)\n{\n\tstruct l2tp_eth *priv = netdev_priv(dev);\n\tstruct l2tp_eth_net *pn = l2tp_eth_pernet(dev_net(dev));\n\n\tspin_lock(&pn->l2tp_eth_lock);\n\tlist_del_init(&priv->list);\n\tspin_unlock(&pn->l2tp_eth_lock);\n\tdev_put(dev);\n}\n\nstatic int l2tp_eth_dev_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct l2tp_eth *priv = netdev_priv(dev);\n\tstruct l2tp_session *session = priv->session;\n\n\tl2tp_xmit_skb(session, skb, session->hdr_len);\n\n\tdev->stats.tx_bytes += skb->len;\n\tdev->stats.tx_packets++;\n\n\treturn 0;\n}\n\nstatic struct net_device_ops l2tp_eth_netdev_ops = {\n\t.ndo_init\t\t= l2tp_eth_dev_init,\n\t.ndo_uninit\t\t= l2tp_eth_dev_uninit,\n\t.ndo_start_xmit\t\t= l2tp_eth_dev_xmit,\n};\n\nstatic void l2tp_eth_dev_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\n\tdev->netdev_ops\t\t= &l2tp_eth_netdev_ops;\n\tdev->destructor\t\t= free_netdev;\n}\n\nstatic void l2tp_eth_dev_recv(struct l2tp_session *session, struct sk_buff *skb, int data_len)\n{\n\tstruct l2tp_eth_sess *spriv = l2tp_session_priv(session);\n\tstruct net_device *dev = spriv->dev;\n\n\tif (session->debug & L2TP_MSG_DATA) {\n\t\tunsigned int length;\n\t\tint offset;\n\t\tu8 *ptr = skb->data;\n\n\t\tlength = min(32u, skb->len);\n\t\tif (!pskb_may_pull(skb, length))\n\t\t\tgoto error;\n\n\t\tprintk(KERN_DEBUG \"%s: eth recv: \", session->name);\n\n\t\toffset = 0;\n\t\tdo {\n\t\t\tprintk(\" %02X\", ptr[offset]);\n\t\t} while (++offset < length);\n\n\t\tprintk(\"\\n\");\n\t}\n\n\tif (!pskb_may_pull(skb, sizeof(ETH_HLEN)))\n\t\tgoto error;\n\n\tsecpath_reset(skb);\n\n\t/* checksums verified by L2TP */\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\tskb_dst_drop(skb);\n\tnf_reset(skb);\n\n\tif (dev_forward_skb(dev, skb) == NET_RX_SUCCESS) {\n\t\tdev->stats.rx_packets++;\n\t\tdev->stats.rx_bytes += data_len;\n\t} else\n\t\tdev->stats.rx_errors++;\n\n\treturn;\n\nerror:\n\tdev->stats.rx_errors++;\n\tkfree_skb(skb);\n}\n\nstatic void l2tp_eth_delete(struct l2tp_session *session)\n{\n\tstruct l2tp_eth_sess *spriv;\n\tstruct net_device *dev;\n\n\tif (session) {\n\t\tspriv = l2tp_session_priv(session);\n\t\tdev = spriv->dev;\n\t\tif (dev) {\n\t\t\tunregister_netdev(dev);\n\t\t\tspriv->dev = NULL;\n\t\t}\n\t}\n}\n\n#if defined(CONFIG_L2TP_DEBUGFS) || defined(CONFIG_L2TP_DEBUGFS_MODULE)\nstatic void l2tp_eth_show(struct seq_file *m, void *arg)\n{\n\tstruct l2tp_session *session = arg;\n\tstruct l2tp_eth_sess *spriv = l2tp_session_priv(session);\n\tstruct net_device *dev = spriv->dev;\n\n\tseq_printf(m, \"   interface %s\\n\", dev->name);\n}\n#endif\n\nstatic int l2tp_eth_create(struct net *net, u32 tunnel_id, u32 session_id, u32 peer_session_id, struct l2tp_session_cfg *cfg)\n{\n\tstruct net_device *dev;\n\tchar name[IFNAMSIZ];\n\tstruct l2tp_tunnel *tunnel;\n\tstruct l2tp_session *session;\n\tstruct l2tp_eth *priv;\n\tstruct l2tp_eth_sess *spriv;\n\tint rc;\n\tstruct l2tp_eth_net *pn;\n\n\ttunnel = l2tp_tunnel_find(net, tunnel_id);\n\tif (!tunnel) {\n\t\trc = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tsession = l2tp_session_find(net, tunnel, session_id);\n\tif (session) {\n\t\trc = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tif (cfg->ifname) {\n\t\tdev = dev_get_by_name(net, cfg->ifname);\n\t\tif (dev) {\n\t\t\tdev_put(dev);\n\t\t\trc = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t\tstrlcpy(name, cfg->ifname, IFNAMSIZ);\n\t} else\n\t\tstrcpy(name, L2TP_ETH_DEV_NAME);\n\n\tsession = l2tp_session_create(sizeof(*spriv), tunnel, session_id,\n\t\t\t\t      peer_session_id, cfg);\n\tif (!session) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdev = alloc_netdev(sizeof(*priv), name, l2tp_eth_dev_setup);\n\tif (!dev) {\n\t\trc = -ENOMEM;\n\t\tgoto out_del_session;\n\t}\n\n\tdev_net_set(dev, net);\n\tif (session->mtu == 0)\n\t\tsession->mtu = dev->mtu - session->hdr_len;\n\tdev->mtu = session->mtu;\n\tdev->needed_headroom += session->hdr_len;\n\n\tpriv = netdev_priv(dev);\n\tpriv->dev = dev;\n\tpriv->session = session;\n\tINIT_LIST_HEAD(&priv->list);\n\n\tpriv->tunnel_sock = tunnel->sock;\n\tsession->recv_skb = l2tp_eth_dev_recv;\n\tsession->session_close = l2tp_eth_delete;\n#if defined(CONFIG_L2TP_DEBUGFS) || defined(CONFIG_L2TP_DEBUGFS_MODULE)\n\tsession->show = l2tp_eth_show;\n#endif\n\n\tspriv = l2tp_session_priv(session);\n\tspriv->dev = dev;\n\n\trc = register_netdev(dev);\n\tif (rc < 0)\n\t\tgoto out_del_dev;\n\n\t/* Must be done after register_netdev() */\n\tstrlcpy(session->ifname, dev->name, IFNAMSIZ);\n\n\tdev_hold(dev);\n\tpn = l2tp_eth_pernet(dev_net(dev));\n\tspin_lock(&pn->l2tp_eth_lock);\n\tlist_add(&priv->list, &pn->l2tp_eth_dev_list);\n\tspin_unlock(&pn->l2tp_eth_lock);\n\n\treturn 0;\n\nout_del_dev:\n\tfree_netdev(dev);\nout_del_session:\n\tl2tp_session_delete(session);\nout:\n\treturn rc;\n}\n\nstatic __net_init int l2tp_eth_init_net(struct net *net)\n{\n\tstruct l2tp_eth_net *pn = net_generic(net, l2tp_eth_net_id);\n\n\tINIT_LIST_HEAD(&pn->l2tp_eth_dev_list);\n\tspin_lock_init(&pn->l2tp_eth_lock);\n\n\treturn 0;\n}\n\nstatic struct pernet_operations l2tp_eth_net_ops = {\n\t.init = l2tp_eth_init_net,\n\t.id   = &l2tp_eth_net_id,\n\t.size = sizeof(struct l2tp_eth_net),\n};\n\n\nstatic const struct l2tp_nl_cmd_ops l2tp_eth_nl_cmd_ops = {\n\t.session_create\t= l2tp_eth_create,\n\t.session_delete\t= l2tp_session_delete,\n};\n\n\nstatic int __init l2tp_eth_init(void)\n{\n\tint err = 0;\n\n\terr = l2tp_nl_register_ops(L2TP_PWTYPE_ETH, &l2tp_eth_nl_cmd_ops);\n\tif (err)\n\t\tgoto out;\n\n\terr = register_pernet_device(&l2tp_eth_net_ops);\n\tif (err)\n\t\tgoto out_unreg;\n\n\tprintk(KERN_INFO \"L2TP ethernet pseudowire support (L2TPv3)\\n\");\n\n\treturn 0;\n\nout_unreg:\n\tl2tp_nl_unregister_ops(L2TP_PWTYPE_ETH);\nout:\n\treturn err;\n}\n\nstatic void __exit l2tp_eth_exit(void)\n{\n\tunregister_pernet_device(&l2tp_eth_net_ops);\n\tl2tp_nl_unregister_ops(L2TP_PWTYPE_ETH);\n}\n\nmodule_init(l2tp_eth_init);\nmodule_exit(l2tp_eth_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"James Chapman <jchapman@katalix.com>\");\nMODULE_DESCRIPTION(\"L2TP ethernet pseudowire driver\");\nMODULE_VERSION(\"1.0\");\n", "/*\n * Interface handling (except master interface)\n *\n * Copyright 2002-2005, Instant802 Networks, Inc.\n * Copyright 2005-2006, Devicescape Software, Inc.\n * Copyright (c) 2006 Jiri Benc <jbenc@suse.cz>\n * Copyright 2008, Johannes Berg <johannes@sipsolutions.net>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n */\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/if_arp.h>\n#include <linux/netdevice.h>\n#include <linux/rtnetlink.h>\n#include <net/mac80211.h>\n#include <net/ieee80211_radiotap.h>\n#include \"ieee80211_i.h\"\n#include \"sta_info.h\"\n#include \"debugfs_netdev.h\"\n#include \"mesh.h\"\n#include \"led.h\"\n#include \"driver-ops.h\"\n#include \"wme.h\"\n#include \"rate.h\"\n\n/**\n * DOC: Interface list locking\n *\n * The interface list in each struct ieee80211_local is protected\n * three-fold:\n *\n * (1) modifications may only be done under the RTNL\n * (2) modifications and readers are protected against each other by\n *     the iflist_mtx.\n * (3) modifications are done in an RCU manner so atomic readers\n *     can traverse the list in RCU-safe blocks.\n *\n * As a consequence, reads (traversals) of the list can be protected\n * by either the RTNL, the iflist_mtx or RCU.\n */\n\n\nstatic int ieee80211_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tint meshhdrlen;\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\tmeshhdrlen = (sdata->vif.type == NL80211_IFTYPE_MESH_POINT) ? 5 : 0;\n\n\t/* FIX: what would be proper limits for MTU?\n\t * This interface uses 802.3 frames. */\n\tif (new_mtu < 256 ||\n\t    new_mtu > IEEE80211_MAX_DATA_LEN - 24 - 6 - meshhdrlen) {\n\t\treturn -EINVAL;\n\t}\n\n#ifdef CONFIG_MAC80211_VERBOSE_DEBUG\n\tprintk(KERN_DEBUG \"%s: setting MTU %d\\n\", dev->name, new_mtu);\n#endif /* CONFIG_MAC80211_VERBOSE_DEBUG */\n\tdev->mtu = new_mtu;\n\treturn 0;\n}\n\nstatic int ieee80211_change_mac(struct net_device *dev, void *addr)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct sockaddr *sa = addr;\n\tint ret;\n\n\tif (ieee80211_sdata_running(sdata))\n\t\treturn -EBUSY;\n\n\tret = eth_mac_addr(dev, sa);\n\n\tif (ret == 0)\n\t\tmemcpy(sdata->vif.addr, sa->sa_data, ETH_ALEN);\n\n\treturn ret;\n}\n\nstatic inline int identical_mac_addr_allowed(int type1, int type2)\n{\n\treturn type1 == NL80211_IFTYPE_MONITOR ||\n\t\ttype2 == NL80211_IFTYPE_MONITOR ||\n\t\t(type1 == NL80211_IFTYPE_AP && type2 == NL80211_IFTYPE_WDS) ||\n\t\t(type1 == NL80211_IFTYPE_WDS &&\n\t\t\t(type2 == NL80211_IFTYPE_WDS ||\n\t\t\t type2 == NL80211_IFTYPE_AP)) ||\n\t\t(type1 == NL80211_IFTYPE_AP && type2 == NL80211_IFTYPE_AP_VLAN) ||\n\t\t(type1 == NL80211_IFTYPE_AP_VLAN &&\n\t\t\t(type2 == NL80211_IFTYPE_AP ||\n\t\t\t type2 == NL80211_IFTYPE_AP_VLAN));\n}\n\nstatic int ieee80211_check_concurrent_iface(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t    enum nl80211_iftype iftype)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_sub_if_data *nsdata;\n\tstruct net_device *dev = sdata->dev;\n\n\tASSERT_RTNL();\n\n\t/* we hold the RTNL here so can safely walk the list */\n\tlist_for_each_entry(nsdata, &local->interfaces, list) {\n\t\tstruct net_device *ndev = nsdata->dev;\n\n\t\tif (ndev != dev && ieee80211_sdata_running(nsdata)) {\n\t\t\t/*\n\t\t\t * Allow only a single IBSS interface to be up at any\n\t\t\t * time. This is restricted because beacon distribution\n\t\t\t * cannot work properly if both are in the same IBSS.\n\t\t\t *\n\t\t\t * To remove this restriction we'd have to disallow them\n\t\t\t * from setting the same SSID on different IBSS interfaces\n\t\t\t * belonging to the same hardware. Then, however, we're\n\t\t\t * faced with having to adopt two different TSF timers...\n\t\t\t */\n\t\t\tif (iftype == NL80211_IFTYPE_ADHOC &&\n\t\t\t    nsdata->vif.type == NL80211_IFTYPE_ADHOC)\n\t\t\t\treturn -EBUSY;\n\n\t\t\t/*\n\t\t\t * The remaining checks are only performed for interfaces\n\t\t\t * with the same MAC address.\n\t\t\t */\n\t\t\tif (compare_ether_addr(dev->dev_addr, ndev->dev_addr))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * check whether it may have the same address\n\t\t\t */\n\t\t\tif (!identical_mac_addr_allowed(iftype,\n\t\t\t\t\t\t\tnsdata->vif.type))\n\t\t\t\treturn -ENOTUNIQ;\n\n\t\t\t/*\n\t\t\t * can only add VLANs to enabled APs\n\t\t\t */\n\t\t\tif (iftype == NL80211_IFTYPE_AP_VLAN &&\n\t\t\t    nsdata->vif.type == NL80211_IFTYPE_AP)\n\t\t\t\tsdata->bss = &nsdata->u.ap;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid ieee80211_adjust_monitor_flags(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    const int offset)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tu32 flags = sdata->u.mntr_flags;\n\n#define ADJUST(_f, _s)\tdo {\t\t\t\t\t\\\n\tif (flags & MONITOR_FLAG_##_f)\t\t\t\t\\\n\t\tlocal->fif_##_s += offset;\t\t\t\\\n\t} while (0)\n\n\tADJUST(FCSFAIL, fcsfail);\n\tADJUST(PLCPFAIL, plcpfail);\n\tADJUST(CONTROL, control);\n\tADJUST(CONTROL, pspoll);\n\tADJUST(OTHER_BSS, other_bss);\n\n#undef ADJUST\n}\n\n/*\n * NOTE: Be very careful when changing this function, it must NOT return\n * an error on interface type changes that have been pre-checked, so most\n * checks should be in ieee80211_check_concurrent_iface.\n */\nstatic int ieee80211_do_open(struct net_device *dev, bool coming_up)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\tu32 changed = 0;\n\tint res;\n\tu32 hw_reconf_flags = 0;\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_WDS:\n\t\tif (!is_valid_ether_addr(sdata->u.wds.remote_addr))\n\t\t\treturn -ENOLINK;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tif (!sdata->bss)\n\t\t\treturn -ENOLINK;\n\t\tlist_add(&sdata->u.vlan.list, &sdata->bss->vlans);\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\t\tsdata->bss = &sdata->u.ap;\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_MONITOR:\n\tcase NL80211_IFTYPE_ADHOC:\n\t\t/* no special treatment */\n\t\tbreak;\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\tcase NUM_NL80211_IFTYPES:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\t/* cannot happen */\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\tif (local->open_count == 0) {\n\t\tres = drv_start(local);\n\t\tif (res)\n\t\t\tgoto err_del_bss;\n\t\tif (local->ops->napi_poll)\n\t\t\tnapi_enable(&local->napi);\n\t\t/* we're brought up, everything changes */\n\t\thw_reconf_flags = ~0;\n\t\tieee80211_led_radio(local, true);\n\t\tieee80211_mod_tpt_led_trig(local,\n\t\t\t\t\t   IEEE80211_TPT_LEDTRIG_FL_RADIO, 0);\n\t}\n\n\t/*\n\t * Copy the hopefully now-present MAC address to\n\t * this interface, if it has the special null one.\n\t */\n\tif (is_zero_ether_addr(dev->dev_addr)) {\n\t\tmemcpy(dev->dev_addr,\n\t\t       local->hw.wiphy->perm_addr,\n\t\t       ETH_ALEN);\n\t\tmemcpy(dev->perm_addr, dev->dev_addr, ETH_ALEN);\n\n\t\tif (!is_valid_ether_addr(dev->dev_addr)) {\n\t\t\tif (!local->open_count)\n\t\t\t\tdrv_stop(local);\n\t\t\treturn -EADDRNOTAVAIL;\n\t\t}\n\t}\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\t/* no need to tell driver */\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tif (sdata->u.mntr_flags & MONITOR_FLAG_COOK_FRAMES) {\n\t\t\tlocal->cooked_mntrs++;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* must be before the call to ieee80211_configure_filter */\n\t\tlocal->monitors++;\n\t\tif (local->monitors == 1) {\n\t\t\tlocal->hw.conf.flags |= IEEE80211_CONF_MONITOR;\n\t\t\thw_reconf_flags |= IEEE80211_CONF_CHANGE_MONITOR;\n\t\t}\n\n\t\tieee80211_adjust_monitor_flags(sdata, 1);\n\t\tieee80211_configure_filter(local);\n\n\t\tnetif_carrier_on(dev);\n\t\tbreak;\n\tdefault:\n\t\tif (coming_up) {\n\t\t\tres = drv_add_interface(local, &sdata->vif);\n\t\t\tif (res)\n\t\t\t\tgoto err_stop;\n\t\t}\n\n\t\tif (sdata->vif.type == NL80211_IFTYPE_AP) {\n\t\t\tlocal->fif_pspoll++;\n\t\t\tlocal->fif_probe_req++;\n\n\t\t\tieee80211_configure_filter(local);\n\t\t} else if (sdata->vif.type == NL80211_IFTYPE_ADHOC) {\n\t\t\tlocal->fif_probe_req++;\n\t\t}\n\n\t\tchanged |= ieee80211_reset_erp_info(sdata);\n\t\tieee80211_bss_info_change_notify(sdata, changed);\n\n\t\tif (sdata->vif.type == NL80211_IFTYPE_STATION)\n\t\t\tnetif_carrier_off(dev);\n\t\telse\n\t\t\tnetif_carrier_on(dev);\n\t}\n\n\tset_bit(SDATA_STATE_RUNNING, &sdata->state);\n\n\tif (sdata->vif.type == NL80211_IFTYPE_WDS) {\n\t\t/* Create STA entry for the WDS peer */\n\t\tsta = sta_info_alloc(sdata, sdata->u.wds.remote_addr,\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!sta) {\n\t\t\tres = -ENOMEM;\n\t\t\tgoto err_del_interface;\n\t\t}\n\n\t\t/* no locking required since STA is not live yet */\n\t\tsta->flags |= WLAN_STA_AUTHORIZED;\n\n\t\tres = sta_info_insert(sta);\n\t\tif (res) {\n\t\t\t/* STA has been freed */\n\t\t\tgoto err_del_interface;\n\t\t}\n\n\t\trate_control_rate_init(sta);\n\t}\n\n\t/*\n\t * set_multicast_list will be invoked by the networking core\n\t * which will check whether any increments here were done in\n\t * error and sync them down to the hardware as filter flags.\n\t */\n\tif (sdata->flags & IEEE80211_SDATA_ALLMULTI)\n\t\tatomic_inc(&local->iff_allmultis);\n\n\tif (sdata->flags & IEEE80211_SDATA_PROMISC)\n\t\tatomic_inc(&local->iff_promiscs);\n\n\tmutex_lock(&local->mtx);\n\thw_reconf_flags |= __ieee80211_recalc_idle(local);\n\tmutex_unlock(&local->mtx);\n\n\tif (coming_up)\n\t\tlocal->open_count++;\n\n\tif (hw_reconf_flags) {\n\t\tieee80211_hw_config(local, hw_reconf_flags);\n\t\t/*\n\t\t * set default queue parameters so drivers don't\n\t\t * need to initialise the hardware if the hardware\n\t\t * doesn't start up with sane defaults\n\t\t */\n\t\tieee80211_set_wmm_default(sdata);\n\t}\n\n\tieee80211_recalc_ps(local, -1);\n\n\tnetif_tx_start_all_queues(dev);\n\n\treturn 0;\n err_del_interface:\n\tdrv_remove_interface(local, &sdata->vif);\n err_stop:\n\tif (!local->open_count)\n\t\tdrv_stop(local);\n err_del_bss:\n\tsdata->bss = NULL;\n\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\tlist_del(&sdata->u.vlan.list);\n\tclear_bit(SDATA_STATE_RUNNING, &sdata->state);\n\treturn res;\n}\n\nstatic int ieee80211_open(struct net_device *dev)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tint err;\n\n\t/* fail early if user set an invalid address */\n\tif (!is_valid_ether_addr(dev->dev_addr))\n\t\treturn -EADDRNOTAVAIL;\n\n\terr = ieee80211_check_concurrent_iface(sdata, sdata->vif.type);\n\tif (err)\n\t\treturn err;\n\n\treturn ieee80211_do_open(dev, true);\n}\n\nstatic void ieee80211_do_stop(struct ieee80211_sub_if_data *sdata,\n\t\t\t      bool going_down)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tunsigned long flags;\n\tstruct sk_buff *skb, *tmp;\n\tu32 hw_reconf_flags = 0;\n\tint i;\n\tenum nl80211_channel_type orig_ct;\n\n\tclear_bit(SDATA_STATE_RUNNING, &sdata->state);\n\n\tif (local->scan_sdata == sdata)\n\t\tieee80211_scan_cancel(local);\n\n\t/*\n\t * Stop TX on this interface first.\n\t */\n\tnetif_tx_stop_all_queues(sdata->dev);\n\n\t/*\n\t * Purge work for this interface.\n\t */\n\tieee80211_work_purge(sdata);\n\n\t/*\n\t * Remove all stations associated with this interface.\n\t *\n\t * This must be done before calling ops->remove_interface()\n\t * because otherwise we can later invoke ops->sta_notify()\n\t * whenever the STAs are removed, and that invalidates driver\n\t * assumptions about always getting a vif pointer that is valid\n\t * (because if we remove a STA after ops->remove_interface()\n\t * the driver will have removed the vif info already!)\n\t *\n\t * This is relevant only in AP, WDS and mesh modes, since in\n\t * all other modes we've already removed all stations when\n\t * disconnecting etc.\n\t */\n\tsta_info_flush(local, sdata);\n\n\t/*\n\t * Don't count this interface for promisc/allmulti while it\n\t * is down. dev_mc_unsync() will invoke set_multicast_list\n\t * on the master interface which will sync these down to the\n\t * hardware as filter flags.\n\t */\n\tif (sdata->flags & IEEE80211_SDATA_ALLMULTI)\n\t\tatomic_dec(&local->iff_allmultis);\n\n\tif (sdata->flags & IEEE80211_SDATA_PROMISC)\n\t\tatomic_dec(&local->iff_promiscs);\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP) {\n\t\tlocal->fif_pspoll--;\n\t\tlocal->fif_probe_req--;\n\t} else if (sdata->vif.type == NL80211_IFTYPE_ADHOC) {\n\t\tlocal->fif_probe_req--;\n\t}\n\n\tnetif_addr_lock_bh(sdata->dev);\n\tspin_lock_bh(&local->filter_lock);\n\t__hw_addr_unsync(&local->mc_list, &sdata->dev->mc,\n\t\t\t sdata->dev->addr_len);\n\tspin_unlock_bh(&local->filter_lock);\n\tnetif_addr_unlock_bh(sdata->dev);\n\n\tieee80211_configure_filter(local);\n\n\tdel_timer_sync(&local->dynamic_ps_timer);\n\tcancel_work_sync(&local->dynamic_ps_enable_work);\n\n\t/* APs need special treatment */\n\tif (sdata->vif.type == NL80211_IFTYPE_AP) {\n\t\tstruct ieee80211_sub_if_data *vlan, *tmpsdata;\n\t\tstruct beacon_data *old_beacon =\n\t\t\trtnl_dereference(sdata->u.ap.beacon);\n\n\t\t/* sdata_running will return false, so this will disable */\n\t\tieee80211_bss_info_change_notify(sdata,\n\t\t\t\t\t\t BSS_CHANGED_BEACON_ENABLED);\n\n\t\t/* remove beacon */\n\t\trcu_assign_pointer(sdata->u.ap.beacon, NULL);\n\t\tsynchronize_rcu();\n\t\tkfree(old_beacon);\n\n\t\t/* free all potentially still buffered bcast frames */\n\t\twhile ((skb = skb_dequeue(&sdata->u.ap.ps_bc_buf))) {\n\t\t\tlocal->total_ps_buffered--;\n\t\t\tdev_kfree_skb(skb);\n\t\t}\n\n\t\t/* down all dependent devices, that is VLANs */\n\t\tlist_for_each_entry_safe(vlan, tmpsdata, &sdata->u.ap.vlans,\n\t\t\t\t\t u.vlan.list)\n\t\t\tdev_close(vlan->dev);\n\t\tWARN_ON(!list_empty(&sdata->u.ap.vlans));\n\t}\n\n\tif (going_down)\n\t\tlocal->open_count--;\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tlist_del(&sdata->u.vlan.list);\n\t\t/* no need to tell driver */\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tif (sdata->u.mntr_flags & MONITOR_FLAG_COOK_FRAMES) {\n\t\t\tlocal->cooked_mntrs--;\n\t\t\tbreak;\n\t\t}\n\n\t\tlocal->monitors--;\n\t\tif (local->monitors == 0) {\n\t\t\tlocal->hw.conf.flags &= ~IEEE80211_CONF_MONITOR;\n\t\t\thw_reconf_flags |= IEEE80211_CONF_CHANGE_MONITOR;\n\t\t}\n\n\t\tieee80211_adjust_monitor_flags(sdata, -1);\n\t\tieee80211_configure_filter(local);\n\t\tbreak;\n\tdefault:\n\t\tflush_work(&sdata->work);\n\t\t/*\n\t\t * When we get here, the interface is marked down.\n\t\t * Call synchronize_rcu() to wait for the RX path\n\t\t * should it be using the interface and enqueuing\n\t\t * frames at this very time on another CPU.\n\t\t */\n\t\tsynchronize_rcu();\n\t\tskb_queue_purge(&sdata->skb_queue);\n\n\t\t/*\n\t\t * Disable beaconing here for mesh only, AP and IBSS\n\t\t * are already taken care of.\n\t\t */\n\t\tif (sdata->vif.type == NL80211_IFTYPE_MESH_POINT)\n\t\t\tieee80211_bss_info_change_notify(sdata,\n\t\t\t\tBSS_CHANGED_BEACON_ENABLED);\n\n\t\t/*\n\t\t * Free all remaining keys, there shouldn't be any,\n\t\t * except maybe group keys in AP more or WDS?\n\t\t */\n\t\tieee80211_free_keys(sdata);\n\n\t\tif (going_down)\n\t\t\tdrv_remove_interface(local, &sdata->vif);\n\t}\n\n\tsdata->bss = NULL;\n\n\tmutex_lock(&local->mtx);\n\thw_reconf_flags |= __ieee80211_recalc_idle(local);\n\tmutex_unlock(&local->mtx);\n\n\tieee80211_recalc_ps(local, -1);\n\n\tif (local->open_count == 0) {\n\t\tif (local->ops->napi_poll)\n\t\t\tnapi_disable(&local->napi);\n\t\tieee80211_clear_tx_pending(local);\n\t\tieee80211_stop_device(local);\n\n\t\t/* no reconfiguring after stop! */\n\t\thw_reconf_flags = 0;\n\t}\n\n\t/* Re-calculate channel-type, in case there are multiple vifs\n\t * on different channel types.\n\t */\n\torig_ct = local->_oper_channel_type;\n\tieee80211_set_channel_type(local, NULL, NL80211_CHAN_NO_HT);\n\n\t/* do after stop to avoid reconfiguring when we stop anyway */\n\tif (hw_reconf_flags || (orig_ct != local->_oper_channel_type))\n\t\tieee80211_hw_config(local, hw_reconf_flags);\n\n\tspin_lock_irqsave(&local->queue_stop_reason_lock, flags);\n\tfor (i = 0; i < IEEE80211_MAX_QUEUES; i++) {\n\t\tskb_queue_walk_safe(&local->pending[i], skb, tmp) {\n\t\t\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\t\t\tif (info->control.vif == &sdata->vif) {\n\t\t\t\t__skb_unlink(skb, &local->pending[i]);\n\t\t\t\tdev_kfree_skb_irq(skb);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);\n}\n\nstatic int ieee80211_stop(struct net_device *dev)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\tieee80211_do_stop(sdata, true);\n\n\treturn 0;\n}\n\nstatic void ieee80211_set_multicast_list(struct net_device *dev)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tint allmulti, promisc, sdata_allmulti, sdata_promisc;\n\n\tallmulti = !!(dev->flags & IFF_ALLMULTI);\n\tpromisc = !!(dev->flags & IFF_PROMISC);\n\tsdata_allmulti = !!(sdata->flags & IEEE80211_SDATA_ALLMULTI);\n\tsdata_promisc = !!(sdata->flags & IEEE80211_SDATA_PROMISC);\n\n\tif (allmulti != sdata_allmulti) {\n\t\tif (dev->flags & IFF_ALLMULTI)\n\t\t\tatomic_inc(&local->iff_allmultis);\n\t\telse\n\t\t\tatomic_dec(&local->iff_allmultis);\n\t\tsdata->flags ^= IEEE80211_SDATA_ALLMULTI;\n\t}\n\n\tif (promisc != sdata_promisc) {\n\t\tif (dev->flags & IFF_PROMISC)\n\t\t\tatomic_inc(&local->iff_promiscs);\n\t\telse\n\t\t\tatomic_dec(&local->iff_promiscs);\n\t\tsdata->flags ^= IEEE80211_SDATA_PROMISC;\n\t}\n\tspin_lock_bh(&local->filter_lock);\n\t__hw_addr_sync(&local->mc_list, &dev->mc, dev->addr_len);\n\tspin_unlock_bh(&local->filter_lock);\n\tieee80211_queue_work(&local->hw, &local->reconfig_filter);\n}\n\n/*\n * Called when the netdev is removed or, by the code below, before\n * the interface type changes.\n */\nstatic void ieee80211_teardown_sdata(struct net_device *dev)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tint flushed;\n\tint i;\n\n\t/* free extra data */\n\tieee80211_free_keys(sdata);\n\n\tieee80211_debugfs_remove_netdev(sdata);\n\n\tfor (i = 0; i < IEEE80211_FRAGMENT_MAX; i++)\n\t\t__skb_queue_purge(&sdata->fragments[i].skb_list);\n\tsdata->fragment_next = 0;\n\n\tif (ieee80211_vif_is_mesh(&sdata->vif))\n\t\tmesh_rmc_free(sdata);\n\n\tflushed = sta_info_flush(local, sdata);\n\tWARN_ON(flushed);\n}\n\nstatic u16 ieee80211_netdev_select_queue(struct net_device *dev,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\treturn ieee80211_select_queue(IEEE80211_DEV_TO_SUB_IF(dev), skb);\n}\n\nstatic const struct net_device_ops ieee80211_dataif_ops = {\n\t.ndo_open\t\t= ieee80211_open,\n\t.ndo_stop\t\t= ieee80211_stop,\n\t.ndo_uninit\t\t= ieee80211_teardown_sdata,\n\t.ndo_start_xmit\t\t= ieee80211_subif_start_xmit,\n\t.ndo_set_multicast_list = ieee80211_set_multicast_list,\n\t.ndo_change_mtu \t= ieee80211_change_mtu,\n\t.ndo_set_mac_address \t= ieee80211_change_mac,\n\t.ndo_select_queue\t= ieee80211_netdev_select_queue,\n};\n\nstatic u16 ieee80211_monitor_select_queue(struct net_device *dev,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_radiotap_header *rtap = (void *)skb->data;\n\tu8 *p;\n\n\tif (local->hw.queues < 4)\n\t\treturn 0;\n\n\tif (skb->len < 4 ||\n\t    skb->len < le16_to_cpu(rtap->it_len) + 2 /* frame control */)\n\t\treturn 0; /* doesn't matter, frame will be dropped */\n\n\thdr = (void *)((u8 *)skb->data + le16_to_cpu(rtap->it_len));\n\n\tif (!ieee80211_is_data(hdr->frame_control)) {\n\t\tskb->priority = 7;\n\t\treturn ieee802_1d_to_ac[skb->priority];\n\t}\n\tif (!ieee80211_is_data_qos(hdr->frame_control)) {\n\t\tskb->priority = 0;\n\t\treturn ieee802_1d_to_ac[skb->priority];\n\t}\n\n\tp = ieee80211_get_qos_ctl(hdr);\n\tskb->priority = *p & IEEE80211_QOS_CTL_TAG1D_MASK;\n\n\treturn ieee80211_downgrade_queue(local, skb);\n}\n\nstatic const struct net_device_ops ieee80211_monitorif_ops = {\n\t.ndo_open\t\t= ieee80211_open,\n\t.ndo_stop\t\t= ieee80211_stop,\n\t.ndo_uninit\t\t= ieee80211_teardown_sdata,\n\t.ndo_start_xmit\t\t= ieee80211_monitor_start_xmit,\n\t.ndo_set_multicast_list = ieee80211_set_multicast_list,\n\t.ndo_change_mtu \t= ieee80211_change_mtu,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_select_queue\t= ieee80211_monitor_select_queue,\n};\n\nstatic void ieee80211_if_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\tdev->netdev_ops = &ieee80211_dataif_ops;\n\tdev->destructor = free_netdev;\n}\n\nstatic void ieee80211_iface_work(struct work_struct *work)\n{\n\tstruct ieee80211_sub_if_data *sdata =\n\t\tcontainer_of(work, struct ieee80211_sub_if_data, work);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sk_buff *skb;\n\tstruct sta_info *sta;\n\tstruct ieee80211_ra_tid *ra_tid;\n\n\tif (!ieee80211_sdata_running(sdata))\n\t\treturn;\n\n\tif (local->scanning)\n\t\treturn;\n\n\t/*\n\t * ieee80211_queue_work() should have picked up most cases,\n\t * here we'll pick the rest.\n\t */\n\tif (WARN(local->suspended,\n\t\t \"interface work scheduled while going to suspend\\n\"))\n\t\treturn;\n\n\t/* first process frames */\n\twhile ((skb = skb_dequeue(&sdata->skb_queue))) {\n\t\tstruct ieee80211_mgmt *mgmt = (void *)skb->data;\n\n\t\tif (skb->pkt_type == IEEE80211_SDATA_QUEUE_AGG_START) {\n\t\t\tra_tid = (void *)&skb->cb;\n\t\t\tieee80211_start_tx_ba_cb(&sdata->vif, ra_tid->ra,\n\t\t\t\t\t\t ra_tid->tid);\n\t\t} else if (skb->pkt_type == IEEE80211_SDATA_QUEUE_AGG_STOP) {\n\t\t\tra_tid = (void *)&skb->cb;\n\t\t\tieee80211_stop_tx_ba_cb(&sdata->vif, ra_tid->ra,\n\t\t\t\t\t\tra_tid->tid);\n\t\t} else if (ieee80211_is_action(mgmt->frame_control) &&\n\t\t\t   mgmt->u.action.category == WLAN_CATEGORY_BACK) {\n\t\t\tint len = skb->len;\n\n\t\t\tmutex_lock(&local->sta_mtx);\n\t\t\tsta = sta_info_get_bss(sdata, mgmt->sa);\n\t\t\tif (sta) {\n\t\t\t\tswitch (mgmt->u.action.u.addba_req.action_code) {\n\t\t\t\tcase WLAN_ACTION_ADDBA_REQ:\n\t\t\t\t\tieee80211_process_addba_request(\n\t\t\t\t\t\t\tlocal, sta, mgmt, len);\n\t\t\t\t\tbreak;\n\t\t\t\tcase WLAN_ACTION_ADDBA_RESP:\n\t\t\t\t\tieee80211_process_addba_resp(local, sta,\n\t\t\t\t\t\t\t\t     mgmt, len);\n\t\t\t\t\tbreak;\n\t\t\t\tcase WLAN_ACTION_DELBA:\n\t\t\t\t\tieee80211_process_delba(sdata, sta,\n\t\t\t\t\t\t\t\tmgmt, len);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tWARN_ON(1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmutex_unlock(&local->sta_mtx);\n\t\t} else if (ieee80211_is_data_qos(mgmt->frame_control)) {\n\t\t\tstruct ieee80211_hdr *hdr = (void *)mgmt;\n\t\t\t/*\n\t\t\t * So the frame isn't mgmt, but frame_control\n\t\t\t * is at the right place anyway, of course, so\n\t\t\t * the if statement is correct.\n\t\t\t *\n\t\t\t * Warn if we have other data frame types here,\n\t\t\t * they must not get here.\n\t\t\t */\n\t\t\tWARN_ON(hdr->frame_control &\n\t\t\t\t\tcpu_to_le16(IEEE80211_STYPE_NULLFUNC));\n\t\t\tWARN_ON(!(hdr->seq_ctrl &\n\t\t\t\t\tcpu_to_le16(IEEE80211_SCTL_FRAG)));\n\t\t\t/*\n\t\t\t * This was a fragment of a frame, received while\n\t\t\t * a block-ack session was active. That cannot be\n\t\t\t * right, so terminate the session.\n\t\t\t */\n\t\t\tmutex_lock(&local->sta_mtx);\n\t\t\tsta = sta_info_get_bss(sdata, mgmt->sa);\n\t\t\tif (sta) {\n\t\t\t\tu16 tid = *ieee80211_get_qos_ctl(hdr) &\n\t\t\t\t\t\tIEEE80211_QOS_CTL_TID_MASK;\n\n\t\t\t\t__ieee80211_stop_rx_ba_session(\n\t\t\t\t\tsta, tid, WLAN_BACK_RECIPIENT,\n\t\t\t\t\tWLAN_REASON_QSTA_REQUIRE_SETUP,\n\t\t\t\t\ttrue);\n\t\t\t}\n\t\t\tmutex_unlock(&local->sta_mtx);\n\t\t} else switch (sdata->vif.type) {\n\t\tcase NL80211_IFTYPE_STATION:\n\t\t\tieee80211_sta_rx_queued_mgmt(sdata, skb);\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_ADHOC:\n\t\t\tieee80211_ibss_rx_queued_mgmt(sdata, skb);\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_MESH_POINT:\n\t\t\tif (!ieee80211_vif_is_mesh(&sdata->vif))\n\t\t\t\tbreak;\n\t\t\tieee80211_mesh_rx_queued_mgmt(sdata, skb);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN(1, \"frame for unexpected interface type\");\n\t\t\tbreak;\n\t\t}\n\n\t\tkfree_skb(skb);\n\t}\n\n\t/* then other type-dependent work */\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tieee80211_sta_work(sdata);\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tieee80211_ibss_work(sdata);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (!ieee80211_vif_is_mesh(&sdata->vif))\n\t\t\tbreak;\n\t\tieee80211_mesh_work(sdata);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n\n/*\n * Helper function to initialise an interface to a specific type.\n */\nstatic void ieee80211_setup_sdata(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  enum nl80211_iftype type)\n{\n\t/* clear type-dependent union */\n\tmemset(&sdata->u, 0, sizeof(sdata->u));\n\n\t/* and set some type-dependent values */\n\tsdata->vif.type = type;\n\tsdata->vif.p2p = false;\n\tsdata->dev->netdev_ops = &ieee80211_dataif_ops;\n\tsdata->wdev.iftype = type;\n\n\tsdata->control_port_protocol = cpu_to_be16(ETH_P_PAE);\n\tsdata->control_port_no_encrypt = false;\n\n\t/* only monitor differs */\n\tsdata->dev->type = ARPHRD_ETHER;\n\n\tskb_queue_head_init(&sdata->skb_queue);\n\tINIT_WORK(&sdata->work, ieee80211_iface_work);\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\ttype = NL80211_IFTYPE_AP;\n\t\tsdata->vif.type = type;\n\t\tsdata->vif.p2p = true;\n\t\t/* fall through */\n\tcase NL80211_IFTYPE_AP:\n\t\tskb_queue_head_init(&sdata->u.ap.ps_bc_buf);\n\t\tINIT_LIST_HEAD(&sdata->u.ap.vlans);\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\ttype = NL80211_IFTYPE_STATION;\n\t\tsdata->vif.type = type;\n\t\tsdata->vif.p2p = true;\n\t\t/* fall through */\n\tcase NL80211_IFTYPE_STATION:\n\t\tieee80211_sta_setup_sdata(sdata);\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tieee80211_ibss_setup_sdata(sdata);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (ieee80211_vif_is_mesh(&sdata->vif))\n\t\t\tieee80211_mesh_init_sdata(sdata);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tsdata->dev->type = ARPHRD_IEEE80211_RADIOTAP;\n\t\tsdata->dev->netdev_ops = &ieee80211_monitorif_ops;\n\t\tsdata->u.mntr_flags = MONITOR_FLAG_CONTROL |\n\t\t\t\t      MONITOR_FLAG_OTHER_BSS;\n\t\tbreak;\n\tcase NL80211_IFTYPE_WDS:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tbreak;\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\tcase NUM_NL80211_IFTYPES:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\tieee80211_debugfs_add_netdev(sdata);\n}\n\nstatic int ieee80211_runtime_change_iftype(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t   enum nl80211_iftype type)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tint ret, err;\n\tenum nl80211_iftype internal_type = type;\n\tbool p2p = false;\n\n\tASSERT_RTNL();\n\n\tif (!local->ops->change_interface)\n\t\treturn -EBUSY;\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\t\t/*\n\t\t * Could maybe also all others here?\n\t\t * Just not sure how that interacts\n\t\t * with the RX/config path e.g. for\n\t\t * mesh.\n\t\t */\n\t\tbreak;\n\tdefault:\n\t\treturn -EBUSY;\n\t}\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\t\t/*\n\t\t * Could probably support everything\n\t\t * but WDS here (WDS do_open can fail\n\t\t * under memory pressure, which this\n\t\t * code isn't prepared to handle).\n\t\t */\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tp2p = true;\n\t\tinternal_type = NL80211_IFTYPE_STATION;\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tp2p = true;\n\t\tinternal_type = NL80211_IFTYPE_AP;\n\t\tbreak;\n\tdefault:\n\t\treturn -EBUSY;\n\t}\n\n\tret = ieee80211_check_concurrent_iface(sdata, internal_type);\n\tif (ret)\n\t\treturn ret;\n\n\tieee80211_do_stop(sdata, false);\n\n\tieee80211_teardown_sdata(sdata->dev);\n\n\tret = drv_change_interface(local, sdata, internal_type, p2p);\n\tif (ret)\n\t\ttype = sdata->vif.type;\n\n\tieee80211_setup_sdata(sdata, type);\n\n\terr = ieee80211_do_open(sdata->dev, false);\n\tWARN(err, \"type change: do_open returned %d\", err);\n\n\treturn ret;\n}\n\nint ieee80211_if_change_type(struct ieee80211_sub_if_data *sdata,\n\t\t\t     enum nl80211_iftype type)\n{\n\tint ret;\n\n\tASSERT_RTNL();\n\n\tif (type == ieee80211_vif_type_p2p(&sdata->vif))\n\t\treturn 0;\n\n\t/* Setting ad-hoc mode on non-IBSS channel is not supported. */\n\tif (sdata->local->oper_channel->flags & IEEE80211_CHAN_NO_IBSS &&\n\t    type == NL80211_IFTYPE_ADHOC)\n\t\treturn -EOPNOTSUPP;\n\n\tif (ieee80211_sdata_running(sdata)) {\n\t\tret = ieee80211_runtime_change_iftype(sdata, type);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\t/* Purge and reset type-dependent state. */\n\t\tieee80211_teardown_sdata(sdata->dev);\n\t\tieee80211_setup_sdata(sdata, type);\n\t}\n\n\t/* reset some values that shouldn't be kept across type changes */\n\tsdata->vif.bss_conf.basic_rates =\n\t\tieee80211_mandatory_rates(sdata->local,\n\t\t\tsdata->local->hw.conf.channel->band);\n\tsdata->drop_unencrypted = 0;\n\tif (type == NL80211_IFTYPE_STATION)\n\t\tsdata->u.mgd.use_4addr = false;\n\n\treturn 0;\n}\n\nstatic void ieee80211_assign_perm_addr(struct ieee80211_local *local,\n\t\t\t\t       struct net_device *dev,\n\t\t\t\t       enum nl80211_iftype type)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tu64 mask, start, addr, val, inc;\n\tu8 *m;\n\tu8 tmp_addr[ETH_ALEN];\n\tint i;\n\n\t/* default ... something at least */\n\tmemcpy(dev->perm_addr, local->hw.wiphy->perm_addr, ETH_ALEN);\n\n\tif (is_zero_ether_addr(local->hw.wiphy->addr_mask) &&\n\t    local->hw.wiphy->n_addresses <= 1)\n\t\treturn;\n\n\n\tmutex_lock(&local->iflist_mtx);\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_MONITOR:\n\t\t/* doesn't matter */\n\t\tbreak;\n\tcase NL80211_IFTYPE_WDS:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\t/* match up with an AP interface */\n\t\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\t\tif (sdata->vif.type != NL80211_IFTYPE_AP)\n\t\t\t\tcontinue;\n\t\t\tmemcpy(dev->perm_addr, sdata->vif.addr, ETH_ALEN);\n\t\t\tbreak;\n\t\t}\n\t\t/* keep default if no AP interface present */\n\t\tbreak;\n\tdefault:\n\t\t/* assign a new address if possible -- try n_addresses first */\n\t\tfor (i = 0; i < local->hw.wiphy->n_addresses; i++) {\n\t\t\tbool used = false;\n\n\t\t\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\t\t\tif (memcmp(local->hw.wiphy->addresses[i].addr,\n\t\t\t\t\t   sdata->vif.addr, ETH_ALEN) == 0) {\n\t\t\t\t\tused = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!used) {\n\t\t\t\tmemcpy(dev->perm_addr,\n\t\t\t\t       local->hw.wiphy->addresses[i].addr,\n\t\t\t\t       ETH_ALEN);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* try mask if available */\n\t\tif (is_zero_ether_addr(local->hw.wiphy->addr_mask))\n\t\t\tbreak;\n\n\t\tm = local->hw.wiphy->addr_mask;\n\t\tmask =\t((u64)m[0] << 5*8) | ((u64)m[1] << 4*8) |\n\t\t\t((u64)m[2] << 3*8) | ((u64)m[3] << 2*8) |\n\t\t\t((u64)m[4] << 1*8) | ((u64)m[5] << 0*8);\n\n\t\tif (__ffs64(mask) + hweight64(mask) != fls64(mask)) {\n\t\t\t/* not a contiguous mask ... not handled now! */\n\t\t\tprintk(KERN_DEBUG \"not contiguous\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tm = local->hw.wiphy->perm_addr;\n\t\tstart = ((u64)m[0] << 5*8) | ((u64)m[1] << 4*8) |\n\t\t\t((u64)m[2] << 3*8) | ((u64)m[3] << 2*8) |\n\t\t\t((u64)m[4] << 1*8) | ((u64)m[5] << 0*8);\n\n\t\tinc = 1ULL<<__ffs64(mask);\n\t\tval = (start & mask);\n\t\taddr = (start & ~mask) | (val & mask);\n\t\tdo {\n\t\t\tbool used = false;\n\n\t\t\ttmp_addr[5] = addr >> 0*8;\n\t\t\ttmp_addr[4] = addr >> 1*8;\n\t\t\ttmp_addr[3] = addr >> 2*8;\n\t\t\ttmp_addr[2] = addr >> 3*8;\n\t\t\ttmp_addr[1] = addr >> 4*8;\n\t\t\ttmp_addr[0] = addr >> 5*8;\n\n\t\t\tval += inc;\n\n\t\t\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\t\t\tif (memcmp(tmp_addr, sdata->vif.addr,\n\t\t\t\t\t\t\tETH_ALEN) == 0) {\n\t\t\t\t\tused = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!used) {\n\t\t\t\tmemcpy(dev->perm_addr, tmp_addr, ETH_ALEN);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\taddr = (start & ~mask) | (val & mask);\n\t\t} while (addr != start);\n\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&local->iflist_mtx);\n}\n\nint ieee80211_if_add(struct ieee80211_local *local, const char *name,\n\t\t     struct net_device **new_dev, enum nl80211_iftype type,\n\t\t     struct vif_params *params)\n{\n\tstruct net_device *ndev;\n\tstruct ieee80211_sub_if_data *sdata = NULL;\n\tint ret, i;\n\n\tASSERT_RTNL();\n\n\tndev = alloc_netdev_mqs(sizeof(*sdata) + local->hw.vif_data_size,\n\t\t\t\tname, ieee80211_if_setup, local->hw.queues, 1);\n\tif (!ndev)\n\t\treturn -ENOMEM;\n\tdev_net_set(ndev, wiphy_net(local->hw.wiphy));\n\n\tndev->needed_headroom = local->tx_headroom +\n\t\t\t\t4*6 /* four MAC addresses */\n\t\t\t\t+ 2 + 2 + 2 + 2 /* ctl, dur, seq, qos */\n\t\t\t\t+ 6 /* mesh */\n\t\t\t\t+ 8 /* rfc1042/bridge tunnel */\n\t\t\t\t- ETH_HLEN /* ethernet hard_header_len */\n\t\t\t\t+ IEEE80211_ENCRYPT_HEADROOM;\n\tndev->needed_tailroom = IEEE80211_ENCRYPT_TAILROOM;\n\n\tret = dev_alloc_name(ndev, ndev->name);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tieee80211_assign_perm_addr(local, ndev, type);\n\tmemcpy(ndev->dev_addr, ndev->perm_addr, ETH_ALEN);\n\tSET_NETDEV_DEV(ndev, wiphy_dev(local->hw.wiphy));\n\n\t/* don't use IEEE80211_DEV_TO_SUB_IF because it checks too much */\n\tsdata = netdev_priv(ndev);\n\tndev->ieee80211_ptr = &sdata->wdev;\n\tmemcpy(sdata->vif.addr, ndev->dev_addr, ETH_ALEN);\n\tmemcpy(sdata->name, ndev->name, IFNAMSIZ);\n\n\t/* initialise type-independent data */\n\tsdata->wdev.wiphy = local->hw.wiphy;\n\tsdata->local = local;\n\tsdata->dev = ndev;\n#ifdef CONFIG_INET\n\tsdata->arp_filter_state = true;\n#endif\n\n\tfor (i = 0; i < IEEE80211_FRAGMENT_MAX; i++)\n\t\tskb_queue_head_init(&sdata->fragments[i].skb_list);\n\n\tINIT_LIST_HEAD(&sdata->key_list);\n\n\tfor (i = 0; i < IEEE80211_NUM_BANDS; i++) {\n\t\tstruct ieee80211_supported_band *sband;\n\t\tsband = local->hw.wiphy->bands[i];\n\t\tsdata->rc_rateidx_mask[i] =\n\t\t\tsband ? (1 << sband->n_bitrates) - 1 : 0;\n\t}\n\n\t/* setup type-dependent data */\n\tieee80211_setup_sdata(sdata, type);\n\n\tif (params) {\n\t\tndev->ieee80211_ptr->use_4addr = params->use_4addr;\n\t\tif (type == NL80211_IFTYPE_STATION)\n\t\t\tsdata->u.mgd.use_4addr = params->use_4addr;\n\t}\n\n\tret = register_netdevice(ndev);\n\tif (ret)\n\t\tgoto fail;\n\n\tmutex_lock(&local->iflist_mtx);\n\tlist_add_tail_rcu(&sdata->list, &local->interfaces);\n\tmutex_unlock(&local->iflist_mtx);\n\n\tif (new_dev)\n\t\t*new_dev = ndev;\n\n\treturn 0;\n\n fail:\n\tfree_netdev(ndev);\n\treturn ret;\n}\n\nvoid ieee80211_if_remove(struct ieee80211_sub_if_data *sdata)\n{\n\tASSERT_RTNL();\n\n\tmutex_lock(&sdata->local->iflist_mtx);\n\tlist_del_rcu(&sdata->list);\n\tmutex_unlock(&sdata->local->iflist_mtx);\n\n\tsynchronize_rcu();\n\tunregister_netdevice(sdata->dev);\n}\n\n/*\n * Remove all interfaces, may only be called at hardware unregistration\n * time because it doesn't do RCU-safe list removals.\n */\nvoid ieee80211_remove_interfaces(struct ieee80211_local *local)\n{\n\tstruct ieee80211_sub_if_data *sdata, *tmp;\n\tLIST_HEAD(unreg_list);\n\n\tASSERT_RTNL();\n\n\tmutex_lock(&local->iflist_mtx);\n\tlist_for_each_entry_safe(sdata, tmp, &local->interfaces, list) {\n\t\tlist_del(&sdata->list);\n\n\t\tunregister_netdevice_queue(sdata->dev, &unreg_list);\n\t}\n\tmutex_unlock(&local->iflist_mtx);\n\tunregister_netdevice_many(&unreg_list);\n\tlist_del(&unreg_list);\n}\n\nstatic u32 ieee80211_idle_off(struct ieee80211_local *local,\n\t\t\t      const char *reason)\n{\n\tif (!(local->hw.conf.flags & IEEE80211_CONF_IDLE))\n\t\treturn 0;\n\n#ifdef CONFIG_MAC80211_VERBOSE_DEBUG\n\twiphy_debug(local->hw.wiphy, \"device no longer idle - %s\\n\", reason);\n#endif\n\n\tlocal->hw.conf.flags &= ~IEEE80211_CONF_IDLE;\n\treturn IEEE80211_CONF_CHANGE_IDLE;\n}\n\nstatic u32 ieee80211_idle_on(struct ieee80211_local *local)\n{\n\tif (local->hw.conf.flags & IEEE80211_CONF_IDLE)\n\t\treturn 0;\n\n#ifdef CONFIG_MAC80211_VERBOSE_DEBUG\n\twiphy_debug(local->hw.wiphy, \"device now idle\\n\");\n#endif\n\n\tdrv_flush(local, false);\n\n\tlocal->hw.conf.flags |= IEEE80211_CONF_IDLE;\n\treturn IEEE80211_CONF_CHANGE_IDLE;\n}\n\nu32 __ieee80211_recalc_idle(struct ieee80211_local *local)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tint count = 0;\n\tbool working = false, scanning = false, hw_roc = false;\n\tstruct ieee80211_work *wk;\n\tunsigned int led_trig_start = 0, led_trig_stop = 0;\n\n#ifdef CONFIG_PROVE_LOCKING\n\tWARN_ON(debug_locks && !lockdep_rtnl_is_held() &&\n\t\t!lockdep_is_held(&local->iflist_mtx));\n#endif\n\tlockdep_assert_held(&local->mtx);\n\n\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\tif (!ieee80211_sdata_running(sdata)) {\n\t\t\tsdata->vif.bss_conf.idle = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tsdata->old_idle = sdata->vif.bss_conf.idle;\n\n\t\t/* do not count disabled managed interfaces */\n\t\tif (sdata->vif.type == NL80211_IFTYPE_STATION &&\n\t\t    !sdata->u.mgd.associated) {\n\t\t\tsdata->vif.bss_conf.idle = true;\n\t\t\tcontinue;\n\t\t}\n\t\t/* do not count unused IBSS interfaces */\n\t\tif (sdata->vif.type == NL80211_IFTYPE_ADHOC &&\n\t\t    !sdata->u.ibss.ssid_len) {\n\t\t\tsdata->vif.bss_conf.idle = true;\n\t\t\tcontinue;\n\t\t}\n\t\t/* count everything else */\n\t\tcount++;\n\t}\n\n\tlist_for_each_entry(wk, &local->work_list, list) {\n\t\tworking = true;\n\t\twk->sdata->vif.bss_conf.idle = false;\n\t}\n\n\tif (local->scan_sdata) {\n\t\tscanning = true;\n\t\tlocal->scan_sdata->vif.bss_conf.idle = false;\n\t}\n\n\tif (local->hw_roc_channel)\n\t\thw_roc = true;\n\n\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\tif (sdata->old_idle == sdata->vif.bss_conf.idle)\n\t\t\tcontinue;\n\t\tif (!ieee80211_sdata_running(sdata))\n\t\t\tcontinue;\n\t\tieee80211_bss_info_change_notify(sdata, BSS_CHANGED_IDLE);\n\t}\n\n\tif (working || scanning || hw_roc)\n\t\tled_trig_start |= IEEE80211_TPT_LEDTRIG_FL_WORK;\n\telse\n\t\tled_trig_stop |= IEEE80211_TPT_LEDTRIG_FL_WORK;\n\n\tif (count)\n\t\tled_trig_start |= IEEE80211_TPT_LEDTRIG_FL_CONNECTED;\n\telse\n\t\tled_trig_stop |= IEEE80211_TPT_LEDTRIG_FL_CONNECTED;\n\n\tieee80211_mod_tpt_led_trig(local, led_trig_start, led_trig_stop);\n\n\tif (hw_roc)\n\t\treturn ieee80211_idle_off(local, \"hw remain-on-channel\");\n\tif (working)\n\t\treturn ieee80211_idle_off(local, \"working\");\n\tif (scanning)\n\t\treturn ieee80211_idle_off(local, \"scanning\");\n\tif (!count)\n\t\treturn ieee80211_idle_on(local);\n\telse\n\t\treturn ieee80211_idle_off(local, \"in use\");\n\n\treturn 0;\n}\n\nvoid ieee80211_recalc_idle(struct ieee80211_local *local)\n{\n\tu32 chg;\n\n\tmutex_lock(&local->iflist_mtx);\n\tchg = __ieee80211_recalc_idle(local);\n\tmutex_unlock(&local->iflist_mtx);\n\tif (chg)\n\t\tieee80211_hw_config(local, chg);\n}\n\nstatic int netdev_notify(struct notifier_block *nb,\n\t\t\t unsigned long state,\n\t\t\t void *ndev)\n{\n\tstruct net_device *dev = ndev;\n\tstruct ieee80211_sub_if_data *sdata;\n\n\tif (state != NETDEV_CHANGENAME)\n\t\treturn 0;\n\n\tif (!dev->ieee80211_ptr || !dev->ieee80211_ptr->wiphy)\n\t\treturn 0;\n\n\tif (dev->ieee80211_ptr->wiphy->privid != mac80211_wiphy_privid)\n\t\treturn 0;\n\n\tsdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\tmemcpy(sdata->name, dev->name, IFNAMSIZ);\n\n\tieee80211_debugfs_rename_netdev(sdata);\n\treturn 0;\n}\n\nstatic struct notifier_block mac80211_netdev_notifier = {\n\t.notifier_call = netdev_notify,\n};\n\nint ieee80211_iface_init(void)\n{\n\treturn register_netdevice_notifier(&mac80211_netdev_notifier);\n}\n\nvoid ieee80211_iface_exit(void)\n{\n\tunregister_netdevice_notifier(&mac80211_netdev_notifier);\n}\n"], "fixing_code": ["/* $Id: isdn_net.c,v 1.1.2.2 2004/01/12 22:37:19 keil Exp $\n *\n * Linux ISDN subsystem, network interfaces and related functions (linklevel).\n *\n * Copyright 1994-1998  by Fritz Elfert (fritz@isdn4linux.de)\n * Copyright 1995,96    by Thinking Objects Software GmbH Wuerzburg\n * Copyright 1995,96    by Michael Hipp (Michael.Hipp@student.uni-tuebingen.de)\n *\n * This software may be used and distributed according to the terms\n * of the GNU General Public License, incorporated herein by reference.\n *\n * Data Over Voice (DOV) support added - Guy Ellis 23-Mar-02 \n *                                       guy@traverse.com.au\n * Outgoing calls - looks for a 'V' in first char of dialed number\n * Incoming calls - checks first character of eaz as follows:\n *   Numeric - accept DATA only - original functionality\n *   'V'     - accept VOICE (DOV) only\n *   'B'     - accept BOTH DATA and DOV types\n *\n * Jan 2001: fix CISCO HDLC      Bjoern A. Zeeb <i4l@zabbadoz.net>\n *           for info on the protocol, see \n *           http://i4l.zabbadoz.net/i4l/cisco-hdlc.txt\n */\n\n#include <linux/isdn.h>\n#include <linux/slab.h>\n#include <net/arp.h>\n#include <net/dst.h>\n#include <net/pkt_sched.h>\n#include <linux/inetdevice.h>\n#include \"isdn_common.h\"\n#include \"isdn_net.h\"\n#ifdef CONFIG_ISDN_PPP\n#include \"isdn_ppp.h\"\n#endif\n#ifdef CONFIG_ISDN_X25\n#include <linux/concap.h>\n#include \"isdn_concap.h\"\n#endif\n\n\n/*\n * Outline of new tbusy handling: \n *\n * Old method, roughly spoken, consisted of setting tbusy when entering\n * isdn_net_start_xmit() and at several other locations and clearing\n * it from isdn_net_start_xmit() thread when sending was successful.\n *\n * With 2.3.x multithreaded network core, to prevent problems, tbusy should\n * only be set by the isdn_net_start_xmit() thread and only when a tx-busy\n * condition is detected. Other threads (in particular isdn_net_stat_callb())\n * are only allowed to clear tbusy.\n *\n * -HE\n */\n\n/*\n * About SOFTNET:\n * Most of the changes were pretty obvious and basically done by HE already.\n *\n * One problem of the isdn net device code is that is uses struct net_device\n * for masters and slaves. However, only master interface are registered to \n * the network layer, and therefore, it only makes sense to call netif_* \n * functions on them.\n *\n * --KG\n */\n\n/* \n * Find out if the netdevice has been ifup-ed yet.\n * For slaves, look at the corresponding master.\n */\nstatic __inline__ int isdn_net_device_started(isdn_net_dev *n)\n{\n\tisdn_net_local *lp = n->local;\n\tstruct net_device *dev;\n\t\n\tif (lp->master) \n\t\tdev = lp->master;\n\telse\n\t\tdev = n->dev;\n\treturn netif_running(dev);\n}\n\n/*\n * wake up the network -> net_device queue.\n * For slaves, wake the corresponding master interface.\n */\nstatic __inline__ void isdn_net_device_wake_queue(isdn_net_local *lp)\n{\n\tif (lp->master) \n\t\tnetif_wake_queue(lp->master);\n\telse\n\t\tnetif_wake_queue(lp->netdev->dev);\n}\n\n/*\n * stop the network -> net_device queue.\n * For slaves, stop the corresponding master interface.\n */\nstatic __inline__ void isdn_net_device_stop_queue(isdn_net_local *lp)\n{\n\tif (lp->master)\n\t\tnetif_stop_queue(lp->master);\n\telse\n\t\tnetif_stop_queue(lp->netdev->dev);\n}\n\n/*\n * find out if the net_device which this lp belongs to (lp can be\n * master or slave) is busy. It's busy iff all (master and slave) \n * queues are busy\n */\nstatic __inline__ int isdn_net_device_busy(isdn_net_local *lp)\n{\n\tisdn_net_local *nlp;\n\tisdn_net_dev *nd;\n\tunsigned long flags;\n\n\tif (!isdn_net_lp_busy(lp))\n\t\treturn 0;\n\n\tif (lp->master)\n\t\tnd = ISDN_MASTER_PRIV(lp)->netdev;\n\telse\n\t\tnd = lp->netdev;\n\t\n\tspin_lock_irqsave(&nd->queue_lock, flags);\n\tnlp = lp->next;\n\twhile (nlp != lp) {\n\t\tif (!isdn_net_lp_busy(nlp)) {\n\t\t\tspin_unlock_irqrestore(&nd->queue_lock, flags);\n\t\t\treturn 0;\n\t\t}\n\t\tnlp = nlp->next;\n\t}\n\tspin_unlock_irqrestore(&nd->queue_lock, flags);\n\treturn 1;\n}\n\nstatic __inline__ void isdn_net_inc_frame_cnt(isdn_net_local *lp)\n{\n\tatomic_inc(&lp->frame_cnt);\n\tif (isdn_net_device_busy(lp))\n\t\tisdn_net_device_stop_queue(lp);\n}\n\nstatic __inline__ void isdn_net_dec_frame_cnt(isdn_net_local *lp)\n{\n\tatomic_dec(&lp->frame_cnt);\n\n\tif (!(isdn_net_device_busy(lp))) {\n\t\tif (!skb_queue_empty(&lp->super_tx_queue)) {\n\t\t\tschedule_work(&lp->tqueue);\n\t\t} else {\n\t\t\tisdn_net_device_wake_queue(lp);\n\t\t}\n       }                                                                      \n}\n\nstatic __inline__ void isdn_net_zero_frame_cnt(isdn_net_local *lp)\n{\n\tatomic_set(&lp->frame_cnt, 0);\n}\n\n/* For 2.2.x we leave the transmitter busy timeout at 2 secs, just \n * to be safe.\n * For 2.3.x we push it up to 20 secs, because call establishment\n * (in particular callback) may take such a long time, and we \n * don't want confusing messages in the log. However, there is a slight\n * possibility that this large timeout will break other things like MPPP,\n * which might rely on the tx timeout. If so, we'll find out this way...\n */\n\n#define ISDN_NET_TX_TIMEOUT (20*HZ) \n\n/* Prototypes */\n\nstatic int isdn_net_force_dial_lp(isdn_net_local *);\nstatic netdev_tx_t isdn_net_start_xmit(struct sk_buff *,\n\t\t\t\t\t     struct net_device *);\n\nstatic void isdn_net_ciscohdlck_connected(isdn_net_local *lp);\nstatic void isdn_net_ciscohdlck_disconnected(isdn_net_local *lp);\n\nchar *isdn_net_revision = \"$Revision: 1.1.2.2 $\";\n\n /*\n  * Code for raw-networking over ISDN\n  */\n\nstatic void\nisdn_net_unreachable(struct net_device *dev, struct sk_buff *skb, char *reason)\n{\n\tif(skb) {\n\n\t\tu_short proto = ntohs(skb->protocol);\n\n\t\tprintk(KERN_DEBUG \"isdn_net: %s: %s, signalling dst_link_failure %s\\n\",\n\t\t       dev->name,\n\t\t       (reason != NULL) ? reason : \"unknown\",\n\t\t       (proto != ETH_P_IP) ? \"Protocol != ETH_P_IP\" : \"\");\n\t\t\n\t\tdst_link_failure(skb);\n\t}\n\telse {  /* dial not triggered by rawIP packet */\n\t\tprintk(KERN_DEBUG \"isdn_net: %s: %s\\n\",\n\t\t\t   dev->name,\n\t\t\t   (reason != NULL) ? reason : \"reason unknown\");\n\t}\n}\n\nstatic void\nisdn_net_reset(struct net_device *dev)\n{\n#ifdef CONFIG_ISDN_X25\n\tstruct concap_device_ops * dops =\n\t\t((isdn_net_local *) netdev_priv(dev))->dops;\n\tstruct concap_proto * cprot =\n\t\t((isdn_net_local *) netdev_priv(dev))->netdev->cprot;\n#endif\n#ifdef CONFIG_ISDN_X25\n\tif( cprot && cprot -> pops && dops )\n\t\tcprot -> pops -> restart ( cprot, dev, dops );\n#endif\n}\n\n/* Open/initialize the board. */\nstatic int\nisdn_net_open(struct net_device *dev)\n{\n\tint i;\n\tstruct net_device *p;\n\tstruct in_device *in_dev;\n\n\t/* moved here from isdn_net_reset, because only the master has an\n\t   interface associated which is supposed to be started. BTW:\n\t   we need to call netif_start_queue, not netif_wake_queue here */\n\tnetif_start_queue(dev);\n\n\tisdn_net_reset(dev);\n\t/* Fill in the MAC-level header (not needed, but for compatibility... */\n\tfor (i = 0; i < ETH_ALEN - sizeof(u32); i++)\n\t\tdev->dev_addr[i] = 0xfc;\n\tif ((in_dev = dev->ip_ptr) != NULL) {\n\t\t/*\n\t\t *      Any address will do - we take the first\n\t\t */\n\t\tstruct in_ifaddr *ifa = in_dev->ifa_list;\n\t\tif (ifa != NULL)\n\t\t\tmemcpy(dev->dev_addr+2, &ifa->ifa_local, 4);\n\t}\n\n\t/* If this interface has slaves, start them also */\n\tp = MASTER_TO_SLAVE(dev);\n\tif (p) {\n\t\twhile (p) {\n\t\t\tisdn_net_reset(p);\n\t\t\tp = MASTER_TO_SLAVE(p);\n\t\t}\n\t}\n\tisdn_lock_drivers();\n\treturn 0;\n}\n\n/*\n * Assign an ISDN-channel to a net-interface\n */\nstatic void\nisdn_net_bind_channel(isdn_net_local * lp, int idx)\n{\n\tlp->flags |= ISDN_NET_CONNECTED;\n\tlp->isdn_device = dev->drvmap[idx];\n\tlp->isdn_channel = dev->chanmap[idx];\n\tdev->rx_netdev[idx] = lp->netdev;\n\tdev->st_netdev[idx] = lp->netdev;\n}\n\n/*\n * unbind a net-interface (resets interface after an error)\n */\nstatic void\nisdn_net_unbind_channel(isdn_net_local * lp)\n{\n\tskb_queue_purge(&lp->super_tx_queue);\n\n\tif (!lp->master) {\t/* reset only master device */\n\t\t/* Moral equivalent of dev_purge_queues():\n\t\t   BEWARE! This chunk of code cannot be called from hardware\n\t\t   interrupt handler. I hope it is true. --ANK\n\t\t */\n\t\tqdisc_reset_all_tx(lp->netdev->dev);\n\t}\n\tlp->dialstate = 0;\n\tdev->rx_netdev[isdn_dc2minor(lp->isdn_device, lp->isdn_channel)] = NULL;\n\tdev->st_netdev[isdn_dc2minor(lp->isdn_device, lp->isdn_channel)] = NULL;\n\tif (lp->isdn_device != -1 && lp->isdn_channel != -1)\n\t\tisdn_free_channel(lp->isdn_device, lp->isdn_channel,\n\t\t\t\t  ISDN_USAGE_NET);\n\tlp->flags &= ~ISDN_NET_CONNECTED;\n\tlp->isdn_device = -1;\n\tlp->isdn_channel = -1;\n}\n\n/*\n * Perform auto-hangup and cps-calculation for net-interfaces.\n *\n * auto-hangup:\n * Increment idle-counter (this counter is reset on any incoming or\n * outgoing packet), if counter exceeds configured limit either do a\n * hangup immediately or - if configured - wait until just before the next\n * charge-info.\n *\n * cps-calculation (needed for dynamic channel-bundling):\n * Since this function is called every second, simply reset the\n * byte-counter of the interface after copying it to the cps-variable.\n */\nstatic unsigned long last_jiffies = -HZ;\n\nvoid\nisdn_net_autohup(void)\n{\n\tisdn_net_dev *p = dev->netdev;\n\tint anymore;\n\n\tanymore = 0;\n\twhile (p) {\n\t\tisdn_net_local *l = p->local;\n\t\tif (jiffies == last_jiffies)\n\t\t\tl->cps = l->transcount;\n\t\telse\n\t\t\tl->cps = (l->transcount * HZ) / (jiffies - last_jiffies);\n\t\tl->transcount = 0;\n\t\tif (dev->net_verbose > 3)\n\t\t\tprintk(KERN_DEBUG \"%s: %d bogocps\\n\", p->dev->name, l->cps);\n\t\tif ((l->flags & ISDN_NET_CONNECTED) && (!l->dialstate)) {\n\t\t\tanymore = 1;\n\t\t\tl->huptimer++;\n\t\t\t/*\n\t\t\t * if there is some dialmode where timeout-hangup\n\t\t\t * should _not_ be done, check for that here\n\t\t\t */\n\t\t\tif ((l->onhtime) &&\n\t\t\t    (l->huptimer > l->onhtime))\n\t\t\t{\n\t\t\t\tif (l->hupflags & ISDN_MANCHARGE &&\n\t\t\t\t    l->hupflags & ISDN_CHARGEHUP) {\n\t\t\t\t\twhile (time_after(jiffies, l->chargetime + l->chargeint))\n\t\t\t\t\t\tl->chargetime += l->chargeint;\n\t\t\t\t\tif (time_after(jiffies, l->chargetime + l->chargeint - 2 * HZ))\n\t\t\t\t\t\tif (l->outgoing || l->hupflags & ISDN_INHUP)\n\t\t\t\t\t\t\tisdn_net_hangup(p->dev);\n\t\t\t\t} else if (l->outgoing) {\n\t\t\t\t\tif (l->hupflags & ISDN_CHARGEHUP) {\n\t\t\t\t\t\tif (l->hupflags & ISDN_WAITCHARGE) {\n\t\t\t\t\t\t\tprintk(KERN_DEBUG \"isdn_net: Hupflags of %s are %X\\n\",\n\t\t\t\t\t\t\t       p->dev->name, l->hupflags);\n\t\t\t\t\t\t\tisdn_net_hangup(p->dev);\n\t\t\t\t\t\t} else if (time_after(jiffies, l->chargetime + l->chargeint)) {\n\t\t\t\t\t\t\tprintk(KERN_DEBUG\n\t\t\t\t\t\t\t       \"isdn_net: %s: chtime = %lu, chint = %d\\n\",\n\t\t\t\t\t\t\t       p->dev->name, l->chargetime, l->chargeint);\n\t\t\t\t\t\t\tisdn_net_hangup(p->dev);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t\tisdn_net_hangup(p->dev);\n\t\t\t\t} else if (l->hupflags & ISDN_INHUP)\n\t\t\t\t\tisdn_net_hangup(p->dev);\n\t\t\t}\n\n\t\t\tif(dev->global_flags & ISDN_GLOBAL_STOPPED || (ISDN_NET_DIALMODE(*l) == ISDN_NET_DM_OFF)) {\n\t\t\t\tisdn_net_hangup(p->dev);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tp = (isdn_net_dev *) p->next;\n\t}\n\tlast_jiffies = jiffies;\n\tisdn_timer_ctrl(ISDN_TIMER_NETHANGUP, anymore);\n}\n\nstatic void isdn_net_lp_disconnected(isdn_net_local *lp)\n{\n\tisdn_net_rm_from_bundle(lp);\n}\n\n/*\n * Handle status-messages from ISDN-interfacecard.\n * This function is called from within the main-status-dispatcher\n * isdn_status_callback, which itself is called from the low-level driver.\n * Return: 1 = Event handled, 0 = not for us or unknown Event.\n */\nint\nisdn_net_stat_callback(int idx, isdn_ctrl *c)\n{\n\tisdn_net_dev *p = dev->st_netdev[idx];\n\tint cmd = c->command;\n\n\tif (p) {\n\t\tisdn_net_local *lp = p->local;\n#ifdef CONFIG_ISDN_X25\n\t\tstruct concap_proto *cprot = lp->netdev->cprot;\n\t\tstruct concap_proto_ops *pops = cprot ? cprot->pops : NULL;\n#endif\n\t\tswitch (cmd) {\n\t\t\tcase ISDN_STAT_BSENT:\n\t\t\t\t/* A packet has successfully been sent out */\n\t\t\t\tif ((lp->flags & ISDN_NET_CONNECTED) &&\n\t\t\t\t    (!lp->dialstate)) {\n\t\t\t\t\tisdn_net_dec_frame_cnt(lp);\n\t\t\t\t\tlp->stats.tx_packets++;\n\t\t\t\t\tlp->stats.tx_bytes += c->parm.length;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\tcase ISDN_STAT_DCONN:\n\t\t\t\t/* D-Channel is up */\n\t\t\t\tswitch (lp->dialstate) {\n\t\t\t\t\tcase 4:\n\t\t\t\t\tcase 7:\n\t\t\t\t\tcase 8:\n\t\t\t\t\t\tlp->dialstate++;\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\tcase 12:\n\t\t\t\t\t\tlp->dialstate = 5;\n\t\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ISDN_STAT_DHUP:\n\t\t\t\t/* Either D-Channel-hangup or error during dialout */\n#ifdef CONFIG_ISDN_X25\n\t\t\t\t/* If we are not connencted then dialing had\n\t\t\t\t   failed. If there are generic encap protocol\n\t\t\t\t   receiver routines signal the closure of\n\t\t\t\t   the link*/\n\n\t\t\t\tif( !(lp->flags & ISDN_NET_CONNECTED)\n\t\t\t\t    && pops && pops -> disconn_ind )\n\t\t\t\t\tpops -> disconn_ind(cprot);\n#endif /* CONFIG_ISDN_X25 */\n\t\t\t\tif ((!lp->dialstate) && (lp->flags & ISDN_NET_CONNECTED)) {\n\t\t\t\t\tif (lp->p_encap == ISDN_NET_ENCAP_CISCOHDLCK)\n\t\t\t\t\t\tisdn_net_ciscohdlck_disconnected(lp);\n#ifdef CONFIG_ISDN_PPP\n\t\t\t\t\tif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP)\n\t\t\t\t\t\tisdn_ppp_free(lp);\n#endif\n\t\t\t\t\tisdn_net_lp_disconnected(lp);\n\t\t\t\t\tisdn_all_eaz(lp->isdn_device, lp->isdn_channel);\n\t\t\t\t\tprintk(KERN_INFO \"%s: remote hangup\\n\", p->dev->name);\n\t\t\t\t\tprintk(KERN_INFO \"%s: Chargesum is %d\\n\", p->dev->name,\n\t\t\t\t\t       lp->charge);\n\t\t\t\t\tisdn_net_unbind_channel(lp);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n#ifdef CONFIG_ISDN_X25\n\t\t\tcase ISDN_STAT_BHUP:\n\t\t\t\t/* B-Channel-hangup */\n\t\t\t\t/* try if there are generic encap protocol\n\t\t\t\t   receiver routines and signal the closure of\n\t\t\t\t   the link */\n\t\t\t\tif( pops  &&  pops -> disconn_ind ){\n\t\t\t\t\t\tpops -> disconn_ind(cprot);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\tbreak;\n#endif /* CONFIG_ISDN_X25 */\n\t\t\tcase ISDN_STAT_BCONN:\n\t\t\t\t/* B-Channel is up */\n\t\t\t\tisdn_net_zero_frame_cnt(lp);\n\t\t\t\tswitch (lp->dialstate) {\n\t\t\t\t\tcase 5:\n\t\t\t\t\tcase 6:\n\t\t\t\t\tcase 7:\n\t\t\t\t\tcase 8:\n\t\t\t\t\tcase 9:\n\t\t\t\t\tcase 10:\n\t\t\t\t\tcase 12:\n\t\t\t\t\t\tif (lp->dialstate <= 6) {\n\t\t\t\t\t\t\tdev->usage[idx] |= ISDN_USAGE_OUTGOING;\n\t\t\t\t\t\t\tisdn_info_update();\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tdev->rx_netdev[idx] = p;\n\t\t\t\t\t\tlp->dialstate = 0;\n\t\t\t\t\t\tisdn_timer_ctrl(ISDN_TIMER_NETHANGUP, 1);\n\t\t\t\t\t\tif (lp->p_encap == ISDN_NET_ENCAP_CISCOHDLCK)\n\t\t\t\t\t\t\tisdn_net_ciscohdlck_connected(lp);\n\t\t\t\t\t\tif (lp->p_encap != ISDN_NET_ENCAP_SYNCPPP) {\n\t\t\t\t\t\t\tif (lp->master) { /* is lp a slave? */\n\t\t\t\t\t\t\t\tisdn_net_dev *nd = ISDN_MASTER_PRIV(lp)->netdev;\n\t\t\t\t\t\t\t\tisdn_net_add_to_bundle(nd, lp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprintk(KERN_INFO \"isdn_net: %s connected\\n\", p->dev->name);\n\t\t\t\t\t\t/* If first Chargeinfo comes before B-Channel connect,\n\t\t\t\t\t\t * we correct the timestamp here.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tlp->chargetime = jiffies;\n\n\t\t\t\t\t\t/* reset dial-timeout */\n\t\t\t\t\t\tlp->dialstarted = 0;\n\t\t\t\t\t\tlp->dialwait_timer = 0;\n\n#ifdef CONFIG_ISDN_PPP\n\t\t\t\t\t\tif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP)\n\t\t\t\t\t\t\tisdn_ppp_wakeup_daemon(lp);\n#endif\n#ifdef CONFIG_ISDN_X25\n\t\t\t\t\t\t/* try if there are generic concap receiver routines */\n\t\t\t\t\t\tif( pops )\n\t\t\t\t\t\t\tif( pops->connect_ind)\n\t\t\t\t\t\t\t\tpops->connect_ind(cprot);\n#endif /* CONFIG_ISDN_X25 */\n\t\t\t\t\t\t/* ppp needs to do negotiations first */\n\t\t\t\t\t\tif (lp->p_encap != ISDN_NET_ENCAP_SYNCPPP)\n\t\t\t\t\t\t\tisdn_net_device_wake_queue(lp);\n\t\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ISDN_STAT_NODCH:\n\t\t\t\t/* No D-Channel avail. */\n\t\t\t\tif (lp->dialstate == 4) {\n\t\t\t\t\tlp->dialstate--;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ISDN_STAT_CINF:\n\t\t\t\t/* Charge-info from TelCo. Calculate interval between\n\t\t\t\t * charge-infos and set timestamp for last info for\n\t\t\t\t * usage by isdn_net_autohup()\n\t\t\t\t */\n\t\t\t\tlp->charge++;\n\t\t\t\tif (lp->hupflags & ISDN_HAVECHARGE) {\n\t\t\t\t\tlp->hupflags &= ~ISDN_WAITCHARGE;\n\t\t\t\t\tlp->chargeint = jiffies - lp->chargetime - (2 * HZ);\n\t\t\t\t}\n\t\t\t\tif (lp->hupflags & ISDN_WAITCHARGE)\n\t\t\t\t\tlp->hupflags |= ISDN_HAVECHARGE;\n\t\t\t\tlp->chargetime = jiffies;\n\t\t\t\tprintk(KERN_DEBUG \"isdn_net: Got CINF chargetime of %s now %lu\\n\",\n\t\t\t\t       p->dev->name, lp->chargetime);\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * Perform dialout for net-interfaces and timeout-handling for\n * D-Channel-up and B-Channel-up Messages.\n * This function is initially called from within isdn_net_start_xmit() or\n * or isdn_net_find_icall() after initializing the dialstate for an\n * interface. If further calls are needed, the function schedules itself\n * for a timer-callback via isdn_timer_function().\n * The dialstate is also affected by incoming status-messages from\n * the ISDN-Channel which are handled in isdn_net_stat_callback() above.\n */\nvoid\nisdn_net_dial(void)\n{\n\tisdn_net_dev *p = dev->netdev;\n\tint anymore = 0;\n\tint i;\n\tisdn_ctrl cmd;\n        u_char *phone_number;\n\n\twhile (p) {\n\t\tisdn_net_local *lp = p->local;\n\n#ifdef ISDN_DEBUG_NET_DIAL\n\t\tif (lp->dialstate)\n\t\t\tprintk(KERN_DEBUG \"%s: dialstate=%d\\n\", p->dev->name, lp->dialstate);\n#endif\n\t\tswitch (lp->dialstate) {\n\t\t\tcase 0:\n\t\t\t\t/* Nothing to do for this interface */\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t/* Initiate dialout. Set phone-number-pointer to first number\n\t\t\t\t * of interface.\n\t\t\t\t */\n\t\t\t\tlp->dial = lp->phone[1];\n\t\t\t\tif (!lp->dial) {\n\t\t\t\t\tprintk(KERN_WARNING \"%s: phone number deleted?\\n\",\n\t\t\t\t\t       p->dev->name);\n\t\t\t\t\tisdn_net_hangup(p->dev);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tanymore = 1;\n\n\t\t\t\tif(lp->dialtimeout > 0)\n\t\t\t\t\tif(lp->dialstarted == 0 || time_after(jiffies, lp->dialstarted + lp->dialtimeout + lp->dialwait)) {\n\t\t\t\t\t\tlp->dialstarted = jiffies;\n\t\t\t\t\t\tlp->dialwait_timer = 0;\n\t\t\t\t\t}\n\n\t\t\t\tlp->dialstate++;\n\t\t\t\t/* Fall through */\n\t\t\tcase 2:\n\t\t\t\t/* Prepare dialing. Clear EAZ, then set EAZ. */\n\t\t\t\tcmd.driver = lp->isdn_device;\n\t\t\t\tcmd.arg = lp->isdn_channel;\n\t\t\t\tcmd.command = ISDN_CMD_CLREAZ;\n\t\t\t\tisdn_command(&cmd);\n\t\t\t\tsprintf(cmd.parm.num, \"%s\", isdn_map_eaz2msn(lp->msn, cmd.driver));\n\t\t\t\tcmd.command = ISDN_CMD_SETEAZ;\n\t\t\t\tisdn_command(&cmd);\n\t\t\t\tlp->dialretry = 0;\n\t\t\t\tanymore = 1;\n\t\t\t\tlp->dialstate++;\n\t\t\t\t/* Fall through */\n\t\t\tcase 3:\n\t\t\t\t/* Setup interface, dial current phone-number, switch to next number.\n\t\t\t\t * If list of phone-numbers is exhausted, increment\n\t\t\t\t * retry-counter.\n\t\t\t\t */\n\t\t\t\tif(dev->global_flags & ISDN_GLOBAL_STOPPED || (ISDN_NET_DIALMODE(*lp) == ISDN_NET_DM_OFF)) {\n\t\t\t\t\tchar *s;\n\t\t\t\t\tif (dev->global_flags & ISDN_GLOBAL_STOPPED)\n\t\t\t\t\t\ts = \"dial suppressed: isdn system stopped\";\n\t\t\t\t\telse\n\t\t\t\t\t\ts = \"dial suppressed: dialmode `off'\";\n\t\t\t\t\tisdn_net_unreachable(p->dev, NULL, s);\n\t\t\t\t\tisdn_net_hangup(p->dev);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcmd.driver = lp->isdn_device;\n\t\t\t\tcmd.command = ISDN_CMD_SETL2;\n\t\t\t\tcmd.arg = lp->isdn_channel + (lp->l2_proto << 8);\n\t\t\t\tisdn_command(&cmd);\n\t\t\t\tcmd.driver = lp->isdn_device;\n\t\t\t\tcmd.command = ISDN_CMD_SETL3;\n\t\t\t\tcmd.arg = lp->isdn_channel + (lp->l3_proto << 8);\n\t\t\t\tisdn_command(&cmd);\n\t\t\t\tcmd.driver = lp->isdn_device;\n\t\t\t\tcmd.arg = lp->isdn_channel;\n\t\t\t\tif (!lp->dial) {\n\t\t\t\t\tprintk(KERN_WARNING \"%s: phone number deleted?\\n\",\n\t\t\t\t\t       p->dev->name);\n\t\t\t\t\tisdn_net_hangup(p->dev);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!strncmp(lp->dial->num, \"LEASED\", strlen(\"LEASED\"))) {\n\t\t\t\t\tlp->dialstate = 4;\n\t\t\t\t\tprintk(KERN_INFO \"%s: Open leased line ...\\n\", p->dev->name);\n\t\t\t\t} else {\n\t\t\t\t\tif(lp->dialtimeout > 0)\n\t\t\t\t\t\tif (time_after(jiffies, lp->dialstarted + lp->dialtimeout)) {\n\t\t\t\t\t\t\tlp->dialwait_timer = jiffies + lp->dialwait;\n\t\t\t\t\t\t\tlp->dialstarted = 0;\n\t\t\t\t\t\t\tisdn_net_unreachable(p->dev, NULL, \"dial: timed out\");\n\t\t\t\t\t\t\tisdn_net_hangup(p->dev);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\tcmd.driver = lp->isdn_device;\n\t\t\t\t\tcmd.command = ISDN_CMD_DIAL;\n\t\t\t\t\tcmd.parm.setup.si2 = 0;\n\n                                        /* check for DOV */\n                                        phone_number = lp->dial->num;\n                                        if ((*phone_number == 'v') ||\n\t\t\t\t\t    (*phone_number == 'V')) { /* DOV call */\n                                                cmd.parm.setup.si1 = 1;\n                                        } else { /* DATA call */\n                                                cmd.parm.setup.si1 = 7;\n\t\t\t\t\t}\n\n\t\t\t\t\tstrcpy(cmd.parm.setup.phone, phone_number);\n\t\t\t\t\t/*\n\t\t\t\t\t * Switch to next number or back to start if at end of list.\n\t\t\t\t\t */\n\t\t\t\t\tif (!(lp->dial = (isdn_net_phone *) lp->dial->next)) {\n\t\t\t\t\t\tlp->dial = lp->phone[1];\n\t\t\t\t\t\tlp->dialretry++;\n\n\t\t\t\t\t\tif (lp->dialretry > lp->dialmax) {\n\t\t\t\t\t\t\tif (lp->dialtimeout == 0) {\n\t\t\t\t\t\t\t\tlp->dialwait_timer = jiffies + lp->dialwait;\n\t\t\t\t\t\t\t\tlp->dialstarted = 0;\n\t\t\t\t\t\t\t\tisdn_net_unreachable(p->dev, NULL, \"dial: tried all numbers dialmax times\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tisdn_net_hangup(p->dev);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsprintf(cmd.parm.setup.eazmsn, \"%s\",\n\t\t\t\t\t\tisdn_map_eaz2msn(lp->msn, cmd.driver));\n\t\t\t\t\ti = isdn_dc2minor(lp->isdn_device, lp->isdn_channel);\n\t\t\t\t\tif (i >= 0) {\n\t\t\t\t\t\tstrcpy(dev->num[i], cmd.parm.setup.phone);\n\t\t\t\t\t\tdev->usage[i] |= ISDN_USAGE_OUTGOING;\n\t\t\t\t\t\tisdn_info_update();\n\t\t\t\t\t}\n\t\t\t\t\tprintk(KERN_INFO \"%s: dialing %d %s... %s\\n\", p->dev->name,\n\t\t\t\t\t       lp->dialretry, cmd.parm.setup.phone,\n\t\t\t\t\t       (cmd.parm.setup.si1 == 1) ? \"DOV\" : \"\");\n\t\t\t\t\tlp->dtimer = 0;\n#ifdef ISDN_DEBUG_NET_DIAL\n\t\t\t\t\tprintk(KERN_DEBUG \"dial: d=%d c=%d\\n\", lp->isdn_device,\n\t\t\t\t\t       lp->isdn_channel);\n#endif\n\t\t\t\t\tisdn_command(&cmd);\n\t\t\t\t}\n\t\t\t\tlp->huptimer = 0;\n\t\t\t\tlp->outgoing = 1;\n\t\t\t\tif (lp->chargeint) {\n\t\t\t\t\tlp->hupflags |= ISDN_HAVECHARGE;\n\t\t\t\t\tlp->hupflags &= ~ISDN_WAITCHARGE;\n\t\t\t\t} else {\n\t\t\t\t\tlp->hupflags |= ISDN_WAITCHARGE;\n\t\t\t\t\tlp->hupflags &= ~ISDN_HAVECHARGE;\n\t\t\t\t}\n\t\t\t\tanymore = 1;\n\t\t\t\tlp->dialstate =\n\t\t\t\t    (lp->cbdelay &&\n\t\t\t\t     (lp->flags & ISDN_NET_CBOUT)) ? 12 : 4;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\t/* Wait for D-Channel-connect.\n\t\t\t\t * If timeout, switch back to state 3.\n\t\t\t\t * Dialmax-handling moved to state 3.\n\t\t\t\t */\n\t\t\t\tif (lp->dtimer++ > ISDN_TIMER_DTIMEOUT10)\n\t\t\t\t\tlp->dialstate = 3;\n\t\t\t\tanymore = 1;\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\t/* Got D-Channel-Connect, send B-Channel-request */\n\t\t\t\tcmd.driver = lp->isdn_device;\n\t\t\t\tcmd.arg = lp->isdn_channel;\n\t\t\t\tcmd.command = ISDN_CMD_ACCEPTB;\n\t\t\t\tanymore = 1;\n\t\t\t\tlp->dtimer = 0;\n\t\t\t\tlp->dialstate++;\n\t\t\t\tisdn_command(&cmd);\n\t\t\t\tbreak;\n\t\t\tcase 6:\n\t\t\t\t/* Wait for B- or D-Channel-connect. If timeout,\n\t\t\t\t * switch back to state 3.\n\t\t\t\t */\n#ifdef ISDN_DEBUG_NET_DIAL\n\t\t\t\tprintk(KERN_DEBUG \"dialtimer2: %d\\n\", lp->dtimer);\n#endif\n\t\t\t\tif (lp->dtimer++ > ISDN_TIMER_DTIMEOUT10)\n\t\t\t\t\tlp->dialstate = 3;\n\t\t\t\tanymore = 1;\n\t\t\t\tbreak;\n\t\t\tcase 7:\n\t\t\t\t/* Got incoming Call, setup L2 and L3 protocols,\n\t\t\t\t * then wait for D-Channel-connect\n\t\t\t\t */\n#ifdef ISDN_DEBUG_NET_DIAL\n\t\t\t\tprintk(KERN_DEBUG \"dialtimer4: %d\\n\", lp->dtimer);\n#endif\n\t\t\t\tcmd.driver = lp->isdn_device;\n\t\t\t\tcmd.command = ISDN_CMD_SETL2;\n\t\t\t\tcmd.arg = lp->isdn_channel + (lp->l2_proto << 8);\n\t\t\t\tisdn_command(&cmd);\n\t\t\t\tcmd.driver = lp->isdn_device;\n\t\t\t\tcmd.command = ISDN_CMD_SETL3;\n\t\t\t\tcmd.arg = lp->isdn_channel + (lp->l3_proto << 8);\n\t\t\t\tisdn_command(&cmd);\n\t\t\t\tif (lp->dtimer++ > ISDN_TIMER_DTIMEOUT15)\n\t\t\t\t\tisdn_net_hangup(p->dev);\n\t\t\t\telse {\n\t\t\t\t\tanymore = 1;\n\t\t\t\t\tlp->dialstate++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 9:\n\t\t\t\t/* Got incoming D-Channel-Connect, send B-Channel-request */\n\t\t\t\tcmd.driver = lp->isdn_device;\n\t\t\t\tcmd.arg = lp->isdn_channel;\n\t\t\t\tcmd.command = ISDN_CMD_ACCEPTB;\n\t\t\t\tisdn_command(&cmd);\n\t\t\t\tanymore = 1;\n\t\t\t\tlp->dtimer = 0;\n\t\t\t\tlp->dialstate++;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\tcase 10:\n\t\t\t\t/*  Wait for B- or D-channel-connect */\n#ifdef ISDN_DEBUG_NET_DIAL\n\t\t\t\tprintk(KERN_DEBUG \"dialtimer4: %d\\n\", lp->dtimer);\n#endif\n\t\t\t\tif (lp->dtimer++ > ISDN_TIMER_DTIMEOUT10)\n\t\t\t\t\tisdn_net_hangup(p->dev);\n\t\t\t\telse\n\t\t\t\t\tanymore = 1;\n\t\t\t\tbreak;\n\t\t\tcase 11:\n\t\t\t\t/* Callback Delay */\n\t\t\t\tif (lp->dtimer++ > lp->cbdelay)\n\t\t\t\t\tlp->dialstate = 1;\n\t\t\t\tanymore = 1;\n\t\t\t\tbreak;\n\t\t\tcase 12:\n\t\t\t\t/* Remote does callback. Hangup after cbdelay, then wait for incoming\n\t\t\t\t * call (in state 4).\n\t\t\t\t */\n\t\t\t\tif (lp->dtimer++ > lp->cbdelay)\n\t\t\t\t{\n\t\t\t\t\tprintk(KERN_INFO \"%s: hangup waiting for callback ...\\n\", p->dev->name);\n\t\t\t\t\tlp->dtimer = 0;\n\t\t\t\t\tlp->dialstate = 4;\n\t\t\t\t\tcmd.driver = lp->isdn_device;\n\t\t\t\t\tcmd.command = ISDN_CMD_HANGUP;\n\t\t\t\t\tcmd.arg = lp->isdn_channel;\n\t\t\t\t\tisdn_command(&cmd);\n\t\t\t\t\tisdn_all_eaz(lp->isdn_device, lp->isdn_channel);\n\t\t\t\t}\n\t\t\t\tanymore = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tprintk(KERN_WARNING \"isdn_net: Illegal dialstate %d for device %s\\n\",\n\t\t\t\t       lp->dialstate, p->dev->name);\n\t\t}\n\t\tp = (isdn_net_dev *) p->next;\n\t}\n\tisdn_timer_ctrl(ISDN_TIMER_NETDIAL, anymore);\n}\n\n/*\n * Perform hangup for a net-interface.\n */\nvoid\nisdn_net_hangup(struct net_device *d)\n{\n\tisdn_net_local *lp = netdev_priv(d);\n\tisdn_ctrl cmd;\n#ifdef CONFIG_ISDN_X25\n\tstruct concap_proto *cprot = lp->netdev->cprot;\n\tstruct concap_proto_ops *pops = cprot ? cprot->pops : NULL;\n#endif\n\n\tif (lp->flags & ISDN_NET_CONNECTED) {\n\t\tif (lp->slave != NULL) {\n\t\t\tisdn_net_local *slp = ISDN_SLAVE_PRIV(lp);\n\t\t\tif (slp->flags & ISDN_NET_CONNECTED) {\n\t\t\t\tprintk(KERN_INFO\n\t\t\t\t\t\"isdn_net: hang up slave %s before %s\\n\",\n\t\t\t\t\tlp->slave->name, d->name);\n\t\t\t\tisdn_net_hangup(lp->slave);\n\t\t\t}\n\t\t}\n\t\tprintk(KERN_INFO \"isdn_net: local hangup %s\\n\", d->name);\n#ifdef CONFIG_ISDN_PPP\n\t\tif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP)\n\t\t\tisdn_ppp_free(lp);\n#endif\n\t\tisdn_net_lp_disconnected(lp);\n#ifdef CONFIG_ISDN_X25\n\t\t/* try if there are generic encap protocol\n\t\t   receiver routines and signal the closure of\n\t\t   the link */\n\t\tif( pops && pops -> disconn_ind )\n\t\t  pops -> disconn_ind(cprot);\n#endif /* CONFIG_ISDN_X25 */\n\n\t\tcmd.driver = lp->isdn_device;\n\t\tcmd.command = ISDN_CMD_HANGUP;\n\t\tcmd.arg = lp->isdn_channel;\n\t\tisdn_command(&cmd);\n\t\tprintk(KERN_INFO \"%s: Chargesum is %d\\n\", d->name, lp->charge);\n\t\tisdn_all_eaz(lp->isdn_device, lp->isdn_channel);\n\t}\n\tisdn_net_unbind_channel(lp);\n}\n\ntypedef struct {\n\t__be16 source;\n\t__be16 dest;\n} ip_ports;\n\nstatic void\nisdn_net_log_skb(struct sk_buff * skb, isdn_net_local * lp)\n{\n\t/* hopefully, this was set correctly */\n\tconst u_char *p = skb_network_header(skb);\n\tunsigned short proto = ntohs(skb->protocol);\n\tint data_ofs;\n\tip_ports *ipp;\n\tchar addinfo[100];\n\n\taddinfo[0] = '\\0';\n\t/* This check stolen from 2.1.72 dev_queue_xmit_nit() */\n\tif (p < skb->data || skb->network_header >= skb->tail) {\n\t\t/* fall back to old isdn_net_log_packet method() */\n\t\tchar * buf = skb->data;\n\n\t\tprintk(KERN_DEBUG \"isdn_net: protocol %04x is buggy, dev %s\\n\", skb->protocol, lp->netdev->dev->name);\n\t\tp = buf;\n\t\tproto = ETH_P_IP;\n\t\tswitch (lp->p_encap) {\n\t\t\tcase ISDN_NET_ENCAP_IPTYP:\n\t\t\t\tproto = ntohs(*(__be16 *)&buf[0]);\n\t\t\t\tp = &buf[2];\n\t\t\t\tbreak;\n\t\t\tcase ISDN_NET_ENCAP_ETHER:\n\t\t\t\tproto = ntohs(*(__be16 *)&buf[12]);\n\t\t\t\tp = &buf[14];\n\t\t\t\tbreak;\n\t\t\tcase ISDN_NET_ENCAP_CISCOHDLC:\n\t\t\t\tproto = ntohs(*(__be16 *)&buf[2]);\n\t\t\t\tp = &buf[4];\n\t\t\t\tbreak;\n#ifdef CONFIG_ISDN_PPP\n\t\t\tcase ISDN_NET_ENCAP_SYNCPPP:\n\t\t\t\tproto = ntohs(skb->protocol);\n\t\t\t\tp = &buf[IPPP_MAX_HEADER];\n\t\t\t\tbreak;\n#endif\n\t\t}\n\t}\n\tdata_ofs = ((p[0] & 15) * 4);\n\tswitch (proto) {\n\t\tcase ETH_P_IP:\n\t\t\tswitch (p[9]) {\n\t\t\t\tcase 1:\n\t\t\t\t\tstrcpy(addinfo, \" ICMP\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tstrcpy(addinfo, \" IGMP\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tstrcpy(addinfo, \" IPIP\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 6:\n\t\t\t\t\tipp = (ip_ports *) (&p[data_ofs]);\n\t\t\t\t\tsprintf(addinfo, \" TCP, port: %d -> %d\", ntohs(ipp->source),\n\t\t\t\t\t\tntohs(ipp->dest));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 8:\n\t\t\t\t\tstrcpy(addinfo, \" EGP\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 12:\n\t\t\t\t\tstrcpy(addinfo, \" PUP\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase 17:\n\t\t\t\t\tipp = (ip_ports *) (&p[data_ofs]);\n\t\t\t\t\tsprintf(addinfo, \" UDP, port: %d -> %d\", ntohs(ipp->source),\n\t\t\t\t\t\tntohs(ipp->dest));\n\t\t\t\t\tbreak;\n\t\t\t\tcase 22:\n\t\t\t\t\tstrcpy(addinfo, \" IDP\");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprintk(KERN_INFO \"OPEN: %pI4 -> %pI4%s\\n\",\n\t\t\t       p + 12, p + 16, addinfo);\n\t\t\tbreak;\n\t\tcase ETH_P_ARP:\n\t\t\tprintk(KERN_INFO \"OPEN: ARP %pI4 -> *.*.*.* ?%pI4\\n\",\n\t\t\t       p + 14, p + 24);\n\t\t\tbreak;\n\t}\n}\n\n/*\n * this function is used to send supervisory data, i.e. data which was\n * not received from the network layer, but e.g. frames from ipppd, CCP\n * reset frames etc.\n */\nvoid isdn_net_write_super(isdn_net_local *lp, struct sk_buff *skb)\n{\n\tif (in_irq()) {\n\t\t// we can't grab the lock from irq context, \n\t\t// so we just queue the packet\n\t\tskb_queue_tail(&lp->super_tx_queue, skb);\n\t\tschedule_work(&lp->tqueue);\n\t\treturn;\n\t}\n\n\tspin_lock_bh(&lp->xmit_lock);\n\tif (!isdn_net_lp_busy(lp)) {\n\t\tisdn_net_writebuf_skb(lp, skb);\n\t} else {\n\t\tskb_queue_tail(&lp->super_tx_queue, skb);\n\t}\n\tspin_unlock_bh(&lp->xmit_lock);\n}\n\n/*\n * called from tq_immediate\n */\nstatic void isdn_net_softint(struct work_struct *work)\n{\n\tisdn_net_local *lp = container_of(work, isdn_net_local, tqueue);\n\tstruct sk_buff *skb;\n\n\tspin_lock_bh(&lp->xmit_lock);\n\twhile (!isdn_net_lp_busy(lp)) {\n\t\tskb = skb_dequeue(&lp->super_tx_queue);\n\t\tif (!skb)\n\t\t\tbreak;\n\t\tisdn_net_writebuf_skb(lp, skb);                                \n\t}\n\tspin_unlock_bh(&lp->xmit_lock);\n}\n\n/* \n * all frames sent from the (net) LL to a HL driver should go via this function\n * it's serialized by the caller holding the lp->xmit_lock spinlock\n */\nvoid isdn_net_writebuf_skb(isdn_net_local *lp, struct sk_buff *skb)\n{\n\tint ret;\n\tint len = skb->len;     /* save len */\n\n\t/* before obtaining the lock the caller should have checked that\n\t   the lp isn't busy */\n\tif (isdn_net_lp_busy(lp)) {\n\t\tprintk(\"isdn BUG at %s:%d!\\n\", __FILE__, __LINE__);\n\t\tgoto error;\n\t}\n\n\tif (!(lp->flags & ISDN_NET_CONNECTED)) {\n\t\tprintk(\"isdn BUG at %s:%d!\\n\", __FILE__, __LINE__);\n\t\tgoto error;\n\t}\n\tret = isdn_writebuf_skb_stub(lp->isdn_device, lp->isdn_channel, 1, skb);\n\tif (ret != len) {\n\t\t/* we should never get here */\n\t\tprintk(KERN_WARNING \"%s: HL driver queue full\\n\", lp->netdev->dev->name);\n\t\tgoto error;\n\t}\n\t\n\tlp->transcount += len;\n\tisdn_net_inc_frame_cnt(lp);\n\treturn;\n\n error:\n\tdev_kfree_skb(skb);\n\tlp->stats.tx_errors++;\n\n}\n\n\n/*\n *  Helper function for isdn_net_start_xmit.\n *  When called, the connection is already established.\n *  Based on cps-calculation, check if device is overloaded.\n *  If so, and if a slave exists, trigger dialing for it.\n *  If any slave is online, deliver packets using a simple round robin\n *  scheme.\n *\n *  Return: 0 on success, !0 on failure.\n */\n\nstatic int\nisdn_net_xmit(struct net_device *ndev, struct sk_buff *skb)\n{\n\tisdn_net_dev *nd;\n\tisdn_net_local *slp;\n\tisdn_net_local *lp = netdev_priv(ndev);\n\tint retv = NETDEV_TX_OK;\n\n\tif (((isdn_net_local *) netdev_priv(ndev))->master) {\n\t\tprintk(\"isdn BUG at %s:%d!\\n\", __FILE__, __LINE__);\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\t/* For the other encaps the header has already been built */\n#ifdef CONFIG_ISDN_PPP\n\tif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP) {\n\t\treturn isdn_ppp_xmit(skb, ndev);\n\t}\n#endif\n\tnd = ((isdn_net_local *) netdev_priv(ndev))->netdev;\n\tlp = isdn_net_get_locked_lp(nd);\n\tif (!lp) {\n\t\tprintk(KERN_WARNING \"%s: all channels busy - requeuing!\\n\", ndev->name);\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\t/* we have our lp locked from now on */\n\n\t/* Reset hangup-timeout */\n\tlp->huptimer = 0; // FIXME?\n\tisdn_net_writebuf_skb(lp, skb);\n\tspin_unlock_bh(&lp->xmit_lock);\n\n\t/* the following stuff is here for backwards compatibility.\n\t * in future, start-up and hangup of slaves (based on current load)\n\t * should move to userspace and get based on an overall cps\n\t * calculation\n\t */\n\tif (lp->cps > lp->triggercps) {\n\t\tif (lp->slave) {\n\t\t\tif (!lp->sqfull) {\n\t\t\t\t/* First time overload: set timestamp only */\n\t\t\t\tlp->sqfull = 1;\n\t\t\t\tlp->sqfull_stamp = jiffies;\n\t\t\t} else {\n\t\t\t\t/* subsequent overload: if slavedelay exceeded, start dialing */\n\t\t\t\tif (time_after(jiffies, lp->sqfull_stamp + lp->slavedelay)) {\n\t\t\t\t\tslp = ISDN_SLAVE_PRIV(lp);\n\t\t\t\t\tif (!(slp->flags & ISDN_NET_CONNECTED)) {\n\t\t\t\t\t\tisdn_net_force_dial_lp(ISDN_SLAVE_PRIV(lp));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (lp->sqfull && time_after(jiffies, lp->sqfull_stamp + lp->slavedelay + (10 * HZ))) {\n\t\t\tlp->sqfull = 0;\n\t\t}\n\t\t/* this is a hack to allow auto-hangup for slaves on moderate loads */\n\t\tnd->queue = nd->local;\n\t}\n\n\treturn retv;\n\n}\n\nstatic void\nisdn_net_adjust_hdr(struct sk_buff *skb, struct net_device *dev)\n{\n\tisdn_net_local *lp = netdev_priv(dev);\n\tif (!skb)\n\t\treturn;\n\tif (lp->p_encap == ISDN_NET_ENCAP_ETHER) {\n\t\tconst int pullsize = skb_network_offset(skb) - ETH_HLEN;\n\t\tif (pullsize > 0) {\n\t\t\tprintk(KERN_DEBUG \"isdn_net: Pull junk %d\\n\", pullsize);\n\t\t\tskb_pull(skb, pullsize);\n\t\t}\n\t}\n}\n\n\nstatic void isdn_net_tx_timeout(struct net_device * ndev)\n{\n\tisdn_net_local *lp = netdev_priv(ndev);\n\n\tprintk(KERN_WARNING \"isdn_tx_timeout dev %s dialstate %d\\n\", ndev->name, lp->dialstate);\n\tif (!lp->dialstate){\n\t\tlp->stats.tx_errors++;\n                /*\n\t\t * There is a certain probability that this currently\n\t\t * works at all because if we always wake up the interface,\n\t\t * then upper layer will try to send the next packet\n\t\t * immediately. And then, the old clean_up logic in the\n\t\t * driver will hopefully continue to work as it used to do.\n\t\t *\n\t\t * This is rather primitive right know, we better should\n\t\t * clean internal queues here, in particular for multilink and\n\t\t * ppp, and reset HL driver's channel, too.   --HE\n\t\t *\n\t\t * actually, this may not matter at all, because ISDN hardware\n\t\t * should not see transmitter hangs at all IMO\n\t\t * changed KERN_DEBUG to KERN_WARNING to find out if this is \n\t\t * ever called   --KG\n\t\t */\n\t}\n\tndev->trans_start = jiffies;\n\tnetif_wake_queue(ndev);\n}\n\n/*\n * Try sending a packet.\n * If this interface isn't connected to a ISDN-Channel, find a free channel,\n * and start dialing.\n */\nstatic netdev_tx_t\nisdn_net_start_xmit(struct sk_buff *skb, struct net_device *ndev)\n{\n\tisdn_net_local *lp = netdev_priv(ndev);\n#ifdef CONFIG_ISDN_X25\n\tstruct concap_proto * cprot = lp -> netdev -> cprot;\n/* At this point hard_start_xmit() passes control to the encapsulation\n   protocol (if present).\n   For X.25 auto-dialing is completly bypassed because:\n   - It does not conform with the semantics of a reliable datalink\n     service as needed by X.25 PLP.\n   - I don't want that the interface starts dialing when the network layer\n     sends a message which requests to disconnect the lapb link (or if it\n     sends any other message not resulting in data transmission).\n   Instead, dialing will be initiated by the encapsulation protocol entity\n   when a dl_establish request is received from the upper layer.\n*/\n\tif (cprot && cprot -> pops) {\n\t\tint ret = cprot -> pops -> encap_and_xmit ( cprot , skb);\n\n\t\tif (ret)\n\t\t\tnetif_stop_queue(ndev);\n\t\treturn ret;\n\t} else\n#endif\n\t/* auto-dialing xmit function */\n\t{\n#ifdef ISDN_DEBUG_NET_DUMP\n\t\tu_char *buf;\n#endif\n\t\tisdn_net_adjust_hdr(skb, ndev);\n#ifdef ISDN_DEBUG_NET_DUMP\n\t\tbuf = skb->data;\n\t\tisdn_dumppkt(\"S:\", buf, skb->len, 40);\n#endif\n\n\t\tif (!(lp->flags & ISDN_NET_CONNECTED)) {\n\t\t\tint chi;\n\t\t\t/* only do autodial if allowed by config */\n\t\t\tif (!(ISDN_NET_DIALMODE(*lp) == ISDN_NET_DM_AUTO)) {\n\t\t\t\tisdn_net_unreachable(ndev, skb, \"dial rejected: interface not in dialmode `auto'\");\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\treturn NETDEV_TX_OK;\n\t\t\t}\n\t\t\tif (lp->phone[1]) {\n\t\t\t\tulong flags;\n\n\t\t\t\tif(lp->dialwait_timer <= 0)\n\t\t\t\t\tif(lp->dialstarted > 0 && lp->dialtimeout > 0 && time_before(jiffies, lp->dialstarted + lp->dialtimeout + lp->dialwait))\n\t\t\t\t\t\tlp->dialwait_timer = lp->dialstarted + lp->dialtimeout + lp->dialwait;\n\n\t\t\t\tif(lp->dialwait_timer > 0) {\n\t\t\t\t\tif(time_before(jiffies, lp->dialwait_timer)) {\n\t\t\t\t\t\tisdn_net_unreachable(ndev, skb, \"dial rejected: retry-time not reached\");\n\t\t\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\t\t\treturn NETDEV_TX_OK;\n\t\t\t\t\t} else\n\t\t\t\t\t\tlp->dialwait_timer = 0;\n\t\t\t\t}\n\t\t\t\t/* Grab a free ISDN-Channel */\n\t\t\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\t\t\tif (((chi =\n\t\t\t\t     isdn_get_free_channel(\n\t\t\t\t\t \t\tISDN_USAGE_NET,\n\t\t\t\t\t\t\tlp->l2_proto,\n\t\t\t\t\t\t\tlp->l3_proto,\n\t\t\t\t\t\t\tlp->pre_device,\n\t\t\t\t\t\t \tlp->pre_channel,\n\t\t\t\t\t\t\tlp->msn)\n\t\t\t\t\t\t\t) < 0) &&\n\t\t\t\t\t((chi =\n\t\t\t\t     isdn_get_free_channel(\n\t\t\t\t\t \t\tISDN_USAGE_NET,\n\t\t\t\t\t\t\tlp->l2_proto,\n\t\t\t\t\t\t\tlp->l3_proto,\n\t\t\t\t\t\t\tlp->pre_device,\n\t\t\t\t\t\t\tlp->pre_channel^1,\n\t\t\t\t\t\t\tlp->msn)\n\t\t\t\t\t\t\t) < 0)) {\n\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\tisdn_net_unreachable(ndev, skb,\n\t\t\t\t\t\t\t   \"No channel\");\n\t\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\t\treturn NETDEV_TX_OK;\n\t\t\t\t}\n\t\t\t\t/* Log packet, which triggered dialing */\n\t\t\t\tif (dev->net_verbose)\n\t\t\t\t\tisdn_net_log_skb(skb, lp);\n\t\t\t\tlp->dialstate = 1;\n\t\t\t\t/* Connect interface with channel */\n\t\t\t\tisdn_net_bind_channel(lp, chi);\n#ifdef CONFIG_ISDN_PPP\n\t\t\t\tif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP) {\n\t\t\t\t\t/* no 'first_skb' handling for syncPPP */\n\t\t\t\t\tif (isdn_ppp_bind(lp) < 0) {\n\t\t\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\t\t\tisdn_net_unbind_channel(lp);\n\t\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\t\treturn NETDEV_TX_OK;\t/* STN (skb to nirvana) ;) */\n\t\t\t\t\t}\n#ifdef CONFIG_IPPP_FILTER\n\t\t\t\t\tif (isdn_ppp_autodial_filter(skb, lp)) {\n\t\t\t\t\t\tisdn_ppp_free(lp);\n\t\t\t\t\t\tisdn_net_unbind_channel(lp);\n\t\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\t\tisdn_net_unreachable(ndev, skb, \"dial rejected: packet filtered\");\n\t\t\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\t\t\treturn NETDEV_TX_OK;\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\tisdn_net_dial();\t/* Initiate dialing */\n\t\t\t\t\tnetif_stop_queue(ndev);\n\t\t\t\t\treturn NETDEV_TX_BUSY;\t/* let upper layer requeue skb packet */\n\t\t\t\t}\n#endif\n\t\t\t\t/* Initiate dialing */\n\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\tisdn_net_dial();\n\t\t\t\tisdn_net_device_stop_queue(lp);\n\t\t\t\treturn NETDEV_TX_BUSY;\n\t\t\t} else {\n\t\t\t\tisdn_net_unreachable(ndev, skb,\n\t\t\t\t\t\t     \"No phone number\");\n\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\treturn NETDEV_TX_OK;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Device is connected to an ISDN channel */ \n\t\t\tndev->trans_start = jiffies;\n\t\t\tif (!lp->dialstate) {\n\t\t\t\t/* ISDN connection is established, try sending */\n\t\t\t\tint ret;\n\t\t\t\tret = (isdn_net_xmit(ndev, skb));\n\t\t\t\tif(ret) netif_stop_queue(ndev);\n\t\t\t\treturn ret;\n\t\t\t} else\n\t\t\t\tnetif_stop_queue(ndev);\n\t\t}\n\t}\n\treturn NETDEV_TX_BUSY;\n}\n\n/*\n * Shutdown a net-interface.\n */\nstatic int\nisdn_net_close(struct net_device *dev)\n{\n\tstruct net_device *p;\n#ifdef CONFIG_ISDN_X25\n\tstruct concap_proto * cprot =\n\t\t((isdn_net_local *) netdev_priv(dev))->netdev->cprot;\n\t/* printk(KERN_DEBUG \"isdn_net_close %s\\n\" , dev-> name ); */\n#endif\n\n#ifdef CONFIG_ISDN_X25\n\tif( cprot && cprot -> pops ) cprot -> pops -> close( cprot );\n#endif\n\tnetif_stop_queue(dev);\n\tp = MASTER_TO_SLAVE(dev);\n\tif (p) {\n\t\t/* If this interface has slaves, stop them also */\n\t\twhile (p) {\n#ifdef CONFIG_ISDN_X25\n\t\t\tcprot = ((isdn_net_local *) netdev_priv(p))\n\t\t\t\t-> netdev -> cprot;\n\t\t\tif( cprot && cprot -> pops )\n\t\t\t\tcprot -> pops -> close( cprot );\n#endif\n\t\t\tisdn_net_hangup(p);\n\t\t\tp = MASTER_TO_SLAVE(p);\n\t\t}\n\t}\n\tisdn_net_hangup(dev);\n\tisdn_unlock_drivers();\n\treturn 0;\n}\n\n/*\n * Get statistics\n */\nstatic struct net_device_stats *\nisdn_net_get_stats(struct net_device *dev)\n{\n\tisdn_net_local *lp = netdev_priv(dev);\n\treturn &lp->stats;\n}\n\n/*      This is simply a copy from std. eth.c EXCEPT we pull ETH_HLEN\n *      instead of dev->hard_header_len off. This is done because the\n *      lowlevel-driver has already pulled off its stuff when we get\n *      here and this routine only gets called with p_encap == ETHER.\n *      Determine the packet's protocol ID. The rule here is that we\n *      assume 802.3 if the type field is short enough to be a length.\n *      This is normal practice and works for any 'now in use' protocol.\n */\n\nstatic __be16\nisdn_net_type_trans(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ethhdr *eth;\n\tunsigned char *rawp;\n\n\tskb_reset_mac_header(skb);\n\tskb_pull(skb, ETH_HLEN);\n\teth = eth_hdr(skb);\n\n\tif (*eth->h_dest & 1) {\n\t\tif (memcmp(eth->h_dest, dev->broadcast, ETH_ALEN) == 0)\n\t\t\tskb->pkt_type = PACKET_BROADCAST;\n\t\telse\n\t\t\tskb->pkt_type = PACKET_MULTICAST;\n\t}\n\t/*\n\t *      This ALLMULTI check should be redundant by 1.4\n\t *      so don't forget to remove it.\n\t */\n\n\telse if (dev->flags & (IFF_PROMISC /*| IFF_ALLMULTI*/)) {\n\t\tif (memcmp(eth->h_dest, dev->dev_addr, ETH_ALEN))\n\t\t\tskb->pkt_type = PACKET_OTHERHOST;\n\t}\n\tif (ntohs(eth->h_proto) >= 1536)\n\t\treturn eth->h_proto;\n\n\trawp = skb->data;\n\n\t/*\n\t *      This is a magic hack to spot IPX packets. Older Novell breaks\n\t *      the protocol design and runs IPX over 802.3 without an 802.2 LLC\n\t *      layer. We look for FFFF which isn't a used 802.2 SSAP/DSAP. This\n\t *      won't work for fault tolerant netware but does for the rest.\n\t */\n\tif (*(unsigned short *) rawp == 0xFFFF)\n\t\treturn htons(ETH_P_802_3);\n\t/*\n\t *      Real 802.2 LLC\n\t */\n\treturn htons(ETH_P_802_2);\n}\n\n\n/* \n * CISCO HDLC keepalive specific stuff\n */\nstatic struct sk_buff*\nisdn_net_ciscohdlck_alloc_skb(isdn_net_local *lp, int len)\n{\n\tunsigned short hl = dev->drv[lp->isdn_device]->interface->hl_hdrlen;\n\tstruct sk_buff *skb;\n\n\tskb = alloc_skb(hl + len, GFP_ATOMIC);\n\tif (skb)\n\t\tskb_reserve(skb, hl);\n\telse \n\t\tprintk(\"isdn out of mem at %s:%d!\\n\", __FILE__, __LINE__);\n\treturn skb;\n}\n\n/* cisco hdlck device private ioctls */\nstatic int\nisdn_ciscohdlck_dev_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tisdn_net_local *lp = netdev_priv(dev);\n\tunsigned long len = 0;\n\tunsigned long expires = 0;\n\tint tmp = 0;\n\tint period = lp->cisco_keepalive_period;\n\ts8 debserint = lp->cisco_debserint;\n\tint rc = 0;\n\n\tif (lp->p_encap != ISDN_NET_ENCAP_CISCOHDLCK)\n\t\treturn -EINVAL;\n\n\tswitch (cmd) {\n\t\t/* get/set keepalive period */\n\t\tcase SIOCGKEEPPERIOD:\n\t\t\tlen = (unsigned long)sizeof(lp->cisco_keepalive_period);\n\t\t\tif (copy_to_user(ifr->ifr_data,\n\t\t\t\t&lp->cisco_keepalive_period, len))\n\t\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\tcase SIOCSKEEPPERIOD:\n\t\t\ttmp = lp->cisco_keepalive_period;\n\t\t\tlen = (unsigned long)sizeof(lp->cisco_keepalive_period);\n\t\t\tif (copy_from_user(&period, ifr->ifr_data, len))\n\t\t\t\trc = -EFAULT;\n\t\t\tif ((period > 0) && (period <= 32767))\n\t\t\t\tlp->cisco_keepalive_period = period;\n\t\t\telse\n\t\t\t\trc = -EINVAL;\n\t\t\tif (!rc && (tmp != lp->cisco_keepalive_period)) {\n\t\t\t\texpires = (unsigned long)(jiffies +\n\t\t\t\t\tlp->cisco_keepalive_period * HZ);\n\t\t\t\tmod_timer(&lp->cisco_timer, expires);\n\t\t\t\tprintk(KERN_INFO \"%s: Keepalive period set \"\n\t\t\t\t\t\"to %d seconds.\\n\",\n\t\t\t\t\tdev->name, lp->cisco_keepalive_period);\n\t\t\t}\n\t\t\tbreak;\n\n\t\t/* get/set debugging */\n\t\tcase SIOCGDEBSERINT:\n\t\t\tlen = (unsigned long)sizeof(lp->cisco_debserint);\n\t\t\tif (copy_to_user(ifr->ifr_data,\n\t\t\t\t&lp->cisco_debserint, len))\n\t\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\tcase SIOCSDEBSERINT:\n\t\t\tlen = (unsigned long)sizeof(lp->cisco_debserint);\n\t\t\tif (copy_from_user(&debserint,\n\t\t\t\tifr->ifr_data, len))\n\t\t\t\trc = -EFAULT;\n\t\t\tif ((debserint >= 0) && (debserint <= 64))\n\t\t\t\tlp->cisco_debserint = debserint;\n\t\t\telse\n\t\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\trc = -EINVAL;\n\t\t\tbreak;\n\t}\n\treturn (rc);\n}\n\n\nstatic int isdn_net_ioctl(struct net_device *dev,\n\t\t\t  struct ifreq *ifr, int cmd)\n{\n\tisdn_net_local *lp = netdev_priv(dev);\n\n\tswitch (lp->p_encap) {\n#ifdef CONFIG_ISDN_PPP\n\tcase ISDN_NET_ENCAP_SYNCPPP:\n\t\treturn isdn_ppp_dev_ioctl(dev, ifr, cmd);\n#endif\n\tcase ISDN_NET_ENCAP_CISCOHDLCK:\n\t\treturn isdn_ciscohdlck_dev_ioctl(dev, ifr, cmd);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n/* called via cisco_timer.function */\nstatic void\nisdn_net_ciscohdlck_slarp_send_keepalive(unsigned long data)\n{\n\tisdn_net_local *lp = (isdn_net_local *) data;\n\tstruct sk_buff *skb;\n\tunsigned char *p;\n\tunsigned long last_cisco_myseq = lp->cisco_myseq;\n\tint myseq_diff = 0;\n\n\tif (!(lp->flags & ISDN_NET_CONNECTED) || lp->dialstate) {\n\t\tprintk(\"isdn BUG at %s:%d!\\n\", __FILE__, __LINE__);\n\t\treturn;\n\t}\n\tlp->cisco_myseq++;\n\n\tmyseq_diff = (lp->cisco_myseq - lp->cisco_mineseen);\n\tif ((lp->cisco_line_state) && ((myseq_diff >= 3)||(myseq_diff <= -3))) {\n\t\t/* line up -> down */\n\t\tlp->cisco_line_state = 0;\n\t\tprintk (KERN_WARNING\n\t\t\t\t\"UPDOWN: Line protocol on Interface %s,\"\n\t\t\t\t\" changed state to down\\n\", lp->netdev->dev->name);\n\t\t/* should stop routing higher-level data across */\n\t} else if ((!lp->cisco_line_state) &&\n\t\t(myseq_diff >= 0) && (myseq_diff <= 2)) {\n\t\t/* line down -> up */\n\t\tlp->cisco_line_state = 1;\n\t\tprintk (KERN_WARNING\n\t\t\t\t\"UPDOWN: Line protocol on Interface %s,\"\n\t\t\t\t\" changed state to up\\n\", lp->netdev->dev->name);\n\t\t/* restart routing higher-level data across */\n\t}\n\n\tif (lp->cisco_debserint)\n\t\tprintk (KERN_DEBUG \"%s: HDLC \"\n\t\t\t\"myseq %lu, mineseen %lu%c, yourseen %lu, %s\\n\",\n\t\t\tlp->netdev->dev->name, last_cisco_myseq, lp->cisco_mineseen,\n\t\t\t((last_cisco_myseq == lp->cisco_mineseen) ? '*' : 040),\n\t\t\tlp->cisco_yourseq,\n\t\t\t((lp->cisco_line_state) ? \"line up\" : \"line down\"));\n\n\tskb = isdn_net_ciscohdlck_alloc_skb(lp, 4 + 14);\n\tif (!skb)\n\t\treturn;\n\n\tp = skb_put(skb, 4 + 14);\n\n\t/* cisco header */\n\t*(u8 *)(p + 0) = CISCO_ADDR_UNICAST;\n\t*(u8 *)(p + 1) = CISCO_CTRL;\n\t*(__be16 *)(p + 2) = cpu_to_be16(CISCO_TYPE_SLARP);\n\n\t/* slarp keepalive */\n\t*(__be32 *)(p +  4) = cpu_to_be32(CISCO_SLARP_KEEPALIVE);\n\t*(__be32 *)(p +  8) = cpu_to_be32(lp->cisco_myseq);\n\t*(__be32 *)(p + 12) = cpu_to_be32(lp->cisco_yourseq);\n\t*(__be16 *)(p + 16) = cpu_to_be16(0xffff); // reliability, always 0xffff\n\tp += 18;\n\n\tisdn_net_write_super(lp, skb);\n\n\tlp->cisco_timer.expires = jiffies + lp->cisco_keepalive_period * HZ;\n\t\n\tadd_timer(&lp->cisco_timer);\n}\n\nstatic void\nisdn_net_ciscohdlck_slarp_send_request(isdn_net_local *lp)\n{\n\tstruct sk_buff *skb;\n\tunsigned char *p;\n\n\tskb = isdn_net_ciscohdlck_alloc_skb(lp, 4 + 14);\n\tif (!skb)\n\t\treturn;\n\n\tp = skb_put(skb, 4 + 14);\n\n\t/* cisco header */\n\t*(u8 *)(p + 0) = CISCO_ADDR_UNICAST;\n\t*(u8 *)(p + 1) = CISCO_CTRL;\n\t*(__be16 *)(p + 2) = cpu_to_be16(CISCO_TYPE_SLARP);\n\n\t/* slarp request */\n\t*(__be32 *)(p +  4) = cpu_to_be32(CISCO_SLARP_REQUEST);\n\t*(__be32 *)(p +  8) = cpu_to_be32(0); // address\n\t*(__be32 *)(p + 12) = cpu_to_be32(0); // netmask\n\t*(__be16 *)(p + 16) = cpu_to_be16(0); // unused\n\tp += 18;\n\n\tisdn_net_write_super(lp, skb);\n}\n\nstatic void \nisdn_net_ciscohdlck_connected(isdn_net_local *lp)\n{\n\tlp->cisco_myseq = 0;\n\tlp->cisco_mineseen = 0;\n\tlp->cisco_yourseq = 0;\n\tlp->cisco_keepalive_period = ISDN_TIMER_KEEPINT;\n\tlp->cisco_last_slarp_in = 0;\n\tlp->cisco_line_state = 0;\n\tlp->cisco_debserint = 0;\n\n\t/* send slarp request because interface/seq.no.s reset */\n\tisdn_net_ciscohdlck_slarp_send_request(lp);\n\n\tinit_timer(&lp->cisco_timer);\n\tlp->cisco_timer.data = (unsigned long) lp;\n\tlp->cisco_timer.function = isdn_net_ciscohdlck_slarp_send_keepalive;\n\tlp->cisco_timer.expires = jiffies + lp->cisco_keepalive_period * HZ;\n\tadd_timer(&lp->cisco_timer);\n}\n\nstatic void \nisdn_net_ciscohdlck_disconnected(isdn_net_local *lp)\n{\n\tdel_timer(&lp->cisco_timer);\n}\n\nstatic void\nisdn_net_ciscohdlck_slarp_send_reply(isdn_net_local *lp)\n{\n\tstruct sk_buff *skb;\n\tunsigned char *p;\n\tstruct in_device *in_dev = NULL;\n\t__be32 addr = 0;\t\t/* local ipv4 address */\n\t__be32 mask = 0;\t\t/* local netmask */\n\n\tif ((in_dev = lp->netdev->dev->ip_ptr) != NULL) {\n\t\t/* take primary(first) address of interface */\n\t\tstruct in_ifaddr *ifa = in_dev->ifa_list;\n\t\tif (ifa != NULL) {\n\t\t\taddr = ifa->ifa_local;\n\t\t\tmask = ifa->ifa_mask;\n\t\t}\n\t}\n\n\tskb = isdn_net_ciscohdlck_alloc_skb(lp, 4 + 14);\n\tif (!skb)\n\t\treturn;\n\n\tp = skb_put(skb, 4 + 14);\n\n\t/* cisco header */\n\t*(u8 *)(p + 0) = CISCO_ADDR_UNICAST;\n\t*(u8 *)(p + 1) = CISCO_CTRL;\n\t*(__be16 *)(p + 2) = cpu_to_be16(CISCO_TYPE_SLARP);\n\n\t/* slarp reply, send own ip/netmask; if values are nonsense remote\n\t * should think we are unable to provide it with an address via SLARP */\n\t*(__be32 *)(p +  4) = cpu_to_be32(CISCO_SLARP_REPLY);\n\t*(__be32 *)(p +  8) = addr; // address\n\t*(__be32 *)(p + 12) = mask; // netmask\n\t*(__be16 *)(p + 16) = cpu_to_be16(0); // unused\n\tp += 18;\n\n\tisdn_net_write_super(lp, skb);\n}\n\nstatic void\nisdn_net_ciscohdlck_slarp_in(isdn_net_local *lp, struct sk_buff *skb)\n{\n\tunsigned char *p;\n\tint period;\n\tu32 code;\n\tu32 my_seq;\n\tu32 your_seq;\n\t__be32 local;\n\t__be32 *addr, *mask;\n\n\tif (skb->len < 14)\n\t\treturn;\n\n\tp = skb->data;\n\tcode = be32_to_cpup((__be32 *)p);\n\tp += 4;\n\n\tswitch (code) {\n\tcase CISCO_SLARP_REQUEST:\n\t\tlp->cisco_yourseq = 0;\n\t\tisdn_net_ciscohdlck_slarp_send_reply(lp);\n\t\tbreak;\n\tcase CISCO_SLARP_REPLY:\n\t\taddr = (__be32 *)p;\n\t\tmask = (__be32 *)(p + 4);\n\t\tif (*mask != cpu_to_be32(0xfffffffc))\n\t\t\tgoto slarp_reply_out;\n\t\tif ((*addr & cpu_to_be32(3)) == cpu_to_be32(0) ||\n\t\t    (*addr & cpu_to_be32(3)) == cpu_to_be32(3))\n\t\t\tgoto slarp_reply_out;\n\t\tlocal = *addr ^ cpu_to_be32(3);\n\t\tprintk(KERN_INFO \"%s: got slarp reply: remote ip: %pI4, local ip: %pI4 mask: %pI4\\n\",\n\t\t       lp->netdev->dev->name, addr, &local, mask);\n\t\tbreak;\n  slarp_reply_out:\n\t\tprintk(KERN_INFO \"%s: got invalid slarp reply (%pI4/%pI4) - ignored\\n\",\n\t\t       lp->netdev->dev->name, addr, mask);\n\t\tbreak;\n\tcase CISCO_SLARP_KEEPALIVE:\n\t\tperiod = (int)((jiffies - lp->cisco_last_slarp_in\n\t\t\t\t+ HZ/2 - 1) / HZ);\n\t\tif (lp->cisco_debserint &&\n\t\t\t\t(period != lp->cisco_keepalive_period) &&\n\t\t\t\tlp->cisco_last_slarp_in) {\n\t\t\tprintk(KERN_DEBUG \"%s: Keepalive period mismatch - \"\n\t\t\t\t\"is %d but should be %d.\\n\",\n\t\t\t\tlp->netdev->dev->name, period,\n\t\t\t\tlp->cisco_keepalive_period);\n\t\t}\n\t\tlp->cisco_last_slarp_in = jiffies;\n\t\tmy_seq = be32_to_cpup((__be32 *)(p + 0));\n\t\tyour_seq = be32_to_cpup((__be32 *)(p + 4));\n\t\tp += 10;\n\t\tlp->cisco_yourseq = my_seq;\n\t\tlp->cisco_mineseen = your_seq;\n\t\tbreak;\n\t}\n}\n\nstatic void\nisdn_net_ciscohdlck_receive(isdn_net_local *lp, struct sk_buff *skb)\n{\n\tunsigned char *p;\n \tu8 addr;\n \tu8 ctrl;\n \tu16 type;\n\t\n\tif (skb->len < 4)\n\t\tgoto out_free;\n\n\tp = skb->data;\n\taddr = *(u8 *)(p + 0);\n\tctrl = *(u8 *)(p + 1);\n\ttype = be16_to_cpup((__be16 *)(p + 2));\n\tp += 4;\n\tskb_pull(skb, 4);\n\t\n\tif (addr != CISCO_ADDR_UNICAST && addr != CISCO_ADDR_BROADCAST) {\n\t\tprintk(KERN_WARNING \"%s: Unknown Cisco addr 0x%02x\\n\",\n\t\t       lp->netdev->dev->name, addr);\n\t\tgoto out_free;\n\t}\n\tif (ctrl != CISCO_CTRL) {\n\t\tprintk(KERN_WARNING \"%s: Unknown Cisco ctrl 0x%02x\\n\",\n\t\t       lp->netdev->dev->name, ctrl);\n\t\tgoto out_free;\n\t}\n\n\tswitch (type) {\n\tcase CISCO_TYPE_SLARP:\n\t\tisdn_net_ciscohdlck_slarp_in(lp, skb);\n\t\tgoto out_free;\n\tcase CISCO_TYPE_CDP:\n\t\tif (lp->cisco_debserint)\n\t\t\tprintk(KERN_DEBUG \"%s: Received CDP packet. use \"\n\t\t\t\t\"\\\"no cdp enable\\\" on cisco.\\n\",\n\t\t\t\tlp->netdev->dev->name);\n\t\tgoto out_free;\n\tdefault:\n\t\t/* no special cisco protocol */\n\t\tskb->protocol = htons(type);\n\t\tnetif_rx(skb);\n\t\treturn;\n\t}\n\n out_free:\n\tkfree_skb(skb);\n}\n\n/*\n * Got a packet from ISDN-Channel.\n */\nstatic void\nisdn_net_receive(struct net_device *ndev, struct sk_buff *skb)\n{\n\tisdn_net_local *lp = netdev_priv(ndev);\n\tisdn_net_local *olp = lp;\t/* original 'lp' */\n#ifdef CONFIG_ISDN_X25\n\tstruct concap_proto *cprot = lp -> netdev -> cprot;\n#endif\n\tlp->transcount += skb->len;\n\n\tlp->stats.rx_packets++;\n\tlp->stats.rx_bytes += skb->len;\n\tif (lp->master) {\n\t\t/* Bundling: If device is a slave-device, deliver to master, also\n\t\t * handle master's statistics and hangup-timeout\n\t\t */\n\t\tndev = lp->master;\n\t\tlp = netdev_priv(ndev);\n\t\tlp->stats.rx_packets++;\n\t\tlp->stats.rx_bytes += skb->len;\n\t}\n\tskb->dev = ndev;\n\tskb->pkt_type = PACKET_HOST;\n\tskb_reset_mac_header(skb);\n#ifdef ISDN_DEBUG_NET_DUMP\n\tisdn_dumppkt(\"R:\", skb->data, skb->len, 40);\n#endif\n\tswitch (lp->p_encap) {\n\t\tcase ISDN_NET_ENCAP_ETHER:\n\t\t\t/* Ethernet over ISDN */\n\t\t\tolp->huptimer = 0;\n\t\t\tlp->huptimer = 0;\n\t\t\tskb->protocol = isdn_net_type_trans(skb, ndev);\n\t\t\tbreak;\n\t\tcase ISDN_NET_ENCAP_UIHDLC:\n\t\t\t/* HDLC with UI-frame (for ispa with -h1 option) */\n\t\t\tolp->huptimer = 0;\n\t\t\tlp->huptimer = 0;\n\t\t\tskb_pull(skb, 2);\n\t\t\t/* Fall through */\n\t\tcase ISDN_NET_ENCAP_RAWIP:\n\t\t\t/* RAW-IP without MAC-Header */\n\t\t\tolp->huptimer = 0;\n\t\t\tlp->huptimer = 0;\n\t\t\tskb->protocol = htons(ETH_P_IP);\n\t\t\tbreak;\n\t\tcase ISDN_NET_ENCAP_CISCOHDLCK:\n\t\t\tisdn_net_ciscohdlck_receive(lp, skb);\n\t\t\treturn;\n\t\tcase ISDN_NET_ENCAP_CISCOHDLC:\n\t\t\t/* CISCO-HDLC IP with type field and  fake I-frame-header */\n\t\t\tskb_pull(skb, 2);\n\t\t\t/* Fall through */\n\t\tcase ISDN_NET_ENCAP_IPTYP:\n\t\t\t/* IP with type field */\n\t\t\tolp->huptimer = 0;\n\t\t\tlp->huptimer = 0;\n\t\t\tskb->protocol = *(__be16 *)&(skb->data[0]);\n\t\t\tskb_pull(skb, 2);\n\t\t\tif (*(unsigned short *) skb->data == 0xFFFF)\n\t\t\t\tskb->protocol = htons(ETH_P_802_3);\n\t\t\tbreak;\n#ifdef CONFIG_ISDN_PPP\n\t\tcase ISDN_NET_ENCAP_SYNCPPP:\n\t\t\t/* huptimer is done in isdn_ppp_push_higher */\n\t\t\tisdn_ppp_receive(lp->netdev, olp, skb);\n\t\t\treturn;\n#endif\n\n\t\tdefault:\n#ifdef CONFIG_ISDN_X25\n\t\t  /* try if there are generic sync_device receiver routines */\n\t\t\tif(cprot) if(cprot -> pops)\n\t\t\t\tif( cprot -> pops -> data_ind){\n\t\t\t\t\tcprot -> pops -> data_ind(cprot,skb);\n\t\t\t\t\treturn;\n\t\t\t\t};\n#endif /* CONFIG_ISDN_X25 */\n\t\t\tprintk(KERN_WARNING \"%s: unknown encapsulation, dropping\\n\",\n\t\t\t       lp->netdev->dev->name);\n\t\t\tkfree_skb(skb);\n\t\t\treturn;\n\t}\n\n\tnetif_rx(skb);\n\treturn;\n}\n\n/*\n * A packet arrived via ISDN. Search interface-chain for a corresponding\n * interface. If found, deliver packet to receiver-function and return 1,\n * else return 0.\n */\nint\nisdn_net_rcv_skb(int idx, struct sk_buff *skb)\n{\n\tisdn_net_dev *p = dev->rx_netdev[idx];\n\n\tif (p) {\n\t\tisdn_net_local *lp = p->local;\n\t\tif ((lp->flags & ISDN_NET_CONNECTED) &&\n\t\t    (!lp->dialstate)) {\n\t\t\tisdn_net_receive(p->dev, skb);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n *  build an header\n *  depends on encaps that is being used.\n */\n\nstatic int isdn_net_header(struct sk_buff *skb, struct net_device *dev,\n\t\t\t   unsigned short type,\n\t\t\t   const void *daddr, const void *saddr, unsigned plen)\n{\n\tisdn_net_local *lp = netdev_priv(dev);\n\tunsigned char *p;\n\tushort len = 0;\n\n\tswitch (lp->p_encap) {\n\t\tcase ISDN_NET_ENCAP_ETHER:\n\t\t\tlen = eth_header(skb, dev, type, daddr, saddr, plen);\n\t\t\tbreak;\n#ifdef CONFIG_ISDN_PPP\n\t\tcase ISDN_NET_ENCAP_SYNCPPP:\n\t\t\t/* stick on a fake header to keep fragmentation code happy. */\n\t\t\tlen = IPPP_MAX_HEADER;\n\t\t\tskb_push(skb,len);\n\t\t\tbreak;\n#endif\n\t\tcase ISDN_NET_ENCAP_RAWIP:\n\t\t\tprintk(KERN_WARNING \"isdn_net_header called with RAW_IP!\\n\");\n\t\t\tlen = 0;\n\t\t\tbreak;\n\t\tcase ISDN_NET_ENCAP_IPTYP:\n\t\t\t/* ethernet type field */\n\t\t\t*((__be16 *)skb_push(skb, 2)) = htons(type);\n\t\t\tlen = 2;\n\t\t\tbreak;\n\t\tcase ISDN_NET_ENCAP_UIHDLC:\n\t\t\t/* HDLC with UI-Frames (for ispa with -h1 option) */\n\t\t\t*((__be16 *)skb_push(skb, 2)) = htons(0x0103);\n\t\t\tlen = 2;\n\t\t\tbreak;\n\t\tcase ISDN_NET_ENCAP_CISCOHDLC:\n\t\tcase ISDN_NET_ENCAP_CISCOHDLCK:\n\t\t\tp = skb_push(skb, 4);\n\t\t\t*(u8 *)(p + 0) = CISCO_ADDR_UNICAST;\n\t\t\t*(u8 *)(p + 1) = CISCO_CTRL;\n\t\t\t*(__be16 *)(p + 2) = cpu_to_be16(type);\n\t\t\tp += 4;\n\t\t\tlen = 4;\n\t\t\tbreak;\n#ifdef CONFIG_ISDN_X25\n\t\tdefault:\n\t\t  /* try if there are generic concap protocol routines */\n\t\t\tif( lp-> netdev -> cprot ){\n\t\t\t\tprintk(KERN_WARNING \"isdn_net_header called with concap_proto!\\n\");\n\t\t\t\tlen = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n#endif /* CONFIG_ISDN_X25 */\n\t}\n\treturn len;\n}\n\n/* We don't need to send arp, because we have point-to-point connections. */\nstatic int\nisdn_net_rebuild_header(struct sk_buff *skb)\n{\n\tstruct net_device *dev = skb->dev;\n\tisdn_net_local *lp = netdev_priv(dev);\n\tint ret = 0;\n\n\tif (lp->p_encap == ISDN_NET_ENCAP_ETHER) {\n\t\tstruct ethhdr *eth = (struct ethhdr *) skb->data;\n\n\t\t/*\n\t\t *      Only ARP/IP is currently supported\n\t\t */\n\n\t\tif (eth->h_proto != htons(ETH_P_IP)) {\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"isdn_net: %s don't know how to resolve type %d addresses?\\n\",\n\t\t\t       dev->name, (int) eth->h_proto);\n\t\t\tmemcpy(eth->h_source, dev->dev_addr, dev->addr_len);\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t *      Try to get ARP to resolve the header.\n\t\t */\n#ifdef CONFIG_INET\n\t\tret = arp_find(eth->h_dest, skb);\n#endif\n\t}\n\treturn ret;\n}\n\nstatic int isdn_header_cache(const struct neighbour *neigh, struct hh_cache *hh,\n\t\t\t     __be16 type)\n{\n\tconst struct net_device *dev = neigh->dev;\n\tisdn_net_local *lp = netdev_priv(dev);\n\n\tif (lp->p_encap == ISDN_NET_ENCAP_ETHER)\n\t\treturn eth_header_cache(neigh, hh, type);\n\treturn -1;\n}\n\nstatic void isdn_header_cache_update(struct hh_cache *hh,\n\t\t\t\t     const struct net_device *dev,\n\t\t\t\t     const unsigned char *haddr)\n{\n\tisdn_net_local *lp = netdev_priv(dev);\n\tif (lp->p_encap == ISDN_NET_ENCAP_ETHER)\n\t\teth_header_cache_update(hh, dev, haddr);\n}\n\nstatic const struct header_ops isdn_header_ops = {\n\t.create = isdn_net_header,\n\t.rebuild = isdn_net_rebuild_header,\n\t.cache = isdn_header_cache,\n\t.cache_update = isdn_header_cache_update,\n};\n\n/*\n * Interface-setup. (just after registering a new interface)\n */\nstatic int\nisdn_net_init(struct net_device *ndev)\n{\n\tushort max_hlhdr_len = 0;\n\tint drvidx;\n\n\t/*\n\t *  up till binding we ask the protocol layer to reserve as much\n\t *  as we might need for HL layer\n\t */\n\n\tfor (drvidx = 0; drvidx < ISDN_MAX_DRIVERS; drvidx++)\n\t\tif (dev->drv[drvidx])\n\t\t\tif (max_hlhdr_len < dev->drv[drvidx]->interface->hl_hdrlen)\n\t\t\t\tmax_hlhdr_len = dev->drv[drvidx]->interface->hl_hdrlen;\n\n\tndev->hard_header_len = ETH_HLEN + max_hlhdr_len;\n\treturn 0;\n}\n\nstatic void\nisdn_net_swapbind(int drvidx)\n{\n\tisdn_net_dev *p;\n\n#ifdef ISDN_DEBUG_NET_ICALL\n\tprintk(KERN_DEBUG \"n_fi: swapping ch of %d\\n\", drvidx);\n#endif\n\tp = dev->netdev;\n\twhile (p) {\n\t\tif (p->local->pre_device == drvidx)\n\t\t\tswitch (p->local->pre_channel) {\n\t\t\t\tcase 0:\n\t\t\t\t\tp->local->pre_channel = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tp->local->pre_channel = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\tp = (isdn_net_dev *) p->next;\n\t}\n}\n\nstatic void\nisdn_net_swap_usage(int i1, int i2)\n{\n\tint u1 = dev->usage[i1] & ISDN_USAGE_EXCLUSIVE;\n\tint u2 = dev->usage[i2] & ISDN_USAGE_EXCLUSIVE;\n\n#ifdef ISDN_DEBUG_NET_ICALL\n\tprintk(KERN_DEBUG \"n_fi: usage of %d and %d\\n\", i1, i2);\n#endif\n\tdev->usage[i1] &= ~ISDN_USAGE_EXCLUSIVE;\n\tdev->usage[i1] |= u2;\n\tdev->usage[i2] &= ~ISDN_USAGE_EXCLUSIVE;\n\tdev->usage[i2] |= u1;\n\tisdn_info_update();\n}\n\n/*\n * An incoming call-request has arrived.\n * Search the interface-chain for an appropriate interface.\n * If found, connect the interface to the ISDN-channel and initiate\n * D- and B-Channel-setup. If secure-flag is set, accept only\n * configured phone-numbers. If callback-flag is set, initiate\n * callback-dialing.\n *\n * Return-Value: 0 = No appropriate interface for this call.\n *               1 = Call accepted\n *               2 = Reject call, wait cbdelay, then call back\n *               3 = Reject call\n *               4 = Wait cbdelay, then call back\n *               5 = No appropriate interface for this call,\n *                   would eventually match if CID was longer.\n */\n\nint\nisdn_net_find_icall(int di, int ch, int idx, setup_parm *setup)\n{\n\tchar *eaz;\n\tint si1;\n\tint si2;\n\tint ematch;\n\tint wret;\n\tint swapped;\n\tint sidx = 0;\n\tu_long flags;\n\tisdn_net_dev *p;\n\tisdn_net_phone *n;\n\tchar nr[ISDN_MSNLEN];\n\tchar *my_eaz;\n\n\t/* Search name in netdev-chain */\n\tif (!setup->phone[0]) {\n\t\tnr[0] = '0';\n\t\tnr[1] = '\\0';\n\t\tprintk(KERN_INFO \"isdn_net: Incoming call without OAD, assuming '0'\\n\");\n\t} else\n\t\tstrlcpy(nr, setup->phone, ISDN_MSNLEN);\n\tsi1 = (int) setup->si1;\n\tsi2 = (int) setup->si2;\n\tif (!setup->eazmsn[0]) {\n\t\tprintk(KERN_WARNING \"isdn_net: Incoming call without CPN, assuming '0'\\n\");\n\t\teaz = \"0\";\n\t} else\n\t\teaz = setup->eazmsn;\n\tif (dev->net_verbose > 1)\n\t\tprintk(KERN_INFO \"isdn_net: call from %s,%d,%d -> %s\\n\", nr, si1, si2, eaz);\n\t/* Accept DATA and VOICE calls at this stage\n\t * local eaz is checked later for allowed call types\n\t */\n\tif ((si1 != 7) && (si1 != 1)) {\n\t\tif (dev->net_verbose > 1)\n\t\t\tprintk(KERN_INFO \"isdn_net: Service-Indicator not 1 or 7, ignored\\n\");\n\t\treturn 0;\n\t}\n\tn = (isdn_net_phone *) 0;\n\tp = dev->netdev;\n\tematch = wret = swapped = 0;\n#ifdef ISDN_DEBUG_NET_ICALL\n\tprintk(KERN_DEBUG \"n_fi: di=%d ch=%d idx=%d usg=%d\\n\", di, ch, idx,\n\t\tdev->usage[idx]);\n#endif\n\twhile (p) {\n\t\tint matchret;\n\t\tisdn_net_local *lp = p->local;\n\n\t\t/* If last check has triggered as binding-swap, revert it */\n\t\tswitch (swapped) {\n\t\t\tcase 2:\n\t\t\t\tisdn_net_swap_usage(idx, sidx);\n\t\t\t\t/* fall through */\n\t\t\tcase 1:\n\t\t\t\tisdn_net_swapbind(di);\n\t\t\t\tbreak;\n\t\t}\n\t\tswapped = 0;\n                /* check acceptable call types for DOV */\n                my_eaz = isdn_map_eaz2msn(lp->msn, di);\n                if (si1 == 1) { /* it's a DOV call, check if we allow it */\n                        if (*my_eaz == 'v' || *my_eaz == 'V' ||\n\t\t\t    *my_eaz == 'b' || *my_eaz == 'B')\n                                my_eaz++; /* skip to allow a match */\n                        else\n                                my_eaz = NULL; /* force non match */\n                } else { /* it's a DATA call, check if we allow it */\n                        if (*my_eaz == 'b' || *my_eaz == 'B')\n                                my_eaz++; /* skip to allow a match */\n                }\n                if (my_eaz)\n                        matchret = isdn_msncmp(eaz, my_eaz);\n                else\n                        matchret = 1;\n                if (!matchret)\n                        ematch = 1;\n\n\t\t/* Remember if more numbers eventually can match */\n\t\tif (matchret > wret)\n\t\t\twret = matchret;\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\tprintk(KERN_DEBUG \"n_fi: if='%s', l.msn=%s, l.flags=%d, l.dstate=%d\\n\",\n\t\t       p->dev->name, lp->msn, lp->flags, lp->dialstate);\n#endif\n\t\tif ((!matchret) &&                                        /* EAZ is matching   */\n\t\t    (((!(lp->flags & ISDN_NET_CONNECTED)) &&              /* but not connected */\n\t\t      (USG_NONE(dev->usage[idx]))) ||                     /* and ch. unused or */\n\t\t     ((((lp->dialstate == 4) || (lp->dialstate == 12)) && /* if dialing        */\n\t\t       (!(lp->flags & ISDN_NET_CALLBACK)))                /* but no callback   */\n\t\t     )))\n\t\t\t {\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\tprintk(KERN_DEBUG \"n_fi: match1, pdev=%d pch=%d\\n\",\n\t\t\t       lp->pre_device, lp->pre_channel);\n#endif\n\t\t\tif (dev->usage[idx] & ISDN_USAGE_EXCLUSIVE) {\n\t\t\t\tif ((lp->pre_channel != ch) ||\n\t\t\t\t    (lp->pre_device != di)) {\n\t\t\t\t\t/* Here we got a problem:\n\t\t\t\t\t * If using an ICN-Card, an incoming call is always signaled on\n\t\t\t\t\t * on the first channel of the card, if both channels are\n\t\t\t\t\t * down. However this channel may be bound exclusive. If the\n\t\t\t\t\t * second channel is free, this call should be accepted.\n\t\t\t\t\t * The solution is horribly but it runs, so what:\n\t\t\t\t\t * We exchange the exclusive bindings of the two channels, the\n\t\t\t\t\t * corresponding variables in the interface-structs.\n\t\t\t\t\t */\n\t\t\t\t\tif (ch == 0) {\n\t\t\t\t\t\tsidx = isdn_dc2minor(di, 1);\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\t\t\tprintk(KERN_DEBUG \"n_fi: ch is 0\\n\");\n#endif\n\t\t\t\t\t\tif (USG_NONE(dev->usage[sidx])) {\n\t\t\t\t\t\t\t/* Second Channel is free, now see if it is bound\n\t\t\t\t\t\t\t * exclusive too. */\n\t\t\t\t\t\t\tif (dev->usage[sidx] & ISDN_USAGE_EXCLUSIVE) {\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\t\t\t\t\tprintk(KERN_DEBUG \"n_fi: 2nd channel is down and bound\\n\");\n#endif\n\t\t\t\t\t\t\t\t/* Yes, swap bindings only, if the original\n\t\t\t\t\t\t\t\t * binding is bound to channel 1 of this driver */\n\t\t\t\t\t\t\t\tif ((lp->pre_device == di) &&\n\t\t\t\t\t\t\t\t    (lp->pre_channel == 1)) {\n\t\t\t\t\t\t\t\t\tisdn_net_swapbind(di);\n\t\t\t\t\t\t\t\t\tswapped = 1;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t/* ... else iterate next device */\n\t\t\t\t\t\t\t\t\tp = (isdn_net_dev *) p->next;\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\t\t\t\t\tprintk(KERN_DEBUG \"n_fi: 2nd channel is down and unbound\\n\");\n#endif\n\t\t\t\t\t\t\t\t/* No, swap always and swap excl-usage also */\n\t\t\t\t\t\t\t\tisdn_net_swap_usage(idx, sidx);\n\t\t\t\t\t\t\t\tisdn_net_swapbind(di);\n\t\t\t\t\t\t\t\tswapped = 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/* Now check for exclusive binding again */\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\t\t\t\tprintk(KERN_DEBUG \"n_fi: final check\\n\");\n#endif\n\t\t\t\t\t\t\tif ((dev->usage[idx] & ISDN_USAGE_EXCLUSIVE) &&\n\t\t\t\t\t\t\t    ((lp->pre_channel != ch) ||\n\t\t\t\t\t\t\t     (lp->pre_device != di))) {\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\t\t\t\t\tprintk(KERN_DEBUG \"n_fi: final check failed\\n\");\n#endif\n\t\t\t\t\t\t\t\tp = (isdn_net_dev *) p->next;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* We are already on the second channel, so nothing to do */\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\t\t\tprintk(KERN_DEBUG \"n_fi: already on 2nd channel\\n\");\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\tprintk(KERN_DEBUG \"n_fi: match2\\n\");\n#endif\n\t\t\tn = lp->phone[0];\n\t\t\tif (lp->flags & ISDN_NET_SECURE) {\n\t\t\t\twhile (n) {\n\t\t\t\t\tif (!isdn_msncmp(nr, n->num))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tn = (isdn_net_phone *) n->next;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (n || (!(lp->flags & ISDN_NET_SECURE))) {\n#ifdef ISDN_DEBUG_NET_ICALL\n\t\t\t\tprintk(KERN_DEBUG \"n_fi: match3\\n\");\n#endif\n\t\t\t\t/* matching interface found */\n\n\t\t\t\t/*\n\t\t\t\t * Is the state STOPPED?\n\t\t\t\t * If so, no dialin is allowed,\n\t\t\t\t * so reject actively.\n\t\t\t\t * */\n\t\t\t\tif (ISDN_NET_DIALMODE(*lp) == ISDN_NET_DM_OFF) {\n\t\t\t\t\tprintk(KERN_INFO \"incoming call, interface %s `stopped' -> rejected\\n\",\n\t\t\t\t\t       p->dev->name);\n\t\t\t\t\treturn 3;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Is the interface up?\n\t\t\t\t * If not, reject the call actively.\n\t\t\t\t */\n\t\t\t\tif (!isdn_net_device_started(p)) {\n\t\t\t\t\tprintk(KERN_INFO \"%s: incoming call, interface down -> rejected\\n\",\n\t\t\t\t\t       p->dev->name);\n\t\t\t\t\treturn 3;\n\t\t\t\t}\n\t\t\t\t/* Interface is up, now see if it's a slave. If so, see if\n\t\t\t\t * it's master and parent slave is online. If not, reject the call.\n\t\t\t\t */\n\t\t\t\tif (lp->master) {\n\t\t\t\t\tisdn_net_local *mlp = ISDN_MASTER_PRIV(lp);\n\t\t\t\t\tprintk(KERN_DEBUG \"ICALLslv: %s\\n\", p->dev->name);\n\t\t\t\t\tprintk(KERN_DEBUG \"master=%s\\n\", lp->master->name);\n\t\t\t\t\tif (mlp->flags & ISDN_NET_CONNECTED) {\n\t\t\t\t\t\tprintk(KERN_DEBUG \"master online\\n\");\n\t\t\t\t\t\t/* Master is online, find parent-slave (master if first slave) */\n\t\t\t\t\t\twhile (mlp->slave) {\n\t\t\t\t\t\t\tif (ISDN_SLAVE_PRIV(mlp) == lp)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tmlp = ISDN_SLAVE_PRIV(mlp);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t\tprintk(KERN_DEBUG \"master offline\\n\");\n\t\t\t\t\t/* Found parent, if it's offline iterate next device */\n\t\t\t\t\tprintk(KERN_DEBUG \"mlpf: %d\\n\", mlp->flags & ISDN_NET_CONNECTED);\n\t\t\t\t\tif (!(mlp->flags & ISDN_NET_CONNECTED)) {\n\t\t\t\t\t\tp = (isdn_net_dev *) p->next;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t\tif (lp->flags & ISDN_NET_CALLBACK) {\n\t\t\t\t\tint chi;\n\t\t\t\t\t/*\n\t\t\t\t\t * Is the state MANUAL?\n\t\t\t\t\t * If so, no callback can be made,\n\t\t\t\t\t * so reject actively.\n\t\t\t\t\t * */\n\t\t\t\t\tif (ISDN_NET_DIALMODE(*lp) == ISDN_NET_DM_OFF) {\n\t\t\t\t\t\tprintk(KERN_INFO \"incoming call for callback, interface %s `off' -> rejected\\n\",\n\t\t\t\t\t\t       p->dev->name);\n\t\t\t\t\t\treturn 3;\n\t\t\t\t\t}\n\t\t\t\t\tprintk(KERN_DEBUG \"%s: call from %s -> %s, start callback\\n\",\n\t\t\t\t\t       p->dev->name, nr, eaz);\n\t\t\t\t\tif (lp->phone[1]) {\n\t\t\t\t\t\t/* Grab a free ISDN-Channel */\n\t\t\t\t\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\t\t\t\t\tif ((chi = \n\t\t\t\t\t\t\tisdn_get_free_channel(\n\t\t\t\t\t\t\t\tISDN_USAGE_NET,\n\t\t\t\t\t\t\t\tlp->l2_proto,\n\t\t\t\t\t\t\t\tlp->l3_proto,\n\t\t\t\t\t\t\t  \tlp->pre_device,\n\t\t\t\t\t\t \t\tlp->pre_channel,\n\t\t\t\t\t\t \t\tlp->msn)\n\t\t\t\t\t\t\t\t) < 0) {\n\n\t\t\t\t\t\t\tprintk(KERN_WARNING \"isdn_net_find_icall: No channel for %s\\n\",\n\t\t\t\t\t\t\t\tp->dev->name);\n\t\t\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* Setup dialstate. */\n\t\t\t\t\t\tlp->dtimer = 0;\n\t\t\t\t\t\tlp->dialstate = 11;\n\t\t\t\t\t\t/* Connect interface with channel */\n\t\t\t\t\t\tisdn_net_bind_channel(lp, chi);\n#ifdef CONFIG_ISDN_PPP\n\t\t\t\t\t\tif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP)\n\t\t\t\t\t\t\tif (isdn_ppp_bind(lp) < 0) {\n\t\t\t\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\t\t\t\tisdn_net_unbind_channel(lp);\n\t\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\t\t/* Initiate dialing by returning 2 or 4 */\n\t\t\t\t\t\treturn (lp->flags & ISDN_NET_CBHUP) ? 2 : 4;\n\t\t\t\t\t} else\n\t\t\t\t\t\tprintk(KERN_WARNING \"isdn_net: %s: No phone number\\n\",\n\t\t\t\t\t\t\tp->dev->name);\n\t\t\t\t\treturn 0;\n\t\t\t\t} else {\n\t\t\t\t\tprintk(KERN_DEBUG \"%s: call from %s -> %s accepted\\n\",\n\t\t\t\t\t\tp->dev->name, nr, eaz);\n\t\t\t\t\t/* if this interface is dialing, it does it probably on a different\n\t\t\t\t\t   device, so free this device */\n\t\t\t\t\tif ((lp->dialstate == 4) || (lp->dialstate == 12)) {\n#ifdef CONFIG_ISDN_PPP\n\t\t\t\t\t\tif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP)\n\t\t\t\t\t\t\tisdn_ppp_free(lp);\n#endif\n\t\t\t\t\t\tisdn_net_lp_disconnected(lp);\n\t\t\t\t\t\tisdn_free_channel(lp->isdn_device, lp->isdn_channel,\n\t\t\t\t\t\t\t ISDN_USAGE_NET);\n\t\t\t\t\t}\n\t\t\t\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\t\t\t\tdev->usage[idx] &= ISDN_USAGE_EXCLUSIVE;\n\t\t\t\t\tdev->usage[idx] |= ISDN_USAGE_NET;\n\t\t\t\t\tstrcpy(dev->num[idx], nr);\n\t\t\t\t\tisdn_info_update();\n\t\t\t\t\tdev->st_netdev[idx] = lp->netdev;\n\t\t\t\t\tlp->isdn_device = di;\n\t\t\t\t\tlp->isdn_channel = ch;\n\t\t\t\t\tlp->ppp_slot = -1;\n\t\t\t\t\tlp->flags |= ISDN_NET_CONNECTED;\n\t\t\t\t\tlp->dialstate = 7;\n\t\t\t\t\tlp->dtimer = 0;\n\t\t\t\t\tlp->outgoing = 0;\n\t\t\t\t\tlp->huptimer = 0;\n\t\t\t\t\tlp->hupflags |= ISDN_WAITCHARGE;\n\t\t\t\t\tlp->hupflags &= ~ISDN_HAVECHARGE;\n#ifdef CONFIG_ISDN_PPP\n\t\t\t\t\tif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP) {\n\t\t\t\t\t\tif (isdn_ppp_bind(lp) < 0) {\n\t\t\t\t\t\t\tisdn_net_unbind_channel(lp);\n\t\t\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n#endif\n\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tp = (isdn_net_dev *) p->next;\n\t}\n\t/* If none of configured EAZ/MSN matched and not verbose, be silent */\n\tif (!ematch || dev->net_verbose)\n\t\tprintk(KERN_INFO \"isdn_net: call from %s -> %d %s ignored\\n\", nr, di, eaz);\n\treturn (wret == 2)?5:0;\n}\n\n/*\n * Search list of net-interfaces for an interface with given name.\n */\nisdn_net_dev *\nisdn_net_findif(char *name)\n{\n\tisdn_net_dev *p = dev->netdev;\n\n\twhile (p) {\n\t\tif (!strcmp(p->dev->name, name))\n\t\t\treturn p;\n\t\tp = (isdn_net_dev *) p->next;\n\t}\n\treturn (isdn_net_dev *) NULL;\n}\n\n/*\n * Force a net-interface to dial out.\n * This is called from the userlevel-routine below or\n * from isdn_net_start_xmit().\n */\nstatic int\nisdn_net_force_dial_lp(isdn_net_local * lp)\n{\n\tif ((!(lp->flags & ISDN_NET_CONNECTED)) && !lp->dialstate) {\n\t\tint chi;\n\t\tif (lp->phone[1]) {\n\t\t\tulong flags;\n\n\t\t\t/* Grab a free ISDN-Channel */\n\t\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\t\tif ((chi = isdn_get_free_channel(\n\t\t\t\t\tISDN_USAGE_NET,\n\t\t\t\t\tlp->l2_proto,\n\t\t\t\t\tlp->l3_proto,\n\t\t\t\t\tlp->pre_device,\n\t\t\t\t\tlp->pre_channel,\n\t\t\t\t\tlp->msn)) < 0) {\n\t\t\t\tprintk(KERN_WARNING \"isdn_net_force_dial: No channel for %s\\n\",\n\t\t\t\t\tlp->netdev->dev->name);\n\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\treturn -EAGAIN;\n\t\t\t}\n\t\t\tlp->dialstate = 1;\n\t\t\t/* Connect interface with channel */\n\t\t\tisdn_net_bind_channel(lp, chi);\n#ifdef CONFIG_ISDN_PPP\n\t\t\tif (lp->p_encap == ISDN_NET_ENCAP_SYNCPPP)\n\t\t\t\tif (isdn_ppp_bind(lp) < 0) {\n\t\t\t\t\tisdn_net_unbind_channel(lp);\n\t\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\t\treturn -EAGAIN;\n\t\t\t\t}\n#endif\n\t\t\t/* Initiate dialing */\n\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\tisdn_net_dial();\n\t\t\treturn 0;\n\t\t} else\n\t\t\treturn -EINVAL;\n\t} else\n\t\treturn -EBUSY;\n}\n\n/*\n * This is called from certain upper protocol layers (multilink ppp\n * and x25iface encapsulation module) that want to initiate dialing\n * themselves.\n */\nint\nisdn_net_dial_req(isdn_net_local * lp)\n{\n\t/* is there a better error code? */\n\tif (!(ISDN_NET_DIALMODE(*lp) == ISDN_NET_DM_AUTO)) return -EBUSY;\n\n\treturn isdn_net_force_dial_lp(lp);\n}\n\n/*\n * Force a net-interface to dial out.\n * This is always called from within userspace (ISDN_IOCTL_NET_DIAL).\n */\nint\nisdn_net_force_dial(char *name)\n{\n\tisdn_net_dev *p = isdn_net_findif(name);\n\n\tif (!p)\n\t\treturn -ENODEV;\n\treturn (isdn_net_force_dial_lp(p->local));\n}\n\n/* The ISDN-specific entries in the device structure. */\nstatic const struct net_device_ops isdn_netdev_ops = {\n\t.ndo_init\t      = isdn_net_init,\n\t.ndo_open\t      = isdn_net_open,\n\t.ndo_stop\t      = isdn_net_close,\n\t.ndo_do_ioctl\t      = isdn_net_ioctl,\n\n\t.ndo_start_xmit\t      = isdn_net_start_xmit,\n\t.ndo_get_stats\t      = isdn_net_get_stats,\n\t.ndo_tx_timeout\t      = isdn_net_tx_timeout,\n};\n\n/*\n * Helper for alloc_netdev()\n */\nstatic void _isdn_setup(struct net_device *dev)\n{\n\tisdn_net_local *lp = netdev_priv(dev);\n\n\tether_setup(dev);\n\n\t/* Setup the generic properties */\n\tdev->flags = IFF_NOARP|IFF_POINTOPOINT;\n\n\t/* isdn prepends a header in the tx path, can't share skbs */\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tdev->header_ops = NULL;\n\tdev->netdev_ops = &isdn_netdev_ops;\n\n\t/* for clients with MPPP maybe higher values better */\n\tdev->tx_queue_len = 30;\n\n\tlp->p_encap = ISDN_NET_ENCAP_RAWIP;\n\tlp->magic = ISDN_NET_MAGIC;\n\tlp->last = lp;\n\tlp->next = lp;\n\tlp->isdn_device = -1;\n\tlp->isdn_channel = -1;\n\tlp->pre_device = -1;\n\tlp->pre_channel = -1;\n\tlp->exclusive = -1;\n\tlp->ppp_slot = -1;\n\tlp->pppbind = -1;\n\tskb_queue_head_init(&lp->super_tx_queue);\n\tlp->l2_proto = ISDN_PROTO_L2_X75I;\n\tlp->l3_proto = ISDN_PROTO_L3_TRANS;\n\tlp->triggercps = 6000;\n\tlp->slavedelay = 10 * HZ;\n\tlp->hupflags = ISDN_INHUP;\t/* Do hangup even on incoming calls */\n\tlp->onhtime = 10;\t/* Default hangup-time for saving costs */\n\tlp->dialmax = 1;\n\t/* Hangup before Callback, manual dial */\n\tlp->flags = ISDN_NET_CBHUP | ISDN_NET_DM_MANUAL;\n\tlp->cbdelay = 25;\t/* Wait 5 secs before Callback */\n\tlp->dialtimeout = -1;  /* Infinite Dial-Timeout */\n\tlp->dialwait = 5 * HZ; /* Wait 5 sec. after failed dial */\n\tlp->dialstarted = 0;   /* Jiffies of last dial-start */\n\tlp->dialwait_timer = 0;  /* Jiffies of earliest next dial-start */\n}\n\n/*\n * Allocate a new network-interface and initialize its data structures.\n */\nchar *\nisdn_net_new(char *name, struct net_device *master)\n{\n\tisdn_net_dev *netdev;\n\n\t/* Avoid creating an existing interface */\n\tif (isdn_net_findif(name)) {\n\t\tprintk(KERN_WARNING \"isdn_net: interface %s already exists\\n\", name);\n\t\treturn NULL;\n\t}\n\tif (name == NULL)\n\t\treturn NULL;\n\tif (!(netdev = kzalloc(sizeof(isdn_net_dev), GFP_KERNEL))) {\n\t\tprintk(KERN_WARNING \"isdn_net: Could not allocate net-device\\n\");\n\t\treturn NULL;\n\t}\n\tnetdev->dev = alloc_netdev(sizeof(isdn_net_local), name, _isdn_setup);\n\tif (!netdev->dev) {\n\t\tprintk(KERN_WARNING \"isdn_net: Could not allocate network device\\n\");\n\t\tkfree(netdev);\n\t\treturn NULL;\n\t}\n\tnetdev->local = netdev_priv(netdev->dev);\n\n\tif (master) {\n\t\t/* Device shall be a slave */\n\t\tstruct net_device *p = MASTER_TO_SLAVE(master);\n\t\tstruct net_device *q = master;\n\n\t\tnetdev->local->master = master;\n\t\t/* Put device at end of slave-chain */\n\t\twhile (p) {\n\t\t\tq = p;\n\t\t\tp = MASTER_TO_SLAVE(p);\n\t\t}\n\t\tMASTER_TO_SLAVE(q) = netdev->dev;\n\t} else {\n\t\t/* Device shall be a master */\n\t\t/*\n\t\t * Watchdog timer (currently) for master only.\n\t\t */\n\t\tnetdev->dev->watchdog_timeo = ISDN_NET_TX_TIMEOUT;\n\t\tif (register_netdev(netdev->dev) != 0) {\n\t\t\tprintk(KERN_WARNING \"isdn_net: Could not register net-device\\n\");\n\t\t\tfree_netdev(netdev->dev);\n\t\t\tkfree(netdev);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tnetdev->queue = netdev->local;\n\tspin_lock_init(&netdev->queue_lock);\n\n\tnetdev->local->netdev = netdev;\n\n\tINIT_WORK(&netdev->local->tqueue, isdn_net_softint);\n\tspin_lock_init(&netdev->local->xmit_lock);\n\n\t/* Put into to netdev-chain */\n\tnetdev->next = (void *) dev->netdev;\n\tdev->netdev = netdev;\n\treturn netdev->dev->name;\n}\n\nchar *\nisdn_net_newslave(char *parm)\n{\n\tchar *p = strchr(parm, ',');\n\tisdn_net_dev *n;\n\tchar newname[10];\n\n\tif (p) {\n\t\t/* Slave-Name MUST not be empty */\n\t\tif (!strlen(p + 1))\n\t\t\treturn NULL;\n\t\tstrcpy(newname, p + 1);\n\t\t*p = 0;\n\t\t/* Master must already exist */\n\t\tif (!(n = isdn_net_findif(parm)))\n\t\t\treturn NULL;\n\t\t/* Master must be a real interface, not a slave */\n\t\tif (n->local->master)\n\t\t\treturn NULL;\n\t\t/* Master must not be started yet */\n\t\tif (isdn_net_device_started(n)) \n\t\t\treturn NULL;\n\t\treturn (isdn_net_new(newname, n->dev));\n\t}\n\treturn NULL;\n}\n\n/*\n * Set interface-parameters.\n * Always set all parameters, so the user-level application is responsible\n * for not overwriting existing setups. It has to get the current\n * setup first, if only selected parameters are to be changed.\n */\nint\nisdn_net_setcfg(isdn_net_ioctl_cfg * cfg)\n{\n\tisdn_net_dev *p = isdn_net_findif(cfg->name);\n\tulong features;\n\tint i;\n\tint drvidx;\n\tint chidx;\n\tchar drvid[25];\n\n\tif (p) {\n\t\tisdn_net_local *lp = p->local;\n\n\t\t/* See if any registered driver supports the features we want */\n\t\tfeatures = ((1 << cfg->l2_proto) << ISDN_FEATURE_L2_SHIFT) |\n\t\t\t((1 << cfg->l3_proto) << ISDN_FEATURE_L3_SHIFT);\n\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\tif (dev->drv[i])\n\t\t\t\tif ((dev->drv[i]->interface->features & features) == features)\n\t\t\t\t\tbreak;\n\t\tif (i == ISDN_MAX_DRIVERS) {\n\t\t\tprintk(KERN_WARNING \"isdn_net: No driver with selected features\\n\");\n\t\t\treturn -ENODEV;\n\t\t}\n\t\tif (lp->p_encap != cfg->p_encap){\n#ifdef CONFIG_ISDN_X25\n\t\t\tstruct concap_proto * cprot = p -> cprot;\n#endif\n\t\t\tif (isdn_net_device_started(p)) {\n\t\t\t\tprintk(KERN_WARNING \"%s: cannot change encap when if is up\\n\",\n\t\t\t\t       p->dev->name);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n#ifdef CONFIG_ISDN_X25\n\t\t\tif( cprot && cprot -> pops )\n\t\t\t\tcprot -> pops -> proto_del ( cprot );\n\t\t\tp -> cprot = NULL;\n\t\t\tlp -> dops = NULL;\n\t\t\t/* ... ,  prepare for configuration of new one ... */\n\t\t\tswitch ( cfg -> p_encap ){\n\t\t\tcase ISDN_NET_ENCAP_X25IFACE:\n\t\t\t\tlp -> dops = &isdn_concap_reliable_dl_dops;\n\t\t\t}\n\t\t\t/* ... and allocate new one ... */\n\t\t\tp -> cprot = isdn_concap_new( cfg -> p_encap );\n\t\t\t/* p -> cprot == NULL now if p_encap is not supported\n\t\t\t   by means of the concap_proto mechanism */\n\t\t\t/* the protocol is not configured yet; this will\n\t\t\t   happen later when isdn_net_reset() is called */\n#endif\n\t\t}\n\t\tswitch ( cfg->p_encap ) {\n\t\tcase ISDN_NET_ENCAP_SYNCPPP:\n#ifndef CONFIG_ISDN_PPP\n\t\t\tprintk(KERN_WARNING \"%s: SyncPPP support not configured\\n\",\n\t\t\t       p->dev->name);\n\t\t\treturn -EINVAL;\n#else\n\t\t\tp->dev->type = ARPHRD_PPP;\t/* change ARP type */\n\t\t\tp->dev->addr_len = 0;\n#endif\n\t\t\tbreak;\n\t\tcase ISDN_NET_ENCAP_X25IFACE:\n#ifndef CONFIG_ISDN_X25\n\t\t\tprintk(KERN_WARNING \"%s: isdn-x25 support not configured\\n\",\n\t\t\t       p->dev->name);\n\t\t\treturn -EINVAL;\n#else\n\t\t\tp->dev->type = ARPHRD_X25;\t/* change ARP type */\n\t\t\tp->dev->addr_len = 0;\n#endif\n\t\t\tbreak;\n\t\tcase ISDN_NET_ENCAP_CISCOHDLCK:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif( cfg->p_encap >= 0 &&\n\t\t\t    cfg->p_encap <= ISDN_NET_ENCAP_MAX_ENCAP )\n\t\t\t\tbreak;\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"%s: encapsulation protocol %d not supported\\n\",\n\t\t\t       p->dev->name, cfg->p_encap);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (strlen(cfg->drvid)) {\n\t\t\t/* A bind has been requested ... */\n\t\t\tchar *c,\n\t\t\t*e;\n\n\t\t\tdrvidx = -1;\n\t\t\tchidx = -1;\n\t\t\tstrcpy(drvid, cfg->drvid);\n\t\t\tif ((c = strchr(drvid, ','))) {\n\t\t\t\t/* The channel-number is appended to the driver-Id with a comma */\n\t\t\t\tchidx = (int) simple_strtoul(c + 1, &e, 10);\n\t\t\t\tif (e == c)\n\t\t\t\t\tchidx = -1;\n\t\t\t\t*c = '\\0';\n\t\t\t}\n\t\t\tfor (i = 0; i < ISDN_MAX_DRIVERS; i++)\n\t\t\t\t/* Lookup driver-Id in array */\n\t\t\t\tif (!(strcmp(dev->drvid[i], drvid))) {\n\t\t\t\t\tdrvidx = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif ((drvidx == -1) || (chidx == -1))\n\t\t\t\t/* Either driver-Id or channel-number invalid */\n\t\t\t\treturn -ENODEV;\n\t\t} else {\n\t\t\t/* Parameters are valid, so get them */\n\t\t\tdrvidx = lp->pre_device;\n\t\t\tchidx = lp->pre_channel;\n\t\t}\n\t\tif (cfg->exclusive > 0) {\n\t\t\tunsigned long flags;\n\n\t\t\t/* If binding is exclusive, try to grab the channel */\n\t\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\t\tif ((i = isdn_get_free_channel(ISDN_USAGE_NET,\n\t\t\t\tlp->l2_proto, lp->l3_proto, drvidx,\n\t\t\t\tchidx, lp->msn)) < 0) {\n\t\t\t\t/* Grab failed, because desired channel is in use */\n\t\t\t\tlp->exclusive = -1;\n\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\treturn -EBUSY;\n\t\t\t}\n\t\t\t/* All went ok, so update isdninfo */\n\t\t\tdev->usage[i] = ISDN_USAGE_EXCLUSIVE;\n\t\t\tisdn_info_update();\n\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\tlp->exclusive = i;\n\t\t} else {\n\t\t\t/* Non-exclusive binding or unbind. */\n\t\t\tlp->exclusive = -1;\n\t\t\tif ((lp->pre_device != -1) && (cfg->exclusive == -1)) {\n\t\t\t\tisdn_unexclusive_channel(lp->pre_device, lp->pre_channel);\n\t\t\t\tisdn_free_channel(lp->pre_device, lp->pre_channel, ISDN_USAGE_NET);\n\t\t\t\tdrvidx = -1;\n\t\t\t\tchidx = -1;\n\t\t\t}\n\t\t}\n\t\tstrlcpy(lp->msn, cfg->eaz, sizeof(lp->msn));\n\t\tlp->pre_device = drvidx;\n\t\tlp->pre_channel = chidx;\n\t\tlp->onhtime = cfg->onhtime;\n\t\tlp->charge = cfg->charge;\n\t\tlp->l2_proto = cfg->l2_proto;\n\t\tlp->l3_proto = cfg->l3_proto;\n\t\tlp->cbdelay = cfg->cbdelay;\n\t\tlp->dialmax = cfg->dialmax;\n\t\tlp->triggercps = cfg->triggercps;\n\t\tlp->slavedelay = cfg->slavedelay * HZ;\n\t\tlp->pppbind = cfg->pppbind;\n\t\tlp->dialtimeout = cfg->dialtimeout >= 0 ? cfg->dialtimeout * HZ : -1;\n\t\tlp->dialwait = cfg->dialwait * HZ;\n\t\tif (cfg->secure)\n\t\t\tlp->flags |= ISDN_NET_SECURE;\n\t\telse\n\t\t\tlp->flags &= ~ISDN_NET_SECURE;\n\t\tif (cfg->cbhup)\n\t\t\tlp->flags |= ISDN_NET_CBHUP;\n\t\telse\n\t\t\tlp->flags &= ~ISDN_NET_CBHUP;\n\t\tswitch (cfg->callback) {\n\t\t\tcase 0:\n\t\t\t\tlp->flags &= ~(ISDN_NET_CALLBACK | ISDN_NET_CBOUT);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tlp->flags |= ISDN_NET_CALLBACK;\n\t\t\t\tlp->flags &= ~ISDN_NET_CBOUT;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tlp->flags |= ISDN_NET_CBOUT;\n\t\t\t\tlp->flags &= ~ISDN_NET_CALLBACK;\n\t\t\t\tbreak;\n\t\t}\n\t\tlp->flags &= ~ISDN_NET_DIALMODE_MASK;\t/* first all bits off */\n\t\tif (cfg->dialmode && !(cfg->dialmode & ISDN_NET_DIALMODE_MASK)) {\n\t\t\t/* old isdnctrl version, where only 0 or 1 is given */\n\t\t\tprintk(KERN_WARNING\n\t\t\t     \"Old isdnctrl version detected! Please update.\\n\");\n\t\t\tlp->flags |= ISDN_NET_DM_OFF; /* turn on `off' bit */\n\t\t}\n\t\telse {\n\t\t\tlp->flags |= cfg->dialmode;  /* turn on selected bits */\n\t\t}\n\t\tif (cfg->chargehup)\n\t\t\tlp->hupflags |= ISDN_CHARGEHUP;\n\t\telse\n\t\t\tlp->hupflags &= ~ISDN_CHARGEHUP;\n\t\tif (cfg->ihup)\n\t\t\tlp->hupflags |= ISDN_INHUP;\n\t\telse\n\t\t\tlp->hupflags &= ~ISDN_INHUP;\n\t\tif (cfg->chargeint > 10) {\n\t\t\tlp->hupflags |= ISDN_CHARGEHUP | ISDN_HAVECHARGE | ISDN_MANCHARGE;\n\t\t\tlp->chargeint = cfg->chargeint * HZ;\n\t\t}\n\t\tif (cfg->p_encap != lp->p_encap) {\n\t\t\tif (cfg->p_encap == ISDN_NET_ENCAP_RAWIP) {\n\t\t\t\tp->dev->header_ops = NULL;\n\t\t\t\tp->dev->flags = IFF_NOARP|IFF_POINTOPOINT;\n\t\t\t} else {\n\t\t\t\tp->dev->header_ops = &isdn_header_ops;\n\t\t\t\tif (cfg->p_encap == ISDN_NET_ENCAP_ETHER)\n\t\t\t\t\tp->dev->flags = IFF_BROADCAST | IFF_MULTICAST;\n\t\t\t\telse\n\t\t\t\t\tp->dev->flags = IFF_NOARP|IFF_POINTOPOINT;\n\t\t\t}\n\t\t}\n\t\tlp->p_encap = cfg->p_encap;\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}\n\n/*\n * Perform get-interface-parameters.ioctl\n */\nint\nisdn_net_getcfg(isdn_net_ioctl_cfg * cfg)\n{\n\tisdn_net_dev *p = isdn_net_findif(cfg->name);\n\n\tif (p) {\n\t\tisdn_net_local *lp = p->local;\n\n\t\tstrcpy(cfg->eaz, lp->msn);\n\t\tcfg->exclusive = lp->exclusive;\n\t\tif (lp->pre_device >= 0) {\n\t\t\tsprintf(cfg->drvid, \"%s,%d\", dev->drvid[lp->pre_device],\n\t\t\t\tlp->pre_channel);\n\t\t} else\n\t\t\tcfg->drvid[0] = '\\0';\n\t\tcfg->onhtime = lp->onhtime;\n\t\tcfg->charge = lp->charge;\n\t\tcfg->l2_proto = lp->l2_proto;\n\t\tcfg->l3_proto = lp->l3_proto;\n\t\tcfg->p_encap = lp->p_encap;\n\t\tcfg->secure = (lp->flags & ISDN_NET_SECURE) ? 1 : 0;\n\t\tcfg->callback = 0;\n\t\tif (lp->flags & ISDN_NET_CALLBACK)\n\t\t\tcfg->callback = 1;\n\t\tif (lp->flags & ISDN_NET_CBOUT)\n\t\t\tcfg->callback = 2;\n\t\tcfg->cbhup = (lp->flags & ISDN_NET_CBHUP) ? 1 : 0;\n\t\tcfg->dialmode = lp->flags & ISDN_NET_DIALMODE_MASK;\n\t\tcfg->chargehup = (lp->hupflags & 4) ? 1 : 0;\n\t\tcfg->ihup = (lp->hupflags & 8) ? 1 : 0;\n\t\tcfg->cbdelay = lp->cbdelay;\n\t\tcfg->dialmax = lp->dialmax;\n\t\tcfg->triggercps = lp->triggercps;\n\t\tcfg->slavedelay = lp->slavedelay / HZ;\n\t\tcfg->chargeint = (lp->hupflags & ISDN_CHARGEHUP) ?\n\t\t    (lp->chargeint / HZ) : 0;\n\t\tcfg->pppbind = lp->pppbind;\n\t\tcfg->dialtimeout = lp->dialtimeout >= 0 ? lp->dialtimeout / HZ : -1;\n\t\tcfg->dialwait = lp->dialwait / HZ;\n\t\tif (lp->slave) {\n\t\t\tif (strlen(lp->slave->name) >= 10)\n\t\t\t\tstrcpy(cfg->slave, \"too-long\");\n\t\t\telse\n\t\t\t\tstrcpy(cfg->slave, lp->slave->name);\n\t\t} else\n\t\t\tcfg->slave[0] = '\\0';\n\t\tif (lp->master) {\n\t\t\tif (strlen(lp->master->name) >= 10)\n\t\t\t\tstrcpy(cfg->master, \"too-long\");\n\t\t\telse\n\t\t\t\tstrcpy(cfg->master, lp->master->name);\n\t\t} else\n\t\t\tcfg->master[0] = '\\0';\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}\n\n/*\n * Add a phone-number to an interface.\n */\nint\nisdn_net_addphone(isdn_net_ioctl_phone * phone)\n{\n\tisdn_net_dev *p = isdn_net_findif(phone->name);\n\tisdn_net_phone *n;\n\n\tif (p) {\n\t\tif (!(n = kmalloc(sizeof(isdn_net_phone), GFP_KERNEL)))\n\t\t\treturn -ENOMEM;\n\t\tstrlcpy(n->num, phone->phone, sizeof(n->num));\n\t\tn->next = p->local->phone[phone->outgoing & 1];\n\t\tp->local->phone[phone->outgoing & 1] = n;\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}\n\n/*\n * Copy a string of all phone-numbers of an interface to user space.\n * This might sleep and must be called with the isdn semaphore down.\n */\nint\nisdn_net_getphones(isdn_net_ioctl_phone * phone, char __user *phones)\n{\n\tisdn_net_dev *p = isdn_net_findif(phone->name);\n\tint inout = phone->outgoing & 1;\n\tint more = 0;\n\tint count = 0;\n\tisdn_net_phone *n;\n\n\tif (!p)\n\t\treturn -ENODEV;\n\tinout &= 1;\n\tfor (n = p->local->phone[inout]; n; n = n->next) {\n\t\tif (more) {\n\t\t\tput_user(' ', phones++);\n\t\t\tcount++;\n\t\t}\n\t\tif (copy_to_user(phones, n->num, strlen(n->num) + 1)) {\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tphones += strlen(n->num);\n\t\tcount += strlen(n->num);\n\t\tmore = 1;\n\t}\n\tput_user(0, phones);\n\tcount++;\n\treturn count;\n}\n\n/*\n * Copy a string containing the peer's phone number of a connected interface\n * to user space.\n */\nint\nisdn_net_getpeer(isdn_net_ioctl_phone *phone, isdn_net_ioctl_phone __user *peer)\n{\n\tisdn_net_dev *p = isdn_net_findif(phone->name);\n\tint ch, dv, idx;\n\n\tif (!p)\n\t\treturn -ENODEV;\n\t/*\n\t * Theoretical race: while this executes, the remote number might\n\t * become invalid (hang up) or change (new connection), resulting\n         * in (partially) wrong number copied to user. This race\n\t * currently ignored.\n\t */\n\tch = p->local->isdn_channel;\n\tdv = p->local->isdn_device;\n\tif(ch < 0 && dv < 0)\n\t\treturn -ENOTCONN;\n\tidx = isdn_dc2minor(dv, ch);\n\tif (idx <0 )\n\t\treturn -ENODEV;\n\t/* for pre-bound channels, we need this extra check */\n\tif (strncmp(dev->num[idx], \"???\", 3) == 0)\n\t\treturn -ENOTCONN;\n\tstrncpy(phone->phone, dev->num[idx], ISDN_MSNLEN);\n\tphone->outgoing = USG_OUTGOING(dev->usage[idx]);\n\tif (copy_to_user(peer, phone, sizeof(*peer)))\n\t\treturn -EFAULT;\n\treturn 0;\n}\n/*\n * Delete a phone-number from an interface.\n */\nint\nisdn_net_delphone(isdn_net_ioctl_phone * phone)\n{\n\tisdn_net_dev *p = isdn_net_findif(phone->name);\n\tint inout = phone->outgoing & 1;\n\tisdn_net_phone *n;\n\tisdn_net_phone *m;\n\n\tif (p) {\n\t\tn = p->local->phone[inout];\n\t\tm = NULL;\n\t\twhile (n) {\n\t\t\tif (!strcmp(n->num, phone->phone)) {\n\t\t\t\tif (p->local->dial == n)\n\t\t\t\t\tp->local->dial = n->next;\n\t\t\t\tif (m)\n\t\t\t\t\tm->next = n->next;\n\t\t\t\telse\n\t\t\t\t\tp->local->phone[inout] = n->next;\n\t\t\t\tkfree(n);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tm = n;\n\t\t\tn = (isdn_net_phone *) n->next;\n\t\t}\n\t\treturn -EINVAL;\n\t}\n\treturn -ENODEV;\n}\n\n/*\n * Delete all phone-numbers of an interface.\n */\nstatic int\nisdn_net_rmallphone(isdn_net_dev * p)\n{\n\tisdn_net_phone *n;\n\tisdn_net_phone *m;\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tn = p->local->phone[i];\n\t\twhile (n) {\n\t\t\tm = n->next;\n\t\t\tkfree(n);\n\t\t\tn = m;\n\t\t}\n\t\tp->local->phone[i] = NULL;\n\t}\n\tp->local->dial = NULL;\n\treturn 0;\n}\n\n/*\n * Force a hangup of a network-interface.\n */\nint\nisdn_net_force_hangup(char *name)\n{\n\tisdn_net_dev *p = isdn_net_findif(name);\n\tstruct net_device *q;\n\n\tif (p) {\n\t\tif (p->local->isdn_device < 0)\n\t\t\treturn 1;\n\t\tq = p->local->slave;\n\t\t/* If this interface has slaves, do a hangup for them also. */\n\t\twhile (q) {\n\t\t\tisdn_net_hangup(q);\n\t\t\tq = MASTER_TO_SLAVE(q);\n\t\t}\n\t\tisdn_net_hangup(p->dev);\n\t\treturn 0;\n\t}\n\treturn -ENODEV;\n}\n\n/*\n * Helper-function for isdn_net_rm: Do the real work.\n */\nstatic int\nisdn_net_realrm(isdn_net_dev * p, isdn_net_dev * q)\n{\n\tu_long flags;\n\n\tif (isdn_net_device_started(p)) {\n\t\treturn -EBUSY;\n\t}\n#ifdef CONFIG_ISDN_X25\n\tif( p -> cprot && p -> cprot -> pops )\n\t\tp -> cprot -> pops -> proto_del ( p -> cprot );\n#endif\n\t/* Free all phone-entries */\n\tisdn_net_rmallphone(p);\n\t/* If interface is bound exclusive, free channel-usage */\n\tif (p->local->exclusive != -1)\n\t\tisdn_unexclusive_channel(p->local->pre_device, p->local->pre_channel);\n\tif (p->local->master) {\n\t\t/* It's a slave-device, so update master's slave-pointer if necessary */\n\t\tif (((isdn_net_local *) ISDN_MASTER_PRIV(p->local))->slave ==\n\t\t    p->dev)\n\t\t\t((isdn_net_local *)ISDN_MASTER_PRIV(p->local))->slave =\n\t\t\t\tp->local->slave;\n\t} else {\n\t\t/* Unregister only if it's a master-device */\n\t\tunregister_netdev(p->dev);\n\t}\n\t/* Unlink device from chain */\n\tspin_lock_irqsave(&dev->lock, flags);\n\tif (q)\n\t\tq->next = p->next;\n\telse\n\t\tdev->netdev = p->next;\n\tif (p->local->slave) {\n\t\t/* If this interface has a slave, remove it also */\n\t\tchar *slavename = p->local->slave->name;\n\t\tisdn_net_dev *n = dev->netdev;\n\t\tq = NULL;\n\t\twhile (n) {\n\t\t\tif (!strcmp(n->dev->name, slavename)) {\n\t\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\t\tisdn_net_realrm(n, q);\n\t\t\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tq = n;\n\t\t\tn = (isdn_net_dev *)n->next;\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\t/* If no more net-devices remain, disable auto-hangup timer */\n\tif (dev->netdev == NULL)\n\t\tisdn_timer_ctrl(ISDN_TIMER_NETHANGUP, 0);\n\tfree_netdev(p->dev);\n\tkfree(p);\n\n\treturn 0;\n}\n\n/*\n * Remove a single network-interface.\n */\nint\nisdn_net_rm(char *name)\n{\n\tu_long flags;\n\tisdn_net_dev *p;\n\tisdn_net_dev *q;\n\n\t/* Search name in netdev-chain */\n\tspin_lock_irqsave(&dev->lock, flags);\n\tp = dev->netdev;\n\tq = NULL;\n\twhile (p) {\n\t\tif (!strcmp(p->dev->name, name)) {\n\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\treturn (isdn_net_realrm(p, q));\n\t\t}\n\t\tq = p;\n\t\tp = (isdn_net_dev *) p->next;\n\t}\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\t/* If no more net-devices remain, disable auto-hangup timer */\n\tif (dev->netdev == NULL)\n\t\tisdn_timer_ctrl(ISDN_TIMER_NETHANGUP, 0);\n\treturn -ENODEV;\n}\n\n/*\n * Remove all network-interfaces\n */\nint\nisdn_net_rmall(void)\n{\n\tu_long flags;\n\tint ret;\n\n\t/* Walk through netdev-chain */\n\tspin_lock_irqsave(&dev->lock, flags);\n\twhile (dev->netdev) {\n\t\tif (!dev->netdev->local->master) {\n\t\t\t/* Remove master-devices only, slaves get removed with their master */\n\t\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\t\t\tif ((ret = isdn_net_realrm(dev->netdev, NULL))) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tspin_lock_irqsave(&dev->lock, flags);\n\t\t}\n\t}\n\tdev->netdev = NULL;\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\treturn 0;\n}\n", "/*\n * originally based on the dummy device.\n *\n * Copyright 1999, Thomas Davis, tadavis@lbl.gov.\n * Licensed under the GPL. Based on dummy.c, and eql.c devices.\n *\n * bonding.c: an Ethernet Bonding driver\n *\n * This is useful to talk to a Cisco EtherChannel compatible equipment:\n *\tCisco 5500\n *\tSun Trunking (Solaris)\n *\tAlteon AceDirector Trunks\n *\tLinux Bonding\n *\tand probably many L2 switches ...\n *\n * How it works:\n *    ifconfig bond0 ipaddress netmask up\n *      will setup a network device, with an ip address.  No mac address\n *\twill be assigned at this time.  The hw mac address will come from\n *\tthe first slave bonded to the channel.  All slaves will then use\n *\tthis hw mac address.\n *\n *    ifconfig bond0 down\n *         will release all slaves, marking them as down.\n *\n *    ifenslave bond0 eth0\n *\twill attach eth0 to bond0 as a slave.  eth0 hw mac address will either\n *\ta: be used as initial mac address\n *\tb: if a hw mac address already is there, eth0's hw mac address\n *\t   will then be set from bond0.\n *\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/fcntl.h>\n#include <linux/interrupt.h>\n#include <linux/ptrace.h>\n#include <linux/ioport.h>\n#include <linux/in.h>\n#include <net/ip.h>\n#include <linux/ip.h>\n#include <linux/tcp.h>\n#include <linux/udp.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/init.h>\n#include <linux/timer.h>\n#include <linux/socket.h>\n#include <linux/ctype.h>\n#include <linux/inet.h>\n#include <linux/bitops.h>\n#include <linux/io.h>\n#include <asm/system.h>\n#include <asm/dma.h>\n#include <linux/uaccess.h>\n#include <linux/errno.h>\n#include <linux/netdevice.h>\n#include <linux/inetdevice.h>\n#include <linux/igmp.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <net/sock.h>\n#include <linux/rtnetlink.h>\n#include <linux/smp.h>\n#include <linux/if_ether.h>\n#include <net/arp.h>\n#include <linux/mii.h>\n#include <linux/ethtool.h>\n#include <linux/if_vlan.h>\n#include <linux/if_bonding.h>\n#include <linux/jiffies.h>\n#include <linux/preempt.h>\n#include <net/route.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include \"bonding.h\"\n#include \"bond_3ad.h\"\n#include \"bond_alb.h\"\n\n/*---------------------------- Module parameters ----------------------------*/\n\n/* monitor all links that often (in milliseconds). <=0 disables monitoring */\n#define BOND_LINK_MON_INTERV\t0\n#define BOND_LINK_ARP_INTERV\t0\n\nstatic int max_bonds\t= BOND_DEFAULT_MAX_BONDS;\nstatic int tx_queues\t= BOND_DEFAULT_TX_QUEUES;\nstatic int num_peer_notif = 1;\nstatic int miimon\t= BOND_LINK_MON_INTERV;\nstatic int updelay;\nstatic int downdelay;\nstatic int use_carrier\t= 1;\nstatic char *mode;\nstatic char *primary;\nstatic char *primary_reselect;\nstatic char *lacp_rate;\nstatic int min_links;\nstatic char *ad_select;\nstatic char *xmit_hash_policy;\nstatic int arp_interval = BOND_LINK_ARP_INTERV;\nstatic char *arp_ip_target[BOND_MAX_ARP_TARGETS];\nstatic char *arp_validate;\nstatic char *fail_over_mac;\nstatic int all_slaves_active = 0;\nstatic struct bond_params bonding_defaults;\nstatic int resend_igmp = BOND_DEFAULT_RESEND_IGMP;\n\nmodule_param(max_bonds, int, 0);\nMODULE_PARM_DESC(max_bonds, \"Max number of bonded devices\");\nmodule_param(tx_queues, int, 0);\nMODULE_PARM_DESC(tx_queues, \"Max number of transmit queues (default = 16)\");\nmodule_param_named(num_grat_arp, num_peer_notif, int, 0644);\nMODULE_PARM_DESC(num_grat_arp, \"Number of peer notifications to send on \"\n\t\t\t       \"failover event (alias of num_unsol_na)\");\nmodule_param_named(num_unsol_na, num_peer_notif, int, 0644);\nMODULE_PARM_DESC(num_unsol_na, \"Number of peer notifications to send on \"\n\t\t\t       \"failover event (alias of num_grat_arp)\");\nmodule_param(miimon, int, 0);\nMODULE_PARM_DESC(miimon, \"Link check interval in milliseconds\");\nmodule_param(updelay, int, 0);\nMODULE_PARM_DESC(updelay, \"Delay before considering link up, in milliseconds\");\nmodule_param(downdelay, int, 0);\nMODULE_PARM_DESC(downdelay, \"Delay before considering link down, \"\n\t\t\t    \"in milliseconds\");\nmodule_param(use_carrier, int, 0);\nMODULE_PARM_DESC(use_carrier, \"Use netif_carrier_ok (vs MII ioctls) in miimon; \"\n\t\t\t      \"0 for off, 1 for on (default)\");\nmodule_param(mode, charp, 0);\nMODULE_PARM_DESC(mode, \"Mode of operation; 0 for balance-rr, \"\n\t\t       \"1 for active-backup, 2 for balance-xor, \"\n\t\t       \"3 for broadcast, 4 for 802.3ad, 5 for balance-tlb, \"\n\t\t       \"6 for balance-alb\");\nmodule_param(primary, charp, 0);\nMODULE_PARM_DESC(primary, \"Primary network device to use\");\nmodule_param(primary_reselect, charp, 0);\nMODULE_PARM_DESC(primary_reselect, \"Reselect primary slave \"\n\t\t\t\t   \"once it comes up; \"\n\t\t\t\t   \"0 for always (default), \"\n\t\t\t\t   \"1 for only if speed of primary is \"\n\t\t\t\t   \"better, \"\n\t\t\t\t   \"2 for only on active slave \"\n\t\t\t\t   \"failure\");\nmodule_param(lacp_rate, charp, 0);\nMODULE_PARM_DESC(lacp_rate, \"LACPDU tx rate to request from 802.3ad partner; \"\n\t\t\t    \"0 for slow, 1 for fast\");\nmodule_param(ad_select, charp, 0);\nMODULE_PARM_DESC(ad_select, \"803.ad aggregation selection logic; \"\n\t\t\t    \"0 for stable (default), 1 for bandwidth, \"\n\t\t\t    \"2 for count\");\nmodule_param(min_links, int, 0);\nMODULE_PARM_DESC(min_links, \"Minimum number of available links before turning on carrier\");\n\nmodule_param(xmit_hash_policy, charp, 0);\nMODULE_PARM_DESC(xmit_hash_policy, \"balance-xor and 802.3ad hashing method; \"\n\t\t\t\t   \"0 for layer 2 (default), 1 for layer 3+4, \"\n\t\t\t\t   \"2 for layer 2+3\");\nmodule_param(arp_interval, int, 0);\nMODULE_PARM_DESC(arp_interval, \"arp interval in milliseconds\");\nmodule_param_array(arp_ip_target, charp, NULL, 0);\nMODULE_PARM_DESC(arp_ip_target, \"arp targets in n.n.n.n form\");\nmodule_param(arp_validate, charp, 0);\nMODULE_PARM_DESC(arp_validate, \"validate src/dst of ARP probes; \"\n\t\t\t       \"0 for none (default), 1 for active, \"\n\t\t\t       \"2 for backup, 3 for all\");\nmodule_param(fail_over_mac, charp, 0);\nMODULE_PARM_DESC(fail_over_mac, \"For active-backup, do not set all slaves to \"\n\t\t\t\t\"the same MAC; 0 for none (default), \"\n\t\t\t\t\"1 for active, 2 for follow\");\nmodule_param(all_slaves_active, int, 0);\nMODULE_PARM_DESC(all_slaves_active, \"Keep all frames received on an interface\"\n\t\t\t\t     \"by setting active flag for all slaves; \"\n\t\t\t\t     \"0 for never (default), 1 for always.\");\nmodule_param(resend_igmp, int, 0);\nMODULE_PARM_DESC(resend_igmp, \"Number of IGMP membership reports to send on \"\n\t\t\t      \"link failure\");\n\n/*----------------------------- Global variables ----------------------------*/\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\natomic_t netpoll_block_tx = ATOMIC_INIT(0);\n#endif\n\nint bond_net_id __read_mostly;\n\nstatic __be32 arp_target[BOND_MAX_ARP_TARGETS];\nstatic int arp_ip_count;\nstatic int bond_mode\t= BOND_MODE_ROUNDROBIN;\nstatic int xmit_hashtype = BOND_XMIT_POLICY_LAYER2;\nstatic int lacp_fast;\n\nconst struct bond_parm_tbl bond_lacp_tbl[] = {\n{\t\"slow\",\t\tAD_LACP_SLOW},\n{\t\"fast\",\t\tAD_LACP_FAST},\n{\tNULL,\t\t-1},\n};\n\nconst struct bond_parm_tbl bond_mode_tbl[] = {\n{\t\"balance-rr\",\t\tBOND_MODE_ROUNDROBIN},\n{\t\"active-backup\",\tBOND_MODE_ACTIVEBACKUP},\n{\t\"balance-xor\",\t\tBOND_MODE_XOR},\n{\t\"broadcast\",\t\tBOND_MODE_BROADCAST},\n{\t\"802.3ad\",\t\tBOND_MODE_8023AD},\n{\t\"balance-tlb\",\t\tBOND_MODE_TLB},\n{\t\"balance-alb\",\t\tBOND_MODE_ALB},\n{\tNULL,\t\t\t-1},\n};\n\nconst struct bond_parm_tbl xmit_hashtype_tbl[] = {\n{\t\"layer2\",\t\tBOND_XMIT_POLICY_LAYER2},\n{\t\"layer3+4\",\t\tBOND_XMIT_POLICY_LAYER34},\n{\t\"layer2+3\",\t\tBOND_XMIT_POLICY_LAYER23},\n{\tNULL,\t\t\t-1},\n};\n\nconst struct bond_parm_tbl arp_validate_tbl[] = {\n{\t\"none\",\t\t\tBOND_ARP_VALIDATE_NONE},\n{\t\"active\",\t\tBOND_ARP_VALIDATE_ACTIVE},\n{\t\"backup\",\t\tBOND_ARP_VALIDATE_BACKUP},\n{\t\"all\",\t\t\tBOND_ARP_VALIDATE_ALL},\n{\tNULL,\t\t\t-1},\n};\n\nconst struct bond_parm_tbl fail_over_mac_tbl[] = {\n{\t\"none\",\t\t\tBOND_FOM_NONE},\n{\t\"active\",\t\tBOND_FOM_ACTIVE},\n{\t\"follow\",\t\tBOND_FOM_FOLLOW},\n{\tNULL,\t\t\t-1},\n};\n\nconst struct bond_parm_tbl pri_reselect_tbl[] = {\n{\t\"always\",\t\tBOND_PRI_RESELECT_ALWAYS},\n{\t\"better\",\t\tBOND_PRI_RESELECT_BETTER},\n{\t\"failure\",\t\tBOND_PRI_RESELECT_FAILURE},\n{\tNULL,\t\t\t-1},\n};\n\nstruct bond_parm_tbl ad_select_tbl[] = {\n{\t\"stable\",\tBOND_AD_STABLE},\n{\t\"bandwidth\",\tBOND_AD_BANDWIDTH},\n{\t\"count\",\tBOND_AD_COUNT},\n{\tNULL,\t\t-1},\n};\n\n/*-------------------------- Forward declarations ---------------------------*/\n\nstatic int bond_init(struct net_device *bond_dev);\nstatic void bond_uninit(struct net_device *bond_dev);\n\n/*---------------------------- General routines -----------------------------*/\n\nconst char *bond_mode_name(int mode)\n{\n\tstatic const char *names[] = {\n\t\t[BOND_MODE_ROUNDROBIN] = \"load balancing (round-robin)\",\n\t\t[BOND_MODE_ACTIVEBACKUP] = \"fault-tolerance (active-backup)\",\n\t\t[BOND_MODE_XOR] = \"load balancing (xor)\",\n\t\t[BOND_MODE_BROADCAST] = \"fault-tolerance (broadcast)\",\n\t\t[BOND_MODE_8023AD] = \"IEEE 802.3ad Dynamic link aggregation\",\n\t\t[BOND_MODE_TLB] = \"transmit load balancing\",\n\t\t[BOND_MODE_ALB] = \"adaptive load balancing\",\n\t};\n\n\tif (mode < 0 || mode > BOND_MODE_ALB)\n\t\treturn \"unknown\";\n\n\treturn names[mode];\n}\n\n/*---------------------------------- VLAN -----------------------------------*/\n\n/**\n * bond_add_vlan - add a new vlan id on bond\n * @bond: bond that got the notification\n * @vlan_id: the vlan id to add\n *\n * Returns -ENOMEM if allocation failed.\n */\nstatic int bond_add_vlan(struct bonding *bond, unsigned short vlan_id)\n{\n\tstruct vlan_entry *vlan;\n\n\tpr_debug(\"bond: %s, vlan id %d\\n\",\n\t\t (bond ? bond->dev->name : \"None\"), vlan_id);\n\n\tvlan = kzalloc(sizeof(struct vlan_entry), GFP_KERNEL);\n\tif (!vlan)\n\t\treturn -ENOMEM;\n\n\tINIT_LIST_HEAD(&vlan->vlan_list);\n\tvlan->vlan_id = vlan_id;\n\n\twrite_lock_bh(&bond->lock);\n\n\tlist_add_tail(&vlan->vlan_list, &bond->vlan_list);\n\n\twrite_unlock_bh(&bond->lock);\n\n\tpr_debug(\"added VLAN ID %d on bond %s\\n\", vlan_id, bond->dev->name);\n\n\treturn 0;\n}\n\n/**\n * bond_del_vlan - delete a vlan id from bond\n * @bond: bond that got the notification\n * @vlan_id: the vlan id to delete\n *\n * returns -ENODEV if @vlan_id was not found in @bond.\n */\nstatic int bond_del_vlan(struct bonding *bond, unsigned short vlan_id)\n{\n\tstruct vlan_entry *vlan;\n\tint res = -ENODEV;\n\n\tpr_debug(\"bond: %s, vlan id %d\\n\", bond->dev->name, vlan_id);\n\n\tblock_netpoll_tx();\n\twrite_lock_bh(&bond->lock);\n\n\tlist_for_each_entry(vlan, &bond->vlan_list, vlan_list) {\n\t\tif (vlan->vlan_id == vlan_id) {\n\t\t\tlist_del(&vlan->vlan_list);\n\n\t\t\tif (bond_is_lb(bond))\n\t\t\t\tbond_alb_clear_vlan(bond, vlan_id);\n\n\t\t\tpr_debug(\"removed VLAN ID %d from bond %s\\n\",\n\t\t\t\t vlan_id, bond->dev->name);\n\n\t\t\tkfree(vlan);\n\n\t\t\tres = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tpr_debug(\"couldn't find VLAN ID %d in bond %s\\n\",\n\t\t vlan_id, bond->dev->name);\n\nout:\n\twrite_unlock_bh(&bond->lock);\n\tunblock_netpoll_tx();\n\treturn res;\n}\n\n/**\n * bond_next_vlan - safely skip to the next item in the vlans list.\n * @bond: the bond we're working on\n * @curr: item we're advancing from\n *\n * Returns %NULL if list is empty, bond->next_vlan if @curr is %NULL,\n * or @curr->next otherwise (even if it is @curr itself again).\n *\n * Caller must hold bond->lock\n */\nstruct vlan_entry *bond_next_vlan(struct bonding *bond, struct vlan_entry *curr)\n{\n\tstruct vlan_entry *next, *last;\n\n\tif (list_empty(&bond->vlan_list))\n\t\treturn NULL;\n\n\tif (!curr) {\n\t\tnext = list_entry(bond->vlan_list.next,\n\t\t\t\t  struct vlan_entry, vlan_list);\n\t} else {\n\t\tlast = list_entry(bond->vlan_list.prev,\n\t\t\t\t  struct vlan_entry, vlan_list);\n\t\tif (last == curr) {\n\t\t\tnext = list_entry(bond->vlan_list.next,\n\t\t\t\t\t  struct vlan_entry, vlan_list);\n\t\t} else {\n\t\t\tnext = list_entry(curr->vlan_list.next,\n\t\t\t\t\t  struct vlan_entry, vlan_list);\n\t\t}\n\t}\n\n\treturn next;\n}\n\n#define bond_queue_mapping(skb) (*(u16 *)((skb)->cb))\n\n/**\n * bond_dev_queue_xmit - Prepare skb for xmit.\n *\n * @bond: bond device that got this skb for tx.\n * @skb: hw accel VLAN tagged skb to transmit\n * @slave_dev: slave that is supposed to xmit this skbuff\n */\nint bond_dev_queue_xmit(struct bonding *bond, struct sk_buff *skb,\n\t\t\tstruct net_device *slave_dev)\n{\n\tskb->dev = slave_dev;\n\tskb->priority = 1;\n\n\tskb->queue_mapping = bond_queue_mapping(skb);\n\n\tif (unlikely(netpoll_tx_running(slave_dev)))\n\t\tbond_netpoll_send_skb(bond_get_slave_by_dev(bond, slave_dev), skb);\n\telse\n\t\tdev_queue_xmit(skb);\n\n\treturn 0;\n}\n\n/*\n * In the following 2 functions, bond_vlan_rx_add_vid and bond_vlan_rx_kill_vid,\n * We don't protect the slave list iteration with a lock because:\n * a. This operation is performed in IOCTL context,\n * b. The operation is protected by the RTNL semaphore in the 8021q code,\n * c. Holding a lock with BH disabled while directly calling a base driver\n *    entry point is generally a BAD idea.\n *\n * The design of synchronization/protection for this operation in the 8021q\n * module is good for one or more VLAN devices over a single physical device\n * and cannot be extended for a teaming solution like bonding, so there is a\n * potential race condition here where a net device from the vlan group might\n * be referenced (either by a base driver or the 8021q code) while it is being\n * removed from the system. However, it turns out we're not making matters\n * worse, and if it works for regular VLAN usage it will work here too.\n*/\n\n/**\n * bond_vlan_rx_add_vid - Propagates adding an id to slaves\n * @bond_dev: bonding net device that got called\n * @vid: vlan id being added\n */\nstatic void bond_vlan_rx_add_vid(struct net_device *bond_dev, uint16_t vid)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct slave *slave;\n\tint i, res;\n\n\tbond_for_each_slave(bond, slave, i) {\n\t\tstruct net_device *slave_dev = slave->dev;\n\t\tconst struct net_device_ops *slave_ops = slave_dev->netdev_ops;\n\n\t\tif ((slave_dev->features & NETIF_F_HW_VLAN_FILTER) &&\n\t\t    slave_ops->ndo_vlan_rx_add_vid) {\n\t\t\tslave_ops->ndo_vlan_rx_add_vid(slave_dev, vid);\n\t\t}\n\t}\n\n\tres = bond_add_vlan(bond, vid);\n\tif (res) {\n\t\tpr_err(\"%s: Error: Failed to add vlan id %d\\n\",\n\t\t       bond_dev->name, vid);\n\t}\n}\n\n/**\n * bond_vlan_rx_kill_vid - Propagates deleting an id to slaves\n * @bond_dev: bonding net device that got called\n * @vid: vlan id being removed\n */\nstatic void bond_vlan_rx_kill_vid(struct net_device *bond_dev, uint16_t vid)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct slave *slave;\n\tint i, res;\n\n\tbond_for_each_slave(bond, slave, i) {\n\t\tstruct net_device *slave_dev = slave->dev;\n\t\tconst struct net_device_ops *slave_ops = slave_dev->netdev_ops;\n\n\t\tif ((slave_dev->features & NETIF_F_HW_VLAN_FILTER) &&\n\t\t    slave_ops->ndo_vlan_rx_kill_vid) {\n\t\t\tslave_ops->ndo_vlan_rx_kill_vid(slave_dev, vid);\n\t\t}\n\t}\n\n\tres = bond_del_vlan(bond, vid);\n\tif (res) {\n\t\tpr_err(\"%s: Error: Failed to remove vlan id %d\\n\",\n\t\t       bond_dev->name, vid);\n\t}\n}\n\nstatic void bond_add_vlans_on_slave(struct bonding *bond, struct net_device *slave_dev)\n{\n\tstruct vlan_entry *vlan;\n\tconst struct net_device_ops *slave_ops = slave_dev->netdev_ops;\n\n\tif (!(slave_dev->features & NETIF_F_HW_VLAN_FILTER) ||\n\t    !(slave_ops->ndo_vlan_rx_add_vid))\n\t\treturn;\n\n\tlist_for_each_entry(vlan, &bond->vlan_list, vlan_list)\n\t\tslave_ops->ndo_vlan_rx_add_vid(slave_dev, vlan->vlan_id);\n}\n\nstatic void bond_del_vlans_from_slave(struct bonding *bond,\n\t\t\t\t      struct net_device *slave_dev)\n{\n\tconst struct net_device_ops *slave_ops = slave_dev->netdev_ops;\n\tstruct vlan_entry *vlan;\n\n\tif (!(slave_dev->features & NETIF_F_HW_VLAN_FILTER) ||\n\t    !(slave_ops->ndo_vlan_rx_kill_vid))\n\t\treturn;\n\n\tlist_for_each_entry(vlan, &bond->vlan_list, vlan_list) {\n\t\tif (!vlan->vlan_id)\n\t\t\tcontinue;\n\t\tslave_ops->ndo_vlan_rx_kill_vid(slave_dev, vlan->vlan_id);\n\t}\n}\n\n/*------------------------------- Link status -------------------------------*/\n\n/*\n * Set the carrier state for the master according to the state of its\n * slaves.  If any slaves are up, the master is up.  In 802.3ad mode,\n * do special 802.3ad magic.\n *\n * Returns zero if carrier state does not change, nonzero if it does.\n */\nstatic int bond_set_carrier(struct bonding *bond)\n{\n\tstruct slave *slave;\n\tint i;\n\n\tif (bond->slave_cnt == 0)\n\t\tgoto down;\n\n\tif (bond->params.mode == BOND_MODE_8023AD)\n\t\treturn bond_3ad_set_carrier(bond);\n\n\tbond_for_each_slave(bond, slave, i) {\n\t\tif (slave->link == BOND_LINK_UP) {\n\t\t\tif (!netif_carrier_ok(bond->dev)) {\n\t\t\t\tnetif_carrier_on(bond->dev);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\ndown:\n\tif (netif_carrier_ok(bond->dev)) {\n\t\tnetif_carrier_off(bond->dev);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/*\n * Get link speed and duplex from the slave's base driver\n * using ethtool. If for some reason the call fails or the\n * values are invalid, fake speed and duplex to 100/Full\n * and return error.\n */\nstatic int bond_update_speed_duplex(struct slave *slave)\n{\n\tstruct net_device *slave_dev = slave->dev;\n\tstruct ethtool_cmd etool = { .cmd = ETHTOOL_GSET };\n\tu32 slave_speed;\n\tint res;\n\n\t/* Fake speed and duplex */\n\tslave->speed = SPEED_100;\n\tslave->duplex = DUPLEX_FULL;\n\n\tif (!slave_dev->ethtool_ops || !slave_dev->ethtool_ops->get_settings)\n\t\treturn -1;\n\n\tres = slave_dev->ethtool_ops->get_settings(slave_dev, &etool);\n\tif (res < 0)\n\t\treturn -1;\n\n\tslave_speed = ethtool_cmd_speed(&etool);\n\tif (slave_speed == 0 || slave_speed == ((__u32) -1))\n\t\treturn -1;\n\n\tswitch (etool.duplex) {\n\tcase DUPLEX_FULL:\n\tcase DUPLEX_HALF:\n\t\tbreak;\n\tdefault:\n\t\treturn -1;\n\t}\n\n\tslave->speed = slave_speed;\n\tslave->duplex = etool.duplex;\n\n\treturn 0;\n}\n\n/*\n * if <dev> supports MII link status reporting, check its link status.\n *\n * We either do MII/ETHTOOL ioctls, or check netif_carrier_ok(),\n * depending upon the setting of the use_carrier parameter.\n *\n * Return either BMSR_LSTATUS, meaning that the link is up (or we\n * can't tell and just pretend it is), or 0, meaning that the link is\n * down.\n *\n * If reporting is non-zero, instead of faking link up, return -1 if\n * both ETHTOOL and MII ioctls fail (meaning the device does not\n * support them).  If use_carrier is set, return whatever it says.\n * It'd be nice if there was a good way to tell if a driver supports\n * netif_carrier, but there really isn't.\n */\nstatic int bond_check_dev_link(struct bonding *bond,\n\t\t\t       struct net_device *slave_dev, int reporting)\n{\n\tconst struct net_device_ops *slave_ops = slave_dev->netdev_ops;\n\tint (*ioctl)(struct net_device *, struct ifreq *, int);\n\tstruct ifreq ifr;\n\tstruct mii_ioctl_data *mii;\n\n\tif (!reporting && !netif_running(slave_dev))\n\t\treturn 0;\n\n\tif (bond->params.use_carrier)\n\t\treturn netif_carrier_ok(slave_dev) ? BMSR_LSTATUS : 0;\n\n\t/* Try to get link status using Ethtool first. */\n\tif (slave_dev->ethtool_ops) {\n\t\tif (slave_dev->ethtool_ops->get_link) {\n\t\t\tu32 link;\n\n\t\t\tlink = slave_dev->ethtool_ops->get_link(slave_dev);\n\n\t\t\treturn link ? BMSR_LSTATUS : 0;\n\t\t}\n\t}\n\n\t/* Ethtool can't be used, fallback to MII ioctls. */\n\tioctl = slave_ops->ndo_do_ioctl;\n\tif (ioctl) {\n\t\t/* TODO: set pointer to correct ioctl on a per team member */\n\t\t/*       bases to make this more efficient. that is, once  */\n\t\t/*       we determine the correct ioctl, we will always    */\n\t\t/*       call it and not the others for that team          */\n\t\t/*       member.                                           */\n\n\t\t/*\n\t\t * We cannot assume that SIOCGMIIPHY will also read a\n\t\t * register; not all network drivers (e.g., e100)\n\t\t * support that.\n\t\t */\n\n\t\t/* Yes, the mii is overlaid on the ifreq.ifr_ifru */\n\t\tstrncpy(ifr.ifr_name, slave_dev->name, IFNAMSIZ);\n\t\tmii = if_mii(&ifr);\n\t\tif (IOCTL(slave_dev, &ifr, SIOCGMIIPHY) == 0) {\n\t\t\tmii->reg_num = MII_BMSR;\n\t\t\tif (IOCTL(slave_dev, &ifr, SIOCGMIIREG) == 0)\n\t\t\t\treturn mii->val_out & BMSR_LSTATUS;\n\t\t}\n\t}\n\n\t/*\n\t * If reporting, report that either there's no dev->do_ioctl,\n\t * or both SIOCGMIIREG and get_link failed (meaning that we\n\t * cannot report link status).  If not reporting, pretend\n\t * we're ok.\n\t */\n\treturn reporting ? -1 : BMSR_LSTATUS;\n}\n\n/*----------------------------- Multicast list ------------------------------*/\n\n/*\n * Push the promiscuity flag down to appropriate slaves\n */\nstatic int bond_set_promiscuity(struct bonding *bond, int inc)\n{\n\tint err = 0;\n\tif (USES_PRIMARY(bond->params.mode)) {\n\t\t/* write lock already acquired */\n\t\tif (bond->curr_active_slave) {\n\t\t\terr = dev_set_promiscuity(bond->curr_active_slave->dev,\n\t\t\t\t\t\t  inc);\n\t\t}\n\t} else {\n\t\tstruct slave *slave;\n\t\tint i;\n\t\tbond_for_each_slave(bond, slave, i) {\n\t\t\terr = dev_set_promiscuity(slave->dev, inc);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn err;\n}\n\n/*\n * Push the allmulti flag down to all slaves\n */\nstatic int bond_set_allmulti(struct bonding *bond, int inc)\n{\n\tint err = 0;\n\tif (USES_PRIMARY(bond->params.mode)) {\n\t\t/* write lock already acquired */\n\t\tif (bond->curr_active_slave) {\n\t\t\terr = dev_set_allmulti(bond->curr_active_slave->dev,\n\t\t\t\t\t       inc);\n\t\t}\n\t} else {\n\t\tstruct slave *slave;\n\t\tint i;\n\t\tbond_for_each_slave(bond, slave, i) {\n\t\t\terr = dev_set_allmulti(slave->dev, inc);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t}\n\treturn err;\n}\n\n/*\n * Add a Multicast address to slaves\n * according to mode\n */\nstatic void bond_mc_add(struct bonding *bond, void *addr)\n{\n\tif (USES_PRIMARY(bond->params.mode)) {\n\t\t/* write lock already acquired */\n\t\tif (bond->curr_active_slave)\n\t\t\tdev_mc_add(bond->curr_active_slave->dev, addr);\n\t} else {\n\t\tstruct slave *slave;\n\t\tint i;\n\n\t\tbond_for_each_slave(bond, slave, i)\n\t\t\tdev_mc_add(slave->dev, addr);\n\t}\n}\n\n/*\n * Remove a multicast address from slave\n * according to mode\n */\nstatic void bond_mc_del(struct bonding *bond, void *addr)\n{\n\tif (USES_PRIMARY(bond->params.mode)) {\n\t\t/* write lock already acquired */\n\t\tif (bond->curr_active_slave)\n\t\t\tdev_mc_del(bond->curr_active_slave->dev, addr);\n\t} else {\n\t\tstruct slave *slave;\n\t\tint i;\n\t\tbond_for_each_slave(bond, slave, i) {\n\t\t\tdev_mc_del(slave->dev, addr);\n\t\t}\n\t}\n}\n\n\nstatic void __bond_resend_igmp_join_requests(struct net_device *dev)\n{\n\tstruct in_device *in_dev;\n\n\trcu_read_lock();\n\tin_dev = __in_dev_get_rcu(dev);\n\tif (in_dev)\n\t\tip_mc_rejoin_groups(in_dev);\n\trcu_read_unlock();\n}\n\n/*\n * Retrieve the list of registered multicast addresses for the bonding\n * device and retransmit an IGMP JOIN request to the current active\n * slave.\n */\nstatic void bond_resend_igmp_join_requests(struct bonding *bond)\n{\n\tstruct net_device *vlan_dev;\n\tstruct vlan_entry *vlan;\n\n\tread_lock(&bond->lock);\n\n\t/* rejoin all groups on bond device */\n\t__bond_resend_igmp_join_requests(bond->dev);\n\n\t/* rejoin all groups on vlan devices */\n\tlist_for_each_entry(vlan, &bond->vlan_list, vlan_list) {\n\t\trcu_read_lock();\n\t\tvlan_dev = __vlan_find_dev_deep(bond->dev,\n\t\t\t\t\t\tvlan->vlan_id);\n\t\trcu_read_unlock();\n\t\tif (vlan_dev)\n\t\t\t__bond_resend_igmp_join_requests(vlan_dev);\n\t}\n\n\tif (--bond->igmp_retrans > 0)\n\t\tqueue_delayed_work(bond->wq, &bond->mcast_work, HZ/5);\n\n\tread_unlock(&bond->lock);\n}\n\nstatic void bond_resend_igmp_join_requests_delayed(struct work_struct *work)\n{\n\tstruct bonding *bond = container_of(work, struct bonding,\n\t\t\t\t\t    mcast_work.work);\n\tbond_resend_igmp_join_requests(bond);\n}\n\n/*\n * flush all members of flush->mc_list from device dev->mc_list\n */\nstatic void bond_mc_list_flush(struct net_device *bond_dev,\n\t\t\t       struct net_device *slave_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct netdev_hw_addr *ha;\n\n\tnetdev_for_each_mc_addr(ha, bond_dev)\n\t\tdev_mc_del(slave_dev, ha->addr);\n\n\tif (bond->params.mode == BOND_MODE_8023AD) {\n\t\t/* del lacpdu mc addr from mc list */\n\t\tu8 lacpdu_multicast[ETH_ALEN] = MULTICAST_LACPDU_ADDR;\n\n\t\tdev_mc_del(slave_dev, lacpdu_multicast);\n\t}\n}\n\n/*--------------------------- Active slave change ---------------------------*/\n\n/*\n * Update the mc list and multicast-related flags for the new and\n * old active slaves (if any) according to the multicast mode, and\n * promiscuous flags unconditionally.\n */\nstatic void bond_mc_swap(struct bonding *bond, struct slave *new_active,\n\t\t\t struct slave *old_active)\n{\n\tstruct netdev_hw_addr *ha;\n\n\tif (!USES_PRIMARY(bond->params.mode))\n\t\t/* nothing to do -  mc list is already up-to-date on\n\t\t * all slaves\n\t\t */\n\t\treturn;\n\n\tif (old_active) {\n\t\tif (bond->dev->flags & IFF_PROMISC)\n\t\t\tdev_set_promiscuity(old_active->dev, -1);\n\n\t\tif (bond->dev->flags & IFF_ALLMULTI)\n\t\t\tdev_set_allmulti(old_active->dev, -1);\n\n\t\tnetdev_for_each_mc_addr(ha, bond->dev)\n\t\t\tdev_mc_del(old_active->dev, ha->addr);\n\t}\n\n\tif (new_active) {\n\t\t/* FIXME: Signal errors upstream. */\n\t\tif (bond->dev->flags & IFF_PROMISC)\n\t\t\tdev_set_promiscuity(new_active->dev, 1);\n\n\t\tif (bond->dev->flags & IFF_ALLMULTI)\n\t\t\tdev_set_allmulti(new_active->dev, 1);\n\n\t\tnetdev_for_each_mc_addr(ha, bond->dev)\n\t\t\tdev_mc_add(new_active->dev, ha->addr);\n\t}\n}\n\n/*\n * bond_do_fail_over_mac\n *\n * Perform special MAC address swapping for fail_over_mac settings\n *\n * Called with RTNL, bond->lock for read, curr_slave_lock for write_bh.\n */\nstatic void bond_do_fail_over_mac(struct bonding *bond,\n\t\t\t\t  struct slave *new_active,\n\t\t\t\t  struct slave *old_active)\n\t__releases(&bond->curr_slave_lock)\n\t__releases(&bond->lock)\n\t__acquires(&bond->lock)\n\t__acquires(&bond->curr_slave_lock)\n{\n\tu8 tmp_mac[ETH_ALEN];\n\tstruct sockaddr saddr;\n\tint rv;\n\n\tswitch (bond->params.fail_over_mac) {\n\tcase BOND_FOM_ACTIVE:\n\t\tif (new_active)\n\t\t\tmemcpy(bond->dev->dev_addr,  new_active->dev->dev_addr,\n\t\t\t       new_active->dev->addr_len);\n\t\tbreak;\n\tcase BOND_FOM_FOLLOW:\n\t\t/*\n\t\t * if new_active && old_active, swap them\n\t\t * if just old_active, do nothing (going to no active slave)\n\t\t * if just new_active, set new_active to bond's MAC\n\t\t */\n\t\tif (!new_active)\n\t\t\treturn;\n\n\t\twrite_unlock_bh(&bond->curr_slave_lock);\n\t\tread_unlock(&bond->lock);\n\n\t\tif (old_active) {\n\t\t\tmemcpy(tmp_mac, new_active->dev->dev_addr, ETH_ALEN);\n\t\t\tmemcpy(saddr.sa_data, old_active->dev->dev_addr,\n\t\t\t       ETH_ALEN);\n\t\t\tsaddr.sa_family = new_active->dev->type;\n\t\t} else {\n\t\t\tmemcpy(saddr.sa_data, bond->dev->dev_addr, ETH_ALEN);\n\t\t\tsaddr.sa_family = bond->dev->type;\n\t\t}\n\n\t\trv = dev_set_mac_address(new_active->dev, &saddr);\n\t\tif (rv) {\n\t\t\tpr_err(\"%s: Error %d setting MAC of slave %s\\n\",\n\t\t\t       bond->dev->name, -rv, new_active->dev->name);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!old_active)\n\t\t\tgoto out;\n\n\t\tmemcpy(saddr.sa_data, tmp_mac, ETH_ALEN);\n\t\tsaddr.sa_family = old_active->dev->type;\n\n\t\trv = dev_set_mac_address(old_active->dev, &saddr);\n\t\tif (rv)\n\t\t\tpr_err(\"%s: Error %d setting MAC of slave %s\\n\",\n\t\t\t       bond->dev->name, -rv, new_active->dev->name);\nout:\n\t\tread_lock(&bond->lock);\n\t\twrite_lock_bh(&bond->curr_slave_lock);\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"%s: bond_do_fail_over_mac impossible: bad policy %d\\n\",\n\t\t       bond->dev->name, bond->params.fail_over_mac);\n\t\tbreak;\n\t}\n\n}\n\nstatic bool bond_should_change_active(struct bonding *bond)\n{\n\tstruct slave *prim = bond->primary_slave;\n\tstruct slave *curr = bond->curr_active_slave;\n\n\tif (!prim || !curr || curr->link != BOND_LINK_UP)\n\t\treturn true;\n\tif (bond->force_primary) {\n\t\tbond->force_primary = false;\n\t\treturn true;\n\t}\n\tif (bond->params.primary_reselect == BOND_PRI_RESELECT_BETTER &&\n\t    (prim->speed < curr->speed ||\n\t     (prim->speed == curr->speed && prim->duplex <= curr->duplex)))\n\t\treturn false;\n\tif (bond->params.primary_reselect == BOND_PRI_RESELECT_FAILURE)\n\t\treturn false;\n\treturn true;\n}\n\n/**\n * find_best_interface - select the best available slave to be the active one\n * @bond: our bonding struct\n *\n * Warning: Caller must hold curr_slave_lock for writing.\n */\nstatic struct slave *bond_find_best_slave(struct bonding *bond)\n{\n\tstruct slave *new_active, *old_active;\n\tstruct slave *bestslave = NULL;\n\tint mintime = bond->params.updelay;\n\tint i;\n\n\tnew_active = bond->curr_active_slave;\n\n\tif (!new_active) { /* there were no active slaves left */\n\t\tif (bond->slave_cnt > 0)   /* found one slave */\n\t\t\tnew_active = bond->first_slave;\n\t\telse\n\t\t\treturn NULL; /* still no slave, return NULL */\n\t}\n\n\tif ((bond->primary_slave) &&\n\t    bond->primary_slave->link == BOND_LINK_UP &&\n\t    bond_should_change_active(bond)) {\n\t\tnew_active = bond->primary_slave;\n\t}\n\n\t/* remember where to stop iterating over the slaves */\n\told_active = new_active;\n\n\tbond_for_each_slave_from(bond, new_active, i, old_active) {\n\t\tif (new_active->link == BOND_LINK_UP) {\n\t\t\treturn new_active;\n\t\t} else if (new_active->link == BOND_LINK_BACK &&\n\t\t\t   IS_UP(new_active->dev)) {\n\t\t\t/* link up, but waiting for stabilization */\n\t\t\tif (new_active->delay < mintime) {\n\t\t\t\tmintime = new_active->delay;\n\t\t\t\tbestslave = new_active;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn bestslave;\n}\n\nstatic bool bond_should_notify_peers(struct bonding *bond)\n{\n\tstruct slave *slave = bond->curr_active_slave;\n\n\tpr_debug(\"bond_should_notify_peers: bond %s slave %s\\n\",\n\t\t bond->dev->name, slave ? slave->dev->name : \"NULL\");\n\n\tif (!slave || !bond->send_peer_notif ||\n\t    test_bit(__LINK_STATE_LINKWATCH_PENDING, &slave->dev->state))\n\t\treturn false;\n\n\tbond->send_peer_notif--;\n\treturn true;\n}\n\n/**\n * change_active_interface - change the active slave into the specified one\n * @bond: our bonding struct\n * @new: the new slave to make the active one\n *\n * Set the new slave to the bond's settings and unset them on the old\n * curr_active_slave.\n * Setting include flags, mc-list, promiscuity, allmulti, etc.\n *\n * If @new's link state is %BOND_LINK_BACK we'll set it to %BOND_LINK_UP,\n * because it is apparently the best available slave we have, even though its\n * updelay hasn't timed out yet.\n *\n * If new_active is not NULL, caller must hold bond->lock for read and\n * curr_slave_lock for write_bh.\n */\nvoid bond_change_active_slave(struct bonding *bond, struct slave *new_active)\n{\n\tstruct slave *old_active = bond->curr_active_slave;\n\n\tif (old_active == new_active)\n\t\treturn;\n\n\tif (new_active) {\n\t\tnew_active->jiffies = jiffies;\n\n\t\tif (new_active->link == BOND_LINK_BACK) {\n\t\t\tif (USES_PRIMARY(bond->params.mode)) {\n\t\t\t\tpr_info(\"%s: making interface %s the new active one %d ms earlier.\\n\",\n\t\t\t\t\tbond->dev->name, new_active->dev->name,\n\t\t\t\t\t(bond->params.updelay - new_active->delay) * bond->params.miimon);\n\t\t\t}\n\n\t\t\tnew_active->delay = 0;\n\t\t\tnew_active->link = BOND_LINK_UP;\n\n\t\t\tif (bond->params.mode == BOND_MODE_8023AD)\n\t\t\t\tbond_3ad_handle_link_change(new_active, BOND_LINK_UP);\n\n\t\t\tif (bond_is_lb(bond))\n\t\t\t\tbond_alb_handle_link_change(bond, new_active, BOND_LINK_UP);\n\t\t} else {\n\t\t\tif (USES_PRIMARY(bond->params.mode)) {\n\t\t\t\tpr_info(\"%s: making interface %s the new active one.\\n\",\n\t\t\t\t\tbond->dev->name, new_active->dev->name);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (USES_PRIMARY(bond->params.mode))\n\t\tbond_mc_swap(bond, new_active, old_active);\n\n\tif (bond_is_lb(bond)) {\n\t\tbond_alb_handle_active_change(bond, new_active);\n\t\tif (old_active)\n\t\t\tbond_set_slave_inactive_flags(old_active);\n\t\tif (new_active)\n\t\t\tbond_set_slave_active_flags(new_active);\n\t} else {\n\t\tbond->curr_active_slave = new_active;\n\t}\n\n\tif (bond->params.mode == BOND_MODE_ACTIVEBACKUP) {\n\t\tif (old_active)\n\t\t\tbond_set_slave_inactive_flags(old_active);\n\n\t\tif (new_active) {\n\t\t\tbool should_notify_peers = false;\n\n\t\t\tbond_set_slave_active_flags(new_active);\n\n\t\t\tif (bond->params.fail_over_mac)\n\t\t\t\tbond_do_fail_over_mac(bond, new_active,\n\t\t\t\t\t\t      old_active);\n\n\t\t\tif (netif_running(bond->dev)) {\n\t\t\t\tbond->send_peer_notif =\n\t\t\t\t\tbond->params.num_peer_notif;\n\t\t\t\tshould_notify_peers =\n\t\t\t\t\tbond_should_notify_peers(bond);\n\t\t\t}\n\n\t\t\twrite_unlock_bh(&bond->curr_slave_lock);\n\t\t\tread_unlock(&bond->lock);\n\n\t\t\tnetdev_bonding_change(bond->dev, NETDEV_BONDING_FAILOVER);\n\t\t\tif (should_notify_peers)\n\t\t\t\tnetdev_bonding_change(bond->dev,\n\t\t\t\t\t\t      NETDEV_NOTIFY_PEERS);\n\n\t\t\tread_lock(&bond->lock);\n\t\t\twrite_lock_bh(&bond->curr_slave_lock);\n\t\t}\n\t}\n\n\t/* resend IGMP joins since active slave has changed or\n\t * all were sent on curr_active_slave.\n\t * resend only if bond is brought up with the affected\n\t * bonding modes and the retransmission is enabled */\n\tif (netif_running(bond->dev) && (bond->params.resend_igmp > 0) &&\n\t    ((USES_PRIMARY(bond->params.mode) && new_active) ||\n\t     bond->params.mode == BOND_MODE_ROUNDROBIN)) {\n\t\tbond->igmp_retrans = bond->params.resend_igmp;\n\t\tqueue_delayed_work(bond->wq, &bond->mcast_work, 0);\n\t}\n}\n\n/**\n * bond_select_active_slave - select a new active slave, if needed\n * @bond: our bonding struct\n *\n * This functions should be called when one of the following occurs:\n * - The old curr_active_slave has been released or lost its link.\n * - The primary_slave has got its link back.\n * - A slave has got its link back and there's no old curr_active_slave.\n *\n * Caller must hold bond->lock for read and curr_slave_lock for write_bh.\n */\nvoid bond_select_active_slave(struct bonding *bond)\n{\n\tstruct slave *best_slave;\n\tint rv;\n\n\tbest_slave = bond_find_best_slave(bond);\n\tif (best_slave != bond->curr_active_slave) {\n\t\tbond_change_active_slave(bond, best_slave);\n\t\trv = bond_set_carrier(bond);\n\t\tif (!rv)\n\t\t\treturn;\n\n\t\tif (netif_carrier_ok(bond->dev)) {\n\t\t\tpr_info(\"%s: first active interface up!\\n\",\n\t\t\t\tbond->dev->name);\n\t\t} else {\n\t\t\tpr_info(\"%s: now running without any active interface !\\n\",\n\t\t\t\tbond->dev->name);\n\t\t}\n\t}\n}\n\n/*--------------------------- slave list handling ---------------------------*/\n\n/*\n * This function attaches the slave to the end of list.\n *\n * bond->lock held for writing by caller.\n */\nstatic void bond_attach_slave(struct bonding *bond, struct slave *new_slave)\n{\n\tif (bond->first_slave == NULL) { /* attaching the first slave */\n\t\tnew_slave->next = new_slave;\n\t\tnew_slave->prev = new_slave;\n\t\tbond->first_slave = new_slave;\n\t} else {\n\t\tnew_slave->next = bond->first_slave;\n\t\tnew_slave->prev = bond->first_slave->prev;\n\t\tnew_slave->next->prev = new_slave;\n\t\tnew_slave->prev->next = new_slave;\n\t}\n\n\tbond->slave_cnt++;\n}\n\n/*\n * This function detaches the slave from the list.\n * WARNING: no check is made to verify if the slave effectively\n * belongs to <bond>.\n * Nothing is freed on return, structures are just unchained.\n * If any slave pointer in bond was pointing to <slave>,\n * it should be changed by the calling function.\n *\n * bond->lock held for writing by caller.\n */\nstatic void bond_detach_slave(struct bonding *bond, struct slave *slave)\n{\n\tif (slave->next)\n\t\tslave->next->prev = slave->prev;\n\n\tif (slave->prev)\n\t\tslave->prev->next = slave->next;\n\n\tif (bond->first_slave == slave) { /* slave is the first slave */\n\t\tif (bond->slave_cnt > 1) { /* there are more slave */\n\t\t\tbond->first_slave = slave->next;\n\t\t} else {\n\t\t\tbond->first_slave = NULL; /* slave was the last one */\n\t\t}\n\t}\n\n\tslave->next = NULL;\n\tslave->prev = NULL;\n\tbond->slave_cnt--;\n}\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic inline int slave_enable_netpoll(struct slave *slave)\n{\n\tstruct netpoll *np;\n\tint err = 0;\n\n\tnp = kzalloc(sizeof(*np), GFP_KERNEL);\n\terr = -ENOMEM;\n\tif (!np)\n\t\tgoto out;\n\n\tnp->dev = slave->dev;\n\tstrlcpy(np->dev_name, slave->dev->name, IFNAMSIZ);\n\terr = __netpoll_setup(np);\n\tif (err) {\n\t\tkfree(np);\n\t\tgoto out;\n\t}\n\tslave->np = np;\nout:\n\treturn err;\n}\nstatic inline void slave_disable_netpoll(struct slave *slave)\n{\n\tstruct netpoll *np = slave->np;\n\n\tif (!np)\n\t\treturn;\n\n\tslave->np = NULL;\n\tsynchronize_rcu_bh();\n\t__netpoll_cleanup(np);\n\tkfree(np);\n}\nstatic inline bool slave_dev_support_netpoll(struct net_device *slave_dev)\n{\n\tif (slave_dev->priv_flags & IFF_DISABLE_NETPOLL)\n\t\treturn false;\n\tif (!slave_dev->netdev_ops->ndo_poll_controller)\n\t\treturn false;\n\treturn true;\n}\n\nstatic void bond_poll_controller(struct net_device *bond_dev)\n{\n}\n\nstatic void __bond_netpoll_cleanup(struct bonding *bond)\n{\n\tstruct slave *slave;\n\tint i;\n\n\tbond_for_each_slave(bond, slave, i)\n\t\tif (IS_UP(slave->dev))\n\t\t\tslave_disable_netpoll(slave);\n}\nstatic void bond_netpoll_cleanup(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\n\tread_lock(&bond->lock);\n\t__bond_netpoll_cleanup(bond);\n\tread_unlock(&bond->lock);\n}\n\nstatic int bond_netpoll_setup(struct net_device *dev, struct netpoll_info *ni)\n{\n\tstruct bonding *bond = netdev_priv(dev);\n\tstruct slave *slave;\n\tint i, err = 0;\n\n\tread_lock(&bond->lock);\n\tbond_for_each_slave(bond, slave, i) {\n\t\terr = slave_enable_netpoll(slave);\n\t\tif (err) {\n\t\t\t__bond_netpoll_cleanup(bond);\n\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock(&bond->lock);\n\treturn err;\n}\n\nstatic struct netpoll_info *bond_netpoll_info(struct bonding *bond)\n{\n\treturn bond->dev->npinfo;\n}\n\n#else\nstatic inline int slave_enable_netpoll(struct slave *slave)\n{\n\treturn 0;\n}\nstatic inline void slave_disable_netpoll(struct slave *slave)\n{\n}\nstatic void bond_netpoll_cleanup(struct net_device *bond_dev)\n{\n}\n#endif\n\n/*---------------------------------- IOCTL ----------------------------------*/\n\nstatic int bond_sethwaddr(struct net_device *bond_dev,\n\t\t\t  struct net_device *slave_dev)\n{\n\tpr_debug(\"bond_dev=%p\\n\", bond_dev);\n\tpr_debug(\"slave_dev=%p\\n\", slave_dev);\n\tpr_debug(\"slave_dev->addr_len=%d\\n\", slave_dev->addr_len);\n\tmemcpy(bond_dev->dev_addr, slave_dev->dev_addr, slave_dev->addr_len);\n\treturn 0;\n}\n\nstatic u32 bond_fix_features(struct net_device *dev, u32 features)\n{\n\tstruct slave *slave;\n\tstruct bonding *bond = netdev_priv(dev);\n\tu32 mask;\n\tint i;\n\n\tread_lock(&bond->lock);\n\n\tif (!bond->first_slave) {\n\t\t/* Disable adding VLANs to empty bond. But why? --mq */\n\t\tfeatures |= NETIF_F_VLAN_CHALLENGED;\n\t\tgoto out;\n\t}\n\n\tmask = features;\n\tfeatures &= ~NETIF_F_ONE_FOR_ALL;\n\tfeatures |= NETIF_F_ALL_FOR_ALL;\n\n\tbond_for_each_slave(bond, slave, i) {\n\t\tfeatures = netdev_increment_features(features,\n\t\t\t\t\t\t     slave->dev->features,\n\t\t\t\t\t\t     mask);\n\t}\n\nout:\n\tread_unlock(&bond->lock);\n\treturn features;\n}\n\n#define BOND_VLAN_FEATURES\t(NETIF_F_ALL_CSUM | NETIF_F_SG | \\\n\t\t\t\t NETIF_F_FRAGLIST | NETIF_F_ALL_TSO | \\\n\t\t\t\t NETIF_F_HIGHDMA | NETIF_F_LRO)\n\nstatic void bond_compute_features(struct bonding *bond)\n{\n\tstruct slave *slave;\n\tstruct net_device *bond_dev = bond->dev;\n\tu32 vlan_features = BOND_VLAN_FEATURES;\n\tunsigned short max_hard_header_len = ETH_HLEN;\n\tint i;\n\n\tread_lock(&bond->lock);\n\n\tif (!bond->first_slave)\n\t\tgoto done;\n\n\tbond_for_each_slave(bond, slave, i) {\n\t\tvlan_features = netdev_increment_features(vlan_features,\n\t\t\tslave->dev->vlan_features, BOND_VLAN_FEATURES);\n\n\t\tif (slave->dev->hard_header_len > max_hard_header_len)\n\t\t\tmax_hard_header_len = slave->dev->hard_header_len;\n\t}\n\ndone:\n\tbond_dev->vlan_features = vlan_features;\n\tbond_dev->hard_header_len = max_hard_header_len;\n\n\tread_unlock(&bond->lock);\n\n\tnetdev_change_features(bond_dev);\n}\n\nstatic void bond_setup_by_slave(struct net_device *bond_dev,\n\t\t\t\tstruct net_device *slave_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\n\tbond_dev->header_ops\t    = slave_dev->header_ops;\n\n\tbond_dev->type\t\t    = slave_dev->type;\n\tbond_dev->hard_header_len   = slave_dev->hard_header_len;\n\tbond_dev->addr_len\t    = slave_dev->addr_len;\n\n\tmemcpy(bond_dev->broadcast, slave_dev->broadcast,\n\t\tslave_dev->addr_len);\n\tbond->setup_by_slave = 1;\n}\n\n/* On bonding slaves other than the currently active slave, suppress\n * duplicates except for alb non-mcast/bcast.\n */\nstatic bool bond_should_deliver_exact_match(struct sk_buff *skb,\n\t\t\t\t\t    struct slave *slave,\n\t\t\t\t\t    struct bonding *bond)\n{\n\tif (bond_is_slave_inactive(slave)) {\n\t\tif (bond->params.mode == BOND_MODE_ALB &&\n\t\t    skb->pkt_type != PACKET_BROADCAST &&\n\t\t    skb->pkt_type != PACKET_MULTICAST)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nstatic rx_handler_result_t bond_handle_frame(struct sk_buff **pskb)\n{\n\tstruct sk_buff *skb = *pskb;\n\tstruct slave *slave;\n\tstruct bonding *bond;\n\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (unlikely(!skb))\n\t\treturn RX_HANDLER_CONSUMED;\n\n\t*pskb = skb;\n\n\tslave = bond_slave_get_rcu(skb->dev);\n\tbond = slave->bond;\n\n\tif (bond->params.arp_interval)\n\t\tslave->dev->last_rx = jiffies;\n\n\tif (bond->recv_probe) {\n\t\tstruct sk_buff *nskb = skb_clone(skb, GFP_ATOMIC);\n\n\t\tif (likely(nskb)) {\n\t\t\tbond->recv_probe(nskb, bond, slave);\n\t\t\tdev_kfree_skb(nskb);\n\t\t}\n\t}\n\n\tif (bond_should_deliver_exact_match(skb, slave, bond)) {\n\t\treturn RX_HANDLER_EXACT;\n\t}\n\n\tskb->dev = bond->dev;\n\n\tif (bond->params.mode == BOND_MODE_ALB &&\n\t    bond->dev->priv_flags & IFF_BRIDGE_PORT &&\n\t    skb->pkt_type == PACKET_HOST) {\n\n\t\tif (unlikely(skb_cow_head(skb,\n\t\t\t\t\t  skb->data - skb_mac_header(skb)))) {\n\t\t\tkfree_skb(skb);\n\t\t\treturn RX_HANDLER_CONSUMED;\n\t\t}\n\t\tmemcpy(eth_hdr(skb)->h_dest, bond->dev->dev_addr, ETH_ALEN);\n\t}\n\n\treturn RX_HANDLER_ANOTHER;\n}\n\n/* enslave device <slave> to bond device <master> */\nint bond_enslave(struct net_device *bond_dev, struct net_device *slave_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tconst struct net_device_ops *slave_ops = slave_dev->netdev_ops;\n\tstruct slave *new_slave = NULL;\n\tstruct netdev_hw_addr *ha;\n\tstruct sockaddr addr;\n\tint link_reporting;\n\tint res = 0;\n\n\tif (!bond->params.use_carrier && slave_dev->ethtool_ops == NULL &&\n\t\tslave_ops->ndo_do_ioctl == NULL) {\n\t\tpr_warning(\"%s: Warning: no link monitoring support for %s\\n\",\n\t\t\t   bond_dev->name, slave_dev->name);\n\t}\n\n\t/* already enslaved */\n\tif (slave_dev->flags & IFF_SLAVE) {\n\t\tpr_debug(\"Error, Device was already enslaved\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\t/* vlan challenged mutual exclusion */\n\t/* no need to lock since we're protected by rtnl_lock */\n\tif (slave_dev->features & NETIF_F_VLAN_CHALLENGED) {\n\t\tpr_debug(\"%s: NETIF_F_VLAN_CHALLENGED\\n\", slave_dev->name);\n\t\tif (bond_vlan_used(bond)) {\n\t\t\tpr_err(\"%s: Error: cannot enslave VLAN challenged slave %s on VLAN enabled bond %s\\n\",\n\t\t\t       bond_dev->name, slave_dev->name, bond_dev->name);\n\t\t\treturn -EPERM;\n\t\t} else {\n\t\t\tpr_warning(\"%s: Warning: enslaved VLAN challenged slave %s. Adding VLANs will be blocked as long as %s is part of bond %s\\n\",\n\t\t\t\t   bond_dev->name, slave_dev->name,\n\t\t\t\t   slave_dev->name, bond_dev->name);\n\t\t}\n\t} else {\n\t\tpr_debug(\"%s: ! NETIF_F_VLAN_CHALLENGED\\n\", slave_dev->name);\n\t}\n\n\t/*\n\t * Old ifenslave binaries are no longer supported.  These can\n\t * be identified with moderate accuracy by the state of the slave:\n\t * the current ifenslave will set the interface down prior to\n\t * enslaving it; the old ifenslave will not.\n\t */\n\tif ((slave_dev->flags & IFF_UP)) {\n\t\tpr_err(\"%s is up. This may be due to an out of date ifenslave.\\n\",\n\t\t       slave_dev->name);\n\t\tres = -EPERM;\n\t\tgoto err_undo_flags;\n\t}\n\n\t/* set bonding device ether type by slave - bonding netdevices are\n\t * created with ether_setup, so when the slave type is not ARPHRD_ETHER\n\t * there is a need to override some of the type dependent attribs/funcs.\n\t *\n\t * bond ether type mutual exclusion - don't allow slaves of dissimilar\n\t * ether type (eg ARPHRD_ETHER and ARPHRD_INFINIBAND) share the same bond\n\t */\n\tif (bond->slave_cnt == 0) {\n\t\tif (bond_dev->type != slave_dev->type) {\n\t\t\tpr_debug(\"%s: change device type from %d to %d\\n\",\n\t\t\t\t bond_dev->name,\n\t\t\t\t bond_dev->type, slave_dev->type);\n\n\t\t\tres = netdev_bonding_change(bond_dev,\n\t\t\t\t\t\t    NETDEV_PRE_TYPE_CHANGE);\n\t\t\tres = notifier_to_errno(res);\n\t\t\tif (res) {\n\t\t\t\tpr_err(\"%s: refused to change device type\\n\",\n\t\t\t\t       bond_dev->name);\n\t\t\t\tres = -EBUSY;\n\t\t\t\tgoto err_undo_flags;\n\t\t\t}\n\n\t\t\t/* Flush unicast and multicast addresses */\n\t\t\tdev_uc_flush(bond_dev);\n\t\t\tdev_mc_flush(bond_dev);\n\n\t\t\tif (slave_dev->type != ARPHRD_ETHER)\n\t\t\t\tbond_setup_by_slave(bond_dev, slave_dev);\n\t\t\telse {\n\t\t\t\tether_setup(bond_dev);\n\t\t\t\tbond_dev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\t\t\t}\n\n\t\t\tnetdev_bonding_change(bond_dev,\n\t\t\t\t\t      NETDEV_POST_TYPE_CHANGE);\n\t\t}\n\t} else if (bond_dev->type != slave_dev->type) {\n\t\tpr_err(\"%s ether type (%d) is different from other slaves (%d), can not enslave it.\\n\",\n\t\t       slave_dev->name,\n\t\t       slave_dev->type, bond_dev->type);\n\t\tres = -EINVAL;\n\t\tgoto err_undo_flags;\n\t}\n\n\tif (slave_ops->ndo_set_mac_address == NULL) {\n\t\tif (bond->slave_cnt == 0) {\n\t\t\tpr_warning(\"%s: Warning: The first slave device specified does not support setting the MAC address. Setting fail_over_mac to active.\",\n\t\t\t\t   bond_dev->name);\n\t\t\tbond->params.fail_over_mac = BOND_FOM_ACTIVE;\n\t\t} else if (bond->params.fail_over_mac != BOND_FOM_ACTIVE) {\n\t\t\tpr_err(\"%s: Error: The slave device specified does not support setting the MAC address, but fail_over_mac is not set to active.\\n\",\n\t\t\t       bond_dev->name);\n\t\t\tres = -EOPNOTSUPP;\n\t\t\tgoto err_undo_flags;\n\t\t}\n\t}\n\n\tcall_netdevice_notifiers(NETDEV_JOIN, slave_dev);\n\n\t/* If this is the first slave, then we need to set the master's hardware\n\t * address to be the same as the slave's. */\n\tif (is_zero_ether_addr(bond->dev->dev_addr))\n\t\tmemcpy(bond->dev->dev_addr, slave_dev->dev_addr,\n\t\t       slave_dev->addr_len);\n\n\n\tnew_slave = kzalloc(sizeof(struct slave), GFP_KERNEL);\n\tif (!new_slave) {\n\t\tres = -ENOMEM;\n\t\tgoto err_undo_flags;\n\t}\n\n\t/*\n\t * Set the new_slave's queue_id to be zero.  Queue ID mapping\n\t * is set via sysfs or module option if desired.\n\t */\n\tnew_slave->queue_id = 0;\n\n\t/* Save slave's original mtu and then set it to match the bond */\n\tnew_slave->original_mtu = slave_dev->mtu;\n\tres = dev_set_mtu(slave_dev, bond->dev->mtu);\n\tif (res) {\n\t\tpr_debug(\"Error %d calling dev_set_mtu\\n\", res);\n\t\tgoto err_free;\n\t}\n\n\t/*\n\t * Save slave's original (\"permanent\") mac address for modes\n\t * that need it, and for restoring it upon release, and then\n\t * set it to the master's address\n\t */\n\tmemcpy(new_slave->perm_hwaddr, slave_dev->dev_addr, ETH_ALEN);\n\n\tif (!bond->params.fail_over_mac) {\n\t\t/*\n\t\t * Set slave to master's mac address.  The application already\n\t\t * set the master's mac address to that of the first slave\n\t\t */\n\t\tmemcpy(addr.sa_data, bond_dev->dev_addr, bond_dev->addr_len);\n\t\taddr.sa_family = slave_dev->type;\n\t\tres = dev_set_mac_address(slave_dev, &addr);\n\t\tif (res) {\n\t\t\tpr_debug(\"Error %d calling set_mac_address\\n\", res);\n\t\t\tgoto err_restore_mtu;\n\t\t}\n\t}\n\n\tres = netdev_set_bond_master(slave_dev, bond_dev);\n\tif (res) {\n\t\tpr_debug(\"Error %d calling netdev_set_bond_master\\n\", res);\n\t\tgoto err_restore_mac;\n\t}\n\n\t/* open the slave since the application closed it */\n\tres = dev_open(slave_dev);\n\tif (res) {\n\t\tpr_debug(\"Opening slave %s failed\\n\", slave_dev->name);\n\t\tgoto err_unset_master;\n\t}\n\n\tnew_slave->bond = bond;\n\tnew_slave->dev = slave_dev;\n\tslave_dev->priv_flags |= IFF_BONDING;\n\n\tif (bond_is_lb(bond)) {\n\t\t/* bond_alb_init_slave() must be called before all other stages since\n\t\t * it might fail and we do not want to have to undo everything\n\t\t */\n\t\tres = bond_alb_init_slave(bond, new_slave);\n\t\tif (res)\n\t\t\tgoto err_close;\n\t}\n\n\t/* If the mode USES_PRIMARY, then the new slave gets the\n\t * master's promisc (and mc) settings only if it becomes the\n\t * curr_active_slave, and that is taken care of later when calling\n\t * bond_change_active()\n\t */\n\tif (!USES_PRIMARY(bond->params.mode)) {\n\t\t/* set promiscuity level to new slave */\n\t\tif (bond_dev->flags & IFF_PROMISC) {\n\t\t\tres = dev_set_promiscuity(slave_dev, 1);\n\t\t\tif (res)\n\t\t\t\tgoto err_close;\n\t\t}\n\n\t\t/* set allmulti level to new slave */\n\t\tif (bond_dev->flags & IFF_ALLMULTI) {\n\t\t\tres = dev_set_allmulti(slave_dev, 1);\n\t\t\tif (res)\n\t\t\t\tgoto err_close;\n\t\t}\n\n\t\tnetif_addr_lock_bh(bond_dev);\n\t\t/* upload master's mc_list to new slave */\n\t\tnetdev_for_each_mc_addr(ha, bond_dev)\n\t\t\tdev_mc_add(slave_dev, ha->addr);\n\t\tnetif_addr_unlock_bh(bond_dev);\n\t}\n\n\tif (bond->params.mode == BOND_MODE_8023AD) {\n\t\t/* add lacpdu mc addr to mc list */\n\t\tu8 lacpdu_multicast[ETH_ALEN] = MULTICAST_LACPDU_ADDR;\n\n\t\tdev_mc_add(slave_dev, lacpdu_multicast);\n\t}\n\n\tbond_add_vlans_on_slave(bond, slave_dev);\n\n\twrite_lock_bh(&bond->lock);\n\n\tbond_attach_slave(bond, new_slave);\n\n\tnew_slave->delay = 0;\n\tnew_slave->link_failure_count = 0;\n\n\twrite_unlock_bh(&bond->lock);\n\n\tbond_compute_features(bond);\n\n\tread_lock(&bond->lock);\n\n\tnew_slave->last_arp_rx = jiffies;\n\n\tif (bond->params.miimon && !bond->params.use_carrier) {\n\t\tlink_reporting = bond_check_dev_link(bond, slave_dev, 1);\n\n\t\tif ((link_reporting == -1) && !bond->params.arp_interval) {\n\t\t\t/*\n\t\t\t * miimon is set but a bonded network driver\n\t\t\t * does not support ETHTOOL/MII and\n\t\t\t * arp_interval is not set.  Note: if\n\t\t\t * use_carrier is enabled, we will never go\n\t\t\t * here (because netif_carrier is always\n\t\t\t * supported); thus, we don't need to change\n\t\t\t * the messages for netif_carrier.\n\t\t\t */\n\t\t\tpr_warning(\"%s: Warning: MII and ETHTOOL support not available for interface %s, and arp_interval/arp_ip_target module parameters not specified, thus bonding will not detect link failures! see bonding.txt for details.\\n\",\n\t\t\t       bond_dev->name, slave_dev->name);\n\t\t} else if (link_reporting == -1) {\n\t\t\t/* unable get link status using mii/ethtool */\n\t\t\tpr_warning(\"%s: Warning: can't get link status from interface %s; the network driver associated with this interface does not support MII or ETHTOOL link status reporting, thus miimon has no effect on this interface.\\n\",\n\t\t\t\t   bond_dev->name, slave_dev->name);\n\t\t}\n\t}\n\n\t/* check for initial state */\n\tif (!bond->params.miimon ||\n\t    (bond_check_dev_link(bond, slave_dev, 0) == BMSR_LSTATUS)) {\n\t\tif (bond->params.updelay) {\n\t\t\tpr_debug(\"Initial state of slave_dev is BOND_LINK_BACK\\n\");\n\t\t\tnew_slave->link  = BOND_LINK_BACK;\n\t\t\tnew_slave->delay = bond->params.updelay;\n\t\t} else {\n\t\t\tpr_debug(\"Initial state of slave_dev is BOND_LINK_UP\\n\");\n\t\t\tnew_slave->link  = BOND_LINK_UP;\n\t\t}\n\t\tnew_slave->jiffies = jiffies;\n\t} else {\n\t\tpr_debug(\"Initial state of slave_dev is BOND_LINK_DOWN\\n\");\n\t\tnew_slave->link  = BOND_LINK_DOWN;\n\t}\n\n\tif (bond_update_speed_duplex(new_slave) &&\n\t    (new_slave->link != BOND_LINK_DOWN)) {\n\t\tpr_warning(\"%s: Warning: failed to get speed and duplex from %s, assumed to be 100Mb/sec and Full.\\n\",\n\t\t\t   bond_dev->name, new_slave->dev->name);\n\n\t\tif (bond->params.mode == BOND_MODE_8023AD) {\n\t\t\tpr_warning(\"%s: Warning: Operation of 802.3ad mode requires ETHTOOL support in base driver for proper aggregator selection.\\n\",\n\t\t\t\t   bond_dev->name);\n\t\t}\n\t}\n\n\tif (USES_PRIMARY(bond->params.mode) && bond->params.primary[0]) {\n\t\t/* if there is a primary slave, remember it */\n\t\tif (strcmp(bond->params.primary, new_slave->dev->name) == 0) {\n\t\t\tbond->primary_slave = new_slave;\n\t\t\tbond->force_primary = true;\n\t\t}\n\t}\n\n\twrite_lock_bh(&bond->curr_slave_lock);\n\n\tswitch (bond->params.mode) {\n\tcase BOND_MODE_ACTIVEBACKUP:\n\t\tbond_set_slave_inactive_flags(new_slave);\n\t\tbond_select_active_slave(bond);\n\t\tbreak;\n\tcase BOND_MODE_8023AD:\n\t\t/* in 802.3ad mode, the internal mechanism\n\t\t * will activate the slaves in the selected\n\t\t * aggregator\n\t\t */\n\t\tbond_set_slave_inactive_flags(new_slave);\n\t\t/* if this is the first slave */\n\t\tif (bond->slave_cnt == 1) {\n\t\t\tSLAVE_AD_INFO(new_slave).id = 1;\n\t\t\t/* Initialize AD with the number of times that the AD timer is called in 1 second\n\t\t\t * can be called only after the mac address of the bond is set\n\t\t\t */\n\t\t\tbond_3ad_initialize(bond, 1000/AD_TIMER_INTERVAL);\n\t\t} else {\n\t\t\tSLAVE_AD_INFO(new_slave).id =\n\t\t\t\tSLAVE_AD_INFO(new_slave->prev).id + 1;\n\t\t}\n\n\t\tbond_3ad_bind_slave(new_slave);\n\t\tbreak;\n\tcase BOND_MODE_TLB:\n\tcase BOND_MODE_ALB:\n\t\tbond_set_active_slave(new_slave);\n\t\tbond_set_slave_inactive_flags(new_slave);\n\t\tbond_select_active_slave(bond);\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"This slave is always active in trunk mode\\n\");\n\n\t\t/* always active in trunk mode */\n\t\tbond_set_active_slave(new_slave);\n\n\t\t/* In trunking mode there is little meaning to curr_active_slave\n\t\t * anyway (it holds no special properties of the bond device),\n\t\t * so we can change it without calling change_active_interface()\n\t\t */\n\t\tif (!bond->curr_active_slave)\n\t\t\tbond->curr_active_slave = new_slave;\n\n\t\tbreak;\n\t} /* switch(bond_mode) */\n\n\twrite_unlock_bh(&bond->curr_slave_lock);\n\n\tbond_set_carrier(bond);\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\tslave_dev->npinfo = bond_netpoll_info(bond);\n\tif (slave_dev->npinfo) {\n\t\tif (slave_enable_netpoll(new_slave)) {\n\t\t\tread_unlock(&bond->lock);\n\t\t\tpr_info(\"Error, %s: master_dev is using netpoll, \"\n\t\t\t\t \"but new slave device does not support netpoll.\\n\",\n\t\t\t\t bond_dev->name);\n\t\t\tres = -EBUSY;\n\t\t\tgoto err_close;\n\t\t}\n\t}\n#endif\n\n\tread_unlock(&bond->lock);\n\n\tres = bond_create_slave_symlinks(bond_dev, slave_dev);\n\tif (res)\n\t\tgoto err_close;\n\n\tres = netdev_rx_handler_register(slave_dev, bond_handle_frame,\n\t\t\t\t\t new_slave);\n\tif (res) {\n\t\tpr_debug(\"Error %d calling netdev_rx_handler_register\\n\", res);\n\t\tgoto err_dest_symlinks;\n\t}\n\n\tpr_info(\"%s: enslaving %s as a%s interface with a%s link.\\n\",\n\t\tbond_dev->name, slave_dev->name,\n\t\tbond_is_active_slave(new_slave) ? \"n active\" : \" backup\",\n\t\tnew_slave->link != BOND_LINK_DOWN ? \"n up\" : \" down\");\n\n\t/* enslave is successful */\n\treturn 0;\n\n/* Undo stages on error */\nerr_dest_symlinks:\n\tbond_destroy_slave_symlinks(bond_dev, slave_dev);\n\nerr_close:\n\tdev_close(slave_dev);\n\nerr_unset_master:\n\tnetdev_set_bond_master(slave_dev, NULL);\n\nerr_restore_mac:\n\tif (!bond->params.fail_over_mac) {\n\t\t/* XXX TODO - fom follow mode needs to change master's\n\t\t * MAC if this slave's MAC is in use by the bond, or at\n\t\t * least print a warning.\n\t\t */\n\t\tmemcpy(addr.sa_data, new_slave->perm_hwaddr, ETH_ALEN);\n\t\taddr.sa_family = slave_dev->type;\n\t\tdev_set_mac_address(slave_dev, &addr);\n\t}\n\nerr_restore_mtu:\n\tdev_set_mtu(slave_dev, new_slave->original_mtu);\n\nerr_free:\n\tkfree(new_slave);\n\nerr_undo_flags:\n\tbond_compute_features(bond);\n\n\treturn res;\n}\n\n/*\n * Try to release the slave device <slave> from the bond device <master>\n * It is legal to access curr_active_slave without a lock because all the function\n * is write-locked.\n *\n * The rules for slave state should be:\n *   for Active/Backup:\n *     Active stays on all backups go down\n *   for Bonded connections:\n *     The first up interface should be left on and all others downed.\n */\nint bond_release(struct net_device *bond_dev, struct net_device *slave_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct slave *slave, *oldcurrent;\n\tstruct sockaddr addr;\n\tu32 old_features = bond_dev->features;\n\n\t/* slave is not a slave or master is not master of this slave */\n\tif (!(slave_dev->flags & IFF_SLAVE) ||\n\t    (slave_dev->master != bond_dev)) {\n\t\tpr_err(\"%s: Error: cannot release %s.\\n\",\n\t\t       bond_dev->name, slave_dev->name);\n\t\treturn -EINVAL;\n\t}\n\n\tblock_netpoll_tx();\n\tnetdev_bonding_change(bond_dev, NETDEV_RELEASE);\n\twrite_lock_bh(&bond->lock);\n\n\tslave = bond_get_slave_by_dev(bond, slave_dev);\n\tif (!slave) {\n\t\t/* not a slave of this bond */\n\t\tpr_info(\"%s: %s not enslaved\\n\",\n\t\t\tbond_dev->name, slave_dev->name);\n\t\twrite_unlock_bh(&bond->lock);\n\t\tunblock_netpoll_tx();\n\t\treturn -EINVAL;\n\t}\n\n\t/* unregister rx_handler early so bond_handle_frame wouldn't be called\n\t * for this slave anymore.\n\t */\n\tnetdev_rx_handler_unregister(slave_dev);\n\twrite_unlock_bh(&bond->lock);\n\tsynchronize_net();\n\twrite_lock_bh(&bond->lock);\n\n\tif (!bond->params.fail_over_mac) {\n\t\tif (!compare_ether_addr(bond_dev->dev_addr, slave->perm_hwaddr) &&\n\t\t    bond->slave_cnt > 1)\n\t\t\tpr_warning(\"%s: Warning: the permanent HWaddr of %s - %pM - is still in use by %s. Set the HWaddr of %s to a different address to avoid conflicts.\\n\",\n\t\t\t\t   bond_dev->name, slave_dev->name,\n\t\t\t\t   slave->perm_hwaddr,\n\t\t\t\t   bond_dev->name, slave_dev->name);\n\t}\n\n\t/* Inform AD package of unbinding of slave. */\n\tif (bond->params.mode == BOND_MODE_8023AD) {\n\t\t/* must be called before the slave is\n\t\t * detached from the list\n\t\t */\n\t\tbond_3ad_unbind_slave(slave);\n\t}\n\n\tpr_info(\"%s: releasing %s interface %s\\n\",\n\t\tbond_dev->name,\n\t\tbond_is_active_slave(slave) ? \"active\" : \"backup\",\n\t\tslave_dev->name);\n\n\toldcurrent = bond->curr_active_slave;\n\n\tbond->current_arp_slave = NULL;\n\n\t/* release the slave from its bond */\n\tbond_detach_slave(bond, slave);\n\n\tif (bond->primary_slave == slave)\n\t\tbond->primary_slave = NULL;\n\n\tif (oldcurrent == slave)\n\t\tbond_change_active_slave(bond, NULL);\n\n\tif (bond_is_lb(bond)) {\n\t\t/* Must be called only after the slave has been\n\t\t * detached from the list and the curr_active_slave\n\t\t * has been cleared (if our_slave == old_current),\n\t\t * but before a new active slave is selected.\n\t\t */\n\t\twrite_unlock_bh(&bond->lock);\n\t\tbond_alb_deinit_slave(bond, slave);\n\t\twrite_lock_bh(&bond->lock);\n\t}\n\n\tif (oldcurrent == slave) {\n\t\t/*\n\t\t * Note that we hold RTNL over this sequence, so there\n\t\t * is no concern that another slave add/remove event\n\t\t * will interfere.\n\t\t */\n\t\twrite_unlock_bh(&bond->lock);\n\t\tread_lock(&bond->lock);\n\t\twrite_lock_bh(&bond->curr_slave_lock);\n\n\t\tbond_select_active_slave(bond);\n\n\t\twrite_unlock_bh(&bond->curr_slave_lock);\n\t\tread_unlock(&bond->lock);\n\t\twrite_lock_bh(&bond->lock);\n\t}\n\n\tif (bond->slave_cnt == 0) {\n\t\tbond_set_carrier(bond);\n\n\t\t/* if the last slave was removed, zero the mac address\n\t\t * of the master so it will be set by the application\n\t\t * to the mac address of the first slave\n\t\t */\n\t\tmemset(bond_dev->dev_addr, 0, bond_dev->addr_len);\n\n\t\tif (bond_vlan_used(bond)) {\n\t\t\tpr_warning(\"%s: Warning: clearing HW address of %s while it still has VLANs.\\n\",\n\t\t\t\t   bond_dev->name, bond_dev->name);\n\t\t\tpr_warning(\"%s: When re-adding slaves, make sure the bond's HW address matches its VLANs'.\\n\",\n\t\t\t\t   bond_dev->name);\n\t\t}\n\t}\n\n\twrite_unlock_bh(&bond->lock);\n\tunblock_netpoll_tx();\n\n\tbond_compute_features(bond);\n\tif (!(bond_dev->features & NETIF_F_VLAN_CHALLENGED) &&\n\t    (old_features & NETIF_F_VLAN_CHALLENGED))\n\t\tpr_info(\"%s: last VLAN challenged slave %s left bond %s. VLAN blocking is removed\\n\",\n\t\t\tbond_dev->name, slave_dev->name, bond_dev->name);\n\n\t/* must do this from outside any spinlocks */\n\tbond_destroy_slave_symlinks(bond_dev, slave_dev);\n\n\tbond_del_vlans_from_slave(bond, slave_dev);\n\n\t/* If the mode USES_PRIMARY, then we should only remove its\n\t * promisc and mc settings if it was the curr_active_slave, but that was\n\t * already taken care of above when we detached the slave\n\t */\n\tif (!USES_PRIMARY(bond->params.mode)) {\n\t\t/* unset promiscuity level from slave */\n\t\tif (bond_dev->flags & IFF_PROMISC)\n\t\t\tdev_set_promiscuity(slave_dev, -1);\n\n\t\t/* unset allmulti level from slave */\n\t\tif (bond_dev->flags & IFF_ALLMULTI)\n\t\t\tdev_set_allmulti(slave_dev, -1);\n\n\t\t/* flush master's mc_list from slave */\n\t\tnetif_addr_lock_bh(bond_dev);\n\t\tbond_mc_list_flush(bond_dev, slave_dev);\n\t\tnetif_addr_unlock_bh(bond_dev);\n\t}\n\n\tnetdev_set_bond_master(slave_dev, NULL);\n\n\tslave_disable_netpoll(slave);\n\n\t/* close slave before restoring its mac address */\n\tdev_close(slave_dev);\n\n\tif (bond->params.fail_over_mac != BOND_FOM_ACTIVE) {\n\t\t/* restore original (\"permanent\") mac address */\n\t\tmemcpy(addr.sa_data, slave->perm_hwaddr, ETH_ALEN);\n\t\taddr.sa_family = slave_dev->type;\n\t\tdev_set_mac_address(slave_dev, &addr);\n\t}\n\n\tdev_set_mtu(slave_dev, slave->original_mtu);\n\n\tslave_dev->priv_flags &= ~IFF_BONDING;\n\n\tkfree(slave);\n\n\treturn 0;  /* deletion OK */\n}\n\n/*\n* First release a slave and then destroy the bond if no more slaves are left.\n* Must be under rtnl_lock when this function is called.\n*/\nstatic int  bond_release_and_destroy(struct net_device *bond_dev,\n\t\t\t\t     struct net_device *slave_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tint ret;\n\n\tret = bond_release(bond_dev, slave_dev);\n\tif ((ret == 0) && (bond->slave_cnt == 0)) {\n\t\tbond_dev->priv_flags |= IFF_DISABLE_NETPOLL;\n\t\tpr_info(\"%s: destroying bond %s.\\n\",\n\t\t\tbond_dev->name, bond_dev->name);\n\t\tunregister_netdevice(bond_dev);\n\t}\n\treturn ret;\n}\n\n/*\n * This function releases all slaves.\n */\nstatic int bond_release_all(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct slave *slave;\n\tstruct net_device *slave_dev;\n\tstruct sockaddr addr;\n\n\twrite_lock_bh(&bond->lock);\n\n\tnetif_carrier_off(bond_dev);\n\n\tif (bond->slave_cnt == 0)\n\t\tgoto out;\n\n\tbond->current_arp_slave = NULL;\n\tbond->primary_slave = NULL;\n\tbond_change_active_slave(bond, NULL);\n\n\twhile ((slave = bond->first_slave) != NULL) {\n\t\t/* Inform AD package of unbinding of slave\n\t\t * before slave is detached from the list.\n\t\t */\n\t\tif (bond->params.mode == BOND_MODE_8023AD)\n\t\t\tbond_3ad_unbind_slave(slave);\n\n\t\tslave_dev = slave->dev;\n\t\tbond_detach_slave(bond, slave);\n\n\t\t/* now that the slave is detached, unlock and perform\n\t\t * all the undo steps that should not be called from\n\t\t * within a lock.\n\t\t */\n\t\twrite_unlock_bh(&bond->lock);\n\n\t\t/* unregister rx_handler early so bond_handle_frame wouldn't\n\t\t * be called for this slave anymore.\n\t\t */\n\t\tnetdev_rx_handler_unregister(slave_dev);\n\t\tsynchronize_net();\n\n\t\tif (bond_is_lb(bond)) {\n\t\t\t/* must be called only after the slave\n\t\t\t * has been detached from the list\n\t\t\t */\n\t\t\tbond_alb_deinit_slave(bond, slave);\n\t\t}\n\n\t\tbond_destroy_slave_symlinks(bond_dev, slave_dev);\n\t\tbond_del_vlans_from_slave(bond, slave_dev);\n\n\t\t/* If the mode USES_PRIMARY, then we should only remove its\n\t\t * promisc and mc settings if it was the curr_active_slave, but that was\n\t\t * already taken care of above when we detached the slave\n\t\t */\n\t\tif (!USES_PRIMARY(bond->params.mode)) {\n\t\t\t/* unset promiscuity level from slave */\n\t\t\tif (bond_dev->flags & IFF_PROMISC)\n\t\t\t\tdev_set_promiscuity(slave_dev, -1);\n\n\t\t\t/* unset allmulti level from slave */\n\t\t\tif (bond_dev->flags & IFF_ALLMULTI)\n\t\t\t\tdev_set_allmulti(slave_dev, -1);\n\n\t\t\t/* flush master's mc_list from slave */\n\t\t\tnetif_addr_lock_bh(bond_dev);\n\t\t\tbond_mc_list_flush(bond_dev, slave_dev);\n\t\t\tnetif_addr_unlock_bh(bond_dev);\n\t\t}\n\n\t\tnetdev_set_bond_master(slave_dev, NULL);\n\n\t\tslave_disable_netpoll(slave);\n\n\t\t/* close slave before restoring its mac address */\n\t\tdev_close(slave_dev);\n\n\t\tif (!bond->params.fail_over_mac) {\n\t\t\t/* restore original (\"permanent\") mac address*/\n\t\t\tmemcpy(addr.sa_data, slave->perm_hwaddr, ETH_ALEN);\n\t\t\taddr.sa_family = slave_dev->type;\n\t\t\tdev_set_mac_address(slave_dev, &addr);\n\t\t}\n\n\t\tkfree(slave);\n\n\t\t/* re-acquire the lock before getting the next slave */\n\t\twrite_lock_bh(&bond->lock);\n\t}\n\n\t/* zero the mac address of the master so it will be\n\t * set by the application to the mac address of the\n\t * first slave\n\t */\n\tmemset(bond_dev->dev_addr, 0, bond_dev->addr_len);\n\n\tif (bond_vlan_used(bond)) {\n\t\tpr_warning(\"%s: Warning: clearing HW address of %s while it still has VLANs.\\n\",\n\t\t\t   bond_dev->name, bond_dev->name);\n\t\tpr_warning(\"%s: When re-adding slaves, make sure the bond's HW address matches its VLANs'.\\n\",\n\t\t\t   bond_dev->name);\n\t}\n\n\tpr_info(\"%s: released all slaves\\n\", bond_dev->name);\n\nout:\n\twrite_unlock_bh(&bond->lock);\n\n\tbond_compute_features(bond);\n\n\treturn 0;\n}\n\n/*\n * This function changes the active slave to slave <slave_dev>.\n * It returns -EINVAL in the following cases.\n *  - <slave_dev> is not found in the list.\n *  - There is not active slave now.\n *  - <slave_dev> is already active.\n *  - The link state of <slave_dev> is not BOND_LINK_UP.\n *  - <slave_dev> is not running.\n * In these cases, this function does nothing.\n * In the other cases, current_slave pointer is changed and 0 is returned.\n */\nstatic int bond_ioctl_change_active(struct net_device *bond_dev, struct net_device *slave_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct slave *old_active = NULL;\n\tstruct slave *new_active = NULL;\n\tint res = 0;\n\n\tif (!USES_PRIMARY(bond->params.mode))\n\t\treturn -EINVAL;\n\n\t/* Verify that master_dev is indeed the master of slave_dev */\n\tif (!(slave_dev->flags & IFF_SLAVE) || (slave_dev->master != bond_dev))\n\t\treturn -EINVAL;\n\n\tread_lock(&bond->lock);\n\n\tread_lock(&bond->curr_slave_lock);\n\told_active = bond->curr_active_slave;\n\tread_unlock(&bond->curr_slave_lock);\n\n\tnew_active = bond_get_slave_by_dev(bond, slave_dev);\n\n\t/*\n\t * Changing to the current active: do nothing; return success.\n\t */\n\tif (new_active && (new_active == old_active)) {\n\t\tread_unlock(&bond->lock);\n\t\treturn 0;\n\t}\n\n\tif ((new_active) &&\n\t    (old_active) &&\n\t    (new_active->link == BOND_LINK_UP) &&\n\t    IS_UP(new_active->dev)) {\n\t\tblock_netpoll_tx();\n\t\twrite_lock_bh(&bond->curr_slave_lock);\n\t\tbond_change_active_slave(bond, new_active);\n\t\twrite_unlock_bh(&bond->curr_slave_lock);\n\t\tunblock_netpoll_tx();\n\t} else\n\t\tres = -EINVAL;\n\n\tread_unlock(&bond->lock);\n\n\treturn res;\n}\n\nstatic int bond_info_query(struct net_device *bond_dev, struct ifbond *info)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\n\tinfo->bond_mode = bond->params.mode;\n\tinfo->miimon = bond->params.miimon;\n\n\tread_lock(&bond->lock);\n\tinfo->num_slaves = bond->slave_cnt;\n\tread_unlock(&bond->lock);\n\n\treturn 0;\n}\n\nstatic int bond_slave_info_query(struct net_device *bond_dev, struct ifslave *info)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct slave *slave;\n\tint i, res = -ENODEV;\n\n\tread_lock(&bond->lock);\n\n\tbond_for_each_slave(bond, slave, i) {\n\t\tif (i == (int)info->slave_id) {\n\t\t\tres = 0;\n\t\t\tstrcpy(info->slave_name, slave->dev->name);\n\t\t\tinfo->link = slave->link;\n\t\t\tinfo->state = bond_slave_state(slave);\n\t\t\tinfo->link_failure_count = slave->link_failure_count;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tread_unlock(&bond->lock);\n\n\treturn res;\n}\n\n/*-------------------------------- Monitoring -------------------------------*/\n\n\nstatic int bond_miimon_inspect(struct bonding *bond)\n{\n\tstruct slave *slave;\n\tint i, link_state, commit = 0;\n\tbool ignore_updelay;\n\n\tignore_updelay = !bond->curr_active_slave ? true : false;\n\n\tbond_for_each_slave(bond, slave, i) {\n\t\tslave->new_link = BOND_LINK_NOCHANGE;\n\n\t\tlink_state = bond_check_dev_link(bond, slave->dev, 0);\n\n\t\tswitch (slave->link) {\n\t\tcase BOND_LINK_UP:\n\t\t\tif (link_state)\n\t\t\t\tcontinue;\n\n\t\t\tslave->link = BOND_LINK_FAIL;\n\t\t\tslave->delay = bond->params.downdelay;\n\t\t\tif (slave->delay) {\n\t\t\t\tpr_info(\"%s: link status down for %sinterface %s, disabling it in %d ms.\\n\",\n\t\t\t\t\tbond->dev->name,\n\t\t\t\t\t(bond->params.mode ==\n\t\t\t\t\t BOND_MODE_ACTIVEBACKUP) ?\n\t\t\t\t\t(bond_is_active_slave(slave) ?\n\t\t\t\t\t \"active \" : \"backup \") : \"\",\n\t\t\t\t\tslave->dev->name,\n\t\t\t\t\tbond->params.downdelay * bond->params.miimon);\n\t\t\t}\n\t\t\t/*FALLTHRU*/\n\t\tcase BOND_LINK_FAIL:\n\t\t\tif (link_state) {\n\t\t\t\t/*\n\t\t\t\t * recovered before downdelay expired\n\t\t\t\t */\n\t\t\t\tslave->link = BOND_LINK_UP;\n\t\t\t\tslave->jiffies = jiffies;\n\t\t\t\tpr_info(\"%s: link status up again after %d ms for interface %s.\\n\",\n\t\t\t\t\tbond->dev->name,\n\t\t\t\t\t(bond->params.downdelay - slave->delay) *\n\t\t\t\t\tbond->params.miimon,\n\t\t\t\t\tslave->dev->name);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (slave->delay <= 0) {\n\t\t\t\tslave->new_link = BOND_LINK_DOWN;\n\t\t\t\tcommit++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tslave->delay--;\n\t\t\tbreak;\n\n\t\tcase BOND_LINK_DOWN:\n\t\t\tif (!link_state)\n\t\t\t\tcontinue;\n\n\t\t\tslave->link = BOND_LINK_BACK;\n\t\t\tslave->delay = bond->params.updelay;\n\n\t\t\tif (slave->delay) {\n\t\t\t\tpr_info(\"%s: link status up for interface %s, enabling it in %d ms.\\n\",\n\t\t\t\t\tbond->dev->name, slave->dev->name,\n\t\t\t\t\tignore_updelay ? 0 :\n\t\t\t\t\tbond->params.updelay *\n\t\t\t\t\tbond->params.miimon);\n\t\t\t}\n\t\t\t/*FALLTHRU*/\n\t\tcase BOND_LINK_BACK:\n\t\t\tif (!link_state) {\n\t\t\t\tslave->link = BOND_LINK_DOWN;\n\t\t\t\tpr_info(\"%s: link status down again after %d ms for interface %s.\\n\",\n\t\t\t\t\tbond->dev->name,\n\t\t\t\t\t(bond->params.updelay - slave->delay) *\n\t\t\t\t\tbond->params.miimon,\n\t\t\t\t\tslave->dev->name);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (ignore_updelay)\n\t\t\t\tslave->delay = 0;\n\n\t\t\tif (slave->delay <= 0) {\n\t\t\t\tslave->new_link = BOND_LINK_UP;\n\t\t\t\tcommit++;\n\t\t\t\tignore_updelay = false;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tslave->delay--;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn commit;\n}\n\nstatic void bond_miimon_commit(struct bonding *bond)\n{\n\tstruct slave *slave;\n\tint i;\n\n\tbond_for_each_slave(bond, slave, i) {\n\t\tswitch (slave->new_link) {\n\t\tcase BOND_LINK_NOCHANGE:\n\t\t\tcontinue;\n\n\t\tcase BOND_LINK_UP:\n\t\t\tslave->link = BOND_LINK_UP;\n\t\t\tslave->jiffies = jiffies;\n\n\t\t\tif (bond->params.mode == BOND_MODE_8023AD) {\n\t\t\t\t/* prevent it from being the active one */\n\t\t\t\tbond_set_backup_slave(slave);\n\t\t\t} else if (bond->params.mode != BOND_MODE_ACTIVEBACKUP) {\n\t\t\t\t/* make it immediately active */\n\t\t\t\tbond_set_active_slave(slave);\n\t\t\t} else if (slave != bond->primary_slave) {\n\t\t\t\t/* prevent it from being the active one */\n\t\t\t\tbond_set_backup_slave(slave);\n\t\t\t}\n\n\t\t\tbond_update_speed_duplex(slave);\n\n\t\t\tpr_info(\"%s: link status definitely up for interface %s, %u Mbps %s duplex.\\n\",\n\t\t\t\tbond->dev->name, slave->dev->name,\n\t\t\t\tslave->speed, slave->duplex ? \"full\" : \"half\");\n\n\t\t\t/* notify ad that the link status has changed */\n\t\t\tif (bond->params.mode == BOND_MODE_8023AD)\n\t\t\t\tbond_3ad_handle_link_change(slave, BOND_LINK_UP);\n\n\t\t\tif (bond_is_lb(bond))\n\t\t\t\tbond_alb_handle_link_change(bond, slave,\n\t\t\t\t\t\t\t    BOND_LINK_UP);\n\n\t\t\tif (!bond->curr_active_slave ||\n\t\t\t    (slave == bond->primary_slave))\n\t\t\t\tgoto do_failover;\n\n\t\t\tcontinue;\n\n\t\tcase BOND_LINK_DOWN:\n\t\t\tif (slave->link_failure_count < UINT_MAX)\n\t\t\t\tslave->link_failure_count++;\n\n\t\t\tslave->link = BOND_LINK_DOWN;\n\n\t\t\tif (bond->params.mode == BOND_MODE_ACTIVEBACKUP ||\n\t\t\t    bond->params.mode == BOND_MODE_8023AD)\n\t\t\t\tbond_set_slave_inactive_flags(slave);\n\n\t\t\tpr_info(\"%s: link status definitely down for interface %s, disabling it\\n\",\n\t\t\t\tbond->dev->name, slave->dev->name);\n\n\t\t\tif (bond->params.mode == BOND_MODE_8023AD)\n\t\t\t\tbond_3ad_handle_link_change(slave,\n\t\t\t\t\t\t\t    BOND_LINK_DOWN);\n\n\t\t\tif (bond_is_lb(bond))\n\t\t\t\tbond_alb_handle_link_change(bond, slave,\n\t\t\t\t\t\t\t    BOND_LINK_DOWN);\n\n\t\t\tif (slave == bond->curr_active_slave)\n\t\t\t\tgoto do_failover;\n\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\tpr_err(\"%s: invalid new link %d on slave %s\\n\",\n\t\t\t       bond->dev->name, slave->new_link,\n\t\t\t       slave->dev->name);\n\t\t\tslave->new_link = BOND_LINK_NOCHANGE;\n\n\t\t\tcontinue;\n\t\t}\n\ndo_failover:\n\t\tASSERT_RTNL();\n\t\tblock_netpoll_tx();\n\t\twrite_lock_bh(&bond->curr_slave_lock);\n\t\tbond_select_active_slave(bond);\n\t\twrite_unlock_bh(&bond->curr_slave_lock);\n\t\tunblock_netpoll_tx();\n\t}\n\n\tbond_set_carrier(bond);\n}\n\n/*\n * bond_mii_monitor\n *\n * Really a wrapper that splits the mii monitor into two phases: an\n * inspection, then (if inspection indicates something needs to be done)\n * an acquisition of appropriate locks followed by a commit phase to\n * implement whatever link state changes are indicated.\n */\nvoid bond_mii_monitor(struct work_struct *work)\n{\n\tstruct bonding *bond = container_of(work, struct bonding,\n\t\t\t\t\t    mii_work.work);\n\tbool should_notify_peers = false;\n\n\tread_lock(&bond->lock);\n\tif (bond->kill_timers)\n\t\tgoto out;\n\n\tif (bond->slave_cnt == 0)\n\t\tgoto re_arm;\n\n\tshould_notify_peers = bond_should_notify_peers(bond);\n\n\tif (bond_miimon_inspect(bond)) {\n\t\tread_unlock(&bond->lock);\n\t\trtnl_lock();\n\t\tread_lock(&bond->lock);\n\n\t\tbond_miimon_commit(bond);\n\n\t\tread_unlock(&bond->lock);\n\t\trtnl_unlock();\t/* might sleep, hold no other locks */\n\t\tread_lock(&bond->lock);\n\t}\n\nre_arm:\n\tif (bond->params.miimon)\n\t\tqueue_delayed_work(bond->wq, &bond->mii_work,\n\t\t\t\t   msecs_to_jiffies(bond->params.miimon));\nout:\n\tread_unlock(&bond->lock);\n\n\tif (should_notify_peers) {\n\t\trtnl_lock();\n\t\tnetdev_bonding_change(bond->dev, NETDEV_NOTIFY_PEERS);\n\t\trtnl_unlock();\n\t}\n}\n\nstatic __be32 bond_glean_dev_ip(struct net_device *dev)\n{\n\tstruct in_device *idev;\n\tstruct in_ifaddr *ifa;\n\t__be32 addr = 0;\n\n\tif (!dev)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tidev = __in_dev_get_rcu(dev);\n\tif (!idev)\n\t\tgoto out;\n\n\tifa = idev->ifa_list;\n\tif (!ifa)\n\t\tgoto out;\n\n\taddr = ifa->ifa_local;\nout:\n\trcu_read_unlock();\n\treturn addr;\n}\n\nstatic int bond_has_this_ip(struct bonding *bond, __be32 ip)\n{\n\tstruct vlan_entry *vlan;\n\n\tif (ip == bond->master_ip)\n\t\treturn 1;\n\n\tlist_for_each_entry(vlan, &bond->vlan_list, vlan_list) {\n\t\tif (ip == vlan->vlan_ip)\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n/*\n * We go to the (large) trouble of VLAN tagging ARP frames because\n * switches in VLAN mode (especially if ports are configured as\n * \"native\" to a VLAN) might not pass non-tagged frames.\n */\nstatic void bond_arp_send(struct net_device *slave_dev, int arp_op, __be32 dest_ip, __be32 src_ip, unsigned short vlan_id)\n{\n\tstruct sk_buff *skb;\n\n\tpr_debug(\"arp %d on slave %s: dst %x src %x vid %d\\n\", arp_op,\n\t\t slave_dev->name, dest_ip, src_ip, vlan_id);\n\n\tskb = arp_create(arp_op, ETH_P_ARP, dest_ip, slave_dev, src_ip,\n\t\t\t NULL, slave_dev->dev_addr, NULL);\n\n\tif (!skb) {\n\t\tpr_err(\"ARP packet allocation failed\\n\");\n\t\treturn;\n\t}\n\tif (vlan_id) {\n\t\tskb = vlan_put_tag(skb, vlan_id);\n\t\tif (!skb) {\n\t\t\tpr_err(\"failed to insert VLAN tag\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\tarp_xmit(skb);\n}\n\n\nstatic void bond_arp_send_all(struct bonding *bond, struct slave *slave)\n{\n\tint i, vlan_id;\n\t__be32 *targets = bond->params.arp_targets;\n\tstruct vlan_entry *vlan;\n\tstruct net_device *vlan_dev;\n\tstruct rtable *rt;\n\n\tfor (i = 0; (i < BOND_MAX_ARP_TARGETS); i++) {\n\t\tif (!targets[i])\n\t\t\tbreak;\n\t\tpr_debug(\"basa: target %x\\n\", targets[i]);\n\t\tif (!bond_vlan_used(bond)) {\n\t\t\tpr_debug(\"basa: empty vlan: arp_send\\n\");\n\t\t\tbond_arp_send(slave->dev, ARPOP_REQUEST, targets[i],\n\t\t\t\t      bond->master_ip, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * If VLANs are configured, we do a route lookup to\n\t\t * determine which VLAN interface would be used, so we\n\t\t * can tag the ARP with the proper VLAN tag.\n\t\t */\n\t\trt = ip_route_output(dev_net(bond->dev), targets[i], 0,\n\t\t\t\t     RTO_ONLINK, 0);\n\t\tif (IS_ERR(rt)) {\n\t\t\tif (net_ratelimit()) {\n\t\t\t\tpr_warning(\"%s: no route to arp_ip_target %pI4\\n\",\n\t\t\t\t\t   bond->dev->name, &targets[i]);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * This target is not on a VLAN\n\t\t */\n\t\tif (rt->dst.dev == bond->dev) {\n\t\t\tip_rt_put(rt);\n\t\t\tpr_debug(\"basa: rtdev == bond->dev: arp_send\\n\");\n\t\t\tbond_arp_send(slave->dev, ARPOP_REQUEST, targets[i],\n\t\t\t\t      bond->master_ip, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\tvlan_id = 0;\n\t\tlist_for_each_entry(vlan, &bond->vlan_list, vlan_list) {\n\t\t\trcu_read_lock();\n\t\t\tvlan_dev = __vlan_find_dev_deep(bond->dev,\n\t\t\t\t\t\t\tvlan->vlan_id);\n\t\t\trcu_read_unlock();\n\t\t\tif (vlan_dev == rt->dst.dev) {\n\t\t\t\tvlan_id = vlan->vlan_id;\n\t\t\t\tpr_debug(\"basa: vlan match on %s %d\\n\",\n\t\t\t\t       vlan_dev->name, vlan_id);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (vlan_id) {\n\t\t\tip_rt_put(rt);\n\t\t\tbond_arp_send(slave->dev, ARPOP_REQUEST, targets[i],\n\t\t\t\t      vlan->vlan_ip, vlan_id);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (net_ratelimit()) {\n\t\t\tpr_warning(\"%s: no path to arp_ip_target %pI4 via rt.dev %s\\n\",\n\t\t\t\t   bond->dev->name, &targets[i],\n\t\t\t\t   rt->dst.dev ? rt->dst.dev->name : \"NULL\");\n\t\t}\n\t\tip_rt_put(rt);\n\t}\n}\n\nstatic void bond_validate_arp(struct bonding *bond, struct slave *slave, __be32 sip, __be32 tip)\n{\n\tint i;\n\t__be32 *targets = bond->params.arp_targets;\n\n\tfor (i = 0; (i < BOND_MAX_ARP_TARGETS) && targets[i]; i++) {\n\t\tpr_debug(\"bva: sip %pI4 tip %pI4 t[%d] %pI4 bhti(tip) %d\\n\",\n\t\t\t &sip, &tip, i, &targets[i],\n\t\t\t bond_has_this_ip(bond, tip));\n\t\tif (sip == targets[i]) {\n\t\t\tif (bond_has_this_ip(bond, tip))\n\t\t\t\tslave->last_arp_rx = jiffies;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void bond_arp_rcv(struct sk_buff *skb, struct bonding *bond,\n\t\t\t struct slave *slave)\n{\n\tstruct arphdr *arp;\n\tunsigned char *arp_ptr;\n\t__be32 sip, tip;\n\n\tif (skb->protocol != __cpu_to_be16(ETH_P_ARP))\n\t\treturn;\n\n\tread_lock(&bond->lock);\n\n\tpr_debug(\"bond_arp_rcv: bond %s skb->dev %s\\n\",\n\t\t bond->dev->name, skb->dev->name);\n\n\tif (!pskb_may_pull(skb, arp_hdr_len(bond->dev)))\n\t\tgoto out_unlock;\n\n\tarp = arp_hdr(skb);\n\tif (arp->ar_hln != bond->dev->addr_len ||\n\t    skb->pkt_type == PACKET_OTHERHOST ||\n\t    skb->pkt_type == PACKET_LOOPBACK ||\n\t    arp->ar_hrd != htons(ARPHRD_ETHER) ||\n\t    arp->ar_pro != htons(ETH_P_IP) ||\n\t    arp->ar_pln != 4)\n\t\tgoto out_unlock;\n\n\tarp_ptr = (unsigned char *)(arp + 1);\n\tarp_ptr += bond->dev->addr_len;\n\tmemcpy(&sip, arp_ptr, 4);\n\tarp_ptr += 4 + bond->dev->addr_len;\n\tmemcpy(&tip, arp_ptr, 4);\n\n\tpr_debug(\"bond_arp_rcv: %s %s/%d av %d sv %d sip %pI4 tip %pI4\\n\",\n\t\t bond->dev->name, slave->dev->name, bond_slave_state(slave),\n\t\t bond->params.arp_validate, slave_do_arp_validate(bond, slave),\n\t\t &sip, &tip);\n\n\t/*\n\t * Backup slaves won't see the ARP reply, but do come through\n\t * here for each ARP probe (so we swap the sip/tip to validate\n\t * the probe).  In a \"redundant switch, common router\" type of\n\t * configuration, the ARP probe will (hopefully) travel from\n\t * the active, through one switch, the router, then the other\n\t * switch before reaching the backup.\n\t */\n\tif (bond_is_active_slave(slave))\n\t\tbond_validate_arp(bond, slave, sip, tip);\n\telse\n\t\tbond_validate_arp(bond, slave, tip, sip);\n\nout_unlock:\n\tread_unlock(&bond->lock);\n}\n\n/*\n * this function is called regularly to monitor each slave's link\n * ensuring that traffic is being sent and received when arp monitoring\n * is used in load-balancing mode. if the adapter has been dormant, then an\n * arp is transmitted to generate traffic. see activebackup_arp_monitor for\n * arp monitoring in active backup mode.\n */\nvoid bond_loadbalance_arp_mon(struct work_struct *work)\n{\n\tstruct bonding *bond = container_of(work, struct bonding,\n\t\t\t\t\t    arp_work.work);\n\tstruct slave *slave, *oldcurrent;\n\tint do_failover = 0;\n\tint delta_in_ticks;\n\tint i;\n\n\tread_lock(&bond->lock);\n\n\tdelta_in_ticks = msecs_to_jiffies(bond->params.arp_interval);\n\n\tif (bond->kill_timers)\n\t\tgoto out;\n\n\tif (bond->slave_cnt == 0)\n\t\tgoto re_arm;\n\n\tread_lock(&bond->curr_slave_lock);\n\toldcurrent = bond->curr_active_slave;\n\tread_unlock(&bond->curr_slave_lock);\n\n\t/* see if any of the previous devices are up now (i.e. they have\n\t * xmt and rcv traffic). the curr_active_slave does not come into\n\t * the picture unless it is null. also, slave->jiffies is not needed\n\t * here because we send an arp on each slave and give a slave as\n\t * long as it needs to get the tx/rx within the delta.\n\t * TODO: what about up/down delay in arp mode? it wasn't here before\n\t *       so it can wait\n\t */\n\tbond_for_each_slave(bond, slave, i) {\n\t\tunsigned long trans_start = dev_trans_start(slave->dev);\n\n\t\tif (slave->link != BOND_LINK_UP) {\n\t\t\tif (time_in_range(jiffies,\n\t\t\t\ttrans_start - delta_in_ticks,\n\t\t\t\ttrans_start + delta_in_ticks) &&\n\t\t\t    time_in_range(jiffies,\n\t\t\t\tslave->dev->last_rx - delta_in_ticks,\n\t\t\t\tslave->dev->last_rx + delta_in_ticks)) {\n\n\t\t\t\tslave->link  = BOND_LINK_UP;\n\t\t\t\tbond_set_active_slave(slave);\n\n\t\t\t\t/* primary_slave has no meaning in round-robin\n\t\t\t\t * mode. the window of a slave being up and\n\t\t\t\t * curr_active_slave being null after enslaving\n\t\t\t\t * is closed.\n\t\t\t\t */\n\t\t\t\tif (!oldcurrent) {\n\t\t\t\t\tpr_info(\"%s: link status definitely up for interface %s, \",\n\t\t\t\t\t\tbond->dev->name,\n\t\t\t\t\t\tslave->dev->name);\n\t\t\t\t\tdo_failover = 1;\n\t\t\t\t} else {\n\t\t\t\t\tpr_info(\"%s: interface %s is now up\\n\",\n\t\t\t\t\t\tbond->dev->name,\n\t\t\t\t\t\tslave->dev->name);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/* slave->link == BOND_LINK_UP */\n\n\t\t\t/* not all switches will respond to an arp request\n\t\t\t * when the source ip is 0, so don't take the link down\n\t\t\t * if we don't know our ip yet\n\t\t\t */\n\t\t\tif (!time_in_range(jiffies,\n\t\t\t\ttrans_start - delta_in_ticks,\n\t\t\t\ttrans_start + 2 * delta_in_ticks) ||\n\t\t\t    !time_in_range(jiffies,\n\t\t\t\tslave->dev->last_rx - delta_in_ticks,\n\t\t\t\tslave->dev->last_rx + 2 * delta_in_ticks)) {\n\n\t\t\t\tslave->link  = BOND_LINK_DOWN;\n\t\t\t\tbond_set_backup_slave(slave);\n\n\t\t\t\tif (slave->link_failure_count < UINT_MAX)\n\t\t\t\t\tslave->link_failure_count++;\n\n\t\t\t\tpr_info(\"%s: interface %s is now down.\\n\",\n\t\t\t\t\tbond->dev->name,\n\t\t\t\t\tslave->dev->name);\n\n\t\t\t\tif (slave == oldcurrent)\n\t\t\t\t\tdo_failover = 1;\n\t\t\t}\n\t\t}\n\n\t\t/* note: if switch is in round-robin mode, all links\n\t\t * must tx arp to ensure all links rx an arp - otherwise\n\t\t * links may oscillate or not come up at all; if switch is\n\t\t * in something like xor mode, there is nothing we can\n\t\t * do - all replies will be rx'ed on same link causing slaves\n\t\t * to be unstable during low/no traffic periods\n\t\t */\n\t\tif (IS_UP(slave->dev))\n\t\t\tbond_arp_send_all(bond, slave);\n\t}\n\n\tif (do_failover) {\n\t\tblock_netpoll_tx();\n\t\twrite_lock_bh(&bond->curr_slave_lock);\n\n\t\tbond_select_active_slave(bond);\n\n\t\twrite_unlock_bh(&bond->curr_slave_lock);\n\t\tunblock_netpoll_tx();\n\t}\n\nre_arm:\n\tif (bond->params.arp_interval)\n\t\tqueue_delayed_work(bond->wq, &bond->arp_work, delta_in_ticks);\nout:\n\tread_unlock(&bond->lock);\n}\n\n/*\n * Called to inspect slaves for active-backup mode ARP monitor link state\n * changes.  Sets new_link in slaves to specify what action should take\n * place for the slave.  Returns 0 if no changes are found, >0 if changes\n * to link states must be committed.\n *\n * Called with bond->lock held for read.\n */\nstatic int bond_ab_arp_inspect(struct bonding *bond, int delta_in_ticks)\n{\n\tstruct slave *slave;\n\tint i, commit = 0;\n\tunsigned long trans_start;\n\n\tbond_for_each_slave(bond, slave, i) {\n\t\tslave->new_link = BOND_LINK_NOCHANGE;\n\n\t\tif (slave->link != BOND_LINK_UP) {\n\t\t\tif (time_in_range(jiffies,\n\t\t\t\tslave_last_rx(bond, slave) - delta_in_ticks,\n\t\t\t\tslave_last_rx(bond, slave) + delta_in_ticks)) {\n\n\t\t\t\tslave->new_link = BOND_LINK_UP;\n\t\t\t\tcommit++;\n\t\t\t}\n\n\t\t\tcontinue;\n\t\t}\n\n\t\t/*\n\t\t * Give slaves 2*delta after being enslaved or made\n\t\t * active.  This avoids bouncing, as the last receive\n\t\t * times need a full ARP monitor cycle to be updated.\n\t\t */\n\t\tif (time_in_range(jiffies,\n\t\t\t\t  slave->jiffies - delta_in_ticks,\n\t\t\t\t  slave->jiffies + 2 * delta_in_ticks))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Backup slave is down if:\n\t\t * - No current_arp_slave AND\n\t\t * - more than 3*delta since last receive AND\n\t\t * - the bond has an IP address\n\t\t *\n\t\t * Note: a non-null current_arp_slave indicates\n\t\t * the curr_active_slave went down and we are\n\t\t * searching for a new one; under this condition\n\t\t * we only take the curr_active_slave down - this\n\t\t * gives each slave a chance to tx/rx traffic\n\t\t * before being taken out\n\t\t */\n\t\tif (!bond_is_active_slave(slave) &&\n\t\t    !bond->current_arp_slave &&\n\t\t    !time_in_range(jiffies,\n\t\t\tslave_last_rx(bond, slave) - delta_in_ticks,\n\t\t\tslave_last_rx(bond, slave) + 3 * delta_in_ticks)) {\n\n\t\t\tslave->new_link = BOND_LINK_DOWN;\n\t\t\tcommit++;\n\t\t}\n\n\t\t/*\n\t\t * Active slave is down if:\n\t\t * - more than 2*delta since transmitting OR\n\t\t * - (more than 2*delta since receive AND\n\t\t *    the bond has an IP address)\n\t\t */\n\t\ttrans_start = dev_trans_start(slave->dev);\n\t\tif (bond_is_active_slave(slave) &&\n\t\t    (!time_in_range(jiffies,\n\t\t\ttrans_start - delta_in_ticks,\n\t\t\ttrans_start + 2 * delta_in_ticks) ||\n\t\t     !time_in_range(jiffies,\n\t\t\tslave_last_rx(bond, slave) - delta_in_ticks,\n\t\t\tslave_last_rx(bond, slave) + 2 * delta_in_ticks))) {\n\n\t\t\tslave->new_link = BOND_LINK_DOWN;\n\t\t\tcommit++;\n\t\t}\n\t}\n\n\treturn commit;\n}\n\n/*\n * Called to commit link state changes noted by inspection step of\n * active-backup mode ARP monitor.\n *\n * Called with RTNL and bond->lock for read.\n */\nstatic void bond_ab_arp_commit(struct bonding *bond, int delta_in_ticks)\n{\n\tstruct slave *slave;\n\tint i;\n\tunsigned long trans_start;\n\n\tbond_for_each_slave(bond, slave, i) {\n\t\tswitch (slave->new_link) {\n\t\tcase BOND_LINK_NOCHANGE:\n\t\t\tcontinue;\n\n\t\tcase BOND_LINK_UP:\n\t\t\ttrans_start = dev_trans_start(slave->dev);\n\t\t\tif ((!bond->curr_active_slave &&\n\t\t\t     time_in_range(jiffies,\n\t\t\t\t\t   trans_start - delta_in_ticks,\n\t\t\t\t\t   trans_start + delta_in_ticks)) ||\n\t\t\t    bond->curr_active_slave != slave) {\n\t\t\t\tslave->link = BOND_LINK_UP;\n\t\t\t\tbond->current_arp_slave = NULL;\n\n\t\t\t\tpr_info(\"%s: link status definitely up for interface %s.\\n\",\n\t\t\t\t\tbond->dev->name, slave->dev->name);\n\n\t\t\t\tif (!bond->curr_active_slave ||\n\t\t\t\t    (slave == bond->primary_slave))\n\t\t\t\t\tgoto do_failover;\n\n\t\t\t}\n\n\t\t\tcontinue;\n\n\t\tcase BOND_LINK_DOWN:\n\t\t\tif (slave->link_failure_count < UINT_MAX)\n\t\t\t\tslave->link_failure_count++;\n\n\t\t\tslave->link = BOND_LINK_DOWN;\n\t\t\tbond_set_slave_inactive_flags(slave);\n\n\t\t\tpr_info(\"%s: link status definitely down for interface %s, disabling it\\n\",\n\t\t\t\tbond->dev->name, slave->dev->name);\n\n\t\t\tif (slave == bond->curr_active_slave) {\n\t\t\t\tbond->current_arp_slave = NULL;\n\t\t\t\tgoto do_failover;\n\t\t\t}\n\n\t\t\tcontinue;\n\n\t\tdefault:\n\t\t\tpr_err(\"%s: impossible: new_link %d on slave %s\\n\",\n\t\t\t       bond->dev->name, slave->new_link,\n\t\t\t       slave->dev->name);\n\t\t\tcontinue;\n\t\t}\n\ndo_failover:\n\t\tASSERT_RTNL();\n\t\tblock_netpoll_tx();\n\t\twrite_lock_bh(&bond->curr_slave_lock);\n\t\tbond_select_active_slave(bond);\n\t\twrite_unlock_bh(&bond->curr_slave_lock);\n\t\tunblock_netpoll_tx();\n\t}\n\n\tbond_set_carrier(bond);\n}\n\n/*\n * Send ARP probes for active-backup mode ARP monitor.\n *\n * Called with bond->lock held for read.\n */\nstatic void bond_ab_arp_probe(struct bonding *bond)\n{\n\tstruct slave *slave;\n\tint i;\n\n\tread_lock(&bond->curr_slave_lock);\n\n\tif (bond->current_arp_slave && bond->curr_active_slave)\n\t\tpr_info(\"PROBE: c_arp %s && cas %s BAD\\n\",\n\t\t\tbond->current_arp_slave->dev->name,\n\t\t\tbond->curr_active_slave->dev->name);\n\n\tif (bond->curr_active_slave) {\n\t\tbond_arp_send_all(bond, bond->curr_active_slave);\n\t\tread_unlock(&bond->curr_slave_lock);\n\t\treturn;\n\t}\n\n\tread_unlock(&bond->curr_slave_lock);\n\n\t/* if we don't have a curr_active_slave, search for the next available\n\t * backup slave from the current_arp_slave and make it the candidate\n\t * for becoming the curr_active_slave\n\t */\n\n\tif (!bond->current_arp_slave) {\n\t\tbond->current_arp_slave = bond->first_slave;\n\t\tif (!bond->current_arp_slave)\n\t\t\treturn;\n\t}\n\n\tbond_set_slave_inactive_flags(bond->current_arp_slave);\n\n\t/* search for next candidate */\n\tbond_for_each_slave_from(bond, slave, i, bond->current_arp_slave->next) {\n\t\tif (IS_UP(slave->dev)) {\n\t\t\tslave->link = BOND_LINK_BACK;\n\t\t\tbond_set_slave_active_flags(slave);\n\t\t\tbond_arp_send_all(bond, slave);\n\t\t\tslave->jiffies = jiffies;\n\t\t\tbond->current_arp_slave = slave;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* if the link state is up at this point, we\n\t\t * mark it down - this can happen if we have\n\t\t * simultaneous link failures and\n\t\t * reselect_active_interface doesn't make this\n\t\t * one the current slave so it is still marked\n\t\t * up when it is actually down\n\t\t */\n\t\tif (slave->link == BOND_LINK_UP) {\n\t\t\tslave->link = BOND_LINK_DOWN;\n\t\t\tif (slave->link_failure_count < UINT_MAX)\n\t\t\t\tslave->link_failure_count++;\n\n\t\t\tbond_set_slave_inactive_flags(slave);\n\n\t\t\tpr_info(\"%s: backup interface %s is now down.\\n\",\n\t\t\t\tbond->dev->name, slave->dev->name);\n\t\t}\n\t}\n}\n\nvoid bond_activebackup_arp_mon(struct work_struct *work)\n{\n\tstruct bonding *bond = container_of(work, struct bonding,\n\t\t\t\t\t    arp_work.work);\n\tbool should_notify_peers = false;\n\tint delta_in_ticks;\n\n\tread_lock(&bond->lock);\n\n\tif (bond->kill_timers)\n\t\tgoto out;\n\n\tdelta_in_ticks = msecs_to_jiffies(bond->params.arp_interval);\n\n\tif (bond->slave_cnt == 0)\n\t\tgoto re_arm;\n\n\tshould_notify_peers = bond_should_notify_peers(bond);\n\n\tif (bond_ab_arp_inspect(bond, delta_in_ticks)) {\n\t\tread_unlock(&bond->lock);\n\t\trtnl_lock();\n\t\tread_lock(&bond->lock);\n\n\t\tbond_ab_arp_commit(bond, delta_in_ticks);\n\n\t\tread_unlock(&bond->lock);\n\t\trtnl_unlock();\n\t\tread_lock(&bond->lock);\n\t}\n\n\tbond_ab_arp_probe(bond);\n\nre_arm:\n\tif (bond->params.arp_interval)\n\t\tqueue_delayed_work(bond->wq, &bond->arp_work, delta_in_ticks);\nout:\n\tread_unlock(&bond->lock);\n\n\tif (should_notify_peers) {\n\t\trtnl_lock();\n\t\tnetdev_bonding_change(bond->dev, NETDEV_NOTIFY_PEERS);\n\t\trtnl_unlock();\n\t}\n}\n\n/*-------------------------- netdev event handling --------------------------*/\n\n/*\n * Change device name\n */\nstatic int bond_event_changename(struct bonding *bond)\n{\n\tbond_remove_proc_entry(bond);\n\tbond_create_proc_entry(bond);\n\n\tbond_debug_reregister(bond);\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int bond_master_netdev_event(unsigned long event,\n\t\t\t\t    struct net_device *bond_dev)\n{\n\tstruct bonding *event_bond = netdev_priv(bond_dev);\n\n\tswitch (event) {\n\tcase NETDEV_CHANGENAME:\n\t\treturn bond_event_changename(event_bond);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\nstatic int bond_slave_netdev_event(unsigned long event,\n\t\t\t\t   struct net_device *slave_dev)\n{\n\tstruct net_device *bond_dev = slave_dev->master;\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\n\tswitch (event) {\n\tcase NETDEV_UNREGISTER:\n\t\tif (bond_dev) {\n\t\t\tif (bond->setup_by_slave)\n\t\t\t\tbond_release_and_destroy(bond_dev, slave_dev);\n\t\t\telse\n\t\t\t\tbond_release(bond_dev, slave_dev);\n\t\t}\n\t\tbreak;\n\tcase NETDEV_CHANGE:\n\t\tif (bond->params.mode == BOND_MODE_8023AD || bond_is_lb(bond)) {\n\t\t\tstruct slave *slave;\n\n\t\t\tslave = bond_get_slave_by_dev(bond, slave_dev);\n\t\t\tif (slave) {\n\t\t\t\tu32 old_speed = slave->speed;\n\t\t\t\tu8  old_duplex = slave->duplex;\n\n\t\t\t\tbond_update_speed_duplex(slave);\n\n\t\t\t\tif (bond_is_lb(bond))\n\t\t\t\t\tbreak;\n\n\t\t\t\tif (old_speed != slave->speed)\n\t\t\t\t\tbond_3ad_adapter_speed_changed(slave);\n\t\t\t\tif (old_duplex != slave->duplex)\n\t\t\t\t\tbond_3ad_adapter_duplex_changed(slave);\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\tcase NETDEV_DOWN:\n\t\t/*\n\t\t * ... Or is it this?\n\t\t */\n\t\tbreak;\n\tcase NETDEV_CHANGEMTU:\n\t\t/*\n\t\t * TODO: Should slaves be allowed to\n\t\t * independently alter their MTU?  For\n\t\t * an active-backup bond, slaves need\n\t\t * not be the same type of device, so\n\t\t * MTUs may vary.  For other modes,\n\t\t * slaves arguably should have the\n\t\t * same MTUs. To do this, we'd need to\n\t\t * take over the slave's change_mtu\n\t\t * function for the duration of their\n\t\t * servitude.\n\t\t */\n\t\tbreak;\n\tcase NETDEV_CHANGENAME:\n\t\t/*\n\t\t * TODO: handle changing the primary's name\n\t\t */\n\t\tbreak;\n\tcase NETDEV_FEAT_CHANGE:\n\t\tbond_compute_features(bond);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\n/*\n * bond_netdev_event: handle netdev notifier chain events.\n *\n * This function receives events for the netdev chain.  The caller (an\n * ioctl handler calling blocking_notifier_call_chain) holds the necessary\n * locks for us to safely manipulate the slave devices (RTNL lock,\n * dev_probe_lock).\n */\nstatic int bond_netdev_event(struct notifier_block *this,\n\t\t\t     unsigned long event, void *ptr)\n{\n\tstruct net_device *event_dev = (struct net_device *)ptr;\n\n\tpr_debug(\"event_dev: %s, event: %lx\\n\",\n\t\t event_dev ? event_dev->name : \"None\",\n\t\t event);\n\n\tif (!(event_dev->priv_flags & IFF_BONDING))\n\t\treturn NOTIFY_DONE;\n\n\tif (event_dev->flags & IFF_MASTER) {\n\t\tpr_debug(\"IFF_MASTER\\n\");\n\t\treturn bond_master_netdev_event(event, event_dev);\n\t}\n\n\tif (event_dev->flags & IFF_SLAVE) {\n\t\tpr_debug(\"IFF_SLAVE\\n\");\n\t\treturn bond_slave_netdev_event(event, event_dev);\n\t}\n\n\treturn NOTIFY_DONE;\n}\n\n/*\n * bond_inetaddr_event: handle inetaddr notifier chain events.\n *\n * We keep track of device IPs primarily to use as source addresses in\n * ARP monitor probes (rather than spewing out broadcasts all the time).\n *\n * We track one IP for the main device (if it has one), plus one per VLAN.\n */\nstatic int bond_inetaddr_event(struct notifier_block *this, unsigned long event, void *ptr)\n{\n\tstruct in_ifaddr *ifa = ptr;\n\tstruct net_device *vlan_dev, *event_dev = ifa->ifa_dev->dev;\n\tstruct bond_net *bn = net_generic(dev_net(event_dev), bond_net_id);\n\tstruct bonding *bond;\n\tstruct vlan_entry *vlan;\n\n\tlist_for_each_entry(bond, &bn->dev_list, bond_list) {\n\t\tif (bond->dev == event_dev) {\n\t\t\tswitch (event) {\n\t\t\tcase NETDEV_UP:\n\t\t\t\tbond->master_ip = ifa->ifa_local;\n\t\t\t\treturn NOTIFY_OK;\n\t\t\tcase NETDEV_DOWN:\n\t\t\t\tbond->master_ip = bond_glean_dev_ip(bond->dev);\n\t\t\t\treturn NOTIFY_OK;\n\t\t\tdefault:\n\t\t\t\treturn NOTIFY_DONE;\n\t\t\t}\n\t\t}\n\n\t\tlist_for_each_entry(vlan, &bond->vlan_list, vlan_list) {\n\t\t\tvlan_dev = __vlan_find_dev_deep(bond->dev,\n\t\t\t\t\t\t\tvlan->vlan_id);\n\t\t\tif (vlan_dev == event_dev) {\n\t\t\t\tswitch (event) {\n\t\t\t\tcase NETDEV_UP:\n\t\t\t\t\tvlan->vlan_ip = ifa->ifa_local;\n\t\t\t\t\treturn NOTIFY_OK;\n\t\t\t\tcase NETDEV_DOWN:\n\t\t\t\t\tvlan->vlan_ip =\n\t\t\t\t\t\tbond_glean_dev_ip(vlan_dev);\n\t\t\t\t\treturn NOTIFY_OK;\n\t\t\t\tdefault:\n\t\t\t\t\treturn NOTIFY_DONE;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block bond_netdev_notifier = {\n\t.notifier_call = bond_netdev_event,\n};\n\nstatic struct notifier_block bond_inetaddr_notifier = {\n\t.notifier_call = bond_inetaddr_event,\n};\n\n/*---------------------------- Hashing Policies -----------------------------*/\n\n/*\n * Hash for the output device based upon layer 2 and layer 3 data. If\n * the packet is not IP mimic bond_xmit_hash_policy_l2()\n */\nstatic int bond_xmit_hash_policy_l23(struct sk_buff *skb, int count)\n{\n\tstruct ethhdr *data = (struct ethhdr *)skb->data;\n\tstruct iphdr *iph = ip_hdr(skb);\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\treturn ((ntohl(iph->saddr ^ iph->daddr) & 0xffff) ^\n\t\t\t(data->h_dest[5] ^ data->h_source[5])) % count;\n\t}\n\n\treturn (data->h_dest[5] ^ data->h_source[5]) % count;\n}\n\n/*\n * Hash for the output device based upon layer 3 and layer 4 data. If\n * the packet is a frag or not TCP or UDP, just use layer 3 data.  If it is\n * altogether not IP, mimic bond_xmit_hash_policy_l2()\n */\nstatic int bond_xmit_hash_policy_l34(struct sk_buff *skb, int count)\n{\n\tstruct ethhdr *data = (struct ethhdr *)skb->data;\n\tstruct iphdr *iph = ip_hdr(skb);\n\t__be16 *layer4hdr = (__be16 *)((u32 *)iph + iph->ihl);\n\tint layer4_xor = 0;\n\n\tif (skb->protocol == htons(ETH_P_IP)) {\n\t\tif (!ip_is_fragment(iph) &&\n\t\t    (iph->protocol == IPPROTO_TCP ||\n\t\t     iph->protocol == IPPROTO_UDP)) {\n\t\t\tlayer4_xor = ntohs((*layer4hdr ^ *(layer4hdr + 1)));\n\t\t}\n\t\treturn (layer4_xor ^\n\t\t\t((ntohl(iph->saddr ^ iph->daddr)) & 0xffff)) % count;\n\n\t}\n\n\treturn (data->h_dest[5] ^ data->h_source[5]) % count;\n}\n\n/*\n * Hash for the output device based upon layer 2 data\n */\nstatic int bond_xmit_hash_policy_l2(struct sk_buff *skb, int count)\n{\n\tstruct ethhdr *data = (struct ethhdr *)skb->data;\n\n\treturn (data->h_dest[5] ^ data->h_source[5]) % count;\n}\n\n/*-------------------------- Device entry points ----------------------------*/\n\nstatic int bond_open(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\n\tbond->kill_timers = 0;\n\n\tINIT_DELAYED_WORK(&bond->mcast_work, bond_resend_igmp_join_requests_delayed);\n\n\tif (bond_is_lb(bond)) {\n\t\t/* bond_alb_initialize must be called before the timer\n\t\t * is started.\n\t\t */\n\t\tif (bond_alb_initialize(bond, (bond->params.mode == BOND_MODE_ALB))) {\n\t\t\t/* something went wrong - fail the open operation */\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tINIT_DELAYED_WORK(&bond->alb_work, bond_alb_monitor);\n\t\tqueue_delayed_work(bond->wq, &bond->alb_work, 0);\n\t}\n\n\tif (bond->params.miimon) {  /* link check interval, in milliseconds. */\n\t\tINIT_DELAYED_WORK(&bond->mii_work, bond_mii_monitor);\n\t\tqueue_delayed_work(bond->wq, &bond->mii_work, 0);\n\t}\n\n\tif (bond->params.arp_interval) {  /* arp interval, in milliseconds. */\n\t\tif (bond->params.mode == BOND_MODE_ACTIVEBACKUP)\n\t\t\tINIT_DELAYED_WORK(&bond->arp_work,\n\t\t\t\t\t  bond_activebackup_arp_mon);\n\t\telse\n\t\t\tINIT_DELAYED_WORK(&bond->arp_work,\n\t\t\t\t\t  bond_loadbalance_arp_mon);\n\n\t\tqueue_delayed_work(bond->wq, &bond->arp_work, 0);\n\t\tif (bond->params.arp_validate)\n\t\t\tbond->recv_probe = bond_arp_rcv;\n\t}\n\n\tif (bond->params.mode == BOND_MODE_8023AD) {\n\t\tINIT_DELAYED_WORK(&bond->ad_work, bond_3ad_state_machine_handler);\n\t\tqueue_delayed_work(bond->wq, &bond->ad_work, 0);\n\t\t/* register to receive LACPDUs */\n\t\tbond->recv_probe = bond_3ad_lacpdu_recv;\n\t\tbond_3ad_initiate_agg_selection(bond, 1);\n\t}\n\n\treturn 0;\n}\n\nstatic int bond_close(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\n\twrite_lock_bh(&bond->lock);\n\n\tbond->send_peer_notif = 0;\n\n\t/* signal timers not to re-arm */\n\tbond->kill_timers = 1;\n\n\twrite_unlock_bh(&bond->lock);\n\n\tif (bond->params.miimon) {  /* link check interval, in milliseconds. */\n\t\tcancel_delayed_work(&bond->mii_work);\n\t}\n\n\tif (bond->params.arp_interval) {  /* arp interval, in milliseconds. */\n\t\tcancel_delayed_work(&bond->arp_work);\n\t}\n\n\tswitch (bond->params.mode) {\n\tcase BOND_MODE_8023AD:\n\t\tcancel_delayed_work(&bond->ad_work);\n\t\tbreak;\n\tcase BOND_MODE_TLB:\n\tcase BOND_MODE_ALB:\n\t\tcancel_delayed_work(&bond->alb_work);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (delayed_work_pending(&bond->mcast_work))\n\t\tcancel_delayed_work(&bond->mcast_work);\n\n\tif (bond_is_lb(bond)) {\n\t\t/* Must be called only after all\n\t\t * slaves have been released\n\t\t */\n\t\tbond_alb_deinitialize(bond);\n\t}\n\tbond->recv_probe = NULL;\n\n\treturn 0;\n}\n\nstatic struct rtnl_link_stats64 *bond_get_stats(struct net_device *bond_dev,\n\t\t\t\t\t\tstruct rtnl_link_stats64 *stats)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct rtnl_link_stats64 temp;\n\tstruct slave *slave;\n\tint i;\n\n\tmemset(stats, 0, sizeof(*stats));\n\n\tread_lock_bh(&bond->lock);\n\n\tbond_for_each_slave(bond, slave, i) {\n\t\tconst struct rtnl_link_stats64 *sstats =\n\t\t\tdev_get_stats(slave->dev, &temp);\n\n\t\tstats->rx_packets += sstats->rx_packets;\n\t\tstats->rx_bytes += sstats->rx_bytes;\n\t\tstats->rx_errors += sstats->rx_errors;\n\t\tstats->rx_dropped += sstats->rx_dropped;\n\n\t\tstats->tx_packets += sstats->tx_packets;\n\t\tstats->tx_bytes += sstats->tx_bytes;\n\t\tstats->tx_errors += sstats->tx_errors;\n\t\tstats->tx_dropped += sstats->tx_dropped;\n\n\t\tstats->multicast += sstats->multicast;\n\t\tstats->collisions += sstats->collisions;\n\n\t\tstats->rx_length_errors += sstats->rx_length_errors;\n\t\tstats->rx_over_errors += sstats->rx_over_errors;\n\t\tstats->rx_crc_errors += sstats->rx_crc_errors;\n\t\tstats->rx_frame_errors += sstats->rx_frame_errors;\n\t\tstats->rx_fifo_errors += sstats->rx_fifo_errors;\n\t\tstats->rx_missed_errors += sstats->rx_missed_errors;\n\n\t\tstats->tx_aborted_errors += sstats->tx_aborted_errors;\n\t\tstats->tx_carrier_errors += sstats->tx_carrier_errors;\n\t\tstats->tx_fifo_errors += sstats->tx_fifo_errors;\n\t\tstats->tx_heartbeat_errors += sstats->tx_heartbeat_errors;\n\t\tstats->tx_window_errors += sstats->tx_window_errors;\n\t}\n\n\tread_unlock_bh(&bond->lock);\n\n\treturn stats;\n}\n\nstatic int bond_do_ioctl(struct net_device *bond_dev, struct ifreq *ifr, int cmd)\n{\n\tstruct net_device *slave_dev = NULL;\n\tstruct ifbond k_binfo;\n\tstruct ifbond __user *u_binfo = NULL;\n\tstruct ifslave k_sinfo;\n\tstruct ifslave __user *u_sinfo = NULL;\n\tstruct mii_ioctl_data *mii = NULL;\n\tint res = 0;\n\n\tpr_debug(\"bond_ioctl: master=%s, cmd=%d\\n\", bond_dev->name, cmd);\n\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\t\tmii = if_mii(ifr);\n\t\tif (!mii)\n\t\t\treturn -EINVAL;\n\n\t\tmii->phy_id = 0;\n\t\t/* Fall Through */\n\tcase SIOCGMIIREG:\n\t\t/*\n\t\t * We do this again just in case we were called by SIOCGMIIREG\n\t\t * instead of SIOCGMIIPHY.\n\t\t */\n\t\tmii = if_mii(ifr);\n\t\tif (!mii)\n\t\t\treturn -EINVAL;\n\n\n\t\tif (mii->reg_num == 1) {\n\t\t\tstruct bonding *bond = netdev_priv(bond_dev);\n\t\t\tmii->val_out = 0;\n\t\t\tread_lock(&bond->lock);\n\t\t\tread_lock(&bond->curr_slave_lock);\n\t\t\tif (netif_carrier_ok(bond->dev))\n\t\t\t\tmii->val_out = BMSR_LSTATUS;\n\n\t\t\tread_unlock(&bond->curr_slave_lock);\n\t\t\tread_unlock(&bond->lock);\n\t\t}\n\n\t\treturn 0;\n\tcase BOND_INFO_QUERY_OLD:\n\tcase SIOCBONDINFOQUERY:\n\t\tu_binfo = (struct ifbond __user *)ifr->ifr_data;\n\n\t\tif (copy_from_user(&k_binfo, u_binfo, sizeof(ifbond)))\n\t\t\treturn -EFAULT;\n\n\t\tres = bond_info_query(bond_dev, &k_binfo);\n\t\tif (res == 0 &&\n\t\t    copy_to_user(u_binfo, &k_binfo, sizeof(ifbond)))\n\t\t\treturn -EFAULT;\n\n\t\treturn res;\n\tcase BOND_SLAVE_INFO_QUERY_OLD:\n\tcase SIOCBONDSLAVEINFOQUERY:\n\t\tu_sinfo = (struct ifslave __user *)ifr->ifr_data;\n\n\t\tif (copy_from_user(&k_sinfo, u_sinfo, sizeof(ifslave)))\n\t\t\treturn -EFAULT;\n\n\t\tres = bond_slave_info_query(bond_dev, &k_sinfo);\n\t\tif (res == 0 &&\n\t\t    copy_to_user(u_sinfo, &k_sinfo, sizeof(ifslave)))\n\t\t\treturn -EFAULT;\n\n\t\treturn res;\n\tdefault:\n\t\t/* Go on */\n\t\tbreak;\n\t}\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tslave_dev = dev_get_by_name(dev_net(bond_dev), ifr->ifr_slave);\n\n\tpr_debug(\"slave_dev=%p:\\n\", slave_dev);\n\n\tif (!slave_dev)\n\t\tres = -ENODEV;\n\telse {\n\t\tpr_debug(\"slave_dev->name=%s:\\n\", slave_dev->name);\n\t\tswitch (cmd) {\n\t\tcase BOND_ENSLAVE_OLD:\n\t\tcase SIOCBONDENSLAVE:\n\t\t\tres = bond_enslave(bond_dev, slave_dev);\n\t\t\tbreak;\n\t\tcase BOND_RELEASE_OLD:\n\t\tcase SIOCBONDRELEASE:\n\t\t\tres = bond_release(bond_dev, slave_dev);\n\t\t\tbreak;\n\t\tcase BOND_SETHWADDR_OLD:\n\t\tcase SIOCBONDSETHWADDR:\n\t\t\tres = bond_sethwaddr(bond_dev, slave_dev);\n\t\t\tbreak;\n\t\tcase BOND_CHANGE_ACTIVE_OLD:\n\t\tcase SIOCBONDCHANGEACTIVE:\n\t\t\tres = bond_ioctl_change_active(bond_dev, slave_dev);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tres = -EOPNOTSUPP;\n\t\t}\n\n\t\tdev_put(slave_dev);\n\t}\n\n\treturn res;\n}\n\nstatic bool bond_addr_in_mc_list(unsigned char *addr,\n\t\t\t\t struct netdev_hw_addr_list *list,\n\t\t\t\t int addrlen)\n{\n\tstruct netdev_hw_addr *ha;\n\n\tnetdev_hw_addr_list_for_each(ha, list)\n\t\tif (!memcmp(ha->addr, addr, addrlen))\n\t\t\treturn true;\n\n\treturn false;\n}\n\nstatic void bond_set_multicast_list(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct netdev_hw_addr *ha;\n\tbool found;\n\n\t/*\n\t * Do promisc before checking multicast_mode\n\t */\n\tif ((bond_dev->flags & IFF_PROMISC) && !(bond->flags & IFF_PROMISC))\n\t\t/*\n\t\t * FIXME: Need to handle the error when one of the multi-slaves\n\t\t * encounters error.\n\t\t */\n\t\tbond_set_promiscuity(bond, 1);\n\n\n\tif (!(bond_dev->flags & IFF_PROMISC) && (bond->flags & IFF_PROMISC))\n\t\tbond_set_promiscuity(bond, -1);\n\n\n\t/* set allmulti flag to slaves */\n\tif ((bond_dev->flags & IFF_ALLMULTI) && !(bond->flags & IFF_ALLMULTI))\n\t\t/*\n\t\t * FIXME: Need to handle the error when one of the multi-slaves\n\t\t * encounters error.\n\t\t */\n\t\tbond_set_allmulti(bond, 1);\n\n\n\tif (!(bond_dev->flags & IFF_ALLMULTI) && (bond->flags & IFF_ALLMULTI))\n\t\tbond_set_allmulti(bond, -1);\n\n\n\tread_lock(&bond->lock);\n\n\tbond->flags = bond_dev->flags;\n\n\t/* looking for addresses to add to slaves' mc list */\n\tnetdev_for_each_mc_addr(ha, bond_dev) {\n\t\tfound = bond_addr_in_mc_list(ha->addr, &bond->mc_list,\n\t\t\t\t\t     bond_dev->addr_len);\n\t\tif (!found)\n\t\t\tbond_mc_add(bond, ha->addr);\n\t}\n\n\t/* looking for addresses to delete from slaves' list */\n\tnetdev_hw_addr_list_for_each(ha, &bond->mc_list) {\n\t\tfound = bond_addr_in_mc_list(ha->addr, &bond_dev->mc,\n\t\t\t\t\t     bond_dev->addr_len);\n\t\tif (!found)\n\t\t\tbond_mc_del(bond, ha->addr);\n\t}\n\n\t/* save master's multicast list */\n\t__hw_addr_flush(&bond->mc_list);\n\t__hw_addr_add_multiple(&bond->mc_list, &bond_dev->mc,\n\t\t\t       bond_dev->addr_len, NETDEV_HW_ADDR_T_MULTICAST);\n\n\tread_unlock(&bond->lock);\n}\n\nstatic int bond_neigh_setup(struct net_device *dev, struct neigh_parms *parms)\n{\n\tstruct bonding *bond = netdev_priv(dev);\n\tstruct slave *slave = bond->first_slave;\n\n\tif (slave) {\n\t\tconst struct net_device_ops *slave_ops\n\t\t\t= slave->dev->netdev_ops;\n\t\tif (slave_ops->ndo_neigh_setup)\n\t\t\treturn slave_ops->ndo_neigh_setup(slave->dev, parms);\n\t}\n\treturn 0;\n}\n\n/*\n * Change the MTU of all of a master's slaves to match the master\n */\nstatic int bond_change_mtu(struct net_device *bond_dev, int new_mtu)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct slave *slave, *stop_at;\n\tint res = 0;\n\tint i;\n\n\tpr_debug(\"bond=%p, name=%s, new_mtu=%d\\n\", bond,\n\t\t (bond_dev ? bond_dev->name : \"None\"), new_mtu);\n\n\t/* Can't hold bond->lock with bh disabled here since\n\t * some base drivers panic. On the other hand we can't\n\t * hold bond->lock without bh disabled because we'll\n\t * deadlock. The only solution is to rely on the fact\n\t * that we're under rtnl_lock here, and the slaves\n\t * list won't change. This doesn't solve the problem\n\t * of setting the slave's MTU while it is\n\t * transmitting, but the assumption is that the base\n\t * driver can handle that.\n\t *\n\t * TODO: figure out a way to safely iterate the slaves\n\t * list, but without holding a lock around the actual\n\t * call to the base driver.\n\t */\n\n\tbond_for_each_slave(bond, slave, i) {\n\t\tpr_debug(\"s %p s->p %p c_m %p\\n\",\n\t\t\t slave,\n\t\t\t slave->prev,\n\t\t\t slave->dev->netdev_ops->ndo_change_mtu);\n\n\t\tres = dev_set_mtu(slave->dev, new_mtu);\n\n\t\tif (res) {\n\t\t\t/* If we failed to set the slave's mtu to the new value\n\t\t\t * we must abort the operation even in ACTIVE_BACKUP\n\t\t\t * mode, because if we allow the backup slaves to have\n\t\t\t * different mtu values than the active slave we'll\n\t\t\t * need to change their mtu when doing a failover. That\n\t\t\t * means changing their mtu from timer context, which\n\t\t\t * is probably not a good idea.\n\t\t\t */\n\t\t\tpr_debug(\"err %d %s\\n\", res, slave->dev->name);\n\t\t\tgoto unwind;\n\t\t}\n\t}\n\n\tbond_dev->mtu = new_mtu;\n\n\treturn 0;\n\nunwind:\n\t/* unwind from head to the slave that failed */\n\tstop_at = slave;\n\tbond_for_each_slave_from_to(bond, slave, i, bond->first_slave, stop_at) {\n\t\tint tmp_res;\n\n\t\ttmp_res = dev_set_mtu(slave->dev, bond_dev->mtu);\n\t\tif (tmp_res) {\n\t\t\tpr_debug(\"unwind err %d dev %s\\n\",\n\t\t\t\t tmp_res, slave->dev->name);\n\t\t}\n\t}\n\n\treturn res;\n}\n\n/*\n * Change HW address\n *\n * Note that many devices must be down to change the HW address, and\n * downing the master releases all slaves.  We can make bonds full of\n * bonding devices to test this, however.\n */\nstatic int bond_set_mac_address(struct net_device *bond_dev, void *addr)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct sockaddr *sa = addr, tmp_sa;\n\tstruct slave *slave, *stop_at;\n\tint res = 0;\n\tint i;\n\n\tif (bond->params.mode == BOND_MODE_ALB)\n\t\treturn bond_alb_set_mac_address(bond_dev, addr);\n\n\n\tpr_debug(\"bond=%p, name=%s\\n\",\n\t\t bond, bond_dev ? bond_dev->name : \"None\");\n\n\t/*\n\t * If fail_over_mac is set to active, do nothing and return\n\t * success.  Returning an error causes ifenslave to fail.\n\t */\n\tif (bond->params.fail_over_mac == BOND_FOM_ACTIVE)\n\t\treturn 0;\n\n\tif (!is_valid_ether_addr(sa->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\t/* Can't hold bond->lock with bh disabled here since\n\t * some base drivers panic. On the other hand we can't\n\t * hold bond->lock without bh disabled because we'll\n\t * deadlock. The only solution is to rely on the fact\n\t * that we're under rtnl_lock here, and the slaves\n\t * list won't change. This doesn't solve the problem\n\t * of setting the slave's hw address while it is\n\t * transmitting, but the assumption is that the base\n\t * driver can handle that.\n\t *\n\t * TODO: figure out a way to safely iterate the slaves\n\t * list, but without holding a lock around the actual\n\t * call to the base driver.\n\t */\n\n\tbond_for_each_slave(bond, slave, i) {\n\t\tconst struct net_device_ops *slave_ops = slave->dev->netdev_ops;\n\t\tpr_debug(\"slave %p %s\\n\", slave, slave->dev->name);\n\n\t\tif (slave_ops->ndo_set_mac_address == NULL) {\n\t\t\tres = -EOPNOTSUPP;\n\t\t\tpr_debug(\"EOPNOTSUPP %s\\n\", slave->dev->name);\n\t\t\tgoto unwind;\n\t\t}\n\n\t\tres = dev_set_mac_address(slave->dev, addr);\n\t\tif (res) {\n\t\t\t/* TODO: consider downing the slave\n\t\t\t * and retry ?\n\t\t\t * User should expect communications\n\t\t\t * breakage anyway until ARP finish\n\t\t\t * updating, so...\n\t\t\t */\n\t\t\tpr_debug(\"err %d %s\\n\", res, slave->dev->name);\n\t\t\tgoto unwind;\n\t\t}\n\t}\n\n\t/* success */\n\tmemcpy(bond_dev->dev_addr, sa->sa_data, bond_dev->addr_len);\n\treturn 0;\n\nunwind:\n\tmemcpy(tmp_sa.sa_data, bond_dev->dev_addr, bond_dev->addr_len);\n\ttmp_sa.sa_family = bond_dev->type;\n\n\t/* unwind from head to the slave that failed */\n\tstop_at = slave;\n\tbond_for_each_slave_from_to(bond, slave, i, bond->first_slave, stop_at) {\n\t\tint tmp_res;\n\n\t\ttmp_res = dev_set_mac_address(slave->dev, &tmp_sa);\n\t\tif (tmp_res) {\n\t\t\tpr_debug(\"unwind err %d dev %s\\n\",\n\t\t\t\t tmp_res, slave->dev->name);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nstatic int bond_xmit_roundrobin(struct sk_buff *skb, struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct slave *slave, *start_at;\n\tint i, slave_no, res = 1;\n\tstruct iphdr *iph = ip_hdr(skb);\n\n\t/*\n\t * Start with the curr_active_slave that joined the bond as the\n\t * default for sending IGMP traffic.  For failover purposes one\n\t * needs to maintain some consistency for the interface that will\n\t * send the join/membership reports.  The curr_active_slave found\n\t * will send all of this type of traffic.\n\t */\n\tif ((iph->protocol == IPPROTO_IGMP) &&\n\t    (skb->protocol == htons(ETH_P_IP))) {\n\n\t\tread_lock(&bond->curr_slave_lock);\n\t\tslave = bond->curr_active_slave;\n\t\tread_unlock(&bond->curr_slave_lock);\n\n\t\tif (!slave)\n\t\t\tgoto out;\n\t} else {\n\t\t/*\n\t\t * Concurrent TX may collide on rr_tx_counter; we accept\n\t\t * that as being rare enough not to justify using an\n\t\t * atomic op here.\n\t\t */\n\t\tslave_no = bond->rr_tx_counter++ % bond->slave_cnt;\n\n\t\tbond_for_each_slave(bond, slave, i) {\n\t\t\tslave_no--;\n\t\t\tif (slave_no < 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tstart_at = slave;\n\tbond_for_each_slave_from(bond, slave, i, start_at) {\n\t\tif (IS_UP(slave->dev) &&\n\t\t    (slave->link == BOND_LINK_UP) &&\n\t\t    bond_is_active_slave(slave)) {\n\t\t\tres = bond_dev_queue_xmit(bond, skb, slave->dev);\n\t\t\tbreak;\n\t\t}\n\t}\n\nout:\n\tif (res) {\n\t\t/* no suitable interface, frame not sent */\n\t\tdev_kfree_skb(skb);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\n\n/*\n * in active-backup mode, we know that bond->curr_active_slave is always valid if\n * the bond has a usable interface.\n */\nstatic int bond_xmit_activebackup(struct sk_buff *skb, struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tint res = 1;\n\n\tread_lock(&bond->curr_slave_lock);\n\n\tif (bond->curr_active_slave)\n\t\tres = bond_dev_queue_xmit(bond, skb,\n\t\t\tbond->curr_active_slave->dev);\n\n\tif (res)\n\t\t/* no suitable interface, frame not sent */\n\t\tdev_kfree_skb(skb);\n\n\tread_unlock(&bond->curr_slave_lock);\n\n\treturn NETDEV_TX_OK;\n}\n\n/*\n * In bond_xmit_xor() , we determine the output device by using a pre-\n * determined xmit_hash_policy(), If the selected device is not enabled,\n * find the next active slave.\n */\nstatic int bond_xmit_xor(struct sk_buff *skb, struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct slave *slave, *start_at;\n\tint slave_no;\n\tint i;\n\tint res = 1;\n\n\tslave_no = bond->xmit_hash_policy(skb, bond->slave_cnt);\n\n\tbond_for_each_slave(bond, slave, i) {\n\t\tslave_no--;\n\t\tif (slave_no < 0)\n\t\t\tbreak;\n\t}\n\n\tstart_at = slave;\n\n\tbond_for_each_slave_from(bond, slave, i, start_at) {\n\t\tif (IS_UP(slave->dev) &&\n\t\t    (slave->link == BOND_LINK_UP) &&\n\t\t    bond_is_active_slave(slave)) {\n\t\t\tres = bond_dev_queue_xmit(bond, skb, slave->dev);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (res) {\n\t\t/* no suitable interface, frame not sent */\n\t\tdev_kfree_skb(skb);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\n/*\n * in broadcast mode, we send everything to all usable interfaces.\n */\nstatic int bond_xmit_broadcast(struct sk_buff *skb, struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct slave *slave, *start_at;\n\tstruct net_device *tx_dev = NULL;\n\tint i;\n\tint res = 1;\n\n\tread_lock(&bond->curr_slave_lock);\n\tstart_at = bond->curr_active_slave;\n\tread_unlock(&bond->curr_slave_lock);\n\n\tif (!start_at)\n\t\tgoto out;\n\n\tbond_for_each_slave_from(bond, slave, i, start_at) {\n\t\tif (IS_UP(slave->dev) &&\n\t\t    (slave->link == BOND_LINK_UP) &&\n\t\t    bond_is_active_slave(slave)) {\n\t\t\tif (tx_dev) {\n\t\t\t\tstruct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);\n\t\t\t\tif (!skb2) {\n\t\t\t\t\tpr_err(\"%s: Error: bond_xmit_broadcast(): skb_clone() failed\\n\",\n\t\t\t\t\t       bond_dev->name);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tres = bond_dev_queue_xmit(bond, skb2, tx_dev);\n\t\t\t\tif (res) {\n\t\t\t\t\tdev_kfree_skb(skb2);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttx_dev = slave->dev;\n\t\t}\n\t}\n\n\tif (tx_dev)\n\t\tres = bond_dev_queue_xmit(bond, skb, tx_dev);\n\nout:\n\tif (res)\n\t\t/* no suitable interface, frame not sent */\n\t\tdev_kfree_skb(skb);\n\n\t/* frame sent to all suitable interfaces */\n\treturn NETDEV_TX_OK;\n}\n\n/*------------------------- Device initialization ---------------------------*/\n\nstatic void bond_set_xmit_hash_policy(struct bonding *bond)\n{\n\tswitch (bond->params.xmit_policy) {\n\tcase BOND_XMIT_POLICY_LAYER23:\n\t\tbond->xmit_hash_policy = bond_xmit_hash_policy_l23;\n\t\tbreak;\n\tcase BOND_XMIT_POLICY_LAYER34:\n\t\tbond->xmit_hash_policy = bond_xmit_hash_policy_l34;\n\t\tbreak;\n\tcase BOND_XMIT_POLICY_LAYER2:\n\tdefault:\n\t\tbond->xmit_hash_policy = bond_xmit_hash_policy_l2;\n\t\tbreak;\n\t}\n}\n\n/*\n * Lookup the slave that corresponds to a qid\n */\nstatic inline int bond_slave_override(struct bonding *bond,\n\t\t\t\t      struct sk_buff *skb)\n{\n\tint i, res = 1;\n\tstruct slave *slave = NULL;\n\tstruct slave *check_slave;\n\n\tif (!skb->queue_mapping)\n\t\treturn 1;\n\n\t/* Find out if any slaves have the same mapping as this skb. */\n\tbond_for_each_slave(bond, check_slave, i) {\n\t\tif (check_slave->queue_id == skb->queue_mapping) {\n\t\t\tslave = check_slave;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* If the slave isn't UP, use default transmit policy. */\n\tif (slave && slave->queue_id && IS_UP(slave->dev) &&\n\t    (slave->link == BOND_LINK_UP)) {\n\t\tres = bond_dev_queue_xmit(bond, skb, slave->dev);\n\t}\n\n\treturn res;\n}\n\n\nstatic u16 bond_select_queue(struct net_device *dev, struct sk_buff *skb)\n{\n\t/*\n\t * This helper function exists to help dev_pick_tx get the correct\n\t * destination queue.  Using a helper function skips a call to\n\t * skb_tx_hash and will put the skbs in the queue we expect on their\n\t * way down to the bonding driver.\n\t */\n\tu16 txq = skb_rx_queue_recorded(skb) ? skb_get_rx_queue(skb) : 0;\n\n\t/*\n\t * Save the original txq to restore before passing to the driver\n\t */\n\tbond_queue_mapping(skb) = skb->queue_mapping;\n\n\tif (unlikely(txq >= dev->real_num_tx_queues)) {\n\t\tdo {\n\t\t\ttxq -= dev->real_num_tx_queues;\n\t\t} while (txq >= dev->real_num_tx_queues);\n\t}\n\treturn txq;\n}\n\nstatic netdev_tx_t __bond_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct bonding *bond = netdev_priv(dev);\n\n\tif (TX_QUEUE_OVERRIDE(bond->params.mode)) {\n\t\tif (!bond_slave_override(bond, skb))\n\t\t\treturn NETDEV_TX_OK;\n\t}\n\n\tswitch (bond->params.mode) {\n\tcase BOND_MODE_ROUNDROBIN:\n\t\treturn bond_xmit_roundrobin(skb, dev);\n\tcase BOND_MODE_ACTIVEBACKUP:\n\t\treturn bond_xmit_activebackup(skb, dev);\n\tcase BOND_MODE_XOR:\n\t\treturn bond_xmit_xor(skb, dev);\n\tcase BOND_MODE_BROADCAST:\n\t\treturn bond_xmit_broadcast(skb, dev);\n\tcase BOND_MODE_8023AD:\n\t\treturn bond_3ad_xmit_xor(skb, dev);\n\tcase BOND_MODE_ALB:\n\tcase BOND_MODE_TLB:\n\t\treturn bond_alb_xmit(skb, dev);\n\tdefault:\n\t\t/* Should never happen, mode already checked */\n\t\tpr_err(\"%s: Error: Unknown bonding mode %d\\n\",\n\t\t       dev->name, bond->params.mode);\n\t\tWARN_ON_ONCE(1);\n\t\tdev_kfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n}\n\nstatic netdev_tx_t bond_start_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct bonding *bond = netdev_priv(dev);\n\tnetdev_tx_t ret = NETDEV_TX_OK;\n\n\t/*\n\t * If we risk deadlock from transmitting this in the\n\t * netpoll path, tell netpoll to queue the frame for later tx\n\t */\n\tif (is_netpoll_tx_blocked(dev))\n\t\treturn NETDEV_TX_BUSY;\n\n\tread_lock(&bond->lock);\n\n\tif (bond->slave_cnt)\n\t\tret = __bond_start_xmit(skb, dev);\n\telse\n\t\tdev_kfree_skb(skb);\n\n\tread_unlock(&bond->lock);\n\n\treturn ret;\n}\n\n/*\n * set bond mode specific net device operations\n */\nvoid bond_set_mode_ops(struct bonding *bond, int mode)\n{\n\tstruct net_device *bond_dev = bond->dev;\n\n\tswitch (mode) {\n\tcase BOND_MODE_ROUNDROBIN:\n\t\tbreak;\n\tcase BOND_MODE_ACTIVEBACKUP:\n\t\tbreak;\n\tcase BOND_MODE_XOR:\n\t\tbond_set_xmit_hash_policy(bond);\n\t\tbreak;\n\tcase BOND_MODE_BROADCAST:\n\t\tbreak;\n\tcase BOND_MODE_8023AD:\n\t\tbond_set_xmit_hash_policy(bond);\n\t\tbreak;\n\tcase BOND_MODE_ALB:\n\t\t/* FALLTHRU */\n\tcase BOND_MODE_TLB:\n\t\tbreak;\n\tdefault:\n\t\t/* Should never happen, mode already checked */\n\t\tpr_err(\"%s: Error: Unknown bonding mode %d\\n\",\n\t\t       bond_dev->name, mode);\n\t\tbreak;\n\t}\n}\n\nstatic void bond_ethtool_get_drvinfo(struct net_device *bond_dev,\n\t\t\t\t    struct ethtool_drvinfo *drvinfo)\n{\n\tstrncpy(drvinfo->driver, DRV_NAME, 32);\n\tstrncpy(drvinfo->version, DRV_VERSION, 32);\n\tsnprintf(drvinfo->fw_version, 32, \"%d\", BOND_ABI_VERSION);\n}\n\nstatic const struct ethtool_ops bond_ethtool_ops = {\n\t.get_drvinfo\t\t= bond_ethtool_get_drvinfo,\n\t.get_link\t\t= ethtool_op_get_link,\n};\n\nstatic const struct net_device_ops bond_netdev_ops = {\n\t.ndo_init\t\t= bond_init,\n\t.ndo_uninit\t\t= bond_uninit,\n\t.ndo_open\t\t= bond_open,\n\t.ndo_stop\t\t= bond_close,\n\t.ndo_start_xmit\t\t= bond_start_xmit,\n\t.ndo_select_queue\t= bond_select_queue,\n\t.ndo_get_stats64\t= bond_get_stats,\n\t.ndo_do_ioctl\t\t= bond_do_ioctl,\n\t.ndo_set_multicast_list\t= bond_set_multicast_list,\n\t.ndo_change_mtu\t\t= bond_change_mtu,\n\t.ndo_set_mac_address\t= bond_set_mac_address,\n\t.ndo_neigh_setup\t= bond_neigh_setup,\n\t.ndo_vlan_rx_add_vid\t= bond_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid\t= bond_vlan_rx_kill_vid,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_netpoll_setup\t= bond_netpoll_setup,\n\t.ndo_netpoll_cleanup\t= bond_netpoll_cleanup,\n\t.ndo_poll_controller\t= bond_poll_controller,\n#endif\n\t.ndo_add_slave\t\t= bond_enslave,\n\t.ndo_del_slave\t\t= bond_release,\n\t.ndo_fix_features\t= bond_fix_features,\n};\n\nstatic void bond_destructor(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tif (bond->wq)\n\t\tdestroy_workqueue(bond->wq);\n\tfree_netdev(bond_dev);\n}\n\nstatic void bond_setup(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\n\t/* initialize rwlocks */\n\trwlock_init(&bond->lock);\n\trwlock_init(&bond->curr_slave_lock);\n\n\tbond->params = bonding_defaults;\n\n\t/* Initialize pointers */\n\tbond->dev = bond_dev;\n\tINIT_LIST_HEAD(&bond->vlan_list);\n\n\t/* Initialize the device entry points */\n\tether_setup(bond_dev);\n\tbond_dev->netdev_ops = &bond_netdev_ops;\n\tbond_dev->ethtool_ops = &bond_ethtool_ops;\n\tbond_set_mode_ops(bond, bond->params.mode);\n\n\tbond_dev->destructor = bond_destructor;\n\n\t/* Initialize the device options */\n\tbond_dev->tx_queue_len = 0;\n\tbond_dev->flags |= IFF_MASTER|IFF_MULTICAST;\n\tbond_dev->priv_flags |= IFF_BONDING;\n\tbond_dev->priv_flags &= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);\n\n\t/* At first, we block adding VLANs. That's the only way to\n\t * prevent problems that occur when adding VLANs over an\n\t * empty bond. The block will be removed once non-challenged\n\t * slaves are enslaved.\n\t */\n\tbond_dev->features |= NETIF_F_VLAN_CHALLENGED;\n\n\t/* don't acquire bond device's netif_tx_lock when\n\t * transmitting */\n\tbond_dev->features |= NETIF_F_LLTX;\n\n\t/* By default, we declare the bond to be fully\n\t * VLAN hardware accelerated capable. Special\n\t * care is taken in the various xmit functions\n\t * when there are slaves that are not hw accel\n\t * capable\n\t */\n\n\tbond_dev->hw_features = BOND_VLAN_FEATURES |\n\t\t\t\tNETIF_F_HW_VLAN_TX |\n\t\t\t\tNETIF_F_HW_VLAN_RX |\n\t\t\t\tNETIF_F_HW_VLAN_FILTER;\n\n\tbond_dev->hw_features &= ~(NETIF_F_ALL_CSUM & ~NETIF_F_NO_CSUM);\n\tbond_dev->features |= bond_dev->hw_features;\n}\n\nstatic void bond_work_cancel_all(struct bonding *bond)\n{\n\twrite_lock_bh(&bond->lock);\n\tbond->kill_timers = 1;\n\twrite_unlock_bh(&bond->lock);\n\n\tif (bond->params.miimon && delayed_work_pending(&bond->mii_work))\n\t\tcancel_delayed_work(&bond->mii_work);\n\n\tif (bond->params.arp_interval && delayed_work_pending(&bond->arp_work))\n\t\tcancel_delayed_work(&bond->arp_work);\n\n\tif (bond->params.mode == BOND_MODE_ALB &&\n\t    delayed_work_pending(&bond->alb_work))\n\t\tcancel_delayed_work(&bond->alb_work);\n\n\tif (bond->params.mode == BOND_MODE_8023AD &&\n\t    delayed_work_pending(&bond->ad_work))\n\t\tcancel_delayed_work(&bond->ad_work);\n\n\tif (delayed_work_pending(&bond->mcast_work))\n\t\tcancel_delayed_work(&bond->mcast_work);\n}\n\n/*\n* Destroy a bonding device.\n* Must be under rtnl_lock when this function is called.\n*/\nstatic void bond_uninit(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct vlan_entry *vlan, *tmp;\n\n\tbond_netpoll_cleanup(bond_dev);\n\n\t/* Release the bonded slaves */\n\tbond_release_all(bond_dev);\n\n\tlist_del(&bond->bond_list);\n\n\tbond_work_cancel_all(bond);\n\n\tbond_remove_proc_entry(bond);\n\n\tbond_debug_unregister(bond);\n\n\t__hw_addr_flush(&bond->mc_list);\n\n\tlist_for_each_entry_safe(vlan, tmp, &bond->vlan_list, vlan_list) {\n\t\tlist_del(&vlan->vlan_list);\n\t\tkfree(vlan);\n\t}\n}\n\n/*------------------------- Module initialization ---------------------------*/\n\n/*\n * Convert string input module parms.  Accept either the\n * number of the mode or its string name.  A bit complicated because\n * some mode names are substrings of other names, and calls from sysfs\n * may have whitespace in the name (trailing newlines, for example).\n */\nint bond_parse_parm(const char *buf, const struct bond_parm_tbl *tbl)\n{\n\tint modeint = -1, i, rv;\n\tchar *p, modestr[BOND_MAX_MODENAME_LEN + 1] = { 0, };\n\n\tfor (p = (char *)buf; *p; p++)\n\t\tif (!(isdigit(*p) || isspace(*p)))\n\t\t\tbreak;\n\n\tif (*p)\n\t\trv = sscanf(buf, \"%20s\", modestr);\n\telse\n\t\trv = sscanf(buf, \"%d\", &modeint);\n\n\tif (!rv)\n\t\treturn -1;\n\n\tfor (i = 0; tbl[i].modename; i++) {\n\t\tif (modeint == tbl[i].mode)\n\t\t\treturn tbl[i].mode;\n\t\tif (strcmp(modestr, tbl[i].modename) == 0)\n\t\t\treturn tbl[i].mode;\n\t}\n\n\treturn -1;\n}\n\nstatic int bond_check_params(struct bond_params *params)\n{\n\tint arp_validate_value, fail_over_mac_value, primary_reselect_value;\n\n\t/*\n\t * Convert string parameters.\n\t */\n\tif (mode) {\n\t\tbond_mode = bond_parse_parm(mode, bond_mode_tbl);\n\t\tif (bond_mode == -1) {\n\t\t\tpr_err(\"Error: Invalid bonding mode \\\"%s\\\"\\n\",\n\t\t\t       mode == NULL ? \"NULL\" : mode);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (xmit_hash_policy) {\n\t\tif ((bond_mode != BOND_MODE_XOR) &&\n\t\t    (bond_mode != BOND_MODE_8023AD)) {\n\t\t\tpr_info(\"xmit_hash_policy param is irrelevant in mode %s\\n\",\n\t\t\t       bond_mode_name(bond_mode));\n\t\t} else {\n\t\t\txmit_hashtype = bond_parse_parm(xmit_hash_policy,\n\t\t\t\t\t\t\txmit_hashtype_tbl);\n\t\t\tif (xmit_hashtype == -1) {\n\t\t\t\tpr_err(\"Error: Invalid xmit_hash_policy \\\"%s\\\"\\n\",\n\t\t\t\t       xmit_hash_policy == NULL ? \"NULL\" :\n\t\t\t\t       xmit_hash_policy);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (lacp_rate) {\n\t\tif (bond_mode != BOND_MODE_8023AD) {\n\t\t\tpr_info(\"lacp_rate param is irrelevant in mode %s\\n\",\n\t\t\t\tbond_mode_name(bond_mode));\n\t\t} else {\n\t\t\tlacp_fast = bond_parse_parm(lacp_rate, bond_lacp_tbl);\n\t\t\tif (lacp_fast == -1) {\n\t\t\t\tpr_err(\"Error: Invalid lacp rate \\\"%s\\\"\\n\",\n\t\t\t\t       lacp_rate == NULL ? \"NULL\" : lacp_rate);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ad_select) {\n\t\tparams->ad_select = bond_parse_parm(ad_select, ad_select_tbl);\n\t\tif (params->ad_select == -1) {\n\t\t\tpr_err(\"Error: Invalid ad_select \\\"%s\\\"\\n\",\n\t\t\t       ad_select == NULL ? \"NULL\" : ad_select);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (bond_mode != BOND_MODE_8023AD) {\n\t\t\tpr_warning(\"ad_select param only affects 802.3ad mode\\n\");\n\t\t}\n\t} else {\n\t\tparams->ad_select = BOND_AD_STABLE;\n\t}\n\n\tif (max_bonds < 0) {\n\t\tpr_warning(\"Warning: max_bonds (%d) not in range %d-%d, so it was reset to BOND_DEFAULT_MAX_BONDS (%d)\\n\",\n\t\t\t   max_bonds, 0, INT_MAX, BOND_DEFAULT_MAX_BONDS);\n\t\tmax_bonds = BOND_DEFAULT_MAX_BONDS;\n\t}\n\n\tif (miimon < 0) {\n\t\tpr_warning(\"Warning: miimon module parameter (%d), not in range 0-%d, so it was reset to %d\\n\",\n\t\t\t   miimon, INT_MAX, BOND_LINK_MON_INTERV);\n\t\tmiimon = BOND_LINK_MON_INTERV;\n\t}\n\n\tif (updelay < 0) {\n\t\tpr_warning(\"Warning: updelay module parameter (%d), not in range 0-%d, so it was reset to 0\\n\",\n\t\t\t   updelay, INT_MAX);\n\t\tupdelay = 0;\n\t}\n\n\tif (downdelay < 0) {\n\t\tpr_warning(\"Warning: downdelay module parameter (%d), not in range 0-%d, so it was reset to 0\\n\",\n\t\t\t   downdelay, INT_MAX);\n\t\tdowndelay = 0;\n\t}\n\n\tif ((use_carrier != 0) && (use_carrier != 1)) {\n\t\tpr_warning(\"Warning: use_carrier module parameter (%d), not of valid value (0/1), so it was set to 1\\n\",\n\t\t\t   use_carrier);\n\t\tuse_carrier = 1;\n\t}\n\n\tif (num_peer_notif < 0 || num_peer_notif > 255) {\n\t\tpr_warning(\"Warning: num_grat_arp/num_unsol_na (%d) not in range 0-255 so it was reset to 1\\n\",\n\t\t\t   num_peer_notif);\n\t\tnum_peer_notif = 1;\n\t}\n\n\t/* reset values for 802.3ad */\n\tif (bond_mode == BOND_MODE_8023AD) {\n\t\tif (!miimon) {\n\t\t\tpr_warning(\"Warning: miimon must be specified, otherwise bonding will not detect link failure, speed and duplex which are essential for 802.3ad operation\\n\");\n\t\t\tpr_warning(\"Forcing miimon to 100msec\\n\");\n\t\t\tmiimon = 100;\n\t\t}\n\t}\n\n\tif (tx_queues < 1 || tx_queues > 255) {\n\t\tpr_warning(\"Warning: tx_queues (%d) should be between \"\n\t\t\t   \"1 and 255, resetting to %d\\n\",\n\t\t\t   tx_queues, BOND_DEFAULT_TX_QUEUES);\n\t\ttx_queues = BOND_DEFAULT_TX_QUEUES;\n\t}\n\n\tif ((all_slaves_active != 0) && (all_slaves_active != 1)) {\n\t\tpr_warning(\"Warning: all_slaves_active module parameter (%d), \"\n\t\t\t   \"not of valid value (0/1), so it was set to \"\n\t\t\t   \"0\\n\", all_slaves_active);\n\t\tall_slaves_active = 0;\n\t}\n\n\tif (resend_igmp < 0 || resend_igmp > 255) {\n\t\tpr_warning(\"Warning: resend_igmp (%d) should be between \"\n\t\t\t   \"0 and 255, resetting to %d\\n\",\n\t\t\t   resend_igmp, BOND_DEFAULT_RESEND_IGMP);\n\t\tresend_igmp = BOND_DEFAULT_RESEND_IGMP;\n\t}\n\n\t/* reset values for TLB/ALB */\n\tif ((bond_mode == BOND_MODE_TLB) ||\n\t    (bond_mode == BOND_MODE_ALB)) {\n\t\tif (!miimon) {\n\t\t\tpr_warning(\"Warning: miimon must be specified, otherwise bonding will not detect link failure and link speed which are essential for TLB/ALB load balancing\\n\");\n\t\t\tpr_warning(\"Forcing miimon to 100msec\\n\");\n\t\t\tmiimon = 100;\n\t\t}\n\t}\n\n\tif (bond_mode == BOND_MODE_ALB) {\n\t\tpr_notice(\"In ALB mode you might experience client disconnections upon reconnection of a link if the bonding module updelay parameter (%d msec) is incompatible with the forwarding delay time of the switch\\n\",\n\t\t\t  updelay);\n\t}\n\n\tif (!miimon) {\n\t\tif (updelay || downdelay) {\n\t\t\t/* just warn the user the up/down delay will have\n\t\t\t * no effect since miimon is zero...\n\t\t\t */\n\t\t\tpr_warning(\"Warning: miimon module parameter not set and updelay (%d) or downdelay (%d) module parameter is set; updelay and downdelay have no effect unless miimon is set\\n\",\n\t\t\t\t   updelay, downdelay);\n\t\t}\n\t} else {\n\t\t/* don't allow arp monitoring */\n\t\tif (arp_interval) {\n\t\t\tpr_warning(\"Warning: miimon (%d) and arp_interval (%d) can't be used simultaneously, disabling ARP monitoring\\n\",\n\t\t\t\t   miimon, arp_interval);\n\t\t\tarp_interval = 0;\n\t\t}\n\n\t\tif ((updelay % miimon) != 0) {\n\t\t\tpr_warning(\"Warning: updelay (%d) is not a multiple of miimon (%d), updelay rounded to %d ms\\n\",\n\t\t\t\t   updelay, miimon,\n\t\t\t\t   (updelay / miimon) * miimon);\n\t\t}\n\n\t\tupdelay /= miimon;\n\n\t\tif ((downdelay % miimon) != 0) {\n\t\t\tpr_warning(\"Warning: downdelay (%d) is not a multiple of miimon (%d), downdelay rounded to %d ms\\n\",\n\t\t\t\t   downdelay, miimon,\n\t\t\t\t   (downdelay / miimon) * miimon);\n\t\t}\n\n\t\tdowndelay /= miimon;\n\t}\n\n\tif (arp_interval < 0) {\n\t\tpr_warning(\"Warning: arp_interval module parameter (%d) , not in range 0-%d, so it was reset to %d\\n\",\n\t\t\t   arp_interval, INT_MAX, BOND_LINK_ARP_INTERV);\n\t\tarp_interval = BOND_LINK_ARP_INTERV;\n\t}\n\n\tfor (arp_ip_count = 0;\n\t     (arp_ip_count < BOND_MAX_ARP_TARGETS) && arp_ip_target[arp_ip_count];\n\t     arp_ip_count++) {\n\t\t/* not complete check, but should be good enough to\n\t\t   catch mistakes */\n\t\tif (!isdigit(arp_ip_target[arp_ip_count][0])) {\n\t\t\tpr_warning(\"Warning: bad arp_ip_target module parameter (%s), ARP monitoring will not be performed\\n\",\n\t\t\t\t   arp_ip_target[arp_ip_count]);\n\t\t\tarp_interval = 0;\n\t\t} else {\n\t\t\t__be32 ip = in_aton(arp_ip_target[arp_ip_count]);\n\t\t\tarp_target[arp_ip_count] = ip;\n\t\t}\n\t}\n\n\tif (arp_interval && !arp_ip_count) {\n\t\t/* don't allow arping if no arp_ip_target given... */\n\t\tpr_warning(\"Warning: arp_interval module parameter (%d) specified without providing an arp_ip_target parameter, arp_interval was reset to 0\\n\",\n\t\t\t   arp_interval);\n\t\tarp_interval = 0;\n\t}\n\n\tif (arp_validate) {\n\t\tif (bond_mode != BOND_MODE_ACTIVEBACKUP) {\n\t\t\tpr_err(\"arp_validate only supported in active-backup mode\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!arp_interval) {\n\t\t\tpr_err(\"arp_validate requires arp_interval\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tarp_validate_value = bond_parse_parm(arp_validate,\n\t\t\t\t\t\t     arp_validate_tbl);\n\t\tif (arp_validate_value == -1) {\n\t\t\tpr_err(\"Error: invalid arp_validate \\\"%s\\\"\\n\",\n\t\t\t       arp_validate == NULL ? \"NULL\" : arp_validate);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else\n\t\tarp_validate_value = 0;\n\n\tif (miimon) {\n\t\tpr_info(\"MII link monitoring set to %d ms\\n\", miimon);\n\t} else if (arp_interval) {\n\t\tint i;\n\n\t\tpr_info(\"ARP monitoring set to %d ms, validate %s, with %d target(s):\",\n\t\t\tarp_interval,\n\t\t\tarp_validate_tbl[arp_validate_value].modename,\n\t\t\tarp_ip_count);\n\n\t\tfor (i = 0; i < arp_ip_count; i++)\n\t\t\tpr_info(\" %s\", arp_ip_target[i]);\n\n\t\tpr_info(\"\\n\");\n\n\t} else if (max_bonds) {\n\t\t/* miimon and arp_interval not set, we need one so things\n\t\t * work as expected, see bonding.txt for details\n\t\t */\n\t\tpr_warning(\"Warning: either miimon or arp_interval and arp_ip_target module parameters must be specified, otherwise bonding will not detect link failures! see bonding.txt for details.\\n\");\n\t}\n\n\tif (primary && !USES_PRIMARY(bond_mode)) {\n\t\t/* currently, using a primary only makes sense\n\t\t * in active backup, TLB or ALB modes\n\t\t */\n\t\tpr_warning(\"Warning: %s primary device specified but has no effect in %s mode\\n\",\n\t\t\t   primary, bond_mode_name(bond_mode));\n\t\tprimary = NULL;\n\t}\n\n\tif (primary && primary_reselect) {\n\t\tprimary_reselect_value = bond_parse_parm(primary_reselect,\n\t\t\t\t\t\t\t pri_reselect_tbl);\n\t\tif (primary_reselect_value == -1) {\n\t\t\tpr_err(\"Error: Invalid primary_reselect \\\"%s\\\"\\n\",\n\t\t\t       primary_reselect ==\n\t\t\t\t\tNULL ? \"NULL\" : primary_reselect);\n\t\t\treturn -EINVAL;\n\t\t}\n\t} else {\n\t\tprimary_reselect_value = BOND_PRI_RESELECT_ALWAYS;\n\t}\n\n\tif (fail_over_mac) {\n\t\tfail_over_mac_value = bond_parse_parm(fail_over_mac,\n\t\t\t\t\t\t      fail_over_mac_tbl);\n\t\tif (fail_over_mac_value == -1) {\n\t\t\tpr_err(\"Error: invalid fail_over_mac \\\"%s\\\"\\n\",\n\t\t\t       arp_validate == NULL ? \"NULL\" : arp_validate);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (bond_mode != BOND_MODE_ACTIVEBACKUP)\n\t\t\tpr_warning(\"Warning: fail_over_mac only affects active-backup mode.\\n\");\n\t} else {\n\t\tfail_over_mac_value = BOND_FOM_NONE;\n\t}\n\n\t/* fill params struct with the proper values */\n\tparams->mode = bond_mode;\n\tparams->xmit_policy = xmit_hashtype;\n\tparams->miimon = miimon;\n\tparams->num_peer_notif = num_peer_notif;\n\tparams->arp_interval = arp_interval;\n\tparams->arp_validate = arp_validate_value;\n\tparams->updelay = updelay;\n\tparams->downdelay = downdelay;\n\tparams->use_carrier = use_carrier;\n\tparams->lacp_fast = lacp_fast;\n\tparams->primary[0] = 0;\n\tparams->primary_reselect = primary_reselect_value;\n\tparams->fail_over_mac = fail_over_mac_value;\n\tparams->tx_queues = tx_queues;\n\tparams->all_slaves_active = all_slaves_active;\n\tparams->resend_igmp = resend_igmp;\n\tparams->min_links = min_links;\n\n\tif (primary) {\n\t\tstrncpy(params->primary, primary, IFNAMSIZ);\n\t\tparams->primary[IFNAMSIZ - 1] = 0;\n\t}\n\n\tmemcpy(params->arp_targets, arp_target, sizeof(arp_target));\n\n\treturn 0;\n}\n\nstatic struct lock_class_key bonding_netdev_xmit_lock_key;\nstatic struct lock_class_key bonding_netdev_addr_lock_key;\n\nstatic void bond_set_lockdep_class_one(struct net_device *dev,\n\t\t\t\t       struct netdev_queue *txq,\n\t\t\t\t       void *_unused)\n{\n\tlockdep_set_class(&txq->_xmit_lock,\n\t\t\t  &bonding_netdev_xmit_lock_key);\n}\n\nstatic void bond_set_lockdep_class(struct net_device *dev)\n{\n\tlockdep_set_class(&dev->addr_list_lock,\n\t\t\t  &bonding_netdev_addr_lock_key);\n\tnetdev_for_each_tx_queue(dev, bond_set_lockdep_class_one, NULL);\n}\n\n/*\n * Called from registration process\n */\nstatic int bond_init(struct net_device *bond_dev)\n{\n\tstruct bonding *bond = netdev_priv(bond_dev);\n\tstruct bond_net *bn = net_generic(dev_net(bond_dev), bond_net_id);\n\tstruct alb_bond_info *bond_info = &(BOND_ALB_INFO(bond));\n\n\tpr_debug(\"Begin bond_init for %s\\n\", bond_dev->name);\n\n\t/*\n\t * Initialize locks that may be required during\n\t * en/deslave operations.  All of the bond_open work\n\t * (of which this is part) should really be moved to\n\t * a phase prior to dev_open\n\t */\n\tspin_lock_init(&(bond_info->tx_hashtbl_lock));\n\tspin_lock_init(&(bond_info->rx_hashtbl_lock));\n\n\tbond->wq = create_singlethread_workqueue(bond_dev->name);\n\tif (!bond->wq)\n\t\treturn -ENOMEM;\n\n\tbond_set_lockdep_class(bond_dev);\n\n\tbond_create_proc_entry(bond);\n\tlist_add_tail(&bond->bond_list, &bn->dev_list);\n\n\tbond_prepare_sysfs_group(bond);\n\n\tbond_debug_register(bond);\n\n\t__hw_addr_init(&bond->mc_list);\n\treturn 0;\n}\n\nstatic int bond_validate(struct nlattr *tb[], struct nlattr *data[])\n{\n\tif (tb[IFLA_ADDRESS]) {\n\t\tif (nla_len(tb[IFLA_ADDRESS]) != ETH_ALEN)\n\t\t\treturn -EINVAL;\n\t\tif (!is_valid_ether_addr(nla_data(tb[IFLA_ADDRESS])))\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\treturn 0;\n}\n\nstatic struct rtnl_link_ops bond_link_ops __read_mostly = {\n\t.kind\t\t= \"bond\",\n\t.priv_size\t= sizeof(struct bonding),\n\t.setup\t\t= bond_setup,\n\t.validate\t= bond_validate,\n};\n\n/* Create a new bond based on the specified name and bonding parameters.\n * If name is NULL, obtain a suitable \"bond%d\" name for us.\n * Caller must NOT hold rtnl_lock; we need to release it here before we\n * set up our sysfs entries.\n */\nint bond_create(struct net *net, const char *name)\n{\n\tstruct net_device *bond_dev;\n\tint res;\n\n\trtnl_lock();\n\n\tbond_dev = alloc_netdev_mq(sizeof(struct bonding),\n\t\t\t\t   name ? name : \"bond%d\",\n\t\t\t\t   bond_setup, tx_queues);\n\tif (!bond_dev) {\n\t\tpr_err(\"%s: eek! can't alloc netdev!\\n\", name);\n\t\trtnl_unlock();\n\t\treturn -ENOMEM;\n\t}\n\n\tdev_net_set(bond_dev, net);\n\tbond_dev->rtnl_link_ops = &bond_link_ops;\n\n\tres = register_netdevice(bond_dev);\n\n\tnetif_carrier_off(bond_dev);\n\n\trtnl_unlock();\n\tif (res < 0)\n\t\tbond_destructor(bond_dev);\n\treturn res;\n}\n\nstatic int __net_init bond_net_init(struct net *net)\n{\n\tstruct bond_net *bn = net_generic(net, bond_net_id);\n\n\tbn->net = net;\n\tINIT_LIST_HEAD(&bn->dev_list);\n\n\tbond_create_proc_dir(bn);\n\t\n\treturn 0;\n}\n\nstatic void __net_exit bond_net_exit(struct net *net)\n{\n\tstruct bond_net *bn = net_generic(net, bond_net_id);\n\n\tbond_destroy_proc_dir(bn);\n}\n\nstatic struct pernet_operations bond_net_ops = {\n\t.init = bond_net_init,\n\t.exit = bond_net_exit,\n\t.id   = &bond_net_id,\n\t.size = sizeof(struct bond_net),\n};\n\nstatic int __init bonding_init(void)\n{\n\tint i;\n\tint res;\n\n\tpr_info(\"%s\", bond_version);\n\n\tres = bond_check_params(&bonding_defaults);\n\tif (res)\n\t\tgoto out;\n\n\tres = register_pernet_subsys(&bond_net_ops);\n\tif (res)\n\t\tgoto out;\n\n\tres = rtnl_link_register(&bond_link_ops);\n\tif (res)\n\t\tgoto err_link;\n\n\tbond_create_debugfs();\n\n\tfor (i = 0; i < max_bonds; i++) {\n\t\tres = bond_create(&init_net, NULL);\n\t\tif (res)\n\t\t\tgoto err;\n\t}\n\n\tres = bond_create_sysfs();\n\tif (res)\n\t\tgoto err;\n\n\tregister_netdevice_notifier(&bond_netdev_notifier);\n\tregister_inetaddr_notifier(&bond_inetaddr_notifier);\nout:\n\treturn res;\nerr:\n\trtnl_link_unregister(&bond_link_ops);\nerr_link:\n\tunregister_pernet_subsys(&bond_net_ops);\n\tgoto out;\n\n}\n\nstatic void __exit bonding_exit(void)\n{\n\tunregister_netdevice_notifier(&bond_netdev_notifier);\n\tunregister_inetaddr_notifier(&bond_inetaddr_notifier);\n\n\tbond_destroy_sysfs();\n\tbond_destroy_debugfs();\n\n\trtnl_link_unregister(&bond_link_ops);\n\tunregister_pernet_subsys(&bond_net_ops);\n\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t/*\n\t * Make sure we don't have an imbalance on our netpoll blocking\n\t */\n\tWARN_ON(atomic_read(&netpoll_block_tx));\n#endif\n}\n\nmodule_init(bonding_init);\nmodule_exit(bonding_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(DRV_VERSION);\nMODULE_DESCRIPTION(DRV_DESCRIPTION \", v\" DRV_VERSION);\nMODULE_AUTHOR(\"Thomas Davis, tadavis@lbl.gov and many others\");\nMODULE_ALIAS_RTNL_LINK(\"bond\");\n", "/* drivers/net/ifb.c:\n\n\tThe purpose of this driver is to provide a device that allows\n\tfor sharing of resources:\n\n\t1) qdiscs/policies that are per device as opposed to system wide.\n\tifb allows for a device which can be redirected to thus providing\n\tan impression of sharing.\n\n\t2) Allows for queueing incoming traffic for shaping instead of\n\tdropping.\n\n\tThe original concept is based on what is known as the IMQ\n\tdriver initially written by Martin Devera, later rewritten\n\tby Patrick McHardy and then maintained by Andre Correa.\n\n\tYou need the tc action  mirror or redirect to feed this device\n       \tpackets.\n\n\tThis program is free software; you can redistribute it and/or\n\tmodify it under the terms of the GNU General Public License\n\tas published by the Free Software Foundation; either version\n\t2 of the License, or (at your option) any later version.\n\n  \tAuthors:\tJamal Hadi Salim (2005)\n\n*/\n\n\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/moduleparam.h>\n#include <net/pkt_sched.h>\n#include <net/net_namespace.h>\n\n#define TX_Q_LIMIT    32\nstruct ifb_private {\n\tstruct tasklet_struct   ifb_tasklet;\n\tint     tasklet_pending;\n\n\tstruct u64_stats_sync\trsync;\n\tstruct sk_buff_head     rq;\n\tu64 rx_packets;\n\tu64 rx_bytes;\n\n\tstruct u64_stats_sync\ttsync;\n\tstruct sk_buff_head     tq;\n\tu64 tx_packets;\n\tu64 tx_bytes;\n};\n\nstatic int numifbs = 2;\n\nstatic void ri_tasklet(unsigned long dev);\nstatic netdev_tx_t ifb_xmit(struct sk_buff *skb, struct net_device *dev);\nstatic int ifb_open(struct net_device *dev);\nstatic int ifb_close(struct net_device *dev);\n\nstatic void ri_tasklet(unsigned long dev)\n{\n\tstruct net_device *_dev = (struct net_device *)dev;\n\tstruct ifb_private *dp = netdev_priv(_dev);\n\tstruct netdev_queue *txq;\n\tstruct sk_buff *skb;\n\n\ttxq = netdev_get_tx_queue(_dev, 0);\n\tif ((skb = skb_peek(&dp->tq)) == NULL) {\n\t\tif (__netif_tx_trylock(txq)) {\n\t\t\tskb_queue_splice_tail_init(&dp->rq, &dp->tq);\n\t\t\t__netif_tx_unlock(txq);\n\t\t} else {\n\t\t\t/* reschedule */\n\t\t\tgoto resched;\n\t\t}\n\t}\n\n\twhile ((skb = __skb_dequeue(&dp->tq)) != NULL) {\n\t\tu32 from = G_TC_FROM(skb->tc_verd);\n\n\t\tskb->tc_verd = 0;\n\t\tskb->tc_verd = SET_TC_NCLS(skb->tc_verd);\n\n\t\tu64_stats_update_begin(&dp->tsync);\n\t\tdp->tx_packets++;\n\t\tdp->tx_bytes += skb->len;\n\t\tu64_stats_update_end(&dp->tsync);\n\n\t\trcu_read_lock();\n\t\tskb->dev = dev_get_by_index_rcu(&init_net, skb->skb_iif);\n\t\tif (!skb->dev) {\n\t\t\trcu_read_unlock();\n\t\t\tdev_kfree_skb(skb);\n\t\t\t_dev->stats.tx_dropped++;\n\t\t\tif (skb_queue_len(&dp->tq) != 0)\n\t\t\t\tgoto resched;\n\t\t\tbreak;\n\t\t}\n\t\trcu_read_unlock();\n\t\tskb->skb_iif = _dev->ifindex;\n\n\t\tif (from & AT_EGRESS) {\n\t\t\tdev_queue_xmit(skb);\n\t\t} else if (from & AT_INGRESS) {\n\t\t\tskb_pull(skb, skb->dev->hard_header_len);\n\t\t\tnetif_receive_skb(skb);\n\t\t} else\n\t\t\tBUG();\n\t}\n\n\tif (__netif_tx_trylock(txq)) {\n\t\tif ((skb = skb_peek(&dp->rq)) == NULL) {\n\t\t\tdp->tasklet_pending = 0;\n\t\t\tif (netif_queue_stopped(_dev))\n\t\t\t\tnetif_wake_queue(_dev);\n\t\t} else {\n\t\t\t__netif_tx_unlock(txq);\n\t\t\tgoto resched;\n\t\t}\n\t\t__netif_tx_unlock(txq);\n\t} else {\nresched:\n\t\tdp->tasklet_pending = 1;\n\t\ttasklet_schedule(&dp->ifb_tasklet);\n\t}\n\n}\n\nstatic struct rtnl_link_stats64 *ifb_stats64(struct net_device *dev,\n\t\t\t\t\t     struct rtnl_link_stats64 *stats)\n{\n\tstruct ifb_private *dp = netdev_priv(dev);\n\tunsigned int start;\n\n\tdo {\n\t\tstart = u64_stats_fetch_begin_bh(&dp->rsync);\n\t\tstats->rx_packets = dp->rx_packets;\n\t\tstats->rx_bytes = dp->rx_bytes;\n\t} while (u64_stats_fetch_retry_bh(&dp->rsync, start));\n\n\tdo {\n\t\tstart = u64_stats_fetch_begin_bh(&dp->tsync);\n\n\t\tstats->tx_packets = dp->tx_packets;\n\t\tstats->tx_bytes = dp->tx_bytes;\n\n\t} while (u64_stats_fetch_retry_bh(&dp->tsync, start));\n\n\tstats->rx_dropped = dev->stats.rx_dropped;\n\tstats->tx_dropped = dev->stats.tx_dropped;\n\n\treturn stats;\n}\n\n\nstatic const struct net_device_ops ifb_netdev_ops = {\n\t.ndo_open\t= ifb_open,\n\t.ndo_stop\t= ifb_close,\n\t.ndo_get_stats64 = ifb_stats64,\n\t.ndo_start_xmit\t= ifb_xmit,\n\t.ndo_validate_addr = eth_validate_addr,\n};\n\n#define IFB_FEATURES (NETIF_F_NO_CSUM | NETIF_F_SG  | NETIF_F_FRAGLIST\t| \\\n\t\t      NETIF_F_TSO_ECN | NETIF_F_TSO | NETIF_F_TSO6\t| \\\n\t\t      NETIF_F_HIGHDMA | NETIF_F_HW_VLAN_TX)\n\nstatic void ifb_setup(struct net_device *dev)\n{\n\t/* Initialize the device structure. */\n\tdev->destructor = free_netdev;\n\tdev->netdev_ops = &ifb_netdev_ops;\n\n\t/* Fill in device structure with ethernet-generic values. */\n\tether_setup(dev);\n\tdev->tx_queue_len = TX_Q_LIMIT;\n\n\tdev->features |= IFB_FEATURES;\n\tdev->vlan_features |= IFB_FEATURES;\n\n\tdev->flags |= IFF_NOARP;\n\tdev->flags &= ~IFF_MULTICAST;\n\tdev->priv_flags &= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);\n\trandom_ether_addr(dev->dev_addr);\n}\n\nstatic netdev_tx_t ifb_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct ifb_private *dp = netdev_priv(dev);\n\tu32 from = G_TC_FROM(skb->tc_verd);\n\n\tu64_stats_update_begin(&dp->rsync);\n\tdp->rx_packets++;\n\tdp->rx_bytes += skb->len;\n\tu64_stats_update_end(&dp->rsync);\n\n\tif (!(from & (AT_INGRESS|AT_EGRESS)) || !skb->skb_iif) {\n\t\tdev_kfree_skb(skb);\n\t\tdev->stats.rx_dropped++;\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tif (skb_queue_len(&dp->rq) >= dev->tx_queue_len) {\n\t\tnetif_stop_queue(dev);\n\t}\n\n\t__skb_queue_tail(&dp->rq, skb);\n\tif (!dp->tasklet_pending) {\n\t\tdp->tasklet_pending = 1;\n\t\ttasklet_schedule(&dp->ifb_tasklet);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic int ifb_close(struct net_device *dev)\n{\n\tstruct ifb_private *dp = netdev_priv(dev);\n\n\ttasklet_kill(&dp->ifb_tasklet);\n\tnetif_stop_queue(dev);\n\t__skb_queue_purge(&dp->rq);\n\t__skb_queue_purge(&dp->tq);\n\treturn 0;\n}\n\nstatic int ifb_open(struct net_device *dev)\n{\n\tstruct ifb_private *dp = netdev_priv(dev);\n\n\ttasklet_init(&dp->ifb_tasklet, ri_tasklet, (unsigned long)dev);\n\t__skb_queue_head_init(&dp->rq);\n\t__skb_queue_head_init(&dp->tq);\n\tnetif_start_queue(dev);\n\n\treturn 0;\n}\n\nstatic int ifb_validate(struct nlattr *tb[], struct nlattr *data[])\n{\n\tif (tb[IFLA_ADDRESS]) {\n\t\tif (nla_len(tb[IFLA_ADDRESS]) != ETH_ALEN)\n\t\t\treturn -EINVAL;\n\t\tif (!is_valid_ether_addr(nla_data(tb[IFLA_ADDRESS])))\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\treturn 0;\n}\n\nstatic struct rtnl_link_ops ifb_link_ops __read_mostly = {\n\t.kind\t\t= \"ifb\",\n\t.priv_size\t= sizeof(struct ifb_private),\n\t.setup\t\t= ifb_setup,\n\t.validate\t= ifb_validate,\n};\n\n/* Number of ifb devices to be set up by this module. */\nmodule_param(numifbs, int, 0);\nMODULE_PARM_DESC(numifbs, \"Number of ifb devices\");\n\nstatic int __init ifb_init_one(int index)\n{\n\tstruct net_device *dev_ifb;\n\tint err;\n\n\tdev_ifb = alloc_netdev(sizeof(struct ifb_private),\n\t\t\t\t \"ifb%d\", ifb_setup);\n\n\tif (!dev_ifb)\n\t\treturn -ENOMEM;\n\n\tdev_ifb->rtnl_link_ops = &ifb_link_ops;\n\terr = register_netdevice(dev_ifb);\n\tif (err < 0)\n\t\tgoto err;\n\n\treturn 0;\n\nerr:\n\tfree_netdev(dev_ifb);\n\treturn err;\n}\n\nstatic int __init ifb_init_module(void)\n{\n\tint i, err;\n\n\trtnl_lock();\n\terr = __rtnl_link_register(&ifb_link_ops);\n\n\tfor (i = 0; i < numifbs && !err; i++)\n\t\terr = ifb_init_one(i);\n\tif (err)\n\t\t__rtnl_link_unregister(&ifb_link_ops);\n\trtnl_unlock();\n\n\treturn err;\n}\n\nstatic void __exit ifb_cleanup_module(void)\n{\n\trtnl_link_unregister(&ifb_link_ops);\n}\n\nmodule_init(ifb_init_module);\nmodule_exit(ifb_cleanup_module);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Jamal Hadi Salim\");\nMODULE_ALIAS_RTNL_LINK(\"ifb\");\n", "/*\n * Copyright (c) 2007 Patrick McHardy <kaber@trash.net>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of\n * the License, or (at your option) any later version.\n *\n * The code this is based on carried the following copyright notice:\n * ---\n * (C) Copyright 2001-2006\n * Alex Zeffertt, Cambridge Broadband Ltd, ajz@cambridgebroadband.com\n * Re-worked by Ben Greear <greearb@candelatech.com>\n * ---\n */\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/rculist.h>\n#include <linux/notifier.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <linux/if_arp.h>\n#include <linux/if_link.h>\n#include <linux/if_macvlan.h>\n#include <net/rtnetlink.h>\n#include <net/xfrm.h>\n\n#define MACVLAN_HASH_SIZE\t(1 << BITS_PER_BYTE)\n\nstruct macvlan_port {\n\tstruct net_device\t*dev;\n\tstruct hlist_head\tvlan_hash[MACVLAN_HASH_SIZE];\n\tstruct list_head\tvlans;\n\tstruct rcu_head\t\trcu;\n\tbool \t\t\tpassthru;\n\tint\t\t\tcount;\n};\n\nstatic void macvlan_port_destroy(struct net_device *dev);\n\n#define macvlan_port_get_rcu(dev) \\\n\t((struct macvlan_port *) rcu_dereference(dev->rx_handler_data))\n#define macvlan_port_get(dev) ((struct macvlan_port *) dev->rx_handler_data)\n#define macvlan_port_exists(dev) (dev->priv_flags & IFF_MACVLAN_PORT)\n\nstatic struct macvlan_dev *macvlan_hash_lookup(const struct macvlan_port *port,\n\t\t\t\t\t       const unsigned char *addr)\n{\n\tstruct macvlan_dev *vlan;\n\tstruct hlist_node *n;\n\n\thlist_for_each_entry_rcu(vlan, n, &port->vlan_hash[addr[5]], hlist) {\n\t\tif (!compare_ether_addr_64bits(vlan->dev->dev_addr, addr))\n\t\t\treturn vlan;\n\t}\n\treturn NULL;\n}\n\nstatic void macvlan_hash_add(struct macvlan_dev *vlan)\n{\n\tstruct macvlan_port *port = vlan->port;\n\tconst unsigned char *addr = vlan->dev->dev_addr;\n\n\thlist_add_head_rcu(&vlan->hlist, &port->vlan_hash[addr[5]]);\n}\n\nstatic void macvlan_hash_del(struct macvlan_dev *vlan, bool sync)\n{\n\thlist_del_rcu(&vlan->hlist);\n\tif (sync)\n\t\tsynchronize_rcu();\n}\n\nstatic void macvlan_hash_change_addr(struct macvlan_dev *vlan,\n\t\t\t\t\tconst unsigned char *addr)\n{\n\tmacvlan_hash_del(vlan, true);\n\t/* Now that we are unhashed it is safe to change the device\n\t * address without confusing packet delivery.\n\t */\n\tmemcpy(vlan->dev->dev_addr, addr, ETH_ALEN);\n\tmacvlan_hash_add(vlan);\n}\n\nstatic int macvlan_addr_busy(const struct macvlan_port *port,\n\t\t\t\tconst unsigned char *addr)\n{\n\t/* Test to see if the specified multicast address is\n\t * currently in use by the underlying device or\n\t * another macvlan.\n\t */\n\tif (!compare_ether_addr_64bits(port->dev->dev_addr, addr))\n\t\treturn 1;\n\n\tif (macvlan_hash_lookup(port, addr))\n\t\treturn 1;\n\n\treturn 0;\n}\n\n\nstatic int macvlan_broadcast_one(struct sk_buff *skb,\n\t\t\t\t const struct macvlan_dev *vlan,\n\t\t\t\t const struct ethhdr *eth, bool local)\n{\n\tstruct net_device *dev = vlan->dev;\n\tif (!skb)\n\t\treturn NET_RX_DROP;\n\n\tif (local)\n\t\treturn vlan->forward(dev, skb);\n\n\tskb->dev = dev;\n\tif (!compare_ether_addr_64bits(eth->h_dest,\n\t\t\t\t       dev->broadcast))\n\t\tskb->pkt_type = PACKET_BROADCAST;\n\telse\n\t\tskb->pkt_type = PACKET_MULTICAST;\n\n\treturn vlan->receive(skb);\n}\n\nstatic void macvlan_broadcast(struct sk_buff *skb,\n\t\t\t      const struct macvlan_port *port,\n\t\t\t      struct net_device *src,\n\t\t\t      enum macvlan_mode mode)\n{\n\tconst struct ethhdr *eth = eth_hdr(skb);\n\tconst struct macvlan_dev *vlan;\n\tstruct hlist_node *n;\n\tstruct sk_buff *nskb;\n\tunsigned int i;\n\tint err;\n\n\tif (skb->protocol == htons(ETH_P_PAUSE))\n\t\treturn;\n\n\tfor (i = 0; i < MACVLAN_HASH_SIZE; i++) {\n\t\thlist_for_each_entry_rcu(vlan, n, &port->vlan_hash[i], hlist) {\n\t\t\tif (vlan->dev == src || !(vlan->mode & mode))\n\t\t\t\tcontinue;\n\n\t\t\tnskb = skb_clone(skb, GFP_ATOMIC);\n\t\t\terr = macvlan_broadcast_one(nskb, vlan, eth,\n\t\t\t\t\t mode == MACVLAN_MODE_BRIDGE);\n\t\t\tmacvlan_count_rx(vlan, skb->len + ETH_HLEN,\n\t\t\t\t\t err == NET_RX_SUCCESS, 1);\n\t\t}\n\t}\n}\n\n/* called under rcu_read_lock() from netif_receive_skb */\nstatic rx_handler_result_t macvlan_handle_frame(struct sk_buff **pskb)\n{\n\tstruct macvlan_port *port;\n\tstruct sk_buff *skb = *pskb;\n\tconst struct ethhdr *eth = eth_hdr(skb);\n\tconst struct macvlan_dev *vlan;\n\tconst struct macvlan_dev *src;\n\tstruct net_device *dev;\n\tunsigned int len = 0;\n\tint ret = NET_RX_DROP;\n\n\tport = macvlan_port_get_rcu(skb->dev);\n\tif (is_multicast_ether_addr(eth->h_dest)) {\n\t\tsrc = macvlan_hash_lookup(port, eth->h_source);\n\t\tif (!src)\n\t\t\t/* frame comes from an external address */\n\t\t\tmacvlan_broadcast(skb, port, NULL,\n\t\t\t\t\t  MACVLAN_MODE_PRIVATE |\n\t\t\t\t\t  MACVLAN_MODE_VEPA    |\n\t\t\t\t\t  MACVLAN_MODE_PASSTHRU|\n\t\t\t\t\t  MACVLAN_MODE_BRIDGE);\n\t\telse if (src->mode == MACVLAN_MODE_VEPA)\n\t\t\t/* flood to everyone except source */\n\t\t\tmacvlan_broadcast(skb, port, src->dev,\n\t\t\t\t\t  MACVLAN_MODE_VEPA |\n\t\t\t\t\t  MACVLAN_MODE_BRIDGE);\n\t\telse if (src->mode == MACVLAN_MODE_BRIDGE)\n\t\t\t/*\n\t\t\t * flood only to VEPA ports, bridge ports\n\t\t\t * already saw the frame on the way out.\n\t\t\t */\n\t\t\tmacvlan_broadcast(skb, port, src->dev,\n\t\t\t\t\t  MACVLAN_MODE_VEPA);\n\t\treturn RX_HANDLER_PASS;\n\t}\n\n\tif (port->passthru)\n\t\tvlan = list_first_entry(&port->vlans, struct macvlan_dev, list);\n\telse\n\t\tvlan = macvlan_hash_lookup(port, eth->h_dest);\n\tif (vlan == NULL)\n\t\treturn RX_HANDLER_PASS;\n\n\tdev = vlan->dev;\n\tif (unlikely(!(dev->flags & IFF_UP))) {\n\t\tkfree_skb(skb);\n\t\treturn RX_HANDLER_CONSUMED;\n\t}\n\tlen = skb->len + ETH_HLEN;\n\tskb = skb_share_check(skb, GFP_ATOMIC);\n\tif (!skb)\n\t\tgoto out;\n\n\tskb->dev = dev;\n\tskb->pkt_type = PACKET_HOST;\n\n\tret = vlan->receive(skb);\n\nout:\n\tmacvlan_count_rx(vlan, len, ret == NET_RX_SUCCESS, 0);\n\treturn RX_HANDLER_CONSUMED;\n}\n\nstatic int macvlan_queue_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tconst struct macvlan_dev *vlan = netdev_priv(dev);\n\tconst struct macvlan_port *port = vlan->port;\n\tconst struct macvlan_dev *dest;\n\t__u8 ip_summed = skb->ip_summed;\n\n\tif (vlan->mode == MACVLAN_MODE_BRIDGE) {\n\t\tconst struct ethhdr *eth = (void *)skb->data;\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\t\t/* send to other bridge ports directly */\n\t\tif (is_multicast_ether_addr(eth->h_dest)) {\n\t\t\tmacvlan_broadcast(skb, port, dev, MACVLAN_MODE_BRIDGE);\n\t\t\tgoto xmit_world;\n\t\t}\n\n\t\tdest = macvlan_hash_lookup(port, eth->h_dest);\n\t\tif (dest && dest->mode == MACVLAN_MODE_BRIDGE) {\n\t\t\t/* send to lowerdev first for its network taps */\n\t\t\tvlan->forward(vlan->lowerdev, skb);\n\n\t\t\treturn NET_XMIT_SUCCESS;\n\t\t}\n\t}\n\nxmit_world:\n\tskb->ip_summed = ip_summed;\n\tskb_set_dev(skb, vlan->lowerdev);\n\treturn dev_queue_xmit(skb);\n}\n\nnetdev_tx_t macvlan_start_xmit(struct sk_buff *skb,\n\t\t\t       struct net_device *dev)\n{\n\tunsigned int len = skb->len;\n\tint ret;\n\tconst struct macvlan_dev *vlan = netdev_priv(dev);\n\n\tret = macvlan_queue_xmit(skb, dev);\n\tif (likely(ret == NET_XMIT_SUCCESS || ret == NET_XMIT_CN)) {\n\t\tstruct macvlan_pcpu_stats *pcpu_stats;\n\n\t\tpcpu_stats = this_cpu_ptr(vlan->pcpu_stats);\n\t\tu64_stats_update_begin(&pcpu_stats->syncp);\n\t\tpcpu_stats->tx_packets++;\n\t\tpcpu_stats->tx_bytes += len;\n\t\tu64_stats_update_end(&pcpu_stats->syncp);\n\t} else {\n\t\tthis_cpu_inc(vlan->pcpu_stats->tx_dropped);\n\t}\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(macvlan_start_xmit);\n\nstatic int macvlan_hard_header(struct sk_buff *skb, struct net_device *dev,\n\t\t\t       unsigned short type, const void *daddr,\n\t\t\t       const void *saddr, unsigned len)\n{\n\tconst struct macvlan_dev *vlan = netdev_priv(dev);\n\tstruct net_device *lowerdev = vlan->lowerdev;\n\n\treturn dev_hard_header(skb, lowerdev, type, daddr,\n\t\t\t       saddr ? : dev->dev_addr, len);\n}\n\nstatic const struct header_ops macvlan_hard_header_ops = {\n\t.create  \t= macvlan_hard_header,\n\t.rebuild\t= eth_rebuild_header,\n\t.parse\t\t= eth_header_parse,\n\t.cache\t\t= eth_header_cache,\n\t.cache_update\t= eth_header_cache_update,\n};\n\nstatic int macvlan_open(struct net_device *dev)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tstruct net_device *lowerdev = vlan->lowerdev;\n\tint err;\n\n\tif (vlan->port->passthru) {\n\t\tdev_set_promiscuity(lowerdev, 1);\n\t\tgoto hash_add;\n\t}\n\n\terr = -EBUSY;\n\tif (macvlan_addr_busy(vlan->port, dev->dev_addr))\n\t\tgoto out;\n\n\terr = dev_uc_add(lowerdev, dev->dev_addr);\n\tif (err < 0)\n\t\tgoto out;\n\tif (dev->flags & IFF_ALLMULTI) {\n\t\terr = dev_set_allmulti(lowerdev, 1);\n\t\tif (err < 0)\n\t\t\tgoto del_unicast;\n\t}\n\nhash_add:\n\tmacvlan_hash_add(vlan);\n\treturn 0;\n\ndel_unicast:\n\tdev_uc_del(lowerdev, dev->dev_addr);\nout:\n\treturn err;\n}\n\nstatic int macvlan_stop(struct net_device *dev)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tstruct net_device *lowerdev = vlan->lowerdev;\n\n\tif (vlan->port->passthru) {\n\t\tdev_set_promiscuity(lowerdev, -1);\n\t\tgoto hash_del;\n\t}\n\n\tdev_mc_unsync(lowerdev, dev);\n\tif (dev->flags & IFF_ALLMULTI)\n\t\tdev_set_allmulti(lowerdev, -1);\n\n\tdev_uc_del(lowerdev, dev->dev_addr);\n\nhash_del:\n\tmacvlan_hash_del(vlan, !dev->dismantle);\n\treturn 0;\n}\n\nstatic int macvlan_set_mac_address(struct net_device *dev, void *p)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tstruct net_device *lowerdev = vlan->lowerdev;\n\tstruct sockaddr *addr = p;\n\tint err;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\tif (!(dev->flags & IFF_UP)) {\n\t\t/* Just copy in the new address */\n\t\tmemcpy(dev->dev_addr, addr->sa_data, ETH_ALEN);\n\t} else {\n\t\t/* Rehash and update the device filters */\n\t\tif (macvlan_addr_busy(vlan->port, addr->sa_data))\n\t\t\treturn -EBUSY;\n\n\t\terr = dev_uc_add(lowerdev, addr->sa_data);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tdev_uc_del(lowerdev, dev->dev_addr);\n\n\t\tmacvlan_hash_change_addr(vlan, addr->sa_data);\n\t}\n\treturn 0;\n}\n\nstatic void macvlan_change_rx_flags(struct net_device *dev, int change)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tstruct net_device *lowerdev = vlan->lowerdev;\n\n\tif (change & IFF_ALLMULTI)\n\t\tdev_set_allmulti(lowerdev, dev->flags & IFF_ALLMULTI ? 1 : -1);\n}\n\nstatic void macvlan_set_multicast_list(struct net_device *dev)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\n\tdev_mc_sync(vlan->lowerdev, dev);\n}\n\nstatic int macvlan_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\n\tif (new_mtu < 68 || vlan->lowerdev->mtu < new_mtu)\n\t\treturn -EINVAL;\n\tdev->mtu = new_mtu;\n\treturn 0;\n}\n\n/*\n * macvlan network devices have devices nesting below it and are a special\n * \"super class\" of normal network devices; split their locks off into a\n * separate class since they always nest.\n */\nstatic struct lock_class_key macvlan_netdev_xmit_lock_key;\nstatic struct lock_class_key macvlan_netdev_addr_lock_key;\n\n#define MACVLAN_FEATURES \\\n\t(NETIF_F_SG | NETIF_F_ALL_CSUM | NETIF_F_HIGHDMA | NETIF_F_FRAGLIST | \\\n\t NETIF_F_GSO | NETIF_F_TSO | NETIF_F_UFO | NETIF_F_GSO_ROBUST | \\\n\t NETIF_F_TSO_ECN | NETIF_F_TSO6 | NETIF_F_GRO | NETIF_F_RXCSUM | \\\n\t NETIF_F_HW_VLAN_FILTER)\n\n#define MACVLAN_STATE_MASK \\\n\t((1<<__LINK_STATE_NOCARRIER) | (1<<__LINK_STATE_DORMANT))\n\nstatic void macvlan_set_lockdep_class_one(struct net_device *dev,\n\t\t\t\t\t  struct netdev_queue *txq,\n\t\t\t\t\t  void *_unused)\n{\n\tlockdep_set_class(&txq->_xmit_lock,\n\t\t\t  &macvlan_netdev_xmit_lock_key);\n}\n\nstatic void macvlan_set_lockdep_class(struct net_device *dev)\n{\n\tlockdep_set_class(&dev->addr_list_lock,\n\t\t\t  &macvlan_netdev_addr_lock_key);\n\tnetdev_for_each_tx_queue(dev, macvlan_set_lockdep_class_one, NULL);\n}\n\nstatic int macvlan_init(struct net_device *dev)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tconst struct net_device *lowerdev = vlan->lowerdev;\n\n\tdev->state\t\t= (dev->state & ~MACVLAN_STATE_MASK) |\n\t\t\t\t  (lowerdev->state & MACVLAN_STATE_MASK);\n\tdev->features \t\t= lowerdev->features & MACVLAN_FEATURES;\n\tdev->features\t\t|= NETIF_F_LLTX;\n\tdev->gso_max_size\t= lowerdev->gso_max_size;\n\tdev->iflink\t\t= lowerdev->ifindex;\n\tdev->hard_header_len\t= lowerdev->hard_header_len;\n\n\tmacvlan_set_lockdep_class(dev);\n\n\tvlan->pcpu_stats = alloc_percpu(struct macvlan_pcpu_stats);\n\tif (!vlan->pcpu_stats)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void macvlan_uninit(struct net_device *dev)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tstruct macvlan_port *port = vlan->port;\n\n\tfree_percpu(vlan->pcpu_stats);\n\n\tport->count -= 1;\n\tif (!port->count)\n\t\tmacvlan_port_destroy(port->dev);\n}\n\nstatic struct rtnl_link_stats64 *macvlan_dev_get_stats64(struct net_device *dev,\n\t\t\t\t\t\t\t struct rtnl_link_stats64 *stats)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\n\tif (vlan->pcpu_stats) {\n\t\tstruct macvlan_pcpu_stats *p;\n\t\tu64 rx_packets, rx_bytes, rx_multicast, tx_packets, tx_bytes;\n\t\tu32 rx_errors = 0, tx_dropped = 0;\n\t\tunsigned int start;\n\t\tint i;\n\n\t\tfor_each_possible_cpu(i) {\n\t\t\tp = per_cpu_ptr(vlan->pcpu_stats, i);\n\t\t\tdo {\n\t\t\t\tstart = u64_stats_fetch_begin_bh(&p->syncp);\n\t\t\t\trx_packets\t= p->rx_packets;\n\t\t\t\trx_bytes\t= p->rx_bytes;\n\t\t\t\trx_multicast\t= p->rx_multicast;\n\t\t\t\ttx_packets\t= p->tx_packets;\n\t\t\t\ttx_bytes\t= p->tx_bytes;\n\t\t\t} while (u64_stats_fetch_retry_bh(&p->syncp, start));\n\n\t\t\tstats->rx_packets\t+= rx_packets;\n\t\t\tstats->rx_bytes\t\t+= rx_bytes;\n\t\t\tstats->multicast\t+= rx_multicast;\n\t\t\tstats->tx_packets\t+= tx_packets;\n\t\t\tstats->tx_bytes\t\t+= tx_bytes;\n\t\t\t/* rx_errors & tx_dropped are u32, updated\n\t\t\t * without syncp protection.\n\t\t\t */\n\t\t\trx_errors\t+= p->rx_errors;\n\t\t\ttx_dropped\t+= p->tx_dropped;\n\t\t}\n\t\tstats->rx_errors\t= rx_errors;\n\t\tstats->rx_dropped\t= rx_errors;\n\t\tstats->tx_dropped\t= tx_dropped;\n\t}\n\treturn stats;\n}\n\nstatic void macvlan_vlan_rx_add_vid(struct net_device *dev,\n\t\t\t\t    unsigned short vid)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tstruct net_device *lowerdev = vlan->lowerdev;\n\tconst struct net_device_ops *ops = lowerdev->netdev_ops;\n\n\tif (ops->ndo_vlan_rx_add_vid)\n\t\tops->ndo_vlan_rx_add_vid(lowerdev, vid);\n}\n\nstatic void macvlan_vlan_rx_kill_vid(struct net_device *dev,\n\t\t\t\t     unsigned short vid)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tstruct net_device *lowerdev = vlan->lowerdev;\n\tconst struct net_device_ops *ops = lowerdev->netdev_ops;\n\n\tif (ops->ndo_vlan_rx_kill_vid)\n\t\tops->ndo_vlan_rx_kill_vid(lowerdev, vid);\n}\n\nstatic void macvlan_ethtool_get_drvinfo(struct net_device *dev,\n\t\t\t\t\tstruct ethtool_drvinfo *drvinfo)\n{\n\tsnprintf(drvinfo->driver, 32, \"macvlan\");\n\tsnprintf(drvinfo->version, 32, \"0.1\");\n}\n\nstatic int macvlan_ethtool_get_settings(struct net_device *dev,\n\t\t\t\t\tstruct ethtool_cmd *cmd)\n{\n\tconst struct macvlan_dev *vlan = netdev_priv(dev);\n\treturn dev_ethtool_get_settings(vlan->lowerdev, cmd);\n}\n\nstatic const struct ethtool_ops macvlan_ethtool_ops = {\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_settings\t\t= macvlan_ethtool_get_settings,\n\t.get_drvinfo\t\t= macvlan_ethtool_get_drvinfo,\n};\n\nstatic const struct net_device_ops macvlan_netdev_ops = {\n\t.ndo_init\t\t= macvlan_init,\n\t.ndo_uninit\t\t= macvlan_uninit,\n\t.ndo_open\t\t= macvlan_open,\n\t.ndo_stop\t\t= macvlan_stop,\n\t.ndo_start_xmit\t\t= macvlan_start_xmit,\n\t.ndo_change_mtu\t\t= macvlan_change_mtu,\n\t.ndo_change_rx_flags\t= macvlan_change_rx_flags,\n\t.ndo_set_mac_address\t= macvlan_set_mac_address,\n\t.ndo_set_multicast_list\t= macvlan_set_multicast_list,\n\t.ndo_get_stats64\t= macvlan_dev_get_stats64,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_vlan_rx_add_vid\t= macvlan_vlan_rx_add_vid,\n\t.ndo_vlan_rx_kill_vid\t= macvlan_vlan_rx_kill_vid,\n};\n\nvoid macvlan_common_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\n\tdev->priv_flags\t       &= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);\n\tdev->netdev_ops\t\t= &macvlan_netdev_ops;\n\tdev->destructor\t\t= free_netdev;\n\tdev->header_ops\t\t= &macvlan_hard_header_ops,\n\tdev->ethtool_ops\t= &macvlan_ethtool_ops;\n}\nEXPORT_SYMBOL_GPL(macvlan_common_setup);\n\nstatic void macvlan_setup(struct net_device *dev)\n{\n\tmacvlan_common_setup(dev);\n\tdev->tx_queue_len\t= 0;\n}\n\nstatic int macvlan_port_create(struct net_device *dev)\n{\n\tstruct macvlan_port *port;\n\tunsigned int i;\n\tint err;\n\n\tif (dev->type != ARPHRD_ETHER || dev->flags & IFF_LOOPBACK)\n\t\treturn -EINVAL;\n\n\tport = kzalloc(sizeof(*port), GFP_KERNEL);\n\tif (port == NULL)\n\t\treturn -ENOMEM;\n\n\tport->passthru = false;\n\tport->dev = dev;\n\tINIT_LIST_HEAD(&port->vlans);\n\tfor (i = 0; i < MACVLAN_HASH_SIZE; i++)\n\t\tINIT_HLIST_HEAD(&port->vlan_hash[i]);\n\n\terr = netdev_rx_handler_register(dev, macvlan_handle_frame, port);\n\tif (err)\n\t\tkfree(port);\n\telse\n\t\tdev->priv_flags |= IFF_MACVLAN_PORT;\n\treturn err;\n}\n\nstatic void macvlan_port_destroy(struct net_device *dev)\n{\n\tstruct macvlan_port *port = macvlan_port_get(dev);\n\n\tdev->priv_flags &= ~IFF_MACVLAN_PORT;\n\tnetdev_rx_handler_unregister(dev);\n\tkfree_rcu(port, rcu);\n}\n\nstatic int macvlan_validate(struct nlattr *tb[], struct nlattr *data[])\n{\n\tif (tb[IFLA_ADDRESS]) {\n\t\tif (nla_len(tb[IFLA_ADDRESS]) != ETH_ALEN)\n\t\t\treturn -EINVAL;\n\t\tif (!is_valid_ether_addr(nla_data(tb[IFLA_ADDRESS])))\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\n\tif (data && data[IFLA_MACVLAN_MODE]) {\n\t\tswitch (nla_get_u32(data[IFLA_MACVLAN_MODE])) {\n\t\tcase MACVLAN_MODE_PRIVATE:\n\t\tcase MACVLAN_MODE_VEPA:\n\t\tcase MACVLAN_MODE_BRIDGE:\n\t\tcase MACVLAN_MODE_PASSTHRU:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint macvlan_common_newlink(struct net *src_net, struct net_device *dev,\n\t\t\t   struct nlattr *tb[], struct nlattr *data[],\n\t\t\t   int (*receive)(struct sk_buff *skb),\n\t\t\t   int (*forward)(struct net_device *dev,\n\t\t\t\t\t  struct sk_buff *skb))\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tstruct macvlan_port *port;\n\tstruct net_device *lowerdev;\n\tint err;\n\n\tif (!tb[IFLA_LINK])\n\t\treturn -EINVAL;\n\n\tlowerdev = __dev_get_by_index(src_net, nla_get_u32(tb[IFLA_LINK]));\n\tif (lowerdev == NULL)\n\t\treturn -ENODEV;\n\n\t/* When creating macvlans on top of other macvlans - use\n\t * the real device as the lowerdev.\n\t */\n\tif (lowerdev->rtnl_link_ops == dev->rtnl_link_ops) {\n\t\tstruct macvlan_dev *lowervlan = netdev_priv(lowerdev);\n\t\tlowerdev = lowervlan->lowerdev;\n\t}\n\n\tif (!tb[IFLA_MTU])\n\t\tdev->mtu = lowerdev->mtu;\n\telse if (dev->mtu > lowerdev->mtu)\n\t\treturn -EINVAL;\n\n\tif (!tb[IFLA_ADDRESS])\n\t\trandom_ether_addr(dev->dev_addr);\n\n\tif (!macvlan_port_exists(lowerdev)) {\n\t\terr = macvlan_port_create(lowerdev);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\tport = macvlan_port_get(lowerdev);\n\n\t/* Only 1 macvlan device can be created in passthru mode */\n\tif (port->passthru)\n\t\treturn -EINVAL;\n\n\tvlan->lowerdev = lowerdev;\n\tvlan->dev      = dev;\n\tvlan->port     = port;\n\tvlan->receive  = receive;\n\tvlan->forward  = forward;\n\n\tvlan->mode     = MACVLAN_MODE_VEPA;\n\tif (data && data[IFLA_MACVLAN_MODE])\n\t\tvlan->mode = nla_get_u32(data[IFLA_MACVLAN_MODE]);\n\n\tif (vlan->mode == MACVLAN_MODE_PASSTHRU) {\n\t\tif (port->count)\n\t\t\treturn -EINVAL;\n\t\tport->passthru = true;\n\t\tmemcpy(dev->dev_addr, lowerdev->dev_addr, ETH_ALEN);\n\t}\n\n\tport->count += 1;\n\terr = register_netdevice(dev);\n\tif (err < 0)\n\t\tgoto destroy_port;\n\n\tlist_add_tail(&vlan->list, &port->vlans);\n\tnetif_stacked_transfer_operstate(lowerdev, dev);\n\n\treturn 0;\n\ndestroy_port:\n\tport->count -= 1;\n\tif (!port->count)\n\t\tmacvlan_port_destroy(lowerdev);\n\n\treturn err;\n}\nEXPORT_SYMBOL_GPL(macvlan_common_newlink);\n\nstatic int macvlan_newlink(struct net *src_net, struct net_device *dev,\n\t\t\t   struct nlattr *tb[], struct nlattr *data[])\n{\n\treturn macvlan_common_newlink(src_net, dev, tb, data,\n\t\t\t\t      netif_rx,\n\t\t\t\t      dev_forward_skb);\n}\n\nvoid macvlan_dellink(struct net_device *dev, struct list_head *head)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\n\tlist_del(&vlan->list);\n\tunregister_netdevice_queue(dev, head);\n}\nEXPORT_SYMBOL_GPL(macvlan_dellink);\n\nstatic int macvlan_changelink(struct net_device *dev,\n\t\tstruct nlattr *tb[], struct nlattr *data[])\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\tif (data && data[IFLA_MACVLAN_MODE])\n\t\tvlan->mode = nla_get_u32(data[IFLA_MACVLAN_MODE]);\n\treturn 0;\n}\n\nstatic size_t macvlan_get_size(const struct net_device *dev)\n{\n\treturn nla_total_size(4);\n}\n\nstatic int macvlan_fill_info(struct sk_buff *skb,\n\t\t\t\tconst struct net_device *dev)\n{\n\tstruct macvlan_dev *vlan = netdev_priv(dev);\n\n\tNLA_PUT_U32(skb, IFLA_MACVLAN_MODE, vlan->mode);\n\treturn 0;\n\nnla_put_failure:\n\treturn -EMSGSIZE;\n}\n\nstatic const struct nla_policy macvlan_policy[IFLA_MACVLAN_MAX + 1] = {\n\t[IFLA_MACVLAN_MODE] = { .type = NLA_U32 },\n};\n\nint macvlan_link_register(struct rtnl_link_ops *ops)\n{\n\t/* common fields */\n\tops->priv_size\t\t= sizeof(struct macvlan_dev);\n\tops->validate\t\t= macvlan_validate;\n\tops->maxtype\t\t= IFLA_MACVLAN_MAX;\n\tops->policy\t\t= macvlan_policy;\n\tops->changelink\t\t= macvlan_changelink;\n\tops->get_size\t\t= macvlan_get_size;\n\tops->fill_info\t\t= macvlan_fill_info;\n\n\treturn rtnl_link_register(ops);\n};\nEXPORT_SYMBOL_GPL(macvlan_link_register);\n\nstatic struct rtnl_link_ops macvlan_link_ops = {\n\t.kind\t\t= \"macvlan\",\n\t.setup\t\t= macvlan_setup,\n\t.newlink\t= macvlan_newlink,\n\t.dellink\t= macvlan_dellink,\n};\n\nstatic int macvlan_device_event(struct notifier_block *unused,\n\t\t\t\tunsigned long event, void *ptr)\n{\n\tstruct net_device *dev = ptr;\n\tstruct macvlan_dev *vlan, *next;\n\tstruct macvlan_port *port;\n\tLIST_HEAD(list_kill);\n\n\tif (!macvlan_port_exists(dev))\n\t\treturn NOTIFY_DONE;\n\n\tport = macvlan_port_get(dev);\n\n\tswitch (event) {\n\tcase NETDEV_CHANGE:\n\t\tlist_for_each_entry(vlan, &port->vlans, list)\n\t\t\tnetif_stacked_transfer_operstate(vlan->lowerdev,\n\t\t\t\t\t\t\t vlan->dev);\n\t\tbreak;\n\tcase NETDEV_FEAT_CHANGE:\n\t\tlist_for_each_entry(vlan, &port->vlans, list) {\n\t\t\tvlan->dev->features = dev->features & MACVLAN_FEATURES;\n\t\t\tvlan->dev->gso_max_size = dev->gso_max_size;\n\t\t\tnetdev_features_change(vlan->dev);\n\t\t}\n\t\tbreak;\n\tcase NETDEV_UNREGISTER:\n\t\t/* twiddle thumbs on netns device moves */\n\t\tif (dev->reg_state != NETREG_UNREGISTERING)\n\t\t\tbreak;\n\n\t\tlist_for_each_entry_safe(vlan, next, &port->vlans, list)\n\t\t\tvlan->dev->rtnl_link_ops->dellink(vlan->dev, &list_kill);\n\t\tunregister_netdevice_many(&list_kill);\n\t\tlist_del(&list_kill);\n\t\tbreak;\n\tcase NETDEV_PRE_TYPE_CHANGE:\n\t\t/* Forbid underlaying device to change its type. */\n\t\treturn NOTIFY_BAD;\n\t}\n\treturn NOTIFY_DONE;\n}\n\nstatic struct notifier_block macvlan_notifier_block __read_mostly = {\n\t.notifier_call\t= macvlan_device_event,\n};\n\nstatic int __init macvlan_init_module(void)\n{\n\tint err;\n\n\tregister_netdevice_notifier(&macvlan_notifier_block);\n\n\terr = macvlan_link_register(&macvlan_link_ops);\n\tif (err < 0)\n\t\tgoto err1;\n\treturn 0;\nerr1:\n\tunregister_netdevice_notifier(&macvlan_notifier_block);\n\treturn err;\n}\n\nstatic void __exit macvlan_cleanup_module(void)\n{\n\trtnl_link_unregister(&macvlan_link_ops);\n\tunregister_netdevice_notifier(&macvlan_notifier_block);\n}\n\nmodule_init(macvlan_init_module);\nmodule_exit(macvlan_cleanup_module);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Patrick McHardy <kaber@trash.net>\");\nMODULE_DESCRIPTION(\"Driver for MAC address based VLANs\");\nMODULE_ALIAS_RTNL_LINK(\"macvlan\");\n", "/*\n *  TUN - Universal TUN/TAP device driver.\n *  Copyright (C) 1999-2002 Maxim Krasnyansky <maxk@qualcomm.com>\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n *  GNU General Public License for more details.\n *\n *  $Id: tun.c,v 1.15 2002/03/01 02:44:24 maxk Exp $\n */\n\n/*\n *  Changes:\n *\n *  Mike Kershaw <dragorn@kismetwireless.net> 2005/08/14\n *    Add TUNSETLINK ioctl to set the link encapsulation\n *\n *  Mark Smith <markzzzsmith@yahoo.com.au>\n *    Use random_ether_addr() for tap MAC address.\n *\n *  Harald Roelle <harald.roelle@ifi.lmu.de>  2004/04/20\n *    Fixes in packet dropping, queue length setting and queue wakeup.\n *    Increased default tx queue length.\n *    Added ethtool API.\n *    Minor cleanups\n *\n *  Daniel Podlejski <underley@underley.eu.org>\n *    Modifications for 2.3.99-pre5 kernel.\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#define DRV_NAME\t\"tun\"\n#define DRV_VERSION\t\"1.6\"\n#define DRV_DESCRIPTION\t\"Universal TUN/TAP device driver\"\n#define DRV_COPYRIGHT\t\"(C) 1999-2004 Max Krasnyansky <maxk@qualcomm.com>\"\n\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/kernel.h>\n#include <linux/major.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/fcntl.h>\n#include <linux/init.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/miscdevice.h>\n#include <linux/ethtool.h>\n#include <linux/rtnetlink.h>\n#include <linux/compat.h>\n#include <linux/if.h>\n#include <linux/if_arp.h>\n#include <linux/if_ether.h>\n#include <linux/if_tun.h>\n#include <linux/crc32.h>\n#include <linux/nsproxy.h>\n#include <linux/virtio_net.h>\n#include <linux/rcupdate.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n#include <net/rtnetlink.h>\n#include <net/sock.h>\n\n#include <asm/system.h>\n#include <asm/uaccess.h>\n\n/* Uncomment to enable debugging */\n/* #define TUN_DEBUG 1 */\n\n#ifdef TUN_DEBUG\nstatic int debug;\n\n#define tun_debug(level, tun, fmt, args...)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (tun->debug)\t\t\t\t\t\t\\\n\t\tnetdev_printk(level, tun->dev, fmt, ##args);\t\\\n} while (0)\n#define DBG1(level, fmt, args...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (debug == 2)\t\t\t\t\t\t\\\n\t\tprintk(level fmt, ##args);\t\t\t\\\n} while (0)\n#else\n#define tun_debug(level, tun, fmt, args...)\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (0)\t\t\t\t\t\t\t\\\n\t\tnetdev_printk(level, tun->dev, fmt, ##args);\t\\\n} while (0)\n#define DBG1(level, fmt, args...)\t\t\t\t\\\ndo {\t\t\t\t\t\t\t\t\\\n\tif (0)\t\t\t\t\t\t\t\\\n\t\tprintk(level fmt, ##args);\t\t\t\\\n} while (0)\n#endif\n\n#define FLT_EXACT_COUNT 8\nstruct tap_filter {\n\tunsigned int    count;    /* Number of addrs. Zero means disabled */\n\tu32             mask[2];  /* Mask of the hashed addrs */\n\tunsigned char\taddr[FLT_EXACT_COUNT][ETH_ALEN];\n};\n\nstruct tun_file {\n\tatomic_t count;\n\tstruct tun_struct *tun;\n\tstruct net *net;\n};\n\nstruct tun_sock;\n\nstruct tun_struct {\n\tstruct tun_file\t\t*tfile;\n\tunsigned int \t\tflags;\n\tuid_t\t\t\towner;\n\tgid_t\t\t\tgroup;\n\n\tstruct net_device\t*dev;\n\tu32\t\t\tset_features;\n#define TUN_USER_FEATURES (NETIF_F_HW_CSUM|NETIF_F_TSO_ECN|NETIF_F_TSO| \\\n\t\t\t  NETIF_F_TSO6|NETIF_F_UFO)\n\tstruct fasync_struct\t*fasync;\n\n\tstruct tap_filter       txflt;\n\tstruct socket\t\tsocket;\n\tstruct socket_wq\twq;\n\n\tint\t\t\tvnet_hdr_sz;\n\n#ifdef TUN_DEBUG\n\tint debug;\n#endif\n};\n\nstruct tun_sock {\n\tstruct sock\t\tsk;\n\tstruct tun_struct\t*tun;\n};\n\nstatic inline struct tun_sock *tun_sk(struct sock *sk)\n{\n\treturn container_of(sk, struct tun_sock, sk);\n}\n\nstatic int tun_attach(struct tun_struct *tun, struct file *file)\n{\n\tstruct tun_file *tfile = file->private_data;\n\tint err;\n\n\tASSERT_RTNL();\n\n\tnetif_tx_lock_bh(tun->dev);\n\n\terr = -EINVAL;\n\tif (tfile->tun)\n\t\tgoto out;\n\n\terr = -EBUSY;\n\tif (tun->tfile)\n\t\tgoto out;\n\n\terr = 0;\n\ttfile->tun = tun;\n\ttun->tfile = tfile;\n\ttun->socket.file = file;\n\tnetif_carrier_on(tun->dev);\n\tdev_hold(tun->dev);\n\tsock_hold(tun->socket.sk);\n\tatomic_inc(&tfile->count);\n\nout:\n\tnetif_tx_unlock_bh(tun->dev);\n\treturn err;\n}\n\nstatic void __tun_detach(struct tun_struct *tun)\n{\n\t/* Detach from net device */\n\tnetif_tx_lock_bh(tun->dev);\n\tnetif_carrier_off(tun->dev);\n\ttun->tfile = NULL;\n\ttun->socket.file = NULL;\n\tnetif_tx_unlock_bh(tun->dev);\n\n\t/* Drop read queue */\n\tskb_queue_purge(&tun->socket.sk->sk_receive_queue);\n\n\t/* Drop the extra count on the net device */\n\tdev_put(tun->dev);\n}\n\nstatic void tun_detach(struct tun_struct *tun)\n{\n\trtnl_lock();\n\t__tun_detach(tun);\n\trtnl_unlock();\n}\n\nstatic struct tun_struct *__tun_get(struct tun_file *tfile)\n{\n\tstruct tun_struct *tun = NULL;\n\n\tif (atomic_inc_not_zero(&tfile->count))\n\t\ttun = tfile->tun;\n\n\treturn tun;\n}\n\nstatic struct tun_struct *tun_get(struct file *file)\n{\n\treturn __tun_get(file->private_data);\n}\n\nstatic void tun_put(struct tun_struct *tun)\n{\n\tstruct tun_file *tfile = tun->tfile;\n\n\tif (atomic_dec_and_test(&tfile->count))\n\t\ttun_detach(tfile->tun);\n}\n\n/* TAP filtering */\nstatic void addr_hash_set(u32 *mask, const u8 *addr)\n{\n\tint n = ether_crc(ETH_ALEN, addr) >> 26;\n\tmask[n >> 5] |= (1 << (n & 31));\n}\n\nstatic unsigned int addr_hash_test(const u32 *mask, const u8 *addr)\n{\n\tint n = ether_crc(ETH_ALEN, addr) >> 26;\n\treturn mask[n >> 5] & (1 << (n & 31));\n}\n\nstatic int update_filter(struct tap_filter *filter, void __user *arg)\n{\n\tstruct { u8 u[ETH_ALEN]; } *addr;\n\tstruct tun_filter uf;\n\tint err, alen, n, nexact;\n\n\tif (copy_from_user(&uf, arg, sizeof(uf)))\n\t\treturn -EFAULT;\n\n\tif (!uf.count) {\n\t\t/* Disabled */\n\t\tfilter->count = 0;\n\t\treturn 0;\n\t}\n\n\talen = ETH_ALEN * uf.count;\n\taddr = kmalloc(alen, GFP_KERNEL);\n\tif (!addr)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(addr, arg + sizeof(uf), alen)) {\n\t\terr = -EFAULT;\n\t\tgoto done;\n\t}\n\n\t/* The filter is updated without holding any locks. Which is\n\t * perfectly safe. We disable it first and in the worst\n\t * case we'll accept a few undesired packets. */\n\tfilter->count = 0;\n\twmb();\n\n\t/* Use first set of addresses as an exact filter */\n\tfor (n = 0; n < uf.count && n < FLT_EXACT_COUNT; n++)\n\t\tmemcpy(filter->addr[n], addr[n].u, ETH_ALEN);\n\n\tnexact = n;\n\n\t/* Remaining multicast addresses are hashed,\n\t * unicast will leave the filter disabled. */\n\tmemset(filter->mask, 0, sizeof(filter->mask));\n\tfor (; n < uf.count; n++) {\n\t\tif (!is_multicast_ether_addr(addr[n].u)) {\n\t\t\terr = 0; /* no filter */\n\t\t\tgoto done;\n\t\t}\n\t\taddr_hash_set(filter->mask, addr[n].u);\n\t}\n\n\t/* For ALLMULTI just set the mask to all ones.\n\t * This overrides the mask populated above. */\n\tif ((uf.flags & TUN_FLT_ALLMULTI))\n\t\tmemset(filter->mask, ~0, sizeof(filter->mask));\n\n\t/* Now enable the filter */\n\twmb();\n\tfilter->count = nexact;\n\n\t/* Return the number of exact filters */\n\terr = nexact;\n\ndone:\n\tkfree(addr);\n\treturn err;\n}\n\n/* Returns: 0 - drop, !=0 - accept */\nstatic int run_filter(struct tap_filter *filter, const struct sk_buff *skb)\n{\n\t/* Cannot use eth_hdr(skb) here because skb_mac_hdr() is incorrect\n\t * at this point. */\n\tstruct ethhdr *eh = (struct ethhdr *) skb->data;\n\tint i;\n\n\t/* Exact match */\n\tfor (i = 0; i < filter->count; i++)\n\t\tif (!compare_ether_addr(eh->h_dest, filter->addr[i]))\n\t\t\treturn 1;\n\n\t/* Inexact match (multicast only) */\n\tif (is_multicast_ether_addr(eh->h_dest))\n\t\treturn addr_hash_test(filter->mask, eh->h_dest);\n\n\treturn 0;\n}\n\n/*\n * Checks whether the packet is accepted or not.\n * Returns: 0 - drop, !=0 - accept\n */\nstatic int check_filter(struct tap_filter *filter, const struct sk_buff *skb)\n{\n\tif (!filter->count)\n\t\treturn 1;\n\n\treturn run_filter(filter, skb);\n}\n\n/* Network device part of the driver */\n\nstatic const struct ethtool_ops tun_ethtool_ops;\n\n/* Net device detach from fd. */\nstatic void tun_net_uninit(struct net_device *dev)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\tstruct tun_file *tfile = tun->tfile;\n\n\t/* Inform the methods they need to stop using the dev.\n\t */\n\tif (tfile) {\n\t\twake_up_all(&tun->wq.wait);\n\t\tif (atomic_dec_and_test(&tfile->count))\n\t\t\t__tun_detach(tun);\n\t}\n}\n\nstatic void tun_free_netdev(struct net_device *dev)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\n\tsock_put(tun->socket.sk);\n}\n\n/* Net device open. */\nstatic int tun_net_open(struct net_device *dev)\n{\n\tnetif_start_queue(dev);\n\treturn 0;\n}\n\n/* Net device close. */\nstatic int tun_net_close(struct net_device *dev)\n{\n\tnetif_stop_queue(dev);\n\treturn 0;\n}\n\n/* Net device start xmit */\nstatic netdev_tx_t tun_net_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\n\ttun_debug(KERN_INFO, tun, \"tun_net_xmit %d\\n\", skb->len);\n\n\t/* Drop packet if interface is not attached */\n\tif (!tun->tfile)\n\t\tgoto drop;\n\n\t/* Drop if the filter does not like it.\n\t * This is a noop if the filter is disabled.\n\t * Filter can be enabled only for the TAP devices. */\n\tif (!check_filter(&tun->txflt, skb))\n\t\tgoto drop;\n\n\tif (tun->socket.sk->sk_filter &&\n\t    sk_filter(tun->socket.sk, skb))\n\t\tgoto drop;\n\n\tif (skb_queue_len(&tun->socket.sk->sk_receive_queue) >= dev->tx_queue_len) {\n\t\tif (!(tun->flags & TUN_ONE_QUEUE)) {\n\t\t\t/* Normal queueing mode. */\n\t\t\t/* Packet scheduler handles dropping of further packets. */\n\t\t\tnetif_stop_queue(dev);\n\n\t\t\t/* We won't see all dropped packets individually, so overrun\n\t\t\t * error is more appropriate. */\n\t\t\tdev->stats.tx_fifo_errors++;\n\t\t} else {\n\t\t\t/* Single queue mode.\n\t\t\t * Driver handles dropping of all packets itself. */\n\t\t\tgoto drop;\n\t\t}\n\t}\n\n\t/* Orphan the skb - required as we might hang on to it\n\t * for indefinite time. */\n\tskb_orphan(skb);\n\n\t/* Enqueue packet */\n\tskb_queue_tail(&tun->socket.sk->sk_receive_queue, skb);\n\n\t/* Notify and wake up reader process */\n\tif (tun->flags & TUN_FASYNC)\n\t\tkill_fasync(&tun->fasync, SIGIO, POLL_IN);\n\twake_up_interruptible_poll(&tun->wq.wait, POLLIN |\n\t\t\t\t   POLLRDNORM | POLLRDBAND);\n\treturn NETDEV_TX_OK;\n\ndrop:\n\tdev->stats.tx_dropped++;\n\tkfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic void tun_net_mclist(struct net_device *dev)\n{\n\t/*\n\t * This callback is supposed to deal with mc filter in\n\t * _rx_ path and has nothing to do with the _tx_ path.\n\t * In rx path we always accept everything userspace gives us.\n\t */\n}\n\n#define MIN_MTU 68\n#define MAX_MTU 65535\n\nstatic int\ntun_net_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tif (new_mtu < MIN_MTU || new_mtu + dev->hard_header_len > MAX_MTU)\n\t\treturn -EINVAL;\n\tdev->mtu = new_mtu;\n\treturn 0;\n}\n\nstatic u32 tun_net_fix_features(struct net_device *dev, u32 features)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\n\treturn (features & tun->set_features) | (features & ~TUN_USER_FEATURES);\n}\n#ifdef CONFIG_NET_POLL_CONTROLLER\nstatic void tun_poll_controller(struct net_device *dev)\n{\n\t/*\n\t * Tun only receives frames when:\n\t * 1) the char device endpoint gets data from user space\n\t * 2) the tun socket gets a sendmsg call from user space\n\t * Since both of those are syncronous operations, we are guaranteed\n\t * never to have pending data when we poll for it\n\t * so theres nothing to do here but return.\n\t * We need this though so netpoll recognizes us as an interface that\n\t * supports polling, which enables bridge devices in virt setups to\n\t * still use netconsole\n\t */\n\treturn;\n}\n#endif\nstatic const struct net_device_ops tun_netdev_ops = {\n\t.ndo_uninit\t\t= tun_net_uninit,\n\t.ndo_open\t\t= tun_net_open,\n\t.ndo_stop\t\t= tun_net_close,\n\t.ndo_start_xmit\t\t= tun_net_xmit,\n\t.ndo_change_mtu\t\t= tun_net_change_mtu,\n\t.ndo_fix_features\t= tun_net_fix_features,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= tun_poll_controller,\n#endif\n};\n\nstatic const struct net_device_ops tap_netdev_ops = {\n\t.ndo_uninit\t\t= tun_net_uninit,\n\t.ndo_open\t\t= tun_net_open,\n\t.ndo_stop\t\t= tun_net_close,\n\t.ndo_start_xmit\t\t= tun_net_xmit,\n\t.ndo_change_mtu\t\t= tun_net_change_mtu,\n\t.ndo_fix_features\t= tun_net_fix_features,\n\t.ndo_set_multicast_list\t= tun_net_mclist,\n\t.ndo_set_mac_address\t= eth_mac_addr,\n\t.ndo_validate_addr\t= eth_validate_addr,\n#ifdef CONFIG_NET_POLL_CONTROLLER\n\t.ndo_poll_controller\t= tun_poll_controller,\n#endif\n};\n\n/* Initialize net device. */\nstatic void tun_net_init(struct net_device *dev)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\n\tswitch (tun->flags & TUN_TYPE_MASK) {\n\tcase TUN_TUN_DEV:\n\t\tdev->netdev_ops = &tun_netdev_ops;\n\n\t\t/* Point-to-Point TUN Device */\n\t\tdev->hard_header_len = 0;\n\t\tdev->addr_len = 0;\n\t\tdev->mtu = 1500;\n\n\t\t/* Zero header length */\n\t\tdev->type = ARPHRD_NONE;\n\t\tdev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;\n\t\tdev->tx_queue_len = TUN_READQ_SIZE;  /* We prefer our own queue length */\n\t\tbreak;\n\n\tcase TUN_TAP_DEV:\n\t\tdev->netdev_ops = &tap_netdev_ops;\n\t\t/* Ethernet TAP Device */\n\t\tether_setup(dev);\n\t\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\n\t\trandom_ether_addr(dev->dev_addr);\n\n\t\tdev->tx_queue_len = TUN_READQ_SIZE;  /* We prefer our own queue length */\n\t\tbreak;\n\t}\n}\n\n/* Character device part */\n\n/* Poll */\nstatic unsigned int tun_chr_poll(struct file *file, poll_table * wait)\n{\n\tstruct tun_file *tfile = file->private_data;\n\tstruct tun_struct *tun = __tun_get(tfile);\n\tstruct sock *sk;\n\tunsigned int mask = 0;\n\n\tif (!tun)\n\t\treturn POLLERR;\n\n\tsk = tun->socket.sk;\n\n\ttun_debug(KERN_INFO, tun, \"tun_chr_poll\\n\");\n\n\tpoll_wait(file, &tun->wq.wait, wait);\n\n\tif (!skb_queue_empty(&sk->sk_receive_queue))\n\t\tmask |= POLLIN | POLLRDNORM;\n\n\tif (sock_writeable(sk) ||\n\t    (!test_and_set_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags) &&\n\t     sock_writeable(sk)))\n\t\tmask |= POLLOUT | POLLWRNORM;\n\n\tif (tun->dev->reg_state != NETREG_REGISTERED)\n\t\tmask = POLLERR;\n\n\ttun_put(tun);\n\treturn mask;\n}\n\n/* prepad is the amount to reserve at front.  len is length after that.\n * linear is a hint as to how much to copy (usually headers). */\nstatic struct sk_buff *tun_alloc_skb(struct tun_struct *tun,\n\t\t\t\t     size_t prepad, size_t len,\n\t\t\t\t     size_t linear, int noblock)\n{\n\tstruct sock *sk = tun->socket.sk;\n\tstruct sk_buff *skb;\n\tint err;\n\n\tsock_update_classid(sk);\n\n\t/* Under a page?  Don't bother with paged skb. */\n\tif (prepad + len < PAGE_SIZE || !linear)\n\t\tlinear = len;\n\n\tskb = sock_alloc_send_pskb(sk, prepad + linear, len - linear, noblock,\n\t\t\t\t   &err);\n\tif (!skb)\n\t\treturn ERR_PTR(err);\n\n\tskb_reserve(skb, prepad);\n\tskb_put(skb, linear);\n\tskb->data_len = len - linear;\n\tskb->len += len - linear;\n\n\treturn skb;\n}\n\n/* Get packet from user space buffer */\nstatic ssize_t tun_get_user(struct tun_struct *tun,\n\t\t\t    const struct iovec *iv, size_t count,\n\t\t\t    int noblock)\n{\n\tstruct tun_pi pi = { 0, cpu_to_be16(ETH_P_IP) };\n\tstruct sk_buff *skb;\n\tsize_t len = count, align = NET_SKB_PAD;\n\tstruct virtio_net_hdr gso = { 0 };\n\tint offset = 0;\n\n\tif (!(tun->flags & TUN_NO_PI)) {\n\t\tif ((len -= sizeof(pi)) > count)\n\t\t\treturn -EINVAL;\n\n\t\tif (memcpy_fromiovecend((void *)&pi, iv, 0, sizeof(pi)))\n\t\t\treturn -EFAULT;\n\t\toffset += sizeof(pi);\n\t}\n\n\tif (tun->flags & TUN_VNET_HDR) {\n\t\tif ((len -= tun->vnet_hdr_sz) > count)\n\t\t\treturn -EINVAL;\n\n\t\tif (memcpy_fromiovecend((void *)&gso, iv, offset, sizeof(gso)))\n\t\t\treturn -EFAULT;\n\n\t\tif ((gso.flags & VIRTIO_NET_HDR_F_NEEDS_CSUM) &&\n\t\t    gso.csum_start + gso.csum_offset + 2 > gso.hdr_len)\n\t\t\tgso.hdr_len = gso.csum_start + gso.csum_offset + 2;\n\n\t\tif (gso.hdr_len > len)\n\t\t\treturn -EINVAL;\n\t\toffset += tun->vnet_hdr_sz;\n\t}\n\n\tif ((tun->flags & TUN_TYPE_MASK) == TUN_TAP_DEV) {\n\t\talign += NET_IP_ALIGN;\n\t\tif (unlikely(len < ETH_HLEN ||\n\t\t\t     (gso.hdr_len && gso.hdr_len < ETH_HLEN)))\n\t\t\treturn -EINVAL;\n\t}\n\n\tskb = tun_alloc_skb(tun, align, len, gso.hdr_len, noblock);\n\tif (IS_ERR(skb)) {\n\t\tif (PTR_ERR(skb) != -EAGAIN)\n\t\t\ttun->dev->stats.rx_dropped++;\n\t\treturn PTR_ERR(skb);\n\t}\n\n\tif (skb_copy_datagram_from_iovec(skb, 0, iv, offset, len)) {\n\t\ttun->dev->stats.rx_dropped++;\n\t\tkfree_skb(skb);\n\t\treturn -EFAULT;\n\t}\n\n\tif (gso.flags & VIRTIO_NET_HDR_F_NEEDS_CSUM) {\n\t\tif (!skb_partial_csum_set(skb, gso.csum_start,\n\t\t\t\t\t  gso.csum_offset)) {\n\t\t\ttun->dev->stats.rx_frame_errors++;\n\t\t\tkfree_skb(skb);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tswitch (tun->flags & TUN_TYPE_MASK) {\n\tcase TUN_TUN_DEV:\n\t\tif (tun->flags & TUN_NO_PI) {\n\t\t\tswitch (skb->data[0] & 0xf0) {\n\t\t\tcase 0x40:\n\t\t\t\tpi.proto = htons(ETH_P_IP);\n\t\t\t\tbreak;\n\t\t\tcase 0x60:\n\t\t\t\tpi.proto = htons(ETH_P_IPV6);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ttun->dev->stats.rx_dropped++;\n\t\t\t\tkfree_skb(skb);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tskb_reset_mac_header(skb);\n\t\tskb->protocol = pi.proto;\n\t\tskb->dev = tun->dev;\n\t\tbreak;\n\tcase TUN_TAP_DEV:\n\t\tskb->protocol = eth_type_trans(skb, tun->dev);\n\t\tbreak;\n\t}\n\n\tif (gso.gso_type != VIRTIO_NET_HDR_GSO_NONE) {\n\t\tpr_debug(\"GSO!\\n\");\n\t\tswitch (gso.gso_type & ~VIRTIO_NET_HDR_GSO_ECN) {\n\t\tcase VIRTIO_NET_HDR_GSO_TCPV4:\n\t\t\tskb_shinfo(skb)->gso_type = SKB_GSO_TCPV4;\n\t\t\tbreak;\n\t\tcase VIRTIO_NET_HDR_GSO_TCPV6:\n\t\t\tskb_shinfo(skb)->gso_type = SKB_GSO_TCPV6;\n\t\t\tbreak;\n\t\tcase VIRTIO_NET_HDR_GSO_UDP:\n\t\t\tskb_shinfo(skb)->gso_type = SKB_GSO_UDP;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttun->dev->stats.rx_frame_errors++;\n\t\t\tkfree_skb(skb);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (gso.gso_type & VIRTIO_NET_HDR_GSO_ECN)\n\t\t\tskb_shinfo(skb)->gso_type |= SKB_GSO_TCP_ECN;\n\n\t\tskb_shinfo(skb)->gso_size = gso.gso_size;\n\t\tif (skb_shinfo(skb)->gso_size == 0) {\n\t\t\ttun->dev->stats.rx_frame_errors++;\n\t\t\tkfree_skb(skb);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Header must be checked, and gso_segs computed. */\n\t\tskb_shinfo(skb)->gso_type |= SKB_GSO_DODGY;\n\t\tskb_shinfo(skb)->gso_segs = 0;\n\t}\n\n\tnetif_rx_ni(skb);\n\n\ttun->dev->stats.rx_packets++;\n\ttun->dev->stats.rx_bytes += len;\n\n\treturn count;\n}\n\nstatic ssize_t tun_chr_aio_write(struct kiocb *iocb, const struct iovec *iv,\n\t\t\t      unsigned long count, loff_t pos)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct tun_struct *tun = tun_get(file);\n\tssize_t result;\n\n\tif (!tun)\n\t\treturn -EBADFD;\n\n\ttun_debug(KERN_INFO, tun, \"tun_chr_write %ld\\n\", count);\n\n\tresult = tun_get_user(tun, iv, iov_length(iv, count),\n\t\t\t      file->f_flags & O_NONBLOCK);\n\n\ttun_put(tun);\n\treturn result;\n}\n\n/* Put packet to the user space buffer */\nstatic ssize_t tun_put_user(struct tun_struct *tun,\n\t\t\t    struct sk_buff *skb,\n\t\t\t    const struct iovec *iv, int len)\n{\n\tstruct tun_pi pi = { 0, skb->protocol };\n\tssize_t total = 0;\n\n\tif (!(tun->flags & TUN_NO_PI)) {\n\t\tif ((len -= sizeof(pi)) < 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (len < skb->len) {\n\t\t\t/* Packet will be striped */\n\t\t\tpi.flags |= TUN_PKT_STRIP;\n\t\t}\n\n\t\tif (memcpy_toiovecend(iv, (void *) &pi, 0, sizeof(pi)))\n\t\t\treturn -EFAULT;\n\t\ttotal += sizeof(pi);\n\t}\n\n\tif (tun->flags & TUN_VNET_HDR) {\n\t\tstruct virtio_net_hdr gso = { 0 }; /* no info leak */\n\t\tif ((len -= tun->vnet_hdr_sz) < 0)\n\t\t\treturn -EINVAL;\n\n\t\tif (skb_is_gso(skb)) {\n\t\t\tstruct skb_shared_info *sinfo = skb_shinfo(skb);\n\n\t\t\t/* This is a hint as to how much should be linear. */\n\t\t\tgso.hdr_len = skb_headlen(skb);\n\t\t\tgso.gso_size = sinfo->gso_size;\n\t\t\tif (sinfo->gso_type & SKB_GSO_TCPV4)\n\t\t\t\tgso.gso_type = VIRTIO_NET_HDR_GSO_TCPV4;\n\t\t\telse if (sinfo->gso_type & SKB_GSO_TCPV6)\n\t\t\t\tgso.gso_type = VIRTIO_NET_HDR_GSO_TCPV6;\n\t\t\telse if (sinfo->gso_type & SKB_GSO_UDP)\n\t\t\t\tgso.gso_type = VIRTIO_NET_HDR_GSO_UDP;\n\t\t\telse {\n\t\t\t\tpr_err(\"unexpected GSO type: \"\n\t\t\t\t       \"0x%x, gso_size %d, hdr_len %d\\n\",\n\t\t\t\t       sinfo->gso_type, gso.gso_size,\n\t\t\t\t       gso.hdr_len);\n\t\t\t\tprint_hex_dump(KERN_ERR, \"tun: \",\n\t\t\t\t\t       DUMP_PREFIX_NONE,\n\t\t\t\t\t       16, 1, skb->head,\n\t\t\t\t\t       min((int)gso.hdr_len, 64), true);\n\t\t\t\tWARN_ON_ONCE(1);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (sinfo->gso_type & SKB_GSO_TCP_ECN)\n\t\t\t\tgso.gso_type |= VIRTIO_NET_HDR_GSO_ECN;\n\t\t} else\n\t\t\tgso.gso_type = VIRTIO_NET_HDR_GSO_NONE;\n\n\t\tif (skb->ip_summed == CHECKSUM_PARTIAL) {\n\t\t\tgso.flags = VIRTIO_NET_HDR_F_NEEDS_CSUM;\n\t\t\tgso.csum_start = skb_checksum_start_offset(skb);\n\t\t\tgso.csum_offset = skb->csum_offset;\n\t\t} else if (skb->ip_summed == CHECKSUM_UNNECESSARY) {\n\t\t\tgso.flags = VIRTIO_NET_HDR_F_DATA_VALID;\n\t\t} /* else everything is zero */\n\n\t\tif (unlikely(memcpy_toiovecend(iv, (void *)&gso, total,\n\t\t\t\t\t       sizeof(gso))))\n\t\t\treturn -EFAULT;\n\t\ttotal += tun->vnet_hdr_sz;\n\t}\n\n\tlen = min_t(int, skb->len, len);\n\n\tskb_copy_datagram_const_iovec(skb, 0, iv, total, len);\n\ttotal += skb->len;\n\n\ttun->dev->stats.tx_packets++;\n\ttun->dev->stats.tx_bytes += len;\n\n\treturn total;\n}\n\nstatic ssize_t tun_do_read(struct tun_struct *tun,\n\t\t\t   struct kiocb *iocb, const struct iovec *iv,\n\t\t\t   ssize_t len, int noblock)\n{\n\tDECLARE_WAITQUEUE(wait, current);\n\tstruct sk_buff *skb;\n\tssize_t ret = 0;\n\n\ttun_debug(KERN_INFO, tun, \"tun_chr_read\\n\");\n\n\tif (unlikely(!noblock))\n\t\tadd_wait_queue(&tun->wq.wait, &wait);\n\twhile (len) {\n\t\tcurrent->state = TASK_INTERRUPTIBLE;\n\n\t\t/* Read frames from the queue */\n\t\tif (!(skb=skb_dequeue(&tun->socket.sk->sk_receive_queue))) {\n\t\t\tif (noblock) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (signal_pending(current)) {\n\t\t\t\tret = -ERESTARTSYS;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (tun->dev->reg_state != NETREG_REGISTERED) {\n\t\t\t\tret = -EIO;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Nothing to read, let's sleep */\n\t\t\tschedule();\n\t\t\tcontinue;\n\t\t}\n\t\tnetif_wake_queue(tun->dev);\n\n\t\tret = tun_put_user(tun, skb, iv, len);\n\t\tkfree_skb(skb);\n\t\tbreak;\n\t}\n\n\tcurrent->state = TASK_RUNNING;\n\tif (unlikely(!noblock))\n\t\tremove_wait_queue(&tun->wq.wait, &wait);\n\n\treturn ret;\n}\n\nstatic ssize_t tun_chr_aio_read(struct kiocb *iocb, const struct iovec *iv,\n\t\t\t    unsigned long count, loff_t pos)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct tun_file *tfile = file->private_data;\n\tstruct tun_struct *tun = __tun_get(tfile);\n\tssize_t len, ret;\n\n\tif (!tun)\n\t\treturn -EBADFD;\n\tlen = iov_length(iv, count);\n\tif (len < 0) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = tun_do_read(tun, iocb, iv, len, file->f_flags & O_NONBLOCK);\n\tret = min_t(ssize_t, ret, len);\nout:\n\ttun_put(tun);\n\treturn ret;\n}\n\nstatic void tun_setup(struct net_device *dev)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\n\ttun->owner = -1;\n\ttun->group = -1;\n\n\tdev->ethtool_ops = &tun_ethtool_ops;\n\tdev->destructor = tun_free_netdev;\n}\n\n/* Trivial set of netlink ops to allow deleting tun or tap\n * device with netlink.\n */\nstatic int tun_validate(struct nlattr *tb[], struct nlattr *data[])\n{\n\treturn -EINVAL;\n}\n\nstatic struct rtnl_link_ops tun_link_ops __read_mostly = {\n\t.kind\t\t= DRV_NAME,\n\t.priv_size\t= sizeof(struct tun_struct),\n\t.setup\t\t= tun_setup,\n\t.validate\t= tun_validate,\n};\n\nstatic void tun_sock_write_space(struct sock *sk)\n{\n\tstruct tun_struct *tun;\n\twait_queue_head_t *wqueue;\n\n\tif (!sock_writeable(sk))\n\t\treturn;\n\n\tif (!test_and_clear_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags))\n\t\treturn;\n\n\twqueue = sk_sleep(sk);\n\tif (wqueue && waitqueue_active(wqueue))\n\t\twake_up_interruptible_sync_poll(wqueue, POLLOUT |\n\t\t\t\t\t\tPOLLWRNORM | POLLWRBAND);\n\n\ttun = tun_sk(sk)->tun;\n\tkill_fasync(&tun->fasync, SIGIO, POLL_OUT);\n}\n\nstatic void tun_sock_destruct(struct sock *sk)\n{\n\tfree_netdev(tun_sk(sk)->tun->dev);\n}\n\nstatic int tun_sendmsg(struct kiocb *iocb, struct socket *sock,\n\t\t       struct msghdr *m, size_t total_len)\n{\n\tstruct tun_struct *tun = container_of(sock, struct tun_struct, socket);\n\treturn tun_get_user(tun, m->msg_iov, total_len,\n\t\t\t    m->msg_flags & MSG_DONTWAIT);\n}\n\nstatic int tun_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t       struct msghdr *m, size_t total_len,\n\t\t       int flags)\n{\n\tstruct tun_struct *tun = container_of(sock, struct tun_struct, socket);\n\tint ret;\n\tif (flags & ~(MSG_DONTWAIT|MSG_TRUNC))\n\t\treturn -EINVAL;\n\tret = tun_do_read(tun, iocb, m->msg_iov, total_len,\n\t\t\t  flags & MSG_DONTWAIT);\n\tif (ret > total_len) {\n\t\tm->msg_flags |= MSG_TRUNC;\n\t\tret = flags & MSG_TRUNC ? ret : total_len;\n\t}\n\treturn ret;\n}\n\n/* Ops structure to mimic raw sockets with tun */\nstatic const struct proto_ops tun_socket_ops = {\n\t.sendmsg = tun_sendmsg,\n\t.recvmsg = tun_recvmsg,\n};\n\nstatic struct proto tun_proto = {\n\t.name\t\t= \"tun\",\n\t.owner\t\t= THIS_MODULE,\n\t.obj_size\t= sizeof(struct tun_sock),\n};\n\nstatic int tun_flags(struct tun_struct *tun)\n{\n\tint flags = 0;\n\n\tif (tun->flags & TUN_TUN_DEV)\n\t\tflags |= IFF_TUN;\n\telse\n\t\tflags |= IFF_TAP;\n\n\tif (tun->flags & TUN_NO_PI)\n\t\tflags |= IFF_NO_PI;\n\n\tif (tun->flags & TUN_ONE_QUEUE)\n\t\tflags |= IFF_ONE_QUEUE;\n\n\tif (tun->flags & TUN_VNET_HDR)\n\t\tflags |= IFF_VNET_HDR;\n\n\treturn flags;\n}\n\nstatic ssize_t tun_show_flags(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct tun_struct *tun = netdev_priv(to_net_dev(dev));\n\treturn sprintf(buf, \"0x%x\\n\", tun_flags(tun));\n}\n\nstatic ssize_t tun_show_owner(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct tun_struct *tun = netdev_priv(to_net_dev(dev));\n\treturn sprintf(buf, \"%d\\n\", tun->owner);\n}\n\nstatic ssize_t tun_show_group(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *buf)\n{\n\tstruct tun_struct *tun = netdev_priv(to_net_dev(dev));\n\treturn sprintf(buf, \"%d\\n\", tun->group);\n}\n\nstatic DEVICE_ATTR(tun_flags, 0444, tun_show_flags, NULL);\nstatic DEVICE_ATTR(owner, 0444, tun_show_owner, NULL);\nstatic DEVICE_ATTR(group, 0444, tun_show_group, NULL);\n\nstatic int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr)\n{\n\tstruct sock *sk;\n\tstruct tun_struct *tun;\n\tstruct net_device *dev;\n\tint err;\n\n\tdev = __dev_get_by_name(net, ifr->ifr_name);\n\tif (dev) {\n\t\tconst struct cred *cred = current_cred();\n\n\t\tif (ifr->ifr_flags & IFF_TUN_EXCL)\n\t\t\treturn -EBUSY;\n\t\tif ((ifr->ifr_flags & IFF_TUN) && dev->netdev_ops == &tun_netdev_ops)\n\t\t\ttun = netdev_priv(dev);\n\t\telse if ((ifr->ifr_flags & IFF_TAP) && dev->netdev_ops == &tap_netdev_ops)\n\t\t\ttun = netdev_priv(dev);\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\tif (((tun->owner != -1 && cred->euid != tun->owner) ||\n\t\t     (tun->group != -1 && !in_egroup_p(tun->group))) &&\n\t\t    !capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\terr = security_tun_dev_attach(tun->socket.sk);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = tun_attach(tun, file);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\telse {\n\t\tchar *name;\n\t\tunsigned long flags = 0;\n\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\terr = security_tun_dev_create();\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\t/* Set dev type */\n\t\tif (ifr->ifr_flags & IFF_TUN) {\n\t\t\t/* TUN device */\n\t\t\tflags |= TUN_TUN_DEV;\n\t\t\tname = \"tun%d\";\n\t\t} else if (ifr->ifr_flags & IFF_TAP) {\n\t\t\t/* TAP device */\n\t\t\tflags |= TUN_TAP_DEV;\n\t\t\tname = \"tap%d\";\n\t\t} else\n\t\t\treturn -EINVAL;\n\n\t\tif (*ifr->ifr_name)\n\t\t\tname = ifr->ifr_name;\n\n\t\tdev = alloc_netdev(sizeof(struct tun_struct), name,\n\t\t\t\t   tun_setup);\n\t\tif (!dev)\n\t\t\treturn -ENOMEM;\n\n\t\tdev_net_set(dev, net);\n\t\tdev->rtnl_link_ops = &tun_link_ops;\n\n\t\ttun = netdev_priv(dev);\n\t\ttun->dev = dev;\n\t\ttun->flags = flags;\n\t\ttun->txflt.count = 0;\n\t\ttun->vnet_hdr_sz = sizeof(struct virtio_net_hdr);\n\n\t\terr = -ENOMEM;\n\t\tsk = sk_alloc(net, AF_UNSPEC, GFP_KERNEL, &tun_proto);\n\t\tif (!sk)\n\t\t\tgoto err_free_dev;\n\n\t\ttun->socket.wq = &tun->wq;\n\t\tinit_waitqueue_head(&tun->wq.wait);\n\t\ttun->socket.ops = &tun_socket_ops;\n\t\tsock_init_data(&tun->socket, sk);\n\t\tsk->sk_write_space = tun_sock_write_space;\n\t\tsk->sk_sndbuf = INT_MAX;\n\n\t\ttun_sk(sk)->tun = tun;\n\n\t\tsecurity_tun_dev_post_create(sk);\n\n\t\ttun_net_init(dev);\n\n\t\tdev->hw_features = NETIF_F_SG | NETIF_F_FRAGLIST |\n\t\t\tTUN_USER_FEATURES;\n\t\tdev->features = dev->hw_features;\n\n\t\terr = register_netdevice(tun->dev);\n\t\tif (err < 0)\n\t\t\tgoto err_free_sk;\n\n\t\tif (device_create_file(&tun->dev->dev, &dev_attr_tun_flags) ||\n\t\t    device_create_file(&tun->dev->dev, &dev_attr_owner) ||\n\t\t    device_create_file(&tun->dev->dev, &dev_attr_group))\n\t\t\tpr_err(\"Failed to create tun sysfs files\\n\");\n\n\t\tsk->sk_destruct = tun_sock_destruct;\n\n\t\terr = tun_attach(tun, file);\n\t\tif (err < 0)\n\t\t\tgoto failed;\n\t}\n\n\ttun_debug(KERN_INFO, tun, \"tun_set_iff\\n\");\n\n\tif (ifr->ifr_flags & IFF_NO_PI)\n\t\ttun->flags |= TUN_NO_PI;\n\telse\n\t\ttun->flags &= ~TUN_NO_PI;\n\n\tif (ifr->ifr_flags & IFF_ONE_QUEUE)\n\t\ttun->flags |= TUN_ONE_QUEUE;\n\telse\n\t\ttun->flags &= ~TUN_ONE_QUEUE;\n\n\tif (ifr->ifr_flags & IFF_VNET_HDR)\n\t\ttun->flags |= TUN_VNET_HDR;\n\telse\n\t\ttun->flags &= ~TUN_VNET_HDR;\n\n\t/* Make sure persistent devices do not get stuck in\n\t * xoff state.\n\t */\n\tif (netif_running(tun->dev))\n\t\tnetif_wake_queue(tun->dev);\n\n\tstrcpy(ifr->ifr_name, tun->dev->name);\n\treturn 0;\n\n err_free_sk:\n\tsock_put(sk);\n err_free_dev:\n\tfree_netdev(dev);\n failed:\n\treturn err;\n}\n\nstatic int tun_get_iff(struct net *net, struct tun_struct *tun,\n\t\t       struct ifreq *ifr)\n{\n\ttun_debug(KERN_INFO, tun, \"tun_get_iff\\n\");\n\n\tstrcpy(ifr->ifr_name, tun->dev->name);\n\n\tifr->ifr_flags = tun_flags(tun);\n\n\treturn 0;\n}\n\n/* This is like a cut-down ethtool ops, except done via tun fd so no\n * privs required. */\nstatic int set_offload(struct tun_struct *tun, unsigned long arg)\n{\n\tu32 features = 0;\n\n\tif (arg & TUN_F_CSUM) {\n\t\tfeatures |= NETIF_F_HW_CSUM;\n\t\targ &= ~TUN_F_CSUM;\n\n\t\tif (arg & (TUN_F_TSO4|TUN_F_TSO6)) {\n\t\t\tif (arg & TUN_F_TSO_ECN) {\n\t\t\t\tfeatures |= NETIF_F_TSO_ECN;\n\t\t\t\targ &= ~TUN_F_TSO_ECN;\n\t\t\t}\n\t\t\tif (arg & TUN_F_TSO4)\n\t\t\t\tfeatures |= NETIF_F_TSO;\n\t\t\tif (arg & TUN_F_TSO6)\n\t\t\t\tfeatures |= NETIF_F_TSO6;\n\t\t\targ &= ~(TUN_F_TSO4|TUN_F_TSO6);\n\t\t}\n\n\t\tif (arg & TUN_F_UFO) {\n\t\t\tfeatures |= NETIF_F_UFO;\n\t\t\targ &= ~TUN_F_UFO;\n\t\t}\n\t}\n\n\t/* This gives the user a way to test for new features in future by\n\t * trying to set them. */\n\tif (arg)\n\t\treturn -EINVAL;\n\n\ttun->set_features = features;\n\tnetdev_update_features(tun->dev);\n\n\treturn 0;\n}\n\nstatic long __tun_chr_ioctl(struct file *file, unsigned int cmd,\n\t\t\t    unsigned long arg, int ifreq_len)\n{\n\tstruct tun_file *tfile = file->private_data;\n\tstruct tun_struct *tun;\n\tvoid __user* argp = (void __user*)arg;\n\tstruct sock_fprog fprog;\n\tstruct ifreq ifr;\n\tint sndbuf;\n\tint vnet_hdr_sz;\n\tint ret;\n\n\tif (cmd == TUNSETIFF || _IOC_TYPE(cmd) == 0x89)\n\t\tif (copy_from_user(&ifr, argp, ifreq_len))\n\t\t\treturn -EFAULT;\n\n\tif (cmd == TUNGETFEATURES) {\n\t\t/* Currently this just means: \"what IFF flags are valid?\".\n\t\t * This is needed because we never checked for invalid flags on\n\t\t * TUNSETIFF. */\n\t\treturn put_user(IFF_TUN | IFF_TAP | IFF_NO_PI | IFF_ONE_QUEUE |\n\t\t\t\tIFF_VNET_HDR,\n\t\t\t\t(unsigned int __user*)argp);\n\t}\n\n\trtnl_lock();\n\n\ttun = __tun_get(tfile);\n\tif (cmd == TUNSETIFF && !tun) {\n\t\tifr.ifr_name[IFNAMSIZ-1] = '\\0';\n\n\t\tret = tun_set_iff(tfile->net, file, &ifr);\n\n\t\tif (ret)\n\t\t\tgoto unlock;\n\n\t\tif (copy_to_user(argp, &ifr, ifreq_len))\n\t\t\tret = -EFAULT;\n\t\tgoto unlock;\n\t}\n\n\tret = -EBADFD;\n\tif (!tun)\n\t\tgoto unlock;\n\n\ttun_debug(KERN_INFO, tun, \"tun_chr_ioctl cmd %d\\n\", cmd);\n\n\tret = 0;\n\tswitch (cmd) {\n\tcase TUNGETIFF:\n\t\tret = tun_get_iff(current->nsproxy->net_ns, tun, &ifr);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (copy_to_user(argp, &ifr, ifreq_len))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase TUNSETNOCSUM:\n\t\t/* Disable/Enable checksum */\n\n\t\t/* [unimplemented] */\n\t\ttun_debug(KERN_INFO, tun, \"ignored: set checksum %s\\n\",\n\t\t\t  arg ? \"disabled\" : \"enabled\");\n\t\tbreak;\n\n\tcase TUNSETPERSIST:\n\t\t/* Disable/Enable persist mode */\n\t\tif (arg)\n\t\t\ttun->flags |= TUN_PERSIST;\n\t\telse\n\t\t\ttun->flags &= ~TUN_PERSIST;\n\n\t\ttun_debug(KERN_INFO, tun, \"persist %s\\n\",\n\t\t\t  arg ? \"enabled\" : \"disabled\");\n\t\tbreak;\n\n\tcase TUNSETOWNER:\n\t\t/* Set owner of the device */\n\t\ttun->owner = (uid_t) arg;\n\n\t\ttun_debug(KERN_INFO, tun, \"owner set to %d\\n\", tun->owner);\n\t\tbreak;\n\n\tcase TUNSETGROUP:\n\t\t/* Set group of the device */\n\t\ttun->group= (gid_t) arg;\n\n\t\ttun_debug(KERN_INFO, tun, \"group set to %d\\n\", tun->group);\n\t\tbreak;\n\n\tcase TUNSETLINK:\n\t\t/* Only allow setting the type when the interface is down */\n\t\tif (tun->dev->flags & IFF_UP) {\n\t\t\ttun_debug(KERN_INFO, tun,\n\t\t\t\t  \"Linktype set failed because interface is up\\n\");\n\t\t\tret = -EBUSY;\n\t\t} else {\n\t\t\ttun->dev->type = (int) arg;\n\t\t\ttun_debug(KERN_INFO, tun, \"linktype set to %d\\n\",\n\t\t\t\t  tun->dev->type);\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\n#ifdef TUN_DEBUG\n\tcase TUNSETDEBUG:\n\t\ttun->debug = arg;\n\t\tbreak;\n#endif\n\tcase TUNSETOFFLOAD:\n\t\tret = set_offload(tun, arg);\n\t\tbreak;\n\n\tcase TUNSETTXFILTER:\n\t\t/* Can be set only for TAPs */\n\t\tret = -EINVAL;\n\t\tif ((tun->flags & TUN_TYPE_MASK) != TUN_TAP_DEV)\n\t\t\tbreak;\n\t\tret = update_filter(&tun->txflt, (void __user *)arg);\n\t\tbreak;\n\n\tcase SIOCGIFHWADDR:\n\t\t/* Get hw address */\n\t\tmemcpy(ifr.ifr_hwaddr.sa_data, tun->dev->dev_addr, ETH_ALEN);\n\t\tifr.ifr_hwaddr.sa_family = tun->dev->type;\n\t\tif (copy_to_user(argp, &ifr, ifreq_len))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase SIOCSIFHWADDR:\n\t\t/* Set hw address */\n\t\ttun_debug(KERN_DEBUG, tun, \"set hw address: %pM\\n\",\n\t\t\t  ifr.ifr_hwaddr.sa_data);\n\n\t\tret = dev_set_mac_address(tun->dev, &ifr.ifr_hwaddr);\n\t\tbreak;\n\n\tcase TUNGETSNDBUF:\n\t\tsndbuf = tun->socket.sk->sk_sndbuf;\n\t\tif (copy_to_user(argp, &sndbuf, sizeof(sndbuf)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase TUNSETSNDBUF:\n\t\tif (copy_from_user(&sndbuf, argp, sizeof(sndbuf))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\ttun->socket.sk->sk_sndbuf = sndbuf;\n\t\tbreak;\n\n\tcase TUNGETVNETHDRSZ:\n\t\tvnet_hdr_sz = tun->vnet_hdr_sz;\n\t\tif (copy_to_user(argp, &vnet_hdr_sz, sizeof(vnet_hdr_sz)))\n\t\t\tret = -EFAULT;\n\t\tbreak;\n\n\tcase TUNSETVNETHDRSZ:\n\t\tif (copy_from_user(&vnet_hdr_sz, argp, sizeof(vnet_hdr_sz))) {\n\t\t\tret = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tif (vnet_hdr_sz < (int)sizeof(struct virtio_net_hdr)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\ttun->vnet_hdr_sz = vnet_hdr_sz;\n\t\tbreak;\n\n\tcase TUNATTACHFILTER:\n\t\t/* Can be set only for TAPs */\n\t\tret = -EINVAL;\n\t\tif ((tun->flags & TUN_TYPE_MASK) != TUN_TAP_DEV)\n\t\t\tbreak;\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(&fprog, argp, sizeof(fprog)))\n\t\t\tbreak;\n\n\t\tret = sk_attach_filter(&fprog, tun->socket.sk);\n\t\tbreak;\n\n\tcase TUNDETACHFILTER:\n\t\t/* Can be set only for TAPs */\n\t\tret = -EINVAL;\n\t\tif ((tun->flags & TUN_TYPE_MASK) != TUN_TAP_DEV)\n\t\t\tbreak;\n\t\tret = sk_detach_filter(tun->socket.sk);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\nunlock:\n\trtnl_unlock();\n\tif (tun)\n\t\ttun_put(tun);\n\treturn ret;\n}\n\nstatic long tun_chr_ioctl(struct file *file,\n\t\t\t  unsigned int cmd, unsigned long arg)\n{\n\treturn __tun_chr_ioctl(file, cmd, arg, sizeof (struct ifreq));\n}\n\n#ifdef CONFIG_COMPAT\nstatic long tun_chr_compat_ioctl(struct file *file,\n\t\t\t unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase TUNSETIFF:\n\tcase TUNGETIFF:\n\tcase TUNSETTXFILTER:\n\tcase TUNGETSNDBUF:\n\tcase TUNSETSNDBUF:\n\tcase SIOCGIFHWADDR:\n\tcase SIOCSIFHWADDR:\n\t\targ = (unsigned long)compat_ptr(arg);\n\t\tbreak;\n\tdefault:\n\t\targ = (compat_ulong_t)arg;\n\t\tbreak;\n\t}\n\n\t/*\n\t * compat_ifreq is shorter than ifreq, so we must not access beyond\n\t * the end of that structure. All fields that are used in this\n\t * driver are compatible though, we don't need to convert the\n\t * contents.\n\t */\n\treturn __tun_chr_ioctl(file, cmd, arg, sizeof(struct compat_ifreq));\n}\n#endif /* CONFIG_COMPAT */\n\nstatic int tun_chr_fasync(int fd, struct file *file, int on)\n{\n\tstruct tun_struct *tun = tun_get(file);\n\tint ret;\n\n\tif (!tun)\n\t\treturn -EBADFD;\n\n\ttun_debug(KERN_INFO, tun, \"tun_chr_fasync %d\\n\", on);\n\n\tif ((ret = fasync_helper(fd, file, on, &tun->fasync)) < 0)\n\t\tgoto out;\n\n\tif (on) {\n\t\tret = __f_setown(file, task_pid(current), PIDTYPE_PID, 0);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\ttun->flags |= TUN_FASYNC;\n\t} else\n\t\ttun->flags &= ~TUN_FASYNC;\n\tret = 0;\nout:\n\ttun_put(tun);\n\treturn ret;\n}\n\nstatic int tun_chr_open(struct inode *inode, struct file * file)\n{\n\tstruct tun_file *tfile;\n\n\tDBG1(KERN_INFO, \"tunX: tun_chr_open\\n\");\n\n\ttfile = kmalloc(sizeof(*tfile), GFP_KERNEL);\n\tif (!tfile)\n\t\treturn -ENOMEM;\n\tatomic_set(&tfile->count, 0);\n\ttfile->tun = NULL;\n\ttfile->net = get_net(current->nsproxy->net_ns);\n\tfile->private_data = tfile;\n\treturn 0;\n}\n\nstatic int tun_chr_close(struct inode *inode, struct file *file)\n{\n\tstruct tun_file *tfile = file->private_data;\n\tstruct tun_struct *tun;\n\n\ttun = __tun_get(tfile);\n\tif (tun) {\n\t\tstruct net_device *dev = tun->dev;\n\n\t\ttun_debug(KERN_INFO, tun, \"tun_chr_close\\n\");\n\n\t\t__tun_detach(tun);\n\n\t\t/* If desirable, unregister the netdevice. */\n\t\tif (!(tun->flags & TUN_PERSIST)) {\n\t\t\trtnl_lock();\n\t\t\tif (dev->reg_state == NETREG_REGISTERED)\n\t\t\t\tunregister_netdevice(dev);\n\t\t\trtnl_unlock();\n\t\t}\n\t}\n\n\ttun = tfile->tun;\n\tif (tun)\n\t\tsock_put(tun->socket.sk);\n\n\tput_net(tfile->net);\n\tkfree(tfile);\n\n\treturn 0;\n}\n\nstatic const struct file_operations tun_fops = {\n\t.owner\t= THIS_MODULE,\n\t.llseek = no_llseek,\n\t.read  = do_sync_read,\n\t.aio_read  = tun_chr_aio_read,\n\t.write = do_sync_write,\n\t.aio_write = tun_chr_aio_write,\n\t.poll\t= tun_chr_poll,\n\t.unlocked_ioctl\t= tun_chr_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = tun_chr_compat_ioctl,\n#endif\n\t.open\t= tun_chr_open,\n\t.release = tun_chr_close,\n\t.fasync = tun_chr_fasync\n};\n\nstatic struct miscdevice tun_miscdev = {\n\t.minor = TUN_MINOR,\n\t.name = \"tun\",\n\t.nodename = \"net/tun\",\n\t.fops = &tun_fops,\n};\n\n/* ethtool interface */\n\nstatic int tun_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\n{\n\tcmd->supported\t\t= 0;\n\tcmd->advertising\t= 0;\n\tethtool_cmd_speed_set(cmd, SPEED_10);\n\tcmd->duplex\t\t= DUPLEX_FULL;\n\tcmd->port\t\t= PORT_TP;\n\tcmd->phy_address\t= 0;\n\tcmd->transceiver\t= XCVR_INTERNAL;\n\tcmd->autoneg\t\t= AUTONEG_DISABLE;\n\tcmd->maxtxpkt\t\t= 0;\n\tcmd->maxrxpkt\t\t= 0;\n\treturn 0;\n}\n\nstatic void tun_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstruct tun_struct *tun = netdev_priv(dev);\n\n\tstrcpy(info->driver, DRV_NAME);\n\tstrcpy(info->version, DRV_VERSION);\n\tstrcpy(info->fw_version, \"N/A\");\n\n\tswitch (tun->flags & TUN_TYPE_MASK) {\n\tcase TUN_TUN_DEV:\n\t\tstrcpy(info->bus_info, \"tun\");\n\t\tbreak;\n\tcase TUN_TAP_DEV:\n\t\tstrcpy(info->bus_info, \"tap\");\n\t\tbreak;\n\t}\n}\n\nstatic u32 tun_get_msglevel(struct net_device *dev)\n{\n#ifdef TUN_DEBUG\n\tstruct tun_struct *tun = netdev_priv(dev);\n\treturn tun->debug;\n#else\n\treturn -EOPNOTSUPP;\n#endif\n}\n\nstatic void tun_set_msglevel(struct net_device *dev, u32 value)\n{\n#ifdef TUN_DEBUG\n\tstruct tun_struct *tun = netdev_priv(dev);\n\ttun->debug = value;\n#endif\n}\n\nstatic const struct ethtool_ops tun_ethtool_ops = {\n\t.get_settings\t= tun_get_settings,\n\t.get_drvinfo\t= tun_get_drvinfo,\n\t.get_msglevel\t= tun_get_msglevel,\n\t.set_msglevel\t= tun_set_msglevel,\n\t.get_link\t= ethtool_op_get_link,\n};\n\n\nstatic int __init tun_init(void)\n{\n\tint ret = 0;\n\n\tpr_info(\"%s, %s\\n\", DRV_DESCRIPTION, DRV_VERSION);\n\tpr_info(\"%s\\n\", DRV_COPYRIGHT);\n\n\tret = rtnl_link_register(&tun_link_ops);\n\tif (ret) {\n\t\tpr_err(\"Can't register link_ops\\n\");\n\t\tgoto err_linkops;\n\t}\n\n\tret = misc_register(&tun_miscdev);\n\tif (ret) {\n\t\tpr_err(\"Can't register misc device %d\\n\", TUN_MINOR);\n\t\tgoto err_misc;\n\t}\n\treturn  0;\nerr_misc:\n\trtnl_link_unregister(&tun_link_ops);\nerr_linkops:\n\treturn ret;\n}\n\nstatic void tun_cleanup(void)\n{\n\tmisc_deregister(&tun_miscdev);\n\trtnl_link_unregister(&tun_link_ops);\n}\n\n/* Get an underlying socket object from tun file.  Returns error unless file is\n * attached to a device.  The returned object works like a packet socket, it\n * can be used for sock_sendmsg/sock_recvmsg.  The caller is responsible for\n * holding a reference to the file for as long as the socket is in use. */\nstruct socket *tun_get_socket(struct file *file)\n{\n\tstruct tun_struct *tun;\n\tif (file->f_op != &tun_fops)\n\t\treturn ERR_PTR(-EINVAL);\n\ttun = tun_get(file);\n\tif (!tun)\n\t\treturn ERR_PTR(-EBADFD);\n\ttun_put(tun);\n\treturn &tun->socket;\n}\nEXPORT_SYMBOL_GPL(tun_get_socket);\n\nmodule_init(tun_init);\nmodule_exit(tun_cleanup);\nMODULE_DESCRIPTION(DRV_DESCRIPTION);\nMODULE_AUTHOR(DRV_COPYRIGHT);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_MISCDEV(TUN_MINOR);\nMODULE_ALIAS(\"devname:net/tun\");\n", "/*\n *  drivers/net/veth.c\n *\n *  Copyright (C) 2007 OpenVZ http://openvz.org, SWsoft Inc\n *\n * Author: Pavel Emelianov <xemul@openvz.org>\n * Ethtool interface from: Eric W. Biederman <ebiederm@xmission.com>\n *\n */\n\n#include <linux/netdevice.h>\n#include <linux/slab.h>\n#include <linux/ethtool.h>\n#include <linux/etherdevice.h>\n#include <linux/u64_stats_sync.h>\n\n#include <net/dst.h>\n#include <net/xfrm.h>\n#include <linux/veth.h>\n\n#define DRV_NAME\t\"veth\"\n#define DRV_VERSION\t\"1.0\"\n\n#define MIN_MTU 68\t\t/* Min L3 MTU */\n#define MAX_MTU 65535\t\t/* Max L3 MTU (arbitrary) */\n\nstruct veth_net_stats {\n\tu64\t\t\trx_packets;\n\tu64\t\t\ttx_packets;\n\tu64\t\t\trx_bytes;\n\tu64\t\t\ttx_bytes;\n\tu64\t\t\trx_dropped;\n\tstruct u64_stats_sync\tsyncp;\n};\n\nstruct veth_priv {\n\tstruct net_device *peer;\n\tstruct veth_net_stats __percpu *stats;\n};\n\n/*\n * ethtool interface\n */\n\nstatic struct {\n\tconst char string[ETH_GSTRING_LEN];\n} ethtool_stats_keys[] = {\n\t{ \"peer_ifindex\" },\n};\n\nstatic int veth_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)\n{\n\tcmd->supported\t\t= 0;\n\tcmd->advertising\t= 0;\n\tethtool_cmd_speed_set(cmd, SPEED_10000);\n\tcmd->duplex\t\t= DUPLEX_FULL;\n\tcmd->port\t\t= PORT_TP;\n\tcmd->phy_address\t= 0;\n\tcmd->transceiver\t= XCVR_INTERNAL;\n\tcmd->autoneg\t\t= AUTONEG_DISABLE;\n\tcmd->maxtxpkt\t\t= 0;\n\tcmd->maxrxpkt\t\t= 0;\n\treturn 0;\n}\n\nstatic void veth_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)\n{\n\tstrcpy(info->driver, DRV_NAME);\n\tstrcpy(info->version, DRV_VERSION);\n\tstrcpy(info->fw_version, \"N/A\");\n}\n\nstatic void veth_get_strings(struct net_device *dev, u32 stringset, u8 *buf)\n{\n\tswitch(stringset) {\n\tcase ETH_SS_STATS:\n\t\tmemcpy(buf, &ethtool_stats_keys, sizeof(ethtool_stats_keys));\n\t\tbreak;\n\t}\n}\n\nstatic int veth_get_sset_count(struct net_device *dev, int sset)\n{\n\tswitch (sset) {\n\tcase ETH_SS_STATS:\n\t\treturn ARRAY_SIZE(ethtool_stats_keys);\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n}\n\nstatic void veth_get_ethtool_stats(struct net_device *dev,\n\t\tstruct ethtool_stats *stats, u64 *data)\n{\n\tstruct veth_priv *priv;\n\n\tpriv = netdev_priv(dev);\n\tdata[0] = priv->peer->ifindex;\n}\n\nstatic const struct ethtool_ops veth_ethtool_ops = {\n\t.get_settings\t\t= veth_get_settings,\n\t.get_drvinfo\t\t= veth_get_drvinfo,\n\t.get_link\t\t= ethtool_op_get_link,\n\t.get_strings\t\t= veth_get_strings,\n\t.get_sset_count\t\t= veth_get_sset_count,\n\t.get_ethtool_stats\t= veth_get_ethtool_stats,\n};\n\n/*\n * xmit\n */\n\nstatic netdev_tx_t veth_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct net_device *rcv = NULL;\n\tstruct veth_priv *priv, *rcv_priv;\n\tstruct veth_net_stats *stats, *rcv_stats;\n\tint length;\n\n\tpriv = netdev_priv(dev);\n\trcv = priv->peer;\n\trcv_priv = netdev_priv(rcv);\n\n\tstats = this_cpu_ptr(priv->stats);\n\trcv_stats = this_cpu_ptr(rcv_priv->stats);\n\n\t/* don't change ip_summed == CHECKSUM_PARTIAL, as that\n\t   will cause bad checksum on forwarded packets */\n\tif (skb->ip_summed == CHECKSUM_NONE &&\n\t    rcv->features & NETIF_F_RXCSUM)\n\t\tskb->ip_summed = CHECKSUM_UNNECESSARY;\n\n\tlength = skb->len;\n\tif (dev_forward_skb(rcv, skb) != NET_RX_SUCCESS)\n\t\tgoto rx_drop;\n\n\tu64_stats_update_begin(&stats->syncp);\n\tstats->tx_bytes += length;\n\tstats->tx_packets++;\n\tu64_stats_update_end(&stats->syncp);\n\n\tu64_stats_update_begin(&rcv_stats->syncp);\n\trcv_stats->rx_bytes += length;\n\trcv_stats->rx_packets++;\n\tu64_stats_update_end(&rcv_stats->syncp);\n\n\treturn NETDEV_TX_OK;\n\nrx_drop:\n\tu64_stats_update_begin(&rcv_stats->syncp);\n\trcv_stats->rx_dropped++;\n\tu64_stats_update_end(&rcv_stats->syncp);\n\treturn NETDEV_TX_OK;\n}\n\n/*\n * general routines\n */\n\nstatic struct rtnl_link_stats64 *veth_get_stats64(struct net_device *dev,\n\t\t\t\t\t\t  struct rtnl_link_stats64 *tot)\n{\n\tstruct veth_priv *priv = netdev_priv(dev);\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct veth_net_stats *stats = per_cpu_ptr(priv->stats, cpu);\n\t\tu64 rx_packets, rx_bytes, rx_dropped;\n\t\tu64 tx_packets, tx_bytes;\n\t\tunsigned int start;\n\n\t\tdo {\n\t\t\tstart = u64_stats_fetch_begin_bh(&stats->syncp);\n\t\t\trx_packets = stats->rx_packets;\n\t\t\ttx_packets = stats->tx_packets;\n\t\t\trx_bytes = stats->rx_bytes;\n\t\t\ttx_bytes = stats->tx_bytes;\n\t\t\trx_dropped = stats->rx_dropped;\n\t\t} while (u64_stats_fetch_retry_bh(&stats->syncp, start));\n\t\ttot->rx_packets += rx_packets;\n\t\ttot->tx_packets += tx_packets;\n\t\ttot->rx_bytes   += rx_bytes;\n\t\ttot->tx_bytes   += tx_bytes;\n\t\ttot->rx_dropped += rx_dropped;\n\t}\n\n\treturn tot;\n}\n\nstatic int veth_open(struct net_device *dev)\n{\n\tstruct veth_priv *priv;\n\n\tpriv = netdev_priv(dev);\n\tif (priv->peer == NULL)\n\t\treturn -ENOTCONN;\n\n\tif (priv->peer->flags & IFF_UP) {\n\t\tnetif_carrier_on(dev);\n\t\tnetif_carrier_on(priv->peer);\n\t}\n\treturn 0;\n}\n\nstatic int veth_close(struct net_device *dev)\n{\n\tstruct veth_priv *priv = netdev_priv(dev);\n\n\tnetif_carrier_off(dev);\n\tnetif_carrier_off(priv->peer);\n\n\treturn 0;\n}\n\nstatic int is_valid_veth_mtu(int new_mtu)\n{\n\treturn new_mtu >= MIN_MTU && new_mtu <= MAX_MTU;\n}\n\nstatic int veth_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tif (!is_valid_veth_mtu(new_mtu))\n\t\treturn -EINVAL;\n\tdev->mtu = new_mtu;\n\treturn 0;\n}\n\nstatic int veth_dev_init(struct net_device *dev)\n{\n\tstruct veth_net_stats __percpu *stats;\n\tstruct veth_priv *priv;\n\n\tstats = alloc_percpu(struct veth_net_stats);\n\tif (stats == NULL)\n\t\treturn -ENOMEM;\n\n\tpriv = netdev_priv(dev);\n\tpriv->stats = stats;\n\treturn 0;\n}\n\nstatic void veth_dev_free(struct net_device *dev)\n{\n\tstruct veth_priv *priv;\n\n\tpriv = netdev_priv(dev);\n\tfree_percpu(priv->stats);\n\tfree_netdev(dev);\n}\n\nstatic const struct net_device_ops veth_netdev_ops = {\n\t.ndo_init            = veth_dev_init,\n\t.ndo_open            = veth_open,\n\t.ndo_stop            = veth_close,\n\t.ndo_start_xmit      = veth_xmit,\n\t.ndo_change_mtu      = veth_change_mtu,\n\t.ndo_get_stats64     = veth_get_stats64,\n\t.ndo_set_mac_address = eth_mac_addr,\n};\n\nstatic void veth_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\n\tdev->netdev_ops = &veth_netdev_ops;\n\tdev->ethtool_ops = &veth_ethtool_ops;\n\tdev->features |= NETIF_F_LLTX;\n\tdev->destructor = veth_dev_free;\n\n\tdev->hw_features = NETIF_F_NO_CSUM | NETIF_F_SG | NETIF_F_RXCSUM;\n}\n\n/*\n * netlink interface\n */\n\nstatic int veth_validate(struct nlattr *tb[], struct nlattr *data[])\n{\n\tif (tb[IFLA_ADDRESS]) {\n\t\tif (nla_len(tb[IFLA_ADDRESS]) != ETH_ALEN)\n\t\t\treturn -EINVAL;\n\t\tif (!is_valid_ether_addr(nla_data(tb[IFLA_ADDRESS])))\n\t\t\treturn -EADDRNOTAVAIL;\n\t}\n\tif (tb[IFLA_MTU]) {\n\t\tif (!is_valid_veth_mtu(nla_get_u32(tb[IFLA_MTU])))\n\t\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic struct rtnl_link_ops veth_link_ops;\n\nstatic int veth_newlink(struct net *src_net, struct net_device *dev,\n\t\t\t struct nlattr *tb[], struct nlattr *data[])\n{\n\tint err;\n\tstruct net_device *peer;\n\tstruct veth_priv *priv;\n\tchar ifname[IFNAMSIZ];\n\tstruct nlattr *peer_tb[IFLA_MAX + 1], **tbp;\n\tstruct ifinfomsg *ifmp;\n\tstruct net *net;\n\n\t/*\n\t * create and register peer first\n\t */\n\tif (data != NULL && data[VETH_INFO_PEER] != NULL) {\n\t\tstruct nlattr *nla_peer;\n\n\t\tnla_peer = data[VETH_INFO_PEER];\n\t\tifmp = nla_data(nla_peer);\n\t\terr = nla_parse(peer_tb, IFLA_MAX,\n\t\t\t\tnla_data(nla_peer) + sizeof(struct ifinfomsg),\n\t\t\t\tnla_len(nla_peer) - sizeof(struct ifinfomsg),\n\t\t\t\tifla_policy);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\terr = veth_validate(peer_tb, NULL);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\ttbp = peer_tb;\n\t} else {\n\t\tifmp = NULL;\n\t\ttbp = tb;\n\t}\n\n\tif (tbp[IFLA_IFNAME])\n\t\tnla_strlcpy(ifname, tbp[IFLA_IFNAME], IFNAMSIZ);\n\telse\n\t\tsnprintf(ifname, IFNAMSIZ, DRV_NAME \"%%d\");\n\n\tnet = rtnl_link_get_net(src_net, tbp);\n\tif (IS_ERR(net))\n\t\treturn PTR_ERR(net);\n\n\tpeer = rtnl_create_link(src_net, net, ifname, &veth_link_ops, tbp);\n\tif (IS_ERR(peer)) {\n\t\tput_net(net);\n\t\treturn PTR_ERR(peer);\n\t}\n\n\tif (tbp[IFLA_ADDRESS] == NULL)\n\t\trandom_ether_addr(peer->dev_addr);\n\n\terr = register_netdevice(peer);\n\tput_net(net);\n\tnet = NULL;\n\tif (err < 0)\n\t\tgoto err_register_peer;\n\n\tnetif_carrier_off(peer);\n\n\terr = rtnl_configure_link(peer, ifmp);\n\tif (err < 0)\n\t\tgoto err_configure_peer;\n\n\t/*\n\t * register dev last\n\t *\n\t * note, that since we've registered new device the dev's name\n\t * should be re-allocated\n\t */\n\n\tif (tb[IFLA_ADDRESS] == NULL)\n\t\trandom_ether_addr(dev->dev_addr);\n\n\tif (tb[IFLA_IFNAME])\n\t\tnla_strlcpy(dev->name, tb[IFLA_IFNAME], IFNAMSIZ);\n\telse\n\t\tsnprintf(dev->name, IFNAMSIZ, DRV_NAME \"%%d\");\n\n\tif (strchr(dev->name, '%')) {\n\t\terr = dev_alloc_name(dev, dev->name);\n\t\tif (err < 0)\n\t\t\tgoto err_alloc_name;\n\t}\n\n\terr = register_netdevice(dev);\n\tif (err < 0)\n\t\tgoto err_register_dev;\n\n\tnetif_carrier_off(dev);\n\n\t/*\n\t * tie the deviced together\n\t */\n\n\tpriv = netdev_priv(dev);\n\tpriv->peer = peer;\n\n\tpriv = netdev_priv(peer);\n\tpriv->peer = dev;\n\treturn 0;\n\nerr_register_dev:\n\t/* nothing to do */\nerr_alloc_name:\nerr_configure_peer:\n\tunregister_netdevice(peer);\n\treturn err;\n\nerr_register_peer:\n\tfree_netdev(peer);\n\treturn err;\n}\n\nstatic void veth_dellink(struct net_device *dev, struct list_head *head)\n{\n\tstruct veth_priv *priv;\n\tstruct net_device *peer;\n\n\tpriv = netdev_priv(dev);\n\tpeer = priv->peer;\n\n\tunregister_netdevice_queue(dev, head);\n\tunregister_netdevice_queue(peer, head);\n}\n\nstatic const struct nla_policy veth_policy[VETH_INFO_MAX + 1];\n\nstatic struct rtnl_link_ops veth_link_ops = {\n\t.kind\t\t= DRV_NAME,\n\t.priv_size\t= sizeof(struct veth_priv),\n\t.setup\t\t= veth_setup,\n\t.validate\t= veth_validate,\n\t.newlink\t= veth_newlink,\n\t.dellink\t= veth_dellink,\n\t.policy\t\t= veth_policy,\n\t.maxtype\t= VETH_INFO_MAX,\n};\n\n/*\n * init/fini\n */\n\nstatic __init int veth_init(void)\n{\n\treturn rtnl_link_register(&veth_link_ops);\n}\n\nstatic __exit void veth_exit(void)\n{\n\trtnl_link_unregister(&veth_link_ops);\n}\n\nmodule_init(veth_init);\nmodule_exit(veth_exit);\n\nMODULE_DESCRIPTION(\"Virtual Ethernet Tunnel\");\nMODULE_LICENSE(\"GPL v2\");\nMODULE_ALIAS_RTNL_LINK(DRV_NAME);\n", "/*\n * Generic HDLC support routines for Linux\n * Frame Relay support\n *\n * Copyright (C) 1999 - 2006 Krzysztof Halasa <khc@pm.waw.pl>\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of version 2 of the GNU General Public License\n * as published by the Free Software Foundation.\n *\n\n            Theory of PVC state\n\n DCE mode:\n\n (exist,new) -> 0,0 when \"PVC create\" or if \"link unreliable\"\n         0,x -> 1,1 if \"link reliable\" when sending FULL STATUS\n         1,1 -> 1,0 if received FULL STATUS ACK\n\n (active)    -> 0 when \"ifconfig PVC down\" or \"link unreliable\" or \"PVC create\"\n             -> 1 when \"PVC up\" and (exist,new) = 1,0\n\n DTE mode:\n (exist,new,active) = FULL STATUS if \"link reliable\"\n\t\t    = 0, 0, 0 if \"link unreliable\"\n No LMI:\n active = open and \"link reliable\"\n exist = new = not used\n\n CCITT LMI: ITU-T Q.933 Annex A\n ANSI LMI: ANSI T1.617 Annex D\n CISCO LMI: the original, aka \"Gang of Four\" LMI\n\n*/\n\n#include <linux/errno.h>\n#include <linux/etherdevice.h>\n#include <linux/hdlc.h>\n#include <linux/if_arp.h>\n#include <linux/inetdevice.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/pkt_sched.h>\n#include <linux/poll.h>\n#include <linux/rtnetlink.h>\n#include <linux/skbuff.h>\n#include <linux/slab.h>\n\n#undef DEBUG_PKT\n#undef DEBUG_ECN\n#undef DEBUG_LINK\n#undef DEBUG_PROTO\n#undef DEBUG_PVC\n\n#define FR_UI\t\t\t0x03\n#define FR_PAD\t\t\t0x00\n\n#define NLPID_IP\t\t0xCC\n#define NLPID_IPV6\t\t0x8E\n#define NLPID_SNAP\t\t0x80\n#define NLPID_PAD\t\t0x00\n#define NLPID_CCITT_ANSI_LMI\t0x08\n#define NLPID_CISCO_LMI\t\t0x09\n\n\n#define LMI_CCITT_ANSI_DLCI\t   0 /* LMI DLCI */\n#define LMI_CISCO_DLCI\t\t1023\n\n#define LMI_CALLREF\t\t0x00 /* Call Reference */\n#define LMI_ANSI_LOCKSHIFT\t0x95 /* ANSI locking shift */\n#define LMI_ANSI_CISCO_REPTYPE\t0x01 /* report type */\n#define LMI_CCITT_REPTYPE\t0x51\n#define LMI_ANSI_CISCO_ALIVE\t0x03 /* keep alive */\n#define LMI_CCITT_ALIVE\t\t0x53\n#define LMI_ANSI_CISCO_PVCSTAT\t0x07 /* PVC status */\n#define LMI_CCITT_PVCSTAT\t0x57\n\n#define LMI_FULLREP\t\t0x00 /* full report  */\n#define LMI_INTEGRITY\t\t0x01 /* link integrity report */\n#define LMI_SINGLE\t\t0x02 /* single PVC report */\n\n#define LMI_STATUS_ENQUIRY      0x75\n#define LMI_STATUS              0x7D /* reply */\n\n#define LMI_REPT_LEN               1 /* report type element length */\n#define LMI_INTEG_LEN              2 /* link integrity element length */\n\n#define LMI_CCITT_CISCO_LENGTH\t  13 /* LMI frame lengths */\n#define LMI_ANSI_LENGTH\t\t  14\n\n\ntypedef struct {\n#if defined(__LITTLE_ENDIAN_BITFIELD)\n\tunsigned ea1:\t1;\n\tunsigned cr:\t1;\n\tunsigned dlcih:\t6;\n\n\tunsigned ea2:\t1;\n\tunsigned de:\t1;\n\tunsigned becn:\t1;\n\tunsigned fecn:\t1;\n\tunsigned dlcil:\t4;\n#else\n\tunsigned dlcih:\t6;\n\tunsigned cr:\t1;\n\tunsigned ea1:\t1;\n\n\tunsigned dlcil:\t4;\n\tunsigned fecn:\t1;\n\tunsigned becn:\t1;\n\tunsigned de:\t1;\n\tunsigned ea2:\t1;\n#endif\n}__packed fr_hdr;\n\n\ntypedef struct pvc_device_struct {\n\tstruct net_device *frad;\n\tstruct net_device *main;\n\tstruct net_device *ether;\t/* bridged Ethernet interface\t*/\n\tstruct pvc_device_struct *next;\t/* Sorted in ascending DLCI order */\n\tint dlci;\n\tint open_count;\n\n\tstruct {\n\t\tunsigned int new: 1;\n\t\tunsigned int active: 1;\n\t\tunsigned int exist: 1;\n\t\tunsigned int deleted: 1;\n\t\tunsigned int fecn: 1;\n\t\tunsigned int becn: 1;\n\t\tunsigned int bandwidth;\t/* Cisco LMI reporting only */\n\t}state;\n}pvc_device;\n\nstruct frad_state {\n\tfr_proto settings;\n\tpvc_device *first_pvc;\n\tint dce_pvc_count;\n\n\tstruct timer_list timer;\n\tunsigned long last_poll;\n\tint reliable;\n\tint dce_changed;\n\tint request;\n\tint fullrep_sent;\n\tu32 last_errors; /* last errors bit list */\n\tu8 n391cnt;\n\tu8 txseq; /* TX sequence number */\n\tu8 rxseq; /* RX sequence number */\n};\n\n\nstatic int fr_ioctl(struct net_device *dev, struct ifreq *ifr);\n\n\nstatic inline u16 q922_to_dlci(u8 *hdr)\n{\n\treturn ((hdr[0] & 0xFC) << 2) | ((hdr[1] & 0xF0) >> 4);\n}\n\n\nstatic inline void dlci_to_q922(u8 *hdr, u16 dlci)\n{\n\thdr[0] = (dlci >> 2) & 0xFC;\n\thdr[1] = ((dlci << 4) & 0xF0) | 0x01;\n}\n\n\nstatic inline struct frad_state* state(hdlc_device *hdlc)\n{\n\treturn(struct frad_state *)(hdlc->state);\n}\n\n\nstatic inline pvc_device* find_pvc(hdlc_device *hdlc, u16 dlci)\n{\n\tpvc_device *pvc = state(hdlc)->first_pvc;\n\n\twhile (pvc) {\n\t\tif (pvc->dlci == dlci)\n\t\t\treturn pvc;\n\t\tif (pvc->dlci > dlci)\n\t\t\treturn NULL; /* the list is sorted */\n\t\tpvc = pvc->next;\n\t}\n\n\treturn NULL;\n}\n\n\nstatic pvc_device* add_pvc(struct net_device *dev, u16 dlci)\n{\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\tpvc_device *pvc, **pvc_p = &state(hdlc)->first_pvc;\n\n\twhile (*pvc_p) {\n\t\tif ((*pvc_p)->dlci == dlci)\n\t\t\treturn *pvc_p;\n\t\tif ((*pvc_p)->dlci > dlci)\n\t\t\tbreak;\t/* the list is sorted */\n\t\tpvc_p = &(*pvc_p)->next;\n\t}\n\n\tpvc = kzalloc(sizeof(pvc_device), GFP_ATOMIC);\n#ifdef DEBUG_PVC\n\tprintk(KERN_DEBUG \"add_pvc: allocated pvc %p, frad %p\\n\", pvc, dev);\n#endif\n\tif (!pvc)\n\t\treturn NULL;\n\n\tpvc->dlci = dlci;\n\tpvc->frad = dev;\n\tpvc->next = *pvc_p;\t/* Put it in the chain */\n\t*pvc_p = pvc;\n\treturn pvc;\n}\n\n\nstatic inline int pvc_is_used(pvc_device *pvc)\n{\n\treturn pvc->main || pvc->ether;\n}\n\n\nstatic inline void pvc_carrier(int on, pvc_device *pvc)\n{\n\tif (on) {\n\t\tif (pvc->main)\n\t\t\tif (!netif_carrier_ok(pvc->main))\n\t\t\t\tnetif_carrier_on(pvc->main);\n\t\tif (pvc->ether)\n\t\t\tif (!netif_carrier_ok(pvc->ether))\n\t\t\t\tnetif_carrier_on(pvc->ether);\n\t} else {\n\t\tif (pvc->main)\n\t\t\tif (netif_carrier_ok(pvc->main))\n\t\t\t\tnetif_carrier_off(pvc->main);\n\t\tif (pvc->ether)\n\t\t\tif (netif_carrier_ok(pvc->ether))\n\t\t\t\tnetif_carrier_off(pvc->ether);\n\t}\n}\n\n\nstatic inline void delete_unused_pvcs(hdlc_device *hdlc)\n{\n\tpvc_device **pvc_p = &state(hdlc)->first_pvc;\n\n\twhile (*pvc_p) {\n\t\tif (!pvc_is_used(*pvc_p)) {\n\t\t\tpvc_device *pvc = *pvc_p;\n#ifdef DEBUG_PVC\n\t\t\tprintk(KERN_DEBUG \"freeing unused pvc: %p\\n\", pvc);\n#endif\n\t\t\t*pvc_p = pvc->next;\n\t\t\tkfree(pvc);\n\t\t\tcontinue;\n\t\t}\n\t\tpvc_p = &(*pvc_p)->next;\n\t}\n}\n\n\nstatic inline struct net_device** get_dev_p(pvc_device *pvc, int type)\n{\n\tif (type == ARPHRD_ETHER)\n\t\treturn &pvc->ether;\n\telse\n\t\treturn &pvc->main;\n}\n\n\nstatic int fr_hard_header(struct sk_buff **skb_p, u16 dlci)\n{\n\tu16 head_len;\n\tstruct sk_buff *skb = *skb_p;\n\n\tswitch (skb->protocol) {\n\tcase cpu_to_be16(NLPID_CCITT_ANSI_LMI):\n\t\thead_len = 4;\n\t\tskb_push(skb, head_len);\n\t\tskb->data[3] = NLPID_CCITT_ANSI_LMI;\n\t\tbreak;\n\n\tcase cpu_to_be16(NLPID_CISCO_LMI):\n\t\thead_len = 4;\n\t\tskb_push(skb, head_len);\n\t\tskb->data[3] = NLPID_CISCO_LMI;\n\t\tbreak;\n\n\tcase cpu_to_be16(ETH_P_IP):\n\t\thead_len = 4;\n\t\tskb_push(skb, head_len);\n\t\tskb->data[3] = NLPID_IP;\n\t\tbreak;\n\n\tcase cpu_to_be16(ETH_P_IPV6):\n\t\thead_len = 4;\n\t\tskb_push(skb, head_len);\n\t\tskb->data[3] = NLPID_IPV6;\n\t\tbreak;\n\n\tcase cpu_to_be16(ETH_P_802_3):\n\t\thead_len = 10;\n\t\tif (skb_headroom(skb) < head_len) {\n\t\t\tstruct sk_buff *skb2 = skb_realloc_headroom(skb,\n\t\t\t\t\t\t\t\t    head_len);\n\t\t\tif (!skb2)\n\t\t\t\treturn -ENOBUFS;\n\t\t\tdev_kfree_skb(skb);\n\t\t\tskb = *skb_p = skb2;\n\t\t}\n\t\tskb_push(skb, head_len);\n\t\tskb->data[3] = FR_PAD;\n\t\tskb->data[4] = NLPID_SNAP;\n\t\tskb->data[5] = FR_PAD;\n\t\tskb->data[6] = 0x80;\n\t\tskb->data[7] = 0xC2;\n\t\tskb->data[8] = 0x00;\n\t\tskb->data[9] = 0x07; /* bridged Ethernet frame w/out FCS */\n\t\tbreak;\n\n\tdefault:\n\t\thead_len = 10;\n\t\tskb_push(skb, head_len);\n\t\tskb->data[3] = FR_PAD;\n\t\tskb->data[4] = NLPID_SNAP;\n\t\tskb->data[5] = FR_PAD;\n\t\tskb->data[6] = FR_PAD;\n\t\tskb->data[7] = FR_PAD;\n\t\t*(__be16*)(skb->data + 8) = skb->protocol;\n\t}\n\n\tdlci_to_q922(skb->data, dlci);\n\tskb->data[2] = FR_UI;\n\treturn 0;\n}\n\n\n\nstatic int pvc_open(struct net_device *dev)\n{\n\tpvc_device *pvc = dev->ml_priv;\n\n\tif ((pvc->frad->flags & IFF_UP) == 0)\n\t\treturn -EIO;  /* Frad must be UP in order to activate PVC */\n\n\tif (pvc->open_count++ == 0) {\n\t\thdlc_device *hdlc = dev_to_hdlc(pvc->frad);\n\t\tif (state(hdlc)->settings.lmi == LMI_NONE)\n\t\t\tpvc->state.active = netif_carrier_ok(pvc->frad);\n\n\t\tpvc_carrier(pvc->state.active, pvc);\n\t\tstate(hdlc)->dce_changed = 1;\n\t}\n\treturn 0;\n}\n\n\n\nstatic int pvc_close(struct net_device *dev)\n{\n\tpvc_device *pvc = dev->ml_priv;\n\n\tif (--pvc->open_count == 0) {\n\t\thdlc_device *hdlc = dev_to_hdlc(pvc->frad);\n\t\tif (state(hdlc)->settings.lmi == LMI_NONE)\n\t\t\tpvc->state.active = 0;\n\n\t\tif (state(hdlc)->settings.dce) {\n\t\t\tstate(hdlc)->dce_changed = 1;\n\t\t\tpvc->state.active = 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n\nstatic int pvc_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tpvc_device *pvc = dev->ml_priv;\n\tfr_proto_pvc_info info;\n\n\tif (ifr->ifr_settings.type == IF_GET_PROTO) {\n\t\tif (dev->type == ARPHRD_ETHER)\n\t\t\tifr->ifr_settings.type = IF_PROTO_FR_ETH_PVC;\n\t\telse\n\t\t\tifr->ifr_settings.type = IF_PROTO_FR_PVC;\n\n\t\tif (ifr->ifr_settings.size < sizeof(info)) {\n\t\t\t/* data size wanted */\n\t\t\tifr->ifr_settings.size = sizeof(info);\n\t\t\treturn -ENOBUFS;\n\t\t}\n\n\t\tinfo.dlci = pvc->dlci;\n\t\tmemcpy(info.master, pvc->frad->name, IFNAMSIZ);\n\t\tif (copy_to_user(ifr->ifr_settings.ifs_ifsu.fr_pvc_info,\n\t\t\t\t &info, sizeof(info)))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\t}\n\n\treturn -EINVAL;\n}\n\nstatic netdev_tx_t pvc_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tpvc_device *pvc = dev->ml_priv;\n\n\tif (pvc->state.active) {\n\t\tif (dev->type == ARPHRD_ETHER) {\n\t\t\tint pad = ETH_ZLEN - skb->len;\n\t\t\tif (pad > 0) { /* Pad the frame with zeros */\n\t\t\t\tint len = skb->len;\n\t\t\t\tif (skb_tailroom(skb) < pad)\n\t\t\t\t\tif (pskb_expand_head(skb, 0, pad,\n\t\t\t\t\t\t\t     GFP_ATOMIC)) {\n\t\t\t\t\t\tdev->stats.tx_dropped++;\n\t\t\t\t\t\tdev_kfree_skb(skb);\n\t\t\t\t\t\treturn NETDEV_TX_OK;\n\t\t\t\t\t}\n\t\t\t\tskb_put(skb, pad);\n\t\t\t\tmemset(skb->data + len, 0, pad);\n\t\t\t}\n\t\t\tskb->protocol = cpu_to_be16(ETH_P_802_3);\n\t\t}\n\t\tif (!fr_hard_header(&skb, pvc->dlci)) {\n\t\t\tdev->stats.tx_bytes += skb->len;\n\t\t\tdev->stats.tx_packets++;\n\t\t\tif (pvc->state.fecn) /* TX Congestion counter */\n\t\t\t\tdev->stats.tx_compressed++;\n\t\t\tskb->dev = pvc->frad;\n\t\t\tdev_queue_xmit(skb);\n\t\t\treturn NETDEV_TX_OK;\n\t\t}\n\t}\n\n\tdev->stats.tx_dropped++;\n\tdev_kfree_skb(skb);\n\treturn NETDEV_TX_OK;\n}\n\nstatic inline void fr_log_dlci_active(pvc_device *pvc)\n{\n\tnetdev_info(pvc->frad, \"DLCI %d [%s%s%s]%s %s\\n\",\n\t\t    pvc->dlci,\n\t\t    pvc->main ? pvc->main->name : \"\",\n\t\t    pvc->main && pvc->ether ? \" \" : \"\",\n\t\t    pvc->ether ? pvc->ether->name : \"\",\n\t\t    pvc->state.new ? \" new\" : \"\",\n\t\t    !pvc->state.exist ? \"deleted\" :\n\t\t    pvc->state.active ? \"active\" : \"inactive\");\n}\n\n\n\nstatic inline u8 fr_lmi_nextseq(u8 x)\n{\n\tx++;\n\treturn x ? x : 1;\n}\n\n\nstatic void fr_lmi_send(struct net_device *dev, int fullrep)\n{\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\tstruct sk_buff *skb;\n\tpvc_device *pvc = state(hdlc)->first_pvc;\n\tint lmi = state(hdlc)->settings.lmi;\n\tint dce = state(hdlc)->settings.dce;\n\tint len = lmi == LMI_ANSI ? LMI_ANSI_LENGTH : LMI_CCITT_CISCO_LENGTH;\n\tint stat_len = (lmi == LMI_CISCO) ? 6 : 3;\n\tu8 *data;\n\tint i = 0;\n\n\tif (dce && fullrep) {\n\t\tlen += state(hdlc)->dce_pvc_count * (2 + stat_len);\n\t\tif (len > HDLC_MAX_MRU) {\n\t\t\tnetdev_warn(dev, \"Too many PVCs while sending LMI full report\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n\n\tskb = dev_alloc_skb(len);\n\tif (!skb) {\n\t\tnetdev_warn(dev, \"Memory squeeze on fr_lmi_send()\\n\");\n\t\treturn;\n\t}\n\tmemset(skb->data, 0, len);\n\tskb_reserve(skb, 4);\n\tif (lmi == LMI_CISCO) {\n\t\tskb->protocol = cpu_to_be16(NLPID_CISCO_LMI);\n\t\tfr_hard_header(&skb, LMI_CISCO_DLCI);\n\t} else {\n\t\tskb->protocol = cpu_to_be16(NLPID_CCITT_ANSI_LMI);\n\t\tfr_hard_header(&skb, LMI_CCITT_ANSI_DLCI);\n\t}\n\tdata = skb_tail_pointer(skb);\n\tdata[i++] = LMI_CALLREF;\n\tdata[i++] = dce ? LMI_STATUS : LMI_STATUS_ENQUIRY;\n\tif (lmi == LMI_ANSI)\n\t\tdata[i++] = LMI_ANSI_LOCKSHIFT;\n\tdata[i++] = lmi == LMI_CCITT ? LMI_CCITT_REPTYPE :\n\t\tLMI_ANSI_CISCO_REPTYPE;\n\tdata[i++] = LMI_REPT_LEN;\n\tdata[i++] = fullrep ? LMI_FULLREP : LMI_INTEGRITY;\n\tdata[i++] = lmi == LMI_CCITT ? LMI_CCITT_ALIVE : LMI_ANSI_CISCO_ALIVE;\n\tdata[i++] = LMI_INTEG_LEN;\n\tdata[i++] = state(hdlc)->txseq =\n\t\tfr_lmi_nextseq(state(hdlc)->txseq);\n\tdata[i++] = state(hdlc)->rxseq;\n\n\tif (dce && fullrep) {\n\t\twhile (pvc) {\n\t\t\tdata[i++] = lmi == LMI_CCITT ? LMI_CCITT_PVCSTAT :\n\t\t\t\tLMI_ANSI_CISCO_PVCSTAT;\n\t\t\tdata[i++] = stat_len;\n\n\t\t\t/* LMI start/restart */\n\t\t\tif (state(hdlc)->reliable && !pvc->state.exist) {\n\t\t\t\tpvc->state.exist = pvc->state.new = 1;\n\t\t\t\tfr_log_dlci_active(pvc);\n\t\t\t}\n\n\t\t\t/* ifconfig PVC up */\n\t\t\tif (pvc->open_count && !pvc->state.active &&\n\t\t\t    pvc->state.exist && !pvc->state.new) {\n\t\t\t\tpvc_carrier(1, pvc);\n\t\t\t\tpvc->state.active = 1;\n\t\t\t\tfr_log_dlci_active(pvc);\n\t\t\t}\n\n\t\t\tif (lmi == LMI_CISCO) {\n\t\t\t\tdata[i] = pvc->dlci >> 8;\n\t\t\t\tdata[i + 1] = pvc->dlci & 0xFF;\n\t\t\t} else {\n\t\t\t\tdata[i] = (pvc->dlci >> 4) & 0x3F;\n\t\t\t\tdata[i + 1] = ((pvc->dlci << 3) & 0x78) | 0x80;\n\t\t\t\tdata[i + 2] = 0x80;\n\t\t\t}\n\n\t\t\tif (pvc->state.new)\n\t\t\t\tdata[i + 2] |= 0x08;\n\t\t\telse if (pvc->state.active)\n\t\t\t\tdata[i + 2] |= 0x02;\n\n\t\t\ti += stat_len;\n\t\t\tpvc = pvc->next;\n\t\t}\n\t}\n\n\tskb_put(skb, i);\n\tskb->priority = TC_PRIO_CONTROL;\n\tskb->dev = dev;\n\tskb_reset_network_header(skb);\n\n\tdev_queue_xmit(skb);\n}\n\n\n\nstatic void fr_set_link_state(int reliable, struct net_device *dev)\n{\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\tpvc_device *pvc = state(hdlc)->first_pvc;\n\n\tstate(hdlc)->reliable = reliable;\n\tif (reliable) {\n\t\tnetif_dormant_off(dev);\n\t\tstate(hdlc)->n391cnt = 0; /* Request full status */\n\t\tstate(hdlc)->dce_changed = 1;\n\n\t\tif (state(hdlc)->settings.lmi == LMI_NONE) {\n\t\t\twhile (pvc) {\t/* Activate all PVCs */\n\t\t\t\tpvc_carrier(1, pvc);\n\t\t\t\tpvc->state.exist = pvc->state.active = 1;\n\t\t\t\tpvc->state.new = 0;\n\t\t\t\tpvc = pvc->next;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tnetif_dormant_on(dev);\n\t\twhile (pvc) {\t\t/* Deactivate all PVCs */\n\t\t\tpvc_carrier(0, pvc);\n\t\t\tpvc->state.exist = pvc->state.active = 0;\n\t\t\tpvc->state.new = 0;\n\t\t\tif (!state(hdlc)->settings.dce)\n\t\t\t\tpvc->state.bandwidth = 0;\n\t\t\tpvc = pvc->next;\n\t\t}\n\t}\n}\n\n\nstatic void fr_timer(unsigned long arg)\n{\n\tstruct net_device *dev = (struct net_device *)arg;\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\tint i, cnt = 0, reliable;\n\tu32 list;\n\n\tif (state(hdlc)->settings.dce) {\n\t\treliable = state(hdlc)->request &&\n\t\t\ttime_before(jiffies, state(hdlc)->last_poll +\n\t\t\t\t    state(hdlc)->settings.t392 * HZ);\n\t\tstate(hdlc)->request = 0;\n\t} else {\n\t\tstate(hdlc)->last_errors <<= 1; /* Shift the list */\n\t\tif (state(hdlc)->request) {\n\t\t\tif (state(hdlc)->reliable)\n\t\t\t\tnetdev_info(dev, \"No LMI status reply received\\n\");\n\t\t\tstate(hdlc)->last_errors |= 1;\n\t\t}\n\n\t\tlist = state(hdlc)->last_errors;\n\t\tfor (i = 0; i < state(hdlc)->settings.n393; i++, list >>= 1)\n\t\t\tcnt += (list & 1);\t/* errors count */\n\n\t\treliable = (cnt < state(hdlc)->settings.n392);\n\t}\n\n\tif (state(hdlc)->reliable != reliable) {\n\t\tnetdev_info(dev, \"Link %sreliable\\n\", reliable ? \"\" : \"un\");\n\t\tfr_set_link_state(reliable, dev);\n\t}\n\n\tif (state(hdlc)->settings.dce)\n\t\tstate(hdlc)->timer.expires = jiffies +\n\t\t\tstate(hdlc)->settings.t392 * HZ;\n\telse {\n\t\tif (state(hdlc)->n391cnt)\n\t\t\tstate(hdlc)->n391cnt--;\n\n\t\tfr_lmi_send(dev, state(hdlc)->n391cnt == 0);\n\n\t\tstate(hdlc)->last_poll = jiffies;\n\t\tstate(hdlc)->request = 1;\n\t\tstate(hdlc)->timer.expires = jiffies +\n\t\t\tstate(hdlc)->settings.t391 * HZ;\n\t}\n\n\tstate(hdlc)->timer.function = fr_timer;\n\tstate(hdlc)->timer.data = arg;\n\tadd_timer(&state(hdlc)->timer);\n}\n\n\nstatic int fr_lmi_recv(struct net_device *dev, struct sk_buff *skb)\n{\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\tpvc_device *pvc;\n\tu8 rxseq, txseq;\n\tint lmi = state(hdlc)->settings.lmi;\n\tint dce = state(hdlc)->settings.dce;\n\tint stat_len = (lmi == LMI_CISCO) ? 6 : 3, reptype, error, no_ram, i;\n\n\tif (skb->len < (lmi == LMI_ANSI ? LMI_ANSI_LENGTH :\n\t\t\tLMI_CCITT_CISCO_LENGTH)) {\n\t\tnetdev_info(dev, \"Short LMI frame\\n\");\n\t\treturn 1;\n\t}\n\n\tif (skb->data[3] != (lmi == LMI_CISCO ? NLPID_CISCO_LMI :\n\t\t\t     NLPID_CCITT_ANSI_LMI)) {\n\t\tnetdev_info(dev, \"Received non-LMI frame with LMI DLCI\\n\");\n\t\treturn 1;\n\t}\n\n\tif (skb->data[4] != LMI_CALLREF) {\n\t\tnetdev_info(dev, \"Invalid LMI Call reference (0x%02X)\\n\",\n\t\t\t    skb->data[4]);\n\t\treturn 1;\n\t}\n\n\tif (skb->data[5] != (dce ? LMI_STATUS_ENQUIRY : LMI_STATUS)) {\n\t\tnetdev_info(dev, \"Invalid LMI Message type (0x%02X)\\n\",\n\t\t\t    skb->data[5]);\n\t\treturn 1;\n\t}\n\n\tif (lmi == LMI_ANSI) {\n\t\tif (skb->data[6] != LMI_ANSI_LOCKSHIFT) {\n\t\t\tnetdev_info(dev, \"Not ANSI locking shift in LMI message (0x%02X)\\n\",\n\t\t\t\t    skb->data[6]);\n\t\t\treturn 1;\n\t\t}\n\t\ti = 7;\n\t} else\n\t\ti = 6;\n\n\tif (skb->data[i] != (lmi == LMI_CCITT ? LMI_CCITT_REPTYPE :\n\t\t\t     LMI_ANSI_CISCO_REPTYPE)) {\n\t\tnetdev_info(dev, \"Not an LMI Report type IE (0x%02X)\\n\",\n\t\t\t    skb->data[i]);\n\t\treturn 1;\n\t}\n\n\tif (skb->data[++i] != LMI_REPT_LEN) {\n\t\tnetdev_info(dev, \"Invalid LMI Report type IE length (%u)\\n\",\n\t\t\t    skb->data[i]);\n\t\treturn 1;\n\t}\n\n\treptype = skb->data[++i];\n\tif (reptype != LMI_INTEGRITY && reptype != LMI_FULLREP) {\n\t\tnetdev_info(dev, \"Unsupported LMI Report type (0x%02X)\\n\",\n\t\t\t    reptype);\n\t\treturn 1;\n\t}\n\n\tif (skb->data[++i] != (lmi == LMI_CCITT ? LMI_CCITT_ALIVE :\n\t\t\t       LMI_ANSI_CISCO_ALIVE)) {\n\t\tnetdev_info(dev, \"Not an LMI Link integrity verification IE (0x%02X)\\n\",\n\t\t\t    skb->data[i]);\n\t\treturn 1;\n\t}\n\n\tif (skb->data[++i] != LMI_INTEG_LEN) {\n\t\tnetdev_info(dev, \"Invalid LMI Link integrity verification IE length (%u)\\n\",\n\t\t\t    skb->data[i]);\n\t\treturn 1;\n\t}\n\ti++;\n\n\tstate(hdlc)->rxseq = skb->data[i++]; /* TX sequence from peer */\n\trxseq = skb->data[i++];\t/* Should confirm our sequence */\n\n\ttxseq = state(hdlc)->txseq;\n\n\tif (dce)\n\t\tstate(hdlc)->last_poll = jiffies;\n\n\terror = 0;\n\tif (!state(hdlc)->reliable)\n\t\terror = 1;\n\n\tif (rxseq == 0 || rxseq != txseq) { /* Ask for full report next time */\n\t\tstate(hdlc)->n391cnt = 0;\n\t\terror = 1;\n\t}\n\n\tif (dce) {\n\t\tif (state(hdlc)->fullrep_sent && !error) {\n/* Stop sending full report - the last one has been confirmed by DTE */\n\t\t\tstate(hdlc)->fullrep_sent = 0;\n\t\t\tpvc = state(hdlc)->first_pvc;\n\t\t\twhile (pvc) {\n\t\t\t\tif (pvc->state.new) {\n\t\t\t\t\tpvc->state.new = 0;\n\n/* Tell DTE that new PVC is now active */\n\t\t\t\t\tstate(hdlc)->dce_changed = 1;\n\t\t\t\t}\n\t\t\t\tpvc = pvc->next;\n\t\t\t}\n\t\t}\n\n\t\tif (state(hdlc)->dce_changed) {\n\t\t\treptype = LMI_FULLREP;\n\t\t\tstate(hdlc)->fullrep_sent = 1;\n\t\t\tstate(hdlc)->dce_changed = 0;\n\t\t}\n\n\t\tstate(hdlc)->request = 1; /* got request */\n\t\tfr_lmi_send(dev, reptype == LMI_FULLREP ? 1 : 0);\n\t\treturn 0;\n\t}\n\n\t/* DTE */\n\n\tstate(hdlc)->request = 0; /* got response, no request pending */\n\n\tif (error)\n\t\treturn 0;\n\n\tif (reptype != LMI_FULLREP)\n\t\treturn 0;\n\n\tpvc = state(hdlc)->first_pvc;\n\n\twhile (pvc) {\n\t\tpvc->state.deleted = 1;\n\t\tpvc = pvc->next;\n\t}\n\n\tno_ram = 0;\n\twhile (skb->len >= i + 2 + stat_len) {\n\t\tu16 dlci;\n\t\tu32 bw;\n\t\tunsigned int active, new;\n\n\t\tif (skb->data[i] != (lmi == LMI_CCITT ? LMI_CCITT_PVCSTAT :\n\t\t\t\t       LMI_ANSI_CISCO_PVCSTAT)) {\n\t\t\tnetdev_info(dev, \"Not an LMI PVC status IE (0x%02X)\\n\",\n\t\t\t\t    skb->data[i]);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (skb->data[++i] != stat_len) {\n\t\t\tnetdev_info(dev, \"Invalid LMI PVC status IE length (%u)\\n\",\n\t\t\t\t    skb->data[i]);\n\t\t\treturn 1;\n\t\t}\n\t\ti++;\n\n\t\tnew = !! (skb->data[i + 2] & 0x08);\n\t\tactive = !! (skb->data[i + 2] & 0x02);\n\t\tif (lmi == LMI_CISCO) {\n\t\t\tdlci = (skb->data[i] << 8) | skb->data[i + 1];\n\t\t\tbw = (skb->data[i + 3] << 16) |\n\t\t\t\t(skb->data[i + 4] << 8) |\n\t\t\t\t(skb->data[i + 5]);\n\t\t} else {\n\t\t\tdlci = ((skb->data[i] & 0x3F) << 4) |\n\t\t\t\t((skb->data[i + 1] & 0x78) >> 3);\n\t\t\tbw = 0;\n\t\t}\n\n\t\tpvc = add_pvc(dev, dlci);\n\n\t\tif (!pvc && !no_ram) {\n\t\t\tnetdev_warn(dev, \"Memory squeeze on fr_lmi_recv()\\n\");\n\t\t\tno_ram = 1;\n\t\t}\n\n\t\tif (pvc) {\n\t\t\tpvc->state.exist = 1;\n\t\t\tpvc->state.deleted = 0;\n\t\t\tif (active != pvc->state.active ||\n\t\t\t    new != pvc->state.new ||\n\t\t\t    bw != pvc->state.bandwidth ||\n\t\t\t    !pvc->state.exist) {\n\t\t\t\tpvc->state.new = new;\n\t\t\t\tpvc->state.active = active;\n\t\t\t\tpvc->state.bandwidth = bw;\n\t\t\t\tpvc_carrier(active, pvc);\n\t\t\t\tfr_log_dlci_active(pvc);\n\t\t\t}\n\t\t}\n\n\t\ti += stat_len;\n\t}\n\n\tpvc = state(hdlc)->first_pvc;\n\n\twhile (pvc) {\n\t\tif (pvc->state.deleted && pvc->state.exist) {\n\t\t\tpvc_carrier(0, pvc);\n\t\t\tpvc->state.active = pvc->state.new = 0;\n\t\t\tpvc->state.exist = 0;\n\t\t\tpvc->state.bandwidth = 0;\n\t\t\tfr_log_dlci_active(pvc);\n\t\t}\n\t\tpvc = pvc->next;\n\t}\n\n\t/* Next full report after N391 polls */\n\tstate(hdlc)->n391cnt = state(hdlc)->settings.n391;\n\n\treturn 0;\n}\n\n\nstatic int fr_rx(struct sk_buff *skb)\n{\n\tstruct net_device *frad = skb->dev;\n\thdlc_device *hdlc = dev_to_hdlc(frad);\n\tfr_hdr *fh = (fr_hdr*)skb->data;\n\tu8 *data = skb->data;\n\tu16 dlci;\n\tpvc_device *pvc;\n\tstruct net_device *dev = NULL;\n\n\tif (skb->len <= 4 || fh->ea1 || data[2] != FR_UI)\n\t\tgoto rx_error;\n\n\tdlci = q922_to_dlci(skb->data);\n\n\tif ((dlci == LMI_CCITT_ANSI_DLCI &&\n\t     (state(hdlc)->settings.lmi == LMI_ANSI ||\n\t      state(hdlc)->settings.lmi == LMI_CCITT)) ||\n\t    (dlci == LMI_CISCO_DLCI &&\n\t     state(hdlc)->settings.lmi == LMI_CISCO)) {\n\t\tif (fr_lmi_recv(frad, skb))\n\t\t\tgoto rx_error;\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NET_RX_SUCCESS;\n\t}\n\n\tpvc = find_pvc(hdlc, dlci);\n\tif (!pvc) {\n#ifdef DEBUG_PKT\n\t\tnetdev_info(frad, \"No PVC for received frame's DLCI %d\\n\",\n\t\t\t    dlci);\n#endif\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NET_RX_DROP;\n\t}\n\n\tif (pvc->state.fecn != fh->fecn) {\n#ifdef DEBUG_ECN\n\t\tprintk(KERN_DEBUG \"%s: DLCI %d FECN O%s\\n\", frad->name,\n\t\t       dlci, fh->fecn ? \"N\" : \"FF\");\n#endif\n\t\tpvc->state.fecn ^= 1;\n\t}\n\n\tif (pvc->state.becn != fh->becn) {\n#ifdef DEBUG_ECN\n\t\tprintk(KERN_DEBUG \"%s: DLCI %d BECN O%s\\n\", frad->name,\n\t\t       dlci, fh->becn ? \"N\" : \"FF\");\n#endif\n\t\tpvc->state.becn ^= 1;\n\t}\n\n\n\tif ((skb = skb_share_check(skb, GFP_ATOMIC)) == NULL) {\n\t\tfrad->stats.rx_dropped++;\n\t\treturn NET_RX_DROP;\n\t}\n\n\tif (data[3] == NLPID_IP) {\n\t\tskb_pull(skb, 4); /* Remove 4-byte header (hdr, UI, NLPID) */\n\t\tdev = pvc->main;\n\t\tskb->protocol = htons(ETH_P_IP);\n\n\t} else if (data[3] == NLPID_IPV6) {\n\t\tskb_pull(skb, 4); /* Remove 4-byte header (hdr, UI, NLPID) */\n\t\tdev = pvc->main;\n\t\tskb->protocol = htons(ETH_P_IPV6);\n\n\t} else if (skb->len > 10 && data[3] == FR_PAD &&\n\t\t   data[4] == NLPID_SNAP && data[5] == FR_PAD) {\n\t\tu16 oui = ntohs(*(__be16*)(data + 6));\n\t\tu16 pid = ntohs(*(__be16*)(data + 8));\n\t\tskb_pull(skb, 10);\n\n\t\tswitch ((((u32)oui) << 16) | pid) {\n\t\tcase ETH_P_ARP: /* routed frame with SNAP */\n\t\tcase ETH_P_IPX:\n\t\tcase ETH_P_IP:\t/* a long variant */\n\t\tcase ETH_P_IPV6:\n\t\t\tdev = pvc->main;\n\t\t\tskb->protocol = htons(pid);\n\t\t\tbreak;\n\n\t\tcase 0x80C20007: /* bridged Ethernet frame */\n\t\t\tif ((dev = pvc->ether) != NULL)\n\t\t\t\tskb->protocol = eth_type_trans(skb, dev);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tnetdev_info(frad, \"Unsupported protocol, OUI=%x PID=%x\\n\",\n\t\t\t\t    oui, pid);\n\t\t\tdev_kfree_skb_any(skb);\n\t\t\treturn NET_RX_DROP;\n\t\t}\n\t} else {\n\t\tnetdev_info(frad, \"Unsupported protocol, NLPID=%x length=%i\\n\",\n\t\t\t    data[3], skb->len);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NET_RX_DROP;\n\t}\n\n\tif (dev) {\n\t\tdev->stats.rx_packets++; /* PVC traffic */\n\t\tdev->stats.rx_bytes += skb->len;\n\t\tif (pvc->state.becn)\n\t\t\tdev->stats.rx_compressed++;\n\t\tskb->dev = dev;\n\t\tnetif_rx(skb);\n\t\treturn NET_RX_SUCCESS;\n\t} else {\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NET_RX_DROP;\n\t}\n\n rx_error:\n\tfrad->stats.rx_errors++; /* Mark error */\n\tdev_kfree_skb_any(skb);\n\treturn NET_RX_DROP;\n}\n\n\n\nstatic void fr_start(struct net_device *dev)\n{\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n#ifdef DEBUG_LINK\n\tprintk(KERN_DEBUG \"fr_start\\n\");\n#endif\n\tif (state(hdlc)->settings.lmi != LMI_NONE) {\n\t\tstate(hdlc)->reliable = 0;\n\t\tstate(hdlc)->dce_changed = 1;\n\t\tstate(hdlc)->request = 0;\n\t\tstate(hdlc)->fullrep_sent = 0;\n\t\tstate(hdlc)->last_errors = 0xFFFFFFFF;\n\t\tstate(hdlc)->n391cnt = 0;\n\t\tstate(hdlc)->txseq = state(hdlc)->rxseq = 0;\n\n\t\tinit_timer(&state(hdlc)->timer);\n\t\t/* First poll after 1 s */\n\t\tstate(hdlc)->timer.expires = jiffies + HZ;\n\t\tstate(hdlc)->timer.function = fr_timer;\n\t\tstate(hdlc)->timer.data = (unsigned long)dev;\n\t\tadd_timer(&state(hdlc)->timer);\n\t} else\n\t\tfr_set_link_state(1, dev);\n}\n\n\nstatic void fr_stop(struct net_device *dev)\n{\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n#ifdef DEBUG_LINK\n\tprintk(KERN_DEBUG \"fr_stop\\n\");\n#endif\n\tif (state(hdlc)->settings.lmi != LMI_NONE)\n\t\tdel_timer_sync(&state(hdlc)->timer);\n\tfr_set_link_state(0, dev);\n}\n\n\nstatic void fr_close(struct net_device *dev)\n{\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\tpvc_device *pvc = state(hdlc)->first_pvc;\n\n\twhile (pvc) {\t\t/* Shutdown all PVCs for this FRAD */\n\t\tif (pvc->main)\n\t\t\tdev_close(pvc->main);\n\t\tif (pvc->ether)\n\t\t\tdev_close(pvc->ether);\n\t\tpvc = pvc->next;\n\t}\n}\n\n\nstatic void pvc_setup(struct net_device *dev)\n{\n\tdev->type = ARPHRD_DLCI;\n\tdev->flags = IFF_POINTOPOINT;\n\tdev->hard_header_len = 10;\n\tdev->addr_len = 2;\n\tdev->priv_flags &= ~IFF_XMIT_DST_RELEASE;\n}\n\nstatic const struct net_device_ops pvc_ops = {\n\t.ndo_open       = pvc_open,\n\t.ndo_stop       = pvc_close,\n\t.ndo_change_mtu = hdlc_change_mtu,\n\t.ndo_start_xmit = pvc_xmit,\n\t.ndo_do_ioctl   = pvc_ioctl,\n};\n\nstatic int fr_add_pvc(struct net_device *frad, unsigned int dlci, int type)\n{\n\thdlc_device *hdlc = dev_to_hdlc(frad);\n\tpvc_device *pvc;\n\tstruct net_device *dev;\n\tint used;\n\n\tif ((pvc = add_pvc(frad, dlci)) == NULL) {\n\t\tnetdev_warn(frad, \"Memory squeeze on fr_add_pvc()\\n\");\n\t\treturn -ENOBUFS;\n\t}\n\n\tif (*get_dev_p(pvc, type))\n\t\treturn -EEXIST;\n\n\tused = pvc_is_used(pvc);\n\n\tif (type == ARPHRD_ETHER) {\n\t\tdev = alloc_netdev(0, \"pvceth%d\", ether_setup);\n\t\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\t} else\n\t\tdev = alloc_netdev(0, \"pvc%d\", pvc_setup);\n\n\tif (!dev) {\n\t\tnetdev_warn(frad, \"Memory squeeze on fr_pvc()\\n\");\n\t\tdelete_unused_pvcs(hdlc);\n\t\treturn -ENOBUFS;\n\t}\n\n\tif (type == ARPHRD_ETHER)\n\t\trandom_ether_addr(dev->dev_addr);\n\telse {\n\t\t*(__be16*)dev->dev_addr = htons(dlci);\n\t\tdlci_to_q922(dev->broadcast, dlci);\n\t}\n\tdev->netdev_ops = &pvc_ops;\n\tdev->mtu = HDLC_MAX_MTU;\n\tdev->tx_queue_len = 0;\n\tdev->ml_priv = pvc;\n\n\tif (register_netdevice(dev) != 0) {\n\t\tfree_netdev(dev);\n\t\tdelete_unused_pvcs(hdlc);\n\t\treturn -EIO;\n\t}\n\n\tdev->destructor = free_netdev;\n\t*get_dev_p(pvc, type) = dev;\n\tif (!used) {\n\t\tstate(hdlc)->dce_changed = 1;\n\t\tstate(hdlc)->dce_pvc_count++;\n\t}\n\treturn 0;\n}\n\n\n\nstatic int fr_del_pvc(hdlc_device *hdlc, unsigned int dlci, int type)\n{\n\tpvc_device *pvc;\n\tstruct net_device *dev;\n\n\tif ((pvc = find_pvc(hdlc, dlci)) == NULL)\n\t\treturn -ENOENT;\n\n\tif ((dev = *get_dev_p(pvc, type)) == NULL)\n\t\treturn -ENOENT;\n\n\tif (dev->flags & IFF_UP)\n\t\treturn -EBUSY;\t\t/* PVC in use */\n\n\tunregister_netdevice(dev); /* the destructor will free_netdev(dev) */\n\t*get_dev_p(pvc, type) = NULL;\n\n\tif (!pvc_is_used(pvc)) {\n\t\tstate(hdlc)->dce_pvc_count--;\n\t\tstate(hdlc)->dce_changed = 1;\n\t}\n\tdelete_unused_pvcs(hdlc);\n\treturn 0;\n}\n\n\n\nstatic void fr_destroy(struct net_device *frad)\n{\n\thdlc_device *hdlc = dev_to_hdlc(frad);\n\tpvc_device *pvc = state(hdlc)->first_pvc;\n\tstate(hdlc)->first_pvc = NULL; /* All PVCs destroyed */\n\tstate(hdlc)->dce_pvc_count = 0;\n\tstate(hdlc)->dce_changed = 1;\n\n\twhile (pvc) {\n\t\tpvc_device *next = pvc->next;\n\t\t/* destructors will free_netdev() main and ether */\n\t\tif (pvc->main)\n\t\t\tunregister_netdevice(pvc->main);\n\n\t\tif (pvc->ether)\n\t\t\tunregister_netdevice(pvc->ether);\n\n\t\tkfree(pvc);\n\t\tpvc = next;\n\t}\n}\n\n\nstatic struct hdlc_proto proto = {\n\t.close\t\t= fr_close,\n\t.start\t\t= fr_start,\n\t.stop\t\t= fr_stop,\n\t.detach\t\t= fr_destroy,\n\t.ioctl\t\t= fr_ioctl,\n\t.netif_rx\t= fr_rx,\n\t.module\t\t= THIS_MODULE,\n};\n\n\nstatic int fr_ioctl(struct net_device *dev, struct ifreq *ifr)\n{\n\tfr_proto __user *fr_s = ifr->ifr_settings.ifs_ifsu.fr;\n\tconst size_t size = sizeof(fr_proto);\n\tfr_proto new_settings;\n\thdlc_device *hdlc = dev_to_hdlc(dev);\n\tfr_proto_pvc pvc;\n\tint result;\n\n\tswitch (ifr->ifr_settings.type) {\n\tcase IF_GET_PROTO:\n\t\tif (dev_to_hdlc(dev)->proto != &proto) /* Different proto */\n\t\t\treturn -EINVAL;\n\t\tifr->ifr_settings.type = IF_PROTO_FR;\n\t\tif (ifr->ifr_settings.size < size) {\n\t\t\tifr->ifr_settings.size = size; /* data size wanted */\n\t\t\treturn -ENOBUFS;\n\t\t}\n\t\tif (copy_to_user(fr_s, &state(hdlc)->settings, size))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\n\tcase IF_PROTO_FR:\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (dev->flags & IFF_UP)\n\t\t\treturn -EBUSY;\n\n\t\tif (copy_from_user(&new_settings, fr_s, size))\n\t\t\treturn -EFAULT;\n\n\t\tif (new_settings.lmi == LMI_DEFAULT)\n\t\t\tnew_settings.lmi = LMI_ANSI;\n\n\t\tif ((new_settings.lmi != LMI_NONE &&\n\t\t     new_settings.lmi != LMI_ANSI &&\n\t\t     new_settings.lmi != LMI_CCITT &&\n\t\t     new_settings.lmi != LMI_CISCO) ||\n\t\t    new_settings.t391 < 1 ||\n\t\t    new_settings.t392 < 2 ||\n\t\t    new_settings.n391 < 1 ||\n\t\t    new_settings.n392 < 1 ||\n\t\t    new_settings.n393 < new_settings.n392 ||\n\t\t    new_settings.n393 > 32 ||\n\t\t    (new_settings.dce != 0 &&\n\t\t     new_settings.dce != 1))\n\t\t\treturn -EINVAL;\n\n\t\tresult=hdlc->attach(dev, ENCODING_NRZ,PARITY_CRC16_PR1_CCITT);\n\t\tif (result)\n\t\t\treturn result;\n\n\t\tif (dev_to_hdlc(dev)->proto != &proto) { /* Different proto */\n\t\t\tresult = attach_hdlc_protocol(dev, &proto,\n\t\t\t\t\t\t      sizeof(struct frad_state));\n\t\t\tif (result)\n\t\t\t\treturn result;\n\t\t\tstate(hdlc)->first_pvc = NULL;\n\t\t\tstate(hdlc)->dce_pvc_count = 0;\n\t\t}\n\t\tmemcpy(&state(hdlc)->settings, &new_settings, size);\n\t\tdev->type = ARPHRD_FRAD;\n\t\treturn 0;\n\n\tcase IF_PROTO_FR_ADD_PVC:\n\tcase IF_PROTO_FR_DEL_PVC:\n\tcase IF_PROTO_FR_ADD_ETH_PVC:\n\tcase IF_PROTO_FR_DEL_ETH_PVC:\n\t\tif (dev_to_hdlc(dev)->proto != &proto) /* Different proto */\n\t\t\treturn -EINVAL;\n\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (copy_from_user(&pvc, ifr->ifr_settings.ifs_ifsu.fr_pvc,\n\t\t\t\t   sizeof(fr_proto_pvc)))\n\t\t\treturn -EFAULT;\n\n\t\tif (pvc.dlci <= 0 || pvc.dlci >= 1024)\n\t\t\treturn -EINVAL;\t/* Only 10 bits, DLCI 0 reserved */\n\n\t\tif (ifr->ifr_settings.type == IF_PROTO_FR_ADD_ETH_PVC ||\n\t\t    ifr->ifr_settings.type == IF_PROTO_FR_DEL_ETH_PVC)\n\t\t\tresult = ARPHRD_ETHER; /* bridged Ethernet device */\n\t\telse\n\t\t\tresult = ARPHRD_DLCI;\n\n\t\tif (ifr->ifr_settings.type == IF_PROTO_FR_ADD_PVC ||\n\t\t    ifr->ifr_settings.type == IF_PROTO_FR_ADD_ETH_PVC)\n\t\t\treturn fr_add_pvc(dev, pvc.dlci, result);\n\t\telse\n\t\t\treturn fr_del_pvc(hdlc, pvc.dlci, result);\n\t}\n\n\treturn -EINVAL;\n}\n\n\nstatic int __init mod_init(void)\n{\n\tregister_hdlc_protocol(&proto);\n\treturn 0;\n}\n\n\nstatic void __exit mod_exit(void)\n{\n\tunregister_hdlc_protocol(&proto);\n}\n\n\nmodule_init(mod_init);\nmodule_exit(mod_exit);\n\nMODULE_AUTHOR(\"Krzysztof Halasa <khc@pm.waw.pl>\");\nMODULE_DESCRIPTION(\"Frame-Relay protocol support for generic HDLC\");\nMODULE_LICENSE(\"GPL v2\");\n", "/*======================================================================\n\n    Aironet driver for 4500 and 4800 series cards\n\n    This code is released under both the GPL version 2 and BSD licenses.\n    Either license may be used.  The respective licenses are found at\n    the end of this file.\n\n    This code was developed by Benjamin Reed <breed@users.sourceforge.net>\n    including portions of which come from the Aironet PC4500\n    Developer's Reference Manual and used with permission.  Copyright\n    (C) 1999 Benjamin Reed.  All Rights Reserved.  Permission to use\n    code in the Developer's manual was granted for this driver by\n    Aironet.  Major code contributions were received from Javier Achirica\n    <achirica@users.sourceforge.net> and Jean Tourrilhes <jt@hpl.hp.com>.\n    Code was also integrated from the Cisco Aironet driver for Linux.\n    Support for MPI350 cards was added by Fabrice Bellet\n    <fabrice@bellet.info>.\n\n======================================================================*/\n\n#include <linux/err.h>\n#include <linux/init.h>\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/proc_fs.h>\n\n#include <linux/sched.h>\n#include <linux/ptrace.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/timer.h>\n#include <linux/interrupt.h>\n#include <linux/in.h>\n#include <linux/bitops.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <asm/io.h>\n#include <asm/system.h>\n#include <asm/unaligned.h>\n\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/if_arp.h>\n#include <linux/ioport.h>\n#include <linux/pci.h>\n#include <asm/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n\n#include <linux/ieee80211.h>\n#include <net/iw_handler.h>\n\n#include \"airo.h\"\n\n#define DRV_NAME \"airo\"\n\n#ifdef CONFIG_PCI\nstatic DEFINE_PCI_DEVICE_TABLE(card_ids) = {\n\t{ 0x14b9, 1, PCI_ANY_ID, PCI_ANY_ID, },\n\t{ 0x14b9, 0x4500, PCI_ANY_ID, PCI_ANY_ID },\n\t{ 0x14b9, 0x4800, PCI_ANY_ID, PCI_ANY_ID, },\n\t{ 0x14b9, 0x0340, PCI_ANY_ID, PCI_ANY_ID, },\n\t{ 0x14b9, 0x0350, PCI_ANY_ID, PCI_ANY_ID, },\n\t{ 0x14b9, 0x5000, PCI_ANY_ID, PCI_ANY_ID, },\n\t{ 0x14b9, 0xa504, PCI_ANY_ID, PCI_ANY_ID, },\n\t{ 0, }\n};\nMODULE_DEVICE_TABLE(pci, card_ids);\n\nstatic int airo_pci_probe(struct pci_dev *, const struct pci_device_id *);\nstatic void airo_pci_remove(struct pci_dev *);\nstatic int airo_pci_suspend(struct pci_dev *pdev, pm_message_t state);\nstatic int airo_pci_resume(struct pci_dev *pdev);\n\nstatic struct pci_driver airo_driver = {\n\t.name     = DRV_NAME,\n\t.id_table = card_ids,\n\t.probe    = airo_pci_probe,\n\t.remove   = __devexit_p(airo_pci_remove),\n\t.suspend  = airo_pci_suspend,\n\t.resume   = airo_pci_resume,\n};\n#endif /* CONFIG_PCI */\n\n/* Include Wireless Extension definition and check version - Jean II */\n#include <linux/wireless.h>\n#define WIRELESS_SPY\t\t/* enable iwspy support */\n#include <net/iw_handler.h>\t/* New driver API */\n\n#define CISCO_EXT\t\t/* enable Cisco extensions */\n#ifdef CISCO_EXT\n#include <linux/delay.h>\n#endif\n\n/* Hack to do some power saving */\n#define POWER_ON_DOWN\n\n/* As you can see this list is HUGH!\n   I really don't know what a lot of these counts are about, but they\n   are all here for completeness.  If the IGNLABEL macro is put in\n   infront of the label, that statistic will not be included in the list\n   of statistics in the /proc filesystem */\n\n#define IGNLABEL(comment) NULL\nstatic const char *statsLabels[] = {\n\t\"RxOverrun\",\n\tIGNLABEL(\"RxPlcpCrcErr\"),\n\tIGNLABEL(\"RxPlcpFormatErr\"),\n\tIGNLABEL(\"RxPlcpLengthErr\"),\n\t\"RxMacCrcErr\",\n\t\"RxMacCrcOk\",\n\t\"RxWepErr\",\n\t\"RxWepOk\",\n\t\"RetryLong\",\n\t\"RetryShort\",\n\t\"MaxRetries\",\n\t\"NoAck\",\n\t\"NoCts\",\n\t\"RxAck\",\n\t\"RxCts\",\n\t\"TxAck\",\n\t\"TxRts\",\n\t\"TxCts\",\n\t\"TxMc\",\n\t\"TxBc\",\n\t\"TxUcFrags\",\n\t\"TxUcPackets\",\n\t\"TxBeacon\",\n\t\"RxBeacon\",\n\t\"TxSinColl\",\n\t\"TxMulColl\",\n\t\"DefersNo\",\n\t\"DefersProt\",\n\t\"DefersEngy\",\n\t\"DupFram\",\n\t\"RxFragDisc\",\n\t\"TxAged\",\n\t\"RxAged\",\n\t\"LostSync-MaxRetry\",\n\t\"LostSync-MissedBeacons\",\n\t\"LostSync-ArlExceeded\",\n\t\"LostSync-Deauth\",\n\t\"LostSync-Disassoced\",\n\t\"LostSync-TsfTiming\",\n\t\"HostTxMc\",\n\t\"HostTxBc\",\n\t\"HostTxUc\",\n\t\"HostTxFail\",\n\t\"HostRxMc\",\n\t\"HostRxBc\",\n\t\"HostRxUc\",\n\t\"HostRxDiscard\",\n\tIGNLABEL(\"HmacTxMc\"),\n\tIGNLABEL(\"HmacTxBc\"),\n\tIGNLABEL(\"HmacTxUc\"),\n\tIGNLABEL(\"HmacTxFail\"),\n\tIGNLABEL(\"HmacRxMc\"),\n\tIGNLABEL(\"HmacRxBc\"),\n\tIGNLABEL(\"HmacRxUc\"),\n\tIGNLABEL(\"HmacRxDiscard\"),\n\tIGNLABEL(\"HmacRxAccepted\"),\n\t\"SsidMismatch\",\n\t\"ApMismatch\",\n\t\"RatesMismatch\",\n\t\"AuthReject\",\n\t\"AuthTimeout\",\n\t\"AssocReject\",\n\t\"AssocTimeout\",\n\tIGNLABEL(\"ReasonOutsideTable\"),\n\tIGNLABEL(\"ReasonStatus1\"),\n\tIGNLABEL(\"ReasonStatus2\"),\n\tIGNLABEL(\"ReasonStatus3\"),\n\tIGNLABEL(\"ReasonStatus4\"),\n\tIGNLABEL(\"ReasonStatus5\"),\n\tIGNLABEL(\"ReasonStatus6\"),\n\tIGNLABEL(\"ReasonStatus7\"),\n\tIGNLABEL(\"ReasonStatus8\"),\n\tIGNLABEL(\"ReasonStatus9\"),\n\tIGNLABEL(\"ReasonStatus10\"),\n\tIGNLABEL(\"ReasonStatus11\"),\n\tIGNLABEL(\"ReasonStatus12\"),\n\tIGNLABEL(\"ReasonStatus13\"),\n\tIGNLABEL(\"ReasonStatus14\"),\n\tIGNLABEL(\"ReasonStatus15\"),\n\tIGNLABEL(\"ReasonStatus16\"),\n\tIGNLABEL(\"ReasonStatus17\"),\n\tIGNLABEL(\"ReasonStatus18\"),\n\tIGNLABEL(\"ReasonStatus19\"),\n\t\"RxMan\",\n\t\"TxMan\",\n\t\"RxRefresh\",\n\t\"TxRefresh\",\n\t\"RxPoll\",\n\t\"TxPoll\",\n\t\"HostRetries\",\n\t\"LostSync-HostReq\",\n\t\"HostTxBytes\",\n\t\"HostRxBytes\",\n\t\"ElapsedUsec\",\n\t\"ElapsedSec\",\n\t\"LostSyncBetterAP\",\n\t\"PrivacyMismatch\",\n\t\"Jammed\",\n\t\"DiscRxNotWepped\",\n\t\"PhyEleMismatch\",\n\t(char*)-1 };\n#ifndef RUN_AT\n#define RUN_AT(x) (jiffies+(x))\n#endif\n\n\n/* These variables are for insmod, since it seems that the rates\n   can only be set in setup_card.  Rates should be a comma separated\n   (no spaces) list of rates (up to 8). */\n\nstatic int rates[8];\nstatic char *ssids[3];\n\nstatic int io[4];\nstatic int irq[4];\n\nstatic\nint maxencrypt /* = 0 */; /* The highest rate that the card can encrypt at.\n\t\t       0 means no limit.  For old cards this was 4 */\n\nstatic int auto_wep /* = 0 */; /* If set, it tries to figure out the wep mode */\nstatic int aux_bap /* = 0 */; /* Checks to see if the aux ports are needed to read\n\t\t    the bap, needed on some older cards and buses. */\nstatic int adhoc;\n\nstatic int probe = 1;\n\nstatic int proc_uid /* = 0 */;\n\nstatic int proc_gid /* = 0 */;\n\nstatic int airo_perm = 0555;\n\nstatic int proc_perm = 0644;\n\nMODULE_AUTHOR(\"Benjamin Reed\");\nMODULE_DESCRIPTION(\"Support for Cisco/Aironet 802.11 wireless ethernet cards.  \"\n\t\t   \"Direct support for ISA/PCI/MPI cards and support for PCMCIA when used with airo_cs.\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_SUPPORTED_DEVICE(\"Aironet 4500, 4800 and Cisco 340/350\");\nmodule_param_array(io, int, NULL, 0);\nmodule_param_array(irq, int, NULL, 0);\nmodule_param_array(rates, int, NULL, 0);\nmodule_param_array(ssids, charp, NULL, 0);\nmodule_param(auto_wep, int, 0);\nMODULE_PARM_DESC(auto_wep,\n\t\t \"If non-zero, the driver will keep looping through the authentication options until an association is made.  \"\n\t\t \"The value of auto_wep is number of the wep keys to check.  \"\n\t\t \"A value of 2 will try using the key at index 0 and index 1.\");\nmodule_param(aux_bap, int, 0);\nMODULE_PARM_DESC(aux_bap,\n\t\t \"If non-zero, the driver will switch into a mode that seems to work better for older cards with some older buses.  \"\n\t\t \"Before switching it checks that the switch is needed.\");\nmodule_param(maxencrypt, int, 0);\nMODULE_PARM_DESC(maxencrypt,\n\t\t \"The maximum speed that the card can do encryption.  \"\n\t\t \"Units are in 512kbs.  \"\n\t\t \"Zero (default) means there is no limit.  \"\n\t\t \"Older cards used to be limited to 2mbs (4).\");\nmodule_param(adhoc, int, 0);\nMODULE_PARM_DESC(adhoc, \"If non-zero, the card will start in adhoc mode.\");\nmodule_param(probe, int, 0);\nMODULE_PARM_DESC(probe, \"If zero, the driver won't start the card.\");\n\nmodule_param(proc_uid, int, 0);\nMODULE_PARM_DESC(proc_uid, \"The uid that the /proc files will belong to.\");\nmodule_param(proc_gid, int, 0);\nMODULE_PARM_DESC(proc_gid, \"The gid that the /proc files will belong to.\");\nmodule_param(airo_perm, int, 0);\nMODULE_PARM_DESC(airo_perm, \"The permission bits of /proc/[driver/]aironet.\");\nmodule_param(proc_perm, int, 0);\nMODULE_PARM_DESC(proc_perm, \"The permission bits of the files in /proc\");\n\n/* This is a kind of sloppy hack to get this information to OUT4500 and\n   IN4500.  I would be extremely interested in the situation where this\n   doesn't work though!!! */\nstatic int do8bitIO /* = 0 */;\n\n/* Return codes */\n#define SUCCESS 0\n#define ERROR -1\n#define NO_PACKET -2\n\n/* Commands */\n#define NOP2\t\t0x0000\n#define MAC_ENABLE\t0x0001\n#define MAC_DISABLE\t0x0002\n#define CMD_LOSE_SYNC\t0x0003 /* Not sure what this does... */\n#define CMD_SOFTRESET\t0x0004\n#define HOSTSLEEP\t0x0005\n#define CMD_MAGIC_PKT\t0x0006\n#define CMD_SETWAKEMASK\t0x0007\n#define CMD_READCFG\t0x0008\n#define CMD_SETMODE\t0x0009\n#define CMD_ALLOCATETX\t0x000a\n#define CMD_TRANSMIT\t0x000b\n#define CMD_DEALLOCATETX 0x000c\n#define NOP\t\t0x0010\n#define CMD_WORKAROUND\t0x0011\n#define CMD_ALLOCATEAUX 0x0020\n#define CMD_ACCESS\t0x0021\n#define CMD_PCIBAP\t0x0022\n#define CMD_PCIAUX\t0x0023\n#define CMD_ALLOCBUF\t0x0028\n#define CMD_GETTLV\t0x0029\n#define CMD_PUTTLV\t0x002a\n#define CMD_DELTLV\t0x002b\n#define CMD_FINDNEXTTLV\t0x002c\n#define CMD_PSPNODES\t0x0030\n#define CMD_SETCW\t0x0031    \n#define CMD_SETPCF\t0x0032    \n#define CMD_SETPHYREG\t0x003e\n#define CMD_TXTEST\t0x003f\n#define MAC_ENABLETX\t0x0101\n#define CMD_LISTBSS\t0x0103\n#define CMD_SAVECFG\t0x0108\n#define CMD_ENABLEAUX\t0x0111\n#define CMD_WRITERID\t0x0121\n#define CMD_USEPSPNODES\t0x0130\n#define MAC_ENABLERX\t0x0201\n\n/* Command errors */\n#define ERROR_QUALIF 0x00\n#define ERROR_ILLCMD 0x01\n#define ERROR_ILLFMT 0x02\n#define ERROR_INVFID 0x03\n#define ERROR_INVRID 0x04\n#define ERROR_LARGE 0x05\n#define ERROR_NDISABL 0x06\n#define ERROR_ALLOCBSY 0x07\n#define ERROR_NORD 0x0B\n#define ERROR_NOWR 0x0C\n#define ERROR_INVFIDTX 0x0D\n#define ERROR_TESTACT 0x0E\n#define ERROR_TAGNFND 0x12\n#define ERROR_DECODE 0x20\n#define ERROR_DESCUNAV 0x21\n#define ERROR_BADLEN 0x22\n#define ERROR_MODE 0x80\n#define ERROR_HOP 0x81\n#define ERROR_BINTER 0x82\n#define ERROR_RXMODE 0x83\n#define ERROR_MACADDR 0x84\n#define ERROR_RATES 0x85\n#define ERROR_ORDER 0x86\n#define ERROR_SCAN 0x87\n#define ERROR_AUTH 0x88\n#define ERROR_PSMODE 0x89\n#define ERROR_RTYPE 0x8A\n#define ERROR_DIVER 0x8B\n#define ERROR_SSID 0x8C\n#define ERROR_APLIST 0x8D\n#define ERROR_AUTOWAKE 0x8E\n#define ERROR_LEAP 0x8F\n\n/* Registers */\n#define COMMAND 0x00\n#define PARAM0 0x02\n#define PARAM1 0x04\n#define PARAM2 0x06\n#define STATUS 0x08\n#define RESP0 0x0a\n#define RESP1 0x0c\n#define RESP2 0x0e\n#define LINKSTAT 0x10\n#define SELECT0 0x18\n#define OFFSET0 0x1c\n#define RXFID 0x20\n#define TXALLOCFID 0x22\n#define TXCOMPLFID 0x24\n#define DATA0 0x36\n#define EVSTAT 0x30\n#define EVINTEN 0x32\n#define EVACK 0x34\n#define SWS0 0x28\n#define SWS1 0x2a\n#define SWS2 0x2c\n#define SWS3 0x2e\n#define AUXPAGE 0x3A\n#define AUXOFF 0x3C\n#define AUXDATA 0x3E\n\n#define FID_TX 1\n#define FID_RX 2\n/* Offset into aux memory for descriptors */\n#define AUX_OFFSET 0x800\n/* Size of allocated packets */\n#define PKTSIZE 1840\n#define RIDSIZE 2048\n/* Size of the transmit queue */\n#define MAXTXQ 64\n\n/* BAP selectors */\n#define BAP0 0 /* Used for receiving packets */\n#define BAP1 2 /* Used for xmiting packets and working with RIDS */\n\n/* Flags */\n#define COMMAND_BUSY 0x8000\n\n#define BAP_BUSY 0x8000\n#define BAP_ERR 0x4000\n#define BAP_DONE 0x2000\n\n#define PROMISC 0xffff\n#define NOPROMISC 0x0000\n\n#define EV_CMD 0x10\n#define EV_CLEARCOMMANDBUSY 0x4000\n#define EV_RX 0x01\n#define EV_TX 0x02\n#define EV_TXEXC 0x04\n#define EV_ALLOC 0x08\n#define EV_LINK 0x80\n#define EV_AWAKE 0x100\n#define EV_TXCPY 0x400\n#define EV_UNKNOWN 0x800\n#define EV_MIC 0x1000 /* Message Integrity Check Interrupt */\n#define EV_AWAKEN 0x2000\n#define STATUS_INTS (EV_AWAKE|EV_LINK|EV_TXEXC|EV_TX|EV_TXCPY|EV_RX|EV_MIC)\n\n#ifdef CHECK_UNKNOWN_INTS\n#define IGNORE_INTS ( EV_CMD | EV_UNKNOWN)\n#else\n#define IGNORE_INTS (~STATUS_INTS)\n#endif\n\n/* RID TYPES */\n#define RID_RW 0x20\n\n/* The RIDs */\n#define RID_CAPABILITIES 0xFF00\n#define RID_APINFO     0xFF01\n#define RID_RADIOINFO  0xFF02\n#define RID_UNKNOWN3   0xFF03\n#define RID_RSSI       0xFF04\n#define RID_CONFIG     0xFF10\n#define RID_SSID       0xFF11\n#define RID_APLIST     0xFF12\n#define RID_DRVNAME    0xFF13\n#define RID_ETHERENCAP 0xFF14\n#define RID_WEP_TEMP   0xFF15\n#define RID_WEP_PERM   0xFF16\n#define RID_MODULATION 0xFF17\n#define RID_OPTIONS    0xFF18\n#define RID_ACTUALCONFIG 0xFF20 /*readonly*/\n#define RID_FACTORYCONFIG 0xFF21\n#define RID_UNKNOWN22  0xFF22\n#define RID_LEAPUSERNAME 0xFF23\n#define RID_LEAPPASSWORD 0xFF24\n#define RID_STATUS     0xFF50\n#define RID_BEACON_HST 0xFF51\n#define RID_BUSY_HST   0xFF52\n#define RID_RETRIES_HST 0xFF53\n#define RID_UNKNOWN54  0xFF54\n#define RID_UNKNOWN55  0xFF55\n#define RID_UNKNOWN56  0xFF56\n#define RID_MIC        0xFF57\n#define RID_STATS16    0xFF60\n#define RID_STATS16DELTA 0xFF61\n#define RID_STATS16DELTACLEAR 0xFF62\n#define RID_STATS      0xFF68\n#define RID_STATSDELTA 0xFF69\n#define RID_STATSDELTACLEAR 0xFF6A\n#define RID_ECHOTEST_RID 0xFF70\n#define RID_ECHOTEST_RESULTS 0xFF71\n#define RID_BSSLISTFIRST 0xFF72\n#define RID_BSSLISTNEXT  0xFF73\n#define RID_WPA_BSSLISTFIRST 0xFF74\n#define RID_WPA_BSSLISTNEXT  0xFF75\n\ntypedef struct {\n\tu16 cmd;\n\tu16 parm0;\n\tu16 parm1;\n\tu16 parm2;\n} Cmd;\n\ntypedef struct {\n\tu16 status;\n\tu16 rsp0;\n\tu16 rsp1;\n\tu16 rsp2;\n} Resp;\n\n/*\n * Rids and endian-ness:  The Rids will always be in cpu endian, since\n * this all the patches from the big-endian guys end up doing that.\n * so all rid access should use the read/writeXXXRid routines.\n */\n\n/* This structure came from an email sent to me from an engineer at\n   aironet for inclusion into this driver */\ntypedef struct WepKeyRid WepKeyRid;\nstruct WepKeyRid {\n\t__le16 len;\n\t__le16 kindex;\n\tu8 mac[ETH_ALEN];\n\t__le16 klen;\n\tu8 key[16];\n} __packed;\n\n/* These structures are from the Aironet's PC4500 Developers Manual */\ntypedef struct Ssid Ssid;\nstruct Ssid {\n\t__le16 len;\n\tu8 ssid[32];\n} __packed;\n\ntypedef struct SsidRid SsidRid;\nstruct SsidRid {\n\t__le16 len;\n\tSsid ssids[3];\n} __packed;\n\ntypedef struct ModulationRid ModulationRid;\nstruct ModulationRid {\n        __le16 len;\n        __le16 modulation;\n#define MOD_DEFAULT cpu_to_le16(0)\n#define MOD_CCK cpu_to_le16(1)\n#define MOD_MOK cpu_to_le16(2)\n} __packed;\n\ntypedef struct ConfigRid ConfigRid;\nstruct ConfigRid {\n\t__le16 len; /* sizeof(ConfigRid) */\n\t__le16 opmode; /* operating mode */\n#define MODE_STA_IBSS cpu_to_le16(0)\n#define MODE_STA_ESS cpu_to_le16(1)\n#define MODE_AP cpu_to_le16(2)\n#define MODE_AP_RPTR cpu_to_le16(3)\n#define MODE_CFG_MASK cpu_to_le16(0xff)\n#define MODE_ETHERNET_HOST cpu_to_le16(0<<8) /* rx payloads converted */\n#define MODE_LLC_HOST cpu_to_le16(1<<8) /* rx payloads left as is */\n#define MODE_AIRONET_EXTEND cpu_to_le16(1<<9) /* enable Aironet extenstions */\n#define MODE_AP_INTERFACE cpu_to_le16(1<<10) /* enable ap interface extensions */\n#define MODE_ANTENNA_ALIGN cpu_to_le16(1<<11) /* enable antenna alignment */\n#define MODE_ETHER_LLC cpu_to_le16(1<<12) /* enable ethernet LLC */\n#define MODE_LEAF_NODE cpu_to_le16(1<<13) /* enable leaf node bridge */\n#define MODE_CF_POLLABLE cpu_to_le16(1<<14) /* enable CF pollable */\n#define MODE_MIC cpu_to_le16(1<<15) /* enable MIC */\n\t__le16 rmode; /* receive mode */\n#define RXMODE_BC_MC_ADDR cpu_to_le16(0)\n#define RXMODE_BC_ADDR cpu_to_le16(1) /* ignore multicasts */\n#define RXMODE_ADDR cpu_to_le16(2) /* ignore multicast and broadcast */\n#define RXMODE_RFMON cpu_to_le16(3) /* wireless monitor mode */\n#define RXMODE_RFMON_ANYBSS cpu_to_le16(4)\n#define RXMODE_LANMON cpu_to_le16(5) /* lan style monitor -- data packets only */\n#define RXMODE_MASK cpu_to_le16(255)\n#define RXMODE_DISABLE_802_3_HEADER cpu_to_le16(1<<8) /* disables 802.3 header on rx */\n#define RXMODE_FULL_MASK (RXMODE_MASK | RXMODE_DISABLE_802_3_HEADER)\n#define RXMODE_NORMALIZED_RSSI cpu_to_le16(1<<9) /* return normalized RSSI */\n\t__le16 fragThresh;\n\t__le16 rtsThres;\n\tu8 macAddr[ETH_ALEN];\n\tu8 rates[8];\n\t__le16 shortRetryLimit;\n\t__le16 longRetryLimit;\n\t__le16 txLifetime; /* in kusec */\n\t__le16 rxLifetime; /* in kusec */\n\t__le16 stationary;\n\t__le16 ordering;\n\t__le16 u16deviceType; /* for overriding device type */\n\t__le16 cfpRate;\n\t__le16 cfpDuration;\n\t__le16 _reserved1[3];\n\t/*---------- Scanning/Associating ----------*/\n\t__le16 scanMode;\n#define SCANMODE_ACTIVE cpu_to_le16(0)\n#define SCANMODE_PASSIVE cpu_to_le16(1)\n#define SCANMODE_AIROSCAN cpu_to_le16(2)\n\t__le16 probeDelay; /* in kusec */\n\t__le16 probeEnergyTimeout; /* in kusec */\n        __le16 probeResponseTimeout;\n\t__le16 beaconListenTimeout;\n\t__le16 joinNetTimeout;\n\t__le16 authTimeout;\n\t__le16 authType;\n#define AUTH_OPEN cpu_to_le16(0x1)\n#define AUTH_ENCRYPT cpu_to_le16(0x101)\n#define AUTH_SHAREDKEY cpu_to_le16(0x102)\n#define AUTH_ALLOW_UNENCRYPTED cpu_to_le16(0x200)\n\t__le16 associationTimeout;\n\t__le16 specifiedApTimeout;\n\t__le16 offlineScanInterval;\n\t__le16 offlineScanDuration;\n\t__le16 linkLossDelay;\n\t__le16 maxBeaconLostTime;\n\t__le16 refreshInterval;\n#define DISABLE_REFRESH cpu_to_le16(0xFFFF)\n\t__le16 _reserved1a[1];\n\t/*---------- Power save operation ----------*/\n\t__le16 powerSaveMode;\n#define POWERSAVE_CAM cpu_to_le16(0)\n#define POWERSAVE_PSP cpu_to_le16(1)\n#define POWERSAVE_PSPCAM cpu_to_le16(2)\n\t__le16 sleepForDtims;\n\t__le16 listenInterval;\n\t__le16 fastListenInterval;\n\t__le16 listenDecay;\n\t__le16 fastListenDelay;\n\t__le16 _reserved2[2];\n\t/*---------- Ap/Ibss config items ----------*/\n\t__le16 beaconPeriod;\n\t__le16 atimDuration;\n\t__le16 hopPeriod;\n\t__le16 channelSet;\n\t__le16 channel;\n\t__le16 dtimPeriod;\n\t__le16 bridgeDistance;\n\t__le16 radioID;\n\t/*---------- Radio configuration ----------*/\n\t__le16 radioType;\n#define RADIOTYPE_DEFAULT cpu_to_le16(0)\n#define RADIOTYPE_802_11 cpu_to_le16(1)\n#define RADIOTYPE_LEGACY cpu_to_le16(2)\n\tu8 rxDiversity;\n\tu8 txDiversity;\n\t__le16 txPower;\n#define TXPOWER_DEFAULT 0\n\t__le16 rssiThreshold;\n#define RSSI_DEFAULT 0\n        __le16 modulation;\n#define PREAMBLE_AUTO cpu_to_le16(0)\n#define PREAMBLE_LONG cpu_to_le16(1)\n#define PREAMBLE_SHORT cpu_to_le16(2)\n\t__le16 preamble;\n\t__le16 homeProduct;\n\t__le16 radioSpecific;\n\t/*---------- Aironet Extensions ----------*/\n\tu8 nodeName[16];\n\t__le16 arlThreshold;\n\t__le16 arlDecay;\n\t__le16 arlDelay;\n\t__le16 _reserved4[1];\n\t/*---------- Aironet Extensions ----------*/\n\tu8 magicAction;\n#define MAGIC_ACTION_STSCHG 1\n#define MAGIC_ACTION_RESUME 2\n#define MAGIC_IGNORE_MCAST (1<<8)\n#define MAGIC_IGNORE_BCAST (1<<9)\n#define MAGIC_SWITCH_TO_PSP (0<<10)\n#define MAGIC_STAY_IN_CAM (1<<10)\n\tu8 magicControl;\n\t__le16 autoWake;\n} __packed;\n\ntypedef struct StatusRid StatusRid;\nstruct StatusRid {\n\t__le16 len;\n\tu8 mac[ETH_ALEN];\n\t__le16 mode;\n\t__le16 errorCode;\n\t__le16 sigQuality;\n\t__le16 SSIDlen;\n\tchar SSID[32];\n\tchar apName[16];\n\tu8 bssid[4][ETH_ALEN];\n\t__le16 beaconPeriod;\n\t__le16 dimPeriod;\n\t__le16 atimDuration;\n\t__le16 hopPeriod;\n\t__le16 channelSet;\n\t__le16 channel;\n\t__le16 hopsToBackbone;\n\t__le16 apTotalLoad;\n\t__le16 generatedLoad;\n\t__le16 accumulatedArl;\n\t__le16 signalQuality;\n\t__le16 currentXmitRate;\n\t__le16 apDevExtensions;\n\t__le16 normalizedSignalStrength;\n\t__le16 shortPreamble;\n\tu8 apIP[4];\n\tu8 noisePercent; /* Noise percent in last second */\n\tu8 noisedBm; /* Noise dBm in last second */\n\tu8 noiseAvePercent; /* Noise percent in last minute */\n\tu8 noiseAvedBm; /* Noise dBm in last minute */\n\tu8 noiseMaxPercent; /* Highest noise percent in last minute */\n\tu8 noiseMaxdBm; /* Highest noise dbm in last minute */\n\t__le16 load;\n\tu8 carrier[4];\n\t__le16 assocStatus;\n#define STAT_NOPACKETS 0\n#define STAT_NOCARRIERSET 10\n#define STAT_GOTCARRIERSET 11\n#define STAT_WRONGSSID 20\n#define STAT_BADCHANNEL 25\n#define STAT_BADBITRATES 30\n#define STAT_BADPRIVACY 35\n#define STAT_APFOUND 40\n#define STAT_APREJECTED 50\n#define STAT_AUTHENTICATING 60\n#define STAT_DEAUTHENTICATED 61\n#define STAT_AUTHTIMEOUT 62\n#define STAT_ASSOCIATING 70\n#define STAT_DEASSOCIATED 71\n#define STAT_ASSOCTIMEOUT 72\n#define STAT_NOTAIROAP 73\n#define STAT_ASSOCIATED 80\n#define STAT_LEAPING 90\n#define STAT_LEAPFAILED 91\n#define STAT_LEAPTIMEDOUT 92\n#define STAT_LEAPCOMPLETE 93\n} __packed;\n\ntypedef struct StatsRid StatsRid;\nstruct StatsRid {\n\t__le16 len;\n\t__le16 spacer;\n\t__le32 vals[100];\n} __packed;\n\ntypedef struct APListRid APListRid;\nstruct APListRid {\n\t__le16 len;\n\tu8 ap[4][ETH_ALEN];\n} __packed;\n\ntypedef struct CapabilityRid CapabilityRid;\nstruct CapabilityRid {\n\t__le16 len;\n\tchar oui[3];\n\tchar zero;\n\t__le16 prodNum;\n\tchar manName[32];\n\tchar prodName[16];\n\tchar prodVer[8];\n\tchar factoryAddr[ETH_ALEN];\n\tchar aironetAddr[ETH_ALEN];\n\t__le16 radioType;\n\t__le16 country;\n\tchar callid[ETH_ALEN];\n\tchar supportedRates[8];\n\tchar rxDiversity;\n\tchar txDiversity;\n\t__le16 txPowerLevels[8];\n\t__le16 hardVer;\n\t__le16 hardCap;\n\t__le16 tempRange;\n\t__le16 softVer;\n\t__le16 softSubVer;\n\t__le16 interfaceVer;\n\t__le16 softCap;\n\t__le16 bootBlockVer;\n\t__le16 requiredHard;\n\t__le16 extSoftCap;\n} __packed;\n\n/* Only present on firmware >= 5.30.17 */\ntypedef struct BSSListRidExtra BSSListRidExtra;\nstruct BSSListRidExtra {\n  __le16 unknown[4];\n  u8 fixed[12]; /* WLAN management frame */\n  u8 iep[624];\n} __packed;\n\ntypedef struct BSSListRid BSSListRid;\nstruct BSSListRid {\n  __le16 len;\n  __le16 index; /* First is 0 and 0xffff means end of list */\n#define RADIO_FH 1 /* Frequency hopping radio type */\n#define RADIO_DS 2 /* Direct sequence radio type */\n#define RADIO_TMA 4 /* Proprietary radio used in old cards (2500) */\n  __le16 radioType;\n  u8 bssid[ETH_ALEN]; /* Mac address of the BSS */\n  u8 zero;\n  u8 ssidLen;\n  u8 ssid[32];\n  __le16 dBm;\n#define CAP_ESS cpu_to_le16(1<<0)\n#define CAP_IBSS cpu_to_le16(1<<1)\n#define CAP_PRIVACY cpu_to_le16(1<<4)\n#define CAP_SHORTHDR cpu_to_le16(1<<5)\n  __le16 cap;\n  __le16 beaconInterval;\n  u8 rates[8]; /* Same as rates for config rid */\n  struct { /* For frequency hopping only */\n    __le16 dwell;\n    u8 hopSet;\n    u8 hopPattern;\n    u8 hopIndex;\n    u8 fill;\n  } fh;\n  __le16 dsChannel;\n  __le16 atimWindow;\n\n  /* Only present on firmware >= 5.30.17 */\n  BSSListRidExtra extra;\n} __packed;\n\ntypedef struct {\n  BSSListRid bss;\n  struct list_head list;\n} BSSListElement;\n\ntypedef struct tdsRssiEntry tdsRssiEntry;\nstruct tdsRssiEntry {\n  u8 rssipct;\n  u8 rssidBm;\n} __packed;\n\ntypedef struct tdsRssiRid tdsRssiRid;\nstruct tdsRssiRid {\n  u16 len;\n  tdsRssiEntry x[256];\n} __packed;\n\ntypedef struct MICRid MICRid;\nstruct MICRid {\n\t__le16 len;\n\t__le16 state;\n\t__le16 multicastValid;\n\tu8  multicast[16];\n\t__le16 unicastValid;\n\tu8  unicast[16];\n} __packed;\n\ntypedef struct MICBuffer MICBuffer;\nstruct MICBuffer {\n\t__be16 typelen;\n\n\tunion {\n\t    u8 snap[8];\n\t    struct {\n\t\tu8 dsap;\n\t\tu8 ssap;\n\t\tu8 control;\n\t\tu8 orgcode[3];\n\t\tu8 fieldtype[2];\n\t    } llc;\n\t} u;\n\t__be32 mic;\n\t__be32 seq;\n} __packed;\n\ntypedef struct {\n\tu8 da[ETH_ALEN];\n\tu8 sa[ETH_ALEN];\n} etherHead;\n\n#define TXCTL_TXOK (1<<1) /* report if tx is ok */\n#define TXCTL_TXEX (1<<2) /* report if tx fails */\n#define TXCTL_802_3 (0<<3) /* 802.3 packet */\n#define TXCTL_802_11 (1<<3) /* 802.11 mac packet */\n#define TXCTL_ETHERNET (0<<4) /* payload has ethertype */\n#define TXCTL_LLC (1<<4) /* payload is llc */\n#define TXCTL_RELEASE (0<<5) /* release after completion */\n#define TXCTL_NORELEASE (1<<5) /* on completion returns to host */\n\n#define BUSY_FID 0x10000\n\n#ifdef CISCO_EXT\n#define AIROMAGIC\t0xa55a\n/* Warning : SIOCDEVPRIVATE may disapear during 2.5.X - Jean II */\n#ifdef SIOCIWFIRSTPRIV\n#ifdef SIOCDEVPRIVATE\n#define AIROOLDIOCTL\tSIOCDEVPRIVATE\n#define AIROOLDIDIFC \tAIROOLDIOCTL + 1\n#endif /* SIOCDEVPRIVATE */\n#else /* SIOCIWFIRSTPRIV */\n#define SIOCIWFIRSTPRIV SIOCDEVPRIVATE\n#endif /* SIOCIWFIRSTPRIV */\n/* This may be wrong. When using the new SIOCIWFIRSTPRIV range, we probably\n * should use only \"GET\" ioctls (last bit set to 1). \"SET\" ioctls are root\n * only and don't return the modified struct ifreq to the application which\n * is usually a problem. - Jean II */\n#define AIROIOCTL\tSIOCIWFIRSTPRIV\n#define AIROIDIFC \tAIROIOCTL + 1\n\n/* Ioctl constants to be used in airo_ioctl.command */\n\n#define\tAIROGCAP  \t\t0\t// Capability rid\n#define AIROGCFG\t\t1       // USED A LOT\n#define AIROGSLIST\t\t2\t// System ID list\n#define AIROGVLIST\t\t3       // List of specified AP's\n#define AIROGDRVNAM\t\t4\t//  NOTUSED\n#define AIROGEHTENC\t\t5\t// NOTUSED\n#define AIROGWEPKTMP\t\t6\n#define AIROGWEPKNV\t\t7\n#define AIROGSTAT\t\t8\n#define AIROGSTATSC32\t\t9\n#define AIROGSTATSD32\t\t10\n#define AIROGMICRID\t\t11\n#define AIROGMICSTATS\t\t12\n#define AIROGFLAGS\t\t13\n#define AIROGID\t\t\t14\n#define AIRORRID\t\t15\n#define AIRORSWVERSION\t\t17\n\n/* Leave gap of 40 commands after AIROGSTATSD32 for future */\n\n#define AIROPCAP               \tAIROGSTATSD32 + 40\n#define AIROPVLIST              AIROPCAP      + 1\n#define AIROPSLIST\t\tAIROPVLIST    + 1\n#define AIROPCFG\t\tAIROPSLIST    + 1\n#define AIROPSIDS\t\tAIROPCFG      + 1\n#define AIROPAPLIST\t\tAIROPSIDS     + 1\n#define AIROPMACON\t\tAIROPAPLIST   + 1\t/* Enable mac  */\n#define AIROPMACOFF\t\tAIROPMACON    + 1 \t/* Disable mac */\n#define AIROPSTCLR\t\tAIROPMACOFF   + 1\n#define AIROPWEPKEY\t\tAIROPSTCLR    + 1\n#define AIROPWEPKEYNV\t\tAIROPWEPKEY   + 1\n#define AIROPLEAPPWD            AIROPWEPKEYNV + 1\n#define AIROPLEAPUSR            AIROPLEAPPWD  + 1\n\n/* Flash codes */\n\n#define AIROFLSHRST\t       AIROPWEPKEYNV  + 40\n#define AIROFLSHGCHR           AIROFLSHRST    + 1\n#define AIROFLSHSTFL           AIROFLSHGCHR   + 1\n#define AIROFLSHPCHR           AIROFLSHSTFL   + 1\n#define AIROFLPUTBUF           AIROFLSHPCHR   + 1\n#define AIRORESTART            AIROFLPUTBUF   + 1\n\n#define FLASHSIZE\t32768\n#define AUXMEMSIZE\t(256 * 1024)\n\ntypedef struct aironet_ioctl {\n\tunsigned short command;\t\t// What to do\n\tunsigned short len;\t\t// Len of data\n\tunsigned short ridnum;\t\t// rid number\n\tunsigned char __user *data;\t// d-data\n} aironet_ioctl;\n\nstatic const char swversion[] = \"2.1\";\n#endif /* CISCO_EXT */\n\n#define NUM_MODULES       2\n#define MIC_MSGLEN_MAX    2400\n#define EMMH32_MSGLEN_MAX MIC_MSGLEN_MAX\n#define AIRO_DEF_MTU      2312\n\ntypedef struct {\n\tu32   size;            // size\n\tu8    enabled;         // MIC enabled or not\n\tu32   rxSuccess;       // successful packets received\n\tu32   rxIncorrectMIC;  // pkts dropped due to incorrect MIC comparison\n\tu32   rxNotMICed;      // pkts dropped due to not being MIC'd\n\tu32   rxMICPlummed;    // pkts dropped due to not having a MIC plummed\n\tu32   rxWrongSequence; // pkts dropped due to sequence number violation\n\tu32   reserve[32];\n} mic_statistics;\n\ntypedef struct {\n\tu32 coeff[((EMMH32_MSGLEN_MAX)+3)>>2];\n\tu64 accum;\t// accumulated mic, reduced to u32 in final()\n\tint position;\t// current position (byte offset) in message\n\tunion {\n\t\tu8  d8[4];\n\t\t__be32 d32;\n\t} part;\t// saves partial message word across update() calls\n} emmh32_context;\n\ntypedef struct {\n\temmh32_context seed;\t    // Context - the seed\n\tu32\t\t rx;\t    // Received sequence number\n\tu32\t\t tx;\t    // Tx sequence number\n\tu32\t\t window;    // Start of window\n\tu8\t\t valid;\t    // Flag to say if context is valid or not\n\tu8\t\t key[16];\n} miccntx;\n\ntypedef struct {\n\tmiccntx mCtx;\t\t// Multicast context\n\tmiccntx uCtx;\t\t// Unicast context\n} mic_module;\n\ntypedef struct {\n\tunsigned int  rid: 16;\n\tunsigned int  len: 15;\n\tunsigned int  valid: 1;\n\tdma_addr_t host_addr;\n} Rid;\n\ntypedef struct {\n\tunsigned int  offset: 15;\n\tunsigned int  eoc: 1;\n\tunsigned int  len: 15;\n\tunsigned int  valid: 1;\n\tdma_addr_t host_addr;\n} TxFid;\n\nstruct rx_hdr {\n\t__le16 status, len;\n\tu8 rssi[2];\n\tu8 rate;\n\tu8 freq;\n\t__le16 tmp[4];\n} __packed;\n\ntypedef struct {\n\tunsigned int  ctl: 15;\n\tunsigned int  rdy: 1;\n\tunsigned int  len: 15;\n\tunsigned int  valid: 1;\n\tdma_addr_t host_addr;\n} RxFid;\n\n/*\n * Host receive descriptor\n */\ntypedef struct {\n\tunsigned char __iomem *card_ram_off; /* offset into card memory of the\n\t\t\t\t\t\tdesc */\n\tRxFid         rx_desc;\t\t     /* card receive descriptor */\n\tchar          *virtual_host_addr;    /* virtual address of host receive\n\t\t\t\t\t        buffer */\n\tint           pending;\n} HostRxDesc;\n\n/*\n * Host transmit descriptor\n */\ntypedef struct {\n\tunsigned char __iomem *card_ram_off;\t     /* offset into card memory of the\n\t\t\t\t\t\tdesc */\n\tTxFid         tx_desc;\t\t     /* card transmit descriptor */\n\tchar          *virtual_host_addr;    /* virtual address of host receive\n\t\t\t\t\t        buffer */\n\tint           pending;\n} HostTxDesc;\n\n/*\n * Host RID descriptor\n */\ntypedef struct {\n\tunsigned char __iomem *card_ram_off;      /* offset into card memory of the\n\t\t\t\t\t     descriptor */\n\tRid           rid_desc;\t\t  /* card RID descriptor */\n\tchar          *virtual_host_addr; /* virtual address of host receive\n\t\t\t\t\t     buffer */\n} HostRidDesc;\n\ntypedef struct {\n\tu16 sw0;\n\tu16 sw1;\n\tu16 status;\n\tu16 len;\n#define HOST_SET (1 << 0)\n#define HOST_INT_TX (1 << 1) /* Interrupt on successful TX */\n#define HOST_INT_TXERR (1 << 2) /* Interrupt on unseccessful TX */\n#define HOST_LCC_PAYLOAD (1 << 4) /* LLC payload, 0 = Ethertype */\n#define HOST_DONT_RLSE (1 << 5) /* Don't release buffer when done */\n#define HOST_DONT_RETRY (1 << 6) /* Don't retry trasmit */\n#define HOST_CLR_AID (1 << 7) /* clear AID failure */\n#define HOST_RTS (1 << 9) /* Force RTS use */\n#define HOST_SHORT (1 << 10) /* Do short preamble */\n\tu16 ctl;\n\tu16 aid;\n\tu16 retries;\n\tu16 fill;\n} TxCtlHdr;\n\ntypedef struct {\n        u16 ctl;\n        u16 duration;\n        char addr1[6];\n        char addr2[6];\n        char addr3[6];\n        u16 seq;\n        char addr4[6];\n} WifiHdr;\n\n\ntypedef struct {\n\tTxCtlHdr ctlhdr;\n\tu16 fill1;\n\tu16 fill2;\n\tWifiHdr wifihdr;\n\tu16 gaplen;\n\tu16 status;\n} WifiCtlHdr;\n\nstatic WifiCtlHdr wifictlhdr8023 = {\n\t.ctlhdr = {\n\t\t.ctl\t= HOST_DONT_RLSE,\n\t}\n};\n\n// A few details needed for WEP (Wireless Equivalent Privacy)\n#define MAX_KEY_SIZE 13\t\t\t// 128 (?) bits\n#define MIN_KEY_SIZE  5\t\t\t// 40 bits RC4 - WEP\ntypedef struct wep_key_t {\n\tu16\tlen;\n\tu8\tkey[16];\t/* 40-bit and 104-bit keys */\n} wep_key_t;\n\n/* List of Wireless Handlers (new API) */\nstatic const struct iw_handler_def\tairo_handler_def;\n\nstatic const char version[] = \"airo.c 0.6 (Ben Reed & Javier Achirica)\";\n\nstruct airo_info;\n\nstatic int get_dec_u16( char *buffer, int *start, int limit );\nstatic void OUT4500( struct airo_info *, u16 register, u16 value );\nstatic unsigned short IN4500( struct airo_info *, u16 register );\nstatic u16 setup_card(struct airo_info*, u8 *mac, int lock);\nstatic int enable_MAC(struct airo_info *ai, int lock);\nstatic void disable_MAC(struct airo_info *ai, int lock);\nstatic void enable_interrupts(struct airo_info*);\nstatic void disable_interrupts(struct airo_info*);\nstatic u16 issuecommand(struct airo_info*, Cmd *pCmd, Resp *pRsp);\nstatic int bap_setup(struct airo_info*, u16 rid, u16 offset, int whichbap);\nstatic int aux_bap_read(struct airo_info*, __le16 *pu16Dst, int bytelen,\n\t\t\tint whichbap);\nstatic int fast_bap_read(struct airo_info*, __le16 *pu16Dst, int bytelen,\n\t\t\t int whichbap);\nstatic int bap_write(struct airo_info*, const __le16 *pu16Src, int bytelen,\n\t\t     int whichbap);\nstatic int PC4500_accessrid(struct airo_info*, u16 rid, u16 accmd);\nstatic int PC4500_readrid(struct airo_info*, u16 rid, void *pBuf, int len, int lock);\nstatic int PC4500_writerid(struct airo_info*, u16 rid, const void\n\t\t\t   *pBuf, int len, int lock);\nstatic int do_writerid( struct airo_info*, u16 rid, const void *rid_data,\n\t\t\tint len, int dummy );\nstatic u16 transmit_allocate(struct airo_info*, int lenPayload, int raw);\nstatic int transmit_802_3_packet(struct airo_info*, int len, char *pPacket);\nstatic int transmit_802_11_packet(struct airo_info*, int len, char *pPacket);\n\nstatic int mpi_send_packet (struct net_device *dev);\nstatic void mpi_unmap_card(struct pci_dev *pci);\nstatic void mpi_receive_802_3(struct airo_info *ai);\nstatic void mpi_receive_802_11(struct airo_info *ai);\nstatic int waitbusy (struct airo_info *ai);\n\nstatic irqreturn_t airo_interrupt( int irq, void* dev_id);\nstatic int airo_thread(void *data);\nstatic void timer_func( struct net_device *dev );\nstatic int airo_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);\nstatic struct iw_statistics *airo_get_wireless_stats (struct net_device *dev);\nstatic void airo_read_wireless_stats (struct airo_info *local);\n#ifdef CISCO_EXT\nstatic int readrids(struct net_device *dev, aironet_ioctl *comp);\nstatic int writerids(struct net_device *dev, aironet_ioctl *comp);\nstatic int flashcard(struct net_device *dev, aironet_ioctl *comp);\n#endif /* CISCO_EXT */\nstatic void micinit(struct airo_info *ai);\nstatic int micsetup(struct airo_info *ai);\nstatic int encapsulate(struct airo_info *ai, etherHead *pPacket, MICBuffer *buffer, int len);\nstatic int decapsulate(struct airo_info *ai, MICBuffer *mic, etherHead *pPacket, u16 payLen);\n\nstatic u8 airo_rssi_to_dbm (tdsRssiEntry *rssi_rid, u8 rssi);\nstatic u8 airo_dbm_to_pct (tdsRssiEntry *rssi_rid, u8 dbm);\n\nstatic void airo_networks_free(struct airo_info *ai);\n\nstruct airo_info {\n\tstruct net_device             *dev;\n\tstruct list_head              dev_list;\n\t/* Note, we can have MAX_FIDS outstanding.  FIDs are 16-bits, so we\n\t   use the high bit to mark whether it is in use. */\n#define MAX_FIDS 6\n#define MPI_MAX_FIDS 1\n\tu32                           fids[MAX_FIDS];\n\tConfigRid config;\n\tchar keyindex; // Used with auto wep\n\tchar defindex; // Used with auto wep\n\tstruct proc_dir_entry *proc_entry;\n        spinlock_t aux_lock;\n#define FLAG_RADIO_OFF\t0\t/* User disabling of MAC */\n#define FLAG_RADIO_DOWN\t1\t/* ifup/ifdown disabling of MAC */\n#define FLAG_RADIO_MASK 0x03\n#define FLAG_ENABLED\t2\n#define FLAG_ADHOC\t3\t/* Needed by MIC */\n#define FLAG_MIC_CAPABLE 4\n#define FLAG_UPDATE_MULTI 5\n#define FLAG_UPDATE_UNI 6\n#define FLAG_802_11\t7\n#define FLAG_PROMISC\t8\t/* IFF_PROMISC 0x100 - include/linux/if.h */\n#define FLAG_PENDING_XMIT 9\n#define FLAG_PENDING_XMIT11 10\n#define FLAG_MPI\t11\n#define FLAG_REGISTERED\t12\n#define FLAG_COMMIT\t13\n#define FLAG_RESET\t14\n#define FLAG_FLASHING\t15\n#define FLAG_WPA_CAPABLE\t16\n\tunsigned long flags;\n#define JOB_DIE\t0\n#define JOB_XMIT\t1\n#define JOB_XMIT11\t2\n#define JOB_STATS\t3\n#define JOB_PROMISC\t4\n#define JOB_MIC\t5\n#define JOB_EVENT\t6\n#define JOB_AUTOWEP\t7\n#define JOB_WSTATS\t8\n#define JOB_SCAN_RESULTS  9\n\tunsigned long jobs;\n\tint (*bap_read)(struct airo_info*, __le16 *pu16Dst, int bytelen,\n\t\t\tint whichbap);\n\tunsigned short *flash;\n\ttdsRssiEntry *rssi;\n\tstruct task_struct *list_bss_task;\n\tstruct task_struct *airo_thread_task;\n\tstruct semaphore sem;\n\twait_queue_head_t thr_wait;\n\tunsigned long expires;\n\tstruct {\n\t\tstruct sk_buff *skb;\n\t\tint fid;\n\t} xmit, xmit11;\n\tstruct net_device *wifidev;\n\tstruct iw_statistics\twstats;\t\t// wireless stats\n\tunsigned long\t\tscan_timeout;\t/* Time scan should be read */\n\tstruct iw_spy_data\tspy_data;\n\tstruct iw_public_data\twireless_data;\n\t/* MIC stuff */\n\tstruct crypto_cipher\t*tfm;\n\tmic_module\t\tmod[2];\n\tmic_statistics\t\tmicstats;\n\tHostRxDesc rxfids[MPI_MAX_FIDS]; // rx/tx/config MPI350 descriptors\n\tHostTxDesc txfids[MPI_MAX_FIDS];\n\tHostRidDesc config_desc;\n\tunsigned long ridbus; // phys addr of config_desc\n\tstruct sk_buff_head txq;// tx queue used by mpi350 code\n\tstruct pci_dev          *pci;\n\tunsigned char\t\t__iomem *pcimem;\n\tunsigned char\t\t__iomem *pciaux;\n\tunsigned char\t\t*shared;\n\tdma_addr_t\t\tshared_dma;\n\tpm_message_t\t\tpower;\n\tSsidRid\t\t\t*SSID;\n\tAPListRid\t\t*APList;\n#define\tPCI_SHARED_LEN\t\t2*MPI_MAX_FIDS*PKTSIZE+RIDSIZE\n\tchar\t\t\tproc_name[IFNAMSIZ];\n\n\tint\t\t\twep_capable;\n\tint\t\t\tmax_wep_idx;\n\n\t/* WPA-related stuff */\n\tunsigned int bssListFirst;\n\tunsigned int bssListNext;\n\tunsigned int bssListRidLen;\n\n\tstruct list_head network_list;\n\tstruct list_head network_free_list;\n\tBSSListElement *networks;\n};\n\nstatic inline int bap_read(struct airo_info *ai, __le16 *pu16Dst, int bytelen,\n\t\t\t   int whichbap)\n{\n\treturn ai->bap_read(ai, pu16Dst, bytelen, whichbap);\n}\n\nstatic int setup_proc_entry( struct net_device *dev,\n\t\t\t     struct airo_info *apriv );\nstatic int takedown_proc_entry( struct net_device *dev,\n\t\t\t\tstruct airo_info *apriv );\n\nstatic int cmdreset(struct airo_info *ai);\nstatic int setflashmode (struct airo_info *ai);\nstatic int flashgchar(struct airo_info *ai,int matchbyte,int dwelltime);\nstatic int flashputbuf(struct airo_info *ai);\nstatic int flashrestart(struct airo_info *ai,struct net_device *dev);\n\n#define airo_print(type, name, fmt, args...) \\\n\tprintk(type DRV_NAME \"(%s): \" fmt \"\\n\", name, ##args)\n\n#define airo_print_info(name, fmt, args...) \\\n\tairo_print(KERN_INFO, name, fmt, ##args)\n\n#define airo_print_dbg(name, fmt, args...) \\\n\tairo_print(KERN_DEBUG, name, fmt, ##args)\n\n#define airo_print_warn(name, fmt, args...) \\\n\tairo_print(KERN_WARNING, name, fmt, ##args)\n\n#define airo_print_err(name, fmt, args...) \\\n\tairo_print(KERN_ERR, name, fmt, ##args)\n\n#define AIRO_FLASH(dev) (((struct airo_info *)dev->ml_priv)->flash)\n\n/***********************************************************************\n *                              MIC ROUTINES                           *\n ***********************************************************************\n */\n\nstatic int RxSeqValid (struct airo_info *ai,miccntx *context,int mcast,u32 micSeq);\nstatic void MoveWindow(miccntx *context, u32 micSeq);\nstatic void emmh32_setseed(emmh32_context *context, u8 *pkey, int keylen,\n\t\t\t   struct crypto_cipher *tfm);\nstatic void emmh32_init(emmh32_context *context);\nstatic void emmh32_update(emmh32_context *context, u8 *pOctets, int len);\nstatic void emmh32_final(emmh32_context *context, u8 digest[4]);\nstatic int flashpchar(struct airo_info *ai,int byte,int dwelltime);\n\nstatic void age_mic_context(miccntx *cur, miccntx *old, u8 *key, int key_len,\n\t\t\t    struct crypto_cipher *tfm)\n{\n\t/* If the current MIC context is valid and its key is the same as\n\t * the MIC register, there's nothing to do.\n\t */\n\tif (cur->valid && (memcmp(cur->key, key, key_len) == 0))\n\t\treturn;\n\n\t/* Age current mic Context */\n\tmemcpy(old, cur, sizeof(*cur));\n\n\t/* Initialize new context */\n\tmemcpy(cur->key, key, key_len);\n\tcur->window  = 33; /* Window always points to the middle */\n\tcur->rx      = 0;  /* Rx Sequence numbers */\n\tcur->tx      = 0;  /* Tx sequence numbers */\n\tcur->valid   = 1;  /* Key is now valid */\n\n\t/* Give key to mic seed */\n\temmh32_setseed(&cur->seed, key, key_len, tfm);\n}\n\n/* micinit - Initialize mic seed */\n\nstatic void micinit(struct airo_info *ai)\n{\n\tMICRid mic_rid;\n\n\tclear_bit(JOB_MIC, &ai->jobs);\n\tPC4500_readrid(ai, RID_MIC, &mic_rid, sizeof(mic_rid), 0);\n\tup(&ai->sem);\n\n\tai->micstats.enabled = (le16_to_cpu(mic_rid.state) & 0x00FF) ? 1 : 0;\n\tif (!ai->micstats.enabled) {\n\t\t/* So next time we have a valid key and mic is enabled, we will\n\t\t * update the sequence number if the key is the same as before.\n\t\t */\n\t\tai->mod[0].uCtx.valid = 0;\n\t\tai->mod[0].mCtx.valid = 0;\n\t\treturn;\n\t}\n\n\tif (mic_rid.multicastValid) {\n\t\tage_mic_context(&ai->mod[0].mCtx, &ai->mod[1].mCtx,\n\t\t                mic_rid.multicast, sizeof(mic_rid.multicast),\n\t\t                ai->tfm);\n\t}\n\n\tif (mic_rid.unicastValid) {\n\t\tage_mic_context(&ai->mod[0].uCtx, &ai->mod[1].uCtx,\n\t\t\t\tmic_rid.unicast, sizeof(mic_rid.unicast),\n\t\t\t\tai->tfm);\n\t}\n}\n\n/* micsetup - Get ready for business */\n\nstatic int micsetup(struct airo_info *ai) {\n\tint i;\n\n\tif (ai->tfm == NULL)\n\t        ai->tfm = crypto_alloc_cipher(\"aes\", 0, CRYPTO_ALG_ASYNC);\n\n        if (IS_ERR(ai->tfm)) {\n                airo_print_err(ai->dev->name, \"failed to load transform for AES\");\n                ai->tfm = NULL;\n                return ERROR;\n        }\n\n\tfor (i=0; i < NUM_MODULES; i++) {\n\t\tmemset(&ai->mod[i].mCtx,0,sizeof(miccntx));\n\t\tmemset(&ai->mod[i].uCtx,0,sizeof(miccntx));\n\t}\n\treturn SUCCESS;\n}\n\nstatic const u8 micsnap[] = {0xAA,0xAA,0x03,0x00,0x40,0x96,0x00,0x02};\n\n/*===========================================================================\n * Description: Mic a packet\n *    \n *      Inputs: etherHead * pointer to an 802.3 frame\n *    \n *     Returns: BOOLEAN if successful, otherwise false.\n *             PacketTxLen will be updated with the mic'd packets size.\n *\n *    Caveats: It is assumed that the frame buffer will already\n *             be big enough to hold the largets mic message possible.\n *            (No memory allocation is done here).\n *  \n *    Author: sbraneky (10/15/01)\n *    Merciless hacks by rwilcher (1/14/02)\n */\n\nstatic int encapsulate(struct airo_info *ai ,etherHead *frame, MICBuffer *mic, int payLen)\n{\n\tmiccntx   *context;\n\n\t// Determine correct context\n\t// If not adhoc, always use unicast key\n\n\tif (test_bit(FLAG_ADHOC, &ai->flags) && (frame->da[0] & 0x1))\n\t\tcontext = &ai->mod[0].mCtx;\n\telse\n\t\tcontext = &ai->mod[0].uCtx;\n  \n\tif (!context->valid)\n\t\treturn ERROR;\n\n\tmic->typelen = htons(payLen + 16); //Length of Mic'd packet\n\n\tmemcpy(&mic->u.snap, micsnap, sizeof(micsnap)); // Add Snap\n\n\t// Add Tx sequence\n\tmic->seq = htonl(context->tx);\n\tcontext->tx += 2;\n\n\temmh32_init(&context->seed); // Mic the packet\n\temmh32_update(&context->seed,frame->da,ETH_ALEN * 2); // DA,SA\n\temmh32_update(&context->seed,(u8*)&mic->typelen,10); // Type/Length and Snap\n\temmh32_update(&context->seed,(u8*)&mic->seq,sizeof(mic->seq)); //SEQ\n\temmh32_update(&context->seed,frame->da + ETH_ALEN * 2,payLen); //payload\n\temmh32_final(&context->seed, (u8*)&mic->mic);\n\n\t/*    New Type/length ?????????? */\n\tmic->typelen = 0; //Let NIC know it could be an oversized packet\n\treturn SUCCESS;\n}\n\ntypedef enum {\n    NONE,\n    NOMIC,\n    NOMICPLUMMED,\n    SEQUENCE,\n    INCORRECTMIC,\n} mic_error;\n\n/*===========================================================================\n *  Description: Decapsulates a MIC'd packet and returns the 802.3 packet\n *               (removes the MIC stuff) if packet is a valid packet.\n *      \n *       Inputs: etherHead  pointer to the 802.3 packet             \n *     \n *      Returns: BOOLEAN - TRUE if packet should be dropped otherwise FALSE\n *     \n *      Author: sbraneky (10/15/01)\n *    Merciless hacks by rwilcher (1/14/02)\n *---------------------------------------------------------------------------\n */\n\nstatic int decapsulate(struct airo_info *ai, MICBuffer *mic, etherHead *eth, u16 payLen)\n{\n\tint      i;\n\tu32      micSEQ;\n\tmiccntx  *context;\n\tu8       digest[4];\n\tmic_error micError = NONE;\n\n\t// Check if the packet is a Mic'd packet\n\n\tif (!ai->micstats.enabled) {\n\t\t//No Mic set or Mic OFF but we received a MIC'd packet.\n\t\tif (memcmp ((u8*)eth + 14, micsnap, sizeof(micsnap)) == 0) {\n\t\t\tai->micstats.rxMICPlummed++;\n\t\t\treturn ERROR;\n\t\t}\n\t\treturn SUCCESS;\n\t}\n\n\tif (ntohs(mic->typelen) == 0x888E)\n\t\treturn SUCCESS;\n\n\tif (memcmp (mic->u.snap, micsnap, sizeof(micsnap)) != 0) {\n\t    // Mic enabled but packet isn't Mic'd\n\t\tai->micstats.rxMICPlummed++;\n\t    \treturn ERROR;\n\t}\n\n\tmicSEQ = ntohl(mic->seq);            //store SEQ as CPU order\n\n\t//At this point we a have a mic'd packet and mic is enabled\n\t//Now do the mic error checking.\n\n\t//Receive seq must be odd\n\tif ( (micSEQ & 1) == 0 ) {\n\t\tai->micstats.rxWrongSequence++;\n\t\treturn ERROR;\n\t}\n\n\tfor (i = 0; i < NUM_MODULES; i++) {\n\t\tint mcast = eth->da[0] & 1;\n\t\t//Determine proper context \n\t\tcontext = mcast ? &ai->mod[i].mCtx : &ai->mod[i].uCtx;\n\t\n\t\t//Make sure context is valid\n\t\tif (!context->valid) {\n\t\t\tif (i == 0)\n\t\t\t\tmicError = NOMICPLUMMED;\n\t\t\tcontinue;                \n\t\t}\n\t       \t//DeMic it \n\n\t\tif (!mic->typelen)\n\t\t\tmic->typelen = htons(payLen + sizeof(MICBuffer) - 2);\n\t\n\t\temmh32_init(&context->seed);\n\t\temmh32_update(&context->seed, eth->da, ETH_ALEN*2); \n\t\temmh32_update(&context->seed, (u8 *)&mic->typelen, sizeof(mic->typelen)+sizeof(mic->u.snap)); \n\t\temmh32_update(&context->seed, (u8 *)&mic->seq,sizeof(mic->seq));\t\n\t\temmh32_update(&context->seed, eth->da + ETH_ALEN*2,payLen);\t\n\t\t//Calculate MIC\n\t\temmh32_final(&context->seed, digest);\n\t\n\t\tif (memcmp(digest, &mic->mic, 4)) { //Make sure the mics match\n\t\t  //Invalid Mic\n\t\t\tif (i == 0)\n\t\t\t\tmicError = INCORRECTMIC;\n\t\t\tcontinue;\n\t\t}\n\n\t\t//Check Sequence number if mics pass\n\t\tif (RxSeqValid(ai, context, mcast, micSEQ) == SUCCESS) {\n\t\t\tai->micstats.rxSuccess++;\n\t\t\treturn SUCCESS;\n\t\t}\n\t\tif (i == 0)\n\t\t\tmicError = SEQUENCE;\n\t}\n\n\t// Update statistics\n\tswitch (micError) {\n\t\tcase NOMICPLUMMED: ai->micstats.rxMICPlummed++;   break;\n\t\tcase SEQUENCE:    ai->micstats.rxWrongSequence++; break;\n\t\tcase INCORRECTMIC: ai->micstats.rxIncorrectMIC++; break;\n\t\tcase NONE:  break;\n\t\tcase NOMIC: break;\n\t}\n\treturn ERROR;\n}\n\n/*===========================================================================\n * Description:  Checks the Rx Seq number to make sure it is valid\n *               and hasn't already been received\n *   \n *     Inputs: miccntx - mic context to check seq against\n *             micSeq  - the Mic seq number\n *   \n *    Returns: TRUE if valid otherwise FALSE. \n *\n *    Author: sbraneky (10/15/01)\n *    Merciless hacks by rwilcher (1/14/02)\n *---------------------------------------------------------------------------\n */\n\nstatic int RxSeqValid (struct airo_info *ai,miccntx *context,int mcast,u32 micSeq)\n{\n\tu32 seq,index;\n\n\t//Allow for the ap being rebooted - if it is then use the next \n\t//sequence number of the current sequence number - might go backwards\n\n\tif (mcast) {\n\t\tif (test_bit(FLAG_UPDATE_MULTI, &ai->flags)) {\n\t\t\tclear_bit (FLAG_UPDATE_MULTI, &ai->flags);\n\t\t\tcontext->window = (micSeq > 33) ? micSeq : 33;\n\t\t\tcontext->rx     = 0;        // Reset rx\n\t\t}\n\t} else if (test_bit(FLAG_UPDATE_UNI, &ai->flags)) {\n\t\tclear_bit (FLAG_UPDATE_UNI, &ai->flags);\n\t\tcontext->window = (micSeq > 33) ? micSeq : 33; // Move window\n\t\tcontext->rx     = 0;        // Reset rx\n\t}\n\n\t//Make sequence number relative to START of window\n\tseq = micSeq - (context->window - 33);\n\n\t//Too old of a SEQ number to check.\n\tif ((s32)seq < 0)\n\t\treturn ERROR;\n    \n\tif ( seq > 64 ) {\n\t\t//Window is infinite forward\n\t\tMoveWindow(context,micSeq);\n\t\treturn SUCCESS;\n\t}\n\n\t// We are in the window. Now check the context rx bit to see if it was already sent\n\tseq >>= 1;         //divide by 2 because we only have odd numbers\n\tindex = 1 << seq;  //Get an index number\n\n\tif (!(context->rx & index)) {\n\t\t//micSEQ falls inside the window.\n\t\t//Add seqence number to the list of received numbers.\n\t\tcontext->rx |= index;\n\n\t\tMoveWindow(context,micSeq);\n\n\t\treturn SUCCESS;\n\t}\n\treturn ERROR;\n}\n\nstatic void MoveWindow(miccntx *context, u32 micSeq)\n{\n\tu32 shift;\n\n\t//Move window if seq greater than the middle of the window\n\tif (micSeq > context->window) {\n\t\tshift = (micSeq - context->window) >> 1;\n    \n\t\t    //Shift out old\n\t\tif (shift < 32)\n\t\t\tcontext->rx >>= shift;\n\t\telse\n\t\t\tcontext->rx = 0;\n\n\t\tcontext->window = micSeq;      //Move window\n\t}\n}\n\n/*==============================================*/\n/*========== EMMH ROUTINES  ====================*/\n/*==============================================*/\n\n/* mic accumulate */\n#define MIC_ACCUM(val)\t\\\n\tcontext->accum += (u64)(val) * context->coeff[coeff_position++];\n\nstatic unsigned char aes_counter[16];\n\n/* expand the key to fill the MMH coefficient array */\nstatic void emmh32_setseed(emmh32_context *context, u8 *pkey, int keylen,\n\t\t\t   struct crypto_cipher *tfm)\n{\n  /* take the keying material, expand if necessary, truncate at 16-bytes */\n  /* run through AES counter mode to generate context->coeff[] */\n  \n\tint i,j;\n\tu32 counter;\n\tu8 *cipher, plain[16];\n\n\tcrypto_cipher_setkey(tfm, pkey, 16);\n\tcounter = 0;\n\tfor (i = 0; i < ARRAY_SIZE(context->coeff); ) {\n\t\taes_counter[15] = (u8)(counter >> 0);\n\t\taes_counter[14] = (u8)(counter >> 8);\n\t\taes_counter[13] = (u8)(counter >> 16);\n\t\taes_counter[12] = (u8)(counter >> 24);\n\t\tcounter++;\n\t\tmemcpy (plain, aes_counter, 16);\n\t\tcrypto_cipher_encrypt_one(tfm, plain, plain);\n\t\tcipher = plain;\n\t\tfor (j = 0; (j < 16) && (i < ARRAY_SIZE(context->coeff)); ) {\n\t\t\tcontext->coeff[i++] = ntohl(*(__be32 *)&cipher[j]);\n\t\t\tj += 4;\n\t\t}\n\t}\n}\n\n/* prepare for calculation of a new mic */\nstatic void emmh32_init(emmh32_context *context)\n{\n\t/* prepare for new mic calculation */\n\tcontext->accum = 0;\n\tcontext->position = 0;\n}\n\n/* add some bytes to the mic calculation */\nstatic void emmh32_update(emmh32_context *context, u8 *pOctets, int len)\n{\n\tint\tcoeff_position, byte_position;\n  \n\tif (len == 0) return;\n  \n\tcoeff_position = context->position >> 2;\n  \n\t/* deal with partial 32-bit word left over from last update */\n\tbyte_position = context->position & 3;\n\tif (byte_position) {\n\t\t/* have a partial word in part to deal with */\n\t\tdo {\n\t\t\tif (len == 0) return;\n\t\t\tcontext->part.d8[byte_position++] = *pOctets++;\n\t\t\tcontext->position++;\n\t\t\tlen--;\n\t\t} while (byte_position < 4);\n\t\tMIC_ACCUM(ntohl(context->part.d32));\n\t}\n\n\t/* deal with full 32-bit words */\n\twhile (len >= 4) {\n\t\tMIC_ACCUM(ntohl(*(__be32 *)pOctets));\n\t\tcontext->position += 4;\n\t\tpOctets += 4;\n\t\tlen -= 4;\n\t}\n\n\t/* deal with partial 32-bit word that will be left over from this update */\n\tbyte_position = 0;\n\twhile (len > 0) {\n\t\tcontext->part.d8[byte_position++] = *pOctets++;\n\t\tcontext->position++;\n\t\tlen--;\n\t}\n}\n\n/* mask used to zero empty bytes for final partial word */\nstatic u32 mask32[4] = { 0x00000000L, 0xFF000000L, 0xFFFF0000L, 0xFFFFFF00L };\n\n/* calculate the mic */\nstatic void emmh32_final(emmh32_context *context, u8 digest[4])\n{\n\tint\tcoeff_position, byte_position;\n\tu32\tval;\n  \n\tu64 sum, utmp;\n\ts64 stmp;\n\n\tcoeff_position = context->position >> 2;\n  \n\t/* deal with partial 32-bit word left over from last update */\n\tbyte_position = context->position & 3;\n\tif (byte_position) {\n\t\t/* have a partial word in part to deal with */\n\t\tval = ntohl(context->part.d32);\n\t\tMIC_ACCUM(val & mask32[byte_position]);\t/* zero empty bytes */\n\t}\n\n\t/* reduce the accumulated u64 to a 32-bit MIC */\n\tsum = context->accum;\n\tstmp = (sum  & 0xffffffffLL) - ((sum >> 32)  * 15);\n\tutmp = (stmp & 0xffffffffLL) - ((stmp >> 32) * 15);\n\tsum = utmp & 0xffffffffLL;\n\tif (utmp > 0x10000000fLL)\n\t\tsum -= 15;\n\n\tval = (u32)sum;\n\tdigest[0] = (val>>24) & 0xFF;\n\tdigest[1] = (val>>16) & 0xFF;\n\tdigest[2] = (val>>8) & 0xFF;\n\tdigest[3] = val & 0xFF;\n}\n\nstatic int readBSSListRid(struct airo_info *ai, int first,\n\t\t      BSSListRid *list)\n{\n\tCmd cmd;\n\tResp rsp;\n\n\tif (first == 1) {\n\t\tif (ai->flags & FLAG_RADIO_MASK) return -ENETDOWN;\n\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\tcmd.cmd=CMD_LISTBSS;\n\t\tif (down_interruptible(&ai->sem))\n\t\t\treturn -ERESTARTSYS;\n\t\tai->list_bss_task = current;\n\t\tissuecommand(ai, &cmd, &rsp);\n\t\tup(&ai->sem);\n\t\t/* Let the command take effect */\n\t\tschedule_timeout_uninterruptible(3 * HZ);\n\t\tai->list_bss_task = NULL;\n\t}\n\treturn PC4500_readrid(ai, first ? ai->bssListFirst : ai->bssListNext,\n\t\t\t    list, ai->bssListRidLen, 1);\n}\n\nstatic int readWepKeyRid(struct airo_info *ai, WepKeyRid *wkr, int temp, int lock)\n{\n\treturn PC4500_readrid(ai, temp ? RID_WEP_TEMP : RID_WEP_PERM,\n\t\t\t\twkr, sizeof(*wkr), lock);\n}\n\nstatic int writeWepKeyRid(struct airo_info *ai, WepKeyRid *wkr, int perm, int lock)\n{\n\tint rc;\n\trc = PC4500_writerid(ai, RID_WEP_TEMP, wkr, sizeof(*wkr), lock);\n\tif (rc!=SUCCESS)\n\t\tairo_print_err(ai->dev->name, \"WEP_TEMP set %x\", rc);\n\tif (perm) {\n\t\trc = PC4500_writerid(ai, RID_WEP_PERM, wkr, sizeof(*wkr), lock);\n\t\tif (rc!=SUCCESS)\n\t\t\tairo_print_err(ai->dev->name, \"WEP_PERM set %x\", rc);\n\t}\n\treturn rc;\n}\n\nstatic int readSsidRid(struct airo_info*ai, SsidRid *ssidr)\n{\n\treturn PC4500_readrid(ai, RID_SSID, ssidr, sizeof(*ssidr), 1);\n}\n\nstatic int writeSsidRid(struct airo_info*ai, SsidRid *pssidr, int lock)\n{\n\treturn PC4500_writerid(ai, RID_SSID, pssidr, sizeof(*pssidr), lock);\n}\n\nstatic int readConfigRid(struct airo_info *ai, int lock)\n{\n\tint rc;\n\tConfigRid cfg;\n\n\tif (ai->config.len)\n\t\treturn SUCCESS;\n\n\trc = PC4500_readrid(ai, RID_ACTUALCONFIG, &cfg, sizeof(cfg), lock);\n\tif (rc != SUCCESS)\n\t\treturn rc;\n\n\tai->config = cfg;\n\treturn SUCCESS;\n}\n\nstatic inline void checkThrottle(struct airo_info *ai)\n{\n\tint i;\n/* Old hardware had a limit on encryption speed */\n\tif (ai->config.authType != AUTH_OPEN && maxencrypt) {\n\t\tfor(i=0; i<8; i++) {\n\t\t\tif (ai->config.rates[i] > maxencrypt) {\n\t\t\t\tai->config.rates[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int writeConfigRid(struct airo_info *ai, int lock)\n{\n\tConfigRid cfgr;\n\n\tif (!test_bit (FLAG_COMMIT, &ai->flags))\n\t\treturn SUCCESS;\n\n\tclear_bit (FLAG_COMMIT, &ai->flags);\n\tclear_bit (FLAG_RESET, &ai->flags);\n\tcheckThrottle(ai);\n\tcfgr = ai->config;\n\n\tif ((cfgr.opmode & MODE_CFG_MASK) == MODE_STA_IBSS)\n\t\tset_bit(FLAG_ADHOC, &ai->flags);\n\telse\n\t\tclear_bit(FLAG_ADHOC, &ai->flags);\n\n\treturn PC4500_writerid( ai, RID_CONFIG, &cfgr, sizeof(cfgr), lock);\n}\n\nstatic int readStatusRid(struct airo_info *ai, StatusRid *statr, int lock)\n{\n\treturn PC4500_readrid(ai, RID_STATUS, statr, sizeof(*statr), lock);\n}\n\nstatic int readAPListRid(struct airo_info *ai, APListRid *aplr)\n{\n\treturn PC4500_readrid(ai, RID_APLIST, aplr, sizeof(*aplr), 1);\n}\n\nstatic int writeAPListRid(struct airo_info *ai, APListRid *aplr, int lock)\n{\n\treturn PC4500_writerid(ai, RID_APLIST, aplr, sizeof(*aplr), lock);\n}\n\nstatic int readCapabilityRid(struct airo_info *ai, CapabilityRid *capr, int lock)\n{\n\treturn PC4500_readrid(ai, RID_CAPABILITIES, capr, sizeof(*capr), lock);\n}\n\nstatic int readStatsRid(struct airo_info*ai, StatsRid *sr, int rid, int lock)\n{\n\treturn PC4500_readrid(ai, rid, sr, sizeof(*sr), lock);\n}\n\nstatic void try_auto_wep(struct airo_info *ai)\n{\n\tif (auto_wep && !(ai->flags & FLAG_RADIO_DOWN)) {\n\t\tai->expires = RUN_AT(3*HZ);\n\t\twake_up_interruptible(&ai->thr_wait);\n\t}\n}\n\nstatic int airo_open(struct net_device *dev) {\n\tstruct airo_info *ai = dev->ml_priv;\n\tint rc = 0;\n\n\tif (test_bit(FLAG_FLASHING, &ai->flags))\n\t\treturn -EIO;\n\n\t/* Make sure the card is configured.\n\t * Wireless Extensions may postpone config changes until the card\n\t * is open (to pipeline changes and speed-up card setup). If\n\t * those changes are not yet committed, do it now - Jean II */\n\tif (test_bit(FLAG_COMMIT, &ai->flags)) {\n\t\tdisable_MAC(ai, 1);\n\t\twriteConfigRid(ai, 1);\n\t}\n\n\tif (ai->wifidev != dev) {\n\t\tclear_bit(JOB_DIE, &ai->jobs);\n\t\tai->airo_thread_task = kthread_run(airo_thread, dev, dev->name);\n\t\tif (IS_ERR(ai->airo_thread_task))\n\t\t\treturn (int)PTR_ERR(ai->airo_thread_task);\n\n\t\trc = request_irq(dev->irq, airo_interrupt, IRQF_SHARED,\n\t\t\tdev->name, dev);\n\t\tif (rc) {\n\t\t\tairo_print_err(dev->name,\n\t\t\t\t\"register interrupt %d failed, rc %d\",\n\t\t\t\tdev->irq, rc);\n\t\t\tset_bit(JOB_DIE, &ai->jobs);\n\t\t\tkthread_stop(ai->airo_thread_task);\n\t\t\treturn rc;\n\t\t}\n\n\t\t/* Power on the MAC controller (which may have been disabled) */\n\t\tclear_bit(FLAG_RADIO_DOWN, &ai->flags);\n\t\tenable_interrupts(ai);\n\n\t\ttry_auto_wep(ai);\n\t}\n\tenable_MAC(ai, 1);\n\n\tnetif_start_queue(dev);\n\treturn 0;\n}\n\nstatic netdev_tx_t mpi_start_xmit(struct sk_buff *skb,\n\t\t\t\t\tstruct net_device *dev)\n{\n\tint npacks, pending;\n\tunsigned long flags;\n\tstruct airo_info *ai = dev->ml_priv;\n\n\tif (!skb) {\n\t\tairo_print_err(dev->name, \"%s: skb == NULL!\",__func__);\n\t\treturn NETDEV_TX_OK;\n\t}\n\tnpacks = skb_queue_len (&ai->txq);\n\n\tif (npacks >= MAXTXQ - 1) {\n\t\tnetif_stop_queue (dev);\n\t\tif (npacks > MAXTXQ) {\n\t\t\tdev->stats.tx_fifo_errors++;\n\t\t\treturn NETDEV_TX_BUSY;\n\t\t}\n\t\tskb_queue_tail (&ai->txq, skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tspin_lock_irqsave(&ai->aux_lock, flags);\n\tskb_queue_tail (&ai->txq, skb);\n\tpending = test_bit(FLAG_PENDING_XMIT, &ai->flags);\n\tspin_unlock_irqrestore(&ai->aux_lock,flags);\n\tnetif_wake_queue (dev);\n\n\tif (pending == 0) {\n\t\tset_bit(FLAG_PENDING_XMIT, &ai->flags);\n\t\tmpi_send_packet (dev);\n\t}\n\treturn NETDEV_TX_OK;\n}\n\n/*\n * @mpi_send_packet\n *\n * Attempt to transmit a packet. Can be called from interrupt\n * or transmit . return number of packets we tried to send\n */\n\nstatic int mpi_send_packet (struct net_device *dev)\n{\n\tstruct sk_buff *skb;\n\tunsigned char *buffer;\n\ts16 len;\n\t__le16 *payloadLen;\n\tstruct airo_info *ai = dev->ml_priv;\n\tu8 *sendbuf;\n\n\t/* get a packet to send */\n\n\tif ((skb = skb_dequeue(&ai->txq)) == NULL) {\n\t\tairo_print_err(dev->name,\n\t\t\t\"%s: Dequeue'd zero in send_packet()\",\n\t\t\t__func__);\n\t\treturn 0;\n\t}\n\n\t/* check min length*/\n\tlen = ETH_ZLEN < skb->len ? skb->len : ETH_ZLEN;\n\tbuffer = skb->data;\n\n\tai->txfids[0].tx_desc.offset = 0;\n\tai->txfids[0].tx_desc.valid = 1;\n\tai->txfids[0].tx_desc.eoc = 1;\n\tai->txfids[0].tx_desc.len =len+sizeof(WifiHdr);\n\n/*\n * Magic, the cards firmware needs a length count (2 bytes) in the host buffer\n * right after  TXFID_HDR.The TXFID_HDR contains the status short so payloadlen\n * is immediately after it. ------------------------------------------------\n *                         |TXFIDHDR+STATUS|PAYLOADLEN|802.3HDR|PACKETDATA|\n *                         ------------------------------------------------\n */\n\n\tmemcpy((char *)ai->txfids[0].virtual_host_addr,\n\t\t(char *)&wifictlhdr8023, sizeof(wifictlhdr8023));\n\n\tpayloadLen = (__le16 *)(ai->txfids[0].virtual_host_addr +\n\t\tsizeof(wifictlhdr8023));\n\tsendbuf = ai->txfids[0].virtual_host_addr +\n\t\tsizeof(wifictlhdr8023) + 2 ;\n\n\t/*\n\t * Firmware automatically puts 802 header on so\n\t * we don't need to account for it in the length\n\t */\n\tif (test_bit(FLAG_MIC_CAPABLE, &ai->flags) && ai->micstats.enabled &&\n\t\t(ntohs(((__be16 *)buffer)[6]) != 0x888E)) {\n\t\tMICBuffer pMic;\n\n\t\tif (encapsulate(ai, (etherHead *)buffer, &pMic, len - sizeof(etherHead)) != SUCCESS)\n\t\t\treturn ERROR;\n\n\t\t*payloadLen = cpu_to_le16(len-sizeof(etherHead)+sizeof(pMic));\n\t\tai->txfids[0].tx_desc.len += sizeof(pMic);\n\t\t/* copy data into airo dma buffer */\n\t\tmemcpy (sendbuf, buffer, sizeof(etherHead));\n\t\tbuffer += sizeof(etherHead);\n\t\tsendbuf += sizeof(etherHead);\n\t\tmemcpy (sendbuf, &pMic, sizeof(pMic));\n\t\tsendbuf += sizeof(pMic);\n\t\tmemcpy (sendbuf, buffer, len - sizeof(etherHead));\n\t} else {\n\t\t*payloadLen = cpu_to_le16(len - sizeof(etherHead));\n\n\t\tdev->trans_start = jiffies;\n\n\t\t/* copy data into airo dma buffer */\n\t\tmemcpy(sendbuf, buffer, len);\n\t}\n\n\tmemcpy_toio(ai->txfids[0].card_ram_off,\n\t\t&ai->txfids[0].tx_desc, sizeof(TxFid));\n\n\tOUT4500(ai, EVACK, 8);\n\n\tdev_kfree_skb_any(skb);\n\treturn 1;\n}\n\nstatic void get_tx_error(struct airo_info *ai, s32 fid)\n{\n\t__le16 status;\n\n\tif (fid < 0)\n\t\tstatus = ((WifiCtlHdr *)ai->txfids[0].virtual_host_addr)->ctlhdr.status;\n\telse {\n\t\tif (bap_setup(ai, ai->fids[fid] & 0xffff, 4, BAP0) != SUCCESS)\n\t\t\treturn;\n\t\tbap_read(ai, &status, 2, BAP0);\n\t}\n\tif (le16_to_cpu(status) & 2) /* Too many retries */\n\t\tai->dev->stats.tx_aborted_errors++;\n\tif (le16_to_cpu(status) & 4) /* Transmit lifetime exceeded */\n\t\tai->dev->stats.tx_heartbeat_errors++;\n\tif (le16_to_cpu(status) & 8) /* Aid fail */\n\t\t{ }\n\tif (le16_to_cpu(status) & 0x10) /* MAC disabled */\n\t\tai->dev->stats.tx_carrier_errors++;\n\tif (le16_to_cpu(status) & 0x20) /* Association lost */\n\t\t{ }\n\t/* We produce a TXDROP event only for retry or lifetime\n\t * exceeded, because that's the only status that really mean\n\t * that this particular node went away.\n\t * Other errors means that *we* screwed up. - Jean II */\n\tif ((le16_to_cpu(status) & 2) ||\n\t     (le16_to_cpu(status) & 4)) {\n\t\tunion iwreq_data\twrqu;\n\t\tchar junk[0x18];\n\n\t\t/* Faster to skip over useless data than to do\n\t\t * another bap_setup(). We are at offset 0x6 and\n\t\t * need to go to 0x18 and read 6 bytes - Jean II */\n\t\tbap_read(ai, (__le16 *) junk, 0x18, BAP0);\n\n\t\t/* Copy 802.11 dest address.\n\t\t * We use the 802.11 header because the frame may\n\t\t * not be 802.3 or may be mangled...\n\t\t * In Ad-Hoc mode, it will be the node address.\n\t\t * In managed mode, it will be most likely the AP addr\n\t\t * User space will figure out how to convert it to\n\t\t * whatever it needs (IP address or else).\n\t\t * - Jean II */\n\t\tmemcpy(wrqu.addr.sa_data, junk + 0x12, ETH_ALEN);\n\t\twrqu.addr.sa_family = ARPHRD_ETHER;\n\n\t\t/* Send event to user space */\n\t\twireless_send_event(ai->dev, IWEVTXDROP, &wrqu, NULL);\n\t}\n}\n\nstatic void airo_end_xmit(struct net_device *dev) {\n\tu16 status;\n\tint i;\n\tstruct airo_info *priv = dev->ml_priv;\n\tstruct sk_buff *skb = priv->xmit.skb;\n\tint fid = priv->xmit.fid;\n\tu32 *fids = priv->fids;\n\n\tclear_bit(JOB_XMIT, &priv->jobs);\n\tclear_bit(FLAG_PENDING_XMIT, &priv->flags);\n\tstatus = transmit_802_3_packet (priv, fids[fid], skb->data);\n\tup(&priv->sem);\n\n\ti = 0;\n\tif ( status == SUCCESS ) {\n\t\tdev->trans_start = jiffies;\n\t\tfor (; i < MAX_FIDS / 2 && (priv->fids[i] & 0xffff0000); i++);\n\t} else {\n\t\tpriv->fids[fid] &= 0xffff;\n\t\tdev->stats.tx_window_errors++;\n\t}\n\tif (i < MAX_FIDS / 2)\n\t\tnetif_wake_queue(dev);\n\tdev_kfree_skb(skb);\n}\n\nstatic netdev_tx_t airo_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t struct net_device *dev)\n{\n\ts16 len;\n\tint i, j;\n\tstruct airo_info *priv = dev->ml_priv;\n\tu32 *fids = priv->fids;\n\n\tif ( skb == NULL ) {\n\t\tairo_print_err(dev->name, \"%s: skb == NULL!\", __func__);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\t/* Find a vacant FID */\n\tfor( i = 0; i < MAX_FIDS / 2 && (fids[i] & 0xffff0000); i++ );\n\tfor( j = i + 1; j < MAX_FIDS / 2 && (fids[j] & 0xffff0000); j++ );\n\n\tif ( j >= MAX_FIDS / 2 ) {\n\t\tnetif_stop_queue(dev);\n\n\t\tif (i == MAX_FIDS / 2) {\n\t\t\tdev->stats.tx_fifo_errors++;\n\t\t\treturn NETDEV_TX_BUSY;\n\t\t}\n\t}\n\t/* check min length*/\n\tlen = ETH_ZLEN < skb->len ? skb->len : ETH_ZLEN;\n        /* Mark fid as used & save length for later */\n\tfids[i] |= (len << 16);\n\tpriv->xmit.skb = skb;\n\tpriv->xmit.fid = i;\n\tif (down_trylock(&priv->sem) != 0) {\n\t\tset_bit(FLAG_PENDING_XMIT, &priv->flags);\n\t\tnetif_stop_queue(dev);\n\t\tset_bit(JOB_XMIT, &priv->jobs);\n\t\twake_up_interruptible(&priv->thr_wait);\n\t} else\n\t\tairo_end_xmit(dev);\n\treturn NETDEV_TX_OK;\n}\n\nstatic void airo_end_xmit11(struct net_device *dev) {\n\tu16 status;\n\tint i;\n\tstruct airo_info *priv = dev->ml_priv;\n\tstruct sk_buff *skb = priv->xmit11.skb;\n\tint fid = priv->xmit11.fid;\n\tu32 *fids = priv->fids;\n\n\tclear_bit(JOB_XMIT11, &priv->jobs);\n\tclear_bit(FLAG_PENDING_XMIT11, &priv->flags);\n\tstatus = transmit_802_11_packet (priv, fids[fid], skb->data);\n\tup(&priv->sem);\n\n\ti = MAX_FIDS / 2;\n\tif ( status == SUCCESS ) {\n\t\tdev->trans_start = jiffies;\n\t\tfor (; i < MAX_FIDS && (priv->fids[i] & 0xffff0000); i++);\n\t} else {\n\t\tpriv->fids[fid] &= 0xffff;\n\t\tdev->stats.tx_window_errors++;\n\t}\n\tif (i < MAX_FIDS)\n\t\tnetif_wake_queue(dev);\n\tdev_kfree_skb(skb);\n}\n\nstatic netdev_tx_t airo_start_xmit11(struct sk_buff *skb,\n\t\t\t\t\t   struct net_device *dev)\n{\n\ts16 len;\n\tint i, j;\n\tstruct airo_info *priv = dev->ml_priv;\n\tu32 *fids = priv->fids;\n\n\tif (test_bit(FLAG_MPI, &priv->flags)) {\n\t\t/* Not implemented yet for MPI350 */\n\t\tnetif_stop_queue(dev);\n\t\tdev_kfree_skb_any(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\tif ( skb == NULL ) {\n\t\tairo_print_err(dev->name, \"%s: skb == NULL!\", __func__);\n\t\treturn NETDEV_TX_OK;\n\t}\n\n\t/* Find a vacant FID */\n\tfor( i = MAX_FIDS / 2; i < MAX_FIDS && (fids[i] & 0xffff0000); i++ );\n\tfor( j = i + 1; j < MAX_FIDS && (fids[j] & 0xffff0000); j++ );\n\n\tif ( j >= MAX_FIDS ) {\n\t\tnetif_stop_queue(dev);\n\n\t\tif (i == MAX_FIDS) {\n\t\t\tdev->stats.tx_fifo_errors++;\n\t\t\treturn NETDEV_TX_BUSY;\n\t\t}\n\t}\n\t/* check min length*/\n\tlen = ETH_ZLEN < skb->len ? skb->len : ETH_ZLEN;\n        /* Mark fid as used & save length for later */\n\tfids[i] |= (len << 16);\n\tpriv->xmit11.skb = skb;\n\tpriv->xmit11.fid = i;\n\tif (down_trylock(&priv->sem) != 0) {\n\t\tset_bit(FLAG_PENDING_XMIT11, &priv->flags);\n\t\tnetif_stop_queue(dev);\n\t\tset_bit(JOB_XMIT11, &priv->jobs);\n\t\twake_up_interruptible(&priv->thr_wait);\n\t} else\n\t\tairo_end_xmit11(dev);\n\treturn NETDEV_TX_OK;\n}\n\nstatic void airo_read_stats(struct net_device *dev)\n{\n\tstruct airo_info *ai = dev->ml_priv;\n\tStatsRid stats_rid;\n\t__le32 *vals = stats_rid.vals;\n\n\tclear_bit(JOB_STATS, &ai->jobs);\n\tif (ai->power.event) {\n\t\tup(&ai->sem);\n\t\treturn;\n\t}\n\treadStatsRid(ai, &stats_rid, RID_STATS, 0);\n\tup(&ai->sem);\n\n\tdev->stats.rx_packets = le32_to_cpu(vals[43]) + le32_to_cpu(vals[44]) +\n\t\t\t       le32_to_cpu(vals[45]);\n\tdev->stats.tx_packets = le32_to_cpu(vals[39]) + le32_to_cpu(vals[40]) +\n\t\t\t       le32_to_cpu(vals[41]);\n\tdev->stats.rx_bytes = le32_to_cpu(vals[92]);\n\tdev->stats.tx_bytes = le32_to_cpu(vals[91]);\n\tdev->stats.rx_errors = le32_to_cpu(vals[0]) + le32_to_cpu(vals[2]) +\n\t\t\t      le32_to_cpu(vals[3]) + le32_to_cpu(vals[4]);\n\tdev->stats.tx_errors = le32_to_cpu(vals[42]) +\n\t\t\t      dev->stats.tx_fifo_errors;\n\tdev->stats.multicast = le32_to_cpu(vals[43]);\n\tdev->stats.collisions = le32_to_cpu(vals[89]);\n\n\t/* detailed rx_errors: */\n\tdev->stats.rx_length_errors = le32_to_cpu(vals[3]);\n\tdev->stats.rx_crc_errors = le32_to_cpu(vals[4]);\n\tdev->stats.rx_frame_errors = le32_to_cpu(vals[2]);\n\tdev->stats.rx_fifo_errors = le32_to_cpu(vals[0]);\n}\n\nstatic struct net_device_stats *airo_get_stats(struct net_device *dev)\n{\n\tstruct airo_info *local =  dev->ml_priv;\n\n\tif (!test_bit(JOB_STATS, &local->jobs)) {\n\t\t/* Get stats out of the card if available */\n\t\tif (down_trylock(&local->sem) != 0) {\n\t\t\tset_bit(JOB_STATS, &local->jobs);\n\t\t\twake_up_interruptible(&local->thr_wait);\n\t\t} else\n\t\t\tairo_read_stats(dev);\n\t}\n\n\treturn &dev->stats;\n}\n\nstatic void airo_set_promisc(struct airo_info *ai) {\n\tCmd cmd;\n\tResp rsp;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.cmd=CMD_SETMODE;\n\tclear_bit(JOB_PROMISC, &ai->jobs);\n\tcmd.parm0=(ai->flags&IFF_PROMISC) ? PROMISC : NOPROMISC;\n\tissuecommand(ai, &cmd, &rsp);\n\tup(&ai->sem);\n}\n\nstatic void airo_set_multicast_list(struct net_device *dev) {\n\tstruct airo_info *ai = dev->ml_priv;\n\n\tif ((dev->flags ^ ai->flags) & IFF_PROMISC) {\n\t\tchange_bit(FLAG_PROMISC, &ai->flags);\n\t\tif (down_trylock(&ai->sem) != 0) {\n\t\t\tset_bit(JOB_PROMISC, &ai->jobs);\n\t\t\twake_up_interruptible(&ai->thr_wait);\n\t\t} else\n\t\t\tairo_set_promisc(ai);\n\t}\n\n\tif ((dev->flags&IFF_ALLMULTI) || !netdev_mc_empty(dev)) {\n\t\t/* Turn on multicast.  (Should be already setup...) */\n\t}\n}\n\nstatic int airo_set_mac_address(struct net_device *dev, void *p)\n{\n\tstruct airo_info *ai = dev->ml_priv;\n\tstruct sockaddr *addr = p;\n\n\treadConfigRid(ai, 1);\n\tmemcpy (ai->config.macAddr, addr->sa_data, dev->addr_len);\n\tset_bit (FLAG_COMMIT, &ai->flags);\n\tdisable_MAC(ai, 1);\n\twriteConfigRid (ai, 1);\n\tenable_MAC(ai, 1);\n\tmemcpy (ai->dev->dev_addr, addr->sa_data, dev->addr_len);\n\tif (ai->wifidev)\n\t\tmemcpy (ai->wifidev->dev_addr, addr->sa_data, dev->addr_len);\n\treturn 0;\n}\n\nstatic int airo_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tif ((new_mtu < 68) || (new_mtu > 2400))\n\t\treturn -EINVAL;\n\tdev->mtu = new_mtu;\n\treturn 0;\n}\n\nstatic LIST_HEAD(airo_devices);\n\nstatic void add_airo_dev(struct airo_info *ai)\n{\n\t/* Upper layers already keep track of PCI devices,\n\t * so we only need to remember our non-PCI cards. */\n\tif (!ai->pci)\n\t\tlist_add_tail(&ai->dev_list, &airo_devices);\n}\n\nstatic void del_airo_dev(struct airo_info *ai)\n{\n\tif (!ai->pci)\n\t\tlist_del(&ai->dev_list);\n}\n\nstatic int airo_close(struct net_device *dev) {\n\tstruct airo_info *ai = dev->ml_priv;\n\n\tnetif_stop_queue(dev);\n\n\tif (ai->wifidev != dev) {\n#ifdef POWER_ON_DOWN\n\t\t/* Shut power to the card. The idea is that the user can save\n\t\t * power when he doesn't need the card with \"ifconfig down\".\n\t\t * That's the method that is most friendly towards the network\n\t\t * stack (i.e. the network stack won't try to broadcast\n\t\t * anything on the interface and routes are gone. Jean II */\n\t\tset_bit(FLAG_RADIO_DOWN, &ai->flags);\n\t\tdisable_MAC(ai, 1);\n#endif\n\t\tdisable_interrupts( ai );\n\n\t\tfree_irq(dev->irq, dev);\n\n\t\tset_bit(JOB_DIE, &ai->jobs);\n\t\tkthread_stop(ai->airo_thread_task);\n\t}\n\treturn 0;\n}\n\nvoid stop_airo_card( struct net_device *dev, int freeres )\n{\n\tstruct airo_info *ai = dev->ml_priv;\n\n\tset_bit(FLAG_RADIO_DOWN, &ai->flags);\n\tdisable_MAC(ai, 1);\n\tdisable_interrupts(ai);\n\ttakedown_proc_entry( dev, ai );\n\tif (test_bit(FLAG_REGISTERED, &ai->flags)) {\n\t\tunregister_netdev( dev );\n\t\tif (ai->wifidev) {\n\t\t\tunregister_netdev(ai->wifidev);\n\t\t\tfree_netdev(ai->wifidev);\n\t\t\tai->wifidev = NULL;\n\t\t}\n\t\tclear_bit(FLAG_REGISTERED, &ai->flags);\n\t}\n\t/*\n\t * Clean out tx queue\n\t */\n\tif (test_bit(FLAG_MPI, &ai->flags) && !skb_queue_empty(&ai->txq)) {\n\t\tstruct sk_buff *skb = NULL;\n\t\tfor (;(skb = skb_dequeue(&ai->txq));)\n\t\t\tdev_kfree_skb(skb);\n\t}\n\n\tairo_networks_free (ai);\n\n\tkfree(ai->flash);\n\tkfree(ai->rssi);\n\tkfree(ai->APList);\n\tkfree(ai->SSID);\n\tif (freeres) {\n\t\t/* PCMCIA frees this stuff, so only for PCI and ISA */\n\t        release_region( dev->base_addr, 64 );\n\t\tif (test_bit(FLAG_MPI, &ai->flags)) {\n\t\t\tif (ai->pci)\n\t\t\t\tmpi_unmap_card(ai->pci);\n\t\t\tif (ai->pcimem)\n\t\t\t\tiounmap(ai->pcimem);\n\t\t\tif (ai->pciaux)\n\t\t\t\tiounmap(ai->pciaux);\n\t\t\tpci_free_consistent(ai->pci, PCI_SHARED_LEN,\n\t\t\t\tai->shared, ai->shared_dma);\n\t\t}\n        }\n\tcrypto_free_cipher(ai->tfm);\n\tdel_airo_dev(ai);\n\tfree_netdev( dev );\n}\n\nEXPORT_SYMBOL(stop_airo_card);\n\nstatic int wll_header_parse(const struct sk_buff *skb, unsigned char *haddr)\n{\n\tmemcpy(haddr, skb_mac_header(skb) + 10, ETH_ALEN);\n\treturn ETH_ALEN;\n}\n\nstatic void mpi_unmap_card(struct pci_dev *pci)\n{\n\tunsigned long mem_start = pci_resource_start(pci, 1);\n\tunsigned long mem_len = pci_resource_len(pci, 1);\n\tunsigned long aux_start = pci_resource_start(pci, 2);\n\tunsigned long aux_len = AUXMEMSIZE;\n\n\trelease_mem_region(aux_start, aux_len);\n\trelease_mem_region(mem_start, mem_len);\n}\n\n/*************************************************************\n *  This routine assumes that descriptors have been setup .\n *  Run at insmod time or after reset  when the decriptors\n *  have been initialized . Returns 0 if all is well nz\n *  otherwise . Does not allocate memory but sets up card\n *  using previously allocated descriptors.\n */\nstatic int mpi_init_descriptors (struct airo_info *ai)\n{\n\tCmd cmd;\n\tResp rsp;\n\tint i;\n\tint rc = SUCCESS;\n\n\t/* Alloc  card RX descriptors */\n\tnetif_stop_queue(ai->dev);\n\n\tmemset(&rsp,0,sizeof(rsp));\n\tmemset(&cmd,0,sizeof(cmd));\n\n\tcmd.cmd = CMD_ALLOCATEAUX;\n\tcmd.parm0 = FID_RX;\n\tcmd.parm1 = (ai->rxfids[0].card_ram_off - ai->pciaux);\n\tcmd.parm2 = MPI_MAX_FIDS;\n\trc=issuecommand(ai, &cmd, &rsp);\n\tif (rc != SUCCESS) {\n\t\tairo_print_err(ai->dev->name, \"Couldn't allocate RX FID\");\n\t\treturn rc;\n\t}\n\n\tfor (i=0; i<MPI_MAX_FIDS; i++) {\n\t\tmemcpy_toio(ai->rxfids[i].card_ram_off,\n\t\t\t&ai->rxfids[i].rx_desc, sizeof(RxFid));\n\t}\n\n\t/* Alloc card TX descriptors */\n\n\tmemset(&rsp,0,sizeof(rsp));\n\tmemset(&cmd,0,sizeof(cmd));\n\n\tcmd.cmd = CMD_ALLOCATEAUX;\n\tcmd.parm0 = FID_TX;\n\tcmd.parm1 = (ai->txfids[0].card_ram_off - ai->pciaux);\n\tcmd.parm2 = MPI_MAX_FIDS;\n\n\tfor (i=0; i<MPI_MAX_FIDS; i++) {\n\t\tai->txfids[i].tx_desc.valid = 1;\n\t\tmemcpy_toio(ai->txfids[i].card_ram_off,\n\t\t\t&ai->txfids[i].tx_desc, sizeof(TxFid));\n\t}\n\tai->txfids[i-1].tx_desc.eoc = 1; /* Last descriptor has EOC set */\n\n\trc=issuecommand(ai, &cmd, &rsp);\n\tif (rc != SUCCESS) {\n\t\tairo_print_err(ai->dev->name, \"Couldn't allocate TX FID\");\n\t\treturn rc;\n\t}\n\n\t/* Alloc card Rid descriptor */\n\tmemset(&rsp,0,sizeof(rsp));\n\tmemset(&cmd,0,sizeof(cmd));\n\n\tcmd.cmd = CMD_ALLOCATEAUX;\n\tcmd.parm0 = RID_RW;\n\tcmd.parm1 = (ai->config_desc.card_ram_off - ai->pciaux);\n\tcmd.parm2 = 1; /* Magic number... */\n\trc=issuecommand(ai, &cmd, &rsp);\n\tif (rc != SUCCESS) {\n\t\tairo_print_err(ai->dev->name, \"Couldn't allocate RID\");\n\t\treturn rc;\n\t}\n\n\tmemcpy_toio(ai->config_desc.card_ram_off,\n\t\t&ai->config_desc.rid_desc, sizeof(Rid));\n\n\treturn rc;\n}\n\n/*\n * We are setting up three things here:\n * 1) Map AUX memory for descriptors: Rid, TxFid, or RxFid.\n * 2) Map PCI memory for issuing commands.\n * 3) Allocate memory (shared) to send and receive ethernet frames.\n */\nstatic int mpi_map_card(struct airo_info *ai, struct pci_dev *pci)\n{\n\tunsigned long mem_start, mem_len, aux_start, aux_len;\n\tint rc = -1;\n\tint i;\n\tdma_addr_t busaddroff;\n\tunsigned char *vpackoff;\n\tunsigned char __iomem *pciaddroff;\n\n\tmem_start = pci_resource_start(pci, 1);\n\tmem_len = pci_resource_len(pci, 1);\n\taux_start = pci_resource_start(pci, 2);\n\taux_len = AUXMEMSIZE;\n\n\tif (!request_mem_region(mem_start, mem_len, DRV_NAME)) {\n\t\tairo_print_err(\"\", \"Couldn't get region %x[%x]\",\n\t\t\t(int)mem_start, (int)mem_len);\n\t\tgoto out;\n\t}\n\tif (!request_mem_region(aux_start, aux_len, DRV_NAME)) {\n\t\tairo_print_err(\"\", \"Couldn't get region %x[%x]\",\n\t\t\t(int)aux_start, (int)aux_len);\n\t\tgoto free_region1;\n\t}\n\n\tai->pcimem = ioremap(mem_start, mem_len);\n\tif (!ai->pcimem) {\n\t\tairo_print_err(\"\", \"Couldn't map region %x[%x]\",\n\t\t\t(int)mem_start, (int)mem_len);\n\t\tgoto free_region2;\n\t}\n\tai->pciaux = ioremap(aux_start, aux_len);\n\tif (!ai->pciaux) {\n\t\tairo_print_err(\"\", \"Couldn't map region %x[%x]\",\n\t\t\t(int)aux_start, (int)aux_len);\n\t\tgoto free_memmap;\n\t}\n\n\t/* Reserve PKTSIZE for each fid and 2K for the Rids */\n\tai->shared = pci_alloc_consistent(pci, PCI_SHARED_LEN, &ai->shared_dma);\n\tif (!ai->shared) {\n\t\tairo_print_err(\"\", \"Couldn't alloc_consistent %d\",\n\t\t\tPCI_SHARED_LEN);\n\t\tgoto free_auxmap;\n\t}\n\n\t/*\n\t * Setup descriptor RX, TX, CONFIG\n\t */\n\tbusaddroff = ai->shared_dma;\n\tpciaddroff = ai->pciaux + AUX_OFFSET;\n\tvpackoff   = ai->shared;\n\n\t/* RX descriptor setup */\n\tfor(i = 0; i < MPI_MAX_FIDS; i++) {\n\t\tai->rxfids[i].pending = 0;\n\t\tai->rxfids[i].card_ram_off = pciaddroff;\n\t\tai->rxfids[i].virtual_host_addr = vpackoff;\n\t\tai->rxfids[i].rx_desc.host_addr = busaddroff;\n\t\tai->rxfids[i].rx_desc.valid = 1;\n\t\tai->rxfids[i].rx_desc.len = PKTSIZE;\n\t\tai->rxfids[i].rx_desc.rdy = 0;\n\n\t\tpciaddroff += sizeof(RxFid);\n\t\tbusaddroff += PKTSIZE;\n\t\tvpackoff   += PKTSIZE;\n\t}\n\n\t/* TX descriptor setup */\n\tfor(i = 0; i < MPI_MAX_FIDS; i++) {\n\t\tai->txfids[i].card_ram_off = pciaddroff;\n\t\tai->txfids[i].virtual_host_addr = vpackoff;\n\t\tai->txfids[i].tx_desc.valid = 1;\n\t\tai->txfids[i].tx_desc.host_addr = busaddroff;\n\t\tmemcpy(ai->txfids[i].virtual_host_addr,\n\t\t\t&wifictlhdr8023, sizeof(wifictlhdr8023));\n\n\t\tpciaddroff += sizeof(TxFid);\n\t\tbusaddroff += PKTSIZE;\n\t\tvpackoff   += PKTSIZE;\n\t}\n\tai->txfids[i-1].tx_desc.eoc = 1; /* Last descriptor has EOC set */\n\n\t/* Rid descriptor setup */\n\tai->config_desc.card_ram_off = pciaddroff;\n\tai->config_desc.virtual_host_addr = vpackoff;\n\tai->config_desc.rid_desc.host_addr = busaddroff;\n\tai->ridbus = busaddroff;\n\tai->config_desc.rid_desc.rid = 0;\n\tai->config_desc.rid_desc.len = RIDSIZE;\n\tai->config_desc.rid_desc.valid = 1;\n\tpciaddroff += sizeof(Rid);\n\tbusaddroff += RIDSIZE;\n\tvpackoff   += RIDSIZE;\n\n\t/* Tell card about descriptors */\n\tif (mpi_init_descriptors (ai) != SUCCESS)\n\t\tgoto free_shared;\n\n\treturn 0;\n free_shared:\n\tpci_free_consistent(pci, PCI_SHARED_LEN, ai->shared, ai->shared_dma);\n free_auxmap:\n\tiounmap(ai->pciaux);\n free_memmap:\n\tiounmap(ai->pcimem);\n free_region2:\n\trelease_mem_region(aux_start, aux_len);\n free_region1:\n\trelease_mem_region(mem_start, mem_len);\n out:\n\treturn rc;\n}\n\nstatic const struct header_ops airo_header_ops = {\n\t.parse = wll_header_parse,\n};\n\nstatic const struct net_device_ops airo11_netdev_ops = {\n\t.ndo_open \t\t= airo_open,\n\t.ndo_stop \t\t= airo_close,\n\t.ndo_start_xmit \t= airo_start_xmit11,\n\t.ndo_get_stats \t\t= airo_get_stats,\n\t.ndo_set_mac_address\t= airo_set_mac_address,\n\t.ndo_do_ioctl\t\t= airo_ioctl,\n\t.ndo_change_mtu\t\t= airo_change_mtu,\n};\n\nstatic void wifi_setup(struct net_device *dev)\n{\n\tdev->netdev_ops = &airo11_netdev_ops;\n\tdev->header_ops = &airo_header_ops;\n\tdev->wireless_handlers = &airo_handler_def;\n\n\tdev->type               = ARPHRD_IEEE80211;\n\tdev->hard_header_len    = ETH_HLEN;\n\tdev->mtu                = AIRO_DEF_MTU;\n\tdev->addr_len           = ETH_ALEN;\n\tdev->tx_queue_len       = 100; \n\n\tmemset(dev->broadcast,0xFF, ETH_ALEN);\n\n\tdev->flags              = IFF_BROADCAST|IFF_MULTICAST;\n}\n\nstatic struct net_device *init_wifidev(struct airo_info *ai,\n\t\t\t\t\tstruct net_device *ethdev)\n{\n\tint err;\n\tstruct net_device *dev = alloc_netdev(0, \"wifi%d\", wifi_setup);\n\tif (!dev)\n\t\treturn NULL;\n\tdev->ml_priv = ethdev->ml_priv;\n\tdev->irq = ethdev->irq;\n\tdev->base_addr = ethdev->base_addr;\n\tdev->wireless_data = ethdev->wireless_data;\n\tSET_NETDEV_DEV(dev, ethdev->dev.parent);\n\tmemcpy(dev->dev_addr, ethdev->dev_addr, dev->addr_len);\n\terr = register_netdev(dev);\n\tif (err<0) {\n\t\tfree_netdev(dev);\n\t\treturn NULL;\n\t}\n\treturn dev;\n}\n\nstatic int reset_card( struct net_device *dev , int lock) {\n\tstruct airo_info *ai = dev->ml_priv;\n\n\tif (lock && down_interruptible(&ai->sem))\n\t\treturn -1;\n\twaitbusy (ai);\n\tOUT4500(ai,COMMAND,CMD_SOFTRESET);\n\tmsleep(200);\n\twaitbusy (ai);\n\tmsleep(200);\n\tif (lock)\n\t\tup(&ai->sem);\n\treturn 0;\n}\n\n#define AIRO_MAX_NETWORK_COUNT\t64\nstatic int airo_networks_allocate(struct airo_info *ai)\n{\n\tif (ai->networks)\n\t\treturn 0;\n\n\tai->networks = kcalloc(AIRO_MAX_NETWORK_COUNT, sizeof(BSSListElement),\n\t\t\t       GFP_KERNEL);\n\tif (!ai->networks) {\n\t\tairo_print_warn(\"\", \"Out of memory allocating beacons\");\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\nstatic void airo_networks_free(struct airo_info *ai)\n{\n\tkfree(ai->networks);\n\tai->networks = NULL;\n}\n\nstatic void airo_networks_initialize(struct airo_info *ai)\n{\n\tint i;\n\n\tINIT_LIST_HEAD(&ai->network_free_list);\n\tINIT_LIST_HEAD(&ai->network_list);\n\tfor (i = 0; i < AIRO_MAX_NETWORK_COUNT; i++)\n\t\tlist_add_tail(&ai->networks[i].list,\n\t\t\t      &ai->network_free_list);\n}\n\nstatic const struct net_device_ops airo_netdev_ops = {\n\t.ndo_open\t\t= airo_open,\n\t.ndo_stop\t\t= airo_close,\n\t.ndo_start_xmit\t\t= airo_start_xmit,\n\t.ndo_get_stats\t\t= airo_get_stats,\n\t.ndo_set_multicast_list\t= airo_set_multicast_list,\n\t.ndo_set_mac_address\t= airo_set_mac_address,\n\t.ndo_do_ioctl\t\t= airo_ioctl,\n\t.ndo_change_mtu\t\t= airo_change_mtu,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic const struct net_device_ops mpi_netdev_ops = {\n\t.ndo_open\t\t= airo_open,\n\t.ndo_stop\t\t= airo_close,\n\t.ndo_start_xmit\t\t= mpi_start_xmit,\n\t.ndo_get_stats\t\t= airo_get_stats,\n\t.ndo_set_multicast_list\t= airo_set_multicast_list,\n\t.ndo_set_mac_address\t= airo_set_mac_address,\n\t.ndo_do_ioctl\t\t= airo_ioctl,\n\t.ndo_change_mtu\t\t= airo_change_mtu,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\n\nstatic struct net_device *_init_airo_card( unsigned short irq, int port,\n\t\t\t\t\t   int is_pcmcia, struct pci_dev *pci,\n\t\t\t\t\t   struct device *dmdev )\n{\n\tstruct net_device *dev;\n\tstruct airo_info *ai;\n\tint i, rc;\n\tCapabilityRid cap_rid;\n\n\t/* Create the network device object. */\n\tdev = alloc_netdev(sizeof(*ai), \"\", ether_setup);\n\tif (!dev) {\n\t\tairo_print_err(\"\", \"Couldn't alloc_etherdev\");\n\t\treturn NULL;\n\t}\n\n\tai = dev->ml_priv = netdev_priv(dev);\n\tai->wifidev = NULL;\n\tai->flags = 1 << FLAG_RADIO_DOWN;\n\tai->jobs = 0;\n\tai->dev = dev;\n\tif (pci && (pci->device == 0x5000 || pci->device == 0xa504)) {\n\t\tairo_print_dbg(\"\", \"Found an MPI350 card\");\n\t\tset_bit(FLAG_MPI, &ai->flags);\n\t}\n\tspin_lock_init(&ai->aux_lock);\n\tsema_init(&ai->sem, 1);\n\tai->config.len = 0;\n\tai->pci = pci;\n\tinit_waitqueue_head (&ai->thr_wait);\n\tai->tfm = NULL;\n\tadd_airo_dev(ai);\n\n\tif (airo_networks_allocate (ai))\n\t\tgoto err_out_free;\n\tairo_networks_initialize (ai);\n\n\tskb_queue_head_init (&ai->txq);\n\n\t/* The Airo-specific entries in the device structure. */\n\tif (test_bit(FLAG_MPI,&ai->flags))\n\t\tdev->netdev_ops = &mpi_netdev_ops;\n\telse\n\t\tdev->netdev_ops = &airo_netdev_ops;\n\tdev->wireless_handlers = &airo_handler_def;\n\tai->wireless_data.spy_data = &ai->spy_data;\n\tdev->wireless_data = &ai->wireless_data;\n\tdev->irq = irq;\n\tdev->base_addr = port;\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\n\tSET_NETDEV_DEV(dev, dmdev);\n\n\treset_card (dev, 1);\n\tmsleep(400);\n\n\tif (!is_pcmcia) {\n\t\tif (!request_region(dev->base_addr, 64, DRV_NAME)) {\n\t\t\trc = -EBUSY;\n\t\t\tairo_print_err(dev->name, \"Couldn't request region\");\n\t\t\tgoto err_out_nets;\n\t\t}\n\t}\n\n\tif (test_bit(FLAG_MPI,&ai->flags)) {\n\t\tif (mpi_map_card(ai, pci)) {\n\t\t\tairo_print_err(\"\", \"Could not map memory\");\n\t\t\tgoto err_out_res;\n\t\t}\n\t}\n\n\tif (probe) {\n\t\tif (setup_card(ai, dev->dev_addr, 1) != SUCCESS) {\n\t\t\tairo_print_err(dev->name, \"MAC could not be enabled\" );\n\t\t\trc = -EIO;\n\t\t\tgoto err_out_map;\n\t\t}\n\t} else if (!test_bit(FLAG_MPI,&ai->flags)) {\n\t\tai->bap_read = fast_bap_read;\n\t\tset_bit(FLAG_FLASHING, &ai->flags);\n\t}\n\n\tstrcpy(dev->name, \"eth%d\");\n\trc = register_netdev(dev);\n\tif (rc) {\n\t\tairo_print_err(dev->name, \"Couldn't register_netdev\");\n\t\tgoto err_out_map;\n\t}\n\tai->wifidev = init_wifidev(ai, dev);\n\tif (!ai->wifidev)\n\t\tgoto err_out_reg;\n\n\trc = readCapabilityRid(ai, &cap_rid, 1);\n\tif (rc != SUCCESS) {\n\t\trc = -EIO;\n\t\tgoto err_out_wifi;\n\t}\n\t/* WEP capability discovery */\n\tai->wep_capable = (cap_rid.softCap & cpu_to_le16(0x02)) ? 1 : 0;\n\tai->max_wep_idx = (cap_rid.softCap & cpu_to_le16(0x80)) ? 3 : 0;\n\n\tairo_print_info(dev->name, \"Firmware version %x.%x.%02d\",\n\t                ((le16_to_cpu(cap_rid.softVer) >> 8) & 0xF),\n\t                (le16_to_cpu(cap_rid.softVer) & 0xFF),\n\t                le16_to_cpu(cap_rid.softSubVer));\n\n\t/* Test for WPA support */\n\t/* Only firmware versions 5.30.17 or better can do WPA */\n\tif (le16_to_cpu(cap_rid.softVer) > 0x530\n\t || (le16_to_cpu(cap_rid.softVer) == 0x530\n\t      && le16_to_cpu(cap_rid.softSubVer) >= 17)) {\n\t\tairo_print_info(ai->dev->name, \"WPA supported.\");\n\n\t\tset_bit(FLAG_WPA_CAPABLE, &ai->flags);\n\t\tai->bssListFirst = RID_WPA_BSSLISTFIRST;\n\t\tai->bssListNext = RID_WPA_BSSLISTNEXT;\n\t\tai->bssListRidLen = sizeof(BSSListRid);\n\t} else {\n\t\tairo_print_info(ai->dev->name, \"WPA unsupported with firmware \"\n\t\t\t\"versions older than 5.30.17.\");\n\n\t\tai->bssListFirst = RID_BSSLISTFIRST;\n\t\tai->bssListNext = RID_BSSLISTNEXT;\n\t\tai->bssListRidLen = sizeof(BSSListRid) - sizeof(BSSListRidExtra);\n\t}\n\n\tset_bit(FLAG_REGISTERED,&ai->flags);\n\tairo_print_info(dev->name, \"MAC enabled %pM\", dev->dev_addr);\n\n\t/* Allocate the transmit buffers */\n\tif (probe && !test_bit(FLAG_MPI,&ai->flags))\n\t\tfor( i = 0; i < MAX_FIDS; i++ )\n\t\t\tai->fids[i] = transmit_allocate(ai,AIRO_DEF_MTU,i>=MAX_FIDS/2);\n\n\tif (setup_proc_entry(dev, dev->ml_priv) < 0)\n\t\tgoto err_out_wifi;\n\n\treturn dev;\n\nerr_out_wifi:\n\tunregister_netdev(ai->wifidev);\n\tfree_netdev(ai->wifidev);\nerr_out_reg:\n\tunregister_netdev(dev);\nerr_out_map:\n\tif (test_bit(FLAG_MPI,&ai->flags) && pci) {\n\t\tpci_free_consistent(pci, PCI_SHARED_LEN, ai->shared, ai->shared_dma);\n\t\tiounmap(ai->pciaux);\n\t\tiounmap(ai->pcimem);\n\t\tmpi_unmap_card(ai->pci);\n\t}\nerr_out_res:\n\tif (!is_pcmcia)\n\t        release_region( dev->base_addr, 64 );\nerr_out_nets:\n\tairo_networks_free(ai);\nerr_out_free:\n\tdel_airo_dev(ai);\n\tfree_netdev(dev);\n\treturn NULL;\n}\n\nstruct net_device *init_airo_card( unsigned short irq, int port, int is_pcmcia,\n\t\t\t\t  struct device *dmdev)\n{\n\treturn _init_airo_card ( irq, port, is_pcmcia, NULL, dmdev);\n}\n\nEXPORT_SYMBOL(init_airo_card);\n\nstatic int waitbusy (struct airo_info *ai) {\n\tint delay = 0;\n\twhile ((IN4500(ai, COMMAND) & COMMAND_BUSY) && (delay < 10000)) {\n\t\tudelay (10);\n\t\tif ((++delay % 20) == 0)\n\t\t\tOUT4500(ai, EVACK, EV_CLEARCOMMANDBUSY);\n\t}\n\treturn delay < 10000;\n}\n\nint reset_airo_card( struct net_device *dev )\n{\n\tint i;\n\tstruct airo_info *ai = dev->ml_priv;\n\n\tif (reset_card (dev, 1))\n\t\treturn -1;\n\n\tif ( setup_card(ai, dev->dev_addr, 1 ) != SUCCESS ) {\n\t\tairo_print_err(dev->name, \"MAC could not be enabled\");\n\t\treturn -1;\n\t}\n\tairo_print_info(dev->name, \"MAC enabled %pM\", dev->dev_addr);\n\t/* Allocate the transmit buffers if needed */\n\tif (!test_bit(FLAG_MPI,&ai->flags))\n\t\tfor( i = 0; i < MAX_FIDS; i++ )\n\t\t\tai->fids[i] = transmit_allocate (ai,AIRO_DEF_MTU,i>=MAX_FIDS/2);\n\n\tenable_interrupts( ai );\n\tnetif_wake_queue(dev);\n\treturn 0;\n}\n\nEXPORT_SYMBOL(reset_airo_card);\n\nstatic void airo_send_event(struct net_device *dev) {\n\tstruct airo_info *ai = dev->ml_priv;\n\tunion iwreq_data wrqu;\n\tStatusRid status_rid;\n\n\tclear_bit(JOB_EVENT, &ai->jobs);\n\tPC4500_readrid(ai, RID_STATUS, &status_rid, sizeof(status_rid), 0);\n\tup(&ai->sem);\n\twrqu.data.length = 0;\n\twrqu.data.flags = 0;\n\tmemcpy(wrqu.ap_addr.sa_data, status_rid.bssid[0], ETH_ALEN);\n\twrqu.ap_addr.sa_family = ARPHRD_ETHER;\n\n\t/* Send event to user space */\n\twireless_send_event(dev, SIOCGIWAP, &wrqu, NULL);\n}\n\nstatic void airo_process_scan_results (struct airo_info *ai) {\n\tunion iwreq_data\twrqu;\n\tBSSListRid bss;\n\tint rc;\n\tBSSListElement * loop_net;\n\tBSSListElement * tmp_net;\n\n\t/* Blow away current list of scan results */\n\tlist_for_each_entry_safe (loop_net, tmp_net, &ai->network_list, list) {\n\t\tlist_move_tail (&loop_net->list, &ai->network_free_list);\n\t\t/* Don't blow away ->list, just BSS data */\n\t\tmemset (loop_net, 0, sizeof (loop_net->bss));\n\t}\n\n\t/* Try to read the first entry of the scan result */\n\trc = PC4500_readrid(ai, ai->bssListFirst, &bss, ai->bssListRidLen, 0);\n\tif((rc) || (bss.index == cpu_to_le16(0xffff))) {\n\t\t/* No scan results */\n\t\tgoto out;\n\t}\n\n\t/* Read and parse all entries */\n\ttmp_net = NULL;\n\twhile((!rc) && (bss.index != cpu_to_le16(0xffff))) {\n\t\t/* Grab a network off the free list */\n\t\tif (!list_empty(&ai->network_free_list)) {\n\t\t\ttmp_net = list_entry(ai->network_free_list.next,\n\t\t\t\t\t    BSSListElement, list);\n\t\t\tlist_del(ai->network_free_list.next);\n\t\t}\n\n\t\tif (tmp_net != NULL) {\n\t\t\tmemcpy(tmp_net, &bss, sizeof(tmp_net->bss));\n\t\t\tlist_add_tail(&tmp_net->list, &ai->network_list);\n\t\t\ttmp_net = NULL;\n\t\t}\n\n\t\t/* Read next entry */\n\t\trc = PC4500_readrid(ai, ai->bssListNext,\n\t\t\t\t    &bss, ai->bssListRidLen, 0);\n\t}\n\nout:\n\tai->scan_timeout = 0;\n\tclear_bit(JOB_SCAN_RESULTS, &ai->jobs);\n\tup(&ai->sem);\n\n\t/* Send an empty event to user space.\n\t * We don't send the received data on\n\t * the event because it would require\n\t * us to do complex transcoding, and\n\t * we want to minimise the work done in\n\t * the irq handler. Use a request to\n\t * extract the data - Jean II */\n\twrqu.data.length = 0;\n\twrqu.data.flags = 0;\n\twireless_send_event(ai->dev, SIOCGIWSCAN, &wrqu, NULL);\n}\n\nstatic int airo_thread(void *data) {\n\tstruct net_device *dev = data;\n\tstruct airo_info *ai = dev->ml_priv;\n\tint locked;\n\n\tset_freezable();\n\twhile(1) {\n\t\t/* make swsusp happy with our thread */\n\t\ttry_to_freeze();\n\n\t\tif (test_bit(JOB_DIE, &ai->jobs))\n\t\t\tbreak;\n\n\t\tif (ai->jobs) {\n\t\t\tlocked = down_interruptible(&ai->sem);\n\t\t} else {\n\t\t\twait_queue_t wait;\n\n\t\t\tinit_waitqueue_entry(&wait, current);\n\t\t\tadd_wait_queue(&ai->thr_wait, &wait);\n\t\t\tfor (;;) {\n\t\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t\t\tif (ai->jobs)\n\t\t\t\t\tbreak;\n\t\t\t\tif (ai->expires || ai->scan_timeout) {\n\t\t\t\t\tif (ai->scan_timeout &&\n\t\t\t\t\t\t\ttime_after_eq(jiffies,ai->scan_timeout)){\n\t\t\t\t\t\tset_bit(JOB_SCAN_RESULTS, &ai->jobs);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (ai->expires &&\n\t\t\t\t\t\t\ttime_after_eq(jiffies,ai->expires)){\n\t\t\t\t\t\tset_bit(JOB_AUTOWEP, &ai->jobs);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (!kthread_should_stop() &&\n\t\t\t\t\t    !freezing(current)) {\n\t\t\t\t\t\tunsigned long wake_at;\n\t\t\t\t\t\tif (!ai->expires || !ai->scan_timeout) {\n\t\t\t\t\t\t\twake_at = max(ai->expires,\n\t\t\t\t\t\t\t\tai->scan_timeout);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twake_at = min(ai->expires,\n\t\t\t\t\t\t\t\tai->scan_timeout);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tschedule_timeout(wake_at - jiffies);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else if (!kthread_should_stop() &&\n\t\t\t\t\t   !freezing(current)) {\n\t\t\t\t\tschedule();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent->state = TASK_RUNNING;\n\t\t\tremove_wait_queue(&ai->thr_wait, &wait);\n\t\t\tlocked = 1;\n\t\t}\n\n\t\tif (locked)\n\t\t\tcontinue;\n\n\t\tif (test_bit(JOB_DIE, &ai->jobs)) {\n\t\t\tup(&ai->sem);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ai->power.event || test_bit(FLAG_FLASHING, &ai->flags)) {\n\t\t\tup(&ai->sem);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (test_bit(JOB_XMIT, &ai->jobs))\n\t\t\tairo_end_xmit(dev);\n\t\telse if (test_bit(JOB_XMIT11, &ai->jobs))\n\t\t\tairo_end_xmit11(dev);\n\t\telse if (test_bit(JOB_STATS, &ai->jobs))\n\t\t\tairo_read_stats(dev);\n\t\telse if (test_bit(JOB_WSTATS, &ai->jobs))\n\t\t\tairo_read_wireless_stats(ai);\n\t\telse if (test_bit(JOB_PROMISC, &ai->jobs))\n\t\t\tairo_set_promisc(ai);\n\t\telse if (test_bit(JOB_MIC, &ai->jobs))\n\t\t\tmicinit(ai);\n\t\telse if (test_bit(JOB_EVENT, &ai->jobs))\n\t\t\tairo_send_event(dev);\n\t\telse if (test_bit(JOB_AUTOWEP, &ai->jobs))\n\t\t\ttimer_func(dev);\n\t\telse if (test_bit(JOB_SCAN_RESULTS, &ai->jobs))\n\t\t\tairo_process_scan_results(ai);\n\t\telse  /* Shouldn't get here, but we make sure to unlock */\n\t\t\tup(&ai->sem);\n\t}\n\n\treturn 0;\n}\n\nstatic int header_len(__le16 ctl)\n{\n\tu16 fc = le16_to_cpu(ctl);\n\tswitch (fc & 0xc) {\n\tcase 4:\n\t\tif ((fc & 0xe0) == 0xc0)\n\t\t\treturn 10;\t/* one-address control packet */\n\t\treturn 16;\t/* two-address control packet */\n\tcase 8:\n\t\tif ((fc & 0x300) == 0x300)\n\t\t\treturn 30;\t/* WDS packet */\n\t}\n\treturn 24;\n}\n\nstatic void airo_handle_cisco_mic(struct airo_info *ai)\n{\n\tif (test_bit(FLAG_MIC_CAPABLE, &ai->flags)) {\n\t\tset_bit(JOB_MIC, &ai->jobs);\n\t\twake_up_interruptible(&ai->thr_wait);\n\t}\n}\n\n/* Airo Status codes */\n#define STAT_NOBEACON\t0x8000 /* Loss of sync - missed beacons */\n#define STAT_MAXRETRIES\t0x8001 /* Loss of sync - max retries */\n#define STAT_MAXARL\t0x8002 /* Loss of sync - average retry level exceeded*/\n#define STAT_FORCELOSS\t0x8003 /* Loss of sync - host request */\n#define STAT_TSFSYNC\t0x8004 /* Loss of sync - TSF synchronization */\n#define STAT_DEAUTH\t0x8100 /* low byte is 802.11 reason code */\n#define STAT_DISASSOC\t0x8200 /* low byte is 802.11 reason code */\n#define STAT_ASSOC_FAIL\t0x8400 /* low byte is 802.11 reason code */\n#define STAT_AUTH_FAIL\t0x0300 /* low byte is 802.11 reason code */\n#define STAT_ASSOC\t0x0400 /* Associated */\n#define STAT_REASSOC    0x0600 /* Reassociated?  Only on firmware >= 5.30.17 */\n\nstatic void airo_print_status(const char *devname, u16 status)\n{\n\tu8 reason = status & 0xFF;\n\n\tswitch (status & 0xFF00) {\n\tcase STAT_NOBEACON:\n\t\tswitch (status) {\n\t\tcase STAT_NOBEACON:\n\t\t\tairo_print_dbg(devname, \"link lost (missed beacons)\");\n\t\t\tbreak;\n\t\tcase STAT_MAXRETRIES:\n\t\tcase STAT_MAXARL:\n\t\t\tairo_print_dbg(devname, \"link lost (max retries)\");\n\t\t\tbreak;\n\t\tcase STAT_FORCELOSS:\n\t\t\tairo_print_dbg(devname, \"link lost (local choice)\");\n\t\t\tbreak;\n\t\tcase STAT_TSFSYNC:\n\t\t\tairo_print_dbg(devname, \"link lost (TSF sync lost)\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tairo_print_dbg(devname, \"unknow status %x\\n\", status);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase STAT_DEAUTH:\n\t\tairo_print_dbg(devname, \"deauthenticated (reason: %d)\", reason);\n\t\tbreak;\n\tcase STAT_DISASSOC:\n\t\tairo_print_dbg(devname, \"disassociated (reason: %d)\", reason);\n\t\tbreak;\n\tcase STAT_ASSOC_FAIL:\n\t\tairo_print_dbg(devname, \"association failed (reason: %d)\",\n\t\t\t       reason);\n\t\tbreak;\n\tcase STAT_AUTH_FAIL:\n\t\tairo_print_dbg(devname, \"authentication failed (reason: %d)\",\n\t\t\t       reason);\n\t\tbreak;\n\tcase STAT_ASSOC:\n\tcase STAT_REASSOC:\n\t\tbreak;\n\tdefault:\n\t\tairo_print_dbg(devname, \"unknow status %x\\n\", status);\n\t\tbreak;\n\t}\n}\n\nstatic void airo_handle_link(struct airo_info *ai)\n{\n\tunion iwreq_data wrqu;\n\tint scan_forceloss = 0;\n\tu16 status;\n\n\t/* Get new status and acknowledge the link change */\n\tstatus = le16_to_cpu(IN4500(ai, LINKSTAT));\n\tOUT4500(ai, EVACK, EV_LINK);\n\n\tif ((status == STAT_FORCELOSS) && (ai->scan_timeout > 0))\n\t\tscan_forceloss = 1;\n\n\tairo_print_status(ai->dev->name, status);\n\n\tif ((status == STAT_ASSOC) || (status == STAT_REASSOC)) {\n\t\tif (auto_wep)\n\t\t\tai->expires = 0;\n\t\tif (ai->list_bss_task)\n\t\t\twake_up_process(ai->list_bss_task);\n\t\tset_bit(FLAG_UPDATE_UNI, &ai->flags);\n\t\tset_bit(FLAG_UPDATE_MULTI, &ai->flags);\n\n\t\tif (down_trylock(&ai->sem) != 0) {\n\t\t\tset_bit(JOB_EVENT, &ai->jobs);\n\t\t\twake_up_interruptible(&ai->thr_wait);\n\t\t} else\n\t\t\tairo_send_event(ai->dev);\n\t} else if (!scan_forceloss) {\n\t\tif (auto_wep && !ai->expires) {\n\t\t\tai->expires = RUN_AT(3*HZ);\n\t\t\twake_up_interruptible(&ai->thr_wait);\n\t\t}\n\n\t\t/* Send event to user space */\n\t\tmemset(wrqu.ap_addr.sa_data, '\\0', ETH_ALEN);\n\t\twrqu.ap_addr.sa_family = ARPHRD_ETHER;\n\t\twireless_send_event(ai->dev, SIOCGIWAP, &wrqu, NULL);\n\t}\n}\n\nstatic void airo_handle_rx(struct airo_info *ai)\n{\n\tstruct sk_buff *skb = NULL;\n\t__le16 fc, v, *buffer, tmpbuf[4];\n\tu16 len, hdrlen = 0, gap, fid;\n\tstruct rx_hdr hdr;\n\tint success = 0;\n\n\tif (test_bit(FLAG_MPI, &ai->flags)) {\n\t\tif (test_bit(FLAG_802_11, &ai->flags))\n\t\t\tmpi_receive_802_11(ai);\n\t\telse\n\t\t\tmpi_receive_802_3(ai);\n\t\tOUT4500(ai, EVACK, EV_RX);\n\t\treturn;\n\t}\n\n\tfid = IN4500(ai, RXFID);\n\n\t/* Get the packet length */\n\tif (test_bit(FLAG_802_11, &ai->flags)) {\n\t\tbap_setup (ai, fid, 4, BAP0);\n\t\tbap_read (ai, (__le16*)&hdr, sizeof(hdr), BAP0);\n\t\t/* Bad CRC. Ignore packet */\n\t\tif (le16_to_cpu(hdr.status) & 2)\n\t\t\thdr.len = 0;\n\t\tif (ai->wifidev == NULL)\n\t\t\thdr.len = 0;\n\t} else {\n\t\tbap_setup(ai, fid, 0x36, BAP0);\n\t\tbap_read(ai, &hdr.len, 2, BAP0);\n\t}\n\tlen = le16_to_cpu(hdr.len);\n\n\tif (len > AIRO_DEF_MTU) {\n\t\tairo_print_err(ai->dev->name, \"Bad size %d\", len);\n\t\tgoto done;\n\t}\n\tif (len == 0)\n\t\tgoto done;\n\n\tif (test_bit(FLAG_802_11, &ai->flags)) {\n\t\tbap_read(ai, &fc, sizeof (fc), BAP0);\n\t\thdrlen = header_len(fc);\n\t} else\n\t\thdrlen = ETH_ALEN * 2;\n\n\tskb = dev_alloc_skb(len + hdrlen + 2 + 2);\n\tif (!skb) {\n\t\tai->dev->stats.rx_dropped++;\n\t\tgoto done;\n\t}\n\n\tskb_reserve(skb, 2); /* This way the IP header is aligned */\n\tbuffer = (__le16 *) skb_put(skb, len + hdrlen);\n\tif (test_bit(FLAG_802_11, &ai->flags)) {\n\t\tbuffer[0] = fc;\n\t\tbap_read(ai, buffer + 1, hdrlen - 2, BAP0);\n\t\tif (hdrlen == 24)\n\t\t\tbap_read(ai, tmpbuf, 6, BAP0);\n\n\t\tbap_read(ai, &v, sizeof(v), BAP0);\n\t\tgap = le16_to_cpu(v);\n\t\tif (gap) {\n\t\t\tif (gap <= 8) {\n\t\t\t\tbap_read(ai, tmpbuf, gap, BAP0);\n\t\t\t} else {\n\t\t\t\tairo_print_err(ai->dev->name, \"gaplen too \"\n\t\t\t\t\t\"big. Problems will follow...\");\n\t\t\t}\n\t\t}\n\t\tbap_read(ai, buffer + hdrlen/2, len, BAP0);\n\t} else {\n\t\tMICBuffer micbuf;\n\n\t\tbap_read(ai, buffer, ETH_ALEN * 2, BAP0);\n\t\tif (ai->micstats.enabled) {\n\t\t\tbap_read(ai, (__le16 *) &micbuf, sizeof (micbuf), BAP0);\n\t\t\tif (ntohs(micbuf.typelen) > 0x05DC)\n\t\t\t\tbap_setup(ai, fid, 0x44, BAP0);\n\t\t\telse {\n\t\t\t\tif (len <= sizeof (micbuf)) {\n\t\t\t\t\tdev_kfree_skb_irq(skb);\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\n\t\t\t\tlen -= sizeof(micbuf);\n\t\t\t\tskb_trim(skb, len + hdrlen);\n\t\t\t}\n\t\t}\n\n\t\tbap_read(ai, buffer + ETH_ALEN, len, BAP0);\n\t\tif (decapsulate(ai, &micbuf, (etherHead*) buffer, len))\n\t\t\tdev_kfree_skb_irq (skb);\n\t\telse\n\t\t\tsuccess = 1;\n\t}\n\n#ifdef WIRELESS_SPY\n\tif (success && (ai->spy_data.spy_number > 0)) {\n\t\tchar *sa;\n\t\tstruct iw_quality wstats;\n\n\t\t/* Prepare spy data : addr + qual */\n\t\tif (!test_bit(FLAG_802_11, &ai->flags)) {\n\t\t\tsa = (char *) buffer + 6;\n\t\t\tbap_setup(ai, fid, 8, BAP0);\n\t\t\tbap_read(ai, (__le16 *) hdr.rssi, 2, BAP0);\n\t\t} else\n\t\t\tsa = (char *) buffer + 10;\n\t\twstats.qual = hdr.rssi[0];\n\t\tif (ai->rssi)\n\t\t\twstats.level = 0x100 - ai->rssi[hdr.rssi[1]].rssidBm;\n\t\telse\n\t\t\twstats.level = (hdr.rssi[1] + 321) / 2;\n\t\twstats.noise = ai->wstats.qual.noise;\n\t\twstats.updated =  IW_QUAL_LEVEL_UPDATED\n\t\t\t\t| IW_QUAL_QUAL_UPDATED\n\t\t\t\t| IW_QUAL_DBM;\n\t\t/* Update spy records */\n\t\twireless_spy_update(ai->dev, sa, &wstats);\n\t}\n#endif /* WIRELESS_SPY */\n\ndone:\n\tOUT4500(ai, EVACK, EV_RX);\n\n\tif (success) {\n\t\tif (test_bit(FLAG_802_11, &ai->flags)) {\n\t\t\tskb_reset_mac_header(skb);\n\t\t\tskb->pkt_type = PACKET_OTHERHOST;\n\t\t\tskb->dev = ai->wifidev;\n\t\t\tskb->protocol = htons(ETH_P_802_2);\n\t\t} else\n\t\t\tskb->protocol = eth_type_trans(skb, ai->dev);\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\n\t\tnetif_rx(skb);\n\t}\n}\n\nstatic void airo_handle_tx(struct airo_info *ai, u16 status)\n{\n\tint i, len = 0, index = -1;\n\tu16 fid;\n\n\tif (test_bit(FLAG_MPI, &ai->flags)) {\n\t\tunsigned long flags;\n\n\t\tif (status & EV_TXEXC)\n\t\t\tget_tx_error(ai, -1);\n\n\t\tspin_lock_irqsave(&ai->aux_lock, flags);\n\t\tif (!skb_queue_empty(&ai->txq)) {\n\t\t\tspin_unlock_irqrestore(&ai->aux_lock,flags);\n\t\t\tmpi_send_packet(ai->dev);\n\t\t} else {\n\t\t\tclear_bit(FLAG_PENDING_XMIT, &ai->flags);\n\t\t\tspin_unlock_irqrestore(&ai->aux_lock,flags);\n\t\t\tnetif_wake_queue(ai->dev);\n\t\t}\n\t\tOUT4500(ai, EVACK, status & (EV_TX | EV_TXCPY | EV_TXEXC));\n\t\treturn;\n\t}\n\n\tfid = IN4500(ai, TXCOMPLFID);\n\n\tfor(i = 0; i < MAX_FIDS; i++) {\n\t\tif ((ai->fids[i] & 0xffff) == fid) {\n\t\t\tlen = ai->fids[i] >> 16;\n\t\t\tindex = i;\n\t\t}\n\t}\n\n\tif (index != -1) {\n\t\tif (status & EV_TXEXC)\n\t\t\tget_tx_error(ai, index);\n\n\t\tOUT4500(ai, EVACK, status & (EV_TX | EV_TXEXC));\n\n\t\t/* Set up to be used again */\n\t\tai->fids[index] &= 0xffff;\n\t\tif (index < MAX_FIDS / 2) {\n\t\t\tif (!test_bit(FLAG_PENDING_XMIT, &ai->flags))\n\t\t\t\tnetif_wake_queue(ai->dev);\n\t\t} else {\n\t\t\tif (!test_bit(FLAG_PENDING_XMIT11, &ai->flags))\n\t\t\t\tnetif_wake_queue(ai->wifidev);\n\t\t}\n\t} else {\n\t\tOUT4500(ai, EVACK, status & (EV_TX | EV_TXCPY | EV_TXEXC));\n\t\tairo_print_err(ai->dev->name, \"Unallocated FID was used to xmit\");\n\t}\n}\n\nstatic irqreturn_t airo_interrupt(int irq, void *dev_id)\n{\n\tstruct net_device *dev = dev_id;\n\tu16 status, savedInterrupts = 0;\n\tstruct airo_info *ai = dev->ml_priv;\n\tint handled = 0;\n\n\tif (!netif_device_present(dev))\n\t\treturn IRQ_NONE;\n\n\tfor (;;) {\n\t\tstatus = IN4500(ai, EVSTAT);\n\t\tif (!(status & STATUS_INTS) || (status == 0xffff))\n\t\t\tbreak;\n\n\t\thandled = 1;\n\n\t\tif (status & EV_AWAKE) {\n\t\t\tOUT4500(ai, EVACK, EV_AWAKE);\n\t\t\tOUT4500(ai, EVACK, EV_AWAKE);\n\t\t}\n\n\t\tif (!savedInterrupts) {\n\t\t\tsavedInterrupts = IN4500(ai, EVINTEN);\n\t\t\tOUT4500(ai, EVINTEN, 0);\n\t\t}\n\n\t\tif (status & EV_MIC) {\n\t\t\tOUT4500(ai, EVACK, EV_MIC);\n\t\t\tairo_handle_cisco_mic(ai);\n\t\t}\n\n\t\tif (status & EV_LINK) {\n\t\t\t/* Link status changed */\n\t\t\tairo_handle_link(ai);\n\t\t}\n\n\t\t/* Check to see if there is something to receive */\n\t\tif (status & EV_RX)\n\t\t\tairo_handle_rx(ai);\n\n\t\t/* Check to see if a packet has been transmitted */\n\t\tif (status & (EV_TX | EV_TXCPY | EV_TXEXC))\n\t\t\tairo_handle_tx(ai, status);\n\n\t\tif ( status & ~STATUS_INTS & ~IGNORE_INTS ) {\n\t\t\tairo_print_warn(ai->dev->name, \"Got weird status %x\",\n\t\t\t\tstatus & ~STATUS_INTS & ~IGNORE_INTS );\n\t\t}\n\t}\n\n\tif (savedInterrupts)\n\t\tOUT4500(ai, EVINTEN, savedInterrupts);\n\n\treturn IRQ_RETVAL(handled);\n}\n\n/*\n *  Routines to talk to the card\n */\n\n/*\n *  This was originally written for the 4500, hence the name\n *  NOTE:  If use with 8bit mode and SMP bad things will happen!\n *         Why would some one do 8 bit IO in an SMP machine?!?\n */\nstatic void OUT4500( struct airo_info *ai, u16 reg, u16 val ) {\n\tif (test_bit(FLAG_MPI,&ai->flags))\n\t\treg <<= 1;\n\tif ( !do8bitIO )\n\t\toutw( val, ai->dev->base_addr + reg );\n\telse {\n\t\toutb( val & 0xff, ai->dev->base_addr + reg );\n\t\toutb( val >> 8, ai->dev->base_addr + reg + 1 );\n\t}\n}\n\nstatic u16 IN4500( struct airo_info *ai, u16 reg ) {\n\tunsigned short rc;\n\n\tif (test_bit(FLAG_MPI,&ai->flags))\n\t\treg <<= 1;\n\tif ( !do8bitIO )\n\t\trc = inw( ai->dev->base_addr + reg );\n\telse {\n\t\trc = inb( ai->dev->base_addr + reg );\n\t\trc += ((int)inb( ai->dev->base_addr + reg + 1 )) << 8;\n\t}\n\treturn rc;\n}\n\nstatic int enable_MAC(struct airo_info *ai, int lock)\n{\n\tint rc;\n\tCmd cmd;\n\tResp rsp;\n\n\t/* FLAG_RADIO_OFF : Radio disabled via /proc or Wireless Extensions\n\t * FLAG_RADIO_DOWN : Radio disabled via \"ifconfig ethX down\"\n\t * Note : we could try to use !netif_running(dev) in enable_MAC()\n\t * instead of this flag, but I don't trust it *within* the\n\t * open/close functions, and testing both flags together is\n\t * \"cheaper\" - Jean II */\n\tif (ai->flags & FLAG_RADIO_MASK) return SUCCESS;\n\n\tif (lock && down_interruptible(&ai->sem))\n\t\treturn -ERESTARTSYS;\n\n\tif (!test_bit(FLAG_ENABLED, &ai->flags)) {\n\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\tcmd.cmd = MAC_ENABLE;\n\t\trc = issuecommand(ai, &cmd, &rsp);\n\t\tif (rc == SUCCESS)\n\t\t\tset_bit(FLAG_ENABLED, &ai->flags);\n\t} else\n\t\trc = SUCCESS;\n\n\tif (lock)\n\t    up(&ai->sem);\n\n\tif (rc)\n\t\tairo_print_err(ai->dev->name, \"Cannot enable MAC\");\n\telse if ((rsp.status & 0xFF00) != 0) {\n\t\tairo_print_err(ai->dev->name, \"Bad MAC enable reason=%x, \"\n\t\t\t\"rid=%x, offset=%d\", rsp.rsp0, rsp.rsp1, rsp.rsp2);\n\t\trc = ERROR;\n\t}\n\treturn rc;\n}\n\nstatic void disable_MAC( struct airo_info *ai, int lock ) {\n        Cmd cmd;\n\tResp rsp;\n\n\tif (lock && down_interruptible(&ai->sem))\n\t\treturn;\n\n\tif (test_bit(FLAG_ENABLED, &ai->flags)) {\n\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\tcmd.cmd = MAC_DISABLE; // disable in case already enabled\n\t\tissuecommand(ai, &cmd, &rsp);\n\t\tclear_bit(FLAG_ENABLED, &ai->flags);\n\t}\n\tif (lock)\n\t\tup(&ai->sem);\n}\n\nstatic void enable_interrupts( struct airo_info *ai ) {\n\t/* Enable the interrupts */\n\tOUT4500( ai, EVINTEN, STATUS_INTS );\n}\n\nstatic void disable_interrupts( struct airo_info *ai ) {\n\tOUT4500( ai, EVINTEN, 0 );\n}\n\nstatic void mpi_receive_802_3(struct airo_info *ai)\n{\n\tRxFid rxd;\n\tint len = 0;\n\tstruct sk_buff *skb;\n\tchar *buffer;\n\tint off = 0;\n\tMICBuffer micbuf;\n\n\tmemcpy_fromio(&rxd, ai->rxfids[0].card_ram_off, sizeof(rxd));\n\t/* Make sure we got something */\n\tif (rxd.rdy && rxd.valid == 0) {\n\t\tlen = rxd.len + 12;\n\t\tif (len < 12 || len > 2048)\n\t\t\tgoto badrx;\n\n\t\tskb = dev_alloc_skb(len);\n\t\tif (!skb) {\n\t\t\tai->dev->stats.rx_dropped++;\n\t\t\tgoto badrx;\n\t\t}\n\t\tbuffer = skb_put(skb,len);\n\t\tmemcpy(buffer, ai->rxfids[0].virtual_host_addr, ETH_ALEN * 2);\n\t\tif (ai->micstats.enabled) {\n\t\t\tmemcpy(&micbuf,\n\t\t\t\tai->rxfids[0].virtual_host_addr + ETH_ALEN * 2,\n\t\t\t\tsizeof(micbuf));\n\t\t\tif (ntohs(micbuf.typelen) <= 0x05DC) {\n\t\t\t\tif (len <= sizeof(micbuf) + ETH_ALEN * 2)\n\t\t\t\t\tgoto badmic;\n\n\t\t\t\toff = sizeof(micbuf);\n\t\t\t\tskb_trim (skb, len - off);\n\t\t\t}\n\t\t}\n\t\tmemcpy(buffer + ETH_ALEN * 2,\n\t\t\tai->rxfids[0].virtual_host_addr + ETH_ALEN * 2 + off,\n\t\t\tlen - ETH_ALEN * 2 - off);\n\t\tif (decapsulate (ai, &micbuf, (etherHead*)buffer, len - off - ETH_ALEN * 2)) {\nbadmic:\n\t\t\tdev_kfree_skb_irq (skb);\n\t\t\tgoto badrx;\n\t\t}\n#ifdef WIRELESS_SPY\n\t\tif (ai->spy_data.spy_number > 0) {\n\t\t\tchar *sa;\n\t\t\tstruct iw_quality wstats;\n\t\t\t/* Prepare spy data : addr + qual */\n\t\t\tsa = buffer + ETH_ALEN;\n\t\t\twstats.qual = 0; /* XXX Where do I get that info from ??? */\n\t\t\twstats.level = 0;\n\t\t\twstats.updated = 0;\n\t\t\t/* Update spy records */\n\t\t\twireless_spy_update(ai->dev, sa, &wstats);\n\t\t}\n#endif /* WIRELESS_SPY */\n\n\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\tskb->protocol = eth_type_trans(skb, ai->dev);\n\t\tnetif_rx(skb);\n\t}\nbadrx:\n\tif (rxd.valid == 0) {\n\t\trxd.valid = 1;\n\t\trxd.rdy = 0;\n\t\trxd.len = PKTSIZE;\n\t\tmemcpy_toio(ai->rxfids[0].card_ram_off, &rxd, sizeof(rxd));\n\t}\n}\n\nstatic void mpi_receive_802_11(struct airo_info *ai)\n{\n\tRxFid rxd;\n\tstruct sk_buff *skb = NULL;\n\tu16 len, hdrlen = 0;\n\t__le16 fc;\n\tstruct rx_hdr hdr;\n\tu16 gap;\n\tu16 *buffer;\n\tchar *ptr = ai->rxfids[0].virtual_host_addr + 4;\n\n\tmemcpy_fromio(&rxd, ai->rxfids[0].card_ram_off, sizeof(rxd));\n\tmemcpy ((char *)&hdr, ptr, sizeof(hdr));\n\tptr += sizeof(hdr);\n\t/* Bad CRC. Ignore packet */\n\tif (le16_to_cpu(hdr.status) & 2)\n\t\thdr.len = 0;\n\tif (ai->wifidev == NULL)\n\t\thdr.len = 0;\n\tlen = le16_to_cpu(hdr.len);\n\tif (len > AIRO_DEF_MTU) {\n\t\tairo_print_err(ai->dev->name, \"Bad size %d\", len);\n\t\tgoto badrx;\n\t}\n\tif (len == 0)\n\t\tgoto badrx;\n\n\tfc = get_unaligned((__le16 *)ptr);\n\thdrlen = header_len(fc);\n\n\tskb = dev_alloc_skb( len + hdrlen + 2 );\n\tif ( !skb ) {\n\t\tai->dev->stats.rx_dropped++;\n\t\tgoto badrx;\n\t}\n\tbuffer = (u16*)skb_put (skb, len + hdrlen);\n\tmemcpy ((char *)buffer, ptr, hdrlen);\n\tptr += hdrlen;\n\tif (hdrlen == 24)\n\t\tptr += 6;\n\tgap = get_unaligned_le16(ptr);\n\tptr += sizeof(__le16);\n\tif (gap) {\n\t\tif (gap <= 8)\n\t\t\tptr += gap;\n\t\telse\n\t\t\tairo_print_err(ai->dev->name,\n\t\t\t    \"gaplen too big. Problems will follow...\");\n\t}\n\tmemcpy ((char *)buffer + hdrlen, ptr, len);\n\tptr += len;\n#ifdef IW_WIRELESS_SPY\t  /* defined in iw_handler.h */\n\tif (ai->spy_data.spy_number > 0) {\n\t\tchar *sa;\n\t\tstruct iw_quality wstats;\n\t\t/* Prepare spy data : addr + qual */\n\t\tsa = (char*)buffer + 10;\n\t\twstats.qual = hdr.rssi[0];\n\t\tif (ai->rssi)\n\t\t\twstats.level = 0x100 - ai->rssi[hdr.rssi[1]].rssidBm;\n\t\telse\n\t\t\twstats.level = (hdr.rssi[1] + 321) / 2;\n\t\twstats.noise = ai->wstats.qual.noise;\n\t\twstats.updated = IW_QUAL_QUAL_UPDATED\n\t\t\t| IW_QUAL_LEVEL_UPDATED\n\t\t\t| IW_QUAL_DBM;\n\t\t/* Update spy records */\n\t\twireless_spy_update(ai->dev, sa, &wstats);\n\t}\n#endif /* IW_WIRELESS_SPY */\n\tskb_reset_mac_header(skb);\n\tskb->pkt_type = PACKET_OTHERHOST;\n\tskb->dev = ai->wifidev;\n\tskb->protocol = htons(ETH_P_802_2);\n\tskb->ip_summed = CHECKSUM_NONE;\n\tnetif_rx( skb );\n\nbadrx:\n\tif (rxd.valid == 0) {\n\t\trxd.valid = 1;\n\t\trxd.rdy = 0;\n\t\trxd.len = PKTSIZE;\n\t\tmemcpy_toio(ai->rxfids[0].card_ram_off, &rxd, sizeof(rxd));\n\t}\n}\n\nstatic u16 setup_card(struct airo_info *ai, u8 *mac, int lock)\n{\n\tCmd cmd;\n\tResp rsp;\n\tint status;\n\tSsidRid mySsid;\n\t__le16 lastindex;\n\tWepKeyRid wkr;\n\tint rc;\n\n\tmemset( &mySsid, 0, sizeof( mySsid ) );\n\tkfree (ai->flash);\n\tai->flash = NULL;\n\n\t/* The NOP is the first step in getting the card going */\n\tcmd.cmd = NOP;\n\tcmd.parm0 = cmd.parm1 = cmd.parm2 = 0;\n\tif (lock && down_interruptible(&ai->sem))\n\t\treturn ERROR;\n\tif ( issuecommand( ai, &cmd, &rsp ) != SUCCESS ) {\n\t\tif (lock)\n\t\t\tup(&ai->sem);\n\t\treturn ERROR;\n\t}\n\tdisable_MAC( ai, 0);\n\n\t// Let's figure out if we need to use the AUX port\n\tif (!test_bit(FLAG_MPI,&ai->flags)) {\n\t\tcmd.cmd = CMD_ENABLEAUX;\n\t\tif (issuecommand(ai, &cmd, &rsp) != SUCCESS) {\n\t\t\tif (lock)\n\t\t\t\tup(&ai->sem);\n\t\t\tairo_print_err(ai->dev->name, \"Error checking for AUX port\");\n\t\t\treturn ERROR;\n\t\t}\n\t\tif (!aux_bap || rsp.status & 0xff00) {\n\t\t\tai->bap_read = fast_bap_read;\n\t\t\tairo_print_dbg(ai->dev->name, \"Doing fast bap_reads\");\n\t\t} else {\n\t\t\tai->bap_read = aux_bap_read;\n\t\t\tairo_print_dbg(ai->dev->name, \"Doing AUX bap_reads\");\n\t\t}\n\t}\n\tif (lock)\n\t\tup(&ai->sem);\n\tif (ai->config.len == 0) {\n\t\tint i;\n\t\ttdsRssiRid rssi_rid;\n\t\tCapabilityRid cap_rid;\n\n\t\tkfree(ai->APList);\n\t\tai->APList = NULL;\n\t\tkfree(ai->SSID);\n\t\tai->SSID = NULL;\n\t\t// general configuration (read/modify/write)\n\t\tstatus = readConfigRid(ai, lock);\n\t\tif ( status != SUCCESS ) return ERROR;\n\n\t\tstatus = readCapabilityRid(ai, &cap_rid, lock);\n\t\tif ( status != SUCCESS ) return ERROR;\n\n\t\tstatus = PC4500_readrid(ai,RID_RSSI,&rssi_rid,sizeof(rssi_rid),lock);\n\t\tif ( status == SUCCESS ) {\n\t\t\tif (ai->rssi || (ai->rssi = kmalloc(512, GFP_KERNEL)) != NULL)\n\t\t\t\tmemcpy(ai->rssi, (u8*)&rssi_rid + 2, 512); /* Skip RID length member */\n\t\t}\n\t\telse {\n\t\t\tkfree(ai->rssi);\n\t\t\tai->rssi = NULL;\n\t\t\tif (cap_rid.softCap & cpu_to_le16(8))\n\t\t\t\tai->config.rmode |= RXMODE_NORMALIZED_RSSI;\n\t\t\telse\n\t\t\t\tairo_print_warn(ai->dev->name, \"unknown received signal \"\n\t\t\t\t\t\t\"level scale\");\n\t\t}\n\t\tai->config.opmode = adhoc ? MODE_STA_IBSS : MODE_STA_ESS;\n\t\tai->config.authType = AUTH_OPEN;\n\t\tai->config.modulation = MOD_CCK;\n\n\t\tif (le16_to_cpu(cap_rid.len) >= sizeof(cap_rid) &&\n\t\t    (cap_rid.extSoftCap & cpu_to_le16(1)) &&\n\t\t    micsetup(ai) == SUCCESS) {\n\t\t\tai->config.opmode |= MODE_MIC;\n\t\t\tset_bit(FLAG_MIC_CAPABLE, &ai->flags);\n\t\t}\n\n\t\t/* Save off the MAC */\n\t\tfor( i = 0; i < ETH_ALEN; i++ ) {\n\t\t\tmac[i] = ai->config.macAddr[i];\n\t\t}\n\n\t\t/* Check to see if there are any insmod configured\n\t\t   rates to add */\n\t\tif ( rates[0] ) {\n\t\t\tmemset(ai->config.rates,0,sizeof(ai->config.rates));\n\t\t\tfor( i = 0; i < 8 && rates[i]; i++ ) {\n\t\t\t\tai->config.rates[i] = rates[i];\n\t\t\t}\n\t\t}\n\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t}\n\n\t/* Setup the SSIDs if present */\n\tif ( ssids[0] ) {\n\t\tint i;\n\t\tfor( i = 0; i < 3 && ssids[i]; i++ ) {\n\t\t\tsize_t len = strlen(ssids[i]);\n\t\t\tif (len > 32)\n\t\t\t\tlen = 32;\n\t\t\tmySsid.ssids[i].len = cpu_to_le16(len);\n\t\t\tmemcpy(mySsid.ssids[i].ssid, ssids[i], len);\n\t\t}\n\t\tmySsid.len = cpu_to_le16(sizeof(mySsid));\n\t}\n\n\tstatus = writeConfigRid(ai, lock);\n\tif ( status != SUCCESS ) return ERROR;\n\n\t/* Set up the SSID list */\n\tif ( ssids[0] ) {\n\t\tstatus = writeSsidRid(ai, &mySsid, lock);\n\t\tif ( status != SUCCESS ) return ERROR;\n\t}\n\n\tstatus = enable_MAC(ai, lock);\n\tif (status != SUCCESS)\n\t\treturn ERROR;\n\n\t/* Grab the initial wep key, we gotta save it for auto_wep */\n\trc = readWepKeyRid(ai, &wkr, 1, lock);\n\tif (rc == SUCCESS) do {\n\t\tlastindex = wkr.kindex;\n\t\tif (wkr.kindex == cpu_to_le16(0xffff)) {\n\t\t\tai->defindex = wkr.mac[0];\n\t\t}\n\t\trc = readWepKeyRid(ai, &wkr, 0, lock);\n\t} while(lastindex != wkr.kindex);\n\n\ttry_auto_wep(ai);\n\n\treturn SUCCESS;\n}\n\nstatic u16 issuecommand(struct airo_info *ai, Cmd *pCmd, Resp *pRsp) {\n        // Im really paranoid about letting it run forever!\n\tint max_tries = 600000;\n\n\tif (IN4500(ai, EVSTAT) & EV_CMD)\n\t\tOUT4500(ai, EVACK, EV_CMD);\n\n\tOUT4500(ai, PARAM0, pCmd->parm0);\n\tOUT4500(ai, PARAM1, pCmd->parm1);\n\tOUT4500(ai, PARAM2, pCmd->parm2);\n\tOUT4500(ai, COMMAND, pCmd->cmd);\n\n\twhile (max_tries-- && (IN4500(ai, EVSTAT) & EV_CMD) == 0) {\n\t\tif ((IN4500(ai, COMMAND)) == pCmd->cmd)\n\t\t\t// PC4500 didn't notice command, try again\n\t\t\tOUT4500(ai, COMMAND, pCmd->cmd);\n\t\tif (!in_atomic() && (max_tries & 255) == 0)\n\t\t\tschedule();\n\t}\n\n\tif ( max_tries == -1 ) {\n\t\tairo_print_err(ai->dev->name,\n\t\t\t\"Max tries exceeded when issuing command\");\n\t\tif (IN4500(ai, COMMAND) & COMMAND_BUSY)\n\t\t\tOUT4500(ai, EVACK, EV_CLEARCOMMANDBUSY);\n\t\treturn ERROR;\n\t}\n\n\t// command completed\n\tpRsp->status = IN4500(ai, STATUS);\n\tpRsp->rsp0 = IN4500(ai, RESP0);\n\tpRsp->rsp1 = IN4500(ai, RESP1);\n\tpRsp->rsp2 = IN4500(ai, RESP2);\n\tif ((pRsp->status & 0xff00)!=0 && pCmd->cmd != CMD_SOFTRESET)\n\t\tairo_print_err(ai->dev->name,\n\t\t\t\"cmd:%x status:%x rsp0:%x rsp1:%x rsp2:%x\",\n\t\t\tpCmd->cmd, pRsp->status, pRsp->rsp0, pRsp->rsp1,\n\t\t\tpRsp->rsp2);\n\n\t// clear stuck command busy if necessary\n\tif (IN4500(ai, COMMAND) & COMMAND_BUSY) {\n\t\tOUT4500(ai, EVACK, EV_CLEARCOMMANDBUSY);\n\t}\n\t// acknowledge processing the status/response\n\tOUT4500(ai, EVACK, EV_CMD);\n\n\treturn SUCCESS;\n}\n\n/* Sets up the bap to start exchange data.  whichbap should\n * be one of the BAP0 or BAP1 defines.  Locks should be held before\n * calling! */\nstatic int bap_setup(struct airo_info *ai, u16 rid, u16 offset, int whichbap )\n{\n\tint timeout = 50;\n\tint max_tries = 3;\n\n\tOUT4500(ai, SELECT0+whichbap, rid);\n\tOUT4500(ai, OFFSET0+whichbap, offset);\n\twhile (1) {\n\t\tint status = IN4500(ai, OFFSET0+whichbap);\n\t\tif (status & BAP_BUSY) {\n                        /* This isn't really a timeout, but its kinda\n\t\t\t   close */\n\t\t\tif (timeout--) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else if ( status & BAP_ERR ) {\n\t\t\t/* invalid rid or offset */\n\t\t\tairo_print_err(ai->dev->name, \"BAP error %x %d\",\n\t\t\t\tstatus, whichbap );\n\t\t\treturn ERROR;\n\t\t} else if (status & BAP_DONE) { // success\n\t\t\treturn SUCCESS;\n\t\t}\n\t\tif ( !(max_tries--) ) {\n\t\t\tairo_print_err(ai->dev->name,\n\t\t\t\t\"BAP setup error too many retries\\n\");\n\t\t\treturn ERROR;\n\t\t}\n\t\t// -- PC4500 missed it, try again\n\t\tOUT4500(ai, SELECT0+whichbap, rid);\n\t\tOUT4500(ai, OFFSET0+whichbap, offset);\n\t\ttimeout = 50;\n\t}\n}\n\n/* should only be called by aux_bap_read.  This aux function and the\n   following use concepts not documented in the developers guide.  I\n   got them from a patch given to my by Aironet */\nstatic u16 aux_setup(struct airo_info *ai, u16 page,\n\t\t     u16 offset, u16 *len)\n{\n\tu16 next;\n\n\tOUT4500(ai, AUXPAGE, page);\n\tOUT4500(ai, AUXOFF, 0);\n\tnext = IN4500(ai, AUXDATA);\n\t*len = IN4500(ai, AUXDATA)&0xff;\n\tif (offset != 4) OUT4500(ai, AUXOFF, offset);\n\treturn next;\n}\n\n/* requires call to bap_setup() first */\nstatic int aux_bap_read(struct airo_info *ai, __le16 *pu16Dst,\n\t\t\tint bytelen, int whichbap)\n{\n\tu16 len;\n\tu16 page;\n\tu16 offset;\n\tu16 next;\n\tint words;\n\tint i;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&ai->aux_lock, flags);\n\tpage = IN4500(ai, SWS0+whichbap);\n\toffset = IN4500(ai, SWS2+whichbap);\n\tnext = aux_setup(ai, page, offset, &len);\n\twords = (bytelen+1)>>1;\n\n\tfor (i=0; i<words;) {\n\t\tint count;\n\t\tcount = (len>>1) < (words-i) ? (len>>1) : (words-i);\n\t\tif ( !do8bitIO )\n\t\t\tinsw( ai->dev->base_addr+DATA0+whichbap,\n\t\t\t      pu16Dst+i,count );\n\t\telse\n\t\t\tinsb( ai->dev->base_addr+DATA0+whichbap,\n\t\t\t      pu16Dst+i, count << 1 );\n\t\ti += count;\n\t\tif (i<words) {\n\t\t\tnext = aux_setup(ai, next, 4, &len);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ai->aux_lock, flags);\n\treturn SUCCESS;\n}\n\n\n/* requires call to bap_setup() first */\nstatic int fast_bap_read(struct airo_info *ai, __le16 *pu16Dst,\n\t\t\t int bytelen, int whichbap)\n{\n\tbytelen = (bytelen + 1) & (~1); // round up to even value\n\tif ( !do8bitIO )\n\t\tinsw( ai->dev->base_addr+DATA0+whichbap, pu16Dst, bytelen>>1 );\n\telse\n\t\tinsb( ai->dev->base_addr+DATA0+whichbap, pu16Dst, bytelen );\n\treturn SUCCESS;\n}\n\n/* requires call to bap_setup() first */\nstatic int bap_write(struct airo_info *ai, const __le16 *pu16Src,\n\t\t     int bytelen, int whichbap)\n{\n\tbytelen = (bytelen + 1) & (~1); // round up to even value\n\tif ( !do8bitIO )\n\t\toutsw( ai->dev->base_addr+DATA0+whichbap,\n\t\t       pu16Src, bytelen>>1 );\n\telse\n\t\toutsb( ai->dev->base_addr+DATA0+whichbap, pu16Src, bytelen );\n\treturn SUCCESS;\n}\n\nstatic int PC4500_accessrid(struct airo_info *ai, u16 rid, u16 accmd)\n{\n\tCmd cmd; /* for issuing commands */\n\tResp rsp; /* response from commands */\n\tu16 status;\n\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.cmd = accmd;\n\tcmd.parm0 = rid;\n\tstatus = issuecommand(ai, &cmd, &rsp);\n\tif (status != 0) return status;\n\tif ( (rsp.status & 0x7F00) != 0) {\n\t\treturn (accmd << 8) + (rsp.rsp0 & 0xFF);\n\t}\n\treturn 0;\n}\n\n/*  Note, that we are using BAP1 which is also used by transmit, so\n *  we must get a lock. */\nstatic int PC4500_readrid(struct airo_info *ai, u16 rid, void *pBuf, int len, int lock)\n{\n\tu16 status;\n        int rc = SUCCESS;\n\n\tif (lock) {\n\t\tif (down_interruptible(&ai->sem))\n\t\t\treturn ERROR;\n\t}\n\tif (test_bit(FLAG_MPI,&ai->flags)) {\n\t\tCmd cmd;\n\t\tResp rsp;\n\n\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\tmemset(&rsp, 0, sizeof(rsp));\n\t\tai->config_desc.rid_desc.valid = 1;\n\t\tai->config_desc.rid_desc.len = RIDSIZE;\n\t\tai->config_desc.rid_desc.rid = 0;\n\t\tai->config_desc.rid_desc.host_addr = ai->ridbus;\n\n\t\tcmd.cmd = CMD_ACCESS;\n\t\tcmd.parm0 = rid;\n\n\t\tmemcpy_toio(ai->config_desc.card_ram_off,\n\t\t\t&ai->config_desc.rid_desc, sizeof(Rid));\n\n\t\trc = issuecommand(ai, &cmd, &rsp);\n\n\t\tif (rsp.status & 0x7f00)\n\t\t\trc = rsp.rsp0;\n\t\tif (!rc)\n\t\t\tmemcpy(pBuf, ai->config_desc.virtual_host_addr, len);\n\t\tgoto done;\n\t} else {\n\t\tif ((status = PC4500_accessrid(ai, rid, CMD_ACCESS))!=SUCCESS) {\n\t                rc = status;\n\t                goto done;\n\t        }\n\t\tif (bap_setup(ai, rid, 0, BAP1) != SUCCESS) {\n\t\t\trc = ERROR;\n\t                goto done;\n\t        }\n\t\t// read the rid length field\n\t\tbap_read(ai, pBuf, 2, BAP1);\n\t\t// length for remaining part of rid\n\t\tlen = min(len, (int)le16_to_cpu(*(__le16*)pBuf)) - 2;\n\n\t\tif ( len <= 2 ) {\n\t\t\tairo_print_err(ai->dev->name,\n\t\t\t\t\"Rid %x has a length of %d which is too short\",\n\t\t\t\t(int)rid, (int)len );\n\t\t\trc = ERROR;\n\t                goto done;\n\t\t}\n\t\t// read remainder of the rid\n\t\trc = bap_read(ai, ((__le16*)pBuf)+1, len, BAP1);\n\t}\ndone:\n\tif (lock)\n\t\tup(&ai->sem);\n\treturn rc;\n}\n\n/*  Note, that we are using BAP1 which is also used by transmit, so\n *  make sure this isn't called when a transmit is happening */\nstatic int PC4500_writerid(struct airo_info *ai, u16 rid,\n\t\t\t   const void *pBuf, int len, int lock)\n{\n\tu16 status;\n\tint rc = SUCCESS;\n\n\t*(__le16*)pBuf = cpu_to_le16((u16)len);\n\n\tif (lock) {\n\t\tif (down_interruptible(&ai->sem))\n\t\t\treturn ERROR;\n\t}\n\tif (test_bit(FLAG_MPI,&ai->flags)) {\n\t\tCmd cmd;\n\t\tResp rsp;\n\n\t\tif (test_bit(FLAG_ENABLED, &ai->flags) && (RID_WEP_TEMP != rid))\n\t\t\tairo_print_err(ai->dev->name,\n\t\t\t\t\"%s: MAC should be disabled (rid=%04x)\",\n\t\t\t\t__func__, rid);\n\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\tmemset(&rsp, 0, sizeof(rsp));\n\n\t\tai->config_desc.rid_desc.valid = 1;\n\t\tai->config_desc.rid_desc.len = *((u16 *)pBuf);\n\t\tai->config_desc.rid_desc.rid = 0;\n\n\t\tcmd.cmd = CMD_WRITERID;\n\t\tcmd.parm0 = rid;\n\n\t\tmemcpy_toio(ai->config_desc.card_ram_off,\n\t\t\t&ai->config_desc.rid_desc, sizeof(Rid));\n\n\t\tif (len < 4 || len > 2047) {\n\t\t\tairo_print_err(ai->dev->name, \"%s: len=%d\", __func__, len);\n\t\t\trc = -1;\n\t\t} else {\n\t\t\tmemcpy((char *)ai->config_desc.virtual_host_addr,\n\t\t\t\tpBuf, len);\n\n\t\t\trc = issuecommand(ai, &cmd, &rsp);\n\t\t\tif ((rc & 0xff00) != 0) {\n\t\t\t\tairo_print_err(ai->dev->name, \"%s: Write rid Error %d\",\n\t\t\t\t\t\t__func__, rc);\n\t\t\t\tairo_print_err(ai->dev->name, \"%s: Cmd=%04x\",\n\t\t\t\t\t\t__func__, cmd.cmd);\n\t\t\t}\n\n\t\t\tif ((rsp.status & 0x7f00))\n\t\t\t\trc = rsp.rsp0;\n\t\t}\n\t} else {\n\t\t// --- first access so that we can write the rid data\n\t\tif ( (status = PC4500_accessrid(ai, rid, CMD_ACCESS)) != 0) {\n\t                rc = status;\n\t                goto done;\n\t        }\n\t\t// --- now write the rid data\n\t\tif (bap_setup(ai, rid, 0, BAP1) != SUCCESS) {\n\t                rc = ERROR;\n\t                goto done;\n\t        }\n\t\tbap_write(ai, pBuf, len, BAP1);\n\t\t// ---now commit the rid data\n\t\trc = PC4500_accessrid(ai, rid, 0x100|CMD_ACCESS);\n\t}\ndone:\n\tif (lock)\n\t\tup(&ai->sem);\n        return rc;\n}\n\n/* Allocates a FID to be used for transmitting packets.  We only use\n   one for now. */\nstatic u16 transmit_allocate(struct airo_info *ai, int lenPayload, int raw)\n{\n\tunsigned int loop = 3000;\n\tCmd cmd;\n\tResp rsp;\n\tu16 txFid;\n\t__le16 txControl;\n\n\tcmd.cmd = CMD_ALLOCATETX;\n\tcmd.parm0 = lenPayload;\n\tif (down_interruptible(&ai->sem))\n\t\treturn ERROR;\n\tif (issuecommand(ai, &cmd, &rsp) != SUCCESS) {\n\t\ttxFid = ERROR;\n\t\tgoto done;\n\t}\n\tif ( (rsp.status & 0xFF00) != 0) {\n\t\ttxFid = ERROR;\n\t\tgoto done;\n\t}\n\t/* wait for the allocate event/indication\n\t * It makes me kind of nervous that this can just sit here and spin,\n\t * but in practice it only loops like four times. */\n\twhile (((IN4500(ai, EVSTAT) & EV_ALLOC) == 0) && --loop);\n\tif (!loop) {\n\t\ttxFid = ERROR;\n\t\tgoto done;\n\t}\n\n\t// get the allocated fid and acknowledge\n\ttxFid = IN4500(ai, TXALLOCFID);\n\tOUT4500(ai, EVACK, EV_ALLOC);\n\n\t/*  The CARD is pretty cool since it converts the ethernet packet\n\t *  into 802.11.  Also note that we don't release the FID since we\n\t *  will be using the same one over and over again. */\n\t/*  We only have to setup the control once since we are not\n\t *  releasing the fid. */\n\tif (raw)\n\t\ttxControl = cpu_to_le16(TXCTL_TXOK | TXCTL_TXEX | TXCTL_802_11\n\t\t\t| TXCTL_ETHERNET | TXCTL_NORELEASE);\n\telse\n\t\ttxControl = cpu_to_le16(TXCTL_TXOK | TXCTL_TXEX | TXCTL_802_3\n\t\t\t| TXCTL_ETHERNET | TXCTL_NORELEASE);\n\tif (bap_setup(ai, txFid, 0x0008, BAP1) != SUCCESS)\n\t\ttxFid = ERROR;\n\telse\n\t\tbap_write(ai, &txControl, sizeof(txControl), BAP1);\n\ndone:\n\tup(&ai->sem);\n\n\treturn txFid;\n}\n\n/* In general BAP1 is dedicated to transmiting packets.  However,\n   since we need a BAP when accessing RIDs, we also use BAP1 for that.\n   Make sure the BAP1 spinlock is held when this is called. */\nstatic int transmit_802_3_packet(struct airo_info *ai, int len, char *pPacket)\n{\n\t__le16 payloadLen;\n\tCmd cmd;\n\tResp rsp;\n\tint miclen = 0;\n\tu16 txFid = len;\n\tMICBuffer pMic;\n\n\tlen >>= 16;\n\n\tif (len <= ETH_ALEN * 2) {\n\t\tairo_print_warn(ai->dev->name, \"Short packet %d\", len);\n\t\treturn ERROR;\n\t}\n\tlen -= ETH_ALEN * 2;\n\n\tif (test_bit(FLAG_MIC_CAPABLE, &ai->flags) && ai->micstats.enabled && \n\t    (ntohs(((__be16 *)pPacket)[6]) != 0x888E)) {\n\t\tif (encapsulate(ai,(etherHead *)pPacket,&pMic,len) != SUCCESS)\n\t\t\treturn ERROR;\n\t\tmiclen = sizeof(pMic);\n\t}\n\t// packet is destination[6], source[6], payload[len-12]\n\t// write the payload length and dst/src/payload\n\tif (bap_setup(ai, txFid, 0x0036, BAP1) != SUCCESS) return ERROR;\n\t/* The hardware addresses aren't counted as part of the payload, so\n\t * we have to subtract the 12 bytes for the addresses off */\n\tpayloadLen = cpu_to_le16(len + miclen);\n\tbap_write(ai, &payloadLen, sizeof(payloadLen),BAP1);\n\tbap_write(ai, (__le16*)pPacket, sizeof(etherHead), BAP1);\n\tif (miclen)\n\t\tbap_write(ai, (__le16*)&pMic, miclen, BAP1);\n\tbap_write(ai, (__le16*)(pPacket + sizeof(etherHead)), len, BAP1);\n\t// issue the transmit command\n\tmemset( &cmd, 0, sizeof( cmd ) );\n\tcmd.cmd = CMD_TRANSMIT;\n\tcmd.parm0 = txFid;\n\tif (issuecommand(ai, &cmd, &rsp) != SUCCESS) return ERROR;\n\tif ( (rsp.status & 0xFF00) != 0) return ERROR;\n\treturn SUCCESS;\n}\n\nstatic int transmit_802_11_packet(struct airo_info *ai, int len, char *pPacket)\n{\n\t__le16 fc, payloadLen;\n\tCmd cmd;\n\tResp rsp;\n\tint hdrlen;\n\tstatic u8 tail[(30-10) + 2 + 6] = {[30-10] = 6};\n\t/* padding of header to full size + le16 gaplen (6) + gaplen bytes */\n\tu16 txFid = len;\n\tlen >>= 16;\n\n\tfc = *(__le16*)pPacket;\n\thdrlen = header_len(fc);\n\n\tif (len < hdrlen) {\n\t\tairo_print_warn(ai->dev->name, \"Short packet %d\", len);\n\t\treturn ERROR;\n\t}\n\n\t/* packet is 802.11 header +  payload\n\t * write the payload length and dst/src/payload */\n\tif (bap_setup(ai, txFid, 6, BAP1) != SUCCESS) return ERROR;\n\t/* The 802.11 header aren't counted as part of the payload, so\n\t * we have to subtract the header bytes off */\n\tpayloadLen = cpu_to_le16(len-hdrlen);\n\tbap_write(ai, &payloadLen, sizeof(payloadLen),BAP1);\n\tif (bap_setup(ai, txFid, 0x0014, BAP1) != SUCCESS) return ERROR;\n\tbap_write(ai, (__le16 *)pPacket, hdrlen, BAP1);\n\tbap_write(ai, (__le16 *)(tail + (hdrlen - 10)), 38 - hdrlen, BAP1);\n\n\tbap_write(ai, (__le16 *)(pPacket + hdrlen), len - hdrlen, BAP1);\n\t// issue the transmit command\n\tmemset( &cmd, 0, sizeof( cmd ) );\n\tcmd.cmd = CMD_TRANSMIT;\n\tcmd.parm0 = txFid;\n\tif (issuecommand(ai, &cmd, &rsp) != SUCCESS) return ERROR;\n\tif ( (rsp.status & 0xFF00) != 0) return ERROR;\n\treturn SUCCESS;\n}\n\n/*\n *  This is the proc_fs routines.  It is a bit messier than I would\n *  like!  Feel free to clean it up!\n */\n\nstatic ssize_t proc_read( struct file *file,\n\t\t\t  char __user *buffer,\n\t\t\t  size_t len,\n\t\t\t  loff_t *offset);\n\nstatic ssize_t proc_write( struct file *file,\n\t\t\t   const char __user *buffer,\n\t\t\t   size_t len,\n\t\t\t   loff_t *offset );\nstatic int proc_close( struct inode *inode, struct file *file );\n\nstatic int proc_stats_open( struct inode *inode, struct file *file );\nstatic int proc_statsdelta_open( struct inode *inode, struct file *file );\nstatic int proc_status_open( struct inode *inode, struct file *file );\nstatic int proc_SSID_open( struct inode *inode, struct file *file );\nstatic int proc_APList_open( struct inode *inode, struct file *file );\nstatic int proc_BSSList_open( struct inode *inode, struct file *file );\nstatic int proc_config_open( struct inode *inode, struct file *file );\nstatic int proc_wepkey_open( struct inode *inode, struct file *file );\n\nstatic const struct file_operations proc_statsdelta_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= proc_read,\n\t.open\t\t= proc_statsdelta_open,\n\t.release\t= proc_close,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic const struct file_operations proc_stats_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= proc_read,\n\t.open\t\t= proc_stats_open,\n\t.release\t= proc_close,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic const struct file_operations proc_status_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= proc_read,\n\t.open\t\t= proc_status_open,\n\t.release\t= proc_close,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic const struct file_operations proc_SSID_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= proc_read,\n\t.write\t\t= proc_write,\n\t.open\t\t= proc_SSID_open,\n\t.release\t= proc_close,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic const struct file_operations proc_BSSList_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= proc_read,\n\t.write\t\t= proc_write,\n\t.open\t\t= proc_BSSList_open,\n\t.release\t= proc_close,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic const struct file_operations proc_APList_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= proc_read,\n\t.write\t\t= proc_write,\n\t.open\t\t= proc_APList_open,\n\t.release\t= proc_close,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic const struct file_operations proc_config_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= proc_read,\n\t.write\t\t= proc_write,\n\t.open\t\t= proc_config_open,\n\t.release\t= proc_close,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic const struct file_operations proc_wepkey_ops = {\n\t.owner\t\t= THIS_MODULE,\n\t.read\t\t= proc_read,\n\t.write\t\t= proc_write,\n\t.open\t\t= proc_wepkey_open,\n\t.release\t= proc_close,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic struct proc_dir_entry *airo_entry;\n\nstruct proc_data {\n\tint release_buffer;\n\tint readlen;\n\tchar *rbuffer;\n\tint writelen;\n\tint maxwritelen;\n\tchar *wbuffer;\n\tvoid (*on_close) (struct inode *, struct file *);\n};\n\nstatic int setup_proc_entry( struct net_device *dev,\n\t\t\t     struct airo_info *apriv ) {\n\tstruct proc_dir_entry *entry;\n\t/* First setup the device directory */\n\tstrcpy(apriv->proc_name,dev->name);\n\tapriv->proc_entry = proc_mkdir_mode(apriv->proc_name, airo_perm,\n\t\t\t\t\t    airo_entry);\n\tif (!apriv->proc_entry)\n\t\tgoto fail;\n\tapriv->proc_entry->uid = proc_uid;\n\tapriv->proc_entry->gid = proc_gid;\n\n\t/* Setup the StatsDelta */\n\tentry = proc_create_data(\"StatsDelta\", S_IRUGO & proc_perm,\n\t\t\t\t apriv->proc_entry, &proc_statsdelta_ops, dev);\n\tif (!entry)\n\t\tgoto fail_stats_delta;\n\tentry->uid = proc_uid;\n\tentry->gid = proc_gid;\n\n\t/* Setup the Stats */\n\tentry = proc_create_data(\"Stats\", S_IRUGO & proc_perm,\n\t\t\t\t apriv->proc_entry, &proc_stats_ops, dev);\n\tif (!entry)\n\t\tgoto fail_stats;\n\tentry->uid = proc_uid;\n\tentry->gid = proc_gid;\n\n\t/* Setup the Status */\n\tentry = proc_create_data(\"Status\", S_IRUGO & proc_perm,\n\t\t\t\t apriv->proc_entry, &proc_status_ops, dev);\n\tif (!entry)\n\t\tgoto fail_status;\n\tentry->uid = proc_uid;\n\tentry->gid = proc_gid;\n\n\t/* Setup the Config */\n\tentry = proc_create_data(\"Config\", proc_perm,\n\t\t\t\t apriv->proc_entry, &proc_config_ops, dev);\n\tif (!entry)\n\t\tgoto fail_config;\n\tentry->uid = proc_uid;\n\tentry->gid = proc_gid;\n\n\t/* Setup the SSID */\n\tentry = proc_create_data(\"SSID\", proc_perm,\n\t\t\t\t apriv->proc_entry, &proc_SSID_ops, dev);\n\tif (!entry)\n\t\tgoto fail_ssid;\n\tentry->uid = proc_uid;\n\tentry->gid = proc_gid;\n\n\t/* Setup the APList */\n\tentry = proc_create_data(\"APList\", proc_perm,\n\t\t\t\t apriv->proc_entry, &proc_APList_ops, dev);\n\tif (!entry)\n\t\tgoto fail_aplist;\n\tentry->uid = proc_uid;\n\tentry->gid = proc_gid;\n\n\t/* Setup the BSSList */\n\tentry = proc_create_data(\"BSSList\", proc_perm,\n\t\t\t\t apriv->proc_entry, &proc_BSSList_ops, dev);\n\tif (!entry)\n\t\tgoto fail_bsslist;\n\tentry->uid = proc_uid;\n\tentry->gid = proc_gid;\n\n\t/* Setup the WepKey */\n\tentry = proc_create_data(\"WepKey\", proc_perm,\n\t\t\t\t apriv->proc_entry, &proc_wepkey_ops, dev);\n\tif (!entry)\n\t\tgoto fail_wepkey;\n\tentry->uid = proc_uid;\n\tentry->gid = proc_gid;\n\n\treturn 0;\n\nfail_wepkey:\n\tremove_proc_entry(\"BSSList\", apriv->proc_entry);\nfail_bsslist:\n\tremove_proc_entry(\"APList\", apriv->proc_entry);\nfail_aplist:\n\tremove_proc_entry(\"SSID\", apriv->proc_entry);\nfail_ssid:\n\tremove_proc_entry(\"Config\", apriv->proc_entry);\nfail_config:\n\tremove_proc_entry(\"Status\", apriv->proc_entry);\nfail_status:\n\tremove_proc_entry(\"Stats\", apriv->proc_entry);\nfail_stats:\n\tremove_proc_entry(\"StatsDelta\", apriv->proc_entry);\nfail_stats_delta:\n\tremove_proc_entry(apriv->proc_name, airo_entry);\nfail:\n\treturn -ENOMEM;\n}\n\nstatic int takedown_proc_entry( struct net_device *dev,\n\t\t\t\tstruct airo_info *apriv ) {\n\tif ( !apriv->proc_entry->namelen ) return 0;\n\tremove_proc_entry(\"Stats\",apriv->proc_entry);\n\tremove_proc_entry(\"StatsDelta\",apriv->proc_entry);\n\tremove_proc_entry(\"Status\",apriv->proc_entry);\n\tremove_proc_entry(\"Config\",apriv->proc_entry);\n\tremove_proc_entry(\"SSID\",apriv->proc_entry);\n\tremove_proc_entry(\"APList\",apriv->proc_entry);\n\tremove_proc_entry(\"BSSList\",apriv->proc_entry);\n\tremove_proc_entry(\"WepKey\",apriv->proc_entry);\n\tremove_proc_entry(apriv->proc_name,airo_entry);\n\treturn 0;\n}\n\n/*\n *  What we want from the proc_fs is to be able to efficiently read\n *  and write the configuration.  To do this, we want to read the\n *  configuration when the file is opened and write it when the file is\n *  closed.  So basically we allocate a read buffer at open and fill it\n *  with data, and allocate a write buffer and read it at close.\n */\n\n/*\n *  The read routine is generic, it relies on the preallocated rbuffer\n *  to supply the data.\n */\nstatic ssize_t proc_read( struct file *file,\n\t\t\t  char __user *buffer,\n\t\t\t  size_t len,\n\t\t\t  loff_t *offset )\n{\n\tstruct proc_data *priv = file->private_data;\n\n\tif (!priv->rbuffer)\n\t\treturn -EINVAL;\n\n\treturn simple_read_from_buffer(buffer, len, offset, priv->rbuffer,\n\t\t\t\t\tpriv->readlen);\n}\n\n/*\n *  The write routine is generic, it fills in a preallocated rbuffer\n *  to supply the data.\n */\nstatic ssize_t proc_write( struct file *file,\n\t\t\t   const char __user *buffer,\n\t\t\t   size_t len,\n\t\t\t   loff_t *offset )\n{\n\tssize_t ret;\n\tstruct proc_data *priv = file->private_data;\n\n\tif (!priv->wbuffer)\n\t\treturn -EINVAL;\n\n\tret = simple_write_to_buffer(priv->wbuffer, priv->maxwritelen, offset,\n\t\t\t\t\tbuffer, len);\n\tif (ret > 0)\n\t\tpriv->writelen = max_t(int, priv->writelen, *offset);\n\n\treturn ret;\n}\n\nstatic int proc_status_open(struct inode *inode, struct file *file)\n{\n\tstruct proc_data *data;\n\tstruct proc_dir_entry *dp = PDE(inode);\n\tstruct net_device *dev = dp->data;\n\tstruct airo_info *apriv = dev->ml_priv;\n\tCapabilityRid cap_rid;\n\tStatusRid status_rid;\n\tu16 mode;\n\tint i;\n\n\tif ((file->private_data = kzalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)\n\t\treturn -ENOMEM;\n\tdata = file->private_data;\n\tif ((data->rbuffer = kmalloc( 2048, GFP_KERNEL )) == NULL) {\n\t\tkfree (file->private_data);\n\t\treturn -ENOMEM;\n\t}\n\n\treadStatusRid(apriv, &status_rid, 1);\n\treadCapabilityRid(apriv, &cap_rid, 1);\n\n\tmode = le16_to_cpu(status_rid.mode);\n\n        i = sprintf(data->rbuffer, \"Status: %s%s%s%s%s%s%s%s%s\\n\",\n                    mode & 1 ? \"CFG \": \"\",\n                    mode & 2 ? \"ACT \": \"\",\n                    mode & 0x10 ? \"SYN \": \"\",\n                    mode & 0x20 ? \"LNK \": \"\",\n                    mode & 0x40 ? \"LEAP \": \"\",\n                    mode & 0x80 ? \"PRIV \": \"\",\n                    mode & 0x100 ? \"KEY \": \"\",\n                    mode & 0x200 ? \"WEP \": \"\",\n                    mode & 0x8000 ? \"ERR \": \"\");\n\tsprintf( data->rbuffer+i, \"Mode: %x\\n\"\n\t\t \"Signal Strength: %d\\n\"\n\t\t \"Signal Quality: %d\\n\"\n\t\t \"SSID: %-.*s\\n\"\n\t\t \"AP: %-.16s\\n\"\n\t\t \"Freq: %d\\n\"\n\t\t \"BitRate: %dmbs\\n\"\n\t\t \"Driver Version: %s\\n\"\n\t\t \"Device: %s\\nManufacturer: %s\\nFirmware Version: %s\\n\"\n\t\t \"Radio type: %x\\nCountry: %x\\nHardware Version: %x\\n\"\n\t\t \"Software Version: %x\\nSoftware Subversion: %x\\n\"\n\t\t \"Boot block version: %x\\n\",\n\t\t le16_to_cpu(status_rid.mode),\n\t\t le16_to_cpu(status_rid.normalizedSignalStrength),\n\t\t le16_to_cpu(status_rid.signalQuality),\n\t\t le16_to_cpu(status_rid.SSIDlen),\n\t\t status_rid.SSID,\n\t\t status_rid.apName,\n\t\t le16_to_cpu(status_rid.channel),\n\t\t le16_to_cpu(status_rid.currentXmitRate) / 2,\n\t\t version,\n\t\t cap_rid.prodName,\n\t\t cap_rid.manName,\n\t\t cap_rid.prodVer,\n\t\t le16_to_cpu(cap_rid.radioType),\n\t\t le16_to_cpu(cap_rid.country),\n\t\t le16_to_cpu(cap_rid.hardVer),\n\t\t le16_to_cpu(cap_rid.softVer),\n\t\t le16_to_cpu(cap_rid.softSubVer),\n\t\t le16_to_cpu(cap_rid.bootBlockVer));\n\tdata->readlen = strlen( data->rbuffer );\n\treturn 0;\n}\n\nstatic int proc_stats_rid_open(struct inode*, struct file*, u16);\nstatic int proc_statsdelta_open( struct inode *inode,\n\t\t\t\t struct file *file ) {\n\tif (file->f_mode&FMODE_WRITE) {\n\t\treturn proc_stats_rid_open(inode, file, RID_STATSDELTACLEAR);\n\t}\n\treturn proc_stats_rid_open(inode, file, RID_STATSDELTA);\n}\n\nstatic int proc_stats_open( struct inode *inode, struct file *file ) {\n\treturn proc_stats_rid_open(inode, file, RID_STATS);\n}\n\nstatic int proc_stats_rid_open( struct inode *inode,\n\t\t\t\tstruct file *file,\n\t\t\t\tu16 rid )\n{\n\tstruct proc_data *data;\n\tstruct proc_dir_entry *dp = PDE(inode);\n\tstruct net_device *dev = dp->data;\n\tstruct airo_info *apriv = dev->ml_priv;\n\tStatsRid stats;\n\tint i, j;\n\t__le32 *vals = stats.vals;\n\tint len;\n\n\tif ((file->private_data = kzalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)\n\t\treturn -ENOMEM;\n\tdata = file->private_data;\n\tif ((data->rbuffer = kmalloc( 4096, GFP_KERNEL )) == NULL) {\n\t\tkfree (file->private_data);\n\t\treturn -ENOMEM;\n\t}\n\n\treadStatsRid(apriv, &stats, rid, 1);\n\tlen = le16_to_cpu(stats.len);\n\n        j = 0;\n\tfor(i=0; statsLabels[i]!=(char *)-1 && i*4<len; i++) {\n\t\tif (!statsLabels[i]) continue;\n\t\tif (j+strlen(statsLabels[i])+16>4096) {\n\t\t\tairo_print_warn(apriv->dev->name,\n\t\t\t       \"Potentially disastrous buffer overflow averted!\");\n\t\t\tbreak;\n\t\t}\n\t\tj+=sprintf(data->rbuffer+j, \"%s: %u\\n\", statsLabels[i],\n\t\t\t\tle32_to_cpu(vals[i]));\n\t}\n\tif (i*4 >= len) {\n\t\tairo_print_warn(apriv->dev->name, \"Got a short rid\");\n\t}\n\tdata->readlen = j;\n\treturn 0;\n}\n\nstatic int get_dec_u16( char *buffer, int *start, int limit ) {\n\tu16 value;\n\tint valid = 0;\n\tfor (value = 0; *start < limit && buffer[*start] >= '0' &&\n\t\t\tbuffer[*start] <= '9'; (*start)++) {\n\t\tvalid = 1;\n\t\tvalue *= 10;\n\t\tvalue += buffer[*start] - '0';\n\t}\n\tif ( !valid ) return -1;\n\treturn value;\n}\n\nstatic int airo_config_commit(struct net_device *dev,\n\t\t\t      struct iw_request_info *info, void *zwrq,\n\t\t\t      char *extra);\n\nstatic inline int sniffing_mode(struct airo_info *ai)\n{\n\treturn (le16_to_cpu(ai->config.rmode) & le16_to_cpu(RXMODE_MASK)) >=\n\t\tle16_to_cpu(RXMODE_RFMON);\n}\n\nstatic void proc_config_on_close(struct inode *inode, struct file *file)\n{\n\tstruct proc_data *data = file->private_data;\n\tstruct proc_dir_entry *dp = PDE(inode);\n\tstruct net_device *dev = dp->data;\n\tstruct airo_info *ai = dev->ml_priv;\n\tchar *line;\n\n\tif ( !data->writelen ) return;\n\n\treadConfigRid(ai, 1);\n\tset_bit (FLAG_COMMIT, &ai->flags);\n\n\tline = data->wbuffer;\n\twhile( line[0] ) {\n/*** Mode processing */\n\t\tif ( !strncmp( line, \"Mode: \", 6 ) ) {\n\t\t\tline += 6;\n\t\t\tif (sniffing_mode(ai))\n\t\t\t\tset_bit (FLAG_RESET, &ai->flags);\n\t\t\tai->config.rmode &= ~RXMODE_FULL_MASK;\n\t\t\tclear_bit (FLAG_802_11, &ai->flags);\n\t\t\tai->config.opmode &= ~MODE_CFG_MASK;\n\t\t\tai->config.scanMode = SCANMODE_ACTIVE;\n\t\t\tif ( line[0] == 'a' ) {\n\t\t\t\tai->config.opmode |= MODE_STA_IBSS;\n\t\t\t} else {\n\t\t\t\tai->config.opmode |= MODE_STA_ESS;\n\t\t\t\tif ( line[0] == 'r' ) {\n\t\t\t\t\tai->config.rmode |= RXMODE_RFMON | RXMODE_DISABLE_802_3_HEADER;\n\t\t\t\t\tai->config.scanMode = SCANMODE_PASSIVE;\n\t\t\t\t\tset_bit (FLAG_802_11, &ai->flags);\n\t\t\t\t} else if ( line[0] == 'y' ) {\n\t\t\t\t\tai->config.rmode |= RXMODE_RFMON_ANYBSS | RXMODE_DISABLE_802_3_HEADER;\n\t\t\t\t\tai->config.scanMode = SCANMODE_PASSIVE;\n\t\t\t\t\tset_bit (FLAG_802_11, &ai->flags);\n\t\t\t\t} else if ( line[0] == 'l' )\n\t\t\t\t\tai->config.rmode |= RXMODE_LANMON;\n\t\t\t}\n\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t}\n\n/*** Radio status */\n\t\telse if (!strncmp(line,\"Radio: \", 7)) {\n\t\t\tline += 7;\n\t\t\tif (!strncmp(line,\"off\",3)) {\n\t\t\t\tset_bit (FLAG_RADIO_OFF, &ai->flags);\n\t\t\t} else {\n\t\t\t\tclear_bit (FLAG_RADIO_OFF, &ai->flags);\n\t\t\t}\n\t\t}\n/*** NodeName processing */\n\t\telse if ( !strncmp( line, \"NodeName: \", 10 ) ) {\n\t\t\tint j;\n\n\t\t\tline += 10;\n\t\t\tmemset( ai->config.nodeName, 0, 16 );\n/* Do the name, assume a space between the mode and node name */\n\t\t\tfor( j = 0; j < 16 && line[j] != '\\n'; j++ ) {\n\t\t\t\tai->config.nodeName[j] = line[j];\n\t\t\t}\n\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t}\n\n/*** PowerMode processing */\n\t\telse if ( !strncmp( line, \"PowerMode: \", 11 ) ) {\n\t\t\tline += 11;\n\t\t\tif ( !strncmp( line, \"PSPCAM\", 6 ) ) {\n\t\t\t\tai->config.powerSaveMode = POWERSAVE_PSPCAM;\n\t\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t\t} else if ( !strncmp( line, \"PSP\", 3 ) ) {\n\t\t\t\tai->config.powerSaveMode = POWERSAVE_PSP;\n\t\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t\t} else {\n\t\t\t\tai->config.powerSaveMode = POWERSAVE_CAM;\n\t\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t\t}\n\t\t} else if ( !strncmp( line, \"DataRates: \", 11 ) ) {\n\t\t\tint v, i = 0, k = 0; /* i is index into line,\n\t\t\t\t\t\tk is index to rates */\n\n\t\t\tline += 11;\n\t\t\twhile((v = get_dec_u16(line, &i, 3))!=-1) {\n\t\t\t\tai->config.rates[k++] = (u8)v;\n\t\t\t\tline += i + 1;\n\t\t\t\ti = 0;\n\t\t\t}\n\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t} else if ( !strncmp( line, \"Channel: \", 9 ) ) {\n\t\t\tint v, i = 0;\n\t\t\tline += 9;\n\t\t\tv = get_dec_u16(line, &i, i+3);\n\t\t\tif ( v != -1 ) {\n\t\t\t\tai->config.channelSet = cpu_to_le16(v);\n\t\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t\t}\n\t\t} else if ( !strncmp( line, \"XmitPower: \", 11 ) ) {\n\t\t\tint v, i = 0;\n\t\t\tline += 11;\n\t\t\tv = get_dec_u16(line, &i, i+3);\n\t\t\tif ( v != -1 ) {\n\t\t\t\tai->config.txPower = cpu_to_le16(v);\n\t\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t\t}\n\t\t} else if ( !strncmp( line, \"WEP: \", 5 ) ) {\n\t\t\tline += 5;\n\t\t\tswitch( line[0] ) {\n\t\t\tcase 's':\n\t\t\t\tai->config.authType = AUTH_SHAREDKEY;\n\t\t\t\tbreak;\n\t\t\tcase 'e':\n\t\t\t\tai->config.authType = AUTH_ENCRYPT;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tai->config.authType = AUTH_OPEN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t} else if ( !strncmp( line, \"LongRetryLimit: \", 16 ) ) {\n\t\t\tint v, i = 0;\n\n\t\t\tline += 16;\n\t\t\tv = get_dec_u16(line, &i, 3);\n\t\t\tv = (v<0) ? 0 : ((v>255) ? 255 : v);\n\t\t\tai->config.longRetryLimit = cpu_to_le16(v);\n\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t} else if ( !strncmp( line, \"ShortRetryLimit: \", 17 ) ) {\n\t\t\tint v, i = 0;\n\n\t\t\tline += 17;\n\t\t\tv = get_dec_u16(line, &i, 3);\n\t\t\tv = (v<0) ? 0 : ((v>255) ? 255 : v);\n\t\t\tai->config.shortRetryLimit = cpu_to_le16(v);\n\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t} else if ( !strncmp( line, \"RTSThreshold: \", 14 ) ) {\n\t\t\tint v, i = 0;\n\n\t\t\tline += 14;\n\t\t\tv = get_dec_u16(line, &i, 4);\n\t\t\tv = (v<0) ? 0 : ((v>AIRO_DEF_MTU) ? AIRO_DEF_MTU : v);\n\t\t\tai->config.rtsThres = cpu_to_le16(v);\n\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t} else if ( !strncmp( line, \"TXMSDULifetime: \", 16 ) ) {\n\t\t\tint v, i = 0;\n\n\t\t\tline += 16;\n\t\t\tv = get_dec_u16(line, &i, 5);\n\t\t\tv = (v<0) ? 0 : v;\n\t\t\tai->config.txLifetime = cpu_to_le16(v);\n\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t} else if ( !strncmp( line, \"RXMSDULifetime: \", 16 ) ) {\n\t\t\tint v, i = 0;\n\n\t\t\tline += 16;\n\t\t\tv = get_dec_u16(line, &i, 5);\n\t\t\tv = (v<0) ? 0 : v;\n\t\t\tai->config.rxLifetime = cpu_to_le16(v);\n\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t} else if ( !strncmp( line, \"TXDiversity: \", 13 ) ) {\n\t\t\tai->config.txDiversity =\n\t\t\t\t(line[13]=='l') ? 1 :\n\t\t\t\t((line[13]=='r')? 2: 3);\n\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t} else if ( !strncmp( line, \"RXDiversity: \", 13 ) ) {\n\t\t\tai->config.rxDiversity =\n\t\t\t\t(line[13]=='l') ? 1 :\n\t\t\t\t((line[13]=='r')? 2: 3);\n\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t} else if ( !strncmp( line, \"FragThreshold: \", 15 ) ) {\n\t\t\tint v, i = 0;\n\n\t\t\tline += 15;\n\t\t\tv = get_dec_u16(line, &i, 4);\n\t\t\tv = (v<256) ? 256 : ((v>AIRO_DEF_MTU) ? AIRO_DEF_MTU : v);\n\t\t\tv = v & 0xfffe; /* Make sure its even */\n\t\t\tai->config.fragThresh = cpu_to_le16(v);\n\t\t\tset_bit (FLAG_COMMIT, &ai->flags);\n\t\t} else if (!strncmp(line, \"Modulation: \", 12)) {\n\t\t\tline += 12;\n\t\t\tswitch(*line) {\n\t\t\tcase 'd':  ai->config.modulation=MOD_DEFAULT; set_bit(FLAG_COMMIT, &ai->flags); break;\n\t\t\tcase 'c':  ai->config.modulation=MOD_CCK; set_bit(FLAG_COMMIT, &ai->flags); break;\n\t\t\tcase 'm':  ai->config.modulation=MOD_MOK; set_bit(FLAG_COMMIT, &ai->flags); break;\n\t\t\tdefault: airo_print_warn(ai->dev->name, \"Unknown modulation\");\n\t\t\t}\n\t\t} else if (!strncmp(line, \"Preamble: \", 10)) {\n\t\t\tline += 10;\n\t\t\tswitch(*line) {\n\t\t\tcase 'a': ai->config.preamble=PREAMBLE_AUTO; set_bit(FLAG_COMMIT, &ai->flags); break;\n\t\t\tcase 'l': ai->config.preamble=PREAMBLE_LONG; set_bit(FLAG_COMMIT, &ai->flags); break;\n\t\t\tcase 's': ai->config.preamble=PREAMBLE_SHORT; set_bit(FLAG_COMMIT, &ai->flags); break;\n\t\t\tdefault: airo_print_warn(ai->dev->name, \"Unknown preamble\");\n\t\t\t}\n\t\t} else {\n\t\t\tairo_print_warn(ai->dev->name, \"Couldn't figure out %s\", line);\n\t\t}\n\t\twhile( line[0] && line[0] != '\\n' ) line++;\n\t\tif ( line[0] ) line++;\n\t}\n\tairo_config_commit(dev, NULL, NULL, NULL);\n}\n\nstatic const char *get_rmode(__le16 mode)\n{\n        switch(mode & RXMODE_MASK) {\n        case RXMODE_RFMON:  return \"rfmon\";\n        case RXMODE_RFMON_ANYBSS:  return \"yna (any) bss rfmon\";\n        case RXMODE_LANMON:  return \"lanmon\";\n        }\n        return \"ESS\";\n}\n\nstatic int proc_config_open(struct inode *inode, struct file *file)\n{\n\tstruct proc_data *data;\n\tstruct proc_dir_entry *dp = PDE(inode);\n\tstruct net_device *dev = dp->data;\n\tstruct airo_info *ai = dev->ml_priv;\n\tint i;\n\t__le16 mode;\n\n\tif ((file->private_data = kzalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)\n\t\treturn -ENOMEM;\n\tdata = file->private_data;\n\tif ((data->rbuffer = kmalloc( 2048, GFP_KERNEL )) == NULL) {\n\t\tkfree (file->private_data);\n\t\treturn -ENOMEM;\n\t}\n\tif ((data->wbuffer = kzalloc( 2048, GFP_KERNEL )) == NULL) {\n\t\tkfree (data->rbuffer);\n\t\tkfree (file->private_data);\n\t\treturn -ENOMEM;\n\t}\n\tdata->maxwritelen = 2048;\n\tdata->on_close = proc_config_on_close;\n\n\treadConfigRid(ai, 1);\n\n\tmode = ai->config.opmode & MODE_CFG_MASK;\n\ti = sprintf( data->rbuffer,\n\t\t     \"Mode: %s\\n\"\n\t\t     \"Radio: %s\\n\"\n\t\t     \"NodeName: %-16s\\n\"\n\t\t     \"PowerMode: %s\\n\"\n\t\t     \"DataRates: %d %d %d %d %d %d %d %d\\n\"\n\t\t     \"Channel: %d\\n\"\n\t\t     \"XmitPower: %d\\n\",\n\t\t     mode == MODE_STA_IBSS ? \"adhoc\" :\n\t\t     mode == MODE_STA_ESS ? get_rmode(ai->config.rmode):\n\t\t     mode == MODE_AP ? \"AP\" :\n\t\t     mode == MODE_AP_RPTR ? \"AP RPTR\" : \"Error\",\n\t\t     test_bit(FLAG_RADIO_OFF, &ai->flags) ? \"off\" : \"on\",\n\t\t     ai->config.nodeName,\n\t\t     ai->config.powerSaveMode == POWERSAVE_CAM ? \"CAM\" :\n\t\t     ai->config.powerSaveMode == POWERSAVE_PSP ? \"PSP\" :\n\t\t     ai->config.powerSaveMode == POWERSAVE_PSPCAM ? \"PSPCAM\" :\n\t\t     \"Error\",\n\t\t     (int)ai->config.rates[0],\n\t\t     (int)ai->config.rates[1],\n\t\t     (int)ai->config.rates[2],\n\t\t     (int)ai->config.rates[3],\n\t\t     (int)ai->config.rates[4],\n\t\t     (int)ai->config.rates[5],\n\t\t     (int)ai->config.rates[6],\n\t\t     (int)ai->config.rates[7],\n\t\t     le16_to_cpu(ai->config.channelSet),\n\t\t     le16_to_cpu(ai->config.txPower)\n\t\t);\n\tsprintf( data->rbuffer + i,\n\t\t \"LongRetryLimit: %d\\n\"\n\t\t \"ShortRetryLimit: %d\\n\"\n\t\t \"RTSThreshold: %d\\n\"\n\t\t \"TXMSDULifetime: %d\\n\"\n\t\t \"RXMSDULifetime: %d\\n\"\n\t\t \"TXDiversity: %s\\n\"\n\t\t \"RXDiversity: %s\\n\"\n\t\t \"FragThreshold: %d\\n\"\n\t\t \"WEP: %s\\n\"\n\t\t \"Modulation: %s\\n\"\n\t\t \"Preamble: %s\\n\",\n\t\t le16_to_cpu(ai->config.longRetryLimit),\n\t\t le16_to_cpu(ai->config.shortRetryLimit),\n\t\t le16_to_cpu(ai->config.rtsThres),\n\t\t le16_to_cpu(ai->config.txLifetime),\n\t\t le16_to_cpu(ai->config.rxLifetime),\n\t\t ai->config.txDiversity == 1 ? \"left\" :\n\t\t ai->config.txDiversity == 2 ? \"right\" : \"both\",\n\t\t ai->config.rxDiversity == 1 ? \"left\" :\n\t\t ai->config.rxDiversity == 2 ? \"right\" : \"both\",\n\t\t le16_to_cpu(ai->config.fragThresh),\n\t\t ai->config.authType == AUTH_ENCRYPT ? \"encrypt\" :\n\t\t ai->config.authType == AUTH_SHAREDKEY ? \"shared\" : \"open\",\n\t\t ai->config.modulation == MOD_DEFAULT ? \"default\" :\n\t\t ai->config.modulation == MOD_CCK ? \"cck\" :\n\t\t ai->config.modulation == MOD_MOK ? \"mok\" : \"error\",\n\t\t ai->config.preamble == PREAMBLE_AUTO ? \"auto\" :\n\t\t ai->config.preamble == PREAMBLE_LONG ? \"long\" :\n\t\t ai->config.preamble == PREAMBLE_SHORT ? \"short\" : \"error\"\n\t\t);\n\tdata->readlen = strlen( data->rbuffer );\n\treturn 0;\n}\n\nstatic void proc_SSID_on_close(struct inode *inode, struct file *file)\n{\n\tstruct proc_data *data = file->private_data;\n\tstruct proc_dir_entry *dp = PDE(inode);\n\tstruct net_device *dev = dp->data;\n\tstruct airo_info *ai = dev->ml_priv;\n\tSsidRid SSID_rid;\n\tint i;\n\tchar *p = data->wbuffer;\n\tchar *end = p + data->writelen;\n\n\tif (!data->writelen)\n\t\treturn;\n\n\t*end = '\\n'; /* sentinel; we have space for it */\n\n\tmemset(&SSID_rid, 0, sizeof(SSID_rid));\n\n\tfor (i = 0; i < 3 && p < end; i++) {\n\t\tint j = 0;\n\t\t/* copy up to 32 characters from this line */\n\t\twhile (*p != '\\n' && j < 32)\n\t\t\tSSID_rid.ssids[i].ssid[j++] = *p++;\n\t\tif (j == 0)\n\t\t\tbreak;\n\t\tSSID_rid.ssids[i].len = cpu_to_le16(j);\n\t\t/* skip to the beginning of the next line */\n\t\twhile (*p++ != '\\n')\n\t\t\t;\n\t}\n\tif (i)\n\t\tSSID_rid.len = cpu_to_le16(sizeof(SSID_rid));\n\tdisable_MAC(ai, 1);\n\twriteSsidRid(ai, &SSID_rid, 1);\n\tenable_MAC(ai, 1);\n}\n\nstatic void proc_APList_on_close( struct inode *inode, struct file *file ) {\n\tstruct proc_data *data = file->private_data;\n\tstruct proc_dir_entry *dp = PDE(inode);\n\tstruct net_device *dev = dp->data;\n\tstruct airo_info *ai = dev->ml_priv;\n\tAPListRid APList_rid;\n\tint i;\n\n\tif ( !data->writelen ) return;\n\n\tmemset( &APList_rid, 0, sizeof(APList_rid) );\n\tAPList_rid.len = cpu_to_le16(sizeof(APList_rid));\n\n\tfor( i = 0; i < 4 && data->writelen >= (i+1)*6*3; i++ ) {\n\t\tint j;\n\t\tfor( j = 0; j < 6*3 && data->wbuffer[j+i*6*3]; j++ ) {\n\t\t\tswitch(j%3) {\n\t\t\tcase 0:\n\t\t\t\tAPList_rid.ap[i][j/3]=\n\t\t\t\t\thex_to_bin(data->wbuffer[j+i*6*3])<<4;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tAPList_rid.ap[i][j/3]|=\n\t\t\t\t\thex_to_bin(data->wbuffer[j+i*6*3]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tdisable_MAC(ai, 1);\n\twriteAPListRid(ai, &APList_rid, 1);\n\tenable_MAC(ai, 1);\n}\n\n/* This function wraps PC4500_writerid with a MAC disable */\nstatic int do_writerid( struct airo_info *ai, u16 rid, const void *rid_data,\n\t\t\tint len, int dummy ) {\n\tint rc;\n\n\tdisable_MAC(ai, 1);\n\trc = PC4500_writerid(ai, rid, rid_data, len, 1);\n\tenable_MAC(ai, 1);\n\treturn rc;\n}\n\n/* Returns the WEP key at the specified index, or -1 if that key does\n * not exist.  The buffer is assumed to be at least 16 bytes in length.\n */\nstatic int get_wep_key(struct airo_info *ai, u16 index, char *buf, u16 buflen)\n{\n\tWepKeyRid wkr;\n\tint rc;\n\t__le16 lastindex;\n\n\trc = readWepKeyRid(ai, &wkr, 1, 1);\n\tif (rc != SUCCESS)\n\t\treturn -1;\n\tdo {\n\t\tlastindex = wkr.kindex;\n\t\tif (le16_to_cpu(wkr.kindex) == index) {\n\t\t\tint klen = min_t(int, buflen, le16_to_cpu(wkr.klen));\n\t\t\tmemcpy(buf, wkr.key, klen);\n\t\t\treturn klen;\n\t\t}\n\t\trc = readWepKeyRid(ai, &wkr, 0, 1);\n\t\tif (rc != SUCCESS)\n\t\t\treturn -1;\n\t} while (lastindex != wkr.kindex);\n\treturn -1;\n}\n\nstatic int get_wep_tx_idx(struct airo_info *ai)\n{\n\tWepKeyRid wkr;\n\tint rc;\n\t__le16 lastindex;\n\n\trc = readWepKeyRid(ai, &wkr, 1, 1);\n\tif (rc != SUCCESS)\n\t\treturn -1;\n\tdo {\n\t\tlastindex = wkr.kindex;\n\t\tif (wkr.kindex == cpu_to_le16(0xffff))\n\t\t\treturn wkr.mac[0];\n\t\trc = readWepKeyRid(ai, &wkr, 0, 1);\n\t\tif (rc != SUCCESS)\n\t\t\treturn -1;\n\t} while (lastindex != wkr.kindex);\n\treturn -1;\n}\n\nstatic int set_wep_key(struct airo_info *ai, u16 index, const char *key,\n\t\t       u16 keylen, int perm, int lock)\n{\n\tstatic const unsigned char macaddr[ETH_ALEN] = { 0x01, 0, 0, 0, 0, 0 };\n\tWepKeyRid wkr;\n\tint rc;\n\n\tif (WARN_ON(keylen == 0))\n\t\treturn -1;\n\n\tmemset(&wkr, 0, sizeof(wkr));\n\twkr.len = cpu_to_le16(sizeof(wkr));\n\twkr.kindex = cpu_to_le16(index);\n\twkr.klen = cpu_to_le16(keylen);\n\tmemcpy(wkr.key, key, keylen);\n\tmemcpy(wkr.mac, macaddr, ETH_ALEN);\n\n\tif (perm) disable_MAC(ai, lock);\n\trc = writeWepKeyRid(ai, &wkr, perm, lock);\n\tif (perm) enable_MAC(ai, lock);\n\treturn rc;\n}\n\nstatic int set_wep_tx_idx(struct airo_info *ai, u16 index, int perm, int lock)\n{\n\tWepKeyRid wkr;\n\tint rc;\n\n\tmemset(&wkr, 0, sizeof(wkr));\n\twkr.len = cpu_to_le16(sizeof(wkr));\n\twkr.kindex = cpu_to_le16(0xffff);\n\twkr.mac[0] = (char)index;\n\n\tif (perm) {\n\t\tai->defindex = (char)index;\n\t\tdisable_MAC(ai, lock);\n\t}\n\n\trc = writeWepKeyRid(ai, &wkr, perm, lock);\n\n\tif (perm)\n\t\tenable_MAC(ai, lock);\n\treturn rc;\n}\n\nstatic void proc_wepkey_on_close( struct inode *inode, struct file *file ) {\n\tstruct proc_data *data;\n\tstruct proc_dir_entry *dp = PDE(inode);\n\tstruct net_device *dev = dp->data;\n\tstruct airo_info *ai = dev->ml_priv;\n\tint i, rc;\n\tchar key[16];\n\tu16 index = 0;\n\tint j = 0;\n\n\tmemset(key, 0, sizeof(key));\n\n\tdata = file->private_data;\n\tif ( !data->writelen ) return;\n\n\tif (data->wbuffer[0] >= '0' && data->wbuffer[0] <= '3' &&\n\t    (data->wbuffer[1] == ' ' || data->wbuffer[1] == '\\n')) {\n\t\tindex = data->wbuffer[0] - '0';\n\t\tif (data->wbuffer[1] == '\\n') {\n\t\t\trc = set_wep_tx_idx(ai, index, 1, 1);\n\t\t\tif (rc < 0) {\n\t\t\t\tairo_print_err(ai->dev->name, \"failed to set \"\n\t\t\t\t               \"WEP transmit index to %d: %d.\",\n\t\t\t\t               index, rc);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tj = 2;\n\t} else {\n\t\tairo_print_err(ai->dev->name, \"WepKey passed invalid key index\");\n\t\treturn;\n\t}\n\n\tfor( i = 0; i < 16*3 && data->wbuffer[i+j]; i++ ) {\n\t\tswitch(i%3) {\n\t\tcase 0:\n\t\t\tkey[i/3] = hex_to_bin(data->wbuffer[i+j])<<4;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tkey[i/3] |= hex_to_bin(data->wbuffer[i+j]);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trc = set_wep_key(ai, index, key, i/3, 1, 1);\n\tif (rc < 0) {\n\t\tairo_print_err(ai->dev->name, \"failed to set WEP key at index \"\n\t\t               \"%d: %d.\", index, rc);\n\t}\n}\n\nstatic int proc_wepkey_open( struct inode *inode, struct file *file )\n{\n\tstruct proc_data *data;\n\tstruct proc_dir_entry *dp = PDE(inode);\n\tstruct net_device *dev = dp->data;\n\tstruct airo_info *ai = dev->ml_priv;\n\tchar *ptr;\n\tWepKeyRid wkr;\n\t__le16 lastindex;\n\tint j=0;\n\tint rc;\n\n\tif ((file->private_data = kzalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)\n\t\treturn -ENOMEM;\n\tmemset(&wkr, 0, sizeof(wkr));\n\tdata = file->private_data;\n\tif ((data->rbuffer = kzalloc( 180, GFP_KERNEL )) == NULL) {\n\t\tkfree (file->private_data);\n\t\treturn -ENOMEM;\n\t}\n\tdata->writelen = 0;\n\tdata->maxwritelen = 80;\n\tif ((data->wbuffer = kzalloc( 80, GFP_KERNEL )) == NULL) {\n\t\tkfree (data->rbuffer);\n\t\tkfree (file->private_data);\n\t\treturn -ENOMEM;\n\t}\n\tdata->on_close = proc_wepkey_on_close;\n\n\tptr = data->rbuffer;\n\tstrcpy(ptr, \"No wep keys\\n\");\n\trc = readWepKeyRid(ai, &wkr, 1, 1);\n\tif (rc == SUCCESS) do {\n\t\tlastindex = wkr.kindex;\n\t\tif (wkr.kindex == cpu_to_le16(0xffff)) {\n\t\t\tj += sprintf(ptr+j, \"Tx key = %d\\n\",\n\t\t\t\t     (int)wkr.mac[0]);\n\t\t} else {\n\t\t\tj += sprintf(ptr+j, \"Key %d set with length = %d\\n\",\n\t\t\t\t     le16_to_cpu(wkr.kindex),\n\t\t\t\t     le16_to_cpu(wkr.klen));\n\t\t}\n\t\treadWepKeyRid(ai, &wkr, 0, 1);\n\t} while((lastindex != wkr.kindex) && (j < 180-30));\n\n\tdata->readlen = strlen( data->rbuffer );\n\treturn 0;\n}\n\nstatic int proc_SSID_open(struct inode *inode, struct file *file)\n{\n\tstruct proc_data *data;\n\tstruct proc_dir_entry *dp = PDE(inode);\n\tstruct net_device *dev = dp->data;\n\tstruct airo_info *ai = dev->ml_priv;\n\tint i;\n\tchar *ptr;\n\tSsidRid SSID_rid;\n\n\tif ((file->private_data = kzalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)\n\t\treturn -ENOMEM;\n\tdata = file->private_data;\n\tif ((data->rbuffer = kmalloc( 104, GFP_KERNEL )) == NULL) {\n\t\tkfree (file->private_data);\n\t\treturn -ENOMEM;\n\t}\n\tdata->writelen = 0;\n\tdata->maxwritelen = 33*3;\n\t/* allocate maxwritelen + 1; we'll want a sentinel */\n\tif ((data->wbuffer = kzalloc(33*3 + 1, GFP_KERNEL)) == NULL) {\n\t\tkfree (data->rbuffer);\n\t\tkfree (file->private_data);\n\t\treturn -ENOMEM;\n\t}\n\tdata->on_close = proc_SSID_on_close;\n\n\treadSsidRid(ai, &SSID_rid);\n\tptr = data->rbuffer;\n\tfor (i = 0; i < 3; i++) {\n\t\tint j;\n\t\tsize_t len = le16_to_cpu(SSID_rid.ssids[i].len);\n\t\tif (!len)\n\t\t\tbreak;\n\t\tif (len > 32)\n\t\t\tlen = 32;\n\t\tfor (j = 0; j < len && SSID_rid.ssids[i].ssid[j]; j++)\n\t\t\t*ptr++ = SSID_rid.ssids[i].ssid[j];\n\t\t*ptr++ = '\\n';\n\t}\n\t*ptr = '\\0';\n\tdata->readlen = strlen( data->rbuffer );\n\treturn 0;\n}\n\nstatic int proc_APList_open( struct inode *inode, struct file *file ) {\n\tstruct proc_data *data;\n\tstruct proc_dir_entry *dp = PDE(inode);\n\tstruct net_device *dev = dp->data;\n\tstruct airo_info *ai = dev->ml_priv;\n\tint i;\n\tchar *ptr;\n\tAPListRid APList_rid;\n\n\tif ((file->private_data = kzalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)\n\t\treturn -ENOMEM;\n\tdata = file->private_data;\n\tif ((data->rbuffer = kmalloc( 104, GFP_KERNEL )) == NULL) {\n\t\tkfree (file->private_data);\n\t\treturn -ENOMEM;\n\t}\n\tdata->writelen = 0;\n\tdata->maxwritelen = 4*6*3;\n\tif ((data->wbuffer = kzalloc( data->maxwritelen, GFP_KERNEL )) == NULL) {\n\t\tkfree (data->rbuffer);\n\t\tkfree (file->private_data);\n\t\treturn -ENOMEM;\n\t}\n\tdata->on_close = proc_APList_on_close;\n\n\treadAPListRid(ai, &APList_rid);\n\tptr = data->rbuffer;\n\tfor( i = 0; i < 4; i++ ) {\n// We end when we find a zero MAC\n\t\tif ( !*(int*)APList_rid.ap[i] &&\n\t\t     !*(int*)&APList_rid.ap[i][2]) break;\n\t\tptr += sprintf(ptr, \"%pM\\n\", APList_rid.ap[i]);\n\t}\n\tif (i==0) ptr += sprintf(ptr, \"Not using specific APs\\n\");\n\n\t*ptr = '\\0';\n\tdata->readlen = strlen( data->rbuffer );\n\treturn 0;\n}\n\nstatic int proc_BSSList_open( struct inode *inode, struct file *file ) {\n\tstruct proc_data *data;\n\tstruct proc_dir_entry *dp = PDE(inode);\n\tstruct net_device *dev = dp->data;\n\tstruct airo_info *ai = dev->ml_priv;\n\tchar *ptr;\n\tBSSListRid BSSList_rid;\n\tint rc;\n\t/* If doLoseSync is not 1, we won't do a Lose Sync */\n\tint doLoseSync = -1;\n\n\tif ((file->private_data = kzalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)\n\t\treturn -ENOMEM;\n\tdata = file->private_data;\n\tif ((data->rbuffer = kmalloc( 1024, GFP_KERNEL )) == NULL) {\n\t\tkfree (file->private_data);\n\t\treturn -ENOMEM;\n\t}\n\tdata->writelen = 0;\n\tdata->maxwritelen = 0;\n\tdata->wbuffer = NULL;\n\tdata->on_close = NULL;\n\n\tif (file->f_mode & FMODE_WRITE) {\n\t\tif (!(file->f_mode & FMODE_READ)) {\n\t\t\tCmd cmd;\n\t\t\tResp rsp;\n\n\t\t\tif (ai->flags & FLAG_RADIO_MASK) return -ENETDOWN;\n\t\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\t\tcmd.cmd=CMD_LISTBSS;\n\t\t\tif (down_interruptible(&ai->sem))\n\t\t\t\treturn -ERESTARTSYS;\n\t\t\tissuecommand(ai, &cmd, &rsp);\n\t\t\tup(&ai->sem);\n\t\t\tdata->readlen = 0;\n\t\t\treturn 0;\n\t\t}\n\t\tdoLoseSync = 1;\n\t}\n\tptr = data->rbuffer;\n\t/* There is a race condition here if there are concurrent opens.\n           Since it is a rare condition, we'll just live with it, otherwise\n           we have to add a spin lock... */\n\trc = readBSSListRid(ai, doLoseSync, &BSSList_rid);\n\twhile(rc == 0 && BSSList_rid.index != cpu_to_le16(0xffff)) {\n\t\tptr += sprintf(ptr, \"%pM %*s rssi = %d\",\n\t\t\t       BSSList_rid.bssid,\n\t\t\t\t(int)BSSList_rid.ssidLen,\n\t\t\t\tBSSList_rid.ssid,\n\t\t\t\tle16_to_cpu(BSSList_rid.dBm));\n\t\tptr += sprintf(ptr, \" channel = %d %s %s %s %s\\n\",\n\t\t\t\tle16_to_cpu(BSSList_rid.dsChannel),\n\t\t\t\tBSSList_rid.cap & CAP_ESS ? \"ESS\" : \"\",\n\t\t\t\tBSSList_rid.cap & CAP_IBSS ? \"adhoc\" : \"\",\n\t\t\t\tBSSList_rid.cap & CAP_PRIVACY ? \"wep\" : \"\",\n\t\t\t\tBSSList_rid.cap & CAP_SHORTHDR ? \"shorthdr\" : \"\");\n\t\trc = readBSSListRid(ai, 0, &BSSList_rid);\n\t}\n\t*ptr = '\\0';\n\tdata->readlen = strlen( data->rbuffer );\n\treturn 0;\n}\n\nstatic int proc_close( struct inode *inode, struct file *file )\n{\n\tstruct proc_data *data = file->private_data;\n\n\tif (data->on_close != NULL)\n\t\tdata->on_close(inode, file);\n\tkfree(data->rbuffer);\n\tkfree(data->wbuffer);\n\tkfree(data);\n\treturn 0;\n}\n\n/* Since the card doesn't automatically switch to the right WEP mode,\n   we will make it do it.  If the card isn't associated, every secs we\n   will switch WEP modes to see if that will help.  If the card is\n   associated we will check every minute to see if anything has\n   changed. */\nstatic void timer_func( struct net_device *dev ) {\n\tstruct airo_info *apriv = dev->ml_priv;\n\n/* We don't have a link so try changing the authtype */\n\treadConfigRid(apriv, 0);\n\tdisable_MAC(apriv, 0);\n\tswitch(apriv->config.authType) {\n\t\tcase AUTH_ENCRYPT:\n/* So drop to OPEN */\n\t\t\tapriv->config.authType = AUTH_OPEN;\n\t\t\tbreak;\n\t\tcase AUTH_SHAREDKEY:\n\t\t\tif (apriv->keyindex < auto_wep) {\n\t\t\t\tset_wep_tx_idx(apriv, apriv->keyindex, 0, 0);\n\t\t\t\tapriv->config.authType = AUTH_SHAREDKEY;\n\t\t\t\tapriv->keyindex++;\n\t\t\t} else {\n\t\t\t        /* Drop to ENCRYPT */\n\t\t\t\tapriv->keyindex = 0;\n\t\t\t\tset_wep_tx_idx(apriv, apriv->defindex, 0, 0);\n\t\t\t\tapriv->config.authType = AUTH_ENCRYPT;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:  /* We'll escalate to SHAREDKEY */\n\t\t\tapriv->config.authType = AUTH_SHAREDKEY;\n\t}\n\tset_bit (FLAG_COMMIT, &apriv->flags);\n\twriteConfigRid(apriv, 0);\n\tenable_MAC(apriv, 0);\n\tup(&apriv->sem);\n\n/* Schedule check to see if the change worked */\n\tclear_bit(JOB_AUTOWEP, &apriv->jobs);\n\tapriv->expires = RUN_AT(HZ*3);\n}\n\n#ifdef CONFIG_PCI\nstatic int __devinit airo_pci_probe(struct pci_dev *pdev,\n\t\t\t\t    const struct pci_device_id *pent)\n{\n\tstruct net_device *dev;\n\n\tif (pci_enable_device(pdev))\n\t\treturn -ENODEV;\n\tpci_set_master(pdev);\n\n\tif (pdev->device == 0x5000 || pdev->device == 0xa504)\n\t\t\tdev = _init_airo_card(pdev->irq, pdev->resource[0].start, 0, pdev, &pdev->dev);\n\telse\n\t\t\tdev = _init_airo_card(pdev->irq, pdev->resource[2].start, 0, pdev, &pdev->dev);\n\tif (!dev) {\n\t\tpci_disable_device(pdev);\n\t\treturn -ENODEV;\n\t}\n\n\tpci_set_drvdata(pdev, dev);\n\treturn 0;\n}\n\nstatic void __devexit airo_pci_remove(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\n\tairo_print_info(dev->name, \"Unregistering...\");\n\tstop_airo_card(dev, 1);\n\tpci_disable_device(pdev);\n\tpci_set_drvdata(pdev, NULL);\n}\n\nstatic int airo_pci_suspend(struct pci_dev *pdev, pm_message_t state)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct airo_info *ai = dev->ml_priv;\n\tCmd cmd;\n\tResp rsp;\n\n\tif (!ai->APList)\n\t\tai->APList = kmalloc(sizeof(APListRid), GFP_KERNEL);\n\tif (!ai->APList)\n\t\treturn -ENOMEM;\n\tif (!ai->SSID)\n\t\tai->SSID = kmalloc(sizeof(SsidRid), GFP_KERNEL);\n\tif (!ai->SSID)\n\t\treturn -ENOMEM;\n\treadAPListRid(ai, ai->APList);\n\treadSsidRid(ai, ai->SSID);\n\tmemset(&cmd, 0, sizeof(cmd));\n\t/* the lock will be released at the end of the resume callback */\n\tif (down_interruptible(&ai->sem))\n\t\treturn -EAGAIN;\n\tdisable_MAC(ai, 0);\n\tnetif_device_detach(dev);\n\tai->power = state;\n\tcmd.cmd = HOSTSLEEP;\n\tissuecommand(ai, &cmd, &rsp);\n\n\tpci_enable_wake(pdev, pci_choose_state(pdev, state), 1);\n\tpci_save_state(pdev);\n\tpci_set_power_state(pdev, pci_choose_state(pdev, state));\n\treturn 0;\n}\n\nstatic int airo_pci_resume(struct pci_dev *pdev)\n{\n\tstruct net_device *dev = pci_get_drvdata(pdev);\n\tstruct airo_info *ai = dev->ml_priv;\n\tpci_power_t prev_state = pdev->current_state;\n\n\tpci_set_power_state(pdev, PCI_D0);\n\tpci_restore_state(pdev);\n\tpci_enable_wake(pdev, PCI_D0, 0);\n\n\tif (prev_state != PCI_D1) {\n\t\treset_card(dev, 0);\n\t\tmpi_init_descriptors(ai);\n\t\tsetup_card(ai, dev->dev_addr, 0);\n\t\tclear_bit(FLAG_RADIO_OFF, &ai->flags);\n\t\tclear_bit(FLAG_PENDING_XMIT, &ai->flags);\n\t} else {\n\t\tOUT4500(ai, EVACK, EV_AWAKEN);\n\t\tOUT4500(ai, EVACK, EV_AWAKEN);\n\t\tmsleep(100);\n\t}\n\n\tset_bit(FLAG_COMMIT, &ai->flags);\n\tdisable_MAC(ai, 0);\n        msleep(200);\n\tif (ai->SSID) {\n\t\twriteSsidRid(ai, ai->SSID, 0);\n\t\tkfree(ai->SSID);\n\t\tai->SSID = NULL;\n\t}\n\tif (ai->APList) {\n\t\twriteAPListRid(ai, ai->APList, 0);\n\t\tkfree(ai->APList);\n\t\tai->APList = NULL;\n\t}\n\twriteConfigRid(ai, 0);\n\tenable_MAC(ai, 0);\n\tai->power = PMSG_ON;\n\tnetif_device_attach(dev);\n\tnetif_wake_queue(dev);\n\tenable_interrupts(ai);\n\tup(&ai->sem);\n\treturn 0;\n}\n#endif\n\nstatic int __init airo_init_module( void )\n{\n\tint i;\n\n\tairo_entry = proc_mkdir_mode(\"driver/aironet\", airo_perm, NULL);\n\n\tif (airo_entry) {\n\t\tairo_entry->uid = proc_uid;\n\t\tairo_entry->gid = proc_gid;\n\t}\n\n\tfor (i = 0; i < 4 && io[i] && irq[i]; i++) {\n\t\tairo_print_info(\"\", \"Trying to configure ISA adapter at irq=%d \"\n\t\t\t\"io=0x%x\", irq[i], io[i] );\n\t\tif (init_airo_card( irq[i], io[i], 0, NULL ))\n\t\t\t/* do nothing */ ;\n\t}\n\n#ifdef CONFIG_PCI\n\tairo_print_info(\"\", \"Probing for PCI adapters\");\n\ti = pci_register_driver(&airo_driver);\n\tairo_print_info(\"\", \"Finished probing for PCI adapters\");\n\n\tif (i) {\n\t\tremove_proc_entry(\"driver/aironet\", NULL);\n\t\treturn i;\n\t}\n#endif\n\n\t/* Always exit with success, as we are a library module\n\t * as well as a driver module\n\t */\n\treturn 0;\n}\n\nstatic void __exit airo_cleanup_module( void )\n{\n\tstruct airo_info *ai;\n\twhile(!list_empty(&airo_devices)) {\n\t\tai = list_entry(airo_devices.next, struct airo_info, dev_list);\n\t\tairo_print_info(ai->dev->name, \"Unregistering...\");\n\t\tstop_airo_card(ai->dev, 1);\n\t}\n#ifdef CONFIG_PCI\n\tpci_unregister_driver(&airo_driver);\n#endif\n\tremove_proc_entry(\"driver/aironet\", NULL);\n}\n\n/*\n * Initial Wireless Extension code for Aironet driver by :\n *\tJean Tourrilhes <jt@hpl.hp.com> - HPL - 17 November 00\n * Conversion to new driver API by :\n *\tJean Tourrilhes <jt@hpl.hp.com> - HPL - 26 March 02\n * Javier also did a good amount of work here, adding some new extensions\n * and fixing my code. Let's just say that without him this code just\n * would not work at all... - Jean II\n */\n\nstatic u8 airo_rssi_to_dbm (tdsRssiEntry *rssi_rid, u8 rssi)\n{\n\tif (!rssi_rid)\n\t\treturn 0;\n\n\treturn (0x100 - rssi_rid[rssi].rssidBm);\n}\n\nstatic u8 airo_dbm_to_pct (tdsRssiEntry *rssi_rid, u8 dbm)\n{\n\tint i;\n\n\tif (!rssi_rid)\n\t\treturn 0;\n\n\tfor (i = 0; i < 256; i++)\n\t\tif (rssi_rid[i].rssidBm == dbm)\n\t\t\treturn rssi_rid[i].rssipct;\n\n\treturn 0;\n}\n\n\nstatic int airo_get_quality (StatusRid *status_rid, CapabilityRid *cap_rid)\n{\n\tint quality = 0;\n\tu16 sq;\n\n\tif ((status_rid->mode & cpu_to_le16(0x3f)) != cpu_to_le16(0x3f))\n\t\treturn 0;\n\n\tif (!(cap_rid->hardCap & cpu_to_le16(8)))\n\t\treturn 0;\n\n\tsq = le16_to_cpu(status_rid->signalQuality);\n\tif (memcmp(cap_rid->prodName, \"350\", 3))\n\t\tif (sq > 0x20)\n\t\t\tquality = 0;\n\t\telse\n\t\t\tquality = 0x20 - sq;\n\telse\n\t\tif (sq > 0xb0)\n\t\t\tquality = 0;\n\t\telse if (sq < 0x10)\n\t\t\tquality = 0xa0;\n\t\telse\n\t\t\tquality = 0xb0 - sq;\n\treturn quality;\n}\n\n#define airo_get_max_quality(cap_rid) (memcmp((cap_rid)->prodName, \"350\", 3) ? 0x20 : 0xa0)\n#define airo_get_avg_quality(cap_rid) (memcmp((cap_rid)->prodName, \"350\", 3) ? 0x10 : 0x50);\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : get protocol name\n */\nstatic int airo_get_name(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t char *cwrq,\n\t\t\t char *extra)\n{\n\tstrcpy(cwrq, \"IEEE 802.11-DS\");\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : set frequency\n */\nstatic int airo_set_freq(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t struct iw_freq *fwrq,\n\t\t\t char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tint rc = -EINPROGRESS;\t\t/* Call commit handler */\n\n\t/* If setting by frequency, convert to a channel */\n\tif(fwrq->e == 1) {\n\t\tint f = fwrq->m / 100000;\n\n\t\t/* Hack to fall through... */\n\t\tfwrq->e = 0;\n\t\tfwrq->m = ieee80211_freq_to_dsss_chan(f);\n\t}\n\t/* Setting by channel number */\n\tif((fwrq->m > 1000) || (fwrq->e > 0))\n\t\trc = -EOPNOTSUPP;\n\telse {\n\t\tint channel = fwrq->m;\n\t\t/* We should do a better check than that,\n\t\t * based on the card capability !!! */\n\t\tif((channel < 1) || (channel > 14)) {\n\t\t\tairo_print_dbg(dev->name, \"New channel value of %d is invalid!\",\n\t\t\t\tfwrq->m);\n\t\t\trc = -EINVAL;\n\t\t} else {\n\t\t\treadConfigRid(local, 1);\n\t\t\t/* Yes ! We can set it !!! */\n\t\t\tlocal->config.channelSet = cpu_to_le16(channel);\n\t\t\tset_bit (FLAG_COMMIT, &local->flags);\n\t\t}\n\t}\n\treturn rc;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : get frequency\n */\nstatic int airo_get_freq(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t struct iw_freq *fwrq,\n\t\t\t char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tStatusRid status_rid;\t\t/* Card status info */\n\tint ch;\n\n\treadConfigRid(local, 1);\n\tif ((local->config.opmode & MODE_CFG_MASK) == MODE_STA_ESS)\n\t\tstatus_rid.channel = local->config.channelSet;\n\telse\n\t\treadStatusRid(local, &status_rid, 1);\n\n\tch = le16_to_cpu(status_rid.channel);\n\tif((ch > 0) && (ch < 15)) {\n\t\tfwrq->m = ieee80211_dsss_chan_to_freq(ch) * 100000;\n\t\tfwrq->e = 1;\n\t} else {\n\t\tfwrq->m = ch;\n\t\tfwrq->e = 0;\n\t}\n\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : set ESSID\n */\nstatic int airo_set_essid(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  struct iw_point *dwrq,\n\t\t\t  char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tSsidRid SSID_rid;\t\t/* SSIDs */\n\n\t/* Reload the list of current SSID */\n\treadSsidRid(local, &SSID_rid);\n\n\t/* Check if we asked for `any' */\n\tif (dwrq->flags == 0) {\n\t\t/* Just send an empty SSID list */\n\t\tmemset(&SSID_rid, 0, sizeof(SSID_rid));\n\t} else {\n\t\tunsigned index = (dwrq->flags & IW_ENCODE_INDEX) - 1;\n\n\t\t/* Check the size of the string */\n\t\tif (dwrq->length > IW_ESSID_MAX_SIZE)\n\t\t\treturn -E2BIG ;\n\n\t\t/* Check if index is valid */\n\t\tif (index >= ARRAY_SIZE(SSID_rid.ssids))\n\t\t\treturn -EINVAL;\n\n\t\t/* Set the SSID */\n\t\tmemset(SSID_rid.ssids[index].ssid, 0,\n\t\t       sizeof(SSID_rid.ssids[index].ssid));\n\t\tmemcpy(SSID_rid.ssids[index].ssid, extra, dwrq->length);\n\t\tSSID_rid.ssids[index].len = cpu_to_le16(dwrq->length);\n\t}\n\tSSID_rid.len = cpu_to_le16(sizeof(SSID_rid));\n\t/* Write it to the card */\n\tdisable_MAC(local, 1);\n\twriteSsidRid(local, &SSID_rid, 1);\n\tenable_MAC(local, 1);\n\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : get ESSID\n */\nstatic int airo_get_essid(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  struct iw_point *dwrq,\n\t\t\t  char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tStatusRid status_rid;\t\t/* Card status info */\n\n\treadStatusRid(local, &status_rid, 1);\n\n\t/* Note : if dwrq->flags != 0, we should\n\t * get the relevant SSID from the SSID list... */\n\n\t/* Get the current SSID */\n\tmemcpy(extra, status_rid.SSID, le16_to_cpu(status_rid.SSIDlen));\n\t/* If none, we may want to get the one that was set */\n\n\t/* Push it out ! */\n\tdwrq->length = le16_to_cpu(status_rid.SSIDlen);\n\tdwrq->flags = 1; /* active */\n\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : set AP address\n */\nstatic int airo_set_wap(struct net_device *dev,\n\t\t\tstruct iw_request_info *info,\n\t\t\tstruct sockaddr *awrq,\n\t\t\tchar *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tCmd cmd;\n\tResp rsp;\n\tAPListRid APList_rid;\n\tstatic const u8 any[ETH_ALEN] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };\n\tstatic const u8 off[ETH_ALEN] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\n\tif (awrq->sa_family != ARPHRD_ETHER)\n\t\treturn -EINVAL;\n\telse if (!memcmp(any, awrq->sa_data, ETH_ALEN) ||\n\t         !memcmp(off, awrq->sa_data, ETH_ALEN)) {\n\t\tmemset(&cmd, 0, sizeof(cmd));\n\t\tcmd.cmd=CMD_LOSE_SYNC;\n\t\tif (down_interruptible(&local->sem))\n\t\t\treturn -ERESTARTSYS;\n\t\tissuecommand(local, &cmd, &rsp);\n\t\tup(&local->sem);\n\t} else {\n\t\tmemset(&APList_rid, 0, sizeof(APList_rid));\n\t\tAPList_rid.len = cpu_to_le16(sizeof(APList_rid));\n\t\tmemcpy(APList_rid.ap[0], awrq->sa_data, ETH_ALEN);\n\t\tdisable_MAC(local, 1);\n\t\twriteAPListRid(local, &APList_rid, 1);\n\t\tenable_MAC(local, 1);\n\t}\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : get AP address\n */\nstatic int airo_get_wap(struct net_device *dev,\n\t\t\tstruct iw_request_info *info,\n\t\t\tstruct sockaddr *awrq,\n\t\t\tchar *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tStatusRid status_rid;\t\t/* Card status info */\n\n\treadStatusRid(local, &status_rid, 1);\n\n\t/* Tentative. This seems to work, wow, I'm lucky !!! */\n\tmemcpy(awrq->sa_data, status_rid.bssid[0], ETH_ALEN);\n\tawrq->sa_family = ARPHRD_ETHER;\n\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : set Nickname\n */\nstatic int airo_set_nick(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t struct iw_point *dwrq,\n\t\t\t char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\n\t/* Check the size of the string */\n\tif(dwrq->length > 16) {\n\t\treturn -E2BIG;\n\t}\n\treadConfigRid(local, 1);\n\tmemset(local->config.nodeName, 0, sizeof(local->config.nodeName));\n\tmemcpy(local->config.nodeName, extra, dwrq->length);\n\tset_bit (FLAG_COMMIT, &local->flags);\n\n\treturn -EINPROGRESS;\t\t/* Call commit handler */\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : get Nickname\n */\nstatic int airo_get_nick(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t struct iw_point *dwrq,\n\t\t\t char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\n\treadConfigRid(local, 1);\n\tstrncpy(extra, local->config.nodeName, 16);\n\textra[16] = '\\0';\n\tdwrq->length = strlen(extra);\n\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : set Bit-Rate\n */\nstatic int airo_set_rate(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t struct iw_param *vwrq,\n\t\t\t char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tCapabilityRid cap_rid;\t\t/* Card capability info */\n\tu8\tbrate = 0;\n\tint\ti;\n\n\t/* First : get a valid bit rate value */\n\treadCapabilityRid(local, &cap_rid, 1);\n\n\t/* Which type of value ? */\n\tif((vwrq->value < 8) && (vwrq->value >= 0)) {\n\t\t/* Setting by rate index */\n\t\t/* Find value in the magic rate table */\n\t\tbrate = cap_rid.supportedRates[vwrq->value];\n\t} else {\n\t\t/* Setting by frequency value */\n\t\tu8\tnormvalue = (u8) (vwrq->value/500000);\n\n\t\t/* Check if rate is valid */\n\t\tfor(i = 0 ; i < 8 ; i++) {\n\t\t\tif(normvalue == cap_rid.supportedRates[i]) {\n\t\t\t\tbrate = normvalue;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t/* -1 designed the max rate (mostly auto mode) */\n\tif(vwrq->value == -1) {\n\t\t/* Get the highest available rate */\n\t\tfor(i = 0 ; i < 8 ; i++) {\n\t\t\tif(cap_rid.supportedRates[i] == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif(i != 0)\n\t\t\tbrate = cap_rid.supportedRates[i - 1];\n\t}\n\t/* Check that it is valid */\n\tif(brate == 0) {\n\t\treturn -EINVAL;\n\t}\n\n\treadConfigRid(local, 1);\n\t/* Now, check if we want a fixed or auto value */\n\tif(vwrq->fixed == 0) {\n\t\t/* Fill all the rates up to this max rate */\n\t\tmemset(local->config.rates, 0, 8);\n\t\tfor(i = 0 ; i < 8 ; i++) {\n\t\t\tlocal->config.rates[i] = cap_rid.supportedRates[i];\n\t\t\tif(local->config.rates[i] == brate)\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\t/* Fixed mode */\n\t\t/* One rate, fixed */\n\t\tmemset(local->config.rates, 0, 8);\n\t\tlocal->config.rates[0] = brate;\n\t}\n\tset_bit (FLAG_COMMIT, &local->flags);\n\n\treturn -EINPROGRESS;\t\t/* Call commit handler */\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : get Bit-Rate\n */\nstatic int airo_get_rate(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t struct iw_param *vwrq,\n\t\t\t char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tStatusRid status_rid;\t\t/* Card status info */\n\n\treadStatusRid(local, &status_rid, 1);\n\n\tvwrq->value = le16_to_cpu(status_rid.currentXmitRate) * 500000;\n\t/* If more than one rate, set auto */\n\treadConfigRid(local, 1);\n\tvwrq->fixed = (local->config.rates[1] == 0);\n\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : set RTS threshold\n */\nstatic int airo_set_rts(struct net_device *dev,\n\t\t\tstruct iw_request_info *info,\n\t\t\tstruct iw_param *vwrq,\n\t\t\tchar *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tint rthr = vwrq->value;\n\n\tif(vwrq->disabled)\n\t\trthr = AIRO_DEF_MTU;\n\tif((rthr < 0) || (rthr > AIRO_DEF_MTU)) {\n\t\treturn -EINVAL;\n\t}\n\treadConfigRid(local, 1);\n\tlocal->config.rtsThres = cpu_to_le16(rthr);\n\tset_bit (FLAG_COMMIT, &local->flags);\n\n\treturn -EINPROGRESS;\t\t/* Call commit handler */\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : get RTS threshold\n */\nstatic int airo_get_rts(struct net_device *dev,\n\t\t\tstruct iw_request_info *info,\n\t\t\tstruct iw_param *vwrq,\n\t\t\tchar *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\n\treadConfigRid(local, 1);\n\tvwrq->value = le16_to_cpu(local->config.rtsThres);\n\tvwrq->disabled = (vwrq->value >= AIRO_DEF_MTU);\n\tvwrq->fixed = 1;\n\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : set Fragmentation threshold\n */\nstatic int airo_set_frag(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t struct iw_param *vwrq,\n\t\t\t char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tint fthr = vwrq->value;\n\n\tif(vwrq->disabled)\n\t\tfthr = AIRO_DEF_MTU;\n\tif((fthr < 256) || (fthr > AIRO_DEF_MTU)) {\n\t\treturn -EINVAL;\n\t}\n\tfthr &= ~0x1;\t/* Get an even value - is it really needed ??? */\n\treadConfigRid(local, 1);\n\tlocal->config.fragThresh = cpu_to_le16(fthr);\n\tset_bit (FLAG_COMMIT, &local->flags);\n\n\treturn -EINPROGRESS;\t\t/* Call commit handler */\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : get Fragmentation threshold\n */\nstatic int airo_get_frag(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t struct iw_param *vwrq,\n\t\t\t char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\n\treadConfigRid(local, 1);\n\tvwrq->value = le16_to_cpu(local->config.fragThresh);\n\tvwrq->disabled = (vwrq->value >= AIRO_DEF_MTU);\n\tvwrq->fixed = 1;\n\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : set Mode of Operation\n */\nstatic int airo_set_mode(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t __u32 *uwrq,\n\t\t\t char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tint reset = 0;\n\n\treadConfigRid(local, 1);\n\tif (sniffing_mode(local))\n\t\treset = 1;\n\n\tswitch(*uwrq) {\n\t\tcase IW_MODE_ADHOC:\n\t\t\tlocal->config.opmode &= ~MODE_CFG_MASK;\n\t\t\tlocal->config.opmode |= MODE_STA_IBSS;\n\t\t\tlocal->config.rmode &= ~RXMODE_FULL_MASK;\n\t\t\tlocal->config.scanMode = SCANMODE_ACTIVE;\n\t\t\tclear_bit (FLAG_802_11, &local->flags);\n\t\t\tbreak;\n\t\tcase IW_MODE_INFRA:\n\t\t\tlocal->config.opmode &= ~MODE_CFG_MASK;\n\t\t\tlocal->config.opmode |= MODE_STA_ESS;\n\t\t\tlocal->config.rmode &= ~RXMODE_FULL_MASK;\n\t\t\tlocal->config.scanMode = SCANMODE_ACTIVE;\n\t\t\tclear_bit (FLAG_802_11, &local->flags);\n\t\t\tbreak;\n\t\tcase IW_MODE_MASTER:\n\t\t\tlocal->config.opmode &= ~MODE_CFG_MASK;\n\t\t\tlocal->config.opmode |= MODE_AP;\n\t\t\tlocal->config.rmode &= ~RXMODE_FULL_MASK;\n\t\t\tlocal->config.scanMode = SCANMODE_ACTIVE;\n\t\t\tclear_bit (FLAG_802_11, &local->flags);\n\t\t\tbreak;\n\t\tcase IW_MODE_REPEAT:\n\t\t\tlocal->config.opmode &= ~MODE_CFG_MASK;\n\t\t\tlocal->config.opmode |= MODE_AP_RPTR;\n\t\t\tlocal->config.rmode &= ~RXMODE_FULL_MASK;\n\t\t\tlocal->config.scanMode = SCANMODE_ACTIVE;\n\t\t\tclear_bit (FLAG_802_11, &local->flags);\n\t\t\tbreak;\n\t\tcase IW_MODE_MONITOR:\n\t\t\tlocal->config.opmode &= ~MODE_CFG_MASK;\n\t\t\tlocal->config.opmode |= MODE_STA_ESS;\n\t\t\tlocal->config.rmode &= ~RXMODE_FULL_MASK;\n\t\t\tlocal->config.rmode |= RXMODE_RFMON | RXMODE_DISABLE_802_3_HEADER;\n\t\t\tlocal->config.scanMode = SCANMODE_PASSIVE;\n\t\t\tset_bit (FLAG_802_11, &local->flags);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\tif (reset)\n\t\tset_bit (FLAG_RESET, &local->flags);\n\tset_bit (FLAG_COMMIT, &local->flags);\n\n\treturn -EINPROGRESS;\t\t/* Call commit handler */\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : get Mode of Operation\n */\nstatic int airo_get_mode(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t __u32 *uwrq,\n\t\t\t char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\n\treadConfigRid(local, 1);\n\t/* If not managed, assume it's ad-hoc */\n\tswitch (local->config.opmode & MODE_CFG_MASK) {\n\t\tcase MODE_STA_ESS:\n\t\t\t*uwrq = IW_MODE_INFRA;\n\t\t\tbreak;\n\t\tcase MODE_AP:\n\t\t\t*uwrq = IW_MODE_MASTER;\n\t\t\tbreak;\n\t\tcase MODE_AP_RPTR:\n\t\t\t*uwrq = IW_MODE_REPEAT;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*uwrq = IW_MODE_ADHOC;\n\t}\n\n\treturn 0;\n}\n\nstatic inline int valid_index(struct airo_info *ai, int index)\n{\n\treturn (index >= 0) && (index <= ai->max_wep_idx);\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : set Encryption Key\n */\nstatic int airo_set_encode(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   struct iw_point *dwrq,\n\t\t\t   char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tint perm = (dwrq->flags & IW_ENCODE_TEMP ? 0 : 1);\n\t__le16 currentAuthType = local->config.authType;\n\tint rc = 0;\n\n\tif (!local->wep_capable)\n\t\treturn -EOPNOTSUPP;\n\n\treadConfigRid(local, 1);\n\n\t/* Basic checking: do we have a key to set ?\n\t * Note : with the new API, it's impossible to get a NULL pointer.\n\t * Therefore, we need to check a key size == 0 instead.\n\t * New version of iwconfig properly set the IW_ENCODE_NOKEY flag\n\t * when no key is present (only change flags), but older versions\n\t * don't do it. - Jean II */\n\tif (dwrq->length > 0) {\n\t\twep_key_t key;\n\t\tint index = (dwrq->flags & IW_ENCODE_INDEX) - 1;\n\t\tint current_index;\n\n\t\t/* Check the size of the key */\n\t\tif (dwrq->length > MAX_KEY_SIZE) {\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tcurrent_index = get_wep_tx_idx(local);\n\t\tif (current_index < 0)\n\t\t\tcurrent_index = 0;\n\n\t\t/* Check the index (none -> use current) */\n\t\tif (!valid_index(local, index))\n\t\t\tindex = current_index;\n\n\t\t/* Set the length */\n\t\tif (dwrq->length > MIN_KEY_SIZE)\n\t\t\tkey.len = MAX_KEY_SIZE;\n\t\telse\n\t\t\tkey.len = MIN_KEY_SIZE;\n\t\t/* Check if the key is not marked as invalid */\n\t\tif(!(dwrq->flags & IW_ENCODE_NOKEY)) {\n\t\t\t/* Cleanup */\n\t\t\tmemset(key.key, 0, MAX_KEY_SIZE);\n\t\t\t/* Copy the key in the driver */\n\t\t\tmemcpy(key.key, extra, dwrq->length);\n\t\t\t/* Send the key to the card */\n\t\t\trc = set_wep_key(local, index, key.key, key.len, perm, 1);\n\t\t\tif (rc < 0) {\n\t\t\t\tairo_print_err(local->dev->name, \"failed to set\"\n\t\t\t\t               \" WEP key at index %d: %d.\",\n\t\t\t\t               index, rc);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t\t/* WE specify that if a valid key is set, encryption\n\t\t * should be enabled (user may turn it off later)\n\t\t * This is also how \"iwconfig ethX key on\" works */\n\t\tif((index == current_index) && (key.len > 0) &&\n\t\t   (local->config.authType == AUTH_OPEN)) {\n\t\t\tlocal->config.authType = AUTH_ENCRYPT;\n\t\t}\n\t} else {\n\t\t/* Do we want to just set the transmit key index ? */\n\t\tint index = (dwrq->flags & IW_ENCODE_INDEX) - 1;\n\t\tif (valid_index(local, index)) {\n\t\t\trc = set_wep_tx_idx(local, index, perm, 1);\n\t\t\tif (rc < 0) {\n\t\t\t\tairo_print_err(local->dev->name, \"failed to set\"\n\t\t\t\t               \" WEP transmit index to %d: %d.\",\n\t\t\t\t               index, rc);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t} else {\n\t\t\t/* Don't complain if only change the mode */\n\t\t\tif (!(dwrq->flags & IW_ENCODE_MODE))\n\t\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\t/* Read the flags */\n\tif(dwrq->flags & IW_ENCODE_DISABLED)\n\t\tlocal->config.authType = AUTH_OPEN;\t// disable encryption\n\tif(dwrq->flags & IW_ENCODE_RESTRICTED)\n\t\tlocal->config.authType = AUTH_SHAREDKEY;\t// Only Both\n\tif(dwrq->flags & IW_ENCODE_OPEN)\n\t\tlocal->config.authType = AUTH_ENCRYPT;\t// Only Wep\n\t/* Commit the changes to flags if needed */\n\tif (local->config.authType != currentAuthType)\n\t\tset_bit (FLAG_COMMIT, &local->flags);\n\treturn -EINPROGRESS;\t\t/* Call commit handler */\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : get Encryption Key\n */\nstatic int airo_get_encode(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   struct iw_point *dwrq,\n\t\t\t   char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tint index = (dwrq->flags & IW_ENCODE_INDEX) - 1;\n\tint wep_key_len;\n\tu8 buf[16];\n\n\tif (!local->wep_capable)\n\t\treturn -EOPNOTSUPP;\n\n\treadConfigRid(local, 1);\n\n\t/* Check encryption mode */\n\tswitch(local->config.authType)\t{\n\t\tcase AUTH_ENCRYPT:\n\t\t\tdwrq->flags = IW_ENCODE_OPEN;\n\t\t\tbreak;\n\t\tcase AUTH_SHAREDKEY:\n\t\t\tdwrq->flags = IW_ENCODE_RESTRICTED;\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase AUTH_OPEN:\n\t\t\tdwrq->flags = IW_ENCODE_DISABLED;\n\t\t\tbreak;\n\t}\n\t/* We can't return the key, so set the proper flag and return zero */\n\tdwrq->flags |= IW_ENCODE_NOKEY;\n\tmemset(extra, 0, 16);\n\n\t/* Which key do we want ? -1 -> tx index */\n\tif (!valid_index(local, index)) {\n\t\tindex = get_wep_tx_idx(local);\n\t\tif (index < 0)\n\t\t\tindex = 0;\n\t}\n\tdwrq->flags |= index + 1;\n\n\t/* Copy the key to the user buffer */\n\twep_key_len = get_wep_key(local, index, &buf[0], sizeof(buf));\n\tif (wep_key_len < 0) {\n\t\tdwrq->length = 0;\n\t} else {\n\t\tdwrq->length = wep_key_len;\n\t\tmemcpy(extra, buf, dwrq->length);\n\t}\n\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : set extended Encryption parameters\n */\nstatic int airo_set_encodeext(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu,\n\t\t\t    char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tstruct iw_point *encoding = &wrqu->encoding;\n\tstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\n\tint perm = ( encoding->flags & IW_ENCODE_TEMP ? 0 : 1 );\n\t__le16 currentAuthType = local->config.authType;\n\tint idx, key_len, alg = ext->alg, set_key = 1, rc;\n\twep_key_t key;\n\n\tif (!local->wep_capable)\n\t\treturn -EOPNOTSUPP;\n\n\treadConfigRid(local, 1);\n\n\t/* Determine and validate the key index */\n\tidx = encoding->flags & IW_ENCODE_INDEX;\n\tif (idx) {\n\t\tif (!valid_index(local, idx - 1))\n\t\t\treturn -EINVAL;\n\t\tidx--;\n\t} else {\n\t\tidx = get_wep_tx_idx(local);\n\t\tif (idx < 0)\n\t\t\tidx = 0;\n\t}\n\n\tif (encoding->flags & IW_ENCODE_DISABLED)\n\t\talg = IW_ENCODE_ALG_NONE;\n\n\tif (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {\n\t\t/* Only set transmit key index here, actual\n\t\t * key is set below if needed.\n\t\t */\n\t\trc = set_wep_tx_idx(local, idx, perm, 1);\n\t\tif (rc < 0) {\n\t\t\tairo_print_err(local->dev->name, \"failed to set \"\n\t\t\t               \"WEP transmit index to %d: %d.\",\n\t\t\t               idx, rc);\n\t\t\treturn rc;\n\t\t}\n\t\tset_key = ext->key_len > 0 ? 1 : 0;\n\t}\n\n\tif (set_key) {\n\t\t/* Set the requested key first */\n\t\tmemset(key.key, 0, MAX_KEY_SIZE);\n\t\tswitch (alg) {\n\t\tcase IW_ENCODE_ALG_NONE:\n\t\t\tkey.len = 0;\n\t\t\tbreak;\n\t\tcase IW_ENCODE_ALG_WEP:\n\t\t\tif (ext->key_len > MIN_KEY_SIZE) {\n\t\t\t\tkey.len = MAX_KEY_SIZE;\n\t\t\t} else if (ext->key_len > 0) {\n\t\t\t\tkey.len = MIN_KEY_SIZE;\n\t\t\t} else {\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tkey_len = min (ext->key_len, key.len);\n\t\t\tmemcpy(key.key, ext->key, key_len);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (key.len == 0) {\n\t\t\trc = set_wep_tx_idx(local, idx, perm, 1);\n\t\t\tif (rc < 0) {\n\t\t\t\tairo_print_err(local->dev->name,\n\t\t\t\t\t       \"failed to set WEP transmit index to %d: %d.\",\n\t\t\t\t\t       idx, rc);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t} else {\n\t\t\trc = set_wep_key(local, idx, key.key, key.len, perm, 1);\n\t\t\tif (rc < 0) {\n\t\t\t\tairo_print_err(local->dev->name,\n\t\t\t\t\t       \"failed to set WEP key at index %d: %d.\",\n\t\t\t\t\t       idx, rc);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Read the flags */\n\tif(encoding->flags & IW_ENCODE_DISABLED)\n\t\tlocal->config.authType = AUTH_OPEN;\t// disable encryption\n\tif(encoding->flags & IW_ENCODE_RESTRICTED)\n\t\tlocal->config.authType = AUTH_SHAREDKEY;\t// Only Both\n\tif(encoding->flags & IW_ENCODE_OPEN)\n\t\tlocal->config.authType = AUTH_ENCRYPT;\t// Only Wep\n\t/* Commit the changes to flags if needed */\n\tif (local->config.authType != currentAuthType)\n\t\tset_bit (FLAG_COMMIT, &local->flags);\n\n\treturn -EINPROGRESS;\n}\n\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : get extended Encryption parameters\n */\nstatic int airo_get_encodeext(struct net_device *dev,\n\t\t\t    struct iw_request_info *info,\n\t\t\t    union iwreq_data *wrqu,\n\t\t\t    char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tstruct iw_point *encoding = &wrqu->encoding;\n\tstruct iw_encode_ext *ext = (struct iw_encode_ext *)extra;\n\tint idx, max_key_len, wep_key_len;\n\tu8 buf[16];\n\n\tif (!local->wep_capable)\n\t\treturn -EOPNOTSUPP;\n\n\treadConfigRid(local, 1);\n\n\tmax_key_len = encoding->length - sizeof(*ext);\n\tif (max_key_len < 0)\n\t\treturn -EINVAL;\n\n\tidx = encoding->flags & IW_ENCODE_INDEX;\n\tif (idx) {\n\t\tif (!valid_index(local, idx - 1))\n\t\t\treturn -EINVAL;\n\t\tidx--;\n\t} else {\n\t\tidx = get_wep_tx_idx(local);\n\t\tif (idx < 0)\n\t\t\tidx = 0;\n\t}\n\n\tencoding->flags = idx + 1;\n\tmemset(ext, 0, sizeof(*ext));\n\n\t/* Check encryption mode */\n\tswitch(local->config.authType) {\n\t\tcase AUTH_ENCRYPT:\n\t\t\tencoding->flags = IW_ENCODE_ALG_WEP | IW_ENCODE_ENABLED;\n\t\t\tbreak;\n\t\tcase AUTH_SHAREDKEY:\n\t\t\tencoding->flags = IW_ENCODE_ALG_WEP | IW_ENCODE_ENABLED;\n\t\t\tbreak;\n\t\tdefault:\n\t\tcase AUTH_OPEN:\n\t\t\tencoding->flags = IW_ENCODE_ALG_NONE | IW_ENCODE_DISABLED;\n\t\t\tbreak;\n\t}\n\t/* We can't return the key, so set the proper flag and return zero */\n\tencoding->flags |= IW_ENCODE_NOKEY;\n\tmemset(extra, 0, 16);\n\t\n\t/* Copy the key to the user buffer */\n\twep_key_len = get_wep_key(local, idx, &buf[0], sizeof(buf));\n\tif (wep_key_len < 0) {\n\t\text->key_len = 0;\n\t} else {\n\t\text->key_len = wep_key_len;\n\t\tmemcpy(extra, buf, ext->key_len);\n\t}\n\n\treturn 0;\n}\n\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : set extended authentication parameters\n */\nstatic int airo_set_auth(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tstruct iw_param *param = &wrqu->param;\n\t__le16 currentAuthType = local->config.authType;\n\n\tswitch (param->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_WPA_VERSION:\n\tcase IW_AUTH_CIPHER_PAIRWISE:\n\tcase IW_AUTH_CIPHER_GROUP:\n\tcase IW_AUTH_KEY_MGMT:\n\tcase IW_AUTH_RX_UNENCRYPTED_EAPOL:\n\tcase IW_AUTH_PRIVACY_INVOKED:\n\t\t/*\n\t\t * airo does not use these parameters\n\t\t */\n\t\tbreak;\n\n\tcase IW_AUTH_DROP_UNENCRYPTED:\n\t\tif (param->value) {\n\t\t\t/* Only change auth type if unencrypted */\n\t\t\tif (currentAuthType == AUTH_OPEN)\n\t\t\t\tlocal->config.authType = AUTH_ENCRYPT;\n\t\t} else {\n\t\t\tlocal->config.authType = AUTH_OPEN;\n\t\t}\n\n\t\t/* Commit the changes to flags if needed */\n\t\tif (local->config.authType != currentAuthType)\n\t\t\tset_bit (FLAG_COMMIT, &local->flags);\n\t\tbreak;\n\n\tcase IW_AUTH_80211_AUTH_ALG: {\n\t\t\t/* FIXME: What about AUTH_OPEN?  This API seems to\n\t\t\t * disallow setting our auth to AUTH_OPEN.\n\t\t\t */\n\t\t\tif (param->value & IW_AUTH_ALG_SHARED_KEY) {\n\t\t\t\tlocal->config.authType = AUTH_SHAREDKEY;\n\t\t\t} else if (param->value & IW_AUTH_ALG_OPEN_SYSTEM) {\n\t\t\t\tlocal->config.authType = AUTH_ENCRYPT;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\n\t\t\t/* Commit the changes to flags if needed */\n\t\t\tif (local->config.authType != currentAuthType)\n\t\t\t\tset_bit (FLAG_COMMIT, &local->flags);\n\t\t\tbreak;\n\t\t}\n\n\tcase IW_AUTH_WPA_ENABLED:\n\t\t/* Silently accept disable of WPA */\n\t\tif (param->value > 0)\n\t\t\treturn -EOPNOTSUPP;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn -EINPROGRESS;\n}\n\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : get extended authentication parameters\n */\nstatic int airo_get_auth(struct net_device *dev,\n\t\t\t       struct iw_request_info *info,\n\t\t\t       union iwreq_data *wrqu, char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tstruct iw_param *param = &wrqu->param;\n\t__le16 currentAuthType = local->config.authType;\n\n\tswitch (param->flags & IW_AUTH_INDEX) {\n\tcase IW_AUTH_DROP_UNENCRYPTED:\n\t\tswitch (currentAuthType) {\n\t\tcase AUTH_SHAREDKEY:\n\t\tcase AUTH_ENCRYPT:\n\t\t\tparam->value = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tparam->value = 0;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase IW_AUTH_80211_AUTH_ALG:\n\t\tswitch (currentAuthType) {\n\t\tcase AUTH_SHAREDKEY:\n\t\t\tparam->value = IW_AUTH_ALG_SHARED_KEY;\n\t\t\tbreak;\n\t\tcase AUTH_ENCRYPT:\n\t\tdefault:\n\t\t\tparam->value = IW_AUTH_ALG_OPEN_SYSTEM;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase IW_AUTH_WPA_ENABLED:\n\t\tparam->value = 0;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\treturn 0;\n}\n\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : set Tx-Power\n */\nstatic int airo_set_txpow(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  struct iw_param *vwrq,\n\t\t\t  char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tCapabilityRid cap_rid;\t\t/* Card capability info */\n\tint i;\n\tint rc = -EINVAL;\n\t__le16 v = cpu_to_le16(vwrq->value);\n\n\treadCapabilityRid(local, &cap_rid, 1);\n\n\tif (vwrq->disabled) {\n\t\tset_bit (FLAG_RADIO_OFF, &local->flags);\n\t\tset_bit (FLAG_COMMIT, &local->flags);\n\t\treturn -EINPROGRESS;\t\t/* Call commit handler */\n\t}\n\tif (vwrq->flags != IW_TXPOW_MWATT) {\n\t\treturn -EINVAL;\n\t}\n\tclear_bit (FLAG_RADIO_OFF, &local->flags);\n\tfor (i = 0; i < 8 && cap_rid.txPowerLevels[i]; i++)\n\t\tif (v == cap_rid.txPowerLevels[i]) {\n\t\t\treadConfigRid(local, 1);\n\t\t\tlocal->config.txPower = v;\n\t\t\tset_bit (FLAG_COMMIT, &local->flags);\n\t\t\trc = -EINPROGRESS;\t/* Call commit handler */\n\t\t\tbreak;\n\t\t}\n\treturn rc;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : get Tx-Power\n */\nstatic int airo_get_txpow(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  struct iw_param *vwrq,\n\t\t\t  char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\n\treadConfigRid(local, 1);\n\tvwrq->value = le16_to_cpu(local->config.txPower);\n\tvwrq->fixed = 1;\t/* No power control */\n\tvwrq->disabled = test_bit(FLAG_RADIO_OFF, &local->flags);\n\tvwrq->flags = IW_TXPOW_MWATT;\n\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : set Retry limits\n */\nstatic int airo_set_retry(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  struct iw_param *vwrq,\n\t\t\t  char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tint rc = -EINVAL;\n\n\tif(vwrq->disabled) {\n\t\treturn -EINVAL;\n\t}\n\treadConfigRid(local, 1);\n\tif(vwrq->flags & IW_RETRY_LIMIT) {\n\t\t__le16 v = cpu_to_le16(vwrq->value);\n\t\tif(vwrq->flags & IW_RETRY_LONG)\n\t\t\tlocal->config.longRetryLimit = v;\n\t\telse if (vwrq->flags & IW_RETRY_SHORT)\n\t\t\tlocal->config.shortRetryLimit = v;\n\t\telse {\n\t\t\t/* No modifier : set both */\n\t\t\tlocal->config.longRetryLimit = v;\n\t\t\tlocal->config.shortRetryLimit = v;\n\t\t}\n\t\tset_bit (FLAG_COMMIT, &local->flags);\n\t\trc = -EINPROGRESS;\t\t/* Call commit handler */\n\t}\n\tif(vwrq->flags & IW_RETRY_LIFETIME) {\n\t\tlocal->config.txLifetime = cpu_to_le16(vwrq->value / 1024);\n\t\tset_bit (FLAG_COMMIT, &local->flags);\n\t\trc = -EINPROGRESS;\t\t/* Call commit handler */\n\t}\n\treturn rc;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : get Retry limits\n */\nstatic int airo_get_retry(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  struct iw_param *vwrq,\n\t\t\t  char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\n\tvwrq->disabled = 0;      /* Can't be disabled */\n\n\treadConfigRid(local, 1);\n\t/* Note : by default, display the min retry number */\n\tif((vwrq->flags & IW_RETRY_TYPE) == IW_RETRY_LIFETIME) {\n\t\tvwrq->flags = IW_RETRY_LIFETIME;\n\t\tvwrq->value = le16_to_cpu(local->config.txLifetime) * 1024;\n\t} else if((vwrq->flags & IW_RETRY_LONG)) {\n\t\tvwrq->flags = IW_RETRY_LIMIT | IW_RETRY_LONG;\n\t\tvwrq->value = le16_to_cpu(local->config.longRetryLimit);\n\t} else {\n\t\tvwrq->flags = IW_RETRY_LIMIT;\n\t\tvwrq->value = le16_to_cpu(local->config.shortRetryLimit);\n\t\tif(local->config.shortRetryLimit != local->config.longRetryLimit)\n\t\t\tvwrq->flags |= IW_RETRY_SHORT;\n\t}\n\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : get range info\n */\nstatic int airo_get_range(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  struct iw_point *dwrq,\n\t\t\t  char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tstruct iw_range *range = (struct iw_range *) extra;\n\tCapabilityRid cap_rid;\t\t/* Card capability info */\n\tint\t\ti;\n\tint\t\tk;\n\n\treadCapabilityRid(local, &cap_rid, 1);\n\n\tdwrq->length = sizeof(struct iw_range);\n\tmemset(range, 0, sizeof(*range));\n\trange->min_nwid = 0x0000;\n\trange->max_nwid = 0x0000;\n\trange->num_channels = 14;\n\t/* Should be based on cap_rid.country to give only\n\t * what the current card support */\n\tk = 0;\n\tfor(i = 0; i < 14; i++) {\n\t\trange->freq[k].i = i + 1; /* List index */\n\t\trange->freq[k].m = ieee80211_dsss_chan_to_freq(i + 1) * 100000;\n\t\trange->freq[k++].e = 1;\t/* Values in MHz -> * 10^5 * 10 */\n\t}\n\trange->num_frequency = k;\n\n\trange->sensitivity = 65535;\n\n\t/* Hum... Should put the right values there */\n\tif (local->rssi)\n\t\trange->max_qual.qual = 100;\t/* % */\n\telse\n\t\trange->max_qual.qual = airo_get_max_quality(&cap_rid);\n\trange->max_qual.level = 0x100 - 120;\t/* -120 dBm */\n\trange->max_qual.noise = 0x100 - 120;\t/* -120 dBm */\n\n\t/* Experimental measurements - boundary 11/5.5 Mb/s */\n\t/* Note : with or without the (local->rssi), results\n\t * are somewhat different. - Jean II */\n\tif (local->rssi) {\n\t\trange->avg_qual.qual = 50;\t\t/* % */\n\t\trange->avg_qual.level = 0x100 - 70;\t/* -70 dBm */\n\t} else {\n\t\trange->avg_qual.qual = airo_get_avg_quality(&cap_rid);\n\t\trange->avg_qual.level = 0x100 - 80;\t/* -80 dBm */\n\t}\n\trange->avg_qual.noise = 0x100 - 85;\t\t/* -85 dBm */\n\n\tfor(i = 0 ; i < 8 ; i++) {\n\t\trange->bitrate[i] = cap_rid.supportedRates[i] * 500000;\n\t\tif(range->bitrate[i] == 0)\n\t\t\tbreak;\n\t}\n\trange->num_bitrates = i;\n\n\t/* Set an indication of the max TCP throughput\n\t * in bit/s that we can expect using this interface.\n\t * May be use for QoS stuff... Jean II */\n\tif(i > 2)\n\t\trange->throughput = 5000 * 1000;\n\telse\n\t\trange->throughput = 1500 * 1000;\n\n\trange->min_rts = 0;\n\trange->max_rts = AIRO_DEF_MTU;\n\trange->min_frag = 256;\n\trange->max_frag = AIRO_DEF_MTU;\n\n\tif(cap_rid.softCap & cpu_to_le16(2)) {\n\t\t// WEP: RC4 40 bits\n\t\trange->encoding_size[0] = 5;\n\t\t// RC4 ~128 bits\n\t\tif (cap_rid.softCap & cpu_to_le16(0x100)) {\n\t\t\trange->encoding_size[1] = 13;\n\t\t\trange->num_encoding_sizes = 2;\n\t\t} else\n\t\t\trange->num_encoding_sizes = 1;\n\t\trange->max_encoding_tokens =\n\t\t\tcap_rid.softCap & cpu_to_le16(0x80) ? 4 : 1;\n\t} else {\n\t\trange->num_encoding_sizes = 0;\n\t\trange->max_encoding_tokens = 0;\n\t}\n\trange->min_pmp = 0;\n\trange->max_pmp = 5000000;\t/* 5 secs */\n\trange->min_pmt = 0;\n\trange->max_pmt = 65535 * 1024;\t/* ??? */\n\trange->pmp_flags = IW_POWER_PERIOD;\n\trange->pmt_flags = IW_POWER_TIMEOUT;\n\trange->pm_capa = IW_POWER_PERIOD | IW_POWER_TIMEOUT | IW_POWER_ALL_R;\n\n\t/* Transmit Power - values are in mW */\n\tfor(i = 0 ; i < 8 ; i++) {\n\t\trange->txpower[i] = le16_to_cpu(cap_rid.txPowerLevels[i]);\n\t\tif(range->txpower[i] == 0)\n\t\t\tbreak;\n\t}\n\trange->num_txpower = i;\n\trange->txpower_capa = IW_TXPOW_MWATT;\n\trange->we_version_source = 19;\n\trange->we_version_compiled = WIRELESS_EXT;\n\trange->retry_capa = IW_RETRY_LIMIT | IW_RETRY_LIFETIME;\n\trange->retry_flags = IW_RETRY_LIMIT;\n\trange->r_time_flags = IW_RETRY_LIFETIME;\n\trange->min_retry = 1;\n\trange->max_retry = 65535;\n\trange->min_r_time = 1024;\n\trange->max_r_time = 65535 * 1024;\n\n\t/* Event capability (kernel + driver) */\n\trange->event_capa[0] = (IW_EVENT_CAPA_K_0 |\n\t\t\t\tIW_EVENT_CAPA_MASK(SIOCGIWTHRSPY) |\n\t\t\t\tIW_EVENT_CAPA_MASK(SIOCGIWAP) |\n\t\t\t\tIW_EVENT_CAPA_MASK(SIOCGIWSCAN));\n\trange->event_capa[1] = IW_EVENT_CAPA_K_1;\n\trange->event_capa[4] = IW_EVENT_CAPA_MASK(IWEVTXDROP);\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : set Power Management\n */\nstatic int airo_set_power(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  struct iw_param *vwrq,\n\t\t\t  char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\n\treadConfigRid(local, 1);\n\tif (vwrq->disabled) {\n\t\tif (sniffing_mode(local))\n\t\t\treturn -EINVAL;\n\t\tlocal->config.powerSaveMode = POWERSAVE_CAM;\n\t\tlocal->config.rmode &= ~RXMODE_MASK;\n\t\tlocal->config.rmode |= RXMODE_BC_MC_ADDR;\n\t\tset_bit (FLAG_COMMIT, &local->flags);\n\t\treturn -EINPROGRESS;\t\t/* Call commit handler */\n\t}\n\tif ((vwrq->flags & IW_POWER_TYPE) == IW_POWER_TIMEOUT) {\n\t\tlocal->config.fastListenDelay = cpu_to_le16((vwrq->value + 500) / 1024);\n\t\tlocal->config.powerSaveMode = POWERSAVE_PSPCAM;\n\t\tset_bit (FLAG_COMMIT, &local->flags);\n\t} else if ((vwrq->flags & IW_POWER_TYPE) == IW_POWER_PERIOD) {\n\t\tlocal->config.fastListenInterval =\n\t\tlocal->config.listenInterval =\n\t\t\tcpu_to_le16((vwrq->value + 500) / 1024);\n\t\tlocal->config.powerSaveMode = POWERSAVE_PSPCAM;\n\t\tset_bit (FLAG_COMMIT, &local->flags);\n\t}\n\tswitch (vwrq->flags & IW_POWER_MODE) {\n\t\tcase IW_POWER_UNICAST_R:\n\t\t\tif (sniffing_mode(local))\n\t\t\t\treturn -EINVAL;\n\t\t\tlocal->config.rmode &= ~RXMODE_MASK;\n\t\t\tlocal->config.rmode |= RXMODE_ADDR;\n\t\t\tset_bit (FLAG_COMMIT, &local->flags);\n\t\t\tbreak;\n\t\tcase IW_POWER_ALL_R:\n\t\t\tif (sniffing_mode(local))\n\t\t\t\treturn -EINVAL;\n\t\t\tlocal->config.rmode &= ~RXMODE_MASK;\n\t\t\tlocal->config.rmode |= RXMODE_BC_MC_ADDR;\n\t\t\tset_bit (FLAG_COMMIT, &local->flags);\n\t\tcase IW_POWER_ON:\n\t\t\t/* This is broken, fixme ;-) */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t}\n\t// Note : we may want to factor local->need_commit here\n\t// Note2 : may also want to factor RXMODE_RFMON test\n\treturn -EINPROGRESS;\t\t/* Call commit handler */\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : get Power Management\n */\nstatic int airo_get_power(struct net_device *dev,\n\t\t\t  struct iw_request_info *info,\n\t\t\t  struct iw_param *vwrq,\n\t\t\t  char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\t__le16 mode;\n\n\treadConfigRid(local, 1);\n\tmode = local->config.powerSaveMode;\n\tif ((vwrq->disabled = (mode == POWERSAVE_CAM)))\n\t\treturn 0;\n\tif ((vwrq->flags & IW_POWER_TYPE) == IW_POWER_TIMEOUT) {\n\t\tvwrq->value = le16_to_cpu(local->config.fastListenDelay) * 1024;\n\t\tvwrq->flags = IW_POWER_TIMEOUT;\n\t} else {\n\t\tvwrq->value = le16_to_cpu(local->config.fastListenInterval) * 1024;\n\t\tvwrq->flags = IW_POWER_PERIOD;\n\t}\n\tif ((local->config.rmode & RXMODE_MASK) == RXMODE_ADDR)\n\t\tvwrq->flags |= IW_POWER_UNICAST_R;\n\telse\n\t\tvwrq->flags |= IW_POWER_ALL_R;\n\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : set Sensitivity\n */\nstatic int airo_set_sens(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t struct iw_param *vwrq,\n\t\t\t char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\n\treadConfigRid(local, 1);\n\tlocal->config.rssiThreshold =\n\t\tcpu_to_le16(vwrq->disabled ? RSSI_DEFAULT : vwrq->value);\n\tset_bit (FLAG_COMMIT, &local->flags);\n\n\treturn -EINPROGRESS;\t\t/* Call commit handler */\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : get Sensitivity\n */\nstatic int airo_get_sens(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t struct iw_param *vwrq,\n\t\t\t char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\n\treadConfigRid(local, 1);\n\tvwrq->value = le16_to_cpu(local->config.rssiThreshold);\n\tvwrq->disabled = (vwrq->value == 0);\n\tvwrq->fixed = 1;\n\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : get AP List\n * Note : this is deprecated in favor of IWSCAN\n */\nstatic int airo_get_aplist(struct net_device *dev,\n\t\t\t   struct iw_request_info *info,\n\t\t\t   struct iw_point *dwrq,\n\t\t\t   char *extra)\n{\n\tstruct airo_info *local = dev->ml_priv;\n\tstruct sockaddr *address = (struct sockaddr *) extra;\n\tstruct iw_quality *qual;\n\tBSSListRid BSSList;\n\tint i;\n\tint loseSync = capable(CAP_NET_ADMIN) ? 1: -1;\n\n\tqual = kmalloc(IW_MAX_AP * sizeof(*qual), GFP_KERNEL);\n\tif (!qual)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < IW_MAX_AP; i++) {\n\t\tu16 dBm;\n\t\tif (readBSSListRid(local, loseSync, &BSSList))\n\t\t\tbreak;\n\t\tloseSync = 0;\n\t\tmemcpy(address[i].sa_data, BSSList.bssid, ETH_ALEN);\n\t\taddress[i].sa_family = ARPHRD_ETHER;\n\t\tdBm = le16_to_cpu(BSSList.dBm);\n\t\tif (local->rssi) {\n\t\t\tqual[i].level = 0x100 - dBm;\n\t\t\tqual[i].qual = airo_dbm_to_pct(local->rssi, dBm);\n\t\t\tqual[i].updated = IW_QUAL_QUAL_UPDATED\n\t\t\t\t\t| IW_QUAL_LEVEL_UPDATED\n\t\t\t\t\t| IW_QUAL_DBM;\n\t\t} else {\n\t\t\tqual[i].level = (dBm + 321) / 2;\n\t\t\tqual[i].qual = 0;\n\t\t\tqual[i].updated = IW_QUAL_QUAL_INVALID\n\t\t\t\t\t| IW_QUAL_LEVEL_UPDATED\n\t\t\t\t\t| IW_QUAL_DBM;\n\t\t}\n\t\tqual[i].noise = local->wstats.qual.noise;\n\t\tif (BSSList.index == cpu_to_le16(0xffff))\n\t\t\tbreak;\n\t}\n\tif (!i) {\n\t\tStatusRid status_rid;\t\t/* Card status info */\n\t\treadStatusRid(local, &status_rid, 1);\n\t\tfor (i = 0;\n\t\t     i < min(IW_MAX_AP, 4) &&\n\t\t\t     (status_rid.bssid[i][0]\n\t\t\t      & status_rid.bssid[i][1]\n\t\t\t      & status_rid.bssid[i][2]\n\t\t\t      & status_rid.bssid[i][3]\n\t\t\t      & status_rid.bssid[i][4]\n\t\t\t      & status_rid.bssid[i][5])!=0xff &&\n\t\t\t     (status_rid.bssid[i][0]\n\t\t\t      | status_rid.bssid[i][1]\n\t\t\t      | status_rid.bssid[i][2]\n\t\t\t      | status_rid.bssid[i][3]\n\t\t\t      | status_rid.bssid[i][4]\n\t\t\t      | status_rid.bssid[i][5]);\n\t\t     i++) {\n\t\t\tmemcpy(address[i].sa_data,\n\t\t\t       status_rid.bssid[i], ETH_ALEN);\n\t\t\taddress[i].sa_family = ARPHRD_ETHER;\n\t\t}\n\t} else {\n\t\tdwrq->flags = 1; /* Should be define'd */\n\t\tmemcpy(extra + sizeof(struct sockaddr)*i,\n\t\t       &qual,  sizeof(struct iw_quality)*i);\n\t}\n\tdwrq->length = i;\n\n\tkfree(qual);\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : Initiate Scan\n */\nstatic int airo_set_scan(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t struct iw_point *dwrq,\n\t\t\t char *extra)\n{\n\tstruct airo_info *ai = dev->ml_priv;\n\tCmd cmd;\n\tResp rsp;\n\tint wake = 0;\n\n\t/* Note : you may have realised that, as this is a SET operation,\n\t * this is privileged and therefore a normal user can't\n\t * perform scanning.\n\t * This is not an error, while the device perform scanning,\n\t * traffic doesn't flow, so it's a perfect DoS...\n\t * Jean II */\n\tif (ai->flags & FLAG_RADIO_MASK) return -ENETDOWN;\n\n\tif (down_interruptible(&ai->sem))\n\t\treturn -ERESTARTSYS;\n\n\t/* If there's already a scan in progress, don't\n\t * trigger another one. */\n\tif (ai->scan_timeout > 0)\n\t\tgoto out;\n\n\t/* Initiate a scan command */\n\tai->scan_timeout = RUN_AT(3*HZ);\n\tmemset(&cmd, 0, sizeof(cmd));\n\tcmd.cmd=CMD_LISTBSS;\n\tissuecommand(ai, &cmd, &rsp);\n\twake = 1;\n\nout:\n\tup(&ai->sem);\n\tif (wake)\n\t\twake_up_interruptible(&ai->thr_wait);\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Translate scan data returned from the card to a card independent\n * format that the Wireless Tools will understand - Jean II\n */\nstatic inline char *airo_translate_scan(struct net_device *dev,\n\t\t\t\t\tstruct iw_request_info *info,\n\t\t\t\t\tchar *current_ev,\n\t\t\t\t\tchar *end_buf,\n\t\t\t\t\tBSSListRid *bss)\n{\n\tstruct airo_info *ai = dev->ml_priv;\n\tstruct iw_event\t\tiwe;\t\t/* Temporary buffer */\n\t__le16\t\t\tcapabilities;\n\tchar *\t\t\tcurrent_val;\t/* For rates */\n\tint\t\t\ti;\n\tchar *\t\tbuf;\n\tu16 dBm;\n\n\t/* First entry *MUST* be the AP MAC address */\n\tiwe.cmd = SIOCGIWAP;\n\tiwe.u.ap_addr.sa_family = ARPHRD_ETHER;\n\tmemcpy(iwe.u.ap_addr.sa_data, bss->bssid, ETH_ALEN);\n\tcurrent_ev = iwe_stream_add_event(info, current_ev, end_buf,\n\t\t\t\t\t  &iwe, IW_EV_ADDR_LEN);\n\n\t/* Other entries will be displayed in the order we give them */\n\n\t/* Add the ESSID */\n\tiwe.u.data.length = bss->ssidLen;\n\tif(iwe.u.data.length > 32)\n\t\tiwe.u.data.length = 32;\n\tiwe.cmd = SIOCGIWESSID;\n\tiwe.u.data.flags = 1;\n\tcurrent_ev = iwe_stream_add_point(info, current_ev, end_buf,\n\t\t\t\t\t  &iwe, bss->ssid);\n\n\t/* Add mode */\n\tiwe.cmd = SIOCGIWMODE;\n\tcapabilities = bss->cap;\n\tif(capabilities & (CAP_ESS | CAP_IBSS)) {\n\t\tif(capabilities & CAP_ESS)\n\t\t\tiwe.u.mode = IW_MODE_MASTER;\n\t\telse\n\t\t\tiwe.u.mode = IW_MODE_ADHOC;\n\t\tcurrent_ev = iwe_stream_add_event(info, current_ev, end_buf,\n\t\t\t\t\t\t  &iwe, IW_EV_UINT_LEN);\n\t}\n\n\t/* Add frequency */\n\tiwe.cmd = SIOCGIWFREQ;\n\tiwe.u.freq.m = le16_to_cpu(bss->dsChannel);\n\tiwe.u.freq.m = ieee80211_dsss_chan_to_freq(iwe.u.freq.m) * 100000;\n\tiwe.u.freq.e = 1;\n\tcurrent_ev = iwe_stream_add_event(info, current_ev, end_buf,\n\t\t\t\t\t  &iwe, IW_EV_FREQ_LEN);\n\n\tdBm = le16_to_cpu(bss->dBm);\n\n\t/* Add quality statistics */\n\tiwe.cmd = IWEVQUAL;\n\tif (ai->rssi) {\n\t\tiwe.u.qual.level = 0x100 - dBm;\n\t\tiwe.u.qual.qual = airo_dbm_to_pct(ai->rssi, dBm);\n\t\tiwe.u.qual.updated = IW_QUAL_QUAL_UPDATED\n\t\t\t\t| IW_QUAL_LEVEL_UPDATED\n\t\t\t\t| IW_QUAL_DBM;\n\t} else {\n\t\tiwe.u.qual.level = (dBm + 321) / 2;\n\t\tiwe.u.qual.qual = 0;\n\t\tiwe.u.qual.updated = IW_QUAL_QUAL_INVALID\n\t\t\t\t| IW_QUAL_LEVEL_UPDATED\n\t\t\t\t| IW_QUAL_DBM;\n\t}\n\tiwe.u.qual.noise = ai->wstats.qual.noise;\n\tcurrent_ev = iwe_stream_add_event(info, current_ev, end_buf,\n\t\t\t\t\t  &iwe, IW_EV_QUAL_LEN);\n\n\t/* Add encryption capability */\n\tiwe.cmd = SIOCGIWENCODE;\n\tif(capabilities & CAP_PRIVACY)\n\t\tiwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;\n\telse\n\t\tiwe.u.data.flags = IW_ENCODE_DISABLED;\n\tiwe.u.data.length = 0;\n\tcurrent_ev = iwe_stream_add_point(info, current_ev, end_buf,\n\t\t\t\t\t  &iwe, bss->ssid);\n\n\t/* Rate : stuffing multiple values in a single event require a bit\n\t * more of magic - Jean II */\n\tcurrent_val = current_ev + iwe_stream_lcp_len(info);\n\n\tiwe.cmd = SIOCGIWRATE;\n\t/* Those two flags are ignored... */\n\tiwe.u.bitrate.fixed = iwe.u.bitrate.disabled = 0;\n\t/* Max 8 values */\n\tfor(i = 0 ; i < 8 ; i++) {\n\t\t/* NULL terminated */\n\t\tif(bss->rates[i] == 0)\n\t\t\tbreak;\n\t\t/* Bit rate given in 500 kb/s units (+ 0x80) */\n\t\tiwe.u.bitrate.value = ((bss->rates[i] & 0x7f) * 500000);\n\t\t/* Add new value to event */\n\t\tcurrent_val = iwe_stream_add_value(info, current_ev,\n\t\t\t\t\t\t   current_val, end_buf,\n\t\t\t\t\t\t   &iwe, IW_EV_PARAM_LEN);\n\t}\n\t/* Check if we added any event */\n\tif ((current_val - current_ev) > iwe_stream_lcp_len(info))\n\t\tcurrent_ev = current_val;\n\n\t/* Beacon interval */\n\tbuf = kmalloc(30, GFP_KERNEL);\n\tif (buf) {\n\t\tiwe.cmd = IWEVCUSTOM;\n\t\tsprintf(buf, \"bcn_int=%d\", bss->beaconInterval);\n\t\tiwe.u.data.length = strlen(buf);\n\t\tcurrent_ev = iwe_stream_add_point(info, current_ev, end_buf,\n\t\t\t\t\t\t  &iwe, buf);\n\t\tkfree(buf);\n\t}\n\n\t/* Put WPA/RSN Information Elements into the event stream */\n\tif (test_bit(FLAG_WPA_CAPABLE, &ai->flags)) {\n\t\tunsigned int num_null_ies = 0;\n\t\tu16 length = sizeof (bss->extra.iep);\n\t\tu8 *ie = (void *)&bss->extra.iep;\n\n\t\twhile ((length >= 2) && (num_null_ies < 2)) {\n\t\t\tif (2 + ie[1] > length) {\n\t\t\t\t/* Invalid element, don't continue parsing IE */\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (ie[0]) {\n\t\t\tcase WLAN_EID_SSID:\n\t\t\t\t/* Two zero-length SSID elements\n\t\t\t\t * mean we're done parsing elements */\n\t\t\t\tif (!ie[1])\n\t\t\t\t\tnum_null_ies++;\n\t\t\t\tbreak;\n\n\t\t\tcase WLAN_EID_GENERIC:\n\t\t\t\tif (ie[1] >= 4 &&\n\t\t\t\t    ie[2] == 0x00 &&\n\t\t\t\t    ie[3] == 0x50 &&\n\t\t\t\t    ie[4] == 0xf2 &&\n\t\t\t\t    ie[5] == 0x01) {\n\t\t\t\t\tiwe.cmd = IWEVGENIE;\n\t\t\t\t\t/* 64 is an arbitrary cut-off */\n\t\t\t\t\tiwe.u.data.length = min(ie[1] + 2,\n\t\t\t\t\t\t\t\t64);\n\t\t\t\t\tcurrent_ev = iwe_stream_add_point(\n\t\t\t\t\t\t\tinfo, current_ev,\n\t\t\t\t\t\t\tend_buf, &iwe, ie);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase WLAN_EID_RSN:\n\t\t\t\tiwe.cmd = IWEVGENIE;\n\t\t\t\t/* 64 is an arbitrary cut-off */\n\t\t\t\tiwe.u.data.length = min(ie[1] + 2, 64);\n\t\t\t\tcurrent_ev = iwe_stream_add_point(\n\t\t\t\t\tinfo, current_ev, end_buf,\n\t\t\t\t\t&iwe, ie);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlength -= 2 + ie[1];\n\t\t\tie += 2 + ie[1];\n\t\t}\n\t}\n\treturn current_ev;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Wireless Handler : Read Scan Results\n */\nstatic int airo_get_scan(struct net_device *dev,\n\t\t\t struct iw_request_info *info,\n\t\t\t struct iw_point *dwrq,\n\t\t\t char *extra)\n{\n\tstruct airo_info *ai = dev->ml_priv;\n\tBSSListElement *net;\n\tint err = 0;\n\tchar *current_ev = extra;\n\n\t/* If a scan is in-progress, return -EAGAIN */\n\tif (ai->scan_timeout > 0)\n\t\treturn -EAGAIN;\n\n\tif (down_interruptible(&ai->sem))\n\t\treturn -EAGAIN;\n\n\tlist_for_each_entry (net, &ai->network_list, list) {\n\t\t/* Translate to WE format this entry */\n\t\tcurrent_ev = airo_translate_scan(dev, info, current_ev,\n\t\t\t\t\t\t extra + dwrq->length,\n\t\t\t\t\t\t &net->bss);\n\n\t\t/* Check if there is space for one more entry */\n\t\tif((extra + dwrq->length - current_ev) <= IW_EV_ADDR_LEN) {\n\t\t\t/* Ask user space to try again with a bigger buffer */\n\t\t\terr = -E2BIG;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* Length of data */\n\tdwrq->length = (current_ev - extra);\n\tdwrq->flags = 0;\t/* todo */\n\nout:\n\tup(&ai->sem);\n\treturn err;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Commit handler : called after a bunch of SET operations\n */\nstatic int airo_config_commit(struct net_device *dev,\n\t\t\t      struct iw_request_info *info,\t/* NULL */\n\t\t\t      void *zwrq,\t\t\t/* NULL */\n\t\t\t      char *extra)\t\t\t/* NULL */\n{\n\tstruct airo_info *local = dev->ml_priv;\n\n\tif (!test_bit (FLAG_COMMIT, &local->flags))\n\t\treturn 0;\n\n\t/* Some of the \"SET\" function may have modified some of the\n\t * parameters. It's now time to commit them in the card */\n\tdisable_MAC(local, 1);\n\tif (test_bit (FLAG_RESET, &local->flags)) {\n\t\tAPListRid APList_rid;\n\t\tSsidRid SSID_rid;\n\n\t\treadAPListRid(local, &APList_rid);\n\t\treadSsidRid(local, &SSID_rid);\n\t\tif (test_bit(FLAG_MPI,&local->flags))\n\t\t\tsetup_card(local, dev->dev_addr, 1 );\n\t\telse\n\t\t\treset_airo_card(dev);\n\t\tdisable_MAC(local, 1);\n\t\twriteSsidRid(local, &SSID_rid, 1);\n\t\twriteAPListRid(local, &APList_rid, 1);\n\t}\n\tif (down_interruptible(&local->sem))\n\t\treturn -ERESTARTSYS;\n\twriteConfigRid(local, 0);\n\tenable_MAC(local, 0);\n\tif (test_bit (FLAG_RESET, &local->flags))\n\t\tairo_set_promisc(local);\n\telse\n\t\tup(&local->sem);\n\n\treturn 0;\n}\n\n/*------------------------------------------------------------------*/\n/*\n * Structures to export the Wireless Handlers\n */\n\nstatic const struct iw_priv_args airo_private_args[] = {\n/*{ cmd,         set_args,                            get_args, name } */\n  { AIROIOCTL, IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | sizeof (aironet_ioctl),\n    IW_PRIV_TYPE_BYTE | 2047, \"airoioctl\" },\n  { AIROIDIFC, IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | sizeof (aironet_ioctl),\n    IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, \"airoidifc\" },\n};\n\nstatic const iw_handler\t\tairo_handler[] =\n{\n\t(iw_handler) airo_config_commit,\t/* SIOCSIWCOMMIT */\n\t(iw_handler) airo_get_name,\t\t/* SIOCGIWNAME */\n\t(iw_handler) NULL,\t\t\t/* SIOCSIWNWID */\n\t(iw_handler) NULL,\t\t\t/* SIOCGIWNWID */\n\t(iw_handler) airo_set_freq,\t\t/* SIOCSIWFREQ */\n\t(iw_handler) airo_get_freq,\t\t/* SIOCGIWFREQ */\n\t(iw_handler) airo_set_mode,\t\t/* SIOCSIWMODE */\n\t(iw_handler) airo_get_mode,\t\t/* SIOCGIWMODE */\n\t(iw_handler) airo_set_sens,\t\t/* SIOCSIWSENS */\n\t(iw_handler) airo_get_sens,\t\t/* SIOCGIWSENS */\n\t(iw_handler) NULL,\t\t\t/* SIOCSIWRANGE */\n\t(iw_handler) airo_get_range,\t\t/* SIOCGIWRANGE */\n\t(iw_handler) NULL,\t\t\t/* SIOCSIWPRIV */\n\t(iw_handler) NULL,\t\t\t/* SIOCGIWPRIV */\n\t(iw_handler) NULL,\t\t\t/* SIOCSIWSTATS */\n\t(iw_handler) NULL,\t\t\t/* SIOCGIWSTATS */\n\tiw_handler_set_spy,\t\t\t/* SIOCSIWSPY */\n\tiw_handler_get_spy,\t\t\t/* SIOCGIWSPY */\n\tiw_handler_set_thrspy,\t\t\t/* SIOCSIWTHRSPY */\n\tiw_handler_get_thrspy,\t\t\t/* SIOCGIWTHRSPY */\n\t(iw_handler) airo_set_wap,\t\t/* SIOCSIWAP */\n\t(iw_handler) airo_get_wap,\t\t/* SIOCGIWAP */\n\t(iw_handler) NULL,\t\t\t/* -- hole -- */\n\t(iw_handler) airo_get_aplist,\t\t/* SIOCGIWAPLIST */\n\t(iw_handler) airo_set_scan,\t\t/* SIOCSIWSCAN */\n\t(iw_handler) airo_get_scan,\t\t/* SIOCGIWSCAN */\n\t(iw_handler) airo_set_essid,\t\t/* SIOCSIWESSID */\n\t(iw_handler) airo_get_essid,\t\t/* SIOCGIWESSID */\n\t(iw_handler) airo_set_nick,\t\t/* SIOCSIWNICKN */\n\t(iw_handler) airo_get_nick,\t\t/* SIOCGIWNICKN */\n\t(iw_handler) NULL,\t\t\t/* -- hole -- */\n\t(iw_handler) NULL,\t\t\t/* -- hole -- */\n\t(iw_handler) airo_set_rate,\t\t/* SIOCSIWRATE */\n\t(iw_handler) airo_get_rate,\t\t/* SIOCGIWRATE */\n\t(iw_handler) airo_set_rts,\t\t/* SIOCSIWRTS */\n\t(iw_handler) airo_get_rts,\t\t/* SIOCGIWRTS */\n\t(iw_handler) airo_set_frag,\t\t/* SIOCSIWFRAG */\n\t(iw_handler) airo_get_frag,\t\t/* SIOCGIWFRAG */\n\t(iw_handler) airo_set_txpow,\t\t/* SIOCSIWTXPOW */\n\t(iw_handler) airo_get_txpow,\t\t/* SIOCGIWTXPOW */\n\t(iw_handler) airo_set_retry,\t\t/* SIOCSIWRETRY */\n\t(iw_handler) airo_get_retry,\t\t/* SIOCGIWRETRY */\n\t(iw_handler) airo_set_encode,\t\t/* SIOCSIWENCODE */\n\t(iw_handler) airo_get_encode,\t\t/* SIOCGIWENCODE */\n\t(iw_handler) airo_set_power,\t\t/* SIOCSIWPOWER */\n\t(iw_handler) airo_get_power,\t\t/* SIOCGIWPOWER */\n\t(iw_handler) NULL,\t\t\t/* -- hole -- */\n\t(iw_handler) NULL,\t\t\t/* -- hole -- */\n\t(iw_handler) NULL,\t\t\t/* SIOCSIWGENIE */\n\t(iw_handler) NULL,\t\t\t/* SIOCGIWGENIE */\n\t(iw_handler) airo_set_auth,\t\t/* SIOCSIWAUTH */\n\t(iw_handler) airo_get_auth,\t\t/* SIOCGIWAUTH */\n\t(iw_handler) airo_set_encodeext,\t/* SIOCSIWENCODEEXT */\n\t(iw_handler) airo_get_encodeext,\t/* SIOCGIWENCODEEXT */\n\t(iw_handler) NULL,\t\t\t/* SIOCSIWPMKSA */\n};\n\n/* Note : don't describe AIROIDIFC and AIROOLDIDIFC in here.\n * We want to force the use of the ioctl code, because those can't be\n * won't work the iw_handler code (because they simultaneously read\n * and write data and iw_handler can't do that).\n * Note that it's perfectly legal to read/write on a single ioctl command,\n * you just can't use iwpriv and need to force it via the ioctl handler.\n * Jean II */\nstatic const iw_handler\t\tairo_private_handler[] =\n{\n\tNULL,\t\t\t\t/* SIOCIWFIRSTPRIV */\n};\n\nstatic const struct iw_handler_def\tairo_handler_def =\n{\n\t.num_standard\t= ARRAY_SIZE(airo_handler),\n\t.num_private\t= ARRAY_SIZE(airo_private_handler),\n\t.num_private_args = ARRAY_SIZE(airo_private_args),\n\t.standard\t= airo_handler,\n\t.private\t= airo_private_handler,\n\t.private_args\t= airo_private_args,\n\t.get_wireless_stats = airo_get_wireless_stats,\n};\n\n/*\n * This defines the configuration part of the Wireless Extensions\n * Note : irq and spinlock protection will occur in the subroutines\n *\n * TODO :\n *\to Check input value more carefully and fill correct values in range\n *\to Test and shakeout the bugs (if any)\n *\n * Jean II\n *\n * Javier Achirica did a great job of merging code from the unnamed CISCO\n * developer that added support for flashing the card.\n */\nstatic int airo_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)\n{\n\tint rc = 0;\n\tstruct airo_info *ai = dev->ml_priv;\n\n\tif (ai->power.event)\n\t\treturn 0;\n\n\tswitch (cmd) {\n#ifdef CISCO_EXT\n\tcase AIROIDIFC:\n#ifdef AIROOLDIDIFC\n\tcase AIROOLDIDIFC:\n#endif\n\t{\n\t\tint val = AIROMAGIC;\n\t\taironet_ioctl com;\n\t\tif (copy_from_user(&com,rq->ifr_data,sizeof(com)))\n\t\t\trc = -EFAULT;\n\t\telse if (copy_to_user(com.data,(char *)&val,sizeof(val)))\n\t\t\trc = -EFAULT;\n\t}\n\tbreak;\n\n\tcase AIROIOCTL:\n#ifdef AIROOLDIOCTL\n\tcase AIROOLDIOCTL:\n#endif\n\t\t/* Get the command struct and hand it off for evaluation by\n\t\t * the proper subfunction\n\t\t */\n\t{\n\t\taironet_ioctl com;\n\t\tif (copy_from_user(&com,rq->ifr_data,sizeof(com))) {\n\t\t\trc = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Separate R/W functions bracket legality here\n\t\t */\n\t\tif ( com.command == AIRORSWVERSION ) {\n\t\t\tif (copy_to_user(com.data, swversion, sizeof(swversion)))\n\t\t\t\trc = -EFAULT;\n\t\t\telse\n\t\t\t\trc = 0;\n\t\t}\n\t\telse if ( com.command <= AIRORRID)\n\t\t\trc = readrids(dev,&com);\n\t\telse if ( com.command >= AIROPCAP && com.command <= (AIROPLEAPUSR+2) )\n\t\t\trc = writerids(dev,&com);\n\t\telse if ( com.command >= AIROFLSHRST && com.command <= AIRORESTART )\n\t\t\trc = flashcard(dev,&com);\n\t\telse\n\t\t\trc = -EINVAL;      /* Bad command in ioctl */\n\t}\n\tbreak;\n#endif /* CISCO_EXT */\n\n\t// All other calls are currently unsupported\n\tdefault:\n\t\trc = -EOPNOTSUPP;\n\t}\n\treturn rc;\n}\n\n/*\n * Get the Wireless stats out of the driver\n * Note : irq and spinlock protection will occur in the subroutines\n *\n * TODO :\n *\to Check if work in Ad-Hoc mode (otherwise, use SPY, as in wvlan_cs)\n *\n * Jean\n */\nstatic void airo_read_wireless_stats(struct airo_info *local)\n{\n\tStatusRid status_rid;\n\tStatsRid stats_rid;\n\tCapabilityRid cap_rid;\n\t__le32 *vals = stats_rid.vals;\n\n\t/* Get stats out of the card */\n\tclear_bit(JOB_WSTATS, &local->jobs);\n\tif (local->power.event) {\n\t\tup(&local->sem);\n\t\treturn;\n\t}\n\treadCapabilityRid(local, &cap_rid, 0);\n\treadStatusRid(local, &status_rid, 0);\n\treadStatsRid(local, &stats_rid, RID_STATS, 0);\n\tup(&local->sem);\n\n\t/* The status */\n\tlocal->wstats.status = le16_to_cpu(status_rid.mode);\n\n\t/* Signal quality and co */\n\tif (local->rssi) {\n\t\tlocal->wstats.qual.level =\n\t\t\tairo_rssi_to_dbm(local->rssi,\n\t\t\t\t\t le16_to_cpu(status_rid.sigQuality));\n\t\t/* normalizedSignalStrength appears to be a percentage */\n\t\tlocal->wstats.qual.qual =\n\t\t\tle16_to_cpu(status_rid.normalizedSignalStrength);\n\t} else {\n\t\tlocal->wstats.qual.level =\n\t\t\t(le16_to_cpu(status_rid.normalizedSignalStrength) + 321) / 2;\n\t\tlocal->wstats.qual.qual = airo_get_quality(&status_rid, &cap_rid);\n\t}\n\tif (le16_to_cpu(status_rid.len) >= 124) {\n\t\tlocal->wstats.qual.noise = 0x100 - status_rid.noisedBm;\n\t\tlocal->wstats.qual.updated = IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;\n\t} else {\n\t\tlocal->wstats.qual.noise = 0;\n\t\tlocal->wstats.qual.updated = IW_QUAL_QUAL_UPDATED | IW_QUAL_LEVEL_UPDATED | IW_QUAL_NOISE_INVALID | IW_QUAL_DBM;\n\t}\n\n\t/* Packets discarded in the wireless adapter due to wireless\n\t * specific problems */\n\tlocal->wstats.discard.nwid = le32_to_cpu(vals[56]) +\n\t\t\t\t     le32_to_cpu(vals[57]) +\n\t\t\t\t     le32_to_cpu(vals[58]); /* SSID Mismatch */\n\tlocal->wstats.discard.code = le32_to_cpu(vals[6]);/* RxWepErr */\n\tlocal->wstats.discard.fragment = le32_to_cpu(vals[30]);\n\tlocal->wstats.discard.retries = le32_to_cpu(vals[10]);\n\tlocal->wstats.discard.misc = le32_to_cpu(vals[1]) +\n\t\t\t\t     le32_to_cpu(vals[32]);\n\tlocal->wstats.miss.beacon = le32_to_cpu(vals[34]);\n}\n\nstatic struct iw_statistics *airo_get_wireless_stats(struct net_device *dev)\n{\n\tstruct airo_info *local =  dev->ml_priv;\n\n\tif (!test_bit(JOB_WSTATS, &local->jobs)) {\n\t\t/* Get stats out of the card if available */\n\t\tif (down_trylock(&local->sem) != 0) {\n\t\t\tset_bit(JOB_WSTATS, &local->jobs);\n\t\t\twake_up_interruptible(&local->thr_wait);\n\t\t} else\n\t\t\tairo_read_wireless_stats(local);\n\t}\n\n\treturn &local->wstats;\n}\n\n#ifdef CISCO_EXT\n/*\n * This just translates from driver IOCTL codes to the command codes to\n * feed to the radio's host interface. Things can be added/deleted\n * as needed.  This represents the READ side of control I/O to\n * the card\n */\nstatic int readrids(struct net_device *dev, aironet_ioctl *comp) {\n\tunsigned short ridcode;\n\tunsigned char *iobuf;\n\tint len;\n\tstruct airo_info *ai = dev->ml_priv;\n\n\tif (test_bit(FLAG_FLASHING, &ai->flags))\n\t\treturn -EIO;\n\n\tswitch(comp->command)\n\t{\n\tcase AIROGCAP:      ridcode = RID_CAPABILITIES; break;\n\tcase AIROGCFG:      ridcode = RID_CONFIG;\n\t\tif (test_bit(FLAG_COMMIT, &ai->flags)) {\n\t\t\tdisable_MAC (ai, 1);\n\t\t\twriteConfigRid (ai, 1);\n\t\t\tenable_MAC(ai, 1);\n\t\t}\n\t\tbreak;\n\tcase AIROGSLIST:    ridcode = RID_SSID;         break;\n\tcase AIROGVLIST:    ridcode = RID_APLIST;       break;\n\tcase AIROGDRVNAM:   ridcode = RID_DRVNAME;      break;\n\tcase AIROGEHTENC:   ridcode = RID_ETHERENCAP;   break;\n\tcase AIROGWEPKTMP:  ridcode = RID_WEP_TEMP;\n\t\t/* Only super-user can read WEP keys */\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tbreak;\n\tcase AIROGWEPKNV:   ridcode = RID_WEP_PERM;\n\t\t/* Only super-user can read WEP keys */\n\t\tif (!capable(CAP_NET_ADMIN))\n\t\t\treturn -EPERM;\n\t\tbreak;\n\tcase AIROGSTAT:     ridcode = RID_STATUS;       break;\n\tcase AIROGSTATSD32: ridcode = RID_STATSDELTA;   break;\n\tcase AIROGSTATSC32: ridcode = RID_STATS;        break;\n\tcase AIROGMICSTATS:\n\t\tif (copy_to_user(comp->data, &ai->micstats,\n\t\t\t\t min((int)comp->len,(int)sizeof(ai->micstats))))\n\t\t\treturn -EFAULT;\n\t\treturn 0;\n\tcase AIRORRID:      ridcode = comp->ridnum;     break;\n\tdefault:\n\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\tif ((iobuf = kmalloc(RIDSIZE, GFP_KERNEL)) == NULL)\n\t\treturn -ENOMEM;\n\n\tPC4500_readrid(ai,ridcode,iobuf,RIDSIZE, 1);\n\t/* get the count of bytes in the rid  docs say 1st 2 bytes is it.\n\t * then return it to the user\n\t * 9/22/2000 Honor user given length\n\t */\n\tlen = comp->len;\n\n\tif (copy_to_user(comp->data, iobuf, min(len, (int)RIDSIZE))) {\n\t\tkfree (iobuf);\n\t\treturn -EFAULT;\n\t}\n\tkfree (iobuf);\n\treturn 0;\n}\n\n/*\n * Danger Will Robinson write the rids here\n */\n\nstatic int writerids(struct net_device *dev, aironet_ioctl *comp) {\n\tstruct airo_info *ai = dev->ml_priv;\n\tint  ridcode;\n        int  enabled;\n\tstatic int (* writer)(struct airo_info *, u16 rid, const void *, int, int);\n\tunsigned char *iobuf;\n\n\t/* Only super-user can write RIDs */\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (test_bit(FLAG_FLASHING, &ai->flags))\n\t\treturn -EIO;\n\n\tridcode = 0;\n\twriter = do_writerid;\n\n\tswitch(comp->command)\n\t{\n\tcase AIROPSIDS:     ridcode = RID_SSID;         break;\n\tcase AIROPCAP:      ridcode = RID_CAPABILITIES; break;\n\tcase AIROPAPLIST:   ridcode = RID_APLIST;       break;\n\tcase AIROPCFG: ai->config.len = 0;\n\t\t\t    clear_bit(FLAG_COMMIT, &ai->flags);\n\t\t\t    ridcode = RID_CONFIG;       break;\n\tcase AIROPWEPKEYNV: ridcode = RID_WEP_PERM;     break;\n\tcase AIROPLEAPUSR:  ridcode = RID_LEAPUSERNAME; break;\n\tcase AIROPLEAPPWD:  ridcode = RID_LEAPPASSWORD; break;\n\tcase AIROPWEPKEY:   ridcode = RID_WEP_TEMP; writer = PC4500_writerid;\n\t\tbreak;\n\tcase AIROPLEAPUSR+1: ridcode = 0xFF2A;          break;\n\tcase AIROPLEAPUSR+2: ridcode = 0xFF2B;          break;\n\n\t\t/* this is not really a rid but a command given to the card\n\t\t * same with MAC off\n\t\t */\n\tcase AIROPMACON:\n\t\tif (enable_MAC(ai, 1) != 0)\n\t\t\treturn -EIO;\n\t\treturn 0;\n\n\t\t/*\n\t\t * Evidently this code in the airo driver does not get a symbol\n\t\t * as disable_MAC. it's probably so short the compiler does not gen one.\n\t\t */\n\tcase AIROPMACOFF:\n\t\tdisable_MAC(ai, 1);\n\t\treturn 0;\n\n\t\t/* This command merely clears the counts does not actually store any data\n\t\t * only reads rid. But as it changes the cards state, I put it in the\n\t\t * writerid routines.\n\t\t */\n\tcase AIROPSTCLR:\n\t\tif ((iobuf = kmalloc(RIDSIZE, GFP_KERNEL)) == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tPC4500_readrid(ai,RID_STATSDELTACLEAR,iobuf,RIDSIZE, 1);\n\n\t\tenabled = ai->micstats.enabled;\n\t\tmemset(&ai->micstats,0,sizeof(ai->micstats));\n\t\tai->micstats.enabled = enabled;\n\n\t\tif (copy_to_user(comp->data, iobuf,\n\t\t\t\t min((int)comp->len, (int)RIDSIZE))) {\n\t\t\tkfree (iobuf);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tkfree (iobuf);\n\t\treturn 0;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\t/* Blarg! */\n\t}\n\tif(comp->len > RIDSIZE)\n\t\treturn -EINVAL;\n\n\tif ((iobuf = kmalloc(RIDSIZE, GFP_KERNEL)) == NULL)\n\t\treturn -ENOMEM;\n\n\tif (copy_from_user(iobuf,comp->data,comp->len)) {\n\t\tkfree (iobuf);\n\t\treturn -EFAULT;\n\t}\n\n\tif (comp->command == AIROPCFG) {\n\t\tConfigRid *cfg = (ConfigRid *)iobuf;\n\n\t\tif (test_bit(FLAG_MIC_CAPABLE, &ai->flags))\n\t\t\tcfg->opmode |= MODE_MIC;\n\n\t\tif ((cfg->opmode & MODE_CFG_MASK) == MODE_STA_IBSS)\n\t\t\tset_bit (FLAG_ADHOC, &ai->flags);\n\t\telse\n\t\t\tclear_bit (FLAG_ADHOC, &ai->flags);\n\t}\n\n\tif((*writer)(ai, ridcode, iobuf,comp->len,1)) {\n\t\tkfree (iobuf);\n\t\treturn -EIO;\n\t}\n\tkfree (iobuf);\n\treturn 0;\n}\n\n/*****************************************************************************\n * Ancillary flash / mod functions much black magic lurkes here              *\n *****************************************************************************\n */\n\n/*\n * Flash command switch table\n */\n\nstatic int flashcard(struct net_device *dev, aironet_ioctl *comp) {\n\tint z;\n\n\t/* Only super-user can modify flash */\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tswitch(comp->command)\n\t{\n\tcase AIROFLSHRST:\n\t\treturn cmdreset((struct airo_info *)dev->ml_priv);\n\n\tcase AIROFLSHSTFL:\n\t\tif (!AIRO_FLASH(dev) &&\n\t\t    (AIRO_FLASH(dev) = kmalloc(FLASHSIZE, GFP_KERNEL)) == NULL)\n\t\t\treturn -ENOMEM;\n\t\treturn setflashmode((struct airo_info *)dev->ml_priv);\n\n\tcase AIROFLSHGCHR: /* Get char from aux */\n\t\tif(comp->len != sizeof(int))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&z,comp->data,comp->len))\n\t\t\treturn -EFAULT;\n\t\treturn flashgchar((struct airo_info *)dev->ml_priv, z, 8000);\n\n\tcase AIROFLSHPCHR: /* Send char to card. */\n\t\tif(comp->len != sizeof(int))\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(&z,comp->data,comp->len))\n\t\t\treturn -EFAULT;\n\t\treturn flashpchar((struct airo_info *)dev->ml_priv, z, 8000);\n\n\tcase AIROFLPUTBUF: /* Send 32k to card */\n\t\tif (!AIRO_FLASH(dev))\n\t\t\treturn -ENOMEM;\n\t\tif(comp->len > FLASHSIZE)\n\t\t\treturn -EINVAL;\n\t\tif (copy_from_user(AIRO_FLASH(dev), comp->data, comp->len))\n\t\t\treturn -EFAULT;\n\n\t\tflashputbuf((struct airo_info *)dev->ml_priv);\n\t\treturn 0;\n\n\tcase AIRORESTART:\n\t\tif (flashrestart((struct airo_info *)dev->ml_priv, dev))\n\t\t\treturn -EIO;\n\t\treturn 0;\n\t}\n\treturn -EINVAL;\n}\n\n#define FLASH_COMMAND  0x7e7e\n\n/*\n * STEP 1)\n * Disable MAC and do soft reset on\n * card.\n */\n\nstatic int cmdreset(struct airo_info *ai) {\n\tdisable_MAC(ai, 1);\n\n\tif(!waitbusy (ai)){\n\t\tairo_print_info(ai->dev->name, \"Waitbusy hang before RESET\");\n\t\treturn -EBUSY;\n\t}\n\n\tOUT4500(ai,COMMAND,CMD_SOFTRESET);\n\n\tssleep(1);\t\t\t/* WAS 600 12/7/00 */\n\n\tif(!waitbusy (ai)){\n\t\tairo_print_info(ai->dev->name, \"Waitbusy hang AFTER RESET\");\n\t\treturn -EBUSY;\n\t}\n\treturn 0;\n}\n\n/* STEP 2)\n * Put the card in legendary flash\n * mode\n */\n\nstatic int setflashmode (struct airo_info *ai) {\n\tset_bit (FLAG_FLASHING, &ai->flags);\n\n\tOUT4500(ai, SWS0, FLASH_COMMAND);\n\tOUT4500(ai, SWS1, FLASH_COMMAND);\n\tif (probe) {\n\t\tOUT4500(ai, SWS0, FLASH_COMMAND);\n\t\tOUT4500(ai, COMMAND,0x10);\n\t} else {\n\t\tOUT4500(ai, SWS2, FLASH_COMMAND);\n\t\tOUT4500(ai, SWS3, FLASH_COMMAND);\n\t\tOUT4500(ai, COMMAND,0);\n\t}\n\tmsleep(500);\t\t/* 500ms delay */\n\n\tif(!waitbusy(ai)) {\n\t\tclear_bit (FLAG_FLASHING, &ai->flags);\n\t\tairo_print_info(ai->dev->name, \"Waitbusy hang after setflash mode\");\n\t\treturn -EIO;\n\t}\n\treturn 0;\n}\n\n/* Put character to SWS0 wait for dwelltime\n * x 50us for  echo .\n */\n\nstatic int flashpchar(struct airo_info *ai,int byte,int dwelltime) {\n\tint echo;\n\tint waittime;\n\n\tbyte |= 0x8000;\n\n\tif(dwelltime == 0 )\n\t\tdwelltime = 200;\n\n\twaittime=dwelltime;\n\n\t/* Wait for busy bit d15 to go false indicating buffer empty */\n\twhile ((IN4500 (ai, SWS0) & 0x8000) && waittime > 0) {\n\t\tudelay (50);\n\t\twaittime -= 50;\n\t}\n\n\t/* timeout for busy clear wait */\n\tif(waittime <= 0 ){\n\t\tairo_print_info(ai->dev->name, \"flash putchar busywait timeout!\");\n\t\treturn -EBUSY;\n\t}\n\n\t/* Port is clear now write byte and wait for it to echo back */\n\tdo {\n\t\tOUT4500(ai,SWS0,byte);\n\t\tudelay(50);\n\t\tdwelltime -= 50;\n\t\techo = IN4500(ai,SWS1);\n\t} while (dwelltime >= 0 && echo != byte);\n\n\tOUT4500(ai,SWS1,0);\n\n\treturn (echo == byte) ? 0 : -EIO;\n}\n\n/*\n * Get a character from the card matching matchbyte\n * Step 3)\n */\nstatic int flashgchar(struct airo_info *ai,int matchbyte,int dwelltime){\n\tint           rchar;\n\tunsigned char rbyte=0;\n\n\tdo {\n\t\trchar = IN4500(ai,SWS1);\n\n\t\tif(dwelltime && !(0x8000 & rchar)){\n\t\t\tdwelltime -= 10;\n\t\t\tmdelay(10);\n\t\t\tcontinue;\n\t\t}\n\t\trbyte = 0xff & rchar;\n\n\t\tif( (rbyte == matchbyte) && (0x8000 & rchar) ){\n\t\t\tOUT4500(ai,SWS1,0);\n\t\t\treturn 0;\n\t\t}\n\t\tif( rbyte == 0x81 || rbyte == 0x82 || rbyte == 0x83 || rbyte == 0x1a || 0xffff == rchar)\n\t\t\tbreak;\n\t\tOUT4500(ai,SWS1,0);\n\n\t}while(dwelltime > 0);\n\treturn -EIO;\n}\n\n/*\n * Transfer 32k of firmware data from user buffer to our buffer and\n * send to the card\n */\n\nstatic int flashputbuf(struct airo_info *ai){\n\tint            nwords;\n\n\t/* Write stuff */\n\tif (test_bit(FLAG_MPI,&ai->flags))\n\t\tmemcpy_toio(ai->pciaux + 0x8000, ai->flash, FLASHSIZE);\n\telse {\n\t\tOUT4500(ai,AUXPAGE,0x100);\n\t\tOUT4500(ai,AUXOFF,0);\n\n\t\tfor(nwords=0;nwords != FLASHSIZE / 2;nwords++){\n\t\t\tOUT4500(ai,AUXDATA,ai->flash[nwords] & 0xffff);\n\t\t}\n\t}\n\tOUT4500(ai,SWS0,0x8000);\n\n\treturn 0;\n}\n\n/*\n *\n */\nstatic int flashrestart(struct airo_info *ai,struct net_device *dev){\n\tint    i,status;\n\n\tssleep(1);\t\t\t/* Added 12/7/00 */\n\tclear_bit (FLAG_FLASHING, &ai->flags);\n\tif (test_bit(FLAG_MPI, &ai->flags)) {\n\t\tstatus = mpi_init_descriptors(ai);\n\t\tif (status != SUCCESS)\n\t\t\treturn status;\n\t}\n\tstatus = setup_card(ai, dev->dev_addr, 1);\n\n\tif (!test_bit(FLAG_MPI,&ai->flags))\n\t\tfor( i = 0; i < MAX_FIDS; i++ ) {\n\t\t\tai->fids[i] = transmit_allocate\n\t\t\t\t( ai, AIRO_DEF_MTU, i >= MAX_FIDS / 2 );\n\t\t}\n\n\tssleep(1);\t\t\t/* Added 12/7/00 */\n\treturn status;\n}\n#endif /* CISCO_EXT */\n\n/*\n    This program is free software; you can redistribute it and/or\n    modify it under the terms of the GNU General Public License\n    as published by the Free Software Foundation; either version 2\n    of the License, or (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    In addition:\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n    1. Redistributions of source code must retain the above copyright\n       notice, this list of conditions and the following disclaimer.\n    2. Redistributions in binary form must reproduce the above copyright\n       notice, this list of conditions and the following disclaimer in the\n       documentation and/or other materials provided with the distribution.\n    3. The name of the author may not be used to endorse or promote\n       products derived from this software without specific prior written\n       permission.\n\n    THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n    ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n    POSSIBILITY OF SUCH DAMAGE.\n*/\n\nmodule_init(airo_init_module);\nmodule_exit(airo_cleanup_module);\n", "/*\n * Host AP (software wireless LAN access point) driver for\n * Intersil Prism2/2.5/3 - hostap.o module, common routines\n *\n * Copyright (c) 2001-2002, SSH Communications Security Corp and Jouni Malinen\n * <j@w1.fi>\n * Copyright (c) 2002-2005, Jouni Malinen <j@w1.fi>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation. See README and COPYING for\n * more details.\n */\n\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/proc_fs.h>\n#include <linux/if_arp.h>\n#include <linux/delay.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/kmod.h>\n#include <linux/rtnetlink.h>\n#include <linux/wireless.h>\n#include <linux/etherdevice.h>\n#include <net/net_namespace.h>\n#include <net/iw_handler.h>\n#include <net/lib80211.h>\n#include <asm/uaccess.h>\n\n#include \"hostap_wlan.h\"\n#include \"hostap_80211.h\"\n#include \"hostap_ap.h\"\n#include \"hostap.h\"\n\nMODULE_AUTHOR(\"Jouni Malinen\");\nMODULE_DESCRIPTION(\"Host AP common routines\");\nMODULE_LICENSE(\"GPL\");\n\n#define TX_TIMEOUT (2 * HZ)\n\n#define PRISM2_MAX_FRAME_SIZE 2304\n#define PRISM2_MIN_MTU 256\n/* FIX: */\n#define PRISM2_MAX_MTU (PRISM2_MAX_FRAME_SIZE - (6 /* LLC */ + 8 /* WEP */))\n\n\nstruct net_device * hostap_add_interface(struct local_info *local,\n\t\t\t\t\t int type, int rtnl_locked,\n\t\t\t\t\t const char *prefix,\n\t\t\t\t\t const char *name)\n{\n\tstruct net_device *dev, *mdev;\n\tstruct hostap_interface *iface;\n\tint ret;\n\n\tdev = alloc_etherdev(sizeof(struct hostap_interface));\n\tif (dev == NULL)\n\t\treturn NULL;\n\n\tiface = netdev_priv(dev);\n\tiface->dev = dev;\n\tiface->local = local;\n\tiface->type = type;\n\tlist_add(&iface->list, &local->hostap_interfaces);\n\n\tmdev = local->dev;\n\tmemcpy(dev->dev_addr, mdev->dev_addr, ETH_ALEN);\n\tdev->base_addr = mdev->base_addr;\n\tdev->irq = mdev->irq;\n\tdev->mem_start = mdev->mem_start;\n\tdev->mem_end = mdev->mem_end;\n\n\thostap_setup_dev(dev, local, type);\n\tdev->destructor = free_netdev;\n\n\tsprintf(dev->name, \"%s%s\", prefix, name);\n\tif (!rtnl_locked)\n\t\trtnl_lock();\n\n\tSET_NETDEV_DEV(dev, mdev->dev.parent);\n\tret = register_netdevice(dev);\n\n\tif (!rtnl_locked)\n\t\trtnl_unlock();\n\n\tif (ret < 0) {\n\t\tprintk(KERN_WARNING \"%s: failed to add new netdevice!\\n\",\n\t\t       dev->name);\n\t\tfree_netdev(dev);\n\t\treturn NULL;\n\t}\n\n\tprintk(KERN_DEBUG \"%s: registered netdevice %s\\n\",\n\t       mdev->name, dev->name);\n\n\treturn dev;\n}\n\n\nvoid hostap_remove_interface(struct net_device *dev, int rtnl_locked,\n\t\t\t     int remove_from_list)\n{\n\tstruct hostap_interface *iface;\n\n\tif (!dev)\n\t\treturn;\n\n\tiface = netdev_priv(dev);\n\n\tif (remove_from_list) {\n\t\tlist_del(&iface->list);\n\t}\n\n\tif (dev == iface->local->ddev)\n\t\tiface->local->ddev = NULL;\n\telse if (dev == iface->local->apdev)\n\t\tiface->local->apdev = NULL;\n\telse if (dev == iface->local->stadev)\n\t\tiface->local->stadev = NULL;\n\n\tif (rtnl_locked)\n\t\tunregister_netdevice(dev);\n\telse\n\t\tunregister_netdev(dev);\n\n\t/* dev->destructor = free_netdev() will free the device data, including\n\t * private data, when removing the device */\n}\n\n\nstatic inline int prism2_wds_special_addr(u8 *addr)\n{\n\tif (addr[0] || addr[1] || addr[2] || addr[3] || addr[4] || addr[5])\n\t\treturn 0;\n\n\treturn 1;\n}\n\n\nint prism2_wds_add(local_info_t *local, u8 *remote_addr,\n\t\t   int rtnl_locked)\n{\n\tstruct net_device *dev;\n\tstruct list_head *ptr;\n\tstruct hostap_interface *iface, *empty, *match;\n\n\tempty = match = NULL;\n\tread_lock_bh(&local->iface_lock);\n\tlist_for_each(ptr, &local->hostap_interfaces) {\n\t\tiface = list_entry(ptr, struct hostap_interface, list);\n\t\tif (iface->type != HOSTAP_INTERFACE_WDS)\n\t\t\tcontinue;\n\n\t\tif (prism2_wds_special_addr(iface->u.wds.remote_addr))\n\t\t\tempty = iface;\n\t\telse if (memcmp(iface->u.wds.remote_addr, remote_addr,\n\t\t\t\tETH_ALEN) == 0) {\n\t\t\tmatch = iface;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!match && empty && !prism2_wds_special_addr(remote_addr)) {\n\t\t/* take pre-allocated entry into use */\n\t\tmemcpy(empty->u.wds.remote_addr, remote_addr, ETH_ALEN);\n\t\tread_unlock_bh(&local->iface_lock);\n\t\tprintk(KERN_DEBUG \"%s: using pre-allocated WDS netdevice %s\\n\",\n\t\t       local->dev->name, empty->dev->name);\n\t\treturn 0;\n\t}\n\tread_unlock_bh(&local->iface_lock);\n\n\tif (!prism2_wds_special_addr(remote_addr)) {\n\t\tif (match)\n\t\t\treturn -EEXIST;\n\t\thostap_add_sta(local->ap, remote_addr);\n\t}\n\n\tif (local->wds_connections >= local->wds_max_connections)\n\t\treturn -ENOBUFS;\n\n\t/* verify that there is room for wds# postfix in the interface name */\n\tif (strlen(local->dev->name) >= IFNAMSIZ - 5) {\n\t\tprintk(KERN_DEBUG \"'%s' too long base device name\\n\",\n\t\t       local->dev->name);\n\t\treturn -EINVAL;\n\t}\n\n\tdev = hostap_add_interface(local, HOSTAP_INTERFACE_WDS, rtnl_locked,\n\t\t\t\t   local->ddev->name, \"wds%d\");\n\tif (dev == NULL)\n\t\treturn -ENOMEM;\n\n\tiface = netdev_priv(dev);\n\tmemcpy(iface->u.wds.remote_addr, remote_addr, ETH_ALEN);\n\n\tlocal->wds_connections++;\n\n\treturn 0;\n}\n\n\nint prism2_wds_del(local_info_t *local, u8 *remote_addr,\n\t\t   int rtnl_locked, int do_not_remove)\n{\n\tunsigned long flags;\n\tstruct list_head *ptr;\n\tstruct hostap_interface *iface, *selected = NULL;\n\n\twrite_lock_irqsave(&local->iface_lock, flags);\n\tlist_for_each(ptr, &local->hostap_interfaces) {\n\t\tiface = list_entry(ptr, struct hostap_interface, list);\n\t\tif (iface->type != HOSTAP_INTERFACE_WDS)\n\t\t\tcontinue;\n\n\t\tif (memcmp(iface->u.wds.remote_addr, remote_addr,\n\t\t\t   ETH_ALEN) == 0) {\n\t\t\tselected = iface;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (selected && !do_not_remove)\n\t\tlist_del(&selected->list);\n\twrite_unlock_irqrestore(&local->iface_lock, flags);\n\n\tif (selected) {\n\t\tif (do_not_remove)\n\t\t\tmemset(selected->u.wds.remote_addr, 0, ETH_ALEN);\n\t\telse {\n\t\t\thostap_remove_interface(selected->dev, rtnl_locked, 0);\n\t\t\tlocal->wds_connections--;\n\t\t}\n\t}\n\n\treturn selected ? 0 : -ENODEV;\n}\n\n\nu16 hostap_tx_callback_register(local_info_t *local,\n\t\t\t\tvoid (*func)(struct sk_buff *, int ok, void *),\n\t\t\t\tvoid *data)\n{\n\tunsigned long flags;\n\tstruct hostap_tx_callback_info *entry;\n\n\tentry = kmalloc(sizeof(*entry),\n\t\t\t\t\t\t\t   GFP_ATOMIC);\n\tif (entry == NULL)\n\t\treturn 0;\n\n\tentry->func = func;\n\tentry->data = data;\n\n\tspin_lock_irqsave(&local->lock, flags);\n\tentry->idx = local->tx_callback ? local->tx_callback->idx + 1 : 1;\n\tentry->next = local->tx_callback;\n\tlocal->tx_callback = entry;\n\tspin_unlock_irqrestore(&local->lock, flags);\n\n\treturn entry->idx;\n}\n\n\nint hostap_tx_callback_unregister(local_info_t *local, u16 idx)\n{\n\tunsigned long flags;\n\tstruct hostap_tx_callback_info *cb, *prev = NULL;\n\n\tspin_lock_irqsave(&local->lock, flags);\n\tcb = local->tx_callback;\n\twhile (cb != NULL && cb->idx != idx) {\n\t\tprev = cb;\n\t\tcb = cb->next;\n\t}\n\tif (cb) {\n\t\tif (prev == NULL)\n\t\t\tlocal->tx_callback = cb->next;\n\t\telse\n\t\t\tprev->next = cb->next;\n\t\tkfree(cb);\n\t}\n\tspin_unlock_irqrestore(&local->lock, flags);\n\n\treturn cb ? 0 : -1;\n}\n\n\n/* val is in host byte order */\nint hostap_set_word(struct net_device *dev, int rid, u16 val)\n{\n\tstruct hostap_interface *iface;\n\t__le16 tmp = cpu_to_le16(val);\n\tiface = netdev_priv(dev);\n\treturn iface->local->func->set_rid(dev, rid, &tmp, 2);\n}\n\n\nint hostap_set_string(struct net_device *dev, int rid, const char *val)\n{\n\tstruct hostap_interface *iface;\n\tchar buf[MAX_SSID_LEN + 2];\n\tint len;\n\n\tiface = netdev_priv(dev);\n\tlen = strlen(val);\n\tif (len > MAX_SSID_LEN)\n\t\treturn -1;\n\tmemset(buf, 0, sizeof(buf));\n\tbuf[0] = len; /* little endian 16 bit word */\n\tmemcpy(buf + 2, val, len);\n\n\treturn iface->local->func->set_rid(dev, rid, &buf, MAX_SSID_LEN + 2);\n}\n\n\nu16 hostap_get_porttype(local_info_t *local)\n{\n\tif (local->iw_mode == IW_MODE_ADHOC && local->pseudo_adhoc)\n\t\treturn HFA384X_PORTTYPE_PSEUDO_IBSS;\n\tif (local->iw_mode == IW_MODE_ADHOC)\n\t\treturn HFA384X_PORTTYPE_IBSS;\n\tif (local->iw_mode == IW_MODE_INFRA)\n\t\treturn HFA384X_PORTTYPE_BSS;\n\tif (local->iw_mode == IW_MODE_REPEAT)\n\t\treturn HFA384X_PORTTYPE_WDS;\n\tif (local->iw_mode == IW_MODE_MONITOR)\n\t\treturn HFA384X_PORTTYPE_PSEUDO_IBSS;\n\treturn HFA384X_PORTTYPE_HOSTAP;\n}\n\n\nint hostap_set_encryption(local_info_t *local)\n{\n\tu16 val, old_val;\n\tint i, keylen, len, idx;\n\tchar keybuf[WEP_KEY_LEN + 1];\n\tenum { NONE, WEP, OTHER } encrypt_type;\n\n\tidx = local->crypt_info.tx_keyidx;\n\tif (local->crypt_info.crypt[idx] == NULL ||\n\t    local->crypt_info.crypt[idx]->ops == NULL)\n\t\tencrypt_type = NONE;\n\telse if (strcmp(local->crypt_info.crypt[idx]->ops->name, \"WEP\") == 0)\n\t\tencrypt_type = WEP;\n\telse\n\t\tencrypt_type = OTHER;\n\n\tif (local->func->get_rid(local->dev, HFA384X_RID_CNFWEPFLAGS, &val, 2,\n\t\t\t\t 1) < 0) {\n\t\tprintk(KERN_DEBUG \"Could not read current WEP flags.\\n\");\n\t\tgoto fail;\n\t}\n\tle16_to_cpus(&val);\n\told_val = val;\n\n\tif (encrypt_type != NONE || local->privacy_invoked)\n\t\tval |= HFA384X_WEPFLAGS_PRIVACYINVOKED;\n\telse\n\t\tval &= ~HFA384X_WEPFLAGS_PRIVACYINVOKED;\n\n\tif (local->open_wep || encrypt_type == NONE ||\n\t    ((local->ieee_802_1x || local->wpa) && local->host_decrypt))\n\t\tval &= ~HFA384X_WEPFLAGS_EXCLUDEUNENCRYPTED;\n\telse\n\t\tval |= HFA384X_WEPFLAGS_EXCLUDEUNENCRYPTED;\n\n\tif ((encrypt_type != NONE || local->privacy_invoked) &&\n\t    (encrypt_type == OTHER || local->host_encrypt))\n\t\tval |= HFA384X_WEPFLAGS_HOSTENCRYPT;\n\telse\n\t\tval &= ~HFA384X_WEPFLAGS_HOSTENCRYPT;\n\tif ((encrypt_type != NONE || local->privacy_invoked) &&\n\t    (encrypt_type == OTHER || local->host_decrypt))\n\t\tval |= HFA384X_WEPFLAGS_HOSTDECRYPT;\n\telse\n\t\tval &= ~HFA384X_WEPFLAGS_HOSTDECRYPT;\n\n\tif (val != old_val &&\n\t    hostap_set_word(local->dev, HFA384X_RID_CNFWEPFLAGS, val)) {\n\t\tprintk(KERN_DEBUG \"Could not write new WEP flags (0x%x)\\n\",\n\t\t       val);\n\t\tgoto fail;\n\t}\n\n\tif (encrypt_type != WEP)\n\t\treturn 0;\n\n\t/* 104-bit support seems to require that all the keys are set to the\n\t * same keylen */\n\tkeylen = 6; /* first 5 octets */\n\tlen = local->crypt_info.crypt[idx]->ops->get_key(keybuf, sizeof(keybuf), NULL,\n\t\t\t\t\t\t\t   local->crypt_info.crypt[idx]->priv);\n\tif (idx >= 0 && idx < WEP_KEYS && len > 5)\n\t\tkeylen = WEP_KEY_LEN + 1; /* first 13 octets */\n\n\tfor (i = 0; i < WEP_KEYS; i++) {\n\t\tmemset(keybuf, 0, sizeof(keybuf));\n\t\tif (local->crypt_info.crypt[i]) {\n\t\t\t(void) local->crypt_info.crypt[i]->ops->get_key(\n\t\t\t\tkeybuf, sizeof(keybuf),\n\t\t\t\tNULL, local->crypt_info.crypt[i]->priv);\n\t\t}\n\t\tif (local->func->set_rid(local->dev,\n\t\t\t\t\t HFA384X_RID_CNFDEFAULTKEY0 + i,\n\t\t\t\t\t keybuf, keylen)) {\n\t\t\tprintk(KERN_DEBUG \"Could not set key %d (len=%d)\\n\",\n\t\t\t       i, keylen);\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (hostap_set_word(local->dev, HFA384X_RID_CNFWEPDEFAULTKEYID, idx)) {\n\t\tprintk(KERN_DEBUG \"Could not set default keyid %d\\n\", idx);\n\t\tgoto fail;\n\t}\n\n\treturn 0;\n\n fail:\n\tprintk(KERN_DEBUG \"%s: encryption setup failed\\n\", local->dev->name);\n\treturn -1;\n}\n\n\nint hostap_set_antsel(local_info_t *local)\n{\n\tu16 val;\n\tint ret = 0;\n\n\tif (local->antsel_tx != HOSTAP_ANTSEL_DO_NOT_TOUCH &&\n\t    local->func->cmd(local->dev, HFA384X_CMDCODE_READMIF,\n\t\t\t     HFA386X_CR_TX_CONFIGURE,\n\t\t\t     NULL, &val) == 0) {\n\t\tval &= ~(BIT(2) | BIT(1));\n\t\tswitch (local->antsel_tx) {\n\t\tcase HOSTAP_ANTSEL_DIVERSITY:\n\t\t\tval |= BIT(1);\n\t\t\tbreak;\n\t\tcase HOSTAP_ANTSEL_LOW:\n\t\t\tbreak;\n\t\tcase HOSTAP_ANTSEL_HIGH:\n\t\t\tval |= BIT(2);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (local->func->cmd(local->dev, HFA384X_CMDCODE_WRITEMIF,\n\t\t\t\t     HFA386X_CR_TX_CONFIGURE, &val, NULL)) {\n\t\t\tprintk(KERN_INFO \"%s: setting TX AntSel failed\\n\",\n\t\t\t       local->dev->name);\n\t\t\tret = -1;\n\t\t}\n\t}\n\n\tif (local->antsel_rx != HOSTAP_ANTSEL_DO_NOT_TOUCH &&\n\t    local->func->cmd(local->dev, HFA384X_CMDCODE_READMIF,\n\t\t\t     HFA386X_CR_RX_CONFIGURE,\n\t\t\t     NULL, &val) == 0) {\n\t\tval &= ~(BIT(1) | BIT(0));\n\t\tswitch (local->antsel_rx) {\n\t\tcase HOSTAP_ANTSEL_DIVERSITY:\n\t\t\tbreak;\n\t\tcase HOSTAP_ANTSEL_LOW:\n\t\t\tval |= BIT(0);\n\t\t\tbreak;\n\t\tcase HOSTAP_ANTSEL_HIGH:\n\t\t\tval |= BIT(0) | BIT(1);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (local->func->cmd(local->dev, HFA384X_CMDCODE_WRITEMIF,\n\t\t\t\t     HFA386X_CR_RX_CONFIGURE, &val, NULL)) {\n\t\t\tprintk(KERN_INFO \"%s: setting RX AntSel failed\\n\",\n\t\t\t       local->dev->name);\n\t\t\tret = -1;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n\nint hostap_set_roaming(local_info_t *local)\n{\n\tu16 val;\n\n\tswitch (local->host_roaming) {\n\tcase 1:\n\t\tval = HFA384X_ROAMING_HOST;\n\t\tbreak;\n\tcase 2:\n\t\tval = HFA384X_ROAMING_DISABLED;\n\t\tbreak;\n\tcase 0:\n\tdefault:\n\t\tval = HFA384X_ROAMING_FIRMWARE;\n\t\tbreak;\n\t}\n\n\treturn hostap_set_word(local->dev, HFA384X_RID_CNFROAMINGMODE, val);\n}\n\n\nint hostap_set_auth_algs(local_info_t *local)\n{\n\tint val = local->auth_algs;\n\t/* At least STA f/w v0.6.2 seems to have issues with cnfAuthentication\n\t * set to include both Open and Shared Key flags. It tries to use\n\t * Shared Key authentication in that case even if WEP keys are not\n\t * configured.. STA f/w v0.7.6 is able to handle such configuration,\n\t * but it is unknown when this was fixed between 0.6.2 .. 0.7.6. */\n\tif (local->sta_fw_ver < PRISM2_FW_VER(0,7,0) &&\n\t    val != PRISM2_AUTH_OPEN && val != PRISM2_AUTH_SHARED_KEY)\n\t\tval = PRISM2_AUTH_OPEN;\n\n\tif (hostap_set_word(local->dev, HFA384X_RID_CNFAUTHENTICATION, val)) {\n\t\tprintk(KERN_INFO \"%s: cnfAuthentication setting to 0x%x \"\n\t\t       \"failed\\n\", local->dev->name, local->auth_algs);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\n\nvoid hostap_dump_rx_header(const char *name, const struct hfa384x_rx_frame *rx)\n{\n\tu16 status, fc;\n\n\tstatus = __le16_to_cpu(rx->status);\n\n\tprintk(KERN_DEBUG \"%s: RX status=0x%04x (port=%d, type=%d, \"\n\t       \"fcserr=%d) silence=%d signal=%d rate=%d rxflow=%d; \"\n\t       \"jiffies=%ld\\n\",\n\t       name, status, (status >> 8) & 0x07, status >> 13, status & 1,\n\t       rx->silence, rx->signal, rx->rate, rx->rxflow, jiffies);\n\n\tfc = __le16_to_cpu(rx->frame_control);\n\tprintk(KERN_DEBUG \"   FC=0x%04x (type=%d:%d) dur=0x%04x seq=0x%04x \"\n\t       \"data_len=%d%s%s\\n\",\n\t       fc, (fc & IEEE80211_FCTL_FTYPE) >> 2,\n\t       (fc & IEEE80211_FCTL_STYPE) >> 4,\n\t       __le16_to_cpu(rx->duration_id), __le16_to_cpu(rx->seq_ctrl),\n\t       __le16_to_cpu(rx->data_len),\n\t       fc & IEEE80211_FCTL_TODS ? \" [ToDS]\" : \"\",\n\t       fc & IEEE80211_FCTL_FROMDS ? \" [FromDS]\" : \"\");\n\n\tprintk(KERN_DEBUG \"   A1=%pM A2=%pM A3=%pM A4=%pM\\n\",\n\t       rx->addr1, rx->addr2, rx->addr3, rx->addr4);\n\n\tprintk(KERN_DEBUG \"   dst=%pM src=%pM len=%d\\n\",\n\t       rx->dst_addr, rx->src_addr,\n\t       __be16_to_cpu(rx->len));\n}\n\n\nvoid hostap_dump_tx_header(const char *name, const struct hfa384x_tx_frame *tx)\n{\n\tu16 fc;\n\n\tprintk(KERN_DEBUG \"%s: TX status=0x%04x retry_count=%d tx_rate=%d \"\n\t       \"tx_control=0x%04x; jiffies=%ld\\n\",\n\t       name, __le16_to_cpu(tx->status), tx->retry_count, tx->tx_rate,\n\t       __le16_to_cpu(tx->tx_control), jiffies);\n\n\tfc = __le16_to_cpu(tx->frame_control);\n\tprintk(KERN_DEBUG \"   FC=0x%04x (type=%d:%d) dur=0x%04x seq=0x%04x \"\n\t       \"data_len=%d%s%s\\n\",\n\t       fc, (fc & IEEE80211_FCTL_FTYPE) >> 2,\n\t       (fc & IEEE80211_FCTL_STYPE) >> 4,\n\t       __le16_to_cpu(tx->duration_id), __le16_to_cpu(tx->seq_ctrl),\n\t       __le16_to_cpu(tx->data_len),\n\t       fc & IEEE80211_FCTL_TODS ? \" [ToDS]\" : \"\",\n\t       fc & IEEE80211_FCTL_FROMDS ? \" [FromDS]\" : \"\");\n\n\tprintk(KERN_DEBUG \"   A1=%pM A2=%pM A3=%pM A4=%pM\\n\",\n\t       tx->addr1, tx->addr2, tx->addr3, tx->addr4);\n\n\tprintk(KERN_DEBUG \"   dst=%pM src=%pM len=%d\\n\",\n\t       tx->dst_addr, tx->src_addr,\n\t       __be16_to_cpu(tx->len));\n}\n\n\nstatic int hostap_80211_header_parse(const struct sk_buff *skb,\n\t\t\t\t     unsigned char *haddr)\n{\n\tmemcpy(haddr, skb_mac_header(skb) + 10, ETH_ALEN); /* addr2 */\n\treturn ETH_ALEN;\n}\n\n\nint hostap_80211_get_hdrlen(__le16 fc)\n{\n\tif (ieee80211_is_data(fc) && ieee80211_has_a4 (fc))\n\t\treturn 30; /* Addr4 */\n\telse if (ieee80211_is_cts(fc) || ieee80211_is_ack(fc))\n\t\treturn 10;\n\telse if (ieee80211_is_ctl(fc))\n\t\treturn 16;\n\n\treturn 24;\n}\n\n\nstatic int prism2_close(struct net_device *dev)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\n\tPDEBUG(DEBUG_FLOW, \"%s: prism2_close\\n\", dev->name);\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (dev == local->ddev) {\n\t\tprism2_sta_deauth(local, WLAN_REASON_DEAUTH_LEAVING);\n\t}\n#ifndef PRISM2_NO_KERNEL_IEEE80211_MGMT\n\tif (!local->hostapd && dev == local->dev &&\n\t    (!local->func->card_present || local->func->card_present(local)) &&\n\t    local->hw_ready && local->ap && local->iw_mode == IW_MODE_MASTER)\n\t\thostap_deauth_all_stas(dev, local->ap, 1);\n#endif /* PRISM2_NO_KERNEL_IEEE80211_MGMT */\n\n\tif (dev == local->dev) {\n\t\tlocal->func->hw_shutdown(dev, HOSTAP_HW_ENABLE_CMDCOMPL);\n\t}\n\n\tif (netif_running(dev)) {\n\t\tnetif_stop_queue(dev);\n\t\tnetif_device_detach(dev);\n\t}\n\n\tcancel_work_sync(&local->reset_queue);\n\tcancel_work_sync(&local->set_multicast_list_queue);\n\tcancel_work_sync(&local->set_tim_queue);\n#ifndef PRISM2_NO_STATION_MODES\n\tcancel_work_sync(&local->info_queue);\n#endif\n\tcancel_work_sync(&local->comms_qual_update);\n\n\tmodule_put(local->hw_module);\n\n\tlocal->num_dev_open--;\n\n\tif (dev != local->dev && local->dev->flags & IFF_UP &&\n\t    local->master_dev_auto_open && local->num_dev_open == 1) {\n\t\t/* Close master radio interface automatically if it was also\n\t\t * opened automatically and we are now closing the last\n\t\t * remaining non-master device. */\n\t\tdev_close(local->dev);\n\t}\n\n\treturn 0;\n}\n\n\nstatic int prism2_open(struct net_device *dev)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\n\tPDEBUG(DEBUG_FLOW, \"%s: prism2_open\\n\", dev->name);\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (local->no_pri) {\n\t\tprintk(KERN_DEBUG \"%s: could not set interface UP - no PRI \"\n\t\t       \"f/w\\n\", dev->name);\n\t\treturn 1;\n\t}\n\n\tif ((local->func->card_present && !local->func->card_present(local)) ||\n\t    local->hw_downloading)\n\t\treturn -ENODEV;\n\n\tif (!try_module_get(local->hw_module))\n\t\treturn -ENODEV;\n\tlocal->num_dev_open++;\n\n\tif (!local->dev_enabled && local->func->hw_enable(dev, 1)) {\n\t\tprintk(KERN_WARNING \"%s: could not enable MAC port\\n\",\n\t\t       dev->name);\n\t\tprism2_close(dev);\n\t\treturn 1;\n\t}\n\tif (!local->dev_enabled)\n\t\tprism2_callback(local, PRISM2_CALLBACK_ENABLE);\n\tlocal->dev_enabled = 1;\n\n\tif (dev != local->dev && !(local->dev->flags & IFF_UP)) {\n\t\t/* Master radio interface is needed for all operation, so open\n\t\t * it automatically when any virtual net_device is opened. */\n\t\tlocal->master_dev_auto_open = 1;\n\t\tdev_open(local->dev);\n\t}\n\n\tnetif_device_attach(dev);\n\tnetif_start_queue(dev);\n\n\treturn 0;\n}\n\n\nstatic int prism2_set_mac_address(struct net_device *dev, void *p)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tstruct list_head *ptr;\n\tstruct sockaddr *addr = p;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tif (local->func->set_rid(dev, HFA384X_RID_CNFOWNMACADDR, addr->sa_data,\n\t\t\t\t ETH_ALEN) < 0 || local->func->reset_port(dev))\n\t\treturn -EINVAL;\n\n\tread_lock_bh(&local->iface_lock);\n\tlist_for_each(ptr, &local->hostap_interfaces) {\n\t\tiface = list_entry(ptr, struct hostap_interface, list);\n\t\tmemcpy(iface->dev->dev_addr, addr->sa_data, ETH_ALEN);\n\t}\n\tmemcpy(local->dev->dev_addr, addr->sa_data, ETH_ALEN);\n\tread_unlock_bh(&local->iface_lock);\n\n\treturn 0;\n}\n\n\n/* TODO: to be further implemented as soon as Prism2 fully supports\n *       GroupAddresses and correct documentation is available */\nvoid hostap_set_multicast_list_queue(struct work_struct *work)\n{\n\tlocal_info_t *local =\n\t\tcontainer_of(work, local_info_t, set_multicast_list_queue);\n\tstruct net_device *dev = local->dev;\n\n\tif (hostap_set_word(dev, HFA384X_RID_PROMISCUOUSMODE,\n\t\t\t    local->is_promisc)) {\n\t\tprintk(KERN_INFO \"%s: %sabling promiscuous mode failed\\n\",\n\t\t       dev->name, local->is_promisc ? \"en\" : \"dis\");\n\t}\n}\n\n\nstatic void hostap_set_multicast_list(struct net_device *dev)\n{\n#if 0\n\t/* FIX: promiscuous mode seems to be causing a lot of problems with\n\t * some station firmware versions (FCSErr frames, invalid MACPort, etc.\n\t * corrupted incoming frames). This code is now commented out while the\n\t * problems are investigated. */\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\tif ((dev->flags & IFF_ALLMULTI) || (dev->flags & IFF_PROMISC)) {\n\t\tlocal->is_promisc = 1;\n\t} else {\n\t\tlocal->is_promisc = 0;\n\t}\n\n\tschedule_work(&local->set_multicast_list_queue);\n#endif\n}\n\n\nstatic int prism2_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tif (new_mtu < PRISM2_MIN_MTU || new_mtu > PRISM2_MAX_MTU)\n\t\treturn -EINVAL;\n\n\tdev->mtu = new_mtu;\n\treturn 0;\n}\n\n\nstatic void prism2_tx_timeout(struct net_device *dev)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tstruct hfa384x_regs regs;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\n\tprintk(KERN_WARNING \"%s Tx timed out! Resetting card\\n\", dev->name);\n\tnetif_stop_queue(local->dev);\n\n\tlocal->func->read_regs(dev, &regs);\n\tprintk(KERN_DEBUG \"%s: CMD=%04x EVSTAT=%04x \"\n\t       \"OFFSET0=%04x OFFSET1=%04x SWSUPPORT0=%04x\\n\",\n\t       dev->name, regs.cmd, regs.evstat, regs.offset0, regs.offset1,\n\t       regs.swsupport0);\n\n\tlocal->func->schedule_reset(local);\n}\n\nconst struct header_ops hostap_80211_ops = {\n\t.create\t\t= eth_header,\n\t.rebuild\t= eth_rebuild_header,\n\t.cache\t\t= eth_header_cache,\n\t.cache_update\t= eth_header_cache_update,\n\t.parse\t\t= hostap_80211_header_parse,\n};\nEXPORT_SYMBOL(hostap_80211_ops);\n\n\nstatic const struct net_device_ops hostap_netdev_ops = {\n\t.ndo_start_xmit\t\t= hostap_data_start_xmit,\n\n\t.ndo_open\t\t= prism2_open,\n\t.ndo_stop\t\t= prism2_close,\n\t.ndo_do_ioctl\t\t= hostap_ioctl,\n\t.ndo_set_mac_address\t= prism2_set_mac_address,\n\t.ndo_set_multicast_list = hostap_set_multicast_list,\n\t.ndo_change_mtu \t= prism2_change_mtu,\n\t.ndo_tx_timeout \t= prism2_tx_timeout,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic const struct net_device_ops hostap_mgmt_netdev_ops = {\n\t.ndo_start_xmit\t\t= hostap_mgmt_start_xmit,\n\n\t.ndo_open\t\t= prism2_open,\n\t.ndo_stop\t\t= prism2_close,\n\t.ndo_do_ioctl\t\t= hostap_ioctl,\n\t.ndo_set_mac_address\t= prism2_set_mac_address,\n\t.ndo_set_multicast_list = hostap_set_multicast_list,\n\t.ndo_change_mtu \t= prism2_change_mtu,\n\t.ndo_tx_timeout \t= prism2_tx_timeout,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nstatic const struct net_device_ops hostap_master_ops = {\n\t.ndo_start_xmit \t= hostap_master_start_xmit,\n\n\t.ndo_open\t\t= prism2_open,\n\t.ndo_stop\t\t= prism2_close,\n\t.ndo_do_ioctl\t\t= hostap_ioctl,\n\t.ndo_set_mac_address\t= prism2_set_mac_address,\n\t.ndo_set_multicast_list = hostap_set_multicast_list,\n\t.ndo_change_mtu \t= prism2_change_mtu,\n\t.ndo_tx_timeout \t= prism2_tx_timeout,\n\t.ndo_validate_addr\t= eth_validate_addr,\n};\n\nvoid hostap_setup_dev(struct net_device *dev, local_info_t *local,\n\t\t      int type)\n{\n\tstruct hostap_interface *iface;\n\n\tiface = netdev_priv(dev);\n\tether_setup(dev);\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\n\t/* kernel callbacks */\n\tif (iface) {\n\t\t/* Currently, we point to the proper spy_data only on\n\t\t * the main_dev. This could be fixed. Jean II */\n\t\tiface->wireless_data.spy_data = &iface->spy_data;\n\t\tdev->wireless_data = &iface->wireless_data;\n\t}\n\tdev->wireless_handlers = &hostap_iw_handler_def;\n\tdev->watchdog_timeo = TX_TIMEOUT;\n\n\tswitch(type) {\n\tcase HOSTAP_INTERFACE_AP:\n\t\tdev->tx_queue_len = 0;\t/* use main radio device queue */\n\t\tdev->netdev_ops = &hostap_mgmt_netdev_ops;\n\t\tdev->type = ARPHRD_IEEE80211;\n\t\tdev->header_ops = &hostap_80211_ops;\n\t\tbreak;\n\tcase HOSTAP_INTERFACE_MASTER:\n\t\tdev->netdev_ops = &hostap_master_ops;\n\t\tbreak;\n\tdefault:\n\t\tdev->tx_queue_len = 0;\t/* use main radio device queue */\n\t\tdev->netdev_ops = &hostap_netdev_ops;\n\t}\n\n\tdev->mtu = local->mtu;\n\n\n\tSET_ETHTOOL_OPS(dev, &prism2_ethtool_ops);\n\n}\n\nstatic int hostap_enable_hostapd(local_info_t *local, int rtnl_locked)\n{\n\tstruct net_device *dev = local->dev;\n\n\tif (local->apdev)\n\t\treturn -EEXIST;\n\n\tprintk(KERN_DEBUG \"%s: enabling hostapd mode\\n\", dev->name);\n\n\tlocal->apdev = hostap_add_interface(local, HOSTAP_INTERFACE_AP,\n\t\t\t\t\t    rtnl_locked, local->ddev->name,\n\t\t\t\t\t    \"ap\");\n\tif (local->apdev == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n\nstatic int hostap_disable_hostapd(local_info_t *local, int rtnl_locked)\n{\n\tstruct net_device *dev = local->dev;\n\n\tprintk(KERN_DEBUG \"%s: disabling hostapd mode\\n\", dev->name);\n\n\thostap_remove_interface(local->apdev, rtnl_locked, 1);\n\tlocal->apdev = NULL;\n\n\treturn 0;\n}\n\n\nstatic int hostap_enable_hostapd_sta(local_info_t *local, int rtnl_locked)\n{\n\tstruct net_device *dev = local->dev;\n\n\tif (local->stadev)\n\t\treturn -EEXIST;\n\n\tprintk(KERN_DEBUG \"%s: enabling hostapd STA mode\\n\", dev->name);\n\n\tlocal->stadev = hostap_add_interface(local, HOSTAP_INTERFACE_STA,\n\t\t\t\t\t     rtnl_locked, local->ddev->name,\n\t\t\t\t\t     \"sta\");\n\tif (local->stadev == NULL)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\n\nstatic int hostap_disable_hostapd_sta(local_info_t *local, int rtnl_locked)\n{\n\tstruct net_device *dev = local->dev;\n\n\tprintk(KERN_DEBUG \"%s: disabling hostapd mode\\n\", dev->name);\n\n\thostap_remove_interface(local->stadev, rtnl_locked, 1);\n\tlocal->stadev = NULL;\n\n\treturn 0;\n}\n\n\nint hostap_set_hostapd(local_info_t *local, int val, int rtnl_locked)\n{\n\tint ret;\n\n\tif (val < 0 || val > 1)\n\t\treturn -EINVAL;\n\n\tif (local->hostapd == val)\n\t\treturn 0;\n\n\tif (val) {\n\t\tret = hostap_enable_hostapd(local, rtnl_locked);\n\t\tif (ret == 0)\n\t\t\tlocal->hostapd = 1;\n\t} else {\n\t\tlocal->hostapd = 0;\n\t\tret = hostap_disable_hostapd(local, rtnl_locked);\n\t\tif (ret != 0)\n\t\t\tlocal->hostapd = 1;\n\t}\n\n\treturn ret;\n}\n\n\nint hostap_set_hostapd_sta(local_info_t *local, int val, int rtnl_locked)\n{\n\tint ret;\n\n\tif (val < 0 || val > 1)\n\t\treturn -EINVAL;\n\n\tif (local->hostapd_sta == val)\n\t\treturn 0;\n\n\tif (val) {\n\t\tret = hostap_enable_hostapd_sta(local, rtnl_locked);\n\t\tif (ret == 0)\n\t\t\tlocal->hostapd_sta = 1;\n\t} else {\n\t\tlocal->hostapd_sta = 0;\n\t\tret = hostap_disable_hostapd_sta(local, rtnl_locked);\n\t\tif (ret != 0)\n\t\t\tlocal->hostapd_sta = 1;\n\t}\n\n\n\treturn ret;\n}\n\n\nint prism2_update_comms_qual(struct net_device *dev)\n{\n\tstruct hostap_interface *iface;\n\tlocal_info_t *local;\n\tint ret = 0;\n\tstruct hfa384x_comms_quality sq;\n\n\tiface = netdev_priv(dev);\n\tlocal = iface->local;\n\tif (!local->sta_fw_ver)\n\t\tret = -1;\n\telse if (local->sta_fw_ver >= PRISM2_FW_VER(1,3,1)) {\n\t\tif (local->func->get_rid(local->dev,\n\t\t\t\t\t HFA384X_RID_DBMCOMMSQUALITY,\n\t\t\t\t\t &sq, sizeof(sq), 1) >= 0) {\n\t\t\tlocal->comms_qual = (s16) le16_to_cpu(sq.comm_qual);\n\t\t\tlocal->avg_signal = (s16) le16_to_cpu(sq.signal_level);\n\t\t\tlocal->avg_noise = (s16) le16_to_cpu(sq.noise_level);\n\t\t\tlocal->last_comms_qual_update = jiffies;\n\t\t} else\n\t\t\tret = -1;\n\t} else {\n\t\tif (local->func->get_rid(local->dev, HFA384X_RID_COMMSQUALITY,\n\t\t\t\t\t &sq, sizeof(sq), 1) >= 0) {\n\t\t\tlocal->comms_qual = le16_to_cpu(sq.comm_qual);\n\t\t\tlocal->avg_signal = HFA384X_LEVEL_TO_dBm(\n\t\t\t\tle16_to_cpu(sq.signal_level));\n\t\t\tlocal->avg_noise = HFA384X_LEVEL_TO_dBm(\n\t\t\t\tle16_to_cpu(sq.noise_level));\n\t\t\tlocal->last_comms_qual_update = jiffies;\n\t\t} else\n\t\t\tret = -1;\n\t}\n\n\treturn ret;\n}\n\n\nint prism2_sta_send_mgmt(local_info_t *local, u8 *dst, u16 stype,\n\t\t\t u8 *body, size_t bodylen)\n{\n\tstruct sk_buff *skb;\n\tstruct hostap_ieee80211_mgmt *mgmt;\n\tstruct hostap_skb_tx_data *meta;\n\tstruct net_device *dev = local->dev;\n\n\tskb = dev_alloc_skb(IEEE80211_MGMT_HDR_LEN + bodylen);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tmgmt = (struct hostap_ieee80211_mgmt *)\n\t\tskb_put(skb, IEEE80211_MGMT_HDR_LEN);\n\tmemset(mgmt, 0, IEEE80211_MGMT_HDR_LEN);\n\tmgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT | stype);\n\tmemcpy(mgmt->da, dst, ETH_ALEN);\n\tmemcpy(mgmt->sa, dev->dev_addr, ETH_ALEN);\n\tmemcpy(mgmt->bssid, dst, ETH_ALEN);\n\tif (body)\n\t\tmemcpy(skb_put(skb, bodylen), body, bodylen);\n\n\tmeta = (struct hostap_skb_tx_data *) skb->cb;\n\tmemset(meta, 0, sizeof(*meta));\n\tmeta->magic = HOSTAP_SKB_TX_DATA_MAGIC;\n\tmeta->iface = netdev_priv(dev);\n\n\tskb->dev = dev;\n\tskb_reset_mac_header(skb);\n\tskb_reset_network_header(skb);\n\tdev_queue_xmit(skb);\n\n\treturn 0;\n}\n\n\nint prism2_sta_deauth(local_info_t *local, u16 reason)\n{\n\tunion iwreq_data wrqu;\n\tint ret;\n\t__le16 val = cpu_to_le16(reason);\n\n\tif (local->iw_mode != IW_MODE_INFRA ||\n\t    memcmp(local->bssid, \"\\x00\\x00\\x00\\x00\\x00\\x00\", ETH_ALEN) == 0 ||\n\t    memcmp(local->bssid, \"\\x44\\x44\\x44\\x44\\x44\\x44\", ETH_ALEN) == 0)\n\t\treturn 0;\n\n\tret = prism2_sta_send_mgmt(local, local->bssid, IEEE80211_STYPE_DEAUTH,\n\t\t\t\t   (u8 *) &val, 2);\n\tmemset(wrqu.ap_addr.sa_data, 0, ETH_ALEN);\n\twireless_send_event(local->dev, SIOCGIWAP, &wrqu, NULL);\n\treturn ret;\n}\n\n\nstruct proc_dir_entry *hostap_proc;\n\nstatic int __init hostap_init(void)\n{\n\tif (init_net.proc_net != NULL) {\n\t\thostap_proc = proc_mkdir(\"hostap\", init_net.proc_net);\n\t\tif (!hostap_proc)\n\t\t\tprintk(KERN_WARNING \"Failed to mkdir \"\n\t\t\t       \"/proc/net/hostap\\n\");\n\t} else\n\t\thostap_proc = NULL;\n\n\treturn 0;\n}\n\n\nstatic void __exit hostap_exit(void)\n{\n\tif (hostap_proc != NULL) {\n\t\thostap_proc = NULL;\n\t\tremove_proc_entry(\"hostap\", init_net.proc_net);\n\t}\n}\n\n\nEXPORT_SYMBOL(hostap_set_word);\nEXPORT_SYMBOL(hostap_set_string);\nEXPORT_SYMBOL(hostap_get_porttype);\nEXPORT_SYMBOL(hostap_set_encryption);\nEXPORT_SYMBOL(hostap_set_antsel);\nEXPORT_SYMBOL(hostap_set_roaming);\nEXPORT_SYMBOL(hostap_set_auth_algs);\nEXPORT_SYMBOL(hostap_dump_rx_header);\nEXPORT_SYMBOL(hostap_dump_tx_header);\nEXPORT_SYMBOL(hostap_80211_get_hdrlen);\nEXPORT_SYMBOL(hostap_setup_dev);\nEXPORT_SYMBOL(hostap_set_multicast_list_queue);\nEXPORT_SYMBOL(hostap_set_hostapd);\nEXPORT_SYMBOL(hostap_set_hostapd_sta);\nEXPORT_SYMBOL(hostap_add_interface);\nEXPORT_SYMBOL(hostap_remove_interface);\nEXPORT_SYMBOL(prism2_update_comms_qual);\n\nmodule_init(hostap_init);\nmodule_exit(hostap_exit);\n", "//------------------------------------------------------------------------------\n// Copyright (c) 2004-2010 Atheros Communications Inc.\n// All rights reserved.\n//\n// \n//\n// Permission to use, copy, modify, and/or distribute this software for any\n// purpose with or without fee is hereby granted, provided that the above\n// copyright notice and this permission notice appear in all copies.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n//\n//\n//\n// Author(s): =\"Atheros\"\n//------------------------------------------------------------------------------\n\n/*\n * This driver is a pseudo ethernet driver to access the Atheros AR6000\n * WLAN Device\n */\n\n#include \"ar6000_drv.h\"\n#include \"cfg80211.h\"\n#include \"htc.h\"\n#include \"wmi_filter_linux.h\"\n#include \"epping_test.h\"\n#include \"wlan_config.h\"\n#include \"ar3kconfig.h\"\n#include \"ar6k_pal.h\"\n#include \"AR6002/addrs.h\"\n\n\n/* LINUX_HACK_FUDGE_FACTOR -- this is used to provide a workaround for linux behavior.  When\n *  the meta data was added to the header it was found that linux did not correctly provide\n *  enough headroom.  However when more headroom was requested beyond what was truly needed\n *  Linux gave the requested headroom. Therefore to get the necessary headroom from Linux\n *  the driver requests more than is needed by the amount = LINUX_HACK_FUDGE_FACTOR */\n#define LINUX_HACK_FUDGE_FACTOR 16\n#define BDATA_BDADDR_OFFSET     28\n\nu8 bcast_mac[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\nu8 null_mac[] = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0};\n\n#ifdef DEBUG\n\n#define  ATH_DEBUG_DBG_LOG       ATH_DEBUG_MAKE_MODULE_MASK(0)\n#define  ATH_DEBUG_WLAN_CONNECT  ATH_DEBUG_MAKE_MODULE_MASK(1)\n#define  ATH_DEBUG_WLAN_SCAN     ATH_DEBUG_MAKE_MODULE_MASK(2)\n#define  ATH_DEBUG_WLAN_TX       ATH_DEBUG_MAKE_MODULE_MASK(3)\n#define  ATH_DEBUG_WLAN_RX       ATH_DEBUG_MAKE_MODULE_MASK(4)\n#define  ATH_DEBUG_HTC_RAW       ATH_DEBUG_MAKE_MODULE_MASK(5)\n#define  ATH_DEBUG_HCI_BRIDGE    ATH_DEBUG_MAKE_MODULE_MASK(6)\n\nstatic struct ath_debug_mask_description driver_debug_desc[] = {\n    { ATH_DEBUG_DBG_LOG      , \"Target Debug Logs\"},\n    { ATH_DEBUG_WLAN_CONNECT , \"WLAN connect\"},\n    { ATH_DEBUG_WLAN_SCAN    , \"WLAN scan\"},\n    { ATH_DEBUG_WLAN_TX      , \"WLAN Tx\"},\n    { ATH_DEBUG_WLAN_RX      , \"WLAN Rx\"},\n    { ATH_DEBUG_HTC_RAW      , \"HTC Raw IF tracing\"},\n    { ATH_DEBUG_HCI_BRIDGE   , \"HCI Bridge Setup\"},\n    { ATH_DEBUG_HCI_RECV     , \"HCI Recv tracing\"},\n    { ATH_DEBUG_HCI_DUMP     , \"HCI Packet dumps\"},\n};\n\nATH_DEBUG_INSTANTIATE_MODULE_VAR(driver,\n                                 \"driver\",\n                                 \"Linux Driver Interface\",\n                                 ATH_DEBUG_MASK_DEFAULTS | ATH_DEBUG_WLAN_SCAN |\n                                 ATH_DEBUG_HCI_BRIDGE,\n                                 ATH_DEBUG_DESCRIPTION_COUNT(driver_debug_desc),\n                                 driver_debug_desc);\n\n#endif\n\n\n#define IS_MAC_NULL(mac) (mac[0]==0 && mac[1]==0 && mac[2]==0 && mac[3]==0 && mac[4]==0 && mac[5]==0)\n#define IS_MAC_BCAST(mac) (*mac==0xff)\n\n#define DESCRIPTION \"Driver to access the Atheros AR600x Device, version \" __stringify(__VER_MAJOR_) \".\" __stringify(__VER_MINOR_) \".\" __stringify(__VER_PATCH_) \".\" __stringify(__BUILD_NUMBER_)\n\nMODULE_AUTHOR(\"Atheros Communications, Inc.\");\nMODULE_DESCRIPTION(DESCRIPTION);\nMODULE_LICENSE(\"Dual BSD/GPL\");\n\n#ifndef REORG_APTC_HEURISTICS\n#undef ADAPTIVE_POWER_THROUGHPUT_CONTROL\n#endif /* REORG_APTC_HEURISTICS */\n\n#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL\n#define APTC_TRAFFIC_SAMPLING_INTERVAL     100  /* msec */\n#define APTC_UPPER_THROUGHPUT_THRESHOLD    3000 /* Kbps */\n#define APTC_LOWER_THROUGHPUT_THRESHOLD    2000 /* Kbps */\n\ntypedef struct aptc_traffic_record {\n    bool timerScheduled;\n    struct timeval samplingTS;\n    unsigned long bytesReceived;\n    unsigned long bytesTransmitted;\n} APTC_TRAFFIC_RECORD;\n\nA_TIMER aptcTimer;\nAPTC_TRAFFIC_RECORD aptcTR;\n#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */\n\n#ifdef EXPORT_HCI_BRIDGE_INTERFACE\n// callbacks registered by HCI transport driver\nstruct hci_transport_callbacks ar6kHciTransCallbacks = { NULL };\n#endif\n\nunsigned int processDot11Hdr = 0;\n\nchar ifname[IFNAMSIZ] = {0,};\n\nint wlaninitmode = WLAN_INIT_MODE_DEFAULT;\nstatic bool bypasswmi;\nunsigned int debuglevel = 0;\nint tspecCompliance = ATHEROS_COMPLIANCE;\nunsigned int busspeedlow = 0;\nunsigned int onebitmode = 0;\nunsigned int skipflash = 0;\nunsigned int wmitimeout = 2;\nunsigned int wlanNodeCaching = 1;\nunsigned int enableuartprint = ENABLEUARTPRINT_DEFAULT;\nunsigned int logWmiRawMsgs = 0;\nunsigned int enabletimerwar = 0;\nunsigned int num_device = 1;\nunsigned int regscanmode;\nunsigned int fwmode = 1;\nunsigned int mbox_yield_limit = 99;\nunsigned int enablerssicompensation = 0;\nint reduce_credit_dribble = 1 + HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_ONE_HALF;\nint allow_trace_signal = 0;\n#ifdef CONFIG_HOST_TCMD_SUPPORT\nunsigned int testmode =0;\n#endif\n\nunsigned int irqprocmode = HIF_DEVICE_IRQ_SYNC_ONLY;//HIF_DEVICE_IRQ_ASYNC_SYNC;\nunsigned int panic_on_assert = 1;\nunsigned int nohifscattersupport = NOHIFSCATTERSUPPORT_DEFAULT;\n\nunsigned int setuphci = SETUPHCI_DEFAULT;\nunsigned int loghci = 0;\nunsigned int setupbtdev = SETUPBTDEV_DEFAULT;\n#ifndef EXPORT_HCI_BRIDGE_INTERFACE\nunsigned int ar3khcibaud = AR3KHCIBAUD_DEFAULT;\nunsigned int hciuartscale = HCIUARTSCALE_DEFAULT;\nunsigned int hciuartstep = HCIUARTSTEP_DEFAULT;\n#endif\nunsigned int csumOffload=0;\nunsigned int csumOffloadTest=0;\nunsigned int eppingtest=0;\nunsigned int mac_addr_method;\nunsigned int firmware_bridge;\n\nmodule_param_string(ifname, ifname, sizeof(ifname), 0644);\nmodule_param(wlaninitmode, int, 0644);\nmodule_param(bypasswmi, bool, 0644);\nmodule_param(debuglevel, uint, 0644);\nmodule_param(tspecCompliance, int, 0644);\nmodule_param(onebitmode, uint, 0644);\nmodule_param(busspeedlow, uint, 0644);\nmodule_param(skipflash, uint, 0644);\nmodule_param(wmitimeout, uint, 0644);\nmodule_param(wlanNodeCaching, uint, 0644);\nmodule_param(logWmiRawMsgs, uint, 0644);\nmodule_param(enableuartprint, uint, 0644);\nmodule_param(enabletimerwar, uint, 0644);\nmodule_param(fwmode, uint, 0644);\nmodule_param(mbox_yield_limit, uint, 0644);\nmodule_param(reduce_credit_dribble, int, 0644);\nmodule_param(allow_trace_signal, int, 0644);\nmodule_param(enablerssicompensation, uint, 0644);\nmodule_param(processDot11Hdr, uint, 0644);\nmodule_param(csumOffload, uint, 0644);\n#ifdef CONFIG_HOST_TCMD_SUPPORT\nmodule_param(testmode, uint, 0644);\n#endif\nmodule_param(irqprocmode, uint, 0644);\nmodule_param(nohifscattersupport, uint, 0644);\nmodule_param(panic_on_assert, uint, 0644);\nmodule_param(setuphci, uint, 0644);\nmodule_param(loghci, uint, 0644);\nmodule_param(setupbtdev, uint, 0644);\n#ifndef EXPORT_HCI_BRIDGE_INTERFACE\nmodule_param(ar3khcibaud, uint, 0644);\nmodule_param(hciuartscale, uint, 0644);\nmodule_param(hciuartstep, uint, 0644);\n#endif\nmodule_param(eppingtest, uint, 0644);\n\n/* in 2.6.10 and later this is now a pointer to a uint */\nunsigned int _mboxnum = HTC_MAILBOX_NUM_MAX;\n#define mboxnum &_mboxnum\n\n#ifdef DEBUG\nu32 g_dbg_flags = DBG_DEFAULTS;\nunsigned int debugflags = 0;\nint debugdriver = 0;\nunsigned int debughtc = 0;\nunsigned int debugbmi = 0;\nunsigned int debughif = 0;\nunsigned int txcreditsavailable[HTC_MAILBOX_NUM_MAX] = {0};\nunsigned int txcreditsconsumed[HTC_MAILBOX_NUM_MAX] = {0};\nunsigned int txcreditintrenable[HTC_MAILBOX_NUM_MAX] = {0};\nunsigned int txcreditintrenableaggregate[HTC_MAILBOX_NUM_MAX] = {0};\nmodule_param(debugflags, uint, 0644);\nmodule_param(debugdriver, int, 0644);\nmodule_param(debughtc, uint, 0644);\nmodule_param(debugbmi, uint, 0644);\nmodule_param(debughif, uint, 0644);\nmodule_param_array(txcreditsavailable, uint, mboxnum, 0644);\nmodule_param_array(txcreditsconsumed, uint, mboxnum, 0644);\nmodule_param_array(txcreditintrenable, uint, mboxnum, 0644);\nmodule_param_array(txcreditintrenableaggregate, uint, mboxnum, 0644);\n\n#endif /* DEBUG */\n\nunsigned int resetok = 1;\nunsigned int tx_attempt[HTC_MAILBOX_NUM_MAX] = {0};\nunsigned int tx_post[HTC_MAILBOX_NUM_MAX] = {0};\nunsigned int tx_complete[HTC_MAILBOX_NUM_MAX] = {0};\nunsigned int hifBusRequestNumMax = 40;\nunsigned int war23838_disabled = 0;\n#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL\nunsigned int enableAPTCHeuristics = 1;\n#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */\nmodule_param_array(tx_attempt, uint, mboxnum, 0644);\nmodule_param_array(tx_post, uint, mboxnum, 0644);\nmodule_param_array(tx_complete, uint, mboxnum, 0644);\nmodule_param(hifBusRequestNumMax, uint, 0644);\nmodule_param(war23838_disabled, uint, 0644);\nmodule_param(resetok, uint, 0644);\n#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL\nmodule_param(enableAPTCHeuristics, uint, 0644);\n#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */\n\n#ifdef BLOCK_TX_PATH_FLAG\nint blocktx = 0;\nmodule_param(blocktx, int, 0644);\n#endif /* BLOCK_TX_PATH_FLAG */\n\ntypedef struct user_rssi_compensation_t {\n    u16 customerID;\n    union {\n    u16 a_enable;\n    u16 bg_enable;\n    u16 enable;\n    };\n    s16 bg_param_a;\n    s16 bg_param_b;\n    s16 a_param_a;\n    s16 a_param_b;\n    u32 reserved;\n} USER_RSSI_CPENSATION;\n\nstatic USER_RSSI_CPENSATION rssi_compensation_param;\n\nstatic s16 rssi_compensation_table[96];\n\nint reconnect_flag = 0;\nstatic ar6k_pal_config_t ar6k_pal_config_g;\n\n/* Function declarations */\nstatic int ar6000_init_module(void);\nstatic void ar6000_cleanup_module(void);\n\nint ar6000_init(struct net_device *dev);\nstatic int ar6000_open(struct net_device *dev);\nstatic int ar6000_close(struct net_device *dev);\nstatic void ar6000_init_control_info(struct ar6_softc *ar);\nstatic int ar6000_data_tx(struct sk_buff *skb, struct net_device *dev);\n\nvoid ar6000_destroy(struct net_device *dev, unsigned int unregister);\nstatic void ar6000_detect_error(unsigned long ptr);\nstatic void\tar6000_set_multicast_list(struct net_device *dev);\nstatic struct net_device_stats *ar6000_get_stats(struct net_device *dev);\n\nstatic void disconnect_timer_handler(unsigned long ptr);\n\nvoid read_rssi_compensation_param(struct ar6_softc *ar);\n\n/*\n * HTC service connection handlers\n */\nstatic int ar6000_avail_ev(void *context, void *hif_handle);\n\nstatic int ar6000_unavail_ev(void *context, void *hif_handle);\n\nint ar6000_configure_target(struct ar6_softc *ar);\n\nstatic void ar6000_target_failure(void *Instance, int Status);\n\nstatic void ar6000_rx(void *Context, struct htc_packet *pPacket);\n\nstatic void ar6000_rx_refill(void *Context,HTC_ENDPOINT_ID Endpoint);\n\nstatic void ar6000_tx_complete(void *Context, struct htc_packet_queue *pPackets);\n\nstatic HTC_SEND_FULL_ACTION ar6000_tx_queue_full(void *Context, struct htc_packet *pPacket);\n\nstatic void ar6000_alloc_netbufs(A_NETBUF_QUEUE_T *q, u16 num);\nstatic void ar6000_deliver_frames_to_nw_stack(void * dev, void *osbuf);\n//static void ar6000_deliver_frames_to_bt_stack(void * dev, void *osbuf);\n\nstatic struct htc_packet *ar6000_alloc_amsdu_rxbuf(void *Context, HTC_ENDPOINT_ID Endpoint, int Length);\n\nstatic void ar6000_refill_amsdu_rxbufs(struct ar6_softc *ar, int Count);\n\nstatic void ar6000_cleanup_amsdu_rxbufs(struct ar6_softc *ar);\n\nstatic ssize_t\nar6000_sysfs_bmi_read(struct file *fp, struct kobject *kobj,\n                      struct bin_attribute *bin_attr,\n                      char *buf, loff_t pos, size_t count);\n\nstatic ssize_t\nar6000_sysfs_bmi_write(struct file *fp, struct kobject *kobj,\n                       struct bin_attribute *bin_attr,\n                       char *buf, loff_t pos, size_t count);\n\nstatic int\nar6000_sysfs_bmi_init(struct ar6_softc *ar);\n\nvoid  ar6k_cleanup_hci_pal(struct ar6_softc *ar);\n\nstatic void\nar6000_sysfs_bmi_deinit(struct ar6_softc *ar);\n\nint\nar6000_sysfs_bmi_get_config(struct ar6_softc *ar, u32 mode);\n\n/*\n * Static variables\n */\n\nstruct net_device *ar6000_devices[MAX_AR6000];\nstatic int is_netdev_registered;\nDECLARE_WAIT_QUEUE_HEAD(arEvent);\nstatic void ar6000_cookie_init(struct ar6_softc *ar);\nstatic void ar6000_cookie_cleanup(struct ar6_softc *ar);\nstatic void ar6000_free_cookie(struct ar6_softc *ar, struct ar_cookie * cookie);\nstatic struct ar_cookie *ar6000_alloc_cookie(struct ar6_softc *ar);\n\nstatic int ar6000_reinstall_keys(struct ar6_softc *ar,u8 key_op_ctrl);\n\n#ifdef CONFIG_AP_VIRTUAL_ADAPTER_SUPPORT\nstruct net_device *arApNetDev;\n#endif /* CONFIG_AP_VIRTUAL_ADAPTER_SUPPORT */\n\nstatic struct ar_cookie s_ar_cookie_mem[MAX_COOKIE_NUM];\n\n#define HOST_INTEREST_ITEM_ADDRESS(ar, item) \\\n        (((ar)->arTargetType == TARGET_TYPE_AR6002) ? AR6002_HOST_INTEREST_ITEM_ADDRESS(item) : \\\n        (((ar)->arTargetType == TARGET_TYPE_AR6003) ? AR6003_HOST_INTEREST_ITEM_ADDRESS(item) : 0))\n\n\nstatic struct net_device_ops ar6000_netdev_ops = {\n    .ndo_init               = NULL,\n    .ndo_open               = ar6000_open,\n    .ndo_stop               = ar6000_close,\n    .ndo_get_stats          = ar6000_get_stats,\n    .ndo_start_xmit         = ar6000_data_tx,\n    .ndo_set_multicast_list = ar6000_set_multicast_list,\n};\n\n/* Debug log support */\n\n/*\n * Flag to govern whether the debug logs should be parsed in the kernel\n * or reported to the application.\n */\n#define REPORT_DEBUG_LOGS_TO_APP\n\nint\nar6000_set_host_app_area(struct ar6_softc *ar)\n{\n    u32 address, data;\n    struct host_app_area_s host_app_area;\n\n    /* Fetch the address of the host_app_area_s instance in the host interest area */\n    address = TARG_VTOP(ar->arTargetType, HOST_INTEREST_ITEM_ADDRESS(ar, hi_app_host_interest));\n    if (ar6000_ReadRegDiag(ar->arHifDevice, &address, &data) != 0) {\n        return A_ERROR;\n    }\n    address = TARG_VTOP(ar->arTargetType, data);\n    host_app_area.wmi_protocol_ver = WMI_PROTOCOL_VERSION;\n    if (ar6000_WriteDataDiag(ar->arHifDevice, address,\n                             (u8 *)&host_app_area,\n                             sizeof(struct host_app_area_s)) != 0)\n    {\n        return A_ERROR;\n    }\n\n    return 0;\n}\n\nu32 dbglog_get_debug_hdr_ptr(struct ar6_softc *ar)\n{\n    u32 param;\n    u32 address;\n    int status;\n\n    address = TARG_VTOP(ar->arTargetType, HOST_INTEREST_ITEM_ADDRESS(ar, hi_dbglog_hdr));\n    if ((status = ar6000_ReadDataDiag(ar->arHifDevice, address,\n                                      (u8 *)&param, 4)) != 0)\n    {\n        param = 0;\n    }\n\n    return param;\n}\n\n/*\n * The dbglog module has been initialized. Its ok to access the relevant\n * data stuctures over the diagnostic window.\n */\nvoid\nar6000_dbglog_init_done(struct ar6_softc *ar)\n{\n    ar->dbglog_init_done = true;\n}\n\nu32 dbglog_get_debug_fragment(s8 *datap, u32 len, u32 limit)\n{\n    s32 *buffer;\n    u32 count;\n    u32 numargs;\n    u32 length;\n    u32 fraglen;\n\n    count = fraglen = 0;\n    buffer = (s32 *)datap;\n    length = (limit >> 2);\n\n    if (len <= limit) {\n        fraglen = len;\n    } else {\n        while (count < length) {\n            numargs = DBGLOG_GET_NUMARGS(buffer[count]);\n            fraglen = (count << 2);\n            count += numargs + 1;\n        }\n    }\n\n    return fraglen;\n}\n\nvoid\ndbglog_parse_debug_logs(s8 *datap, u32 len)\n{\n    s32 *buffer;\n    u32 count;\n    u32 timestamp;\n    u32 debugid;\n    u32 moduleid;\n    u32 numargs;\n    u32 length;\n\n    count = 0;\n    buffer = (s32 *)datap;\n    length = (len >> 2);\n    while (count < length) {\n        debugid = DBGLOG_GET_DBGID(buffer[count]);\n        moduleid = DBGLOG_GET_MODULEID(buffer[count]);\n        numargs = DBGLOG_GET_NUMARGS(buffer[count]);\n        timestamp = DBGLOG_GET_TIMESTAMP(buffer[count]);\n        switch (numargs) {\n            case 0:\n            AR_DEBUG_PRINTF(ATH_DEBUG_DBG_LOG,(\"%d %d (%d)\\n\", moduleid, debugid, timestamp));\n            break;\n\n            case 1:\n            AR_DEBUG_PRINTF(ATH_DEBUG_DBG_LOG,(\"%d %d (%d): 0x%x\\n\", moduleid, debugid,\n                            timestamp, buffer[count+1]));\n            break;\n\n            case 2:\n            AR_DEBUG_PRINTF(ATH_DEBUG_DBG_LOG,(\"%d %d (%d): 0x%x, 0x%x\\n\", moduleid, debugid,\n                            timestamp, buffer[count+1], buffer[count+2]));\n            break;\n\n            default:\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"Invalid args: %d\\n\", numargs));\n        }\n        count += numargs + 1;\n    }\n}\n\nint\nar6000_dbglog_get_debug_logs(struct ar6_softc *ar)\n{\n    u32 data[8]; /* Should be able to accommodate struct dbglog_buf_s */\n    u32 address;\n    u32 length;\n    u32 dropped;\n    u32 firstbuf;\n    u32 debug_hdr_ptr;\n\n    if (!ar->dbglog_init_done) return A_ERROR;\n\n\n    AR6000_SPIN_LOCK(&ar->arLock, 0);\n\n    if (ar->dbgLogFetchInProgress) {\n        AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n        return A_EBUSY;\n    }\n\n        /* block out others */\n    ar->dbgLogFetchInProgress = true;\n\n    AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n\n    debug_hdr_ptr = dbglog_get_debug_hdr_ptr(ar);\n    printk(\"debug_hdr_ptr: 0x%x\\n\", debug_hdr_ptr);\n\n    /* Get the contents of the ring buffer */\n    if (debug_hdr_ptr) {\n        address = TARG_VTOP(ar->arTargetType, debug_hdr_ptr);\n        length = 4 /* sizeof(dbuf) */ + 4 /* sizeof(dropped) */;\n        A_MEMZERO(data, sizeof(data));\n        ar6000_ReadDataDiag(ar->arHifDevice, address, (u8 *)data, length);\n        address = TARG_VTOP(ar->arTargetType, data[0] /* dbuf */);\n        firstbuf = address;\n        dropped = data[1]; /* dropped */\n        length = 4 /* sizeof(next) */ + 4 /* sizeof(buffer) */ + 4 /* sizeof(bufsize) */ + 4 /* sizeof(length) */ + 4 /* sizeof(count) */ + 4 /* sizeof(free) */;\n        A_MEMZERO(data, sizeof(data));\n        ar6000_ReadDataDiag(ar->arHifDevice, address, (u8 *)&data, length);\n\n        do {\n            address = TARG_VTOP(ar->arTargetType, data[1] /* buffer*/);\n            length = data[3]; /* length */\n            if ((length) && (length <= data[2] /* bufsize*/)) {\n                /* Rewind the index if it is about to overrun the buffer */\n                if (ar->log_cnt > (DBGLOG_HOST_LOG_BUFFER_SIZE - length)) {\n                    ar->log_cnt = 0;\n                }\n                if(0 != ar6000_ReadDataDiag(ar->arHifDevice, address,\n                                    (u8 *)&ar->log_buffer[ar->log_cnt], length))\n                {\n                    break;\n                }\n                ar6000_dbglog_event(ar, dropped, (s8 *)&ar->log_buffer[ar->log_cnt], length);\n                ar->log_cnt += length;\n            } else {\n                AR_DEBUG_PRINTF(ATH_DEBUG_DBG_LOG,(\"Length: %d (Total size: %d)\\n\",\n                                data[3], data[2]));\n            }\n\n            address = TARG_VTOP(ar->arTargetType, data[0] /* next */);\n            length = 4 /* sizeof(next) */ + 4 /* sizeof(buffer) */ + 4 /* sizeof(bufsize) */ + 4 /* sizeof(length) */ + 4 /* sizeof(count) */ + 4 /* sizeof(free) */;\n            A_MEMZERO(data, sizeof(data));\n            if(0 != ar6000_ReadDataDiag(ar->arHifDevice, address,\n                                (u8 *)&data, length))\n            {\n                break;\n            }\n\n        } while (address != firstbuf);\n    }\n\n    ar->dbgLogFetchInProgress = false;\n\n    return 0;\n}\n\nvoid\nar6000_dbglog_event(struct ar6_softc *ar, u32 dropped,\n                    s8 *buffer, u32 length)\n{\n#ifdef REPORT_DEBUG_LOGS_TO_APP\n    #define MAX_WIRELESS_EVENT_SIZE 252\n    /*\n     * Break it up into chunks of MAX_WIRELESS_EVENT_SIZE bytes of messages.\n     * There seems to be a limitation on the length of message that could be\n     * transmitted to the user app via this mechanism.\n     */\n    u32 send, sent;\n\n    sent = 0;\n    send = dbglog_get_debug_fragment(&buffer[sent], length - sent,\n                                     MAX_WIRELESS_EVENT_SIZE);\n    while (send) {\n        sent += send;\n        send = dbglog_get_debug_fragment(&buffer[sent], length - sent,\n                                         MAX_WIRELESS_EVENT_SIZE);\n    }\n#else\n    AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"Dropped logs: 0x%x\\nDebug info length: %d\\n\",\n                    dropped, length));\n\n    /* Interpret the debug logs */\n    dbglog_parse_debug_logs((s8 *)buffer, length);\n#endif /* REPORT_DEBUG_LOGS_TO_APP */\n}\n\n\nstatic int __init\nar6000_init_module(void)\n{\n    static int probed = 0;\n    int r;\n    OSDRV_CALLBACKS osdrvCallbacks;\n\n    a_module_debug_support_init();\n\n#ifdef DEBUG\n        /* check for debug mask overrides */\n    if (debughtc != 0) {\n        ATH_DEBUG_SET_DEBUG_MASK(htc,debughtc);\n    }\n    if (debugbmi != 0) {\n        ATH_DEBUG_SET_DEBUG_MASK(bmi,debugbmi);\n    }\n    if (debughif != 0) {\n        ATH_DEBUG_SET_DEBUG_MASK(hif,debughif);\n    }\n    if (debugdriver != 0) {\n        ATH_DEBUG_SET_DEBUG_MASK(driver,debugdriver);\n    }\n\n#endif\n\n    A_REGISTER_MODULE_DEBUG_INFO(driver);\n\n    A_MEMZERO(&osdrvCallbacks,sizeof(osdrvCallbacks));\n    osdrvCallbacks.deviceInsertedHandler = ar6000_avail_ev;\n    osdrvCallbacks.deviceRemovedHandler = ar6000_unavail_ev;\n#ifdef CONFIG_PM\n    osdrvCallbacks.deviceSuspendHandler = ar6000_suspend_ev;\n    osdrvCallbacks.deviceResumeHandler = ar6000_resume_ev;\n    osdrvCallbacks.devicePowerChangeHandler = ar6000_power_change_ev;\n#endif\n\n#ifdef DEBUG\n    /* Set the debug flags if specified at load time */\n    if(debugflags != 0)\n    {\n        g_dbg_flags = debugflags;\n    }\n#endif\n\n    if (probed) {\n        return -ENODEV;\n    }\n    probed++;\n\n#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL\n    memset(&aptcTR, 0, sizeof(APTC_TRAFFIC_RECORD));\n#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */\n\n    r = HIFInit(&osdrvCallbacks);\n    if (r)\n        return r;\n\n    return 0;\n}\n\nstatic void __exit\nar6000_cleanup_module(void)\n{\n    int i = 0;\n    struct net_device *ar6000_netdev;\n\n#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL\n    /* Delete the Adaptive Power Control timer */\n    if (timer_pending(&aptcTimer)) {\n        del_timer_sync(&aptcTimer);\n    }\n#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */\n\n    for (i=0; i < MAX_AR6000; i++) {\n        if (ar6000_devices[i] != NULL) {\n            ar6000_netdev = ar6000_devices[i];\n            ar6000_devices[i] = NULL;\n            ar6000_destroy(ar6000_netdev, 1);\n        }\n    }\n\n    HIFShutDownDevice(NULL);\n\n    a_module_debug_support_cleanup();\n\n    AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"ar6000_cleanup: success\\n\"));\n}\n\n#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL\nvoid\naptcTimerHandler(unsigned long arg)\n{\n    u32 numbytes;\n    u32 throughput;\n    struct ar6_softc *ar;\n    int status;\n\n    ar = (struct ar6_softc *)arg;\n    A_ASSERT(ar != NULL);\n    A_ASSERT(!timer_pending(&aptcTimer));\n\n    AR6000_SPIN_LOCK(&ar->arLock, 0);\n\n    /* Get the number of bytes transferred */\n    numbytes = aptcTR.bytesTransmitted + aptcTR.bytesReceived;\n    aptcTR.bytesTransmitted = aptcTR.bytesReceived = 0;\n\n    /* Calculate and decide based on throughput thresholds */\n    throughput = ((numbytes * 8)/APTC_TRAFFIC_SAMPLING_INTERVAL); /* Kbps */\n    if (throughput < APTC_LOWER_THROUGHPUT_THRESHOLD) {\n        /* Enable Sleep and delete the timer */\n        A_ASSERT(ar->arWmiReady == true);\n        AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n        status = wmi_powermode_cmd(ar->arWmi, REC_POWER);\n        AR6000_SPIN_LOCK(&ar->arLock, 0);\n        A_ASSERT(status == 0);\n        aptcTR.timerScheduled = false;\n    } else {\n        A_TIMEOUT_MS(&aptcTimer, APTC_TRAFFIC_SAMPLING_INTERVAL, 0);\n    }\n\n    AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n}\n#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */\n\nstatic void\nar6000_alloc_netbufs(A_NETBUF_QUEUE_T *q, u16 num)\n{\n    void * osbuf;\n\n    while(num) {\n        if((osbuf = A_NETBUF_ALLOC(AR6000_BUFFER_SIZE))) {\n            A_NETBUF_ENQUEUE(q, osbuf);\n        } else {\n            break;\n        }\n        num--;\n    }\n\n    if(num) {\n        A_PRINTF(\"%s(), allocation of netbuf failed\", __func__);\n    }\n}\n\nstatic struct bin_attribute bmi_attr = {\n    .attr = {.name = \"bmi\", .mode = 0600},\n    .read = ar6000_sysfs_bmi_read,\n    .write = ar6000_sysfs_bmi_write,\n};\n\nstatic ssize_t\nar6000_sysfs_bmi_read(struct file *fp, struct kobject *kobj,\n                      struct bin_attribute *bin_attr,\n                      char *buf, loff_t pos, size_t count)\n{\n    int index;\n    struct ar6_softc *ar;\n    struct hif_device_os_device_info   *osDevInfo;\n\n    AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"BMI: Read %d bytes\\n\", (u32)count));\n    for (index=0; index < MAX_AR6000; index++) {\n        ar = (struct ar6_softc *)ar6k_priv(ar6000_devices[index]);\n        osDevInfo = &ar->osDevInfo;\n        if (kobj == (&(((struct device *)osDevInfo->pOSDevice)->kobj))) {\n            break;\n        }\n    }\n\n    if (index == MAX_AR6000) return 0;\n\n    if ((BMIRawRead(ar->arHifDevice, (u8*)buf, count, true)) != 0) {\n        return 0;\n    }\n\n    return count;\n}\n\nstatic ssize_t\nar6000_sysfs_bmi_write(struct file *fp, struct kobject *kobj,\n                       struct bin_attribute *bin_attr,\n                       char *buf, loff_t pos, size_t count)\n{\n    int index;\n    struct ar6_softc *ar;\n    struct hif_device_os_device_info   *osDevInfo;\n\n    AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"BMI: Write %d bytes\\n\", (u32)count));\n    for (index=0; index < MAX_AR6000; index++) {\n        ar = (struct ar6_softc *)ar6k_priv(ar6000_devices[index]);\n        osDevInfo = &ar->osDevInfo;\n        if (kobj == (&(((struct device *)osDevInfo->pOSDevice)->kobj))) {\n            break;\n        }\n    }\n\n    if (index == MAX_AR6000) return 0;\n\n    if ((BMIRawWrite(ar->arHifDevice, (u8*)buf, count)) != 0) {\n        return 0;\n    }\n\n    return count;\n}\n\nstatic int\nar6000_sysfs_bmi_init(struct ar6_softc *ar)\n{\n    int status;\n\n    AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"BMI: Creating sysfs entry\\n\"));\n    A_MEMZERO(&ar->osDevInfo, sizeof(struct hif_device_os_device_info));\n\n    /* Get the underlying OS device */\n    status = HIFConfigureDevice(ar->arHifDevice,\n                                HIF_DEVICE_GET_OS_DEVICE,\n                                &ar->osDevInfo,\n                                sizeof(struct hif_device_os_device_info));\n\n    if (status) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"BMI: Failed to get OS device info from HIF\\n\"));\n        return A_ERROR;\n    }\n\n    /* Create a bmi entry in the sysfs filesystem */\n    if ((sysfs_create_bin_file(&(((struct device *)ar->osDevInfo.pOSDevice)->kobj), &bmi_attr)) < 0)\n    {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"BMI: Failed to create entry for bmi in sysfs filesystem\\n\"));\n        return A_ERROR;\n    }\n\n    return 0;\n}\n\nstatic void\nar6000_sysfs_bmi_deinit(struct ar6_softc *ar)\n{\n    AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"BMI: Deleting sysfs entry\\n\"));\n\n    sysfs_remove_bin_file(&(((struct device *)ar->osDevInfo.pOSDevice)->kobj), &bmi_attr);\n}\n\n#define bmifn(fn) do { \\\n    if ((fn) < 0) { \\\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"BMI operation failed: %d\\n\", __LINE__)); \\\n        return A_ERROR; \\\n    } \\\n} while(0)\n\n#ifdef SOFTMAC_FILE_USED\n#define AR6002_MAC_ADDRESS_OFFSET     0x0A\n#define AR6003_MAC_ADDRESS_OFFSET     0x16\nstatic\nvoid calculate_crc(u32 TargetType, u8 *eeprom_data)\n{\n    u16 *ptr_crc;\n    u16 *ptr16_eeprom;\n    u16 checksum;\n    u32 i;\n    u32 eeprom_size;\n\n    if (TargetType == TARGET_TYPE_AR6001)\n    {\n        eeprom_size = 512;\n        ptr_crc = (u16 *)eeprom_data;\n    }\n    else if (TargetType == TARGET_TYPE_AR6003)\n    {\n        eeprom_size = 1024;\n        ptr_crc = (u16 *)((u8 *)eeprom_data + 0x04);\n    }\n    else\n    {\n        eeprom_size = 768;\n        ptr_crc = (u16 *)((u8 *)eeprom_data + 0x04);\n    }\n\n\n    // Clear the crc\n    *ptr_crc = 0;\n\n    // Recalculate new CRC\n    checksum = 0;\n    ptr16_eeprom = (u16 *)eeprom_data;\n    for (i = 0;i < eeprom_size; i += 2)\n    {\n        checksum = checksum ^ (*ptr16_eeprom);\n        ptr16_eeprom++;\n    }\n    checksum = 0xFFFF ^ checksum;\n    *ptr_crc = checksum;\n}\n\nstatic void \nar6000_softmac_update(struct ar6_softc *ar, u8 *eeprom_data, size_t size)\n{\n    const char *source = \"random generated\";\n    const struct firmware *softmac_entry;\n    u8 *ptr_mac;\n    switch (ar->arTargetType) {\n    case TARGET_TYPE_AR6002:\n        ptr_mac = (u8 *)((u8 *)eeprom_data + AR6002_MAC_ADDRESS_OFFSET);\n        break;\n    case TARGET_TYPE_AR6003:\n        ptr_mac = (u8 *)((u8 *)eeprom_data + AR6003_MAC_ADDRESS_OFFSET);\n        break;\n    default:\n\tAR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"Invalid Target Type\\n\"));\n        return;\n    }\n\tprintk(KERN_DEBUG \"MAC from EEPROM %pM\\n\", ptr_mac);\n\n    /* create a random MAC in case we cannot read file from system */\n    ptr_mac[0] = 0;\n    ptr_mac[1] = 0x03;\n    ptr_mac[2] = 0x7F;\n    ptr_mac[3] = random32() & 0xff; \n    ptr_mac[4] = random32() & 0xff; \n    ptr_mac[5] = random32() & 0xff; \n    if ((A_REQUEST_FIRMWARE(&softmac_entry, \"softmac\", ((struct device *)ar->osDevInfo.pOSDevice))) == 0)\n    {\n        char *macbuf = A_MALLOC_NOWAIT(softmac_entry->size+1);\n        if (macbuf) {            \n            unsigned int softmac[6];\n            memcpy(macbuf, softmac_entry->data, softmac_entry->size);\n            macbuf[softmac_entry->size] = '\\0';\n            if (sscanf(macbuf, \"%02x:%02x:%02x:%02x:%02x:%02x\", \n                        &softmac[0], &softmac[1], &softmac[2],\n                        &softmac[3], &softmac[4], &softmac[5])==6) {\n                int i;\n                for (i=0; i<6; ++i) {\n                    ptr_mac[i] = softmac[i] & 0xff;\n                }\n                source = \"softmac file\";\n            }\n            kfree(macbuf);\n        }\n        A_RELEASE_FIRMWARE(softmac_entry);\n    }\n\tprintk(KERN_DEBUG \"MAC from %s %pM\\n\", source, ptr_mac);\n   calculate_crc(ar->arTargetType, eeprom_data);\n}\n#endif /* SOFTMAC_FILE_USED */\n\nstatic int\nar6000_transfer_bin_file(struct ar6_softc *ar, AR6K_BIN_FILE file, u32 address, bool compressed)\n{\n    int status;\n    const char *filename;\n    const struct firmware *fw_entry;\n    u32 fw_entry_size;\n\n    switch (file) {\n        case AR6K_OTP_FILE:\n            if (ar->arVersion.target_ver == AR6003_REV1_VERSION) {\n                filename = AR6003_REV1_OTP_FILE;\n            } else if (ar->arVersion.target_ver == AR6003_REV2_VERSION) {\n                filename = AR6003_REV2_OTP_FILE;\n                } else if (ar->arVersion.target_ver == AR6003_REV3_VERSION) {\n                        filename = AR6003_REV3_OTP_FILE;\n            } else {\n                AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"Unknown firmware revision: %d\\n\", ar->arVersion.target_ver));\n                return A_ERROR;\n            }\n            break;\n\n        case AR6K_FIRMWARE_FILE:\n            if (ar->arVersion.target_ver == AR6003_REV1_VERSION) {\n                filename = AR6003_REV1_FIRMWARE_FILE;\n            } else if (ar->arVersion.target_ver == AR6003_REV2_VERSION) {\n                filename = AR6003_REV2_FIRMWARE_FILE;\n                } else if (ar->arVersion.target_ver == AR6003_REV3_VERSION) {\n                        filename = AR6003_REV3_FIRMWARE_FILE;\n            } else {\n                AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"Unknown firmware revision: %d\\n\", ar->arVersion.target_ver));\n                return A_ERROR;\n            }\n            \n            if (eppingtest) {\n                bypasswmi = true;\n                if (ar->arVersion.target_ver == AR6003_REV1_VERSION) {\n                    filename = AR6003_REV1_EPPING_FIRMWARE_FILE;\n                } else if (ar->arVersion.target_ver == AR6003_REV2_VERSION) {\n                    filename = AR6003_REV2_EPPING_FIRMWARE_FILE;\n                } else if (ar->arVersion.target_ver == AR6003_REV3_VERSION) {\n                        filename = AR6003_REV3_EPPING_FIRMWARE_FILE;\n                } else {\n                    AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"eppingtest : unsupported firmware revision: %d\\n\", \n                        ar->arVersion.target_ver));\n                    return A_ERROR;\n                }\n                compressed = false;\n            }\n            \n#ifdef CONFIG_HOST_TCMD_SUPPORT\n            if(testmode) {\n                if (ar->arVersion.target_ver == AR6003_REV1_VERSION) {\n                    filename = AR6003_REV1_TCMD_FIRMWARE_FILE;\n                } else if (ar->arVersion.target_ver == AR6003_REV2_VERSION) {\n                    filename = AR6003_REV2_TCMD_FIRMWARE_FILE;\n                } else if (ar->arVersion.target_ver == AR6003_REV3_VERSION) {\n                        filename = AR6003_REV3_TCMD_FIRMWARE_FILE;\n                } else {\n                    AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"Unknown firmware revision: %d\\n\", ar->arVersion.target_ver));\n                    return A_ERROR;\n                }\n                compressed = false;\n            }\n#endif \n#ifdef HTC_RAW_INTERFACE\n            if (!eppingtest && bypasswmi) {\n                if (ar->arVersion.target_ver == AR6003_REV1_VERSION) {\n                    filename = AR6003_REV1_ART_FIRMWARE_FILE;\n                } else if (ar->arVersion.target_ver == AR6003_REV2_VERSION) {\n                    filename = AR6003_REV2_ART_FIRMWARE_FILE;\n                } else {\n                    AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"Unknown firmware revision: %d\\n\", ar->arVersion.target_ver));\n                    return A_ERROR;\n                }\n                compressed = false;\n            }\n#endif \n            break;\n\n        case AR6K_PATCH_FILE:\n            if (ar->arVersion.target_ver == AR6003_REV1_VERSION) {\n                filename = AR6003_REV1_PATCH_FILE;\n            } else if (ar->arVersion.target_ver == AR6003_REV2_VERSION) {\n                filename = AR6003_REV2_PATCH_FILE;\n                } else if (ar->arVersion.target_ver == AR6003_REV3_VERSION) {\n                        filename = AR6003_REV3_PATCH_FILE;\n            } else {\n                AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"Unknown firmware revision: %d\\n\", ar->arVersion.target_ver));\n                return A_ERROR;\n            }\n            break;\n\n        case AR6K_BOARD_DATA_FILE:\n            if (ar->arVersion.target_ver == AR6003_REV1_VERSION) {\n                filename = AR6003_REV1_BOARD_DATA_FILE;\n            } else if (ar->arVersion.target_ver == AR6003_REV2_VERSION) {\n                filename = AR6003_REV2_BOARD_DATA_FILE;\n                } else if (ar->arVersion.target_ver == AR6003_REV3_VERSION) {\n                        filename = AR6003_REV3_BOARD_DATA_FILE;\n            } else {\n                AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"Unknown firmware revision: %d\\n\", ar->arVersion.target_ver));\n                return A_ERROR;\n            }\n            break;\n\n        default:\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"Unknown file type: %d\\n\", file));\n            return A_ERROR;\n    }\n    if ((A_REQUEST_FIRMWARE(&fw_entry, filename, ((struct device *)ar->osDevInfo.pOSDevice))) != 0)\n    {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"Failed to get %s\\n\", filename));\n        return A_ENOENT;\n    }\n\n#ifdef SOFTMAC_FILE_USED\n    if (file==AR6K_BOARD_DATA_FILE && fw_entry->data) {\n        ar6000_softmac_update(ar, (u8 *)fw_entry->data, fw_entry->size);\n    }\n#endif \n\n\n    fw_entry_size = fw_entry->size;\n\n    /* Load extended board data for AR6003 */\n    if ((file==AR6K_BOARD_DATA_FILE) && (fw_entry->data)) {\n        u32 board_ext_address;\n        u32 board_ext_data_size;\n        u32 board_data_size;\n\n        board_ext_data_size = (((ar)->arTargetType == TARGET_TYPE_AR6002) ? AR6002_BOARD_EXT_DATA_SZ : \\\n                               (((ar)->arTargetType == TARGET_TYPE_AR6003) ? AR6003_BOARD_EXT_DATA_SZ : 0));\n\n        board_data_size = (((ar)->arTargetType == TARGET_TYPE_AR6002) ? AR6002_BOARD_DATA_SZ : \\\n                          (((ar)->arTargetType == TARGET_TYPE_AR6003) ? AR6003_BOARD_DATA_SZ : 0));\n        \n        /* Determine where in Target RAM to write Board Data */\n        bmifn(BMIReadMemory(ar->arHifDevice, HOST_INTEREST_ITEM_ADDRESS(ar, hi_board_ext_data), (u8 *)&board_ext_address, 4));\n        AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\"Board extended Data download address: 0x%x\\n\", board_ext_address));\n\n        /* check whether the target has allocated memory for extended board data and file contains extended board data */\n        if ((board_ext_address) && (fw_entry->size == (board_data_size + board_ext_data_size))) {\n            u32 param;\n\n            status = BMIWriteMemory(ar->arHifDevice, board_ext_address, (u8 *)(fw_entry->data + board_data_size), board_ext_data_size);\n\n            if (status) {\n                AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"BMI operation failed: %d\\n\", __LINE__));\n                A_RELEASE_FIRMWARE(fw_entry);\n                return A_ERROR;\n            }\n\n            /* Record the fact that extended board Data IS initialized */\n            param = (board_ext_data_size << 16) | 1;\n            bmifn(BMIWriteMemory(ar->arHifDevice,\n            HOST_INTEREST_ITEM_ADDRESS(ar, hi_board_ext_data_config),\n\t\t\t\t       (unsigned char *)&param, 4));\n        }\n        fw_entry_size = board_data_size;\n    }\n\n    if (compressed) {\n        status = BMIFastDownload(ar->arHifDevice, address, (u8 *)fw_entry->data, fw_entry_size);\n    } else {\n        status = BMIWriteMemory(ar->arHifDevice, address, (u8 *)fw_entry->data, fw_entry_size);\n    }\n\n    if (status) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"BMI operation failed: %d\\n\", __LINE__));\n        A_RELEASE_FIRMWARE(fw_entry);\n        return A_ERROR;\n    }\n    A_RELEASE_FIRMWARE(fw_entry);\n    return 0;\n}\n\nint\nar6000_update_bdaddr(struct ar6_softc *ar)\n{\n\n        if (setupbtdev != 0) {\n            u32 address;\n\n           if (BMIReadMemory(ar->arHifDevice,\n\t\tHOST_INTEREST_ITEM_ADDRESS(ar, hi_board_data), (u8 *)&address, 4) != 0)\n           {\n    \t      \tAR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"BMIReadMemory for hi_board_data failed\\n\"));\n           \treturn A_ERROR;\n           }\n\n           if (BMIReadMemory(ar->arHifDevice, address + BDATA_BDADDR_OFFSET, (u8 *)ar->bdaddr, 6) != 0)\n           {\n    \t    \tAR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"BMIReadMemory for BD address failed\\n\"));\n           \treturn A_ERROR;\n           }\n\t   AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"BDADDR 0x%x:0x%x:0x%x:0x%x:0x%x:0x%x\\n\", ar->bdaddr[0],\n\t\t\t\t\t\t\t\tar->bdaddr[1], ar->bdaddr[2], ar->bdaddr[3],\n\t\t\t\t\t\t\t\tar->bdaddr[4], ar->bdaddr[5]));\n        }\n\nreturn 0;\n}\n\nint\nar6000_sysfs_bmi_get_config(struct ar6_softc *ar, u32 mode)\n{\n    AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"BMI: Requesting device specific configuration\\n\"));\n\n    if (mode == WLAN_INIT_MODE_UDEV) {\n        char version[16];\n        const struct firmware *fw_entry;\n\n        /* Get config using udev through a script in user space */\n        sprintf(version, \"%2.2x\", ar->arVersion.target_ver);\n        if ((A_REQUEST_FIRMWARE(&fw_entry, version, ((struct device *)ar->osDevInfo.pOSDevice))) != 0)\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"BMI: Failure to get configuration for target version: %s\\n\", version));\n            return A_ERROR;\n        }\n\n        A_RELEASE_FIRMWARE(fw_entry);\n    } else {\n        /* The config is contained within the driver itself */\n        int status;\n        u32 param, options, sleep, address;\n\n        /* Temporarily disable system sleep */\n        address = MBOX_BASE_ADDRESS + LOCAL_SCRATCH_ADDRESS;\n        bmifn(BMIReadSOCRegister(ar->arHifDevice, address, &param));\n        options = param;\n        param |= AR6K_OPTION_SLEEP_DISABLE;\n        bmifn(BMIWriteSOCRegister(ar->arHifDevice, address, param));\n\n        address = RTC_BASE_ADDRESS + SYSTEM_SLEEP_ADDRESS;\n        bmifn(BMIReadSOCRegister(ar->arHifDevice, address, &param));\n        sleep = param;\n        param |= WLAN_SYSTEM_SLEEP_DISABLE_SET(1);\n        bmifn(BMIWriteSOCRegister(ar->arHifDevice, address, param));\n        AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\"old options: %d, old sleep: %d\\n\", options, sleep));\n\n        if (ar->arTargetType == TARGET_TYPE_AR6003) {\n            /* Program analog PLL register */\n            bmifn(BMIWriteSOCRegister(ar->arHifDevice, ANALOG_INTF_BASE_ADDRESS + 0x284, 0xF9104001));\n            /* Run at 80/88MHz by default */\n            param = CPU_CLOCK_STANDARD_SET(1);\n        } else {\n            /* Run at 40/44MHz by default */\n            param = CPU_CLOCK_STANDARD_SET(0);\n        }\n        address = RTC_BASE_ADDRESS + CPU_CLOCK_ADDRESS;\n        bmifn(BMIWriteSOCRegister(ar->arHifDevice, address, param));\n\n        param = 0;\n        if (ar->arTargetType == TARGET_TYPE_AR6002) {\n            bmifn(BMIReadMemory(ar->arHifDevice, HOST_INTEREST_ITEM_ADDRESS(ar, hi_ext_clk_detected), (u8 *)&param, 4));\n        }\n\n        /* LPO_CAL.ENABLE = 1 if no external clk is detected */\n        if (param != 1) {\n            address = RTC_BASE_ADDRESS + LPO_CAL_ADDRESS;\n            param = LPO_CAL_ENABLE_SET(1);\n            bmifn(BMIWriteSOCRegister(ar->arHifDevice, address, param));\n        }\n\n        /* Venus2.0: Lower SDIO pad drive strength,\n         * temporary WAR to avoid SDIO CRC error */\n        if (ar->arVersion.target_ver == AR6003_REV2_VERSION) {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"AR6K: Temporary WAR to avoid SDIO CRC error\\n\"));\n            param = 0x20;\n            address = GPIO_BASE_ADDRESS + GPIO_PIN10_ADDRESS;\n            bmifn(BMIWriteSOCRegister(ar->arHifDevice, address, param));\n\n            address = GPIO_BASE_ADDRESS + GPIO_PIN11_ADDRESS;\n            bmifn(BMIWriteSOCRegister(ar->arHifDevice, address, param));\n\n            address = GPIO_BASE_ADDRESS + GPIO_PIN12_ADDRESS;\n            bmifn(BMIWriteSOCRegister(ar->arHifDevice, address, param));\n\n            address = GPIO_BASE_ADDRESS + GPIO_PIN13_ADDRESS;\n            bmifn(BMIWriteSOCRegister(ar->arHifDevice, address, param));\n        }\n\n#ifdef FORCE_INTERNAL_CLOCK\n        /* Ignore external clock, if any, and force use of internal clock */\n        if (ar->arTargetType == TARGET_TYPE_AR6003) {\n            /* hi_ext_clk_detected = 0 */\n            param = 0;\n            bmifn(BMIWriteMemory(ar->arHifDevice, HOST_INTEREST_ITEM_ADDRESS(ar, hi_ext_clk_detected), (u8 *)&param, 4));\n\n            /* CLOCK_CONTROL &= ~LF_CLK32 */\n            address = RTC_BASE_ADDRESS + CLOCK_CONTROL_ADDRESS;\n            bmifn(BMIReadSOCRegister(ar->arHifDevice, address, &param));\n            param &= (~CLOCK_CONTROL_LF_CLK32_SET(1));\n            bmifn(BMIWriteSOCRegister(ar->arHifDevice, address, param));\n        }\n#endif /* FORCE_INTERNAL_CLOCK */\n\n        /* Transfer Board Data from Target EEPROM to Target RAM */\n        if (ar->arTargetType == TARGET_TYPE_AR6003) {\n            /* Determine where in Target RAM to write Board Data */\n            bmifn(BMIReadMemory(ar->arHifDevice, HOST_INTEREST_ITEM_ADDRESS(ar, hi_board_data), (u8 *)&address, 4));\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\"Board Data download address: 0x%x\\n\", address));\n\n            /* Write EEPROM data to Target RAM */\n            if ((ar6000_transfer_bin_file(ar, AR6K_BOARD_DATA_FILE, address, false)) != 0) {\n                return A_ERROR;\n            }\n\n            /* Record the fact that Board Data IS initialized */\n            param = 1;\n            bmifn(BMIWriteMemory(ar->arHifDevice, HOST_INTEREST_ITEM_ADDRESS(ar, hi_board_data_initialized), (u8 *)&param, 4));\n\n            /* Transfer One time Programmable data */\n\t    AR6K_APP_LOAD_ADDRESS(address, ar->arVersion.target_ver);\n\t    if (ar->arVersion.target_ver == AR6003_REV3_VERSION)\n\t\t  address = 0x1234;\n            status = ar6000_transfer_bin_file(ar, AR6K_OTP_FILE, address, true);\n            if (status == 0) {\n                /* Execute the OTP code */\n                param = 0;\n                AR6K_APP_START_OVERRIDE_ADDRESS(address, ar->arVersion.target_ver);\n                bmifn(BMIExecute(ar->arHifDevice, address, &param));\n            } else if (status != A_ENOENT) {\n                return A_ERROR;\n            } \n        } else {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"Programming of board data for chip %d not supported\\n\", ar->arTargetType));\n            return A_ERROR;\n        }\n\n        /* Download Target firmware */\n        AR6K_APP_LOAD_ADDRESS(address, ar->arVersion.target_ver);\n        if (ar->arVersion.target_ver == AR6003_REV3_VERSION)\n                address = 0x1234;\n        if ((ar6000_transfer_bin_file(ar, AR6K_FIRMWARE_FILE, address, true)) != 0) {\n            return A_ERROR;\n        }\n\n        /* Set starting address for firmware */\n        AR6K_APP_START_OVERRIDE_ADDRESS(address, ar->arVersion.target_ver);\n        bmifn(BMISetAppStart(ar->arHifDevice, address));\n\n\tif(ar->arTargetType == TARGET_TYPE_AR6003) {\n\t\tAR6K_DATASET_PATCH_ADDRESS(address, ar->arVersion.target_ver);\n\t\tif ((ar6000_transfer_bin_file(ar, AR6K_PATCH_FILE,\n\t\t\t\t\t      address, false)) != 0)\n\t\t\treturn A_ERROR;\n\t\tparam = address;\n\t\tbmifn(BMIWriteMemory(ar->arHifDevice,\n\t\tHOST_INTEREST_ITEM_ADDRESS(ar, hi_dset_list_head),\n\t\t\t\t\t   (unsigned char *)&param, 4));\n\t}\n\n        /* Restore system sleep */\n        address = RTC_BASE_ADDRESS + SYSTEM_SLEEP_ADDRESS;\n        bmifn(BMIWriteSOCRegister(ar->arHifDevice, address, sleep));\n\n        address = MBOX_BASE_ADDRESS + LOCAL_SCRATCH_ADDRESS;\n        param = options | 0x20;\n        bmifn(BMIWriteSOCRegister(ar->arHifDevice, address, param));\n\n        if (ar->arTargetType == TARGET_TYPE_AR6003) {\n            /* Configure GPIO AR6003 UART */\n#ifndef CONFIG_AR600x_DEBUG_UART_TX_PIN\n#define CONFIG_AR600x_DEBUG_UART_TX_PIN 8\n#endif\n            param = CONFIG_AR600x_DEBUG_UART_TX_PIN;\n            bmifn(BMIWriteMemory(ar->arHifDevice, HOST_INTEREST_ITEM_ADDRESS(ar, hi_dbg_uart_txpin), (u8 *)&param, 4));\n\n#if (CONFIG_AR600x_DEBUG_UART_TX_PIN == 23)\n            {\n                address = GPIO_BASE_ADDRESS + CLOCK_GPIO_ADDRESS;\n                bmifn(BMIReadSOCRegister(ar->arHifDevice, address, &param));\n                param |= CLOCK_GPIO_BT_CLK_OUT_EN_SET(1);\n                bmifn(BMIWriteSOCRegister(ar->arHifDevice, address, param));\n            }\n#endif\n\n            /* Configure GPIO for BT Reset */\n#ifdef ATH6KL_CONFIG_GPIO_BT_RESET\n#define CONFIG_AR600x_BT_RESET_PIN\t0x16\n            param = CONFIG_AR600x_BT_RESET_PIN;\n            bmifn(BMIWriteMemory(ar->arHifDevice, HOST_INTEREST_ITEM_ADDRESS(ar, hi_hci_uart_support_pins), (u8 *)&param, 4));\n#endif /* ATH6KL_CONFIG_GPIO_BT_RESET */\n\n            /* Configure UART flow control polarity */\n#ifndef CONFIG_ATH6KL_BT_UART_FC_POLARITY\n#define CONFIG_ATH6KL_BT_UART_FC_POLARITY 0\n#endif\n\n#if (CONFIG_ATH6KL_BT_UART_FC_POLARITY == 1)\n            if (ar->arVersion.target_ver == AR6003_REV2_VERSION) {\n                param = ((CONFIG_ATH6KL_BT_UART_FC_POLARITY << 1) & 0x2);\n                bmifn(BMIWriteMemory(ar->arHifDevice, HOST_INTEREST_ITEM_ADDRESS(ar, hi_hci_uart_pwr_mgmt_params), (u8 *)&param, 4));\n            }\n#endif /* CONFIG_ATH6KL_BT_UART_FC_POLARITY */\n        }\n\n#ifdef HTC_RAW_INTERFACE\n        if (!eppingtest && bypasswmi) {\n            /* Don't run BMIDone for ART mode and force resetok=0 */\n            resetok = 0;\n            msleep(1000);\n        }\n#endif /* HTC_RAW_INTERFACE */\n    }\n\n    return 0;\n}\n\nint\nar6000_configure_target(struct ar6_softc *ar)\n{\n    u32 param;\n    if (enableuartprint) {\n        param = 1;\n        if (BMIWriteMemory(ar->arHifDevice,\n                           HOST_INTEREST_ITEM_ADDRESS(ar, hi_serial_enable),\n                           (u8 *)&param,\n                           4)!= 0)\n        {\n             AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"BMIWriteMemory for enableuartprint failed \\n\"));\n             return A_ERROR;\n        }\n        AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"Serial console prints enabled\\n\"));\n    }\n\n    /* Tell target which HTC version it is used*/\n    param = HTC_PROTOCOL_VERSION;\n    if (BMIWriteMemory(ar->arHifDevice,\n                       HOST_INTEREST_ITEM_ADDRESS(ar, hi_app_host_interest),\n                       (u8 *)&param,\n                       4)!= 0)\n    {\n         AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"BMIWriteMemory for htc version failed \\n\"));\n         return A_ERROR;\n    }\n\n#ifdef CONFIG_HOST_TCMD_SUPPORT\n    if(testmode) {\n        ar->arTargetMode = AR6000_TCMD_MODE;\n    }else {\n        ar->arTargetMode = AR6000_WLAN_MODE;\n    }\n#endif\n    if (enabletimerwar) {\n        u32 param;\n\n        if (BMIReadMemory(ar->arHifDevice,\n            HOST_INTEREST_ITEM_ADDRESS(ar, hi_option_flag),\n            (u8 *)&param,\n            4)!= 0)\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"BMIReadMemory for enabletimerwar failed \\n\"));\n            return A_ERROR;\n        }\n\n        param |= HI_OPTION_TIMER_WAR;\n\n        if (BMIWriteMemory(ar->arHifDevice,\n            HOST_INTEREST_ITEM_ADDRESS(ar, hi_option_flag),\n            (u8 *)&param,\n            4) != 0)\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"BMIWriteMemory for enabletimerwar failed \\n\"));\n            return A_ERROR;\n        }\n        AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"Timer WAR enabled\\n\"));\n    }\n\n    /* set the firmware mode to STA/IBSS/AP */\n    {\n        u32 param;\n\n        if (BMIReadMemory(ar->arHifDevice,\n            HOST_INTEREST_ITEM_ADDRESS(ar, hi_option_flag),\n            (u8 *)&param,\n            4)!= 0)\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"BMIReadMemory for setting fwmode failed \\n\"));\n            return A_ERROR;\n        }\n\n        param |= (num_device << HI_OPTION_NUM_DEV_SHIFT);\n        param |= (fwmode << HI_OPTION_FW_MODE_SHIFT);\n        param |= (mac_addr_method << HI_OPTION_MAC_ADDR_METHOD_SHIFT);\n        param |= (firmware_bridge << HI_OPTION_FW_BRIDGE_SHIFT);\n\n\n        if (BMIWriteMemory(ar->arHifDevice,\n            HOST_INTEREST_ITEM_ADDRESS(ar, hi_option_flag),\n            (u8 *)&param,\n            4) != 0)\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"BMIWriteMemory for setting fwmode failed \\n\"));\n            return A_ERROR;\n        }\n        AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"Firmware mode set\\n\"));\n    }\n\n#ifdef ATH6KL_DISABLE_TARGET_DBGLOGS\n    {\n        u32 param;\n\n        if (BMIReadMemory(ar->arHifDevice,\n            HOST_INTEREST_ITEM_ADDRESS(ar, hi_option_flag),\n            (u8 *)&param,\n            4)!= 0)\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"BMIReadMemory for disabling debug logs failed\\n\"));\n            return A_ERROR;\n        }\n\n        param |= HI_OPTION_DISABLE_DBGLOG;\n\n        if (BMIWriteMemory(ar->arHifDevice,\n            HOST_INTEREST_ITEM_ADDRESS(ar, hi_option_flag),\n            (u8 *)&param,\n            4) != 0)\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"BMIWriteMemory for HI_OPTION_DISABLE_DBGLOG\\n\"));\n            return A_ERROR;\n        }\n        AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"Firmware mode set\\n\"));\n    }\n#endif /* ATH6KL_DISABLE_TARGET_DBGLOGS */\n\n    /* \n     * Hardcode the address use for the extended board data \n     * Ideally this should be pre-allocate by the OS at boot time\n     * But since it is a new feature and board data is loaded \n     * at init time, we have to workaround this from host.\n     * It is difficult to patch the firmware boot code,\n     * but possible in theory.\n     */\n\n\tif (ar->arTargetType == TARGET_TYPE_AR6003) {\n\t\tu32 ramReservedSz;\n\t\tif (ar->arVersion.target_ver == AR6003_REV2_VERSION) {\n\t\t\tparam = AR6003_REV2_BOARD_EXT_DATA_ADDRESS;\n\t\t\tramReservedSz =  AR6003_REV2_RAM_RESERVE_SIZE;\n                } else {\n\t\t\tparam = AR6003_REV3_BOARD_EXT_DATA_ADDRESS;\n\t\t\tramReservedSz =  AR6003_REV3_RAM_RESERVE_SIZE;\n\t\t}\n\t\tif (BMIWriteMemory(ar->arHifDevice,\n\t\t\tHOST_INTEREST_ITEM_ADDRESS(ar, hi_board_ext_data),\n\t\t\t\t\t\t   (u8 *)&param, 4) != 0) {\n\t\t\t\tAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\n\t\t\t\t\t\t(\"BMIWriteMemory for \"\n\t\t\t\t\t\t \"hi_board_ext_data failed\\n\"));\n\t\t\t\treturn A_ERROR;\n\t\t}\n\t\tif (BMIWriteMemory(ar->arHifDevice,\n\t\t\t\t   HOST_INTEREST_ITEM_ADDRESS(ar,\n\t\t\t\t   hi_end_RAM_reserve_sz),\n\t\t\t\t   (u8 *)&ramReservedSz, 4) != 0) {\n\t\t\tAR_DEBUG_PRINTF(ATH_DEBUG_ERR ,\n\t\t\t\t\t(\"BMIWriteMemory for \"\n\t\t\t\t\t \"hi_end_RAM_reserve_sz failed\\n\"));\n\t\t\treturn A_ERROR;\n\t\t}\n\t}\n\n        /* since BMIInit is called in the driver layer, we have to set the block\n         * size here for the target */\n\n    if (ar6000_set_htc_params(ar->arHifDevice, ar->arTargetType,\n\t\t\t      mbox_yield_limit, 0)) {\n\t\t\t\t/* use default number of control buffers */\n        return A_ERROR;\n    }\n\n    if (setupbtdev != 0) {\n        if (ar6000_set_hci_bridge_flags(ar->arHifDevice,\n\t\t\t\t\tar->arTargetType,\n\t\t\t\t\tsetupbtdev)) {\n            return A_ERROR;\n        }\n    }\n    return 0;\n}\n\nstatic void\ninit_netdev(struct net_device *dev, char *name)\n{\n    dev->netdev_ops = &ar6000_netdev_ops;\n    dev->watchdog_timeo = AR6000_TX_TIMEOUT;\n\n   /*\n    * We need the OS to provide us with more headroom in order to\n    * perform dix to 802.3, WMI header encap, and the HTC header\n    */\n    if (processDot11Hdr) {\n        dev->hard_header_len = sizeof(struct ieee80211_qosframe) + sizeof(ATH_LLC_SNAP_HDR) + sizeof(WMI_DATA_HDR) + HTC_HEADER_LEN + WMI_MAX_TX_META_SZ + LINUX_HACK_FUDGE_FACTOR;\n    } else {\n        dev->hard_header_len = ETH_HLEN + sizeof(ATH_LLC_SNAP_HDR) +\n            sizeof(WMI_DATA_HDR) + HTC_HEADER_LEN + WMI_MAX_TX_META_SZ + LINUX_HACK_FUDGE_FACTOR;\n    }\n\n    if (name[0])\n    {\n        strcpy(dev->name, name);\n    }\n\n#ifdef CONFIG_CHECKSUM_OFFLOAD\n    if(csumOffload){\n        dev->features |= NETIF_F_IP_CSUM; /*advertise kernel capability to do TCP/UDP CSUM offload for IPV4*/\n    }\n#endif\n\n    return;\n}\n\nstatic int __ath6kl_init_netdev(struct net_device *dev)\n{\n\tint r;\n\n\trtnl_lock();\n\tr = ar6000_init(dev);\n\trtnl_unlock();\n\n\tif (r) {\n\t\tAR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_avail: ar6000_init\\n\"));\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n\n#ifdef HTC_RAW_INTERFACE\nstatic int ath6kl_init_netdev_wmi(struct net_device *dev)\n{\n\tif (!eppingtest && bypasswmi)\n\t\treturn 0;\n\n\treturn __ath6kl_init_netdev(dev);\n}\n#else\nstatic int ath6kl_init_netdev_wmi(struct net_device *dev)\n{\n\treturn __ath6kl_init_netdev(dev);\n}\n#endif\n\nstatic int ath6kl_init_netdev(struct ar6_softc *ar)\n{\n\tint r;\n\n        r = ar6000_sysfs_bmi_get_config(ar, wlaninitmode);\n        if (r) {\n\t\tAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\n\t\t\t\t(\"ar6000_avail: \"\n\t\t\t\t \"ar6000_sysfs_bmi_get_config failed\\n\"));\n\t\treturn r;\n        }\n\n\treturn ath6kl_init_netdev_wmi(ar->arNetDev);\n}\n\n/*\n * HTC Event handlers\n */\nstatic int\nar6000_avail_ev(void *context, void *hif_handle)\n{\n    int i;\n    struct net_device *dev;\n    void *ar_netif;\n    struct ar6_softc *ar;\n    int device_index = 0;\n    struct htc_init_info  htcInfo;\n    struct wireless_dev *wdev;\n    int r = 0;\n    struct hif_device_os_device_info osDevInfo;\n\n    memset(&osDevInfo, 0, sizeof(osDevInfo));\n    if (HIFConfigureDevice(hif_handle, HIF_DEVICE_GET_OS_DEVICE,\n        &osDevInfo, sizeof(osDevInfo))) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"%s: Failed to get OS device instance\\n\", __func__));\n        return A_ERROR;\n    }\n\n    AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"ar6000_available\\n\"));\n\n    for (i=0; i < MAX_AR6000; i++) {\n        if (ar6000_devices[i] == NULL) {\n            break;\n        }\n    }\n\n    if (i == MAX_AR6000) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_available: max devices reached\\n\"));\n        return A_ERROR;\n    }\n\n    /* Save this. It gives a bit better readability especially since */\n    /* we use another local \"i\" variable below.                      */\n    device_index = i;\n\n    wdev = ar6k_cfg80211_init(osDevInfo.pOSDevice);\n    if (IS_ERR(wdev)) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"%s: ar6k_cfg80211_init failed\\n\", __func__));\n        return A_ERROR;\n    }\n    ar_netif = wdev_priv(wdev);\n\n    if (ar_netif == NULL) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR, (\"%s: Can't allocate ar6k priv memory\\n\", __func__));\n        return A_ERROR;\n    }\n\n    A_MEMZERO(ar_netif, sizeof(struct ar6_softc));\n    ar = (struct ar6_softc *)ar_netif;\n\n    ar->wdev = wdev;\n    wdev->iftype = NL80211_IFTYPE_STATION;\n\n    dev = alloc_netdev_mq(0, \"wlan%d\", ether_setup, 1);\n    if (!dev) {\n        printk(KERN_CRIT \"AR6K: no memory for network device instance\\n\");\n        ar6k_cfg80211_deinit(ar);\n        return A_ERROR;\n    }\n\n    dev->ieee80211_ptr = wdev;\n    SET_NETDEV_DEV(dev, wiphy_dev(wdev->wiphy));\n    wdev->netdev = dev;\n    ar->arNetworkType = INFRA_NETWORK;\n    ar->smeState = SME_DISCONNECTED;\n    ar->arAutoAuthStage = AUTH_IDLE;\n\n    init_netdev(dev, ifname);\n\n\n    ar->arNetDev             = dev;\n    ar->arHifDevice          = hif_handle;\n    ar->arWlanState          = WLAN_ENABLED;\n    ar->arDeviceIndex        = device_index;\n\n    ar->arWlanPowerState     = WLAN_POWER_STATE_ON;\n    ar->arWlanOff            = false;   /* We are in ON state */\n#ifdef CONFIG_PM\n    ar->arWowState           = WLAN_WOW_STATE_NONE;\n    ar->arBTOff              = true;   /* BT chip assumed to be OFF */\n    ar->arBTSharing          = WLAN_CONFIG_BT_SHARING; \n    ar->arWlanOffConfig      = WLAN_CONFIG_WLAN_OFF;\n    ar->arSuspendConfig      = WLAN_CONFIG_PM_SUSPEND;\n    ar->arWow2Config         = WLAN_CONFIG_PM_WOW2;\n#endif /* CONFIG_PM */\n\n    A_INIT_TIMER(&ar->arHBChallengeResp.timer, ar6000_detect_error, dev);\n    ar->arHBChallengeResp.seqNum = 0;\n    ar->arHBChallengeResp.outstanding = false;\n    ar->arHBChallengeResp.missCnt = 0;\n    ar->arHBChallengeResp.frequency = AR6000_HB_CHALLENGE_RESP_FREQ_DEFAULT;\n    ar->arHBChallengeResp.missThres = AR6000_HB_CHALLENGE_RESP_MISS_THRES_DEFAULT;\n\n    ar6000_init_control_info(ar);\n    init_waitqueue_head(&arEvent);\n    sema_init(&ar->arSem, 1);\n    ar->bIsDestroyProgress = false;\n\n    INIT_HTC_PACKET_QUEUE(&ar->amsdu_rx_buffer_queue);\n\n#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL\n    A_INIT_TIMER(&aptcTimer, aptcTimerHandler, ar);\n#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */\n\n    A_INIT_TIMER(&ar->disconnect_timer, disconnect_timer_handler, dev);\n\n    BMIInit();\n\n    ar6000_sysfs_bmi_init(ar);\n\n    {\n        struct bmi_target_info targ_info;\n\n        r = BMIGetTargetInfo(ar->arHifDevice, &targ_info);\n        if (r)\n            goto avail_ev_failed;\n\n        ar->arVersion.target_ver = targ_info.target_ver;\n        ar->arTargetType = targ_info.target_type;\n\twdev->wiphy->hw_version = targ_info.target_ver;\n    }\n\n    r = ar6000_configure_target(ar);\n    if (r)\n            goto avail_ev_failed;\n\n    A_MEMZERO(&htcInfo,sizeof(htcInfo));\n    htcInfo.pContext = ar;\n    htcInfo.TargetFailure = ar6000_target_failure;\n\n    ar->arHtcTarget = HTCCreate(ar->arHifDevice,&htcInfo);\n\n    if (!ar->arHtcTarget) {\n        r = -ENOMEM;\n        goto avail_ev_failed;\n    }\n\n    spin_lock_init(&ar->arLock);\n\n#ifdef WAPI_ENABLE\n    ar->arWapiEnable = 0;\n#endif\n\n\n    if(csumOffload){\n        /*if external frame work is also needed, change and use an extended rxMetaVerion*/\n        ar->rxMetaVersion=WMI_META_VERSION_2;\n    }\n\n    ar->aggr_cntxt = aggr_init(ar6000_alloc_netbufs);\n    if (!ar->aggr_cntxt) {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"%s() Failed to initialize aggr.\\n\", __func__));\n            r = -ENOMEM;\n            goto avail_ev_failed;\n    }\n\n    aggr_register_rx_dispatcher(ar->aggr_cntxt, (void *)dev, ar6000_deliver_frames_to_nw_stack);\n\n    HIFClaimDevice(ar->arHifDevice, ar);\n\n    /* We only register the device in the global list if we succeed. */\n    /* If the device is in the global list, it will be destroyed     */\n    /* when the module is unloaded.                                  */\n    ar6000_devices[device_index] = dev;\n\n    AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\"BMI enabled: %d\\n\", wlaninitmode));\n    if ((wlaninitmode == WLAN_INIT_MODE_UDEV) ||\n        (wlaninitmode == WLAN_INIT_MODE_DRV)) {\n\tr = ath6kl_init_netdev(ar);\n\tif (r)\n            goto avail_ev_failed;\n    }\n\n    /* This runs the init function if registered */\n    r = register_netdev(dev);\n    if (r) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_avail: register_netdev failed\\n\"));\n        ar6000_destroy(dev, 0);\n        return r;\n    }\n\n\tis_netdev_registered = 1;\n\n#ifdef CONFIG_AP_VIRTUAL_ADAPTER_SUPPORT\n    arApNetDev = NULL;\n#endif /* CONFIG_AP_VIRTUAL_ADAPTER_SUPPORT */\n    AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"ar6000_avail: name=%s hifdevice=0x%lx, dev=0x%lx (%d), ar=0x%lx\\n\",\n                    dev->name, (unsigned long)ar->arHifDevice, (unsigned long)dev, device_index,\n                    (unsigned long)ar));\n\navail_ev_failed :\n    if (r)\n        ar6000_sysfs_bmi_deinit(ar);  \n\n    return r;\n}\n\nstatic void ar6000_target_failure(void *Instance, int Status)\n{\n    struct ar6_softc *ar = (struct ar6_softc *)Instance;\n    WMI_TARGET_ERROR_REPORT_EVENT errEvent;\n    static bool sip = false;\n\n    if (Status != 0) {\n\n        printk(KERN_ERR \"ar6000_target_failure: target asserted \\n\");\n\n        if (timer_pending(&ar->arHBChallengeResp.timer)) {\n            A_UNTIMEOUT(&ar->arHBChallengeResp.timer);\n        }\n\n        /* try dumping target assertion information (if any) */\n        ar6000_dump_target_assert_info(ar->arHifDevice,ar->arTargetType);\n\n        /*\n         * Fetch the logs from the target via the diagnostic\n         * window.\n         */\n        ar6000_dbglog_get_debug_logs(ar);\n\n        /* Report the error only once */\n        if (!sip) {\n            sip = true;\n            errEvent.errorVal = WMI_TARGET_COM_ERR |\n                                WMI_TARGET_FATAL_ERR;\n        }\n    }\n}\n\nstatic int\nar6000_unavail_ev(void *context, void *hif_handle)\n{\n    struct ar6_softc *ar = (struct ar6_softc *)context;\n        /* NULL out it's entry in the global list */\n    ar6000_devices[ar->arDeviceIndex] = NULL;\n    ar6000_destroy(ar->arNetDev, 1);\n\n    return 0;\n}\n\nvoid\nar6000_restart_endpoint(struct net_device *dev)\n{\n    int status = 0;\n    struct ar6_softc *ar = (struct ar6_softc *)ar6k_priv(dev);\n\n    BMIInit();\n    do {\n        if ( (status=ar6000_configure_target(ar))!= 0)\n            break;\n        if ( (status=ar6000_sysfs_bmi_get_config(ar, wlaninitmode)) != 0)\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_avail: ar6000_sysfs_bmi_get_config failed\\n\"));\n            break;\n        }\n        rtnl_lock();\n        status = (ar6000_init(dev)==0) ? 0 : A_ERROR;\n        rtnl_unlock();\n\n        if (status) {\n            break;\n        }\n        if (ar->arSsidLen && ar->arWlanState == WLAN_ENABLED) {\n            ar6000_connect_to_ap(ar);\n        }  \n    } while (0);\n\n    if (status== 0) {\n        return;\n    }\n\n    ar6000_devices[ar->arDeviceIndex] = NULL;\n    ar6000_destroy(ar->arNetDev, 1);\n}\n\nvoid\nar6000_stop_endpoint(struct net_device *dev, bool keepprofile, bool getdbglogs)\n{\n    struct ar6_softc *ar = (struct ar6_softc *)ar6k_priv(dev);\n\n    /* Stop the transmit queues */\n    netif_stop_queue(dev);\n\n    /* Disable the target and the interrupts associated with it */\n    if (ar->arWmiReady == true)\n    {\n        if (!bypasswmi)\n        {\n            bool disconnectIssued;\n \n            disconnectIssued = (ar->arConnected) || (ar->arConnectPending);\n            ar6000_disconnect(ar);\n            if (!keepprofile) {\n                ar6000_init_profile_info(ar);\n            }\n\n            A_UNTIMEOUT(&ar->disconnect_timer);\n\n            if (getdbglogs) {\n                ar6000_dbglog_get_debug_logs(ar);\n            }\n\n            ar->arWmiReady  = false;\n            wmi_shutdown(ar->arWmi);\n            ar->arWmiEnabled = false;\n            ar->arWmi = NULL;\n            /* \n             * After wmi_shudown all WMI events will be dropped.\n             * We need to cleanup the buffers allocated in AP mode\n             * and give disconnect notification to stack, which usually\n             * happens in the disconnect_event. \n             * Simulate the disconnect_event by calling the function directly.\n             * Sometimes disconnect_event will be received when the debug logs \n             * are collected.\n             */\n            if (disconnectIssued) {\n                if(ar->arNetworkType & AP_NETWORK) {\n                    ar6000_disconnect_event(ar, DISCONNECT_CMD, bcast_mac, 0, NULL, 0);\n                } else {\n                    ar6000_disconnect_event(ar, DISCONNECT_CMD, ar->arBssid, 0, NULL, 0);\n                }\n            }\n            ar->user_savedkeys_stat = USER_SAVEDKEYS_STAT_INIT;\n            ar->user_key_ctrl      = 0;\n        }\n\n         AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"%s(): WMI stopped\\n\", __func__));\n    }\n    else\n    {\n        AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"%s(): WMI not ready 0x%lx 0x%lx\\n\",\n            __func__, (unsigned long) ar, (unsigned long) ar->arWmi));\n\n        /* Shut down WMI if we have started it */\n        if(ar->arWmiEnabled == true)\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"%s(): Shut down WMI\\n\", __func__));\n            wmi_shutdown(ar->arWmi);\n            ar->arWmiEnabled = false;\n            ar->arWmi = NULL;\n        }\n    }\n\n    if (ar->arHtcTarget != NULL) {\n#ifdef EXPORT_HCI_BRIDGE_INTERFACE\n        if (NULL != ar6kHciTransCallbacks.cleanupTransport) {\n            ar6kHciTransCallbacks.cleanupTransport(NULL);\n        }\n#else\n        // FIXME: workaround to reset BT's UART baud rate to default\n        if (NULL != ar->exitCallback) {\n            struct ar3k_config_info ar3kconfig;\n            int status;\n\n            A_MEMZERO(&ar3kconfig,sizeof(ar3kconfig));\n            ar6000_set_default_ar3kconfig(ar, (void *)&ar3kconfig);\n            status = ar->exitCallback(&ar3kconfig);\n            if (0 != status) {\n                AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"Failed to reset AR3K baud rate! \\n\"));\n            }\n        }\n        // END workaround\n        if (setuphci)\n        \tar6000_cleanup_hci(ar);\n#endif\n        AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\" Shutting down HTC .... \\n\"));\n        /* stop HTC */\n        HTCStop(ar->arHtcTarget);\n    }\n\n    if (resetok) {\n        /* try to reset the device if we can\n         * The driver may have been configure NOT to reset the target during\n         * a debug session */\n        AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\" Attempting to reset target on instance destroy.... \\n\"));\n        if (ar->arHifDevice != NULL) {\n            bool coldReset = (ar->arTargetType == TARGET_TYPE_AR6003) ? true: false;\n            ar6000_reset_device(ar->arHifDevice, ar->arTargetType, true, coldReset);\n        }\n    } else {\n        AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\" Host does not want target reset. \\n\"));\n    }\n       /* Done with cookies */\n    ar6000_cookie_cleanup(ar);\n\n    /* cleanup any allocated AMSDU buffers */\n    ar6000_cleanup_amsdu_rxbufs(ar);\n}\n/*\n * We need to differentiate between the surprise and planned removal of the\n * device because of the following consideration:\n * - In case of surprise removal, the hcd already frees up the pending\n *   for the device and hence there is no need to unregister the function\n *   driver inorder to get these requests. For planned removal, the function\n *   driver has to explicitly unregister itself to have the hcd return all the\n *   pending requests before the data structures for the devices are freed up.\n *   Note that as per the current implementation, the function driver will\n *   end up releasing all the devices since there is no API to selectively\n *   release a particular device.\n * - Certain commands issued to the target can be skipped for surprise\n *   removal since they will anyway not go through.\n */\nvoid\nar6000_destroy(struct net_device *dev, unsigned int unregister)\n{\n    struct ar6_softc *ar;\n\n    AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"+ar6000_destroy \\n\"));\n    \n    if((dev == NULL) || ((ar = ar6k_priv(dev)) == NULL))\n    {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"%s(): Failed to get device structure.\\n\", __func__));\n        return;\n    }\n\n    ar->bIsDestroyProgress = true;\n\n    if (down_interruptible(&ar->arSem)) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"%s(): down_interruptible failed \\n\", __func__));\n        return;\n    }\n\n    if (ar->arWlanPowerState != WLAN_POWER_STATE_CUT_PWR) {\n        /* only stop endpoint if we are not stop it in suspend_ev */\n        ar6000_stop_endpoint(dev, false, true);\n    }\n\n    ar->arWlanState = WLAN_DISABLED;\n    if (ar->arHtcTarget != NULL) {\n        /* destroy HTC */\n        HTCDestroy(ar->arHtcTarget);\n    }\n    if (ar->arHifDevice != NULL) {\n        /*release the device so we do not get called back on remove incase we\n         * we're explicity destroyed by module unload */\n        HIFReleaseDevice(ar->arHifDevice);\n        HIFShutDownDevice(ar->arHifDevice);\n    }\n    aggr_module_destroy(ar->aggr_cntxt);\n\n       /* Done with cookies */\n    ar6000_cookie_cleanup(ar);\n\n        /* cleanup any allocated AMSDU buffers */\n    ar6000_cleanup_amsdu_rxbufs(ar);\n\n    ar6000_sysfs_bmi_deinit(ar);\n\n    /* Cleanup BMI */\n    BMICleanup();\n\n    /* Clear the tx counters */\n    memset(tx_attempt, 0, sizeof(tx_attempt));\n    memset(tx_post, 0, sizeof(tx_post));\n    memset(tx_complete, 0, sizeof(tx_complete));\n\n#ifdef HTC_RAW_INTERFACE\n    if (ar->arRawHtc) {\n        kfree(ar->arRawHtc);\n        ar->arRawHtc = NULL;\n    }\n#endif \n    /* Free up the device data structure */\n    if (unregister && is_netdev_registered) {\t\t\n        unregister_netdev(dev);\n        is_netdev_registered = 0;\n    }\n    free_netdev(dev);\n\n    ar6k_cfg80211_deinit(ar);\n\n#ifdef CONFIG_AP_VIRTUL_ADAPTER_SUPPORT\n    ar6000_remove_ap_interface();\n#endif /*CONFIG_AP_VIRTUAL_ADAPTER_SUPPORT */\n\n    AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"-ar6000_destroy \\n\"));\n}\n\nstatic void disconnect_timer_handler(unsigned long ptr)\n{\n    struct net_device *dev = (struct net_device *)ptr;\n    struct ar6_softc *ar = (struct ar6_softc *)ar6k_priv(dev);\n\n    A_UNTIMEOUT(&ar->disconnect_timer);\n\n    ar6000_init_profile_info(ar);\n    ar6000_disconnect(ar);\n}\n\nstatic void ar6000_detect_error(unsigned long ptr)\n{\n    struct net_device *dev = (struct net_device *)ptr;\n    struct ar6_softc *ar = (struct ar6_softc *)ar6k_priv(dev);\n    WMI_TARGET_ERROR_REPORT_EVENT errEvent;\n\n    AR6000_SPIN_LOCK(&ar->arLock, 0);\n\n    if (ar->arHBChallengeResp.outstanding) {\n        ar->arHBChallengeResp.missCnt++;\n    } else {\n        ar->arHBChallengeResp.missCnt = 0;\n    }\n\n    if (ar->arHBChallengeResp.missCnt > ar->arHBChallengeResp.missThres) {\n        /* Send Error Detect event to the application layer and do not reschedule the error detection module timer */\n        ar->arHBChallengeResp.missCnt = 0;\n        ar->arHBChallengeResp.seqNum = 0;\n        errEvent.errorVal = WMI_TARGET_COM_ERR | WMI_TARGET_FATAL_ERR;\n        AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n        return;\n    }\n\n    /* Generate the sequence number for the next challenge */\n    ar->arHBChallengeResp.seqNum++;\n    ar->arHBChallengeResp.outstanding = true;\n\n    AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n\n    /* Send the challenge on the control channel */\n    if (wmi_get_challenge_resp_cmd(ar->arWmi, ar->arHBChallengeResp.seqNum, DRV_HB_CHALLENGE) != 0) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"Unable to send heart beat challenge\\n\"));\n    }\n\n\n    /* Reschedule the timer for the next challenge */\n    A_TIMEOUT_MS(&ar->arHBChallengeResp.timer, ar->arHBChallengeResp.frequency * 1000, 0);\n}\n\nvoid ar6000_init_profile_info(struct ar6_softc *ar)\n{\n    ar->arSsidLen            = 0;\n    A_MEMZERO(ar->arSsid, sizeof(ar->arSsid));\n\n    switch(fwmode) {\n        case HI_OPTION_FW_MODE_IBSS:\n            ar->arNetworkType = ar->arNextMode = ADHOC_NETWORK;\n            break;\n        case HI_OPTION_FW_MODE_BSS_STA:\n            ar->arNetworkType = ar->arNextMode = INFRA_NETWORK;\n            break;\n        case HI_OPTION_FW_MODE_AP:\n            ar->arNetworkType = ar->arNextMode = AP_NETWORK;\n            break;\n    }\n\n    ar->arDot11AuthMode      = OPEN_AUTH;\n    ar->arAuthMode           = NONE_AUTH;\n    ar->arPairwiseCrypto     = NONE_CRYPT;\n    ar->arPairwiseCryptoLen  = 0;\n    ar->arGroupCrypto        = NONE_CRYPT;\n    ar->arGroupCryptoLen     = 0;\n    A_MEMZERO(ar->arWepKeyList, sizeof(ar->arWepKeyList));\n    A_MEMZERO(ar->arReqBssid, sizeof(ar->arReqBssid));\n    A_MEMZERO(ar->arBssid, sizeof(ar->arBssid));\n    ar->arBssChannel = 0;\n}\n\nstatic void\nar6000_init_control_info(struct ar6_softc *ar)\n{\n    ar->arWmiEnabled         = false;\n    ar6000_init_profile_info(ar);\n    ar->arDefTxKeyIndex      = 0;\n    A_MEMZERO(ar->arWepKeyList, sizeof(ar->arWepKeyList));\n    ar->arChannelHint        = 0;\n    ar->arListenIntervalT    = A_DEFAULT_LISTEN_INTERVAL;\n    ar->arListenIntervalB    = 0;\n    ar->arVersion.host_ver   = AR6K_SW_VERSION;\n    ar->arRssi               = 0;\n    ar->arTxPwr              = 0;\n    ar->arTxPwrSet           = false;\n    ar->arSkipScan           = 0;\n    ar->arBeaconInterval     = 0;\n    ar->arBitRate            = 0;\n    ar->arMaxRetries         = 0;\n    ar->arWmmEnabled         = true;\n    ar->intra_bss            = 1;\n    ar->scan_triggered       = 0;\n    A_MEMZERO(&ar->scParams, sizeof(ar->scParams));\n    ar->scParams.shortScanRatio = WMI_SHORTSCANRATIO_DEFAULT;\n    ar->scParams.scanCtrlFlags = DEFAULT_SCAN_CTRL_FLAGS;\n\n    /* Initialize the AP mode state info */\n    {\n        u8 ctr;\n        A_MEMZERO((u8 *)ar->sta_list, AP_MAX_NUM_STA * sizeof(sta_t));\n\n        /* init the Mutexes */\n        A_MUTEX_INIT(&ar->mcastpsqLock);\n\n        /* Init the PS queues */\n        for (ctr=0; ctr < AP_MAX_NUM_STA ; ctr++) {\n            A_MUTEX_INIT(&ar->sta_list[ctr].psqLock);\n            A_NETBUF_QUEUE_INIT(&ar->sta_list[ctr].psq);\n        }\n\n        ar->ap_profile_flag = 0;\n        A_NETBUF_QUEUE_INIT(&ar->mcastpsq);\n\n        memcpy(ar->ap_country_code, DEF_AP_COUNTRY_CODE, 3);\n        ar->ap_wmode = DEF_AP_WMODE_G;\n        ar->ap_dtim_period = DEF_AP_DTIM;\n        ar->ap_beacon_interval = DEF_BEACON_INTERVAL;\n    }\n}\n\nstatic int\nar6000_open(struct net_device *dev)\n{\n    unsigned long  flags;\n    struct ar6_softc    *ar = (struct ar6_softc *)ar6k_priv(dev);\n\n    spin_lock_irqsave(&ar->arLock, flags);\n\n    if(ar->arWlanState == WLAN_DISABLED) {\n        ar->arWlanState = WLAN_ENABLED;\n    }\n\n    if( ar->arConnected || bypasswmi) {\n        netif_carrier_on(dev);\n        /* Wake up the queues */\n        netif_wake_queue(dev);\n    }\n    else\n        netif_carrier_off(dev);\n\n    spin_unlock_irqrestore(&ar->arLock, flags);\n    return 0;\n}\n\nstatic int\nar6000_close(struct net_device *dev)\n{\n    struct ar6_softc    *ar = (struct ar6_softc *)ar6k_priv(dev);\n    netif_stop_queue(dev);\n\n    ar6000_disconnect(ar);\n\n    if(ar->arWmiReady == true) {\n        if (wmi_scanparams_cmd(ar->arWmi, 0xFFFF, 0,\n                               0, 0, 0, 0, 0, 0, 0, 0) != 0) {\n            return -EIO;\n        }\n        ar->arWlanState = WLAN_DISABLED;\n    }\n\tar6k_cfg80211_scanComplete_event(ar, A_ECANCELED);\n\n    return 0;\n}\n\n/* connect to a service */\nstatic int ar6000_connectservice(struct ar6_softc               *ar,\n                                      struct htc_service_connect_req  *pConnect,\n                                      char *pDesc)\n{\n    int                 status;\n    struct htc_service_connect_resp response;\n\n    do {\n\n        A_MEMZERO(&response,sizeof(response));\n\n        status = HTCConnectService(ar->arHtcTarget,\n                                   pConnect,\n                                   &response);\n\n        if (status) {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\" Failed to connect to %s service status:%d \\n\",\n                              pDesc, status));\n            break;\n        }\n        switch (pConnect->ServiceID) {\n            case WMI_CONTROL_SVC :\n                if (ar->arWmiEnabled) {\n                        /* set control endpoint for WMI use */\n                    wmi_set_control_ep(ar->arWmi, response.Endpoint);\n                }\n                    /* save EP for fast lookup */\n                ar->arControlEp = response.Endpoint;\n                break;\n            case WMI_DATA_BE_SVC :\n                arSetAc2EndpointIDMap(ar, WMM_AC_BE, response.Endpoint);\n                break;\n            case WMI_DATA_BK_SVC :\n                arSetAc2EndpointIDMap(ar, WMM_AC_BK, response.Endpoint);\n                break;\n            case WMI_DATA_VI_SVC :\n                arSetAc2EndpointIDMap(ar, WMM_AC_VI, response.Endpoint);\n                 break;\n           case WMI_DATA_VO_SVC :\n                arSetAc2EndpointIDMap(ar, WMM_AC_VO, response.Endpoint);\n                break;\n           default:\n                AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ServiceID not mapped %d\\n\", pConnect->ServiceID));\n                status = A_EINVAL;\n            break;\n        }\n\n    } while (false);\n\n    return status;\n}\n\nvoid ar6000_TxDataCleanup(struct ar6_softc *ar)\n{\n        /* flush all the data (non-control) streams\n         * we only flush packets that are tagged as data, we leave any control packets that\n         * were in the TX queues alone */\n    HTCFlushEndpoint(ar->arHtcTarget,\n                     arAc2EndpointID(ar, WMM_AC_BE),\n                     AR6K_DATA_PKT_TAG);\n    HTCFlushEndpoint(ar->arHtcTarget,\n                     arAc2EndpointID(ar, WMM_AC_BK),\n                     AR6K_DATA_PKT_TAG);\n    HTCFlushEndpoint(ar->arHtcTarget,\n                     arAc2EndpointID(ar, WMM_AC_VI),\n                     AR6K_DATA_PKT_TAG);\n    HTCFlushEndpoint(ar->arHtcTarget,\n                     arAc2EndpointID(ar, WMM_AC_VO),\n                     AR6K_DATA_PKT_TAG);\n}\n\nHTC_ENDPOINT_ID\nar6000_ac2_endpoint_id ( void * devt, u8 ac)\n{\n    struct ar6_softc *ar = (struct ar6_softc *) devt;\n    return(arAc2EndpointID(ar, ac));\n}\n\nu8 ar6000_endpoint_id2_ac(void * devt, HTC_ENDPOINT_ID ep )\n{\n    struct ar6_softc *ar = (struct ar6_softc *) devt;\n    return(arEndpoint2Ac(ar, ep ));\n}\n\n#if defined(CONFIG_ATH6KL_ENABLE_COEXISTENCE)\nstatic int ath6kl_config_btcoex_params(struct ar6_softc *ar)\n{\n\tint r;\n\tWMI_SET_BTCOEX_COLOCATED_BT_DEV_CMD sbcb_cmd;\n\tWMI_SET_BTCOEX_FE_ANT_CMD sbfa_cmd;\n\n\t/* Configure the type of BT collocated with WLAN */\n\tmemset(&sbcb_cmd, 0, sizeof(WMI_SET_BTCOEX_COLOCATED_BT_DEV_CMD));\n\tsbcb_cmd.btcoexCoLocatedBTdev = ATH6KL_BT_DEV;\n\n\tr = wmi_set_btcoex_colocated_bt_dev_cmd(ar->arWmi, &sbcb_cmd);\n\n\tif (r) {\n\t\tAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\n\t\t\t\t(\"Unable to set collocated BT type\\n\"));\n\t\treturn r;\n\t}\n\n\t/* Configure the type of BT collocated with WLAN */\n\tmemset(&sbfa_cmd, 0, sizeof(WMI_SET_BTCOEX_FE_ANT_CMD));\n\n\tsbfa_cmd.btcoexFeAntType = ATH6KL_BT_ANTENNA;\n\n\tr = wmi_set_btcoex_fe_ant_cmd(ar->arWmi, &sbfa_cmd);\n\tif (r) {\n\t\tAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\n\t\t\t\t(\"Unable to set fornt end antenna configuration\\n\"));\n\t\treturn r;\n\t}\n\n\treturn 0;\n}\n#else\nstatic int ath6kl_config_btcoex_params(struct ar6_softc *ar)\n{\n\treturn 0;\n}\n#endif /* CONFIG_ATH6KL_ENABLE_COEXISTENCE */\n\n/*\n * This function applies WLAN specific configuration defined in wlan_config.h\n */\nint ar6000_target_config_wlan_params(struct ar6_softc *ar)\n{\n    int status = 0;\n\n#ifdef CONFIG_HOST_TCMD_SUPPORT\n    if (ar->arTargetMode != AR6000_WLAN_MODE) {\n        return 0;\n    }\n#endif /* CONFIG_HOST_TCMD_SUPPORT */\n\n    /* \n     * configure the device for rx dot11 header rules 0,0 are the default values\n     * therefore this command can be skipped if the inputs are 0,FALSE,FALSE.Required\n     * if checksum offload is needed. Set RxMetaVersion to 2\n     */\n    if ((wmi_set_rx_frame_format_cmd(ar->arWmi,ar->rxMetaVersion, processDot11Hdr, processDot11Hdr)) != 0) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"Unable to set the rx frame format.\\n\"));\n        status = A_ERROR;\n    }\n\n    status = ath6kl_config_btcoex_params(ar);\n    if (status)\n\treturn status;\n\n#if WLAN_CONFIG_IGNORE_POWER_SAVE_FAIL_EVENT_DURING_SCAN\n    if ((wmi_pmparams_cmd(ar->arWmi, 0, 1, 0, 0, 1, IGNORE_POWER_SAVE_FAIL_EVENT_DURING_SCAN)) != 0) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"Unable to set power save fail event policy\\n\"));\n        status = A_ERROR;\n    }\n#endif\n\n#if WLAN_CONFIG_DONOT_IGNORE_BARKER_IN_ERP\n    if ((wmi_set_lpreamble_cmd(ar->arWmi, 0, WMI_DONOT_IGNORE_BARKER_IN_ERP)) != 0) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"Unable to set barker preamble policy\\n\"));\n        status = A_ERROR;\n    }\n#endif\n\n    if ((wmi_set_keepalive_cmd(ar->arWmi, WLAN_CONFIG_KEEP_ALIVE_INTERVAL)) != 0) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"Unable to set keep alive interval\\n\"));\n        status = A_ERROR;\n    }\n\n#if WLAN_CONFIG_DISABLE_11N\n    {\n        WMI_SET_HT_CAP_CMD htCap;\n\n        memset(&htCap, 0, sizeof(WMI_SET_HT_CAP_CMD));\n        htCap.band = 0;\n        if ((wmi_set_ht_cap_cmd(ar->arWmi, &htCap)) != 0) {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"Unable to set ht capabilities \\n\"));\n            status = A_ERROR;\n        }\n\n        htCap.band = 1;\n        if ((wmi_set_ht_cap_cmd(ar->arWmi, &htCap)) != 0) {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"Unable to set ht capabilities \\n\"));\n            status = A_ERROR;\n        }\n    }\n#endif /* WLAN_CONFIG_DISABLE_11N */\n\n#ifdef ATH6K_CONFIG_OTA_MODE\n    if ((wmi_powermode_cmd(ar->arWmi, MAX_PERF_POWER)) != 0) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"Unable to set power mode \\n\"));\n        status = A_ERROR;\n    }\n#endif\n\n    if ((wmi_disctimeout_cmd(ar->arWmi, WLAN_CONFIG_DISCONNECT_TIMEOUT)) != 0) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"Unable to set disconnect timeout \\n\"));\n        status = A_ERROR;\n    }\n\n#if WLAN_CONFIG_DISABLE_TX_BURSTING  \n    if ((wmi_set_wmm_txop(ar->arWmi, WMI_TXOP_DISABLED)) != 0) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"Unable to set txop bursting \\n\"));\n        status = A_ERROR;\n    }\n#endif \n\n    return status;\n}\n\n/* This function does one time initialization for the lifetime of the device */\nint ar6000_init(struct net_device *dev)\n{\n    struct ar6_softc *ar;\n    int    status;\n    s32 timeleft;\n    s16 i;\n    int         ret = 0;\n\n    if((ar = ar6k_priv(dev)) == NULL)\n    {\n        return -EIO;\n    }\n\n    if (wlaninitmode == WLAN_INIT_MODE_USR || wlaninitmode == WLAN_INIT_MODE_DRV) {\n    \n        ar6000_update_bdaddr(ar);\n\n        if (enablerssicompensation) {\n            ar6000_copy_cust_data_from_target(ar->arHifDevice, ar->arTargetType);\n            read_rssi_compensation_param(ar);\n            for (i=-95; i<=0; i++) {\n                rssi_compensation_table[0-i] = rssi_compensation_calc(ar,i);\n            }\n        }\n    }\n\n    dev_hold(dev);\n    rtnl_unlock();\n\n    /* Do we need to finish the BMI phase */\n    if ((wlaninitmode == WLAN_INIT_MODE_USR || wlaninitmode == WLAN_INIT_MODE_DRV) && \n        (BMIDone(ar->arHifDevice) != 0))\n    {\n        ret = -EIO;\n        goto ar6000_init_done;\n    }\n\n    if (!bypasswmi)\n    {\n#if 0 /* TBDXXX */\n        if (ar->arVersion.host_ver != ar->arVersion.target_ver) {\n            A_PRINTF(\"WARNING: Host version 0x%x does not match Target \"\n                    \" version 0x%x!\\n\",\n                    ar->arVersion.host_ver, ar->arVersion.target_ver);\n        }\n#endif\n\n        /* Indicate that WMI is enabled (although not ready yet) */\n        ar->arWmiEnabled = true;\n        if ((ar->arWmi = wmi_init((void *) ar)) == NULL)\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"%s() Failed to initialize WMI.\\n\", __func__));\n            ret = -EIO;\n            goto ar6000_init_done;\n        }\n\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"%s() Got WMI @ 0x%lx.\\n\", __func__,\n            (unsigned long) ar->arWmi));\n    }\n\n    do {\n        struct htc_service_connect_req connect;\n\n            /* the reason we have to wait for the target here is that the driver layer\n             * has to init BMI in order to set the host block size,\n             */\n        status = HTCWaitTarget(ar->arHtcTarget);\n\n        if (status) {\n            break;\n        }\n\n        A_MEMZERO(&connect,sizeof(connect));\n            /* meta data is unused for now */\n        connect.pMetaData = NULL;\n        connect.MetaDataLength = 0;\n            /* these fields are the same for all service endpoints */\n        connect.EpCallbacks.pContext = ar;\n        connect.EpCallbacks.EpTxCompleteMultiple = ar6000_tx_complete;\n        connect.EpCallbacks.EpRecv = ar6000_rx;\n        connect.EpCallbacks.EpRecvRefill = ar6000_rx_refill;\n        connect.EpCallbacks.EpSendFull = ar6000_tx_queue_full;\n            /* set the max queue depth so that our ar6000_tx_queue_full handler gets called.\n             * Linux has the peculiarity of not providing flow control between the\n             * NIC and the network stack. There is no API to indicate that a TX packet\n             * was sent which could provide some back pressure to the network stack.\n             * Under linux you would have to wait till the network stack consumed all sk_buffs\n             * before any back-flow kicked in. Which isn't very friendly.\n             * So we have to manage this ourselves */\n        connect.MaxSendQueueDepth = MAX_DEFAULT_SEND_QUEUE_DEPTH;\n        connect.EpCallbacks.RecvRefillWaterMark = AR6000_MAX_RX_BUFFERS / 4; /* set to 25 % */\n        if (0 == connect.EpCallbacks.RecvRefillWaterMark) {\n            connect.EpCallbacks.RecvRefillWaterMark++;\n        }\n            /* connect to control service */\n        connect.ServiceID = WMI_CONTROL_SVC;\n        status = ar6000_connectservice(ar,\n                                       &connect,\n                                       \"WMI CONTROL\");\n        if (status) {\n            break;\n        }\n\n        connect.LocalConnectionFlags |= HTC_LOCAL_CONN_FLAGS_ENABLE_SEND_BUNDLE_PADDING;\n            /* limit the HTC message size on the send path, although we can receive A-MSDU frames of\n             * 4K, we will only send ethernet-sized (802.3) frames on the send path. */\n        connect.MaxSendMsgSize = WMI_MAX_TX_DATA_FRAME_LENGTH;\n\n            /* to reduce the amount of committed memory for larger A_MSDU frames, use the recv-alloc threshold\n             * mechanism for larger packets */\n        connect.EpCallbacks.RecvAllocThreshold = AR6000_BUFFER_SIZE;\n        connect.EpCallbacks.EpRecvAllocThresh = ar6000_alloc_amsdu_rxbuf;\n\n            /* for the remaining data services set the connection flag to reduce dribbling,\n             * if configured to do so */\n        if (reduce_credit_dribble) {\n            connect.ConnectionFlags |= HTC_CONNECT_FLAGS_REDUCE_CREDIT_DRIBBLE;\n            /* the credit dribble trigger threshold is (reduce_credit_dribble - 1) for a value\n             * of 0-3 */\n            connect.ConnectionFlags &= ~HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_MASK;\n            connect.ConnectionFlags |=\n                        ((u16)reduce_credit_dribble - 1) & HTC_CONNECT_FLAGS_THRESHOLD_LEVEL_MASK;\n        }\n            /* connect to best-effort service */\n        connect.ServiceID = WMI_DATA_BE_SVC;\n\n        status = ar6000_connectservice(ar,\n                                       &connect,\n                                       \"WMI DATA BE\");\n        if (status) {\n            break;\n        }\n\n            /* connect to back-ground\n             * map this to WMI LOW_PRI */\n        connect.ServiceID = WMI_DATA_BK_SVC;\n        status = ar6000_connectservice(ar,\n                                       &connect,\n                                       \"WMI DATA BK\");\n        if (status) {\n            break;\n        }\n\n            /* connect to Video service, map this to\n             * to HI PRI */\n        connect.ServiceID = WMI_DATA_VI_SVC;\n        status = ar6000_connectservice(ar,\n                                       &connect,\n                                       \"WMI DATA VI\");\n        if (status) {\n            break;\n        }\n\n            /* connect to VO service, this is currently not\n             * mapped to a WMI priority stream due to historical reasons.\n             * WMI originally defined 3 priorities over 3 mailboxes\n             * We can change this when WMI is reworked so that priorities are not\n             * dependent on mailboxes */\n        connect.ServiceID = WMI_DATA_VO_SVC;\n        status = ar6000_connectservice(ar,\n                                       &connect,\n                                       \"WMI DATA VO\");\n        if (status) {\n            break;\n        }\n\n        A_ASSERT(arAc2EndpointID(ar,WMM_AC_BE) != 0);\n        A_ASSERT(arAc2EndpointID(ar,WMM_AC_BK) != 0);\n        A_ASSERT(arAc2EndpointID(ar,WMM_AC_VI) != 0);\n        A_ASSERT(arAc2EndpointID(ar,WMM_AC_VO) != 0);\n\n            /* setup access class priority mappings */\n        ar->arAcStreamPriMap[WMM_AC_BK] = 0; /* lowest  */\n        ar->arAcStreamPriMap[WMM_AC_BE] = 1; /*         */\n        ar->arAcStreamPriMap[WMM_AC_VI] = 2; /*         */\n        ar->arAcStreamPriMap[WMM_AC_VO] = 3; /* highest */\n\n#ifdef EXPORT_HCI_BRIDGE_INTERFACE\n        if (setuphci && (NULL != ar6kHciTransCallbacks.setupTransport)) {\n            struct hci_transport_misc_handles hciHandles;\n\n            hciHandles.netDevice = ar->arNetDev;\n            hciHandles.hifDevice = ar->arHifDevice;\n            hciHandles.htcHandle = ar->arHtcTarget;\n            status = (int)(ar6kHciTransCallbacks.setupTransport(&hciHandles));\n        }\n#else\n        if (setuphci) {\n                /* setup HCI */\n            status = ar6000_setup_hci(ar);\n        }\n#endif\n\n    } while (false);\n\n    if (status) {\n        ret = -EIO;\n        goto ar6000_init_done;\n    }\n\n\tif (regscanmode) {\n\t\tu32 param;\n\n\t\tif (BMIReadMemory(ar->arHifDevice,\n\t\t\t\t  HOST_INTEREST_ITEM_ADDRESS(ar,\n\t\t\t\t\t\t\t     hi_option_flag),\n\t\t\t\t\t\t\t     (u8 *)&param,\n\t\t\t\t\t\t\t     4) != 0) {\n\t\t\tAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\n\t\t\t\t\t(\"BMIReadMemory forsetting \"\n\t\t\t\t\t \"regscanmode failed\\n\"));\n\t\t\treturn A_ERROR;\n\t\t}\n\n\t\tif (regscanmode == 1)\n\t\t\tparam |= HI_OPTION_SKIP_REG_SCAN;\n\t\telse if (regscanmode == 2)\n\t\t\tparam |= HI_OPTION_INIT_REG_SCAN;\n\n\t\tif (BMIWriteMemory(ar->arHifDevice,\n\t\t\t\t   HOST_INTEREST_ITEM_ADDRESS(ar,\n\t\t\t\t\t\t\t      hi_option_flag),\n\t\t\t\t\t\t\t      (u8 *)&param,\n\t\t\t\t\t\t\t      4) != 0) {\n\t\t\tAR_DEBUG_PRINTF(ATH_DEBUG_ERR,\n\t\t\t\t\t(\"BMIWriteMemory forsetting \"\n\t\t\t\t\t\"regscanmode failed\\n\"));\n\t\t\treturn A_ERROR;\n\t\t}\n\t\tAR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\"Regulatory scan mode set\\n\"));\n\t}\n\n    /*\n     * give our connected endpoints some buffers\n     */\n\n    ar6000_rx_refill(ar, ar->arControlEp);\n    ar6000_rx_refill(ar, arAc2EndpointID(ar,WMM_AC_BE));\n\n    /*\n     * We will post the receive buffers only for SPE or endpoint ping testing so we are\n     * making it conditional on the 'bypasswmi' flag.\n     */\n    if (bypasswmi) {\n        ar6000_rx_refill(ar,arAc2EndpointID(ar,WMM_AC_BK));\n        ar6000_rx_refill(ar,arAc2EndpointID(ar,WMM_AC_VI));\n        ar6000_rx_refill(ar,arAc2EndpointID(ar,WMM_AC_VO));\n    }\n\n    /* allocate some buffers that handle larger AMSDU frames */\n    ar6000_refill_amsdu_rxbufs(ar,AR6000_MAX_AMSDU_RX_BUFFERS);\n\n        /* setup credit distribution */\n    ar6000_setup_credit_dist(ar->arHtcTarget, &ar->arCreditStateInfo);\n\n    /* Since cookies are used for HTC transports, they should be */\n    /* initialized prior to enabling HTC.                        */\n    ar6000_cookie_init(ar);\n\n    /* start HTC */\n    status = HTCStart(ar->arHtcTarget);\n\n    if (status) {\n        if (ar->arWmiEnabled == true) {\n            wmi_shutdown(ar->arWmi);\n            ar->arWmiEnabled = false;\n            ar->arWmi = NULL;\n        }\n        ar6000_cookie_cleanup(ar);\n        ret = -EIO;\n        goto ar6000_init_done;\n    }\n\n    if (!bypasswmi) {\n        /* Wait for Wmi event to be ready */\n        timeleft = wait_event_interruptible_timeout(arEvent,\n            (ar->arWmiReady == true), wmitimeout * HZ);\n\n        if (ar->arVersion.abi_ver != AR6K_ABI_VERSION) {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ABI Version mismatch: Host(0x%x), Target(0x%x)\\n\", AR6K_ABI_VERSION, ar->arVersion.abi_ver));\n#ifndef ATH6K_SKIP_ABI_VERSION_CHECK\n            ret = -EIO;\n            goto ar6000_init_done;\n#endif /* ATH6K_SKIP_ABI_VERSION_CHECK */\n        }\n\n        if(!timeleft || signal_pending(current))\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"WMI is not ready or wait was interrupted\\n\"));\n            ret = -EIO;\n            goto ar6000_init_done;\n        }\n\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"%s() WMI is ready\\n\", __func__));\n\n        /* Communicate the wmi protocol verision to the target */\n        if ((ar6000_set_host_app_area(ar)) != 0) {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"Unable to set the host app area\\n\"));\n        }\n        ar6000_target_config_wlan_params(ar);\n    }\n\n    ar->arNumDataEndPts = 1;\n\n    if (bypasswmi) {\n            /* for tests like endpoint ping, the MAC address needs to be non-zero otherwise\n             * the data path through a raw socket is disabled */\n        dev->dev_addr[0] = 0x00;\n        dev->dev_addr[1] = 0x01;\n        dev->dev_addr[2] = 0x02;\n        dev->dev_addr[3] = 0xAA;\n        dev->dev_addr[4] = 0xBB;\n        dev->dev_addr[5] = 0xCC;\n    }\n\nar6000_init_done:\n    rtnl_lock();\n    dev_put(dev);\n\n    return ret;\n}\n\n\nvoid\nar6000_bitrate_rx(void *devt, s32 rateKbps)\n{\n    struct ar6_softc *ar = (struct ar6_softc *)devt;\n\n    ar->arBitRate = rateKbps;\n    wake_up(&arEvent);\n}\n\nvoid\nar6000_ratemask_rx(void *devt, u32 ratemask)\n{\n    struct ar6_softc *ar = (struct ar6_softc *)devt;\n\n    ar->arRateMask = ratemask;\n    wake_up(&arEvent);\n}\n\nvoid\nar6000_txPwr_rx(void *devt, u8 txPwr)\n{\n    struct ar6_softc *ar = (struct ar6_softc *)devt;\n\n    ar->arTxPwr = txPwr;\n    wake_up(&arEvent);\n}\n\n\nvoid\nar6000_channelList_rx(void *devt, s8 numChan, u16 *chanList)\n{\n    struct ar6_softc *ar = (struct ar6_softc *)devt;\n\n    memcpy(ar->arChannelList, chanList, numChan * sizeof (u16));\n    ar->arNumChannels = numChan;\n\n    wake_up(&arEvent);\n}\n\nu8 ar6000_ibss_map_epid(struct sk_buff *skb, struct net_device *dev, u32 *mapNo)\n{\n    struct ar6_softc      *ar = (struct ar6_softc *)ar6k_priv(dev);\n    u8 *datap;\n    ATH_MAC_HDR     *macHdr;\n    u32 i, eptMap;\n\n    (*mapNo) = 0;\n    datap = A_NETBUF_DATA(skb);\n    macHdr = (ATH_MAC_HDR *)(datap + sizeof(WMI_DATA_HDR));\n    if (IEEE80211_IS_MULTICAST(macHdr->dstMac)) {\n        return ENDPOINT_2;\n    }\n\n    eptMap = -1;\n    for (i = 0; i < ar->arNodeNum; i ++) {\n        if (IEEE80211_ADDR_EQ(macHdr->dstMac, ar->arNodeMap[i].macAddress)) {\n            (*mapNo) = i + 1;\n            ar->arNodeMap[i].txPending ++;\n            return ar->arNodeMap[i].epId;\n        }\n\n        if ((eptMap == -1) && !ar->arNodeMap[i].txPending) {\n            eptMap = i;\n        }\n    }\n\n    if (eptMap == -1) {\n        eptMap = ar->arNodeNum;\n        ar->arNodeNum ++;\n        A_ASSERT(ar->arNodeNum <= MAX_NODE_NUM);\n    }\n\n    memcpy(ar->arNodeMap[eptMap].macAddress, macHdr->dstMac, IEEE80211_ADDR_LEN);\n\n    for (i = ENDPOINT_2; i <= ENDPOINT_5; i ++) {\n        if (!ar->arTxPending[i]) {\n            ar->arNodeMap[eptMap].epId = i;\n            break;\n        }\n        // No free endpoint is available, start redistribution on the inuse endpoints.\n        if (i == ENDPOINT_5) {\n            ar->arNodeMap[eptMap].epId = ar->arNexEpId;\n            ar->arNexEpId ++;\n            if (ar->arNexEpId > ENDPOINT_5) {\n                ar->arNexEpId = ENDPOINT_2;\n            }\n        }\n    }\n\n    (*mapNo) = eptMap + 1;\n    ar->arNodeMap[eptMap].txPending ++;\n\n    return ar->arNodeMap[eptMap].epId;\n}\n\n#ifdef DEBUG\nstatic void ar6000_dump_skb(struct sk_buff *skb)\n{\n   u_char *ch;\n   for (ch = A_NETBUF_DATA(skb);\n        (unsigned long)ch < ((unsigned long)A_NETBUF_DATA(skb) +\n        A_NETBUF_LEN(skb)); ch++)\n    {\n         AR_DEBUG_PRINTF(ATH_DEBUG_WARN,(\"%2.2x \", *ch));\n    }\n    AR_DEBUG_PRINTF(ATH_DEBUG_WARN,(\"\\n\"));\n}\n#endif\n\n#ifdef HTC_TEST_SEND_PKTS\nstatic void DoHTCSendPktsTest(struct ar6_softc *ar, int MapNo, HTC_ENDPOINT_ID eid, struct sk_buff *skb);\n#endif\n\nstatic int\nar6000_data_tx(struct sk_buff *skb, struct net_device *dev)\n{\n#define AC_NOT_MAPPED   99\n    struct ar6_softc        *ar = (struct ar6_softc *)ar6k_priv(dev);\n    u8 ac = AC_NOT_MAPPED;\n    HTC_ENDPOINT_ID    eid = ENDPOINT_UNUSED;\n    u32 mapNo = 0;\n    int               len;\n    struct ar_cookie *cookie;\n    bool            checkAdHocPsMapping = false,bMoreData = false;\n    HTC_TX_TAG        htc_tag = AR6K_DATA_PKT_TAG;\n    u8 dot11Hdr = processDot11Hdr;\n#ifdef CONFIG_PM\n    if (ar->arWowState != WLAN_WOW_STATE_NONE) {\n        A_NETBUF_FREE(skb);\n        return 0;\n    }\n#endif /* CONFIG_PM */\n\n    AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_TX,(\"ar6000_data_tx start - skb=0x%lx, data=0x%lx, len=0x%x\\n\",\n                     (unsigned long)skb, (unsigned long)A_NETBUF_DATA(skb),\n                     A_NETBUF_LEN(skb)));\n\n    /* If target is not associated */\n    if( (!ar->arConnected && !bypasswmi)\n#ifdef CONFIG_HOST_TCMD_SUPPORT\n     /* TCMD doesn't support any data, free the buf and return */\n    || (ar->arTargetMode == AR6000_TCMD_MODE)\n#endif\n                                            ) {\n        A_NETBUF_FREE(skb);\n        return 0;\n    }\n\n    do {\n\n        if (ar->arWmiReady == false && bypasswmi == 0) {\n            break;\n        }\n\n#ifdef BLOCK_TX_PATH_FLAG\n        if (blocktx) {\n            break;\n        }\n#endif /* BLOCK_TX_PATH_FLAG */\n\n        /* AP mode Power save processing */\n        /* If the dst STA is in sleep state, queue the pkt in its PS queue */\n\n        if (ar->arNetworkType == AP_NETWORK) {\n            ATH_MAC_HDR *datap = (ATH_MAC_HDR *)A_NETBUF_DATA(skb);\n            sta_t *conn = NULL;\n\n            /* If the dstMac is a Multicast address & atleast one of the\n             * associated STA is in PS mode, then queue the pkt to the\n             * mcastq\n             */\n            if (IEEE80211_IS_MULTICAST(datap->dstMac)) {\n                u8 ctr=0;\n                bool qMcast=false;\n\n\n                for (ctr=0; ctr<AP_MAX_NUM_STA; ctr++) {\n                    if (STA_IS_PWR_SLEEP((&ar->sta_list[ctr]))) {\n                        qMcast = true;\n                    }\n                }\n                if(qMcast) {\n\n                    /* If this transmit is not because of a Dtim Expiry q it */\n                    if (ar->DTIMExpired == false) {\n                        bool isMcastqEmpty = false;\n\n                        A_MUTEX_LOCK(&ar->mcastpsqLock);\n                        isMcastqEmpty = A_NETBUF_QUEUE_EMPTY(&ar->mcastpsq);\n                        A_NETBUF_ENQUEUE(&ar->mcastpsq, skb);\n                        A_MUTEX_UNLOCK(&ar->mcastpsqLock);\n\n                        /* If this is the first Mcast pkt getting queued\n                         * indicate to the target to set the BitmapControl LSB\n                         * of the TIM IE.\n                         */\n                        if (isMcastqEmpty) {\n                             wmi_set_pvb_cmd(ar->arWmi, MCAST_AID, 1);\n                        }\n                        return 0;\n                    } else {\n                     /* This transmit is because of Dtim expiry. Determine if\n                      * MoreData bit has to be set.\n                      */\n                         A_MUTEX_LOCK(&ar->mcastpsqLock);\n                         if(!A_NETBUF_QUEUE_EMPTY(&ar->mcastpsq)) {\n                             bMoreData = true;\n                         }\n                         A_MUTEX_UNLOCK(&ar->mcastpsqLock);\n                    }\n                }\n            } else {\n                conn = ieee80211_find_conn(ar, datap->dstMac);\n                if (conn) {\n                    if (STA_IS_PWR_SLEEP(conn)) {\n                        /* If this transmit is not because of a PsPoll q it*/\n                        if (!STA_IS_PS_POLLED(conn)) {\n                            bool isPsqEmpty = false;\n                            /* Queue the frames if the STA is sleeping */\n                            A_MUTEX_LOCK(&conn->psqLock);\n                            isPsqEmpty = A_NETBUF_QUEUE_EMPTY(&conn->psq);\n                            A_NETBUF_ENQUEUE(&conn->psq, skb);\n                            A_MUTEX_UNLOCK(&conn->psqLock);\n\n                            /* If this is the first pkt getting queued\n                             * for this STA, update the PVB for this STA\n                             */\n                            if (isPsqEmpty) {\n                                wmi_set_pvb_cmd(ar->arWmi, conn->aid, 1);\n                            }\n\n                            return 0;\n                         } else {\n                         /* This tx is because of a PsPoll. Determine if\n                          * MoreData bit has to be set\n                          */\n                             A_MUTEX_LOCK(&conn->psqLock);\n                             if (!A_NETBUF_QUEUE_EMPTY(&conn->psq)) {\n                                 bMoreData = true;\n                             }\n                             A_MUTEX_UNLOCK(&conn->psqLock);\n                         }\n                    }\n                } else {\n\n                    /* non existent STA. drop the frame */\n                    A_NETBUF_FREE(skb);\n                    return 0;\n                }\n            }\n        }\n\n        if (ar->arWmiEnabled) {\n        u8 csumStart=0;\n        u8 csumDest=0;\n        u8 csum=skb->ip_summed;\n        if(csumOffload && (csum==CHECKSUM_PARTIAL)){\n            csumStart = (skb->head + skb->csum_start - skb_network_header(skb) +\n\t\t\t sizeof(ATH_LLC_SNAP_HDR));\n            csumDest=skb->csum_offset+csumStart;\n        }\n            if (A_NETBUF_HEADROOM(skb) < dev->hard_header_len - LINUX_HACK_FUDGE_FACTOR) {\n                struct sk_buff  *newbuf;\n\n                /*\n                 * We really should have gotten enough headroom but sometimes\n                 * we still get packets with not enough headroom.  Copy the packet.\n                 */\n                len = A_NETBUF_LEN(skb);\n                newbuf = A_NETBUF_ALLOC(len);\n                if (newbuf == NULL) {\n                    break;\n                }\n                A_NETBUF_PUT(newbuf, len);\n                memcpy(A_NETBUF_DATA(newbuf), A_NETBUF_DATA(skb), len);\n                A_NETBUF_FREE(skb);\n                skb = newbuf;\n                /* fall through and assemble header */\n            }\n\n            if (dot11Hdr) {\n                if (wmi_dot11_hdr_add(ar->arWmi,skb,ar->arNetworkType) != 0) {\n                    AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_data_tx-wmi_dot11_hdr_add failed\\n\"));\n                    break;\n                }\n            } else {\n                if (wmi_dix_2_dot3(ar->arWmi, skb) != 0) {\n                    AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_data_tx - wmi_dix_2_dot3 failed\\n\"));\n                    break;\n                }\n            }\n            if(csumOffload && (csum ==CHECKSUM_PARTIAL)){\n                WMI_TX_META_V2  metaV2;\n                metaV2.csumStart =csumStart;\n                metaV2.csumDest = csumDest;\n                metaV2.csumFlags = 0x1;/*instruct target to calculate checksum*/\n                if (wmi_data_hdr_add(ar->arWmi, skb, DATA_MSGTYPE, bMoreData, dot11Hdr,\n                                        WMI_META_VERSION_2,&metaV2) != 0) {\n                    AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_data_tx - wmi_data_hdr_add failed\\n\"));\n                    break;\n                }\n\n            }\n            else\n            {\n                if (wmi_data_hdr_add(ar->arWmi, skb, DATA_MSGTYPE, bMoreData, dot11Hdr,0,NULL) != 0) {\n                    AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_data_tx - wmi_data_hdr_add failed\\n\"));\n                    break;\n                }\n            }\n\n\n            if ((ar->arNetworkType == ADHOC_NETWORK) &&\n                ar->arIbssPsEnable && ar->arConnected) {\n                    /* flag to check adhoc mapping once we take the lock below: */\n                checkAdHocPsMapping = true;\n\n            } else {\n                    /* get the stream mapping */\n                ac  =  wmi_implicit_create_pstream(ar->arWmi, skb, 0, ar->arWmmEnabled);\n            }\n\n        } else {\n            EPPING_HEADER    *eppingHdr;\n\n            eppingHdr = A_NETBUF_DATA(skb);\n\n            if (IS_EPPING_PACKET(eppingHdr)) {\n                    /* the stream ID is mapped to an access class */\n                ac = eppingHdr->StreamNo_h;\n                    /* some EPPING packets cannot be dropped no matter what access class it was\n                     * sent on.  We can change the packet tag to guarantee it will not get dropped */\n                if (IS_EPING_PACKET_NO_DROP(eppingHdr)) {\n                    htc_tag = AR6K_CONTROL_PKT_TAG;\n                }\n\n                if (ac == HCI_TRANSPORT_STREAM_NUM) {\n                        /* pass this to HCI */\n#ifndef EXPORT_HCI_BRIDGE_INTERFACE\n                    if (!hci_test_send(ar,skb)) {\n                        return 0;\n                    }\n#endif\n                        /* set AC to discard this skb */\n                    ac = AC_NOT_MAPPED;\n                } else {\n                    /* a quirk of linux, the payload of the frame is 32-bit aligned and thus the addition\n                     * of the HTC header will mis-align the start of the HTC frame, so we add some\n                     * padding which will be stripped off in the target */\n                    if (EPPING_ALIGNMENT_PAD > 0) {\n                        A_NETBUF_PUSH(skb, EPPING_ALIGNMENT_PAD);\n                    }\n                }\n\n            } else {\n                    /* not a ping packet, drop it */\n                ac = AC_NOT_MAPPED;\n            }\n        }\n\n    } while (false);\n\n        /* did we succeed ? */\n    if ((ac == AC_NOT_MAPPED) && !checkAdHocPsMapping) {\n            /* cleanup and exit */\n        A_NETBUF_FREE(skb);\n        AR6000_STAT_INC(ar, tx_dropped);\n        AR6000_STAT_INC(ar, tx_aborted_errors);\n        return 0;\n    }\n\n    cookie = NULL;\n\n        /* take the lock to protect driver data */\n    AR6000_SPIN_LOCK(&ar->arLock, 0);\n\n    do {\n\n        if (checkAdHocPsMapping) {\n            eid = ar6000_ibss_map_epid(skb, dev, &mapNo);\n        }else {\n            eid = arAc2EndpointID (ar, ac);\n        }\n            /* validate that the endpoint is connected */\n        if (eid == 0 || eid == ENDPOINT_UNUSED ) {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\" eid %d is NOT mapped!\\n\", eid));\n            break;\n        }\n            /* allocate resource for this packet */\n        cookie = ar6000_alloc_cookie(ar);\n\n        if (cookie != NULL) {\n                /* update counts while the lock is held */\n            ar->arTxPending[eid]++;\n            ar->arTotalTxDataPending++;\n        }\n\n    } while (false);\n\n    AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n\n    if (cookie != NULL) {\n        cookie->arc_bp[0] = (unsigned long)skb;\n        cookie->arc_bp[1] = mapNo;\n        SET_HTC_PACKET_INFO_TX(&cookie->HtcPkt,\n                               cookie,\n                               A_NETBUF_DATA(skb),\n                               A_NETBUF_LEN(skb),\n                               eid,\n                               htc_tag);\n\n#ifdef DEBUG\n        if (debugdriver >= 3) {\n            ar6000_dump_skb(skb);\n        }\n#endif\n#ifdef HTC_TEST_SEND_PKTS\n        DoHTCSendPktsTest(ar,mapNo,eid,skb);\n#endif\n            /* HTC interface is asynchronous, if this fails, cleanup will happen in\n             * the ar6000_tx_complete callback */\n        HTCSendPkt(ar->arHtcTarget, &cookie->HtcPkt);\n    } else {\n            /* no packet to send, cleanup */\n        A_NETBUF_FREE(skb);\n        AR6000_STAT_INC(ar, tx_dropped);\n        AR6000_STAT_INC(ar, tx_aborted_errors);\n    }\n\n    return 0;\n}\n\nint\nar6000_acl_data_tx(struct sk_buff *skb, struct net_device *dev)\n{\n    struct ar6_softc        *ar = (struct ar6_softc *)ar6k_priv(dev);\n    struct ar_cookie *cookie;\n    HTC_ENDPOINT_ID    eid = ENDPOINT_UNUSED;\n\n    cookie = NULL;\n    AR6000_SPIN_LOCK(&ar->arLock, 0);\n\n        /* For now we send ACL on BE endpoint: We can also have a dedicated EP */\n        eid = arAc2EndpointID (ar, 0);\n        /* allocate resource for this packet */\n        cookie = ar6000_alloc_cookie(ar);\n\n        if (cookie != NULL) {\n            /* update counts while the lock is held */\n            ar->arTxPending[eid]++;\n            ar->arTotalTxDataPending++;\n        }\n\n\n    AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n\n        if (cookie != NULL) {\n            cookie->arc_bp[0] = (unsigned long)skb;\n            cookie->arc_bp[1] = 0;\n            SET_HTC_PACKET_INFO_TX(&cookie->HtcPkt,\n                            cookie,\n                            A_NETBUF_DATA(skb),\n                            A_NETBUF_LEN(skb),\n                            eid,\n                            AR6K_DATA_PKT_TAG);\n\n            /* HTC interface is asynchronous, if this fails, cleanup will happen in\n             * the ar6000_tx_complete callback */\n            HTCSendPkt(ar->arHtcTarget, &cookie->HtcPkt);\n        } else {\n            /* no packet to send, cleanup */\n            A_NETBUF_FREE(skb);\n            AR6000_STAT_INC(ar, tx_dropped);\n            AR6000_STAT_INC(ar, tx_aborted_errors);\n        }\n    return 0;\n}\n\n\n#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL\nstatic void\ntvsub(register struct timeval *out, register struct timeval *in)\n{\n    if((out->tv_usec -= in->tv_usec) < 0) {\n        out->tv_sec--;\n        out->tv_usec += 1000000;\n    }\n    out->tv_sec -= in->tv_sec;\n}\n\nvoid\napplyAPTCHeuristics(struct ar6_softc *ar)\n{\n    u32 duration;\n    u32 numbytes;\n    u32 throughput;\n    struct timeval ts;\n    int status;\n\n    AR6000_SPIN_LOCK(&ar->arLock, 0);\n\n    if ((enableAPTCHeuristics) && (!aptcTR.timerScheduled)) {\n        do_gettimeofday(&ts);\n        tvsub(&ts, &aptcTR.samplingTS);\n        duration = ts.tv_sec * 1000 + ts.tv_usec / 1000; /* ms */\n        numbytes = aptcTR.bytesTransmitted + aptcTR.bytesReceived;\n\n        if (duration > APTC_TRAFFIC_SAMPLING_INTERVAL) {\n            /* Initialize the time stamp and byte count */\n            aptcTR.bytesTransmitted = aptcTR.bytesReceived = 0;\n            do_gettimeofday(&aptcTR.samplingTS);\n\n            /* Calculate and decide based on throughput thresholds */\n            throughput = ((numbytes * 8) / duration);\n            if (throughput > APTC_UPPER_THROUGHPUT_THRESHOLD) {\n                /* Disable Sleep and schedule a timer */\n                A_ASSERT(ar->arWmiReady == true);\n                AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n                status = wmi_powermode_cmd(ar->arWmi, MAX_PERF_POWER);\n                AR6000_SPIN_LOCK(&ar->arLock, 0);\n                A_TIMEOUT_MS(&aptcTimer, APTC_TRAFFIC_SAMPLING_INTERVAL, 0);\n                aptcTR.timerScheduled = true;\n            }\n        }\n    }\n\n    AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n}\n#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */\n\nstatic HTC_SEND_FULL_ACTION ar6000_tx_queue_full(void *Context, struct htc_packet *pPacket)\n{\n    struct ar6_softc     *ar = (struct ar6_softc *)Context;\n    HTC_SEND_FULL_ACTION    action = HTC_SEND_FULL_KEEP;\n    bool                  stopNet = false;\n    HTC_ENDPOINT_ID         Endpoint = HTC_GET_ENDPOINT_FROM_PKT(pPacket);\n\n    do {\n\n        if (bypasswmi) {\n            int accessClass;\n\n            if (HTC_GET_TAG_FROM_PKT(pPacket) == AR6K_CONTROL_PKT_TAG) {\n                    /* don't drop special control packets */\n                break;\n            }\n\n            accessClass = arEndpoint2Ac(ar,Endpoint);\n                /* for endpoint ping testing drop Best Effort and Background */\n            if ((accessClass == WMM_AC_BE) || (accessClass == WMM_AC_BK)) {\n                action = HTC_SEND_FULL_DROP;\n                stopNet = false;\n            } else {\n                    /* keep but stop the netqueues */\n                stopNet = true;\n            }\n            break;\n        }\n\n        if (Endpoint == ar->arControlEp) {\n                /* under normal WMI if this is getting full, then something is running rampant\n                 * the host should not be exhausting the WMI queue with too many commands\n                 * the only exception to this is during testing using endpointping */\n            AR6000_SPIN_LOCK(&ar->arLock, 0);\n                /* set flag to handle subsequent messages */\n            ar->arWMIControlEpFull = true;\n            AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"WMI Control Endpoint is FULL!!! \\n\"));\n                /* no need to stop the network */\n            stopNet = false;\n            break;\n        }\n\n        /* if we get here, we are dealing with data endpoints getting full */\n\n        if (HTC_GET_TAG_FROM_PKT(pPacket) == AR6K_CONTROL_PKT_TAG) {\n            /* don't drop control packets issued on ANY data endpoint */\n            break;\n        }\n\n        if (ar->arNetworkType == ADHOC_NETWORK) {\n            /* in adhoc mode, we cannot differentiate traffic priorities so there is no need to\n             * continue, however we should stop the network */\n            stopNet = true;\n            break;\n        }\n        /* the last MAX_HI_COOKIE_NUM \"batch\" of cookies are reserved for the highest\n         * active stream */\n        if (ar->arAcStreamPriMap[arEndpoint2Ac(ar,Endpoint)] < ar->arHiAcStreamActivePri &&\n            ar->arCookieCount <= MAX_HI_COOKIE_NUM) {\n                /* this stream's priority is less than the highest active priority, we\n                 * give preference to the highest priority stream by directing\n                 * HTC to drop the packet that overflowed */\n            action = HTC_SEND_FULL_DROP;\n                /* since we are dropping packets, no need to stop the network */\n            stopNet = false;\n            break;\n        }\n\n    } while (false);\n\n    if (stopNet) {\n        AR6000_SPIN_LOCK(&ar->arLock, 0);\n        ar->arNetQueueStopped = true;\n        AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n        /* one of the data endpoints queues is getting full..need to stop network stack\n         * the queue will resume in ar6000_tx_complete() */\n        netif_stop_queue(ar->arNetDev);\n    }\n\n    return action;\n}\n\n\nstatic void\nar6000_tx_complete(void *Context, struct htc_packet_queue *pPacketQueue)\n{\n    struct ar6_softc     *ar = (struct ar6_softc *)Context;\n    u32 mapNo = 0;\n    int        status;\n    struct ar_cookie * ar_cookie;\n    HTC_ENDPOINT_ID   eid;\n    bool          wakeEvent = false;\n    struct sk_buff_head  skb_queue;\n    struct htc_packet      *pPacket;\n    struct sk_buff  *pktSkb;\n    bool          flushing = false;\n\n    skb_queue_head_init(&skb_queue);\n\n        /* lock the driver as we update internal state */\n    AR6000_SPIN_LOCK(&ar->arLock, 0);\n\n        /* reap completed packets */\n    while (!HTC_QUEUE_EMPTY(pPacketQueue)) {\n\n        pPacket = HTC_PACKET_DEQUEUE(pPacketQueue);\n\n        ar_cookie = (struct ar_cookie *)pPacket->pPktContext;\n        A_ASSERT(ar_cookie);\n\n        status = pPacket->Status;\n        pktSkb = (struct sk_buff *)ar_cookie->arc_bp[0];\n        eid = pPacket->Endpoint;\n        mapNo = ar_cookie->arc_bp[1];\n\n        A_ASSERT(pktSkb);\n        A_ASSERT(pPacket->pBuffer == A_NETBUF_DATA(pktSkb));\n\n            /* add this to the list, use faster non-lock API */\n        __skb_queue_tail(&skb_queue,pktSkb);\n\n        if (!status) {\n            A_ASSERT(pPacket->ActualLength == A_NETBUF_LEN(pktSkb));\n        }\n\n        AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_TX,(\"ar6000_tx_complete skb=0x%lx data=0x%lx len=0x%x eid=%d \",\n                         (unsigned long)pktSkb, (unsigned long)pPacket->pBuffer,\n                         pPacket->ActualLength,\n                         eid));\n\n        ar->arTxPending[eid]--;\n\n        if ((eid  != ar->arControlEp) || bypasswmi) {\n            ar->arTotalTxDataPending--;\n        }\n\n        if (eid == ar->arControlEp)\n        {\n            if (ar->arWMIControlEpFull) {\n                    /* since this packet completed, the WMI EP is no longer full */\n                ar->arWMIControlEpFull = false;\n            }\n\n            if (ar->arTxPending[eid] == 0) {\n                wakeEvent = true;\n            }\n        }\n\n        if (status) {\n            if (status == A_ECANCELED) {\n                    /* a packet was flushed  */\n                flushing = true;\n            }\n            AR6000_STAT_INC(ar, tx_errors);\n            if (status != A_NO_RESOURCE) {\n                AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"%s() -TX ERROR, status: 0x%x\\n\", __func__,\n                            status));\n            }\n        } else {\n            AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_TX,(\"OK\\n\"));\n            flushing = false;\n            AR6000_STAT_INC(ar, tx_packets);\n            ar->arNetStats.tx_bytes += A_NETBUF_LEN(pktSkb);\n#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL\n            aptcTR.bytesTransmitted += a_netbuf_to_len(pktSkb);\n            applyAPTCHeuristics(ar);\n#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */\n        }\n\n        // TODO this needs to be looked at\n        if ((ar->arNetworkType == ADHOC_NETWORK) && ar->arIbssPsEnable\n            && (eid != ar->arControlEp) && mapNo)\n        {\n            mapNo --;\n            ar->arNodeMap[mapNo].txPending --;\n\n            if (!ar->arNodeMap[mapNo].txPending && (mapNo == (ar->arNodeNum - 1))) {\n                u32 i;\n                for (i = ar->arNodeNum; i > 0; i --) {\n                    if (!ar->arNodeMap[i - 1].txPending) {\n                        A_MEMZERO(&ar->arNodeMap[i - 1], sizeof(struct ar_node_mapping));\n                        ar->arNodeNum --;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n\n        ar6000_free_cookie(ar, ar_cookie);\n\n        if (ar->arNetQueueStopped) {\n            ar->arNetQueueStopped = false;\n        }\n    }\n\n    AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n\n    /* lock is released, we can freely call other kernel APIs */\n\n        /* free all skbs in our local list */\n    while (!skb_queue_empty(&skb_queue)) {\n            /* use non-lock version */\n        pktSkb = __skb_dequeue(&skb_queue);\n        A_NETBUF_FREE(pktSkb);\n    }\n\n    if ((ar->arConnected == true) || bypasswmi) {\n        if (!flushing) {\n                /* don't wake the queue if we are flushing, other wise it will just\n                 * keep queueing packets, which will keep failing */\n            netif_wake_queue(ar->arNetDev);\n        }\n    }\n\n    if (wakeEvent) {\n        wake_up(&arEvent);\n    }\n\n}\n\nsta_t *\nieee80211_find_conn(struct ar6_softc *ar, u8 *node_addr)\n{\n    sta_t *conn = NULL;\n    u8 i, max_conn;\n\n    switch(ar->arNetworkType) {\n        case AP_NETWORK:\n            max_conn = AP_MAX_NUM_STA;\n            break;\n        default:\n            max_conn=0;\n            break;\n    }\n\n    for (i = 0; i < max_conn; i++) {\n        if (IEEE80211_ADDR_EQ(node_addr, ar->sta_list[i].mac)) {\n            conn = &ar->sta_list[i];\n            break;\n        }\n    }\n\n    return conn;\n}\n\nsta_t *ieee80211_find_conn_for_aid(struct ar6_softc *ar, u8 aid)\n{\n    sta_t *conn = NULL;\n    u8 ctr;\n\n    for (ctr = 0; ctr < AP_MAX_NUM_STA; ctr++) {\n        if (ar->sta_list[ctr].aid == aid) {\n            conn = &ar->sta_list[ctr];\n            break;\n        }\n    }\n    return conn;\n}\n\n/*\n * Receive event handler.  This is called by HTC when a packet is received\n */\nint pktcount;\nstatic void\nar6000_rx(void *Context, struct htc_packet *pPacket)\n{\n    struct ar6_softc *ar = (struct ar6_softc *)Context;\n    struct sk_buff *skb = (struct sk_buff *)pPacket->pPktContext;\n    int minHdrLen;\n    u8 containsDot11Hdr = 0;\n    int        status = pPacket->Status;\n    HTC_ENDPOINT_ID   ept = pPacket->Endpoint;\n\n    A_ASSERT((status) ||\n             (pPacket->pBuffer == (A_NETBUF_DATA(skb) + HTC_HEADER_LEN)));\n\n    AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_RX,(\"ar6000_rx ar=0x%lx eid=%d, skb=0x%lx, data=0x%lx, len=0x%x status:%d\",\n                    (unsigned long)ar, ept, (unsigned long)skb, (unsigned long)pPacket->pBuffer,\n                    pPacket->ActualLength, status));\n    if (status) {\n        if (status != A_ECANCELED) {\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"RX ERR (%d) \\n\",status));\n        }\n    }\n\n        /* take lock to protect buffer counts\n         * and adaptive power throughput state */\n    AR6000_SPIN_LOCK(&ar->arLock, 0);\n\n    if (!status) {\n        AR6000_STAT_INC(ar, rx_packets);\n        ar->arNetStats.rx_bytes += pPacket->ActualLength;\n#ifdef ADAPTIVE_POWER_THROUGHPUT_CONTROL\n        aptcTR.bytesReceived += a_netbuf_to_len(skb);\n        applyAPTCHeuristics(ar);\n#endif /* ADAPTIVE_POWER_THROUGHPUT_CONTROL */\n\n        A_NETBUF_PUT(skb, pPacket->ActualLength +  HTC_HEADER_LEN);\n        A_NETBUF_PULL(skb, HTC_HEADER_LEN);\n\n#ifdef DEBUG\n        if (debugdriver >= 2) {\n            ar6000_dump_skb(skb);\n        }\n#endif /* DEBUG */\n    }\n\n    AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n\n    skb->dev = ar->arNetDev;\n    if (status) {\n        AR6000_STAT_INC(ar, rx_errors);\n        A_NETBUF_FREE(skb);\n    } else if (ar->arWmiEnabled == true) {\n        if (ept == ar->arControlEp) {\n           /*\n            * this is a wmi control msg\n            */\n#ifdef CONFIG_PM \n            ar6000_check_wow_status(ar, skb, true);\n#endif /* CONFIG_PM */\n            wmi_control_rx(ar->arWmi, skb);\n        } else {\n                WMI_DATA_HDR *dhdr = (WMI_DATA_HDR *)A_NETBUF_DATA(skb);\n                bool is_amsdu;\n                u8 tid;\n\n\t\t/*\n\t\t * This check can be removed if after a while we do not\n\t\t * see the warning. For now we leave it to ensure\n\t\t * we drop these frames accordingly in case the\n\t\t * target generates them for some reason. These\n\t\t * were used for an internal PAL but that's not\n\t\t * used or supported anymore. These frames should\n\t\t * not come up from the target.\n\t\t */\n                if (WARN_ON(WMI_DATA_HDR_GET_DATA_TYPE(dhdr) ==\n\t\t\t    WMI_DATA_HDR_DATA_TYPE_ACL)) {\n\t\t\tAR6000_STAT_INC(ar, rx_errors);\n\t\t\tA_NETBUF_FREE(skb);\n\t\t\treturn;\n\t\t}\n\n#ifdef CONFIG_PM \n                ar6000_check_wow_status(ar, NULL, false);\n#endif /* CONFIG_PM */\n                /*\n                 * this is a wmi data packet\n                 */\n                 // NWF\n\n                if (processDot11Hdr) {\n                    minHdrLen = sizeof(WMI_DATA_HDR) + sizeof(struct ieee80211_frame) + sizeof(ATH_LLC_SNAP_HDR);\n                } else {\n                    minHdrLen = sizeof (WMI_DATA_HDR) + sizeof(ATH_MAC_HDR) +\n                          sizeof(ATH_LLC_SNAP_HDR);\n                }\n\n                /* In the case of AP mode we may receive NULL data frames\n                 * that do not have LLC hdr. They are 16 bytes in size.\n                 * Allow these frames in the AP mode.\n                 * ACL data frames don't follow ethernet frame bounds for\n                 * min length\n                 */\n                if (ar->arNetworkType != AP_NETWORK &&\n                    ((pPacket->ActualLength < minHdrLen) ||\n                    (pPacket->ActualLength > AR6000_MAX_RX_MESSAGE_SIZE)))\n                {\n                    /*\n                     * packet is too short or too long\n                     */\n                    AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"TOO SHORT or TOO LONG\\n\"));\n                    AR6000_STAT_INC(ar, rx_errors);\n                    AR6000_STAT_INC(ar, rx_length_errors);\n                    A_NETBUF_FREE(skb);\n                } else {\n                    u16 seq_no;\n                    u8 meta_type;\n\n#if 0\n                    /* Access RSSI values here */\n                    AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"RSSI %d\\n\",\n                        ((WMI_DATA_HDR *) A_NETBUF_DATA(skb))->rssi));\n#endif\n                    /* Get the Power save state of the STA */\n                    if (ar->arNetworkType == AP_NETWORK) {\n                        sta_t *conn = NULL;\n                        u8 psState=0,prevPsState;\n                        ATH_MAC_HDR *datap=NULL;\n                        u16 offset;\n\n                        meta_type = WMI_DATA_HDR_GET_META(dhdr);\n\n                        psState = (((WMI_DATA_HDR *)A_NETBUF_DATA(skb))->info\n                                     >> WMI_DATA_HDR_PS_SHIFT) & WMI_DATA_HDR_PS_MASK;\n\n                        offset = sizeof(WMI_DATA_HDR);\n\n                        switch (meta_type) {\n                            case 0:\n                                break;\n                            case WMI_META_VERSION_1:\n                                offset += sizeof(WMI_RX_META_V1);\n                                break;\n                            case WMI_META_VERSION_2:\n                                offset += sizeof(WMI_RX_META_V2);\n                                break;\n                            default:\n                                break;\n                        }\n\n                        datap = (ATH_MAC_HDR *)(A_NETBUF_DATA(skb)+offset);\n                        conn = ieee80211_find_conn(ar, datap->srcMac);\n\n                        if (conn) {\n                            /* if there is a change in PS state of the STA,\n                             * take appropriate steps.\n                             * 1. If Sleep-->Awake, flush the psq for the STA\n                             *    Clear the PVB for the STA.\n                             * 2. If Awake-->Sleep, Starting queueing frames\n                             * the STA.\n                             */\n                            prevPsState = STA_IS_PWR_SLEEP(conn);\n                            if (psState) {\n                                STA_SET_PWR_SLEEP(conn);\n                            } else {\n                                STA_CLR_PWR_SLEEP(conn);\n                            }\n\n                            if (prevPsState ^ STA_IS_PWR_SLEEP(conn)) {\n\n                                if (!STA_IS_PWR_SLEEP(conn)) {\n\n                                    A_MUTEX_LOCK(&conn->psqLock);\n                                    while (!A_NETBUF_QUEUE_EMPTY(&conn->psq)) {\n                                        struct sk_buff *skb=NULL;\n\n                                        skb = A_NETBUF_DEQUEUE(&conn->psq);\n                                        A_MUTEX_UNLOCK(&conn->psqLock);\n                                        ar6000_data_tx(skb,ar->arNetDev);\n                                        A_MUTEX_LOCK(&conn->psqLock);\n                                    }\n                                    A_MUTEX_UNLOCK(&conn->psqLock);\n                                    /* Clear the PVB for this STA */\n                                    wmi_set_pvb_cmd(ar->arWmi, conn->aid, 0);\n                                }\n                            }\n                        } else {\n                            /* This frame is from a STA that is not associated*/\n                            A_ASSERT(false);\n                        }\n\n                        /* Drop NULL data frames here */\n                        if((pPacket->ActualLength < minHdrLen) ||\n                                (pPacket->ActualLength > AR6000_MAX_RX_MESSAGE_SIZE)) {\n                            A_NETBUF_FREE(skb);\n                            goto rx_done;\n                        }\n                    }\n\n                    is_amsdu = WMI_DATA_HDR_IS_AMSDU(dhdr) ? true : false;\n                    tid = WMI_DATA_HDR_GET_UP(dhdr);\n                    seq_no = WMI_DATA_HDR_GET_SEQNO(dhdr);\n                    meta_type = WMI_DATA_HDR_GET_META(dhdr);\n                    containsDot11Hdr = WMI_DATA_HDR_GET_DOT11(dhdr);\n\n                    wmi_data_hdr_remove(ar->arWmi, skb);\n\n                    switch (meta_type) {\n                        case WMI_META_VERSION_1:\n                            {\n                                WMI_RX_META_V1 *pMeta = (WMI_RX_META_V1 *)A_NETBUF_DATA(skb);\n                                A_PRINTF(\"META %d %d %d %d %x\\n\", pMeta->status, pMeta->rix, pMeta->rssi, pMeta->channel, pMeta->flags);\n                                A_NETBUF_PULL((void*)skb, sizeof(WMI_RX_META_V1));\n                                break;\n                            }\n                        case WMI_META_VERSION_2:\n                            {\n                                WMI_RX_META_V2 *pMeta = (WMI_RX_META_V2 *)A_NETBUF_DATA(skb);\n                                if(pMeta->csumFlags & 0x1){\n                                    skb->ip_summed=CHECKSUM_COMPLETE;\n                                    skb->csum=(pMeta->csum);\n                                }\n                                A_NETBUF_PULL((void*)skb, sizeof(WMI_RX_META_V2));\n                                break;\n                            }\n                        default:\n                            break;\n                    }\n\n                    A_ASSERT(status == 0);\n\n                    /* NWF: print the 802.11 hdr bytes */\n                    if(containsDot11Hdr) {\n                        status = wmi_dot11_hdr_remove(ar->arWmi,skb);\n                    } else if(!is_amsdu) {\n                        status = wmi_dot3_2_dix(skb);\n                    }\n\n                    if (status) {\n                        /* Drop frames that could not be processed (lack of memory, etc.) */\n                        A_NETBUF_FREE(skb);\n                        goto rx_done;\n                    }\n\n                    if ((ar->arNetDev->flags & IFF_UP) == IFF_UP) {\n                        if (ar->arNetworkType == AP_NETWORK) {\n                            struct sk_buff *skb1 = NULL;\n                            ATH_MAC_HDR *datap;\n\n                            datap = (ATH_MAC_HDR *)A_NETBUF_DATA(skb);\n                            if (IEEE80211_IS_MULTICAST(datap->dstMac)) {\n                                /* Bcast/Mcast frames should be sent to the OS\n                                 * stack as well as on the air.\n                                 */\n                                skb1 = skb_copy(skb,GFP_ATOMIC);\n                            } else {\n                                /* Search for a connected STA with dstMac as\n                                 * the Mac address. If found send the frame to\n                                 * it on the air else send the frame up the\n                                 * stack\n                                 */\n                                sta_t *conn = NULL;\n                                conn = ieee80211_find_conn(ar, datap->dstMac);\n\n                                if (conn && ar->intra_bss) {\n                                    skb1 = skb;\n                                    skb = NULL;\n                                } else if(conn && !ar->intra_bss) {\n                                    A_NETBUF_FREE(skb);\n                                    skb = NULL;\n                                }\n                            }\n                            if (skb1) {\n                                ar6000_data_tx(skb1, ar->arNetDev);\n                            }\n                        }\n                    }\n                    aggr_process_recv_frm(ar->aggr_cntxt, tid, seq_no, is_amsdu, (void **)&skb);\n                    ar6000_deliver_frames_to_nw_stack((void *) ar->arNetDev, (void *)skb);\n                }\n            }\n    } else {\n        if (EPPING_ALIGNMENT_PAD > 0) {\n            A_NETBUF_PULL(skb, EPPING_ALIGNMENT_PAD);\n        }\n        ar6000_deliver_frames_to_nw_stack((void *)ar->arNetDev, (void *)skb);\n    }\n\nrx_done:\n\n    return;\n}\n\nstatic void\nar6000_deliver_frames_to_nw_stack(void *dev, void *osbuf)\n{\n    struct sk_buff *skb = (struct sk_buff *)osbuf;\n\n    if(skb) {\n        skb->dev = dev;\n        if ((skb->dev->flags & IFF_UP) == IFF_UP) {\n#ifdef CONFIG_PM \n            ar6000_check_wow_status((struct ar6_softc *)ar6k_priv(dev), skb, false);\n#endif /* CONFIG_PM */\n            skb->protocol = eth_type_trans(skb, skb->dev);\n        /*\n         * If this routine is called on a ISR (Hard IRQ) or DSR (Soft IRQ)\n         * or tasklet use the netif_rx to deliver the packet to the stack\n         * netif_rx will queue the packet onto the receive queue and mark\n         * the softirq thread has a pending action to complete. Kernel will \n         * schedule the softIrq kernel thread after processing the DSR.\n         *\n         * If this routine is called on a process context, use netif_rx_ni\n         * which will schedle the softIrq kernel thread after queuing the packet.\n         */\n            if (in_interrupt()) {\n                netif_rx(skb);\n            } else {\n                netif_rx_ni(skb);\n            }\n        } else {\n            A_NETBUF_FREE(skb);\n        }\n    }\n}\n\n#if 0\nstatic void\nar6000_deliver_frames_to_bt_stack(void *dev, void *osbuf)\n{\n    struct sk_buff *skb = (struct sk_buff *)osbuf;\n\n    if(skb) {\n        skb->dev = dev;\n        if ((skb->dev->flags & IFF_UP) == IFF_UP) {\n            skb->protocol = htons(ETH_P_CONTROL);\n            netif_rx(skb);\n        } else {\n            A_NETBUF_FREE(skb);\n        }\n    }\n}\n#endif\n\nstatic void\nar6000_rx_refill(void *Context, HTC_ENDPOINT_ID Endpoint)\n{\n    struct ar6_softc  *ar = (struct ar6_softc *)Context;\n    void        *osBuf;\n    int         RxBuffers;\n    int         buffersToRefill;\n    struct htc_packet  *pPacket;\n    struct htc_packet_queue queue;\n\n    buffersToRefill = (int)AR6000_MAX_RX_BUFFERS -\n                                    HTCGetNumRecvBuffers(ar->arHtcTarget, Endpoint);\n\n    if (buffersToRefill <= 0) {\n            /* fast return, nothing to fill */\n        return;\n    }\n\n    INIT_HTC_PACKET_QUEUE(&queue);\n\n    AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_RX,(\"ar6000_rx_refill: providing htc with %d buffers at eid=%d\\n\",\n                    buffersToRefill, Endpoint));\n\n    for (RxBuffers = 0; RxBuffers < buffersToRefill; RxBuffers++) {\n        osBuf = A_NETBUF_ALLOC(AR6000_BUFFER_SIZE);\n        if (NULL == osBuf) {\n            break;\n        }\n            /* the HTC packet wrapper is at the head of the reserved area\n             * in the skb */\n        pPacket = (struct htc_packet *)(A_NETBUF_HEAD(osBuf));\n            /* set re-fill info */\n        SET_HTC_PACKET_INFO_RX_REFILL(pPacket,osBuf,A_NETBUF_DATA(osBuf),AR6000_BUFFER_SIZE,Endpoint);\n            /* add to queue */\n        HTC_PACKET_ENQUEUE(&queue,pPacket);\n    }\n\n    if (!HTC_QUEUE_EMPTY(&queue)) {\n            /* add packets */\n        HTCAddReceivePktMultiple(ar->arHtcTarget, &queue);\n    }\n\n}\n\n  /* clean up our amsdu buffer list */\nstatic void ar6000_cleanup_amsdu_rxbufs(struct ar6_softc *ar)\n{\n    struct htc_packet  *pPacket;\n    void        *osBuf;\n\n        /* empty AMSDU buffer queue and free OS bufs */\n    while (true) {\n\n        AR6000_SPIN_LOCK(&ar->arLock, 0);\n        pPacket = HTC_PACKET_DEQUEUE(&ar->amsdu_rx_buffer_queue);\n        AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n\n        if (NULL == pPacket) {\n            break;\n        }\n\n        osBuf = pPacket->pPktContext;\n        if (NULL == osBuf) {\n            A_ASSERT(false);\n            break;\n        }\n\n        A_NETBUF_FREE(osBuf);\n    }\n\n}\n\n\n    /* refill the amsdu buffer list */\nstatic void ar6000_refill_amsdu_rxbufs(struct ar6_softc *ar, int Count)\n{\n    struct htc_packet  *pPacket;\n    void        *osBuf;\n\n    while (Count > 0) {\n        osBuf = A_NETBUF_ALLOC(AR6000_AMSDU_BUFFER_SIZE);\n        if (NULL == osBuf) {\n            break;\n        }\n            /* the HTC packet wrapper is at the head of the reserved area\n             * in the skb */\n        pPacket = (struct htc_packet *)(A_NETBUF_HEAD(osBuf));\n            /* set re-fill info */\n        SET_HTC_PACKET_INFO_RX_REFILL(pPacket,osBuf,A_NETBUF_DATA(osBuf),AR6000_AMSDU_BUFFER_SIZE,0);\n\n        AR6000_SPIN_LOCK(&ar->arLock, 0);\n            /* put it in the list */\n        HTC_PACKET_ENQUEUE(&ar->amsdu_rx_buffer_queue,pPacket);\n        AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n        Count--;\n    }\n\n}\n\n    /* callback to allocate a large receive buffer for a pending packet.  This function is called when\n     * an HTC packet arrives whose length exceeds a threshold value\n     *\n     * We use a pre-allocated list of buffers of maximum AMSDU size (4K).  Under linux it is more optimal to\n     * keep the allocation size the same to optimize cached-slab allocations.\n     *\n     * */\nstatic struct htc_packet *ar6000_alloc_amsdu_rxbuf(void *Context, HTC_ENDPOINT_ID Endpoint, int Length)\n{\n    struct htc_packet  *pPacket = NULL;\n    struct ar6_softc  *ar = (struct ar6_softc *)Context;\n    int         refillCount = 0;\n\n    AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_RX,(\"ar6000_alloc_amsdu_rxbuf: eid=%d, Length:%d\\n\",Endpoint,Length));\n\n    do {\n\n        if (Length <= AR6000_BUFFER_SIZE) {\n                /* shouldn't be getting called on normal sized packets */\n            A_ASSERT(false);\n            break;\n        }\n\n        if (Length > AR6000_AMSDU_BUFFER_SIZE) {\n            A_ASSERT(false);\n            break;\n        }\n\n        AR6000_SPIN_LOCK(&ar->arLock, 0);\n            /* allocate a packet from the list */\n        pPacket = HTC_PACKET_DEQUEUE(&ar->amsdu_rx_buffer_queue);\n            /* see if we need to refill again */\n        refillCount = AR6000_MAX_AMSDU_RX_BUFFERS - HTC_PACKET_QUEUE_DEPTH(&ar->amsdu_rx_buffer_queue);\n        AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n\n        if (NULL == pPacket) {\n            break;\n        }\n            /* set actual endpoint ID */\n        pPacket->Endpoint = Endpoint;\n\n    } while (false);\n\n    if (refillCount >= AR6000_AMSDU_REFILL_THRESHOLD) {\n        ar6000_refill_amsdu_rxbufs(ar,refillCount);\n    }\n\n    return pPacket;\n}\n\nstatic void\t\nar6000_set_multicast_list(struct net_device *dev)\n{\n    AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000: Multicast filter not supported\\n\"));\n}\n\nstatic struct net_device_stats *\nar6000_get_stats(struct net_device *dev)\n{\n    struct ar6_softc *ar = (struct ar6_softc *)ar6k_priv(dev);\n    return &ar->arNetStats;\n}\n\nvoid\nar6000_ready_event(void *devt, u8 *datap, u8 phyCap, u32 sw_ver, u32 abi_ver)\n{\n    struct ar6_softc *ar = (struct ar6_softc *)devt;\n    struct net_device *dev = ar->arNetDev;\n\n    memcpy(dev->dev_addr, datap, AR6000_ETH_ADDR_LEN);\n    AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"mac address = %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x\\n\",\n        dev->dev_addr[0], dev->dev_addr[1],\n        dev->dev_addr[2], dev->dev_addr[3],\n        dev->dev_addr[4], dev->dev_addr[5]));\n\n    ar->arPhyCapability = phyCap;\n    ar->arVersion.wlan_ver = sw_ver;\n    ar->arVersion.abi_ver = abi_ver;\n\n    /* Indicate to the waiting thread that the ready event was received */\n    ar->arWmiReady = true;\n    wake_up(&arEvent);\n}\n\nvoid ar6000_install_static_wep_keys(struct ar6_softc *ar)\n{\n    u8 index;\n    u8 keyUsage;\n\n    for (index = WMI_MIN_KEY_INDEX; index <= WMI_MAX_KEY_INDEX; index++) {\n        if (ar->arWepKeyList[index].arKeyLen) {\n            keyUsage = GROUP_USAGE;\n            if (index == ar->arDefTxKeyIndex) {\n                keyUsage |= TX_USAGE;\n            }\n            wmi_addKey_cmd(ar->arWmi,\n                           index,\n                           WEP_CRYPT,\n                           keyUsage,\n                           ar->arWepKeyList[index].arKeyLen,\n                           NULL,\n                           ar->arWepKeyList[index].arKey, KEY_OP_INIT_VAL, NULL,\n                           NO_SYNC_WMIFLAG);\n        }\n    }\n}\n\nvoid\nadd_new_sta(struct ar6_softc *ar, u8 *mac, u16 aid, u8 *wpaie,\n            u8 ielen, u8 keymgmt, u8 ucipher, u8 auth)\n{\n    u8 free_slot=aid-1;\n\n        memcpy(ar->sta_list[free_slot].mac, mac, ATH_MAC_LEN);\n        memcpy(ar->sta_list[free_slot].wpa_ie, wpaie, ielen);\n        ar->sta_list[free_slot].aid = aid;\n        ar->sta_list[free_slot].keymgmt = keymgmt;\n        ar->sta_list[free_slot].ucipher = ucipher;\n        ar->sta_list[free_slot].auth = auth;\n        ar->sta_list_index = ar->sta_list_index | (1 << free_slot);\n    ar->arAPStats.sta[free_slot].aid = aid;\n}\n\nvoid\nar6000_connect_event(struct ar6_softc *ar, u16 channel, u8 *bssid,\n                     u16 listenInterval, u16 beaconInterval,\n                     NETWORK_TYPE networkType, u8 beaconIeLen,\n                     u8 assocReqLen, u8 assocRespLen,\n                     u8 *assocInfo)\n{\n    union iwreq_data wrqu;\n    int i, beacon_ie_pos, assoc_resp_ie_pos, assoc_req_ie_pos;\n    static const char *tag1 = \"ASSOCINFO(ReqIEs=\";\n    static const char *tag2 = \"ASSOCRESPIE=\";\n    static const char *beaconIetag = \"BEACONIE=\";\n    char buf[WMI_CONTROL_MSG_MAX_LEN * 2 + strlen(tag1) + 1];\n    char *pos;\n    u8 key_op_ctrl;\n    unsigned long flags;\n    struct ieee80211req_key *ik;\n    CRYPTO_TYPE keyType = NONE_CRYPT;\n\n    if(ar->arNetworkType & AP_NETWORK) {\n        struct net_device *dev = ar->arNetDev;\n        if(memcmp(dev->dev_addr, bssid, ATH_MAC_LEN)==0) {\n            ar->arACS = channel;\n            ik = &ar->ap_mode_bkey;\n\n            switch(ar->arAuthMode) {\n            case NONE_AUTH:\n                if(ar->arPairwiseCrypto == WEP_CRYPT) {\n                    ar6000_install_static_wep_keys(ar);\n                }\n#ifdef WAPI_ENABLE\n                else if(ar->arPairwiseCrypto == WAPI_CRYPT) {\n                    ap_set_wapi_key(ar, ik);\n                }\n#endif\n                break;\n            case WPA_PSK_AUTH:\n            case WPA2_PSK_AUTH:\n            case (WPA_PSK_AUTH|WPA2_PSK_AUTH):\n                switch (ik->ik_type) {\n                    case IEEE80211_CIPHER_TKIP:\n                        keyType = TKIP_CRYPT;\n                        break;\n                    case IEEE80211_CIPHER_AES_CCM:\n                        keyType = AES_CRYPT;\n                        break;\n                    default:\n                       goto skip_key;\n                }\n                wmi_addKey_cmd(ar->arWmi, ik->ik_keyix, keyType, GROUP_USAGE,\n                                ik->ik_keylen, (u8 *)&ik->ik_keyrsc,\n                                ik->ik_keydata, KEY_OP_INIT_VAL, ik->ik_macaddr,\n                                SYNC_BOTH_WMIFLAG);\n\n                break;\n            }\nskip_key:\n            ar->arConnected  = true;\n            return;\n        }\n\n        A_PRINTF(\"NEW STA %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x \\n \"\n            \" AID=%d \\n\", bssid[0], bssid[1], bssid[2],\n             bssid[3], bssid[4], bssid[5], channel);\n        switch ((listenInterval>>8)&0xFF) {\n            case OPEN_AUTH:\n                A_PRINTF(\"AUTH: OPEN\\n\");\n                break;\n            case SHARED_AUTH:\n                A_PRINTF(\"AUTH: SHARED\\n\");\n                break;\n            default:\n                A_PRINTF(\"AUTH: Unknown\\n\");\n                break;\n        }\n        switch (listenInterval&0xFF) {\n            case WPA_PSK_AUTH:\n                A_PRINTF(\"KeyMgmt: WPA-PSK\\n\");\n                break;\n            case WPA2_PSK_AUTH:\n                A_PRINTF(\"KeyMgmt: WPA2-PSK\\n\");\n                break;\n            default:\n                A_PRINTF(\"KeyMgmt: NONE\\n\");\n                break;\n        }\n        switch (beaconInterval) {\n            case AES_CRYPT:\n                A_PRINTF(\"Cipher: AES\\n\");\n                break;\n            case TKIP_CRYPT:\n                A_PRINTF(\"Cipher: TKIP\\n\");\n                break;\n            case WEP_CRYPT:\n                A_PRINTF(\"Cipher: WEP\\n\");\n                break;\n#ifdef WAPI_ENABLE\n            case WAPI_CRYPT:\n                A_PRINTF(\"Cipher: WAPI\\n\");\n                break;\n#endif\n            default:\n                A_PRINTF(\"Cipher: NONE\\n\");\n                break;\n        }\n\n        add_new_sta(ar, bssid, channel /*aid*/,\n            assocInfo /* WPA IE */, assocRespLen /* IE len */,\n            listenInterval&0xFF /* Keymgmt */, beaconInterval /* cipher */,\n            (listenInterval>>8)&0xFF /* auth alg */);\n\n        /* Send event to application */\n        A_MEMZERO(&wrqu, sizeof(wrqu));\n        memcpy(wrqu.addr.sa_data, bssid, ATH_MAC_LEN);\n        wireless_send_event(ar->arNetDev, IWEVREGISTERED, &wrqu, NULL);\n        /* In case the queue is stopped when we switch modes, this will\n         * wake it up\n         */\n        netif_wake_queue(ar->arNetDev);\n        return;\n    }\n\n    ar6k_cfg80211_connect_event(ar, channel, bssid,\n                                listenInterval, beaconInterval,\n                                networkType, beaconIeLen,\n                                assocReqLen, assocRespLen,\n                                assocInfo);\n\n    memcpy(ar->arBssid, bssid, sizeof(ar->arBssid));\n    ar->arBssChannel = channel;\n\n    A_PRINTF(\"AR6000 connected event on freq %d \", channel);\n    A_PRINTF(\"with bssid %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x \"\n            \" listenInterval=%d, beaconInterval = %d, beaconIeLen = %d assocReqLen=%d\"\n            \" assocRespLen =%d\\n\",\n             bssid[0], bssid[1], bssid[2],\n             bssid[3], bssid[4], bssid[5],\n             listenInterval, beaconInterval,\n             beaconIeLen, assocReqLen, assocRespLen);\n    if (networkType & ADHOC_NETWORK) {\n        if (networkType & ADHOC_CREATOR) {\n            A_PRINTF(\"Network: Adhoc (Creator)\\n\");\n        } else {\n            A_PRINTF(\"Network: Adhoc (Joiner)\\n\");\n        }\n    } else {\n        A_PRINTF(\"Network: Infrastructure\\n\");\n    }\n\n    if ((ar->arNetworkType == INFRA_NETWORK)) {\n        wmi_listeninterval_cmd(ar->arWmi, ar->arListenIntervalT, ar->arListenIntervalB);\n    }\n\n    if (beaconIeLen && (sizeof(buf) > (9 + beaconIeLen * 2))) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"\\nBeaconIEs= \"));\n\n        beacon_ie_pos = 0;\n        A_MEMZERO(buf, sizeof(buf));\n        sprintf(buf, \"%s\", beaconIetag);\n        pos = buf + 9;\n        for (i = beacon_ie_pos; i < beacon_ie_pos + beaconIeLen; i++) {\n            AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"%2.2x \", assocInfo[i]));\n            sprintf(pos, \"%2.2x\", assocInfo[i]);\n            pos += 2;\n        }\n        AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"\\n\"));\n\n        A_MEMZERO(&wrqu, sizeof(wrqu));\n        wrqu.data.length = strlen(buf);\n        wireless_send_event(ar->arNetDev, IWEVCUSTOM, &wrqu, buf);\n    }\n\n    if (assocRespLen && (sizeof(buf) > (12 + (assocRespLen * 2))))\n    {\n        assoc_resp_ie_pos = beaconIeLen + assocReqLen +\n                            sizeof(u16)  +  /* capinfo*/\n                            sizeof(u16)  +  /* status Code */\n                            sizeof(u16)  ;  /* associd */\n        A_MEMZERO(buf, sizeof(buf));\n        sprintf(buf, \"%s\", tag2);\n        pos = buf + 12;\n        AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"\\nAssocRespIEs= \"));\n        /*\n         * The Association Response Frame w.o. the WLAN header is delivered to\n         * the host, so skip over to the IEs\n         */\n        for (i = assoc_resp_ie_pos; i < assoc_resp_ie_pos + assocRespLen - 6; i++)\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"%2.2x \", assocInfo[i]));\n            sprintf(pos, \"%2.2x\", assocInfo[i]);\n            pos += 2;\n        }\n        AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"\\n\"));\n\n        A_MEMZERO(&wrqu, sizeof(wrqu));\n        wrqu.data.length = strlen(buf);\n        wireless_send_event(ar->arNetDev, IWEVCUSTOM, &wrqu, buf);\n    }\n\n    if (assocReqLen && (sizeof(buf) > (17 + (assocReqLen * 2)))) {\n        /*\n         * assoc Request includes capability and listen interval. Skip these.\n         */\n        assoc_req_ie_pos =  beaconIeLen +\n                            sizeof(u16)  +  /* capinfo*/\n                            sizeof(u16);    /* listen interval */\n\n        A_MEMZERO(buf, sizeof(buf));\n        sprintf(buf, \"%s\", tag1);\n        pos = buf + 17;\n        AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"AssocReqIEs= \"));\n        for (i = assoc_req_ie_pos; i < assoc_req_ie_pos + assocReqLen - 4; i++) {\n            AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"%2.2x \", assocInfo[i]));\n            sprintf(pos, \"%2.2x\", assocInfo[i]);\n            pos += 2;\n        }\n        AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"\\n\"));\n\n        A_MEMZERO(&wrqu, sizeof(wrqu));\n        wrqu.data.length = strlen(buf);\n        wireless_send_event(ar->arNetDev, IWEVCUSTOM, &wrqu, buf);\n    }\n\n    if (ar->user_savedkeys_stat == USER_SAVEDKEYS_STAT_RUN &&\n        ar->user_saved_keys.keyOk == true)\n    {\n        key_op_ctrl = KEY_OP_VALID_MASK & ~KEY_OP_INIT_TSC;\n\n        if (ar->user_key_ctrl & AR6000_USER_SETKEYS_RSC_UNCHANGED) {\n            key_op_ctrl &= ~KEY_OP_INIT_RSC;\n        } else {\n            key_op_ctrl |= KEY_OP_INIT_RSC;\n        }\n        ar6000_reinstall_keys(ar, key_op_ctrl);\n    }\n\n    netif_wake_queue(ar->arNetDev);\n\n    /* Update connect & link status atomically */\n    spin_lock_irqsave(&ar->arLock, flags);\n    ar->arConnected  = true;\n    ar->arConnectPending = false;\n    netif_carrier_on(ar->arNetDev);\n    spin_unlock_irqrestore(&ar->arLock, flags);\n    /* reset the rx aggr state */\n    aggr_reset_state(ar->aggr_cntxt);\n    reconnect_flag = 0;\n\n    A_MEMZERO(&wrqu, sizeof(wrqu));\n    memcpy(wrqu.addr.sa_data, bssid, IEEE80211_ADDR_LEN);\n    wrqu.addr.sa_family = ARPHRD_ETHER;\n    wireless_send_event(ar->arNetDev, SIOCGIWAP, &wrqu, NULL);\n    if ((ar->arNetworkType == ADHOC_NETWORK) && ar->arIbssPsEnable) {\n        A_MEMZERO(ar->arNodeMap, sizeof(ar->arNodeMap));\n        ar->arNodeNum = 0;\n        ar->arNexEpId = ENDPOINT_2;\n    }\n   if (!ar->arUserBssFilter) {\n        wmi_bssfilter_cmd(ar->arWmi, NONE_BSS_FILTER, 0);\n   }\n\n}\n\nvoid ar6000_set_numdataendpts(struct ar6_softc *ar, u32 num)\n{\n    A_ASSERT(num <= (HTC_MAILBOX_NUM_MAX - 1));\n    ar->arNumDataEndPts = num;\n}\n\nvoid\nsta_cleanup(struct ar6_softc *ar, u8 i)\n{\n    struct sk_buff *skb;\n\n    /* empty the queued pkts in the PS queue if any */\n    A_MUTEX_LOCK(&ar->sta_list[i].psqLock);\n    while (!A_NETBUF_QUEUE_EMPTY(&ar->sta_list[i].psq)) {\n        skb = A_NETBUF_DEQUEUE(&ar->sta_list[i].psq);\n        A_NETBUF_FREE(skb);\n    }\n    A_MUTEX_UNLOCK(&ar->sta_list[i].psqLock);\n\n    /* Zero out the state fields */\n    A_MEMZERO(&ar->arAPStats.sta[ar->sta_list[i].aid-1], sizeof(WMI_PER_STA_STAT));\n    A_MEMZERO(&ar->sta_list[i].mac, ATH_MAC_LEN);\n    A_MEMZERO(&ar->sta_list[i].wpa_ie, IEEE80211_MAX_IE);\n    ar->sta_list[i].aid = 0;\n    ar->sta_list[i].flags = 0;\n\n    ar->sta_list_index = ar->sta_list_index & ~(1 << i);\n\n}\n\nu8 remove_sta(struct ar6_softc *ar, u8 *mac, u16 reason)\n{\n    u8 i, removed=0;\n\n    if(IS_MAC_NULL(mac)) {\n        return removed;\n    }\n\n    if(IS_MAC_BCAST(mac)) {\n        A_PRINTF(\"DEL ALL STA\\n\");\n        for(i=0; i < AP_MAX_NUM_STA; i++) {\n            if(!IS_MAC_NULL(ar->sta_list[i].mac)) {\n                sta_cleanup(ar, i);\n                removed = 1;\n            }\n        }\n    } else {\n        for(i=0; i < AP_MAX_NUM_STA; i++) {\n            if(memcmp(ar->sta_list[i].mac, mac, ATH_MAC_LEN)==0) {\n                A_PRINTF(\"DEL STA %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x \"\n                \" aid=%d REASON=%d\\n\", mac[0], mac[1], mac[2],\n                 mac[3], mac[4], mac[5], ar->sta_list[i].aid, reason);\n\n                sta_cleanup(ar, i);\n                removed = 1;\n                break;\n            }\n        }\n    }\n    return removed;\n}\n\nvoid\nar6000_disconnect_event(struct ar6_softc *ar, u8 reason, u8 *bssid,\n                        u8 assocRespLen, u8 *assocInfo, u16 protocolReasonStatus)\n{\n    u8 i;\n    unsigned long flags;\n    union iwreq_data wrqu;\n\n    if(ar->arNetworkType & AP_NETWORK) {\n        union iwreq_data wrqu;\n        struct sk_buff *skb;\n\n        if(!remove_sta(ar, bssid, protocolReasonStatus)) {\n            return;\n        }\n\n        /* If there are no more associated STAs, empty the mcast PS q */\n        if (ar->sta_list_index == 0) {\n            A_MUTEX_LOCK(&ar->mcastpsqLock);\n            while (!A_NETBUF_QUEUE_EMPTY(&ar->mcastpsq)) {\n                skb = A_NETBUF_DEQUEUE(&ar->mcastpsq);\n                A_NETBUF_FREE(skb);\n            }\n            A_MUTEX_UNLOCK(&ar->mcastpsqLock);\n\n            /* Clear the LSB of the BitMapCtl field of the TIM IE */\n            if (ar->arWmiReady) {\n                wmi_set_pvb_cmd(ar->arWmi, MCAST_AID, 0);\n            }\n        }\n\n        if(!IS_MAC_BCAST(bssid)) {\n            /* Send event to application */\n            A_MEMZERO(&wrqu, sizeof(wrqu));\n            memcpy(wrqu.addr.sa_data, bssid, ATH_MAC_LEN);\n            wireless_send_event(ar->arNetDev, IWEVEXPIRED, &wrqu, NULL);\n        }\n\n        ar->arConnected = false;\n        return;\n    }\n\n    ar6k_cfg80211_disconnect_event(ar, reason, bssid,\n                                   assocRespLen, assocInfo,\n                                   protocolReasonStatus);\n\n    /* Send disconnect event to supplicant */\n    A_MEMZERO(&wrqu, sizeof(wrqu));\n    wrqu.addr.sa_family = ARPHRD_ETHER;\n    wireless_send_event(ar->arNetDev, SIOCGIWAP, &wrqu, NULL);\n\n    /* it is necessary to clear the host-side rx aggregation state */\n    aggr_reset_state(ar->aggr_cntxt);\n\n    A_UNTIMEOUT(&ar->disconnect_timer);\n\n    A_PRINTF(\"AR6000 disconnected\");\n    if (bssid[0] || bssid[1] || bssid[2] || bssid[3] || bssid[4] || bssid[5]) {\n        A_PRINTF(\" from %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x \",\n                 bssid[0], bssid[1], bssid[2], bssid[3], bssid[4], bssid[5]);\n    }\n\n    AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"\\nDisconnect Reason is %d\", reason));\n    AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"\\nProtocol Reason/Status Code is %d\", protocolReasonStatus));\n    AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"\\nAssocResp Frame = %s\",\n                    assocRespLen ? \" \" : \"NULL\"));\n    for (i = 0; i < assocRespLen; i++) {\n        if (!(i % 0x10)) {\n            AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"\\n\"));\n        }\n        AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"%2.2x \", assocInfo[i]));\n    }\n    AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"\\n\"));\n    /*\n     * If the event is due to disconnect cmd from the host, only they the target\n     * would stop trying to connect. Under any other condition, target would\n     * keep trying to connect.\n     *\n     */\n    if( reason == DISCONNECT_CMD)\n    {\n        if ((!ar->arUserBssFilter) && (ar->arWmiReady)) {\n            wmi_bssfilter_cmd(ar->arWmi, NONE_BSS_FILTER, 0);\n        }\n    } else {\n        ar->arConnectPending = true;\n        if (((reason == ASSOC_FAILED) && (protocolReasonStatus == 0x11)) ||\n            ((reason == ASSOC_FAILED) && (protocolReasonStatus == 0x0) && (reconnect_flag == 1))) {\n            ar->arConnected = true;\n            return;\n        }\n    }\n\n    if ((reason == NO_NETWORK_AVAIL) && (ar->arWmiReady)) \n    {\n        bss_t *pWmiSsidnode = NULL;\n\n        /* remove the current associated bssid node */\n        wmi_free_node (ar->arWmi, bssid);\n\n        /*\n         * In case any other same SSID nodes are present\n         * remove it, since those nodes also not available now\n         */\n        do\n        {\n            /*\n             * Find the nodes based on SSID and remove it\n             * NOTE :: This case will not work out for Hidden-SSID\n             */\n            pWmiSsidnode = wmi_find_Ssidnode (ar->arWmi, ar->arSsid, ar->arSsidLen, false, true);\n\n            if (pWmiSsidnode)\n            {\n                wmi_free_node (ar->arWmi, pWmiSsidnode->ni_macaddr);\n            }\n\n        } while (pWmiSsidnode);\n    }\n\n    /* Update connect & link status atomically */\n    spin_lock_irqsave(&ar->arLock, flags);\n    ar->arConnected = false;\n    netif_carrier_off(ar->arNetDev);\n    spin_unlock_irqrestore(&ar->arLock, flags);\n\n    if( (reason != CSERV_DISCONNECT) || (reconnect_flag != 1) ) {\n        reconnect_flag = 0;\n    }\n\n    if (reason != CSERV_DISCONNECT)\n    {\n        ar->user_savedkeys_stat = USER_SAVEDKEYS_STAT_INIT;\n        ar->user_key_ctrl      = 0;\n    }\n\n    netif_stop_queue(ar->arNetDev);\n    A_MEMZERO(ar->arBssid, sizeof(ar->arBssid));\n    ar->arBssChannel = 0;\n    ar->arBeaconInterval = 0;\n\n    ar6000_TxDataCleanup(ar);\n}\n\nvoid\nar6000_regDomain_event(struct ar6_softc *ar, u32 regCode)\n{\n    A_PRINTF(\"AR6000 Reg Code = 0x%x\\n\", regCode);\n    ar->arRegCode = regCode;\n}\n\nvoid\nar6000_aggr_rcv_addba_req_evt(struct ar6_softc *ar, WMI_ADDBA_REQ_EVENT *evt)\n{\n    if(evt->status == 0) {\n        aggr_recv_addba_req_evt(ar->aggr_cntxt, evt->tid, evt->st_seq_no, evt->win_sz);\n    }\n}\n\nvoid\nar6000_aggr_rcv_addba_resp_evt(struct ar6_softc *ar, WMI_ADDBA_RESP_EVENT *evt)\n{\n    A_PRINTF(\"ADDBA RESP. tid %d status %d, sz %d\\n\", evt->tid, evt->status, evt->amsdu_sz);\n    if(evt->status == 0) {\n    }\n}\n\nvoid\nar6000_aggr_rcv_delba_req_evt(struct ar6_softc *ar, WMI_DELBA_EVENT *evt)\n{\n    aggr_recv_delba_req_evt(ar->aggr_cntxt, evt->tid);\n}\n\nvoid register_pal_cb(ar6k_pal_config_t *palConfig_p)\n{\n  ar6k_pal_config_g = *palConfig_p;\n}\n\nvoid\nar6000_hci_event_rcv_evt(struct ar6_softc *ar, WMI_HCI_EVENT *cmd)\n{\n    void *osbuf = NULL;\n    s8 i;\n    u8 size, *buf;\n    int ret = 0;\n\n    size = cmd->evt_buf_sz + 4;\n    osbuf = A_NETBUF_ALLOC(size);\n    if (osbuf == NULL) {\n       ret = A_NO_MEMORY;\n       A_PRINTF(\"Error in allocating netbuf \\n\");\n       return;\n    }\n\n    A_NETBUF_PUT(osbuf, size);\n    buf = (u8 *)A_NETBUF_DATA(osbuf);\n    /* First 2-bytes carry HCI event/ACL data type\n     * the next 2 are free\n     */\n    *((short *)buf) = WMI_HCI_EVENT_EVENTID;\n    buf += sizeof(int);\n    memcpy(buf, cmd->buf, cmd->evt_buf_sz);\n\n    ar6000_deliver_frames_to_nw_stack(ar->arNetDev, osbuf);\n    if(loghci) {\n        A_PRINTF_LOG(\"HCI Event From PAL <-- \\n\");\n        for(i = 0; i < cmd->evt_buf_sz; i++) {\n           A_PRINTF_LOG(\"0x%02x \", cmd->buf[i]);\n           if((i % 10) == 0) {\n               A_PRINTF_LOG(\"\\n\");\n           }\n        }\n        A_PRINTF_LOG(\"\\n\");\n        A_PRINTF_LOG(\"==================================\\n\");\n    }\n}\n\nvoid\nar6000_neighborReport_event(struct ar6_softc *ar, int numAps, WMI_NEIGHBOR_INFO *info)\n{\n#if WIRELESS_EXT >= 18\n    struct iw_pmkid_cand *pmkcand;\n#else /* WIRELESS_EXT >= 18 */\n    static const char *tag = \"PRE-AUTH\";\n    char buf[128];\n#endif /* WIRELESS_EXT >= 18 */\n\n    union iwreq_data wrqu;\n    int i;\n\n    AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_SCAN,(\"AR6000 Neighbor Report Event\\n\"));\n    for (i=0; i < numAps; info++, i++) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_SCAN,(\"bssid %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x \",\n            info->bssid[0], info->bssid[1], info->bssid[2],\n            info->bssid[3], info->bssid[4], info->bssid[5]));\n        if (info->bssFlags & WMI_PREAUTH_CAPABLE_BSS) {\n            AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_SCAN,(\"preauth-cap\"));\n        }\n        if (info->bssFlags & WMI_PMKID_VALID_BSS) {\n            AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_SCAN,(\" pmkid-valid\\n\"));\n            continue;           /* we skip bss if the pmkid is already valid */\n        }\n        AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_SCAN,(\"\\n\"));\n        A_MEMZERO(&wrqu, sizeof(wrqu));\n#if WIRELESS_EXT >= 18\n        pmkcand = A_MALLOC_NOWAIT(sizeof(struct iw_pmkid_cand));\n        A_MEMZERO(pmkcand, sizeof(struct iw_pmkid_cand));\n        pmkcand->index = i;\n        pmkcand->flags = info->bssFlags;\n        memcpy(pmkcand->bssid.sa_data, info->bssid, ATH_MAC_LEN);\n        wrqu.data.length = sizeof(struct iw_pmkid_cand);\n        wireless_send_event(ar->arNetDev, IWEVPMKIDCAND, &wrqu, (char *)pmkcand);\n        kfree(pmkcand);\n#else /* WIRELESS_EXT >= 18 */\n        snprintf(buf, sizeof(buf), \"%s%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x%2.2x\",\n                 tag,\n                 info->bssid[0], info->bssid[1], info->bssid[2],\n                 info->bssid[3], info->bssid[4], info->bssid[5],\n                 i, info->bssFlags);\n        wrqu.data.length = strlen(buf);\n        wireless_send_event(ar->arNetDev, IWEVCUSTOM, &wrqu, buf);\n#endif /* WIRELESS_EXT >= 18 */\n    }\n}\n\nvoid\nar6000_tkip_micerr_event(struct ar6_softc *ar, u8 keyid, bool ismcast)\n{\n    static const char *tag = \"MLME-MICHAELMICFAILURE.indication\";\n    char buf[128];\n    union iwreq_data wrqu;\n\n    /*\n     * For AP case, keyid will have aid of STA which sent pkt with\n     * MIC error. Use this aid to get MAC & send it to hostapd.\n     */\n    if (ar->arNetworkType == AP_NETWORK) {\n        sta_t *s = ieee80211_find_conn_for_aid(ar, (keyid >> 2));\n        if(!s){\n            A_PRINTF(\"AP TKIP MIC error received from Invalid aid / STA not found =%d\\n\", keyid);\n            return;\n        }\n        A_PRINTF(\"AP TKIP MIC error received from aid=%d\\n\", keyid);\n        snprintf(buf,sizeof(buf), \"%s addr=%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x\",\n            tag, s->mac[0],s->mac[1],s->mac[2],s->mac[3],s->mac[4],s->mac[5]);\n    } else {\n\n    ar6k_cfg80211_tkip_micerr_event(ar, keyid, ismcast);\n\n        A_PRINTF(\"AR6000 TKIP MIC error received for keyid %d %scast\\n\",\n             keyid & 0x3, ismcast ? \"multi\": \"uni\");\n        snprintf(buf, sizeof(buf), \"%s(keyid=%d %sicast)\", tag, keyid & 0x3,\n             ismcast ? \"mult\" : \"un\");\n    }\n\n    memset(&wrqu, 0, sizeof(wrqu));\n    wrqu.data.length = strlen(buf);\n    wireless_send_event(ar->arNetDev, IWEVCUSTOM, &wrqu, buf);\n}\n\nvoid\nar6000_scanComplete_event(struct ar6_softc *ar, int status)\n{\n\n    ar6k_cfg80211_scanComplete_event(ar, status);\n\n    if (!ar->arUserBssFilter) {\n        wmi_bssfilter_cmd(ar->arWmi, NONE_BSS_FILTER, 0);\n    }\n    if (ar->scan_triggered) {\n        if (status== 0) {\n            union iwreq_data wrqu;\n            A_MEMZERO(&wrqu, sizeof(wrqu));\n            wireless_send_event(ar->arNetDev, SIOCGIWSCAN, &wrqu, NULL);\n        }\n        ar->scan_triggered = 0;\n    }\n\n    AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_SCAN,( \"AR6000 scan complete: %d\\n\", status));\n}\n\nvoid\nar6000_targetStats_event(struct ar6_softc *ar,  u8 *ptr, u32 len)\n{\n    u8 ac;\n\n    if(ar->arNetworkType == AP_NETWORK) {\n        WMI_AP_MODE_STAT *p = (WMI_AP_MODE_STAT *)ptr;\n        WMI_AP_MODE_STAT *ap = &ar->arAPStats;\n\n        if (len < sizeof(*p)) {\n            return;\n        }\n\n        for(ac=0;ac<AP_MAX_NUM_STA;ac++) {\n            ap->sta[ac].tx_bytes   += p->sta[ac].tx_bytes;\n            ap->sta[ac].tx_pkts    += p->sta[ac].tx_pkts;\n            ap->sta[ac].tx_error   += p->sta[ac].tx_error;\n            ap->sta[ac].tx_discard += p->sta[ac].tx_discard;\n            ap->sta[ac].rx_bytes   += p->sta[ac].rx_bytes;\n            ap->sta[ac].rx_pkts    += p->sta[ac].rx_pkts;\n            ap->sta[ac].rx_error   += p->sta[ac].rx_error;\n            ap->sta[ac].rx_discard += p->sta[ac].rx_discard;\n        }\n\n    } else {\n        WMI_TARGET_STATS *pTarget = (WMI_TARGET_STATS *)ptr;\n         TARGET_STATS *pStats = &ar->arTargetStats;\n\n        if (len < sizeof(*pTarget)) {\n            return;\n        }\n\n        // Update the RSSI of the connected bss.\n        if (ar->arConnected) {\n            bss_t *pConnBss = NULL;\n\n            pConnBss = wmi_find_node(ar->arWmi,ar->arBssid);\n            if (pConnBss)\n            {\n                pConnBss->ni_rssi = pTarget->cservStats.cs_aveBeacon_rssi;\n                pConnBss->ni_snr = pTarget->cservStats.cs_aveBeacon_snr;\n                wmi_node_return(ar->arWmi, pConnBss);\n            }\n        }\n\n        AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"AR6000 updating target stats\\n\"));\n        pStats->tx_packets          += pTarget->txrxStats.tx_stats.tx_packets;\n        pStats->tx_bytes            += pTarget->txrxStats.tx_stats.tx_bytes;\n        pStats->tx_unicast_pkts     += pTarget->txrxStats.tx_stats.tx_unicast_pkts;\n        pStats->tx_unicast_bytes    += pTarget->txrxStats.tx_stats.tx_unicast_bytes;\n        pStats->tx_multicast_pkts   += pTarget->txrxStats.tx_stats.tx_multicast_pkts;\n        pStats->tx_multicast_bytes  += pTarget->txrxStats.tx_stats.tx_multicast_bytes;\n        pStats->tx_broadcast_pkts   += pTarget->txrxStats.tx_stats.tx_broadcast_pkts;\n        pStats->tx_broadcast_bytes  += pTarget->txrxStats.tx_stats.tx_broadcast_bytes;\n        pStats->tx_rts_success_cnt  += pTarget->txrxStats.tx_stats.tx_rts_success_cnt;\n        for(ac = 0; ac < WMM_NUM_AC; ac++)\n            pStats->tx_packet_per_ac[ac] += pTarget->txrxStats.tx_stats.tx_packet_per_ac[ac];\n        pStats->tx_errors           += pTarget->txrxStats.tx_stats.tx_errors;\n        pStats->tx_failed_cnt       += pTarget->txrxStats.tx_stats.tx_failed_cnt;\n        pStats->tx_retry_cnt        += pTarget->txrxStats.tx_stats.tx_retry_cnt;\n        pStats->tx_mult_retry_cnt   += pTarget->txrxStats.tx_stats.tx_mult_retry_cnt;\n        pStats->tx_rts_fail_cnt     += pTarget->txrxStats.tx_stats.tx_rts_fail_cnt;\n        pStats->tx_unicast_rate      = wmi_get_rate(pTarget->txrxStats.tx_stats.tx_unicast_rate);\n\n        pStats->rx_packets          += pTarget->txrxStats.rx_stats.rx_packets;\n        pStats->rx_bytes            += pTarget->txrxStats.rx_stats.rx_bytes;\n        pStats->rx_unicast_pkts     += pTarget->txrxStats.rx_stats.rx_unicast_pkts;\n        pStats->rx_unicast_bytes    += pTarget->txrxStats.rx_stats.rx_unicast_bytes;\n        pStats->rx_multicast_pkts   += pTarget->txrxStats.rx_stats.rx_multicast_pkts;\n        pStats->rx_multicast_bytes  += pTarget->txrxStats.rx_stats.rx_multicast_bytes;\n        pStats->rx_broadcast_pkts   += pTarget->txrxStats.rx_stats.rx_broadcast_pkts;\n        pStats->rx_broadcast_bytes  += pTarget->txrxStats.rx_stats.rx_broadcast_bytes;\n        pStats->rx_fragment_pkt     += pTarget->txrxStats.rx_stats.rx_fragment_pkt;\n        pStats->rx_errors           += pTarget->txrxStats.rx_stats.rx_errors;\n        pStats->rx_crcerr           += pTarget->txrxStats.rx_stats.rx_crcerr;\n        pStats->rx_key_cache_miss   += pTarget->txrxStats.rx_stats.rx_key_cache_miss;\n        pStats->rx_decrypt_err      += pTarget->txrxStats.rx_stats.rx_decrypt_err;\n        pStats->rx_duplicate_frames += pTarget->txrxStats.rx_stats.rx_duplicate_frames;\n        pStats->rx_unicast_rate      = wmi_get_rate(pTarget->txrxStats.rx_stats.rx_unicast_rate);\n\n\n        pStats->tkip_local_mic_failure\n                                += pTarget->txrxStats.tkipCcmpStats.tkip_local_mic_failure;\n        pStats->tkip_counter_measures_invoked\n                                += pTarget->txrxStats.tkipCcmpStats.tkip_counter_measures_invoked;\n        pStats->tkip_replays        += pTarget->txrxStats.tkipCcmpStats.tkip_replays;\n        pStats->tkip_format_errors  += pTarget->txrxStats.tkipCcmpStats.tkip_format_errors;\n        pStats->ccmp_format_errors  += pTarget->txrxStats.tkipCcmpStats.ccmp_format_errors;\n        pStats->ccmp_replays        += pTarget->txrxStats.tkipCcmpStats.ccmp_replays;\n\n        pStats->power_save_failure_cnt += pTarget->pmStats.power_save_failure_cnt;\n        pStats->noise_floor_calibation = pTarget->noise_floor_calibation;\n\n        pStats->cs_bmiss_cnt        += pTarget->cservStats.cs_bmiss_cnt;\n        pStats->cs_lowRssi_cnt      += pTarget->cservStats.cs_lowRssi_cnt;\n        pStats->cs_connect_cnt      += pTarget->cservStats.cs_connect_cnt;\n        pStats->cs_disconnect_cnt   += pTarget->cservStats.cs_disconnect_cnt;\n        pStats->cs_aveBeacon_snr    = pTarget->cservStats.cs_aveBeacon_snr;\n        pStats->cs_aveBeacon_rssi   = pTarget->cservStats.cs_aveBeacon_rssi;\n\n        if (enablerssicompensation) {\n            pStats->cs_aveBeacon_rssi =\n                    rssi_compensation_calc(ar, pStats->cs_aveBeacon_rssi);\n        }\n        pStats->cs_lastRoam_msec    = pTarget->cservStats.cs_lastRoam_msec;\n        pStats->cs_snr              = pTarget->cservStats.cs_snr;\n        pStats->cs_rssi             = pTarget->cservStats.cs_rssi;\n\n        pStats->lq_val              = pTarget->lqVal;\n\n        pStats->wow_num_pkts_dropped += pTarget->wowStats.wow_num_pkts_dropped;\n        pStats->wow_num_host_pkt_wakeups += pTarget->wowStats.wow_num_host_pkt_wakeups;\n        pStats->wow_num_host_event_wakeups += pTarget->wowStats.wow_num_host_event_wakeups;\n        pStats->wow_num_events_discarded += pTarget->wowStats.wow_num_events_discarded;\n        pStats->arp_received += pTarget->arpStats.arp_received;\n        pStats->arp_matched  += pTarget->arpStats.arp_matched;\n        pStats->arp_replied  += pTarget->arpStats.arp_replied;\n\n        if (ar->statsUpdatePending) {\n            ar->statsUpdatePending = false;\n            wake_up(&arEvent);\n        }\n    }\n}\n\nvoid\nar6000_rssiThreshold_event(struct ar6_softc *ar,  WMI_RSSI_THRESHOLD_VAL newThreshold, s16 rssi)\n{\n    USER_RSSI_THOLD userRssiThold;\n\n    rssi = rssi + SIGNAL_QUALITY_NOISE_FLOOR;\n\n    if (enablerssicompensation) {\n        rssi = rssi_compensation_calc(ar, rssi);\n    }\n\n    /* Send an event to the app */\n    userRssiThold.tag = ar->rssi_map[newThreshold].tag;\n    userRssiThold.rssi = rssi;\n    A_PRINTF(\"rssi Threshold range = %d tag = %d  rssi = %d\\n\", newThreshold,\n             userRssiThold.tag, userRssiThold.rssi);\n}\n\n\nvoid\nar6000_hbChallengeResp_event(struct ar6_softc *ar, u32 cookie, u32 source)\n{\n    if (source != APP_HB_CHALLENGE) {\n        /* This would ignore the replys that come in after their due time */\n        if (cookie == ar->arHBChallengeResp.seqNum) {\n            ar->arHBChallengeResp.outstanding = false;\n        }\n    }\n}\n\n\nvoid\nar6000_reportError_event(struct ar6_softc *ar, WMI_TARGET_ERROR_VAL errorVal)\n{\n\tstatic const char * const errString[] = {\n\t\t[WMI_TARGET_PM_ERR_FAIL]    \"WMI_TARGET_PM_ERR_FAIL\",\n\t\t[WMI_TARGET_KEY_NOT_FOUND]  \"WMI_TARGET_KEY_NOT_FOUND\",\n\t\t[WMI_TARGET_DECRYPTION_ERR] \"WMI_TARGET_DECRYPTION_ERR\",\n\t\t[WMI_TARGET_BMISS]          \"WMI_TARGET_BMISS\",\n\t\t[WMI_PSDISABLE_NODE_JOIN]   \"WMI_PSDISABLE_NODE_JOIN\"\n\t};\n\n    A_PRINTF(\"AR6000 Error on Target. Error = 0x%x\\n\", errorVal);\n\n    /* One error is reported at a time, and errorval is a bitmask */\n    if(errorVal & (errorVal - 1))\n       return;\n\n    A_PRINTF(\"AR6000 Error type = \");\n    switch(errorVal)\n    {\n        case WMI_TARGET_PM_ERR_FAIL:\n        case WMI_TARGET_KEY_NOT_FOUND:\n        case WMI_TARGET_DECRYPTION_ERR:\n        case WMI_TARGET_BMISS:\n        case WMI_PSDISABLE_NODE_JOIN:\n            A_PRINTF(\"%s\\n\", errString[errorVal]);\n            break;\n        default:\n            A_PRINTF(\"INVALID\\n\");\n            break;\n    }\n\n}\n\n\nvoid\nar6000_cac_event(struct ar6_softc *ar, u8 ac, u8 cacIndication,\n                 u8 statusCode, u8 *tspecSuggestion)\n{\n    WMM_TSPEC_IE    *tspecIe;\n\n    /*\n     * This is the TSPEC IE suggestion from AP.\n     * Suggestion provided by AP under some error\n     * cases, could be helpful for the host app.\n     * Check documentation.\n     */\n    tspecIe = (WMM_TSPEC_IE *)tspecSuggestion;\n\n    /*\n     * What do we do, if we get TSPEC rejection? One thought\n     * that comes to mind is implictly delete the pstream...\n     */\n    A_PRINTF(\"AR6000 CAC notification. \"\n                \"AC = %d, cacIndication = 0x%x, statusCode = 0x%x\\n\",\n                 ac, cacIndication, statusCode);\n}\n\nvoid\nar6000_channel_change_event(struct ar6_softc *ar, u16 oldChannel,\n                            u16 newChannel)\n{\n    A_PRINTF(\"Channel Change notification\\nOld Channel: %d, New Channel: %d\\n\",\n             oldChannel, newChannel);\n}\n\n#define AR6000_PRINT_BSSID(_pBss)  do {     \\\n        A_PRINTF(\"%2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x \",\\\n                 (_pBss)[0],(_pBss)[1],(_pBss)[2],(_pBss)[3],\\\n                 (_pBss)[4],(_pBss)[5]);  \\\n} while(0)\n\nvoid\nar6000_roam_tbl_event(struct ar6_softc *ar, WMI_TARGET_ROAM_TBL *pTbl)\n{\n    u8 i;\n\n    A_PRINTF(\"ROAM TABLE NO OF ENTRIES is %d ROAM MODE is %d\\n\",\n              pTbl->numEntries, pTbl->roamMode);\n    for (i= 0; i < pTbl->numEntries; i++) {\n        A_PRINTF(\"[%d]bssid %2.2x:%2.2x:%2.2x:%2.2x:%2.2x:%2.2x \", i,\n            pTbl->bssRoamInfo[i].bssid[0], pTbl->bssRoamInfo[i].bssid[1],\n            pTbl->bssRoamInfo[i].bssid[2],\n            pTbl->bssRoamInfo[i].bssid[3],\n            pTbl->bssRoamInfo[i].bssid[4],\n            pTbl->bssRoamInfo[i].bssid[5]);\n        A_PRINTF(\"RSSI %d RSSIDT %d LAST RSSI %d UTIL %d ROAM_UTIL %d\"\n                 \" BIAS %d\\n\",\n            pTbl->bssRoamInfo[i].rssi,\n            pTbl->bssRoamInfo[i].rssidt,\n            pTbl->bssRoamInfo[i].last_rssi,\n            pTbl->bssRoamInfo[i].util,\n            pTbl->bssRoamInfo[i].roam_util,\n            pTbl->bssRoamInfo[i].bias);\n    }\n}\n\nvoid\nar6000_wow_list_event(struct ar6_softc *ar, u8 num_filters, WMI_GET_WOW_LIST_REPLY *wow_reply)\n{\n    u8 i,j;\n\n    /*Each event now contains exactly one filter, see bug 26613*/\n    A_PRINTF(\"WOW pattern %d of %d patterns\\n\", wow_reply->this_filter_num,                 wow_reply->num_filters);\n    A_PRINTF(\"wow mode = %s host mode = %s\\n\",\n            (wow_reply->wow_mode == 0? \"disabled\":\"enabled\"),\n            (wow_reply->host_mode == 1 ? \"awake\":\"asleep\"));\n\n\n    /*If there are no patterns, the reply will only contain generic\n      WoW information. Pattern information will exist only if there are\n      patterns present. Bug 26716*/\n\n   /* If this event contains pattern information, display it*/\n    if (wow_reply->this_filter_num) {\n        i=0;\n        A_PRINTF(\"id=%d size=%d offset=%d\\n\",\n                    wow_reply->wow_filters[i].wow_filter_id,\n                    wow_reply->wow_filters[i].wow_filter_size,\n                    wow_reply->wow_filters[i].wow_filter_offset);\n       A_PRINTF(\"wow pattern = \");\n       for (j=0; j< wow_reply->wow_filters[i].wow_filter_size; j++) {\n             A_PRINTF(\"%2.2x\",wow_reply->wow_filters[i].wow_filter_pattern[j]);\n        }\n\n        A_PRINTF(\"\\nwow mask = \");\n        for (j=0; j< wow_reply->wow_filters[i].wow_filter_size; j++) {\n            A_PRINTF(\"%2.2x\",wow_reply->wow_filters[i].wow_filter_mask[j]);\n        }\n        A_PRINTF(\"\\n\");\n    }\n}\n\n/*\n * Report the Roaming related data collected on the target\n */\nvoid\nar6000_display_roam_time(WMI_TARGET_ROAM_TIME *p)\n{\n    A_PRINTF(\"Disconnect Data : BSSID: \");\n    AR6000_PRINT_BSSID(p->disassoc_bssid);\n    A_PRINTF(\" RSSI %d DISASSOC Time %d NO_TXRX_TIME %d\\n\",\n             p->disassoc_bss_rssi,p->disassoc_time,\n             p->no_txrx_time);\n    A_PRINTF(\"Connect Data: BSSID: \");\n    AR6000_PRINT_BSSID(p->assoc_bssid);\n    A_PRINTF(\" RSSI %d ASSOC Time %d TXRX_TIME %d\\n\",\n             p->assoc_bss_rssi,p->assoc_time,\n             p->allow_txrx_time);\n}\n\nvoid\nar6000_roam_data_event(struct ar6_softc *ar, WMI_TARGET_ROAM_DATA *p)\n{\n    switch (p->roamDataType) {\n        case ROAM_DATA_TIME:\n            ar6000_display_roam_time(&p->u.roamTime);\n            break;\n        default:\n            break;\n    }\n}\n\nvoid\nar6000_bssInfo_event_rx(struct ar6_softc *ar, u8 *datap, int len)\n{\n    struct sk_buff *skb;\n    WMI_BSS_INFO_HDR *bih = (WMI_BSS_INFO_HDR *)datap;\n\n\n    if (!ar->arMgmtFilter) {\n        return;\n    }\n    if (((ar->arMgmtFilter & IEEE80211_FILTER_TYPE_BEACON) &&\n        (bih->frameType != BEACON_FTYPE))  ||\n        ((ar->arMgmtFilter & IEEE80211_FILTER_TYPE_PROBE_RESP) &&\n        (bih->frameType != PROBERESP_FTYPE)))\n    {\n        return;\n    }\n\n    if ((skb = A_NETBUF_ALLOC_RAW(len)) != NULL) {\n\n        A_NETBUF_PUT(skb, len);\n        memcpy(A_NETBUF_DATA(skb), datap, len);\n        skb->dev = ar->arNetDev;\n        memcpy(skb_mac_header(skb), A_NETBUF_DATA(skb), 6);\n        skb->ip_summed = CHECKSUM_NONE;\n        skb->pkt_type = PACKET_OTHERHOST;\n        skb->protocol = __constant_htons(0x0019);\n        netif_rx(skb);\n    }\n}\n\nu32 wmiSendCmdNum;\n\nint\nar6000_control_tx(void *devt, void *osbuf, HTC_ENDPOINT_ID eid)\n{\n    struct ar6_softc       *ar = (struct ar6_softc *)devt;\n    int         status = 0;\n    struct ar_cookie *cookie = NULL;\n    int i;\n#ifdef CONFIG_PM\n    if (ar->arWowState != WLAN_WOW_STATE_NONE) {\n        A_NETBUF_FREE(osbuf);\n        return A_EACCES;\n    }\n#endif /* CONFIG_PM */\n        /* take lock to protect ar6000_alloc_cookie() */\n    AR6000_SPIN_LOCK(&ar->arLock, 0);\n\n    do {\n\n        AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_TX,(\"ar_contrstatus = ol_tx: skb=0x%lx, len=0x%x eid =%d\\n\",\n                         (unsigned long)osbuf, A_NETBUF_LEN(osbuf), eid));\n\n        if (ar->arWMIControlEpFull && (eid == ar->arControlEp)) {\n                /* control endpoint is full, don't allocate resources, we\n                 * are just going to drop this packet */\n            cookie = NULL;\n            AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\" WMI Control EP full, dropping packet : 0x%lX, len:%d \\n\",\n                    (unsigned long)osbuf, A_NETBUF_LEN(osbuf)));\n        } else {\n            cookie = ar6000_alloc_cookie(ar);\n        }\n\n        if (cookie == NULL) {\n            status = A_NO_MEMORY;\n            break;\n        }\n\n        if(logWmiRawMsgs) {\n            A_PRINTF(\"WMI cmd send, msgNo %d :\", wmiSendCmdNum);\n            for(i = 0; i < a_netbuf_to_len(osbuf); i++)\n                A_PRINTF(\"%x \", ((u8 *)a_netbuf_to_data(osbuf))[i]);\n            A_PRINTF(\"\\n\");\n        }\n\n        wmiSendCmdNum++;\n\n    } while (false);\n\n    if (cookie != NULL) {\n            /* got a structure to send it out on */\n        ar->arTxPending[eid]++;\n\n        if (eid != ar->arControlEp) {\n            ar->arTotalTxDataPending++;\n        }\n    }\n\n    AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n\n    if (cookie != NULL) {\n        cookie->arc_bp[0] = (unsigned long)osbuf;\n        cookie->arc_bp[1] = 0;\n        SET_HTC_PACKET_INFO_TX(&cookie->HtcPkt,\n                               cookie,\n                               A_NETBUF_DATA(osbuf),\n                               A_NETBUF_LEN(osbuf),\n                               eid,\n                               AR6K_CONTROL_PKT_TAG);\n            /* this interface is asynchronous, if there is an error, cleanup will happen in the\n             * TX completion callback */\n        HTCSendPkt(ar->arHtcTarget, &cookie->HtcPkt);\n        status = 0;\n    }\n\n    if (status) {\n        A_NETBUF_FREE(osbuf);\n    }\n    return status;\n}\n\n/* indicate tx activity or inactivity on a WMI stream */\nvoid ar6000_indicate_tx_activity(void *devt, u8 TrafficClass, bool Active)\n{\n    struct ar6_softc  *ar = (struct ar6_softc *)devt;\n    HTC_ENDPOINT_ID eid ;\n    int i;\n\n    if (ar->arWmiEnabled) {\n        eid = arAc2EndpointID(ar, TrafficClass);\n\n        AR6000_SPIN_LOCK(&ar->arLock, 0);\n\n        ar->arAcStreamActive[TrafficClass] = Active;\n\n        if (Active) {\n            /* when a stream goes active, keep track of the active stream with the highest priority */\n\n            if (ar->arAcStreamPriMap[TrafficClass] > ar->arHiAcStreamActivePri) {\n                    /* set the new highest active priority */\n                ar->arHiAcStreamActivePri = ar->arAcStreamPriMap[TrafficClass];\n            }\n\n        } else {\n            /* when a stream goes inactive, we may have to search for the next active stream\n             * that is the highest priority */\n\n            if (ar->arHiAcStreamActivePri == ar->arAcStreamPriMap[TrafficClass]) {\n\n                /* the highest priority stream just went inactive */\n\n                    /* reset and search for the \"next\" highest \"active\" priority stream */\n                ar->arHiAcStreamActivePri = 0;\n                for (i = 0; i < WMM_NUM_AC; i++) {\n                    if (ar->arAcStreamActive[i]) {\n                        if (ar->arAcStreamPriMap[i] > ar->arHiAcStreamActivePri) {\n                            /* set the new highest active priority */\n                            ar->arHiAcStreamActivePri = ar->arAcStreamPriMap[i];\n                        }\n                    }\n                }\n            }\n        }\n\n        AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n\n    } else {\n            /* for mbox ping testing, the traffic class is mapped directly as a stream ID,\n             * see handling of AR6000_XIOCTL_TRAFFIC_ACTIVITY_CHANGE in ioctl.c\n             * convert the stream ID to a endpoint */\n        eid = arAc2EndpointID(ar, TrafficClass);\n    }\n\n        /* notify HTC, this may cause credit distribution changes */\n\n    HTCIndicateActivityChange(ar->arHtcTarget,\n                              eid,\n                              Active);\n\n}\n\nvoid\nar6000_btcoex_config_event(struct ar6_softc *ar,  u8 *ptr, u32 len)\n{\n\n    WMI_BTCOEX_CONFIG_EVENT *pBtcoexConfig = (WMI_BTCOEX_CONFIG_EVENT *)ptr;\n    WMI_BTCOEX_CONFIG_EVENT *pArbtcoexConfig =&ar->arBtcoexConfig;\n\n    AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"AR6000 BTCOEX CONFIG EVENT \\n\"));\n\n    A_PRINTF(\"received config event\\n\");\n    pArbtcoexConfig->btProfileType = pBtcoexConfig->btProfileType;\n    pArbtcoexConfig->linkId = pBtcoexConfig->linkId;\n\n    switch (pBtcoexConfig->btProfileType) {\n        case WMI_BTCOEX_BT_PROFILE_SCO:\n            memcpy(&pArbtcoexConfig->info.scoConfigCmd, &pBtcoexConfig->info.scoConfigCmd,\n                                        sizeof(WMI_SET_BTCOEX_SCO_CONFIG_CMD));\n            break;\n        case WMI_BTCOEX_BT_PROFILE_A2DP:\n            memcpy(&pArbtcoexConfig->info.a2dpConfigCmd, &pBtcoexConfig->info.a2dpConfigCmd,\n                                        sizeof(WMI_SET_BTCOEX_A2DP_CONFIG_CMD));\n            break;\n        case WMI_BTCOEX_BT_PROFILE_ACLCOEX:\n            memcpy(&pArbtcoexConfig->info.aclcoexConfig, &pBtcoexConfig->info.aclcoexConfig,\n                                        sizeof(WMI_SET_BTCOEX_ACLCOEX_CONFIG_CMD));\n            break;\n        case WMI_BTCOEX_BT_PROFILE_INQUIRY_PAGE:\n           memcpy(&pArbtcoexConfig->info.btinquiryPageConfigCmd, &pBtcoexConfig->info.btinquiryPageConfigCmd,\n                                        sizeof(WMI_SET_BTCOEX_ACLCOEX_CONFIG_CMD));\n            break;\n    }\n    if (ar->statsUpdatePending) {\n         ar->statsUpdatePending = false;\n          wake_up(&arEvent);\n    }\n}\n\nvoid\nar6000_btcoex_stats_event(struct ar6_softc *ar,  u8 *ptr, u32 len)\n{\n    WMI_BTCOEX_STATS_EVENT *pBtcoexStats = (WMI_BTCOEX_STATS_EVENT *)ptr;\n\n    AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"AR6000 BTCOEX CONFIG EVENT \\n\"));\n\n    memcpy(&ar->arBtcoexStats, pBtcoexStats, sizeof(WMI_BTCOEX_STATS_EVENT));\n\n    if (ar->statsUpdatePending) {\n         ar->statsUpdatePending = false;\n        wake_up(&arEvent);\n    }\n\n}\nmodule_init(ar6000_init_module);\nmodule_exit(ar6000_cleanup_module);\n\n/* Init cookie queue */\nstatic void\nar6000_cookie_init(struct ar6_softc *ar)\n{\n    u32 i;\n\n    ar->arCookieList = NULL;\n    ar->arCookieCount = 0;\n\n    A_MEMZERO(s_ar_cookie_mem, sizeof(s_ar_cookie_mem));\n\n    for (i = 0; i < MAX_COOKIE_NUM; i++) {\n        ar6000_free_cookie(ar, &s_ar_cookie_mem[i]);\n    }\n}\n\n/* cleanup cookie queue */\nstatic void\nar6000_cookie_cleanup(struct ar6_softc *ar)\n{\n    /* It is gone .... */\n    ar->arCookieList = NULL;\n    ar->arCookieCount = 0;\n}\n\n/* Init cookie queue */\nstatic void\nar6000_free_cookie(struct ar6_softc *ar, struct ar_cookie * cookie)\n{\n    /* Insert first */\n    A_ASSERT(ar != NULL);\n    A_ASSERT(cookie != NULL);\n\n    cookie->arc_list_next = ar->arCookieList;\n    ar->arCookieList = cookie;\n    ar->arCookieCount++;\n}\n\n/* cleanup cookie queue */\nstatic struct ar_cookie *\nar6000_alloc_cookie(struct ar6_softc  *ar)\n{\n    struct ar_cookie   *cookie;\n\n    cookie = ar->arCookieList;\n    if(cookie != NULL)\n    {\n        ar->arCookieList = cookie->arc_list_next;\n        ar->arCookieCount--;\n    }\n\n    return cookie;\n}\n\nvoid\nar6000_tx_retry_err_event(void *devt)\n{\n    AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"Tx retries reach maximum!\\n\"));\n}\n\nvoid\nar6000_snrThresholdEvent_rx(void *devt, WMI_SNR_THRESHOLD_VAL newThreshold, u8 snr)\n{\n    WMI_SNR_THRESHOLD_EVENT event;\n\n    event.range = newThreshold;\n    event.snr = snr;\n}\n\nvoid\nar6000_lqThresholdEvent_rx(void *devt, WMI_LQ_THRESHOLD_VAL newThreshold, u8 lq)\n{\n    AR_DEBUG_PRINTF(ATH_DEBUG_INFO,(\"lq threshold range %d, lq %d\\n\", newThreshold, lq));\n}\n\n\n\nu32 a_copy_to_user(void *to, const void *from, u32 n)\n{\n    return(copy_to_user(to, from, n));\n}\n\nu32 a_copy_from_user(void *to, const void *from, u32 n)\n{\n    return(copy_from_user(to, from, n));\n}\n\n\nint\nar6000_get_driver_cfg(struct net_device *dev,\n                        u16 cfgParam,\n                        void *result)\n{\n\n    int    ret = 0;\n\n    switch(cfgParam)\n    {\n        case AR6000_DRIVER_CFG_GET_WLANNODECACHING:\n           *((u32 *)result) = wlanNodeCaching;\n           break;\n        case AR6000_DRIVER_CFG_LOG_RAW_WMI_MSGS:\n           *((u32 *)result) = logWmiRawMsgs;\n            break;\n        default:\n           ret = EINVAL;\n           break;\n    }\n\n    return ret;\n}\n\nvoid\nar6000_keepalive_rx(void *devt, u8 configured)\n{\n    struct ar6_softc *ar = (struct ar6_softc *)devt;\n\n    ar->arKeepaliveConfigured = configured;\n    wake_up(&arEvent);\n}\n\nvoid\nar6000_pmkid_list_event(void *devt, u8 numPMKID, WMI_PMKID *pmkidList,\n                        u8 *bssidList)\n{\n    u8 i, j;\n\n    A_PRINTF(\"Number of Cached PMKIDs is %d\\n\", numPMKID);\n\n    for (i = 0; i < numPMKID; i++) {\n        A_PRINTF(\"\\nBSSID %d \", i);\n            for (j = 0; j < ATH_MAC_LEN; j++) {\n                A_PRINTF(\"%2.2x\", bssidList[j]);\n            }\n        bssidList += (ATH_MAC_LEN + WMI_PMKID_LEN);\n        A_PRINTF(\"\\nPMKID %d \", i);\n            for (j = 0; j < WMI_PMKID_LEN; j++) {\n                A_PRINTF(\"%2.2x\", pmkidList->pmkid[j]);\n            }\n        pmkidList = (WMI_PMKID *)((u8 *)pmkidList + ATH_MAC_LEN +\n                                  WMI_PMKID_LEN);\n    }\n}\n\nvoid ar6000_pspoll_event(struct ar6_softc *ar,u8 aid)\n{\n    sta_t *conn=NULL;\n    bool isPsqEmpty = false;\n\n    conn = ieee80211_find_conn_for_aid(ar, aid);\n\n    /* If the PS q for this STA is not empty, dequeue and send a pkt from\n     * the head of the q. Also update the More data bit in the WMI_DATA_HDR\n     * if there are more pkts for this STA in the PS q. If there are no more\n     * pkts for this STA, update the PVB for this STA.\n     */\n    A_MUTEX_LOCK(&conn->psqLock);\n    isPsqEmpty  = A_NETBUF_QUEUE_EMPTY(&conn->psq);\n    A_MUTEX_UNLOCK(&conn->psqLock);\n\n    if (isPsqEmpty) {\n        /* TODO:No buffered pkts for this STA. Send out a NULL data frame */\n    } else {\n        struct sk_buff *skb = NULL;\n\n        A_MUTEX_LOCK(&conn->psqLock);\n        skb = A_NETBUF_DEQUEUE(&conn->psq);\n        A_MUTEX_UNLOCK(&conn->psqLock);\n        /* Set the STA flag to PSPolled, so that the frame will go out */\n        STA_SET_PS_POLLED(conn);\n        ar6000_data_tx(skb, ar->arNetDev);\n        STA_CLR_PS_POLLED(conn);\n\n        /* Clear the PVB for this STA if the queue has become empty */\n        A_MUTEX_LOCK(&conn->psqLock);\n        isPsqEmpty  = A_NETBUF_QUEUE_EMPTY(&conn->psq);\n        A_MUTEX_UNLOCK(&conn->psqLock);\n\n        if (isPsqEmpty) {\n            wmi_set_pvb_cmd(ar->arWmi, conn->aid, 0);\n        }\n    }\n}\n\nvoid ar6000_dtimexpiry_event(struct ar6_softc *ar)\n{\n    bool isMcastQueued = false;\n    struct sk_buff *skb = NULL;\n\n    /* If there are no associated STAs, ignore the DTIM expiry event.\n     * There can be potential race conditions where the last associated\n     * STA may disconnect & before the host could clear the 'Indicate DTIM'\n     * request to the firmware, the firmware would have just indicated a DTIM\n     * expiry event. The race is between 'clear DTIM expiry cmd' going\n     * from the host to the firmware & the DTIM expiry event happening from\n     * the firmware to the host.\n     */\n    if (ar->sta_list_index == 0) {\n        return;\n    }\n\n    A_MUTEX_LOCK(&ar->mcastpsqLock);\n    isMcastQueued = A_NETBUF_QUEUE_EMPTY(&ar->mcastpsq);\n    A_MUTEX_UNLOCK(&ar->mcastpsqLock);\n\n    A_ASSERT(isMcastQueued == false);\n\n    /* Flush the mcast psq to the target */\n    /* Set the STA flag to DTIMExpired, so that the frame will go out */\n    ar->DTIMExpired = true;\n\n    A_MUTEX_LOCK(&ar->mcastpsqLock);\n    while (!A_NETBUF_QUEUE_EMPTY(&ar->mcastpsq)) {\n        skb = A_NETBUF_DEQUEUE(&ar->mcastpsq);\n        A_MUTEX_UNLOCK(&ar->mcastpsqLock);\n\n        ar6000_data_tx(skb, ar->arNetDev);\n\n        A_MUTEX_LOCK(&ar->mcastpsqLock);\n    }\n    A_MUTEX_UNLOCK(&ar->mcastpsqLock);\n\n    /* Reset the DTIMExpired flag back to 0 */\n    ar->DTIMExpired = false;\n\n    /* Clear the LSB of the BitMapCtl field of the TIM IE */\n    wmi_set_pvb_cmd(ar->arWmi, MCAST_AID, 0);\n}\n\nvoid\nread_rssi_compensation_param(struct ar6_softc *ar)\n{\n    u8 *cust_data_ptr;\n\n//#define RSSICOMPENSATION_PRINT\n\n#ifdef RSSICOMPENSATION_PRINT\n    s16 i;\n    cust_data_ptr = ar6000_get_cust_data_buffer(ar->arTargetType);\n    for (i=0; i<16; i++) {\n        A_PRINTF(\"cust_data_%d = %x \\n\", i, *(u8 *)cust_data_ptr);\n        cust_data_ptr += 1;\n    }\n#endif\n\n    cust_data_ptr = ar6000_get_cust_data_buffer(ar->arTargetType);\n\n    rssi_compensation_param.customerID = *(u16 *)cust_data_ptr & 0xffff;\n    rssi_compensation_param.enable = *(u16 *)(cust_data_ptr+2) & 0xffff;\n    rssi_compensation_param.bg_param_a = *(u16 *)(cust_data_ptr+4) & 0xffff;\n    rssi_compensation_param.bg_param_b = *(u16 *)(cust_data_ptr+6) & 0xffff;\n    rssi_compensation_param.a_param_a = *(u16 *)(cust_data_ptr+8) & 0xffff;\n    rssi_compensation_param.a_param_b = *(u16 *)(cust_data_ptr+10) &0xffff;\n    rssi_compensation_param.reserved = *(u32 *)(cust_data_ptr+12);\n\n#ifdef RSSICOMPENSATION_PRINT\n    A_PRINTF(\"customerID = 0x%x \\n\", rssi_compensation_param.customerID);\n    A_PRINTF(\"enable = 0x%x \\n\", rssi_compensation_param.enable);\n    A_PRINTF(\"bg_param_a = 0x%x and %d \\n\", rssi_compensation_param.bg_param_a, rssi_compensation_param.bg_param_a);\n    A_PRINTF(\"bg_param_b = 0x%x and %d \\n\", rssi_compensation_param.bg_param_b, rssi_compensation_param.bg_param_b);\n    A_PRINTF(\"a_param_a = 0x%x and %d \\n\", rssi_compensation_param.a_param_a, rssi_compensation_param.a_param_a);\n    A_PRINTF(\"a_param_b = 0x%x and %d \\n\", rssi_compensation_param.a_param_b, rssi_compensation_param.a_param_b);\n    A_PRINTF(\"Last 4 bytes = 0x%x \\n\", rssi_compensation_param.reserved);\n#endif\n\n    if (rssi_compensation_param.enable != 0x1) {\n        rssi_compensation_param.enable = 0;\n    }\n\n   return;\n}\n\ns32 rssi_compensation_calc_tcmd(u32 freq, s32 rssi, u32 totalPkt)\n{\n\n    if (freq > 5000)\n    {\n        if (rssi_compensation_param.enable)\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\">>> 11a\\n\"));\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\"rssi before compensation  = %d, totalPkt = %d\\n\", rssi,totalPkt));\n            rssi = rssi * rssi_compensation_param.a_param_a + totalPkt * rssi_compensation_param.a_param_b;\n            rssi = (rssi-50) /100;\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\"rssi after compensation = %d\\n\", rssi));\n        }\n    }\n    else\n    {\n        if (rssi_compensation_param.enable)\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\">>> 11bg\\n\"));\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\"rssi before compensation  = %d, totalPkt = %d\\n\", rssi,totalPkt));\n            rssi = rssi * rssi_compensation_param.bg_param_a + totalPkt * rssi_compensation_param.bg_param_b;\n            rssi = (rssi-50) /100;\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\"rssi after compensation = %d\\n\", rssi));\n        }\n    }\n\n    return rssi;\n}\n\ns16 rssi_compensation_calc(struct ar6_softc *ar, s16 rssi)\n{\n    if (ar->arBssChannel > 5000)\n    {\n        if (rssi_compensation_param.enable)\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\">>> 11a\\n\"));\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\"rssi before compensation  = %d\\n\", rssi));\n            rssi = rssi * rssi_compensation_param.a_param_a + rssi_compensation_param.a_param_b;\n            rssi = (rssi-50) /100;\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\"rssi after compensation = %d\\n\", rssi));\n        }\n    }\n    else\n    {\n        if (rssi_compensation_param.enable)\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\">>> 11bg\\n\"));\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\"rssi before compensation  = %d\\n\", rssi));\n            rssi = rssi * rssi_compensation_param.bg_param_a + rssi_compensation_param.bg_param_b;\n            rssi = (rssi-50) /100;\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\"rssi after compensation = %d\\n\", rssi));\n        }\n    }\n\n    return rssi;\n}\n\ns16 rssi_compensation_reverse_calc(struct ar6_softc *ar, s16 rssi, bool Above)\n{\n    s16 i;\n\n    if (ar->arBssChannel > 5000)\n    {\n        if (rssi_compensation_param.enable)\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\">>> 11a\\n\"));\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\"rssi before rev compensation  = %d\\n\", rssi));\n            rssi = rssi * 100;\n            rssi = (rssi - rssi_compensation_param.a_param_b) / rssi_compensation_param.a_param_a;\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\"rssi after rev compensation = %d\\n\", rssi));\n        }\n    }\n    else\n    {\n        if (rssi_compensation_param.enable)\n        {\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\">>> 11bg\\n\"));\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\"rssi before rev compensation  = %d\\n\", rssi));\n\n            if (Above) {\n                for (i=95; i>=0; i--) {\n                    if (rssi <=  rssi_compensation_table[i]) {\n                        rssi = 0 - i;\n                        break;\n                    }\n                }\n            } else {\n                for (i=0; i<=95; i++) {\n                    if (rssi >=  rssi_compensation_table[i]) {\n                        rssi = 0 - i;\n                        break;\n                    }\n                }\n            }\n            AR_DEBUG_PRINTF(ATH_DEBUG_INFO, (\"rssi after rev compensation = %d\\n\", rssi));\n        }\n    }\n\n    return rssi;\n}\n\n#ifdef WAPI_ENABLE\nvoid ap_wapi_rekey_event(struct ar6_softc *ar, u8 type, u8 *mac)\n{\n    union iwreq_data wrqu;\n    char buf[20];\n\n    A_MEMZERO(buf, sizeof(buf));\n\n    strcpy(buf, \"WAPI_REKEY\");\n    buf[10] = type;\n    memcpy(&buf[11], mac, ATH_MAC_LEN);\n\n    A_MEMZERO(&wrqu, sizeof(wrqu));\n    wrqu.data.length = 10+1+ATH_MAC_LEN;\n    wireless_send_event(ar->arNetDev, IWEVCUSTOM, &wrqu, buf);\n\n    A_PRINTF(\"WAPI REKEY - %d - %02x:%02x\\n\", type, mac[4], mac[5]);\n}\n#endif\n\nstatic int\nar6000_reinstall_keys(struct ar6_softc *ar, u8 key_op_ctrl)\n{\n    int status = 0;\n    struct ieee80211req_key *uik = &ar->user_saved_keys.ucast_ik;\n    struct ieee80211req_key *bik = &ar->user_saved_keys.bcast_ik;\n    CRYPTO_TYPE  keyType = ar->user_saved_keys.keyType;\n\n    if (IEEE80211_CIPHER_CCKM_KRK != uik->ik_type) {\n        if (NONE_CRYPT == keyType) {\n            goto _reinstall_keys_out;\n        }\n\n        if (uik->ik_keylen) {\n            status = wmi_addKey_cmd(ar->arWmi, uik->ik_keyix,\n                    ar->user_saved_keys.keyType, PAIRWISE_USAGE,\n                    uik->ik_keylen, (u8 *)&uik->ik_keyrsc,\n                    uik->ik_keydata, key_op_ctrl, uik->ik_macaddr, SYNC_BEFORE_WMIFLAG);\n        }\n\n    } else {\n        status = wmi_add_krk_cmd(ar->arWmi, uik->ik_keydata);\n    }\n\n    if (IEEE80211_CIPHER_CCKM_KRK != bik->ik_type) {\n        if (NONE_CRYPT == keyType) {\n            goto _reinstall_keys_out;\n        }\n\n        if (bik->ik_keylen) {\n            status = wmi_addKey_cmd(ar->arWmi, bik->ik_keyix,\n                    ar->user_saved_keys.keyType, GROUP_USAGE,\n                    bik->ik_keylen, (u8 *)&bik->ik_keyrsc,\n                    bik->ik_keydata, key_op_ctrl, bik->ik_macaddr, NO_SYNC_WMIFLAG);\n        }\n    } else {\n        status = wmi_add_krk_cmd(ar->arWmi, bik->ik_keydata);\n    }\n\n_reinstall_keys_out:\n    ar->user_savedkeys_stat = USER_SAVEDKEYS_STAT_INIT;\n    ar->user_key_ctrl      = 0;\n\n    return status;\n}\n\n\nvoid\nar6000_dset_open_req(\n    void *context,\n    u32 id,\n    u32 targHandle,\n    u32 targReplyFn,\n    u32 targReplyArg)\n{\n}\n\nvoid\nar6000_dset_close(\n    void *context,\n    u32 access_cookie)\n{\n    return;\n}\n\nvoid\nar6000_dset_data_req(\n   void *context,\n   u32 accessCookie,\n   u32 offset,\n   u32 length,\n   u32 targBuf,\n   u32 targReplyFn,\n   u32 targReplyArg)\n{\n}\n\nint\nar6000_ap_mode_profile_commit(struct ar6_softc *ar)\n{\n    WMI_CONNECT_CMD p;\n    unsigned long  flags;\n\n    /* No change in AP's profile configuration */\n    if(ar->ap_profile_flag==0) {\n        A_PRINTF(\"COMMIT: No change in profile!!!\\n\");\n        return -ENODATA;\n    }\n\n    if(!ar->arSsidLen) {\n        A_PRINTF(\"SSID not set!!!\\n\");\n        return -ECHRNG;\n    }\n\n    switch(ar->arAuthMode) {\n    case NONE_AUTH:\n        if((ar->arPairwiseCrypto != NONE_CRYPT) &&\n#ifdef WAPI_ENABLE\n           (ar->arPairwiseCrypto != WAPI_CRYPT) &&\n#endif\n           (ar->arPairwiseCrypto != WEP_CRYPT)) {\n            A_PRINTF(\"Cipher not supported in AP mode Open auth\\n\");\n            return -EOPNOTSUPP;\n        }\n        break;\n    case WPA_PSK_AUTH:\n    case WPA2_PSK_AUTH:\n    case (WPA_PSK_AUTH|WPA2_PSK_AUTH):\n        break;\n    default:\n        A_PRINTF(\"This key mgmt type not supported in AP mode\\n\");\n        return -EOPNOTSUPP;\n    }\n\n    /* Update the arNetworkType */\n    ar->arNetworkType = ar->arNextMode;\n\n    A_MEMZERO(&p,sizeof(p));\n    p.ssidLength = ar->arSsidLen;\n    memcpy(p.ssid,ar->arSsid,p.ssidLength);\n    p.channel = ar->arChannelHint;\n    p.networkType = ar->arNetworkType;\n\n    p.dot11AuthMode = ar->arDot11AuthMode;\n    p.authMode = ar->arAuthMode;\n    p.pairwiseCryptoType = ar->arPairwiseCrypto;\n    p.pairwiseCryptoLen = ar->arPairwiseCryptoLen;\n    p.groupCryptoType = ar->arGroupCrypto;\n    p.groupCryptoLen = ar->arGroupCryptoLen;\n    p.ctrl_flags = ar->arConnectCtrlFlags;\n\n    wmi_ap_profile_commit(ar->arWmi, &p);\n    spin_lock_irqsave(&ar->arLock, flags);\n    ar->arConnected  = true;\n    netif_carrier_on(ar->arNetDev);\n    spin_unlock_irqrestore(&ar->arLock, flags);\n    ar->ap_profile_flag = 0;\n    return 0;\n}\n\nint\nar6000_connect_to_ap(struct ar6_softc *ar)\n{\n    /* The ssid length check prevents second \"essid off\" from the user,\n       to be treated as a connect cmd. The second \"essid off\" is ignored.\n    */\n    if((ar->arWmiReady == true) && (ar->arSsidLen > 0) && ar->arNetworkType!=AP_NETWORK)\n    {\n        int status;\n        if((ADHOC_NETWORK != ar->arNetworkType) &&\n           (NONE_AUTH==ar->arAuthMode)          &&\n           (WEP_CRYPT==ar->arPairwiseCrypto)) {\n                ar6000_install_static_wep_keys(ar);\n        }\n\n        if (!ar->arUserBssFilter) {\n            if (wmi_bssfilter_cmd(ar->arWmi, ALL_BSS_FILTER, 0) != 0) {\n                return -EIO;\n            }\n        }\n#ifdef WAPI_ENABLE\n        if (ar->arWapiEnable)  {\n            ar->arPairwiseCrypto = WAPI_CRYPT;\n            ar->arPairwiseCryptoLen = 0;\n            ar->arGroupCrypto = WAPI_CRYPT;\n            ar->arGroupCryptoLen = 0;\n            ar->arAuthMode = NONE_AUTH;\n            ar->arConnectCtrlFlags |= CONNECT_IGNORE_WPAx_GROUP_CIPHER;\n        }\n#endif\n        AR_DEBUG_PRINTF(ATH_DEBUG_WLAN_CONNECT,(\"Connect called with authmode %d dot11 auth %d\"\\\n                        \" PW crypto %d PW crypto Len %d GRP crypto %d\"\\\n                        \" GRP crypto Len %d\\n\",\n                        ar->arAuthMode, ar->arDot11AuthMode,\n                        ar->arPairwiseCrypto, ar->arPairwiseCryptoLen,\n                        ar->arGroupCrypto, ar->arGroupCryptoLen));\n        reconnect_flag = 0;\n        /* Set the listen interval into 1000TUs or more. This value will be indicated to Ap in the conn.\n           later set it back locally at the STA to 100/1000 TUs depending on the power mode */\n        if ((ar->arNetworkType == INFRA_NETWORK)) {\n            wmi_listeninterval_cmd(ar->arWmi, max(ar->arListenIntervalT, (u16)A_MAX_WOW_LISTEN_INTERVAL), 0);\n        }\n        status = wmi_connect_cmd(ar->arWmi, ar->arNetworkType,\n                                 ar->arDot11AuthMode, ar->arAuthMode,\n                                 ar->arPairwiseCrypto, ar->arPairwiseCryptoLen,\n                                 ar->arGroupCrypto,ar->arGroupCryptoLen,\n                                 ar->arSsidLen, ar->arSsid,\n                                 ar->arReqBssid, ar->arChannelHint,\n                                 ar->arConnectCtrlFlags);\n        if (status) {\n            wmi_listeninterval_cmd(ar->arWmi, ar->arListenIntervalT, ar->arListenIntervalB);\n            if (!ar->arUserBssFilter) {\n                wmi_bssfilter_cmd(ar->arWmi, NONE_BSS_FILTER, 0);\n            }\n            return status;\n        }\n\n        if ((!(ar->arConnectCtrlFlags & CONNECT_DO_WPA_OFFLOAD)) &&\n            ((WPA_PSK_AUTH == ar->arAuthMode) || (WPA2_PSK_AUTH == ar->arAuthMode)))\n        {\n            A_TIMEOUT_MS(&ar->disconnect_timer, A_DISCONNECT_TIMER_INTERVAL, 0);\n        }\n\n        ar->arConnectCtrlFlags &= ~CONNECT_DO_WPA_OFFLOAD;\n        \n        ar->arConnectPending = true;\n        return status;    \n    }\n    return A_ERROR;\n}\n\nint\nar6000_disconnect(struct ar6_softc *ar)\n{\n    if ((ar->arConnected == true) || (ar->arConnectPending == true)) {\n        wmi_disconnect_cmd(ar->arWmi);\n        /* \n         * Disconnect cmd is issued, clear connectPending.\n         * arConnected will be cleard in disconnect_event notification.\n         */\n        ar->arConnectPending = false;\n    }\n\n    return 0;\n}\n\nint\nar6000_ap_mode_get_wpa_ie(struct ar6_softc *ar, struct ieee80211req_wpaie *wpaie)\n{\n    sta_t *conn = NULL;\n    conn = ieee80211_find_conn(ar, wpaie->wpa_macaddr);\n\n    A_MEMZERO(wpaie->wpa_ie, IEEE80211_MAX_IE);\n    A_MEMZERO(wpaie->rsn_ie, IEEE80211_MAX_IE);\n\n    if(conn) {\n        memcpy(wpaie->wpa_ie, conn->wpa_ie, IEEE80211_MAX_IE);\n    }\n\n    return 0;\n}\n\nint\nis_iwioctl_allowed(u8 mode, u16 cmd)\n{\n    if(cmd >= SIOCSIWCOMMIT && cmd <= SIOCGIWPOWER) {\n        cmd -= SIOCSIWCOMMIT;\n        if(sioctl_filter[cmd] == 0xFF) return 0;\n        if(sioctl_filter[cmd] & mode) return 0;\n    } else if(cmd >= SIOCIWFIRSTPRIV && cmd <= (SIOCIWFIRSTPRIV+30)) {\n        cmd -= SIOCIWFIRSTPRIV;\n        if(pioctl_filter[cmd] == 0xFF) return 0;\n        if(pioctl_filter[cmd] & mode) return 0;\n    } else {\n        return A_ERROR;\n    }\n    return A_ENOTSUP;\n}\n\nint\nis_xioctl_allowed(u8 mode, int cmd)\n{\n    if(sizeof(xioctl_filter)-1 < cmd) {\n        A_PRINTF(\"Filter for this cmd=%d not defined\\n\",cmd);\n        return 0;\n    }\n    if(xioctl_filter[cmd] == 0xFF) return 0;\n    if(xioctl_filter[cmd] & mode) return 0;\n    return A_ERROR;\n}\n\n#ifdef WAPI_ENABLE\nint\nap_set_wapi_key(struct ar6_softc *ar, void *ikey)\n{\n    struct ieee80211req_key *ik = (struct ieee80211req_key *)ikey;\n    KEY_USAGE   keyUsage = 0;\n    int    status;\n\n    if (memcmp(ik->ik_macaddr, bcast_mac, IEEE80211_ADDR_LEN) == 0) {\n        keyUsage = GROUP_USAGE;\n    } else {\n        keyUsage = PAIRWISE_USAGE;\n    }\n    A_PRINTF(\"WAPI_KEY: Type:%d ix:%d mac:%02x:%02x len:%d\\n\",\n        keyUsage, ik->ik_keyix, ik->ik_macaddr[4], ik->ik_macaddr[5],\n        ik->ik_keylen);\n\n    status = wmi_addKey_cmd(ar->arWmi, ik->ik_keyix, WAPI_CRYPT, keyUsage,\n                            ik->ik_keylen, (u8 *)&ik->ik_keyrsc,\n                            ik->ik_keydata, KEY_OP_INIT_VAL, ik->ik_macaddr,\n                            SYNC_BOTH_WMIFLAG);\n\n    if (0 != status) {\n        return -EIO;\n    }\n    return 0;\n}\n#endif\n\nvoid ar6000_peer_event(\n    void *context,\n    u8 eventCode,\n    u8 *macAddr)\n{\n    u8 pos;\n\n    for (pos=0;pos<6;pos++)\n        printk(\"%02x: \",*(macAddr+pos));\n    printk(\"\\n\");\n}\n\n#ifdef HTC_TEST_SEND_PKTS\n#define HTC_TEST_DUPLICATE 8\nstatic void DoHTCSendPktsTest(struct ar6_softc *ar, int MapNo, HTC_ENDPOINT_ID eid, struct sk_buff *dupskb)\n{\n    struct ar_cookie *cookie;\n    struct ar_cookie *cookieArray[HTC_TEST_DUPLICATE];\n    struct sk_buff   *new_skb;\n    int    i;\n    int    pkts = 0;\n    struct htc_packet_queue pktQueue;\n    EPPING_HEADER    *eppingHdr;\n\n    eppingHdr = A_NETBUF_DATA(dupskb);\n\n    if (eppingHdr->Cmd_h == EPPING_CMD_NO_ECHO) {\n        /* skip test if this is already a tx perf test */\n        return;\n    }\n\n    for (i = 0; i < HTC_TEST_DUPLICATE; i++,pkts++) {\n        AR6000_SPIN_LOCK(&ar->arLock, 0);\n        cookie = ar6000_alloc_cookie(ar);\n        if (cookie != NULL) {\n            ar->arTxPending[eid]++;\n            ar->arTotalTxDataPending++;\n        }\n\n        AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n\n        if (NULL == cookie) {\n            break;\n        }\n\n        new_skb = A_NETBUF_ALLOC(A_NETBUF_LEN(dupskb));\n\n        if (new_skb == NULL) {\n            AR6000_SPIN_LOCK(&ar->arLock, 0);\n            ar6000_free_cookie(ar,cookie);\n            AR6000_SPIN_UNLOCK(&ar->arLock, 0);\n            break;\n        }\n\n        A_NETBUF_PUT_DATA(new_skb, A_NETBUF_DATA(dupskb), A_NETBUF_LEN(dupskb));\n        cookie->arc_bp[0] = (unsigned long)new_skb;\n        cookie->arc_bp[1] = MapNo;\n        SET_HTC_PACKET_INFO_TX(&cookie->HtcPkt,\n                               cookie,\n                               A_NETBUF_DATA(new_skb),\n                               A_NETBUF_LEN(new_skb),\n                               eid,\n                               AR6K_DATA_PKT_TAG);\n\n        cookieArray[i] = cookie;\n\n        {\n            EPPING_HEADER *pHdr = (EPPING_HEADER *)A_NETBUF_DATA(new_skb);\n            pHdr->Cmd_h = EPPING_CMD_NO_ECHO;  /* do not echo the packet */\n        }\n    }\n\n    if (pkts == 0) {\n        return;\n    }\n\n    INIT_HTC_PACKET_QUEUE(&pktQueue);\n\n    for (i = 0; i < pkts; i++) {\n        HTC_PACKET_ENQUEUE(&pktQueue,&cookieArray[i]->HtcPkt);\n    }\n\n    HTCSendPktsMultiple(ar->arHtcTarget, &pktQueue);\n\n}\n#endif\n\n#ifdef CONFIG_AP_VIRTUAL_ADAPTER_SUPPORT\n/*\n * Add support for adding and removing a virtual adapter for soft AP.\n * Some OS requires different adapters names for station and soft AP mode.\n * To support these requirement, create and destroy a netdevice  instance\n * when the AP mode is operational. A full fledged support for virual device\n * is not implemented. Rather a virtual interface is created and is linked\n * with the existing physical device instance during the operation of the \n * AP mode.\n */\n\nint ar6000_start_ap_interface(struct ar6_softc *ar)\n{\n    struct ar_virtual_interface *arApDev;\n\n    /* Change net_device to point to AP instance */\n    arApDev = (struct ar_virtual_interface *)ar->arApDev;\n    ar->arNetDev = arApDev->arNetDev;\n\n    return 0;\n}\n\nint ar6000_stop_ap_interface(struct ar6_softc *ar)\n{\n    struct ar_virtual_interface *arApDev;\n\n    /* Change net_device to point to sta instance */\n    arApDev = (struct ar_virtual_interface *)ar->arApDev;\n    if (arApDev) {\n        ar->arNetDev = arApDev->arStaNetDev;\n    }\n\n    return 0;\n}\n\n\nint ar6000_create_ap_interface(struct ar6_softc *ar, char *ap_ifname)\n{\n    struct net_device *dev;\n    struct ar_virtual_interface *arApDev;\n\n    dev = alloc_etherdev(sizeof(struct ar_virtual_interface));\n    if (dev == NULL) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_create_ap_interface: can't alloc etherdev\\n\"));\n        return A_ERROR;\n    } \n    \n    ether_setup(dev);\n    init_netdev(dev, ap_ifname);\n    dev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\n    if (register_netdev(dev)) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_create_ap_interface: register_netdev failed\\n\"));\n        return A_ERROR;\n    }\n\n    arApDev = netdev_priv(dev);\n    arApDev->arDev = ar;\n    arApDev->arNetDev = dev;\n    arApDev->arStaNetDev = ar->arNetDev;\n\n    ar->arApDev = arApDev;\n    arApNetDev = dev;\n\n    /* Copy the MAC address */\n    memcpy(dev->dev_addr, ar->arNetDev->dev_addr, AR6000_ETH_ADDR_LEN);\n\n    return 0;\n}\n\nint ar6000_add_ap_interface(struct ar6_softc *ar, char *ap_ifname)\n{\n    /* Interface already added, need not proceed further */\n    if (ar->arApDev != NULL) {\n        AR_DEBUG_PRINTF(ATH_DEBUG_ERR,(\"ar6000_add_ap_interface: interface already present \\n\"));\n        return 0;\n    }\n\n    if (ar6000_create_ap_interface(ar, ap_ifname) != 0) {\n        return A_ERROR;\n    }\n\n    A_PRINTF(\"Add AP interface %s \\n\",ap_ifname);\n\n    return ar6000_start_ap_interface(ar);\n}\n\nint ar6000_remove_ap_interface(struct ar6_softc *ar)\n{\n    if (arApNetDev) {\n        ar6000_stop_ap_interface(ar);\n\n        unregister_netdev(arApNetDev);\n        free_netdev(apApNetDev);\n\n        A_PRINTF(\"Remove AP interface\\n\");\n    }\n    ar->arApDev = NULL;\n    arApNetDev = NULL;\n\n    \n    return 0;\n}\n#endif /* CONFIG_AP_VIRTUAL_ADAPTER_SUPPORT */\n\n\n#ifdef EXPORT_HCI_BRIDGE_INTERFACE\nEXPORT_SYMBOL(setupbtdev);\n#endif\n", "/* -*- linux-c -*-\n * INET\t\t802.1Q VLAN\n *\t\tEthernet-type device handling.\n *\n * Authors:\tBen Greear <greearb@candelatech.com>\n *              Please send support related email to: netdev@vger.kernel.org\n *              VLAN Home Page: http://www.candelatech.com/~greear/vlan.html\n *\n * Fixes:       Mar 22 2001: Martin Bokaemper <mbokaemper@unispherenetworks.com>\n *                - reset skb->pkt_type on incoming packets when MAC was changed\n *                - see that changed MAC is saddr for outgoing packets\n *              Oct 20, 2001:  Ard van Breeman:\n *                - Fix MC-list, finally.\n *                - Flush MC-list on VLAN destroy.\n *\n *\n *\t\tThis program is free software; you can redistribute it and/or\n *\t\tmodify it under the terms of the GNU General Public License\n *\t\tas published by the Free Software Foundation; either version\n *\t\t2 of the License, or (at your option) any later version.\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/skbuff.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/ethtool.h>\n#include <net/arp.h>\n\n#include \"vlan.h\"\n#include \"vlanproc.h\"\n#include <linux/if_vlan.h>\n\n/*\n *\tRebuild the Ethernet MAC header. This is called after an ARP\n *\t(or in future other address resolution) has completed on this\n *\tsk_buff. We now let ARP fill in the other fields.\n *\n *\tThis routine CANNOT use cached dst->neigh!\n *\tReally, it is used only when dst->neigh is wrong.\n *\n * TODO:  This needs a checkup, I'm ignorant here. --BLG\n */\nstatic int vlan_dev_rebuild_header(struct sk_buff *skb)\n{\n\tstruct net_device *dev = skb->dev;\n\tstruct vlan_ethhdr *veth = (struct vlan_ethhdr *)(skb->data);\n\n\tswitch (veth->h_vlan_encapsulated_proto) {\n#ifdef CONFIG_INET\n\tcase htons(ETH_P_IP):\n\n\t\t/* TODO:  Confirm this will work with VLAN headers... */\n\t\treturn arp_find(veth->h_dest, skb);\n#endif\n\tdefault:\n\t\tpr_debug(\"%s: unable to resolve type %X addresses\\n\",\n\t\t\t dev->name, ntohs(veth->h_vlan_encapsulated_proto));\n\n\t\tmemcpy(veth->h_source, dev->dev_addr, ETH_ALEN);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic inline u16\nvlan_dev_get_egress_qos_mask(struct net_device *dev, struct sk_buff *skb)\n{\n\tstruct vlan_priority_tci_mapping *mp;\n\n\tmp = vlan_dev_info(dev)->egress_priority_map[(skb->priority & 0xF)];\n\twhile (mp) {\n\t\tif (mp->priority == skb->priority) {\n\t\t\treturn mp->vlan_qos; /* This should already be shifted\n\t\t\t\t\t      * to mask correctly with the\n\t\t\t\t\t      * VLAN's TCI */\n\t\t}\n\t\tmp = mp->next;\n\t}\n\treturn 0;\n}\n\n/*\n *\tCreate the VLAN header for an arbitrary protocol layer\n *\n *\tsaddr=NULL\tmeans use device source address\n *\tdaddr=NULL\tmeans leave destination address (eg unresolved arp)\n *\n *  This is called when the SKB is moving down the stack towards the\n *  physical devices.\n */\nstatic int vlan_dev_hard_header(struct sk_buff *skb, struct net_device *dev,\n\t\t\t\tunsigned short type,\n\t\t\t\tconst void *daddr, const void *saddr,\n\t\t\t\tunsigned int len)\n{\n\tstruct vlan_hdr *vhdr;\n\tunsigned int vhdrlen = 0;\n\tu16 vlan_tci = 0;\n\tint rc;\n\n\tif (!(vlan_dev_info(dev)->flags & VLAN_FLAG_REORDER_HDR)) {\n\t\tvhdr = (struct vlan_hdr *) skb_push(skb, VLAN_HLEN);\n\n\t\tvlan_tci = vlan_dev_info(dev)->vlan_id;\n\t\tvlan_tci |= vlan_dev_get_egress_qos_mask(dev, skb);\n\t\tvhdr->h_vlan_TCI = htons(vlan_tci);\n\n\t\t/*\n\t\t *  Set the protocol type. For a packet of type ETH_P_802_3/2 we\n\t\t *  put the length in here instead.\n\t\t */\n\t\tif (type != ETH_P_802_3 && type != ETH_P_802_2)\n\t\t\tvhdr->h_vlan_encapsulated_proto = htons(type);\n\t\telse\n\t\t\tvhdr->h_vlan_encapsulated_proto = htons(len);\n\n\t\tskb->protocol = htons(ETH_P_8021Q);\n\t\ttype = ETH_P_8021Q;\n\t\tvhdrlen = VLAN_HLEN;\n\t}\n\n\t/* Before delegating work to the lower layer, enter our MAC-address */\n\tif (saddr == NULL)\n\t\tsaddr = dev->dev_addr;\n\n\t/* Now make the underlying real hard header */\n\tdev = vlan_dev_info(dev)->real_dev;\n\trc = dev_hard_header(skb, dev, type, daddr, saddr, len + vhdrlen);\n\tif (rc > 0)\n\t\trc += vhdrlen;\n\treturn rc;\n}\n\nstatic netdev_tx_t vlan_dev_hard_start_xmit(struct sk_buff *skb,\n\t\t\t\t\t    struct net_device *dev)\n{\n\tstruct vlan_ethhdr *veth = (struct vlan_ethhdr *)(skb->data);\n\tunsigned int len;\n\tint ret;\n\n\t/* Handle non-VLAN frames if they are sent to us, for example by DHCP.\n\t *\n\t * NOTE: THIS ASSUMES DIX ETHERNET, SPECIFICALLY NOT SUPPORTING\n\t * OTHER THINGS LIKE FDDI/TokenRing/802.3 SNAPs...\n\t */\n\tif (veth->h_vlan_proto != htons(ETH_P_8021Q) ||\n\t    vlan_dev_info(dev)->flags & VLAN_FLAG_REORDER_HDR) {\n\t\tu16 vlan_tci;\n\t\tvlan_tci = vlan_dev_info(dev)->vlan_id;\n\t\tvlan_tci |= vlan_dev_get_egress_qos_mask(dev, skb);\n\t\tskb = __vlan_hwaccel_put_tag(skb, vlan_tci);\n\t}\n\n\tskb_set_dev(skb, vlan_dev_info(dev)->real_dev);\n\tlen = skb->len;\n\tret = dev_queue_xmit(skb);\n\n\tif (likely(ret == NET_XMIT_SUCCESS || ret == NET_XMIT_CN)) {\n\t\tstruct vlan_pcpu_stats *stats;\n\n\t\tstats = this_cpu_ptr(vlan_dev_info(dev)->vlan_pcpu_stats);\n\t\tu64_stats_update_begin(&stats->syncp);\n\t\tstats->tx_packets++;\n\t\tstats->tx_bytes += len;\n\t\tu64_stats_update_end(&stats->syncp);\n\t} else {\n\t\tthis_cpu_inc(vlan_dev_info(dev)->vlan_pcpu_stats->tx_dropped);\n\t}\n\n\treturn ret;\n}\n\nstatic int vlan_dev_change_mtu(struct net_device *dev, int new_mtu)\n{\n\t/* TODO: gotta make sure the underlying layer can handle it,\n\t * maybe an IFF_VLAN_CAPABLE flag for devices?\n\t */\n\tif (vlan_dev_info(dev)->real_dev->mtu < new_mtu)\n\t\treturn -ERANGE;\n\n\tdev->mtu = new_mtu;\n\n\treturn 0;\n}\n\nvoid vlan_dev_set_ingress_priority(const struct net_device *dev,\n\t\t\t\t   u32 skb_prio, u16 vlan_prio)\n{\n\tstruct vlan_dev_info *vlan = vlan_dev_info(dev);\n\n\tif (vlan->ingress_priority_map[vlan_prio & 0x7] && !skb_prio)\n\t\tvlan->nr_ingress_mappings--;\n\telse if (!vlan->ingress_priority_map[vlan_prio & 0x7] && skb_prio)\n\t\tvlan->nr_ingress_mappings++;\n\n\tvlan->ingress_priority_map[vlan_prio & 0x7] = skb_prio;\n}\n\nint vlan_dev_set_egress_priority(const struct net_device *dev,\n\t\t\t\t u32 skb_prio, u16 vlan_prio)\n{\n\tstruct vlan_dev_info *vlan = vlan_dev_info(dev);\n\tstruct vlan_priority_tci_mapping *mp = NULL;\n\tstruct vlan_priority_tci_mapping *np;\n\tu32 vlan_qos = (vlan_prio << VLAN_PRIO_SHIFT) & VLAN_PRIO_MASK;\n\n\t/* See if a priority mapping exists.. */\n\tmp = vlan->egress_priority_map[skb_prio & 0xF];\n\twhile (mp) {\n\t\tif (mp->priority == skb_prio) {\n\t\t\tif (mp->vlan_qos && !vlan_qos)\n\t\t\t\tvlan->nr_egress_mappings--;\n\t\t\telse if (!mp->vlan_qos && vlan_qos)\n\t\t\t\tvlan->nr_egress_mappings++;\n\t\t\tmp->vlan_qos = vlan_qos;\n\t\t\treturn 0;\n\t\t}\n\t\tmp = mp->next;\n\t}\n\n\t/* Create a new mapping then. */\n\tmp = vlan->egress_priority_map[skb_prio & 0xF];\n\tnp = kmalloc(sizeof(struct vlan_priority_tci_mapping), GFP_KERNEL);\n\tif (!np)\n\t\treturn -ENOBUFS;\n\n\tnp->next = mp;\n\tnp->priority = skb_prio;\n\tnp->vlan_qos = vlan_qos;\n\tvlan->egress_priority_map[skb_prio & 0xF] = np;\n\tif (vlan_qos)\n\t\tvlan->nr_egress_mappings++;\n\treturn 0;\n}\n\n/* Flags are defined in the vlan_flags enum in include/linux/if_vlan.h file. */\nint vlan_dev_change_flags(const struct net_device *dev, u32 flags, u32 mask)\n{\n\tstruct vlan_dev_info *vlan = vlan_dev_info(dev);\n\tu32 old_flags = vlan->flags;\n\n\tif (mask & ~(VLAN_FLAG_REORDER_HDR | VLAN_FLAG_GVRP |\n\t\t     VLAN_FLAG_LOOSE_BINDING))\n\t\treturn -EINVAL;\n\n\tvlan->flags = (old_flags & ~mask) | (flags & mask);\n\n\tif (netif_running(dev) && (vlan->flags ^ old_flags) & VLAN_FLAG_GVRP) {\n\t\tif (vlan->flags & VLAN_FLAG_GVRP)\n\t\t\tvlan_gvrp_request_join(dev);\n\t\telse\n\t\t\tvlan_gvrp_request_leave(dev);\n\t}\n\treturn 0;\n}\n\nvoid vlan_dev_get_realdev_name(const struct net_device *dev, char *result)\n{\n\tstrncpy(result, vlan_dev_info(dev)->real_dev->name, 23);\n}\n\nstatic int vlan_dev_open(struct net_device *dev)\n{\n\tstruct vlan_dev_info *vlan = vlan_dev_info(dev);\n\tstruct net_device *real_dev = vlan->real_dev;\n\tint err;\n\n\tif (!(real_dev->flags & IFF_UP) &&\n\t    !(vlan->flags & VLAN_FLAG_LOOSE_BINDING))\n\t\treturn -ENETDOWN;\n\n\tif (compare_ether_addr(dev->dev_addr, real_dev->dev_addr)) {\n\t\terr = dev_uc_add(real_dev, dev->dev_addr);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (dev->flags & IFF_ALLMULTI) {\n\t\terr = dev_set_allmulti(real_dev, 1);\n\t\tif (err < 0)\n\t\t\tgoto del_unicast;\n\t}\n\tif (dev->flags & IFF_PROMISC) {\n\t\terr = dev_set_promiscuity(real_dev, 1);\n\t\tif (err < 0)\n\t\t\tgoto clear_allmulti;\n\t}\n\n\tmemcpy(vlan->real_dev_addr, real_dev->dev_addr, ETH_ALEN);\n\n\tif (vlan->flags & VLAN_FLAG_GVRP)\n\t\tvlan_gvrp_request_join(dev);\n\n\tif (netif_carrier_ok(real_dev))\n\t\tnetif_carrier_on(dev);\n\treturn 0;\n\nclear_allmulti:\n\tif (dev->flags & IFF_ALLMULTI)\n\t\tdev_set_allmulti(real_dev, -1);\ndel_unicast:\n\tif (compare_ether_addr(dev->dev_addr, real_dev->dev_addr))\n\t\tdev_uc_del(real_dev, dev->dev_addr);\nout:\n\tnetif_carrier_off(dev);\n\treturn err;\n}\n\nstatic int vlan_dev_stop(struct net_device *dev)\n{\n\tstruct vlan_dev_info *vlan = vlan_dev_info(dev);\n\tstruct net_device *real_dev = vlan->real_dev;\n\n\tdev_mc_unsync(real_dev, dev);\n\tdev_uc_unsync(real_dev, dev);\n\tif (dev->flags & IFF_ALLMULTI)\n\t\tdev_set_allmulti(real_dev, -1);\n\tif (dev->flags & IFF_PROMISC)\n\t\tdev_set_promiscuity(real_dev, -1);\n\n\tif (compare_ether_addr(dev->dev_addr, real_dev->dev_addr))\n\t\tdev_uc_del(real_dev, dev->dev_addr);\n\n\tnetif_carrier_off(dev);\n\treturn 0;\n}\n\nstatic int vlan_dev_set_mac_address(struct net_device *dev, void *p)\n{\n\tstruct net_device *real_dev = vlan_dev_info(dev)->real_dev;\n\tstruct sockaddr *addr = p;\n\tint err;\n\n\tif (!is_valid_ether_addr(addr->sa_data))\n\t\treturn -EADDRNOTAVAIL;\n\n\tif (!(dev->flags & IFF_UP))\n\t\tgoto out;\n\n\tif (compare_ether_addr(addr->sa_data, real_dev->dev_addr)) {\n\t\terr = dev_uc_add(real_dev, addr->sa_data);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\tif (compare_ether_addr(dev->dev_addr, real_dev->dev_addr))\n\t\tdev_uc_del(real_dev, dev->dev_addr);\n\nout:\n\tmemcpy(dev->dev_addr, addr->sa_data, ETH_ALEN);\n\treturn 0;\n}\n\nstatic int vlan_dev_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n\tstruct net_device *real_dev = vlan_dev_info(dev)->real_dev;\n\tconst struct net_device_ops *ops = real_dev->netdev_ops;\n\tstruct ifreq ifrr;\n\tint err = -EOPNOTSUPP;\n\n\tstrncpy(ifrr.ifr_name, real_dev->name, IFNAMSIZ);\n\tifrr.ifr_ifru = ifr->ifr_ifru;\n\n\tswitch (cmd) {\n\tcase SIOCGMIIPHY:\n\tcase SIOCGMIIREG:\n\tcase SIOCSMIIREG:\n\t\tif (netif_device_present(real_dev) && ops->ndo_do_ioctl)\n\t\t\terr = ops->ndo_do_ioctl(real_dev, &ifrr, cmd);\n\t\tbreak;\n\t}\n\n\tif (!err)\n\t\tifr->ifr_ifru = ifrr.ifr_ifru;\n\n\treturn err;\n}\n\nstatic int vlan_dev_neigh_setup(struct net_device *dev, struct neigh_parms *pa)\n{\n\tstruct net_device *real_dev = vlan_dev_info(dev)->real_dev;\n\tconst struct net_device_ops *ops = real_dev->netdev_ops;\n\tint err = 0;\n\n\tif (netif_device_present(real_dev) && ops->ndo_neigh_setup)\n\t\terr = ops->ndo_neigh_setup(real_dev, pa);\n\n\treturn err;\n}\n\n#if defined(CONFIG_FCOE) || defined(CONFIG_FCOE_MODULE)\nstatic int vlan_dev_fcoe_ddp_setup(struct net_device *dev, u16 xid,\n\t\t\t\t   struct scatterlist *sgl, unsigned int sgc)\n{\n\tstruct net_device *real_dev = vlan_dev_info(dev)->real_dev;\n\tconst struct net_device_ops *ops = real_dev->netdev_ops;\n\tint rc = 0;\n\n\tif (ops->ndo_fcoe_ddp_setup)\n\t\trc = ops->ndo_fcoe_ddp_setup(real_dev, xid, sgl, sgc);\n\n\treturn rc;\n}\n\nstatic int vlan_dev_fcoe_ddp_done(struct net_device *dev, u16 xid)\n{\n\tstruct net_device *real_dev = vlan_dev_info(dev)->real_dev;\n\tconst struct net_device_ops *ops = real_dev->netdev_ops;\n\tint len = 0;\n\n\tif (ops->ndo_fcoe_ddp_done)\n\t\tlen = ops->ndo_fcoe_ddp_done(real_dev, xid);\n\n\treturn len;\n}\n\nstatic int vlan_dev_fcoe_enable(struct net_device *dev)\n{\n\tstruct net_device *real_dev = vlan_dev_info(dev)->real_dev;\n\tconst struct net_device_ops *ops = real_dev->netdev_ops;\n\tint rc = -EINVAL;\n\n\tif (ops->ndo_fcoe_enable)\n\t\trc = ops->ndo_fcoe_enable(real_dev);\n\treturn rc;\n}\n\nstatic int vlan_dev_fcoe_disable(struct net_device *dev)\n{\n\tstruct net_device *real_dev = vlan_dev_info(dev)->real_dev;\n\tconst struct net_device_ops *ops = real_dev->netdev_ops;\n\tint rc = -EINVAL;\n\n\tif (ops->ndo_fcoe_disable)\n\t\trc = ops->ndo_fcoe_disable(real_dev);\n\treturn rc;\n}\n\nstatic int vlan_dev_fcoe_get_wwn(struct net_device *dev, u64 *wwn, int type)\n{\n\tstruct net_device *real_dev = vlan_dev_info(dev)->real_dev;\n\tconst struct net_device_ops *ops = real_dev->netdev_ops;\n\tint rc = -EINVAL;\n\n\tif (ops->ndo_fcoe_get_wwn)\n\t\trc = ops->ndo_fcoe_get_wwn(real_dev, wwn, type);\n\treturn rc;\n}\n\nstatic int vlan_dev_fcoe_ddp_target(struct net_device *dev, u16 xid,\n\t\t\t\t    struct scatterlist *sgl, unsigned int sgc)\n{\n\tstruct net_device *real_dev = vlan_dev_info(dev)->real_dev;\n\tconst struct net_device_ops *ops = real_dev->netdev_ops;\n\tint rc = 0;\n\n\tif (ops->ndo_fcoe_ddp_target)\n\t\trc = ops->ndo_fcoe_ddp_target(real_dev, xid, sgl, sgc);\n\n\treturn rc;\n}\n#endif\n\nstatic void vlan_dev_change_rx_flags(struct net_device *dev, int change)\n{\n\tstruct net_device *real_dev = vlan_dev_info(dev)->real_dev;\n\n\tif (change & IFF_ALLMULTI)\n\t\tdev_set_allmulti(real_dev, dev->flags & IFF_ALLMULTI ? 1 : -1);\n\tif (change & IFF_PROMISC)\n\t\tdev_set_promiscuity(real_dev, dev->flags & IFF_PROMISC ? 1 : -1);\n}\n\nstatic void vlan_dev_set_rx_mode(struct net_device *vlan_dev)\n{\n\tdev_mc_sync(vlan_dev_info(vlan_dev)->real_dev, vlan_dev);\n\tdev_uc_sync(vlan_dev_info(vlan_dev)->real_dev, vlan_dev);\n}\n\n/*\n * vlan network devices have devices nesting below it, and are a special\n * \"super class\" of normal network devices; split their locks off into a\n * separate class since they always nest.\n */\nstatic struct lock_class_key vlan_netdev_xmit_lock_key;\nstatic struct lock_class_key vlan_netdev_addr_lock_key;\n\nstatic void vlan_dev_set_lockdep_one(struct net_device *dev,\n\t\t\t\t     struct netdev_queue *txq,\n\t\t\t\t     void *_subclass)\n{\n\tlockdep_set_class_and_subclass(&txq->_xmit_lock,\n\t\t\t\t       &vlan_netdev_xmit_lock_key,\n\t\t\t\t       *(int *)_subclass);\n}\n\nstatic void vlan_dev_set_lockdep_class(struct net_device *dev, int subclass)\n{\n\tlockdep_set_class_and_subclass(&dev->addr_list_lock,\n\t\t\t\t       &vlan_netdev_addr_lock_key,\n\t\t\t\t       subclass);\n\tnetdev_for_each_tx_queue(dev, vlan_dev_set_lockdep_one, &subclass);\n}\n\nstatic const struct header_ops vlan_header_ops = {\n\t.create\t = vlan_dev_hard_header,\n\t.rebuild = vlan_dev_rebuild_header,\n\t.parse\t = eth_header_parse,\n};\n\nstatic const struct net_device_ops vlan_netdev_ops;\n\nstatic int vlan_dev_init(struct net_device *dev)\n{\n\tstruct net_device *real_dev = vlan_dev_info(dev)->real_dev;\n\tint subclass = 0;\n\n\tnetif_carrier_off(dev);\n\n\t/* IFF_BROADCAST|IFF_MULTICAST; ??? */\n\tdev->flags  = real_dev->flags & ~(IFF_UP | IFF_PROMISC | IFF_ALLMULTI |\n\t\t\t\t\t  IFF_MASTER | IFF_SLAVE);\n\tdev->iflink = real_dev->ifindex;\n\tdev->state  = (real_dev->state & ((1<<__LINK_STATE_NOCARRIER) |\n\t\t\t\t\t  (1<<__LINK_STATE_DORMANT))) |\n\t\t      (1<<__LINK_STATE_PRESENT);\n\n\tdev->hw_features = NETIF_F_ALL_CSUM | NETIF_F_SG |\n\t\t\t   NETIF_F_FRAGLIST | NETIF_F_ALL_TSO |\n\t\t\t   NETIF_F_HIGHDMA | NETIF_F_SCTP_CSUM |\n\t\t\t   NETIF_F_ALL_FCOE;\n\n\tdev->features |= real_dev->vlan_features | NETIF_F_LLTX;\n\tdev->gso_max_size = real_dev->gso_max_size;\n\n\t/* ipv6 shared card related stuff */\n\tdev->dev_id = real_dev->dev_id;\n\n\tif (is_zero_ether_addr(dev->dev_addr))\n\t\tmemcpy(dev->dev_addr, real_dev->dev_addr, dev->addr_len);\n\tif (is_zero_ether_addr(dev->broadcast))\n\t\tmemcpy(dev->broadcast, real_dev->broadcast, dev->addr_len);\n\n#if defined(CONFIG_FCOE) || defined(CONFIG_FCOE_MODULE)\n\tdev->fcoe_ddp_xid = real_dev->fcoe_ddp_xid;\n#endif\n\n\tdev->needed_headroom = real_dev->needed_headroom;\n\tif (real_dev->features & NETIF_F_HW_VLAN_TX) {\n\t\tdev->header_ops      = real_dev->header_ops;\n\t\tdev->hard_header_len = real_dev->hard_header_len;\n\t} else {\n\t\tdev->header_ops      = &vlan_header_ops;\n\t\tdev->hard_header_len = real_dev->hard_header_len + VLAN_HLEN;\n\t}\n\n\tdev->netdev_ops = &vlan_netdev_ops;\n\n\tif (is_vlan_dev(real_dev))\n\t\tsubclass = 1;\n\n\tvlan_dev_set_lockdep_class(dev, subclass);\n\n\tvlan_dev_info(dev)->vlan_pcpu_stats = alloc_percpu(struct vlan_pcpu_stats);\n\tif (!vlan_dev_info(dev)->vlan_pcpu_stats)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic void vlan_dev_uninit(struct net_device *dev)\n{\n\tstruct vlan_priority_tci_mapping *pm;\n\tstruct vlan_dev_info *vlan = vlan_dev_info(dev);\n\tint i;\n\n\tfree_percpu(vlan->vlan_pcpu_stats);\n\tvlan->vlan_pcpu_stats = NULL;\n\tfor (i = 0; i < ARRAY_SIZE(vlan->egress_priority_map); i++) {\n\t\twhile ((pm = vlan->egress_priority_map[i]) != NULL) {\n\t\t\tvlan->egress_priority_map[i] = pm->next;\n\t\t\tkfree(pm);\n\t\t}\n\t}\n}\n\nstatic u32 vlan_dev_fix_features(struct net_device *dev, u32 features)\n{\n\tstruct net_device *real_dev = vlan_dev_info(dev)->real_dev;\n\tu32 old_features = features;\n\n\tfeatures &= real_dev->features;\n\tfeatures &= real_dev->vlan_features;\n\n\tfeatures |= old_features & NETIF_F_SOFT_FEATURES;\n\n\tif (dev_ethtool_get_rx_csum(real_dev))\n\t\tfeatures |= NETIF_F_RXCSUM;\n\tfeatures |= NETIF_F_LLTX;\n\n\treturn features;\n}\n\nstatic int vlan_ethtool_get_settings(struct net_device *dev,\n\t\t\t\t     struct ethtool_cmd *cmd)\n{\n\tconst struct vlan_dev_info *vlan = vlan_dev_info(dev);\n\treturn dev_ethtool_get_settings(vlan->real_dev, cmd);\n}\n\nstatic void vlan_ethtool_get_drvinfo(struct net_device *dev,\n\t\t\t\t     struct ethtool_drvinfo *info)\n{\n\tstrcpy(info->driver, vlan_fullname);\n\tstrcpy(info->version, vlan_version);\n\tstrcpy(info->fw_version, \"N/A\");\n}\n\nstatic struct rtnl_link_stats64 *vlan_dev_get_stats64(struct net_device *dev, struct rtnl_link_stats64 *stats)\n{\n\n\tif (vlan_dev_info(dev)->vlan_pcpu_stats) {\n\t\tstruct vlan_pcpu_stats *p;\n\t\tu32 rx_errors = 0, tx_dropped = 0;\n\t\tint i;\n\n\t\tfor_each_possible_cpu(i) {\n\t\t\tu64 rxpackets, rxbytes, rxmulticast, txpackets, txbytes;\n\t\t\tunsigned int start;\n\n\t\t\tp = per_cpu_ptr(vlan_dev_info(dev)->vlan_pcpu_stats, i);\n\t\t\tdo {\n\t\t\t\tstart = u64_stats_fetch_begin_bh(&p->syncp);\n\t\t\t\trxpackets\t= p->rx_packets;\n\t\t\t\trxbytes\t\t= p->rx_bytes;\n\t\t\t\trxmulticast\t= p->rx_multicast;\n\t\t\t\ttxpackets\t= p->tx_packets;\n\t\t\t\ttxbytes\t\t= p->tx_bytes;\n\t\t\t} while (u64_stats_fetch_retry_bh(&p->syncp, start));\n\n\t\t\tstats->rx_packets\t+= rxpackets;\n\t\t\tstats->rx_bytes\t\t+= rxbytes;\n\t\t\tstats->multicast\t+= rxmulticast;\n\t\t\tstats->tx_packets\t+= txpackets;\n\t\t\tstats->tx_bytes\t\t+= txbytes;\n\t\t\t/* rx_errors & tx_dropped are u32 */\n\t\t\trx_errors\t+= p->rx_errors;\n\t\t\ttx_dropped\t+= p->tx_dropped;\n\t\t}\n\t\tstats->rx_errors  = rx_errors;\n\t\tstats->tx_dropped = tx_dropped;\n\t}\n\treturn stats;\n}\n\nstatic const struct ethtool_ops vlan_ethtool_ops = {\n\t.get_settings\t        = vlan_ethtool_get_settings,\n\t.get_drvinfo\t        = vlan_ethtool_get_drvinfo,\n\t.get_link\t\t= ethtool_op_get_link,\n};\n\nstatic const struct net_device_ops vlan_netdev_ops = {\n\t.ndo_change_mtu\t\t= vlan_dev_change_mtu,\n\t.ndo_init\t\t= vlan_dev_init,\n\t.ndo_uninit\t\t= vlan_dev_uninit,\n\t.ndo_open\t\t= vlan_dev_open,\n\t.ndo_stop\t\t= vlan_dev_stop,\n\t.ndo_start_xmit =  vlan_dev_hard_start_xmit,\n\t.ndo_validate_addr\t= eth_validate_addr,\n\t.ndo_set_mac_address\t= vlan_dev_set_mac_address,\n\t.ndo_set_rx_mode\t= vlan_dev_set_rx_mode,\n\t.ndo_set_multicast_list\t= vlan_dev_set_rx_mode,\n\t.ndo_change_rx_flags\t= vlan_dev_change_rx_flags,\n\t.ndo_do_ioctl\t\t= vlan_dev_ioctl,\n\t.ndo_neigh_setup\t= vlan_dev_neigh_setup,\n\t.ndo_get_stats64\t= vlan_dev_get_stats64,\n#if defined(CONFIG_FCOE) || defined(CONFIG_FCOE_MODULE)\n\t.ndo_fcoe_ddp_setup\t= vlan_dev_fcoe_ddp_setup,\n\t.ndo_fcoe_ddp_done\t= vlan_dev_fcoe_ddp_done,\n\t.ndo_fcoe_enable\t= vlan_dev_fcoe_enable,\n\t.ndo_fcoe_disable\t= vlan_dev_fcoe_disable,\n\t.ndo_fcoe_get_wwn\t= vlan_dev_fcoe_get_wwn,\n\t.ndo_fcoe_ddp_target\t= vlan_dev_fcoe_ddp_target,\n#endif\n\t.ndo_fix_features\t= vlan_dev_fix_features,\n};\n\nvoid vlan_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\n\tdev->priv_flags\t\t|= IFF_802_1Q_VLAN;\n\tdev->priv_flags\t\t&= ~(IFF_XMIT_DST_RELEASE | IFF_TX_SKB_SHARING);\n\tdev->tx_queue_len\t= 0;\n\n\tdev->netdev_ops\t\t= &vlan_netdev_ops;\n\tdev->destructor\t\t= free_netdev;\n\tdev->ethtool_ops\t= &vlan_ethtool_ops;\n\n\tmemset(dev->broadcast, 0, ETH_ALEN);\n}\n", "/*\n   BNEP implementation for Linux Bluetooth stack (BlueZ).\n   Copyright (C) 2001-2002 Inventel Systemes\n   Written 2001-2002 by\n\tCl\u00e9ment Moreau <clement.moreau@inventel.fr>\n\tDavid Libault  <david.libault@inventel.fr>\n\n   Copyright (C) 2002 Maxim Krasnyansky <maxk@qualcomm.com>\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License version 2 as\n   published by the Free Software Foundation;\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.\n   IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY\n   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES\n   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS,\n   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS\n   SOFTWARE IS DISCLAIMED.\n*/\n\n#include <linux/module.h>\n#include <linux/slab.h>\n\n#include <linux/socket.h>\n#include <linux/netdevice.h>\n#include <linux/etherdevice.h>\n#include <linux/skbuff.h>\n#include <linux/wait.h>\n\n#include <asm/unaligned.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <net/bluetooth/l2cap.h>\n\n#include \"bnep.h\"\n\n#define BNEP_TX_QUEUE_LEN 20\n\nstatic int bnep_net_open(struct net_device *dev)\n{\n\tnetif_start_queue(dev);\n\treturn 0;\n}\n\nstatic int bnep_net_close(struct net_device *dev)\n{\n\tnetif_stop_queue(dev);\n\treturn 0;\n}\n\nstatic void bnep_net_set_mc_list(struct net_device *dev)\n{\n#ifdef CONFIG_BT_BNEP_MC_FILTER\n\tstruct bnep_session *s = netdev_priv(dev);\n\tstruct sock *sk = s->sock->sk;\n\tstruct bnep_set_filter_req *r;\n\tstruct sk_buff *skb;\n\tint size;\n\n\tBT_DBG(\"%s mc_count %d\", dev->name, netdev_mc_count(dev));\n\n\tsize = sizeof(*r) + (BNEP_MAX_MULTICAST_FILTERS + 1) * ETH_ALEN * 2;\n\tskb  = alloc_skb(size, GFP_ATOMIC);\n\tif (!skb) {\n\t\tBT_ERR(\"%s Multicast list allocation failed\", dev->name);\n\t\treturn;\n\t}\n\n\tr = (void *) skb->data;\n\t__skb_put(skb, sizeof(*r));\n\n\tr->type = BNEP_CONTROL;\n\tr->ctrl = BNEP_FILTER_MULTI_ADDR_SET;\n\n\tif (dev->flags & (IFF_PROMISC | IFF_ALLMULTI)) {\n\t\tu8 start[ETH_ALEN] = { 0x01 };\n\n\t\t/* Request all addresses */\n\t\tmemcpy(__skb_put(skb, ETH_ALEN), start, ETH_ALEN);\n\t\tmemcpy(__skb_put(skb, ETH_ALEN), dev->broadcast, ETH_ALEN);\n\t\tr->len = htons(ETH_ALEN * 2);\n\t} else {\n\t\tstruct netdev_hw_addr *ha;\n\t\tint i, len = skb->len;\n\n\t\tif (dev->flags & IFF_BROADCAST) {\n\t\t\tmemcpy(__skb_put(skb, ETH_ALEN), dev->broadcast, ETH_ALEN);\n\t\t\tmemcpy(__skb_put(skb, ETH_ALEN), dev->broadcast, ETH_ALEN);\n\t\t}\n\n\t\t/* FIXME: We should group addresses here. */\n\n\t\ti = 0;\n\t\tnetdev_for_each_mc_addr(ha, dev) {\n\t\t\tif (i == BNEP_MAX_MULTICAST_FILTERS)\n\t\t\t\tbreak;\n\t\t\tmemcpy(__skb_put(skb, ETH_ALEN), ha->addr, ETH_ALEN);\n\t\t\tmemcpy(__skb_put(skb, ETH_ALEN), ha->addr, ETH_ALEN);\n\n\t\t\ti++;\n\t\t}\n\t\tr->len = htons(skb->len - len);\n\t}\n\n\tskb_queue_tail(&sk->sk_write_queue, skb);\n\twake_up_interruptible(sk_sleep(sk));\n#endif\n}\n\nstatic int bnep_net_set_mac_addr(struct net_device *dev, void *arg)\n{\n\tBT_DBG(\"%s\", dev->name);\n\treturn 0;\n}\n\nstatic void bnep_net_timeout(struct net_device *dev)\n{\n\tBT_DBG(\"net_timeout\");\n\tnetif_wake_queue(dev);\n}\n\n#ifdef CONFIG_BT_BNEP_MC_FILTER\nstatic inline int bnep_net_mc_filter(struct sk_buff *skb, struct bnep_session *s)\n{\n\tstruct ethhdr *eh = (void *) skb->data;\n\n\tif ((eh->h_dest[0] & 1) && !test_bit(bnep_mc_hash(eh->h_dest), (ulong *) &s->mc_filter))\n\t\treturn 1;\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_BT_BNEP_PROTO_FILTER\n/* Determine ether protocol. Based on eth_type_trans. */\nstatic inline u16 bnep_net_eth_proto(struct sk_buff *skb)\n{\n\tstruct ethhdr *eh = (void *) skb->data;\n\tu16 proto = ntohs(eh->h_proto);\n\n\tif (proto >= 1536)\n\t\treturn proto;\n\n\tif (get_unaligned((__be16 *) skb->data) == htons(0xFFFF))\n\t\treturn ETH_P_802_3;\n\n\treturn ETH_P_802_2;\n}\n\nstatic inline int bnep_net_proto_filter(struct sk_buff *skb, struct bnep_session *s)\n{\n\tu16 proto = bnep_net_eth_proto(skb);\n\tstruct bnep_proto_filter *f = s->proto_filter;\n\tint i;\n\n\tfor (i = 0; i < BNEP_MAX_PROTO_FILTERS && f[i].end; i++) {\n\t\tif (proto >= f[i].start && proto <= f[i].end)\n\t\t\treturn 0;\n\t}\n\n\tBT_DBG(\"BNEP: filtered skb %p, proto 0x%.4x\", skb, proto);\n\treturn 1;\n}\n#endif\n\nstatic netdev_tx_t bnep_net_xmit(struct sk_buff *skb,\n\t\t\t\t struct net_device *dev)\n{\n\tstruct bnep_session *s = netdev_priv(dev);\n\tstruct sock *sk = s->sock->sk;\n\n\tBT_DBG(\"skb %p, dev %p\", skb, dev);\n\n#ifdef CONFIG_BT_BNEP_MC_FILTER\n\tif (bnep_net_mc_filter(skb, s)) {\n\t\tkfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n#endif\n\n#ifdef CONFIG_BT_BNEP_PROTO_FILTER\n\tif (bnep_net_proto_filter(skb, s)) {\n\t\tkfree_skb(skb);\n\t\treturn NETDEV_TX_OK;\n\t}\n#endif\n\n\t/*\n\t * We cannot send L2CAP packets from here as we are potentially in a bh.\n\t * So we have to queue them and wake up session thread which is sleeping\n\t * on the sk_sleep(sk).\n\t */\n\tdev->trans_start = jiffies;\n\tskb_queue_tail(&sk->sk_write_queue, skb);\n\twake_up_interruptible(sk_sleep(sk));\n\n\tif (skb_queue_len(&sk->sk_write_queue) >= BNEP_TX_QUEUE_LEN) {\n\t\tBT_DBG(\"tx queue is full\");\n\n\t\t/* Stop queuing.\n\t\t * Session thread will do netif_wake_queue() */\n\t\tnetif_stop_queue(dev);\n\t}\n\n\treturn NETDEV_TX_OK;\n}\n\nstatic const struct net_device_ops bnep_netdev_ops = {\n\t.ndo_open            = bnep_net_open,\n\t.ndo_stop            = bnep_net_close,\n\t.ndo_start_xmit\t     = bnep_net_xmit,\n\t.ndo_validate_addr   = eth_validate_addr,\n\t.ndo_set_multicast_list = bnep_net_set_mc_list,\n\t.ndo_set_mac_address = bnep_net_set_mac_addr,\n\t.ndo_tx_timeout      = bnep_net_timeout,\n\t.ndo_change_mtu\t     = eth_change_mtu,\n\n};\n\nvoid bnep_net_setup(struct net_device *dev)\n{\n\n\tmemset(dev->broadcast, 0xff, ETH_ALEN);\n\tdev->addr_len = ETH_ALEN;\n\n\tether_setup(dev);\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tdev->netdev_ops = &bnep_netdev_ops;\n\n\tdev->watchdog_timeo  = HZ * 2;\n}\n", "/*\n * L2TPv3 ethernet pseudowire driver\n *\n * Copyright (c) 2008,2009,2010 Katalix Systems Ltd\n *\n *\tThis program is free software; you can redistribute it and/or\n *\tmodify it under the terms of the GNU General Public License\n *\tas published by the Free Software Foundation; either version\n *\t2 of the License, or (at your option) any later version.\n */\n\n#include <linux/module.h>\n#include <linux/skbuff.h>\n#include <linux/socket.h>\n#include <linux/hash.h>\n#include <linux/l2tp.h>\n#include <linux/in.h>\n#include <linux/etherdevice.h>\n#include <linux/spinlock.h>\n#include <net/sock.h>\n#include <net/ip.h>\n#include <net/icmp.h>\n#include <net/udp.h>\n#include <net/inet_common.h>\n#include <net/inet_hashtables.h>\n#include <net/tcp_states.h>\n#include <net/protocol.h>\n#include <net/xfrm.h>\n#include <net/net_namespace.h>\n#include <net/netns/generic.h>\n\n#include \"l2tp_core.h\"\n\n/* Default device name. May be overridden by name specified by user */\n#define L2TP_ETH_DEV_NAME\t\"l2tpeth%d\"\n\n/* via netdev_priv() */\nstruct l2tp_eth {\n\tstruct net_device\t*dev;\n\tstruct sock\t\t*tunnel_sock;\n\tstruct l2tp_session\t*session;\n\tstruct list_head\tlist;\n};\n\n/* via l2tp_session_priv() */\nstruct l2tp_eth_sess {\n\tstruct net_device\t*dev;\n};\n\n/* per-net private data for this module */\nstatic unsigned int l2tp_eth_net_id;\nstruct l2tp_eth_net {\n\tstruct list_head l2tp_eth_dev_list;\n\tspinlock_t l2tp_eth_lock;\n};\n\nstatic inline struct l2tp_eth_net *l2tp_eth_pernet(struct net *net)\n{\n\treturn net_generic(net, l2tp_eth_net_id);\n}\n\nstatic int l2tp_eth_dev_init(struct net_device *dev)\n{\n\tstruct l2tp_eth *priv = netdev_priv(dev);\n\n\tpriv->dev = dev;\n\trandom_ether_addr(dev->dev_addr);\n\tmemset(&dev->broadcast[0], 0xff, 6);\n\n\treturn 0;\n}\n\nstatic void l2tp_eth_dev_uninit(struct net_device *dev)\n{\n\tstruct l2tp_eth *priv = netdev_priv(dev);\n\tstruct l2tp_eth_net *pn = l2tp_eth_pernet(dev_net(dev));\n\n\tspin_lock(&pn->l2tp_eth_lock);\n\tlist_del_init(&priv->list);\n\tspin_unlock(&pn->l2tp_eth_lock);\n\tdev_put(dev);\n}\n\nstatic int l2tp_eth_dev_xmit(struct sk_buff *skb, struct net_device *dev)\n{\n\tstruct l2tp_eth *priv = netdev_priv(dev);\n\tstruct l2tp_session *session = priv->session;\n\n\tl2tp_xmit_skb(session, skb, session->hdr_len);\n\n\tdev->stats.tx_bytes += skb->len;\n\tdev->stats.tx_packets++;\n\n\treturn 0;\n}\n\nstatic struct net_device_ops l2tp_eth_netdev_ops = {\n\t.ndo_init\t\t= l2tp_eth_dev_init,\n\t.ndo_uninit\t\t= l2tp_eth_dev_uninit,\n\t.ndo_start_xmit\t\t= l2tp_eth_dev_xmit,\n};\n\nstatic void l2tp_eth_dev_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tdev->netdev_ops\t\t= &l2tp_eth_netdev_ops;\n\tdev->destructor\t\t= free_netdev;\n}\n\nstatic void l2tp_eth_dev_recv(struct l2tp_session *session, struct sk_buff *skb, int data_len)\n{\n\tstruct l2tp_eth_sess *spriv = l2tp_session_priv(session);\n\tstruct net_device *dev = spriv->dev;\n\n\tif (session->debug & L2TP_MSG_DATA) {\n\t\tunsigned int length;\n\t\tint offset;\n\t\tu8 *ptr = skb->data;\n\n\t\tlength = min(32u, skb->len);\n\t\tif (!pskb_may_pull(skb, length))\n\t\t\tgoto error;\n\n\t\tprintk(KERN_DEBUG \"%s: eth recv: \", session->name);\n\n\t\toffset = 0;\n\t\tdo {\n\t\t\tprintk(\" %02X\", ptr[offset]);\n\t\t} while (++offset < length);\n\n\t\tprintk(\"\\n\");\n\t}\n\n\tif (!pskb_may_pull(skb, sizeof(ETH_HLEN)))\n\t\tgoto error;\n\n\tsecpath_reset(skb);\n\n\t/* checksums verified by L2TP */\n\tskb->ip_summed = CHECKSUM_NONE;\n\n\tskb_dst_drop(skb);\n\tnf_reset(skb);\n\n\tif (dev_forward_skb(dev, skb) == NET_RX_SUCCESS) {\n\t\tdev->stats.rx_packets++;\n\t\tdev->stats.rx_bytes += data_len;\n\t} else\n\t\tdev->stats.rx_errors++;\n\n\treturn;\n\nerror:\n\tdev->stats.rx_errors++;\n\tkfree_skb(skb);\n}\n\nstatic void l2tp_eth_delete(struct l2tp_session *session)\n{\n\tstruct l2tp_eth_sess *spriv;\n\tstruct net_device *dev;\n\n\tif (session) {\n\t\tspriv = l2tp_session_priv(session);\n\t\tdev = spriv->dev;\n\t\tif (dev) {\n\t\t\tunregister_netdev(dev);\n\t\t\tspriv->dev = NULL;\n\t\t}\n\t}\n}\n\n#if defined(CONFIG_L2TP_DEBUGFS) || defined(CONFIG_L2TP_DEBUGFS_MODULE)\nstatic void l2tp_eth_show(struct seq_file *m, void *arg)\n{\n\tstruct l2tp_session *session = arg;\n\tstruct l2tp_eth_sess *spriv = l2tp_session_priv(session);\n\tstruct net_device *dev = spriv->dev;\n\n\tseq_printf(m, \"   interface %s\\n\", dev->name);\n}\n#endif\n\nstatic int l2tp_eth_create(struct net *net, u32 tunnel_id, u32 session_id, u32 peer_session_id, struct l2tp_session_cfg *cfg)\n{\n\tstruct net_device *dev;\n\tchar name[IFNAMSIZ];\n\tstruct l2tp_tunnel *tunnel;\n\tstruct l2tp_session *session;\n\tstruct l2tp_eth *priv;\n\tstruct l2tp_eth_sess *spriv;\n\tint rc;\n\tstruct l2tp_eth_net *pn;\n\n\ttunnel = l2tp_tunnel_find(net, tunnel_id);\n\tif (!tunnel) {\n\t\trc = -ENODEV;\n\t\tgoto out;\n\t}\n\n\tsession = l2tp_session_find(net, tunnel, session_id);\n\tif (session) {\n\t\trc = -EEXIST;\n\t\tgoto out;\n\t}\n\n\tif (cfg->ifname) {\n\t\tdev = dev_get_by_name(net, cfg->ifname);\n\t\tif (dev) {\n\t\t\tdev_put(dev);\n\t\t\trc = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t\tstrlcpy(name, cfg->ifname, IFNAMSIZ);\n\t} else\n\t\tstrcpy(name, L2TP_ETH_DEV_NAME);\n\n\tsession = l2tp_session_create(sizeof(*spriv), tunnel, session_id,\n\t\t\t\t      peer_session_id, cfg);\n\tif (!session) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tdev = alloc_netdev(sizeof(*priv), name, l2tp_eth_dev_setup);\n\tif (!dev) {\n\t\trc = -ENOMEM;\n\t\tgoto out_del_session;\n\t}\n\n\tdev_net_set(dev, net);\n\tif (session->mtu == 0)\n\t\tsession->mtu = dev->mtu - session->hdr_len;\n\tdev->mtu = session->mtu;\n\tdev->needed_headroom += session->hdr_len;\n\n\tpriv = netdev_priv(dev);\n\tpriv->dev = dev;\n\tpriv->session = session;\n\tINIT_LIST_HEAD(&priv->list);\n\n\tpriv->tunnel_sock = tunnel->sock;\n\tsession->recv_skb = l2tp_eth_dev_recv;\n\tsession->session_close = l2tp_eth_delete;\n#if defined(CONFIG_L2TP_DEBUGFS) || defined(CONFIG_L2TP_DEBUGFS_MODULE)\n\tsession->show = l2tp_eth_show;\n#endif\n\n\tspriv = l2tp_session_priv(session);\n\tspriv->dev = dev;\n\n\trc = register_netdev(dev);\n\tif (rc < 0)\n\t\tgoto out_del_dev;\n\n\t/* Must be done after register_netdev() */\n\tstrlcpy(session->ifname, dev->name, IFNAMSIZ);\n\n\tdev_hold(dev);\n\tpn = l2tp_eth_pernet(dev_net(dev));\n\tspin_lock(&pn->l2tp_eth_lock);\n\tlist_add(&priv->list, &pn->l2tp_eth_dev_list);\n\tspin_unlock(&pn->l2tp_eth_lock);\n\n\treturn 0;\n\nout_del_dev:\n\tfree_netdev(dev);\nout_del_session:\n\tl2tp_session_delete(session);\nout:\n\treturn rc;\n}\n\nstatic __net_init int l2tp_eth_init_net(struct net *net)\n{\n\tstruct l2tp_eth_net *pn = net_generic(net, l2tp_eth_net_id);\n\n\tINIT_LIST_HEAD(&pn->l2tp_eth_dev_list);\n\tspin_lock_init(&pn->l2tp_eth_lock);\n\n\treturn 0;\n}\n\nstatic struct pernet_operations l2tp_eth_net_ops = {\n\t.init = l2tp_eth_init_net,\n\t.id   = &l2tp_eth_net_id,\n\t.size = sizeof(struct l2tp_eth_net),\n};\n\n\nstatic const struct l2tp_nl_cmd_ops l2tp_eth_nl_cmd_ops = {\n\t.session_create\t= l2tp_eth_create,\n\t.session_delete\t= l2tp_session_delete,\n};\n\n\nstatic int __init l2tp_eth_init(void)\n{\n\tint err = 0;\n\n\terr = l2tp_nl_register_ops(L2TP_PWTYPE_ETH, &l2tp_eth_nl_cmd_ops);\n\tif (err)\n\t\tgoto out;\n\n\terr = register_pernet_device(&l2tp_eth_net_ops);\n\tif (err)\n\t\tgoto out_unreg;\n\n\tprintk(KERN_INFO \"L2TP ethernet pseudowire support (L2TPv3)\\n\");\n\n\treturn 0;\n\nout_unreg:\n\tl2tp_nl_unregister_ops(L2TP_PWTYPE_ETH);\nout:\n\treturn err;\n}\n\nstatic void __exit l2tp_eth_exit(void)\n{\n\tunregister_pernet_device(&l2tp_eth_net_ops);\n\tl2tp_nl_unregister_ops(L2TP_PWTYPE_ETH);\n}\n\nmodule_init(l2tp_eth_init);\nmodule_exit(l2tp_eth_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"James Chapman <jchapman@katalix.com>\");\nMODULE_DESCRIPTION(\"L2TP ethernet pseudowire driver\");\nMODULE_VERSION(\"1.0\");\n", "/*\n * Interface handling (except master interface)\n *\n * Copyright 2002-2005, Instant802 Networks, Inc.\n * Copyright 2005-2006, Devicescape Software, Inc.\n * Copyright (c) 2006 Jiri Benc <jbenc@suse.cz>\n * Copyright 2008, Johannes Berg <johannes@sipsolutions.net>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n */\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/if_arp.h>\n#include <linux/netdevice.h>\n#include <linux/rtnetlink.h>\n#include <net/mac80211.h>\n#include <net/ieee80211_radiotap.h>\n#include \"ieee80211_i.h\"\n#include \"sta_info.h\"\n#include \"debugfs_netdev.h\"\n#include \"mesh.h\"\n#include \"led.h\"\n#include \"driver-ops.h\"\n#include \"wme.h\"\n#include \"rate.h\"\n\n/**\n * DOC: Interface list locking\n *\n * The interface list in each struct ieee80211_local is protected\n * three-fold:\n *\n * (1) modifications may only be done under the RTNL\n * (2) modifications and readers are protected against each other by\n *     the iflist_mtx.\n * (3) modifications are done in an RCU manner so atomic readers\n *     can traverse the list in RCU-safe blocks.\n *\n * As a consequence, reads (traversals) of the list can be protected\n * by either the RTNL, the iflist_mtx or RCU.\n */\n\n\nstatic int ieee80211_change_mtu(struct net_device *dev, int new_mtu)\n{\n\tint meshhdrlen;\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\tmeshhdrlen = (sdata->vif.type == NL80211_IFTYPE_MESH_POINT) ? 5 : 0;\n\n\t/* FIX: what would be proper limits for MTU?\n\t * This interface uses 802.3 frames. */\n\tif (new_mtu < 256 ||\n\t    new_mtu > IEEE80211_MAX_DATA_LEN - 24 - 6 - meshhdrlen) {\n\t\treturn -EINVAL;\n\t}\n\n#ifdef CONFIG_MAC80211_VERBOSE_DEBUG\n\tprintk(KERN_DEBUG \"%s: setting MTU %d\\n\", dev->name, new_mtu);\n#endif /* CONFIG_MAC80211_VERBOSE_DEBUG */\n\tdev->mtu = new_mtu;\n\treturn 0;\n}\n\nstatic int ieee80211_change_mac(struct net_device *dev, void *addr)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct sockaddr *sa = addr;\n\tint ret;\n\n\tif (ieee80211_sdata_running(sdata))\n\t\treturn -EBUSY;\n\n\tret = eth_mac_addr(dev, sa);\n\n\tif (ret == 0)\n\t\tmemcpy(sdata->vif.addr, sa->sa_data, ETH_ALEN);\n\n\treturn ret;\n}\n\nstatic inline int identical_mac_addr_allowed(int type1, int type2)\n{\n\treturn type1 == NL80211_IFTYPE_MONITOR ||\n\t\ttype2 == NL80211_IFTYPE_MONITOR ||\n\t\t(type1 == NL80211_IFTYPE_AP && type2 == NL80211_IFTYPE_WDS) ||\n\t\t(type1 == NL80211_IFTYPE_WDS &&\n\t\t\t(type2 == NL80211_IFTYPE_WDS ||\n\t\t\t type2 == NL80211_IFTYPE_AP)) ||\n\t\t(type1 == NL80211_IFTYPE_AP && type2 == NL80211_IFTYPE_AP_VLAN) ||\n\t\t(type1 == NL80211_IFTYPE_AP_VLAN &&\n\t\t\t(type2 == NL80211_IFTYPE_AP ||\n\t\t\t type2 == NL80211_IFTYPE_AP_VLAN));\n}\n\nstatic int ieee80211_check_concurrent_iface(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t    enum nl80211_iftype iftype)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_sub_if_data *nsdata;\n\tstruct net_device *dev = sdata->dev;\n\n\tASSERT_RTNL();\n\n\t/* we hold the RTNL here so can safely walk the list */\n\tlist_for_each_entry(nsdata, &local->interfaces, list) {\n\t\tstruct net_device *ndev = nsdata->dev;\n\n\t\tif (ndev != dev && ieee80211_sdata_running(nsdata)) {\n\t\t\t/*\n\t\t\t * Allow only a single IBSS interface to be up at any\n\t\t\t * time. This is restricted because beacon distribution\n\t\t\t * cannot work properly if both are in the same IBSS.\n\t\t\t *\n\t\t\t * To remove this restriction we'd have to disallow them\n\t\t\t * from setting the same SSID on different IBSS interfaces\n\t\t\t * belonging to the same hardware. Then, however, we're\n\t\t\t * faced with having to adopt two different TSF timers...\n\t\t\t */\n\t\t\tif (iftype == NL80211_IFTYPE_ADHOC &&\n\t\t\t    nsdata->vif.type == NL80211_IFTYPE_ADHOC)\n\t\t\t\treturn -EBUSY;\n\n\t\t\t/*\n\t\t\t * The remaining checks are only performed for interfaces\n\t\t\t * with the same MAC address.\n\t\t\t */\n\t\t\tif (compare_ether_addr(dev->dev_addr, ndev->dev_addr))\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * check whether it may have the same address\n\t\t\t */\n\t\t\tif (!identical_mac_addr_allowed(iftype,\n\t\t\t\t\t\t\tnsdata->vif.type))\n\t\t\t\treturn -ENOTUNIQ;\n\n\t\t\t/*\n\t\t\t * can only add VLANs to enabled APs\n\t\t\t */\n\t\t\tif (iftype == NL80211_IFTYPE_AP_VLAN &&\n\t\t\t    nsdata->vif.type == NL80211_IFTYPE_AP)\n\t\t\t\tsdata->bss = &nsdata->u.ap;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nvoid ieee80211_adjust_monitor_flags(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t    const int offset)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tu32 flags = sdata->u.mntr_flags;\n\n#define ADJUST(_f, _s)\tdo {\t\t\t\t\t\\\n\tif (flags & MONITOR_FLAG_##_f)\t\t\t\t\\\n\t\tlocal->fif_##_s += offset;\t\t\t\\\n\t} while (0)\n\n\tADJUST(FCSFAIL, fcsfail);\n\tADJUST(PLCPFAIL, plcpfail);\n\tADJUST(CONTROL, control);\n\tADJUST(CONTROL, pspoll);\n\tADJUST(OTHER_BSS, other_bss);\n\n#undef ADJUST\n}\n\n/*\n * NOTE: Be very careful when changing this function, it must NOT return\n * an error on interface type changes that have been pre-checked, so most\n * checks should be in ieee80211_check_concurrent_iface.\n */\nstatic int ieee80211_do_open(struct net_device *dev, bool coming_up)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sta_info *sta;\n\tu32 changed = 0;\n\tint res;\n\tu32 hw_reconf_flags = 0;\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_WDS:\n\t\tif (!is_valid_ether_addr(sdata->u.wds.remote_addr))\n\t\t\treturn -ENOLINK;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tif (!sdata->bss)\n\t\t\treturn -ENOLINK;\n\t\tlist_add(&sdata->u.vlan.list, &sdata->bss->vlans);\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\t\tsdata->bss = &sdata->u.ap;\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_MONITOR:\n\tcase NL80211_IFTYPE_ADHOC:\n\t\t/* no special treatment */\n\t\tbreak;\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\tcase NUM_NL80211_IFTYPES:\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\t/* cannot happen */\n\t\tWARN_ON(1);\n\t\tbreak;\n\t}\n\n\tif (local->open_count == 0) {\n\t\tres = drv_start(local);\n\t\tif (res)\n\t\t\tgoto err_del_bss;\n\t\tif (local->ops->napi_poll)\n\t\t\tnapi_enable(&local->napi);\n\t\t/* we're brought up, everything changes */\n\t\thw_reconf_flags = ~0;\n\t\tieee80211_led_radio(local, true);\n\t\tieee80211_mod_tpt_led_trig(local,\n\t\t\t\t\t   IEEE80211_TPT_LEDTRIG_FL_RADIO, 0);\n\t}\n\n\t/*\n\t * Copy the hopefully now-present MAC address to\n\t * this interface, if it has the special null one.\n\t */\n\tif (is_zero_ether_addr(dev->dev_addr)) {\n\t\tmemcpy(dev->dev_addr,\n\t\t       local->hw.wiphy->perm_addr,\n\t\t       ETH_ALEN);\n\t\tmemcpy(dev->perm_addr, dev->dev_addr, ETH_ALEN);\n\n\t\tif (!is_valid_ether_addr(dev->dev_addr)) {\n\t\t\tif (!local->open_count)\n\t\t\t\tdrv_stop(local);\n\t\t\treturn -EADDRNOTAVAIL;\n\t\t}\n\t}\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\t/* no need to tell driver */\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tif (sdata->u.mntr_flags & MONITOR_FLAG_COOK_FRAMES) {\n\t\t\tlocal->cooked_mntrs++;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* must be before the call to ieee80211_configure_filter */\n\t\tlocal->monitors++;\n\t\tif (local->monitors == 1) {\n\t\t\tlocal->hw.conf.flags |= IEEE80211_CONF_MONITOR;\n\t\t\thw_reconf_flags |= IEEE80211_CONF_CHANGE_MONITOR;\n\t\t}\n\n\t\tieee80211_adjust_monitor_flags(sdata, 1);\n\t\tieee80211_configure_filter(local);\n\n\t\tnetif_carrier_on(dev);\n\t\tbreak;\n\tdefault:\n\t\tif (coming_up) {\n\t\t\tres = drv_add_interface(local, &sdata->vif);\n\t\t\tif (res)\n\t\t\t\tgoto err_stop;\n\t\t}\n\n\t\tif (sdata->vif.type == NL80211_IFTYPE_AP) {\n\t\t\tlocal->fif_pspoll++;\n\t\t\tlocal->fif_probe_req++;\n\n\t\t\tieee80211_configure_filter(local);\n\t\t} else if (sdata->vif.type == NL80211_IFTYPE_ADHOC) {\n\t\t\tlocal->fif_probe_req++;\n\t\t}\n\n\t\tchanged |= ieee80211_reset_erp_info(sdata);\n\t\tieee80211_bss_info_change_notify(sdata, changed);\n\n\t\tif (sdata->vif.type == NL80211_IFTYPE_STATION)\n\t\t\tnetif_carrier_off(dev);\n\t\telse\n\t\t\tnetif_carrier_on(dev);\n\t}\n\n\tset_bit(SDATA_STATE_RUNNING, &sdata->state);\n\n\tif (sdata->vif.type == NL80211_IFTYPE_WDS) {\n\t\t/* Create STA entry for the WDS peer */\n\t\tsta = sta_info_alloc(sdata, sdata->u.wds.remote_addr,\n\t\t\t\t     GFP_KERNEL);\n\t\tif (!sta) {\n\t\t\tres = -ENOMEM;\n\t\t\tgoto err_del_interface;\n\t\t}\n\n\t\t/* no locking required since STA is not live yet */\n\t\tsta->flags |= WLAN_STA_AUTHORIZED;\n\n\t\tres = sta_info_insert(sta);\n\t\tif (res) {\n\t\t\t/* STA has been freed */\n\t\t\tgoto err_del_interface;\n\t\t}\n\n\t\trate_control_rate_init(sta);\n\t}\n\n\t/*\n\t * set_multicast_list will be invoked by the networking core\n\t * which will check whether any increments here were done in\n\t * error and sync them down to the hardware as filter flags.\n\t */\n\tif (sdata->flags & IEEE80211_SDATA_ALLMULTI)\n\t\tatomic_inc(&local->iff_allmultis);\n\n\tif (sdata->flags & IEEE80211_SDATA_PROMISC)\n\t\tatomic_inc(&local->iff_promiscs);\n\n\tmutex_lock(&local->mtx);\n\thw_reconf_flags |= __ieee80211_recalc_idle(local);\n\tmutex_unlock(&local->mtx);\n\n\tif (coming_up)\n\t\tlocal->open_count++;\n\n\tif (hw_reconf_flags) {\n\t\tieee80211_hw_config(local, hw_reconf_flags);\n\t\t/*\n\t\t * set default queue parameters so drivers don't\n\t\t * need to initialise the hardware if the hardware\n\t\t * doesn't start up with sane defaults\n\t\t */\n\t\tieee80211_set_wmm_default(sdata);\n\t}\n\n\tieee80211_recalc_ps(local, -1);\n\n\tnetif_tx_start_all_queues(dev);\n\n\treturn 0;\n err_del_interface:\n\tdrv_remove_interface(local, &sdata->vif);\n err_stop:\n\tif (!local->open_count)\n\t\tdrv_stop(local);\n err_del_bss:\n\tsdata->bss = NULL;\n\tif (sdata->vif.type == NL80211_IFTYPE_AP_VLAN)\n\t\tlist_del(&sdata->u.vlan.list);\n\tclear_bit(SDATA_STATE_RUNNING, &sdata->state);\n\treturn res;\n}\n\nstatic int ieee80211_open(struct net_device *dev)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tint err;\n\n\t/* fail early if user set an invalid address */\n\tif (!is_valid_ether_addr(dev->dev_addr))\n\t\treturn -EADDRNOTAVAIL;\n\n\terr = ieee80211_check_concurrent_iface(sdata, sdata->vif.type);\n\tif (err)\n\t\treturn err;\n\n\treturn ieee80211_do_open(dev, true);\n}\n\nstatic void ieee80211_do_stop(struct ieee80211_sub_if_data *sdata,\n\t\t\t      bool going_down)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tunsigned long flags;\n\tstruct sk_buff *skb, *tmp;\n\tu32 hw_reconf_flags = 0;\n\tint i;\n\tenum nl80211_channel_type orig_ct;\n\n\tclear_bit(SDATA_STATE_RUNNING, &sdata->state);\n\n\tif (local->scan_sdata == sdata)\n\t\tieee80211_scan_cancel(local);\n\n\t/*\n\t * Stop TX on this interface first.\n\t */\n\tnetif_tx_stop_all_queues(sdata->dev);\n\n\t/*\n\t * Purge work for this interface.\n\t */\n\tieee80211_work_purge(sdata);\n\n\t/*\n\t * Remove all stations associated with this interface.\n\t *\n\t * This must be done before calling ops->remove_interface()\n\t * because otherwise we can later invoke ops->sta_notify()\n\t * whenever the STAs are removed, and that invalidates driver\n\t * assumptions about always getting a vif pointer that is valid\n\t * (because if we remove a STA after ops->remove_interface()\n\t * the driver will have removed the vif info already!)\n\t *\n\t * This is relevant only in AP, WDS and mesh modes, since in\n\t * all other modes we've already removed all stations when\n\t * disconnecting etc.\n\t */\n\tsta_info_flush(local, sdata);\n\n\t/*\n\t * Don't count this interface for promisc/allmulti while it\n\t * is down. dev_mc_unsync() will invoke set_multicast_list\n\t * on the master interface which will sync these down to the\n\t * hardware as filter flags.\n\t */\n\tif (sdata->flags & IEEE80211_SDATA_ALLMULTI)\n\t\tatomic_dec(&local->iff_allmultis);\n\n\tif (sdata->flags & IEEE80211_SDATA_PROMISC)\n\t\tatomic_dec(&local->iff_promiscs);\n\n\tif (sdata->vif.type == NL80211_IFTYPE_AP) {\n\t\tlocal->fif_pspoll--;\n\t\tlocal->fif_probe_req--;\n\t} else if (sdata->vif.type == NL80211_IFTYPE_ADHOC) {\n\t\tlocal->fif_probe_req--;\n\t}\n\n\tnetif_addr_lock_bh(sdata->dev);\n\tspin_lock_bh(&local->filter_lock);\n\t__hw_addr_unsync(&local->mc_list, &sdata->dev->mc,\n\t\t\t sdata->dev->addr_len);\n\tspin_unlock_bh(&local->filter_lock);\n\tnetif_addr_unlock_bh(sdata->dev);\n\n\tieee80211_configure_filter(local);\n\n\tdel_timer_sync(&local->dynamic_ps_timer);\n\tcancel_work_sync(&local->dynamic_ps_enable_work);\n\n\t/* APs need special treatment */\n\tif (sdata->vif.type == NL80211_IFTYPE_AP) {\n\t\tstruct ieee80211_sub_if_data *vlan, *tmpsdata;\n\t\tstruct beacon_data *old_beacon =\n\t\t\trtnl_dereference(sdata->u.ap.beacon);\n\n\t\t/* sdata_running will return false, so this will disable */\n\t\tieee80211_bss_info_change_notify(sdata,\n\t\t\t\t\t\t BSS_CHANGED_BEACON_ENABLED);\n\n\t\t/* remove beacon */\n\t\trcu_assign_pointer(sdata->u.ap.beacon, NULL);\n\t\tsynchronize_rcu();\n\t\tkfree(old_beacon);\n\n\t\t/* free all potentially still buffered bcast frames */\n\t\twhile ((skb = skb_dequeue(&sdata->u.ap.ps_bc_buf))) {\n\t\t\tlocal->total_ps_buffered--;\n\t\t\tdev_kfree_skb(skb);\n\t\t}\n\n\t\t/* down all dependent devices, that is VLANs */\n\t\tlist_for_each_entry_safe(vlan, tmpsdata, &sdata->u.ap.vlans,\n\t\t\t\t\t u.vlan.list)\n\t\t\tdev_close(vlan->dev);\n\t\tWARN_ON(!list_empty(&sdata->u.ap.vlans));\n\t}\n\n\tif (going_down)\n\t\tlocal->open_count--;\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tlist_del(&sdata->u.vlan.list);\n\t\t/* no need to tell driver */\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tif (sdata->u.mntr_flags & MONITOR_FLAG_COOK_FRAMES) {\n\t\t\tlocal->cooked_mntrs--;\n\t\t\tbreak;\n\t\t}\n\n\t\tlocal->monitors--;\n\t\tif (local->monitors == 0) {\n\t\t\tlocal->hw.conf.flags &= ~IEEE80211_CONF_MONITOR;\n\t\t\thw_reconf_flags |= IEEE80211_CONF_CHANGE_MONITOR;\n\t\t}\n\n\t\tieee80211_adjust_monitor_flags(sdata, -1);\n\t\tieee80211_configure_filter(local);\n\t\tbreak;\n\tdefault:\n\t\tflush_work(&sdata->work);\n\t\t/*\n\t\t * When we get here, the interface is marked down.\n\t\t * Call synchronize_rcu() to wait for the RX path\n\t\t * should it be using the interface and enqueuing\n\t\t * frames at this very time on another CPU.\n\t\t */\n\t\tsynchronize_rcu();\n\t\tskb_queue_purge(&sdata->skb_queue);\n\n\t\t/*\n\t\t * Disable beaconing here for mesh only, AP and IBSS\n\t\t * are already taken care of.\n\t\t */\n\t\tif (sdata->vif.type == NL80211_IFTYPE_MESH_POINT)\n\t\t\tieee80211_bss_info_change_notify(sdata,\n\t\t\t\tBSS_CHANGED_BEACON_ENABLED);\n\n\t\t/*\n\t\t * Free all remaining keys, there shouldn't be any,\n\t\t * except maybe group keys in AP more or WDS?\n\t\t */\n\t\tieee80211_free_keys(sdata);\n\n\t\tif (going_down)\n\t\t\tdrv_remove_interface(local, &sdata->vif);\n\t}\n\n\tsdata->bss = NULL;\n\n\tmutex_lock(&local->mtx);\n\thw_reconf_flags |= __ieee80211_recalc_idle(local);\n\tmutex_unlock(&local->mtx);\n\n\tieee80211_recalc_ps(local, -1);\n\n\tif (local->open_count == 0) {\n\t\tif (local->ops->napi_poll)\n\t\t\tnapi_disable(&local->napi);\n\t\tieee80211_clear_tx_pending(local);\n\t\tieee80211_stop_device(local);\n\n\t\t/* no reconfiguring after stop! */\n\t\thw_reconf_flags = 0;\n\t}\n\n\t/* Re-calculate channel-type, in case there are multiple vifs\n\t * on different channel types.\n\t */\n\torig_ct = local->_oper_channel_type;\n\tieee80211_set_channel_type(local, NULL, NL80211_CHAN_NO_HT);\n\n\t/* do after stop to avoid reconfiguring when we stop anyway */\n\tif (hw_reconf_flags || (orig_ct != local->_oper_channel_type))\n\t\tieee80211_hw_config(local, hw_reconf_flags);\n\n\tspin_lock_irqsave(&local->queue_stop_reason_lock, flags);\n\tfor (i = 0; i < IEEE80211_MAX_QUEUES; i++) {\n\t\tskb_queue_walk_safe(&local->pending[i], skb, tmp) {\n\t\t\tstruct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);\n\t\t\tif (info->control.vif == &sdata->vif) {\n\t\t\t\t__skb_unlink(skb, &local->pending[i]);\n\t\t\t\tdev_kfree_skb_irq(skb);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);\n}\n\nstatic int ieee80211_stop(struct net_device *dev)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\tieee80211_do_stop(sdata, true);\n\n\treturn 0;\n}\n\nstatic void ieee80211_set_multicast_list(struct net_device *dev)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tint allmulti, promisc, sdata_allmulti, sdata_promisc;\n\n\tallmulti = !!(dev->flags & IFF_ALLMULTI);\n\tpromisc = !!(dev->flags & IFF_PROMISC);\n\tsdata_allmulti = !!(sdata->flags & IEEE80211_SDATA_ALLMULTI);\n\tsdata_promisc = !!(sdata->flags & IEEE80211_SDATA_PROMISC);\n\n\tif (allmulti != sdata_allmulti) {\n\t\tif (dev->flags & IFF_ALLMULTI)\n\t\t\tatomic_inc(&local->iff_allmultis);\n\t\telse\n\t\t\tatomic_dec(&local->iff_allmultis);\n\t\tsdata->flags ^= IEEE80211_SDATA_ALLMULTI;\n\t}\n\n\tif (promisc != sdata_promisc) {\n\t\tif (dev->flags & IFF_PROMISC)\n\t\t\tatomic_inc(&local->iff_promiscs);\n\t\telse\n\t\t\tatomic_dec(&local->iff_promiscs);\n\t\tsdata->flags ^= IEEE80211_SDATA_PROMISC;\n\t}\n\tspin_lock_bh(&local->filter_lock);\n\t__hw_addr_sync(&local->mc_list, &dev->mc, dev->addr_len);\n\tspin_unlock_bh(&local->filter_lock);\n\tieee80211_queue_work(&local->hw, &local->reconfig_filter);\n}\n\n/*\n * Called when the netdev is removed or, by the code below, before\n * the interface type changes.\n */\nstatic void ieee80211_teardown_sdata(struct net_device *dev)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tint flushed;\n\tint i;\n\n\t/* free extra data */\n\tieee80211_free_keys(sdata);\n\n\tieee80211_debugfs_remove_netdev(sdata);\n\n\tfor (i = 0; i < IEEE80211_FRAGMENT_MAX; i++)\n\t\t__skb_queue_purge(&sdata->fragments[i].skb_list);\n\tsdata->fragment_next = 0;\n\n\tif (ieee80211_vif_is_mesh(&sdata->vif))\n\t\tmesh_rmc_free(sdata);\n\n\tflushed = sta_info_flush(local, sdata);\n\tWARN_ON(flushed);\n}\n\nstatic u16 ieee80211_netdev_select_queue(struct net_device *dev,\n\t\t\t\t\t struct sk_buff *skb)\n{\n\treturn ieee80211_select_queue(IEEE80211_DEV_TO_SUB_IF(dev), skb);\n}\n\nstatic const struct net_device_ops ieee80211_dataif_ops = {\n\t.ndo_open\t\t= ieee80211_open,\n\t.ndo_stop\t\t= ieee80211_stop,\n\t.ndo_uninit\t\t= ieee80211_teardown_sdata,\n\t.ndo_start_xmit\t\t= ieee80211_subif_start_xmit,\n\t.ndo_set_multicast_list = ieee80211_set_multicast_list,\n\t.ndo_change_mtu \t= ieee80211_change_mtu,\n\t.ndo_set_mac_address \t= ieee80211_change_mac,\n\t.ndo_select_queue\t= ieee80211_netdev_select_queue,\n};\n\nstatic u16 ieee80211_monitor_select_queue(struct net_device *dev,\n\t\t\t\t\t  struct sk_buff *skb)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct ieee80211_hdr *hdr;\n\tstruct ieee80211_radiotap_header *rtap = (void *)skb->data;\n\tu8 *p;\n\n\tif (local->hw.queues < 4)\n\t\treturn 0;\n\n\tif (skb->len < 4 ||\n\t    skb->len < le16_to_cpu(rtap->it_len) + 2 /* frame control */)\n\t\treturn 0; /* doesn't matter, frame will be dropped */\n\n\thdr = (void *)((u8 *)skb->data + le16_to_cpu(rtap->it_len));\n\n\tif (!ieee80211_is_data(hdr->frame_control)) {\n\t\tskb->priority = 7;\n\t\treturn ieee802_1d_to_ac[skb->priority];\n\t}\n\tif (!ieee80211_is_data_qos(hdr->frame_control)) {\n\t\tskb->priority = 0;\n\t\treturn ieee802_1d_to_ac[skb->priority];\n\t}\n\n\tp = ieee80211_get_qos_ctl(hdr);\n\tskb->priority = *p & IEEE80211_QOS_CTL_TAG1D_MASK;\n\n\treturn ieee80211_downgrade_queue(local, skb);\n}\n\nstatic const struct net_device_ops ieee80211_monitorif_ops = {\n\t.ndo_open\t\t= ieee80211_open,\n\t.ndo_stop\t\t= ieee80211_stop,\n\t.ndo_uninit\t\t= ieee80211_teardown_sdata,\n\t.ndo_start_xmit\t\t= ieee80211_monitor_start_xmit,\n\t.ndo_set_multicast_list = ieee80211_set_multicast_list,\n\t.ndo_change_mtu \t= ieee80211_change_mtu,\n\t.ndo_set_mac_address \t= eth_mac_addr,\n\t.ndo_select_queue\t= ieee80211_monitor_select_queue,\n};\n\nstatic void ieee80211_if_setup(struct net_device *dev)\n{\n\tether_setup(dev);\n\tdev->priv_flags &= ~IFF_TX_SKB_SHARING;\n\tdev->netdev_ops = &ieee80211_dataif_ops;\n\tdev->destructor = free_netdev;\n}\n\nstatic void ieee80211_iface_work(struct work_struct *work)\n{\n\tstruct ieee80211_sub_if_data *sdata =\n\t\tcontainer_of(work, struct ieee80211_sub_if_data, work);\n\tstruct ieee80211_local *local = sdata->local;\n\tstruct sk_buff *skb;\n\tstruct sta_info *sta;\n\tstruct ieee80211_ra_tid *ra_tid;\n\n\tif (!ieee80211_sdata_running(sdata))\n\t\treturn;\n\n\tif (local->scanning)\n\t\treturn;\n\n\t/*\n\t * ieee80211_queue_work() should have picked up most cases,\n\t * here we'll pick the rest.\n\t */\n\tif (WARN(local->suspended,\n\t\t \"interface work scheduled while going to suspend\\n\"))\n\t\treturn;\n\n\t/* first process frames */\n\twhile ((skb = skb_dequeue(&sdata->skb_queue))) {\n\t\tstruct ieee80211_mgmt *mgmt = (void *)skb->data;\n\n\t\tif (skb->pkt_type == IEEE80211_SDATA_QUEUE_AGG_START) {\n\t\t\tra_tid = (void *)&skb->cb;\n\t\t\tieee80211_start_tx_ba_cb(&sdata->vif, ra_tid->ra,\n\t\t\t\t\t\t ra_tid->tid);\n\t\t} else if (skb->pkt_type == IEEE80211_SDATA_QUEUE_AGG_STOP) {\n\t\t\tra_tid = (void *)&skb->cb;\n\t\t\tieee80211_stop_tx_ba_cb(&sdata->vif, ra_tid->ra,\n\t\t\t\t\t\tra_tid->tid);\n\t\t} else if (ieee80211_is_action(mgmt->frame_control) &&\n\t\t\t   mgmt->u.action.category == WLAN_CATEGORY_BACK) {\n\t\t\tint len = skb->len;\n\n\t\t\tmutex_lock(&local->sta_mtx);\n\t\t\tsta = sta_info_get_bss(sdata, mgmt->sa);\n\t\t\tif (sta) {\n\t\t\t\tswitch (mgmt->u.action.u.addba_req.action_code) {\n\t\t\t\tcase WLAN_ACTION_ADDBA_REQ:\n\t\t\t\t\tieee80211_process_addba_request(\n\t\t\t\t\t\t\tlocal, sta, mgmt, len);\n\t\t\t\t\tbreak;\n\t\t\t\tcase WLAN_ACTION_ADDBA_RESP:\n\t\t\t\t\tieee80211_process_addba_resp(local, sta,\n\t\t\t\t\t\t\t\t     mgmt, len);\n\t\t\t\t\tbreak;\n\t\t\t\tcase WLAN_ACTION_DELBA:\n\t\t\t\t\tieee80211_process_delba(sdata, sta,\n\t\t\t\t\t\t\t\tmgmt, len);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tWARN_ON(1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmutex_unlock(&local->sta_mtx);\n\t\t} else if (ieee80211_is_data_qos(mgmt->frame_control)) {\n\t\t\tstruct ieee80211_hdr *hdr = (void *)mgmt;\n\t\t\t/*\n\t\t\t * So the frame isn't mgmt, but frame_control\n\t\t\t * is at the right place anyway, of course, so\n\t\t\t * the if statement is correct.\n\t\t\t *\n\t\t\t * Warn if we have other data frame types here,\n\t\t\t * they must not get here.\n\t\t\t */\n\t\t\tWARN_ON(hdr->frame_control &\n\t\t\t\t\tcpu_to_le16(IEEE80211_STYPE_NULLFUNC));\n\t\t\tWARN_ON(!(hdr->seq_ctrl &\n\t\t\t\t\tcpu_to_le16(IEEE80211_SCTL_FRAG)));\n\t\t\t/*\n\t\t\t * This was a fragment of a frame, received while\n\t\t\t * a block-ack session was active. That cannot be\n\t\t\t * right, so terminate the session.\n\t\t\t */\n\t\t\tmutex_lock(&local->sta_mtx);\n\t\t\tsta = sta_info_get_bss(sdata, mgmt->sa);\n\t\t\tif (sta) {\n\t\t\t\tu16 tid = *ieee80211_get_qos_ctl(hdr) &\n\t\t\t\t\t\tIEEE80211_QOS_CTL_TID_MASK;\n\n\t\t\t\t__ieee80211_stop_rx_ba_session(\n\t\t\t\t\tsta, tid, WLAN_BACK_RECIPIENT,\n\t\t\t\t\tWLAN_REASON_QSTA_REQUIRE_SETUP,\n\t\t\t\t\ttrue);\n\t\t\t}\n\t\t\tmutex_unlock(&local->sta_mtx);\n\t\t} else switch (sdata->vif.type) {\n\t\tcase NL80211_IFTYPE_STATION:\n\t\t\tieee80211_sta_rx_queued_mgmt(sdata, skb);\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_ADHOC:\n\t\t\tieee80211_ibss_rx_queued_mgmt(sdata, skb);\n\t\t\tbreak;\n\t\tcase NL80211_IFTYPE_MESH_POINT:\n\t\t\tif (!ieee80211_vif_is_mesh(&sdata->vif))\n\t\t\t\tbreak;\n\t\t\tieee80211_mesh_rx_queued_mgmt(sdata, skb);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN(1, \"frame for unexpected interface type\");\n\t\t\tbreak;\n\t\t}\n\n\t\tkfree_skb(skb);\n\t}\n\n\t/* then other type-dependent work */\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_STATION:\n\t\tieee80211_sta_work(sdata);\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tieee80211_ibss_work(sdata);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (!ieee80211_vif_is_mesh(&sdata->vif))\n\t\t\tbreak;\n\t\tieee80211_mesh_work(sdata);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n\n/*\n * Helper function to initialise an interface to a specific type.\n */\nstatic void ieee80211_setup_sdata(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t  enum nl80211_iftype type)\n{\n\t/* clear type-dependent union */\n\tmemset(&sdata->u, 0, sizeof(sdata->u));\n\n\t/* and set some type-dependent values */\n\tsdata->vif.type = type;\n\tsdata->vif.p2p = false;\n\tsdata->dev->netdev_ops = &ieee80211_dataif_ops;\n\tsdata->wdev.iftype = type;\n\n\tsdata->control_port_protocol = cpu_to_be16(ETH_P_PAE);\n\tsdata->control_port_no_encrypt = false;\n\n\t/* only monitor differs */\n\tsdata->dev->type = ARPHRD_ETHER;\n\n\tskb_queue_head_init(&sdata->skb_queue);\n\tINIT_WORK(&sdata->work, ieee80211_iface_work);\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\ttype = NL80211_IFTYPE_AP;\n\t\tsdata->vif.type = type;\n\t\tsdata->vif.p2p = true;\n\t\t/* fall through */\n\tcase NL80211_IFTYPE_AP:\n\t\tskb_queue_head_init(&sdata->u.ap.ps_bc_buf);\n\t\tINIT_LIST_HEAD(&sdata->u.ap.vlans);\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\ttype = NL80211_IFTYPE_STATION;\n\t\tsdata->vif.type = type;\n\t\tsdata->vif.p2p = true;\n\t\t/* fall through */\n\tcase NL80211_IFTYPE_STATION:\n\t\tieee80211_sta_setup_sdata(sdata);\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tieee80211_ibss_setup_sdata(sdata);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (ieee80211_vif_is_mesh(&sdata->vif))\n\t\t\tieee80211_mesh_init_sdata(sdata);\n\t\tbreak;\n\tcase NL80211_IFTYPE_MONITOR:\n\t\tsdata->dev->type = ARPHRD_IEEE80211_RADIOTAP;\n\t\tsdata->dev->netdev_ops = &ieee80211_monitorif_ops;\n\t\tsdata->u.mntr_flags = MONITOR_FLAG_CONTROL |\n\t\t\t\t      MONITOR_FLAG_OTHER_BSS;\n\t\tbreak;\n\tcase NL80211_IFTYPE_WDS:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tbreak;\n\tcase NL80211_IFTYPE_UNSPECIFIED:\n\tcase NUM_NL80211_IFTYPES:\n\t\tBUG();\n\t\tbreak;\n\t}\n\n\tieee80211_debugfs_add_netdev(sdata);\n}\n\nstatic int ieee80211_runtime_change_iftype(struct ieee80211_sub_if_data *sdata,\n\t\t\t\t\t   enum nl80211_iftype type)\n{\n\tstruct ieee80211_local *local = sdata->local;\n\tint ret, err;\n\tenum nl80211_iftype internal_type = type;\n\tbool p2p = false;\n\n\tASSERT_RTNL();\n\n\tif (!local->ops->change_interface)\n\t\treturn -EBUSY;\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\t\t/*\n\t\t * Could maybe also all others here?\n\t\t * Just not sure how that interacts\n\t\t * with the RX/config path e.g. for\n\t\t * mesh.\n\t\t */\n\t\tbreak;\n\tdefault:\n\t\treturn -EBUSY;\n\t}\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_STATION:\n\tcase NL80211_IFTYPE_ADHOC:\n\t\t/*\n\t\t * Could probably support everything\n\t\t * but WDS here (WDS do_open can fail\n\t\t * under memory pressure, which this\n\t\t * code isn't prepared to handle).\n\t\t */\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_CLIENT:\n\t\tp2p = true;\n\t\tinternal_type = NL80211_IFTYPE_STATION;\n\t\tbreak;\n\tcase NL80211_IFTYPE_P2P_GO:\n\t\tp2p = true;\n\t\tinternal_type = NL80211_IFTYPE_AP;\n\t\tbreak;\n\tdefault:\n\t\treturn -EBUSY;\n\t}\n\n\tret = ieee80211_check_concurrent_iface(sdata, internal_type);\n\tif (ret)\n\t\treturn ret;\n\n\tieee80211_do_stop(sdata, false);\n\n\tieee80211_teardown_sdata(sdata->dev);\n\n\tret = drv_change_interface(local, sdata, internal_type, p2p);\n\tif (ret)\n\t\ttype = sdata->vif.type;\n\n\tieee80211_setup_sdata(sdata, type);\n\n\terr = ieee80211_do_open(sdata->dev, false);\n\tWARN(err, \"type change: do_open returned %d\", err);\n\n\treturn ret;\n}\n\nint ieee80211_if_change_type(struct ieee80211_sub_if_data *sdata,\n\t\t\t     enum nl80211_iftype type)\n{\n\tint ret;\n\n\tASSERT_RTNL();\n\n\tif (type == ieee80211_vif_type_p2p(&sdata->vif))\n\t\treturn 0;\n\n\t/* Setting ad-hoc mode on non-IBSS channel is not supported. */\n\tif (sdata->local->oper_channel->flags & IEEE80211_CHAN_NO_IBSS &&\n\t    type == NL80211_IFTYPE_ADHOC)\n\t\treturn -EOPNOTSUPP;\n\n\tif (ieee80211_sdata_running(sdata)) {\n\t\tret = ieee80211_runtime_change_iftype(sdata, type);\n\t\tif (ret)\n\t\t\treturn ret;\n\t} else {\n\t\t/* Purge and reset type-dependent state. */\n\t\tieee80211_teardown_sdata(sdata->dev);\n\t\tieee80211_setup_sdata(sdata, type);\n\t}\n\n\t/* reset some values that shouldn't be kept across type changes */\n\tsdata->vif.bss_conf.basic_rates =\n\t\tieee80211_mandatory_rates(sdata->local,\n\t\t\tsdata->local->hw.conf.channel->band);\n\tsdata->drop_unencrypted = 0;\n\tif (type == NL80211_IFTYPE_STATION)\n\t\tsdata->u.mgd.use_4addr = false;\n\n\treturn 0;\n}\n\nstatic void ieee80211_assign_perm_addr(struct ieee80211_local *local,\n\t\t\t\t       struct net_device *dev,\n\t\t\t\t       enum nl80211_iftype type)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tu64 mask, start, addr, val, inc;\n\tu8 *m;\n\tu8 tmp_addr[ETH_ALEN];\n\tint i;\n\n\t/* default ... something at least */\n\tmemcpy(dev->perm_addr, local->hw.wiphy->perm_addr, ETH_ALEN);\n\n\tif (is_zero_ether_addr(local->hw.wiphy->addr_mask) &&\n\t    local->hw.wiphy->n_addresses <= 1)\n\t\treturn;\n\n\n\tmutex_lock(&local->iflist_mtx);\n\n\tswitch (type) {\n\tcase NL80211_IFTYPE_MONITOR:\n\t\t/* doesn't matter */\n\t\tbreak;\n\tcase NL80211_IFTYPE_WDS:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\t/* match up with an AP interface */\n\t\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\t\tif (sdata->vif.type != NL80211_IFTYPE_AP)\n\t\t\t\tcontinue;\n\t\t\tmemcpy(dev->perm_addr, sdata->vif.addr, ETH_ALEN);\n\t\t\tbreak;\n\t\t}\n\t\t/* keep default if no AP interface present */\n\t\tbreak;\n\tdefault:\n\t\t/* assign a new address if possible -- try n_addresses first */\n\t\tfor (i = 0; i < local->hw.wiphy->n_addresses; i++) {\n\t\t\tbool used = false;\n\n\t\t\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\t\t\tif (memcmp(local->hw.wiphy->addresses[i].addr,\n\t\t\t\t\t   sdata->vif.addr, ETH_ALEN) == 0) {\n\t\t\t\t\tused = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!used) {\n\t\t\t\tmemcpy(dev->perm_addr,\n\t\t\t\t       local->hw.wiphy->addresses[i].addr,\n\t\t\t\t       ETH_ALEN);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* try mask if available */\n\t\tif (is_zero_ether_addr(local->hw.wiphy->addr_mask))\n\t\t\tbreak;\n\n\t\tm = local->hw.wiphy->addr_mask;\n\t\tmask =\t((u64)m[0] << 5*8) | ((u64)m[1] << 4*8) |\n\t\t\t((u64)m[2] << 3*8) | ((u64)m[3] << 2*8) |\n\t\t\t((u64)m[4] << 1*8) | ((u64)m[5] << 0*8);\n\n\t\tif (__ffs64(mask) + hweight64(mask) != fls64(mask)) {\n\t\t\t/* not a contiguous mask ... not handled now! */\n\t\t\tprintk(KERN_DEBUG \"not contiguous\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t\tm = local->hw.wiphy->perm_addr;\n\t\tstart = ((u64)m[0] << 5*8) | ((u64)m[1] << 4*8) |\n\t\t\t((u64)m[2] << 3*8) | ((u64)m[3] << 2*8) |\n\t\t\t((u64)m[4] << 1*8) | ((u64)m[5] << 0*8);\n\n\t\tinc = 1ULL<<__ffs64(mask);\n\t\tval = (start & mask);\n\t\taddr = (start & ~mask) | (val & mask);\n\t\tdo {\n\t\t\tbool used = false;\n\n\t\t\ttmp_addr[5] = addr >> 0*8;\n\t\t\ttmp_addr[4] = addr >> 1*8;\n\t\t\ttmp_addr[3] = addr >> 2*8;\n\t\t\ttmp_addr[2] = addr >> 3*8;\n\t\t\ttmp_addr[1] = addr >> 4*8;\n\t\t\ttmp_addr[0] = addr >> 5*8;\n\n\t\t\tval += inc;\n\n\t\t\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\t\t\tif (memcmp(tmp_addr, sdata->vif.addr,\n\t\t\t\t\t\t\tETH_ALEN) == 0) {\n\t\t\t\t\tused = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!used) {\n\t\t\t\tmemcpy(dev->perm_addr, tmp_addr, ETH_ALEN);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\taddr = (start & ~mask) | (val & mask);\n\t\t} while (addr != start);\n\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&local->iflist_mtx);\n}\n\nint ieee80211_if_add(struct ieee80211_local *local, const char *name,\n\t\t     struct net_device **new_dev, enum nl80211_iftype type,\n\t\t     struct vif_params *params)\n{\n\tstruct net_device *ndev;\n\tstruct ieee80211_sub_if_data *sdata = NULL;\n\tint ret, i;\n\n\tASSERT_RTNL();\n\n\tndev = alloc_netdev_mqs(sizeof(*sdata) + local->hw.vif_data_size,\n\t\t\t\tname, ieee80211_if_setup, local->hw.queues, 1);\n\tif (!ndev)\n\t\treturn -ENOMEM;\n\tdev_net_set(ndev, wiphy_net(local->hw.wiphy));\n\n\tndev->needed_headroom = local->tx_headroom +\n\t\t\t\t4*6 /* four MAC addresses */\n\t\t\t\t+ 2 + 2 + 2 + 2 /* ctl, dur, seq, qos */\n\t\t\t\t+ 6 /* mesh */\n\t\t\t\t+ 8 /* rfc1042/bridge tunnel */\n\t\t\t\t- ETH_HLEN /* ethernet hard_header_len */\n\t\t\t\t+ IEEE80211_ENCRYPT_HEADROOM;\n\tndev->needed_tailroom = IEEE80211_ENCRYPT_TAILROOM;\n\n\tret = dev_alloc_name(ndev, ndev->name);\n\tif (ret < 0)\n\t\tgoto fail;\n\n\tieee80211_assign_perm_addr(local, ndev, type);\n\tmemcpy(ndev->dev_addr, ndev->perm_addr, ETH_ALEN);\n\tSET_NETDEV_DEV(ndev, wiphy_dev(local->hw.wiphy));\n\n\t/* don't use IEEE80211_DEV_TO_SUB_IF because it checks too much */\n\tsdata = netdev_priv(ndev);\n\tndev->ieee80211_ptr = &sdata->wdev;\n\tmemcpy(sdata->vif.addr, ndev->dev_addr, ETH_ALEN);\n\tmemcpy(sdata->name, ndev->name, IFNAMSIZ);\n\n\t/* initialise type-independent data */\n\tsdata->wdev.wiphy = local->hw.wiphy;\n\tsdata->local = local;\n\tsdata->dev = ndev;\n#ifdef CONFIG_INET\n\tsdata->arp_filter_state = true;\n#endif\n\n\tfor (i = 0; i < IEEE80211_FRAGMENT_MAX; i++)\n\t\tskb_queue_head_init(&sdata->fragments[i].skb_list);\n\n\tINIT_LIST_HEAD(&sdata->key_list);\n\n\tfor (i = 0; i < IEEE80211_NUM_BANDS; i++) {\n\t\tstruct ieee80211_supported_band *sband;\n\t\tsband = local->hw.wiphy->bands[i];\n\t\tsdata->rc_rateidx_mask[i] =\n\t\t\tsband ? (1 << sband->n_bitrates) - 1 : 0;\n\t}\n\n\t/* setup type-dependent data */\n\tieee80211_setup_sdata(sdata, type);\n\n\tif (params) {\n\t\tndev->ieee80211_ptr->use_4addr = params->use_4addr;\n\t\tif (type == NL80211_IFTYPE_STATION)\n\t\t\tsdata->u.mgd.use_4addr = params->use_4addr;\n\t}\n\n\tret = register_netdevice(ndev);\n\tif (ret)\n\t\tgoto fail;\n\n\tmutex_lock(&local->iflist_mtx);\n\tlist_add_tail_rcu(&sdata->list, &local->interfaces);\n\tmutex_unlock(&local->iflist_mtx);\n\n\tif (new_dev)\n\t\t*new_dev = ndev;\n\n\treturn 0;\n\n fail:\n\tfree_netdev(ndev);\n\treturn ret;\n}\n\nvoid ieee80211_if_remove(struct ieee80211_sub_if_data *sdata)\n{\n\tASSERT_RTNL();\n\n\tmutex_lock(&sdata->local->iflist_mtx);\n\tlist_del_rcu(&sdata->list);\n\tmutex_unlock(&sdata->local->iflist_mtx);\n\n\tsynchronize_rcu();\n\tunregister_netdevice(sdata->dev);\n}\n\n/*\n * Remove all interfaces, may only be called at hardware unregistration\n * time because it doesn't do RCU-safe list removals.\n */\nvoid ieee80211_remove_interfaces(struct ieee80211_local *local)\n{\n\tstruct ieee80211_sub_if_data *sdata, *tmp;\n\tLIST_HEAD(unreg_list);\n\n\tASSERT_RTNL();\n\n\tmutex_lock(&local->iflist_mtx);\n\tlist_for_each_entry_safe(sdata, tmp, &local->interfaces, list) {\n\t\tlist_del(&sdata->list);\n\n\t\tunregister_netdevice_queue(sdata->dev, &unreg_list);\n\t}\n\tmutex_unlock(&local->iflist_mtx);\n\tunregister_netdevice_many(&unreg_list);\n\tlist_del(&unreg_list);\n}\n\nstatic u32 ieee80211_idle_off(struct ieee80211_local *local,\n\t\t\t      const char *reason)\n{\n\tif (!(local->hw.conf.flags & IEEE80211_CONF_IDLE))\n\t\treturn 0;\n\n#ifdef CONFIG_MAC80211_VERBOSE_DEBUG\n\twiphy_debug(local->hw.wiphy, \"device no longer idle - %s\\n\", reason);\n#endif\n\n\tlocal->hw.conf.flags &= ~IEEE80211_CONF_IDLE;\n\treturn IEEE80211_CONF_CHANGE_IDLE;\n}\n\nstatic u32 ieee80211_idle_on(struct ieee80211_local *local)\n{\n\tif (local->hw.conf.flags & IEEE80211_CONF_IDLE)\n\t\treturn 0;\n\n#ifdef CONFIG_MAC80211_VERBOSE_DEBUG\n\twiphy_debug(local->hw.wiphy, \"device now idle\\n\");\n#endif\n\n\tdrv_flush(local, false);\n\n\tlocal->hw.conf.flags |= IEEE80211_CONF_IDLE;\n\treturn IEEE80211_CONF_CHANGE_IDLE;\n}\n\nu32 __ieee80211_recalc_idle(struct ieee80211_local *local)\n{\n\tstruct ieee80211_sub_if_data *sdata;\n\tint count = 0;\n\tbool working = false, scanning = false, hw_roc = false;\n\tstruct ieee80211_work *wk;\n\tunsigned int led_trig_start = 0, led_trig_stop = 0;\n\n#ifdef CONFIG_PROVE_LOCKING\n\tWARN_ON(debug_locks && !lockdep_rtnl_is_held() &&\n\t\t!lockdep_is_held(&local->iflist_mtx));\n#endif\n\tlockdep_assert_held(&local->mtx);\n\n\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\tif (!ieee80211_sdata_running(sdata)) {\n\t\t\tsdata->vif.bss_conf.idle = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tsdata->old_idle = sdata->vif.bss_conf.idle;\n\n\t\t/* do not count disabled managed interfaces */\n\t\tif (sdata->vif.type == NL80211_IFTYPE_STATION &&\n\t\t    !sdata->u.mgd.associated) {\n\t\t\tsdata->vif.bss_conf.idle = true;\n\t\t\tcontinue;\n\t\t}\n\t\t/* do not count unused IBSS interfaces */\n\t\tif (sdata->vif.type == NL80211_IFTYPE_ADHOC &&\n\t\t    !sdata->u.ibss.ssid_len) {\n\t\t\tsdata->vif.bss_conf.idle = true;\n\t\t\tcontinue;\n\t\t}\n\t\t/* count everything else */\n\t\tcount++;\n\t}\n\n\tlist_for_each_entry(wk, &local->work_list, list) {\n\t\tworking = true;\n\t\twk->sdata->vif.bss_conf.idle = false;\n\t}\n\n\tif (local->scan_sdata) {\n\t\tscanning = true;\n\t\tlocal->scan_sdata->vif.bss_conf.idle = false;\n\t}\n\n\tif (local->hw_roc_channel)\n\t\thw_roc = true;\n\n\tlist_for_each_entry(sdata, &local->interfaces, list) {\n\t\tif (sdata->old_idle == sdata->vif.bss_conf.idle)\n\t\t\tcontinue;\n\t\tif (!ieee80211_sdata_running(sdata))\n\t\t\tcontinue;\n\t\tieee80211_bss_info_change_notify(sdata, BSS_CHANGED_IDLE);\n\t}\n\n\tif (working || scanning || hw_roc)\n\t\tled_trig_start |= IEEE80211_TPT_LEDTRIG_FL_WORK;\n\telse\n\t\tled_trig_stop |= IEEE80211_TPT_LEDTRIG_FL_WORK;\n\n\tif (count)\n\t\tled_trig_start |= IEEE80211_TPT_LEDTRIG_FL_CONNECTED;\n\telse\n\t\tled_trig_stop |= IEEE80211_TPT_LEDTRIG_FL_CONNECTED;\n\n\tieee80211_mod_tpt_led_trig(local, led_trig_start, led_trig_stop);\n\n\tif (hw_roc)\n\t\treturn ieee80211_idle_off(local, \"hw remain-on-channel\");\n\tif (working)\n\t\treturn ieee80211_idle_off(local, \"working\");\n\tif (scanning)\n\t\treturn ieee80211_idle_off(local, \"scanning\");\n\tif (!count)\n\t\treturn ieee80211_idle_on(local);\n\telse\n\t\treturn ieee80211_idle_off(local, \"in use\");\n\n\treturn 0;\n}\n\nvoid ieee80211_recalc_idle(struct ieee80211_local *local)\n{\n\tu32 chg;\n\n\tmutex_lock(&local->iflist_mtx);\n\tchg = __ieee80211_recalc_idle(local);\n\tmutex_unlock(&local->iflist_mtx);\n\tif (chg)\n\t\tieee80211_hw_config(local, chg);\n}\n\nstatic int netdev_notify(struct notifier_block *nb,\n\t\t\t unsigned long state,\n\t\t\t void *ndev)\n{\n\tstruct net_device *dev = ndev;\n\tstruct ieee80211_sub_if_data *sdata;\n\n\tif (state != NETDEV_CHANGENAME)\n\t\treturn 0;\n\n\tif (!dev->ieee80211_ptr || !dev->ieee80211_ptr->wiphy)\n\t\treturn 0;\n\n\tif (dev->ieee80211_ptr->wiphy->privid != mac80211_wiphy_privid)\n\t\treturn 0;\n\n\tsdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\tmemcpy(sdata->name, dev->name, IFNAMSIZ);\n\n\tieee80211_debugfs_rename_netdev(sdata);\n\treturn 0;\n}\n\nstatic struct notifier_block mac80211_netdev_notifier = {\n\t.notifier_call = netdev_notify,\n};\n\nint ieee80211_iface_init(void)\n{\n\treturn register_netdevice_notifier(&mac80211_netdev_notifier);\n}\n\nvoid ieee80211_iface_exit(void)\n{\n\tunregister_netdevice_notifier(&mac80211_netdev_notifier);\n}\n"], "filenames": ["drivers/isdn/i4l/isdn_net.c", "drivers/net/bonding/bond_main.c", "drivers/net/ifb.c", "drivers/net/macvlan.c", "drivers/net/tun.c", "drivers/net/veth.c", "drivers/net/wan/hdlc_fr.c", "drivers/net/wireless/airo.c", "drivers/net/wireless/hostap/hostap_main.c", "drivers/staging/ath6kl/os/linux/ar6000_drv.c", "net/8021q/vlan_dev.c", "net/bluetooth/bnep/netdev.c", "net/l2tp/l2tp_eth.c", "net/mac80211/iface.c"], "buggy_code_start_loc": [2534, 1560, 186, 575, 530, 265, 1077, 2825, 857, 6181, 698, 233, 106, 700], "buggy_code_end_loc": [2534, 4334, 187, 576, 530, 265, 1080, 2825, 857, 6181, 699, 233, 107, 700], "fixing_code_start_loc": [2535, 1560, 186, 575, 531, 266, 1077, 2826, 858, 6182, 698, 234, 106, 701], "fixing_code_end_loc": [2538, 4336, 187, 576, 532, 268, 1081, 2827, 859, 6183, 699, 235, 107, 702], "type": "NVD-CWE-noinfo", "message": "The net subsystem in the Linux kernel before 3.1 does not properly restrict use of the IFF_TX_SKB_SHARING flag, which allows local users to cause a denial of service (panic) by leveraging the CAP_NET_ADMIN capability to access /proc/net/pktgen/pgctrl, and then using the pktgen package in conjunction with a bridge device for a VLAN interface.", "other": {"cve": {"id": "CVE-2011-4112", "sourceIdentifier": "secalert@redhat.com", "published": "2012-05-17T11:00:32.757", "lastModified": "2023-02-13T01:21:27.810", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The net subsystem in the Linux kernel before 3.1 does not properly restrict use of the IFF_TX_SKB_SHARING flag, which allows local users to cause a denial of service (panic) by leveraging the CAP_NET_ADMIN capability to access /proc/net/pktgen/pgctrl, and then using the pktgen package in conjunction with a bridge device for a VLAN interface."}, {"lang": "es", "value": "El subsistema de red en el kernel de Linux antes de v3.1 no restringe adecuadamente el uso de la bandera IFF_TX_SKB_SHARING, lo que permite a usuarios locales causar una denegaci\u00f3n de servicio (panic) mediante el aprovechamiento de la funcionalidad CAP_NET_ADMIN para acceder a /proc/net/pktgen/pgctrl para, a continuaci\u00f3n, usar el paquete pktgen junto con un dispositivo de puente para una interfaz VLAN."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.1", "matchCriteriaId": "156989A4-23D9-434A-B512-9C0F3583D13D"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:avaya:9608_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.0", "versionEndIncluding": "6.6.0", "matchCriteriaId": "F84E862C-FBF3-416E-8EF0-58A84B5F3F73"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:avaya:9608:-:*:*:*:*:*:*:*", "matchCriteriaId": "A19365A8-CCD5-410E-BB2D-1B8C1E995768"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:avaya:9608g_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.0", "versionEndIncluding": "6.6.0", "matchCriteriaId": "83FC5CEA-4EF1-4CA1-9094-6E40DCF3FAC3"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:avaya:9608g:-:*:*:*:*:*:*:*", "matchCriteriaId": "787289FF-AD0C-4E55-9521-F99D26412C35"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:avaya:9611g_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.0", "versionEndIncluding": "6.6.0", "matchCriteriaId": "A8895429-A1B6-4B39-A93F-EDD5D49F03B0"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:avaya:9611g:-:*:*:*:*:*:*:*", "matchCriteriaId": "5CEDBEB4-D9F2-4BBB-940A-D887F2C7A86F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:avaya:9621g_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.0", "versionEndIncluding": "6.6.0", "matchCriteriaId": "BCEA36DC-17F8-4535-AB2E-329C076A8831"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:avaya:9621g:-:*:*:*:*:*:*:*", "matchCriteriaId": "337D5E48-6AC6-4723-862A-1F7A9180322C"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:avaya:9641g_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.0", "versionEndIncluding": "6.6.0", "matchCriteriaId": "3FC48708-1F19-430B-A84A-4F853B247B6B"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:avaya:9641g:-:*:*:*:*:*:*:*", "matchCriteriaId": "0C5EC883-7D5F-48E9-A3A9-A2E2A6903483"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:avaya:9641gs_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.0", "versionEndIncluding": "6.6.0", "matchCriteriaId": "BE9207F2-B3B2-4312-9D32-4FD800AC0463"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:avaya:9641gs:-:*:*:*:*:*:*:*", "matchCriteriaId": "09AF8F44-9695-4F82-9943-4406A3B9879B"}]}]}], "references": [{"url": "http://downloads.avaya.com/css/P8/documents/100156038", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=550fd08c2cebad61c548def135f67aba284c6162", "source": "secalert@redhat.com"}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.1", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2011/11/21/4", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=751006", "source": "secalert@redhat.com", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/550fd08c2cebad61c548def135f67aba284c6162"}}