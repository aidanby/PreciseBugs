{"buggy_code": ["/* @flow */\n/* global child_process$spawnOpts */\n\nimport * as constants from '../constants.js';\nimport BlockingQueue from './blocking-queue.js';\nimport {ProcessSpawnError, ProcessTermError} from '../errors.js';\nimport {promisify} from './promise.js';\n\nconst child = require('child_process');\n\nexport const queue = new BlockingQueue('child', constants.CHILD_CONCURRENCY);\n\n// TODO: this uid check is kinda whack\nlet uid = 0;\n\nexport const exec = promisify(child.exec);\n\nexport function forkp(program: string, args: Array<string>, opts?: Object): Promise<number> {\n  const key = String(++uid);\n  return new Promise((resolve, reject) => {\n    const proc = child.fork(program, args, opts);\n    spawnedProcesses[key] = proc;\n\n    proc.on('error', error => {\n      reject(error);\n    });\n\n    proc.on('close', exitCode => {\n      resolve(exitCode);\n    });\n  });\n}\n\nexport function spawnp(program: string, args: Array<string>, opts?: Object): Promise<number> {\n  const key = String(++uid);\n  return new Promise((resolve, reject) => {\n    const proc = child.spawn(program, args, opts);\n    spawnedProcesses[key] = proc;\n\n    proc.on('error', error => {\n      reject(error);\n    });\n\n    proc.on('close', exitCode => {\n      resolve(exitCode);\n    });\n  });\n}\n\nconst spawnedProcesses = {};\n\nexport function forwardSignalToSpawnedProcesses(signal: string) {\n  for (const key of Object.keys(spawnedProcesses)) {\n    spawnedProcesses[key].kill(signal);\n  }\n}\n\ntype ProcessFn = (\n  proc: child_process$ChildProcess,\n  update: (chunk: string) => void,\n  reject: (err: mixed) => void,\n  done: () => void,\n) => void;\n\nexport function spawn(\n  program: string,\n  args: Array<string>,\n  opts?: child_process$spawnOpts & {detached?: boolean, process?: ProcessFn} = {},\n  onData?: (chunk: Buffer | string) => void,\n): Promise<string> {\n  const key = opts.cwd || String(++uid);\n  return queue.push(\n    key,\n    (): Promise<string> =>\n      new Promise((resolve, reject) => {\n        const proc = child.spawn(program, args, opts);\n        spawnedProcesses[key] = proc;\n\n        let processingDone = false;\n        let processClosed = false;\n        let err = null;\n\n        let stdout = '';\n\n        proc.on('error', err => {\n          if (err.code === 'ENOENT') {\n            reject(new ProcessSpawnError(`Couldn't find the binary ${program}`, err.code, program));\n          } else {\n            reject(err);\n          }\n        });\n\n        function updateStdout(chunk: string) {\n          stdout += chunk;\n          if (onData) {\n            onData(chunk);\n          }\n        }\n\n        function finish() {\n          delete spawnedProcesses[key];\n          if (err) {\n            reject(err);\n          } else {\n            resolve(stdout.trim());\n          }\n        }\n\n        if (typeof opts.process === 'function') {\n          opts.process(proc, updateStdout, reject, function() {\n            if (processClosed) {\n              finish();\n            } else {\n              processingDone = true;\n            }\n          });\n        } else {\n          if (proc.stderr) {\n            proc.stderr.on('data', updateStdout);\n          }\n\n          if (proc.stdout) {\n            proc.stdout.on('data', updateStdout);\n          }\n\n          processingDone = true;\n        }\n\n        proc.on('close', (code: number, signal: string) => {\n          if (signal || code >= 1) {\n            err = new ProcessTermError(\n              [\n                'Command failed.',\n                signal ? `Exit signal: ${signal}` : `Exit code: ${code}`,\n                `Command: ${program}`,\n                `Arguments: ${args.join(' ')}`,\n                `Directory: ${opts.cwd || process.cwd()}`,\n                `Output:\\n${stdout.trim()}`,\n              ].join('\\n'),\n            );\n            err.EXIT_SIGNAL = signal;\n            err.EXIT_CODE = code;\n          }\n\n          if (processingDone || err) {\n            finish();\n          } else {\n            processClosed = true;\n          }\n        });\n      }),\n  );\n}\n"], "fixing_code": ["/* @flow */\n/* global child_process$spawnOpts */\n\nimport * as constants from '../constants.js';\nimport BlockingQueue from './blocking-queue.js';\nimport {ProcessSpawnError, ProcessTermError} from '../errors.js';\nimport {promisify} from './promise.js';\n\nconst child = require('child_process');\nconst fs = require('fs');\nconst path = require('path');\n\nexport const queue = new BlockingQueue('child', constants.CHILD_CONCURRENCY);\n\n// TODO: this uid check is kinda whack\nlet uid = 0;\n\nexport const exec = promisify(child.exec);\n\nfunction validate(program: string, opts?: Object = {}) {\n  if (program.includes('/')) {\n    return true;\n  }\n\n  const cwd = opts.cwd || process.cwd();\n  const pathext = process.env.PATHEXT || '';\n\n  for (const ext of pathext.split(';')) {\n    const candidate = path.join(cwd, `${program}${ext}`);\n    if (fs.existsSync(candidate)) {\n      throw new Error(`Potentially dangerous call to \"${program}\" in ${cwd}`);\n    }\n  }\n}\n\nexport function forkp(program: string, args: Array<string>, opts?: Object): Promise<number> {\n  validate(program, opts);\n  const key = String(++uid);\n  return new Promise((resolve, reject) => {\n    const proc = child.fork(program, args, opts);\n    spawnedProcesses[key] = proc;\n\n    proc.on('error', error => {\n      reject(error);\n    });\n\n    proc.on('close', exitCode => {\n      resolve(exitCode);\n    });\n  });\n}\n\nexport function spawnp(program: string, args: Array<string>, opts?: Object): Promise<number> {\n  validate(program, opts);\n  const key = String(++uid);\n  return new Promise((resolve, reject) => {\n    const proc = child.spawn(program, args, opts);\n    spawnedProcesses[key] = proc;\n\n    proc.on('error', error => {\n      reject(error);\n    });\n\n    proc.on('close', exitCode => {\n      resolve(exitCode);\n    });\n  });\n}\n\nconst spawnedProcesses = {};\n\nexport function forwardSignalToSpawnedProcesses(signal: string) {\n  for (const key of Object.keys(spawnedProcesses)) {\n    spawnedProcesses[key].kill(signal);\n  }\n}\n\ntype ProcessFn = (\n  proc: child_process$ChildProcess,\n  update: (chunk: string) => void,\n  reject: (err: mixed) => void,\n  done: () => void,\n) => void;\n\nexport function spawn(\n  program: string,\n  args: Array<string>,\n  opts?: child_process$spawnOpts & {detached?: boolean, process?: ProcessFn} = {},\n  onData?: (chunk: Buffer | string) => void,\n): Promise<string> {\n  const key = opts.cwd || String(++uid);\n  return queue.push(\n    key,\n    (): Promise<string> =>\n      new Promise((resolve, reject) => {\n        validate(program, opts);\n\n        const proc = child.spawn(program, args, opts);\n        spawnedProcesses[key] = proc;\n\n        let processingDone = false;\n        let processClosed = false;\n        let err = null;\n\n        let stdout = '';\n\n        proc.on('error', err => {\n          if (err.code === 'ENOENT') {\n            reject(new ProcessSpawnError(`Couldn't find the binary ${program}`, err.code, program));\n          } else {\n            reject(err);\n          }\n        });\n\n        function updateStdout(chunk: string) {\n          stdout += chunk;\n          if (onData) {\n            onData(chunk);\n          }\n        }\n\n        function finish() {\n          delete spawnedProcesses[key];\n          if (err) {\n            reject(err);\n          } else {\n            resolve(stdout.trim());\n          }\n        }\n\n        if (typeof opts.process === 'function') {\n          opts.process(proc, updateStdout, reject, function() {\n            if (processClosed) {\n              finish();\n            } else {\n              processingDone = true;\n            }\n          });\n        } else {\n          if (proc.stderr) {\n            proc.stderr.on('data', updateStdout);\n          }\n\n          if (proc.stdout) {\n            proc.stdout.on('data', updateStdout);\n          }\n\n          processingDone = true;\n        }\n\n        proc.on('close', (code: number, signal: string) => {\n          if (signal || code >= 1) {\n            err = new ProcessTermError(\n              [\n                'Command failed.',\n                signal ? `Exit signal: ${signal}` : `Exit code: ${code}`,\n                `Command: ${program}`,\n                `Arguments: ${args.join(' ')}`,\n                `Directory: ${opts.cwd || process.cwd()}`,\n                `Output:\\n${stdout.trim()}`,\n              ].join('\\n'),\n            );\n            err.EXIT_SIGNAL = signal;\n            err.EXIT_CODE = code;\n          }\n\n          if (processingDone || err) {\n            finish();\n          } else {\n            processClosed = true;\n          }\n        });\n      }),\n  );\n}\n"], "filenames": ["src/util/child.js"], "buggy_code_start_loc": [9], "buggy_code_end_loc": [75], "fixing_code_start_loc": [10], "fixing_code_end_loc": [98], "type": "CWE-426", "message": "An untrusted search path vulnerability was found in Yarn. When a victim runs certain Yarn commands in a directory with attacker-controlled content, malicious commands could be executed in unexpected ways.", "other": {"cve": {"id": "CVE-2021-4435", "sourceIdentifier": "patrick@puiterwijk.org", "published": "2024-02-04T20:15:45.657", "lastModified": "2024-02-13T00:38:56.303", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An untrusted search path vulnerability was found in Yarn. When a victim runs certain Yarn commands in a directory with attacker-controlled content, malicious commands could be executed in unexpected ways."}, {"lang": "es", "value": "Se encontr\u00f3 una vulnerabilidad de ruta de b\u00fasqueda no confiable en Yarn. Cuando una v\u00edctima ejecuta ciertos comandos de Yarn en un directorio con contenido controlado por un atacante, se podr\u00edan ejecutar comandos maliciosos de formas inesperadas."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "patrick@puiterwijk.org", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:N/UI:R/S:C/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 6.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-426"}]}, {"source": "patrick@puiterwijk.org", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-426"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:yarnpkg:yarn:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.22.13", "matchCriteriaId": "BCBACDE9-403C-4A92-8F39-ABCF4216F7AA"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/CVE-2021-4435", "source": "patrick@puiterwijk.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2262284", "source": "patrick@puiterwijk.org", "tags": ["Issue Tracking"]}, {"url": "https://github.com/yarnpkg/yarn/commit/67fcce88935e45092ffa2674c08053f1ef5268a1", "source": "patrick@puiterwijk.org", "tags": ["Patch"]}, {"url": "https://github.com/yarnpkg/yarn/releases/tag/v1.22.13", "source": "patrick@puiterwijk.org", "tags": ["Release Notes"]}]}, "github_commit_url": "https://github.com/yarnpkg/yarn/commit/67fcce88935e45092ffa2674c08053f1ef5268a1"}}