{"buggy_code": ["/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _NET_NF_TABLES_H\n#define _NET_NF_TABLES_H\n\n#include <asm/unaligned.h>\n#include <linux/list.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nfnetlink.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter/nf_tables.h>\n#include <linux/u64_stats_sync.h>\n#include <linux/rhashtable.h>\n#include <net/netfilter/nf_flow_table.h>\n#include <net/netlink.h>\n#include <net/flow_offload.h>\n#include <net/netns/generic.h>\n\n#define NFT_MAX_HOOKS\t(NF_INET_INGRESS + 1)\n\nstruct module;\n\n#define NFT_JUMP_STACK_SIZE\t16\n\nenum {\n\tNFT_PKTINFO_L4PROTO\t= (1 << 0),\n\tNFT_PKTINFO_INNER\t= (1 << 1),\n\tNFT_PKTINFO_INNER_FULL\t= (1 << 2),\n};\n\nstruct nft_pktinfo {\n\tstruct sk_buff\t\t\t*skb;\n\tconst struct nf_hook_state\t*state;\n\tu8\t\t\t\tflags;\n\tu8\t\t\t\ttprot;\n\tu16\t\t\t\tfragoff;\n\tu16\t\t\t\tthoff;\n\tu16\t\t\t\tinneroff;\n};\n\nstatic inline struct sock *nft_sk(const struct nft_pktinfo *pkt)\n{\n\treturn pkt->state->sk;\n}\n\nstatic inline unsigned int nft_thoff(const struct nft_pktinfo *pkt)\n{\n\treturn pkt->thoff;\n}\n\nstatic inline struct net *nft_net(const struct nft_pktinfo *pkt)\n{\n\treturn pkt->state->net;\n}\n\nstatic inline unsigned int nft_hook(const struct nft_pktinfo *pkt)\n{\n\treturn pkt->state->hook;\n}\n\nstatic inline u8 nft_pf(const struct nft_pktinfo *pkt)\n{\n\treturn pkt->state->pf;\n}\n\nstatic inline const struct net_device *nft_in(const struct nft_pktinfo *pkt)\n{\n\treturn pkt->state->in;\n}\n\nstatic inline const struct net_device *nft_out(const struct nft_pktinfo *pkt)\n{\n\treturn pkt->state->out;\n}\n\nstatic inline void nft_set_pktinfo(struct nft_pktinfo *pkt,\n\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t   const struct nf_hook_state *state)\n{\n\tpkt->skb = skb;\n\tpkt->state = state;\n}\n\nstatic inline void nft_set_pktinfo_unspec(struct nft_pktinfo *pkt)\n{\n\tpkt->flags = 0;\n\tpkt->tprot = 0;\n\tpkt->thoff = 0;\n\tpkt->fragoff = 0;\n}\n\n/**\n * \tstruct nft_verdict - nf_tables verdict\n *\n * \t@code: nf_tables/netfilter verdict code\n * \t@chain: destination chain for NFT_JUMP/NFT_GOTO\n */\nstruct nft_verdict {\n\tu32\t\t\t\tcode;\n\tstruct nft_chain\t\t*chain;\n};\n\nstruct nft_data {\n\tunion {\n\t\tu32\t\t\tdata[4];\n\t\tstruct nft_verdict\tverdict;\n\t};\n} __attribute__((aligned(__alignof__(u64))));\n\n#define NFT_REG32_NUM\t\t20\n\n/**\n *\tstruct nft_regs - nf_tables register set\n *\n *\t@data: data registers\n *\t@verdict: verdict register\n *\n *\tThe first four data registers alias to the verdict register.\n */\nstruct nft_regs {\n\tunion {\n\t\tu32\t\t\tdata[NFT_REG32_NUM];\n\t\tstruct nft_verdict\tverdict;\n\t};\n};\n\nstruct nft_regs_track {\n\tstruct {\n\t\tconst struct nft_expr\t\t*selector;\n\t\tconst struct nft_expr\t\t*bitwise;\n\t\tu8\t\t\t\tnum_reg;\n\t} regs[NFT_REG32_NUM];\n\n\tconst struct nft_expr\t\t\t*cur;\n\tconst struct nft_expr\t\t\t*last;\n};\n\n/* Store/load an u8, u16 or u64 integer to/from the u32 data register.\n *\n * Note, when using concatenations, register allocation happens at 32-bit\n * level. So for store instruction, pad the rest part with zero to avoid\n * garbage values.\n */\n\nstatic inline void nft_reg_store8(u32 *dreg, u8 val)\n{\n\t*dreg = 0;\n\t*(u8 *)dreg = val;\n}\n\nstatic inline u8 nft_reg_load8(const u32 *sreg)\n{\n\treturn *(u8 *)sreg;\n}\n\nstatic inline void nft_reg_store16(u32 *dreg, u16 val)\n{\n\t*dreg = 0;\n\t*(u16 *)dreg = val;\n}\n\nstatic inline void nft_reg_store_be16(u32 *dreg, __be16 val)\n{\n\tnft_reg_store16(dreg, (__force __u16)val);\n}\n\nstatic inline u16 nft_reg_load16(const u32 *sreg)\n{\n\treturn *(u16 *)sreg;\n}\n\nstatic inline __be16 nft_reg_load_be16(const u32 *sreg)\n{\n\treturn (__force __be16)nft_reg_load16(sreg);\n}\n\nstatic inline __be32 nft_reg_load_be32(const u32 *sreg)\n{\n\treturn *(__force __be32 *)sreg;\n}\n\nstatic inline void nft_reg_store64(u32 *dreg, u64 val)\n{\n\tput_unaligned(val, (u64 *)dreg);\n}\n\nstatic inline u64 nft_reg_load64(const u32 *sreg)\n{\n\treturn get_unaligned((u64 *)sreg);\n}\n\nstatic inline void nft_data_copy(u32 *dst, const struct nft_data *src,\n\t\t\t\t unsigned int len)\n{\n\tif (len % NFT_REG32_SIZE)\n\t\tdst[len / NFT_REG32_SIZE] = 0;\n\tmemcpy(dst, src, len);\n}\n\n/**\n *\tstruct nft_ctx - nf_tables rule/set context\n *\n *\t@net: net namespace\n * \t@table: the table the chain is contained in\n * \t@chain: the chain the rule is contained in\n *\t@nla: netlink attributes\n *\t@portid: netlink portID of the original message\n *\t@seq: netlink sequence number\n *\t@family: protocol family\n *\t@level: depth of the chains\n *\t@report: notify via unicast netlink message\n */\nstruct nft_ctx {\n\tstruct net\t\t\t*net;\n\tstruct nft_table\t\t*table;\n\tstruct nft_chain\t\t*chain;\n\tconst struct nlattr * const \t*nla;\n\tu32\t\t\t\tportid;\n\tu32\t\t\t\tseq;\n\tu16\t\t\t\tflags;\n\tu8\t\t\t\tfamily;\n\tu8\t\t\t\tlevel;\n\tbool\t\t\t\treport;\n};\n\nenum nft_data_desc_flags {\n\tNFT_DATA_DESC_SETELEM\t= (1 << 0),\n};\n\nstruct nft_data_desc {\n\tenum nft_data_types\t\ttype;\n\tunsigned int\t\t\tsize;\n\tunsigned int\t\t\tlen;\n\tunsigned int\t\t\tflags;\n};\n\nint nft_data_init(const struct nft_ctx *ctx, struct nft_data *data,\n\t\t  struct nft_data_desc *desc, const struct nlattr *nla);\nvoid nft_data_hold(const struct nft_data *data, enum nft_data_types type);\nvoid nft_data_release(const struct nft_data *data, enum nft_data_types type);\nint nft_data_dump(struct sk_buff *skb, int attr, const struct nft_data *data,\n\t\t  enum nft_data_types type, unsigned int len);\n\nstatic inline enum nft_data_types nft_dreg_to_type(enum nft_registers reg)\n{\n\treturn reg == NFT_REG_VERDICT ? NFT_DATA_VERDICT : NFT_DATA_VALUE;\n}\n\nstatic inline enum nft_registers nft_type_to_reg(enum nft_data_types type)\n{\n\treturn type == NFT_DATA_VERDICT ? NFT_REG_VERDICT : NFT_REG_1 * NFT_REG_SIZE / NFT_REG32_SIZE;\n}\n\nint nft_parse_u32_check(const struct nlattr *attr, int max, u32 *dest);\nint nft_dump_register(struct sk_buff *skb, unsigned int attr, unsigned int reg);\n\nint nft_parse_register_load(const struct nlattr *attr, u8 *sreg, u32 len);\nint nft_parse_register_store(const struct nft_ctx *ctx,\n\t\t\t     const struct nlattr *attr, u8 *dreg,\n\t\t\t     const struct nft_data *data,\n\t\t\t     enum nft_data_types type, unsigned int len);\n\n/**\n *\tstruct nft_userdata - user defined data associated with an object\n *\n *\t@len: length of the data\n *\t@data: content\n *\n *\tThe presence of user data is indicated in an object specific fashion,\n *\tso a length of zero can't occur and the value \"len\" indicates data\n *\tof length len + 1.\n */\nstruct nft_userdata {\n\tu8\t\t\tlen;\n\tunsigned char\t\tdata[];\n};\n\n/* placeholder structure for opaque set element backend representation. */\nstruct nft_elem_priv { };\n\n/**\n *\tstruct nft_set_elem - generic representation of set elements\n *\n *\t@key: element key\n *\t@key_end: closing element key\n *\t@priv: element private data and extensions\n */\nstruct nft_set_elem {\n\tunion {\n\t\tu32\t\tbuf[NFT_DATA_VALUE_MAXLEN / sizeof(u32)];\n\t\tstruct nft_data\tval;\n\t} key;\n\tunion {\n\t\tu32\t\tbuf[NFT_DATA_VALUE_MAXLEN / sizeof(u32)];\n\t\tstruct nft_data\tval;\n\t} key_end;\n\tunion {\n\t\tu32\t\tbuf[NFT_DATA_VALUE_MAXLEN / sizeof(u32)];\n\t\tstruct nft_data val;\n\t} data;\n\tstruct nft_elem_priv\t*priv;\n};\n\nstatic inline void *nft_elem_priv_cast(const struct nft_elem_priv *priv)\n{\n\treturn (void *)priv;\n}\n\nstruct nft_set;\nstruct nft_set_iter {\n\tu8\t\tgenmask;\n\tunsigned int\tcount;\n\tunsigned int\tskip;\n\tint\t\terr;\n\tint\t\t(*fn)(const struct nft_ctx *ctx,\n\t\t\t      struct nft_set *set,\n\t\t\t      const struct nft_set_iter *iter,\n\t\t\t      struct nft_elem_priv *elem_priv);\n};\n\n/**\n *\tstruct nft_set_desc - description of set elements\n *\n *\t@ktype: key type\n *\t@klen: key length\n *\t@dtype: data type\n *\t@dlen: data length\n *\t@objtype: object type\n *\t@flags: flags\n *\t@size: number of set elements\n *\t@policy: set policy\n *\t@gc_int: garbage collector interval\n *\t@field_len: length of each field in concatenation, bytes\n *\t@field_count: number of concatenated fields in element\n *\t@expr: set must support for expressions\n */\nstruct nft_set_desc {\n\tu32\t\t\tktype;\n\tunsigned int\t\tklen;\n\tu32\t\t\tdtype;\n\tunsigned int\t\tdlen;\n\tu32\t\t\tobjtype;\n\tunsigned int\t\tsize;\n\tu32\t\t\tpolicy;\n\tu32\t\t\tgc_int;\n\tu64\t\t\ttimeout;\n\tu8\t\t\tfield_len[NFT_REG32_COUNT];\n\tu8\t\t\tfield_count;\n\tbool\t\t\texpr;\n};\n\n/**\n *\tenum nft_set_class - performance class\n *\n *\t@NFT_LOOKUP_O_1: constant, O(1)\n *\t@NFT_LOOKUP_O_LOG_N: logarithmic, O(log N)\n *\t@NFT_LOOKUP_O_N: linear, O(N)\n */\nenum nft_set_class {\n\tNFT_SET_CLASS_O_1,\n\tNFT_SET_CLASS_O_LOG_N,\n\tNFT_SET_CLASS_O_N,\n};\n\n/**\n *\tstruct nft_set_estimate - estimation of memory and performance\n *\t\t\t\t  characteristics\n *\n *\t@size: required memory\n *\t@lookup: lookup performance class\n *\t@space: memory class\n */\nstruct nft_set_estimate {\n\tu64\t\t\tsize;\n\tenum nft_set_class\tlookup;\n\tenum nft_set_class\tspace;\n};\n\n#define NFT_EXPR_MAXATTR\t\t16\n#define NFT_EXPR_SIZE(size)\t\t(sizeof(struct nft_expr) + \\\n\t\t\t\t\t ALIGN(size, __alignof__(struct nft_expr)))\n\n/**\n *\tstruct nft_expr - nf_tables expression\n *\n *\t@ops: expression ops\n *\t@data: expression private data\n */\nstruct nft_expr {\n\tconst struct nft_expr_ops\t*ops;\n\tunsigned char\t\t\tdata[]\n\t\t__attribute__((aligned(__alignof__(u64))));\n};\n\nstatic inline void *nft_expr_priv(const struct nft_expr *expr)\n{\n\treturn (void *)expr->data;\n}\n\nstruct nft_expr_info;\n\nint nft_expr_inner_parse(const struct nft_ctx *ctx, const struct nlattr *nla,\n\t\t\t struct nft_expr_info *info);\nint nft_expr_clone(struct nft_expr *dst, struct nft_expr *src);\nvoid nft_expr_destroy(const struct nft_ctx *ctx, struct nft_expr *expr);\nint nft_expr_dump(struct sk_buff *skb, unsigned int attr,\n\t\t  const struct nft_expr *expr, bool reset);\nbool nft_expr_reduce_bitwise(struct nft_regs_track *track,\n\t\t\t     const struct nft_expr *expr);\n\nstruct nft_set_ext;\n\n/**\n *\tstruct nft_set_ops - nf_tables set operations\n *\n *\t@lookup: look up an element within the set\n *\t@update: update an element if exists, add it if doesn't exist\n *\t@delete: delete an element\n *\t@insert: insert new element into set\n *\t@activate: activate new element in the next generation\n *\t@deactivate: lookup for element and deactivate it in the next generation\n *\t@flush: deactivate element in the next generation\n *\t@remove: remove element from set\n *\t@walk: iterate over all set elements\n *\t@get: get set elements\n *\t@privsize: function to return size of set private data\n *\t@init: initialize private data of new set instance\n *\t@destroy: destroy private data of set instance\n *\t@elemsize: element private size\n *\n *\tOperations lookup, update and delete have simpler interfaces, are faster\n *\tand currently only used in the packet path. All the rest are slower,\n *\tcontrol plane functions.\n */\nstruct nft_set_ops {\n\tbool\t\t\t\t(*lookup)(const struct net *net,\n\t\t\t\t\t\t  const struct nft_set *set,\n\t\t\t\t\t\t  const u32 *key,\n\t\t\t\t\t\t  const struct nft_set_ext **ext);\n\tbool\t\t\t\t(*update)(struct nft_set *set,\n\t\t\t\t\t\t  const u32 *key,\n\t\t\t\t\t\t  struct nft_elem_priv *\n\t\t\t\t\t\t\t(*new)(struct nft_set *,\n\t\t\t\t\t\t\t       const struct nft_expr *,\n\t\t\t\t\t\t\t       struct nft_regs *),\n\t\t\t\t\t\t  const struct nft_expr *expr,\n\t\t\t\t\t\t  struct nft_regs *regs,\n\t\t\t\t\t\t  const struct nft_set_ext **ext);\n\tbool\t\t\t\t(*delete)(const struct nft_set *set,\n\t\t\t\t\t\t  const u32 *key);\n\n\tint\t\t\t\t(*insert)(const struct net *net,\n\t\t\t\t\t\t  const struct nft_set *set,\n\t\t\t\t\t\t  const struct nft_set_elem *elem,\n\t\t\t\t\t\t  struct nft_elem_priv **priv);\n\tvoid\t\t\t\t(*activate)(const struct net *net,\n\t\t\t\t\t\t    const struct nft_set *set,\n\t\t\t\t\t\t    struct nft_elem_priv *elem_priv);\n\tstruct nft_elem_priv *\t\t(*deactivate)(const struct net *net,\n\t\t\t\t\t\t      const struct nft_set *set,\n\t\t\t\t\t\t      const struct nft_set_elem *elem);\n\tvoid\t\t\t\t(*flush)(const struct net *net,\n\t\t\t\t\t\t const struct nft_set *set,\n\t\t\t\t\t\t struct nft_elem_priv *priv);\n\tvoid\t\t\t\t(*remove)(const struct net *net,\n\t\t\t\t\t\t  const struct nft_set *set,\n\t\t\t\t\t\t  struct nft_elem_priv *elem_priv);\n\tvoid\t\t\t\t(*walk)(const struct nft_ctx *ctx,\n\t\t\t\t\t\tstruct nft_set *set,\n\t\t\t\t\t\tstruct nft_set_iter *iter);\n\tstruct nft_elem_priv *\t\t(*get)(const struct net *net,\n\t\t\t\t\t       const struct nft_set *set,\n\t\t\t\t\t       const struct nft_set_elem *elem,\n\t\t\t\t\t       unsigned int flags);\n\tvoid\t\t\t\t(*commit)(struct nft_set *set);\n\tvoid\t\t\t\t(*abort)(const struct nft_set *set);\n\tu64\t\t\t\t(*privsize)(const struct nlattr * const nla[],\n\t\t\t\t\t\t    const struct nft_set_desc *desc);\n\tbool\t\t\t\t(*estimate)(const struct nft_set_desc *desc,\n\t\t\t\t\t\t    u32 features,\n\t\t\t\t\t\t    struct nft_set_estimate *est);\n\tint\t\t\t\t(*init)(const struct nft_set *set,\n\t\t\t\t\t\tconst struct nft_set_desc *desc,\n\t\t\t\t\t\tconst struct nlattr * const nla[]);\n\tvoid\t\t\t\t(*destroy)(const struct nft_ctx *ctx,\n\t\t\t\t\t\t   const struct nft_set *set);\n\tvoid\t\t\t\t(*gc_init)(const struct nft_set *set);\n\n\tunsigned int\t\t\telemsize;\n};\n\n/**\n *      struct nft_set_type - nf_tables set type\n *\n *      @ops: set ops for this type\n *      @features: features supported by the implementation\n */\nstruct nft_set_type {\n\tconst struct nft_set_ops\tops;\n\tu32\t\t\t\tfeatures;\n};\n#define to_set_type(o) container_of(o, struct nft_set_type, ops)\n\nstruct nft_set_elem_expr {\n\tu8\t\t\t\tsize;\n\tunsigned char\t\t\tdata[]\n\t\t__attribute__((aligned(__alignof__(struct nft_expr))));\n};\n\n#define nft_setelem_expr_at(__elem_expr, __offset)\t\t\t\\\n\t((struct nft_expr *)&__elem_expr->data[__offset])\n\n#define nft_setelem_expr_foreach(__expr, __elem_expr, __size)\t\t\\\n\tfor (__expr = nft_setelem_expr_at(__elem_expr, 0), __size = 0;\t\\\n\t     __size < (__elem_expr)->size;\t\t\t\t\\\n\t     __size += (__expr)->ops->size, __expr = ((void *)(__expr)) + (__expr)->ops->size)\n\n#define NFT_SET_EXPR_MAX\t2\n\n/**\n * \tstruct nft_set - nf_tables set instance\n *\n *\t@list: table set list node\n *\t@bindings: list of set bindings\n *\t@refs: internal refcounting for async set destruction\n *\t@table: table this set belongs to\n *\t@net: netnamespace this set belongs to\n * \t@name: name of the set\n *\t@handle: unique handle of the set\n * \t@ktype: key type (numeric type defined by userspace, not used in the kernel)\n * \t@dtype: data type (verdict or numeric type defined by userspace)\n * \t@objtype: object type (see NFT_OBJECT_* definitions)\n * \t@size: maximum set size\n *\t@field_len: length of each field in concatenation, bytes\n *\t@field_count: number of concatenated fields in element\n *\t@use: number of rules references to this set\n * \t@nelems: number of elements\n * \t@ndeact: number of deactivated elements queued for removal\n *\t@timeout: default timeout value in jiffies\n * \t@gc_int: garbage collection interval in msecs\n *\t@policy: set parameterization (see enum nft_set_policies)\n *\t@udlen: user data length\n *\t@udata: user data\n *\t@expr: stateful expression\n * \t@ops: set ops\n * \t@flags: set flags\n *\t@dead: set will be freed, never cleared\n *\t@genmask: generation mask\n * \t@klen: key length\n * \t@dlen: data length\n * \t@data: private set data\n */\nstruct nft_set {\n\tstruct list_head\t\tlist;\n\tstruct list_head\t\tbindings;\n\trefcount_t\t\t\trefs;\n\tstruct nft_table\t\t*table;\n\tpossible_net_t\t\t\tnet;\n\tchar\t\t\t\t*name;\n\tu64\t\t\t\thandle;\n\tu32\t\t\t\tktype;\n\tu32\t\t\t\tdtype;\n\tu32\t\t\t\tobjtype;\n\tu32\t\t\t\tsize;\n\tu8\t\t\t\tfield_len[NFT_REG32_COUNT];\n\tu8\t\t\t\tfield_count;\n\tu32\t\t\t\tuse;\n\tatomic_t\t\t\tnelems;\n\tu32\t\t\t\tndeact;\n\tu64\t\t\t\ttimeout;\n\tu32\t\t\t\tgc_int;\n\tu16\t\t\t\tpolicy;\n\tu16\t\t\t\tudlen;\n\tunsigned char\t\t\t*udata;\n\tstruct list_head\t\tpending_update;\n\t/* runtime data below here */\n\tconst struct nft_set_ops\t*ops ____cacheline_aligned;\n\tu16\t\t\t\tflags:13,\n\t\t\t\t\tdead:1,\n\t\t\t\t\tgenmask:2;\n\tu8\t\t\t\tklen;\n\tu8\t\t\t\tdlen;\n\tu8\t\t\t\tnum_exprs;\n\tstruct nft_expr\t\t\t*exprs[NFT_SET_EXPR_MAX];\n\tstruct list_head\t\tcatchall_list;\n\tunsigned char\t\t\tdata[]\n\t\t__attribute__((aligned(__alignof__(u64))));\n};\n\nstatic inline bool nft_set_is_anonymous(const struct nft_set *set)\n{\n\treturn set->flags & NFT_SET_ANONYMOUS;\n}\n\nstatic inline void *nft_set_priv(const struct nft_set *set)\n{\n\treturn (void *)set->data;\n}\n\nstatic inline bool nft_set_gc_is_pending(const struct nft_set *s)\n{\n\treturn refcount_read(&s->refs) != 1;\n}\n\nstatic inline struct nft_set *nft_set_container_of(const void *priv)\n{\n\treturn (void *)priv - offsetof(struct nft_set, data);\n}\n\nstruct nft_set *nft_set_lookup_global(const struct net *net,\n\t\t\t\t      const struct nft_table *table,\n\t\t\t\t      const struct nlattr *nla_set_name,\n\t\t\t\t      const struct nlattr *nla_set_id,\n\t\t\t\t      u8 genmask);\n\nstruct nft_set_ext *nft_set_catchall_lookup(const struct net *net,\n\t\t\t\t\t    const struct nft_set *set);\n\nstatic inline unsigned long nft_set_gc_interval(const struct nft_set *set)\n{\n\tu32 gc_int = READ_ONCE(set->gc_int);\n\n\treturn gc_int ? msecs_to_jiffies(gc_int) : HZ;\n}\n\n/**\n *\tstruct nft_set_binding - nf_tables set binding\n *\n *\t@list: set bindings list node\n *\t@chain: chain containing the rule bound to the set\n *\t@flags: set action flags\n *\n *\tA set binding contains all information necessary for validation\n *\tof new elements added to a bound set.\n */\nstruct nft_set_binding {\n\tstruct list_head\t\tlist;\n\tconst struct nft_chain\t\t*chain;\n\tu32\t\t\t\tflags;\n};\n\nenum nft_trans_phase;\nvoid nf_tables_activate_set(const struct nft_ctx *ctx, struct nft_set *set);\nvoid nf_tables_deactivate_set(const struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t      struct nft_set_binding *binding,\n\t\t\t      enum nft_trans_phase phase);\nint nf_tables_bind_set(const struct nft_ctx *ctx, struct nft_set *set,\n\t\t       struct nft_set_binding *binding);\nvoid nf_tables_destroy_set(const struct nft_ctx *ctx, struct nft_set *set);\n\n/**\n *\tenum nft_set_extensions - set extension type IDs\n *\n *\t@NFT_SET_EXT_KEY: element key\n *\t@NFT_SET_EXT_KEY_END: upper bound element key, for ranges\n *\t@NFT_SET_EXT_DATA: mapping data\n *\t@NFT_SET_EXT_FLAGS: element flags\n *\t@NFT_SET_EXT_TIMEOUT: element timeout\n *\t@NFT_SET_EXT_EXPIRATION: element expiration time\n *\t@NFT_SET_EXT_USERDATA: user data associated with the element\n *\t@NFT_SET_EXT_EXPRESSIONS: expressions assiciated with the element\n *\t@NFT_SET_EXT_OBJREF: stateful object reference associated with element\n *\t@NFT_SET_EXT_NUM: number of extension types\n */\nenum nft_set_extensions {\n\tNFT_SET_EXT_KEY,\n\tNFT_SET_EXT_KEY_END,\n\tNFT_SET_EXT_DATA,\n\tNFT_SET_EXT_FLAGS,\n\tNFT_SET_EXT_TIMEOUT,\n\tNFT_SET_EXT_EXPIRATION,\n\tNFT_SET_EXT_USERDATA,\n\tNFT_SET_EXT_EXPRESSIONS,\n\tNFT_SET_EXT_OBJREF,\n\tNFT_SET_EXT_NUM\n};\n\n/**\n *\tstruct nft_set_ext_type - set extension type\n *\n * \t@len: fixed part length of the extension\n * \t@align: alignment requirements of the extension\n */\nstruct nft_set_ext_type {\n\tu8\tlen;\n\tu8\talign;\n};\n\nextern const struct nft_set_ext_type nft_set_ext_types[];\n\n/**\n *\tstruct nft_set_ext_tmpl - set extension template\n *\n *\t@len: length of extension area\n *\t@offset: offsets of individual extension types\n */\nstruct nft_set_ext_tmpl {\n\tu16\tlen;\n\tu8\toffset[NFT_SET_EXT_NUM];\n\tu8\text_len[NFT_SET_EXT_NUM];\n};\n\n/**\n *\tstruct nft_set_ext - set extensions\n *\n *\t@genmask: generation mask\n *\t@offset: offsets of individual extension types\n *\t@data: beginning of extension data\n */\nstruct nft_set_ext {\n\tu8\tgenmask;\n\tu8\toffset[NFT_SET_EXT_NUM];\n\tchar\tdata[];\n};\n\nstatic inline void nft_set_ext_prepare(struct nft_set_ext_tmpl *tmpl)\n{\n\tmemset(tmpl, 0, sizeof(*tmpl));\n\ttmpl->len = sizeof(struct nft_set_ext);\n}\n\nstatic inline int nft_set_ext_add_length(struct nft_set_ext_tmpl *tmpl, u8 id,\n\t\t\t\t\t unsigned int len)\n{\n\ttmpl->len\t = ALIGN(tmpl->len, nft_set_ext_types[id].align);\n\tif (tmpl->len > U8_MAX)\n\t\treturn -EINVAL;\n\n\ttmpl->offset[id] = tmpl->len;\n\ttmpl->ext_len[id] = nft_set_ext_types[id].len + len;\n\ttmpl->len\t+= tmpl->ext_len[id];\n\n\treturn 0;\n}\n\nstatic inline int nft_set_ext_add(struct nft_set_ext_tmpl *tmpl, u8 id)\n{\n\treturn nft_set_ext_add_length(tmpl, id, 0);\n}\n\nstatic inline void nft_set_ext_init(struct nft_set_ext *ext,\n\t\t\t\t    const struct nft_set_ext_tmpl *tmpl)\n{\n\tmemcpy(ext->offset, tmpl->offset, sizeof(ext->offset));\n}\n\nstatic inline bool __nft_set_ext_exists(const struct nft_set_ext *ext, u8 id)\n{\n\treturn !!ext->offset[id];\n}\n\nstatic inline bool nft_set_ext_exists(const struct nft_set_ext *ext, u8 id)\n{\n\treturn ext && __nft_set_ext_exists(ext, id);\n}\n\nstatic inline void *nft_set_ext(const struct nft_set_ext *ext, u8 id)\n{\n\treturn (void *)ext + ext->offset[id];\n}\n\nstatic inline struct nft_data *nft_set_ext_key(const struct nft_set_ext *ext)\n{\n\treturn nft_set_ext(ext, NFT_SET_EXT_KEY);\n}\n\nstatic inline struct nft_data *nft_set_ext_key_end(const struct nft_set_ext *ext)\n{\n\treturn nft_set_ext(ext, NFT_SET_EXT_KEY_END);\n}\n\nstatic inline struct nft_data *nft_set_ext_data(const struct nft_set_ext *ext)\n{\n\treturn nft_set_ext(ext, NFT_SET_EXT_DATA);\n}\n\nstatic inline u8 *nft_set_ext_flags(const struct nft_set_ext *ext)\n{\n\treturn nft_set_ext(ext, NFT_SET_EXT_FLAGS);\n}\n\nstatic inline u64 *nft_set_ext_timeout(const struct nft_set_ext *ext)\n{\n\treturn nft_set_ext(ext, NFT_SET_EXT_TIMEOUT);\n}\n\nstatic inline u64 *nft_set_ext_expiration(const struct nft_set_ext *ext)\n{\n\treturn nft_set_ext(ext, NFT_SET_EXT_EXPIRATION);\n}\n\nstatic inline struct nft_userdata *nft_set_ext_userdata(const struct nft_set_ext *ext)\n{\n\treturn nft_set_ext(ext, NFT_SET_EXT_USERDATA);\n}\n\nstatic inline struct nft_set_elem_expr *nft_set_ext_expr(const struct nft_set_ext *ext)\n{\n\treturn nft_set_ext(ext, NFT_SET_EXT_EXPRESSIONS);\n}\n\nstatic inline bool nft_set_elem_expired(const struct nft_set_ext *ext)\n{\n\treturn nft_set_ext_exists(ext, NFT_SET_EXT_EXPIRATION) &&\n\t       time_is_before_eq_jiffies64(*nft_set_ext_expiration(ext));\n}\n\nstatic inline struct nft_set_ext *nft_set_elem_ext(const struct nft_set *set,\n\t\t\t\t\t\t   const struct nft_elem_priv *elem_priv)\n{\n\treturn (void *)elem_priv + set->ops->elemsize;\n}\n\nstatic inline struct nft_object **nft_set_ext_obj(const struct nft_set_ext *ext)\n{\n\treturn nft_set_ext(ext, NFT_SET_EXT_OBJREF);\n}\n\nstruct nft_expr *nft_set_elem_expr_alloc(const struct nft_ctx *ctx,\n\t\t\t\t\t const struct nft_set *set,\n\t\t\t\t\t const struct nlattr *attr);\n\nstruct nft_elem_priv *nft_set_elem_init(const struct nft_set *set,\n\t\t\t\t\tconst struct nft_set_ext_tmpl *tmpl,\n\t\t\t\t\tconst u32 *key, const u32 *key_end,\n\t\t\t\t\tconst u32 *data,\n\t\t\t\t\tu64 timeout, u64 expiration, gfp_t gfp);\nint nft_set_elem_expr_clone(const struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t    struct nft_expr *expr_array[]);\nvoid nft_set_elem_destroy(const struct nft_set *set,\n\t\t\t  const struct nft_elem_priv *elem_priv,\n\t\t\t  bool destroy_expr);\nvoid nf_tables_set_elem_destroy(const struct nft_ctx *ctx,\n\t\t\t\tconst struct nft_set *set,\n\t\t\t\tconst struct nft_elem_priv *elem_priv);\n\nstruct nft_expr_ops;\n/**\n *\tstruct nft_expr_type - nf_tables expression type\n *\n *\t@select_ops: function to select nft_expr_ops\n *\t@release_ops: release nft_expr_ops\n *\t@ops: default ops, used when no select_ops functions is present\n *\t@list: used internally\n *\t@name: Identifier\n *\t@owner: module reference\n *\t@policy: netlink attribute policy\n *\t@maxattr: highest netlink attribute number\n *\t@family: address family for AF-specific types\n *\t@flags: expression type flags\n */\nstruct nft_expr_type {\n\tconst struct nft_expr_ops\t*(*select_ops)(const struct nft_ctx *,\n\t\t\t\t\t\t       const struct nlattr * const tb[]);\n\tvoid\t\t\t\t(*release_ops)(const struct nft_expr_ops *ops);\n\tconst struct nft_expr_ops\t*ops;\n\tconst struct nft_expr_ops\t*inner_ops;\n\tstruct list_head\t\tlist;\n\tconst char\t\t\t*name;\n\tstruct module\t\t\t*owner;\n\tconst struct nla_policy\t\t*policy;\n\tunsigned int\t\t\tmaxattr;\n\tu8\t\t\t\tfamily;\n\tu8\t\t\t\tflags;\n};\n\n#define NFT_EXPR_STATEFUL\t\t0x1\n#define NFT_EXPR_GC\t\t\t0x2\n\nenum nft_trans_phase {\n\tNFT_TRANS_PREPARE,\n\tNFT_TRANS_PREPARE_ERROR,\n\tNFT_TRANS_ABORT,\n\tNFT_TRANS_COMMIT,\n\tNFT_TRANS_RELEASE\n};\n\nstruct nft_flow_rule;\nstruct nft_offload_ctx;\n\n/**\n *\tstruct nft_expr_ops - nf_tables expression operations\n *\n *\t@eval: Expression evaluation function\n *\t@size: full expression size, including private data size\n *\t@init: initialization function\n *\t@activate: activate expression in the next generation\n *\t@deactivate: deactivate expression in next generation\n *\t@destroy: destruction function, called after synchronize_rcu\n *\t@dump: function to dump parameters\n *\t@type: expression type\n *\t@validate: validate expression, called during loop detection\n *\t@data: extra data to attach to this expression operation\n */\nstruct nft_expr_ops {\n\tvoid\t\t\t\t(*eval)(const struct nft_expr *expr,\n\t\t\t\t\t\tstruct nft_regs *regs,\n\t\t\t\t\t\tconst struct nft_pktinfo *pkt);\n\tint\t\t\t\t(*clone)(struct nft_expr *dst,\n\t\t\t\t\t\t const struct nft_expr *src);\n\tunsigned int\t\t\tsize;\n\n\tint\t\t\t\t(*init)(const struct nft_ctx *ctx,\n\t\t\t\t\t\tconst struct nft_expr *expr,\n\t\t\t\t\t\tconst struct nlattr * const tb[]);\n\tvoid\t\t\t\t(*activate)(const struct nft_ctx *ctx,\n\t\t\t\t\t\t    const struct nft_expr *expr);\n\tvoid\t\t\t\t(*deactivate)(const struct nft_ctx *ctx,\n\t\t\t\t\t\t      const struct nft_expr *expr,\n\t\t\t\t\t\t      enum nft_trans_phase phase);\n\tvoid\t\t\t\t(*destroy)(const struct nft_ctx *ctx,\n\t\t\t\t\t\t   const struct nft_expr *expr);\n\tvoid\t\t\t\t(*destroy_clone)(const struct nft_ctx *ctx,\n\t\t\t\t\t\t\t const struct nft_expr *expr);\n\tint\t\t\t\t(*dump)(struct sk_buff *skb,\n\t\t\t\t\t\tconst struct nft_expr *expr,\n\t\t\t\t\t\tbool reset);\n\tint\t\t\t\t(*validate)(const struct nft_ctx *ctx,\n\t\t\t\t\t\t    const struct nft_expr *expr,\n\t\t\t\t\t\t    const struct nft_data **data);\n\tbool\t\t\t\t(*reduce)(struct nft_regs_track *track,\n\t\t\t\t\t\t  const struct nft_expr *expr);\n\tbool\t\t\t\t(*gc)(struct net *net,\n\t\t\t\t\t      const struct nft_expr *expr);\n\tint\t\t\t\t(*offload)(struct nft_offload_ctx *ctx,\n\t\t\t\t\t\t   struct nft_flow_rule *flow,\n\t\t\t\t\t\t   const struct nft_expr *expr);\n\tbool\t\t\t\t(*offload_action)(const struct nft_expr *expr);\n\tvoid\t\t\t\t(*offload_stats)(struct nft_expr *expr,\n\t\t\t\t\t\t\t const struct flow_stats *stats);\n\tconst struct nft_expr_type\t*type;\n\tvoid\t\t\t\t*data;\n};\n\n/**\n *\tstruct nft_rule - nf_tables rule\n *\n *\t@list: used internally\n *\t@handle: rule handle\n *\t@genmask: generation mask\n *\t@dlen: length of expression data\n *\t@udata: user data is appended to the rule\n *\t@data: expression data\n */\nstruct nft_rule {\n\tstruct list_head\t\tlist;\n\tu64\t\t\t\thandle:42,\n\t\t\t\t\tgenmask:2,\n\t\t\t\t\tdlen:12,\n\t\t\t\t\tudata:1;\n\tunsigned char\t\t\tdata[]\n\t\t__attribute__((aligned(__alignof__(struct nft_expr))));\n};\n\nstatic inline struct nft_expr *nft_expr_first(const struct nft_rule *rule)\n{\n\treturn (struct nft_expr *)&rule->data[0];\n}\n\nstatic inline struct nft_expr *nft_expr_next(const struct nft_expr *expr)\n{\n\treturn ((void *)expr) + expr->ops->size;\n}\n\nstatic inline struct nft_expr *nft_expr_last(const struct nft_rule *rule)\n{\n\treturn (struct nft_expr *)&rule->data[rule->dlen];\n}\n\nstatic inline bool nft_expr_more(const struct nft_rule *rule,\n\t\t\t\t const struct nft_expr *expr)\n{\n\treturn expr != nft_expr_last(rule) && expr->ops;\n}\n\nstatic inline struct nft_userdata *nft_userdata(const struct nft_rule *rule)\n{\n\treturn (void *)&rule->data[rule->dlen];\n}\n\nvoid nft_rule_expr_activate(const struct nft_ctx *ctx, struct nft_rule *rule);\nvoid nft_rule_expr_deactivate(const struct nft_ctx *ctx, struct nft_rule *rule,\n\t\t\t      enum nft_trans_phase phase);\nvoid nf_tables_rule_destroy(const struct nft_ctx *ctx, struct nft_rule *rule);\n\nstatic inline void nft_set_elem_update_expr(const struct nft_set_ext *ext,\n\t\t\t\t\t    struct nft_regs *regs,\n\t\t\t\t\t    const struct nft_pktinfo *pkt)\n{\n\tstruct nft_set_elem_expr *elem_expr;\n\tstruct nft_expr *expr;\n\tu32 size;\n\n\tif (__nft_set_ext_exists(ext, NFT_SET_EXT_EXPRESSIONS)) {\n\t\telem_expr = nft_set_ext_expr(ext);\n\t\tnft_setelem_expr_foreach(expr, elem_expr, size) {\n\t\t\texpr->ops->eval(expr, regs, pkt);\n\t\t\tif (regs->verdict.code == NFT_BREAK)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\n/*\n * The last pointer isn't really necessary, but the compiler isn't able to\n * determine that the result of nft_expr_last() is always the same since it\n * can't assume that the dlen value wasn't changed within calls in the loop.\n */\n#define nft_rule_for_each_expr(expr, last, rule) \\\n\tfor ((expr) = nft_expr_first(rule), (last) = nft_expr_last(rule); \\\n\t     (expr) != (last); \\\n\t     (expr) = nft_expr_next(expr))\n\n#define NFT_CHAIN_POLICY_UNSET\t\tU8_MAX\n\nstruct nft_rule_dp {\n\tu64\t\t\t\tis_last:1,\n\t\t\t\t\tdlen:12,\n\t\t\t\t\thandle:42;\t/* for tracing */\n\tunsigned char\t\t\tdata[]\n\t\t__attribute__((aligned(__alignof__(struct nft_expr))));\n};\n\nstruct nft_rule_dp_last {\n\tstruct nft_rule_dp end;\t\t/* end of nft_rule_blob marker */\n\tstruct rcu_head h;\t\t/* call_rcu head */\n\tstruct nft_rule_blob *blob;\t/* ptr to free via call_rcu */\n\tconst struct nft_chain *chain;\t/* for nftables tracing */\n};\n\nstatic inline const struct nft_rule_dp *nft_rule_next(const struct nft_rule_dp *rule)\n{\n\treturn (void *)rule + sizeof(*rule) + rule->dlen;\n}\n\nstruct nft_rule_blob {\n\tunsigned long\t\t\tsize;\n\tunsigned char\t\t\tdata[]\n\t\t__attribute__((aligned(__alignof__(struct nft_rule_dp))));\n};\n\n/**\n *\tstruct nft_chain - nf_tables chain\n *\n *\t@rules: list of rules in the chain\n *\t@list: used internally\n *\t@rhlhead: used internally\n *\t@table: table that this chain belongs to\n *\t@handle: chain handle\n *\t@use: number of jump references to this chain\n *\t@flags: bitmask of enum nft_chain_flags\n *\t@name: name of the chain\n */\nstruct nft_chain {\n\tstruct nft_rule_blob\t\t__rcu *blob_gen_0;\n\tstruct nft_rule_blob\t\t__rcu *blob_gen_1;\n\tstruct list_head\t\trules;\n\tstruct list_head\t\tlist;\n\tstruct rhlist_head\t\trhlhead;\n\tstruct nft_table\t\t*table;\n\tu64\t\t\t\thandle;\n\tu32\t\t\t\tuse;\n\tu8\t\t\t\tflags:5,\n\t\t\t\t\tbound:1,\n\t\t\t\t\tgenmask:2;\n\tchar\t\t\t\t*name;\n\tu16\t\t\t\tudlen;\n\tu8\t\t\t\t*udata;\n\n\t/* Only used during control plane commit phase: */\n\tstruct nft_rule_blob\t\t*blob_next;\n};\n\nint nft_chain_validate(const struct nft_ctx *ctx, const struct nft_chain *chain);\nint nft_setelem_validate(const struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t const struct nft_set_iter *iter,\n\t\t\t struct nft_elem_priv *elem_priv);\nint nft_set_catchall_validate(const struct nft_ctx *ctx, struct nft_set *set);\nint nf_tables_bind_chain(const struct nft_ctx *ctx, struct nft_chain *chain);\nvoid nf_tables_unbind_chain(const struct nft_ctx *ctx, struct nft_chain *chain);\n\nenum nft_chain_types {\n\tNFT_CHAIN_T_DEFAULT = 0,\n\tNFT_CHAIN_T_ROUTE,\n\tNFT_CHAIN_T_NAT,\n\tNFT_CHAIN_T_MAX\n};\n\n/**\n * \tstruct nft_chain_type - nf_tables chain type info\n *\n * \t@name: name of the type\n * \t@type: numeric identifier\n * \t@family: address family\n * \t@owner: module owner\n * \t@hook_mask: mask of valid hooks\n * \t@hooks: array of hook functions\n *\t@ops_register: base chain register function\n *\t@ops_unregister: base chain unregister function\n */\nstruct nft_chain_type {\n\tconst char\t\t\t*name;\n\tenum nft_chain_types\t\ttype;\n\tint\t\t\t\tfamily;\n\tstruct module\t\t\t*owner;\n\tunsigned int\t\t\thook_mask;\n\tnf_hookfn\t\t\t*hooks[NFT_MAX_HOOKS];\n\tint\t\t\t\t(*ops_register)(struct net *net, const struct nf_hook_ops *ops);\n\tvoid\t\t\t\t(*ops_unregister)(struct net *net, const struct nf_hook_ops *ops);\n};\n\nint nft_chain_validate_dependency(const struct nft_chain *chain,\n\t\t\t\t  enum nft_chain_types type);\nint nft_chain_validate_hooks(const struct nft_chain *chain,\n                             unsigned int hook_flags);\n\nstatic inline bool nft_chain_binding(const struct nft_chain *chain)\n{\n\treturn chain->flags & NFT_CHAIN_BINDING;\n}\n\nstatic inline bool nft_chain_is_bound(struct nft_chain *chain)\n{\n\treturn (chain->flags & NFT_CHAIN_BINDING) && chain->bound;\n}\n\nint nft_chain_add(struct nft_table *table, struct nft_chain *chain);\nvoid nft_chain_del(struct nft_chain *chain);\nvoid nf_tables_chain_destroy(struct nft_ctx *ctx);\n\nstruct nft_stats {\n\tu64\t\t\tbytes;\n\tu64\t\t\tpkts;\n\tstruct u64_stats_sync\tsyncp;\n};\n\nstruct nft_hook {\n\tstruct list_head\tlist;\n\tstruct nf_hook_ops\tops;\n\tstruct rcu_head\t\trcu;\n};\n\n/**\n *\tstruct nft_base_chain - nf_tables base chain\n *\n *\t@ops: netfilter hook ops\n *\t@hook_list: list of netfilter hooks (for NFPROTO_NETDEV family)\n *\t@type: chain type\n *\t@policy: default policy\n *\t@stats: per-cpu chain stats\n *\t@chain: the chain\n *\t@flow_block: flow block (for hardware offload)\n */\nstruct nft_base_chain {\n\tstruct nf_hook_ops\t\tops;\n\tstruct list_head\t\thook_list;\n\tconst struct nft_chain_type\t*type;\n\tu8\t\t\t\tpolicy;\n\tu8\t\t\t\tflags;\n\tstruct nft_stats __percpu\t*stats;\n\tstruct nft_chain\t\tchain;\n\tstruct flow_block\t\tflow_block;\n};\n\nstatic inline struct nft_base_chain *nft_base_chain(const struct nft_chain *chain)\n{\n\treturn container_of(chain, struct nft_base_chain, chain);\n}\n\nstatic inline bool nft_is_base_chain(const struct nft_chain *chain)\n{\n\treturn chain->flags & NFT_CHAIN_BASE;\n}\n\nint __nft_release_basechain(struct nft_ctx *ctx);\n\nunsigned int nft_do_chain(struct nft_pktinfo *pkt, void *priv);\n\nstatic inline bool nft_use_inc(u32 *use)\n{\n\tif (*use == UINT_MAX)\n\t\treturn false;\n\n\t(*use)++;\n\n\treturn true;\n}\n\nstatic inline void nft_use_dec(u32 *use)\n{\n\tWARN_ON_ONCE((*use)-- == 0);\n}\n\n/* For error and abort path: restore use counter to previous state. */\nstatic inline void nft_use_inc_restore(u32 *use)\n{\n\tWARN_ON_ONCE(!nft_use_inc(use));\n}\n\n#define nft_use_dec_restore\tnft_use_dec\n\n/**\n *\tstruct nft_table - nf_tables table\n *\n *\t@list: used internally\n *\t@chains_ht: chains in the table\n *\t@chains: same, for stable walks\n *\t@sets: sets in the table\n *\t@objects: stateful objects in the table\n *\t@flowtables: flow tables in the table\n *\t@hgenerator: handle generator state\n *\t@handle: table handle\n *\t@use: number of chain references to this table\n *\t@family:address family\n *\t@flags: table flag (see enum nft_table_flags)\n *\t@genmask: generation mask\n *\t@nlpid: netlink port ID\n *\t@name: name of the table\n *\t@udlen: length of the user data\n *\t@udata: user data\n *\t@validate_state: internal, set when transaction adds jumps\n */\nstruct nft_table {\n\tstruct list_head\t\tlist;\n\tstruct rhltable\t\t\tchains_ht;\n\tstruct list_head\t\tchains;\n\tstruct list_head\t\tsets;\n\tstruct list_head\t\tobjects;\n\tstruct list_head\t\tflowtables;\n\tu64\t\t\t\thgenerator;\n\tu64\t\t\t\thandle;\n\tu32\t\t\t\tuse;\n\tu16\t\t\t\tfamily:6,\n\t\t\t\t\tflags:8,\n\t\t\t\t\tgenmask:2;\n\tu32\t\t\t\tnlpid;\n\tchar\t\t\t\t*name;\n\tu16\t\t\t\tudlen;\n\tu8\t\t\t\t*udata;\n\tu8\t\t\t\tvalidate_state;\n};\n\nstatic inline bool nft_table_has_owner(const struct nft_table *table)\n{\n\treturn table->flags & NFT_TABLE_F_OWNER;\n}\n\nstatic inline bool nft_base_chain_netdev(int family, u32 hooknum)\n{\n\treturn family == NFPROTO_NETDEV ||\n\t       (family == NFPROTO_INET && hooknum == NF_INET_INGRESS);\n}\n\nvoid nft_register_chain_type(const struct nft_chain_type *);\nvoid nft_unregister_chain_type(const struct nft_chain_type *);\n\nint nft_register_expr(struct nft_expr_type *);\nvoid nft_unregister_expr(struct nft_expr_type *);\n\nint nft_verdict_dump(struct sk_buff *skb, int type,\n\t\t     const struct nft_verdict *v);\n\n/**\n *\tstruct nft_object_hash_key - key to lookup nft_object\n *\n *\t@name: name of the stateful object to look up\n *\t@table: table the object belongs to\n */\nstruct nft_object_hash_key {\n\tconst char                      *name;\n\tconst struct nft_table          *table;\n};\n\n/**\n *\tstruct nft_object - nf_tables stateful object\n *\n *\t@list: table stateful object list node\n *\t@key:  keys that identify this object\n *\t@rhlhead: nft_objname_ht node\n *\t@genmask: generation mask\n *\t@use: number of references to this stateful object\n *\t@handle: unique object handle\n *\t@ops: object operations\n *\t@data: object data, layout depends on type\n */\nstruct nft_object {\n\tstruct list_head\t\tlist;\n\tstruct rhlist_head\t\trhlhead;\n\tstruct nft_object_hash_key\tkey;\n\tu32\t\t\t\tgenmask:2;\n\tu32\t\t\t\tuse;\n\tu64\t\t\t\thandle;\n\tu16\t\t\t\tudlen;\n\tu8\t\t\t\t*udata;\n\t/* runtime data below here */\n\tconst struct nft_object_ops\t*ops ____cacheline_aligned;\n\tunsigned char\t\t\tdata[]\n\t\t__attribute__((aligned(__alignof__(u64))));\n};\n\nstatic inline void *nft_obj_data(const struct nft_object *obj)\n{\n\treturn (void *)obj->data;\n}\n\n#define nft_expr_obj(expr)\t*((struct nft_object **)nft_expr_priv(expr))\n\nstruct nft_object *nft_obj_lookup(const struct net *net,\n\t\t\t\t  const struct nft_table *table,\n\t\t\t\t  const struct nlattr *nla, u32 objtype,\n\t\t\t\t  u8 genmask);\n\nvoid nft_obj_notify(struct net *net, const struct nft_table *table,\n\t\t    struct nft_object *obj, u32 portid, u32 seq,\n\t\t    int event, u16 flags, int family, int report, gfp_t gfp);\n\n/**\n *\tstruct nft_object_type - stateful object type\n *\n *\t@select_ops: function to select nft_object_ops\n *\t@ops: default ops, used when no select_ops functions is present\n *\t@list: list node in list of object types\n *\t@type: stateful object numeric type\n *\t@owner: module owner\n *\t@maxattr: maximum netlink attribute\n *\t@policy: netlink attribute policy\n */\nstruct nft_object_type {\n\tconst struct nft_object_ops\t*(*select_ops)(const struct nft_ctx *,\n\t\t\t\t\t\t       const struct nlattr * const tb[]);\n\tconst struct nft_object_ops\t*ops;\n\tstruct list_head\t\tlist;\n\tu32\t\t\t\ttype;\n\tunsigned int                    maxattr;\n\tstruct module\t\t\t*owner;\n\tconst struct nla_policy\t\t*policy;\n};\n\n/**\n *\tstruct nft_object_ops - stateful object operations\n *\n *\t@eval: stateful object evaluation function\n *\t@size: stateful object size\n *\t@init: initialize object from netlink attributes\n *\t@destroy: release existing stateful object\n *\t@dump: netlink dump stateful object\n *\t@update: update stateful object\n */\nstruct nft_object_ops {\n\tvoid\t\t\t\t(*eval)(struct nft_object *obj,\n\t\t\t\t\t\tstruct nft_regs *regs,\n\t\t\t\t\t\tconst struct nft_pktinfo *pkt);\n\tunsigned int\t\t\tsize;\n\tint\t\t\t\t(*init)(const struct nft_ctx *ctx,\n\t\t\t\t\t\tconst struct nlattr *const tb[],\n\t\t\t\t\t\tstruct nft_object *obj);\n\tvoid\t\t\t\t(*destroy)(const struct nft_ctx *ctx,\n\t\t\t\t\t\t   struct nft_object *obj);\n\tint\t\t\t\t(*dump)(struct sk_buff *skb,\n\t\t\t\t\t\tstruct nft_object *obj,\n\t\t\t\t\t\tbool reset);\n\tvoid\t\t\t\t(*update)(struct nft_object *obj,\n\t\t\t\t\t\t  struct nft_object *newobj);\n\tconst struct nft_object_type\t*type;\n};\n\nint nft_register_obj(struct nft_object_type *obj_type);\nvoid nft_unregister_obj(struct nft_object_type *obj_type);\n\n#define NFT_NETDEVICE_MAX\t256\n\n/**\n *\tstruct nft_flowtable - nf_tables flow table\n *\n *\t@list: flow table list node in table list\n * \t@table: the table the flow table is contained in\n *\t@name: name of this flow table\n *\t@hooknum: hook number\n *\t@ops_len: number of hooks in array\n *\t@genmask: generation mask\n *\t@use: number of references to this flow table\n * \t@handle: unique object handle\n *\t@dev_name: array of device names\n *\t@data: rhashtable and garbage collector\n * \t@ops: array of hooks\n */\nstruct nft_flowtable {\n\tstruct list_head\t\tlist;\n\tstruct nft_table\t\t*table;\n\tchar\t\t\t\t*name;\n\tint\t\t\t\thooknum;\n\tint\t\t\t\tops_len;\n\tu32\t\t\t\tgenmask:2;\n\tu32\t\t\t\tuse;\n\tu64\t\t\t\thandle;\n\t/* runtime data below here */\n\tstruct list_head\t\thook_list ____cacheline_aligned;\n\tstruct nf_flowtable\t\tdata;\n};\n\nstruct nft_flowtable *nft_flowtable_lookup(const struct nft_table *table,\n\t\t\t\t\t   const struct nlattr *nla,\n\t\t\t\t\t   u8 genmask);\n\nvoid nf_tables_deactivate_flowtable(const struct nft_ctx *ctx,\n\t\t\t\t    struct nft_flowtable *flowtable,\n\t\t\t\t    enum nft_trans_phase phase);\n\nvoid nft_register_flowtable_type(struct nf_flowtable_type *type);\nvoid nft_unregister_flowtable_type(struct nf_flowtable_type *type);\n\n/**\n *\tstruct nft_traceinfo - nft tracing information and state\n *\n *\t@trace: other struct members are initialised\n *\t@nf_trace: copy of skb->nf_trace before rule evaluation\n *\t@type: event type (enum nft_trace_types)\n *\t@skbid: hash of skb to be used as trace id\n *\t@packet_dumped: packet headers sent in a previous traceinfo message\n *\t@basechain: base chain currently processed\n */\nstruct nft_traceinfo {\n\tbool\t\t\t\ttrace;\n\tbool\t\t\t\tnf_trace;\n\tbool\t\t\t\tpacket_dumped;\n\tenum nft_trace_types\t\ttype:8;\n\tu32\t\t\t\tskbid;\n\tconst struct nft_base_chain\t*basechain;\n};\n\nvoid nft_trace_init(struct nft_traceinfo *info, const struct nft_pktinfo *pkt,\n\t\t    const struct nft_chain *basechain);\n\nvoid nft_trace_notify(const struct nft_pktinfo *pkt,\n\t\t      const struct nft_verdict *verdict,\n\t\t      const struct nft_rule_dp *rule,\n\t\t      struct nft_traceinfo *info);\n\n#define MODULE_ALIAS_NFT_CHAIN(family, name) \\\n\tMODULE_ALIAS(\"nft-chain-\" __stringify(family) \"-\" name)\n\n#define MODULE_ALIAS_NFT_AF_EXPR(family, name) \\\n\tMODULE_ALIAS(\"nft-expr-\" __stringify(family) \"-\" name)\n\n#define MODULE_ALIAS_NFT_EXPR(name) \\\n\tMODULE_ALIAS(\"nft-expr-\" name)\n\n#define MODULE_ALIAS_NFT_OBJ(type) \\\n\tMODULE_ALIAS(\"nft-obj-\" __stringify(type))\n\n#if IS_ENABLED(CONFIG_NF_TABLES)\n\n/*\n * The gencursor defines two generations, the currently active and the\n * next one. Objects contain a bitmask of 2 bits specifying the generations\n * they're active in. A set bit means they're inactive in the generation\n * represented by that bit.\n *\n * New objects start out as inactive in the current and active in the\n * next generation. When committing the ruleset the bitmask is cleared,\n * meaning they're active in all generations. When removing an object,\n * it is set inactive in the next generation. After committing the ruleset,\n * the objects are removed.\n */\nstatic inline unsigned int nft_gencursor_next(const struct net *net)\n{\n\treturn net->nft.gencursor + 1 == 1 ? 1 : 0;\n}\n\nstatic inline u8 nft_genmask_next(const struct net *net)\n{\n\treturn 1 << nft_gencursor_next(net);\n}\n\nstatic inline u8 nft_genmask_cur(const struct net *net)\n{\n\t/* Use READ_ONCE() to prevent refetching the value for atomicity */\n\treturn 1 << READ_ONCE(net->nft.gencursor);\n}\n\n#define NFT_GENMASK_ANY\t\t((1 << 0) | (1 << 1))\n\n/*\n * Generic transaction helpers\n */\n\n/* Check if this object is currently active. */\n#define nft_is_active(__net, __obj)\t\t\t\t\\\n\t(((__obj)->genmask & nft_genmask_cur(__net)) == 0)\n\n/* Check if this object is active in the next generation. */\n#define nft_is_active_next(__net, __obj)\t\t\t\\\n\t(((__obj)->genmask & nft_genmask_next(__net)) == 0)\n\n/* This object becomes active in the next generation. */\n#define nft_activate_next(__net, __obj)\t\t\t\t\\\n\t(__obj)->genmask = nft_genmask_cur(__net)\n\n/* This object becomes inactive in the next generation. */\n#define nft_deactivate_next(__net, __obj)\t\t\t\\\n        (__obj)->genmask = nft_genmask_next(__net)\n\n/* After committing the ruleset, clear the stale generation bit. */\n#define nft_clear(__net, __obj)\t\t\t\t\t\\\n\t(__obj)->genmask &= ~nft_genmask_next(__net)\n#define nft_active_genmask(__obj, __genmask)\t\t\t\\\n\t!((__obj)->genmask & __genmask)\n\n/*\n * Set element transaction helpers\n */\n\nstatic inline bool nft_set_elem_active(const struct nft_set_ext *ext,\n\t\t\t\t       u8 genmask)\n{\n\treturn !(ext->genmask & genmask);\n}\n\nstatic inline void nft_set_elem_change_active(const struct net *net,\n\t\t\t\t\t      const struct nft_set *set,\n\t\t\t\t\t      struct nft_set_ext *ext)\n{\n\text->genmask ^= nft_genmask_next(net);\n}\n\n#endif /* IS_ENABLED(CONFIG_NF_TABLES) */\n\n#define NFT_SET_ELEM_DEAD_MASK\t(1 << 2)\n\n#if defined(__LITTLE_ENDIAN_BITFIELD)\n#define NFT_SET_ELEM_DEAD_BIT\t2\n#elif defined(__BIG_ENDIAN_BITFIELD)\n#define NFT_SET_ELEM_DEAD_BIT\t(BITS_PER_LONG - BITS_PER_BYTE + 2)\n#else\n#error\n#endif\n\nstatic inline void nft_set_elem_dead(struct nft_set_ext *ext)\n{\n\tunsigned long *word = (unsigned long *)ext;\n\n\tBUILD_BUG_ON(offsetof(struct nft_set_ext, genmask) != 0);\n\tset_bit(NFT_SET_ELEM_DEAD_BIT, word);\n}\n\nstatic inline int nft_set_elem_is_dead(const struct nft_set_ext *ext)\n{\n\tunsigned long *word = (unsigned long *)ext;\n\n\tBUILD_BUG_ON(offsetof(struct nft_set_ext, genmask) != 0);\n\treturn test_bit(NFT_SET_ELEM_DEAD_BIT, word);\n}\n\n/**\n *\tstruct nft_trans - nf_tables object update in transaction\n *\n *\t@list: used internally\n *\t@binding_list: list of objects with possible bindings\n *\t@msg_type: message type\n *\t@put_net: ctx->net needs to be put\n *\t@ctx: transaction context\n *\t@data: internal information related to the transaction\n */\nstruct nft_trans {\n\tstruct list_head\t\tlist;\n\tstruct list_head\t\tbinding_list;\n\tint\t\t\t\tmsg_type;\n\tbool\t\t\t\tput_net;\n\tstruct nft_ctx\t\t\tctx;\n\tchar\t\t\t\tdata[];\n};\n\nstruct nft_trans_rule {\n\tstruct nft_rule\t\t\t*rule;\n\tstruct nft_flow_rule\t\t*flow;\n\tu32\t\t\t\trule_id;\n\tbool\t\t\t\tbound;\n};\n\n#define nft_trans_rule(trans)\t\\\n\t(((struct nft_trans_rule *)trans->data)->rule)\n#define nft_trans_flow_rule(trans)\t\\\n\t(((struct nft_trans_rule *)trans->data)->flow)\n#define nft_trans_rule_id(trans)\t\\\n\t(((struct nft_trans_rule *)trans->data)->rule_id)\n#define nft_trans_rule_bound(trans)\t\\\n\t(((struct nft_trans_rule *)trans->data)->bound)\n\nstruct nft_trans_set {\n\tstruct nft_set\t\t\t*set;\n\tu32\t\t\t\tset_id;\n\tu32\t\t\t\tgc_int;\n\tu64\t\t\t\ttimeout;\n\tbool\t\t\t\tupdate;\n\tbool\t\t\t\tbound;\n\tu32\t\t\t\tsize;\n};\n\n#define nft_trans_set(trans)\t\\\n\t(((struct nft_trans_set *)trans->data)->set)\n#define nft_trans_set_id(trans)\t\\\n\t(((struct nft_trans_set *)trans->data)->set_id)\n#define nft_trans_set_bound(trans)\t\\\n\t(((struct nft_trans_set *)trans->data)->bound)\n#define nft_trans_set_update(trans)\t\\\n\t(((struct nft_trans_set *)trans->data)->update)\n#define nft_trans_set_timeout(trans)\t\\\n\t(((struct nft_trans_set *)trans->data)->timeout)\n#define nft_trans_set_gc_int(trans)\t\\\n\t(((struct nft_trans_set *)trans->data)->gc_int)\n#define nft_trans_set_size(trans)\t\\\n\t(((struct nft_trans_set *)trans->data)->size)\n\nstruct nft_trans_chain {\n\tstruct nft_chain\t\t*chain;\n\tbool\t\t\t\tupdate;\n\tchar\t\t\t\t*name;\n\tstruct nft_stats __percpu\t*stats;\n\tu8\t\t\t\tpolicy;\n\tbool\t\t\t\tbound;\n\tu32\t\t\t\tchain_id;\n\tstruct nft_base_chain\t\t*basechain;\n\tstruct list_head\t\thook_list;\n};\n\n#define nft_trans_chain(trans)\t\\\n\t(((struct nft_trans_chain *)trans->data)->chain)\n#define nft_trans_chain_update(trans)\t\\\n\t(((struct nft_trans_chain *)trans->data)->update)\n#define nft_trans_chain_name(trans)\t\\\n\t(((struct nft_trans_chain *)trans->data)->name)\n#define nft_trans_chain_stats(trans)\t\\\n\t(((struct nft_trans_chain *)trans->data)->stats)\n#define nft_trans_chain_policy(trans)\t\\\n\t(((struct nft_trans_chain *)trans->data)->policy)\n#define nft_trans_chain_bound(trans)\t\\\n\t(((struct nft_trans_chain *)trans->data)->bound)\n#define nft_trans_chain_id(trans)\t\\\n\t(((struct nft_trans_chain *)trans->data)->chain_id)\n#define nft_trans_basechain(trans)\t\\\n\t(((struct nft_trans_chain *)trans->data)->basechain)\n#define nft_trans_chain_hooks(trans)\t\\\n\t(((struct nft_trans_chain *)trans->data)->hook_list)\n\nstruct nft_trans_table {\n\tbool\t\t\t\tupdate;\n};\n\n#define nft_trans_table_update(trans)\t\\\n\t(((struct nft_trans_table *)trans->data)->update)\n\nstruct nft_trans_elem {\n\tstruct nft_set\t\t\t*set;\n\tstruct nft_elem_priv\t\t*elem_priv;\n\tbool\t\t\t\tbound;\n};\n\n#define nft_trans_elem_set(trans)\t\\\n\t(((struct nft_trans_elem *)trans->data)->set)\n#define nft_trans_elem_priv(trans)\t\\\n\t(((struct nft_trans_elem *)trans->data)->elem_priv)\n#define nft_trans_elem_set_bound(trans)\t\\\n\t(((struct nft_trans_elem *)trans->data)->bound)\n\nstruct nft_trans_obj {\n\tstruct nft_object\t\t*obj;\n\tstruct nft_object\t\t*newobj;\n\tbool\t\t\t\tupdate;\n};\n\n#define nft_trans_obj(trans)\t\\\n\t(((struct nft_trans_obj *)trans->data)->obj)\n#define nft_trans_obj_newobj(trans) \\\n\t(((struct nft_trans_obj *)trans->data)->newobj)\n#define nft_trans_obj_update(trans)\t\\\n\t(((struct nft_trans_obj *)trans->data)->update)\n\nstruct nft_trans_flowtable {\n\tstruct nft_flowtable\t\t*flowtable;\n\tbool\t\t\t\tupdate;\n\tstruct list_head\t\thook_list;\n\tu32\t\t\t\tflags;\n};\n\n#define nft_trans_flowtable(trans)\t\\\n\t(((struct nft_trans_flowtable *)trans->data)->flowtable)\n#define nft_trans_flowtable_update(trans)\t\\\n\t(((struct nft_trans_flowtable *)trans->data)->update)\n#define nft_trans_flowtable_hooks(trans)\t\\\n\t(((struct nft_trans_flowtable *)trans->data)->hook_list)\n#define nft_trans_flowtable_flags(trans)\t\\\n\t(((struct nft_trans_flowtable *)trans->data)->flags)\n\n#define NFT_TRANS_GC_BATCHCOUNT\t256\n\nstruct nft_trans_gc {\n\tstruct list_head\tlist;\n\tstruct net\t\t*net;\n\tstruct nft_set\t\t*set;\n\tu32\t\t\tseq;\n\tu16\t\t\tcount;\n\tstruct nft_elem_priv\t*priv[NFT_TRANS_GC_BATCHCOUNT];\n\tstruct rcu_head\t\trcu;\n};\n\nstruct nft_trans_gc *nft_trans_gc_alloc(struct nft_set *set,\n\t\t\t\t\tunsigned int gc_seq, gfp_t gfp);\nvoid nft_trans_gc_destroy(struct nft_trans_gc *trans);\n\nstruct nft_trans_gc *nft_trans_gc_queue_async(struct nft_trans_gc *gc,\n\t\t\t\t\t      unsigned int gc_seq, gfp_t gfp);\nvoid nft_trans_gc_queue_async_done(struct nft_trans_gc *gc);\n\nstruct nft_trans_gc *nft_trans_gc_queue_sync(struct nft_trans_gc *gc, gfp_t gfp);\nvoid nft_trans_gc_queue_sync_done(struct nft_trans_gc *trans);\n\nvoid nft_trans_gc_elem_add(struct nft_trans_gc *gc, void *priv);\n\nstruct nft_trans_gc *nft_trans_gc_catchall_async(struct nft_trans_gc *gc,\n\t\t\t\t\t\t unsigned int gc_seq);\nstruct nft_trans_gc *nft_trans_gc_catchall_sync(struct nft_trans_gc *gc);\n\nvoid nft_setelem_data_deactivate(const struct net *net,\n\t\t\t\t const struct nft_set *set,\n\t\t\t\t struct nft_elem_priv *elem_priv);\n\nint __init nft_chain_filter_init(void);\nvoid nft_chain_filter_fini(void);\n\nvoid __init nft_chain_route_init(void);\nvoid nft_chain_route_fini(void);\n\nvoid nf_tables_trans_destroy_flush_work(void);\n\nint nf_msecs_to_jiffies64(const struct nlattr *nla, u64 *result);\n__be64 nf_jiffies64_to_msecs(u64 input);\n\n#ifdef CONFIG_MODULES\n__printf(2, 3) int nft_request_module(struct net *net, const char *fmt, ...);\n#else\nstatic inline int nft_request_module(struct net *net, const char *fmt, ...) { return -ENOENT; }\n#endif\n\nstruct nftables_pernet {\n\tstruct list_head\ttables;\n\tstruct list_head\tcommit_list;\n\tstruct list_head\tbinding_list;\n\tstruct list_head\tmodule_list;\n\tstruct list_head\tnotify_list;\n\tstruct mutex\t\tcommit_mutex;\n\tu64\t\t\ttable_handle;\n\tunsigned int\t\tbase_seq;\n\tunsigned int\t\tgc_seq;\n\tu8\t\t\tvalidate_state;\n};\n\nextern unsigned int nf_tables_net_id;\n\nstatic inline struct nftables_pernet *nft_pernet(const struct net *net)\n{\n\treturn net_generic(net, nf_tables_net_id);\n}\n\n#define __NFT_REDUCE_READONLY\t1UL\n#define NFT_REDUCE_READONLY\t(void *)__NFT_REDUCE_READONLY\n\nstatic inline bool nft_reduce_is_readonly(const struct nft_expr *expr)\n{\n\treturn expr->ops->reduce == NFT_REDUCE_READONLY;\n}\n\nvoid nft_reg_track_update(struct nft_regs_track *track,\n\t\t\t  const struct nft_expr *expr, u8 dreg, u8 len);\nvoid nft_reg_track_cancel(struct nft_regs_track *track, u8 dreg, u8 len);\nvoid __nft_reg_track_cancel(struct nft_regs_track *track, u8 dreg);\n\nstatic inline bool nft_reg_track_cmp(struct nft_regs_track *track,\n\t\t\t\t     const struct nft_expr *expr, u8 dreg)\n{\n\treturn track->regs[dreg].selector &&\n\t       track->regs[dreg].selector->ops == expr->ops &&\n\t       track->regs[dreg].num_reg == 0;\n}\n\n#endif /* _NET_NF_TABLES_H */\n", "// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Copyright (c) 2008-2009 Patrick McHardy <kaber@trash.net>\n *\n * Development of this code funded by Astaro AG (http://www.astaro.com/)\n */\n\n#include <asm/unaligned.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_core.h>\n#include <net/netfilter/nf_tables.h>\n\nstruct nft_byteorder {\n\tu8\t\t\tsreg;\n\tu8\t\t\tdreg;\n\tenum nft_byteorder_ops\top:8;\n\tu8\t\t\tlen;\n\tu8\t\t\tsize;\n};\n\nvoid nft_byteorder_eval(const struct nft_expr *expr,\n\t\t\tstruct nft_regs *regs,\n\t\t\tconst struct nft_pktinfo *pkt)\n{\n\tconst struct nft_byteorder *priv = nft_expr_priv(expr);\n\tu32 *src = &regs->data[priv->sreg];\n\tu32 *dst = &regs->data[priv->dreg];\n\tu16 *s16, *d16;\n\tunsigned int i;\n\n\ts16 = (void *)src;\n\td16 = (void *)dst;\n\n\tswitch (priv->size) {\n\tcase 8: {\n\t\tu64 src64;\n\n\t\tswitch (priv->op) {\n\t\tcase NFT_BYTEORDER_NTOH:\n\t\t\tfor (i = 0; i < priv->len / 8; i++) {\n\t\t\t\tsrc64 = nft_reg_load64(&src[i]);\n\t\t\t\tnft_reg_store64(&dst[i],\n\t\t\t\t\t\tbe64_to_cpu((__force __be64)src64));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NFT_BYTEORDER_HTON:\n\t\t\tfor (i = 0; i < priv->len / 8; i++) {\n\t\t\t\tsrc64 = (__force __u64)\n\t\t\t\t\tcpu_to_be64(nft_reg_load64(&src[i]));\n\t\t\t\tnft_reg_store64(&dst[i], src64);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase 4:\n\t\tswitch (priv->op) {\n\t\tcase NFT_BYTEORDER_NTOH:\n\t\t\tfor (i = 0; i < priv->len / 4; i++)\n\t\t\t\tdst[i] = ntohl((__force __be32)src[i]);\n\t\t\tbreak;\n\t\tcase NFT_BYTEORDER_HTON:\n\t\t\tfor (i = 0; i < priv->len / 4; i++)\n\t\t\t\tdst[i] = (__force __u32)htonl(src[i]);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tswitch (priv->op) {\n\t\tcase NFT_BYTEORDER_NTOH:\n\t\t\tfor (i = 0; i < priv->len / 2; i++)\n\t\t\t\td16[i] = ntohs((__force __be16)s16[i]);\n\t\t\tbreak;\n\t\tcase NFT_BYTEORDER_HTON:\n\t\t\tfor (i = 0; i < priv->len / 2; i++)\n\t\t\t\td16[i] = (__force __u16)htons(s16[i]);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic const struct nla_policy nft_byteorder_policy[NFTA_BYTEORDER_MAX + 1] = {\n\t[NFTA_BYTEORDER_SREG]\t= { .type = NLA_U32 },\n\t[NFTA_BYTEORDER_DREG]\t= { .type = NLA_U32 },\n\t[NFTA_BYTEORDER_OP]\t= NLA_POLICY_MAX(NLA_BE32, 255),\n\t[NFTA_BYTEORDER_LEN]\t= NLA_POLICY_MAX(NLA_BE32, 255),\n\t[NFTA_BYTEORDER_SIZE]\t= NLA_POLICY_MAX(NLA_BE32, 255),\n};\n\nstatic int nft_byteorder_init(const struct nft_ctx *ctx,\n\t\t\t      const struct nft_expr *expr,\n\t\t\t      const struct nlattr * const tb[])\n{\n\tstruct nft_byteorder *priv = nft_expr_priv(expr);\n\tu32 size, len;\n\tint err;\n\n\tif (tb[NFTA_BYTEORDER_SREG] == NULL ||\n\t    tb[NFTA_BYTEORDER_DREG] == NULL ||\n\t    tb[NFTA_BYTEORDER_LEN] == NULL ||\n\t    tb[NFTA_BYTEORDER_SIZE] == NULL ||\n\t    tb[NFTA_BYTEORDER_OP] == NULL)\n\t\treturn -EINVAL;\n\n\tpriv->op = ntohl(nla_get_be32(tb[NFTA_BYTEORDER_OP]));\n\tswitch (priv->op) {\n\tcase NFT_BYTEORDER_NTOH:\n\tcase NFT_BYTEORDER_HTON:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\terr = nft_parse_u32_check(tb[NFTA_BYTEORDER_SIZE], U8_MAX, &size);\n\tif (err < 0)\n\t\treturn err;\n\n\tpriv->size = size;\n\n\tswitch (priv->size) {\n\tcase 2:\n\tcase 4:\n\tcase 8:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\terr = nft_parse_u32_check(tb[NFTA_BYTEORDER_LEN], U8_MAX, &len);\n\tif (err < 0)\n\t\treturn err;\n\n\tpriv->len = len;\n\n\terr = nft_parse_register_load(tb[NFTA_BYTEORDER_SREG], &priv->sreg,\n\t\t\t\t      priv->len);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn nft_parse_register_store(ctx, tb[NFTA_BYTEORDER_DREG],\n\t\t\t\t\t&priv->dreg, NULL, NFT_DATA_VALUE,\n\t\t\t\t\tpriv->len);\n}\n\nstatic int nft_byteorder_dump(struct sk_buff *skb,\n\t\t\t      const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_byteorder *priv = nft_expr_priv(expr);\n\n\tif (nft_dump_register(skb, NFTA_BYTEORDER_SREG, priv->sreg))\n\t\tgoto nla_put_failure;\n\tif (nft_dump_register(skb, NFTA_BYTEORDER_DREG, priv->dreg))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_BYTEORDER_OP, htonl(priv->op)))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_BYTEORDER_LEN, htonl(priv->len)))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_BYTEORDER_SIZE, htonl(priv->size)))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic bool nft_byteorder_reduce(struct nft_regs_track *track,\n\t\t\t\t const struct nft_expr *expr)\n{\n\tstruct nft_byteorder *priv = nft_expr_priv(expr);\n\n\tnft_reg_track_cancel(track, priv->dreg, priv->len);\n\n\treturn false;\n}\n\nstatic const struct nft_expr_ops nft_byteorder_ops = {\n\t.type\t\t= &nft_byteorder_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_byteorder)),\n\t.eval\t\t= nft_byteorder_eval,\n\t.init\t\t= nft_byteorder_init,\n\t.dump\t\t= nft_byteorder_dump,\n\t.reduce\t\t= nft_byteorder_reduce,\n};\n\nstruct nft_expr_type nft_byteorder_type __read_mostly = {\n\t.name\t\t= \"byteorder\",\n\t.ops\t\t= &nft_byteorder_ops,\n\t.policy\t\t= nft_byteorder_policy,\n\t.maxattr\t= NFTA_BYTEORDER_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n", "// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Copyright (c) 2008-2009 Patrick McHardy <kaber@trash.net>\n * Copyright (c) 2014 Intel Corporation\n * Author: Tomasz Bursztyka <tomasz.bursztyka@linux.intel.com>\n *\n * Development of this code funded by Astaro AG (http://www.astaro.com/)\n */\n\n#include <linux/kernel.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/random.h>\n#include <linux/smp.h>\n#include <linux/static_key.h>\n#include <net/dst.h>\n#include <net/ip.h>\n#include <net/sock.h>\n#include <net/tcp_states.h> /* for TCP_TIME_WAIT */\n#include <net/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_core.h>\n#include <net/netfilter/nft_meta.h>\n#include <net/netfilter/nf_tables_offload.h>\n\n#include <uapi/linux/netfilter_bridge.h> /* NF_BR_PRE_ROUTING */\n\n#define NFT_META_SECS_PER_MINUTE\t60\n#define NFT_META_SECS_PER_HOUR\t\t3600\n#define NFT_META_SECS_PER_DAY\t\t86400\n#define NFT_META_DAYS_PER_WEEK\t\t7\n\nstatic u8 nft_meta_weekday(void)\n{\n\ttime64_t secs = ktime_get_real_seconds();\n\tunsigned int dse;\n\tu8 wday;\n\n\tsecs -= NFT_META_SECS_PER_MINUTE * sys_tz.tz_minuteswest;\n\tdse = div_u64(secs, NFT_META_SECS_PER_DAY);\n\twday = (4 + dse) % NFT_META_DAYS_PER_WEEK;\n\n\treturn wday;\n}\n\nstatic u32 nft_meta_hour(time64_t secs)\n{\n\tstruct tm tm;\n\n\ttime64_to_tm(secs, 0, &tm);\n\n\treturn tm.tm_hour * NFT_META_SECS_PER_HOUR\n\t\t+ tm.tm_min * NFT_META_SECS_PER_MINUTE\n\t\t+ tm.tm_sec;\n}\n\nstatic noinline_for_stack void\nnft_meta_get_eval_time(enum nft_meta_keys key,\n\t\t       u32 *dest)\n{\n\tswitch (key) {\n\tcase NFT_META_TIME_NS:\n\t\tnft_reg_store64(dest, ktime_get_real_ns());\n\t\tbreak;\n\tcase NFT_META_TIME_DAY:\n\t\tnft_reg_store8(dest, nft_meta_weekday());\n\t\tbreak;\n\tcase NFT_META_TIME_HOUR:\n\t\t*dest = nft_meta_hour(ktime_get_real_seconds());\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic noinline bool\nnft_meta_get_eval_pkttype_lo(const struct nft_pktinfo *pkt,\n\t\t\t     u32 *dest)\n{\n\tconst struct sk_buff *skb = pkt->skb;\n\n\tswitch (nft_pf(pkt)) {\n\tcase NFPROTO_IPV4:\n\t\tif (ipv4_is_multicast(ip_hdr(skb)->daddr))\n\t\t\tnft_reg_store8(dest, PACKET_MULTICAST);\n\t\telse\n\t\t\tnft_reg_store8(dest, PACKET_BROADCAST);\n\t\tbreak;\n\tcase NFPROTO_IPV6:\n\t\tnft_reg_store8(dest, PACKET_MULTICAST);\n\t\tbreak;\n\tcase NFPROTO_NETDEV:\n\t\tswitch (skb->protocol) {\n\t\tcase htons(ETH_P_IP): {\n\t\t\tint noff = skb_network_offset(skb);\n\t\t\tstruct iphdr *iph, _iph;\n\n\t\t\tiph = skb_header_pointer(skb, noff,\n\t\t\t\t\t\t sizeof(_iph), &_iph);\n\t\t\tif (!iph)\n\t\t\t\treturn false;\n\n\t\t\tif (ipv4_is_multicast(iph->daddr))\n\t\t\t\tnft_reg_store8(dest, PACKET_MULTICAST);\n\t\t\telse\n\t\t\t\tnft_reg_store8(dest, PACKET_BROADCAST);\n\n\t\t\tbreak;\n\t\t}\n\t\tcase htons(ETH_P_IPV6):\n\t\t\tnft_reg_store8(dest, PACKET_MULTICAST);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON_ONCE(1);\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic noinline bool\nnft_meta_get_eval_skugid(enum nft_meta_keys key,\n\t\t\t u32 *dest,\n\t\t\t const struct nft_pktinfo *pkt)\n{\n\tstruct sock *sk = skb_to_full_sk(pkt->skb);\n\tstruct socket *sock;\n\n\tif (!sk || !sk_fullsock(sk) || !net_eq(nft_net(pkt), sock_net(sk)))\n\t\treturn false;\n\n\tread_lock_bh(&sk->sk_callback_lock);\n\tsock = sk->sk_socket;\n\tif (!sock || !sock->file) {\n\t\tread_unlock_bh(&sk->sk_callback_lock);\n\t\treturn false;\n\t}\n\n\tswitch (key) {\n\tcase NFT_META_SKUID:\n\t\t*dest = from_kuid_munged(sock_net(sk)->user_ns,\n\t\t\t\t\t sock->file->f_cred->fsuid);\n\t\tbreak;\n\tcase NFT_META_SKGID:\n\t\t*dest =\tfrom_kgid_munged(sock_net(sk)->user_ns,\n\t\t\t\t\t sock->file->f_cred->fsgid);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tread_unlock_bh(&sk->sk_callback_lock);\n\treturn true;\n}\n\n#ifdef CONFIG_CGROUP_NET_CLASSID\nstatic noinline bool\nnft_meta_get_eval_cgroup(u32 *dest, const struct nft_pktinfo *pkt)\n{\n\tstruct sock *sk = skb_to_full_sk(pkt->skb);\n\n\tif (!sk || !sk_fullsock(sk) || !net_eq(nft_net(pkt), sock_net(sk)))\n\t\treturn false;\n\n\t*dest = sock_cgroup_classid(&sk->sk_cgrp_data);\n\treturn true;\n}\n#endif\n\nstatic noinline bool nft_meta_get_eval_kind(enum nft_meta_keys key,\n\t\t\t\t\t    u32 *dest,\n\t\t\t\t\t    const struct nft_pktinfo *pkt)\n{\n\tconst struct net_device *in = nft_in(pkt), *out = nft_out(pkt);\n\n\tswitch (key) {\n\tcase NFT_META_IIFKIND:\n\t\tif (!in || !in->rtnl_link_ops)\n\t\t\treturn false;\n\t\tstrscpy_pad((char *)dest, in->rtnl_link_ops->kind, IFNAMSIZ);\n\t\tbreak;\n\tcase NFT_META_OIFKIND:\n\t\tif (!out || !out->rtnl_link_ops)\n\t\t\treturn false;\n\t\tstrscpy_pad((char *)dest, out->rtnl_link_ops->kind, IFNAMSIZ);\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void nft_meta_store_ifindex(u32 *dest, const struct net_device *dev)\n{\n\t*dest = dev ? dev->ifindex : 0;\n}\n\nstatic void nft_meta_store_ifname(u32 *dest, const struct net_device *dev)\n{\n\tstrscpy_pad((char *)dest, dev ? dev->name : \"\", IFNAMSIZ);\n}\n\nstatic bool nft_meta_store_iftype(u32 *dest, const struct net_device *dev)\n{\n\tif (!dev)\n\t\treturn false;\n\n\tnft_reg_store16(dest, dev->type);\n\treturn true;\n}\n\nstatic bool nft_meta_store_ifgroup(u32 *dest, const struct net_device *dev)\n{\n\tif (!dev)\n\t\treturn false;\n\n\t*dest = dev->group;\n\treturn true;\n}\n\nstatic bool nft_meta_get_eval_ifname(enum nft_meta_keys key, u32 *dest,\n\t\t\t\t     const struct nft_pktinfo *pkt)\n{\n\tswitch (key) {\n\tcase NFT_META_IIFNAME:\n\t\tnft_meta_store_ifname(dest, nft_in(pkt));\n\t\tbreak;\n\tcase NFT_META_OIFNAME:\n\t\tnft_meta_store_ifname(dest, nft_out(pkt));\n\t\tbreak;\n\tcase NFT_META_IIF:\n\t\tnft_meta_store_ifindex(dest, nft_in(pkt));\n\t\tbreak;\n\tcase NFT_META_OIF:\n\t\tnft_meta_store_ifindex(dest, nft_out(pkt));\n\t\tbreak;\n\tcase NFT_META_IFTYPE:\n\t\tif (!nft_meta_store_iftype(dest, pkt->skb->dev))\n\t\t\treturn false;\n\t\tbreak;\n\tcase __NFT_META_IIFTYPE:\n\t\tif (!nft_meta_store_iftype(dest, nft_in(pkt)))\n\t\t\treturn false;\n\t\tbreak;\n\tcase NFT_META_OIFTYPE:\n\t\tif (!nft_meta_store_iftype(dest, nft_out(pkt)))\n\t\t\treturn false;\n\t\tbreak;\n\tcase NFT_META_IIFGROUP:\n\t\tif (!nft_meta_store_ifgroup(dest, nft_in(pkt)))\n\t\t\treturn false;\n\t\tbreak;\n\tcase NFT_META_OIFGROUP:\n\t\tif (!nft_meta_store_ifgroup(dest, nft_out(pkt)))\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n#ifdef CONFIG_IP_ROUTE_CLASSID\nstatic noinline bool\nnft_meta_get_eval_rtclassid(const struct sk_buff *skb, u32 *dest)\n{\n\tconst struct dst_entry *dst = skb_dst(skb);\n\n\tif (!dst)\n\t\treturn false;\n\n\t*dest = dst->tclassid;\n\treturn true;\n}\n#endif\n\nstatic noinline u32 nft_meta_get_eval_sdif(const struct nft_pktinfo *pkt)\n{\n\tswitch (nft_pf(pkt)) {\n\tcase NFPROTO_IPV4:\n\t\treturn inet_sdif(pkt->skb);\n\tcase NFPROTO_IPV6:\n\t\treturn inet6_sdif(pkt->skb);\n\t}\n\n\treturn 0;\n}\n\nstatic noinline void\nnft_meta_get_eval_sdifname(u32 *dest, const struct nft_pktinfo *pkt)\n{\n\tu32 sdif = nft_meta_get_eval_sdif(pkt);\n\tconst struct net_device *dev;\n\n\tdev = sdif ? dev_get_by_index_rcu(nft_net(pkt), sdif) : NULL;\n\tnft_meta_store_ifname(dest, dev);\n}\n\nvoid nft_meta_get_eval(const struct nft_expr *expr,\n\t\t       struct nft_regs *regs,\n\t\t       const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_meta *priv = nft_expr_priv(expr);\n\tconst struct sk_buff *skb = pkt->skb;\n\tu32 *dest = &regs->data[priv->dreg];\n\n\tswitch (priv->key) {\n\tcase NFT_META_LEN:\n\t\t*dest = skb->len;\n\t\tbreak;\n\tcase NFT_META_PROTOCOL:\n\t\tnft_reg_store16(dest, (__force u16)skb->protocol);\n\t\tbreak;\n\tcase NFT_META_NFPROTO:\n\t\tnft_reg_store8(dest, nft_pf(pkt));\n\t\tbreak;\n\tcase NFT_META_L4PROTO:\n\t\tif (!(pkt->flags & NFT_PKTINFO_L4PROTO))\n\t\t\tgoto err;\n\t\tnft_reg_store8(dest, pkt->tprot);\n\t\tbreak;\n\tcase NFT_META_PRIORITY:\n\t\t*dest = skb->priority;\n\t\tbreak;\n\tcase NFT_META_MARK:\n\t\t*dest = skb->mark;\n\t\tbreak;\n\tcase NFT_META_IIF:\n\tcase NFT_META_OIF:\n\tcase NFT_META_IIFNAME:\n\tcase NFT_META_OIFNAME:\n\tcase NFT_META_IIFTYPE:\n\tcase NFT_META_OIFTYPE:\n\tcase NFT_META_IIFGROUP:\n\tcase NFT_META_OIFGROUP:\n\t\tif (!nft_meta_get_eval_ifname(priv->key, dest, pkt))\n\t\t\tgoto err;\n\t\tbreak;\n\tcase NFT_META_SKUID:\n\tcase NFT_META_SKGID:\n\t\tif (!nft_meta_get_eval_skugid(priv->key, dest, pkt))\n\t\t\tgoto err;\n\t\tbreak;\n#ifdef CONFIG_IP_ROUTE_CLASSID\n\tcase NFT_META_RTCLASSID:\n\t\tif (!nft_meta_get_eval_rtclassid(skb, dest))\n\t\t\tgoto err;\n\t\tbreak;\n#endif\n#ifdef CONFIG_NETWORK_SECMARK\n\tcase NFT_META_SECMARK:\n\t\t*dest = skb->secmark;\n\t\tbreak;\n#endif\n\tcase NFT_META_PKTTYPE:\n\t\tif (skb->pkt_type != PACKET_LOOPBACK) {\n\t\t\tnft_reg_store8(dest, skb->pkt_type);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!nft_meta_get_eval_pkttype_lo(pkt, dest))\n\t\t\tgoto err;\n\t\tbreak;\n\tcase NFT_META_CPU:\n\t\t*dest = raw_smp_processor_id();\n\t\tbreak;\n#ifdef CONFIG_CGROUP_NET_CLASSID\n\tcase NFT_META_CGROUP:\n\t\tif (!nft_meta_get_eval_cgroup(dest, pkt))\n\t\t\tgoto err;\n\t\tbreak;\n#endif\n\tcase NFT_META_PRANDOM:\n\t\t*dest = get_random_u32();\n\t\tbreak;\n#ifdef CONFIG_XFRM\n\tcase NFT_META_SECPATH:\n\t\tnft_reg_store8(dest, secpath_exists(skb));\n\t\tbreak;\n#endif\n\tcase NFT_META_IIFKIND:\n\tcase NFT_META_OIFKIND:\n\t\tif (!nft_meta_get_eval_kind(priv->key, dest, pkt))\n\t\t\tgoto err;\n\t\tbreak;\n\tcase NFT_META_TIME_NS:\n\tcase NFT_META_TIME_DAY:\n\tcase NFT_META_TIME_HOUR:\n\t\tnft_meta_get_eval_time(priv->key, dest);\n\t\tbreak;\n\tcase NFT_META_SDIF:\n\t\t*dest = nft_meta_get_eval_sdif(pkt);\n\t\tbreak;\n\tcase NFT_META_SDIFNAME:\n\t\tnft_meta_get_eval_sdifname(dest, pkt);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tgoto err;\n\t}\n\treturn;\n\nerr:\n\tregs->verdict.code = NFT_BREAK;\n}\nEXPORT_SYMBOL_GPL(nft_meta_get_eval);\n\nvoid nft_meta_set_eval(const struct nft_expr *expr,\n\t\t       struct nft_regs *regs,\n\t\t       const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_meta *meta = nft_expr_priv(expr);\n\tstruct sk_buff *skb = pkt->skb;\n\tu32 *sreg = &regs->data[meta->sreg];\n\tu32 value = *sreg;\n\tu8 value8;\n\n\tswitch (meta->key) {\n\tcase NFT_META_MARK:\n\t\tskb->mark = value;\n\t\tbreak;\n\tcase NFT_META_PRIORITY:\n\t\tskb->priority = value;\n\t\tbreak;\n\tcase NFT_META_PKTTYPE:\n\t\tvalue8 = nft_reg_load8(sreg);\n\n\t\tif (skb->pkt_type != value8 &&\n\t\t    skb_pkt_type_ok(value8) &&\n\t\t    skb_pkt_type_ok(skb->pkt_type))\n\t\t\tskb->pkt_type = value8;\n\t\tbreak;\n\tcase NFT_META_NFTRACE:\n\t\tvalue8 = nft_reg_load8(sreg);\n\n\t\tskb->nf_trace = !!value8;\n\t\tbreak;\n#ifdef CONFIG_NETWORK_SECMARK\n\tcase NFT_META_SECMARK:\n\t\tskb->secmark = value;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n}\nEXPORT_SYMBOL_GPL(nft_meta_set_eval);\n\nconst struct nla_policy nft_meta_policy[NFTA_META_MAX + 1] = {\n\t[NFTA_META_DREG]\t= { .type = NLA_U32 },\n\t[NFTA_META_KEY]\t\t= NLA_POLICY_MAX(NLA_BE32, 255),\n\t[NFTA_META_SREG]\t= { .type = NLA_U32 },\n};\nEXPORT_SYMBOL_GPL(nft_meta_policy);\n\nint nft_meta_get_init(const struct nft_ctx *ctx,\n\t\t      const struct nft_expr *expr,\n\t\t      const struct nlattr * const tb[])\n{\n\tstruct nft_meta *priv = nft_expr_priv(expr);\n\tunsigned int len;\n\n\tpriv->key = ntohl(nla_get_be32(tb[NFTA_META_KEY]));\n\tswitch (priv->key) {\n\tcase NFT_META_PROTOCOL:\n\tcase NFT_META_IIFTYPE:\n\tcase NFT_META_OIFTYPE:\n\t\tlen = sizeof(u16);\n\t\tbreak;\n\tcase NFT_META_NFPROTO:\n\tcase NFT_META_L4PROTO:\n\tcase NFT_META_LEN:\n\tcase NFT_META_PRIORITY:\n\tcase NFT_META_MARK:\n\tcase NFT_META_IIF:\n\tcase NFT_META_OIF:\n\tcase NFT_META_SDIF:\n\tcase NFT_META_SKUID:\n\tcase NFT_META_SKGID:\n#ifdef CONFIG_IP_ROUTE_CLASSID\n\tcase NFT_META_RTCLASSID:\n#endif\n#ifdef CONFIG_NETWORK_SECMARK\n\tcase NFT_META_SECMARK:\n#endif\n\tcase NFT_META_PKTTYPE:\n\tcase NFT_META_CPU:\n\tcase NFT_META_IIFGROUP:\n\tcase NFT_META_OIFGROUP:\n#ifdef CONFIG_CGROUP_NET_CLASSID\n\tcase NFT_META_CGROUP:\n#endif\n\t\tlen = sizeof(u32);\n\t\tbreak;\n\tcase NFT_META_IIFNAME:\n\tcase NFT_META_OIFNAME:\n\tcase NFT_META_IIFKIND:\n\tcase NFT_META_OIFKIND:\n\tcase NFT_META_SDIFNAME:\n\t\tlen = IFNAMSIZ;\n\t\tbreak;\n\tcase NFT_META_PRANDOM:\n\t\tlen = sizeof(u32);\n\t\tbreak;\n#ifdef CONFIG_XFRM\n\tcase NFT_META_SECPATH:\n\t\tlen = sizeof(u8);\n\t\tbreak;\n#endif\n\tcase NFT_META_TIME_NS:\n\t\tlen = sizeof(u64);\n\t\tbreak;\n\tcase NFT_META_TIME_DAY:\n\t\tlen = sizeof(u8);\n\t\tbreak;\n\tcase NFT_META_TIME_HOUR:\n\t\tlen = sizeof(u32);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tpriv->len = len;\n\treturn nft_parse_register_store(ctx, tb[NFTA_META_DREG], &priv->dreg,\n\t\t\t\t\tNULL, NFT_DATA_VALUE, len);\n}\nEXPORT_SYMBOL_GPL(nft_meta_get_init);\n\nstatic int nft_meta_get_validate_sdif(const struct nft_ctx *ctx)\n{\n\tunsigned int hooks;\n\n\tswitch (ctx->family) {\n\tcase NFPROTO_IPV4:\n\tcase NFPROTO_IPV6:\n\tcase NFPROTO_INET:\n\t\thooks = (1 << NF_INET_LOCAL_IN) |\n\t\t\t(1 << NF_INET_FORWARD);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn nft_chain_validate_hooks(ctx->chain, hooks);\n}\n\nstatic int nft_meta_get_validate_xfrm(const struct nft_ctx *ctx)\n{\n#ifdef CONFIG_XFRM\n\tunsigned int hooks;\n\n\tswitch (ctx->family) {\n\tcase NFPROTO_NETDEV:\n\t\thooks = 1 << NF_NETDEV_INGRESS;\n\t\tbreak;\n\tcase NFPROTO_IPV4:\n\tcase NFPROTO_IPV6:\n\tcase NFPROTO_INET:\n\t\thooks = (1 << NF_INET_PRE_ROUTING) |\n\t\t\t(1 << NF_INET_LOCAL_IN) |\n\t\t\t(1 << NF_INET_FORWARD);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn nft_chain_validate_hooks(ctx->chain, hooks);\n#else\n\treturn 0;\n#endif\n}\n\nstatic int nft_meta_get_validate(const struct nft_ctx *ctx,\n\t\t\t\t const struct nft_expr *expr,\n\t\t\t\t const struct nft_data **data)\n{\n\tconst struct nft_meta *priv = nft_expr_priv(expr);\n\n\tswitch (priv->key) {\n\tcase NFT_META_SECPATH:\n\t\treturn nft_meta_get_validate_xfrm(ctx);\n\tcase NFT_META_SDIF:\n\tcase NFT_META_SDIFNAME:\n\t\treturn nft_meta_get_validate_sdif(ctx);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nint nft_meta_set_validate(const struct nft_ctx *ctx,\n\t\t\t  const struct nft_expr *expr,\n\t\t\t  const struct nft_data **data)\n{\n\tstruct nft_meta *priv = nft_expr_priv(expr);\n\tunsigned int hooks;\n\n\tif (priv->key != NFT_META_PKTTYPE)\n\t\treturn 0;\n\n\tswitch (ctx->family) {\n\tcase NFPROTO_BRIDGE:\n\t\thooks = 1 << NF_BR_PRE_ROUTING;\n\t\tbreak;\n\tcase NFPROTO_NETDEV:\n\t\thooks = 1 << NF_NETDEV_INGRESS;\n\t\tbreak;\n\tcase NFPROTO_IPV4:\n\tcase NFPROTO_IPV6:\n\tcase NFPROTO_INET:\n\t\thooks = 1 << NF_INET_PRE_ROUTING;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn nft_chain_validate_hooks(ctx->chain, hooks);\n}\nEXPORT_SYMBOL_GPL(nft_meta_set_validate);\n\nint nft_meta_set_init(const struct nft_ctx *ctx,\n\t\t      const struct nft_expr *expr,\n\t\t      const struct nlattr * const tb[])\n{\n\tstruct nft_meta *priv = nft_expr_priv(expr);\n\tunsigned int len;\n\tint err;\n\n\tpriv->key = ntohl(nla_get_be32(tb[NFTA_META_KEY]));\n\tswitch (priv->key) {\n\tcase NFT_META_MARK:\n\tcase NFT_META_PRIORITY:\n#ifdef CONFIG_NETWORK_SECMARK\n\tcase NFT_META_SECMARK:\n#endif\n\t\tlen = sizeof(u32);\n\t\tbreak;\n\tcase NFT_META_NFTRACE:\n\t\tlen = sizeof(u8);\n\t\tbreak;\n\tcase NFT_META_PKTTYPE:\n\t\tlen = sizeof(u8);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tpriv->len = len;\n\terr = nft_parse_register_load(tb[NFTA_META_SREG], &priv->sreg, len);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (priv->key == NFT_META_NFTRACE)\n\t\tstatic_branch_inc(&nft_trace_enabled);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nft_meta_set_init);\n\nint nft_meta_get_dump(struct sk_buff *skb,\n\t\t      const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_meta *priv = nft_expr_priv(expr);\n\n\tif (nla_put_be32(skb, NFTA_META_KEY, htonl(priv->key)))\n\t\tgoto nla_put_failure;\n\tif (nft_dump_register(skb, NFTA_META_DREG, priv->dreg))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\nEXPORT_SYMBOL_GPL(nft_meta_get_dump);\n\nint nft_meta_set_dump(struct sk_buff *skb,\n\t\t      const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_meta *priv = nft_expr_priv(expr);\n\n\tif (nla_put_be32(skb, NFTA_META_KEY, htonl(priv->key)))\n\t\tgoto nla_put_failure;\n\tif (nft_dump_register(skb, NFTA_META_SREG, priv->sreg))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\nEXPORT_SYMBOL_GPL(nft_meta_set_dump);\n\nvoid nft_meta_set_destroy(const struct nft_ctx *ctx,\n\t\t\t  const struct nft_expr *expr)\n{\n\tconst struct nft_meta *priv = nft_expr_priv(expr);\n\n\tif (priv->key == NFT_META_NFTRACE)\n\t\tstatic_branch_dec(&nft_trace_enabled);\n}\nEXPORT_SYMBOL_GPL(nft_meta_set_destroy);\n\nstatic int nft_meta_get_offload(struct nft_offload_ctx *ctx,\n\t\t\t\tstruct nft_flow_rule *flow,\n\t\t\t\tconst struct nft_expr *expr)\n{\n\tconst struct nft_meta *priv = nft_expr_priv(expr);\n\tstruct nft_offload_reg *reg = &ctx->regs[priv->dreg];\n\n\tswitch (priv->key) {\n\tcase NFT_META_PROTOCOL:\n\t\tNFT_OFFLOAD_MATCH_EXACT(FLOW_DISSECTOR_KEY_BASIC, basic, n_proto,\n\t\t\t\t\tsizeof(__u16), reg);\n\t\tnft_offload_set_dependency(ctx, NFT_OFFLOAD_DEP_NETWORK);\n\t\tbreak;\n\tcase NFT_META_L4PROTO:\n\t\tNFT_OFFLOAD_MATCH_EXACT(FLOW_DISSECTOR_KEY_BASIC, basic, ip_proto,\n\t\t\t\t\tsizeof(__u8), reg);\n\t\tnft_offload_set_dependency(ctx, NFT_OFFLOAD_DEP_TRANSPORT);\n\t\tbreak;\n\tcase NFT_META_IIF:\n\t\tNFT_OFFLOAD_MATCH_EXACT(FLOW_DISSECTOR_KEY_META, meta,\n\t\t\t\t\tingress_ifindex, sizeof(__u32), reg);\n\t\tbreak;\n\tcase NFT_META_IIFTYPE:\n\t\tNFT_OFFLOAD_MATCH_EXACT(FLOW_DISSECTOR_KEY_META, meta,\n\t\t\t\t\tingress_iftype, sizeof(__u16), reg);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nbool nft_meta_get_reduce(struct nft_regs_track *track,\n\t\t\t const struct nft_expr *expr)\n{\n\tconst struct nft_meta *priv = nft_expr_priv(expr);\n\tconst struct nft_meta *meta;\n\n\tif (!nft_reg_track_cmp(track, expr, priv->dreg)) {\n\t\tnft_reg_track_update(track, expr, priv->dreg, priv->len);\n\t\treturn false;\n\t}\n\n\tmeta = nft_expr_priv(track->regs[priv->dreg].selector);\n\tif (priv->key != meta->key ||\n\t    priv->dreg != meta->dreg) {\n\t\tnft_reg_track_update(track, expr, priv->dreg, priv->len);\n\t\treturn false;\n\t}\n\n\tif (!track->regs[priv->dreg].bitwise)\n\t\treturn true;\n\n\treturn nft_expr_reduce_bitwise(track, expr);\n}\nEXPORT_SYMBOL_GPL(nft_meta_get_reduce);\n\nstatic const struct nft_expr_ops nft_meta_get_ops = {\n\t.type\t\t= &nft_meta_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_meta)),\n\t.eval\t\t= nft_meta_get_eval,\n\t.init\t\t= nft_meta_get_init,\n\t.dump\t\t= nft_meta_get_dump,\n\t.reduce\t\t= nft_meta_get_reduce,\n\t.validate\t= nft_meta_get_validate,\n\t.offload\t= nft_meta_get_offload,\n};\n\nstatic bool nft_meta_set_reduce(struct nft_regs_track *track,\n\t\t\t\tconst struct nft_expr *expr)\n{\n\tint i;\n\n\tfor (i = 0; i < NFT_REG32_NUM; i++) {\n\t\tif (!track->regs[i].selector)\n\t\t\tcontinue;\n\n\t\tif (track->regs[i].selector->ops != &nft_meta_get_ops)\n\t\t\tcontinue;\n\n\t\t__nft_reg_track_cancel(track, i);\n\t}\n\n\treturn false;\n}\n\nstatic const struct nft_expr_ops nft_meta_set_ops = {\n\t.type\t\t= &nft_meta_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_meta)),\n\t.eval\t\t= nft_meta_set_eval,\n\t.init\t\t= nft_meta_set_init,\n\t.destroy\t= nft_meta_set_destroy,\n\t.dump\t\t= nft_meta_set_dump,\n\t.reduce\t\t= nft_meta_set_reduce,\n\t.validate\t= nft_meta_set_validate,\n};\n\nstatic const struct nft_expr_ops *\nnft_meta_select_ops(const struct nft_ctx *ctx,\n\t\t    const struct nlattr * const tb[])\n{\n\tif (tb[NFTA_META_KEY] == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (tb[NFTA_META_DREG] && tb[NFTA_META_SREG])\n\t\treturn ERR_PTR(-EINVAL);\n\n#if IS_ENABLED(CONFIG_NF_TABLES_BRIDGE) && IS_MODULE(CONFIG_NFT_BRIDGE_META)\n\tif (ctx->family == NFPROTO_BRIDGE)\n\t\treturn ERR_PTR(-EAGAIN);\n#endif\n\tif (tb[NFTA_META_DREG])\n\t\treturn &nft_meta_get_ops;\n\n\tif (tb[NFTA_META_SREG])\n\t\treturn &nft_meta_set_ops;\n\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic int nft_meta_inner_init(const struct nft_ctx *ctx,\n\t\t\t       const struct nft_expr *expr,\n\t\t\t       const struct nlattr * const tb[])\n{\n\tstruct nft_meta *priv = nft_expr_priv(expr);\n\tunsigned int len;\n\n\tpriv->key = ntohl(nla_get_be32(tb[NFTA_META_KEY]));\n\tswitch (priv->key) {\n\tcase NFT_META_PROTOCOL:\n\t\tlen = sizeof(u16);\n\t\tbreak;\n\tcase NFT_META_L4PROTO:\n\t\tlen = sizeof(u32);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\tpriv->len = len;\n\n\treturn nft_parse_register_store(ctx, tb[NFTA_META_DREG], &priv->dreg,\n\t\t\t\t\tNULL, NFT_DATA_VALUE, len);\n}\n\nvoid nft_meta_inner_eval(const struct nft_expr *expr,\n\t\t\t struct nft_regs *regs,\n\t\t\t const struct nft_pktinfo *pkt,\n\t\t\t struct nft_inner_tun_ctx *tun_ctx)\n{\n\tconst struct nft_meta *priv = nft_expr_priv(expr);\n\tu32 *dest = &regs->data[priv->dreg];\n\n\tswitch (priv->key) {\n\tcase NFT_META_PROTOCOL:\n\t\tnft_reg_store16(dest, (__force u16)tun_ctx->llproto);\n\t\tbreak;\n\tcase NFT_META_L4PROTO:\n\t\tif (!(tun_ctx->flags & NFT_PAYLOAD_CTX_INNER_TH))\n\t\t\tgoto err;\n\n\t\tnft_reg_store8(dest, tun_ctx->l4proto);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tgoto err;\n\t}\n\treturn;\n\nerr:\n\tregs->verdict.code = NFT_BREAK;\n}\nEXPORT_SYMBOL_GPL(nft_meta_inner_eval);\n\nstatic const struct nft_expr_ops nft_meta_inner_ops = {\n\t.type\t\t= &nft_meta_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_meta)),\n\t.init\t\t= nft_meta_inner_init,\n\t.dump\t\t= nft_meta_get_dump,\n\t/* direct call to nft_meta_inner_eval(). */\n};\n\nstruct nft_expr_type nft_meta_type __read_mostly = {\n\t.name\t\t= \"meta\",\n\t.select_ops\t= nft_meta_select_ops,\n\t.inner_ops\t= &nft_meta_inner_ops,\n\t.policy\t\t= nft_meta_policy,\n\t.maxattr\t= NFTA_META_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n\n#ifdef CONFIG_NETWORK_SECMARK\nstruct nft_secmark {\n\tu32 secid;\n\tchar *ctx;\n};\n\nstatic const struct nla_policy nft_secmark_policy[NFTA_SECMARK_MAX + 1] = {\n\t[NFTA_SECMARK_CTX]     = { .type = NLA_STRING, .len = NFT_SECMARK_CTX_MAXLEN },\n};\n\nstatic int nft_secmark_compute_secid(struct nft_secmark *priv)\n{\n\tu32 tmp_secid = 0;\n\tint err;\n\n\terr = security_secctx_to_secid(priv->ctx, strlen(priv->ctx), &tmp_secid);\n\tif (err)\n\t\treturn err;\n\n\tif (!tmp_secid)\n\t\treturn -ENOENT;\n\n\terr = security_secmark_relabel_packet(tmp_secid);\n\tif (err)\n\t\treturn err;\n\n\tpriv->secid = tmp_secid;\n\treturn 0;\n}\n\nstatic void nft_secmark_obj_eval(struct nft_object *obj, struct nft_regs *regs,\n\t\t\t\t const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_secmark *priv = nft_obj_data(obj);\n\tstruct sk_buff *skb = pkt->skb;\n\n\tskb->secmark = priv->secid;\n}\n\nstatic int nft_secmark_obj_init(const struct nft_ctx *ctx,\n\t\t\t\tconst struct nlattr * const tb[],\n\t\t\t\tstruct nft_object *obj)\n{\n\tstruct nft_secmark *priv = nft_obj_data(obj);\n\tint err;\n\n\tif (tb[NFTA_SECMARK_CTX] == NULL)\n\t\treturn -EINVAL;\n\n\tpriv->ctx = nla_strdup(tb[NFTA_SECMARK_CTX], GFP_KERNEL);\n\tif (!priv->ctx)\n\t\treturn -ENOMEM;\n\n\terr = nft_secmark_compute_secid(priv);\n\tif (err) {\n\t\tkfree(priv->ctx);\n\t\treturn err;\n\t}\n\n\tsecurity_secmark_refcount_inc();\n\n\treturn 0;\n}\n\nstatic int nft_secmark_obj_dump(struct sk_buff *skb, struct nft_object *obj,\n\t\t\t\tbool reset)\n{\n\tstruct nft_secmark *priv = nft_obj_data(obj);\n\tint err;\n\n\tif (nla_put_string(skb, NFTA_SECMARK_CTX, priv->ctx))\n\t\treturn -1;\n\n\tif (reset) {\n\t\terr = nft_secmark_compute_secid(priv);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void nft_secmark_obj_destroy(const struct nft_ctx *ctx, struct nft_object *obj)\n{\n\tstruct nft_secmark *priv = nft_obj_data(obj);\n\n\tsecurity_secmark_refcount_dec();\n\n\tkfree(priv->ctx);\n}\n\nstatic const struct nft_object_ops nft_secmark_obj_ops = {\n\t.type\t\t= &nft_secmark_obj_type,\n\t.size\t\t= sizeof(struct nft_secmark),\n\t.init\t\t= nft_secmark_obj_init,\n\t.eval\t\t= nft_secmark_obj_eval,\n\t.dump\t\t= nft_secmark_obj_dump,\n\t.destroy\t= nft_secmark_obj_destroy,\n};\nstruct nft_object_type nft_secmark_obj_type __read_mostly = {\n\t.type\t\t= NFT_OBJECT_SECMARK,\n\t.ops\t\t= &nft_secmark_obj_ops,\n\t.maxattr\t= NFTA_SECMARK_MAX,\n\t.policy\t\t= nft_secmark_policy,\n\t.owner\t\t= THIS_MODULE,\n};\n#endif /* CONFIG_NETWORK_SECMARK */\n"], "fixing_code": ["/* SPDX-License-Identifier: GPL-2.0 */\n#ifndef _NET_NF_TABLES_H\n#define _NET_NF_TABLES_H\n\n#include <asm/unaligned.h>\n#include <linux/list.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nfnetlink.h>\n#include <linux/netfilter/x_tables.h>\n#include <linux/netfilter/nf_tables.h>\n#include <linux/u64_stats_sync.h>\n#include <linux/rhashtable.h>\n#include <net/netfilter/nf_flow_table.h>\n#include <net/netlink.h>\n#include <net/flow_offload.h>\n#include <net/netns/generic.h>\n\n#define NFT_MAX_HOOKS\t(NF_INET_INGRESS + 1)\n\nstruct module;\n\n#define NFT_JUMP_STACK_SIZE\t16\n\nenum {\n\tNFT_PKTINFO_L4PROTO\t= (1 << 0),\n\tNFT_PKTINFO_INNER\t= (1 << 1),\n\tNFT_PKTINFO_INNER_FULL\t= (1 << 2),\n};\n\nstruct nft_pktinfo {\n\tstruct sk_buff\t\t\t*skb;\n\tconst struct nf_hook_state\t*state;\n\tu8\t\t\t\tflags;\n\tu8\t\t\t\ttprot;\n\tu16\t\t\t\tfragoff;\n\tu16\t\t\t\tthoff;\n\tu16\t\t\t\tinneroff;\n};\n\nstatic inline struct sock *nft_sk(const struct nft_pktinfo *pkt)\n{\n\treturn pkt->state->sk;\n}\n\nstatic inline unsigned int nft_thoff(const struct nft_pktinfo *pkt)\n{\n\treturn pkt->thoff;\n}\n\nstatic inline struct net *nft_net(const struct nft_pktinfo *pkt)\n{\n\treturn pkt->state->net;\n}\n\nstatic inline unsigned int nft_hook(const struct nft_pktinfo *pkt)\n{\n\treturn pkt->state->hook;\n}\n\nstatic inline u8 nft_pf(const struct nft_pktinfo *pkt)\n{\n\treturn pkt->state->pf;\n}\n\nstatic inline const struct net_device *nft_in(const struct nft_pktinfo *pkt)\n{\n\treturn pkt->state->in;\n}\n\nstatic inline const struct net_device *nft_out(const struct nft_pktinfo *pkt)\n{\n\treturn pkt->state->out;\n}\n\nstatic inline void nft_set_pktinfo(struct nft_pktinfo *pkt,\n\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t   const struct nf_hook_state *state)\n{\n\tpkt->skb = skb;\n\tpkt->state = state;\n}\n\nstatic inline void nft_set_pktinfo_unspec(struct nft_pktinfo *pkt)\n{\n\tpkt->flags = 0;\n\tpkt->tprot = 0;\n\tpkt->thoff = 0;\n\tpkt->fragoff = 0;\n}\n\n/**\n * \tstruct nft_verdict - nf_tables verdict\n *\n * \t@code: nf_tables/netfilter verdict code\n * \t@chain: destination chain for NFT_JUMP/NFT_GOTO\n */\nstruct nft_verdict {\n\tu32\t\t\t\tcode;\n\tstruct nft_chain\t\t*chain;\n};\n\nstruct nft_data {\n\tunion {\n\t\tu32\t\t\tdata[4];\n\t\tstruct nft_verdict\tverdict;\n\t};\n} __attribute__((aligned(__alignof__(u64))));\n\n#define NFT_REG32_NUM\t\t20\n\n/**\n *\tstruct nft_regs - nf_tables register set\n *\n *\t@data: data registers\n *\t@verdict: verdict register\n *\n *\tThe first four data registers alias to the verdict register.\n */\nstruct nft_regs {\n\tunion {\n\t\tu32\t\t\tdata[NFT_REG32_NUM];\n\t\tstruct nft_verdict\tverdict;\n\t};\n};\n\nstruct nft_regs_track {\n\tstruct {\n\t\tconst struct nft_expr\t\t*selector;\n\t\tconst struct nft_expr\t\t*bitwise;\n\t\tu8\t\t\t\tnum_reg;\n\t} regs[NFT_REG32_NUM];\n\n\tconst struct nft_expr\t\t\t*cur;\n\tconst struct nft_expr\t\t\t*last;\n};\n\n/* Store/load an u8, u16 or u64 integer to/from the u32 data register.\n *\n * Note, when using concatenations, register allocation happens at 32-bit\n * level. So for store instruction, pad the rest part with zero to avoid\n * garbage values.\n */\n\nstatic inline void nft_reg_store8(u32 *dreg, u8 val)\n{\n\t*dreg = 0;\n\t*(u8 *)dreg = val;\n}\n\nstatic inline u8 nft_reg_load8(const u32 *sreg)\n{\n\treturn *(u8 *)sreg;\n}\n\nstatic inline void nft_reg_store16(u32 *dreg, u16 val)\n{\n\t*dreg = 0;\n\t*(u16 *)dreg = val;\n}\n\nstatic inline void nft_reg_store_be16(u32 *dreg, __be16 val)\n{\n\tnft_reg_store16(dreg, (__force __u16)val);\n}\n\nstatic inline u16 nft_reg_load16(const u32 *sreg)\n{\n\treturn *(u16 *)sreg;\n}\n\nstatic inline __be16 nft_reg_load_be16(const u32 *sreg)\n{\n\treturn (__force __be16)nft_reg_load16(sreg);\n}\n\nstatic inline __be32 nft_reg_load_be32(const u32 *sreg)\n{\n\treturn *(__force __be32 *)sreg;\n}\n\nstatic inline void nft_reg_store64(u64 *dreg, u64 val)\n{\n\tput_unaligned(val, dreg);\n}\n\nstatic inline u64 nft_reg_load64(const u32 *sreg)\n{\n\treturn get_unaligned((u64 *)sreg);\n}\n\nstatic inline void nft_data_copy(u32 *dst, const struct nft_data *src,\n\t\t\t\t unsigned int len)\n{\n\tif (len % NFT_REG32_SIZE)\n\t\tdst[len / NFT_REG32_SIZE] = 0;\n\tmemcpy(dst, src, len);\n}\n\n/**\n *\tstruct nft_ctx - nf_tables rule/set context\n *\n *\t@net: net namespace\n * \t@table: the table the chain is contained in\n * \t@chain: the chain the rule is contained in\n *\t@nla: netlink attributes\n *\t@portid: netlink portID of the original message\n *\t@seq: netlink sequence number\n *\t@family: protocol family\n *\t@level: depth of the chains\n *\t@report: notify via unicast netlink message\n */\nstruct nft_ctx {\n\tstruct net\t\t\t*net;\n\tstruct nft_table\t\t*table;\n\tstruct nft_chain\t\t*chain;\n\tconst struct nlattr * const \t*nla;\n\tu32\t\t\t\tportid;\n\tu32\t\t\t\tseq;\n\tu16\t\t\t\tflags;\n\tu8\t\t\t\tfamily;\n\tu8\t\t\t\tlevel;\n\tbool\t\t\t\treport;\n};\n\nenum nft_data_desc_flags {\n\tNFT_DATA_DESC_SETELEM\t= (1 << 0),\n};\n\nstruct nft_data_desc {\n\tenum nft_data_types\t\ttype;\n\tunsigned int\t\t\tsize;\n\tunsigned int\t\t\tlen;\n\tunsigned int\t\t\tflags;\n};\n\nint nft_data_init(const struct nft_ctx *ctx, struct nft_data *data,\n\t\t  struct nft_data_desc *desc, const struct nlattr *nla);\nvoid nft_data_hold(const struct nft_data *data, enum nft_data_types type);\nvoid nft_data_release(const struct nft_data *data, enum nft_data_types type);\nint nft_data_dump(struct sk_buff *skb, int attr, const struct nft_data *data,\n\t\t  enum nft_data_types type, unsigned int len);\n\nstatic inline enum nft_data_types nft_dreg_to_type(enum nft_registers reg)\n{\n\treturn reg == NFT_REG_VERDICT ? NFT_DATA_VERDICT : NFT_DATA_VALUE;\n}\n\nstatic inline enum nft_registers nft_type_to_reg(enum nft_data_types type)\n{\n\treturn type == NFT_DATA_VERDICT ? NFT_REG_VERDICT : NFT_REG_1 * NFT_REG_SIZE / NFT_REG32_SIZE;\n}\n\nint nft_parse_u32_check(const struct nlattr *attr, int max, u32 *dest);\nint nft_dump_register(struct sk_buff *skb, unsigned int attr, unsigned int reg);\n\nint nft_parse_register_load(const struct nlattr *attr, u8 *sreg, u32 len);\nint nft_parse_register_store(const struct nft_ctx *ctx,\n\t\t\t     const struct nlattr *attr, u8 *dreg,\n\t\t\t     const struct nft_data *data,\n\t\t\t     enum nft_data_types type, unsigned int len);\n\n/**\n *\tstruct nft_userdata - user defined data associated with an object\n *\n *\t@len: length of the data\n *\t@data: content\n *\n *\tThe presence of user data is indicated in an object specific fashion,\n *\tso a length of zero can't occur and the value \"len\" indicates data\n *\tof length len + 1.\n */\nstruct nft_userdata {\n\tu8\t\t\tlen;\n\tunsigned char\t\tdata[];\n};\n\n/* placeholder structure for opaque set element backend representation. */\nstruct nft_elem_priv { };\n\n/**\n *\tstruct nft_set_elem - generic representation of set elements\n *\n *\t@key: element key\n *\t@key_end: closing element key\n *\t@priv: element private data and extensions\n */\nstruct nft_set_elem {\n\tunion {\n\t\tu32\t\tbuf[NFT_DATA_VALUE_MAXLEN / sizeof(u32)];\n\t\tstruct nft_data\tval;\n\t} key;\n\tunion {\n\t\tu32\t\tbuf[NFT_DATA_VALUE_MAXLEN / sizeof(u32)];\n\t\tstruct nft_data\tval;\n\t} key_end;\n\tunion {\n\t\tu32\t\tbuf[NFT_DATA_VALUE_MAXLEN / sizeof(u32)];\n\t\tstruct nft_data val;\n\t} data;\n\tstruct nft_elem_priv\t*priv;\n};\n\nstatic inline void *nft_elem_priv_cast(const struct nft_elem_priv *priv)\n{\n\treturn (void *)priv;\n}\n\nstruct nft_set;\nstruct nft_set_iter {\n\tu8\t\tgenmask;\n\tunsigned int\tcount;\n\tunsigned int\tskip;\n\tint\t\terr;\n\tint\t\t(*fn)(const struct nft_ctx *ctx,\n\t\t\t      struct nft_set *set,\n\t\t\t      const struct nft_set_iter *iter,\n\t\t\t      struct nft_elem_priv *elem_priv);\n};\n\n/**\n *\tstruct nft_set_desc - description of set elements\n *\n *\t@ktype: key type\n *\t@klen: key length\n *\t@dtype: data type\n *\t@dlen: data length\n *\t@objtype: object type\n *\t@flags: flags\n *\t@size: number of set elements\n *\t@policy: set policy\n *\t@gc_int: garbage collector interval\n *\t@field_len: length of each field in concatenation, bytes\n *\t@field_count: number of concatenated fields in element\n *\t@expr: set must support for expressions\n */\nstruct nft_set_desc {\n\tu32\t\t\tktype;\n\tunsigned int\t\tklen;\n\tu32\t\t\tdtype;\n\tunsigned int\t\tdlen;\n\tu32\t\t\tobjtype;\n\tunsigned int\t\tsize;\n\tu32\t\t\tpolicy;\n\tu32\t\t\tgc_int;\n\tu64\t\t\ttimeout;\n\tu8\t\t\tfield_len[NFT_REG32_COUNT];\n\tu8\t\t\tfield_count;\n\tbool\t\t\texpr;\n};\n\n/**\n *\tenum nft_set_class - performance class\n *\n *\t@NFT_LOOKUP_O_1: constant, O(1)\n *\t@NFT_LOOKUP_O_LOG_N: logarithmic, O(log N)\n *\t@NFT_LOOKUP_O_N: linear, O(N)\n */\nenum nft_set_class {\n\tNFT_SET_CLASS_O_1,\n\tNFT_SET_CLASS_O_LOG_N,\n\tNFT_SET_CLASS_O_N,\n};\n\n/**\n *\tstruct nft_set_estimate - estimation of memory and performance\n *\t\t\t\t  characteristics\n *\n *\t@size: required memory\n *\t@lookup: lookup performance class\n *\t@space: memory class\n */\nstruct nft_set_estimate {\n\tu64\t\t\tsize;\n\tenum nft_set_class\tlookup;\n\tenum nft_set_class\tspace;\n};\n\n#define NFT_EXPR_MAXATTR\t\t16\n#define NFT_EXPR_SIZE(size)\t\t(sizeof(struct nft_expr) + \\\n\t\t\t\t\t ALIGN(size, __alignof__(struct nft_expr)))\n\n/**\n *\tstruct nft_expr - nf_tables expression\n *\n *\t@ops: expression ops\n *\t@data: expression private data\n */\nstruct nft_expr {\n\tconst struct nft_expr_ops\t*ops;\n\tunsigned char\t\t\tdata[]\n\t\t__attribute__((aligned(__alignof__(u64))));\n};\n\nstatic inline void *nft_expr_priv(const struct nft_expr *expr)\n{\n\treturn (void *)expr->data;\n}\n\nstruct nft_expr_info;\n\nint nft_expr_inner_parse(const struct nft_ctx *ctx, const struct nlattr *nla,\n\t\t\t struct nft_expr_info *info);\nint nft_expr_clone(struct nft_expr *dst, struct nft_expr *src);\nvoid nft_expr_destroy(const struct nft_ctx *ctx, struct nft_expr *expr);\nint nft_expr_dump(struct sk_buff *skb, unsigned int attr,\n\t\t  const struct nft_expr *expr, bool reset);\nbool nft_expr_reduce_bitwise(struct nft_regs_track *track,\n\t\t\t     const struct nft_expr *expr);\n\nstruct nft_set_ext;\n\n/**\n *\tstruct nft_set_ops - nf_tables set operations\n *\n *\t@lookup: look up an element within the set\n *\t@update: update an element if exists, add it if doesn't exist\n *\t@delete: delete an element\n *\t@insert: insert new element into set\n *\t@activate: activate new element in the next generation\n *\t@deactivate: lookup for element and deactivate it in the next generation\n *\t@flush: deactivate element in the next generation\n *\t@remove: remove element from set\n *\t@walk: iterate over all set elements\n *\t@get: get set elements\n *\t@privsize: function to return size of set private data\n *\t@init: initialize private data of new set instance\n *\t@destroy: destroy private data of set instance\n *\t@elemsize: element private size\n *\n *\tOperations lookup, update and delete have simpler interfaces, are faster\n *\tand currently only used in the packet path. All the rest are slower,\n *\tcontrol plane functions.\n */\nstruct nft_set_ops {\n\tbool\t\t\t\t(*lookup)(const struct net *net,\n\t\t\t\t\t\t  const struct nft_set *set,\n\t\t\t\t\t\t  const u32 *key,\n\t\t\t\t\t\t  const struct nft_set_ext **ext);\n\tbool\t\t\t\t(*update)(struct nft_set *set,\n\t\t\t\t\t\t  const u32 *key,\n\t\t\t\t\t\t  struct nft_elem_priv *\n\t\t\t\t\t\t\t(*new)(struct nft_set *,\n\t\t\t\t\t\t\t       const struct nft_expr *,\n\t\t\t\t\t\t\t       struct nft_regs *),\n\t\t\t\t\t\t  const struct nft_expr *expr,\n\t\t\t\t\t\t  struct nft_regs *regs,\n\t\t\t\t\t\t  const struct nft_set_ext **ext);\n\tbool\t\t\t\t(*delete)(const struct nft_set *set,\n\t\t\t\t\t\t  const u32 *key);\n\n\tint\t\t\t\t(*insert)(const struct net *net,\n\t\t\t\t\t\t  const struct nft_set *set,\n\t\t\t\t\t\t  const struct nft_set_elem *elem,\n\t\t\t\t\t\t  struct nft_elem_priv **priv);\n\tvoid\t\t\t\t(*activate)(const struct net *net,\n\t\t\t\t\t\t    const struct nft_set *set,\n\t\t\t\t\t\t    struct nft_elem_priv *elem_priv);\n\tstruct nft_elem_priv *\t\t(*deactivate)(const struct net *net,\n\t\t\t\t\t\t      const struct nft_set *set,\n\t\t\t\t\t\t      const struct nft_set_elem *elem);\n\tvoid\t\t\t\t(*flush)(const struct net *net,\n\t\t\t\t\t\t const struct nft_set *set,\n\t\t\t\t\t\t struct nft_elem_priv *priv);\n\tvoid\t\t\t\t(*remove)(const struct net *net,\n\t\t\t\t\t\t  const struct nft_set *set,\n\t\t\t\t\t\t  struct nft_elem_priv *elem_priv);\n\tvoid\t\t\t\t(*walk)(const struct nft_ctx *ctx,\n\t\t\t\t\t\tstruct nft_set *set,\n\t\t\t\t\t\tstruct nft_set_iter *iter);\n\tstruct nft_elem_priv *\t\t(*get)(const struct net *net,\n\t\t\t\t\t       const struct nft_set *set,\n\t\t\t\t\t       const struct nft_set_elem *elem,\n\t\t\t\t\t       unsigned int flags);\n\tvoid\t\t\t\t(*commit)(struct nft_set *set);\n\tvoid\t\t\t\t(*abort)(const struct nft_set *set);\n\tu64\t\t\t\t(*privsize)(const struct nlattr * const nla[],\n\t\t\t\t\t\t    const struct nft_set_desc *desc);\n\tbool\t\t\t\t(*estimate)(const struct nft_set_desc *desc,\n\t\t\t\t\t\t    u32 features,\n\t\t\t\t\t\t    struct nft_set_estimate *est);\n\tint\t\t\t\t(*init)(const struct nft_set *set,\n\t\t\t\t\t\tconst struct nft_set_desc *desc,\n\t\t\t\t\t\tconst struct nlattr * const nla[]);\n\tvoid\t\t\t\t(*destroy)(const struct nft_ctx *ctx,\n\t\t\t\t\t\t   const struct nft_set *set);\n\tvoid\t\t\t\t(*gc_init)(const struct nft_set *set);\n\n\tunsigned int\t\t\telemsize;\n};\n\n/**\n *      struct nft_set_type - nf_tables set type\n *\n *      @ops: set ops for this type\n *      @features: features supported by the implementation\n */\nstruct nft_set_type {\n\tconst struct nft_set_ops\tops;\n\tu32\t\t\t\tfeatures;\n};\n#define to_set_type(o) container_of(o, struct nft_set_type, ops)\n\nstruct nft_set_elem_expr {\n\tu8\t\t\t\tsize;\n\tunsigned char\t\t\tdata[]\n\t\t__attribute__((aligned(__alignof__(struct nft_expr))));\n};\n\n#define nft_setelem_expr_at(__elem_expr, __offset)\t\t\t\\\n\t((struct nft_expr *)&__elem_expr->data[__offset])\n\n#define nft_setelem_expr_foreach(__expr, __elem_expr, __size)\t\t\\\n\tfor (__expr = nft_setelem_expr_at(__elem_expr, 0), __size = 0;\t\\\n\t     __size < (__elem_expr)->size;\t\t\t\t\\\n\t     __size += (__expr)->ops->size, __expr = ((void *)(__expr)) + (__expr)->ops->size)\n\n#define NFT_SET_EXPR_MAX\t2\n\n/**\n * \tstruct nft_set - nf_tables set instance\n *\n *\t@list: table set list node\n *\t@bindings: list of set bindings\n *\t@refs: internal refcounting for async set destruction\n *\t@table: table this set belongs to\n *\t@net: netnamespace this set belongs to\n * \t@name: name of the set\n *\t@handle: unique handle of the set\n * \t@ktype: key type (numeric type defined by userspace, not used in the kernel)\n * \t@dtype: data type (verdict or numeric type defined by userspace)\n * \t@objtype: object type (see NFT_OBJECT_* definitions)\n * \t@size: maximum set size\n *\t@field_len: length of each field in concatenation, bytes\n *\t@field_count: number of concatenated fields in element\n *\t@use: number of rules references to this set\n * \t@nelems: number of elements\n * \t@ndeact: number of deactivated elements queued for removal\n *\t@timeout: default timeout value in jiffies\n * \t@gc_int: garbage collection interval in msecs\n *\t@policy: set parameterization (see enum nft_set_policies)\n *\t@udlen: user data length\n *\t@udata: user data\n *\t@expr: stateful expression\n * \t@ops: set ops\n * \t@flags: set flags\n *\t@dead: set will be freed, never cleared\n *\t@genmask: generation mask\n * \t@klen: key length\n * \t@dlen: data length\n * \t@data: private set data\n */\nstruct nft_set {\n\tstruct list_head\t\tlist;\n\tstruct list_head\t\tbindings;\n\trefcount_t\t\t\trefs;\n\tstruct nft_table\t\t*table;\n\tpossible_net_t\t\t\tnet;\n\tchar\t\t\t\t*name;\n\tu64\t\t\t\thandle;\n\tu32\t\t\t\tktype;\n\tu32\t\t\t\tdtype;\n\tu32\t\t\t\tobjtype;\n\tu32\t\t\t\tsize;\n\tu8\t\t\t\tfield_len[NFT_REG32_COUNT];\n\tu8\t\t\t\tfield_count;\n\tu32\t\t\t\tuse;\n\tatomic_t\t\t\tnelems;\n\tu32\t\t\t\tndeact;\n\tu64\t\t\t\ttimeout;\n\tu32\t\t\t\tgc_int;\n\tu16\t\t\t\tpolicy;\n\tu16\t\t\t\tudlen;\n\tunsigned char\t\t\t*udata;\n\tstruct list_head\t\tpending_update;\n\t/* runtime data below here */\n\tconst struct nft_set_ops\t*ops ____cacheline_aligned;\n\tu16\t\t\t\tflags:13,\n\t\t\t\t\tdead:1,\n\t\t\t\t\tgenmask:2;\n\tu8\t\t\t\tklen;\n\tu8\t\t\t\tdlen;\n\tu8\t\t\t\tnum_exprs;\n\tstruct nft_expr\t\t\t*exprs[NFT_SET_EXPR_MAX];\n\tstruct list_head\t\tcatchall_list;\n\tunsigned char\t\t\tdata[]\n\t\t__attribute__((aligned(__alignof__(u64))));\n};\n\nstatic inline bool nft_set_is_anonymous(const struct nft_set *set)\n{\n\treturn set->flags & NFT_SET_ANONYMOUS;\n}\n\nstatic inline void *nft_set_priv(const struct nft_set *set)\n{\n\treturn (void *)set->data;\n}\n\nstatic inline bool nft_set_gc_is_pending(const struct nft_set *s)\n{\n\treturn refcount_read(&s->refs) != 1;\n}\n\nstatic inline struct nft_set *nft_set_container_of(const void *priv)\n{\n\treturn (void *)priv - offsetof(struct nft_set, data);\n}\n\nstruct nft_set *nft_set_lookup_global(const struct net *net,\n\t\t\t\t      const struct nft_table *table,\n\t\t\t\t      const struct nlattr *nla_set_name,\n\t\t\t\t      const struct nlattr *nla_set_id,\n\t\t\t\t      u8 genmask);\n\nstruct nft_set_ext *nft_set_catchall_lookup(const struct net *net,\n\t\t\t\t\t    const struct nft_set *set);\n\nstatic inline unsigned long nft_set_gc_interval(const struct nft_set *set)\n{\n\tu32 gc_int = READ_ONCE(set->gc_int);\n\n\treturn gc_int ? msecs_to_jiffies(gc_int) : HZ;\n}\n\n/**\n *\tstruct nft_set_binding - nf_tables set binding\n *\n *\t@list: set bindings list node\n *\t@chain: chain containing the rule bound to the set\n *\t@flags: set action flags\n *\n *\tA set binding contains all information necessary for validation\n *\tof new elements added to a bound set.\n */\nstruct nft_set_binding {\n\tstruct list_head\t\tlist;\n\tconst struct nft_chain\t\t*chain;\n\tu32\t\t\t\tflags;\n};\n\nenum nft_trans_phase;\nvoid nf_tables_activate_set(const struct nft_ctx *ctx, struct nft_set *set);\nvoid nf_tables_deactivate_set(const struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t      struct nft_set_binding *binding,\n\t\t\t      enum nft_trans_phase phase);\nint nf_tables_bind_set(const struct nft_ctx *ctx, struct nft_set *set,\n\t\t       struct nft_set_binding *binding);\nvoid nf_tables_destroy_set(const struct nft_ctx *ctx, struct nft_set *set);\n\n/**\n *\tenum nft_set_extensions - set extension type IDs\n *\n *\t@NFT_SET_EXT_KEY: element key\n *\t@NFT_SET_EXT_KEY_END: upper bound element key, for ranges\n *\t@NFT_SET_EXT_DATA: mapping data\n *\t@NFT_SET_EXT_FLAGS: element flags\n *\t@NFT_SET_EXT_TIMEOUT: element timeout\n *\t@NFT_SET_EXT_EXPIRATION: element expiration time\n *\t@NFT_SET_EXT_USERDATA: user data associated with the element\n *\t@NFT_SET_EXT_EXPRESSIONS: expressions assiciated with the element\n *\t@NFT_SET_EXT_OBJREF: stateful object reference associated with element\n *\t@NFT_SET_EXT_NUM: number of extension types\n */\nenum nft_set_extensions {\n\tNFT_SET_EXT_KEY,\n\tNFT_SET_EXT_KEY_END,\n\tNFT_SET_EXT_DATA,\n\tNFT_SET_EXT_FLAGS,\n\tNFT_SET_EXT_TIMEOUT,\n\tNFT_SET_EXT_EXPIRATION,\n\tNFT_SET_EXT_USERDATA,\n\tNFT_SET_EXT_EXPRESSIONS,\n\tNFT_SET_EXT_OBJREF,\n\tNFT_SET_EXT_NUM\n};\n\n/**\n *\tstruct nft_set_ext_type - set extension type\n *\n * \t@len: fixed part length of the extension\n * \t@align: alignment requirements of the extension\n */\nstruct nft_set_ext_type {\n\tu8\tlen;\n\tu8\talign;\n};\n\nextern const struct nft_set_ext_type nft_set_ext_types[];\n\n/**\n *\tstruct nft_set_ext_tmpl - set extension template\n *\n *\t@len: length of extension area\n *\t@offset: offsets of individual extension types\n */\nstruct nft_set_ext_tmpl {\n\tu16\tlen;\n\tu8\toffset[NFT_SET_EXT_NUM];\n\tu8\text_len[NFT_SET_EXT_NUM];\n};\n\n/**\n *\tstruct nft_set_ext - set extensions\n *\n *\t@genmask: generation mask\n *\t@offset: offsets of individual extension types\n *\t@data: beginning of extension data\n */\nstruct nft_set_ext {\n\tu8\tgenmask;\n\tu8\toffset[NFT_SET_EXT_NUM];\n\tchar\tdata[];\n};\n\nstatic inline void nft_set_ext_prepare(struct nft_set_ext_tmpl *tmpl)\n{\n\tmemset(tmpl, 0, sizeof(*tmpl));\n\ttmpl->len = sizeof(struct nft_set_ext);\n}\n\nstatic inline int nft_set_ext_add_length(struct nft_set_ext_tmpl *tmpl, u8 id,\n\t\t\t\t\t unsigned int len)\n{\n\ttmpl->len\t = ALIGN(tmpl->len, nft_set_ext_types[id].align);\n\tif (tmpl->len > U8_MAX)\n\t\treturn -EINVAL;\n\n\ttmpl->offset[id] = tmpl->len;\n\ttmpl->ext_len[id] = nft_set_ext_types[id].len + len;\n\ttmpl->len\t+= tmpl->ext_len[id];\n\n\treturn 0;\n}\n\nstatic inline int nft_set_ext_add(struct nft_set_ext_tmpl *tmpl, u8 id)\n{\n\treturn nft_set_ext_add_length(tmpl, id, 0);\n}\n\nstatic inline void nft_set_ext_init(struct nft_set_ext *ext,\n\t\t\t\t    const struct nft_set_ext_tmpl *tmpl)\n{\n\tmemcpy(ext->offset, tmpl->offset, sizeof(ext->offset));\n}\n\nstatic inline bool __nft_set_ext_exists(const struct nft_set_ext *ext, u8 id)\n{\n\treturn !!ext->offset[id];\n}\n\nstatic inline bool nft_set_ext_exists(const struct nft_set_ext *ext, u8 id)\n{\n\treturn ext && __nft_set_ext_exists(ext, id);\n}\n\nstatic inline void *nft_set_ext(const struct nft_set_ext *ext, u8 id)\n{\n\treturn (void *)ext + ext->offset[id];\n}\n\nstatic inline struct nft_data *nft_set_ext_key(const struct nft_set_ext *ext)\n{\n\treturn nft_set_ext(ext, NFT_SET_EXT_KEY);\n}\n\nstatic inline struct nft_data *nft_set_ext_key_end(const struct nft_set_ext *ext)\n{\n\treturn nft_set_ext(ext, NFT_SET_EXT_KEY_END);\n}\n\nstatic inline struct nft_data *nft_set_ext_data(const struct nft_set_ext *ext)\n{\n\treturn nft_set_ext(ext, NFT_SET_EXT_DATA);\n}\n\nstatic inline u8 *nft_set_ext_flags(const struct nft_set_ext *ext)\n{\n\treturn nft_set_ext(ext, NFT_SET_EXT_FLAGS);\n}\n\nstatic inline u64 *nft_set_ext_timeout(const struct nft_set_ext *ext)\n{\n\treturn nft_set_ext(ext, NFT_SET_EXT_TIMEOUT);\n}\n\nstatic inline u64 *nft_set_ext_expiration(const struct nft_set_ext *ext)\n{\n\treturn nft_set_ext(ext, NFT_SET_EXT_EXPIRATION);\n}\n\nstatic inline struct nft_userdata *nft_set_ext_userdata(const struct nft_set_ext *ext)\n{\n\treturn nft_set_ext(ext, NFT_SET_EXT_USERDATA);\n}\n\nstatic inline struct nft_set_elem_expr *nft_set_ext_expr(const struct nft_set_ext *ext)\n{\n\treturn nft_set_ext(ext, NFT_SET_EXT_EXPRESSIONS);\n}\n\nstatic inline bool nft_set_elem_expired(const struct nft_set_ext *ext)\n{\n\treturn nft_set_ext_exists(ext, NFT_SET_EXT_EXPIRATION) &&\n\t       time_is_before_eq_jiffies64(*nft_set_ext_expiration(ext));\n}\n\nstatic inline struct nft_set_ext *nft_set_elem_ext(const struct nft_set *set,\n\t\t\t\t\t\t   const struct nft_elem_priv *elem_priv)\n{\n\treturn (void *)elem_priv + set->ops->elemsize;\n}\n\nstatic inline struct nft_object **nft_set_ext_obj(const struct nft_set_ext *ext)\n{\n\treturn nft_set_ext(ext, NFT_SET_EXT_OBJREF);\n}\n\nstruct nft_expr *nft_set_elem_expr_alloc(const struct nft_ctx *ctx,\n\t\t\t\t\t const struct nft_set *set,\n\t\t\t\t\t const struct nlattr *attr);\n\nstruct nft_elem_priv *nft_set_elem_init(const struct nft_set *set,\n\t\t\t\t\tconst struct nft_set_ext_tmpl *tmpl,\n\t\t\t\t\tconst u32 *key, const u32 *key_end,\n\t\t\t\t\tconst u32 *data,\n\t\t\t\t\tu64 timeout, u64 expiration, gfp_t gfp);\nint nft_set_elem_expr_clone(const struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t    struct nft_expr *expr_array[]);\nvoid nft_set_elem_destroy(const struct nft_set *set,\n\t\t\t  const struct nft_elem_priv *elem_priv,\n\t\t\t  bool destroy_expr);\nvoid nf_tables_set_elem_destroy(const struct nft_ctx *ctx,\n\t\t\t\tconst struct nft_set *set,\n\t\t\t\tconst struct nft_elem_priv *elem_priv);\n\nstruct nft_expr_ops;\n/**\n *\tstruct nft_expr_type - nf_tables expression type\n *\n *\t@select_ops: function to select nft_expr_ops\n *\t@release_ops: release nft_expr_ops\n *\t@ops: default ops, used when no select_ops functions is present\n *\t@list: used internally\n *\t@name: Identifier\n *\t@owner: module reference\n *\t@policy: netlink attribute policy\n *\t@maxattr: highest netlink attribute number\n *\t@family: address family for AF-specific types\n *\t@flags: expression type flags\n */\nstruct nft_expr_type {\n\tconst struct nft_expr_ops\t*(*select_ops)(const struct nft_ctx *,\n\t\t\t\t\t\t       const struct nlattr * const tb[]);\n\tvoid\t\t\t\t(*release_ops)(const struct nft_expr_ops *ops);\n\tconst struct nft_expr_ops\t*ops;\n\tconst struct nft_expr_ops\t*inner_ops;\n\tstruct list_head\t\tlist;\n\tconst char\t\t\t*name;\n\tstruct module\t\t\t*owner;\n\tconst struct nla_policy\t\t*policy;\n\tunsigned int\t\t\tmaxattr;\n\tu8\t\t\t\tfamily;\n\tu8\t\t\t\tflags;\n};\n\n#define NFT_EXPR_STATEFUL\t\t0x1\n#define NFT_EXPR_GC\t\t\t0x2\n\nenum nft_trans_phase {\n\tNFT_TRANS_PREPARE,\n\tNFT_TRANS_PREPARE_ERROR,\n\tNFT_TRANS_ABORT,\n\tNFT_TRANS_COMMIT,\n\tNFT_TRANS_RELEASE\n};\n\nstruct nft_flow_rule;\nstruct nft_offload_ctx;\n\n/**\n *\tstruct nft_expr_ops - nf_tables expression operations\n *\n *\t@eval: Expression evaluation function\n *\t@size: full expression size, including private data size\n *\t@init: initialization function\n *\t@activate: activate expression in the next generation\n *\t@deactivate: deactivate expression in next generation\n *\t@destroy: destruction function, called after synchronize_rcu\n *\t@dump: function to dump parameters\n *\t@type: expression type\n *\t@validate: validate expression, called during loop detection\n *\t@data: extra data to attach to this expression operation\n */\nstruct nft_expr_ops {\n\tvoid\t\t\t\t(*eval)(const struct nft_expr *expr,\n\t\t\t\t\t\tstruct nft_regs *regs,\n\t\t\t\t\t\tconst struct nft_pktinfo *pkt);\n\tint\t\t\t\t(*clone)(struct nft_expr *dst,\n\t\t\t\t\t\t const struct nft_expr *src);\n\tunsigned int\t\t\tsize;\n\n\tint\t\t\t\t(*init)(const struct nft_ctx *ctx,\n\t\t\t\t\t\tconst struct nft_expr *expr,\n\t\t\t\t\t\tconst struct nlattr * const tb[]);\n\tvoid\t\t\t\t(*activate)(const struct nft_ctx *ctx,\n\t\t\t\t\t\t    const struct nft_expr *expr);\n\tvoid\t\t\t\t(*deactivate)(const struct nft_ctx *ctx,\n\t\t\t\t\t\t      const struct nft_expr *expr,\n\t\t\t\t\t\t      enum nft_trans_phase phase);\n\tvoid\t\t\t\t(*destroy)(const struct nft_ctx *ctx,\n\t\t\t\t\t\t   const struct nft_expr *expr);\n\tvoid\t\t\t\t(*destroy_clone)(const struct nft_ctx *ctx,\n\t\t\t\t\t\t\t const struct nft_expr *expr);\n\tint\t\t\t\t(*dump)(struct sk_buff *skb,\n\t\t\t\t\t\tconst struct nft_expr *expr,\n\t\t\t\t\t\tbool reset);\n\tint\t\t\t\t(*validate)(const struct nft_ctx *ctx,\n\t\t\t\t\t\t    const struct nft_expr *expr,\n\t\t\t\t\t\t    const struct nft_data **data);\n\tbool\t\t\t\t(*reduce)(struct nft_regs_track *track,\n\t\t\t\t\t\t  const struct nft_expr *expr);\n\tbool\t\t\t\t(*gc)(struct net *net,\n\t\t\t\t\t      const struct nft_expr *expr);\n\tint\t\t\t\t(*offload)(struct nft_offload_ctx *ctx,\n\t\t\t\t\t\t   struct nft_flow_rule *flow,\n\t\t\t\t\t\t   const struct nft_expr *expr);\n\tbool\t\t\t\t(*offload_action)(const struct nft_expr *expr);\n\tvoid\t\t\t\t(*offload_stats)(struct nft_expr *expr,\n\t\t\t\t\t\t\t const struct flow_stats *stats);\n\tconst struct nft_expr_type\t*type;\n\tvoid\t\t\t\t*data;\n};\n\n/**\n *\tstruct nft_rule - nf_tables rule\n *\n *\t@list: used internally\n *\t@handle: rule handle\n *\t@genmask: generation mask\n *\t@dlen: length of expression data\n *\t@udata: user data is appended to the rule\n *\t@data: expression data\n */\nstruct nft_rule {\n\tstruct list_head\t\tlist;\n\tu64\t\t\t\thandle:42,\n\t\t\t\t\tgenmask:2,\n\t\t\t\t\tdlen:12,\n\t\t\t\t\tudata:1;\n\tunsigned char\t\t\tdata[]\n\t\t__attribute__((aligned(__alignof__(struct nft_expr))));\n};\n\nstatic inline struct nft_expr *nft_expr_first(const struct nft_rule *rule)\n{\n\treturn (struct nft_expr *)&rule->data[0];\n}\n\nstatic inline struct nft_expr *nft_expr_next(const struct nft_expr *expr)\n{\n\treturn ((void *)expr) + expr->ops->size;\n}\n\nstatic inline struct nft_expr *nft_expr_last(const struct nft_rule *rule)\n{\n\treturn (struct nft_expr *)&rule->data[rule->dlen];\n}\n\nstatic inline bool nft_expr_more(const struct nft_rule *rule,\n\t\t\t\t const struct nft_expr *expr)\n{\n\treturn expr != nft_expr_last(rule) && expr->ops;\n}\n\nstatic inline struct nft_userdata *nft_userdata(const struct nft_rule *rule)\n{\n\treturn (void *)&rule->data[rule->dlen];\n}\n\nvoid nft_rule_expr_activate(const struct nft_ctx *ctx, struct nft_rule *rule);\nvoid nft_rule_expr_deactivate(const struct nft_ctx *ctx, struct nft_rule *rule,\n\t\t\t      enum nft_trans_phase phase);\nvoid nf_tables_rule_destroy(const struct nft_ctx *ctx, struct nft_rule *rule);\n\nstatic inline void nft_set_elem_update_expr(const struct nft_set_ext *ext,\n\t\t\t\t\t    struct nft_regs *regs,\n\t\t\t\t\t    const struct nft_pktinfo *pkt)\n{\n\tstruct nft_set_elem_expr *elem_expr;\n\tstruct nft_expr *expr;\n\tu32 size;\n\n\tif (__nft_set_ext_exists(ext, NFT_SET_EXT_EXPRESSIONS)) {\n\t\telem_expr = nft_set_ext_expr(ext);\n\t\tnft_setelem_expr_foreach(expr, elem_expr, size) {\n\t\t\texpr->ops->eval(expr, regs, pkt);\n\t\t\tif (regs->verdict.code == NFT_BREAK)\n\t\t\t\treturn;\n\t\t}\n\t}\n}\n\n/*\n * The last pointer isn't really necessary, but the compiler isn't able to\n * determine that the result of nft_expr_last() is always the same since it\n * can't assume that the dlen value wasn't changed within calls in the loop.\n */\n#define nft_rule_for_each_expr(expr, last, rule) \\\n\tfor ((expr) = nft_expr_first(rule), (last) = nft_expr_last(rule); \\\n\t     (expr) != (last); \\\n\t     (expr) = nft_expr_next(expr))\n\n#define NFT_CHAIN_POLICY_UNSET\t\tU8_MAX\n\nstruct nft_rule_dp {\n\tu64\t\t\t\tis_last:1,\n\t\t\t\t\tdlen:12,\n\t\t\t\t\thandle:42;\t/* for tracing */\n\tunsigned char\t\t\tdata[]\n\t\t__attribute__((aligned(__alignof__(struct nft_expr))));\n};\n\nstruct nft_rule_dp_last {\n\tstruct nft_rule_dp end;\t\t/* end of nft_rule_blob marker */\n\tstruct rcu_head h;\t\t/* call_rcu head */\n\tstruct nft_rule_blob *blob;\t/* ptr to free via call_rcu */\n\tconst struct nft_chain *chain;\t/* for nftables tracing */\n};\n\nstatic inline const struct nft_rule_dp *nft_rule_next(const struct nft_rule_dp *rule)\n{\n\treturn (void *)rule + sizeof(*rule) + rule->dlen;\n}\n\nstruct nft_rule_blob {\n\tunsigned long\t\t\tsize;\n\tunsigned char\t\t\tdata[]\n\t\t__attribute__((aligned(__alignof__(struct nft_rule_dp))));\n};\n\n/**\n *\tstruct nft_chain - nf_tables chain\n *\n *\t@rules: list of rules in the chain\n *\t@list: used internally\n *\t@rhlhead: used internally\n *\t@table: table that this chain belongs to\n *\t@handle: chain handle\n *\t@use: number of jump references to this chain\n *\t@flags: bitmask of enum nft_chain_flags\n *\t@name: name of the chain\n */\nstruct nft_chain {\n\tstruct nft_rule_blob\t\t__rcu *blob_gen_0;\n\tstruct nft_rule_blob\t\t__rcu *blob_gen_1;\n\tstruct list_head\t\trules;\n\tstruct list_head\t\tlist;\n\tstruct rhlist_head\t\trhlhead;\n\tstruct nft_table\t\t*table;\n\tu64\t\t\t\thandle;\n\tu32\t\t\t\tuse;\n\tu8\t\t\t\tflags:5,\n\t\t\t\t\tbound:1,\n\t\t\t\t\tgenmask:2;\n\tchar\t\t\t\t*name;\n\tu16\t\t\t\tudlen;\n\tu8\t\t\t\t*udata;\n\n\t/* Only used during control plane commit phase: */\n\tstruct nft_rule_blob\t\t*blob_next;\n};\n\nint nft_chain_validate(const struct nft_ctx *ctx, const struct nft_chain *chain);\nint nft_setelem_validate(const struct nft_ctx *ctx, struct nft_set *set,\n\t\t\t const struct nft_set_iter *iter,\n\t\t\t struct nft_elem_priv *elem_priv);\nint nft_set_catchall_validate(const struct nft_ctx *ctx, struct nft_set *set);\nint nf_tables_bind_chain(const struct nft_ctx *ctx, struct nft_chain *chain);\nvoid nf_tables_unbind_chain(const struct nft_ctx *ctx, struct nft_chain *chain);\n\nenum nft_chain_types {\n\tNFT_CHAIN_T_DEFAULT = 0,\n\tNFT_CHAIN_T_ROUTE,\n\tNFT_CHAIN_T_NAT,\n\tNFT_CHAIN_T_MAX\n};\n\n/**\n * \tstruct nft_chain_type - nf_tables chain type info\n *\n * \t@name: name of the type\n * \t@type: numeric identifier\n * \t@family: address family\n * \t@owner: module owner\n * \t@hook_mask: mask of valid hooks\n * \t@hooks: array of hook functions\n *\t@ops_register: base chain register function\n *\t@ops_unregister: base chain unregister function\n */\nstruct nft_chain_type {\n\tconst char\t\t\t*name;\n\tenum nft_chain_types\t\ttype;\n\tint\t\t\t\tfamily;\n\tstruct module\t\t\t*owner;\n\tunsigned int\t\t\thook_mask;\n\tnf_hookfn\t\t\t*hooks[NFT_MAX_HOOKS];\n\tint\t\t\t\t(*ops_register)(struct net *net, const struct nf_hook_ops *ops);\n\tvoid\t\t\t\t(*ops_unregister)(struct net *net, const struct nf_hook_ops *ops);\n};\n\nint nft_chain_validate_dependency(const struct nft_chain *chain,\n\t\t\t\t  enum nft_chain_types type);\nint nft_chain_validate_hooks(const struct nft_chain *chain,\n                             unsigned int hook_flags);\n\nstatic inline bool nft_chain_binding(const struct nft_chain *chain)\n{\n\treturn chain->flags & NFT_CHAIN_BINDING;\n}\n\nstatic inline bool nft_chain_is_bound(struct nft_chain *chain)\n{\n\treturn (chain->flags & NFT_CHAIN_BINDING) && chain->bound;\n}\n\nint nft_chain_add(struct nft_table *table, struct nft_chain *chain);\nvoid nft_chain_del(struct nft_chain *chain);\nvoid nf_tables_chain_destroy(struct nft_ctx *ctx);\n\nstruct nft_stats {\n\tu64\t\t\tbytes;\n\tu64\t\t\tpkts;\n\tstruct u64_stats_sync\tsyncp;\n};\n\nstruct nft_hook {\n\tstruct list_head\tlist;\n\tstruct nf_hook_ops\tops;\n\tstruct rcu_head\t\trcu;\n};\n\n/**\n *\tstruct nft_base_chain - nf_tables base chain\n *\n *\t@ops: netfilter hook ops\n *\t@hook_list: list of netfilter hooks (for NFPROTO_NETDEV family)\n *\t@type: chain type\n *\t@policy: default policy\n *\t@stats: per-cpu chain stats\n *\t@chain: the chain\n *\t@flow_block: flow block (for hardware offload)\n */\nstruct nft_base_chain {\n\tstruct nf_hook_ops\t\tops;\n\tstruct list_head\t\thook_list;\n\tconst struct nft_chain_type\t*type;\n\tu8\t\t\t\tpolicy;\n\tu8\t\t\t\tflags;\n\tstruct nft_stats __percpu\t*stats;\n\tstruct nft_chain\t\tchain;\n\tstruct flow_block\t\tflow_block;\n};\n\nstatic inline struct nft_base_chain *nft_base_chain(const struct nft_chain *chain)\n{\n\treturn container_of(chain, struct nft_base_chain, chain);\n}\n\nstatic inline bool nft_is_base_chain(const struct nft_chain *chain)\n{\n\treturn chain->flags & NFT_CHAIN_BASE;\n}\n\nint __nft_release_basechain(struct nft_ctx *ctx);\n\nunsigned int nft_do_chain(struct nft_pktinfo *pkt, void *priv);\n\nstatic inline bool nft_use_inc(u32 *use)\n{\n\tif (*use == UINT_MAX)\n\t\treturn false;\n\n\t(*use)++;\n\n\treturn true;\n}\n\nstatic inline void nft_use_dec(u32 *use)\n{\n\tWARN_ON_ONCE((*use)-- == 0);\n}\n\n/* For error and abort path: restore use counter to previous state. */\nstatic inline void nft_use_inc_restore(u32 *use)\n{\n\tWARN_ON_ONCE(!nft_use_inc(use));\n}\n\n#define nft_use_dec_restore\tnft_use_dec\n\n/**\n *\tstruct nft_table - nf_tables table\n *\n *\t@list: used internally\n *\t@chains_ht: chains in the table\n *\t@chains: same, for stable walks\n *\t@sets: sets in the table\n *\t@objects: stateful objects in the table\n *\t@flowtables: flow tables in the table\n *\t@hgenerator: handle generator state\n *\t@handle: table handle\n *\t@use: number of chain references to this table\n *\t@family:address family\n *\t@flags: table flag (see enum nft_table_flags)\n *\t@genmask: generation mask\n *\t@nlpid: netlink port ID\n *\t@name: name of the table\n *\t@udlen: length of the user data\n *\t@udata: user data\n *\t@validate_state: internal, set when transaction adds jumps\n */\nstruct nft_table {\n\tstruct list_head\t\tlist;\n\tstruct rhltable\t\t\tchains_ht;\n\tstruct list_head\t\tchains;\n\tstruct list_head\t\tsets;\n\tstruct list_head\t\tobjects;\n\tstruct list_head\t\tflowtables;\n\tu64\t\t\t\thgenerator;\n\tu64\t\t\t\thandle;\n\tu32\t\t\t\tuse;\n\tu16\t\t\t\tfamily:6,\n\t\t\t\t\tflags:8,\n\t\t\t\t\tgenmask:2;\n\tu32\t\t\t\tnlpid;\n\tchar\t\t\t\t*name;\n\tu16\t\t\t\tudlen;\n\tu8\t\t\t\t*udata;\n\tu8\t\t\t\tvalidate_state;\n};\n\nstatic inline bool nft_table_has_owner(const struct nft_table *table)\n{\n\treturn table->flags & NFT_TABLE_F_OWNER;\n}\n\nstatic inline bool nft_base_chain_netdev(int family, u32 hooknum)\n{\n\treturn family == NFPROTO_NETDEV ||\n\t       (family == NFPROTO_INET && hooknum == NF_INET_INGRESS);\n}\n\nvoid nft_register_chain_type(const struct nft_chain_type *);\nvoid nft_unregister_chain_type(const struct nft_chain_type *);\n\nint nft_register_expr(struct nft_expr_type *);\nvoid nft_unregister_expr(struct nft_expr_type *);\n\nint nft_verdict_dump(struct sk_buff *skb, int type,\n\t\t     const struct nft_verdict *v);\n\n/**\n *\tstruct nft_object_hash_key - key to lookup nft_object\n *\n *\t@name: name of the stateful object to look up\n *\t@table: table the object belongs to\n */\nstruct nft_object_hash_key {\n\tconst char                      *name;\n\tconst struct nft_table          *table;\n};\n\n/**\n *\tstruct nft_object - nf_tables stateful object\n *\n *\t@list: table stateful object list node\n *\t@key:  keys that identify this object\n *\t@rhlhead: nft_objname_ht node\n *\t@genmask: generation mask\n *\t@use: number of references to this stateful object\n *\t@handle: unique object handle\n *\t@ops: object operations\n *\t@data: object data, layout depends on type\n */\nstruct nft_object {\n\tstruct list_head\t\tlist;\n\tstruct rhlist_head\t\trhlhead;\n\tstruct nft_object_hash_key\tkey;\n\tu32\t\t\t\tgenmask:2;\n\tu32\t\t\t\tuse;\n\tu64\t\t\t\thandle;\n\tu16\t\t\t\tudlen;\n\tu8\t\t\t\t*udata;\n\t/* runtime data below here */\n\tconst struct nft_object_ops\t*ops ____cacheline_aligned;\n\tunsigned char\t\t\tdata[]\n\t\t__attribute__((aligned(__alignof__(u64))));\n};\n\nstatic inline void *nft_obj_data(const struct nft_object *obj)\n{\n\treturn (void *)obj->data;\n}\n\n#define nft_expr_obj(expr)\t*((struct nft_object **)nft_expr_priv(expr))\n\nstruct nft_object *nft_obj_lookup(const struct net *net,\n\t\t\t\t  const struct nft_table *table,\n\t\t\t\t  const struct nlattr *nla, u32 objtype,\n\t\t\t\t  u8 genmask);\n\nvoid nft_obj_notify(struct net *net, const struct nft_table *table,\n\t\t    struct nft_object *obj, u32 portid, u32 seq,\n\t\t    int event, u16 flags, int family, int report, gfp_t gfp);\n\n/**\n *\tstruct nft_object_type - stateful object type\n *\n *\t@select_ops: function to select nft_object_ops\n *\t@ops: default ops, used when no select_ops functions is present\n *\t@list: list node in list of object types\n *\t@type: stateful object numeric type\n *\t@owner: module owner\n *\t@maxattr: maximum netlink attribute\n *\t@policy: netlink attribute policy\n */\nstruct nft_object_type {\n\tconst struct nft_object_ops\t*(*select_ops)(const struct nft_ctx *,\n\t\t\t\t\t\t       const struct nlattr * const tb[]);\n\tconst struct nft_object_ops\t*ops;\n\tstruct list_head\t\tlist;\n\tu32\t\t\t\ttype;\n\tunsigned int                    maxattr;\n\tstruct module\t\t\t*owner;\n\tconst struct nla_policy\t\t*policy;\n};\n\n/**\n *\tstruct nft_object_ops - stateful object operations\n *\n *\t@eval: stateful object evaluation function\n *\t@size: stateful object size\n *\t@init: initialize object from netlink attributes\n *\t@destroy: release existing stateful object\n *\t@dump: netlink dump stateful object\n *\t@update: update stateful object\n */\nstruct nft_object_ops {\n\tvoid\t\t\t\t(*eval)(struct nft_object *obj,\n\t\t\t\t\t\tstruct nft_regs *regs,\n\t\t\t\t\t\tconst struct nft_pktinfo *pkt);\n\tunsigned int\t\t\tsize;\n\tint\t\t\t\t(*init)(const struct nft_ctx *ctx,\n\t\t\t\t\t\tconst struct nlattr *const tb[],\n\t\t\t\t\t\tstruct nft_object *obj);\n\tvoid\t\t\t\t(*destroy)(const struct nft_ctx *ctx,\n\t\t\t\t\t\t   struct nft_object *obj);\n\tint\t\t\t\t(*dump)(struct sk_buff *skb,\n\t\t\t\t\t\tstruct nft_object *obj,\n\t\t\t\t\t\tbool reset);\n\tvoid\t\t\t\t(*update)(struct nft_object *obj,\n\t\t\t\t\t\t  struct nft_object *newobj);\n\tconst struct nft_object_type\t*type;\n};\n\nint nft_register_obj(struct nft_object_type *obj_type);\nvoid nft_unregister_obj(struct nft_object_type *obj_type);\n\n#define NFT_NETDEVICE_MAX\t256\n\n/**\n *\tstruct nft_flowtable - nf_tables flow table\n *\n *\t@list: flow table list node in table list\n * \t@table: the table the flow table is contained in\n *\t@name: name of this flow table\n *\t@hooknum: hook number\n *\t@ops_len: number of hooks in array\n *\t@genmask: generation mask\n *\t@use: number of references to this flow table\n * \t@handle: unique object handle\n *\t@dev_name: array of device names\n *\t@data: rhashtable and garbage collector\n * \t@ops: array of hooks\n */\nstruct nft_flowtable {\n\tstruct list_head\t\tlist;\n\tstruct nft_table\t\t*table;\n\tchar\t\t\t\t*name;\n\tint\t\t\t\thooknum;\n\tint\t\t\t\tops_len;\n\tu32\t\t\t\tgenmask:2;\n\tu32\t\t\t\tuse;\n\tu64\t\t\t\thandle;\n\t/* runtime data below here */\n\tstruct list_head\t\thook_list ____cacheline_aligned;\n\tstruct nf_flowtable\t\tdata;\n};\n\nstruct nft_flowtable *nft_flowtable_lookup(const struct nft_table *table,\n\t\t\t\t\t   const struct nlattr *nla,\n\t\t\t\t\t   u8 genmask);\n\nvoid nf_tables_deactivate_flowtable(const struct nft_ctx *ctx,\n\t\t\t\t    struct nft_flowtable *flowtable,\n\t\t\t\t    enum nft_trans_phase phase);\n\nvoid nft_register_flowtable_type(struct nf_flowtable_type *type);\nvoid nft_unregister_flowtable_type(struct nf_flowtable_type *type);\n\n/**\n *\tstruct nft_traceinfo - nft tracing information and state\n *\n *\t@trace: other struct members are initialised\n *\t@nf_trace: copy of skb->nf_trace before rule evaluation\n *\t@type: event type (enum nft_trace_types)\n *\t@skbid: hash of skb to be used as trace id\n *\t@packet_dumped: packet headers sent in a previous traceinfo message\n *\t@basechain: base chain currently processed\n */\nstruct nft_traceinfo {\n\tbool\t\t\t\ttrace;\n\tbool\t\t\t\tnf_trace;\n\tbool\t\t\t\tpacket_dumped;\n\tenum nft_trace_types\t\ttype:8;\n\tu32\t\t\t\tskbid;\n\tconst struct nft_base_chain\t*basechain;\n};\n\nvoid nft_trace_init(struct nft_traceinfo *info, const struct nft_pktinfo *pkt,\n\t\t    const struct nft_chain *basechain);\n\nvoid nft_trace_notify(const struct nft_pktinfo *pkt,\n\t\t      const struct nft_verdict *verdict,\n\t\t      const struct nft_rule_dp *rule,\n\t\t      struct nft_traceinfo *info);\n\n#define MODULE_ALIAS_NFT_CHAIN(family, name) \\\n\tMODULE_ALIAS(\"nft-chain-\" __stringify(family) \"-\" name)\n\n#define MODULE_ALIAS_NFT_AF_EXPR(family, name) \\\n\tMODULE_ALIAS(\"nft-expr-\" __stringify(family) \"-\" name)\n\n#define MODULE_ALIAS_NFT_EXPR(name) \\\n\tMODULE_ALIAS(\"nft-expr-\" name)\n\n#define MODULE_ALIAS_NFT_OBJ(type) \\\n\tMODULE_ALIAS(\"nft-obj-\" __stringify(type))\n\n#if IS_ENABLED(CONFIG_NF_TABLES)\n\n/*\n * The gencursor defines two generations, the currently active and the\n * next one. Objects contain a bitmask of 2 bits specifying the generations\n * they're active in. A set bit means they're inactive in the generation\n * represented by that bit.\n *\n * New objects start out as inactive in the current and active in the\n * next generation. When committing the ruleset the bitmask is cleared,\n * meaning they're active in all generations. When removing an object,\n * it is set inactive in the next generation. After committing the ruleset,\n * the objects are removed.\n */\nstatic inline unsigned int nft_gencursor_next(const struct net *net)\n{\n\treturn net->nft.gencursor + 1 == 1 ? 1 : 0;\n}\n\nstatic inline u8 nft_genmask_next(const struct net *net)\n{\n\treturn 1 << nft_gencursor_next(net);\n}\n\nstatic inline u8 nft_genmask_cur(const struct net *net)\n{\n\t/* Use READ_ONCE() to prevent refetching the value for atomicity */\n\treturn 1 << READ_ONCE(net->nft.gencursor);\n}\n\n#define NFT_GENMASK_ANY\t\t((1 << 0) | (1 << 1))\n\n/*\n * Generic transaction helpers\n */\n\n/* Check if this object is currently active. */\n#define nft_is_active(__net, __obj)\t\t\t\t\\\n\t(((__obj)->genmask & nft_genmask_cur(__net)) == 0)\n\n/* Check if this object is active in the next generation. */\n#define nft_is_active_next(__net, __obj)\t\t\t\\\n\t(((__obj)->genmask & nft_genmask_next(__net)) == 0)\n\n/* This object becomes active in the next generation. */\n#define nft_activate_next(__net, __obj)\t\t\t\t\\\n\t(__obj)->genmask = nft_genmask_cur(__net)\n\n/* This object becomes inactive in the next generation. */\n#define nft_deactivate_next(__net, __obj)\t\t\t\\\n        (__obj)->genmask = nft_genmask_next(__net)\n\n/* After committing the ruleset, clear the stale generation bit. */\n#define nft_clear(__net, __obj)\t\t\t\t\t\\\n\t(__obj)->genmask &= ~nft_genmask_next(__net)\n#define nft_active_genmask(__obj, __genmask)\t\t\t\\\n\t!((__obj)->genmask & __genmask)\n\n/*\n * Set element transaction helpers\n */\n\nstatic inline bool nft_set_elem_active(const struct nft_set_ext *ext,\n\t\t\t\t       u8 genmask)\n{\n\treturn !(ext->genmask & genmask);\n}\n\nstatic inline void nft_set_elem_change_active(const struct net *net,\n\t\t\t\t\t      const struct nft_set *set,\n\t\t\t\t\t      struct nft_set_ext *ext)\n{\n\text->genmask ^= nft_genmask_next(net);\n}\n\n#endif /* IS_ENABLED(CONFIG_NF_TABLES) */\n\n#define NFT_SET_ELEM_DEAD_MASK\t(1 << 2)\n\n#if defined(__LITTLE_ENDIAN_BITFIELD)\n#define NFT_SET_ELEM_DEAD_BIT\t2\n#elif defined(__BIG_ENDIAN_BITFIELD)\n#define NFT_SET_ELEM_DEAD_BIT\t(BITS_PER_LONG - BITS_PER_BYTE + 2)\n#else\n#error\n#endif\n\nstatic inline void nft_set_elem_dead(struct nft_set_ext *ext)\n{\n\tunsigned long *word = (unsigned long *)ext;\n\n\tBUILD_BUG_ON(offsetof(struct nft_set_ext, genmask) != 0);\n\tset_bit(NFT_SET_ELEM_DEAD_BIT, word);\n}\n\nstatic inline int nft_set_elem_is_dead(const struct nft_set_ext *ext)\n{\n\tunsigned long *word = (unsigned long *)ext;\n\n\tBUILD_BUG_ON(offsetof(struct nft_set_ext, genmask) != 0);\n\treturn test_bit(NFT_SET_ELEM_DEAD_BIT, word);\n}\n\n/**\n *\tstruct nft_trans - nf_tables object update in transaction\n *\n *\t@list: used internally\n *\t@binding_list: list of objects with possible bindings\n *\t@msg_type: message type\n *\t@put_net: ctx->net needs to be put\n *\t@ctx: transaction context\n *\t@data: internal information related to the transaction\n */\nstruct nft_trans {\n\tstruct list_head\t\tlist;\n\tstruct list_head\t\tbinding_list;\n\tint\t\t\t\tmsg_type;\n\tbool\t\t\t\tput_net;\n\tstruct nft_ctx\t\t\tctx;\n\tchar\t\t\t\tdata[];\n};\n\nstruct nft_trans_rule {\n\tstruct nft_rule\t\t\t*rule;\n\tstruct nft_flow_rule\t\t*flow;\n\tu32\t\t\t\trule_id;\n\tbool\t\t\t\tbound;\n};\n\n#define nft_trans_rule(trans)\t\\\n\t(((struct nft_trans_rule *)trans->data)->rule)\n#define nft_trans_flow_rule(trans)\t\\\n\t(((struct nft_trans_rule *)trans->data)->flow)\n#define nft_trans_rule_id(trans)\t\\\n\t(((struct nft_trans_rule *)trans->data)->rule_id)\n#define nft_trans_rule_bound(trans)\t\\\n\t(((struct nft_trans_rule *)trans->data)->bound)\n\nstruct nft_trans_set {\n\tstruct nft_set\t\t\t*set;\n\tu32\t\t\t\tset_id;\n\tu32\t\t\t\tgc_int;\n\tu64\t\t\t\ttimeout;\n\tbool\t\t\t\tupdate;\n\tbool\t\t\t\tbound;\n\tu32\t\t\t\tsize;\n};\n\n#define nft_trans_set(trans)\t\\\n\t(((struct nft_trans_set *)trans->data)->set)\n#define nft_trans_set_id(trans)\t\\\n\t(((struct nft_trans_set *)trans->data)->set_id)\n#define nft_trans_set_bound(trans)\t\\\n\t(((struct nft_trans_set *)trans->data)->bound)\n#define nft_trans_set_update(trans)\t\\\n\t(((struct nft_trans_set *)trans->data)->update)\n#define nft_trans_set_timeout(trans)\t\\\n\t(((struct nft_trans_set *)trans->data)->timeout)\n#define nft_trans_set_gc_int(trans)\t\\\n\t(((struct nft_trans_set *)trans->data)->gc_int)\n#define nft_trans_set_size(trans)\t\\\n\t(((struct nft_trans_set *)trans->data)->size)\n\nstruct nft_trans_chain {\n\tstruct nft_chain\t\t*chain;\n\tbool\t\t\t\tupdate;\n\tchar\t\t\t\t*name;\n\tstruct nft_stats __percpu\t*stats;\n\tu8\t\t\t\tpolicy;\n\tbool\t\t\t\tbound;\n\tu32\t\t\t\tchain_id;\n\tstruct nft_base_chain\t\t*basechain;\n\tstruct list_head\t\thook_list;\n};\n\n#define nft_trans_chain(trans)\t\\\n\t(((struct nft_trans_chain *)trans->data)->chain)\n#define nft_trans_chain_update(trans)\t\\\n\t(((struct nft_trans_chain *)trans->data)->update)\n#define nft_trans_chain_name(trans)\t\\\n\t(((struct nft_trans_chain *)trans->data)->name)\n#define nft_trans_chain_stats(trans)\t\\\n\t(((struct nft_trans_chain *)trans->data)->stats)\n#define nft_trans_chain_policy(trans)\t\\\n\t(((struct nft_trans_chain *)trans->data)->policy)\n#define nft_trans_chain_bound(trans)\t\\\n\t(((struct nft_trans_chain *)trans->data)->bound)\n#define nft_trans_chain_id(trans)\t\\\n\t(((struct nft_trans_chain *)trans->data)->chain_id)\n#define nft_trans_basechain(trans)\t\\\n\t(((struct nft_trans_chain *)trans->data)->basechain)\n#define nft_trans_chain_hooks(trans)\t\\\n\t(((struct nft_trans_chain *)trans->data)->hook_list)\n\nstruct nft_trans_table {\n\tbool\t\t\t\tupdate;\n};\n\n#define nft_trans_table_update(trans)\t\\\n\t(((struct nft_trans_table *)trans->data)->update)\n\nstruct nft_trans_elem {\n\tstruct nft_set\t\t\t*set;\n\tstruct nft_elem_priv\t\t*elem_priv;\n\tbool\t\t\t\tbound;\n};\n\n#define nft_trans_elem_set(trans)\t\\\n\t(((struct nft_trans_elem *)trans->data)->set)\n#define nft_trans_elem_priv(trans)\t\\\n\t(((struct nft_trans_elem *)trans->data)->elem_priv)\n#define nft_trans_elem_set_bound(trans)\t\\\n\t(((struct nft_trans_elem *)trans->data)->bound)\n\nstruct nft_trans_obj {\n\tstruct nft_object\t\t*obj;\n\tstruct nft_object\t\t*newobj;\n\tbool\t\t\t\tupdate;\n};\n\n#define nft_trans_obj(trans)\t\\\n\t(((struct nft_trans_obj *)trans->data)->obj)\n#define nft_trans_obj_newobj(trans) \\\n\t(((struct nft_trans_obj *)trans->data)->newobj)\n#define nft_trans_obj_update(trans)\t\\\n\t(((struct nft_trans_obj *)trans->data)->update)\n\nstruct nft_trans_flowtable {\n\tstruct nft_flowtable\t\t*flowtable;\n\tbool\t\t\t\tupdate;\n\tstruct list_head\t\thook_list;\n\tu32\t\t\t\tflags;\n};\n\n#define nft_trans_flowtable(trans)\t\\\n\t(((struct nft_trans_flowtable *)trans->data)->flowtable)\n#define nft_trans_flowtable_update(trans)\t\\\n\t(((struct nft_trans_flowtable *)trans->data)->update)\n#define nft_trans_flowtable_hooks(trans)\t\\\n\t(((struct nft_trans_flowtable *)trans->data)->hook_list)\n#define nft_trans_flowtable_flags(trans)\t\\\n\t(((struct nft_trans_flowtable *)trans->data)->flags)\n\n#define NFT_TRANS_GC_BATCHCOUNT\t256\n\nstruct nft_trans_gc {\n\tstruct list_head\tlist;\n\tstruct net\t\t*net;\n\tstruct nft_set\t\t*set;\n\tu32\t\t\tseq;\n\tu16\t\t\tcount;\n\tstruct nft_elem_priv\t*priv[NFT_TRANS_GC_BATCHCOUNT];\n\tstruct rcu_head\t\trcu;\n};\n\nstruct nft_trans_gc *nft_trans_gc_alloc(struct nft_set *set,\n\t\t\t\t\tunsigned int gc_seq, gfp_t gfp);\nvoid nft_trans_gc_destroy(struct nft_trans_gc *trans);\n\nstruct nft_trans_gc *nft_trans_gc_queue_async(struct nft_trans_gc *gc,\n\t\t\t\t\t      unsigned int gc_seq, gfp_t gfp);\nvoid nft_trans_gc_queue_async_done(struct nft_trans_gc *gc);\n\nstruct nft_trans_gc *nft_trans_gc_queue_sync(struct nft_trans_gc *gc, gfp_t gfp);\nvoid nft_trans_gc_queue_sync_done(struct nft_trans_gc *trans);\n\nvoid nft_trans_gc_elem_add(struct nft_trans_gc *gc, void *priv);\n\nstruct nft_trans_gc *nft_trans_gc_catchall_async(struct nft_trans_gc *gc,\n\t\t\t\t\t\t unsigned int gc_seq);\nstruct nft_trans_gc *nft_trans_gc_catchall_sync(struct nft_trans_gc *gc);\n\nvoid nft_setelem_data_deactivate(const struct net *net,\n\t\t\t\t const struct nft_set *set,\n\t\t\t\t struct nft_elem_priv *elem_priv);\n\nint __init nft_chain_filter_init(void);\nvoid nft_chain_filter_fini(void);\n\nvoid __init nft_chain_route_init(void);\nvoid nft_chain_route_fini(void);\n\nvoid nf_tables_trans_destroy_flush_work(void);\n\nint nf_msecs_to_jiffies64(const struct nlattr *nla, u64 *result);\n__be64 nf_jiffies64_to_msecs(u64 input);\n\n#ifdef CONFIG_MODULES\n__printf(2, 3) int nft_request_module(struct net *net, const char *fmt, ...);\n#else\nstatic inline int nft_request_module(struct net *net, const char *fmt, ...) { return -ENOENT; }\n#endif\n\nstruct nftables_pernet {\n\tstruct list_head\ttables;\n\tstruct list_head\tcommit_list;\n\tstruct list_head\tbinding_list;\n\tstruct list_head\tmodule_list;\n\tstruct list_head\tnotify_list;\n\tstruct mutex\t\tcommit_mutex;\n\tu64\t\t\ttable_handle;\n\tunsigned int\t\tbase_seq;\n\tunsigned int\t\tgc_seq;\n\tu8\t\t\tvalidate_state;\n};\n\nextern unsigned int nf_tables_net_id;\n\nstatic inline struct nftables_pernet *nft_pernet(const struct net *net)\n{\n\treturn net_generic(net, nf_tables_net_id);\n}\n\n#define __NFT_REDUCE_READONLY\t1UL\n#define NFT_REDUCE_READONLY\t(void *)__NFT_REDUCE_READONLY\n\nstatic inline bool nft_reduce_is_readonly(const struct nft_expr *expr)\n{\n\treturn expr->ops->reduce == NFT_REDUCE_READONLY;\n}\n\nvoid nft_reg_track_update(struct nft_regs_track *track,\n\t\t\t  const struct nft_expr *expr, u8 dreg, u8 len);\nvoid nft_reg_track_cancel(struct nft_regs_track *track, u8 dreg, u8 len);\nvoid __nft_reg_track_cancel(struct nft_regs_track *track, u8 dreg);\n\nstatic inline bool nft_reg_track_cmp(struct nft_regs_track *track,\n\t\t\t\t     const struct nft_expr *expr, u8 dreg)\n{\n\treturn track->regs[dreg].selector &&\n\t       track->regs[dreg].selector->ops == expr->ops &&\n\t       track->regs[dreg].num_reg == 0;\n}\n\n#endif /* _NET_NF_TABLES_H */\n", "// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Copyright (c) 2008-2009 Patrick McHardy <kaber@trash.net>\n *\n * Development of this code funded by Astaro AG (http://www.astaro.com/)\n */\n\n#include <asm/unaligned.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_core.h>\n#include <net/netfilter/nf_tables.h>\n\nstruct nft_byteorder {\n\tu8\t\t\tsreg;\n\tu8\t\t\tdreg;\n\tenum nft_byteorder_ops\top:8;\n\tu8\t\t\tlen;\n\tu8\t\t\tsize;\n};\n\nvoid nft_byteorder_eval(const struct nft_expr *expr,\n\t\t\tstruct nft_regs *regs,\n\t\t\tconst struct nft_pktinfo *pkt)\n{\n\tconst struct nft_byteorder *priv = nft_expr_priv(expr);\n\tu32 *src = &regs->data[priv->sreg];\n\tu32 *dst = &regs->data[priv->dreg];\n\tu16 *s16, *d16;\n\tunsigned int i;\n\n\ts16 = (void *)src;\n\td16 = (void *)dst;\n\n\tswitch (priv->size) {\n\tcase 8: {\n\t\tu64 *dst64 = (void *)dst;\n\t\tu64 src64;\n\n\t\tswitch (priv->op) {\n\t\tcase NFT_BYTEORDER_NTOH:\n\t\t\tfor (i = 0; i < priv->len / 8; i++) {\n\t\t\t\tsrc64 = nft_reg_load64(&src[i]);\n\t\t\t\tnft_reg_store64(&dst64[i],\n\t\t\t\t\t\tbe64_to_cpu((__force __be64)src64));\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NFT_BYTEORDER_HTON:\n\t\t\tfor (i = 0; i < priv->len / 8; i++) {\n\t\t\t\tsrc64 = (__force __u64)\n\t\t\t\t\tcpu_to_be64(nft_reg_load64(&src[i]));\n\t\t\t\tnft_reg_store64(&dst64[i], src64);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n\tcase 4:\n\t\tswitch (priv->op) {\n\t\tcase NFT_BYTEORDER_NTOH:\n\t\t\tfor (i = 0; i < priv->len / 4; i++)\n\t\t\t\tdst[i] = ntohl((__force __be32)src[i]);\n\t\t\tbreak;\n\t\tcase NFT_BYTEORDER_HTON:\n\t\t\tfor (i = 0; i < priv->len / 4; i++)\n\t\t\t\tdst[i] = (__force __u32)htonl(src[i]);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 2:\n\t\tswitch (priv->op) {\n\t\tcase NFT_BYTEORDER_NTOH:\n\t\t\tfor (i = 0; i < priv->len / 2; i++)\n\t\t\t\td16[i] = ntohs((__force __be16)s16[i]);\n\t\t\tbreak;\n\t\tcase NFT_BYTEORDER_HTON:\n\t\t\tfor (i = 0; i < priv->len / 2; i++)\n\t\t\t\td16[i] = (__force __u16)htons(s16[i]);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\t}\n}\n\nstatic const struct nla_policy nft_byteorder_policy[NFTA_BYTEORDER_MAX + 1] = {\n\t[NFTA_BYTEORDER_SREG]\t= { .type = NLA_U32 },\n\t[NFTA_BYTEORDER_DREG]\t= { .type = NLA_U32 },\n\t[NFTA_BYTEORDER_OP]\t= NLA_POLICY_MAX(NLA_BE32, 255),\n\t[NFTA_BYTEORDER_LEN]\t= NLA_POLICY_MAX(NLA_BE32, 255),\n\t[NFTA_BYTEORDER_SIZE]\t= NLA_POLICY_MAX(NLA_BE32, 255),\n};\n\nstatic int nft_byteorder_init(const struct nft_ctx *ctx,\n\t\t\t      const struct nft_expr *expr,\n\t\t\t      const struct nlattr * const tb[])\n{\n\tstruct nft_byteorder *priv = nft_expr_priv(expr);\n\tu32 size, len;\n\tint err;\n\n\tif (tb[NFTA_BYTEORDER_SREG] == NULL ||\n\t    tb[NFTA_BYTEORDER_DREG] == NULL ||\n\t    tb[NFTA_BYTEORDER_LEN] == NULL ||\n\t    tb[NFTA_BYTEORDER_SIZE] == NULL ||\n\t    tb[NFTA_BYTEORDER_OP] == NULL)\n\t\treturn -EINVAL;\n\n\tpriv->op = ntohl(nla_get_be32(tb[NFTA_BYTEORDER_OP]));\n\tswitch (priv->op) {\n\tcase NFT_BYTEORDER_NTOH:\n\tcase NFT_BYTEORDER_HTON:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\terr = nft_parse_u32_check(tb[NFTA_BYTEORDER_SIZE], U8_MAX, &size);\n\tif (err < 0)\n\t\treturn err;\n\n\tpriv->size = size;\n\n\tswitch (priv->size) {\n\tcase 2:\n\tcase 4:\n\tcase 8:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\terr = nft_parse_u32_check(tb[NFTA_BYTEORDER_LEN], U8_MAX, &len);\n\tif (err < 0)\n\t\treturn err;\n\n\tpriv->len = len;\n\n\terr = nft_parse_register_load(tb[NFTA_BYTEORDER_SREG], &priv->sreg,\n\t\t\t\t      priv->len);\n\tif (err < 0)\n\t\treturn err;\n\n\treturn nft_parse_register_store(ctx, tb[NFTA_BYTEORDER_DREG],\n\t\t\t\t\t&priv->dreg, NULL, NFT_DATA_VALUE,\n\t\t\t\t\tpriv->len);\n}\n\nstatic int nft_byteorder_dump(struct sk_buff *skb,\n\t\t\t      const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_byteorder *priv = nft_expr_priv(expr);\n\n\tif (nft_dump_register(skb, NFTA_BYTEORDER_SREG, priv->sreg))\n\t\tgoto nla_put_failure;\n\tif (nft_dump_register(skb, NFTA_BYTEORDER_DREG, priv->dreg))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_BYTEORDER_OP, htonl(priv->op)))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_BYTEORDER_LEN, htonl(priv->len)))\n\t\tgoto nla_put_failure;\n\tif (nla_put_be32(skb, NFTA_BYTEORDER_SIZE, htonl(priv->size)))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\n\nstatic bool nft_byteorder_reduce(struct nft_regs_track *track,\n\t\t\t\t const struct nft_expr *expr)\n{\n\tstruct nft_byteorder *priv = nft_expr_priv(expr);\n\n\tnft_reg_track_cancel(track, priv->dreg, priv->len);\n\n\treturn false;\n}\n\nstatic const struct nft_expr_ops nft_byteorder_ops = {\n\t.type\t\t= &nft_byteorder_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_byteorder)),\n\t.eval\t\t= nft_byteorder_eval,\n\t.init\t\t= nft_byteorder_init,\n\t.dump\t\t= nft_byteorder_dump,\n\t.reduce\t\t= nft_byteorder_reduce,\n};\n\nstruct nft_expr_type nft_byteorder_type __read_mostly = {\n\t.name\t\t= \"byteorder\",\n\t.ops\t\t= &nft_byteorder_ops,\n\t.policy\t\t= nft_byteorder_policy,\n\t.maxattr\t= NFTA_BYTEORDER_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n", "// SPDX-License-Identifier: GPL-2.0-only\n/*\n * Copyright (c) 2008-2009 Patrick McHardy <kaber@trash.net>\n * Copyright (c) 2014 Intel Corporation\n * Author: Tomasz Bursztyka <tomasz.bursztyka@linux.intel.com>\n *\n * Development of this code funded by Astaro AG (http://www.astaro.com/)\n */\n\n#include <linux/kernel.h>\n#include <linux/netlink.h>\n#include <linux/netfilter.h>\n#include <linux/netfilter/nf_tables.h>\n#include <linux/in.h>\n#include <linux/ip.h>\n#include <linux/ipv6.h>\n#include <linux/random.h>\n#include <linux/smp.h>\n#include <linux/static_key.h>\n#include <net/dst.h>\n#include <net/ip.h>\n#include <net/sock.h>\n#include <net/tcp_states.h> /* for TCP_TIME_WAIT */\n#include <net/netfilter/nf_tables.h>\n#include <net/netfilter/nf_tables_core.h>\n#include <net/netfilter/nft_meta.h>\n#include <net/netfilter/nf_tables_offload.h>\n\n#include <uapi/linux/netfilter_bridge.h> /* NF_BR_PRE_ROUTING */\n\n#define NFT_META_SECS_PER_MINUTE\t60\n#define NFT_META_SECS_PER_HOUR\t\t3600\n#define NFT_META_SECS_PER_DAY\t\t86400\n#define NFT_META_DAYS_PER_WEEK\t\t7\n\nstatic u8 nft_meta_weekday(void)\n{\n\ttime64_t secs = ktime_get_real_seconds();\n\tunsigned int dse;\n\tu8 wday;\n\n\tsecs -= NFT_META_SECS_PER_MINUTE * sys_tz.tz_minuteswest;\n\tdse = div_u64(secs, NFT_META_SECS_PER_DAY);\n\twday = (4 + dse) % NFT_META_DAYS_PER_WEEK;\n\n\treturn wday;\n}\n\nstatic u32 nft_meta_hour(time64_t secs)\n{\n\tstruct tm tm;\n\n\ttime64_to_tm(secs, 0, &tm);\n\n\treturn tm.tm_hour * NFT_META_SECS_PER_HOUR\n\t\t+ tm.tm_min * NFT_META_SECS_PER_MINUTE\n\t\t+ tm.tm_sec;\n}\n\nstatic noinline_for_stack void\nnft_meta_get_eval_time(enum nft_meta_keys key,\n\t\t       u32 *dest)\n{\n\tswitch (key) {\n\tcase NFT_META_TIME_NS:\n\t\tnft_reg_store64((u64 *)dest, ktime_get_real_ns());\n\t\tbreak;\n\tcase NFT_META_TIME_DAY:\n\t\tnft_reg_store8(dest, nft_meta_weekday());\n\t\tbreak;\n\tcase NFT_META_TIME_HOUR:\n\t\t*dest = nft_meta_hour(ktime_get_real_seconds());\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic noinline bool\nnft_meta_get_eval_pkttype_lo(const struct nft_pktinfo *pkt,\n\t\t\t     u32 *dest)\n{\n\tconst struct sk_buff *skb = pkt->skb;\n\n\tswitch (nft_pf(pkt)) {\n\tcase NFPROTO_IPV4:\n\t\tif (ipv4_is_multicast(ip_hdr(skb)->daddr))\n\t\t\tnft_reg_store8(dest, PACKET_MULTICAST);\n\t\telse\n\t\t\tnft_reg_store8(dest, PACKET_BROADCAST);\n\t\tbreak;\n\tcase NFPROTO_IPV6:\n\t\tnft_reg_store8(dest, PACKET_MULTICAST);\n\t\tbreak;\n\tcase NFPROTO_NETDEV:\n\t\tswitch (skb->protocol) {\n\t\tcase htons(ETH_P_IP): {\n\t\t\tint noff = skb_network_offset(skb);\n\t\t\tstruct iphdr *iph, _iph;\n\n\t\t\tiph = skb_header_pointer(skb, noff,\n\t\t\t\t\t\t sizeof(_iph), &_iph);\n\t\t\tif (!iph)\n\t\t\t\treturn false;\n\n\t\t\tif (ipv4_is_multicast(iph->daddr))\n\t\t\t\tnft_reg_store8(dest, PACKET_MULTICAST);\n\t\t\telse\n\t\t\t\tnft_reg_store8(dest, PACKET_BROADCAST);\n\n\t\t\tbreak;\n\t\t}\n\t\tcase htons(ETH_P_IPV6):\n\t\t\tnft_reg_store8(dest, PACKET_MULTICAST);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN_ON_ONCE(1);\n\t\t\treturn false;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic noinline bool\nnft_meta_get_eval_skugid(enum nft_meta_keys key,\n\t\t\t u32 *dest,\n\t\t\t const struct nft_pktinfo *pkt)\n{\n\tstruct sock *sk = skb_to_full_sk(pkt->skb);\n\tstruct socket *sock;\n\n\tif (!sk || !sk_fullsock(sk) || !net_eq(nft_net(pkt), sock_net(sk)))\n\t\treturn false;\n\n\tread_lock_bh(&sk->sk_callback_lock);\n\tsock = sk->sk_socket;\n\tif (!sock || !sock->file) {\n\t\tread_unlock_bh(&sk->sk_callback_lock);\n\t\treturn false;\n\t}\n\n\tswitch (key) {\n\tcase NFT_META_SKUID:\n\t\t*dest = from_kuid_munged(sock_net(sk)->user_ns,\n\t\t\t\t\t sock->file->f_cred->fsuid);\n\t\tbreak;\n\tcase NFT_META_SKGID:\n\t\t*dest =\tfrom_kgid_munged(sock_net(sk)->user_ns,\n\t\t\t\t\t sock->file->f_cred->fsgid);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tread_unlock_bh(&sk->sk_callback_lock);\n\treturn true;\n}\n\n#ifdef CONFIG_CGROUP_NET_CLASSID\nstatic noinline bool\nnft_meta_get_eval_cgroup(u32 *dest, const struct nft_pktinfo *pkt)\n{\n\tstruct sock *sk = skb_to_full_sk(pkt->skb);\n\n\tif (!sk || !sk_fullsock(sk) || !net_eq(nft_net(pkt), sock_net(sk)))\n\t\treturn false;\n\n\t*dest = sock_cgroup_classid(&sk->sk_cgrp_data);\n\treturn true;\n}\n#endif\n\nstatic noinline bool nft_meta_get_eval_kind(enum nft_meta_keys key,\n\t\t\t\t\t    u32 *dest,\n\t\t\t\t\t    const struct nft_pktinfo *pkt)\n{\n\tconst struct net_device *in = nft_in(pkt), *out = nft_out(pkt);\n\n\tswitch (key) {\n\tcase NFT_META_IIFKIND:\n\t\tif (!in || !in->rtnl_link_ops)\n\t\t\treturn false;\n\t\tstrscpy_pad((char *)dest, in->rtnl_link_ops->kind, IFNAMSIZ);\n\t\tbreak;\n\tcase NFT_META_OIFKIND:\n\t\tif (!out || !out->rtnl_link_ops)\n\t\t\treturn false;\n\t\tstrscpy_pad((char *)dest, out->rtnl_link_ops->kind, IFNAMSIZ);\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void nft_meta_store_ifindex(u32 *dest, const struct net_device *dev)\n{\n\t*dest = dev ? dev->ifindex : 0;\n}\n\nstatic void nft_meta_store_ifname(u32 *dest, const struct net_device *dev)\n{\n\tstrscpy_pad((char *)dest, dev ? dev->name : \"\", IFNAMSIZ);\n}\n\nstatic bool nft_meta_store_iftype(u32 *dest, const struct net_device *dev)\n{\n\tif (!dev)\n\t\treturn false;\n\n\tnft_reg_store16(dest, dev->type);\n\treturn true;\n}\n\nstatic bool nft_meta_store_ifgroup(u32 *dest, const struct net_device *dev)\n{\n\tif (!dev)\n\t\treturn false;\n\n\t*dest = dev->group;\n\treturn true;\n}\n\nstatic bool nft_meta_get_eval_ifname(enum nft_meta_keys key, u32 *dest,\n\t\t\t\t     const struct nft_pktinfo *pkt)\n{\n\tswitch (key) {\n\tcase NFT_META_IIFNAME:\n\t\tnft_meta_store_ifname(dest, nft_in(pkt));\n\t\tbreak;\n\tcase NFT_META_OIFNAME:\n\t\tnft_meta_store_ifname(dest, nft_out(pkt));\n\t\tbreak;\n\tcase NFT_META_IIF:\n\t\tnft_meta_store_ifindex(dest, nft_in(pkt));\n\t\tbreak;\n\tcase NFT_META_OIF:\n\t\tnft_meta_store_ifindex(dest, nft_out(pkt));\n\t\tbreak;\n\tcase NFT_META_IFTYPE:\n\t\tif (!nft_meta_store_iftype(dest, pkt->skb->dev))\n\t\t\treturn false;\n\t\tbreak;\n\tcase __NFT_META_IIFTYPE:\n\t\tif (!nft_meta_store_iftype(dest, nft_in(pkt)))\n\t\t\treturn false;\n\t\tbreak;\n\tcase NFT_META_OIFTYPE:\n\t\tif (!nft_meta_store_iftype(dest, nft_out(pkt)))\n\t\t\treturn false;\n\t\tbreak;\n\tcase NFT_META_IIFGROUP:\n\t\tif (!nft_meta_store_ifgroup(dest, nft_in(pkt)))\n\t\t\treturn false;\n\t\tbreak;\n\tcase NFT_META_OIFGROUP:\n\t\tif (!nft_meta_store_ifgroup(dest, nft_out(pkt)))\n\t\t\treturn false;\n\t\tbreak;\n\tdefault:\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n#ifdef CONFIG_IP_ROUTE_CLASSID\nstatic noinline bool\nnft_meta_get_eval_rtclassid(const struct sk_buff *skb, u32 *dest)\n{\n\tconst struct dst_entry *dst = skb_dst(skb);\n\n\tif (!dst)\n\t\treturn false;\n\n\t*dest = dst->tclassid;\n\treturn true;\n}\n#endif\n\nstatic noinline u32 nft_meta_get_eval_sdif(const struct nft_pktinfo *pkt)\n{\n\tswitch (nft_pf(pkt)) {\n\tcase NFPROTO_IPV4:\n\t\treturn inet_sdif(pkt->skb);\n\tcase NFPROTO_IPV6:\n\t\treturn inet6_sdif(pkt->skb);\n\t}\n\n\treturn 0;\n}\n\nstatic noinline void\nnft_meta_get_eval_sdifname(u32 *dest, const struct nft_pktinfo *pkt)\n{\n\tu32 sdif = nft_meta_get_eval_sdif(pkt);\n\tconst struct net_device *dev;\n\n\tdev = sdif ? dev_get_by_index_rcu(nft_net(pkt), sdif) : NULL;\n\tnft_meta_store_ifname(dest, dev);\n}\n\nvoid nft_meta_get_eval(const struct nft_expr *expr,\n\t\t       struct nft_regs *regs,\n\t\t       const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_meta *priv = nft_expr_priv(expr);\n\tconst struct sk_buff *skb = pkt->skb;\n\tu32 *dest = &regs->data[priv->dreg];\n\n\tswitch (priv->key) {\n\tcase NFT_META_LEN:\n\t\t*dest = skb->len;\n\t\tbreak;\n\tcase NFT_META_PROTOCOL:\n\t\tnft_reg_store16(dest, (__force u16)skb->protocol);\n\t\tbreak;\n\tcase NFT_META_NFPROTO:\n\t\tnft_reg_store8(dest, nft_pf(pkt));\n\t\tbreak;\n\tcase NFT_META_L4PROTO:\n\t\tif (!(pkt->flags & NFT_PKTINFO_L4PROTO))\n\t\t\tgoto err;\n\t\tnft_reg_store8(dest, pkt->tprot);\n\t\tbreak;\n\tcase NFT_META_PRIORITY:\n\t\t*dest = skb->priority;\n\t\tbreak;\n\tcase NFT_META_MARK:\n\t\t*dest = skb->mark;\n\t\tbreak;\n\tcase NFT_META_IIF:\n\tcase NFT_META_OIF:\n\tcase NFT_META_IIFNAME:\n\tcase NFT_META_OIFNAME:\n\tcase NFT_META_IIFTYPE:\n\tcase NFT_META_OIFTYPE:\n\tcase NFT_META_IIFGROUP:\n\tcase NFT_META_OIFGROUP:\n\t\tif (!nft_meta_get_eval_ifname(priv->key, dest, pkt))\n\t\t\tgoto err;\n\t\tbreak;\n\tcase NFT_META_SKUID:\n\tcase NFT_META_SKGID:\n\t\tif (!nft_meta_get_eval_skugid(priv->key, dest, pkt))\n\t\t\tgoto err;\n\t\tbreak;\n#ifdef CONFIG_IP_ROUTE_CLASSID\n\tcase NFT_META_RTCLASSID:\n\t\tif (!nft_meta_get_eval_rtclassid(skb, dest))\n\t\t\tgoto err;\n\t\tbreak;\n#endif\n#ifdef CONFIG_NETWORK_SECMARK\n\tcase NFT_META_SECMARK:\n\t\t*dest = skb->secmark;\n\t\tbreak;\n#endif\n\tcase NFT_META_PKTTYPE:\n\t\tif (skb->pkt_type != PACKET_LOOPBACK) {\n\t\t\tnft_reg_store8(dest, skb->pkt_type);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!nft_meta_get_eval_pkttype_lo(pkt, dest))\n\t\t\tgoto err;\n\t\tbreak;\n\tcase NFT_META_CPU:\n\t\t*dest = raw_smp_processor_id();\n\t\tbreak;\n#ifdef CONFIG_CGROUP_NET_CLASSID\n\tcase NFT_META_CGROUP:\n\t\tif (!nft_meta_get_eval_cgroup(dest, pkt))\n\t\t\tgoto err;\n\t\tbreak;\n#endif\n\tcase NFT_META_PRANDOM:\n\t\t*dest = get_random_u32();\n\t\tbreak;\n#ifdef CONFIG_XFRM\n\tcase NFT_META_SECPATH:\n\t\tnft_reg_store8(dest, secpath_exists(skb));\n\t\tbreak;\n#endif\n\tcase NFT_META_IIFKIND:\n\tcase NFT_META_OIFKIND:\n\t\tif (!nft_meta_get_eval_kind(priv->key, dest, pkt))\n\t\t\tgoto err;\n\t\tbreak;\n\tcase NFT_META_TIME_NS:\n\tcase NFT_META_TIME_DAY:\n\tcase NFT_META_TIME_HOUR:\n\t\tnft_meta_get_eval_time(priv->key, dest);\n\t\tbreak;\n\tcase NFT_META_SDIF:\n\t\t*dest = nft_meta_get_eval_sdif(pkt);\n\t\tbreak;\n\tcase NFT_META_SDIFNAME:\n\t\tnft_meta_get_eval_sdifname(dest, pkt);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON(1);\n\t\tgoto err;\n\t}\n\treturn;\n\nerr:\n\tregs->verdict.code = NFT_BREAK;\n}\nEXPORT_SYMBOL_GPL(nft_meta_get_eval);\n\nvoid nft_meta_set_eval(const struct nft_expr *expr,\n\t\t       struct nft_regs *regs,\n\t\t       const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_meta *meta = nft_expr_priv(expr);\n\tstruct sk_buff *skb = pkt->skb;\n\tu32 *sreg = &regs->data[meta->sreg];\n\tu32 value = *sreg;\n\tu8 value8;\n\n\tswitch (meta->key) {\n\tcase NFT_META_MARK:\n\t\tskb->mark = value;\n\t\tbreak;\n\tcase NFT_META_PRIORITY:\n\t\tskb->priority = value;\n\t\tbreak;\n\tcase NFT_META_PKTTYPE:\n\t\tvalue8 = nft_reg_load8(sreg);\n\n\t\tif (skb->pkt_type != value8 &&\n\t\t    skb_pkt_type_ok(value8) &&\n\t\t    skb_pkt_type_ok(skb->pkt_type))\n\t\t\tskb->pkt_type = value8;\n\t\tbreak;\n\tcase NFT_META_NFTRACE:\n\t\tvalue8 = nft_reg_load8(sreg);\n\n\t\tskb->nf_trace = !!value8;\n\t\tbreak;\n#ifdef CONFIG_NETWORK_SECMARK\n\tcase NFT_META_SECMARK:\n\t\tskb->secmark = value;\n\t\tbreak;\n#endif\n\tdefault:\n\t\tWARN_ON(1);\n\t}\n}\nEXPORT_SYMBOL_GPL(nft_meta_set_eval);\n\nconst struct nla_policy nft_meta_policy[NFTA_META_MAX + 1] = {\n\t[NFTA_META_DREG]\t= { .type = NLA_U32 },\n\t[NFTA_META_KEY]\t\t= NLA_POLICY_MAX(NLA_BE32, 255),\n\t[NFTA_META_SREG]\t= { .type = NLA_U32 },\n};\nEXPORT_SYMBOL_GPL(nft_meta_policy);\n\nint nft_meta_get_init(const struct nft_ctx *ctx,\n\t\t      const struct nft_expr *expr,\n\t\t      const struct nlattr * const tb[])\n{\n\tstruct nft_meta *priv = nft_expr_priv(expr);\n\tunsigned int len;\n\n\tpriv->key = ntohl(nla_get_be32(tb[NFTA_META_KEY]));\n\tswitch (priv->key) {\n\tcase NFT_META_PROTOCOL:\n\tcase NFT_META_IIFTYPE:\n\tcase NFT_META_OIFTYPE:\n\t\tlen = sizeof(u16);\n\t\tbreak;\n\tcase NFT_META_NFPROTO:\n\tcase NFT_META_L4PROTO:\n\tcase NFT_META_LEN:\n\tcase NFT_META_PRIORITY:\n\tcase NFT_META_MARK:\n\tcase NFT_META_IIF:\n\tcase NFT_META_OIF:\n\tcase NFT_META_SDIF:\n\tcase NFT_META_SKUID:\n\tcase NFT_META_SKGID:\n#ifdef CONFIG_IP_ROUTE_CLASSID\n\tcase NFT_META_RTCLASSID:\n#endif\n#ifdef CONFIG_NETWORK_SECMARK\n\tcase NFT_META_SECMARK:\n#endif\n\tcase NFT_META_PKTTYPE:\n\tcase NFT_META_CPU:\n\tcase NFT_META_IIFGROUP:\n\tcase NFT_META_OIFGROUP:\n#ifdef CONFIG_CGROUP_NET_CLASSID\n\tcase NFT_META_CGROUP:\n#endif\n\t\tlen = sizeof(u32);\n\t\tbreak;\n\tcase NFT_META_IIFNAME:\n\tcase NFT_META_OIFNAME:\n\tcase NFT_META_IIFKIND:\n\tcase NFT_META_OIFKIND:\n\tcase NFT_META_SDIFNAME:\n\t\tlen = IFNAMSIZ;\n\t\tbreak;\n\tcase NFT_META_PRANDOM:\n\t\tlen = sizeof(u32);\n\t\tbreak;\n#ifdef CONFIG_XFRM\n\tcase NFT_META_SECPATH:\n\t\tlen = sizeof(u8);\n\t\tbreak;\n#endif\n\tcase NFT_META_TIME_NS:\n\t\tlen = sizeof(u64);\n\t\tbreak;\n\tcase NFT_META_TIME_DAY:\n\t\tlen = sizeof(u8);\n\t\tbreak;\n\tcase NFT_META_TIME_HOUR:\n\t\tlen = sizeof(u32);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tpriv->len = len;\n\treturn nft_parse_register_store(ctx, tb[NFTA_META_DREG], &priv->dreg,\n\t\t\t\t\tNULL, NFT_DATA_VALUE, len);\n}\nEXPORT_SYMBOL_GPL(nft_meta_get_init);\n\nstatic int nft_meta_get_validate_sdif(const struct nft_ctx *ctx)\n{\n\tunsigned int hooks;\n\n\tswitch (ctx->family) {\n\tcase NFPROTO_IPV4:\n\tcase NFPROTO_IPV6:\n\tcase NFPROTO_INET:\n\t\thooks = (1 << NF_INET_LOCAL_IN) |\n\t\t\t(1 << NF_INET_FORWARD);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn nft_chain_validate_hooks(ctx->chain, hooks);\n}\n\nstatic int nft_meta_get_validate_xfrm(const struct nft_ctx *ctx)\n{\n#ifdef CONFIG_XFRM\n\tunsigned int hooks;\n\n\tswitch (ctx->family) {\n\tcase NFPROTO_NETDEV:\n\t\thooks = 1 << NF_NETDEV_INGRESS;\n\t\tbreak;\n\tcase NFPROTO_IPV4:\n\tcase NFPROTO_IPV6:\n\tcase NFPROTO_INET:\n\t\thooks = (1 << NF_INET_PRE_ROUTING) |\n\t\t\t(1 << NF_INET_LOCAL_IN) |\n\t\t\t(1 << NF_INET_FORWARD);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn nft_chain_validate_hooks(ctx->chain, hooks);\n#else\n\treturn 0;\n#endif\n}\n\nstatic int nft_meta_get_validate(const struct nft_ctx *ctx,\n\t\t\t\t const struct nft_expr *expr,\n\t\t\t\t const struct nft_data **data)\n{\n\tconst struct nft_meta *priv = nft_expr_priv(expr);\n\n\tswitch (priv->key) {\n\tcase NFT_META_SECPATH:\n\t\treturn nft_meta_get_validate_xfrm(ctx);\n\tcase NFT_META_SDIF:\n\tcase NFT_META_SDIFNAME:\n\t\treturn nft_meta_get_validate_sdif(ctx);\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nint nft_meta_set_validate(const struct nft_ctx *ctx,\n\t\t\t  const struct nft_expr *expr,\n\t\t\t  const struct nft_data **data)\n{\n\tstruct nft_meta *priv = nft_expr_priv(expr);\n\tunsigned int hooks;\n\n\tif (priv->key != NFT_META_PKTTYPE)\n\t\treturn 0;\n\n\tswitch (ctx->family) {\n\tcase NFPROTO_BRIDGE:\n\t\thooks = 1 << NF_BR_PRE_ROUTING;\n\t\tbreak;\n\tcase NFPROTO_NETDEV:\n\t\thooks = 1 << NF_NETDEV_INGRESS;\n\t\tbreak;\n\tcase NFPROTO_IPV4:\n\tcase NFPROTO_IPV6:\n\tcase NFPROTO_INET:\n\t\thooks = 1 << NF_INET_PRE_ROUTING;\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn nft_chain_validate_hooks(ctx->chain, hooks);\n}\nEXPORT_SYMBOL_GPL(nft_meta_set_validate);\n\nint nft_meta_set_init(const struct nft_ctx *ctx,\n\t\t      const struct nft_expr *expr,\n\t\t      const struct nlattr * const tb[])\n{\n\tstruct nft_meta *priv = nft_expr_priv(expr);\n\tunsigned int len;\n\tint err;\n\n\tpriv->key = ntohl(nla_get_be32(tb[NFTA_META_KEY]));\n\tswitch (priv->key) {\n\tcase NFT_META_MARK:\n\tcase NFT_META_PRIORITY:\n#ifdef CONFIG_NETWORK_SECMARK\n\tcase NFT_META_SECMARK:\n#endif\n\t\tlen = sizeof(u32);\n\t\tbreak;\n\tcase NFT_META_NFTRACE:\n\t\tlen = sizeof(u8);\n\t\tbreak;\n\tcase NFT_META_PKTTYPE:\n\t\tlen = sizeof(u8);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tpriv->len = len;\n\terr = nft_parse_register_load(tb[NFTA_META_SREG], &priv->sreg, len);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (priv->key == NFT_META_NFTRACE)\n\t\tstatic_branch_inc(&nft_trace_enabled);\n\n\treturn 0;\n}\nEXPORT_SYMBOL_GPL(nft_meta_set_init);\n\nint nft_meta_get_dump(struct sk_buff *skb,\n\t\t      const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_meta *priv = nft_expr_priv(expr);\n\n\tif (nla_put_be32(skb, NFTA_META_KEY, htonl(priv->key)))\n\t\tgoto nla_put_failure;\n\tif (nft_dump_register(skb, NFTA_META_DREG, priv->dreg))\n\t\tgoto nla_put_failure;\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\nEXPORT_SYMBOL_GPL(nft_meta_get_dump);\n\nint nft_meta_set_dump(struct sk_buff *skb,\n\t\t      const struct nft_expr *expr, bool reset)\n{\n\tconst struct nft_meta *priv = nft_expr_priv(expr);\n\n\tif (nla_put_be32(skb, NFTA_META_KEY, htonl(priv->key)))\n\t\tgoto nla_put_failure;\n\tif (nft_dump_register(skb, NFTA_META_SREG, priv->sreg))\n\t\tgoto nla_put_failure;\n\n\treturn 0;\n\nnla_put_failure:\n\treturn -1;\n}\nEXPORT_SYMBOL_GPL(nft_meta_set_dump);\n\nvoid nft_meta_set_destroy(const struct nft_ctx *ctx,\n\t\t\t  const struct nft_expr *expr)\n{\n\tconst struct nft_meta *priv = nft_expr_priv(expr);\n\n\tif (priv->key == NFT_META_NFTRACE)\n\t\tstatic_branch_dec(&nft_trace_enabled);\n}\nEXPORT_SYMBOL_GPL(nft_meta_set_destroy);\n\nstatic int nft_meta_get_offload(struct nft_offload_ctx *ctx,\n\t\t\t\tstruct nft_flow_rule *flow,\n\t\t\t\tconst struct nft_expr *expr)\n{\n\tconst struct nft_meta *priv = nft_expr_priv(expr);\n\tstruct nft_offload_reg *reg = &ctx->regs[priv->dreg];\n\n\tswitch (priv->key) {\n\tcase NFT_META_PROTOCOL:\n\t\tNFT_OFFLOAD_MATCH_EXACT(FLOW_DISSECTOR_KEY_BASIC, basic, n_proto,\n\t\t\t\t\tsizeof(__u16), reg);\n\t\tnft_offload_set_dependency(ctx, NFT_OFFLOAD_DEP_NETWORK);\n\t\tbreak;\n\tcase NFT_META_L4PROTO:\n\t\tNFT_OFFLOAD_MATCH_EXACT(FLOW_DISSECTOR_KEY_BASIC, basic, ip_proto,\n\t\t\t\t\tsizeof(__u8), reg);\n\t\tnft_offload_set_dependency(ctx, NFT_OFFLOAD_DEP_TRANSPORT);\n\t\tbreak;\n\tcase NFT_META_IIF:\n\t\tNFT_OFFLOAD_MATCH_EXACT(FLOW_DISSECTOR_KEY_META, meta,\n\t\t\t\t\tingress_ifindex, sizeof(__u32), reg);\n\t\tbreak;\n\tcase NFT_META_IIFTYPE:\n\t\tNFT_OFFLOAD_MATCH_EXACT(FLOW_DISSECTOR_KEY_META, meta,\n\t\t\t\t\tingress_iftype, sizeof(__u16), reg);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\treturn 0;\n}\n\nbool nft_meta_get_reduce(struct nft_regs_track *track,\n\t\t\t const struct nft_expr *expr)\n{\n\tconst struct nft_meta *priv = nft_expr_priv(expr);\n\tconst struct nft_meta *meta;\n\n\tif (!nft_reg_track_cmp(track, expr, priv->dreg)) {\n\t\tnft_reg_track_update(track, expr, priv->dreg, priv->len);\n\t\treturn false;\n\t}\n\n\tmeta = nft_expr_priv(track->regs[priv->dreg].selector);\n\tif (priv->key != meta->key ||\n\t    priv->dreg != meta->dreg) {\n\t\tnft_reg_track_update(track, expr, priv->dreg, priv->len);\n\t\treturn false;\n\t}\n\n\tif (!track->regs[priv->dreg].bitwise)\n\t\treturn true;\n\n\treturn nft_expr_reduce_bitwise(track, expr);\n}\nEXPORT_SYMBOL_GPL(nft_meta_get_reduce);\n\nstatic const struct nft_expr_ops nft_meta_get_ops = {\n\t.type\t\t= &nft_meta_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_meta)),\n\t.eval\t\t= nft_meta_get_eval,\n\t.init\t\t= nft_meta_get_init,\n\t.dump\t\t= nft_meta_get_dump,\n\t.reduce\t\t= nft_meta_get_reduce,\n\t.validate\t= nft_meta_get_validate,\n\t.offload\t= nft_meta_get_offload,\n};\n\nstatic bool nft_meta_set_reduce(struct nft_regs_track *track,\n\t\t\t\tconst struct nft_expr *expr)\n{\n\tint i;\n\n\tfor (i = 0; i < NFT_REG32_NUM; i++) {\n\t\tif (!track->regs[i].selector)\n\t\t\tcontinue;\n\n\t\tif (track->regs[i].selector->ops != &nft_meta_get_ops)\n\t\t\tcontinue;\n\n\t\t__nft_reg_track_cancel(track, i);\n\t}\n\n\treturn false;\n}\n\nstatic const struct nft_expr_ops nft_meta_set_ops = {\n\t.type\t\t= &nft_meta_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_meta)),\n\t.eval\t\t= nft_meta_set_eval,\n\t.init\t\t= nft_meta_set_init,\n\t.destroy\t= nft_meta_set_destroy,\n\t.dump\t\t= nft_meta_set_dump,\n\t.reduce\t\t= nft_meta_set_reduce,\n\t.validate\t= nft_meta_set_validate,\n};\n\nstatic const struct nft_expr_ops *\nnft_meta_select_ops(const struct nft_ctx *ctx,\n\t\t    const struct nlattr * const tb[])\n{\n\tif (tb[NFTA_META_KEY] == NULL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (tb[NFTA_META_DREG] && tb[NFTA_META_SREG])\n\t\treturn ERR_PTR(-EINVAL);\n\n#if IS_ENABLED(CONFIG_NF_TABLES_BRIDGE) && IS_MODULE(CONFIG_NFT_BRIDGE_META)\n\tif (ctx->family == NFPROTO_BRIDGE)\n\t\treturn ERR_PTR(-EAGAIN);\n#endif\n\tif (tb[NFTA_META_DREG])\n\t\treturn &nft_meta_get_ops;\n\n\tif (tb[NFTA_META_SREG])\n\t\treturn &nft_meta_set_ops;\n\n\treturn ERR_PTR(-EINVAL);\n}\n\nstatic int nft_meta_inner_init(const struct nft_ctx *ctx,\n\t\t\t       const struct nft_expr *expr,\n\t\t\t       const struct nlattr * const tb[])\n{\n\tstruct nft_meta *priv = nft_expr_priv(expr);\n\tunsigned int len;\n\n\tpriv->key = ntohl(nla_get_be32(tb[NFTA_META_KEY]));\n\tswitch (priv->key) {\n\tcase NFT_META_PROTOCOL:\n\t\tlen = sizeof(u16);\n\t\tbreak;\n\tcase NFT_META_L4PROTO:\n\t\tlen = sizeof(u32);\n\t\tbreak;\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\tpriv->len = len;\n\n\treturn nft_parse_register_store(ctx, tb[NFTA_META_DREG], &priv->dreg,\n\t\t\t\t\tNULL, NFT_DATA_VALUE, len);\n}\n\nvoid nft_meta_inner_eval(const struct nft_expr *expr,\n\t\t\t struct nft_regs *regs,\n\t\t\t const struct nft_pktinfo *pkt,\n\t\t\t struct nft_inner_tun_ctx *tun_ctx)\n{\n\tconst struct nft_meta *priv = nft_expr_priv(expr);\n\tu32 *dest = &regs->data[priv->dreg];\n\n\tswitch (priv->key) {\n\tcase NFT_META_PROTOCOL:\n\t\tnft_reg_store16(dest, (__force u16)tun_ctx->llproto);\n\t\tbreak;\n\tcase NFT_META_L4PROTO:\n\t\tif (!(tun_ctx->flags & NFT_PAYLOAD_CTX_INNER_TH))\n\t\t\tgoto err;\n\n\t\tnft_reg_store8(dest, tun_ctx->l4proto);\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t\tgoto err;\n\t}\n\treturn;\n\nerr:\n\tregs->verdict.code = NFT_BREAK;\n}\nEXPORT_SYMBOL_GPL(nft_meta_inner_eval);\n\nstatic const struct nft_expr_ops nft_meta_inner_ops = {\n\t.type\t\t= &nft_meta_type,\n\t.size\t\t= NFT_EXPR_SIZE(sizeof(struct nft_meta)),\n\t.init\t\t= nft_meta_inner_init,\n\t.dump\t\t= nft_meta_get_dump,\n\t/* direct call to nft_meta_inner_eval(). */\n};\n\nstruct nft_expr_type nft_meta_type __read_mostly = {\n\t.name\t\t= \"meta\",\n\t.select_ops\t= nft_meta_select_ops,\n\t.inner_ops\t= &nft_meta_inner_ops,\n\t.policy\t\t= nft_meta_policy,\n\t.maxattr\t= NFTA_META_MAX,\n\t.owner\t\t= THIS_MODULE,\n};\n\n#ifdef CONFIG_NETWORK_SECMARK\nstruct nft_secmark {\n\tu32 secid;\n\tchar *ctx;\n};\n\nstatic const struct nla_policy nft_secmark_policy[NFTA_SECMARK_MAX + 1] = {\n\t[NFTA_SECMARK_CTX]     = { .type = NLA_STRING, .len = NFT_SECMARK_CTX_MAXLEN },\n};\n\nstatic int nft_secmark_compute_secid(struct nft_secmark *priv)\n{\n\tu32 tmp_secid = 0;\n\tint err;\n\n\terr = security_secctx_to_secid(priv->ctx, strlen(priv->ctx), &tmp_secid);\n\tif (err)\n\t\treturn err;\n\n\tif (!tmp_secid)\n\t\treturn -ENOENT;\n\n\terr = security_secmark_relabel_packet(tmp_secid);\n\tif (err)\n\t\treturn err;\n\n\tpriv->secid = tmp_secid;\n\treturn 0;\n}\n\nstatic void nft_secmark_obj_eval(struct nft_object *obj, struct nft_regs *regs,\n\t\t\t\t const struct nft_pktinfo *pkt)\n{\n\tconst struct nft_secmark *priv = nft_obj_data(obj);\n\tstruct sk_buff *skb = pkt->skb;\n\n\tskb->secmark = priv->secid;\n}\n\nstatic int nft_secmark_obj_init(const struct nft_ctx *ctx,\n\t\t\t\tconst struct nlattr * const tb[],\n\t\t\t\tstruct nft_object *obj)\n{\n\tstruct nft_secmark *priv = nft_obj_data(obj);\n\tint err;\n\n\tif (tb[NFTA_SECMARK_CTX] == NULL)\n\t\treturn -EINVAL;\n\n\tpriv->ctx = nla_strdup(tb[NFTA_SECMARK_CTX], GFP_KERNEL);\n\tif (!priv->ctx)\n\t\treturn -ENOMEM;\n\n\terr = nft_secmark_compute_secid(priv);\n\tif (err) {\n\t\tkfree(priv->ctx);\n\t\treturn err;\n\t}\n\n\tsecurity_secmark_refcount_inc();\n\n\treturn 0;\n}\n\nstatic int nft_secmark_obj_dump(struct sk_buff *skb, struct nft_object *obj,\n\t\t\t\tbool reset)\n{\n\tstruct nft_secmark *priv = nft_obj_data(obj);\n\tint err;\n\n\tif (nla_put_string(skb, NFTA_SECMARK_CTX, priv->ctx))\n\t\treturn -1;\n\n\tif (reset) {\n\t\terr = nft_secmark_compute_secid(priv);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\treturn 0;\n}\n\nstatic void nft_secmark_obj_destroy(const struct nft_ctx *ctx, struct nft_object *obj)\n{\n\tstruct nft_secmark *priv = nft_obj_data(obj);\n\n\tsecurity_secmark_refcount_dec();\n\n\tkfree(priv->ctx);\n}\n\nstatic const struct nft_object_ops nft_secmark_obj_ops = {\n\t.type\t\t= &nft_secmark_obj_type,\n\t.size\t\t= sizeof(struct nft_secmark),\n\t.init\t\t= nft_secmark_obj_init,\n\t.eval\t\t= nft_secmark_obj_eval,\n\t.dump\t\t= nft_secmark_obj_dump,\n\t.destroy\t= nft_secmark_obj_destroy,\n};\nstruct nft_object_type nft_secmark_obj_type __read_mostly = {\n\t.type\t\t= NFT_OBJECT_SECMARK,\n\t.ops\t\t= &nft_secmark_obj_ops,\n\t.maxattr\t= NFTA_SECMARK_MAX,\n\t.policy\t\t= nft_secmark_policy,\n\t.owner\t\t= THIS_MODULE,\n};\n#endif /* CONFIG_NETWORK_SECMARK */\n"], "filenames": ["include/net/netfilter/nf_tables.h", "net/netfilter/nft_byteorder.c", "net/netfilter/nft_meta.c"], "buggy_code_start_loc": [181, 40, 66], "buggy_code_end_loc": [184, 56, 67], "fixing_code_start_loc": [181, 41, 66], "fixing_code_end_loc": [184, 57, 67], "type": "NVD-CWE-Other", "message": "A flaw was found in the Netfilter subsystem in the Linux kernel. The issue is in the nft_byteorder_eval() function, where the code iterates through a loop and writes to the `dst` array. On each iteration, 8 bytes are written, but `dst` is an array of u32, so each element only has space for 4 bytes. That means every iteration overwrites part of the previous element corrupting this array of u32. This flaw allows a local user to cause a denial of service or potentially break NetFilter functionality.", "other": {"cve": {"id": "CVE-2024-0607", "sourceIdentifier": "secalert@redhat.com", "published": "2024-01-18T16:15:08.690", "lastModified": "2024-01-26T19:00:06.617", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A flaw was found in the Netfilter subsystem in the Linux kernel. The issue is in the nft_byteorder_eval() function, where the code iterates through a loop and writes to the `dst` array. On each iteration, 8 bytes are written, but `dst` is an array of u32, so each element only has space for 4 bytes. That means every iteration overwrites part of the previous element corrupting this array of u32. This flaw allows a local user to cause a denial of service or potentially break NetFilter functionality."}, {"lang": "es", "value": "Se encontr\u00f3 una falla en el subsistema Netfilter en el kernel de Linux. El problema est\u00e1 en la funci\u00f3n nft_byteorder_eval(), donde el c\u00f3digo itera a trav\u00e9s de un bucle y escribe en la matriz `dst`. En cada iteraci\u00f3n, se escriben 8 bytes, pero `dst` es una matriz de u32, por lo que cada elemento solo tiene espacio para 4 bytes. Eso significa que cada iteraci\u00f3n sobrescribe parte del elemento anterior, lo que posiblemente lleve a una escritura fuera de los l\u00edmites. Esta falla permite que un usuario local provoque una denegaci\u00f3n de servicio o potencialmente aumente sus privilegios en el sistema."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 6.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 4.7}, {"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 6.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 4.7}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-229"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.7", "matchCriteriaId": "668F5607-E136-4E8E-86F2-316E9DC41ADC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.7:rc1:*:*:*:*:*:*", "matchCriteriaId": "3A0038DE-E183-4958-A6E3-CE3821FEAFBF"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:39:*:*:*:*:*:*:*", "matchCriteriaId": "B8EDB836-4E6A-4B71-B9B2-AA3E03E0F646"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "7F6FB57C-2BC7-487C-96DD-132683AEB35D"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/CVE-2024-0607", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2258635", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/c301f0981fdd3fd1ffac6836b423c4d7a8e0eb63", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/c301f0981fdd3fd1ffac6836b423c4d7a8e0eb63"}}