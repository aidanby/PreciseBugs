{"buggy_code": ["#\n# The Python Imaging Library.\n# $Id$\n#\n# EPS file handling\n#\n# History:\n# 1995-09-01 fl   Created (0.1)\n# 1996-05-18 fl   Don't choke on \"atend\" fields, Ghostscript interface (0.2)\n# 1996-08-22 fl   Don't choke on floating point BoundingBox values\n# 1996-08-23 fl   Handle files from Macintosh (0.3)\n# 2001-02-17 fl   Use 're' instead of 'regex' (Python 2.1) (0.4)\n# 2003-09-07 fl   Check gs.close status (from Federico Di Gregorio) (0.5)\n#\n# Copyright (c) 1997-2003 by Secret Labs AB.\n# Copyright (c) 1995-2003 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\n\n__version__ = \"0.5\"\n\nimport re\nimport io\nfrom PIL import Image, ImageFile, _binary\n\n#\n# --------------------------------------------------------------------\n\ni32 = _binary.i32le\no32 = _binary.o32le\n\nsplit = re.compile(r\"^%%([^:]*):[ \\t]*(.*)[ \\t]*$\")\nfield = re.compile(r\"^%[%!\\w]([^:]*)[ \\t]*$\")\n\ngs_windows_binary = None\nimport sys\nif sys.platform.startswith('win'):\n    import shutil\n    if hasattr(shutil, 'which'):\n        which = shutil.which\n    else:\n        # Python < 3.3\n        import distutils.spawn\n        which = distutils.spawn.find_executable\n    for binary in ('gswin32c', 'gswin64c', 'gs'):\n        if which(binary) is not None:\n            gs_windows_binary = binary\n            break\n    else:\n        gs_windows_binary = False\n\ndef Ghostscript(tile, size, fp, scale=1):\n    \"\"\"Render an image using Ghostscript\"\"\"\n\n    # Unpack decoder tile\n    decoder, tile, offset, data = tile[0]\n    length, bbox = data\n\n    #Hack to support hi-res rendering\n    scale = int(scale) or 1\n    orig_size = size\n    orig_bbox = bbox\n    size = (size[0] * scale, size[1] * scale)\n    bbox = [bbox[0], bbox[1], bbox[2] * scale, bbox[3] * scale]\n    #print(\"Ghostscript\", scale, size, orig_size, bbox, orig_bbox)\n\n    import tempfile, os, subprocess\n\n    file = tempfile.mktemp()\n\n    # Build ghostscript command\n    command = [\"gs\",\n               \"-q\",                    # quite mode\n               \"-g%dx%d\" % size,        # set output geometry (pixels)\n               \"-r%d\" % (72*scale),     # set input DPI (dots per inch)\n               \"-dNOPAUSE -dSAFER\",     # don't pause between pages, safe mode\n               \"-sDEVICE=ppmraw\",       # ppm driver\n               \"-sOutputFile=%s\" % file,# output file\n            ]\n\n    if gs_windows_binary is not None:\n        if gs_windows_binary is False:\n            raise WindowsError('Unable to locate Ghostscript on paths')\n        command[0] = gs_windows_binary\n\n    # push data through ghostscript\n    try:\n        gs = subprocess.Popen(command, stdin=subprocess.PIPE, stdout=subprocess.PIPE)\n        # adjust for image origin\n        if bbox[0] != 0 or bbox[1] != 0:\n            gs.stdin.write((\"%d %d translate\\n\" % (-bbox[0], -bbox[1])).encode('ascii'))\n        fp.seek(offset)\n        while length > 0:\n            s = fp.read(8192)\n            if not s:\n                break\n            length = length - len(s)\n            gs.stdin.write(s)\n        gs.stdin.close()\n        status = gs.wait()\n        if status:\n            raise IOError(\"gs failed (status %d)\" % status)\n        im = Image.core.open_ppm(file)\n    finally:\n        try: os.unlink(file)\n        except: pass\n\n    return im\n\n\nclass PSFile:\n    \"\"\"Wrapper that treats either CR or LF as end of line.\"\"\"\n    def __init__(self, fp):\n        self.fp = fp\n        self.char = None\n    def __getattr__(self, id):\n        v = getattr(self.fp, id)\n        setattr(self, id, v)\n        return v\n    def seek(self, offset, whence=0):\n        self.char = None\n        self.fp.seek(offset, whence)\n    def read(self, count):\n        return self.fp.read(count).decode('latin-1')\n    def tell(self):\n        pos = self.fp.tell()\n        if self.char:\n            pos = pos - 1\n        return pos\n    def readline(self):\n        s = b\"\"\n        if self.char:\n            c = self.char\n            self.char = None\n        else:\n            c = self.fp.read(1)\n        while c not in b\"\\r\\n\":\n            s = s + c\n            c = self.fp.read(1)\n        if c == b\"\\r\":\n            self.char = self.fp.read(1)\n            if self.char == b\"\\n\":\n                self.char = None\n        return s.decode('latin-1') + \"\\n\"\n\n\ndef _accept(prefix):\n    return prefix[:4] == b\"%!PS\" or i32(prefix) == 0xC6D3D0C5\n\n##\n# Image plugin for Encapsulated Postscript.  This plugin supports only\n# a few variants of this format.\n\nclass EpsImageFile(ImageFile.ImageFile):\n    \"\"\"EPS File Parser for the Python Imaging Library\"\"\"\n\n    format = \"EPS\"\n    format_description = \"Encapsulated Postscript\"\n\n    def _open(self):\n\n        # FIXME: should check the first 512 bytes to see if this\n        # really is necessary (platform-dependent, though...)\n\n        fp = PSFile(self.fp)\n\n        # HEAD\n        s = fp.read(512)\n        if s[:4] == \"%!PS\":\n            offset = 0\n            fp.seek(0, 2)\n            length = fp.tell()\n        elif i32(s) == 0xC6D3D0C5:\n            offset = i32(s[4:])\n            length = i32(s[8:])\n            fp.seek(offset)\n        else:\n            raise SyntaxError(\"not an EPS file\")\n\n        fp.seek(offset)\n\n        box = None\n\n        self.mode = \"RGB\"\n        self.size = 1, 1 # FIXME: huh?\n\n        #\n        # Load EPS header\n\n        s = fp.readline()\n\n        while s:\n\n            if len(s) > 255:\n                raise SyntaxError(\"not an EPS file\")\n\n            if s[-2:] == '\\r\\n':\n                s = s[:-2]\n            elif s[-1:] == '\\n':\n                s = s[:-1]\n\n            try:\n                m = split.match(s)\n            except re.error as v:\n                raise SyntaxError(\"not an EPS file\")\n\n            if m:\n                k, v = m.group(1, 2)\n                self.info[k] = v\n                if k == \"BoundingBox\":\n                    try:\n                        # Note: The DSC spec says that BoundingBox\n                        # fields should be integers, but some drivers\n                        # put floating point values there anyway.\n                        box = [int(float(s)) for s in v.split()]\n                        self.size = box[2] - box[0], box[3] - box[1]\n                        self.tile = [(\"eps\", (0,0) + self.size, offset,\n                                      (length, box))]\n                    except:\n                        pass\n\n            else:\n\n                m = field.match(s)\n\n                if m:\n                    k = m.group(1)\n\n                    if k == \"EndComments\":\n                        break\n                    if k[:8] == \"PS-Adobe\":\n                        self.info[k[:8]] = k[9:]\n                    else:\n                        self.info[k] = \"\"\n                elif s[0:1] == '%':\n                    # handle non-DSC Postscript comments that some\n                    # tools mistakenly put in the Comments section\n                    pass\n                else:\n                    raise IOError(\"bad EPS header\")\n\n            s = fp.readline()\n\n            if s[:1] != \"%\":\n                break\n\n\n        #\n        # Scan for an \"ImageData\" descriptor\n\n        while s[0] == \"%\":\n\n            if len(s) > 255:\n                raise SyntaxError(\"not an EPS file\")\n\n            if s[-2:] == '\\r\\n':\n                s = s[:-2]\n            elif s[-1:] == '\\n':\n                s = s[:-1]\n\n            if s[:11] == \"%ImageData:\":\n\n                [x, y, bi, mo, z3, z4, en, id] =\\\n                    s[11:].split(None, 7)\n\n                x = int(x); y = int(y)\n\n                bi = int(bi)\n                mo = int(mo)\n\n                en = int(en)\n\n                if en == 1:\n                    decoder = \"eps_binary\"\n                elif en == 2:\n                    decoder = \"eps_hex\"\n                else:\n                    break\n                if bi != 8:\n                    break\n                if mo == 1:\n                    self.mode = \"L\"\n                elif mo == 2:\n                    self.mode = \"LAB\"\n                elif mo == 3:\n                    self.mode = \"RGB\"\n                else:\n                    break\n\n                if id[:1] == id[-1:] == '\"':\n                    id = id[1:-1]\n\n                # Scan forward to the actual image data\n                while True:\n                    s = fp.readline()\n                    if not s:\n                        break\n                    if s[:len(id)] == id:\n                        self.size = x, y\n                        self.tile2 = [(decoder,\n                                       (0, 0, x, y),\n                                       fp.tell(),\n                                       0)]\n                        return\n\n            s = fp.readline()\n            if not s:\n                break\n\n        if not box:\n            raise IOError(\"cannot determine EPS bounding box\")\n\n    def load(self, scale=1):\n        # Load EPS via Ghostscript\n        if not self.tile:\n            return\n        self.im = Ghostscript(self.tile, self.size, self.fp, scale)\n        self.mode = self.im.mode\n        self.size = self.im.size\n        self.tile = []\n\n#\n# --------------------------------------------------------------------\n\ndef _save(im, fp, filename, eps=1):\n    \"\"\"EPS Writer for the Python Imaging Library.\"\"\"\n\n    #\n    # make sure image data is available\n    im.load()\n\n    #\n    # determine postscript image mode\n    if im.mode == \"L\":\n        operator = (8, 1, \"image\")\n    elif im.mode == \"RGB\":\n        operator = (8, 3, \"false 3 colorimage\")\n    elif im.mode == \"CMYK\":\n        operator = (8, 4, \"false 4 colorimage\")\n    else:\n        raise ValueError(\"image mode is not supported\")\n\n    class NoCloseStream:\n        def __init__(self, fp):\n            self.fp = fp\n        def __getattr__(self, name):\n            return getattr(self.fp, name)\n        def close(self):\n            pass\n\n    base_fp = fp\n    fp = io.TextIOWrapper(NoCloseStream(fp), encoding='latin-1')\n\n    if eps:\n        #\n        # write EPS header\n        fp.write(\"%!PS-Adobe-3.0 EPSF-3.0\\n\")\n        fp.write(\"%%Creator: PIL 0.1 EpsEncode\\n\")\n        #fp.write(\"%%CreationDate: %s\"...)\n        fp.write(\"%%%%BoundingBox: 0 0 %d %d\\n\" % im.size)\n        fp.write(\"%%Pages: 1\\n\")\n        fp.write(\"%%EndComments\\n\")\n        fp.write(\"%%Page: 1 1\\n\")\n        fp.write(\"%%ImageData: %d %d \" % im.size)\n        fp.write(\"%d %d 0 1 1 \\\"%s\\\"\\n\" % operator)\n\n    #\n    # image header\n    fp.write(\"gsave\\n\")\n    fp.write(\"10 dict begin\\n\")\n    fp.write(\"/buf %d string def\\n\" % (im.size[0] * operator[1]))\n    fp.write(\"%d %d scale\\n\" % im.size)\n    fp.write(\"%d %d 8\\n\" % im.size) # <= bits\n    fp.write(\"[%d 0 0 -%d 0 %d]\\n\" % (im.size[0], im.size[1], im.size[1]))\n    fp.write(\"{ currentfile buf readhexstring pop } bind\\n\")\n    fp.write(operator[2] + \"\\n\")\n    fp.flush()\n\n    ImageFile._save(im, base_fp, [(\"eps\", (0,0)+im.size, 0, None)])\n\n    fp.write(\"\\n%%%%EndBinary\\n\")\n    fp.write(\"grestore end\\n\")\n    fp.flush()\n\n#\n# --------------------------------------------------------------------\n\nImage.register_open(EpsImageFile.format, EpsImageFile, _accept)\n\nImage.register_save(EpsImageFile.format, _save)\n\nImage.register_extension(EpsImageFile.format, \".ps\")\nImage.register_extension(EpsImageFile.format, \".eps\")\n\nImage.register_mime(EpsImageFile.format, \"application/postscript\")\n", "#\n# The Python Imaging Library.\n# $Id$\n#\n# the Image class wrapper\n#\n# partial release history:\n# 1995-09-09 fl   Created\n# 1996-03-11 fl   PIL release 0.0 (proof of concept)\n# 1996-04-30 fl   PIL release 0.1b1\n# 1999-07-28 fl   PIL release 1.0 final\n# 2000-06-07 fl   PIL release 1.1\n# 2000-10-20 fl   PIL release 1.1.1\n# 2001-05-07 fl   PIL release 1.1.2\n# 2002-03-15 fl   PIL release 1.1.3\n# 2003-05-10 fl   PIL release 1.1.4\n# 2005-03-28 fl   PIL release 1.1.5\n# 2006-12-02 fl   PIL release 1.1.6\n# 2009-11-15 fl   PIL release 1.1.7\n#\n# Copyright (c) 1997-2009 by Secret Labs AB.  All rights reserved.\n# Copyright (c) 1995-2009 by Fredrik Lundh.\n#\n# See the README file for information on usage and redistribution.\n#\n\nfrom __future__ import print_function\n\nfrom PIL import VERSION, PILLOW_VERSION, _plugins\n\nimport warnings\n\nclass _imaging_not_installed:\n    # module placeholder\n    def __getattr__(self, id):\n        raise ImportError(\"The _imaging C module is not installed\")\n\ntry:\n    # give Tk a chance to set up the environment, in case we're\n    # using an _imaging module linked against libtcl/libtk (use\n    # __import__ to hide this from naive packagers; we don't really\n    # depend on Tk unless ImageTk is used, and that module already\n    # imports Tkinter)\n    __import__(\"FixTk\")\nexcept ImportError:\n    pass\n\ntry:\n    # If the _imaging C module is not present, you can still use\n    # the \"open\" function to identify files, but you cannot load\n    # them.  Note that other modules should not refer to _imaging\n    # directly; import Image and use the Image.core variable instead.\n    from PIL import _imaging as core\n    if PILLOW_VERSION != getattr(core, 'PILLOW_VERSION', None):\n         raise ImportError(\"The _imaging extension was built for another \"\n                            \" version of Pillow or PIL\")\n\nexcept ImportError as v:\n    core = _imaging_not_installed()\n    # Explanations for ways that we know we might have an import error\n    if str(v).startswith(\"Module use of python\"):\n        # The _imaging C module is present, but not compiled for\n        # the right version (windows only).  Print a warning, if\n        # possible.\n        warnings.warn(\n            \"The _imaging extension was built for another version \"\n            \"of Python.\",\n            RuntimeWarning\n            )\n    elif str(v).startswith(\"The _imaging extension\"):\n        warnings.warn(str(v), RuntimeWarning)\n    elif \"Symbol not found: _PyUnicodeUCS2_FromString\" in str(v):\n        warnings.warn(\n            \"The _imaging extension was built for Python with UCS2 support; \"\n            \"recompile PIL or build Python --without-wide-unicode. \",\n            RuntimeWarning\n            )\n    elif \"Symbol not found: _PyUnicodeUCS4_FromString\" in str(v):\n        warnings.warn(\n            \"The _imaging extension was built for Python with UCS4 support; \"\n            \"recompile PIL or build Python --with-wide-unicode. \",\n            RuntimeWarning\n            )\n    # Fail here anyway. Don't let people run with a mostly broken Pillow.\n    raise\n\ntry:\n    import builtins\nexcept ImportError:\n    import __builtin__\n    builtins = __builtin__\n\nfrom PIL import ImageMode\nfrom PIL._binary import i8, o8\nfrom PIL._util import isPath, isStringType\n\nimport os, sys\n\n# type stuff\nimport collections\nimport numbers\n\n\ndef isImageType(t):\n    \"\"\"\n    Checks if an object is an image object.\n\n    .. warning::\n\n       This function is for internal use only.\n\n    :param t: object to check if it's an image\n    :returns: True if the object is an image\n    \"\"\"\n    return hasattr(t, \"im\")\n\n#\n# Debug level\n\nDEBUG = 0\n\n#\n# Constants (also defined in _imagingmodule.c!)\n\nNONE = 0\n\n# transpose\nFLIP_LEFT_RIGHT = 0\nFLIP_TOP_BOTTOM = 1\nROTATE_90 = 2\nROTATE_180 = 3\nROTATE_270 = 4\n\n# transforms\nAFFINE = 0\nEXTENT = 1\nPERSPECTIVE = 2\nQUAD = 3\nMESH = 4\n\n# resampling filters\nNONE = 0\nNEAREST = 0\nANTIALIAS = 1 # 3-lobed lanczos\nLINEAR = BILINEAR = 2\nCUBIC = BICUBIC = 3\n\n# dithers\nNONE = 0\nNEAREST = 0\nORDERED = 1 # Not yet implemented\nRASTERIZE = 2 # Not yet implemented\nFLOYDSTEINBERG = 3 # default\n\n# palettes/quantizers\nWEB = 0\nADAPTIVE = 1\n\nMEDIANCUT = 0\nMAXCOVERAGE = 1\nFASTOCTREE = 2\n\n# categories\nNORMAL = 0\nSEQUENCE = 1\nCONTAINER = 2\n\nif hasattr(core, 'DEFAULT_STRATEGY'):\n    DEFAULT_STRATEGY = core.DEFAULT_STRATEGY\n    FILTERED = core.FILTERED\n    HUFFMAN_ONLY = core.HUFFMAN_ONLY\n    RLE = core.RLE\n    FIXED = core.FIXED\n\n\n# --------------------------------------------------------------------\n# Registries\n\nID = []\nOPEN = {}\nMIME = {}\nSAVE = {}\nEXTENSION = {}\n\n# --------------------------------------------------------------------\n# Modes supported by this version\n\n_MODEINFO = {\n    # NOTE: this table will be removed in future versions.  use\n    # getmode* functions or ImageMode descriptors instead.\n\n    # official modes\n    \"1\": (\"L\", \"L\", (\"1\",)),\n    \"L\": (\"L\", \"L\", (\"L\",)),\n    \"I\": (\"L\", \"I\", (\"I\",)),\n    \"F\": (\"L\", \"F\", (\"F\",)),\n    \"P\": (\"RGB\", \"L\", (\"P\",)),\n    \"RGB\": (\"RGB\", \"L\", (\"R\", \"G\", \"B\")),\n    \"RGBX\": (\"RGB\", \"L\", (\"R\", \"G\", \"B\", \"X\")),\n    \"RGBA\": (\"RGB\", \"L\", (\"R\", \"G\", \"B\", \"A\")),\n    \"CMYK\": (\"RGB\", \"L\", (\"C\", \"M\", \"Y\", \"K\")),\n    \"YCbCr\": (\"RGB\", \"L\", (\"Y\", \"Cb\", \"Cr\")),\n    \"LAB\": (\"RGB\", \"L\", (\"L\", \"A\", \"B\")),\n\n    # Experimental modes include I;16, I;16L, I;16B, RGBa, BGR;15, and\n    # BGR;24.  Use these modes only if you know exactly what you're\n    # doing...\n\n}\n\nif sys.byteorder == 'little':\n    _ENDIAN = '<'\nelse:\n    _ENDIAN = '>'\n\n_MODE_CONV = {\n    # official modes\n    \"1\": ('|b1', None), # broken\n    \"L\": ('|u1', None),\n    \"I\": (_ENDIAN + 'i4', None),\n    \"F\": (_ENDIAN + 'f4', None),\n    \"P\": ('|u1', None),\n    \"RGB\": ('|u1', 3),\n    \"RGBX\": ('|u1', 4),\n    \"RGBA\": ('|u1', 4),\n    \"CMYK\": ('|u1', 4),\n    \"YCbCr\": ('|u1', 3),\n    \"LAB\": ('|u1', 3), # UNDONE - unsigned |u1i1i1\n\t# I;16 == I;16L, and I;32 == I;32L  \n    \"I;16\": ('<u2', None),\n    \"I;16B\": ('>u2', None),\n    \"I;16L\": ('<u2', None),\n    \"I;16S\": ('<i2', None),\n    \"I;16BS\": ('>i2', None),\n    \"I;16LS\": ('<i2', None),\n    \"I;32\": ('<u4', None),\n    \"I;32B\": ('>u4', None),\n    \"I;32L\": ('<u4', None),\n    \"I;32S\": ('<i4', None),\n    \"I;32BS\": ('>i4', None),\n    \"I;32LS\": ('<i4', None),\n}\n\ndef _conv_type_shape(im):\n    shape = im.size[1], im.size[0]\n    typ, extra = _MODE_CONV[im.mode]\n    if extra is None:\n        return shape, typ\n    else:\n        return shape+(extra,), typ\n\n\nMODES = sorted(_MODEINFO.keys())\n\n# raw modes that may be memory mapped.  NOTE: if you change this, you\n# may have to modify the stride calculation in map.c too!\n_MAPMODES = (\"L\", \"P\", \"RGBX\", \"RGBA\", \"CMYK\", \"I;16\", \"I;16L\", \"I;16B\")\n\n\ndef getmodebase(mode):\n    \"\"\"\n    Gets the \"base\" mode for given mode.  This function returns \"L\" for\n    images that contain grayscale data, and \"RGB\" for images that\n    contain color data.\n\n    :param mode: Input mode.\n    :returns: \"L\" or \"RGB\".\n    :exception KeyError: If the input mode was not a standard mode.\n    \"\"\"\n    return ImageMode.getmode(mode).basemode\n\n\ndef getmodetype(mode):\n    \"\"\"\n    Gets the storage type mode.  Given a mode, this function returns a\n    single-layer mode suitable for storing individual bands.\n\n    :param mode: Input mode.\n    :returns: \"L\", \"I\", or \"F\".\n    :exception KeyError: If the input mode was not a standard mode.\n    \"\"\"\n    return ImageMode.getmode(mode).basetype\n\n\ndef getmodebandnames(mode):\n    \"\"\"\n    Gets a list of individual band names.  Given a mode, this function returns\n    a tuple containing the names of individual bands (use\n    :py:method:`~PIL.Image.getmodetype` to get the mode used to store each\n    individual band.\n\n    :param mode: Input mode.\n    :returns: A tuple containing band names.  The length of the tuple\n        gives the number of bands in an image of the given mode.\n    :exception KeyError: If the input mode was not a standard mode.\n    \"\"\"\n    return ImageMode.getmode(mode).bands\n\n\ndef getmodebands(mode):\n    \"\"\"\n    Gets the number of individual bands for this mode.\n\n    :param mode: Input mode.\n    :returns: The number of bands in this mode.\n    :exception KeyError: If the input mode was not a standard mode.\n    \"\"\"\n    return len(ImageMode.getmode(mode).bands)\n\n# --------------------------------------------------------------------\n# Helpers\n\n_initialized = 0\n\n\ndef preinit():\n    \"Explicitly load standard file format drivers.\"\n\n    global _initialized\n    if _initialized >= 1:\n        return\n\n    try:\n        from PIL import BmpImagePlugin\n    except ImportError:\n        pass\n    try:\n        from PIL import GifImagePlugin\n    except ImportError:\n        pass\n    try:\n        from PIL import JpegImagePlugin\n    except ImportError:\n        pass\n    try:\n        from PIL import PpmImagePlugin\n    except ImportError:\n        pass\n    try:\n        from PIL import PngImagePlugin\n    except ImportError:\n        pass\n#   try:\n#       import TiffImagePlugin\n#   except ImportError:\n#       pass\n\n    _initialized = 1\n\n\ndef init():\n    \"\"\"\n    Explicitly initializes the Python Imaging Library. This function\n    loads all available file format drivers.\n    \"\"\"\n\n    global _initialized\n    if _initialized >= 2:\n        return 0\n\n    for plugin in _plugins:\n        try:\n            if DEBUG:\n                print (\"Importing %s\"%plugin)\n            __import__(\"PIL.%s\"%plugin, globals(), locals(), [])\n        except ImportError:\n            if DEBUG:\n                print(\"Image: failed to import\", end=' ')\n                print(plugin, \":\", sys.exc_info()[1])\n\n    if OPEN or SAVE:\n        _initialized = 2\n        return 1\n\n# --------------------------------------------------------------------\n# Codec factories (used by tobytes/frombytes and ImageFile.load)\n\ndef _getdecoder(mode, decoder_name, args, extra=()):\n\n    # tweak arguments\n    if args is None:\n        args = ()\n    elif not isinstance(args, tuple):\n        args = (args,)\n\n    try:\n        # get decoder\n        decoder = getattr(core, decoder_name + \"_decoder\")\n        # print(decoder, mode, args + extra)\n        return decoder(mode, *args + extra)\n    except AttributeError:\n        raise IOError(\"decoder %s not available\" % decoder_name)\n\ndef _getencoder(mode, encoder_name, args, extra=()):\n\n    # tweak arguments\n    if args is None:\n        args = ()\n    elif not isinstance(args, tuple):\n        args = (args,)\n\n    try:\n        # get encoder\n        encoder = getattr(core, encoder_name + \"_encoder\")\n        # print(encoder, mode, args + extra)\n        return encoder(mode, *args + extra)\n    except AttributeError:\n        raise IOError(\"encoder %s not available\" % encoder_name)\n\n\n# --------------------------------------------------------------------\n# Simple expression analyzer\n\ndef coerce_e(value):\n    return value if isinstance(value, _E) else _E(value)\n\nclass _E:\n    def __init__(self, data):\n        self.data = data\n    def __add__(self, other):\n        return _E((self.data, \"__add__\", coerce_e(other).data))\n    def __mul__(self, other):\n        return _E((self.data, \"__mul__\", coerce_e(other).data))\n\ndef _getscaleoffset(expr):\n    stub = [\"stub\"]\n    data = expr(_E(stub)).data\n    try:\n        (a, b, c) = data # simplified syntax\n        if (a is stub and b == \"__mul__\" and isinstance(c, numbers.Number)):\n            return c, 0.0\n        if (a is stub and b == \"__add__\" and isinstance(c, numbers.Number)):\n            return 1.0, c\n    except TypeError: pass\n    try:\n        ((a, b, c), d, e) = data # full syntax\n        if (a is stub and b == \"__mul__\" and isinstance(c, numbers.Number) and\n            d == \"__add__\" and isinstance(e, numbers.Number)):\n            return c, e\n    except TypeError: pass\n    raise ValueError(\"illegal expression\")\n\n\n# --------------------------------------------------------------------\n# Implementation wrapper\n\nclass Image:\n    \"\"\"\n    This class represents an image object.  To create\n    :py:class:`~PIL.Image.Image` objects, use the appropriate factory\n    functions.  There's hardly ever any reason to call the Image constructor\n    directly.\n\n    * :py:func:`~PIL.Image.open`\n    * :py:func:`~PIL.Image.new`\n    * :py:func:`~PIL.Image.frombytes`\n    \"\"\"\n    format = None\n    format_description = None\n\n    def __init__(self):\n        # FIXME: take \"new\" parameters / other image?\n        # FIXME: turn mode and size into delegating properties?\n        self.im = None\n        self.mode = \"\"\n        self.size = (0, 0)\n        self.palette = None\n        self.info = {}\n        self.category = NORMAL\n        self.readonly = 0\n\n    def _new(self, im):\n        new = Image()\n        new.im = im\n        new.mode = im.mode\n        new.size = im.size\n        new.palette = self.palette\n        if im.mode == \"P\" and not new.palette:\n            from PIL import ImagePalette\n            new.palette = ImagePalette.ImagePalette()\n        try:\n            new.info = self.info.copy()\n        except AttributeError:\n            # fallback (pre-1.5.2)\n            new.info = {}\n            for k, v in self.info:\n                new.info[k] = v\n        return new\n\n    _makeself = _new # compatibility\n\n    def _copy(self):\n        self.load()\n        self.im = self.im.copy()\n        self.readonly = 0\n\n    def _dump(self, file=None, format=None):\n        import tempfile\n        if not file:\n            file = tempfile.mktemp()\n        self.load()\n        if not format or format == \"PPM\":\n            self.im.save_ppm(file)\n        else:\n            file = file + \".\" + format\n            self.save(file, format)\n        return file\n\n    def __repr__(self):\n        return \"<%s.%s image mode=%s size=%dx%d at 0x%X>\" % (\n            self.__class__.__module__, self.__class__.__name__,\n            self.mode, self.size[0], self.size[1],\n            id(self)\n            )\n\n    def __getattr__(self, name):\n        if name == \"__array_interface__\":\n            # numpy array interface support\n            new = {}\n            shape, typestr = _conv_type_shape(self)\n            new['shape'] = shape\n            new['typestr'] = typestr\n            new['data'] = self.tobytes()\n            return new\n        raise AttributeError(name)\n\n    def tobytes(self, encoder_name=\"raw\", *args):\n        \"\"\"\n        Return image as a bytes object\n\n        :param encoder_name: What encoder to use.  The default is to\n                             use the standard \"raw\" encoder.\n        :param args: Extra arguments to the encoder.\n        :rtype: A bytes object.\n        \"\"\"\n\n        # may pass tuple instead of argument list\n        if len(args) == 1 and isinstance(args[0], tuple):\n            args = args[0]\n\n        if encoder_name == \"raw\" and args == ():\n            args = self.mode\n\n        self.load()\n\n        # unpack data\n        e = _getencoder(self.mode, encoder_name, args)\n        e.setimage(self.im)\n\n        bufsize = max(65536, self.size[0] * 4) # see RawEncode.c\n\n        data = []\n        while True:\n            l, s, d = e.encode(bufsize)\n            data.append(d)\n            if s:\n                break\n        if s < 0:\n            raise RuntimeError(\"encoder error %d in tobytes\" % s)\n\n        return b\"\".join(data)\n\n    # Declare tostring as alias to tobytes\n    def tostring(self, *args, **kw):\n        warnings.warn(\n            'tostring() is deprecated. Please call tobytes() instead.',\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.tobytes(*args, **kw)\n\n    def tobitmap(self, name=\"image\"):\n        \"\"\"\n        Returns the image converted to an X11 bitmap.\n\n        .. note:: This method only works for mode \"1\" images.\n\n        :param name: The name prefix to use for the bitmap variables.\n        :returns: A string containing an X11 bitmap.\n        :raises ValueError: If the mode is not \"1\"\n        \"\"\"\n\n        self.load()\n        if self.mode != \"1\":\n            raise ValueError(\"not a bitmap\")\n        data = self.tobytes(\"xbm\")\n        return b\"\".join([(\"#define %s_width %d\\n\" % (name, self.size[0])).encode('ascii'),\n                (\"#define %s_height %d\\n\"% (name, self.size[1])).encode('ascii'),\n                (\"static char %s_bits[] = {\\n\" % name).encode('ascii'), data, b\"};\"])\n\n    def frombytes(self, data, decoder_name=\"raw\", *args):\n        \"\"\"\n        Loads this image with pixel data from a bytes object.\n\n        This method is similar to the :py:func:`~PIL.Image.frombytes` function,\n        but loads data into this image instead of creating a new image object.\n        \"\"\"\n\n        # may pass tuple instead of argument list\n        if len(args) == 1 and isinstance(args[0], tuple):\n            args = args[0]\n\n        # default format\n        if decoder_name == \"raw\" and args == ():\n            args = self.mode\n\n        # unpack data\n        d = _getdecoder(self.mode, decoder_name, args)\n        d.setimage(self.im)\n        s = d.decode(data)\n\n        if s[0] >= 0:\n            raise ValueError(\"not enough image data\")\n        if s[1] != 0:\n            raise ValueError(\"cannot decode image data\")\n\n    def fromstring(self, *args, **kw):\n        \"\"\"Deprecated alias to frombytes.\n\n        .. deprecated:: 2.0\n        \"\"\"\n        warnings.warn('fromstring() is deprecated. Please call frombytes() instead.', DeprecationWarning)\n        return self.frombytes(*args, **kw)\n\n    def load(self):\n        \"\"\"\n        Allocates storage for the image and loads the pixel data.  In\n        normal cases, you don't need to call this method, since the\n        Image class automatically loads an opened image when it is\n        accessed for the first time.\n\n        :returns: An image access object.\n        \"\"\"\n        if self.im and self.palette and self.palette.dirty:\n            # realize palette\n            self.im.putpalette(*self.palette.getdata())\n            self.palette.dirty = 0\n            self.palette.mode = \"RGB\"\n            self.palette.rawmode = None\n            if \"transparency\" in self.info:\n                if isinstance(self.info[\"transparency\"], int):\n                    self.im.putpalettealpha(self.info[\"transparency\"], 0)\n                else:\n                    self.im.putpalettealphas(self.info[\"transparency\"])\n                self.palette.mode = \"RGBA\"\n\n        if self.im:\n            return self.im.pixel_access(self.readonly)\n\n    def verify(self):\n        \"\"\"\n        Verifies the contents of a file. For data read from a file, this\n        method attempts to determine if the file is broken, without\n        actually decoding the image data.  If this method finds any\n        problems, it raises suitable exceptions.  If you need to load\n        the image after using this method, you must reopen the image\n        file.\n        \"\"\"\n        pass\n\n    def convert(self, mode=None, matrix=None, dither=None,\n                palette=WEB, colors=256):\n        \"\"\"\n        Returns a converted copy of this image. For the \"P\" mode, this\n        method translates pixels through the palette.  If mode is\n        omitted, a mode is chosen so that all information in the image\n        and the palette can be represented without a palette.\n\n        The current version supports all possible conversions between\n        \"L\", \"RGB\" and \"CMYK.\" The **matrix** argument only supports \"L\"\n        and \"RGB\".\n\n        When translating a color image to black and white (mode \"L\"),\n        the library uses the ITU-R 601-2 luma transform::\n\n            L = R * 299/1000 + G * 587/1000 + B * 114/1000\n\n        The default method of converting a greyscale (\"L\") or \"RGB\"\n        image into a bilevel (mode \"1\") image uses Floyd-Steinberg\n        dither to approximate the original image luminosity levels. If\n        dither is NONE, all non-zero values are set to 255 (white). To\n        use other thresholds, use the :py:meth:`~PIL.Image.Image.point`\n        method.\n\n        :param mode: The requested mode.\n        :param matrix: An optional conversion matrix.  If given, this\n           should be 4- or 16-tuple containing floating point values.\n        :param dither: Dithering method, used when converting from\n           mode \"RGB\" to \"P\" or from \"RGB\" or \"L\" to \"1\".\n           Available methods are NONE or FLOYDSTEINBERG (default).\n        :param palette: Palette to use when converting from mode \"RGB\"\n           to \"P\".  Available palettes are WEB or ADAPTIVE.\n        :param colors: Number of colors to use for the ADAPTIVE palette.\n           Defaults to 256.\n        :rtype: :py:class:`~PIL.Image.Image`\n        :returns: An :py:class:`~PIL.Image.Image` object.\n        \"\"\"\n\n        if not mode:\n            # determine default mode\n            if self.mode == \"P\":\n                self.load()\n                if self.palette:\n                    mode = self.palette.mode\n                else:\n                    mode = \"RGB\"\n            else:\n                return self.copy()\n\n        self.load()\n\n        if matrix:\n            # matrix conversion\n            if mode not in (\"L\", \"RGB\"):\n                raise ValueError(\"illegal conversion\")\n            im = self.im.convert_matrix(mode, matrix)\n            return self._new(im)\n\n        if mode == \"P\" and palette == ADAPTIVE:\n            im = self.im.quantize(colors)\n            return self._new(im)\n\n        # colorspace conversion\n        if dither is None:\n            dither = FLOYDSTEINBERG\n\n        # Use transparent conversion to promote from transparent color to an alpha channel.\n        if self.mode in (\"L\", \"RGB\") and mode == \"RGBA\" and \"transparency\" in self.info:\n            return self._new(self.im.convert_transparent(mode, self.info['transparency']))\n            \n        try:\n            im = self.im.convert(mode, dither)\n        except ValueError:\n            try:\n                # normalize source image and try again\n                im = self.im.convert(getmodebase(self.mode))\n                im = im.convert(mode, dither)\n            except KeyError:\n                raise ValueError(\"illegal conversion\")\n\n        return self._new(im)\n\n    def quantize(self, colors=256, method=0, kmeans=0, palette=None):\n\n        # methods:\n        #    0 = median cut\n        #    1 = maximum coverage\n        #    2 = fast octree\n\n        # NOTE: this functionality will be moved to the extended\n        # quantizer interface in a later version of PIL.\n\n        self.load()\n\n        if palette:\n            # use palette from reference image\n            palette.load()\n            if palette.mode != \"P\":\n                raise ValueError(\"bad mode for palette image\")\n            if self.mode != \"RGB\" and self.mode != \"L\":\n                raise ValueError(\n                    \"only RGB or L mode images can be quantized to a palette\"\n                    )\n            im = self.im.convert(\"P\", 1, palette.im)\n            return self._makeself(im)\n\n        im = self.im.quantize(colors, method, kmeans)\n        return self._new(im)\n\n    def copy(self):\n        \"\"\"\n        Copies this image. Use this method if you wish to paste things\n        into an image, but still retain the original.\n\n        :rtype: :py:class:`~PIL.Image.Image`\n        :returns: An :py:class:`~PIL.Image.Image` object.\n        \"\"\"\n        self.load()\n        im = self.im.copy()\n        return self._new(im)\n\n    def crop(self, box=None):\n        \"\"\"\n        Returns a rectangular region from this image. The box is a\n        4-tuple defining the left, upper, right, and lower pixel\n        coordinate.\n\n        This is a lazy operation.  Changes to the source image may or\n        may not be reflected in the cropped image.  To break the\n        connection, call the :py:meth:`~PIL.Image.Image.load` method on\n        the cropped copy.\n\n        :param box: The crop rectangle, as a (left, upper, right, lower)-tuple.\n        :rtype: :py:class:`~PIL.Image.Image`\n        :returns: An :py:class:`~PIL.Image.Image` object.\n        \"\"\"\n\n        self.load()\n        if box is None:\n            return self.copy()\n\n        # lazy operation\n        return _ImageCrop(self, box)\n\n    def draft(self, mode, size):\n        \"\"\"\n        Configures the image file loader so it returns a version of the\n        image that as closely as possible matches the given mode and\n        size.  For example, you can use this method to convert a color\n        JPEG to greyscale while loading it, or to extract a 128x192\n        version from a PCD file.\n\n        Note that this method modifies the :py:class:`~PIL.Image.Image` object\n        in place.  If the image has already been loaded, this method has no\n        effect.\n\n        :param mode: The requested mode.\n        :param size: The requested size.\n        \"\"\"\n        pass\n\n    def _expand(self, xmargin, ymargin=None):\n        if ymargin is None:\n            ymargin = xmargin\n        self.load()\n        return self._new(self.im.expand(xmargin, ymargin, 0))\n\n    def filter(self, filter):\n        \"\"\"\n        Filters this image using the given filter.  For a list of\n        available filters, see the :py:mod:`~PIL.ImageFilter` module.\n\n        :param filter: Filter kernel.\n        :returns: An :py:class:`~PIL.Image.Image` object.  \"\"\"\n\n        self.load()\n\n        if isinstance(filter, collections.Callable):\n            filter = filter()\n        if not hasattr(filter, \"filter\"):\n            raise TypeError(\"filter argument should be ImageFilter.Filter instance or class\")\n\n        if self.im.bands == 1:\n            return self._new(filter.filter(self.im))\n        # fix to handle multiband images since _imaging doesn't\n        ims = []\n        for c in range(self.im.bands):\n            ims.append(self._new(filter.filter(self.im.getband(c))))\n        return merge(self.mode, ims)\n\n    def getbands(self):\n        \"\"\"\n        Returns a tuple containing the name of each band in this image.\n        For example, **getbands** on an RGB image returns (\"R\", \"G\", \"B\").\n\n        :returns: A tuple containing band names.\n        :rtype: tuple\n        \"\"\"\n        return ImageMode.getmode(self.mode).bands\n\n    def getbbox(self):\n        \"\"\"\n        Calculates the bounding box of the non-zero regions in the\n        image.\n\n        :returns: The bounding box is returned as a 4-tuple defining the\n           left, upper, right, and lower pixel coordinate. If the image\n           is completely empty, this method returns None.\n\n        \"\"\"\n\n        self.load()\n        return self.im.getbbox()\n\n    def getcolors(self, maxcolors=256):\n        \"\"\"\n        Returns a list of colors used in this image.\n\n        :param maxcolors: Maximum number of colors.  If this number is\n           exceeded, this method returns None.  The default limit is\n           256 colors.\n        :returns: An unsorted list of (count, pixel) values.\n        \"\"\"\n\n        self.load()\n        if self.mode in (\"1\", \"L\", \"P\"):\n            h = self.im.histogram()\n            out = []\n            for i in range(256):\n                if h[i]:\n                    out.append((h[i], i))\n            if len(out) > maxcolors:\n                return None\n            return out\n        return self.im.getcolors(maxcolors)\n\n    def getdata(self, band = None):\n        \"\"\"\n        Returns the contents of this image as a sequence object\n        containing pixel values.  The sequence object is flattened, so\n        that values for line one follow directly after the values of\n        line zero, and so on.\n\n        Note that the sequence object returned by this method is an\n        internal PIL data type, which only supports certain sequence\n        operations.  To convert it to an ordinary sequence (e.g. for\n        printing), use **list(im.getdata())**.\n\n        :param band: What band to return.  The default is to return\n           all bands.  To return a single band, pass in the index\n           value (e.g. 0 to get the \"R\" band from an \"RGB\" image).\n        :returns: A sequence-like object.\n        \"\"\"\n\n        self.load()\n        if band is not None:\n            return self.im.getband(band)\n        return self.im # could be abused\n\n    def getextrema(self):\n        \"\"\"\n        Gets the the minimum and maximum pixel values for each band in\n        the image.\n\n        :returns: For a single-band image, a 2-tuple containing the\n           minimum and maximum pixel value.  For a multi-band image,\n           a tuple containing one 2-tuple for each band.\n        \"\"\"\n\n        self.load()\n        if self.im.bands > 1:\n            extrema = []\n            for i in range(self.im.bands):\n                extrema.append(self.im.getband(i).getextrema())\n            return tuple(extrema)\n        return self.im.getextrema()\n\n    def getim(self):\n        \"\"\"\n        Returns a capsule that points to the internal image memory.\n\n        :returns: A capsule object.\n        \"\"\"\n\n        self.load()\n        return self.im.ptr\n\n\n    def getpalette(self):\n        \"\"\"\n        Returns the image palette as a list.\n\n        :returns: A list of color values [r, g, b, ...], or None if the\n           image has no palette.\n        \"\"\"\n\n        self.load()\n        try:\n            if bytes is str:\n                return [i8(c) for c in self.im.getpalette()]\n            else:\n                return list(self.im.getpalette())\n        except ValueError:\n            return None # no palette\n\n\n    def getpixel(self, xy):\n        \"\"\"\n        Returns the pixel value at a given position.\n\n        :param xy: The coordinate, given as (x, y).\n        :returns: The pixel value.  If the image is a multi-layer image,\n           this method returns a tuple.\n        \"\"\"\n\n        self.load()\n        return self.im.getpixel(xy)\n\n    def getprojection(self):\n        \"\"\"\n        Get projection to x and y axes\n\n        :returns: Two sequences, indicating where there are non-zero\n            pixels along the X-axis and the Y-axis, respectively.\n        \"\"\"\n\n        self.load()\n        x, y = self.im.getprojection()\n        return [i8(c) for c in x], [i8(c) for c in y]\n\n    def histogram(self, mask=None, extrema=None):\n        \"\"\"\n        Returns a histogram for the image. The histogram is returned as\n        a list of pixel counts, one for each pixel value in the source\n        image. If the image has more than one band, the histograms for\n        all bands are concatenated (for example, the histogram for an\n        \"RGB\" image contains 768 values).\n\n        A bilevel image (mode \"1\") is treated as a greyscale (\"L\") image\n        by this method.\n\n        If a mask is provided, the method returns a histogram for those\n        parts of the image where the mask image is non-zero. The mask\n        image must have the same size as the image, and be either a\n        bi-level image (mode \"1\") or a greyscale image (\"L\").\n\n        :param mask: An optional mask.\n        :returns: A list containing pixel counts.\n        \"\"\"\n        self.load()\n        if mask:\n            mask.load()\n            return self.im.histogram((0, 0), mask.im)\n        if self.mode in (\"I\", \"F\"):\n            if extrema is None:\n                extrema = self.getextrema()\n            return self.im.histogram(extrema)\n        return self.im.histogram()\n\n    def offset(self, xoffset, yoffset=None):\n        \"\"\"\n        .. deprecated:: 2.0\n\n        .. note:: New code should use :py:func:`PIL.ImageChops.offset`.\n\n        Returns a copy of the image where the data has been offset by the given\n        distances. Data wraps around the edges. If **yoffset** is omitted, it\n        is assumed to be equal to **xoffset**.\n\n        :param xoffset: The horizontal distance.\n        :param yoffset: The vertical distance.  If omitted, both\n           distances are set to the same value.\n        :returns: An :py:class:`~PIL.Image.Image` object.\n        \"\"\"\n        if warnings:\n            warnings.warn(\n                \"'offset' is deprecated; use 'ImageChops.offset' instead\",\n                DeprecationWarning, stacklevel=2\n                )\n        from PIL import ImageChops\n        return ImageChops.offset(self, xoffset, yoffset)\n\n    def paste(self, im, box=None, mask=None):\n        \"\"\"\n        Pastes another image into this image. The box argument is either\n        a 2-tuple giving the upper left corner, a 4-tuple defining the\n        left, upper, right, and lower pixel coordinate, or None (same as\n        (0, 0)).  If a 4-tuple is given, the size of the pasted image\n        must match the size of the region.\n\n        If the modes don't match, the pasted image is converted to the mode of\n        this image (see the :py:meth:`~PIL.Image.Image.convert` method for\n        details).\n\n        Instead of an image, the source can be a integer or tuple\n        containing pixel values.  The method then fills the region\n        with the given color.  When creating RGB images, you can\n        also use color strings as supported by the ImageColor module.\n\n        If a mask is given, this method updates only the regions\n        indicated by the mask.  You can use either \"1\", \"L\" or \"RGBA\"\n        images (in the latter case, the alpha band is used as mask).\n        Where the mask is 255, the given image is copied as is.  Where\n        the mask is 0, the current value is preserved.  Intermediate\n        values can be used for transparency effects.\n\n        Note that if you paste an \"RGBA\" image, the alpha band is\n        ignored.  You can work around this by using the same image as\n        both source image and mask.\n\n        :param im: Source image or pixel value (integer or tuple).\n        :param box: An optional 4-tuple giving the region to paste into.\n           If a 2-tuple is used instead, it's treated as the upper left\n           corner.  If omitted or None, the source is pasted into the\n           upper left corner.\n\n           If an image is given as the second argument and there is no\n           third, the box defaults to (0, 0), and the second argument\n           is interpreted as a mask image.\n        :param mask: An optional mask image.\n        :returns: An :py:class:`~PIL.Image.Image` object.\n        \"\"\"\n\n        if isImageType(box) and mask is None:\n            # abbreviated paste(im, mask) syntax\n            mask = box; box = None\n\n        if box is None:\n            # cover all of self\n            box = (0, 0) + self.size\n\n        if len(box) == 2:\n            # lower left corner given; get size from image or mask\n            if isImageType(im):\n                size = im.size\n            elif isImageType(mask):\n                size = mask.size\n            else:\n                # FIXME: use self.size here?\n                raise ValueError(\n                    \"cannot determine region size; use 4-item box\"\n                    )\n            box = box + (box[0]+size[0], box[1]+size[1])\n\n        if isStringType(im):\n            from PIL import ImageColor\n            im = ImageColor.getcolor(im, self.mode)\n\n        elif isImageType(im):\n            im.load()\n            if self.mode != im.mode:\n                if self.mode != \"RGB\" or im.mode not in (\"RGBA\", \"RGBa\"):\n                    # should use an adapter for this!\n                    im = im.convert(self.mode)\n            im = im.im\n\n        self.load()\n        if self.readonly:\n            self._copy()\n\n        if mask:\n            mask.load()\n            self.im.paste(im, box, mask.im)\n        else:\n            self.im.paste(im, box)\n\n    def point(self, lut, mode=None):\n        \"\"\"\n        Maps this image through a lookup table or function.\n\n        :param lut: A lookup table, containing 256 (or 65336 if\n           self.mode==\"I\" and mode == \"L\") values per band in the\n           image.  A function can be used instead, it should take a\n           single argument. The function is called once for each\n           possible pixel value, and the resulting table is applied to\n           all bands of the image.\n        :param mode: Output mode (default is same as input).  In the\n           current version, this can only be used if the source image\n           has mode \"L\" or \"P\", and the output has mode \"1\" or the\n           source image mode is \"I\" and the output mode is \"L\".\n        :returns: An :py:class:`~PIL.Image.Image` object.\n        \"\"\"\n\n        self.load()\n\n        if isinstance(lut, ImagePointHandler):\n            return lut.point(self)\n\n        if callable(lut):\n            # if it isn't a list, it should be a function\n            if self.mode in (\"I\", \"I;16\", \"F\"):\n                # check if the function can be used with point_transform\n                # UNDONE wiredfool -- I think this prevents us from ever doing\n                # a gamma function point transform on > 8bit images. \n                scale, offset = _getscaleoffset(lut)\n                return self._new(self.im.point_transform(scale, offset))\n            # for other modes, convert the function to a table\n            lut = [lut(i) for i in range(256)] * self.im.bands\n\n        if self.mode == \"F\":\n            # FIXME: _imaging returns a confusing error message for this case\n            raise ValueError(\"point operation not supported for this mode\")\n\n        return self._new(self.im.point(lut, mode))\n\n    def putalpha(self, alpha):\n        \"\"\"\n        Adds or replaces the alpha layer in this image.  If the image\n        does not have an alpha layer, it's converted to \"LA\" or \"RGBA\".\n        The new layer must be either \"L\" or \"1\".\n\n        :param alpha: The new alpha layer.  This can either be an \"L\" or \"1\"\n           image having the same size as this image, or an integer or\n           other color value.\n        \"\"\"\n\n        self.load()\n        if self.readonly:\n            self._copy()\n\n        if self.mode not in (\"LA\", \"RGBA\"):\n            # attempt to promote self to a matching alpha mode\n            try:\n                mode = getmodebase(self.mode) + \"A\"\n                try:\n                    self.im.setmode(mode)\n                except (AttributeError, ValueError):\n                    # do things the hard way\n                    im = self.im.convert(mode)\n                    if im.mode not in (\"LA\", \"RGBA\"):\n                        raise ValueError # sanity check\n                    self.im = im\n                self.mode = self.im.mode\n            except (KeyError, ValueError):\n                raise ValueError(\"illegal image mode\")\n\n        if self.mode == \"LA\":\n            band = 1\n        else:\n            band = 3\n\n        if isImageType(alpha):\n            # alpha layer\n            if alpha.mode not in (\"1\", \"L\"):\n                raise ValueError(\"illegal image mode\")\n            alpha.load()\n            if alpha.mode == \"1\":\n                alpha = alpha.convert(\"L\")\n        else:\n            # constant alpha\n            try:\n                self.im.fillband(band, alpha)\n            except (AttributeError, ValueError):\n                # do things the hard way\n                alpha = new(\"L\", self.size, alpha)\n            else:\n                return\n\n        self.im.putband(alpha.im, band)\n\n    def putdata(self, data, scale=1.0, offset=0.0):\n        \"\"\"\n        Copies pixel data to this image.  This method copies data from a\n        sequence object into the image, starting at the upper left\n        corner (0, 0), and continuing until either the image or the\n        sequence ends.  The scale and offset values are used to adjust\n        the sequence values: **pixel = value*scale + offset**.\n\n        :param data: A sequence object.\n        :param scale: An optional scale value.  The default is 1.0.\n        :param offset: An optional offset value.  The default is 0.0.\n        \"\"\"\n\n        self.load()\n        if self.readonly:\n            self._copy()\n\n        self.im.putdata(data, scale, offset)\n\n    def putpalette(self, data, rawmode=\"RGB\"):\n        \"\"\"\n        Attaches a palette to this image.  The image must be a \"P\" or\n        \"L\" image, and the palette sequence must contain 768 integer\n        values, where each group of three values represent the red,\n        green, and blue values for the corresponding pixel\n        index. Instead of an integer sequence, you can use an 8-bit\n        string.\n\n        :param data: A palette sequence (either a list or a string).\n        \"\"\"\n        from PIL import ImagePalette\n\n        if self.mode not in (\"L\", \"P\"):\n            raise ValueError(\"illegal image mode\")\n        self.load()\n        if isinstance(data, ImagePalette.ImagePalette):\n            palette = ImagePalette.raw(data.rawmode, data.palette)\n        else:\n            if not isinstance(data, bytes):\n                if bytes is str:\n                    data = \"\".join(chr(x) for x in data)\n                else:\n                    data = bytes(data)\n            palette = ImagePalette.raw(rawmode, data)\n        self.mode = \"P\"\n        self.palette = palette\n        self.palette.mode = \"RGB\"\n        self.load() # install new palette\n\n    def putpixel(self, xy, value):\n        \"\"\"\n        Modifies the pixel at the given position. The color is given as\n        a single numerical value for single-band images, and a tuple for\n        multi-band images.\n\n        Note that this method is relatively slow.  For more extensive changes,\n        use :py:meth:`~PIL.Image.Image.paste` or the :py:mod:`~PIL.ImageDraw`\n        module instead.\n\n        See:\n\n        * :py:meth:`~PIL.Image.Image.paste`\n        * :py:meth:`~PIL.Image.Image.putdata`\n        * :py:mod:`~PIL.ImageDraw`\n\n        :param xy: The pixel coordinate, given as (x, y).\n        :param value: The pixel value.\n        \"\"\"\n\n        self.load()\n        if self.readonly:\n            self._copy()\n\n        return self.im.putpixel(xy, value)\n\n    def resize(self, size, resample=NEAREST):\n        \"\"\"\n        Returns a resized copy of this image.\n\n        :param size: The requested size in pixels, as a 2-tuple:\n           (width, height).\n        :param filter: An optional resampling filter.  This can be\n           one of :py:attr:`PIL.Image.NEAREST` (use nearest neighbour),\n           :py:attr:`PIL.Image.BILINEAR` (linear interpolation in a 2x2\n           environment), :py:attr:`PIL.Image.BICUBIC` (cubic spline\n           interpolation in a 4x4 environment), or\n           :py:attr:`PIL.Image.ANTIALIAS` (a high-quality downsampling filter).\n           If omitted, or if the image has mode \"1\" or \"P\", it is\n           set :py:attr:`PIL.Image.NEAREST`.\n        :returns: An :py:class:`~PIL.Image.Image` object.\n        \"\"\"\n\n        if resample not in (NEAREST, BILINEAR, BICUBIC, ANTIALIAS):\n            raise ValueError(\"unknown resampling filter\")\n\n        self.load()\n\n        if self.mode in (\"1\", \"P\"):\n            resample = NEAREST\n\n        if self.mode == 'RGBA':\n            return self.convert('RGBa').resize(size, resample).convert('RGBA')\n\n        if resample == ANTIALIAS:\n            # requires stretch support (imToolkit & PIL 1.1.3)\n            try:\n                im = self.im.stretch(size, resample)\n            except AttributeError:\n                raise ValueError(\"unsupported resampling filter\")\n        else:\n            im = self.im.resize(size, resample)\n\n        return self._new(im)\n\n    def rotate(self, angle, resample=NEAREST, expand=0):\n        \"\"\"\n        Returns a rotated copy of this image.  This method returns a\n        copy of this image, rotated the given number of degrees counter\n        clockwise around its centre.\n\n        :param angle: In degrees counter clockwise.\n        :param filter: An optional resampling filter.  This can be\n           one of :py:attr:`PIL.Image.NEAREST` (use nearest neighbour),\n           :py:attr:`PIL.Image.BILINEAR` (linear interpolation in a 2x2\n           environment), or :py:attr:`PIL.Image.BICUBIC`\n           (cubic spline interpolation in a 4x4 environment).\n           If omitted, or if the image has mode \"1\" or \"P\", it is\n           set :py:attr:`PIL.Image.NEAREST`.\n        :param expand: Optional expansion flag.  If true, expands the output\n           image to make it large enough to hold the entire rotated image.\n           If false or omitted, make the output image the same size as the\n           input image.\n        :returns: An :py:class:`~PIL.Image.Image` object.\n        \"\"\"\n\n        if expand:\n            import math\n            angle = -angle * math.pi / 180\n            matrix = [\n                 math.cos(angle), math.sin(angle), 0.0,\n                -math.sin(angle), math.cos(angle), 0.0\n                 ]\n            def transform(x, y, matrix=matrix):\n                (a, b, c, d, e, f) = matrix\n                return a*x + b*y + c, d*x + e*y + f\n\n            # calculate output size\n            w, h = self.size\n            xx = []\n            yy = []\n            for x, y in ((0, 0), (w, 0), (w, h), (0, h)):\n                x, y = transform(x, y)\n                xx.append(x)\n                yy.append(y)\n            w = int(math.ceil(max(xx)) - math.floor(min(xx)))\n            h = int(math.ceil(max(yy)) - math.floor(min(yy)))\n\n            # adjust center\n            x, y = transform(w / 2.0, h / 2.0)\n            matrix[2] = self.size[0] / 2.0 - x\n            matrix[5] = self.size[1] / 2.0 - y\n\n            return self.transform((w, h), AFFINE, matrix, resample)\n\n        if resample not in (NEAREST, BILINEAR, BICUBIC):\n            raise ValueError(\"unknown resampling filter\")\n\n        self.load()\n\n        if self.mode in (\"1\", \"P\"):\n            resample = NEAREST\n\n        return self._new(self.im.rotate(angle, resample))\n\n    def save(self, fp, format=None, **params):\n        \"\"\"\n        Saves this image under the given filename.  If no format is\n        specified, the format to use is determined from the filename\n        extension, if possible.\n\n        Keyword options can be used to provide additional instructions\n        to the writer. If a writer doesn't recognise an option, it is\n        silently ignored. The available options are described later in\n        this handbook.\n\n        You can use a file object instead of a filename. In this case,\n        you must always specify the format. The file object must\n        implement the **seek**, **tell**, and **write**\n        methods, and be opened in binary mode.\n\n        :param file: File name or file object.\n        :param format: Optional format override.  If omitted, the\n           format to use is determined from the filename extension.\n           If a file object was used instead of a filename, this\n           parameter should always be used.\n        :param options: Extra parameters to the image writer.\n        :returns: None\n        :exception KeyError: If the output format could not be determined\n           from the file name.  Use the format option to solve this.\n        :exception IOError: If the file could not be written.  The file\n           may have been created, and may contain partial data.\n        \"\"\"\n\n        if isPath(fp):\n            filename = fp\n        else:\n            if hasattr(fp, \"name\") and isPath(fp.name):\n                filename = fp.name\n            else:\n                filename = \"\"\n\n        # may mutate self!\n        self.load()\n\n        self.encoderinfo = params\n        self.encoderconfig = ()\n\n        preinit()\n\n        ext = os.path.splitext(filename)[1].lower()\n\n        if not format:\n            try:\n                format = EXTENSION[ext]\n            except KeyError:\n                init()\n                try:\n                    format = EXTENSION[ext]\n                except KeyError:\n                    raise KeyError(ext) # unknown extension\n\n        try:\n            save_handler = SAVE[format.upper()]\n        except KeyError:\n            init()\n            save_handler = SAVE[format.upper()] # unknown format\n\n        if isPath(fp):\n            fp = builtins.open(fp, \"wb\")\n            close = 1\n        else:\n            close = 0\n\n        try:\n            save_handler(self, fp, filename)\n        finally:\n            # do what we can to clean up\n            if close:\n                fp.close()\n\n    def seek(self, frame):\n        \"\"\"\n        Seeks to the given frame in this sequence file. If you seek\n        beyond the end of the sequence, the method raises an\n        **EOFError** exception. When a sequence file is opened, the\n        library automatically seeks to frame 0.\n\n        Note that in the current version of the library, most sequence\n        formats only allows you to seek to the next frame.\n\n        See :py:meth:`~PIL.Image.Image.tell`.\n\n        :param frame: Frame number, starting at 0.\n        :exception EOFError: If the call attempts to seek beyond the end\n            of the sequence.\n        \"\"\"\n\n        # overridden by file handlers\n        if frame != 0:\n            raise EOFError\n\n    def show(self, title=None, command=None):\n        \"\"\"\n        Displays this image. This method is mainly intended for\n        debugging purposes.\n\n        On Unix platforms, this method saves the image to a temporary\n        PPM file, and calls the **xv** utility.\n\n        On Windows, it saves the image to a temporary BMP file, and uses\n        the standard BMP display utility to show it (usually Paint).\n\n        :param title: Optional title to use for the image window,\n           where possible.\n        :param command: command used to show the image\n        \"\"\"\n\n        _show(self, title=title, command=command)\n\n    def split(self):\n        \"\"\"\n        Split this image into individual bands. This method returns a\n        tuple of individual image bands from an image. For example,\n        splitting an \"RGB\" image creates three new images each\n        containing a copy of one of the original bands (red, green,\n        blue).\n\n        :returns: A tuple containing bands.\n        \"\"\"\n\n        self.load()\n        if self.im.bands == 1:\n            ims = [self.copy()]\n        else:\n            ims = []\n            for i in range(self.im.bands):\n                ims.append(self._new(self.im.getband(i)))\n        return tuple(ims)\n\n    def tell(self):\n        \"\"\"\n        Returns the current frame number. See :py:meth:`~PIL.Image.Image.seek`.\n\n        :returns: Frame number, starting with 0.\n        \"\"\"\n        return 0\n\n    def thumbnail(self, size, resample=NEAREST):\n        \"\"\"\n        Make this image into a thumbnail.  This method modifies the\n        image to contain a thumbnail version of itself, no larger than\n        the given size.  This method calculates an appropriate thumbnail\n        size to preserve the aspect of the image, calls the\n        :py:meth:`~PIL.Image.Image.draft` method to configure the file reader\n        (where applicable), and finally resizes the image.\n\n        Note that the bilinear and bicubic filters in the current\n        version of PIL are not well-suited for thumbnail generation.\n        You should use :py:attr:`PIL.Image.ANTIALIAS` unless speed is much more\n        important than quality.\n\n        Also note that this function modifies the :py:class:`~PIL.Image.Image`\n        object in place.  If you need to use the full resolution image as well, apply\n        this method to a :py:meth:`~PIL.Image.Image.copy` of the original image.\n\n        :param size: Requested size.\n        :param resample: Optional resampling filter.  This can be one\n           of :py:attr:`PIL.Image.NEAREST`, :py:attr:`PIL.Image.BILINEAR`,\n           :py:attr:`PIL.Image.BICUBIC`, or :py:attr:`PIL.Image.ANTIALIAS`\n           (best quality).  If omitted, it defaults to\n           :py:attr:`PIL.Image.NEAREST` (this will be changed to ANTIALIAS in a\n           future version).\n        :returns: None\n        \"\"\"\n\n        # FIXME: the default resampling filter will be changed\n        # to ANTIALIAS in future versions\n\n        # preserve aspect ratio\n        x, y = self.size\n        if x > size[0]: y = int(max(y * size[0] / x, 1)); x = int(size[0])\n        if y > size[1]: x = int(max(x * size[1] / y, 1)); y = int(size[1])\n        size = x, y\n\n        if size == self.size:\n            return\n\n        self.draft(None, size)\n\n        self.load()\n\n        try:\n            im = self.resize(size, resample)\n        except ValueError:\n            if resample != ANTIALIAS:\n                raise\n            im = self.resize(size, NEAREST) # fallback\n\n        self.im = im.im\n        self.mode = im.mode\n        self.size = size\n\n        self.readonly = 0\n\n    # FIXME: the different tranform methods need further explanation\n    # instead of bloating the method docs, add a separate chapter.\n    def transform(self, size, method, data=None, resample=NEAREST, fill=1):\n        \"\"\"\n        Transforms this image.  This method creates a new image with the\n        given size, and the same mode as the original, and copies data\n        to the new image using the given transform.\n\n        :param size: The output size.\n        :param method: The transformation method.  This is one of\n          :py:attr:`PIL.Image.EXTENT` (cut out a rectangular subregion),\n          :py:attr:`PIL.Image.AFFINE` (affine transform),\n          :py:attr:`PIL.Image.PERSPECTIVE` (perspective transform),\n          :py:attr:`PIL.Image.QUAD` (map a quadrilateral to a rectangle), or\n          :py:attr:`PIL.Image.MESH` (map a number of source quadrilaterals\n          in one operation).\n        :param data: Extra data to the transformation method.\n        :param resample: Optional resampling filter.  It can be one of\n           :py:attr:`PIL.Image.NEAREST` (use nearest neighbour),\n           :py:attr:`PIL.Image.BILINEAR` (linear interpolation in a 2x2\n           environment), or :py:attr:`PIL.Image.BICUBIC` (cubic spline\n           interpolation in a 4x4 environment). If omitted, or if the image\n           has mode \"1\" or \"P\", it is set to :py:attr:`PIL.Image.NEAREST`.\n        :returns: An :py:class:`~PIL.Image.Image` object.\n        \"\"\"\n\n        if self.mode == 'RGBA':\n            return self.convert('RGBa').transform(size, method, data, resample, fill).convert('RGBA')\n\n        if isinstance(method, ImageTransformHandler):\n            return method.transform(size, self, resample=resample, fill=fill)\n        if hasattr(method, \"getdata\"):\n            # compatibility w. old-style transform objects\n            method, data = method.getdata()\n        if data is None:\n            raise ValueError(\"missing method data\")\n\n        im = new(self.mode, size, None)\n        if method == MESH:\n            # list of quads\n            for box, quad in data:\n                im.__transformer(box, self, QUAD, quad, resample, fill)\n        else:\n            im.__transformer((0, 0)+size, self, method, data, resample, fill)\n\n        return im\n\n    def __transformer(self, box, image, method, data,\n                      resample=NEAREST, fill=1):\n\n        # FIXME: this should be turned into a lazy operation (?)\n\n        w = box[2]-box[0]\n        h = box[3]-box[1]\n\n        if method == AFFINE:\n            # change argument order to match implementation\n            data = (data[2], data[0], data[1],\n                    data[5], data[3], data[4])\n        elif method == EXTENT:\n            # convert extent to an affine transform\n            x0, y0, x1, y1 = data\n            xs = float(x1 - x0) / w\n            ys = float(y1 - y0) / h\n            method = AFFINE\n            data = (x0 + xs/2, xs, 0, y0 + ys/2, 0, ys)\n        elif method == PERSPECTIVE:\n            # change argument order to match implementation\n            data = (data[2], data[0], data[1],\n                    data[5], data[3], data[4],\n                    data[6], data[7])\n        elif method == QUAD:\n            # quadrilateral warp.  data specifies the four corners\n            # given as NW, SW, SE, and NE.\n            nw = data[0:2]; sw = data[2:4]; se = data[4:6]; ne = data[6:8]\n            x0, y0 = nw; As = 1.0 / w; At = 1.0 / h\n            data = (x0, (ne[0]-x0)*As, (sw[0]-x0)*At,\n                    (se[0]-sw[0]-ne[0]+x0)*As*At,\n                    y0, (ne[1]-y0)*As, (sw[1]-y0)*At,\n                    (se[1]-sw[1]-ne[1]+y0)*As*At)\n        else:\n            raise ValueError(\"unknown transformation method\")\n\n        if resample not in (NEAREST, BILINEAR, BICUBIC):\n            raise ValueError(\"unknown resampling filter\")\n\n        image.load()\n\n        self.load()\n\n        if image.mode in (\"1\", \"P\"):\n            resample = NEAREST\n\n        self.im.transform2(box, image.im, method, data, resample, fill)\n\n    def transpose(self, method):\n        \"\"\"\n        Transpose image (flip or rotate in 90 degree steps)\n\n        :param method: One of :py:attr:`PIL.Image.FLIP_LEFT_RIGHT`,\n          :py:attr:`PIL.Image.FLIP_TOP_BOTTOM`, :py:attr:`PIL.Image.ROTATE_90`,\n          :py:attr:`PIL.Image.ROTATE_180`, or :py:attr:`PIL.Image.ROTATE_270`.\n        :returns: Returns a flipped or rotated copy of this image.\n        \"\"\"\n\n        self.load()\n        im = self.im.transpose(method)\n        return self._new(im)\n\n# --------------------------------------------------------------------\n# Lazy operations\n\nclass _ImageCrop(Image):\n\n    def __init__(self, im, box):\n\n        Image.__init__(self)\n\n        x0, y0, x1, y1 = box\n        if x1 < x0:\n            x1 = x0\n        if y1 < y0:\n            y1 = y0\n\n        self.mode = im.mode\n        self.size = x1-x0, y1-y0\n\n        self.__crop = x0, y0, x1, y1\n\n        self.im = im.im\n\n    def load(self):\n\n        # lazy evaluation!\n        if self.__crop:\n            self.im = self.im.crop(self.__crop)\n            self.__crop = None\n\n        if self.im:\n            return self.im.pixel_access(self.readonly)\n\n        # FIXME: future versions should optimize crop/paste\n        # sequences!\n\n# --------------------------------------------------------------------\n# Abstract handlers.\n\nclass ImagePointHandler:\n    # used as a mixin by point transforms (for use with im.point)\n    pass\n\nclass ImageTransformHandler:\n    # used as a mixin by geometry transforms (for use with im.transform)\n    pass\n\n# --------------------------------------------------------------------\n# Factories\n\n#\n# Debugging\n\ndef _wedge():\n    \"Create greyscale wedge (for debugging only)\"\n\n    return Image()._new(core.wedge(\"L\"))\n\n\ndef new(mode, size, color=0):\n    \"\"\"\n    Creates a new image with the given mode and size.\n\n    :param mode: The mode to use for the new image.\n    :param size: A 2-tuple, containing (width, height) in pixels.\n    :param color: What color to use for the image.  Default is black.\n       If given, this should be a single integer or floating point value\n       for single-band modes, and a tuple for multi-band modes (one value\n       per band).  When creating RGB images, you can also use color\n       strings as supported by the ImageColor module.  If the color is\n       None, the image is not initialised.\n    :returns: An :py:class:`~PIL.Image.Image` object.\n    \"\"\"\n\n    if color is None:\n        # don't initialize\n        return Image()._new(core.new(mode, size))\n\n    if isStringType(color):\n        # css3-style specifier\n\n        from PIL import ImageColor\n        color = ImageColor.getcolor(color, mode)\n\n    return Image()._new(core.fill(mode, size, color))\n\n\ndef frombytes(mode, size, data, decoder_name=\"raw\", *args):\n    \"\"\"\n    Creates a copy of an image memory from pixel data in a buffer.\n\n    In its simplest form, this function takes three arguments\n    (mode, size, and unpacked pixel data).\n\n    You can also use any pixel decoder supported by PIL.  For more\n    information on available decoders, see the section\n    **Writing Your Own File Decoder**.\n\n    Note that this function decodes pixel data only, not entire images.\n    If you have an entire image in a string, wrap it in a\n    :py:class:`~io.BytesIO` object, and use :py:func:`~PIL.Image.open` to load\n    it.\n\n    :param mode: The image mode.\n    :param size: The image size.\n    :param data: A byte buffer containing raw data for the given mode.\n    :param decoder_name: What decoder to use.\n    :param args: Additional parameters for the given decoder.\n    :returns: An :py:class:`~PIL.Image.Image` object.\n    \"\"\"\n\n    # may pass tuple instead of argument list\n    if len(args) == 1 and isinstance(args[0], tuple):\n        args = args[0]\n\n    if decoder_name == \"raw\" and args == ():\n        args = mode\n\n    im = new(mode, size)\n    im.frombytes(data, decoder_name, args)\n    return im\n\ndef fromstring(*args, **kw):\n    \"\"\"Deprecated alias to frombytes.\n\n    .. deprecated:: 2.0\n    \"\"\"\n    warnings.warn(\n        'fromstring() is deprecated. Please call frombytes() instead.',\n        DeprecationWarning,\n        stacklevel=2\n    )\n    return frombytes(*args, **kw)\n\n\ndef frombuffer(mode, size, data, decoder_name=\"raw\", *args):\n    \"\"\"\n    Creates an image memory referencing pixel data in a byte buffer.\n\n    This function is similar to :py:func:`~PIL.Image.frombytes`, but uses data\n    in the byte buffer, where possible.  This means that changes to the\n    original buffer object are reflected in this image).  Not all modes can\n    share memory; supported modes include \"L\", \"RGBX\", \"RGBA\", and \"CMYK\".\n\n    Note that this function decodes pixel data only, not entire images.\n    If you have an entire image file in a string, wrap it in a\n    **BytesIO** object, and use :py:func:`~PIL.Image.open` to load it.\n\n    In the current version, the default parameters used for the \"raw\" decoder\n    differs from that used for :py:func:`~PIL.Image.fromstring`.  This is a\n    bug, and will probably be fixed in a future release.  The current release\n    issues a warning if you do this; to disable the warning, you should provide\n    the full set of parameters.  See below for details.\n\n    :param mode: The image mode.\n    :param size: The image size.\n    :param data: A bytes or other buffer object containing raw\n        data for the given mode.\n    :param decoder_name: What decoder to use.\n    :param args: Additional parameters for the given decoder.  For the\n        default encoder (\"raw\"), it's recommended that you provide the\n        full set of parameters::\n\n            frombuffer(mode, size, data, \"raw\", mode, 0, 1)\n\n    :returns: An :py:class:`~PIL.Image.Image` object.\n\n    .. versionadded:: 1.1.4\n    \"\"\"\n    \"Load image from bytes or buffer\"\n\n    # may pass tuple instead of argument list\n    if len(args) == 1 and isinstance(args[0], tuple):\n        args = args[0]\n\n    if decoder_name == \"raw\":\n        if args == ():\n            if warnings:\n                warnings.warn(\n                    \"the frombuffer defaults may change in a future release; \"\n                    \"for portability, change the call to read:\\n\"\n                    \"  frombuffer(mode, size, data, 'raw', mode, 0, 1)\",\n                    RuntimeWarning, stacklevel=2\n                )\n            args = mode, 0, -1 # may change to (mode, 0, 1) post-1.1.6\n        if args[0] in _MAPMODES:\n            im = new(mode, (1,1))\n            im = im._new(\n                core.map_buffer(data, size, decoder_name, None, 0, args)\n                )\n            im.readonly = 1\n            return im\n\n    return frombytes(mode, size, data, decoder_name, args)\n\n\ndef fromarray(obj, mode=None):\n    \"\"\"\n    Creates an image memory from an object exporting the array interface\n    (using the buffer protocol).\n\n    If obj is not contiguous, then the tobytes method is called\n    and :py:func:`~PIL.Image.frombuffer` is used.\n\n    :param obj: Object with array interface\n    :param mode: Mode to use (will be determined from type if None)\n    :returns: An image memory.\n\n    .. versionadded:: 1.1.6\n    \"\"\"\n    arr = obj.__array_interface__\n    shape = arr['shape']\n    ndim = len(shape)\n    try:\n        strides = arr['strides']\n    except KeyError:\n        strides = None\n    if mode is None:\n        try:\n            typekey = (1, 1) + shape[2:], arr['typestr']\n            mode, rawmode = _fromarray_typemap[typekey]\n        except KeyError:\n            # print typekey\n            raise TypeError(\"Cannot handle this data type\")\n    else:\n        rawmode = mode\n    if mode in [\"1\", \"L\", \"I\", \"P\", \"F\"]:\n        ndmax = 2\n    elif mode == \"RGB\":\n        ndmax = 3\n    else:\n        ndmax = 4\n    if ndim > ndmax:\n        raise ValueError(\"Too many dimensions.\")\n\n    size = shape[1], shape[0]\n    if strides is not None:\n        if hasattr(obj, 'tobytes'):\n            obj = obj.tobytes()\n        else:\n            obj = obj.tostring()\n\n    return frombuffer(mode, size, obj, \"raw\", rawmode, 0, 1)\n\n_fromarray_typemap = {\n    # (shape, typestr) => mode, rawmode\n    # first two members of shape are set to one\n    # ((1, 1), \"|b1\"): (\"1\", \"1\"), # broken\n    ((1, 1), \"|u1\"): (\"L\", \"L\"),\n    ((1, 1), \"|i1\"): (\"I\", \"I;8\"),\n    ((1, 1), \"<i2\"): (\"I\", \"I;16\"),\n    ((1, 1), \">i2\"): (\"I\", \"I;16B\"),\n    ((1, 1), \"<i4\"): (\"I\", \"I;32\"),\n    ((1, 1), \">i4\"): (\"I\", \"I;32B\"),\n    ((1, 1), \"<f4\"): (\"F\", \"F;32F\"),\n    ((1, 1), \">f4\"): (\"F\", \"F;32BF\"),\n    ((1, 1), \"<f8\"): (\"F\", \"F;64F\"),\n    ((1, 1), \">f8\"): (\"F\", \"F;64BF\"),\n    ((1, 1, 3), \"|u1\"): (\"RGB\", \"RGB\"),\n    ((1, 1, 4), \"|u1\"): (\"RGBA\", \"RGBA\"),\n    }\n\n# shortcuts\n_fromarray_typemap[((1, 1), _ENDIAN + \"i4\")] = (\"I\", \"I\")\n_fromarray_typemap[((1, 1), _ENDIAN + \"f4\")] = (\"F\", \"F\")\n\n\ndef open(fp, mode=\"r\"):\n    \"\"\"\n    Opens and identifies the given image file.\n\n    This is a lazy operation; this function identifies the file, but the\n    actual image data is not read from the file until you try to process\n    the data (or call the :py:meth:`~PIL.Image.Image.load` method).\n    See :py:func:`~PIL.Image.new`.\n\n    :param file: A filename (string) or a file object.  The file object\n       must implement :py:meth:`~file.read`, :py:meth:`~file.seek`, and\n       :py:meth:`~file.tell` methods, and be opened in binary mode.\n    :param mode: The mode.  If given, this argument must be \"r\".\n    :returns: An :py:class:`~PIL.Image.Image` object.\n    :exception IOError: If the file cannot be found, or the image cannot be\n       opened and identified.\n    \"\"\"\n\n    if mode != \"r\":\n        raise ValueError(\"bad mode\")\n\n    if isPath(fp):\n        filename = fp\n        fp = builtins.open(fp, \"rb\")\n    else:\n        filename = \"\"\n\n    prefix = fp.read(16)\n\n    preinit()\n\n    for i in ID:\n        try:\n            factory, accept = OPEN[i]\n            if not accept or accept(prefix):\n                fp.seek(0)\n                return factory(fp, filename)\n        except (SyntaxError, IndexError, TypeError):\n            #import traceback\n            #traceback.print_exc()\n            pass\n\n    if init():\n\n        for i in ID:\n            try:\n                factory, accept = OPEN[i]\n                if not accept or accept(prefix):\n                    fp.seek(0)\n                    return factory(fp, filename)\n            except (SyntaxError, IndexError, TypeError):\n                #import traceback\n                #traceback.print_exc()\n                pass\n\n    raise IOError(\"cannot identify image file\")\n\n#\n# Image processing.\n\ndef alpha_composite(im1, im2):\n    \"\"\"\n    Alpha composite im2 over im1.\n\n    :param im1: The first image.\n    :param im2: The second image.  Must have the same mode and size as\n       the first image.\n    :returns: An :py:class:`~PIL.Image.Image` object.\n    \"\"\"\n\n    im1.load()\n    im2.load()\n    return im1._new(core.alpha_composite(im1.im, im2.im))\n\n\ndef blend(im1, im2, alpha):\n    \"\"\"\n    Creates a new image by interpolating between two input images, using\n    a constant alpha.::\n\n        out = image1 * (1.0 - alpha) + image2 * alpha\n\n    :param im1: The first image.\n    :param im2: The second image.  Must have the same mode and size as\n       the first image.\n    :param alpha: The interpolation alpha factor.  If alpha is 0.0, a\n       copy of the first image is returned. If alpha is 1.0, a copy of\n       the second image is returned. There are no restrictions on the\n       alpha value. If necessary, the result is clipped to fit into\n       the allowed output range.\n    :returns: An :py:class:`~PIL.Image.Image` object.\n    \"\"\"\n\n    im1.load()\n    im2.load()\n    return im1._new(core.blend(im1.im, im2.im, alpha))\n\n\ndef composite(image1, image2, mask):\n    \"\"\"\n    Create composite image by blending images using a transparency mask.\n\n    :param image1: The first image.\n    :param image2: The second image.  Must have the same mode and\n       size as the first image.\n    :param mask: A mask image.  This image can can have mode\n       \"1\", \"L\", or \"RGBA\", and must have the same size as the\n       other two images.\n    \"\"\"\n\n    image = image2.copy()\n    image.paste(image1, None, mask)\n    return image\n\n\ndef eval(image, *args):\n    \"\"\"\n    Applies the function (which should take one argument) to each pixel\n    in the given image. If the image has more than one band, the same\n    function is applied to each band. Note that the function is\n    evaluated once for each possible pixel value, so you cannot use\n    random components or other generators.\n\n    :param image: The input image.\n    :param function: A function object, taking one integer argument.\n    :returns: An :py:class:`~PIL.Image.Image` object.\n    \"\"\"\n\n    return image.point(args[0])\n\n\ndef merge(mode, bands):\n    \"\"\"\n    Merge a set of single band images into a new multiband image.\n\n    :param mode: The mode to use for the output image.\n    :param bands: A sequence containing one single-band image for\n        each band in the output image.  All bands must have the\n        same size.\n    :returns: An :py:class:`~PIL.Image.Image` object.\n    \"\"\"\n\n    if getmodebands(mode) != len(bands) or \"*\" in mode:\n        raise ValueError(\"wrong number of bands\")\n    for im in bands[1:]:\n        if im.mode != getmodetype(mode):\n            raise ValueError(\"mode mismatch\")\n        if im.size != bands[0].size:\n            raise ValueError(\"size mismatch\")\n    im = core.new(mode, bands[0].size)\n    for i in range(getmodebands(mode)):\n        bands[i].load()\n        im.putband(bands[i].im, i)\n    return bands[0]._new(im)\n\n# --------------------------------------------------------------------\n# Plugin registry\n\ndef register_open(id, factory, accept=None):\n    \"\"\"\n    Register an image file plugin.  This function should not be used\n    in application code.\n\n    :param id: An image format identifier.\n    :param factory: An image file factory method.\n    :param accept: An optional function that can be used to quickly\n       reject images having another format.\n    \"\"\"\n    id = id.upper()\n    ID.append(id)\n    OPEN[id] = factory, accept\n\n\ndef register_mime(id, mimetype):\n    \"\"\"\n    Registers an image MIME type.  This function should not be used\n    in application code.\n\n    :param id: An image format identifier.\n    :param mimetype: The image MIME type for this format.\n    \"\"\"\n    MIME[id.upper()] = mimetype\n\n\ndef register_save(id, driver):\n    \"\"\"\n    Registers an image save function.  This function should not be\n    used in application code.\n\n    :param id: An image format identifier.\n    :param driver: A function to save images in this format.\n    \"\"\"\n    SAVE[id.upper()] = driver\n\n\ndef register_extension(id, extension):\n    \"\"\"\n    Registers an image extension.  This function should not be\n    used in application code.\n\n    :param id: An image format identifier.\n    :param extension: An extension used for this format.\n    \"\"\"\n    EXTENSION[extension.lower()] = id.upper()\n\n\n# --------------------------------------------------------------------\n# Simple display support.  User code may override this.\n\ndef _show(image, **options):\n    # override me, as necessary\n    _showxv(image, **options)\n\ndef _showxv(image, title=None, **options):\n    from PIL import ImageShow\n    ImageShow.show(image, title, **options)\n", "#\n# The Python Imaging Library.\n# $Id$\n#\n# IPTC/NAA file handling\n#\n# history:\n# 1995-10-01 fl   Created\n# 1998-03-09 fl   Cleaned up and added to PIL\n# 2002-06-18 fl   Added getiptcinfo helper\n#\n# Copyright (c) Secret Labs AB 1997-2002.\n# Copyright (c) Fredrik Lundh 1995.\n#\n# See the README file for information on usage and redistribution.\n#\n\nfrom __future__ import print_function\n\n__version__ = \"0.3\"\n\n\nfrom PIL import Image, ImageFile, _binary\nimport os, tempfile\n\ni8 = _binary.i8\ni16 = _binary.i16be\ni32 = _binary.i32be\no8 = _binary.o8\n\nCOMPRESSION = {\n    1: \"raw\",\n    5: \"jpeg\"\n}\n\nPAD = o8(0) * 4\n\n#\n# Helpers\n\ndef i(c):\n    return i32((PAD + c)[-4:])\n\ndef dump(c):\n    for i in c:\n        print(\"%02x\" % i8(i), end=' ')\n    print()\n\n##\n# Image plugin for IPTC/NAA datastreams.  To read IPTC/NAA fields\n# from TIFF and JPEG files, use the <b>getiptcinfo</b> function.\n\nclass IptcImageFile(ImageFile.ImageFile):\n\n    format = \"IPTC\"\n    format_description = \"IPTC/NAA\"\n\n    def getint(self, key):\n        return i(self.info[key])\n\n    def field(self):\n        #\n        # get a IPTC field header\n        s = self.fp.read(5)\n        if not len(s):\n            return None, 0\n\n        tag = i8(s[1]), i8(s[2])\n\n        # syntax\n        if i8(s[0]) != 0x1C or tag[0] < 1 or tag[0] > 9:\n            raise SyntaxError(\"invalid IPTC/NAA file\")\n\n        # field size\n        size = i8(s[3])\n        if size > 132:\n            raise IOError(\"illegal field length in IPTC/NAA file\")\n        elif size == 128:\n            size = 0\n        elif size > 128:\n            size = i(self.fp.read(size-128))\n        else:\n            size = i16(s[3:])\n\n        return tag, size\n\n    def _is_raw(self, offset, size):\n        #\n        # check if the file can be mapped\n\n        # DISABLED: the following only slows things down...\n        return 0\n\n        self.fp.seek(offset)\n        t, sz = self.field()\n        if sz != size[0]:\n            return 0\n        y = 1\n        while True:\n            self.fp.seek(sz, 1)\n            t, s = self.field()\n            if t != (8, 10):\n                break\n            if s != sz:\n                return 0\n            y = y + 1\n        return y == size[1]\n\n    def _open(self):\n\n        # load descriptive fields\n        while True:\n            offset = self.fp.tell()\n            tag, size = self.field()\n            if not tag or tag == (8,10):\n                break\n            if size:\n                tagdata = self.fp.read(size)\n            else:\n                tagdata = None\n            if tag in list(self.info.keys()):\n                if isinstance(self.info[tag], list):\n                    self.info[tag].append(tagdata)\n                else:\n                    self.info[tag] = [self.info[tag], tagdata]\n            else:\n                self.info[tag] = tagdata\n\n            # print tag, self.info[tag]\n\n        # mode\n        layers = i8(self.info[(3,60)][0])\n        component = i8(self.info[(3,60)][1])\n        if (3,65) in self.info:\n            id = i8(self.info[(3,65)][0])-1\n        else:\n            id = 0\n        if layers == 1 and not component:\n            self.mode = \"L\"\n        elif layers == 3 and component:\n            self.mode = \"RGB\"[id]\n        elif layers == 4 and component:\n            self.mode = \"CMYK\"[id]\n\n        # size\n        self.size = self.getint((3,20)), self.getint((3,30))\n\n        # compression\n        try:\n            compression = COMPRESSION[self.getint((3,120))]\n        except KeyError:\n            raise IOError(\"Unknown IPTC image compression\")\n\n        # tile\n        if tag == (8,10):\n            if compression == \"raw\" and self._is_raw(offset, self.size):\n                self.tile = [(compression, (offset, size + 5, -1),\n                             (0, 0, self.size[0], self.size[1]))]\n            else:\n                self.tile = [(\"iptc\", (compression, offset),\n                             (0, 0, self.size[0], self.size[1]))]\n\n    def load(self):\n\n        if len(self.tile) != 1 or self.tile[0][0] != \"iptc\":\n            return ImageFile.ImageFile.load(self)\n\n        type, tile, box = self.tile[0]\n\n        encoding, offset = tile\n\n        self.fp.seek(offset)\n\n        # Copy image data to temporary file\n        outfile = tempfile.mktemp()\n        o = open(outfile, \"wb\")\n        if encoding == \"raw\":\n            # To simplify access to the extracted file,\n            # prepend a PPM header\n            o.write(\"P5\\n%d %d\\n255\\n\" % self.size)\n        while True:\n            type, size = self.field()\n            if type != (8, 10):\n                break\n            while size > 0:\n                s = self.fp.read(min(size, 8192))\n                if not s:\n                    break\n                o.write(s)\n                size = size - len(s)\n        o.close()\n\n        try:\n            try:\n                # fast\n                self.im = Image.core.open_ppm(outfile)\n            except:\n                # slightly slower\n                im = Image.open(outfile)\n                im.load()\n                self.im = im.im\n        finally:\n            try: os.unlink(outfile)\n            except: pass\n\n\nImage.register_open(\"IPTC\", IptcImageFile)\n\nImage.register_extension(\"IPTC\", \".iim\")\n\n##\n# Get IPTC information from TIFF, JPEG, or IPTC file.\n#\n# @param im An image containing IPTC data.\n# @return A dictionary containing IPTC information, or None if\n#     no IPTC information block was found.\n\ndef getiptcinfo(im):\n\n    from PIL import TiffImagePlugin, JpegImagePlugin\n    import io\n\n    data = None\n\n    if isinstance(im, IptcImageFile):\n        # return info dictionary right away\n        return im.info\n\n    elif isinstance(im, JpegImagePlugin.JpegImageFile):\n        # extract the IPTC/NAA resource\n        try:\n            app = im.app[\"APP13\"]\n            if app[:14] == \"Photoshop 3.0\\x00\":\n                app = app[14:]\n                # parse the image resource block\n                offset = 0\n                while app[offset:offset+4] == \"8BIM\":\n                    offset = offset + 4\n                    # resource code\n                    code = JpegImagePlugin.i16(app, offset)\n                    offset = offset + 2\n                    # resource name (usually empty)\n                    name_len = i8(app[offset])\n                    name = app[offset+1:offset+1+name_len]\n                    offset = 1 + offset + name_len\n                    if offset & 1:\n                        offset = offset + 1\n                    # resource data block\n                    size = JpegImagePlugin.i32(app, offset)\n                    offset = offset + 4\n                    if code == 0x0404:\n                        # 0x0404 contains IPTC/NAA data\n                        data = app[offset:offset+size]\n                        break\n                    offset = offset + size\n                    if offset & 1:\n                        offset = offset + 1\n        except (AttributeError, KeyError):\n            pass\n\n    elif isinstance(im, TiffImagePlugin.TiffImageFile):\n        # get raw data from the IPTC/NAA tag (PhotoShop tags the data\n        # as 4-byte integers, so we cannot use the get method...)\n        try:\n            data = im.tag.tagdata[TiffImagePlugin.IPTC_NAA_CHUNK]\n        except (AttributeError, KeyError):\n            pass\n\n    if data is None:\n        return None # no properties\n\n    # create an IptcImagePlugin object without initializing it\n    class FakeImage:\n        pass\n    im = FakeImage()\n    im.__class__ = IptcImageFile\n\n    # parse the IPTC information chunk\n    im.info = {}\n    im.fp = io.BytesIO(data)\n\n    try:\n        im._open()\n    except (IndexError, KeyError):\n        pass # expected failure\n\n    return im.info\n", "#\n# The Python Imaging Library.\n# $Id$\n#\n# JPEG (JFIF) file handling\n#\n# See \"Digital Compression and Coding of Continous-Tone Still Images,\n# Part 1, Requirements and Guidelines\" (CCITT T.81 / ISO 10918-1)\n#\n# History:\n# 1995-09-09 fl   Created\n# 1995-09-13 fl   Added full parser\n# 1996-03-25 fl   Added hack to use the IJG command line utilities\n# 1996-05-05 fl   Workaround Photoshop 2.5 CMYK polarity bug\n# 1996-05-28 fl   Added draft support, JFIF version (0.1)\n# 1996-12-30 fl   Added encoder options, added progression property (0.2)\n# 1997-08-27 fl   Save mode 1 images as BW (0.3)\n# 1998-07-12 fl   Added YCbCr to draft and save methods (0.4)\n# 1998-10-19 fl   Don't hang on files using 16-bit DQT's (0.4.1)\n# 2001-04-16 fl   Extract DPI settings from JFIF files (0.4.2)\n# 2002-07-01 fl   Skip pad bytes before markers; identify Exif files (0.4.3)\n# 2003-04-25 fl   Added experimental EXIF decoder (0.5)\n# 2003-06-06 fl   Added experimental EXIF GPSinfo decoder\n# 2003-09-13 fl   Extract COM markers\n# 2009-09-06 fl   Added icc_profile support (from Florian Hoech)\n# 2009-03-06 fl   Changed CMYK handling; always use Adobe polarity (0.6)\n# 2009-03-08 fl   Added subsampling support (from Justin Huff).\n#\n# Copyright (c) 1997-2003 by Secret Labs AB.\n# Copyright (c) 1995-1996 by Fredrik Lundh.\n#\n# See the README file for information on usage and redistribution.\n#\n\n__version__ = \"0.6\"\n\nimport array, struct\nfrom PIL import Image, ImageFile, _binary\nfrom PIL.JpegPresets import presets\nfrom PIL._util import isStringType\n\ni8 = _binary.i8\no8 = _binary.o8\ni16 = _binary.i16be\ni32 = _binary.i32be\n\n#\n# Parser\n\ndef Skip(self, marker):\n    n = i16(self.fp.read(2))-2\n    ImageFile._safe_read(self.fp, n)\n\ndef APP(self, marker):\n    #\n    # Application marker.  Store these in the APP dictionary.\n    # Also look for well-known application markers.\n\n    n = i16(self.fp.read(2))-2\n    s = ImageFile._safe_read(self.fp, n)\n\n    app = \"APP%d\" % (marker&15)\n\n    self.app[app] = s # compatibility\n    self.applist.append((app, s))\n\n    if marker == 0xFFE0 and s[:4] == b\"JFIF\":\n        # extract JFIF information\n        self.info[\"jfif\"] = version = i16(s, 5) # version\n        self.info[\"jfif_version\"] = divmod(version, 256)\n        # extract JFIF properties\n        try:\n            jfif_unit = i8(s[7])\n            jfif_density = i16(s, 8), i16(s, 10)\n        except:\n            pass\n        else:\n            if jfif_unit == 1:\n                self.info[\"dpi\"] = jfif_density\n            self.info[\"jfif_unit\"] = jfif_unit\n            self.info[\"jfif_density\"] = jfif_density\n    elif marker == 0xFFE1 and s[:5] == b\"Exif\\0\":\n        # extract Exif information (incomplete)\n        self.info[\"exif\"] = s # FIXME: value will change\n    elif marker == 0xFFE2 and s[:5] == b\"FPXR\\0\":\n        # extract FlashPix information (incomplete)\n        self.info[\"flashpix\"] = s # FIXME: value will change\n    elif marker == 0xFFE2 and s[:12] == b\"ICC_PROFILE\\0\":\n        # Since an ICC profile can be larger than the maximum size of\n        # a JPEG marker (64K), we need provisions to split it into\n        # multiple markers. The format defined by the ICC specifies\n        # one or more APP2 markers containing the following data:\n        #   Identifying string      ASCII \"ICC_PROFILE\\0\"  (12 bytes)\n        #   Marker sequence number  1, 2, etc (1 byte)\n        #   Number of markers       Total of APP2's used (1 byte)\n        #   Profile data            (remainder of APP2 data)\n        # Decoders should use the marker sequence numbers to\n        # reassemble the profile, rather than assuming that the APP2\n        # markers appear in the correct sequence.\n        self.icclist.append(s)\n    elif marker == 0xFFEE and s[:5] == b\"Adobe\":\n        self.info[\"adobe\"] = i16(s, 5)\n        # extract Adobe custom properties\n        try:\n            adobe_transform = i8(s[1])\n        except:\n            pass\n        else:\n            self.info[\"adobe_transform\"] = adobe_transform\n\ndef COM(self, marker):\n    #\n    # Comment marker.  Store these in the APP dictionary.\n\n    n = i16(self.fp.read(2))-2\n    s = ImageFile._safe_read(self.fp, n)\n\n    self.app[\"COM\"] = s # compatibility\n    self.applist.append((\"COM\", s))\n\ndef SOF(self, marker):\n    #\n    # Start of frame marker.  Defines the size and mode of the\n    # image.  JPEG is colour blind, so we use some simple\n    # heuristics to map the number of layers to an appropriate\n    # mode.  Note that this could be made a bit brighter, by\n    # looking for JFIF and Adobe APP markers.\n\n    n = i16(self.fp.read(2))-2\n    s = ImageFile._safe_read(self.fp, n)\n    self.size = i16(s[3:]), i16(s[1:])\n\n    self.bits = i8(s[0])\n    if self.bits != 8:\n        raise SyntaxError(\"cannot handle %d-bit layers\" % self.bits)\n\n    self.layers = i8(s[5])\n    if self.layers == 1:\n        self.mode = \"L\"\n    elif self.layers == 3:\n        self.mode = \"RGB\"\n    elif self.layers == 4:\n        self.mode = \"CMYK\"\n    else:\n        raise SyntaxError(\"cannot handle %d-layer images\" % self.layers)\n\n    if marker in [0xFFC2, 0xFFC6, 0xFFCA, 0xFFCE]:\n        self.info[\"progressive\"] = self.info[\"progression\"] = 1\n\n    if self.icclist:\n        # fixup icc profile\n        self.icclist.sort() # sort by sequence number\n        if i8(self.icclist[0][13]) == len(self.icclist):\n            profile = []\n            for p in self.icclist:\n                profile.append(p[14:])\n            icc_profile = b\"\".join(profile)\n        else:\n            icc_profile = None # wrong number of fragments\n        self.info[\"icc_profile\"] = icc_profile\n        self.icclist = None\n\n    for i in range(6, len(s), 3):\n        t = s[i:i+3]\n        # 4-tuples: id, vsamp, hsamp, qtable\n        self.layer.append((t[0], i8(t[1])//16, i8(t[1])&15, i8(t[2])))\n\ndef DQT(self, marker):\n    #\n    # Define quantization table.  Support baseline 8-bit tables\n    # only.  Note that there might be more than one table in\n    # each marker.\n\n    # FIXME: The quantization tables can be used to estimate the\n    # compression quality.\n\n    n = i16(self.fp.read(2))-2\n    s = ImageFile._safe_read(self.fp, n)\n    while len(s):\n        if len(s) < 65:\n            raise SyntaxError(\"bad quantization table marker\")\n        v = i8(s[0])\n        if v//16 == 0:\n            self.quantization[v&15] = array.array(\"b\", s[1:65])\n            s = s[65:]\n        else:\n            return # FIXME: add code to read 16-bit tables!\n            # raise SyntaxError, \"bad quantization table element size\"\n\n\n#\n# JPEG marker table\n\nMARKER = {\n    0xFFC0: (\"SOF0\", \"Baseline DCT\", SOF),\n    0xFFC1: (\"SOF1\", \"Extended Sequential DCT\", SOF),\n    0xFFC2: (\"SOF2\", \"Progressive DCT\", SOF),\n    0xFFC3: (\"SOF3\", \"Spatial lossless\", SOF),\n    0xFFC4: (\"DHT\", \"Define Huffman table\", Skip),\n    0xFFC5: (\"SOF5\", \"Differential sequential DCT\", SOF),\n    0xFFC6: (\"SOF6\", \"Differential progressive DCT\", SOF),\n    0xFFC7: (\"SOF7\", \"Differential spatial\", SOF),\n    0xFFC8: (\"JPG\", \"Extension\", None),\n    0xFFC9: (\"SOF9\", \"Extended sequential DCT (AC)\", SOF),\n    0xFFCA: (\"SOF10\", \"Progressive DCT (AC)\", SOF),\n    0xFFCB: (\"SOF11\", \"Spatial lossless DCT (AC)\", SOF),\n    0xFFCC: (\"DAC\", \"Define arithmetic coding conditioning\", Skip),\n    0xFFCD: (\"SOF13\", \"Differential sequential DCT (AC)\", SOF),\n    0xFFCE: (\"SOF14\", \"Differential progressive DCT (AC)\", SOF),\n    0xFFCF: (\"SOF15\", \"Differential spatial (AC)\", SOF),\n    0xFFD0: (\"RST0\", \"Restart 0\", None),\n    0xFFD1: (\"RST1\", \"Restart 1\", None),\n    0xFFD2: (\"RST2\", \"Restart 2\", None),\n    0xFFD3: (\"RST3\", \"Restart 3\", None),\n    0xFFD4: (\"RST4\", \"Restart 4\", None),\n    0xFFD5: (\"RST5\", \"Restart 5\", None),\n    0xFFD6: (\"RST6\", \"Restart 6\", None),\n    0xFFD7: (\"RST7\", \"Restart 7\", None),\n    0xFFD8: (\"SOI\", \"Start of image\", None),\n    0xFFD9: (\"EOI\", \"End of image\", None),\n    0xFFDA: (\"SOS\", \"Start of scan\", Skip),\n    0xFFDB: (\"DQT\", \"Define quantization table\", DQT),\n    0xFFDC: (\"DNL\", \"Define number of lines\", Skip),\n    0xFFDD: (\"DRI\", \"Define restart interval\", Skip),\n    0xFFDE: (\"DHP\", \"Define hierarchical progression\", SOF),\n    0xFFDF: (\"EXP\", \"Expand reference component\", Skip),\n    0xFFE0: (\"APP0\", \"Application segment 0\", APP),\n    0xFFE1: (\"APP1\", \"Application segment 1\", APP),\n    0xFFE2: (\"APP2\", \"Application segment 2\", APP),\n    0xFFE3: (\"APP3\", \"Application segment 3\", APP),\n    0xFFE4: (\"APP4\", \"Application segment 4\", APP),\n    0xFFE5: (\"APP5\", \"Application segment 5\", APP),\n    0xFFE6: (\"APP6\", \"Application segment 6\", APP),\n    0xFFE7: (\"APP7\", \"Application segment 7\", APP),\n    0xFFE8: (\"APP8\", \"Application segment 8\", APP),\n    0xFFE9: (\"APP9\", \"Application segment 9\", APP),\n    0xFFEA: (\"APP10\", \"Application segment 10\", APP),\n    0xFFEB: (\"APP11\", \"Application segment 11\", APP),\n    0xFFEC: (\"APP12\", \"Application segment 12\", APP),\n    0xFFED: (\"APP13\", \"Application segment 13\", APP),\n    0xFFEE: (\"APP14\", \"Application segment 14\", APP),\n    0xFFEF: (\"APP15\", \"Application segment 15\", APP),\n    0xFFF0: (\"JPG0\", \"Extension 0\", None),\n    0xFFF1: (\"JPG1\", \"Extension 1\", None),\n    0xFFF2: (\"JPG2\", \"Extension 2\", None),\n    0xFFF3: (\"JPG3\", \"Extension 3\", None),\n    0xFFF4: (\"JPG4\", \"Extension 4\", None),\n    0xFFF5: (\"JPG5\", \"Extension 5\", None),\n    0xFFF6: (\"JPG6\", \"Extension 6\", None),\n    0xFFF7: (\"JPG7\", \"Extension 7\", None),\n    0xFFF8: (\"JPG8\", \"Extension 8\", None),\n    0xFFF9: (\"JPG9\", \"Extension 9\", None),\n    0xFFFA: (\"JPG10\", \"Extension 10\", None),\n    0xFFFB: (\"JPG11\", \"Extension 11\", None),\n    0xFFFC: (\"JPG12\", \"Extension 12\", None),\n    0xFFFD: (\"JPG13\", \"Extension 13\", None),\n    0xFFFE: (\"COM\", \"Comment\", COM)\n}\n\n\ndef _accept(prefix):\n    return prefix[0:1] == b\"\\377\"\n\n##\n# Image plugin for JPEG and JFIF images.\n\nclass JpegImageFile(ImageFile.ImageFile):\n\n    format = \"JPEG\"\n    format_description = \"JPEG (ISO 10918)\"\n\n    def _open(self):\n\n        s = self.fp.read(1)\n\n        if i8(s[0]) != 255:\n            raise SyntaxError(\"not a JPEG file\")\n\n        # Create attributes\n        self.bits = self.layers = 0\n\n        # JPEG specifics (internal)\n        self.layer = []\n        self.huffman_dc = {}\n        self.huffman_ac = {}\n        self.quantization = {}\n        self.app = {} # compatibility\n        self.applist = []\n        self.icclist = []\n\n        while True:\n\n            s = s + self.fp.read(1)\n\n            i = i16(s)\n\n            if i in MARKER:\n                name, description, handler = MARKER[i]\n                # print hex(i), name, description\n                if handler is not None:\n                    handler(self, i)\n                if i == 0xFFDA: # start of scan\n                    rawmode = self.mode\n                    if self.mode == \"CMYK\":\n                        rawmode = \"CMYK;I\" # assume adobe conventions\n                    self.tile = [(\"jpeg\", (0,0) + self.size, 0, (rawmode, \"\"))]\n                    # self.__offset = self.fp.tell()\n                    break\n                s = self.fp.read(1)\n            elif i == 0 or i == 65535:\n                # padded marker or junk; move on\n                s = \"\\xff\"\n            else:\n                raise SyntaxError(\"no marker found\")\n\n    def draft(self, mode, size):\n\n        if len(self.tile) != 1:\n            return\n\n        d, e, o, a = self.tile[0]\n        scale = 0\n\n        if a[0] == \"RGB\" and mode in [\"L\", \"YCbCr\"]:\n            self.mode = mode\n            a = mode, \"\"\n\n        if size:\n            scale = max(self.size[0] // size[0], self.size[1] // size[1])\n            for s in [8, 4, 2, 1]:\n                if scale >= s:\n                    break\n            e = e[0], e[1], (e[2]-e[0]+s-1)//s+e[0], (e[3]-e[1]+s-1)//s+e[1]\n            self.size = ((self.size[0]+s-1)//s, (self.size[1]+s-1)//s)\n            scale = s\n\n        self.tile = [(d, e, o, a)]\n        self.decoderconfig = (scale, 1)\n\n        return self\n\n    def load_djpeg(self):\n\n        # ALTERNATIVE: handle JPEGs via the IJG command line utilities\n\n        import tempfile, os\n        file = tempfile.mktemp()\n        os.system(\"djpeg %s >%s\" % (self.filename, file))\n\n        try:\n            self.im = Image.core.open_ppm(file)\n        finally:\n            try: os.unlink(file)\n            except: pass\n\n        self.mode = self.im.mode\n        self.size = self.im.size\n\n        self.tile = []\n\n    def _getexif(self):\n        return _getexif(self)\n\n\ndef _getexif(self):\n    # Extract EXIF information.  This method is highly experimental,\n    # and is likely to be replaced with something better in a future\n    # version.\n    from PIL import TiffImagePlugin\n    import io\n    def fixup(value):\n        if len(value) == 1:\n            return value[0]\n        return value\n    # The EXIF record consists of a TIFF file embedded in a JPEG\n    # application marker (!).\n    try:\n        data = self.info[\"exif\"]\n    except KeyError:\n        return None\n    file = io.BytesIO(data[6:])\n    head = file.read(8)\n    exif = {}\n    # process dictionary\n    info = TiffImagePlugin.ImageFileDirectory(head)\n    info.load(file)\n    for key, value in info.items():\n        exif[key] = fixup(value)\n    # get exif extension\n    try:\n        file.seek(exif[0x8769])\n    except KeyError:\n        pass\n    else:\n        info = TiffImagePlugin.ImageFileDirectory(head)\n        info.load(file)\n        for key, value in info.items():\n            exif[key] = fixup(value)\n    # get gpsinfo extension\n    try:\n        file.seek(exif[0x8825])\n    except KeyError:\n        pass\n    else:\n        info = TiffImagePlugin.ImageFileDirectory(head)\n        info.load(file)\n        exif[0x8825] = gps = {}\n        for key, value in info.items():\n            gps[key] = fixup(value)\n    return exif\n\n# --------------------------------------------------------------------\n# stuff to save JPEG files\n\nRAWMODE = {\n    \"1\": \"L\",\n    \"L\": \"L\",\n    \"RGB\": \"RGB\",\n    \"RGBA\": \"RGB\",\n    \"RGBX\": \"RGB\",\n    \"CMYK\": \"CMYK;I\", # assume adobe conventions\n    \"YCbCr\": \"YCbCr\",\n}\n\nzigzag_index = ( 0,  1,  5,  6, 14, 15, 27, 28,\n                 2,  4,  7, 13, 16, 26, 29, 42,\n                 3,  8, 12, 17, 25, 30, 41, 43,\n                 9, 11, 18, 24, 31, 40, 44, 53,\n                10, 19, 23, 32, 39, 45, 52, 54,\n                20, 22, 33, 38, 46, 51, 55, 60,\n                21, 34, 37, 47, 50, 56, 59, 61,\n                35, 36, 48, 49, 57, 58, 62, 63)\n\nsamplings = {\n             (1, 1, 1, 1, 1, 1): 0,\n             (2, 1, 1, 1, 1, 1): 1,\n             (2, 2, 1, 1, 1, 1): 2,\n            }\n\ndef convert_dict_qtables(qtables):\n    qtables = [qtables[key] for key in xrange(len(qtables)) if qtables.has_key(key)]\n    for idx, table in enumerate(qtables):\n        qtables[idx] = [table[i] for i in zigzag_index]\n    return qtables\n\ndef get_sampling(im):\n    sampling = im.layer[0][1:3] + im.layer[1][1:3] + im.layer[2][1:3]\n    return samplings.get(sampling, -1)\n\ndef _save(im, fp, filename):\n\n    try:\n        rawmode = RAWMODE[im.mode]\n    except KeyError:\n        raise IOError(\"cannot write mode %s as JPEG\" % im.mode)\n\n    info = im.encoderinfo\n\n    dpi = info.get(\"dpi\", (0, 0))\n\n    quality = info.get(\"quality\", 0)\n    subsampling = info.get(\"subsampling\", -1)\n    qtables = info.get(\"qtables\")\n\n    if quality == \"keep\":\n        quality = 0\n        subsampling = \"keep\"\n        qtables = \"keep\"\n    elif quality in presets:\n        preset = presets[quality]\n        quality = 0\n        subsampling = preset.get('subsampling', -1)\n        qtables = preset.get('quantization')\n    elif not isinstance(quality, int):\n        raise ValueError(\"Invalid quality setting\")\n    else:\n        if subsampling in presets:\n            subsampling = presets[subsampling].get('subsampling', -1)\n        if qtables in presets:\n            qtables = presets[qtables].get('quantization')\n\n    if subsampling == \"4:4:4\":\n        subsampling = 0\n    elif subsampling == \"4:2:2\":\n        subsampling = 1\n    elif subsampling == \"4:1:1\":\n        subsampling = 2\n    elif subsampling == \"keep\":\n        if im.format != \"JPEG\":\n            raise ValueError(\"Cannot use 'keep' when original image is not a JPEG\")\n        subsampling = get_sampling(im)\n\n    def validate_qtables(qtables):\n        if qtables is None:\n            return qtables\n        if isStringType(qtables):\n            try:\n                lines = [int(num) for line in qtables.splitlines()\n                         for num in line.split('#', 1)[0].split()]\n            except ValueError:\n                raise ValueError(\"Invalid quantization table\")\n            else:\n                qtables = [lines[s:s+64] for s in xrange(0, len(lines), 64)]\n        if isinstance(qtables, (tuple, list, dict)):\n            if isinstance(qtables, dict):\n                qtables = convert_dict_qtables(qtables)\n            elif isinstance(qtables, tuple):\n                qtables = list(qtables)\n            if not (0 < len(qtables) < 5):\n                raise ValueError(\"None or too many quantization tables\")\n            for idx, table in enumerate(qtables):\n                try:\n                    if len(table) != 64:\n                        raise\n                    table = array.array('b', table)\n                except TypeError:\n                    raise ValueError(\"Invalid quantization table\")\n                else:\n                    qtables[idx] = list(table)\n            return qtables\n\n    if qtables == \"keep\":\n        if im.format != \"JPEG\":\n            raise ValueError(\"Cannot use 'keep' when original image is not a JPEG\")\n        qtables = getattr(im, \"quantization\", None)\n    qtables = validate_qtables(qtables)\n\n    extra = b\"\"\n\n    icc_profile = info.get(\"icc_profile\")\n    if icc_profile:\n        ICC_OVERHEAD_LEN = 14\n        MAX_BYTES_IN_MARKER = 65533\n        MAX_DATA_BYTES_IN_MARKER = MAX_BYTES_IN_MARKER - ICC_OVERHEAD_LEN\n        markers = []\n        while icc_profile:\n            markers.append(icc_profile[:MAX_DATA_BYTES_IN_MARKER])\n            icc_profile = icc_profile[MAX_DATA_BYTES_IN_MARKER:]\n        i = 1\n        for marker in markers:\n            size = struct.pack(\">H\", 2 + ICC_OVERHEAD_LEN + len(marker))\n            extra = extra + (b\"\\xFF\\xE2\" + size + b\"ICC_PROFILE\\0\" + o8(i) + o8(len(markers)) + marker)\n            i = i + 1\n\n    # get keyword arguments\n    im.encoderconfig = (\n        quality,\n        # \"progressive\" is the official name, but older documentation\n        # says \"progression\"\n        # FIXME: issue a warning if the wrong form is used (post-1.1.7)\n        \"progressive\" in info or \"progression\" in info,\n        info.get(\"smooth\", 0),\n        \"optimize\" in info,\n        info.get(\"streamtype\", 0),\n        dpi[0], dpi[1],\n        subsampling,\n        qtables,\n        extra,\n        info.get(\"exif\", b\"\")\n        )\n\n\n    # if we optimize, libjpeg needs a buffer big enough to hold the whole image in a shot.\n    # Guessing on the size, at im.size bytes. (raw pizel size is channels*size, this\n    # is a value that's been used in a django patch.\n    # https://github.com/jdriscoll/django-imagekit/issues/50\n    bufsize=0\n    if \"optimize\" in info or \"progressive\" in info or \"progression\" in info:\n        bufsize = im.size[0]*im.size[1]\n\n    # The exif info needs to be written as one block, + APP1, + one spare byte.\n    # Ensure that our buffer is big enough\n    bufsize = max(ImageFile.MAXBLOCK, bufsize, len(info.get(\"exif\",b\"\")) + 5 )\n\n    ImageFile._save(im, fp, [(\"jpeg\", (0,0)+im.size, 0, rawmode)], bufsize)\n\ndef _save_cjpeg(im, fp, filename):\n    # ALTERNATIVE: handle JPEGs via the IJG command line utilities.\n    import os\n    file = im._dump()\n    os.system(\"cjpeg %s >%s\" % (file, filename))\n    try: os.unlink(file)\n    except: pass\n\n# -------------------------------------------------------------------q-\n# Registry stuff\n\nImage.register_open(\"JPEG\", JpegImageFile, _accept)\nImage.register_save(\"JPEG\", _save)\n\nImage.register_extension(\"JPEG\", \".jfif\")\nImage.register_extension(\"JPEG\", \".jpe\")\nImage.register_extension(\"JPEG\", \".jpg\")\nImage.register_extension(\"JPEG\", \".jpeg\")\n\nImage.register_mime(\"JPEG\", \"image/jpeg\")\n"], "fixing_code": ["#\n# The Python Imaging Library.\n# $Id$\n#\n# EPS file handling\n#\n# History:\n# 1995-09-01 fl   Created (0.1)\n# 1996-05-18 fl   Don't choke on \"atend\" fields, Ghostscript interface (0.2)\n# 1996-08-22 fl   Don't choke on floating point BoundingBox values\n# 1996-08-23 fl   Handle files from Macintosh (0.3)\n# 2001-02-17 fl   Use 're' instead of 'regex' (Python 2.1) (0.4)\n# 2003-09-07 fl   Check gs.close status (from Federico Di Gregorio) (0.5)\n#\n# Copyright (c) 1997-2003 by Secret Labs AB.\n# Copyright (c) 1995-2003 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\n\n__version__ = \"0.5\"\n\nimport re\nimport io\nfrom PIL import Image, ImageFile, _binary\n\n#\n# --------------------------------------------------------------------\n\ni32 = _binary.i32le\no32 = _binary.o32le\n\nsplit = re.compile(r\"^%%([^:]*):[ \\t]*(.*)[ \\t]*$\")\nfield = re.compile(r\"^%[%!\\w]([^:]*)[ \\t]*$\")\n\ngs_windows_binary = None\nimport sys\nif sys.platform.startswith('win'):\n    import shutil\n    if hasattr(shutil, 'which'):\n        which = shutil.which\n    else:\n        # Python < 3.3\n        import distutils.spawn\n        which = distutils.spawn.find_executable\n    for binary in ('gswin32c', 'gswin64c', 'gs'):\n        if which(binary) is not None:\n            gs_windows_binary = binary\n            break\n    else:\n        gs_windows_binary = False\n\ndef Ghostscript(tile, size, fp, scale=1):\n    \"\"\"Render an image using Ghostscript\"\"\"\n\n    # Unpack decoder tile\n    decoder, tile, offset, data = tile[0]\n    length, bbox = data\n\n    #Hack to support hi-res rendering\n    scale = int(scale) or 1\n    orig_size = size\n    orig_bbox = bbox\n    size = (size[0] * scale, size[1] * scale)\n    bbox = [bbox[0], bbox[1], bbox[2] * scale, bbox[3] * scale]\n    #print(\"Ghostscript\", scale, size, orig_size, bbox, orig_bbox)\n\n    import tempfile, os, subprocess\n\n    out_fd, file = tempfile.mkstemp()\n    os.close(out_fd)\n\n    # Build ghostscript command\n    command = [\"gs\",\n               \"-q\",                    # quite mode\n               \"-g%dx%d\" % size,        # set output geometry (pixels)\n               \"-r%d\" % (72*scale),     # set input DPI (dots per inch)\n               \"-dNOPAUSE -dSAFER\",     # don't pause between pages, safe mode\n               \"-sDEVICE=ppmraw\",       # ppm driver\n               \"-sOutputFile=%s\" % file,# output file\n            ]\n\n    if gs_windows_binary is not None:\n        if gs_windows_binary is False:\n            raise WindowsError('Unable to locate Ghostscript on paths')\n        command[0] = gs_windows_binary\n\n    # push data through ghostscript\n    try:\n        gs = subprocess.Popen(command, stdin=subprocess.PIPE, stdout=subprocess.PIPE)\n        # adjust for image origin\n        if bbox[0] != 0 or bbox[1] != 0:\n            gs.stdin.write((\"%d %d translate\\n\" % (-bbox[0], -bbox[1])).encode('ascii'))\n        fp.seek(offset)\n        while length > 0:\n            s = fp.read(8192)\n            if not s:\n                break\n            length = length - len(s)\n            gs.stdin.write(s)\n        gs.stdin.close()\n        status = gs.wait()\n        if status:\n            raise IOError(\"gs failed (status %d)\" % status)\n        im = Image.core.open_ppm(file)\n    finally:\n        try: os.unlink(file)\n        except: pass\n\n    return im\n\n\nclass PSFile:\n    \"\"\"Wrapper that treats either CR or LF as end of line.\"\"\"\n    def __init__(self, fp):\n        self.fp = fp\n        self.char = None\n    def __getattr__(self, id):\n        v = getattr(self.fp, id)\n        setattr(self, id, v)\n        return v\n    def seek(self, offset, whence=0):\n        self.char = None\n        self.fp.seek(offset, whence)\n    def read(self, count):\n        return self.fp.read(count).decode('latin-1')\n    def tell(self):\n        pos = self.fp.tell()\n        if self.char:\n            pos = pos - 1\n        return pos\n    def readline(self):\n        s = b\"\"\n        if self.char:\n            c = self.char\n            self.char = None\n        else:\n            c = self.fp.read(1)\n        while c not in b\"\\r\\n\":\n            s = s + c\n            c = self.fp.read(1)\n        if c == b\"\\r\":\n            self.char = self.fp.read(1)\n            if self.char == b\"\\n\":\n                self.char = None\n        return s.decode('latin-1') + \"\\n\"\n\n\ndef _accept(prefix):\n    return prefix[:4] == b\"%!PS\" or i32(prefix) == 0xC6D3D0C5\n\n##\n# Image plugin for Encapsulated Postscript.  This plugin supports only\n# a few variants of this format.\n\nclass EpsImageFile(ImageFile.ImageFile):\n    \"\"\"EPS File Parser for the Python Imaging Library\"\"\"\n\n    format = \"EPS\"\n    format_description = \"Encapsulated Postscript\"\n\n    def _open(self):\n\n        # FIXME: should check the first 512 bytes to see if this\n        # really is necessary (platform-dependent, though...)\n\n        fp = PSFile(self.fp)\n\n        # HEAD\n        s = fp.read(512)\n        if s[:4] == \"%!PS\":\n            offset = 0\n            fp.seek(0, 2)\n            length = fp.tell()\n        elif i32(s) == 0xC6D3D0C5:\n            offset = i32(s[4:])\n            length = i32(s[8:])\n            fp.seek(offset)\n        else:\n            raise SyntaxError(\"not an EPS file\")\n\n        fp.seek(offset)\n\n        box = None\n\n        self.mode = \"RGB\"\n        self.size = 1, 1 # FIXME: huh?\n\n        #\n        # Load EPS header\n\n        s = fp.readline()\n\n        while s:\n\n            if len(s) > 255:\n                raise SyntaxError(\"not an EPS file\")\n\n            if s[-2:] == '\\r\\n':\n                s = s[:-2]\n            elif s[-1:] == '\\n':\n                s = s[:-1]\n\n            try:\n                m = split.match(s)\n            except re.error as v:\n                raise SyntaxError(\"not an EPS file\")\n\n            if m:\n                k, v = m.group(1, 2)\n                self.info[k] = v\n                if k == \"BoundingBox\":\n                    try:\n                        # Note: The DSC spec says that BoundingBox\n                        # fields should be integers, but some drivers\n                        # put floating point values there anyway.\n                        box = [int(float(s)) for s in v.split()]\n                        self.size = box[2] - box[0], box[3] - box[1]\n                        self.tile = [(\"eps\", (0,0) + self.size, offset,\n                                      (length, box))]\n                    except:\n                        pass\n\n            else:\n\n                m = field.match(s)\n\n                if m:\n                    k = m.group(1)\n\n                    if k == \"EndComments\":\n                        break\n                    if k[:8] == \"PS-Adobe\":\n                        self.info[k[:8]] = k[9:]\n                    else:\n                        self.info[k] = \"\"\n                elif s[0:1] == '%':\n                    # handle non-DSC Postscript comments that some\n                    # tools mistakenly put in the Comments section\n                    pass\n                else:\n                    raise IOError(\"bad EPS header\")\n\n            s = fp.readline()\n\n            if s[:1] != \"%\":\n                break\n\n\n        #\n        # Scan for an \"ImageData\" descriptor\n\n        while s[0] == \"%\":\n\n            if len(s) > 255:\n                raise SyntaxError(\"not an EPS file\")\n\n            if s[-2:] == '\\r\\n':\n                s = s[:-2]\n            elif s[-1:] == '\\n':\n                s = s[:-1]\n\n            if s[:11] == \"%ImageData:\":\n\n                [x, y, bi, mo, z3, z4, en, id] =\\\n                    s[11:].split(None, 7)\n\n                x = int(x); y = int(y)\n\n                bi = int(bi)\n                mo = int(mo)\n\n                en = int(en)\n\n                if en == 1:\n                    decoder = \"eps_binary\"\n                elif en == 2:\n                    decoder = \"eps_hex\"\n                else:\n                    break\n                if bi != 8:\n                    break\n                if mo == 1:\n                    self.mode = \"L\"\n                elif mo == 2:\n                    self.mode = \"LAB\"\n                elif mo == 3:\n                    self.mode = \"RGB\"\n                else:\n                    break\n\n                if id[:1] == id[-1:] == '\"':\n                    id = id[1:-1]\n\n                # Scan forward to the actual image data\n                while True:\n                    s = fp.readline()\n                    if not s:\n                        break\n                    if s[:len(id)] == id:\n                        self.size = x, y\n                        self.tile2 = [(decoder,\n                                       (0, 0, x, y),\n                                       fp.tell(),\n                                       0)]\n                        return\n\n            s = fp.readline()\n            if not s:\n                break\n\n        if not box:\n            raise IOError(\"cannot determine EPS bounding box\")\n\n    def load(self, scale=1):\n        # Load EPS via Ghostscript\n        if not self.tile:\n            return\n        self.im = Ghostscript(self.tile, self.size, self.fp, scale)\n        self.mode = self.im.mode\n        self.size = self.im.size\n        self.tile = []\n\n#\n# --------------------------------------------------------------------\n\ndef _save(im, fp, filename, eps=1):\n    \"\"\"EPS Writer for the Python Imaging Library.\"\"\"\n\n    #\n    # make sure image data is available\n    im.load()\n\n    #\n    # determine postscript image mode\n    if im.mode == \"L\":\n        operator = (8, 1, \"image\")\n    elif im.mode == \"RGB\":\n        operator = (8, 3, \"false 3 colorimage\")\n    elif im.mode == \"CMYK\":\n        operator = (8, 4, \"false 4 colorimage\")\n    else:\n        raise ValueError(\"image mode is not supported\")\n\n    class NoCloseStream:\n        def __init__(self, fp):\n            self.fp = fp\n        def __getattr__(self, name):\n            return getattr(self.fp, name)\n        def close(self):\n            pass\n\n    base_fp = fp\n    fp = io.TextIOWrapper(NoCloseStream(fp), encoding='latin-1')\n\n    if eps:\n        #\n        # write EPS header\n        fp.write(\"%!PS-Adobe-3.0 EPSF-3.0\\n\")\n        fp.write(\"%%Creator: PIL 0.1 EpsEncode\\n\")\n        #fp.write(\"%%CreationDate: %s\"...)\n        fp.write(\"%%%%BoundingBox: 0 0 %d %d\\n\" % im.size)\n        fp.write(\"%%Pages: 1\\n\")\n        fp.write(\"%%EndComments\\n\")\n        fp.write(\"%%Page: 1 1\\n\")\n        fp.write(\"%%ImageData: %d %d \" % im.size)\n        fp.write(\"%d %d 0 1 1 \\\"%s\\\"\\n\" % operator)\n\n    #\n    # image header\n    fp.write(\"gsave\\n\")\n    fp.write(\"10 dict begin\\n\")\n    fp.write(\"/buf %d string def\\n\" % (im.size[0] * operator[1]))\n    fp.write(\"%d %d scale\\n\" % im.size)\n    fp.write(\"%d %d 8\\n\" % im.size) # <= bits\n    fp.write(\"[%d 0 0 -%d 0 %d]\\n\" % (im.size[0], im.size[1], im.size[1]))\n    fp.write(\"{ currentfile buf readhexstring pop } bind\\n\")\n    fp.write(operator[2] + \"\\n\")\n    fp.flush()\n\n    ImageFile._save(im, base_fp, [(\"eps\", (0,0)+im.size, 0, None)])\n\n    fp.write(\"\\n%%%%EndBinary\\n\")\n    fp.write(\"grestore end\\n\")\n    fp.flush()\n\n#\n# --------------------------------------------------------------------\n\nImage.register_open(EpsImageFile.format, EpsImageFile, _accept)\n\nImage.register_save(EpsImageFile.format, _save)\n\nImage.register_extension(EpsImageFile.format, \".ps\")\nImage.register_extension(EpsImageFile.format, \".eps\")\n\nImage.register_mime(EpsImageFile.format, \"application/postscript\")\n", "#\n# The Python Imaging Library.\n# $Id$\n#\n# the Image class wrapper\n#\n# partial release history:\n# 1995-09-09 fl   Created\n# 1996-03-11 fl   PIL release 0.0 (proof of concept)\n# 1996-04-30 fl   PIL release 0.1b1\n# 1999-07-28 fl   PIL release 1.0 final\n# 2000-06-07 fl   PIL release 1.1\n# 2000-10-20 fl   PIL release 1.1.1\n# 2001-05-07 fl   PIL release 1.1.2\n# 2002-03-15 fl   PIL release 1.1.3\n# 2003-05-10 fl   PIL release 1.1.4\n# 2005-03-28 fl   PIL release 1.1.5\n# 2006-12-02 fl   PIL release 1.1.6\n# 2009-11-15 fl   PIL release 1.1.7\n#\n# Copyright (c) 1997-2009 by Secret Labs AB.  All rights reserved.\n# Copyright (c) 1995-2009 by Fredrik Lundh.\n#\n# See the README file for information on usage and redistribution.\n#\n\nfrom __future__ import print_function\n\nfrom PIL import VERSION, PILLOW_VERSION, _plugins\n\nimport warnings\n\nclass _imaging_not_installed:\n    # module placeholder\n    def __getattr__(self, id):\n        raise ImportError(\"The _imaging C module is not installed\")\n\ntry:\n    # give Tk a chance to set up the environment, in case we're\n    # using an _imaging module linked against libtcl/libtk (use\n    # __import__ to hide this from naive packagers; we don't really\n    # depend on Tk unless ImageTk is used, and that module already\n    # imports Tkinter)\n    __import__(\"FixTk\")\nexcept ImportError:\n    pass\n\ntry:\n    # If the _imaging C module is not present, you can still use\n    # the \"open\" function to identify files, but you cannot load\n    # them.  Note that other modules should not refer to _imaging\n    # directly; import Image and use the Image.core variable instead.\n    from PIL import _imaging as core\n    if PILLOW_VERSION != getattr(core, 'PILLOW_VERSION', None):\n         raise ImportError(\"The _imaging extension was built for another \"\n                            \" version of Pillow or PIL\")\n\nexcept ImportError as v:\n    core = _imaging_not_installed()\n    # Explanations for ways that we know we might have an import error\n    if str(v).startswith(\"Module use of python\"):\n        # The _imaging C module is present, but not compiled for\n        # the right version (windows only).  Print a warning, if\n        # possible.\n        warnings.warn(\n            \"The _imaging extension was built for another version \"\n            \"of Python.\",\n            RuntimeWarning\n            )\n    elif str(v).startswith(\"The _imaging extension\"):\n        warnings.warn(str(v), RuntimeWarning)\n    elif \"Symbol not found: _PyUnicodeUCS2_FromString\" in str(v):\n        warnings.warn(\n            \"The _imaging extension was built for Python with UCS2 support; \"\n            \"recompile PIL or build Python --without-wide-unicode. \",\n            RuntimeWarning\n            )\n    elif \"Symbol not found: _PyUnicodeUCS4_FromString\" in str(v):\n        warnings.warn(\n            \"The _imaging extension was built for Python with UCS4 support; \"\n            \"recompile PIL or build Python --with-wide-unicode. \",\n            RuntimeWarning\n            )\n    # Fail here anyway. Don't let people run with a mostly broken Pillow.\n    raise\n\ntry:\n    import builtins\nexcept ImportError:\n    import __builtin__\n    builtins = __builtin__\n\nfrom PIL import ImageMode\nfrom PIL._binary import i8, o8\nfrom PIL._util import isPath, isStringType\n\nimport os, sys\n\n# type stuff\nimport collections\nimport numbers\n\n\ndef isImageType(t):\n    \"\"\"\n    Checks if an object is an image object.\n\n    .. warning::\n\n       This function is for internal use only.\n\n    :param t: object to check if it's an image\n    :returns: True if the object is an image\n    \"\"\"\n    return hasattr(t, \"im\")\n\n#\n# Debug level\n\nDEBUG = 0\n\n#\n# Constants (also defined in _imagingmodule.c!)\n\nNONE = 0\n\n# transpose\nFLIP_LEFT_RIGHT = 0\nFLIP_TOP_BOTTOM = 1\nROTATE_90 = 2\nROTATE_180 = 3\nROTATE_270 = 4\n\n# transforms\nAFFINE = 0\nEXTENT = 1\nPERSPECTIVE = 2\nQUAD = 3\nMESH = 4\n\n# resampling filters\nNONE = 0\nNEAREST = 0\nANTIALIAS = 1 # 3-lobed lanczos\nLINEAR = BILINEAR = 2\nCUBIC = BICUBIC = 3\n\n# dithers\nNONE = 0\nNEAREST = 0\nORDERED = 1 # Not yet implemented\nRASTERIZE = 2 # Not yet implemented\nFLOYDSTEINBERG = 3 # default\n\n# palettes/quantizers\nWEB = 0\nADAPTIVE = 1\n\nMEDIANCUT = 0\nMAXCOVERAGE = 1\nFASTOCTREE = 2\n\n# categories\nNORMAL = 0\nSEQUENCE = 1\nCONTAINER = 2\n\nif hasattr(core, 'DEFAULT_STRATEGY'):\n    DEFAULT_STRATEGY = core.DEFAULT_STRATEGY\n    FILTERED = core.FILTERED\n    HUFFMAN_ONLY = core.HUFFMAN_ONLY\n    RLE = core.RLE\n    FIXED = core.FIXED\n\n\n# --------------------------------------------------------------------\n# Registries\n\nID = []\nOPEN = {}\nMIME = {}\nSAVE = {}\nEXTENSION = {}\n\n# --------------------------------------------------------------------\n# Modes supported by this version\n\n_MODEINFO = {\n    # NOTE: this table will be removed in future versions.  use\n    # getmode* functions or ImageMode descriptors instead.\n\n    # official modes\n    \"1\": (\"L\", \"L\", (\"1\",)),\n    \"L\": (\"L\", \"L\", (\"L\",)),\n    \"I\": (\"L\", \"I\", (\"I\",)),\n    \"F\": (\"L\", \"F\", (\"F\",)),\n    \"P\": (\"RGB\", \"L\", (\"P\",)),\n    \"RGB\": (\"RGB\", \"L\", (\"R\", \"G\", \"B\")),\n    \"RGBX\": (\"RGB\", \"L\", (\"R\", \"G\", \"B\", \"X\")),\n    \"RGBA\": (\"RGB\", \"L\", (\"R\", \"G\", \"B\", \"A\")),\n    \"CMYK\": (\"RGB\", \"L\", (\"C\", \"M\", \"Y\", \"K\")),\n    \"YCbCr\": (\"RGB\", \"L\", (\"Y\", \"Cb\", \"Cr\")),\n    \"LAB\": (\"RGB\", \"L\", (\"L\", \"A\", \"B\")),\n\n    # Experimental modes include I;16, I;16L, I;16B, RGBa, BGR;15, and\n    # BGR;24.  Use these modes only if you know exactly what you're\n    # doing...\n\n}\n\nif sys.byteorder == 'little':\n    _ENDIAN = '<'\nelse:\n    _ENDIAN = '>'\n\n_MODE_CONV = {\n    # official modes\n    \"1\": ('|b1', None), # broken\n    \"L\": ('|u1', None),\n    \"I\": (_ENDIAN + 'i4', None),\n    \"F\": (_ENDIAN + 'f4', None),\n    \"P\": ('|u1', None),\n    \"RGB\": ('|u1', 3),\n    \"RGBX\": ('|u1', 4),\n    \"RGBA\": ('|u1', 4),\n    \"CMYK\": ('|u1', 4),\n    \"YCbCr\": ('|u1', 3),\n    \"LAB\": ('|u1', 3), # UNDONE - unsigned |u1i1i1\n\t# I;16 == I;16L, and I;32 == I;32L  \n    \"I;16\": ('<u2', None),\n    \"I;16B\": ('>u2', None),\n    \"I;16L\": ('<u2', None),\n    \"I;16S\": ('<i2', None),\n    \"I;16BS\": ('>i2', None),\n    \"I;16LS\": ('<i2', None),\n    \"I;32\": ('<u4', None),\n    \"I;32B\": ('>u4', None),\n    \"I;32L\": ('<u4', None),\n    \"I;32S\": ('<i4', None),\n    \"I;32BS\": ('>i4', None),\n    \"I;32LS\": ('<i4', None),\n}\n\ndef _conv_type_shape(im):\n    shape = im.size[1], im.size[0]\n    typ, extra = _MODE_CONV[im.mode]\n    if extra is None:\n        return shape, typ\n    else:\n        return shape+(extra,), typ\n\n\nMODES = sorted(_MODEINFO.keys())\n\n# raw modes that may be memory mapped.  NOTE: if you change this, you\n# may have to modify the stride calculation in map.c too!\n_MAPMODES = (\"L\", \"P\", \"RGBX\", \"RGBA\", \"CMYK\", \"I;16\", \"I;16L\", \"I;16B\")\n\n\ndef getmodebase(mode):\n    \"\"\"\n    Gets the \"base\" mode for given mode.  This function returns \"L\" for\n    images that contain grayscale data, and \"RGB\" for images that\n    contain color data.\n\n    :param mode: Input mode.\n    :returns: \"L\" or \"RGB\".\n    :exception KeyError: If the input mode was not a standard mode.\n    \"\"\"\n    return ImageMode.getmode(mode).basemode\n\n\ndef getmodetype(mode):\n    \"\"\"\n    Gets the storage type mode.  Given a mode, this function returns a\n    single-layer mode suitable for storing individual bands.\n\n    :param mode: Input mode.\n    :returns: \"L\", \"I\", or \"F\".\n    :exception KeyError: If the input mode was not a standard mode.\n    \"\"\"\n    return ImageMode.getmode(mode).basetype\n\n\ndef getmodebandnames(mode):\n    \"\"\"\n    Gets a list of individual band names.  Given a mode, this function returns\n    a tuple containing the names of individual bands (use\n    :py:method:`~PIL.Image.getmodetype` to get the mode used to store each\n    individual band.\n\n    :param mode: Input mode.\n    :returns: A tuple containing band names.  The length of the tuple\n        gives the number of bands in an image of the given mode.\n    :exception KeyError: If the input mode was not a standard mode.\n    \"\"\"\n    return ImageMode.getmode(mode).bands\n\n\ndef getmodebands(mode):\n    \"\"\"\n    Gets the number of individual bands for this mode.\n\n    :param mode: Input mode.\n    :returns: The number of bands in this mode.\n    :exception KeyError: If the input mode was not a standard mode.\n    \"\"\"\n    return len(ImageMode.getmode(mode).bands)\n\n# --------------------------------------------------------------------\n# Helpers\n\n_initialized = 0\n\n\ndef preinit():\n    \"Explicitly load standard file format drivers.\"\n\n    global _initialized\n    if _initialized >= 1:\n        return\n\n    try:\n        from PIL import BmpImagePlugin\n    except ImportError:\n        pass\n    try:\n        from PIL import GifImagePlugin\n    except ImportError:\n        pass\n    try:\n        from PIL import JpegImagePlugin\n    except ImportError:\n        pass\n    try:\n        from PIL import PpmImagePlugin\n    except ImportError:\n        pass\n    try:\n        from PIL import PngImagePlugin\n    except ImportError:\n        pass\n#   try:\n#       import TiffImagePlugin\n#   except ImportError:\n#       pass\n\n    _initialized = 1\n\n\ndef init():\n    \"\"\"\n    Explicitly initializes the Python Imaging Library. This function\n    loads all available file format drivers.\n    \"\"\"\n\n    global _initialized\n    if _initialized >= 2:\n        return 0\n\n    for plugin in _plugins:\n        try:\n            if DEBUG:\n                print (\"Importing %s\"%plugin)\n            __import__(\"PIL.%s\"%plugin, globals(), locals(), [])\n        except ImportError:\n            if DEBUG:\n                print(\"Image: failed to import\", end=' ')\n                print(plugin, \":\", sys.exc_info()[1])\n\n    if OPEN or SAVE:\n        _initialized = 2\n        return 1\n\n# --------------------------------------------------------------------\n# Codec factories (used by tobytes/frombytes and ImageFile.load)\n\ndef _getdecoder(mode, decoder_name, args, extra=()):\n\n    # tweak arguments\n    if args is None:\n        args = ()\n    elif not isinstance(args, tuple):\n        args = (args,)\n\n    try:\n        # get decoder\n        decoder = getattr(core, decoder_name + \"_decoder\")\n        # print(decoder, mode, args + extra)\n        return decoder(mode, *args + extra)\n    except AttributeError:\n        raise IOError(\"decoder %s not available\" % decoder_name)\n\ndef _getencoder(mode, encoder_name, args, extra=()):\n\n    # tweak arguments\n    if args is None:\n        args = ()\n    elif not isinstance(args, tuple):\n        args = (args,)\n\n    try:\n        # get encoder\n        encoder = getattr(core, encoder_name + \"_encoder\")\n        # print(encoder, mode, args + extra)\n        return encoder(mode, *args + extra)\n    except AttributeError:\n        raise IOError(\"encoder %s not available\" % encoder_name)\n\n\n# --------------------------------------------------------------------\n# Simple expression analyzer\n\ndef coerce_e(value):\n    return value if isinstance(value, _E) else _E(value)\n\nclass _E:\n    def __init__(self, data):\n        self.data = data\n    def __add__(self, other):\n        return _E((self.data, \"__add__\", coerce_e(other).data))\n    def __mul__(self, other):\n        return _E((self.data, \"__mul__\", coerce_e(other).data))\n\ndef _getscaleoffset(expr):\n    stub = [\"stub\"]\n    data = expr(_E(stub)).data\n    try:\n        (a, b, c) = data # simplified syntax\n        if (a is stub and b == \"__mul__\" and isinstance(c, numbers.Number)):\n            return c, 0.0\n        if (a is stub and b == \"__add__\" and isinstance(c, numbers.Number)):\n            return 1.0, c\n    except TypeError: pass\n    try:\n        ((a, b, c), d, e) = data # full syntax\n        if (a is stub and b == \"__mul__\" and isinstance(c, numbers.Number) and\n            d == \"__add__\" and isinstance(e, numbers.Number)):\n            return c, e\n    except TypeError: pass\n    raise ValueError(\"illegal expression\")\n\n\n# --------------------------------------------------------------------\n# Implementation wrapper\n\nclass Image:\n    \"\"\"\n    This class represents an image object.  To create\n    :py:class:`~PIL.Image.Image` objects, use the appropriate factory\n    functions.  There's hardly ever any reason to call the Image constructor\n    directly.\n\n    * :py:func:`~PIL.Image.open`\n    * :py:func:`~PIL.Image.new`\n    * :py:func:`~PIL.Image.frombytes`\n    \"\"\"\n    format = None\n    format_description = None\n\n    def __init__(self):\n        # FIXME: take \"new\" parameters / other image?\n        # FIXME: turn mode and size into delegating properties?\n        self.im = None\n        self.mode = \"\"\n        self.size = (0, 0)\n        self.palette = None\n        self.info = {}\n        self.category = NORMAL\n        self.readonly = 0\n\n    def _new(self, im):\n        new = Image()\n        new.im = im\n        new.mode = im.mode\n        new.size = im.size\n        new.palette = self.palette\n        if im.mode == \"P\" and not new.palette:\n            from PIL import ImagePalette\n            new.palette = ImagePalette.ImagePalette()\n        try:\n            new.info = self.info.copy()\n        except AttributeError:\n            # fallback (pre-1.5.2)\n            new.info = {}\n            for k, v in self.info:\n                new.info[k] = v\n        return new\n\n    _makeself = _new # compatibility\n\n    def _copy(self):\n        self.load()\n        self.im = self.im.copy()\n        self.readonly = 0\n\n    def _dump(self, file=None, format=None):\n        import tempfile, os\n        if not file:\n            f, file = tempfile.mkstemp(format or '')\n            os.close(f)\n            \n        self.load()\n        if not format or format == \"PPM\":\n            self.im.save_ppm(file)\n        else:\n            if file.endswith(format):\n                file = file + \".\" + format\n            self.save(file, format)\n        return file\n\n    def __repr__(self):\n        return \"<%s.%s image mode=%s size=%dx%d at 0x%X>\" % (\n            self.__class__.__module__, self.__class__.__name__,\n            self.mode, self.size[0], self.size[1],\n            id(self)\n            )\n\n    def __getattr__(self, name):\n        if name == \"__array_interface__\":\n            # numpy array interface support\n            new = {}\n            shape, typestr = _conv_type_shape(self)\n            new['shape'] = shape\n            new['typestr'] = typestr\n            new['data'] = self.tobytes()\n            return new\n        raise AttributeError(name)\n\n    def tobytes(self, encoder_name=\"raw\", *args):\n        \"\"\"\n        Return image as a bytes object\n\n        :param encoder_name: What encoder to use.  The default is to\n                             use the standard \"raw\" encoder.\n        :param args: Extra arguments to the encoder.\n        :rtype: A bytes object.\n        \"\"\"\n\n        # may pass tuple instead of argument list\n        if len(args) == 1 and isinstance(args[0], tuple):\n            args = args[0]\n\n        if encoder_name == \"raw\" and args == ():\n            args = self.mode\n\n        self.load()\n\n        # unpack data\n        e = _getencoder(self.mode, encoder_name, args)\n        e.setimage(self.im)\n\n        bufsize = max(65536, self.size[0] * 4) # see RawEncode.c\n\n        data = []\n        while True:\n            l, s, d = e.encode(bufsize)\n            data.append(d)\n            if s:\n                break\n        if s < 0:\n            raise RuntimeError(\"encoder error %d in tobytes\" % s)\n\n        return b\"\".join(data)\n\n    # Declare tostring as alias to tobytes\n    def tostring(self, *args, **kw):\n        warnings.warn(\n            'tostring() is deprecated. Please call tobytes() instead.',\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return self.tobytes(*args, **kw)\n\n    def tobitmap(self, name=\"image\"):\n        \"\"\"\n        Returns the image converted to an X11 bitmap.\n\n        .. note:: This method only works for mode \"1\" images.\n\n        :param name: The name prefix to use for the bitmap variables.\n        :returns: A string containing an X11 bitmap.\n        :raises ValueError: If the mode is not \"1\"\n        \"\"\"\n\n        self.load()\n        if self.mode != \"1\":\n            raise ValueError(\"not a bitmap\")\n        data = self.tobytes(\"xbm\")\n        return b\"\".join([(\"#define %s_width %d\\n\" % (name, self.size[0])).encode('ascii'),\n                (\"#define %s_height %d\\n\"% (name, self.size[1])).encode('ascii'),\n                (\"static char %s_bits[] = {\\n\" % name).encode('ascii'), data, b\"};\"])\n\n    def frombytes(self, data, decoder_name=\"raw\", *args):\n        \"\"\"\n        Loads this image with pixel data from a bytes object.\n\n        This method is similar to the :py:func:`~PIL.Image.frombytes` function,\n        but loads data into this image instead of creating a new image object.\n        \"\"\"\n\n        # may pass tuple instead of argument list\n        if len(args) == 1 and isinstance(args[0], tuple):\n            args = args[0]\n\n        # default format\n        if decoder_name == \"raw\" and args == ():\n            args = self.mode\n\n        # unpack data\n        d = _getdecoder(self.mode, decoder_name, args)\n        d.setimage(self.im)\n        s = d.decode(data)\n\n        if s[0] >= 0:\n            raise ValueError(\"not enough image data\")\n        if s[1] != 0:\n            raise ValueError(\"cannot decode image data\")\n\n    def fromstring(self, *args, **kw):\n        \"\"\"Deprecated alias to frombytes.\n\n        .. deprecated:: 2.0\n        \"\"\"\n        warnings.warn('fromstring() is deprecated. Please call frombytes() instead.', DeprecationWarning)\n        return self.frombytes(*args, **kw)\n\n    def load(self):\n        \"\"\"\n        Allocates storage for the image and loads the pixel data.  In\n        normal cases, you don't need to call this method, since the\n        Image class automatically loads an opened image when it is\n        accessed for the first time.\n\n        :returns: An image access object.\n        \"\"\"\n        if self.im and self.palette and self.palette.dirty:\n            # realize palette\n            self.im.putpalette(*self.palette.getdata())\n            self.palette.dirty = 0\n            self.palette.mode = \"RGB\"\n            self.palette.rawmode = None\n            if \"transparency\" in self.info:\n                if isinstance(self.info[\"transparency\"], int):\n                    self.im.putpalettealpha(self.info[\"transparency\"], 0)\n                else:\n                    self.im.putpalettealphas(self.info[\"transparency\"])\n                self.palette.mode = \"RGBA\"\n\n        if self.im:\n            return self.im.pixel_access(self.readonly)\n\n    def verify(self):\n        \"\"\"\n        Verifies the contents of a file. For data read from a file, this\n        method attempts to determine if the file is broken, without\n        actually decoding the image data.  If this method finds any\n        problems, it raises suitable exceptions.  If you need to load\n        the image after using this method, you must reopen the image\n        file.\n        \"\"\"\n        pass\n\n    def convert(self, mode=None, matrix=None, dither=None,\n                palette=WEB, colors=256):\n        \"\"\"\n        Returns a converted copy of this image. For the \"P\" mode, this\n        method translates pixels through the palette.  If mode is\n        omitted, a mode is chosen so that all information in the image\n        and the palette can be represented without a palette.\n\n        The current version supports all possible conversions between\n        \"L\", \"RGB\" and \"CMYK.\" The **matrix** argument only supports \"L\"\n        and \"RGB\".\n\n        When translating a color image to black and white (mode \"L\"),\n        the library uses the ITU-R 601-2 luma transform::\n\n            L = R * 299/1000 + G * 587/1000 + B * 114/1000\n\n        The default method of converting a greyscale (\"L\") or \"RGB\"\n        image into a bilevel (mode \"1\") image uses Floyd-Steinberg\n        dither to approximate the original image luminosity levels. If\n        dither is NONE, all non-zero values are set to 255 (white). To\n        use other thresholds, use the :py:meth:`~PIL.Image.Image.point`\n        method.\n\n        :param mode: The requested mode.\n        :param matrix: An optional conversion matrix.  If given, this\n           should be 4- or 16-tuple containing floating point values.\n        :param dither: Dithering method, used when converting from\n           mode \"RGB\" to \"P\" or from \"RGB\" or \"L\" to \"1\".\n           Available methods are NONE or FLOYDSTEINBERG (default).\n        :param palette: Palette to use when converting from mode \"RGB\"\n           to \"P\".  Available palettes are WEB or ADAPTIVE.\n        :param colors: Number of colors to use for the ADAPTIVE palette.\n           Defaults to 256.\n        :rtype: :py:class:`~PIL.Image.Image`\n        :returns: An :py:class:`~PIL.Image.Image` object.\n        \"\"\"\n\n        if not mode:\n            # determine default mode\n            if self.mode == \"P\":\n                self.load()\n                if self.palette:\n                    mode = self.palette.mode\n                else:\n                    mode = \"RGB\"\n            else:\n                return self.copy()\n\n        self.load()\n\n        if matrix:\n            # matrix conversion\n            if mode not in (\"L\", \"RGB\"):\n                raise ValueError(\"illegal conversion\")\n            im = self.im.convert_matrix(mode, matrix)\n            return self._new(im)\n\n        if mode == \"P\" and palette == ADAPTIVE:\n            im = self.im.quantize(colors)\n            return self._new(im)\n\n        # colorspace conversion\n        if dither is None:\n            dither = FLOYDSTEINBERG\n\n        # Use transparent conversion to promote from transparent color to an alpha channel.\n        if self.mode in (\"L\", \"RGB\") and mode == \"RGBA\" and \"transparency\" in self.info:\n            return self._new(self.im.convert_transparent(mode, self.info['transparency']))\n            \n        try:\n            im = self.im.convert(mode, dither)\n        except ValueError:\n            try:\n                # normalize source image and try again\n                im = self.im.convert(getmodebase(self.mode))\n                im = im.convert(mode, dither)\n            except KeyError:\n                raise ValueError(\"illegal conversion\")\n\n        return self._new(im)\n\n    def quantize(self, colors=256, method=0, kmeans=0, palette=None):\n\n        # methods:\n        #    0 = median cut\n        #    1 = maximum coverage\n        #    2 = fast octree\n\n        # NOTE: this functionality will be moved to the extended\n        # quantizer interface in a later version of PIL.\n\n        self.load()\n\n        if palette:\n            # use palette from reference image\n            palette.load()\n            if palette.mode != \"P\":\n                raise ValueError(\"bad mode for palette image\")\n            if self.mode != \"RGB\" and self.mode != \"L\":\n                raise ValueError(\n                    \"only RGB or L mode images can be quantized to a palette\"\n                    )\n            im = self.im.convert(\"P\", 1, palette.im)\n            return self._makeself(im)\n\n        im = self.im.quantize(colors, method, kmeans)\n        return self._new(im)\n\n    def copy(self):\n        \"\"\"\n        Copies this image. Use this method if you wish to paste things\n        into an image, but still retain the original.\n\n        :rtype: :py:class:`~PIL.Image.Image`\n        :returns: An :py:class:`~PIL.Image.Image` object.\n        \"\"\"\n        self.load()\n        im = self.im.copy()\n        return self._new(im)\n\n    def crop(self, box=None):\n        \"\"\"\n        Returns a rectangular region from this image. The box is a\n        4-tuple defining the left, upper, right, and lower pixel\n        coordinate.\n\n        This is a lazy operation.  Changes to the source image may or\n        may not be reflected in the cropped image.  To break the\n        connection, call the :py:meth:`~PIL.Image.Image.load` method on\n        the cropped copy.\n\n        :param box: The crop rectangle, as a (left, upper, right, lower)-tuple.\n        :rtype: :py:class:`~PIL.Image.Image`\n        :returns: An :py:class:`~PIL.Image.Image` object.\n        \"\"\"\n\n        self.load()\n        if box is None:\n            return self.copy()\n\n        # lazy operation\n        return _ImageCrop(self, box)\n\n    def draft(self, mode, size):\n        \"\"\"\n        Configures the image file loader so it returns a version of the\n        image that as closely as possible matches the given mode and\n        size.  For example, you can use this method to convert a color\n        JPEG to greyscale while loading it, or to extract a 128x192\n        version from a PCD file.\n\n        Note that this method modifies the :py:class:`~PIL.Image.Image` object\n        in place.  If the image has already been loaded, this method has no\n        effect.\n\n        :param mode: The requested mode.\n        :param size: The requested size.\n        \"\"\"\n        pass\n\n    def _expand(self, xmargin, ymargin=None):\n        if ymargin is None:\n            ymargin = xmargin\n        self.load()\n        return self._new(self.im.expand(xmargin, ymargin, 0))\n\n    def filter(self, filter):\n        \"\"\"\n        Filters this image using the given filter.  For a list of\n        available filters, see the :py:mod:`~PIL.ImageFilter` module.\n\n        :param filter: Filter kernel.\n        :returns: An :py:class:`~PIL.Image.Image` object.  \"\"\"\n\n        self.load()\n\n        if isinstance(filter, collections.Callable):\n            filter = filter()\n        if not hasattr(filter, \"filter\"):\n            raise TypeError(\"filter argument should be ImageFilter.Filter instance or class\")\n\n        if self.im.bands == 1:\n            return self._new(filter.filter(self.im))\n        # fix to handle multiband images since _imaging doesn't\n        ims = []\n        for c in range(self.im.bands):\n            ims.append(self._new(filter.filter(self.im.getband(c))))\n        return merge(self.mode, ims)\n\n    def getbands(self):\n        \"\"\"\n        Returns a tuple containing the name of each band in this image.\n        For example, **getbands** on an RGB image returns (\"R\", \"G\", \"B\").\n\n        :returns: A tuple containing band names.\n        :rtype: tuple\n        \"\"\"\n        return ImageMode.getmode(self.mode).bands\n\n    def getbbox(self):\n        \"\"\"\n        Calculates the bounding box of the non-zero regions in the\n        image.\n\n        :returns: The bounding box is returned as a 4-tuple defining the\n           left, upper, right, and lower pixel coordinate. If the image\n           is completely empty, this method returns None.\n\n        \"\"\"\n\n        self.load()\n        return self.im.getbbox()\n\n    def getcolors(self, maxcolors=256):\n        \"\"\"\n        Returns a list of colors used in this image.\n\n        :param maxcolors: Maximum number of colors.  If this number is\n           exceeded, this method returns None.  The default limit is\n           256 colors.\n        :returns: An unsorted list of (count, pixel) values.\n        \"\"\"\n\n        self.load()\n        if self.mode in (\"1\", \"L\", \"P\"):\n            h = self.im.histogram()\n            out = []\n            for i in range(256):\n                if h[i]:\n                    out.append((h[i], i))\n            if len(out) > maxcolors:\n                return None\n            return out\n        return self.im.getcolors(maxcolors)\n\n    def getdata(self, band = None):\n        \"\"\"\n        Returns the contents of this image as a sequence object\n        containing pixel values.  The sequence object is flattened, so\n        that values for line one follow directly after the values of\n        line zero, and so on.\n\n        Note that the sequence object returned by this method is an\n        internal PIL data type, which only supports certain sequence\n        operations.  To convert it to an ordinary sequence (e.g. for\n        printing), use **list(im.getdata())**.\n\n        :param band: What band to return.  The default is to return\n           all bands.  To return a single band, pass in the index\n           value (e.g. 0 to get the \"R\" band from an \"RGB\" image).\n        :returns: A sequence-like object.\n        \"\"\"\n\n        self.load()\n        if band is not None:\n            return self.im.getband(band)\n        return self.im # could be abused\n\n    def getextrema(self):\n        \"\"\"\n        Gets the the minimum and maximum pixel values for each band in\n        the image.\n\n        :returns: For a single-band image, a 2-tuple containing the\n           minimum and maximum pixel value.  For a multi-band image,\n           a tuple containing one 2-tuple for each band.\n        \"\"\"\n\n        self.load()\n        if self.im.bands > 1:\n            extrema = []\n            for i in range(self.im.bands):\n                extrema.append(self.im.getband(i).getextrema())\n            return tuple(extrema)\n        return self.im.getextrema()\n\n    def getim(self):\n        \"\"\"\n        Returns a capsule that points to the internal image memory.\n\n        :returns: A capsule object.\n        \"\"\"\n\n        self.load()\n        return self.im.ptr\n\n\n    def getpalette(self):\n        \"\"\"\n        Returns the image palette as a list.\n\n        :returns: A list of color values [r, g, b, ...], or None if the\n           image has no palette.\n        \"\"\"\n\n        self.load()\n        try:\n            if bytes is str:\n                return [i8(c) for c in self.im.getpalette()]\n            else:\n                return list(self.im.getpalette())\n        except ValueError:\n            return None # no palette\n\n\n    def getpixel(self, xy):\n        \"\"\"\n        Returns the pixel value at a given position.\n\n        :param xy: The coordinate, given as (x, y).\n        :returns: The pixel value.  If the image is a multi-layer image,\n           this method returns a tuple.\n        \"\"\"\n\n        self.load()\n        return self.im.getpixel(xy)\n\n    def getprojection(self):\n        \"\"\"\n        Get projection to x and y axes\n\n        :returns: Two sequences, indicating where there are non-zero\n            pixels along the X-axis and the Y-axis, respectively.\n        \"\"\"\n\n        self.load()\n        x, y = self.im.getprojection()\n        return [i8(c) for c in x], [i8(c) for c in y]\n\n    def histogram(self, mask=None, extrema=None):\n        \"\"\"\n        Returns a histogram for the image. The histogram is returned as\n        a list of pixel counts, one for each pixel value in the source\n        image. If the image has more than one band, the histograms for\n        all bands are concatenated (for example, the histogram for an\n        \"RGB\" image contains 768 values).\n\n        A bilevel image (mode \"1\") is treated as a greyscale (\"L\") image\n        by this method.\n\n        If a mask is provided, the method returns a histogram for those\n        parts of the image where the mask image is non-zero. The mask\n        image must have the same size as the image, and be either a\n        bi-level image (mode \"1\") or a greyscale image (\"L\").\n\n        :param mask: An optional mask.\n        :returns: A list containing pixel counts.\n        \"\"\"\n        self.load()\n        if mask:\n            mask.load()\n            return self.im.histogram((0, 0), mask.im)\n        if self.mode in (\"I\", \"F\"):\n            if extrema is None:\n                extrema = self.getextrema()\n            return self.im.histogram(extrema)\n        return self.im.histogram()\n\n    def offset(self, xoffset, yoffset=None):\n        \"\"\"\n        .. deprecated:: 2.0\n\n        .. note:: New code should use :py:func:`PIL.ImageChops.offset`.\n\n        Returns a copy of the image where the data has been offset by the given\n        distances. Data wraps around the edges. If **yoffset** is omitted, it\n        is assumed to be equal to **xoffset**.\n\n        :param xoffset: The horizontal distance.\n        :param yoffset: The vertical distance.  If omitted, both\n           distances are set to the same value.\n        :returns: An :py:class:`~PIL.Image.Image` object.\n        \"\"\"\n        if warnings:\n            warnings.warn(\n                \"'offset' is deprecated; use 'ImageChops.offset' instead\",\n                DeprecationWarning, stacklevel=2\n                )\n        from PIL import ImageChops\n        return ImageChops.offset(self, xoffset, yoffset)\n\n    def paste(self, im, box=None, mask=None):\n        \"\"\"\n        Pastes another image into this image. The box argument is either\n        a 2-tuple giving the upper left corner, a 4-tuple defining the\n        left, upper, right, and lower pixel coordinate, or None (same as\n        (0, 0)).  If a 4-tuple is given, the size of the pasted image\n        must match the size of the region.\n\n        If the modes don't match, the pasted image is converted to the mode of\n        this image (see the :py:meth:`~PIL.Image.Image.convert` method for\n        details).\n\n        Instead of an image, the source can be a integer or tuple\n        containing pixel values.  The method then fills the region\n        with the given color.  When creating RGB images, you can\n        also use color strings as supported by the ImageColor module.\n\n        If a mask is given, this method updates only the regions\n        indicated by the mask.  You can use either \"1\", \"L\" or \"RGBA\"\n        images (in the latter case, the alpha band is used as mask).\n        Where the mask is 255, the given image is copied as is.  Where\n        the mask is 0, the current value is preserved.  Intermediate\n        values can be used for transparency effects.\n\n        Note that if you paste an \"RGBA\" image, the alpha band is\n        ignored.  You can work around this by using the same image as\n        both source image and mask.\n\n        :param im: Source image or pixel value (integer or tuple).\n        :param box: An optional 4-tuple giving the region to paste into.\n           If a 2-tuple is used instead, it's treated as the upper left\n           corner.  If omitted or None, the source is pasted into the\n           upper left corner.\n\n           If an image is given as the second argument and there is no\n           third, the box defaults to (0, 0), and the second argument\n           is interpreted as a mask image.\n        :param mask: An optional mask image.\n        :returns: An :py:class:`~PIL.Image.Image` object.\n        \"\"\"\n\n        if isImageType(box) and mask is None:\n            # abbreviated paste(im, mask) syntax\n            mask = box; box = None\n\n        if box is None:\n            # cover all of self\n            box = (0, 0) + self.size\n\n        if len(box) == 2:\n            # lower left corner given; get size from image or mask\n            if isImageType(im):\n                size = im.size\n            elif isImageType(mask):\n                size = mask.size\n            else:\n                # FIXME: use self.size here?\n                raise ValueError(\n                    \"cannot determine region size; use 4-item box\"\n                    )\n            box = box + (box[0]+size[0], box[1]+size[1])\n\n        if isStringType(im):\n            from PIL import ImageColor\n            im = ImageColor.getcolor(im, self.mode)\n\n        elif isImageType(im):\n            im.load()\n            if self.mode != im.mode:\n                if self.mode != \"RGB\" or im.mode not in (\"RGBA\", \"RGBa\"):\n                    # should use an adapter for this!\n                    im = im.convert(self.mode)\n            im = im.im\n\n        self.load()\n        if self.readonly:\n            self._copy()\n\n        if mask:\n            mask.load()\n            self.im.paste(im, box, mask.im)\n        else:\n            self.im.paste(im, box)\n\n    def point(self, lut, mode=None):\n        \"\"\"\n        Maps this image through a lookup table or function.\n\n        :param lut: A lookup table, containing 256 (or 65336 if\n           self.mode==\"I\" and mode == \"L\") values per band in the\n           image.  A function can be used instead, it should take a\n           single argument. The function is called once for each\n           possible pixel value, and the resulting table is applied to\n           all bands of the image.\n        :param mode: Output mode (default is same as input).  In the\n           current version, this can only be used if the source image\n           has mode \"L\" or \"P\", and the output has mode \"1\" or the\n           source image mode is \"I\" and the output mode is \"L\".\n        :returns: An :py:class:`~PIL.Image.Image` object.\n        \"\"\"\n\n        self.load()\n\n        if isinstance(lut, ImagePointHandler):\n            return lut.point(self)\n\n        if callable(lut):\n            # if it isn't a list, it should be a function\n            if self.mode in (\"I\", \"I;16\", \"F\"):\n                # check if the function can be used with point_transform\n                # UNDONE wiredfool -- I think this prevents us from ever doing\n                # a gamma function point transform on > 8bit images. \n                scale, offset = _getscaleoffset(lut)\n                return self._new(self.im.point_transform(scale, offset))\n            # for other modes, convert the function to a table\n            lut = [lut(i) for i in range(256)] * self.im.bands\n\n        if self.mode == \"F\":\n            # FIXME: _imaging returns a confusing error message for this case\n            raise ValueError(\"point operation not supported for this mode\")\n\n        return self._new(self.im.point(lut, mode))\n\n    def putalpha(self, alpha):\n        \"\"\"\n        Adds or replaces the alpha layer in this image.  If the image\n        does not have an alpha layer, it's converted to \"LA\" or \"RGBA\".\n        The new layer must be either \"L\" or \"1\".\n\n        :param alpha: The new alpha layer.  This can either be an \"L\" or \"1\"\n           image having the same size as this image, or an integer or\n           other color value.\n        \"\"\"\n\n        self.load()\n        if self.readonly:\n            self._copy()\n\n        if self.mode not in (\"LA\", \"RGBA\"):\n            # attempt to promote self to a matching alpha mode\n            try:\n                mode = getmodebase(self.mode) + \"A\"\n                try:\n                    self.im.setmode(mode)\n                except (AttributeError, ValueError):\n                    # do things the hard way\n                    im = self.im.convert(mode)\n                    if im.mode not in (\"LA\", \"RGBA\"):\n                        raise ValueError # sanity check\n                    self.im = im\n                self.mode = self.im.mode\n            except (KeyError, ValueError):\n                raise ValueError(\"illegal image mode\")\n\n        if self.mode == \"LA\":\n            band = 1\n        else:\n            band = 3\n\n        if isImageType(alpha):\n            # alpha layer\n            if alpha.mode not in (\"1\", \"L\"):\n                raise ValueError(\"illegal image mode\")\n            alpha.load()\n            if alpha.mode == \"1\":\n                alpha = alpha.convert(\"L\")\n        else:\n            # constant alpha\n            try:\n                self.im.fillband(band, alpha)\n            except (AttributeError, ValueError):\n                # do things the hard way\n                alpha = new(\"L\", self.size, alpha)\n            else:\n                return\n\n        self.im.putband(alpha.im, band)\n\n    def putdata(self, data, scale=1.0, offset=0.0):\n        \"\"\"\n        Copies pixel data to this image.  This method copies data from a\n        sequence object into the image, starting at the upper left\n        corner (0, 0), and continuing until either the image or the\n        sequence ends.  The scale and offset values are used to adjust\n        the sequence values: **pixel = value*scale + offset**.\n\n        :param data: A sequence object.\n        :param scale: An optional scale value.  The default is 1.0.\n        :param offset: An optional offset value.  The default is 0.0.\n        \"\"\"\n\n        self.load()\n        if self.readonly:\n            self._copy()\n\n        self.im.putdata(data, scale, offset)\n\n    def putpalette(self, data, rawmode=\"RGB\"):\n        \"\"\"\n        Attaches a palette to this image.  The image must be a \"P\" or\n        \"L\" image, and the palette sequence must contain 768 integer\n        values, where each group of three values represent the red,\n        green, and blue values for the corresponding pixel\n        index. Instead of an integer sequence, you can use an 8-bit\n        string.\n\n        :param data: A palette sequence (either a list or a string).\n        \"\"\"\n        from PIL import ImagePalette\n\n        if self.mode not in (\"L\", \"P\"):\n            raise ValueError(\"illegal image mode\")\n        self.load()\n        if isinstance(data, ImagePalette.ImagePalette):\n            palette = ImagePalette.raw(data.rawmode, data.palette)\n        else:\n            if not isinstance(data, bytes):\n                if bytes is str:\n                    data = \"\".join(chr(x) for x in data)\n                else:\n                    data = bytes(data)\n            palette = ImagePalette.raw(rawmode, data)\n        self.mode = \"P\"\n        self.palette = palette\n        self.palette.mode = \"RGB\"\n        self.load() # install new palette\n\n    def putpixel(self, xy, value):\n        \"\"\"\n        Modifies the pixel at the given position. The color is given as\n        a single numerical value for single-band images, and a tuple for\n        multi-band images.\n\n        Note that this method is relatively slow.  For more extensive changes,\n        use :py:meth:`~PIL.Image.Image.paste` or the :py:mod:`~PIL.ImageDraw`\n        module instead.\n\n        See:\n\n        * :py:meth:`~PIL.Image.Image.paste`\n        * :py:meth:`~PIL.Image.Image.putdata`\n        * :py:mod:`~PIL.ImageDraw`\n\n        :param xy: The pixel coordinate, given as (x, y).\n        :param value: The pixel value.\n        \"\"\"\n\n        self.load()\n        if self.readonly:\n            self._copy()\n\n        return self.im.putpixel(xy, value)\n\n    def resize(self, size, resample=NEAREST):\n        \"\"\"\n        Returns a resized copy of this image.\n\n        :param size: The requested size in pixels, as a 2-tuple:\n           (width, height).\n        :param filter: An optional resampling filter.  This can be\n           one of :py:attr:`PIL.Image.NEAREST` (use nearest neighbour),\n           :py:attr:`PIL.Image.BILINEAR` (linear interpolation in a 2x2\n           environment), :py:attr:`PIL.Image.BICUBIC` (cubic spline\n           interpolation in a 4x4 environment), or\n           :py:attr:`PIL.Image.ANTIALIAS` (a high-quality downsampling filter).\n           If omitted, or if the image has mode \"1\" or \"P\", it is\n           set :py:attr:`PIL.Image.NEAREST`.\n        :returns: An :py:class:`~PIL.Image.Image` object.\n        \"\"\"\n\n        if resample not in (NEAREST, BILINEAR, BICUBIC, ANTIALIAS):\n            raise ValueError(\"unknown resampling filter\")\n\n        self.load()\n\n        if self.mode in (\"1\", \"P\"):\n            resample = NEAREST\n\n        if self.mode == 'RGBA':\n            return self.convert('RGBa').resize(size, resample).convert('RGBA')\n\n        if resample == ANTIALIAS:\n            # requires stretch support (imToolkit & PIL 1.1.3)\n            try:\n                im = self.im.stretch(size, resample)\n            except AttributeError:\n                raise ValueError(\"unsupported resampling filter\")\n        else:\n            im = self.im.resize(size, resample)\n\n        return self._new(im)\n\n    def rotate(self, angle, resample=NEAREST, expand=0):\n        \"\"\"\n        Returns a rotated copy of this image.  This method returns a\n        copy of this image, rotated the given number of degrees counter\n        clockwise around its centre.\n\n        :param angle: In degrees counter clockwise.\n        :param filter: An optional resampling filter.  This can be\n           one of :py:attr:`PIL.Image.NEAREST` (use nearest neighbour),\n           :py:attr:`PIL.Image.BILINEAR` (linear interpolation in a 2x2\n           environment), or :py:attr:`PIL.Image.BICUBIC`\n           (cubic spline interpolation in a 4x4 environment).\n           If omitted, or if the image has mode \"1\" or \"P\", it is\n           set :py:attr:`PIL.Image.NEAREST`.\n        :param expand: Optional expansion flag.  If true, expands the output\n           image to make it large enough to hold the entire rotated image.\n           If false or omitted, make the output image the same size as the\n           input image.\n        :returns: An :py:class:`~PIL.Image.Image` object.\n        \"\"\"\n\n        if expand:\n            import math\n            angle = -angle * math.pi / 180\n            matrix = [\n                 math.cos(angle), math.sin(angle), 0.0,\n                -math.sin(angle), math.cos(angle), 0.0\n                 ]\n            def transform(x, y, matrix=matrix):\n                (a, b, c, d, e, f) = matrix\n                return a*x + b*y + c, d*x + e*y + f\n\n            # calculate output size\n            w, h = self.size\n            xx = []\n            yy = []\n            for x, y in ((0, 0), (w, 0), (w, h), (0, h)):\n                x, y = transform(x, y)\n                xx.append(x)\n                yy.append(y)\n            w = int(math.ceil(max(xx)) - math.floor(min(xx)))\n            h = int(math.ceil(max(yy)) - math.floor(min(yy)))\n\n            # adjust center\n            x, y = transform(w / 2.0, h / 2.0)\n            matrix[2] = self.size[0] / 2.0 - x\n            matrix[5] = self.size[1] / 2.0 - y\n\n            return self.transform((w, h), AFFINE, matrix, resample)\n\n        if resample not in (NEAREST, BILINEAR, BICUBIC):\n            raise ValueError(\"unknown resampling filter\")\n\n        self.load()\n\n        if self.mode in (\"1\", \"P\"):\n            resample = NEAREST\n\n        return self._new(self.im.rotate(angle, resample))\n\n    def save(self, fp, format=None, **params):\n        \"\"\"\n        Saves this image under the given filename.  If no format is\n        specified, the format to use is determined from the filename\n        extension, if possible.\n\n        Keyword options can be used to provide additional instructions\n        to the writer. If a writer doesn't recognise an option, it is\n        silently ignored. The available options are described later in\n        this handbook.\n\n        You can use a file object instead of a filename. In this case,\n        you must always specify the format. The file object must\n        implement the **seek**, **tell**, and **write**\n        methods, and be opened in binary mode.\n\n        :param file: File name or file object.\n        :param format: Optional format override.  If omitted, the\n           format to use is determined from the filename extension.\n           If a file object was used instead of a filename, this\n           parameter should always be used.\n        :param options: Extra parameters to the image writer.\n        :returns: None\n        :exception KeyError: If the output format could not be determined\n           from the file name.  Use the format option to solve this.\n        :exception IOError: If the file could not be written.  The file\n           may have been created, and may contain partial data.\n        \"\"\"\n\n        if isPath(fp):\n            filename = fp\n        else:\n            if hasattr(fp, \"name\") and isPath(fp.name):\n                filename = fp.name\n            else:\n                filename = \"\"\n\n        # may mutate self!\n        self.load()\n\n        self.encoderinfo = params\n        self.encoderconfig = ()\n\n        preinit()\n\n        ext = os.path.splitext(filename)[1].lower()\n\n        if not format:\n            try:\n                format = EXTENSION[ext]\n            except KeyError:\n                init()\n                try:\n                    format = EXTENSION[ext]\n                except KeyError:\n                    raise KeyError(ext) # unknown extension\n\n        try:\n            save_handler = SAVE[format.upper()]\n        except KeyError:\n            init()\n            save_handler = SAVE[format.upper()] # unknown format\n\n        if isPath(fp):\n            fp = builtins.open(fp, \"wb\")\n            close = 1\n        else:\n            close = 0\n\n        try:\n            save_handler(self, fp, filename)\n        finally:\n            # do what we can to clean up\n            if close:\n                fp.close()\n\n    def seek(self, frame):\n        \"\"\"\n        Seeks to the given frame in this sequence file. If you seek\n        beyond the end of the sequence, the method raises an\n        **EOFError** exception. When a sequence file is opened, the\n        library automatically seeks to frame 0.\n\n        Note that in the current version of the library, most sequence\n        formats only allows you to seek to the next frame.\n\n        See :py:meth:`~PIL.Image.Image.tell`.\n\n        :param frame: Frame number, starting at 0.\n        :exception EOFError: If the call attempts to seek beyond the end\n            of the sequence.\n        \"\"\"\n\n        # overridden by file handlers\n        if frame != 0:\n            raise EOFError\n\n    def show(self, title=None, command=None):\n        \"\"\"\n        Displays this image. This method is mainly intended for\n        debugging purposes.\n\n        On Unix platforms, this method saves the image to a temporary\n        PPM file, and calls the **xv** utility.\n\n        On Windows, it saves the image to a temporary BMP file, and uses\n        the standard BMP display utility to show it (usually Paint).\n\n        :param title: Optional title to use for the image window,\n           where possible.\n        :param command: command used to show the image\n        \"\"\"\n\n        _show(self, title=title, command=command)\n\n    def split(self):\n        \"\"\"\n        Split this image into individual bands. This method returns a\n        tuple of individual image bands from an image. For example,\n        splitting an \"RGB\" image creates three new images each\n        containing a copy of one of the original bands (red, green,\n        blue).\n\n        :returns: A tuple containing bands.\n        \"\"\"\n\n        self.load()\n        if self.im.bands == 1:\n            ims = [self.copy()]\n        else:\n            ims = []\n            for i in range(self.im.bands):\n                ims.append(self._new(self.im.getband(i)))\n        return tuple(ims)\n\n    def tell(self):\n        \"\"\"\n        Returns the current frame number. See :py:meth:`~PIL.Image.Image.seek`.\n\n        :returns: Frame number, starting with 0.\n        \"\"\"\n        return 0\n\n    def thumbnail(self, size, resample=NEAREST):\n        \"\"\"\n        Make this image into a thumbnail.  This method modifies the\n        image to contain a thumbnail version of itself, no larger than\n        the given size.  This method calculates an appropriate thumbnail\n        size to preserve the aspect of the image, calls the\n        :py:meth:`~PIL.Image.Image.draft` method to configure the file reader\n        (where applicable), and finally resizes the image.\n\n        Note that the bilinear and bicubic filters in the current\n        version of PIL are not well-suited for thumbnail generation.\n        You should use :py:attr:`PIL.Image.ANTIALIAS` unless speed is much more\n        important than quality.\n\n        Also note that this function modifies the :py:class:`~PIL.Image.Image`\n        object in place.  If you need to use the full resolution image as well, apply\n        this method to a :py:meth:`~PIL.Image.Image.copy` of the original image.\n\n        :param size: Requested size.\n        :param resample: Optional resampling filter.  This can be one\n           of :py:attr:`PIL.Image.NEAREST`, :py:attr:`PIL.Image.BILINEAR`,\n           :py:attr:`PIL.Image.BICUBIC`, or :py:attr:`PIL.Image.ANTIALIAS`\n           (best quality).  If omitted, it defaults to\n           :py:attr:`PIL.Image.NEAREST` (this will be changed to ANTIALIAS in a\n           future version).\n        :returns: None\n        \"\"\"\n\n        # FIXME: the default resampling filter will be changed\n        # to ANTIALIAS in future versions\n\n        # preserve aspect ratio\n        x, y = self.size\n        if x > size[0]: y = int(max(y * size[0] / x, 1)); x = int(size[0])\n        if y > size[1]: x = int(max(x * size[1] / y, 1)); y = int(size[1])\n        size = x, y\n\n        if size == self.size:\n            return\n\n        self.draft(None, size)\n\n        self.load()\n\n        try:\n            im = self.resize(size, resample)\n        except ValueError:\n            if resample != ANTIALIAS:\n                raise\n            im = self.resize(size, NEAREST) # fallback\n\n        self.im = im.im\n        self.mode = im.mode\n        self.size = size\n\n        self.readonly = 0\n\n    # FIXME: the different tranform methods need further explanation\n    # instead of bloating the method docs, add a separate chapter.\n    def transform(self, size, method, data=None, resample=NEAREST, fill=1):\n        \"\"\"\n        Transforms this image.  This method creates a new image with the\n        given size, and the same mode as the original, and copies data\n        to the new image using the given transform.\n\n        :param size: The output size.\n        :param method: The transformation method.  This is one of\n          :py:attr:`PIL.Image.EXTENT` (cut out a rectangular subregion),\n          :py:attr:`PIL.Image.AFFINE` (affine transform),\n          :py:attr:`PIL.Image.PERSPECTIVE` (perspective transform),\n          :py:attr:`PIL.Image.QUAD` (map a quadrilateral to a rectangle), or\n          :py:attr:`PIL.Image.MESH` (map a number of source quadrilaterals\n          in one operation).\n        :param data: Extra data to the transformation method.\n        :param resample: Optional resampling filter.  It can be one of\n           :py:attr:`PIL.Image.NEAREST` (use nearest neighbour),\n           :py:attr:`PIL.Image.BILINEAR` (linear interpolation in a 2x2\n           environment), or :py:attr:`PIL.Image.BICUBIC` (cubic spline\n           interpolation in a 4x4 environment). If omitted, or if the image\n           has mode \"1\" or \"P\", it is set to :py:attr:`PIL.Image.NEAREST`.\n        :returns: An :py:class:`~PIL.Image.Image` object.\n        \"\"\"\n\n        if self.mode == 'RGBA':\n            return self.convert('RGBa').transform(size, method, data, resample, fill).convert('RGBA')\n\n        if isinstance(method, ImageTransformHandler):\n            return method.transform(size, self, resample=resample, fill=fill)\n        if hasattr(method, \"getdata\"):\n            # compatibility w. old-style transform objects\n            method, data = method.getdata()\n        if data is None:\n            raise ValueError(\"missing method data\")\n\n        im = new(self.mode, size, None)\n        if method == MESH:\n            # list of quads\n            for box, quad in data:\n                im.__transformer(box, self, QUAD, quad, resample, fill)\n        else:\n            im.__transformer((0, 0)+size, self, method, data, resample, fill)\n\n        return im\n\n    def __transformer(self, box, image, method, data,\n                      resample=NEAREST, fill=1):\n\n        # FIXME: this should be turned into a lazy operation (?)\n\n        w = box[2]-box[0]\n        h = box[3]-box[1]\n\n        if method == AFFINE:\n            # change argument order to match implementation\n            data = (data[2], data[0], data[1],\n                    data[5], data[3], data[4])\n        elif method == EXTENT:\n            # convert extent to an affine transform\n            x0, y0, x1, y1 = data\n            xs = float(x1 - x0) / w\n            ys = float(y1 - y0) / h\n            method = AFFINE\n            data = (x0 + xs/2, xs, 0, y0 + ys/2, 0, ys)\n        elif method == PERSPECTIVE:\n            # change argument order to match implementation\n            data = (data[2], data[0], data[1],\n                    data[5], data[3], data[4],\n                    data[6], data[7])\n        elif method == QUAD:\n            # quadrilateral warp.  data specifies the four corners\n            # given as NW, SW, SE, and NE.\n            nw = data[0:2]; sw = data[2:4]; se = data[4:6]; ne = data[6:8]\n            x0, y0 = nw; As = 1.0 / w; At = 1.0 / h\n            data = (x0, (ne[0]-x0)*As, (sw[0]-x0)*At,\n                    (se[0]-sw[0]-ne[0]+x0)*As*At,\n                    y0, (ne[1]-y0)*As, (sw[1]-y0)*At,\n                    (se[1]-sw[1]-ne[1]+y0)*As*At)\n        else:\n            raise ValueError(\"unknown transformation method\")\n\n        if resample not in (NEAREST, BILINEAR, BICUBIC):\n            raise ValueError(\"unknown resampling filter\")\n\n        image.load()\n\n        self.load()\n\n        if image.mode in (\"1\", \"P\"):\n            resample = NEAREST\n\n        self.im.transform2(box, image.im, method, data, resample, fill)\n\n    def transpose(self, method):\n        \"\"\"\n        Transpose image (flip or rotate in 90 degree steps)\n\n        :param method: One of :py:attr:`PIL.Image.FLIP_LEFT_RIGHT`,\n          :py:attr:`PIL.Image.FLIP_TOP_BOTTOM`, :py:attr:`PIL.Image.ROTATE_90`,\n          :py:attr:`PIL.Image.ROTATE_180`, or :py:attr:`PIL.Image.ROTATE_270`.\n        :returns: Returns a flipped or rotated copy of this image.\n        \"\"\"\n\n        self.load()\n        im = self.im.transpose(method)\n        return self._new(im)\n\n# --------------------------------------------------------------------\n# Lazy operations\n\nclass _ImageCrop(Image):\n\n    def __init__(self, im, box):\n\n        Image.__init__(self)\n\n        x0, y0, x1, y1 = box\n        if x1 < x0:\n            x1 = x0\n        if y1 < y0:\n            y1 = y0\n\n        self.mode = im.mode\n        self.size = x1-x0, y1-y0\n\n        self.__crop = x0, y0, x1, y1\n\n        self.im = im.im\n\n    def load(self):\n\n        # lazy evaluation!\n        if self.__crop:\n            self.im = self.im.crop(self.__crop)\n            self.__crop = None\n\n        if self.im:\n            return self.im.pixel_access(self.readonly)\n\n        # FIXME: future versions should optimize crop/paste\n        # sequences!\n\n# --------------------------------------------------------------------\n# Abstract handlers.\n\nclass ImagePointHandler:\n    # used as a mixin by point transforms (for use with im.point)\n    pass\n\nclass ImageTransformHandler:\n    # used as a mixin by geometry transforms (for use with im.transform)\n    pass\n\n# --------------------------------------------------------------------\n# Factories\n\n#\n# Debugging\n\ndef _wedge():\n    \"Create greyscale wedge (for debugging only)\"\n\n    return Image()._new(core.wedge(\"L\"))\n\n\ndef new(mode, size, color=0):\n    \"\"\"\n    Creates a new image with the given mode and size.\n\n    :param mode: The mode to use for the new image.\n    :param size: A 2-tuple, containing (width, height) in pixels.\n    :param color: What color to use for the image.  Default is black.\n       If given, this should be a single integer or floating point value\n       for single-band modes, and a tuple for multi-band modes (one value\n       per band).  When creating RGB images, you can also use color\n       strings as supported by the ImageColor module.  If the color is\n       None, the image is not initialised.\n    :returns: An :py:class:`~PIL.Image.Image` object.\n    \"\"\"\n\n    if color is None:\n        # don't initialize\n        return Image()._new(core.new(mode, size))\n\n    if isStringType(color):\n        # css3-style specifier\n\n        from PIL import ImageColor\n        color = ImageColor.getcolor(color, mode)\n\n    return Image()._new(core.fill(mode, size, color))\n\n\ndef frombytes(mode, size, data, decoder_name=\"raw\", *args):\n    \"\"\"\n    Creates a copy of an image memory from pixel data in a buffer.\n\n    In its simplest form, this function takes three arguments\n    (mode, size, and unpacked pixel data).\n\n    You can also use any pixel decoder supported by PIL.  For more\n    information on available decoders, see the section\n    **Writing Your Own File Decoder**.\n\n    Note that this function decodes pixel data only, not entire images.\n    If you have an entire image in a string, wrap it in a\n    :py:class:`~io.BytesIO` object, and use :py:func:`~PIL.Image.open` to load\n    it.\n\n    :param mode: The image mode.\n    :param size: The image size.\n    :param data: A byte buffer containing raw data for the given mode.\n    :param decoder_name: What decoder to use.\n    :param args: Additional parameters for the given decoder.\n    :returns: An :py:class:`~PIL.Image.Image` object.\n    \"\"\"\n\n    # may pass tuple instead of argument list\n    if len(args) == 1 and isinstance(args[0], tuple):\n        args = args[0]\n\n    if decoder_name == \"raw\" and args == ():\n        args = mode\n\n    im = new(mode, size)\n    im.frombytes(data, decoder_name, args)\n    return im\n\ndef fromstring(*args, **kw):\n    \"\"\"Deprecated alias to frombytes.\n\n    .. deprecated:: 2.0\n    \"\"\"\n    warnings.warn(\n        'fromstring() is deprecated. Please call frombytes() instead.',\n        DeprecationWarning,\n        stacklevel=2\n    )\n    return frombytes(*args, **kw)\n\n\ndef frombuffer(mode, size, data, decoder_name=\"raw\", *args):\n    \"\"\"\n    Creates an image memory referencing pixel data in a byte buffer.\n\n    This function is similar to :py:func:`~PIL.Image.frombytes`, but uses data\n    in the byte buffer, where possible.  This means that changes to the\n    original buffer object are reflected in this image).  Not all modes can\n    share memory; supported modes include \"L\", \"RGBX\", \"RGBA\", and \"CMYK\".\n\n    Note that this function decodes pixel data only, not entire images.\n    If you have an entire image file in a string, wrap it in a\n    **BytesIO** object, and use :py:func:`~PIL.Image.open` to load it.\n\n    In the current version, the default parameters used for the \"raw\" decoder\n    differs from that used for :py:func:`~PIL.Image.fromstring`.  This is a\n    bug, and will probably be fixed in a future release.  The current release\n    issues a warning if you do this; to disable the warning, you should provide\n    the full set of parameters.  See below for details.\n\n    :param mode: The image mode.\n    :param size: The image size.\n    :param data: A bytes or other buffer object containing raw\n        data for the given mode.\n    :param decoder_name: What decoder to use.\n    :param args: Additional parameters for the given decoder.  For the\n        default encoder (\"raw\"), it's recommended that you provide the\n        full set of parameters::\n\n            frombuffer(mode, size, data, \"raw\", mode, 0, 1)\n\n    :returns: An :py:class:`~PIL.Image.Image` object.\n\n    .. versionadded:: 1.1.4\n    \"\"\"\n    \"Load image from bytes or buffer\"\n\n    # may pass tuple instead of argument list\n    if len(args) == 1 and isinstance(args[0], tuple):\n        args = args[0]\n\n    if decoder_name == \"raw\":\n        if args == ():\n            if warnings:\n                warnings.warn(\n                    \"the frombuffer defaults may change in a future release; \"\n                    \"for portability, change the call to read:\\n\"\n                    \"  frombuffer(mode, size, data, 'raw', mode, 0, 1)\",\n                    RuntimeWarning, stacklevel=2\n                )\n            args = mode, 0, -1 # may change to (mode, 0, 1) post-1.1.6\n        if args[0] in _MAPMODES:\n            im = new(mode, (1,1))\n            im = im._new(\n                core.map_buffer(data, size, decoder_name, None, 0, args)\n                )\n            im.readonly = 1\n            return im\n\n    return frombytes(mode, size, data, decoder_name, args)\n\n\ndef fromarray(obj, mode=None):\n    \"\"\"\n    Creates an image memory from an object exporting the array interface\n    (using the buffer protocol).\n\n    If obj is not contiguous, then the tobytes method is called\n    and :py:func:`~PIL.Image.frombuffer` is used.\n\n    :param obj: Object with array interface\n    :param mode: Mode to use (will be determined from type if None)\n    :returns: An image memory.\n\n    .. versionadded:: 1.1.6\n    \"\"\"\n    arr = obj.__array_interface__\n    shape = arr['shape']\n    ndim = len(shape)\n    try:\n        strides = arr['strides']\n    except KeyError:\n        strides = None\n    if mode is None:\n        try:\n            typekey = (1, 1) + shape[2:], arr['typestr']\n            mode, rawmode = _fromarray_typemap[typekey]\n        except KeyError:\n            # print typekey\n            raise TypeError(\"Cannot handle this data type\")\n    else:\n        rawmode = mode\n    if mode in [\"1\", \"L\", \"I\", \"P\", \"F\"]:\n        ndmax = 2\n    elif mode == \"RGB\":\n        ndmax = 3\n    else:\n        ndmax = 4\n    if ndim > ndmax:\n        raise ValueError(\"Too many dimensions.\")\n\n    size = shape[1], shape[0]\n    if strides is not None:\n        if hasattr(obj, 'tobytes'):\n            obj = obj.tobytes()\n        else:\n            obj = obj.tostring()\n\n    return frombuffer(mode, size, obj, \"raw\", rawmode, 0, 1)\n\n_fromarray_typemap = {\n    # (shape, typestr) => mode, rawmode\n    # first two members of shape are set to one\n    # ((1, 1), \"|b1\"): (\"1\", \"1\"), # broken\n    ((1, 1), \"|u1\"): (\"L\", \"L\"),\n    ((1, 1), \"|i1\"): (\"I\", \"I;8\"),\n    ((1, 1), \"<i2\"): (\"I\", \"I;16\"),\n    ((1, 1), \">i2\"): (\"I\", \"I;16B\"),\n    ((1, 1), \"<i4\"): (\"I\", \"I;32\"),\n    ((1, 1), \">i4\"): (\"I\", \"I;32B\"),\n    ((1, 1), \"<f4\"): (\"F\", \"F;32F\"),\n    ((1, 1), \">f4\"): (\"F\", \"F;32BF\"),\n    ((1, 1), \"<f8\"): (\"F\", \"F;64F\"),\n    ((1, 1), \">f8\"): (\"F\", \"F;64BF\"),\n    ((1, 1, 3), \"|u1\"): (\"RGB\", \"RGB\"),\n    ((1, 1, 4), \"|u1\"): (\"RGBA\", \"RGBA\"),\n    }\n\n# shortcuts\n_fromarray_typemap[((1, 1), _ENDIAN + \"i4\")] = (\"I\", \"I\")\n_fromarray_typemap[((1, 1), _ENDIAN + \"f4\")] = (\"F\", \"F\")\n\n\ndef open(fp, mode=\"r\"):\n    \"\"\"\n    Opens and identifies the given image file.\n\n    This is a lazy operation; this function identifies the file, but the\n    actual image data is not read from the file until you try to process\n    the data (or call the :py:meth:`~PIL.Image.Image.load` method).\n    See :py:func:`~PIL.Image.new`.\n\n    :param file: A filename (string) or a file object.  The file object\n       must implement :py:meth:`~file.read`, :py:meth:`~file.seek`, and\n       :py:meth:`~file.tell` methods, and be opened in binary mode.\n    :param mode: The mode.  If given, this argument must be \"r\".\n    :returns: An :py:class:`~PIL.Image.Image` object.\n    :exception IOError: If the file cannot be found, or the image cannot be\n       opened and identified.\n    \"\"\"\n\n    if mode != \"r\":\n        raise ValueError(\"bad mode\")\n\n    if isPath(fp):\n        filename = fp\n        fp = builtins.open(fp, \"rb\")\n    else:\n        filename = \"\"\n\n    prefix = fp.read(16)\n\n    preinit()\n\n    for i in ID:\n        try:\n            factory, accept = OPEN[i]\n            if not accept or accept(prefix):\n                fp.seek(0)\n                return factory(fp, filename)\n        except (SyntaxError, IndexError, TypeError):\n            #import traceback\n            #traceback.print_exc()\n            pass\n\n    if init():\n\n        for i in ID:\n            try:\n                factory, accept = OPEN[i]\n                if not accept or accept(prefix):\n                    fp.seek(0)\n                    return factory(fp, filename)\n            except (SyntaxError, IndexError, TypeError):\n                #import traceback\n                #traceback.print_exc()\n                pass\n\n    raise IOError(\"cannot identify image file\")\n\n#\n# Image processing.\n\ndef alpha_composite(im1, im2):\n    \"\"\"\n    Alpha composite im2 over im1.\n\n    :param im1: The first image.\n    :param im2: The second image.  Must have the same mode and size as\n       the first image.\n    :returns: An :py:class:`~PIL.Image.Image` object.\n    \"\"\"\n\n    im1.load()\n    im2.load()\n    return im1._new(core.alpha_composite(im1.im, im2.im))\n\n\ndef blend(im1, im2, alpha):\n    \"\"\"\n    Creates a new image by interpolating between two input images, using\n    a constant alpha.::\n\n        out = image1 * (1.0 - alpha) + image2 * alpha\n\n    :param im1: The first image.\n    :param im2: The second image.  Must have the same mode and size as\n       the first image.\n    :param alpha: The interpolation alpha factor.  If alpha is 0.0, a\n       copy of the first image is returned. If alpha is 1.0, a copy of\n       the second image is returned. There are no restrictions on the\n       alpha value. If necessary, the result is clipped to fit into\n       the allowed output range.\n    :returns: An :py:class:`~PIL.Image.Image` object.\n    \"\"\"\n\n    im1.load()\n    im2.load()\n    return im1._new(core.blend(im1.im, im2.im, alpha))\n\n\ndef composite(image1, image2, mask):\n    \"\"\"\n    Create composite image by blending images using a transparency mask.\n\n    :param image1: The first image.\n    :param image2: The second image.  Must have the same mode and\n       size as the first image.\n    :param mask: A mask image.  This image can can have mode\n       \"1\", \"L\", or \"RGBA\", and must have the same size as the\n       other two images.\n    \"\"\"\n\n    image = image2.copy()\n    image.paste(image1, None, mask)\n    return image\n\n\ndef eval(image, *args):\n    \"\"\"\n    Applies the function (which should take one argument) to each pixel\n    in the given image. If the image has more than one band, the same\n    function is applied to each band. Note that the function is\n    evaluated once for each possible pixel value, so you cannot use\n    random components or other generators.\n\n    :param image: The input image.\n    :param function: A function object, taking one integer argument.\n    :returns: An :py:class:`~PIL.Image.Image` object.\n    \"\"\"\n\n    return image.point(args[0])\n\n\ndef merge(mode, bands):\n    \"\"\"\n    Merge a set of single band images into a new multiband image.\n\n    :param mode: The mode to use for the output image.\n    :param bands: A sequence containing one single-band image for\n        each band in the output image.  All bands must have the\n        same size.\n    :returns: An :py:class:`~PIL.Image.Image` object.\n    \"\"\"\n\n    if getmodebands(mode) != len(bands) or \"*\" in mode:\n        raise ValueError(\"wrong number of bands\")\n    for im in bands[1:]:\n        if im.mode != getmodetype(mode):\n            raise ValueError(\"mode mismatch\")\n        if im.size != bands[0].size:\n            raise ValueError(\"size mismatch\")\n    im = core.new(mode, bands[0].size)\n    for i in range(getmodebands(mode)):\n        bands[i].load()\n        im.putband(bands[i].im, i)\n    return bands[0]._new(im)\n\n# --------------------------------------------------------------------\n# Plugin registry\n\ndef register_open(id, factory, accept=None):\n    \"\"\"\n    Register an image file plugin.  This function should not be used\n    in application code.\n\n    :param id: An image format identifier.\n    :param factory: An image file factory method.\n    :param accept: An optional function that can be used to quickly\n       reject images having another format.\n    \"\"\"\n    id = id.upper()\n    ID.append(id)\n    OPEN[id] = factory, accept\n\n\ndef register_mime(id, mimetype):\n    \"\"\"\n    Registers an image MIME type.  This function should not be used\n    in application code.\n\n    :param id: An image format identifier.\n    :param mimetype: The image MIME type for this format.\n    \"\"\"\n    MIME[id.upper()] = mimetype\n\n\ndef register_save(id, driver):\n    \"\"\"\n    Registers an image save function.  This function should not be\n    used in application code.\n\n    :param id: An image format identifier.\n    :param driver: A function to save images in this format.\n    \"\"\"\n    SAVE[id.upper()] = driver\n\n\ndef register_extension(id, extension):\n    \"\"\"\n    Registers an image extension.  This function should not be\n    used in application code.\n\n    :param id: An image format identifier.\n    :param extension: An extension used for this format.\n    \"\"\"\n    EXTENSION[extension.lower()] = id.upper()\n\n\n# --------------------------------------------------------------------\n# Simple display support.  User code may override this.\n\ndef _show(image, **options):\n    # override me, as necessary\n    _showxv(image, **options)\n\ndef _showxv(image, title=None, **options):\n    from PIL import ImageShow\n    ImageShow.show(image, title, **options)\n", "#\n# The Python Imaging Library.\n# $Id$\n#\n# IPTC/NAA file handling\n#\n# history:\n# 1995-10-01 fl   Created\n# 1998-03-09 fl   Cleaned up and added to PIL\n# 2002-06-18 fl   Added getiptcinfo helper\n#\n# Copyright (c) Secret Labs AB 1997-2002.\n# Copyright (c) Fredrik Lundh 1995.\n#\n# See the README file for information on usage and redistribution.\n#\n\nfrom __future__ import print_function\n\n__version__ = \"0.3\"\n\n\nfrom PIL import Image, ImageFile, _binary\nimport os, tempfile\n\ni8 = _binary.i8\ni16 = _binary.i16be\ni32 = _binary.i32be\no8 = _binary.o8\n\nCOMPRESSION = {\n    1: \"raw\",\n    5: \"jpeg\"\n}\n\nPAD = o8(0) * 4\n\n#\n# Helpers\n\ndef i(c):\n    return i32((PAD + c)[-4:])\n\ndef dump(c):\n    for i in c:\n        print(\"%02x\" % i8(i), end=' ')\n    print()\n\n##\n# Image plugin for IPTC/NAA datastreams.  To read IPTC/NAA fields\n# from TIFF and JPEG files, use the <b>getiptcinfo</b> function.\n\nclass IptcImageFile(ImageFile.ImageFile):\n\n    format = \"IPTC\"\n    format_description = \"IPTC/NAA\"\n\n    def getint(self, key):\n        return i(self.info[key])\n\n    def field(self):\n        #\n        # get a IPTC field header\n        s = self.fp.read(5)\n        if not len(s):\n            return None, 0\n\n        tag = i8(s[1]), i8(s[2])\n\n        # syntax\n        if i8(s[0]) != 0x1C or tag[0] < 1 or tag[0] > 9:\n            raise SyntaxError(\"invalid IPTC/NAA file\")\n\n        # field size\n        size = i8(s[3])\n        if size > 132:\n            raise IOError(\"illegal field length in IPTC/NAA file\")\n        elif size == 128:\n            size = 0\n        elif size > 128:\n            size = i(self.fp.read(size-128))\n        else:\n            size = i16(s[3:])\n\n        return tag, size\n\n    def _is_raw(self, offset, size):\n        #\n        # check if the file can be mapped\n\n        # DISABLED: the following only slows things down...\n        return 0\n\n        self.fp.seek(offset)\n        t, sz = self.field()\n        if sz != size[0]:\n            return 0\n        y = 1\n        while True:\n            self.fp.seek(sz, 1)\n            t, s = self.field()\n            if t != (8, 10):\n                break\n            if s != sz:\n                return 0\n            y = y + 1\n        return y == size[1]\n\n    def _open(self):\n\n        # load descriptive fields\n        while True:\n            offset = self.fp.tell()\n            tag, size = self.field()\n            if not tag or tag == (8,10):\n                break\n            if size:\n                tagdata = self.fp.read(size)\n            else:\n                tagdata = None\n            if tag in list(self.info.keys()):\n                if isinstance(self.info[tag], list):\n                    self.info[tag].append(tagdata)\n                else:\n                    self.info[tag] = [self.info[tag], tagdata]\n            else:\n                self.info[tag] = tagdata\n\n            # print tag, self.info[tag]\n\n        # mode\n        layers = i8(self.info[(3,60)][0])\n        component = i8(self.info[(3,60)][1])\n        if (3,65) in self.info:\n            id = i8(self.info[(3,65)][0])-1\n        else:\n            id = 0\n        if layers == 1 and not component:\n            self.mode = \"L\"\n        elif layers == 3 and component:\n            self.mode = \"RGB\"[id]\n        elif layers == 4 and component:\n            self.mode = \"CMYK\"[id]\n\n        # size\n        self.size = self.getint((3,20)), self.getint((3,30))\n\n        # compression\n        try:\n            compression = COMPRESSION[self.getint((3,120))]\n        except KeyError:\n            raise IOError(\"Unknown IPTC image compression\")\n\n        # tile\n        if tag == (8,10):\n            if compression == \"raw\" and self._is_raw(offset, self.size):\n                self.tile = [(compression, (offset, size + 5, -1),\n                             (0, 0, self.size[0], self.size[1]))]\n            else:\n                self.tile = [(\"iptc\", (compression, offset),\n                             (0, 0, self.size[0], self.size[1]))]\n\n    def load(self):\n\n        if len(self.tile) != 1 or self.tile[0][0] != \"iptc\":\n            return ImageFile.ImageFile.load(self)\n\n        type, tile, box = self.tile[0]\n\n        encoding, offset = tile\n\n        self.fp.seek(offset)\n\n        # Copy image data to temporary file\n        o_fd, outfile = tempfile.mkstemp(text=False)\n        o = os.fdopen(o_fd)\n        if encoding == \"raw\":\n            # To simplify access to the extracted file,\n            # prepend a PPM header\n            o.write(\"P5\\n%d %d\\n255\\n\" % self.size)\n        while True:\n            type, size = self.field()\n            if type != (8, 10):\n                break\n            while size > 0:\n                s = self.fp.read(min(size, 8192))\n                if not s:\n                    break\n                o.write(s)\n                size = size - len(s)\n        o.close()\n\n        try:\n            try:\n                # fast\n                self.im = Image.core.open_ppm(outfile)\n            except:\n                # slightly slower\n                im = Image.open(outfile)\n                im.load()\n                self.im = im.im\n        finally:\n            try: os.unlink(outfile)\n            except: pass\n\n\nImage.register_open(\"IPTC\", IptcImageFile)\n\nImage.register_extension(\"IPTC\", \".iim\")\n\n##\n# Get IPTC information from TIFF, JPEG, or IPTC file.\n#\n# @param im An image containing IPTC data.\n# @return A dictionary containing IPTC information, or None if\n#     no IPTC information block was found.\n\ndef getiptcinfo(im):\n\n    from PIL import TiffImagePlugin, JpegImagePlugin\n    import io\n\n    data = None\n\n    if isinstance(im, IptcImageFile):\n        # return info dictionary right away\n        return im.info\n\n    elif isinstance(im, JpegImagePlugin.JpegImageFile):\n        # extract the IPTC/NAA resource\n        try:\n            app = im.app[\"APP13\"]\n            if app[:14] == \"Photoshop 3.0\\x00\":\n                app = app[14:]\n                # parse the image resource block\n                offset = 0\n                while app[offset:offset+4] == \"8BIM\":\n                    offset = offset + 4\n                    # resource code\n                    code = JpegImagePlugin.i16(app, offset)\n                    offset = offset + 2\n                    # resource name (usually empty)\n                    name_len = i8(app[offset])\n                    name = app[offset+1:offset+1+name_len]\n                    offset = 1 + offset + name_len\n                    if offset & 1:\n                        offset = offset + 1\n                    # resource data block\n                    size = JpegImagePlugin.i32(app, offset)\n                    offset = offset + 4\n                    if code == 0x0404:\n                        # 0x0404 contains IPTC/NAA data\n                        data = app[offset:offset+size]\n                        break\n                    offset = offset + size\n                    if offset & 1:\n                        offset = offset + 1\n        except (AttributeError, KeyError):\n            pass\n\n    elif isinstance(im, TiffImagePlugin.TiffImageFile):\n        # get raw data from the IPTC/NAA tag (PhotoShop tags the data\n        # as 4-byte integers, so we cannot use the get method...)\n        try:\n            data = im.tag.tagdata[TiffImagePlugin.IPTC_NAA_CHUNK]\n        except (AttributeError, KeyError):\n            pass\n\n    if data is None:\n        return None # no properties\n\n    # create an IptcImagePlugin object without initializing it\n    class FakeImage:\n        pass\n    im = FakeImage()\n    im.__class__ = IptcImageFile\n\n    # parse the IPTC information chunk\n    im.info = {}\n    im.fp = io.BytesIO(data)\n\n    try:\n        im._open()\n    except (IndexError, KeyError):\n        pass # expected failure\n\n    return im.info\n", "#\n# The Python Imaging Library.\n# $Id$\n#\n# JPEG (JFIF) file handling\n#\n# See \"Digital Compression and Coding of Continous-Tone Still Images,\n# Part 1, Requirements and Guidelines\" (CCITT T.81 / ISO 10918-1)\n#\n# History:\n# 1995-09-09 fl   Created\n# 1995-09-13 fl   Added full parser\n# 1996-03-25 fl   Added hack to use the IJG command line utilities\n# 1996-05-05 fl   Workaround Photoshop 2.5 CMYK polarity bug\n# 1996-05-28 fl   Added draft support, JFIF version (0.1)\n# 1996-12-30 fl   Added encoder options, added progression property (0.2)\n# 1997-08-27 fl   Save mode 1 images as BW (0.3)\n# 1998-07-12 fl   Added YCbCr to draft and save methods (0.4)\n# 1998-10-19 fl   Don't hang on files using 16-bit DQT's (0.4.1)\n# 2001-04-16 fl   Extract DPI settings from JFIF files (0.4.2)\n# 2002-07-01 fl   Skip pad bytes before markers; identify Exif files (0.4.3)\n# 2003-04-25 fl   Added experimental EXIF decoder (0.5)\n# 2003-06-06 fl   Added experimental EXIF GPSinfo decoder\n# 2003-09-13 fl   Extract COM markers\n# 2009-09-06 fl   Added icc_profile support (from Florian Hoech)\n# 2009-03-06 fl   Changed CMYK handling; always use Adobe polarity (0.6)\n# 2009-03-08 fl   Added subsampling support (from Justin Huff).\n#\n# Copyright (c) 1997-2003 by Secret Labs AB.\n# Copyright (c) 1995-1996 by Fredrik Lundh.\n#\n# See the README file for information on usage and redistribution.\n#\n\n__version__ = \"0.6\"\n\nimport array, struct\nfrom PIL import Image, ImageFile, _binary\nfrom PIL.JpegPresets import presets\nfrom PIL._util import isStringType\n\ni8 = _binary.i8\no8 = _binary.o8\ni16 = _binary.i16be\ni32 = _binary.i32be\n\n#\n# Parser\n\ndef Skip(self, marker):\n    n = i16(self.fp.read(2))-2\n    ImageFile._safe_read(self.fp, n)\n\ndef APP(self, marker):\n    #\n    # Application marker.  Store these in the APP dictionary.\n    # Also look for well-known application markers.\n\n    n = i16(self.fp.read(2))-2\n    s = ImageFile._safe_read(self.fp, n)\n\n    app = \"APP%d\" % (marker&15)\n\n    self.app[app] = s # compatibility\n    self.applist.append((app, s))\n\n    if marker == 0xFFE0 and s[:4] == b\"JFIF\":\n        # extract JFIF information\n        self.info[\"jfif\"] = version = i16(s, 5) # version\n        self.info[\"jfif_version\"] = divmod(version, 256)\n        # extract JFIF properties\n        try:\n            jfif_unit = i8(s[7])\n            jfif_density = i16(s, 8), i16(s, 10)\n        except:\n            pass\n        else:\n            if jfif_unit == 1:\n                self.info[\"dpi\"] = jfif_density\n            self.info[\"jfif_unit\"] = jfif_unit\n            self.info[\"jfif_density\"] = jfif_density\n    elif marker == 0xFFE1 and s[:5] == b\"Exif\\0\":\n        # extract Exif information (incomplete)\n        self.info[\"exif\"] = s # FIXME: value will change\n    elif marker == 0xFFE2 and s[:5] == b\"FPXR\\0\":\n        # extract FlashPix information (incomplete)\n        self.info[\"flashpix\"] = s # FIXME: value will change\n    elif marker == 0xFFE2 and s[:12] == b\"ICC_PROFILE\\0\":\n        # Since an ICC profile can be larger than the maximum size of\n        # a JPEG marker (64K), we need provisions to split it into\n        # multiple markers. The format defined by the ICC specifies\n        # one or more APP2 markers containing the following data:\n        #   Identifying string      ASCII \"ICC_PROFILE\\0\"  (12 bytes)\n        #   Marker sequence number  1, 2, etc (1 byte)\n        #   Number of markers       Total of APP2's used (1 byte)\n        #   Profile data            (remainder of APP2 data)\n        # Decoders should use the marker sequence numbers to\n        # reassemble the profile, rather than assuming that the APP2\n        # markers appear in the correct sequence.\n        self.icclist.append(s)\n    elif marker == 0xFFEE and s[:5] == b\"Adobe\":\n        self.info[\"adobe\"] = i16(s, 5)\n        # extract Adobe custom properties\n        try:\n            adobe_transform = i8(s[1])\n        except:\n            pass\n        else:\n            self.info[\"adobe_transform\"] = adobe_transform\n\ndef COM(self, marker):\n    #\n    # Comment marker.  Store these in the APP dictionary.\n\n    n = i16(self.fp.read(2))-2\n    s = ImageFile._safe_read(self.fp, n)\n\n    self.app[\"COM\"] = s # compatibility\n    self.applist.append((\"COM\", s))\n\ndef SOF(self, marker):\n    #\n    # Start of frame marker.  Defines the size and mode of the\n    # image.  JPEG is colour blind, so we use some simple\n    # heuristics to map the number of layers to an appropriate\n    # mode.  Note that this could be made a bit brighter, by\n    # looking for JFIF and Adobe APP markers.\n\n    n = i16(self.fp.read(2))-2\n    s = ImageFile._safe_read(self.fp, n)\n    self.size = i16(s[3:]), i16(s[1:])\n\n    self.bits = i8(s[0])\n    if self.bits != 8:\n        raise SyntaxError(\"cannot handle %d-bit layers\" % self.bits)\n\n    self.layers = i8(s[5])\n    if self.layers == 1:\n        self.mode = \"L\"\n    elif self.layers == 3:\n        self.mode = \"RGB\"\n    elif self.layers == 4:\n        self.mode = \"CMYK\"\n    else:\n        raise SyntaxError(\"cannot handle %d-layer images\" % self.layers)\n\n    if marker in [0xFFC2, 0xFFC6, 0xFFCA, 0xFFCE]:\n        self.info[\"progressive\"] = self.info[\"progression\"] = 1\n\n    if self.icclist:\n        # fixup icc profile\n        self.icclist.sort() # sort by sequence number\n        if i8(self.icclist[0][13]) == len(self.icclist):\n            profile = []\n            for p in self.icclist:\n                profile.append(p[14:])\n            icc_profile = b\"\".join(profile)\n        else:\n            icc_profile = None # wrong number of fragments\n        self.info[\"icc_profile\"] = icc_profile\n        self.icclist = None\n\n    for i in range(6, len(s), 3):\n        t = s[i:i+3]\n        # 4-tuples: id, vsamp, hsamp, qtable\n        self.layer.append((t[0], i8(t[1])//16, i8(t[1])&15, i8(t[2])))\n\ndef DQT(self, marker):\n    #\n    # Define quantization table.  Support baseline 8-bit tables\n    # only.  Note that there might be more than one table in\n    # each marker.\n\n    # FIXME: The quantization tables can be used to estimate the\n    # compression quality.\n\n    n = i16(self.fp.read(2))-2\n    s = ImageFile._safe_read(self.fp, n)\n    while len(s):\n        if len(s) < 65:\n            raise SyntaxError(\"bad quantization table marker\")\n        v = i8(s[0])\n        if v//16 == 0:\n            self.quantization[v&15] = array.array(\"b\", s[1:65])\n            s = s[65:]\n        else:\n            return # FIXME: add code to read 16-bit tables!\n            # raise SyntaxError, \"bad quantization table element size\"\n\n\n#\n# JPEG marker table\n\nMARKER = {\n    0xFFC0: (\"SOF0\", \"Baseline DCT\", SOF),\n    0xFFC1: (\"SOF1\", \"Extended Sequential DCT\", SOF),\n    0xFFC2: (\"SOF2\", \"Progressive DCT\", SOF),\n    0xFFC3: (\"SOF3\", \"Spatial lossless\", SOF),\n    0xFFC4: (\"DHT\", \"Define Huffman table\", Skip),\n    0xFFC5: (\"SOF5\", \"Differential sequential DCT\", SOF),\n    0xFFC6: (\"SOF6\", \"Differential progressive DCT\", SOF),\n    0xFFC7: (\"SOF7\", \"Differential spatial\", SOF),\n    0xFFC8: (\"JPG\", \"Extension\", None),\n    0xFFC9: (\"SOF9\", \"Extended sequential DCT (AC)\", SOF),\n    0xFFCA: (\"SOF10\", \"Progressive DCT (AC)\", SOF),\n    0xFFCB: (\"SOF11\", \"Spatial lossless DCT (AC)\", SOF),\n    0xFFCC: (\"DAC\", \"Define arithmetic coding conditioning\", Skip),\n    0xFFCD: (\"SOF13\", \"Differential sequential DCT (AC)\", SOF),\n    0xFFCE: (\"SOF14\", \"Differential progressive DCT (AC)\", SOF),\n    0xFFCF: (\"SOF15\", \"Differential spatial (AC)\", SOF),\n    0xFFD0: (\"RST0\", \"Restart 0\", None),\n    0xFFD1: (\"RST1\", \"Restart 1\", None),\n    0xFFD2: (\"RST2\", \"Restart 2\", None),\n    0xFFD3: (\"RST3\", \"Restart 3\", None),\n    0xFFD4: (\"RST4\", \"Restart 4\", None),\n    0xFFD5: (\"RST5\", \"Restart 5\", None),\n    0xFFD6: (\"RST6\", \"Restart 6\", None),\n    0xFFD7: (\"RST7\", \"Restart 7\", None),\n    0xFFD8: (\"SOI\", \"Start of image\", None),\n    0xFFD9: (\"EOI\", \"End of image\", None),\n    0xFFDA: (\"SOS\", \"Start of scan\", Skip),\n    0xFFDB: (\"DQT\", \"Define quantization table\", DQT),\n    0xFFDC: (\"DNL\", \"Define number of lines\", Skip),\n    0xFFDD: (\"DRI\", \"Define restart interval\", Skip),\n    0xFFDE: (\"DHP\", \"Define hierarchical progression\", SOF),\n    0xFFDF: (\"EXP\", \"Expand reference component\", Skip),\n    0xFFE0: (\"APP0\", \"Application segment 0\", APP),\n    0xFFE1: (\"APP1\", \"Application segment 1\", APP),\n    0xFFE2: (\"APP2\", \"Application segment 2\", APP),\n    0xFFE3: (\"APP3\", \"Application segment 3\", APP),\n    0xFFE4: (\"APP4\", \"Application segment 4\", APP),\n    0xFFE5: (\"APP5\", \"Application segment 5\", APP),\n    0xFFE6: (\"APP6\", \"Application segment 6\", APP),\n    0xFFE7: (\"APP7\", \"Application segment 7\", APP),\n    0xFFE8: (\"APP8\", \"Application segment 8\", APP),\n    0xFFE9: (\"APP9\", \"Application segment 9\", APP),\n    0xFFEA: (\"APP10\", \"Application segment 10\", APP),\n    0xFFEB: (\"APP11\", \"Application segment 11\", APP),\n    0xFFEC: (\"APP12\", \"Application segment 12\", APP),\n    0xFFED: (\"APP13\", \"Application segment 13\", APP),\n    0xFFEE: (\"APP14\", \"Application segment 14\", APP),\n    0xFFEF: (\"APP15\", \"Application segment 15\", APP),\n    0xFFF0: (\"JPG0\", \"Extension 0\", None),\n    0xFFF1: (\"JPG1\", \"Extension 1\", None),\n    0xFFF2: (\"JPG2\", \"Extension 2\", None),\n    0xFFF3: (\"JPG3\", \"Extension 3\", None),\n    0xFFF4: (\"JPG4\", \"Extension 4\", None),\n    0xFFF5: (\"JPG5\", \"Extension 5\", None),\n    0xFFF6: (\"JPG6\", \"Extension 6\", None),\n    0xFFF7: (\"JPG7\", \"Extension 7\", None),\n    0xFFF8: (\"JPG8\", \"Extension 8\", None),\n    0xFFF9: (\"JPG9\", \"Extension 9\", None),\n    0xFFFA: (\"JPG10\", \"Extension 10\", None),\n    0xFFFB: (\"JPG11\", \"Extension 11\", None),\n    0xFFFC: (\"JPG12\", \"Extension 12\", None),\n    0xFFFD: (\"JPG13\", \"Extension 13\", None),\n    0xFFFE: (\"COM\", \"Comment\", COM)\n}\n\n\ndef _accept(prefix):\n    return prefix[0:1] == b\"\\377\"\n\n##\n# Image plugin for JPEG and JFIF images.\n\nclass JpegImageFile(ImageFile.ImageFile):\n\n    format = \"JPEG\"\n    format_description = \"JPEG (ISO 10918)\"\n\n    def _open(self):\n\n        s = self.fp.read(1)\n\n        if i8(s[0]) != 255:\n            raise SyntaxError(\"not a JPEG file\")\n\n        # Create attributes\n        self.bits = self.layers = 0\n\n        # JPEG specifics (internal)\n        self.layer = []\n        self.huffman_dc = {}\n        self.huffman_ac = {}\n        self.quantization = {}\n        self.app = {} # compatibility\n        self.applist = []\n        self.icclist = []\n\n        while True:\n\n            s = s + self.fp.read(1)\n\n            i = i16(s)\n\n            if i in MARKER:\n                name, description, handler = MARKER[i]\n                # print hex(i), name, description\n                if handler is not None:\n                    handler(self, i)\n                if i == 0xFFDA: # start of scan\n                    rawmode = self.mode\n                    if self.mode == \"CMYK\":\n                        rawmode = \"CMYK;I\" # assume adobe conventions\n                    self.tile = [(\"jpeg\", (0,0) + self.size, 0, (rawmode, \"\"))]\n                    # self.__offset = self.fp.tell()\n                    break\n                s = self.fp.read(1)\n            elif i == 0 or i == 65535:\n                # padded marker or junk; move on\n                s = \"\\xff\"\n            else:\n                raise SyntaxError(\"no marker found\")\n\n    def draft(self, mode, size):\n\n        if len(self.tile) != 1:\n            return\n\n        d, e, o, a = self.tile[0]\n        scale = 0\n\n        if a[0] == \"RGB\" and mode in [\"L\", \"YCbCr\"]:\n            self.mode = mode\n            a = mode, \"\"\n\n        if size:\n            scale = max(self.size[0] // size[0], self.size[1] // size[1])\n            for s in [8, 4, 2, 1]:\n                if scale >= s:\n                    break\n            e = e[0], e[1], (e[2]-e[0]+s-1)//s+e[0], (e[3]-e[1]+s-1)//s+e[1]\n            self.size = ((self.size[0]+s-1)//s, (self.size[1]+s-1)//s)\n            scale = s\n\n        self.tile = [(d, e, o, a)]\n        self.decoderconfig = (scale, 1)\n\n        return self\n\n    def load_djpeg(self):\n\n        # ALTERNATIVE: handle JPEGs via the IJG command line utilities\n\n        import tempfile, os\n        f, path = tempfile.mkstemp()\n        os.close(f)\n        if os.path.exists(self.filename):\n            os.system(\"djpeg '%s' >'%s'\" % (self.filename, path))\n        else:\n            raise ValueError(\"Invalid Filename\")\n\n        try:\n            self.im = Image.core.open_ppm(path)\n        finally:\n            try: os.unlink(path)\n            except: pass\n\n        self.mode = self.im.mode\n        self.size = self.im.size\n\n        self.tile = []\n\n    def _getexif(self):\n        return _getexif(self)\n\n\ndef _getexif(self):\n    # Extract EXIF information.  This method is highly experimental,\n    # and is likely to be replaced with something better in a future\n    # version.\n    from PIL import TiffImagePlugin\n    import io\n    def fixup(value):\n        if len(value) == 1:\n            return value[0]\n        return value\n    # The EXIF record consists of a TIFF file embedded in a JPEG\n    # application marker (!).\n    try:\n        data = self.info[\"exif\"]\n    except KeyError:\n        return None\n    file = io.BytesIO(data[6:])\n    head = file.read(8)\n    exif = {}\n    # process dictionary\n    info = TiffImagePlugin.ImageFileDirectory(head)\n    info.load(file)\n    for key, value in info.items():\n        exif[key] = fixup(value)\n    # get exif extension\n    try:\n        file.seek(exif[0x8769])\n    except KeyError:\n        pass\n    else:\n        info = TiffImagePlugin.ImageFileDirectory(head)\n        info.load(file)\n        for key, value in info.items():\n            exif[key] = fixup(value)\n    # get gpsinfo extension\n    try:\n        file.seek(exif[0x8825])\n    except KeyError:\n        pass\n    else:\n        info = TiffImagePlugin.ImageFileDirectory(head)\n        info.load(file)\n        exif[0x8825] = gps = {}\n        for key, value in info.items():\n            gps[key] = fixup(value)\n    return exif\n\n# --------------------------------------------------------------------\n# stuff to save JPEG files\n\nRAWMODE = {\n    \"1\": \"L\",\n    \"L\": \"L\",\n    \"RGB\": \"RGB\",\n    \"RGBA\": \"RGB\",\n    \"RGBX\": \"RGB\",\n    \"CMYK\": \"CMYK;I\", # assume adobe conventions\n    \"YCbCr\": \"YCbCr\",\n}\n\nzigzag_index = ( 0,  1,  5,  6, 14, 15, 27, 28,\n                 2,  4,  7, 13, 16, 26, 29, 42,\n                 3,  8, 12, 17, 25, 30, 41, 43,\n                 9, 11, 18, 24, 31, 40, 44, 53,\n                10, 19, 23, 32, 39, 45, 52, 54,\n                20, 22, 33, 38, 46, 51, 55, 60,\n                21, 34, 37, 47, 50, 56, 59, 61,\n                35, 36, 48, 49, 57, 58, 62, 63)\n\nsamplings = {\n             (1, 1, 1, 1, 1, 1): 0,\n             (2, 1, 1, 1, 1, 1): 1,\n             (2, 2, 1, 1, 1, 1): 2,\n            }\n\ndef convert_dict_qtables(qtables):\n    qtables = [qtables[key] for key in xrange(len(qtables)) if qtables.has_key(key)]\n    for idx, table in enumerate(qtables):\n        qtables[idx] = [table[i] for i in zigzag_index]\n    return qtables\n\ndef get_sampling(im):\n    sampling = im.layer[0][1:3] + im.layer[1][1:3] + im.layer[2][1:3]\n    return samplings.get(sampling, -1)\n\ndef _save(im, fp, filename):\n\n    try:\n        rawmode = RAWMODE[im.mode]\n    except KeyError:\n        raise IOError(\"cannot write mode %s as JPEG\" % im.mode)\n\n    info = im.encoderinfo\n\n    dpi = info.get(\"dpi\", (0, 0))\n\n    quality = info.get(\"quality\", 0)\n    subsampling = info.get(\"subsampling\", -1)\n    qtables = info.get(\"qtables\")\n\n    if quality == \"keep\":\n        quality = 0\n        subsampling = \"keep\"\n        qtables = \"keep\"\n    elif quality in presets:\n        preset = presets[quality]\n        quality = 0\n        subsampling = preset.get('subsampling', -1)\n        qtables = preset.get('quantization')\n    elif not isinstance(quality, int):\n        raise ValueError(\"Invalid quality setting\")\n    else:\n        if subsampling in presets:\n            subsampling = presets[subsampling].get('subsampling', -1)\n        if qtables in presets:\n            qtables = presets[qtables].get('quantization')\n\n    if subsampling == \"4:4:4\":\n        subsampling = 0\n    elif subsampling == \"4:2:2\":\n        subsampling = 1\n    elif subsampling == \"4:1:1\":\n        subsampling = 2\n    elif subsampling == \"keep\":\n        if im.format != \"JPEG\":\n            raise ValueError(\"Cannot use 'keep' when original image is not a JPEG\")\n        subsampling = get_sampling(im)\n\n    def validate_qtables(qtables):\n        if qtables is None:\n            return qtables\n        if isStringType(qtables):\n            try:\n                lines = [int(num) for line in qtables.splitlines()\n                         for num in line.split('#', 1)[0].split()]\n            except ValueError:\n                raise ValueError(\"Invalid quantization table\")\n            else:\n                qtables = [lines[s:s+64] for s in xrange(0, len(lines), 64)]\n        if isinstance(qtables, (tuple, list, dict)):\n            if isinstance(qtables, dict):\n                qtables = convert_dict_qtables(qtables)\n            elif isinstance(qtables, tuple):\n                qtables = list(qtables)\n            if not (0 < len(qtables) < 5):\n                raise ValueError(\"None or too many quantization tables\")\n            for idx, table in enumerate(qtables):\n                try:\n                    if len(table) != 64:\n                        raise\n                    table = array.array('b', table)\n                except TypeError:\n                    raise ValueError(\"Invalid quantization table\")\n                else:\n                    qtables[idx] = list(table)\n            return qtables\n\n    if qtables == \"keep\":\n        if im.format != \"JPEG\":\n            raise ValueError(\"Cannot use 'keep' when original image is not a JPEG\")\n        qtables = getattr(im, \"quantization\", None)\n    qtables = validate_qtables(qtables)\n\n    extra = b\"\"\n\n    icc_profile = info.get(\"icc_profile\")\n    if icc_profile:\n        ICC_OVERHEAD_LEN = 14\n        MAX_BYTES_IN_MARKER = 65533\n        MAX_DATA_BYTES_IN_MARKER = MAX_BYTES_IN_MARKER - ICC_OVERHEAD_LEN\n        markers = []\n        while icc_profile:\n            markers.append(icc_profile[:MAX_DATA_BYTES_IN_MARKER])\n            icc_profile = icc_profile[MAX_DATA_BYTES_IN_MARKER:]\n        i = 1\n        for marker in markers:\n            size = struct.pack(\">H\", 2 + ICC_OVERHEAD_LEN + len(marker))\n            extra = extra + (b\"\\xFF\\xE2\" + size + b\"ICC_PROFILE\\0\" + o8(i) + o8(len(markers)) + marker)\n            i = i + 1\n\n    # get keyword arguments\n    im.encoderconfig = (\n        quality,\n        # \"progressive\" is the official name, but older documentation\n        # says \"progression\"\n        # FIXME: issue a warning if the wrong form is used (post-1.1.7)\n        \"progressive\" in info or \"progression\" in info,\n        info.get(\"smooth\", 0),\n        \"optimize\" in info,\n        info.get(\"streamtype\", 0),\n        dpi[0], dpi[1],\n        subsampling,\n        qtables,\n        extra,\n        info.get(\"exif\", b\"\")\n        )\n\n\n    # if we optimize, libjpeg needs a buffer big enough to hold the whole image in a shot.\n    # Guessing on the size, at im.size bytes. (raw pizel size is channels*size, this\n    # is a value that's been used in a django patch.\n    # https://github.com/jdriscoll/django-imagekit/issues/50\n    bufsize=0\n    if \"optimize\" in info or \"progressive\" in info or \"progression\" in info:\n        bufsize = im.size[0]*im.size[1]\n\n    # The exif info needs to be written as one block, + APP1, + one spare byte.\n    # Ensure that our buffer is big enough\n    bufsize = max(ImageFile.MAXBLOCK, bufsize, len(info.get(\"exif\",b\"\")) + 5 )\n\n    ImageFile._save(im, fp, [(\"jpeg\", (0,0)+im.size, 0, rawmode)], bufsize)\n\ndef _save_cjpeg(im, fp, filename):\n    # ALTERNATIVE: handle JPEGs via the IJG command line utilities.\n    import os\n    file = im._dump()\n    os.system(\"cjpeg %s >%s\" % (file, filename))\n    try: os.unlink(file)\n    except: pass\n\n# -------------------------------------------------------------------q-\n# Registry stuff\n\nImage.register_open(\"JPEG\", JpegImageFile, _accept)\nImage.register_save(\"JPEG\", _save)\n\nImage.register_extension(\"JPEG\", \".jfif\")\nImage.register_extension(\"JPEG\", \".jpe\")\nImage.register_extension(\"JPEG\", \".jpg\")\nImage.register_extension(\"JPEG\", \".jpeg\")\n\nImage.register_mime(\"JPEG\", \"image/jpeg\")\n"], "filenames": ["PIL/EpsImagePlugin.py", "PIL/Image.py", "PIL/IptcImagePlugin.py", "PIL/JpegImagePlugin.py"], "buggy_code_start_loc": [70, 498, 175, 347], "buggy_code_end_loc": [71, 506, 177, 354], "fixing_code_start_loc": [70, 498, 175, 347], "fixing_code_end_loc": [72, 509, 177, 358], "type": "CWE-264", "message": "The (1) JpegImagePlugin.py and (2) EpsImagePlugin.py scripts in Python Image Library (PIL) 1.1.7 and earlier and Pillow before 2.3.1 uses the names of temporary files on the command line, which makes it easier for local users to conduct symlink attacks by listing the processes.", "other": {"cve": {"id": "CVE-2014-1933", "sourceIdentifier": "cve@mitre.org", "published": "2014-04-17T14:55:11.120", "lastModified": "2017-07-01T01:29:05.687", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The (1) JpegImagePlugin.py and (2) EpsImagePlugin.py scripts in Python Image Library (PIL) 1.1.7 and earlier and Pillow before 2.3.1 uses the names of temporary files on the command line, which makes it easier for local users to conduct symlink attacks by listing the processes."}, {"lang": "es", "value": "Los scripts (1) JpegImagePlugin.py y (2) EpsImagePlugin.py en Python Image Library (PIL) 1.1.7 y anteriores y Pillow anterior a 2.3.1 utiliza los nombres de archivos temporales en la l\u00ednea de comando, lo que facilita a usuarios locales realizar ataques symlink mediante el listado de los procesos."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-264"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:python:pillow:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.3.0", "matchCriteriaId": "A1BAE1A0-BC57-4410-83DD-DB85B992398A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:pythonware:python_imaging_library:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.1.7", "matchCriteriaId": "C0BFFC56-855D-49E5-A4FD-7AA2D68F5B5C"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-updates/2014-05/msg00002.html", "source": "cve@mitre.org"}, {"url": "http://www.openwall.com/lists/oss-security/2014/02/10/15", "source": "cve@mitre.org"}, {"url": "http://www.openwall.com/lists/oss-security/2014/02/11/1", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/65513", "source": "cve@mitre.org"}, {"url": "http://www.ubuntu.com/usn/USN-2168-1", "source": "cve@mitre.org"}, {"url": "https://github.com/python-imaging/Pillow/commit/4e9f367dfd3f04c8f5d23f7f759ec12782e10ee7", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}, {"url": "https://security.gentoo.org/glsa/201612-52", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/python-imaging/Pillow/commit/4e9f367dfd3f04c8f5d23f7f759ec12782e10ee7"}}