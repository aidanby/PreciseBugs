{"buggy_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.xml.html;\n\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.jdom.DocType;\nimport org.jdom.Element;\nimport org.jdom.input.DOMBuilder;\nimport org.jdom.output.Format;\nimport org.jdom.output.XMLOutputter;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xwiki.xml.XMLUtils;\n\n/**\n * HTML Utility methods.\n *\n * @version $Id$\n * @since 1.8.3\n */\n// TODO: Create a separate class for each HTML version (XHTML 1.0, HTML5, etc...)\npublic final class HTMLUtils\n{\n    /**\n     * In HTML5, some elements must be expanded (for example {@code <span></span>} instead of {@code <span />}), and\n     * some others must not (for example {@code <br />} instead of {@code <br></br>}. Thus for the list of elements\n     * below we need special handling (not expanding).\n     */\n    private static final List<String> OMIT_ELEMENT_EXPANDING_SET = Arrays.asList(\n        \"area\", \"base\", \"br\", \"col\", \"hr\", \"img\", \"input\", \"link\", \"meta\", \"param\");\n\n    /**\n     * JDOM's XMLOutputter class converts reserved XML character ({@code &}) into its entity\n     * format {@code &amp;}. However since we're using HTML Cleaner\n     * (http://htmlcleaner.sourceforge.net/) and since it's buggy for unicode character escapes we have turned off\n     * character escaping for it and thus we need to perform selective escaping here.\n     * <p>\n     * Moreover, since we support HTML5, we need to\n     * expand empty elements on some elements and not on the others. For example: {@code <span></span>} is valid\n     * meanwhile:\n     * <pre>{@code\n     * <br>\n     * </br>}</pre>\n     * is not. See {@code OMIT_ELEMENT_EXPANDING_SET} for the list of elements to not expand.\n     */\n    // TODO: Remove the complex escaping code when SF HTML Cleaner will do proper escaping\n    public static class XWikiXMLOutputter extends XMLOutputter\n    {\n        /**\n         * Regex for a character reference as defined in:\n         * https://www.w3.org/TR/WD-xml-lang-970630#dt-charref.\n         */\n        private static final String CHARACTER_REFERENCE = \"&amp;#[0-9]+;|&amp;#x[0-9a-fA-F]+;\";\n\n        /**\n         * Regex to recognize a character reference Entity.\n         */\n        private static final Pattern CHARACTER_REFERENCE_PATTERN = Pattern.compile(CHARACTER_REFERENCE);\n\n        /**\n         * Escaped ampersand character.\n         */\n        private static final String AMPERSAND = \"&amp;\";\n\n        /**\n         * Whether to omit the document type when printing the W3C Document or not.\n         */\n        private boolean omitDocType;\n\n        /**\n         * @param format the JDOM class used to control output formats, see {@link org.jdom.output.Format}\n         * @param omitDocType if true then omit the document type when printing the W3C Document\n         * @see XMLOutputter#XMLOutputter(Format)\n         */\n        public XWikiXMLOutputter(Format format, boolean omitDocType)\n        {\n            super(format);\n            this.omitDocType = omitDocType;\n        }\n\n        @Override\n        public String escapeElementEntities(String text)\n        {\n            String result = super.escapeElementEntities(text);\n\n            // \"\\r\" characters are automatically transformed in &#xD; but we want to keep the original \\r there.\n            return cleanAmpersandEscape(result).replaceAll(\"&#xD;\", \"\\r\");\n        }\n\n        @Override\n        public String escapeAttributeEntities(String text)\n        {\n            String result = super.escapeAttributeEntities(text);\n            return cleanAmpersandEscape(result);\n        }\n\n        /**\n         * Remove ampersand escapes when it's not needed (i.e. on character entities).\n         *\n         * @param text the text escaped.\n         * @return the text cleaned\n         */\n        private String cleanAmpersandEscape(String text)\n        {\n            StringBuilder buffer = new StringBuilder(text);\n            // find all occurrences of &\n            int pos = buffer.indexOf(AMPERSAND);\n            while (pos > -1 && pos < buffer.length()) {\n                // Check if the & is a character entity\n                Matcher matcher = CHARACTER_REFERENCE_PATTERN.matcher(buffer.substring(pos));\n                if (matcher.lookingAt()) {\n                    // We've found an entity, replace the \"&amp;\" by a single \"&\"\n                    buffer.replace(pos, pos + 5, \"&\");\n\n                    // We have replaced 4 characters in the buffer so let's move the position back\n                    pos = pos + matcher.end() - matcher.start() - 4;\n                } else {\n                    // don't do anything, just move on.\n                    pos += 5;\n                }\n                pos = buffer.indexOf(AMPERSAND, pos);\n            }\n            return buffer.toString();\n        }\n\n        @Override\n        protected void printDocType(Writer out, DocType docType) throws IOException\n        {\n            if (!this.omitDocType) {\n                super.printDocType(out, docType);\n            }\n        }\n\n        @Override\n        protected void printElement(Writer out, Element element, int level, NamespaceStack namespaces)\n            throws IOException\n        {\n            // We override the code from the super class to not expand some empty elements.\n            boolean currentFormatPolicy = currentFormat.getExpandEmptyElements();\n            try {\n                String elementName = element.getName();\n                for (String name : OMIT_ELEMENT_EXPANDING_SET) {\n                    if (name.equals(elementName)) {\n                        // We do not expand this empty element\n                        currentFormat.setExpandEmptyElements(false);\n                        break;\n                    }\n                }\n\n                // Call the method from the super class\n                super.printElement(out, element, level, namespaces);\n\n            } finally {\n                // Reset the format\n                currentFormat.setExpandEmptyElements(currentFormatPolicy);\n            }\n        }\n    }\n\n    /**\n     * Private constructor since this is a utility class that shouldn't be instantiated (all methods are static).\n     */\n    private HTMLUtils()\n    {\n        // Nothing to do\n    }\n\n    /**\n     * @param document the W3C Document to transform into a String\n     * @return the XML as a String\n     */\n    public static String toString(Document document)\n    {\n        return HTMLUtils.toString(document, false, false);\n    }\n\n    /**\n     * @param document the W3C Document to transform into a String\n     * @param omitDeclaration whether the XML declaration should be printed or not\n     * @param omitDoctype whether the document type should be printed or not\n     * @return the XML as a String\n     */\n    public static String toString(Document document, boolean omitDeclaration, boolean omitDoctype)\n    {\n        // Note: We don't use javax.xml.transform.Transformer since it prints our valid XHTML as HTML which is not\n        // XHTML compliant. For example it transforms our \"<hr/>\" into \"<hr>.\n        DOMBuilder builder = new DOMBuilder();\n        org.jdom.Document jdomDoc = builder.build(document);\n\n        Format format = Format.getRawFormat();\n        // Force newlines to use \\n since otherwise the default is \\n\\r.\n        // See http://www.jdom.org/docs/apidocs/org/jdom/output/Format.html#setLineSeparator(java.lang.String)\n        format.setLineSeparator(\"\\n\");\n\n        // Make sure all elements are expanded so that they can also be rendered fine in browsers that only support\n        // HTML.\n        format.setExpandEmptyElements(true);\n\n        format.setOmitDeclaration(omitDeclaration);\n\n        XMLOutputter outputter = new XWikiXMLOutputter(format, omitDoctype);\n\n        return outputter.outputString(jdomDoc);\n    }\n\n    /**\n     * Strip the HTML envelope if it exists. Precisely this means removing the head tag and move all tags in the body\n     * tag directly under the html element. This is useful for example if you wish to insert an HTML fragment into an\n     * existing HTML page.\n     *\n     * @param document the w3c Document to strip\n     */\n    public static void stripHTMLEnvelope(Document document)\n    {\n        org.w3c.dom.Element root = document.getDocumentElement();\n        if (root.getNodeName().equalsIgnoreCase(HTMLConstants.TAG_HTML)) {\n            // Look for a head element below the root element and for a body element\n            Node bodyNode = null;\n            Node headNode = null;\n            NodeList nodes = root.getChildNodes();\n            for (int i = 0; i < nodes.getLength(); i++) {\n                Node node = nodes.item(i);\n                if (node.getNodeName().equalsIgnoreCase(HTMLConstants.TAG_HEAD)) {\n                    headNode = node;\n                } else if (node.getNodeName().equalsIgnoreCase(HTMLConstants.TAG_BODY)) {\n                    bodyNode = node;\n                }\n            }\n\n            if (headNode != null) {\n                root.removeChild(headNode);\n            }\n\n            if (bodyNode != null) {\n                // Move all children of body node under the root element\n                NodeList bodyChildrenNodes = bodyNode.getChildNodes();\n                while (bodyChildrenNodes.getLength() > 0) {\n                    root.insertBefore(bodyChildrenNodes.item(0), null);\n                }\n                root.removeChild(bodyNode);\n            }\n        }\n    }\n\n    /**\n     * Remove the first element inside a parent element and copy the element's children in the parent.\n     *\n     * @param document the w3c document from which to remove the top level paragraph\n     * @param parentTagName the name of the parent tag to look under\n     * @param elementTagName the name of the first element to remove\n     */\n    public static void stripFirstElementInside(Document document, String parentTagName, String elementTagName)\n    {\n        NodeList parentNodes = document.getElementsByTagName(parentTagName);\n        if (parentNodes.getLength() > 0) {\n            Node parentNode = parentNodes.item(0);\n            // Look for a p element below the first parent element\n            Node pNode = parentNode.getFirstChild();\n            if (elementTagName.equalsIgnoreCase(pNode.getNodeName())) {\n                // Move all children of p node under the root element\n                NodeList pChildrenNodes = pNode.getChildNodes();\n                while (pChildrenNodes.getLength() > 0) {\n                    parentNode.insertBefore(pChildrenNodes.item(0), null);\n                }\n                parentNode.removeChild(pNode);\n            }\n        }\n    }\n\n    /**\n     * Escapes HTML special characters in a {@code String} using numerical HTML entities, so that the resulting string\n     * can safely be used as an HTML content text value.\n     * For instance, {@code Jim & John} will be escaped and can thus be put inside a HTML tag, such as the {@code p}\n     * tag, as in {@code <p>Jim &amp; John</p>}.\n     * Specifically, escapes &lt; to {@code &lt;}, and &amp; to {@code &amp;}.\n     *\n     * @param content the text to escape, may be {@code null}.\n     * @return a new escaped {@code String}, {@code null} if {@code null} input\n     * @since 12.8RC1\n     * @since 12.6.3\n     * @since 11.10.11\n     */\n    public static String escapeElementText(String content)\n    {\n        return XMLUtils.escapeElementText(content);\n    }\n\n    /**\n     * Same logic as {@link #escapeElementText(String)} but only indicates if there is something to escape.\n     * \n     * @param content the content to parse\n     * @return true if the passed content contains content that can be interpreted as HTML syntax\n     * @see #escapeElementText(String)\n     * @since 12.10\n     * @since 12.6.5\n     */\n    public static boolean containsElementText(CharSequence content)\n    {\n        return XMLUtils.containsElementText(content);\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.xml.internal.html;\n\nimport java.io.Reader;\nimport java.util.Arrays;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Singleton;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.htmlcleaner.CleanerProperties;\nimport org.htmlcleaner.DoctypeToken;\nimport org.htmlcleaner.HtmlCleaner;\nimport org.htmlcleaner.TagNode;\nimport org.htmlcleaner.TagTransformation;\nimport org.htmlcleaner.TrimAttributeTagTransformation;\nimport org.htmlcleaner.XWikiDOMSerializer;\nimport org.w3c.dom.Document;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.context.Execution;\nimport org.xwiki.context.ExecutionContext;\nimport org.xwiki.xml.html.HTMLCleaner;\nimport org.xwiki.xml.html.HTMLCleanerConfiguration;\nimport org.xwiki.xml.html.HTMLConstants;\nimport org.xwiki.xml.html.filter.HTMLFilter;\n\n/**\n * Default implementation for {@link org.xwiki.xml.html.HTMLCleaner} using the <a href=\"HTML Cleaner\n * framework>http://htmlcleaner.sourceforge.net/</a>.\n *\n * @version $Id$\n * @since 1.6M1\n */\n@Component\n@Singleton\npublic class DefaultHTMLCleaner implements HTMLCleaner\n{\n    /**\n     * {@link HTMLFilter} for filtering html lists.\n     */\n    @Inject\n    @Named(\"list\")\n    private HTMLFilter listFilter;\n\n    /**\n     * {@link HTMLFilter} for filtering html lists.\n     */\n    @Inject\n    @Named(\"listitem\")\n    private HTMLFilter listItemFilter;\n\n    /**\n     * {@link HTMLFilter} for filtering HTML font elements.\n     */\n    @Inject\n    @Named(\"font\")\n    private HTMLFilter fontFilter;\n\n    /**\n     * {@link HTMLFilter} for wrapping invalid body elements with paragraphs.\n     */\n    @Inject\n    @Named(\"body\")\n    private HTMLFilter bodyFilter;\n\n    /**\n     * {@link HTMLFilter} for filtering HTML attributes that are used by many different elements and for which we cannot\n     * write simple transformations like in {@link #getDefaultCleanerTransformations(HTMLCleanerConfiguration)}.\n     */\n    @Inject\n    @Named(\"attribute\")\n    private HTMLFilter attributeFilter;\n\n    /**\n     * {@link HTMLFilter} for filtering HTML links.\n     */\n    @Inject\n    @Named(\"link\")\n    private HTMLFilter linkFilter;\n\n    /**\n     * Remove control characters.\n     */\n    @Inject\n    @Named(\"controlcharacters\")\n    // TODO: remove when upgrading to HTMLClener 2.23\n    private HTMLFilter controlFilter;\n\n    @Inject\n    @Named(\"sanitizer\")\n    private HTMLFilter sanitizerFilter;\n\n    @Inject\n    private Execution execution;\n\n    @Inject\n    private XWikiHTML5TagProvider html5TagInfoProvider;\n\n    @Override\n    public Document clean(Reader originalHtmlContent)\n    {\n        return clean(originalHtmlContent, getDefaultConfiguration());\n    }\n\n    private DocumentBuilder getAvailableDocumentBuilder() throws ParserConfigurationException\n    {\n        ExecutionContext econtext = this.execution.getContext();\n\n        if (econtext != null) {\n            DocumentBuilder documentBuilder = (DocumentBuilder) econtext.getProperty(DocumentBuilder.class.getName());\n\n            if (documentBuilder == null) {\n                documentBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n                econtext.setProperty(DocumentBuilder.class.getName(), documentBuilder);\n            }\n\n            return documentBuilder;\n        }\n\n        return DocumentBuilderFactory.newInstance().newDocumentBuilder();\n    }\n\n    @Override\n    public Document clean(Reader originalHtmlContent, HTMLCleanerConfiguration configuration)\n    {\n        Document result;\n\n        // Note: Instantiation of an HtmlCleaner object is cheap so there's no need to cache an instance of it,\n        // especially since this makes it extra safe with regards to multithreading (even though HTML Cleaner is\n        // already supposed to be thread safe).\n        CleanerProperties cleanerProperties = getDefaultCleanerProperties(configuration);\n        HtmlCleaner cleaner;\n        if (isHTML5(configuration)) {\n            // Use our custom provider to fix bugs, should be checked on each upgrade if still necessary.\n            cleaner = new HtmlCleaner(this.html5TagInfoProvider, cleanerProperties);\n        }  else {\n            cleaner = new HtmlCleaner(cleanerProperties);\n        }\n\n        TagNode cleanedNode;\n        try {\n            cleanedNode = cleaner.clean(originalHtmlContent);\n        } catch (Exception e) {\n            // This shouldn't happen since we're not doing any IO... I consider this a flaw in the design of HTML\n            // Cleaner.\n            throw new RuntimeException(\"Unhandled error when cleaning HTML\", e);\n        }\n\n        try {\n            // Ideally we would use SF's HTMLCleaner DomSerializer but there are outstanding issues with it, so we're\n            // using a custom XWikiDOMSerializer (see its javadoc for more details).\n            // Replace by the following when fixed:\n            //   result = new DomSerializer(cleanerProperties, false).createDOM(cleanedNode);\n\n            if (isHTML5(configuration)) {\n                cleanedNode.setDocType(new DoctypeToken(HTMLConstants.TAG_HTML, null, null, null));\n            } else {\n                cleanedNode.setDocType(\n                    new DoctypeToken(HTMLConstants.TAG_HTML, \"PUBLIC\", \"-//W3C//DTD XHTML 1.0 Strict//EN\",\n                        \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"));\n            }\n            result =\n                new XWikiDOMSerializer(cleanerProperties).createDOM(getAvailableDocumentBuilder(), cleanedNode);\n        } catch (ParserConfigurationException ex) {\n            throw new RuntimeException(\"Error while serializing TagNode into w3c dom.\", ex);\n        }\n\n        // Finally apply filters.\n        for (HTMLFilter filter : configuration.getFilters()) {\n            filter.filter(result, configuration.getParameters());\n        }\n\n        return result;\n    }\n\n    @Override\n    public HTMLCleanerConfiguration getDefaultConfiguration()\n    {\n        HTMLCleanerConfiguration configuration = new DefaultHTMLCleanerConfiguration();\n        configuration.setFilters(Arrays.asList(\n            this.controlFilter,\n            this.bodyFilter,\n            this.listItemFilter,\n            this.listFilter,\n            this.fontFilter,\n            this.attributeFilter,\n            this.linkFilter,\n            this.sanitizerFilter));\n        return configuration;\n    }\n\n    /**\n     * @param configuration the configuration to use for the cleaning\n     * @return the default {@link CleanerProperties} to be used for cleaning.\n     */\n    private CleanerProperties getDefaultCleanerProperties(HTMLCleanerConfiguration configuration)\n    {\n        CleanerProperties defaultProperties = new CleanerProperties();\n        defaultProperties.setOmitUnknownTags(true);\n\n        // HTML Cleaner uses the compact notation by default but we don't want that since:\n        // - it's more work and not required since not compact notation is valid XHTML\n        // - expanded elements can also be rendered fine in browsers that only support HTML.\n        defaultProperties.setUseEmptyElementTags(false);\n\n        // Wrap script and style content in CDATA blocks\n        defaultProperties.setUseCdataForScriptAndStyle(true);\n\n        // We need this for example to ignore CDATA sections not inside script or style elements.\n        defaultProperties.setIgnoreQuestAndExclam(true);\n\n        // Remove CDATA outside of script and style since according to the spec it has no effect there.\n        defaultProperties.setOmitCdataOutsideScriptAndStyle(true);\n\n        // If the caller has defined NAMESPACE_AWARE configuration property then use it, otherwise use our default.\n        String param = configuration.getParameters().get(HTMLCleanerConfiguration.NAMESPACES_AWARE);\n        boolean namespacesAware = (param == null) || Boolean.parseBoolean(param);\n        defaultProperties.setNamespacesAware(namespacesAware);\n\n        // Set Cleaner transformations\n        defaultProperties.setCleanerTransformations(getDefaultCleanerTransformations(configuration));\n\n        // Don't convert special HTML entities (i.e. &ocirc;, &permil;, &times;) with unicode characters they represent.\n        defaultProperties.setTranslateSpecialEntities(false);\n\n        // Use character references rather than entity references if needed (for instance if you need to parse the\n        // output as XML)\n        param = configuration.getParameters().get(HTMLCleanerConfiguration.USE_CHARACTER_REFERENCES);\n        boolean useCharacterReferences = (param != null) && Boolean.parseBoolean(param);\n        defaultProperties.setTransResCharsToNCR(useCharacterReferences);\n\n        // Sets the HTML version from the configuration (by default 4).\n        defaultProperties.setHtmlVersion(getHTMLVersion(configuration));\n\n        // We trim values by default for all attributes but the input value attribute.\n        // The only way to currently do that is to switch off this flag, and to create a dedicated TagTransformation.\n        // See TrimAttributeCleanerTransformation for more information.\n        defaultProperties.setTrimAttributeValues(false);\n\n        // This flag should be set to true once https://sourceforge.net/p/htmlcleaner/bugs/221/ is fixed.\n        defaultProperties.setRecognizeUnicodeChars(false);\n\n        param = configuration.getParameters().get(HTMLCleanerConfiguration.TRANSLATE_SPECIAL_ENTITIES);\n        boolean translateSpecialEntities = (param != null) && Boolean.parseBoolean(param);\n        defaultProperties.setTranslateSpecialEntities(translateSpecialEntities);\n\n        defaultProperties.setDeserializeEntities(true);\n\n        return defaultProperties;\n    }\n\n    /**\n     * @param configuration The cleaner configuration.\n     * @return the default cleaning transformations to perform on tags, in addition to the base transformations done by\n     *         HTML Cleaner\n     */\n    private TrimAttributeCleanerTransformations getDefaultCleanerTransformations(HTMLCleanerConfiguration configuration)\n    {\n        TrimAttributeCleanerTransformations defaultTransformations = new TrimAttributeCleanerTransformations();\n\n        TagTransformation tt;\n\n        // note that we do not care here to use a TrimAttributeTagTransformation, since the attributes are not preserved\n        if (!isHTML5(configuration)) {\n            // These tags are not obsolete in HTML5.\n            tt = new TagTransformation(HTMLConstants.TAG_B, HTMLConstants.TAG_STRONG, false);\n            defaultTransformations.addTransformation(tt);\n\n            tt = new TagTransformation(HTMLConstants.TAG_I, HTMLConstants.TAG_EM, false);\n            defaultTransformations.addTransformation(tt);\n\n            tt = new TagTransformation(HTMLConstants.TAG_U, HTMLConstants.TAG_INS, false);\n            defaultTransformations.addTransformation(tt);\n\n            tt = new TagTransformation(HTMLConstants.TAG_S, HTMLConstants.TAG_DEL, false);\n            defaultTransformations.addTransformation(tt);\n        }\n\n        tt = new TagTransformation(HTMLConstants.TAG_STRIKE, HTMLConstants.TAG_DEL, false);\n        defaultTransformations.addTransformation(tt);\n\n        tt = new TagTransformation(HTMLConstants.TAG_CENTER, HTMLConstants.TAG_P, false);\n        tt.addAttributeTransformation(HTMLConstants.ATTRIBUTE_STYLE, \"text-align:center\");\n        defaultTransformations.addTransformation(tt);\n\n        if (isHTML5(configuration)) {\n            // Font tags are removed before the filters are applied in HTML5, we thus need a transformation here.\n            defaultTransformations.addTransformation(new FontTagTransformation());\n\n            // The tt-tag is obsolete in HTML5\n            tt = new TrimAttributeTagTransformation(HTMLConstants.TAG_TT, HTMLConstants.TAG_SPAN);\n            tt.addAttributeTransformation(HTMLConstants.ATTRIBUTE_CLASS, \"${class} monospace\");\n            defaultTransformations.addTransformation(tt);\n        }\n\n        String restricted = configuration.getParameters().get(HTMLCleanerConfiguration.RESTRICTED);\n        if (\"true\".equalsIgnoreCase(restricted)) {\n\n            tt = new TagTransformation(HTMLConstants.TAG_SCRIPT, HTMLConstants.TAG_PRE, false);\n            defaultTransformations.addTransformation(tt);\n\n            tt = new TagTransformation(HTMLConstants.TAG_STYLE, HTMLConstants.TAG_PRE, false);\n            defaultTransformations.addTransformation(tt);\n        }\n\n        return defaultTransformations;\n    }\n\n    /**\n     * @param configuration The configuration to parse.\n     * @return If the configuration specifies HTML 5 as version.\n     */\n    private boolean isHTML5(HTMLCleanerConfiguration configuration)\n    {\n        return getHTMLVersion(configuration) == 5;\n    }\n\n    /**\n     * @param configuration The configuration to parse.\n     * @return The HTML version specified in the configuration.\n     */\n    private int getHTMLVersion(HTMLCleanerConfiguration configuration)\n    {\n        String param = configuration.getParameters().get(HTMLCleanerConfiguration.HTML_VERSION);\n        int htmlVersion = 4;\n        if (\"5\".equals(param)) {\n            htmlVersion = 5;\n        }\n        return htmlVersion;\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.xml.internal.html;\n\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.htmlcleaner.CleanerProperties;\nimport org.htmlcleaner.DomSerializer;\nimport org.htmlcleaner.HtmlCleaner;\nimport org.htmlcleaner.TagNode;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.Test;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.NodeList;\nimport org.xwiki.component.manager.ComponentManager;\nimport org.xwiki.test.junit5.mockito.ComponentTest;\nimport org.xwiki.test.junit5.mockito.InjectMockComponents;\nimport org.xwiki.xml.html.DefaultHTMLCleanerComponentList;\nimport org.xwiki.xml.html.HTMLCleanerConfiguration;\nimport org.xwiki.xml.html.HTMLUtils;\nimport org.xwiki.xml.html.filter.HTMLFilter;\nimport org.xwiki.xml.internal.html.filter.UniqueIdFilter;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\n/**\n * Unit tests for {@link DefaultHTMLCleaner}.\n *\n * @version $Id$\n * @since 1.6M1\n */\n@ComponentTest\n@DefaultHTMLCleanerComponentList\npublic class DefaultHTMLCleanerTest\n{\n    public static final String HEADER = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\"\n        + \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Strict//EN\\\" \"\n        + \"\\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\\\">\\n\";\n\n    private static final String HEADER_FULL = HEADER + \"<html><head></head><body>\";\n\n    protected static final String FOOTER = \"</body></html>\\n\";\n\n    @InjectMockComponents\n    protected DefaultHTMLCleaner cleaner;\n\n    protected HTMLCleanerConfiguration cleanerConfiguration;\n\n    /**\n     * @return The expected XHTML 1.0 header.\n     */\n    public String getHeader()\n    {\n        return HEADER;\n    }\n\n    /**\n     * @return The expected full XHTML 1.0 header up to &lt;body&gt;.\n     */\n    public String getHeaderFull()\n    {\n        return HEADER_FULL;\n    }\n\n    /**\n     * Cleans using the cleaner configuration {@link DefaultHTMLCleanerTest#cleanerConfiguration}.\n     * <p>\n     * Ensures that always the correct configuration is used and allows executing the same tests for HTML 4 and HTML 5.\n     *\n     * @param originalHtmlContent The content to clean as string.\n     * @return The cleaned document.\n     */\n    protected Document clean(String originalHtmlContent)\n    {\n        return this.cleaner.clean(new StringReader(originalHtmlContent), cleanerConfiguration);\n    }\n\n    @BeforeEach\n    void setUpCleaner()\n    {\n        this.cleanerConfiguration = this.cleaner.getDefaultConfiguration();\n    }\n\n    @Test\n    void elementExpansion()\n    {\n        assertHTML(\"<p><textarea></textarea></p>\", \"<textarea/>\");\n\n        // Verify exceptions (by default elements are expanded).\n        assertHTML(\"<p><br /></p>\", \"<p><br></p>\");\n        assertHTML(\"<hr />\", \"<hr>\");\n    }\n\n    @Test\n    void specialCharacters()\n    {\n        // The blank space is not a standard space, but a non-breaking space.\n        assertHTML(\"<p>\\\"&amp;**notbold**&lt;notag&gt;\u00a0</p>\",\n            \"<p>&quot;&amp;**notbold**&lt;notag&gt;&nbsp;</p>\");\n        assertHTML(\"<p>\\\"&amp;</p>\", \"<p>\\\"&</p>\");\n        assertHTML(\"<p><img src=\\\"http://host.com/a.gif?a=foo&amp;b=bar\\\" /></p>\",\n            \"<img src=\\\"http://host.com/a.gif?a=foo&amp;b=bar\\\" />\");\n        assertHTML(\"<p>&#xA;</p>\", \"<p>&#xA;</p>\");\n\n        // Verify that double quotes are escaped in attribute values\n        assertHTML(\"<p value=\\\"script:&quot;&quot;\\\"></p>\", \"<p value='script:\\\"\\\"'\");\n    }\n\n    @Test\n    void closeUnbalancedTags()\n    {\n        assertHTML(\"<hr /><p>hello</p>\", \"<hr><p>hello\");\n    }\n\n    @Test\n    void conversionsFromHTML()\n    {\n        assertHTML(\"<p>this <strong>is</strong> bold</p>\", \"this <b>is</b> bold\");\n        assertHTML(\"<p><em>italic</em></p>\", \"<i>italic</i>\");\n        assertHTML(\"<del>strike</del>\", \"<strike>strike</strike>\");\n        assertHTML(\"<del>strike</del>\", \"<s>strike</s>\");\n        assertHTML(\"<ins>strike</ins>\", \"<u>strike</u>\");\n        assertHTML(\"<p style=\\\"text-align:center\\\">center</p>\", \"<center>center</center>\");\n        assertHTML(\"<p><span style=\\\"color:red;font-family:Arial;font-size:1.0em;\\\">This is some text!</span></p>\",\n            \"<font face=\\\"Arial\\\" size=\\\"3\\\" color=\\\"red\\\">This is some text!</font>\");\n        assertHTML(\"<p><span style=\\\"font-size:1.6em;\\\">This is some text!</span></p>\",\n            \"<font size=\\\"+3\\\">This is some text!</font>\");\n        assertHTML(\"<table><tbody><tr><td style=\\\"text-align:right;background-color:red;vertical-align:top\\\">\"\n            + \"x</td></tr></tbody></table>\", \"<table><tr><td align=right valign=top bgcolor=red>x</td></tr></table>\");\n    }\n\n    @Test\n    void convertImageAlignment()\n    {\n        assertHTML(\"<p><img style=\\\"float:left\\\" /></p>\", \"<img align=\\\"left\\\"/>\");\n        assertHTML(\"<p><img style=\\\"float:right\\\" /></p>\", \"<img align=\\\"right\\\"/>\");\n        assertHTML(\"<p><img style=\\\"vertical-align:top\\\" /></p>\", \"<img align=\\\"top\\\"/>\");\n        assertHTML(\"<p><img style=\\\"vertical-align:middle\\\" /></p>\", \"<img align=\\\"middle\\\"/>\");\n        assertHTML(\"<p><img style=\\\"vertical-align:bottom\\\" /></p>\", \"<img align=\\\"bottom\\\"/>\");\n    }\n\n    @Test\n    void convertImplicitParagraphs()\n    {\n        assertHTML(\"<p>word1</p><p>word2</p><p>word3</p><hr /><p>word4</p>\", \"word1<p>word2</p>word3<hr />word4\");\n\n        // Don't convert when there are only spaces or new lines\n        assertHTML(\"<p>word1</p>  \\n  <p>word2</p>\", \"<p>word1</p>  \\n  <p>word2</p>\");\n\n        // Ensure that whitespaces at the end works.\n        assertHTML(\"\\n \", \"\\n \");\n\n        // Ensure that comments are not wrapped\n        assertHTML(\"<!-- comment1 -->\\n<p>hello</p>\\n<!-- comment2 -->\",\n            \"<!-- comment1 -->\\n<p>hello</p>\\n<!-- comment2 -->\");\n\n        // Ensure that comments don't prevent other elements to be wrapped with paragraphs.\n        assertHTML(\"<!-- comment --><p><span>hello</span><!-- comment --></p><p>world</p>\",\n            \"<!-- comment --><span>hello</span><!-- comment --><p>world</p>\");\n    }\n\n    @Test\n    void cleanNonXHTMLLists()\n    {\n        // Fixing invalid list item.\n        assertHTML(\"<ul><li>item</li></ul>\", \"<li>item</li>\");\n\n        assertHTML(\"<ul><li>item1<ul><li>item2</li></ul></li></ul>\", \"<ul><li>item1</li><ul><li>item2</li></ul></ul>\");\n        assertHTML(\"<ul><li>item1<ul><li>item2<ul><li>item3</li></ul></li></ul></li></ul>\",\n            \"<ul><li>item1</li><ul><li>item2</li><ul><li>item3</li></ul></ul></ul>\");\n        assertHTML(\"<ul><li style=\\\"list-style-type: none\\\"><ul><li>item</li></ul></li></ul>\",\n            \"<ul><ul><li>item</li></ul></ul>\");\n        assertHTML(\"<ul> <li style=\\\"list-style-type: none\\\"><ul><li>item</li></ul></li></ul>\",\n            \"<ul> <ul><li>item</li></ul></ul>\");\n        assertHTML(\"<ul><li>item1<ol><li>item2</li></ol></li></ul>\", \"<ul><li>item1</li><ol><li>item2</li></ol></ul>\");\n        assertHTML(\"<ol><li>item1<ol><li>item2<ol><li>item3</li></ol></li></ol></li></ol>\",\n            \"<ol><li>item1</li><ol><li>item2</li><ol><li>item3</li></ol></ol></ol>\");\n        assertHTML(\"<ol><li style=\\\"list-style-type: none\\\"><ol><li>item</li></ol></li></ol>\",\n            \"<ol><ol><li>item</li></ol></ol>\");\n        assertHTML(\"<ul><li>item1<ul><li style=\\\"list-style-type: none\\\"><ul><li>item2</li></ul></li>\"\n            + \"<li>item3</li></ul></li></ul>\", \"<ul><li>item1</li><ul><ul><li>item2</li></ul><li>item3</li></ul></ul>\");\n\n        assertHTML(\"<ul>\\n\\n<li style=\\\"list-style-type: none\\\"><p>text</p></li></ul>\", \"<ul>\\n\\n<p>text</p></ul>\");\n        assertHTML(\"<ul><li>item<p>text</p></li><!--x-->  </ul>\", \"<ul><li>item</li><!--x-->  <p>text</p></ul>\");\n        assertHTML(\"<ul> \\n<li style=\\\"list-style-type: none\\\"><em>1</em>2<ins>3</ins></li><!--x--><li>item</li></ul>\",\n            \"<ul> \\n<em>1</em><!--x-->2<ins>3</ins><li>item</li></ul>\");\n    }\n\n    /**\n     * Verify that scripts are not cleaned and that we can have a CDATA section inside. Also verify CDATA behaviors.\n     */\n    @Test\n    void scriptAndCData()\n    {\n        assertHTML(\"<script type=\\\"text/javascript\\\">/*<![CDATA[*/\\nalert(\\\"Hello World\\\")\\n/*]]>*/</script>\",\n            \"<script type=\\\"text/javascript\\\"><![CDATA[\\nalert(\\\"Hello World\\\")\\n]]></script>\");\n\n        assertHTML(\"<script type=\\\"text/javascript\\\">/*<![CDATA[*/\\nalert(\\\"Hello World\\\")\\n/*]]>*/</script>\",\n            \"<script type=\\\"text/javascript\\\">//<![CDATA[\\nalert(\\\"Hello World\\\")\\n//]]></script>\");\n\n        assertHTML(\"<script type=\\\"text/javascript\\\">/*<![CDATA[*/\\nalert(\\\"Hello World\\\")\\n/*]]>*/</script>\",\n            \"<script type=\\\"text/javascript\\\">/*<![CDATA[*/\\nalert(\\\"Hello World\\\")\\n/*]]>*/</script>\");\n\n        assertHTML(\"<script type=\\\"text/javascript\\\">/*<![CDATA[*/\\n\\n\" + \"function escapeForXML(origtext) {\\n\"\n            + \"   return origtext.replace(/\\\\&/g,'&'+'amp;').replace(/</g,'&'+'lt;')\\n\"\n            + \"       .replace(/>/g,'&'+'gt;').replace(/\\'/g,'&'+'apos;').replace(/\\\"/g,'&'+'quot;');\" + \"}\\n\\n/*]]>*/\"\n            + \"</script>\", \"<script type=\\\"text/javascript\\\">\\n\" + \"/*<![CDATA[*/\\n\"\n            + \"function escapeForXML(origtext) {\\n\"\n            + \"   return origtext.replace(/\\\\&/g,'&'+'amp;').replace(/</g,'&'+'lt;')\\n\"\n            + \"       .replace(/>/g,'&'+'gt;').replace(/\\'/g,'&'+'apos;').replace(/\\\"/g,'&'+'quot;');\" + \"}\\n\"\n            + \"/*]]>*/\\n\" + \"</script>\");\n\n        assertHTML(\"<script>/*<![CDATA[*/\\n<>\\n/*]]>*/</script>\", \"<script>&lt;&gt;</script>\");\n        assertHTML(\"<script>/*<![CDATA[*/\\n<>\\n/*]]>*/</script>\", \"<script><></script>\");\n\n        // Verify that CDATA not inside SCRIPT or STYLE elements are considered comments in HTML and thus stripped\n        // when cleaned.\n        assertHTML(\"<p></p>\", \"<p><![CDATA[&]]></p>\");\n        assertHTML(\"<p>&amp;&amp;</p>\", \"<p>&<![CDATA[&]]>&</p>\");\n    }\n\n    /**\n     * Verify that inline style elements are not cleaned and that we can have a CDATA section inside.\n     */\n    @Test\n    void styleAndCData()\n    {\n        assertHTMLWithHeadContent(\"<style type=\\\"text/css\\\">/*<![CDATA[*/\\na { color: red; }\\n/*]]>*/</style>\",\n            \"<style type=\\\"text/css\\\"><![CDATA[\\na { color: red; }\\n]]></style>\");\n\n        assertHTMLWithHeadContent(\"<style type=\\\"text/css\\\">/*<![CDATA[*/\\na { color: red; }\\n/*]]>*/</style>\",\n            \"<style type=\\\"text/css\\\">/*<![CDATA[*/\\na { color: red; }\\n/*]]>*/</style>\");\n\n        assertHTMLWithHeadContent(\"<style type=\\\"text/css\\\">/*<![CDATA[*/\\na>span { color: blue;}\\n/*]]>*/</style>\",\n            \"<style type=\\\"text/css\\\">a&gt;span { color: blue;}</style>\");\n\n        assertHTMLWithHeadContent(\"<style>/*<![CDATA[*/\\n<>\\n/*]]>*/</style>\", \"<style>&lt;&gt;</style>\");\n        assertHTMLWithHeadContent(\"<style>/*<![CDATA[*/\\n<>\\n/*]]>*/</style>\", \"<style><></style>\");\n    }\n\n    /**\n     * Verify that we can control what filters are used for cleaning.\n     */\n    @Test\n    void explicitFilterList()\n    {\n        this.cleanerConfiguration.setFilters(Collections.emptyList());\n        String result = HTMLUtils.toString(clean(\"something\"));\n        // Note that if the default Body filter had been executed the result would have been:\n        // <p>something</p>.\n        assertEquals(getHeaderFull() + \"something\" + FOOTER, result);\n    }\n\n    /**\n     * Verify that the restricted parameter works.\n     */\n    @Test\n    void restrictedHtml()\n    {\n        Map<String, String> parameters = new HashMap<>(this.cleanerConfiguration.getParameters());\n        parameters.put(\"restricted\", \"true\");\n        this.cleanerConfiguration.setParameters(parameters);\n        Document document = clean(\"<script>alert(\\\"foo\\\")</script>\");\n\n        String textContent =\n            document.getElementsByTagName(\"pre\").item(0).getTextContent();\n        assertEquals(\"alert(\\\"foo\\\")\", textContent);\n\n        String result = HTMLUtils.toString(document);\n        assertEquals(getHeaderFull() + \"<pre>alert(\\\"foo\\\")</pre>\" + FOOTER, result);\n\n        document = clean(\"<style>p {color:white;}</style>\");\n\n        textContent =\n            document.getElementsByTagName(\"pre\").item(0).getTextContent();\n        assertEquals(\"p {color:white;}\", textContent);\n\n        result = HTMLUtils.toString(document);\n        assertEquals(getHeaderFull() + \"<pre>p {color:white;}</pre>\" + FOOTER, result);\n    }\n\n    /**\n     * Verify that the restricted parameter forbids dangerous attributes and tags.\n     */\n    @Test\n    void restrictedAttributesAndTags() throws Exception\n    {\n        Map<String, String> parameters = new HashMap<>(this.cleanerConfiguration.getParameters());\n        parameters.put(\"restricted\", \"true\");\n        this.cleanerConfiguration.setParameters(parameters);\n\n        assertHTML(\"<p><img src=\\\"img.png\\\" /></p>\", \"<img onerror=\\\"alert(1)\\\" src=img.png />\");\n        assertHTML(\"<p><a>Hello!</a></p>\", \"<a href=\\\"javascript:alert(1)\\\">Hello!</a>\");\n        assertHTML(\"<p></p>\", \"<iframe src=\\\"whatever\\\"/>\");\n\n        // Check that SVG is still working in restricted mode.\n        cleanSVGTags();\n        cleanTitleWithNamespace();\n\n        // Check that MathML is still working in restricted mode.\n        assertHTML(\"<p><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><mtext>X</mtext><mi><span>foo</span>\"\n                + \"</mi></math></p>\",\n            \"<math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><span></span><mtext>X</mtext><mi><span>foo</span>\"\n                + \"</mi></math>\");\n    }\n\n    /**\n     * Verify that passing a fully-formed XHTML header works fine.\n     */\n    @Test\n    void fullXHTMLHeader()\n    {\n        assertHTML(\"<p>test</p>\", getHeaderFull() + \"<p>test</p>\" + FOOTER);\n    }\n\n    /**\n     * Test {@link UniqueIdFilter}.\n     */\n    @Test\n    public void duplicateIds(ComponentManager componentManager) throws Exception\n    {\n        String actual = \"<p id=\\\"x\\\">1</p><p id=\\\"xy\\\">2</p><p id=\\\"x\\\">3</p>\";\n        String expected = \"<p id=\\\"x\\\">1</p><p id=\\\"xy\\\">2</p><p id=\\\"x0\\\">3</p>\";\n        List<HTMLFilter> filters = new ArrayList<>(this.cleanerConfiguration.getFilters());\n        filters.add(componentManager.getInstance(HTMLFilter.class, \"uniqueId\"));\n        this.cleanerConfiguration.setFilters(filters);\n        assertEquals(getHeaderFull() + expected + FOOTER,\n            HTMLUtils.toString(clean(actual)));\n    }\n\n    /**\n     * Test that tags with a namespace are not considered as unknown tags by HTMLCleaner (see also <a\n     * href=\"https://jira.xwiki.org/browse/XWIKI-9753\">XWIKI-9753</a>).\n     */\n    @Test\n    void cleanSVGTags() throws Exception\n    {\n        String input =\n            \"<p>before</p>\\n\" + \"<p><svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\">\\n\"\n                + \"<circle cx=\\\"100\\\" cy=\\\"50\\\" fill=\\\"red\\\" r=\\\"40\\\" stroke=\\\"black\\\" stroke-width=\\\"2\\\"></circle>\\n\"\n                + \"</svg></p>\\n\" + \"<p>after</p>\\n\";\n        assertHTML(input, getHeaderFull() + input + FOOTER);\n    }\n\n    /**\n     * Test that cleaning works when there's a TITLE element in the body (but with a namespace). The issue was that\n     * HTMLCleaner would consider it a duplicate of the TITLE element in the HEAD even though it's namespaced. (see\n     * also\n     * <a href=\"https://jira.xwiki.org/browse/XWIKI-9753\">XWIKI-9753</a>).\n     */\n    @Test\n    void cleanTitleWithNamespace()\n    {\n        // Test with TITLE in HEAD\n        String input =\n            \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\" lang=\\\"en\\\">\"\n                + \"<head>\\n\"\n                + \"    <title>Title test</title>\\n\"\n                + \"  </head>\"\n                + \"<body>\\n\"\n                + \"    <p>before</p>\\n\"\n                + \"    <p><svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"300\\\" width=\\\"500\\\">\\n\"\n                + \"      <g>\\n\"\n                + \"        <title>SVG Title Demo example</title>\\n\"\n                + \"        <rect height=\\\"50\\\" style=\\\"fill:none; stroke:blue; stroke-width:1px\\\" width=\\\"200\\\" x=\\\"10\\\" \"\n                + \"y=\\\"10\\\"></rect>\\n\" + \"      </g>\\n\" + \"    </svg></p>\\n\" + \"    <p>after</p>\\n\";\n        assertEquals(getHeader() + input + FOOTER,\n            HTMLUtils.toString(clean(input)));\n    }\n\n    /**\n     * Verify that a xmlns namespace set on the HTML element is not removed by default and it's removed if\n     * {@link HTMLCleanerConfiguration#NAMESPACES_AWARE} is set to false.\n     */\n    @Test\n    void cleanHTMLTagWithNamespace()\n    {\n        String input = \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\"><head></head><body>\";\n\n        // Default\n        assertEquals(getHeader() + input + FOOTER,\n            HTMLUtils.toString(clean(input)));\n\n        // Configured for namespace awareness being false\n        Map<String, String> parameters = new HashMap<>(this.cleanerConfiguration.getParameters());\n        parameters.put(HTMLCleanerConfiguration.NAMESPACES_AWARE, \"false\");\n        this.cleanerConfiguration.setParameters(parameters);\n        assertEquals(getHeader() + \"<html><head></head><body>\" + FOOTER,\n            HTMLUtils.toString(clean(input)));\n    }\n\n    /**\n     * Check that template tags inside select don't survive, might be security-relevant, DOMPurify contains a similar\n     * check, see <a href=\"https://github.com/cure53/DOMPurify/commit/e32ca248c0e9450fb182e52e978631cbd78f1123\">commit\n     * e32ca248c0 in DOMPurify</a>.\n     */\n    @Test\n    void cleanTemplateInsideSelect()\n    {\n        assertHTML(\"<p><select></select></p>\", \"<select><template></template></select>\");\n    }\n\n    /**\n     * Test that cleaning an empty DIV works (it used to fail, see <a\n     * href=\"https://jira.xwiki.org/browse/XWIKI-4007\">XWIKI-4007</a>).\n     */\n    @Test\n    void cleanEmptyDIV()\n    {\n        String input = \"<div id=\\\"y\\\"></div><div id=\\\"z\\\">something</div>\";\n        assertHTML(input, getHeaderFull() + input + FOOTER);\n    }\n\n    @Test\n    void verifyLegendTagNotStripped()\n    {\n        String input = \"<fieldset><legend>test</legend><div>content</div></fieldset>\";\n        assertHTML(input, getHeaderFull() + input + FOOTER);\n    }\n\n    @Test\n    void verifySpanIsExpanded()\n    {\n        assertHTML(\"<p><span class=\\\"fa fa-icon\\\"></span></p>\", \"<span class=\\\"fa fa-icon\\\" />\");\n    }\n\n    @Test\n    void verifyExternalLinksAreSecure()\n    {\n        assertHTML(\"<p><a href=\\\"relativeLink\\\" target=\\\"_blank\\\">label</a></p>\",\n            \"<a href=\\\"relativeLink\\\" target=\\\"_blank\\\">label</a>\");\n        assertHTML(\"<p><a href=\\\"http://xwiki.org\\\" rel=\\\" noopener noreferrer\\\" target=\\\"_blank\\\">label</a></p>\",\n            \"<a href=\\\"http://xwiki.org\\\" target=\\\"_blank\\\">label</a>\");\n        assertHTML(\"<p><a href=\\\"http://xwiki.org\\\" rel=\\\" noopener noreferrer\\\" target=\\\"someframe\\\">label</a></p>\",\n            \"<a href=\\\"http://xwiki.org\\\" target=\\\"someframe\\\">label</a>\");\n        assertHTML(\"<p><a href=\\\"http://xwiki.org\\\" target=\\\"_top\\\">label</a></p>\",\n            \"<a href=\\\"http://xwiki.org\\\" target=\\\"_top\\\">label</a>\");\n        assertHTML(\"<p><a href=\\\"http://xwiki.org\\\" target=\\\"_parent\\\">label</a></p>\",\n            \"<a href=\\\"http://xwiki.org\\\" target=\\\"_parent\\\">label</a>\");\n        assertHTML(\"<p><a href=\\\"http://xwiki.org\\\" target=\\\"_self\\\">label</a></p>\",\n            \"<a href=\\\"http://xwiki.org\\\" target=\\\"_self\\\">label</a>\");\n        assertHTML(\"<p><a href=\\\"http://xwiki.org\\\" rel=\\\"noopener noreferrer\\\" target=\\\"_blank\\\">label</a></p>\",\n            \"<a href=\\\"http://xwiki.org\\\" target=\\\"_blank\\\" rel=\\\"noopener\\\">label</a>\");\n        assertHTML(\"<p><a href=\\\"http://xwiki.org\\\" rel=\\\"noreferrer noopener\\\" target=\\\"_blank\\\">label</a></p>\",\n            \"<a href=\\\"http://xwiki.org\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">label</a>\");\n        assertHTML(\"<p><a href=\\\"http://xwiki.org\\\" rel=\\\"hello noopener noreferrer\\\" target=\\\"_blank\\\">label</a></p>\",\n            \"<a href=\\\"http://xwiki.org\\\" target=\\\"_blank\\\" rel=\\\"hello\\\">label</a>\");\n    }\n\n    @Test\n    void verifyEntitiesAreNotBroken()\n    {\n        Document document = clean(\"<p>&Eacute;</p>\");\n        String content = document.getElementsByTagName(\"p\").item(0).getTextContent();\n        assertEquals(\"\u00c9\", content);\n        assertHTML(\"<p>\u00c9</p>\", \"&Eacute;\");\n\n        document = clean(\"<p>&frac14;</p>\");\n        content = document.getElementsByTagName(\"p\").item(0).getTextContent();\n        assertEquals(\"\u00bc\", content);\n        assertHTML(\"<p>\u00bc</p>\", \"&frac14;\");\n\n        document = clean(\"<p>&f!rac14;</p>\");\n        content = document.getElementsByTagName(\"p\").item(0).getTextContent();\n        assertEquals(\"&f!rac14;\", content);\n        assertHTML(\"<p>&amp;f!rac14;</p>\", \"&f!rac14;\");\n\n        document = clean(\"<p>&frac12;</p>\");\n        content = document.getElementsByTagName(\"p\").item(0).getTextContent();\n        assertEquals(\"\u00bd\", content);\n        assertHTML(\"<p>\u00bd</p>\", \"&frac12;\");\n    }\n\n    @Test\n    void entitiesWithTranslation()\n    {\n        String content = \"<p>1&gt;2&amp;3&nbsp;4&frac12;5\u00f6\u00fc\u00e4\u0103\u00e2\u00ee\u0219</p>\";\n        String expectedContent = \"1>2&3\u00a04\u00bd5\u00f6\u00fc\u00e4\u0103\u00e2\u00ee\u0219\";\n        Document document = clean(content);\n        String obtainedContent = document.getElementsByTagName(\"p\").item(0).getTextContent();\n        assertEquals(expectedContent, obtainedContent);\n        assertHTML(\"<p>1&gt;2&amp;3\u00a04\u00bd5\u00f6\u00fc\u00e4\u0103\u00e2\u00ee\u0219</p>\", content);\n\n        Map<String, String> parameters = new HashMap<>(this.cleanerConfiguration.getParameters());\n        parameters.put(HTMLCleanerConfiguration.TRANSLATE_SPECIAL_ENTITIES, \"true\");\n        this.cleanerConfiguration.setParameters(parameters);\n        assertHTML(\"<p>1&amp;gt;2&amp;amp;3\u00a04\u00bd5\u00f6\u00fc\u00e4\u0103\u00e2\u00ee\u0219</p>\",\n            \"<p>1&gt;2&amp;3&nbsp;4&frac12;5\u00f6\u00fc\u00e4\u0103\u00e2\u00ee\u0219</p>\");\n    }\n\n    @Test\n    void verifyLeadingSpacesAreKeptOnlyInInputValue()\n    {\n        assertHTML(\"<p><input type=\\\"hidden\\\" value=\\\"  fff\\\" /></p>\", \"<input type=\\\"hidden\\\" value=\\\"  fff\\\" />\");\n        assertHTML(\"<p><input type=\\\"hidden\\\" value=\\\"foo\\\" /></p>\", \"<input type=\\\"hidden\\\" value=\\\"foo\\\" />\");\n        assertHTML(\"<p><input type=\\\"hidden\\\" value=\\\"foo bar\\\" /></p>\", \"<input type=\\\"hidden\\\" value=\\\"foo bar\\\" />\");\n        assertHTML(\"<p><input class=\\\"fff\\\" type=\\\"hidden\\\" /></p>\", \"<input type=\\\"hidden\\\" class=\\\"  fff\\\" />\");\n        assertHTML(\"<p><input class=\\\"foo bar\\\" type=\\\"hidden\\\" value=\\\" foo bar  \\\" /></p>\",\n            \"<input type=\\\"hidden   \\\" value=\\\" foo bar  \\\" class=\\\" foo bar  \\\"/>\");\n        assertHTML(\"<div class=\\\"foo bar\\\" title=\\\"foo bar\\\"></div>\",\n            \"<div title=\\\" foo bar  \\\" class=\\\" foo bar  \\\"/>\");\n    }\n\n    /**\n     * @see <a href=\"https://jira.xwiki.org/browse/XCOMMONS-1293\">XCOMMONS-1293</a>\n     */\n    @Test\n    void verifyIFRAMECleaning() throws Exception\n    {\n        // TODO: these 2 lines need to be changed to the following when https://jira.xwiki.org/browse/XCOMMONS-1292 is\n        // fixed:\n        //          assertHTML(\"<iframe src=\\\"whatever\\\"></iframe>\", \"<iframe src=\\\"whatever\\\"/>\");\n        //          assertHTML(\"<iframe src=\\\"whatever\\\"></iframe>\\r\\n\", \"<iframe src=\\\"whatever\\\"/>\\r\\n\");\n        assertHTML(\"<p><iframe src=\\\"whatever\\\"></iframe></p>\", \"<iframe src=\\\"whatever\\\"/>\");\n        assertHTML(\"<p><iframe src=\\\"whatever\\\"></iframe>\\r\\n</p>\", \"<iframe src=\\\"whatever\\\"/>\\r\\n\");\n        assertHTML(\"<p>\\r\\n<iframe src=\\\"whatever\\\"></iframe></p>\", \"\\r\\n<iframe src=\\\"whatever\\\"/>\");\n        assertHTML(\"<p>\\r\\n<iframe src=\\\"whatever\\\"></iframe>\\r\\n</p>\", \"\\r\\n<iframe src=\\\"whatever\\\"/>\\r\\n\");\n        assertHTML(\"<p><iframe src=\\\"whatever\\\"></iframe><iframe src=\\\"whatever\\\"></iframe></p>\",\n            \"<iframe src=\\\"whatever\\\"/><iframe src=\\\"whatever\\\"/>\");\n        assertHTML(\"<p><iframe src=\\\"whatever\\\"></iframe>\\r\\n<iframe src=\\\"whatever\\\"></iframe></p>\",\n            \"<iframe src=\\\"whatever\\\"/>\\r\\n<iframe src=\\\"whatever\\\"/>\");\n        assertHTML(\"<p>\\r\\n<iframe src=\\\"whatever\\\"></iframe>\\r\\n<iframe src=\\\"whatever\\\"></iframe>\\r\\n</p>\",\n            \"\\r\\n<iframe src=\\\"whatever\\\"/>\\r\\n<iframe src=\\\"whatever\\\"/>\\r\\n\");\n    }\n\n    @Test\n    void escapeHTMLCharsInAttributes() throws Exception\n    {\n        // Note: single quotes are not escaped since they're valid chars in attribute values that are surrounded by\n        // quotes. And HTMLCleaner will convert single quoted attributes into double-quoted ones.\n        String htmlInput = \"<div foo=\\\"aaa&quot;bbb&amp;ccc&gt;ddd&lt;eee&apos;fff\\\">content</div>\";\n        Document document = clean(htmlInput);\n\n        String textContent =\n            document.getElementsByTagName(\"div\").item(0).getAttributes().getNamedItem(\"foo\").getTextContent();\n        assertEquals(\"aaa\\\"bbb&ccc>ddd<eee'fff\", textContent);\n\n        htmlInput = \"<div foo='aaa&quot;bbb&amp;ccc&gt;ddd&lt;eee&apos;fff'>content</div>\";\n        document = clean(htmlInput);\n\n        textContent =\n            document.getElementsByTagName(\"div\").item(0).getAttributes().getNamedItem(\"foo\").getTextContent();\n        assertEquals(\"aaa\\\"bbb&ccc>ddd<eee'fff\", textContent);\n\n        assertHTML(\"<div foo=\\\"aaa&quot;bbb&amp;ccc&gt;ddd&lt;eee'fff\\\">content</div>\",\n            \"<div foo=\\\"aaa&quot;bbb&amp;ccc&gt;ddd&lt;eee&apos;fff\\\">content</div>\");\n        assertHTML(\"<div foo=\\\"aaa&quot;bbb&amp;ccc&gt;ddd&lt;eee'fff\\\">content</div>\",\n            \"<div foo='aaa&quot;bbb&amp;ccc&gt;ddd&lt;eee&apos;fff'>content</div>\");\n    }\n\n    @Test\n    void controlCharacters() throws Exception\n    {\n        String htmlInput = \"<p>\\u0008</p>\";\n        Document document = clean(htmlInput);\n\n        String textContent =\n            document.getElementsByTagName(\"p\").item(0).getTextContent();\n        assertEquals(\" \", textContent);\n        assertHTML(\" \", \"\\u0008\");\n\n        htmlInput = \"<p>&#8;</p>\";\n        document = clean(htmlInput);\n\n        // HtmlCleaner currently doesn't handle properly unicode characters: asking it to recognize them\n        // involves that all entities will be escaped during the parsing and that's not what we want. So we\n        // keep them encoded.\n        // See https://sourceforge.net/p/htmlcleaner/bugs/221/\n        textContent =\n            document.getElementsByTagName(\"p\").item(0).getTextContent();\n        assertEquals(\"&#8;\", textContent);\n        assertHTML(\"<p>&#8;</p>\", \"&#8;\");\n\n        htmlInput = \"<p foo=\\\"&#8;\\\">content</p>\";\n        document = clean(htmlInput);\n\n        // HtmlCleaner currently doesn't handle properly unicode characters: asking it to recognize them\n        // involves that all entities will be escaped during the parsing and that's not what we want. So we\n        // keep them encoded.\n        textContent =\n            document.getElementsByTagName(\"p\").item(0).getAttributes().getNamedItem(\"foo\").getTextContent();\n        assertEquals(\"&#8;\", textContent);\n        assertHTML(\"<p foo=\\\"&#8;\\\">content</p>\", \"<p foo=\\\"&#8;\\\">content</p>\");\n    }\n\n    @Test\n    void ttElement()\n    {\n        assertHTML(\"<p><tt>Monospace Text</tt></p>\", \"<tt>Monospace Text</tt>\");\n    }\n\n    @Test\n    void divInsideDl()\n    {\n        // Check for https://jira.xwiki.org/browse/XCOMMONS-2375 - div inside dl should be allowed.\n        assertHTML(\n            \"<dl><div><dt>HTML</dt><dd>Hypertext Markup Language</dd></div><dt>another</dt><dd>entry</dd></dl>\",\n            \"<dl><div><dt>HTML<dd>Hypertext Markup Language</div><dt>another<dd>entry</dl>\");\n    }\n\n    /**\n     * Check what happens when the dt-tag is inside div.\n     * <p>\n     * This should add a wrapping dl but doesn't for HTML 4, but it works in HTML5, see\n     * {@link HTML5HTMLCleanerTest#divWithDt()}.\n     *\n     * @todo Replace by {@link HTML5HTMLCleanerTest#divWithDt()} if this should be fixed and this test is failing.\n     */\n    @Test\n    void divWithDt()\n    {\n        assertHTML(\"<div><dt>HTML</dt><dd>Hypertext Markup Language</dd></div>\",\n            \"<div><dt>HTML<dd>Hypertext Markup Language</div>\");\n    }\n\n    /**\n     * Check if plain text is allowed inside a div in dl - it shouldn't be but isn't filtered currently.\n     * <p>\n     * Note: even though this test is passing XWiki should not depend on this behavior.\n     *\n     * @todo Test with a valid expected HTML string when HTMLCleaner starts cleaning this.\n     */\n    @Test\n    void dlWithoutDt()\n    {\n        String htmlInput = \"<dl><div><strong>Hello!</strong></div></dl>\";\n        assertHTML(htmlInput, htmlInput);\n    }\n\n    protected void assertHTML(String expected, String actual)\n    {\n        Document documentValue = clean(actual);\n        assertEquals(getHeaderFull() + expected + FOOTER, HTMLUtils.toString(documentValue));\n    }\n\n    protected void assertHTMLWithHeadContent(String expected, String actual)\n    {\n        assertEquals(getHeader() + \"<html><head>\" + expected + \"</head><body>\" + FOOTER,\n            HTMLUtils.toString(clean(actual)));\n    }\n\n    @Test\n    void transformedDOMContent()\n    {\n        String htmlInput = \"<img src=\\\"http://host.com/a.gif?a=foo&b=bar\\\" />\";\n        Document document = clean(htmlInput);\n\n        String textContent =\n            document.getElementsByTagName(\"img\").item(0).getAttributes().getNamedItem(\"src\").getTextContent();\n        assertEquals(\"http://host.com/a.gif?a=foo&b=bar\", textContent);\n\n        htmlInput = \"<img src=\\\"http://host.com/a.gif?a=foo&amp;b=bar\\\" />\";\n        document = clean(htmlInput);\n\n        textContent =\n            document.getElementsByTagName(\"img\").item(0).getAttributes().getNamedItem(\"src\").getTextContent();\n        assertEquals(\"http://host.com/a.gif?a=foo&b=bar\", textContent);\n    }\n\n    @Test\n    public void preserveDoubleEscapingInAttributes() throws Exception\n    {\n        CleanerProperties cleanerProperties = new CleanerProperties();\n        cleanerProperties.setDeserializeEntities(true);\n        HtmlCleaner cleaner = new HtmlCleaner(cleanerProperties);\n        TagNode tagNode = cleaner.clean(\"<?xml version = \\\"1.0\\\"?><div foo=\\\"&amp;quot;\\\">&amp;quot;</div>\");\n        List<? extends TagNode> divList = tagNode.getElementListByName(\"div\", true);\n        assertEquals(1, divList.size());\n        assertEquals(\"&quot;\", divList.get(0).getText().toString());\n        // This assert is failing: the attribute is deserialized to contain \".\n        assertEquals(\"&quot;\", divList.get(0).getAttributeByName(\"foo\"));\n\n        DomSerializer domSerializer = new DomSerializer(cleanerProperties, false);\n        Document document = domSerializer.createDOM(tagNode);\n\n        NodeList nodeList = document.getElementsByTagName(\"div\");\n        assertEquals(1, nodeList.getLength());\n        assertEquals(\"&quot;\", nodeList.item(0).getTextContent());\n        assertEquals(\"&quot;\", nodeList.item(0).getAttributes().getNamedItem(\"foo\").getTextContent());\n\n        document = clean(\"<div foo=\\\"&amp;quot;\\\">&amp;quot;</div>\");\n        nodeList = document.getElementsByTagName(\"div\");\n        assertEquals(1, nodeList.getLength());\n        assertEquals(\"&quot;\", nodeList.item(0).getTextContent());\n        // We can never retrieve the expected value here since the encoded &amp; has been lost earlier.\n        assertEquals(\"&quot;\", nodeList.item(0).getAttributes().getNamedItem(\"foo\").getTextContent());\n\n        assertHTML(\"<div foo=\\\"&amp;quot;\\\">content</div>\",\n            \"<div foo=\\\"&amp;quot;\\\">content</div>\");\n    }\n\n    @Test\n    @Disabled(\"See https://sourceforge.net/p/htmlcleaner/bugs/221/\")\n    public void parseWithUnicodeChars() throws Exception\n    {\n        CleanerProperties cleanerProperties = new CleanerProperties();\n\n        cleanerProperties.setDeserializeEntities(true);\n        cleanerProperties.setRecognizeUnicodeChars(true);\n        cleanerProperties.setTranslateSpecialEntities(false);\n\n        HtmlCleaner cleaner = new HtmlCleaner(cleanerProperties);\n        TagNode tagNode = cleaner.clean(\"<?xml version = \\\"1.0\\\"?>\"\n            + \"<div foo=\\\"&#169;\\\">&#169;</div>\"\n            + \"<div foo=\\\"baz&gt;buz\\\">baz&gt;buz</div>\"\n            + \"<div foo=\\\"baz&buz\\\">baz&buz</div>\");\n        List<? extends TagNode> divList = tagNode.getElementListByName(\"div\", true);\n        assertEquals(3, divList.size());\n\n        assertEquals(\"\u00a9\", divList.get(0).getText().toString());\n        assertEquals(\"\u00a9\", divList.get(0).getAttributeByName(\"foo\"));\n\n        assertEquals(\"baz>buz\", divList.get(1).getText().toString());\n        assertEquals(\"baz>buz\", divList.get(1).getAttributeByName(\"foo\"));\n\n        assertEquals(\"baz&buz\", divList.get(2).getText().toString());\n        assertEquals(\"baz&buz\", divList.get(2).getAttributeByName(\"foo\"));\n\n        DomSerializer domSerializer = new DomSerializer(cleanerProperties, false);\n        Document document = domSerializer.createDOM(tagNode);\n\n        NodeList nodeList = document.getElementsByTagName(\"div\");\n        assertEquals(3, nodeList.getLength());\n        assertEquals(\"\u00a9\", nodeList.item(0).getTextContent());\n        assertEquals(\"\u00a9\", nodeList.item(0).getAttributes().getNamedItem(\"foo\").getTextContent());\n\n        assertEquals(\"baz>buz\", nodeList.item(1).getAttributes().getNamedItem(\"foo\").getTextContent());\n\n        assertEquals(\"baz&buz\", nodeList.item(2).getAttributes().getNamedItem(\"foo\").getTextContent());\n\n        // BUG: This is failing with baz&gt;buz\n        assertEquals(\"baz>buz\", nodeList.item(1).getTextContent());\n        // BUG: This is failing with baz&amp;buz\n        assertEquals(\"baz&buz\", nodeList.item(2).getTextContent());\n    }\n\n    @Test\n    public void followingEncodedEntitiesAreProperlyKept()\n    {\n        String content = \"<p><textarea>&#123;&#123;velocity}}machin&#123;&#123;/velocity}}</textarea></p>\";\n        Document document = clean(content);\n        String textareaContent = document.getElementsByTagName(\"textarea\").item(0).getTextContent();\n        assertEquals(\"&#123;&#123;velocity}}machin&#123;&#123;/velocity}}\", textareaContent);\n\n        assertHTML(\"<p><textarea>&#123;&#123;velocity}}machin&#123;&#123;/velocity}}</textarea></p>\", content);\n    }\n}\n"], "fixing_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.xml.html;\n\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.jdom.Comment;\nimport org.jdom.DocType;\nimport org.jdom.Element;\nimport org.jdom.input.DOMBuilder;\nimport org.jdom.output.Format;\nimport org.jdom.output.XMLOutputter;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xwiki.xml.XMLUtils;\n\n/**\n * HTML Utility methods.\n *\n * @version $Id$\n * @since 1.8.3\n */\n// TODO: Create a separate class for each HTML version (XHTML 1.0, HTML5, etc...)\npublic final class HTMLUtils\n{\n    /**\n     * In HTML5, some elements must be expanded (for example {@code <span></span>} instead of {@code <span />}), and\n     * some others must not (for example {@code <br />} instead of {@code <br></br>}. Thus for the list of elements\n     * below we need special handling (not expanding).\n     */\n    private static final List<String> OMIT_ELEMENT_EXPANDING_SET = Arrays.asList(\n        \"area\", \"base\", \"br\", \"col\", \"hr\", \"img\", \"input\", \"link\", \"meta\", \"param\");\n\n    /**\n     * JDOM's XMLOutputter class converts reserved XML character ({@code &}) into its entity\n     * format {@code &amp;}. However since we're using HTML Cleaner\n     * (http://htmlcleaner.sourceforge.net/) and since it's buggy for unicode character escapes we have turned off\n     * character escaping for it and thus we need to perform selective escaping here.\n     * <p>\n     * Moreover, since we support HTML5, we need to\n     * expand empty elements on some elements and not on the others. For example: {@code <span></span>} is valid\n     * meanwhile:\n     * <pre>{@code\n     * <br>\n     * </br>}</pre>\n     * is not. See {@code OMIT_ELEMENT_EXPANDING_SET} for the list of elements to not expand.\n     */\n    // TODO: Remove the complex escaping code when SF HTML Cleaner will do proper escaping\n    public static class XWikiXMLOutputter extends XMLOutputter\n    {\n        /**\n         * Regex for a character reference as defined in:\n         * https://www.w3.org/TR/WD-xml-lang-970630#dt-charref.\n         */\n        private static final String CHARACTER_REFERENCE = \"&amp;#[0-9]+;|&amp;#x[0-9a-fA-F]+;\";\n\n        /**\n         * Regex to recognize a character reference Entity.\n         */\n        private static final Pattern CHARACTER_REFERENCE_PATTERN = Pattern.compile(CHARACTER_REFERENCE);\n\n        /**\n         * Escaped ampersand character.\n         */\n        private static final String AMPERSAND = \"&amp;\";\n\n        /**\n         * Whether to omit the document type when printing the W3C Document or not.\n         */\n        private boolean omitDocType;\n\n        /**\n         * @param format the JDOM class used to control output formats, see {@link org.jdom.output.Format}\n         * @param omitDocType if true then omit the document type when printing the W3C Document\n         * @see XMLOutputter#XMLOutputter(Format)\n         */\n        public XWikiXMLOutputter(Format format, boolean omitDocType)\n        {\n            super(format);\n            this.omitDocType = omitDocType;\n        }\n\n        @Override\n        public String escapeElementEntities(String text)\n        {\n            String result = super.escapeElementEntities(text);\n\n            // \"\\r\" characters are automatically transformed in &#xD; but we want to keep the original \\r there.\n            return cleanAmpersandEscape(result).replaceAll(\"&#xD;\", \"\\r\");\n        }\n\n        @Override\n        public String escapeAttributeEntities(String text)\n        {\n            String result = super.escapeAttributeEntities(text);\n            return cleanAmpersandEscape(result);\n        }\n\n        /**\n         * Remove ampersand escapes when it's not needed (i.e. on character entities).\n         *\n         * @param text the text escaped.\n         * @return the text cleaned\n         */\n        private String cleanAmpersandEscape(String text)\n        {\n            StringBuilder buffer = new StringBuilder(text);\n            // find all occurrences of &\n            int pos = buffer.indexOf(AMPERSAND);\n            while (pos > -1 && pos < buffer.length()) {\n                // Check if the & is a character entity\n                Matcher matcher = CHARACTER_REFERENCE_PATTERN.matcher(buffer.substring(pos));\n                if (matcher.lookingAt()) {\n                    // We've found an entity, replace the \"&amp;\" by a single \"&\"\n                    buffer.replace(pos, pos + 5, \"&\");\n\n                    // We have replaced 4 characters in the buffer so let's move the position back\n                    pos = pos + matcher.end() - matcher.start() - 4;\n                } else {\n                    // don't do anything, just move on.\n                    pos += 5;\n                }\n                pos = buffer.indexOf(AMPERSAND, pos);\n            }\n            return buffer.toString();\n        }\n\n        @Override\n        protected void printDocType(Writer out, DocType docType) throws IOException\n        {\n            if (!this.omitDocType) {\n                super.printDocType(out, docType);\n            }\n        }\n\n        @Override\n        protected void printElement(Writer out, Element element, int level, NamespaceStack namespaces)\n            throws IOException\n        {\n            // We override the code from the super class to not expand some empty elements.\n            boolean currentFormatPolicy = currentFormat.getExpandEmptyElements();\n            try {\n                String elementName = element.getName();\n                for (String name : OMIT_ELEMENT_EXPANDING_SET) {\n                    if (name.equals(elementName)) {\n                        // We do not expand this empty element\n                        currentFormat.setExpandEmptyElements(false);\n                        break;\n                    }\n                }\n\n                // Call the method from the super class\n                super.printElement(out, element, level, namespaces);\n\n            } finally {\n                // Reset the format\n                currentFormat.setExpandEmptyElements(currentFormatPolicy);\n            }\n        }\n\n        @Override\n        protected void printComment(Writer out, Comment comment) throws IOException\n        {\n            String commentText = comment.getText();\n\n            // TODO: remove this again when https://sourceforge.net/p/htmlcleaner/bugs/234/ has been fixed.\n            // Make sure that the comment text conforms to the HTML specification, in particular: \"Optionally, text,\n            // with the additional restriction that the text must not start with the string \">\", nor start with the\n            // string \"->\", nor contain the strings \"<!--\", \"-->\", or \"--!>\", nor end with the string \"<!-\".\"\n            while (commentText.startsWith(\">\") || commentText.startsWith(\"->\")) {\n                commentText = commentText.substring(1);\n            }\n\n            super.printComment(out, new Comment(commentText));\n        }\n    }\n\n    /**\n     * Private constructor since this is a utility class that shouldn't be instantiated (all methods are static).\n     */\n    private HTMLUtils()\n    {\n        // Nothing to do\n    }\n\n    /**\n     * @param document the W3C Document to transform into a String\n     * @return the XML as a String\n     */\n    public static String toString(Document document)\n    {\n        return HTMLUtils.toString(document, false, false);\n    }\n\n    /**\n     * @param document the W3C Document to transform into a String\n     * @param omitDeclaration whether the XML declaration should be printed or not\n     * @param omitDoctype whether the document type should be printed or not\n     * @return the XML as a String\n     */\n    public static String toString(Document document, boolean omitDeclaration, boolean omitDoctype)\n    {\n        // Note: We don't use javax.xml.transform.Transformer since it prints our valid XHTML as HTML which is not\n        // XHTML compliant. For example it transforms our \"<hr/>\" into \"<hr>.\n        DOMBuilder builder = new DOMBuilder();\n        org.jdom.Document jdomDoc = builder.build(document);\n\n        Format format = Format.getRawFormat();\n        // Force newlines to use \\n since otherwise the default is \\n\\r.\n        // See http://www.jdom.org/docs/apidocs/org/jdom/output/Format.html#setLineSeparator(java.lang.String)\n        format.setLineSeparator(\"\\n\");\n\n        // Make sure all elements are expanded so that they can also be rendered fine in browsers that only support\n        // HTML.\n        format.setExpandEmptyElements(true);\n\n        format.setOmitDeclaration(omitDeclaration);\n\n        XMLOutputter outputter = new XWikiXMLOutputter(format, omitDoctype);\n\n        return outputter.outputString(jdomDoc);\n    }\n\n    /**\n     * Strip the HTML envelope if it exists. Precisely this means removing the head tag and move all tags in the body\n     * tag directly under the html element. This is useful for example if you wish to insert an HTML fragment into an\n     * existing HTML page.\n     *\n     * @param document the w3c Document to strip\n     */\n    public static void stripHTMLEnvelope(Document document)\n    {\n        org.w3c.dom.Element root = document.getDocumentElement();\n        if (root.getNodeName().equalsIgnoreCase(HTMLConstants.TAG_HTML)) {\n            // Look for a head element below the root element and for a body element\n            Node bodyNode = null;\n            Node headNode = null;\n            NodeList nodes = root.getChildNodes();\n            for (int i = 0; i < nodes.getLength(); i++) {\n                Node node = nodes.item(i);\n                if (node.getNodeName().equalsIgnoreCase(HTMLConstants.TAG_HEAD)) {\n                    headNode = node;\n                } else if (node.getNodeName().equalsIgnoreCase(HTMLConstants.TAG_BODY)) {\n                    bodyNode = node;\n                }\n            }\n\n            if (headNode != null) {\n                root.removeChild(headNode);\n            }\n\n            if (bodyNode != null) {\n                // Move all children of body node under the root element\n                NodeList bodyChildrenNodes = bodyNode.getChildNodes();\n                while (bodyChildrenNodes.getLength() > 0) {\n                    root.insertBefore(bodyChildrenNodes.item(0), null);\n                }\n                root.removeChild(bodyNode);\n            }\n        }\n    }\n\n    /**\n     * Remove the first element inside a parent element and copy the element's children in the parent.\n     *\n     * @param document the w3c document from which to remove the top level paragraph\n     * @param parentTagName the name of the parent tag to look under\n     * @param elementTagName the name of the first element to remove\n     */\n    public static void stripFirstElementInside(Document document, String parentTagName, String elementTagName)\n    {\n        NodeList parentNodes = document.getElementsByTagName(parentTagName);\n        if (parentNodes.getLength() > 0) {\n            Node parentNode = parentNodes.item(0);\n            // Look for a p element below the first parent element\n            Node pNode = parentNode.getFirstChild();\n            if (elementTagName.equalsIgnoreCase(pNode.getNodeName())) {\n                // Move all children of p node under the root element\n                NodeList pChildrenNodes = pNode.getChildNodes();\n                while (pChildrenNodes.getLength() > 0) {\n                    parentNode.insertBefore(pChildrenNodes.item(0), null);\n                }\n                parentNode.removeChild(pNode);\n            }\n        }\n    }\n\n    /**\n     * Escapes HTML special characters in a {@code String} using numerical HTML entities, so that the resulting string\n     * can safely be used as an HTML content text value.\n     * For instance, {@code Jim & John} will be escaped and can thus be put inside a HTML tag, such as the {@code p}\n     * tag, as in {@code <p>Jim &amp; John</p>}.\n     * Specifically, escapes &lt; to {@code &lt;}, and &amp; to {@code &amp;}.\n     *\n     * @param content the text to escape, may be {@code null}.\n     * @return a new escaped {@code String}, {@code null} if {@code null} input\n     * @since 12.8RC1\n     * @since 12.6.3\n     * @since 11.10.11\n     */\n    public static String escapeElementText(String content)\n    {\n        return XMLUtils.escapeElementText(content);\n    }\n\n    /**\n     * Same logic as {@link #escapeElementText(String)} but only indicates if there is something to escape.\n     * \n     * @param content the content to parse\n     * @return true if the passed content contains content that can be interpreted as HTML syntax\n     * @see #escapeElementText(String)\n     * @since 12.10\n     * @since 12.6.5\n     */\n    public static boolean containsElementText(CharSequence content)\n    {\n        return XMLUtils.containsElementText(content);\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.xml.internal.html;\n\nimport java.io.Reader;\nimport java.util.Arrays;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Singleton;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.htmlcleaner.CleanerProperties;\nimport org.htmlcleaner.DoctypeToken;\nimport org.htmlcleaner.HtmlCleaner;\nimport org.htmlcleaner.TagNode;\nimport org.htmlcleaner.TagTransformation;\nimport org.htmlcleaner.TrimAttributeTagTransformation;\nimport org.htmlcleaner.XWikiDOMSerializer;\nimport org.w3c.dom.Document;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.context.Execution;\nimport org.xwiki.context.ExecutionContext;\nimport org.xwiki.xml.html.HTMLCleaner;\nimport org.xwiki.xml.html.HTMLCleanerConfiguration;\nimport org.xwiki.xml.html.HTMLConstants;\nimport org.xwiki.xml.html.filter.HTMLFilter;\n\n/**\n * Default implementation for {@link org.xwiki.xml.html.HTMLCleaner} using the <a href=\"HTML Cleaner\n * framework>http://htmlcleaner.sourceforge.net/</a>.\n *\n * @version $Id$\n * @since 1.6M1\n */\n@Component\n@Singleton\npublic class DefaultHTMLCleaner implements HTMLCleaner\n{\n    /**\n     * {@link HTMLFilter} for filtering html lists.\n     */\n    @Inject\n    @Named(\"list\")\n    private HTMLFilter listFilter;\n\n    /**\n     * {@link HTMLFilter} for filtering html lists.\n     */\n    @Inject\n    @Named(\"listitem\")\n    private HTMLFilter listItemFilter;\n\n    /**\n     * {@link HTMLFilter} for filtering HTML font elements.\n     */\n    @Inject\n    @Named(\"font\")\n    private HTMLFilter fontFilter;\n\n    /**\n     * {@link HTMLFilter} for wrapping invalid body elements with paragraphs.\n     */\n    @Inject\n    @Named(\"body\")\n    private HTMLFilter bodyFilter;\n\n    /**\n     * {@link HTMLFilter} for filtering HTML attributes that are used by many different elements and for which we cannot\n     * write simple transformations like in {@link #getDefaultCleanerTransformations(HTMLCleanerConfiguration)}.\n     */\n    @Inject\n    @Named(\"attribute\")\n    private HTMLFilter attributeFilter;\n\n    /**\n     * {@link HTMLFilter} for filtering HTML links.\n     */\n    @Inject\n    @Named(\"link\")\n    private HTMLFilter linkFilter;\n\n    /**\n     * Remove control characters.\n     */\n    @Inject\n    @Named(\"controlcharacters\")\n    // TODO: remove when upgrading to HTMLClener 2.23\n    private HTMLFilter controlFilter;\n\n    @Inject\n    @Named(\"sanitizer\")\n    private HTMLFilter sanitizerFilter;\n\n    @Inject\n    private Execution execution;\n\n    @Inject\n    private XWikiHTML5TagProvider html5TagInfoProvider;\n\n    @Override\n    public Document clean(Reader originalHtmlContent)\n    {\n        return clean(originalHtmlContent, getDefaultConfiguration());\n    }\n\n    private DocumentBuilder getAvailableDocumentBuilder() throws ParserConfigurationException\n    {\n        ExecutionContext econtext = this.execution.getContext();\n\n        if (econtext != null) {\n            DocumentBuilder documentBuilder = (DocumentBuilder) econtext.getProperty(DocumentBuilder.class.getName());\n\n            if (documentBuilder == null) {\n                documentBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n                econtext.setProperty(DocumentBuilder.class.getName(), documentBuilder);\n            }\n\n            return documentBuilder;\n        }\n\n        return DocumentBuilderFactory.newInstance().newDocumentBuilder();\n    }\n\n    @Override\n    public Document clean(Reader originalHtmlContent, HTMLCleanerConfiguration configuration)\n    {\n        Document result;\n\n        // Note: Instantiation of an HtmlCleaner object is cheap so there's no need to cache an instance of it,\n        // especially since this makes it extra safe with regards to multithreading (even though HTML Cleaner is\n        // already supposed to be thread safe).\n        CleanerProperties cleanerProperties = getDefaultCleanerProperties(configuration);\n        HtmlCleaner cleaner;\n        if (isHTML5(configuration)) {\n            // Use our custom provider to fix bugs, should be checked on each upgrade if still necessary.\n            cleaner = new HtmlCleaner(this.html5TagInfoProvider, cleanerProperties);\n        }  else {\n            cleaner = new HtmlCleaner(cleanerProperties);\n        }\n\n        TagNode cleanedNode;\n        try {\n            cleanedNode = cleaner.clean(originalHtmlContent);\n        } catch (Exception e) {\n            // This shouldn't happen since we're not doing any IO... I consider this a flaw in the design of HTML\n            // Cleaner.\n            throw new RuntimeException(\"Unhandled error when cleaning HTML\", e);\n        }\n\n        try {\n            // Ideally we would use SF's HTMLCleaner DomSerializer but there are outstanding issues with it, so we're\n            // using a custom XWikiDOMSerializer (see its javadoc for more details).\n            // Replace by the following when fixed:\n            //   result = new DomSerializer(cleanerProperties, false).createDOM(cleanedNode);\n\n            if (isHTML5(configuration)) {\n                cleanedNode.setDocType(new DoctypeToken(HTMLConstants.TAG_HTML, null, null, null));\n            } else {\n                cleanedNode.setDocType(\n                    new DoctypeToken(HTMLConstants.TAG_HTML, \"PUBLIC\", \"-//W3C//DTD XHTML 1.0 Strict//EN\",\n                        \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"));\n            }\n            result =\n                new XWikiDOMSerializer(cleanerProperties).createDOM(getAvailableDocumentBuilder(), cleanedNode);\n        } catch (ParserConfigurationException ex) {\n            throw new RuntimeException(\"Error while serializing TagNode into w3c dom.\", ex);\n        }\n\n        // Finally apply filters.\n        for (HTMLFilter filter : configuration.getFilters()) {\n            filter.filter(result, configuration.getParameters());\n        }\n\n        return result;\n    }\n\n    @Override\n    public HTMLCleanerConfiguration getDefaultConfiguration()\n    {\n        HTMLCleanerConfiguration configuration = new DefaultHTMLCleanerConfiguration();\n        configuration.setFilters(Arrays.asList(\n            this.controlFilter,\n            this.bodyFilter,\n            this.listItemFilter,\n            this.listFilter,\n            this.fontFilter,\n            this.attributeFilter,\n            this.linkFilter,\n            this.sanitizerFilter));\n        return configuration;\n    }\n\n    /**\n     * @param configuration the configuration to use for the cleaning\n     * @return the default {@link CleanerProperties} to be used for cleaning.\n     */\n    private CleanerProperties getDefaultCleanerProperties(HTMLCleanerConfiguration configuration)\n    {\n        CleanerProperties defaultProperties = new CleanerProperties();\n        defaultProperties.setOmitUnknownTags(true);\n\n        // HTML Cleaner uses the compact notation by default but we don't want that since:\n        // - it's more work and not required since not compact notation is valid XHTML\n        // - expanded elements can also be rendered fine in browsers that only support HTML.\n        defaultProperties.setUseEmptyElementTags(false);\n\n        // Wrap script and style content in CDATA blocks\n        defaultProperties.setUseCdataForScriptAndStyle(true);\n\n        // We need this for example to ignore CDATA sections not inside script or style elements.\n        defaultProperties.setIgnoreQuestAndExclam(true);\n\n        // Remove CDATA outside of script and style since according to the spec it has no effect there.\n        defaultProperties.setOmitCdataOutsideScriptAndStyle(true);\n\n        // If the caller has defined NAMESPACE_AWARE configuration property then use it, otherwise use our default.\n        String param = configuration.getParameters().get(HTMLCleanerConfiguration.NAMESPACES_AWARE);\n        boolean namespacesAware = (param == null) || Boolean.parseBoolean(param);\n        defaultProperties.setNamespacesAware(namespacesAware);\n\n        // Set Cleaner transformations\n        defaultProperties.setCleanerTransformations(getDefaultCleanerTransformations(configuration));\n\n        // Don't convert special HTML entities (i.e. &ocirc;, &permil;, &times;) with unicode characters they represent.\n        defaultProperties.setTranslateSpecialEntities(false);\n\n        // Use character references rather than entity references if needed (for instance if you need to parse the\n        // output as XML)\n        param = configuration.getParameters().get(HTMLCleanerConfiguration.USE_CHARACTER_REFERENCES);\n        boolean useCharacterReferences = (param != null) && Boolean.parseBoolean(param);\n        defaultProperties.setTransResCharsToNCR(useCharacterReferences);\n\n        // Sets the HTML version from the configuration (by default 4).\n        defaultProperties.setHtmlVersion(getHTMLVersion(configuration));\n\n        // We trim values by default for all attributes but the input value attribute.\n        // The only way to currently do that is to switch off this flag, and to create a dedicated TagTransformation.\n        // See TrimAttributeCleanerTransformation for more information.\n        defaultProperties.setTrimAttributeValues(false);\n\n        // This flag should be set to true once https://sourceforge.net/p/htmlcleaner/bugs/221/ is fixed.\n        defaultProperties.setRecognizeUnicodeChars(false);\n\n        param = configuration.getParameters().get(HTMLCleanerConfiguration.TRANSLATE_SPECIAL_ENTITIES);\n        boolean translateSpecialEntities = (param != null) && Boolean.parseBoolean(param);\n        defaultProperties.setTranslateSpecialEntities(translateSpecialEntities);\n\n        defaultProperties.setDeserializeEntities(true);\n\n        // Omit comments in restricted mode to avoid any potential parser confusion.\n        // Any part of the filtered HTML that contains unfiltered input is potentially dangerous/a candidate for\n        // parser confusion. Comments, style and script elements seem to be frequently found ingredients in successful\n        // attacks against good sanitizers. We're already removing style and script elements, so removing comments\n        // seems like a good defense against future attacks.\n        defaultProperties.setOmitComments(isRestricted(configuration));\n\n        return defaultProperties;\n    }\n\n    /**\n     * @param configuration The cleaner configuration.\n     * @return the default cleaning transformations to perform on tags, in addition to the base transformations done by\n     *         HTML Cleaner\n     */\n    private TrimAttributeCleanerTransformations getDefaultCleanerTransformations(HTMLCleanerConfiguration configuration)\n    {\n        TrimAttributeCleanerTransformations defaultTransformations = new TrimAttributeCleanerTransformations();\n\n        TagTransformation tt;\n\n        // note that we do not care here to use a TrimAttributeTagTransformation, since the attributes are not preserved\n        if (!isHTML5(configuration)) {\n            // These tags are not obsolete in HTML5.\n            tt = new TagTransformation(HTMLConstants.TAG_B, HTMLConstants.TAG_STRONG, false);\n            defaultTransformations.addTransformation(tt);\n\n            tt = new TagTransformation(HTMLConstants.TAG_I, HTMLConstants.TAG_EM, false);\n            defaultTransformations.addTransformation(tt);\n\n            tt = new TagTransformation(HTMLConstants.TAG_U, HTMLConstants.TAG_INS, false);\n            defaultTransformations.addTransformation(tt);\n\n            tt = new TagTransformation(HTMLConstants.TAG_S, HTMLConstants.TAG_DEL, false);\n            defaultTransformations.addTransformation(tt);\n        }\n\n        tt = new TagTransformation(HTMLConstants.TAG_STRIKE, HTMLConstants.TAG_DEL, false);\n        defaultTransformations.addTransformation(tt);\n\n        tt = new TagTransformation(HTMLConstants.TAG_CENTER, HTMLConstants.TAG_P, false);\n        tt.addAttributeTransformation(HTMLConstants.ATTRIBUTE_STYLE, \"text-align:center\");\n        defaultTransformations.addTransformation(tt);\n\n        if (isHTML5(configuration)) {\n            // Font tags are removed before the filters are applied in HTML5, we thus need a transformation here.\n            defaultTransformations.addTransformation(new FontTagTransformation());\n\n            // The tt-tag is obsolete in HTML5\n            tt = new TrimAttributeTagTransformation(HTMLConstants.TAG_TT, HTMLConstants.TAG_SPAN);\n            tt.addAttributeTransformation(HTMLConstants.ATTRIBUTE_CLASS, \"${class} monospace\");\n            defaultTransformations.addTransformation(tt);\n        }\n\n        if (isRestricted(configuration)) {\n\n            tt = new TagTransformation(HTMLConstants.TAG_SCRIPT, HTMLConstants.TAG_PRE, false);\n            defaultTransformations.addTransformation(tt);\n\n            tt = new TagTransformation(HTMLConstants.TAG_STYLE, HTMLConstants.TAG_PRE, false);\n            defaultTransformations.addTransformation(tt);\n        }\n\n        return defaultTransformations;\n    }\n\n    /**\n     * @param configuration The configuration to parse.\n     * @return If the configuration specifies HTML 5 as version.\n     */\n    private boolean isHTML5(HTMLCleanerConfiguration configuration)\n    {\n        return getHTMLVersion(configuration) == 5;\n    }\n\n    /**\n     * @param configuration the configuration to parse\n     * @return if the parsing should happen in restricted mode\n     */\n    private boolean isRestricted(HTMLCleanerConfiguration configuration)\n    {\n        String restricted = configuration.getParameters().get(HTMLCleanerConfiguration.RESTRICTED);\n        return \"true\".equalsIgnoreCase(restricted);\n    }\n\n    /**\n     * @param configuration The configuration to parse.\n     * @return The HTML version specified in the configuration.\n     */\n    private int getHTMLVersion(HTMLCleanerConfiguration configuration)\n    {\n        String param = configuration.getParameters().get(HTMLCleanerConfiguration.HTML_VERSION);\n        int htmlVersion = 4;\n        if (\"5\".equals(param)) {\n            htmlVersion = 5;\n        }\n        return htmlVersion;\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.xml.internal.html;\n\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.htmlcleaner.CleanerProperties;\nimport org.htmlcleaner.DomSerializer;\nimport org.htmlcleaner.HtmlCleaner;\nimport org.htmlcleaner.TagNode;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvSource;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.NodeList;\nimport org.xwiki.component.manager.ComponentManager;\nimport org.xwiki.test.junit5.mockito.ComponentTest;\nimport org.xwiki.test.junit5.mockito.InjectMockComponents;\nimport org.xwiki.xml.html.DefaultHTMLCleanerComponentList;\nimport org.xwiki.xml.html.HTMLCleanerConfiguration;\nimport org.xwiki.xml.html.HTMLUtils;\nimport org.xwiki.xml.html.filter.HTMLFilter;\nimport org.xwiki.xml.internal.html.filter.UniqueIdFilter;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\n/**\n * Unit tests for {@link DefaultHTMLCleaner}.\n *\n * @version $Id$\n * @since 1.6M1\n */\n@ComponentTest\n@DefaultHTMLCleanerComponentList\npublic class DefaultHTMLCleanerTest\n{\n    public static final String HEADER = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\"\n        + \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Strict//EN\\\" \"\n        + \"\\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\\\">\\n\";\n\n    private static final String HEADER_FULL = HEADER + \"<html><head></head><body>\";\n\n    protected static final String FOOTER = \"</body></html>\\n\";\n\n    @InjectMockComponents\n    protected DefaultHTMLCleaner cleaner;\n\n    protected HTMLCleanerConfiguration cleanerConfiguration;\n\n    /**\n     * @return The expected XHTML 1.0 header.\n     */\n    public String getHeader()\n    {\n        return HEADER;\n    }\n\n    /**\n     * @return The expected full XHTML 1.0 header up to &lt;body&gt;.\n     */\n    public String getHeaderFull()\n    {\n        return HEADER_FULL;\n    }\n\n    /**\n     * Cleans using the cleaner configuration {@link DefaultHTMLCleanerTest#cleanerConfiguration}.\n     * <p>\n     * Ensures that always the correct configuration is used and allows executing the same tests for HTML 4 and HTML 5.\n     *\n     * @param originalHtmlContent The content to clean as string.\n     * @return The cleaned document.\n     */\n    protected Document clean(String originalHtmlContent)\n    {\n        return this.cleaner.clean(new StringReader(originalHtmlContent), cleanerConfiguration);\n    }\n\n    @BeforeEach\n    void setUpCleaner()\n    {\n        this.cleanerConfiguration = this.cleaner.getDefaultConfiguration();\n    }\n\n    @Test\n    void elementExpansion()\n    {\n        assertHTML(\"<p><textarea></textarea></p>\", \"<textarea/>\");\n\n        // Verify exceptions (by default elements are expanded).\n        assertHTML(\"<p><br /></p>\", \"<p><br></p>\");\n        assertHTML(\"<hr />\", \"<hr>\");\n    }\n\n    @Test\n    void specialCharacters()\n    {\n        // The blank space is not a standard space, but a non-breaking space.\n        assertHTML(\"<p>\\\"&amp;**notbold**&lt;notag&gt;\u00a0</p>\",\n            \"<p>&quot;&amp;**notbold**&lt;notag&gt;&nbsp;</p>\");\n        assertHTML(\"<p>\\\"&amp;</p>\", \"<p>\\\"&</p>\");\n        assertHTML(\"<p><img src=\\\"http://host.com/a.gif?a=foo&amp;b=bar\\\" /></p>\",\n            \"<img src=\\\"http://host.com/a.gif?a=foo&amp;b=bar\\\" />\");\n        assertHTML(\"<p>&#xA;</p>\", \"<p>&#xA;</p>\");\n\n        // Verify that double quotes are escaped in attribute values\n        assertHTML(\"<p value=\\\"script:&quot;&quot;\\\"></p>\", \"<p value='script:\\\"\\\"'\");\n    }\n\n    @Test\n    void closeUnbalancedTags()\n    {\n        assertHTML(\"<hr /><p>hello</p>\", \"<hr><p>hello\");\n    }\n\n    @Test\n    void conversionsFromHTML()\n    {\n        assertHTML(\"<p>this <strong>is</strong> bold</p>\", \"this <b>is</b> bold\");\n        assertHTML(\"<p><em>italic</em></p>\", \"<i>italic</i>\");\n        assertHTML(\"<del>strike</del>\", \"<strike>strike</strike>\");\n        assertHTML(\"<del>strike</del>\", \"<s>strike</s>\");\n        assertHTML(\"<ins>strike</ins>\", \"<u>strike</u>\");\n        assertHTML(\"<p style=\\\"text-align:center\\\">center</p>\", \"<center>center</center>\");\n        assertHTML(\"<p><span style=\\\"color:red;font-family:Arial;font-size:1.0em;\\\">This is some text!</span></p>\",\n            \"<font face=\\\"Arial\\\" size=\\\"3\\\" color=\\\"red\\\">This is some text!</font>\");\n        assertHTML(\"<p><span style=\\\"font-size:1.6em;\\\">This is some text!</span></p>\",\n            \"<font size=\\\"+3\\\">This is some text!</font>\");\n        assertHTML(\"<table><tbody><tr><td style=\\\"text-align:right;background-color:red;vertical-align:top\\\">\"\n            + \"x</td></tr></tbody></table>\", \"<table><tr><td align=right valign=top bgcolor=red>x</td></tr></table>\");\n    }\n\n    @Test\n    void convertImageAlignment()\n    {\n        assertHTML(\"<p><img style=\\\"float:left\\\" /></p>\", \"<img align=\\\"left\\\"/>\");\n        assertHTML(\"<p><img style=\\\"float:right\\\" /></p>\", \"<img align=\\\"right\\\"/>\");\n        assertHTML(\"<p><img style=\\\"vertical-align:top\\\" /></p>\", \"<img align=\\\"top\\\"/>\");\n        assertHTML(\"<p><img style=\\\"vertical-align:middle\\\" /></p>\", \"<img align=\\\"middle\\\"/>\");\n        assertHTML(\"<p><img style=\\\"vertical-align:bottom\\\" /></p>\", \"<img align=\\\"bottom\\\"/>\");\n    }\n\n    @Test\n    void convertImplicitParagraphs()\n    {\n        assertHTML(\"<p>word1</p><p>word2</p><p>word3</p><hr /><p>word4</p>\", \"word1<p>word2</p>word3<hr />word4\");\n\n        // Don't convert when there are only spaces or new lines\n        assertHTML(\"<p>word1</p>  \\n  <p>word2</p>\", \"<p>word1</p>  \\n  <p>word2</p>\");\n\n        // Ensure that whitespaces at the end works.\n        assertHTML(\"\\n \", \"\\n \");\n\n        // Ensure that comments are not wrapped\n        assertHTML(\"<!-- comment1 -->\\n<p>hello</p>\\n<!-- comment2 -->\",\n            \"<!-- comment1 -->\\n<p>hello</p>\\n<!-- comment2 -->\");\n\n        // Ensure that comments don't prevent other elements to be wrapped with paragraphs.\n        assertHTML(\"<!-- comment --><p><span>hello</span><!-- comment --></p><p>world</p>\",\n            \"<!-- comment --><span>hello</span><!-- comment --><p>world</p>\");\n    }\n\n    @Test\n    void cleanNonXHTMLLists()\n    {\n        // Fixing invalid list item.\n        assertHTML(\"<ul><li>item</li></ul>\", \"<li>item</li>\");\n\n        assertHTML(\"<ul><li>item1<ul><li>item2</li></ul></li></ul>\", \"<ul><li>item1</li><ul><li>item2</li></ul></ul>\");\n        assertHTML(\"<ul><li>item1<ul><li>item2<ul><li>item3</li></ul></li></ul></li></ul>\",\n            \"<ul><li>item1</li><ul><li>item2</li><ul><li>item3</li></ul></ul></ul>\");\n        assertHTML(\"<ul><li style=\\\"list-style-type: none\\\"><ul><li>item</li></ul></li></ul>\",\n            \"<ul><ul><li>item</li></ul></ul>\");\n        assertHTML(\"<ul> <li style=\\\"list-style-type: none\\\"><ul><li>item</li></ul></li></ul>\",\n            \"<ul> <ul><li>item</li></ul></ul>\");\n        assertHTML(\"<ul><li>item1<ol><li>item2</li></ol></li></ul>\", \"<ul><li>item1</li><ol><li>item2</li></ol></ul>\");\n        assertHTML(\"<ol><li>item1<ol><li>item2<ol><li>item3</li></ol></li></ol></li></ol>\",\n            \"<ol><li>item1</li><ol><li>item2</li><ol><li>item3</li></ol></ol></ol>\");\n        assertHTML(\"<ol><li style=\\\"list-style-type: none\\\"><ol><li>item</li></ol></li></ol>\",\n            \"<ol><ol><li>item</li></ol></ol>\");\n        assertHTML(\"<ul><li>item1<ul><li style=\\\"list-style-type: none\\\"><ul><li>item2</li></ul></li>\"\n            + \"<li>item3</li></ul></li></ul>\", \"<ul><li>item1</li><ul><ul><li>item2</li></ul><li>item3</li></ul></ul>\");\n\n        assertHTML(\"<ul>\\n\\n<li style=\\\"list-style-type: none\\\"><p>text</p></li></ul>\", \"<ul>\\n\\n<p>text</p></ul>\");\n        assertHTML(\"<ul><li>item<p>text</p></li><!--x-->  </ul>\", \"<ul><li>item</li><!--x-->  <p>text</p></ul>\");\n        assertHTML(\"<ul> \\n<li style=\\\"list-style-type: none\\\"><em>1</em>2<ins>3</ins></li><!--x--><li>item</li></ul>\",\n            \"<ul> \\n<em>1</em><!--x-->2<ins>3</ins><li>item</li></ul>\");\n    }\n\n    /**\n     * Verify that scripts are not cleaned and that we can have a CDATA section inside. Also verify CDATA behaviors.\n     */\n    @Test\n    void scriptAndCData()\n    {\n        assertHTML(\"<script type=\\\"text/javascript\\\">/*<![CDATA[*/\\nalert(\\\"Hello World\\\")\\n/*]]>*/</script>\",\n            \"<script type=\\\"text/javascript\\\"><![CDATA[\\nalert(\\\"Hello World\\\")\\n]]></script>\");\n\n        assertHTML(\"<script type=\\\"text/javascript\\\">/*<![CDATA[*/\\nalert(\\\"Hello World\\\")\\n/*]]>*/</script>\",\n            \"<script type=\\\"text/javascript\\\">//<![CDATA[\\nalert(\\\"Hello World\\\")\\n//]]></script>\");\n\n        assertHTML(\"<script type=\\\"text/javascript\\\">/*<![CDATA[*/\\nalert(\\\"Hello World\\\")\\n/*]]>*/</script>\",\n            \"<script type=\\\"text/javascript\\\">/*<![CDATA[*/\\nalert(\\\"Hello World\\\")\\n/*]]>*/</script>\");\n\n        assertHTML(\"<script type=\\\"text/javascript\\\">/*<![CDATA[*/\\n\\n\" + \"function escapeForXML(origtext) {\\n\"\n            + \"   return origtext.replace(/\\\\&/g,'&'+'amp;').replace(/</g,'&'+'lt;')\\n\"\n            + \"       .replace(/>/g,'&'+'gt;').replace(/\\'/g,'&'+'apos;').replace(/\\\"/g,'&'+'quot;');\" + \"}\\n\\n/*]]>*/\"\n            + \"</script>\", \"<script type=\\\"text/javascript\\\">\\n\" + \"/*<![CDATA[*/\\n\"\n            + \"function escapeForXML(origtext) {\\n\"\n            + \"   return origtext.replace(/\\\\&/g,'&'+'amp;').replace(/</g,'&'+'lt;')\\n\"\n            + \"       .replace(/>/g,'&'+'gt;').replace(/\\'/g,'&'+'apos;').replace(/\\\"/g,'&'+'quot;');\" + \"}\\n\"\n            + \"/*]]>*/\\n\" + \"</script>\");\n\n        assertHTML(\"<script>/*<![CDATA[*/\\n<>\\n/*]]>*/</script>\", \"<script>&lt;&gt;</script>\");\n        assertHTML(\"<script>/*<![CDATA[*/\\n<>\\n/*]]>*/</script>\", \"<script><></script>\");\n\n        // Verify that CDATA not inside SCRIPT or STYLE elements are considered comments in HTML and thus stripped\n        // when cleaned.\n        assertHTML(\"<p></p>\", \"<p><![CDATA[&]]></p>\");\n        assertHTML(\"<p>&amp;&amp;</p>\", \"<p>&<![CDATA[&]]>&</p>\");\n    }\n\n    /**\n     * Verify that inline style elements are not cleaned and that we can have a CDATA section inside.\n     */\n    @Test\n    void styleAndCData()\n    {\n        assertHTMLWithHeadContent(\"<style type=\\\"text/css\\\">/*<![CDATA[*/\\na { color: red; }\\n/*]]>*/</style>\",\n            \"<style type=\\\"text/css\\\"><![CDATA[\\na { color: red; }\\n]]></style>\");\n\n        assertHTMLWithHeadContent(\"<style type=\\\"text/css\\\">/*<![CDATA[*/\\na { color: red; }\\n/*]]>*/</style>\",\n            \"<style type=\\\"text/css\\\">/*<![CDATA[*/\\na { color: red; }\\n/*]]>*/</style>\");\n\n        assertHTMLWithHeadContent(\"<style type=\\\"text/css\\\">/*<![CDATA[*/\\na>span { color: blue;}\\n/*]]>*/</style>\",\n            \"<style type=\\\"text/css\\\">a&gt;span { color: blue;}</style>\");\n\n        assertHTMLWithHeadContent(\"<style>/*<![CDATA[*/\\n<>\\n/*]]>*/</style>\", \"<style>&lt;&gt;</style>\");\n        assertHTMLWithHeadContent(\"<style>/*<![CDATA[*/\\n<>\\n/*]]>*/</style>\", \"<style><></style>\");\n    }\n\n    /**\n     * Verify that we can control what filters are used for cleaning.\n     */\n    @Test\n    void explicitFilterList()\n    {\n        this.cleanerConfiguration.setFilters(Collections.emptyList());\n        String result = HTMLUtils.toString(clean(\"something\"));\n        // Note that if the default Body filter had been executed the result would have been:\n        // <p>something</p>.\n        assertEquals(getHeaderFull() + \"something\" + FOOTER, result);\n    }\n\n    /**\n     * Verify that the restricted parameter works.\n     */\n    @Test\n    void restrictedHtml()\n    {\n        Map<String, String> parameters = new HashMap<>(this.cleanerConfiguration.getParameters());\n        parameters.put(\"restricted\", \"true\");\n        this.cleanerConfiguration.setParameters(parameters);\n        Document document = clean(\"<script>alert(\\\"foo\\\")</script>\");\n\n        String textContent =\n            document.getElementsByTagName(\"pre\").item(0).getTextContent();\n        assertEquals(\"alert(\\\"foo\\\")\", textContent);\n\n        String result = HTMLUtils.toString(document);\n        assertEquals(getHeaderFull() + \"<pre>alert(\\\"foo\\\")</pre>\" + FOOTER, result);\n\n        document = clean(\"<style>p {color:white;}</style>\");\n\n        textContent =\n            document.getElementsByTagName(\"pre\").item(0).getTextContent();\n        assertEquals(\"p {color:white;}\", textContent);\n\n        result = HTMLUtils.toString(document);\n        assertEquals(getHeaderFull() + \"<pre>p {color:white;}</pre>\" + FOOTER, result);\n    }\n\n    /**\n     * Verify that the restricted parameter forbids dangerous attributes and tags.\n     */\n    @Test\n    void restrictedAttributesAndTags() throws Exception\n    {\n        Map<String, String> parameters = new HashMap<>(this.cleanerConfiguration.getParameters());\n        parameters.put(\"restricted\", \"true\");\n        this.cleanerConfiguration.setParameters(parameters);\n\n        assertHTML(\"<p><img src=\\\"img.png\\\" /></p>\", \"<img onerror=\\\"alert(1)\\\" src=img.png />\");\n        assertHTML(\"<p><a>Hello!</a></p>\", \"<a href=\\\"javascript:alert(1)\\\">Hello!</a>\");\n        assertHTML(\"<p></p>\", \"<iframe src=\\\"whatever\\\"/>\");\n\n        // Check that SVG is still working in restricted mode.\n        cleanSVGTags();\n        cleanTitleWithNamespace();\n\n        // Check that MathML is still working in restricted mode.\n        assertHTML(\"<p><math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><mtext>X</mtext><mi><span>foo</span>\"\n                + \"</mi></math></p>\",\n            \"<math xmlns=\\\"http://www.w3.org/1998/Math/MathML\\\"><span></span><mtext>X</mtext><mi><span>foo</span>\"\n                + \"</mi></math>\");\n    }\n\n    /**\n     * Verify comment handling in restricted mode.\n     */\n    @ParameterizedTest\n    @CsvSource({\n        \"<p><strong>Hello  World</strong></p>,<strong>Hello <!-- a comment --> World</strong>\",\n        \"'', <!--My favorite operators are > and <!-->\",\n        // FIXME: Actually, just the comment should be removed but due to erroneous parsing in HTMLCleaner, the whole\n        // string is treated as a comment.\n        \"'', <!--> <a href=\\\"#\\\">no comment</a>\",\n        \"'', <!---> <a href=\\\"#\\\">no comment</a>\"\n    })\n    void restrictedComments(String expected, String actual)\n    {\n        Map<String, String> parameters = new HashMap<>(this.cleanerConfiguration.getParameters());\n        parameters.put(\"restricted\", \"true\");\n        this.cleanerConfiguration.setParameters(parameters);\n\n        assertHTML(expected, actual);\n    }\n\n    @ParameterizedTest\n    @CsvSource({\n        \"<!--My favorite operators are > and <!-->, <!--My favorite operators are > and <!-->\",\n        \"<!-- a comment ==!> not a comment-->, <!-- a comment --!> not a comment\",\n        // FIXME: this is wrongly parsed as a full comment.\n        \"<!-- <a foo=`bar`>not a comment</a>-->, <!--> <a foo=`bar`>not a comment</a>\",\n        \"<!--=>-->, <!--->\",\n        // FIXME: according to the HTML specification, this should be a comment.\n        \"'', <! fake comment >\",\n        \"<!-- <!== comment -->, <!-- <!-- comment -->\",\n        \"<!--My favorite operators are > and <!=-->, <!--My favorite operators are > and <!--->\"\n    })\n    void comments(String expected, String actual)\n    {\n        assertHTML(expected, actual);\n    }\n\n    /**\n     * Verify that passing a fully-formed XHTML header works fine.\n     */\n    @Test\n    void fullXHTMLHeader()\n    {\n        assertHTML(\"<p>test</p>\", getHeaderFull() + \"<p>test</p>\" + FOOTER);\n    }\n\n    /**\n     * Test {@link UniqueIdFilter}.\n     */\n    @Test\n    public void duplicateIds(ComponentManager componentManager) throws Exception\n    {\n        String actual = \"<p id=\\\"x\\\">1</p><p id=\\\"xy\\\">2</p><p id=\\\"x\\\">3</p>\";\n        String expected = \"<p id=\\\"x\\\">1</p><p id=\\\"xy\\\">2</p><p id=\\\"x0\\\">3</p>\";\n        List<HTMLFilter> filters = new ArrayList<>(this.cleanerConfiguration.getFilters());\n        filters.add(componentManager.getInstance(HTMLFilter.class, \"uniqueId\"));\n        this.cleanerConfiguration.setFilters(filters);\n        assertEquals(getHeaderFull() + expected + FOOTER,\n            HTMLUtils.toString(clean(actual)));\n    }\n\n    /**\n     * Test that tags with a namespace are not considered as unknown tags by HTMLCleaner (see also <a\n     * href=\"https://jira.xwiki.org/browse/XWIKI-9753\">XWIKI-9753</a>).\n     */\n    @Test\n    void cleanSVGTags() throws Exception\n    {\n        String input =\n            \"<p>before</p>\\n\" + \"<p><svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.1\\\">\\n\"\n                + \"<circle cx=\\\"100\\\" cy=\\\"50\\\" fill=\\\"red\\\" r=\\\"40\\\" stroke=\\\"black\\\" stroke-width=\\\"2\\\"></circle>\\n\"\n                + \"</svg></p>\\n\" + \"<p>after</p>\\n\";\n        assertHTML(input, getHeaderFull() + input + FOOTER);\n    }\n\n    /**\n     * Test that cleaning works when there's a TITLE element in the body (but with a namespace). The issue was that\n     * HTMLCleaner would consider it a duplicate of the TITLE element in the HEAD even though it's namespaced. (see\n     * also\n     * <a href=\"https://jira.xwiki.org/browse/XWIKI-9753\">XWIKI-9753</a>).\n     */\n    @Test\n    void cleanTitleWithNamespace()\n    {\n        // Test with TITLE in HEAD\n        String input =\n            \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\" lang=\\\"en\\\">\"\n                + \"<head>\\n\"\n                + \"    <title>Title test</title>\\n\"\n                + \"  </head>\"\n                + \"<body>\\n\"\n                + \"    <p>before</p>\\n\"\n                + \"    <p><svg xmlns=\\\"http://www.w3.org/2000/svg\\\" height=\\\"300\\\" width=\\\"500\\\">\\n\"\n                + \"      <g>\\n\"\n                + \"        <title>SVG Title Demo example</title>\\n\"\n                + \"        <rect height=\\\"50\\\" style=\\\"fill:none; stroke:blue; stroke-width:1px\\\" width=\\\"200\\\" x=\\\"10\\\" \"\n                + \"y=\\\"10\\\"></rect>\\n\" + \"      </g>\\n\" + \"    </svg></p>\\n\" + \"    <p>after</p>\\n\";\n        assertEquals(getHeader() + input + FOOTER,\n            HTMLUtils.toString(clean(input)));\n    }\n\n    /**\n     * Verify that a xmlns namespace set on the HTML element is not removed by default and it's removed if\n     * {@link HTMLCleanerConfiguration#NAMESPACES_AWARE} is set to false.\n     */\n    @Test\n    void cleanHTMLTagWithNamespace()\n    {\n        String input = \"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\"><head></head><body>\";\n\n        // Default\n        assertEquals(getHeader() + input + FOOTER,\n            HTMLUtils.toString(clean(input)));\n\n        // Configured for namespace awareness being false\n        Map<String, String> parameters = new HashMap<>(this.cleanerConfiguration.getParameters());\n        parameters.put(HTMLCleanerConfiguration.NAMESPACES_AWARE, \"false\");\n        this.cleanerConfiguration.setParameters(parameters);\n        assertEquals(getHeader() + \"<html><head></head><body>\" + FOOTER,\n            HTMLUtils.toString(clean(input)));\n    }\n\n    /**\n     * Check that template tags inside select don't survive, might be security-relevant, DOMPurify contains a similar\n     * check, see <a href=\"https://github.com/cure53/DOMPurify/commit/e32ca248c0e9450fb182e52e978631cbd78f1123\">commit\n     * e32ca248c0 in DOMPurify</a>.\n     */\n    @Test\n    void cleanTemplateInsideSelect()\n    {\n        assertHTML(\"<p><select></select></p>\", \"<select><template></template></select>\");\n    }\n\n    /**\n     * Test that cleaning an empty DIV works (it used to fail, see <a\n     * href=\"https://jira.xwiki.org/browse/XWIKI-4007\">XWIKI-4007</a>).\n     */\n    @Test\n    void cleanEmptyDIV()\n    {\n        String input = \"<div id=\\\"y\\\"></div><div id=\\\"z\\\">something</div>\";\n        assertHTML(input, getHeaderFull() + input + FOOTER);\n    }\n\n    @Test\n    void verifyLegendTagNotStripped()\n    {\n        String input = \"<fieldset><legend>test</legend><div>content</div></fieldset>\";\n        assertHTML(input, getHeaderFull() + input + FOOTER);\n    }\n\n    @Test\n    void verifySpanIsExpanded()\n    {\n        assertHTML(\"<p><span class=\\\"fa fa-icon\\\"></span></p>\", \"<span class=\\\"fa fa-icon\\\" />\");\n    }\n\n    @Test\n    void verifyExternalLinksAreSecure()\n    {\n        assertHTML(\"<p><a href=\\\"relativeLink\\\" target=\\\"_blank\\\">label</a></p>\",\n            \"<a href=\\\"relativeLink\\\" target=\\\"_blank\\\">label</a>\");\n        assertHTML(\"<p><a href=\\\"http://xwiki.org\\\" rel=\\\" noopener noreferrer\\\" target=\\\"_blank\\\">label</a></p>\",\n            \"<a href=\\\"http://xwiki.org\\\" target=\\\"_blank\\\">label</a>\");\n        assertHTML(\"<p><a href=\\\"http://xwiki.org\\\" rel=\\\" noopener noreferrer\\\" target=\\\"someframe\\\">label</a></p>\",\n            \"<a href=\\\"http://xwiki.org\\\" target=\\\"someframe\\\">label</a>\");\n        assertHTML(\"<p><a href=\\\"http://xwiki.org\\\" target=\\\"_top\\\">label</a></p>\",\n            \"<a href=\\\"http://xwiki.org\\\" target=\\\"_top\\\">label</a>\");\n        assertHTML(\"<p><a href=\\\"http://xwiki.org\\\" target=\\\"_parent\\\">label</a></p>\",\n            \"<a href=\\\"http://xwiki.org\\\" target=\\\"_parent\\\">label</a>\");\n        assertHTML(\"<p><a href=\\\"http://xwiki.org\\\" target=\\\"_self\\\">label</a></p>\",\n            \"<a href=\\\"http://xwiki.org\\\" target=\\\"_self\\\">label</a>\");\n        assertHTML(\"<p><a href=\\\"http://xwiki.org\\\" rel=\\\"noopener noreferrer\\\" target=\\\"_blank\\\">label</a></p>\",\n            \"<a href=\\\"http://xwiki.org\\\" target=\\\"_blank\\\" rel=\\\"noopener\\\">label</a>\");\n        assertHTML(\"<p><a href=\\\"http://xwiki.org\\\" rel=\\\"noreferrer noopener\\\" target=\\\"_blank\\\">label</a></p>\",\n            \"<a href=\\\"http://xwiki.org\\\" target=\\\"_blank\\\" rel=\\\"noreferrer\\\">label</a>\");\n        assertHTML(\"<p><a href=\\\"http://xwiki.org\\\" rel=\\\"hello noopener noreferrer\\\" target=\\\"_blank\\\">label</a></p>\",\n            \"<a href=\\\"http://xwiki.org\\\" target=\\\"_blank\\\" rel=\\\"hello\\\">label</a>\");\n    }\n\n    @Test\n    void verifyEntitiesAreNotBroken()\n    {\n        Document document = clean(\"<p>&Eacute;</p>\");\n        String content = document.getElementsByTagName(\"p\").item(0).getTextContent();\n        assertEquals(\"\u00c9\", content);\n        assertHTML(\"<p>\u00c9</p>\", \"&Eacute;\");\n\n        document = clean(\"<p>&frac14;</p>\");\n        content = document.getElementsByTagName(\"p\").item(0).getTextContent();\n        assertEquals(\"\u00bc\", content);\n        assertHTML(\"<p>\u00bc</p>\", \"&frac14;\");\n\n        document = clean(\"<p>&f!rac14;</p>\");\n        content = document.getElementsByTagName(\"p\").item(0).getTextContent();\n        assertEquals(\"&f!rac14;\", content);\n        assertHTML(\"<p>&amp;f!rac14;</p>\", \"&f!rac14;\");\n\n        document = clean(\"<p>&frac12;</p>\");\n        content = document.getElementsByTagName(\"p\").item(0).getTextContent();\n        assertEquals(\"\u00bd\", content);\n        assertHTML(\"<p>\u00bd</p>\", \"&frac12;\");\n    }\n\n    @Test\n    void entitiesWithTranslation()\n    {\n        String content = \"<p>1&gt;2&amp;3&nbsp;4&frac12;5\u00f6\u00fc\u00e4\u0103\u00e2\u00ee\u0219</p>\";\n        String expectedContent = \"1>2&3\u00a04\u00bd5\u00f6\u00fc\u00e4\u0103\u00e2\u00ee\u0219\";\n        Document document = clean(content);\n        String obtainedContent = document.getElementsByTagName(\"p\").item(0).getTextContent();\n        assertEquals(expectedContent, obtainedContent);\n        assertHTML(\"<p>1&gt;2&amp;3\u00a04\u00bd5\u00f6\u00fc\u00e4\u0103\u00e2\u00ee\u0219</p>\", content);\n\n        Map<String, String> parameters = new HashMap<>(this.cleanerConfiguration.getParameters());\n        parameters.put(HTMLCleanerConfiguration.TRANSLATE_SPECIAL_ENTITIES, \"true\");\n        this.cleanerConfiguration.setParameters(parameters);\n        assertHTML(\"<p>1&amp;gt;2&amp;amp;3\u00a04\u00bd5\u00f6\u00fc\u00e4\u0103\u00e2\u00ee\u0219</p>\",\n            \"<p>1&gt;2&amp;3&nbsp;4&frac12;5\u00f6\u00fc\u00e4\u0103\u00e2\u00ee\u0219</p>\");\n    }\n\n    @Test\n    void verifyLeadingSpacesAreKeptOnlyInInputValue()\n    {\n        assertHTML(\"<p><input type=\\\"hidden\\\" value=\\\"  fff\\\" /></p>\", \"<input type=\\\"hidden\\\" value=\\\"  fff\\\" />\");\n        assertHTML(\"<p><input type=\\\"hidden\\\" value=\\\"foo\\\" /></p>\", \"<input type=\\\"hidden\\\" value=\\\"foo\\\" />\");\n        assertHTML(\"<p><input type=\\\"hidden\\\" value=\\\"foo bar\\\" /></p>\", \"<input type=\\\"hidden\\\" value=\\\"foo bar\\\" />\");\n        assertHTML(\"<p><input class=\\\"fff\\\" type=\\\"hidden\\\" /></p>\", \"<input type=\\\"hidden\\\" class=\\\"  fff\\\" />\");\n        assertHTML(\"<p><input class=\\\"foo bar\\\" type=\\\"hidden\\\" value=\\\" foo bar  \\\" /></p>\",\n            \"<input type=\\\"hidden   \\\" value=\\\" foo bar  \\\" class=\\\" foo bar  \\\"/>\");\n        assertHTML(\"<div class=\\\"foo bar\\\" title=\\\"foo bar\\\"></div>\",\n            \"<div title=\\\" foo bar  \\\" class=\\\" foo bar  \\\"/>\");\n    }\n\n    /**\n     * @see <a href=\"https://jira.xwiki.org/browse/XCOMMONS-1293\">XCOMMONS-1293</a>\n     */\n    @Test\n    void verifyIFRAMECleaning() throws Exception\n    {\n        // TODO: these 2 lines need to be changed to the following when https://jira.xwiki.org/browse/XCOMMONS-1292 is\n        // fixed:\n        //          assertHTML(\"<iframe src=\\\"whatever\\\"></iframe>\", \"<iframe src=\\\"whatever\\\"/>\");\n        //          assertHTML(\"<iframe src=\\\"whatever\\\"></iframe>\\r\\n\", \"<iframe src=\\\"whatever\\\"/>\\r\\n\");\n        assertHTML(\"<p><iframe src=\\\"whatever\\\"></iframe></p>\", \"<iframe src=\\\"whatever\\\"/>\");\n        assertHTML(\"<p><iframe src=\\\"whatever\\\"></iframe>\\r\\n</p>\", \"<iframe src=\\\"whatever\\\"/>\\r\\n\");\n        assertHTML(\"<p>\\r\\n<iframe src=\\\"whatever\\\"></iframe></p>\", \"\\r\\n<iframe src=\\\"whatever\\\"/>\");\n        assertHTML(\"<p>\\r\\n<iframe src=\\\"whatever\\\"></iframe>\\r\\n</p>\", \"\\r\\n<iframe src=\\\"whatever\\\"/>\\r\\n\");\n        assertHTML(\"<p><iframe src=\\\"whatever\\\"></iframe><iframe src=\\\"whatever\\\"></iframe></p>\",\n            \"<iframe src=\\\"whatever\\\"/><iframe src=\\\"whatever\\\"/>\");\n        assertHTML(\"<p><iframe src=\\\"whatever\\\"></iframe>\\r\\n<iframe src=\\\"whatever\\\"></iframe></p>\",\n            \"<iframe src=\\\"whatever\\\"/>\\r\\n<iframe src=\\\"whatever\\\"/>\");\n        assertHTML(\"<p>\\r\\n<iframe src=\\\"whatever\\\"></iframe>\\r\\n<iframe src=\\\"whatever\\\"></iframe>\\r\\n</p>\",\n            \"\\r\\n<iframe src=\\\"whatever\\\"/>\\r\\n<iframe src=\\\"whatever\\\"/>\\r\\n\");\n    }\n\n    @Test\n    void escapeHTMLCharsInAttributes() throws Exception\n    {\n        // Note: single quotes are not escaped since they're valid chars in attribute values that are surrounded by\n        // quotes. And HTMLCleaner will convert single quoted attributes into double-quoted ones.\n        String htmlInput = \"<div foo=\\\"aaa&quot;bbb&amp;ccc&gt;ddd&lt;eee&apos;fff\\\">content</div>\";\n        Document document = clean(htmlInput);\n\n        String textContent =\n            document.getElementsByTagName(\"div\").item(0).getAttributes().getNamedItem(\"foo\").getTextContent();\n        assertEquals(\"aaa\\\"bbb&ccc>ddd<eee'fff\", textContent);\n\n        htmlInput = \"<div foo='aaa&quot;bbb&amp;ccc&gt;ddd&lt;eee&apos;fff'>content</div>\";\n        document = clean(htmlInput);\n\n        textContent =\n            document.getElementsByTagName(\"div\").item(0).getAttributes().getNamedItem(\"foo\").getTextContent();\n        assertEquals(\"aaa\\\"bbb&ccc>ddd<eee'fff\", textContent);\n\n        assertHTML(\"<div foo=\\\"aaa&quot;bbb&amp;ccc&gt;ddd&lt;eee'fff\\\">content</div>\",\n            \"<div foo=\\\"aaa&quot;bbb&amp;ccc&gt;ddd&lt;eee&apos;fff\\\">content</div>\");\n        assertHTML(\"<div foo=\\\"aaa&quot;bbb&amp;ccc&gt;ddd&lt;eee'fff\\\">content</div>\",\n            \"<div foo='aaa&quot;bbb&amp;ccc&gt;ddd&lt;eee&apos;fff'>content</div>\");\n    }\n\n    @Test\n    void controlCharacters() throws Exception\n    {\n        String htmlInput = \"<p>\\u0008</p>\";\n        Document document = clean(htmlInput);\n\n        String textContent =\n            document.getElementsByTagName(\"p\").item(0).getTextContent();\n        assertEquals(\" \", textContent);\n        assertHTML(\" \", \"\\u0008\");\n\n        htmlInput = \"<p>&#8;</p>\";\n        document = clean(htmlInput);\n\n        // HtmlCleaner currently doesn't handle properly unicode characters: asking it to recognize them\n        // involves that all entities will be escaped during the parsing and that's not what we want. So we\n        // keep them encoded.\n        // See https://sourceforge.net/p/htmlcleaner/bugs/221/\n        textContent =\n            document.getElementsByTagName(\"p\").item(0).getTextContent();\n        assertEquals(\"&#8;\", textContent);\n        assertHTML(\"<p>&#8;</p>\", \"&#8;\");\n\n        htmlInput = \"<p foo=\\\"&#8;\\\">content</p>\";\n        document = clean(htmlInput);\n\n        // HtmlCleaner currently doesn't handle properly unicode characters: asking it to recognize them\n        // involves that all entities will be escaped during the parsing and that's not what we want. So we\n        // keep them encoded.\n        textContent =\n            document.getElementsByTagName(\"p\").item(0).getAttributes().getNamedItem(\"foo\").getTextContent();\n        assertEquals(\"&#8;\", textContent);\n        assertHTML(\"<p foo=\\\"&#8;\\\">content</p>\", \"<p foo=\\\"&#8;\\\">content</p>\");\n    }\n\n    @Test\n    void ttElement()\n    {\n        assertHTML(\"<p><tt>Monospace Text</tt></p>\", \"<tt>Monospace Text</tt>\");\n    }\n\n    @Test\n    void divInsideDl()\n    {\n        // Check for https://jira.xwiki.org/browse/XCOMMONS-2375 - div inside dl should be allowed.\n        assertHTML(\n            \"<dl><div><dt>HTML</dt><dd>Hypertext Markup Language</dd></div><dt>another</dt><dd>entry</dd></dl>\",\n            \"<dl><div><dt>HTML<dd>Hypertext Markup Language</div><dt>another<dd>entry</dl>\");\n    }\n\n    /**\n     * Check what happens when the dt-tag is inside div.\n     * <p>\n     * This should add a wrapping dl but doesn't for HTML 4, but it works in HTML5, see\n     * {@link HTML5HTMLCleanerTest#divWithDt()}.\n     *\n     * @todo Replace by {@link HTML5HTMLCleanerTest#divWithDt()} if this should be fixed and this test is failing.\n     */\n    @Test\n    void divWithDt()\n    {\n        assertHTML(\"<div><dt>HTML</dt><dd>Hypertext Markup Language</dd></div>\",\n            \"<div><dt>HTML<dd>Hypertext Markup Language</div>\");\n    }\n\n    /**\n     * Check if plain text is allowed inside a div in dl - it shouldn't be but isn't filtered currently.\n     * <p>\n     * Note: even though this test is passing XWiki should not depend on this behavior.\n     *\n     * @todo Test with a valid expected HTML string when HTMLCleaner starts cleaning this.\n     */\n    @Test\n    void dlWithoutDt()\n    {\n        String htmlInput = \"<dl><div><strong>Hello!</strong></div></dl>\";\n        assertHTML(htmlInput, htmlInput);\n    }\n\n    protected void assertHTML(String expected, String actual)\n    {\n        Document documentValue = clean(actual);\n        assertEquals(getHeaderFull() + expected + FOOTER, HTMLUtils.toString(documentValue));\n    }\n\n    protected void assertHTMLWithHeadContent(String expected, String actual)\n    {\n        assertEquals(getHeader() + \"<html><head>\" + expected + \"</head><body>\" + FOOTER,\n            HTMLUtils.toString(clean(actual)));\n    }\n\n    @Test\n    void transformedDOMContent()\n    {\n        String htmlInput = \"<img src=\\\"http://host.com/a.gif?a=foo&b=bar\\\" />\";\n        Document document = clean(htmlInput);\n\n        String textContent =\n            document.getElementsByTagName(\"img\").item(0).getAttributes().getNamedItem(\"src\").getTextContent();\n        assertEquals(\"http://host.com/a.gif?a=foo&b=bar\", textContent);\n\n        htmlInput = \"<img src=\\\"http://host.com/a.gif?a=foo&amp;b=bar\\\" />\";\n        document = clean(htmlInput);\n\n        textContent =\n            document.getElementsByTagName(\"img\").item(0).getAttributes().getNamedItem(\"src\").getTextContent();\n        assertEquals(\"http://host.com/a.gif?a=foo&b=bar\", textContent);\n    }\n\n    @Test\n    public void preserveDoubleEscapingInAttributes() throws Exception\n    {\n        CleanerProperties cleanerProperties = new CleanerProperties();\n        cleanerProperties.setDeserializeEntities(true);\n        HtmlCleaner cleaner = new HtmlCleaner(cleanerProperties);\n        TagNode tagNode = cleaner.clean(\"<?xml version = \\\"1.0\\\"?><div foo=\\\"&amp;quot;\\\">&amp;quot;</div>\");\n        List<? extends TagNode> divList = tagNode.getElementListByName(\"div\", true);\n        assertEquals(1, divList.size());\n        assertEquals(\"&quot;\", divList.get(0).getText().toString());\n        // This assert is failing: the attribute is deserialized to contain \".\n        assertEquals(\"&quot;\", divList.get(0).getAttributeByName(\"foo\"));\n\n        DomSerializer domSerializer = new DomSerializer(cleanerProperties, false);\n        Document document = domSerializer.createDOM(tagNode);\n\n        NodeList nodeList = document.getElementsByTagName(\"div\");\n        assertEquals(1, nodeList.getLength());\n        assertEquals(\"&quot;\", nodeList.item(0).getTextContent());\n        assertEquals(\"&quot;\", nodeList.item(0).getAttributes().getNamedItem(\"foo\").getTextContent());\n\n        document = clean(\"<div foo=\\\"&amp;quot;\\\">&amp;quot;</div>\");\n        nodeList = document.getElementsByTagName(\"div\");\n        assertEquals(1, nodeList.getLength());\n        assertEquals(\"&quot;\", nodeList.item(0).getTextContent());\n        // We can never retrieve the expected value here since the encoded &amp; has been lost earlier.\n        assertEquals(\"&quot;\", nodeList.item(0).getAttributes().getNamedItem(\"foo\").getTextContent());\n\n        assertHTML(\"<div foo=\\\"&amp;quot;\\\">content</div>\",\n            \"<div foo=\\\"&amp;quot;\\\">content</div>\");\n    }\n\n    @Test\n    @Disabled(\"See https://sourceforge.net/p/htmlcleaner/bugs/221/\")\n    public void parseWithUnicodeChars() throws Exception\n    {\n        CleanerProperties cleanerProperties = new CleanerProperties();\n\n        cleanerProperties.setDeserializeEntities(true);\n        cleanerProperties.setRecognizeUnicodeChars(true);\n        cleanerProperties.setTranslateSpecialEntities(false);\n\n        HtmlCleaner cleaner = new HtmlCleaner(cleanerProperties);\n        TagNode tagNode = cleaner.clean(\"<?xml version = \\\"1.0\\\"?>\"\n            + \"<div foo=\\\"&#169;\\\">&#169;</div>\"\n            + \"<div foo=\\\"baz&gt;buz\\\">baz&gt;buz</div>\"\n            + \"<div foo=\\\"baz&buz\\\">baz&buz</div>\");\n        List<? extends TagNode> divList = tagNode.getElementListByName(\"div\", true);\n        assertEquals(3, divList.size());\n\n        assertEquals(\"\u00a9\", divList.get(0).getText().toString());\n        assertEquals(\"\u00a9\", divList.get(0).getAttributeByName(\"foo\"));\n\n        assertEquals(\"baz>buz\", divList.get(1).getText().toString());\n        assertEquals(\"baz>buz\", divList.get(1).getAttributeByName(\"foo\"));\n\n        assertEquals(\"baz&buz\", divList.get(2).getText().toString());\n        assertEquals(\"baz&buz\", divList.get(2).getAttributeByName(\"foo\"));\n\n        DomSerializer domSerializer = new DomSerializer(cleanerProperties, false);\n        Document document = domSerializer.createDOM(tagNode);\n\n        NodeList nodeList = document.getElementsByTagName(\"div\");\n        assertEquals(3, nodeList.getLength());\n        assertEquals(\"\u00a9\", nodeList.item(0).getTextContent());\n        assertEquals(\"\u00a9\", nodeList.item(0).getAttributes().getNamedItem(\"foo\").getTextContent());\n\n        assertEquals(\"baz>buz\", nodeList.item(1).getAttributes().getNamedItem(\"foo\").getTextContent());\n\n        assertEquals(\"baz&buz\", nodeList.item(2).getAttributes().getNamedItem(\"foo\").getTextContent());\n\n        // BUG: This is failing with baz&gt;buz\n        assertEquals(\"baz>buz\", nodeList.item(1).getTextContent());\n        // BUG: This is failing with baz&amp;buz\n        assertEquals(\"baz&buz\", nodeList.item(2).getTextContent());\n    }\n\n    @Test\n    public void followingEncodedEntitiesAreProperlyKept()\n    {\n        String content = \"<p><textarea>&#123;&#123;velocity}}machin&#123;&#123;/velocity}}</textarea></p>\";\n        Document document = clean(content);\n        String textareaContent = document.getElementsByTagName(\"textarea\").item(0).getTextContent();\n        assertEquals(\"&#123;&#123;velocity}}machin&#123;&#123;/velocity}}\", textareaContent);\n\n        assertHTML(\"<p><textarea>&#123;&#123;velocity}}machin&#123;&#123;/velocity}}</textarea></p>\", content);\n    }\n}\n"], "filenames": ["xwiki-commons-core/xwiki-commons-xml/src/main/java/org/xwiki/xml/html/HTMLUtils.java", "xwiki-commons-core/xwiki-commons-xml/src/main/java/org/xwiki/xml/internal/html/DefaultHTMLCleaner.java", "xwiki-commons-core/xwiki-commons-xml/src/test/java/org/xwiki/xml/internal/html/DefaultHTMLCleanerTest.java"], "buggy_code_start_loc": [28, 269, 35], "buggy_code_end_loc": [181, 336, 327], "fixing_code_start_loc": [29, 270, 36], "fixing_code_end_loc": [199, 353, 368], "type": "CWE-79", "message": "XWiki Commons are technical libraries common to several other top level XWiki projects. The \"restricted\" mode of the HTML cleaner in XWiki, introduced in version 4.2-milestone-1 and massively improved in version 14.6-rc-1, allowed the injection of arbitrary HTML code and thus cross-site scripting via invalid HTML comments. As a consequence, any code relying on this \"restricted\" mode for security is vulnerable to JavaScript injection (\"cross-site scripting\"/XSS). When a privileged user with programming rights visits such a comment in XWiki, the malicious JavaScript code is executed in the context of the user session. This allows server-side code execution with programming rights, impacting the confidentiality, integrity and availability of the XWiki instance. This problem has been patched in XWiki 14.10, HTML comments are now removed in restricted mode and a check has been introduced that ensures that comments don't start with `>`. There are no known workarounds apart from upgrading to a version including the fix.\n", "other": {"cve": {"id": "CVE-2023-29528", "sourceIdentifier": "security-advisories@github.com", "published": "2023-04-20T18:15:07.307", "lastModified": "2023-05-01T15:46:06.867", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "XWiki Commons are technical libraries common to several other top level XWiki projects. The \"restricted\" mode of the HTML cleaner in XWiki, introduced in version 4.2-milestone-1 and massively improved in version 14.6-rc-1, allowed the injection of arbitrary HTML code and thus cross-site scripting via invalid HTML comments. As a consequence, any code relying on this \"restricted\" mode for security is vulnerable to JavaScript injection (\"cross-site scripting\"/XSS). When a privileged user with programming rights visits such a comment in XWiki, the malicious JavaScript code is executed in the context of the user session. This allows server-side code execution with programming rights, impacting the confidentiality, integrity and availability of the XWiki instance. This problem has been patched in XWiki 14.10, HTML comments are now removed in restricted mode and a check has been introduced that ensures that comments don't start with `>`. There are no known workarounds apart from upgrading to a version including the fix.\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.3, "impactScore": 6.0}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.3, "impactScore": 6.0}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:commons:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.3", "versionEndExcluding": "14.10", "matchCriteriaId": "03911D90-117F-4EFD-9CA9-D6F653CB1D48"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:commons:4.2:-:*:*:*:*:*:*", "matchCriteriaId": "C514853A-989A-4BED-A653-D1578DB40157"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:commons:4.2:milestone1:*:*:*:*:*:*", "matchCriteriaId": "36E79F9F-67BC-4E06-9882-DEA941AEF84B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:commons:4.2:milestone2:*:*:*:*:*:*", "matchCriteriaId": "9BE5ECE0-5A68-4B4F-9752-8C2F46AE9009"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:commons:4.2:milestone3:*:*:*:*:*:*", "matchCriteriaId": "60F8E581-DBE8-407C-970A-0ED230F074BB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:commons:4.2:rc1:*:*:*:*:*:*", "matchCriteriaId": "8D23E926-03F5-4EC0-B8D7-434F97D01A8B"}]}]}], "references": [{"url": "https://github.com/xwiki/xwiki-commons/commit/8ff1a9d7e5d7b45b690134a537d53dc05cae04ab", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/xwiki/xwiki-commons/security/advisories/GHSA-x37v-36wv-6v6h", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://jira.xwiki.org/browse/XCOMMONS-2568", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://jira.xwiki.org/browse/XWIKI-20348", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/xwiki/xwiki-commons/commit/8ff1a9d7e5d7b45b690134a537d53dc05cae04ab"}}