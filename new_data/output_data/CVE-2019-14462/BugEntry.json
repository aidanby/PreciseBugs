{"buggy_code": ["/*\n * Copyright \u00a9 2001-2011 St\u00e9phane Raimbault <stephane.raimbault@gmail.com>\n *\n * SPDX-License-Identifier: LGPL-2.1+\n *\n * This library implements the Modbus protocol.\n * http://libmodbus.org/\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <errno.h>\n#include <limits.h>\n#include <time.h>\n#ifndef _MSC_VER\n#include <unistd.h>\n#endif\n\n#include <config.h>\n\n#include \"modbus.h\"\n#include \"modbus-private.h\"\n\n/* Internal use */\n#define MSG_LENGTH_UNDEFINED -1\n\n/* Exported version */\nconst unsigned int libmodbus_version_major = LIBMODBUS_VERSION_MAJOR;\nconst unsigned int libmodbus_version_minor = LIBMODBUS_VERSION_MINOR;\nconst unsigned int libmodbus_version_micro = LIBMODBUS_VERSION_MICRO;\n\n/* Max between RTU and TCP max adu length (so TCP) */\n#define MAX_MESSAGE_LENGTH 260\n\n/* 3 steps are used to parse the query */\ntypedef enum {\n    _STEP_FUNCTION,\n    _STEP_META,\n    _STEP_DATA\n} _step_t;\n\nconst char *modbus_strerror(int errnum) {\n    switch (errnum) {\n    case EMBXILFUN:\n        return \"Illegal function\";\n    case EMBXILADD:\n        return \"Illegal data address\";\n    case EMBXILVAL:\n        return \"Illegal data value\";\n    case EMBXSFAIL:\n        return \"Slave device or server failure\";\n    case EMBXACK:\n        return \"Acknowledge\";\n    case EMBXSBUSY:\n        return \"Slave device or server is busy\";\n    case EMBXNACK:\n        return \"Negative acknowledge\";\n    case EMBXMEMPAR:\n        return \"Memory parity error\";\n    case EMBXGPATH:\n        return \"Gateway path unavailable\";\n    case EMBXGTAR:\n        return \"Target device failed to respond\";\n    case EMBBADCRC:\n        return \"Invalid CRC\";\n    case EMBBADDATA:\n        return \"Invalid data\";\n    case EMBBADEXC:\n        return \"Invalid exception code\";\n    case EMBMDATA:\n        return \"Too many data\";\n    case EMBBADSLAVE:\n        return \"Response not from requested slave\";\n    default:\n        return strerror(errnum);\n    }\n}\n\nvoid _error_print(modbus_t *ctx, const char *context)\n{\n    if (ctx->debug) {\n        fprintf(stderr, \"ERROR %s\", modbus_strerror(errno));\n        if (context != NULL) {\n            fprintf(stderr, \": %s\\n\", context);\n        } else {\n            fprintf(stderr, \"\\n\");\n        }\n    }\n}\n\nstatic void _sleep_response_timeout(modbus_t *ctx)\n{\n    /* Response timeout is always positive */\n#ifdef _WIN32\n    /* usleep doesn't exist on Windows */\n    Sleep((ctx->response_timeout.tv_sec * 1000) +\n          (ctx->response_timeout.tv_usec / 1000));\n#else\n    /* usleep source code */\n    struct timespec request, remaining;\n    request.tv_sec = ctx->response_timeout.tv_sec;\n    request.tv_nsec = ((long int)ctx->response_timeout.tv_usec) * 1000;\n    while (nanosleep(&request, &remaining) == -1 && errno == EINTR) {\n        request = remaining;\n    }\n#endif\n}\n\nint modbus_flush(modbus_t *ctx)\n{\n    int rc;\n\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    rc = ctx->backend->flush(ctx);\n    if (rc != -1 && ctx->debug) {\n        /* Not all backends are able to return the number of bytes flushed */\n        printf(\"Bytes flushed (%d)\\n\", rc);\n    }\n    return rc;\n}\n\n/* Computes the length of the expected response */\nstatic unsigned int compute_response_length_from_request(modbus_t *ctx, uint8_t *req)\n{\n    int length;\n    const int offset = ctx->backend->header_length;\n\n    switch (req[offset]) {\n    case MODBUS_FC_READ_COILS:\n    case MODBUS_FC_READ_DISCRETE_INPUTS: {\n        /* Header + nb values (code from write_bits) */\n        int nb = (req[offset + 3] << 8) | req[offset + 4];\n        length = 2 + (nb / 8) + ((nb % 8) ? 1 : 0);\n    }\n        break;\n    case MODBUS_FC_WRITE_AND_READ_REGISTERS:\n    case MODBUS_FC_READ_HOLDING_REGISTERS:\n    case MODBUS_FC_READ_INPUT_REGISTERS:\n        /* Header + 2 * nb values */\n        length = 2 + 2 * (req[offset + 3] << 8 | req[offset + 4]);\n        break;\n    case MODBUS_FC_READ_EXCEPTION_STATUS:\n        length = 3;\n        break;\n    case MODBUS_FC_REPORT_SLAVE_ID:\n        /* The response is device specific (the header provides the\n           length) */\n        return MSG_LENGTH_UNDEFINED;\n    case MODBUS_FC_MASK_WRITE_REGISTER:\n        length = 7;\n        break;\n    default:\n        length = 5;\n    }\n\n    return offset + length + ctx->backend->checksum_length;\n}\n\n/* Sends a request/response */\nstatic int send_msg(modbus_t *ctx, uint8_t *msg, int msg_length)\n{\n    int rc;\n    int i;\n\n    msg_length = ctx->backend->send_msg_pre(msg, msg_length);\n\n    if (ctx->debug) {\n        for (i = 0; i < msg_length; i++)\n            printf(\"[%.2X]\", msg[i]);\n        printf(\"\\n\");\n    }\n\n    /* In recovery mode, the write command will be issued until to be\n       successful! Disabled by default. */\n    do {\n        rc = ctx->backend->send(ctx, msg, msg_length);\n        if (rc == -1) {\n            _error_print(ctx, NULL);\n            if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_LINK) {\n                int saved_errno = errno;\n\n                if ((errno == EBADF || errno == ECONNRESET || errno == EPIPE)) {\n                    modbus_close(ctx);\n                    _sleep_response_timeout(ctx);\n                    modbus_connect(ctx);\n                } else {\n                    _sleep_response_timeout(ctx);\n                    modbus_flush(ctx);\n                }\n                errno = saved_errno;\n            }\n        }\n    } while ((ctx->error_recovery & MODBUS_ERROR_RECOVERY_LINK) &&\n             rc == -1);\n\n    if (rc > 0 && rc != msg_length) {\n        errno = EMBBADDATA;\n        return -1;\n    }\n\n    return rc;\n}\n\nint modbus_send_raw_request(modbus_t *ctx, uint8_t *raw_req, int raw_req_length)\n{\n    sft_t sft;\n    uint8_t req[MAX_MESSAGE_LENGTH];\n    int req_length;\n\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    if (raw_req_length < 2 || raw_req_length > (MODBUS_MAX_PDU_LENGTH + 1)) {\n        /* The raw request must contain function and slave at least and\n           must not be longer than the maximum pdu length plus the slave\n           address. */\n        errno = EINVAL;\n        return -1;\n    }\n\n    sft.slave = raw_req[0];\n    sft.function = raw_req[1];\n    /* The t_id is left to zero */\n    sft.t_id = 0;\n    /* This response function only set the header so it's convenient here */\n    req_length = ctx->backend->build_response_basis(&sft, req);\n\n    if (raw_req_length > 2) {\n        /* Copy data after function code */\n        memcpy(req + req_length, raw_req + 2, raw_req_length - 2);\n        req_length += raw_req_length - 2;\n    }\n\n    return send_msg(ctx, req, req_length);\n}\n\n/*\n *  ---------- Request     Indication ----------\n *  | Client | ---------------------->| Server |\n *  ---------- Confirmation  Response ----------\n */\n\n/* Computes the length to read after the function received */\nstatic uint8_t compute_meta_length_after_function(int function,\n                                                  msg_type_t msg_type)\n{\n    int length;\n\n    if (msg_type == MSG_INDICATION) {\n        if (function <= MODBUS_FC_WRITE_SINGLE_REGISTER) {\n            length = 4;\n        } else if (function == MODBUS_FC_WRITE_MULTIPLE_COILS ||\n                   function == MODBUS_FC_WRITE_MULTIPLE_REGISTERS) {\n            length = 5;\n        } else if (function == MODBUS_FC_MASK_WRITE_REGISTER) {\n            length = 6;\n        } else if (function == MODBUS_FC_WRITE_AND_READ_REGISTERS) {\n            length = 9;\n        } else {\n            /* MODBUS_FC_READ_EXCEPTION_STATUS, MODBUS_FC_REPORT_SLAVE_ID */\n            length = 0;\n        }\n    } else {\n        /* MSG_CONFIRMATION */\n        switch (function) {\n        case MODBUS_FC_WRITE_SINGLE_COIL:\n        case MODBUS_FC_WRITE_SINGLE_REGISTER:\n        case MODBUS_FC_WRITE_MULTIPLE_COILS:\n        case MODBUS_FC_WRITE_MULTIPLE_REGISTERS:\n            length = 4;\n            break;\n        case MODBUS_FC_MASK_WRITE_REGISTER:\n            length = 6;\n            break;\n        default:\n            length = 1;\n        }\n    }\n\n    return length;\n}\n\n/* Computes the length to read after the meta information (address, count, etc) */\nstatic int compute_data_length_after_meta(modbus_t *ctx, uint8_t *msg,\n                                          msg_type_t msg_type)\n{\n    int function = msg[ctx->backend->header_length];\n    int length;\n\n    if (msg_type == MSG_INDICATION) {\n        switch (function) {\n        case MODBUS_FC_WRITE_MULTIPLE_COILS:\n        case MODBUS_FC_WRITE_MULTIPLE_REGISTERS:\n            length = msg[ctx->backend->header_length + 5];\n            break;\n        case MODBUS_FC_WRITE_AND_READ_REGISTERS:\n            length = msg[ctx->backend->header_length + 9];\n            break;\n        default:\n            length = 0;\n        }\n    } else {\n        /* MSG_CONFIRMATION */\n        if (function <= MODBUS_FC_READ_INPUT_REGISTERS ||\n            function == MODBUS_FC_REPORT_SLAVE_ID ||\n            function == MODBUS_FC_WRITE_AND_READ_REGISTERS) {\n            length = msg[ctx->backend->header_length + 1];\n        } else {\n            length = 0;\n        }\n    }\n\n    length += ctx->backend->checksum_length;\n\n    return length;\n}\n\n\n/* Waits a response from a modbus server or a request from a modbus client.\n   This function blocks if there is no replies (3 timeouts).\n\n   The function shall return the number of received characters and the received\n   message in an array of uint8_t if successful. Otherwise it shall return -1\n   and errno is set to one of the values defined below:\n   - ECONNRESET\n   - EMBBADDATA\n   - EMBUNKEXC\n   - ETIMEDOUT\n   - read() or recv() error codes\n*/\n\nint _modbus_receive_msg(modbus_t *ctx, uint8_t *msg, msg_type_t msg_type)\n{\n    int rc;\n    fd_set rset;\n    struct timeval tv;\n    struct timeval *p_tv;\n    int length_to_read;\n    int msg_length = 0;\n    _step_t step;\n\n    if (ctx->debug) {\n        if (msg_type == MSG_INDICATION) {\n            printf(\"Waiting for an indication...\\n\");\n        } else {\n            printf(\"Waiting for a confirmation...\\n\");\n        }\n    }\n\n    /* Add a file descriptor to the set */\n    FD_ZERO(&rset);\n    FD_SET(ctx->s, &rset);\n\n    /* We need to analyse the message step by step.  At the first step, we want\n     * to reach the function code because all packets contain this\n     * information. */\n    step = _STEP_FUNCTION;\n    length_to_read = ctx->backend->header_length + 1;\n\n    if (msg_type == MSG_INDICATION) {\n        /* Wait for a message, we don't know when the message will be\n         * received */\n        if (ctx->indication_timeout.tv_sec == 0 && ctx->indication_timeout.tv_usec == 0) {\n            /* By default, the indication timeout isn't set */\n            p_tv = NULL;\n        } else {\n            /* Wait for an indication (name of a received request by a server, see schema) */\n            tv.tv_sec = ctx->indication_timeout.tv_sec;\n            tv.tv_usec = ctx->indication_timeout.tv_usec;\n            p_tv = &tv;\n        }\n    } else {\n        tv.tv_sec = ctx->response_timeout.tv_sec;\n        tv.tv_usec = ctx->response_timeout.tv_usec;\n        p_tv = &tv;\n    }\n\n    while (length_to_read != 0) {\n        rc = ctx->backend->select(ctx, &rset, p_tv, length_to_read);\n        if (rc == -1) {\n            _error_print(ctx, \"select\");\n            if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_LINK) {\n                int saved_errno = errno;\n\n                if (errno == ETIMEDOUT) {\n                    _sleep_response_timeout(ctx);\n                    modbus_flush(ctx);\n                } else if (errno == EBADF) {\n                    modbus_close(ctx);\n                    modbus_connect(ctx);\n                }\n                errno = saved_errno;\n            }\n            return -1;\n        }\n\n        rc = ctx->backend->recv(ctx, msg + msg_length, length_to_read);\n        if (rc == 0) {\n            errno = ECONNRESET;\n            rc = -1;\n        }\n\n        if (rc == -1) {\n            _error_print(ctx, \"read\");\n            if ((ctx->error_recovery & MODBUS_ERROR_RECOVERY_LINK) &&\n                (errno == ECONNRESET || errno == ECONNREFUSED ||\n                 errno == EBADF)) {\n                int saved_errno = errno;\n                modbus_close(ctx);\n                modbus_connect(ctx);\n                /* Could be removed by previous calls */\n                errno = saved_errno;\n            }\n            return -1;\n        }\n\n        /* Display the hex code of each character received */\n        if (ctx->debug) {\n            int i;\n            for (i=0; i < rc; i++)\n                printf(\"<%.2X>\", msg[msg_length + i]);\n        }\n\n        /* Sums bytes received */\n        msg_length += rc;\n        /* Computes remaining bytes */\n        length_to_read -= rc;\n\n        if (length_to_read == 0) {\n            switch (step) {\n            case _STEP_FUNCTION:\n                /* Function code position */\n                length_to_read = compute_meta_length_after_function(\n                    msg[ctx->backend->header_length],\n                    msg_type);\n                if (length_to_read != 0) {\n                    step = _STEP_META;\n                    break;\n                } /* else switches straight to the next step */\n            case _STEP_META:\n                length_to_read = compute_data_length_after_meta(\n                    ctx, msg, msg_type);\n                if ((msg_length + length_to_read) > (int)ctx->backend->max_adu_length) {\n                    errno = EMBBADDATA;\n                    _error_print(ctx, \"too many data\");\n                    return -1;\n                }\n                step = _STEP_DATA;\n                break;\n            default:\n                break;\n            }\n        }\n\n        if (length_to_read > 0 &&\n            (ctx->byte_timeout.tv_sec > 0 || ctx->byte_timeout.tv_usec > 0)) {\n            /* If there is no character in the buffer, the allowed timeout\n               interval between two consecutive bytes is defined by\n               byte_timeout */\n            tv.tv_sec = ctx->byte_timeout.tv_sec;\n            tv.tv_usec = ctx->byte_timeout.tv_usec;\n            p_tv = &tv;\n        }\n        /* else timeout isn't set again, the full response must be read before\n           expiration of response timeout (for CONFIRMATION only) */\n    }\n\n    if (ctx->debug)\n        printf(\"\\n\");\n\n    return ctx->backend->check_integrity(ctx, msg, msg_length);\n}\n\n/* Receive the request from a modbus master */\nint modbus_receive(modbus_t *ctx, uint8_t *req)\n{\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    return ctx->backend->receive(ctx, req);\n}\n\n/* Receives the confirmation.\n\n   The function shall store the read response in rsp and return the number of\n   values (bits or words). Otherwise, its shall return -1 and errno is set.\n\n   The function doesn't check the confirmation is the expected response to the\n   initial request.\n*/\nint modbus_receive_confirmation(modbus_t *ctx, uint8_t *rsp)\n{\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    return _modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);\n}\n\nstatic int check_confirmation(modbus_t *ctx, uint8_t *req,\n                              uint8_t *rsp, int rsp_length)\n{\n    int rc;\n    int rsp_length_computed;\n    const int offset = ctx->backend->header_length;\n    const int function = rsp[offset];\n\n    if (ctx->backend->pre_check_confirmation) {\n        rc = ctx->backend->pre_check_confirmation(ctx, req, rsp, rsp_length);\n        if (rc == -1) {\n            if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {\n                _sleep_response_timeout(ctx);\n                modbus_flush(ctx);\n            }\n            return -1;\n        }\n    }\n\n    rsp_length_computed = compute_response_length_from_request(ctx, req);\n\n    /* Exception code */\n    if (function >= 0x80) {\n        if (rsp_length == (offset + 2 + (int)ctx->backend->checksum_length) &&\n            req[offset] == (rsp[offset] - 0x80)) {\n            /* Valid exception code received */\n\n            int exception_code = rsp[offset + 1];\n            if (exception_code < MODBUS_EXCEPTION_MAX) {\n                errno = MODBUS_ENOBASE + exception_code;\n            } else {\n                errno = EMBBADEXC;\n            }\n            _error_print(ctx, NULL);\n            return -1;\n        } else {\n            errno = EMBBADEXC;\n            _error_print(ctx, NULL);\n            return -1;\n        }\n    }\n\n    /* Check length */\n    if ((rsp_length == rsp_length_computed ||\n         rsp_length_computed == MSG_LENGTH_UNDEFINED) &&\n        function < 0x80) {\n        int req_nb_value;\n        int rsp_nb_value;\n\n        /* Check function code */\n        if (function != req[offset]) {\n            if (ctx->debug) {\n                fprintf(stderr,\n                        \"Received function not corresponding to the request (0x%X != 0x%X)\\n\",\n                        function, req[offset]);\n            }\n            if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {\n                _sleep_response_timeout(ctx);\n                modbus_flush(ctx);\n            }\n            errno = EMBBADDATA;\n            return -1;\n        }\n\n        /* Check the number of values is corresponding to the request */\n        switch (function) {\n        case MODBUS_FC_READ_COILS:\n        case MODBUS_FC_READ_DISCRETE_INPUTS:\n            /* Read functions, 8 values in a byte (nb\n             * of values in the request and byte count in\n             * the response. */\n            req_nb_value = (req[offset + 3] << 8) + req[offset + 4];\n            req_nb_value = (req_nb_value / 8) + ((req_nb_value % 8) ? 1 : 0);\n            rsp_nb_value = rsp[offset + 1];\n            break;\n        case MODBUS_FC_WRITE_AND_READ_REGISTERS:\n        case MODBUS_FC_READ_HOLDING_REGISTERS:\n        case MODBUS_FC_READ_INPUT_REGISTERS:\n            /* Read functions 1 value = 2 bytes */\n            req_nb_value = (req[offset + 3] << 8) + req[offset + 4];\n            rsp_nb_value = (rsp[offset + 1] / 2);\n            break;\n        case MODBUS_FC_WRITE_MULTIPLE_COILS:\n        case MODBUS_FC_WRITE_MULTIPLE_REGISTERS:\n            /* N Write functions */\n            req_nb_value = (req[offset + 3] << 8) + req[offset + 4];\n            rsp_nb_value = (rsp[offset + 3] << 8) | rsp[offset + 4];\n            break;\n        case MODBUS_FC_REPORT_SLAVE_ID:\n            /* Report slave ID (bytes received) */\n            req_nb_value = rsp_nb_value = rsp[offset + 1];\n            break;\n        default:\n            /* 1 Write functions & others */\n            req_nb_value = rsp_nb_value = 1;\n        }\n\n        if (req_nb_value == rsp_nb_value) {\n            rc = rsp_nb_value;\n        } else {\n            if (ctx->debug) {\n                fprintf(stderr,\n                        \"Quantity not corresponding to the request (%d != %d)\\n\",\n                        rsp_nb_value, req_nb_value);\n            }\n\n            if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {\n                _sleep_response_timeout(ctx);\n                modbus_flush(ctx);\n            }\n\n            errno = EMBBADDATA;\n            rc = -1;\n        }\n    } else {\n        if (ctx->debug) {\n            fprintf(stderr,\n                    \"Message length not corresponding to the computed length (%d != %d)\\n\",\n                    rsp_length, rsp_length_computed);\n        }\n        if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {\n            _sleep_response_timeout(ctx);\n            modbus_flush(ctx);\n        }\n        errno = EMBBADDATA;\n        rc = -1;\n    }\n\n    return rc;\n}\n\nstatic int response_io_status(uint8_t *tab_io_status,\n                              int address, int nb,\n                              uint8_t *rsp, int offset)\n{\n    int shift = 0;\n    /* Instead of byte (not allowed in Win32) */\n    int one_byte = 0;\n    int i;\n\n    for (i = address; i < address + nb; i++) {\n        one_byte |= tab_io_status[i] << shift;\n        if (shift == 7) {\n            /* Byte is full */\n            rsp[offset++] = one_byte;\n            one_byte = shift = 0;\n        } else {\n            shift++;\n        }\n    }\n\n    if (shift != 0)\n        rsp[offset++] = one_byte;\n\n    return offset;\n}\n\n/* Build the exception response */\nstatic int response_exception(modbus_t *ctx, sft_t *sft,\n                              int exception_code, uint8_t *rsp,\n                              unsigned int to_flush,\n                              const char* template, ...)\n{\n    int rsp_length;\n\n    /* Print debug message */\n    if (ctx->debug) {\n        va_list ap;\n\n        va_start(ap, template);\n        vfprintf(stderr, template, ap);\n        va_end(ap);\n    }\n\n    /* Flush if required */\n    if (to_flush) {\n        _sleep_response_timeout(ctx);\n        modbus_flush(ctx);\n    }\n\n    /* Build exception response */\n    sft->function = sft->function + 0x80;\n    rsp_length = ctx->backend->build_response_basis(sft, rsp);\n    rsp[rsp_length++] = exception_code;\n\n    return rsp_length;\n}\n\n/* Send a response to the received request.\n   Analyses the request and constructs a response.\n\n   If an error occurs, this function construct the response\n   accordingly.\n*/\nint modbus_reply(modbus_t *ctx, const uint8_t *req,\n                 int req_length, modbus_mapping_t *mb_mapping)\n{\n    int offset;\n    int slave;\n    int function;\n    uint16_t address;\n    uint8_t rsp[MAX_MESSAGE_LENGTH];\n    int rsp_length = 0;\n    sft_t sft;\n\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    offset = ctx->backend->header_length;\n    slave = req[offset - 1];\n    function = req[offset];\n    address = (req[offset + 1] << 8) + req[offset + 2];\n\n    sft.slave = slave;\n    sft.function = function;\n    sft.t_id = ctx->backend->prepare_response_tid(req, &req_length);\n\n    /* Data are flushed on illegal number of values errors. */\n    switch (function) {\n    case MODBUS_FC_READ_COILS:\n    case MODBUS_FC_READ_DISCRETE_INPUTS: {\n        unsigned int is_input = (function == MODBUS_FC_READ_DISCRETE_INPUTS);\n        int start_bits = is_input ? mb_mapping->start_input_bits : mb_mapping->start_bits;\n        int nb_bits = is_input ? mb_mapping->nb_input_bits : mb_mapping->nb_bits;\n        uint8_t *tab_bits = is_input ? mb_mapping->tab_input_bits : mb_mapping->tab_bits;\n        const char * const name = is_input ? \"read_input_bits\" : \"read_bits\";\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        /* The mapping can be shifted to reduce memory consumption and it\n           doesn't always start at address zero. */\n        int mapping_address = address - start_bits;\n\n        if (nb < 1 || MODBUS_MAX_READ_BITS < nb) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal nb of values %d in %s (max %d)\\n\",\n                nb, name, MODBUS_MAX_READ_BITS);\n        } else if (mapping_address < 0 || (mapping_address + nb) > nb_bits) {\n            rsp_length = response_exception(\n                ctx, &sft,\n                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in %s\\n\",\n                mapping_address < 0 ? address : address + nb, name);\n        } else {\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            rsp[rsp_length++] = (nb / 8) + ((nb % 8) ? 1 : 0);\n            rsp_length = response_io_status(tab_bits, mapping_address, nb,\n                                            rsp, rsp_length);\n        }\n    }\n        break;\n    case MODBUS_FC_READ_HOLDING_REGISTERS:\n    case MODBUS_FC_READ_INPUT_REGISTERS: {\n        unsigned int is_input = (function == MODBUS_FC_READ_INPUT_REGISTERS);\n        int start_registers = is_input ? mb_mapping->start_input_registers : mb_mapping->start_registers;\n        int nb_registers = is_input ? mb_mapping->nb_input_registers : mb_mapping->nb_registers;\n        uint16_t *tab_registers = is_input ? mb_mapping->tab_input_registers : mb_mapping->tab_registers;\n        const char * const name = is_input ? \"read_input_registers\" : \"read_registers\";\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        /* The mapping can be shifted to reduce memory consumption and it\n           doesn't always start at address zero. */\n        int mapping_address = address - start_registers;\n\n        if (nb < 1 || MODBUS_MAX_READ_REGISTERS < nb) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal nb of values %d in %s (max %d)\\n\",\n                nb, name, MODBUS_MAX_READ_REGISTERS);\n        } else if (mapping_address < 0 || (mapping_address + nb) > nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in %s\\n\",\n                mapping_address < 0 ? address : address + nb, name);\n        } else {\n            int i;\n\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            rsp[rsp_length++] = nb << 1;\n            for (i = mapping_address; i < mapping_address + nb; i++) {\n                rsp[rsp_length++] = tab_registers[i] >> 8;\n                rsp[rsp_length++] = tab_registers[i] & 0xFF;\n            }\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_SINGLE_COIL: {\n        int mapping_address = address - mb_mapping->start_bits;\n\n        if (mapping_address < 0 || mapping_address >= mb_mapping->nb_bits) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_bit\\n\",\n                address);\n        } else {\n            int data = (req[offset + 3] << 8) + req[offset + 4];\n\n            if (data == 0xFF00 || data == 0x0) {\n                mb_mapping->tab_bits[mapping_address] = data ? ON : OFF;\n                memcpy(rsp, req, req_length);\n                rsp_length = req_length;\n            } else {\n                rsp_length = response_exception(\n                    ctx, &sft,\n                    MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, FALSE,\n                    \"Illegal data value 0x%0X in write_bit request at address %0X\\n\",\n                    data, address);\n            }\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_SINGLE_REGISTER: {\n        int mapping_address = address - mb_mapping->start_registers;\n\n        if (mapping_address < 0 || mapping_address >= mb_mapping->nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft,\n                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_register\\n\",\n                address);\n        } else {\n            int data = (req[offset + 3] << 8) + req[offset + 4];\n\n            mb_mapping->tab_registers[mapping_address] = data;\n            memcpy(rsp, req, req_length);\n            rsp_length = req_length;\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_MULTIPLE_COILS: {\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        int mapping_address = address - mb_mapping->start_bits;\n\n        if (nb < 1 || MODBUS_MAX_WRITE_BITS < nb) {\n            /* May be the indication has been truncated on reading because of\n             * invalid address (eg. nb is 0 but the request contains values to\n             * write) so it's necessary to flush. */\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal number of values %d in write_bits (max %d)\\n\",\n                nb, MODBUS_MAX_WRITE_BITS);\n        } else if (mapping_address < 0 ||\n                   (mapping_address + nb) > mb_mapping->nb_bits) {\n            rsp_length = response_exception(\n                ctx, &sft,\n                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_bits\\n\",\n                mapping_address < 0 ? address : address + nb);\n        } else {\n            /* 6 = byte count */\n            modbus_set_bits_from_bytes(mb_mapping->tab_bits, mapping_address, nb,\n                                       &req[offset + 6]);\n\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            /* 4 to copy the bit address (2) and the quantity of bits */\n            memcpy(rsp + rsp_length, req + rsp_length, 4);\n            rsp_length += 4;\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_MULTIPLE_REGISTERS: {\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        int mapping_address = address - mb_mapping->start_registers;\n\n        if (nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal number of values %d in write_registers (max %d)\\n\",\n                nb, MODBUS_MAX_WRITE_REGISTERS);\n        } else if (mapping_address < 0 ||\n                   (mapping_address + nb) > mb_mapping->nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_registers\\n\",\n                mapping_address < 0 ? address : address + nb);\n        } else {\n            int i, j;\n            for (i = mapping_address, j = 6; i < mapping_address + nb; i++, j += 2) {\n                /* 6 and 7 = first value */\n                mb_mapping->tab_registers[i] =\n                    (req[offset + j] << 8) + req[offset + j + 1];\n            }\n\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            /* 4 to copy the address (2) and the no. of registers */\n            memcpy(rsp + rsp_length, req + rsp_length, 4);\n            rsp_length += 4;\n        }\n    }\n        break;\n    case MODBUS_FC_REPORT_SLAVE_ID: {\n        int str_len;\n        int byte_count_pos;\n\n        rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n        /* Skip byte count for now */\n        byte_count_pos = rsp_length++;\n        rsp[rsp_length++] = _REPORT_SLAVE_ID;\n        /* Run indicator status to ON */\n        rsp[rsp_length++] = 0xFF;\n        /* LMB + length of LIBMODBUS_VERSION_STRING */\n        str_len = 3 + strlen(LIBMODBUS_VERSION_STRING);\n        memcpy(rsp + rsp_length, \"LMB\" LIBMODBUS_VERSION_STRING, str_len);\n        rsp_length += str_len;\n        rsp[byte_count_pos] = rsp_length - byte_count_pos - 1;\n    }\n        break;\n    case MODBUS_FC_READ_EXCEPTION_STATUS:\n        if (ctx->debug) {\n            fprintf(stderr, \"FIXME Not implemented\\n\");\n        }\n        errno = ENOPROTOOPT;\n        return -1;\n        break;\n    case MODBUS_FC_MASK_WRITE_REGISTER: {\n        int mapping_address = address - mb_mapping->start_registers;\n\n        if (mapping_address < 0 || mapping_address >= mb_mapping->nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_register\\n\",\n                address);\n        } else {\n            uint16_t data = mb_mapping->tab_registers[mapping_address];\n            uint16_t and = (req[offset + 3] << 8) + req[offset + 4];\n            uint16_t or = (req[offset + 5] << 8) + req[offset + 6];\n\n            data = (data & and) | (or & (~and));\n            mb_mapping->tab_registers[mapping_address] = data;\n            memcpy(rsp, req, req_length);\n            rsp_length = req_length;\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_AND_READ_REGISTERS: {\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        uint16_t address_write = (req[offset + 5] << 8) + req[offset + 6];\n        int nb_write = (req[offset + 7] << 8) + req[offset + 8];\n        int nb_write_bytes = req[offset + 9];\n        int mapping_address = address - mb_mapping->start_registers;\n        int mapping_address_write = address_write - mb_mapping->start_registers;\n\n        if (nb_write < 1 || MODBUS_MAX_WR_WRITE_REGISTERS < nb_write ||\n            nb < 1 || MODBUS_MAX_WR_READ_REGISTERS < nb ||\n            nb_write_bytes != nb_write * 2) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal nb of values (W%d, R%d) in write_and_read_registers (max W%d, R%d)\\n\",\n                nb_write, nb, MODBUS_MAX_WR_WRITE_REGISTERS, MODBUS_MAX_WR_READ_REGISTERS);\n        } else if (mapping_address < 0 ||\n                   (mapping_address + nb) > mb_mapping->nb_registers ||\n                   mapping_address < 0 ||\n                   (mapping_address_write + nb_write) > mb_mapping->nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data read address 0x%0X or write address 0x%0X write_and_read_registers\\n\",\n                mapping_address < 0 ? address : address + nb,\n                mapping_address_write < 0 ? address_write : address_write + nb_write);\n        } else {\n            int i, j;\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            rsp[rsp_length++] = nb << 1;\n\n            /* Write first.\n               10 and 11 are the offset of the first values to write */\n            for (i = mapping_address_write, j = 10;\n                 i < mapping_address_write + nb_write; i++, j += 2) {\n                mb_mapping->tab_registers[i] =\n                    (req[offset + j] << 8) + req[offset + j + 1];\n            }\n\n            /* and read the data for the response */\n            for (i = mapping_address; i < mapping_address + nb; i++) {\n                rsp[rsp_length++] = mb_mapping->tab_registers[i] >> 8;\n                rsp[rsp_length++] = mb_mapping->tab_registers[i] & 0xFF;\n            }\n        }\n    }\n        break;\n\n    default:\n        rsp_length = response_exception(\n            ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_FUNCTION, rsp, TRUE,\n            \"Unknown Modbus function code: 0x%0X\\n\", function);\n        break;\n    }\n\n    /* Suppress any responses when the request was a broadcast */\n    return (ctx->backend->backend_type == _MODBUS_BACKEND_TYPE_RTU &&\n            slave == MODBUS_BROADCAST_ADDRESS) ? 0 : send_msg(ctx, rsp, rsp_length);\n}\n\nint modbus_reply_exception(modbus_t *ctx, const uint8_t *req,\n                           unsigned int exception_code)\n{\n    int offset;\n    int slave;\n    int function;\n    uint8_t rsp[MAX_MESSAGE_LENGTH];\n    int rsp_length;\n    int dummy_length = 99;\n    sft_t sft;\n\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    offset = ctx->backend->header_length;\n    slave = req[offset - 1];\n    function = req[offset];\n\n    sft.slave = slave;\n    sft.function = function + 0x80;\n    sft.t_id = ctx->backend->prepare_response_tid(req, &dummy_length);\n    rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n\n    /* Positive exception code */\n    if (exception_code < MODBUS_EXCEPTION_MAX) {\n        rsp[rsp_length++] = exception_code;\n        return send_msg(ctx, rsp, rsp_length);\n    } else {\n        errno = EINVAL;\n        return -1;\n    }\n}\n\n/* Reads IO status */\nstatic int read_io_status(modbus_t *ctx, int function,\n                          int addr, int nb, uint8_t *dest)\n{\n    int rc;\n    int req_length;\n\n    uint8_t req[_MIN_REQ_LENGTH];\n    uint8_t rsp[MAX_MESSAGE_LENGTH];\n\n    req_length = ctx->backend->build_request_basis(ctx, function, addr, nb, req);\n\n    rc = send_msg(ctx, req, req_length);\n    if (rc > 0) {\n        int i, temp, bit;\n        int pos = 0;\n        int offset;\n        int offset_end;\n\n        rc = _modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);\n        if (rc == -1)\n            return -1;\n\n        rc = check_confirmation(ctx, req, rsp, rc);\n        if (rc == -1)\n            return -1;\n\n        offset = ctx->backend->header_length + 2;\n        offset_end = offset + rc;\n        for (i = offset; i < offset_end; i++) {\n            /* Shift reg hi_byte to temp */\n            temp = rsp[i];\n\n            for (bit = 0x01; (bit & 0xff) && (pos < nb);) {\n                dest[pos++] = (temp & bit) ? TRUE : FALSE;\n                bit = bit << 1;\n            }\n\n        }\n    }\n\n    return rc;\n}\n\n/* Reads the boolean status of bits and sets the array elements\n   in the destination to TRUE or FALSE (single bits). */\nint modbus_read_bits(modbus_t *ctx, int addr, int nb, uint8_t *dest)\n{\n    int rc;\n\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    if (nb > MODBUS_MAX_READ_BITS) {\n        if (ctx->debug) {\n            fprintf(stderr,\n                    \"ERROR Too many bits requested (%d > %d)\\n\",\n                    nb, MODBUS_MAX_READ_BITS);\n        }\n        errno = EMBMDATA;\n        return -1;\n    }\n\n    rc = read_io_status(ctx, MODBUS_FC_READ_COILS, addr, nb, dest);\n\n    if (rc == -1)\n        return -1;\n    else\n        return nb;\n}\n\n\n/* Same as modbus_read_bits but reads the remote device input table */\nint modbus_read_input_bits(modbus_t *ctx, int addr, int nb, uint8_t *dest)\n{\n    int rc;\n\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    if (nb > MODBUS_MAX_READ_BITS) {\n        if (ctx->debug) {\n            fprintf(stderr,\n                    \"ERROR Too many discrete inputs requested (%d > %d)\\n\",\n                    nb, MODBUS_MAX_READ_BITS);\n        }\n        errno = EMBMDATA;\n        return -1;\n    }\n\n    rc = read_io_status(ctx, MODBUS_FC_READ_DISCRETE_INPUTS, addr, nb, dest);\n\n    if (rc == -1)\n        return -1;\n    else\n        return nb;\n}\n\n/* Reads the data from a remove device and put that data into an array */\nstatic int read_registers(modbus_t *ctx, int function, int addr, int nb,\n                          uint16_t *dest)\n{\n    int rc;\n    int req_length;\n    uint8_t req[_MIN_REQ_LENGTH];\n    uint8_t rsp[MAX_MESSAGE_LENGTH];\n\n    if (nb > MODBUS_MAX_READ_REGISTERS) {\n        if (ctx->debug) {\n            fprintf(stderr,\n                    \"ERROR Too many registers requested (%d > %d)\\n\",\n                    nb, MODBUS_MAX_READ_REGISTERS);\n        }\n        errno = EMBMDATA;\n        return -1;\n    }\n\n    req_length = ctx->backend->build_request_basis(ctx, function, addr, nb, req);\n\n    rc = send_msg(ctx, req, req_length);\n    if (rc > 0) {\n        int offset;\n        int i;\n\n        rc = _modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);\n        if (rc == -1)\n            return -1;\n\n        rc = check_confirmation(ctx, req, rsp, rc);\n        if (rc == -1)\n            return -1;\n\n        offset = ctx->backend->header_length;\n\n        for (i = 0; i < rc; i++) {\n            /* shift reg hi_byte to temp OR with lo_byte */\n            dest[i] = (rsp[offset + 2 + (i << 1)] << 8) |\n                rsp[offset + 3 + (i << 1)];\n        }\n    }\n\n    return rc;\n}\n\n/* Reads the holding registers of remote device and put the data into an\n   array */\nint modbus_read_registers(modbus_t *ctx, int addr, int nb, uint16_t *dest)\n{\n    int status;\n\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    if (nb > MODBUS_MAX_READ_REGISTERS) {\n        if (ctx->debug) {\n            fprintf(stderr,\n                    \"ERROR Too many registers requested (%d > %d)\\n\",\n                    nb, MODBUS_MAX_READ_REGISTERS);\n        }\n        errno = EMBMDATA;\n        return -1;\n    }\n\n    status = read_registers(ctx, MODBUS_FC_READ_HOLDING_REGISTERS,\n                            addr, nb, dest);\n    return status;\n}\n\n/* Reads the input registers of remote device and put the data into an array */\nint modbus_read_input_registers(modbus_t *ctx, int addr, int nb,\n                                uint16_t *dest)\n{\n    int status;\n\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    if (nb > MODBUS_MAX_READ_REGISTERS) {\n        fprintf(stderr,\n                \"ERROR Too many input registers requested (%d > %d)\\n\",\n                nb, MODBUS_MAX_READ_REGISTERS);\n        errno = EMBMDATA;\n        return -1;\n    }\n\n    status = read_registers(ctx, MODBUS_FC_READ_INPUT_REGISTERS,\n                            addr, nb, dest);\n\n    return status;\n}\n\n/* Write a value to the specified register of the remote device.\n   Used by write_bit and write_register */\nstatic int write_single(modbus_t *ctx, int function, int addr, int value)\n{\n    int rc;\n    int req_length;\n    uint8_t req[_MIN_REQ_LENGTH];\n\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    req_length = ctx->backend->build_request_basis(ctx, function, addr, value, req);\n\n    rc = send_msg(ctx, req, req_length);\n    if (rc > 0) {\n        /* Used by write_bit and write_register */\n        uint8_t rsp[MAX_MESSAGE_LENGTH];\n\n        rc = _modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);\n        if (rc == -1)\n            return -1;\n\n        rc = check_confirmation(ctx, req, rsp, rc);\n    }\n\n    return rc;\n}\n\n/* Turns ON or OFF a single bit of the remote device */\nint modbus_write_bit(modbus_t *ctx, int addr, int status)\n{\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    return write_single(ctx, MODBUS_FC_WRITE_SINGLE_COIL, addr,\n                        status ? 0xFF00 : 0);\n}\n\n/* Writes a value in one register of the remote device */\nint modbus_write_register(modbus_t *ctx, int addr, int value)\n{\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    return write_single(ctx, MODBUS_FC_WRITE_SINGLE_REGISTER, addr, value);\n}\n\n/* Write the bits of the array in the remote device */\nint modbus_write_bits(modbus_t *ctx, int addr, int nb, const uint8_t *src)\n{\n    int rc;\n    int i;\n    int byte_count;\n    int req_length;\n    int bit_check = 0;\n    int pos = 0;\n    uint8_t req[MAX_MESSAGE_LENGTH];\n\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    if (nb > MODBUS_MAX_WRITE_BITS) {\n        if (ctx->debug) {\n            fprintf(stderr, \"ERROR Writing too many bits (%d > %d)\\n\",\n                    nb, MODBUS_MAX_WRITE_BITS);\n        }\n        errno = EMBMDATA;\n        return -1;\n    }\n\n    req_length = ctx->backend->build_request_basis(ctx,\n                                                   MODBUS_FC_WRITE_MULTIPLE_COILS,\n                                                   addr, nb, req);\n    byte_count = (nb / 8) + ((nb % 8) ? 1 : 0);\n    req[req_length++] = byte_count;\n\n    for (i = 0; i < byte_count; i++) {\n        int bit;\n\n        bit = 0x01;\n        req[req_length] = 0;\n\n        while ((bit & 0xFF) && (bit_check++ < nb)) {\n            if (src[pos++])\n                req[req_length] |= bit;\n            else\n                req[req_length] &=~ bit;\n\n            bit = bit << 1;\n        }\n        req_length++;\n    }\n\n    rc = send_msg(ctx, req, req_length);\n    if (rc > 0) {\n        uint8_t rsp[MAX_MESSAGE_LENGTH];\n\n        rc = _modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);\n        if (rc == -1)\n            return -1;\n\n        rc = check_confirmation(ctx, req, rsp, rc);\n    }\n\n\n    return rc;\n}\n\n/* Write the values from the array to the registers of the remote device */\nint modbus_write_registers(modbus_t *ctx, int addr, int nb, const uint16_t *src)\n{\n    int rc;\n    int i;\n    int req_length;\n    int byte_count;\n    uint8_t req[MAX_MESSAGE_LENGTH];\n\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    if (nb > MODBUS_MAX_WRITE_REGISTERS) {\n        if (ctx->debug) {\n            fprintf(stderr,\n                    \"ERROR Trying to write to too many registers (%d > %d)\\n\",\n                    nb, MODBUS_MAX_WRITE_REGISTERS);\n        }\n        errno = EMBMDATA;\n        return -1;\n    }\n\n    req_length = ctx->backend->build_request_basis(ctx,\n                                                   MODBUS_FC_WRITE_MULTIPLE_REGISTERS,\n                                                   addr, nb, req);\n    byte_count = nb * 2;\n    req[req_length++] = byte_count;\n\n    for (i = 0; i < nb; i++) {\n        req[req_length++] = src[i] >> 8;\n        req[req_length++] = src[i] & 0x00FF;\n    }\n\n    rc = send_msg(ctx, req, req_length);\n    if (rc > 0) {\n        uint8_t rsp[MAX_MESSAGE_LENGTH];\n\n        rc = _modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);\n        if (rc == -1)\n            return -1;\n\n        rc = check_confirmation(ctx, req, rsp, rc);\n    }\n\n    return rc;\n}\n\nint modbus_mask_write_register(modbus_t *ctx, int addr, uint16_t and_mask, uint16_t or_mask)\n{\n    int rc;\n    int req_length;\n    /* The request length can not exceed _MIN_REQ_LENGTH - 2 and 4 bytes to\n     * store the masks. The ugly substraction is there to remove the 'nb' value\n     * (2 bytes) which is not used. */\n    uint8_t req[_MIN_REQ_LENGTH + 2];\n\n    req_length = ctx->backend->build_request_basis(ctx,\n                                                   MODBUS_FC_MASK_WRITE_REGISTER,\n                                                   addr, 0, req);\n\n    /* HACKISH, count is not used */\n    req_length -= 2;\n\n    req[req_length++] = and_mask >> 8;\n    req[req_length++] = and_mask & 0x00ff;\n    req[req_length++] = or_mask >> 8;\n    req[req_length++] = or_mask & 0x00ff;\n\n    rc = send_msg(ctx, req, req_length);\n    if (rc > 0) {\n        /* Used by write_bit and write_register */\n        uint8_t rsp[MAX_MESSAGE_LENGTH];\n\n        rc = _modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);\n        if (rc == -1)\n            return -1;\n\n        rc = check_confirmation(ctx, req, rsp, rc);\n    }\n\n    return rc;\n}\n\n/* Write multiple registers from src array to remote device and read multiple\n   registers from remote device to dest array. */\nint modbus_write_and_read_registers(modbus_t *ctx,\n                                    int write_addr, int write_nb,\n                                    const uint16_t *src,\n                                    int read_addr, int read_nb,\n                                    uint16_t *dest)\n\n{\n    int rc;\n    int req_length;\n    int i;\n    int byte_count;\n    uint8_t req[MAX_MESSAGE_LENGTH];\n    uint8_t rsp[MAX_MESSAGE_LENGTH];\n\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    if (write_nb > MODBUS_MAX_WR_WRITE_REGISTERS) {\n        if (ctx->debug) {\n            fprintf(stderr,\n                    \"ERROR Too many registers to write (%d > %d)\\n\",\n                    write_nb, MODBUS_MAX_WR_WRITE_REGISTERS);\n        }\n        errno = EMBMDATA;\n        return -1;\n    }\n\n    if (read_nb > MODBUS_MAX_WR_READ_REGISTERS) {\n        if (ctx->debug) {\n            fprintf(stderr,\n                    \"ERROR Too many registers requested (%d > %d)\\n\",\n                    read_nb, MODBUS_MAX_WR_READ_REGISTERS);\n        }\n        errno = EMBMDATA;\n        return -1;\n    }\n    req_length = ctx->backend->build_request_basis(ctx,\n                                                   MODBUS_FC_WRITE_AND_READ_REGISTERS,\n                                                   read_addr, read_nb, req);\n\n    req[req_length++] = write_addr >> 8;\n    req[req_length++] = write_addr & 0x00ff;\n    req[req_length++] = write_nb >> 8;\n    req[req_length++] = write_nb & 0x00ff;\n    byte_count = write_nb * 2;\n    req[req_length++] = byte_count;\n\n    for (i = 0; i < write_nb; i++) {\n        req[req_length++] = src[i] >> 8;\n        req[req_length++] = src[i] & 0x00FF;\n    }\n\n    rc = send_msg(ctx, req, req_length);\n    if (rc > 0) {\n        int offset;\n\n        rc = _modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);\n        if (rc == -1)\n            return -1;\n\n        rc = check_confirmation(ctx, req, rsp, rc);\n        if (rc == -1)\n            return -1;\n\n        offset = ctx->backend->header_length;\n        for (i = 0; i < rc; i++) {\n            /* shift reg hi_byte to temp OR with lo_byte */\n            dest[i] = (rsp[offset + 2 + (i << 1)] << 8) |\n                rsp[offset + 3 + (i << 1)];\n        }\n    }\n\n    return rc;\n}\n\n/* Send a request to get the slave ID of the device (only available in serial\n   communication). */\nint modbus_report_slave_id(modbus_t *ctx, int max_dest, uint8_t *dest)\n{\n    int rc;\n    int req_length;\n    uint8_t req[_MIN_REQ_LENGTH];\n\n    if (ctx == NULL || max_dest <= 0) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    req_length = ctx->backend->build_request_basis(ctx, MODBUS_FC_REPORT_SLAVE_ID,\n                                                   0, 0, req);\n\n    /* HACKISH, addr and count are not used */\n    req_length -= 4;\n\n    rc = send_msg(ctx, req, req_length);\n    if (rc > 0) {\n        int i;\n        int offset;\n        uint8_t rsp[MAX_MESSAGE_LENGTH];\n\n        rc = _modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);\n        if (rc == -1)\n            return -1;\n\n        rc = check_confirmation(ctx, req, rsp, rc);\n        if (rc == -1)\n            return -1;\n\n        offset = ctx->backend->header_length + 2;\n\n        /* Byte count, slave id, run indicator status and\n           additional data. Truncate copy to max_dest. */\n        for (i=0; i < rc && i < max_dest; i++) {\n            dest[i] = rsp[offset + i];\n        }\n    }\n\n    return rc;\n}\n\nvoid _modbus_init_common(modbus_t *ctx)\n{\n    /* Slave and socket are initialized to -1 */\n    ctx->slave = -1;\n    ctx->s = -1;\n\n    ctx->debug = FALSE;\n    ctx->error_recovery = MODBUS_ERROR_RECOVERY_NONE;\n\n    ctx->response_timeout.tv_sec = 0;\n    ctx->response_timeout.tv_usec = _RESPONSE_TIMEOUT;\n\n    ctx->byte_timeout.tv_sec = 0;\n    ctx->byte_timeout.tv_usec = _BYTE_TIMEOUT;\n\n    ctx->indication_timeout.tv_sec = 0;\n    ctx->indication_timeout.tv_usec = 0;\n}\n\n/* Define the slave number */\nint modbus_set_slave(modbus_t *ctx, int slave)\n{\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    return ctx->backend->set_slave(ctx, slave);\n}\n\nint modbus_get_slave(modbus_t *ctx)\n{\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    return ctx->slave;\n}\n\nint modbus_set_error_recovery(modbus_t *ctx,\n                              modbus_error_recovery_mode error_recovery)\n{\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    /* The type of modbus_error_recovery_mode is unsigned enum */\n    ctx->error_recovery = (uint8_t) error_recovery;\n    return 0;\n}\n\nint modbus_set_socket(modbus_t *ctx, int s)\n{\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    ctx->s = s;\n    return 0;\n}\n\nint modbus_get_socket(modbus_t *ctx)\n{\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    return ctx->s;\n}\n\n/* Get the timeout interval used to wait for a response */\nint modbus_get_response_timeout(modbus_t *ctx, uint32_t *to_sec, uint32_t *to_usec)\n{\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    *to_sec = ctx->response_timeout.tv_sec;\n    *to_usec = ctx->response_timeout.tv_usec;\n    return 0;\n}\n\nint modbus_set_response_timeout(modbus_t *ctx, uint32_t to_sec, uint32_t to_usec)\n{\n    if (ctx == NULL ||\n        (to_sec == 0 && to_usec == 0) || to_usec > 999999) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    ctx->response_timeout.tv_sec = to_sec;\n    ctx->response_timeout.tv_usec = to_usec;\n    return 0;\n}\n\n/* Get the timeout interval between two consecutive bytes of a message */\nint modbus_get_byte_timeout(modbus_t *ctx, uint32_t *to_sec, uint32_t *to_usec)\n{\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    *to_sec = ctx->byte_timeout.tv_sec;\n    *to_usec = ctx->byte_timeout.tv_usec;\n    return 0;\n}\n\nint modbus_set_byte_timeout(modbus_t *ctx, uint32_t to_sec, uint32_t to_usec)\n{\n    /* Byte timeout can be disabled when both values are zero */\n    if (ctx == NULL || to_usec > 999999) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    ctx->byte_timeout.tv_sec = to_sec;\n    ctx->byte_timeout.tv_usec = to_usec;\n    return 0;\n}\n\n/* Get the timeout interval used by the server to wait for an indication from a client */\nint modbus_get_indication_timeout(modbus_t *ctx, uint32_t *to_sec, uint32_t *to_usec)\n{\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    *to_sec = ctx->indication_timeout.tv_sec;\n    *to_usec = ctx->indication_timeout.tv_usec;\n    return 0;\n}\n\nint modbus_set_indication_timeout(modbus_t *ctx, uint32_t to_sec, uint32_t to_usec)\n{\n    /* Indication timeout can be disabled when both values are zero */\n    if (ctx == NULL || to_usec > 999999) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    ctx->indication_timeout.tv_sec = to_sec;\n    ctx->indication_timeout.tv_usec = to_usec;\n    return 0;\n}\n\nint modbus_get_header_length(modbus_t *ctx)\n{\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    return ctx->backend->header_length;\n}\n\nint modbus_connect(modbus_t *ctx)\n{\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    return ctx->backend->connect(ctx);\n}\n\nvoid modbus_close(modbus_t *ctx)\n{\n    if (ctx == NULL)\n        return;\n\n    ctx->backend->close(ctx);\n}\n\nvoid modbus_free(modbus_t *ctx)\n{\n    if (ctx == NULL)\n        return;\n\n    ctx->backend->free(ctx);\n}\n\nint modbus_set_debug(modbus_t *ctx, int flag)\n{\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    ctx->debug = flag;\n    return 0;\n}\n\n/* Allocates 4 arrays to store bits, input bits, registers and inputs\n   registers. The pointers are stored in modbus_mapping structure.\n\n   The modbus_mapping_new_start_address() function shall return the new allocated\n   structure if successful. Otherwise it shall return NULL and set errno to\n   ENOMEM. */\nmodbus_mapping_t* modbus_mapping_new_start_address(\n    unsigned int start_bits, unsigned int nb_bits,\n    unsigned int start_input_bits, unsigned int nb_input_bits,\n    unsigned int start_registers, unsigned int nb_registers,\n    unsigned int start_input_registers, unsigned int nb_input_registers)\n{\n    modbus_mapping_t *mb_mapping;\n\n    mb_mapping = (modbus_mapping_t *)malloc(sizeof(modbus_mapping_t));\n    if (mb_mapping == NULL) {\n        return NULL;\n    }\n\n    /* 0X */\n    mb_mapping->nb_bits = nb_bits;\n    mb_mapping->start_bits = start_bits;\n    if (nb_bits == 0) {\n        mb_mapping->tab_bits = NULL;\n    } else {\n        /* Negative number raises a POSIX error */\n        mb_mapping->tab_bits =\n            (uint8_t *) malloc(nb_bits * sizeof(uint8_t));\n        if (mb_mapping->tab_bits == NULL) {\n            free(mb_mapping);\n            return NULL;\n        }\n        memset(mb_mapping->tab_bits, 0, nb_bits * sizeof(uint8_t));\n    }\n\n    /* 1X */\n    mb_mapping->nb_input_bits = nb_input_bits;\n    mb_mapping->start_input_bits = start_input_bits;\n    if (nb_input_bits == 0) {\n        mb_mapping->tab_input_bits = NULL;\n    } else {\n        mb_mapping->tab_input_bits =\n            (uint8_t *) malloc(nb_input_bits * sizeof(uint8_t));\n        if (mb_mapping->tab_input_bits == NULL) {\n            free(mb_mapping->tab_bits);\n            free(mb_mapping);\n            return NULL;\n        }\n        memset(mb_mapping->tab_input_bits, 0, nb_input_bits * sizeof(uint8_t));\n    }\n\n    /* 4X */\n    mb_mapping->nb_registers = nb_registers;\n    mb_mapping->start_registers = start_registers;\n    if (nb_registers == 0) {\n        mb_mapping->tab_registers = NULL;\n    } else {\n        mb_mapping->tab_registers =\n            (uint16_t *) malloc(nb_registers * sizeof(uint16_t));\n        if (mb_mapping->tab_registers == NULL) {\n            free(mb_mapping->tab_input_bits);\n            free(mb_mapping->tab_bits);\n            free(mb_mapping);\n            return NULL;\n        }\n        memset(mb_mapping->tab_registers, 0, nb_registers * sizeof(uint16_t));\n    }\n\n    /* 3X */\n    mb_mapping->nb_input_registers = nb_input_registers;\n    mb_mapping->start_input_registers = start_input_registers;\n    if (nb_input_registers == 0) {\n        mb_mapping->tab_input_registers = NULL;\n    } else {\n        mb_mapping->tab_input_registers =\n            (uint16_t *) malloc(nb_input_registers * sizeof(uint16_t));\n        if (mb_mapping->tab_input_registers == NULL) {\n            free(mb_mapping->tab_registers);\n            free(mb_mapping->tab_input_bits);\n            free(mb_mapping->tab_bits);\n            free(mb_mapping);\n            return NULL;\n        }\n        memset(mb_mapping->tab_input_registers, 0,\n               nb_input_registers * sizeof(uint16_t));\n    }\n\n    return mb_mapping;\n}\n\nmodbus_mapping_t* modbus_mapping_new(int nb_bits, int nb_input_bits,\n                                     int nb_registers, int nb_input_registers)\n{\n    return modbus_mapping_new_start_address(\n        0, nb_bits, 0, nb_input_bits, 0, nb_registers, 0, nb_input_registers);\n}\n\n/* Frees the 4 arrays */\nvoid modbus_mapping_free(modbus_mapping_t *mb_mapping)\n{\n    if (mb_mapping == NULL) {\n        return;\n    }\n\n    free(mb_mapping->tab_input_registers);\n    free(mb_mapping->tab_registers);\n    free(mb_mapping->tab_input_bits);\n    free(mb_mapping->tab_bits);\n    free(mb_mapping);\n}\n\n#ifndef HAVE_STRLCPY\n/*\n * Function strlcpy was originally developed by\n * Todd C. Miller <Todd.Miller@courtesan.com> to simplify writing secure code.\n * See ftp://ftp.openbsd.org/pub/OpenBSD/src/lib/libc/string/strlcpy.3\n * for more information.\n *\n * Thank you Ulrich Drepper... not!\n *\n * Copy src to string dest of size dest_size.  At most dest_size-1 characters\n * will be copied.  Always NUL terminates (unless dest_size == 0).  Returns\n * strlen(src); if retval >= dest_size, truncation occurred.\n */\nsize_t strlcpy(char *dest, const char *src, size_t dest_size)\n{\n    register char *d = dest;\n    register const char *s = src;\n    register size_t n = dest_size;\n\n    /* Copy as many bytes as will fit */\n    if (n != 0 && --n != 0) {\n        do {\n            if ((*d++ = *s++) == 0)\n                break;\n        } while (--n != 0);\n    }\n\n    /* Not enough room in dest, add NUL and traverse rest of src */\n    if (n == 0) {\n        if (dest_size != 0)\n            *d = '\\0'; /* NUL-terminate dest */\n        while (*s++)\n            ;\n    }\n\n    return (s - src - 1); /* count does not include NUL */\n}\n#endif\n"], "fixing_code": ["/*\n * Copyright \u00a9 2001-2011 St\u00e9phane Raimbault <stephane.raimbault@gmail.com>\n *\n * SPDX-License-Identifier: LGPL-2.1+\n *\n * This library implements the Modbus protocol.\n * http://libmodbus.org/\n */\n\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <errno.h>\n#include <limits.h>\n#include <time.h>\n#ifndef _MSC_VER\n#include <unistd.h>\n#endif\n\n#include <config.h>\n\n#include \"modbus.h\"\n#include \"modbus-private.h\"\n\n/* Internal use */\n#define MSG_LENGTH_UNDEFINED -1\n\n/* Exported version */\nconst unsigned int libmodbus_version_major = LIBMODBUS_VERSION_MAJOR;\nconst unsigned int libmodbus_version_minor = LIBMODBUS_VERSION_MINOR;\nconst unsigned int libmodbus_version_micro = LIBMODBUS_VERSION_MICRO;\n\n/* Max between RTU and TCP max adu length (so TCP) */\n#define MAX_MESSAGE_LENGTH 260\n\n/* 3 steps are used to parse the query */\ntypedef enum {\n    _STEP_FUNCTION,\n    _STEP_META,\n    _STEP_DATA\n} _step_t;\n\nconst char *modbus_strerror(int errnum) {\n    switch (errnum) {\n    case EMBXILFUN:\n        return \"Illegal function\";\n    case EMBXILADD:\n        return \"Illegal data address\";\n    case EMBXILVAL:\n        return \"Illegal data value\";\n    case EMBXSFAIL:\n        return \"Slave device or server failure\";\n    case EMBXACK:\n        return \"Acknowledge\";\n    case EMBXSBUSY:\n        return \"Slave device or server is busy\";\n    case EMBXNACK:\n        return \"Negative acknowledge\";\n    case EMBXMEMPAR:\n        return \"Memory parity error\";\n    case EMBXGPATH:\n        return \"Gateway path unavailable\";\n    case EMBXGTAR:\n        return \"Target device failed to respond\";\n    case EMBBADCRC:\n        return \"Invalid CRC\";\n    case EMBBADDATA:\n        return \"Invalid data\";\n    case EMBBADEXC:\n        return \"Invalid exception code\";\n    case EMBMDATA:\n        return \"Too many data\";\n    case EMBBADSLAVE:\n        return \"Response not from requested slave\";\n    default:\n        return strerror(errnum);\n    }\n}\n\nvoid _error_print(modbus_t *ctx, const char *context)\n{\n    if (ctx->debug) {\n        fprintf(stderr, \"ERROR %s\", modbus_strerror(errno));\n        if (context != NULL) {\n            fprintf(stderr, \": %s\\n\", context);\n        } else {\n            fprintf(stderr, \"\\n\");\n        }\n    }\n}\n\nstatic void _sleep_response_timeout(modbus_t *ctx)\n{\n    /* Response timeout is always positive */\n#ifdef _WIN32\n    /* usleep doesn't exist on Windows */\n    Sleep((ctx->response_timeout.tv_sec * 1000) +\n          (ctx->response_timeout.tv_usec / 1000));\n#else\n    /* usleep source code */\n    struct timespec request, remaining;\n    request.tv_sec = ctx->response_timeout.tv_sec;\n    request.tv_nsec = ((long int)ctx->response_timeout.tv_usec) * 1000;\n    while (nanosleep(&request, &remaining) == -1 && errno == EINTR) {\n        request = remaining;\n    }\n#endif\n}\n\nint modbus_flush(modbus_t *ctx)\n{\n    int rc;\n\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    rc = ctx->backend->flush(ctx);\n    if (rc != -1 && ctx->debug) {\n        /* Not all backends are able to return the number of bytes flushed */\n        printf(\"Bytes flushed (%d)\\n\", rc);\n    }\n    return rc;\n}\n\n/* Computes the length of the expected response */\nstatic unsigned int compute_response_length_from_request(modbus_t *ctx, uint8_t *req)\n{\n    int length;\n    const int offset = ctx->backend->header_length;\n\n    switch (req[offset]) {\n    case MODBUS_FC_READ_COILS:\n    case MODBUS_FC_READ_DISCRETE_INPUTS: {\n        /* Header + nb values (code from write_bits) */\n        int nb = (req[offset + 3] << 8) | req[offset + 4];\n        length = 2 + (nb / 8) + ((nb % 8) ? 1 : 0);\n    }\n        break;\n    case MODBUS_FC_WRITE_AND_READ_REGISTERS:\n    case MODBUS_FC_READ_HOLDING_REGISTERS:\n    case MODBUS_FC_READ_INPUT_REGISTERS:\n        /* Header + 2 * nb values */\n        length = 2 + 2 * (req[offset + 3] << 8 | req[offset + 4]);\n        break;\n    case MODBUS_FC_READ_EXCEPTION_STATUS:\n        length = 3;\n        break;\n    case MODBUS_FC_REPORT_SLAVE_ID:\n        /* The response is device specific (the header provides the\n           length) */\n        return MSG_LENGTH_UNDEFINED;\n    case MODBUS_FC_MASK_WRITE_REGISTER:\n        length = 7;\n        break;\n    default:\n        length = 5;\n    }\n\n    return offset + length + ctx->backend->checksum_length;\n}\n\n/* Sends a request/response */\nstatic int send_msg(modbus_t *ctx, uint8_t *msg, int msg_length)\n{\n    int rc;\n    int i;\n\n    msg_length = ctx->backend->send_msg_pre(msg, msg_length);\n\n    if (ctx->debug) {\n        for (i = 0; i < msg_length; i++)\n            printf(\"[%.2X]\", msg[i]);\n        printf(\"\\n\");\n    }\n\n    /* In recovery mode, the write command will be issued until to be\n       successful! Disabled by default. */\n    do {\n        rc = ctx->backend->send(ctx, msg, msg_length);\n        if (rc == -1) {\n            _error_print(ctx, NULL);\n            if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_LINK) {\n                int saved_errno = errno;\n\n                if ((errno == EBADF || errno == ECONNRESET || errno == EPIPE)) {\n                    modbus_close(ctx);\n                    _sleep_response_timeout(ctx);\n                    modbus_connect(ctx);\n                } else {\n                    _sleep_response_timeout(ctx);\n                    modbus_flush(ctx);\n                }\n                errno = saved_errno;\n            }\n        }\n    } while ((ctx->error_recovery & MODBUS_ERROR_RECOVERY_LINK) &&\n             rc == -1);\n\n    if (rc > 0 && rc != msg_length) {\n        errno = EMBBADDATA;\n        return -1;\n    }\n\n    return rc;\n}\n\nint modbus_send_raw_request(modbus_t *ctx, uint8_t *raw_req, int raw_req_length)\n{\n    sft_t sft;\n    uint8_t req[MAX_MESSAGE_LENGTH];\n    int req_length;\n\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    if (raw_req_length < 2 || raw_req_length > (MODBUS_MAX_PDU_LENGTH + 1)) {\n        /* The raw request must contain function and slave at least and\n           must not be longer than the maximum pdu length plus the slave\n           address. */\n        errno = EINVAL;\n        return -1;\n    }\n\n    sft.slave = raw_req[0];\n    sft.function = raw_req[1];\n    /* The t_id is left to zero */\n    sft.t_id = 0;\n    /* This response function only set the header so it's convenient here */\n    req_length = ctx->backend->build_response_basis(&sft, req);\n\n    if (raw_req_length > 2) {\n        /* Copy data after function code */\n        memcpy(req + req_length, raw_req + 2, raw_req_length - 2);\n        req_length += raw_req_length - 2;\n    }\n\n    return send_msg(ctx, req, req_length);\n}\n\n/*\n *  ---------- Request     Indication ----------\n *  | Client | ---------------------->| Server |\n *  ---------- Confirmation  Response ----------\n */\n\n/* Computes the length to read after the function received */\nstatic uint8_t compute_meta_length_after_function(int function,\n                                                  msg_type_t msg_type)\n{\n    int length;\n\n    if (msg_type == MSG_INDICATION) {\n        if (function <= MODBUS_FC_WRITE_SINGLE_REGISTER) {\n            length = 4;\n        } else if (function == MODBUS_FC_WRITE_MULTIPLE_COILS ||\n                   function == MODBUS_FC_WRITE_MULTIPLE_REGISTERS) {\n            length = 5;\n        } else if (function == MODBUS_FC_MASK_WRITE_REGISTER) {\n            length = 6;\n        } else if (function == MODBUS_FC_WRITE_AND_READ_REGISTERS) {\n            length = 9;\n        } else {\n            /* MODBUS_FC_READ_EXCEPTION_STATUS, MODBUS_FC_REPORT_SLAVE_ID */\n            length = 0;\n        }\n    } else {\n        /* MSG_CONFIRMATION */\n        switch (function) {\n        case MODBUS_FC_WRITE_SINGLE_COIL:\n        case MODBUS_FC_WRITE_SINGLE_REGISTER:\n        case MODBUS_FC_WRITE_MULTIPLE_COILS:\n        case MODBUS_FC_WRITE_MULTIPLE_REGISTERS:\n            length = 4;\n            break;\n        case MODBUS_FC_MASK_WRITE_REGISTER:\n            length = 6;\n            break;\n        default:\n            length = 1;\n        }\n    }\n\n    return length;\n}\n\n/* Computes the length to read after the meta information (address, count, etc) */\nstatic int compute_data_length_after_meta(modbus_t *ctx, uint8_t *msg,\n                                          msg_type_t msg_type)\n{\n    int function = msg[ctx->backend->header_length];\n    int length;\n\n    if (msg_type == MSG_INDICATION) {\n        switch (function) {\n        case MODBUS_FC_WRITE_MULTIPLE_COILS:\n        case MODBUS_FC_WRITE_MULTIPLE_REGISTERS:\n            length = msg[ctx->backend->header_length + 5];\n            break;\n        case MODBUS_FC_WRITE_AND_READ_REGISTERS:\n            length = msg[ctx->backend->header_length + 9];\n            break;\n        default:\n            length = 0;\n        }\n    } else {\n        /* MSG_CONFIRMATION */\n        if (function <= MODBUS_FC_READ_INPUT_REGISTERS ||\n            function == MODBUS_FC_REPORT_SLAVE_ID ||\n            function == MODBUS_FC_WRITE_AND_READ_REGISTERS) {\n            length = msg[ctx->backend->header_length + 1];\n        } else {\n            length = 0;\n        }\n    }\n\n    length += ctx->backend->checksum_length;\n\n    return length;\n}\n\n\n/* Waits a response from a modbus server or a request from a modbus client.\n   This function blocks if there is no replies (3 timeouts).\n\n   The function shall return the number of received characters and the received\n   message in an array of uint8_t if successful. Otherwise it shall return -1\n   and errno is set to one of the values defined below:\n   - ECONNRESET\n   - EMBBADDATA\n   - EMBUNKEXC\n   - ETIMEDOUT\n   - read() or recv() error codes\n*/\n\nint _modbus_receive_msg(modbus_t *ctx, uint8_t *msg, msg_type_t msg_type)\n{\n    int rc;\n    fd_set rset;\n    struct timeval tv;\n    struct timeval *p_tv;\n    int length_to_read;\n    int msg_length = 0;\n    _step_t step;\n\n    if (ctx->debug) {\n        if (msg_type == MSG_INDICATION) {\n            printf(\"Waiting for an indication...\\n\");\n        } else {\n            printf(\"Waiting for a confirmation...\\n\");\n        }\n    }\n\n    /* Add a file descriptor to the set */\n    FD_ZERO(&rset);\n    FD_SET(ctx->s, &rset);\n\n    /* We need to analyse the message step by step.  At the first step, we want\n     * to reach the function code because all packets contain this\n     * information. */\n    step = _STEP_FUNCTION;\n    length_to_read = ctx->backend->header_length + 1;\n\n    if (msg_type == MSG_INDICATION) {\n        /* Wait for a message, we don't know when the message will be\n         * received */\n        if (ctx->indication_timeout.tv_sec == 0 && ctx->indication_timeout.tv_usec == 0) {\n            /* By default, the indication timeout isn't set */\n            p_tv = NULL;\n        } else {\n            /* Wait for an indication (name of a received request by a server, see schema) */\n            tv.tv_sec = ctx->indication_timeout.tv_sec;\n            tv.tv_usec = ctx->indication_timeout.tv_usec;\n            p_tv = &tv;\n        }\n    } else {\n        tv.tv_sec = ctx->response_timeout.tv_sec;\n        tv.tv_usec = ctx->response_timeout.tv_usec;\n        p_tv = &tv;\n    }\n\n    while (length_to_read != 0) {\n        rc = ctx->backend->select(ctx, &rset, p_tv, length_to_read);\n        if (rc == -1) {\n            _error_print(ctx, \"select\");\n            if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_LINK) {\n                int saved_errno = errno;\n\n                if (errno == ETIMEDOUT) {\n                    _sleep_response_timeout(ctx);\n                    modbus_flush(ctx);\n                } else if (errno == EBADF) {\n                    modbus_close(ctx);\n                    modbus_connect(ctx);\n                }\n                errno = saved_errno;\n            }\n            return -1;\n        }\n\n        rc = ctx->backend->recv(ctx, msg + msg_length, length_to_read);\n        if (rc == 0) {\n            errno = ECONNRESET;\n            rc = -1;\n        }\n\n        if (rc == -1) {\n            _error_print(ctx, \"read\");\n            if ((ctx->error_recovery & MODBUS_ERROR_RECOVERY_LINK) &&\n                (errno == ECONNRESET || errno == ECONNREFUSED ||\n                 errno == EBADF)) {\n                int saved_errno = errno;\n                modbus_close(ctx);\n                modbus_connect(ctx);\n                /* Could be removed by previous calls */\n                errno = saved_errno;\n            }\n            return -1;\n        }\n\n        /* Display the hex code of each character received */\n        if (ctx->debug) {\n            int i;\n            for (i=0; i < rc; i++)\n                printf(\"<%.2X>\", msg[msg_length + i]);\n        }\n\n        /* Sums bytes received */\n        msg_length += rc;\n        /* Computes remaining bytes */\n        length_to_read -= rc;\n\n        if (length_to_read == 0) {\n            switch (step) {\n            case _STEP_FUNCTION:\n                /* Function code position */\n                length_to_read = compute_meta_length_after_function(\n                    msg[ctx->backend->header_length],\n                    msg_type);\n                if (length_to_read != 0) {\n                    step = _STEP_META;\n                    break;\n                } /* else switches straight to the next step */\n            case _STEP_META:\n                length_to_read = compute_data_length_after_meta(\n                    ctx, msg, msg_type);\n                if ((msg_length + length_to_read) > (int)ctx->backend->max_adu_length) {\n                    errno = EMBBADDATA;\n                    _error_print(ctx, \"too many data\");\n                    return -1;\n                }\n                step = _STEP_DATA;\n                break;\n            default:\n                break;\n            }\n        }\n\n        if (length_to_read > 0 &&\n            (ctx->byte_timeout.tv_sec > 0 || ctx->byte_timeout.tv_usec > 0)) {\n            /* If there is no character in the buffer, the allowed timeout\n               interval between two consecutive bytes is defined by\n               byte_timeout */\n            tv.tv_sec = ctx->byte_timeout.tv_sec;\n            tv.tv_usec = ctx->byte_timeout.tv_usec;\n            p_tv = &tv;\n        }\n        /* else timeout isn't set again, the full response must be read before\n           expiration of response timeout (for CONFIRMATION only) */\n    }\n\n    if (ctx->debug)\n        printf(\"\\n\");\n\n    return ctx->backend->check_integrity(ctx, msg, msg_length);\n}\n\n/* Receive the request from a modbus master */\nint modbus_receive(modbus_t *ctx, uint8_t *req)\n{\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    return ctx->backend->receive(ctx, req);\n}\n\n/* Receives the confirmation.\n\n   The function shall store the read response in rsp and return the number of\n   values (bits or words). Otherwise, its shall return -1 and errno is set.\n\n   The function doesn't check the confirmation is the expected response to the\n   initial request.\n*/\nint modbus_receive_confirmation(modbus_t *ctx, uint8_t *rsp)\n{\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    return _modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);\n}\n\nstatic int check_confirmation(modbus_t *ctx, uint8_t *req,\n                              uint8_t *rsp, int rsp_length)\n{\n    int rc;\n    int rsp_length_computed;\n    const int offset = ctx->backend->header_length;\n    const int function = rsp[offset];\n\n    if (ctx->backend->pre_check_confirmation) {\n        rc = ctx->backend->pre_check_confirmation(ctx, req, rsp, rsp_length);\n        if (rc == -1) {\n            if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {\n                _sleep_response_timeout(ctx);\n                modbus_flush(ctx);\n            }\n            return -1;\n        }\n    }\n\n    rsp_length_computed = compute_response_length_from_request(ctx, req);\n\n    /* Exception code */\n    if (function >= 0x80) {\n        if (rsp_length == (offset + 2 + (int)ctx->backend->checksum_length) &&\n            req[offset] == (rsp[offset] - 0x80)) {\n            /* Valid exception code received */\n\n            int exception_code = rsp[offset + 1];\n            if (exception_code < MODBUS_EXCEPTION_MAX) {\n                errno = MODBUS_ENOBASE + exception_code;\n            } else {\n                errno = EMBBADEXC;\n            }\n            _error_print(ctx, NULL);\n            return -1;\n        } else {\n            errno = EMBBADEXC;\n            _error_print(ctx, NULL);\n            return -1;\n        }\n    }\n\n    /* Check length */\n    if ((rsp_length == rsp_length_computed ||\n         rsp_length_computed == MSG_LENGTH_UNDEFINED) &&\n        function < 0x80) {\n        int req_nb_value;\n        int rsp_nb_value;\n\n        /* Check function code */\n        if (function != req[offset]) {\n            if (ctx->debug) {\n                fprintf(stderr,\n                        \"Received function not corresponding to the request (0x%X != 0x%X)\\n\",\n                        function, req[offset]);\n            }\n            if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {\n                _sleep_response_timeout(ctx);\n                modbus_flush(ctx);\n            }\n            errno = EMBBADDATA;\n            return -1;\n        }\n\n        /* Check the number of values is corresponding to the request */\n        switch (function) {\n        case MODBUS_FC_READ_COILS:\n        case MODBUS_FC_READ_DISCRETE_INPUTS:\n            /* Read functions, 8 values in a byte (nb\n             * of values in the request and byte count in\n             * the response. */\n            req_nb_value = (req[offset + 3] << 8) + req[offset + 4];\n            req_nb_value = (req_nb_value / 8) + ((req_nb_value % 8) ? 1 : 0);\n            rsp_nb_value = rsp[offset + 1];\n            break;\n        case MODBUS_FC_WRITE_AND_READ_REGISTERS:\n        case MODBUS_FC_READ_HOLDING_REGISTERS:\n        case MODBUS_FC_READ_INPUT_REGISTERS:\n            /* Read functions 1 value = 2 bytes */\n            req_nb_value = (req[offset + 3] << 8) + req[offset + 4];\n            rsp_nb_value = (rsp[offset + 1] / 2);\n            break;\n        case MODBUS_FC_WRITE_MULTIPLE_COILS:\n        case MODBUS_FC_WRITE_MULTIPLE_REGISTERS:\n            /* N Write functions */\n            req_nb_value = (req[offset + 3] << 8) + req[offset + 4];\n            rsp_nb_value = (rsp[offset + 3] << 8) | rsp[offset + 4];\n            break;\n        case MODBUS_FC_REPORT_SLAVE_ID:\n            /* Report slave ID (bytes received) */\n            req_nb_value = rsp_nb_value = rsp[offset + 1];\n            break;\n        default:\n            /* 1 Write functions & others */\n            req_nb_value = rsp_nb_value = 1;\n        }\n\n        if (req_nb_value == rsp_nb_value) {\n            rc = rsp_nb_value;\n        } else {\n            if (ctx->debug) {\n                fprintf(stderr,\n                        \"Quantity not corresponding to the request (%d != %d)\\n\",\n                        rsp_nb_value, req_nb_value);\n            }\n\n            if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {\n                _sleep_response_timeout(ctx);\n                modbus_flush(ctx);\n            }\n\n            errno = EMBBADDATA;\n            rc = -1;\n        }\n    } else {\n        if (ctx->debug) {\n            fprintf(stderr,\n                    \"Message length not corresponding to the computed length (%d != %d)\\n\",\n                    rsp_length, rsp_length_computed);\n        }\n        if (ctx->error_recovery & MODBUS_ERROR_RECOVERY_PROTOCOL) {\n            _sleep_response_timeout(ctx);\n            modbus_flush(ctx);\n        }\n        errno = EMBBADDATA;\n        rc = -1;\n    }\n\n    return rc;\n}\n\nstatic int response_io_status(uint8_t *tab_io_status,\n                              int address, int nb,\n                              uint8_t *rsp, int offset)\n{\n    int shift = 0;\n    /* Instead of byte (not allowed in Win32) */\n    int one_byte = 0;\n    int i;\n\n    for (i = address; i < address + nb; i++) {\n        one_byte |= tab_io_status[i] << shift;\n        if (shift == 7) {\n            /* Byte is full */\n            rsp[offset++] = one_byte;\n            one_byte = shift = 0;\n        } else {\n            shift++;\n        }\n    }\n\n    if (shift != 0)\n        rsp[offset++] = one_byte;\n\n    return offset;\n}\n\n/* Build the exception response */\nstatic int response_exception(modbus_t *ctx, sft_t *sft,\n                              int exception_code, uint8_t *rsp,\n                              unsigned int to_flush,\n                              const char* template, ...)\n{\n    int rsp_length;\n\n    /* Print debug message */\n    if (ctx->debug) {\n        va_list ap;\n\n        va_start(ap, template);\n        vfprintf(stderr, template, ap);\n        va_end(ap);\n    }\n\n    /* Flush if required */\n    if (to_flush) {\n        _sleep_response_timeout(ctx);\n        modbus_flush(ctx);\n    }\n\n    /* Build exception response */\n    sft->function = sft->function + 0x80;\n    rsp_length = ctx->backend->build_response_basis(sft, rsp);\n    rsp[rsp_length++] = exception_code;\n\n    return rsp_length;\n}\n\n/* Send a response to the received request.\n   Analyses the request and constructs a response.\n\n   If an error occurs, this function construct the response\n   accordingly.\n*/\nint modbus_reply(modbus_t *ctx, const uint8_t *req,\n                 int req_length, modbus_mapping_t *mb_mapping)\n{\n    int offset;\n    int slave;\n    int function;\n    uint16_t address;\n    uint8_t rsp[MAX_MESSAGE_LENGTH];\n    int rsp_length = 0;\n    sft_t sft;\n\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    offset = ctx->backend->header_length;\n    slave = req[offset - 1];\n    function = req[offset];\n    address = (req[offset + 1] << 8) + req[offset + 2];\n\n    sft.slave = slave;\n    sft.function = function;\n    sft.t_id = ctx->backend->prepare_response_tid(req, &req_length);\n\n    /* Data are flushed on illegal number of values errors. */\n    switch (function) {\n    case MODBUS_FC_READ_COILS:\n    case MODBUS_FC_READ_DISCRETE_INPUTS: {\n        unsigned int is_input = (function == MODBUS_FC_READ_DISCRETE_INPUTS);\n        int start_bits = is_input ? mb_mapping->start_input_bits : mb_mapping->start_bits;\n        int nb_bits = is_input ? mb_mapping->nb_input_bits : mb_mapping->nb_bits;\n        uint8_t *tab_bits = is_input ? mb_mapping->tab_input_bits : mb_mapping->tab_bits;\n        const char * const name = is_input ? \"read_input_bits\" : \"read_bits\";\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        /* The mapping can be shifted to reduce memory consumption and it\n           doesn't always start at address zero. */\n        int mapping_address = address - start_bits;\n\n        if (nb < 1 || MODBUS_MAX_READ_BITS < nb) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal nb of values %d in %s (max %d)\\n\",\n                nb, name, MODBUS_MAX_READ_BITS);\n        } else if (mapping_address < 0 || (mapping_address + nb) > nb_bits) {\n            rsp_length = response_exception(\n                ctx, &sft,\n                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in %s\\n\",\n                mapping_address < 0 ? address : address + nb, name);\n        } else {\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            rsp[rsp_length++] = (nb / 8) + ((nb % 8) ? 1 : 0);\n            rsp_length = response_io_status(tab_bits, mapping_address, nb,\n                                            rsp, rsp_length);\n        }\n    }\n        break;\n    case MODBUS_FC_READ_HOLDING_REGISTERS:\n    case MODBUS_FC_READ_INPUT_REGISTERS: {\n        unsigned int is_input = (function == MODBUS_FC_READ_INPUT_REGISTERS);\n        int start_registers = is_input ? mb_mapping->start_input_registers : mb_mapping->start_registers;\n        int nb_registers = is_input ? mb_mapping->nb_input_registers : mb_mapping->nb_registers;\n        uint16_t *tab_registers = is_input ? mb_mapping->tab_input_registers : mb_mapping->tab_registers;\n        const char * const name = is_input ? \"read_input_registers\" : \"read_registers\";\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        /* The mapping can be shifted to reduce memory consumption and it\n           doesn't always start at address zero. */\n        int mapping_address = address - start_registers;\n\n        if (nb < 1 || MODBUS_MAX_READ_REGISTERS < nb) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal nb of values %d in %s (max %d)\\n\",\n                nb, name, MODBUS_MAX_READ_REGISTERS);\n        } else if (mapping_address < 0 || (mapping_address + nb) > nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in %s\\n\",\n                mapping_address < 0 ? address : address + nb, name);\n        } else {\n            int i;\n\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            rsp[rsp_length++] = nb << 1;\n            for (i = mapping_address; i < mapping_address + nb; i++) {\n                rsp[rsp_length++] = tab_registers[i] >> 8;\n                rsp[rsp_length++] = tab_registers[i] & 0xFF;\n            }\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_SINGLE_COIL: {\n        int mapping_address = address - mb_mapping->start_bits;\n\n        if (mapping_address < 0 || mapping_address >= mb_mapping->nb_bits) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_bit\\n\",\n                address);\n        } else {\n            int data = (req[offset + 3] << 8) + req[offset + 4];\n\n            if (data == 0xFF00 || data == 0x0) {\n                mb_mapping->tab_bits[mapping_address] = data ? ON : OFF;\n                memcpy(rsp, req, req_length);\n                rsp_length = req_length;\n            } else {\n                rsp_length = response_exception(\n                    ctx, &sft,\n                    MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, FALSE,\n                    \"Illegal data value 0x%0X in write_bit request at address %0X\\n\",\n                    data, address);\n            }\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_SINGLE_REGISTER: {\n        int mapping_address = address - mb_mapping->start_registers;\n\n        if (mapping_address < 0 || mapping_address >= mb_mapping->nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft,\n                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_register\\n\",\n                address);\n        } else {\n            int data = (req[offset + 3] << 8) + req[offset + 4];\n\n            mb_mapping->tab_registers[mapping_address] = data;\n            memcpy(rsp, req, req_length);\n            rsp_length = req_length;\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_MULTIPLE_COILS: {\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        int nb_bits = req[offset + 5];\n        int mapping_address = address - mb_mapping->start_bits;\n\n        if (nb < 1 || MODBUS_MAX_WRITE_BITS < nb || nb_bits * 8 < nb) {\n            /* May be the indication has been truncated on reading because of\n             * invalid address (eg. nb is 0 but the request contains values to\n             * write) so it's necessary to flush. */\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal number of values %d in write_bits (max %d)\\n\",\n                nb, MODBUS_MAX_WRITE_BITS);\n        } else if (mapping_address < 0 ||\n                   (mapping_address + nb) > mb_mapping->nb_bits) {\n            rsp_length = response_exception(\n                ctx, &sft,\n                MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_bits\\n\",\n                mapping_address < 0 ? address : address + nb);\n        } else {\n            /* 6 = byte count */\n            modbus_set_bits_from_bytes(mb_mapping->tab_bits, mapping_address, nb,\n                                       &req[offset + 6]);\n\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            /* 4 to copy the bit address (2) and the quantity of bits */\n            memcpy(rsp + rsp_length, req + rsp_length, 4);\n            rsp_length += 4;\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_MULTIPLE_REGISTERS: {\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        int nb_bytes = req[offset + 5];\n        int mapping_address = address - mb_mapping->start_registers;\n\n        if (nb < 1 || MODBUS_MAX_WRITE_REGISTERS < nb || nb_bytes * 8 < nb) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal number of values %d in write_registers (max %d)\\n\",\n                nb, MODBUS_MAX_WRITE_REGISTERS);\n        } else if (mapping_address < 0 ||\n                   (mapping_address + nb) > mb_mapping->nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_registers\\n\",\n                mapping_address < 0 ? address : address + nb);\n        } else {\n            int i, j;\n            for (i = mapping_address, j = 6; i < mapping_address + nb; i++, j += 2) {\n                /* 6 and 7 = first value */\n                mb_mapping->tab_registers[i] =\n                    (req[offset + j] << 8) + req[offset + j + 1];\n            }\n\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            /* 4 to copy the address (2) and the no. of registers */\n            memcpy(rsp + rsp_length, req + rsp_length, 4);\n            rsp_length += 4;\n        }\n    }\n        break;\n    case MODBUS_FC_REPORT_SLAVE_ID: {\n        int str_len;\n        int byte_count_pos;\n\n        rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n        /* Skip byte count for now */\n        byte_count_pos = rsp_length++;\n        rsp[rsp_length++] = _REPORT_SLAVE_ID;\n        /* Run indicator status to ON */\n        rsp[rsp_length++] = 0xFF;\n        /* LMB + length of LIBMODBUS_VERSION_STRING */\n        str_len = 3 + strlen(LIBMODBUS_VERSION_STRING);\n        memcpy(rsp + rsp_length, \"LMB\" LIBMODBUS_VERSION_STRING, str_len);\n        rsp_length += str_len;\n        rsp[byte_count_pos] = rsp_length - byte_count_pos - 1;\n    }\n        break;\n    case MODBUS_FC_READ_EXCEPTION_STATUS:\n        if (ctx->debug) {\n            fprintf(stderr, \"FIXME Not implemented\\n\");\n        }\n        errno = ENOPROTOOPT;\n        return -1;\n        break;\n    case MODBUS_FC_MASK_WRITE_REGISTER: {\n        int mapping_address = address - mb_mapping->start_registers;\n\n        if (mapping_address < 0 || mapping_address >= mb_mapping->nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data address 0x%0X in write_register\\n\",\n                address);\n        } else {\n            uint16_t data = mb_mapping->tab_registers[mapping_address];\n            uint16_t and = (req[offset + 3] << 8) + req[offset + 4];\n            uint16_t or = (req[offset + 5] << 8) + req[offset + 6];\n\n            data = (data & and) | (or & (~and));\n            mb_mapping->tab_registers[mapping_address] = data;\n            memcpy(rsp, req, req_length);\n            rsp_length = req_length;\n        }\n    }\n        break;\n    case MODBUS_FC_WRITE_AND_READ_REGISTERS: {\n        int nb = (req[offset + 3] << 8) + req[offset + 4];\n        uint16_t address_write = (req[offset + 5] << 8) + req[offset + 6];\n        int nb_write = (req[offset + 7] << 8) + req[offset + 8];\n        int nb_write_bytes = req[offset + 9];\n        int mapping_address = address - mb_mapping->start_registers;\n        int mapping_address_write = address_write - mb_mapping->start_registers;\n\n        if (nb_write < 1 || MODBUS_MAX_WR_WRITE_REGISTERS < nb_write ||\n            nb < 1 || MODBUS_MAX_WR_READ_REGISTERS < nb ||\n            nb_write_bytes != nb_write * 2) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_VALUE, rsp, TRUE,\n                \"Illegal nb of values (W%d, R%d) in write_and_read_registers (max W%d, R%d)\\n\",\n                nb_write, nb, MODBUS_MAX_WR_WRITE_REGISTERS, MODBUS_MAX_WR_READ_REGISTERS);\n        } else if (mapping_address < 0 ||\n                   (mapping_address + nb) > mb_mapping->nb_registers ||\n                   mapping_address < 0 ||\n                   (mapping_address_write + nb_write) > mb_mapping->nb_registers) {\n            rsp_length = response_exception(\n                ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_DATA_ADDRESS, rsp, FALSE,\n                \"Illegal data read address 0x%0X or write address 0x%0X write_and_read_registers\\n\",\n                mapping_address < 0 ? address : address + nb,\n                mapping_address_write < 0 ? address_write : address_write + nb_write);\n        } else {\n            int i, j;\n            rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n            rsp[rsp_length++] = nb << 1;\n\n            /* Write first.\n               10 and 11 are the offset of the first values to write */\n            for (i = mapping_address_write, j = 10;\n                 i < mapping_address_write + nb_write; i++, j += 2) {\n                mb_mapping->tab_registers[i] =\n                    (req[offset + j] << 8) + req[offset + j + 1];\n            }\n\n            /* and read the data for the response */\n            for (i = mapping_address; i < mapping_address + nb; i++) {\n                rsp[rsp_length++] = mb_mapping->tab_registers[i] >> 8;\n                rsp[rsp_length++] = mb_mapping->tab_registers[i] & 0xFF;\n            }\n        }\n    }\n        break;\n\n    default:\n        rsp_length = response_exception(\n            ctx, &sft, MODBUS_EXCEPTION_ILLEGAL_FUNCTION, rsp, TRUE,\n            \"Unknown Modbus function code: 0x%0X\\n\", function);\n        break;\n    }\n\n    /* Suppress any responses when the request was a broadcast */\n    return (ctx->backend->backend_type == _MODBUS_BACKEND_TYPE_RTU &&\n            slave == MODBUS_BROADCAST_ADDRESS) ? 0 : send_msg(ctx, rsp, rsp_length);\n}\n\nint modbus_reply_exception(modbus_t *ctx, const uint8_t *req,\n                           unsigned int exception_code)\n{\n    int offset;\n    int slave;\n    int function;\n    uint8_t rsp[MAX_MESSAGE_LENGTH];\n    int rsp_length;\n    int dummy_length = 99;\n    sft_t sft;\n\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    offset = ctx->backend->header_length;\n    slave = req[offset - 1];\n    function = req[offset];\n\n    sft.slave = slave;\n    sft.function = function + 0x80;\n    sft.t_id = ctx->backend->prepare_response_tid(req, &dummy_length);\n    rsp_length = ctx->backend->build_response_basis(&sft, rsp);\n\n    /* Positive exception code */\n    if (exception_code < MODBUS_EXCEPTION_MAX) {\n        rsp[rsp_length++] = exception_code;\n        return send_msg(ctx, rsp, rsp_length);\n    } else {\n        errno = EINVAL;\n        return -1;\n    }\n}\n\n/* Reads IO status */\nstatic int read_io_status(modbus_t *ctx, int function,\n                          int addr, int nb, uint8_t *dest)\n{\n    int rc;\n    int req_length;\n\n    uint8_t req[_MIN_REQ_LENGTH];\n    uint8_t rsp[MAX_MESSAGE_LENGTH];\n\n    req_length = ctx->backend->build_request_basis(ctx, function, addr, nb, req);\n\n    rc = send_msg(ctx, req, req_length);\n    if (rc > 0) {\n        int i, temp, bit;\n        int pos = 0;\n        int offset;\n        int offset_end;\n\n        rc = _modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);\n        if (rc == -1)\n            return -1;\n\n        rc = check_confirmation(ctx, req, rsp, rc);\n        if (rc == -1)\n            return -1;\n\n        offset = ctx->backend->header_length + 2;\n        offset_end = offset + rc;\n        for (i = offset; i < offset_end; i++) {\n            /* Shift reg hi_byte to temp */\n            temp = rsp[i];\n\n            for (bit = 0x01; (bit & 0xff) && (pos < nb);) {\n                dest[pos++] = (temp & bit) ? TRUE : FALSE;\n                bit = bit << 1;\n            }\n\n        }\n    }\n\n    return rc;\n}\n\n/* Reads the boolean status of bits and sets the array elements\n   in the destination to TRUE or FALSE (single bits). */\nint modbus_read_bits(modbus_t *ctx, int addr, int nb, uint8_t *dest)\n{\n    int rc;\n\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    if (nb > MODBUS_MAX_READ_BITS) {\n        if (ctx->debug) {\n            fprintf(stderr,\n                    \"ERROR Too many bits requested (%d > %d)\\n\",\n                    nb, MODBUS_MAX_READ_BITS);\n        }\n        errno = EMBMDATA;\n        return -1;\n    }\n\n    rc = read_io_status(ctx, MODBUS_FC_READ_COILS, addr, nb, dest);\n\n    if (rc == -1)\n        return -1;\n    else\n        return nb;\n}\n\n\n/* Same as modbus_read_bits but reads the remote device input table */\nint modbus_read_input_bits(modbus_t *ctx, int addr, int nb, uint8_t *dest)\n{\n    int rc;\n\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    if (nb > MODBUS_MAX_READ_BITS) {\n        if (ctx->debug) {\n            fprintf(stderr,\n                    \"ERROR Too many discrete inputs requested (%d > %d)\\n\",\n                    nb, MODBUS_MAX_READ_BITS);\n        }\n        errno = EMBMDATA;\n        return -1;\n    }\n\n    rc = read_io_status(ctx, MODBUS_FC_READ_DISCRETE_INPUTS, addr, nb, dest);\n\n    if (rc == -1)\n        return -1;\n    else\n        return nb;\n}\n\n/* Reads the data from a remove device and put that data into an array */\nstatic int read_registers(modbus_t *ctx, int function, int addr, int nb,\n                          uint16_t *dest)\n{\n    int rc;\n    int req_length;\n    uint8_t req[_MIN_REQ_LENGTH];\n    uint8_t rsp[MAX_MESSAGE_LENGTH];\n\n    if (nb > MODBUS_MAX_READ_REGISTERS) {\n        if (ctx->debug) {\n            fprintf(stderr,\n                    \"ERROR Too many registers requested (%d > %d)\\n\",\n                    nb, MODBUS_MAX_READ_REGISTERS);\n        }\n        errno = EMBMDATA;\n        return -1;\n    }\n\n    req_length = ctx->backend->build_request_basis(ctx, function, addr, nb, req);\n\n    rc = send_msg(ctx, req, req_length);\n    if (rc > 0) {\n        int offset;\n        int i;\n\n        rc = _modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);\n        if (rc == -1)\n            return -1;\n\n        rc = check_confirmation(ctx, req, rsp, rc);\n        if (rc == -1)\n            return -1;\n\n        offset = ctx->backend->header_length;\n\n        for (i = 0; i < rc; i++) {\n            /* shift reg hi_byte to temp OR with lo_byte */\n            dest[i] = (rsp[offset + 2 + (i << 1)] << 8) |\n                rsp[offset + 3 + (i << 1)];\n        }\n    }\n\n    return rc;\n}\n\n/* Reads the holding registers of remote device and put the data into an\n   array */\nint modbus_read_registers(modbus_t *ctx, int addr, int nb, uint16_t *dest)\n{\n    int status;\n\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    if (nb > MODBUS_MAX_READ_REGISTERS) {\n        if (ctx->debug) {\n            fprintf(stderr,\n                    \"ERROR Too many registers requested (%d > %d)\\n\",\n                    nb, MODBUS_MAX_READ_REGISTERS);\n        }\n        errno = EMBMDATA;\n        return -1;\n    }\n\n    status = read_registers(ctx, MODBUS_FC_READ_HOLDING_REGISTERS,\n                            addr, nb, dest);\n    return status;\n}\n\n/* Reads the input registers of remote device and put the data into an array */\nint modbus_read_input_registers(modbus_t *ctx, int addr, int nb,\n                                uint16_t *dest)\n{\n    int status;\n\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    if (nb > MODBUS_MAX_READ_REGISTERS) {\n        fprintf(stderr,\n                \"ERROR Too many input registers requested (%d > %d)\\n\",\n                nb, MODBUS_MAX_READ_REGISTERS);\n        errno = EMBMDATA;\n        return -1;\n    }\n\n    status = read_registers(ctx, MODBUS_FC_READ_INPUT_REGISTERS,\n                            addr, nb, dest);\n\n    return status;\n}\n\n/* Write a value to the specified register of the remote device.\n   Used by write_bit and write_register */\nstatic int write_single(modbus_t *ctx, int function, int addr, int value)\n{\n    int rc;\n    int req_length;\n    uint8_t req[_MIN_REQ_LENGTH];\n\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    req_length = ctx->backend->build_request_basis(ctx, function, addr, value, req);\n\n    rc = send_msg(ctx, req, req_length);\n    if (rc > 0) {\n        /* Used by write_bit and write_register */\n        uint8_t rsp[MAX_MESSAGE_LENGTH];\n\n        rc = _modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);\n        if (rc == -1)\n            return -1;\n\n        rc = check_confirmation(ctx, req, rsp, rc);\n    }\n\n    return rc;\n}\n\n/* Turns ON or OFF a single bit of the remote device */\nint modbus_write_bit(modbus_t *ctx, int addr, int status)\n{\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    return write_single(ctx, MODBUS_FC_WRITE_SINGLE_COIL, addr,\n                        status ? 0xFF00 : 0);\n}\n\n/* Writes a value in one register of the remote device */\nint modbus_write_register(modbus_t *ctx, int addr, int value)\n{\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    return write_single(ctx, MODBUS_FC_WRITE_SINGLE_REGISTER, addr, value);\n}\n\n/* Write the bits of the array in the remote device */\nint modbus_write_bits(modbus_t *ctx, int addr, int nb, const uint8_t *src)\n{\n    int rc;\n    int i;\n    int byte_count;\n    int req_length;\n    int bit_check = 0;\n    int pos = 0;\n    uint8_t req[MAX_MESSAGE_LENGTH];\n\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    if (nb > MODBUS_MAX_WRITE_BITS) {\n        if (ctx->debug) {\n            fprintf(stderr, \"ERROR Writing too many bits (%d > %d)\\n\",\n                    nb, MODBUS_MAX_WRITE_BITS);\n        }\n        errno = EMBMDATA;\n        return -1;\n    }\n\n    req_length = ctx->backend->build_request_basis(ctx,\n                                                   MODBUS_FC_WRITE_MULTIPLE_COILS,\n                                                   addr, nb, req);\n    byte_count = (nb / 8) + ((nb % 8) ? 1 : 0);\n    req[req_length++] = byte_count;\n\n    for (i = 0; i < byte_count; i++) {\n        int bit;\n\n        bit = 0x01;\n        req[req_length] = 0;\n\n        while ((bit & 0xFF) && (bit_check++ < nb)) {\n            if (src[pos++])\n                req[req_length] |= bit;\n            else\n                req[req_length] &=~ bit;\n\n            bit = bit << 1;\n        }\n        req_length++;\n    }\n\n    rc = send_msg(ctx, req, req_length);\n    if (rc > 0) {\n        uint8_t rsp[MAX_MESSAGE_LENGTH];\n\n        rc = _modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);\n        if (rc == -1)\n            return -1;\n\n        rc = check_confirmation(ctx, req, rsp, rc);\n    }\n\n\n    return rc;\n}\n\n/* Write the values from the array to the registers of the remote device */\nint modbus_write_registers(modbus_t *ctx, int addr, int nb, const uint16_t *src)\n{\n    int rc;\n    int i;\n    int req_length;\n    int byte_count;\n    uint8_t req[MAX_MESSAGE_LENGTH];\n\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    if (nb > MODBUS_MAX_WRITE_REGISTERS) {\n        if (ctx->debug) {\n            fprintf(stderr,\n                    \"ERROR Trying to write to too many registers (%d > %d)\\n\",\n                    nb, MODBUS_MAX_WRITE_REGISTERS);\n        }\n        errno = EMBMDATA;\n        return -1;\n    }\n\n    req_length = ctx->backend->build_request_basis(ctx,\n                                                   MODBUS_FC_WRITE_MULTIPLE_REGISTERS,\n                                                   addr, nb, req);\n    byte_count = nb * 2;\n    req[req_length++] = byte_count;\n\n    for (i = 0; i < nb; i++) {\n        req[req_length++] = src[i] >> 8;\n        req[req_length++] = src[i] & 0x00FF;\n    }\n\n    rc = send_msg(ctx, req, req_length);\n    if (rc > 0) {\n        uint8_t rsp[MAX_MESSAGE_LENGTH];\n\n        rc = _modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);\n        if (rc == -1)\n            return -1;\n\n        rc = check_confirmation(ctx, req, rsp, rc);\n    }\n\n    return rc;\n}\n\nint modbus_mask_write_register(modbus_t *ctx, int addr, uint16_t and_mask, uint16_t or_mask)\n{\n    int rc;\n    int req_length;\n    /* The request length can not exceed _MIN_REQ_LENGTH - 2 and 4 bytes to\n     * store the masks. The ugly substraction is there to remove the 'nb' value\n     * (2 bytes) which is not used. */\n    uint8_t req[_MIN_REQ_LENGTH + 2];\n\n    req_length = ctx->backend->build_request_basis(ctx,\n                                                   MODBUS_FC_MASK_WRITE_REGISTER,\n                                                   addr, 0, req);\n\n    /* HACKISH, count is not used */\n    req_length -= 2;\n\n    req[req_length++] = and_mask >> 8;\n    req[req_length++] = and_mask & 0x00ff;\n    req[req_length++] = or_mask >> 8;\n    req[req_length++] = or_mask & 0x00ff;\n\n    rc = send_msg(ctx, req, req_length);\n    if (rc > 0) {\n        /* Used by write_bit and write_register */\n        uint8_t rsp[MAX_MESSAGE_LENGTH];\n\n        rc = _modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);\n        if (rc == -1)\n            return -1;\n\n        rc = check_confirmation(ctx, req, rsp, rc);\n    }\n\n    return rc;\n}\n\n/* Write multiple registers from src array to remote device and read multiple\n   registers from remote device to dest array. */\nint modbus_write_and_read_registers(modbus_t *ctx,\n                                    int write_addr, int write_nb,\n                                    const uint16_t *src,\n                                    int read_addr, int read_nb,\n                                    uint16_t *dest)\n\n{\n    int rc;\n    int req_length;\n    int i;\n    int byte_count;\n    uint8_t req[MAX_MESSAGE_LENGTH];\n    uint8_t rsp[MAX_MESSAGE_LENGTH];\n\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    if (write_nb > MODBUS_MAX_WR_WRITE_REGISTERS) {\n        if (ctx->debug) {\n            fprintf(stderr,\n                    \"ERROR Too many registers to write (%d > %d)\\n\",\n                    write_nb, MODBUS_MAX_WR_WRITE_REGISTERS);\n        }\n        errno = EMBMDATA;\n        return -1;\n    }\n\n    if (read_nb > MODBUS_MAX_WR_READ_REGISTERS) {\n        if (ctx->debug) {\n            fprintf(stderr,\n                    \"ERROR Too many registers requested (%d > %d)\\n\",\n                    read_nb, MODBUS_MAX_WR_READ_REGISTERS);\n        }\n        errno = EMBMDATA;\n        return -1;\n    }\n    req_length = ctx->backend->build_request_basis(ctx,\n                                                   MODBUS_FC_WRITE_AND_READ_REGISTERS,\n                                                   read_addr, read_nb, req);\n\n    req[req_length++] = write_addr >> 8;\n    req[req_length++] = write_addr & 0x00ff;\n    req[req_length++] = write_nb >> 8;\n    req[req_length++] = write_nb & 0x00ff;\n    byte_count = write_nb * 2;\n    req[req_length++] = byte_count;\n\n    for (i = 0; i < write_nb; i++) {\n        req[req_length++] = src[i] >> 8;\n        req[req_length++] = src[i] & 0x00FF;\n    }\n\n    rc = send_msg(ctx, req, req_length);\n    if (rc > 0) {\n        int offset;\n\n        rc = _modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);\n        if (rc == -1)\n            return -1;\n\n        rc = check_confirmation(ctx, req, rsp, rc);\n        if (rc == -1)\n            return -1;\n\n        offset = ctx->backend->header_length;\n        for (i = 0; i < rc; i++) {\n            /* shift reg hi_byte to temp OR with lo_byte */\n            dest[i] = (rsp[offset + 2 + (i << 1)] << 8) |\n                rsp[offset + 3 + (i << 1)];\n        }\n    }\n\n    return rc;\n}\n\n/* Send a request to get the slave ID of the device (only available in serial\n   communication). */\nint modbus_report_slave_id(modbus_t *ctx, int max_dest, uint8_t *dest)\n{\n    int rc;\n    int req_length;\n    uint8_t req[_MIN_REQ_LENGTH];\n\n    if (ctx == NULL || max_dest <= 0) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    req_length = ctx->backend->build_request_basis(ctx, MODBUS_FC_REPORT_SLAVE_ID,\n                                                   0, 0, req);\n\n    /* HACKISH, addr and count are not used */\n    req_length -= 4;\n\n    rc = send_msg(ctx, req, req_length);\n    if (rc > 0) {\n        int i;\n        int offset;\n        uint8_t rsp[MAX_MESSAGE_LENGTH];\n\n        rc = _modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);\n        if (rc == -1)\n            return -1;\n\n        rc = check_confirmation(ctx, req, rsp, rc);\n        if (rc == -1)\n            return -1;\n\n        offset = ctx->backend->header_length + 2;\n\n        /* Byte count, slave id, run indicator status and\n           additional data. Truncate copy to max_dest. */\n        for (i=0; i < rc && i < max_dest; i++) {\n            dest[i] = rsp[offset + i];\n        }\n    }\n\n    return rc;\n}\n\nvoid _modbus_init_common(modbus_t *ctx)\n{\n    /* Slave and socket are initialized to -1 */\n    ctx->slave = -1;\n    ctx->s = -1;\n\n    ctx->debug = FALSE;\n    ctx->error_recovery = MODBUS_ERROR_RECOVERY_NONE;\n\n    ctx->response_timeout.tv_sec = 0;\n    ctx->response_timeout.tv_usec = _RESPONSE_TIMEOUT;\n\n    ctx->byte_timeout.tv_sec = 0;\n    ctx->byte_timeout.tv_usec = _BYTE_TIMEOUT;\n\n    ctx->indication_timeout.tv_sec = 0;\n    ctx->indication_timeout.tv_usec = 0;\n}\n\n/* Define the slave number */\nint modbus_set_slave(modbus_t *ctx, int slave)\n{\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    return ctx->backend->set_slave(ctx, slave);\n}\n\nint modbus_get_slave(modbus_t *ctx)\n{\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    return ctx->slave;\n}\n\nint modbus_set_error_recovery(modbus_t *ctx,\n                              modbus_error_recovery_mode error_recovery)\n{\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    /* The type of modbus_error_recovery_mode is unsigned enum */\n    ctx->error_recovery = (uint8_t) error_recovery;\n    return 0;\n}\n\nint modbus_set_socket(modbus_t *ctx, int s)\n{\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    ctx->s = s;\n    return 0;\n}\n\nint modbus_get_socket(modbus_t *ctx)\n{\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    return ctx->s;\n}\n\n/* Get the timeout interval used to wait for a response */\nint modbus_get_response_timeout(modbus_t *ctx, uint32_t *to_sec, uint32_t *to_usec)\n{\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    *to_sec = ctx->response_timeout.tv_sec;\n    *to_usec = ctx->response_timeout.tv_usec;\n    return 0;\n}\n\nint modbus_set_response_timeout(modbus_t *ctx, uint32_t to_sec, uint32_t to_usec)\n{\n    if (ctx == NULL ||\n        (to_sec == 0 && to_usec == 0) || to_usec > 999999) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    ctx->response_timeout.tv_sec = to_sec;\n    ctx->response_timeout.tv_usec = to_usec;\n    return 0;\n}\n\n/* Get the timeout interval between two consecutive bytes of a message */\nint modbus_get_byte_timeout(modbus_t *ctx, uint32_t *to_sec, uint32_t *to_usec)\n{\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    *to_sec = ctx->byte_timeout.tv_sec;\n    *to_usec = ctx->byte_timeout.tv_usec;\n    return 0;\n}\n\nint modbus_set_byte_timeout(modbus_t *ctx, uint32_t to_sec, uint32_t to_usec)\n{\n    /* Byte timeout can be disabled when both values are zero */\n    if (ctx == NULL || to_usec > 999999) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    ctx->byte_timeout.tv_sec = to_sec;\n    ctx->byte_timeout.tv_usec = to_usec;\n    return 0;\n}\n\n/* Get the timeout interval used by the server to wait for an indication from a client */\nint modbus_get_indication_timeout(modbus_t *ctx, uint32_t *to_sec, uint32_t *to_usec)\n{\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    *to_sec = ctx->indication_timeout.tv_sec;\n    *to_usec = ctx->indication_timeout.tv_usec;\n    return 0;\n}\n\nint modbus_set_indication_timeout(modbus_t *ctx, uint32_t to_sec, uint32_t to_usec)\n{\n    /* Indication timeout can be disabled when both values are zero */\n    if (ctx == NULL || to_usec > 999999) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    ctx->indication_timeout.tv_sec = to_sec;\n    ctx->indication_timeout.tv_usec = to_usec;\n    return 0;\n}\n\nint modbus_get_header_length(modbus_t *ctx)\n{\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    return ctx->backend->header_length;\n}\n\nint modbus_connect(modbus_t *ctx)\n{\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    return ctx->backend->connect(ctx);\n}\n\nvoid modbus_close(modbus_t *ctx)\n{\n    if (ctx == NULL)\n        return;\n\n    ctx->backend->close(ctx);\n}\n\nvoid modbus_free(modbus_t *ctx)\n{\n    if (ctx == NULL)\n        return;\n\n    ctx->backend->free(ctx);\n}\n\nint modbus_set_debug(modbus_t *ctx, int flag)\n{\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n\n    ctx->debug = flag;\n    return 0;\n}\n\n/* Allocates 4 arrays to store bits, input bits, registers and inputs\n   registers. The pointers are stored in modbus_mapping structure.\n\n   The modbus_mapping_new_start_address() function shall return the new allocated\n   structure if successful. Otherwise it shall return NULL and set errno to\n   ENOMEM. */\nmodbus_mapping_t* modbus_mapping_new_start_address(\n    unsigned int start_bits, unsigned int nb_bits,\n    unsigned int start_input_bits, unsigned int nb_input_bits,\n    unsigned int start_registers, unsigned int nb_registers,\n    unsigned int start_input_registers, unsigned int nb_input_registers)\n{\n    modbus_mapping_t *mb_mapping;\n\n    mb_mapping = (modbus_mapping_t *)malloc(sizeof(modbus_mapping_t));\n    if (mb_mapping == NULL) {\n        return NULL;\n    }\n\n    /* 0X */\n    mb_mapping->nb_bits = nb_bits;\n    mb_mapping->start_bits = start_bits;\n    if (nb_bits == 0) {\n        mb_mapping->tab_bits = NULL;\n    } else {\n        /* Negative number raises a POSIX error */\n        mb_mapping->tab_bits =\n            (uint8_t *) malloc(nb_bits * sizeof(uint8_t));\n        if (mb_mapping->tab_bits == NULL) {\n            free(mb_mapping);\n            return NULL;\n        }\n        memset(mb_mapping->tab_bits, 0, nb_bits * sizeof(uint8_t));\n    }\n\n    /* 1X */\n    mb_mapping->nb_input_bits = nb_input_bits;\n    mb_mapping->start_input_bits = start_input_bits;\n    if (nb_input_bits == 0) {\n        mb_mapping->tab_input_bits = NULL;\n    } else {\n        mb_mapping->tab_input_bits =\n            (uint8_t *) malloc(nb_input_bits * sizeof(uint8_t));\n        if (mb_mapping->tab_input_bits == NULL) {\n            free(mb_mapping->tab_bits);\n            free(mb_mapping);\n            return NULL;\n        }\n        memset(mb_mapping->tab_input_bits, 0, nb_input_bits * sizeof(uint8_t));\n    }\n\n    /* 4X */\n    mb_mapping->nb_registers = nb_registers;\n    mb_mapping->start_registers = start_registers;\n    if (nb_registers == 0) {\n        mb_mapping->tab_registers = NULL;\n    } else {\n        mb_mapping->tab_registers =\n            (uint16_t *) malloc(nb_registers * sizeof(uint16_t));\n        if (mb_mapping->tab_registers == NULL) {\n            free(mb_mapping->tab_input_bits);\n            free(mb_mapping->tab_bits);\n            free(mb_mapping);\n            return NULL;\n        }\n        memset(mb_mapping->tab_registers, 0, nb_registers * sizeof(uint16_t));\n    }\n\n    /* 3X */\n    mb_mapping->nb_input_registers = nb_input_registers;\n    mb_mapping->start_input_registers = start_input_registers;\n    if (nb_input_registers == 0) {\n        mb_mapping->tab_input_registers = NULL;\n    } else {\n        mb_mapping->tab_input_registers =\n            (uint16_t *) malloc(nb_input_registers * sizeof(uint16_t));\n        if (mb_mapping->tab_input_registers == NULL) {\n            free(mb_mapping->tab_registers);\n            free(mb_mapping->tab_input_bits);\n            free(mb_mapping->tab_bits);\n            free(mb_mapping);\n            return NULL;\n        }\n        memset(mb_mapping->tab_input_registers, 0,\n               nb_input_registers * sizeof(uint16_t));\n    }\n\n    return mb_mapping;\n}\n\nmodbus_mapping_t* modbus_mapping_new(int nb_bits, int nb_input_bits,\n                                     int nb_registers, int nb_input_registers)\n{\n    return modbus_mapping_new_start_address(\n        0, nb_bits, 0, nb_input_bits, 0, nb_registers, 0, nb_input_registers);\n}\n\n/* Frees the 4 arrays */\nvoid modbus_mapping_free(modbus_mapping_t *mb_mapping)\n{\n    if (mb_mapping == NULL) {\n        return;\n    }\n\n    free(mb_mapping->tab_input_registers);\n    free(mb_mapping->tab_registers);\n    free(mb_mapping->tab_input_bits);\n    free(mb_mapping->tab_bits);\n    free(mb_mapping);\n}\n\n#ifndef HAVE_STRLCPY\n/*\n * Function strlcpy was originally developed by\n * Todd C. Miller <Todd.Miller@courtesan.com> to simplify writing secure code.\n * See ftp://ftp.openbsd.org/pub/OpenBSD/src/lib/libc/string/strlcpy.3\n * for more information.\n *\n * Thank you Ulrich Drepper... not!\n *\n * Copy src to string dest of size dest_size.  At most dest_size-1 characters\n * will be copied.  Always NUL terminates (unless dest_size == 0).  Returns\n * strlen(src); if retval >= dest_size, truncation occurred.\n */\nsize_t strlcpy(char *dest, const char *src, size_t dest_size)\n{\n    register char *d = dest;\n    register const char *s = src;\n    register size_t n = dest_size;\n\n    /* Copy as many bytes as will fit */\n    if (n != 0 && --n != 0) {\n        do {\n            if ((*d++ = *s++) == 0)\n                break;\n        } while (--n != 0);\n    }\n\n    /* Not enough room in dest, add NUL and traverse rest of src */\n    if (n == 0) {\n        if (dest_size != 0)\n            *d = '\\0'; /* NUL-terminate dest */\n        while (*s++)\n            ;\n    }\n\n    return (s - src - 1); /* count does not include NUL */\n}\n#endif\n"], "filenames": ["src/modbus.c"], "buggy_code_start_loc": [841], "buggy_code_end_loc": [876], "fixing_code_start_loc": [842], "fixing_code_end_loc": [878], "type": "CWE-125", "message": "An issue was discovered in libmodbus before 3.0.7 and 3.1.x before 3.1.5. There is an out-of-bounds read for the MODBUS_FC_WRITE_MULTIPLE_COILS case, aka VD-1302.", "other": {"cve": {"id": "CVE-2019-14462", "sourceIdentifier": "cve@mitre.org", "published": "2019-07-31T23:15:10.950", "lastModified": "2021-11-23T22:24:18.667", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in libmodbus before 3.0.7 and 3.1.x before 3.1.5. There is an out-of-bounds read for the MODBUS_FC_WRITE_MULTIPLE_COILS case, aka VD-1302."}, {"lang": "es", "value": "Un problema fue descubierto en LIbmodbus anterior a 3.0.7 y 3.1 x anterior a 3.1.5. hay lectura fuera de l\u00edmites para el caso  MODBUS_FC_WRITE_MULTIPLE_COILS , tambi\u00e9n conocido como VD-1302"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libmodbus:libmodbus:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.0.7", "matchCriteriaId": "4AFB41B9-ADCC-4197-A546-F136695D1D47"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libmodbus:libmodbus:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.1.0", "versionEndExcluding": "3.1.5", "matchCriteriaId": "B997AA7F-46D8-4818-8EDC-3FB5E537AFA4"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:29:*:*:*:*:*:*:*", "matchCriteriaId": "D100F7CE-FC64-4CC6-852A-6136D72DA419"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/stephane/libmodbus/commit/5ccdf5ef79d742640355d1132fa9e2abc7fbaefc", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://libmodbus.org/2019/stable-and-development-releases/", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/11/msg00020.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/HAGHQFJTJCMYHW553OUWJ3YIJR6PJHB7/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PRAQZXGAZY6UGWZ6CD33QEFLL7AWW233/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/stephane/libmodbus/commit/5ccdf5ef79d742640355d1132fa9e2abc7fbaefc"}}