{"buggy_code": ["'use strict';\n\nvar isGlob = require('is-glob');\nvar pathPosixDirname = require('path').posix.dirname;\nvar isWin32 = require('os').platform() === 'win32';\n\nvar slash = '/';\nvar backslash = /\\\\/g;\nvar enclosure = /[{[].*\\/.*[}\\]]$/;\nvar globby = /(^|[^\\\\])([{[]|\\([^)]+$)/;\nvar escaped = /\\\\([!*?|[\\](){}])/g;\n\n/**\n * @param {string} str\n * @param {Object} opts\n * @param {boolean} [opts.flipBackslashes=true]\n */\nmodule.exports = function globParent(str, opts) {\n  var options = Object.assign({ flipBackslashes: true }, opts);\n\n  // flip windows path separators\n  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {\n    str = str.replace(backslash, slash);\n  }\n\n  // special case for strings ending in enclosure containing path separator\n  if (enclosure.test(str)) {\n    str += slash;\n  }\n\n  // preserves full path in case of trailing path separator\n  str += 'a';\n\n  // remove path parts that are globby\n  do {\n    str = pathPosixDirname(str);\n  } while (isGlob(str) || globby.test(str));\n\n  // remove escape chars and return result\n  return str.replace(escaped, '$1');\n};\n", "'use strict';\n\nvar gp = require('../');\nvar expect = require('expect');\nvar isWin32 = require('os').platform() === 'win32';\n\ndescribe('glob-parent', function () {\n  it('should strip glob magic to return parent path', function (done) {\n    expect(gp('.')).toEqual('.');\n    expect(gp('.*')).toEqual('.');\n    expect(gp('/.*')).toEqual('/');\n    expect(gp('/.*/')).toEqual('/');\n    expect(gp('a/.*/b')).toEqual('a');\n    expect(gp('a*/.*/b')).toEqual('.');\n    expect(gp('*/a/b/c')).toEqual('.');\n    expect(gp('*')).toEqual('.');\n    expect(gp('*/')).toEqual('.');\n    expect(gp('*/*')).toEqual('.');\n    expect(gp('*/*/')).toEqual('.');\n    expect(gp('**')).toEqual('.');\n    expect(gp('**/')).toEqual('.');\n    expect(gp('**/*')).toEqual('.');\n    expect(gp('**/*/')).toEqual('.');\n    expect(gp('/*.js')).toEqual('/');\n    expect(gp('*.js')).toEqual('.');\n    expect(gp('**/*.js')).toEqual('.');\n    expect(gp('{a,b}')).toEqual('.');\n    expect(gp('/{a,b}')).toEqual('/');\n    expect(gp('/{a,b}/')).toEqual('/');\n    expect(gp('(a|b)')).toEqual('.');\n    expect(gp('/(a|b)')).toEqual('/');\n    expect(gp('./(a|b)')).toEqual('.');\n    expect(gp('a/(b c)')).toEqual('a'); // not an extglob\n    expect(gp('a/(b c)/')).toEqual('a/(b c)'); // not an extglob\n    expect(gp('a/(b c)/d')).toEqual('a/(b c)'); // not an extglob\n    expect(gp('path/to/*.js')).toEqual('path/to');\n    expect(gp('/root/path/to/*.js')).toEqual('/root/path/to');\n    expect(gp('chapter/foo [bar]/')).toEqual('chapter');\n    expect(gp('path/[a-z]')).toEqual('path');\n    expect(gp('[a-z]')).toEqual('.');\n    expect(gp('path/{to,from}')).toEqual('path');\n    expect(gp('path/(to|from)')).toEqual('path');\n    expect(gp('path/(foo bar)/subdir/foo.*')).toEqual('path/(foo bar)/subdir');\n    expect(gp('path/!(to|from)')).toEqual('path');\n    expect(gp('path/?(to|from)')).toEqual('path');\n    expect(gp('path/+(to|from)')).toEqual('path');\n    expect(gp('path/*(to|from)')).toEqual('path');\n    expect(gp('path/@(to|from)')).toEqual('path');\n    expect(gp('path/!/foo')).toEqual('path/!');\n    expect(gp('path/?/foo')).toEqual('path/?');\n    expect(gp('path/+/foo')).toEqual('path/+');\n    expect(gp('path/*/foo')).toEqual('path');\n    expect(gp('path/@/foo')).toEqual('path/@');\n    expect(gp('path/!/foo/')).toEqual('path/!/foo');\n    expect(gp('path/?/foo/')).toEqual('path/?/foo');\n    expect(gp('path/+/foo/')).toEqual('path/+/foo');\n    expect(gp('path/*/foo/')).toEqual('path');\n    expect(gp('path/@/foo/')).toEqual('path/@/foo');\n    expect(gp('path/**/*')).toEqual('path');\n    expect(gp('path/**/subdir/foo.*')).toEqual('path');\n    expect(gp('path/subdir/**/foo.js')).toEqual('path/subdir');\n    expect(gp('path/!subdir/foo.js')).toEqual('path/!subdir');\n    expect(gp('path/{foo,bar}/')).toEqual('path');\n\n    done();\n  });\n\n  it('should respect escaped characters', function (done) {\n    expect(gp('path/\\\\*\\\\*/subdir/foo.*')).toEqual('path/**/subdir');\n    expect(gp('path/\\\\[\\\\*\\\\]/subdir/foo.*')).toEqual('path/[*]/subdir');\n    expect(gp('path/\\\\*(a|b)/subdir/foo.*')).toEqual('path');\n    expect(gp('path/\\\\*/(a|b)/subdir/foo.*')).toEqual('path/*');\n    expect(gp('path/\\\\*\\\\(a\\\\|b\\\\)/subdir/foo.*')).toEqual(\n      'path/*(a|b)/subdir'\n    );\n    expect(gp('path/\\\\[foo bar\\\\]/subdir/foo.*')).toEqual(\n      'path/[foo bar]/subdir'\n    );\n    expect(gp('path/\\\\[bar]/')).toEqual('path/[bar]');\n    expect(gp('path/\\\\[bar]')).toEqual('path');\n    expect(gp('[bar]')).toEqual('.');\n    expect(gp('[bar]/')).toEqual('.');\n    expect(gp('./\\\\[bar]')).toEqual('.');\n    expect(gp('\\\\[bar]/')).toEqual('[bar]');\n    expect(gp('\\\\!dir/*')).toEqual('!dir');\n    expect(gp('[bar\\\\]/')).toEqual('.');\n    expect(gp('path/foo \\\\[bar]/')).toEqual('path/foo [bar]');\n    expect(gp('path/\\\\{foo,bar}/')).toEqual('path/{foo,bar}');\n    expect(gp('\\\\{foo,bar}/')).toEqual('{foo,bar}');\n    expect(gp('\\\\{foo,bar\\\\}/')).toEqual('{foo,bar}');\n    expect(gp('{foo,bar\\\\}/')).toEqual('.');\n\n    if (isWin32) {\n      // On Windows we are trying to flip backslashes foo-\\\\( \u2192 foo-/(\n      expect(gp('foo-\\\\(bar\\\\).md')).toEqual('foo-');\n    } else {\n      expect(gp('foo-\\\\(bar\\\\).md')).toEqual('.');\n      expect(gp('\\\\[bar]')).toEqual('.');\n      expect(gp('[bar\\\\]')).toEqual('.');\n      expect(gp('\\\\{foo,bar\\\\}')).toEqual('.');\n      expect(gp('{foo,bar\\\\}')).toEqual('.');\n    }\n\n    done();\n  });\n\n  it('should respect glob enclosures with embedded separators', function (done) {\n    /* eslint-disable no-useless-escape */\n    expect(gp('path/{,/,bar/baz,qux}/')).toEqual('path');\n    expect(gp('path/\\\\{,/,bar/baz,qux}/')).toEqual('path/{,/,bar/baz,qux}');\n    expect(gp('path/\\\\{,/,bar/baz,qux\\\\}/')).toEqual('path/{,/,bar/baz,qux}');\n    expect(gp('/{,/,bar/baz,qux}/')).toEqual('/');\n    expect(gp('/\\\\{,/,bar/baz,qux}/')).toEqual('/{,/,bar/baz,qux}');\n    expect(gp('{,/,bar/baz,qux}')).toEqual('.');\n    expect(gp('\\\\{,/,bar/baz,qux\\\\}')).toEqual('{,/,bar/baz,qux}');\n    expect(gp('\\\\{,/,bar/baz,qux}/')).toEqual('{,/,bar/baz,qux}');\n    expect(gp('path/foo[a\\\\/]/')).toEqual('path');\n    expect(gp('path/foo\\\\[a\\\\/]/')).toEqual('path/foo[a\\\\/]');\n    expect(gp('foo[a\\\\/]')).toEqual('.');\n    expect(gp('foo\\\\[a\\\\/]')).toEqual('foo[a\\\\/]');\n    expect(gp('path/(foo/bar|baz)')).toEqual('path');\n    expect(gp('path/(foo/bar|baz)/')).toEqual('path');\n    expect(gp('path/\\\\(foo/bar|baz)/')).toEqual('path/(foo/bar|baz)');\n    /* eslint-enable no-useless-escape */\n\n    done();\n  });\n\n  it('should handle nested braces', function (done) {\n    expect(gp('path/{../,./,{bar,/baz\\\\},qux\\\\}/')).toEqual('path');\n    expect(gp('path/{../,./,\\\\{bar,/baz},qux}/')).toEqual('path');\n    expect(gp('path/\\\\{../,./,\\\\{bar,/baz\\\\},qux\\\\}/')).toEqual(\n      'path/{../,./,{bar,/baz},qux}'\n    );\n    expect(gp('{../,./,{bar,/baz\\\\},qux\\\\}/')).toEqual('.');\n    expect(gp('{../,./,{bar,/baz\\\\},qux\\\\}')).toEqual('.');\n    expect(gp('path/{,/,bar/{baz,qux\\\\}}/')).toEqual('path');\n    expect(gp('path/{,/,bar/{baz,qux}\\\\}/')).toEqual('path');\n    // expect(gp('path/\\\\{../,./,{bar,/baz},qux}/')).toEqual('path');\n\n    done();\n  });\n\n  it('should return parent dirname from non-glob paths', function (done) {\n    expect(gp('path')).toEqual('.');\n    expect(gp('path/foo')).toEqual('path');\n    expect(gp('path/foo/')).toEqual('path/foo');\n    expect(gp('path/foo/bar.js')).toEqual('path/foo');\n\n    done();\n  });\n\n  it('should respect disabled auto flip backslashes', function (done) {\n    expect(gp('foo-\\\\(bar\\\\).md', { flipBackslashes: false })).toEqual('.');\n\n    done();\n  });\n});\n\ndescribe('glob2base test patterns', function () {\n  it('should get a base name', function (done) {\n    expect(gp('js/*.js')).toEqual('js');\n\n    done();\n  });\n\n  it('should get a base name from a nested glob', function (done) {\n    expect(gp('js/**/test/*.js')).toEqual('js');\n\n    done();\n  });\n\n  it('should get a base name from a flat file', function (done) {\n    expect(gp('js/test/wow.js')).toEqual('js/test');\n    expect(gp('js/test/wow.js')).toEqual('js/test');\n\n    done();\n  });\n\n  it('should get a base name from character class pattern', function (done) {\n    expect(gp('js/t[a-z]st}/*.js')).toEqual('js');\n\n    done();\n  });\n\n  it('should get a base name from brace , expansion', function (done) {\n    expect(gp('js/{src,test}/*.js')).toEqual('js');\n\n    done();\n  });\n\n  it('should get a base name from brace .. expansion', function (done) {\n    expect(gp('js/test{0..9}/*.js')).toEqual('js');\n\n    done();\n  });\n\n  it('should get a base name from extglob', function (done) {\n    expect(gp('js/t+(wo|est)/*.js')).toEqual('js');\n\n    done();\n  });\n\n  it('should get a base name from a path with non-exglob parens', function (done) {\n    expect(gp('js/t(wo|est)/*.js')).toEqual('js');\n    expect(gp('js/t/(wo|est)/*.js')).toEqual('js/t');\n\n    done();\n  });\n\n  it('should get a base name from a complex brace glob', function (done) {\n    expect(gp('lib/{components,pages}/**/{test,another}/*.txt')).toEqual('lib');\n\n    expect(gp('js/test/**/{images,components}/*.js')).toEqual('js/test');\n\n    expect(gp('ooga/{booga,sooga}/**/dooga/{eooga,fooga}')).toEqual('ooga');\n\n    done();\n  });\n\n  it('should not be susceptible to SNYK-JS-GLOBPARENT-1016905', function (done) {\n    // This will time out if susceptible.\n    gp('{' + '/'.repeat(5000));\n\n    done();\n  });\n});\n\nif (isWin32) {\n  describe('technically invalid windows globs', function () {\n    it('should manage simple globs with backslash path separator', function (done) {\n      expect(gp('C:\\\\path\\\\*.js')).toEqual('C:/path');\n\n      done();\n    });\n  });\n}\n"], "fixing_code": ["'use strict';\n\nvar isGlob = require('is-glob');\nvar pathPosixDirname = require('path').posix.dirname;\nvar isWin32 = require('os').platform() === 'win32';\n\nvar slash = '/';\nvar backslash = /\\\\/g;\nvar globby = /(^|[^\\\\])([{[]|\\([^)]+$)/;\nvar escaped = /\\\\([!*?|[\\](){}])/g;\n\n/**\n * @param {string} str\n * @param {Object} opts\n * @param {boolean} [opts.flipBackslashes=true]\n */\nmodule.exports = function globParent(str, opts) {\n  var options = Object.assign({ flipBackslashes: true }, opts);\n\n  // flip windows path separators\n  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {\n    str = str.replace(backslash, slash);\n  }\n\n  // special case for strings ending in enclosure containing path separator\n  if (isEnclosure(str)) {\n    str += slash;\n  }\n\n  // preserves full path in case of trailing path separator\n  str += 'a';\n\n  // remove path parts that are globby\n  do {\n    str = pathPosixDirname(str);\n  } while (isGlob(str) || globby.test(str));\n\n  // remove escape chars and return result\n  return str.replace(escaped, '$1');\n};\n\n\nfunction isEnclosure(str) {\n  var lastChar = str.slice(-1)\n\n  var enclosureStart;\n  switch (lastChar) {\n    case '}':\n      enclosureStart = '{';\n      break;\n    case ']':\n      enclosureStart = '[';\n      break;\n    default:\n      return false;\n  }\n\n  var foundIndex = str.indexOf(enclosureStart);\n  if (foundIndex < 0) {\n    return false;\n  }\n\n  return str.slice(foundIndex + 1, -1).includes(slash);\n}\n", "'use strict';\n\nvar gp = require('../');\nvar expect = require('expect');\nvar isWin32 = require('os').platform() === 'win32';\n\ndescribe('glob-parent', function () {\n  it('should strip glob magic to return parent path', function (done) {\n    expect(gp('.')).toEqual('.');\n    expect(gp('.*')).toEqual('.');\n    expect(gp('/.*')).toEqual('/');\n    expect(gp('/.*/')).toEqual('/');\n    expect(gp('a/.*/b')).toEqual('a');\n    expect(gp('a*/.*/b')).toEqual('.');\n    expect(gp('*/a/b/c')).toEqual('.');\n    expect(gp('*')).toEqual('.');\n    expect(gp('*/')).toEqual('.');\n    expect(gp('*/*')).toEqual('.');\n    expect(gp('*/*/')).toEqual('.');\n    expect(gp('**')).toEqual('.');\n    expect(gp('**/')).toEqual('.');\n    expect(gp('**/*')).toEqual('.');\n    expect(gp('**/*/')).toEqual('.');\n    expect(gp('/*.js')).toEqual('/');\n    expect(gp('*.js')).toEqual('.');\n    expect(gp('**/*.js')).toEqual('.');\n    expect(gp('{a,b}')).toEqual('.');\n    expect(gp('/{a,b}')).toEqual('/');\n    expect(gp('/{a,b}/')).toEqual('/');\n    expect(gp('(a|b)')).toEqual('.');\n    expect(gp('/(a|b)')).toEqual('/');\n    expect(gp('./(a|b)')).toEqual('.');\n    expect(gp('a/(b c)')).toEqual('a'); // not an extglob\n    expect(gp('a/(b c)/')).toEqual('a/(b c)'); // not an extglob\n    expect(gp('a/(b c)/d')).toEqual('a/(b c)'); // not an extglob\n    expect(gp('path/to/*.js')).toEqual('path/to');\n    expect(gp('/root/path/to/*.js')).toEqual('/root/path/to');\n    expect(gp('chapter/foo [bar]/')).toEqual('chapter');\n    expect(gp('path/[a-z]')).toEqual('path');\n    expect(gp('[a-z]')).toEqual('.');\n    expect(gp('path/{to,from}')).toEqual('path');\n    expect(gp('path/(to|from)')).toEqual('path');\n    expect(gp('path/(foo bar)/subdir/foo.*')).toEqual('path/(foo bar)/subdir');\n    expect(gp('path/!(to|from)')).toEqual('path');\n    expect(gp('path/?(to|from)')).toEqual('path');\n    expect(gp('path/+(to|from)')).toEqual('path');\n    expect(gp('path/*(to|from)')).toEqual('path');\n    expect(gp('path/@(to|from)')).toEqual('path');\n    expect(gp('path/!/foo')).toEqual('path/!');\n    expect(gp('path/?/foo')).toEqual('path/?');\n    expect(gp('path/+/foo')).toEqual('path/+');\n    expect(gp('path/*/foo')).toEqual('path');\n    expect(gp('path/@/foo')).toEqual('path/@');\n    expect(gp('path/!/foo/')).toEqual('path/!/foo');\n    expect(gp('path/?/foo/')).toEqual('path/?/foo');\n    expect(gp('path/+/foo/')).toEqual('path/+/foo');\n    expect(gp('path/*/foo/')).toEqual('path');\n    expect(gp('path/@/foo/')).toEqual('path/@/foo');\n    expect(gp('path/**/*')).toEqual('path');\n    expect(gp('path/**/subdir/foo.*')).toEqual('path');\n    expect(gp('path/subdir/**/foo.js')).toEqual('path/subdir');\n    expect(gp('path/!subdir/foo.js')).toEqual('path/!subdir');\n    expect(gp('path/{foo,bar}/')).toEqual('path');\n\n    done();\n  });\n\n  it('should respect escaped characters', function (done) {\n    expect(gp('path/\\\\*\\\\*/subdir/foo.*')).toEqual('path/**/subdir');\n    expect(gp('path/\\\\[\\\\*\\\\]/subdir/foo.*')).toEqual('path/[*]/subdir');\n    expect(gp('path/\\\\*(a|b)/subdir/foo.*')).toEqual('path');\n    expect(gp('path/\\\\*/(a|b)/subdir/foo.*')).toEqual('path/*');\n    expect(gp('path/\\\\*\\\\(a\\\\|b\\\\)/subdir/foo.*')).toEqual(\n      'path/*(a|b)/subdir'\n    );\n    expect(gp('path/\\\\[foo bar\\\\]/subdir/foo.*')).toEqual(\n      'path/[foo bar]/subdir'\n    );\n    expect(gp('path/\\\\[bar]/')).toEqual('path/[bar]');\n    expect(gp('path/\\\\[bar]')).toEqual('path');\n    expect(gp('[bar]')).toEqual('.');\n    expect(gp('[bar]/')).toEqual('.');\n    expect(gp('./\\\\[bar]')).toEqual('.');\n    expect(gp('\\\\[bar]/')).toEqual('[bar]');\n    expect(gp('\\\\!dir/*')).toEqual('!dir');\n    expect(gp('[bar\\\\]/')).toEqual('.');\n    expect(gp('path/foo \\\\[bar]/')).toEqual('path/foo [bar]');\n    expect(gp('path/\\\\{foo,bar}/')).toEqual('path/{foo,bar}');\n    expect(gp('\\\\{foo,bar}/')).toEqual('{foo,bar}');\n    expect(gp('\\\\{foo,bar\\\\}/')).toEqual('{foo,bar}');\n    expect(gp('{foo,bar\\\\}/')).toEqual('.');\n\n    if (isWin32) {\n      // On Windows we are trying to flip backslashes foo-\\\\( \u2192 foo-/(\n      expect(gp('foo-\\\\(bar\\\\).md')).toEqual('foo-');\n    } else {\n      expect(gp('foo-\\\\(bar\\\\).md')).toEqual('.');\n      expect(gp('\\\\[bar]')).toEqual('.');\n      expect(gp('[bar\\\\]')).toEqual('.');\n      expect(gp('\\\\{foo,bar\\\\}')).toEqual('.');\n      expect(gp('{foo,bar\\\\}')).toEqual('.');\n    }\n\n    done();\n  });\n\n  it('should respect glob enclosures with embedded separators', function (done) {\n    /* eslint-disable no-useless-escape */\n    expect(gp('path/{,/,bar/baz,qux}/')).toEqual('path');\n    expect(gp('path/\\\\{,/,bar/baz,qux}/')).toEqual('path/{,/,bar/baz,qux}');\n    expect(gp('path/\\\\{,/,bar/baz,qux\\\\}/')).toEqual('path/{,/,bar/baz,qux}');\n    expect(gp('/{,/,bar/baz,qux}/')).toEqual('/');\n    expect(gp('/\\\\{,/,bar/baz,qux}/')).toEqual('/{,/,bar/baz,qux}');\n    expect(gp('{,/,bar/baz,qux}')).toEqual('.');\n    expect(gp('\\\\{,/,bar/baz,qux\\\\}')).toEqual('{,/,bar/baz,qux}');\n    expect(gp('\\\\{,/,bar/baz,qux}/')).toEqual('{,/,bar/baz,qux}');\n    expect(gp('path/foo[a\\\\/]/')).toEqual('path');\n    expect(gp('path/foo\\\\[a\\\\/]/')).toEqual('path/foo[a\\\\/]');\n    expect(gp('foo[a\\\\/]')).toEqual('.');\n    expect(gp('foo\\\\[a\\\\/]')).toEqual('foo[a\\\\/]');\n    expect(gp('path/(foo/bar|baz)')).toEqual('path');\n    expect(gp('path/(foo/bar|baz)/')).toEqual('path');\n    expect(gp('path/\\\\(foo/bar|baz)/')).toEqual('path/(foo/bar|baz)');\n    /* eslint-enable no-useless-escape */\n\n    done();\n  });\n\n  it('should handle nested braces', function (done) {\n    expect(gp('path/{../,./,{bar,/baz\\\\},qux\\\\}/')).toEqual('path');\n    expect(gp('path/{../,./,\\\\{bar,/baz},qux}/')).toEqual('path');\n    expect(gp('path/\\\\{../,./,\\\\{bar,/baz\\\\},qux\\\\}/')).toEqual(\n      'path/{../,./,{bar,/baz},qux}'\n    );\n    expect(gp('{../,./,{bar,/baz\\\\},qux\\\\}/')).toEqual('.');\n    expect(gp('{../,./,{bar,/baz\\\\},qux\\\\}')).toEqual('.');\n    expect(gp('path/{,/,bar/{baz,qux\\\\}}/')).toEqual('path');\n    expect(gp('path/{,/,bar/{baz,qux}\\\\}/')).toEqual('path');\n    // expect(gp('path/\\\\{../,./,{bar,/baz},qux}/')).toEqual('path');\n\n    done();\n  });\n\n  it('should return parent dirname from non-glob paths', function (done) {\n    expect(gp('path')).toEqual('.');\n    expect(gp('path/foo')).toEqual('path');\n    expect(gp('path/foo/')).toEqual('path/foo');\n    expect(gp('path/foo/bar.js')).toEqual('path/foo');\n\n    done();\n  });\n\n  it('should respect disabled auto flip backslashes', function (done) {\n    expect(gp('foo-\\\\(bar\\\\).md', { flipBackslashes: false })).toEqual('.');\n\n    done();\n  });\n});\n\ndescribe('glob2base test patterns', function () {\n  it('should get a base name', function (done) {\n    expect(gp('js/*.js')).toEqual('js');\n\n    done();\n  });\n\n  it('should get a base name from a nested glob', function (done) {\n    expect(gp('js/**/test/*.js')).toEqual('js');\n\n    done();\n  });\n\n  it('should get a base name from a flat file', function (done) {\n    expect(gp('js/test/wow.js')).toEqual('js/test');\n    expect(gp('js/test/wow.js')).toEqual('js/test');\n\n    done();\n  });\n\n  it('should get a base name from character class pattern', function (done) {\n    expect(gp('js/t[a-z]st}/*.js')).toEqual('js');\n\n    done();\n  });\n\n  it('should get a base name from brace , expansion', function (done) {\n    expect(gp('js/{src,test}/*.js')).toEqual('js');\n\n    done();\n  });\n\n  it('should get a base name from brace .. expansion', function (done) {\n    expect(gp('js/test{0..9}/*.js')).toEqual('js');\n\n    done();\n  });\n\n  it('should get a base name from extglob', function (done) {\n    expect(gp('js/t+(wo|est)/*.js')).toEqual('js');\n\n    done();\n  });\n\n  it('should get a base name from a path with non-exglob parens', function (done) {\n    expect(gp('js/t(wo|est)/*.js')).toEqual('js');\n    expect(gp('js/t/(wo|est)/*.js')).toEqual('js/t');\n\n    done();\n  });\n\n  it('should get a base name from a complex brace glob', function (done) {\n    expect(gp('lib/{components,pages}/**/{test,another}/*.txt')).toEqual('lib');\n\n    expect(gp('js/test/**/{images,components}/*.js')).toEqual('js/test');\n\n    expect(gp('ooga/{booga,sooga}/**/dooga/{eooga,fooga}')).toEqual('ooga');\n\n    done();\n  });\n\n  it('should not be susceptible to SNYK-JS-GLOBPARENT-1016905', function (done) {\n    // This will time out if susceptible.\n    gp('{' + '/'.repeat(5000));\n\n    done();\n  });\n\n  it('should finish in reasonable time for \\'{\\' + \\'/\\'.repeat(n) [CVE-2021-35065]', function(done) {\n    this.timeout(1000);\n    gp('{' + '/'.repeat(500000));\n    done();\n  });\n\n  it('should finish in reasonable time for \\'{\\'.repeat(n)', function(done) {\n    this.timeout(1000);\n    gp('{'.repeat(500000));\n    done();\n  });\n\n  it('should finish in reasonable time for \\'(\\'.repeat(n)', function(done) {\n    this.timeout(1000);\n    gp('('.repeat(500000));\n    done();\n  });\n});\n\nif (isWin32) {\n  describe('technically invalid windows globs', function () {\n    it('should manage simple globs with backslash path separator', function (done) {\n      expect(gp('C:\\\\path\\\\*.js')).toEqual('C:/path');\n\n      done();\n    });\n  });\n}\n"], "filenames": ["index.js", "test/index.test.js"], "buggy_code_start_loc": [9, 226], "buggy_code_end_loc": [41, 226], "fixing_code_start_loc": [8, 227], "fixing_code_end_loc": [65, 245], "type": "CWE-1333", "message": "The glob-parent package before 6.0.1 for Node.js allows ReDoS (regular expression denial of service) attacks against the enclosure regular expression.", "other": {"cve": {"id": "CVE-2021-35065", "sourceIdentifier": "cve@mitre.org", "published": "2022-12-26T07:15:11.730", "lastModified": "2023-01-23T18:32:24.010", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The glob-parent package before 6.0.1 for Node.js allows ReDoS (regular expression denial of service) attacks against the enclosure regular expression."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1333"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gulpjs:glob-parent:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "6.0.0", "versionEndExcluding": "6.0.1", "matchCriteriaId": "89D4AC09-A67D-4F86-B6A3-7BD266105561"}]}]}], "references": [{"url": "https://github.com/gulpjs/glob-parent/commit/3e9f04a3b4349db7e1962d87c9a7398cda51f339", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gulpjs/glob-parent/pull/49", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://security.snyk.io/vuln/SNYK-JS-GLOBPARENT-1314294", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gulpjs/glob-parent/commit/3e9f04a3b4349db7e1962d87c9a7398cda51f339"}}