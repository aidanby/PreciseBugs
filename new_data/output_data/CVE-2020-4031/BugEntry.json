{"buggy_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n *\n * Copyright 2014 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2017 Armin Novak <armin.novak@thincast.com>\n * Copyright 2017 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <errno.h>\n\n#include <winpr/crt.h>\n#include <winpr/ssl.h>\n#include <winpr/wnd.h>\n#include <winpr/path.h>\n#include <winpr/cmdline.h>\n#include <winpr/winsock.h>\n\n#include <freerdp/log.h>\n#include <freerdp/version.h>\n\n#include <winpr/tools/makecert.h>\n\n#ifndef _WIN32\n#include <sys/select.h>\n#include <signal.h>\n#endif\n\n#include \"shadow.h\"\n\n#define TAG SERVER_TAG(\"shadow\")\n\nstatic const char bind_address[] = \"bind-address,\";\n\nstatic const COMMAND_LINE_ARGUMENT_A shadow_args[] = {\n\t{ \"port\", COMMAND_LINE_VALUE_REQUIRED, \"<number>\", NULL, NULL, -1, NULL, \"Server port\" },\n\t{ \"ipc-socket\", COMMAND_LINE_VALUE_REQUIRED, \"<ipc-socket>\", NULL, NULL, -1, NULL,\n\t  \"Server IPC socket\" },\n\t{ \"bind-address\", COMMAND_LINE_VALUE_REQUIRED, \"<bind-address>[,<another address>, ...]\", NULL,\n\t  NULL, -1, NULL,\n\t  \"An address to bind to. Use '[<ipv6>]' for IPv6 addresses, e.g. '[::1]' for \"\n\t  \"localhost\" },\n\t{ \"monitors\", COMMAND_LINE_VALUE_OPTIONAL, \"<0,1,2...>\", NULL, NULL, -1, NULL,\n\t  \"Select or list monitors\" },\n\t{ \"rect\", COMMAND_LINE_VALUE_REQUIRED, \"<x,y,w,h>\", NULL, NULL, -1, NULL,\n\t  \"Select rectangle within monitor to share\" },\n\t{ \"auth\", COMMAND_LINE_VALUE_BOOL, NULL, BoolValueFalse, NULL, -1, NULL,\n\t  \"Clients must authenticate\" },\n\t{ \"may-view\", COMMAND_LINE_VALUE_BOOL, NULL, BoolValueTrue, NULL, -1, NULL,\n\t  \"Clients may view without prompt\" },\n\t{ \"may-interact\", COMMAND_LINE_VALUE_BOOL, NULL, BoolValueTrue, NULL, -1, NULL,\n\t  \"Clients may interact without prompt\" },\n\t{ \"sec\", COMMAND_LINE_VALUE_REQUIRED, \"<rdp|tls|nla|ext>\", NULL, NULL, -1, NULL,\n\t  \"force specific protocol security\" },\n\t{ \"sec-rdp\", COMMAND_LINE_VALUE_BOOL, NULL, BoolValueTrue, NULL, -1, NULL,\n\t  \"rdp protocol security\" },\n\t{ \"sec-tls\", COMMAND_LINE_VALUE_BOOL, NULL, BoolValueTrue, NULL, -1, NULL,\n\t  \"tls protocol security\" },\n\t{ \"sec-nla\", COMMAND_LINE_VALUE_BOOL, NULL, BoolValueTrue, NULL, -1, NULL,\n\t  \"nla protocol security\" },\n\t{ \"sec-ext\", COMMAND_LINE_VALUE_BOOL, NULL, BoolValueFalse, NULL, -1, NULL,\n\t  \"nla extended protocol security\" },\n\t{ \"sam-file\", COMMAND_LINE_VALUE_REQUIRED, \"<file>\", NULL, NULL, -1, NULL,\n\t  \"NTLM SAM file for NLA authentication\" },\n\t{ \"version\", COMMAND_LINE_VALUE_FLAG | COMMAND_LINE_PRINT_VERSION, NULL, NULL, NULL, -1, NULL,\n\t  \"Print version\" },\n\t{ \"buildconfig\", COMMAND_LINE_VALUE_FLAG | COMMAND_LINE_PRINT_BUILDCONFIG, NULL, NULL, NULL, -1,\n\t  NULL, \"Print the build configuration\" },\n\t{ \"help\", COMMAND_LINE_VALUE_FLAG | COMMAND_LINE_PRINT_HELP, NULL, NULL, NULL, -1, \"?\",\n\t  \"Print help\" },\n\t{ NULL, 0, NULL, NULL, NULL, -1, NULL, NULL }\n};\n\nstatic int shadow_server_print_command_line_help(int argc, char** argv)\n{\n\tchar* str;\n\tsize_t length;\n\tCOMMAND_LINE_ARGUMENT_A* arg;\n\tCOMMAND_LINE_ARGUMENT_A largs[ARRAYSIZE(shadow_args)];\n\tmemcpy(largs, shadow_args, sizeof(shadow_args));\n\tif (argc < 1)\n\t\treturn -1;\n\n\tWLog_INFO(TAG, \"Usage: %s [options]\", argv[0]);\n\tWLog_INFO(TAG, \"\");\n\tWLog_INFO(TAG, \"Syntax:\");\n\tWLog_INFO(TAG, \"    /flag (enables flag)\");\n\tWLog_INFO(TAG, \"    /option:<value> (specifies option with value)\");\n\tWLog_INFO(TAG,\n\t          \"    +toggle -toggle (enables or disables toggle, where '/' is a synonym of '+')\");\n\tWLog_INFO(TAG, \"\");\n\targ = largs;\n\n\tdo\n\t{\n\t\tif (arg->Flags & COMMAND_LINE_VALUE_FLAG)\n\t\t{\n\t\t\tWLog_INFO(TAG, \"    %s\", \"/\");\n\t\t\tWLog_INFO(TAG, \"%-20s\", arg->Name);\n\t\t\tWLog_INFO(TAG, \"\\t%s\", arg->Text);\n\t\t}\n\t\telse if ((arg->Flags & COMMAND_LINE_VALUE_REQUIRED) ||\n\t\t         (arg->Flags & COMMAND_LINE_VALUE_OPTIONAL))\n\t\t{\n\t\t\tWLog_INFO(TAG, \"    %s\", \"/\");\n\n\t\t\tif (arg->Format)\n\t\t\t{\n\t\t\t\tlength = (strlen(arg->Name) + strlen(arg->Format) + 2);\n\t\t\t\tstr = (char*)malloc(length + 1);\n\n\t\t\t\tif (!str)\n\t\t\t\t\treturn -1;\n\n\t\t\t\tsprintf_s(str, length + 1, \"%s:%s\", arg->Name, arg->Format);\n\t\t\t\tWLog_INFO(TAG, \"%-20s\", str);\n\t\t\t\tfree(str);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tWLog_INFO(TAG, \"%-20s\", arg->Name);\n\t\t\t}\n\n\t\t\tWLog_INFO(TAG, \"\\t%s\", arg->Text);\n\t\t}\n\t\telse if (arg->Flags & COMMAND_LINE_VALUE_BOOL)\n\t\t{\n\t\t\tlength = strlen(arg->Name) + 32;\n\t\t\tstr = (char*)malloc(length + 1);\n\n\t\t\tif (!str)\n\t\t\t\treturn -1;\n\n\t\t\tsprintf_s(str, length + 1, \"%s (default:%s)\", arg->Name, arg->Default ? \"on\" : \"off\");\n\t\t\tWLog_INFO(TAG, \"    %s\", arg->Default ? \"-\" : \"+\");\n\t\t\tWLog_INFO(TAG, \"%-20s\", str);\n\t\t\tfree(str);\n\t\t\tWLog_INFO(TAG, \"\\t%s\", arg->Text);\n\t\t}\n\t} while ((arg = CommandLineFindNextArgumentA(arg)) != NULL);\n\n\treturn 1;\n}\n\nint shadow_server_command_line_status_print(rdpShadowServer* server, int argc, char** argv,\n                                            int status)\n{\n\tWINPR_UNUSED(server);\n\n\tif (status == COMMAND_LINE_STATUS_PRINT_VERSION)\n\t{\n\t\tWLog_INFO(TAG, \"FreeRDP version %s (git %s)\", FREERDP_VERSION_FULL, GIT_REVISION);\n\t\treturn COMMAND_LINE_STATUS_PRINT_VERSION;\n\t}\n\telse if (status == COMMAND_LINE_STATUS_PRINT_BUILDCONFIG)\n\t{\n\t\tWLog_INFO(TAG, \"%s\", freerdp_get_build_config());\n\t\treturn COMMAND_LINE_STATUS_PRINT_BUILDCONFIG;\n\t}\n\telse if (status == COMMAND_LINE_STATUS_PRINT)\n\t{\n\t\treturn COMMAND_LINE_STATUS_PRINT;\n\t}\n\telse if (status < 0)\n\t{\n\t\tif (shadow_server_print_command_line_help(argc, argv) < 0)\n\t\t\treturn -1;\n\n\t\treturn COMMAND_LINE_STATUS_PRINT_HELP;\n\t}\n\n\treturn 1;\n}\n\nint shadow_server_parse_command_line(rdpShadowServer* server, int argc, char** argv)\n{\n\tint status;\n\tDWORD flags;\n\tCOMMAND_LINE_ARGUMENT_A* arg;\n\trdpSettings* settings = server->settings;\n\tCOMMAND_LINE_ARGUMENT_A largs[ARRAYSIZE(shadow_args)];\n\tmemcpy(largs, shadow_args, sizeof(shadow_args));\n\n\tif (argc < 2)\n\t\treturn 1;\n\n\tCommandLineClearArgumentsA(largs);\n\tflags = COMMAND_LINE_SEPARATOR_COLON;\n\tflags |= COMMAND_LINE_SIGIL_SLASH | COMMAND_LINE_SIGIL_PLUS_MINUS;\n\tstatus = CommandLineParseArgumentsA(argc, argv, largs, flags, server, NULL, NULL);\n\n\tif (status < 0)\n\t\treturn status;\n\n\targ = largs;\n\terrno = 0;\n\n\tdo\n\t{\n\t\tif (!(arg->Flags & COMMAND_LINE_ARGUMENT_PRESENT))\n\t\t\tcontinue;\n\n\t\tCommandLineSwitchStart(arg) CommandLineSwitchCase(arg, \"port\")\n\t\t{\n\t\t\tlong val = strtol(arg->Value, NULL, 0);\n\n\t\t\tif ((errno != 0) || (val <= 0) || (val > UINT16_MAX))\n\t\t\t\treturn -1;\n\n\t\t\tserver->port = (DWORD)val;\n\t\t}\n\t\tCommandLineSwitchCase(arg, \"ipc-socket\")\n\t\t{\n\t\t\t/* /bind-address is incompatible */\n\t\t\tif (server->ipcSocket)\n\t\t\t\treturn -1;\n\n\t\t\tserver->ipcSocket = _strdup(arg->Value);\n\n\t\t\tif (!server->ipcSocket)\n\t\t\t\treturn -1;\n\t\t}\n\t\tCommandLineSwitchCase(arg, \"bind-address\")\n\t\t{\n\t\t\tint rc;\n\t\t\tsize_t len = strlen(arg->Value) + sizeof(bind_address);\n\t\t\t/* /ipc-socket is incompatible */\n\t\t\tif (server->ipcSocket)\n\t\t\t\treturn -1;\n\t\t\tserver->ipcSocket = calloc(len, sizeof(CHAR));\n\n\t\t\tif (!server->ipcSocket)\n\t\t\t\treturn -1;\n\n\t\t\trc = _snprintf(server->ipcSocket, len, \"%s%s\", bind_address, arg->Value);\n\t\t\tif ((rc < 0) || ((size_t)rc != len - 1))\n\t\t\t\treturn -1;\n\t\t}\n\t\tCommandLineSwitchCase(arg, \"may-view\")\n\t\t{\n\t\t\tserver->mayView = arg->Value ? TRUE : FALSE;\n\t\t}\n\t\tCommandLineSwitchCase(arg, \"may-interact\")\n\t\t{\n\t\t\tserver->mayInteract = arg->Value ? TRUE : FALSE;\n\t\t}\n\t\tCommandLineSwitchCase(arg, \"rect\")\n\t\t{\n\t\t\tchar* p;\n\t\t\tchar* tok[4];\n\t\t\tlong x = -1, y = -1, w = -1, h = -1;\n\t\t\tchar* str = _strdup(arg->Value);\n\n\t\t\tif (!str)\n\t\t\t\treturn -1;\n\n\t\t\ttok[0] = p = str;\n\t\t\tp = strchr(p + 1, ',');\n\n\t\t\tif (!p)\n\t\t\t{\n\t\t\t\tfree(str);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t*p++ = '\\0';\n\t\t\ttok[1] = p;\n\t\t\tp = strchr(p + 1, ',');\n\n\t\t\tif (!p)\n\t\t\t{\n\t\t\t\tfree(str);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t*p++ = '\\0';\n\t\t\ttok[2] = p;\n\t\t\tp = strchr(p + 1, ',');\n\n\t\t\tif (!p)\n\t\t\t{\n\t\t\t\tfree(str);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t*p++ = '\\0';\n\t\t\ttok[3] = p;\n\t\t\tx = strtol(tok[0], NULL, 0);\n\n\t\t\tif (errno != 0)\n\t\t\t\tgoto fail;\n\n\t\t\ty = strtol(tok[1], NULL, 0);\n\n\t\t\tif (errno != 0)\n\t\t\t\tgoto fail;\n\n\t\t\tw = strtol(tok[2], NULL, 0);\n\n\t\t\tif (errno != 0)\n\t\t\t\tgoto fail;\n\n\t\t\th = strtol(tok[3], NULL, 0);\n\n\t\t\tif (errno != 0)\n\t\t\t\tgoto fail;\n\n\t\tfail:\n\t\t\tfree(str);\n\n\t\t\tif ((x < 0) || (y < 0) || (w < 1) || (h < 1) || (errno != 0))\n\t\t\t\treturn -1;\n\n\t\t\tserver->subRect.left = x;\n\t\t\tserver->subRect.top = y;\n\t\t\tserver->subRect.right = x + w;\n\t\t\tserver->subRect.bottom = y + h;\n\t\t\tserver->shareSubRect = TRUE;\n\t\t}\n\t\tCommandLineSwitchCase(arg, \"auth\")\n\t\t{\n\t\t\tserver->authentication = arg->Value ? TRUE : FALSE;\n\t\t}\n\t\tCommandLineSwitchCase(arg, \"sec\")\n\t\t{\n\t\t\tif (strcmp(\"rdp\", arg->Value) == 0) /* Standard RDP */\n\t\t\t{\n\t\t\t\tsettings->RdpSecurity = TRUE;\n\t\t\t\tsettings->TlsSecurity = FALSE;\n\t\t\t\tsettings->NlaSecurity = FALSE;\n\t\t\t\tsettings->ExtSecurity = FALSE;\n\t\t\t\tsettings->UseRdpSecurityLayer = TRUE;\n\t\t\t}\n\t\t\telse if (strcmp(\"tls\", arg->Value) == 0) /* TLS */\n\t\t\t{\n\t\t\t\tsettings->RdpSecurity = FALSE;\n\t\t\t\tsettings->TlsSecurity = TRUE;\n\t\t\t\tsettings->NlaSecurity = FALSE;\n\t\t\t\tsettings->ExtSecurity = FALSE;\n\t\t\t}\n\t\t\telse if (strcmp(\"nla\", arg->Value) == 0) /* NLA */\n\t\t\t{\n\t\t\t\tsettings->RdpSecurity = FALSE;\n\t\t\t\tsettings->TlsSecurity = FALSE;\n\t\t\t\tsettings->NlaSecurity = TRUE;\n\t\t\t\tsettings->ExtSecurity = FALSE;\n\t\t\t}\n\t\t\telse if (strcmp(\"ext\", arg->Value) == 0) /* NLA Extended */\n\t\t\t{\n\t\t\t\tsettings->RdpSecurity = FALSE;\n\t\t\t\tsettings->TlsSecurity = FALSE;\n\t\t\t\tsettings->NlaSecurity = FALSE;\n\t\t\t\tsettings->ExtSecurity = TRUE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"unknown protocol security: %s\", arg->Value);\n\t\t\t}\n\t\t}\n\t\tCommandLineSwitchCase(arg, \"sec-rdp\")\n\t\t{\n\t\t\tsettings->RdpSecurity = arg->Value ? TRUE : FALSE;\n\t\t}\n\t\tCommandLineSwitchCase(arg, \"sec-tls\")\n\t\t{\n\t\t\tsettings->TlsSecurity = arg->Value ? TRUE : FALSE;\n\t\t}\n\t\tCommandLineSwitchCase(arg, \"sec-nla\")\n\t\t{\n\t\t\tsettings->NlaSecurity = arg->Value ? TRUE : FALSE;\n\t\t}\n\t\tCommandLineSwitchCase(arg, \"sec-ext\")\n\t\t{\n\t\t\tsettings->ExtSecurity = arg->Value ? TRUE : FALSE;\n\t\t}\n\t\tCommandLineSwitchCase(arg, \"sam-file\")\n\t\t{\n\t\t\tfreerdp_settings_set_string(settings, FreeRDP_NtlmSamFile, arg->Value);\n\t\t}\n\t\tCommandLineSwitchDefault(arg)\n\t\t{\n\t\t}\n\t\tCommandLineSwitchEnd(arg)\n\t} while ((arg = CommandLineFindNextArgumentA(arg)) != NULL);\n\n\targ = CommandLineFindArgumentA(largs, \"monitors\");\n\n\tif (arg && (arg->Flags & COMMAND_LINE_ARGUMENT_PRESENT))\n\t{\n\t\tint index;\n\t\tint numMonitors;\n\t\tMONITOR_DEF monitors[16];\n\t\tnumMonitors = shadow_enum_monitors(monitors, 16);\n\n\t\tif (arg->Flags & COMMAND_LINE_VALUE_PRESENT)\n\t\t{\n\t\t\t/* Select monitors */\n\t\t\tlong val = strtol(arg->Value, NULL, 0);\n\n\t\t\tif ((val < 0) || (errno != 0) || (val >= numMonitors))\n\t\t\t\tstatus = COMMAND_LINE_STATUS_PRINT;\n\n\t\t\tserver->selectedMonitor = val;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint width, height;\n\t\t\tMONITOR_DEF* monitor;\n\n\t\t\t/* List monitors */\n\n\t\t\tfor (index = 0; index < numMonitors; index++)\n\t\t\t{\n\t\t\t\tmonitor = &monitors[index];\n\t\t\t\twidth = monitor->right - monitor->left;\n\t\t\t\theight = monitor->bottom - monitor->top;\n\t\t\t\tWLog_INFO(TAG, \"      %s [%d] %dx%d\\t+%\" PRId32 \"+%\" PRId32 \"\",\n\t\t\t\t          (monitor->flags == 1) ? \"*\" : \" \", index, width, height, monitor->left,\n\t\t\t\t          monitor->top);\n\t\t\t}\n\n\t\t\tstatus = COMMAND_LINE_STATUS_PRINT;\n\t\t}\n\t}\n\n\treturn status;\n}\n\nstatic DWORD WINAPI shadow_server_thread(LPVOID arg)\n{\n\trdpShadowServer* server = (rdpShadowServer*)arg;\n\tBOOL running = TRUE;\n\tDWORD status;\n\tfreerdp_listener* listener = server->listener;\n\tshadow_subsystem_start(server->subsystem);\n\n\twhile (running)\n\t{\n\t\tHANDLE events[32];\n\t\tDWORD nCount = 0;\n\t\tevents[nCount++] = server->StopEvent;\n\t\tnCount += listener->GetEventHandles(listener, &events[nCount], 32 - nCount);\n\n\t\tif (nCount <= 1)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Failed to get FreeRDP file descriptor\");\n\t\t\tbreak;\n\t\t}\n\n\t\tstatus = WaitForMultipleObjects(nCount, events, FALSE, INFINITE);\n\n\t\tswitch (status)\n\t\t{\n\t\t\tcase WAIT_FAILED:\n\t\t\tcase WAIT_OBJECT_0:\n\t\t\t\trunning = FALSE;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t{\n\t\t\t\tif (!listener->CheckFileDescriptor(listener))\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"Failed to check FreeRDP file descriptor\");\n\t\t\t\t\trunning = FALSE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n#ifdef _WIN32\n\t\t\t\t\tSleep(100); /* FIXME: listener event handles */\n#endif\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlistener->Close(listener);\n\tshadow_subsystem_stop(server->subsystem);\n\n\t/* Signal to the clients that server is being stopped and wait for them\n\t * to disconnect. */\n\tif (shadow_client_boardcast_quit(server, 0))\n\t{\n\t\twhile (ArrayList_Count(server->clients) > 0)\n\t\t{\n\t\t\tSleep(100);\n\t\t}\n\t}\n\n\tExitThread(0);\n\treturn 0;\n}\n\nstatic BOOL open_port(rdpShadowServer* server, char* address)\n{\n\tBOOL status;\n\tchar* modaddr = address;\n\n\tif (modaddr)\n\t{\n\t\tif (modaddr[0] == '[')\n\t\t{\n\t\t\tchar* end = strchr(address, ']');\n\t\t\tif (!end)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Could not parse bind-address %s\", address);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t*end++ = '\\0';\n\t\t\tif (strlen(end) > 0)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Excess data after IPv6 address: '%s'\", end);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmodaddr++;\n\t\t}\n\t}\n\tstatus = server->listener->Open(server->listener, modaddr, (UINT16)server->port);\n\n\tif (!status)\n\t{\n\t\tWLog_ERR(TAG,\n\t\t         \"Problem creating TCP listener. (Port already used or insufficient permissions?)\");\n\t}\n\n\treturn status;\n}\n\nint shadow_server_start(rdpShadowServer* server)\n{\n\tBOOL ipc;\n\tBOOL status;\n\tWSADATA wsaData;\n\n\tif (!server)\n\t\treturn -1;\n\n\tif (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)\n\t\treturn -1;\n\n#ifndef _WIN32\n\tsignal(SIGPIPE, SIG_IGN);\n#endif\n\tserver->screen = shadow_screen_new(server);\n\n\tif (!server->screen)\n\t{\n\t\tWLog_ERR(TAG, \"screen_new failed\");\n\t\treturn -1;\n\t}\n\n\tserver->capture = shadow_capture_new(server);\n\n\tif (!server->capture)\n\t{\n\t\tWLog_ERR(TAG, \"capture_new failed\");\n\t\treturn -1;\n\t}\n\n\t/* Bind magic:\n\t *\n\t * emtpy                 ... bind TCP all\n\t * <local path>          ... bind local (IPC)\n\t * bind-socket,<address> ... bind TCP to specified interface\n\t */\n\tipc = server->ipcSocket && (strncmp(bind_address, server->ipcSocket,\n\t                                    strnlen(bind_address, sizeof(bind_address))) != 0);\n\tif (!ipc)\n\t{\n\t\tsize_t x, count;\n\t\tchar** list = CommandLineParseCommaSeparatedValuesEx(NULL, server->ipcSocket, &count);\n\t\tif (!list || (count <= 1))\n\t\t{\n\t\t\tfree(list);\n\t\t\tif (server->ipcSocket == NULL)\n\t\t\t{\n\t\t\t\tif (!open_port(server, NULL))\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tfor (x = 1; x < count; x++)\n\t\t{\n\t\t\tBOOL success = open_port(server, list[x]);\n\t\t\tif (!success)\n\t\t\t{\n\t\t\t\tfree(list);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(list);\n\t}\n\telse\n\t{\n\t\tstatus = server->listener->OpenLocal(server->listener, server->ipcSocket);\n\t\tif (!status)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Problem creating local socket listener. (Port already used or \"\n\t\t\t              \"insufficient permissions?)\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!(server->thread = CreateThread(NULL, 0, shadow_server_thread, (void*)server, 0, NULL)))\n\t{\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint shadow_server_stop(rdpShadowServer* server)\n{\n\tif (!server)\n\t\treturn -1;\n\n\tif (server->thread)\n\t{\n\t\tSetEvent(server->StopEvent);\n\t\tWaitForSingleObject(server->thread, INFINITE);\n\t\tCloseHandle(server->thread);\n\t\tserver->thread = NULL;\n\t\tserver->listener->Close(server->listener);\n\t}\n\n\tif (server->screen)\n\t{\n\t\tshadow_screen_free(server->screen);\n\t\tserver->screen = NULL;\n\t}\n\n\tif (server->capture)\n\t{\n\t\tshadow_capture_free(server->capture);\n\t\tserver->capture = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic int shadow_server_init_config_path(rdpShadowServer* server)\n{\n#ifdef _WIN32\n\n\tif (!server->ConfigPath)\n\t{\n\t\tserver->ConfigPath = GetEnvironmentSubPath(\"LOCALAPPDATA\", \"freerdp\");\n\t}\n\n#endif\n#ifdef __APPLE__\n\n\tif (!server->ConfigPath)\n\t{\n\t\tchar* userLibraryPath;\n\t\tchar* userApplicationSupportPath;\n\t\tuserLibraryPath = GetKnownSubPath(KNOWN_PATH_HOME, \"Library\");\n\n\t\tif (userLibraryPath)\n\t\t{\n\t\t\tif (!PathFileExistsA(userLibraryPath) && !PathMakePathA(userLibraryPath, 0))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Failed to create directory '%s'\", userLibraryPath);\n\t\t\t\tfree(userLibraryPath);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tuserApplicationSupportPath = GetCombinedPath(userLibraryPath, \"Application Support\");\n\n\t\t\tif (userApplicationSupportPath)\n\t\t\t{\n\t\t\t\tif (!PathFileExistsA(userApplicationSupportPath) &&\n\t\t\t\t    !PathMakePathA(userApplicationSupportPath, 0))\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"Failed to create directory '%s'\", userApplicationSupportPath);\n\t\t\t\t\tfree(userLibraryPath);\n\t\t\t\t\tfree(userApplicationSupportPath);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tserver->ConfigPath = GetCombinedPath(userApplicationSupportPath, \"freerdp\");\n\t\t\t}\n\n\t\t\tfree(userLibraryPath);\n\t\t\tfree(userApplicationSupportPath);\n\t\t}\n\t}\n\n#endif\n\n\tif (!server->ConfigPath)\n\t{\n\t\tchar* configHome;\n\t\tconfigHome = GetKnownPath(KNOWN_PATH_XDG_CONFIG_HOME);\n\n\t\tif (configHome)\n\t\t{\n\t\t\tif (!PathFileExistsA(configHome) && !PathMakePathA(configHome, 0))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Failed to create directory '%s'\", configHome);\n\t\t\t\tfree(configHome);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tserver->ConfigPath = GetKnownSubPath(KNOWN_PATH_XDG_CONFIG_HOME, \"freerdp\");\n\t\t\tfree(configHome);\n\t\t}\n\t}\n\n\tif (!server->ConfigPath)\n\t\treturn -1; /* no usable config path */\n\n\treturn 1;\n}\n\nstatic BOOL shadow_server_init_certificate(rdpShadowServer* server)\n{\n\tchar* filepath;\n\tMAKECERT_CONTEXT* makecert = NULL;\n\tBOOL ret = FALSE;\n\tconst char* makecert_argv[6] = { \"makecert\", \"-rdp\", \"-live\", \"-silent\", \"-y\", \"5\" };\n\tint makecert_argc = (sizeof(makecert_argv) / sizeof(char*));\n\n\tif (!PathFileExistsA(server->ConfigPath) && !PathMakePathA(server->ConfigPath, 0))\n\t{\n\t\tWLog_ERR(TAG, \"Failed to create directory '%s'\", server->ConfigPath);\n\t\treturn FALSE;\n\t}\n\n\tif (!(filepath = GetCombinedPath(server->ConfigPath, \"shadow\")))\n\t\treturn FALSE;\n\n\tif (!PathFileExistsA(filepath) && !PathMakePathA(filepath, 0))\n\t{\n\t\tif (!CreateDirectoryA(filepath, 0))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Failed to create directory '%s'\", filepath);\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\tserver->CertificateFile = GetCombinedPath(filepath, \"shadow.crt\");\n\tserver->PrivateKeyFile = GetCombinedPath(filepath, \"shadow.key\");\n\n\tif (!server->CertificateFile || !server->PrivateKeyFile)\n\t\tgoto out_fail;\n\n\tif ((!PathFileExistsA(server->CertificateFile)) || (!PathFileExistsA(server->PrivateKeyFile)))\n\t{\n\t\tmakecert = makecert_context_new();\n\n\t\tif (!makecert)\n\t\t\tgoto out_fail;\n\n\t\tif (makecert_context_process(makecert, makecert_argc, (char**)makecert_argv) < 0)\n\t\t\tgoto out_fail;\n\n\t\tif (makecert_context_set_output_file_name(makecert, \"shadow\") != 1)\n\t\t\tgoto out_fail;\n\n\t\tif (!PathFileExistsA(server->CertificateFile))\n\t\t{\n\t\t\tif (makecert_context_output_certificate_file(makecert, filepath) != 1)\n\t\t\t\tgoto out_fail;\n\t\t}\n\n\t\tif (!PathFileExistsA(server->PrivateKeyFile))\n\t\t{\n\t\t\tif (makecert_context_output_private_key_file(makecert, filepath) != 1)\n\t\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\tret = TRUE;\nout_fail:\n\tmakecert_context_free(makecert);\n\tfree(filepath);\n\treturn ret;\n}\n\nint shadow_server_init(rdpShadowServer* server)\n{\n\tint status;\n\twinpr_InitializeSSL(WINPR_SSL_INIT_DEFAULT);\n\tWTSRegisterWtsApiFunctionTable(FreeRDP_InitWtsApi());\n\n\tif (!(server->clients = ArrayList_New(TRUE)))\n\t\tgoto fail_client_array;\n\n\tif (!(server->StopEvent = CreateEvent(NULL, TRUE, FALSE, NULL)))\n\t\tgoto fail_stop_event;\n\n\tif (!InitializeCriticalSectionAndSpinCount(&(server->lock), 4000))\n\t\tgoto fail_server_lock;\n\n\tstatus = shadow_server_init_config_path(server);\n\n\tif (status < 0)\n\t\tgoto fail_config_path;\n\n\tstatus = shadow_server_init_certificate(server);\n\n\tif (status < 0)\n\t\tgoto fail_certificate;\n\n\tserver->listener = freerdp_listener_new();\n\n\tif (!server->listener)\n\t\tgoto fail_listener;\n\n\tserver->listener->info = (void*)server;\n\tserver->listener->PeerAccepted = shadow_client_accepted;\n\tserver->subsystem = shadow_subsystem_new();\n\n\tif (!server->subsystem)\n\t\tgoto fail_subsystem_new;\n\n\tstatus = shadow_subsystem_init(server->subsystem, server);\n\n\tif (status >= 0)\n\t\treturn status;\n\n\tshadow_subsystem_free(server->subsystem);\nfail_subsystem_new:\n\tfreerdp_listener_free(server->listener);\n\tserver->listener = NULL;\nfail_listener:\n\tfree(server->CertificateFile);\n\tserver->CertificateFile = NULL;\n\tfree(server->PrivateKeyFile);\n\tserver->PrivateKeyFile = NULL;\nfail_certificate:\n\tfree(server->ConfigPath);\n\tserver->ConfigPath = NULL;\nfail_config_path:\n\tDeleteCriticalSection(&(server->lock));\nfail_server_lock:\n\tCloseHandle(server->StopEvent);\n\tserver->StopEvent = NULL;\nfail_stop_event:\n\tArrayList_Free(server->clients);\n\tserver->clients = NULL;\nfail_client_array:\n\tWLog_ERR(TAG, \"Failed to initialize shadow server\");\n\treturn -1;\n}\n\nint shadow_server_uninit(rdpShadowServer* server)\n{\n\tif (!server)\n\t\treturn -1;\n\n\tshadow_server_stop(server);\n\tshadow_subsystem_uninit(server->subsystem);\n\tshadow_subsystem_free(server->subsystem);\n\tfreerdp_listener_free(server->listener);\n\tserver->listener = NULL;\n\tfree(server->CertificateFile);\n\tserver->CertificateFile = NULL;\n\tfree(server->PrivateKeyFile);\n\tserver->PrivateKeyFile = NULL;\n\tfree(server->ConfigPath);\n\tserver->ConfigPath = NULL;\n\tDeleteCriticalSection(&(server->lock));\n\tCloseHandle(server->StopEvent);\n\tserver->StopEvent = NULL;\n\tArrayList_Free(server->clients);\n\tserver->clients = NULL;\n\treturn 1;\n}\n\nrdpShadowServer* shadow_server_new(void)\n{\n\trdpShadowServer* server;\n\tserver = (rdpShadowServer*)calloc(1, sizeof(rdpShadowServer));\n\n\tif (!server)\n\t\treturn NULL;\n\n\tserver->port = 3389;\n\tserver->mayView = TRUE;\n\tserver->mayInteract = TRUE;\n\tserver->rfxMode = RLGR3;\n\tserver->h264RateControlMode = H264_RATECONTROL_VBR;\n\tserver->h264BitRate = 10000000;\n\tserver->h264FrameRate = 30;\n\tserver->h264QP = 0;\n\tserver->authentication = FALSE;\n\tserver->settings = freerdp_settings_new(FREERDP_SETTINGS_SERVER_MODE);\n\treturn server;\n}\n\nvoid shadow_server_free(rdpShadowServer* server)\n{\n\tif (!server)\n\t\treturn;\n\n\tfree(server->ipcSocket);\n\tserver->ipcSocket = NULL;\n\tfreerdp_settings_free(server->settings);\n\tserver->settings = NULL;\n\tfree(server);\n}\n"], "fixing_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n *\n * Copyright 2014 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n * Copyright 2017 Armin Novak <armin.novak@thincast.com>\n * Copyright 2017 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <errno.h>\n\n#include <winpr/crt.h>\n#include <winpr/ssl.h>\n#include <winpr/wnd.h>\n#include <winpr/path.h>\n#include <winpr/cmdline.h>\n#include <winpr/winsock.h>\n\n#include <freerdp/log.h>\n#include <freerdp/version.h>\n\n#include <winpr/tools/makecert.h>\n\n#ifndef _WIN32\n#include <sys/select.h>\n#include <signal.h>\n#endif\n\n#include \"shadow.h\"\n\n#define TAG SERVER_TAG(\"shadow\")\n\nstatic const char bind_address[] = \"bind-address,\";\n\nstatic const COMMAND_LINE_ARGUMENT_A shadow_args[] = {\n\t{ \"port\", COMMAND_LINE_VALUE_REQUIRED, \"<number>\", NULL, NULL, -1, NULL, \"Server port\" },\n\t{ \"ipc-socket\", COMMAND_LINE_VALUE_REQUIRED, \"<ipc-socket>\", NULL, NULL, -1, NULL,\n\t  \"Server IPC socket\" },\n\t{ \"bind-address\", COMMAND_LINE_VALUE_REQUIRED, \"<bind-address>[,<another address>, ...]\", NULL,\n\t  NULL, -1, NULL,\n\t  \"An address to bind to. Use '[<ipv6>]' for IPv6 addresses, e.g. '[::1]' for \"\n\t  \"localhost\" },\n\t{ \"monitors\", COMMAND_LINE_VALUE_OPTIONAL, \"<0,1,2...>\", NULL, NULL, -1, NULL,\n\t  \"Select or list monitors\" },\n\t{ \"rect\", COMMAND_LINE_VALUE_REQUIRED, \"<x,y,w,h>\", NULL, NULL, -1, NULL,\n\t  \"Select rectangle within monitor to share\" },\n\t{ \"auth\", COMMAND_LINE_VALUE_BOOL, NULL, BoolValueFalse, NULL, -1, NULL,\n\t  \"Clients must authenticate\" },\n\t{ \"may-view\", COMMAND_LINE_VALUE_BOOL, NULL, BoolValueTrue, NULL, -1, NULL,\n\t  \"Clients may view without prompt\" },\n\t{ \"may-interact\", COMMAND_LINE_VALUE_BOOL, NULL, BoolValueTrue, NULL, -1, NULL,\n\t  \"Clients may interact without prompt\" },\n\t{ \"sec\", COMMAND_LINE_VALUE_REQUIRED, \"<rdp|tls|nla|ext>\", NULL, NULL, -1, NULL,\n\t  \"force specific protocol security\" },\n\t{ \"sec-rdp\", COMMAND_LINE_VALUE_BOOL, NULL, BoolValueTrue, NULL, -1, NULL,\n\t  \"rdp protocol security\" },\n\t{ \"sec-tls\", COMMAND_LINE_VALUE_BOOL, NULL, BoolValueTrue, NULL, -1, NULL,\n\t  \"tls protocol security\" },\n\t{ \"sec-nla\", COMMAND_LINE_VALUE_BOOL, NULL, BoolValueTrue, NULL, -1, NULL,\n\t  \"nla protocol security\" },\n\t{ \"sec-ext\", COMMAND_LINE_VALUE_BOOL, NULL, BoolValueFalse, NULL, -1, NULL,\n\t  \"nla extended protocol security\" },\n\t{ \"sam-file\", COMMAND_LINE_VALUE_REQUIRED, \"<file>\", NULL, NULL, -1, NULL,\n\t  \"NTLM SAM file for NLA authentication\" },\n\t{ \"version\", COMMAND_LINE_VALUE_FLAG | COMMAND_LINE_PRINT_VERSION, NULL, NULL, NULL, -1, NULL,\n\t  \"Print version\" },\n\t{ \"buildconfig\", COMMAND_LINE_VALUE_FLAG | COMMAND_LINE_PRINT_BUILDCONFIG, NULL, NULL, NULL, -1,\n\t  NULL, \"Print the build configuration\" },\n\t{ \"help\", COMMAND_LINE_VALUE_FLAG | COMMAND_LINE_PRINT_HELP, NULL, NULL, NULL, -1, \"?\",\n\t  \"Print help\" },\n\t{ NULL, 0, NULL, NULL, NULL, -1, NULL, NULL }\n};\n\nstatic int shadow_server_print_command_line_help(int argc, char** argv)\n{\n\tchar* str;\n\tsize_t length;\n\tCOMMAND_LINE_ARGUMENT_A* arg;\n\tCOMMAND_LINE_ARGUMENT_A largs[ARRAYSIZE(shadow_args)];\n\tmemcpy(largs, shadow_args, sizeof(shadow_args));\n\tif (argc < 1)\n\t\treturn -1;\n\n\tWLog_INFO(TAG, \"Usage: %s [options]\", argv[0]);\n\tWLog_INFO(TAG, \"\");\n\tWLog_INFO(TAG, \"Syntax:\");\n\tWLog_INFO(TAG, \"    /flag (enables flag)\");\n\tWLog_INFO(TAG, \"    /option:<value> (specifies option with value)\");\n\tWLog_INFO(TAG,\n\t          \"    +toggle -toggle (enables or disables toggle, where '/' is a synonym of '+')\");\n\tWLog_INFO(TAG, \"\");\n\targ = largs;\n\n\tdo\n\t{\n\t\tif (arg->Flags & COMMAND_LINE_VALUE_FLAG)\n\t\t{\n\t\t\tWLog_INFO(TAG, \"    %s\", \"/\");\n\t\t\tWLog_INFO(TAG, \"%-20s\", arg->Name);\n\t\t\tWLog_INFO(TAG, \"\\t%s\", arg->Text);\n\t\t}\n\t\telse if ((arg->Flags & COMMAND_LINE_VALUE_REQUIRED) ||\n\t\t         (arg->Flags & COMMAND_LINE_VALUE_OPTIONAL))\n\t\t{\n\t\t\tWLog_INFO(TAG, \"    %s\", \"/\");\n\n\t\t\tif (arg->Format)\n\t\t\t{\n\t\t\t\tlength = (strlen(arg->Name) + strlen(arg->Format) + 2);\n\t\t\t\tstr = (char*)malloc(length + 1);\n\n\t\t\t\tif (!str)\n\t\t\t\t\treturn -1;\n\n\t\t\t\tsprintf_s(str, length + 1, \"%s:%s\", arg->Name, arg->Format);\n\t\t\t\tWLog_INFO(TAG, \"%-20s\", str);\n\t\t\t\tfree(str);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tWLog_INFO(TAG, \"%-20s\", arg->Name);\n\t\t\t}\n\n\t\t\tWLog_INFO(TAG, \"\\t%s\", arg->Text);\n\t\t}\n\t\telse if (arg->Flags & COMMAND_LINE_VALUE_BOOL)\n\t\t{\n\t\t\tlength = strlen(arg->Name) + 32;\n\t\t\tstr = (char*)malloc(length + 1);\n\n\t\t\tif (!str)\n\t\t\t\treturn -1;\n\n\t\t\tsprintf_s(str, length + 1, \"%s (default:%s)\", arg->Name, arg->Default ? \"on\" : \"off\");\n\t\t\tWLog_INFO(TAG, \"    %s\", arg->Default ? \"-\" : \"+\");\n\t\t\tWLog_INFO(TAG, \"%-20s\", str);\n\t\t\tfree(str);\n\t\t\tWLog_INFO(TAG, \"\\t%s\", arg->Text);\n\t\t}\n\t} while ((arg = CommandLineFindNextArgumentA(arg)) != NULL);\n\n\treturn 1;\n}\n\nint shadow_server_command_line_status_print(rdpShadowServer* server, int argc, char** argv,\n                                            int status)\n{\n\tWINPR_UNUSED(server);\n\n\tif (status == COMMAND_LINE_STATUS_PRINT_VERSION)\n\t{\n\t\tWLog_INFO(TAG, \"FreeRDP version %s (git %s)\", FREERDP_VERSION_FULL, GIT_REVISION);\n\t\treturn COMMAND_LINE_STATUS_PRINT_VERSION;\n\t}\n\telse if (status == COMMAND_LINE_STATUS_PRINT_BUILDCONFIG)\n\t{\n\t\tWLog_INFO(TAG, \"%s\", freerdp_get_build_config());\n\t\treturn COMMAND_LINE_STATUS_PRINT_BUILDCONFIG;\n\t}\n\telse if (status == COMMAND_LINE_STATUS_PRINT)\n\t{\n\t\treturn COMMAND_LINE_STATUS_PRINT;\n\t}\n\telse if (status < 0)\n\t{\n\t\tif (shadow_server_print_command_line_help(argc, argv) < 0)\n\t\t\treturn -1;\n\n\t\treturn COMMAND_LINE_STATUS_PRINT_HELP;\n\t}\n\n\treturn 1;\n}\n\nint shadow_server_parse_command_line(rdpShadowServer* server, int argc, char** argv)\n{\n\tint status;\n\tDWORD flags;\n\tCOMMAND_LINE_ARGUMENT_A* arg;\n\trdpSettings* settings = server->settings;\n\tCOMMAND_LINE_ARGUMENT_A largs[ARRAYSIZE(shadow_args)];\n\tmemcpy(largs, shadow_args, sizeof(shadow_args));\n\n\tif (argc < 2)\n\t\treturn 1;\n\n\tCommandLineClearArgumentsA(largs);\n\tflags = COMMAND_LINE_SEPARATOR_COLON;\n\tflags |= COMMAND_LINE_SIGIL_SLASH | COMMAND_LINE_SIGIL_PLUS_MINUS;\n\tstatus = CommandLineParseArgumentsA(argc, argv, largs, flags, server, NULL, NULL);\n\n\tif (status < 0)\n\t\treturn status;\n\n\targ = largs;\n\terrno = 0;\n\n\tdo\n\t{\n\t\tif (!(arg->Flags & COMMAND_LINE_ARGUMENT_PRESENT))\n\t\t\tcontinue;\n\n\t\tCommandLineSwitchStart(arg) CommandLineSwitchCase(arg, \"port\")\n\t\t{\n\t\t\tlong val = strtol(arg->Value, NULL, 0);\n\n\t\t\tif ((errno != 0) || (val <= 0) || (val > UINT16_MAX))\n\t\t\t\treturn -1;\n\n\t\t\tserver->port = (DWORD)val;\n\t\t}\n\t\tCommandLineSwitchCase(arg, \"ipc-socket\")\n\t\t{\n\t\t\t/* /bind-address is incompatible */\n\t\t\tif (server->ipcSocket)\n\t\t\t\treturn -1;\n\n\t\t\tserver->ipcSocket = _strdup(arg->Value);\n\n\t\t\tif (!server->ipcSocket)\n\t\t\t\treturn -1;\n\t\t}\n\t\tCommandLineSwitchCase(arg, \"bind-address\")\n\t\t{\n\t\t\tint rc;\n\t\t\tsize_t len = strlen(arg->Value) + sizeof(bind_address);\n\t\t\t/* /ipc-socket is incompatible */\n\t\t\tif (server->ipcSocket)\n\t\t\t\treturn -1;\n\t\t\tserver->ipcSocket = calloc(len, sizeof(CHAR));\n\n\t\t\tif (!server->ipcSocket)\n\t\t\t\treturn -1;\n\n\t\t\trc = _snprintf(server->ipcSocket, len, \"%s%s\", bind_address, arg->Value);\n\t\t\tif ((rc < 0) || ((size_t)rc != len - 1))\n\t\t\t\treturn -1;\n\t\t}\n\t\tCommandLineSwitchCase(arg, \"may-view\")\n\t\t{\n\t\t\tserver->mayView = arg->Value ? TRUE : FALSE;\n\t\t}\n\t\tCommandLineSwitchCase(arg, \"may-interact\")\n\t\t{\n\t\t\tserver->mayInteract = arg->Value ? TRUE : FALSE;\n\t\t}\n\t\tCommandLineSwitchCase(arg, \"rect\")\n\t\t{\n\t\t\tchar* p;\n\t\t\tchar* tok[4];\n\t\t\tlong x = -1, y = -1, w = -1, h = -1;\n\t\t\tchar* str = _strdup(arg->Value);\n\n\t\t\tif (!str)\n\t\t\t\treturn -1;\n\n\t\t\ttok[0] = p = str;\n\t\t\tp = strchr(p + 1, ',');\n\n\t\t\tif (!p)\n\t\t\t{\n\t\t\t\tfree(str);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t*p++ = '\\0';\n\t\t\ttok[1] = p;\n\t\t\tp = strchr(p + 1, ',');\n\n\t\t\tif (!p)\n\t\t\t{\n\t\t\t\tfree(str);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t*p++ = '\\0';\n\t\t\ttok[2] = p;\n\t\t\tp = strchr(p + 1, ',');\n\n\t\t\tif (!p)\n\t\t\t{\n\t\t\t\tfree(str);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t*p++ = '\\0';\n\t\t\ttok[3] = p;\n\t\t\tx = strtol(tok[0], NULL, 0);\n\n\t\t\tif (errno != 0)\n\t\t\t\tgoto fail;\n\n\t\t\ty = strtol(tok[1], NULL, 0);\n\n\t\t\tif (errno != 0)\n\t\t\t\tgoto fail;\n\n\t\t\tw = strtol(tok[2], NULL, 0);\n\n\t\t\tif (errno != 0)\n\t\t\t\tgoto fail;\n\n\t\t\th = strtol(tok[3], NULL, 0);\n\n\t\t\tif (errno != 0)\n\t\t\t\tgoto fail;\n\n\t\tfail:\n\t\t\tfree(str);\n\n\t\t\tif ((x < 0) || (y < 0) || (w < 1) || (h < 1) || (errno != 0))\n\t\t\t\treturn -1;\n\n\t\t\tserver->subRect.left = x;\n\t\t\tserver->subRect.top = y;\n\t\t\tserver->subRect.right = x + w;\n\t\t\tserver->subRect.bottom = y + h;\n\t\t\tserver->shareSubRect = TRUE;\n\t\t}\n\t\tCommandLineSwitchCase(arg, \"auth\")\n\t\t{\n\t\t\tserver->authentication = arg->Value ? TRUE : FALSE;\n\t\t}\n\t\tCommandLineSwitchCase(arg, \"sec\")\n\t\t{\n\t\t\tif (strcmp(\"rdp\", arg->Value) == 0) /* Standard RDP */\n\t\t\t{\n\t\t\t\tsettings->RdpSecurity = TRUE;\n\t\t\t\tsettings->TlsSecurity = FALSE;\n\t\t\t\tsettings->NlaSecurity = FALSE;\n\t\t\t\tsettings->ExtSecurity = FALSE;\n\t\t\t\tsettings->UseRdpSecurityLayer = TRUE;\n\t\t\t}\n\t\t\telse if (strcmp(\"tls\", arg->Value) == 0) /* TLS */\n\t\t\t{\n\t\t\t\tsettings->RdpSecurity = FALSE;\n\t\t\t\tsettings->TlsSecurity = TRUE;\n\t\t\t\tsettings->NlaSecurity = FALSE;\n\t\t\t\tsettings->ExtSecurity = FALSE;\n\t\t\t}\n\t\t\telse if (strcmp(\"nla\", arg->Value) == 0) /* NLA */\n\t\t\t{\n\t\t\t\tsettings->RdpSecurity = FALSE;\n\t\t\t\tsettings->TlsSecurity = FALSE;\n\t\t\t\tsettings->NlaSecurity = TRUE;\n\t\t\t\tsettings->ExtSecurity = FALSE;\n\t\t\t}\n\t\t\telse if (strcmp(\"ext\", arg->Value) == 0) /* NLA Extended */\n\t\t\t{\n\t\t\t\tsettings->RdpSecurity = FALSE;\n\t\t\t\tsettings->TlsSecurity = FALSE;\n\t\t\t\tsettings->NlaSecurity = FALSE;\n\t\t\t\tsettings->ExtSecurity = TRUE;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"unknown protocol security: %s\", arg->Value);\n\t\t\t}\n\t\t}\n\t\tCommandLineSwitchCase(arg, \"sec-rdp\")\n\t\t{\n\t\t\tsettings->RdpSecurity = arg->Value ? TRUE : FALSE;\n\t\t}\n\t\tCommandLineSwitchCase(arg, \"sec-tls\")\n\t\t{\n\t\t\tsettings->TlsSecurity = arg->Value ? TRUE : FALSE;\n\t\t}\n\t\tCommandLineSwitchCase(arg, \"sec-nla\")\n\t\t{\n\t\t\tsettings->NlaSecurity = arg->Value ? TRUE : FALSE;\n\t\t}\n\t\tCommandLineSwitchCase(arg, \"sec-ext\")\n\t\t{\n\t\t\tsettings->ExtSecurity = arg->Value ? TRUE : FALSE;\n\t\t}\n\t\tCommandLineSwitchCase(arg, \"sam-file\")\n\t\t{\n\t\t\tfreerdp_settings_set_string(settings, FreeRDP_NtlmSamFile, arg->Value);\n\t\t}\n\t\tCommandLineSwitchDefault(arg)\n\t\t{\n\t\t}\n\t\tCommandLineSwitchEnd(arg)\n\t} while ((arg = CommandLineFindNextArgumentA(arg)) != NULL);\n\n\targ = CommandLineFindArgumentA(largs, \"monitors\");\n\n\tif (arg && (arg->Flags & COMMAND_LINE_ARGUMENT_PRESENT))\n\t{\n\t\tint index;\n\t\tint numMonitors;\n\t\tMONITOR_DEF monitors[16];\n\t\tnumMonitors = shadow_enum_monitors(monitors, 16);\n\n\t\tif (arg->Flags & COMMAND_LINE_VALUE_PRESENT)\n\t\t{\n\t\t\t/* Select monitors */\n\t\t\tlong val = strtol(arg->Value, NULL, 0);\n\n\t\t\tif ((val < 0) || (errno != 0) || (val >= numMonitors))\n\t\t\t\tstatus = COMMAND_LINE_STATUS_PRINT;\n\n\t\t\tserver->selectedMonitor = val;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint width, height;\n\t\t\tMONITOR_DEF* monitor;\n\n\t\t\t/* List monitors */\n\n\t\t\tfor (index = 0; index < numMonitors; index++)\n\t\t\t{\n\t\t\t\tmonitor = &monitors[index];\n\t\t\t\twidth = monitor->right - monitor->left;\n\t\t\t\theight = monitor->bottom - monitor->top;\n\t\t\t\tWLog_INFO(TAG, \"      %s [%d] %dx%d\\t+%\" PRId32 \"+%\" PRId32 \"\",\n\t\t\t\t          (monitor->flags == 1) ? \"*\" : \" \", index, width, height, monitor->left,\n\t\t\t\t          monitor->top);\n\t\t\t}\n\n\t\t\tstatus = COMMAND_LINE_STATUS_PRINT;\n\t\t}\n\t}\n\n\treturn status;\n}\n\nstatic DWORD WINAPI shadow_server_thread(LPVOID arg)\n{\n\trdpShadowServer* server = (rdpShadowServer*)arg;\n\tBOOL running = TRUE;\n\tDWORD status;\n\tfreerdp_listener* listener = server->listener;\n\tshadow_subsystem_start(server->subsystem);\n\n\twhile (running)\n\t{\n\t\tHANDLE events[32];\n\t\tDWORD nCount = 0;\n\t\tevents[nCount++] = server->StopEvent;\n\t\tnCount += listener->GetEventHandles(listener, &events[nCount], 32 - nCount);\n\n\t\tif (nCount <= 1)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Failed to get FreeRDP file descriptor\");\n\t\t\tbreak;\n\t\t}\n\n\t\tstatus = WaitForMultipleObjects(nCount, events, FALSE, INFINITE);\n\n\t\tswitch (status)\n\t\t{\n\t\t\tcase WAIT_FAILED:\n\t\t\tcase WAIT_OBJECT_0:\n\t\t\t\trunning = FALSE;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t{\n\t\t\t\tif (!listener->CheckFileDescriptor(listener))\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"Failed to check FreeRDP file descriptor\");\n\t\t\t\t\trunning = FALSE;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n#ifdef _WIN32\n\t\t\t\t\tSleep(100); /* FIXME: listener event handles */\n#endif\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tlistener->Close(listener);\n\tshadow_subsystem_stop(server->subsystem);\n\n\t/* Signal to the clients that server is being stopped and wait for them\n\t * to disconnect. */\n\tif (shadow_client_boardcast_quit(server, 0))\n\t{\n\t\twhile (ArrayList_Count(server->clients) > 0)\n\t\t{\n\t\t\tSleep(100);\n\t\t}\n\t}\n\n\tExitThread(0);\n\treturn 0;\n}\n\nstatic BOOL open_port(rdpShadowServer* server, char* address)\n{\n\tBOOL status;\n\tchar* modaddr = address;\n\n\tif (modaddr)\n\t{\n\t\tif (modaddr[0] == '[')\n\t\t{\n\t\t\tchar* end = strchr(address, ']');\n\t\t\tif (!end)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Could not parse bind-address %s\", address);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t*end++ = '\\0';\n\t\t\tif (strlen(end) > 0)\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Excess data after IPv6 address: '%s'\", end);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tmodaddr++;\n\t\t}\n\t}\n\tstatus = server->listener->Open(server->listener, modaddr, (UINT16)server->port);\n\n\tif (!status)\n\t{\n\t\tWLog_ERR(TAG,\n\t\t         \"Problem creating TCP listener. (Port already used or insufficient permissions?)\");\n\t}\n\n\treturn status;\n}\n\nint shadow_server_start(rdpShadowServer* server)\n{\n\tBOOL ipc;\n\tBOOL status;\n\tWSADATA wsaData;\n\n\tif (!server)\n\t\treturn -1;\n\n\tif (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)\n\t\treturn -1;\n\n#ifndef _WIN32\n\tsignal(SIGPIPE, SIG_IGN);\n#endif\n\tserver->screen = shadow_screen_new(server);\n\n\tif (!server->screen)\n\t{\n\t\tWLog_ERR(TAG, \"screen_new failed\");\n\t\treturn -1;\n\t}\n\n\tserver->capture = shadow_capture_new(server);\n\n\tif (!server->capture)\n\t{\n\t\tWLog_ERR(TAG, \"capture_new failed\");\n\t\treturn -1;\n\t}\n\n\t/* Bind magic:\n\t *\n\t * emtpy                 ... bind TCP all\n\t * <local path>          ... bind local (IPC)\n\t * bind-socket,<address> ... bind TCP to specified interface\n\t */\n\tipc = server->ipcSocket && (strncmp(bind_address, server->ipcSocket,\n\t                                    strnlen(bind_address, sizeof(bind_address))) != 0);\n\tif (!ipc)\n\t{\n\t\tsize_t x, count;\n\t\tchar** list = CommandLineParseCommaSeparatedValuesEx(NULL, server->ipcSocket, &count);\n\t\tif (!list || (count <= 1))\n\t\t{\n\t\t\tif (server->ipcSocket == NULL)\n\t\t\t{\n\t\t\t\tif (!open_port(server, NULL))\n\t\t\t\t{\n\t\t\t\t\tfree(list);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfree(list);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tfor (x = 1; x < count; x++)\n\t\t{\n\t\t\tBOOL success = open_port(server, list[x]);\n\t\t\tif (!success)\n\t\t\t{\n\t\t\t\tfree(list);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tfree(list);\n\t}\n\telse\n\t{\n\t\tstatus = server->listener->OpenLocal(server->listener, server->ipcSocket);\n\t\tif (!status)\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Problem creating local socket listener. (Port already used or \"\n\t\t\t              \"insufficient permissions?)\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (!(server->thread = CreateThread(NULL, 0, shadow_server_thread, (void*)server, 0, NULL)))\n\t{\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nint shadow_server_stop(rdpShadowServer* server)\n{\n\tif (!server)\n\t\treturn -1;\n\n\tif (server->thread)\n\t{\n\t\tSetEvent(server->StopEvent);\n\t\tWaitForSingleObject(server->thread, INFINITE);\n\t\tCloseHandle(server->thread);\n\t\tserver->thread = NULL;\n\t\tserver->listener->Close(server->listener);\n\t}\n\n\tif (server->screen)\n\t{\n\t\tshadow_screen_free(server->screen);\n\t\tserver->screen = NULL;\n\t}\n\n\tif (server->capture)\n\t{\n\t\tshadow_capture_free(server->capture);\n\t\tserver->capture = NULL;\n\t}\n\n\treturn 0;\n}\n\nstatic int shadow_server_init_config_path(rdpShadowServer* server)\n{\n#ifdef _WIN32\n\n\tif (!server->ConfigPath)\n\t{\n\t\tserver->ConfigPath = GetEnvironmentSubPath(\"LOCALAPPDATA\", \"freerdp\");\n\t}\n\n#endif\n#ifdef __APPLE__\n\n\tif (!server->ConfigPath)\n\t{\n\t\tchar* userLibraryPath;\n\t\tchar* userApplicationSupportPath;\n\t\tuserLibraryPath = GetKnownSubPath(KNOWN_PATH_HOME, \"Library\");\n\n\t\tif (userLibraryPath)\n\t\t{\n\t\t\tif (!PathFileExistsA(userLibraryPath) && !PathMakePathA(userLibraryPath, 0))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Failed to create directory '%s'\", userLibraryPath);\n\t\t\t\tfree(userLibraryPath);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tuserApplicationSupportPath = GetCombinedPath(userLibraryPath, \"Application Support\");\n\n\t\t\tif (userApplicationSupportPath)\n\t\t\t{\n\t\t\t\tif (!PathFileExistsA(userApplicationSupportPath) &&\n\t\t\t\t    !PathMakePathA(userApplicationSupportPath, 0))\n\t\t\t\t{\n\t\t\t\t\tWLog_ERR(TAG, \"Failed to create directory '%s'\", userApplicationSupportPath);\n\t\t\t\t\tfree(userLibraryPath);\n\t\t\t\t\tfree(userApplicationSupportPath);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tserver->ConfigPath = GetCombinedPath(userApplicationSupportPath, \"freerdp\");\n\t\t\t}\n\n\t\t\tfree(userLibraryPath);\n\t\t\tfree(userApplicationSupportPath);\n\t\t}\n\t}\n\n#endif\n\n\tif (!server->ConfigPath)\n\t{\n\t\tchar* configHome;\n\t\tconfigHome = GetKnownPath(KNOWN_PATH_XDG_CONFIG_HOME);\n\n\t\tif (configHome)\n\t\t{\n\t\t\tif (!PathFileExistsA(configHome) && !PathMakePathA(configHome, 0))\n\t\t\t{\n\t\t\t\tWLog_ERR(TAG, \"Failed to create directory '%s'\", configHome);\n\t\t\t\tfree(configHome);\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tserver->ConfigPath = GetKnownSubPath(KNOWN_PATH_XDG_CONFIG_HOME, \"freerdp\");\n\t\t\tfree(configHome);\n\t\t}\n\t}\n\n\tif (!server->ConfigPath)\n\t\treturn -1; /* no usable config path */\n\n\treturn 1;\n}\n\nstatic BOOL shadow_server_init_certificate(rdpShadowServer* server)\n{\n\tchar* filepath;\n\tMAKECERT_CONTEXT* makecert = NULL;\n\tBOOL ret = FALSE;\n\tconst char* makecert_argv[6] = { \"makecert\", \"-rdp\", \"-live\", \"-silent\", \"-y\", \"5\" };\n\tint makecert_argc = (sizeof(makecert_argv) / sizeof(char*));\n\n\tif (!PathFileExistsA(server->ConfigPath) && !PathMakePathA(server->ConfigPath, 0))\n\t{\n\t\tWLog_ERR(TAG, \"Failed to create directory '%s'\", server->ConfigPath);\n\t\treturn FALSE;\n\t}\n\n\tif (!(filepath = GetCombinedPath(server->ConfigPath, \"shadow\")))\n\t\treturn FALSE;\n\n\tif (!PathFileExistsA(filepath) && !PathMakePathA(filepath, 0))\n\t{\n\t\tif (!CreateDirectoryA(filepath, 0))\n\t\t{\n\t\t\tWLog_ERR(TAG, \"Failed to create directory '%s'\", filepath);\n\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\tserver->CertificateFile = GetCombinedPath(filepath, \"shadow.crt\");\n\tserver->PrivateKeyFile = GetCombinedPath(filepath, \"shadow.key\");\n\n\tif (!server->CertificateFile || !server->PrivateKeyFile)\n\t\tgoto out_fail;\n\n\tif ((!PathFileExistsA(server->CertificateFile)) || (!PathFileExistsA(server->PrivateKeyFile)))\n\t{\n\t\tmakecert = makecert_context_new();\n\n\t\tif (!makecert)\n\t\t\tgoto out_fail;\n\n\t\tif (makecert_context_process(makecert, makecert_argc, (char**)makecert_argv) < 0)\n\t\t\tgoto out_fail;\n\n\t\tif (makecert_context_set_output_file_name(makecert, \"shadow\") != 1)\n\t\t\tgoto out_fail;\n\n\t\tif (!PathFileExistsA(server->CertificateFile))\n\t\t{\n\t\t\tif (makecert_context_output_certificate_file(makecert, filepath) != 1)\n\t\t\t\tgoto out_fail;\n\t\t}\n\n\t\tif (!PathFileExistsA(server->PrivateKeyFile))\n\t\t{\n\t\t\tif (makecert_context_output_private_key_file(makecert, filepath) != 1)\n\t\t\t\tgoto out_fail;\n\t\t}\n\t}\n\n\tret = TRUE;\nout_fail:\n\tmakecert_context_free(makecert);\n\tfree(filepath);\n\treturn ret;\n}\n\nint shadow_server_init(rdpShadowServer* server)\n{\n\tint status;\n\twinpr_InitializeSSL(WINPR_SSL_INIT_DEFAULT);\n\tWTSRegisterWtsApiFunctionTable(FreeRDP_InitWtsApi());\n\n\tif (!(server->clients = ArrayList_New(TRUE)))\n\t\tgoto fail_client_array;\n\n\tif (!(server->StopEvent = CreateEvent(NULL, TRUE, FALSE, NULL)))\n\t\tgoto fail_stop_event;\n\n\tif (!InitializeCriticalSectionAndSpinCount(&(server->lock), 4000))\n\t\tgoto fail_server_lock;\n\n\tstatus = shadow_server_init_config_path(server);\n\n\tif (status < 0)\n\t\tgoto fail_config_path;\n\n\tstatus = shadow_server_init_certificate(server);\n\n\tif (status < 0)\n\t\tgoto fail_certificate;\n\n\tserver->listener = freerdp_listener_new();\n\n\tif (!server->listener)\n\t\tgoto fail_listener;\n\n\tserver->listener->info = (void*)server;\n\tserver->listener->PeerAccepted = shadow_client_accepted;\n\tserver->subsystem = shadow_subsystem_new();\n\n\tif (!server->subsystem)\n\t\tgoto fail_subsystem_new;\n\n\tstatus = shadow_subsystem_init(server->subsystem, server);\n\n\tif (status >= 0)\n\t\treturn status;\n\n\tshadow_subsystem_free(server->subsystem);\nfail_subsystem_new:\n\tfreerdp_listener_free(server->listener);\n\tserver->listener = NULL;\nfail_listener:\n\tfree(server->CertificateFile);\n\tserver->CertificateFile = NULL;\n\tfree(server->PrivateKeyFile);\n\tserver->PrivateKeyFile = NULL;\nfail_certificate:\n\tfree(server->ConfigPath);\n\tserver->ConfigPath = NULL;\nfail_config_path:\n\tDeleteCriticalSection(&(server->lock));\nfail_server_lock:\n\tCloseHandle(server->StopEvent);\n\tserver->StopEvent = NULL;\nfail_stop_event:\n\tArrayList_Free(server->clients);\n\tserver->clients = NULL;\nfail_client_array:\n\tWLog_ERR(TAG, \"Failed to initialize shadow server\");\n\treturn -1;\n}\n\nint shadow_server_uninit(rdpShadowServer* server)\n{\n\tif (!server)\n\t\treturn -1;\n\n\tshadow_server_stop(server);\n\tshadow_subsystem_uninit(server->subsystem);\n\tshadow_subsystem_free(server->subsystem);\n\tfreerdp_listener_free(server->listener);\n\tserver->listener = NULL;\n\tfree(server->CertificateFile);\n\tserver->CertificateFile = NULL;\n\tfree(server->PrivateKeyFile);\n\tserver->PrivateKeyFile = NULL;\n\tfree(server->ConfigPath);\n\tserver->ConfigPath = NULL;\n\tDeleteCriticalSection(&(server->lock));\n\tCloseHandle(server->StopEvent);\n\tserver->StopEvent = NULL;\n\tArrayList_Free(server->clients);\n\tserver->clients = NULL;\n\treturn 1;\n}\n\nrdpShadowServer* shadow_server_new(void)\n{\n\trdpShadowServer* server;\n\tserver = (rdpShadowServer*)calloc(1, sizeof(rdpShadowServer));\n\n\tif (!server)\n\t\treturn NULL;\n\n\tserver->port = 3389;\n\tserver->mayView = TRUE;\n\tserver->mayInteract = TRUE;\n\tserver->rfxMode = RLGR3;\n\tserver->h264RateControlMode = H264_RATECONTROL_VBR;\n\tserver->h264BitRate = 10000000;\n\tserver->h264FrameRate = 30;\n\tserver->h264QP = 0;\n\tserver->authentication = FALSE;\n\tserver->settings = freerdp_settings_new(FREERDP_SETTINGS_SERVER_MODE);\n\treturn server;\n}\n\nvoid shadow_server_free(rdpShadowServer* server)\n{\n\tif (!server)\n\t\treturn;\n\n\tfree(server->ipcSocket);\n\tserver->ipcSocket = NULL;\n\tfreerdp_settings_free(server->settings);\n\tserver->settings = NULL;\n\tfree(server);\n}\n"], "filenames": ["server/shadow/shadow_server.c"], "buggy_code_start_loc": [589], "buggy_code_end_loc": [597], "fixing_code_start_loc": [588], "fixing_code_end_loc": [602], "type": "CWE-416", "message": "In FreeRDP before version 2.1.2, there is a use-after-free in gdi_SelectObject. All FreeRDP clients using compatibility mode with /relax-order-checks are affected. This is fixed in version 2.1.2.", "other": {"cve": {"id": "CVE-2020-4031", "sourceIdentifier": "security-advisories@github.com", "published": "2020-06-22T22:15:13.163", "lastModified": "2022-06-01T18:48:30.880", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In FreeRDP before version 2.1.2, there is a use-after-free in gdi_SelectObject. All FreeRDP clients using compatibility mode with /relax-order-checks are affected. This is fixed in version 2.1.2."}, {"lang": "es", "value": "En FreeRDP versiones anteriores a 2.1.2, se presenta un uso de la memoria previamente liberada en gdi_SelectObject. Todos los clientes FreeRDP que usan el modo de compatibilidad con /relax-order-checks est\u00e1n afectados. Esto es corregido en la versi\u00f3n 2.1.2"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.2", "matchCriteriaId": "DDAC8E89-8F23-4799-AA42-AD419455D1F6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00080.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.freerdp.com/2020/06/22/2_1_2-released", "source": "security-advisories@github.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/commit/6d86e20e1e7caaab4f0c7f89e36d32914dbccc52", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/FreeRDP/FreeRDP/security/advisories/GHSA-gwcq-hpq2-m74g", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6Y35HBHG2INICLSGCIKNAR7GCXEHQACQ/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/XOZLH35OJWIQLM7FYDXAP2EAUBDXE76V/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4481-1/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FreeRDP/FreeRDP/commit/6d86e20e1e7caaab4f0c7f89e36d32914dbccc52"}}