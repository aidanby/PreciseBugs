{"buggy_code": ["package io.onedev.server.entitymanager.impl;\n\nimport static java.util.stream.Collectors.toList;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\nimport javax.annotation.Nullable;\nimport javax.inject.Inject;\nimport javax.inject.Singleton;\nimport javax.persistence.criteria.CriteriaBuilder;\nimport javax.persistence.criteria.CriteriaQuery;\nimport javax.persistence.criteria.From;\nimport javax.persistence.criteria.Path;\nimport javax.persistence.criteria.Predicate;\nimport javax.persistence.criteria.Root;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.shiro.authz.Permission;\nimport org.apache.shiro.authz.UnauthorizedException;\nimport org.eclipse.jgit.api.Git;\nimport org.eclipse.jgit.api.errors.GitAPIException;\nimport org.eclipse.jgit.diff.DiffAlgorithm.SupportedAlgorithm;\nimport org.eclipse.jgit.internal.storage.file.FileRepository;\nimport org.eclipse.jgit.lib.ConfigConstants;\nimport org.eclipse.jgit.lib.ObjectId;\nimport org.eclipse.jgit.lib.Repository;\nimport org.eclipse.jgit.lib.StoredConfig;\nimport org.hibernate.Session;\nimport org.hibernate.query.Query;\nimport org.quartz.ScheduleBuilder;\nimport org.quartz.SimpleScheduleBuilder;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.Sets;\n\nimport io.onedev.commons.loader.Listen;\nimport io.onedev.commons.loader.ListenerRegistry;\nimport io.onedev.commons.utils.ExceptionUtils;\nimport io.onedev.commons.utils.FileUtils;\nimport io.onedev.commons.utils.StringUtils;\nimport io.onedev.server.buildspec.job.JobManager;\nimport io.onedev.server.entitymanager.BuildManager;\nimport io.onedev.server.entitymanager.IssueManager;\nimport io.onedev.server.entitymanager.LinkSpecManager;\nimport io.onedev.server.entitymanager.ProjectManager;\nimport io.onedev.server.entitymanager.RoleManager;\nimport io.onedev.server.entitymanager.SettingManager;\nimport io.onedev.server.entitymanager.UserAuthorizationManager;\nimport io.onedev.server.event.ProjectCreated;\nimport io.onedev.server.event.ProjectEvent;\nimport io.onedev.server.event.RefUpdated;\nimport io.onedev.server.event.entity.EntityPersisted;\nimport io.onedev.server.event.entity.EntityRemoved;\nimport io.onedev.server.event.system.SystemStarted;\nimport io.onedev.server.event.system.SystemStopping;\nimport io.onedev.server.git.GitUtils;\nimport io.onedev.server.git.command.CloneCommand;\nimport io.onedev.server.infomanager.CommitInfoManager;\nimport io.onedev.server.model.Build;\nimport io.onedev.server.model.Issue;\nimport io.onedev.server.model.LinkSpec;\nimport io.onedev.server.model.Milestone;\nimport io.onedev.server.model.Project;\nimport io.onedev.server.model.PullRequest;\nimport io.onedev.server.model.User;\nimport io.onedev.server.model.UserAuthorization;\nimport io.onedev.server.model.support.BranchProtection;\nimport io.onedev.server.model.support.TagProtection;\nimport io.onedev.server.persistence.SessionManager;\nimport io.onedev.server.persistence.TransactionManager;\nimport io.onedev.server.persistence.annotation.Sessional;\nimport io.onedev.server.persistence.annotation.Transactional;\nimport io.onedev.server.persistence.dao.BaseEntityManager;\nimport io.onedev.server.persistence.dao.Dao;\nimport io.onedev.server.search.entity.EntityQuery;\nimport io.onedev.server.search.entity.EntitySort;\nimport io.onedev.server.search.entity.EntitySort.Direction;\nimport io.onedev.server.search.entity.issue.IssueQueryUpdater;\nimport io.onedev.server.search.entity.project.ProjectQuery;\nimport io.onedev.server.security.SecurityUtils;\nimport io.onedev.server.security.permission.AccessProject;\nimport io.onedev.server.security.permission.ProjectPermission;\nimport io.onedev.server.util.criteria.Criteria;\nimport io.onedev.server.util.facade.ProjectFacade;\nimport io.onedev.server.util.match.WildcardUtils;\nimport io.onedev.server.util.patternset.PatternSet;\nimport io.onedev.server.util.schedule.SchedulableTask;\nimport io.onedev.server.util.schedule.TaskScheduler;\nimport io.onedev.server.util.usage.Usage;\nimport io.onedev.server.web.avatar.AvatarManager;\n\n@Singleton\npublic class DefaultProjectManager extends BaseEntityManager<Project> \n\t\timplements ProjectManager, SchedulableTask {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(DefaultProjectManager.class);\n\t\n    private final CommitInfoManager commitInfoManager;\n    \n    private final BuildManager buildManager;\n    \n    private final AvatarManager avatarManager;\n    \n    private final SettingManager settingManager;\n    \n    private final SessionManager sessionManager;\n    \n    private final TransactionManager transactionManager;\n    \n    private final IssueManager issueManager;\n    \n    private final LinkSpecManager linkSpecManager;\n    \n    private final JobManager jobManager;\n    \n    private final TaskScheduler taskScheduler;\n    \n    private final ListenerRegistry listenerRegistry;\n    \n    private final RoleManager roleManager;\n    \n    private final UserAuthorizationManager userAuthorizationManager;\n    \n    private final String gitReceiveHook;\n    \n\tprivate final Map<Long, Repository> repositoryCache = new ConcurrentHashMap<>();\n\t\n\tprivate final Map<Long, Date> updateDates = new ConcurrentHashMap<>();\n\t\n\tprivate final Map<Long, ProjectFacade> cache = new HashMap<>();\n\t\n\tprivate final ReadWriteLock cacheLock = new ReentrantReadWriteLock();\n\t\n\tprivate String taskId;\n\t\n    @Inject\n    public DefaultProjectManager(Dao dao, CommitInfoManager commitInfoManager,  \n    \t\tBuildManager buildManager, AvatarManager avatarManager, \n    \t\tSettingManager settingManager, TransactionManager transactionManager, \n    \t\tSessionManager sessionManager, ListenerRegistry listenerRegistry, \n    \t\tTaskScheduler taskScheduler, UserAuthorizationManager userAuthorizationManager, \n    \t\tRoleManager roleManager, JobManager jobManager, IssueManager issueManager, \n    \t\tLinkSpecManager linkSpecManager) {\n    \tsuper(dao);\n    \t\n        this.commitInfoManager = commitInfoManager;\n        this.buildManager = buildManager;\n        this.avatarManager = avatarManager;\n        this.settingManager = settingManager;\n        this.transactionManager = transactionManager;\n        this.sessionManager = sessionManager;\n        this.listenerRegistry = listenerRegistry;\n        this.taskScheduler = taskScheduler;\n        this.userAuthorizationManager = userAuthorizationManager;\n        this.roleManager = roleManager;\n        this.jobManager = jobManager;\n        this.issueManager = issueManager;\n        this.linkSpecManager = linkSpecManager;\n        \n        try (InputStream is = getClass().getClassLoader().getResourceAsStream(\"git-receive-hook\")) {\n        \tPreconditions.checkNotNull(is);\n            gitReceiveHook = StringUtils.join(IOUtils.readLines(is, Charset.defaultCharset()), \"\\n\");\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n\n    }\n    \n    @Override\n    public Repository getRepository(Project project) {\n    \tRepository repository = repositoryCache.get(project.getId());\n    \tif (repository == null) {\n    \t\tsynchronized (repositoryCache) {\n    \t\t\trepository = repositoryCache.get(project.getId());\n    \t\t\tif (repository == null) {\n    \t\t\t\ttry {\n\t\t\t\t\t\trepository = new FileRepository(project.getGitDir());\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t}\n    \t\t\t\trepositoryCache.put(project.getId(), repository);\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn repository;\n    }\n    \n    @Transactional\n    @Override\n    public void save(Project project) {\n    \tsave(project, null);\n    }\n    \n    @Transactional\n    @Override\n    public void save(Project project, String oldPath) {\n    \tdao.persist(project);\n    \tif (oldPath != null && !oldPath.equals(project.getPath())) {\n    \t\tCollection<Milestone> milestones = new ArrayList<>();\n    \t\tfor (Milestone milestone: issueManager.queryUsedMilestones(project)) {\n    \t\t\tif (!project.isSelfOrAncestorOf(milestone.getProject()) \n    \t\t\t\t\t&& !milestone.getProject().isSelfOrAncestorOf(project)) {\n    \t\t\t\tmilestones.add(milestone);\n    \t\t\t}\n    \t\t}\n    \t\tissueManager.clearSchedules(project, milestones);\n    \t\tsettingManager.onMoveProject(oldPath, project.getPath());\n    \t\t\n    \t\tfor (LinkSpec link: linkSpecManager.query()) {\n    \t\t\tfor (IssueQueryUpdater updater: link.getQueryUpdaters())\n    \t\t\t\tupdater.onMoveProject(oldPath, project.getPath());\n    \t\t}\n    \t\t\t\n    \t\tscheduleTree(project);\n    \t}\n    }\n    \n    private void scheduleTree(Project project) {\n    \tjobManager.schedule(project);\n    \tfor (Project child: project.getChildren()) \n    \t\tscheduleTree(child);\n    }\n    \n    @Transactional\n    @Override\n    public void create(Project project) {\n    \tProject parent = project.getParent();\n    \tif (parent != null && parent.isNew())\n    \t\tcreate(parent);\n    \tdao.persist(project);\n       \tcheckSanity(project);\n       \tUserAuthorization authorization = new UserAuthorization();\n       \tauthorization.setProject(project);\n       \tauthorization.setUser(SecurityUtils.getUser());\n       \tauthorization.setRole(roleManager.getOwner());\n       \tuserAuthorizationManager.save(authorization);\n       \tlistenerRegistry.post(new ProjectCreated(project));\n    }\n    \n    @Transactional\n    @Listen\n    public void on(EntityRemoved event) {\n    \tif (event.getEntity() instanceof Project) {\n    \t\tProject project = (Project) event.getEntity();\n    \t\tLong projectId = project.getId();\n    \t\ttransactionManager.runAfterCommit(new Runnable() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tcacheLock.writeLock().lock();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcache.remove(projectId);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tcacheLock.writeLock().unlock();\n\t\t\t\t\t}\n\t\t\t\t}\n    \t\t\t\n    \t\t});\n    \t}\n    }\n    \n    @Transactional\n    @Listen\n    public void on(EntityPersisted event) {\n    \tif (event.getEntity() instanceof Project) {\n    \t\tProjectFacade facade = ((Project) event.getEntity()).getFacade();\n    \t\ttransactionManager.runAfterCommit(new Runnable() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tcacheLock.writeLock().lock();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcache.put(facade.getId(), facade);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tcacheLock.writeLock().unlock();\n\t\t\t\t\t}\n\t\t\t\t}\n    \t\t\t\n    \t\t});\n    \t}\n    }\n    \n    @Transactional\n    @Override\n    public void delete(Project project) {\n    \tfor (Project child: project.getChildren())\n    \t\tdelete(child);\n    \t\n    \tUsage usage = new Usage();\n    \tusage.add(settingManager.onDeleteProject(project.getPath()));\n    \t\n\t\tfor (LinkSpec link: linkSpecManager.query()) {\n\t\t\tfor (IssueQueryUpdater updater: link.getQueryUpdaters())\n\t\t\t\tusage.add(updater.onDeleteProject(project.getPath()).prefix(\"issue setting\").prefix(\"administration\"));\n\t\t}\n    \t\n    \tusage.checkInUse(\"Project '\" + project.getPath() + \"'\");\n\n    \tfor (Project fork: project.getForks()) {\n    \t\tCollection<Project> descendants = fork.getForkChildren();\n    \t\tdescendants.add(fork);\n    \t\tfor (Project descendant: descendants) {\n            \tQuery<?> query = getSession().createQuery(String.format(\"update Issue set %s=:fork where %s=:descendant\", \n            \t\t\tIssue.PROP_NUMBER_SCOPE, Issue.PROP_PROJECT));\n            \tquery.setParameter(\"fork\", fork);\n            \tquery.setParameter(\"descendant\", descendant);\n            \tquery.executeUpdate();\n            \t\n            \tquery = getSession().createQuery(String.format(\"update Build set %s=:fork where %s=:descendant\", \n            \t\t\tBuild.PROP_NUMBER_SCOPE, Build.PROP_PROJECT));\n            \tquery.setParameter(\"fork\", fork);\n            \tquery.setParameter(\"descendant\", descendant);\n            \tquery.executeUpdate();\n            \t\n            \tquery = getSession().createQuery(String.format(\"update PullRequest set %s=:fork where %s=:descendant\", \n            \t\t\tPullRequest.PROP_NUMBER_SCOPE, PullRequest.PROP_TARGET_PROJECT));\n            \tquery.setParameter(\"fork\", fork);\n            \tquery.setParameter(\"descendant\", descendant);\n            \tquery.executeUpdate();\n    \t\t}\n    \t}\n    \t\n    \tQuery<?> query = getSession().createQuery(String.format(\"update Project set %s=null where %s=:forkedFrom\", \n    \t\t\tProject.PROP_FORKED_FROM, Project.PROP_FORKED_FROM));\n    \tquery.setParameter(\"forkedFrom\", project);\n    \tquery.executeUpdate();\n\n    \tquery = getSession().createQuery(String.format(\"update PullRequest set %s=null where %s=:sourceProject\", \n    \t\t\tPullRequest.PROP_SOURCE_PROJECT, PullRequest.PROP_SOURCE_PROJECT));\n    \tquery.setParameter(\"sourceProject\", project);\n    \tquery.executeUpdate();\n\n    \tfor (Build build: project.getBuilds()) \n    \t\tbuildManager.delete(build);\n    \t\n    \tdao.remove(project);\n    \t\n    \tsynchronized (repositoryCache) {\n\t\t\tRepository repository = repositoryCache.remove(project.getId());\n\t\t\tif (repository != null) \n\t\t\t\trepository.close();\n\t\t}\n    }\n    \n    @Override\n    public Project findByPath(String path) {\n\t\tcacheLock.readLock().lock();\n\t\ttry {\n\t\t\tLong projectId = findProjectId(path);\n\t\t\tif (projectId != null)\n\t\t\t\treturn load(projectId);\n\t\t\telse\n\t\t\t\treturn null;\n\t\t} finally {\n\t\t\tcacheLock.readLock().unlock();\n\t\t}\n    }\n    \n    @Nullable\n    private Long findProjectId(String path) {\n    \tLong projectId = null;\n    \tfor (String name: Splitter.on(\"/\").omitEmptyStrings().trimResults().split(path)) {\n    \t\tprojectId = findProjectId(projectId, name);\n    \t\tif (projectId == null)\n    \t\t\tbreak;\n    \t}\n    \treturn projectId;\n    }\n    \n    @Sessional\n    @Override\n    public Project findByServiceDeskName(String serviceDeskName) {\n\t\tcacheLock.readLock().lock();\n\t\ttry {\n\t\t\tLong projectId = null;\n\t\t\tfor (ProjectFacade facade: cache.values()) {\n\t\t\t\tif (serviceDeskName.equals(facade.getServiceDeskName())) {\n\t\t\t\t\tprojectId = facade.getId();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (projectId != null)\n\t\t\t\treturn load(projectId);\n\t\t\telse\n\t\t\t\treturn null;\n\t\t} finally {\n\t\t\tcacheLock.readLock().unlock();\n\t\t}\n    }\n    \n    @Sessional\n    @Override\n    public Project initialize(String path) {\n    \tList<String> names = Splitter.on(\"/\").omitEmptyStrings().trimResults().splitToList(path);\n    \tProject project = null;\n    \tfor (String name: names) { \n    \t\tProject child;\n    \t\tif (project == null || !project.isNew()) {\n    \t\t\tchild = find(project, name);\n    \t\t\tif (child == null) {\n\t    \t\t\tif (project == null && !SecurityUtils.canCreateRootProjects())\n\t    \t\t\t\tthrow new UnauthorizedException(\"Not authorized to create root project\");\n\t    \t\t\tif (project != null && !SecurityUtils.canCreateChildren(project))\n\t    \t\t\t\tthrow new UnauthorizedException(\"Not authorized to create project under '\" + project.getPath() + \"'\");\n\t    \t\t\tchild = new Project();\n\t    \t\t\tchild.setName(name);\n\t    \t\t\tchild.setParent(project); \n    \t\t\t}\n    \t\t} else {\n    \t\t\tchild = new Project();\n    \t\t\tchild.setName(name);\n    \t\t\tchild.setParent(project);\n    \t\t}\n    \t\tproject = child;\n    \t}\n    \t\n    \tProject parent = project.getParent();\n    \twhile (parent != null && parent.isNew()) {\n    \t\tparent.setCodeManagement(false);\n    \t\tparent.setIssueManagement(false);\n    \t\tparent = parent.getParent();\n    \t}\n    \t\n    \treturn project;\n    }\n    \n    @Sessional\n    @Override\n    public Project find(Project parent, String name) {\n\t\tcacheLock.readLock().lock();\n\t\ttry {\n\t\t\tLong projectId = null;\n\t\t\tfor (ProjectFacade facade: cache.values()) {\n\t\t\t\tif (facade.getName().equalsIgnoreCase(name) && Objects.equals(Project.idOf(parent), facade.getParentId())) {\n\t\t\t\t\tprojectId = facade.getId();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (projectId != null)\n\t\t\t\treturn load(projectId);\n\t\t\telse\n\t\t\t\treturn null;\n\t\t} finally {\n\t\t\tcacheLock.readLock().unlock();\n\t\t}\n    }\n    \n    @Transactional\n\t@Override\n\tpublic void fork(Project from, Project to) {\n    \tProject parent = to.getParent();\n    \tif (parent != null && parent.isNew())\n    \t\tcreate(parent);\n    \t\n    \tdao.persist(to);\n    \t\n       \tUserAuthorization authorization = new UserAuthorization();\n       \tauthorization.setProject(to);\n       \tauthorization.setUser(SecurityUtils.getUser());\n       \tauthorization.setRole(roleManager.getOwner());\n       \tuserAuthorizationManager.save(authorization);\n    \t\n        FileUtils.cleanDir(to.getGitDir());\n        new CloneCommand(to.getGitDir()).mirror(true).from(from.getGitDir().getAbsolutePath()).call();\n        checkSanity(to);\n        commitInfoManager.cloneInfo(from, to);\n        avatarManager.copyAvatar(from, to);\n        \n        if (from.getLfsObjectsDir().exists()) {\n            for (File file: FileUtils.listFiles(from.getLfsObjectsDir(), Sets.newHashSet(\"**\"), Sets.newHashSet())) {\n            \tString objectId = file.getName();\n            \tLock lock = from.getLfsObjectLock(objectId).readLock();\n            \tlock.lock();\n            \ttry {\n            \t\tFileUtils.copyFile(file, to.getLfsObjectFile(objectId));\n            \t} catch (IOException e) {\n            \t\tthrow new RuntimeException(e);\n    \t\t\t} finally {\n            \t\tlock.unlock();\n            \t}\n            }\n        }\n        \n        listenerRegistry.post(new ProjectCreated(to));\n\t}\n    \n    @Transactional\n    @Override\n    public void clone(Project project, String repositoryUrl) {\n    \tProject parent = project.getParent();\n    \tif (parent != null && parent.isNew())\n    \t\tcreate(parent);\n    \t\n    \tdao.persist(project);\n    \t\n    \tUser user = SecurityUtils.getUser();\n       \tUserAuthorization authorization = new UserAuthorization();\n       \tauthorization.setProject(project);\n       \tauthorization.setUser(user);\n       \tauthorization.setRole(roleManager.getOwner());\n       \tproject.getUserAuthorizations().add(authorization);\n       \tuser.getAuthorizations().add(authorization);\n       \tuserAuthorizationManager.save(authorization);\n    \t\n        FileUtils.cleanDir(project.getGitDir());\n        new CloneCommand(project.getGitDir()).mirror(true).from(repositoryUrl).call();\n        checkSanity(project);\n        \n        listenerRegistry.post(new ProjectCreated(project));\n    }\n    \n\tprivate boolean isGitHookValid(File gitDir, String hookName) {\n        File hookFile = new File(gitDir, \"hooks/\" + hookName);\n        if (!hookFile.exists()) \n        \treturn false;\n        \n        try {\n\t\t\tString content = FileUtils.readFileToString(hookFile, Charset.defaultCharset());\n\t\t\tif (!content.contains(\"ENV_GIT_ALTERNATE_OBJECT_DIRECTORIES\"))\n\t\t\t\treturn false;\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\t\n        if (!hookFile.canExecute())\n        \treturn false;\n        \n        return true;\n\t}\n\t\n\tprivate void checkSanity(Project project) {\n\t\tFile gitDir = project.getGitDir();\n\t\tif (gitDir.listFiles().length == 0) {\n        \tlogger.info(\"Initializing git repository in '\" + gitDir + \"'...\");\n            try (Git git = Git.init().setDirectory(gitDir).setBare(true).call()) {\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow ExceptionUtils.unchecked(e);\n\t\t\t}\n\t\t} else if (!GitUtils.isValid(gitDir)) {\n        \tlogger.warn(\"Directory '\" + gitDir + \"' is not a valid git repository, reinitializing...\");\n        \tFileUtils.cleanDir(gitDir);\n            try (Git git = Git.init().setDirectory(gitDir).setBare(true).call()) {\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow ExceptionUtils.unchecked(e);\n\t\t\t}\n        } \n\n\t\tif (!isGitHookValid(gitDir, \"pre-receive\") || !isGitHookValid(gitDir, \"post-receive\")) {\n            File hooksDir = new File(gitDir, \"hooks\");\n\n            File gitPreReceiveHookFile = new File(hooksDir, \"pre-receive\");\n            FileUtils.writeFile(gitPreReceiveHookFile, String.format(gitReceiveHook, \"git-prereceive-callback\"));\n            gitPreReceiveHookFile.setExecutable(true);\n            \n            File gitPostReceiveHookFile = new File(hooksDir, \"post-receive\");\n            FileUtils.writeFile(gitPostReceiveHookFile, String.format(gitReceiveHook, \"git-postreceive-callback\"));\n            gitPostReceiveHookFile.setExecutable(true);\n        }\n\n\t\ttry {\n\t\t\tStoredConfig config = project.getRepository().getConfig();\n\t\t\tboolean changed = false;\n\t\t\tif (config.getEnum(ConfigConstants.CONFIG_DIFF_SECTION, null, ConfigConstants.CONFIG_KEY_ALGORITHM, \n\t\t\t\t\tSupportedAlgorithm.MYERS) != SupportedAlgorithm.HISTOGRAM) {\n\t\t\t\tconfig.setEnum(ConfigConstants.CONFIG_DIFF_SECTION, null, ConfigConstants.CONFIG_KEY_ALGORITHM, \n\t\t\t\t\t\tSupportedAlgorithm.HISTOGRAM);\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t\tif (!config.getBoolean(\"uploadpack\", \"allowAnySHA1InWant\", false)) {\n\t\t\t\tconfig.setBoolean(\"uploadpack\", null, \"allowAnySHA1InWant\", true);\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t\tif (changed)\n\t\t\t\tconfig.save();\t\t\t\t\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\t\n\t@Listen\n\tpublic void on(SystemStopping event) {\n\t\ttaskScheduler.unschedule(taskId);\n\t\tsynchronized(repositoryCache) {\n\t\t\tfor (Repository repository: repositoryCache.values()) {\n\t\t\t\trepository.close();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Transactional\n\t@Listen\n\tpublic void on(ProjectEvent event) {\n\t\t/*\n\t\t * Update asynchronously to avoid deadlock \n\t\t */\n\t\tupdateDates.put(event.getProject().getId(), event.getDate());\n\t}\n\t\n\t@Transactional\n\t@Listen(1)\n\tpublic void on(SystemStarted event) {\n\t\tlogger.info(\"Checking projects...\");\n\t\tcacheLock.writeLock().lock();\n\t\ttry {\n\t\t\tfor (Project project: query()) {\n\t\t\t\tcache.put(project.getId(), project.getFacade());\n\t\t\t\tcheckSanity(project);\n\t\t\t}\n\t\t} finally {\n\t\t\tcacheLock.writeLock().unlock();\n\t\t}\n\t\ttaskId = taskScheduler.schedule(this);\n\t}\n\n\t@Transactional\n\t@Override\n\tpublic void onDeleteBranch(Project project, String branchName) {\n\t\tfor (Iterator<BranchProtection> it = project.getBranchProtections().iterator(); it.hasNext();) { \n\t\t\tBranchProtection protection = it.next();\n\t\t\tPatternSet patternSet = PatternSet.parse(protection.getBranches());\n\t\t\tpatternSet.getIncludes().remove(branchName);\n\t\t\tpatternSet.getExcludes().remove(branchName);\n\t\t\tprotection.setBranches(patternSet.toString());\n\t\t\tif (protection.getBranches().length() == 0)\n\t\t\t\tit.remove();\n\t\t}\n\t}\n\t\n\t@Transactional\n\t@Override\n\tpublic void deleteBranch(Project project, String branchName) {\n\t\tonDeleteBranch(project, branchName);\n\n\t\tString refName = GitUtils.branch2ref(branchName);\n    \tObjectId commitId = project.getObjectId(refName, true);\n    \ttry {\n\t\t\tproject.git().branchDelete().setForce(true).setBranchNames(branchName).call();\n\t\t} catch (Exception e) {\n\t\t\tthrow ExceptionUtils.unchecked(e);\n\t\t}\n    \t\n    \tLong projectId = project.getId();\n    \ttransactionManager.runAfterCommit(new Runnable() {\n\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t    \tsessionManager.runAsync(new Runnable() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tProject project = load(projectId);\n\t\t\t\t\t\tlistenerRegistry.post(new RefUpdated(project, refName, commitId, ObjectId.zeroId()));\n\t\t\t\t\t}\n\t\t    \t\t\n\t\t    \t});\n\t\t\t}\n    \t\t\n    \t});\n\t\t\n\t}\n\n\t@Transactional\n\t@Override\n\tpublic void onDeleteTag(Project project, String tagName) {\n\t\tfor (Iterator<TagProtection> it = project.getTagProtections().iterator(); it.hasNext();) { \n\t\t\tTagProtection protection = it.next();\n\t\t\tPatternSet patternSet = PatternSet.parse(protection.getTags());\n\t\t\tpatternSet.getIncludes().remove(tagName);\n\t\t\tpatternSet.getExcludes().remove(tagName);\n\t\t\tprotection.setTags(patternSet.toString());\n\t\t\tif (protection.getTags().length() == 0)\n\t\t\t\tit.remove();\n\t\t}\n\t}\n\t\n\t@Transactional\n\t@Override\n\tpublic void deleteTag(Project project, String tagName) {\n    \tonDeleteTag(project, tagName);\n    \t\n    \tString refName = GitUtils.tag2ref(tagName);\n    \tObjectId commitId = project.getRevCommit(refName, true).getId();\n    \ttry {\n\t\t\tproject.git().tagDelete().setTags(tagName).call();\n\t\t} catch (GitAPIException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\n    \tLong projectId = project.getId();\n    \ttransactionManager.runAfterCommit(new Runnable() {\n\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t    \tsessionManager.runAsync(new Runnable() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tProject project = load(projectId);\n\t\t\t\t\t\tlistenerRegistry.post(new RefUpdated(project, refName, commitId, ObjectId.zeroId()));\n\t\t\t\t\t}\n\t\t    \t\t\n\t\t    \t});\n\t\t\t}\n    \t\t\n    \t});\n\t}\n\t\n\t@Override\n\tpublic List<Project> query() {\n\t\treturn query(true);\n\t}\n\n\t@Override\n\tpublic int count() {\n\t\treturn count(true);\n\t}\n\t\n\t@Sessional\n\t@Override\n\tpublic Collection<Project> getPermittedProjects(Permission permission) {\n\t\treturn query().stream()\n\t\t\t\t.filter(it->SecurityUtils.getSubject().isPermitted(new ProjectPermission(it, permission)))\n\t\t\t\t.collect(toList());\n\t}\n\n\tprivate CriteriaQuery<Project> buildCriteriaQuery(Session session, EntityQuery<Project> projectQuery) {\n\t\tCriteriaBuilder builder = session.getCriteriaBuilder();\n\t\tCriteriaQuery<Project> query = builder.createQuery(Project.class);\n\t\tRoot<Project> root = query.from(Project.class);\n\t\tquery.select(root);\n\t\t\n\t\tquery.where(getPredicates(projectQuery.getCriteria(), query, root, builder));\n\n\t\tList<javax.persistence.criteria.Order> orders = new ArrayList<>();\n\t\tfor (EntitySort sort: projectQuery.getSorts()) {\n\t\t\tif (sort.getDirection() == Direction.ASCENDING)\n\t\t\t\torders.add(builder.asc(ProjectQuery.getPath(root, Project.ORDER_FIELDS.get(sort.getField()))));\n\t\t\telse\n\t\t\t\torders.add(builder.desc(ProjectQuery.getPath(root, Project.ORDER_FIELDS.get(sort.getField()))));\n\t\t}\n\n\t\tif (orders.isEmpty())\n\t\t\torders.add(builder.desc(ProjectQuery.getPath(root, Project.PROP_UPDATE_DATE)));\n\t\tquery.orderBy(orders);\n\t\t\n\t\treturn query;\n\t}\n\t\n\tprivate Predicate[] getPredicates(@Nullable Criteria<Project> criteria, CriteriaQuery<?> query, \n\t\t\tFrom<Project, Project> from, CriteriaBuilder builder) {\n\t\tList<Predicate> predicates = new ArrayList<>();\n\t\tif (!SecurityUtils.isAdministrator()) {\n\t\t\tCollection<Project> projects = getPermittedProjects(new AccessProject());\n\t\t\tif (!projects.isEmpty())\n\t\t\t\tpredicates.add(getProjectsPredicate(builder, from, projects));\n\t\t\telse\n\t\t\t\tpredicates.add(builder.disjunction());\n\t\t}\n\t\tif (criteria != null) \n\t\t\tpredicates.add(criteria.getPredicate(query, from, builder));\n\t\treturn predicates.toArray(new Predicate[0]);\n\t}\n\t\n\t@Sessional\n\t@Override\n\tpublic List<Project> query(EntityQuery<Project> query, int firstResult, int maxResults) {\n\t\tCriteriaQuery<Project> criteriaQuery = buildCriteriaQuery(getSession(), query);\n\t\tQuery<Project> projectQuery = getSession().createQuery(criteriaQuery);\n\t\tprojectQuery.setFirstResult(firstResult);\n\t\tprojectQuery.setMaxResults(maxResults);\n\t\treturn projectQuery.getResultList();\n\t}\n\n\t@Sessional\n\t@Override\n\tpublic int count(Criteria<Project> projectCriteria) {\n\t\tCriteriaBuilder builder = getSession().getCriteriaBuilder();\n\t\tCriteriaQuery<Long> criteriaQuery = builder.createQuery(Long.class);\n\t\tRoot<Project> root = criteriaQuery.from(Project.class);\n\n\t\tcriteriaQuery.where(getPredicates(projectCriteria, criteriaQuery, root, builder));\n\n\t\tcriteriaQuery.select(builder.count(root));\n\t\treturn getSession().createQuery(criteriaQuery).uniqueResult().intValue();\n\t}\n\n\t@Override\n\tpublic void execute() {\n\t\ttry {\n\t\t\ttransactionManager.run(new Runnable() {\n\t\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tDate now = new Date();\n\t\t\t\t\tfor (Iterator<Map.Entry<Long, Date>> it = updateDates.entrySet().iterator(); it.hasNext();) {\n\t\t\t\t\t\tMap.Entry<Long, Date> entry = it.next();\n\t\t\t\t\t\tif (now.getTime() - entry.getValue().getTime() > 60000) {\n\t\t\t\t\t\t\tProject project = get(entry.getKey());\n\t\t\t\t\t\t\tif (project != null)\n\t\t\t\t\t\t\t\tproject.setUpdateDate(entry.getValue());\n\t\t\t\t\t\t\tit.remove();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t});\n\t\t} catch (Exception e) {\n\t\t\tlogger.error(\"Error flushing project update dates\", e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic ScheduleBuilder<?> getScheduleBuilder() {\n\t\treturn SimpleScheduleBuilder.repeatMinutelyForever();\n\t}\n\t\n\tprivate String getPath(Long id) {\n\t\tProjectFacade facade = cache.get(id);\n\t\tif (facade != null) {\n\t\t\tif (facade.getParentId() != null) {\n\t\t\t\tString parentPath = getPath(facade.getParentId());\n\t\t\t\tif (parentPath != null)\n\t\t\t\t\treturn parentPath + \"/\" + facade.getName();\n\t\t\t\telse\n\t\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\treturn facade.getName();\n\t\t\t}\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate Collection<Long> getMatchingIds(String pathPattern) {\n\t\tCollection<Long> ids = new HashSet<>();\n\t\tfor (Long id: cache.keySet()) {\n\t\t\tString path = getPath(id);\n\t\t\tif (path != null && WildcardUtils.matchPath(pathPattern, path))\n\t\t\t\tids.add(id);\n\t\t}\n\t\treturn ids;\n\t}\n\n\tprivate Collection<Long> getSubtreeIds(Long projectId) {\n\t\tCollection<Long> treeIds = Sets.newHashSet(projectId);\n\t\tfor (ProjectFacade facade: cache.values()) {\n\t\t\tif (projectId.equals(facade.getParentId()))\n\t\t\t\ttreeIds.addAll(getSubtreeIds(facade.getId()));\n\t\t}\n\t\treturn treeIds;\n\t}\n\t\n\t@Override\n\tpublic Predicate getPathMatchPredicate(CriteriaBuilder builder, Path<Project> path, String pathPattern) {\n\t\tcacheLock.readLock().lock();\n\t\ttry {\n\t\t\treturn Criteria.forManyValues(builder, path.get(Project.PROP_ID), \n\t\t\t\t\tgetMatchingIds(pathPattern), cache.keySet());\t\t\n\t\t} finally {\n\t\t\tcacheLock.readLock().unlock();\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic org.apache.lucene.search.Query getPathMatchQuery(String fieldName, String pathPattern) {\n\t\tcacheLock.readLock().lock();\n\t\ttry {\n\t\t\treturn Criteria.forManyValues(fieldName, getMatchingIds(pathPattern), cache.keySet());\t\t\n\t\t} finally {\n\t\t\tcacheLock.readLock().unlock();\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic Predicate getSubtreePredicate(CriteriaBuilder builder, Path<Project> path, Project project) {\n\t\tcacheLock.readLock().lock();\n\t\ttry {\n\t\t\treturn Criteria.forManyValues(builder, path.get(Project.PROP_ID), \n\t\t\t\t\tgetSubtreeIds(project.getId()), cache.keySet());\t\t\n\t\t} finally {\n\t\t\tcacheLock.readLock().unlock();\n\t\t}\n\t}\n\n\t@Override\n\tpublic org.apache.lucene.search.Query getSubtreeQuery(String fieldName, Project project) {\n\t\tcacheLock.readLock().lock();\n\t\ttry {\n\t\t\treturn Criteria.forManyValues(fieldName, getSubtreeIds(project.getId()), cache.keySet());\t\t\n\t\t} finally {\n\t\t\tcacheLock.readLock().unlock();\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic Predicate getProjectsPredicate(CriteriaBuilder builder, Path<Project> path, Collection<Project> projects) {\n\t\tcacheLock.readLock().lock();\n\t\ttry {\n\t\t\treturn Criteria.forManyValues(builder, path.get(Project.PROP_ID), \n\t\t\t\t\tprojects.stream().map(it->it.getId()).collect(toList()), cache.keySet());\t\t\n\t\t} finally {\n\t\t\tcacheLock.readLock().unlock();\n\t\t}\n\t}\n\n\t@Override\n\tpublic org.apache.lucene.search.Query getProjectsQuery(String fieldName, Collection<Project> projects) {\n\t\tcacheLock.readLock().lock();\n\t\ttry {\n\t\t\treturn Criteria.forManyValues(fieldName, projects.stream().map(it->it.getId()).collect(toList()), \n\t\t\t\t\tcache.keySet());\t\t\n\t\t} finally {\n\t\t\tcacheLock.readLock().unlock();\n\t\t}\n\t}\n\t\n\t@Transactional\n\t@Override\n\tpublic void move(Collection<Project> projects, Project parent) {\n\t\tfor (Project project: projects) { \n\t\t\tString oldPath = project.getPath();\n\t\t\tproject.setParent(parent);\n\t\t\tsave(project, oldPath);\n\t\t}\n\t}\n\n\t@Transactional\n\t@Override\n\tpublic void delete(Collection<Project> projects) {\n\t\tCollection<Project> independents = new HashSet<>(projects);\n\t\tfor (Iterator<Project> it = independents.iterator(); it.hasNext();) {\n\t\t\tProject independent = it.next();\n\t\t\tfor (Project each: independents) {\n\t\t\t\tif (!each.equals(independent) && each.isSelfOrAncestorOf(independent)) {\n\t\t\t\t\tit.remove();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (Project independent: independents)\n\t\t\tdelete(independent);\n\t}\n    \n\t@Nullable\n    private Long findProjectId(@Nullable Long parentId, String name) {\n\t\tfor (ProjectFacade facade: cache.values()) {\n\t\t\tif (facade.getName().equalsIgnoreCase(name) && Objects.equals(parentId, facade.getParentId())) \n\t\t\t\treturn facade.getId();\n\t\t}\n\t\treturn null;\n    }\n\n\tprivate int findLongestMatch(@Nullable Long parentId, List<String> pathSegments) {\n\t\tif (!pathSegments.isEmpty()) {\n\t\t\tString name = pathSegments.get(0);\n\t\t\tLong projectId = findProjectId(parentId, name);\n\t\t\tif (projectId != null)\n\t\t\t\treturn findLongestMatch(projectId, pathSegments.subList(1, pathSegments.size())) + 1;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic int findLongestMatch(List<String> pathSegments) {\n\t\tcacheLock.readLock().lock();\n\t\ttry {\n\t\t\treturn findLongestMatch(null, pathSegments);\n\t\t} finally {\n\t\t\tcacheLock.readLock().unlock();\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic List<ProjectFacade> getChildren(Long projectId) {\n\t\tcacheLock.readLock().lock();\n\t\ttry {\n\t\t\tList<ProjectFacade> children = new ArrayList<>();\n\t\t\tfor (ProjectFacade facade: cache.values()) {\n\t\t\t\tif (projectId.equals(facade.getParentId()))\n\t\t\t\t\tchildren.add(facade);\n\t\t\t}\n\t\t\tCollections.sort(children, new Comparator<ProjectFacade>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(ProjectFacade o1, ProjectFacade o2) {\n\t\t\t\t\treturn o1.getName().compareTo(o2.getName());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t});\n\t\t\treturn children;\n\t\t} finally {\n\t\t\tcacheLock.readLock().unlock();\n\t\t}\n\t}\n    \n}\n", "package io.onedev.server.git;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport javax.inject.Inject;\nimport javax.inject.Singleton;\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.shiro.authz.UnauthorizedException;\nimport org.eclipse.jgit.http.server.GitSmartHttpTools;\nimport org.eclipse.jgit.http.server.ServletUtils;\nimport org.eclipse.jgit.transport.PacketLineOut;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport io.onedev.commons.utils.command.ErrorCollector;\nimport io.onedev.commons.utils.command.ExecutionResult;\nimport io.onedev.server.OneDev;\nimport io.onedev.server.entitymanager.ProjectManager;\nimport io.onedev.server.entitymanager.SettingManager;\nimport io.onedev.server.exception.SystemNotReadyException;\nimport io.onedev.server.git.command.AdvertiseReceiveRefsCommand;\nimport io.onedev.server.git.command.AdvertiseUploadRefsCommand;\nimport io.onedev.server.git.command.ReceivePackCommand;\nimport io.onedev.server.git.command.UploadPackCommand;\nimport io.onedev.server.git.exception.GitException;\nimport io.onedev.server.model.Project;\nimport io.onedev.server.persistence.SessionManager;\nimport io.onedev.server.security.CodePullAuthorizationSource;\nimport io.onedev.server.security.SecurityUtils;\nimport io.onedev.server.storage.StorageManager;\nimport io.onedev.server.util.InputStreamWrapper;\nimport io.onedev.server.util.OutputStreamWrapper;\nimport io.onedev.server.util.ServerConfig;\nimport io.onedev.server.util.concurrent.PrioritizedRunnable;\nimport io.onedev.server.util.concurrent.WorkExecutor;\n\n@Singleton\npublic class GitFilter implements Filter {\n\t\n\tprivate static final Logger logger = LoggerFactory.getLogger(GitFilter.class);\n\n\tprivate static final int PRIORITY = 2;\n\t\n\tprivate static final String INFO_REFS = \"info/refs\";\n\t\n\tprivate final OneDev oneDev;\n\t\n\tprivate final StorageManager storageManager;\n\t\n\tprivate final ProjectManager projectManager;\n\t\n\tprivate final WorkExecutor workExecutor;\n\t\n\tprivate final ServerConfig serverConfig;\n\t\n\tprivate final SettingManager settingManager;\n\t\n\tprivate final SessionManager sessionManager;\n\t\n\tprivate final Set<CodePullAuthorizationSource> codePullAuthorizationSources;\n\t\n\t@Inject\n\tpublic GitFilter(OneDev oneDev, StorageManager storageManager, ProjectManager projectManager, \n\t\t\tWorkExecutor workExecutor, ServerConfig serverConfig, SettingManager settingManager,\n\t\t\tSessionManager sessionManager, Set<CodePullAuthorizationSource> codePullAuthorizationSources) {\n\t\tthis.oneDev = oneDev;\n\t\tthis.storageManager = storageManager;\n\t\tthis.projectManager = projectManager;\n\t\tthis.workExecutor = workExecutor;\n\t\tthis.serverConfig = serverConfig;\n\t\tthis.settingManager = settingManager;\n\t\tthis.sessionManager = sessionManager;\n\t\tthis.codePullAuthorizationSources = codePullAuthorizationSources;\n\t}\n\t\n\tprivate String getPathInfo(HttpServletRequest request) {\n\t\tString pathInfo = request.getRequestURI().substring(request.getContextPath().length());\n\t\treturn StringUtils.stripStart(pathInfo, \"/\");\n\t}\n\t\n\tprivate Project getProject(HttpServletRequest request, HttpServletResponse response, String projectInfo) \n\t\t\tthrows IOException {\n\t\tString projectPath = StringUtils.strip(projectInfo, \"/\");\n\n\t\tProject project = projectManager.findByPath(projectPath);\n\t\tif (project == null && projectPath.startsWith(\"projects/\")) {\n\t\t\tprojectPath = projectPath.substring(\"projects/\".length());\n\t\t\tproject = projectManager.findByPath(projectPath);\n\t\t}\n\t\tif (project == null) \n\t\t\tthrow new GitException(String.format(\"Unable to find project '%s'\", projectPath));\n\t\treturn project;\n\t}\n\t\n\tprivate void doNotCache(HttpServletResponse response) {\n\t\tresponse.setHeader(\"Expires\", \"Fri, 01 Jan 1980 00:00:00 GMT\");\n\t\tresponse.setHeader(\"Pragma\", \"no-cache\");\n\t\tresponse.setHeader(\"Cache-Control\", \"no-cache, max-age=0, must-revalidate\");\n\t}\n\t\n\tprotected void processPacks(final HttpServletRequest request, final HttpServletResponse response) \n\t\t\tthrows ServletException, IOException, InterruptedException, ExecutionException {\n\t\tFile gitDir;\n\t\tboolean upload;\n\t\tMap<String, String> environments = new HashMap<>();\n\t\t\n\t\tsessionManager.openSession();\n\t\ttry {\n\t\t\tString pathInfo = getPathInfo(request);\n\t\t\t\n\t\t\tString service = StringUtils.substringAfterLast(pathInfo, \"/\");\n\n\t\t\tString projectInfo = StringUtils.substringBeforeLast(pathInfo, \"/\");\n\t\t\tProject project = getProject(request, response, projectInfo);\n\t\t\t\n\t\t\tdoNotCache(response);\n\t\t\tresponse.setHeader(\"Content-Type\", \"application/x-\" + service + \"-result\");\t\t\t\n\n\t\t\tString serverUrl;\n\t        if (serverConfig.getHttpPort() != 0)\n\t            serverUrl = \"http://localhost:\" + serverConfig.getHttpPort();\n\t        else \n\t            serverUrl = \"https://localhost:\" + serverConfig.getHttpsPort();\n\n\t        environments.put(\"ONEDEV_CURL\", settingManager.getSystemSetting().getCurlConfig().getExecutable());\n\t\t\tenvironments.put(\"ONEDEV_URL\", serverUrl);\n\t\t\tenvironments.put(\"ONEDEV_USER_ID\", SecurityUtils.getUserId().toString());\n\t\t\tenvironments.put(\"ONEDEV_REPOSITORY_ID\", project.getId().toString());\n\t\t\t\n\t\t\t// to be compatible with old repository\n\t        environments.put(\"GITPLEX_CURL\", settingManager.getSystemSetting().getCurlConfig().getExecutable());\n\t\t\tenvironments.put(\"GITPLEX_URL\", serverUrl);\n\t\t\tenvironments.put(\"GITPLEX_USER_ID\", SecurityUtils.getUserId().toString());\n\t\t\tenvironments.put(\"GITPLEX_REPOSITORY_ID\", project.getId().toString());\n\t\t\t\n\t\t\tgitDir = storageManager.getProjectGitDir(project.getId());\n\n\t\t\tif (GitSmartHttpTools.isUploadPack(request)) {\n\t\t\t\tcheckPullPermission(request, project);\n\t\t\t\tupload = true;\n\t\t\t} else {\n\t\t\t\tif (!SecurityUtils.canWriteCode(project))\n\t\t\t\t\tthrow new UnauthorizedException(\"You do not have permission to push to this project.\");\n\t\t\t\tupload = false;\n\t\t\t}\t\t\t\n\t\t} finally {\n\t\t\tsessionManager.closeSession();\n\t\t}\n\t\t\n\t\tInputStream stdin = new InputStreamWrapper(ServletUtils.getInputStream(request)) {\n\n\t\t\t@Override\n\t\t\tpublic void close() throws IOException {\n\t\t\t}\n\t\t\t\n\t\t};\n\t\tOutputStream stdout = new OutputStreamWrapper(response.getOutputStream()) {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void close() throws IOException {\n\t\t\t}\n\t\t\t\n\t\t};\n\t\t\n\t\tString protocol = request.getHeader(\"Git-Protocol\");\t\t\n\t\t\n\t\tif (upload) {\n\t\t\tworkExecutor.submit(new PrioritizedRunnable(PRIORITY) {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tAtomicBoolean toleratedErrors = new AtomicBoolean(false);\n\t\t\t\t\tErrorCollector stderr = new ErrorCollector(StandardCharsets.UTF_8.name()) {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void consume(String line) {\n\t\t\t\t\t\t\tsuper.consume(line);\n\t\t\t\t\t\t\t// This error may happen during a normal shallow fetch/clone \n\t\t\t\t\t\t\tif (line.contains(\"remote end hung up unexpectedly\")) {\n\t\t\t\t\t\t\t\ttoleratedErrors.set(true);\n\t\t\t\t\t\t\t\tlogger.debug(line);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlogger.error(line);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t};\n\n\t\t\t\t\tExecutionResult result;\n\t\t\t\t\tUploadPackCommand upload = new UploadPackCommand(gitDir, environments);\n\t\t\t\t\tupload.stdin(stdin).stdout(stdout).stderr(stderr).statelessRpc(true).protocol(protocol);\n\t\t\t\t\tresult = upload.call();\n\t\t\t\t\tresult.setStderr(stderr.getMessage());\n\t\t\t\t\t\n\t\t\t\t\tif (result.getReturnCode() != 0 && !toleratedErrors.get())\n\t\t\t\t\t\tthrow result.buildException();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}).get();\n\t\t} else {\n\t\t\tworkExecutor.submit(new PrioritizedRunnable(PRIORITY) {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tErrorCollector stderr = new ErrorCollector(StandardCharsets.UTF_8.name()) {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void consume(String line) {\n\t\t\t\t\t\t\tsuper.consume(line);\n\t\t\t\t\t\t\tlogger.error(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\t\tReceivePackCommand receive = new ReceivePackCommand(gitDir, environments);\n\t\t\t\t\treceive.stdin(stdin).stdout(stdout).stderr(stderr).statelessRpc(true).protocol(protocol);\n\t\t\t\t\tExecutionResult result = receive.call();\n\t\t\t\t\tresult.setStderr(stderr.getMessage());\n\t\t\t\t\tresult.checkReturnCode();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}).get();\n\t\t}\n\t}\n\t\n\tprivate void writeInitial(HttpServletResponse response, String service) throws IOException {\n\t\tdoNotCache(response);\n\t\tresponse.setHeader(\"Content-Type\", \"application/x-\" + service + \"-advertisement\");\t\t\t\n\t\t\n\t\tPacketLineOut pack = new PacketLineOut(response.getOutputStream());\n\t\tpack.setFlushOnEnd(false);\n\t\tpack.writeString(\"# service=\" + service + \"\\n\");\n\t\tpack.end();\n\t}\n\t\n\tprivate void checkPullPermission(HttpServletRequest request, Project project) {\n\t\tif (!SecurityUtils.canReadCode(project)) {\n\t\t\tboolean isAuthorized = false;\n\t\t\tfor (CodePullAuthorizationSource source: codePullAuthorizationSources) {\n\t\t\t\tif (source.canPullCode(request, project)) {\n\t\t\t\t\tisAuthorized = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!isAuthorized)\n\t\t\t\tthrow new UnauthorizedException(\"You do not have permission to pull from this project.\");\n\t\t}\n\t}\n\t\n\tprotected void processRefs(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\tFile gitDir;\n\t\tboolean upload;\n\n\t\tsessionManager.openSession();\n\t\ttry {\n\t\t\tString pathInfo = request.getRequestURI().substring(request.getContextPath().length());\n\t\t\tpathInfo = StringUtils.stripStart(pathInfo, \"/\");\n\n\t\t\tString projectInfo = pathInfo.substring(0, pathInfo.length() - INFO_REFS.length());\n\t\t\tProject project = getProject(request, response, projectInfo);\n\t\t\tString service = request.getParameter(\"service\");\n\t\t\t\n\t\t\tgitDir = storageManager.getProjectGitDir(project.getId());\n\n\t\t\tif (service.contains(\"upload\")) {\n\t\t\t\tcheckPullPermission(request, project);\n\t\t\t\twriteInitial(response, service);\n\t\t\t\tupload = true;\n\t\t\t} else {\n\t\t\t\tif (!SecurityUtils.canWriteCode(project))\n\t\t\t\t\tthrow new UnauthorizedException(\"You do not have permission to push to this project.\");\n\t\t\t\twriteInitial(response, service);\n\t\t\t\tupload = false;\n\t\t\t}\n\t\t} finally {\n\t\t\tsessionManager.closeSession();\n\t\t}\n\t\t\n\t\tOutputStream os = new OutputStreamWrapper(response.getOutputStream()) {\n\n\t\t\t@Override\n\t\t\tpublic void close() throws IOException {\n\t\t\t}\n\t\t\t\n\t\t};\n\t\t\n\t\tString protocolVersion = request.getHeader(\"Git-Protocol\");\t\t\n\t\t\n\t\tif (upload) \n\t\t\tnew AdvertiseUploadRefsCommand(gitDir).protocol(protocolVersion).output(os).call();\n\t\telse \n\t\t\tnew AdvertiseReceiveRefsCommand(gitDir).protocol(protocolVersion).output(os).call();\n\t}\n\n\t@Override\n\tpublic void init(FilterConfig filterConfig) throws ServletException {\n\t}\n\n\t@Override\n\tpublic void doFilter(ServletRequest request, ServletResponse response,\n\t\t\tFilterChain chain) throws IOException, ServletException {\n\t\tHttpServletRequest httpRequest = (HttpServletRequest) request;\n\t\tHttpServletResponse httpResponse = (HttpServletResponse) response;\n\t\t\n\t\ttry {\n\t\t\tif (GitSmartHttpTools.isInfoRefs(httpRequest)) {\n\t\t\t\tif (oneDev.isReady())\n\t\t\t\t\tprocessRefs(httpRequest, httpResponse);\n\t\t\t\telse\n\t\t\t\t\tthrow new SystemNotReadyException();\n\t\t\t} else if (GitSmartHttpTools.isReceivePack(httpRequest) || GitSmartHttpTools.isUploadPack(httpRequest)) {\n\t\t\t\tif (oneDev.isReady())\n\t\t\t\t\tprocessPacks(httpRequest, httpResponse);\n\t\t\t\telse\n\t\t\t\t\tthrow new SystemNotReadyException();\n\t\t\t} else {\n\t\t\t\tchain.doFilter(request, response);\n\t\t\t}\n\t\t} catch (SystemNotReadyException e) {\n\t\t\tlogger.debug(\"Unable to serve git request as system is not ready yet\");\n\t\t\tGitSmartHttpTools.sendError(httpRequest, httpResponse, HttpServletResponse.SC_SERVICE_UNAVAILABLE, e.getMessage());\n\t\t} catch (GitException|InterruptedException|ExecutionException e) {\n\t\t\tlogger.error(\"Error serving git request\", e);\n\t\t\tGitSmartHttpTools.sendError(httpRequest, httpResponse, HttpServletResponse.SC_INTERNAL_SERVER_ERROR, e.getMessage());\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic void destroy() {\n\t}\n\t\n}\n ", "package io.onedev.server.git;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.net.InetSocketAddress;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.Future;\n\nimport javax.annotation.Nullable;\n\nimport org.apache.shiro.util.ThreadContext;\nimport org.apache.sshd.common.channel.ChannelOutputStream;\nimport org.apache.sshd.server.Environment;\nimport org.apache.sshd.server.ExitCallback;\nimport org.apache.sshd.server.channel.ChannelSession;\nimport org.apache.sshd.server.command.Command;\nimport org.apache.sshd.server.session.ServerSession;\nimport org.apache.sshd.server.session.ServerSessionAware;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport io.onedev.commons.utils.StringUtils;\nimport io.onedev.commons.utils.command.ExecutionResult;\nimport io.onedev.server.OneDev;\nimport io.onedev.server.entitymanager.ProjectManager;\nimport io.onedev.server.entitymanager.SettingManager;\nimport io.onedev.server.model.Project;\nimport io.onedev.server.persistence.SessionManager;\nimport io.onedev.server.security.SecurityUtils;\nimport io.onedev.server.ssh.SshAuthenticator;\nimport io.onedev.server.util.InputStreamWrapper;\nimport io.onedev.server.util.OutputStreamWrapper;\nimport io.onedev.server.util.ServerConfig;\nimport io.onedev.server.util.concurrent.WorkExecutor;\nimport io.onedev.server.util.concurrent.PrioritizedRunnable;\n\nabstract class GitSshCommand implements Command, ServerSessionAware {\n\t\n\tprivate static final int PRIORITY = 2;\n\t\n\tprivate static final Logger logger = LoggerFactory.getLogger(GitSshCommand.class);\n\n\tfinal String command;\n\t\n\tInputStream in;\n\t\n\tOutputStream out;\n\t\n\tOutputStream err;\n\t\n\tExitCallback callback;\n\t\n\tServerSession session;\n\t\n\tFuture<?> future;\n\t\n\tGitSshCommand(String command) {\n\t\tthis.command = command;\n\t}\n\t\n    private Map<String, String> buildGitEnvs(Project project) {\n\t\tMap<String, String> environments = new HashMap<>();\n\t\t\n\t\tServerConfig serverConfig = OneDev.getInstance(ServerConfig.class);\n\t\tString serverUrl;\n        if (serverConfig.getHttpPort() != 0)\n            serverUrl = \"http://localhost:\" + serverConfig.getHttpPort();\n        else \n            serverUrl = \"https://localhost:\" + serverConfig.getHttpsPort();\n\n        SettingManager settingManager = OneDev.getInstance(SettingManager.class);\n        environments.put(\"ONEDEV_CURL\", settingManager.getSystemSetting().getCurlConfig().getExecutable());\n\t\tenvironments.put(\"ONEDEV_URL\", serverUrl);\n\t\tenvironments.put(\"ONEDEV_USER_ID\", SecurityUtils.getUserId().toString());\n\t\tenvironments.put(\"ONEDEV_REPOSITORY_ID\", project.getId().toString());\n\t\treturn environments;\n    }\n    \n\t@Override\n\tpublic void start(ChannelSession channel, Environment env) throws IOException {\n\t\tSshAuthenticator authenticator = OneDev.getInstance(SshAuthenticator.class);\n\t\tThreadContext.bind(SecurityUtils.asSubject(authenticator.getPublicKeyOwnerId(session)));\n\t\t\n        File gitDir;\n        Map<String, String> gitEnvs;\n        \n        SessionManager sessionManager = OneDev.getInstance(SessionManager.class);\n        sessionManager.openSession(); \n        try {\n\t\t\tProjectManager projectManager = OneDev.getInstance(ProjectManager.class);\n\t\t\tString projectPath = StringUtils.substringAfter(command, \"'/\");   \n\t\t\tprojectPath = StringUtils.substringBefore(projectPath, \"'\");\n            Project project = projectManager.findByPath(projectPath);\n    \t\tif (project == null && projectPath.startsWith(\"projects/\")) {\n    \t\t\tprojectPath = projectPath.substring(\"projects/\".length());\n    \t\t\tproject = projectManager.findByPath(projectPath);\n    \t\t}\n            if (project == null) {\n                onExit(-1, \"Unable to find project '\" + projectPath + \"'\");\n                return;\n            } \n            \n        \tString errorMessage = checkPermission(project);\n        \tif (errorMessage != null) {\n        \t\tonExit(-1, errorMessage);\n        \t\treturn;\n        \t} \n\n            gitDir = project.getGitDir();\n            gitEnvs = buildGitEnvs(project);\n        } finally {                \n            sessionManager.closeSession();\n        }\n\t\t\n        InetSocketAddress address = (InetSocketAddress) session.getRemoteAddress();\n        String groupId = \"git-over-ssh-\" + gitDir.getAbsolutePath() \n        \t\t+ \"-\" + address.getAddress().getHostAddress();\n        \n        WorkExecutor workExecutor = OneDev.getInstance(WorkExecutor.class);\n\t\tfuture = workExecutor.submit(groupId, new PrioritizedRunnable(PRIORITY) {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tExecutionResult result = execute(gitDir, gitEnvs);\n\t\t\t\t\tonExit(result.getReturnCode(), null);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tlogger.error(\"Error executing git command\", e);\n\t\t\t\t\tonExit(-1, e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t}\n\t\n\t@Nullable\n\tprotected abstract String checkPermission(Project project);\n\n\tprotected abstract ExecutionResult execute(File gitDir, Map<String, String> gitEnvs);\n\n\t@Override\n\tpublic void destroy(ChannelSession channel) throws Exception {\n\t\tif (future != null)\n\t\t\tfuture.cancel(true);\n\t}\n\n\tprotected void onExit(int exitValue, @Nullable String errorMessage) {\n\t\tif (errorMessage != null)\n\t\t\tnew PrintStream(err).println(\"ERROR: \" + errorMessage);\n\t\tcallback.onExit(exitValue);\n\t}\n\n\t@Override\n\tpublic void setInputStream(InputStream in) {\n\t\tthis.in = new InputStreamWrapper(in) {\n\n\t\t\t@Override\n\t\t\tpublic void close() throws IOException {\n\t\t\t}\n\t\t\t\n\t\t};\n\t}\n\n\t@Override\n\tpublic void setOutputStream(OutputStream out) {\n\t\tthis.out = new OutputStreamWrapper(out) {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void close() throws IOException {\n\t\t\t}\n\t\t\t\n\t\t};\n\t\t((ChannelOutputStream) out).setNoDelay(true);\n\t}\n\n\t@Override\n\tpublic void setErrorStream(OutputStream err) {\n\t\tthis.err = new OutputStreamWrapper(err) {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void close() throws IOException {\n\t\t\t}\n\t\t\t\n\t\t};\n\t\t((ChannelOutputStream) err).setNoDelay(true);\n\t}\n\n\t@Override\n\tpublic void setExitCallback(ExitCallback callBack) {\n\t\tthis.callback = callBack;\n\t}\n\n\t@Override\n\tpublic void setSession(ServerSession session) {\n\t\tthis.session = session;\n\t}\n\n}", "package io.onedev.server.git;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.annotation.Nullable;\n\nimport org.bouncycastle.bcpg.ArmoredOutputStream;\nimport org.bouncycastle.bcpg.BCPGOutputStream;\nimport org.bouncycastle.bcpg.HashAlgorithmTags;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.openpgp.PGPCompressedData;\nimport org.bouncycastle.openpgp.PGPException;\nimport org.bouncycastle.openpgp.PGPPrivateKey;\nimport org.bouncycastle.openpgp.PGPPublicKey;\nimport org.bouncycastle.openpgp.PGPSecretKeyRing;\nimport org.bouncycastle.openpgp.PGPSignature;\nimport org.bouncycastle.openpgp.PGPSignatureGenerator;\nimport org.bouncycastle.openpgp.PGPSignatureList;\nimport org.bouncycastle.openpgp.PGPSignatureSubpacketGenerator;\nimport org.bouncycastle.openpgp.PGPUtil;\nimport org.bouncycastle.openpgp.jcajce.JcaPGPObjectFactory;\nimport org.bouncycastle.openpgp.operator.jcajce.JcaPGPContentSignerBuilder;\nimport org.bouncycastle.openpgp.operator.jcajce.JcaPGPContentVerifierBuilderProvider;\nimport org.bouncycastle.openpgp.operator.jcajce.JcePBESecretKeyDecryptorBuilder;\nimport org.eclipse.jgit.diff.DiffEntry;\nimport org.eclipse.jgit.diff.DiffEntry.ChangeType;\nimport org.eclipse.jgit.diff.DiffFormatter;\nimport org.eclipse.jgit.diff.RawTextComparator;\nimport org.eclipse.jgit.errors.AmbiguousObjectException;\nimport org.eclipse.jgit.errors.IncorrectObjectTypeException;\nimport org.eclipse.jgit.errors.MissingObjectException;\nimport org.eclipse.jgit.errors.RevisionSyntaxException;\nimport org.eclipse.jgit.lib.AnyObjectId;\nimport org.eclipse.jgit.lib.CommitBuilder;\nimport org.eclipse.jgit.lib.Constants;\nimport org.eclipse.jgit.lib.FileMode;\nimport org.eclipse.jgit.lib.GpgSignature;\nimport org.eclipse.jgit.lib.ObjectBuilder;\nimport org.eclipse.jgit.lib.ObjectId;\nimport org.eclipse.jgit.lib.ObjectInserter;\nimport org.eclipse.jgit.lib.ObjectReader;\nimport org.eclipse.jgit.lib.PersonIdent;\nimport org.eclipse.jgit.lib.RefUpdate;\nimport org.eclipse.jgit.lib.Repository;\nimport org.eclipse.jgit.merge.MergeStrategy;\nimport org.eclipse.jgit.merge.Merger;\nimport org.eclipse.jgit.merge.ResolveMerger;\nimport org.eclipse.jgit.revwalk.RevCommit;\nimport org.eclipse.jgit.revwalk.RevObject;\nimport org.eclipse.jgit.revwalk.RevTag;\nimport org.eclipse.jgit.revwalk.RevWalk;\nimport org.eclipse.jgit.revwalk.RevWalkUtils;\nimport org.eclipse.jgit.revwalk.filter.RevFilter;\nimport org.eclipse.jgit.treewalk.CanonicalTreeParser;\nimport org.eclipse.jgit.treewalk.TreeWalk;\nimport org.eclipse.jgit.treewalk.filter.TreeFilter;\nimport org.eclipse.jgit.util.RawParseUtils;\nimport org.eclipse.jgit.util.SystemReader;\nimport org.eclipse.jgit.util.io.NullOutputStream;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Objects;\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Splitter;\nimport com.google.common.base.Strings;\nimport com.google.common.collect.Iterables;\n\nimport io.onedev.commons.utils.PathUtils;\nimport io.onedev.server.git.command.FetchCommand;\nimport io.onedev.server.git.command.IsAncestorCommand;\nimport io.onedev.server.git.exception.ObsoleteCommitException;\nimport io.onedev.server.git.exception.RefUpdateException;\nimport io.onedev.server.git.signature.SignatureUnverified;\nimport io.onedev.server.git.signature.SignatureVerification;\nimport io.onedev.server.git.signature.SignatureVerificationKey;\nimport io.onedev.server.git.signature.SignatureVerificationKeyLoader;\nimport io.onedev.server.git.signature.SignatureVerified;\nimport io.onedev.server.util.GpgUtils;\n\npublic class GitUtils {\n\n\tpublic static final int SHORT_SHA_LENGTH = 8;\n\t\n\tprivate static final Logger logger = LoggerFactory.getLogger(GitUtils.class);\n\t\n\tpublic static boolean isEmptyPath(String path) {\n\t\treturn Strings.isNullOrEmpty(path) || Objects.equal(path, DiffEntry.DEV_NULL);\n\t}\n\n\tpublic static String abbreviateSHA(String sha, int length) {\n\t\tPreconditions.checkArgument(ObjectId.isId(sha));\n\t\treturn sha.substring(0, length);\n\t}\n\n\tpublic static String abbreviateSHA(String sha) {\n\t\treturn abbreviateSHA(sha, SHORT_SHA_LENGTH);\n\t}\n\n\tpublic static List<DiffEntry> diff(Repository repository, AnyObjectId oldRevId, AnyObjectId newRevId) {\n\t\tList<DiffEntry> diffs = new ArrayList<>();\n\t\ttry (DiffFormatter diffFormatter = new DiffFormatter(NullOutputStream.INSTANCE);\n\t\t\t\tRevWalk revWalk = new RevWalk(repository);\n\t\t\t\tObjectReader reader = repository.newObjectReader();) {\n\t\t\tdiffFormatter.setRepository(repository);\n\t\t\tdiffFormatter.setDetectRenames(true);\n\t\t\tdiffFormatter.setDiffComparator(RawTextComparator.DEFAULT);\n\n\t\t\tCanonicalTreeParser oldTreeParser = new CanonicalTreeParser();\n\t\t\tif (!oldRevId.equals(ObjectId.zeroId()))\n\t\t\t\toldTreeParser.reset(reader, revWalk.parseCommit(oldRevId).getTree());\n\n\t\t\tCanonicalTreeParser newTreeParser = new CanonicalTreeParser();\n\t\t\tif (!newRevId.equals(ObjectId.zeroId()))\n\t\t\t\tnewTreeParser.reset(reader, revWalk.parseCommit(newRevId).getTree());\n\n\t\t\tfor (DiffEntry entry : diffFormatter.scan(oldTreeParser, newTreeParser)) {\n\t\t\t\tif (!Objects.equal(entry.getOldPath(), entry.getNewPath())\n\t\t\t\t\t\t|| !Objects.equal(entry.getOldMode(), entry.getNewMode()) || entry.getOldId() == null\n\t\t\t\t\t\t|| !entry.getOldId().isComplete() || entry.getNewId() == null || !entry.getNewId().isComplete()\n\t\t\t\t\t\t|| !entry.getOldId().equals(entry.getNewId())) {\n\t\t\t\t\tdiffs.add(entry);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\treturn diffs;\n\t}\n\n\t@Nullable\n\tpublic static String getDetailMessage(RevCommit commit) {\n\t\tint start = 0;\n\t\tString fullMessage = commit.getFullMessage();\n\t\twhile (true) {\n\t\t\tint index = fullMessage.indexOf('\\n', start);\n\t\t\tif (index == -1)\n\t\t\t\treturn null;\n\t\t\tstart = index + 1;\n\t\t\tint nextIndex = fullMessage.indexOf('\\n', start);\n\t\t\tif (nextIndex == -1)\n\t\t\t\treturn null;\n\t\t\tstart = nextIndex + 1;\n\t\t\tif (fullMessage.substring(index, nextIndex).trim().length() == 0) {\n\t\t\t\tString detailMessage = fullMessage.substring(start).trim();\n\t\t\t\treturn detailMessage.length() != 0 ? detailMessage : null;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static String getBlobTypeName(int blobType) {\n\t\tif (blobType == FileMode.TYPE_FILE)\n\t\t\treturn \"File\";\n\t\telse if (blobType == FileMode.TYPE_GITLINK)\n\t\t\treturn \"Sub module\";\n\t\telse if (blobType == FileMode.TYPE_SYMLINK)\n\t\t\treturn \"Symbol link\";\n\t\telse\n\t\t\treturn \"Folder\";\n\t}\n\n\tpublic static PersonIdent newPersonIdent(String name, String email, Date when) {\n\t\treturn new PersonIdent(name, email, when.getTime(), SystemReader.getInstance().getTimezone(when.getTime()));\n\t}\n\n\t/**\n\t * Parse the original git raw date to Java date. The raw git date is in unix\n\t * timestamp with timezone like: 1392312299 -0800\n\t * \n\t * @param input the input raw date string\n\t * @return Java date\n\t */\n\tpublic static Date parseRawDate(String input) {\n\t\tString[] pieces = Iterables.toArray(Splitter.on(\" \").split(input), String.class);\n\t\treturn new Date(Long.valueOf(pieces[0]) * 1000L);\n\t}\n\n\t/**\n\t * Parse the raw user information into PersonIdent object, the raw information\n\t * should be in format <code>[name] [<email>] [epoch timezone]</code>, for\n\t * example:\n\t * \n\t * Jacob Thornton <jacobthornton@gmail.com> 1328060294 -0800\n\t * \n\t * @param raw\n\t * @return\n\t */\n\tpublic static @Nullable PersonIdent parsePersonIdent(String raw) {\n\t\tif (Strings.isNullOrEmpty(raw))\n\t\t\treturn null;\n\n\t\tint pos1 = raw.indexOf('<');\n\t\tif (pos1 <= 0)\n\t\t\tthrow new IllegalArgumentException(\"Raw \" + raw);\n\n\t\tString name = raw.substring(0, pos1 - 1);\n\n\t\tint pos2 = raw.indexOf('>');\n\t\tif (pos2 <= 0)\n\t\t\tthrow new IllegalArgumentException(\"Raw \" + raw);\n\n\t\tString time = raw.substring(pos2 + 1).trim();\n\t\tDate when = parseRawDate(time);\n\n\t\tString email = raw.substring(pos1 + 1, pos2 - 1);\n\n\t\treturn newPersonIdent(name, email, when);\n\t}\n\n\tpublic static int comparePath(@Nullable String path1, @Nullable String path2) {\n\t\tList<String> segments1 = splitPath(path1);\n\t\tList<String> segments2 = splitPath(path2);\n\n\t\tint index = 0;\n\t\tfor (String segment1 : segments1) {\n\t\t\tif (index < segments2.size()) {\n\t\t\t\tint result = segment1.compareTo(segments2.get(index));\n\t\t\t\tif (result != 0)\n\t\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t\tif (index < segments2.size())\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\tpublic static List<String> splitPath(@Nullable String path) {\n\t\tList<String> pathSegments;\n\t\tif (path != null)\n\t\t\tpathSegments = Splitter.on(\"/\").omitEmptyStrings().splitToList(path);\n\t\telse\n\t\t\tpathSegments = new ArrayList<>();\n\t\treturn pathSegments;\n\t}\n\n\tpublic static @Nullable String normalizePath(@Nullable String path) {\n\t\tList<String> pathSegments = splitPath(PathUtils.normalizeDots(path));\n\t\tif (!pathSegments.isEmpty())\n\t\t\treturn Joiner.on(\"/\").join(pathSegments);\n\t\telse\n\t\t\treturn null;\n\t}\n\n\t/**\n\t * Convert a git reference name to branch name.\n\t * \n\t * @param refName name of the git reference\n\t * @return name of the branch, or <tt>null</tt> if specified ref does not\n\t *         represent a branch\n\t */\n\tpublic static @Nullable String ref2branch(String refName) {\n\t\tif (refName.startsWith(Constants.R_HEADS))\n\t\t\treturn refName.substring(Constants.R_HEADS.length());\n\t\telse\n\t\t\treturn null;\n\t}\n\n\tpublic static String branch2ref(String branch) {\n\t\treturn Constants.R_HEADS + branch;\n\t}\n\n\t/**\n\t * Convert a git reference name to tag name.\n\t * \n\t * @param refName name of the git reference\n\t * @return name of the tag, or <tt>null</tt> if specified ref does not represent\n\t *         a tag\n\t */\n\tpublic static @Nullable String ref2tag(String refName) {\n\t\tif (refName.startsWith(Constants.R_TAGS))\n\t\t\treturn refName.substring(Constants.R_TAGS.length());\n\t\telse\n\t\t\treturn null;\n\t}\n\n\tpublic static String tag2ref(String tag) {\n\t\treturn Constants.R_TAGS + tag;\n\t}\n\n\tpublic static BlobIdent getOldBlobIdent(DiffEntry diffEntry, String oldRev) {\n\t\tBlobIdent blobIdent;\n\t\tif (diffEntry.getChangeType() != ChangeType.ADD) {\n\t\t\tblobIdent = new BlobIdent(oldRev, diffEntry.getOldPath(), diffEntry.getOldMode().getBits());\n\t\t} else {\n\t\t\tblobIdent = new BlobIdent(oldRev, null, null);\n\t\t}\n\t\treturn blobIdent;\n\t}\n\n\tpublic static BlobIdent getNewBlobIdent(DiffEntry diffEntry, String newRev) {\n\t\tBlobIdent blobIdent;\n\t\tif (diffEntry.getChangeType() != ChangeType.DELETE) {\n\t\t\tblobIdent = new BlobIdent(newRev, diffEntry.getNewPath(), diffEntry.getNewMode().getBits());\n\t\t} else {\n\t\t\tblobIdent = new BlobIdent(newRev, null, null);\n\t\t}\n\t\treturn blobIdent;\n\t}\n\n\t/**\n\t * @return merge base of specified commits, or <tt>null</tt> if two commits do\n\t *         not have related history. In this case, these two commits can not be\n\t *         merged\n\t */\n\t@Nullable\n\tpublic static ObjectId getMergeBase(Repository repository, ObjectId commitId1, ObjectId commitId2) {\n\t\ttry (RevWalk revWalk = new RevWalk(repository)) {\n\t\t\trevWalk.setRevFilter(RevFilter.MERGE_BASE);\n\n\t\t\trevWalk.markStart(revWalk.parseCommit(commitId1));\n\t\t\trevWalk.markStart(revWalk.parseCommit(commitId2));\n\t\t\tRevCommit mergeBase = revWalk.next();\n\t\t\treturn mergeBase != null ? mergeBase.copy() : null;\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\t/**\n\t * @return merge base of specified commits, or <tt>null</tt> if two commits do\n\t *         not have related history. In this case, these two commits can not be\n\t *         merged\n\t */\n\t@Nullable\n\tpublic static ObjectId getMergeBase(Repository repository1, ObjectId commit1, Repository repository2,\n\t\t\tObjectId commit2) {\n\t\tif (repository1.getDirectory() == null || !repository1.getDirectory().equals(repository2.getDirectory())) {\n\t\t\tfetch(repository2, commit2, repository1);\n\t\t}\n\t\treturn GitUtils.getMergeBase(repository1, commit1, commit2);\n\t}\n\n\tpublic static void fetch(Repository fromRepository, ObjectId fromCommit, Repository toRepository) {\n\t\tnew FetchCommand(toRepository.getDirectory(), null)\n\t\t\t\t.from(fromRepository.getDirectory().getAbsolutePath())\n\t\t\t\t.refspec(fromCommit.name())\n\t\t\t\t.force(true)\n\t\t\t\t.quiet(true)\n\t\t\t\t.call();\n\t}\n\n\tpublic static boolean isMergedInto(Repository repository, @Nullable Map<String, String> gitEnvs, ObjectId base,\n\t\t\tObjectId tip) {\n\t\tif (gitEnvs != null && !gitEnvs.isEmpty()) {\n\t\t\tIsAncestorCommand cmd = new IsAncestorCommand(repository.getDirectory(), gitEnvs);\n\t\t\tcmd.ancestor(base.name()).descendant(tip.name());\n\t\t\treturn cmd.call();\n\t\t} else {\n\t\t\ttry (RevWalk revWalk = new RevWalk(repository)) {\n\t\t\t\tRevCommit baseCommit;\n\t\t\t\ttry {\n\t\t\t\t\tbaseCommit = revWalk.parseCommit(base);\n\t\t\t\t} catch (MissingObjectException e) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn revWalk.isMergedInto(baseCommit, revWalk.parseCommit(tip));\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get commit of specified revision id.\n\t * \n\t * @param revWalk\n\t * @param revId\n\t * @return <tt>null</tt> if specified id does not exist or does not represent a\n\t *         commit\n\t */\n\t@Nullable\n\tpublic static RevCommit parseCommit(RevWalk revWalk, ObjectId revId) {\n\t\tRevObject peeled;\n\t\ttry {\n\t\t\tpeeled = revWalk.peel(revWalk.parseAny(revId));\n\t\t\tif (peeled instanceof RevCommit)\n\t\t\t\treturn (RevCommit) peeled;\n\t\t\telse\n\t\t\t\treturn null;\n\t\t} catch (MissingObjectException e) {\n\t\t\treturn null;\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\t@Nullable\n\tpublic static ObjectId resolve(Repository repository, String revision) {\n\t\ttry {\n\t\t\treturn repository.resolve(revision);\n\t\t} catch (RevisionSyntaxException | AmbiguousObjectException | IncorrectObjectTypeException e) {\n\t\t\treturn null;\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\t@Nullable\n\tpublic static ObjectId rebase(Repository repository, ObjectId source, ObjectId target, PersonIdent committer) {\n\t\ttry (RevWalk revWalk = new RevWalk(repository); ObjectInserter inserter = repository.newObjectInserter();) {\n\t\t\tRevCommit sourceCommit = revWalk.parseCommit(source);\n\t\t\tRevCommit targetCommit = revWalk.parseCommit(target);\n\t\t\trevWalk.setRevFilter(RevFilter.NO_MERGES);\n\t\t\tList<RevCommit> commits = RevWalkUtils.find(revWalk, sourceCommit, targetCommit);\n\t\t\tCollections.reverse(commits);\n\t\t\tRevCommit headCommit = targetCommit;\n\t\t\tfor (RevCommit commit : commits) {\n\t\t\t\tResolveMerger merger = (ResolveMerger) MergeStrategy.RECURSIVE.newMerger(repository, true);\n\t\t\t\tmerger.setBase(commit.getParent(0));\n\t\t\t\tif (merger.merge(headCommit, commit)) {\n\t\t\t\t\tif (!headCommit.getTree().getId().equals(merger.getResultTreeId())) {\n\t\t\t\t\t\tif (!commit.getTree().getId().equals(merger.getResultTreeId())\n\t\t\t\t\t\t\t\t|| !commit.getParent(0).equals(headCommit)) {\n\t\t\t\t\t\t\tCommitBuilder commitBuilder = new CommitBuilder();\n\t\t\t\t\t\t\tcommitBuilder.setAuthor(commit.getAuthorIdent());\n\t\t\t\t\t\t\tcommitBuilder.setCommitter(committer);\n\t\t\t\t\t\t\tcommitBuilder.setParentId(headCommit);\n\t\t\t\t\t\t\tcommitBuilder.setMessage(commit.getFullMessage());\n\t\t\t\t\t\t\tcommitBuilder.setTreeId(merger.getResultTreeId());\n\t\t\t\t\t\t\theadCommit = revWalk.parseCommit(inserter.insert(commitBuilder));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\theadCommit = commit;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tinserter.flush();\n\t\t\treturn headCommit.copy();\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\t@Nullable\n\tpublic static ObjectId merge(Repository repository, ObjectId targetCommitId, ObjectId sourceCommitId,\n\t\t\tboolean squash, PersonIdent committer, PersonIdent author, String commitMessage,\n\t\t\tboolean useOursOnConflict) {\n\t\ttry (RevWalk revWalk = new RevWalk(repository); ObjectInserter inserter = repository.newObjectInserter();) {\n\t\t\tRevCommit sourceCommit = revWalk.parseCommit(sourceCommitId);\n\t\t\tRevCommit targetCommit = revWalk.parseCommit(targetCommitId);\n\t\t\tMerger merger;\n\t\t\tif (useOursOnConflict)\n\t\t\t\tmerger = MergeStrategy.OURS.newMerger(repository, true);\n\t\t\telse\n\t\t\t\tmerger = MergeStrategy.RECURSIVE.newMerger(repository, true);\n\t\t\tif (merger.merge(targetCommit, sourceCommit)) {\n\t\t\t\tCommitBuilder mergedCommit = new CommitBuilder();\n\t\t\t\tmergedCommit.setAuthor(author);\n\t\t\t\tmergedCommit.setCommitter(committer);\n\t\t\t\tif (squash)\n\t\t\t\t\tmergedCommit.setParentId(targetCommit);\n\t\t\t\telse\n\t\t\t\t\tmergedCommit.setParentIds(targetCommit, sourceCommit);\n\t\t\t\tmergedCommit.setMessage(commitMessage);\n\t\t\t\tmergedCommit.setTreeId(merger.getResultTreeId());\n\t\t\t\tObjectId mergedCommitId = inserter.insert(mergedCommit);\n\t\t\t\tinserter.flush();\n\t\t\t\treturn mergedCommitId;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tpublic static Collection<String> getChangedFiles(Repository repository, ObjectId oldCommitId,\n\t\t\tObjectId newCommitId) {\n\t\tCollection<String> changedFiles = new HashSet<>();\n\t\ttry (RevWalk revWalk = new RevWalk(repository); TreeWalk treeWalk = new TreeWalk(repository)) {\n\t\t\ttreeWalk.setFilter(TreeFilter.ANY_DIFF);\n\t\t\ttreeWalk.setRecursive(true);\n\t\t\tRevCommit oldCommit = revWalk.parseCommit(oldCommitId);\n\t\t\tRevCommit newCommit = revWalk.parseCommit(newCommitId);\n\t\t\ttreeWalk.addTree(oldCommit.getTree());\n\t\t\ttreeWalk.addTree(newCommit.getTree());\n\t\t\twhile (treeWalk.next()) {\n\t\t\t\tchangedFiles.add(treeWalk.getPathString());\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\treturn changedFiles;\n\t}\n\n\tpublic static boolean isValid(File gitDir) {\n\t\treturn new File(gitDir, \"objects\").exists();\n\t}\n\n\tpublic static RefUpdate getRefUpdate(Repository repository, String refName) {\n\t\ttry {\n\t\t\treturn repository.updateRef(refName);\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tpublic static void updateRef(RefUpdate refUpdate) {\n\t\ttry {\n\t\t\tRefUpdate.Result result = refUpdate.forceUpdate();\n\t\t\tif (result == RefUpdate.Result.LOCK_FAILURE && refUpdate.getExpectedOldObjectId() != null\n\t\t\t\t\t&& !refUpdate.getExpectedOldObjectId().equals(refUpdate.getOldObjectId())) {\n\t\t\t\tthrow new ObsoleteCommitException(refUpdate.getOldObjectId());\n\t\t\t} else if (result != RefUpdate.Result.FAST_FORWARD && result != RefUpdate.Result.FORCED\n\t\t\t\t\t&& result != RefUpdate.Result.NEW && result != RefUpdate.Result.NO_CHANGE) {\n\t\t\t\tthrow new RefUpdateException(result);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tpublic static void deleteRef(RefUpdate refUpdate) {\n\t\ttry {\n\t\t\trefUpdate.setForceUpdate(true);\n\t\t\tRefUpdate.Result result = refUpdate.delete();\n\t\t\tif (result == RefUpdate.Result.LOCK_FAILURE && refUpdate.getExpectedOldObjectId() != null\n\t\t\t\t\t&& !refUpdate.getExpectedOldObjectId().equals(refUpdate.getOldObjectId())) {\n\t\t\t\tthrow new ObsoleteCommitException(refUpdate.getOldObjectId());\n\t\t\t} else if (result != RefUpdate.Result.FAST_FORWARD && result != RefUpdate.Result.FORCED\n\t\t\t\t\t&& result != RefUpdate.Result.NEW && result != RefUpdate.Result.NO_CHANGE) {\n\t\t\t\tthrow new RefUpdateException(result);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tpublic static void linkRef(RefUpdate refUpdate, String target) {\n\t\ttry {\n\t\t\tRefUpdate.Result result = refUpdate.link(target);\n\t\t\tif (result != RefUpdate.Result.FORCED && result != RefUpdate.Result.NEW\n\t\t\t\t\t&& result != RefUpdate.Result.NO_CHANGE)\n\t\t\t\tthrow new RefUpdateException(result);\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\t\n\tpublic static void sign(ObjectBuilder object, PGPSecretKeyRing signingKey) {\n\t\tJcePBESecretKeyDecryptorBuilder decryptorBuilder = new JcePBESecretKeyDecryptorBuilder()\n\t\t\t\t.setProvider(BouncyCastleProvider.PROVIDER_NAME);\n\t\tPGPPrivateKey privateKey;\n\t\ttry {\n\t\t\tprivateKey = signingKey.getSecretKey().extractPrivateKey(\n\t\t\t\t\tdecryptorBuilder.build(new char[0]));\n\t\t} catch (PGPException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\t\n\t\tPGPPublicKey publicKey = signingKey.getPublicKey();\n\t\t\n\t\tPGPSignatureGenerator signatureGenerator = new PGPSignatureGenerator(\n\t\t\t\tnew JcaPGPContentSignerBuilder(publicKey.getAlgorithm(), HashAlgorithmTags.SHA256)\n\t\t\t\t\t\t.setProvider(BouncyCastleProvider.PROVIDER_NAME));\n\t\ttry {\n\t\t\tsignatureGenerator.init(PGPSignature.BINARY_DOCUMENT, privateKey);\n\t\t\tPGPSignatureSubpacketGenerator subpackets = new PGPSignatureSubpacketGenerator();\n\t\t\tsubpackets.setIssuerFingerprint(false, publicKey);\n\t\t\t\n\t\t\tString emailAddress = GpgUtils.getEmailAddress(publicKey.getUserIDs().next());\n\t\t\tsubpackets.addSignerUserID(false, emailAddress);\n\t\t\t\n\t\t\tsignatureGenerator.setHashedSubpackets(subpackets.generate());\n\t\t\tByteArrayOutputStream buffer = new ByteArrayOutputStream();\n\t\t\ttry (BCPGOutputStream out = new BCPGOutputStream(new ArmoredOutputStream(buffer))) {\n\t\t\t\tsignatureGenerator.update(object.build());\n\t\t\t\tsignatureGenerator.generate().encode(out);\n\t\t\t}\n\t\t\tobject.setGpgSignature(new GpgSignature(buffer.toByteArray()));\t\t\n\t\t} catch (IOException | PGPException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\t\n\t@Nullable\n\tpublic static SignatureVerification verifyTagSignature(byte[] raw, \n\t\t\tSignatureVerificationKeyLoader keyLoader) {\n\t\tbyte[] signatureData = TagParser.getRawGpgSignature(raw); \n\t\tif (signatureData == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// The signature is just tacked onto the end of the message, which\n\t\t// is last in the buffer.\n\t\tbyte[] data = Arrays.copyOfRange(raw, 0, raw.length - signatureData.length);\n\t\t\n\t\tPersonIdent taggerIdent = TagParser.getTaggerIdent(raw);\n\t\tif (taggerIdent == null)\n\t\t\treturn null;\n\t\t\n\t\treturn verify(data, signatureData, taggerIdent.getEmailAddress(), keyLoader);\n\t}\n\t\n\t/*\n\t * Most logic here is copied from JGit\n\t */\n\t@Nullable\n\tpublic static SignatureVerification verifyCommitSignature(byte[] raw, \n\t\t\tSignatureVerificationKeyLoader keyLoader) {\n\t\tbyte[] header = {'g', 'p', 'g', 's', 'i', 'g'};\n\t\tint start = RawParseUtils.headerStart(header, raw, 0);\n\t\tif (start < 0)\n\t\t\treturn null;\n\t\tint end = RawParseUtils.headerEnd(raw, start);\n\t\tbyte[] signatureData = Arrays.copyOfRange(raw, start, end);\n\t\t\n\t\t// start is at the beginning of the header's content\n\t\tstart -= header.length + 1;\n\t\t// end is on the terminating LF; we need to skip that, too\n\t\tif (end < raw.length) {\n\t\t\tend++;\n\t\t}\n\t\tbyte[] data = new byte[raw.length - (end - start)];\n\t\tSystem.arraycopy(raw, 0, data, 0, start);\n\t\tSystem.arraycopy(raw, end, data, start, raw.length - end);\n\n\t\tint nameB = RawParseUtils.committer(raw, 0);\n\t\tif (nameB < 0)\n\t\t\treturn null;\n\t\tPersonIdent committerIdent = RawParseUtils.parsePersonIdent(raw, nameB);\n\t\tString emailAddress = committerIdent.getEmailAddress();\n\t\treturn verify(data, signatureData, emailAddress, keyLoader);\n\t}\n\t\n\t@Nullable\n\tpublic static SignatureVerification verifySignature(RevObject object, SignatureVerificationKeyLoader keyLoader) {\n\t\tif (object instanceof RevCommit) {\n\t\t\tRevCommit commit = (RevCommit) object;\n\t\t\treturn verifyCommitSignature(commit.getRawBuffer(), keyLoader);\n\t\t} else if (object instanceof RevTag) {\n\t\t\tRevTag tag = (RevTag) object;\n\t\t\treturn verifyTagSignature(tag.getRawBuffer(), keyLoader);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate static PGPSignature parseSignature(InputStream in) throws IOException, PGPException {\n\t\ttry (InputStream sigIn = PGPUtil.getDecoderStream(in)) {\n\t\t\tJcaPGPObjectFactory pgpFactory = new JcaPGPObjectFactory(sigIn);\n\t\t\tObject obj = pgpFactory.nextObject();\n\t\t\tif (obj instanceof PGPCompressedData) {\n\t\t\t\tobj = new JcaPGPObjectFactory(((PGPCompressedData) obj).getDataStream()).nextObject();\n\t\t\t}\n\t\t\tif (obj instanceof PGPSignatureList) {\n\t\t\t\treturn ((PGPSignatureList) obj).get(0);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@Nullable\n\tprivate static SignatureVerification verify(byte[] data, byte[] signatureData, String dataWriter, \n\t\t\tSignatureVerificationKeyLoader keyLoader) {\n\t\ttry (InputStream sigIn = new ByteArrayInputStream(signatureData)) {\n\t\t\tPGPSignature signature = parseSignature(sigIn);\n\t\t\tif (signature != null) {\n\t\t\t\tSignatureVerificationKey key = keyLoader.getSignatureVerificationKey(signature.getKeyID());\n\t\t\t\tif (key != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tsignature.init(\n\t\t\t\t\t\t\t\tnew JcaPGPContentVerifierBuilderProvider().setProvider(BouncyCastleProvider.PROVIDER_NAME),\n\t\t\t\t\t\t\t\tkey.getPublicKey());\n\t\t\t\t\t\tsignature.update(data);\n\t\t\t\t\t\tif (signature.verify()) {\n\t\t\t\t\t\t\tif (!key.shouldVerifyDataWriter() || key.getEmailAddress().equals(dataWriter)) \n\t\t\t\t\t\t\t\treturn new SignatureVerified(key);\n\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\treturn new SignatureUnverified(key, \"Email address of signing key and committer is different\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn new SignatureUnverified(key, \"Invalid commit signature\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (PGPException e) {\n\t\t\t\t\t\tlogger.error(\"Commit signature verification failed\", e);\n\t\t\t\t\t\treturn new SignatureUnverified(key, \"Signature verification failed\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn new SignatureUnverified(null, \"Signature is signed with an unknown key \"\n\t\t\t\t\t\t\t+ \"(key ID: \" + GpgUtils.getKeyIDString(signature.getKeyID()) + \")\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn new SignatureUnverified(null, \"Signature does not decode into a signature object\");\n\t\t\t}\n\t\t} catch (PGPException e) {\n\t\t\tlogger.error(\"Error parsing commit signature\", e);\n\t\t\treturn new SignatureUnverified(null, \"Signature cannot be parsed\");\n\t\t} catch (IOException e2) {\n\t\t\tthrow new RuntimeException(e2);\n\t\t}\n\t}\n\t\n\t/*\n\t * Copied from JGit\n\t */\n\tprivate static class TagParser {\n\t\t\n\t\tprivate static final byte[] hSignature = Constants.encodeASCII(\"-----BEGIN PGP SIGNATURE-----\");\n\n\t\tprivate static int nextStart(byte[] prefix, byte[] buffer, int from) {\n\t\t\tint stop = buffer.length - prefix.length + 1;\n\t\t\tint ptr = from;\n\t\t\tif (ptr > 0) {\n\t\t\t\tptr = RawParseUtils.nextLF(buffer, ptr - 1);\n\t\t\t}\n\t\t\twhile (ptr < stop) {\n\t\t\t\tint lineStart = ptr;\n\t\t\t\tboolean found = true;\n\t\t\t\tfor (byte element : prefix) {\n\t\t\t\t\tif (element != buffer[ptr++]) {\n\t\t\t\t\t\tfound = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (found) {\n\t\t\t\t\treturn lineStart;\n\t\t\t\t}\n\t\t\t\tdo {\n\t\t\t\t\tptr = RawParseUtils.nextLF(buffer, ptr);\n\t\t\t\t} while (ptr < stop && buffer[ptr] == '\\n');\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\n\t\tprivate static int getSignatureStart(byte[] raw) {\n\t\t\tint msgB = RawParseUtils.tagMessage(raw, 0);\n\t\t\tif (msgB < 0) {\n\t\t\t\treturn msgB;\n\t\t\t}\n\t\t\t// Find the last signature start and return the rest\n\t\t\tint start = nextStart(hSignature, raw, msgB);\n\t\t\tif (start < 0) {\n\t\t\t\treturn start;\n\t\t\t}\n\t\t\tint next = RawParseUtils.nextLF(raw, start);\n\t\t\twhile (next < raw.length) {\n\t\t\t\tint newStart = nextStart(hSignature, raw, next);\n\t\t\t\tif (newStart < 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstart = newStart;\n\t\t\t\tnext = RawParseUtils.nextLF(raw, start);\n\t\t\t}\n\t\t\treturn start;\n\t\t}\n\t\t\n\t\tprivate static byte[] getRawGpgSignature(byte[] raw) {\n\t\t\tint start = getSignatureStart(raw);\n\t\t\tif (start < 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn Arrays.copyOfRange(raw, start, raw.length);\n\t\t}\n\n\t\tprivate static PersonIdent getTaggerIdent(byte[] raw) {\n\t\t\tint nameB = RawParseUtils.tagger(raw, 0);\n\t\t\tif (nameB < 0)\n\t\t\t\treturn null;\n\t\t\treturn RawParseUtils.parsePersonIdent(raw, nameB);\n\t\t}\n\t\t\n\t}\n\t\n}\n", "package io.onedev.server.git.hookcallback;\r\n\r\nimport java.io.IOException;\r\nimport java.net.InetAddress;\r\nimport java.util.ArrayList;\r\nimport java.util.Enumeration;\r\nimport java.util.List;\r\n\r\nimport javax.inject.Inject;\r\nimport javax.inject.Singleton;\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\n\r\nimport org.apache.commons.lang3.tuple.ImmutableTriple;\r\nimport org.apache.shiro.util.ThreadContext;\r\nimport org.eclipse.jgit.lib.ObjectId;\r\nimport org.eclipse.jgit.lib.RefUpdate;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\n\r\nimport com.google.common.base.Preconditions;\r\n\r\nimport io.onedev.commons.loader.ListenerRegistry;\r\nimport io.onedev.commons.utils.StringUtils;\r\nimport io.onedev.server.entitymanager.ProjectManager;\r\nimport io.onedev.server.event.RefUpdated;\r\nimport io.onedev.server.git.GitUtils;\r\nimport io.onedev.server.model.Project;\r\nimport io.onedev.server.persistence.SessionManager;\r\nimport io.onedev.server.persistence.annotation.Sessional;\r\nimport io.onedev.server.security.SecurityUtils;\r\n\r\n@SuppressWarnings(\"serial\")\r\n@Singleton\r\npublic class GitPostReceiveCallback extends HttpServlet {\r\n\r\n\tprivate static final Logger logger = LoggerFactory.getLogger(GitPostReceiveCallback.class);\r\n\t\r\n    public static final String PATH = \"/git-postreceive-callback\";\r\n    \r\n    private final ProjectManager projectManager;\r\n\r\n    private final ListenerRegistry listenerRegistry;\r\n    \r\n    private final SessionManager sessionManager;\r\n    \r\n    @Inject\r\n    public GitPostReceiveCallback(ProjectManager projectManager, SessionManager sessionManager, ListenerRegistry listenerRegistry) {\r\n    \tthis.projectManager = projectManager;\r\n    \tthis.sessionManager = sessionManager;\r\n        this.listenerRegistry = listenerRegistry;\r\n    }\r\n\r\n    @Sessional\r\n    @Override\r\n\tprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        String clientIp = request.getHeader(\"X-Forwarded-For\");\r\n        if (clientIp == null) clientIp = request.getRemoteAddr();\r\n\r\n        if (!InetAddress.getByName(clientIp).isLoopbackAddress()) {\r\n            response.sendError(HttpServletResponse.SC_FORBIDDEN,\r\n                    \"Git hook callbacks can only be accessed from localhost.\");\r\n            return;\r\n        }\r\n\r\n        List<String> fields = StringUtils.splitAndTrim(request.getPathInfo(), \"/\");\r\n        Preconditions.checkState(fields.size() == 2);\r\n        \r\n        Project project = projectManager.load(Long.valueOf(fields.get(0)));\r\n        Long userId = Long.valueOf(fields.get(1));\r\n        ThreadContext.bind(SecurityUtils.asSubject(userId));\r\n\r\n        String refUpdateInfo = null;\r\n        Enumeration<String> paramNames = request.getParameterNames();\r\n        while (paramNames.hasMoreElements()) {\r\n        \tString paramName = paramNames.nextElement();\r\n        \tif (paramName.contains(\" \")) {\r\n        \t\trefUpdateInfo = paramName;\r\n        \t} \r\n        }\r\n        Preconditions.checkState(refUpdateInfo != null, \"Git ref update information is not available\");\r\n\r\n\t\tOutput output = new Output(response.getOutputStream());\r\n        \r\n        /*\r\n         * If multiple refs are updated, the hook stdin will put each ref update info into\r\n         * a separate line, however the line breaks is omitted when forward the hook stdin\r\n         * to curl via \"@-\", below logic is used to parse these info correctly even \r\n         * without line breaks.  \r\n         */\r\n        refUpdateInfo = StringUtils.reverse(StringUtils.remove(refUpdateInfo, '\\n'));\r\n        \r\n        fields.clear();\r\n        fields.addAll(StringUtils.splitAndTrim(refUpdateInfo, \" \"));\r\n\r\n        List<ImmutableTriple<String, ObjectId, ObjectId>> eventData = new ArrayList<>();\r\n        \r\n        int pos = 0;\r\n        while (true) {\r\n        \tString refName = StringUtils.reverse(fields.get(pos));\r\n        \tpos++;\r\n        \tObjectId newObjectId = ObjectId.fromString(StringUtils.reverse(fields.get(pos)));\r\n        \tpos++;\r\n        \tString field = fields.get(pos);\r\n        \tObjectId oldObjectId = ObjectId.fromString(StringUtils.reverse(field.substring(0, 40)));\r\n        \t\r\n        \tString branch = GitUtils.ref2branch(refName);\r\n        \tif (branch != null && project.getDefaultBranch() == null) {\r\n        \t\tRefUpdate refUpdate = GitUtils.getRefUpdate(project.getRepository(), \"HEAD\");\r\n        \t\tGitUtils.linkRef(refUpdate, refName);\r\n        \t}\r\n\r\n        \tif (branch != null && project.getDefaultBranch() != null && !branch.equals(project.getDefaultBranch()))\r\n        \t\tshowPullRequestLink(output, project, branch);\r\n        \t\r\n        \teventData.add(new ImmutableTriple<>(refName, oldObjectId, newObjectId));\r\n    \t\t\r\n        \tfield = field.substring(40);\r\n        \tif (field.length() == 0)\r\n        \t\tbreak;\r\n        \telse\r\n        \t\tfields.set(pos, field);\r\n        }\r\n        \r\n        Long projectId = project.getId();\r\n        \r\n        sessionManager.runAsync(new Runnable() {\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic void run() {\r\n\t\t        try {\r\n\t\t        \t// We can not use a hibernate entity safely in a different thread. Let's reload it \r\n\t\t            Project project = projectManager.load(projectId);\r\n\r\n\t\t            for (ImmutableTriple<String, ObjectId, ObjectId> each: eventData) {\r\n\t\t            \tString refName = each.getLeft();\r\n\t\t            \tObjectId oldObjectId = each.getMiddle();\r\n\t\t            \tObjectId newObjectId = each.getRight();\r\n\t\t\t        \tif (!newObjectId.equals(ObjectId.zeroId()))\r\n\t\t\t        \t\tproject.cacheObjectId(refName, newObjectId);\r\n\t\t\t        \telse \r\n\t\t\t        \t\tproject.cacheObjectId(refName, null);\r\n\t\t            \t\r\n\t\t\t        \tlistenerRegistry.post(new RefUpdated(project, refName, oldObjectId, newObjectId));\r\n\t\t            }\r\n\t\t        } catch (Exception e) {\r\n\t\t        \tlogger.error(\"Error posting ref updated event\", e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n        \t\r\n        });\r\n\t}\r\n\r\n\tprivate void showPullRequestLink(Output output, Project project, String branch) {\r\n    \toutput.writeLine();\r\n    \toutput.writeLine(\"Create a pull request for '\"+ branch +\"' by visiting:\");\r\n\t\toutput.writeLine(\"    \" + project.getUrl() \r\n\t\t\t\t+\"/pulls/new?target=\" \r\n\t\t\t\t+ project.getId() \r\n\t\t\t\t+ \":\" \r\n\t\t\t\t+ project.getDefaultBranch() \r\n\t\t\t\t+ \"&source=\" \r\n\t\t\t\t+ project.getId()\r\n\t\t\t\t+ \":\"\r\n\t\t\t\t+ branch);\r\n\t\toutput.writeLine();\r\n\t}\r\n\t\r\n}\r\n", "package io.onedev.server.git.hookcallback;\n\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.annotation.Nullable;\nimport javax.inject.Inject;\nimport javax.inject.Singleton;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.eclipse.jgit.lib.Constants;\nimport org.eclipse.jgit.lib.ObjectId;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.Lists;\n\nimport io.onedev.commons.utils.ExplicitException;\nimport io.onedev.commons.utils.StringUtils;\nimport io.onedev.server.entitymanager.ProjectManager;\nimport io.onedev.server.git.GitUtils;\nimport io.onedev.server.model.Project;\nimport io.onedev.server.model.PullRequest;\nimport io.onedev.server.model.PullRequestUpdate;\nimport io.onedev.server.model.User;\nimport io.onedev.server.model.support.BranchProtection;\nimport io.onedev.server.model.support.TagProtection;\nimport io.onedev.server.persistence.annotation.Sessional;\nimport io.onedev.server.security.SecurityUtils;\nimport io.onedev.server.security.permission.ManageProject;\nimport io.onedev.server.security.permission.ProjectPermission;\n\n@SuppressWarnings(\"serial\")\n@Singleton\npublic class GitPreReceiveCallback extends HttpServlet {\n\n\tpublic static final String PATH = \"/git-prereceive-callback\";\n\n\tprivate final ProjectManager projectManager;\n\t\n\t@Inject\n\tpublic GitPreReceiveCallback(ProjectManager projectManager) {\n\t\tthis.projectManager = projectManager;\n\t}\n\t\n\tprivate void error(Output output, @Nullable String refName, List<String> messages) {\n\t\toutput.markError();\n\t\toutput.writeLine();\n\t\toutput.writeLine(\"*******************************************************\");\n\t\toutput.writeLine(\"*\");\n\t\tif (refName != null)\n\t\t\toutput.writeLine(\"*  ERROR PUSHING REF: \" + refName);\n\t\telse\n\t\t\toutput.writeLine(\"*  ERROR PUSHING\");\n\t\toutput.writeLine(\"-------------------------------------------------------\");\n\t\tfor (String message: messages)\n\t\t\toutput.writeLine(\"*  \" + message);\n\t\toutput.writeLine(\"*\");\n\t\toutput.writeLine(\"*******************************************************\");\n\t\toutput.writeLine();\n\t}\n\t\n\t@Sessional\n\t@Override\n\tprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String clientIp = request.getHeader(\"X-Forwarded-For\");\n        if (clientIp == null) clientIp = request.getRemoteAddr();\n\n        if (!InetAddress.getByName(clientIp).isLoopbackAddress()) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN,\n                    \"Git hook callbacks can only be accessed from localhost.\");\n            return;\n        }\n        \n        List<String> fields = StringUtils.splitAndTrim(request.getPathInfo(), \"/\");\n        Preconditions.checkState(fields.size() == 2);\n        \n        SecurityUtils.getSubject().runAs(SecurityUtils.asPrincipal(Long.valueOf(fields.get(1))));\n        try {\n            Project project = projectManager.load(Long.valueOf(fields.get(0)));\n            \n            String refUpdateInfo = null;\n            \n            /*\n             * Since git 2.11, pushed commits will be placed in to a QUARANTINE directory when pre-receive hook \n             * is fired. Current version of jgit does not pick up objects in this directory so we should call \n             * native git instead with various environments passed from pre-receive hook   \n             */\n            Map<String, String> gitEnvs = new HashMap<>();\n            Enumeration<String> paramNames = request.getParameterNames();\n            while (paramNames.hasMoreElements()) {\n            \tString paramName = paramNames.nextElement();\n            \tif (paramName.contains(\" \")) {\n            \t\trefUpdateInfo = paramName;\n            \t} else if (paramName.startsWith(\"ENV_\")) {\n            \t\tString paramValue = request.getParameter(paramName);\n            \t\tif (StringUtils.isNotBlank(paramValue))\n            \t\t\tgitEnvs.put(paramName.substring(\"ENV_\".length()), paramValue);\n            \t}\n            }\n            \n            Preconditions.checkState(refUpdateInfo != null, \"Git ref update information is not available\");\n            \n\t        Output output = new Output(response.getOutputStream());\n\t        \n\t        /*\n\t         * If multiple refs are updated, the hook stdin will put each ref update info into\n\t         * a separate line, however the line breaks is omitted when forward the hook stdin\n\t         * to curl via \"@-\", below logic is used to parse these info correctly even \n\t         * without line breaks.  \n\t         */\n\t        refUpdateInfo = StringUtils.reverse(StringUtils.remove(refUpdateInfo, '\\n'));\n\t        fields = StringUtils.splitAndTrim(refUpdateInfo, \" \");\n\t        \n\t        int pos = 0;\n\t        while (true) {\n\t        \tString refName = StringUtils.reverse(fields.get(pos));\n\t        \tpos++;\n\t        \tObjectId newObjectId = ObjectId.fromString(StringUtils.reverse(fields.get(pos)));\n\t        \tpos++;\n\t        \tString field = fields.get(pos);\n\t        \tObjectId oldObjectId = ObjectId.fromString(StringUtils.reverse(field.substring(0, 40)));\n\t        \t\n\t    \t\tUser user = Preconditions.checkNotNull(SecurityUtils.getUser());\n\n\t    \t\tif (refName.startsWith(PullRequest.REFS_PREFIX) || refName.startsWith(PullRequestUpdate.REFS_PREFIX)) {\n\t    \t\t\tif (!user.asSubject().isPermitted(new ProjectPermission(project, new ManageProject()))) {\n\t    \t\t\t\terror(output, refName, Lists.newArrayList(\"Only project administrators can update onedev refs.\"));\n\t    \t\t\t\tbreak;\n\t    \t\t\t}\n\t    \t\t} else if (refName.startsWith(Constants.R_HEADS)) {\n\t    \t\t\tString branchName = Preconditions.checkNotNull(GitUtils.ref2branch(refName));\n\t    \t\t\tList<String> errorMessages = new ArrayList<>();\n\t    \t\t\tBranchProtection protection = project.getHierarchyBranchProtection(branchName, user);\n\t\t\t\t\tif (oldObjectId.equals(ObjectId.zeroId())) {\n\t\t\t\t\t\tif (protection.isPreventCreation()) {\n\t\t\t\t\t\t\terrorMessages.add(\"Can not create this branch according to branch protection setting\");\n\t\t\t\t\t\t} else if (protection.isSignatureRequired() \n\t\t\t\t\t\t\t\t&& !project.hasValidCommitSignature(newObjectId, gitEnvs)) {\n\t\t\t\t\t\t\terrorMessages.add(\"Can not create this branch as branch protection setting \"\n\t\t\t\t\t\t\t\t\t+ \"requires valid signature on head commit\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (newObjectId.equals(ObjectId.zeroId())) {\n\t\t\t\t\t\tif (protection.isPreventDeletion()) \n\t\t\t\t\t\t\terrorMessages.add(\"Can not delete this branch according to branch protection setting\");\n\t\t\t\t\t} else if (protection.isPreventForcedPush() \n\t\t\t\t\t\t\t&& !GitUtils.isMergedInto(project.getRepository(), gitEnvs, oldObjectId, newObjectId)) {\n\t\t\t\t\t\terrorMessages.add(\"Can not force-push to this branch according to branch protection setting\");\n\t\t\t\t\t} else if (protection.isSignatureRequired() \n\t\t\t\t\t\t\t&& !project.hasValidCommitSignature(newObjectId, gitEnvs)) {\n\t\t\t\t\t\terrorMessages.add(\"Can not push to this branch as branch protection rule requires \"\n\t\t\t\t\t\t\t\t+ \"valid signature for head commit\");\n\t\t\t\t\t} else if (protection.isReviewRequiredForPush(user, project, branchName, oldObjectId, newObjectId, gitEnvs)) {\n    \t\t\t\t\terrorMessages.add(\"Review required for your change. Please submit pull request instead\");\n\t\t\t\t\t}\n\t    \t\t\tif (errorMessages.isEmpty() \n\t    \t\t\t\t\t&& !oldObjectId.equals(ObjectId.zeroId()) \n\t    \t\t\t\t\t&& !newObjectId.equals(ObjectId.zeroId()) \n\t    \t\t\t\t\t&& project.isBuildRequiredForPush(user, branchName, oldObjectId, newObjectId, gitEnvs)) {\n\t    \t\t\t\terrorMessages.add(\"Build required for your change. Please submit pull request instead\");\n\t    \t\t\t}\n\t    \t\t\tif (errorMessages.isEmpty() && newObjectId.equals(ObjectId.zeroId())) {\n\t    \t\t\t\ttry {\n\t    \t\t\t\t\tprojectManager.onDeleteBranch(project, branchName);\n\t    \t\t\t\t} catch (ExplicitException e) {\n\t    \t\t\t\t\terrorMessages.addAll(Splitter.on(\"\\n\").splitToList(e.getMessage()));\n\t    \t\t\t\t}\n\t    \t\t\t}\n\t\t\t\t\tif (!errorMessages.isEmpty())\n\t\t\t\t\t\terror(output, refName, errorMessages);\n\t    \t\t} else if (refName.startsWith(Constants.R_TAGS)) {\n\t    \t\t\tString tagName = Preconditions.checkNotNull(GitUtils.ref2tag(refName));\n\t    \t\t\tList<String> errorMessages = new ArrayList<>();\n\t    \t\t\tTagProtection protection = project.getHierarchyTagProtection(tagName, user);\n\t\t\t\t\tif (oldObjectId.equals(ObjectId.zeroId())) {\n\t\t\t\t\t\tif (protection.isPreventCreation()) {\n\t\t\t\t\t\t\terrorMessages.add(\"Can not create this tag according to tag protection setting\");\n\t\t\t\t\t\t} else if (protection.isSignatureRequired() \n\t\t\t\t\t\t\t\t&& !project.hasValidTagSignature(newObjectId, gitEnvs)) {\n\t\t\t\t\t\t\terrorMessages.add(\"Can not create this tag as tag protection setting requires \"\n\t\t\t\t\t\t\t\t\t+ \"valid tag signature\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (newObjectId.equals(ObjectId.zeroId())) {\n\t\t\t\t\t\tif (protection.isPreventDeletion())\n\t\t\t\t\t\t\terrorMessages.add(\"Can not delete this tag according to tag protection setting\");\n\t\t\t\t\t} else if (protection.isPreventUpdate()) {\n\t\t\t\t\t\terrorMessages.add(\"Can not update this tag according to tag protection setting\");\n\t\t\t\t\t} else if (protection.isSignatureRequired() \n\t\t\t\t\t\t\t&& !project.hasValidTagSignature(newObjectId, gitEnvs)) {\n\t\t\t\t\t\terrorMessages.add(\"Can not update this tag as tag protection setting requires \"\n\t\t\t\t\t\t\t\t+ \"valid tag signature\");\n\t\t\t\t\t}\n\t    \t\t\tif (errorMessages.isEmpty() && newObjectId.equals(ObjectId.zeroId())) {\n\t    \t\t\t\ttry {\n\t    \t\t\t\t\tprojectManager.onDeleteTag(project, tagName);\n\t    \t\t\t\t} catch (ExplicitException e) {\n\t    \t\t\t\t\terrorMessages.addAll(Splitter.on(\"\\n\").splitToList(e.getMessage()));\n\t    \t\t\t\t}\n\t    \t\t\t}\n\t\t\t\t\tif (!errorMessages.isEmpty())\n\t\t\t\t\t\terror(output, refName, errorMessages);\n\t    \t\t}\n\t    \t\t\n\t        \tfield = field.substring(40);\n\t        \tif (field.length() == 0)\n\t        \t\tbreak;\n\t        \telse\n\t        \t\tfields.set(pos, field);\n\t        }\n        } finally {\n        \tSecurityUtils.getSubject().releaseRunAs();\n        }\t\t\n\t}\t\n}\n", "#!/usr/bin/env bash\nunset http_proxy\nunset https_proxy\nIFS=$'\\r\\n'; \nlines=($(${ONEDEV_CURL} -k -s -S -f -X POST --data-urlencode \"ENV_GIT_ALTERNATE_OBJECT_DIRECTORIES=${GIT_ALTERNATE_OBJECT_DIRECTORIES}\" --data-urlencode \"ENV_GIT_OBJECT_DIRECTORY=${GIT_OBJECT_DIRECTORY}\" --data-urlencode \"ENV_GIT_QUARANTINE_PATH=${GIT_QUARANTINE_PATH}\" -d @- ${ONEDEV_URL}/%s/${ONEDEV_REPOSITORY_ID}/${ONEDEV_USER_ID} 2>&1))\n\nreturnCode=0;\n\nfor i in ${lines[@]}\ndo\n  if [ \"$i\" = \"ERROR\" ]; then \n    returnCode=1\n  else\n    if [[ $i == curl:* ]]; then\n      returnCode=1\n    fi;\n    echo \"$i\"\n  fi;\ndone\n\nexit $returnCode"], "fixing_code": ["package io.onedev.server.entitymanager.impl;\n\nimport static java.util.stream.Collectors.toList;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\n\nimport javax.annotation.Nullable;\nimport javax.inject.Inject;\nimport javax.inject.Singleton;\nimport javax.persistence.criteria.CriteriaBuilder;\nimport javax.persistence.criteria.CriteriaQuery;\nimport javax.persistence.criteria.From;\nimport javax.persistence.criteria.Path;\nimport javax.persistence.criteria.Predicate;\nimport javax.persistence.criteria.Root;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.shiro.authz.Permission;\nimport org.apache.shiro.authz.UnauthorizedException;\nimport org.eclipse.jgit.api.Git;\nimport org.eclipse.jgit.api.errors.GitAPIException;\nimport org.eclipse.jgit.diff.DiffAlgorithm.SupportedAlgorithm;\nimport org.eclipse.jgit.internal.storage.file.FileRepository;\nimport org.eclipse.jgit.lib.ConfigConstants;\nimport org.eclipse.jgit.lib.ObjectId;\nimport org.eclipse.jgit.lib.Repository;\nimport org.eclipse.jgit.lib.StoredConfig;\nimport org.hibernate.Session;\nimport org.hibernate.query.Query;\nimport org.quartz.ScheduleBuilder;\nimport org.quartz.SimpleScheduleBuilder;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.Sets;\n\nimport io.onedev.commons.loader.Listen;\nimport io.onedev.commons.loader.ListenerRegistry;\nimport io.onedev.commons.utils.ExceptionUtils;\nimport io.onedev.commons.utils.FileUtils;\nimport io.onedev.commons.utils.StringUtils;\nimport io.onedev.server.buildspec.job.JobManager;\nimport io.onedev.server.entitymanager.BuildManager;\nimport io.onedev.server.entitymanager.IssueManager;\nimport io.onedev.server.entitymanager.LinkSpecManager;\nimport io.onedev.server.entitymanager.ProjectManager;\nimport io.onedev.server.entitymanager.RoleManager;\nimport io.onedev.server.entitymanager.SettingManager;\nimport io.onedev.server.entitymanager.UserAuthorizationManager;\nimport io.onedev.server.event.ProjectCreated;\nimport io.onedev.server.event.ProjectEvent;\nimport io.onedev.server.event.RefUpdated;\nimport io.onedev.server.event.entity.EntityPersisted;\nimport io.onedev.server.event.entity.EntityRemoved;\nimport io.onedev.server.event.system.SystemStarted;\nimport io.onedev.server.event.system.SystemStopping;\nimport io.onedev.server.git.GitUtils;\nimport io.onedev.server.git.command.CloneCommand;\nimport io.onedev.server.infomanager.CommitInfoManager;\nimport io.onedev.server.model.Build;\nimport io.onedev.server.model.Issue;\nimport io.onedev.server.model.LinkSpec;\nimport io.onedev.server.model.Milestone;\nimport io.onedev.server.model.Project;\nimport io.onedev.server.model.PullRequest;\nimport io.onedev.server.model.User;\nimport io.onedev.server.model.UserAuthorization;\nimport io.onedev.server.model.support.BranchProtection;\nimport io.onedev.server.model.support.TagProtection;\nimport io.onedev.server.persistence.SessionManager;\nimport io.onedev.server.persistence.TransactionManager;\nimport io.onedev.server.persistence.annotation.Sessional;\nimport io.onedev.server.persistence.annotation.Transactional;\nimport io.onedev.server.persistence.dao.BaseEntityManager;\nimport io.onedev.server.persistence.dao.Dao;\nimport io.onedev.server.search.entity.EntityQuery;\nimport io.onedev.server.search.entity.EntitySort;\nimport io.onedev.server.search.entity.EntitySort.Direction;\nimport io.onedev.server.search.entity.issue.IssueQueryUpdater;\nimport io.onedev.server.search.entity.project.ProjectQuery;\nimport io.onedev.server.security.SecurityUtils;\nimport io.onedev.server.security.permission.AccessProject;\nimport io.onedev.server.security.permission.ProjectPermission;\nimport io.onedev.server.util.criteria.Criteria;\nimport io.onedev.server.util.facade.ProjectFacade;\nimport io.onedev.server.util.match.WildcardUtils;\nimport io.onedev.server.util.patternset.PatternSet;\nimport io.onedev.server.util.schedule.SchedulableTask;\nimport io.onedev.server.util.schedule.TaskScheduler;\nimport io.onedev.server.util.usage.Usage;\nimport io.onedev.server.web.avatar.AvatarManager;\n\n@Singleton\npublic class DefaultProjectManager extends BaseEntityManager<Project> \n\t\timplements ProjectManager, SchedulableTask {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(DefaultProjectManager.class);\n\t\n    private final CommitInfoManager commitInfoManager;\n    \n    private final BuildManager buildManager;\n    \n    private final AvatarManager avatarManager;\n    \n    private final SettingManager settingManager;\n    \n    private final SessionManager sessionManager;\n    \n    private final TransactionManager transactionManager;\n    \n    private final IssueManager issueManager;\n    \n    private final LinkSpecManager linkSpecManager;\n    \n    private final JobManager jobManager;\n    \n    private final TaskScheduler taskScheduler;\n    \n    private final ListenerRegistry listenerRegistry;\n    \n    private final RoleManager roleManager;\n    \n    private final UserAuthorizationManager userAuthorizationManager;\n    \n    private final String gitReceiveHook;\n    \n\tprivate final Map<Long, Repository> repositoryCache = new ConcurrentHashMap<>();\n\t\n\tprivate final Map<Long, Date> updateDates = new ConcurrentHashMap<>();\n\t\n\tprivate final Map<Long, ProjectFacade> cache = new HashMap<>();\n\t\n\tprivate final ReadWriteLock cacheLock = new ReentrantReadWriteLock();\n\t\n\tprivate String taskId;\n\t\n    @Inject\n    public DefaultProjectManager(Dao dao, CommitInfoManager commitInfoManager,  \n    \t\tBuildManager buildManager, AvatarManager avatarManager, \n    \t\tSettingManager settingManager, TransactionManager transactionManager, \n    \t\tSessionManager sessionManager, ListenerRegistry listenerRegistry, \n    \t\tTaskScheduler taskScheduler, UserAuthorizationManager userAuthorizationManager, \n    \t\tRoleManager roleManager, JobManager jobManager, IssueManager issueManager, \n    \t\tLinkSpecManager linkSpecManager) {\n    \tsuper(dao);\n    \t\n        this.commitInfoManager = commitInfoManager;\n        this.buildManager = buildManager;\n        this.avatarManager = avatarManager;\n        this.settingManager = settingManager;\n        this.transactionManager = transactionManager;\n        this.sessionManager = sessionManager;\n        this.listenerRegistry = listenerRegistry;\n        this.taskScheduler = taskScheduler;\n        this.userAuthorizationManager = userAuthorizationManager;\n        this.roleManager = roleManager;\n        this.jobManager = jobManager;\n        this.issueManager = issueManager;\n        this.linkSpecManager = linkSpecManager;\n        \n        try (InputStream is = getClass().getClassLoader().getResourceAsStream(\"git-receive-hook\")) {\n        \tPreconditions.checkNotNull(is);\n            gitReceiveHook = StringUtils.join(IOUtils.readLines(is, Charset.defaultCharset()), \"\\n\");\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n\n    }\n    \n    @Override\n    public Repository getRepository(Project project) {\n    \tRepository repository = repositoryCache.get(project.getId());\n    \tif (repository == null) {\n    \t\tsynchronized (repositoryCache) {\n    \t\t\trepository = repositoryCache.get(project.getId());\n    \t\t\tif (repository == null) {\n    \t\t\t\ttry {\n\t\t\t\t\t\trepository = new FileRepository(project.getGitDir());\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t\t}\n    \t\t\t\trepositoryCache.put(project.getId(), repository);\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn repository;\n    }\n    \n    @Transactional\n    @Override\n    public void save(Project project) {\n    \tsave(project, null);\n    }\n    \n    @Transactional\n    @Override\n    public void save(Project project, String oldPath) {\n    \tdao.persist(project);\n    \tif (oldPath != null && !oldPath.equals(project.getPath())) {\n    \t\tCollection<Milestone> milestones = new ArrayList<>();\n    \t\tfor (Milestone milestone: issueManager.queryUsedMilestones(project)) {\n    \t\t\tif (!project.isSelfOrAncestorOf(milestone.getProject()) \n    \t\t\t\t\t&& !milestone.getProject().isSelfOrAncestorOf(project)) {\n    \t\t\t\tmilestones.add(milestone);\n    \t\t\t}\n    \t\t}\n    \t\tissueManager.clearSchedules(project, milestones);\n    \t\tsettingManager.onMoveProject(oldPath, project.getPath());\n    \t\t\n    \t\tfor (LinkSpec link: linkSpecManager.query()) {\n    \t\t\tfor (IssueQueryUpdater updater: link.getQueryUpdaters())\n    \t\t\t\tupdater.onMoveProject(oldPath, project.getPath());\n    \t\t}\n    \t\t\t\n    \t\tscheduleTree(project);\n    \t}\n    }\n    \n    private void scheduleTree(Project project) {\n    \tjobManager.schedule(project);\n    \tfor (Project child: project.getChildren()) \n    \t\tscheduleTree(child);\n    }\n    \n    @Transactional\n    @Override\n    public void create(Project project) {\n    \tProject parent = project.getParent();\n    \tif (parent != null && parent.isNew())\n    \t\tcreate(parent);\n    \tdao.persist(project);\n       \tcheckSanity(project);\n       \tUserAuthorization authorization = new UserAuthorization();\n       \tauthorization.setProject(project);\n       \tauthorization.setUser(SecurityUtils.getUser());\n       \tauthorization.setRole(roleManager.getOwner());\n       \tuserAuthorizationManager.save(authorization);\n       \tlistenerRegistry.post(new ProjectCreated(project));\n    }\n    \n    @Transactional\n    @Listen\n    public void on(EntityRemoved event) {\n    \tif (event.getEntity() instanceof Project) {\n    \t\tProject project = (Project) event.getEntity();\n    \t\tLong projectId = project.getId();\n    \t\ttransactionManager.runAfterCommit(new Runnable() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tcacheLock.writeLock().lock();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcache.remove(projectId);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tcacheLock.writeLock().unlock();\n\t\t\t\t\t}\n\t\t\t\t}\n    \t\t\t\n    \t\t});\n    \t}\n    }\n    \n    @Transactional\n    @Listen\n    public void on(EntityPersisted event) {\n    \tif (event.getEntity() instanceof Project) {\n    \t\tProjectFacade facade = ((Project) event.getEntity()).getFacade();\n    \t\ttransactionManager.runAfterCommit(new Runnable() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tcacheLock.writeLock().lock();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcache.put(facade.getId(), facade);\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tcacheLock.writeLock().unlock();\n\t\t\t\t\t}\n\t\t\t\t}\n    \t\t\t\n    \t\t});\n    \t}\n    }\n    \n    @Transactional\n    @Override\n    public void delete(Project project) {\n    \tfor (Project child: project.getChildren())\n    \t\tdelete(child);\n    \t\n    \tUsage usage = new Usage();\n    \tusage.add(settingManager.onDeleteProject(project.getPath()));\n    \t\n\t\tfor (LinkSpec link: linkSpecManager.query()) {\n\t\t\tfor (IssueQueryUpdater updater: link.getQueryUpdaters())\n\t\t\t\tusage.add(updater.onDeleteProject(project.getPath()).prefix(\"issue setting\").prefix(\"administration\"));\n\t\t}\n    \t\n    \tusage.checkInUse(\"Project '\" + project.getPath() + \"'\");\n\n    \tfor (Project fork: project.getForks()) {\n    \t\tCollection<Project> descendants = fork.getForkChildren();\n    \t\tdescendants.add(fork);\n    \t\tfor (Project descendant: descendants) {\n            \tQuery<?> query = getSession().createQuery(String.format(\"update Issue set %s=:fork where %s=:descendant\", \n            \t\t\tIssue.PROP_NUMBER_SCOPE, Issue.PROP_PROJECT));\n            \tquery.setParameter(\"fork\", fork);\n            \tquery.setParameter(\"descendant\", descendant);\n            \tquery.executeUpdate();\n            \t\n            \tquery = getSession().createQuery(String.format(\"update Build set %s=:fork where %s=:descendant\", \n            \t\t\tBuild.PROP_NUMBER_SCOPE, Build.PROP_PROJECT));\n            \tquery.setParameter(\"fork\", fork);\n            \tquery.setParameter(\"descendant\", descendant);\n            \tquery.executeUpdate();\n            \t\n            \tquery = getSession().createQuery(String.format(\"update PullRequest set %s=:fork where %s=:descendant\", \n            \t\t\tPullRequest.PROP_NUMBER_SCOPE, PullRequest.PROP_TARGET_PROJECT));\n            \tquery.setParameter(\"fork\", fork);\n            \tquery.setParameter(\"descendant\", descendant);\n            \tquery.executeUpdate();\n    \t\t}\n    \t}\n    \t\n    \tQuery<?> query = getSession().createQuery(String.format(\"update Project set %s=null where %s=:forkedFrom\", \n    \t\t\tProject.PROP_FORKED_FROM, Project.PROP_FORKED_FROM));\n    \tquery.setParameter(\"forkedFrom\", project);\n    \tquery.executeUpdate();\n\n    \tquery = getSession().createQuery(String.format(\"update PullRequest set %s=null where %s=:sourceProject\", \n    \t\t\tPullRequest.PROP_SOURCE_PROJECT, PullRequest.PROP_SOURCE_PROJECT));\n    \tquery.setParameter(\"sourceProject\", project);\n    \tquery.executeUpdate();\n\n    \tfor (Build build: project.getBuilds()) \n    \t\tbuildManager.delete(build);\n    \t\n    \tdao.remove(project);\n    \t\n    \tsynchronized (repositoryCache) {\n\t\t\tRepository repository = repositoryCache.remove(project.getId());\n\t\t\tif (repository != null) \n\t\t\t\trepository.close();\n\t\t}\n    }\n    \n    @Override\n    public Project findByPath(String path) {\n\t\tcacheLock.readLock().lock();\n\t\ttry {\n\t\t\tLong projectId = findProjectId(path);\n\t\t\tif (projectId != null)\n\t\t\t\treturn load(projectId);\n\t\t\telse\n\t\t\t\treturn null;\n\t\t} finally {\n\t\t\tcacheLock.readLock().unlock();\n\t\t}\n    }\n    \n    @Nullable\n    private Long findProjectId(String path) {\n    \tLong projectId = null;\n    \tfor (String name: Splitter.on(\"/\").omitEmptyStrings().trimResults().split(path)) {\n    \t\tprojectId = findProjectId(projectId, name);\n    \t\tif (projectId == null)\n    \t\t\tbreak;\n    \t}\n    \treturn projectId;\n    }\n    \n    @Sessional\n    @Override\n    public Project findByServiceDeskName(String serviceDeskName) {\n\t\tcacheLock.readLock().lock();\n\t\ttry {\n\t\t\tLong projectId = null;\n\t\t\tfor (ProjectFacade facade: cache.values()) {\n\t\t\t\tif (serviceDeskName.equals(facade.getServiceDeskName())) {\n\t\t\t\t\tprojectId = facade.getId();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (projectId != null)\n\t\t\t\treturn load(projectId);\n\t\t\telse\n\t\t\t\treturn null;\n\t\t} finally {\n\t\t\tcacheLock.readLock().unlock();\n\t\t}\n    }\n    \n    @Sessional\n    @Override\n    public Project initialize(String path) {\n    \tList<String> names = Splitter.on(\"/\").omitEmptyStrings().trimResults().splitToList(path);\n    \tProject project = null;\n    \tfor (String name: names) { \n    \t\tProject child;\n    \t\tif (project == null || !project.isNew()) {\n    \t\t\tchild = find(project, name);\n    \t\t\tif (child == null) {\n\t    \t\t\tif (project == null && !SecurityUtils.canCreateRootProjects())\n\t    \t\t\t\tthrow new UnauthorizedException(\"Not authorized to create root project\");\n\t    \t\t\tif (project != null && !SecurityUtils.canCreateChildren(project))\n\t    \t\t\t\tthrow new UnauthorizedException(\"Not authorized to create project under '\" + project.getPath() + \"'\");\n\t    \t\t\tchild = new Project();\n\t    \t\t\tchild.setName(name);\n\t    \t\t\tchild.setParent(project); \n    \t\t\t}\n    \t\t} else {\n    \t\t\tchild = new Project();\n    \t\t\tchild.setName(name);\n    \t\t\tchild.setParent(project);\n    \t\t}\n    \t\tproject = child;\n    \t}\n    \t\n    \tProject parent = project.getParent();\n    \twhile (parent != null && parent.isNew()) {\n    \t\tparent.setCodeManagement(false);\n    \t\tparent.setIssueManagement(false);\n    \t\tparent = parent.getParent();\n    \t}\n    \t\n    \treturn project;\n    }\n    \n    @Sessional\n    @Override\n    public Project find(Project parent, String name) {\n\t\tcacheLock.readLock().lock();\n\t\ttry {\n\t\t\tLong projectId = null;\n\t\t\tfor (ProjectFacade facade: cache.values()) {\n\t\t\t\tif (facade.getName().equalsIgnoreCase(name) && Objects.equals(Project.idOf(parent), facade.getParentId())) {\n\t\t\t\t\tprojectId = facade.getId();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (projectId != null)\n\t\t\t\treturn load(projectId);\n\t\t\telse\n\t\t\t\treturn null;\n\t\t} finally {\n\t\t\tcacheLock.readLock().unlock();\n\t\t}\n    }\n    \n    @Transactional\n\t@Override\n\tpublic void fork(Project from, Project to) {\n    \tProject parent = to.getParent();\n    \tif (parent != null && parent.isNew())\n    \t\tcreate(parent);\n    \t\n    \tdao.persist(to);\n    \t\n       \tUserAuthorization authorization = new UserAuthorization();\n       \tauthorization.setProject(to);\n       \tauthorization.setUser(SecurityUtils.getUser());\n       \tauthorization.setRole(roleManager.getOwner());\n       \tuserAuthorizationManager.save(authorization);\n    \t\n        FileUtils.cleanDir(to.getGitDir());\n        new CloneCommand(to.getGitDir()).mirror(true).from(from.getGitDir().getAbsolutePath()).call();\n        checkSanity(to);\n        commitInfoManager.cloneInfo(from, to);\n        avatarManager.copyAvatar(from, to);\n        \n        if (from.getLfsObjectsDir().exists()) {\n            for (File file: FileUtils.listFiles(from.getLfsObjectsDir(), Sets.newHashSet(\"**\"), Sets.newHashSet())) {\n            \tString objectId = file.getName();\n            \tLock lock = from.getLfsObjectLock(objectId).readLock();\n            \tlock.lock();\n            \ttry {\n            \t\tFileUtils.copyFile(file, to.getLfsObjectFile(objectId));\n            \t} catch (IOException e) {\n            \t\tthrow new RuntimeException(e);\n    \t\t\t} finally {\n            \t\tlock.unlock();\n            \t}\n            }\n        }\n        \n        listenerRegistry.post(new ProjectCreated(to));\n\t}\n    \n    @Transactional\n    @Override\n    public void clone(Project project, String repositoryUrl) {\n    \tProject parent = project.getParent();\n    \tif (parent != null && parent.isNew())\n    \t\tcreate(parent);\n    \t\n    \tdao.persist(project);\n    \t\n    \tUser user = SecurityUtils.getUser();\n       \tUserAuthorization authorization = new UserAuthorization();\n       \tauthorization.setProject(project);\n       \tauthorization.setUser(user);\n       \tauthorization.setRole(roleManager.getOwner());\n       \tproject.getUserAuthorizations().add(authorization);\n       \tuser.getAuthorizations().add(authorization);\n       \tuserAuthorizationManager.save(authorization);\n    \t\n        FileUtils.cleanDir(project.getGitDir());\n        new CloneCommand(project.getGitDir()).mirror(true).from(repositoryUrl).call();\n        checkSanity(project);\n        \n        listenerRegistry.post(new ProjectCreated(project));\n    }\n    \n\tprivate boolean isGitHookValid(File gitDir, String hookName) {\n        File hookFile = new File(gitDir, \"hooks/\" + hookName);\n        if (!hookFile.exists()) \n        \treturn false;\n        \n        try {\n\t\t\tString content = FileUtils.readFileToString(hookFile, Charset.defaultCharset());\n\t\t\tif (!content.contains(\"ONEDEV_HOOK_TOKEN\"))\n\t\t\t\treturn false;\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\t\n        if (!hookFile.canExecute())\n        \treturn false;\n        \n        return true;\n\t}\n\t\n\tprivate void checkSanity(Project project) {\n\t\tFile gitDir = project.getGitDir();\n\t\tif (gitDir.listFiles().length == 0) {\n        \tlogger.info(\"Initializing git repository in '\" + gitDir + \"'...\");\n            try (Git git = Git.init().setDirectory(gitDir).setBare(true).call()) {\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow ExceptionUtils.unchecked(e);\n\t\t\t}\n\t\t} else if (!GitUtils.isValid(gitDir)) {\n        \tlogger.warn(\"Directory '\" + gitDir + \"' is not a valid git repository, reinitializing...\");\n        \tFileUtils.cleanDir(gitDir);\n            try (Git git = Git.init().setDirectory(gitDir).setBare(true).call()) {\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow ExceptionUtils.unchecked(e);\n\t\t\t}\n        } \n\n\t\tif (!isGitHookValid(gitDir, \"pre-receive\") || !isGitHookValid(gitDir, \"post-receive\")) {\n            File hooksDir = new File(gitDir, \"hooks\");\n\n            File gitPreReceiveHookFile = new File(hooksDir, \"pre-receive\");\n            FileUtils.writeFile(gitPreReceiveHookFile, String.format(gitReceiveHook, \"git-prereceive-callback\"));\n            gitPreReceiveHookFile.setExecutable(true);\n            \n            File gitPostReceiveHookFile = new File(hooksDir, \"post-receive\");\n            FileUtils.writeFile(gitPostReceiveHookFile, String.format(gitReceiveHook, \"git-postreceive-callback\"));\n            gitPostReceiveHookFile.setExecutable(true);\n        }\n\n\t\ttry {\n\t\t\tStoredConfig config = project.getRepository().getConfig();\n\t\t\tboolean changed = false;\n\t\t\tif (config.getEnum(ConfigConstants.CONFIG_DIFF_SECTION, null, ConfigConstants.CONFIG_KEY_ALGORITHM, \n\t\t\t\t\tSupportedAlgorithm.MYERS) != SupportedAlgorithm.HISTOGRAM) {\n\t\t\t\tconfig.setEnum(ConfigConstants.CONFIG_DIFF_SECTION, null, ConfigConstants.CONFIG_KEY_ALGORITHM, \n\t\t\t\t\t\tSupportedAlgorithm.HISTOGRAM);\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t\tif (!config.getBoolean(\"uploadpack\", \"allowAnySHA1InWant\", false)) {\n\t\t\t\tconfig.setBoolean(\"uploadpack\", null, \"allowAnySHA1InWant\", true);\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t\tif (changed)\n\t\t\t\tconfig.save();\t\t\t\t\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\t\n\t@Listen\n\tpublic void on(SystemStopping event) {\n\t\ttaskScheduler.unschedule(taskId);\n\t\tsynchronized(repositoryCache) {\n\t\t\tfor (Repository repository: repositoryCache.values()) {\n\t\t\t\trepository.close();\n\t\t\t}\n\t\t}\n\t}\n\n\t@Transactional\n\t@Listen\n\tpublic void on(ProjectEvent event) {\n\t\t/*\n\t\t * Update asynchronously to avoid deadlock \n\t\t */\n\t\tupdateDates.put(event.getProject().getId(), event.getDate());\n\t}\n\t\n\t@Transactional\n\t@Listen(1)\n\tpublic void on(SystemStarted event) {\n\t\tlogger.info(\"Checking projects...\");\n\t\tcacheLock.writeLock().lock();\n\t\ttry {\n\t\t\tfor (Project project: query()) {\n\t\t\t\tcache.put(project.getId(), project.getFacade());\n\t\t\t\tcheckSanity(project);\n\t\t\t}\n\t\t} finally {\n\t\t\tcacheLock.writeLock().unlock();\n\t\t}\n\t\ttaskId = taskScheduler.schedule(this);\n\t}\n\n\t@Transactional\n\t@Override\n\tpublic void onDeleteBranch(Project project, String branchName) {\n\t\tfor (Iterator<BranchProtection> it = project.getBranchProtections().iterator(); it.hasNext();) { \n\t\t\tBranchProtection protection = it.next();\n\t\t\tPatternSet patternSet = PatternSet.parse(protection.getBranches());\n\t\t\tpatternSet.getIncludes().remove(branchName);\n\t\t\tpatternSet.getExcludes().remove(branchName);\n\t\t\tprotection.setBranches(patternSet.toString());\n\t\t\tif (protection.getBranches().length() == 0)\n\t\t\t\tit.remove();\n\t\t}\n\t}\n\t\n\t@Transactional\n\t@Override\n\tpublic void deleteBranch(Project project, String branchName) {\n\t\tonDeleteBranch(project, branchName);\n\n\t\tString refName = GitUtils.branch2ref(branchName);\n    \tObjectId commitId = project.getObjectId(refName, true);\n    \ttry {\n\t\t\tproject.git().branchDelete().setForce(true).setBranchNames(branchName).call();\n\t\t} catch (Exception e) {\n\t\t\tthrow ExceptionUtils.unchecked(e);\n\t\t}\n    \t\n    \tLong projectId = project.getId();\n    \ttransactionManager.runAfterCommit(new Runnable() {\n\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t    \tsessionManager.runAsync(new Runnable() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tProject project = load(projectId);\n\t\t\t\t\t\tlistenerRegistry.post(new RefUpdated(project, refName, commitId, ObjectId.zeroId()));\n\t\t\t\t\t}\n\t\t    \t\t\n\t\t    \t});\n\t\t\t}\n    \t\t\n    \t});\n\t\t\n\t}\n\n\t@Transactional\n\t@Override\n\tpublic void onDeleteTag(Project project, String tagName) {\n\t\tfor (Iterator<TagProtection> it = project.getTagProtections().iterator(); it.hasNext();) { \n\t\t\tTagProtection protection = it.next();\n\t\t\tPatternSet patternSet = PatternSet.parse(protection.getTags());\n\t\t\tpatternSet.getIncludes().remove(tagName);\n\t\t\tpatternSet.getExcludes().remove(tagName);\n\t\t\tprotection.setTags(patternSet.toString());\n\t\t\tif (protection.getTags().length() == 0)\n\t\t\t\tit.remove();\n\t\t}\n\t}\n\t\n\t@Transactional\n\t@Override\n\tpublic void deleteTag(Project project, String tagName) {\n    \tonDeleteTag(project, tagName);\n    \t\n    \tString refName = GitUtils.tag2ref(tagName);\n    \tObjectId commitId = project.getRevCommit(refName, true).getId();\n    \ttry {\n\t\t\tproject.git().tagDelete().setTags(tagName).call();\n\t\t} catch (GitAPIException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\n    \tLong projectId = project.getId();\n    \ttransactionManager.runAfterCommit(new Runnable() {\n\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t    \tsessionManager.runAsync(new Runnable() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\tProject project = load(projectId);\n\t\t\t\t\t\tlistenerRegistry.post(new RefUpdated(project, refName, commitId, ObjectId.zeroId()));\n\t\t\t\t\t}\n\t\t    \t\t\n\t\t    \t});\n\t\t\t}\n    \t\t\n    \t});\n\t}\n\t\n\t@Override\n\tpublic List<Project> query() {\n\t\treturn query(true);\n\t}\n\n\t@Override\n\tpublic int count() {\n\t\treturn count(true);\n\t}\n\t\n\t@Sessional\n\t@Override\n\tpublic Collection<Project> getPermittedProjects(Permission permission) {\n\t\treturn query().stream()\n\t\t\t\t.filter(it->SecurityUtils.getSubject().isPermitted(new ProjectPermission(it, permission)))\n\t\t\t\t.collect(toList());\n\t}\n\n\tprivate CriteriaQuery<Project> buildCriteriaQuery(Session session, EntityQuery<Project> projectQuery) {\n\t\tCriteriaBuilder builder = session.getCriteriaBuilder();\n\t\tCriteriaQuery<Project> query = builder.createQuery(Project.class);\n\t\tRoot<Project> root = query.from(Project.class);\n\t\tquery.select(root);\n\t\t\n\t\tquery.where(getPredicates(projectQuery.getCriteria(), query, root, builder));\n\n\t\tList<javax.persistence.criteria.Order> orders = new ArrayList<>();\n\t\tfor (EntitySort sort: projectQuery.getSorts()) {\n\t\t\tif (sort.getDirection() == Direction.ASCENDING)\n\t\t\t\torders.add(builder.asc(ProjectQuery.getPath(root, Project.ORDER_FIELDS.get(sort.getField()))));\n\t\t\telse\n\t\t\t\torders.add(builder.desc(ProjectQuery.getPath(root, Project.ORDER_FIELDS.get(sort.getField()))));\n\t\t}\n\n\t\tif (orders.isEmpty())\n\t\t\torders.add(builder.desc(ProjectQuery.getPath(root, Project.PROP_UPDATE_DATE)));\n\t\tquery.orderBy(orders);\n\t\t\n\t\treturn query;\n\t}\n\t\n\tprivate Predicate[] getPredicates(@Nullable Criteria<Project> criteria, CriteriaQuery<?> query, \n\t\t\tFrom<Project, Project> from, CriteriaBuilder builder) {\n\t\tList<Predicate> predicates = new ArrayList<>();\n\t\tif (!SecurityUtils.isAdministrator()) {\n\t\t\tCollection<Project> projects = getPermittedProjects(new AccessProject());\n\t\t\tif (!projects.isEmpty())\n\t\t\t\tpredicates.add(getProjectsPredicate(builder, from, projects));\n\t\t\telse\n\t\t\t\tpredicates.add(builder.disjunction());\n\t\t}\n\t\tif (criteria != null) \n\t\t\tpredicates.add(criteria.getPredicate(query, from, builder));\n\t\treturn predicates.toArray(new Predicate[0]);\n\t}\n\t\n\t@Sessional\n\t@Override\n\tpublic List<Project> query(EntityQuery<Project> query, int firstResult, int maxResults) {\n\t\tCriteriaQuery<Project> criteriaQuery = buildCriteriaQuery(getSession(), query);\n\t\tQuery<Project> projectQuery = getSession().createQuery(criteriaQuery);\n\t\tprojectQuery.setFirstResult(firstResult);\n\t\tprojectQuery.setMaxResults(maxResults);\n\t\treturn projectQuery.getResultList();\n\t}\n\n\t@Sessional\n\t@Override\n\tpublic int count(Criteria<Project> projectCriteria) {\n\t\tCriteriaBuilder builder = getSession().getCriteriaBuilder();\n\t\tCriteriaQuery<Long> criteriaQuery = builder.createQuery(Long.class);\n\t\tRoot<Project> root = criteriaQuery.from(Project.class);\n\n\t\tcriteriaQuery.where(getPredicates(projectCriteria, criteriaQuery, root, builder));\n\n\t\tcriteriaQuery.select(builder.count(root));\n\t\treturn getSession().createQuery(criteriaQuery).uniqueResult().intValue();\n\t}\n\n\t@Override\n\tpublic void execute() {\n\t\ttry {\n\t\t\ttransactionManager.run(new Runnable() {\n\t\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tDate now = new Date();\n\t\t\t\t\tfor (Iterator<Map.Entry<Long, Date>> it = updateDates.entrySet().iterator(); it.hasNext();) {\n\t\t\t\t\t\tMap.Entry<Long, Date> entry = it.next();\n\t\t\t\t\t\tif (now.getTime() - entry.getValue().getTime() > 60000) {\n\t\t\t\t\t\t\tProject project = get(entry.getKey());\n\t\t\t\t\t\t\tif (project != null)\n\t\t\t\t\t\t\t\tproject.setUpdateDate(entry.getValue());\n\t\t\t\t\t\t\tit.remove();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t});\n\t\t} catch (Exception e) {\n\t\t\tlogger.error(\"Error flushing project update dates\", e);\n\t\t}\n\t}\n\n\t@Override\n\tpublic ScheduleBuilder<?> getScheduleBuilder() {\n\t\treturn SimpleScheduleBuilder.repeatMinutelyForever();\n\t}\n\t\n\tprivate String getPath(Long id) {\n\t\tProjectFacade facade = cache.get(id);\n\t\tif (facade != null) {\n\t\t\tif (facade.getParentId() != null) {\n\t\t\t\tString parentPath = getPath(facade.getParentId());\n\t\t\t\tif (parentPath != null)\n\t\t\t\t\treturn parentPath + \"/\" + facade.getName();\n\t\t\t\telse\n\t\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\treturn facade.getName();\n\t\t\t}\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate Collection<Long> getMatchingIds(String pathPattern) {\n\t\tCollection<Long> ids = new HashSet<>();\n\t\tfor (Long id: cache.keySet()) {\n\t\t\tString path = getPath(id);\n\t\t\tif (path != null && WildcardUtils.matchPath(pathPattern, path))\n\t\t\t\tids.add(id);\n\t\t}\n\t\treturn ids;\n\t}\n\n\tprivate Collection<Long> getSubtreeIds(Long projectId) {\n\t\tCollection<Long> treeIds = Sets.newHashSet(projectId);\n\t\tfor (ProjectFacade facade: cache.values()) {\n\t\t\tif (projectId.equals(facade.getParentId()))\n\t\t\t\ttreeIds.addAll(getSubtreeIds(facade.getId()));\n\t\t}\n\t\treturn treeIds;\n\t}\n\t\n\t@Override\n\tpublic Predicate getPathMatchPredicate(CriteriaBuilder builder, Path<Project> path, String pathPattern) {\n\t\tcacheLock.readLock().lock();\n\t\ttry {\n\t\t\treturn Criteria.forManyValues(builder, path.get(Project.PROP_ID), \n\t\t\t\t\tgetMatchingIds(pathPattern), cache.keySet());\t\t\n\t\t} finally {\n\t\t\tcacheLock.readLock().unlock();\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic org.apache.lucene.search.Query getPathMatchQuery(String fieldName, String pathPattern) {\n\t\tcacheLock.readLock().lock();\n\t\ttry {\n\t\t\treturn Criteria.forManyValues(fieldName, getMatchingIds(pathPattern), cache.keySet());\t\t\n\t\t} finally {\n\t\t\tcacheLock.readLock().unlock();\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic Predicate getSubtreePredicate(CriteriaBuilder builder, Path<Project> path, Project project) {\n\t\tcacheLock.readLock().lock();\n\t\ttry {\n\t\t\treturn Criteria.forManyValues(builder, path.get(Project.PROP_ID), \n\t\t\t\t\tgetSubtreeIds(project.getId()), cache.keySet());\t\t\n\t\t} finally {\n\t\t\tcacheLock.readLock().unlock();\n\t\t}\n\t}\n\n\t@Override\n\tpublic org.apache.lucene.search.Query getSubtreeQuery(String fieldName, Project project) {\n\t\tcacheLock.readLock().lock();\n\t\ttry {\n\t\t\treturn Criteria.forManyValues(fieldName, getSubtreeIds(project.getId()), cache.keySet());\t\t\n\t\t} finally {\n\t\t\tcacheLock.readLock().unlock();\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic Predicate getProjectsPredicate(CriteriaBuilder builder, Path<Project> path, Collection<Project> projects) {\n\t\tcacheLock.readLock().lock();\n\t\ttry {\n\t\t\treturn Criteria.forManyValues(builder, path.get(Project.PROP_ID), \n\t\t\t\t\tprojects.stream().map(it->it.getId()).collect(toList()), cache.keySet());\t\t\n\t\t} finally {\n\t\t\tcacheLock.readLock().unlock();\n\t\t}\n\t}\n\n\t@Override\n\tpublic org.apache.lucene.search.Query getProjectsQuery(String fieldName, Collection<Project> projects) {\n\t\tcacheLock.readLock().lock();\n\t\ttry {\n\t\t\treturn Criteria.forManyValues(fieldName, projects.stream().map(it->it.getId()).collect(toList()), \n\t\t\t\t\tcache.keySet());\t\t\n\t\t} finally {\n\t\t\tcacheLock.readLock().unlock();\n\t\t}\n\t}\n\t\n\t@Transactional\n\t@Override\n\tpublic void move(Collection<Project> projects, Project parent) {\n\t\tfor (Project project: projects) { \n\t\t\tString oldPath = project.getPath();\n\t\t\tproject.setParent(parent);\n\t\t\tsave(project, oldPath);\n\t\t}\n\t}\n\n\t@Transactional\n\t@Override\n\tpublic void delete(Collection<Project> projects) {\n\t\tCollection<Project> independents = new HashSet<>(projects);\n\t\tfor (Iterator<Project> it = independents.iterator(); it.hasNext();) {\n\t\t\tProject independent = it.next();\n\t\t\tfor (Project each: independents) {\n\t\t\t\tif (!each.equals(independent) && each.isSelfOrAncestorOf(independent)) {\n\t\t\t\t\tit.remove();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (Project independent: independents)\n\t\t\tdelete(independent);\n\t}\n    \n\t@Nullable\n    private Long findProjectId(@Nullable Long parentId, String name) {\n\t\tfor (ProjectFacade facade: cache.values()) {\n\t\t\tif (facade.getName().equalsIgnoreCase(name) && Objects.equals(parentId, facade.getParentId())) \n\t\t\t\treturn facade.getId();\n\t\t}\n\t\treturn null;\n    }\n\n\tprivate int findLongestMatch(@Nullable Long parentId, List<String> pathSegments) {\n\t\tif (!pathSegments.isEmpty()) {\n\t\t\tString name = pathSegments.get(0);\n\t\t\tLong projectId = findProjectId(parentId, name);\n\t\t\tif (projectId != null)\n\t\t\t\treturn findLongestMatch(projectId, pathSegments.subList(1, pathSegments.size())) + 1;\n\t\t\telse\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic int findLongestMatch(List<String> pathSegments) {\n\t\tcacheLock.readLock().lock();\n\t\ttry {\n\t\t\treturn findLongestMatch(null, pathSegments);\n\t\t} finally {\n\t\t\tcacheLock.readLock().unlock();\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic List<ProjectFacade> getChildren(Long projectId) {\n\t\tcacheLock.readLock().lock();\n\t\ttry {\n\t\t\tList<ProjectFacade> children = new ArrayList<>();\n\t\t\tfor (ProjectFacade facade: cache.values()) {\n\t\t\t\tif (projectId.equals(facade.getParentId()))\n\t\t\t\t\tchildren.add(facade);\n\t\t\t}\n\t\t\tCollections.sort(children, new Comparator<ProjectFacade>() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(ProjectFacade o1, ProjectFacade o2) {\n\t\t\t\t\treturn o1.getName().compareTo(o2.getName());\n\t\t\t\t}\n\t\t\t\t\n\t\t\t});\n\t\t\treturn children;\n\t\t} finally {\n\t\t\tcacheLock.readLock().unlock();\n\t\t}\n\t}\n    \n}\n", "package io.onedev.server.git;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport javax.inject.Inject;\nimport javax.inject.Singleton;\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.shiro.authz.UnauthorizedException;\nimport org.eclipse.jgit.http.server.GitSmartHttpTools;\nimport org.eclipse.jgit.http.server.ServletUtils;\nimport org.eclipse.jgit.transport.PacketLineOut;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport io.onedev.commons.utils.command.ErrorCollector;\nimport io.onedev.commons.utils.command.ExecutionResult;\nimport io.onedev.server.OneDev;\nimport io.onedev.server.entitymanager.ProjectManager;\nimport io.onedev.server.entitymanager.SettingManager;\nimport io.onedev.server.exception.SystemNotReadyException;\nimport io.onedev.server.git.command.AdvertiseReceiveRefsCommand;\nimport io.onedev.server.git.command.AdvertiseUploadRefsCommand;\nimport io.onedev.server.git.command.ReceivePackCommand;\nimport io.onedev.server.git.command.UploadPackCommand;\nimport io.onedev.server.git.exception.GitException;\nimport io.onedev.server.model.Project;\nimport io.onedev.server.persistence.SessionManager;\nimport io.onedev.server.security.CodePullAuthorizationSource;\nimport io.onedev.server.security.SecurityUtils;\nimport io.onedev.server.storage.StorageManager;\nimport io.onedev.server.util.InputStreamWrapper;\nimport io.onedev.server.util.OutputStreamWrapper;\nimport io.onedev.server.util.ServerConfig;\nimport io.onedev.server.util.concurrent.PrioritizedRunnable;\nimport io.onedev.server.util.concurrent.WorkExecutor;\n\n@Singleton\npublic class GitFilter implements Filter {\n\t\n\tprivate static final Logger logger = LoggerFactory.getLogger(GitFilter.class);\n\n\tprivate static final int PRIORITY = 2;\n\t\n\tprivate static final String INFO_REFS = \"info/refs\";\n\t\n\tprivate final OneDev oneDev;\n\t\n\tprivate final StorageManager storageManager;\n\t\n\tprivate final ProjectManager projectManager;\n\t\n\tprivate final WorkExecutor workExecutor;\n\t\n\tprivate final ServerConfig serverConfig;\n\t\n\tprivate final SettingManager settingManager;\n\t\n\tprivate final SessionManager sessionManager;\n\t\n\tprivate final Set<CodePullAuthorizationSource> codePullAuthorizationSources;\n\t\n\t@Inject\n\tpublic GitFilter(OneDev oneDev, StorageManager storageManager, ProjectManager projectManager, \n\t\t\tWorkExecutor workExecutor, ServerConfig serverConfig, SettingManager settingManager,\n\t\t\tSessionManager sessionManager, Set<CodePullAuthorizationSource> codePullAuthorizationSources) {\n\t\tthis.oneDev = oneDev;\n\t\tthis.storageManager = storageManager;\n\t\tthis.projectManager = projectManager;\n\t\tthis.workExecutor = workExecutor;\n\t\tthis.serverConfig = serverConfig;\n\t\tthis.settingManager = settingManager;\n\t\tthis.sessionManager = sessionManager;\n\t\tthis.codePullAuthorizationSources = codePullAuthorizationSources;\n\t}\n\t\n\tprivate String getPathInfo(HttpServletRequest request) {\n\t\tString pathInfo = request.getRequestURI().substring(request.getContextPath().length());\n\t\treturn StringUtils.stripStart(pathInfo, \"/\");\n\t}\n\t\n\tprivate Project getProject(HttpServletRequest request, HttpServletResponse response, String projectInfo) \n\t\t\tthrows IOException {\n\t\tString projectPath = StringUtils.strip(projectInfo, \"/\");\n\n\t\tProject project = projectManager.findByPath(projectPath);\n\t\tif (project == null && projectPath.startsWith(\"projects/\")) {\n\t\t\tprojectPath = projectPath.substring(\"projects/\".length());\n\t\t\tproject = projectManager.findByPath(projectPath);\n\t\t}\n\t\tif (project == null) \n\t\t\tthrow new GitException(String.format(\"Unable to find project '%s'\", projectPath));\n\t\treturn project;\n\t}\n\t\n\tprivate void doNotCache(HttpServletResponse response) {\n\t\tresponse.setHeader(\"Expires\", \"Fri, 01 Jan 1980 00:00:00 GMT\");\n\t\tresponse.setHeader(\"Pragma\", \"no-cache\");\n\t\tresponse.setHeader(\"Cache-Control\", \"no-cache, max-age=0, must-revalidate\");\n\t}\n\t\n\tprotected void processPacks(final HttpServletRequest request, final HttpServletResponse response) \n\t\t\tthrows ServletException, IOException, InterruptedException, ExecutionException {\n\t\tFile gitDir;\n\t\tboolean upload;\n\t\tMap<String, String> environments = new HashMap<>();\n\t\t\n\t\tsessionManager.openSession();\n\t\ttry {\n\t\t\tString pathInfo = getPathInfo(request);\n\t\t\t\n\t\t\tString service = StringUtils.substringAfterLast(pathInfo, \"/\");\n\n\t\t\tString projectInfo = StringUtils.substringBeforeLast(pathInfo, \"/\");\n\t\t\tProject project = getProject(request, response, projectInfo);\n\t\t\t\n\t\t\tdoNotCache(response);\n\t\t\tresponse.setHeader(\"Content-Type\", \"application/x-\" + service + \"-result\");\t\t\t\n\n\t\t\tString serverUrl;\n\t        if (serverConfig.getHttpPort() != 0)\n\t            serverUrl = \"http://localhost:\" + serverConfig.getHttpPort();\n\t        else \n\t            serverUrl = \"https://localhost:\" + serverConfig.getHttpsPort();\n\n\t        environments.put(\"ONEDEV_CURL\", settingManager.getSystemSetting().getCurlConfig().getExecutable());\n\t\t\tenvironments.put(\"ONEDEV_URL\", serverUrl);\n\t\t\tenvironments.put(\"ONEDEV_USER_ID\", SecurityUtils.getUserId().toString());\n\t\t\tenvironments.put(\"ONEDEV_HOOK_TOKEN\", GitUtils.HOOK_TOKEN);\n\t\t\tenvironments.put(\"ONEDEV_REPOSITORY_ID\", project.getId().toString());\n\t\t\t\n\t\t\t// to be compatible with old repository\n\t        environments.put(\"GITPLEX_CURL\", settingManager.getSystemSetting().getCurlConfig().getExecutable());\n\t\t\tenvironments.put(\"GITPLEX_URL\", serverUrl);\n\t\t\tenvironments.put(\"GITPLEX_USER_ID\", SecurityUtils.getUserId().toString());\n\t\t\tenvironments.put(\"GITPLEX_REPOSITORY_ID\", project.getId().toString());\n\t\t\t\n\t\t\tgitDir = storageManager.getProjectGitDir(project.getId());\n\n\t\t\tif (GitSmartHttpTools.isUploadPack(request)) {\n\t\t\t\tcheckPullPermission(request, project);\n\t\t\t\tupload = true;\n\t\t\t} else {\n\t\t\t\tif (!SecurityUtils.canWriteCode(project))\n\t\t\t\t\tthrow new UnauthorizedException(\"You do not have permission to push to this project.\");\n\t\t\t\tupload = false;\n\t\t\t}\t\t\t\n\t\t} finally {\n\t\t\tsessionManager.closeSession();\n\t\t}\n\t\t\n\t\tInputStream stdin = new InputStreamWrapper(ServletUtils.getInputStream(request)) {\n\n\t\t\t@Override\n\t\t\tpublic void close() throws IOException {\n\t\t\t}\n\t\t\t\n\t\t};\n\t\tOutputStream stdout = new OutputStreamWrapper(response.getOutputStream()) {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void close() throws IOException {\n\t\t\t}\n\t\t\t\n\t\t};\n\t\t\n\t\tString protocol = request.getHeader(\"Git-Protocol\");\t\t\n\t\t\n\t\tif (upload) {\n\t\t\tworkExecutor.submit(new PrioritizedRunnable(PRIORITY) {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tAtomicBoolean toleratedErrors = new AtomicBoolean(false);\n\t\t\t\t\tErrorCollector stderr = new ErrorCollector(StandardCharsets.UTF_8.name()) {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void consume(String line) {\n\t\t\t\t\t\t\tsuper.consume(line);\n\t\t\t\t\t\t\t// This error may happen during a normal shallow fetch/clone \n\t\t\t\t\t\t\tif (line.contains(\"remote end hung up unexpectedly\")) {\n\t\t\t\t\t\t\t\ttoleratedErrors.set(true);\n\t\t\t\t\t\t\t\tlogger.debug(line);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tlogger.error(line);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t};\n\n\t\t\t\t\tExecutionResult result;\n\t\t\t\t\tUploadPackCommand upload = new UploadPackCommand(gitDir, environments);\n\t\t\t\t\tupload.stdin(stdin).stdout(stdout).stderr(stderr).statelessRpc(true).protocol(protocol);\n\t\t\t\t\tresult = upload.call();\n\t\t\t\t\tresult.setStderr(stderr.getMessage());\n\t\t\t\t\t\n\t\t\t\t\tif (result.getReturnCode() != 0 && !toleratedErrors.get())\n\t\t\t\t\t\tthrow result.buildException();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}).get();\n\t\t} else {\n\t\t\tworkExecutor.submit(new PrioritizedRunnable(PRIORITY) {\n\t\t\t\t\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tErrorCollector stderr = new ErrorCollector(StandardCharsets.UTF_8.name()) {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void consume(String line) {\n\t\t\t\t\t\t\tsuper.consume(line);\n\t\t\t\t\t\t\tlogger.error(line);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t};\n\t\t\t\t\t\n\t\t\t\t\tReceivePackCommand receive = new ReceivePackCommand(gitDir, environments);\n\t\t\t\t\treceive.stdin(stdin).stdout(stdout).stderr(stderr).statelessRpc(true).protocol(protocol);\n\t\t\t\t\tExecutionResult result = receive.call();\n\t\t\t\t\tresult.setStderr(stderr.getMessage());\n\t\t\t\t\tresult.checkReturnCode();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}).get();\n\t\t}\n\t}\n\t\n\tprivate void writeInitial(HttpServletResponse response, String service) throws IOException {\n\t\tdoNotCache(response);\n\t\tresponse.setHeader(\"Content-Type\", \"application/x-\" + service + \"-advertisement\");\t\t\t\n\t\t\n\t\tPacketLineOut pack = new PacketLineOut(response.getOutputStream());\n\t\tpack.setFlushOnEnd(false);\n\t\tpack.writeString(\"# service=\" + service + \"\\n\");\n\t\tpack.end();\n\t}\n\t\n\tprivate void checkPullPermission(HttpServletRequest request, Project project) {\n\t\tif (!SecurityUtils.canReadCode(project)) {\n\t\t\tboolean isAuthorized = false;\n\t\t\tfor (CodePullAuthorizationSource source: codePullAuthorizationSources) {\n\t\t\t\tif (source.canPullCode(request, project)) {\n\t\t\t\t\tisAuthorized = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!isAuthorized)\n\t\t\t\tthrow new UnauthorizedException(\"You do not have permission to pull from this project.\");\n\t\t}\n\t}\n\t\n\tprotected void processRefs(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\tFile gitDir;\n\t\tboolean upload;\n\n\t\tsessionManager.openSession();\n\t\ttry {\n\t\t\tString pathInfo = request.getRequestURI().substring(request.getContextPath().length());\n\t\t\tpathInfo = StringUtils.stripStart(pathInfo, \"/\");\n\n\t\t\tString projectInfo = pathInfo.substring(0, pathInfo.length() - INFO_REFS.length());\n\t\t\tProject project = getProject(request, response, projectInfo);\n\t\t\tString service = request.getParameter(\"service\");\n\t\t\t\n\t\t\tgitDir = storageManager.getProjectGitDir(project.getId());\n\n\t\t\tif (service.contains(\"upload\")) {\n\t\t\t\tcheckPullPermission(request, project);\n\t\t\t\twriteInitial(response, service);\n\t\t\t\tupload = true;\n\t\t\t} else {\n\t\t\t\tif (!SecurityUtils.canWriteCode(project))\n\t\t\t\t\tthrow new UnauthorizedException(\"You do not have permission to push to this project.\");\n\t\t\t\twriteInitial(response, service);\n\t\t\t\tupload = false;\n\t\t\t}\n\t\t} finally {\n\t\t\tsessionManager.closeSession();\n\t\t}\n\t\t\n\t\tOutputStream os = new OutputStreamWrapper(response.getOutputStream()) {\n\n\t\t\t@Override\n\t\t\tpublic void close() throws IOException {\n\t\t\t}\n\t\t\t\n\t\t};\n\t\t\n\t\tString protocolVersion = request.getHeader(\"Git-Protocol\");\t\t\n\t\t\n\t\tif (upload) \n\t\t\tnew AdvertiseUploadRefsCommand(gitDir).protocol(protocolVersion).output(os).call();\n\t\telse \n\t\t\tnew AdvertiseReceiveRefsCommand(gitDir).protocol(protocolVersion).output(os).call();\n\t}\n\n\t@Override\n\tpublic void init(FilterConfig filterConfig) throws ServletException {\n\t}\n\n\t@Override\n\tpublic void doFilter(ServletRequest request, ServletResponse response,\n\t\t\tFilterChain chain) throws IOException, ServletException {\n\t\tHttpServletRequest httpRequest = (HttpServletRequest) request;\n\t\tHttpServletResponse httpResponse = (HttpServletResponse) response;\n\t\t\n\t\ttry {\n\t\t\tif (GitSmartHttpTools.isInfoRefs(httpRequest)) {\n\t\t\t\tif (oneDev.isReady())\n\t\t\t\t\tprocessRefs(httpRequest, httpResponse);\n\t\t\t\telse\n\t\t\t\t\tthrow new SystemNotReadyException();\n\t\t\t} else if (GitSmartHttpTools.isReceivePack(httpRequest) || GitSmartHttpTools.isUploadPack(httpRequest)) {\n\t\t\t\tif (oneDev.isReady())\n\t\t\t\t\tprocessPacks(httpRequest, httpResponse);\n\t\t\t\telse\n\t\t\t\t\tthrow new SystemNotReadyException();\n\t\t\t} else {\n\t\t\t\tchain.doFilter(request, response);\n\t\t\t}\n\t\t} catch (SystemNotReadyException e) {\n\t\t\tlogger.debug(\"Unable to serve git request as system is not ready yet\");\n\t\t\tGitSmartHttpTools.sendError(httpRequest, httpResponse, HttpServletResponse.SC_SERVICE_UNAVAILABLE, e.getMessage());\n\t\t} catch (GitException|InterruptedException|ExecutionException e) {\n\t\t\tlogger.error(\"Error serving git request\", e);\n\t\t\tGitSmartHttpTools.sendError(httpRequest, httpResponse, HttpServletResponse.SC_INTERNAL_SERVER_ERROR, e.getMessage());\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic void destroy() {\n\t}\n\t\n}\n ", "package io.onedev.server.git;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.net.InetSocketAddress;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.Future;\n\nimport javax.annotation.Nullable;\n\nimport org.apache.shiro.util.ThreadContext;\nimport org.apache.sshd.common.channel.ChannelOutputStream;\nimport org.apache.sshd.server.Environment;\nimport org.apache.sshd.server.ExitCallback;\nimport org.apache.sshd.server.channel.ChannelSession;\nimport org.apache.sshd.server.command.Command;\nimport org.apache.sshd.server.session.ServerSession;\nimport org.apache.sshd.server.session.ServerSessionAware;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport io.onedev.commons.utils.StringUtils;\nimport io.onedev.commons.utils.command.ExecutionResult;\nimport io.onedev.server.OneDev;\nimport io.onedev.server.entitymanager.ProjectManager;\nimport io.onedev.server.entitymanager.SettingManager;\nimport io.onedev.server.model.Project;\nimport io.onedev.server.persistence.SessionManager;\nimport io.onedev.server.security.SecurityUtils;\nimport io.onedev.server.ssh.SshAuthenticator;\nimport io.onedev.server.util.InputStreamWrapper;\nimport io.onedev.server.util.OutputStreamWrapper;\nimport io.onedev.server.util.ServerConfig;\nimport io.onedev.server.util.concurrent.WorkExecutor;\nimport io.onedev.server.util.concurrent.PrioritizedRunnable;\n\nabstract class GitSshCommand implements Command, ServerSessionAware {\n\t\n\tprivate static final int PRIORITY = 2;\n\t\n\tprivate static final Logger logger = LoggerFactory.getLogger(GitSshCommand.class);\n\n\tfinal String command;\n\t\n\tInputStream in;\n\t\n\tOutputStream out;\n\t\n\tOutputStream err;\n\t\n\tExitCallback callback;\n\t\n\tServerSession session;\n\t\n\tFuture<?> future;\n\t\n\tGitSshCommand(String command) {\n\t\tthis.command = command;\n\t}\n\t\n    private Map<String, String> buildGitEnvs(Project project) {\n\t\tMap<String, String> environments = new HashMap<>();\n\t\t\n\t\tServerConfig serverConfig = OneDev.getInstance(ServerConfig.class);\n\t\tString serverUrl;\n        if (serverConfig.getHttpPort() != 0)\n            serverUrl = \"http://localhost:\" + serverConfig.getHttpPort();\n        else \n            serverUrl = \"https://localhost:\" + serverConfig.getHttpsPort();\n\n        SettingManager settingManager = OneDev.getInstance(SettingManager.class);\n        environments.put(\"ONEDEV_CURL\", settingManager.getSystemSetting().getCurlConfig().getExecutable());\n\t\tenvironments.put(\"ONEDEV_URL\", serverUrl);\n\t\tenvironments.put(\"ONEDEV_HOOK_TOKEN\", GitUtils.HOOK_TOKEN);\n\t\tenvironments.put(\"ONEDEV_USER_ID\", SecurityUtils.getUserId().toString());\n\t\tenvironments.put(\"ONEDEV_REPOSITORY_ID\", project.getId().toString());\n\t\treturn environments;\n    }\n    \n\t@Override\n\tpublic void start(ChannelSession channel, Environment env) throws IOException {\n\t\tSshAuthenticator authenticator = OneDev.getInstance(SshAuthenticator.class);\n\t\tThreadContext.bind(SecurityUtils.asSubject(authenticator.getPublicKeyOwnerId(session)));\n\t\t\n        File gitDir;\n        Map<String, String> gitEnvs;\n        \n        SessionManager sessionManager = OneDev.getInstance(SessionManager.class);\n        sessionManager.openSession(); \n        try {\n\t\t\tProjectManager projectManager = OneDev.getInstance(ProjectManager.class);\n\t\t\tString projectPath = StringUtils.substringAfter(command, \"'/\");   \n\t\t\tprojectPath = StringUtils.substringBefore(projectPath, \"'\");\n            Project project = projectManager.findByPath(projectPath);\n    \t\tif (project == null && projectPath.startsWith(\"projects/\")) {\n    \t\t\tprojectPath = projectPath.substring(\"projects/\".length());\n    \t\t\tproject = projectManager.findByPath(projectPath);\n    \t\t}\n            if (project == null) {\n                onExit(-1, \"Unable to find project '\" + projectPath + \"'\");\n                return;\n            } \n            \n        \tString errorMessage = checkPermission(project);\n        \tif (errorMessage != null) {\n        \t\tonExit(-1, errorMessage);\n        \t\treturn;\n        \t} \n\n            gitDir = project.getGitDir();\n            gitEnvs = buildGitEnvs(project);\n        } finally {                \n            sessionManager.closeSession();\n        }\n\t\t\n        InetSocketAddress address = (InetSocketAddress) session.getRemoteAddress();\n        String groupId = \"git-over-ssh-\" + gitDir.getAbsolutePath() \n        \t\t+ \"-\" + address.getAddress().getHostAddress();\n        \n        WorkExecutor workExecutor = OneDev.getInstance(WorkExecutor.class);\n\t\tfuture = workExecutor.submit(groupId, new PrioritizedRunnable(PRIORITY) {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tExecutionResult result = execute(gitDir, gitEnvs);\n\t\t\t\t\tonExit(result.getReturnCode(), null);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tlogger.error(\"Error executing git command\", e);\n\t\t\t\t\tonExit(-1, e.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t}\n\t\n\t@Nullable\n\tprotected abstract String checkPermission(Project project);\n\n\tprotected abstract ExecutionResult execute(File gitDir, Map<String, String> gitEnvs);\n\n\t@Override\n\tpublic void destroy(ChannelSession channel) throws Exception {\n\t\tif (future != null)\n\t\t\tfuture.cancel(true);\n\t}\n\n\tprotected void onExit(int exitValue, @Nullable String errorMessage) {\n\t\tif (errorMessage != null)\n\t\t\tnew PrintStream(err).println(\"ERROR: \" + errorMessage);\n\t\tcallback.onExit(exitValue);\n\t}\n\n\t@Override\n\tpublic void setInputStream(InputStream in) {\n\t\tthis.in = new InputStreamWrapper(in) {\n\n\t\t\t@Override\n\t\t\tpublic void close() throws IOException {\n\t\t\t}\n\t\t\t\n\t\t};\n\t}\n\n\t@Override\n\tpublic void setOutputStream(OutputStream out) {\n\t\tthis.out = new OutputStreamWrapper(out) {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void close() throws IOException {\n\t\t\t}\n\t\t\t\n\t\t};\n\t\t((ChannelOutputStream) out).setNoDelay(true);\n\t}\n\n\t@Override\n\tpublic void setErrorStream(OutputStream err) {\n\t\tthis.err = new OutputStreamWrapper(err) {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void close() throws IOException {\n\t\t\t}\n\t\t\t\n\t\t};\n\t\t((ChannelOutputStream) err).setNoDelay(true);\n\t}\n\n\t@Override\n\tpublic void setExitCallback(ExitCallback callBack) {\n\t\tthis.callback = callBack;\n\t}\n\n\t@Override\n\tpublic void setSession(ServerSession session) {\n\t\tthis.session = session;\n\t}\n\n}", "package io.onedev.server.git;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.annotation.Nullable;\n\nimport org.apache.commons.lang3.RandomStringUtils;\nimport org.bouncycastle.bcpg.ArmoredOutputStream;\nimport org.bouncycastle.bcpg.BCPGOutputStream;\nimport org.bouncycastle.bcpg.HashAlgorithmTags;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.bouncycastle.openpgp.PGPCompressedData;\nimport org.bouncycastle.openpgp.PGPException;\nimport org.bouncycastle.openpgp.PGPPrivateKey;\nimport org.bouncycastle.openpgp.PGPPublicKey;\nimport org.bouncycastle.openpgp.PGPSecretKeyRing;\nimport org.bouncycastle.openpgp.PGPSignature;\nimport org.bouncycastle.openpgp.PGPSignatureGenerator;\nimport org.bouncycastle.openpgp.PGPSignatureList;\nimport org.bouncycastle.openpgp.PGPSignatureSubpacketGenerator;\nimport org.bouncycastle.openpgp.PGPUtil;\nimport org.bouncycastle.openpgp.jcajce.JcaPGPObjectFactory;\nimport org.bouncycastle.openpgp.operator.jcajce.JcaPGPContentSignerBuilder;\nimport org.bouncycastle.openpgp.operator.jcajce.JcaPGPContentVerifierBuilderProvider;\nimport org.bouncycastle.openpgp.operator.jcajce.JcePBESecretKeyDecryptorBuilder;\nimport org.eclipse.jgit.diff.DiffEntry;\nimport org.eclipse.jgit.diff.DiffEntry.ChangeType;\nimport org.eclipse.jgit.diff.DiffFormatter;\nimport org.eclipse.jgit.diff.RawTextComparator;\nimport org.eclipse.jgit.errors.AmbiguousObjectException;\nimport org.eclipse.jgit.errors.IncorrectObjectTypeException;\nimport org.eclipse.jgit.errors.MissingObjectException;\nimport org.eclipse.jgit.errors.RevisionSyntaxException;\nimport org.eclipse.jgit.lib.AnyObjectId;\nimport org.eclipse.jgit.lib.CommitBuilder;\nimport org.eclipse.jgit.lib.Constants;\nimport org.eclipse.jgit.lib.FileMode;\nimport org.eclipse.jgit.lib.GpgSignature;\nimport org.eclipse.jgit.lib.ObjectBuilder;\nimport org.eclipse.jgit.lib.ObjectId;\nimport org.eclipse.jgit.lib.ObjectInserter;\nimport org.eclipse.jgit.lib.ObjectReader;\nimport org.eclipse.jgit.lib.PersonIdent;\nimport org.eclipse.jgit.lib.RefUpdate;\nimport org.eclipse.jgit.lib.Repository;\nimport org.eclipse.jgit.merge.MergeStrategy;\nimport org.eclipse.jgit.merge.Merger;\nimport org.eclipse.jgit.merge.ResolveMerger;\nimport org.eclipse.jgit.revwalk.RevCommit;\nimport org.eclipse.jgit.revwalk.RevObject;\nimport org.eclipse.jgit.revwalk.RevTag;\nimport org.eclipse.jgit.revwalk.RevWalk;\nimport org.eclipse.jgit.revwalk.RevWalkUtils;\nimport org.eclipse.jgit.revwalk.filter.RevFilter;\nimport org.eclipse.jgit.treewalk.CanonicalTreeParser;\nimport org.eclipse.jgit.treewalk.TreeWalk;\nimport org.eclipse.jgit.treewalk.filter.TreeFilter;\nimport org.eclipse.jgit.util.RawParseUtils;\nimport org.eclipse.jgit.util.SystemReader;\nimport org.eclipse.jgit.util.io.NullOutputStream;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Objects;\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Splitter;\nimport com.google.common.base.Strings;\nimport com.google.common.collect.Iterables;\n\nimport io.onedev.commons.utils.PathUtils;\nimport io.onedev.server.git.command.FetchCommand;\nimport io.onedev.server.git.command.IsAncestorCommand;\nimport io.onedev.server.git.exception.ObsoleteCommitException;\nimport io.onedev.server.git.exception.RefUpdateException;\nimport io.onedev.server.git.signature.SignatureUnverified;\nimport io.onedev.server.git.signature.SignatureVerification;\nimport io.onedev.server.git.signature.SignatureVerificationKey;\nimport io.onedev.server.git.signature.SignatureVerificationKeyLoader;\nimport io.onedev.server.git.signature.SignatureVerified;\nimport io.onedev.server.util.GpgUtils;\n\npublic class GitUtils {\n\n\tpublic static final int SHORT_SHA_LENGTH = 8;\n\t\n\tprivate static final Logger logger = LoggerFactory.getLogger(GitUtils.class);\n\t\n\tpublic static final String HOOK_TOKEN = RandomStringUtils.randomAlphanumeric(20); \n\t\n\tpublic static boolean isEmptyPath(String path) {\n\t\treturn Strings.isNullOrEmpty(path) || Objects.equal(path, DiffEntry.DEV_NULL);\n\t}\n\n\tpublic static String abbreviateSHA(String sha, int length) {\n\t\tPreconditions.checkArgument(ObjectId.isId(sha));\n\t\treturn sha.substring(0, length);\n\t}\n\n\tpublic static String abbreviateSHA(String sha) {\n\t\treturn abbreviateSHA(sha, SHORT_SHA_LENGTH);\n\t}\n\n\tpublic static List<DiffEntry> diff(Repository repository, AnyObjectId oldRevId, AnyObjectId newRevId) {\n\t\tList<DiffEntry> diffs = new ArrayList<>();\n\t\ttry (DiffFormatter diffFormatter = new DiffFormatter(NullOutputStream.INSTANCE);\n\t\t\t\tRevWalk revWalk = new RevWalk(repository);\n\t\t\t\tObjectReader reader = repository.newObjectReader();) {\n\t\t\tdiffFormatter.setRepository(repository);\n\t\t\tdiffFormatter.setDetectRenames(true);\n\t\t\tdiffFormatter.setDiffComparator(RawTextComparator.DEFAULT);\n\n\t\t\tCanonicalTreeParser oldTreeParser = new CanonicalTreeParser();\n\t\t\tif (!oldRevId.equals(ObjectId.zeroId()))\n\t\t\t\toldTreeParser.reset(reader, revWalk.parseCommit(oldRevId).getTree());\n\n\t\t\tCanonicalTreeParser newTreeParser = new CanonicalTreeParser();\n\t\t\tif (!newRevId.equals(ObjectId.zeroId()))\n\t\t\t\tnewTreeParser.reset(reader, revWalk.parseCommit(newRevId).getTree());\n\n\t\t\tfor (DiffEntry entry : diffFormatter.scan(oldTreeParser, newTreeParser)) {\n\t\t\t\tif (!Objects.equal(entry.getOldPath(), entry.getNewPath())\n\t\t\t\t\t\t|| !Objects.equal(entry.getOldMode(), entry.getNewMode()) || entry.getOldId() == null\n\t\t\t\t\t\t|| !entry.getOldId().isComplete() || entry.getNewId() == null || !entry.getNewId().isComplete()\n\t\t\t\t\t\t|| !entry.getOldId().equals(entry.getNewId())) {\n\t\t\t\t\tdiffs.add(entry);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\treturn diffs;\n\t}\n\n\t@Nullable\n\tpublic static String getDetailMessage(RevCommit commit) {\n\t\tint start = 0;\n\t\tString fullMessage = commit.getFullMessage();\n\t\twhile (true) {\n\t\t\tint index = fullMessage.indexOf('\\n', start);\n\t\t\tif (index == -1)\n\t\t\t\treturn null;\n\t\t\tstart = index + 1;\n\t\t\tint nextIndex = fullMessage.indexOf('\\n', start);\n\t\t\tif (nextIndex == -1)\n\t\t\t\treturn null;\n\t\t\tstart = nextIndex + 1;\n\t\t\tif (fullMessage.substring(index, nextIndex).trim().length() == 0) {\n\t\t\t\tString detailMessage = fullMessage.substring(start).trim();\n\t\t\t\treturn detailMessage.length() != 0 ? detailMessage : null;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static String getBlobTypeName(int blobType) {\n\t\tif (blobType == FileMode.TYPE_FILE)\n\t\t\treturn \"File\";\n\t\telse if (blobType == FileMode.TYPE_GITLINK)\n\t\t\treturn \"Sub module\";\n\t\telse if (blobType == FileMode.TYPE_SYMLINK)\n\t\t\treturn \"Symbol link\";\n\t\telse\n\t\t\treturn \"Folder\";\n\t}\n\n\tpublic static PersonIdent newPersonIdent(String name, String email, Date when) {\n\t\treturn new PersonIdent(name, email, when.getTime(), SystemReader.getInstance().getTimezone(when.getTime()));\n\t}\n\n\t/**\n\t * Parse the original git raw date to Java date. The raw git date is in unix\n\t * timestamp with timezone like: 1392312299 -0800\n\t * \n\t * @param input the input raw date string\n\t * @return Java date\n\t */\n\tpublic static Date parseRawDate(String input) {\n\t\tString[] pieces = Iterables.toArray(Splitter.on(\" \").split(input), String.class);\n\t\treturn new Date(Long.valueOf(pieces[0]) * 1000L);\n\t}\n\n\t/**\n\t * Parse the raw user information into PersonIdent object, the raw information\n\t * should be in format <code>[name] [<email>] [epoch timezone]</code>, for\n\t * example:\n\t * \n\t * Jacob Thornton <jacobthornton@gmail.com> 1328060294 -0800\n\t * \n\t * @param raw\n\t * @return\n\t */\n\tpublic static @Nullable PersonIdent parsePersonIdent(String raw) {\n\t\tif (Strings.isNullOrEmpty(raw))\n\t\t\treturn null;\n\n\t\tint pos1 = raw.indexOf('<');\n\t\tif (pos1 <= 0)\n\t\t\tthrow new IllegalArgumentException(\"Raw \" + raw);\n\n\t\tString name = raw.substring(0, pos1 - 1);\n\n\t\tint pos2 = raw.indexOf('>');\n\t\tif (pos2 <= 0)\n\t\t\tthrow new IllegalArgumentException(\"Raw \" + raw);\n\n\t\tString time = raw.substring(pos2 + 1).trim();\n\t\tDate when = parseRawDate(time);\n\n\t\tString email = raw.substring(pos1 + 1, pos2 - 1);\n\n\t\treturn newPersonIdent(name, email, when);\n\t}\n\n\tpublic static int comparePath(@Nullable String path1, @Nullable String path2) {\n\t\tList<String> segments1 = splitPath(path1);\n\t\tList<String> segments2 = splitPath(path2);\n\n\t\tint index = 0;\n\t\tfor (String segment1 : segments1) {\n\t\t\tif (index < segments2.size()) {\n\t\t\t\tint result = segment1.compareTo(segments2.get(index));\n\t\t\t\tif (result != 0)\n\t\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\t\tif (index < segments2.size())\n\t\t\treturn -1;\n\t\telse\n\t\t\treturn 0;\n\t}\n\n\tpublic static List<String> splitPath(@Nullable String path) {\n\t\tList<String> pathSegments;\n\t\tif (path != null)\n\t\t\tpathSegments = Splitter.on(\"/\").omitEmptyStrings().splitToList(path);\n\t\telse\n\t\t\tpathSegments = new ArrayList<>();\n\t\treturn pathSegments;\n\t}\n\n\tpublic static @Nullable String normalizePath(@Nullable String path) {\n\t\tList<String> pathSegments = splitPath(PathUtils.normalizeDots(path));\n\t\tif (!pathSegments.isEmpty())\n\t\t\treturn Joiner.on(\"/\").join(pathSegments);\n\t\telse\n\t\t\treturn null;\n\t}\n\n\t/**\n\t * Convert a git reference name to branch name.\n\t * \n\t * @param refName name of the git reference\n\t * @return name of the branch, or <tt>null</tt> if specified ref does not\n\t *         represent a branch\n\t */\n\tpublic static @Nullable String ref2branch(String refName) {\n\t\tif (refName.startsWith(Constants.R_HEADS))\n\t\t\treturn refName.substring(Constants.R_HEADS.length());\n\t\telse\n\t\t\treturn null;\n\t}\n\n\tpublic static String branch2ref(String branch) {\n\t\treturn Constants.R_HEADS + branch;\n\t}\n\n\t/**\n\t * Convert a git reference name to tag name.\n\t * \n\t * @param refName name of the git reference\n\t * @return name of the tag, or <tt>null</tt> if specified ref does not represent\n\t *         a tag\n\t */\n\tpublic static @Nullable String ref2tag(String refName) {\n\t\tif (refName.startsWith(Constants.R_TAGS))\n\t\t\treturn refName.substring(Constants.R_TAGS.length());\n\t\telse\n\t\t\treturn null;\n\t}\n\n\tpublic static String tag2ref(String tag) {\n\t\treturn Constants.R_TAGS + tag;\n\t}\n\n\tpublic static BlobIdent getOldBlobIdent(DiffEntry diffEntry, String oldRev) {\n\t\tBlobIdent blobIdent;\n\t\tif (diffEntry.getChangeType() != ChangeType.ADD) {\n\t\t\tblobIdent = new BlobIdent(oldRev, diffEntry.getOldPath(), diffEntry.getOldMode().getBits());\n\t\t} else {\n\t\t\tblobIdent = new BlobIdent(oldRev, null, null);\n\t\t}\n\t\treturn blobIdent;\n\t}\n\n\tpublic static BlobIdent getNewBlobIdent(DiffEntry diffEntry, String newRev) {\n\t\tBlobIdent blobIdent;\n\t\tif (diffEntry.getChangeType() != ChangeType.DELETE) {\n\t\t\tblobIdent = new BlobIdent(newRev, diffEntry.getNewPath(), diffEntry.getNewMode().getBits());\n\t\t} else {\n\t\t\tblobIdent = new BlobIdent(newRev, null, null);\n\t\t}\n\t\treturn blobIdent;\n\t}\n\n\t/**\n\t * @return merge base of specified commits, or <tt>null</tt> if two commits do\n\t *         not have related history. In this case, these two commits can not be\n\t *         merged\n\t */\n\t@Nullable\n\tpublic static ObjectId getMergeBase(Repository repository, ObjectId commitId1, ObjectId commitId2) {\n\t\ttry (RevWalk revWalk = new RevWalk(repository)) {\n\t\t\trevWalk.setRevFilter(RevFilter.MERGE_BASE);\n\n\t\t\trevWalk.markStart(revWalk.parseCommit(commitId1));\n\t\t\trevWalk.markStart(revWalk.parseCommit(commitId2));\n\t\t\tRevCommit mergeBase = revWalk.next();\n\t\t\treturn mergeBase != null ? mergeBase.copy() : null;\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\t/**\n\t * @return merge base of specified commits, or <tt>null</tt> if two commits do\n\t *         not have related history. In this case, these two commits can not be\n\t *         merged\n\t */\n\t@Nullable\n\tpublic static ObjectId getMergeBase(Repository repository1, ObjectId commit1, Repository repository2,\n\t\t\tObjectId commit2) {\n\t\tif (repository1.getDirectory() == null || !repository1.getDirectory().equals(repository2.getDirectory())) {\n\t\t\tfetch(repository2, commit2, repository1);\n\t\t}\n\t\treturn GitUtils.getMergeBase(repository1, commit1, commit2);\n\t}\n\n\tpublic static void fetch(Repository fromRepository, ObjectId fromCommit, Repository toRepository) {\n\t\tnew FetchCommand(toRepository.getDirectory(), null)\n\t\t\t\t.from(fromRepository.getDirectory().getAbsolutePath())\n\t\t\t\t.refspec(fromCommit.name())\n\t\t\t\t.force(true)\n\t\t\t\t.quiet(true)\n\t\t\t\t.call();\n\t}\n\n\tpublic static boolean isMergedInto(Repository repository, @Nullable Map<String, String> gitEnvs, ObjectId base,\n\t\t\tObjectId tip) {\n\t\tif (gitEnvs != null && !gitEnvs.isEmpty()) {\n\t\t\tIsAncestorCommand cmd = new IsAncestorCommand(repository.getDirectory(), gitEnvs);\n\t\t\tcmd.ancestor(base.name()).descendant(tip.name());\n\t\t\treturn cmd.call();\n\t\t} else {\n\t\t\ttry (RevWalk revWalk = new RevWalk(repository)) {\n\t\t\t\tRevCommit baseCommit;\n\t\t\t\ttry {\n\t\t\t\t\tbaseCommit = revWalk.parseCommit(base);\n\t\t\t\t} catch (MissingObjectException e) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn revWalk.isMergedInto(baseCommit, revWalk.parseCommit(tip));\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get commit of specified revision id.\n\t * \n\t * @param revWalk\n\t * @param revId\n\t * @return <tt>null</tt> if specified id does not exist or does not represent a\n\t *         commit\n\t */\n\t@Nullable\n\tpublic static RevCommit parseCommit(RevWalk revWalk, ObjectId revId) {\n\t\tRevObject peeled;\n\t\ttry {\n\t\t\tpeeled = revWalk.peel(revWalk.parseAny(revId));\n\t\t\tif (peeled instanceof RevCommit)\n\t\t\t\treturn (RevCommit) peeled;\n\t\t\telse\n\t\t\t\treturn null;\n\t\t} catch (MissingObjectException e) {\n\t\t\treturn null;\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\t@Nullable\n\tpublic static ObjectId resolve(Repository repository, String revision) {\n\t\ttry {\n\t\t\treturn repository.resolve(revision);\n\t\t} catch (RevisionSyntaxException | AmbiguousObjectException | IncorrectObjectTypeException e) {\n\t\t\treturn null;\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\t@Nullable\n\tpublic static ObjectId rebase(Repository repository, ObjectId source, ObjectId target, PersonIdent committer) {\n\t\ttry (RevWalk revWalk = new RevWalk(repository); ObjectInserter inserter = repository.newObjectInserter();) {\n\t\t\tRevCommit sourceCommit = revWalk.parseCommit(source);\n\t\t\tRevCommit targetCommit = revWalk.parseCommit(target);\n\t\t\trevWalk.setRevFilter(RevFilter.NO_MERGES);\n\t\t\tList<RevCommit> commits = RevWalkUtils.find(revWalk, sourceCommit, targetCommit);\n\t\t\tCollections.reverse(commits);\n\t\t\tRevCommit headCommit = targetCommit;\n\t\t\tfor (RevCommit commit : commits) {\n\t\t\t\tResolveMerger merger = (ResolveMerger) MergeStrategy.RECURSIVE.newMerger(repository, true);\n\t\t\t\tmerger.setBase(commit.getParent(0));\n\t\t\t\tif (merger.merge(headCommit, commit)) {\n\t\t\t\t\tif (!headCommit.getTree().getId().equals(merger.getResultTreeId())) {\n\t\t\t\t\t\tif (!commit.getTree().getId().equals(merger.getResultTreeId())\n\t\t\t\t\t\t\t\t|| !commit.getParent(0).equals(headCommit)) {\n\t\t\t\t\t\t\tCommitBuilder commitBuilder = new CommitBuilder();\n\t\t\t\t\t\t\tcommitBuilder.setAuthor(commit.getAuthorIdent());\n\t\t\t\t\t\t\tcommitBuilder.setCommitter(committer);\n\t\t\t\t\t\t\tcommitBuilder.setParentId(headCommit);\n\t\t\t\t\t\t\tcommitBuilder.setMessage(commit.getFullMessage());\n\t\t\t\t\t\t\tcommitBuilder.setTreeId(merger.getResultTreeId());\n\t\t\t\t\t\t\theadCommit = revWalk.parseCommit(inserter.insert(commitBuilder));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\theadCommit = commit;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tinserter.flush();\n\t\t\treturn headCommit.copy();\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\t@Nullable\n\tpublic static ObjectId merge(Repository repository, ObjectId targetCommitId, ObjectId sourceCommitId,\n\t\t\tboolean squash, PersonIdent committer, PersonIdent author, String commitMessage,\n\t\t\tboolean useOursOnConflict) {\n\t\ttry (RevWalk revWalk = new RevWalk(repository); ObjectInserter inserter = repository.newObjectInserter();) {\n\t\t\tRevCommit sourceCommit = revWalk.parseCommit(sourceCommitId);\n\t\t\tRevCommit targetCommit = revWalk.parseCommit(targetCommitId);\n\t\t\tMerger merger;\n\t\t\tif (useOursOnConflict)\n\t\t\t\tmerger = MergeStrategy.OURS.newMerger(repository, true);\n\t\t\telse\n\t\t\t\tmerger = MergeStrategy.RECURSIVE.newMerger(repository, true);\n\t\t\tif (merger.merge(targetCommit, sourceCommit)) {\n\t\t\t\tCommitBuilder mergedCommit = new CommitBuilder();\n\t\t\t\tmergedCommit.setAuthor(author);\n\t\t\t\tmergedCommit.setCommitter(committer);\n\t\t\t\tif (squash)\n\t\t\t\t\tmergedCommit.setParentId(targetCommit);\n\t\t\t\telse\n\t\t\t\t\tmergedCommit.setParentIds(targetCommit, sourceCommit);\n\t\t\t\tmergedCommit.setMessage(commitMessage);\n\t\t\t\tmergedCommit.setTreeId(merger.getResultTreeId());\n\t\t\t\tObjectId mergedCommitId = inserter.insert(mergedCommit);\n\t\t\t\tinserter.flush();\n\t\t\t\treturn mergedCommitId;\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tpublic static Collection<String> getChangedFiles(Repository repository, ObjectId oldCommitId,\n\t\t\tObjectId newCommitId) {\n\t\tCollection<String> changedFiles = new HashSet<>();\n\t\ttry (RevWalk revWalk = new RevWalk(repository); TreeWalk treeWalk = new TreeWalk(repository)) {\n\t\t\ttreeWalk.setFilter(TreeFilter.ANY_DIFF);\n\t\t\ttreeWalk.setRecursive(true);\n\t\t\tRevCommit oldCommit = revWalk.parseCommit(oldCommitId);\n\t\t\tRevCommit newCommit = revWalk.parseCommit(newCommitId);\n\t\t\ttreeWalk.addTree(oldCommit.getTree());\n\t\t\ttreeWalk.addTree(newCommit.getTree());\n\t\t\twhile (treeWalk.next()) {\n\t\t\t\tchangedFiles.add(treeWalk.getPathString());\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\treturn changedFiles;\n\t}\n\n\tpublic static boolean isValid(File gitDir) {\n\t\treturn new File(gitDir, \"objects\").exists();\n\t}\n\n\tpublic static RefUpdate getRefUpdate(Repository repository, String refName) {\n\t\ttry {\n\t\t\treturn repository.updateRef(refName);\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tpublic static void updateRef(RefUpdate refUpdate) {\n\t\ttry {\n\t\t\tRefUpdate.Result result = refUpdate.forceUpdate();\n\t\t\tif (result == RefUpdate.Result.LOCK_FAILURE && refUpdate.getExpectedOldObjectId() != null\n\t\t\t\t\t&& !refUpdate.getExpectedOldObjectId().equals(refUpdate.getOldObjectId())) {\n\t\t\t\tthrow new ObsoleteCommitException(refUpdate.getOldObjectId());\n\t\t\t} else if (result != RefUpdate.Result.FAST_FORWARD && result != RefUpdate.Result.FORCED\n\t\t\t\t\t&& result != RefUpdate.Result.NEW && result != RefUpdate.Result.NO_CHANGE) {\n\t\t\t\tthrow new RefUpdateException(result);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tpublic static void deleteRef(RefUpdate refUpdate) {\n\t\ttry {\n\t\t\trefUpdate.setForceUpdate(true);\n\t\t\tRefUpdate.Result result = refUpdate.delete();\n\t\t\tif (result == RefUpdate.Result.LOCK_FAILURE && refUpdate.getExpectedOldObjectId() != null\n\t\t\t\t\t&& !refUpdate.getExpectedOldObjectId().equals(refUpdate.getOldObjectId())) {\n\t\t\t\tthrow new ObsoleteCommitException(refUpdate.getOldObjectId());\n\t\t\t} else if (result != RefUpdate.Result.FAST_FORWARD && result != RefUpdate.Result.FORCED\n\t\t\t\t\t&& result != RefUpdate.Result.NEW && result != RefUpdate.Result.NO_CHANGE) {\n\t\t\t\tthrow new RefUpdateException(result);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tpublic static void linkRef(RefUpdate refUpdate, String target) {\n\t\ttry {\n\t\t\tRefUpdate.Result result = refUpdate.link(target);\n\t\t\tif (result != RefUpdate.Result.FORCED && result != RefUpdate.Result.NEW\n\t\t\t\t\t&& result != RefUpdate.Result.NO_CHANGE)\n\t\t\t\tthrow new RefUpdateException(result);\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\t\n\tpublic static void sign(ObjectBuilder object, PGPSecretKeyRing signingKey) {\n\t\tJcePBESecretKeyDecryptorBuilder decryptorBuilder = new JcePBESecretKeyDecryptorBuilder()\n\t\t\t\t.setProvider(BouncyCastleProvider.PROVIDER_NAME);\n\t\tPGPPrivateKey privateKey;\n\t\ttry {\n\t\t\tprivateKey = signingKey.getSecretKey().extractPrivateKey(\n\t\t\t\t\tdecryptorBuilder.build(new char[0]));\n\t\t} catch (PGPException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\t\n\t\tPGPPublicKey publicKey = signingKey.getPublicKey();\n\t\t\n\t\tPGPSignatureGenerator signatureGenerator = new PGPSignatureGenerator(\n\t\t\t\tnew JcaPGPContentSignerBuilder(publicKey.getAlgorithm(), HashAlgorithmTags.SHA256)\n\t\t\t\t\t\t.setProvider(BouncyCastleProvider.PROVIDER_NAME));\n\t\ttry {\n\t\t\tsignatureGenerator.init(PGPSignature.BINARY_DOCUMENT, privateKey);\n\t\t\tPGPSignatureSubpacketGenerator subpackets = new PGPSignatureSubpacketGenerator();\n\t\t\tsubpackets.setIssuerFingerprint(false, publicKey);\n\t\t\t\n\t\t\tString emailAddress = GpgUtils.getEmailAddress(publicKey.getUserIDs().next());\n\t\t\tsubpackets.addSignerUserID(false, emailAddress);\n\t\t\t\n\t\t\tsignatureGenerator.setHashedSubpackets(subpackets.generate());\n\t\t\tByteArrayOutputStream buffer = new ByteArrayOutputStream();\n\t\t\ttry (BCPGOutputStream out = new BCPGOutputStream(new ArmoredOutputStream(buffer))) {\n\t\t\t\tsignatureGenerator.update(object.build());\n\t\t\t\tsignatureGenerator.generate().encode(out);\n\t\t\t}\n\t\t\tobject.setGpgSignature(new GpgSignature(buffer.toByteArray()));\t\t\n\t\t} catch (IOException | PGPException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\t\n\t@Nullable\n\tpublic static SignatureVerification verifyTagSignature(byte[] raw, \n\t\t\tSignatureVerificationKeyLoader keyLoader) {\n\t\tbyte[] signatureData = TagParser.getRawGpgSignature(raw); \n\t\tif (signatureData == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// The signature is just tacked onto the end of the message, which\n\t\t// is last in the buffer.\n\t\tbyte[] data = Arrays.copyOfRange(raw, 0, raw.length - signatureData.length);\n\t\t\n\t\tPersonIdent taggerIdent = TagParser.getTaggerIdent(raw);\n\t\tif (taggerIdent == null)\n\t\t\treturn null;\n\t\t\n\t\treturn verify(data, signatureData, taggerIdent.getEmailAddress(), keyLoader);\n\t}\n\t\n\t/*\n\t * Most logic here is copied from JGit\n\t */\n\t@Nullable\n\tpublic static SignatureVerification verifyCommitSignature(byte[] raw, \n\t\t\tSignatureVerificationKeyLoader keyLoader) {\n\t\tbyte[] header = {'g', 'p', 'g', 's', 'i', 'g'};\n\t\tint start = RawParseUtils.headerStart(header, raw, 0);\n\t\tif (start < 0)\n\t\t\treturn null;\n\t\tint end = RawParseUtils.headerEnd(raw, start);\n\t\tbyte[] signatureData = Arrays.copyOfRange(raw, start, end);\n\t\t\n\t\t// start is at the beginning of the header's content\n\t\tstart -= header.length + 1;\n\t\t// end is on the terminating LF; we need to skip that, too\n\t\tif (end < raw.length) {\n\t\t\tend++;\n\t\t}\n\t\tbyte[] data = new byte[raw.length - (end - start)];\n\t\tSystem.arraycopy(raw, 0, data, 0, start);\n\t\tSystem.arraycopy(raw, end, data, start, raw.length - end);\n\n\t\tint nameB = RawParseUtils.committer(raw, 0);\n\t\tif (nameB < 0)\n\t\t\treturn null;\n\t\tPersonIdent committerIdent = RawParseUtils.parsePersonIdent(raw, nameB);\n\t\tString emailAddress = committerIdent.getEmailAddress();\n\t\treturn verify(data, signatureData, emailAddress, keyLoader);\n\t}\n\t\n\t@Nullable\n\tpublic static SignatureVerification verifySignature(RevObject object, SignatureVerificationKeyLoader keyLoader) {\n\t\tif (object instanceof RevCommit) {\n\t\t\tRevCommit commit = (RevCommit) object;\n\t\t\treturn verifyCommitSignature(commit.getRawBuffer(), keyLoader);\n\t\t} else if (object instanceof RevTag) {\n\t\t\tRevTag tag = (RevTag) object;\n\t\t\treturn verifyTagSignature(tag.getRawBuffer(), keyLoader);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tprivate static PGPSignature parseSignature(InputStream in) throws IOException, PGPException {\n\t\ttry (InputStream sigIn = PGPUtil.getDecoderStream(in)) {\n\t\t\tJcaPGPObjectFactory pgpFactory = new JcaPGPObjectFactory(sigIn);\n\t\t\tObject obj = pgpFactory.nextObject();\n\t\t\tif (obj instanceof PGPCompressedData) {\n\t\t\t\tobj = new JcaPGPObjectFactory(((PGPCompressedData) obj).getDataStream()).nextObject();\n\t\t\t}\n\t\t\tif (obj instanceof PGPSignatureList) {\n\t\t\t\treturn ((PGPSignatureList) obj).get(0);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t@Nullable\n\tprivate static SignatureVerification verify(byte[] data, byte[] signatureData, String dataWriter, \n\t\t\tSignatureVerificationKeyLoader keyLoader) {\n\t\ttry (InputStream sigIn = new ByteArrayInputStream(signatureData)) {\n\t\t\tPGPSignature signature = parseSignature(sigIn);\n\t\t\tif (signature != null) {\n\t\t\t\tSignatureVerificationKey key = keyLoader.getSignatureVerificationKey(signature.getKeyID());\n\t\t\t\tif (key != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tsignature.init(\n\t\t\t\t\t\t\t\tnew JcaPGPContentVerifierBuilderProvider().setProvider(BouncyCastleProvider.PROVIDER_NAME),\n\t\t\t\t\t\t\t\tkey.getPublicKey());\n\t\t\t\t\t\tsignature.update(data);\n\t\t\t\t\t\tif (signature.verify()) {\n\t\t\t\t\t\t\tif (!key.shouldVerifyDataWriter() || key.getEmailAddress().equals(dataWriter)) \n\t\t\t\t\t\t\t\treturn new SignatureVerified(key);\n\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\treturn new SignatureUnverified(key, \"Email address of signing key and committer is different\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn new SignatureUnverified(key, \"Invalid commit signature\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (PGPException e) {\n\t\t\t\t\t\tlogger.error(\"Commit signature verification failed\", e);\n\t\t\t\t\t\treturn new SignatureUnverified(key, \"Signature verification failed\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn new SignatureUnverified(null, \"Signature is signed with an unknown key \"\n\t\t\t\t\t\t\t+ \"(key ID: \" + GpgUtils.getKeyIDString(signature.getKeyID()) + \")\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn new SignatureUnverified(null, \"Signature does not decode into a signature object\");\n\t\t\t}\n\t\t} catch (PGPException e) {\n\t\t\tlogger.error(\"Error parsing commit signature\", e);\n\t\t\treturn new SignatureUnverified(null, \"Signature cannot be parsed\");\n\t\t} catch (IOException e2) {\n\t\t\tthrow new RuntimeException(e2);\n\t\t}\n\t}\n\t\n\t/*\n\t * Copied from JGit\n\t */\n\tprivate static class TagParser {\n\t\t\n\t\tprivate static final byte[] hSignature = Constants.encodeASCII(\"-----BEGIN PGP SIGNATURE-----\");\n\n\t\tprivate static int nextStart(byte[] prefix, byte[] buffer, int from) {\n\t\t\tint stop = buffer.length - prefix.length + 1;\n\t\t\tint ptr = from;\n\t\t\tif (ptr > 0) {\n\t\t\t\tptr = RawParseUtils.nextLF(buffer, ptr - 1);\n\t\t\t}\n\t\t\twhile (ptr < stop) {\n\t\t\t\tint lineStart = ptr;\n\t\t\t\tboolean found = true;\n\t\t\t\tfor (byte element : prefix) {\n\t\t\t\t\tif (element != buffer[ptr++]) {\n\t\t\t\t\t\tfound = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (found) {\n\t\t\t\t\treturn lineStart;\n\t\t\t\t}\n\t\t\t\tdo {\n\t\t\t\t\tptr = RawParseUtils.nextLF(buffer, ptr);\n\t\t\t\t} while (ptr < stop && buffer[ptr] == '\\n');\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\n\t\tprivate static int getSignatureStart(byte[] raw) {\n\t\t\tint msgB = RawParseUtils.tagMessage(raw, 0);\n\t\t\tif (msgB < 0) {\n\t\t\t\treturn msgB;\n\t\t\t}\n\t\t\t// Find the last signature start and return the rest\n\t\t\tint start = nextStart(hSignature, raw, msgB);\n\t\t\tif (start < 0) {\n\t\t\t\treturn start;\n\t\t\t}\n\t\t\tint next = RawParseUtils.nextLF(raw, start);\n\t\t\twhile (next < raw.length) {\n\t\t\t\tint newStart = nextStart(hSignature, raw, next);\n\t\t\t\tif (newStart < 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstart = newStart;\n\t\t\t\tnext = RawParseUtils.nextLF(raw, start);\n\t\t\t}\n\t\t\treturn start;\n\t\t}\n\t\t\n\t\tprivate static byte[] getRawGpgSignature(byte[] raw) {\n\t\t\tint start = getSignatureStart(raw);\n\t\t\tif (start < 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn Arrays.copyOfRange(raw, start, raw.length);\n\t\t}\n\n\t\tprivate static PersonIdent getTaggerIdent(byte[] raw) {\n\t\t\tint nameB = RawParseUtils.tagger(raw, 0);\n\t\t\tif (nameB < 0)\n\t\t\t\treturn null;\n\t\t\treturn RawParseUtils.parsePersonIdent(raw, nameB);\n\t\t}\n\t\t\n\t}\n\t\n}\n", "package io.onedev.server.git.hookcallback;\r\n\r\nimport java.io.IOException;\r\nimport java.util.ArrayList;\r\nimport java.util.Enumeration;\r\nimport java.util.List;\r\n\r\nimport javax.inject.Inject;\r\nimport javax.inject.Singleton;\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\n\r\nimport org.apache.commons.lang3.tuple.ImmutableTriple;\r\nimport org.apache.shiro.util.ThreadContext;\r\nimport org.eclipse.jgit.lib.ObjectId;\r\nimport org.eclipse.jgit.lib.RefUpdate;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\n\r\nimport com.google.common.base.Preconditions;\r\n\r\nimport io.onedev.commons.loader.ListenerRegistry;\r\nimport io.onedev.commons.utils.StringUtils;\r\nimport io.onedev.server.entitymanager.ProjectManager;\r\nimport io.onedev.server.event.RefUpdated;\r\nimport io.onedev.server.git.GitUtils;\r\nimport io.onedev.server.model.Project;\r\nimport io.onedev.server.persistence.SessionManager;\r\nimport io.onedev.server.persistence.annotation.Sessional;\r\nimport io.onedev.server.security.SecurityUtils;\r\n\r\n@SuppressWarnings(\"serial\")\r\n@Singleton\r\npublic class GitPostReceiveCallback extends HttpServlet {\r\n\r\n\tprivate static final Logger logger = LoggerFactory.getLogger(GitPostReceiveCallback.class);\r\n\t\r\n    public static final String PATH = \"/git-postreceive-callback\";\r\n    \r\n    private final ProjectManager projectManager;\r\n\r\n    private final ListenerRegistry listenerRegistry;\r\n    \r\n    private final SessionManager sessionManager;\r\n    \r\n    @Inject\r\n    public GitPostReceiveCallback(ProjectManager projectManager, SessionManager sessionManager, ListenerRegistry listenerRegistry) {\r\n    \tthis.projectManager = projectManager;\r\n    \tthis.sessionManager = sessionManager;\r\n        this.listenerRegistry = listenerRegistry;\r\n    }\r\n\r\n    @Sessional\r\n    @Override\r\n\tprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        List<String> fields = StringUtils.splitAndTrim(request.getPathInfo(), \"/\");\r\n        Preconditions.checkState(fields.size() == 3);\r\n        \r\n        if (!fields.get(2).equals(GitUtils.HOOK_TOKEN)) {\r\n            response.sendError(HttpServletResponse.SC_FORBIDDEN,\r\n                    \"Git hook callbacks can only be accessed by OneDev itself\");\r\n            return;\r\n        }\r\n        \r\n        Project project = projectManager.load(Long.valueOf(fields.get(0)));\r\n        Long userId = Long.valueOf(fields.get(1));\r\n        ThreadContext.bind(SecurityUtils.asSubject(userId));\r\n\r\n        String refUpdateInfo = null;\r\n        Enumeration<String> paramNames = request.getParameterNames();\r\n        while (paramNames.hasMoreElements()) {\r\n        \tString paramName = paramNames.nextElement();\r\n        \tif (paramName.contains(\" \")) {\r\n        \t\trefUpdateInfo = paramName;\r\n        \t} \r\n        }\r\n        Preconditions.checkState(refUpdateInfo != null, \"Git ref update information is not available\");\r\n\r\n\t\tOutput output = new Output(response.getOutputStream());\r\n        \r\n        /*\r\n         * If multiple refs are updated, the hook stdin will put each ref update info into\r\n         * a separate line, however the line breaks is omitted when forward the hook stdin\r\n         * to curl via \"@-\", below logic is used to parse these info correctly even \r\n         * without line breaks.  \r\n         */\r\n        refUpdateInfo = StringUtils.reverse(StringUtils.remove(refUpdateInfo, '\\n'));\r\n        \r\n        fields.clear();\r\n        fields.addAll(StringUtils.splitAndTrim(refUpdateInfo, \" \"));\r\n\r\n        List<ImmutableTriple<String, ObjectId, ObjectId>> eventData = new ArrayList<>();\r\n        \r\n        int pos = 0;\r\n        while (true) {\r\n        \tString refName = StringUtils.reverse(fields.get(pos));\r\n        \tpos++;\r\n        \tObjectId newObjectId = ObjectId.fromString(StringUtils.reverse(fields.get(pos)));\r\n        \tpos++;\r\n        \tString field = fields.get(pos);\r\n        \tObjectId oldObjectId = ObjectId.fromString(StringUtils.reverse(field.substring(0, 40)));\r\n        \t\r\n        \tString branch = GitUtils.ref2branch(refName);\r\n        \tif (branch != null && project.getDefaultBranch() == null) {\r\n        \t\tRefUpdate refUpdate = GitUtils.getRefUpdate(project.getRepository(), \"HEAD\");\r\n        \t\tGitUtils.linkRef(refUpdate, refName);\r\n        \t}\r\n\r\n        \tif (branch != null && project.getDefaultBranch() != null && !branch.equals(project.getDefaultBranch()))\r\n        \t\tshowPullRequestLink(output, project, branch);\r\n        \t\r\n        \teventData.add(new ImmutableTriple<>(refName, oldObjectId, newObjectId));\r\n    \t\t\r\n        \tfield = field.substring(40);\r\n        \tif (field.length() == 0)\r\n        \t\tbreak;\r\n        \telse\r\n        \t\tfields.set(pos, field);\r\n        }\r\n        \r\n        Long projectId = project.getId();\r\n        \r\n        sessionManager.runAsync(new Runnable() {\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic void run() {\r\n\t\t        try {\r\n\t\t        \t// We can not use a hibernate entity safely in a different thread. Let's reload it \r\n\t\t            Project project = projectManager.load(projectId);\r\n\r\n\t\t            for (ImmutableTriple<String, ObjectId, ObjectId> each: eventData) {\r\n\t\t            \tString refName = each.getLeft();\r\n\t\t            \tObjectId oldObjectId = each.getMiddle();\r\n\t\t            \tObjectId newObjectId = each.getRight();\r\n\t\t\t        \tif (!newObjectId.equals(ObjectId.zeroId()))\r\n\t\t\t        \t\tproject.cacheObjectId(refName, newObjectId);\r\n\t\t\t        \telse \r\n\t\t\t        \t\tproject.cacheObjectId(refName, null);\r\n\t\t            \t\r\n\t\t\t        \tlistenerRegistry.post(new RefUpdated(project, refName, oldObjectId, newObjectId));\r\n\t\t            }\r\n\t\t        } catch (Exception e) {\r\n\t\t        \tlogger.error(\"Error posting ref updated event\", e);\r\n\t\t\t\t}\r\n\t\t\t}\r\n        \t\r\n        });\r\n\t}\r\n\r\n\tprivate void showPullRequestLink(Output output, Project project, String branch) {\r\n    \toutput.writeLine();\r\n    \toutput.writeLine(\"Create a pull request for '\"+ branch +\"' by visiting:\");\r\n\t\toutput.writeLine(\"    \" + project.getUrl() \r\n\t\t\t\t+\"/pulls/new?target=\" \r\n\t\t\t\t+ project.getId() \r\n\t\t\t\t+ \":\" \r\n\t\t\t\t+ project.getDefaultBranch() \r\n\t\t\t\t+ \"&source=\" \r\n\t\t\t\t+ project.getId()\r\n\t\t\t\t+ \":\"\r\n\t\t\t\t+ branch);\r\n\t\toutput.writeLine();\r\n\t}\r\n\t\r\n}\r\n", "package io.onedev.server.git.hookcallback;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.annotation.Nullable;\nimport javax.inject.Inject;\nimport javax.inject.Singleton;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.eclipse.jgit.lib.Constants;\nimport org.eclipse.jgit.lib.ObjectId;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.Lists;\n\nimport io.onedev.commons.utils.ExplicitException;\nimport io.onedev.commons.utils.StringUtils;\nimport io.onedev.server.entitymanager.ProjectManager;\nimport io.onedev.server.git.GitUtils;\nimport io.onedev.server.model.Project;\nimport io.onedev.server.model.PullRequest;\nimport io.onedev.server.model.PullRequestUpdate;\nimport io.onedev.server.model.User;\nimport io.onedev.server.model.support.BranchProtection;\nimport io.onedev.server.model.support.TagProtection;\nimport io.onedev.server.persistence.annotation.Sessional;\nimport io.onedev.server.security.SecurityUtils;\nimport io.onedev.server.security.permission.ManageProject;\nimport io.onedev.server.security.permission.ProjectPermission;\n\n@SuppressWarnings(\"serial\")\n@Singleton\npublic class GitPreReceiveCallback extends HttpServlet {\n\n\tpublic static final String PATH = \"/git-prereceive-callback\";\n\n\tprivate final ProjectManager projectManager;\n\t\n\t@Inject\n\tpublic GitPreReceiveCallback(ProjectManager projectManager) {\n\t\tthis.projectManager = projectManager;\n\t}\n\t\n\tprivate void error(Output output, @Nullable String refName, List<String> messages) {\n\t\toutput.markError();\n\t\toutput.writeLine();\n\t\toutput.writeLine(\"*******************************************************\");\n\t\toutput.writeLine(\"*\");\n\t\tif (refName != null)\n\t\t\toutput.writeLine(\"*  ERROR PUSHING REF: \" + refName);\n\t\telse\n\t\t\toutput.writeLine(\"*  ERROR PUSHING\");\n\t\toutput.writeLine(\"-------------------------------------------------------\");\n\t\tfor (String message: messages)\n\t\t\toutput.writeLine(\"*  \" + message);\n\t\toutput.writeLine(\"*\");\n\t\toutput.writeLine(\"*******************************************************\");\n\t\toutput.writeLine();\n\t}\n\t\n\t@Sessional\n\t@Override\n\tprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        List<String> fields = StringUtils.splitAndTrim(request.getPathInfo(), \"/\");\n        Preconditions.checkState(fields.size() == 3);\n        \n        if (!fields.get(2).equals(GitUtils.HOOK_TOKEN)) {\n            response.sendError(HttpServletResponse.SC_FORBIDDEN,\n                    \"Git hook callbacks can only be accessed by OneDev itself\");\n            return;\n        }\n        \n        SecurityUtils.getSubject().runAs(SecurityUtils.asPrincipal(Long.valueOf(fields.get(1))));\n        try {\n            Project project = projectManager.load(Long.valueOf(fields.get(0)));\n            \n            String refUpdateInfo = null;\n            \n            /*\n             * Since git 2.11, pushed commits will be placed in to a QUARANTINE directory when pre-receive hook \n             * is fired. Current version of jgit does not pick up objects in this directory so we should call \n             * native git instead with various environments passed from pre-receive hook   \n             */\n            Map<String, String> gitEnvs = new HashMap<>();\n            Enumeration<String> paramNames = request.getParameterNames();\n            while (paramNames.hasMoreElements()) {\n            \tString paramName = paramNames.nextElement();\n            \tif (paramName.contains(\" \")) {\n            \t\trefUpdateInfo = paramName;\n            \t} else if (paramName.startsWith(\"ENV_\")) {\n            \t\tString paramValue = request.getParameter(paramName);\n            \t\tif (StringUtils.isNotBlank(paramValue))\n            \t\t\tgitEnvs.put(paramName.substring(\"ENV_\".length()), paramValue);\n            \t}\n            }\n            \n            Preconditions.checkState(refUpdateInfo != null, \"Git ref update information is not available\");\n            \n\t        Output output = new Output(response.getOutputStream());\n\t        \n\t        /*\n\t         * If multiple refs are updated, the hook stdin will put each ref update info into\n\t         * a separate line, however the line breaks is omitted when forward the hook stdin\n\t         * to curl via \"@-\", below logic is used to parse these info correctly even \n\t         * without line breaks.  \n\t         */\n\t        refUpdateInfo = StringUtils.reverse(StringUtils.remove(refUpdateInfo, '\\n'));\n\t        fields = StringUtils.splitAndTrim(refUpdateInfo, \" \");\n\t        \n\t        int pos = 0;\n\t        while (true) {\n\t        \tString refName = StringUtils.reverse(fields.get(pos));\n\t        \tpos++;\n\t        \tObjectId newObjectId = ObjectId.fromString(StringUtils.reverse(fields.get(pos)));\n\t        \tpos++;\n\t        \tString field = fields.get(pos);\n\t        \tObjectId oldObjectId = ObjectId.fromString(StringUtils.reverse(field.substring(0, 40)));\n\t        \t\n\t    \t\tUser user = Preconditions.checkNotNull(SecurityUtils.getUser());\n\n\t    \t\tif (refName.startsWith(PullRequest.REFS_PREFIX) || refName.startsWith(PullRequestUpdate.REFS_PREFIX)) {\n\t    \t\t\tif (!user.asSubject().isPermitted(new ProjectPermission(project, new ManageProject()))) {\n\t    \t\t\t\terror(output, refName, Lists.newArrayList(\"Only project administrators can update onedev refs.\"));\n\t    \t\t\t\tbreak;\n\t    \t\t\t}\n\t    \t\t} else if (refName.startsWith(Constants.R_HEADS)) {\n\t    \t\t\tString branchName = Preconditions.checkNotNull(GitUtils.ref2branch(refName));\n\t    \t\t\tList<String> errorMessages = new ArrayList<>();\n\t    \t\t\tBranchProtection protection = project.getHierarchyBranchProtection(branchName, user);\n\t\t\t\t\tif (oldObjectId.equals(ObjectId.zeroId())) {\n\t\t\t\t\t\tif (protection.isPreventCreation()) {\n\t\t\t\t\t\t\terrorMessages.add(\"Can not create this branch according to branch protection setting\");\n\t\t\t\t\t\t} else if (protection.isSignatureRequired() \n\t\t\t\t\t\t\t\t&& !project.hasValidCommitSignature(newObjectId, gitEnvs)) {\n\t\t\t\t\t\t\terrorMessages.add(\"Can not create this branch as branch protection setting \"\n\t\t\t\t\t\t\t\t\t+ \"requires valid signature on head commit\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (newObjectId.equals(ObjectId.zeroId())) {\n\t\t\t\t\t\tif (protection.isPreventDeletion()) \n\t\t\t\t\t\t\terrorMessages.add(\"Can not delete this branch according to branch protection setting\");\n\t\t\t\t\t} else if (protection.isPreventForcedPush() \n\t\t\t\t\t\t\t&& !GitUtils.isMergedInto(project.getRepository(), gitEnvs, oldObjectId, newObjectId)) {\n\t\t\t\t\t\terrorMessages.add(\"Can not force-push to this branch according to branch protection setting\");\n\t\t\t\t\t} else if (protection.isSignatureRequired() \n\t\t\t\t\t\t\t&& !project.hasValidCommitSignature(newObjectId, gitEnvs)) {\n\t\t\t\t\t\terrorMessages.add(\"Can not push to this branch as branch protection rule requires \"\n\t\t\t\t\t\t\t\t+ \"valid signature for head commit\");\n\t\t\t\t\t} else if (protection.isReviewRequiredForPush(user, project, branchName, oldObjectId, newObjectId, gitEnvs)) {\n    \t\t\t\t\terrorMessages.add(\"Review required for your change. Please submit pull request instead\");\n\t\t\t\t\t}\n\t    \t\t\tif (errorMessages.isEmpty() \n\t    \t\t\t\t\t&& !oldObjectId.equals(ObjectId.zeroId()) \n\t    \t\t\t\t\t&& !newObjectId.equals(ObjectId.zeroId()) \n\t    \t\t\t\t\t&& project.isBuildRequiredForPush(user, branchName, oldObjectId, newObjectId, gitEnvs)) {\n\t    \t\t\t\terrorMessages.add(\"Build required for your change. Please submit pull request instead\");\n\t    \t\t\t}\n\t    \t\t\tif (errorMessages.isEmpty() && newObjectId.equals(ObjectId.zeroId())) {\n\t    \t\t\t\ttry {\n\t    \t\t\t\t\tprojectManager.onDeleteBranch(project, branchName);\n\t    \t\t\t\t} catch (ExplicitException e) {\n\t    \t\t\t\t\terrorMessages.addAll(Splitter.on(\"\\n\").splitToList(e.getMessage()));\n\t    \t\t\t\t}\n\t    \t\t\t}\n\t\t\t\t\tif (!errorMessages.isEmpty())\n\t\t\t\t\t\terror(output, refName, errorMessages);\n\t    \t\t} else if (refName.startsWith(Constants.R_TAGS)) {\n\t    \t\t\tString tagName = Preconditions.checkNotNull(GitUtils.ref2tag(refName));\n\t    \t\t\tList<String> errorMessages = new ArrayList<>();\n\t    \t\t\tTagProtection protection = project.getHierarchyTagProtection(tagName, user);\n\t\t\t\t\tif (oldObjectId.equals(ObjectId.zeroId())) {\n\t\t\t\t\t\tif (protection.isPreventCreation()) {\n\t\t\t\t\t\t\terrorMessages.add(\"Can not create this tag according to tag protection setting\");\n\t\t\t\t\t\t} else if (protection.isSignatureRequired() \n\t\t\t\t\t\t\t\t&& !project.hasValidTagSignature(newObjectId, gitEnvs)) {\n\t\t\t\t\t\t\terrorMessages.add(\"Can not create this tag as tag protection setting requires \"\n\t\t\t\t\t\t\t\t\t+ \"valid tag signature\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (newObjectId.equals(ObjectId.zeroId())) {\n\t\t\t\t\t\tif (protection.isPreventDeletion())\n\t\t\t\t\t\t\terrorMessages.add(\"Can not delete this tag according to tag protection setting\");\n\t\t\t\t\t} else if (protection.isPreventUpdate()) {\n\t\t\t\t\t\terrorMessages.add(\"Can not update this tag according to tag protection setting\");\n\t\t\t\t\t} else if (protection.isSignatureRequired() \n\t\t\t\t\t\t\t&& !project.hasValidTagSignature(newObjectId, gitEnvs)) {\n\t\t\t\t\t\terrorMessages.add(\"Can not update this tag as tag protection setting requires \"\n\t\t\t\t\t\t\t\t+ \"valid tag signature\");\n\t\t\t\t\t}\n\t    \t\t\tif (errorMessages.isEmpty() && newObjectId.equals(ObjectId.zeroId())) {\n\t    \t\t\t\ttry {\n\t    \t\t\t\t\tprojectManager.onDeleteTag(project, tagName);\n\t    \t\t\t\t} catch (ExplicitException e) {\n\t    \t\t\t\t\terrorMessages.addAll(Splitter.on(\"\\n\").splitToList(e.getMessage()));\n\t    \t\t\t\t}\n\t    \t\t\t}\n\t\t\t\t\tif (!errorMessages.isEmpty())\n\t\t\t\t\t\terror(output, refName, errorMessages);\n\t    \t\t}\n\t    \t\t\n\t        \tfield = field.substring(40);\n\t        \tif (field.length() == 0)\n\t        \t\tbreak;\n\t        \telse\n\t        \t\tfields.set(pos, field);\n\t        }\n        } finally {\n        \tSecurityUtils.getSubject().releaseRunAs();\n        }\t\t\n\t}\t\n}\n", "#!/usr/bin/env bash\nunset http_proxy\nunset https_proxy\nIFS=$'\\r\\n'; \nlines=($(${ONEDEV_CURL} -k -s -S -f -X POST --data-urlencode \"ENV_GIT_ALTERNATE_OBJECT_DIRECTORIES=${GIT_ALTERNATE_OBJECT_DIRECTORIES}\" --data-urlencode \"ENV_GIT_OBJECT_DIRECTORY=${GIT_OBJECT_DIRECTORY}\" --data-urlencode \"ENV_GIT_QUARANTINE_PATH=${GIT_QUARANTINE_PATH}\" -d @- ${ONEDEV_URL}/%s/${ONEDEV_REPOSITORY_ID}/${ONEDEV_USER_ID}/${ONEDEV_HOOK_TOKEN} 2>&1))\n\nreturnCode=0;\n\nfor i in ${lines[@]}\ndo\n  if [ \"$i\" = \"ERROR\" ]; then \n    returnCode=1\n  else\n    if [[ $i == curl:* ]]; then\n      returnCode=1\n    fi;\n    echo \"$i\"\n  fi;\ndone\n\nexit $returnCode"], "filenames": ["server-core/src/main/java/io/onedev/server/entitymanager/impl/DefaultProjectManager.java", "server-core/src/main/java/io/onedev/server/git/GitFilter.java", "server-core/src/main/java/io/onedev/server/git/GitSshCommand.java", "server-core/src/main/java/io/onedev/server/git/GitUtils.java", "server-core/src/main/java/io/onedev/server/git/hookcallback/GitPostReceiveCallback.java", "server-core/src/main/java/io/onedev/server/git/hookcallback/GitPreReceiveCallback.java", "server-core/src/main/resources/git-receive-hook"], "buggy_code_start_loc": [540, 145, 77, 18, 4, 4, 5], "buggy_code_end_loc": [541, 145, 77, 99, 70, 85, 6], "fixing_code_start_loc": [540, 146, 78, 19, 3, 3, 5], "fixing_code_end_loc": [541, 147, 79, 103, 65, 80, 6], "type": "CWE-287", "message": "Onedev is an open source, self-hosted Git Server with CI/CD and Kanban. In versions of Onedev prior to 7.3.0 unauthenticated users can take over a OneDev instance if there is no properly configured reverse proxy. The /git-prereceive-callback endpoint is used by the pre-receive git hook on the server to check for branch protections during a push event. It is only intended to be accessed from localhost, but the check relies on the X-Forwarded-For header. Invoking this endpoint leads to the execution of one of various git commands. The environment variables of this command execution can be controlled via query parameters. This allows attackers to write to arbitrary files, which can in turn lead to the execution of arbitrary code. Such an attack would be very hard to detect, which increases the potential impact even more. Users are advised to upgrade. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-39205", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-13T19:15:13.093", "lastModified": "2022-10-01T02:18:36.193", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Onedev is an open source, self-hosted Git Server with CI/CD and Kanban. In versions of Onedev prior to 7.3.0 unauthenticated users can take over a OneDev instance if there is no properly configured reverse proxy. The /git-prereceive-callback endpoint is used by the pre-receive git hook on the server to check for branch protections during a push event. It is only intended to be accessed from localhost, but the check relies on the X-Forwarded-For header. Invoking this endpoint leads to the execution of one of various git commands. The environment variables of this command execution can be controlled via query parameters. This allows attackers to write to arbitrary files, which can in turn lead to the execution of arbitrary code. Such an attack would be very hard to detect, which increases the potential impact even more. Users are advised to upgrade. There are no known workarounds for this issue."}, {"lang": "es", "value": "Onedev es un servidor Git de c\u00f3digo abierto, auto-alojado con CI/CD y Kanban. En versiones de Onedev anteriores a 7.3.0, los usuarios no autenticados pueden tomar el control de una instancia de OneDev si no se presenta un proxy inverso configurado apropiadamente. El endpoint /git-prereceive-callback es usado por el hook git pre-receive en el servidor para comprobar las protecciones de las ramas durante un evento push. S\u00f3lo puede accederse a \u00e9l desde localhost, pero la comprobaci\u00f3n es basada en la cabecera X-Forwarded-For. La invocaci\u00f3n de este endpoint conlleva a una ejecuci\u00f3n de uno de varios comandos de git. Las variables de entorno de la ejecuci\u00f3n de este comando pueden ser controladas por medio de par\u00e1metros de consulta. Esto permite a atacantes escribir en archivos arbitrarios, lo que a su vez puede conllevar a una ejecuci\u00f3n de c\u00f3digo arbitrario. Un ataque de este tipo ser\u00eda muy dif\u00edcil de detectar, lo que aumenta a\u00fan m\u00e1s el impacto potencial. Es recomendado a usuarios actualizar. No se presentan mitigaciones conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.2, "impactScore": 6.0}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:onedev_project:onedev:*:*:*:*:*:*:*:*", "versionEndExcluding": "7.3.0", "matchCriteriaId": "EC376576-D05E-4FBF-8E5E-CB81C3965142"}]}]}], "references": [{"url": "https://blog.sonarsource.com/onedev-remote-code-execution/", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/theonedev/onedev/commit/f1e97688e4e19d6de1dfa1d00e04655209d39f8e", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/theonedev/onedev/releases/tag/v7.3.0", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/theonedev/onedev/security/advisories/GHSA-4f9h-h82c-4xm2", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/theonedev/onedev/commit/f1e97688e4e19d6de1dfa1d00e04655209d39f8e"}}