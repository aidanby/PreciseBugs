{"buggy_code": ["<?php\n\n/*\n * This file is part of Twig.\n *\n * (c) Fabien Potencier\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Twig\\Loader;\n\nuse Twig\\Error\\LoaderError;\nuse Twig\\Source;\n\n/**\n * Loads template from the filesystem.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass FilesystemLoader implements LoaderInterface, ExistsLoaderInterface, SourceContextLoaderInterface\n{\n    /** Identifier of the main namespace. */\n    public const MAIN_NAMESPACE = '__main__';\n\n    protected $paths = [];\n    protected $cache = [];\n    protected $errorCache = [];\n\n    private $rootPath;\n\n    /**\n     * @param string|array $paths    A path or an array of paths where to look for templates\n     * @param string|null  $rootPath The root path common to all relative paths (null for getcwd())\n     */\n    public function __construct($paths = [], $rootPath = null)\n    {\n        $this->rootPath = (null === $rootPath ? getcwd() : $rootPath).\\DIRECTORY_SEPARATOR;\n        if (null !== $rootPath && false !== ($realPath = realpath($rootPath))) {\n            $this->rootPath = $realPath.\\DIRECTORY_SEPARATOR;\n        }\n\n        if ($paths) {\n            $this->setPaths($paths);\n        }\n    }\n\n    /**\n     * Returns the paths to the templates.\n     *\n     * @param string $namespace A path namespace\n     *\n     * @return array The array of paths where to look for templates\n     */\n    public function getPaths($namespace = self::MAIN_NAMESPACE)\n    {\n        return isset($this->paths[$namespace]) ? $this->paths[$namespace] : [];\n    }\n\n    /**\n     * Returns the path namespaces.\n     *\n     * The main namespace is always defined.\n     *\n     * @return array The array of defined namespaces\n     */\n    public function getNamespaces()\n    {\n        return array_keys($this->paths);\n    }\n\n    /**\n     * Sets the paths where templates are stored.\n     *\n     * @param string|array $paths     A path or an array of paths where to look for templates\n     * @param string       $namespace A path namespace\n     */\n    public function setPaths($paths, $namespace = self::MAIN_NAMESPACE)\n    {\n        if (!\\is_array($paths)) {\n            $paths = [$paths];\n        }\n\n        $this->paths[$namespace] = [];\n        foreach ($paths as $path) {\n            $this->addPath($path, $namespace);\n        }\n    }\n\n    /**\n     * Adds a path where templates are stored.\n     *\n     * @param string $path      A path where to look for templates\n     * @param string $namespace A path namespace\n     *\n     * @throws LoaderError\n     */\n    public function addPath($path, $namespace = self::MAIN_NAMESPACE)\n    {\n        // invalidate the cache\n        $this->cache = $this->errorCache = [];\n\n        $checkPath = $this->isAbsolutePath($path) ? $path : $this->rootPath.$path;\n        if (!is_dir($checkPath)) {\n            throw new LoaderError(sprintf('The \"%s\" directory does not exist (\"%s\").', $path, $checkPath));\n        }\n\n        $this->paths[$namespace][] = rtrim($path, '/\\\\');\n    }\n\n    /**\n     * Prepends a path where templates are stored.\n     *\n     * @param string $path      A path where to look for templates\n     * @param string $namespace A path namespace\n     *\n     * @throws LoaderError\n     */\n    public function prependPath($path, $namespace = self::MAIN_NAMESPACE)\n    {\n        // invalidate the cache\n        $this->cache = $this->errorCache = [];\n\n        $checkPath = $this->isAbsolutePath($path) ? $path : $this->rootPath.$path;\n        if (!is_dir($checkPath)) {\n            throw new LoaderError(sprintf('The \"%s\" directory does not exist (\"%s\").', $path, $checkPath));\n        }\n\n        $path = rtrim($path, '/\\\\');\n\n        if (!isset($this->paths[$namespace])) {\n            $this->paths[$namespace][] = $path;\n        } else {\n            array_unshift($this->paths[$namespace], $path);\n        }\n    }\n\n    public function getSource($name)\n    {\n        @trigger_error(sprintf('Calling \"getSource\" on \"%s\" is deprecated since 1.27. Use getSourceContext() instead.', static::class), \\E_USER_DEPRECATED);\n\n        if (null === ($path = $this->findTemplate($name)) || false === $path) {\n            return '';\n        }\n\n        return file_get_contents($path);\n    }\n\n    public function getSourceContext($name)\n    {\n        if (null === ($path = $this->findTemplate($name)) || false === $path) {\n            return new Source('', $name, '');\n        }\n\n        return new Source(file_get_contents($path), $name, $path);\n    }\n\n    public function getCacheKey($name)\n    {\n        if (null === ($path = $this->findTemplate($name)) || false === $path) {\n            return '';\n        }\n        $len = \\strlen($this->rootPath);\n        if (0 === strncmp($this->rootPath, $path, $len)) {\n            return substr($path, $len);\n        }\n\n        return $path;\n    }\n\n    public function exists($name)\n    {\n        $name = $this->normalizeName($name);\n\n        if (isset($this->cache[$name])) {\n            return true;\n        }\n\n        try {\n            return null !== ($path = $this->findTemplate($name, false)) && false !== $path;\n        } catch (LoaderError $e) {\n            @trigger_error(sprintf('In %s::findTemplate(), you must accept a second argument that when set to \"false\" returns \"false\" instead of throwing an exception. Not supporting this argument is deprecated since version 1.27.', static::class), \\E_USER_DEPRECATED);\n\n            return false;\n        }\n    }\n\n    public function isFresh($name, $time)\n    {\n        // false support to be removed in 3.0\n        if (null === ($path = $this->findTemplate($name)) || false === $path) {\n            return false;\n        }\n\n        return filemtime($path) < $time;\n    }\n\n    /**\n     * Checks if the template can be found.\n     *\n     * @param string $name The template name\n     *\n     * @return string|false|null The template name or false/null\n     */\n    protected function findTemplate($name)\n    {\n        $throw = \\func_num_args() > 1 ? func_get_arg(1) : true;\n        $name = $this->normalizeName($name);\n\n        if (isset($this->cache[$name])) {\n            return $this->cache[$name];\n        }\n\n        if (isset($this->errorCache[$name])) {\n            if (!$throw) {\n                return false;\n            }\n\n            throw new LoaderError($this->errorCache[$name]);\n        }\n\n        try {\n            $this->validateName($name);\n\n            list($namespace, $shortname) = $this->parseName($name);\n        } catch (LoaderError $e) {\n            if (!$throw) {\n                return false;\n            }\n\n            throw $e;\n        }\n\n        if (!isset($this->paths[$namespace])) {\n            $this->errorCache[$name] = sprintf('There are no registered paths for namespace \"%s\".', $namespace);\n\n            if (!$throw) {\n                return false;\n            }\n\n            throw new LoaderError($this->errorCache[$name]);\n        }\n\n        foreach ($this->paths[$namespace] as $path) {\n            if (!$this->isAbsolutePath($path)) {\n                $path = $this->rootPath.$path;\n            }\n\n            if (is_file($path.'/'.$shortname)) {\n                if (false !== $realpath = realpath($path.'/'.$shortname)) {\n                    return $this->cache[$name] = $realpath;\n                }\n\n                return $this->cache[$name] = $path.'/'.$shortname;\n            }\n        }\n\n        $this->errorCache[$name] = sprintf('Unable to find template \"%s\" (looked into: %s).', $name, implode(', ', $this->paths[$namespace]));\n\n        if (!$throw) {\n            return false;\n        }\n\n        throw new LoaderError($this->errorCache[$name]);\n    }\n\n    protected function parseName($name, $default = self::MAIN_NAMESPACE)\n    {\n        if (isset($name[0]) && '@' == $name[0]) {\n            if (false === $pos = strpos($name, '/')) {\n                throw new LoaderError(sprintf('Malformed namespaced template name \"%s\" (expecting \"@namespace/template_name\").', $name));\n            }\n\n            $namespace = substr($name, 1, $pos - 1);\n            $shortname = substr($name, $pos + 1);\n\n            return [$namespace, $shortname];\n        }\n\n        return [$default, $name];\n    }\n\n    protected function normalizeName($name)\n    {\n        return preg_replace('#/{2,}#', '/', str_replace('\\\\', '/', (string) $name));\n    }\n\n    protected function validateName($name)\n    {\n        if (false !== strpos($name, \"\\0\")) {\n            throw new LoaderError('A template name cannot contain NUL bytes.');\n        }\n\n        $name = ltrim($name, '/');\n        $parts = explode('/', $name);\n        $level = 0;\n        foreach ($parts as $part) {\n            if ('..' === $part) {\n                --$level;\n            } elseif ('.' !== $part) {\n                ++$level;\n            }\n\n            if ($level < 0) {\n                throw new LoaderError(sprintf('Looks like you try to load a template outside configured directories (%s).', $name));\n            }\n        }\n    }\n\n    private function isAbsolutePath($file)\n    {\n        return strspn($file, '/\\\\', 0, 1)\n            || (\\strlen($file) > 3 && ctype_alpha($file[0])\n                && ':' === substr($file, 1, 1)\n                && strspn($file, '/\\\\', 2, 1)\n            )\n            || null !== parse_url($file, \\PHP_URL_SCHEME)\n        ;\n    }\n}\n\nclass_alias('Twig\\Loader\\FilesystemLoader', 'Twig_Loader_Filesystem');\n", "<?php\n\nnamespace Twig\\Tests\\Loader;\n\n/*\n * This file is part of Twig.\n *\n * (c) Fabien Potencier\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nuse Twig\\Environment;\nuse Twig\\Error\\LoaderError;\nuse Twig\\Loader\\FilesystemLoader;\n\nclass FilesystemTest extends \\PHPUnit\\Framework\\TestCase\n{\n    public function testGetSourceContext()\n    {\n        $path = __DIR__.'/../Fixtures';\n        $loader = new FilesystemLoader([$path]);\n        $this->assertEquals('errors/index.html', $loader->getSourceContext('errors/index.html')->getName());\n        $this->assertEquals(realpath($path.'/errors/index.html'), realpath($loader->getSourceContext('errors/index.html')->getPath()));\n    }\n\n    /**\n     * @dataProvider getSecurityTests\n     */\n    public function testSecurity($template)\n    {\n        $loader = new FilesystemLoader([__DIR__.'/../Fixtures']);\n\n        try {\n            $loader->getCacheKey($template);\n            $this->fail();\n        } catch (LoaderError $e) {\n            $this->assertStringNotContainsString('Unable to find template', $e->getMessage());\n        }\n    }\n\n    public function getSecurityTests()\n    {\n        return [\n            [\"AutoloaderTest\\0.php\"],\n            ['..\\\\AutoloaderTest.php'],\n            ['..\\\\\\\\\\\\AutoloaderTest.php'],\n            ['../AutoloaderTest.php'],\n            ['..////AutoloaderTest.php'],\n            ['./../AutoloaderTest.php'],\n            ['.\\\\..\\\\AutoloaderTest.php'],\n            ['././././././../AutoloaderTest.php'],\n            ['.\\\\./.\\\\./.\\\\./../AutoloaderTest.php'],\n            ['foo/../../AutoloaderTest.php'],\n            ['foo\\\\..\\\\..\\\\AutoloaderTest.php'],\n            ['foo/../bar/../../AutoloaderTest.php'],\n            ['foo/bar/../../../AutoloaderTest.php'],\n            ['filters/../../AutoloaderTest.php'],\n            ['filters//..//..//AutoloaderTest.php'],\n            ['filters\\\\..\\\\..\\\\AutoloaderTest.php'],\n            ['filters\\\\\\\\..\\\\\\\\..\\\\\\\\AutoloaderTest.php'],\n            ['filters\\\\//../\\\\/\\\\..\\\\AutoloaderTest.php'],\n            ['/../AutoloaderTest.php'],\n        ];\n    }\n\n    /**\n     * @dataProvider getBasePaths\n     */\n    public function testPaths($basePath, $cacheKey, $rootPath)\n    {\n        $loader = new FilesystemLoader([$basePath.'/normal', $basePath.'/normal_bis'], $rootPath);\n        $loader->setPaths([$basePath.'/named', $basePath.'/named_bis'], 'named');\n        $loader->addPath($basePath.'/named_ter', 'named');\n        $loader->addPath($basePath.'/normal_ter');\n        $loader->prependPath($basePath.'/normal_final');\n        $loader->prependPath($basePath.'/named/../named_quater', 'named');\n        $loader->prependPath($basePath.'/named_final', 'named');\n\n        $this->assertEquals([\n            $basePath.'/normal_final',\n            $basePath.'/normal',\n            $basePath.'/normal_bis',\n            $basePath.'/normal_ter',\n        ], $loader->getPaths());\n        $this->assertEquals([\n            $basePath.'/named_final',\n            $basePath.'/named/../named_quater',\n            $basePath.'/named',\n            $basePath.'/named_bis',\n            $basePath.'/named_ter',\n        ], $loader->getPaths('named'));\n\n        // do not use realpath here as it would make the test unuseful\n        $this->assertEquals($cacheKey, str_replace('\\\\', '/', $loader->getCacheKey('@named/named_absolute.html')));\n        $this->assertEquals(\"path (final)\\n\", $loader->getSourceContext('index.html')->getCode());\n        $this->assertEquals(\"path (final)\\n\", $loader->getSourceContext('@__main__/index.html')->getCode());\n        $this->assertEquals(\"named path (final)\\n\", $loader->getSourceContext('@named/index.html')->getCode());\n    }\n\n    public function getBasePaths()\n    {\n        return [\n            [\n                __DIR__.'/Fixtures',\n                'tests/Loader/Fixtures/named_quater/named_absolute.html',\n                null,\n            ],\n            [\n                __DIR__.'/Fixtures/../Fixtures',\n                'tests/Loader/Fixtures/named_quater/named_absolute.html',\n                null,\n            ],\n            [\n                'tests/Loader/Fixtures',\n                'tests/Loader/Fixtures/named_quater/named_absolute.html',\n                getcwd(),\n            ],\n            [\n                'Fixtures',\n                'Fixtures/named_quater/named_absolute.html',\n                getcwd().'/tests/Loader',\n            ],\n            [\n                'Fixtures',\n                'Fixtures/named_quater/named_absolute.html',\n                getcwd().'/tests/../tests/Loader',\n            ],\n        ];\n    }\n\n    public function testEmptyConstructor()\n    {\n        $loader = new FilesystemLoader();\n        $this->assertEquals([], $loader->getPaths());\n    }\n\n    public function testGetNamespaces()\n    {\n        $loader = new FilesystemLoader(sys_get_temp_dir());\n        $this->assertEquals([FilesystemLoader::MAIN_NAMESPACE], $loader->getNamespaces());\n\n        $loader->addPath(sys_get_temp_dir(), 'named');\n        $this->assertEquals([FilesystemLoader::MAIN_NAMESPACE, 'named'], $loader->getNamespaces());\n    }\n\n    public function testFindTemplateExceptionNamespace()\n    {\n        $basePath = __DIR__.'/Fixtures';\n\n        $loader = new FilesystemLoader([$basePath.'/normal']);\n        $loader->addPath($basePath.'/named', 'named');\n\n        try {\n            $loader->getSourceContext('@named/nowhere.html');\n        } catch (\\Exception $e) {\n            $this->assertInstanceOf('\\Twig\\Error\\LoaderError', $e);\n            $this->assertStringContainsString('Unable to find template \"@named/nowhere.html\"', $e->getMessage());\n        }\n    }\n\n    public function testFindTemplateWithCache()\n    {\n        $basePath = __DIR__.'/Fixtures';\n\n        $loader = new FilesystemLoader([$basePath.'/normal']);\n        $loader->addPath($basePath.'/named', 'named');\n\n        // prime the cache for index.html in the named namespace\n        $namedSource = $loader->getSourceContext('@named/index.html')->getCode();\n        $this->assertEquals(\"named path\\n\", $namedSource);\n\n        // get index.html from the main namespace\n        $this->assertEquals(\"path\\n\", $loader->getSourceContext('index.html')->getCode());\n    }\n\n    public function testLoadTemplateAndRenderBlockWithCache()\n    {\n        $loader = new FilesystemLoader([]);\n        $loader->addPath(__DIR__.'/Fixtures/themes/theme2');\n        $loader->addPath(__DIR__.'/Fixtures/themes/theme1');\n        $loader->addPath(__DIR__.'/Fixtures/themes/theme1', 'default_theme');\n\n        $twig = new Environment($loader);\n\n        $template = $twig->load('blocks.html.twig');\n        $this->assertSame('block from theme 1', $template->renderBlock('b1', []));\n\n        $template = $twig->load('blocks.html.twig');\n        $this->assertSame('block from theme 2', $template->renderBlock('b2', []));\n    }\n\n    public function getArrayInheritanceTests()\n    {\n        return [\n            'valid array inheritance' => ['array_inheritance_valid_parent.html.twig'],\n            'array inheritance with null first template' => ['array_inheritance_null_parent.html.twig'],\n            'array inheritance with empty first template' => ['array_inheritance_empty_parent.html.twig'],\n            'array inheritance with non-existent first template' => ['array_inheritance_nonexistent_parent.html.twig'],\n        ];\n    }\n\n    /**\n     * @dataProvider getArrayInheritanceTests\n     *\n     * @param $templateName string Template name with array inheritance\n     */\n    public function testArrayInheritance($templateName)\n    {\n        $loader = new FilesystemLoader([]);\n        $loader->addPath(__DIR__.'/Fixtures/inheritance');\n\n        $twig = new Environment($loader);\n\n        $template = $twig->load($templateName);\n        $this->assertSame('VALID Child', $template->renderBlock('body', []));\n    }\n\n    /**\n     * @requires PHP 5.3\n     */\n    public function testLoadTemplateFromPhar()\n    {\n        $loader = new FilesystemLoader([]);\n        // phar-sample.phar was created with the following script:\n        // $f = new Phar('phar-test.phar');\n        // $f->addFromString('hello.twig', 'hello from phar');\n        $loader->addPath('phar://'.__DIR__.'/Fixtures/phar/phar-sample.phar');\n        $this->assertSame('hello from phar', $loader->getSourceContext('hello.twig')->getCode());\n    }\n\n    public function testTemplateExistsAlwaysReturnsBool()\n    {\n        $loader = new FilesystemLoader([]);\n        $this->assertFalse($loader->exists(\"foo\\0.twig\"));\n        $this->assertFalse($loader->exists('../foo.twig'));\n        $this->assertFalse($loader->exists('@foo'));\n        $this->assertFalse($loader->exists('foo'));\n        $this->assertFalse($loader->exists('@foo/bar.twig'));\n\n        $loader->addPath(__DIR__.'/Fixtures/normal');\n        $this->assertTrue($loader->exists('index.html'));\n        $loader->addPath(__DIR__.'/Fixtures/normal', 'foo');\n        $this->assertTrue($loader->exists('@foo/index.html'));\n    }\n}\n"], "fixing_code": ["<?php\n\n/*\n * This file is part of Twig.\n *\n * (c) Fabien Potencier\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nnamespace Twig\\Loader;\n\nuse Twig\\Error\\LoaderError;\nuse Twig\\Source;\n\n/**\n * Loads template from the filesystem.\n *\n * @author Fabien Potencier <fabien@symfony.com>\n */\nclass FilesystemLoader implements LoaderInterface, ExistsLoaderInterface, SourceContextLoaderInterface\n{\n    /** Identifier of the main namespace. */\n    public const MAIN_NAMESPACE = '__main__';\n\n    protected $paths = [];\n    protected $cache = [];\n    protected $errorCache = [];\n\n    private $rootPath;\n\n    /**\n     * @param string|array $paths    A path or an array of paths where to look for templates\n     * @param string|null  $rootPath The root path common to all relative paths (null for getcwd())\n     */\n    public function __construct($paths = [], $rootPath = null)\n    {\n        $this->rootPath = (null === $rootPath ? getcwd() : $rootPath).\\DIRECTORY_SEPARATOR;\n        if (null !== $rootPath && false !== ($realPath = realpath($rootPath))) {\n            $this->rootPath = $realPath.\\DIRECTORY_SEPARATOR;\n        }\n\n        if ($paths) {\n            $this->setPaths($paths);\n        }\n    }\n\n    /**\n     * Returns the paths to the templates.\n     *\n     * @param string $namespace A path namespace\n     *\n     * @return array The array of paths where to look for templates\n     */\n    public function getPaths($namespace = self::MAIN_NAMESPACE)\n    {\n        return isset($this->paths[$namespace]) ? $this->paths[$namespace] : [];\n    }\n\n    /**\n     * Returns the path namespaces.\n     *\n     * The main namespace is always defined.\n     *\n     * @return array The array of defined namespaces\n     */\n    public function getNamespaces()\n    {\n        return array_keys($this->paths);\n    }\n\n    /**\n     * Sets the paths where templates are stored.\n     *\n     * @param string|array $paths     A path or an array of paths where to look for templates\n     * @param string       $namespace A path namespace\n     */\n    public function setPaths($paths, $namespace = self::MAIN_NAMESPACE)\n    {\n        if (!\\is_array($paths)) {\n            $paths = [$paths];\n        }\n\n        $this->paths[$namespace] = [];\n        foreach ($paths as $path) {\n            $this->addPath($path, $namespace);\n        }\n    }\n\n    /**\n     * Adds a path where templates are stored.\n     *\n     * @param string $path      A path where to look for templates\n     * @param string $namespace A path namespace\n     *\n     * @throws LoaderError\n     */\n    public function addPath($path, $namespace = self::MAIN_NAMESPACE)\n    {\n        // invalidate the cache\n        $this->cache = $this->errorCache = [];\n\n        $checkPath = $this->isAbsolutePath($path) ? $path : $this->rootPath.$path;\n        if (!is_dir($checkPath)) {\n            throw new LoaderError(sprintf('The \"%s\" directory does not exist (\"%s\").', $path, $checkPath));\n        }\n\n        $this->paths[$namespace][] = rtrim($path, '/\\\\');\n    }\n\n    /**\n     * Prepends a path where templates are stored.\n     *\n     * @param string $path      A path where to look for templates\n     * @param string $namespace A path namespace\n     *\n     * @throws LoaderError\n     */\n    public function prependPath($path, $namespace = self::MAIN_NAMESPACE)\n    {\n        // invalidate the cache\n        $this->cache = $this->errorCache = [];\n\n        $checkPath = $this->isAbsolutePath($path) ? $path : $this->rootPath.$path;\n        if (!is_dir($checkPath)) {\n            throw new LoaderError(sprintf('The \"%s\" directory does not exist (\"%s\").', $path, $checkPath));\n        }\n\n        $path = rtrim($path, '/\\\\');\n\n        if (!isset($this->paths[$namespace])) {\n            $this->paths[$namespace][] = $path;\n        } else {\n            array_unshift($this->paths[$namespace], $path);\n        }\n    }\n\n    public function getSource($name)\n    {\n        @trigger_error(sprintf('Calling \"getSource\" on \"%s\" is deprecated since 1.27. Use getSourceContext() instead.', static::class), \\E_USER_DEPRECATED);\n\n        if (null === ($path = $this->findTemplate($name)) || false === $path) {\n            return '';\n        }\n\n        return file_get_contents($path);\n    }\n\n    public function getSourceContext($name)\n    {\n        if (null === ($path = $this->findTemplate($name)) || false === $path) {\n            return new Source('', $name, '');\n        }\n\n        return new Source(file_get_contents($path), $name, $path);\n    }\n\n    public function getCacheKey($name)\n    {\n        if (null === ($path = $this->findTemplate($name)) || false === $path) {\n            return '';\n        }\n        $len = \\strlen($this->rootPath);\n        if (0 === strncmp($this->rootPath, $path, $len)) {\n            return substr($path, $len);\n        }\n\n        return $path;\n    }\n\n    public function exists($name)\n    {\n        $name = $this->normalizeName($name);\n\n        if (isset($this->cache[$name])) {\n            return true;\n        }\n\n        try {\n            return null !== ($path = $this->findTemplate($name, false)) && false !== $path;\n        } catch (LoaderError $e) {\n            @trigger_error(sprintf('In %s::findTemplate(), you must accept a second argument that when set to \"false\" returns \"false\" instead of throwing an exception. Not supporting this argument is deprecated since version 1.27.', static::class), \\E_USER_DEPRECATED);\n\n            return false;\n        }\n    }\n\n    public function isFresh($name, $time)\n    {\n        // false support to be removed in 3.0\n        if (null === ($path = $this->findTemplate($name)) || false === $path) {\n            return false;\n        }\n\n        return filemtime($path) < $time;\n    }\n\n    /**\n     * Checks if the template can be found.\n     *\n     * @param string $name The template name\n     *\n     * @return string|false|null The template name or false/null\n     */\n    protected function findTemplate($name)\n    {\n        $throw = \\func_num_args() > 1 ? func_get_arg(1) : true;\n        $name = $this->normalizeName($name);\n\n        if (isset($this->cache[$name])) {\n            return $this->cache[$name];\n        }\n\n        if (isset($this->errorCache[$name])) {\n            if (!$throw) {\n                return false;\n            }\n\n            throw new LoaderError($this->errorCache[$name]);\n        }\n\n        try {\n            list($namespace, $shortname) = $this->parseName($name);\n\n            $this->validateName($shortname);\n        } catch (LoaderError $e) {\n            if (!$throw) {\n                return false;\n            }\n\n            throw $e;\n        }\n\n        if (!isset($this->paths[$namespace])) {\n            $this->errorCache[$name] = sprintf('There are no registered paths for namespace \"%s\".', $namespace);\n\n            if (!$throw) {\n                return false;\n            }\n\n            throw new LoaderError($this->errorCache[$name]);\n        }\n\n        foreach ($this->paths[$namespace] as $path) {\n            if (!$this->isAbsolutePath($path)) {\n                $path = $this->rootPath.$path;\n            }\n\n            if (is_file($path.'/'.$shortname)) {\n                if (false !== $realpath = realpath($path.'/'.$shortname)) {\n                    return $this->cache[$name] = $realpath;\n                }\n\n                return $this->cache[$name] = $path.'/'.$shortname;\n            }\n        }\n\n        $this->errorCache[$name] = sprintf('Unable to find template \"%s\" (looked into: %s).', $name, implode(', ', $this->paths[$namespace]));\n\n        if (!$throw) {\n            return false;\n        }\n\n        throw new LoaderError($this->errorCache[$name]);\n    }\n\n    protected function parseName($name, $default = self::MAIN_NAMESPACE)\n    {\n        if (isset($name[0]) && '@' == $name[0]) {\n            if (false === $pos = strpos($name, '/')) {\n                throw new LoaderError(sprintf('Malformed namespaced template name \"%s\" (expecting \"@namespace/template_name\").', $name));\n            }\n\n            $namespace = substr($name, 1, $pos - 1);\n            $shortname = substr($name, $pos + 1);\n\n            return [$namespace, $shortname];\n        }\n\n        return [$default, $name];\n    }\n\n    protected function normalizeName($name)\n    {\n        return preg_replace('#/{2,}#', '/', str_replace('\\\\', '/', (string) $name));\n    }\n\n    protected function validateName($name)\n    {\n        if (false !== strpos($name, \"\\0\")) {\n            throw new LoaderError('A template name cannot contain NUL bytes.');\n        }\n\n        $name = ltrim($name, '/');\n        $parts = explode('/', $name);\n        $level = 0;\n        foreach ($parts as $part) {\n            if ('..' === $part) {\n                --$level;\n            } elseif ('.' !== $part) {\n                ++$level;\n            }\n\n            if ($level < 0) {\n                throw new LoaderError(sprintf('Looks like you try to load a template outside configured directories (%s).', $name));\n            }\n        }\n    }\n\n    private function isAbsolutePath($file)\n    {\n        return strspn($file, '/\\\\', 0, 1)\n            || (\\strlen($file) > 3 && ctype_alpha($file[0])\n                && ':' === substr($file, 1, 1)\n                && strspn($file, '/\\\\', 2, 1)\n            )\n            || null !== parse_url($file, \\PHP_URL_SCHEME)\n        ;\n    }\n}\n\nclass_alias('Twig\\Loader\\FilesystemLoader', 'Twig_Loader_Filesystem');\n", "<?php\n\nnamespace Twig\\Tests\\Loader;\n\n/*\n * This file is part of Twig.\n *\n * (c) Fabien Potencier\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nuse Twig\\Environment;\nuse Twig\\Error\\LoaderError;\nuse Twig\\Loader\\FilesystemLoader;\n\nclass FilesystemTest extends \\PHPUnit\\Framework\\TestCase\n{\n    public function testGetSourceContext()\n    {\n        $path = __DIR__.'/../Fixtures';\n        $loader = new FilesystemLoader([$path]);\n        $this->assertEquals('errors/index.html', $loader->getSourceContext('errors/index.html')->getName());\n        $this->assertEquals(realpath($path.'/errors/index.html'), realpath($loader->getSourceContext('errors/index.html')->getPath()));\n    }\n\n    /**\n     * @dataProvider getSecurityTests\n     */\n    public function testSecurity($template)\n    {\n        $loader = new FilesystemLoader([__DIR__.'/../Fixtures']);\n        $loader->addPath(__DIR__.'/../Fixtures', 'foo');\n\n        try {\n            $loader->getCacheKey($template);\n            $this->fail();\n        } catch (LoaderError $e) {\n            $this->assertStringNotContainsString('Unable to find template', $e->getMessage());\n        }\n    }\n\n    public function getSecurityTests()\n    {\n        return [\n            [\"AutoloaderTest\\0.php\"],\n            ['..\\\\AutoloaderTest.php'],\n            ['..\\\\\\\\\\\\AutoloaderTest.php'],\n            ['../AutoloaderTest.php'],\n            ['..////AutoloaderTest.php'],\n            ['./../AutoloaderTest.php'],\n            ['.\\\\..\\\\AutoloaderTest.php'],\n            ['././././././../AutoloaderTest.php'],\n            ['.\\\\./.\\\\./.\\\\./../AutoloaderTest.php'],\n            ['foo/../../AutoloaderTest.php'],\n            ['foo\\\\..\\\\..\\\\AutoloaderTest.php'],\n            ['foo/../bar/../../AutoloaderTest.php'],\n            ['foo/bar/../../../AutoloaderTest.php'],\n            ['filters/../../AutoloaderTest.php'],\n            ['filters//..//..//AutoloaderTest.php'],\n            ['filters\\\\..\\\\..\\\\AutoloaderTest.php'],\n            ['filters\\\\\\\\..\\\\\\\\..\\\\\\\\AutoloaderTest.php'],\n            ['filters\\\\//../\\\\/\\\\..\\\\AutoloaderTest.php'],\n            ['/../AutoloaderTest.php'],\n            ['@__main__/../AutoloaderTest.php'],\n            ['@foo/../AutoloaderTest.php'],\n            ['@__main__/../../AutoloaderTest.php'],\n            ['@foo/../../AutoloaderTest.php'],\n        ];\n    }\n\n    /**\n     * @dataProvider getBasePaths\n     */\n    public function testPaths($basePath, $cacheKey, $rootPath)\n    {\n        $loader = new FilesystemLoader([$basePath.'/normal', $basePath.'/normal_bis'], $rootPath);\n        $loader->setPaths([$basePath.'/named', $basePath.'/named_bis'], 'named');\n        $loader->addPath($basePath.'/named_ter', 'named');\n        $loader->addPath($basePath.'/normal_ter');\n        $loader->prependPath($basePath.'/normal_final');\n        $loader->prependPath($basePath.'/named/../named_quater', 'named');\n        $loader->prependPath($basePath.'/named_final', 'named');\n\n        $this->assertEquals([\n            $basePath.'/normal_final',\n            $basePath.'/normal',\n            $basePath.'/normal_bis',\n            $basePath.'/normal_ter',\n        ], $loader->getPaths());\n        $this->assertEquals([\n            $basePath.'/named_final',\n            $basePath.'/named/../named_quater',\n            $basePath.'/named',\n            $basePath.'/named_bis',\n            $basePath.'/named_ter',\n        ], $loader->getPaths('named'));\n\n        // do not use realpath here as it would make the test unuseful\n        $this->assertEquals($cacheKey, str_replace('\\\\', '/', $loader->getCacheKey('@named/named_absolute.html')));\n        $this->assertEquals(\"path (final)\\n\", $loader->getSourceContext('index.html')->getCode());\n        $this->assertEquals(\"path (final)\\n\", $loader->getSourceContext('@__main__/index.html')->getCode());\n        $this->assertEquals(\"named path (final)\\n\", $loader->getSourceContext('@named/index.html')->getCode());\n    }\n\n    public function getBasePaths()\n    {\n        return [\n            [\n                __DIR__.'/Fixtures',\n                'tests/Loader/Fixtures/named_quater/named_absolute.html',\n                null,\n            ],\n            [\n                __DIR__.'/Fixtures/../Fixtures',\n                'tests/Loader/Fixtures/named_quater/named_absolute.html',\n                null,\n            ],\n            [\n                'tests/Loader/Fixtures',\n                'tests/Loader/Fixtures/named_quater/named_absolute.html',\n                getcwd(),\n            ],\n            [\n                'Fixtures',\n                'Fixtures/named_quater/named_absolute.html',\n                getcwd().'/tests/Loader',\n            ],\n            [\n                'Fixtures',\n                'Fixtures/named_quater/named_absolute.html',\n                getcwd().'/tests/../tests/Loader',\n            ],\n        ];\n    }\n\n    public function testEmptyConstructor()\n    {\n        $loader = new FilesystemLoader();\n        $this->assertEquals([], $loader->getPaths());\n    }\n\n    public function testGetNamespaces()\n    {\n        $loader = new FilesystemLoader(sys_get_temp_dir());\n        $this->assertEquals([FilesystemLoader::MAIN_NAMESPACE], $loader->getNamespaces());\n\n        $loader->addPath(sys_get_temp_dir(), 'named');\n        $this->assertEquals([FilesystemLoader::MAIN_NAMESPACE, 'named'], $loader->getNamespaces());\n    }\n\n    public function testFindTemplateExceptionNamespace()\n    {\n        $basePath = __DIR__.'/Fixtures';\n\n        $loader = new FilesystemLoader([$basePath.'/normal']);\n        $loader->addPath($basePath.'/named', 'named');\n\n        try {\n            $loader->getSourceContext('@named/nowhere.html');\n        } catch (\\Exception $e) {\n            $this->assertInstanceOf('\\Twig\\Error\\LoaderError', $e);\n            $this->assertStringContainsString('Unable to find template \"@named/nowhere.html\"', $e->getMessage());\n        }\n    }\n\n    public function testFindTemplateWithCache()\n    {\n        $basePath = __DIR__.'/Fixtures';\n\n        $loader = new FilesystemLoader([$basePath.'/normal']);\n        $loader->addPath($basePath.'/named', 'named');\n\n        // prime the cache for index.html in the named namespace\n        $namedSource = $loader->getSourceContext('@named/index.html')->getCode();\n        $this->assertEquals(\"named path\\n\", $namedSource);\n\n        // get index.html from the main namespace\n        $this->assertEquals(\"path\\n\", $loader->getSourceContext('index.html')->getCode());\n    }\n\n    public function testLoadTemplateAndRenderBlockWithCache()\n    {\n        $loader = new FilesystemLoader([]);\n        $loader->addPath(__DIR__.'/Fixtures/themes/theme2');\n        $loader->addPath(__DIR__.'/Fixtures/themes/theme1');\n        $loader->addPath(__DIR__.'/Fixtures/themes/theme1', 'default_theme');\n\n        $twig = new Environment($loader);\n\n        $template = $twig->load('blocks.html.twig');\n        $this->assertSame('block from theme 1', $template->renderBlock('b1', []));\n\n        $template = $twig->load('blocks.html.twig');\n        $this->assertSame('block from theme 2', $template->renderBlock('b2', []));\n    }\n\n    public function getArrayInheritanceTests()\n    {\n        return [\n            'valid array inheritance' => ['array_inheritance_valid_parent.html.twig'],\n            'array inheritance with null first template' => ['array_inheritance_null_parent.html.twig'],\n            'array inheritance with empty first template' => ['array_inheritance_empty_parent.html.twig'],\n            'array inheritance with non-existent first template' => ['array_inheritance_nonexistent_parent.html.twig'],\n        ];\n    }\n\n    /**\n     * @dataProvider getArrayInheritanceTests\n     *\n     * @param $templateName string Template name with array inheritance\n     */\n    public function testArrayInheritance($templateName)\n    {\n        $loader = new FilesystemLoader([]);\n        $loader->addPath(__DIR__.'/Fixtures/inheritance');\n\n        $twig = new Environment($loader);\n\n        $template = $twig->load($templateName);\n        $this->assertSame('VALID Child', $template->renderBlock('body', []));\n    }\n\n    /**\n     * @requires PHP 5.3\n     */\n    public function testLoadTemplateFromPhar()\n    {\n        $loader = new FilesystemLoader([]);\n        // phar-sample.phar was created with the following script:\n        // $f = new Phar('phar-test.phar');\n        // $f->addFromString('hello.twig', 'hello from phar');\n        $loader->addPath('phar://'.__DIR__.'/Fixtures/phar/phar-sample.phar');\n        $this->assertSame('hello from phar', $loader->getSourceContext('hello.twig')->getCode());\n    }\n\n    public function testTemplateExistsAlwaysReturnsBool()\n    {\n        $loader = new FilesystemLoader([]);\n        $this->assertFalse($loader->exists(\"foo\\0.twig\"));\n        $this->assertFalse($loader->exists('../foo.twig'));\n        $this->assertFalse($loader->exists('@foo'));\n        $this->assertFalse($loader->exists('foo'));\n        $this->assertFalse($loader->exists('@foo/bar.twig'));\n\n        $loader->addPath(__DIR__.'/Fixtures/normal');\n        $this->assertTrue($loader->exists('index.html'));\n        $loader->addPath(__DIR__.'/Fixtures/normal', 'foo');\n        $this->assertTrue($loader->exists('@foo/index.html'));\n    }\n}\n"], "filenames": ["src/Loader/FilesystemLoader.php", "tests/Loader/FilesystemTest.php"], "buggy_code_start_loc": [224, 33], "buggy_code_end_loc": [226, 64], "fixing_code_start_loc": [223, 34], "fixing_code_end_loc": [227, 70], "type": "CWE-22", "message": "Twig is a template language for PHP. Versions 1.x prior to 1.44.7, 2.x prior to 2.15.3, and 3.x prior to 3.4.3 encounter an issue when the filesystem loader loads templates for which the name is a user input. It is possible to use the `source` or `include` statement to read arbitrary files from outside the templates' directory when using a namespace like `@somewhere/../some.file`. In such a case, validation is bypassed. Versions 1.44.7, 2.15.3, and 3.4.3 contain a fix for validation of such template names. There are no known workarounds aside from upgrading.", "other": {"cve": {"id": "CVE-2022-39261", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-28T14:15:10.827", "lastModified": "2022-11-21T15:26:31.897", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Twig is a template language for PHP. Versions 1.x prior to 1.44.7, 2.x prior to 2.15.3, and 3.x prior to 3.4.3 encounter an issue when the filesystem loader loads templates for which the name is a user input. It is possible to use the `source` or `include` statement to read arbitrary files from outside the templates' directory when using a namespace like `@somewhere/../some.file`. In such a case, validation is bypassed. Versions 1.44.7, 2.15.3, and 3.4.3 contain a fix for validation of such template names. There are no known workarounds aside from upgrading."}, {"lang": "es", "value": "Twig es un lenguaje de plantillas para PHP. Las versiones 1.x anteriores a 1.44.7, 2.x anteriores a 2.15.3 y 3.x anteriores a 3.4.3 encuentran un problema cuando el cargador del sistema de archivos carga plantillas cuyo nombre es una entrada del usuario. Es posible usar la sentencia \"source\" o \"include\" para leer archivos arbitrarios desde fuera del directorio de las plantillas cuando es usado un espacio de nombres como \"@somewhere/../some.file\". En este caso, la comprobaci\u00f3n es omitida. Las versiones 1.44.7, 2.15.3 y 3.4.3 contienen una correcci\u00f3n para la comprobaci\u00f3n de estos nombres de plantillas. No son conocidas mitigaciones aparte de la actualizaci\u00f3n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:symfony:twig:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.0.0", "versionEndExcluding": "1.44.7", "matchCriteriaId": "89FDEFD5-C01B-444B-996C-2AEA80CAE42A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:symfony:twig:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "2.15.3", "matchCriteriaId": "DA8EB8B6-8BB9-4663-BD97-75FF6E8CCBAC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:symfony:twig:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0", "versionEndExcluding": "3.4.3", "matchCriteriaId": "B75C1066-0489-4A94-BCCE-1C87F647F292"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:drupal:drupal:*:*:*:*:*:*:*:*", "versionStartIncluding": "8.0.0", "versionEndExcluding": "9.3.22", "matchCriteriaId": "17D11CF6-B0D3-455B-AC16-E8B73E1F3F01"}, {"vulnerable": true, "criteria": "cpe:2.3:a:drupal:drupal:*:*:*:*:*:*:*:*", "versionStartIncluding": "9.4.0", "versionEndExcluding": "9.4.7", "matchCriteriaId": "6A56407C-9F90-4FC1-A6F2-45D9DAE7789B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}], "references": [{"url": "https://github.com/twigphp/Twig/commit/35f3035c5deb0041da7b84daf02dea074ddc7a0b", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/twigphp/Twig/security/advisories/GHSA-52m2-vc4m-jj33", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/10/msg00016.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/2OKRUHPVLIQVFPPJ2UWC3WV3WQO763NR/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/AUVTXMNPSZAHS3DWZEM56V5W4NPVR6L7/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/NWRFPZSR74SYVJKBTKTMYUK36IJ3SQJP/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/TW53TFJ6WWNXMUHOFACKATJTS7NIHVQE/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WV5TNNJLGG536TJH6DLCIAAZZIPV2GUD/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/YU4ZYX62H2NUAKKGUES4RZIM4KMTKZ7F/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5248", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.drupal.org/sa-core-2022-016", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/twigphp/Twig/commit/35f3035c5deb0041da7b84daf02dea074ddc7a0b"}}