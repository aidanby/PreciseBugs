{"buggy_code": ["/*\n * crun - OCI runtime written in C\n *\n * Copyright (C) 2017, 2018, 2019 Giuseppe Scrivano <giuseppe@scrivano.org>\n * crun is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * crun is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with crun.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <config.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <argp.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n\n#include \"crun.h\"\n#include \"libcrun/container.h\"\n#include \"libcrun/utils.h\"\n#include \"libcrun/linux.h\"\n\nstatic char doc[] = \"OCI runtime\";\n\nstruct exec_options_s\n{\n  bool tty;\n  bool detach;\n  bool no_new_privs;\n  int preserve_fds;\n  const char *process;\n  const char *console_socket;\n  const char *pid_file;\n  char *process_label;\n  char *apparmor;\n  char *cwd;\n  char *user;\n  char **env;\n  char **cap;\n  size_t cap_size;\n  size_t env_size;\n  char *cgroup;\n};\n\nenum\n{\n  OPTION_CONSOLE_SOCKET = 1000,\n  OPTION_PID_FILE,\n  OPTION_CWD,\n  OPTION_PRESERVE_FDS,\n  OPTION_NO_NEW_PRIVS,\n  OPTION_PROCESS_LABEL,\n  OPTION_APPARMOR,\n  OPTION_CGROUP,\n};\n\nstatic struct exec_options_s exec_options;\n\nstatic struct argp_option options[]\n    = { { \"console-socket\", OPTION_CONSOLE_SOCKET, \"SOCKET\", 0,\n          \"path to a socket that will receive the ptmx end of the tty\", 0 },\n        { \"tty\", 't', \"TTY\", OPTION_ARG_OPTIONAL, \"allocate a pseudo-TTY\", 0 },\n        { \"process\", 'p', \"FILE\", 0, \"path to the process.json\", 0 },\n        { \"cwd\", OPTION_CWD, \"CWD\", 0, \"current working directory\", 0 },\n        { \"cgroup\", OPTION_CGROUP, \"PATH\", 0, \"sub-cgroup in the container\", 0 },\n        { \"detach\", 'd', 0, 0, \"detach the command in the background\", 0 },\n        { \"user\", 'u', \"USERSPEC\", 0, \"specify the user in the form UID[:GID]\", 0 },\n        { \"env\", 'e', \"ENV\", 0, \"add an environment variable\", 0 },\n        { \"cap\", 'c', \"CAP\", 0, \"add a capability\", 0 },\n        { \"pid-file\", OPTION_PID_FILE, \"FILE\", 0, \"where to write the PID of the container\", 0 },\n        { \"preserve-fds\", OPTION_PRESERVE_FDS, \"N\", 0, \"pass additional FDs to the container\", 0 },\n        { \"no-new-privs\", OPTION_NO_NEW_PRIVS, 0, 0, \"set the no new privileges value for the process\", 0 },\n        { \"process-label\", OPTION_PROCESS_LABEL, \"VALUE\", 0, \"set the asm process label for the process commonly used with selinux\", 0 },\n        { \"apparmor\", OPTION_APPARMOR, \"VALUE\", 0, \"set the apparmor profile for the process\", 0 },\n        {\n            0,\n        } };\n\nstatic char args_doc[] = \"exec CONTAINER cmd\";\n\nstatic void\nappend_env (const char *arg)\n{\n  exec_options.env = realloc (exec_options.env, (exec_options.env_size + 2) * sizeof (*exec_options.env));\n  if (exec_options.env == NULL)\n    error (EXIT_FAILURE, errno, \"cannot allocate memory\");\n  exec_options.env[exec_options.env_size + 1] = NULL;\n  exec_options.env[exec_options.env_size] = xstrdup (arg);\n  exec_options.env_size++;\n}\n\nstatic void\nappend_cap (const char *arg)\n{\n  exec_options.cap = realloc (exec_options.cap, (exec_options.cap_size + 2) * sizeof (*exec_options.cap));\n  if (exec_options.cap == NULL)\n    error (EXIT_FAILURE, errno, \"cannot allocate memory\");\n  exec_options.cap[exec_options.cap_size + 1] = NULL;\n  exec_options.cap[exec_options.cap_size] = xstrdup (arg);\n  exec_options.cap_size++;\n}\n\nstatic char **\ndup_array (char **arr, size_t len)\n{\n  size_t i;\n  char **ret;\n\n  ret = malloc (sizeof (char *) * (len + 1));\n  if (ret == NULL)\n    error (EXIT_FAILURE, errno, \"cannot allocate memory\");\n  for (i = 0; i < len; i++)\n    ret[i] = xstrdup (arr[i]);\n\n  ret[i] = NULL;\n  return ret;\n}\n\nstatic error_t\nparse_opt (int key, char *arg, struct argp_state *state)\n{\n  switch (key)\n    {\n    case OPTION_CONSOLE_SOCKET:\n      exec_options.console_socket = arg;\n      break;\n\n    case OPTION_PID_FILE:\n      exec_options.pid_file = arg;\n      break;\n\n    case OPTION_NO_NEW_PRIVS:\n      exec_options.no_new_privs = true;\n      break;\n\n    case OPTION_PROCESS_LABEL:\n      exec_options.process_label = argp_mandatory_argument (arg, state);\n      break;\n\n    case OPTION_APPARMOR:\n      exec_options.apparmor = argp_mandatory_argument (arg, state);\n      break;\n\n    case OPTION_PRESERVE_FDS:\n      exec_options.preserve_fds = strtoul (argp_mandatory_argument (arg, state), NULL, 10);\n      break;\n\n    case OPTION_CGROUP:\n      exec_options.cgroup = argp_mandatory_argument (arg, state);\n      break;\n\n    case 'd':\n      exec_options.detach = true;\n      break;\n\n    case 'p':\n      exec_options.process = arg;\n      break;\n\n    case 't':\n      exec_options.tty = arg == NULL || (strcmp (arg, \"false\") != 0 && strcmp (arg, \"no\") != 0);\n      break;\n\n    case 'u':\n      exec_options.user = arg;\n      break;\n\n    case 'e':\n      append_env (arg);\n      break;\n\n    case 'c':\n      append_cap (arg);\n      break;\n\n    case OPTION_CWD:\n      exec_options.cwd = xstrdup (arg);\n      break;\n\n    case ARGP_KEY_NO_ARGS:\n      libcrun_fail_with_error (0, \"please specify a ID for the container\");\n\n    default:\n      return ARGP_ERR_UNKNOWN;\n    }\n\n  return 0;\n}\n\nstatic struct argp run_argp = { options, parse_opt, args_doc, doc, NULL, NULL, NULL };\n\nstatic runtime_spec_schema_config_schema_process_user *\nmake_oci_process_user (const char *userspec)\n{\n  runtime_spec_schema_config_schema_process_user *u;\n  char *endptr = NULL;\n\n  if (userspec == NULL)\n    return NULL;\n\n  u = xmalloc0 (sizeof (runtime_spec_schema_config_schema_process_user));\n  errno = 0;\n  u->uid = strtol (userspec, &endptr, 10);\n  if (errno == ERANGE)\n    libcrun_fail_with_error (0, \"invalid UID specified\");\n  if (*endptr == '\\0')\n    return u;\n  if (*endptr != ':')\n    libcrun_fail_with_error (0, \"invalid USERSPEC specified\");\n\n  errno = 0;\n  u->gid = strtol (endptr + 1, &endptr, 10);\n  if (errno == ERANGE)\n    libcrun_fail_with_error (0, \"invalid GID specified\");\n  if (*endptr != '\\0')\n    libcrun_fail_with_error (0, \"invalid USERSPEC specified\");\n\n  return u;\n}\n\n#define cleanup_process_schema __attribute__ ((cleanup (cleanup_process_schemap)))\n\nstatic inline void\ncleanup_process_schemap (runtime_spec_schema_config_schema_process **p)\n{\n  runtime_spec_schema_config_schema_process *process = *p;\n  if (process)\n    (void) free_runtime_spec_schema_config_schema_process (process);\n}\n\nint\ncrun_command_exec (struct crun_global_arguments *global_args, int argc, char **argv, libcrun_error_t *err)\n{\n  int first_arg = 0, ret = 0;\n  libcrun_context_t crun_context = {\n    0,\n  };\n  cleanup_process_schema runtime_spec_schema_config_schema_process *process = NULL;\n  struct libcrun_container_exec_options_s exec_opts;\n\n  memset (&exec_opts, 0, sizeof (exec_opts));\n  exec_opts.struct_size = sizeof (exec_opts);\n\n  crun_context.preserve_fds = 0;\n  crun_context.listen_fds = 0;\n\n  argp_parse (&run_argp, argc, argv, ARGP_IN_ORDER, &first_arg, &exec_options);\n  crun_assert_n_args (argc - first_arg, exec_options.process ? 1 : 2, -1);\n\n  ret = init_libcrun_context (&crun_context, argv[first_arg], global_args, err);\n  if (UNLIKELY (ret < 0))\n    return ret;\n\n  crun_context.detach = exec_options.detach;\n  crun_context.console_socket = exec_options.console_socket;\n  crun_context.pid_file = exec_options.pid_file;\n  crun_context.preserve_fds = exec_options.preserve_fds;\n\n  if (getenv (\"LISTEN_FDS\"))\n    {\n      crun_context.listen_fds = strtoll (getenv (\"LISTEN_FDS\"), NULL, 10);\n      crun_context.preserve_fds += crun_context.listen_fds;\n    }\n\n  if (exec_options.process)\n    exec_opts.path = exec_options.process;\n  else\n    {\n      process = xmalloc0 (sizeof (*process));\n      int i;\n\n      process->args_len = argc;\n      process->args = xmalloc0 ((argc + 1) * sizeof (*process->args));\n      for (i = 0; i < argc - first_arg; i++)\n        process->args[i] = xstrdup (argv[first_arg + i + 1]);\n      process->args[i] = NULL;\n      if (exec_options.cwd)\n        process->cwd = exec_options.cwd;\n      process->terminal = exec_options.tty;\n      process->env = exec_options.env;\n      process->env_len = exec_options.env_size;\n      process->user = make_oci_process_user (exec_options.user);\n\n      if (exec_options.process_label != NULL)\n        process->selinux_label = exec_options.process_label;\n\n      if (exec_options.apparmor != NULL)\n        process->apparmor_profile = exec_options.apparmor;\n\n      if (exec_options.cap_size > 0)\n        {\n          runtime_spec_schema_config_schema_process_capabilities *capabilities\n              = xmalloc (sizeof (runtime_spec_schema_config_schema_process_capabilities));\n\n          capabilities->effective = exec_options.cap;\n          capabilities->effective_len = exec_options.cap_size;\n\n          capabilities->inheritable = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->inheritable_len = exec_options.cap_size;\n\n          capabilities->bounding = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->bounding_len = exec_options.cap_size;\n\n          capabilities->ambient = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->ambient_len = exec_options.cap_size;\n\n          capabilities->permitted = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->permitted_len = exec_options.cap_size;\n\n          process->capabilities = capabilities;\n        }\n\n      // noNewPriviledges will remain `false` if basespec has `false` unless specified\n      // Default is always `true` in generated basespec config\n      if (exec_options.no_new_privs)\n        process->no_new_privileges = 1;\n\n      exec_opts.process = process;\n    }\n\n  exec_opts.cgroup = exec_options.cgroup;\n\n  return libcrun_container_exec_with_options (&crun_context, argv[first_arg], &exec_opts, err);\n}\n"], "fixing_code": ["/*\n * crun - OCI runtime written in C\n *\n * Copyright (C) 2017, 2018, 2019 Giuseppe Scrivano <giuseppe@scrivano.org>\n * crun is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * crun is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with crun.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <config.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <argp.h>\n#include <string.h>\n#include <unistd.h>\n#include <errno.h>\n\n#include \"crun.h\"\n#include \"libcrun/container.h\"\n#include \"libcrun/utils.h\"\n#include \"libcrun/linux.h\"\n\nstatic char doc[] = \"OCI runtime\";\n\nstruct exec_options_s\n{\n  bool tty;\n  bool detach;\n  bool no_new_privs;\n  int preserve_fds;\n  const char *process;\n  const char *console_socket;\n  const char *pid_file;\n  char *process_label;\n  char *apparmor;\n  char *cwd;\n  char *user;\n  char **env;\n  char **cap;\n  size_t cap_size;\n  size_t env_size;\n  char *cgroup;\n};\n\nenum\n{\n  OPTION_CONSOLE_SOCKET = 1000,\n  OPTION_PID_FILE,\n  OPTION_CWD,\n  OPTION_PRESERVE_FDS,\n  OPTION_NO_NEW_PRIVS,\n  OPTION_PROCESS_LABEL,\n  OPTION_APPARMOR,\n  OPTION_CGROUP,\n};\n\nstatic struct exec_options_s exec_options;\n\nstatic struct argp_option options[]\n    = { { \"console-socket\", OPTION_CONSOLE_SOCKET, \"SOCKET\", 0,\n          \"path to a socket that will receive the ptmx end of the tty\", 0 },\n        { \"tty\", 't', \"TTY\", OPTION_ARG_OPTIONAL, \"allocate a pseudo-TTY\", 0 },\n        { \"process\", 'p', \"FILE\", 0, \"path to the process.json\", 0 },\n        { \"cwd\", OPTION_CWD, \"CWD\", 0, \"current working directory\", 0 },\n        { \"cgroup\", OPTION_CGROUP, \"PATH\", 0, \"sub-cgroup in the container\", 0 },\n        { \"detach\", 'd', 0, 0, \"detach the command in the background\", 0 },\n        { \"user\", 'u', \"USERSPEC\", 0, \"specify the user in the form UID[:GID]\", 0 },\n        { \"env\", 'e', \"ENV\", 0, \"add an environment variable\", 0 },\n        { \"cap\", 'c', \"CAP\", 0, \"add a capability\", 0 },\n        { \"pid-file\", OPTION_PID_FILE, \"FILE\", 0, \"where to write the PID of the container\", 0 },\n        { \"preserve-fds\", OPTION_PRESERVE_FDS, \"N\", 0, \"pass additional FDs to the container\", 0 },\n        { \"no-new-privs\", OPTION_NO_NEW_PRIVS, 0, 0, \"set the no new privileges value for the process\", 0 },\n        { \"process-label\", OPTION_PROCESS_LABEL, \"VALUE\", 0, \"set the asm process label for the process commonly used with selinux\", 0 },\n        { \"apparmor\", OPTION_APPARMOR, \"VALUE\", 0, \"set the apparmor profile for the process\", 0 },\n        {\n            0,\n        } };\n\nstatic char args_doc[] = \"exec CONTAINER cmd\";\n\nstatic void\nappend_env (const char *arg)\n{\n  exec_options.env = realloc (exec_options.env, (exec_options.env_size + 2) * sizeof (*exec_options.env));\n  if (exec_options.env == NULL)\n    error (EXIT_FAILURE, errno, \"cannot allocate memory\");\n  exec_options.env[exec_options.env_size + 1] = NULL;\n  exec_options.env[exec_options.env_size] = xstrdup (arg);\n  exec_options.env_size++;\n}\n\nstatic void\nappend_cap (const char *arg)\n{\n  exec_options.cap = realloc (exec_options.cap, (exec_options.cap_size + 2) * sizeof (*exec_options.cap));\n  if (exec_options.cap == NULL)\n    error (EXIT_FAILURE, errno, \"cannot allocate memory\");\n  exec_options.cap[exec_options.cap_size + 1] = NULL;\n  exec_options.cap[exec_options.cap_size] = xstrdup (arg);\n  exec_options.cap_size++;\n}\n\nstatic char **\ndup_array (char **arr, size_t len)\n{\n  size_t i;\n  char **ret;\n\n  ret = malloc (sizeof (char *) * (len + 1));\n  if (ret == NULL)\n    error (EXIT_FAILURE, errno, \"cannot allocate memory\");\n  for (i = 0; i < len; i++)\n    ret[i] = xstrdup (arr[i]);\n\n  ret[i] = NULL;\n  return ret;\n}\n\nstatic error_t\nparse_opt (int key, char *arg, struct argp_state *state)\n{\n  switch (key)\n    {\n    case OPTION_CONSOLE_SOCKET:\n      exec_options.console_socket = arg;\n      break;\n\n    case OPTION_PID_FILE:\n      exec_options.pid_file = arg;\n      break;\n\n    case OPTION_NO_NEW_PRIVS:\n      exec_options.no_new_privs = true;\n      break;\n\n    case OPTION_PROCESS_LABEL:\n      exec_options.process_label = argp_mandatory_argument (arg, state);\n      break;\n\n    case OPTION_APPARMOR:\n      exec_options.apparmor = argp_mandatory_argument (arg, state);\n      break;\n\n    case OPTION_PRESERVE_FDS:\n      exec_options.preserve_fds = strtoul (argp_mandatory_argument (arg, state), NULL, 10);\n      break;\n\n    case OPTION_CGROUP:\n      exec_options.cgroup = argp_mandatory_argument (arg, state);\n      break;\n\n    case 'd':\n      exec_options.detach = true;\n      break;\n\n    case 'p':\n      exec_options.process = arg;\n      break;\n\n    case 't':\n      exec_options.tty = arg == NULL || (strcmp (arg, \"false\") != 0 && strcmp (arg, \"no\") != 0);\n      break;\n\n    case 'u':\n      exec_options.user = arg;\n      break;\n\n    case 'e':\n      append_env (arg);\n      break;\n\n    case 'c':\n      append_cap (arg);\n      break;\n\n    case OPTION_CWD:\n      exec_options.cwd = xstrdup (arg);\n      break;\n\n    case ARGP_KEY_NO_ARGS:\n      libcrun_fail_with_error (0, \"please specify a ID for the container\");\n\n    default:\n      return ARGP_ERR_UNKNOWN;\n    }\n\n  return 0;\n}\n\nstatic struct argp run_argp = { options, parse_opt, args_doc, doc, NULL, NULL, NULL };\n\nstatic runtime_spec_schema_config_schema_process_user *\nmake_oci_process_user (const char *userspec)\n{\n  runtime_spec_schema_config_schema_process_user *u;\n  char *endptr = NULL;\n\n  if (userspec == NULL)\n    return NULL;\n\n  u = xmalloc0 (sizeof (runtime_spec_schema_config_schema_process_user));\n  errno = 0;\n  u->uid = strtol (userspec, &endptr, 10);\n  if (errno == ERANGE)\n    libcrun_fail_with_error (0, \"invalid UID specified\");\n  if (*endptr == '\\0')\n    return u;\n  if (*endptr != ':')\n    libcrun_fail_with_error (0, \"invalid USERSPEC specified\");\n\n  errno = 0;\n  u->gid = strtol (endptr + 1, &endptr, 10);\n  if (errno == ERANGE)\n    libcrun_fail_with_error (0, \"invalid GID specified\");\n  if (*endptr != '\\0')\n    libcrun_fail_with_error (0, \"invalid USERSPEC specified\");\n\n  return u;\n}\n\n#define cleanup_process_schema __attribute__ ((cleanup (cleanup_process_schemap)))\n\nstatic inline void\ncleanup_process_schemap (runtime_spec_schema_config_schema_process **p)\n{\n  runtime_spec_schema_config_schema_process *process = *p;\n  if (process)\n    (void) free_runtime_spec_schema_config_schema_process (process);\n}\n\nint\ncrun_command_exec (struct crun_global_arguments *global_args, int argc, char **argv, libcrun_error_t *err)\n{\n  int first_arg = 0, ret = 0;\n  libcrun_context_t crun_context = {\n    0,\n  };\n  cleanup_process_schema runtime_spec_schema_config_schema_process *process = NULL;\n  struct libcrun_container_exec_options_s exec_opts;\n\n  memset (&exec_opts, 0, sizeof (exec_opts));\n  exec_opts.struct_size = sizeof (exec_opts);\n\n  crun_context.preserve_fds = 0;\n  crun_context.listen_fds = 0;\n\n  argp_parse (&run_argp, argc, argv, ARGP_IN_ORDER, &first_arg, &exec_options);\n  crun_assert_n_args (argc - first_arg, exec_options.process ? 1 : 2, -1);\n\n  ret = init_libcrun_context (&crun_context, argv[first_arg], global_args, err);\n  if (UNLIKELY (ret < 0))\n    return ret;\n\n  crun_context.detach = exec_options.detach;\n  crun_context.console_socket = exec_options.console_socket;\n  crun_context.pid_file = exec_options.pid_file;\n  crun_context.preserve_fds = exec_options.preserve_fds;\n\n  if (getenv (\"LISTEN_FDS\"))\n    {\n      crun_context.listen_fds = strtoll (getenv (\"LISTEN_FDS\"), NULL, 10);\n      crun_context.preserve_fds += crun_context.listen_fds;\n    }\n\n  if (exec_options.process)\n    exec_opts.path = exec_options.process;\n  else\n    {\n      process = xmalloc0 (sizeof (*process));\n      int i;\n\n      process->args_len = argc;\n      process->args = xmalloc0 ((argc + 1) * sizeof (*process->args));\n      for (i = 0; i < argc - first_arg; i++)\n        process->args[i] = xstrdup (argv[first_arg + i + 1]);\n      process->args[i] = NULL;\n      if (exec_options.cwd)\n        process->cwd = exec_options.cwd;\n      process->terminal = exec_options.tty;\n      process->env = exec_options.env;\n      process->env_len = exec_options.env_size;\n      process->user = make_oci_process_user (exec_options.user);\n\n      if (exec_options.process_label != NULL)\n        process->selinux_label = exec_options.process_label;\n\n      if (exec_options.apparmor != NULL)\n        process->apparmor_profile = exec_options.apparmor;\n\n      if (exec_options.cap_size > 0)\n        {\n          runtime_spec_schema_config_schema_process_capabilities *capabilities\n              = xmalloc (sizeof (runtime_spec_schema_config_schema_process_capabilities));\n\n          capabilities->effective = exec_options.cap;\n          capabilities->effective_len = exec_options.cap_size;\n\n          capabilities->inheritable = NULL;\n          capabilities->inheritable_len = 0;\n\n          capabilities->bounding = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->bounding_len = exec_options.cap_size;\n\n          capabilities->ambient = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->ambient_len = exec_options.cap_size;\n\n          capabilities->permitted = dup_array (exec_options.cap, exec_options.cap_size);\n          capabilities->permitted_len = exec_options.cap_size;\n\n          process->capabilities = capabilities;\n        }\n\n      // noNewPriviledges will remain `false` if basespec has `false` unless specified\n      // Default is always `true` in generated basespec config\n      if (exec_options.no_new_privs)\n        process->no_new_privileges = 1;\n\n      exec_opts.process = process;\n    }\n\n  exec_opts.cgroup = exec_options.cgroup;\n\n  return libcrun_container_exec_with_options (&crun_context, argv[first_arg], &exec_opts, err);\n}\n"], "filenames": ["src/exec.c"], "buggy_code_start_loc": [307], "buggy_code_end_loc": [309], "fixing_code_start_loc": [307], "fixing_code_end_loc": [309], "type": "CWE-276", "message": "A flaw was found in crun where containers were incorrectly started with non-empty default permissions. A vulnerability was found in Moby (Docker Engine) where containers were started incorrectly with non-empty inheritable Linux process capabilities. This flaw allows an attacker with access to programs with inheritable file capabilities to elevate those capabilities to the permitted set when execve(2) runs.", "other": {"cve": {"id": "CVE-2022-27650", "sourceIdentifier": "secalert@redhat.com", "published": "2022-04-04T20:15:10.940", "lastModified": "2022-11-28T17:51:38.093", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A flaw was found in crun where containers were incorrectly started with non-empty default permissions. A vulnerability was found in Moby (Docker Engine) where containers were started incorrectly with non-empty inheritable Linux process capabilities. This flaw allows an attacker with access to programs with inheritable file capabilities to elevate those capabilities to the permitted set when execve(2) runs."}, {"lang": "es", "value": "Se encontr\u00f3 un fallo en crun donde los contenedores eran iniciados incorrectamente con permisos por defecto no vac\u00edos. Se ha encontrado una vulnerabilidad en Moby (Docker Engine) donde los contenedores eran iniciados incorrectamente con capacidades de proceso Linux heredables no vac\u00edas. Este fallo permite a un atacante con acceso a programas con capacidades de archivo heredables elevar esas capacidades al conjunto permitido cuando se ejecuta execve(2)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 6.8, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-276"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-276"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:crun_project:crun:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.4.4", "matchCriteriaId": "06EAF691-0DBA-40AC-A231-0418FC8DF132"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openshift_container_platform:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "932D137F-528B-4526-9A89-CD59FA1AB0FE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "F4CFF558-3C47-480D-A2F0-BABF26042943"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2066845", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/containers/crun/commit/1aeeed2e4fdeffb4875c0d0b439915894594c8c6", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/containers/crun/security/advisories/GHSA-wr4f-w546-m398", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/HYIGABCZ7ZHAG2XCOGITTQRJU2ASWMFA/", "source": "secalert@redhat.com", "tags": ["Mailing List", "Release Notes", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/containers/crun/commit/1aeeed2e4fdeffb4875c0d0b439915894594c8c6"}}