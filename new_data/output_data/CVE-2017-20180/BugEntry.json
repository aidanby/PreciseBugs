{"buggy_code": ["/**\n * @file       CoinSpend.cpp\n *\n * @brief      CoinSpend class for the Zerocoin library.\n *\n * @author     Ian Miers, Christina Garman and Matthew Green\n * @date       June 2013\n *\n * @copyright  Copyright 2013 Ian Miers, Christina Garman and Matthew Green\n * @license    This project is released under the MIT license.\n **/\n\n#include \"Zerocoin.h\"\n\nnamespace libzerocoin {\n\nCoinSpend::CoinSpend(const Params* p, const PrivateCoin& coin,\n                     Accumulator& a, const AccumulatorWitness& witness, const SpendMetaData& m):\n\tparams(p),\n\tdenomination(coin.getPublicCoin().getDenomination()),\n\tcoinSerialNumber((coin.getSerialNumber())),\n\taccumulatorPoK(&p->accumulatorParams),\n\tserialNumberSoK(p),\n\tcommitmentPoK(&p->serialNumberSoKCommitmentGroup, &p->accumulatorParams.accumulatorPoKCommitmentGroup) {\n\n\t// Sanity check: let's verify that the Witness is valid with respect to\n\t// the coin and Accumulator provided.\n\tif (!(witness.VerifyWitness(a, coin.getPublicCoin()))) {\n\t\tthrow ZerocoinException(\"Accumulator witness does not verify\");\n\t}\n\n\t// 1: Generate two separate commitments to the public coin (C), each under\n\t// a different set of public parameters. We do this because the RSA accumulator\n\t// has specific requirements for the commitment parameters that are not\n\t// compatible with the group we use for the serial number proof.\n\t// Specifically, our serial number proof requires the order of the commitment group\n\t// to be the same as the modulus of the upper group. The Accumulator proof requires a\n\t// group with a significantly larger order.\n\tconst Commitment fullCommitmentToCoinUnderSerialParams(&p->serialNumberSoKCommitmentGroup, coin.getPublicCoin().getValue());\n\tthis->serialCommitmentToCoinValue = fullCommitmentToCoinUnderSerialParams.getCommitmentValue();\n\n\tconst Commitment fullCommitmentToCoinUnderAccParams(&p->accumulatorParams.accumulatorPoKCommitmentGroup, coin.getPublicCoin().getValue());\n\tthis->accCommitmentToCoinValue = fullCommitmentToCoinUnderAccParams.getCommitmentValue();\n\n\t// 2. Generate a ZK proof that the two commitments contain the same public coin.\n\tthis->commitmentPoK = CommitmentProofOfKnowledge(&p->serialNumberSoKCommitmentGroup, &p->accumulatorParams.accumulatorPoKCommitmentGroup, fullCommitmentToCoinUnderSerialParams, fullCommitmentToCoinUnderAccParams);\n\n\t// Now generate the two core ZK proofs:\n\t// 3. Proves that the committed public coin is in the Accumulator (PoK of \"witness\")\n\tthis->accumulatorPoK = AccumulatorProofOfKnowledge(&p->accumulatorParams, fullCommitmentToCoinUnderAccParams, witness, a);\n\n\t// 4. Proves that the coin is correct w.r.t. serial number and hidden coin secret\n\t// (This proof is bound to the coin 'metadata', i.e., transaction hash)\n\tthis->serialNumberSoK = SerialNumberSignatureOfKnowledge(p, coin, fullCommitmentToCoinUnderSerialParams, signatureHash(m));\n}\n\nconst Bignum&\nCoinSpend::getCoinSerialNumber() {\n\treturn this->coinSerialNumber;\n}\n\nconst CoinDenomination\nCoinSpend::getDenomination() {\n\treturn static_cast<CoinDenomination>(this->denomination);\n}\n\nbool\nCoinSpend::Verify(const Accumulator& a, const SpendMetaData &m) const {\n\t// Verify both of the sub-proofs using the given meta-data\n\treturn  (a.getDenomination() == this->denomination)\n\t        && commitmentPoK.Verify(serialCommitmentToCoinValue, accCommitmentToCoinValue)\n\t        && accumulatorPoK.Verify(a, accCommitmentToCoinValue)\n\t        && serialNumberSoK.Verify(coinSerialNumber, serialCommitmentToCoinValue, signatureHash(m));\n}\n\nconst uint256 CoinSpend::signatureHash(const SpendMetaData &m) const {\n\tCHashWriter h(0,0);\n\th << m << serialCommitmentToCoinValue << accCommitmentToCoinValue << commitmentPoK << accumulatorPoK;\n\treturn h.GetHash();\n}\n\n} /* namespace libzerocoin */\n", "/**\n * @file       CoinSpend.h\n *\n * @brief      CoinSpend class for the Zerocoin library.\n *\n * @author     Ian Miers, Christina Garman and Matthew Green\n * @date       June 2013\n *\n * @copyright  Copyright 2013 Ian Miers, Christina Garman and Matthew Green\n * @license    This project is released under the MIT license.\n **/\n\n#ifndef COINSPEND_H_\n#define COINSPEND_H_\n\n#include \"Params.h\"\n#include \"Coin.h\"\n#include \"Commitment.h\"\n#include \"bitcoin_bignum/bignum.h\"\n#include \"Accumulator.h\"\n#include \"AccumulatorProofOfKnowledge.h\"\n#include \"SerialNumberSignatureOfKnowledge.h\"\n#include \"SpendMetaData.h\"\n#include \"bitcoin_bignum/serialize.h\"\n\nnamespace libzerocoin {\n\n/** The complete proof needed to spend a zerocoin.\n * Composes together a proof that a coin is accumulated\n * and that it has a given serial number.\n */\nclass CoinSpend {\npublic:\n\ttemplate<typename Stream>\n\tCoinSpend(const Params* p,  Stream& strm):denomination(ZQ_LOVELACE),\n\t\taccumulatorPoK(&p->accumulatorParams),\n\t\tserialNumberSoK(p),\n\t\tcommitmentPoK(&p->serialNumberSoKCommitmentGroup, &p->accumulatorParams.accumulatorPoKCommitmentGroup) {\n\t\tstrm >> *this;\n\t}\n\t/**Generates a proof spending a zerocoin.\n\t *\n\t * To use this, provide an unspent PrivateCoin, the latest Accumulator\n\t * (e.g from the most recent Bitcoin block) containing the public part\n\t * of the coin, a witness to that, and whatever medeta data is needed.\n\t *\n\t * Once constructed, this proof can be serialized and sent.\n\t * It is validated simply be calling validate.\n\t * @warning Validation only checks that the proof is correct\n\t * @warning for the specified values in this class. These values must be validated\n\t *  Clients ought to check that\n\t * 1) params is the right params\n\t * 2) the accumulator actually is in some block\n\t * 3) that the serial number is unspent\n\t * 4) that the transaction\n\t *\n\t * @param p cryptographic parameters\n\t * @param coin The coin to be spend\n\t * @param a The current accumulator containing the coin\n\t * @param witness The witness showing that the accumulator contains the coin\n\t * @param m arbitrary meta data related to the spend that might be needed by Bitcoin\n\t * \t\t\t(i.e. the transaction hash)\n\t * @throw ZerocoinException if the process fails\n\t */\n\tCoinSpend(const Params* p, const PrivateCoin& coin, Accumulator& a, const AccumulatorWitness& witness, const SpendMetaData& m);\n\n\t/** Returns the serial number of the coin spend by this proof.\n\t *\n\t * @return the coin's serial number\n\t */\n\tconst Bignum& getCoinSerialNumber();\n\n\t/**Gets the denomination of the coin spent in this proof.\n\t *\n\t * @return the denomination\n\t */\n\tconst CoinDenomination getDenomination();\n\n\tbool Verify(const Accumulator& a, const SpendMetaData &metaData) const;\n\n\tIMPLEMENT_SERIALIZE\n\t(\n\t    READWRITE(denomination);\n\t    READWRITE(accCommitmentToCoinValue);\n\t    READWRITE(serialCommitmentToCoinValue);\n\t    READWRITE(coinSerialNumber);\n\t    READWRITE(accumulatorPoK);\n\t    READWRITE(serialNumberSoK);\n\t    READWRITE(commitmentPoK);\n\t)\n\nprivate:\n\tconst Params *params;\n\tconst uint256 signatureHash(const SpendMetaData &m) const;\n\t// Denomination is stored as an INT because storing\n\t// and enum raises amigiuities in the serialize code //FIXME if possible\n\tint denomination;\n\tBignum accCommitmentToCoinValue;\n\tBignum serialCommitmentToCoinValue;\n\tBignum coinSerialNumber;\n\tAccumulatorProofOfKnowledge accumulatorPoK;\n\tSerialNumberSignatureOfKnowledge serialNumberSoK;\n\tCommitmentProofOfKnowledge commitmentPoK;\n};\n\n} /* namespace libzerocoin */\n#endif /* COINSPEND_H_ */\n"], "fixing_code": ["/**\n * @file       CoinSpend.cpp\n *\n * @brief      CoinSpend class for the Zerocoin library.\n *\n * @author     Ian Miers, Christina Garman and Matthew Green\n * @date       June 2013\n *\n * @copyright  Copyright 2013 Ian Miers, Christina Garman and Matthew Green\n * @license    This project is released under the MIT license.\n **/\n\n#include \"Zerocoin.h\"\n\nnamespace libzerocoin {\n\nCoinSpend::CoinSpend(const Params* p, const PrivateCoin& coin,\n                     Accumulator& a, const AccumulatorWitness& witness, const SpendMetaData& m):\n\tparams(p),\n\tdenomination(coin.getPublicCoin().getDenomination()),\n\tcoinSerialNumber((coin.getSerialNumber())),\n\taccumulatorPoK(&p->accumulatorParams),\n\tserialNumberSoK(p),\n\tcommitmentPoK(&p->serialNumberSoKCommitmentGroup, &p->accumulatorParams.accumulatorPoKCommitmentGroup) {\n\n\t// Sanity check: let's verify that the Witness is valid with respect to\n\t// the coin and Accumulator provided.\n\tif (!(witness.VerifyWitness(a, coin.getPublicCoin()))) {\n\t\tthrow ZerocoinException(\"Accumulator witness does not verify\");\n\t}\n\n\t// The serial # needs to be within the specified range our else it can be incremented by the modulus and create another valid proof\n\tif (!HasValidSerial()) {\n\t\tthrow ZerocoinException(\"Invalid serial # range\");\n\t}\n\n\t// 1: Generate two separate commitments to the public coin (C), each under\n\t// a different set of public parameters. We do this because the RSA accumulator\n\t// has specific requirements for the commitment parameters that are not\n\t// compatible with the group we use for the serial number proof.\n\t// Specifically, our serial number proof requires the order of the commitment group\n\t// to be the same as the modulus of the upper group. The Accumulator proof requires a\n\t// group with a significantly larger order.\n\tconst Commitment fullCommitmentToCoinUnderSerialParams(&p->serialNumberSoKCommitmentGroup, coin.getPublicCoin().getValue());\n\tthis->serialCommitmentToCoinValue = fullCommitmentToCoinUnderSerialParams.getCommitmentValue();\n\n\tconst Commitment fullCommitmentToCoinUnderAccParams(&p->accumulatorParams.accumulatorPoKCommitmentGroup, coin.getPublicCoin().getValue());\n\tthis->accCommitmentToCoinValue = fullCommitmentToCoinUnderAccParams.getCommitmentValue();\n\n\t// 2. Generate a ZK proof that the two commitments contain the same public coin.\n\tthis->commitmentPoK = CommitmentProofOfKnowledge(&p->serialNumberSoKCommitmentGroup, &p->accumulatorParams.accumulatorPoKCommitmentGroup, fullCommitmentToCoinUnderSerialParams, fullCommitmentToCoinUnderAccParams);\n\n\t// Now generate the two core ZK proofs:\n\t// 3. Proves that the committed public coin is in the Accumulator (PoK of \"witness\")\n\tthis->accumulatorPoK = AccumulatorProofOfKnowledge(&p->accumulatorParams, fullCommitmentToCoinUnderAccParams, witness, a);\n\n\t// 4. Proves that the coin is correct w.r.t. serial number and hidden coin secret\n\t// (This proof is bound to the coin 'metadata', i.e., transaction hash)\n\tthis->serialNumberSoK = SerialNumberSignatureOfKnowledge(p, coin, fullCommitmentToCoinUnderSerialParams, signatureHash(m));\n}\n\nconst Bignum&\nCoinSpend::getCoinSerialNumber() {\n\treturn this->coinSerialNumber;\n}\n\nconst CoinDenomination\nCoinSpend::getDenomination() {\n\treturn static_cast<CoinDenomination>(this->denomination);\n}\n\nbool\nCoinSpend::Verify(const Accumulator& a, const SpendMetaData &m) const {\n\t// Verify both of the sub-proofs using the given meta-data\n\treturn  (a.getDenomination() == this->denomination)\n\t        && commitmentPoK.Verify(serialCommitmentToCoinValue, accCommitmentToCoinValue)\n\t        && accumulatorPoK.Verify(a, accCommitmentToCoinValue)\n\t        && serialNumberSoK.Verify(coinSerialNumber, serialCommitmentToCoinValue, signatureHash(m));\n}\n\nconst uint256 CoinSpend::signatureHash(const SpendMetaData &m) const {\n\tCHashWriter h(0,0);\n\th << m << serialCommitmentToCoinValue << accCommitmentToCoinValue << commitmentPoK << accumulatorPoK;\n\treturn h.GetHash();\n}\n\nbool CoinSpend::HasValidSerial() const\n{\n\treturn coinSerialNumber > 0 && coinSerialNumber < params->coinCommitmentGroup.groupOrder;\n}\n\n} /* namespace libzerocoin */\n", "/**\n * @file       CoinSpend.h\n *\n * @brief      CoinSpend class for the Zerocoin library.\n *\n * @author     Ian Miers, Christina Garman and Matthew Green\n * @date       June 2013\n *\n * @copyright  Copyright 2013 Ian Miers, Christina Garman and Matthew Green\n * @license    This project is released under the MIT license.\n **/\n\n#ifndef COINSPEND_H_\n#define COINSPEND_H_\n\n#include \"Params.h\"\n#include \"Coin.h\"\n#include \"Commitment.h\"\n#include \"bitcoin_bignum/bignum.h\"\n#include \"Accumulator.h\"\n#include \"AccumulatorProofOfKnowledge.h\"\n#include \"SerialNumberSignatureOfKnowledge.h\"\n#include \"SpendMetaData.h\"\n#include \"bitcoin_bignum/serialize.h\"\n\nnamespace libzerocoin {\n\n/** The complete proof needed to spend a zerocoin.\n * Composes together a proof that a coin is accumulated\n * and that it has a given serial number.\n */\nclass CoinSpend {\npublic:\n\ttemplate<typename Stream>\n\tCoinSpend(const Params* p,  Stream& strm):denomination(ZQ_LOVELACE),\n\t\taccumulatorPoK(&p->accumulatorParams),\n\t\tserialNumberSoK(p),\n\t\tcommitmentPoK(&p->serialNumberSoKCommitmentGroup, &p->accumulatorParams.accumulatorPoKCommitmentGroup) {\n\t\tstrm >> *this;\n\t}\n\t/**Generates a proof spending a zerocoin.\n\t *\n\t * To use this, provide an unspent PrivateCoin, the latest Accumulator\n\t * (e.g from the most recent Bitcoin block) containing the public part\n\t * of the coin, a witness to that, and whatever medeta data is needed.\n\t *\n\t * Once constructed, this proof can be serialized and sent.\n\t * It is validated simply be calling validate.\n\t * @warning Validation only checks that the proof is correct\n\t * @warning for the specified values in this class. These values must be validated\n\t *  Clients ought to check that\n\t * 1) params is the right params\n\t * 2) the accumulator actually is in some block\n\t * 3) that the serial number is unspent\n\t * 4) that the transaction\n\t *\n\t * @param p cryptographic parameters\n\t * @param coin The coin to be spend\n\t * @param a The current accumulator containing the coin\n\t * @param witness The witness showing that the accumulator contains the coin\n\t * @param m arbitrary meta data related to the spend that might be needed by Bitcoin\n\t * \t\t\t(i.e. the transaction hash)\n\t * @throw ZerocoinException if the process fails\n\t */\n\tCoinSpend(const Params* p, const PrivateCoin& coin, Accumulator& a, const AccumulatorWitness& witness, const SpendMetaData& m);\n\n\t/** Returns the serial number of the coin spend by this proof.\n\t *\n\t * @return the coin's serial number\n\t */\n\tconst Bignum& getCoinSerialNumber();\n\n\t/**Gets the denomination of the coin spent in this proof.\n\t *\n\t * @return the denomination\n\t */\n\tconst CoinDenomination getDenomination();\n\n\tbool HasValidSerial() const;\n\tbool Verify(const Accumulator& a, const SpendMetaData &metaData) const;\n\n\tIMPLEMENT_SERIALIZE\n\t(\n\t    READWRITE(denomination);\n\t    READWRITE(accCommitmentToCoinValue);\n\t    READWRITE(serialCommitmentToCoinValue);\n\t    READWRITE(coinSerialNumber);\n\t    READWRITE(accumulatorPoK);\n\t    READWRITE(serialNumberSoK);\n\t    READWRITE(commitmentPoK);\n\t)\n\nprivate:\n\tconst Params *params;\n\tconst uint256 signatureHash(const SpendMetaData &m) const;\n\t// Denomination is stored as an INT because storing\n\t// and enum raises amigiuities in the serialize code //FIXME if possible\n\tint denomination;\n\tBignum accCommitmentToCoinValue;\n\tBignum serialCommitmentToCoinValue;\n\tBignum coinSerialNumber;\n\tAccumulatorProofOfKnowledge accumulatorPoK;\n\tSerialNumberSignatureOfKnowledge serialNumberSoK;\n\tCommitmentProofOfKnowledge commitmentPoK;\n};\n\n} /* namespace libzerocoin */\n#endif /* COINSPEND_H_ */\n"], "filenames": ["CoinSpend.cpp", "CoinSpend.h"], "buggy_code_start_loc": [29, 78], "buggy_code_end_loc": [81, 78], "fixing_code_start_loc": [30, 79], "fixing_code_end_loc": [92, 80], "type": "CWE-345", "message": "A vulnerability classified as critical has been found in Zerocoin libzerocoin. Affected is the function CoinSpend::CoinSpend of the file CoinSpend.cpp of the component Proof Handler. The manipulation leads to insufficient verification of data authenticity. Continious delivery with rolling releases is used by this product. Therefore, no version details of affected nor updated releases are available. The name of the patch is ce103a09ec079d0a0ed95475992348bed6e860de. It is recommended to apply a patch to fix this issue. VDB-222318 is the identifier assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2017-20180", "sourceIdentifier": "cna@vuldb.com", "published": "2023-03-06T11:15:09.813", "lastModified": "2023-03-11T02:13:16.340", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability classified as critical has been found in Zerocoin libzerocoin. Affected is the function CoinSpend::CoinSpend of the file CoinSpend.cpp of the component Proof Handler. The manipulation leads to insufficient verification of data authenticity. Continious delivery with rolling releases is used by this product. Therefore, no version details of affected nor updated releases are available. The name of the patch is ce103a09ec079d0a0ed95475992348bed6e860de. It is recommended to apply a patch to fix this issue. VDB-222318 is the identifier assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 4.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 2.5}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:S/C:N/I:P/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.1}, "baseSeverity": "MEDIUM", "exploitabilityScore": 5.1, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-345"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:zerocoin:libzerocoin:*:*:*:*:*:*:*:*", "versionEndExcluding": "2017-11-15", "matchCriteriaId": "8F889383-9916-48A3-AFFE-A149BCA7BDF9"}]}]}], "references": [{"url": "https://github.com/Zerocoin/libzerocoin/commit/ce103a09ec079d0a0ed95475992348bed6e860de", "source": "cna@vuldb.com", "tags": ["Patch"]}, {"url": "https://github.com/Zerocoin/libzerocoin/pull/16", "source": "cna@vuldb.com", "tags": ["Issue Tracking"]}, {"url": "https://vuldb.com/?ctiid.222318", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.222318", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Zerocoin/libzerocoin/commit/ce103a09ec079d0a0ed95475992348bed6e860de"}}