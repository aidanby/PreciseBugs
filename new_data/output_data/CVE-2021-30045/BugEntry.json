{"buggy_code": ["/*\n * Copyright (c) 2021, Idan Horowitz <idan.horowitz@gmail.com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#pragma once\n\n#include <AK/Function.h>\n#include <AK/IterationDecision.h>\n#include <AK/Span.h>\n#include <AK/Stream.h>\n#include <AK/String.h>\n#include <AK/Vector.h>\n#include <string.h>\n\nnamespace Archive {\n\n// NOTE: Due to the format of zip files compression is streamed and decompression is random access.\n\nstatic constexpr u8 end_of_central_directory_signature[] = { 0x50, 0x4b, 0x05, 0x06 }; // 'PK\\x05\\x06'\nstruct [[gnu::packed]] EndOfCentralDirectory {\n    u16 disk_number;\n    u16 central_directory_start_disk;\n    u16 disk_records_count;\n    u16 total_records_count;\n    u32 central_directory_size;\n    u32 central_directory_offset;\n    u16 comment_length;\n    const u8* comment;\n\n    bool read(ReadonlyBytes buffer)\n    {\n        auto fields_size = sizeof(EndOfCentralDirectory) - sizeof(u8*);\n        if (buffer.size() < fields_size)\n            return false;\n        if (memcmp(buffer.data(), end_of_central_directory_signature, sizeof(end_of_central_directory_signature)) != 0)\n            return false;\n        memcpy(reinterpret_cast<void*>(&disk_number), buffer.data() + sizeof(end_of_central_directory_signature), fields_size);\n        comment = buffer.data() + sizeof(end_of_central_directory_signature) + fields_size;\n        return true;\n    }\n\n    void write(OutputStream& stream) const\n    {\n        stream.write_or_error({ end_of_central_directory_signature, sizeof(end_of_central_directory_signature) });\n        stream << disk_number;\n        stream << central_directory_start_disk;\n        stream << disk_records_count;\n        stream << total_records_count;\n        stream << central_directory_size;\n        stream << central_directory_offset;\n        stream << comment_length;\n        if (comment_length > 0)\n            stream.write_or_error({ comment, comment_length });\n    }\n};\n\nstatic constexpr u8 central_directory_record_signature[] = { 0x50, 0x4b, 0x01, 0x02 }; // 'PK\\x01\\x02'\nstruct [[gnu::packed]] CentralDirectoryRecord {\n    u16 made_by_version;\n    u16 minimum_version;\n    u16 general_purpose_flags;\n    u16 compression_method;\n    u16 modification_time;\n    u16 modification_date;\n    u32 crc32;\n    u32 compressed_size;\n    u32 uncompressed_size;\n    u16 name_length;\n    u16 extra_data_length;\n    u16 comment_length;\n    u16 start_disk;\n    u16 internal_attributes;\n    u32 external_attributes;\n    u32 local_file_header_offset;\n    const u8* name;\n    const u8* extra_data;\n    const u8* comment;\n\n    bool read(ReadonlyBytes buffer)\n    {\n        auto fields_size = sizeof(CentralDirectoryRecord) - (sizeof(u8*) * 3);\n        if (buffer.size() < fields_size)\n            return false;\n        if (memcmp(buffer.data(), central_directory_record_signature, sizeof(central_directory_record_signature)) != 0)\n            return false;\n        memcpy(reinterpret_cast<void*>(&made_by_version), buffer.data() + sizeof(central_directory_record_signature), fields_size);\n        name = buffer.data() + sizeof(central_directory_record_signature) + fields_size;\n        extra_data = name + name_length;\n        comment = extra_data + extra_data_length;\n        return true;\n    }\n\n    void write(OutputStream& stream) const\n    {\n        stream.write_or_error({ central_directory_record_signature, sizeof(central_directory_record_signature) });\n        stream << made_by_version;\n        stream << minimum_version;\n        stream << general_purpose_flags;\n        stream << compression_method;\n        stream << modification_time;\n        stream << modification_date;\n        stream << crc32;\n        stream << compressed_size;\n        stream << uncompressed_size;\n        stream << name_length;\n        stream << extra_data_length;\n        stream << comment_length;\n        stream << start_disk;\n        stream << internal_attributes;\n        stream << external_attributes;\n        stream << local_file_header_offset;\n        if (name_length > 0)\n            stream.write_or_error({ name, name_length });\n        if (extra_data_length > 0)\n            stream.write_or_error({ extra_data, extra_data_length });\n        if (comment_length > 0)\n            stream.write_or_error({ comment, comment_length });\n    }\n\n    [[nodiscard]] size_t size() const\n    {\n        return sizeof(central_directory_record_signature) + (sizeof(CentralDirectoryRecord) - (sizeof(u8*) * 3)) + name_length + extra_data_length + comment_length;\n    }\n};\nstatic constexpr u32 zip_directory_external_attribute = 1 << 4;\n\nstatic constexpr u8 local_file_header_signature[] = { 0x50, 0x4b, 0x03, 0x04 }; // 'PK\\x03\\x04'\nstruct [[gnu::packed]] LocalFileHeader {\n    u16 minimum_version;\n    u16 general_purpose_flags;\n    u16 compression_method;\n    u16 modification_time;\n    u16 modification_date;\n    u32 crc32;\n    u32 compressed_size;\n    u32 uncompressed_size;\n    u16 name_length;\n    u16 extra_data_length;\n    const u8* name;\n    const u8* extra_data;\n    const u8* compressed_data;\n\n    bool read(ReadonlyBytes buffer)\n    {\n        auto fields_size = sizeof(LocalFileHeader) - (sizeof(u8*) * 3);\n        if (buffer.size() < fields_size)\n            return false;\n        if (memcmp(buffer.data(), local_file_header_signature, sizeof(local_file_header_signature)) != 0)\n            return false;\n        memcpy(reinterpret_cast<void*>(&minimum_version), buffer.data() + sizeof(local_file_header_signature), fields_size);\n        name = buffer.data() + sizeof(local_file_header_signature) + fields_size;\n        extra_data = name + name_length;\n        compressed_data = extra_data + extra_data_length;\n        return true;\n    }\n\n    void write(OutputStream& stream) const\n    {\n        stream.write_or_error({ local_file_header_signature, sizeof(local_file_header_signature) });\n        stream << minimum_version;\n        stream << general_purpose_flags;\n        stream << compression_method;\n        stream << modification_time;\n        stream << modification_date;\n        stream << crc32;\n        stream << compressed_size;\n        stream << uncompressed_size;\n        stream << name_length;\n        stream << extra_data_length;\n        if (name_length > 0)\n            stream.write_or_error({ name, name_length });\n        if (extra_data_length > 0)\n            stream.write_or_error({ extra_data, extra_data_length });\n        if (compressed_size > 0)\n            stream.write_or_error({ compressed_data, compressed_size });\n    }\n};\n\nenum ZipCompressionMethod : u16 {\n    Store = 0,\n    Shrink = 1,\n    Reduce1 = 2,\n    Reduce2 = 3,\n    Reduce3 = 4,\n    Reduce4 = 5,\n    Implode = 6,\n    Reserved = 7,\n    Deflate = 8\n};\n\nstruct ZipMember {\n    String name;\n    ReadonlyBytes compressed_data; // TODO: maybe the decompression/compression should be handled by LibArchive instead of the user?\n    ZipCompressionMethod compression_method;\n    u32 uncompressed_size;\n    u32 crc32;\n    bool is_directory;\n};\n\nclass Zip {\npublic:\n    static Optional<Zip> try_create(const ReadonlyBytes& buffer);\n    bool for_each_member(Function<IterationDecision(const ZipMember&)>);\n\nprivate:\n    static bool find_end_of_central_directory_offset(const ReadonlyBytes&, size_t& offset);\n\n    u16 member_count { 0 };\n    size_t members_start_offset { 0 };\n    ReadonlyBytes m_input_data;\n};\n\nclass ZipOutputStream {\npublic:\n    ZipOutputStream(OutputStream&);\n    void add_member(const ZipMember&);\n    void finish();\n\nprivate:\n    OutputStream& m_stream;\n    Vector<ZipMember> m_members;\n\n    bool m_finished { false };\n};\n\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2021, Idan Horowitz <idan.horowitz@gmail.com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#pragma once\n\n#include <AK/Function.h>\n#include <AK/IterationDecision.h>\n#include <AK/Span.h>\n#include <AK/Stream.h>\n#include <AK/String.h>\n#include <AK/Vector.h>\n#include <string.h>\n\nnamespace Archive {\n\n// NOTE: Due to the format of zip files compression is streamed and decompression is random access.\n\nstatic constexpr u8 end_of_central_directory_signature[] = { 0x50, 0x4b, 0x05, 0x06 }; // 'PK\\x05\\x06'\nstruct [[gnu::packed]] EndOfCentralDirectory {\n    u16 disk_number;\n    u16 central_directory_start_disk;\n    u16 disk_records_count;\n    u16 total_records_count;\n    u32 central_directory_size;\n    u32 central_directory_offset;\n    u16 comment_length;\n    const u8* comment;\n\n    bool read(ReadonlyBytes buffer)\n    {\n        auto fields_size = sizeof(EndOfCentralDirectory) - sizeof(u8*);\n        if (buffer.size() < sizeof(end_of_central_directory_signature) + fields_size)\n            return false;\n        if (memcmp(buffer.data(), end_of_central_directory_signature, sizeof(end_of_central_directory_signature)) != 0)\n            return false;\n        memcpy(reinterpret_cast<void*>(&disk_number), buffer.data() + sizeof(end_of_central_directory_signature), fields_size);\n        if (buffer.size() < sizeof(end_of_central_directory_signature) + fields_size + comment_length)\n            return false;\n        comment = buffer.data() + sizeof(end_of_central_directory_signature) + fields_size;\n        return true;\n    }\n\n    void write(OutputStream& stream) const\n    {\n        stream.write_or_error({ end_of_central_directory_signature, sizeof(end_of_central_directory_signature) });\n        stream << disk_number;\n        stream << central_directory_start_disk;\n        stream << disk_records_count;\n        stream << total_records_count;\n        stream << central_directory_size;\n        stream << central_directory_offset;\n        stream << comment_length;\n        if (comment_length > 0)\n            stream.write_or_error({ comment, comment_length });\n    }\n};\n\nstatic constexpr u8 central_directory_record_signature[] = { 0x50, 0x4b, 0x01, 0x02 }; // 'PK\\x01\\x02'\nstruct [[gnu::packed]] CentralDirectoryRecord {\n    u16 made_by_version;\n    u16 minimum_version;\n    u16 general_purpose_flags;\n    u16 compression_method;\n    u16 modification_time;\n    u16 modification_date;\n    u32 crc32;\n    u32 compressed_size;\n    u32 uncompressed_size;\n    u16 name_length;\n    u16 extra_data_length;\n    u16 comment_length;\n    u16 start_disk;\n    u16 internal_attributes;\n    u32 external_attributes;\n    u32 local_file_header_offset;\n    const u8* name;\n    const u8* extra_data;\n    const u8* comment;\n\n    bool read(ReadonlyBytes buffer)\n    {\n        auto fields_size = sizeof(CentralDirectoryRecord) - (sizeof(u8*) * 3);\n        if (buffer.size() < sizeof(central_directory_record_signature) + fields_size)\n            return false;\n        if (memcmp(buffer.data(), central_directory_record_signature, sizeof(central_directory_record_signature)) != 0)\n            return false;\n        memcpy(reinterpret_cast<void*>(&made_by_version), buffer.data() + sizeof(central_directory_record_signature), fields_size);\n        if (buffer.size() < sizeof(end_of_central_directory_signature) + fields_size + comment_length + name_length + extra_data_length)\n            return false;\n        name = buffer.data() + sizeof(central_directory_record_signature) + fields_size;\n        extra_data = name + name_length;\n        comment = extra_data + extra_data_length;\n        return true;\n    }\n\n    void write(OutputStream& stream) const\n    {\n        stream.write_or_error({ central_directory_record_signature, sizeof(central_directory_record_signature) });\n        stream << made_by_version;\n        stream << minimum_version;\n        stream << general_purpose_flags;\n        stream << compression_method;\n        stream << modification_time;\n        stream << modification_date;\n        stream << crc32;\n        stream << compressed_size;\n        stream << uncompressed_size;\n        stream << name_length;\n        stream << extra_data_length;\n        stream << comment_length;\n        stream << start_disk;\n        stream << internal_attributes;\n        stream << external_attributes;\n        stream << local_file_header_offset;\n        if (name_length > 0)\n            stream.write_or_error({ name, name_length });\n        if (extra_data_length > 0)\n            stream.write_or_error({ extra_data, extra_data_length });\n        if (comment_length > 0)\n            stream.write_or_error({ comment, comment_length });\n    }\n\n    [[nodiscard]] size_t size() const\n    {\n        return sizeof(central_directory_record_signature) + (sizeof(CentralDirectoryRecord) - (sizeof(u8*) * 3)) + name_length + extra_data_length + comment_length;\n    }\n};\nstatic constexpr u32 zip_directory_external_attribute = 1 << 4;\n\nstatic constexpr u8 local_file_header_signature[] = { 0x50, 0x4b, 0x03, 0x04 }; // 'PK\\x03\\x04'\nstruct [[gnu::packed]] LocalFileHeader {\n    u16 minimum_version;\n    u16 general_purpose_flags;\n    u16 compression_method;\n    u16 modification_time;\n    u16 modification_date;\n    u32 crc32;\n    u32 compressed_size;\n    u32 uncompressed_size;\n    u16 name_length;\n    u16 extra_data_length;\n    const u8* name;\n    const u8* extra_data;\n    const u8* compressed_data;\n\n    bool read(ReadonlyBytes buffer)\n    {\n        auto fields_size = sizeof(LocalFileHeader) - (sizeof(u8*) * 3);\n        if (buffer.size() < sizeof(local_file_header_signature) + fields_size)\n            return false;\n        if (memcmp(buffer.data(), local_file_header_signature, sizeof(local_file_header_signature)) != 0)\n            return false;\n        memcpy(reinterpret_cast<void*>(&minimum_version), buffer.data() + sizeof(local_file_header_signature), fields_size);\n        if (buffer.size() < sizeof(end_of_central_directory_signature) + fields_size + name_length + extra_data_length + compressed_size)\n            return false;\n        name = buffer.data() + sizeof(local_file_header_signature) + fields_size;\n        extra_data = name + name_length;\n        compressed_data = extra_data + extra_data_length;\n        return true;\n    }\n\n    void write(OutputStream& stream) const\n    {\n        stream.write_or_error({ local_file_header_signature, sizeof(local_file_header_signature) });\n        stream << minimum_version;\n        stream << general_purpose_flags;\n        stream << compression_method;\n        stream << modification_time;\n        stream << modification_date;\n        stream << crc32;\n        stream << compressed_size;\n        stream << uncompressed_size;\n        stream << name_length;\n        stream << extra_data_length;\n        if (name_length > 0)\n            stream.write_or_error({ name, name_length });\n        if (extra_data_length > 0)\n            stream.write_or_error({ extra_data, extra_data_length });\n        if (compressed_size > 0)\n            stream.write_or_error({ compressed_data, compressed_size });\n    }\n};\n\nenum ZipCompressionMethod : u16 {\n    Store = 0,\n    Shrink = 1,\n    Reduce1 = 2,\n    Reduce2 = 3,\n    Reduce3 = 4,\n    Reduce4 = 5,\n    Implode = 6,\n    Reserved = 7,\n    Deflate = 8\n};\n\nstruct ZipMember {\n    String name;\n    ReadonlyBytes compressed_data; // TODO: maybe the decompression/compression should be handled by LibArchive instead of the user?\n    ZipCompressionMethod compression_method;\n    u32 uncompressed_size;\n    u32 crc32;\n    bool is_directory;\n};\n\nclass Zip {\npublic:\n    static Optional<Zip> try_create(const ReadonlyBytes& buffer);\n    bool for_each_member(Function<IterationDecision(const ZipMember&)>);\n\nprivate:\n    static bool find_end_of_central_directory_offset(const ReadonlyBytes&, size_t& offset);\n\n    u16 member_count { 0 };\n    size_t members_start_offset { 0 };\n    ReadonlyBytes m_input_data;\n};\n\nclass ZipOutputStream {\npublic:\n    ZipOutputStream(OutputStream&);\n    void add_member(const ZipMember&);\n    void finish();\n\nprivate:\n    OutputStream& m_stream;\n    Vector<ZipMember> m_members;\n\n    bool m_finished { false };\n};\n\n}\n"], "filenames": ["Userland/Libraries/LibArchive/Zip.h"], "buggy_code_start_loc": [55], "buggy_code_end_loc": [172], "fixing_code_start_loc": [55], "fixing_code_end_loc": [179], "type": "CWE-120", "message": "SerenityOS 2021-03-27 contains a buffer overflow vulnerability in the EndOfCentralDirectory::read() function.", "other": {"cve": {"id": "CVE-2021-30045", "sourceIdentifier": "cve@mitre.org", "published": "2021-04-06T13:15:14.543", "lastModified": "2022-12-08T18:55:41.790", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "SerenityOS 2021-03-27 contains a buffer overflow vulnerability in the EndOfCentralDirectory::read() function."}, {"lang": "es", "value": "SerenityOS hasta el 27-03-2021, contiene una vulnerabilidad de desbordamiento del b\u00fafer en la funci\u00f3n EndOfCentralDirectory::read()"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:serenityos:serenityos:2021-03-27:*:*:*:*:*:*:*", "matchCriteriaId": "418C100E-2C4B-4568-A8F6-E0122F20DB19"}]}]}], "references": [{"url": "https://github.com/SerenityOS/serenity/commit/4317db7498eaa5a37068052bb0310fbc6a5f78e4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/SerenityOS/serenity/issues/5975", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/SerenityOS/serenity/pull/5977", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/SerenityOS/serenity/commit/4317db7498eaa5a37068052bb0310fbc6a5f78e4"}}