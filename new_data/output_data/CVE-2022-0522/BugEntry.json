{"buggy_code": ["/* radare2 - LGPL - Copyright 2013-2022 - pancake */\n\n#include <r_anal.h>\n#include <r_lib.h>\n#include <ht_uu.h>\n#include <arm.h>\n#include <capstone.h>\n#include <arm.h>\n#include <r_util/r_assert.h>\n#include \"./anal_arm_hacks.inc\"\n\n/* arm64 */\n#define IMM64(x) (ut64)(insn->detail->arm64.operands[x].imm)\n#define INSOP64(x) insn->detail->arm64.operands[x]\n\n/* arm32 */\n#define REG(x) r_str_getf (cs_reg_name (*handle, insn->detail->arm.operands[x].reg))\n#define REG64(x) r_str_getf (cs_reg_name (*handle, insn->detail->arm64.operands[x].reg))\n#define REGID64(x) insn->detail->arm64.operands[x].reg\n#define REGID(x) insn->detail->arm.operands[x].reg\n#define IMM(x) (ut32)(insn->detail->arm.operands[x].imm)\n#define INSOP(x) insn->detail->arm.operands[x]\n#define MEMBASE(x) r_str_getf (cs_reg_name (*handle, insn->detail->arm.operands[x].mem.base))\n#define MEMBASE64(x) r_str_getf (cs_reg_name (*handle, insn->detail->arm64.operands[x].mem.base))\n#define REGBASE(x) insn->detail->arm.operands[x].mem.base\n#define REGBASE64(x) insn->detail->arm64.operands[x].mem.base\n// s/index/base|reg/\n#define MEMINDEX(x) r_str_getf (cs_reg_name (*handle, insn->detail->arm.operands[x].mem.index))\n#define HASMEMINDEX(x) (insn->detail->arm.operands[x].mem.index != ARM_REG_INVALID)\n#define MEMINDEX64(x) r_str_getf (cs_reg_name (*handle, insn->detail->arm64.operands[x].mem.index))\n#define HASMEMINDEX64(x) (insn->detail->arm64.operands[x].mem.index != ARM64_REG_INVALID)\n#define ISMEMINDEXSUB(x) insn->detail->arm.operands[x].subtracted\n#define MEMDISP(x) insn->detail->arm.operands[x].mem.disp\n#define MEMDISP64(x) (ut64)insn->detail->arm64.operands[x].mem.disp\n#define ISIMM(x) (insn->detail->arm.operands[x].type == ARM_OP_IMM)\n#define ISIMM64(x) (insn->detail->arm64.operands[x].type & (ARM64_OP_IMM | ARM64_OP_CIMM | ARM64_OP_FP))\n#define ISREG(x) (insn->detail->arm.operands[x].type == ARM_OP_REG)\n#define ISREG64(x) (insn->detail->arm64.operands[x].type == ARM64_OP_REG)\n#define ISMEM(x) (insn->detail->arm.operands[x].type == ARM_OP_MEM)\n#define ISMEM64(x) (insn->detail->arm64.operands[x].type == ARM64_OP_MEM)\n#define EXT64(x) decode_sign_ext (insn->detail->arm64.operands[x].ext)\n\n#if CS_API_MAJOR > 3\n#define LSHIFT(x) insn->detail->arm.operands[x].mem.lshift\n#define LSHIFT2(x) insn->detail->arm.operands[x].shift.value // Dangerous, returns value even if isn't LSL\n#define LSHIFT2_64(x) insn->detail->arm64.operands[x].shift.value\n#else\n#define LSHIFT(x) 0\n#define LSHIFT2(x) 0\n#define LSHIFT2_64(x) 0\n#endif\n#define OPCOUNT() insn->detail->arm.op_count\n#define OPCOUNT64() insn->detail->arm64.op_count\n#define ISSHIFTED(x) (insn->detail->arm.operands[x].shift.type != ARM_SFT_INVALID && insn->detail->arm.operands[x].shift.value != 0)\n#define ISSHIFTED64(x) (insn->detail->arm64.operands[x].shift.type != ARM64_SFT_INVALID && insn->detail->arm64.operands[x].shift.value != 0)\n#define SHIFTTYPE(x) insn->detail->arm.operands[x].shift.type\n#define SHIFTVALUE(x) insn->detail->arm.operands[x].shift.value\n\n#define ISWRITEBACK32() insn->detail->arm.writeback\n#define ISPREINDEX32() (((OPCOUNT () == 2) && (ISMEM (1)) && (ISWRITEBACK32 ())) || ((OPCOUNT () == 3) && (ISMEM (2)) && (ISWRITEBACK32 ())))\n#define ISPOSTINDEX32() (((OPCOUNT () == 3) && (ISIMM (2) || ISREG (2)) && (ISWRITEBACK32 ())) || ((OPCOUNT () == 4) && (ISIMM (3) || ISREG (3)) && (ISWRITEBACK32 ())))\n#define ISWRITEBACK64() (insn->detail->arm64.writeback == true)\n#define ISPREINDEX64() (((OPCOUNT64() == 2) && (ISMEM64(1)) && (ISWRITEBACK64())) || ((OPCOUNT64() == 3) && (ISMEM64(2)) && (ISWRITEBACK64())))\n#define ISPOSTINDEX64() (((OPCOUNT64() == 3) && (ISIMM64(2)) && (ISWRITEBACK64())) || ((OPCOUNT64() == 4) && (ISIMM64(3)) && (ISWRITEBACK64())))\n\nstatic R_TH_LOCAL HtUU *ht_itblock = NULL;\nstatic R_TH_LOCAL HtUU *ht_it = NULL;\n\n#define BITMASK_BY_WIDTH_COUNT 64\nstatic const ut64 bitmask_by_width[BITMASK_BY_WIDTH_COUNT] = {\n\t0x1, 0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f, 0xff, 0x1ff, 0x3ff, 0x7ff,\n\t0xfff, 0x1fff, 0x3fff, 0x7fff, 0xffff, 0x1ffff, 0x3ffff, 0x7ffff,\n\t0xfffff, 0x1fffff, 0x3fffff, 0x7fffff, 0xffffff, 0x1ffffffLL, 0x3ffffffLL,\n\t0x7ffffffLL, 0xfffffffLL, 0x1fffffffLL, 0x3fffffffLL, 0x7fffffffLL, 0xffffffffLL,\n\t0x1ffffffffLL, 0x3ffffffffLL, 0x7ffffffffLL, 0xfffffffffLL, 0x1fffffffffLL,\n\t0x3fffffffffLL, 0x7fffffffffLL, 0xffffffffffLL, 0x1ffffffffffLL, 0x3ffffffffffLL,\n\t0x7ffffffffffLL, 0xfffffffffffLL, 0x1fffffffffffLL, 0x3fffffffffffLL, 0x7fffffffffffLL,\n\t0xffffffffffffLL, 0x1ffffffffffffLL, 0x3ffffffffffffLL, 0x7ffffffffffffLL,\n\t0xfffffffffffffLL, 0x1fffffffffffffLL, 0x3fffffffffffffLL, 0x7fffffffffffffLL,\n\t0xffffffffffffffLL, 0x1ffffffffffffffLL, 0x3ffffffffffffffLL, 0x7ffffffffffffffLL,\n\t0xfffffffffffffffLL, 0x1fffffffffffffffLL, 0x3fffffffffffffffLL, 0x7fffffffffffffffLL, 0xffffffffffffffffLL\n};\n\nstatic const char *shift_type_name(arm_shifter type) {\n\tswitch (type) {\n\tcase ARM_SFT_ASR:\n\t\treturn \"asr\";\n\tcase ARM_SFT_LSL:\n\t\treturn \"lsl\";\n\tcase ARM_SFT_LSR:\n\t\treturn \"lsr\";\n\tcase ARM_SFT_ROR:\n\t\treturn \"ror\";\n\tcase ARM_SFT_RRX:\n\t\treturn \"rrx\";\n\tcase ARM_SFT_ASR_REG:\n\t\treturn \"asr_reg\";\n\tcase ARM_SFT_LSL_REG:\n\t\treturn \"lsl_reg\";\n\tcase ARM_SFT_LSR_REG:\n\t\treturn \"lsr_reg\";\n\tcase ARM_SFT_ROR_REG:\n\t\treturn \"ror_reg\";\n\tcase ARM_SFT_RRX_REG:\n\t\treturn \"rrx_reg\";\n\tdefault:\n\t\treturn \"\";\n\t}\n}\n\nstatic const char *vector_data_type_name(arm_vectordata_type type) {\n\tswitch (type) {\n\tcase ARM_VECTORDATA_I8:\n\t\treturn \"i8\";\n\tcase ARM_VECTORDATA_I16:\n\t\treturn \"i16\";\n\tcase ARM_VECTORDATA_I32:\n\t\treturn \"i32\";\n\tcase ARM_VECTORDATA_I64:\n\t\treturn \"i64\";\n\tcase ARM_VECTORDATA_S8:\n\t\treturn \"s8\";\n\tcase ARM_VECTORDATA_S16:\n\t\treturn \"s16\";\n\tcase ARM_VECTORDATA_S32:\n\t\treturn \"s32\";\n\tcase ARM_VECTORDATA_S64:\n\t\treturn \"s64\";\n\tcase ARM_VECTORDATA_U8:\n\t\treturn \"u8\";\n\tcase ARM_VECTORDATA_U16:\n\t\treturn \"u16\";\n\tcase ARM_VECTORDATA_U32:\n\t\treturn \"u32\";\n\tcase ARM_VECTORDATA_U64:\n\t\treturn \"u64\";\n\tcase ARM_VECTORDATA_P8:\n\t\treturn \"p8\";\n\tcase ARM_VECTORDATA_F32:\n\t\treturn \"f32\";\n\tcase ARM_VECTORDATA_F64:\n\t\treturn \"f64\";\n\tcase ARM_VECTORDATA_F16F64:\n\t\treturn \"f16.f64\";\n\tcase ARM_VECTORDATA_F64F16:\n\t\treturn \"f64.f16\";\n\tcase ARM_VECTORDATA_F32F16:\n\t\treturn \"f32.f16\";\n\tcase ARM_VECTORDATA_F16F32:\n\t\treturn \"f16.f32\";\n\tcase ARM_VECTORDATA_F64F32:\n\t\treturn \"f64.f32\";\n\tcase ARM_VECTORDATA_F32F64:\n\t\treturn \"f32.f64\";\n\tcase ARM_VECTORDATA_S32F32:\n\t\treturn \"s32.f32\";\n\tcase ARM_VECTORDATA_U32F32:\n\t\treturn \"u32.f32\";\n\tcase ARM_VECTORDATA_F32S32:\n\t\treturn \"f32.s32\";\n\tcase ARM_VECTORDATA_F32U32:\n\t\treturn \"f32.u32\";\n\tcase ARM_VECTORDATA_F64S16:\n\t\treturn \"f64.s16\";\n\tcase ARM_VECTORDATA_F32S16:\n\t\treturn \"f32.s16\";\n\tcase ARM_VECTORDATA_F64S32:\n\t\treturn \"f64.s32\";\n\tcase ARM_VECTORDATA_S16F64:\n\t\treturn \"s16.f64\";\n\tcase ARM_VECTORDATA_S16F32:\n\t\treturn \"s16.f64\";\n\tcase ARM_VECTORDATA_S32F64:\n\t\treturn \"s32.f64\";\n\tcase ARM_VECTORDATA_U16F64:\n\t\treturn \"u16.f64\";\n\tcase ARM_VECTORDATA_U16F32:\n\t\treturn \"u16.f32\";\n\tcase ARM_VECTORDATA_U32F64:\n\t\treturn \"u32.f64\";\n\tcase ARM_VECTORDATA_F64U16:\n\t\treturn \"f64.u16\";\n\tcase ARM_VECTORDATA_F32U16:\n\t\treturn \"f32.u16\";\n\tcase ARM_VECTORDATA_F64U32:\n\t\treturn \"f64.u32\";\n\tdefault:\n\t\treturn \"\";\n\t}\n}\n\nstatic const char *cc_name(arm_cc cc) {\n\tswitch (cc) {\n\tcase ARM_CC_EQ: // Equal                      Equal\n\t\treturn \"eq\";\n\tcase ARM_CC_NE: // Not equal                  Not equal, or unordered\n\t\treturn \"ne\";\n\tcase ARM_CC_HS: // Carry set                  >, ==, or unordered\n\t\treturn \"hs\";\n\tcase ARM_CC_LO: // Carry clear                Less than\n\t\treturn \"lo\";\n\tcase ARM_CC_MI: // Minus, negative            Less than\n\t\treturn \"mi\";\n\tcase ARM_CC_PL: // Plus, positive or zero     >, ==, or unordered\n\t\treturn \"pl\";\n\tcase ARM_CC_VS: // Overflow                   Unordered\n\t\treturn \"vs\";\n\tcase ARM_CC_VC: // No overflow                Not unordered\n\t\treturn \"vc\";\n\tcase ARM_CC_HI: // Unsigned higher            Greater than, or unordered\n\t\treturn \"hi\";\n\tcase ARM_CC_LS: // Unsigned lower or same     Less than or equal\n\t\treturn \"ls\";\n\tcase ARM_CC_GE: // Greater than or equal      Greater than or equal\n\t\treturn \"ge\";\n\tcase ARM_CC_LT: // Less than                  Less than, or unordered\n\t\treturn \"lt\";\n\tcase ARM_CC_GT: // Greater than               Greater than\n\t\treturn \"gt\";\n\tcase ARM_CC_LE: // Less than or equal         <, ==, or unordered\n\t\treturn \"le\";\n\tdefault:\n\t\treturn \"\";\n\t}\n}\n\nstatic void opex(RStrBuf *buf, csh handle, cs_insn *insn) {\n\tint i;\n\tPJ *pj = pj_new ();\n\tif (!pj) {\n\t\treturn;\n\t}\n\tpj_o (pj);\n\tpj_ka (pj, \"operands\");\n\tcs_arm *x = &insn->detail->arm;\n\tfor (i = 0; i < x->op_count; i++) {\n\t\tcs_arm_op *op = x->operands + i;\n\t\tpj_o (pj);\n\t\tswitch (op->type) {\n\t\tcase ARM_OP_REG:\n\t\t\tpj_ks (pj, \"type\", \"reg\");\n\t\t\tpj_ks (pj, \"value\", cs_reg_name (handle, op->reg));\n\t\t\tbreak;\n\t\tcase ARM_OP_IMM:\n\t\t\tpj_ks (pj, \"type\", \"imm\");\n\t\t\tpj_ki (pj, \"value\", op->imm);\n\t\t\tbreak;\n\t\tcase ARM_OP_MEM:\n\t\t\tpj_ks (pj, \"type\", \"mem\");\n\t\t\tif (op->mem.base != ARM_REG_INVALID) {\n\t\t\t\tpj_ks (pj, \"base\", cs_reg_name (handle, op->mem.base));\n\t\t\t}\n\t\t\tif (op->mem.index != ARM_REG_INVALID) {\n\t\t\t\tpj_ks (pj, \"index\", cs_reg_name (handle, op->mem.index));\n\t\t\t}\n\t\t\tpj_ki (pj, \"scale\", op->mem.scale);\n\t\t\tpj_ki (pj, \"disp\", op->mem.disp);\n\t\t\tbreak;\n\t\tcase ARM_OP_FP:\n\t\t\tpj_ks (pj, \"type\", \"fp\");\n\t\t\tpj_kd (pj, \"value\", op->fp);\n\t\t\tbreak;\n\t\tcase ARM_OP_CIMM:\n\t\t\tpj_ks (pj, \"type\", \"cimm\");\n\t\t\tpj_ki (pj, \"value\", op->imm);\n\t\t\tbreak;\n\t\tcase ARM_OP_PIMM:\n\t\t\tpj_ks (pj, \"type\", \"pimm\");\n\t\t\tpj_ki (pj, \"value\", op->imm);\n\t\t\tbreak;\n\t\tcase ARM_OP_SETEND:\n\t\t\tpj_ks (pj, \"type\", \"setend\");\n\t\t\tswitch (op->setend) {\n\t\t\tcase ARM_SETEND_BE:\n\t\t\t\tpj_ks (pj, \"value\", \"be\");\n\t\t\t\tbreak;\n\t\t\tcase ARM_SETEND_LE:\n\t\t\t\tpj_ks (pj, \"value\", \"le\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpj_ks (pj, \"value\", \"invalid\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ARM_OP_SYSREG:\n\t\t\tpj_ks (pj, \"type\", \"sysreg\");\n\t\t\tpj_ks (pj, \"value\", r_str_get_fail (cs_reg_name (handle, op->reg), \"\"));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpj_ks (pj, \"type\", \"invalid\");\n\t\t\tbreak;\n\t\t}\n\t\tif (op->shift.type != ARM_SFT_INVALID) {\n\t\t\tpj_ko (pj, \"shift\");\n\t\t\tswitch (op->shift.type) {\n\t\t\tcase ARM_SFT_ASR:\n\t\t\tcase ARM_SFT_LSL:\n\t\t\tcase ARM_SFT_LSR:\n\t\t\tcase ARM_SFT_ROR:\n\t\t\tcase ARM_SFT_RRX:\n\t\t\t\tpj_ks (pj, \"type\", shift_type_name (op->shift.type));\n\t\t\t\tpj_kn (pj, \"value\", (ut64)op->shift.value);\n\t\t\t\tbreak;\n\t\t\tcase ARM_SFT_ASR_REG:\n\t\t\tcase ARM_SFT_LSL_REG:\n\t\t\tcase ARM_SFT_LSR_REG:\n\t\t\tcase ARM_SFT_ROR_REG:\n\t\t\tcase ARM_SFT_RRX_REG:\n\t\t\t\tpj_ks (pj, \"type\", shift_type_name (op->shift.type));\n\t\t\t\tpj_ks (pj, \"value\", cs_reg_name (handle, op->shift.value));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpj_end (pj); /* o shift */\n\t\t}\n\t\tif (op->vector_index != -1) {\n\t\t\tpj_ki (pj, \"vector_index\", op->vector_index);\n\t\t}\n\t\tif (op->subtracted) {\n\t\t\tpj_kb (pj, \"subtracted\", true);\n\t\t}\n\t\tpj_end (pj); /* o operand */\n\t}\n\tpj_end (pj); /* a operands */\n\tif (x->usermode) {\n\t\tpj_kb (pj, \"usermode\", true);\n\t}\n\tif (x->update_flags) {\n\t\tpj_kb (pj, \"update_flags\", true);\n\t}\n\tif (x->writeback) {\n\t\tpj_kb (pj, \"writeback\", true);\n\t}\n\tif (x->vector_size) {\n\t\tpj_ki (pj, \"vector_size\", x->vector_size);\n\t}\n\tif (x->vector_data != ARM_VECTORDATA_INVALID) {\n\t\tpj_ks (pj, \"vector_data\", vector_data_type_name (x->vector_data));\n\t}\n\tif (x->cps_mode != ARM_CPSMODE_INVALID) {\n\t\tpj_ki (pj, \"cps_mode\", x->cps_mode);\n\t}\n\tif (x->cps_flag != ARM_CPSFLAG_INVALID) {\n\t\tpj_ki (pj, \"cps_flag\", x->cps_flag);\n\t}\n\tif (x->cc != ARM_CC_INVALID && x->cc != ARM_CC_AL) {\n\t\tpj_ks (pj, \"cc\", cc_name (x->cc));\n\t}\n\tif (x->mem_barrier != ARM_MB_INVALID) {\n\t\tpj_ki (pj, \"mem_barrier\", x->mem_barrier - 1);\n\t}\n\tpj_end (pj);\n\n\tr_strbuf_init (buf);\n\tr_strbuf_append (buf, pj_string (pj));\n\tpj_free (pj);\n}\n\nstatic int arm64_reg_width(int reg) {\n\tswitch (reg) {\n\tcase ARM64_REG_W0:\n\tcase ARM64_REG_W1:\n\tcase ARM64_REG_W2:\n\tcase ARM64_REG_W3:\n\tcase ARM64_REG_W4:\n\tcase ARM64_REG_W5:\n\tcase ARM64_REG_W6:\n\tcase ARM64_REG_W7:\n\tcase ARM64_REG_W8:\n\tcase ARM64_REG_W9:\n\tcase ARM64_REG_W10:\n\tcase ARM64_REG_W11:\n\tcase ARM64_REG_W12:\n\tcase ARM64_REG_W13:\n\tcase ARM64_REG_W14:\n\tcase ARM64_REG_W15:\n\tcase ARM64_REG_W16:\n\tcase ARM64_REG_W17:\n\tcase ARM64_REG_W18:\n\tcase ARM64_REG_W19:\n\tcase ARM64_REG_W20:\n\tcase ARM64_REG_W21:\n\tcase ARM64_REG_W22:\n\tcase ARM64_REG_W23:\n\tcase ARM64_REG_W24:\n\tcase ARM64_REG_W25:\n\tcase ARM64_REG_W26:\n\tcase ARM64_REG_W27:\n\tcase ARM64_REG_W28:\n\tcase ARM64_REG_W29:\n\tcase ARM64_REG_W30:\n\tcase ARM64_REG_S0:\n\tcase ARM64_REG_S1:\n\tcase ARM64_REG_S2:\n\tcase ARM64_REG_S3:\n\tcase ARM64_REG_S4:\n\tcase ARM64_REG_S5:\n\tcase ARM64_REG_S6:\n\tcase ARM64_REG_S7:\n\tcase ARM64_REG_S8:\n\tcase ARM64_REG_S9:\n\tcase ARM64_REG_S10:\n\tcase ARM64_REG_S11:\n\tcase ARM64_REG_S12:\n\tcase ARM64_REG_S13:\n\tcase ARM64_REG_S14:\n\tcase ARM64_REG_S15:\n\tcase ARM64_REG_S16:\n\tcase ARM64_REG_S17:\n\tcase ARM64_REG_S18:\n\tcase ARM64_REG_S19:\n\tcase ARM64_REG_S20:\n\tcase ARM64_REG_S21:\n\tcase ARM64_REG_S22:\n\tcase ARM64_REG_S23:\n\tcase ARM64_REG_S24:\n\tcase ARM64_REG_S25:\n\tcase ARM64_REG_S26:\n\tcase ARM64_REG_S27:\n\tcase ARM64_REG_S28:\n\tcase ARM64_REG_S29:\n\tcase ARM64_REG_S30:\n\tcase ARM64_REG_S31:\n\t\treturn 32;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 64;\n}\n\nstatic const char *cc_name64(arm64_cc cc) {\n\tswitch (cc) {\n\tcase ARM64_CC_EQ: // Equal\n\t\treturn \"eq\";\n\tcase ARM64_CC_NE: // Not equal:                 Not equal, or unordered\n\t\treturn \"ne\";\n\tcase ARM64_CC_HS: // Unsigned higher or same:   >, ==, or unordered\n\t\treturn \"hs\";\n\tcase ARM64_CC_LO: // Unsigned lower or same:    Less than\n\t\treturn \"lo\";\n\tcase ARM64_CC_MI: // Minus, negative:           Less than\n\t\treturn \"mi\";\n\tcase ARM64_CC_PL: // Plus, positive or zero:    >, ==, or unordered\n\t\treturn \"pl\";\n\tcase ARM64_CC_VS: // Overflow:                  Unordered\n\t\treturn \"vs\";\n\tcase ARM64_CC_VC: // No overflow:               Ordered\n\t\treturn \"vc\";\n\tcase ARM64_CC_HI: // Unsigned higher:           Greater than, or unordered\n\t\treturn \"hi\";\n\tcase ARM64_CC_LS: // Unsigned lower or same:    Less than or equal\n\t\treturn \"ls\";\n\tcase ARM64_CC_GE: // Greater than or equal:     Greater than or equal\n\t\treturn \"ge\";\n\tcase ARM64_CC_LT: // Less than:                 Less than, or unordered\n\t\treturn \"lt\";\n\tcase ARM64_CC_GT: // Signed greater than:       Greater than\n\t\treturn \"gt\";\n\tcase ARM64_CC_LE: // Signed less than or equal: <, ==, or unordered\n\t\treturn \"le\";\n\tdefault:\n\t\treturn \"\";\n\t}\n}\n\nstatic const char *extender_name(arm64_extender extender) {\n\tswitch (extender) {\n\tcase ARM64_EXT_UXTB:\n\t\treturn \"uxtb\";\n\tcase ARM64_EXT_UXTH:\n\t\treturn \"uxth\";\n\tcase ARM64_EXT_UXTW:\n\t\treturn \"uxtw\";\n\tcase ARM64_EXT_UXTX:\n\t\treturn \"uxtx\";\n\tcase ARM64_EXT_SXTB:\n\t\treturn \"sxtb\";\n\tcase ARM64_EXT_SXTH:\n\t\treturn \"sxth\";\n\tcase ARM64_EXT_SXTW:\n\t\treturn \"sxtw\";\n\tcase ARM64_EXT_SXTX:\n\t\treturn \"sxtx\";\n\tdefault:\n\t\treturn \"\";\n\t}\n}\n\nstatic const char *vas_name(arm64_vas vas) {\n\tswitch (vas) {\n\tcase ARM64_VAS_8B:\n\t\treturn \"8b\";\n\tcase ARM64_VAS_16B:\n\t\treturn \"16b\";\n\tcase ARM64_VAS_4H:\n\t\treturn \"4h\";\n\tcase ARM64_VAS_8H:\n\t\treturn \"8h\";\n\tcase ARM64_VAS_2S:\n\t\treturn \"2s\";\n\tcase ARM64_VAS_4S:\n\t\treturn \"4s\";\n\tcase ARM64_VAS_2D:\n\t\treturn \"2d\";\n\tcase ARM64_VAS_1D:\n\t\treturn \"1d\";\n\tcase ARM64_VAS_1Q:\n\t\treturn \"1q\";\n#if CS_API_MAJOR > 4\n\tcase ARM64_VAS_1B:\n\t\treturn \"8b\";\n\tcase ARM64_VAS_4B:\n\t\treturn \"8b\";\n\tcase ARM64_VAS_2H:\n\t\treturn \"2h\";\n\tcase ARM64_VAS_1H:\n\t\treturn \"1h\";\n\tcase ARM64_VAS_1S:\n\t\treturn \"1s\";\n#endif\n\tdefault:\n\t\treturn \"\";\n\t}\n}\n\nstatic int vas_size(arm64_vas vas) {\n\tswitch (vas) {\n\tcase ARM64_VAS_8B:\n\tcase ARM64_VAS_16B:\n\t\treturn 8;\n\tcase ARM64_VAS_4H:\n\tcase ARM64_VAS_8H:\n\t\treturn 16;\n\tcase ARM64_VAS_2S:\n\tcase ARM64_VAS_4S:\n\t\treturn 32;\n\tcase ARM64_VAS_2D:\n\tcase ARM64_VAS_1D:\n\t\treturn 64;\n\tcase ARM64_VAS_1Q:\n\t\treturn 128;\n#if CS_API_MAJOR > 4\n\tcase ARM64_VAS_1B:\n\tcase ARM64_VAS_4B:\n\t\treturn 8;\n\tcase ARM64_VAS_2H:\n\tcase ARM64_VAS_1H:\n\t\treturn 16;\n\tcase ARM64_VAS_1S:\n\t\treturn 32;\n#endif\n\tdefault:\n\t\treturn 64;\n\t}\n}\n\nstatic int vas_count(arm64_vas vas) {\n\tswitch (vas) {\n\tcase ARM64_VAS_16B:\n\t\treturn 16;\n\tcase ARM64_VAS_8B:\n\tcase ARM64_VAS_8H:\n\t\treturn 8;\n\tcase ARM64_VAS_4S:\n\tcase ARM64_VAS_4H:\n\t\treturn 4;\n\tcase ARM64_VAS_2D:\n\tcase ARM64_VAS_2S:\n\t\treturn 2;\n\tcase ARM64_VAS_1D:\n\tcase ARM64_VAS_1Q:\n\t\treturn 1;\n#if CS_API_MAJOR > 4\n\tcase ARM64_VAS_4B:\n\t\treturn 4;\n\tcase ARM64_VAS_2H:\n\t\treturn 2;\n\tcase ARM64_VAS_1B:\n\tcase ARM64_VAS_1H:\n\tcase ARM64_VAS_1S:\n\t\treturn 1;\n#endif\n\tdefault:\n\t\treturn 64;\n\t}\n}\n\n#if CS_API_MAJOR == 4\nstatic const char *vess_name(arm64_vess vess) {\n\tswitch (vess) {\n\tcase ARM64_VESS_B:\n\t\treturn \"b\";\n\tcase ARM64_VESS_H:\n\t\treturn \"h\";\n\tcase ARM64_VESS_S:\n\t\treturn \"s\";\n\tcase ARM64_VESS_D:\n\t\treturn \"d\";\n\tdefault:\n\t\treturn \"\";\n\t}\n}\n#endif\n\n#if CS_API_MAJOR == 4\nstatic int vess_size(arm64_vess vess) {\n\tswitch (vess) {\n\tcase ARM64_VESS_B:\n\t\treturn 8;\n\tcase ARM64_VESS_H:\n\t\treturn 16;\n\tcase ARM64_VESS_S:\n\t\treturn 32;\n\tcase ARM64_VESS_D:\n\t\treturn 64;\n\tdefault:\n\t\treturn 64;\n\t}\n}\n#endif\n\nstatic void opex64(RStrBuf *buf, csh handle, cs_insn *insn) {\n\tint i;\n\tPJ *pj = pj_new ();\n\tif (!pj) {\n\t\treturn;\n\t}\n\tpj_o (pj);\n\tpj_ka (pj, \"operands\");\n\tcs_arm64 *x = &insn->detail->arm64;\n\tfor (i = 0; i < x->op_count; i++) {\n\t\tcs_arm64_op *op = x->operands + i;\n\t\tpj_o (pj);\n\t\tswitch (op->type) {\n\t\tcase ARM64_OP_REG:\n\t\t\t{\n\t\t\tpj_ks (pj, \"type\", \"reg\");\n\t\t\tconst char *rn = cs_reg_name (handle, op->reg);\n\t\t\tif (rn) {\n\t\t\t\tpj_ks (pj, \"value\", rn);\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ARM64_OP_REG_MRS:\n\t\t\tpj_ks (pj, \"type\", \"reg_mrs\");\n\t\t\t// TODO value\n\t\t\tbreak;\n\t\tcase ARM64_OP_REG_MSR:\n\t\t\tpj_ks (pj, \"type\", \"reg_msr\");\n\t\t\t// TODO value\n\t\t\tbreak;\n\t\tcase ARM64_OP_IMM:\n\t\t\tpj_ks (pj, \"type\", \"imm\");\n\t\t\tpj_kN (pj, \"value\", op->imm);\n\t\t\tbreak;\n\t\tcase ARM64_OP_MEM:\n\t\t\tpj_ks (pj, \"type\", \"mem\");\n\t\t\tif (op->mem.base != ARM64_REG_INVALID) {\n\t\t\t\tpj_ks (pj, \"base\", cs_reg_name (handle, op->mem.base));\n\t\t\t}\n\t\t\tif (op->mem.index != ARM64_REG_INVALID) {\n\t\t\t\tpj_ks (pj, \"index\", cs_reg_name (handle, op->mem.index));\n\t\t\t}\n\t\t\tpj_ki (pj, \"disp\", op->mem.disp);\n\t\t\tbreak;\n\t\tcase ARM64_OP_FP:\n\t\t\tpj_ks (pj, \"type\", \"fp\");\n\t\t\tpj_kd (pj, \"value\", op->fp);\n\t\t\tbreak;\n\t\tcase ARM64_OP_CIMM:\n\t\t\tpj_ks (pj, \"type\", \"cimm\");\n\t\t\tpj_kN (pj, \"value\", op->imm);\n\t\t\tbreak;\n\t\tcase ARM64_OP_PSTATE:\n\t\t\tpj_ks (pj, \"type\", \"pstate\");\n\t\t\tswitch (op->pstate) {\n\t\t\tcase ARM64_PSTATE_SPSEL:\n\t\t\t\tpj_ks (pj, \"value\", \"spsel\");\n\t\t\t\tbreak;\n\t\t\tcase ARM64_PSTATE_DAIFSET:\n\t\t\t\tpj_ks (pj, \"value\", \"daifset\");\n\t\t\t\tbreak;\n\t\t\tcase ARM64_PSTATE_DAIFCLR:\n\t\t\t\tpj_ks (pj, \"value\", \"daifclr\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpj_ki (pj, \"value\", op->pstate);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ARM64_OP_SYS:\n\t\t\tpj_ks (pj, \"type\", \"sys\");\n\t\t\tpj_kn (pj, \"value\", (ut64)op->sys);\n\t\t\tbreak;\n\t\tcase ARM64_OP_PREFETCH:\n\t\t\tpj_ks (pj, \"type\", \"prefetch\");\n\t\t\tpj_ki (pj, \"value\", op->prefetch - 1);\n\t\t\tbreak;\n\t\tcase ARM64_OP_BARRIER:\n\t\t\tpj_ks (pj, \"type\", \"prefetch\");\n\t\t\tpj_ki (pj, \"value\", op->barrier - 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpj_ks (pj, \"type\", \"invalid\");\n\t\t\tbreak;\n\t\t}\n\t\tif (op->shift.type != ARM64_SFT_INVALID) {\n\t\t\tpj_ko (pj, \"shift\");\n\t\t\tswitch (op->shift.type) {\n\t\t\tcase ARM64_SFT_LSL:\n\t\t\t\tpj_ks (pj, \"type\", \"lsl\");\n\t\t\t\tbreak;\n\t\t\tcase ARM64_SFT_MSL:\n\t\t\t\tpj_ks (pj, \"type\", \"msl\");\n\t\t\t\tbreak;\n\t\t\tcase ARM64_SFT_LSR:\n\t\t\t\tpj_ks (pj, \"type\", \"lsr\");\n\t\t\t\tbreak;\n\t\t\tcase ARM64_SFT_ASR:\n\t\t\t\tpj_ks (pj, \"type\", \"asr\");\n\t\t\t\tbreak;\n\t\t\tcase ARM64_SFT_ROR:\n\t\t\t\tpj_ks (pj, \"type\", \"ror\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpj_kn (pj, \"value\", (ut64)op->shift.value);\n\t\t\tpj_end (pj);\n\t\t}\n\t\tif (op->ext != ARM64_EXT_INVALID) {\n\t\t\tpj_ks (pj, \"ext\", extender_name (op->ext));\n\t\t}\n\t\tif (op->vector_index != -1) {\n\t\t\tpj_ki (pj, \"vector_index\", op->vector_index);\n\t\t}\n\t\tif (op->vas != ARM64_VAS_INVALID) {\n\t\t\tpj_ks (pj, \"vas\", vas_name (op->vas));\n\t\t}\n#if CS_API_MAJOR == 4\n\t\tif (op->vess != ARM64_VESS_INVALID) {\n\t\t\tpj_ks (pj, \"vess\", vess_name (op->vess));\n\t\t}\n#endif\n\t\tpj_end (pj);\n\t}\n\tpj_end (pj);\n\tif (x->update_flags) {\n\t\tpj_kb (pj, \"update_flags\", true);\n\t}\n\tif (x->writeback) {\n\t\tpj_kb (pj, \"writeback\", true);\n\t}\n\tif (x->cc != ARM64_CC_INVALID && x->cc != ARM64_CC_AL && x->cc != ARM64_CC_NV) {\n\t\tpj_ks (pj, \"cc\", cc_name64 (x->cc));\n\t}\n\tpj_end (pj);\n\n\tr_strbuf_init (buf);\n\tr_strbuf_append (buf, pj_string (pj));\n\tpj_free (pj);\n}\n\nstatic int decode_sign_ext(arm64_extender extender) {\n\tswitch (extender) {\n\tcase ARM64_EXT_UXTB:\n\tcase ARM64_EXT_UXTH:\n\tcase ARM64_EXT_UXTW:\n\tcase ARM64_EXT_UXTX:\n\t\treturn 0; // nothing needs to be done for unsigned\n\tcase ARM64_EXT_SXTB:\n\t\treturn 8;\n\tcase ARM64_EXT_SXTH:\n\t\treturn 16;\n\tcase ARM64_EXT_SXTW:\n\t\treturn 32;\n\tcase ARM64_EXT_SXTX:\n\t\treturn 64;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const char *decode_shift(arm_shifter shift) {\n\tstatic const char *E_OP_SR = \">>\";\n\tstatic const char *E_OP_SL = \"<<\";\n\tstatic const char *E_OP_RR = \">>>\";\n\tstatic const char *E_OP_ASR = \">>>>\";\n\tstatic const char *E_OP_VOID = \"\";\n\n\tswitch (shift) {\n\tcase ARM_SFT_ASR:\n\tcase ARM_SFT_ASR_REG:\n\t\treturn E_OP_ASR;\n\n\tcase ARM_SFT_LSR:\n\tcase ARM_SFT_LSR_REG:\n\t\treturn E_OP_SR;\n\n\tcase ARM_SFT_LSL:\n\tcase ARM_SFT_LSL_REG:\n\t\treturn E_OP_SL;\n\n\tcase ARM_SFT_ROR:\n\tcase ARM_SFT_RRX:\n\tcase ARM_SFT_ROR_REG:\n\tcase ARM_SFT_RRX_REG:\n\t\treturn E_OP_RR;\n\n\tdefault:\n\t\tbreak;\n\t}\n\treturn E_OP_VOID;\n}\n\nstatic const char *decode_shift_64(arm64_shifter shift) {\n\tstatic const char *E_OP_SR = \">>\";\n\tstatic const char *E_OP_SL = \"<<\";\n\tstatic const char *E_OP_RR = \">>>\";\n\tstatic const char *E_OP_AR = \">>>>\";\n\tstatic const char *E_OP_VOID = \"\";\n\n\tswitch (shift) {\n\tcase ARM64_SFT_ASR:\n\t\treturn E_OP_AR;\n\tcase ARM64_SFT_LSR:\n\t\treturn E_OP_SR;\n\n\tcase ARM64_SFT_LSL:\n\tcase ARM64_SFT_MSL:\n\t\treturn E_OP_SL;\n\n\tcase ARM64_SFT_ROR:\n\t\treturn E_OP_RR;\n\n\tdefault:\n\t\tbreak;\n\t}\n\treturn E_OP_VOID;\n}\n\n#define DECODE_SHIFT(x) decode_shift(insn->detail->arm.operands[x].shift.type)\n#define DECODE_SHIFT64(x) decode_shift_64(insn->detail->arm64.operands[x].shift.type)\n\nstatic unsigned int regsize32(cs_insn *insn, int n) {\n\tr_return_val_if_fail(n >= 0 && n < insn->detail->arm.op_count, 0);\n\tunsigned int reg = insn->detail->arm.operands[n].reg;\n\tif (reg >= ARM_REG_D0 && reg <= ARM_REG_D31) {\n\t\treturn 8;\n\t}\n\tif (reg >= ARM_REG_Q0 && reg <= ARM_REG_Q15) {\n\t\treturn 16;\n\t}\n\treturn 4; // s0-s31, r0-r15\n}\n\nstatic int regsize64(cs_insn *insn, int n) {\n\tunsigned int reg = insn->detail->arm64.operands[n].reg;\n\tif ( (reg >= ARM64_REG_S0 && reg <= ARM64_REG_S31) ||\n\t\t(reg >= ARM64_REG_W0 && reg <= ARM64_REG_W30) ||\n\t\treg == ARM64_REG_WZR) {\n\t\treturn 4;\n\t}\n\tif (reg >= ARM64_REG_B0 && reg <= ARM64_REG_B31) {\n\t\treturn 1;\n\t}\n\tif (reg >= ARM64_REG_H0 && reg <= ARM64_REG_H31) {\n\t\treturn 2;\n\t}\n\tif ( (reg >= ARM64_REG_Q0 && reg <= ARM64_REG_Q31) ||\n\t\t(reg >= ARM64_REG_V0 && reg <= ARM64_REG_V31) ) {\n\t\treturn 16;\n\t}\n\treturn 8;\n}\n\n#define REGSIZE64(x) regsize64 (insn, x)\n#define REGSIZE32(x) regsize32 (insn, x)\n#define REGBITS64(x) (8 * regsize64 (insn, x))\n#define REGBITS32(x) (8 * regsize32 (insn, x))\n\n#define SET_FLAGS() r_strbuf_appendf (&op->esil, \",$z,zf,:=,%d,$s,nf,:=,%d,$c,cf,:=,%d,$o,vf,:=\", REGBITS64 (0) - 1, REGBITS64 (0), REGBITS64 (0) -1);\n\nstatic int vector_size(cs_arm64_op *op) {\n#if CS_API_MAJOR == 4\n\tif (op->vess) {\n\t\treturn vess_size(op->vess);\n\t}\n#endif\n\tif (op->vas) {\n\t\treturn vas_size(op->vas);\n\t} else {\n\t\treturn 64;\n\t}\n}\n\n// return postfix\nconst char* arm_prefix_cond(RAnalOp *op, int cond_type) {\n\tconst char *close_cond[2];\n\tclose_cond[0] = \"\\0\";\n\tclose_cond[1] = \",}\\0\";\n\tint close_type = 0;\n\tswitch (cond_type) {\n\tcase ARM_CC_EQ:\n\t\tclose_type = 1;\n\t\tr_strbuf_appendf (&op->esil, \"zf,?{,\");\n\t\tbreak;\n\tcase ARM_CC_NE:\n\t\tclose_type = 1;\n\t\tr_strbuf_appendf (&op->esil, \"zf,!,?{,\");\n\t\tbreak;\n\tcase ARM_CC_HS:\n\t\tclose_type = 1;\n\t\tr_strbuf_appendf (&op->esil, \"cf,?{,\");\n\t\tbreak;\n\tcase ARM_CC_LO:\n\t\tclose_type = 1;\n\t\tr_strbuf_appendf (&op->esil, \"cf,!,?{,\");\n\t\tbreak;\n\tcase ARM_CC_MI:\n\t\tclose_type = 1;\n\t\tr_strbuf_appendf (&op->esil, \"nf,?{,\");\n\t\tbreak;\n\tcase ARM_CC_PL:\n\t\tclose_type = 1;\n\t\tr_strbuf_appendf (&op->esil, \"nf,!,?{,\");\n\t\tbreak;\n\tcase ARM_CC_VS:\n\t\tclose_type = 1;\n\t\tr_strbuf_appendf (&op->esil, \"vf,?{,\");\n\t\tbreak;\n\tcase ARM_CC_VC:\n\t\tclose_type = 1;\n\t\tr_strbuf_appendf (&op->esil, \"vf,!,?{,\");\n\t\tbreak;\n\tcase ARM_CC_HI:\n\t\tclose_type = 1;\n\t\tr_strbuf_appendf (&op->esil, \"cf,zf,!,&,?{,\");\n\t\tbreak;\n\tcase ARM_CC_LS:\n\t\tclose_type = 1;\n\t\tr_strbuf_appendf (&op->esil, \"cf,!,zf,|,?{,\");\n\t\tbreak;\n\tcase ARM_CC_GE:\n\t\tclose_type = 1;\n\t\tr_strbuf_appendf (&op->esil, \"nf,vf,^,!,?{,\");\n\t\tbreak;\n\tcase ARM_CC_LT:\n\t\tclose_type = 1;\n\t\tr_strbuf_appendf (&op->esil, \"nf,vf,^,?{,\");\n\t\tbreak;\n\tcase ARM_CC_GT:\n\t\t// zf == 0 && nf == vf\n\t\tclose_type = 1;\n\t\tr_strbuf_appendf (&op->esil, \"zf,!,nf,vf,^,!,&,?{,\");\n\t\tbreak;\n\tcase ARM_CC_LE:\n\t\t// zf == 1 || nf != vf\n\t\tclose_type = 1;\n\t\tr_strbuf_appendf (&op->esil, \"zf,nf,vf,^,|,?{,\");\n\t\tbreak;\n\tcase ARM_CC_AL:\n\t\t// always executed\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn close_cond[close_type];\n}\n\n/* arm64 */\n\nstatic const char *arg(RAnal *a, csh *handle, cs_insn *insn, char *buf, int n) {\n\tbuf[0] = 0;\n\tswitch (insn->detail->arm.operands[n].type) {\n\tcase ARM_OP_REG:\n\t\tif (ISSHIFTED (n)) {\n\t\t\tsprintf (buf, \"%u,%s,%s\",\n\t\t\tLSHIFT2 (n),\n\t\t\tr_str_getf (cs_reg_name (*handle,\n\t\t\t\tinsn->detail->arm.operands[n].reg)),\n\t\t\tDECODE_SHIFT (n));\n\t\t} else {\n\t\t\tsprintf (buf, \"%s\",\n\t\t\tr_str_getf (cs_reg_name (*handle,\n\t\t\t\tinsn->detail->arm.operands[n].reg)));\n\t\t}\n\t\tbreak;\n\tcase ARM_OP_IMM:\n\t\tif (a->bits == 64) {\n\t\t\t// 64bit only\n\t\t\tsprintf (buf, \"%\"PFMT64d, (ut64)\n\t\t\t\t\tinsn->detail->arm.operands[n].imm);\n\t\t} else {\n\t\t\t// 32bit only\n\t\t\tsprintf (buf, \"%\"PFMT64d, (ut64)(ut32)\n\t\t\t\t\tinsn->detail->arm.operands[n].imm);\n\t\t}\n\t\tbreak;\n\tcase ARM_OP_MEM:\n\t\tbreak;\n\tcase ARM_OP_FP:\n\t\tsprintf (buf, \"%lf\", insn->detail->arm.operands[n].fp);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn buf;\n}\n\n#define ARG(x) arg(a, handle, insn, str[x], x)\n\n#define VEC64(n) insn->detail->arm64.operands[n].vess\n#define VEC64_APPEND(sb, n, i) vector64_append(sb, handle, insn, n, i)\n#define VEC64_MASK(sh, sz) (bitmask_by_width[63]^(bitmask_by_width[sz-1]<<sh))\n\nstatic void vector64_append(RStrBuf *sb, csh *handle, cs_insn *insn, int n, int i) {\n\tcs_arm64_op op = INSOP64 (n);\n\n\tif (op.vector_index != -1) {\n\t\ti = op.vector_index;\n\t}\n\n#if CS_API_MAJOR == 4\n\tconst bool isvessas = (op.vess || op.vas);\n#else\n\tconst bool isvessas = op.vas;\n#endif\n\tif (isvessas && i != -1) {\n\t\tint size = vector_size (&op);\n\t\tint shift = i * size;\n\t\tchar *regc = \"l\";\n\t\tif (shift >= 64) {\n\t\t\tshift -= 64;\n\t\t\tregc = \"h\";\n\t\t}\n\n\t\tsize_t s = sizeof (bitmask_by_width) / sizeof (*bitmask_by_width);\n\t\tint width = size > 0? (size - 1) % s: 0;\n\t\tif (shift > 0) {\n\t\t\tr_strbuf_appendf (sb, \"0x%\"PFMT64x\",%d,%s%s,>>,&\",\n\t\t\t\tbitmask_by_width[width], shift, REG64 (n), regc);\n\t\t} else {\n\t\t\tr_strbuf_appendf (sb, \"0x%\"PFMT64x\",%s%s,&\",\n\t\t\t\tbitmask_by_width[width], REG64 (n), regc);\n\t\t}\n\t} else {\n\t\tr_strbuf_appendf (sb, \"%s\", REG64 (n));\n\t}\n}\n\n#define VEC64_DST_APPEND(sb, n, i) vector64_dst_append(sb, handle, insn, n, i)\n\nstatic void vector64_dst_append(RStrBuf *sb, csh *handle, cs_insn *insn, int n, int i) {\n\tcs_arm64_op op = INSOP64 (n);\n\n\tif (op.vector_index != -1) {\n\t\ti = op.vector_index;\n\t}\n#if CS_API_MAJOR == 4\n\tconst bool isvessas = (op.vess || op.vas);\n#else\n\tconst bool isvessas = op.vas;\n#endif\n\tif (isvessas && i != -1) {\n\t\tint size = vector_size (&op);\n\t\tint shift = i * size;\n\t\tchar *regc = \"l\";\n\t\tsize_t s = sizeof (bitmask_by_width) / sizeof (*bitmask_by_width);\n\t\tsize_t index = size > 0? (size - 1) % s: 0;\n\t\tif (index >= BITMASK_BY_WIDTH_COUNT) {\n\t\t\tindex = 0;\n\t\t}\n\t\tut64 mask = bitmask_by_width[index];\n\t\tif (shift >= 64) {\n\t\t\tshift -= 64;\n\t\t\tregc = \"h\";\n\t\t}\n\n\t\tif (shift > 0 && shift < 64) {\n\t\t\tr_strbuf_appendf (sb, \"%d,SWAP,0x%\"PFMT64x\",&,<<,%s%s,0x%\"PFMT64x\",&,|,%s%s\",\n\t\t\t\tshift, mask, REG64 (n), regc, VEC64_MASK (shift, size), REG64 (n), regc);\n\t\t} else {\n\t\t\tint dimsize = size % 64;\n\t\t\tr_strbuf_appendf (sb, \"0x%\"PFMT64x\",&,%s%s,0x%\"PFMT64x\",&,|,%s%s\",\n\t\t\t\tmask, REG64 (n), regc, VEC64_MASK (shift, dimsize), REG64 (n), regc);\n\t\t}\n\t} else {\n\t\tr_strbuf_appendf (sb, \"%s\", REG64 (n));\n\t}\n}\n\n#define SHIFTED_IMM64(n, sz) shifted_imm64(handle, insn, n, sz)\n\nstatic ut64 shifted_imm64(csh *handle, cs_insn *insn, int n, int sz) {\n\tcs_arm64_op op = INSOP64 (n);\n\tint sft = op.shift.value;\n\tswitch (op.shift.type) {\n\t\tcase ARM64_SFT_MSL:\n\t\t\treturn (IMM64 (n) << sft) | ((1 << sft) - 1);\n\t\tcase ARM64_SFT_LSL:\n\t\t\treturn IMM64 (n) << sft;\n\t\tcase ARM64_SFT_LSR:\n\t\t\treturn IMM64 (n) >> sft;\n\t\tcase ARM64_SFT_ROR:\n\t\t\treturn (IMM64 (n) >> sft)|(IMM64 (n) << (sz - sft));\n\t\tcase ARM64_SFT_ASR:\n\t\t\tswitch (sz) {\n\t\t\tcase 8: return (st8)IMM64 (n) >> sft;\n\t\t\tcase 16: return (st16)IMM64 (n) >> sft;\n\t\t\tcase 32: return (st32)IMM64 (n) >> sft;\n\t\t\tdefault: return (st64)IMM64 (n) >> sft;\n\t\t\t}\n\t\tdefault:\n\t\t\treturn IMM64 (n);\n\t}\n}\n\n#define ARG64_APPEND(sb, n) arg64_append (sb, handle, insn, n, -1, 0)\n#define ARG64_SIGN_APPEND(sb, n, s) arg64_append (sb, handle, insn, n, -1, s)\n#define VECARG64_APPEND(sb, n, i, s) arg64_append (sb, handle, insn, n, i, s)\n#define COMMA(sb) r_strbuf_appendf (sb, \",\")\n\nstatic void arg64_append(RStrBuf *sb, csh *handle, cs_insn *insn, int n, int i, int sign) {\n\tcs_arm64_op op = INSOP64 (n);\n\n\tint size = 64;\n\tif (ISREG64 (n)) {\n\t\tsize = REGSIZE64 (n)*8;\n\t}\n\n\tif (ISIMM64 (n)) {\n\t\tif (!ISSHIFTED64 (n)) {\n\t\t\tut64 imm = SHIFTED_IMM64 (n, size);\n\t\t\tr_strbuf_appendf (sb, \"0x%\"PFMT64x, imm);\n\t\t\treturn;\n\t\t}\n\t}\n\tconst char *rn = (ISMEM64 (n) && HASMEMINDEX64 (n))\n\t\t? MEMINDEX64 (n): REG64 (n);\n\tint shift = LSHIFT2_64 (n);\n\tint signext = EXT64 (n);\n\tif (sign && !signext) {\n\t\tsignext = size;\n\t}\n\n\tif (signext) {\n\t\tr_strbuf_appendf (sb, \"%d,\", signext);\n\t}\n\tif (shift) {\n\t\tr_strbuf_appendf (sb, \"%d,\", shift);\n\t}\n\n#if CS_API_MAJOR == 4\n\tconst bool isvessas = (op.vess || op.vas);\n#else\n\tconst bool isvessas = op.vas;\n#endif\n\tif (isvessas) {\n\t\tVEC64_APPEND (sb, n, i);\n\t} else {\n\t\tr_strbuf_appendf (sb, \"%s\", rn);\n\t}\n\n\tif (shift) {\n\t\tr_strbuf_appendf (sb, \",%s\", DECODE_SHIFT64 (n));\n\t}\n\tif (signext) {\n\t\tr_strbuf_appendf (sb, \",~\");\n\t}\n}\n\n#define OPCALL(opchar) arm64math(a, op, addr, buf, len, handle, insn, opchar, 0, 0)\n#define OPCALL_NEG(opchar) arm64math(a, op, addr, buf, len, handle, insn, opchar, 1, 0)\n#define OPCALL_SIGN(opchar, sign) arm64math(a, op, addr, buf, len, handle, insn, opchar, 0, sign)\n\nstatic void arm64math(RAnal *a, RAnalOp *op, ut64 addr, const ut8 *buf, int len, csh *handle, cs_insn *insn, const char *opchar, int negate, int sign) {\n\tcs_arm64_op dst = INSOP64 (0);\n\tint i, c = (OPCOUNT64 () > 2) ? 1 : 0;\n\n\tif (dst.vas) {\n\t\tint end = vas_count (dst.vas);\n\t\tfor (i = 0; i < end; i++) {\n\t\t\tVECARG64_APPEND (&op->esil, 2, i, sign);\n\t\t\tif (negate) {\n\t\t\t\tr_strbuf_appendf (&op->esil, \",-1,^\");\n\t\t\t}\n\t\t\tCOMMA (&op->esil);\n\t\t\tVECARG64_APPEND (&op->esil, 1, i, sign);\n\t\t\tr_strbuf_appendf (&op->esil, \",%s,\", opchar);\n\t\t\tVEC64_DST_APPEND (&op->esil, 0, i);\n\t\t\tr_strbuf_appendf (&op->esil, \",=\");\n\t\t\tif (i < end - 1) {\n\t\t\t\tCOMMA (&op->esil);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tVECARG64_APPEND (&op->esil, c+1, -1, sign);\n\t\tif (negate) {\n\t\t\tr_strbuf_appendf (&op->esil, \",-1,^\");\n\t\t}\n\t\tCOMMA (&op->esil);\n\t\tVECARG64_APPEND (&op->esil, c, -1, sign);\n\t\tr_strbuf_appendf (&op->esil, \",%s,\", opchar);\n\t\tVEC64_DST_APPEND (&op->esil, 0, -1);\n\t\tr_strbuf_appendf (&op->esil, \",=\");\n\t}\n}\n\n#define FPOPCALL(opchar) arm64fpmath(a, op, addr, buf, len, handle, insn, opchar, 0)\n#define FPOPCALL_NEGATE(opchar) arm64fpmath(a, op, addr, buf, len, handle, insn, opchar, 1)\n\n// floating point math instruction helper\nstatic void arm64fpmath(RAnal *a, RAnalOp *op, ut64 addr, const ut8 *buf, int len, csh *handle, cs_insn *insn, const char *opchar, int negate) {\n\tint i, size = REGSIZE64 (1)*8;\n\n\tcs_arm64_op dst = INSOP64 (0);\n\tint start = -1;\n\tint end = 0;\n\tint convert = size == 64 ? 0 : 1;\n\tif (dst.vas) {\n\t\tstart = 0;\n\t\tend = vas_count(dst.vas);\n\t}\n\n\tfor (i = start; i < end; i++) {\n\t\tif (convert) {\n\t\t\tr_strbuf_appendf (&op->esil, \"%d,DUP,\", size);\n\t\t}\n\t\tVEC64_APPEND (&op->esil, 2, i);\n\t\tif (convert) {\n\t\t\tr_strbuf_appendf (&op->esil, \",F2D\");\n\t\t}\n\t\tif (negate) {\n\t\t\tr_strbuf_appendf (&op->esil, \",-F\");\n\t\t}\n\t\tif (convert) {\n\t\t\tr_strbuf_appendf (&op->esil, \",%d\", size);\n\t\t}\n\t\tCOMMA (&op->esil);\n\t\tVEC64_APPEND (&op->esil, 1, i);\n\t\tif (convert) {\n\t\t\tr_strbuf_appendf (&op->esil, \",F2D,F%s,D2F,\", opchar);\t\n\t\t} else {\n\t\t\tr_strbuf_appendf (&op->esil, \",F%s,\", opchar);\t\n\t\t}\n\t\tVEC64_DST_APPEND (&op->esil, 0, i);\n\t\tr_strbuf_appendf (&op->esil, \",=\");\n\t\tif (i < end - 1) {\n\t\t\tCOMMA (&op->esil);\n\t\t}\n\t}\n}\n\nstatic int analop64_esil(RAnal *a, RAnalOp *op, ut64 addr, const ut8 *buf, int len, csh *handle, cs_insn *insn) {\n\tconst char *postfix = NULL;\n\n\tr_strbuf_init (&op->esil);\n\tr_strbuf_set (&op->esil, \"\");\n\n\tpostfix = arm_prefix_cond (op, insn->detail->arm64.cc);\n\n\tswitch (insn->id) {\n\tcase ARM64_INS_REV:\n\tcase ARM64_INS_REV64:\n\t// these REV* instructions were almost right, except in the cases like rev x0, x0\n\t// where the use of |= caused copies of the value to be erroneously present\n\t{\n\t\tconst char *r0 = REG64 (0);\n\t\tconst char *r1 = REG64 (1);\n\t\tint size = REGSIZE64 (1);\n\t\tif (size == 8) {\n\t\t\tr_strbuf_setf (&op->esil,\n\t\t\t\t\"56,0xff,%s,&,<<,tmp,=,\"\n\t\t\t\t\"48,0xff,8,%s,>>,&,<<,tmp,|=,\"\n\t\t\t\t\"40,0xff,16,%s,>>,&,<<,tmp,|=,\"\n\t\t\t\t\"32,0xff,24,%s,>>,&,<<,tmp,|=,\"\n\t\t\t\t\"24,0xff,32,%s,>>,&,<<,tmp,|=,\"\n\t\t\t\t\"16,0xff,40,%s,>>,&,<<,tmp,|=,\"\n\t\t\t\t\"8,0xff,48,%s,>>,&,<<,tmp,|=,\"\n\t\t\t\t\"0xff,56,%s,>>,&,tmp,|=,tmp,%s,=\",\n\t\t\t\tr1, r1, r1, r1,\n\t\t\t\tr1, r1, r1, r1, r0);\n\t\t} else {\n\t\t\tr_strbuf_setf (&op->esil,\n\t\t\t\t\"24,0xff,%s,&,<<,tmp,=,\"\n\t\t\t\t\"16,0xff,8,%s,>>,&,<<,tmp,|=,\"\n\t\t\t\t\"8,0xff,16,%s,>>,&,<<,tmp,|=,\"\n\t\t\t\t\"0xff,24,%s,>>,&,tmp,|=,tmp,%s,=\",\n\t\t\t\tr1, r1, r1, r1, r0);\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARM64_INS_REV32:\n\t\tr_strbuf_setf (&op->esil,\n\t\t\t\"24,0x000000ff000000ff,%s,&,<<,tmp,=,\"\n\t\t\t\"16,0x000000ff000000ff,8,%s,>>,&,<<,tmp,|=,\"\n\t\t\t\"8,0x000000ff000000ff,16,%s,>>,&,<<,tmp,|=,\"\n\t\t\t\"0x000000ff000000ff,24,%s,>>,&,tmp,|=,tmp,%s,=\",\n\t\t\tREG64 (1), REG64 (1), REG64 (1), REG64 (1), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_REV16:\n\t\tr_strbuf_setf (&op->esil,\n\t\t\t\"8,0xff00ff00ff00ff00,%s,&,>>,tmp,=,\"\n\t\t\t\"8,0x00ff00ff00ff00ff,%s,&,<<,tmp,|=,tmp,%s,=\",\n\t\t\tREG64 (1), REG64 (1), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_ADR:\n\t\t// TODO: must be 21bit signed\n\t\tr_strbuf_setf (&op->esil,\n\t\t\t\"%\"PFMT64d\",%s,=\", IMM64 (1), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_SMADDL:\n\t\tr_strbuf_setf (&op->esil, \"%d,%s,~,%d,%s,~,*,%s,+,%s,=\",\n\t\t\tREGBITS64 (1), REG64 (2), REGBITS64 (1), REG64 (1), REG64 (3), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_UMADDL:\n\tcase ARM64_INS_MADD:\n\t\tr_strbuf_setf (&op->esil, \"%s,%s,*,%s,+,%s,=\",\n\t\t\tREG64 (2), REG64 (1), REG64 (3), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_MSUB:\n\t\tr_strbuf_setf (&op->esil, \"%s,%s,*,%s,-,%s,=\",\n\t\t\tREG64 (2), REG64 (1), REG64 (3), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_MNEG:\n\t\tr_strbuf_setf (&op->esil, \"%s,%s,*,0,-,%s,=\",\n\t\t\tREG64 (2), REG64 (1), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_ADD:\n\tcase ARM64_INS_ADC: // Add with carry.\n\t\tOPCALL (\"+\");\n\t\tbreak;\n\tcase ARM64_INS_SUB:\n\t\tOPCALL (\"-\");\n\t\tbreak;\n\tcase ARM64_INS_SBC:\n\t\t// TODO have to check this more, VEX does not work\n\t\tr_strbuf_setf (&op->esil, \"%s,cf,+,%s,-,%s,=\",\n\t\t\tREG64 (2), REG64 (1), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_SMULL2:\n\tcase ARM64_INS_SMULL:\n\t\tOPCALL_SIGN (\"*\", REGBITS64 (1));\n\t\tbreak;\n\tcase ARM64_INS_UMULL2:\n\tcase ARM64_INS_UMULL:\n\tcase ARM64_INS_MUL:\n\t\tOPCALL (\"*\");\n\t\tbreak;\n\tcase ARM64_INS_UMULH:\n\t\tr_strbuf_setf (&op->esil, \"%s,%s,L*,SWAP,%s,=\",\n\t\t\tREG64 (2), REG64 (1), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_SMULH:\n\t\t// TODO this needs to be a 128 bit sign ext to be right\n\t\tr_strbuf_setf (&op->esil, \"%d,%s,~,%d,%s,~,L*,SWAP,%s,=\",\n\t\t\tREGBITS64 (1), REG64 (2), REGBITS64 (1), REG64 (1), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_AND:\n\t\tOPCALL (\"&\");\n\t\tbreak;\n\tcase ARM64_INS_ORR:\n\t\tOPCALL (\"|\");\n\t\tbreak;\n#if CS_API_MAJOR > 4\t\n\tcase ARM64_INS_NAND:\n\t\tOPCALL_NEG (\"&\");\n\t\tbreak;\n\tcase ARM64_INS_ADDS:\n\tcase ARM64_INS_ADCS:\n\t\tOPCALL (\"+\");\n\t\tSET_FLAGS();\n\t\tbreak;\n\tcase ARM64_INS_SUBS:\n\t\tOPCALL (\"-\");\n\t\tSET_FLAGS();\n\t\tbreak;\n\tcase ARM64_INS_ANDS:\n\t\tOPCALL (\"&\");\n\t\tSET_FLAGS();\n\t\tbreak;\n\tcase ARM64_INS_NANDS:\n\t\tOPCALL_NEG (\"&\");\n\t\tSET_FLAGS();\n\t\tbreak;\n\tcase ARM64_INS_ORRS:\n\t\tOPCALL (\"|\");\n\t\tSET_FLAGS();\n\t\tbreak;\n\tcase ARM64_INS_EORS:\n\t\tOPCALL (\"^\");\n\t\tSET_FLAGS();\n\t\tbreak;\n\tcase ARM64_INS_ORNS:\n\t\tOPCALL_NEG (\"|\");\n\t\tSET_FLAGS();\n\t\tbreak;\n#endif\n\tcase ARM64_INS_EOR:\n\t\tOPCALL (\"^\");\n\t\tbreak;\n\tcase ARM64_INS_ORN:\n\t\tOPCALL_NEG (\"|\");\n\t\tbreak;\n\tcase ARM64_INS_EON:\n\t\tOPCALL_NEG (\"^\");\n\t\tbreak;\n\tcase ARM64_INS_LSR:\n\t{\n\t\tconst char *r0 = REG64 (0);\n\t\tconst char *r1 = REG64 (1);\n\t\tconst int size = REGSIZE64 (0)*8;\n\n\t\tif (ISREG64(2)) {\n\t\t\tif (LSHIFT2_64 (2) || EXT64 (2)) {\n\t\t\t\tARG64_APPEND (&op->esil, 2);\n\t\t\t\tr_strbuf_appendf (&op->esil, \",%d,%%,%s,>>,%s,=\", size, r1, r0);\n\t\t\t} else {\n\t\t\t\tconst char *r2 = REG64 (2);\n\t\t\t\tr_strbuf_setf (&op->esil, \"%d,%s,%%,%s,>>,%s,=\", size, r2, r1, r0);\n\t\t\t}\n\t\t} else {\n\t\t\tut64 i2 = IMM64 (2);\n\t\t\tr_strbuf_setf (&op->esil, \"%\"PFMT64d\",%s,>>,%s,=\", i2 % (ut64)size, r1, r0);\n\t\t}\n\t\t//OPCALL (\">>\");\n\t\tbreak;\n\t}\n\tcase ARM64_INS_LSL:\n\t{\n\t\tconst char *r0 = REG64 (0);\n\t\tconst char *r1 = REG64 (1);\n\t\tconst int size = REGSIZE64 (0)*8;\n\n\t\tif (ISREG64 (2)) {\n\t\t\tif (LSHIFT2_64 (2) || EXT64 (2)) {\n\t\t\t\tARG64_APPEND (&op->esil, 2);\n\t\t\t\tr_strbuf_appendf (&op->esil, \",%d,%%,%s,<<,%s,=\", size, r1, r0);\n\t\t\t} else {\n\t\t\t\tconst char *r2 = REG64 (2);\n\t\t\t\tr_strbuf_setf (&op->esil, \"%d,%s,%%,%s,<<,%s,=\", size, r2, r1, r0);\n\t\t\t}\n\t\t} else {\n\t\t\tut64 i2 = IMM64 (2);\n\t\t\tr_strbuf_setf (&op->esil, \"%\"PFMT64d\",%s,<<,%s,=\", i2 % (ut64)size, r1, r0);\n\t\t}\n\t\t//OPCALL (\"<<\");\n\t\tbreak;\n\t}\n\tcase ARM64_INS_ROR:\n\t\tOPCALL (\">>>\");\n\t\tbreak;\n\tcase ARM64_INS_NOP:\n\t\tr_strbuf_setf (&op->esil, \",\");\n\t\tbreak;\n\tcase ARM64_INS_MOV:\n\tcase ARM64_INS_FMOV:\n\t{\n\t\tcs_arm64_op dst = INSOP64 (0);\n\t\tcs_arm64_op src = INSOP64 (1);\n\n\t\tif (dst.vas && src.vas) {\n\t\t\tr_strbuf_setf (&op->esil, \"%sh,%sh,=,%sl,%sl,=\",\n\t\t\t\tREG64 (1), REG64 (0), REG64 (1), REG64 (0));\n\t\t} else {\n\t\t\tARG64_APPEND (&op->esil, 1);\n\t\t\tr_strbuf_appendf (&op->esil, \",\");\n\t\t\tVEC64_DST_APPEND (&op->esil, 0, -1);\n\t\t\tr_strbuf_appendf (&op->esil, \",=\");\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARM64_INS_FCMP:\n\tcase ARM64_INS_FCMPE:\n\tcase ARM64_INS_FCCMP:\n\tcase ARM64_INS_FCCMPE:\n\t\tif (ISREG64 (1)) {\n\t\t\tr_strbuf_setf (&op->esil,\n\t\t\t\t\"%d,%s,F2D,NAN,%d,%s,F2D,NAN,|,vf,:=\"\n\t\t\t\t\",%d,%s,F2D,%d,%s,F2D,F==,vf,|,zf,:=\"\n\t\t\t\t\",%d,%s,F2D,%d,%s,F2D,F<,vf,|,nf,:=\",\n\t\t\t\tREGBITS64 (1), REG64 (1), REGBITS64 (1), REG64 (0),\n\t\t\t\tREGBITS64 (1), REG64 (1), REGBITS64 (1), REG64 (0),\n\t\t\t\tREGBITS64 (1), REG64 (1), REGBITS64 (1), REG64 (0)\n\t\t\t);\t\n\t\t} else {\n\t\t\tr_strbuf_setf (&op->esil,\n\t\t\t\t\"%d,%s,F2D,NAN,vf,:=\"\n\t\t\t\t\",0,I2D,%d,%s,F2D,F==,vf,|,zf,:=\"\n\t\t\t\t\",0,I2D,%d,%s,F2D,F<,vf,|,nf,:=\",\n\t\t\t\tREGBITS64 (1), REG64 (0),\n\t\t\t\tREGBITS64 (1), REG64 (0),\n\t\t\t\tREGBITS64 (1), REG64 (0)\n\t\t\t);\n\t\t}\n\n\t\tif (insn->id == ARM64_INS_FCCMP || insn->id == ARM64_INS_FCCMPE) {\n\t\t\tr_strbuf_appendf (&op->esil, \",\");\n\t\t\tarm_prefix_cond (op, insn->detail->arm64.cc);\n\t\t\tr_strbuf_appendf (&op->esil, \"}{,pstate,1,28,1,<<,-,&,0x%\"PFMT64x\",|,pstate,:=\",\n\t\t\t\tIMM64(2) << 28);\n\t\t}\n\t\tbreak;\n\tcase ARM64_INS_FCVT:\n\t\tr_strbuf_setf (&op->esil, \"%d,%d,%s,F2D,D2F,%s,=\",\n\t\t\tREGBITS64 (0), REGBITS64 (1), REG64 (1), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_SCVTF:\n\t\tr_strbuf_setf (&op->esil, \"%d,\", REGBITS64 (0));\n\t\tARG64_SIGN_APPEND (&op->esil, 1, REGBITS64 (1));\n\t\tr_strbuf_appendf (&op->esil, \",S2D,D2F,\");\n\t\tVEC64_DST_APPEND (&op->esil, 0, -1);\n\t\tr_strbuf_appendf (&op->esil, \",=\");\n\t\tbreak;\n\tcase ARM64_INS_UCVTF:\n\t\tr_strbuf_setf (&op->esil, \"%d,\", REGBITS64 (0));\n\t\tARG64_APPEND (&op->esil, 1);\n\t\tr_strbuf_appendf (&op->esil, \",U2D,D2F,\");\n\t\tVEC64_DST_APPEND (&op->esil, 0, -1);\n\t\tr_strbuf_appendf (&op->esil, \",=\");\n\t\tbreak;\n\tcase ARM64_INS_FCVTAU:\n\tcase ARM64_INS_FCVTAS:\n\tcase ARM64_INS_FCVTMU:\n\tcase ARM64_INS_FCVTMS:\n\tcase ARM64_INS_FCVTNU:\n\tcase ARM64_INS_FCVTNS:\n\tcase ARM64_INS_FCVTPU:\n\tcase ARM64_INS_FCVTPS:\n\tcase ARM64_INS_FCVTZU:\n\tcase ARM64_INS_FCVTZS:\n\t\t// TODO: unsigned int won't be right, idk entirely what it even means\n\t\t// also the rounding mode... idk i hate floats\n\t\tr_strbuf_setf (&op->esil, \"%d,\", REGBITS64 (1));\n\t\tARG64_APPEND (&op->esil, 1);\n\t\tr_strbuf_appendf (&op->esil, \",F2D,D2I,\");\n\t\tVEC64_DST_APPEND (&op->esil, 0, -1);\n\t\tr_strbuf_appendf (&op->esil, \",=\");\n\t\tbreak;\n\tcase ARM64_INS_FRINTA:\n\tcase ARM64_INS_FRINTI:\n\tcase ARM64_INS_FRINTN:\n\tcase ARM64_INS_FRINTX:\n\tcase ARM64_INS_FRINTZ:\n\tcase ARM64_INS_FRINTP:\n\tcase ARM64_INS_FRINTM:\n\t{\n\t\tchar* rounder = \"ROUND\";\n\t\tif (insn->id == ARM64_INS_FRINTM) {\n\t\t\trounder = \"FLOOR\";\n\t\t} else if (insn->id == ARM64_INS_FRINTP) {\n\t\t\trounder = \"CEIL\";\n\t\t}\n\t\tr_strbuf_setf (&op->esil, \"%d,DUP,\", REGBITS64 (1));\n\t\tARG64_APPEND (&op->esil, 1);\n\t\tr_strbuf_appendf (&op->esil, \",F2D,%s,D2F,\", rounder);\n\t\tVEC64_DST_APPEND (&op->esil, 0, -1);\n\t\tr_strbuf_appendf (&op->esil, \",=\");\n\t\tbreak;\n\t}\n\tcase ARM64_INS_FABS:\n\t\tr_strbuf_setf (&op->esil, \"%d,DUP,%s,F2D,DUP,0,I2D,F<,?{,-F,},D2F,%s,=\",\n\t\t\tREGBITS64 (1), REG64 (1), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_FNEG:\n\t\tr_strbuf_setf (&op->esil, \"%d,DUP,%s,F2D,-F,D2F,%s,=\",\n\t\t\tREGBITS64 (1), REG64 (1), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_FMIN:\n\t\tr_strbuf_setf (&op->esil, \"%d,%s,F2D,%d,%s,F2D,F<,?{,%s,}{,%s,},%s,=\",\n\t\t\tREGBITS64 (2), REG64 (2),\n\t\t\tREGBITS64 (1), REG64 (1), REG64 (1), REG64 (2), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_FMAX:\n\t\tr_strbuf_setf (&op->esil, \"%d,%s,F2D,%d,%s,F2D,F<,!,?{,%s,}{,%s,},%s,=\",\n\t\t\tREGBITS64 (2), REG64 (2),\n\t\t\tREGBITS64 (1), REG64 (1), REG64 (1), REG64 (2), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_FADD:\n\t\tFPOPCALL (\"+\");\n\t\tbreak;\n\tcase ARM64_INS_FSUB:\n\t\tFPOPCALL (\"-\");\n\t\tbreak;\n\tcase ARM64_INS_FMUL:\n\t\tFPOPCALL (\"*\");\n\t\tbreak;\n\tcase ARM64_INS_FNMUL:\n\t\tFPOPCALL_NEGATE(\"*\");\n\t\tbreak;\n\tcase ARM64_INS_FMADD:\n\t\tr_strbuf_setf (&op->esil, \"%d,DUP,%s,F2D,%d,%s,F2D,F*,%d,%s,F2D,F+,D2F,%s,=\",\n\t\t\tREGBITS64 (1), REG64 (1),\n\t\t\tREGBITS64 (2), REG64 (2),\n\t\t\tREGBITS64 (3), REG64 (3), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_FNMADD:\n\t\tr_strbuf_setf (&op->esil, \"%d,DUP,%s,F2D,%d,%s,F2D,F*,-F,%d,%s,F2D,F+,-F,D2F,%s,=\",\n\t\t\tREGBITS64 (1), REG64 (1),\n\t\t\tREGBITS64 (2), REG64 (2),\n\t\t\tREGBITS64 (3), REG64 (3), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_FMSUB:\n\t\tr_strbuf_setf (&op->esil, \"%d,DUP,%s,F2D,%d,%s,F2D,F*,%d,%s,F2D,F-,D2F,%s,=\",\n\t\t\tREGBITS64 (1), REG64 (1),\n\t\t\tREGBITS64 (2), REG64 (2),\n\t\t\tREGBITS64 (3), REG64 (3), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_FNMSUB:\n\t\tr_strbuf_setf (&op->esil, \"%d,DUP,%s,F2D,%d,%s,F2D,F*,-F,%d,%s,F2D,F-,-F,D2F,%s,=\",\n\t\t\tREGBITS64 (1), REG64 (1),\n\t\t\tREGBITS64 (2), REG64 (2),\n\t\t\tREGBITS64 (3), REG64 (3), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_FDIV:\n\t\tFPOPCALL (\"/\");\n\t\tbreak;\n\tcase ARM64_INS_SDIV:\n\t\tOPCALL_SIGN (\"/\", REGBITS64 (1));\n\t\tbreak;\n\tcase ARM64_INS_UDIV:\n\t\t/* TODO: support WZR XZR to specify 32, 64bit op */\n\t\tOPCALL (\"/\");\n\t\tbreak;\n#if CS_API_MAJOR > 4\n\tcase ARM64_INS_BRAA:\n\tcase ARM64_INS_BRAAZ:\n\tcase ARM64_INS_BRAB:\n\tcase ARM64_INS_BRABZ:\n#endif\n\tcase ARM64_INS_BR:\n\t\tr_strbuf_setf (&op->esil, \"%s,pc,=\", REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_B:\n\t\t/* capstone precompute resulting address, using PC + IMM */\n\t\tr_strbuf_appendf (&op->esil, \"%\"PFMT64d\",pc,=\", IMM64 (0));\n\t\tbreak;\n\tcase ARM64_INS_BL:\n\t\tr_strbuf_setf (&op->esil, \"pc,lr,=,%\"PFMT64d\",pc,=\", IMM64 (0));\n\t\tbreak;\n#if CS_API_MAJOR > 4\n\tcase ARM64_INS_BLRAA:\n\tcase ARM64_INS_BLRAAZ:\n\tcase ARM64_INS_BLRAB:\n\tcase ARM64_INS_BLRABZ:\n#endif\n\tcase ARM64_INS_BLR:\n\t\tr_strbuf_setf (&op->esil, \"pc,lr,=,%s,pc,=\", REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_CLZ:\n\t{\n\t\t/*\n\t\tfrom https://en.wikipedia.org/wiki/Find_first_set modified for up to size 64\n\t\tfunction clz3 (x)\n\t\t\tif x = 0 return 32\n\t\t\tn \u2190 0\n\t\t\tif (x & 0xFFFF0000) = 0: n \u2190 n + 16, x \u2190 x << 16\n\t\t\tif (x & 0xFF000000) = 0: n \u2190 n +  8, x \u2190 x <<  8\n\t\t\tif (x & 0xF0000000) = 0: n \u2190 n +  4, x \u2190 x <<  4\n\t\t\tif (x & 0xC0000000) = 0: n \u2190 n +  2, x \u2190 x <<  2\n\t\t\tif (x & 0x80000000) = 0: n \u2190 n +  1\n\t\t\treturn n\n\t\t*/\n\n\t\tint size = 8 * REGSIZE64 (0);\n\t\tconst char *r0 = REG64 (0);\n\t\tconst char *r1 = REG64 (1);\n\n\t\tif (size == 32) {\n\t\t\tr_strbuf_setf (&op->esil,\n\t\t\t\"%s,tmp,=,0,\"\n\t\t\t\"tmp,0xffff0000,&,!,?{,16,tmp,<<=,16,+,},\"\n\t\t\t\"tmp,0xff000000,&,!,?{,8,tmp,<<=,8,+,},\"\n\t\t\t\"tmp,0xf0000000,&,!,?{,4,tmp,<<=,4,+,},\"\n\t\t\t\"tmp,0xc0000000,&,!,?{,2,tmp,<<=,2,+,},\"\n\t\t\t\"tmp,0x80000000,&,!,?{,1,+,},\"\n\t\t\t\"%s,!,?{,32,%s,=,}{,%s,=,}\",\n\t\t\tr1, r1, r0, r0);\n\t\t} else {\n\t\t\tr_strbuf_setf (&op->esil,\n\t\t\t\"%s,tmp,=,0,\"\n\t\t\t\"tmp,0xffffffff00000000,&,!,?{,32,tmp,<<=,32,+,},\"\n\t\t\t\"tmp,0xffff000000000000,&,!,?{,16,tmp,<<=,16,+,},\"\n\t\t\t\"tmp,0xff00000000000000,&,!,?{,8,tmp,<<=,8,+,},\"\n\t\t\t\"tmp,0xf000000000000000,&,!,?{,4,tmp,<<=,4,+,},\"\n\t\t\t\"tmp,0xc000000000000000,&,!,?{,2,tmp,<<=,2,+,},\"\n\t\t\t\"tmp,0x8000000000000000,&,!,?{,1,+,},\"\n\t\t\t\"%s,!,?{,64,%s,=,}{,%s,=,}\",\n\t\t\tr1, r1, r0, r0);\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARM64_INS_LDRH:\n\tcase ARM64_INS_LDUR:\n\tcase ARM64_INS_LDURB:\n\tcase ARM64_INS_LDURH:\n\tcase ARM64_INS_LDR:\n\tcase ARM64_INS_LDRB:\n\tcase ARM64_INS_LDXR:\n\tcase ARM64_INS_LDXRB:\n\tcase ARM64_INS_LDXRH:\n\tcase ARM64_INS_LDAXR:\n\tcase ARM64_INS_LDAXRB:\n\tcase ARM64_INS_LDAXRH:\n\tcase ARM64_INS_LDAR:\n\tcase ARM64_INS_LDARB:\n\tcase ARM64_INS_LDARH:\n\t{\n\t\tint size = REGSIZE64 (0);\n\t\tswitch (insn->id) {\n\t\tcase ARM64_INS_LDRB:\n\t\tcase ARM64_INS_LDARB:\n\t\tcase ARM64_INS_LDAXRB:\n\t\tcase ARM64_INS_LDXRB:\n\t\tcase ARM64_INS_LDURB:\n\t\t\tsize = 1;\n\t\t\tbreak;\n\t\tcase ARM64_INS_LDRH:\n\t\tcase ARM64_INS_LDARH:\n\t\tcase ARM64_INS_LDXRH:\n\t\tcase ARM64_INS_LDAXRH:\n\t\tcase ARM64_INS_LDURH:\n\t\t\tsize = 2;\n\t\t\tbreak;\n\t\tcase ARM64_INS_LDRSW:\n\t\tcase ARM64_INS_LDURSW:\n\t\t\tsize = 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (ISMEM64 (1)) {\n\t\t\tif (HASMEMINDEX64 (1)) {\n\t\t\t\tif (LSHIFT2_64 (1) || EXT64 (1)) {\n\t\t\t\t\tARG64_APPEND (&op->esil, 1);\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \",%s,+,[%d],%s,=\",\n\t\t\t\t\t\t\tMEMBASE64 (1), size, REG64 (0));\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,+,[%d],%s,=\",\n\t\t\t\t\t\t\tMEMBASE64 (1), MEMINDEX64 (1), size, REG64 (0));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (LSHIFT2_64 (1)) {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%d,%\"PFMT64d\",%s,+\",\n\t\t\t\t\t\t\tMEMBASE64 (1), LSHIFT2_64 (1), MEMDISP64 (1), DECODE_SHIFT64 (1));\n\t\t\t\t} else if ((int)MEMDISP64 (1) < 0) {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%\"PFMT64d\",%s,-\",\n\t\t\t\t\t\t\t-(st64)MEMDISP64 (1), MEMBASE64 (1));\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%\"PFMT64d\",%s,+\",\n\t\t\t\t\t\t\tMEMDISP64 (1), MEMBASE64 (1));\n\t\t\t\t}\n\t\t\t\tr_strbuf_append (&op->esil, \",DUP,tmp,=\");\n\n\t\t\t\t// I assume the DUPs here previously were to handle preindexing\n\t\t\t\t// but it was never finished?\n\t\t\t\tif (ISPREINDEX64 ()) {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \",tmp,%s,=\", REG64 (1));\n\t\t\t\t}\n\n\t\t\t\tr_strbuf_appendf (&op->esil, \",[%d],%s,=\", size, REG64 (0));\n\n\t\t\t\tif (ISPOSTINDEX64 ()) {\n\t\t\t\t\tif (ISREG64 (2)) { // not sure if register valued post indexing exists?\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",tmp,%s,+,%s,=\", REG64 (2), REG64 (1));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",tmp,%\"PFMT64d\",+,%s,=\", IMM64 (2), REG64 (1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\top->refptr = 4;\n\t\t} else {\n\t\t\tif (ISREG64 (1)) {\n\t\t\t\tif (OPCOUNT64 () == 2) {\n\t\t\t\t\tr_strbuf_setf (&op->esil, \"%s,[%d],%s,=\",\n\t\t\t\t\t\tREG64 (1), size, REG64 (0));\n\t\t\t\t} else if (OPCOUNT64 () == 3) {\n\t\t\t\t\t/*\n\t\t\t\t\t\tThis seems like a capstone bug:\n\t\t\t\t\t\tinstructions like\n\t\t\t\t\t\t\tldr x16, [x13, x9]\n\t\t\t\t\t\t\tldrb w2, [x19, x23]\n\t\t\t\t\t\tare not detected as ARM64_OP_MEM type and\n\t\t\t\t\t\tfall in this case instead.\n\t\t\t\t\t*/\n\t\t\t\t\tif (ISREG64 (2)) {\n\t\t\t\t\t\tr_strbuf_setf (&op->esil, \"%s,%s,+,[%d],%s,=\",\n\t\t\t\t\t\t\tREG64 (1), REG64 (2), size, REG64 (0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr_strbuf_setf (&op->esil, \"%\"PFMT64d\",[%d],%s,=\",\n\t\t\t\t\tIMM64 (1), size, REG64 (0));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARM64_INS_LDRSB:\n\tcase ARM64_INS_LDRSH:\n\tcase ARM64_INS_LDRSW:\n\tcase ARM64_INS_LDURSB:\n\tcase ARM64_INS_LDURSH:\n\tcase ARM64_INS_LDURSW:\n\t{\n\t\t// handle the sign extended instrs here\n\t\tint size = 0;\n\t\tswitch (insn->id) {\n\t\tcase ARM64_INS_LDRSB:\n\t\tcase ARM64_INS_LDURSB:\n\t\t\tsize = 1;\n\t\t\tbreak;\n\t\tcase ARM64_INS_LDRSH:\n\t\tcase ARM64_INS_LDURSH:\n\t\t\tsize = 2;\n\t\t\tbreak;\n\t\tcase ARM64_INS_LDRSW:\n\t\tcase ARM64_INS_LDURSW:\n\t\t\tsize = 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsize = REGSIZE64 (0);\n\t\t\tbreak;\n\t\t}\n\t\tif (ISMEM64 (1)) {\n\t\t\tif (HASMEMINDEX64 (1)) {\n\t\t\t\tif (LSHIFT2_64 (1) || EXT64 (1)) {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%d,%s,\", size*8, MEMBASE64 (1));\n\t\t\t\t\tARG64_APPEND (&op->esil, 1);\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \",+,[%d],~,%s,=\", size, REG64 (0));\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%d,%s,%s,+,[%d],~,%s,=\",\n\t\t\t\t\t\t\tsize*8, MEMBASE64 (1), MEMINDEX64 (1), size, REG64 (0));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (LSHIFT2_64 (1)) {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%d,%s,%d,%\"PFMT64d\",%s\",\n\t\t\t\t\t\t\tsize*8, MEMBASE64 (1), LSHIFT2_64 (1), MEMDISP64 (1), DECODE_SHIFT64 (1));\n\t\t\t\t} else if ((int)MEMDISP64 (1) < 0) {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%d,%\"PFMT64d\",%s,-\",\n\t\t\t\t\t\t\tsize*8, -(st64)MEMDISP64 (1), MEMBASE64 (1));\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%d,%\"PFMT64d\",%s,+\",\n\t\t\t\t\t\t\tsize*8, MEMDISP64 (1), MEMBASE64 (1));\n\t\t\t\t}\n\n\t\t\t\tr_strbuf_append (&op->esil, \",DUP,tmp,=\");\n\n\t\t\t\t// I assume the DUPs here previously were to handle preindexing\n\t\t\t\t// but it was never finished?\n\t\t\t\tif (ISPREINDEX64 ()) {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \",tmp,%s,=\", REG64 (1));\n\t\t\t\t}\n\n\t\t\t\tr_strbuf_appendf (&op->esil, \",[%d],~,%s,=\", size, REG64 (0));\n\t\t\t\t\n\t\t\t\tif (ISPOSTINDEX64 ()) {\n\t\t\t\t\tif (ISREG64 (2)) { // not sure if register valued post indexing exists?\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",tmp,%s,+,%s,=\", REG64 (2), REG64 (1));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",tmp,%\"PFMT64d\",+,%s,=\", IMM64 (2), REG64 (1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\top->refptr = 4;\n\t\t} else {\n\t\t\tif (ISREG64 (1)) {\n\t\t\t\tif (OPCOUNT64 () == 2) {\n\t\t\t\t\tr_strbuf_setf (&op->esil, \"%d,%s,[%d],~,%s,=\",\n\t\t\t\t\t\tsize * 8, REG64 (1), size, REG64 (0));\n\t\t\t\t} else if (OPCOUNT64 () == 3) {\n\t\t\t\t\t/*\n\t\t\t\t\t\tThis seems like a capstone bug:\n\t\t\t\t\t\tinstructions like\n\t\t\t\t\t\t\tldr x16, [x13, x9]\n\t\t\t\t\t\t\tldrb w2, [x19, x23]\n\t\t\t\t\t\tare not detected as ARM64_OP_MEM type and\n\t\t\t\t\t\tfall in this case instead.\n\t\t\t\t\t*/\n\t\t\t\t\tif (ISREG64 (2)) {\n\t\t\t\t\t\tr_strbuf_setf (&op->esil, \"%d,%s,%s,+,[%d],~,%s,=\",\n\t\t\t\t\t\t\tsize * 8, REG64 (1), REG64 (2), size, REG64 (0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr_strbuf_setf (&op->esil, \"%d,%\"PFMT64d\",[%d],~,%s,=\",\n\t\t\t\t\tsize * 8, IMM64 (1), size, REG64 (0));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARM64_INS_CCMP:\n\tcase ARM64_INS_TST: // cmp w8, 0xd\n\tcase ARM64_INS_CMP: // cmp w8, 0xd\n\t\tARG64_APPEND (&op->esil, 1);\n\t\tCOMMA (&op->esil);\n\t\tARG64_APPEND (&op->esil, 0);\n\t\tr_strbuf_appendf (&op->esil, \",==,$z,zf,:=,%d,$s,nf,:=,%d,$b,!,cf,:=,%d,$o,vf,:=\",\n\t\t\tREGBITS64 (0) - 1, REGBITS64 (0), REGBITS64 (0) - 1);\n\t\n\t\tif (insn->id == ARM64_INS_CCMP || insn->id == ARM64_INS_CCMN) {\n\t\t\tr_strbuf_appendf (&op->esil, \",\");\n\t\t\tarm_prefix_cond (op, insn->detail->arm64.cc);\n\t\t\tr_strbuf_appendf (&op->esil, \"}{,pstate,1,28,1,<<,-,&,28,%\"PFMT64d\",<<,|,pstate,:=\", IMM64 (2));\n\t\t}\n\t\tbreak;\n\tcase ARM64_INS_CMN: \n\tcase ARM64_INS_CCMN:\n\t\tARG64_APPEND (&op->esil, 1);\n\t\tCOMMA (&op->esil);\n\t\tARG64_APPEND (&op->esil, 0);\n\t\tr_strbuf_appendf (&op->esil, \",-1,*,==,$z,zf,:=,%d,$s,nf,:=,%d,$b,!,cf,:=,%d,$o,vf,:=\",\n\t\t\tREGBITS64 (0) - 1, REGBITS64 (0), REGBITS64 (0) - 1);\n\t\n\t\tif (insn->id == ARM64_INS_CCMN) {\n\t\t\tr_strbuf_appendf (&op->esil, \",\");\n\t\t\tarm_prefix_cond (op, insn->detail->arm64.cc);\n\t\t\tr_strbuf_appendf (&op->esil, \"}{,pstate,1,28,1,<<,-,&,28,%\"PFMT64d\",<<,|,pstate,:=\", IMM64 (2));\n\t\t}\n\t\tbreak;\n\tcase ARM64_INS_FCSEL:\n\tcase ARM64_INS_CSEL: // csel Wd, Wn, Wm --> Wd := (cond) ? Wn : Wm\n\t\tr_strbuf_appendf (&op->esil, \"%s,}{,%s,},%s,=\", REG64 (1), REG64 (2), REG64 (0));\n\t\tpostfix = \"\";\n\t\tbreak;\n\tcase ARM64_INS_CSET: // cset Wd --> Wd := (cond) ? 1 : 0\n\t\tr_strbuf_appendf (&op->esil, \"1,}{,0,},%s,=\", REG64 (0));\n\t\tpostfix = \"\";\n\t\tbreak;\n\tcase ARM64_INS_CINC: // cinc Wd, Wn --> Wd := (cond) ? (Wn+1) : Wn\n\t\tr_strbuf_appendf (&op->esil, \"1,%s,+,}{,%s,},%s,=\", REG64 (1), REG64 (1), REG64 (0));\n\t\tpostfix = \"\";\n\t\tbreak;\n\tcase ARM64_INS_CSINC: // csinc Wd, Wn, Wm --> Wd := (cond) ? Wn : (Wm+1)\n\t\tr_strbuf_appendf (&op->esil, \"%s,}{,1,%s,+,},%s,=\", REG64 (1), REG64 (2), REG64 (0));\n\t\tpostfix = \"\";\n\t\tbreak;\n\tcase ARM64_INS_STXRB:\n\tcase ARM64_INS_STXRH:\n\tcase ARM64_INS_STXR:\n\t{\n\t\tint size = (insn->id == ARM64_INS_STXRB)\n\t\t    ? 1: (insn->id == ARM64_INS_STXRH)\n\t\t    ? 2: REGSIZE64 (1);\n\t\tr_strbuf_setf (&op->esil, \"0,%s,=,%s,%s,%\"PFMT64d\",+,=[%d]\",\n\t\t\tREG64 (0), REG64 (1), MEMBASE64 (1), MEMDISP64 (1), size);\n\t\tbreak;\n\t}\n\tcase ARM64_INS_STRB:\n\tcase ARM64_INS_STRH:\n\tcase ARM64_INS_STUR:\n\tcase ARM64_INS_STURB:\n\tcase ARM64_INS_STURH:\n\tcase ARM64_INS_STR: // str x6, [x6,0xf90]\n\t{\n\t\tint size = REGSIZE64 (0);\n\t\tif (insn->id == ARM64_INS_STRB || insn->id == ARM64_INS_STURB) {\n\t\t    size = 1;\n\t\t} else if (insn->id == ARM64_INS_STRH || insn->id == ARM64_INS_STURH) {\n\t\t    size = 2;\n\t\t}\n\t\tif (ISMEM64 (1)) {\n\t\t\tif (HASMEMINDEX64 (1)) {\n\t\t\t\tif (LSHIFT2_64 (1) || EXT64 (1)) {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,\", REG64 (0), MEMBASE64 (1));\n\t\t\t\t\tARG64_APPEND (&op->esil, 1);\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \",+,=[%d]\", size);\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,%s,+,=[%d]\",\n\t\t\t\t\t\t\tREG64 (0), MEMBASE64 (1), MEMINDEX64 (1), size);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (LSHIFT2_64 (1)) {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,%d,%\"PFMT64d\",%s,+\",\n\t\t\t\t\t\t\tREG64 (0), MEMBASE64 (1), LSHIFT2_64 (1), MEMDISP64 (1), DECODE_SHIFT64 (1));\n\t\t\t\t} else if ((int)MEMDISP64 (1) < 0) {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%\"PFMT64d\",%s,-\",\n\t\t\t\t\t\t\tREG64 (0), -(st64)MEMDISP64 (1), MEMBASE64 (1));\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%\"PFMT64d\",%s,+\",\n\t\t\t\t\t\t\tREG64 (0), MEMDISP64 (1), MEMBASE64 (1));\n\t\t\t\t}\n\n\t\t\t\tr_strbuf_append (&op->esil, \",DUP,tmp,=\");\n\n\t\t\t\t// I assume the DUPs here previously were to handle preindexing\n\t\t\t\t// but it was never finished?\n\t\t\t\tif (ISPREINDEX64 ()) {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \",tmp,%s,=\", REG64 (1));\n\t\t\t\t}\n\n\t\t\t\tr_strbuf_appendf (&op->esil, \",=[%d]\", size);\n\n\t\t\t\tif (ISPOSTINDEX64 ()) {\n\t\t\t\t\tif (ISREG64 (2)) { // not sure if register valued post indexing exists?\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",tmp,%s,+,%s,=\", REG64 (2), REG64 (1));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",tmp,%\"PFMT64d\",+,%s,=\", IMM64 (2), REG64 (1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\top->refptr = 4;\n\t\t} else {\n\t\t\tif (ISREG64 (1)) {\n\t\t\t\tif (OPCOUNT64 () == 2) {\n\t\t\t\t\tr_strbuf_setf (&op->esil, \"%s,%s,=[%d]\",\n\t\t\t\t\t\tREG64 (0), REG64 (1), size);\n\t\t\t\t} else if (OPCOUNT64 () == 3) {\n\t\t\t\t\t/*\n\t\t\t\t\t\tThis seems like a capstone bug:\n\t\t\t\t\t\tinstructions like\n\t\t\t\t\t\t\tldr x16, [x13, x9]\n\t\t\t\t\t\t\tldrb w2, [x19, x23]\n\t\t\t\t\t\tare not detected as ARM64_OP_MEM type and\n\t\t\t\t\t\tfall in this case instead.\n\t\t\t\t\t*/\n\t\t\t\t\tif (ISREG64 (2)) {\n\t\t\t\t\t\tr_strbuf_setf (&op->esil, \"%s,%s,%s,+,=[%d]\",\n\t\t\t\t\t\t\tREG64 (0), REG64 (1), REG64 (2), size);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr_strbuf_setf (&op->esil, \"%s,%\"PFMT64d\",=[%d]\",\n\t\t\t\t\tREG64 (0), IMM64 (1), size);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARM64_INS_BIC:\n\tif (OPCOUNT64 () == 2) {\n\t\tif (REGSIZE64 (0) == 4) {\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,0xffffffff,^,%s,&=\",\n\t\t\t\t\tREG64 (1), REG64 (0));\n\t\t} else {\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,0xffffffffffffffff,^,%s,&=\",\n\t\t\t\t\tREG64 (1), REG64 (0));\n\t\t}\n\t} else {\n\t\tif (REGSIZE64 (0) == 4) {\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,0xffffffff,^,%s,&,%s,=\",\n\t\t\t\t\tREG64 (2), REG64 (1), REG64 (0));\n\t\t} else {\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,0xffffffffffffffff,^,%s,&,%s,=\",\n\t\t\t\t\tREG64 (2), REG64 (1), REG64 (0));\n\t\t}\n\t}\n\tbreak;\n\tcase ARM64_INS_CBZ:\n\t\tr_strbuf_setf (&op->esil, \"%s,!,?{,%\"PFMT64d\",pc,=,}\",\n\t\t\t\tREG64 (0), IMM64 (1));\n\t\tbreak;\n\tcase ARM64_INS_CBNZ:\n\t\tr_strbuf_setf (&op->esil, \"%s,?{,%\"PFMT64d\",pc,=,}\",\n\t\t\t\tREG64 (0), IMM64 (1));\n\t\tbreak;\n\tcase ARM64_INS_TBZ:\n\t\t// tbnz x0, 4, label\n\t\t// if ((1<<4) & x0) goto label;\n\t\tr_strbuf_setf (&op->esil, \"%\" PFMT64d \",1,<<,%s,&,!,?{,%\"PFMT64d\",pc,=,}\",\n\t\t\t\tIMM64 (1), REG64 (0), IMM64 (2));\n\t\tbreak;\n\tcase ARM64_INS_TBNZ:\n\t\t// tbnz x0, 4, label\n\t\t// if ((1<<4) & x0) goto label;\n\t\tr_strbuf_setf (&op->esil, \"%\" PFMT64d \",1,<<,%s,&,?{,%\"PFMT64d\",pc,=,}\",\n\t\t\t\tIMM64 (1), REG64 (0), IMM64 (2));\n\t\tbreak;\n\tcase ARM64_INS_STNP:\n\tcase ARM64_INS_STP: // stp x6, x7, [x6,0xf90]\n\t{\n\t\tint disp = (int)MEMDISP64 (2);\n\t\tchar sign = disp>=0?'+':'-';\n\t\tst64 abs = disp>=0? MEMDISP64 (2): -(st64)MEMDISP64 (2);\n\t\tint size = REGSIZE64 (0);\n\t\t// Pre-index case\n\t\tif (ISPREINDEX64 ()) {\n\t\t\t// \"stp x2, x3, [x8, 0x20]!\n\t\t\t// \"32,x8,+=,x2,x8,=[8],x3,x8,8,+,=[8]\",\n\t\t\tr_strbuf_setf(&op->esil,\n\t\t\t\t\t\"%\" PFMT64d \",%s,%c=,%s,%s,=[%d],%s,%s,%d,+,=[%d]\",\n\t\t\t\t\tabs, MEMBASE64 (2), sign,\n\t\t\t\t\tREG64 (0), MEMBASE64 (2), size,\n\t\t\t\t\tREG64 (1), MEMBASE64 (2), size, size);\n\t\t// Post-index case\n\t\t} else if (ISPOSTINDEX64 ()) {\n\t\t\tint val = IMM64 (3);\n\t\t\tsign = val>=0?'+':'-';\n\t\t\tabs = val>=0? val: -val;\n\t\t\t// \"stp x4, x5, [x8], 0x10\"\n\t\t\t// \"x4,x8,=[],x5,x8,8,+,=[],16,x8,+=\"\n\t\t\tr_strbuf_setf(&op->esil,\n\t\t\t\t\t\"%s,%s,=[%d],%s,%s,%d,+,=[%d],%\" PFMT64d \",%s,%c=\",\n\t\t\t\t\tREG64 (0), MEMBASE64 (2), size,\n\t\t\t\t\tREG64 (1), MEMBASE64 (2), size, size,\n\t\t\t\t\tabs, MEMBASE64 (2), sign);\n\t\t// Everything else\n\t\t} else {\n\t\t\tr_strbuf_setf (&op->esil,\n\t\t\t\t\t\"%s,%s,%\"PFMT64d\",%c,=[%d],\"\n\t\t\t\t\t\"%s,%s,%\"PFMT64d\",%c,%d,+,=[%d]\",\n\t\t\t\t\tREG64 (0), MEMBASE64 (2), abs, sign, size,\n\t\t\t\t\tREG64 (1), MEMBASE64 (2), abs, sign, size, size);\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARM64_INS_LDP: // ldp x29, x30, [sp], 0x10\n\t{\n\t\tint disp = (int)MEMDISP64 (2);\n\t\tchar sign = disp>=0?'+':'-';\n\t\tut64 abs = disp>=0? MEMDISP64 (2): -MEMDISP64 (2);\n\t\tint size = REGSIZE64 (0);\n\t\t// Pre-index case\n\t\t// x2,x8,32,+,=[8],x3,x8,32,+,8,+,=[8]\n\t\tif (ISPREINDEX64 ()) {\n\t\t\t// \"ldp x0, x1, [x8, -0x10]!\"\n\t\t\t// 16,x8,-=,x8,[8],x0,=,x8,8,+,[8],x1,=\n\t\t\tr_strbuf_setf (&op->esil,\n\t\t\t\t\t\"%\"PFMT64d\",%s,%c=,\"\n\t\t\t\t\t\"%s,[%d],%s,=,\"\n\t\t\t\t\t\"%d,%s,+,[%d],%s,=\",\n\t\t\t\t\tabs, MEMBASE64 (2), sign,\n\t\t\t\t\tMEMBASE64 (2), size, REG64 (0),\n\t\t\t\t\tsize, MEMBASE64 (2), size, REG64 (1));\n\t\t// Post-index case\n\t\t} else if (ISPOSTINDEX64 ()) {\n\t\t\tint val = IMM64 (3);\n\t\t\tsign = val>=0?'+':'-';\n\t\t\tabs = val>=0? val: -val;\n\t\t\t// ldp x4, x5, [x8], -0x10\n\t\t\t// x8,[8],x4,=,x8,8,+,[8],x5,=,16,x8,+=\n\t\t\tr_strbuf_setf (&op->esil,\n\t\t\t\t\t\"%s,[%d],%s,=,\"\n\t\t\t\t\t\"%s,%d,+,[%d],%s,=,\"\n\t\t\t\t\t\"%\" PFMT64d \",%s,%c=\",\n\t\t\t\t\tMEMBASE64 (2), size, REG64 (0),\n\t\t\t\t\tMEMBASE64 (2), size, size, REG64 (1),\n\t\t\t\t\tabs, MEMBASE64 (2), sign);\n\t\t} else {\n\t\t\tr_strbuf_setf (&op->esil,\n\t\t\t\t\t\"%\"PFMT64d\",%s,%c,[%d],%s,=,\"\n\t\t\t\t\t\"%d,%\"PFMT64d\",%s,%c,+,[%d],%s,=\",\n\t\t\t\t\tabs, MEMBASE64 (2), sign, size, REG64 (0),\n\t\t\t\t\tsize, abs, MEMBASE64 (2), sign, size, REG64 (1));\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARM64_INS_ADRP:\n\t\tr_strbuf_setf (&op->esil, \"%\"PFMT64d\",%s,=\",\n\t\t\t\tIMM64 (1), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_EXTR:\n\t\t// from VEX\n\t\t/*\n\t\t\t01 | t0 = GET:I64(x4)\n\t\t\t02 | t1 = GET:I64(x0)\n\t\t\t03 | t4 = Shr64(t1,0x20)\n\t\t\t04 | t5 = Shl64(t0,0x20)\n\t\t\t05 | t3 = Or64(t5,t4)\n\t\t\t06 | PUT(x4) = t3\n\t\t*/\n\t\tr_strbuf_setf (&op->esil, \"%\" PFMT64d \",%s,>>,%\" PFMT64d \",%s,<<,|,%s,=\",\n\t\t\tIMM64 (3), REG64 (2), IMM64 (3), REG64 (1), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_RBIT:\n\t\t// slightly shorter expression to reverse bits\n\t\tr_strbuf_setf (&op->esil, \"0,tmp,=,0,DUP,DUP,DUP,%d,-,%s,>>,1,&,<<,tmp,+=,%d,-,?{,++,4,GOTO,},tmp,%s,=\",\n\t\t\tREGBITS64 (1)-1, REG64 (1), REGBITS64 (1)-1, REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_MVN:\n\tcase ARM64_INS_MOVN:\n\t{\n\t\tcs_arm64_op dst = INSOP64 (0);\n\t\tcs_arm64_op src = INSOP64 (1);\n\n\t\tif (dst.vas && src.vas) {\n\t\t\tr_strbuf_setf (&op->esil, \"%sh,-1,^,%sh,=,%sl,-1,^,%sl,=\",\n\t\t\t\tREG64 (1), REG64 (0), REG64 (1), REG64 (0));\n\t\t} else {\n\t\t\tARG64_APPEND (&op->esil, 1);\n\t\t\tr_strbuf_appendf (&op->esil, \",-1,^,\");\n\t\t\tVEC64_DST_APPEND (&op->esil, 0, -1);\n\t\t\tr_strbuf_appendf (&op->esil, \",=\");\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARM64_INS_MOVK: // movk w8, 0x1290\n\t{\n\t\tut64 shift = LSHIFT2_64 (1);\n\t\tif (shift < 0) {\n\t\t\tshift = 0;\n\t\t} else if (shift > 48) {\n\t\t\tshift = 48;\n\t\t}\n\t\tut64 shifted_imm = IMM64 (1) << shift;\n\t\tut64 mask = ~(0xffffULL << shift);\n\n\t\tr_strbuf_setf (&op->esil, \"0x%\"PFMT64x\",%s,&,%\"PFMT64u\",|,%s,=\",\n\t\t\tmask,\n\t\t\tREG64 (0),\n\t\t\tshifted_imm,\n\t\t\tREG64 (0));\n\n\t\tbreak;\n\t}\n\tcase ARM64_INS_MOVZ:\n\t\tr_strbuf_setf (&op->esil, \"%\"PFMT64u\",%s,=\",\n\t\t\tSHIFTED_IMM64 (1, REGSIZE64 (0)*8),\n\t\t\tREG64 (0));\n\t\tbreak;\n\t/* ASR, SXTB, SXTH and SXTW are alias for SBFM */\n\tcase ARM64_INS_ASR:\n\t{\n\t\t//OPCALL (\">>>>\");\n\t\tconst char *r0 = REG64 (0);\n\t\tconst char *r1 = REG64 (1);\n\t\tconst int size = REGSIZE64 (0)*8;\n\n\t\tif (ISREG64 (2)) {\n\t\t\tif (LSHIFT2_64 (2)) {\n\t\t\t\tARG64_APPEND (&op->esil, 2);\n\t\t\t\tr_strbuf_appendf (&op->esil, \",%d,%%,%s,>>>>,%s,=\", size, r1, r0);\n\t\t\t} else {\n\t\t\t\tconst char *r2 = REG64 (2);\n\t\t\t\tr_strbuf_setf (&op->esil, \"%d,%s,%%,%s,>>>>,%s,=\", size, r2, r1, r0);\n\t\t\t}\n\t\t} else {\n\t\t\tut64 i2 = IMM64 (2);\n\t\t\tr_strbuf_setf (&op->esil, \"%\"PFMT64d\",%s,>>>>,%s,=\", i2 % (ut64)size, r1, r0);\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARM64_INS_SXTB:\n\t\tif (arm64_reg_width(REGID64 (0)) == 32) {\n\t\t\tr_strbuf_setf (&op->esil, \"0xffffffff,8,0xff,%s,&,~,&,%s,=\",\n\t\t\t\tREG64 (1), REG64 (0));\n\t\t} else {\n\t\t\tr_strbuf_setf (&op->esil, \"8,0xff,%s,&,~,%s,=\",\n\t\t\t\tREG64 (1), REG64 (0));\n\t\t}\n\t\tbreak;\n\tcase ARM64_INS_SXTH: /* halfword */\n\t\tif (arm64_reg_width(REGID64 (0)) == 32) {\n\t\t\tr_strbuf_setf (&op->esil, \"0xffffffff,16,0xffff,%s,&,~,&,%s,=\",\n\t\t\t\tREG64 (1), REG64 (0));\n\t\t} else {\n\t\t\tr_strbuf_setf (&op->esil, \"16,0xffff,%s,&,~,%s,=\",\n\t\t\t\tREG64 (1), REG64 (0));\n\t\t}\n\t\tbreak;\n\tcase ARM64_INS_SXTW: /* word */\n\t\tr_strbuf_setf (&op->esil, \"32,0xffffffff,%s,&,~,%s,=\",\n\t\t\t\tREG64 (1), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_UXTB:\n\t\tr_strbuf_setf (&op->esil, \"%s,0xff,&,%s,=\", REG64 (1), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_UXTH:\n\t\tr_strbuf_setf (&op->esil, \"%s,0xffff,&,%s,=\", REG64 (1), REG64 (0));\n\t\tbreak;\n#if CS_API_MAJOR > 4\n\tcase ARM64_INS_RETAA:\n\tcase ARM64_INS_RETAB:\n\tcase ARM64_INS_ERETAA:\n\tcase ARM64_INS_ERETAB:\n#endif\n\tcase ARM64_INS_RET:\n\t\tr_strbuf_setf (&op->esil, \"lr,pc,=\");\n\t\tbreak;\n\tcase ARM64_INS_ERET:\n\t\tr_strbuf_setf (&op->esil, \"lr,pc,=\");\n\t\tbreak;\n\tcase ARM64_INS_BFI: // bfi w8, w8, 2, 1\n\tcase ARM64_INS_BFXIL:\n\t{\n\t\tif (OPCOUNT64 () >= 3 && ISIMM64 (3) && IMM64 (3) > 0) {\n\t\t\tsize_t index = IMM64 (3) - 1;\n\t\t\tif (index >= BITMASK_BY_WIDTH_COUNT) {\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\tut64 mask = bitmask_by_width[index];\n\t\t\tut64 shift = IMM64 (2);\n\t\t\tut64 notmask = ~(mask << shift);\n\t\t\t// notmask,dst,&,lsb,mask,src,&,<<,|,dst,=\n\t\t\tr_strbuf_setf (&op->esil, \"%\"PFMT64u\",%s,&,%\"PFMT64u\",%\"PFMT64u\",%s,&,<<,|,%s,=\",\n\t\t\t\tnotmask, REG64 (0), shift, mask, REG64 (1), REG64 (0));\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARM64_INS_SBFIZ:\n\t\tif (IMM64 (3) > 0 && IMM64 (3) <= 64 - IMM64 (2)) {\n\t\t\tsize_t index = IMM64 (3) - 1;\n\t\t\tif (index >= BITMASK_BY_WIDTH_COUNT) {\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\tr_strbuf_appendf (&op->esil, \"%\" PFMT64d \",%\" PFMT64d \",%s,%\"PFMT64u\",&,~,<<,%s,=\",\n\t\t\t\t\tIMM64 (2), IMM64 (3), REG64 (1), (ut64)bitmask_by_width[index], REG64 (0));\n\t\t}\n\t\tbreak;\n\tcase ARM64_INS_UBFIZ:\n\t\tif (IMM64 (3) > 0 && IMM64 (3) <= 64 - IMM64 (2)) {\n\t\t\tsize_t index = IMM64 (3) - 1;\n\t\t\tif (index >= BITMASK_BY_WIDTH_COUNT) {\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\tr_strbuf_appendf (&op->esil, \"%\" PFMT64d \",%s,%\"PFMT64u\",&,<<,%s,=\",\n\t\t\t\t\tIMM64 (2), REG64 (1), (ut64)bitmask_by_width[index], REG64 (0));\n\t\t}\n\t\tbreak;\n\tcase ARM64_INS_SBFX:\n\t\tif (IMM64 (3) > 0 && IMM64 (3) <= 64 - IMM64 (2)) {\n\t\t\tsize_t index = IMM64 (3) - 1;\n\t\t\tif (index >= BITMASK_BY_WIDTH_COUNT) {\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\tr_strbuf_appendf (&op->esil, \"%\" PFMT64d \",%\" PFMT64d \",%s,%\" PFMT64d \",%\"PFMT64u\",<<,&,>>,~,%s,=\",\n\t\t\t\tIMM64 (3), IMM64 (2), REG64 (1), IMM64 (2) , (ut64)bitmask_by_width[index], REG64 (0));\n\t\t}\n\t\tbreak;\n\tcase ARM64_INS_UBFX:\n\t\tif (IMM64 (3) > 0 && IMM64 (3) <= 64 - IMM64 (2)) {\n\t\t\tsize_t index = IMM64 (3) - 1;\n\t\t\tif (index >= BITMASK_BY_WIDTH_COUNT) {\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\tr_strbuf_appendf (&op->esil, \"%\" PFMT64d \",%s,%\" PFMT64d \",%\"PFMT64u\",<<,&,>>,%s,=\",\n\t\t\t\tIMM64 (2), REG64 (1), IMM64 (2) , (ut64)bitmask_by_width[index], REG64 (0));\n\t\t}\n\t\tbreak;\n\tcase ARM64_INS_NEG:\n#if CS_API_MAJOR > 3\n\tcase ARM64_INS_NEGS:\n#endif\n\t\tARG64_APPEND (&op->esil, 1);\n\t\tr_strbuf_appendf (&op->esil, \",0,-,%s,=\", REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_SVC:\n\t\tr_strbuf_setf (&op->esil, \"%\" PFMT64u \",$\", IMM64 (0));\n\t\tbreak;\n\t}\n\n\tr_strbuf_append (&op->esil, postfix);\n\n\treturn 0;\n}\n\n#define MATH32(opchar) arm32math(a, op, addr, buf, len, handle, insn, pcdelta, str, opchar, 0)\n#define MATH32_NEG(opchar) arm32math(a, op, addr, buf, len, handle, insn, pcdelta, str, opchar, 1)\n#define MATH32AS(opchar) arm32mathaddsub(a, op, addr, buf, len, handle, insn, pcdelta, str, opchar)\n\nstatic void arm32math(RAnal *a, RAnalOp *op, ut64 addr, const ut8 *buf, int len, csh *handle, cs_insn *insn, int pcdelta, char(*str)[32], const char *opchar, int negate) {\n\tconst char *dest = ARG(0);\n\tconst char *op1;\n\tconst char *op2;\n\tbool rotate_imm = OPCOUNT() > 3;\n\tif (OPCOUNT() > 2) {\n\t\t op1 = ARG(1);\n\t\t op2 = ARG(2);\n\t} else {\n\t\top1 = dest;\n\t\top2 = ARG(1);\n\t}\n\t// right operand\n\tif (rotate_imm) {\n\t\tr_strbuf_appendf (&op->esil, \"%s,\", ARG(3));\n\t}\n\tif (!strcmp (op2, \"pc\")) {\n\t\tr_strbuf_appendf (&op->esil, \"%d,$$,+\", pcdelta);\n\t} else {\n\t\tr_strbuf_appendf (&op->esil, \"%s\", op2);\n\t}\n\tif (rotate_imm) {\n\t\tr_strbuf_appendf (&op->esil, \",>>>\");\n\t}\n\tif (negate) {\n\t\tr_strbuf_appendf (&op->esil, \",-1,^\");\n\t}\n\tif (!strcmp (op1, \"pc\")) {\n\t\tr_strbuf_appendf (&op->esil, \",%d,$$,+,%s,0xffffffff,&,%s,=\", pcdelta, opchar, dest);\n\t} else {\n\t\tif (ISSHIFTED(1)) {\n\t\t\tr_strbuf_appendf (&op->esil, \",0xffffffff,&,%s,=\", dest);\n\t\t} else {\n\t\t\tr_strbuf_appendf (&op->esil, \",%s,%s,0xffffffff,&,%s,=\", op1, opchar, dest);\n\t\t}\n\t}\n}\n\nstatic void arm32mathaddsub(RAnal *a, RAnalOp *op, ut64 addr, const ut8 *buf, int len, csh *handle, cs_insn *insn, int pcdelta, char(*str)[32], const char *opchar) {\n\tconst char *dst = ARG (0);\n\tconst char *src;\n\tbool noflags = false;\n\tif (!strcmp (dst, \"pc\")) {\t//this is because strbuf_prepend doesn't exist and E_TOO_LAZY\n\t\t//\t\tr_strbuf_append (&op->esil, \"$$,pc,=,\");\n\t\tnoflags = true;\n\t}\n\tif (OPCOUNT () == 3) {\n\t\tr_strbuf_appendf (&op->esil, \"%s,0xffffffff,&,%s,=,\", ARG (1), dst);\n\t\tsrc = ARG (2);\n\t} else {\n\t\t//\t\tsrc = (!strcmp (ARG(1), \"pc\"))? \"$$\": ARG(1);\n\t\tsrc = ARG (1);\n\t}\n\tr_strbuf_appendf (&op->esil, \"%s,%s,%s,0xffffffff,&,%s,=\", src, dst, opchar, dst);\n\tif (noflags) {\n\t\treturn;\n\t}\n\tr_strbuf_appendf (&op->esil, \",$z,zf,:=,%s,cf,:=,vf,=,0,nf,=\",\n\t\t(!strcmp (opchar, \"+\")? \"30,$c,31,$c,^,31,$c\": \"30,$c,31,$c,^,32,$b\"));\n}\n\nstatic int analop_esil(RAnal *a, RAnalOp *op, ut64 addr, const ut8 *buf, int len, csh *handle, cs_insn *insn, bool thumb) {\n\tint i;\n\tconst char *postfix = NULL;\n\tchar str[32][32];\n\tint msr_flags;\n\tint pcdelta = (thumb? 4: 8);\n\tut32 mask = UT32_MAX;\n\tint str_ldr_bytes = 4;\n\tunsigned int width = 0;\n\n\tr_strbuf_init (&op->esil);\n\tr_strbuf_set (&op->esil, \"\");\n\tpostfix = arm_prefix_cond (op, insn->detail->arm.cc);\n\n\tswitch (insn->id) {\n\tcase ARM_INS_CLZ:\n\t\tr_strbuf_appendf (&op->esil, \"%s,!,?{,32,%s,=,BREAK,},0,%s,=,%s,%s,<<,0x80000000,&,!,?{,1,%s,+=,11,GOTO,}\", REG (1), REG (0), REG (0), REG (0), REG (1), REG (0));\n\t\tbreak;\n\tcase ARM_INS_IT:\n\t\tr_strbuf_appendf (&op->esil, \"2,$$,+,pc,=\");\n\t\tbreak;\n\tcase ARM_INS_BKPT:\n\t\tr_strbuf_setf (&op->esil, \"%d,%d,TRAP\", IMM (0), IMM (0));\n\t\tbreak;\n\tcase ARM_INS_NOP:\n\t\tr_strbuf_setf (&op->esil, \",\");\n\t\tbreak;\n\tcase ARM_INS_BL:\n\tcase ARM_INS_BLX:\n\t\tr_strbuf_appendf (&op->esil, \"pc,%d,+,lr,=,\", thumb);\n\t\t/* fallthrough */\n\tcase ARM_INS_BX:\n\tcase ARM_INS_BXJ:\n\tcase ARM_INS_B:\n\t\tif (ISREG (0) && REGID (0) == ARM_REG_PC) {\n\t\t\tr_strbuf_appendf (&op->esil, \"0x%\" PFMT64x \",pc,=\",\n\t\t\t\t(ut64)((addr & ~3LL) + pcdelta));\n\t\t} else {\n\t\t\tif (ISIMM (0)) {\n\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,pc,=\", ARG (0));\n\t\t\t} else {\n\t\t\t\tr_strbuf_appendf (&op->esil, \"%d,%s,-,pc,=\", thumb, ARG (0));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_UDF:\n\t\tr_strbuf_setf (&op->esil, \"%s,TRAP\", ARG (0));\n\t\tbreak;\n\tcase ARM_INS_SADD16:\n\tcase ARM_INS_SADD8:\n\t\tMATH32AS (\"+\");\n\t\tbreak;\n\tcase ARM_INS_ADDW:\n\tcase ARM_INS_ADD:\n\t\tMATH32 (\"+\");\n\t\tbreak;\n\tcase ARM_INS_ADC:\n\t\tif (OPCOUNT () == 2) {\n\t\t\tr_strbuf_appendf (&op->esil, \"cf,%s,+=,%s,%s,+=\", ARG (0), ARG (1), ARG (0));\n\t\t} else {\n\t\t\tr_strbuf_appendf (&op->esil, \"cf,%s,+=,%s,%s,+,%s,+=\", ARG (0), ARG (2), ARG (1), ARG (0));\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_SSUB16:\n\tcase ARM_INS_SSUB8:\n\t\tMATH32AS (\"-\");\n\t\tbreak;\n\tcase ARM_INS_SUBW:\n\tcase ARM_INS_SUB:\n\t\tMATH32 (\"-\");\n\t\tbreak;\n\tcase ARM_INS_SBC:\n\t\tif (OPCOUNT () == 2) {\n\t\t\tr_strbuf_appendf (&op->esil, \"cf,%s,-=,%s,%s,-=\", ARG (0), ARG (1), ARG (0));\n\t\t} else {\n\t\t\tr_strbuf_appendf (&op->esil, \"cf,%s,-=,%s,%s,+,%s,-=\", ARG (0), ARG (2), ARG (1), ARG (0));\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_MUL:\n\t\tMATH32 (\"*\");\n\t\tbreak;\n\tcase ARM_INS_AND:\n\t\tMATH32 (\"&\");\n\t\tbreak;\n\tcase ARM_INS_ORR:\n\t\tMATH32 (\"|\");\n\t\tbreak;\n\tcase ARM_INS_EOR:\n\t\tMATH32 (\"^\");\n\t\tbreak;\n\tcase ARM_INS_ORN:\n\t\tMATH32_NEG (\"|\");\n\t\tbreak;\n\tcase ARM_INS_LSR:\n\t\tif (insn->detail->arm.update_flags) {\n\t\t\tif (OPCOUNT () == 2) {\n\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,!,!,?{,%s,1,%s,-,0x1,<<,&,!,!,cf,:=,},\", ARG (1), ARG (0), ARG (1));\n\t\t\t} else {\n\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,!,!,?{,%s,1,%s,-,0x1,<<,&,!,!,cf,:=,},\", ARG (2), ARG (1), ARG (2));\n\t\t\t}\n\t\t}\n\t\tMATH32 (\">>\");\n\t\tbreak;\n\tcase ARM_INS_LSL:\n\t\tif (insn->detail->arm.update_flags) {\n\t\t\tif (OPCOUNT () == 2) {\n\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,!,!,?{,%s,32,-,%s,>>,cf,:=,},\", ARG (1), ARG (1), ARG (0));\n\t\t\t} else {\n\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,!,!,?{,%s,32,-,%s,>>,cf,:=,},\", ARG (2), ARG (2), ARG (1));\n\t\t\t}\n\t\t}\n\t\tMATH32 (\"<<\");\n\t\tbreak;\n\tcase ARM_INS_SVC:\n\t\tr_strbuf_setf (&op->esil, \"%s,$\", ARG (0));\n\t\tbreak;\n\tcase ARM_INS_PUSH:\n#if 0\nPUSH { r4, r5, r6, r7, lr }\n4,sp,-=,lr,sp,=[4],\n4,sp,-=,r7,sp,=[4],\n4,sp,-=,r6,sp,=[4],\n4,sp,-=,r5,sp,=[4],\n4,sp,-=,r4,sp,=[4]\n\n20,sp,-=,lr,r7,r6,r5,r4,5,sp,=[*]\n#endif\n\t\tr_strbuf_appendf (&op->esil, \"%d,sp,-=,\",\n\t\t\t4 * insn->detail->arm.op_count);\n\t\tfor (i = insn->detail->arm.op_count; i > 0; i--) {\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,\", REG (i - 1));\n\t\t}\n\t\tr_strbuf_appendf (&op->esil, \"%d,sp,=[*]\",\n\t\t\tinsn->detail->arm.op_count);\n\t\tbreak;\n\tcase ARM_INS_STMDA:\n\tcase ARM_INS_STMDB:\n\tcase ARM_INS_STM:\n\tcase ARM_INS_STMIB: {\n\t\tint direction = (insn->id == ARM_INS_STMDA || insn->id == ARM_INS_STMDB ? -1 : 1);\n\t\tint offset = direction > 0 ? -1 : -insn->detail->arm.op_count;\n\t\tif (insn->id == ARM_INS_STMDA || insn->id == ARM_INS_STMIB) {\n\t\t\toffset++;\n\t\t}\n\t\tfor (i = 1; i < insn->detail->arm.op_count; i++) {\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,%d,+,=[4],\",\n\t\t\t\tREG (i), ARG (0), (i + offset) * 4);\n\t\t}\n\t\tif (insn->detail->arm.writeback == true) { //writeback, reg should be incremented\n\t\t\tr_strbuf_appendf (&op->esil, \"%d,%s,+=,\",\n\t\t\t\tdirection * (insn->detail->arm.op_count - 1) * 4, ARG (0));\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARM_INS_VSTMIA:\n\t\tr_strbuf_set (&op->esil, \"\");\n\t\twidth = 0;\n\t\tfor (i = 1; i < insn->detail->arm.op_count; i++) {\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,%d,%s,+,=[%d],\",\n\t\t\t\tREG (i), width, ARG (0), REGSIZE32(i));\n\t\t\twidth += REGSIZE32(i);\n\t\t}\n\t\t// increment if writeback\n\t\tif (insn->detail->arm.writeback) {\n\t\t\tr_strbuf_appendf (&op->esil, \"%d,%s,+=,\", width, ARG (0));\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_VSTMDB:\n\t\tr_strbuf_set (&op->esil, \"\");\n\t\twidth = 0;\n\t\tfor (i = insn->detail->arm.op_count - 1; i > 0; i--) {\n\t\t\twidth += REGSIZE32(i);\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,%d,%s,-,=[%d],\",\n\t\t\t\tREG (i), width, ARG (0), REGSIZE32(i));\n\t\t}\n\t\t// decrement writeback is mandatory for VSTMDB\n\t\tr_strbuf_appendf (&op->esil, \"%d,%s,-=,\", width, ARG (0));\n\t\tbreak;\n\tcase ARM_INS_VLDMIA:\n\t\tr_strbuf_set (&op->esil, \"\");\n\t\twidth = 0;\n\t\tfor (i = 1; i < insn->detail->arm.op_count; i++) {\n\t\t\tr_strbuf_appendf (&op->esil, \"%d,%s,+,[%d],%s,=,\",\n\t\t\t\twidth, ARG (0), REGSIZE32(i), REG (i));\n\t\t\twidth += REGSIZE32(i);\n\t\t}\n\t\t// increment if writeback\n\t\tif (insn->detail->arm.writeback) {\n\t\t\tr_strbuf_appendf (&op->esil, \"%d,%s,+=,\", width, ARG (0));\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_VLDMDB:\n\t\tr_strbuf_set (&op->esil, \"\");\n\t\twidth = 0;\n\t\tfor (i = insn->detail->arm.op_count - 1; i > 0; i--) {\n\t\t\twidth += REGSIZE32(i);\n\t\t\tr_strbuf_appendf (&op->esil, \"%d,%s,-,[%d],%s,=,\",\n\t\t\t\twidth, ARG (0), REGSIZE32(i), REG (i));\n\t\t}\n\t\t// decrement writeback is mandatory for VLDMDB\n\t\tr_strbuf_appendf (&op->esil, \"%d,%s,-=,\", width, ARG (0));\n\t\tbreak;\n\tcase ARM_INS_ASR:\n\t\t// suffix 'S' forces conditional flag to be updated\n\t\tif (insn->detail->arm.update_flags) {\n\t\t\tif (OPCOUNT () == 2) {\n\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,!,!,?{,%s,1,%s,-,0x1,<<,&,!,!,cf,:=,},\", ARG (1), ARG (0), ARG (1));\n\t\t\t} else if (OPCOUNT () == 3) {\n\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,!,!,?{,%s,1,%s,-,0x1,<<,&,!,!,cf,:=,},\", ARG (2), ARG (1), ARG (2));\n\t\t\t}\n\t\t}\n\t\tif (OPCOUNT () == 2) {\n\t\t\tif (ISSHIFTED (1)) {\n\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,=\", ARG (1), ARG (0));\n\t\t\t} else {\n\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,>>>>,%s,=\", ARG (1), ARG (0), ARG (0));\n\t\t\t}\n\t\t} else if (OPCOUNT () == 3) {\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,>>>>,%s,=\", ARG (2), ARG (1), ARG (0));\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_POP:\n#if 0\nPOP { r4,r5, r6}\nr6,r5,r4,3,sp,[*],12,sp,+=\n#endif\n\t\tfor (i = insn->detail->arm.op_count; i > 0; i--) {\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,\", REG (i - 1));\n\t\t}\n\t\tr_strbuf_appendf (&op->esil, \"%d,sp,[*],\",\n\t\t\tinsn->detail->arm.op_count);\n\t\tr_strbuf_appendf (&op->esil, \"%d,sp,+=\",\n\t\t\t4 * insn->detail->arm.op_count);\n\t\tbreak;\n\tcase ARM_INS_LDMDA:\n\tcase ARM_INS_LDMDB:\n\tcase ARM_INS_LDM:\n\tcase ARM_INS_LDMIB: {\n\t\tint direction = (insn->id == ARM_INS_LDMDA || insn->id == ARM_INS_LDMDB) ? -1 : 1;\n\t\tint offset = direction > 0 ? -1 : -insn->detail->arm.op_count;\n\t\tif (insn->id == ARM_INS_LDMDA || insn->id == ARM_INS_LDMIB) {\n\t\t\toffset++;\n\t\t}\n\t\tfor (i = 1; i < insn->detail->arm.op_count; i++) {\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,%d,+,[4],%s,=,\", ARG (0), (i + offset) * 4, REG (i));\n\t\t}\n\t\tif (insn->detail->arm.writeback) {\n\t\t\tr_strbuf_appendf (&op->esil, \"%d,%s,+=,\",\n\t\t\t\tdirection * (insn->detail->arm.op_count - 1) * 4, ARG (0));\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARM_INS_CMP:\n\t\tr_strbuf_appendf (&op->esil, \"%s,%s,==\", ARG (1), ARG (0));\n\t\tbreak;\n\tcase ARM_INS_CMN:\n\t\tr_strbuf_appendf (&op->esil, \"%s,%s,^,!,!,zf,=\", ARG (1), ARG (0));\n\t\tbreak;\n\tcase ARM_INS_MOVT:\n\t\tr_strbuf_appendf (&op->esil, \"16,%s,<<,%s,|=\", ARG (1), REG (0));\n\t\tbreak;\n\tcase ARM_INS_ADR:\n\t\tr_strbuf_appendf (&op->esil, \"%d,$$,+,%s,+,0xfffffffc,&,%s,=\",\n\t\t\tpcdelta, ARG (1), REG (0));\n\t\tbreak;\n\tcase ARM_INS_MOV:\n\tcase ARM_INS_VMOV:\n\tcase ARM_INS_MOVW:\n\t\tif (a->bits == 16) {\n\t\t\tMATH32 (\"=\");\n\t\t} else {\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,=\", ARG (1), REG (0));\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_CBZ:\n\t\tr_strbuf_appendf (&op->esil, \"%s,!,?{,%\" PFMT32u \",pc,=,}\",\n\t\t\tREG (0), IMM (1));\n\t\tbreak;\n\tcase ARM_INS_CBNZ:\n\t\tr_strbuf_appendf (&op->esil, \"%s,?{,%\" PFMT32u \",pc,=,}\",\n\t\t\tREG (0), IMM (1));\n\t\tbreak;\n\t\t// Encapsulated STR/H/B into a code section\n\tcase ARM_INS_STRT:\n\tcase ARM_INS_STR:\n\tcase ARM_INS_STRHT:\n\tcase ARM_INS_STRH:\n\tcase ARM_INS_STRBT:\n\tcase ARM_INS_STRB:\n\tcase ARM_INS_STRD:\n\t//case ARM_INS_STLXRB: // capstone has no STLXR?\n\t\tswitch (insn->id) {\n\t\tcase ARM_INS_STRD:\n\t\t\tstr_ldr_bytes = 8; // just an indication, won't be used in esil code\n\t\t\tbreak;\n\t\tcase ARM_INS_STRHT:\n\t\tcase ARM_INS_STRH:\n\t\t\tstr_ldr_bytes = 2;\n\t\t\tbreak;\n\t\tcase ARM_INS_STRBT:\n\t\tcase ARM_INS_STRB:\n\t\t\tstr_ldr_bytes = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstr_ldr_bytes = 4;\n\t\t}\n\t\tif (OPCOUNT() == 2) {\n\t\t\tif (ISMEM(1) && !HASMEMINDEX(1)) {\n\t\t\t\tint disp = MEMDISP(1);\n\t\t\t\tchar sign = disp>=0?'+':'-';\n\t\t\t\tdisp = disp>=0?disp:-disp;\n\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,0x%x,%s,%c,0xffffffff,&,=[%d]\",\n\t\t\t\t\t\t  REG(0), disp, MEMBASE(1), sign, str_ldr_bytes);\n\t\t\t\tif (insn->detail->arm.writeback) {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \",%d,%s,%c,%s,=\",\n\t\t\t\t\t\t\t  disp, MEMBASE(1), sign, MEMBASE(1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (HASMEMINDEX(1)) {\t// e.g. 'str r2, [r3, r1]'\n\t\t\t\tif (ISSHIFTED(1)) { // e.g. 'str r2, [r3, r1, lsl 4]'\n\t\t\t\t\tswitch (SHIFTTYPE(1)) {\n\t\t\t\t\tcase ARM_SFT_LSL:\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,%d,%s,<<,+,0xffffffff,&,=[%d]\",\n\t\t\t\t\t\t\t\t  REG(0), MEMBASE(1), SHIFTVALUE(1), MEMINDEX(1), str_ldr_bytes);\n\t\t\t\t\t\tif (insn->detail->arm.writeback) { // e.g. 'str r2, [r3, r1, lsl 4]!'\n\t\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",%s,%d,%s,<<,+,%s,=\",\n\t\t\t\t\t\t\t\t\t  MEMBASE(1), SHIFTVALUE(1), MEMINDEX(1), MEMBASE(1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ARM_SFT_LSR:\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,%d,%s,>>,+,0xffffffff,&,=[%d]\",\n\t\t\t\t\t\t\t\t  REG(0), MEMBASE(1), SHIFTVALUE(1), MEMINDEX(1), str_ldr_bytes);\n\t\t\t\t\t\tif (insn->detail->arm.writeback) {\n\t\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",%s,%d,%s,>>,+,%s,=\",\n\t\t\t\t\t\t\t\t\t  MEMBASE(1), SHIFTVALUE(1), MEMINDEX(1), MEMBASE(1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ARM_SFT_ASR:\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,%d,%s,>>>>,+,0xffffffff,&,=[%d]\",\n\t\t\t\t\t\t\t\t  REG(0), MEMBASE(1), SHIFTVALUE(1), MEMINDEX(1), str_ldr_bytes);\n\t\t\t\t\t\tif (insn->detail->arm.writeback) {\n\t\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",%s,%d,%s,>>>>,+,%s,=\",\n\t\t\t\t\t\t\t\t\t  MEMBASE(1), SHIFTVALUE(1), MEMINDEX(1), MEMBASE(1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ARM_SFT_ROR:\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,%d,%s,>>>,+,0xffffffff,&,=[%d]\",\n\t\t\t\t\t\t\t\t  REG(0), MEMBASE(1), SHIFTVALUE(1), MEMINDEX(1), str_ldr_bytes);\n\t\t\t\t\t\tif (insn->detail->arm.writeback) {\n\t\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",%s,%d,%s,>>>,+,%s,=\",\n\t\t\t\t\t\t\t\t\t  MEMBASE(1), SHIFTVALUE(1), MEMINDEX(1), MEMBASE(1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ARM_SFT_RRX: // ROR with single bit shift, using previous cf rather than new cf\n\t\t\t\t\t\t//TODO: r2 doesn't mark this as a shift, it falls through to no shift\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// Hopefully nothing here\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else { // No shift\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,%s,+,0xffffffff,&,=[%d]\",\n\t\t\t\t\t\t\t  REG(0), MEMINDEX(1), MEMBASE(1), str_ldr_bytes);\n\t\t\t\t\tif (insn->detail->arm.writeback) {\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",%s,%s,+,%s,=\",\n\t\t\t\t\t\t\t\t  MEMINDEX(1), MEMBASE(1), MEMBASE(1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (OPCOUNT() == 3) { // e.g. 'str r2, [r3], 4\n\t\t\tif (ISIMM(2)) { // e.g. 'str r2, [r3], 4\n\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,0xffffffff,&,=[%d],%d,%s,+=\",\n\t\t\t\t\t       REG(0), MEMBASE(1), str_ldr_bytes, IMM(2), MEMBASE(1));\n\t\t\t}\n\t\t\tif (ISREG(2)) { // e.g. 'str r2, [r3], r1\n\t\t\t\tif (ISSHIFTED(2)) { // e.g. 'str r2, [r3], r1, lsl 4'\n\t\t\t\t\tswitch (SHIFTTYPE(2)) {\n\t\t\t\t\tcase ARM_SFT_LSL:\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,0xffffffff,&,=[%d],%s,%d,%s,<<,+,%s,=\",\n\t\t\t\t\t\t\t       REG(0), MEMBASE(1), str_ldr_bytes, MEMBASE(1), SHIFTVALUE(2), REG(2), MEMBASE(1));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ARM_SFT_LSR:\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,0xffffffff,&,=[%d],%s,%d,%s,>>,+,%s,=\",\n\t\t\t\t\t\t\t       REG(0), MEMBASE(1), str_ldr_bytes, MEMBASE(1), SHIFTVALUE(2), REG(2), MEMBASE(1));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ARM_SFT_ASR:\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,0xffffffff,&,=[%d],%s,%d,%s,>>>>,+,%s,=\",\n\t\t\t\t\t\t\t       REG(0), MEMBASE(1), str_ldr_bytes, MEMBASE(1), SHIFTVALUE(2), REG(2), MEMBASE(1));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ARM_SFT_ROR:\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,0xffffffff,&,=[%d],%s,%d,%s,>>>,+,%s,=\",\n\t\t\t\t\t\t\t       REG(0), MEMBASE(1), str_ldr_bytes, MEMBASE(1), SHIFTVALUE(2), REG(2), MEMBASE(1));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ARM_SFT_RRX:\n\t\t\t\t\t\t//TODO\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// Hopefully nothing here\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else { // No shift\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,0xffffffff,&,=[%d],%s,%s,+=\",\n\t\t\t\t\t\t       REG(0), MEMBASE(1), str_ldr_bytes, REG(2), MEMBASE(1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ISREG(1) && str_ldr_bytes==8) { // e.g. 'strd r2, r3, [r4]', normally should be the only case for ISREG(1).\n\t\t\t\tif (!HASMEMINDEX(2)) {\n\t\t\t\t\tint disp = MEMDISP(2);\n\t\t\t\t\tchar sign = disp>=0?'+':'-';\n\t\t\t\t\tdisp = disp>=0?disp:-disp;\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%d,%s,%c,0xffffffff,&,=[4],%s,4,%d,+,%s,%c,0xffffffff,&,=[4]\",\n\t\t\t\t\t\t\t  REG(0), disp, MEMBASE(2), sign, REG(1), disp, MEMBASE(2), sign);\n\t\t\t\t\tif (insn->detail->arm.writeback) {\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",%d,%s,%c,%s,=\",\n\t\t\t\t\t\t\t\t  disp, MEMBASE(2), sign, MEMBASE(2));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (ISSHIFTED(2)) {\n\t\t\t\t\t\t// it seems strd does not support SHIFT which is good, but have a check nonetheless\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,%s,+,0xffffffff,&,=[4],%s,4,%s,+,%s,+,0xffffffff,&,=[4]\",\n\t\t\t\t\t\t\t\t  REG(0), MEMINDEX(2), MEMBASE(2), REG(1), MEMINDEX(2), MEMBASE(2));\n\t\t\t\t\t\tif (insn->detail->arm.writeback) {\n\t\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",%s,%s,+,%s,=\",\n\t\t\t\t\t\t\t\t\t  MEMINDEX(2), MEMBASE(2), MEMBASE(2));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (OPCOUNT() == 4) { // e.g. 'strd r2, r3, [r4], 4' or 'strd r2, r3, [r4], r5'\n\t\t\tif (ISIMM(3)) { // e.g. 'strd r2, r3, [r4], 4'\n\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,0xffffffff,&,=[%d],%s,4,%s,+,0xffffffff,&,=[%d],%d,%s,+=,\",\n\t\t\t\t\t       REG(0), MEMBASE(2), str_ldr_bytes, REG(1), MEMBASE(2), str_ldr_bytes, IMM(3), MEMBASE(2));\n\t\t\t}\n\t\t\tif (ISREG(3)) { // e.g. 'strd r2, r3, [r4], r5'\n\t\t\t\tif (ISSHIFTED(3)) {\n\t\t\t\t\t// same as above\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,0xffffffff,&,=[%d],%s,4,%s,+,0xffffffff,&,=[%d],%s,%s,+=\",\n\t\t\t\t\t\t       REG(0), MEMBASE(2), str_ldr_bytes, REG(1), MEMBASE(2), str_ldr_bytes, REG(3), MEMBASE(2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_TST:\n\t\tr_strbuf_appendf (&op->esil, \"0,%s,%s,&,==\", ARG(1), ARG(0));\n\t\tbreak;\n\tcase ARM_INS_LDRD:\n\t\taddr &= ~3LL;\n\t\tif (MEMDISP (2) < 0) {\n\t\t\tconst char *pc = \"$$\";\n\t\t\tif (REGBASE (2) == ARM_REG_PC) {\n\t\t\t\top->refptr = 4;\n\t\t\t\top->ptr = addr + pcdelta + MEMDISP (2);\n\t\t\t\tr_strbuf_appendf (&op->esil, \"0x%\" PFMT64x \",2,2,%s,%d,+,>>,<<,+,0xffffffff,&,DUP,[4],%s,=,4,+,[4],%s,=\",\n\t\t\t\t\t(ut64)MEMDISP (2), pc, pcdelta, REG (0), REG (1));\n\t\t\t} else {\n\t\t\t\tint disp = MEMDISP (2);\n\t\t\t\t// not refptr, because we can't grab the reg value statically op->refptr = 4;\n\t\t\t\tif (disp < 0) {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"0x%\" PFMT64x \",%s,-,0xffffffff,&,DUP,[4],%s,=,4,+,[4],%s,=\",\n\t\t\t\t\t\t(ut64)-disp, MEMBASE (2), REG (0), REG (1));\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"0x%\" PFMT64x \",%s,+,0xffffffff,&,DUP,[4],%s,=,4,+,[4],%s,=\",\n\t\t\t\t\t\t(ut64)disp, MEMBASE (2), REG (0), REG (1));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (REGBASE (2) == ARM_REG_PC) {\n\t\t\t\tconst char *pc = \"$$\";\n\t\t\t\top->refptr = 4;\n\t\t\t\top->ptr = addr + pcdelta + MEMDISP (2);\n\t\t\t\tif (HASMEMINDEX (2) || ISREG (2)) {\n\t\t\t\t\tconst char op_index = ISMEMINDEXSUB (2)? '-': '+';\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,2,2,%d,%s,+,>>,<<,%c,0xffffffff,&,DUP,[4],%s,=,4,+,[4],%s,=\",\n\t\t\t\t\t\tMEMINDEX (2), pcdelta, pc, op_index, REG (0), REG (1));\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"2,2,%d,%s,+,>>,<<,%d,+,0xffffffff,&,DUP,[4],%s,=,4,+,[4],%s,=\",\n\t\t\t\t\t\tpcdelta, pc, MEMDISP (2), REG (0), REG (1));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (HASMEMINDEX (2)) { // e.g. `ldrd r2, r3 [r4, r1]`\n\t\t\t\t\tconst char op_index = ISMEMINDEXSUB (2)? '-': '+';\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,%c,0xffffffff,&,DUP,[4],%s,=,4,+,[4],%s,=\",\n\t\t\t\t\t\tMEMINDEX (2), MEMBASE (2), op_index, REG (0), REG (1));\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%d,%s,+,0xffffffff,&,DUP,[4],%s,=,4,+,[4],%s,=\",\n\t\t\t\t\t\tMEMDISP (2), MEMBASE (2), REG (0), REG (1));\n\t\t\t\t}\n\t\t\t\tif (insn->detail->arm.writeback) {\n\t\t\t\t\tif (ISPOSTINDEX32 ()) {\n\t\t\t\t\t\tif (ISIMM (3)) {\n\t\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",%s,%d,+,%s,=\",\n\t\t\t\t\t\t\t\tMEMBASE (2), IMM (3), MEMBASE (2));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst char op_index = ISMEMINDEXSUB (3)? '-': '+';\n\t\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",%s,%s,%c,%s,=\",\n\t\t\t\t\t\t\t\tREG (3), MEMBASE (2), op_index, MEMBASE (2));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ISPREINDEX32 ()) {\n\t\t\t\t\t\tif (HASMEMINDEX (2)) {\n\t\t\t\t\t\t\tconst char op_index = ISMEMINDEXSUB (2)? '-': '+';\n\t\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",%s,%s,%c,%s,=\",\n\t\t\t\t\t\t\t\tMEMINDEX (2), MEMBASE (2), op_index, MEMBASE (2));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",%s,%d,+,%s,=\",\n\t\t\t\t\t\t\t\tMEMBASE (2), MEMDISP (2), MEMBASE (2));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_LDRB:\n\t\tif (ISMEM(1) && LSHIFT2(1)) {\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,%d,%s,<<,+,0xffffffff,&,[1],0x%x,&,%s,=\",\n\t\t\t\tMEMBASE (1), LSHIFT2 (1), MEMINDEX (1), mask, REG (0));\n\t\t} else if (HASMEMINDEX (1)) {\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,+,0xffffffff,&,[1],%s,=\",\n\t\t\t\tMEMINDEX (1), MEMBASE (1), REG (0));\n\t\t} else {\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,%d,+,[1],%s,=\",\n\t\t\t\tMEMBASE (1), MEMDISP (1), REG (0));\n\t\t}\n\t\tif (insn->detail->arm.writeback) {\n\t\t\tif (ISIMM(2)) {\n\t\t\t\tr_strbuf_appendf (&op->esil, \",%s,%d,+,%s,=\",\n\t\t\t\t\tMEMBASE (1), IMM (2), MEMBASE (1));\n\t\t\t} else {\n\t\t\t\tr_strbuf_appendf (&op->esil, \",%s,%d,+,%s,=\",\n\t\t\t\t\tMEMBASE (1), MEMDISP (1), MEMBASE (1));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_SXTH:\n\t\tr_strbuf_appendf (&op->esil,\n\t\t\t\"15,%s,>>,1,&,?{,15,-1,<<,%s,0xffff,&,|,%s,:=,}{,%s,0xffff,%s,:=,}\",\n\t\t\tREG (1), REG (1), REG (0), REG (1), REG (0));\n\t\tbreak;\n\tcase ARM_INS_SXTB:\n\t\tr_strbuf_appendf (&op->esil,\n\t\t\t\"7,%s,>>,1,&,?{,7,-1,<<,%s,0xff,&,|,%s,:=,}{,%s,0xff,&,%s,:=,}\",\n\t\t\tREG (1), REG (1), REG (0), REG (1), REG (0));\n\t\tbreak;\n\tcase ARM_INS_LDREX:\n\tcase ARM_INS_LDREXB:\n\tcase ARM_INS_LDREXD:\n\tcase ARM_INS_LDREXH:\n\t\top->family = R_ANAL_OP_FAMILY_THREAD;\n\t\t// intentional fallthrough\n\tcase ARM_INS_LDRHT:\n\tcase ARM_INS_LDRH:\n\tcase ARM_INS_LDRT:\n\tcase ARM_INS_LDRBT:\n\tcase ARM_INS_LDRSB:\n\tcase ARM_INS_LDRSBT:\n\tcase ARM_INS_LDRSH:\n\tcase ARM_INS_LDRSHT:\n\tcase ARM_INS_LDR:\n\t\tswitch (insn->id) {\n\t\tcase ARM_INS_LDRHT:\n\t\tcase ARM_INS_LDRH:\n\t\tcase ARM_INS_LDRSH:\n\t\tcase ARM_INS_LDRSHT:\n\t\t\tmask = UT16_MAX;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmask = UT32_MAX;\n\t\t\tbreak;\n\t\t}\n\t\taddr &= ~3LL;\n\t\tif (MEMDISP(1) < 0) {\n\t\t\tconst char *pc = \"$$\";\n\t\t\tif (REGBASE(1) == ARM_REG_PC) {\n\t\t\t\top->refptr = 4;\n\t\t\t\top->ptr = addr + pcdelta + MEMDISP(1);\n\t\t\t\tr_strbuf_appendf (&op->esil, \"0x%\"PFMT64x\",2,2,%s,%d,+,>>,<<,+,0xffffffff,&,[4],0x%x,&,%s,=\",\n\t\t\t\t\t(ut64)MEMDISP(1), pc, pcdelta, mask, REG(0));\n\t\t\t} else {\n\t\t\t\tint disp = MEMDISP(1);\n\t\t\t\t// not refptr, because we can't grab the reg value statically op->refptr = 4;\n\t\t\t\tif (disp < 0) {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"0x%\"PFMT64x\",%s,-,0xffffffff,&,[4],0x%x,&,%s,=\",\n\t\t\t\t\t\t\t(ut64)-disp, MEMBASE(1), mask, REG(0));\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"0x%\"PFMT64x\",%s,+,0xffffffff,&,[4],0x%x,&,%s,=\",\n\t\t\t\t\t\t\t(ut64)disp, MEMBASE(1), mask, REG(0));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (REGBASE(1) == ARM_REG_PC) {\n\t\t\t\tconst char *pc = \"$$\";\n\t\t\t\top->refptr = 4;\n\t\t\t\top->ptr = addr + pcdelta + MEMDISP(1);\n\t\t\t\tif (ISMEM(1) && LSHIFT2(1)) {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"2,2,%d,%s,+,>>,<<,%d,%s,<<,+,0xffffffff,&,[4],0x%x,&,%s,=\",\n\t\t\t\t\t\tpcdelta, pc, LSHIFT2(1), MEMINDEX(1), mask, REG(0));\n\t\t\t\t} else {\n\t\t\t\t\tif (ISREG(1)) {\n\t\t\t\t\t\tconst char op_index = ISMEMINDEXSUB (1)? '-': '+';\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,2,2,%d,%s,+,>>,<<,%c,0xffffffff,&,[4],0x%x,&,%s,=\",\n\t\t\t\t\t\t\tMEMINDEX (1), pcdelta, pc, op_index, mask, REG (0));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \"2,2,%d,%s,+,>>,<<,%d,+,0xffffffff,&,[4],0x%x,&,%s,=\",\n\t\t\t\t\t\t\tpcdelta, pc, MEMDISP(1), mask, REG(0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (ISMEM(1) && LSHIFT2(1)) {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%d,%s,<<,+,0xffffffff,&,[4],0x%x,&,%s,=\",\n\t\t\t\t\t\tMEMBASE (1), LSHIFT2 (1), MEMINDEX (1), mask, REG (0));\n\t\t\t\t} else if (HASMEMINDEX(1)) {\t// e.g. `ldr r2, [r3, r1]`\n\t\t\t\t\tconst char op_index = ISMEMINDEXSUB (1)? '-': '+';\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,%c,0xffffffff,&,[4],0x%x,&,%s,=\",\n\t\t\t\t\t\tMEMINDEX (1), MEMBASE (1), op_index, mask, REG (0));\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%d,%s,+,0xffffffff,&,[4],0x%x,&,%s,=\",\n\t\t\t\t\t\tMEMDISP (1), MEMBASE (1), mask, REG (0));\n\t\t\t\t}\n\t\t\t\tif (insn->detail->arm.writeback) {\n\t\t\t\t\tif (ISPOSTINDEX32 ()) {\n\t\t\t\t\t\tif (ISIMM (2)) {\n\t\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",%s,%d,+,%s,=\",\n\t\t\t\t\t\t\t\tMEMBASE (1), IMM (2), MEMBASE (1));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst char op_index = ISMEMINDEXSUB (2)? '-': '+';\n\t\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",%d,%s,<<,%s,%c,%s,=\",\n\t\t\t\t\t\t\t\tLSHIFT2 (2), REG (2), MEMBASE (1), op_index, MEMBASE (1));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ISPREINDEX32 ()) {\n\t\t\t\t\t\tif (HASMEMINDEX (1)) {\n\t\t\t\t\t\t\tconst char op_index = ISMEMINDEXSUB (1)? '-': '+';\n\t\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",%d,%s,<<,%s,%c,%s,=\",\n\t\t\t\t\t\t\t\tLSHIFT2 (1), MEMINDEX (1), MEMBASE (1), op_index, MEMBASE (1));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",%s,%d,+,%s,=\",\n\t\t\t\t\t\t\t\tMEMBASE (1), MEMDISP (1), MEMBASE (1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_MRS:\n\t\t// TODO: esil for MRS\n\t\tbreak;\n\tcase ARM_INS_MSR:\n\t\tmsr_flags = insn->detail->arm.operands[0].reg >> 4;\n\t\tr_strbuf_appendf (&op->esil, \"0,\");\n\t\tif (msr_flags & 1) {\n\t\t\tr_strbuf_appendf (&op->esil, \"0xFF,|,\");\n\t\t}\n\t\tif (msr_flags & 2) {\n\t\t\tr_strbuf_appendf (&op->esil, \"0xFF00,|,\");\n\t\t}\n\t\tif (msr_flags & 4) {\n\t\t\tr_strbuf_appendf (&op->esil, \"0xFF0000,|,\");\n\t\t}\n\t\tif (msr_flags & 8) {\n\t\t\tr_strbuf_appendf (&op->esil, \"0xFF000000,|,\");\n\t\t}\n\t\tr_strbuf_appendf (&op->esil, \"DUP,!,SWAP,&,%s,SWAP,cpsr,&,|,cpsr,=\", REG(1));\n\t\tbreak;\n\tcase ARM_INS_UBFX:\n\t\tif (IMM (3) > 0 && IMM (3) <= 32 - IMM (2)) {\n\t\t\tsize_t index = IMM (3) - 1;\n\t\t\tif (index >= BITMASK_BY_WIDTH_COUNT) {\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\tr_strbuf_appendf (&op->esil, \"%d,%s,%d,%\"PFMT64u\",<<,&,>>,%s,=\",\n\t\t\t\tIMM(2), REG(1), IMM(2), bitmask_by_width[index], REG(0));\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_UXTB:\n\t\tr_strbuf_appendf (&op->esil, \"%s,0xff,&,%s,=\", ARG(1), REG(0));\n\t\tbreak;\n\tcase ARM_INS_RSB:\n\t\tif (OPCOUNT () == 2) {\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,-=\", ARG(0), ARG(1));\n\t\t} else if (OPCOUNT () == 3) {\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,-,%s,=\", ARG(1), ARG(2), ARG(0));\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_BIC:\n\t\tif (OPCOUNT () == 2) {\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,0xffffffff,^,%s,&=\", ARG(1), ARG(0));\n\t\t} else {\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,0xffffffff,^,%s,&,%s,=\", ARG(2), ARG(1), ARG(0));\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_SMMLA:\n\t\tr_strbuf_appendf (&op->esil, \"32,%s,%s,*,>>,%s,+,0xffffffff,&,%s,=\",\n\t\t\tREG(1), REG(2), REG(3), REG(0));\n\t\tbreak;\n\tcase ARM_INS_SMMLAR:\n\t\tr_strbuf_appendf (&op->esil, \"32,0x80000000,%s,%s,*,+,>>,%s,+,0xffffffff,&,%s,=\",\n\t\t\tREG(1), REG(2), REG(3), REG(0));\n\t\tbreak;\n\tcase ARM_INS_UMULL:\n\t\tr_strbuf_appendf (&op->esil, \"32,%s,%s,*,DUP,0xffffffff,&,%s,=,>>,%s,=\",\n\t\t\tREG(2), REG(3), REG(0), REG(1));\n\t\tbreak;\n\tcase ARM_INS_MLS:\n\t\tr_strbuf_appendf (&op->esil, \"%s,%s,*,%s,-,0xffffffff,&,%s,=\",\n\t\t\tREG(1), REG(2), REG(3), REG(0));\n\t\tbreak;\n\tcase ARM_INS_MLA:\n\t\tr_strbuf_appendf (&op->esil, \"%s,%s,*,%s,+,0xffffffff,&,%s,=\",\n\t\t\tREG(1), REG(2), REG(3), REG(0));\n\t\tbreak;\n\tcase ARM_INS_MVN:\n\t\tr_strbuf_appendf (&op->esil, \"-1,%s,^,0xffffffff,&,%s,=\",\n\t\t\tARG(1), REG(0));\n\t\tbreak;\n\tcase ARM_INS_BFI:\n\t{\n\t\tif (OPCOUNT() >= 3 && ISIMM(3) && IMM(3) > 0 && IMM(3) < 64) {\n\t\t\tsize_t index = IMM (3) - 1;\n\t\t\tif (index >= BITMASK_BY_WIDTH_COUNT) {\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\tut64 mask = bitmask_by_width[index];\n\t\t\tut64 shift = IMM(2);\n\t\t\tut64 notmask = ~(mask << shift);\n\t\t\t// notmask,dst,&,lsb,mask,src,&,<<,|,dst,=\n\t\t\tr_strbuf_setf (&op->esil, \"%\"PFMT64u\",%s,&,%\"PFMT64u\",%\"PFMT64u\",%s,&,<<,|,0xffffffff,&,%s,=\",\n\t\t\t\tnotmask, REG(0), shift, mask, REG(1), REG(0));\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARM_INS_BFC:\n\t{\n\t\tif (OPCOUNT() >= 2 && ISIMM(2) && IMM(2) > 0 && IMM(2) < 64) {\n\t\t\tsize_t index = IMM (2) - 1;\n\t\t\tif (index >= BITMASK_BY_WIDTH_COUNT) {\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\tut64 mask = bitmask_by_width[IMM(2) - 1];\n\t\t\tut64 shift = IMM(1);\n\t\t\tut64 notmask = ~(mask << shift);\n\t\t\t// notmask,dst,&,dst,=\n\t\t\tr_strbuf_setf (&op->esil, \"%\"PFMT64u\",%s,&,0xffffffff,&,%s,=\",\n\t\t\t\tnotmask, REG(0), REG(0));\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARM_INS_REV:\n\t{\n\t\tconst char *r0 = REG(0);\n\t\tconst char *r1 = REG(1);\n\t\tr_strbuf_setf (&op->esil,\n\t\t\t\"24,0xff,%s,&,<<,%s,=,\"\n\t\t\t\"16,0xff,8,%s,>>,&,<<,%s,|=,\"\n\t\t\t\"8,0xff,16,%s,>>,&,<<,%s,|=,\"\n\t\t\t\"0xff,24,%s,>>,&,%s,|=,\",\n\t\t\tr1, r0, r1, r0, r1, r0, r1, r0);\n\t\tbreak;\n\t}\n\tcase ARM_INS_REV16:\n\t{\n\t\tconst char *r0 = REG(0);\n\t\tconst char *r1 = REG(1);\n\t\tr_strbuf_setf (&op->esil,\n\t\t\t\"8,0xff00ff00,%s,&,>>,%s,=,\"\n\t\t\t\"8,0x00ff00ff,%s,&,<<,%s,|=,\",\n\t\t\tr1, r0, r1, r0);\n\t\tbreak;\n\t}\n\tcase ARM_INS_REVSH:\n\t{\n\t\tconst char *r0 = REG(0);\n\t\tconst char *r1 = REG(1);\n\t\tr_strbuf_setf (&op->esil,\n\t\t\t\"8,0xff00,%s,&,>>,%s,=,\"\n\t\t\t\"8,0x00ff,%s,&,<<,%s,|=,\"\n\t\t\t\"0x8000,%s,&,?{,\"\n\t\t\t\t\"0xffff0000,%s,|=,\"\n\t\t\t\"}\",\n\t\t\tr1, r0, r1, r0, r0, r0);\n\t\tbreak;\n\t}\n\tcase ARM_INS_TBB:\n\t\tr_strbuf_appendf (&op->esil, \"%s,%s,+,0xffffffff,&,DUP,[1],1,SWAP,<<,+,pc,+=\",\n\t\t\tMEMBASE (0), MEMINDEX (0));\n\t\tbreak;\n\tcase ARM_INS_TBH:\n\t\tr_strbuf_appendf (&op->esil, \"%s,%d,%s,<<,+,0xffffffff,&,[2],1,SWAP,<<,pc,+=\",\n\t\t\tMEMBASE (0), LSHIFT2 (0), MEMINDEX (0));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\t// Update flags if required...TODO different instructions update different flags, but this should fix\n\t// many errors\n\tif (insn->detail->arm.update_flags) {\n\t\tswitch(insn->id) {\n\t\tcase ARM_INS_CMP:\n\t\t\tr_strbuf_appendf (&op->esil, \",$z,zf,:=,31,$s,nf,:=,32,$b,!,cf,:=,31,$o,vf,:=\");\n\t\t\tbreak;\n\t\tcase ARM_INS_ADD:\n\t\tcase ARM_INS_RSB:\n\t\tcase ARM_INS_SUB:\n\t\tcase ARM_INS_SBC:\n\t\tcase ARM_INS_ADC:\n\t\tcase ARM_INS_CMN:\n\t\t\tr_strbuf_appendf (&op->esil, \",$z,zf,:=,31,$s,nf,:=,31,$c,cf,:=,31,$o,vf,:=\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_strbuf_appendf (&op->esil, \",$z,zf,:=,31,$s,nf,:=\");\n\t\t}\n\t}\n\n\tr_strbuf_append (&op->esil, postfix);\n\n\treturn 0;\n}\n\nstatic int cond_cs2r2(int cc) {\n\tif (cc == ARM_CC_AL || cc < 0) {\n\t\tcc = R_ANAL_COND_AL;\n\t} else {\n\t\tswitch (cc) {\n\t\tcase ARM_CC_EQ: cc = R_ANAL_COND_EQ; break;\n\t\tcase ARM_CC_NE: cc = R_ANAL_COND_NE; break;\n\t\tcase ARM_CC_HS: cc = R_ANAL_COND_HS; break;\n\t\tcase ARM_CC_LO: cc = R_ANAL_COND_LO; break;\n\t\tcase ARM_CC_MI: cc = R_ANAL_COND_MI; break;\n\t\tcase ARM_CC_PL: cc = R_ANAL_COND_PL; break;\n\t\tcase ARM_CC_VS: cc = R_ANAL_COND_VS; break;\n\t\tcase ARM_CC_VC: cc = R_ANAL_COND_VC; break;\n\t\tcase ARM_CC_HI: cc = R_ANAL_COND_HI; break;\n\t\tcase ARM_CC_LS: cc = R_ANAL_COND_LS; break;\n\t\tcase ARM_CC_GE: cc = R_ANAL_COND_GE; break;\n\t\tcase ARM_CC_LT: cc = R_ANAL_COND_LT; break;\n\t\tcase ARM_CC_GT: cc = R_ANAL_COND_GT; break;\n\t\tcase ARM_CC_LE: cc = R_ANAL_COND_LE; break;\n\t\t}\n\t}\n\treturn cc;\n}\n\nstatic void anop64(csh handle, RAnalOp *op, cs_insn *insn) {\n\tut64 addr = op->addr;\n\n\t/* grab family */\n\tif (cs_insn_group (handle, insn, ARM64_GRP_CRYPTO)) {\n\t\top->family = R_ANAL_OP_FAMILY_CRYPTO;\n\t} else if (cs_insn_group (handle, insn, ARM64_GRP_CRC)) {\n\t\top->family = R_ANAL_OP_FAMILY_CRYPTO;\n#if CS_API_MAJOR >= 4\n\t} else if (cs_insn_group (handle, insn, ARM64_GRP_PRIVILEGE)) {\n\t\top->family = R_ANAL_OP_FAMILY_PRIV;\n#endif\n\t} else if (cs_insn_group (handle, insn, ARM64_GRP_NEON)) {\n\t\top->family = R_ANAL_OP_FAMILY_MMX;\n\t} else if (cs_insn_group (handle, insn, ARM64_GRP_FPARMV8)) {\n\t\top->family = R_ANAL_OP_FAMILY_FPU;\n\t} else {\n\t\top->family = R_ANAL_OP_FAMILY_CPU;\n\t}\n\n\top->cond = cond_cs2r2 (insn->detail->arm64.cc);\n\tif (op->cond == R_ANAL_COND_NV) {\n\t\top->type = R_ANAL_OP_TYPE_NOP;\n\t\treturn;\n\t}\n\n\tswitch (insn->detail->arm64.cc) {\n\tcase ARM64_CC_GE:\n\tcase ARM64_CC_GT:\n\tcase ARM64_CC_LE:\n\tcase ARM64_CC_LT:\n\t\top->sign = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (insn->id) {\n#if CS_API_MAJOR > 4\n\tcase ARM64_INS_PACDA:\n\tcase ARM64_INS_PACDB:\n\tcase ARM64_INS_PACDZA:\n\tcase ARM64_INS_PACDZB:\n\tcase ARM64_INS_PACGA:\n\tcase ARM64_INS_PACIA:\n\tcase ARM64_INS_PACIA1716:\n\tcase ARM64_INS_PACIASP:\n\tcase ARM64_INS_PACIAZ:\n\tcase ARM64_INS_PACIB:\n\tcase ARM64_INS_PACIB1716:\n\tcase ARM64_INS_PACIBSP:\n\tcase ARM64_INS_PACIBZ:\n\tcase ARM64_INS_PACIZA:\n\tcase ARM64_INS_PACIZB:\n\tcase ARM64_INS_AUTDA:\n\tcase ARM64_INS_AUTDB:\n\tcase ARM64_INS_AUTDZA:\n\tcase ARM64_INS_AUTDZB:\n\tcase ARM64_INS_AUTIA:\n\tcase ARM64_INS_AUTIA1716:\n\tcase ARM64_INS_AUTIASP:\n\tcase ARM64_INS_AUTIAZ:\n\tcase ARM64_INS_AUTIB:\n\tcase ARM64_INS_AUTIB1716:\n\tcase ARM64_INS_AUTIBSP:\n\tcase ARM64_INS_AUTIBZ:\n\tcase ARM64_INS_AUTIZA:\n\tcase ARM64_INS_AUTIZB:\n\tcase ARM64_INS_XPACD:\n\tcase ARM64_INS_XPACI:\n\tcase ARM64_INS_XPACLRI:\n\t\top->type = R_ANAL_OP_TYPE_CMP;\n\t\top->family = R_ANAL_OP_FAMILY_SECURITY;\n\t\tbreak;\n#endif\n\tcase ARM64_INS_SVC:\n\t\top->type = R_ANAL_OP_TYPE_SWI;\n\t\top->val = IMM64(0);\n\t\tbreak;\n\tcase ARM64_INS_ADRP:\n\tcase ARM64_INS_ADR:\n\t\top->type = R_ANAL_OP_TYPE_LEA;\n\t\top->ptr = IMM64(1);\n\t\tbreak;\n\tcase ARM64_INS_NOP:\n\t\top->type = R_ANAL_OP_TYPE_NOP;\n\t\top->cycles = 1;\n\t\tbreak;\n\tcase ARM64_INS_SUB:\n\t\tif (ISREG64(0) && REGID64(0) == ARM64_REG_SP) {\n\t\t\top->stackop = R_ANAL_STACK_INC;\n\t\t\tif (ISIMM64(1)) {\n\t\t\t\t//sub sp, 0x54\n\t\t\t\top->stackptr = IMM(1);\n\t\t\t} else if (ISIMM64(2) && ISREG64(1) && REGID64(1) == ARM64_REG_SP) {\n\t\t\t\t//sub sp, sp, 0x10\n\t\t\t\top->stackptr = IMM64(2);\n\t\t\t}\n\t\t\top->val = op->stackptr;\n\t\t} else {\n\t\t\top->stackop = R_ANAL_STACK_RESET;\n\t\t\top->stackptr = 0;\n\t\t}\n\t\top->cycles = 1;\n\t\t/* fallthru */\n\tcase ARM64_INS_MSUB:\n\t\top->type = R_ANAL_OP_TYPE_SUB;\n\t\tbreak;\n\tcase ARM64_INS_FDIV:\n\tcase ARM64_INS_SDIV:\n\tcase ARM64_INS_UDIV:\n\t\top->cycles = 4;\n\t\top->type = R_ANAL_OP_TYPE_DIV;\n\t\tbreak;\n\tcase ARM64_INS_MUL:\n\tcase ARM64_INS_SMULL:\n\tcase ARM64_INS_FMUL:\n\tcase ARM64_INS_UMULL:\n\t\t/* TODO: if next instruction is also a MUL, cycles are /=2 */\n\t\t/* also known as Register Indexing Addressing */\n\t\top->cycles = 4;\n\t\top->type = R_ANAL_OP_TYPE_MUL;\n\t\tbreak;\n\tcase ARM64_INS_ADD:\n\t\tif (ISREG64 (0) && REGID64 (0) == ARM64_REG_SP) {\n\t\t\top->stackop = R_ANAL_STACK_INC;\n\t\t\tif (ISIMM64 (1)) {\n\t\t\t\t//add sp, 0x54\n\t\t\t\top->stackptr = -IMM (1);\n\t\t\t} else if (ISIMM64 (2) && ISREG64 (1) && REGID64 (1) == ARM64_REG_SP) {\n\t\t\t\t//add sp, sp, 0x10\n\t\t\t\top->stackptr = -IMM64 (2);\n\t\t\t}\n\t\t\top->val = op->stackptr;\n\t\t} else {\n\t\t\top->stackop = R_ANAL_STACK_RESET;\n\t\t\top->stackptr = 0;\n\t\t}\n\t\top->cycles = 1;\n\t\t/* fallthru */\n\tcase ARM64_INS_ADC:\n\t//case ARM64_INS_ADCS:\n\tcase ARM64_INS_UMADDL:\n\tcase ARM64_INS_SMADDL:\n\tcase ARM64_INS_FMADD:\n\tcase ARM64_INS_MADD:\n\t\top->type = R_ANAL_OP_TYPE_ADD;\n\t\tbreak;\n\tcase ARM64_INS_CSEL:\n\tcase ARM64_INS_FCSEL:\n\tcase ARM64_INS_CSET:\n\tcase ARM64_INS_CINC:\n\t\top->type = R_ANAL_OP_TYPE_CMOV;\n\t\tbreak;\n\tcase ARM64_INS_MOV:\n\t\tif (REGID64(0) == ARM64_REG_SP) {\n\t\t\top->stackop = R_ANAL_STACK_RESET;\n\t\t\top->stackptr = 0;\n\t\t}\n\t\top->cycles = 1;\n\t\t/* fallthru */\n\tcase ARM64_INS_MOVI:\n\tcase ARM64_INS_MOVK:\n\tcase ARM64_INS_MOVN:\n\tcase ARM64_INS_SMOV:\n\tcase ARM64_INS_UMOV:\n\tcase ARM64_INS_FMOV:\n\tcase ARM64_INS_SBFX:\n\tcase ARM64_INS_UBFX:\n\tcase ARM64_INS_UBFM:\n\tcase ARM64_INS_SBFIZ:\n\tcase ARM64_INS_UBFIZ:\n\tcase ARM64_INS_BIC:\n\tcase ARM64_INS_BFI:\n\tcase ARM64_INS_BFXIL:\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\tif (ISIMM64 (1)) {\n\t\t\top->val = IMM64(1);\n\t\t}\n\t\tbreak;\n\tcase ARM64_INS_MRS:\n\tcase ARM64_INS_MSR:\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\top->family = R_ANAL_OP_FAMILY_PRIV;\n\t\tbreak;\n\tcase ARM64_INS_MOVZ:\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\top->ptr = 0LL;\n\t\top->ptrsize = 8;\n\t\top->val = IMM64(1);\n\t\tbreak;\n\tcase ARM64_INS_UXTB:\n\tcase ARM64_INS_SXTB:\n\t\top->type = R_ANAL_OP_TYPE_CAST;\n\t\top->ptr = 0LL;\n\t\top->ptrsize = 1;\n\t\tbreak;\n\tcase ARM64_INS_UXTH:\n\tcase ARM64_INS_SXTH:\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\top->ptr = 0LL;\n\t\top->ptrsize = 2;\n\t\tbreak;\n\tcase ARM64_INS_UXTW:\n\tcase ARM64_INS_SXTW:\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\top->ptr = 0LL;\n\t\top->ptrsize = 4;\n\t\tbreak;\n\tcase ARM64_INS_BRK:\n\tcase ARM64_INS_HLT:\n\t\top->type = R_ANAL_OP_TYPE_TRAP;\n\t\t// hlt stops the process, not skips some cycles like in x86\n\t\tbreak;\n\tcase ARM64_INS_DMB:\n\tcase ARM64_INS_DSB:\n\tcase ARM64_INS_ISB:\n\t\top->family = R_ANAL_OP_FAMILY_THREAD;\n\t\t// intentional fallthrough\n\tcase ARM64_INS_IC: // instruction cache invalidate\n\tcase ARM64_INS_DC: // data cache invalidate\n\t\top->type = R_ANAL_OP_TYPE_SYNC; // or cache\n\t\tbreak;\n\t//  XXX unimplemented instructions\n\tcase ARM64_INS_DUP:\n\tcase ARM64_INS_XTN:\n\tcase ARM64_INS_XTN2:\n\tcase ARM64_INS_REV64:\n\tcase ARM64_INS_EXT:\n\tcase ARM64_INS_INS:\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\tbreak;\n\tcase ARM64_INS_LSL:\n\t\top->cycles = 1;\n\t\t/* fallthru */\n\tcase ARM64_INS_SHL:\n\tcase ARM64_INS_USHLL:\n\t\top->type = R_ANAL_OP_TYPE_SHL;\n\t\tbreak;\n\tcase ARM64_INS_LSR:\n\t\top->cycles = 1;\n\t\top->type = R_ANAL_OP_TYPE_SHR;\n\t\tbreak;\n\tcase ARM64_INS_ASR:\n\t\top->cycles = 1;\n\t\top->type = R_ANAL_OP_TYPE_SAR;\n\t\tbreak;\n\tcase ARM64_INS_NEG:\n#if CS_API_MAJOR > 3\n\tcase ARM64_INS_NEGS:\n#endif\n\t\top->type = R_ANAL_OP_TYPE_NOT;\n\t\tbreak;\n\tcase ARM64_INS_FCMP:\n\tcase ARM64_INS_CCMP:\n\tcase ARM64_INS_CCMN:\n\tcase ARM64_INS_CMP:\n\tcase ARM64_INS_CMN:\n\tcase ARM64_INS_TST:\n\t\top->type = R_ANAL_OP_TYPE_CMP;\n\t\tbreak;\n\tcase ARM64_INS_ROR:\n\t\top->cycles = 1;\n\t\top->type = R_ANAL_OP_TYPE_ROR;\n\t\tbreak;\n\tcase ARM64_INS_AND:\n\t\top->type = R_ANAL_OP_TYPE_AND;\n\t\tbreak;\n\tcase ARM64_INS_ORR:\n\tcase ARM64_INS_ORN:\n\t\top->type = R_ANAL_OP_TYPE_OR;\n\t\tbreak;\n\tcase ARM64_INS_EOR:\n\tcase ARM64_INS_EON:\n\t\top->type = R_ANAL_OP_TYPE_XOR;\n\t\tbreak;\n\tcase ARM64_INS_STRB:\n\tcase ARM64_INS_STURB:\n\tcase ARM64_INS_STUR:\n\tcase ARM64_INS_STR:\n\tcase ARM64_INS_STP:\n\tcase ARM64_INS_STNP:\n\tcase ARM64_INS_STXR:\n\tcase ARM64_INS_STXRH:\n\tcase ARM64_INS_STLXR:\n\tcase ARM64_INS_STLXRH:\n\tcase ARM64_INS_STXRB:\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\tif (ISPREINDEX64 () && REGBASE64 (2) == ARM64_REG_SP) {\n\t\t\top->stackop = R_ANAL_STACK_INC;\n\t\t\top->stackptr = -MEMDISP64 (2);\n\t\t} else if (ISPOSTINDEX64 () && REGID64 (2) == ARM64_REG_SP) {\n\t\t\top->stackop = R_ANAL_STACK_INC;\n\t\t\top->stackptr = -IMM64 (3);\n\t\t} else if (ISPREINDEX64 () && REGBASE64 (1) == ARM64_REG_SP) {\n\t\t\top->stackop = R_ANAL_STACK_INC;\n\t\t\top->stackptr = -MEMDISP64 (1);\n\t\t} else if (ISPOSTINDEX64 () && REGID64 (1) == ARM64_REG_SP) {\n\t\t\top->stackop = R_ANAL_STACK_INC;\n\t\t\top->stackptr = -IMM64 (2);\n\t\t}\n\t\tbreak;\n\tcase ARM64_INS_LDUR:\n\tcase ARM64_INS_LDURB:\n\tcase ARM64_INS_LDRSW:\n\tcase ARM64_INS_LDRSB:\n\tcase ARM64_INS_LDRSH:\n\tcase ARM64_INS_LDR:\n\tcase ARM64_INS_LDURSW:\n\tcase ARM64_INS_LDP:\n\tcase ARM64_INS_LDNP:\n\tcase ARM64_INS_LDPSW:\n\tcase ARM64_INS_LDRH:\n\tcase ARM64_INS_LDRB:\n\t\tif (ISPREINDEX64 () && REGBASE64 (2) == ARM64_REG_SP) {\n\t\t\top->stackop = R_ANAL_STACK_INC;\n\t\t\top->stackptr = -MEMDISP64 (2);\n\t\t} else if (ISPOSTINDEX64 () && REGID64 (2) == ARM64_REG_SP) {\n\t\t\top->stackop = R_ANAL_STACK_INC;\n\t\t\top->stackptr = -IMM64 (3);\n\t\t} else if (ISPREINDEX64 () && REGBASE64 (1) == ARM64_REG_SP) {\n\t\t\top->stackop = R_ANAL_STACK_INC;\n\t\t\top->stackptr = -MEMDISP64 (1);\n\t\t} else if (ISPOSTINDEX64 () && REGID64 (1) == ARM64_REG_SP) {\n\t\t\top->stackop = R_ANAL_STACK_INC;\n\t\t\top->stackptr = -IMM64 (2);\n\t\t}\n\t\tif (REGID(0) == ARM_REG_PC) {\n\t\t\top->type = R_ANAL_OP_TYPE_UJMP;\n\t\t\tif (insn->detail->arm.cc != ARM_CC_AL) {\n\t\t\t\t//op->type = R_ANAL_OP_TYPE_MCJMP;\n\t\t\t\top->type = R_ANAL_OP_TYPE_UCJMP;\n\t\t\t}\n\t\t} else {\n\t\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\t}\n\t\tswitch (insn->id) {\n\t\tcase ARM64_INS_LDPSW:\n\t\tcase ARM64_INS_LDRSW:\n\t\tcase ARM64_INS_LDRSH:\n\t\tcase ARM64_INS_LDRSB:\n\t\t\top->sign = true;\n\t\t\tbreak;\n\t\t}\n\t\tif (REGBASE64(1) == ARM64_REG_X29) {\n\t\t\top->stackop = R_ANAL_STACK_GET;\n\t\t\top->stackptr = 0;\n\t\t\top->ptr = MEMDISP64(1);\n\t\t} else {\n\t\t\tif (ISIMM64(1)) {\n\t\t\t\top->type = R_ANAL_OP_TYPE_LEA;\n\t\t\t\top->ptr = IMM64(1);\n\t\t\t\top->refptr = 8;\n\t\t\t} else {\n\t\t\t\tint d = (int)MEMDISP64(1);\n\t\t\t\top->ptr = (d < 0)? -d: d;\n\t\t\t\top->refptr = 4;\n\t\t\t}\n\t\t}\n\t\tbreak;\n#if CS_API_MAJOR > 4\n\tcase ARM64_INS_BLRAA:\n\tcase ARM64_INS_BLRAAZ:\n\tcase ARM64_INS_BLRAB:\n\tcase ARM64_INS_BLRABZ:\n\t\top->family = R_ANAL_OP_FAMILY_SECURITY;\n\t\top->type = R_ANAL_OP_TYPE_RCALL;\n\t\tbreak;\n\tcase ARM64_INS_BRAA:\n\tcase ARM64_INS_BRAAZ:\n\tcase ARM64_INS_BRAB:\n\tcase ARM64_INS_BRABZ:\n\t\top->family = R_ANAL_OP_FAMILY_SECURITY;\n\t\top->type = R_ANAL_OP_TYPE_RJMP;\n\t\tbreak;\n\tcase ARM64_INS_LDRAA:\n\tcase ARM64_INS_LDRAB:\n\t\top->family = R_ANAL_OP_FAMILY_SECURITY;\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\tbreak;\n\tcase ARM64_INS_RETAA:\n\tcase ARM64_INS_RETAB:\n\tcase ARM64_INS_ERETAA:\n\tcase ARM64_INS_ERETAB:\n\t\top->family = R_ANAL_OP_FAMILY_SECURITY;\n\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\tbreak;\n#endif\n\tcase ARM64_INS_ERET:\n\t\top->family = R_ANAL_OP_FAMILY_PRIV;\n\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\tbreak;\n\tcase ARM64_INS_RET:\n\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\tbreak;\n\tcase ARM64_INS_BL: // bl 0x89480\n\t\top->type = R_ANAL_OP_TYPE_CALL;\n\t\top->jump = IMM64(0);\n\t\top->fail = addr + 4;\n\t\tbreak;\n\tcase ARM64_INS_BLR: // blr x0\n\t\top->type = R_ANAL_OP_TYPE_RCALL;\n\t\top->fail = addr + 4;\n\t\t//op->jump = IMM64(0);\n\t\tbreak;\n\tcase ARM64_INS_CBZ:\n\tcase ARM64_INS_CBNZ:\n\t\top->type = R_ANAL_OP_TYPE_CJMP;\n\t\top->jump = IMM64(1);\n\t\top->fail = addr+op->size;\n\t\tbreak;\n\tcase ARM64_INS_TBZ:\n\tcase ARM64_INS_TBNZ:\n\t\top->type = R_ANAL_OP_TYPE_CJMP;\n\t\top->jump = IMM64(2);\n\t\top->fail = addr+op->size;\n\t\tbreak;\n\tcase ARM64_INS_BR:\n\t\top->type = R_ANAL_OP_TYPE_UJMP; // RJMP ?\n\t\top->eob = true;\n\t\tbreak;\n\tcase ARM64_INS_B:\n\t\t// BX LR == RET\n\t\tif (insn->detail->arm64.operands[0].reg == ARM64_REG_LR) {\n\t\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\t} else if (insn->detail->arm64.cc) {\n\t\t\top->type = R_ANAL_OP_TYPE_CJMP;\n\t\t\top->jump = IMM64(0);\n\t\t\top->fail = addr + op->size;\n\t\t} else {\n\t\t\top->type = R_ANAL_OP_TYPE_JMP;\n\t\t\top->jump = IMM64(0);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tR_LOG_DEBUG (\"ARM64 analysis: Op type %d at 0x%\" PFMT64x \" not handled\\n\", insn->id, op->addr);\n\t\tbreak;\n\t}\n}\n\nstatic void anal_itblock(cs_insn *insn) {\n\tsize_t i, size =  r_str_nlen (insn->mnemonic, 5);\n\tht_uu_update (ht_itblock, insn->address,  size);\n\tfor (i = 1; i < size; i++) {\n\t\tswitch (insn->mnemonic[i]) {\n\t\tcase 0x74: //'t'\n\t\t\tht_uu_update (ht_it, insn->address + (i * insn->size), insn->detail->arm.cc);\n\t\t\tbreak;\n\t\tcase 0x65: //'e'\n\t\t\tht_uu_update (ht_it, insn->address + (i * insn->size), (insn->detail->arm.cc % 2)?\n\t\t\t\tinsn->detail->arm.cc + 1: insn->detail->arm.cc - 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void check_itblock(cs_insn *insn) {\n\tsize_t x;\n\tbool found;\n\tut64 itlen = ht_uu_find (ht_itblock, insn->address, &found);\n\tif (found) {\n\t\tfor (x = 1; x < itlen; x++) {\n\t\t\tht_uu_delete (ht_it, insn->address + (x*insn->size));\n\t\t}\n\t\tht_uu_delete (ht_itblock, insn->address);\n\t}\n}\n\nstatic void anop32(RAnal *a, csh handle, RAnalOp *op, cs_insn *insn, bool thumb, const ut8 *buf, int len) {\n\tconst ut64 addr = op->addr;\n\tconst int pcdelta = thumb? 4: 8;\n\tint i;\n\tbool found = 0;\n\tut64 itcond;\n\n\top->cond = cond_cs2r2 (insn->detail->arm.cc);\n\tif (op->cond == R_ANAL_COND_NV) {\n\t\top->type = R_ANAL_OP_TYPE_NOP;\n\t\treturn;\n\t}\n\top->cycles = 1;\n\t/* grab family */\n\tif (cs_insn_group (handle, insn, ARM_GRP_CRYPTO)) {\n\t\top->family = R_ANAL_OP_FAMILY_CRYPTO;\n\t} else if (cs_insn_group (handle, insn, ARM_GRP_CRC)) {\n\t\top->family = R_ANAL_OP_FAMILY_CRYPTO;\n#if CS_API_MAJOR >= 4\n\t} else if (cs_insn_group (handle, insn, ARM_GRP_PRIVILEGE)) {\n\t\top->family = R_ANAL_OP_FAMILY_PRIV;\n\t} else if (cs_insn_group (handle, insn, ARM_GRP_VIRTUALIZATION)) {\n\t\top->family = R_ANAL_OP_FAMILY_VIRT;\n#endif\n\t} else if (cs_insn_group (handle, insn, ARM_GRP_NEON)) {\n\t\top->family = R_ANAL_OP_FAMILY_MMX;\n\t} else if (cs_insn_group (handle, insn, ARM_GRP_FPARMV8)) {\n\t\top->family = R_ANAL_OP_FAMILY_FPU;\n\t} else if (cs_insn_group (handle, insn, ARM_GRP_THUMB2DSP)) {\n\t\top->family = R_ANAL_OP_FAMILY_MMX;\n\t} else {\n\t\top->family = R_ANAL_OP_FAMILY_CPU;\n\t}\n\n\tif (insn->id != ARM_INS_IT) {\n\t\tcheck_itblock (insn);\n\t}\n\n\tswitch (insn->id) {\n#if 0\n\nIf PC is specified for Rn, the value used is the address of the instruction plus 4.\n\nThese instructions cause a PC-relative forward branch using a table of single byte offsets (TBB) or halfword offsets (TBH). Rn provides a pointer to the table, and Rm supplies an index into the table. The branch length is twice the value of the byte (TBB) or the halfword (TBH) returned from the table. The target of the branch table must be in the same execution state.\n\njmp $$ + 4 + ( [delta] * 2 )\n\n#endif\n\tcase ARM_INS_TBH: // half word table\n\t\top->type = R_ANAL_OP_TYPE_UJMP;\n\t\top->cycles = 2;\n\t\top->ptrsize = 2;\n\t\top->ireg = r_str_getf (cs_reg_name (handle, INSOP (0).mem.index));\n\t\tbreak;\n\tcase ARM_INS_TBB: // byte jump table\n\t\top->type = R_ANAL_OP_TYPE_UJMP;\n\t\top->cycles = 2;\n\t\top->ptrsize = 1;\n\t\top->ireg = r_str_getf (cs_reg_name (handle, INSOP (0).mem.index));\n\t\tbreak;\n\tcase ARM_INS_PLD:\n\t\top->type = R_ANAL_OP_TYPE_LEA; // not really a lea, just a prefetch\n\t\tif (ISMEM (0)) {\n\t\t\tint regBase = REGBASE(0);\n\t\t\tint delta = MEMDISP(0);\n\t\t\tif (regBase == ARM_REG_PC) {\n\t\t\t\top->ptr = addr + 4 + delta;\n\t\t\t} else {\n\t\t\t\t// exotic pld\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_IT:\n\t\tanal_itblock (insn);\n\t\top->cycles = 2;\n\t\tbreak;\n\tcase ARM_INS_BKPT:\n\t\top->type = R_ANAL_OP_TYPE_TRAP;\n\t\top->cycles = 4;\n\t\tbreak;\n\tcase ARM_INS_NOP:\n\t\top->type = R_ANAL_OP_TYPE_NOP;\n\t\top->cycles = 1;\n\t\tbreak;\n\tcase ARM_INS_POP:\n\t\top->stackop = R_ANAL_STACK_INC;\n\t\top->stackptr = -4LL * insn->detail->arm.op_count;\n\t\t// fallthrough\n\tcase ARM_INS_FLDMDBX:\n\tcase ARM_INS_FLDMIAX:\n\tcase ARM_INS_LDMDA:\n\tcase ARM_INS_LDMDB:\n\tcase ARM_INS_LDMIB:\n\tcase ARM_INS_LDM:\n\t\top->type = R_ANAL_OP_TYPE_POP;\n\t\top->cycles = 2;\n\t\tfor (i = 0; i < insn->detail->arm.op_count; i++) {\n\t\t\tif (insn->detail->arm.operands[i].type == ARM_OP_REG &&\n\t\t\t\t\tinsn->detail->arm.operands[i].reg == ARM_REG_PC) {\n\t\t\t\tif (insn->detail->arm.cc == ARM_CC_AL) {\n\t\t\t\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\t\t\t} else {\n\t\t\t\t\top->type = R_ANAL_OP_TYPE_CRET;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_SUB:\n\t\tif (ISREG(0) && REGID(0) == ARM_REG_SP) {\n\t\t\t\top->stackop = R_ANAL_STACK_INC;\n\t\t\t\tif (ISIMM(1)) {\n\t\t\t\t\t//0x0000bf4e      95b0           sub sp, 0x54\n\t\t\t\t\top->stackptr = IMM(1);\n\t\t\t\t} else if ( ISIMM(2) && ISREG(1) && REGID(1) == ARM_REG_SP) {\n\t\t\t\t\t// 0x00008254    10d04de2     sub sp, sp, 0x10\n\t\t\t\t\top->stackptr = IMM(2);\n\t\t\t\t}\n\t\t\t\top->val = op->stackptr;\n\t\t}\n\t\top->cycles = 1;\n\t\t/* fall-thru */\n\tcase ARM_INS_SUBW:\n\tcase ARM_INS_SSUB8:\n\tcase ARM_INS_SSUB16:\n\t\top->type = R_ANAL_OP_TYPE_SUB;\n\t\tbreak;\n\tcase ARM_INS_ADD:\n\t\tif (ISREG (0) && REGID (0) == ARM_REG_SP) {\n\t\t\top->stackop = R_ANAL_STACK_INC;\n\t\t\tif (ISIMM (1)) {\n\t\t\t\t//add sp, 0x54\n\t\t\t\top->stackptr = -IMM (1);\n\t\t\t} else if (ISIMM (2) && ISREG (1) && REGID (1) == ARM_REG_SP) {\n\t\t\t\t//add sp, sp, 0x10\n\t\t\t\top->stackptr = -IMM (2);\n\t\t\t}\n\t\t\top->val = op->stackptr;\n\t\t}\n\tcase ARM_INS_ADC:\n\t\top->type = R_ANAL_OP_TYPE_ADD;\n\t\tif (REGID(0) == ARM_REG_PC) {\n\t\t\top->type = R_ANAL_OP_TYPE_UJMP;\n\t\t\tif (REGID(1) == ARM_REG_PC && insn->detail->arm.cc != ARM_CC_AL) {\n\t\t\t\t//op->type = R_ANAL_OP_TYPE_RCJMP;\n\t\t\t\top->type = R_ANAL_OP_TYPE_UCJMP;\n\t\t\t\top->fail = addr+op->size;\n\t\t\t\top->jump = ((addr & ~3LL) + (thumb? 4: 8) + MEMDISP(1)) & UT64_MAX;\n\t\t\t\top->ptr = (addr & ~3LL) + (thumb? 4: 8) + MEMDISP(1);\n\t\t\t\top->refptr = 4;\n\t\t\t\top->reg = r_str_getf (cs_reg_name (handle, INSOP (2).reg));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\top->cycles = 1;\n\t\tbreak;\n\t\t/* fall-thru */\n\tcase ARM_INS_ADDW:\n\tcase ARM_INS_SADD8:\n\tcase ARM_INS_SADD16:\n\t\top->type = R_ANAL_OP_TYPE_ADD;\n\t\tbreak;\n\tcase ARM_INS_SDIV:\n\tcase ARM_INS_UDIV:\n\t\top->cycles = 4;\n\t\t/* fall-thru */\n\tcase ARM_INS_VDIV:\n\t\top->type = R_ANAL_OP_TYPE_DIV;\n\t\tbreak;\n\tcase ARM_INS_MUL:\n\tcase ARM_INS_SMULL:\n\tcase ARM_INS_UMULL:\n\t\t/* TODO: if next instruction is also a MUL, cycles are /=2 */\n\t\t/* also known as Register Indexing Addressing */\n\t\top->cycles = 4;\n\t\t/* fall-thru */\n\tcase ARM_INS_VMUL:\n\t\top->type = R_ANAL_OP_TYPE_MUL;\n\t\tbreak;\n\tcase ARM_INS_TRAP:\n\t\top->type = R_ANAL_OP_TYPE_TRAP;\n\t\top->cycles = 2;\n\t\tbreak;\n\tcase ARM_INS_MOV:\n\t\tif (REGID(0) == ARM_REG_PC) {\n\t\t\tif (REGID(1) == ARM_REG_LR) {\n\t\t\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\t\t} else {\n\t\t\t\top->type = R_ANAL_OP_TYPE_UJMP;\n\t\t\t}\n\t\t}\n\t\tif (ISIMM(1)) {\n\t\t\top->val = IMM(1);\n\t\t}\n\t\t/* fall-thru */\n\tcase ARM_INS_MOVT:\n\tcase ARM_INS_MOVW:\n\tcase ARM_INS_VMOVL:\n\tcase ARM_INS_VMOVN:\n\tcase ARM_INS_VQMOVUN:\n\tcase ARM_INS_VQMOVN:\n\tcase ARM_INS_SBFX:\n\tcase ARM_INS_UBFX:\n\tcase ARM_INS_BIC:\n\tcase ARM_INS_BFI:\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\tbreak;\n\tcase ARM_INS_VMOV:\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\top->family = R_ANAL_OP_FAMILY_FPU;\n\t\top->cycles = 2;\n\t\tbreak;\n\tcase ARM_INS_UDF:\n\t\top->type = R_ANAL_OP_TYPE_TRAP;\n\t\top->cycles = 4;\n\t\tbreak;\n\tcase ARM_INS_SVC:\n\t\top->type = R_ANAL_OP_TYPE_SWI;\n\t\top->val = IMM(0);\n\t\tbreak;\n\tcase ARM_INS_ROR:\n\tcase ARM_INS_RRX:\n\t\top->cycles = 1;\n\t\top->type = R_ANAL_OP_TYPE_ROR;\n\t\tbreak;\n\tcase ARM_INS_AND:\n\t\top->type = R_ANAL_OP_TYPE_AND;\n\t\tbreak;\n\tcase ARM_INS_ORR:\n\tcase ARM_INS_ORN:\n\t\top->type = R_ANAL_OP_TYPE_OR;\n\t\tbreak;\n\tcase ARM_INS_EOR:\n\t\top->type = R_ANAL_OP_TYPE_XOR;\n\t\tbreak;\n\tcase ARM_INS_CMP:\n\tcase ARM_INS_CMN:\n\tcase ARM_INS_TST:\n\t\tif (ISIMM(1)) {\n\t\t\top->ptr = IMM(1);\n\t\t}\n\t\top->reg = r_str_getf (cs_reg_name (handle, INSOP (0).reg));\n\t\t/* fall-thru */\n\tcase ARM_INS_VCMP:\n\t\top->type = R_ANAL_OP_TYPE_CMP;\n\t\tbreak;\n\tcase ARM_INS_LSL:\n\t\top->cycles = 1;\n\t\top->type = R_ANAL_OP_TYPE_SHL;\n\t\tbreak;\n\tcase ARM_INS_LSR:\n\t\top->cycles = 1;\n\t\top->type = R_ANAL_OP_TYPE_SHR;\n\t\tbreak;\n\tcase ARM_INS_ASR:\n\t\top->cycles = 1;\n\t\top->type = R_ANAL_OP_TYPE_SAR;\n\t\tbreak;\n\tcase ARM_INS_PUSH:\n\t\top->stackop = R_ANAL_STACK_INC;\n\t\top->stackptr = 4LL * insn->detail->arm.op_count;\n\t\t// fallthrough\n\tcase ARM_INS_STM:\n\tcase ARM_INS_STMDA:\n\tcase ARM_INS_STMDB:\n\t\top->type = R_ANAL_OP_TYPE_PUSH;\n// 0x00008160    04202de5     str r2, [sp, -4]!\n// 0x000082a0    28000be5     str r0, [fp, -0x28]\n\t\tif (REGBASE(1) == ARM_REG_FP) {\n\t\t\top->stackop = R_ANAL_STACK_SET;\n\t\t\top->stackptr = 0;\n\t\t\top->ptr = MEMDISP(1);\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_STREX:\n\tcase ARM_INS_STREXB:\n\tcase ARM_INS_STREXD:\n\tcase ARM_INS_STREXH:\n\t\top->family = R_ANAL_OP_FAMILY_THREAD;\n\t\t/* fall-thru */\n\tcase ARM_INS_STR:\n\tcase ARM_INS_STRB:\n\tcase ARM_INS_STRD:\n\tcase ARM_INS_STRBT:\n\tcase ARM_INS_STRH:\n\tcase ARM_INS_STRHT:\n\tcase ARM_INS_STRT:\n\t\top->cycles = 4;\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\tif (REGBASE(1) == ARM_REG_FP) {\n\t\t\top->stackop = R_ANAL_STACK_SET;\n\t\t\top->stackptr = 0;\n\t\t\top->ptr = -MEMDISP(1);\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_SXTB:\n\tcase ARM_INS_SXTH:\n\t\top->cycles = 1;\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\tbreak;\n\tcase ARM_INS_LDREX:\n\tcase ARM_INS_LDREXB:\n\tcase ARM_INS_LDREXD:\n\tcase ARM_INS_LDREXH:\n\t\top->family = R_ANAL_OP_FAMILY_THREAD;\n\t\t/* fall-thru */\n\tcase ARM_INS_LDR:\n\tcase ARM_INS_LDRD:\n\tcase ARM_INS_LDRB:\n\tcase ARM_INS_LDRBT:\n\tcase ARM_INS_LDRH:\n\tcase ARM_INS_LDRHT:\n\tcase ARM_INS_LDRSB:\n\tcase ARM_INS_LDRSBT:\n\tcase ARM_INS_LDRSH:\n\tcase ARM_INS_LDRSHT:\n\tcase ARM_INS_LDRT:\n\t\top->cycles = 4;\n// 0x000082a8    28301be5     ldr r3, [fp, -0x28]\n\t\tif (REGID(0) == ARM_REG_PC) {\n\t\t\top->type = R_ANAL_OP_TYPE_UJMP;\n\t\t\tif (insn->detail->arm.cc != ARM_CC_AL) {\n\t\t\t\t//op->type = R_ANAL_OP_TYPE_MCJMP;\n\t\t\t\top->type = R_ANAL_OP_TYPE_UCJMP;\n\t\t\t}\n\t\t} else {\n\t\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\t}\n\t\tswitch (insn->id) {\n\t\tcase ARM_INS_LDRB:\n\t\t\top->ptrsize = 1;\n\t\t\tbreak;\n\t\tcase ARM_INS_LDRH:\n\t\tcase ARM_INS_LDRHT:\n\t\t\top->ptrsize = 2;\n\t\t\tbreak;\n\t\t}\n\t\tif (REGBASE(1) == ARM_REG_FP) {\n\t\t\top->stackop = R_ANAL_STACK_GET;\n\t\t\top->stackptr = 0;\n\t\t\top->ptr = -MEMDISP(1);\n\t\t} else if (REGBASE(1) == ARM_REG_PC) {\n\t\t\top->ptr = (addr & ~3LL) + (thumb? 4: 8) + MEMDISP(1);\n\t\t\top->refptr = 4;\n\t\t\tif (REGID(0) == ARM_REG_PC && insn->detail->arm.cc != ARM_CC_AL) {\n\t\t\t\t//op->type = R_ANAL_OP_TYPE_MCJMP;\n\t\t\t\top->type = R_ANAL_OP_TYPE_UCJMP;\n\t\t\t\top->fail = addr+op->size;\n\t\t\t\top->jump = ((addr & ~3LL) + (thumb? 4: 8) + MEMDISP(1)) & UT64_MAX;\n\t\t\t\top->ireg = r_str_getf (cs_reg_name (handle, INSOP (1).mem.index));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_MRS:\n\tcase ARM_INS_MSR:\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\top->family = R_ANAL_OP_FAMILY_PRIV;\n\t\tbreak;\n\tcase ARM_INS_BLX:\n\t\top->cycles = 4;\n\t\tif (ISREG(0)) {\n\t\t\t/* blx reg */\n\t\t\top->type = R_ANAL_OP_TYPE_RCALL;\n\t\t} else {\n\t\t\t/* blx label */\n\t\t\top->type = R_ANAL_OP_TYPE_CALL;\n\t\t\top->jump = IMM(0) & UT32_MAX;\n\t\t\top->fail = addr + op->size;\n\t\t\top->hint.new_bits = (a->bits == 32)? 16 : 32;\n\t\t\t//switch instruction set always with blx label\n\t\t\t// r_anal_hint_set_bits (a, op->jump, a->bits == 32? 16 : 32);\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_BL:\n\t\t/* bl label */\n\t\top->cycles = 4;\n\t\top->type = R_ANAL_OP_TYPE_CALL;\n\t\top->jump = IMM(0) & UT32_MAX;\n\t\top->fail = addr + op->size;\n\t\top->hint.new_bits = a->bits;\n\t\tbreak;\n\tcase ARM_INS_CBZ:\n\tcase ARM_INS_CBNZ:\n\t\top->cycles = 4;\n\t\top->type = R_ANAL_OP_TYPE_CJMP;\n\t\top->jump = IMM(1) & UT32_MAX;\n\t\top->fail = addr + op->size;\n\t\tif (op->jump == op->fail) {\n\t\t\top->type = R_ANAL_OP_TYPE_JMP;\n\t\t\top->fail = UT64_MAX;\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_B:\n\t\t/* b.cc label */\n\t\top->cycles = 4;\n\t\tif (insn->detail->arm.cc == ARM_CC_INVALID) {\n\t\t\top->type = R_ANAL_OP_TYPE_ILL;\n\t\t\top->fail = addr+op->size;\n\t\t} else if (insn->detail->arm.cc == ARM_CC_AL) {\n\t\t\top->type = R_ANAL_OP_TYPE_JMP;\n\t\t\top->fail = UT64_MAX;\n\t\t} else {\n\t\t\top->type = R_ANAL_OP_TYPE_CJMP;\n\t\t\top->fail = addr+op->size;\n\t\t}\n\t\top->jump = IMM(0) & UT32_MAX;\n\t\t// propagate bits to create correctly hints ranges\n\t\top->hint.new_bits = a->bits;\n\t\tbreak;\n\tcase ARM_INS_BX:\n\tcase ARM_INS_BXJ:\n\t\t/* bx reg */\n\t\top->cycles = 4;\n\t\tswitch (REGID(0)) {\n\t\tcase ARM_REG_LR:\n\t\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\t\tbreak;\n\t\tcase ARM_REG_IP:\n\t\t\top->type = R_ANAL_OP_TYPE_UJMP;\n\t\t\tbreak;\n\t\tcase ARM_REG_PC:\n\t\t\t// bx pc is well known without ESIL\n\t\t\top->type = R_ANAL_OP_TYPE_UJMP;\n\t\t\top->jump = (addr & ~3LL) + pcdelta;\n\t\t\top->hint.new_bits = 32;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\top->type = R_ANAL_OP_TYPE_UJMP;\n\t\t\top->eob = true;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_ADR:\n\t\top->cycles = 2;\n\t\top->type = R_ANAL_OP_TYPE_LEA;\n\t\t// Set the pointer address and align it\n\t\top->ptr = IMM(1) + addr + 4 - (addr%4);\n\t\top->refptr = 1;\n\t\tbreak;\n\tcase ARM_INS_UXTAB:\n\tcase ARM_INS_UXTAB16:\n\t\top->type = R_ANAL_OP_TYPE_ADD;\n\t\top->ptr = 0LL;\n\t\top->ptrsize = 1;\n\t\tbreak;\n\tcase ARM_INS_UXTAH:\n\t\top->type = R_ANAL_OP_TYPE_ADD;\n\t\top->ptr = 0LL;\n\t\top->ptrsize = 2;\n\t\tbreak;\n\tcase ARM_INS_UXTB:\n\tcase ARM_INS_UXTB16:\n\t\top->type = R_ANAL_OP_TYPE_CAST;\n\t\top->ptr = 0LL;\n\t\top->ptrsize = 1;\n\t\tbreak;\n\tcase ARM_INS_UXTH:\n\t\top->type = R_ANAL_OP_TYPE_CAST;\n\t\top->ptr = 0LL;\n\t\top->ptrsize = 2;\n\t\tbreak;\n\tdefault:\n\t\tR_LOG_DEBUG (\"ARM analysis: Op type %d at 0x%\" PFMT64x \" not handled\\n\", insn->id, op->addr);\n\t\tbreak;\n\t}\n\titcond = ht_uu_find (ht_it,  addr, &found);\n\tif (found) {\n\t\tinsn->detail->arm.cc = itcond;\n\t\tinsn->detail->arm.update_flags = 0;\n\t\top->mnemonic = r_str_newf (\"%s%s%s%s\",\n\t\t\tr_anal_optype_to_string (op->type),\n\t\t\tcc_name (itcond),\n\t\t\tinsn->op_str[0]?\" \":\"\",\n\t\t\tinsn->op_str);\n\t\top->cond = itcond;\n\t}\n}\n\nstatic bool is_valid(arm_reg reg) {\n\treturn reg != ARM_REG_INVALID;\n}\n\nstatic int parse_reg_name(RReg *reg, RRegItem **reg_base, RRegItem **reg_delta, csh handle, cs_insn *insn, int reg_num) {\n\tcs_arm_op armop = INSOP (reg_num);\n\tswitch (armop.type) {\n\tcase ARM_OP_REG:\n\t\t*reg_base = r_reg_get (reg, cs_reg_name (handle, armop.reg), R_REG_TYPE_ALL);\n\t\tbreak;\n\tcase ARM_OP_MEM:\n\t\tif (is_valid (armop.mem.base) && is_valid (armop.mem.index)) {\n\t\t\t*reg_base = r_reg_get (reg, cs_reg_name (handle, armop.mem.base), R_REG_TYPE_ALL);\n\t\t\t*reg_delta = r_reg_get (reg, cs_reg_name (handle, armop.mem.index), R_REG_TYPE_ALL);\n\t\t} else if (is_valid (armop.mem.base)) {\n\t\t\t*reg_base = r_reg_get (reg, cs_reg_name (handle, armop.mem.base), R_REG_TYPE_ALL);\n\t\t} else if (is_valid (armop.mem.index)) {\n\t\t\t*reg_base = r_reg_get (reg, cs_reg_name (handle, armop.mem.index), R_REG_TYPE_ALL);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic bool is_valid64(arm64_reg reg) {\n\treturn reg != ARM64_REG_INVALID;\n}\n\nstatic char *reg_list[] = {\n\t\"x0\", \"x1\", \"x2\", \"x3\", \"x4\",\n\t\"x5\", \"x6\", \"x7\", \"x8\", \"x9\",\n\t\"x10\", \"x11\", \"x12\", \"x13\", \"x14\",\n\t\"x15\", \"x16\", \"x17\", \"x18\", \"x19\",\n\t\"x20\", \"x21\", \"x22\", \"x23\", \"x24\",\n\t\"x25\", \"x26\", \"x27\", \"x28\", \"x29\",\n\t\"x30\"\n};\n\nstatic int parse_reg64_name(RReg *reg, RRegItem **reg_base, RRegItem **reg_delta, csh handle, cs_insn *insn, int reg_num) {\n\tcs_arm64_op armop = INSOP64 (reg_num);\n\tswitch (armop.type) {\n\tcase ARM64_OP_REG:\n\t\t*reg_base = r_reg_get (reg, cs_reg_name (handle, armop.reg), R_REG_TYPE_ALL);\n\t\tbreak;\n\tcase ARM64_OP_MEM:\n\t\tif (is_valid64 (armop.mem.base) && is_valid64 (armop.mem.index)) {\n\t\t\t*reg_base = r_reg_get (reg, cs_reg_name (handle, armop.mem.base), R_REG_TYPE_ALL);\n\t\t\t*reg_delta = r_reg_get (reg, cs_reg_name (handle, armop.mem.index), R_REG_TYPE_ALL);\n\t\t} else if (is_valid64 (armop.mem.base)) {\n\t\t\t*reg_base = r_reg_get (reg, cs_reg_name (handle, armop.mem.base), R_REG_TYPE_ALL);\n\t\t} else if (is_valid64 (armop.mem.index)) {\n\t\t\t*reg_base = r_reg_get (reg, cs_reg_name (handle, armop.mem.index), R_REG_TYPE_ALL);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (*reg_base && *(*reg_base)->name == 'w') {\n\t\t*reg_base = r_reg_get (reg, reg_list[atoi ((*reg_base)->name + 1)], R_REG_TYPE_ALL);\n\t}\n\treturn 0;\n}\n\nstatic void set_opdir(RAnalOp *op) {\n\tswitch (op->type & R_ANAL_OP_TYPE_MASK) {\n\tcase R_ANAL_OP_TYPE_LOAD:\n\t\top->direction = R_ANAL_OP_DIR_READ;\n\t\tbreak;\n\tcase R_ANAL_OP_TYPE_STORE:\n\t\top->direction = R_ANAL_OP_DIR_WRITE;\n\t\tbreak;\n\tcase R_ANAL_OP_TYPE_LEA:\n\t\top->direction = R_ANAL_OP_DIR_REF;\n\t\tbreak;\n\tcase R_ANAL_OP_TYPE_CALL:\n\tcase R_ANAL_OP_TYPE_JMP:\n\tcase R_ANAL_OP_TYPE_UJMP:\n\tcase R_ANAL_OP_TYPE_UCALL:\n\t\top->direction = R_ANAL_OP_DIR_EXEC;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void set_src_dst(RAnalValue *val, RReg *reg, csh *handle, cs_insn *insn, int x, int bits) {\n\tcs_arm_op armop = INSOP (x);\n\tcs_arm64_op arm64op = INSOP64 (x);\n\tif (bits == 64) {\n\t\tparse_reg64_name (reg, &val->reg, &val->regdelta, *handle, insn, x);\n\t} else {\n\t\tparse_reg_name (reg, &val->reg, &val->regdelta, *handle, insn, x);\n\t}\n\tif (bits == 64) {\n\t\tswitch (arm64op.type) {\n\t\tcase ARM64_OP_REG:\n\t\t\tbreak;\n\t\tcase ARM64_OP_MEM:\n\t\t\tval->delta = arm64op.mem.disp;\n\t\t\tbreak;\n\t\tcase ARM64_OP_IMM:\n\t\t\tval->imm = arm64op.imm;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (armop.type) {\n\t\tcase ARM_OP_REG:\n\t\t\tbreak;\n\t\tcase ARM_OP_MEM:\n\t\t\tval->mul = armop.mem.scale;\n\t\t\tval->delta = armop.mem.disp;\n\t\t\tbreak;\n\t\tcase ARM_OP_IMM:\n\t\t\tval->imm = armop.imm;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void create_src_dst(RAnalOp *op) {\n\top->src[0] = r_anal_value_new ();\n\top->src[1] = r_anal_value_new ();\n\top->src[2] = r_anal_value_new ();\n\top->dst = r_anal_value_new ();\n}\n\nstatic void op_fillval(RAnal *anal, RAnalOp *op, csh handle, cs_insn *insn, int bits) {\n\tcreate_src_dst (op);\n\tint i, j;\n\tint count = bits == 64 ? insn->detail->arm64.op_count : insn->detail->arm.op_count;\n\tswitch (op->type & R_ANAL_OP_TYPE_MASK) {\n\tcase R_ANAL_OP_TYPE_MOV:\n\tcase R_ANAL_OP_TYPE_CMP:\n\tcase R_ANAL_OP_TYPE_ADD:\n\tcase R_ANAL_OP_TYPE_SUB:\n\tcase R_ANAL_OP_TYPE_MUL:\n\tcase R_ANAL_OP_TYPE_DIV:\n\tcase R_ANAL_OP_TYPE_SHR:\n\tcase R_ANAL_OP_TYPE_SHL:\n\tcase R_ANAL_OP_TYPE_SAL:\n\tcase R_ANAL_OP_TYPE_SAR:\n\tcase R_ANAL_OP_TYPE_OR:\n\tcase R_ANAL_OP_TYPE_AND:\n\tcase R_ANAL_OP_TYPE_XOR:\n\tcase R_ANAL_OP_TYPE_NOR:\n\tcase R_ANAL_OP_TYPE_NOT:\n\tcase R_ANAL_OP_TYPE_LOAD:\n\tcase R_ANAL_OP_TYPE_LEA:\n\tcase R_ANAL_OP_TYPE_ROR:\n\tcase R_ANAL_OP_TYPE_ROL:\n\tcase R_ANAL_OP_TYPE_CAST:\n\t\tfor (i = 1; i < count; i++) {\n#if CS_API_MAJOR > 3\n\t\t\tif (bits == 64) {\n\t\t\t\tcs_arm64_op arm64op = INSOP64 (i);\n\t\t\t\tif (arm64op.access == CS_AC_WRITE) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcs_arm_op armop = INSOP (i);\n\n\t\t\t\tif (armop.access == CS_AC_WRITE) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tfor (j = 0; j < 3; j++, i++) {\n\t\t\tset_src_dst (op->src[j], anal->reg, &handle, insn, i, bits);\n\t\t}\n\t\tset_src_dst (op->dst, anal->reg, &handle, insn, 0, bits);\n\t\tbreak;\n\tcase R_ANAL_OP_TYPE_STORE:\n\t\tif (count > 2) {\n\t\t\tif (bits == 64) {\n\t\t\t\tcs_arm64_op arm64op = INSOP64 (count - 1);\n\t\t\t\tif (arm64op.type == ARM64_OP_IMM) {\n\t\t\t\t\tcount--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcs_arm_op armop = INSOP (count - 1);\n\t\t\t\tif (armop.type == ARM_OP_IMM) {\n\t\t\t\t\tcount--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tset_src_dst (op->dst, anal->reg, &handle, insn, --count, bits);\n\t\tfor (j = 0; j < 3 && j < count; j++) {\n\t\t\tset_src_dst (op->src[j], anal->reg, &handle, insn, j, bits);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif ((bits == 64) && HASMEMINDEX64 (1)) {\n\t\top->ireg = r_str_getf (cs_reg_name (handle, INSOP64 (1).mem.index));\n\t} else if (HASMEMINDEX (1)) {\n\t\top->ireg = r_str_getf (cs_reg_name (handle, INSOP (1).mem.index));\n\t\top->scale = INSOP (1).mem.scale;\n\t}\n}\n\nstatic int analop(RAnal *a, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAnalOpMask mask) {\n\tstatic csh handle = 0;\n\tstatic int omode = -1;\n\tstatic int obits = 32;\n\tcs_insn *insn = NULL;\n\tint mode = (a->bits==16)? CS_MODE_THUMB: CS_MODE_ARM;\n\tint n, ret;\n\tmode |= (a->big_endian)? CS_MODE_BIG_ENDIAN: CS_MODE_LITTLE_ENDIAN;\n\tif (a->cpu && strstr (a->cpu, \"cortex\")) {\n\t\tmode |= CS_MODE_MCLASS;\n\t}\n\n\tif (mode != omode || a->bits != obits) {\n\t\tcs_close (&handle);\n\t\thandle = 0; // unnecessary\n\t\tomode = mode;\n\t\tobits = a->bits;\n\t}\n\top->size = (a->bits==16)? 2: 4;\n\top->addr = addr;\n\tif (handle == 0) {\n\t\tret = (a->bits == 64)?\n\t\t\tcs_open (CS_ARCH_ARM64, mode, &handle):\n\t\t\tcs_open (CS_ARCH_ARM, mode, &handle);\n\t\tcs_option (handle, CS_OPT_DETAIL, CS_OPT_ON);\n\t\tif (ret != CS_ERR_OK) {\n\t\t\thandle = 0;\n\t\t\treturn -1;\n\t\t}\n\t}\n\tint haa = hackyArmAnal (a, op, buf, len);\n\tif (haa > 0) {\n\t\treturn haa;\n\t}\n\n\tn = cs_disasm (handle, (ut8*)buf, len, addr, 1, &insn);\n\tif (n < 1) {\n\t\top->type = R_ANAL_OP_TYPE_ILL;\n\t\tif (mask & R_ANAL_OP_MASK_DISASM) {\n\t\t\top->mnemonic = strdup (\"invalid\");\n\t\t}\n\t} else {\n\t\tif (mask & R_ANAL_OP_MASK_DISASM) {\n\t\t\top->mnemonic = r_str_newf (\"%s%s%s\",\n\t\t\t\tinsn->mnemonic,\n\t\t\t\tinsn->op_str[0]?\" \":\"\",\n\t\t\t\tinsn->op_str);\n\t\t}\n\t\t//bool thumb = cs_insn_group (handle, insn, ARM_GRP_THUMB);\n\t\tbool thumb = a->bits == 16;\n\t\top->size = insn->size;\n\t\top->id = insn->id;\n\t\tif (a->bits == 64) {\n\t\t\tanop64 (handle, op, insn);\n\t\t\tif (mask & R_ANAL_OP_MASK_OPEX) {\n\t\t\t\topex64 (&op->opex, handle, insn);\n\t\t\t}\n\t\t\tif (mask & R_ANAL_OP_MASK_ESIL) {\n\t\t\t\tanalop64_esil (a, op, addr, buf, len, &handle, insn);\n\t\t\t}\n\t\t} else {\n\t\t\tanop32 (a, handle, op, insn, thumb, (ut8*)buf, len);\n\t\t\tif (mask & R_ANAL_OP_MASK_OPEX) {\n\t\t\t\topex (&op->opex, handle, insn);\n\t\t\t}\n\t\t\tif (mask & R_ANAL_OP_MASK_ESIL) {\n\t\t\t\tanalop_esil (a, op, addr, buf, len, &handle, insn, thumb);\n\t\t\t}\n\t\t}\n\t\tset_opdir (op);\n\t\tif (mask & R_ANAL_OP_MASK_VAL) {\n\t\t\top_fillval (a, op, handle, insn, a->bits);\n\t\t}\n\t\tcs_free (insn, n);\n\t}\n//\tcs_close (&handle);\n\treturn op->size;\n}\n\n#include \"anal_arm_regprofile.inc\"\n\nstatic int archinfo(RAnal *anal, int q) {\n\tif (q == R_ANAL_ARCHINFO_DATA_ALIGN) {\n\t\treturn 4;\n\t}\n\tif (q == R_ANAL_ARCHINFO_ALIGN) {\n\t\tif (anal && anal->bits == 16) {\n\t\t\treturn 2;\n\t\t}\n\t\treturn 4;\n\t}\n\tif (q == R_ANAL_ARCHINFO_INV_OP_SIZE) {\n\t\treturn 4;\n\t}\n\tif (q == R_ANAL_ARCHINFO_MAX_OP_SIZE) {\n\t\treturn 4;\n\t}\n\tif (q == R_ANAL_ARCHINFO_MIN_OP_SIZE) {\n\t\tif (anal && anal->bits == 16) {\n\t\t\treturn 2;\n\t\t}\n\t\treturn 4;\n\t}\n\treturn 4; // XXX\n}\n\nstatic ut8 *anal_mask(RAnal *anal, int size, const ut8 *data, ut64 at) {\n\tRAnalOp *op = NULL;\n\tut8 *ret = NULL;\n\tint oplen, idx = 0, obits = anal->bits;\n\tRAnalHint *hint = NULL;\n\n\tif (!data) {\n\t\treturn NULL;\n\t}\n\n\top = r_anal_op_new ();\n\tret = malloc (size);\n\tmemset (ret, 0xff, size);\n\n\twhile (idx < size) {\n\t\thint = r_anal_hint_get (anal, at + idx);\n\t\tif (hint) {\n\t\t\tif (hint->bits != 0) {\n\t\t\t\tanal->bits = hint->bits;\n\t\t\t}\n\t\t\tfree (hint);\n\t\t}\n\n\t\tif ((oplen = analop (anal, op, at + idx, data + idx, size - idx, R_ANAL_OP_MASK_BASIC)) < 1) {\n\t\t\tbreak;\n\t\t}\n\t\tif (op->ptr != UT64_MAX || op->jump != UT64_MAX) {\n\t\t\tif ((oplen * 8) > size - idx) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut32 opcode = r_read_ble (data + idx, anal->big_endian, oplen * 8);\n\t\t\tswitch (oplen) {\n\t\t\tcase 2:\n\t\t\t\tmemcpy (ret + idx, \"\\xf0\\x00\", 2);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tif (anal->bits == 64) {\n\t\t\t\t\tswitch (op->id) {\n\t\t\t\t\tcase ARM64_INS_LDP:\n\t\t\t\t\tcase ARM64_INS_LDXP:\n\t\t\t\t\tcase ARM64_INS_LDXR:\n\t\t\t\t\tcase ARM64_INS_LDXRB:\n\t\t\t\t\tcase ARM64_INS_LDXRH:\n\t\t\t\t\tcase ARM64_INS_LDPSW:\n\t\t\t\t\tcase ARM64_INS_LDNP:\n\t\t\t\t\tcase ARM64_INS_LDTR:\n\t\t\t\t\tcase ARM64_INS_LDTRB:\n\t\t\t\t\tcase ARM64_INS_LDTRH:\n\t\t\t\t\tcase ARM64_INS_LDTRSB:\n\t\t\t\t\tcase ARM64_INS_LDTRSH:\n\t\t\t\t\tcase ARM64_INS_LDTRSW:\n\t\t\t\t\tcase ARM64_INS_LDUR:\n\t\t\t\t\tcase ARM64_INS_LDURB:\n\t\t\t\t\tcase ARM64_INS_LDURH:\n\t\t\t\t\tcase ARM64_INS_LDURSB:\n\t\t\t\t\tcase ARM64_INS_LDURSH:\n\t\t\t\t\tcase ARM64_INS_LDURSW:\n\t\t\t\t\tcase ARM64_INS_STP:\n\t\t\t\t\tcase ARM64_INS_STNP:\n\t\t\t\t\tcase ARM64_INS_STXR:\n\t\t\t\t\tcase ARM64_INS_STXRB:\n\t\t\t\t\tcase ARM64_INS_STXRH:\n\t\t\t\t\t\tr_write_ble (ret + idx, 0xffffffff, anal->big_endian, 32);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ARM64_INS_STRB:\n\t\t\t\t\tcase ARM64_INS_STURB:\n\t\t\t\t\tcase ARM64_INS_STURH:\n\t\t\t\t\tcase ARM64_INS_STUR:\n\t\t\t\t\tcase ARM64_INS_STR:\n\t\t\t\t\tcase ARM64_INS_STTR:\n\t\t\t\t\tcase ARM64_INS_STTRB:\n\t\t\t\t\tcase ARM64_INS_STRH:\n\t\t\t\t\tcase ARM64_INS_STTRH:\n\t\t\t\t\tcase ARM64_INS_LDR:\n\t\t\t\t\tcase ARM64_INS_LDRB:\n\t\t\t\t\tcase ARM64_INS_LDRH:\n\t\t\t\t\tcase ARM64_INS_LDRSB:\n\t\t\t\t\tcase ARM64_INS_LDRSW:\n\t\t\t\t\tcase ARM64_INS_LDRSH: {\n\t\t\t\t\t\tbool is_literal = (opcode & 0x38000000) == 0x18000000;\n\t\t\t\t\t\tif (is_literal) {\n\t\t\t\t\t\t\tr_write_ble (ret + idx, 0xff000000, anal->big_endian, 32);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_write_ble (ret + idx, 0xffffffff, anal->big_endian, 32);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase ARM64_INS_B:\n\t\t\t\t\tcase ARM64_INS_BL:\n\t\t\t\t\tcase ARM64_INS_CBZ:\n\t\t\t\t\tcase ARM64_INS_CBNZ:\n\t\t\t\t\t\tif (op->type == R_ANAL_OP_TYPE_CJMP) {\n\t\t\t\t\t\t\tr_write_ble (ret + idx, 0xff00001f, anal->big_endian, 32);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_write_ble (ret + idx, 0xfc000000, anal->big_endian, 32);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ARM64_INS_TBZ:\n\t\t\t\t\tcase ARM64_INS_TBNZ:\n\t\t\t\t\t\tr_write_ble (ret + idx, 0xfff8001f, anal->big_endian, 32);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ARM64_INS_ADR:\n\t\t\t\t\tcase ARM64_INS_ADRP:\n\t\t\t\t\t\tr_write_ble (ret + idx, 0xff00001f, anal->big_endian, 32);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tr_write_ble (ret + idx, 0xfff00000, anal->big_endian, 32);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tr_write_ble (ret + idx, 0xfff00000, anal->big_endian, 32);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tidx += oplen;\n\t}\n\n\tanal->bits = obits;\n\tr_anal_op_free (op);\n\n\treturn ret;\n}\n\nstatic RList *anal_preludes(RAnal *anal) {\n#define KW(d,ds,m,ms) r_list_append (l, r_search_keyword_new((const ut8*)d,ds,(const ut8*)m, ms, NULL))\n\tRList *l = r_list_newf ((RListFree)r_search_keyword_free);\n\tswitch (anal->bits) {\n\tcase 16:\n\t\tKW (\"\\x00\\xb5\", 2, \"\\x0f\\xff\", 2);\n\t\tKW (\"\\x08\\xb5\", 2, \"\\x0f\\xff\", 2);\n\t\tbreak;\n\tcase 32:\n\t\tKW(\"\\x00\\x00\\x2d\\xe9\", 4, \"\\x0f\\x0f\\xff\\xff\", 4);\n\t\tbreak;\n\tcase 64:\n\t\tKW (\"\\xf0\\x0f\\x00\\xf8\", 4, \"\\xf0\\x0f\\x00\\xff\", 4);\n\t\tKW (\"\\xf0\\x00\\x00\\xd1\", 4, \"\\xf0\\x00\\x00\\xff\", 4);\n\t\tKW (\"\\xf0\\x00\\x00\\xa9\", 4, \"\\xf0\\x00\\x00\\xff\", 4);\n\t\tKW (\"\\x7f\\x23\\x03\\xd5\\xff\", 5, NULL, 0);\n\t\tbreak;\n\tdefault:\n\t\tr_list_free (l);\n\t\tl = NULL;\n\t}\n\treturn l;\n}\n\nstatic int init(void* user) {\n\tif (!ht_it) {\n\t\tht_it = ht_uu_new0 ();\n\t}\n\tif (!ht_itblock) {\n\t\tht_itblock = ht_uu_new0 ();\n\t}\n\treturn 0;\n}\n\nstatic int fini(void* user) {\n\tht_uu_free (ht_itblock);\n\tht_uu_free (ht_it);\n\tht_itblock = NULL;\n\tht_it = NULL;\n\treturn 0;\n}\n\nRAnalPlugin r_anal_plugin_arm_cs = {\n\t.name = \"arm\",\n\t.desc = \"Capstone ARM analyzer\",\n\t.license = \"BSD\",\n\t.esil = true,\n\t.arch = \"arm\",\n\t.archinfo = archinfo,\n\t.get_reg_profile = get_reg_profile,\n\t.anal_mask = anal_mask,\n\t.preludes = anal_preludes,\n\t.bits = 16 | 32 | 64,\n\t.op = &analop,\n\t.init = &init,\n\t.fini = &fini,\n};\n\n#ifndef R2_PLUGIN_INCORE\nR_API RLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_ANAL,\n\t.data = &r_anal_plugin_arm_cs,\n\t.version = R2_VERSION\n};\n#endif\n"], "fixing_code": ["/* radare2 - LGPL - Copyright 2013-2022 - pancake */\n\n#include <r_anal.h>\n#include <r_lib.h>\n#include <ht_uu.h>\n#include <arm.h>\n#include <capstone.h>\n#include <arm.h>\n#include <r_util/r_assert.h>\n#include \"./anal_arm_hacks.inc\"\n\n/* arm64 */\n#define IMM64(x) (ut64)(insn->detail->arm64.operands[x].imm)\n#define INSOP64(x) insn->detail->arm64.operands[x]\n\n/* arm32 */\n#define REG(x) r_str_getf (cs_reg_name (*handle, insn->detail->arm.operands[x].reg))\n#define REG64(x) r_str_getf (cs_reg_name (*handle, insn->detail->arm64.operands[x].reg))\n#define REGID64(x) insn->detail->arm64.operands[x].reg\n#define REGID(x) insn->detail->arm.operands[x].reg\n#define IMM(x) (ut32)(insn->detail->arm.operands[x].imm)\n#define INSOP(x) insn->detail->arm.operands[x]\n#define MEMBASE(x) r_str_getf (cs_reg_name (*handle, insn->detail->arm.operands[x].mem.base))\n#define MEMBASE64(x) r_str_getf (cs_reg_name (*handle, insn->detail->arm64.operands[x].mem.base))\n#define REGBASE(x) insn->detail->arm.operands[x].mem.base\n#define REGBASE64(x) insn->detail->arm64.operands[x].mem.base\n// s/index/base|reg/\n#define MEMINDEX(x) r_str_getf (cs_reg_name (*handle, insn->detail->arm.operands[x].mem.index))\n#define HASMEMINDEX(x) (insn->detail->arm.operands[x].mem.index != ARM_REG_INVALID)\n#define MEMINDEX64(x) r_str_getf (cs_reg_name (*handle, insn->detail->arm64.operands[x].mem.index))\n#define HASMEMINDEX64(x) (insn->detail->arm64.operands[x].mem.index != ARM64_REG_INVALID)\n#define ISMEMINDEXSUB(x) insn->detail->arm.operands[x].subtracted\n#define MEMDISP(x) insn->detail->arm.operands[x].mem.disp\n#define MEMDISP64(x) (ut64)insn->detail->arm64.operands[x].mem.disp\n#define ISIMM(x) (insn->detail->arm.operands[x].type == ARM_OP_IMM)\n#define ISIMM64(x) (insn->detail->arm64.operands[x].type & (ARM64_OP_IMM | ARM64_OP_CIMM | ARM64_OP_FP))\n#define ISREG(x) (insn->detail->arm.operands[x].type == ARM_OP_REG)\n#define ISREG64(x) (insn->detail->arm64.operands[x].type == ARM64_OP_REG)\n#define ISMEM(x) (insn->detail->arm.operands[x].type == ARM_OP_MEM)\n#define ISMEM64(x) (insn->detail->arm64.operands[x].type == ARM64_OP_MEM)\n#define EXT64(x) decode_sign_ext (insn->detail->arm64.operands[x].ext)\n\n#if CS_API_MAJOR > 3\n#define LSHIFT(x) insn->detail->arm.operands[x].mem.lshift\n#define LSHIFT2(x) insn->detail->arm.operands[x].shift.value // Dangerous, returns value even if isn't LSL\n#define LSHIFT2_64(x) insn->detail->arm64.operands[x].shift.value\n#else\n#define LSHIFT(x) 0\n#define LSHIFT2(x) 0\n#define LSHIFT2_64(x) 0\n#endif\n#define OPCOUNT() insn->detail->arm.op_count\n#define OPCOUNT64() insn->detail->arm64.op_count\n#define ISSHIFTED(x) (insn->detail->arm.operands[x].shift.type != ARM_SFT_INVALID && insn->detail->arm.operands[x].shift.value != 0)\n#define ISSHIFTED64(x) (insn->detail->arm64.operands[x].shift.type != ARM64_SFT_INVALID && insn->detail->arm64.operands[x].shift.value != 0)\n#define SHIFTTYPE(x) insn->detail->arm.operands[x].shift.type\n#define SHIFTVALUE(x) insn->detail->arm.operands[x].shift.value\n\n#define ISWRITEBACK32() insn->detail->arm.writeback\n#define ISPREINDEX32() (((OPCOUNT () == 2) && (ISMEM (1)) && (ISWRITEBACK32 ())) || ((OPCOUNT () == 3) && (ISMEM (2)) && (ISWRITEBACK32 ())))\n#define ISPOSTINDEX32() (((OPCOUNT () == 3) && (ISIMM (2) || ISREG (2)) && (ISWRITEBACK32 ())) || ((OPCOUNT () == 4) && (ISIMM (3) || ISREG (3)) && (ISWRITEBACK32 ())))\n#define ISWRITEBACK64() (insn->detail->arm64.writeback == true)\n#define ISPREINDEX64() (((OPCOUNT64() == 2) && (ISMEM64(1)) && (ISWRITEBACK64())) || ((OPCOUNT64() == 3) && (ISMEM64(2)) && (ISWRITEBACK64())))\n#define ISPOSTINDEX64() (((OPCOUNT64() == 3) && (ISIMM64(2)) && (ISWRITEBACK64())) || ((OPCOUNT64() == 4) && (ISIMM64(3)) && (ISWRITEBACK64())))\n\nstatic R_TH_LOCAL HtUU *ht_itblock = NULL;\nstatic R_TH_LOCAL HtUU *ht_it = NULL;\n\n#define BITMASK_BY_WIDTH_COUNT 64\nstatic const ut64 bitmask_by_width[BITMASK_BY_WIDTH_COUNT] = {\n\t0x1, 0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f, 0xff, 0x1ff, 0x3ff, 0x7ff,\n\t0xfff, 0x1fff, 0x3fff, 0x7fff, 0xffff, 0x1ffff, 0x3ffff, 0x7ffff,\n\t0xfffff, 0x1fffff, 0x3fffff, 0x7fffff, 0xffffff, 0x1ffffffLL, 0x3ffffffLL,\n\t0x7ffffffLL, 0xfffffffLL, 0x1fffffffLL, 0x3fffffffLL, 0x7fffffffLL, 0xffffffffLL,\n\t0x1ffffffffLL, 0x3ffffffffLL, 0x7ffffffffLL, 0xfffffffffLL, 0x1fffffffffLL,\n\t0x3fffffffffLL, 0x7fffffffffLL, 0xffffffffffLL, 0x1ffffffffffLL, 0x3ffffffffffLL,\n\t0x7ffffffffffLL, 0xfffffffffffLL, 0x1fffffffffffLL, 0x3fffffffffffLL, 0x7fffffffffffLL,\n\t0xffffffffffffLL, 0x1ffffffffffffLL, 0x3ffffffffffffLL, 0x7ffffffffffffLL,\n\t0xfffffffffffffLL, 0x1fffffffffffffLL, 0x3fffffffffffffLL, 0x7fffffffffffffLL,\n\t0xffffffffffffffLL, 0x1ffffffffffffffLL, 0x3ffffffffffffffLL, 0x7ffffffffffffffLL,\n\t0xfffffffffffffffLL, 0x1fffffffffffffffLL, 0x3fffffffffffffffLL, 0x7fffffffffffffffLL, 0xffffffffffffffffLL\n};\n\nstatic const char *shift_type_name(arm_shifter type) {\n\tswitch (type) {\n\tcase ARM_SFT_ASR:\n\t\treturn \"asr\";\n\tcase ARM_SFT_LSL:\n\t\treturn \"lsl\";\n\tcase ARM_SFT_LSR:\n\t\treturn \"lsr\";\n\tcase ARM_SFT_ROR:\n\t\treturn \"ror\";\n\tcase ARM_SFT_RRX:\n\t\treturn \"rrx\";\n\tcase ARM_SFT_ASR_REG:\n\t\treturn \"asr_reg\";\n\tcase ARM_SFT_LSL_REG:\n\t\treturn \"lsl_reg\";\n\tcase ARM_SFT_LSR_REG:\n\t\treturn \"lsr_reg\";\n\tcase ARM_SFT_ROR_REG:\n\t\treturn \"ror_reg\";\n\tcase ARM_SFT_RRX_REG:\n\t\treturn \"rrx_reg\";\n\tdefault:\n\t\treturn \"\";\n\t}\n}\n\nstatic const char *vector_data_type_name(arm_vectordata_type type) {\n\tswitch (type) {\n\tcase ARM_VECTORDATA_I8:\n\t\treturn \"i8\";\n\tcase ARM_VECTORDATA_I16:\n\t\treturn \"i16\";\n\tcase ARM_VECTORDATA_I32:\n\t\treturn \"i32\";\n\tcase ARM_VECTORDATA_I64:\n\t\treturn \"i64\";\n\tcase ARM_VECTORDATA_S8:\n\t\treturn \"s8\";\n\tcase ARM_VECTORDATA_S16:\n\t\treturn \"s16\";\n\tcase ARM_VECTORDATA_S32:\n\t\treturn \"s32\";\n\tcase ARM_VECTORDATA_S64:\n\t\treturn \"s64\";\n\tcase ARM_VECTORDATA_U8:\n\t\treturn \"u8\";\n\tcase ARM_VECTORDATA_U16:\n\t\treturn \"u16\";\n\tcase ARM_VECTORDATA_U32:\n\t\treturn \"u32\";\n\tcase ARM_VECTORDATA_U64:\n\t\treturn \"u64\";\n\tcase ARM_VECTORDATA_P8:\n\t\treturn \"p8\";\n\tcase ARM_VECTORDATA_F32:\n\t\treturn \"f32\";\n\tcase ARM_VECTORDATA_F64:\n\t\treturn \"f64\";\n\tcase ARM_VECTORDATA_F16F64:\n\t\treturn \"f16.f64\";\n\tcase ARM_VECTORDATA_F64F16:\n\t\treturn \"f64.f16\";\n\tcase ARM_VECTORDATA_F32F16:\n\t\treturn \"f32.f16\";\n\tcase ARM_VECTORDATA_F16F32:\n\t\treturn \"f16.f32\";\n\tcase ARM_VECTORDATA_F64F32:\n\t\treturn \"f64.f32\";\n\tcase ARM_VECTORDATA_F32F64:\n\t\treturn \"f32.f64\";\n\tcase ARM_VECTORDATA_S32F32:\n\t\treturn \"s32.f32\";\n\tcase ARM_VECTORDATA_U32F32:\n\t\treturn \"u32.f32\";\n\tcase ARM_VECTORDATA_F32S32:\n\t\treturn \"f32.s32\";\n\tcase ARM_VECTORDATA_F32U32:\n\t\treturn \"f32.u32\";\n\tcase ARM_VECTORDATA_F64S16:\n\t\treturn \"f64.s16\";\n\tcase ARM_VECTORDATA_F32S16:\n\t\treturn \"f32.s16\";\n\tcase ARM_VECTORDATA_F64S32:\n\t\treturn \"f64.s32\";\n\tcase ARM_VECTORDATA_S16F64:\n\t\treturn \"s16.f64\";\n\tcase ARM_VECTORDATA_S16F32:\n\t\treturn \"s16.f64\";\n\tcase ARM_VECTORDATA_S32F64:\n\t\treturn \"s32.f64\";\n\tcase ARM_VECTORDATA_U16F64:\n\t\treturn \"u16.f64\";\n\tcase ARM_VECTORDATA_U16F32:\n\t\treturn \"u16.f32\";\n\tcase ARM_VECTORDATA_U32F64:\n\t\treturn \"u32.f64\";\n\tcase ARM_VECTORDATA_F64U16:\n\t\treturn \"f64.u16\";\n\tcase ARM_VECTORDATA_F32U16:\n\t\treturn \"f32.u16\";\n\tcase ARM_VECTORDATA_F64U32:\n\t\treturn \"f64.u32\";\n\tdefault:\n\t\treturn \"\";\n\t}\n}\n\nstatic const char *cc_name(arm_cc cc) {\n\tswitch (cc) {\n\tcase ARM_CC_EQ: // Equal                      Equal\n\t\treturn \"eq\";\n\tcase ARM_CC_NE: // Not equal                  Not equal, or unordered\n\t\treturn \"ne\";\n\tcase ARM_CC_HS: // Carry set                  >, ==, or unordered\n\t\treturn \"hs\";\n\tcase ARM_CC_LO: // Carry clear                Less than\n\t\treturn \"lo\";\n\tcase ARM_CC_MI: // Minus, negative            Less than\n\t\treturn \"mi\";\n\tcase ARM_CC_PL: // Plus, positive or zero     >, ==, or unordered\n\t\treturn \"pl\";\n\tcase ARM_CC_VS: // Overflow                   Unordered\n\t\treturn \"vs\";\n\tcase ARM_CC_VC: // No overflow                Not unordered\n\t\treturn \"vc\";\n\tcase ARM_CC_HI: // Unsigned higher            Greater than, or unordered\n\t\treturn \"hi\";\n\tcase ARM_CC_LS: // Unsigned lower or same     Less than or equal\n\t\treturn \"ls\";\n\tcase ARM_CC_GE: // Greater than or equal      Greater than or equal\n\t\treturn \"ge\";\n\tcase ARM_CC_LT: // Less than                  Less than, or unordered\n\t\treturn \"lt\";\n\tcase ARM_CC_GT: // Greater than               Greater than\n\t\treturn \"gt\";\n\tcase ARM_CC_LE: // Less than or equal         <, ==, or unordered\n\t\treturn \"le\";\n\tdefault:\n\t\treturn \"\";\n\t}\n}\n\nstatic void opex(RStrBuf *buf, csh handle, cs_insn *insn) {\n\tint i;\n\tPJ *pj = pj_new ();\n\tif (!pj) {\n\t\treturn;\n\t}\n\tpj_o (pj);\n\tpj_ka (pj, \"operands\");\n\tcs_arm *x = &insn->detail->arm;\n\tfor (i = 0; i < x->op_count; i++) {\n\t\tcs_arm_op *op = x->operands + i;\n\t\tpj_o (pj);\n\t\tswitch (op->type) {\n\t\tcase ARM_OP_REG:\n\t\t\tpj_ks (pj, \"type\", \"reg\");\n\t\t\tpj_ks (pj, \"value\", cs_reg_name (handle, op->reg));\n\t\t\tbreak;\n\t\tcase ARM_OP_IMM:\n\t\t\tpj_ks (pj, \"type\", \"imm\");\n\t\t\tpj_ki (pj, \"value\", op->imm);\n\t\t\tbreak;\n\t\tcase ARM_OP_MEM:\n\t\t\tpj_ks (pj, \"type\", \"mem\");\n\t\t\tif (op->mem.base != ARM_REG_INVALID) {\n\t\t\t\tpj_ks (pj, \"base\", cs_reg_name (handle, op->mem.base));\n\t\t\t}\n\t\t\tif (op->mem.index != ARM_REG_INVALID) {\n\t\t\t\tpj_ks (pj, \"index\", cs_reg_name (handle, op->mem.index));\n\t\t\t}\n\t\t\tpj_ki (pj, \"scale\", op->mem.scale);\n\t\t\tpj_ki (pj, \"disp\", op->mem.disp);\n\t\t\tbreak;\n\t\tcase ARM_OP_FP:\n\t\t\tpj_ks (pj, \"type\", \"fp\");\n\t\t\tpj_kd (pj, \"value\", op->fp);\n\t\t\tbreak;\n\t\tcase ARM_OP_CIMM:\n\t\t\tpj_ks (pj, \"type\", \"cimm\");\n\t\t\tpj_ki (pj, \"value\", op->imm);\n\t\t\tbreak;\n\t\tcase ARM_OP_PIMM:\n\t\t\tpj_ks (pj, \"type\", \"pimm\");\n\t\t\tpj_ki (pj, \"value\", op->imm);\n\t\t\tbreak;\n\t\tcase ARM_OP_SETEND:\n\t\t\tpj_ks (pj, \"type\", \"setend\");\n\t\t\tswitch (op->setend) {\n\t\t\tcase ARM_SETEND_BE:\n\t\t\t\tpj_ks (pj, \"value\", \"be\");\n\t\t\t\tbreak;\n\t\t\tcase ARM_SETEND_LE:\n\t\t\t\tpj_ks (pj, \"value\", \"le\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpj_ks (pj, \"value\", \"invalid\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ARM_OP_SYSREG:\n\t\t\tpj_ks (pj, \"type\", \"sysreg\");\n\t\t\tpj_ks (pj, \"value\", r_str_get_fail (cs_reg_name (handle, op->reg), \"\"));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpj_ks (pj, \"type\", \"invalid\");\n\t\t\tbreak;\n\t\t}\n\t\tif (op->shift.type != ARM_SFT_INVALID) {\n\t\t\tpj_ko (pj, \"shift\");\n\t\t\tswitch (op->shift.type) {\n\t\t\tcase ARM_SFT_ASR:\n\t\t\tcase ARM_SFT_LSL:\n\t\t\tcase ARM_SFT_LSR:\n\t\t\tcase ARM_SFT_ROR:\n\t\t\tcase ARM_SFT_RRX:\n\t\t\t\tpj_ks (pj, \"type\", shift_type_name (op->shift.type));\n\t\t\t\tpj_kn (pj, \"value\", (ut64)op->shift.value);\n\t\t\t\tbreak;\n\t\t\tcase ARM_SFT_ASR_REG:\n\t\t\tcase ARM_SFT_LSL_REG:\n\t\t\tcase ARM_SFT_LSR_REG:\n\t\t\tcase ARM_SFT_ROR_REG:\n\t\t\tcase ARM_SFT_RRX_REG:\n\t\t\t\tpj_ks (pj, \"type\", shift_type_name (op->shift.type));\n\t\t\t\tpj_ks (pj, \"value\", cs_reg_name (handle, op->shift.value));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpj_end (pj); /* o shift */\n\t\t}\n\t\tif (op->vector_index != -1) {\n\t\t\tpj_ki (pj, \"vector_index\", op->vector_index);\n\t\t}\n\t\tif (op->subtracted) {\n\t\t\tpj_kb (pj, \"subtracted\", true);\n\t\t}\n\t\tpj_end (pj); /* o operand */\n\t}\n\tpj_end (pj); /* a operands */\n\tif (x->usermode) {\n\t\tpj_kb (pj, \"usermode\", true);\n\t}\n\tif (x->update_flags) {\n\t\tpj_kb (pj, \"update_flags\", true);\n\t}\n\tif (x->writeback) {\n\t\tpj_kb (pj, \"writeback\", true);\n\t}\n\tif (x->vector_size) {\n\t\tpj_ki (pj, \"vector_size\", x->vector_size);\n\t}\n\tif (x->vector_data != ARM_VECTORDATA_INVALID) {\n\t\tpj_ks (pj, \"vector_data\", vector_data_type_name (x->vector_data));\n\t}\n\tif (x->cps_mode != ARM_CPSMODE_INVALID) {\n\t\tpj_ki (pj, \"cps_mode\", x->cps_mode);\n\t}\n\tif (x->cps_flag != ARM_CPSFLAG_INVALID) {\n\t\tpj_ki (pj, \"cps_flag\", x->cps_flag);\n\t}\n\tif (x->cc != ARM_CC_INVALID && x->cc != ARM_CC_AL) {\n\t\tpj_ks (pj, \"cc\", cc_name (x->cc));\n\t}\n\tif (x->mem_barrier != ARM_MB_INVALID) {\n\t\tpj_ki (pj, \"mem_barrier\", x->mem_barrier - 1);\n\t}\n\tpj_end (pj);\n\n\tr_strbuf_init (buf);\n\tr_strbuf_append (buf, pj_string (pj));\n\tpj_free (pj);\n}\n\nstatic int arm64_reg_width(int reg) {\n\tswitch (reg) {\n\tcase ARM64_REG_W0:\n\tcase ARM64_REG_W1:\n\tcase ARM64_REG_W2:\n\tcase ARM64_REG_W3:\n\tcase ARM64_REG_W4:\n\tcase ARM64_REG_W5:\n\tcase ARM64_REG_W6:\n\tcase ARM64_REG_W7:\n\tcase ARM64_REG_W8:\n\tcase ARM64_REG_W9:\n\tcase ARM64_REG_W10:\n\tcase ARM64_REG_W11:\n\tcase ARM64_REG_W12:\n\tcase ARM64_REG_W13:\n\tcase ARM64_REG_W14:\n\tcase ARM64_REG_W15:\n\tcase ARM64_REG_W16:\n\tcase ARM64_REG_W17:\n\tcase ARM64_REG_W18:\n\tcase ARM64_REG_W19:\n\tcase ARM64_REG_W20:\n\tcase ARM64_REG_W21:\n\tcase ARM64_REG_W22:\n\tcase ARM64_REG_W23:\n\tcase ARM64_REG_W24:\n\tcase ARM64_REG_W25:\n\tcase ARM64_REG_W26:\n\tcase ARM64_REG_W27:\n\tcase ARM64_REG_W28:\n\tcase ARM64_REG_W29:\n\tcase ARM64_REG_W30:\n\tcase ARM64_REG_S0:\n\tcase ARM64_REG_S1:\n\tcase ARM64_REG_S2:\n\tcase ARM64_REG_S3:\n\tcase ARM64_REG_S4:\n\tcase ARM64_REG_S5:\n\tcase ARM64_REG_S6:\n\tcase ARM64_REG_S7:\n\tcase ARM64_REG_S8:\n\tcase ARM64_REG_S9:\n\tcase ARM64_REG_S10:\n\tcase ARM64_REG_S11:\n\tcase ARM64_REG_S12:\n\tcase ARM64_REG_S13:\n\tcase ARM64_REG_S14:\n\tcase ARM64_REG_S15:\n\tcase ARM64_REG_S16:\n\tcase ARM64_REG_S17:\n\tcase ARM64_REG_S18:\n\tcase ARM64_REG_S19:\n\tcase ARM64_REG_S20:\n\tcase ARM64_REG_S21:\n\tcase ARM64_REG_S22:\n\tcase ARM64_REG_S23:\n\tcase ARM64_REG_S24:\n\tcase ARM64_REG_S25:\n\tcase ARM64_REG_S26:\n\tcase ARM64_REG_S27:\n\tcase ARM64_REG_S28:\n\tcase ARM64_REG_S29:\n\tcase ARM64_REG_S30:\n\tcase ARM64_REG_S31:\n\t\treturn 32;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 64;\n}\n\nstatic const char *cc_name64(arm64_cc cc) {\n\tswitch (cc) {\n\tcase ARM64_CC_EQ: // Equal\n\t\treturn \"eq\";\n\tcase ARM64_CC_NE: // Not equal:                 Not equal, or unordered\n\t\treturn \"ne\";\n\tcase ARM64_CC_HS: // Unsigned higher or same:   >, ==, or unordered\n\t\treturn \"hs\";\n\tcase ARM64_CC_LO: // Unsigned lower or same:    Less than\n\t\treturn \"lo\";\n\tcase ARM64_CC_MI: // Minus, negative:           Less than\n\t\treturn \"mi\";\n\tcase ARM64_CC_PL: // Plus, positive or zero:    >, ==, or unordered\n\t\treturn \"pl\";\n\tcase ARM64_CC_VS: // Overflow:                  Unordered\n\t\treturn \"vs\";\n\tcase ARM64_CC_VC: // No overflow:               Ordered\n\t\treturn \"vc\";\n\tcase ARM64_CC_HI: // Unsigned higher:           Greater than, or unordered\n\t\treturn \"hi\";\n\tcase ARM64_CC_LS: // Unsigned lower or same:    Less than or equal\n\t\treturn \"ls\";\n\tcase ARM64_CC_GE: // Greater than or equal:     Greater than or equal\n\t\treturn \"ge\";\n\tcase ARM64_CC_LT: // Less than:                 Less than, or unordered\n\t\treturn \"lt\";\n\tcase ARM64_CC_GT: // Signed greater than:       Greater than\n\t\treturn \"gt\";\n\tcase ARM64_CC_LE: // Signed less than or equal: <, ==, or unordered\n\t\treturn \"le\";\n\tdefault:\n\t\treturn \"\";\n\t}\n}\n\nstatic const char *extender_name(arm64_extender extender) {\n\tswitch (extender) {\n\tcase ARM64_EXT_UXTB:\n\t\treturn \"uxtb\";\n\tcase ARM64_EXT_UXTH:\n\t\treturn \"uxth\";\n\tcase ARM64_EXT_UXTW:\n\t\treturn \"uxtw\";\n\tcase ARM64_EXT_UXTX:\n\t\treturn \"uxtx\";\n\tcase ARM64_EXT_SXTB:\n\t\treturn \"sxtb\";\n\tcase ARM64_EXT_SXTH:\n\t\treturn \"sxth\";\n\tcase ARM64_EXT_SXTW:\n\t\treturn \"sxtw\";\n\tcase ARM64_EXT_SXTX:\n\t\treturn \"sxtx\";\n\tdefault:\n\t\treturn \"\";\n\t}\n}\n\nstatic const char *vas_name(arm64_vas vas) {\n\tswitch (vas) {\n\tcase ARM64_VAS_8B:\n\t\treturn \"8b\";\n\tcase ARM64_VAS_16B:\n\t\treturn \"16b\";\n\tcase ARM64_VAS_4H:\n\t\treturn \"4h\";\n\tcase ARM64_VAS_8H:\n\t\treturn \"8h\";\n\tcase ARM64_VAS_2S:\n\t\treturn \"2s\";\n\tcase ARM64_VAS_4S:\n\t\treturn \"4s\";\n\tcase ARM64_VAS_2D:\n\t\treturn \"2d\";\n\tcase ARM64_VAS_1D:\n\t\treturn \"1d\";\n\tcase ARM64_VAS_1Q:\n\t\treturn \"1q\";\n#if CS_API_MAJOR > 4\n\tcase ARM64_VAS_1B:\n\t\treturn \"8b\";\n\tcase ARM64_VAS_4B:\n\t\treturn \"8b\";\n\tcase ARM64_VAS_2H:\n\t\treturn \"2h\";\n\tcase ARM64_VAS_1H:\n\t\treturn \"1h\";\n\tcase ARM64_VAS_1S:\n\t\treturn \"1s\";\n#endif\n\tdefault:\n\t\treturn \"\";\n\t}\n}\n\nstatic int vas_size(arm64_vas vas) {\n\tswitch (vas) {\n\tcase ARM64_VAS_8B:\n\tcase ARM64_VAS_16B:\n\t\treturn 8;\n\tcase ARM64_VAS_4H:\n\tcase ARM64_VAS_8H:\n\t\treturn 16;\n\tcase ARM64_VAS_2S:\n\tcase ARM64_VAS_4S:\n\t\treturn 32;\n\tcase ARM64_VAS_2D:\n\tcase ARM64_VAS_1D:\n\t\treturn 64;\n\tcase ARM64_VAS_1Q:\n\t\treturn 128;\n#if CS_API_MAJOR > 4\n\tcase ARM64_VAS_1B:\n\tcase ARM64_VAS_4B:\n\t\treturn 8;\n\tcase ARM64_VAS_2H:\n\tcase ARM64_VAS_1H:\n\t\treturn 16;\n\tcase ARM64_VAS_1S:\n\t\treturn 32;\n#endif\n\tdefault:\n\t\treturn 64;\n\t}\n}\n\nstatic int vas_count(arm64_vas vas) {\n\tswitch (vas) {\n\tcase ARM64_VAS_16B:\n\t\treturn 16;\n\tcase ARM64_VAS_8B:\n\tcase ARM64_VAS_8H:\n\t\treturn 8;\n\tcase ARM64_VAS_4S:\n\tcase ARM64_VAS_4H:\n\t\treturn 4;\n\tcase ARM64_VAS_2D:\n\tcase ARM64_VAS_2S:\n\t\treturn 2;\n\tcase ARM64_VAS_1D:\n\tcase ARM64_VAS_1Q:\n\t\treturn 1;\n#if CS_API_MAJOR > 4\n\tcase ARM64_VAS_4B:\n\t\treturn 4;\n\tcase ARM64_VAS_2H:\n\t\treturn 2;\n\tcase ARM64_VAS_1B:\n\tcase ARM64_VAS_1H:\n\tcase ARM64_VAS_1S:\n\t\treturn 1;\n#endif\n\tdefault:\n\t\treturn 64;\n\t}\n}\n\n#if CS_API_MAJOR == 4\nstatic const char *vess_name(arm64_vess vess) {\n\tswitch (vess) {\n\tcase ARM64_VESS_B:\n\t\treturn \"b\";\n\tcase ARM64_VESS_H:\n\t\treturn \"h\";\n\tcase ARM64_VESS_S:\n\t\treturn \"s\";\n\tcase ARM64_VESS_D:\n\t\treturn \"d\";\n\tdefault:\n\t\treturn \"\";\n\t}\n}\n#endif\n\n#if CS_API_MAJOR == 4\nstatic int vess_size(arm64_vess vess) {\n\tswitch (vess) {\n\tcase ARM64_VESS_B:\n\t\treturn 8;\n\tcase ARM64_VESS_H:\n\t\treturn 16;\n\tcase ARM64_VESS_S:\n\t\treturn 32;\n\tcase ARM64_VESS_D:\n\t\treturn 64;\n\tdefault:\n\t\treturn 64;\n\t}\n}\n#endif\n\nstatic void opex64(RStrBuf *buf, csh handle, cs_insn *insn) {\n\tint i;\n\tPJ *pj = pj_new ();\n\tif (!pj) {\n\t\treturn;\n\t}\n\tpj_o (pj);\n\tpj_ka (pj, \"operands\");\n\tcs_arm64 *x = &insn->detail->arm64;\n\tfor (i = 0; i < x->op_count; i++) {\n\t\tcs_arm64_op *op = x->operands + i;\n\t\tpj_o (pj);\n\t\tswitch (op->type) {\n\t\tcase ARM64_OP_REG:\n\t\t\t{\n\t\t\tpj_ks (pj, \"type\", \"reg\");\n\t\t\tconst char *rn = cs_reg_name (handle, op->reg);\n\t\t\tif (rn) {\n\t\t\t\tpj_ks (pj, \"value\", rn);\n\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ARM64_OP_REG_MRS:\n\t\t\tpj_ks (pj, \"type\", \"reg_mrs\");\n\t\t\t// TODO value\n\t\t\tbreak;\n\t\tcase ARM64_OP_REG_MSR:\n\t\t\tpj_ks (pj, \"type\", \"reg_msr\");\n\t\t\t// TODO value\n\t\t\tbreak;\n\t\tcase ARM64_OP_IMM:\n\t\t\tpj_ks (pj, \"type\", \"imm\");\n\t\t\tpj_kN (pj, \"value\", op->imm);\n\t\t\tbreak;\n\t\tcase ARM64_OP_MEM:\n\t\t\tpj_ks (pj, \"type\", \"mem\");\n\t\t\tif (op->mem.base != ARM64_REG_INVALID) {\n\t\t\t\tpj_ks (pj, \"base\", cs_reg_name (handle, op->mem.base));\n\t\t\t}\n\t\t\tif (op->mem.index != ARM64_REG_INVALID) {\n\t\t\t\tpj_ks (pj, \"index\", cs_reg_name (handle, op->mem.index));\n\t\t\t}\n\t\t\tpj_ki (pj, \"disp\", op->mem.disp);\n\t\t\tbreak;\n\t\tcase ARM64_OP_FP:\n\t\t\tpj_ks (pj, \"type\", \"fp\");\n\t\t\tpj_kd (pj, \"value\", op->fp);\n\t\t\tbreak;\n\t\tcase ARM64_OP_CIMM:\n\t\t\tpj_ks (pj, \"type\", \"cimm\");\n\t\t\tpj_kN (pj, \"value\", op->imm);\n\t\t\tbreak;\n\t\tcase ARM64_OP_PSTATE:\n\t\t\tpj_ks (pj, \"type\", \"pstate\");\n\t\t\tswitch (op->pstate) {\n\t\t\tcase ARM64_PSTATE_SPSEL:\n\t\t\t\tpj_ks (pj, \"value\", \"spsel\");\n\t\t\t\tbreak;\n\t\t\tcase ARM64_PSTATE_DAIFSET:\n\t\t\t\tpj_ks (pj, \"value\", \"daifset\");\n\t\t\t\tbreak;\n\t\t\tcase ARM64_PSTATE_DAIFCLR:\n\t\t\t\tpj_ks (pj, \"value\", \"daifclr\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tpj_ki (pj, \"value\", op->pstate);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ARM64_OP_SYS:\n\t\t\tpj_ks (pj, \"type\", \"sys\");\n\t\t\tpj_kn (pj, \"value\", (ut64)op->sys);\n\t\t\tbreak;\n\t\tcase ARM64_OP_PREFETCH:\n\t\t\tpj_ks (pj, \"type\", \"prefetch\");\n\t\t\tpj_ki (pj, \"value\", op->prefetch - 1);\n\t\t\tbreak;\n\t\tcase ARM64_OP_BARRIER:\n\t\t\tpj_ks (pj, \"type\", \"prefetch\");\n\t\t\tpj_ki (pj, \"value\", op->barrier - 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpj_ks (pj, \"type\", \"invalid\");\n\t\t\tbreak;\n\t\t}\n\t\tif (op->shift.type != ARM64_SFT_INVALID) {\n\t\t\tpj_ko (pj, \"shift\");\n\t\t\tswitch (op->shift.type) {\n\t\t\tcase ARM64_SFT_LSL:\n\t\t\t\tpj_ks (pj, \"type\", \"lsl\");\n\t\t\t\tbreak;\n\t\t\tcase ARM64_SFT_MSL:\n\t\t\t\tpj_ks (pj, \"type\", \"msl\");\n\t\t\t\tbreak;\n\t\t\tcase ARM64_SFT_LSR:\n\t\t\t\tpj_ks (pj, \"type\", \"lsr\");\n\t\t\t\tbreak;\n\t\t\tcase ARM64_SFT_ASR:\n\t\t\t\tpj_ks (pj, \"type\", \"asr\");\n\t\t\t\tbreak;\n\t\t\tcase ARM64_SFT_ROR:\n\t\t\t\tpj_ks (pj, \"type\", \"ror\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpj_kn (pj, \"value\", (ut64)op->shift.value);\n\t\t\tpj_end (pj);\n\t\t}\n\t\tif (op->ext != ARM64_EXT_INVALID) {\n\t\t\tpj_ks (pj, \"ext\", extender_name (op->ext));\n\t\t}\n\t\tif (op->vector_index != -1) {\n\t\t\tpj_ki (pj, \"vector_index\", op->vector_index);\n\t\t}\n\t\tif (op->vas != ARM64_VAS_INVALID) {\n\t\t\tpj_ks (pj, \"vas\", vas_name (op->vas));\n\t\t}\n#if CS_API_MAJOR == 4\n\t\tif (op->vess != ARM64_VESS_INVALID) {\n\t\t\tpj_ks (pj, \"vess\", vess_name (op->vess));\n\t\t}\n#endif\n\t\tpj_end (pj);\n\t}\n\tpj_end (pj);\n\tif (x->update_flags) {\n\t\tpj_kb (pj, \"update_flags\", true);\n\t}\n\tif (x->writeback) {\n\t\tpj_kb (pj, \"writeback\", true);\n\t}\n\tif (x->cc != ARM64_CC_INVALID && x->cc != ARM64_CC_AL && x->cc != ARM64_CC_NV) {\n\t\tpj_ks (pj, \"cc\", cc_name64 (x->cc));\n\t}\n\tpj_end (pj);\n\n\tr_strbuf_init (buf);\n\tr_strbuf_append (buf, pj_string (pj));\n\tpj_free (pj);\n}\n\nstatic int decode_sign_ext(arm64_extender extender) {\n\tswitch (extender) {\n\tcase ARM64_EXT_UXTB:\n\tcase ARM64_EXT_UXTH:\n\tcase ARM64_EXT_UXTW:\n\tcase ARM64_EXT_UXTX:\n\t\treturn 0; // nothing needs to be done for unsigned\n\tcase ARM64_EXT_SXTB:\n\t\treturn 8;\n\tcase ARM64_EXT_SXTH:\n\t\treturn 16;\n\tcase ARM64_EXT_SXTW:\n\t\treturn 32;\n\tcase ARM64_EXT_SXTX:\n\t\treturn 64;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic const char *decode_shift(arm_shifter shift) {\n\tstatic const char *E_OP_SR = \">>\";\n\tstatic const char *E_OP_SL = \"<<\";\n\tstatic const char *E_OP_RR = \">>>\";\n\tstatic const char *E_OP_ASR = \">>>>\";\n\tstatic const char *E_OP_VOID = \"\";\n\n\tswitch (shift) {\n\tcase ARM_SFT_ASR:\n\tcase ARM_SFT_ASR_REG:\n\t\treturn E_OP_ASR;\n\n\tcase ARM_SFT_LSR:\n\tcase ARM_SFT_LSR_REG:\n\t\treturn E_OP_SR;\n\n\tcase ARM_SFT_LSL:\n\tcase ARM_SFT_LSL_REG:\n\t\treturn E_OP_SL;\n\n\tcase ARM_SFT_ROR:\n\tcase ARM_SFT_RRX:\n\tcase ARM_SFT_ROR_REG:\n\tcase ARM_SFT_RRX_REG:\n\t\treturn E_OP_RR;\n\n\tdefault:\n\t\tbreak;\n\t}\n\treturn E_OP_VOID;\n}\n\nstatic const char *decode_shift_64(arm64_shifter shift) {\n\tstatic const char *E_OP_SR = \">>\";\n\tstatic const char *E_OP_SL = \"<<\";\n\tstatic const char *E_OP_RR = \">>>\";\n\tstatic const char *E_OP_AR = \">>>>\";\n\tstatic const char *E_OP_VOID = \"\";\n\n\tswitch (shift) {\n\tcase ARM64_SFT_ASR:\n\t\treturn E_OP_AR;\n\tcase ARM64_SFT_LSR:\n\t\treturn E_OP_SR;\n\n\tcase ARM64_SFT_LSL:\n\tcase ARM64_SFT_MSL:\n\t\treturn E_OP_SL;\n\n\tcase ARM64_SFT_ROR:\n\t\treturn E_OP_RR;\n\n\tdefault:\n\t\tbreak;\n\t}\n\treturn E_OP_VOID;\n}\n\n#define DECODE_SHIFT(x) decode_shift(insn->detail->arm.operands[x].shift.type)\n#define DECODE_SHIFT64(x) decode_shift_64(insn->detail->arm64.operands[x].shift.type)\n\nstatic unsigned int regsize32(cs_insn *insn, int n) {\n\tr_return_val_if_fail(n >= 0 && n < insn->detail->arm.op_count, 0);\n\tunsigned int reg = insn->detail->arm.operands[n].reg;\n\tif (reg >= ARM_REG_D0 && reg <= ARM_REG_D31) {\n\t\treturn 8;\n\t}\n\tif (reg >= ARM_REG_Q0 && reg <= ARM_REG_Q15) {\n\t\treturn 16;\n\t}\n\treturn 4; // s0-s31, r0-r15\n}\n\nstatic int regsize64(cs_insn *insn, int n) {\n\tunsigned int reg = insn->detail->arm64.operands[n].reg;\n\tif ( (reg >= ARM64_REG_S0 && reg <= ARM64_REG_S31) ||\n\t\t(reg >= ARM64_REG_W0 && reg <= ARM64_REG_W30) ||\n\t\treg == ARM64_REG_WZR) {\n\t\treturn 4;\n\t}\n\tif (reg >= ARM64_REG_B0 && reg <= ARM64_REG_B31) {\n\t\treturn 1;\n\t}\n\tif (reg >= ARM64_REG_H0 && reg <= ARM64_REG_H31) {\n\t\treturn 2;\n\t}\n\tif ( (reg >= ARM64_REG_Q0 && reg <= ARM64_REG_Q31) ||\n\t\t(reg >= ARM64_REG_V0 && reg <= ARM64_REG_V31) ) {\n\t\treturn 16;\n\t}\n\treturn 8;\n}\n\n#define REGSIZE64(x) regsize64 (insn, x)\n#define REGSIZE32(x) regsize32 (insn, x)\n#define REGBITS64(x) (8 * regsize64 (insn, x))\n#define REGBITS32(x) (8 * regsize32 (insn, x))\n\n#define SET_FLAGS() r_strbuf_appendf (&op->esil, \",$z,zf,:=,%d,$s,nf,:=,%d,$c,cf,:=,%d,$o,vf,:=\", REGBITS64 (0) - 1, REGBITS64 (0), REGBITS64 (0) -1);\n\nstatic int vector_size(cs_arm64_op *op) {\n#if CS_API_MAJOR == 4\n\tif (op->vess) {\n\t\treturn vess_size(op->vess);\n\t}\n#endif\n\tif (op->vas) {\n\t\treturn vas_size(op->vas);\n\t} else {\n\t\treturn 64;\n\t}\n}\n\n// return postfix\nconst char* arm_prefix_cond(RAnalOp *op, int cond_type) {\n\tconst char *close_cond[2];\n\tclose_cond[0] = \"\\0\";\n\tclose_cond[1] = \",}\\0\";\n\tint close_type = 0;\n\tswitch (cond_type) {\n\tcase ARM_CC_EQ:\n\t\tclose_type = 1;\n\t\tr_strbuf_appendf (&op->esil, \"zf,?{,\");\n\t\tbreak;\n\tcase ARM_CC_NE:\n\t\tclose_type = 1;\n\t\tr_strbuf_appendf (&op->esil, \"zf,!,?{,\");\n\t\tbreak;\n\tcase ARM_CC_HS:\n\t\tclose_type = 1;\n\t\tr_strbuf_appendf (&op->esil, \"cf,?{,\");\n\t\tbreak;\n\tcase ARM_CC_LO:\n\t\tclose_type = 1;\n\t\tr_strbuf_appendf (&op->esil, \"cf,!,?{,\");\n\t\tbreak;\n\tcase ARM_CC_MI:\n\t\tclose_type = 1;\n\t\tr_strbuf_appendf (&op->esil, \"nf,?{,\");\n\t\tbreak;\n\tcase ARM_CC_PL:\n\t\tclose_type = 1;\n\t\tr_strbuf_appendf (&op->esil, \"nf,!,?{,\");\n\t\tbreak;\n\tcase ARM_CC_VS:\n\t\tclose_type = 1;\n\t\tr_strbuf_appendf (&op->esil, \"vf,?{,\");\n\t\tbreak;\n\tcase ARM_CC_VC:\n\t\tclose_type = 1;\n\t\tr_strbuf_appendf (&op->esil, \"vf,!,?{,\");\n\t\tbreak;\n\tcase ARM_CC_HI:\n\t\tclose_type = 1;\n\t\tr_strbuf_appendf (&op->esil, \"cf,zf,!,&,?{,\");\n\t\tbreak;\n\tcase ARM_CC_LS:\n\t\tclose_type = 1;\n\t\tr_strbuf_appendf (&op->esil, \"cf,!,zf,|,?{,\");\n\t\tbreak;\n\tcase ARM_CC_GE:\n\t\tclose_type = 1;\n\t\tr_strbuf_appendf (&op->esil, \"nf,vf,^,!,?{,\");\n\t\tbreak;\n\tcase ARM_CC_LT:\n\t\tclose_type = 1;\n\t\tr_strbuf_appendf (&op->esil, \"nf,vf,^,?{,\");\n\t\tbreak;\n\tcase ARM_CC_GT:\n\t\t// zf == 0 && nf == vf\n\t\tclose_type = 1;\n\t\tr_strbuf_appendf (&op->esil, \"zf,!,nf,vf,^,!,&,?{,\");\n\t\tbreak;\n\tcase ARM_CC_LE:\n\t\t// zf == 1 || nf != vf\n\t\tclose_type = 1;\n\t\tr_strbuf_appendf (&op->esil, \"zf,nf,vf,^,|,?{,\");\n\t\tbreak;\n\tcase ARM_CC_AL:\n\t\t// always executed\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn close_cond[close_type];\n}\n\n/* arm64 */\n\nstatic const char *arg(RAnal *a, csh *handle, cs_insn *insn, char *buf, int n) {\n\tbuf[0] = 0;\n\tswitch (insn->detail->arm.operands[n].type) {\n\tcase ARM_OP_REG:\n\t\tif (ISSHIFTED (n)) {\n\t\t\tsprintf (buf, \"%u,%s,%s\",\n\t\t\tLSHIFT2 (n),\n\t\t\tr_str_getf (cs_reg_name (*handle,\n\t\t\t\tinsn->detail->arm.operands[n].reg)),\n\t\t\tDECODE_SHIFT (n));\n\t\t} else {\n\t\t\tsprintf (buf, \"%s\",\n\t\t\tr_str_getf (cs_reg_name (*handle,\n\t\t\t\tinsn->detail->arm.operands[n].reg)));\n\t\t}\n\t\tbreak;\n\tcase ARM_OP_IMM:\n\t\tif (a->bits == 64) {\n\t\t\t// 64bit only\n\t\t\tsprintf (buf, \"%\"PFMT64d, (ut64)\n\t\t\t\t\tinsn->detail->arm.operands[n].imm);\n\t\t} else {\n\t\t\t// 32bit only\n\t\t\tsprintf (buf, \"%\"PFMT64d, (ut64)(ut32)\n\t\t\t\t\tinsn->detail->arm.operands[n].imm);\n\t\t}\n\t\tbreak;\n\tcase ARM_OP_MEM:\n\t\tbreak;\n\tcase ARM_OP_FP:\n\t\tsprintf (buf, \"%lf\", insn->detail->arm.operands[n].fp);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn buf;\n}\n\n#define ARG(x) arg(a, handle, insn, str[x], x)\n\n#define VEC64(n) insn->detail->arm64.operands[n].vess\n#define VEC64_APPEND(sb, n, i) vector64_append(sb, handle, insn, n, i)\n#define VEC64_MASK(sh, sz) (bitmask_by_width[63]^(bitmask_by_width[sz>0?sz-1:0]<<sh))\n\nstatic void vector64_append(RStrBuf *sb, csh *handle, cs_insn *insn, int n, int i) {\n\tcs_arm64_op op = INSOP64 (n);\n\n\tif (op.vector_index != -1) {\n\t\ti = op.vector_index;\n\t}\n\n#if CS_API_MAJOR == 4\n\tconst bool isvessas = (op.vess || op.vas);\n#else\n\tconst bool isvessas = op.vas;\n#endif\n\tif (isvessas && i != -1) {\n\t\tint size = vector_size (&op);\n\t\tint shift = i * size;\n\t\tchar *regc = \"l\";\n\t\tif (shift >= 64) {\n\t\t\tshift -= 64;\n\t\t\tregc = \"h\";\n\t\t}\n\n\t\tsize_t s = sizeof (bitmask_by_width) / sizeof (*bitmask_by_width);\n\t\tint width = size > 0? (size - 1) % s: 0;\n\t\tif (shift > 0) {\n\t\t\tr_strbuf_appendf (sb, \"0x%\"PFMT64x\",%d,%s%s,>>,&\",\n\t\t\t\tbitmask_by_width[width], shift, REG64 (n), regc);\n\t\t} else {\n\t\t\tr_strbuf_appendf (sb, \"0x%\"PFMT64x\",%s%s,&\",\n\t\t\t\tbitmask_by_width[width], REG64 (n), regc);\n\t\t}\n\t} else {\n\t\tr_strbuf_appendf (sb, \"%s\", REG64 (n));\n\t}\n}\n\n#define VEC64_DST_APPEND(sb, n, i) vector64_dst_append(sb, handle, insn, n, i)\n\nstatic void vector64_dst_append(RStrBuf *sb, csh *handle, cs_insn *insn, int n, int i) {\n\tcs_arm64_op op = INSOP64 (n);\n\n\tif (op.vector_index != -1) {\n\t\ti = op.vector_index;\n\t}\n#if CS_API_MAJOR == 4\n\tconst bool isvessas = (op.vess || op.vas);\n#else\n\tconst bool isvessas = op.vas;\n#endif\n\tif (isvessas && i != -1) {\n\t\tint size = vector_size (&op);\n\t\tint shift = i * size;\n\t\tchar *regc = \"l\";\n\t\tsize_t s = sizeof (bitmask_by_width) / sizeof (*bitmask_by_width);\n\t\tsize_t index = size > 0? (size - 1) % s: 0;\n\t\tif (index >= BITMASK_BY_WIDTH_COUNT) {\n\t\t\tindex = 0;\n\t\t}\n\t\tut64 mask = bitmask_by_width[index];\n\t\tif (shift >= 64) {\n\t\t\tshift -= 64;\n\t\t\tregc = \"h\";\n\t\t}\n\t\tif (shift > 0 && shift < 64) {\n\t\t\tr_strbuf_appendf (sb, \"%d,SWAP,0x%\"PFMT64x\",&,<<,%s%s,0x%\"PFMT64x\",&,|,%s%s\",\n\t\t\t\tshift, mask, REG64 (n), regc, VEC64_MASK (shift, size), REG64 (n), regc);\n\t\t} else {\n\t\t\tint dimsize = size % 64;\n\t\t\tr_strbuf_appendf (sb, \"0x%\"PFMT64x\",&,%s%s,0x%\"PFMT64x\",&,|,%s%s\",\n\t\t\t\tmask, REG64 (n), regc, VEC64_MASK (shift, dimsize), REG64 (n), regc);\n\t\t}\n\t} else {\n\t\tr_strbuf_appendf (sb, \"%s\", REG64 (n));\n\t}\n}\n\n#define SHIFTED_IMM64(n, sz) shifted_imm64(handle, insn, n, sz)\n\nstatic ut64 shifted_imm64(csh *handle, cs_insn *insn, int n, int sz) {\n\tcs_arm64_op op = INSOP64 (n);\n\tint sft = op.shift.value;\n\tswitch (op.shift.type) {\n\t\tcase ARM64_SFT_MSL:\n\t\t\treturn (IMM64 (n) << sft) | ((1 << sft) - 1);\n\t\tcase ARM64_SFT_LSL:\n\t\t\treturn IMM64 (n) << sft;\n\t\tcase ARM64_SFT_LSR:\n\t\t\treturn IMM64 (n) >> sft;\n\t\tcase ARM64_SFT_ROR:\n\t\t\treturn (IMM64 (n) >> sft)|(IMM64 (n) << (sz - sft));\n\t\tcase ARM64_SFT_ASR:\n\t\t\tswitch (sz) {\n\t\t\tcase 8: return (st8)IMM64 (n) >> sft;\n\t\t\tcase 16: return (st16)IMM64 (n) >> sft;\n\t\t\tcase 32: return (st32)IMM64 (n) >> sft;\n\t\t\tdefault: return (st64)IMM64 (n) >> sft;\n\t\t\t}\n\t\tdefault:\n\t\t\treturn IMM64 (n);\n\t}\n}\n\n#define ARG64_APPEND(sb, n) arg64_append (sb, handle, insn, n, -1, 0)\n#define ARG64_SIGN_APPEND(sb, n, s) arg64_append (sb, handle, insn, n, -1, s)\n#define VECARG64_APPEND(sb, n, i, s) arg64_append (sb, handle, insn, n, i, s)\n#define COMMA(sb) r_strbuf_appendf (sb, \",\")\n\nstatic void arg64_append(RStrBuf *sb, csh *handle, cs_insn *insn, int n, int i, int sign) {\n\tcs_arm64_op op = INSOP64 (n);\n\n\tint size = 64;\n\tif (ISREG64 (n)) {\n\t\tsize = REGSIZE64 (n)*8;\n\t}\n\n\tif (ISIMM64 (n)) {\n\t\tif (!ISSHIFTED64 (n)) {\n\t\t\tut64 imm = SHIFTED_IMM64 (n, size);\n\t\t\tr_strbuf_appendf (sb, \"0x%\"PFMT64x, imm);\n\t\t\treturn;\n\t\t}\n\t}\n\tconst char *rn = (ISMEM64 (n) && HASMEMINDEX64 (n))\n\t\t? MEMINDEX64 (n): REG64 (n);\n\tint shift = LSHIFT2_64 (n);\n\tint signext = EXT64 (n);\n\tif (sign && !signext) {\n\t\tsignext = size;\n\t}\n\n\tif (signext) {\n\t\tr_strbuf_appendf (sb, \"%d,\", signext);\n\t}\n\tif (shift) {\n\t\tr_strbuf_appendf (sb, \"%d,\", shift);\n\t}\n\n#if CS_API_MAJOR == 4\n\tconst bool isvessas = (op.vess || op.vas);\n#else\n\tconst bool isvessas = op.vas;\n#endif\n\tif (isvessas) {\n\t\tVEC64_APPEND (sb, n, i);\n\t} else {\n\t\tr_strbuf_appendf (sb, \"%s\", rn);\n\t}\n\n\tif (shift) {\n\t\tr_strbuf_appendf (sb, \",%s\", DECODE_SHIFT64 (n));\n\t}\n\tif (signext) {\n\t\tr_strbuf_appendf (sb, \",~\");\n\t}\n}\n\n#define OPCALL(opchar) arm64math(a, op, addr, buf, len, handle, insn, opchar, 0, 0)\n#define OPCALL_NEG(opchar) arm64math(a, op, addr, buf, len, handle, insn, opchar, 1, 0)\n#define OPCALL_SIGN(opchar, sign) arm64math(a, op, addr, buf, len, handle, insn, opchar, 0, sign)\n\nstatic void arm64math(RAnal *a, RAnalOp *op, ut64 addr, const ut8 *buf, int len, csh *handle, cs_insn *insn, const char *opchar, int negate, int sign) {\n\tcs_arm64_op dst = INSOP64 (0);\n\tint i, c = (OPCOUNT64 () > 2) ? 1 : 0;\n\n\tif (dst.vas) {\n\t\tint end = vas_count (dst.vas);\n\t\tfor (i = 0; i < end; i++) {\n\t\t\tVECARG64_APPEND (&op->esil, 2, i, sign);\n\t\t\tif (negate) {\n\t\t\t\tr_strbuf_appendf (&op->esil, \",-1,^\");\n\t\t\t}\n\t\t\tCOMMA (&op->esil);\n\t\t\tVECARG64_APPEND (&op->esil, 1, i, sign);\n\t\t\tr_strbuf_appendf (&op->esil, \",%s,\", opchar);\n\t\t\tVEC64_DST_APPEND (&op->esil, 0, i);\n\t\t\tr_strbuf_appendf (&op->esil, \",=\");\n\t\t\tif (i < end - 1) {\n\t\t\t\tCOMMA (&op->esil);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tVECARG64_APPEND (&op->esil, c+1, -1, sign);\n\t\tif (negate) {\n\t\t\tr_strbuf_appendf (&op->esil, \",-1,^\");\n\t\t}\n\t\tCOMMA (&op->esil);\n\t\tVECARG64_APPEND (&op->esil, c, -1, sign);\n\t\tr_strbuf_appendf (&op->esil, \",%s,\", opchar);\n\t\tVEC64_DST_APPEND (&op->esil, 0, -1);\n\t\tr_strbuf_appendf (&op->esil, \",=\");\n\t}\n}\n\n#define FPOPCALL(opchar) arm64fpmath(a, op, addr, buf, len, handle, insn, opchar, 0)\n#define FPOPCALL_NEGATE(opchar) arm64fpmath(a, op, addr, buf, len, handle, insn, opchar, 1)\n\n// floating point math instruction helper\nstatic void arm64fpmath(RAnal *a, RAnalOp *op, ut64 addr, const ut8 *buf, int len, csh *handle, cs_insn *insn, const char *opchar, int negate) {\n\tint i, size = REGSIZE64 (1)*8;\n\n\tcs_arm64_op dst = INSOP64 (0);\n\tint start = -1;\n\tint end = 0;\n\tint convert = size == 64 ? 0 : 1;\n\tif (dst.vas) {\n\t\tstart = 0;\n\t\tend = vas_count(dst.vas);\n\t}\n\n\tfor (i = start; i < end; i++) {\n\t\tif (convert) {\n\t\t\tr_strbuf_appendf (&op->esil, \"%d,DUP,\", size);\n\t\t}\n\t\tVEC64_APPEND (&op->esil, 2, i);\n\t\tif (convert) {\n\t\t\tr_strbuf_appendf (&op->esil, \",F2D\");\n\t\t}\n\t\tif (negate) {\n\t\t\tr_strbuf_appendf (&op->esil, \",-F\");\n\t\t}\n\t\tif (convert) {\n\t\t\tr_strbuf_appendf (&op->esil, \",%d\", size);\n\t\t}\n\t\tCOMMA (&op->esil);\n\t\tVEC64_APPEND (&op->esil, 1, i);\n\t\tif (convert) {\n\t\t\tr_strbuf_appendf (&op->esil, \",F2D,F%s,D2F,\", opchar);\t\n\t\t} else {\n\t\t\tr_strbuf_appendf (&op->esil, \",F%s,\", opchar);\t\n\t\t}\n\t\tVEC64_DST_APPEND (&op->esil, 0, i);\n\t\tr_strbuf_appendf (&op->esil, \",=\");\n\t\tif (i < end - 1) {\n\t\t\tCOMMA (&op->esil);\n\t\t}\n\t}\n}\n\nstatic int analop64_esil(RAnal *a, RAnalOp *op, ut64 addr, const ut8 *buf, int len, csh *handle, cs_insn *insn) {\n\tconst char *postfix = NULL;\n\n\tr_strbuf_init (&op->esil);\n\tr_strbuf_set (&op->esil, \"\");\n\n\tpostfix = arm_prefix_cond (op, insn->detail->arm64.cc);\n\n\tswitch (insn->id) {\n\tcase ARM64_INS_REV:\n\tcase ARM64_INS_REV64:\n\t// these REV* instructions were almost right, except in the cases like rev x0, x0\n\t// where the use of |= caused copies of the value to be erroneously present\n\t{\n\t\tconst char *r0 = REG64 (0);\n\t\tconst char *r1 = REG64 (1);\n\t\tint size = REGSIZE64 (1);\n\t\tif (size == 8) {\n\t\t\tr_strbuf_setf (&op->esil,\n\t\t\t\t\"56,0xff,%s,&,<<,tmp,=,\"\n\t\t\t\t\"48,0xff,8,%s,>>,&,<<,tmp,|=,\"\n\t\t\t\t\"40,0xff,16,%s,>>,&,<<,tmp,|=,\"\n\t\t\t\t\"32,0xff,24,%s,>>,&,<<,tmp,|=,\"\n\t\t\t\t\"24,0xff,32,%s,>>,&,<<,tmp,|=,\"\n\t\t\t\t\"16,0xff,40,%s,>>,&,<<,tmp,|=,\"\n\t\t\t\t\"8,0xff,48,%s,>>,&,<<,tmp,|=,\"\n\t\t\t\t\"0xff,56,%s,>>,&,tmp,|=,tmp,%s,=\",\n\t\t\t\tr1, r1, r1, r1,\n\t\t\t\tr1, r1, r1, r1, r0);\n\t\t} else {\n\t\t\tr_strbuf_setf (&op->esil,\n\t\t\t\t\"24,0xff,%s,&,<<,tmp,=,\"\n\t\t\t\t\"16,0xff,8,%s,>>,&,<<,tmp,|=,\"\n\t\t\t\t\"8,0xff,16,%s,>>,&,<<,tmp,|=,\"\n\t\t\t\t\"0xff,24,%s,>>,&,tmp,|=,tmp,%s,=\",\n\t\t\t\tr1, r1, r1, r1, r0);\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARM64_INS_REV32:\n\t\tr_strbuf_setf (&op->esil,\n\t\t\t\"24,0x000000ff000000ff,%s,&,<<,tmp,=,\"\n\t\t\t\"16,0x000000ff000000ff,8,%s,>>,&,<<,tmp,|=,\"\n\t\t\t\"8,0x000000ff000000ff,16,%s,>>,&,<<,tmp,|=,\"\n\t\t\t\"0x000000ff000000ff,24,%s,>>,&,tmp,|=,tmp,%s,=\",\n\t\t\tREG64 (1), REG64 (1), REG64 (1), REG64 (1), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_REV16:\n\t\tr_strbuf_setf (&op->esil,\n\t\t\t\"8,0xff00ff00ff00ff00,%s,&,>>,tmp,=,\"\n\t\t\t\"8,0x00ff00ff00ff00ff,%s,&,<<,tmp,|=,tmp,%s,=\",\n\t\t\tREG64 (1), REG64 (1), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_ADR:\n\t\t// TODO: must be 21bit signed\n\t\tr_strbuf_setf (&op->esil,\n\t\t\t\"%\"PFMT64d\",%s,=\", IMM64 (1), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_SMADDL:\n\t\tr_strbuf_setf (&op->esil, \"%d,%s,~,%d,%s,~,*,%s,+,%s,=\",\n\t\t\tREGBITS64 (1), REG64 (2), REGBITS64 (1), REG64 (1), REG64 (3), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_UMADDL:\n\tcase ARM64_INS_MADD:\n\t\tr_strbuf_setf (&op->esil, \"%s,%s,*,%s,+,%s,=\",\n\t\t\tREG64 (2), REG64 (1), REG64 (3), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_MSUB:\n\t\tr_strbuf_setf (&op->esil, \"%s,%s,*,%s,-,%s,=\",\n\t\t\tREG64 (2), REG64 (1), REG64 (3), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_MNEG:\n\t\tr_strbuf_setf (&op->esil, \"%s,%s,*,0,-,%s,=\",\n\t\t\tREG64 (2), REG64 (1), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_ADD:\n\tcase ARM64_INS_ADC: // Add with carry.\n\t\tOPCALL (\"+\");\n\t\tbreak;\n\tcase ARM64_INS_SUB:\n\t\tOPCALL (\"-\");\n\t\tbreak;\n\tcase ARM64_INS_SBC:\n\t\t// TODO have to check this more, VEX does not work\n\t\tr_strbuf_setf (&op->esil, \"%s,cf,+,%s,-,%s,=\",\n\t\t\tREG64 (2), REG64 (1), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_SMULL2:\n\tcase ARM64_INS_SMULL:\n\t\tOPCALL_SIGN (\"*\", REGBITS64 (1));\n\t\tbreak;\n\tcase ARM64_INS_UMULL2:\n\tcase ARM64_INS_UMULL:\n\tcase ARM64_INS_MUL:\n\t\tOPCALL (\"*\");\n\t\tbreak;\n\tcase ARM64_INS_UMULH:\n\t\tr_strbuf_setf (&op->esil, \"%s,%s,L*,SWAP,%s,=\",\n\t\t\tREG64 (2), REG64 (1), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_SMULH:\n\t\t// TODO this needs to be a 128 bit sign ext to be right\n\t\tr_strbuf_setf (&op->esil, \"%d,%s,~,%d,%s,~,L*,SWAP,%s,=\",\n\t\t\tREGBITS64 (1), REG64 (2), REGBITS64 (1), REG64 (1), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_AND:\n\t\tOPCALL (\"&\");\n\t\tbreak;\n\tcase ARM64_INS_ORR:\n\t\tOPCALL (\"|\");\n\t\tbreak;\n#if CS_API_MAJOR > 4\t\n\tcase ARM64_INS_NAND:\n\t\tOPCALL_NEG (\"&\");\n\t\tbreak;\n\tcase ARM64_INS_ADDS:\n\tcase ARM64_INS_ADCS:\n\t\tOPCALL (\"+\");\n\t\tSET_FLAGS();\n\t\tbreak;\n\tcase ARM64_INS_SUBS:\n\t\tOPCALL (\"-\");\n\t\tSET_FLAGS();\n\t\tbreak;\n\tcase ARM64_INS_ANDS:\n\t\tOPCALL (\"&\");\n\t\tSET_FLAGS();\n\t\tbreak;\n\tcase ARM64_INS_NANDS:\n\t\tOPCALL_NEG (\"&\");\n\t\tSET_FLAGS();\n\t\tbreak;\n\tcase ARM64_INS_ORRS:\n\t\tOPCALL (\"|\");\n\t\tSET_FLAGS();\n\t\tbreak;\n\tcase ARM64_INS_EORS:\n\t\tOPCALL (\"^\");\n\t\tSET_FLAGS();\n\t\tbreak;\n\tcase ARM64_INS_ORNS:\n\t\tOPCALL_NEG (\"|\");\n\t\tSET_FLAGS();\n\t\tbreak;\n#endif\n\tcase ARM64_INS_EOR:\n\t\tOPCALL (\"^\");\n\t\tbreak;\n\tcase ARM64_INS_ORN:\n\t\tOPCALL_NEG (\"|\");\n\t\tbreak;\n\tcase ARM64_INS_EON:\n\t\tOPCALL_NEG (\"^\");\n\t\tbreak;\n\tcase ARM64_INS_LSR:\n\t{\n\t\tconst char *r0 = REG64 (0);\n\t\tconst char *r1 = REG64 (1);\n\t\tconst int size = REGSIZE64 (0)*8;\n\n\t\tif (ISREG64(2)) {\n\t\t\tif (LSHIFT2_64 (2) || EXT64 (2)) {\n\t\t\t\tARG64_APPEND (&op->esil, 2);\n\t\t\t\tr_strbuf_appendf (&op->esil, \",%d,%%,%s,>>,%s,=\", size, r1, r0);\n\t\t\t} else {\n\t\t\t\tconst char *r2 = REG64 (2);\n\t\t\t\tr_strbuf_setf (&op->esil, \"%d,%s,%%,%s,>>,%s,=\", size, r2, r1, r0);\n\t\t\t}\n\t\t} else {\n\t\t\tut64 i2 = IMM64 (2);\n\t\t\tr_strbuf_setf (&op->esil, \"%\"PFMT64d\",%s,>>,%s,=\", i2 % (ut64)size, r1, r0);\n\t\t}\n\t\t//OPCALL (\">>\");\n\t\tbreak;\n\t}\n\tcase ARM64_INS_LSL:\n\t{\n\t\tconst char *r0 = REG64 (0);\n\t\tconst char *r1 = REG64 (1);\n\t\tconst int size = REGSIZE64 (0)*8;\n\n\t\tif (ISREG64 (2)) {\n\t\t\tif (LSHIFT2_64 (2) || EXT64 (2)) {\n\t\t\t\tARG64_APPEND (&op->esil, 2);\n\t\t\t\tr_strbuf_appendf (&op->esil, \",%d,%%,%s,<<,%s,=\", size, r1, r0);\n\t\t\t} else {\n\t\t\t\tconst char *r2 = REG64 (2);\n\t\t\t\tr_strbuf_setf (&op->esil, \"%d,%s,%%,%s,<<,%s,=\", size, r2, r1, r0);\n\t\t\t}\n\t\t} else {\n\t\t\tut64 i2 = IMM64 (2);\n\t\t\tr_strbuf_setf (&op->esil, \"%\"PFMT64d\",%s,<<,%s,=\", i2 % (ut64)size, r1, r0);\n\t\t}\n\t\t//OPCALL (\"<<\");\n\t\tbreak;\n\t}\n\tcase ARM64_INS_ROR:\n\t\tOPCALL (\">>>\");\n\t\tbreak;\n\tcase ARM64_INS_NOP:\n\t\tr_strbuf_setf (&op->esil, \",\");\n\t\tbreak;\n\tcase ARM64_INS_MOV:\n\tcase ARM64_INS_FMOV:\n\t{\n\t\tcs_arm64_op dst = INSOP64 (0);\n\t\tcs_arm64_op src = INSOP64 (1);\n\n\t\tif (dst.vas && src.vas) {\n\t\t\tr_strbuf_setf (&op->esil, \"%sh,%sh,=,%sl,%sl,=\",\n\t\t\t\tREG64 (1), REG64 (0), REG64 (1), REG64 (0));\n\t\t} else {\n\t\t\tARG64_APPEND (&op->esil, 1);\n\t\t\tr_strbuf_appendf (&op->esil, \",\");\n\t\t\tVEC64_DST_APPEND (&op->esil, 0, -1);\n\t\t\tr_strbuf_appendf (&op->esil, \",=\");\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARM64_INS_FCMP:\n\tcase ARM64_INS_FCMPE:\n\tcase ARM64_INS_FCCMP:\n\tcase ARM64_INS_FCCMPE:\n\t\tif (ISREG64 (1)) {\n\t\t\tr_strbuf_setf (&op->esil,\n\t\t\t\t\"%d,%s,F2D,NAN,%d,%s,F2D,NAN,|,vf,:=\"\n\t\t\t\t\",%d,%s,F2D,%d,%s,F2D,F==,vf,|,zf,:=\"\n\t\t\t\t\",%d,%s,F2D,%d,%s,F2D,F<,vf,|,nf,:=\",\n\t\t\t\tREGBITS64 (1), REG64 (1), REGBITS64 (1), REG64 (0),\n\t\t\t\tREGBITS64 (1), REG64 (1), REGBITS64 (1), REG64 (0),\n\t\t\t\tREGBITS64 (1), REG64 (1), REGBITS64 (1), REG64 (0)\n\t\t\t);\t\n\t\t} else {\n\t\t\tr_strbuf_setf (&op->esil,\n\t\t\t\t\"%d,%s,F2D,NAN,vf,:=\"\n\t\t\t\t\",0,I2D,%d,%s,F2D,F==,vf,|,zf,:=\"\n\t\t\t\t\",0,I2D,%d,%s,F2D,F<,vf,|,nf,:=\",\n\t\t\t\tREGBITS64 (1), REG64 (0),\n\t\t\t\tREGBITS64 (1), REG64 (0),\n\t\t\t\tREGBITS64 (1), REG64 (0)\n\t\t\t);\n\t\t}\n\n\t\tif (insn->id == ARM64_INS_FCCMP || insn->id == ARM64_INS_FCCMPE) {\n\t\t\tr_strbuf_appendf (&op->esil, \",\");\n\t\t\tarm_prefix_cond (op, insn->detail->arm64.cc);\n\t\t\tr_strbuf_appendf (&op->esil, \"}{,pstate,1,28,1,<<,-,&,0x%\"PFMT64x\",|,pstate,:=\",\n\t\t\t\tIMM64(2) << 28);\n\t\t}\n\t\tbreak;\n\tcase ARM64_INS_FCVT:\n\t\tr_strbuf_setf (&op->esil, \"%d,%d,%s,F2D,D2F,%s,=\",\n\t\t\tREGBITS64 (0), REGBITS64 (1), REG64 (1), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_SCVTF:\n\t\tr_strbuf_setf (&op->esil, \"%d,\", REGBITS64 (0));\n\t\tARG64_SIGN_APPEND (&op->esil, 1, REGBITS64 (1));\n\t\tr_strbuf_appendf (&op->esil, \",S2D,D2F,\");\n\t\tVEC64_DST_APPEND (&op->esil, 0, -1);\n\t\tr_strbuf_appendf (&op->esil, \",=\");\n\t\tbreak;\n\tcase ARM64_INS_UCVTF:\n\t\tr_strbuf_setf (&op->esil, \"%d,\", REGBITS64 (0));\n\t\tARG64_APPEND (&op->esil, 1);\n\t\tr_strbuf_appendf (&op->esil, \",U2D,D2F,\");\n\t\tVEC64_DST_APPEND (&op->esil, 0, -1);\n\t\tr_strbuf_appendf (&op->esil, \",=\");\n\t\tbreak;\n\tcase ARM64_INS_FCVTAU:\n\tcase ARM64_INS_FCVTAS:\n\tcase ARM64_INS_FCVTMU:\n\tcase ARM64_INS_FCVTMS:\n\tcase ARM64_INS_FCVTNU:\n\tcase ARM64_INS_FCVTNS:\n\tcase ARM64_INS_FCVTPU:\n\tcase ARM64_INS_FCVTPS:\n\tcase ARM64_INS_FCVTZU:\n\tcase ARM64_INS_FCVTZS:\n\t\t// TODO: unsigned int won't be right, idk entirely what it even means\n\t\t// also the rounding mode... idk i hate floats\n\t\tr_strbuf_setf (&op->esil, \"%d,\", REGBITS64 (1));\n\t\tARG64_APPEND (&op->esil, 1);\n\t\tr_strbuf_appendf (&op->esil, \",F2D,D2I,\");\n\t\tVEC64_DST_APPEND (&op->esil, 0, -1);\n\t\tr_strbuf_appendf (&op->esil, \",=\");\n\t\tbreak;\n\tcase ARM64_INS_FRINTA:\n\tcase ARM64_INS_FRINTI:\n\tcase ARM64_INS_FRINTN:\n\tcase ARM64_INS_FRINTX:\n\tcase ARM64_INS_FRINTZ:\n\tcase ARM64_INS_FRINTP:\n\tcase ARM64_INS_FRINTM:\n\t{\n\t\tchar* rounder = \"ROUND\";\n\t\tif (insn->id == ARM64_INS_FRINTM) {\n\t\t\trounder = \"FLOOR\";\n\t\t} else if (insn->id == ARM64_INS_FRINTP) {\n\t\t\trounder = \"CEIL\";\n\t\t}\n\t\tr_strbuf_setf (&op->esil, \"%d,DUP,\", REGBITS64 (1));\n\t\tARG64_APPEND (&op->esil, 1);\n\t\tr_strbuf_appendf (&op->esil, \",F2D,%s,D2F,\", rounder);\n\t\tVEC64_DST_APPEND (&op->esil, 0, -1);\n\t\tr_strbuf_appendf (&op->esil, \",=\");\n\t\tbreak;\n\t}\n\tcase ARM64_INS_FABS:\n\t\tr_strbuf_setf (&op->esil, \"%d,DUP,%s,F2D,DUP,0,I2D,F<,?{,-F,},D2F,%s,=\",\n\t\t\tREGBITS64 (1), REG64 (1), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_FNEG:\n\t\tr_strbuf_setf (&op->esil, \"%d,DUP,%s,F2D,-F,D2F,%s,=\",\n\t\t\tREGBITS64 (1), REG64 (1), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_FMIN:\n\t\tr_strbuf_setf (&op->esil, \"%d,%s,F2D,%d,%s,F2D,F<,?{,%s,}{,%s,},%s,=\",\n\t\t\tREGBITS64 (2), REG64 (2),\n\t\t\tREGBITS64 (1), REG64 (1), REG64 (1), REG64 (2), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_FMAX:\n\t\tr_strbuf_setf (&op->esil, \"%d,%s,F2D,%d,%s,F2D,F<,!,?{,%s,}{,%s,},%s,=\",\n\t\t\tREGBITS64 (2), REG64 (2),\n\t\t\tREGBITS64 (1), REG64 (1), REG64 (1), REG64 (2), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_FADD:\n\t\tFPOPCALL (\"+\");\n\t\tbreak;\n\tcase ARM64_INS_FSUB:\n\t\tFPOPCALL (\"-\");\n\t\tbreak;\n\tcase ARM64_INS_FMUL:\n\t\tFPOPCALL (\"*\");\n\t\tbreak;\n\tcase ARM64_INS_FNMUL:\n\t\tFPOPCALL_NEGATE(\"*\");\n\t\tbreak;\n\tcase ARM64_INS_FMADD:\n\t\tr_strbuf_setf (&op->esil, \"%d,DUP,%s,F2D,%d,%s,F2D,F*,%d,%s,F2D,F+,D2F,%s,=\",\n\t\t\tREGBITS64 (1), REG64 (1),\n\t\t\tREGBITS64 (2), REG64 (2),\n\t\t\tREGBITS64 (3), REG64 (3), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_FNMADD:\n\t\tr_strbuf_setf (&op->esil, \"%d,DUP,%s,F2D,%d,%s,F2D,F*,-F,%d,%s,F2D,F+,-F,D2F,%s,=\",\n\t\t\tREGBITS64 (1), REG64 (1),\n\t\t\tREGBITS64 (2), REG64 (2),\n\t\t\tREGBITS64 (3), REG64 (3), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_FMSUB:\n\t\tr_strbuf_setf (&op->esil, \"%d,DUP,%s,F2D,%d,%s,F2D,F*,%d,%s,F2D,F-,D2F,%s,=\",\n\t\t\tREGBITS64 (1), REG64 (1),\n\t\t\tREGBITS64 (2), REG64 (2),\n\t\t\tREGBITS64 (3), REG64 (3), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_FNMSUB:\n\t\tr_strbuf_setf (&op->esil, \"%d,DUP,%s,F2D,%d,%s,F2D,F*,-F,%d,%s,F2D,F-,-F,D2F,%s,=\",\n\t\t\tREGBITS64 (1), REG64 (1),\n\t\t\tREGBITS64 (2), REG64 (2),\n\t\t\tREGBITS64 (3), REG64 (3), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_FDIV:\n\t\tFPOPCALL (\"/\");\n\t\tbreak;\n\tcase ARM64_INS_SDIV:\n\t\tOPCALL_SIGN (\"/\", REGBITS64 (1));\n\t\tbreak;\n\tcase ARM64_INS_UDIV:\n\t\t/* TODO: support WZR XZR to specify 32, 64bit op */\n\t\tOPCALL (\"/\");\n\t\tbreak;\n#if CS_API_MAJOR > 4\n\tcase ARM64_INS_BRAA:\n\tcase ARM64_INS_BRAAZ:\n\tcase ARM64_INS_BRAB:\n\tcase ARM64_INS_BRABZ:\n#endif\n\tcase ARM64_INS_BR:\n\t\tr_strbuf_setf (&op->esil, \"%s,pc,=\", REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_B:\n\t\t/* capstone precompute resulting address, using PC + IMM */\n\t\tr_strbuf_appendf (&op->esil, \"%\"PFMT64d\",pc,=\", IMM64 (0));\n\t\tbreak;\n\tcase ARM64_INS_BL:\n\t\tr_strbuf_setf (&op->esil, \"pc,lr,=,%\"PFMT64d\",pc,=\", IMM64 (0));\n\t\tbreak;\n#if CS_API_MAJOR > 4\n\tcase ARM64_INS_BLRAA:\n\tcase ARM64_INS_BLRAAZ:\n\tcase ARM64_INS_BLRAB:\n\tcase ARM64_INS_BLRABZ:\n#endif\n\tcase ARM64_INS_BLR:\n\t\tr_strbuf_setf (&op->esil, \"pc,lr,=,%s,pc,=\", REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_CLZ:\n\t{\n\t\t/*\n\t\tfrom https://en.wikipedia.org/wiki/Find_first_set modified for up to size 64\n\t\tfunction clz3 (x)\n\t\t\tif x = 0 return 32\n\t\t\tn \u2190 0\n\t\t\tif (x & 0xFFFF0000) = 0: n \u2190 n + 16, x \u2190 x << 16\n\t\t\tif (x & 0xFF000000) = 0: n \u2190 n +  8, x \u2190 x <<  8\n\t\t\tif (x & 0xF0000000) = 0: n \u2190 n +  4, x \u2190 x <<  4\n\t\t\tif (x & 0xC0000000) = 0: n \u2190 n +  2, x \u2190 x <<  2\n\t\t\tif (x & 0x80000000) = 0: n \u2190 n +  1\n\t\t\treturn n\n\t\t*/\n\n\t\tint size = 8 * REGSIZE64 (0);\n\t\tconst char *r0 = REG64 (0);\n\t\tconst char *r1 = REG64 (1);\n\n\t\tif (size == 32) {\n\t\t\tr_strbuf_setf (&op->esil,\n\t\t\t\"%s,tmp,=,0,\"\n\t\t\t\"tmp,0xffff0000,&,!,?{,16,tmp,<<=,16,+,},\"\n\t\t\t\"tmp,0xff000000,&,!,?{,8,tmp,<<=,8,+,},\"\n\t\t\t\"tmp,0xf0000000,&,!,?{,4,tmp,<<=,4,+,},\"\n\t\t\t\"tmp,0xc0000000,&,!,?{,2,tmp,<<=,2,+,},\"\n\t\t\t\"tmp,0x80000000,&,!,?{,1,+,},\"\n\t\t\t\"%s,!,?{,32,%s,=,}{,%s,=,}\",\n\t\t\tr1, r1, r0, r0);\n\t\t} else {\n\t\t\tr_strbuf_setf (&op->esil,\n\t\t\t\"%s,tmp,=,0,\"\n\t\t\t\"tmp,0xffffffff00000000,&,!,?{,32,tmp,<<=,32,+,},\"\n\t\t\t\"tmp,0xffff000000000000,&,!,?{,16,tmp,<<=,16,+,},\"\n\t\t\t\"tmp,0xff00000000000000,&,!,?{,8,tmp,<<=,8,+,},\"\n\t\t\t\"tmp,0xf000000000000000,&,!,?{,4,tmp,<<=,4,+,},\"\n\t\t\t\"tmp,0xc000000000000000,&,!,?{,2,tmp,<<=,2,+,},\"\n\t\t\t\"tmp,0x8000000000000000,&,!,?{,1,+,},\"\n\t\t\t\"%s,!,?{,64,%s,=,}{,%s,=,}\",\n\t\t\tr1, r1, r0, r0);\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARM64_INS_LDRH:\n\tcase ARM64_INS_LDUR:\n\tcase ARM64_INS_LDURB:\n\tcase ARM64_INS_LDURH:\n\tcase ARM64_INS_LDR:\n\tcase ARM64_INS_LDRB:\n\tcase ARM64_INS_LDXR:\n\tcase ARM64_INS_LDXRB:\n\tcase ARM64_INS_LDXRH:\n\tcase ARM64_INS_LDAXR:\n\tcase ARM64_INS_LDAXRB:\n\tcase ARM64_INS_LDAXRH:\n\tcase ARM64_INS_LDAR:\n\tcase ARM64_INS_LDARB:\n\tcase ARM64_INS_LDARH:\n\t{\n\t\tint size = REGSIZE64 (0);\n\t\tswitch (insn->id) {\n\t\tcase ARM64_INS_LDRB:\n\t\tcase ARM64_INS_LDARB:\n\t\tcase ARM64_INS_LDAXRB:\n\t\tcase ARM64_INS_LDXRB:\n\t\tcase ARM64_INS_LDURB:\n\t\t\tsize = 1;\n\t\t\tbreak;\n\t\tcase ARM64_INS_LDRH:\n\t\tcase ARM64_INS_LDARH:\n\t\tcase ARM64_INS_LDXRH:\n\t\tcase ARM64_INS_LDAXRH:\n\t\tcase ARM64_INS_LDURH:\n\t\t\tsize = 2;\n\t\t\tbreak;\n\t\tcase ARM64_INS_LDRSW:\n\t\tcase ARM64_INS_LDURSW:\n\t\t\tsize = 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif (ISMEM64 (1)) {\n\t\t\tif (HASMEMINDEX64 (1)) {\n\t\t\t\tif (LSHIFT2_64 (1) || EXT64 (1)) {\n\t\t\t\t\tARG64_APPEND (&op->esil, 1);\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \",%s,+,[%d],%s,=\",\n\t\t\t\t\t\t\tMEMBASE64 (1), size, REG64 (0));\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,+,[%d],%s,=\",\n\t\t\t\t\t\t\tMEMBASE64 (1), MEMINDEX64 (1), size, REG64 (0));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (LSHIFT2_64 (1)) {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%d,%\"PFMT64d\",%s,+\",\n\t\t\t\t\t\t\tMEMBASE64 (1), LSHIFT2_64 (1), MEMDISP64 (1), DECODE_SHIFT64 (1));\n\t\t\t\t} else if ((int)MEMDISP64 (1) < 0) {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%\"PFMT64d\",%s,-\",\n\t\t\t\t\t\t\t-(st64)MEMDISP64 (1), MEMBASE64 (1));\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%\"PFMT64d\",%s,+\",\n\t\t\t\t\t\t\tMEMDISP64 (1), MEMBASE64 (1));\n\t\t\t\t}\n\t\t\t\tr_strbuf_append (&op->esil, \",DUP,tmp,=\");\n\n\t\t\t\t// I assume the DUPs here previously were to handle preindexing\n\t\t\t\t// but it was never finished?\n\t\t\t\tif (ISPREINDEX64 ()) {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \",tmp,%s,=\", REG64 (1));\n\t\t\t\t}\n\n\t\t\t\tr_strbuf_appendf (&op->esil, \",[%d],%s,=\", size, REG64 (0));\n\n\t\t\t\tif (ISPOSTINDEX64 ()) {\n\t\t\t\t\tif (ISREG64 (2)) { // not sure if register valued post indexing exists?\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",tmp,%s,+,%s,=\", REG64 (2), REG64 (1));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",tmp,%\"PFMT64d\",+,%s,=\", IMM64 (2), REG64 (1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\top->refptr = 4;\n\t\t} else {\n\t\t\tif (ISREG64 (1)) {\n\t\t\t\tif (OPCOUNT64 () == 2) {\n\t\t\t\t\tr_strbuf_setf (&op->esil, \"%s,[%d],%s,=\",\n\t\t\t\t\t\tREG64 (1), size, REG64 (0));\n\t\t\t\t} else if (OPCOUNT64 () == 3) {\n\t\t\t\t\t/*\n\t\t\t\t\t\tThis seems like a capstone bug:\n\t\t\t\t\t\tinstructions like\n\t\t\t\t\t\t\tldr x16, [x13, x9]\n\t\t\t\t\t\t\tldrb w2, [x19, x23]\n\t\t\t\t\t\tare not detected as ARM64_OP_MEM type and\n\t\t\t\t\t\tfall in this case instead.\n\t\t\t\t\t*/\n\t\t\t\t\tif (ISREG64 (2)) {\n\t\t\t\t\t\tr_strbuf_setf (&op->esil, \"%s,%s,+,[%d],%s,=\",\n\t\t\t\t\t\t\tREG64 (1), REG64 (2), size, REG64 (0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr_strbuf_setf (&op->esil, \"%\"PFMT64d\",[%d],%s,=\",\n\t\t\t\t\tIMM64 (1), size, REG64 (0));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARM64_INS_LDRSB:\n\tcase ARM64_INS_LDRSH:\n\tcase ARM64_INS_LDRSW:\n\tcase ARM64_INS_LDURSB:\n\tcase ARM64_INS_LDURSH:\n\tcase ARM64_INS_LDURSW:\n\t{\n\t\t// handle the sign extended instrs here\n\t\tint size = 0;\n\t\tswitch (insn->id) {\n\t\tcase ARM64_INS_LDRSB:\n\t\tcase ARM64_INS_LDURSB:\n\t\t\tsize = 1;\n\t\t\tbreak;\n\t\tcase ARM64_INS_LDRSH:\n\t\tcase ARM64_INS_LDURSH:\n\t\t\tsize = 2;\n\t\t\tbreak;\n\t\tcase ARM64_INS_LDRSW:\n\t\tcase ARM64_INS_LDURSW:\n\t\t\tsize = 4;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsize = REGSIZE64 (0);\n\t\t\tbreak;\n\t\t}\n\t\tif (ISMEM64 (1)) {\n\t\t\tif (HASMEMINDEX64 (1)) {\n\t\t\t\tif (LSHIFT2_64 (1) || EXT64 (1)) {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%d,%s,\", size*8, MEMBASE64 (1));\n\t\t\t\t\tARG64_APPEND (&op->esil, 1);\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \",+,[%d],~,%s,=\", size, REG64 (0));\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%d,%s,%s,+,[%d],~,%s,=\",\n\t\t\t\t\t\t\tsize*8, MEMBASE64 (1), MEMINDEX64 (1), size, REG64 (0));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (LSHIFT2_64 (1)) {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%d,%s,%d,%\"PFMT64d\",%s\",\n\t\t\t\t\t\t\tsize*8, MEMBASE64 (1), LSHIFT2_64 (1), MEMDISP64 (1), DECODE_SHIFT64 (1));\n\t\t\t\t} else if ((int)MEMDISP64 (1) < 0) {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%d,%\"PFMT64d\",%s,-\",\n\t\t\t\t\t\t\tsize*8, -(st64)MEMDISP64 (1), MEMBASE64 (1));\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%d,%\"PFMT64d\",%s,+\",\n\t\t\t\t\t\t\tsize*8, MEMDISP64 (1), MEMBASE64 (1));\n\t\t\t\t}\n\n\t\t\t\tr_strbuf_append (&op->esil, \",DUP,tmp,=\");\n\n\t\t\t\t// I assume the DUPs here previously were to handle preindexing\n\t\t\t\t// but it was never finished?\n\t\t\t\tif (ISPREINDEX64 ()) {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \",tmp,%s,=\", REG64 (1));\n\t\t\t\t}\n\n\t\t\t\tr_strbuf_appendf (&op->esil, \",[%d],~,%s,=\", size, REG64 (0));\n\t\t\t\t\n\t\t\t\tif (ISPOSTINDEX64 ()) {\n\t\t\t\t\tif (ISREG64 (2)) { // not sure if register valued post indexing exists?\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",tmp,%s,+,%s,=\", REG64 (2), REG64 (1));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",tmp,%\"PFMT64d\",+,%s,=\", IMM64 (2), REG64 (1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\top->refptr = 4;\n\t\t} else {\n\t\t\tif (ISREG64 (1)) {\n\t\t\t\tif (OPCOUNT64 () == 2) {\n\t\t\t\t\tr_strbuf_setf (&op->esil, \"%d,%s,[%d],~,%s,=\",\n\t\t\t\t\t\tsize * 8, REG64 (1), size, REG64 (0));\n\t\t\t\t} else if (OPCOUNT64 () == 3) {\n\t\t\t\t\t/*\n\t\t\t\t\t\tThis seems like a capstone bug:\n\t\t\t\t\t\tinstructions like\n\t\t\t\t\t\t\tldr x16, [x13, x9]\n\t\t\t\t\t\t\tldrb w2, [x19, x23]\n\t\t\t\t\t\tare not detected as ARM64_OP_MEM type and\n\t\t\t\t\t\tfall in this case instead.\n\t\t\t\t\t*/\n\t\t\t\t\tif (ISREG64 (2)) {\n\t\t\t\t\t\tr_strbuf_setf (&op->esil, \"%d,%s,%s,+,[%d],~,%s,=\",\n\t\t\t\t\t\t\tsize * 8, REG64 (1), REG64 (2), size, REG64 (0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr_strbuf_setf (&op->esil, \"%d,%\"PFMT64d\",[%d],~,%s,=\",\n\t\t\t\t\tsize * 8, IMM64 (1), size, REG64 (0));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARM64_INS_CCMP:\n\tcase ARM64_INS_TST: // cmp w8, 0xd\n\tcase ARM64_INS_CMP: // cmp w8, 0xd\n\t\tARG64_APPEND (&op->esil, 1);\n\t\tCOMMA (&op->esil);\n\t\tARG64_APPEND (&op->esil, 0);\n\t\tr_strbuf_appendf (&op->esil, \",==,$z,zf,:=,%d,$s,nf,:=,%d,$b,!,cf,:=,%d,$o,vf,:=\",\n\t\t\tREGBITS64 (0) - 1, REGBITS64 (0), REGBITS64 (0) - 1);\n\t\n\t\tif (insn->id == ARM64_INS_CCMP || insn->id == ARM64_INS_CCMN) {\n\t\t\tr_strbuf_appendf (&op->esil, \",\");\n\t\t\tarm_prefix_cond (op, insn->detail->arm64.cc);\n\t\t\tr_strbuf_appendf (&op->esil, \"}{,pstate,1,28,1,<<,-,&,28,%\"PFMT64d\",<<,|,pstate,:=\", IMM64 (2));\n\t\t}\n\t\tbreak;\n\tcase ARM64_INS_CMN: \n\tcase ARM64_INS_CCMN:\n\t\tARG64_APPEND (&op->esil, 1);\n\t\tCOMMA (&op->esil);\n\t\tARG64_APPEND (&op->esil, 0);\n\t\tr_strbuf_appendf (&op->esil, \",-1,*,==,$z,zf,:=,%d,$s,nf,:=,%d,$b,!,cf,:=,%d,$o,vf,:=\",\n\t\t\tREGBITS64 (0) - 1, REGBITS64 (0), REGBITS64 (0) - 1);\n\t\n\t\tif (insn->id == ARM64_INS_CCMN) {\n\t\t\tr_strbuf_appendf (&op->esil, \",\");\n\t\t\tarm_prefix_cond (op, insn->detail->arm64.cc);\n\t\t\tr_strbuf_appendf (&op->esil, \"}{,pstate,1,28,1,<<,-,&,28,%\"PFMT64d\",<<,|,pstate,:=\", IMM64 (2));\n\t\t}\n\t\tbreak;\n\tcase ARM64_INS_FCSEL:\n\tcase ARM64_INS_CSEL: // csel Wd, Wn, Wm --> Wd := (cond) ? Wn : Wm\n\t\tr_strbuf_appendf (&op->esil, \"%s,}{,%s,},%s,=\", REG64 (1), REG64 (2), REG64 (0));\n\t\tpostfix = \"\";\n\t\tbreak;\n\tcase ARM64_INS_CSET: // cset Wd --> Wd := (cond) ? 1 : 0\n\t\tr_strbuf_appendf (&op->esil, \"1,}{,0,},%s,=\", REG64 (0));\n\t\tpostfix = \"\";\n\t\tbreak;\n\tcase ARM64_INS_CINC: // cinc Wd, Wn --> Wd := (cond) ? (Wn+1) : Wn\n\t\tr_strbuf_appendf (&op->esil, \"1,%s,+,}{,%s,},%s,=\", REG64 (1), REG64 (1), REG64 (0));\n\t\tpostfix = \"\";\n\t\tbreak;\n\tcase ARM64_INS_CSINC: // csinc Wd, Wn, Wm --> Wd := (cond) ? Wn : (Wm+1)\n\t\tr_strbuf_appendf (&op->esil, \"%s,}{,1,%s,+,},%s,=\", REG64 (1), REG64 (2), REG64 (0));\n\t\tpostfix = \"\";\n\t\tbreak;\n\tcase ARM64_INS_STXRB:\n\tcase ARM64_INS_STXRH:\n\tcase ARM64_INS_STXR:\n\t{\n\t\tint size = (insn->id == ARM64_INS_STXRB)\n\t\t    ? 1: (insn->id == ARM64_INS_STXRH)\n\t\t    ? 2: REGSIZE64 (1);\n\t\tr_strbuf_setf (&op->esil, \"0,%s,=,%s,%s,%\"PFMT64d\",+,=[%d]\",\n\t\t\tREG64 (0), REG64 (1), MEMBASE64 (1), MEMDISP64 (1), size);\n\t\tbreak;\n\t}\n\tcase ARM64_INS_STRB:\n\tcase ARM64_INS_STRH:\n\tcase ARM64_INS_STUR:\n\tcase ARM64_INS_STURB:\n\tcase ARM64_INS_STURH:\n\tcase ARM64_INS_STR: // str x6, [x6,0xf90]\n\t{\n\t\tint size = REGSIZE64 (0);\n\t\tif (insn->id == ARM64_INS_STRB || insn->id == ARM64_INS_STURB) {\n\t\t    size = 1;\n\t\t} else if (insn->id == ARM64_INS_STRH || insn->id == ARM64_INS_STURH) {\n\t\t    size = 2;\n\t\t}\n\t\tif (ISMEM64 (1)) {\n\t\t\tif (HASMEMINDEX64 (1)) {\n\t\t\t\tif (LSHIFT2_64 (1) || EXT64 (1)) {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,\", REG64 (0), MEMBASE64 (1));\n\t\t\t\t\tARG64_APPEND (&op->esil, 1);\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \",+,=[%d]\", size);\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,%s,+,=[%d]\",\n\t\t\t\t\t\t\tREG64 (0), MEMBASE64 (1), MEMINDEX64 (1), size);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (LSHIFT2_64 (1)) {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,%d,%\"PFMT64d\",%s,+\",\n\t\t\t\t\t\t\tREG64 (0), MEMBASE64 (1), LSHIFT2_64 (1), MEMDISP64 (1), DECODE_SHIFT64 (1));\n\t\t\t\t} else if ((int)MEMDISP64 (1) < 0) {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%\"PFMT64d\",%s,-\",\n\t\t\t\t\t\t\tREG64 (0), -(st64)MEMDISP64 (1), MEMBASE64 (1));\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%\"PFMT64d\",%s,+\",\n\t\t\t\t\t\t\tREG64 (0), MEMDISP64 (1), MEMBASE64 (1));\n\t\t\t\t}\n\n\t\t\t\tr_strbuf_append (&op->esil, \",DUP,tmp,=\");\n\n\t\t\t\t// I assume the DUPs here previously were to handle preindexing\n\t\t\t\t// but it was never finished?\n\t\t\t\tif (ISPREINDEX64 ()) {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \",tmp,%s,=\", REG64 (1));\n\t\t\t\t}\n\n\t\t\t\tr_strbuf_appendf (&op->esil, \",=[%d]\", size);\n\n\t\t\t\tif (ISPOSTINDEX64 ()) {\n\t\t\t\t\tif (ISREG64 (2)) { // not sure if register valued post indexing exists?\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",tmp,%s,+,%s,=\", REG64 (2), REG64 (1));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",tmp,%\"PFMT64d\",+,%s,=\", IMM64 (2), REG64 (1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\top->refptr = 4;\n\t\t} else {\n\t\t\tif (ISREG64 (1)) {\n\t\t\t\tif (OPCOUNT64 () == 2) {\n\t\t\t\t\tr_strbuf_setf (&op->esil, \"%s,%s,=[%d]\",\n\t\t\t\t\t\tREG64 (0), REG64 (1), size);\n\t\t\t\t} else if (OPCOUNT64 () == 3) {\n\t\t\t\t\t/*\n\t\t\t\t\t\tThis seems like a capstone bug:\n\t\t\t\t\t\tinstructions like\n\t\t\t\t\t\t\tldr x16, [x13, x9]\n\t\t\t\t\t\t\tldrb w2, [x19, x23]\n\t\t\t\t\t\tare not detected as ARM64_OP_MEM type and\n\t\t\t\t\t\tfall in this case instead.\n\t\t\t\t\t*/\n\t\t\t\t\tif (ISREG64 (2)) {\n\t\t\t\t\t\tr_strbuf_setf (&op->esil, \"%s,%s,%s,+,=[%d]\",\n\t\t\t\t\t\t\tREG64 (0), REG64 (1), REG64 (2), size);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr_strbuf_setf (&op->esil, \"%s,%\"PFMT64d\",=[%d]\",\n\t\t\t\t\tREG64 (0), IMM64 (1), size);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARM64_INS_BIC:\n\tif (OPCOUNT64 () == 2) {\n\t\tif (REGSIZE64 (0) == 4) {\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,0xffffffff,^,%s,&=\",\n\t\t\t\t\tREG64 (1), REG64 (0));\n\t\t} else {\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,0xffffffffffffffff,^,%s,&=\",\n\t\t\t\t\tREG64 (1), REG64 (0));\n\t\t}\n\t} else {\n\t\tif (REGSIZE64 (0) == 4) {\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,0xffffffff,^,%s,&,%s,=\",\n\t\t\t\t\tREG64 (2), REG64 (1), REG64 (0));\n\t\t} else {\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,0xffffffffffffffff,^,%s,&,%s,=\",\n\t\t\t\t\tREG64 (2), REG64 (1), REG64 (0));\n\t\t}\n\t}\n\tbreak;\n\tcase ARM64_INS_CBZ:\n\t\tr_strbuf_setf (&op->esil, \"%s,!,?{,%\"PFMT64d\",pc,=,}\",\n\t\t\t\tREG64 (0), IMM64 (1));\n\t\tbreak;\n\tcase ARM64_INS_CBNZ:\n\t\tr_strbuf_setf (&op->esil, \"%s,?{,%\"PFMT64d\",pc,=,}\",\n\t\t\t\tREG64 (0), IMM64 (1));\n\t\tbreak;\n\tcase ARM64_INS_TBZ:\n\t\t// tbnz x0, 4, label\n\t\t// if ((1<<4) & x0) goto label;\n\t\tr_strbuf_setf (&op->esil, \"%\" PFMT64d \",1,<<,%s,&,!,?{,%\"PFMT64d\",pc,=,}\",\n\t\t\t\tIMM64 (1), REG64 (0), IMM64 (2));\n\t\tbreak;\n\tcase ARM64_INS_TBNZ:\n\t\t// tbnz x0, 4, label\n\t\t// if ((1<<4) & x0) goto label;\n\t\tr_strbuf_setf (&op->esil, \"%\" PFMT64d \",1,<<,%s,&,?{,%\"PFMT64d\",pc,=,}\",\n\t\t\t\tIMM64 (1), REG64 (0), IMM64 (2));\n\t\tbreak;\n\tcase ARM64_INS_STNP:\n\tcase ARM64_INS_STP: // stp x6, x7, [x6,0xf90]\n\t{\n\t\tint disp = (int)MEMDISP64 (2);\n\t\tchar sign = disp>=0?'+':'-';\n\t\tst64 abs = disp>=0? MEMDISP64 (2): -(st64)MEMDISP64 (2);\n\t\tint size = REGSIZE64 (0);\n\t\t// Pre-index case\n\t\tif (ISPREINDEX64 ()) {\n\t\t\t// \"stp x2, x3, [x8, 0x20]!\n\t\t\t// \"32,x8,+=,x2,x8,=[8],x3,x8,8,+,=[8]\",\n\t\t\tr_strbuf_setf(&op->esil,\n\t\t\t\t\t\"%\" PFMT64d \",%s,%c=,%s,%s,=[%d],%s,%s,%d,+,=[%d]\",\n\t\t\t\t\tabs, MEMBASE64 (2), sign,\n\t\t\t\t\tREG64 (0), MEMBASE64 (2), size,\n\t\t\t\t\tREG64 (1), MEMBASE64 (2), size, size);\n\t\t// Post-index case\n\t\t} else if (ISPOSTINDEX64 ()) {\n\t\t\tint val = IMM64 (3);\n\t\t\tsign = val>=0?'+':'-';\n\t\t\tabs = val>=0? val: -val;\n\t\t\t// \"stp x4, x5, [x8], 0x10\"\n\t\t\t// \"x4,x8,=[],x5,x8,8,+,=[],16,x8,+=\"\n\t\t\tr_strbuf_setf(&op->esil,\n\t\t\t\t\t\"%s,%s,=[%d],%s,%s,%d,+,=[%d],%\" PFMT64d \",%s,%c=\",\n\t\t\t\t\tREG64 (0), MEMBASE64 (2), size,\n\t\t\t\t\tREG64 (1), MEMBASE64 (2), size, size,\n\t\t\t\t\tabs, MEMBASE64 (2), sign);\n\t\t// Everything else\n\t\t} else {\n\t\t\tr_strbuf_setf (&op->esil,\n\t\t\t\t\t\"%s,%s,%\"PFMT64d\",%c,=[%d],\"\n\t\t\t\t\t\"%s,%s,%\"PFMT64d\",%c,%d,+,=[%d]\",\n\t\t\t\t\tREG64 (0), MEMBASE64 (2), abs, sign, size,\n\t\t\t\t\tREG64 (1), MEMBASE64 (2), abs, sign, size, size);\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARM64_INS_LDP: // ldp x29, x30, [sp], 0x10\n\t{\n\t\tint disp = (int)MEMDISP64 (2);\n\t\tchar sign = disp>=0?'+':'-';\n\t\tut64 abs = disp>=0? MEMDISP64 (2): -MEMDISP64 (2);\n\t\tint size = REGSIZE64 (0);\n\t\t// Pre-index case\n\t\t// x2,x8,32,+,=[8],x3,x8,32,+,8,+,=[8]\n\t\tif (ISPREINDEX64 ()) {\n\t\t\t// \"ldp x0, x1, [x8, -0x10]!\"\n\t\t\t// 16,x8,-=,x8,[8],x0,=,x8,8,+,[8],x1,=\n\t\t\tr_strbuf_setf (&op->esil,\n\t\t\t\t\t\"%\"PFMT64d\",%s,%c=,\"\n\t\t\t\t\t\"%s,[%d],%s,=,\"\n\t\t\t\t\t\"%d,%s,+,[%d],%s,=\",\n\t\t\t\t\tabs, MEMBASE64 (2), sign,\n\t\t\t\t\tMEMBASE64 (2), size, REG64 (0),\n\t\t\t\t\tsize, MEMBASE64 (2), size, REG64 (1));\n\t\t// Post-index case\n\t\t} else if (ISPOSTINDEX64 ()) {\n\t\t\tint val = IMM64 (3);\n\t\t\tsign = val>=0?'+':'-';\n\t\t\tabs = val>=0? val: -val;\n\t\t\t// ldp x4, x5, [x8], -0x10\n\t\t\t// x8,[8],x4,=,x8,8,+,[8],x5,=,16,x8,+=\n\t\t\tr_strbuf_setf (&op->esil,\n\t\t\t\t\t\"%s,[%d],%s,=,\"\n\t\t\t\t\t\"%s,%d,+,[%d],%s,=,\"\n\t\t\t\t\t\"%\" PFMT64d \",%s,%c=\",\n\t\t\t\t\tMEMBASE64 (2), size, REG64 (0),\n\t\t\t\t\tMEMBASE64 (2), size, size, REG64 (1),\n\t\t\t\t\tabs, MEMBASE64 (2), sign);\n\t\t} else {\n\t\t\tr_strbuf_setf (&op->esil,\n\t\t\t\t\t\"%\"PFMT64d\",%s,%c,[%d],%s,=,\"\n\t\t\t\t\t\"%d,%\"PFMT64d\",%s,%c,+,[%d],%s,=\",\n\t\t\t\t\tabs, MEMBASE64 (2), sign, size, REG64 (0),\n\t\t\t\t\tsize, abs, MEMBASE64 (2), sign, size, REG64 (1));\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARM64_INS_ADRP:\n\t\tr_strbuf_setf (&op->esil, \"%\"PFMT64d\",%s,=\",\n\t\t\t\tIMM64 (1), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_EXTR:\n\t\t// from VEX\n\t\t/*\n\t\t\t01 | t0 = GET:I64(x4)\n\t\t\t02 | t1 = GET:I64(x0)\n\t\t\t03 | t4 = Shr64(t1,0x20)\n\t\t\t04 | t5 = Shl64(t0,0x20)\n\t\t\t05 | t3 = Or64(t5,t4)\n\t\t\t06 | PUT(x4) = t3\n\t\t*/\n\t\tr_strbuf_setf (&op->esil, \"%\" PFMT64d \",%s,>>,%\" PFMT64d \",%s,<<,|,%s,=\",\n\t\t\tIMM64 (3), REG64 (2), IMM64 (3), REG64 (1), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_RBIT:\n\t\t// slightly shorter expression to reverse bits\n\t\tr_strbuf_setf (&op->esil, \"0,tmp,=,0,DUP,DUP,DUP,%d,-,%s,>>,1,&,<<,tmp,+=,%d,-,?{,++,4,GOTO,},tmp,%s,=\",\n\t\t\tREGBITS64 (1)-1, REG64 (1), REGBITS64 (1)-1, REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_MVN:\n\tcase ARM64_INS_MOVN:\n\t{\n\t\tcs_arm64_op dst = INSOP64 (0);\n\t\tcs_arm64_op src = INSOP64 (1);\n\n\t\tif (dst.vas && src.vas) {\n\t\t\tr_strbuf_setf (&op->esil, \"%sh,-1,^,%sh,=,%sl,-1,^,%sl,=\",\n\t\t\t\tREG64 (1), REG64 (0), REG64 (1), REG64 (0));\n\t\t} else {\n\t\t\tARG64_APPEND (&op->esil, 1);\n\t\t\tr_strbuf_appendf (&op->esil, \",-1,^,\");\n\t\t\tVEC64_DST_APPEND (&op->esil, 0, -1);\n\t\t\tr_strbuf_appendf (&op->esil, \",=\");\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARM64_INS_MOVK: // movk w8, 0x1290\n\t{\n\t\tut64 shift = LSHIFT2_64 (1);\n\t\tif (shift < 0) {\n\t\t\tshift = 0;\n\t\t} else if (shift > 48) {\n\t\t\tshift = 48;\n\t\t}\n\t\tut64 shifted_imm = IMM64 (1) << shift;\n\t\tut64 mask = ~(0xffffULL << shift);\n\n\t\tr_strbuf_setf (&op->esil, \"0x%\"PFMT64x\",%s,&,%\"PFMT64u\",|,%s,=\",\n\t\t\tmask,\n\t\t\tREG64 (0),\n\t\t\tshifted_imm,\n\t\t\tREG64 (0));\n\n\t\tbreak;\n\t}\n\tcase ARM64_INS_MOVZ:\n\t\tr_strbuf_setf (&op->esil, \"%\"PFMT64u\",%s,=\",\n\t\t\tSHIFTED_IMM64 (1, REGSIZE64 (0)*8),\n\t\t\tREG64 (0));\n\t\tbreak;\n\t/* ASR, SXTB, SXTH and SXTW are alias for SBFM */\n\tcase ARM64_INS_ASR:\n\t{\n\t\t//OPCALL (\">>>>\");\n\t\tconst char *r0 = REG64 (0);\n\t\tconst char *r1 = REG64 (1);\n\t\tconst int size = REGSIZE64 (0)*8;\n\n\t\tif (ISREG64 (2)) {\n\t\t\tif (LSHIFT2_64 (2)) {\n\t\t\t\tARG64_APPEND (&op->esil, 2);\n\t\t\t\tr_strbuf_appendf (&op->esil, \",%d,%%,%s,>>>>,%s,=\", size, r1, r0);\n\t\t\t} else {\n\t\t\t\tconst char *r2 = REG64 (2);\n\t\t\t\tr_strbuf_setf (&op->esil, \"%d,%s,%%,%s,>>>>,%s,=\", size, r2, r1, r0);\n\t\t\t}\n\t\t} else {\n\t\t\tut64 i2 = IMM64 (2);\n\t\t\tr_strbuf_setf (&op->esil, \"%\"PFMT64d\",%s,>>>>,%s,=\", i2 % (ut64)size, r1, r0);\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARM64_INS_SXTB:\n\t\tif (arm64_reg_width(REGID64 (0)) == 32) {\n\t\t\tr_strbuf_setf (&op->esil, \"0xffffffff,8,0xff,%s,&,~,&,%s,=\",\n\t\t\t\tREG64 (1), REG64 (0));\n\t\t} else {\n\t\t\tr_strbuf_setf (&op->esil, \"8,0xff,%s,&,~,%s,=\",\n\t\t\t\tREG64 (1), REG64 (0));\n\t\t}\n\t\tbreak;\n\tcase ARM64_INS_SXTH: /* halfword */\n\t\tif (arm64_reg_width(REGID64 (0)) == 32) {\n\t\t\tr_strbuf_setf (&op->esil, \"0xffffffff,16,0xffff,%s,&,~,&,%s,=\",\n\t\t\t\tREG64 (1), REG64 (0));\n\t\t} else {\n\t\t\tr_strbuf_setf (&op->esil, \"16,0xffff,%s,&,~,%s,=\",\n\t\t\t\tREG64 (1), REG64 (0));\n\t\t}\n\t\tbreak;\n\tcase ARM64_INS_SXTW: /* word */\n\t\tr_strbuf_setf (&op->esil, \"32,0xffffffff,%s,&,~,%s,=\",\n\t\t\t\tREG64 (1), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_UXTB:\n\t\tr_strbuf_setf (&op->esil, \"%s,0xff,&,%s,=\", REG64 (1), REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_UXTH:\n\t\tr_strbuf_setf (&op->esil, \"%s,0xffff,&,%s,=\", REG64 (1), REG64 (0));\n\t\tbreak;\n#if CS_API_MAJOR > 4\n\tcase ARM64_INS_RETAA:\n\tcase ARM64_INS_RETAB:\n\tcase ARM64_INS_ERETAA:\n\tcase ARM64_INS_ERETAB:\n#endif\n\tcase ARM64_INS_RET:\n\t\tr_strbuf_setf (&op->esil, \"lr,pc,=\");\n\t\tbreak;\n\tcase ARM64_INS_ERET:\n\t\tr_strbuf_setf (&op->esil, \"lr,pc,=\");\n\t\tbreak;\n\tcase ARM64_INS_BFI: // bfi w8, w8, 2, 1\n\tcase ARM64_INS_BFXIL:\n\t{\n\t\tif (OPCOUNT64 () >= 3 && ISIMM64 (3) && IMM64 (3) > 0) {\n\t\t\tsize_t index = IMM64 (3) - 1;\n\t\t\tif (index >= BITMASK_BY_WIDTH_COUNT) {\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\tut64 mask = bitmask_by_width[index];\n\t\t\tut64 shift = IMM64 (2);\n\t\t\tut64 notmask = ~(mask << shift);\n\t\t\t// notmask,dst,&,lsb,mask,src,&,<<,|,dst,=\n\t\t\tr_strbuf_setf (&op->esil, \"%\"PFMT64u\",%s,&,%\"PFMT64u\",%\"PFMT64u\",%s,&,<<,|,%s,=\",\n\t\t\t\tnotmask, REG64 (0), shift, mask, REG64 (1), REG64 (0));\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARM64_INS_SBFIZ:\n\t\tif (IMM64 (3) > 0 && IMM64 (3) <= 64 - IMM64 (2)) {\n\t\t\tsize_t index = IMM64 (3) - 1;\n\t\t\tif (index >= BITMASK_BY_WIDTH_COUNT) {\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\tr_strbuf_appendf (&op->esil, \"%\" PFMT64d \",%\" PFMT64d \",%s,%\"PFMT64u\",&,~,<<,%s,=\",\n\t\t\t\t\tIMM64 (2), IMM64 (3), REG64 (1), (ut64)bitmask_by_width[index], REG64 (0));\n\t\t}\n\t\tbreak;\n\tcase ARM64_INS_UBFIZ:\n\t\tif (IMM64 (3) > 0 && IMM64 (3) <= 64 - IMM64 (2)) {\n\t\t\tsize_t index = IMM64 (3) - 1;\n\t\t\tif (index >= BITMASK_BY_WIDTH_COUNT) {\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\tr_strbuf_appendf (&op->esil, \"%\" PFMT64d \",%s,%\"PFMT64u\",&,<<,%s,=\",\n\t\t\t\t\tIMM64 (2), REG64 (1), (ut64)bitmask_by_width[index], REG64 (0));\n\t\t}\n\t\tbreak;\n\tcase ARM64_INS_SBFX:\n\t\tif (IMM64 (3) > 0 && IMM64 (3) <= 64 - IMM64 (2)) {\n\t\t\tsize_t index = IMM64 (3) - 1;\n\t\t\tif (index >= BITMASK_BY_WIDTH_COUNT) {\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\tr_strbuf_appendf (&op->esil, \"%\" PFMT64d \",%\" PFMT64d \",%s,%\" PFMT64d \",%\"PFMT64u\",<<,&,>>,~,%s,=\",\n\t\t\t\tIMM64 (3), IMM64 (2), REG64 (1), IMM64 (2) , (ut64)bitmask_by_width[index], REG64 (0));\n\t\t}\n\t\tbreak;\n\tcase ARM64_INS_UBFX:\n\t\tif (IMM64 (3) > 0 && IMM64 (3) <= 64 - IMM64 (2)) {\n\t\t\tsize_t index = IMM64 (3) - 1;\n\t\t\tif (index >= BITMASK_BY_WIDTH_COUNT) {\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\tr_strbuf_appendf (&op->esil, \"%\" PFMT64d \",%s,%\" PFMT64d \",%\"PFMT64u\",<<,&,>>,%s,=\",\n\t\t\t\tIMM64 (2), REG64 (1), IMM64 (2) , (ut64)bitmask_by_width[index], REG64 (0));\n\t\t}\n\t\tbreak;\n\tcase ARM64_INS_NEG:\n#if CS_API_MAJOR > 3\n\tcase ARM64_INS_NEGS:\n#endif\n\t\tARG64_APPEND (&op->esil, 1);\n\t\tr_strbuf_appendf (&op->esil, \",0,-,%s,=\", REG64 (0));\n\t\tbreak;\n\tcase ARM64_INS_SVC:\n\t\tr_strbuf_setf (&op->esil, \"%\" PFMT64u \",$\", IMM64 (0));\n\t\tbreak;\n\t}\n\n\tr_strbuf_append (&op->esil, postfix);\n\n\treturn 0;\n}\n\n#define MATH32(opchar) arm32math(a, op, addr, buf, len, handle, insn, pcdelta, str, opchar, 0)\n#define MATH32_NEG(opchar) arm32math(a, op, addr, buf, len, handle, insn, pcdelta, str, opchar, 1)\n#define MATH32AS(opchar) arm32mathaddsub(a, op, addr, buf, len, handle, insn, pcdelta, str, opchar)\n\nstatic void arm32math(RAnal *a, RAnalOp *op, ut64 addr, const ut8 *buf, int len, csh *handle, cs_insn *insn, int pcdelta, char(*str)[32], const char *opchar, int negate) {\n\tconst char *dest = ARG(0);\n\tconst char *op1;\n\tconst char *op2;\n\tbool rotate_imm = OPCOUNT() > 3;\n\tif (OPCOUNT() > 2) {\n\t\t op1 = ARG(1);\n\t\t op2 = ARG(2);\n\t} else {\n\t\top1 = dest;\n\t\top2 = ARG(1);\n\t}\n\t// right operand\n\tif (rotate_imm) {\n\t\tr_strbuf_appendf (&op->esil, \"%s,\", ARG(3));\n\t}\n\tif (!strcmp (op2, \"pc\")) {\n\t\tr_strbuf_appendf (&op->esil, \"%d,$$,+\", pcdelta);\n\t} else {\n\t\tr_strbuf_appendf (&op->esil, \"%s\", op2);\n\t}\n\tif (rotate_imm) {\n\t\tr_strbuf_appendf (&op->esil, \",>>>\");\n\t}\n\tif (negate) {\n\t\tr_strbuf_appendf (&op->esil, \",-1,^\");\n\t}\n\tif (!strcmp (op1, \"pc\")) {\n\t\tr_strbuf_appendf (&op->esil, \",%d,$$,+,%s,0xffffffff,&,%s,=\", pcdelta, opchar, dest);\n\t} else {\n\t\tif (ISSHIFTED(1)) {\n\t\t\tr_strbuf_appendf (&op->esil, \",0xffffffff,&,%s,=\", dest);\n\t\t} else {\n\t\t\tr_strbuf_appendf (&op->esil, \",%s,%s,0xffffffff,&,%s,=\", op1, opchar, dest);\n\t\t}\n\t}\n}\n\nstatic void arm32mathaddsub(RAnal *a, RAnalOp *op, ut64 addr, const ut8 *buf, int len, csh *handle, cs_insn *insn, int pcdelta, char(*str)[32], const char *opchar) {\n\tconst char *dst = ARG (0);\n\tconst char *src;\n\tbool noflags = false;\n\tif (!strcmp (dst, \"pc\")) {\t//this is because strbuf_prepend doesn't exist and E_TOO_LAZY\n\t\t//\t\tr_strbuf_append (&op->esil, \"$$,pc,=,\");\n\t\tnoflags = true;\n\t}\n\tif (OPCOUNT () == 3) {\n\t\tr_strbuf_appendf (&op->esil, \"%s,0xffffffff,&,%s,=,\", ARG (1), dst);\n\t\tsrc = ARG (2);\n\t} else {\n\t\t//\t\tsrc = (!strcmp (ARG(1), \"pc\"))? \"$$\": ARG(1);\n\t\tsrc = ARG (1);\n\t}\n\tr_strbuf_appendf (&op->esil, \"%s,%s,%s,0xffffffff,&,%s,=\", src, dst, opchar, dst);\n\tif (noflags) {\n\t\treturn;\n\t}\n\tr_strbuf_appendf (&op->esil, \",$z,zf,:=,%s,cf,:=,vf,=,0,nf,=\",\n\t\t(!strcmp (opchar, \"+\")? \"30,$c,31,$c,^,31,$c\": \"30,$c,31,$c,^,32,$b\"));\n}\n\nstatic int analop_esil(RAnal *a, RAnalOp *op, ut64 addr, const ut8 *buf, int len, csh *handle, cs_insn *insn, bool thumb) {\n\tint i;\n\tconst char *postfix = NULL;\n\tchar str[32][32];\n\tint msr_flags;\n\tint pcdelta = (thumb? 4: 8);\n\tut32 mask = UT32_MAX;\n\tint str_ldr_bytes = 4;\n\tunsigned int width = 0;\n\n\tr_strbuf_init (&op->esil);\n\tr_strbuf_set (&op->esil, \"\");\n\tpostfix = arm_prefix_cond (op, insn->detail->arm.cc);\n\n\tswitch (insn->id) {\n\tcase ARM_INS_CLZ:\n\t\tr_strbuf_appendf (&op->esil, \"%s,!,?{,32,%s,=,BREAK,},0,%s,=,%s,%s,<<,0x80000000,&,!,?{,1,%s,+=,11,GOTO,}\", REG (1), REG (0), REG (0), REG (0), REG (1), REG (0));\n\t\tbreak;\n\tcase ARM_INS_IT:\n\t\tr_strbuf_appendf (&op->esil, \"2,$$,+,pc,=\");\n\t\tbreak;\n\tcase ARM_INS_BKPT:\n\t\tr_strbuf_setf (&op->esil, \"%d,%d,TRAP\", IMM (0), IMM (0));\n\t\tbreak;\n\tcase ARM_INS_NOP:\n\t\tr_strbuf_setf (&op->esil, \",\");\n\t\tbreak;\n\tcase ARM_INS_BL:\n\tcase ARM_INS_BLX:\n\t\tr_strbuf_appendf (&op->esil, \"pc,%d,+,lr,=,\", thumb);\n\t\t/* fallthrough */\n\tcase ARM_INS_BX:\n\tcase ARM_INS_BXJ:\n\tcase ARM_INS_B:\n\t\tif (ISREG (0) && REGID (0) == ARM_REG_PC) {\n\t\t\tr_strbuf_appendf (&op->esil, \"0x%\" PFMT64x \",pc,=\",\n\t\t\t\t(ut64)((addr & ~3LL) + pcdelta));\n\t\t} else {\n\t\t\tif (ISIMM (0)) {\n\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,pc,=\", ARG (0));\n\t\t\t} else {\n\t\t\t\tr_strbuf_appendf (&op->esil, \"%d,%s,-,pc,=\", thumb, ARG (0));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_UDF:\n\t\tr_strbuf_setf (&op->esil, \"%s,TRAP\", ARG (0));\n\t\tbreak;\n\tcase ARM_INS_SADD16:\n\tcase ARM_INS_SADD8:\n\t\tMATH32AS (\"+\");\n\t\tbreak;\n\tcase ARM_INS_ADDW:\n\tcase ARM_INS_ADD:\n\t\tMATH32 (\"+\");\n\t\tbreak;\n\tcase ARM_INS_ADC:\n\t\tif (OPCOUNT () == 2) {\n\t\t\tr_strbuf_appendf (&op->esil, \"cf,%s,+=,%s,%s,+=\", ARG (0), ARG (1), ARG (0));\n\t\t} else {\n\t\t\tr_strbuf_appendf (&op->esil, \"cf,%s,+=,%s,%s,+,%s,+=\", ARG (0), ARG (2), ARG (1), ARG (0));\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_SSUB16:\n\tcase ARM_INS_SSUB8:\n\t\tMATH32AS (\"-\");\n\t\tbreak;\n\tcase ARM_INS_SUBW:\n\tcase ARM_INS_SUB:\n\t\tMATH32 (\"-\");\n\t\tbreak;\n\tcase ARM_INS_SBC:\n\t\tif (OPCOUNT () == 2) {\n\t\t\tr_strbuf_appendf (&op->esil, \"cf,%s,-=,%s,%s,-=\", ARG (0), ARG (1), ARG (0));\n\t\t} else {\n\t\t\tr_strbuf_appendf (&op->esil, \"cf,%s,-=,%s,%s,+,%s,-=\", ARG (0), ARG (2), ARG (1), ARG (0));\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_MUL:\n\t\tMATH32 (\"*\");\n\t\tbreak;\n\tcase ARM_INS_AND:\n\t\tMATH32 (\"&\");\n\t\tbreak;\n\tcase ARM_INS_ORR:\n\t\tMATH32 (\"|\");\n\t\tbreak;\n\tcase ARM_INS_EOR:\n\t\tMATH32 (\"^\");\n\t\tbreak;\n\tcase ARM_INS_ORN:\n\t\tMATH32_NEG (\"|\");\n\t\tbreak;\n\tcase ARM_INS_LSR:\n\t\tif (insn->detail->arm.update_flags) {\n\t\t\tif (OPCOUNT () == 2) {\n\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,!,!,?{,%s,1,%s,-,0x1,<<,&,!,!,cf,:=,},\", ARG (1), ARG (0), ARG (1));\n\t\t\t} else {\n\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,!,!,?{,%s,1,%s,-,0x1,<<,&,!,!,cf,:=,},\", ARG (2), ARG (1), ARG (2));\n\t\t\t}\n\t\t}\n\t\tMATH32 (\">>\");\n\t\tbreak;\n\tcase ARM_INS_LSL:\n\t\tif (insn->detail->arm.update_flags) {\n\t\t\tif (OPCOUNT () == 2) {\n\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,!,!,?{,%s,32,-,%s,>>,cf,:=,},\", ARG (1), ARG (1), ARG (0));\n\t\t\t} else {\n\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,!,!,?{,%s,32,-,%s,>>,cf,:=,},\", ARG (2), ARG (2), ARG (1));\n\t\t\t}\n\t\t}\n\t\tMATH32 (\"<<\");\n\t\tbreak;\n\tcase ARM_INS_SVC:\n\t\tr_strbuf_setf (&op->esil, \"%s,$\", ARG (0));\n\t\tbreak;\n\tcase ARM_INS_PUSH:\n#if 0\nPUSH { r4, r5, r6, r7, lr }\n4,sp,-=,lr,sp,=[4],\n4,sp,-=,r7,sp,=[4],\n4,sp,-=,r6,sp,=[4],\n4,sp,-=,r5,sp,=[4],\n4,sp,-=,r4,sp,=[4]\n\n20,sp,-=,lr,r7,r6,r5,r4,5,sp,=[*]\n#endif\n\t\tr_strbuf_appendf (&op->esil, \"%d,sp,-=,\",\n\t\t\t4 * insn->detail->arm.op_count);\n\t\tfor (i = insn->detail->arm.op_count; i > 0; i--) {\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,\", REG (i - 1));\n\t\t}\n\t\tr_strbuf_appendf (&op->esil, \"%d,sp,=[*]\",\n\t\t\tinsn->detail->arm.op_count);\n\t\tbreak;\n\tcase ARM_INS_STMDA:\n\tcase ARM_INS_STMDB:\n\tcase ARM_INS_STM:\n\tcase ARM_INS_STMIB: {\n\t\tint direction = (insn->id == ARM_INS_STMDA || insn->id == ARM_INS_STMDB ? -1 : 1);\n\t\tint offset = direction > 0 ? -1 : -insn->detail->arm.op_count;\n\t\tif (insn->id == ARM_INS_STMDA || insn->id == ARM_INS_STMIB) {\n\t\t\toffset++;\n\t\t}\n\t\tfor (i = 1; i < insn->detail->arm.op_count; i++) {\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,%d,+,=[4],\",\n\t\t\t\tREG (i), ARG (0), (i + offset) * 4);\n\t\t}\n\t\tif (insn->detail->arm.writeback == true) { //writeback, reg should be incremented\n\t\t\tr_strbuf_appendf (&op->esil, \"%d,%s,+=,\",\n\t\t\t\tdirection * (insn->detail->arm.op_count - 1) * 4, ARG (0));\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARM_INS_VSTMIA:\n\t\tr_strbuf_set (&op->esil, \"\");\n\t\twidth = 0;\n\t\tfor (i = 1; i < insn->detail->arm.op_count; i++) {\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,%d,%s,+,=[%d],\",\n\t\t\t\tREG (i), width, ARG (0), REGSIZE32(i));\n\t\t\twidth += REGSIZE32(i);\n\t\t}\n\t\t// increment if writeback\n\t\tif (insn->detail->arm.writeback) {\n\t\t\tr_strbuf_appendf (&op->esil, \"%d,%s,+=,\", width, ARG (0));\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_VSTMDB:\n\t\tr_strbuf_set (&op->esil, \"\");\n\t\twidth = 0;\n\t\tfor (i = insn->detail->arm.op_count - 1; i > 0; i--) {\n\t\t\twidth += REGSIZE32(i);\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,%d,%s,-,=[%d],\",\n\t\t\t\tREG (i), width, ARG (0), REGSIZE32(i));\n\t\t}\n\t\t// decrement writeback is mandatory for VSTMDB\n\t\tr_strbuf_appendf (&op->esil, \"%d,%s,-=,\", width, ARG (0));\n\t\tbreak;\n\tcase ARM_INS_VLDMIA:\n\t\tr_strbuf_set (&op->esil, \"\");\n\t\twidth = 0;\n\t\tfor (i = 1; i < insn->detail->arm.op_count; i++) {\n\t\t\tr_strbuf_appendf (&op->esil, \"%d,%s,+,[%d],%s,=,\",\n\t\t\t\twidth, ARG (0), REGSIZE32(i), REG (i));\n\t\t\twidth += REGSIZE32(i);\n\t\t}\n\t\t// increment if writeback\n\t\tif (insn->detail->arm.writeback) {\n\t\t\tr_strbuf_appendf (&op->esil, \"%d,%s,+=,\", width, ARG (0));\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_VLDMDB:\n\t\tr_strbuf_set (&op->esil, \"\");\n\t\twidth = 0;\n\t\tfor (i = insn->detail->arm.op_count - 1; i > 0; i--) {\n\t\t\twidth += REGSIZE32(i);\n\t\t\tr_strbuf_appendf (&op->esil, \"%d,%s,-,[%d],%s,=,\",\n\t\t\t\twidth, ARG (0), REGSIZE32(i), REG (i));\n\t\t}\n\t\t// decrement writeback is mandatory for VLDMDB\n\t\tr_strbuf_appendf (&op->esil, \"%d,%s,-=,\", width, ARG (0));\n\t\tbreak;\n\tcase ARM_INS_ASR:\n\t\t// suffix 'S' forces conditional flag to be updated\n\t\tif (insn->detail->arm.update_flags) {\n\t\t\tif (OPCOUNT () == 2) {\n\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,!,!,?{,%s,1,%s,-,0x1,<<,&,!,!,cf,:=,},\", ARG (1), ARG (0), ARG (1));\n\t\t\t} else if (OPCOUNT () == 3) {\n\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,!,!,?{,%s,1,%s,-,0x1,<<,&,!,!,cf,:=,},\", ARG (2), ARG (1), ARG (2));\n\t\t\t}\n\t\t}\n\t\tif (OPCOUNT () == 2) {\n\t\t\tif (ISSHIFTED (1)) {\n\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,=\", ARG (1), ARG (0));\n\t\t\t} else {\n\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,>>>>,%s,=\", ARG (1), ARG (0), ARG (0));\n\t\t\t}\n\t\t} else if (OPCOUNT () == 3) {\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,>>>>,%s,=\", ARG (2), ARG (1), ARG (0));\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_POP:\n#if 0\nPOP { r4,r5, r6}\nr6,r5,r4,3,sp,[*],12,sp,+=\n#endif\n\t\tfor (i = insn->detail->arm.op_count; i > 0; i--) {\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,\", REG (i - 1));\n\t\t}\n\t\tr_strbuf_appendf (&op->esil, \"%d,sp,[*],\",\n\t\t\tinsn->detail->arm.op_count);\n\t\tr_strbuf_appendf (&op->esil, \"%d,sp,+=\",\n\t\t\t4 * insn->detail->arm.op_count);\n\t\tbreak;\n\tcase ARM_INS_LDMDA:\n\tcase ARM_INS_LDMDB:\n\tcase ARM_INS_LDM:\n\tcase ARM_INS_LDMIB: {\n\t\tint direction = (insn->id == ARM_INS_LDMDA || insn->id == ARM_INS_LDMDB) ? -1 : 1;\n\t\tint offset = direction > 0 ? -1 : -insn->detail->arm.op_count;\n\t\tif (insn->id == ARM_INS_LDMDA || insn->id == ARM_INS_LDMIB) {\n\t\t\toffset++;\n\t\t}\n\t\tfor (i = 1; i < insn->detail->arm.op_count; i++) {\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,%d,+,[4],%s,=,\", ARG (0), (i + offset) * 4, REG (i));\n\t\t}\n\t\tif (insn->detail->arm.writeback) {\n\t\t\tr_strbuf_appendf (&op->esil, \"%d,%s,+=,\",\n\t\t\t\tdirection * (insn->detail->arm.op_count - 1) * 4, ARG (0));\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARM_INS_CMP:\n\t\tr_strbuf_appendf (&op->esil, \"%s,%s,==\", ARG (1), ARG (0));\n\t\tbreak;\n\tcase ARM_INS_CMN:\n\t\tr_strbuf_appendf (&op->esil, \"%s,%s,^,!,!,zf,=\", ARG (1), ARG (0));\n\t\tbreak;\n\tcase ARM_INS_MOVT:\n\t\tr_strbuf_appendf (&op->esil, \"16,%s,<<,%s,|=\", ARG (1), REG (0));\n\t\tbreak;\n\tcase ARM_INS_ADR:\n\t\tr_strbuf_appendf (&op->esil, \"%d,$$,+,%s,+,0xfffffffc,&,%s,=\",\n\t\t\tpcdelta, ARG (1), REG (0));\n\t\tbreak;\n\tcase ARM_INS_MOV:\n\tcase ARM_INS_VMOV:\n\tcase ARM_INS_MOVW:\n\t\tif (a->bits == 16) {\n\t\t\tMATH32 (\"=\");\n\t\t} else {\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,=\", ARG (1), REG (0));\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_CBZ:\n\t\tr_strbuf_appendf (&op->esil, \"%s,!,?{,%\" PFMT32u \",pc,=,}\",\n\t\t\tREG (0), IMM (1));\n\t\tbreak;\n\tcase ARM_INS_CBNZ:\n\t\tr_strbuf_appendf (&op->esil, \"%s,?{,%\" PFMT32u \",pc,=,}\",\n\t\t\tREG (0), IMM (1));\n\t\tbreak;\n\t\t// Encapsulated STR/H/B into a code section\n\tcase ARM_INS_STRT:\n\tcase ARM_INS_STR:\n\tcase ARM_INS_STRHT:\n\tcase ARM_INS_STRH:\n\tcase ARM_INS_STRBT:\n\tcase ARM_INS_STRB:\n\tcase ARM_INS_STRD:\n\t//case ARM_INS_STLXRB: // capstone has no STLXR?\n\t\tswitch (insn->id) {\n\t\tcase ARM_INS_STRD:\n\t\t\tstr_ldr_bytes = 8; // just an indication, won't be used in esil code\n\t\t\tbreak;\n\t\tcase ARM_INS_STRHT:\n\t\tcase ARM_INS_STRH:\n\t\t\tstr_ldr_bytes = 2;\n\t\t\tbreak;\n\t\tcase ARM_INS_STRBT:\n\t\tcase ARM_INS_STRB:\n\t\t\tstr_ldr_bytes = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstr_ldr_bytes = 4;\n\t\t}\n\t\tif (OPCOUNT() == 2) {\n\t\t\tif (ISMEM(1) && !HASMEMINDEX(1)) {\n\t\t\t\tint disp = MEMDISP(1);\n\t\t\t\tchar sign = disp>=0?'+':'-';\n\t\t\t\tdisp = disp>=0?disp:-disp;\n\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,0x%x,%s,%c,0xffffffff,&,=[%d]\",\n\t\t\t\t\t\t  REG(0), disp, MEMBASE(1), sign, str_ldr_bytes);\n\t\t\t\tif (insn->detail->arm.writeback) {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \",%d,%s,%c,%s,=\",\n\t\t\t\t\t\t\t  disp, MEMBASE(1), sign, MEMBASE(1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (HASMEMINDEX(1)) {\t// e.g. 'str r2, [r3, r1]'\n\t\t\t\tif (ISSHIFTED(1)) { // e.g. 'str r2, [r3, r1, lsl 4]'\n\t\t\t\t\tswitch (SHIFTTYPE(1)) {\n\t\t\t\t\tcase ARM_SFT_LSL:\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,%d,%s,<<,+,0xffffffff,&,=[%d]\",\n\t\t\t\t\t\t\t\t  REG(0), MEMBASE(1), SHIFTVALUE(1), MEMINDEX(1), str_ldr_bytes);\n\t\t\t\t\t\tif (insn->detail->arm.writeback) { // e.g. 'str r2, [r3, r1, lsl 4]!'\n\t\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",%s,%d,%s,<<,+,%s,=\",\n\t\t\t\t\t\t\t\t\t  MEMBASE(1), SHIFTVALUE(1), MEMINDEX(1), MEMBASE(1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ARM_SFT_LSR:\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,%d,%s,>>,+,0xffffffff,&,=[%d]\",\n\t\t\t\t\t\t\t\t  REG(0), MEMBASE(1), SHIFTVALUE(1), MEMINDEX(1), str_ldr_bytes);\n\t\t\t\t\t\tif (insn->detail->arm.writeback) {\n\t\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",%s,%d,%s,>>,+,%s,=\",\n\t\t\t\t\t\t\t\t\t  MEMBASE(1), SHIFTVALUE(1), MEMINDEX(1), MEMBASE(1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ARM_SFT_ASR:\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,%d,%s,>>>>,+,0xffffffff,&,=[%d]\",\n\t\t\t\t\t\t\t\t  REG(0), MEMBASE(1), SHIFTVALUE(1), MEMINDEX(1), str_ldr_bytes);\n\t\t\t\t\t\tif (insn->detail->arm.writeback) {\n\t\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",%s,%d,%s,>>>>,+,%s,=\",\n\t\t\t\t\t\t\t\t\t  MEMBASE(1), SHIFTVALUE(1), MEMINDEX(1), MEMBASE(1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ARM_SFT_ROR:\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,%d,%s,>>>,+,0xffffffff,&,=[%d]\",\n\t\t\t\t\t\t\t\t  REG(0), MEMBASE(1), SHIFTVALUE(1), MEMINDEX(1), str_ldr_bytes);\n\t\t\t\t\t\tif (insn->detail->arm.writeback) {\n\t\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",%s,%d,%s,>>>,+,%s,=\",\n\t\t\t\t\t\t\t\t\t  MEMBASE(1), SHIFTVALUE(1), MEMINDEX(1), MEMBASE(1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ARM_SFT_RRX: // ROR with single bit shift, using previous cf rather than new cf\n\t\t\t\t\t\t//TODO: r2 doesn't mark this as a shift, it falls through to no shift\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// Hopefully nothing here\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else { // No shift\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,%s,+,0xffffffff,&,=[%d]\",\n\t\t\t\t\t\t\t  REG(0), MEMINDEX(1), MEMBASE(1), str_ldr_bytes);\n\t\t\t\t\tif (insn->detail->arm.writeback) {\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",%s,%s,+,%s,=\",\n\t\t\t\t\t\t\t\t  MEMINDEX(1), MEMBASE(1), MEMBASE(1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (OPCOUNT() == 3) { // e.g. 'str r2, [r3], 4\n\t\t\tif (ISIMM(2)) { // e.g. 'str r2, [r3], 4\n\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,0xffffffff,&,=[%d],%d,%s,+=\",\n\t\t\t\t\t       REG(0), MEMBASE(1), str_ldr_bytes, IMM(2), MEMBASE(1));\n\t\t\t}\n\t\t\tif (ISREG(2)) { // e.g. 'str r2, [r3], r1\n\t\t\t\tif (ISSHIFTED(2)) { // e.g. 'str r2, [r3], r1, lsl 4'\n\t\t\t\t\tswitch (SHIFTTYPE(2)) {\n\t\t\t\t\tcase ARM_SFT_LSL:\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,0xffffffff,&,=[%d],%s,%d,%s,<<,+,%s,=\",\n\t\t\t\t\t\t\t       REG(0), MEMBASE(1), str_ldr_bytes, MEMBASE(1), SHIFTVALUE(2), REG(2), MEMBASE(1));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ARM_SFT_LSR:\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,0xffffffff,&,=[%d],%s,%d,%s,>>,+,%s,=\",\n\t\t\t\t\t\t\t       REG(0), MEMBASE(1), str_ldr_bytes, MEMBASE(1), SHIFTVALUE(2), REG(2), MEMBASE(1));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ARM_SFT_ASR:\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,0xffffffff,&,=[%d],%s,%d,%s,>>>>,+,%s,=\",\n\t\t\t\t\t\t\t       REG(0), MEMBASE(1), str_ldr_bytes, MEMBASE(1), SHIFTVALUE(2), REG(2), MEMBASE(1));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ARM_SFT_ROR:\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,0xffffffff,&,=[%d],%s,%d,%s,>>>,+,%s,=\",\n\t\t\t\t\t\t\t       REG(0), MEMBASE(1), str_ldr_bytes, MEMBASE(1), SHIFTVALUE(2), REG(2), MEMBASE(1));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ARM_SFT_RRX:\n\t\t\t\t\t\t//TODO\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// Hopefully nothing here\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else { // No shift\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,0xffffffff,&,=[%d],%s,%s,+=\",\n\t\t\t\t\t\t       REG(0), MEMBASE(1), str_ldr_bytes, REG(2), MEMBASE(1));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ISREG(1) && str_ldr_bytes==8) { // e.g. 'strd r2, r3, [r4]', normally should be the only case for ISREG(1).\n\t\t\t\tif (!HASMEMINDEX(2)) {\n\t\t\t\t\tint disp = MEMDISP(2);\n\t\t\t\t\tchar sign = disp>=0?'+':'-';\n\t\t\t\t\tdisp = disp>=0?disp:-disp;\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%d,%s,%c,0xffffffff,&,=[4],%s,4,%d,+,%s,%c,0xffffffff,&,=[4]\",\n\t\t\t\t\t\t\t  REG(0), disp, MEMBASE(2), sign, REG(1), disp, MEMBASE(2), sign);\n\t\t\t\t\tif (insn->detail->arm.writeback) {\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",%d,%s,%c,%s,=\",\n\t\t\t\t\t\t\t\t  disp, MEMBASE(2), sign, MEMBASE(2));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (ISSHIFTED(2)) {\n\t\t\t\t\t\t// it seems strd does not support SHIFT which is good, but have a check nonetheless\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,%s,+,0xffffffff,&,=[4],%s,4,%s,+,%s,+,0xffffffff,&,=[4]\",\n\t\t\t\t\t\t\t\t  REG(0), MEMINDEX(2), MEMBASE(2), REG(1), MEMINDEX(2), MEMBASE(2));\n\t\t\t\t\t\tif (insn->detail->arm.writeback) {\n\t\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",%s,%s,+,%s,=\",\n\t\t\t\t\t\t\t\t\t  MEMINDEX(2), MEMBASE(2), MEMBASE(2));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (OPCOUNT() == 4) { // e.g. 'strd r2, r3, [r4], 4' or 'strd r2, r3, [r4], r5'\n\t\t\tif (ISIMM(3)) { // e.g. 'strd r2, r3, [r4], 4'\n\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,0xffffffff,&,=[%d],%s,4,%s,+,0xffffffff,&,=[%d],%d,%s,+=,\",\n\t\t\t\t\t       REG(0), MEMBASE(2), str_ldr_bytes, REG(1), MEMBASE(2), str_ldr_bytes, IMM(3), MEMBASE(2));\n\t\t\t}\n\t\t\tif (ISREG(3)) { // e.g. 'strd r2, r3, [r4], r5'\n\t\t\t\tif (ISSHIFTED(3)) {\n\t\t\t\t\t// same as above\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,0xffffffff,&,=[%d],%s,4,%s,+,0xffffffff,&,=[%d],%s,%s,+=\",\n\t\t\t\t\t\t       REG(0), MEMBASE(2), str_ldr_bytes, REG(1), MEMBASE(2), str_ldr_bytes, REG(3), MEMBASE(2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_TST:\n\t\tr_strbuf_appendf (&op->esil, \"0,%s,%s,&,==\", ARG(1), ARG(0));\n\t\tbreak;\n\tcase ARM_INS_LDRD:\n\t\taddr &= ~3LL;\n\t\tif (MEMDISP (2) < 0) {\n\t\t\tconst char *pc = \"$$\";\n\t\t\tif (REGBASE (2) == ARM_REG_PC) {\n\t\t\t\top->refptr = 4;\n\t\t\t\top->ptr = addr + pcdelta + MEMDISP (2);\n\t\t\t\tr_strbuf_appendf (&op->esil, \"0x%\" PFMT64x \",2,2,%s,%d,+,>>,<<,+,0xffffffff,&,DUP,[4],%s,=,4,+,[4],%s,=\",\n\t\t\t\t\t(ut64)MEMDISP (2), pc, pcdelta, REG (0), REG (1));\n\t\t\t} else {\n\t\t\t\tint disp = MEMDISP (2);\n\t\t\t\t// not refptr, because we can't grab the reg value statically op->refptr = 4;\n\t\t\t\tif (disp < 0) {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"0x%\" PFMT64x \",%s,-,0xffffffff,&,DUP,[4],%s,=,4,+,[4],%s,=\",\n\t\t\t\t\t\t(ut64)-disp, MEMBASE (2), REG (0), REG (1));\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"0x%\" PFMT64x \",%s,+,0xffffffff,&,DUP,[4],%s,=,4,+,[4],%s,=\",\n\t\t\t\t\t\t(ut64)disp, MEMBASE (2), REG (0), REG (1));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (REGBASE (2) == ARM_REG_PC) {\n\t\t\t\tconst char *pc = \"$$\";\n\t\t\t\top->refptr = 4;\n\t\t\t\top->ptr = addr + pcdelta + MEMDISP (2);\n\t\t\t\tif (HASMEMINDEX (2) || ISREG (2)) {\n\t\t\t\t\tconst char op_index = ISMEMINDEXSUB (2)? '-': '+';\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,2,2,%d,%s,+,>>,<<,%c,0xffffffff,&,DUP,[4],%s,=,4,+,[4],%s,=\",\n\t\t\t\t\t\tMEMINDEX (2), pcdelta, pc, op_index, REG (0), REG (1));\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"2,2,%d,%s,+,>>,<<,%d,+,0xffffffff,&,DUP,[4],%s,=,4,+,[4],%s,=\",\n\t\t\t\t\t\tpcdelta, pc, MEMDISP (2), REG (0), REG (1));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (HASMEMINDEX (2)) { // e.g. `ldrd r2, r3 [r4, r1]`\n\t\t\t\t\tconst char op_index = ISMEMINDEXSUB (2)? '-': '+';\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,%c,0xffffffff,&,DUP,[4],%s,=,4,+,[4],%s,=\",\n\t\t\t\t\t\tMEMINDEX (2), MEMBASE (2), op_index, REG (0), REG (1));\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%d,%s,+,0xffffffff,&,DUP,[4],%s,=,4,+,[4],%s,=\",\n\t\t\t\t\t\tMEMDISP (2), MEMBASE (2), REG (0), REG (1));\n\t\t\t\t}\n\t\t\t\tif (insn->detail->arm.writeback) {\n\t\t\t\t\tif (ISPOSTINDEX32 ()) {\n\t\t\t\t\t\tif (ISIMM (3)) {\n\t\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",%s,%d,+,%s,=\",\n\t\t\t\t\t\t\t\tMEMBASE (2), IMM (3), MEMBASE (2));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst char op_index = ISMEMINDEXSUB (3)? '-': '+';\n\t\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",%s,%s,%c,%s,=\",\n\t\t\t\t\t\t\t\tREG (3), MEMBASE (2), op_index, MEMBASE (2));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ISPREINDEX32 ()) {\n\t\t\t\t\t\tif (HASMEMINDEX (2)) {\n\t\t\t\t\t\t\tconst char op_index = ISMEMINDEXSUB (2)? '-': '+';\n\t\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",%s,%s,%c,%s,=\",\n\t\t\t\t\t\t\t\tMEMINDEX (2), MEMBASE (2), op_index, MEMBASE (2));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",%s,%d,+,%s,=\",\n\t\t\t\t\t\t\t\tMEMBASE (2), MEMDISP (2), MEMBASE (2));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_LDRB:\n\t\tif (ISMEM(1) && LSHIFT2(1)) {\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,%d,%s,<<,+,0xffffffff,&,[1],0x%x,&,%s,=\",\n\t\t\t\tMEMBASE (1), LSHIFT2 (1), MEMINDEX (1), mask, REG (0));\n\t\t} else if (HASMEMINDEX (1)) {\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,+,0xffffffff,&,[1],%s,=\",\n\t\t\t\tMEMINDEX (1), MEMBASE (1), REG (0));\n\t\t} else {\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,%d,+,[1],%s,=\",\n\t\t\t\tMEMBASE (1), MEMDISP (1), REG (0));\n\t\t}\n\t\tif (insn->detail->arm.writeback) {\n\t\t\tif (ISIMM(2)) {\n\t\t\t\tr_strbuf_appendf (&op->esil, \",%s,%d,+,%s,=\",\n\t\t\t\t\tMEMBASE (1), IMM (2), MEMBASE (1));\n\t\t\t} else {\n\t\t\t\tr_strbuf_appendf (&op->esil, \",%s,%d,+,%s,=\",\n\t\t\t\t\tMEMBASE (1), MEMDISP (1), MEMBASE (1));\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_SXTH:\n\t\tr_strbuf_appendf (&op->esil,\n\t\t\t\"15,%s,>>,1,&,?{,15,-1,<<,%s,0xffff,&,|,%s,:=,}{,%s,0xffff,%s,:=,}\",\n\t\t\tREG (1), REG (1), REG (0), REG (1), REG (0));\n\t\tbreak;\n\tcase ARM_INS_SXTB:\n\t\tr_strbuf_appendf (&op->esil,\n\t\t\t\"7,%s,>>,1,&,?{,7,-1,<<,%s,0xff,&,|,%s,:=,}{,%s,0xff,&,%s,:=,}\",\n\t\t\tREG (1), REG (1), REG (0), REG (1), REG (0));\n\t\tbreak;\n\tcase ARM_INS_LDREX:\n\tcase ARM_INS_LDREXB:\n\tcase ARM_INS_LDREXD:\n\tcase ARM_INS_LDREXH:\n\t\top->family = R_ANAL_OP_FAMILY_THREAD;\n\t\t// intentional fallthrough\n\tcase ARM_INS_LDRHT:\n\tcase ARM_INS_LDRH:\n\tcase ARM_INS_LDRT:\n\tcase ARM_INS_LDRBT:\n\tcase ARM_INS_LDRSB:\n\tcase ARM_INS_LDRSBT:\n\tcase ARM_INS_LDRSH:\n\tcase ARM_INS_LDRSHT:\n\tcase ARM_INS_LDR:\n\t\tswitch (insn->id) {\n\t\tcase ARM_INS_LDRHT:\n\t\tcase ARM_INS_LDRH:\n\t\tcase ARM_INS_LDRSH:\n\t\tcase ARM_INS_LDRSHT:\n\t\t\tmask = UT16_MAX;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tmask = UT32_MAX;\n\t\t\tbreak;\n\t\t}\n\t\taddr &= ~3LL;\n\t\tif (MEMDISP(1) < 0) {\n\t\t\tconst char *pc = \"$$\";\n\t\t\tif (REGBASE(1) == ARM_REG_PC) {\n\t\t\t\top->refptr = 4;\n\t\t\t\top->ptr = addr + pcdelta + MEMDISP(1);\n\t\t\t\tr_strbuf_appendf (&op->esil, \"0x%\"PFMT64x\",2,2,%s,%d,+,>>,<<,+,0xffffffff,&,[4],0x%x,&,%s,=\",\n\t\t\t\t\t(ut64)MEMDISP(1), pc, pcdelta, mask, REG(0));\n\t\t\t} else {\n\t\t\t\tint disp = MEMDISP(1);\n\t\t\t\t// not refptr, because we can't grab the reg value statically op->refptr = 4;\n\t\t\t\tif (disp < 0) {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"0x%\"PFMT64x\",%s,-,0xffffffff,&,[4],0x%x,&,%s,=\",\n\t\t\t\t\t\t\t(ut64)-disp, MEMBASE(1), mask, REG(0));\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"0x%\"PFMT64x\",%s,+,0xffffffff,&,[4],0x%x,&,%s,=\",\n\t\t\t\t\t\t\t(ut64)disp, MEMBASE(1), mask, REG(0));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (REGBASE(1) == ARM_REG_PC) {\n\t\t\t\tconst char *pc = \"$$\";\n\t\t\t\top->refptr = 4;\n\t\t\t\top->ptr = addr + pcdelta + MEMDISP(1);\n\t\t\t\tif (ISMEM(1) && LSHIFT2(1)) {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"2,2,%d,%s,+,>>,<<,%d,%s,<<,+,0xffffffff,&,[4],0x%x,&,%s,=\",\n\t\t\t\t\t\tpcdelta, pc, LSHIFT2(1), MEMINDEX(1), mask, REG(0));\n\t\t\t\t} else {\n\t\t\t\t\tif (ISREG(1)) {\n\t\t\t\t\t\tconst char op_index = ISMEMINDEXSUB (1)? '-': '+';\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,2,2,%d,%s,+,>>,<<,%c,0xffffffff,&,[4],0x%x,&,%s,=\",\n\t\t\t\t\t\t\tMEMINDEX (1), pcdelta, pc, op_index, mask, REG (0));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \"2,2,%d,%s,+,>>,<<,%d,+,0xffffffff,&,[4],0x%x,&,%s,=\",\n\t\t\t\t\t\t\tpcdelta, pc, MEMDISP(1), mask, REG(0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (ISMEM(1) && LSHIFT2(1)) {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%d,%s,<<,+,0xffffffff,&,[4],0x%x,&,%s,=\",\n\t\t\t\t\t\tMEMBASE (1), LSHIFT2 (1), MEMINDEX (1), mask, REG (0));\n\t\t\t\t} else if (HASMEMINDEX(1)) {\t// e.g. `ldr r2, [r3, r1]`\n\t\t\t\t\tconst char op_index = ISMEMINDEXSUB (1)? '-': '+';\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,%c,0xffffffff,&,[4],0x%x,&,%s,=\",\n\t\t\t\t\t\tMEMINDEX (1), MEMBASE (1), op_index, mask, REG (0));\n\t\t\t\t} else {\n\t\t\t\t\tr_strbuf_appendf (&op->esil, \"%d,%s,+,0xffffffff,&,[4],0x%x,&,%s,=\",\n\t\t\t\t\t\tMEMDISP (1), MEMBASE (1), mask, REG (0));\n\t\t\t\t}\n\t\t\t\tif (insn->detail->arm.writeback) {\n\t\t\t\t\tif (ISPOSTINDEX32 ()) {\n\t\t\t\t\t\tif (ISIMM (2)) {\n\t\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",%s,%d,+,%s,=\",\n\t\t\t\t\t\t\t\tMEMBASE (1), IMM (2), MEMBASE (1));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst char op_index = ISMEMINDEXSUB (2)? '-': '+';\n\t\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",%d,%s,<<,%s,%c,%s,=\",\n\t\t\t\t\t\t\t\tLSHIFT2 (2), REG (2), MEMBASE (1), op_index, MEMBASE (1));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (ISPREINDEX32 ()) {\n\t\t\t\t\t\tif (HASMEMINDEX (1)) {\n\t\t\t\t\t\t\tconst char op_index = ISMEMINDEXSUB (1)? '-': '+';\n\t\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",%d,%s,<<,%s,%c,%s,=\",\n\t\t\t\t\t\t\t\tLSHIFT2 (1), MEMINDEX (1), MEMBASE (1), op_index, MEMBASE (1));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_strbuf_appendf (&op->esil, \",%s,%d,+,%s,=\",\n\t\t\t\t\t\t\t\tMEMBASE (1), MEMDISP (1), MEMBASE (1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_MRS:\n\t\t// TODO: esil for MRS\n\t\tbreak;\n\tcase ARM_INS_MSR:\n\t\tmsr_flags = insn->detail->arm.operands[0].reg >> 4;\n\t\tr_strbuf_appendf (&op->esil, \"0,\");\n\t\tif (msr_flags & 1) {\n\t\t\tr_strbuf_appendf (&op->esil, \"0xFF,|,\");\n\t\t}\n\t\tif (msr_flags & 2) {\n\t\t\tr_strbuf_appendf (&op->esil, \"0xFF00,|,\");\n\t\t}\n\t\tif (msr_flags & 4) {\n\t\t\tr_strbuf_appendf (&op->esil, \"0xFF0000,|,\");\n\t\t}\n\t\tif (msr_flags & 8) {\n\t\t\tr_strbuf_appendf (&op->esil, \"0xFF000000,|,\");\n\t\t}\n\t\tr_strbuf_appendf (&op->esil, \"DUP,!,SWAP,&,%s,SWAP,cpsr,&,|,cpsr,=\", REG(1));\n\t\tbreak;\n\tcase ARM_INS_UBFX:\n\t\tif (IMM (3) > 0 && IMM (3) <= 32 - IMM (2)) {\n\t\t\tsize_t index = IMM (3) - 1;\n\t\t\tif (index >= BITMASK_BY_WIDTH_COUNT) {\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\tr_strbuf_appendf (&op->esil, \"%d,%s,%d,%\"PFMT64u\",<<,&,>>,%s,=\",\n\t\t\t\tIMM(2), REG(1), IMM(2), bitmask_by_width[index], REG(0));\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_UXTB:\n\t\tr_strbuf_appendf (&op->esil, \"%s,0xff,&,%s,=\", ARG(1), REG(0));\n\t\tbreak;\n\tcase ARM_INS_RSB:\n\t\tif (OPCOUNT () == 2) {\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,-=\", ARG(0), ARG(1));\n\t\t} else if (OPCOUNT () == 3) {\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,%s,-,%s,=\", ARG(1), ARG(2), ARG(0));\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_BIC:\n\t\tif (OPCOUNT () == 2) {\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,0xffffffff,^,%s,&=\", ARG(1), ARG(0));\n\t\t} else {\n\t\t\tr_strbuf_appendf (&op->esil, \"%s,0xffffffff,^,%s,&,%s,=\", ARG(2), ARG(1), ARG(0));\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_SMMLA:\n\t\tr_strbuf_appendf (&op->esil, \"32,%s,%s,*,>>,%s,+,0xffffffff,&,%s,=\",\n\t\t\tREG(1), REG(2), REG(3), REG(0));\n\t\tbreak;\n\tcase ARM_INS_SMMLAR:\n\t\tr_strbuf_appendf (&op->esil, \"32,0x80000000,%s,%s,*,+,>>,%s,+,0xffffffff,&,%s,=\",\n\t\t\tREG(1), REG(2), REG(3), REG(0));\n\t\tbreak;\n\tcase ARM_INS_UMULL:\n\t\tr_strbuf_appendf (&op->esil, \"32,%s,%s,*,DUP,0xffffffff,&,%s,=,>>,%s,=\",\n\t\t\tREG(2), REG(3), REG(0), REG(1));\n\t\tbreak;\n\tcase ARM_INS_MLS:\n\t\tr_strbuf_appendf (&op->esil, \"%s,%s,*,%s,-,0xffffffff,&,%s,=\",\n\t\t\tREG(1), REG(2), REG(3), REG(0));\n\t\tbreak;\n\tcase ARM_INS_MLA:\n\t\tr_strbuf_appendf (&op->esil, \"%s,%s,*,%s,+,0xffffffff,&,%s,=\",\n\t\t\tREG(1), REG(2), REG(3), REG(0));\n\t\tbreak;\n\tcase ARM_INS_MVN:\n\t\tr_strbuf_appendf (&op->esil, \"-1,%s,^,0xffffffff,&,%s,=\",\n\t\t\tARG(1), REG(0));\n\t\tbreak;\n\tcase ARM_INS_BFI:\n\t{\n\t\tif (OPCOUNT() >= 3 && ISIMM(3) && IMM(3) > 0 && IMM(3) < 64) {\n\t\t\tsize_t index = IMM (3) - 1;\n\t\t\tif (index >= BITMASK_BY_WIDTH_COUNT) {\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\tut64 mask = bitmask_by_width[index];\n\t\t\tut64 shift = IMM(2);\n\t\t\tut64 notmask = ~(mask << shift);\n\t\t\t// notmask,dst,&,lsb,mask,src,&,<<,|,dst,=\n\t\t\tr_strbuf_setf (&op->esil, \"%\"PFMT64u\",%s,&,%\"PFMT64u\",%\"PFMT64u\",%s,&,<<,|,0xffffffff,&,%s,=\",\n\t\t\t\tnotmask, REG(0), shift, mask, REG(1), REG(0));\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARM_INS_BFC:\n\t{\n\t\tif (OPCOUNT() >= 2 && ISIMM(2) && IMM(2) > 0 && IMM(2) < 64) {\n\t\t\tsize_t index = IMM (2) - 1;\n\t\t\tif (index >= BITMASK_BY_WIDTH_COUNT) {\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\tut64 mask = bitmask_by_width[IMM(2) - 1];\n\t\t\tut64 shift = IMM(1);\n\t\t\tut64 notmask = ~(mask << shift);\n\t\t\t// notmask,dst,&,dst,=\n\t\t\tr_strbuf_setf (&op->esil, \"%\"PFMT64u\",%s,&,0xffffffff,&,%s,=\",\n\t\t\t\tnotmask, REG(0), REG(0));\n\t\t}\n\t\tbreak;\n\t}\n\tcase ARM_INS_REV:\n\t{\n\t\tconst char *r0 = REG(0);\n\t\tconst char *r1 = REG(1);\n\t\tr_strbuf_setf (&op->esil,\n\t\t\t\"24,0xff,%s,&,<<,%s,=,\"\n\t\t\t\"16,0xff,8,%s,>>,&,<<,%s,|=,\"\n\t\t\t\"8,0xff,16,%s,>>,&,<<,%s,|=,\"\n\t\t\t\"0xff,24,%s,>>,&,%s,|=,\",\n\t\t\tr1, r0, r1, r0, r1, r0, r1, r0);\n\t\tbreak;\n\t}\n\tcase ARM_INS_REV16:\n\t{\n\t\tconst char *r0 = REG(0);\n\t\tconst char *r1 = REG(1);\n\t\tr_strbuf_setf (&op->esil,\n\t\t\t\"8,0xff00ff00,%s,&,>>,%s,=,\"\n\t\t\t\"8,0x00ff00ff,%s,&,<<,%s,|=,\",\n\t\t\tr1, r0, r1, r0);\n\t\tbreak;\n\t}\n\tcase ARM_INS_REVSH:\n\t{\n\t\tconst char *r0 = REG(0);\n\t\tconst char *r1 = REG(1);\n\t\tr_strbuf_setf (&op->esil,\n\t\t\t\"8,0xff00,%s,&,>>,%s,=,\"\n\t\t\t\"8,0x00ff,%s,&,<<,%s,|=,\"\n\t\t\t\"0x8000,%s,&,?{,\"\n\t\t\t\t\"0xffff0000,%s,|=,\"\n\t\t\t\"}\",\n\t\t\tr1, r0, r1, r0, r0, r0);\n\t\tbreak;\n\t}\n\tcase ARM_INS_TBB:\n\t\tr_strbuf_appendf (&op->esil, \"%s,%s,+,0xffffffff,&,DUP,[1],1,SWAP,<<,+,pc,+=\",\n\t\t\tMEMBASE (0), MEMINDEX (0));\n\t\tbreak;\n\tcase ARM_INS_TBH:\n\t\tr_strbuf_appendf (&op->esil, \"%s,%d,%s,<<,+,0xffffffff,&,[2],1,SWAP,<<,pc,+=\",\n\t\t\tMEMBASE (0), LSHIFT2 (0), MEMINDEX (0));\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\t// Update flags if required...TODO different instructions update different flags, but this should fix\n\t// many errors\n\tif (insn->detail->arm.update_flags) {\n\t\tswitch(insn->id) {\n\t\tcase ARM_INS_CMP:\n\t\t\tr_strbuf_appendf (&op->esil, \",$z,zf,:=,31,$s,nf,:=,32,$b,!,cf,:=,31,$o,vf,:=\");\n\t\t\tbreak;\n\t\tcase ARM_INS_ADD:\n\t\tcase ARM_INS_RSB:\n\t\tcase ARM_INS_SUB:\n\t\tcase ARM_INS_SBC:\n\t\tcase ARM_INS_ADC:\n\t\tcase ARM_INS_CMN:\n\t\t\tr_strbuf_appendf (&op->esil, \",$z,zf,:=,31,$s,nf,:=,31,$c,cf,:=,31,$o,vf,:=\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_strbuf_appendf (&op->esil, \",$z,zf,:=,31,$s,nf,:=\");\n\t\t}\n\t}\n\n\tr_strbuf_append (&op->esil, postfix);\n\n\treturn 0;\n}\n\nstatic int cond_cs2r2(int cc) {\n\tif (cc == ARM_CC_AL || cc < 0) {\n\t\tcc = R_ANAL_COND_AL;\n\t} else {\n\t\tswitch (cc) {\n\t\tcase ARM_CC_EQ: cc = R_ANAL_COND_EQ; break;\n\t\tcase ARM_CC_NE: cc = R_ANAL_COND_NE; break;\n\t\tcase ARM_CC_HS: cc = R_ANAL_COND_HS; break;\n\t\tcase ARM_CC_LO: cc = R_ANAL_COND_LO; break;\n\t\tcase ARM_CC_MI: cc = R_ANAL_COND_MI; break;\n\t\tcase ARM_CC_PL: cc = R_ANAL_COND_PL; break;\n\t\tcase ARM_CC_VS: cc = R_ANAL_COND_VS; break;\n\t\tcase ARM_CC_VC: cc = R_ANAL_COND_VC; break;\n\t\tcase ARM_CC_HI: cc = R_ANAL_COND_HI; break;\n\t\tcase ARM_CC_LS: cc = R_ANAL_COND_LS; break;\n\t\tcase ARM_CC_GE: cc = R_ANAL_COND_GE; break;\n\t\tcase ARM_CC_LT: cc = R_ANAL_COND_LT; break;\n\t\tcase ARM_CC_GT: cc = R_ANAL_COND_GT; break;\n\t\tcase ARM_CC_LE: cc = R_ANAL_COND_LE; break;\n\t\t}\n\t}\n\treturn cc;\n}\n\nstatic void anop64(csh handle, RAnalOp *op, cs_insn *insn) {\n\tut64 addr = op->addr;\n\n\t/* grab family */\n\tif (cs_insn_group (handle, insn, ARM64_GRP_CRYPTO)) {\n\t\top->family = R_ANAL_OP_FAMILY_CRYPTO;\n\t} else if (cs_insn_group (handle, insn, ARM64_GRP_CRC)) {\n\t\top->family = R_ANAL_OP_FAMILY_CRYPTO;\n#if CS_API_MAJOR >= 4\n\t} else if (cs_insn_group (handle, insn, ARM64_GRP_PRIVILEGE)) {\n\t\top->family = R_ANAL_OP_FAMILY_PRIV;\n#endif\n\t} else if (cs_insn_group (handle, insn, ARM64_GRP_NEON)) {\n\t\top->family = R_ANAL_OP_FAMILY_MMX;\n\t} else if (cs_insn_group (handle, insn, ARM64_GRP_FPARMV8)) {\n\t\top->family = R_ANAL_OP_FAMILY_FPU;\n\t} else {\n\t\top->family = R_ANAL_OP_FAMILY_CPU;\n\t}\n\n\top->cond = cond_cs2r2 (insn->detail->arm64.cc);\n\tif (op->cond == R_ANAL_COND_NV) {\n\t\top->type = R_ANAL_OP_TYPE_NOP;\n\t\treturn;\n\t}\n\n\tswitch (insn->detail->arm64.cc) {\n\tcase ARM64_CC_GE:\n\tcase ARM64_CC_GT:\n\tcase ARM64_CC_LE:\n\tcase ARM64_CC_LT:\n\t\top->sign = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tswitch (insn->id) {\n#if CS_API_MAJOR > 4\n\tcase ARM64_INS_PACDA:\n\tcase ARM64_INS_PACDB:\n\tcase ARM64_INS_PACDZA:\n\tcase ARM64_INS_PACDZB:\n\tcase ARM64_INS_PACGA:\n\tcase ARM64_INS_PACIA:\n\tcase ARM64_INS_PACIA1716:\n\tcase ARM64_INS_PACIASP:\n\tcase ARM64_INS_PACIAZ:\n\tcase ARM64_INS_PACIB:\n\tcase ARM64_INS_PACIB1716:\n\tcase ARM64_INS_PACIBSP:\n\tcase ARM64_INS_PACIBZ:\n\tcase ARM64_INS_PACIZA:\n\tcase ARM64_INS_PACIZB:\n\tcase ARM64_INS_AUTDA:\n\tcase ARM64_INS_AUTDB:\n\tcase ARM64_INS_AUTDZA:\n\tcase ARM64_INS_AUTDZB:\n\tcase ARM64_INS_AUTIA:\n\tcase ARM64_INS_AUTIA1716:\n\tcase ARM64_INS_AUTIASP:\n\tcase ARM64_INS_AUTIAZ:\n\tcase ARM64_INS_AUTIB:\n\tcase ARM64_INS_AUTIB1716:\n\tcase ARM64_INS_AUTIBSP:\n\tcase ARM64_INS_AUTIBZ:\n\tcase ARM64_INS_AUTIZA:\n\tcase ARM64_INS_AUTIZB:\n\tcase ARM64_INS_XPACD:\n\tcase ARM64_INS_XPACI:\n\tcase ARM64_INS_XPACLRI:\n\t\top->type = R_ANAL_OP_TYPE_CMP;\n\t\top->family = R_ANAL_OP_FAMILY_SECURITY;\n\t\tbreak;\n#endif\n\tcase ARM64_INS_SVC:\n\t\top->type = R_ANAL_OP_TYPE_SWI;\n\t\top->val = IMM64(0);\n\t\tbreak;\n\tcase ARM64_INS_ADRP:\n\tcase ARM64_INS_ADR:\n\t\top->type = R_ANAL_OP_TYPE_LEA;\n\t\top->ptr = IMM64(1);\n\t\tbreak;\n\tcase ARM64_INS_NOP:\n\t\top->type = R_ANAL_OP_TYPE_NOP;\n\t\top->cycles = 1;\n\t\tbreak;\n\tcase ARM64_INS_SUB:\n\t\tif (ISREG64(0) && REGID64(0) == ARM64_REG_SP) {\n\t\t\top->stackop = R_ANAL_STACK_INC;\n\t\t\tif (ISIMM64(1)) {\n\t\t\t\t//sub sp, 0x54\n\t\t\t\top->stackptr = IMM(1);\n\t\t\t} else if (ISIMM64(2) && ISREG64(1) && REGID64(1) == ARM64_REG_SP) {\n\t\t\t\t//sub sp, sp, 0x10\n\t\t\t\top->stackptr = IMM64(2);\n\t\t\t}\n\t\t\top->val = op->stackptr;\n\t\t} else {\n\t\t\top->stackop = R_ANAL_STACK_RESET;\n\t\t\top->stackptr = 0;\n\t\t}\n\t\top->cycles = 1;\n\t\t/* fallthru */\n\tcase ARM64_INS_MSUB:\n\t\top->type = R_ANAL_OP_TYPE_SUB;\n\t\tbreak;\n\tcase ARM64_INS_FDIV:\n\tcase ARM64_INS_SDIV:\n\tcase ARM64_INS_UDIV:\n\t\top->cycles = 4;\n\t\top->type = R_ANAL_OP_TYPE_DIV;\n\t\tbreak;\n\tcase ARM64_INS_MUL:\n\tcase ARM64_INS_SMULL:\n\tcase ARM64_INS_FMUL:\n\tcase ARM64_INS_UMULL:\n\t\t/* TODO: if next instruction is also a MUL, cycles are /=2 */\n\t\t/* also known as Register Indexing Addressing */\n\t\top->cycles = 4;\n\t\top->type = R_ANAL_OP_TYPE_MUL;\n\t\tbreak;\n\tcase ARM64_INS_ADD:\n\t\tif (ISREG64 (0) && REGID64 (0) == ARM64_REG_SP) {\n\t\t\top->stackop = R_ANAL_STACK_INC;\n\t\t\tif (ISIMM64 (1)) {\n\t\t\t\t//add sp, 0x54\n\t\t\t\top->stackptr = -IMM (1);\n\t\t\t} else if (ISIMM64 (2) && ISREG64 (1) && REGID64 (1) == ARM64_REG_SP) {\n\t\t\t\t//add sp, sp, 0x10\n\t\t\t\top->stackptr = -IMM64 (2);\n\t\t\t}\n\t\t\top->val = op->stackptr;\n\t\t} else {\n\t\t\top->stackop = R_ANAL_STACK_RESET;\n\t\t\top->stackptr = 0;\n\t\t}\n\t\top->cycles = 1;\n\t\t/* fallthru */\n\tcase ARM64_INS_ADC:\n\t//case ARM64_INS_ADCS:\n\tcase ARM64_INS_UMADDL:\n\tcase ARM64_INS_SMADDL:\n\tcase ARM64_INS_FMADD:\n\tcase ARM64_INS_MADD:\n\t\top->type = R_ANAL_OP_TYPE_ADD;\n\t\tbreak;\n\tcase ARM64_INS_CSEL:\n\tcase ARM64_INS_FCSEL:\n\tcase ARM64_INS_CSET:\n\tcase ARM64_INS_CINC:\n\t\top->type = R_ANAL_OP_TYPE_CMOV;\n\t\tbreak;\n\tcase ARM64_INS_MOV:\n\t\tif (REGID64(0) == ARM64_REG_SP) {\n\t\t\top->stackop = R_ANAL_STACK_RESET;\n\t\t\top->stackptr = 0;\n\t\t}\n\t\top->cycles = 1;\n\t\t/* fallthru */\n\tcase ARM64_INS_MOVI:\n\tcase ARM64_INS_MOVK:\n\tcase ARM64_INS_MOVN:\n\tcase ARM64_INS_SMOV:\n\tcase ARM64_INS_UMOV:\n\tcase ARM64_INS_FMOV:\n\tcase ARM64_INS_SBFX:\n\tcase ARM64_INS_UBFX:\n\tcase ARM64_INS_UBFM:\n\tcase ARM64_INS_SBFIZ:\n\tcase ARM64_INS_UBFIZ:\n\tcase ARM64_INS_BIC:\n\tcase ARM64_INS_BFI:\n\tcase ARM64_INS_BFXIL:\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\tif (ISIMM64 (1)) {\n\t\t\top->val = IMM64(1);\n\t\t}\n\t\tbreak;\n\tcase ARM64_INS_MRS:\n\tcase ARM64_INS_MSR:\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\top->family = R_ANAL_OP_FAMILY_PRIV;\n\t\tbreak;\n\tcase ARM64_INS_MOVZ:\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\top->ptr = 0LL;\n\t\top->ptrsize = 8;\n\t\top->val = IMM64(1);\n\t\tbreak;\n\tcase ARM64_INS_UXTB:\n\tcase ARM64_INS_SXTB:\n\t\top->type = R_ANAL_OP_TYPE_CAST;\n\t\top->ptr = 0LL;\n\t\top->ptrsize = 1;\n\t\tbreak;\n\tcase ARM64_INS_UXTH:\n\tcase ARM64_INS_SXTH:\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\top->ptr = 0LL;\n\t\top->ptrsize = 2;\n\t\tbreak;\n\tcase ARM64_INS_UXTW:\n\tcase ARM64_INS_SXTW:\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\top->ptr = 0LL;\n\t\top->ptrsize = 4;\n\t\tbreak;\n\tcase ARM64_INS_BRK:\n\tcase ARM64_INS_HLT:\n\t\top->type = R_ANAL_OP_TYPE_TRAP;\n\t\t// hlt stops the process, not skips some cycles like in x86\n\t\tbreak;\n\tcase ARM64_INS_DMB:\n\tcase ARM64_INS_DSB:\n\tcase ARM64_INS_ISB:\n\t\top->family = R_ANAL_OP_FAMILY_THREAD;\n\t\t// intentional fallthrough\n\tcase ARM64_INS_IC: // instruction cache invalidate\n\tcase ARM64_INS_DC: // data cache invalidate\n\t\top->type = R_ANAL_OP_TYPE_SYNC; // or cache\n\t\tbreak;\n\t//  XXX unimplemented instructions\n\tcase ARM64_INS_DUP:\n\tcase ARM64_INS_XTN:\n\tcase ARM64_INS_XTN2:\n\tcase ARM64_INS_REV64:\n\tcase ARM64_INS_EXT:\n\tcase ARM64_INS_INS:\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\tbreak;\n\tcase ARM64_INS_LSL:\n\t\top->cycles = 1;\n\t\t/* fallthru */\n\tcase ARM64_INS_SHL:\n\tcase ARM64_INS_USHLL:\n\t\top->type = R_ANAL_OP_TYPE_SHL;\n\t\tbreak;\n\tcase ARM64_INS_LSR:\n\t\top->cycles = 1;\n\t\top->type = R_ANAL_OP_TYPE_SHR;\n\t\tbreak;\n\tcase ARM64_INS_ASR:\n\t\top->cycles = 1;\n\t\top->type = R_ANAL_OP_TYPE_SAR;\n\t\tbreak;\n\tcase ARM64_INS_NEG:\n#if CS_API_MAJOR > 3\n\tcase ARM64_INS_NEGS:\n#endif\n\t\top->type = R_ANAL_OP_TYPE_NOT;\n\t\tbreak;\n\tcase ARM64_INS_FCMP:\n\tcase ARM64_INS_CCMP:\n\tcase ARM64_INS_CCMN:\n\tcase ARM64_INS_CMP:\n\tcase ARM64_INS_CMN:\n\tcase ARM64_INS_TST:\n\t\top->type = R_ANAL_OP_TYPE_CMP;\n\t\tbreak;\n\tcase ARM64_INS_ROR:\n\t\top->cycles = 1;\n\t\top->type = R_ANAL_OP_TYPE_ROR;\n\t\tbreak;\n\tcase ARM64_INS_AND:\n\t\top->type = R_ANAL_OP_TYPE_AND;\n\t\tbreak;\n\tcase ARM64_INS_ORR:\n\tcase ARM64_INS_ORN:\n\t\top->type = R_ANAL_OP_TYPE_OR;\n\t\tbreak;\n\tcase ARM64_INS_EOR:\n\tcase ARM64_INS_EON:\n\t\top->type = R_ANAL_OP_TYPE_XOR;\n\t\tbreak;\n\tcase ARM64_INS_STRB:\n\tcase ARM64_INS_STURB:\n\tcase ARM64_INS_STUR:\n\tcase ARM64_INS_STR:\n\tcase ARM64_INS_STP:\n\tcase ARM64_INS_STNP:\n\tcase ARM64_INS_STXR:\n\tcase ARM64_INS_STXRH:\n\tcase ARM64_INS_STLXR:\n\tcase ARM64_INS_STLXRH:\n\tcase ARM64_INS_STXRB:\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\tif (ISPREINDEX64 () && REGBASE64 (2) == ARM64_REG_SP) {\n\t\t\top->stackop = R_ANAL_STACK_INC;\n\t\t\top->stackptr = -MEMDISP64 (2);\n\t\t} else if (ISPOSTINDEX64 () && REGID64 (2) == ARM64_REG_SP) {\n\t\t\top->stackop = R_ANAL_STACK_INC;\n\t\t\top->stackptr = -IMM64 (3);\n\t\t} else if (ISPREINDEX64 () && REGBASE64 (1) == ARM64_REG_SP) {\n\t\t\top->stackop = R_ANAL_STACK_INC;\n\t\t\top->stackptr = -MEMDISP64 (1);\n\t\t} else if (ISPOSTINDEX64 () && REGID64 (1) == ARM64_REG_SP) {\n\t\t\top->stackop = R_ANAL_STACK_INC;\n\t\t\top->stackptr = -IMM64 (2);\n\t\t}\n\t\tbreak;\n\tcase ARM64_INS_LDUR:\n\tcase ARM64_INS_LDURB:\n\tcase ARM64_INS_LDRSW:\n\tcase ARM64_INS_LDRSB:\n\tcase ARM64_INS_LDRSH:\n\tcase ARM64_INS_LDR:\n\tcase ARM64_INS_LDURSW:\n\tcase ARM64_INS_LDP:\n\tcase ARM64_INS_LDNP:\n\tcase ARM64_INS_LDPSW:\n\tcase ARM64_INS_LDRH:\n\tcase ARM64_INS_LDRB:\n\t\tif (ISPREINDEX64 () && REGBASE64 (2) == ARM64_REG_SP) {\n\t\t\top->stackop = R_ANAL_STACK_INC;\n\t\t\top->stackptr = -MEMDISP64 (2);\n\t\t} else if (ISPOSTINDEX64 () && REGID64 (2) == ARM64_REG_SP) {\n\t\t\top->stackop = R_ANAL_STACK_INC;\n\t\t\top->stackptr = -IMM64 (3);\n\t\t} else if (ISPREINDEX64 () && REGBASE64 (1) == ARM64_REG_SP) {\n\t\t\top->stackop = R_ANAL_STACK_INC;\n\t\t\top->stackptr = -MEMDISP64 (1);\n\t\t} else if (ISPOSTINDEX64 () && REGID64 (1) == ARM64_REG_SP) {\n\t\t\top->stackop = R_ANAL_STACK_INC;\n\t\t\top->stackptr = -IMM64 (2);\n\t\t}\n\t\tif (REGID(0) == ARM_REG_PC) {\n\t\t\top->type = R_ANAL_OP_TYPE_UJMP;\n\t\t\tif (insn->detail->arm.cc != ARM_CC_AL) {\n\t\t\t\t//op->type = R_ANAL_OP_TYPE_MCJMP;\n\t\t\t\top->type = R_ANAL_OP_TYPE_UCJMP;\n\t\t\t}\n\t\t} else {\n\t\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\t}\n\t\tswitch (insn->id) {\n\t\tcase ARM64_INS_LDPSW:\n\t\tcase ARM64_INS_LDRSW:\n\t\tcase ARM64_INS_LDRSH:\n\t\tcase ARM64_INS_LDRSB:\n\t\t\top->sign = true;\n\t\t\tbreak;\n\t\t}\n\t\tif (REGBASE64(1) == ARM64_REG_X29) {\n\t\t\top->stackop = R_ANAL_STACK_GET;\n\t\t\top->stackptr = 0;\n\t\t\top->ptr = MEMDISP64(1);\n\t\t} else {\n\t\t\tif (ISIMM64(1)) {\n\t\t\t\top->type = R_ANAL_OP_TYPE_LEA;\n\t\t\t\top->ptr = IMM64(1);\n\t\t\t\top->refptr = 8;\n\t\t\t} else {\n\t\t\t\tint d = (int)MEMDISP64(1);\n\t\t\t\top->ptr = (d < 0)? -d: d;\n\t\t\t\top->refptr = 4;\n\t\t\t}\n\t\t}\n\t\tbreak;\n#if CS_API_MAJOR > 4\n\tcase ARM64_INS_BLRAA:\n\tcase ARM64_INS_BLRAAZ:\n\tcase ARM64_INS_BLRAB:\n\tcase ARM64_INS_BLRABZ:\n\t\top->family = R_ANAL_OP_FAMILY_SECURITY;\n\t\top->type = R_ANAL_OP_TYPE_RCALL;\n\t\tbreak;\n\tcase ARM64_INS_BRAA:\n\tcase ARM64_INS_BRAAZ:\n\tcase ARM64_INS_BRAB:\n\tcase ARM64_INS_BRABZ:\n\t\top->family = R_ANAL_OP_FAMILY_SECURITY;\n\t\top->type = R_ANAL_OP_TYPE_RJMP;\n\t\tbreak;\n\tcase ARM64_INS_LDRAA:\n\tcase ARM64_INS_LDRAB:\n\t\top->family = R_ANAL_OP_FAMILY_SECURITY;\n\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\tbreak;\n\tcase ARM64_INS_RETAA:\n\tcase ARM64_INS_RETAB:\n\tcase ARM64_INS_ERETAA:\n\tcase ARM64_INS_ERETAB:\n\t\top->family = R_ANAL_OP_FAMILY_SECURITY;\n\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\tbreak;\n#endif\n\tcase ARM64_INS_ERET:\n\t\top->family = R_ANAL_OP_FAMILY_PRIV;\n\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\tbreak;\n\tcase ARM64_INS_RET:\n\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\tbreak;\n\tcase ARM64_INS_BL: // bl 0x89480\n\t\top->type = R_ANAL_OP_TYPE_CALL;\n\t\top->jump = IMM64(0);\n\t\top->fail = addr + 4;\n\t\tbreak;\n\tcase ARM64_INS_BLR: // blr x0\n\t\top->type = R_ANAL_OP_TYPE_RCALL;\n\t\top->fail = addr + 4;\n\t\t//op->jump = IMM64(0);\n\t\tbreak;\n\tcase ARM64_INS_CBZ:\n\tcase ARM64_INS_CBNZ:\n\t\top->type = R_ANAL_OP_TYPE_CJMP;\n\t\top->jump = IMM64(1);\n\t\top->fail = addr+op->size;\n\t\tbreak;\n\tcase ARM64_INS_TBZ:\n\tcase ARM64_INS_TBNZ:\n\t\top->type = R_ANAL_OP_TYPE_CJMP;\n\t\top->jump = IMM64(2);\n\t\top->fail = addr+op->size;\n\t\tbreak;\n\tcase ARM64_INS_BR:\n\t\top->type = R_ANAL_OP_TYPE_UJMP; // RJMP ?\n\t\top->eob = true;\n\t\tbreak;\n\tcase ARM64_INS_B:\n\t\t// BX LR == RET\n\t\tif (insn->detail->arm64.operands[0].reg == ARM64_REG_LR) {\n\t\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\t} else if (insn->detail->arm64.cc) {\n\t\t\top->type = R_ANAL_OP_TYPE_CJMP;\n\t\t\top->jump = IMM64(0);\n\t\t\top->fail = addr + op->size;\n\t\t} else {\n\t\t\top->type = R_ANAL_OP_TYPE_JMP;\n\t\t\top->jump = IMM64(0);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tR_LOG_DEBUG (\"ARM64 analysis: Op type %d at 0x%\" PFMT64x \" not handled\\n\", insn->id, op->addr);\n\t\tbreak;\n\t}\n}\n\nstatic void anal_itblock(cs_insn *insn) {\n\tsize_t i, size =  r_str_nlen (insn->mnemonic, 5);\n\tht_uu_update (ht_itblock, insn->address,  size);\n\tfor (i = 1; i < size; i++) {\n\t\tswitch (insn->mnemonic[i]) {\n\t\tcase 0x74: //'t'\n\t\t\tht_uu_update (ht_it, insn->address + (i * insn->size), insn->detail->arm.cc);\n\t\t\tbreak;\n\t\tcase 0x65: //'e'\n\t\t\tht_uu_update (ht_it, insn->address + (i * insn->size), (insn->detail->arm.cc % 2)?\n\t\t\t\tinsn->detail->arm.cc + 1: insn->detail->arm.cc - 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void check_itblock(cs_insn *insn) {\n\tsize_t x;\n\tbool found;\n\tut64 itlen = ht_uu_find (ht_itblock, insn->address, &found);\n\tif (found) {\n\t\tfor (x = 1; x < itlen; x++) {\n\t\t\tht_uu_delete (ht_it, insn->address + (x*insn->size));\n\t\t}\n\t\tht_uu_delete (ht_itblock, insn->address);\n\t}\n}\n\nstatic void anop32(RAnal *a, csh handle, RAnalOp *op, cs_insn *insn, bool thumb, const ut8 *buf, int len) {\n\tconst ut64 addr = op->addr;\n\tconst int pcdelta = thumb? 4: 8;\n\tint i;\n\tbool found = 0;\n\tut64 itcond;\n\n\top->cond = cond_cs2r2 (insn->detail->arm.cc);\n\tif (op->cond == R_ANAL_COND_NV) {\n\t\top->type = R_ANAL_OP_TYPE_NOP;\n\t\treturn;\n\t}\n\top->cycles = 1;\n\t/* grab family */\n\tif (cs_insn_group (handle, insn, ARM_GRP_CRYPTO)) {\n\t\top->family = R_ANAL_OP_FAMILY_CRYPTO;\n\t} else if (cs_insn_group (handle, insn, ARM_GRP_CRC)) {\n\t\top->family = R_ANAL_OP_FAMILY_CRYPTO;\n#if CS_API_MAJOR >= 4\n\t} else if (cs_insn_group (handle, insn, ARM_GRP_PRIVILEGE)) {\n\t\top->family = R_ANAL_OP_FAMILY_PRIV;\n\t} else if (cs_insn_group (handle, insn, ARM_GRP_VIRTUALIZATION)) {\n\t\top->family = R_ANAL_OP_FAMILY_VIRT;\n#endif\n\t} else if (cs_insn_group (handle, insn, ARM_GRP_NEON)) {\n\t\top->family = R_ANAL_OP_FAMILY_MMX;\n\t} else if (cs_insn_group (handle, insn, ARM_GRP_FPARMV8)) {\n\t\top->family = R_ANAL_OP_FAMILY_FPU;\n\t} else if (cs_insn_group (handle, insn, ARM_GRP_THUMB2DSP)) {\n\t\top->family = R_ANAL_OP_FAMILY_MMX;\n\t} else {\n\t\top->family = R_ANAL_OP_FAMILY_CPU;\n\t}\n\n\tif (insn->id != ARM_INS_IT) {\n\t\tcheck_itblock (insn);\n\t}\n\n\tswitch (insn->id) {\n#if 0\n\nIf PC is specified for Rn, the value used is the address of the instruction plus 4.\n\nThese instructions cause a PC-relative forward branch using a table of single byte offsets (TBB) or halfword offsets (TBH). Rn provides a pointer to the table, and Rm supplies an index into the table. The branch length is twice the value of the byte (TBB) or the halfword (TBH) returned from the table. The target of the branch table must be in the same execution state.\n\njmp $$ + 4 + ( [delta] * 2 )\n\n#endif\n\tcase ARM_INS_TBH: // half word table\n\t\top->type = R_ANAL_OP_TYPE_UJMP;\n\t\top->cycles = 2;\n\t\top->ptrsize = 2;\n\t\top->ireg = r_str_getf (cs_reg_name (handle, INSOP (0).mem.index));\n\t\tbreak;\n\tcase ARM_INS_TBB: // byte jump table\n\t\top->type = R_ANAL_OP_TYPE_UJMP;\n\t\top->cycles = 2;\n\t\top->ptrsize = 1;\n\t\top->ireg = r_str_getf (cs_reg_name (handle, INSOP (0).mem.index));\n\t\tbreak;\n\tcase ARM_INS_PLD:\n\t\top->type = R_ANAL_OP_TYPE_LEA; // not really a lea, just a prefetch\n\t\tif (ISMEM (0)) {\n\t\t\tint regBase = REGBASE(0);\n\t\t\tint delta = MEMDISP(0);\n\t\t\tif (regBase == ARM_REG_PC) {\n\t\t\t\top->ptr = addr + 4 + delta;\n\t\t\t} else {\n\t\t\t\t// exotic pld\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_IT:\n\t\tanal_itblock (insn);\n\t\top->cycles = 2;\n\t\tbreak;\n\tcase ARM_INS_BKPT:\n\t\top->type = R_ANAL_OP_TYPE_TRAP;\n\t\top->cycles = 4;\n\t\tbreak;\n\tcase ARM_INS_NOP:\n\t\top->type = R_ANAL_OP_TYPE_NOP;\n\t\top->cycles = 1;\n\t\tbreak;\n\tcase ARM_INS_POP:\n\t\top->stackop = R_ANAL_STACK_INC;\n\t\top->stackptr = -4LL * insn->detail->arm.op_count;\n\t\t// fallthrough\n\tcase ARM_INS_FLDMDBX:\n\tcase ARM_INS_FLDMIAX:\n\tcase ARM_INS_LDMDA:\n\tcase ARM_INS_LDMDB:\n\tcase ARM_INS_LDMIB:\n\tcase ARM_INS_LDM:\n\t\top->type = R_ANAL_OP_TYPE_POP;\n\t\top->cycles = 2;\n\t\tfor (i = 0; i < insn->detail->arm.op_count; i++) {\n\t\t\tif (insn->detail->arm.operands[i].type == ARM_OP_REG &&\n\t\t\t\t\tinsn->detail->arm.operands[i].reg == ARM_REG_PC) {\n\t\t\t\tif (insn->detail->arm.cc == ARM_CC_AL) {\n\t\t\t\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\t\t\t} else {\n\t\t\t\t\top->type = R_ANAL_OP_TYPE_CRET;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_SUB:\n\t\tif (ISREG(0) && REGID(0) == ARM_REG_SP) {\n\t\t\t\top->stackop = R_ANAL_STACK_INC;\n\t\t\t\tif (ISIMM(1)) {\n\t\t\t\t\t//0x0000bf4e      95b0           sub sp, 0x54\n\t\t\t\t\top->stackptr = IMM(1);\n\t\t\t\t} else if ( ISIMM(2) && ISREG(1) && REGID(1) == ARM_REG_SP) {\n\t\t\t\t\t// 0x00008254    10d04de2     sub sp, sp, 0x10\n\t\t\t\t\top->stackptr = IMM(2);\n\t\t\t\t}\n\t\t\t\top->val = op->stackptr;\n\t\t}\n\t\top->cycles = 1;\n\t\t/* fall-thru */\n\tcase ARM_INS_SUBW:\n\tcase ARM_INS_SSUB8:\n\tcase ARM_INS_SSUB16:\n\t\top->type = R_ANAL_OP_TYPE_SUB;\n\t\tbreak;\n\tcase ARM_INS_ADD:\n\t\tif (ISREG (0) && REGID (0) == ARM_REG_SP) {\n\t\t\top->stackop = R_ANAL_STACK_INC;\n\t\t\tif (ISIMM (1)) {\n\t\t\t\t//add sp, 0x54\n\t\t\t\top->stackptr = -IMM (1);\n\t\t\t} else if (ISIMM (2) && ISREG (1) && REGID (1) == ARM_REG_SP) {\n\t\t\t\t//add sp, sp, 0x10\n\t\t\t\top->stackptr = -IMM (2);\n\t\t\t}\n\t\t\top->val = op->stackptr;\n\t\t}\n\tcase ARM_INS_ADC:\n\t\top->type = R_ANAL_OP_TYPE_ADD;\n\t\tif (REGID(0) == ARM_REG_PC) {\n\t\t\top->type = R_ANAL_OP_TYPE_UJMP;\n\t\t\tif (REGID(1) == ARM_REG_PC && insn->detail->arm.cc != ARM_CC_AL) {\n\t\t\t\t//op->type = R_ANAL_OP_TYPE_RCJMP;\n\t\t\t\top->type = R_ANAL_OP_TYPE_UCJMP;\n\t\t\t\top->fail = addr+op->size;\n\t\t\t\top->jump = ((addr & ~3LL) + (thumb? 4: 8) + MEMDISP(1)) & UT64_MAX;\n\t\t\t\top->ptr = (addr & ~3LL) + (thumb? 4: 8) + MEMDISP(1);\n\t\t\t\top->refptr = 4;\n\t\t\t\top->reg = r_str_getf (cs_reg_name (handle, INSOP (2).reg));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\top->cycles = 1;\n\t\tbreak;\n\t\t/* fall-thru */\n\tcase ARM_INS_ADDW:\n\tcase ARM_INS_SADD8:\n\tcase ARM_INS_SADD16:\n\t\top->type = R_ANAL_OP_TYPE_ADD;\n\t\tbreak;\n\tcase ARM_INS_SDIV:\n\tcase ARM_INS_UDIV:\n\t\top->cycles = 4;\n\t\t/* fall-thru */\n\tcase ARM_INS_VDIV:\n\t\top->type = R_ANAL_OP_TYPE_DIV;\n\t\tbreak;\n\tcase ARM_INS_MUL:\n\tcase ARM_INS_SMULL:\n\tcase ARM_INS_UMULL:\n\t\t/* TODO: if next instruction is also a MUL, cycles are /=2 */\n\t\t/* also known as Register Indexing Addressing */\n\t\top->cycles = 4;\n\t\t/* fall-thru */\n\tcase ARM_INS_VMUL:\n\t\top->type = R_ANAL_OP_TYPE_MUL;\n\t\tbreak;\n\tcase ARM_INS_TRAP:\n\t\top->type = R_ANAL_OP_TYPE_TRAP;\n\t\top->cycles = 2;\n\t\tbreak;\n\tcase ARM_INS_MOV:\n\t\tif (REGID(0) == ARM_REG_PC) {\n\t\t\tif (REGID(1) == ARM_REG_LR) {\n\t\t\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\t\t} else {\n\t\t\t\top->type = R_ANAL_OP_TYPE_UJMP;\n\t\t\t}\n\t\t}\n\t\tif (ISIMM(1)) {\n\t\t\top->val = IMM(1);\n\t\t}\n\t\t/* fall-thru */\n\tcase ARM_INS_MOVT:\n\tcase ARM_INS_MOVW:\n\tcase ARM_INS_VMOVL:\n\tcase ARM_INS_VMOVN:\n\tcase ARM_INS_VQMOVUN:\n\tcase ARM_INS_VQMOVN:\n\tcase ARM_INS_SBFX:\n\tcase ARM_INS_UBFX:\n\tcase ARM_INS_BIC:\n\tcase ARM_INS_BFI:\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\tbreak;\n\tcase ARM_INS_VMOV:\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\top->family = R_ANAL_OP_FAMILY_FPU;\n\t\top->cycles = 2;\n\t\tbreak;\n\tcase ARM_INS_UDF:\n\t\top->type = R_ANAL_OP_TYPE_TRAP;\n\t\top->cycles = 4;\n\t\tbreak;\n\tcase ARM_INS_SVC:\n\t\top->type = R_ANAL_OP_TYPE_SWI;\n\t\top->val = IMM(0);\n\t\tbreak;\n\tcase ARM_INS_ROR:\n\tcase ARM_INS_RRX:\n\t\top->cycles = 1;\n\t\top->type = R_ANAL_OP_TYPE_ROR;\n\t\tbreak;\n\tcase ARM_INS_AND:\n\t\top->type = R_ANAL_OP_TYPE_AND;\n\t\tbreak;\n\tcase ARM_INS_ORR:\n\tcase ARM_INS_ORN:\n\t\top->type = R_ANAL_OP_TYPE_OR;\n\t\tbreak;\n\tcase ARM_INS_EOR:\n\t\top->type = R_ANAL_OP_TYPE_XOR;\n\t\tbreak;\n\tcase ARM_INS_CMP:\n\tcase ARM_INS_CMN:\n\tcase ARM_INS_TST:\n\t\tif (ISIMM(1)) {\n\t\t\top->ptr = IMM(1);\n\t\t}\n\t\top->reg = r_str_getf (cs_reg_name (handle, INSOP (0).reg));\n\t\t/* fall-thru */\n\tcase ARM_INS_VCMP:\n\t\top->type = R_ANAL_OP_TYPE_CMP;\n\t\tbreak;\n\tcase ARM_INS_LSL:\n\t\top->cycles = 1;\n\t\top->type = R_ANAL_OP_TYPE_SHL;\n\t\tbreak;\n\tcase ARM_INS_LSR:\n\t\top->cycles = 1;\n\t\top->type = R_ANAL_OP_TYPE_SHR;\n\t\tbreak;\n\tcase ARM_INS_ASR:\n\t\top->cycles = 1;\n\t\top->type = R_ANAL_OP_TYPE_SAR;\n\t\tbreak;\n\tcase ARM_INS_PUSH:\n\t\top->stackop = R_ANAL_STACK_INC;\n\t\top->stackptr = 4LL * insn->detail->arm.op_count;\n\t\t// fallthrough\n\tcase ARM_INS_STM:\n\tcase ARM_INS_STMDA:\n\tcase ARM_INS_STMDB:\n\t\top->type = R_ANAL_OP_TYPE_PUSH;\n// 0x00008160    04202de5     str r2, [sp, -4]!\n// 0x000082a0    28000be5     str r0, [fp, -0x28]\n\t\tif (REGBASE(1) == ARM_REG_FP) {\n\t\t\top->stackop = R_ANAL_STACK_SET;\n\t\t\top->stackptr = 0;\n\t\t\top->ptr = MEMDISP(1);\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_STREX:\n\tcase ARM_INS_STREXB:\n\tcase ARM_INS_STREXD:\n\tcase ARM_INS_STREXH:\n\t\top->family = R_ANAL_OP_FAMILY_THREAD;\n\t\t/* fall-thru */\n\tcase ARM_INS_STR:\n\tcase ARM_INS_STRB:\n\tcase ARM_INS_STRD:\n\tcase ARM_INS_STRBT:\n\tcase ARM_INS_STRH:\n\tcase ARM_INS_STRHT:\n\tcase ARM_INS_STRT:\n\t\top->cycles = 4;\n\t\top->type = R_ANAL_OP_TYPE_STORE;\n\t\tif (REGBASE(1) == ARM_REG_FP) {\n\t\t\top->stackop = R_ANAL_STACK_SET;\n\t\t\top->stackptr = 0;\n\t\t\top->ptr = -MEMDISP(1);\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_SXTB:\n\tcase ARM_INS_SXTH:\n\t\top->cycles = 1;\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\tbreak;\n\tcase ARM_INS_LDREX:\n\tcase ARM_INS_LDREXB:\n\tcase ARM_INS_LDREXD:\n\tcase ARM_INS_LDREXH:\n\t\top->family = R_ANAL_OP_FAMILY_THREAD;\n\t\t/* fall-thru */\n\tcase ARM_INS_LDR:\n\tcase ARM_INS_LDRD:\n\tcase ARM_INS_LDRB:\n\tcase ARM_INS_LDRBT:\n\tcase ARM_INS_LDRH:\n\tcase ARM_INS_LDRHT:\n\tcase ARM_INS_LDRSB:\n\tcase ARM_INS_LDRSBT:\n\tcase ARM_INS_LDRSH:\n\tcase ARM_INS_LDRSHT:\n\tcase ARM_INS_LDRT:\n\t\top->cycles = 4;\n// 0x000082a8    28301be5     ldr r3, [fp, -0x28]\n\t\tif (REGID(0) == ARM_REG_PC) {\n\t\t\top->type = R_ANAL_OP_TYPE_UJMP;\n\t\t\tif (insn->detail->arm.cc != ARM_CC_AL) {\n\t\t\t\t//op->type = R_ANAL_OP_TYPE_MCJMP;\n\t\t\t\top->type = R_ANAL_OP_TYPE_UCJMP;\n\t\t\t}\n\t\t} else {\n\t\t\top->type = R_ANAL_OP_TYPE_LOAD;\n\t\t}\n\t\tswitch (insn->id) {\n\t\tcase ARM_INS_LDRB:\n\t\t\top->ptrsize = 1;\n\t\t\tbreak;\n\t\tcase ARM_INS_LDRH:\n\t\tcase ARM_INS_LDRHT:\n\t\t\top->ptrsize = 2;\n\t\t\tbreak;\n\t\t}\n\t\tif (REGBASE(1) == ARM_REG_FP) {\n\t\t\top->stackop = R_ANAL_STACK_GET;\n\t\t\top->stackptr = 0;\n\t\t\top->ptr = -MEMDISP(1);\n\t\t} else if (REGBASE(1) == ARM_REG_PC) {\n\t\t\top->ptr = (addr & ~3LL) + (thumb? 4: 8) + MEMDISP(1);\n\t\t\top->refptr = 4;\n\t\t\tif (REGID(0) == ARM_REG_PC && insn->detail->arm.cc != ARM_CC_AL) {\n\t\t\t\t//op->type = R_ANAL_OP_TYPE_MCJMP;\n\t\t\t\top->type = R_ANAL_OP_TYPE_UCJMP;\n\t\t\t\top->fail = addr+op->size;\n\t\t\t\top->jump = ((addr & ~3LL) + (thumb? 4: 8) + MEMDISP(1)) & UT64_MAX;\n\t\t\t\top->ireg = r_str_getf (cs_reg_name (handle, INSOP (1).mem.index));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_MRS:\n\tcase ARM_INS_MSR:\n\t\top->type = R_ANAL_OP_TYPE_MOV;\n\t\top->family = R_ANAL_OP_FAMILY_PRIV;\n\t\tbreak;\n\tcase ARM_INS_BLX:\n\t\top->cycles = 4;\n\t\tif (ISREG(0)) {\n\t\t\t/* blx reg */\n\t\t\top->type = R_ANAL_OP_TYPE_RCALL;\n\t\t} else {\n\t\t\t/* blx label */\n\t\t\top->type = R_ANAL_OP_TYPE_CALL;\n\t\t\top->jump = IMM(0) & UT32_MAX;\n\t\t\top->fail = addr + op->size;\n\t\t\top->hint.new_bits = (a->bits == 32)? 16 : 32;\n\t\t\t//switch instruction set always with blx label\n\t\t\t// r_anal_hint_set_bits (a, op->jump, a->bits == 32? 16 : 32);\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_BL:\n\t\t/* bl label */\n\t\top->cycles = 4;\n\t\top->type = R_ANAL_OP_TYPE_CALL;\n\t\top->jump = IMM(0) & UT32_MAX;\n\t\top->fail = addr + op->size;\n\t\top->hint.new_bits = a->bits;\n\t\tbreak;\n\tcase ARM_INS_CBZ:\n\tcase ARM_INS_CBNZ:\n\t\top->cycles = 4;\n\t\top->type = R_ANAL_OP_TYPE_CJMP;\n\t\top->jump = IMM(1) & UT32_MAX;\n\t\top->fail = addr + op->size;\n\t\tif (op->jump == op->fail) {\n\t\t\top->type = R_ANAL_OP_TYPE_JMP;\n\t\t\top->fail = UT64_MAX;\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_B:\n\t\t/* b.cc label */\n\t\top->cycles = 4;\n\t\tif (insn->detail->arm.cc == ARM_CC_INVALID) {\n\t\t\top->type = R_ANAL_OP_TYPE_ILL;\n\t\t\top->fail = addr+op->size;\n\t\t} else if (insn->detail->arm.cc == ARM_CC_AL) {\n\t\t\top->type = R_ANAL_OP_TYPE_JMP;\n\t\t\top->fail = UT64_MAX;\n\t\t} else {\n\t\t\top->type = R_ANAL_OP_TYPE_CJMP;\n\t\t\top->fail = addr+op->size;\n\t\t}\n\t\top->jump = IMM(0) & UT32_MAX;\n\t\t// propagate bits to create correctly hints ranges\n\t\top->hint.new_bits = a->bits;\n\t\tbreak;\n\tcase ARM_INS_BX:\n\tcase ARM_INS_BXJ:\n\t\t/* bx reg */\n\t\top->cycles = 4;\n\t\tswitch (REGID(0)) {\n\t\tcase ARM_REG_LR:\n\t\t\top->type = R_ANAL_OP_TYPE_RET;\n\t\t\tbreak;\n\t\tcase ARM_REG_IP:\n\t\t\top->type = R_ANAL_OP_TYPE_UJMP;\n\t\t\tbreak;\n\t\tcase ARM_REG_PC:\n\t\t\t// bx pc is well known without ESIL\n\t\t\top->type = R_ANAL_OP_TYPE_UJMP;\n\t\t\top->jump = (addr & ~3LL) + pcdelta;\n\t\t\top->hint.new_bits = 32;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\top->type = R_ANAL_OP_TYPE_UJMP;\n\t\t\top->eob = true;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase ARM_INS_ADR:\n\t\top->cycles = 2;\n\t\top->type = R_ANAL_OP_TYPE_LEA;\n\t\t// Set the pointer address and align it\n\t\top->ptr = IMM(1) + addr + 4 - (addr%4);\n\t\top->refptr = 1;\n\t\tbreak;\n\tcase ARM_INS_UXTAB:\n\tcase ARM_INS_UXTAB16:\n\t\top->type = R_ANAL_OP_TYPE_ADD;\n\t\top->ptr = 0LL;\n\t\top->ptrsize = 1;\n\t\tbreak;\n\tcase ARM_INS_UXTAH:\n\t\top->type = R_ANAL_OP_TYPE_ADD;\n\t\top->ptr = 0LL;\n\t\top->ptrsize = 2;\n\t\tbreak;\n\tcase ARM_INS_UXTB:\n\tcase ARM_INS_UXTB16:\n\t\top->type = R_ANAL_OP_TYPE_CAST;\n\t\top->ptr = 0LL;\n\t\top->ptrsize = 1;\n\t\tbreak;\n\tcase ARM_INS_UXTH:\n\t\top->type = R_ANAL_OP_TYPE_CAST;\n\t\top->ptr = 0LL;\n\t\top->ptrsize = 2;\n\t\tbreak;\n\tdefault:\n\t\tR_LOG_DEBUG (\"ARM analysis: Op type %d at 0x%\" PFMT64x \" not handled\\n\", insn->id, op->addr);\n\t\tbreak;\n\t}\n\titcond = ht_uu_find (ht_it,  addr, &found);\n\tif (found) {\n\t\tinsn->detail->arm.cc = itcond;\n\t\tinsn->detail->arm.update_flags = 0;\n\t\top->mnemonic = r_str_newf (\"%s%s%s%s\",\n\t\t\tr_anal_optype_to_string (op->type),\n\t\t\tcc_name (itcond),\n\t\t\tinsn->op_str[0]?\" \":\"\",\n\t\t\tinsn->op_str);\n\t\top->cond = itcond;\n\t}\n}\n\nstatic bool is_valid(arm_reg reg) {\n\treturn reg != ARM_REG_INVALID;\n}\n\nstatic int parse_reg_name(RReg *reg, RRegItem **reg_base, RRegItem **reg_delta, csh handle, cs_insn *insn, int reg_num) {\n\tcs_arm_op armop = INSOP (reg_num);\n\tswitch (armop.type) {\n\tcase ARM_OP_REG:\n\t\t*reg_base = r_reg_get (reg, cs_reg_name (handle, armop.reg), R_REG_TYPE_ALL);\n\t\tbreak;\n\tcase ARM_OP_MEM:\n\t\tif (is_valid (armop.mem.base) && is_valid (armop.mem.index)) {\n\t\t\t*reg_base = r_reg_get (reg, cs_reg_name (handle, armop.mem.base), R_REG_TYPE_ALL);\n\t\t\t*reg_delta = r_reg_get (reg, cs_reg_name (handle, armop.mem.index), R_REG_TYPE_ALL);\n\t\t} else if (is_valid (armop.mem.base)) {\n\t\t\t*reg_base = r_reg_get (reg, cs_reg_name (handle, armop.mem.base), R_REG_TYPE_ALL);\n\t\t} else if (is_valid (armop.mem.index)) {\n\t\t\t*reg_base = r_reg_get (reg, cs_reg_name (handle, armop.mem.index), R_REG_TYPE_ALL);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic bool is_valid64(arm64_reg reg) {\n\treturn reg != ARM64_REG_INVALID;\n}\n\nstatic char *reg_list[] = {\n\t\"x0\", \"x1\", \"x2\", \"x3\", \"x4\",\n\t\"x5\", \"x6\", \"x7\", \"x8\", \"x9\",\n\t\"x10\", \"x11\", \"x12\", \"x13\", \"x14\",\n\t\"x15\", \"x16\", \"x17\", \"x18\", \"x19\",\n\t\"x20\", \"x21\", \"x22\", \"x23\", \"x24\",\n\t\"x25\", \"x26\", \"x27\", \"x28\", \"x29\",\n\t\"x30\"\n};\n\nstatic int parse_reg64_name(RReg *reg, RRegItem **reg_base, RRegItem **reg_delta, csh handle, cs_insn *insn, int reg_num) {\n\tcs_arm64_op armop = INSOP64 (reg_num);\n\tswitch (armop.type) {\n\tcase ARM64_OP_REG:\n\t\t*reg_base = r_reg_get (reg, cs_reg_name (handle, armop.reg), R_REG_TYPE_ALL);\n\t\tbreak;\n\tcase ARM64_OP_MEM:\n\t\tif (is_valid64 (armop.mem.base) && is_valid64 (armop.mem.index)) {\n\t\t\t*reg_base = r_reg_get (reg, cs_reg_name (handle, armop.mem.base), R_REG_TYPE_ALL);\n\t\t\t*reg_delta = r_reg_get (reg, cs_reg_name (handle, armop.mem.index), R_REG_TYPE_ALL);\n\t\t} else if (is_valid64 (armop.mem.base)) {\n\t\t\t*reg_base = r_reg_get (reg, cs_reg_name (handle, armop.mem.base), R_REG_TYPE_ALL);\n\t\t} else if (is_valid64 (armop.mem.index)) {\n\t\t\t*reg_base = r_reg_get (reg, cs_reg_name (handle, armop.mem.index), R_REG_TYPE_ALL);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif (*reg_base && *(*reg_base)->name == 'w') {\n\t\t*reg_base = r_reg_get (reg, reg_list[atoi ((*reg_base)->name + 1)], R_REG_TYPE_ALL);\n\t}\n\treturn 0;\n}\n\nstatic void set_opdir(RAnalOp *op) {\n\tswitch (op->type & R_ANAL_OP_TYPE_MASK) {\n\tcase R_ANAL_OP_TYPE_LOAD:\n\t\top->direction = R_ANAL_OP_DIR_READ;\n\t\tbreak;\n\tcase R_ANAL_OP_TYPE_STORE:\n\t\top->direction = R_ANAL_OP_DIR_WRITE;\n\t\tbreak;\n\tcase R_ANAL_OP_TYPE_LEA:\n\t\top->direction = R_ANAL_OP_DIR_REF;\n\t\tbreak;\n\tcase R_ANAL_OP_TYPE_CALL:\n\tcase R_ANAL_OP_TYPE_JMP:\n\tcase R_ANAL_OP_TYPE_UJMP:\n\tcase R_ANAL_OP_TYPE_UCALL:\n\t\top->direction = R_ANAL_OP_DIR_EXEC;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nstatic void set_src_dst(RAnalValue *val, RReg *reg, csh *handle, cs_insn *insn, int x, int bits) {\n\tcs_arm_op armop = INSOP (x);\n\tcs_arm64_op arm64op = INSOP64 (x);\n\tif (bits == 64) {\n\t\tparse_reg64_name (reg, &val->reg, &val->regdelta, *handle, insn, x);\n\t} else {\n\t\tparse_reg_name (reg, &val->reg, &val->regdelta, *handle, insn, x);\n\t}\n\tif (bits == 64) {\n\t\tswitch (arm64op.type) {\n\t\tcase ARM64_OP_REG:\n\t\t\tbreak;\n\t\tcase ARM64_OP_MEM:\n\t\t\tval->delta = arm64op.mem.disp;\n\t\t\tbreak;\n\t\tcase ARM64_OP_IMM:\n\t\t\tval->imm = arm64op.imm;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (armop.type) {\n\t\tcase ARM_OP_REG:\n\t\t\tbreak;\n\t\tcase ARM_OP_MEM:\n\t\t\tval->mul = armop.mem.scale;\n\t\t\tval->delta = armop.mem.disp;\n\t\t\tbreak;\n\t\tcase ARM_OP_IMM:\n\t\t\tval->imm = armop.imm;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic void create_src_dst(RAnalOp *op) {\n\top->src[0] = r_anal_value_new ();\n\top->src[1] = r_anal_value_new ();\n\top->src[2] = r_anal_value_new ();\n\top->dst = r_anal_value_new ();\n}\n\nstatic void op_fillval(RAnal *anal, RAnalOp *op, csh handle, cs_insn *insn, int bits) {\n\tcreate_src_dst (op);\n\tint i, j;\n\tint count = bits == 64 ? insn->detail->arm64.op_count : insn->detail->arm.op_count;\n\tswitch (op->type & R_ANAL_OP_TYPE_MASK) {\n\tcase R_ANAL_OP_TYPE_MOV:\n\tcase R_ANAL_OP_TYPE_CMP:\n\tcase R_ANAL_OP_TYPE_ADD:\n\tcase R_ANAL_OP_TYPE_SUB:\n\tcase R_ANAL_OP_TYPE_MUL:\n\tcase R_ANAL_OP_TYPE_DIV:\n\tcase R_ANAL_OP_TYPE_SHR:\n\tcase R_ANAL_OP_TYPE_SHL:\n\tcase R_ANAL_OP_TYPE_SAL:\n\tcase R_ANAL_OP_TYPE_SAR:\n\tcase R_ANAL_OP_TYPE_OR:\n\tcase R_ANAL_OP_TYPE_AND:\n\tcase R_ANAL_OP_TYPE_XOR:\n\tcase R_ANAL_OP_TYPE_NOR:\n\tcase R_ANAL_OP_TYPE_NOT:\n\tcase R_ANAL_OP_TYPE_LOAD:\n\tcase R_ANAL_OP_TYPE_LEA:\n\tcase R_ANAL_OP_TYPE_ROR:\n\tcase R_ANAL_OP_TYPE_ROL:\n\tcase R_ANAL_OP_TYPE_CAST:\n\t\tfor (i = 1; i < count; i++) {\n#if CS_API_MAJOR > 3\n\t\t\tif (bits == 64) {\n\t\t\t\tcs_arm64_op arm64op = INSOP64 (i);\n\t\t\t\tif (arm64op.access == CS_AC_WRITE) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcs_arm_op armop = INSOP (i);\n\n\t\t\t\tif (armop.access == CS_AC_WRITE) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\t}\n\t\tfor (j = 0; j < 3; j++, i++) {\n\t\t\tset_src_dst (op->src[j], anal->reg, &handle, insn, i, bits);\n\t\t}\n\t\tset_src_dst (op->dst, anal->reg, &handle, insn, 0, bits);\n\t\tbreak;\n\tcase R_ANAL_OP_TYPE_STORE:\n\t\tif (count > 2) {\n\t\t\tif (bits == 64) {\n\t\t\t\tcs_arm64_op arm64op = INSOP64 (count - 1);\n\t\t\t\tif (arm64op.type == ARM64_OP_IMM) {\n\t\t\t\t\tcount--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcs_arm_op armop = INSOP (count - 1);\n\t\t\t\tif (armop.type == ARM_OP_IMM) {\n\t\t\t\t\tcount--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tset_src_dst (op->dst, anal->reg, &handle, insn, --count, bits);\n\t\tfor (j = 0; j < 3 && j < count; j++) {\n\t\t\tset_src_dst (op->src[j], anal->reg, &handle, insn, j, bits);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\tif ((bits == 64) && HASMEMINDEX64 (1)) {\n\t\top->ireg = r_str_getf (cs_reg_name (handle, INSOP64 (1).mem.index));\n\t} else if (HASMEMINDEX (1)) {\n\t\top->ireg = r_str_getf (cs_reg_name (handle, INSOP (1).mem.index));\n\t\top->scale = INSOP (1).mem.scale;\n\t}\n}\n\nstatic int analop(RAnal *a, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAnalOpMask mask) {\n\tstatic csh handle = 0;\n\tstatic int omode = -1;\n\tstatic int obits = 32;\n\tcs_insn *insn = NULL;\n\tint mode = (a->bits==16)? CS_MODE_THUMB: CS_MODE_ARM;\n\tint n, ret;\n\tmode |= (a->big_endian)? CS_MODE_BIG_ENDIAN: CS_MODE_LITTLE_ENDIAN;\n\tif (a->cpu && strstr (a->cpu, \"cortex\")) {\n\t\tmode |= CS_MODE_MCLASS;\n\t}\n\n\tif (mode != omode || a->bits != obits) {\n\t\tcs_close (&handle);\n\t\thandle = 0; // unnecessary\n\t\tomode = mode;\n\t\tobits = a->bits;\n\t}\n\top->size = (a->bits==16)? 2: 4;\n\top->addr = addr;\n\tif (handle == 0) {\n\t\tret = (a->bits == 64)?\n\t\t\tcs_open (CS_ARCH_ARM64, mode, &handle):\n\t\t\tcs_open (CS_ARCH_ARM, mode, &handle);\n\t\tcs_option (handle, CS_OPT_DETAIL, CS_OPT_ON);\n\t\tif (ret != CS_ERR_OK) {\n\t\t\thandle = 0;\n\t\t\treturn -1;\n\t\t}\n\t}\n\tint haa = hackyArmAnal (a, op, buf, len);\n\tif (haa > 0) {\n\t\treturn haa;\n\t}\n\n\tn = cs_disasm (handle, (ut8*)buf, len, addr, 1, &insn);\n\tif (n < 1) {\n\t\top->type = R_ANAL_OP_TYPE_ILL;\n\t\tif (mask & R_ANAL_OP_MASK_DISASM) {\n\t\t\top->mnemonic = strdup (\"invalid\");\n\t\t}\n\t} else {\n\t\tif (mask & R_ANAL_OP_MASK_DISASM) {\n\t\t\top->mnemonic = r_str_newf (\"%s%s%s\",\n\t\t\t\tinsn->mnemonic,\n\t\t\t\tinsn->op_str[0]?\" \":\"\",\n\t\t\t\tinsn->op_str);\n\t\t}\n\t\t//bool thumb = cs_insn_group (handle, insn, ARM_GRP_THUMB);\n\t\tbool thumb = a->bits == 16;\n\t\top->size = insn->size;\n\t\top->id = insn->id;\n\t\tif (a->bits == 64) {\n\t\t\tanop64 (handle, op, insn);\n\t\t\tif (mask & R_ANAL_OP_MASK_OPEX) {\n\t\t\t\topex64 (&op->opex, handle, insn);\n\t\t\t}\n\t\t\tif (mask & R_ANAL_OP_MASK_ESIL) {\n\t\t\t\tanalop64_esil (a, op, addr, buf, len, &handle, insn);\n\t\t\t}\n\t\t} else {\n\t\t\tanop32 (a, handle, op, insn, thumb, (ut8*)buf, len);\n\t\t\tif (mask & R_ANAL_OP_MASK_OPEX) {\n\t\t\t\topex (&op->opex, handle, insn);\n\t\t\t}\n\t\t\tif (mask & R_ANAL_OP_MASK_ESIL) {\n\t\t\t\tanalop_esil (a, op, addr, buf, len, &handle, insn, thumb);\n\t\t\t}\n\t\t}\n\t\tset_opdir (op);\n\t\tif (mask & R_ANAL_OP_MASK_VAL) {\n\t\t\top_fillval (a, op, handle, insn, a->bits);\n\t\t}\n\t\tcs_free (insn, n);\n\t}\n//\tcs_close (&handle);\n\treturn op->size;\n}\n\n#include \"anal_arm_regprofile.inc\"\n\nstatic int archinfo(RAnal *anal, int q) {\n\tif (q == R_ANAL_ARCHINFO_DATA_ALIGN) {\n\t\treturn 4;\n\t}\n\tif (q == R_ANAL_ARCHINFO_ALIGN) {\n\t\tif (anal && anal->bits == 16) {\n\t\t\treturn 2;\n\t\t}\n\t\treturn 4;\n\t}\n\tif (q == R_ANAL_ARCHINFO_INV_OP_SIZE) {\n\t\treturn 4;\n\t}\n\tif (q == R_ANAL_ARCHINFO_MAX_OP_SIZE) {\n\t\treturn 4;\n\t}\n\tif (q == R_ANAL_ARCHINFO_MIN_OP_SIZE) {\n\t\tif (anal && anal->bits == 16) {\n\t\t\treturn 2;\n\t\t}\n\t\treturn 4;\n\t}\n\treturn 4; // XXX\n}\n\nstatic ut8 *anal_mask(RAnal *anal, int size, const ut8 *data, ut64 at) {\n\tRAnalOp *op = NULL;\n\tut8 *ret = NULL;\n\tint oplen, idx = 0, obits = anal->bits;\n\tRAnalHint *hint = NULL;\n\n\tif (!data) {\n\t\treturn NULL;\n\t}\n\n\top = r_anal_op_new ();\n\tret = malloc (size);\n\tmemset (ret, 0xff, size);\n\n\twhile (idx < size) {\n\t\thint = r_anal_hint_get (anal, at + idx);\n\t\tif (hint) {\n\t\t\tif (hint->bits != 0) {\n\t\t\t\tanal->bits = hint->bits;\n\t\t\t}\n\t\t\tfree (hint);\n\t\t}\n\n\t\tif ((oplen = analop (anal, op, at + idx, data + idx, size - idx, R_ANAL_OP_MASK_BASIC)) < 1) {\n\t\t\tbreak;\n\t\t}\n\t\tif (op->ptr != UT64_MAX || op->jump != UT64_MAX) {\n\t\t\tif ((oplen * 8) > size - idx) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tut32 opcode = r_read_ble (data + idx, anal->big_endian, oplen * 8);\n\t\t\tswitch (oplen) {\n\t\t\tcase 2:\n\t\t\t\tmemcpy (ret + idx, \"\\xf0\\x00\", 2);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tif (anal->bits == 64) {\n\t\t\t\t\tswitch (op->id) {\n\t\t\t\t\tcase ARM64_INS_LDP:\n\t\t\t\t\tcase ARM64_INS_LDXP:\n\t\t\t\t\tcase ARM64_INS_LDXR:\n\t\t\t\t\tcase ARM64_INS_LDXRB:\n\t\t\t\t\tcase ARM64_INS_LDXRH:\n\t\t\t\t\tcase ARM64_INS_LDPSW:\n\t\t\t\t\tcase ARM64_INS_LDNP:\n\t\t\t\t\tcase ARM64_INS_LDTR:\n\t\t\t\t\tcase ARM64_INS_LDTRB:\n\t\t\t\t\tcase ARM64_INS_LDTRH:\n\t\t\t\t\tcase ARM64_INS_LDTRSB:\n\t\t\t\t\tcase ARM64_INS_LDTRSH:\n\t\t\t\t\tcase ARM64_INS_LDTRSW:\n\t\t\t\t\tcase ARM64_INS_LDUR:\n\t\t\t\t\tcase ARM64_INS_LDURB:\n\t\t\t\t\tcase ARM64_INS_LDURH:\n\t\t\t\t\tcase ARM64_INS_LDURSB:\n\t\t\t\t\tcase ARM64_INS_LDURSH:\n\t\t\t\t\tcase ARM64_INS_LDURSW:\n\t\t\t\t\tcase ARM64_INS_STP:\n\t\t\t\t\tcase ARM64_INS_STNP:\n\t\t\t\t\tcase ARM64_INS_STXR:\n\t\t\t\t\tcase ARM64_INS_STXRB:\n\t\t\t\t\tcase ARM64_INS_STXRH:\n\t\t\t\t\t\tr_write_ble (ret + idx, 0xffffffff, anal->big_endian, 32);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ARM64_INS_STRB:\n\t\t\t\t\tcase ARM64_INS_STURB:\n\t\t\t\t\tcase ARM64_INS_STURH:\n\t\t\t\t\tcase ARM64_INS_STUR:\n\t\t\t\t\tcase ARM64_INS_STR:\n\t\t\t\t\tcase ARM64_INS_STTR:\n\t\t\t\t\tcase ARM64_INS_STTRB:\n\t\t\t\t\tcase ARM64_INS_STRH:\n\t\t\t\t\tcase ARM64_INS_STTRH:\n\t\t\t\t\tcase ARM64_INS_LDR:\n\t\t\t\t\tcase ARM64_INS_LDRB:\n\t\t\t\t\tcase ARM64_INS_LDRH:\n\t\t\t\t\tcase ARM64_INS_LDRSB:\n\t\t\t\t\tcase ARM64_INS_LDRSW:\n\t\t\t\t\tcase ARM64_INS_LDRSH: {\n\t\t\t\t\t\tbool is_literal = (opcode & 0x38000000) == 0x18000000;\n\t\t\t\t\t\tif (is_literal) {\n\t\t\t\t\t\t\tr_write_ble (ret + idx, 0xff000000, anal->big_endian, 32);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_write_ble (ret + idx, 0xffffffff, anal->big_endian, 32);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase ARM64_INS_B:\n\t\t\t\t\tcase ARM64_INS_BL:\n\t\t\t\t\tcase ARM64_INS_CBZ:\n\t\t\t\t\tcase ARM64_INS_CBNZ:\n\t\t\t\t\t\tif (op->type == R_ANAL_OP_TYPE_CJMP) {\n\t\t\t\t\t\t\tr_write_ble (ret + idx, 0xff00001f, anal->big_endian, 32);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_write_ble (ret + idx, 0xfc000000, anal->big_endian, 32);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ARM64_INS_TBZ:\n\t\t\t\t\tcase ARM64_INS_TBNZ:\n\t\t\t\t\t\tr_write_ble (ret + idx, 0xfff8001f, anal->big_endian, 32);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ARM64_INS_ADR:\n\t\t\t\t\tcase ARM64_INS_ADRP:\n\t\t\t\t\t\tr_write_ble (ret + idx, 0xff00001f, anal->big_endian, 32);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tr_write_ble (ret + idx, 0xfff00000, anal->big_endian, 32);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tr_write_ble (ret + idx, 0xfff00000, anal->big_endian, 32);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tidx += oplen;\n\t}\n\n\tanal->bits = obits;\n\tr_anal_op_free (op);\n\n\treturn ret;\n}\n\nstatic RList *anal_preludes(RAnal *anal) {\n#define KW(d,ds,m,ms) r_list_append (l, r_search_keyword_new((const ut8*)d,ds,(const ut8*)m, ms, NULL))\n\tRList *l = r_list_newf ((RListFree)r_search_keyword_free);\n\tswitch (anal->bits) {\n\tcase 16:\n\t\tKW (\"\\x00\\xb5\", 2, \"\\x0f\\xff\", 2);\n\t\tKW (\"\\x08\\xb5\", 2, \"\\x0f\\xff\", 2);\n\t\tbreak;\n\tcase 32:\n\t\tKW(\"\\x00\\x00\\x2d\\xe9\", 4, \"\\x0f\\x0f\\xff\\xff\", 4);\n\t\tbreak;\n\tcase 64:\n\t\tKW (\"\\xf0\\x0f\\x00\\xf8\", 4, \"\\xf0\\x0f\\x00\\xff\", 4);\n\t\tKW (\"\\xf0\\x00\\x00\\xd1\", 4, \"\\xf0\\x00\\x00\\xff\", 4);\n\t\tKW (\"\\xf0\\x00\\x00\\xa9\", 4, \"\\xf0\\x00\\x00\\xff\", 4);\n\t\tKW (\"\\x7f\\x23\\x03\\xd5\\xff\", 5, NULL, 0);\n\t\tbreak;\n\tdefault:\n\t\tr_list_free (l);\n\t\tl = NULL;\n\t}\n\treturn l;\n}\n\nstatic int init(void* user) {\n\tif (!ht_it) {\n\t\tht_it = ht_uu_new0 ();\n\t}\n\tif (!ht_itblock) {\n\t\tht_itblock = ht_uu_new0 ();\n\t}\n\treturn 0;\n}\n\nstatic int fini(void* user) {\n\tht_uu_free (ht_itblock);\n\tht_uu_free (ht_it);\n\tht_itblock = NULL;\n\tht_it = NULL;\n\treturn 0;\n}\n\nRAnalPlugin r_anal_plugin_arm_cs = {\n\t.name = \"arm\",\n\t.desc = \"Capstone ARM analyzer\",\n\t.license = \"BSD\",\n\t.esil = true,\n\t.arch = \"arm\",\n\t.archinfo = archinfo,\n\t.get_reg_profile = get_reg_profile,\n\t.anal_mask = anal_mask,\n\t.preludes = anal_preludes,\n\t.bits = 16 | 32 | 64,\n\t.op = &analop,\n\t.init = &init,\n\t.fini = &fini,\n};\n\n#ifndef R2_PLUGIN_INCORE\nR_API RLibStruct radare_plugin = {\n\t.type = R_LIB_TYPE_ANAL,\n\t.data = &r_anal_plugin_arm_cs,\n\t.version = R2_VERSION\n};\n#endif\n"], "filenames": ["libr/anal/p/anal_arm_cs.c"], "buggy_code_start_loc": [1018], "buggy_code_end_loc": [1083], "fixing_code_start_loc": [1018], "fixing_code_end_loc": [1081], "type": "CWE-119", "message": "Access of Memory Location Before Start of Buffer in NPM radare2.js prior to 5.6.2.", "other": {"cve": {"id": "CVE-2022-0522", "sourceIdentifier": "security@huntr.dev", "published": "2022-02-08T21:15:20.000", "lastModified": "2022-04-08T13:41:33.990", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Access of Memory Location Before Start of Buffer in NPM radare2.js prior to 5.6.2."}, {"lang": "es", "value": "Un Acceso a una Ubicaci\u00f3n de Memoria Antes del Inicio del B\u00fafer en el repositorio de GitHub radareorg/radare2 versiones anteriores a 5.6.2"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.2}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-786"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.6.2", "matchCriteriaId": "B0653877-95C4-4D74-A0EA-9C5EFA579627"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://github.com/radareorg/radare2/commit/d17a7bdf166108a29a27cd89bf454f9fa6c050d6", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/2d45e589-d614-4875-bba1-be0f729e7ca9", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/BZTIMAS53YT66FUS4QHQAFRJOBMUFG6D/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/E6YBRQ3UCFWJVSOYIKPVUDASZ544TFND/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radareorg/radare2/commit/d17a7bdf166108a29a27cd89bf454f9fa6c050d6"}}