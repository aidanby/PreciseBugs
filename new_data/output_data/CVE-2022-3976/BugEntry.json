{"buggy_code": ["/*\n *  file_provider_linux.c\n *\n *  Copyright 2014-2018 Michael Zillgith\n *\n *  This file is part of libIEC61850.\n *\n *  libIEC61850 is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  libIEC61850 is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with libIEC61850.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  See COPYING file for the complete license text.\n */\n\n#include <string.h>\n#include <dirent.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#include \"hal_filesystem.h\"\n#include \"lib_memory.h\"\n\nstruct sDirectoryHandle {\n    DIR* handle;\n};\n\n\nFileHandle\nFileSystem_openFile(char* fileName, bool readWrite)\n{\n    FileHandle newHandle = NULL;\n\n    if (readWrite)\n        newHandle = (FileHandle) fopen(fileName, \"w\");\n    else\n        newHandle = (FileHandle) fopen(fileName, \"r\");\n\n    return newHandle;\n}\n\nint\nFileSystem_readFile(FileHandle handle, uint8_t* buffer, int maxSize)\n{\n    return fread(buffer, maxSize, 1, (FILE*) handle);\n}\n\nint\nFileSystem_writeFile(FileHandle handle, uint8_t* buffer, int size)\n{\n    return fwrite(buffer, size, 1, (FILE*) handle);\n}\n\nvoid\nFileSystem_closeFile(FileHandle handle)\n{\n    fclose((FILE*) handle);\n}\n\nbool\nFileSystem_deleteFile(char* filename)\n{\n    if (remove(filename) == 0)\n        return true;\n    else\n        return false;\n}\n\nbool\nFileSystem_renameFile(char* oldFilename, char* newFilename)\n{\n    if (rename(oldFilename, newFilename) == 0)\n        return true;\n    else\n        return false;\n}\n\n\nbool\nFileSystem_getFileInfo(char* filename, uint32_t* fileSize, uint64_t* lastModificationTimestamp)\n{\n    struct stat fileStats;\n\n    if (stat(filename, &fileStats) == -1)\n        return false;\n\n    if (lastModificationTimestamp != NULL)\n        *lastModificationTimestamp = (uint64_t) (fileStats.st_mtime) * 1000LL;\n        // does not work on older systems --> *lastModificationTimestamp = (uint64_t) (fileStats.st_ctim.tv_sec) * 1000LL;\n\n    if (fileSize != NULL)\n        *fileSize = fileStats.st_size;\n\n    return true;\n}\n\nDirectoryHandle\nFileSystem_openDirectory(char* directoryName)\n{\n    DIR* dirHandle = opendir(directoryName);\n\n    DirectoryHandle handle = NULL;\n\n    if (dirHandle != NULL) {\n        handle = (DirectoryHandle) GLOBAL_MALLOC(sizeof(struct sDirectoryHandle));\n        handle->handle = dirHandle;\n    }\n\n    return handle;\n}\n\nchar*\nFileSystem_readDirectory(DirectoryHandle directory, bool* isDirectory)\n{\n    struct dirent* dir;\n\n    dir = readdir(directory->handle);\n\n    if (dir != NULL) {\n        if (dir->d_name[0] == '.')\n            return FileSystem_readDirectory(directory, isDirectory);\n        else {\n            if (isDirectory != NULL) {\n                if (dir->d_type == DT_DIR)\n                    *isDirectory = true;\n                else\n                    *isDirectory = false;\n            }\n\n            return dir->d_name;\n        }\n    }\n    else\n        return NULL;\n}\n\nvoid\nFileSystem_closeDirectory(DirectoryHandle directory)\n{\n    closedir(directory->handle);\n    GLOBAL_FREEMEM(directory);\n}\n\n", "/*\n *  mms_common_internal.h\n *\n *  Copyright 2013-2019 Michael Zillgith\n *\n *  This file is part of libIEC61850.\n *\n *  libIEC61850 is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  libIEC61850 is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with libIEC61850.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  See COPYING file for the complete license text.\n */\n\n#ifndef MMS_COMMON_INTERNAL_H_\n#define MMS_COMMON_INTERNAL_H_\n\n#include \"mms_value.h\"\n#include \"MmsPdu.h\"\n#include \"conversions.h\"\n#include \"byte_buffer.h\"\n#include \"mms_server.h\"\n\n#define DEFAULT_MAX_SERV_OUTSTANDING_CALLING 5\n#define DEFAULT_MAX_SERV_OUTSTANDING_CALLED 5\n#define DEFAULT_DATA_STRUCTURE_NESTING_LEVEL 10\n\n#if (MMS_FILE_SERVICE == 1)\n\n#ifndef CONFIG_MMS_MAX_NUMBER_OF_OPEN_FILES_PER_CONNECTION\n#define CONFIG_MMS_MAX_NUMBER_OF_OPEN_FILES_PER_CONNECTION 5\n#endif\n\n#include \"hal_filesystem.h\"\n\ntypedef struct sMmsOutstandingCall* MmsOutstandingCall;\n\ntypedef struct {\n        int32_t frsmId;\n        uint32_t readPosition;\n        uint32_t fileSize;\n        FileHandle fileHandle;\n\n#if (MMS_OBTAIN_FILE_SERVICE == 1)\n        MmsOutstandingCall obtainRequest;\n#endif\n} MmsFileReadStateMachine;\n\n/* include for MmsFileReadHandler definition */\n#include \"mms_client_connection.h\"\n\nLIB61850_INTERNAL bool\nmmsMsg_parseFileOpenResponse(uint8_t* buffer, int bufPos, int maxBufPos, int32_t* frsmId, uint32_t* fileSize, uint64_t* lastModified);\n\nLIB61850_INTERNAL bool\nmmsMsg_parseFileReadResponse(uint8_t* buffer, int bufPos, int maxBufPos, uint32_t invokeId, int32_t frsmId,  bool* moreFollows, MmsConnection_FileReadHandler handler, void* handlerParameter);\n\nLIB61850_INTERNAL void\nmmsMsg_createFileReadResponse(int maxPduSize, uint32_t invokeId, ByteBuffer* response,  MmsFileReadStateMachine* frsm);\n\nLIB61850_INTERNAL void\nmmsMsg_createFileCloseResponse(uint32_t invokeId, ByteBuffer* response);\n\nLIB61850_INTERNAL void\nmmsMsg_createFileOpenResponse(const char* basepath, uint32_t invokeId, ByteBuffer* response, char* fullPath, MmsFileReadStateMachine* frsm);\n\nLIB61850_INTERNAL bool\nmmsMsg_parseFileName(char* filename, uint8_t* buffer, int* bufPos, int maxBufPos , uint32_t invokeId, ByteBuffer* response);\n\nLIB61850_INTERNAL void\nmmsMsg_createExtendedFilename(const char* basepath, int bufSize, char* extendedFileName, char* fileName);\n\nLIB61850_INTERNAL FileHandle\nmmsMsg_openFile(const char* basepath, char* fileName, bool readWrite);\n\n#endif /* (MMS_FILE_SERVICE == 1) */\n\ntypedef struct sMmsServiceError\n{\n    int errorClass;\n    int errorCode;\n} MmsServiceError;\n\n\nLIB61850_INTERNAL void /* Confirmed service error (ServiceError) */\nmmsMsg_createServiceErrorPdu(uint32_t invokeId, ByteBuffer* response, MmsError errorType);\n\nLIB61850_INTERNAL void\nmmsMsg_createMmsRejectPdu(uint32_t* invokeId, int reason, ByteBuffer* response);\n\nLIB61850_INTERNAL int\nmmsMsg_parseConfirmedErrorPDU(uint8_t* buffer, int bufPos, int maxBufPos, uint32_t* invokeId, bool* hasInvokeId, MmsServiceError* serviceError);\n\nLIB61850_INTERNAL int\nmmsMsg_parseRejectPDU(uint8_t* buffer, int bufPos, int maxBufPos, uint32_t* invokeId, bool* hasInvokeId, int* rejectType, int* rejectReason);\n\nLIB61850_INTERNAL MmsValue*\nmmsMsg_parseDataElement(Data_t* dataElement);\n\nLIB61850_INTERNAL Data_t*\nmmsMsg_createBasicDataElement(MmsValue* value);\n\nLIB61850_INTERNAL AccessResult_t**\nmmsMsg_createAccessResultsList(MmsPdu_t* mmsPdu, int resultsCount);\n\nLIB61850_INTERNAL char*\nmmsMsg_createStringFromAsnIdentifier(Identifier_t identifier);\n\nLIB61850_INTERNAL void\nmmsMsg_copyAsn1IdentifierToStringBuffer(Identifier_t identifier, char* buffer, int bufSize);\n\nLIB61850_INTERNAL char*\nmmsMsg_getComponentNameFromAlternateAccess(AlternateAccess_t* alternateAccess, char* componentNameBuf, int nameBufPos);\n\nLIB61850_INTERNAL void\nmmsMsg_deleteAccessResultList(AccessResult_t** accessResult, int variableCount);\n\n#endif /* MMS_COMMON_INTERNAL */\n\n", "/*\n *  mms_client_files.c\n *\n *  Copyright 2013 - 2022 Michael Zillgith\n *\n *  This file is part of libIEC61850.\n *\n *  libIEC61850 is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  libIEC61850 is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with libIEC61850.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  See COPYING file for the complete license text.\n */\n\n#include \"libiec61850_platform_includes.h\"\n#include \"stack_config.h\"\n#include \"mms_common.h\"\n#include \"mms_client_connection.h\"\n#include \"byte_buffer.h\"\n\n#include \"mms_client_internal.h\"\n#include \"ber_encoder.h\"\n#include \"ber_decode.h\"\n#include \"ber_integer.h\"\n#include \"conversions.h\"\n\n#if (MMS_OBTAIN_FILE_SERVICE == 1)\n\nstatic MmsFileReadStateMachine*\ngetFreeFrsm(MmsConnection connection)\n{\n    int i;\n\n    MmsFileReadStateMachine* freeFrsm = NULL;\n\n    for (i = 0; i < CONFIG_MMS_MAX_NUMBER_OF_OPEN_FILES_PER_CONNECTION; i++) {\n        if (connection->frsms[i].fileHandle == NULL) {\n            freeFrsm = &(connection->frsms[i]);\n            break;\n        }\n    }\n\n    return freeFrsm;\n}\n\nstatic MmsFileReadStateMachine*\ngetFrsm(MmsConnection connection, int32_t frsmId)\n{\n    int i;\n\n    MmsFileReadStateMachine* frsm = NULL;\n\n    for (i = 0; i < CONFIG_MMS_MAX_NUMBER_OF_OPEN_FILES_PER_CONNECTION; i++) {\n        if (connection->frsms[i].fileHandle != NULL) {\n            if (connection->frsms[i].frsmId == frsmId) {\n                frsm = &(connection->frsms[i]);\n                break;\n            }\n        }\n    }\n\n    return frsm;\n}\n\n\nstatic int32_t\ngetNextFrsmId(MmsConnection connection)\n{\n    uint32_t nextFrsmId = connection->nextFrsmId;\n    connection->nextFrsmId++;\n\n    return nextFrsmId;\n}\n\nvoid\nmmsClient_handleFileOpenRequest(\n    MmsConnection connection,\n    uint8_t* buffer, int bufPos, int maxBufPos,\n    uint32_t invokeId, ByteBuffer* response)\n{\n    char filename[256];\n    bool hasFileName = false;\n    uint32_t filePosition = 0;\n\n    while (bufPos < maxBufPos) {\n        uint8_t tag = buffer[bufPos++];\n        int length;\n\n        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n\n        if (bufPos < 0) goto exit_reject_invalid_pdu;\n\n        switch(tag) {\n        case 0xa0: /* filename */\n\n            if (!mmsMsg_parseFileName(filename, buffer, &bufPos, bufPos + length, invokeId, response))\n                return;\n\n            hasFileName = true;\n\n            break;\n\n        case 0x81: /* initial position */\n            filePosition = BerDecoder_decodeUint32(buffer, length, bufPos);\n            bufPos += length;\n            break;\n\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n\n        default: /* unrecognized parameter */\n            bufPos += length;\n            goto exit_reject_invalid_pdu;\n        }\n    }\n\n    if (hasFileName) {\n\n        MmsFileReadStateMachine* frsm = getFreeFrsm(connection);\n\n        if (frsm != NULL) {\n\n            MmsOutstandingCall obtainFileCall = mmsClient_getMatchingObtainFileRequest(connection, filename);\n\n            if (obtainFileCall) {\n\n                if (DEBUG_MMS_CLIENT)\n                    printf(\"MMS_CLIENT: file open is matching obtain file request for file %s\\n\", filename);\n\n                obtainFileCall->timeout = Hal_getTimeInMs() + connection->requestTimeout;\n            }\n\n            FileHandle fileHandle = mmsMsg_openFile(MmsConnection_getFilestoreBasepath(connection), filename, false);\n\n            if (fileHandle != NULL) {\n\n                frsm->fileHandle = fileHandle;\n                frsm->readPosition = filePosition;\n                frsm->frsmId = getNextFrsmId(connection);\n                frsm->obtainRequest = obtainFileCall;\n\n                mmsMsg_createFileOpenResponse(MmsConnection_getFilestoreBasepath(connection),\n                        invokeId, response, filename, frsm);\n            }\n            else\n                mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n\n        }\n        else\n            mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_RESOURCE_OTHER);\n    }\n    else\n        goto exit_invalid_parameter;\n\n    return;\n\nexit_invalid_parameter:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_REQUEST_INVALID_ARGUMENT, response);\n    return;\n\nexit_reject_invalid_pdu:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n}\n\n\nvoid\nmmsClient_handleFileReadRequest(\n    MmsConnection connection,\n    uint8_t* buffer, int bufPos, int maxBufPos,\n    uint32_t invokeId,\n    ByteBuffer* response)\n{\n    int32_t frsmId = BerDecoder_decodeInt32(buffer, maxBufPos - bufPos, bufPos);\n\n    if (DEBUG_MMS_CLIENT)\n        printf(\"MMS_CLIENT: mmsClient_handleFileReadRequest read request for frsmId: %i\\n\", frsmId);\n\n    MmsFileReadStateMachine* frsm = getFrsm(connection, frsmId);\n\n    if (frsm) {\n        if (frsm->obtainRequest)\n            frsm->obtainRequest->timeout = Hal_getTimeInMs() + connection->requestTimeout;\n\n        mmsMsg_createFileReadResponse(connection->parameters.maxPduSize, invokeId, response, frsm);\n    }\n    else\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_OTHER);\n}\n\nvoid\nmmsClient_handleFileCloseRequest(\n    MmsConnection connection,\n    uint8_t* buffer, int bufPos, int maxBufPos,\n    uint32_t invokeId,\n    ByteBuffer* response)\n{\n    int32_t frsmId = BerDecoder_decodeInt32(buffer, maxBufPos - bufPos, bufPos);\n\n    MmsFileReadStateMachine* frsm = getFrsm(connection, frsmId);\n\n    if (frsm) {\n        if (frsm->obtainRequest)\n            frsm->obtainRequest->timeout = Hal_getTimeInMs() + connection->requestTimeout;\n\n        if(frsm->fileHandle){\n            FileSystem_closeFile(frsm->fileHandle);\n            frsm->fileHandle = NULL;\n        }\n        frsm->frsmId = 0;\n        frsm->obtainRequest = NULL;\n\n        mmsMsg_createFileCloseResponse(invokeId, response);\n    }\n    else\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_OTHER);\n}\n\nvoid\nmmsClient_closeOutstandingOpenFiles(MmsConnection connection)\n{\n    int i;\n\n    for (i = 0; i < CONFIG_MMS_MAX_NUMBER_OF_OPEN_FILES_PER_CONNECTION; i++) {\n        if (connection->frsms[i].fileHandle != NULL) {\n            FileSystem_closeFile(connection->frsms[i].fileHandle);\n            connection->frsms[i].fileHandle = NULL;\n        }\n    }\n}\n\n\n#endif /* (MMS_OBTAIN_FILE_SERVICE == 1) */\n\n#if (MMS_FILE_SERVICE == 1)\n\nvoid\nmmsClient_createFileOpenRequest(uint32_t invokeId, ByteBuffer* request, const char* fileName, uint32_t initialPosition)\n{\n    uint32_t invokeIdSize = BerEncoder_UInt32determineEncodedSize(invokeId);\n\n    uint32_t fileNameStringSize = strlen(fileName);\n    uint32_t fileNameSize = 1 + BerEncoder_determineLengthSize(fileNameStringSize) + fileNameStringSize;\n\n    uint32_t fileNameSeqSize = fileNameSize;\n\n    uint32_t fileOpenRequestSize = 1 + BerEncoder_determineLengthSize(fileNameSeqSize) + fileNameSeqSize + 2 + BerEncoder_UInt32determineEncodedSize(initialPosition);\n\n    uint32_t confirmedRequestPduSize = 2  + invokeIdSize + 2 + BerEncoder_determineLengthSize(fileOpenRequestSize) + fileOpenRequestSize;\n\n    int bufPos = 0;\n    uint8_t* buffer = request->buffer;\n\n    bufPos = BerEncoder_encodeTL(0xa0, confirmedRequestPduSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeTL(0x02, invokeIdSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeUInt32(invokeId, buffer, bufPos);\n\n    /* Encode FileOpen tag (context | structured ) [72 = 48h] */\n    buffer[bufPos++] = 0xbf;\n    buffer[bufPos++] = 0x48;\n    bufPos = BerEncoder_encodeLength(fileOpenRequestSize, buffer, bufPos);\n\n    bufPos = BerEncoder_encodeTL(0xa0, fileNameSeqSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeOctetString(0x19, (uint8_t*) fileName, fileNameStringSize, buffer, bufPos);\n\n    bufPos = BerEncoder_encodeUInt32WithTL(0x81, initialPosition, buffer, bufPos);\n\n    request->size = bufPos;\n}\n\nvoid\nmmsClient_createFileDeleteRequest(uint32_t invokeId, ByteBuffer* request, const char* fileName)\n{\n    uint32_t invokeIdSize = BerEncoder_UInt32determineEncodedSize(invokeId);\n\n    uint32_t fileNameStringSize = strlen(fileName);\n    uint32_t fileNameSize = 1 + BerEncoder_determineLengthSize(fileNameStringSize) + fileNameStringSize;\n\n    uint32_t fileDeleteRequestSize = fileNameSize;\n\n    uint32_t confirmedRequestPduSize = 1 + 2 + invokeIdSize + 1 + BerEncoder_determineLengthSize(fileDeleteRequestSize) + fileDeleteRequestSize;\n\n    int bufPos = 0;\n    uint8_t* buffer = request->buffer;\n\n    bufPos = BerEncoder_encodeTL(0xa0, confirmedRequestPduSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeTL(0x02, invokeIdSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeUInt32(invokeId, buffer, bufPos);\n\n    /* Encode FileOpen tag (context | structured ) [76 = 4ch] */\n    buffer[bufPos++] = 0xbf;\n    buffer[bufPos++] = 0x4c;\n\n    bufPos = BerEncoder_encodeLength(fileDeleteRequestSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeOctetString(0x19, (uint8_t*) fileName, fileNameStringSize, buffer, bufPos);\n\n    request->size = bufPos;\n}\n\nvoid\nmmsClient_createFileReadRequest(uint32_t invokeId, ByteBuffer* request, int32_t frsmId)\n{\n    uint32_t invokeIdSize = BerEncoder_UInt32determineEncodedSize(invokeId);\n\n    uint8_t frsmIdBuf[5];\n    Asn1PrimitiveValue frsmIdBer;\n    frsmIdBer.octets = frsmIdBuf;\n    frsmIdBer.maxSize = 5;\n    frsmIdBer.size = 0;\n\n    BerInteger_setInt32(&frsmIdBer, frsmId);\n\n    uint32_t frsmIdSize = frsmIdBer.size;\n\n    uint32_t confirmedRequestPduSize = 1 + 2 + 2  + invokeIdSize + frsmIdSize;\n\n    int bufPos = 0;\n    uint8_t* buffer = request->buffer;\n\n    bufPos = BerEncoder_encodeTL(0xa0, confirmedRequestPduSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeTL(0x02, invokeIdSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeUInt32(invokeId, buffer, bufPos);\n\n    /* Encode FileRead tag (context | primitive ) [73 = 49h] */\n    buffer[bufPos++] = 0x9f;\n    bufPos = BerEncoder_encodeOctetString(0x49, frsmIdBer.octets, frsmIdBer.size, buffer, bufPos);\n\n    request->size = bufPos;\n}\n\nstatic int\nencodeFileSpecification(uint8_t tag, const char* fileSpecification, uint8_t* buffer, int bufPos)\n{\n    uint32_t fileNameStringSize = strlen(fileSpecification);\n    uint32_t fileNameSeqSize = 1 + BerEncoder_determineLengthSize(fileNameStringSize) + fileNameStringSize;\n\n    if (buffer != NULL) {\n\n        bufPos = BerEncoder_encodeTL(tag, fileNameSeqSize, buffer, bufPos);\n        bufPos = BerEncoder_encodeOctetString(0x19, (uint8_t*) fileSpecification, fileNameStringSize, buffer, bufPos);\n\n        return bufPos;\n    }\n    else {\n        return fileNameSeqSize + 1 + BerEncoder_determineLengthSize(fileNameSeqSize);\n    }\n}\n\nvoid\nmmsClient_createFileDirectoryRequest(uint32_t invokeId, ByteBuffer* request, const char* fileSpecification, const char* continueAfter)\n{\n    uint32_t invokeIdSize = BerEncoder_UInt32determineEncodedSize(invokeId);\n\n    uint32_t confirmedRequestPduSize = 1 + 2 + 1  + invokeIdSize;\n\n    uint32_t parameterSize = 0;\n\n    if (fileSpecification)\n        parameterSize += encodeFileSpecification(0xa0, fileSpecification, NULL, 0);\n\n    if (continueAfter)\n        parameterSize += encodeFileSpecification(0xa1, continueAfter, NULL, 0);\n\n    confirmedRequestPduSize += BerEncoder_determineLengthSize(parameterSize) + parameterSize;\n\n    int bufPos = 0;\n    uint8_t* buffer = request->buffer;\n\n    bufPos = BerEncoder_encodeTL(0xa0, confirmedRequestPduSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeTL(0x02, invokeIdSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeUInt32(invokeId, buffer, bufPos);\n\n    /* Encode FileRead tag (context | structured ) [77 = 4dh] */\n    buffer[bufPos++] = 0xbf;\n    buffer[bufPos++] = 0x4d;\n    bufPos = BerEncoder_encodeLength(parameterSize, buffer, bufPos);\n\n    if (fileSpecification)\n        bufPos = encodeFileSpecification(0xa0, fileSpecification, buffer, bufPos);\n\n    if (continueAfter)\n        bufPos = encodeFileSpecification(0xa1, continueAfter, buffer, bufPos);\n\n    request->size = bufPos;\n}\n\n\nvoid\nmmsClient_createFileRenameRequest(uint32_t invokeId, ByteBuffer* request, const char* currentFileName, const char* newFileName)\n{\n    uint32_t invokeIdSize = BerEncoder_UInt32determineEncodedSize(invokeId);\n\n    uint32_t parameterSize = 0;\n\n    parameterSize += encodeFileSpecification(0xa0, currentFileName, NULL, 0);\n\n    parameterSize += encodeFileSpecification(0xa1, newFileName, NULL, 0);\n\n    uint32_t confirmedRequestPduSize = 2  + invokeIdSize + 2 + BerEncoder_determineLengthSize(parameterSize) + parameterSize;\n\n    int bufPos = 0;\n    uint8_t* buffer = request->buffer;\n\n    bufPos = BerEncoder_encodeTL(0xa0, confirmedRequestPduSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeTL(0x02, invokeIdSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeUInt32(invokeId, buffer, bufPos);\n\n    /* Encode FileRead tag (context | structured ) [75 = 4bh] */\n    buffer[bufPos++] = 0xbf;\n    buffer[bufPos++] = 0x4b;\n    bufPos = BerEncoder_encodeLength(parameterSize, buffer, bufPos);\n\n    bufPos = encodeFileSpecification(0xa0, currentFileName, buffer, bufPos);\n\n    bufPos = encodeFileSpecification(0xa1, newFileName, buffer, bufPos);\n\n    request->size = bufPos;\n}\n\nvoid\nmmsClient_createObtainFileRequest(uint32_t invokeId, ByteBuffer* request, const char* sourceFile, const char* destinationFile)\n{\n    uint32_t invokeIdSize = BerEncoder_UInt32determineEncodedSize(invokeId);\n\n    uint32_t parameterSize = 0;\n\n    parameterSize += encodeFileSpecification(0xa0, sourceFile, NULL, 0);\n\n    parameterSize += encodeFileSpecification(0xa1, destinationFile, NULL, 0);\n\n    uint32_t confirmedRequestPduSize = 2  + invokeIdSize + 2 + BerEncoder_determineLengthSize(parameterSize) + parameterSize;\n\n    int bufPos = 0;\n    uint8_t* buffer = request->buffer;\n\n    bufPos = BerEncoder_encodeTL(0xa0, confirmedRequestPduSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeTL(0x02, invokeIdSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeUInt32(invokeId, buffer, bufPos);\n\n    /* Encode ObtainFile tag (context | structured ) [46 = 2eh] */\n    buffer[bufPos++] = 0xbf;\n    buffer[bufPos++] = 0x2e;\n    bufPos = BerEncoder_encodeLength(parameterSize, buffer, bufPos);\n\n    bufPos = encodeFileSpecification(0xa1, sourceFile, buffer, bufPos);\n\n    bufPos = encodeFileSpecification(0xa2, destinationFile, buffer, bufPos);\n\n    request->size = bufPos;\n}\n\n\nstatic bool\nparseFileAttributes(uint8_t* buffer, int bufPos, int maxBufPos, uint32_t* fileSize, uint64_t* lastModified)\n{\n    int endPos = maxBufPos;\n\n    while (bufPos < endPos) {\n        uint8_t tag = buffer[bufPos++];\n        int length;\n\n        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, endPos);\n        if (bufPos < 0)\n            return false;\n\n        switch (tag) {\n        case 0x80: /* sizeOfFile */\n            if (fileSize != NULL)\n                *fileSize = BerDecoder_decodeUint32(buffer, length, bufPos);\n            break;\n        case 0x81: /* lastModified */\n            {\n                if (lastModified != NULL) {\n                    char gtString[40];\n                    memcpy(gtString, buffer + bufPos, length);\n                    gtString[length] = 0;\n                    *lastModified = Conversions_generalizedTimeToMsTime(gtString);\n                }\n            }\n            break;\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n        default:\n            return false;\n        }\n\n        bufPos += length;\n    }\n\n    return true;\n}\n\nstatic bool\nparseDirectoryEntry(uint8_t* buffer, int bufPos, int maxBufPos, uint32_t invokeId, MmsConnection_FileDirectoryHandler handler, void* parameter)\n{\n    char fileNameMemory[400];\n    char* filename = NULL;\n    uint32_t fileSize = 0;\n    uint64_t lastModified = 0;\n\n    while (bufPos < maxBufPos) {\n        uint8_t tag = buffer[bufPos++];\n        int length;\n\n        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n        if (bufPos < 0) {\n            if (DEBUG_MMS_CLIENT)\n                printf(\"MMS_CLIENT: invalid length field\\n\");\n            return false;\n        }\n\n        switch (tag) {\n        case 0xa0: /* file-name */\n\n            filename = fileNameMemory;\n\n            tag = buffer[bufPos++];\n\n            bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n            if (bufPos < 0) {\n                if (DEBUG_MMS_CLIENT)\n                    printf(\"MMS_CLIENT: invalid length field\\n\");\n                return false;\n            }\n\n            memcpy(filename, buffer + bufPos, length);\n            filename[length] = 0;\n\n            bufPos += length;\n            break;\n        case 0xa1: /* file-attributes */\n            if (!parseFileAttributes(buffer, bufPos, bufPos + length, &fileSize, &lastModified))\n                return false;\n            bufPos += length;\n            break;\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n        default:\n            bufPos += length;\n            if (DEBUG_MMS_CLIENT)\n                printf(\"MMS_CLIENT: message contains unknown tag!\\n\");\n\n            return false;\n        }\n    }\n\n    if (filename != NULL)\n        handler(invokeId, parameter, MMS_ERROR_NONE, filename, fileSize, lastModified, true);\n    else\n        return false;\n\n    return true;\n}\n\nstatic bool\nparseListOfDirectoryEntries(uint8_t* buffer, int bufPos, int maxBufPos, uint32_t invokeId,\n        MmsConnection_FileDirectoryHandler handler, void* parameter)\n{\n    uint8_t tag = buffer[bufPos++];\n\n    if (tag != 0x30)\n        return false;\n\n    int length;\n\n    bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n\n    if (bufPos < 0) return false;\n\n    int endPos = bufPos + length;\n\n    while (bufPos < endPos) {\n        tag = buffer[bufPos++];\n\n        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n        if (bufPos < 0) return false;\n\n        switch (tag) {\n        case 0x30: /* Sequence */\n            parseDirectoryEntry(buffer, bufPos, bufPos + length, invokeId, handler, parameter);\n            bufPos += length;\n            break;\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n        default:\n            bufPos += length;\n            if (DEBUG_MMS_CLIENT)\n                printf(\"mmsClient_parseFileDirectoryResponse: message contains unknown tag!\\n\");\n            return false;\n        }\n    }\n\n    return true;\n}\n\n\nbool\nmmsClient_parseFileDirectoryResponse(ByteBuffer* response, int bufPos, uint32_t invokeId, MmsConnection_FileDirectoryHandler handler, void* parameter)\n{\n    uint8_t* buffer = response->buffer;\n    int maxBufPos = response->size;\n    int length;\n\n    uint8_t tag = buffer[bufPos++];\n\n    if (tag != 0xbf) {\n        if (DEBUG_MMS_CLIENT)\n            printf(\"mmsClient_parseFileDirectoryResponse: unknown tag %02x\\n\", tag);\n        return false;\n    }\n\n    tag = buffer[bufPos++];\n\n    if (tag != 0x4d) {\n        if (DEBUG_MMS_CLIENT)\n            printf(\"mmsClient_parseFileDirectoryResponse: unknown tag %02x\\n\", tag);\n        return false;\n    }\n\n    bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n    if (bufPos < 0) return false;\n\n    int endPos = bufPos + length;\n\n    bool moreFollows = false;\n\n    while (bufPos < endPos) {\n        tag = buffer[bufPos++];\n\n        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n        if (bufPos < 0) return false;\n\n        switch (tag) {\n        case 0xa0: /* listOfDirectoryEntries */\n            parseListOfDirectoryEntries(buffer, bufPos, bufPos + length, invokeId, handler, parameter);\n\n            bufPos += length;\n            break;\n        case 0x81: /* moreFollows */\n            moreFollows = BerDecoder_decodeBoolean(buffer, bufPos);\n            bufPos += length;\n            break;\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n        default:\n            bufPos += length;\n            if (DEBUG_MMS_CLIENT)\n                printf(\"mmsClient_parseFileDirectoryResponse: message contains unknown tag!\\n\");\n            break;\n        }\n    }\n\n    handler(invokeId, parameter, MMS_ERROR_NONE, NULL, 0, 0, moreFollows);\n\n    return true;\n}\n\nbool\nmmsMsg_parseFileOpenResponse(uint8_t* buffer, int bufPos, int maxBufPos, int32_t* frsmId, uint32_t* fileSize, uint64_t* lastModified)\n{\n    int length;\n\n    uint8_t tag = buffer[bufPos++];\n\n    if (tag != 0xbf) {\n        if (DEBUG_MMS_CLIENT)\n            printf(\"MMS: mmsClient_parseFileOpenResponse: unknown tag %02x\\n\", tag);\n        return false;\n    }\n\n    tag = buffer[bufPos++];\n\n    if (tag != 0x48) {\n        if (DEBUG_MMS_CLIENT)\n            printf(\"MMS_CLIENT: mmsClient_parseFileOpenResponse: unknown tag %02x\\n\", tag);\n        return false;\n    }\n\n    bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n    if (bufPos < 0)\n        return false;\n\n    int endPos = bufPos + length;\n\n    while (bufPos < endPos) {\n        tag = buffer[bufPos++];\n\n        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n        if (bufPos < 0)\n            return false;\n\n        switch (tag) {\n        case 0x80: /* frsmId */\n            *frsmId = BerDecoder_decodeInt32(buffer, length, bufPos);\n\n            bufPos += length;\n            break;\n        case 0xa1: /* fileAttributes */\n            if (!parseFileAttributes(buffer, bufPos, bufPos + length, fileSize, lastModified))\n                return false;\n            bufPos += length;\n            break;\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n        default:\n            bufPos += length;\n            if (DEBUG_MMS_CLIENT)\n                printf(\"MMS_CLIENT/SERVER: mmsClient_parseFileOpenResponse: message contains unknown tag %02x!\\n\", tag);\n            break;\n        }\n    }\n\n    return true;\n}\n\nbool\nmmsMsg_parseFileReadResponse(uint8_t* buffer, int bufPos, int maxBufPos, uint32_t invokeId, int frsmId, bool* moreFollows, MmsConnection_FileReadHandler handler, void* handlerParameter)\n{\n    int length;\n    uint8_t* data = NULL;\n    int dataLen = 0;\n\n\n    uint8_t tag = buffer[bufPos++];\n\n\n    if (tag != 0xbf) {\n        if (DEBUG_MMS_CLIENT)\n            printf(\"MMS_CLIENT/SERVER: mmsClient_parseFileReadResponse: unknown tag %02x\\n\", tag);\n        return false;\n    }\n\n    tag = buffer[bufPos++];\n\n    *moreFollows = true;\n\n    if (tag != 0x49) {\n        if (DEBUG_MMS_CLIENT)\n            printf(\"MMS_CLIENT/SERVER: mmsClient_parseFileReadResponse: unknown tag %02x\\n\", tag);\n        return false;\n    }\n\n    bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n    if (bufPos < 0)\n        return false;\n\n    int endPos = bufPos + length;\n\n    while (bufPos < endPos) {\n        tag = buffer[bufPos++];\n\n        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n        if (bufPos < 0)\n            return false;\n\n        switch (tag) {\n        case 0x80: /* fileData */\n            data = buffer + bufPos;\n            dataLen = length;\n\n            bufPos += length;\n            break;\n\n        case 0x81: /* moreFollows */\n            *moreFollows = BerDecoder_decodeBoolean(buffer, bufPos);\n            bufPos += length;\n            break;\n\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n\n        default:\n            bufPos += length;\n            if (DEBUG_MMS_CLIENT)\n                printf(\"MMS_CLIENT/SERVER: mmsClient_parseFileReadResponse: message contains unknown tag %02x!\\n\", tag);\n\n            return false;\n        }\n    }\n\n    handler(invokeId, handlerParameter, MMS_ERROR_NONE, frsmId, data, dataLen, *moreFollows);\n\n    return true;\n}\n\nvoid\nmmsClient_createFileCloseRequest(uint32_t invokeId, ByteBuffer* request, int32_t frsmId)\n{\n    uint32_t invokeIdSize = BerEncoder_UInt32determineEncodedSize(invokeId);\n\n    uint8_t frsmIdBuf[5];\n    Asn1PrimitiveValue frsmIdBer;\n    frsmIdBer.octets = frsmIdBuf;\n    frsmIdBer.maxSize = 5;\n    frsmIdBer.size = 0;\n\n    BerInteger_setInt32(&frsmIdBer, frsmId);\n\n    uint32_t confirmedRequestPduSize = 1 + 2 + 2  + invokeIdSize + frsmIdBer.size;\n\n    int bufPos = 0;\n    uint8_t* buffer = request->buffer;\n\n    bufPos = BerEncoder_encodeTL(0xa0, confirmedRequestPduSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeTL(0x02, invokeIdSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeUInt32(invokeId, buffer, bufPos);\n\n    /* Encode FileClose tag (context | primitive) [74 = 4ah] */\n    buffer[bufPos++] = 0x9f;\n    bufPos = BerEncoder_encodeOctetString(0x4a, frsmIdBer.octets, frsmIdBer.size, buffer, bufPos);\n\n    request->size = bufPos;\n}\n\n#endif /* (MMS_FILE_SERVICE == 1) */\n", "/*\n *  mms_common_msg.c\n *\n *  Copyright 2013-2022 Michael Zillgith\n *\n *  This file is part of libIEC61850.\n *\n *  libIEC61850 is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  libIEC61850 is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with libIEC61850.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  See COPYING file for the complete license text.\n */\n\n#include \"libiec61850_platform_includes.h\"\n#include \"mms_common_internal.h\"\n#include \"stack_config.h\"\n#include \"mms_value_internal.h\"\n#include \"ber_decode.h\"\n\nstatic void\nmmsMsg_createFloatData(MmsValue* value, int* size, uint8_t** buf)\n{\n    if (value->value.floatingPoint.formatWidth == 64) {\n        *size = 9;\n        *buf = (uint8_t*) GLOBAL_MALLOC(9);\n        (*buf)[0] = 11;\n#if (ORDER_LITTLE_ENDIAN == 1)\n        memcpyReverseByteOrder((*buf) + 1, value->value.floatingPoint.buf, 8);\n#else\n        memcpy((*buf) + 1, value->value.floatingPoint.buf, 8);\n#endif\n    } else {\n        *size = 5;\n        *buf = (uint8_t*) GLOBAL_MALLOC(5);\n        (*buf)[0] = 8;\n#if (ORDER_LITTLE_ENDIAN == 1)\n        memcpyReverseByteOrder((*buf) + 1, value->value.floatingPoint.buf, 4);\n#else\n        memcpy((*buf) + 1, value->value.floatingPoint.buf, 4);\n#endif\n    }\n}\n\nData_t*\nmmsMsg_createBasicDataElement(MmsValue* value)\n{\n    Data_t* dataElement = (Data_t*) GLOBAL_CALLOC(1, sizeof(Data_t));\n\n    switch (value->type) {\n    case MMS_ARRAY:\n        {\n            int size = MmsValue_getArraySize(value);\n            dataElement->present = Data_PR_array;\n            dataElement->choice.array = (DataSequence_t*) GLOBAL_CALLOC(1, sizeof(DataSequence_t));\n            dataElement->choice.array->list.count = size;\n            dataElement->choice.array->list.size = size;\n            dataElement->choice.array->list.array = (Data_t**) GLOBAL_CALLOC(size, sizeof(Data_t*));\n            int i;\n            for (i = 0; i < size; i++) {\n                dataElement->choice.array->list.array[i] =\n                        mmsMsg_createBasicDataElement(MmsValue_getElement(value, i));\n            }\n        }\n        break;\n\n    case MMS_STRUCTURE:\n        {\n            int size = value->value.structure.size;\n\n            dataElement->present = Data_PR_structure;\n            dataElement->choice.structure = (DataSequence_t*) GLOBAL_CALLOC(1, sizeof(DataSequence_t));\n            dataElement->choice.structure->list.count = size;\n            dataElement->choice.structure->list.size = size;\n            dataElement->choice.structure->list.array = (Data_t**) GLOBAL_CALLOC(size, sizeof(Data_t*));\n            int i;\n            for (i = 0; i < size; i++) {\n                dataElement->choice.structure->list.array[i] = mmsMsg_createBasicDataElement(\n                        value->value.structure.components[i]);\n            }\n        }\n        break;\n\n    case MMS_BIT_STRING: \n\t\t{\n\t\t\tdataElement->present = Data_PR_bitstring;\n\t\t\tdataElement->choice.bitstring.buf = value->value.bitString.buf;\n\t\t\tint size = (value->value.bitString.size / 8) + ((value->value.bitString.size % 8) > 0);\n\t\t\tint unused = 8 - (value->value.bitString.size % 8);\n\t\t\tdataElement->choice.bitstring.size = size; /* size in bytes */\n\t\t\tdataElement->choice.bitstring.bits_unused = unused;\n\t\t}\n        break;\n\n    case MMS_BOOLEAN:\n        dataElement->present = Data_PR_boolean;\n        dataElement->choice.boolean = value->value.boolean;\n        break;\n\n    case MMS_FLOAT:\n        dataElement->present = Data_PR_floatingpoint;\n\n        mmsMsg_createFloatData(value, &dataElement->choice.floatingpoint.size,\n                &dataElement->choice.floatingpoint.buf);\n        break;\n\n    case MMS_UTC_TIME:\n        dataElement->present = Data_PR_utctime;\n\n        dataElement->choice.utctime.buf = (uint8_t*) GLOBAL_MALLOC(8);\n        memcpy(dataElement->choice.utctime.buf, value->value.utcTime, 8);\n        dataElement->choice.utctime.size = 8;\n        break;\n\n    case MMS_INTEGER:\n        dataElement->present = Data_PR_integer;\n\n        dataElement->choice.integer.size = value->value.integer->size;\n        dataElement->choice.integer.buf = value->value.integer->octets;\n\n        break;\n\n    case MMS_UNSIGNED:\n        dataElement->present = Data_PR_unsigned;\n\n        dataElement->choice.Unsigned.size = value->value.integer->size;\n        dataElement->choice.Unsigned.buf = value->value.integer->octets;\n\n        break;\n\n    case MMS_VISIBLE_STRING:\n        dataElement->present = Data_PR_visiblestring;\n        if (value->value.visibleString.buf != NULL ) {\n            dataElement->choice.visiblestring.buf = (uint8_t*) value->value.visibleString.buf;\n            dataElement->choice.visiblestring.size = strlen(value->value.visibleString.buf);\n        } else\n            dataElement->choice.visiblestring.size = 0;\n        break;\n\n    case MMS_OCTET_STRING:\n        dataElement->present = Data_PR_octetstring;\n        if (value->value.octetString.buf != NULL ) {\n            dataElement->choice.octetstring.buf = value->value.octetString.buf;\n            dataElement->choice.octetstring.size =\n                    value->value.octetString.size;\n        } else\n            dataElement->choice.octetstring.size = 0;\n        break;\n\n    case MMS_STRING:\n        dataElement->present = Data_PR_mMSString;\n        if (value->value.visibleString.buf != NULL ) {\n            dataElement->choice.mMSString.buf = (uint8_t*) value->value.visibleString.buf;\n            dataElement->choice.mMSString.size = strlen(value->value.visibleString.buf);\n        } else\n            dataElement->choice.mMSString.size = 0;\n        break;\n\n    case MMS_BINARY_TIME:\n        dataElement->present = Data_PR_binarytime;\n        dataElement->choice.binarytime.size = value->value.binaryTime.size;\n        dataElement->choice.binarytime.buf = value->value.binaryTime.buf;\n        break;\n\n    default:\n        dataElement->present = Data_PR_NOTHING;\n\n        break;\n    }\n\n    return dataElement;\n}\n\nMmsValue*\nmmsMsg_parseDataElement(Data_t* dataElement)\n{\n    MmsValue* value = NULL;\n\n    if (dataElement->present == Data_PR_array) {\n\n        int componentCount = dataElement->choice.array->list.count;\n\n        if (componentCount > 0) {\n            value = (MmsValue*) GLOBAL_CALLOC(1, sizeof(MmsValue));\n\n            if (value) {\n                value->type = MMS_ARRAY;\n                value->value.structure.size = componentCount;\n                value->value.structure.components = (MmsValue**) GLOBAL_CALLOC(componentCount, sizeof(MmsValue*));\n\n                int i;\n\n                for (i = 0; i < componentCount; i++) {\n                    value->value.structure.components[i] =\n                            mmsMsg_parseDataElement(dataElement->choice.array->list.array[i]);\n\n                    if (value->value.structure.components[i] == NULL) {\n                        MmsValue_delete(value);\n                        value = NULL;\n                        break;\n                    }\n                }\n            }\n        }\n        else {\n            if (DEBUG_MMS_CLIENT)\n                printf(\"MMS CLIENT: error parsing data element (invalid array size)!\\n\");\n        }\n\n    }\n    else if (dataElement->present == Data_PR_structure) {\n\n        int componentCount = dataElement->choice.structure->list.count;\n\n        if (componentCount > 0) {\n            value = (MmsValue*) GLOBAL_CALLOC(1, sizeof(MmsValue));\n\n            if (value) {\n                value->type = MMS_STRUCTURE;\n                value->value.structure.size = componentCount;\n                value->value.structure.components = (MmsValue**) GLOBAL_CALLOC(componentCount, sizeof(MmsValue*));\n\n                int i;\n\n                for (i = 0; i < componentCount; i++) {\n                    value->value.structure.components[i] =\n                            mmsMsg_parseDataElement(dataElement->choice.structure->list.array[i]);\n\n                    if (value->value.structure.components[i] == NULL) {\n                        MmsValue_delete(value);\n                        value = NULL;\n                        break;\n                    }\n                }\n            }\n        }\n        else {\n            if (DEBUG_MMS_CLIENT)\n                printf(\"MMS CLIENT: error parsing data element (invalid structure size)!\\n\");\n        }\n    }\n    else {\n        if (dataElement->present == Data_PR_integer) {\n\n            if (dataElement->choice.integer.size > 0) {\n                Asn1PrimitiveValue* berInteger = BerInteger_createFromBuffer(\n                        dataElement->choice.integer.buf, dataElement->choice.integer.size);\n\n                if (berInteger)\n                    value = MmsValue_newIntegerFromBerInteger(berInteger);\n            }\n            else {\n                if (DEBUG_MMS_CLIENT)\n                    printf(\"MMS CLIENT: error parsing data element (invalid integer size)!\\n\");\n            }\n        }\n        else if (dataElement->present == Data_PR_unsigned) {\n\n            if (dataElement->choice.Unsigned.size > 0) {\n                Asn1PrimitiveValue* berInteger = BerInteger_createFromBuffer(\n                        dataElement->choice.Unsigned.buf, dataElement->choice.Unsigned.size);\n\n                if (berInteger)\n                    value = MmsValue_newUnsignedFromBerInteger(berInteger);\n            }\n            else {\n                if (DEBUG_MMS_CLIENT)\n                    printf(\"MMS CLIENT: error parsing data element (invalid unsigned size)!\\n\");\n            }\n        }\n        else if (dataElement->present == Data_PR_visiblestring) {\n\n            if (dataElement->choice.visiblestring.size >= 0) {\n                value = MmsValue_newVisibleStringFromByteArray(dataElement->choice.visiblestring.buf,\n                        dataElement->choice.visiblestring.size);\n            }\n        }\n        else if (dataElement->present == Data_PR_mMSString) {\n\n            if ( dataElement->choice.mMSString.size >= 0) {\n                value = MmsValue_newMmsStringFromByteArray(dataElement->choice.mMSString.buf,\n                        dataElement->choice.mMSString.size);\n            }\n        }\n        else if (dataElement->present == Data_PR_bitstring) {\n\n            int size = dataElement->choice.bitstring.size;\n\n            if (size >= 0) {\n\n                int maxSize = (size * 8);\n                int bitSize = maxSize - dataElement->choice.bitstring.bits_unused;\n\n                if ((bitSize > 0) && (maxSize >= bitSize)) {\n                    value = (MmsValue*) GLOBAL_CALLOC(1, sizeof(MmsValue));\n\n                    if (value) {\n\n                        value->type = MMS_BIT_STRING;\n\n                        value->value.bitString.size = bitSize;\n\n                        value->value.bitString.buf = (uint8_t*) GLOBAL_MALLOC(size);\n\n                        if (value->value.bitString.buf) {\n                            memcpy(value->value.bitString.buf,\n                                dataElement->choice.bitstring.buf, size);\n                        }\n                        else {\n                            GLOBAL_FREEMEM(value);\n                            value = 0;\n                        }\n                    }\n                }\n                else if (bitSize == 0) {\n                    value = (MmsValue*) GLOBAL_CALLOC(1, sizeof(MmsValue));\n\n                    if (value) {\n                        value->type = MMS_BIT_STRING;\n                        value->value.bitString.size = 0;\n                        value->value.bitString.buf = NULL;\n                    }\n                }\n                else {\n                    if (DEBUG_MMS_CLIENT)\n                        printf(\"MMS CLIENT: error parsing data element (bit string padding problem)!\\n\");\n                }\n            }\n            else {\n                if (DEBUG_MMS_CLIENT)\n                    printf(\"MMS CLIENT: error parsing data element (bit string size 0 or negative)!\\n\");\n            }\n        }\n        else if (dataElement->present == Data_PR_floatingpoint) {\n\n            int size = dataElement->choice.floatingpoint.size;\n\n            if (size == 5) { /* FLOAT32 */\n\n                value = (MmsValue*) GLOBAL_CALLOC(1, sizeof(MmsValue));\n\n                if (value) {\n                    value->type = MMS_FLOAT;\n\n                    value->value.floatingPoint.formatWidth = 32;\n                    value->value.floatingPoint.exponentWidth = dataElement->choice.floatingpoint.buf[0];\n\n                    uint8_t* floatBuf = (dataElement->choice.floatingpoint.buf + 1);\n\n#if (ORDER_LITTLE_ENDIAN == 1)\n                    memcpyReverseByteOrder(value->value.floatingPoint.buf, floatBuf, 4);\n#else\n                    memcpy(value->value.floatingPoint.buf, floatBuf, 4);\n#endif\n                }\n            }\n\n            if (size == 9) { /* FLOAT64 */\n\n                value = (MmsValue*) GLOBAL_CALLOC(1, sizeof(MmsValue));\n\n                if (value) {\n                    value->type = MMS_FLOAT;\n\n                    value->value.floatingPoint.formatWidth = 64;\n                    value->value.floatingPoint.exponentWidth = dataElement->choice.floatingpoint.buf[0];\n\n                    uint8_t* floatBuf = (dataElement->choice.floatingpoint.buf + 1);\n\n#if (ORDER_LITTLE_ENDIAN == 1)\n                    memcpyReverseByteOrder(value->value.floatingPoint.buf, floatBuf, 8);\n#else\n                    memcpy(value->value.floatingPoint.buf, floatBuf, 8);\n#endif\n                }\n            }\n        }\n        else if (dataElement->present == Data_PR_utctime) {\n\n            int size = dataElement->choice.utctime.size;\n\n            if (size == 8) {\n                value = (MmsValue*) GLOBAL_CALLOC(1, sizeof(MmsValue));\n\n                if (value) {\n                    value->type = MMS_UTC_TIME;\n                    memcpy(value->value.utcTime, dataElement->choice.utctime.buf, 8);\n                }\n            }\n            else {\n                if (DEBUG_MMS_CLIENT)\n                    printf(\"MMS CLIENT: error parsing UTC time (size is %i instead of 8\\n\", size);\n            }\n        }\n        else if (dataElement->present == Data_PR_octetstring) {\n\n            if (dataElement->choice.octetstring.size >= 0) {\n                value = (MmsValue*) GLOBAL_CALLOC(1, sizeof(MmsValue));\n\n                if (value) {\n                    value->type = MMS_OCTET_STRING;\n                    int size = dataElement->choice.octetstring.size;\n\n                    value->value.octetString.size = size;\n\n                    if (size > 0)\n                        value->value.octetString.maxSize = -size;\n                    else\n                        value->value.octetString.maxSize = -8;\n\n                    value->value.octetString.buf = (uint8_t*) GLOBAL_MALLOC(abs(value->value.octetString.maxSize));\n\n                    if (value->value.octetString.buf) {\n                        memcpy(value->value.octetString.buf, dataElement->choice.octetstring.buf, size);\n                    }\n                    else {\n                        GLOBAL_FREEMEM(value);\n                        value = NULL;\n                    }\n                }\n            }\n\n        }\n        else if (dataElement->present == Data_PR_binarytime) {\n            int size = dataElement->choice.binarytime.size;\n\n            if ((size == 4) || (size == 6)) {\n                value = (MmsValue*) GLOBAL_CALLOC(1, sizeof(MmsValue));\n\n                if (value) {\n                    value->type = MMS_BINARY_TIME;\n                    value->value.binaryTime.size = size;\n                    memcpy(value->value.binaryTime.buf, dataElement->choice.binarytime.buf, size);\n                }\n            }\n            else {\n                if (DEBUG_MMS_CLIENT)\n                    printf(\"MMS CLIENT: error parsing binary time (size must be 4 or 6, is %i\\n\", size);\n            }\n        }\n        else if (dataElement->present == Data_PR_boolean) {\n            value = MmsValue_newBoolean(dataElement->choice.boolean);\n        }\n        else if (dataElement->present == Data_PR_booleanArray) {\n\n        }\n\n    }\n\n    if (DEBUG_MMS_CLIENT) {\n        if (value == NULL)\n            printf(\"MMS CLIENT: error parsing data element\\n\");\n    }\n\n    return value;\n}\n\nchar*\nmmsMsg_createStringFromAsnIdentifier(Identifier_t identifier)\n{\n    char* str = StringUtils_createStringFromBuffer(identifier.buf, identifier.size);\n\n    return str;\n}\n\n\nvoid\nmmsMsg_copyAsn1IdentifierToStringBuffer(Identifier_t identifier, char* buffer, int bufSize)\n{\n    if (identifier.size < bufSize) {\n        memcpy(buffer, identifier.buf, identifier.size);\n        buffer[identifier.size] = 0;\n    }\n    else {\n\n        if (DEBUG_MMS_SERVER || DEBUG_MMS_CLIENT)\n            printf(\"MMS_COMMON: mms_common_msg.c: ASN1 identifier to long!\\n\");\n\n        buffer[0] = 0;\n    }\n}\n\nchar*\nmmsMsg_getComponentNameFromAlternateAccess(AlternateAccess_t* alternateAccess, char* componentNameBuf, int nameBufPos)\n{\n    if (alternateAccess->list.count == 1) {\n\n        if (alternateAccess->list.array[0]->present == AlternateAccess__Member_PR_unnamed) {\n\n            if (alternateAccess->list.array[0]->choice.unnamed->present == AlternateAccessSelection_PR_selectAlternateAccess) {\n\n                if (alternateAccess->list.array[0]->choice.unnamed->choice.selectAlternateAccess.accessSelection.present ==\n                                AlternateAccessSelection__selectAlternateAccess__accessSelection_PR_component)\n                {\n                    Identifier_t componentIdentifier = alternateAccess->list.array[0]->choice.unnamed->\n                            choice.selectAlternateAccess.accessSelection.choice.component;\n\n                    AlternateAccess_t* nextAlternateAccess = alternateAccess->list.array[0]->choice.unnamed->\n                            choice.selectAlternateAccess.alternateAccess;\n\n                    if (nextAlternateAccess) {\n                        if (nameBufPos + componentIdentifier.size + 1 < 65) {\n                            memcpy(componentNameBuf + nameBufPos, componentIdentifier.buf, componentIdentifier.size);\n                            nameBufPos += componentIdentifier.size;\n                            componentNameBuf[nameBufPos++] = '$';\n                            return mmsMsg_getComponentNameFromAlternateAccess(nextAlternateAccess, componentNameBuf, nameBufPos);\n                        }\n                        else {\n                            if (DEBUG_MMS_SERVER)\n                                printf(\"MMS_SERVER: component identifier name too long!\\n\");\n                        }\n                    }\n                    else {\n                        if (DEBUG_MMS_SERVER)\n                            printf(\"MMS_SERVER: next alternate access specification is missing!\\n\");\n                    }\n                }\n            }\n            else if (alternateAccess->list.array[0]->choice.unnamed->present == AlternateAccessSelection_PR_selectAccess) {\n\n                /* final component part */\n\n                if (alternateAccess->list.array[0]->choice.unnamed->choice.selectAccess.present ==\n                        AlternateAccessSelection__selectAccess_PR_component)\n                {\n                    Identifier_t componentIdentifier = alternateAccess->list.array[0]->choice.unnamed->\n                            choice.selectAccess.choice.component;\n\n                    if (nameBufPos + componentIdentifier.size + 1 < 65) {\n                        memcpy(componentNameBuf + nameBufPos, componentIdentifier.buf, componentIdentifier.size);\n                        nameBufPos += componentIdentifier.size;\n                        componentNameBuf[nameBufPos++] = 0;\n                        return componentNameBuf;\n                    }\n                    else {\n                        if (DEBUG_MMS_SERVER)\n                            printf(\"MMS_SERVER: component identifier name too long!\\n\");\n                    }\n                }\n            }\n\n        }\n\n    }\n\n    if (DEBUG_MMS_SERVER)\n        printf(\"MMS_SERVER: invalid component access specification\\n\");\n\n    return NULL;\n}\n\n#if (MMS_FILE_SERVICE == 1)\n\nvoid\nmmsMsg_createExtendedFilename(const char* basepath, int bufSize, char* extendedFileName, char* fileName)\n{\n#if (CONFIG_SET_FILESTORE_BASEPATH_AT_RUNTIME == 1)\n    StringUtils_concatString(extendedFileName, bufSize, basepath, fileName);\n#else\n    StringUtils_concatString(extendedFileName, bufSize, CONFIG_VIRTUAL_FILESTORE_BASEPATH, fileName);\n#endif\n}\n\nFileHandle\nmmsMsg_openFile(const char* basepath, char* fileName, bool readWrite)\n{\n#if (CONFIG_SET_FILESTORE_BASEPATH_AT_RUNTIME == 1)\n    char extendedFileName[512];\n#else\n    char extendedFileName[sizeof(CONFIG_VIRTUAL_FILESTORE_BASEPATH) + 256];\n#endif\n\n    mmsMsg_createExtendedFilename(basepath, 512, extendedFileName, fileName);\n\n    return FileSystem_openFile(extendedFileName, readWrite);\n}\n\nbool\nmmsMsg_parseFileName(char* filename, uint8_t* buffer, int* bufPos, int maxBufPos , uint32_t invokeId, ByteBuffer* response)\n{\n    if (*bufPos == maxBufPos)\n        return false;\n\n    uint8_t tag = buffer[(*bufPos)++];\n\n    if (tag != 0x19) {\n      mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n      return false;\n    }\n\n    int length;\n\n    *bufPos = BerDecoder_decodeLength(buffer, &length, *bufPos, maxBufPos);\n\n    if (*bufPos < 0)  {\n      mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n      return false;\n    }\n\n    if (length > 255) {\n      mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_REQUEST_INVALID_ARGUMENT, response);\n      return false;\n    }\n\n    memcpy(filename, buffer + *bufPos, length);\n    filename[length] = 0;\n    *bufPos += length;\n\n    /* Check if path contains invalid characters (prevent escaping the virtual filestore by using \"..\")\n     * TODO this may be platform dependent. Also depending of the platform there might be other evil\n     * characters.\n     */\n    if (strstr(filename, \"..\") != NULL) {\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILENAME_SYNTAX_ERROR);\n        return false;\n    }\n\n    return true;\n}\n\n#endif /* (MMS_FILE_SERVICE == 1) */\n\n", "/*\n *  mms_file_service.c\n *\n *  Copyright 2013-2018 Michael Zillgith\n *\n *  This file is part of libIEC61850.\n *\n *  libIEC61850 is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  libIEC61850 is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with libIEC61850.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  See COPYING file for the complete license text.\n */\n\n#include \"libiec61850_platform_includes.h\"\n#include \"mms_server_internal.h\"\n#include \"mms_client_internal.h\"\n\n#if (MMS_FILE_SERVICE == 1)\n\n#include \"hal_filesystem.h\"\n#include \"conversions.h\"\n\n#define CONFIG_MMS_FILE_SERVICE_MAX_FILENAME_LENGTH 256\n\nstatic void\ncreateNullResponseExtendedTag(uint32_t invokeId, ByteBuffer* response, uint8_t tag)\n{\n    uint32_t invokeIdSize = BerEncoder_UInt32determineEncodedSize(invokeId) + 2;\n\n    uint32_t confirmedResponsePDUSize = invokeIdSize + 3 ;\n\n    uint8_t* buffer = response->buffer;\n\n    int bufPos = 0;\n\n    bufPos = BerEncoder_encodeTL(0xa1, confirmedResponsePDUSize, buffer, bufPos);\n\n    bufPos = BerEncoder_encodeTL(0x02, invokeIdSize - 2, buffer, bufPos);\n    bufPos = BerEncoder_encodeUInt32(invokeId, buffer, bufPos);\n\n    buffer[bufPos++] = 0x9f; /* Context specific / primitive / extended */\n    bufPos = BerEncoder_encodeTL(tag, 0, buffer, bufPos);\n\n    response->size = bufPos;\n}\n\nstatic MmsFileReadStateMachine*\ngetFreeFrsm(MmsServerConnection connection)\n{\n    int i;\n\n    MmsFileReadStateMachine* freeFrsm = NULL;\n\n    for (i = 0; i < CONFIG_MMS_MAX_NUMBER_OF_OPEN_FILES_PER_CONNECTION; i++) {\n        if (connection->frsms[i].fileHandle == NULL) {\n            freeFrsm = &(connection->frsms[i]);\n            break;\n        }\n    }\n\n    return freeFrsm;\n}\n\nstatic MmsFileReadStateMachine*\ngetFrsm(MmsServerConnection connection, int32_t frsmId)\n{\n    int i;\n\n    MmsFileReadStateMachine* frsm = NULL;\n\n    for (i = 0; i < CONFIG_MMS_MAX_NUMBER_OF_OPEN_FILES_PER_CONNECTION; i++) {\n        if (connection->frsms[i].fileHandle != NULL) {\n            if (connection->frsms[i].frsmId == frsmId) {\n                frsm = &(connection->frsms[i]);\n                break;\n            }\n        }\n    }\n\n    return frsm;\n}\n\nstatic int32_t\ngetNextFrsmId(MmsServerConnection connection)\n{\n    uint32_t nextFrsmId = connection->nextFrsmId;\n    connection->nextFrsmId++;\n\n    return nextFrsmId;\n}\n\nstatic int\nencodeFileAttributes(uint8_t tag, uint32_t fileSize, char* gtString, uint8_t* buffer, int bufPos)\n{\n    uint32_t sizeOfFileSize = BerEncoder_UInt32determineEncodedSize(fileSize);\n\n    uint32_t gtStringSize = strlen(gtString);\n\n    uint32_t fileAttributesSize = 1 + BerEncoder_determineLengthSize(sizeOfFileSize) + sizeOfFileSize\n            + 2 + gtStringSize;\n\n    if (buffer == NULL) {\n        return fileAttributesSize;\n    }\n    else {\n        bufPos = BerEncoder_encodeTL(tag, fileAttributesSize, buffer, bufPos); /* file attributes */\n        bufPos = BerEncoder_encodeTL(0x80, sizeOfFileSize, buffer, bufPos); /* file size */\n        bufPos = BerEncoder_encodeUInt32(fileSize, buffer, bufPos);\n        bufPos = BerEncoder_encodeOctetString(0x81, (uint8_t*) gtString, gtStringSize, buffer, bufPos);\n        return bufPos;\n    }\n}\n\nstatic bool\ngetFileInfo(const char* basepath, char* filename, uint32_t* fileSize, uint64_t* lastModificationTimestamp)\n{\n#if (CONFIG_SET_FILESTORE_BASEPATH_AT_RUNTIME == 1)\n    char extendedFileName[512];\n    mmsMsg_createExtendedFilename(basepath, 512, extendedFileName, filename);\n#else\n    char extendedFileName[sizeof(CONFIG_VIRTUAL_FILESTORE_BASEPATH) + 256];\n    mmsMsg_createExtendedFilename(basepath, sizeof(CONFIG_VIRTUAL_FILESTORE_BASEPATH) + 256, extendedFileName, filename);\n#endif\n\n    return FileSystem_getFileInfo(extendedFileName, fileSize, lastModificationTimestamp);\n}\n\nstatic FileHandle\nopenFile(const char* basepath, char* fileName, bool readWrite)\n{\n#if (CONFIG_SET_FILESTORE_BASEPATH_AT_RUNTIME == 1)\n    char extendedFileName[512];\n    mmsMsg_createExtendedFilename(basepath, 512, extendedFileName, fileName);\n#else\n    char extendedFileName[sizeof(CONFIG_VIRTUAL_FILESTORE_BASEPATH) + 256];\n    mmsMsg_createExtendedFilename(basepath, sizeof(CONFIG_VIRTUAL_FILESTORE_BASEPATH) + 256, extendedFileName, fileName);\n#endif\n\n    return FileSystem_openFile(extendedFileName, readWrite);\n}\n\nstatic DirectoryHandle\nopenDirectory(const char* basepath, char* directoryName)\n{\n#if (CONFIG_SET_FILESTORE_BASEPATH_AT_RUNTIME == 1)\n    char extendedFileName[512];\n    mmsMsg_createExtendedFilename(basepath, 512, extendedFileName, directoryName);\n#else\n    char extendedFileName[sizeof(CONFIG_VIRTUAL_FILESTORE_BASEPATH) + 256];\n    mmsMsg_createExtendedFilename(basepath, sizeof(CONFIG_VIRTUAL_FILESTORE_BASEPATH) + 256, extendedFileName, directoryName);\n#endif\n\n    return FileSystem_openDirectory(extendedFileName);\n}\n\nstatic bool\nrenameFile(const char* basepath, char* oldFilename, char* newFilename) {\n\n#if (CONFIG_SET_FILESTORE_BASEPATH_AT_RUNTIME == 1)\n    char extendedOldFileName[512];\n    char extendedNewFileName[512];\n    mmsMsg_createExtendedFilename(basepath, 512, extendedOldFileName, oldFilename);\n    mmsMsg_createExtendedFilename(basepath, 512, extendedNewFileName, newFilename);\n#else\n    char extendedOldFileName[sizeof(CONFIG_VIRTUAL_FILESTORE_BASEPATH) + 256];\n    char extendedNewFileName[sizeof(CONFIG_VIRTUAL_FILESTORE_BASEPATH) + 256];\n    mmsMsg_createExtendedFilename(basepath, sizeof(CONFIG_VIRTUAL_FILESTORE_BASEPATH) + 256, extendedOldFileName, oldFilename);\n    mmsMsg_createExtendedFilename(basepath, sizeof(CONFIG_VIRTUAL_FILESTORE_BASEPATH) + 256, extendedNewFileName, newFilename);\n#endif\n\n    return FileSystem_renameFile(extendedOldFileName, extendedNewFileName);\n}\n\nstatic bool\ndeleteFile(const char* basepath, char* fileName) {\n#if (CONFIG_SET_FILESTORE_BASEPATH_AT_RUNTIME == 1)\n    char extendedFileName[512];\n    mmsMsg_createExtendedFilename(basepath, 512, extendedFileName, fileName);\n#else\n    char extendedFileName[sizeof(CONFIG_VIRTUAL_FILESTORE_BASEPATH) + 256];\n    mmsMsg_createExtendedFilename(basepath, sizeof(CONFIG_VIRTUAL_FILESTORE_BASEPATH) + 256, extendedFileName, fileName);\n#endif\n\n    return FileSystem_deleteFile(extendedFileName);\n}\n\nvoid\nmmsMsg_createFileOpenResponse(const char* basepath, uint32_t invokeId, ByteBuffer* response,\n        char* filename, MmsFileReadStateMachine* frsm)\n{\n    uint64_t msTime;\n\n    getFileInfo(basepath, filename, &(frsm->fileSize), &msTime);\n\n    char gtString[30];\n\n    Conversions_msTimeToGeneralizedTime(msTime, (uint8_t*) gtString);\n\n    uint32_t fileAttributesSize = encodeFileAttributes(0xa1, frsm->fileSize, gtString, NULL, 0) + 2;\n\n    uint32_t invokeIdSize = BerEncoder_UInt32determineEncodedSize(invokeId) + 2;\n\n    uint32_t frsmIdSize = BerEncoder_UInt32determineEncodedSize(frsm->frsmId) + 2;\n\n    uint32_t openFileResponseSize = fileAttributesSize + frsmIdSize;\n\n    uint32_t confirmedResponsePDUSize = invokeIdSize + 2 + BerEncoder_determineLengthSize(openFileResponseSize)\n               + openFileResponseSize;\n\n    uint8_t* buffer = response->buffer;\n\n    int bufPos = 0;\n\n    bufPos = BerEncoder_encodeTL(0xa1, confirmedResponsePDUSize, buffer, bufPos);\n\n    bufPos = BerEncoder_encodeTL(0x02, invokeIdSize - 2, buffer, bufPos);\n    bufPos = BerEncoder_encodeUInt32(invokeId, buffer, bufPos);\n\n    buffer[bufPos++] = 0xbf;\n    bufPos = BerEncoder_encodeTL(0x48, openFileResponseSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeTL(0x80, frsmIdSize - 2, buffer, bufPos);\n    bufPos = BerEncoder_encodeInt32(frsm->frsmId, buffer, bufPos);\n    bufPos = encodeFileAttributes(0xa1, frsm->fileSize, gtString, buffer, bufPos);\n\n    response->size = bufPos;\n}\n\n\n\nvoid\nmmsServer_handleFileDeleteRequest(\n    MmsServerConnection connection,\n    uint8_t* buffer, int bufPos, int maxBufPos,\n    uint32_t invokeId,\n    ByteBuffer* response)\n{\n    if (buffer[bufPos++] != 0x19)\n        goto exit_reject_invalid_pdu;\n\n    int length;\n\n    bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n    if (bufPos == -1)\n        goto exit_reject_invalid_pdu;\n\n    if (length > 255) {\n        mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_REQUEST_INVALID_ARGUMENT, response);\n        return;\n    }\n\n    char filename[256];\n\n    memcpy(filename, buffer + bufPos, length);\n    filename[length] = 0;\n\n    if (DEBUG_MMS_SERVER)\n        printf(\"MMS_SERVER: mms_file_service.c: Delete file (%s)\\n\", filename);\n\n    if (connection->server->fileAccessHandler != NULL) {\n        MmsError access = connection->server->fileAccessHandler(connection->server->fileAccessHandlerParameter,\n                            connection, MMS_FILE_ACCESS_TYPE_DELETE, filename, NULL);\n\n        if (access != MMS_ERROR_NONE) {\n            mmsMsg_createServiceErrorPdu(invokeId, response, access);\n            return;\n        }\n    }\n\n    if (!getFileInfo(MmsServerConnection_getFilesystemBasepath(connection), filename, NULL, NULL)) {\n        if (DEBUG_MMS_SERVER)\n            printf(\"MMS_SERVER: mms_file_service.c:  File (%s) not found\\n\", filename);\n\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n        return;\n    }\n\n    if (!deleteFile(MmsServerConnection_getFilesystemBasepath(connection), filename)) {\n        if (DEBUG_MMS_SERVER)\n            printf(\"MMS_SERVER: mms_file_service.c:  Delete file (%s) failed\\n\", filename);\n\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_ACCESS_DENIED);\n        return;\n    }\n\n    createNullResponseExtendedTag(invokeId, response, 0x4c);\n    return;\n\nexit_reject_invalid_pdu:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n}\n\nvoid\nmmsServer_handleFileOpenRequest(\n    MmsServerConnection connection,\n    uint8_t* buffer, int bufPos, int maxBufPos,\n    uint32_t invokeId,\n    ByteBuffer* response)\n{\n    char filename[256];\n    bool hasFileName = false;\n    uint32_t filePosition = 0;\n\n    while (bufPos < maxBufPos) {\n        uint8_t tag = buffer[bufPos++];\n        int length;\n\n        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n\n        if (bufPos < 0) goto exit_reject_invalid_pdu;\n\n        switch(tag) {\n        case 0xa0: /* filename */\n\n            if (!mmsMsg_parseFileName(filename, buffer, &bufPos, bufPos + length, invokeId, response))\n                return;\n\n            hasFileName = true;\n\n            break;\n\n        case 0x81: /* initial position */\n            filePosition = BerDecoder_decodeUint32(buffer, length, bufPos);\n            bufPos += length;\n            break;\n\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n\n        default: /* unrecognized parameter */\n            bufPos += length;\n            goto exit_reject_invalid_pdu;\n        }\n    }\n\n    if (hasFileName) {\n\n        if (connection->server->fileAccessHandler != NULL) {\n            MmsError access = connection->server->fileAccessHandler(connection->server->fileAccessHandlerParameter,\n                                connection, MMS_FILE_ACCESS_TYPE_OPEN, filename, NULL);\n\n            if (access != MMS_ERROR_NONE) {\n                mmsMsg_createServiceErrorPdu(invokeId, response, access);\n                return;\n            }\n        }\n\n        MmsFileReadStateMachine* frsm = getFreeFrsm(connection);\n\n        if (frsm != NULL) {\n            FileHandle fileHandle = openFile(MmsServerConnection_getFilesystemBasepath(connection), filename, false);\n\n            if (fileHandle != NULL) {\n                frsm->fileHandle = fileHandle;\n                frsm->readPosition = filePosition;\n                frsm->frsmId = getNextFrsmId(connection);\n\n                mmsMsg_createFileOpenResponse(MmsServerConnection_getFilesystemBasepath(connection),\n                        invokeId, response, filename, frsm);\n            }\n            else\n                mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n\n\n        }\n        else\n            mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_RESOURCE_OTHER);\n    }\n    else\n        goto exit_invalid_parameter;\n\n    return;\n\nexit_invalid_parameter:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_REQUEST_INVALID_ARGUMENT, response);\n    return;\n\nexit_reject_invalid_pdu:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n}\n\n#if (MMS_OBTAIN_FILE_SERVICE == 1)\n\n\nstatic void /* Confirmed service error (ServiceError) */\ncreateServiceErrorObtainFileError(uint32_t invokeId, ByteBuffer* response,\n        MmsError errorType, uint32_t value)\n{\n    uint8_t buffer[8];\n\n    int size = BerEncoder_encodeUInt32WithTL(0x80, value, buffer, 0);\n\n    mmsServer_createServiceErrorPduWithServiceSpecificInfo(invokeId, response, errorType,\n            buffer, size);\n}\n\n\nstatic void\ncreateObtainFileResponse(uint32_t invokeId, ByteBuffer* response)\n{\n    createNullResponseExtendedTag(invokeId, response, 0x2e);\n}\n\nvoid\nmmsServer_fileUploadTask(MmsServer self, MmsObtainFileTask task, int taskState)\n{\n    /* call locks in certain order (lock IsoConnection -> reserverTransmitBuffer, task->taskLock) to prevent potential deadlock */\n\n    ByteBuffer* message = NULL;\n\n    if (taskState == MMS_FILE_UPLOAD_STATE_SEND_FILE_READ || \n        taskState == MMS_FILE_UPLOAD_STATE_SEND_FILE_CLOSE ||\n        taskState == MMS_FILE_UPLOAD_STATE_SEND_OBTAIN_FILE_ERROR_SOURCE ||\n        taskState == MMS_FILE_UPLOAD_STATE_SEND_OBTAIN_FILE_ERROR_DESTINATION ||\n        taskState == MMS_FILE_UPLOAD_STATE_SEND_OBTAIN_FILE_RESPONSE) \n    {\n        IsoConnection_lock(task->connection->isoConnection);\n\n        message = MmsServer_reserveTransmitBuffer(self);\n    }\n\n#if (CONFIG_MMS_THREADLESS_STACK != 1)\n    Semaphore_wait(task->taskLock);\n#endif\n\n    if (task->state == taskState) {\n\n        switch (task->state) {\n\n            case MMS_FILE_UPLOAD_STATE_NOT_USED:\n                break;\n\n            case MMS_FILE_UPLOAD_STATE_FILE_OPEN_SENT:\n                {\n                    if (Hal_getTimeInMs() > task->nextTimeout) {\n\n                        if (DEBUG_MMS_SERVER)\n                            printf(\"MMS_SERVER: file open timeout!\\n\");\n\n                        task->state = MMS_FILE_UPLOAD_STATE_SEND_OBTAIN_FILE_ERROR_SOURCE;\n\n                        if(task->fileHandle){\n                            FileSystem_closeFile(task->fileHandle);\n                            task->fileHandle = NULL;\n                        }\n                        deleteFile(MmsServer_getFilesystemBasepath(self), task->destinationFilename);\n                    }\n                }\n                break;\n\n            case MMS_FILE_UPLOAD_STATE_SEND_FILE_READ:\n                {\n                    task->lastRequestInvokeId = MmsServerConnection_getNextRequestInvokeId(task->connection);\n\n                    mmsClient_createFileReadRequest(task->lastRequestInvokeId, message, task->frmsId);\n\n                    task->state = MMS_FILE_UPLOAD_STATE_FILE_READ_SENT;\n                    IsoConnection_sendMessage(task->connection->isoConnection, message);\n\n                    task->nextTimeout = Hal_getTimeInMs() + 2000; /* timeout 2000 ms */\n                }\n\n                break;\n\n            case MMS_FILE_UPLOAD_STATE_FILE_READ_SENT:\n\n                if (Hal_getTimeInMs() > task->nextTimeout) {\n\n                    if (DEBUG_MMS_SERVER)\n                        printf(\"MMS_SERVER: file read timeout!\\n\");\n\n                    task->state = MMS_FILE_UPLOAD_STATE_SEND_OBTAIN_FILE_ERROR_SOURCE;\n\n                    if(task->fileHandle){\n                        FileSystem_closeFile(task->fileHandle);\n                        task->fileHandle = NULL;\n                    }\n                    deleteFile(MmsServer_getFilesystemBasepath(self), task->destinationFilename);\n                }\n\n                break;\n\n            case MMS_FILE_UPLOAD_STATE_SEND_FILE_CLOSE:\n                {\n                    task->lastRequestInvokeId = MmsServerConnection_getNextRequestInvokeId(task->connection);\n\n                    mmsClient_createFileCloseRequest(task->lastRequestInvokeId, message, task->frmsId);\n\n                    task->state = MMS_FILE_UPLOAD_STATE_FILE_CLOSE_SENT;\n\n                    IsoConnection_sendMessage(task->connection->isoConnection, message);\n\n                    task->nextTimeout = Hal_getTimeInMs() + 2000; /* timeout 2000 ms */\n\n                }\n                break;\n\n            case MMS_FILE_UPLOAD_STATE_FILE_CLOSE_SENT:\n\n                if (Hal_getTimeInMs() > task->nextTimeout) {\n\n                    if (DEBUG_MMS_SERVER)\n                        printf(\"MMS_SERVER: file close timeout!\\n\");\n\n                    task->state = MMS_FILE_UPLOAD_STATE_SEND_OBTAIN_FILE_ERROR_SOURCE;\n\n                    FileSystem_closeFile(task->fileHandle);\n                    task->fileHandle = NULL;\n                    deleteFile(MmsServer_getFilesystemBasepath(self), task->destinationFilename);\n                }\n\n                break;\n\n            case MMS_FILE_UPLOAD_STATE_SEND_OBTAIN_FILE_ERROR_SOURCE:\n\n                {\n                    /* send ObtainFileError */\n                    createServiceErrorObtainFileError(task->obtainFileRequestInvokeId, message, MMS_ERROR_FILE_FILE_NON_EXISTENT, 0);\n\n                    IsoConnection_sendMessage(task->connection->isoConnection, message);\n\n                    if(task->fileHandle){\n                        FileSystem_closeFile(task->fileHandle);\n                        task->fileHandle = NULL;\n                    }\n                    \n                    deleteFile(MmsServer_getFilesystemBasepath(self), task->destinationFilename);\n\n                    if (DEBUG_MMS_SERVER)\n                        printf(\"MMS_SERVER: ObtainFile service: failed to open file from client\\n\");\n\n                    task->state = MMS_FILE_UPLOAD_STATE_NOT_USED;\n                }\n                break;\n\n            case MMS_FILE_UPLOAD_STATE_SEND_OBTAIN_FILE_ERROR_DESTINATION:\n                {\n                    /* send ObtainFileError */\n                    createServiceErrorObtainFileError(task->obtainFileRequestInvokeId, message, MMS_ERROR_FILE_OTHER, 1);\n\n                    IsoConnection_sendMessage(task->connection->isoConnection, message);\n\n                    if (task->fileHandle) {\n                        FileSystem_closeFile(task->fileHandle);\n                        task->fileHandle = NULL;\n\n                        if (task->destinationFilename[0])\n                            deleteFile(MmsServer_getFilesystemBasepath(self), task->destinationFilename);\n                    }\n\n                    if (DEBUG_MMS_SERVER)\n                        printf(\"MMS_SERVER: ObtainFile service: failed to create local file\\n\");\n\n                    task->state = MMS_FILE_UPLOAD_STATE_NOT_USED;\n                }\n\n                break;\n\n            case MMS_FILE_UPLOAD_STATE_SEND_OBTAIN_FILE_RESPONSE:\n                {\n                    createObtainFileResponse(task->obtainFileRequestInvokeId, message);\n\n                    task->state = MMS_FILE_UPLOAD_STATE_NOT_USED;\n\n                    IsoConnection_sendMessage(task->connection->isoConnection, message);\n\n                    if (self->getFileCompleteHandler)\n                        self->getFileCompleteHandler(self->getFileCompleteHandlerParameter, task->connection, task->destinationFilename);\n                }\n                break;\n\n            case MMS_FILE_UPLOAD_STATE_INTERRUPTED:\n                {\n                    if (DEBUG_MMS_SERVER)\n                        printf(\"MMS_SERVER: file service interrupted, due to client disconnection\\n\");\n\n                    if (task->fileHandle){\n                        FileSystem_closeFile(task->fileHandle);\n                        task->fileHandle = NULL;\n\n                        if (task->destinationFilename[0])\n                            deleteFile(MmsServer_getFilesystemBasepath(self), task->destinationFilename);\n                    }\n                    task->state = MMS_FILE_UPLOAD_STATE_NOT_USED;\n                }\n                break;\n        }\n    }\n\n#if (CONFIG_MMS_THREADLESS_STACK != 1)\n    Semaphore_post(task->taskLock);\n#endif\n\n    if (message) {\n        MmsServer_releaseTransmitBuffer(self);\n        IsoConnection_unlock(task->connection->isoConnection);\n    }\n}\n\n#if (MMS_OBTAIN_FILE_SERVICE == 1)\n\nvoid\nmmsServerConnection_stopFileUploadTasks(MmsServerConnection self)\n{\n    MmsServer server = self->server;\n\n    int i;\n\n    for (i = 0; i < CONFIG_MMS_SERVER_MAX_GET_FILE_TASKS; i++) {\n\n#if (CONFIG_MMS_THREADLESS_STACK != 1)\n        Semaphore_wait(server->fileUploadTasks[i].taskLock);\n#endif\n\n        if (server->fileUploadTasks[i].state != 0) {\n\n            if (server->fileUploadTasks[i].connection == self) {\n\n                /* stop file upload task */\n                server->fileUploadTasks[i].state = MMS_FILE_UPLOAD_STATE_INTERRUPTED;\n            }\n\n        }\n\n#if (CONFIG_MMS_THREADLESS_STACK != 1)\n        Semaphore_post(server->fileUploadTasks[i].taskLock);\n#endif\n    }\n}\n\n#endif /*(MMS_OBTAIN_FILE_SERVICE == 1) */\nvoid\nmmsServer_handleObtainFileRequest(\n        MmsServerConnection connection,\n        uint8_t* buffer, int bufPos, int maxBufPos,\n        uint32_t invokeId,\n        ByteBuffer* response)\n{\n    char sourceFilename[256];\n    bool hasSourceFileName = false;\n\n    char destinationFilename[256];\n    bool hasDestinationFilename = false;\n\n    while (bufPos < maxBufPos) {\n        uint8_t tag = buffer[bufPos++];\n        int length;\n\n        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n\n        if (bufPos < 0) goto exit_reject_invalid_pdu;\n\n        switch(tag) {\n\n        case 0xa1: /* source filename */\n\n            if (!mmsMsg_parseFileName(sourceFilename, buffer, &bufPos, bufPos + length, invokeId, response))\n                return;\n\n            hasSourceFileName = true;\n\n            break;\n\n        case 0xa2: /* destination filename */\n\n            if (!mmsMsg_parseFileName(destinationFilename, buffer, &bufPos, bufPos + length, invokeId, response))\n                return;\n\n            hasDestinationFilename = true;\n\n            break;\n\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n\n        default: /* unrecognized parameter */\n            bufPos += length;\n            goto exit_reject_invalid_pdu;\n        }\n    }\n\n    if (hasSourceFileName && hasDestinationFilename) {\n\n        /* Call user to check if access is allowed */\n        if (connection->server->fileAccessHandler != NULL) {\n            MmsError access = connection->server->fileAccessHandler(connection->server->fileAccessHandlerParameter,\n                                connection, MMS_FILE_ACCESS_TYPE_OBTAIN, destinationFilename, sourceFilename);\n\n            if (access != MMS_ERROR_NONE) {\n                mmsMsg_createServiceErrorPdu(invokeId, response, access);\n                return;\n            }\n        }\n\n        /* call callback to check if access is allowed -- DEPRECATED */\n        if (connection->server->obtainFileHandler)\n            if (connection->server->obtainFileHandler(connection->server->obtainFileHandlerParameter, connection, sourceFilename, destinationFilename) == false)\n                goto exit_access_denied;\n\n        /*  check if destination file already exists. If exists return error message */\n\n#if (CONFIG_SET_FILESTORE_BASEPATH_AT_RUNTIME == 1)\n        char extendedFileName[512];\n        mmsMsg_createExtendedFilename(MmsServerConnection_getFilesystemBasepath(connection), 512,\n                extendedFileName, destinationFilename);\n\n#else\n        char extendedFileName[sizeof(CONFIG_VIRTUAL_FILESTORE_BASEPATH) + 256];\n\n        mmsMsg_createExtendedFilename(MmsServerConnection_getFilesystemBasepath(connection),\n                sizeof(CONFIG_VIRTUAL_FILESTORE_BASEPATH) + 256,\n                extendedFileName, destinationFilename);\n#endif\n\n        if (FileSystem_getFileInfo(extendedFileName, NULL, NULL)) {\n            if (DEBUG_MMS_SERVER)\n                printf(\"MMS_SERVER: obtainFile - file already exists on server\\n\");\n            goto exit_file_already_exists;\n        }\n\n        if (DEBUG_MMS_SERVER)\n            printf(\"MMS_SERVER: Start download file %s from client to local file %s...\\n\", sourceFilename, destinationFilename);\n\n        MmsObtainFileTask task = MmsServer_getObtainFileTask(connection->server);\n\n        if (task != NULL) {\n\n            FileHandle fileHandle = openFile(MmsServerConnection_getFilesystemBasepath(connection),\n                    destinationFilename, true);\n\n            task->connection = connection;\n            task->obtainFileRequestInvokeId = invokeId;\n\n            if (fileHandle == NULL) {\n                task->state = MMS_FILE_UPLOAD_STATE_SEND_OBTAIN_FILE_ERROR_DESTINATION;\n            }\n            else {\n                /* send file open request */\n                task->lastRequestInvokeId = MmsServerConnection_getNextRequestInvokeId(connection);\n                task->fileHandle = fileHandle;\n\n                StringUtils_copyStringMax(task->destinationFilename, 256, destinationFilename);\n\n                ByteBuffer* request = MmsServer_reserveTransmitBuffer(connection->server);\n\n                mmsClient_createFileOpenRequest(task->lastRequestInvokeId, request, sourceFilename, 0);\n\n                IsoConnection_sendMessage(task->connection->isoConnection, request);\n\n                MmsServer_releaseTransmitBuffer(connection->server);\n\n                task->nextTimeout = Hal_getTimeInMs() + 2000; /* timeout 2000 ms */\n\n                task->state = MMS_FILE_UPLOAD_STATE_FILE_OPEN_SENT;\n            }\n\n#if (CONFIG_MMS_THREADLESS_STACK != 1)\n            Semaphore_post(task->taskLock);\n#endif\n        }\n        else\n            goto exit_unavailable;\n    }\n    else\n        goto exit_invalid_parameter;\n\n    return;\n\nexit_invalid_parameter:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_REQUEST_INVALID_ARGUMENT, response);\n    return;\n\nexit_access_denied:\n    createServiceErrorObtainFileError(invokeId, response, MMS_ERROR_FILE_FILE_ACCESS_DENIED, 1);\n    return;\n\nexit_file_already_exists:\n    createServiceErrorObtainFileError(invokeId, response, MMS_ERROR_FILE_DUPLICATE_FILENAME, 1);\n    return;\n\nexit_unavailable:\n    mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_ACCESS_TEMPORARILY_UNAVAILABLE);\n    return;\n\nexit_reject_invalid_pdu:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n}\n\n#endif /* (MMS_OBTAIN_FILE_SERVICE == 1) */\n\nvoid\nmmsMsg_createFileReadResponse(int maxPduSize, uint32_t invokeId,\n        ByteBuffer* response,  MmsFileReadStateMachine* frsm)\n{\n     /* determine remaining bytes in file */\n     uint32_t bytesLeft = frsm->fileSize - frsm->readPosition;\n\n     uint32_t fileChunkSize = 0;\n\n     uint32_t maxFileChunkSize = maxPduSize - 20;\n\n     uint32_t fileReadResponseSize = 1; /* for tag */\n\n     bool moreFollows = true;\n\n     if (bytesLeft > maxFileChunkSize) {\n         fileChunkSize = maxFileChunkSize;\n     }\n     else {\n         fileChunkSize = bytesLeft;\n         moreFollows = false;\n         fileReadResponseSize += 3; /* for moreFollows */\n     }\n\n     fileReadResponseSize += fileChunkSize;\n     fileReadResponseSize += BerEncoder_determineLengthSize(fileChunkSize);\n\n     frsm->readPosition += fileChunkSize;\n\n     uint32_t invokeIdSize = BerEncoder_UInt32determineEncodedSize(invokeId) + 2;\n\n     uint32_t confirmedResponsePDUSize = invokeIdSize + 2 + BerEncoder_determineLengthSize(fileReadResponseSize)\n                + fileReadResponseSize;\n\n     uint8_t* buffer = response->buffer;\n\n     int bufPos = 0;\n\n     bufPos = BerEncoder_encodeTL(0xa1, confirmedResponsePDUSize, buffer, bufPos);\n\n     bufPos = BerEncoder_encodeTL(0x02, invokeIdSize - 2, buffer, bufPos);\n     bufPos = BerEncoder_encodeUInt32(invokeId, buffer, bufPos);\n\n     buffer[bufPos++] = 0xbf;\n     bufPos = BerEncoder_encodeTL(0x49, fileReadResponseSize, buffer, bufPos);\n\n     bufPos = BerEncoder_encodeTL(0x80, fileChunkSize, buffer, bufPos);\n     FileSystem_readFile(frsm->fileHandle, buffer + bufPos, fileChunkSize);\n     bufPos += fileChunkSize;\n\n     if (!moreFollows)\n         bufPos = BerEncoder_encodeBoolean(0x81, false, buffer, bufPos);\n\n     response->size = bufPos;\n}\n\nvoid\nmmsServer_handleFileReadRequest(\n    MmsServerConnection connection,\n    uint8_t* buffer, int bufPos, int maxBufPos,\n    uint32_t invokeId,\n    ByteBuffer* response)\n{\n    int32_t frsmId = BerDecoder_decodeInt32(buffer, maxBufPos - bufPos, bufPos);\n\n    if (DEBUG_MMS_SERVER)\n        printf(\"MMS_SERVER: mmsServer_handleFileReadRequest read request for frsmId: %i\\n\", frsmId);\n\n    MmsFileReadStateMachine* frsm = getFrsm(connection, frsmId);\n\n    if (frsm != NULL)\n        mmsMsg_createFileReadResponse(connection->maxPduSize, invokeId, response, frsm);\n    else\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_OTHER);\n}\n\nvoid\nmmsMsg_createFileCloseResponse(uint32_t invokeId, ByteBuffer* response)\n{\n    createNullResponseExtendedTag(invokeId, response, 0x4a);\n}\n\nvoid\nmmsServer_handleFileCloseRequest(\n    MmsServerConnection connection,\n    uint8_t* buffer, int bufPos, int maxBufPos,\n    uint32_t invokeId,\n    ByteBuffer* response)\n{\n    int32_t frsmId = BerDecoder_decodeInt32(buffer, maxBufPos - bufPos, bufPos);\n\n    MmsFileReadStateMachine* frsm = getFrsm(connection, frsmId);\n\n    if (frsm) {\n        FileSystem_closeFile(frsm->fileHandle);\n        frsm->fileHandle = NULL;\n        frsm->frsmId = 0;\n\n        mmsMsg_createFileCloseResponse(invokeId, response);\n    }\n    else {\n        if (DEBUG_MMS_SERVER)\n            printf(\"MMS_SERVER: Unused file ID %i\\n\", frsmId);\n\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_OTHER);\n    }\n}\n\n\n\nstatic int /* TODO remove redundancy - same as in client code! */\nencodeFileSpecification(uint8_t tag, char* fileSpecification, uint8_t* buffer, int bufPos)\n{\n    uint32_t fileNameStringSize = strlen(fileSpecification);\n    uint32_t fileNameSeqSize = 1 + BerEncoder_determineLengthSize(fileNameStringSize) + fileNameStringSize;\n\n    if (buffer != NULL) {\n\n        bufPos = BerEncoder_encodeTL(tag, fileNameSeqSize, buffer, bufPos);\n        bufPos = BerEncoder_encodeOctetString(0x19, (uint8_t*) fileSpecification, fileNameStringSize, buffer, bufPos);\n\n        return bufPos;\n    }\n    else {\n        return fileNameSeqSize + 1 + BerEncoder_determineLengthSize(fileNameSeqSize);\n    }\n}\n\nstatic int\naddFileEntriesToResponse(const char* basepath, uint8_t* buffer, int bufPos, int maxBufSize, char* directoryName, char** continueAfterFileName, bool* moreFollows)\n{\n\tint directoryNameLength = strlen(directoryName);\n\n    DirectoryHandle directory = openDirectory(basepath, directoryName);\n\n    if (directory != NULL) {\n\n        bool isDirectory;\n        char* fileName = FileSystem_readDirectory(directory, &isDirectory);\n\n        while (fileName != NULL) {\n        \tdirectoryName[directoryNameLength] = 0;\n\n        \tif (directoryNameLength > 0) {\n        \t\tif (directoryName[directoryNameLength - 1] != '/')\n        \t\t    StringUtils_appendString(directoryName, 256, \"/\");\n        \t}\n\n        \tStringUtils_appendString(directoryName, 256, fileName);\n\n            bufPos = addFileEntriesToResponse(basepath, buffer, bufPos, maxBufSize, directoryName, continueAfterFileName, moreFollows);\n\n            if (*moreFollows == true)\n                break;\n\n            fileName = FileSystem_readDirectory(directory, &isDirectory);\n        }\n\n        FileSystem_closeDirectory(directory);\n    }\n    else {\n\n        if (*continueAfterFileName != NULL) {\n            if (strcmp(*continueAfterFileName, directoryName) == 0) {\n                *continueAfterFileName = NULL;\n            }\n        }\n        else {\n            uint64_t msTime;\n\n            uint32_t fileSize;\n\n            if (getFileInfo(basepath, directoryName, &fileSize, &msTime)) {\n                char gtString[30];\n\n                Conversions_msTimeToGeneralizedTime(msTime, (uint8_t*) gtString);\n\n                int fileAttributesSize = encodeFileAttributes(0xa1, fileSize, gtString, NULL, 0);\n\n                int filenameSize = encodeFileSpecification(0xa0, directoryName, NULL, 0);\n\n                int dirEntrySize = 2 + fileAttributesSize + filenameSize;\n\n                int overallEntrySize = 1 + BerEncoder_determineLengthSize(dirEntrySize) + dirEntrySize;\n\n                int bufferSpaceLeft = maxBufSize - bufPos;\n\n                if (overallEntrySize > bufferSpaceLeft) {\n                    *moreFollows = true;\n                }\n                else {\n\n                    bufPos = BerEncoder_encodeTL(0x30, dirEntrySize, buffer, bufPos); /* SEQUENCE (DirectoryEntry) */\n                    bufPos = encodeFileSpecification(0xa0, directoryName, buffer, bufPos); /* fileName */\n                    bufPos = encodeFileAttributes(0xa1, fileSize, gtString, buffer, bufPos); /* file attributes */\n                }\n            }\n            else\n                bufPos = -1;\n\n        }\n\n    }\n\n    directoryName[directoryNameLength] = 0;\n\n    return bufPos;\n}\n\nstatic void\ncreateFileDirectoryResponse(const char* basepath, uint32_t invokeId, ByteBuffer* response, int maxPduSize, char* directoryName, char* continueAfterFileName)\n{\n    int maxSize = maxPduSize - 3; /* reserve space for moreFollows */\n    uint8_t* buffer = response->buffer;\n\n    bool moreFollows = false;\n\n    int tempStartPos = 30; /* estimated header part with safety margin */\n    int tempCurPos = tempStartPos;\n    int tempEncoded = 0;\n\n    if (continueAfterFileName != NULL) {\n        if (strlen(continueAfterFileName) == 0)\n            continueAfterFileName = NULL;\n    }\n\n    tempCurPos = addFileEntriesToResponse(basepath, buffer, tempCurPos, maxSize, directoryName, &continueAfterFileName, &moreFollows);\n\n\tif (tempCurPos < 0) {\n\n       if (DEBUG_MMS_SERVER)\n            printf(\"MMS_SERVER: Error opening directory!\\n\");\n\n       mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n\n       return;\n    }\n\n    tempEncoded = tempCurPos - tempStartPos;\n\n    uint32_t invokeIdSize = BerEncoder_UInt32determineEncodedSize((uint32_t) invokeId) + 2;\n\n    uint32_t listOfDirectoryEntrySeqSize = tempEncoded;\n\n    uint32_t listOfDirectoryEntrySize = 1 + BerEncoder_determineLengthSize(tempEncoded) + tempEncoded;\n\n    uint32_t fileDirectoryResponseSize = 1 + BerEncoder_determineLengthSize(listOfDirectoryEntrySize)\n            + listOfDirectoryEntrySize;\n\n    if (moreFollows)\n        fileDirectoryResponseSize += 3; /* for moreFollows */\n\n    uint32_t confirmedResponsePDUSize = invokeIdSize + 2 + BerEncoder_determineLengthSize(fileDirectoryResponseSize)\n            + fileDirectoryResponseSize;\n\n    int bufPos = 0;\n\n    bufPos = BerEncoder_encodeTL(0xa1, confirmedResponsePDUSize, buffer, bufPos);\n\n    bufPos = BerEncoder_encodeTL(0x02, invokeIdSize - 2, buffer, bufPos);\n    bufPos = BerEncoder_encodeUInt32(invokeId, buffer, bufPos);\n\n    buffer[bufPos++] = 0xbf;\n    bufPos = BerEncoder_encodeTL(0x4d, fileDirectoryResponseSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeTL(0xa0, listOfDirectoryEntrySize, buffer, bufPos);\n\n    bufPos = BerEncoder_encodeTL(0x30, listOfDirectoryEntrySeqSize, buffer, bufPos); /* SEQUENCE OF (DirectoryEntry) */\n\n    /* memmove is required instead of memcpy since memory areas overlap */\n    memmove(buffer + bufPos, buffer + tempStartPos, tempEncoded);\n\n    bufPos += tempEncoded;\n\n    if (moreFollows)\n        bufPos = BerEncoder_encodeBoolean(0x81, moreFollows, buffer, bufPos);\n\n    response->size = bufPos;\n}\n\nvoid\nmmsServer_handleFileRenameRequest(\n        MmsServerConnection connection,\n        uint8_t* buffer, int bufPos, int maxBufPos,\n        uint32_t invokeId,\n        ByteBuffer* response)\n{\n    char currentFileName[256] = \"\";\n    char newFileName[256] = \"\";\n\n    while (bufPos < maxBufPos) {\n        uint8_t tag = buffer[bufPos++];\n        int length;\n\n        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n\n        if (bufPos < 0) {\n            mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n            return;\n        }\n\n        switch(tag) {\n        case 0xa0: /* currentFilename */\n            if (!mmsMsg_parseFileName(currentFileName, buffer, &bufPos, bufPos + length, invokeId, response))\n                return;\n\n            if (DEBUG_MMS_SERVER)\n                printf(\"MMS_SERVER: currentFileName: (%s)\\n\", currentFileName);\n\n            break;\n\n        case 0xa1: /* newFilename */\n            if (!mmsMsg_parseFileName(newFileName, buffer, &bufPos, bufPos + length, invokeId, response))\n                return;\n\n            if (DEBUG_MMS_SERVER)\n                printf(\"MMS_SERVER: newFileName: (%s)\\n\", newFileName);\n\n            break;\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n        default: /* ignore unknown tag */\n            if (DEBUG_MMS_SERVER)\n                printf(\"MMS_SERVER: unknown tag: (%02x)\\n\", tag);\n\n            bufPos += length;\n            break;\n        }\n    }\n\n    if ((strlen(currentFileName) != 0) && (strlen(newFileName) != 0)) {\n\n        /* Call user to check if access is allowed */\n        if (connection->server->fileAccessHandler != NULL) {\n            MmsError access = connection->server->fileAccessHandler(connection->server->fileAccessHandlerParameter,\n                                connection, MMS_FILE_ACCESS_TYPE_RENAME, currentFileName, newFileName);\n\n            if (access != MMS_ERROR_NONE) {\n                mmsMsg_createServiceErrorPdu(invokeId, response, access);\n                return;\n            }\n        }\n\n        if (renameFile(MmsServerConnection_getFilesystemBasepath(connection), currentFileName, newFileName)){\n            /* send positive response */\n            createNullResponseExtendedTag(invokeId, response, 0x4b);\n        }\n        else\n        {\n            if (DEBUG_MMS_SERVER)\n                printf(\"MMS_SERVER: rename file failed!\\n\");\n\n            mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_OTHER);\n        }\n    }\n    else\n        mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n\n}\n\nvoid\nmmsServer_handleFileDirectoryRequest(\n    MmsServerConnection connection,\n    uint8_t* buffer, int bufPos, int maxBufPos,\n    uint32_t invokeId,\n    ByteBuffer* response)\n{\n    if (DEBUG_MMS_SERVER)\n        printf(\"MMS_SERVER: handleFileDirectoryRequest bufPos:%i, maxBufPus:%i\\n\", bufPos, maxBufPos);\n\n    char filename[256] = \"\";\n\n    char continueAfterFileName[256];\n\n    char* continueAfter = NULL;\n\n    while (bufPos < maxBufPos) {\n        uint8_t tag = buffer[bufPos++];\n        int length;\n\n        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n\n        if (bufPos < 0) {\n            mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n            return;\n        }\n\n        switch(tag) {\n        case 0xa0: /* filename */\n            if (!mmsMsg_parseFileName(filename, buffer, &bufPos, bufPos + length, invokeId, response))\n                return;\n\n            /* check for wildcard character(*) */\n            if ((strcmp(filename, \"*\") == 0) || (strcmp(filename, \"/\") == 0) || (strcmp(filename, \"\\\\\") == 0))\n            \tfilename[0] = 0;\n\n            break;\n\n        case 0xa1: /* continue-after */\n            if (!mmsMsg_parseFileName(continueAfterFileName, buffer, &bufPos, bufPos + length, invokeId, response))\n                return;\n\n            continueAfter = continueAfterFileName;\n\n            break;\n\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n\n        default: /* unrecognized parameter */\n            if (DEBUG_MMS_SERVER)\n                printf(\"MMS_SERVER: handleFileDirectoryRequest: unrecognized parameter\\n\");\n            mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n            return;\n        }\n\n\n    }\n\n    int maxPduSize = connection->maxPduSize;\n\n    /* Call user to check if access is allowed */\n    if (connection->server->fileAccessHandler != NULL) {\n        MmsError access = connection->server->fileAccessHandler(connection->server->fileAccessHandlerParameter,\n                            connection, MMS_FILE_ACCESS_TYPE_READ_DIRECTORY, filename, continueAfter);\n\n        if (access != MMS_ERROR_NONE) {\n            mmsMsg_createServiceErrorPdu(invokeId, response, access);\n            return;\n        }\n    }\n\n    createFileDirectoryResponse(MmsServerConnection_getFilesystemBasepath(connection),\n            invokeId, response, maxPduSize, filename, continueAfter);\n}\n\n#endif /* MMS_FILE_SERVICE == 1 */\n\n"], "fixing_code": ["/*\n *  file_provider_linux.c\n *\n *  Copyright 2014-2018 Michael Zillgith\n *\n *  This file is part of libIEC61850.\n *\n *  libIEC61850 is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  libIEC61850 is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with libIEC61850.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  See COPYING file for the complete license text.\n */\n\n#include <string.h>\n#include <dirent.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#include \"hal_filesystem.h\"\n#include \"lib_memory.h\"\n\nstruct sDirectoryHandle {\n    DIR* handle;\n};\n\nFileHandle\nFileSystem_openFile(char* fileName, bool readWrite)\n{\n    FileHandle newHandle = NULL;\n\n    if (readWrite)\n        newHandle = (FileHandle) fopen(fileName, \"w\");\n    else\n        newHandle = (FileHandle) fopen(fileName, \"r\");\n\n    return newHandle;\n}\n\nint\nFileSystem_readFile(FileHandle handle, uint8_t* buffer, int maxSize)\n{\n    return fread(buffer, maxSize, 1, (FILE*) handle);\n}\n\nint\nFileSystem_writeFile(FileHandle handle, uint8_t* buffer, int size)\n{\n    return fwrite(buffer, size, 1, (FILE*) handle);\n}\n\nvoid\nFileSystem_closeFile(FileHandle handle)\n{\n    fclose((FILE*) handle);\n}\n\nbool\nFileSystem_deleteFile(char* filename)\n{\n    if (remove(filename) == 0)\n        return true;\n    else\n        return false;\n}\n\nbool\nFileSystem_renameFile(char* oldFilename, char* newFilename)\n{\n    if (rename(oldFilename, newFilename) == 0)\n        return true;\n    else\n        return false;\n}\n\n\nbool\nFileSystem_getFileInfo(char* filename, uint32_t* fileSize, uint64_t* lastModificationTimestamp)\n{\n    struct stat fileStats;\n\n    if (stat(filename, &fileStats) == -1)\n        return false;\n\n    if (lastModificationTimestamp != NULL)\n        *lastModificationTimestamp = (uint64_t) (fileStats.st_mtime) * 1000LL;\n        // does not work on older systems --> *lastModificationTimestamp = (uint64_t) (fileStats.st_ctim.tv_sec) * 1000LL;\n\n    if (fileSize != NULL)\n        *fileSize = fileStats.st_size;\n\n    return true;\n}\n\nDirectoryHandle\nFileSystem_openDirectory(char* directoryName)\n{\n    DIR* dirHandle = opendir(directoryName);\n\n    DirectoryHandle handle = NULL;\n\n    if (dirHandle != NULL) {\n        handle = (DirectoryHandle) GLOBAL_MALLOC(sizeof(struct sDirectoryHandle));\n        handle->handle = dirHandle;\n    }\n\n    return handle;\n}\n\nchar*\nFileSystem_readDirectory(DirectoryHandle directory, bool* isDirectory)\n{\n    struct dirent* dir;\n\n    dir = readdir(directory->handle);\n\n    if (dir != NULL) {\n        if (dir->d_name[0] == '.')\n            return FileSystem_readDirectory(directory, isDirectory);\n        else {\n            if (isDirectory != NULL) {\n                if (dir->d_type == DT_DIR)\n                    *isDirectory = true;\n                else\n                    *isDirectory = false;\n            }\n\n            return dir->d_name;\n        }\n    }\n    else\n        return NULL;\n}\n\nvoid\nFileSystem_closeDirectory(DirectoryHandle directory)\n{\n    closedir(directory->handle);\n    GLOBAL_FREEMEM(directory);\n}\n\n", "/*\n *  mms_common_internal.h\n *\n *  Copyright 2013-2019 Michael Zillgith\n *\n *  This file is part of libIEC61850.\n *\n *  libIEC61850 is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  libIEC61850 is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with libIEC61850.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  See COPYING file for the complete license text.\n */\n\n#ifndef MMS_COMMON_INTERNAL_H_\n#define MMS_COMMON_INTERNAL_H_\n\n#include \"mms_value.h\"\n#include \"MmsPdu.h\"\n#include \"conversions.h\"\n#include \"byte_buffer.h\"\n#include \"mms_server.h\"\n\n#define DEFAULT_MAX_SERV_OUTSTANDING_CALLING 5\n#define DEFAULT_MAX_SERV_OUTSTANDING_CALLED 5\n#define DEFAULT_DATA_STRUCTURE_NESTING_LEVEL 10\n\n#if (MMS_FILE_SERVICE == 1)\n\n#ifndef CONFIG_MMS_MAX_NUMBER_OF_OPEN_FILES_PER_CONNECTION\n#define CONFIG_MMS_MAX_NUMBER_OF_OPEN_FILES_PER_CONNECTION 5\n#endif\n\n#include \"hal_filesystem.h\"\n\ntypedef struct sMmsOutstandingCall* MmsOutstandingCall;\n\ntypedef struct {\n        int32_t frsmId;\n        uint32_t readPosition;\n        uint32_t fileSize;\n        FileHandle fileHandle;\n\n#if (MMS_OBTAIN_FILE_SERVICE == 1)\n        MmsOutstandingCall obtainRequest;\n#endif\n} MmsFileReadStateMachine;\n\n/* include for MmsFileReadHandler definition */\n#include \"mms_client_connection.h\"\n\nLIB61850_INTERNAL bool\nmmsMsg_parseFileOpenResponse(uint8_t* buffer, int bufPos, int maxBufPos, int32_t* frsmId, uint32_t* fileSize, uint64_t* lastModified);\n\nLIB61850_INTERNAL bool\nmmsMsg_parseFileReadResponse(uint8_t* buffer, int bufPos, int maxBufPos, uint32_t invokeId, int32_t frsmId,  bool* moreFollows, MmsConnection_FileReadHandler handler, void* handlerParameter);\n\nLIB61850_INTERNAL void\nmmsMsg_createFileReadResponse(int maxPduSize, uint32_t invokeId, ByteBuffer* response,  MmsFileReadStateMachine* frsm);\n\nLIB61850_INTERNAL void\nmmsMsg_createFileCloseResponse(uint32_t invokeId, ByteBuffer* response);\n\nLIB61850_INTERNAL void\nmmsMsg_createFileOpenResponse(const char* basepath, uint32_t invokeId, ByteBuffer* response, char* fullPath, MmsFileReadStateMachine* frsm);\n\nLIB61850_INTERNAL bool\nmmsMsg_parseFileName(char* filename, uint8_t* buffer, int* bufPos, int maxBufPos , uint32_t invokeId, ByteBuffer* response);\n\nLIB61850_INTERNAL void\nmmsMsg_createExtendedFilename(const char* basepath, int bufSize, char* extendedFileName, char* fileName);\n\nLIB61850_INTERNAL FileHandle\nmmsMsg_openFile(const char* basepath, char* fileName, bool readWrite);\n\nLIB61850_INTERNAL bool\nmmsMsg_isFilenameSave(const char* filename);\n\n#endif /* (MMS_FILE_SERVICE == 1) */\n\ntypedef struct sMmsServiceError\n{\n    int errorClass;\n    int errorCode;\n} MmsServiceError;\n\n\nLIB61850_INTERNAL void /* Confirmed service error (ServiceError) */\nmmsMsg_createServiceErrorPdu(uint32_t invokeId, ByteBuffer* response, MmsError errorType);\n\nLIB61850_INTERNAL void\nmmsMsg_createMmsRejectPdu(uint32_t* invokeId, int reason, ByteBuffer* response);\n\nLIB61850_INTERNAL int\nmmsMsg_parseConfirmedErrorPDU(uint8_t* buffer, int bufPos, int maxBufPos, uint32_t* invokeId, bool* hasInvokeId, MmsServiceError* serviceError);\n\nLIB61850_INTERNAL int\nmmsMsg_parseRejectPDU(uint8_t* buffer, int bufPos, int maxBufPos, uint32_t* invokeId, bool* hasInvokeId, int* rejectType, int* rejectReason);\n\nLIB61850_INTERNAL MmsValue*\nmmsMsg_parseDataElement(Data_t* dataElement);\n\nLIB61850_INTERNAL Data_t*\nmmsMsg_createBasicDataElement(MmsValue* value);\n\nLIB61850_INTERNAL AccessResult_t**\nmmsMsg_createAccessResultsList(MmsPdu_t* mmsPdu, int resultsCount);\n\nLIB61850_INTERNAL char*\nmmsMsg_createStringFromAsnIdentifier(Identifier_t identifier);\n\nLIB61850_INTERNAL void\nmmsMsg_copyAsn1IdentifierToStringBuffer(Identifier_t identifier, char* buffer, int bufSize);\n\nLIB61850_INTERNAL char*\nmmsMsg_getComponentNameFromAlternateAccess(AlternateAccess_t* alternateAccess, char* componentNameBuf, int nameBufPos);\n\nLIB61850_INTERNAL void\nmmsMsg_deleteAccessResultList(AccessResult_t** accessResult, int variableCount);\n\n#endif /* MMS_COMMON_INTERNAL */\n\n", "/*\n *  mms_client_files.c\n *\n *  Copyright 2013 - 2022 Michael Zillgith\n *\n *  This file is part of libIEC61850.\n *\n *  libIEC61850 is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  libIEC61850 is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with libIEC61850.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  See COPYING file for the complete license text.\n */\n\n#include \"libiec61850_platform_includes.h\"\n#include \"stack_config.h\"\n#include \"mms_common.h\"\n#include \"mms_client_connection.h\"\n#include \"byte_buffer.h\"\n\n#include \"mms_client_internal.h\"\n#include \"ber_encoder.h\"\n#include \"ber_decode.h\"\n#include \"ber_integer.h\"\n#include \"conversions.h\"\n\n#if (MMS_OBTAIN_FILE_SERVICE == 1)\n\nstatic MmsFileReadStateMachine*\ngetFreeFrsm(MmsConnection connection)\n{\n    int i;\n\n    MmsFileReadStateMachine* freeFrsm = NULL;\n\n    for (i = 0; i < CONFIG_MMS_MAX_NUMBER_OF_OPEN_FILES_PER_CONNECTION; i++) {\n        if (connection->frsms[i].fileHandle == NULL) {\n            freeFrsm = &(connection->frsms[i]);\n            break;\n        }\n    }\n\n    return freeFrsm;\n}\n\nstatic MmsFileReadStateMachine*\ngetFrsm(MmsConnection connection, int32_t frsmId)\n{\n    int i;\n\n    MmsFileReadStateMachine* frsm = NULL;\n\n    for (i = 0; i < CONFIG_MMS_MAX_NUMBER_OF_OPEN_FILES_PER_CONNECTION; i++) {\n        if (connection->frsms[i].fileHandle != NULL) {\n            if (connection->frsms[i].frsmId == frsmId) {\n                frsm = &(connection->frsms[i]);\n                break;\n            }\n        }\n    }\n\n    return frsm;\n}\n\nstatic int32_t\ngetNextFrsmId(MmsConnection connection)\n{\n    uint32_t nextFrsmId = connection->nextFrsmId;\n    connection->nextFrsmId++;\n\n    return nextFrsmId;\n}\n\nvoid\nmmsClient_handleFileOpenRequest(\n    MmsConnection connection,\n    uint8_t* buffer, int bufPos, int maxBufPos,\n    uint32_t invokeId, ByteBuffer* response)\n{\n    char filename[256];\n    bool hasFileName = false;\n    uint32_t filePosition = 0;\n\n    while (bufPos < maxBufPos) {\n        uint8_t tag = buffer[bufPos++];\n        int length;\n\n        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n\n        if (bufPos < 0) goto exit_reject_invalid_pdu;\n\n        switch(tag) {\n        case 0xa0: /* filename */\n\n            if (!mmsMsg_parseFileName(filename, buffer, &bufPos, bufPos + length, invokeId, response))\n                return;\n\n            hasFileName = true;\n\n            break;\n\n        case 0x81: /* initial position */\n            filePosition = BerDecoder_decodeUint32(buffer, length, bufPos);\n            bufPos += length;\n            break;\n\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n\n        default: /* unrecognized parameter */\n            bufPos += length;\n            goto exit_reject_invalid_pdu;\n        }\n    }\n\n    if (hasFileName) {\n\n        if (mmsMsg_isFilenameSave(filename) == false) {\n            /* potential attack */\n\n            if (DEBUG_MMS_CLIENT)\n                printf(\"MMS_CLIENT: client provided unsave filename -> rejected\\n\");\n\n             mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n        }\n        else {\n            MmsFileReadStateMachine* frsm = getFreeFrsm(connection);\n\n            if (frsm != NULL) {\n\n                MmsOutstandingCall obtainFileCall = mmsClient_getMatchingObtainFileRequest(connection, filename);\n\n                if (obtainFileCall) {\n\n                    if (DEBUG_MMS_CLIENT)\n                        printf(\"MMS_CLIENT: file open is matching obtain file request for file %s\\n\", filename);\n\n                    obtainFileCall->timeout = Hal_getTimeInMs() + connection->requestTimeout;\n                }\n\n                FileHandle fileHandle = mmsMsg_openFile(MmsConnection_getFilestoreBasepath(connection), filename, false);\n\n                if (fileHandle != NULL) {\n\n                    frsm->fileHandle = fileHandle;\n                    frsm->readPosition = filePosition;\n                    frsm->frsmId = getNextFrsmId(connection);\n                    frsm->obtainRequest = obtainFileCall;\n\n                    mmsMsg_createFileOpenResponse(MmsConnection_getFilestoreBasepath(connection),\n                            invokeId, response, filename, frsm);\n                }\n                else\n                    mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n\n            }\n            else\n                mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_RESOURCE_OTHER);\n        }\n    }\n    else\n        goto exit_invalid_parameter;\n\n    return;\n\nexit_invalid_parameter:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_REQUEST_INVALID_ARGUMENT, response);\n    return;\n\nexit_reject_invalid_pdu:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n}\n\n\nvoid\nmmsClient_handleFileReadRequest(\n    MmsConnection connection,\n    uint8_t* buffer, int bufPos, int maxBufPos,\n    uint32_t invokeId,\n    ByteBuffer* response)\n{\n    int32_t frsmId = BerDecoder_decodeInt32(buffer, maxBufPos - bufPos, bufPos);\n\n    if (DEBUG_MMS_CLIENT)\n        printf(\"MMS_CLIENT: mmsClient_handleFileReadRequest read request for frsmId: %i\\n\", frsmId);\n\n    MmsFileReadStateMachine* frsm = getFrsm(connection, frsmId);\n\n    if (frsm) {\n        if (frsm->obtainRequest)\n            frsm->obtainRequest->timeout = Hal_getTimeInMs() + connection->requestTimeout;\n\n        mmsMsg_createFileReadResponse(connection->parameters.maxPduSize, invokeId, response, frsm);\n    }\n    else\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_OTHER);\n}\n\nvoid\nmmsClient_handleFileCloseRequest(\n    MmsConnection connection,\n    uint8_t* buffer, int bufPos, int maxBufPos,\n    uint32_t invokeId,\n    ByteBuffer* response)\n{\n    int32_t frsmId = BerDecoder_decodeInt32(buffer, maxBufPos - bufPos, bufPos);\n\n    MmsFileReadStateMachine* frsm = getFrsm(connection, frsmId);\n\n    if (frsm) {\n        if (frsm->obtainRequest)\n            frsm->obtainRequest->timeout = Hal_getTimeInMs() + connection->requestTimeout;\n\n        if(frsm->fileHandle){\n            FileSystem_closeFile(frsm->fileHandle);\n            frsm->fileHandle = NULL;\n        }\n        frsm->frsmId = 0;\n        frsm->obtainRequest = NULL;\n\n        mmsMsg_createFileCloseResponse(invokeId, response);\n    }\n    else\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_OTHER);\n}\n\nvoid\nmmsClient_closeOutstandingOpenFiles(MmsConnection connection)\n{\n    int i;\n\n    for (i = 0; i < CONFIG_MMS_MAX_NUMBER_OF_OPEN_FILES_PER_CONNECTION; i++) {\n        if (connection->frsms[i].fileHandle != NULL) {\n            FileSystem_closeFile(connection->frsms[i].fileHandle);\n            connection->frsms[i].fileHandle = NULL;\n        }\n    }\n}\n\n\n#endif /* (MMS_OBTAIN_FILE_SERVICE == 1) */\n\n#if (MMS_FILE_SERVICE == 1)\n\nvoid\nmmsClient_createFileOpenRequest(uint32_t invokeId, ByteBuffer* request, const char* fileName, uint32_t initialPosition)\n{\n    uint32_t invokeIdSize = BerEncoder_UInt32determineEncodedSize(invokeId);\n\n    uint32_t fileNameStringSize = strlen(fileName);\n    uint32_t fileNameSize = 1 + BerEncoder_determineLengthSize(fileNameStringSize) + fileNameStringSize;\n\n    uint32_t fileNameSeqSize = fileNameSize;\n\n    uint32_t fileOpenRequestSize = 1 + BerEncoder_determineLengthSize(fileNameSeqSize) + fileNameSeqSize + 2 + BerEncoder_UInt32determineEncodedSize(initialPosition);\n\n    uint32_t confirmedRequestPduSize = 2  + invokeIdSize + 2 + BerEncoder_determineLengthSize(fileOpenRequestSize) + fileOpenRequestSize;\n\n    int bufPos = 0;\n    uint8_t* buffer = request->buffer;\n\n    bufPos = BerEncoder_encodeTL(0xa0, confirmedRequestPduSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeTL(0x02, invokeIdSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeUInt32(invokeId, buffer, bufPos);\n\n    /* Encode FileOpen tag (context | structured ) [72 = 48h] */\n    buffer[bufPos++] = 0xbf;\n    buffer[bufPos++] = 0x48;\n    bufPos = BerEncoder_encodeLength(fileOpenRequestSize, buffer, bufPos);\n\n    bufPos = BerEncoder_encodeTL(0xa0, fileNameSeqSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeOctetString(0x19, (uint8_t*) fileName, fileNameStringSize, buffer, bufPos);\n\n    bufPos = BerEncoder_encodeUInt32WithTL(0x81, initialPosition, buffer, bufPos);\n\n    request->size = bufPos;\n}\n\nvoid\nmmsClient_createFileDeleteRequest(uint32_t invokeId, ByteBuffer* request, const char* fileName)\n{\n    uint32_t invokeIdSize = BerEncoder_UInt32determineEncodedSize(invokeId);\n\n    uint32_t fileNameStringSize = strlen(fileName);\n    uint32_t fileNameSize = 1 + BerEncoder_determineLengthSize(fileNameStringSize) + fileNameStringSize;\n\n    uint32_t fileDeleteRequestSize = fileNameSize;\n\n    uint32_t confirmedRequestPduSize = 1 + 2 + invokeIdSize + 1 + BerEncoder_determineLengthSize(fileDeleteRequestSize) + fileDeleteRequestSize;\n\n    int bufPos = 0;\n    uint8_t* buffer = request->buffer;\n\n    bufPos = BerEncoder_encodeTL(0xa0, confirmedRequestPduSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeTL(0x02, invokeIdSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeUInt32(invokeId, buffer, bufPos);\n\n    /* Encode FileOpen tag (context | structured ) [76 = 4ch] */\n    buffer[bufPos++] = 0xbf;\n    buffer[bufPos++] = 0x4c;\n\n    bufPos = BerEncoder_encodeLength(fileDeleteRequestSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeOctetString(0x19, (uint8_t*) fileName, fileNameStringSize, buffer, bufPos);\n\n    request->size = bufPos;\n}\n\nvoid\nmmsClient_createFileReadRequest(uint32_t invokeId, ByteBuffer* request, int32_t frsmId)\n{\n    uint32_t invokeIdSize = BerEncoder_UInt32determineEncodedSize(invokeId);\n\n    uint8_t frsmIdBuf[5];\n    Asn1PrimitiveValue frsmIdBer;\n    frsmIdBer.octets = frsmIdBuf;\n    frsmIdBer.maxSize = 5;\n    frsmIdBer.size = 0;\n\n    BerInteger_setInt32(&frsmIdBer, frsmId);\n\n    uint32_t frsmIdSize = frsmIdBer.size;\n\n    uint32_t confirmedRequestPduSize = 1 + 2 + 2  + invokeIdSize + frsmIdSize;\n\n    int bufPos = 0;\n    uint8_t* buffer = request->buffer;\n\n    bufPos = BerEncoder_encodeTL(0xa0, confirmedRequestPduSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeTL(0x02, invokeIdSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeUInt32(invokeId, buffer, bufPos);\n\n    /* Encode FileRead tag (context | primitive ) [73 = 49h] */\n    buffer[bufPos++] = 0x9f;\n    bufPos = BerEncoder_encodeOctetString(0x49, frsmIdBer.octets, frsmIdBer.size, buffer, bufPos);\n\n    request->size = bufPos;\n}\n\nstatic int\nencodeFileSpecification(uint8_t tag, const char* fileSpecification, uint8_t* buffer, int bufPos)\n{\n    uint32_t fileNameStringSize = strlen(fileSpecification);\n    uint32_t fileNameSeqSize = 1 + BerEncoder_determineLengthSize(fileNameStringSize) + fileNameStringSize;\n\n    if (buffer != NULL) {\n\n        bufPos = BerEncoder_encodeTL(tag, fileNameSeqSize, buffer, bufPos);\n        bufPos = BerEncoder_encodeOctetString(0x19, (uint8_t*) fileSpecification, fileNameStringSize, buffer, bufPos);\n\n        return bufPos;\n    }\n    else {\n        return fileNameSeqSize + 1 + BerEncoder_determineLengthSize(fileNameSeqSize);\n    }\n}\n\nvoid\nmmsClient_createFileDirectoryRequest(uint32_t invokeId, ByteBuffer* request, const char* fileSpecification, const char* continueAfter)\n{\n    uint32_t invokeIdSize = BerEncoder_UInt32determineEncodedSize(invokeId);\n\n    uint32_t confirmedRequestPduSize = 1 + 2 + 1  + invokeIdSize;\n\n    uint32_t parameterSize = 0;\n\n    if (fileSpecification)\n        parameterSize += encodeFileSpecification(0xa0, fileSpecification, NULL, 0);\n\n    if (continueAfter)\n        parameterSize += encodeFileSpecification(0xa1, continueAfter, NULL, 0);\n\n    confirmedRequestPduSize += BerEncoder_determineLengthSize(parameterSize) + parameterSize;\n\n    int bufPos = 0;\n    uint8_t* buffer = request->buffer;\n\n    bufPos = BerEncoder_encodeTL(0xa0, confirmedRequestPduSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeTL(0x02, invokeIdSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeUInt32(invokeId, buffer, bufPos);\n\n    /* Encode FileRead tag (context | structured ) [77 = 4dh] */\n    buffer[bufPos++] = 0xbf;\n    buffer[bufPos++] = 0x4d;\n    bufPos = BerEncoder_encodeLength(parameterSize, buffer, bufPos);\n\n    if (fileSpecification)\n        bufPos = encodeFileSpecification(0xa0, fileSpecification, buffer, bufPos);\n\n    if (continueAfter)\n        bufPos = encodeFileSpecification(0xa1, continueAfter, buffer, bufPos);\n\n    request->size = bufPos;\n}\n\n\nvoid\nmmsClient_createFileRenameRequest(uint32_t invokeId, ByteBuffer* request, const char* currentFileName, const char* newFileName)\n{\n    uint32_t invokeIdSize = BerEncoder_UInt32determineEncodedSize(invokeId);\n\n    uint32_t parameterSize = 0;\n\n    parameterSize += encodeFileSpecification(0xa0, currentFileName, NULL, 0);\n\n    parameterSize += encodeFileSpecification(0xa1, newFileName, NULL, 0);\n\n    uint32_t confirmedRequestPduSize = 2  + invokeIdSize + 2 + BerEncoder_determineLengthSize(parameterSize) + parameterSize;\n\n    int bufPos = 0;\n    uint8_t* buffer = request->buffer;\n\n    bufPos = BerEncoder_encodeTL(0xa0, confirmedRequestPduSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeTL(0x02, invokeIdSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeUInt32(invokeId, buffer, bufPos);\n\n    /* Encode FileRead tag (context | structured ) [75 = 4bh] */\n    buffer[bufPos++] = 0xbf;\n    buffer[bufPos++] = 0x4b;\n    bufPos = BerEncoder_encodeLength(parameterSize, buffer, bufPos);\n\n    bufPos = encodeFileSpecification(0xa0, currentFileName, buffer, bufPos);\n\n    bufPos = encodeFileSpecification(0xa1, newFileName, buffer, bufPos);\n\n    request->size = bufPos;\n}\n\nvoid\nmmsClient_createObtainFileRequest(uint32_t invokeId, ByteBuffer* request, const char* sourceFile, const char* destinationFile)\n{\n    uint32_t invokeIdSize = BerEncoder_UInt32determineEncodedSize(invokeId);\n\n    uint32_t parameterSize = 0;\n\n    parameterSize += encodeFileSpecification(0xa0, sourceFile, NULL, 0);\n\n    parameterSize += encodeFileSpecification(0xa1, destinationFile, NULL, 0);\n\n    uint32_t confirmedRequestPduSize = 2  + invokeIdSize + 2 + BerEncoder_determineLengthSize(parameterSize) + parameterSize;\n\n    int bufPos = 0;\n    uint8_t* buffer = request->buffer;\n\n    bufPos = BerEncoder_encodeTL(0xa0, confirmedRequestPduSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeTL(0x02, invokeIdSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeUInt32(invokeId, buffer, bufPos);\n\n    /* Encode ObtainFile tag (context | structured ) [46 = 2eh] */\n    buffer[bufPos++] = 0xbf;\n    buffer[bufPos++] = 0x2e;\n    bufPos = BerEncoder_encodeLength(parameterSize, buffer, bufPos);\n\n    bufPos = encodeFileSpecification(0xa1, sourceFile, buffer, bufPos);\n\n    bufPos = encodeFileSpecification(0xa2, destinationFile, buffer, bufPos);\n\n    request->size = bufPos;\n}\n\n\nstatic bool\nparseFileAttributes(uint8_t* buffer, int bufPos, int maxBufPos, uint32_t* fileSize, uint64_t* lastModified)\n{\n    int endPos = maxBufPos;\n\n    while (bufPos < endPos) {\n        uint8_t tag = buffer[bufPos++];\n        int length;\n\n        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, endPos);\n        if (bufPos < 0)\n            return false;\n\n        switch (tag) {\n        case 0x80: /* sizeOfFile */\n            if (fileSize != NULL)\n                *fileSize = BerDecoder_decodeUint32(buffer, length, bufPos);\n            break;\n        case 0x81: /* lastModified */\n            {\n                if (lastModified != NULL) {\n                    char gtString[40];\n                    memcpy(gtString, buffer + bufPos, length);\n                    gtString[length] = 0;\n                    *lastModified = Conversions_generalizedTimeToMsTime(gtString);\n                }\n            }\n            break;\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n        default:\n            return false;\n        }\n\n        bufPos += length;\n    }\n\n    return true;\n}\n\nstatic bool\nparseDirectoryEntry(uint8_t* buffer, int bufPos, int maxBufPos, uint32_t invokeId, MmsConnection_FileDirectoryHandler handler, void* parameter)\n{\n    char fileNameMemory[400];\n    char* filename = NULL;\n    uint32_t fileSize = 0;\n    uint64_t lastModified = 0;\n\n    while (bufPos < maxBufPos) {\n        uint8_t tag = buffer[bufPos++];\n        int length;\n\n        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n        if (bufPos < 0) {\n            if (DEBUG_MMS_CLIENT)\n                printf(\"MMS_CLIENT: invalid length field\\n\");\n            return false;\n        }\n\n        switch (tag) {\n        case 0xa0: /* file-name */\n\n            filename = fileNameMemory;\n\n            tag = buffer[bufPos++];\n\n            bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n            if (bufPos < 0) {\n                if (DEBUG_MMS_CLIENT)\n                    printf(\"MMS_CLIENT: invalid length field\\n\");\n                return false;\n            }\n\n            memcpy(filename, buffer + bufPos, length);\n            filename[length] = 0;\n\n            bufPos += length;\n            break;\n        case 0xa1: /* file-attributes */\n            if (!parseFileAttributes(buffer, bufPos, bufPos + length, &fileSize, &lastModified))\n                return false;\n            bufPos += length;\n            break;\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n        default:\n            bufPos += length;\n            if (DEBUG_MMS_CLIENT)\n                printf(\"MMS_CLIENT: message contains unknown tag!\\n\");\n\n            return false;\n        }\n    }\n\n    if (filename != NULL)\n        handler(invokeId, parameter, MMS_ERROR_NONE, filename, fileSize, lastModified, true);\n    else\n        return false;\n\n    return true;\n}\n\nstatic bool\nparseListOfDirectoryEntries(uint8_t* buffer, int bufPos, int maxBufPos, uint32_t invokeId,\n        MmsConnection_FileDirectoryHandler handler, void* parameter)\n{\n    uint8_t tag = buffer[bufPos++];\n\n    if (tag != 0x30)\n        return false;\n\n    int length;\n\n    bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n\n    if (bufPos < 0) return false;\n\n    int endPos = bufPos + length;\n\n    while (bufPos < endPos) {\n        tag = buffer[bufPos++];\n\n        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n        if (bufPos < 0) return false;\n\n        switch (tag) {\n        case 0x30: /* Sequence */\n            parseDirectoryEntry(buffer, bufPos, bufPos + length, invokeId, handler, parameter);\n            bufPos += length;\n            break;\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n        default:\n            bufPos += length;\n            if (DEBUG_MMS_CLIENT)\n                printf(\"mmsClient_parseFileDirectoryResponse: message contains unknown tag!\\n\");\n            return false;\n        }\n    }\n\n    return true;\n}\n\n\nbool\nmmsClient_parseFileDirectoryResponse(ByteBuffer* response, int bufPos, uint32_t invokeId, MmsConnection_FileDirectoryHandler handler, void* parameter)\n{\n    uint8_t* buffer = response->buffer;\n    int maxBufPos = response->size;\n    int length;\n\n    uint8_t tag = buffer[bufPos++];\n\n    if (tag != 0xbf) {\n        if (DEBUG_MMS_CLIENT)\n            printf(\"mmsClient_parseFileDirectoryResponse: unknown tag %02x\\n\", tag);\n        return false;\n    }\n\n    tag = buffer[bufPos++];\n\n    if (tag != 0x4d) {\n        if (DEBUG_MMS_CLIENT)\n            printf(\"mmsClient_parseFileDirectoryResponse: unknown tag %02x\\n\", tag);\n        return false;\n    }\n\n    bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n    if (bufPos < 0) return false;\n\n    int endPos = bufPos + length;\n\n    bool moreFollows = false;\n\n    while (bufPos < endPos) {\n        tag = buffer[bufPos++];\n\n        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n        if (bufPos < 0) return false;\n\n        switch (tag) {\n        case 0xa0: /* listOfDirectoryEntries */\n            parseListOfDirectoryEntries(buffer, bufPos, bufPos + length, invokeId, handler, parameter);\n\n            bufPos += length;\n            break;\n        case 0x81: /* moreFollows */\n            moreFollows = BerDecoder_decodeBoolean(buffer, bufPos);\n            bufPos += length;\n            break;\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n        default:\n            bufPos += length;\n            if (DEBUG_MMS_CLIENT)\n                printf(\"mmsClient_parseFileDirectoryResponse: message contains unknown tag!\\n\");\n            break;\n        }\n    }\n\n    handler(invokeId, parameter, MMS_ERROR_NONE, NULL, 0, 0, moreFollows);\n\n    return true;\n}\n\nbool\nmmsMsg_parseFileOpenResponse(uint8_t* buffer, int bufPos, int maxBufPos, int32_t* frsmId, uint32_t* fileSize, uint64_t* lastModified)\n{\n    int length;\n\n    uint8_t tag = buffer[bufPos++];\n\n    if (tag != 0xbf) {\n        if (DEBUG_MMS_CLIENT)\n            printf(\"MMS: mmsClient_parseFileOpenResponse: unknown tag %02x\\n\", tag);\n        return false;\n    }\n\n    tag = buffer[bufPos++];\n\n    if (tag != 0x48) {\n        if (DEBUG_MMS_CLIENT)\n            printf(\"MMS_CLIENT: mmsClient_parseFileOpenResponse: unknown tag %02x\\n\", tag);\n        return false;\n    }\n\n    bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n    if (bufPos < 0)\n        return false;\n\n    int endPos = bufPos + length;\n\n    while (bufPos < endPos) {\n        tag = buffer[bufPos++];\n\n        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n        if (bufPos < 0)\n            return false;\n\n        switch (tag) {\n        case 0x80: /* frsmId */\n            *frsmId = BerDecoder_decodeInt32(buffer, length, bufPos);\n\n            bufPos += length;\n            break;\n        case 0xa1: /* fileAttributes */\n            if (!parseFileAttributes(buffer, bufPos, bufPos + length, fileSize, lastModified))\n                return false;\n            bufPos += length;\n            break;\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n        default:\n            bufPos += length;\n            if (DEBUG_MMS_CLIENT)\n                printf(\"MMS_CLIENT/SERVER: mmsClient_parseFileOpenResponse: message contains unknown tag %02x!\\n\", tag);\n            break;\n        }\n    }\n\n    return true;\n}\n\nbool\nmmsMsg_parseFileReadResponse(uint8_t* buffer, int bufPos, int maxBufPos, uint32_t invokeId, int frsmId, bool* moreFollows, MmsConnection_FileReadHandler handler, void* handlerParameter)\n{\n    int length;\n    uint8_t* data = NULL;\n    int dataLen = 0;\n\n\n    uint8_t tag = buffer[bufPos++];\n\n\n    if (tag != 0xbf) {\n        if (DEBUG_MMS_CLIENT)\n            printf(\"MMS_CLIENT/SERVER: mmsClient_parseFileReadResponse: unknown tag %02x\\n\", tag);\n        return false;\n    }\n\n    tag = buffer[bufPos++];\n\n    *moreFollows = true;\n\n    if (tag != 0x49) {\n        if (DEBUG_MMS_CLIENT)\n            printf(\"MMS_CLIENT/SERVER: mmsClient_parseFileReadResponse: unknown tag %02x\\n\", tag);\n        return false;\n    }\n\n    bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n    if (bufPos < 0)\n        return false;\n\n    int endPos = bufPos + length;\n\n    while (bufPos < endPos) {\n        tag = buffer[bufPos++];\n\n        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n        if (bufPos < 0)\n            return false;\n\n        switch (tag) {\n        case 0x80: /* fileData */\n            data = buffer + bufPos;\n            dataLen = length;\n\n            bufPos += length;\n            break;\n\n        case 0x81: /* moreFollows */\n            *moreFollows = BerDecoder_decodeBoolean(buffer, bufPos);\n            bufPos += length;\n            break;\n\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n\n        default:\n            bufPos += length;\n            if (DEBUG_MMS_CLIENT)\n                printf(\"MMS_CLIENT/SERVER: mmsClient_parseFileReadResponse: message contains unknown tag %02x!\\n\", tag);\n\n            return false;\n        }\n    }\n\n    handler(invokeId, handlerParameter, MMS_ERROR_NONE, frsmId, data, dataLen, *moreFollows);\n\n    return true;\n}\n\nvoid\nmmsClient_createFileCloseRequest(uint32_t invokeId, ByteBuffer* request, int32_t frsmId)\n{\n    uint32_t invokeIdSize = BerEncoder_UInt32determineEncodedSize(invokeId);\n\n    uint8_t frsmIdBuf[5];\n    Asn1PrimitiveValue frsmIdBer;\n    frsmIdBer.octets = frsmIdBuf;\n    frsmIdBer.maxSize = 5;\n    frsmIdBer.size = 0;\n\n    BerInteger_setInt32(&frsmIdBer, frsmId);\n\n    uint32_t confirmedRequestPduSize = 1 + 2 + 2  + invokeIdSize + frsmIdBer.size;\n\n    int bufPos = 0;\n    uint8_t* buffer = request->buffer;\n\n    bufPos = BerEncoder_encodeTL(0xa0, confirmedRequestPduSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeTL(0x02, invokeIdSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeUInt32(invokeId, buffer, bufPos);\n\n    /* Encode FileClose tag (context | primitive) [74 = 4ah] */\n    buffer[bufPos++] = 0x9f;\n    bufPos = BerEncoder_encodeOctetString(0x4a, frsmIdBer.octets, frsmIdBer.size, buffer, bufPos);\n\n    request->size = bufPos;\n}\n\n#endif /* (MMS_FILE_SERVICE == 1) */\n", "/*\n *  mms_common_msg.c\n *\n *  Copyright 2013-2022 Michael Zillgith\n *\n *  This file is part of libIEC61850.\n *\n *  libIEC61850 is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  libIEC61850 is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with libIEC61850.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  See COPYING file for the complete license text.\n */\n\n#include \"libiec61850_platform_includes.h\"\n#include \"mms_common_internal.h\"\n#include \"stack_config.h\"\n#include \"mms_value_internal.h\"\n#include \"ber_decode.h\"\n\nstatic void\nmmsMsg_createFloatData(MmsValue* value, int* size, uint8_t** buf)\n{\n    if (value->value.floatingPoint.formatWidth == 64) {\n        *size = 9;\n        *buf = (uint8_t*) GLOBAL_MALLOC(9);\n        (*buf)[0] = 11;\n#if (ORDER_LITTLE_ENDIAN == 1)\n        memcpyReverseByteOrder((*buf) + 1, value->value.floatingPoint.buf, 8);\n#else\n        memcpy((*buf) + 1, value->value.floatingPoint.buf, 8);\n#endif\n    } else {\n        *size = 5;\n        *buf = (uint8_t*) GLOBAL_MALLOC(5);\n        (*buf)[0] = 8;\n#if (ORDER_LITTLE_ENDIAN == 1)\n        memcpyReverseByteOrder((*buf) + 1, value->value.floatingPoint.buf, 4);\n#else\n        memcpy((*buf) + 1, value->value.floatingPoint.buf, 4);\n#endif\n    }\n}\n\nData_t*\nmmsMsg_createBasicDataElement(MmsValue* value)\n{\n    Data_t* dataElement = (Data_t*) GLOBAL_CALLOC(1, sizeof(Data_t));\n\n    switch (value->type) {\n    case MMS_ARRAY:\n        {\n            int size = MmsValue_getArraySize(value);\n            dataElement->present = Data_PR_array;\n            dataElement->choice.array = (DataSequence_t*) GLOBAL_CALLOC(1, sizeof(DataSequence_t));\n            dataElement->choice.array->list.count = size;\n            dataElement->choice.array->list.size = size;\n            dataElement->choice.array->list.array = (Data_t**) GLOBAL_CALLOC(size, sizeof(Data_t*));\n            int i;\n            for (i = 0; i < size; i++) {\n                dataElement->choice.array->list.array[i] =\n                        mmsMsg_createBasicDataElement(MmsValue_getElement(value, i));\n            }\n        }\n        break;\n\n    case MMS_STRUCTURE:\n        {\n            int size = value->value.structure.size;\n\n            dataElement->present = Data_PR_structure;\n            dataElement->choice.structure = (DataSequence_t*) GLOBAL_CALLOC(1, sizeof(DataSequence_t));\n            dataElement->choice.structure->list.count = size;\n            dataElement->choice.structure->list.size = size;\n            dataElement->choice.structure->list.array = (Data_t**) GLOBAL_CALLOC(size, sizeof(Data_t*));\n            int i;\n            for (i = 0; i < size; i++) {\n                dataElement->choice.structure->list.array[i] = mmsMsg_createBasicDataElement(\n                        value->value.structure.components[i]);\n            }\n        }\n        break;\n\n    case MMS_BIT_STRING: \n\t\t{\n\t\t\tdataElement->present = Data_PR_bitstring;\n\t\t\tdataElement->choice.bitstring.buf = value->value.bitString.buf;\n\t\t\tint size = (value->value.bitString.size / 8) + ((value->value.bitString.size % 8) > 0);\n\t\t\tint unused = 8 - (value->value.bitString.size % 8);\n\t\t\tdataElement->choice.bitstring.size = size; /* size in bytes */\n\t\t\tdataElement->choice.bitstring.bits_unused = unused;\n\t\t}\n        break;\n\n    case MMS_BOOLEAN:\n        dataElement->present = Data_PR_boolean;\n        dataElement->choice.boolean = value->value.boolean;\n        break;\n\n    case MMS_FLOAT:\n        dataElement->present = Data_PR_floatingpoint;\n\n        mmsMsg_createFloatData(value, &dataElement->choice.floatingpoint.size,\n                &dataElement->choice.floatingpoint.buf);\n        break;\n\n    case MMS_UTC_TIME:\n        dataElement->present = Data_PR_utctime;\n\n        dataElement->choice.utctime.buf = (uint8_t*) GLOBAL_MALLOC(8);\n        memcpy(dataElement->choice.utctime.buf, value->value.utcTime, 8);\n        dataElement->choice.utctime.size = 8;\n        break;\n\n    case MMS_INTEGER:\n        dataElement->present = Data_PR_integer;\n\n        dataElement->choice.integer.size = value->value.integer->size;\n        dataElement->choice.integer.buf = value->value.integer->octets;\n\n        break;\n\n    case MMS_UNSIGNED:\n        dataElement->present = Data_PR_unsigned;\n\n        dataElement->choice.Unsigned.size = value->value.integer->size;\n        dataElement->choice.Unsigned.buf = value->value.integer->octets;\n\n        break;\n\n    case MMS_VISIBLE_STRING:\n        dataElement->present = Data_PR_visiblestring;\n        if (value->value.visibleString.buf != NULL ) {\n            dataElement->choice.visiblestring.buf = (uint8_t*) value->value.visibleString.buf;\n            dataElement->choice.visiblestring.size = strlen(value->value.visibleString.buf);\n        } else\n            dataElement->choice.visiblestring.size = 0;\n        break;\n\n    case MMS_OCTET_STRING:\n        dataElement->present = Data_PR_octetstring;\n        if (value->value.octetString.buf != NULL ) {\n            dataElement->choice.octetstring.buf = value->value.octetString.buf;\n            dataElement->choice.octetstring.size =\n                    value->value.octetString.size;\n        } else\n            dataElement->choice.octetstring.size = 0;\n        break;\n\n    case MMS_STRING:\n        dataElement->present = Data_PR_mMSString;\n        if (value->value.visibleString.buf != NULL ) {\n            dataElement->choice.mMSString.buf = (uint8_t*) value->value.visibleString.buf;\n            dataElement->choice.mMSString.size = strlen(value->value.visibleString.buf);\n        } else\n            dataElement->choice.mMSString.size = 0;\n        break;\n\n    case MMS_BINARY_TIME:\n        dataElement->present = Data_PR_binarytime;\n        dataElement->choice.binarytime.size = value->value.binaryTime.size;\n        dataElement->choice.binarytime.buf = value->value.binaryTime.buf;\n        break;\n\n    default:\n        dataElement->present = Data_PR_NOTHING;\n\n        break;\n    }\n\n    return dataElement;\n}\n\nMmsValue*\nmmsMsg_parseDataElement(Data_t* dataElement)\n{\n    MmsValue* value = NULL;\n\n    if (dataElement->present == Data_PR_array) {\n\n        int componentCount = dataElement->choice.array->list.count;\n\n        if (componentCount > 0) {\n            value = (MmsValue*) GLOBAL_CALLOC(1, sizeof(MmsValue));\n\n            if (value) {\n                value->type = MMS_ARRAY;\n                value->value.structure.size = componentCount;\n                value->value.structure.components = (MmsValue**) GLOBAL_CALLOC(componentCount, sizeof(MmsValue*));\n\n                int i;\n\n                for (i = 0; i < componentCount; i++) {\n                    value->value.structure.components[i] =\n                            mmsMsg_parseDataElement(dataElement->choice.array->list.array[i]);\n\n                    if (value->value.structure.components[i] == NULL) {\n                        MmsValue_delete(value);\n                        value = NULL;\n                        break;\n                    }\n                }\n            }\n        }\n        else {\n            if (DEBUG_MMS_CLIENT)\n                printf(\"MMS CLIENT: error parsing data element (invalid array size)!\\n\");\n        }\n\n    }\n    else if (dataElement->present == Data_PR_structure) {\n\n        int componentCount = dataElement->choice.structure->list.count;\n\n        if (componentCount > 0) {\n            value = (MmsValue*) GLOBAL_CALLOC(1, sizeof(MmsValue));\n\n            if (value) {\n                value->type = MMS_STRUCTURE;\n                value->value.structure.size = componentCount;\n                value->value.structure.components = (MmsValue**) GLOBAL_CALLOC(componentCount, sizeof(MmsValue*));\n\n                int i;\n\n                for (i = 0; i < componentCount; i++) {\n                    value->value.structure.components[i] =\n                            mmsMsg_parseDataElement(dataElement->choice.structure->list.array[i]);\n\n                    if (value->value.structure.components[i] == NULL) {\n                        MmsValue_delete(value);\n                        value = NULL;\n                        break;\n                    }\n                }\n            }\n        }\n        else {\n            if (DEBUG_MMS_CLIENT)\n                printf(\"MMS CLIENT: error parsing data element (invalid structure size)!\\n\");\n        }\n    }\n    else {\n        if (dataElement->present == Data_PR_integer) {\n\n            if (dataElement->choice.integer.size > 0) {\n                Asn1PrimitiveValue* berInteger = BerInteger_createFromBuffer(\n                        dataElement->choice.integer.buf, dataElement->choice.integer.size);\n\n                if (berInteger)\n                    value = MmsValue_newIntegerFromBerInteger(berInteger);\n            }\n            else {\n                if (DEBUG_MMS_CLIENT)\n                    printf(\"MMS CLIENT: error parsing data element (invalid integer size)!\\n\");\n            }\n        }\n        else if (dataElement->present == Data_PR_unsigned) {\n\n            if (dataElement->choice.Unsigned.size > 0) {\n                Asn1PrimitiveValue* berInteger = BerInteger_createFromBuffer(\n                        dataElement->choice.Unsigned.buf, dataElement->choice.Unsigned.size);\n\n                if (berInteger)\n                    value = MmsValue_newUnsignedFromBerInteger(berInteger);\n            }\n            else {\n                if (DEBUG_MMS_CLIENT)\n                    printf(\"MMS CLIENT: error parsing data element (invalid unsigned size)!\\n\");\n            }\n        }\n        else if (dataElement->present == Data_PR_visiblestring) {\n\n            if (dataElement->choice.visiblestring.size >= 0) {\n                value = MmsValue_newVisibleStringFromByteArray(dataElement->choice.visiblestring.buf,\n                        dataElement->choice.visiblestring.size);\n            }\n        }\n        else if (dataElement->present == Data_PR_mMSString) {\n\n            if ( dataElement->choice.mMSString.size >= 0) {\n                value = MmsValue_newMmsStringFromByteArray(dataElement->choice.mMSString.buf,\n                        dataElement->choice.mMSString.size);\n            }\n        }\n        else if (dataElement->present == Data_PR_bitstring) {\n\n            int size = dataElement->choice.bitstring.size;\n\n            if (size >= 0) {\n\n                int maxSize = (size * 8);\n                int bitSize = maxSize - dataElement->choice.bitstring.bits_unused;\n\n                if ((bitSize > 0) && (maxSize >= bitSize)) {\n                    value = (MmsValue*) GLOBAL_CALLOC(1, sizeof(MmsValue));\n\n                    if (value) {\n\n                        value->type = MMS_BIT_STRING;\n\n                        value->value.bitString.size = bitSize;\n\n                        value->value.bitString.buf = (uint8_t*) GLOBAL_MALLOC(size);\n\n                        if (value->value.bitString.buf) {\n                            memcpy(value->value.bitString.buf,\n                                dataElement->choice.bitstring.buf, size);\n                        }\n                        else {\n                            GLOBAL_FREEMEM(value);\n                            value = 0;\n                        }\n                    }\n                }\n                else if (bitSize == 0) {\n                    value = (MmsValue*) GLOBAL_CALLOC(1, sizeof(MmsValue));\n\n                    if (value) {\n                        value->type = MMS_BIT_STRING;\n                        value->value.bitString.size = 0;\n                        value->value.bitString.buf = NULL;\n                    }\n                }\n                else {\n                    if (DEBUG_MMS_CLIENT)\n                        printf(\"MMS CLIENT: error parsing data element (bit string padding problem)!\\n\");\n                }\n            }\n            else {\n                if (DEBUG_MMS_CLIENT)\n                    printf(\"MMS CLIENT: error parsing data element (bit string size 0 or negative)!\\n\");\n            }\n        }\n        else if (dataElement->present == Data_PR_floatingpoint) {\n\n            int size = dataElement->choice.floatingpoint.size;\n\n            if (size == 5) { /* FLOAT32 */\n\n                value = (MmsValue*) GLOBAL_CALLOC(1, sizeof(MmsValue));\n\n                if (value) {\n                    value->type = MMS_FLOAT;\n\n                    value->value.floatingPoint.formatWidth = 32;\n                    value->value.floatingPoint.exponentWidth = dataElement->choice.floatingpoint.buf[0];\n\n                    uint8_t* floatBuf = (dataElement->choice.floatingpoint.buf + 1);\n\n#if (ORDER_LITTLE_ENDIAN == 1)\n                    memcpyReverseByteOrder(value->value.floatingPoint.buf, floatBuf, 4);\n#else\n                    memcpy(value->value.floatingPoint.buf, floatBuf, 4);\n#endif\n                }\n            }\n\n            if (size == 9) { /* FLOAT64 */\n\n                value = (MmsValue*) GLOBAL_CALLOC(1, sizeof(MmsValue));\n\n                if (value) {\n                    value->type = MMS_FLOAT;\n\n                    value->value.floatingPoint.formatWidth = 64;\n                    value->value.floatingPoint.exponentWidth = dataElement->choice.floatingpoint.buf[0];\n\n                    uint8_t* floatBuf = (dataElement->choice.floatingpoint.buf + 1);\n\n#if (ORDER_LITTLE_ENDIAN == 1)\n                    memcpyReverseByteOrder(value->value.floatingPoint.buf, floatBuf, 8);\n#else\n                    memcpy(value->value.floatingPoint.buf, floatBuf, 8);\n#endif\n                }\n            }\n        }\n        else if (dataElement->present == Data_PR_utctime) {\n\n            int size = dataElement->choice.utctime.size;\n\n            if (size == 8) {\n                value = (MmsValue*) GLOBAL_CALLOC(1, sizeof(MmsValue));\n\n                if (value) {\n                    value->type = MMS_UTC_TIME;\n                    memcpy(value->value.utcTime, dataElement->choice.utctime.buf, 8);\n                }\n            }\n            else {\n                if (DEBUG_MMS_CLIENT)\n                    printf(\"MMS CLIENT: error parsing UTC time (size is %i instead of 8\\n\", size);\n            }\n        }\n        else if (dataElement->present == Data_PR_octetstring) {\n\n            if (dataElement->choice.octetstring.size >= 0) {\n                value = (MmsValue*) GLOBAL_CALLOC(1, sizeof(MmsValue));\n\n                if (value) {\n                    value->type = MMS_OCTET_STRING;\n                    int size = dataElement->choice.octetstring.size;\n\n                    value->value.octetString.size = size;\n\n                    if (size > 0)\n                        value->value.octetString.maxSize = -size;\n                    else\n                        value->value.octetString.maxSize = -8;\n\n                    value->value.octetString.buf = (uint8_t*) GLOBAL_MALLOC(abs(value->value.octetString.maxSize));\n\n                    if (value->value.octetString.buf) {\n                        memcpy(value->value.octetString.buf, dataElement->choice.octetstring.buf, size);\n                    }\n                    else {\n                        GLOBAL_FREEMEM(value);\n                        value = NULL;\n                    }\n                }\n            }\n\n        }\n        else if (dataElement->present == Data_PR_binarytime) {\n            int size = dataElement->choice.binarytime.size;\n\n            if ((size == 4) || (size == 6)) {\n                value = (MmsValue*) GLOBAL_CALLOC(1, sizeof(MmsValue));\n\n                if (value) {\n                    value->type = MMS_BINARY_TIME;\n                    value->value.binaryTime.size = size;\n                    memcpy(value->value.binaryTime.buf, dataElement->choice.binarytime.buf, size);\n                }\n            }\n            else {\n                if (DEBUG_MMS_CLIENT)\n                    printf(\"MMS CLIENT: error parsing binary time (size must be 4 or 6, is %i\\n\", size);\n            }\n        }\n        else if (dataElement->present == Data_PR_boolean) {\n            value = MmsValue_newBoolean(dataElement->choice.boolean);\n        }\n        else if (dataElement->present == Data_PR_booleanArray) {\n\n        }\n\n    }\n\n    if (DEBUG_MMS_CLIENT) {\n        if (value == NULL)\n            printf(\"MMS CLIENT: error parsing data element\\n\");\n    }\n\n    return value;\n}\n\nchar*\nmmsMsg_createStringFromAsnIdentifier(Identifier_t identifier)\n{\n    char* str = StringUtils_createStringFromBuffer(identifier.buf, identifier.size);\n\n    return str;\n}\n\n\nvoid\nmmsMsg_copyAsn1IdentifierToStringBuffer(Identifier_t identifier, char* buffer, int bufSize)\n{\n    if (identifier.size < bufSize) {\n        memcpy(buffer, identifier.buf, identifier.size);\n        buffer[identifier.size] = 0;\n    }\n    else {\n\n        if (DEBUG_MMS_SERVER || DEBUG_MMS_CLIENT)\n            printf(\"MMS_COMMON: mms_common_msg.c: ASN1 identifier to long!\\n\");\n\n        buffer[0] = 0;\n    }\n}\n\nchar*\nmmsMsg_getComponentNameFromAlternateAccess(AlternateAccess_t* alternateAccess, char* componentNameBuf, int nameBufPos)\n{\n    if (alternateAccess->list.count == 1) {\n\n        if (alternateAccess->list.array[0]->present == AlternateAccess__Member_PR_unnamed) {\n\n            if (alternateAccess->list.array[0]->choice.unnamed->present == AlternateAccessSelection_PR_selectAlternateAccess) {\n\n                if (alternateAccess->list.array[0]->choice.unnamed->choice.selectAlternateAccess.accessSelection.present ==\n                                AlternateAccessSelection__selectAlternateAccess__accessSelection_PR_component)\n                {\n                    Identifier_t componentIdentifier = alternateAccess->list.array[0]->choice.unnamed->\n                            choice.selectAlternateAccess.accessSelection.choice.component;\n\n                    AlternateAccess_t* nextAlternateAccess = alternateAccess->list.array[0]->choice.unnamed->\n                            choice.selectAlternateAccess.alternateAccess;\n\n                    if (nextAlternateAccess) {\n                        if (nameBufPos + componentIdentifier.size + 1 < 65) {\n                            memcpy(componentNameBuf + nameBufPos, componentIdentifier.buf, componentIdentifier.size);\n                            nameBufPos += componentIdentifier.size;\n                            componentNameBuf[nameBufPos++] = '$';\n                            return mmsMsg_getComponentNameFromAlternateAccess(nextAlternateAccess, componentNameBuf, nameBufPos);\n                        }\n                        else {\n                            if (DEBUG_MMS_SERVER)\n                                printf(\"MMS_SERVER: component identifier name too long!\\n\");\n                        }\n                    }\n                    else {\n                        if (DEBUG_MMS_SERVER)\n                            printf(\"MMS_SERVER: next alternate access specification is missing!\\n\");\n                    }\n                }\n            }\n            else if (alternateAccess->list.array[0]->choice.unnamed->present == AlternateAccessSelection_PR_selectAccess) {\n\n                /* final component part */\n\n                if (alternateAccess->list.array[0]->choice.unnamed->choice.selectAccess.present ==\n                        AlternateAccessSelection__selectAccess_PR_component)\n                {\n                    Identifier_t componentIdentifier = alternateAccess->list.array[0]->choice.unnamed->\n                            choice.selectAccess.choice.component;\n\n                    if (nameBufPos + componentIdentifier.size + 1 < 65) {\n                        memcpy(componentNameBuf + nameBufPos, componentIdentifier.buf, componentIdentifier.size);\n                        nameBufPos += componentIdentifier.size;\n                        componentNameBuf[nameBufPos++] = 0;\n                        return componentNameBuf;\n                    }\n                    else {\n                        if (DEBUG_MMS_SERVER)\n                            printf(\"MMS_SERVER: component identifier name too long!\\n\");\n                    }\n                }\n            }\n\n        }\n\n    }\n\n    if (DEBUG_MMS_SERVER)\n        printf(\"MMS_SERVER: invalid component access specification\\n\");\n\n    return NULL;\n}\n\n#if (MMS_FILE_SERVICE == 1)\n\nvoid\nmmsMsg_createExtendedFilename(const char* basepath, int bufSize, char* extendedFileName, char* fileName)\n{\n#if (CONFIG_SET_FILESTORE_BASEPATH_AT_RUNTIME == 1)\n    StringUtils_concatString(extendedFileName, bufSize, basepath, fileName);\n#else\n    StringUtils_concatString(extendedFileName, bufSize, CONFIG_VIRTUAL_FILESTORE_BASEPATH, fileName);\n#endif\n}\n\nbool\nmmsMsg_isFilenameSave(const char* filename)\n{\n    if (filename)\n    {\n        if (strstr(filename, \"..\"))\n            return false;\n\n        if (strstr(filename, \"./\"))\n            return false;\n\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\nFileHandle\nmmsMsg_openFile(const char* basepath, char* fileName, bool readWrite)\n{\n#if (CONFIG_SET_FILESTORE_BASEPATH_AT_RUNTIME == 1)\n    char extendedFileName[512];\n#else\n    char extendedFileName[sizeof(CONFIG_VIRTUAL_FILESTORE_BASEPATH) + 256];\n#endif\n\n    mmsMsg_createExtendedFilename(basepath, 512, extendedFileName, fileName);\n\n    return FileSystem_openFile(extendedFileName, readWrite);\n}\n\nbool\nmmsMsg_parseFileName(char* filename, uint8_t* buffer, int* bufPos, int maxBufPos , uint32_t invokeId, ByteBuffer* response)\n{\n    if (*bufPos == maxBufPos)\n        return false;\n\n    uint8_t tag = buffer[(*bufPos)++];\n\n    if (tag != 0x19) {\n      mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n      return false;\n    }\n\n    int length;\n\n    *bufPos = BerDecoder_decodeLength(buffer, &length, *bufPos, maxBufPos);\n\n    if (*bufPos < 0)  {\n      mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n      return false;\n    }\n\n    if (length > 255) {\n      mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_REQUEST_INVALID_ARGUMENT, response);\n      return false;\n    }\n\n    memcpy(filename, buffer + *bufPos, length);\n    filename[length] = 0;\n    *bufPos += length;\n\n    /* Check if path contains invalid characters (prevent escaping the virtual filestore by using \"..\")\n     * TODO this may be platform dependent. Also depending of the platform there might be other evil\n     * characters.\n     */\n    if (strstr(filename, \"..\") != NULL) {\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n        return false;\n    }\n\n    return true;\n}\n\n#endif /* (MMS_FILE_SERVICE == 1) */\n\n", "/*\n *  mms_file_service.c\n *\n *  Copyright 2013-2018 Michael Zillgith\n *\n *  This file is part of libIEC61850.\n *\n *  libIEC61850 is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  libIEC61850 is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with libIEC61850.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  See COPYING file for the complete license text.\n */\n\n#include \"libiec61850_platform_includes.h\"\n#include \"mms_server_internal.h\"\n#include \"mms_client_internal.h\"\n\n#if (MMS_FILE_SERVICE == 1)\n\n#include \"hal_filesystem.h\"\n#include \"conversions.h\"\n\n#define CONFIG_MMS_FILE_SERVICE_MAX_FILENAME_LENGTH 256\n\nstatic void\ncreateNullResponseExtendedTag(uint32_t invokeId, ByteBuffer* response, uint8_t tag)\n{\n    uint32_t invokeIdSize = BerEncoder_UInt32determineEncodedSize(invokeId) + 2;\n\n    uint32_t confirmedResponsePDUSize = invokeIdSize + 3 ;\n\n    uint8_t* buffer = response->buffer;\n\n    int bufPos = 0;\n\n    bufPos = BerEncoder_encodeTL(0xa1, confirmedResponsePDUSize, buffer, bufPos);\n\n    bufPos = BerEncoder_encodeTL(0x02, invokeIdSize - 2, buffer, bufPos);\n    bufPos = BerEncoder_encodeUInt32(invokeId, buffer, bufPos);\n\n    buffer[bufPos++] = 0x9f; /* Context specific / primitive / extended */\n    bufPos = BerEncoder_encodeTL(tag, 0, buffer, bufPos);\n\n    response->size = bufPos;\n}\n\nstatic MmsFileReadStateMachine*\ngetFreeFrsm(MmsServerConnection connection)\n{\n    int i;\n\n    MmsFileReadStateMachine* freeFrsm = NULL;\n\n    for (i = 0; i < CONFIG_MMS_MAX_NUMBER_OF_OPEN_FILES_PER_CONNECTION; i++) {\n        if (connection->frsms[i].fileHandle == NULL) {\n            freeFrsm = &(connection->frsms[i]);\n            break;\n        }\n    }\n\n    return freeFrsm;\n}\n\nstatic MmsFileReadStateMachine*\ngetFrsm(MmsServerConnection connection, int32_t frsmId)\n{\n    int i;\n\n    MmsFileReadStateMachine* frsm = NULL;\n\n    for (i = 0; i < CONFIG_MMS_MAX_NUMBER_OF_OPEN_FILES_PER_CONNECTION; i++) {\n        if (connection->frsms[i].fileHandle != NULL) {\n            if (connection->frsms[i].frsmId == frsmId) {\n                frsm = &(connection->frsms[i]);\n                break;\n            }\n        }\n    }\n\n    return frsm;\n}\n\nstatic int32_t\ngetNextFrsmId(MmsServerConnection connection)\n{\n    uint32_t nextFrsmId = connection->nextFrsmId;\n    connection->nextFrsmId++;\n\n    return nextFrsmId;\n}\n\nstatic int\nencodeFileAttributes(uint8_t tag, uint32_t fileSize, char* gtString, uint8_t* buffer, int bufPos)\n{\n    uint32_t sizeOfFileSize = BerEncoder_UInt32determineEncodedSize(fileSize);\n\n    uint32_t gtStringSize = strlen(gtString);\n\n    uint32_t fileAttributesSize = 1 + BerEncoder_determineLengthSize(sizeOfFileSize) + sizeOfFileSize\n            + 2 + gtStringSize;\n\n    if (buffer == NULL) {\n        return fileAttributesSize;\n    }\n    else {\n        bufPos = BerEncoder_encodeTL(tag, fileAttributesSize, buffer, bufPos); /* file attributes */\n        bufPos = BerEncoder_encodeTL(0x80, sizeOfFileSize, buffer, bufPos); /* file size */\n        bufPos = BerEncoder_encodeUInt32(fileSize, buffer, bufPos);\n        bufPos = BerEncoder_encodeOctetString(0x81, (uint8_t*) gtString, gtStringSize, buffer, bufPos);\n        return bufPos;\n    }\n}\n\nstatic bool\ngetFileInfo(const char* basepath, char* filename, uint32_t* fileSize, uint64_t* lastModificationTimestamp)\n{\n#if (CONFIG_SET_FILESTORE_BASEPATH_AT_RUNTIME == 1)\n    char extendedFileName[512];\n    mmsMsg_createExtendedFilename(basepath, 512, extendedFileName, filename);\n#else\n    char extendedFileName[sizeof(CONFIG_VIRTUAL_FILESTORE_BASEPATH) + 256];\n    mmsMsg_createExtendedFilename(basepath, sizeof(CONFIG_VIRTUAL_FILESTORE_BASEPATH) + 256, extendedFileName, filename);\n#endif\n\n    return FileSystem_getFileInfo(extendedFileName, fileSize, lastModificationTimestamp);\n}\n\nstatic FileHandle\nopenFile(const char* basepath, char* fileName, bool readWrite)\n{\n#if (CONFIG_SET_FILESTORE_BASEPATH_AT_RUNTIME == 1)\n    char extendedFileName[512];\n    mmsMsg_createExtendedFilename(basepath, 512, extendedFileName, fileName);\n#else\n    char extendedFileName[sizeof(CONFIG_VIRTUAL_FILESTORE_BASEPATH) + 256];\n    mmsMsg_createExtendedFilename(basepath, sizeof(CONFIG_VIRTUAL_FILESTORE_BASEPATH) + 256, extendedFileName, fileName);\n#endif\n\n    return FileSystem_openFile(extendedFileName, readWrite);\n}\n\nstatic DirectoryHandle\nopenDirectory(const char* basepath, char* directoryName)\n{\n#if (CONFIG_SET_FILESTORE_BASEPATH_AT_RUNTIME == 1)\n    char extendedFileName[512];\n    mmsMsg_createExtendedFilename(basepath, 512, extendedFileName, directoryName);\n#else\n    char extendedFileName[sizeof(CONFIG_VIRTUAL_FILESTORE_BASEPATH) + 256];\n    mmsMsg_createExtendedFilename(basepath, sizeof(CONFIG_VIRTUAL_FILESTORE_BASEPATH) + 256, extendedFileName, directoryName);\n#endif\n\n    return FileSystem_openDirectory(extendedFileName);\n}\n\nstatic bool\nrenameFile(const char* basepath, char* oldFilename, char* newFilename) {\n\n#if (CONFIG_SET_FILESTORE_BASEPATH_AT_RUNTIME == 1)\n    char extendedOldFileName[512];\n    char extendedNewFileName[512];\n    mmsMsg_createExtendedFilename(basepath, 512, extendedOldFileName, oldFilename);\n    mmsMsg_createExtendedFilename(basepath, 512, extendedNewFileName, newFilename);\n#else\n    char extendedOldFileName[sizeof(CONFIG_VIRTUAL_FILESTORE_BASEPATH) + 256];\n    char extendedNewFileName[sizeof(CONFIG_VIRTUAL_FILESTORE_BASEPATH) + 256];\n    mmsMsg_createExtendedFilename(basepath, sizeof(CONFIG_VIRTUAL_FILESTORE_BASEPATH) + 256, extendedOldFileName, oldFilename);\n    mmsMsg_createExtendedFilename(basepath, sizeof(CONFIG_VIRTUAL_FILESTORE_BASEPATH) + 256, extendedNewFileName, newFilename);\n#endif\n\n    return FileSystem_renameFile(extendedOldFileName, extendedNewFileName);\n}\n\nstatic bool\ndeleteFile(const char* basepath, char* fileName) {\n#if (CONFIG_SET_FILESTORE_BASEPATH_AT_RUNTIME == 1)\n    char extendedFileName[512];\n    mmsMsg_createExtendedFilename(basepath, 512, extendedFileName, fileName);\n#else\n    char extendedFileName[sizeof(CONFIG_VIRTUAL_FILESTORE_BASEPATH) + 256];\n    mmsMsg_createExtendedFilename(basepath, sizeof(CONFIG_VIRTUAL_FILESTORE_BASEPATH) + 256, extendedFileName, fileName);\n#endif\n\n    return FileSystem_deleteFile(extendedFileName);\n}\n\nvoid\nmmsMsg_createFileOpenResponse(const char* basepath, uint32_t invokeId, ByteBuffer* response,\n        char* filename, MmsFileReadStateMachine* frsm)\n{\n    uint64_t msTime;\n\n    getFileInfo(basepath, filename, &(frsm->fileSize), &msTime);\n\n    char gtString[30];\n\n    Conversions_msTimeToGeneralizedTime(msTime, (uint8_t*) gtString);\n\n    uint32_t fileAttributesSize = encodeFileAttributes(0xa1, frsm->fileSize, gtString, NULL, 0) + 2;\n\n    uint32_t invokeIdSize = BerEncoder_UInt32determineEncodedSize(invokeId) + 2;\n\n    uint32_t frsmIdSize = BerEncoder_UInt32determineEncodedSize(frsm->frsmId) + 2;\n\n    uint32_t openFileResponseSize = fileAttributesSize + frsmIdSize;\n\n    uint32_t confirmedResponsePDUSize = invokeIdSize + 2 + BerEncoder_determineLengthSize(openFileResponseSize)\n               + openFileResponseSize;\n\n    uint8_t* buffer = response->buffer;\n\n    int bufPos = 0;\n\n    bufPos = BerEncoder_encodeTL(0xa1, confirmedResponsePDUSize, buffer, bufPos);\n\n    bufPos = BerEncoder_encodeTL(0x02, invokeIdSize - 2, buffer, bufPos);\n    bufPos = BerEncoder_encodeUInt32(invokeId, buffer, bufPos);\n\n    buffer[bufPos++] = 0xbf;\n    bufPos = BerEncoder_encodeTL(0x48, openFileResponseSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeTL(0x80, frsmIdSize - 2, buffer, bufPos);\n    bufPos = BerEncoder_encodeInt32(frsm->frsmId, buffer, bufPos);\n    bufPos = encodeFileAttributes(0xa1, frsm->fileSize, gtString, buffer, bufPos);\n\n    response->size = bufPos;\n}\n\nvoid\nmmsServer_handleFileDeleteRequest(\n    MmsServerConnection connection,\n    uint8_t* buffer, int bufPos, int maxBufPos,\n    uint32_t invokeId,\n    ByteBuffer* response)\n{\n    if (buffer[bufPos++] != 0x19)\n        goto exit_reject_invalid_pdu;\n\n    int length;\n\n    bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n    if (bufPos == -1)\n        goto exit_reject_invalid_pdu;\n\n    if (length > 255) {\n        mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_REQUEST_INVALID_ARGUMENT, response);\n        return;\n    }\n\n    char filename[256];\n\n    memcpy(filename, buffer + bufPos, length);\n    filename[length] = 0;\n\n    if (DEBUG_MMS_SERVER)\n        printf(\"MMS_SERVER: mms_file_service.c: Delete file (%s)\\n\", filename);\n\n    if (mmsMsg_isFilenameSave(filename) == false)\n    {\n        if (DEBUG_MMS_SERVER)\n            printf(\"MMS_SERVER: remote provided unsave filename -> rejected\\n\");\n\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n\n        return;\n    }\n\n    if (connection->server->fileAccessHandler != NULL) {\n        MmsError access = connection->server->fileAccessHandler(connection->server->fileAccessHandlerParameter,\n                            connection, MMS_FILE_ACCESS_TYPE_DELETE, filename, NULL);\n\n        if (access != MMS_ERROR_NONE) {\n            mmsMsg_createServiceErrorPdu(invokeId, response, access);\n            return;\n        }\n    }\n\n    if (!getFileInfo(MmsServerConnection_getFilesystemBasepath(connection), filename, NULL, NULL)) {\n        if (DEBUG_MMS_SERVER)\n            printf(\"MMS_SERVER: mms_file_service.c:  File (%s) not found\\n\", filename);\n\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n        return;\n    }\n\n    if (!deleteFile(MmsServerConnection_getFilesystemBasepath(connection), filename)) {\n        if (DEBUG_MMS_SERVER)\n            printf(\"MMS_SERVER: mms_file_service.c:  Delete file (%s) failed\\n\", filename);\n\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_ACCESS_DENIED);\n        return;\n    }\n\n    createNullResponseExtendedTag(invokeId, response, 0x4c);\n    return;\n\nexit_reject_invalid_pdu:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n}\n\nvoid\nmmsServer_handleFileOpenRequest(\n    MmsServerConnection connection,\n    uint8_t* buffer, int bufPos, int maxBufPos,\n    uint32_t invokeId,\n    ByteBuffer* response)\n{\n    char filename[256];\n    bool hasFileName = false;\n    uint32_t filePosition = 0;\n\n    while (bufPos < maxBufPos) {\n        uint8_t tag = buffer[bufPos++];\n        int length;\n\n        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n\n        if (bufPos < 0) goto exit_reject_invalid_pdu;\n\n        switch(tag) {\n        case 0xa0: /* filename */\n\n            if (!mmsMsg_parseFileName(filename, buffer, &bufPos, bufPos + length, invokeId, response))\n                return;\n\n            hasFileName = true;\n\n            break;\n\n        case 0x81: /* initial position */\n            filePosition = BerDecoder_decodeUint32(buffer, length, bufPos);\n            bufPos += length;\n            break;\n\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n\n        default: /* unrecognized parameter */\n            bufPos += length;\n            goto exit_reject_invalid_pdu;\n        }\n    }\n\n    if (hasFileName) {\n\n        if (mmsMsg_isFilenameSave(filename) == false) {\n            /* potential attack */\n\n            if (DEBUG_MMS_CLIENT)\n                printf(\"MMS_SERVER: remote provided unsave filename -> rejected\\n\");\n\n             mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n\n             return;\n        }\n\n        if (connection->server->fileAccessHandler != NULL) {\n            MmsError access = connection->server->fileAccessHandler(connection->server->fileAccessHandlerParameter,\n                                connection, MMS_FILE_ACCESS_TYPE_OPEN, filename, NULL);\n\n            if (access != MMS_ERROR_NONE) {\n                mmsMsg_createServiceErrorPdu(invokeId, response, access);\n                return;\n            }\n        }\n\n        MmsFileReadStateMachine* frsm = getFreeFrsm(connection);\n\n        if (frsm != NULL) {\n            FileHandle fileHandle = openFile(MmsServerConnection_getFilesystemBasepath(connection), filename, false);\n\n            if (fileHandle != NULL) {\n                frsm->fileHandle = fileHandle;\n                frsm->readPosition = filePosition;\n                frsm->frsmId = getNextFrsmId(connection);\n\n                mmsMsg_createFileOpenResponse(MmsServerConnection_getFilesystemBasepath(connection),\n                        invokeId, response, filename, frsm);\n            }\n            else\n                mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n\n\n        }\n        else\n            mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_RESOURCE_OTHER);\n    }\n    else\n        goto exit_invalid_parameter;\n\n    return;\n\nexit_invalid_parameter:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_REQUEST_INVALID_ARGUMENT, response);\n    return;\n\nexit_reject_invalid_pdu:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n}\n\n#if (MMS_OBTAIN_FILE_SERVICE == 1)\n\n\nstatic void /* Confirmed service error (ServiceError) */\ncreateServiceErrorObtainFileError(uint32_t invokeId, ByteBuffer* response,\n        MmsError errorType, uint32_t value)\n{\n    uint8_t buffer[8];\n\n    int size = BerEncoder_encodeUInt32WithTL(0x80, value, buffer, 0);\n\n    mmsServer_createServiceErrorPduWithServiceSpecificInfo(invokeId, response, errorType,\n            buffer, size);\n}\n\n\nstatic void\ncreateObtainFileResponse(uint32_t invokeId, ByteBuffer* response)\n{\n    createNullResponseExtendedTag(invokeId, response, 0x2e);\n}\n\nvoid\nmmsServer_fileUploadTask(MmsServer self, MmsObtainFileTask task, int taskState)\n{\n    /* call locks in certain order (lock IsoConnection -> reserverTransmitBuffer, task->taskLock) to prevent potential deadlock */\n\n    ByteBuffer* message = NULL;\n\n    if (taskState == MMS_FILE_UPLOAD_STATE_SEND_FILE_READ || \n        taskState == MMS_FILE_UPLOAD_STATE_SEND_FILE_CLOSE ||\n        taskState == MMS_FILE_UPLOAD_STATE_SEND_OBTAIN_FILE_ERROR_SOURCE ||\n        taskState == MMS_FILE_UPLOAD_STATE_SEND_OBTAIN_FILE_ERROR_DESTINATION ||\n        taskState == MMS_FILE_UPLOAD_STATE_SEND_OBTAIN_FILE_RESPONSE) \n    {\n        IsoConnection_lock(task->connection->isoConnection);\n\n        message = MmsServer_reserveTransmitBuffer(self);\n    }\n\n#if (CONFIG_MMS_THREADLESS_STACK != 1)\n    Semaphore_wait(task->taskLock);\n#endif\n\n    if (task->state == taskState) {\n\n        switch (task->state) {\n\n            case MMS_FILE_UPLOAD_STATE_NOT_USED:\n                break;\n\n            case MMS_FILE_UPLOAD_STATE_FILE_OPEN_SENT:\n                {\n                    if (Hal_getTimeInMs() > task->nextTimeout) {\n\n                        if (DEBUG_MMS_SERVER)\n                            printf(\"MMS_SERVER: file open timeout!\\n\");\n\n                        task->state = MMS_FILE_UPLOAD_STATE_SEND_OBTAIN_FILE_ERROR_SOURCE;\n\n                        if(task->fileHandle){\n                            FileSystem_closeFile(task->fileHandle);\n                            task->fileHandle = NULL;\n                        }\n                        deleteFile(MmsServer_getFilesystemBasepath(self), task->destinationFilename);\n                    }\n                }\n                break;\n\n            case MMS_FILE_UPLOAD_STATE_SEND_FILE_READ:\n                {\n                    task->lastRequestInvokeId = MmsServerConnection_getNextRequestInvokeId(task->connection);\n\n                    mmsClient_createFileReadRequest(task->lastRequestInvokeId, message, task->frmsId);\n\n                    task->state = MMS_FILE_UPLOAD_STATE_FILE_READ_SENT;\n                    IsoConnection_sendMessage(task->connection->isoConnection, message);\n\n                    task->nextTimeout = Hal_getTimeInMs() + 2000; /* timeout 2000 ms */\n                }\n\n                break;\n\n            case MMS_FILE_UPLOAD_STATE_FILE_READ_SENT:\n\n                if (Hal_getTimeInMs() > task->nextTimeout) {\n\n                    if (DEBUG_MMS_SERVER)\n                        printf(\"MMS_SERVER: file read timeout!\\n\");\n\n                    task->state = MMS_FILE_UPLOAD_STATE_SEND_OBTAIN_FILE_ERROR_SOURCE;\n\n                    if(task->fileHandle){\n                        FileSystem_closeFile(task->fileHandle);\n                        task->fileHandle = NULL;\n                    }\n                    deleteFile(MmsServer_getFilesystemBasepath(self), task->destinationFilename);\n                }\n\n                break;\n\n            case MMS_FILE_UPLOAD_STATE_SEND_FILE_CLOSE:\n                {\n                    task->lastRequestInvokeId = MmsServerConnection_getNextRequestInvokeId(task->connection);\n\n                    mmsClient_createFileCloseRequest(task->lastRequestInvokeId, message, task->frmsId);\n\n                    task->state = MMS_FILE_UPLOAD_STATE_FILE_CLOSE_SENT;\n\n                    IsoConnection_sendMessage(task->connection->isoConnection, message);\n\n                    task->nextTimeout = Hal_getTimeInMs() + 2000; /* timeout 2000 ms */\n\n                }\n                break;\n\n            case MMS_FILE_UPLOAD_STATE_FILE_CLOSE_SENT:\n\n                if (Hal_getTimeInMs() > task->nextTimeout) {\n\n                    if (DEBUG_MMS_SERVER)\n                        printf(\"MMS_SERVER: file close timeout!\\n\");\n\n                    task->state = MMS_FILE_UPLOAD_STATE_SEND_OBTAIN_FILE_ERROR_SOURCE;\n\n                    FileSystem_closeFile(task->fileHandle);\n                    task->fileHandle = NULL;\n                    deleteFile(MmsServer_getFilesystemBasepath(self), task->destinationFilename);\n                }\n\n                break;\n\n            case MMS_FILE_UPLOAD_STATE_SEND_OBTAIN_FILE_ERROR_SOURCE:\n\n                {\n                    /* send ObtainFileError */\n                    createServiceErrorObtainFileError(task->obtainFileRequestInvokeId, message, MMS_ERROR_FILE_FILE_NON_EXISTENT, 0);\n\n                    IsoConnection_sendMessage(task->connection->isoConnection, message);\n\n                    if(task->fileHandle){\n                        FileSystem_closeFile(task->fileHandle);\n                        task->fileHandle = NULL;\n                    }\n                    \n                    deleteFile(MmsServer_getFilesystemBasepath(self), task->destinationFilename);\n\n                    if (DEBUG_MMS_SERVER)\n                        printf(\"MMS_SERVER: ObtainFile service: failed to open file from client\\n\");\n\n                    task->state = MMS_FILE_UPLOAD_STATE_NOT_USED;\n                }\n                break;\n\n            case MMS_FILE_UPLOAD_STATE_SEND_OBTAIN_FILE_ERROR_DESTINATION:\n                {\n                    /* send ObtainFileError */\n                    createServiceErrorObtainFileError(task->obtainFileRequestInvokeId, message, MMS_ERROR_FILE_OTHER, 1);\n\n                    IsoConnection_sendMessage(task->connection->isoConnection, message);\n\n                    if (task->fileHandle) {\n                        FileSystem_closeFile(task->fileHandle);\n                        task->fileHandle = NULL;\n\n                        if (task->destinationFilename[0])\n                            deleteFile(MmsServer_getFilesystemBasepath(self), task->destinationFilename);\n                    }\n\n                    if (DEBUG_MMS_SERVER)\n                        printf(\"MMS_SERVER: ObtainFile service: failed to create local file\\n\");\n\n                    task->state = MMS_FILE_UPLOAD_STATE_NOT_USED;\n                }\n\n                break;\n\n            case MMS_FILE_UPLOAD_STATE_SEND_OBTAIN_FILE_RESPONSE:\n                {\n                    createObtainFileResponse(task->obtainFileRequestInvokeId, message);\n\n                    task->state = MMS_FILE_UPLOAD_STATE_NOT_USED;\n\n                    IsoConnection_sendMessage(task->connection->isoConnection, message);\n\n                    if (self->getFileCompleteHandler)\n                        self->getFileCompleteHandler(self->getFileCompleteHandlerParameter, task->connection, task->destinationFilename);\n                }\n                break;\n\n            case MMS_FILE_UPLOAD_STATE_INTERRUPTED:\n                {\n                    if (DEBUG_MMS_SERVER)\n                        printf(\"MMS_SERVER: file service interrupted, due to client disconnection\\n\");\n\n                    if (task->fileHandle){\n                        FileSystem_closeFile(task->fileHandle);\n                        task->fileHandle = NULL;\n\n                        if (task->destinationFilename[0])\n                            deleteFile(MmsServer_getFilesystemBasepath(self), task->destinationFilename);\n                    }\n                    task->state = MMS_FILE_UPLOAD_STATE_NOT_USED;\n                }\n                break;\n        }\n    }\n\n#if (CONFIG_MMS_THREADLESS_STACK != 1)\n    Semaphore_post(task->taskLock);\n#endif\n\n    if (message) {\n        MmsServer_releaseTransmitBuffer(self);\n        IsoConnection_unlock(task->connection->isoConnection);\n    }\n}\n\n#if (MMS_OBTAIN_FILE_SERVICE == 1)\n\nvoid\nmmsServerConnection_stopFileUploadTasks(MmsServerConnection self)\n{\n    MmsServer server = self->server;\n\n    int i;\n\n    for (i = 0; i < CONFIG_MMS_SERVER_MAX_GET_FILE_TASKS; i++) {\n\n#if (CONFIG_MMS_THREADLESS_STACK != 1)\n        Semaphore_wait(server->fileUploadTasks[i].taskLock);\n#endif\n\n        if (server->fileUploadTasks[i].state != 0) {\n\n            if (server->fileUploadTasks[i].connection == self) {\n\n                /* stop file upload task */\n                server->fileUploadTasks[i].state = MMS_FILE_UPLOAD_STATE_INTERRUPTED;\n            }\n\n        }\n\n#if (CONFIG_MMS_THREADLESS_STACK != 1)\n        Semaphore_post(server->fileUploadTasks[i].taskLock);\n#endif\n    }\n}\n\n#endif /*(MMS_OBTAIN_FILE_SERVICE == 1) */\nvoid\nmmsServer_handleObtainFileRequest(\n        MmsServerConnection connection,\n        uint8_t* buffer, int bufPos, int maxBufPos,\n        uint32_t invokeId,\n        ByteBuffer* response)\n{\n    char sourceFilename[256];\n    bool hasSourceFileName = false;\n\n    char destinationFilename[256];\n    bool hasDestinationFilename = false;\n\n    while (bufPos < maxBufPos) {\n        uint8_t tag = buffer[bufPos++];\n        int length;\n\n        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n\n        if (bufPos < 0) goto exit_reject_invalid_pdu;\n\n        switch(tag) {\n\n        case 0xa1: /* source filename */\n\n            if (!mmsMsg_parseFileName(sourceFilename, buffer, &bufPos, bufPos + length, invokeId, response))\n                return;\n\n            hasSourceFileName = true;\n\n            break;\n\n        case 0xa2: /* destination filename */\n\n            if (!mmsMsg_parseFileName(destinationFilename, buffer, &bufPos, bufPos + length, invokeId, response))\n                return;\n\n            hasDestinationFilename = true;\n\n            break;\n\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n\n        default: /* unrecognized parameter */\n            bufPos += length;\n            goto exit_reject_invalid_pdu;\n        }\n    }\n\n    if (hasSourceFileName && hasDestinationFilename) {\n\n        if (mmsMsg_isFilenameSave(destinationFilename) == false) {\n            /* potential attack */\n\n            if (DEBUG_MMS_SERVER)\n                printf(\"MMS_SERVER: remote provided unsave filename -> rejected\\n\");\n\n            goto exit_invalid_parameter;\n        }\n\n        /* Call user to check if access is allowed */\n        if (connection->server->fileAccessHandler != NULL) {\n            MmsError access = connection->server->fileAccessHandler(connection->server->fileAccessHandlerParameter,\n                                connection, MMS_FILE_ACCESS_TYPE_OBTAIN, destinationFilename, sourceFilename);\n\n            if (access != MMS_ERROR_NONE) {\n                mmsMsg_createServiceErrorPdu(invokeId, response, access);\n                return;\n            }\n        }\n\n        /* call callback to check if access is allowed -- DEPRECATED */\n        if (connection->server->obtainFileHandler)\n            if (connection->server->obtainFileHandler(connection->server->obtainFileHandlerParameter, connection, sourceFilename, destinationFilename) == false)\n                goto exit_access_denied;\n\n        /*  check if destination file already exists. If exists return error message */\n\n#if (CONFIG_SET_FILESTORE_BASEPATH_AT_RUNTIME == 1)\n        char extendedFileName[512];\n        mmsMsg_createExtendedFilename(MmsServerConnection_getFilesystemBasepath(connection), 512,\n                extendedFileName, destinationFilename);\n\n#else\n        char extendedFileName[sizeof(CONFIG_VIRTUAL_FILESTORE_BASEPATH) + 256];\n\n        mmsMsg_createExtendedFilename(MmsServerConnection_getFilesystemBasepath(connection),\n                sizeof(CONFIG_VIRTUAL_FILESTORE_BASEPATH) + 256,\n                extendedFileName, destinationFilename);\n#endif\n\n        if (FileSystem_getFileInfo(extendedFileName, NULL, NULL)) {\n            if (DEBUG_MMS_SERVER)\n                printf(\"MMS_SERVER: obtainFile - file already exists on server\\n\");\n            goto exit_file_already_exists;\n        }\n\n        if (DEBUG_MMS_SERVER)\n            printf(\"MMS_SERVER: Start download file %s from client to local file %s...\\n\", sourceFilename, destinationFilename);\n\n        MmsObtainFileTask task = MmsServer_getObtainFileTask(connection->server);\n\n        if (task != NULL) {\n\n            FileHandle fileHandle = openFile(MmsServerConnection_getFilesystemBasepath(connection),\n                    destinationFilename, true);\n\n            task->connection = connection;\n            task->obtainFileRequestInvokeId = invokeId;\n\n            if (fileHandle == NULL) {\n                task->state = MMS_FILE_UPLOAD_STATE_SEND_OBTAIN_FILE_ERROR_DESTINATION;\n            }\n            else {\n                /* send file open request */\n                task->lastRequestInvokeId = MmsServerConnection_getNextRequestInvokeId(connection);\n                task->fileHandle = fileHandle;\n\n                StringUtils_copyStringMax(task->destinationFilename, 256, destinationFilename);\n\n                ByteBuffer* request = MmsServer_reserveTransmitBuffer(connection->server);\n\n                mmsClient_createFileOpenRequest(task->lastRequestInvokeId, request, sourceFilename, 0);\n\n                IsoConnection_sendMessage(task->connection->isoConnection, request);\n\n                MmsServer_releaseTransmitBuffer(connection->server);\n\n                task->nextTimeout = Hal_getTimeInMs() + 2000; /* timeout 2000 ms */\n\n                task->state = MMS_FILE_UPLOAD_STATE_FILE_OPEN_SENT;\n            }\n\n#if (CONFIG_MMS_THREADLESS_STACK != 1)\n            Semaphore_post(task->taskLock);\n#endif\n        }\n        else\n            goto exit_unavailable;\n    }\n    else\n        goto exit_invalid_parameter;\n\n    return;\n\nexit_invalid_parameter:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_REQUEST_INVALID_ARGUMENT, response);\n    return;\n\nexit_access_denied:\n    createServiceErrorObtainFileError(invokeId, response, MMS_ERROR_FILE_FILE_ACCESS_DENIED, 1);\n    return;\n\nexit_file_already_exists:\n    createServiceErrorObtainFileError(invokeId, response, MMS_ERROR_FILE_DUPLICATE_FILENAME, 1);\n    return;\n\nexit_unavailable:\n    mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_ACCESS_TEMPORARILY_UNAVAILABLE);\n    return;\n\nexit_reject_invalid_pdu:\n    mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n}\n\n#endif /* (MMS_OBTAIN_FILE_SERVICE == 1) */\n\nvoid\nmmsMsg_createFileReadResponse(int maxPduSize, uint32_t invokeId,\n        ByteBuffer* response,  MmsFileReadStateMachine* frsm)\n{\n     /* determine remaining bytes in file */\n     uint32_t bytesLeft = frsm->fileSize - frsm->readPosition;\n\n     uint32_t fileChunkSize = 0;\n\n     uint32_t maxFileChunkSize = maxPduSize - 20;\n\n     uint32_t fileReadResponseSize = 1; /* for tag */\n\n     bool moreFollows = true;\n\n     if (bytesLeft > maxFileChunkSize) {\n         fileChunkSize = maxFileChunkSize;\n     }\n     else {\n         fileChunkSize = bytesLeft;\n         moreFollows = false;\n         fileReadResponseSize += 3; /* for moreFollows */\n     }\n\n     fileReadResponseSize += fileChunkSize;\n     fileReadResponseSize += BerEncoder_determineLengthSize(fileChunkSize);\n\n     frsm->readPosition += fileChunkSize;\n\n     uint32_t invokeIdSize = BerEncoder_UInt32determineEncodedSize(invokeId) + 2;\n\n     uint32_t confirmedResponsePDUSize = invokeIdSize + 2 + BerEncoder_determineLengthSize(fileReadResponseSize)\n                + fileReadResponseSize;\n\n     uint8_t* buffer = response->buffer;\n\n     int bufPos = 0;\n\n     bufPos = BerEncoder_encodeTL(0xa1, confirmedResponsePDUSize, buffer, bufPos);\n\n     bufPos = BerEncoder_encodeTL(0x02, invokeIdSize - 2, buffer, bufPos);\n     bufPos = BerEncoder_encodeUInt32(invokeId, buffer, bufPos);\n\n     buffer[bufPos++] = 0xbf;\n     bufPos = BerEncoder_encodeTL(0x49, fileReadResponseSize, buffer, bufPos);\n\n     bufPos = BerEncoder_encodeTL(0x80, fileChunkSize, buffer, bufPos);\n     FileSystem_readFile(frsm->fileHandle, buffer + bufPos, fileChunkSize);\n     bufPos += fileChunkSize;\n\n     if (!moreFollows)\n         bufPos = BerEncoder_encodeBoolean(0x81, false, buffer, bufPos);\n\n     response->size = bufPos;\n}\n\nvoid\nmmsServer_handleFileReadRequest(\n    MmsServerConnection connection,\n    uint8_t* buffer, int bufPos, int maxBufPos,\n    uint32_t invokeId,\n    ByteBuffer* response)\n{\n    int32_t frsmId = BerDecoder_decodeInt32(buffer, maxBufPos - bufPos, bufPos);\n\n    if (DEBUG_MMS_SERVER)\n        printf(\"MMS_SERVER: mmsServer_handleFileReadRequest read request for frsmId: %i\\n\", frsmId);\n\n    MmsFileReadStateMachine* frsm = getFrsm(connection, frsmId);\n\n    if (frsm != NULL)\n        mmsMsg_createFileReadResponse(connection->maxPduSize, invokeId, response, frsm);\n    else\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_OTHER);\n}\n\nvoid\nmmsMsg_createFileCloseResponse(uint32_t invokeId, ByteBuffer* response)\n{\n    createNullResponseExtendedTag(invokeId, response, 0x4a);\n}\n\nvoid\nmmsServer_handleFileCloseRequest(\n    MmsServerConnection connection,\n    uint8_t* buffer, int bufPos, int maxBufPos,\n    uint32_t invokeId,\n    ByteBuffer* response)\n{\n    int32_t frsmId = BerDecoder_decodeInt32(buffer, maxBufPos - bufPos, bufPos);\n\n    MmsFileReadStateMachine* frsm = getFrsm(connection, frsmId);\n\n    if (frsm) {\n        FileSystem_closeFile(frsm->fileHandle);\n        frsm->fileHandle = NULL;\n        frsm->frsmId = 0;\n\n        mmsMsg_createFileCloseResponse(invokeId, response);\n    }\n    else {\n        if (DEBUG_MMS_SERVER)\n            printf(\"MMS_SERVER: Unused file ID %i\\n\", frsmId);\n\n        mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_OTHER);\n    }\n}\n\n\n\nstatic int /* TODO remove redundancy - same as in client code! */\nencodeFileSpecification(uint8_t tag, char* fileSpecification, uint8_t* buffer, int bufPos)\n{\n    uint32_t fileNameStringSize = strlen(fileSpecification);\n    uint32_t fileNameSeqSize = 1 + BerEncoder_determineLengthSize(fileNameStringSize) + fileNameStringSize;\n\n    if (buffer != NULL) {\n\n        bufPos = BerEncoder_encodeTL(tag, fileNameSeqSize, buffer, bufPos);\n        bufPos = BerEncoder_encodeOctetString(0x19, (uint8_t*) fileSpecification, fileNameStringSize, buffer, bufPos);\n\n        return bufPos;\n    }\n    else {\n        return fileNameSeqSize + 1 + BerEncoder_determineLengthSize(fileNameSeqSize);\n    }\n}\n\nstatic int\naddFileEntriesToResponse(const char* basepath, uint8_t* buffer, int bufPos, int maxBufSize, char* directoryName, char** continueAfterFileName, bool* moreFollows)\n{\n\tint directoryNameLength = strlen(directoryName);\n\n    DirectoryHandle directory = openDirectory(basepath, directoryName);\n\n    if (directory != NULL) {\n\n        bool isDirectory;\n        char* fileName = FileSystem_readDirectory(directory, &isDirectory);\n\n        while (fileName != NULL) {\n        \tdirectoryName[directoryNameLength] = 0;\n\n        \tif (directoryNameLength > 0) {\n        \t\tif (directoryName[directoryNameLength - 1] != '/')\n        \t\t    StringUtils_appendString(directoryName, 256, \"/\");\n        \t}\n\n        \tStringUtils_appendString(directoryName, 256, fileName);\n\n            bufPos = addFileEntriesToResponse(basepath, buffer, bufPos, maxBufSize, directoryName, continueAfterFileName, moreFollows);\n\n            if (*moreFollows == true)\n                break;\n\n            fileName = FileSystem_readDirectory(directory, &isDirectory);\n        }\n\n        FileSystem_closeDirectory(directory);\n    }\n    else {\n\n        if (*continueAfterFileName != NULL) {\n            if (strcmp(*continueAfterFileName, directoryName) == 0) {\n                *continueAfterFileName = NULL;\n            }\n        }\n        else {\n            uint64_t msTime;\n\n            uint32_t fileSize;\n\n            if (getFileInfo(basepath, directoryName, &fileSize, &msTime)) {\n                char gtString[30];\n\n                Conversions_msTimeToGeneralizedTime(msTime, (uint8_t*) gtString);\n\n                int fileAttributesSize = encodeFileAttributes(0xa1, fileSize, gtString, NULL, 0);\n\n                int filenameSize = encodeFileSpecification(0xa0, directoryName, NULL, 0);\n\n                int dirEntrySize = 2 + fileAttributesSize + filenameSize;\n\n                int overallEntrySize = 1 + BerEncoder_determineLengthSize(dirEntrySize) + dirEntrySize;\n\n                int bufferSpaceLeft = maxBufSize - bufPos;\n\n                if (overallEntrySize > bufferSpaceLeft) {\n                    *moreFollows = true;\n                }\n                else {\n\n                    bufPos = BerEncoder_encodeTL(0x30, dirEntrySize, buffer, bufPos); /* SEQUENCE (DirectoryEntry) */\n                    bufPos = encodeFileSpecification(0xa0, directoryName, buffer, bufPos); /* fileName */\n                    bufPos = encodeFileAttributes(0xa1, fileSize, gtString, buffer, bufPos); /* file attributes */\n                }\n            }\n            else\n                bufPos = -1;\n\n        }\n\n    }\n\n    directoryName[directoryNameLength] = 0;\n\n    return bufPos;\n}\n\nstatic void\ncreateFileDirectoryResponse(const char* basepath, uint32_t invokeId, ByteBuffer* response, int maxPduSize, char* directoryName, char* continueAfterFileName)\n{\n    int maxSize = maxPduSize - 3; /* reserve space for moreFollows */\n    uint8_t* buffer = response->buffer;\n\n    bool moreFollows = false;\n\n    int tempStartPos = 30; /* estimated header part with safety margin */\n    int tempCurPos = tempStartPos;\n    int tempEncoded = 0;\n\n    if (continueAfterFileName != NULL) {\n        if (strlen(continueAfterFileName) == 0)\n            continueAfterFileName = NULL;\n    }\n\n    if ((directoryName && mmsMsg_isFilenameSave(directoryName) == false) || \n        (continueAfterFileName && mmsMsg_isFilenameSave(continueAfterFileName) == false))\n    {\n        if (DEBUG_MMS_SERVER)\n            printf(\"MMS_SERVER: remote provided unsave filename -> rejected\\n\");\n\n       mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n\n       return;\n    }\n\n    tempCurPos = addFileEntriesToResponse(basepath, buffer, tempCurPos, maxSize, directoryName, &continueAfterFileName, &moreFollows);\n\n\tif (tempCurPos < 0) {\n\n       if (DEBUG_MMS_SERVER)\n            printf(\"MMS_SERVER: Error opening directory!\\n\");\n\n       mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n\n       return;\n    }\n\n    tempEncoded = tempCurPos - tempStartPos;\n\n    uint32_t invokeIdSize = BerEncoder_UInt32determineEncodedSize((uint32_t) invokeId) + 2;\n\n    uint32_t listOfDirectoryEntrySeqSize = tempEncoded;\n\n    uint32_t listOfDirectoryEntrySize = 1 + BerEncoder_determineLengthSize(tempEncoded) + tempEncoded;\n\n    uint32_t fileDirectoryResponseSize = 1 + BerEncoder_determineLengthSize(listOfDirectoryEntrySize)\n            + listOfDirectoryEntrySize;\n\n    if (moreFollows)\n        fileDirectoryResponseSize += 3; /* for moreFollows */\n\n    uint32_t confirmedResponsePDUSize = invokeIdSize + 2 + BerEncoder_determineLengthSize(fileDirectoryResponseSize)\n            + fileDirectoryResponseSize;\n\n    int bufPos = 0;\n\n    bufPos = BerEncoder_encodeTL(0xa1, confirmedResponsePDUSize, buffer, bufPos);\n\n    bufPos = BerEncoder_encodeTL(0x02, invokeIdSize - 2, buffer, bufPos);\n    bufPos = BerEncoder_encodeUInt32(invokeId, buffer, bufPos);\n\n    buffer[bufPos++] = 0xbf;\n    bufPos = BerEncoder_encodeTL(0x4d, fileDirectoryResponseSize, buffer, bufPos);\n    bufPos = BerEncoder_encodeTL(0xa0, listOfDirectoryEntrySize, buffer, bufPos);\n\n    bufPos = BerEncoder_encodeTL(0x30, listOfDirectoryEntrySeqSize, buffer, bufPos); /* SEQUENCE OF (DirectoryEntry) */\n\n    /* memmove is required instead of memcpy since memory areas overlap */\n    memmove(buffer + bufPos, buffer + tempStartPos, tempEncoded);\n\n    bufPos += tempEncoded;\n\n    if (moreFollows)\n        bufPos = BerEncoder_encodeBoolean(0x81, moreFollows, buffer, bufPos);\n\n    response->size = bufPos;\n}\n\nvoid\nmmsServer_handleFileRenameRequest(\n        MmsServerConnection connection,\n        uint8_t* buffer, int bufPos, int maxBufPos,\n        uint32_t invokeId,\n        ByteBuffer* response)\n{\n    char currentFileName[256] = \"\";\n    char newFileName[256] = \"\";\n\n    while (bufPos < maxBufPos) {\n        uint8_t tag = buffer[bufPos++];\n        int length;\n\n        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n\n        if (bufPos < 0) {\n            mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n            return;\n        }\n\n        switch(tag) {\n        case 0xa0: /* currentFilename */\n            if (!mmsMsg_parseFileName(currentFileName, buffer, &bufPos, bufPos + length, invokeId, response))\n                return;\n\n            if (DEBUG_MMS_SERVER)\n                printf(\"MMS_SERVER: currentFileName: (%s)\\n\", currentFileName);\n\n            break;\n\n        case 0xa1: /* newFilename */\n            if (!mmsMsg_parseFileName(newFileName, buffer, &bufPos, bufPos + length, invokeId, response))\n                return;\n\n            if (DEBUG_MMS_SERVER)\n                printf(\"MMS_SERVER: newFileName: (%s)\\n\", newFileName);\n\n            break;\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n        default: /* ignore unknown tag */\n            if (DEBUG_MMS_SERVER)\n                printf(\"MMS_SERVER: unknown tag: (%02x)\\n\", tag);\n\n            bufPos += length;\n            break;\n        }\n    }\n\n    if ((strlen(currentFileName) != 0) && (strlen(newFileName) != 0)) {\n\n        if ((mmsMsg_isFilenameSave(currentFileName) == false) || (mmsMsg_isFilenameSave(newFileName) == false))\n        {\n            if (DEBUG_MMS_SERVER)\n                printf(\"MMS_SERVER: remote provided unsave filename -> rejected\\n\");\n\n            mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_FILE_NON_EXISTENT);\n\n            return;\n        }\n\n        /* Call user to check if access is allowed */\n        if (connection->server->fileAccessHandler != NULL) {\n            MmsError access = connection->server->fileAccessHandler(connection->server->fileAccessHandlerParameter,\n                                connection, MMS_FILE_ACCESS_TYPE_RENAME, currentFileName, newFileName);\n\n            if (access != MMS_ERROR_NONE) {\n                mmsMsg_createServiceErrorPdu(invokeId, response, access);\n                return;\n            }\n        }\n\n        if (renameFile(MmsServerConnection_getFilesystemBasepath(connection), currentFileName, newFileName)){\n            /* send positive response */\n            createNullResponseExtendedTag(invokeId, response, 0x4b);\n        }\n        else\n        {\n            if (DEBUG_MMS_SERVER)\n                printf(\"MMS_SERVER: rename file failed!\\n\");\n\n            mmsMsg_createServiceErrorPdu(invokeId, response, MMS_ERROR_FILE_OTHER);\n        }\n    }\n    else\n        mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n\n}\n\nvoid\nmmsServer_handleFileDirectoryRequest(\n    MmsServerConnection connection,\n    uint8_t* buffer, int bufPos, int maxBufPos,\n    uint32_t invokeId,\n    ByteBuffer* response)\n{\n    if (DEBUG_MMS_SERVER)\n        printf(\"MMS_SERVER: handleFileDirectoryRequest bufPos:%i, maxBufPus:%i\\n\", bufPos, maxBufPos);\n\n    char filename[256] = \"\";\n\n    char continueAfterFileName[256];\n\n    char* continueAfter = NULL;\n\n    while (bufPos < maxBufPos) {\n        uint8_t tag = buffer[bufPos++];\n        int length;\n\n        bufPos = BerDecoder_decodeLength(buffer, &length, bufPos, maxBufPos);\n\n        if (bufPos < 0) {\n            mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n            return;\n        }\n\n        switch(tag) {\n        case 0xa0: /* filename */\n            if (!mmsMsg_parseFileName(filename, buffer, &bufPos, bufPos + length, invokeId, response))\n                return;\n\n            /* check for wildcard character(*) */\n            if ((strcmp(filename, \"*\") == 0) || (strcmp(filename, \"/\") == 0) || (strcmp(filename, \"\\\\\") == 0))\n            \tfilename[0] = 0;\n\n            break;\n\n        case 0xa1: /* continue-after */\n            if (!mmsMsg_parseFileName(continueAfterFileName, buffer, &bufPos, bufPos + length, invokeId, response))\n                return;\n\n            continueAfter = continueAfterFileName;\n\n            break;\n\n        case 0x00: /* indefinite length end tag -> ignore */\n            break;\n\n        default: /* unrecognized parameter */\n            if (DEBUG_MMS_SERVER)\n                printf(\"MMS_SERVER: handleFileDirectoryRequest: unrecognized parameter\\n\");\n            mmsMsg_createMmsRejectPdu(&invokeId, MMS_ERROR_REJECT_INVALID_PDU, response);\n            return;\n        }\n\n\n    }\n\n    int maxPduSize = connection->maxPduSize;\n\n    /* Call user to check if access is allowed */\n    if (connection->server->fileAccessHandler != NULL) {\n        MmsError access = connection->server->fileAccessHandler(connection->server->fileAccessHandlerParameter,\n                            connection, MMS_FILE_ACCESS_TYPE_READ_DIRECTORY, filename, continueAfter);\n\n        if (access != MMS_ERROR_NONE) {\n            mmsMsg_createServiceErrorPdu(invokeId, response, access);\n            return;\n        }\n    }\n\n    createFileDirectoryResponse(MmsServerConnection_getFilesystemBasepath(connection),\n            invokeId, response, maxPduSize, filename, continueAfter);\n}\n\n#endif /* MMS_FILE_SERVICE == 1 */\n\n"], "filenames": ["hal/filesystem/linux/file_provider_linux.c", "src/mms/inc_private/mms_common_internal.h", "src/mms/iso_mms/client/mms_client_files.c", "src/mms/iso_mms/common/mms_common_msg.c", "src/mms/iso_mms/server/mms_file_service.c"], "buggy_code_start_loc": [39, 84, 74, 572, 238], "buggy_code_end_loc": [40, 84, 160, 624, 1130], "fixing_code_start_loc": [38, 85, 73, 573, 237], "fixing_code_end_loc": [38, 88, 169, 642, 1180], "type": "CWE-22", "message": "A vulnerability has been found in MZ Automation libiec61850 up to 1.4 and classified as critical. This vulnerability affects unknown code of the file src/mms/iso_mms/client/mms_client_files.c of the component MMS File Services. The manipulation of the argument filename leads to path traversal. Upgrading to version 1.5 is able to address this issue. The name of the patch is 10622ba36bb3910c151348f1569f039ecdd8786f. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-213556.", "other": {"cve": {"id": "CVE-2022-3976", "sourceIdentifier": "cna@vuldb.com", "published": "2022-11-13T14:15:10.400", "lastModified": "2022-11-18T21:05:19.780", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability has been found in MZ Automation libiec61850 up to 1.4 and classified as critical. This vulnerability affects unknown code of the file src/mms/iso_mms/client/mms_client_files.c of the component MMS File Services. The manipulation of the argument filename leads to path traversal. Upgrading to version 1.5 is able to address this issue. The name of the patch is 10622ba36bb3910c151348f1569f039ecdd8786f. It is recommended to upgrade the affected component. The identifier of this vulnerability is VDB-213556."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.4}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mz-automation:libiec61850:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.5", "matchCriteriaId": "34A877C3-A67B-4C50-A65C-B518156D30F0"}]}]}], "references": [{"url": "https://github.com/mz-automation/libiec61850", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/mz-automation/libiec61850/commit/10622ba36bb3910c151348f1569f039ecdd8786f", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.213556", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mz-automation/libiec61850/commit/10622ba36bb3910c151348f1569f039ecdd8786f"}}