{"buggy_code": ["/*\n *  Copyright (C) 2005-2018 Team Kodi\n *  This file is part of Kodi - https://kodi.tv\n *\n *  SPDX-License-Identifier: GPL-2.0-or-later\n *  See LICENSES/README.md for more information.\n */\n\n//--------------------------------------------------------------------------\n// Program to pull the EXIF information out of various types of digital\n// images and present it in a reasonably consistent way\n//\n// Original code pulled from 'jhead' by Matthias Wandel (http://www.sentex.net/~mwandel/) - jhead\n// Adapted for XBMC by DD.\n//--------------------------------------------------------------------------\n\n// Note: Jhead supports TAG_MAKER_NOTE exif field,\n//       but that is omitted for now - to make porting easier and addition smaller\n\n#include \"ExifParse.h\"\n\n#ifdef TARGET_WINDOWS\n#include <windows.h>\n#else\n#include <memory.h>\n#include <cstring>\n#endif\n\n#include <math.h>\n#include <stdio.h>\n\n#ifndef min\n#define min(a,b) (a)>(b)?(b):(a)\n#endif\n#ifndef max\n#define max(a,b) (a)<(b)?(b):(a)\n#endif\n\n\n// Prototypes for exif utility functions.\nstatic void ErrNonfatal(const char* const msg, int a1, int a2);\n\n#define DIR_ENTRY_ADDR(Start, Entry) ((Start)+2+12*(Entry))\n\n\n//--------------------------------------------------------------------------\n// Describes tag values\n#define TAG_DESCRIPTION        0x010E\n#define TAG_MAKE               0x010F\n#define TAG_MODEL              0x0110\n#define TAG_ORIENTATION        0x0112\n#define TAG_X_RESOLUTION       0x011A           // Not processed. Format rational64u (see http://search.cpan.org/src/EXIFTOOL/Image-ExifTool-6.76/html/TagNames/EXIF.html)\n#define TAG_Y_RESOLUTION       0x011B           // Not processed. Format rational64u\n#define TAG_RESOLUTION_UNIT    0x0128           // Not processed. Format int16u. Values: 1-none; 2-inches; 3-cm\n#define TAG_SOFTWARE           0x0131\n#define TAG_DATETIME           0x0132\n#define TAG_THUMBNAIL_OFFSET   0x0201\n#define TAG_THUMBNAIL_LENGTH   0x0202\n#define TAG_Y_CB_CR_POS        0x0213           // Not processed. Format int16u. Values: 1-Centered; 2-Co-sited\n#define TAG_EXPOSURETIME       0x829A\n#define TAG_FNUMBER            0x829D\n#define TAG_EXIF_OFFSET        0x8769\n#define TAG_EXPOSURE_PROGRAM   0x8822\n#define TAG_GPSINFO            0x8825\n#define TAG_ISO_EQUIVALENT     0x8827\n#define TAG_EXIF_VERSION       0x9000           // Not processed.\n#define TAG_COMPONENT_CFG      0x9101           // Not processed.\n#define TAG_DATETIME_ORIGINAL  0x9003\n#define TAG_DATETIME_DIGITIZED 0x9004\n#define TAG_SHUTTERSPEED       0x9201\n#define TAG_APERTURE           0x9202\n#define TAG_EXPOSURE_BIAS      0x9204\n#define TAG_MAXAPERTURE        0x9205\n#define TAG_SUBJECT_DISTANCE   0x9206\n#define TAG_METERING_MODE      0x9207\n#define TAG_LIGHT_SOURCE       0x9208\n#define TAG_FLASH              0x9209\n#define TAG_FOCALLENGTH        0x920A\n#define TAG_MAKER_NOTE         0x927C           // Not processed yet. Maybe in the future.\n#define TAG_USERCOMMENT        0x9286\n#define TAG_XP_COMMENT         0x9c9c\n#define TAG_FLASHPIX_VERSION   0xA000           // Not processed.\n#define TAG_COLOUR_SPACE       0xA001           // Not processed. Format int16u. Values: 1-RGB; 2-Adobe RGB 65535-Uncalibrated\n#define TAG_EXIF_IMAGEWIDTH    0xa002\n#define TAG_EXIF_IMAGELENGTH   0xa003\n#define TAG_INTEROP_OFFSET     0xa005\n#define TAG_FOCALPLANEXRES     0xa20E\n#define TAG_FOCALPLANEUNITS    0xa210\n#define TAG_EXPOSURE_INDEX     0xa215\n#define TAG_EXPOSURE_MODE      0xa402\n#define TAG_WHITEBALANCE       0xa403\n#define TAG_DIGITALZOOMRATIO   0xA404\n#define TAG_FOCALLENGTH_35MM   0xa405\n\n#define TAG_GPS_LAT_REF        1\n#define TAG_GPS_LAT            2\n#define TAG_GPS_LONG_REF       3\n#define TAG_GPS_LONG           4\n#define TAG_GPS_ALT_REF        5\n#define TAG_GPS_ALT            6\n\n//--------------------------------------------------------------------------\n// Exif format descriptor stuff\nnamespace\n{\nconstexpr auto FMT_BYTE = 1;\nconstexpr auto FMT_USHORT = 2;\nconstexpr auto FMT_ULONG = 3;\nconstexpr auto FMT_URATIONAL = 4;\nconstexpr auto FMT_SBYTE = 5;\nconstexpr auto FMT_SSHORT = 6;\nconstexpr auto FMT_SLONG = 7;\nconstexpr auto FMT_SRATIONAL = 8;\nconstexpr auto FMT_SINGLE = 9;\nconstexpr auto FMT_DOUBLE = 10;\n// NOTE: Remember to change NUM_FORMATS if you define a new format\nconstexpr auto NUM_FORMATS = 10;\n\nconst unsigned int BytesPerFormat[NUM_FORMATS] = {1, 2, 4, 8, 1, 2, 4, 8, 4, 8};\n} // namespace\n\n//--------------------------------------------------------------------------\n// Internationalisation string IDs. The enum order must match that in the\n// language file (e.g. 'language/resource.language.en_gb/strings.po', and EXIF_PARSE_STRING_ID_BASE\n// must match the ID of the first Exif string in that file.\n#define EXIF_PARSE_STRING_ID_BASE       21800\nenum {\n// Distance\n  ExifStrDistanceInfinite = EXIF_PARSE_STRING_ID_BASE,\n// Whitebalance et.al.\n  ExifStrManual,\n  ExifStrAuto,\n// Flash modes\n  ExifStrYes,\n  ExifStrNo,\n  ExifStrFlashNoStrobe,\n  ExifStrFlashStrobe,\n  ExifStrFlashManual,\n  ExifStrFlashManualNoReturn,\n  ExifStrFlashManualReturn,\n  ExifStrFlashAuto,\n  ExifStrFlashAutoNoReturn,\n  ExifStrFlashAutoReturn,\n  ExifStrFlashRedEye,\n  ExifStrFlashRedEyeNoReturn,\n  ExifStrFlashRedEyeReturn,\n  ExifStrFlashManualRedEye,\n  ExifStrFlashManualRedEyeNoReturn,\n  ExifStrFlashManualRedEyeReturn,\n  ExifStrFlashAutoRedEye,\n  ExifStrFlashAutoRedEyeNoReturn,\n  ExifStrFlashAutoRedEyeReturn,\n// Light sources\n  ExifStrDaylight,\n  ExifStrFluorescent,\n  ExifStrIncandescent,\n  ExifStrFlash,\n  ExifStrFineWeather,\n  ExifStrShade,\n// Metering Mode\n  ExifStrMeteringCenter,\n  ExifStrMeteringSpot,\n  ExifStrMeteringMatrix,\n// Exposure Program\n  ExifStrExposureProgram,\n  ExifStrExposureAperture,\n  ExifStrExposureShutter,\n  ExifStrExposureCreative,\n  ExifStrExposureAction,\n  ExifStrExposurePortrait,\n  ExifStrExposureLandscape,\n// Exposure mode\n  ExifStrExposureModeAuto,\n// ISO equivalent\n  ExifStrIsoEquivalent,\n// GPS latitude, longitude, altitude\n  ExifStrGpsLatitude,\n  ExifStrGpsLongitude,\n  ExifStrGpsAltitude,\n};\n\n\n\n\n//--------------------------------------------------------------------------\n// Report non fatal errors.  Now that microsoft.net modifies exif headers,\n// there's corrupted ones, and there could be more in the future.\n//--------------------------------------------------------------------------\nstatic void ErrNonfatal(const char* const msg, int a1, int a2)\n{\n  printf(\"ExifParse - Nonfatal Error : %s %d %d\", msg, a1, a2);\n}\n\n//--------------------------------------------------------------------------\n// Convert a 16 bit unsigned value from file's native byte order\n//--------------------------------------------------------------------------\nint CExifParse::Get16(const void* const Short, const bool motorolaOrder)\n{\n    if (motorolaOrder) {\n        return (((const unsigned char *)Short)[0] << 8) | ((const unsigned char *)Short)[1];\n    } else {\n        return (((const unsigned char *)Short)[1] << 8) | ((const unsigned char *)Short)[0];\n    }\n}\n\n//--------------------------------------------------------------------------\n// Convert a 32 bit signed value from file's native byte order\n//--------------------------------------------------------------------------\nint CExifParse::Get32(const void* const Long, const bool motorolaOrder)\n{\n    if (motorolaOrder) {\n        return  (((const char *)Long)[0] << 24) | (((const unsigned char *)Long)[1] << 16)\n          | (((const unsigned char *)Long)[2] << 8 ) | (((const unsigned char *)Long)[3] << 0 );\n    } else {\n        return  (((const char *)Long)[3] << 24) | (((const unsigned char *)Long)[2] << 16)\n          | (((const unsigned char *)Long)[1] << 8 ) | (((const unsigned char *)Long)[0] << 0 );\n    }\n}\n\n//--------------------------------------------------------------------------\n// It appears that CStdString constructor replaces \"\\n\" with \"\\r\\n\" which results\n// in \"\\r\\r\\n\" if there already is \"\\r\\n\", which in turn results in corrupted\n// display. So this is an attempt to undo effects of a smart constructor. Also,\n// replaces all nonprintable characters with \".\"\n//--------------------------------------------------------------------------\n/*void CExifParse::FixComment(CStdString& comment)\n{\n  comment.Replace(\"\\r\\r\\n\", \"\\r\\n\");\n  for (unsigned int i=0; i<comment.length(); i++)\n  {\n    if ((comment[i] < 32) && (comment[i] != '\\n') && (comment[i] != '\\t') && (comment[i] != '\\r'))\n    {\n      comment[i] = '.';\n    }\n  }\n}*/\n\n//--------------------------------------------------------------------------\n// Evaluate number, be it int, rational, or float from directory.\n//--------------------------------------------------------------------------\ndouble CExifParse::ConvertAnyFormat(const void* const ValuePtr, int Format)\n{\n  double Value;\n  Value = 0;\n\n  switch(Format)\n  {\n    case FMT_SBYTE:     Value = *(const   signed char*)ValuePtr;          break;\n    case FMT_BYTE:      Value = *(const unsigned char*)ValuePtr;          break;\n\n    case FMT_USHORT:    Value = Get16(ValuePtr, m_MotorolaOrder);   break;\n    case FMT_ULONG:     Value = (unsigned)Get32(ValuePtr, m_MotorolaOrder);   break;\n\n    case FMT_URATIONAL:\n    case FMT_SRATIONAL:\n    {\n      int Num,Den;\n      Num = Get32(ValuePtr, m_MotorolaOrder);\n      Den = Get32(4+(const char *)ValuePtr, m_MotorolaOrder);\n\n      if (Den == 0)    Value = 0;\n      else             Value = (double)Num/Den;\n    }\n    break;\n\n    case FMT_SSHORT:    Value = (signed short)Get16(ValuePtr, m_MotorolaOrder);    break;\n    case FMT_SLONG:     Value = Get32(ValuePtr, m_MotorolaOrder);                  break;\n\n    // Not sure if this is correct (never seen float used in Exif format)\n    case FMT_SINGLE:    Value = (double)*(const float*)ValuePtr;          break;\n    case FMT_DOUBLE:    Value = *(const double*)ValuePtr;                 break;\n\n    default:\n      ErrNonfatal(\"Illegal format code %d\",Format,0);\n  }\n  return Value;\n}\n\n//--------------------------------------------------------------------------\n// Exif date tag is stored as a fixed format string \"YYYY:MM:DD HH:MM:SS\".\n// If date is not set, then the string is filled with blanks and colons:\n// \"    :  :     :  :  \". We want this string localised.\n//--------------------------------------------------------------------------\n/*void CExifParse::LocaliseDate (void)\n{\n    if (m_ExifInfo[SLIDESHOW_EXIF_DATE_TIME][0] != ' ')\n    {\n        int year  = atoi(m_ExifInfo[SLIDESHOW_EXIF_DATE_TIME].substr(0, 4).c_str());\n        int month = atoi(m_ExifInfo[SLIDESHOW_EXIF_DATE_TIME].substr(5, 2).c_str());\n        int day   = atoi(m_ExifInfo[SLIDESHOW_EXIF_DATE_TIME].substr(8, 2).c_str());\n        int hour  = atoi(m_ExifInfo[SLIDESHOW_EXIF_DATE_TIME].substr(11,2).c_str());\n        int min   = atoi(m_ExifInfo[SLIDESHOW_EXIF_DATE_TIME].substr(14,2).c_str());\n        int sec   = atoi(m_ExifInfo[SLIDESHOW_EXIF_DATE_TIME].substr(17,2).c_str());\n        CDateTime date(year, month, day, hour, min, sec);\n        m_ExifInfo[SLIDESHOW_EXIF_DATE_TIME] = date.GetAsLocalizedDateTime();\n    }\n}*/\n\n\n//--------------------------------------------------------------------------\n// Convert exposure time into a human readable format\n//--------------------------------------------------------------------------\n/*void CExifParse::GetExposureTime(const float exposureTime, CStdString& outStr)\n{\n  if (exposureTime)\n  {\n    if (exposureTime < 0.010)   outStr.Format(\"%6.4fs \", exposureTime);\n    else                        outStr.Format(\"%5.3fs \", exposureTime);\n    if (exposureTime <= 0.5)    outStr.Format(\"%s (1/%d)\", outStr, (int)(0.5 + 1/exposureTime));\n  }\n}*/\n\n//--------------------------------------------------------------------------\n// Process one of the nested EXIF directories.\n//--------------------------------------------------------------------------\nvoid CExifParse::ProcessDir(const unsigned char* const DirStart,\n                            const unsigned char* const OffsetBase,\n                            const unsigned ExifLength,\n                            int NestingLevel)\n{\n  if (NestingLevel > 4)\n  {\n    ErrNonfatal(\"Maximum directory nesting exceeded (corrupt exif header)\", 0,0);\n    return;\n  }\n\n  char IndentString[25];\n  memset(IndentString, ' ', 25);\n  IndentString[NestingLevel * 4] = '\\0';\n\n\n  int NumDirEntries = Get16((const void*)DirStart, m_MotorolaOrder);\n\n  const unsigned char* const DirEnd = DIR_ENTRY_ADDR(DirStart, NumDirEntries);\n  if (DirEnd+4 > (OffsetBase+ExifLength))\n  {\n    if (DirEnd+2 == OffsetBase+ExifLength || DirEnd == OffsetBase+ExifLength)\n    {\n      // Version 1.3 of jhead would truncate a bit too much.\n      // This also caught later on as well.\n    }\n    else\n    {\n      ErrNonfatal(\"Illegally sized directory\", 0,0);\n      return;\n    }\n  }\n\n  for (int de=0;de<NumDirEntries;de++)\n  {\n    int Tag, Format, Components;\n    unsigned char* ValuePtr;\n    int ByteCount;\n    const unsigned char* const DirEntry = DIR_ENTRY_ADDR(DirStart, de);\n\n    Tag = Get16(DirEntry, m_MotorolaOrder);\n    Format = Get16(DirEntry+2, m_MotorolaOrder);\n    Components = Get32(DirEntry+4, m_MotorolaOrder);\n\n    if (Format <= 0 || Format > NUM_FORMATS)\n    {\n      ErrNonfatal(\"Illegal number format %d for tag %04x\", Format, Tag);\n      continue;\n    }\n\n    if ((unsigned)Components > 0x10000)\n    {\n      ErrNonfatal(\"Illegal number of components %d for tag %04x\", Components, Tag);\n      continue;\n    }\n\n    ByteCount = Components * BytesPerFormat[Format - 1];\n\n    if (ByteCount > 4)\n    {\n      unsigned OffsetVal;\n      OffsetVal = (unsigned)Get32(DirEntry+8, m_MotorolaOrder);\n      // If its bigger than 4 bytes, the dir entry contains an offset.\n      if (OffsetVal+ByteCount > ExifLength)\n      {\n        // Bogus pointer offset and / or bytecount value\n        ErrNonfatal(\"Illegal value pointer for tag %04x\", Tag,0);\n        continue;\n      }\n      ValuePtr = (unsigned char*)(const_cast<unsigned char*>(OffsetBase)+OffsetVal);\n\n      if (OffsetVal > m_LargestExifOffset)\n      {\n        m_LargestExifOffset = OffsetVal;\n      }\n\n    }\n    else {\n      // 4 bytes or less and value is in the dir entry itself\n      ValuePtr = (unsigned char*)(const_cast<unsigned char*>(DirEntry)+8);\n    }\n\n\n    // Extract useful components of tag\n    switch(Tag)\n    {\n      case TAG_DESCRIPTION:\n      {\n        int length = max(ByteCount, 0);\n        length = min(length, MAX_COMMENT);\n        strncpy(m_ExifInfo->Description, (char *)ValuePtr, length);\n        m_ExifInfo->Description[length] = '\\0';\n        break;\n      }\n      case TAG_MAKE:\n      {\n        int space = sizeof(m_ExifInfo->CameraMake);\n        if (space > 0)\n        {\n          strncpy(m_ExifInfo->CameraMake, (char *)ValuePtr, space - 1);\n          m_ExifInfo->CameraMake[space - 1] = '\\0';\n        }\n        break;\n      }\n      case TAG_MODEL:\n      {\n        int space = sizeof(m_ExifInfo->CameraModel);\n        if (space > 0)\n        {\n          strncpy(m_ExifInfo->CameraModel, (char *)ValuePtr, space - 1);\n          m_ExifInfo->CameraModel[space - 1] = '\\0';\n        }\n        break;\n      }\n//      case TAG_SOFTWARE:          strncpy(m_ExifInfo->Software, ValuePtr, 5);    break;\n      case TAG_FOCALPLANEXRES:    m_FocalPlaneXRes  = ConvertAnyFormat(ValuePtr, Format);               break;\n      case TAG_THUMBNAIL_OFFSET:  m_ExifInfo->ThumbnailOffset = (unsigned)ConvertAnyFormat(ValuePtr, Format);     break;\n      case TAG_THUMBNAIL_LENGTH:  m_ExifInfo->ThumbnailSize   = (unsigned)ConvertAnyFormat(ValuePtr, Format);     break;\n\n      case TAG_MAKER_NOTE:\n        continue;\n      break;\n\n      case TAG_DATETIME_ORIGINAL:\n      {\n\n        int space = sizeof(m_ExifInfo->DateTime);\n        if (space > 0)\n        {\n          strncpy(m_ExifInfo->DateTime, (char *)ValuePtr, space - 1);\n          m_ExifInfo->DateTime[space - 1] = '\\0';\n          // If we get a DATETIME_ORIGINAL, we use that one.\n          m_DateFound = true;\n        }\n        break;\n      }\n      case TAG_DATETIME_DIGITIZED:\n      case TAG_DATETIME:\n      {\n        if (!m_DateFound)\n        {\n          // If we don't already have a DATETIME_ORIGINAL, use whatever\n          // time fields we may have.\n          int space = sizeof(m_ExifInfo->DateTime);\n          if (space > 0)\n          {\n            strncpy(m_ExifInfo->DateTime, (char *)ValuePtr, space - 1);\n            m_ExifInfo->DateTime[space - 1] = '\\0';\n          }\n        }\n        break;\n      }\n      case TAG_USERCOMMENT:\n      {\n        // The UserComment allows comments without the charset limitations of ImageDescription.\n        // Therefore the UserComment field is prefixed by a CharacterCode field (8 Byte):\n        //  - ASCII:         'ASCII\\0\\0\\0'\n        //  - Unicode:       'UNICODE\\0'\n        //  - JIS X208-1990: 'JIS\\0\\0\\0\\0\\0'\n        //  - Unknown:       '\\0\\0\\0\\0\\0\\0\\0\\0' (application specific)\n\n        m_ExifInfo->CommentsCharset = EXIF_COMMENT_CHARSET_UNKNOWN;\n\n        const int EXIF_COMMENT_CHARSET_LENGTH = 8;\n        if (ByteCount >= EXIF_COMMENT_CHARSET_LENGTH)\n        {\n          // As some implementations use spaces instead of \\0 for the padding,\n          // we're not so strict and check only the prefix.\n          if (memcmp(ValuePtr, \"ASCII\", 5) == 0)\n            m_ExifInfo->CommentsCharset = EXIF_COMMENT_CHARSET_ASCII;\n          else if (memcmp(ValuePtr, \"UNICODE\", 7) == 0)\n            m_ExifInfo->CommentsCharset = EXIF_COMMENT_CHARSET_UNICODE;\n          else if (memcmp(ValuePtr, \"JIS\", 3) == 0)\n            m_ExifInfo->CommentsCharset = EXIF_COMMENT_CHARSET_JIS;\n\n          int length = ByteCount - EXIF_COMMENT_CHARSET_LENGTH;\n          length = min(length, MAX_COMMENT);\n          memcpy(m_ExifInfo->Comments, ValuePtr + EXIF_COMMENT_CHARSET_LENGTH, length);\n          m_ExifInfo->Comments[length] = '\\0';\n//          FixComment(comment);                          // Ensure comment is printable\n        }\n      }\n      break;\n\n      case TAG_XP_COMMENT:\n      {\n        // The XP user comment field is always unicode (UCS-2) encoded\n        m_ExifInfo->XPCommentsCharset = EXIF_COMMENT_CHARSET_UNICODE;\n        size_t length = min(ByteCount, MAX_COMMENT);\n        memcpy(m_ExifInfo->XPComment, ValuePtr, length);\n        m_ExifInfo->XPComment[length] = '\\0';\n      }\n      break;\n\n      case TAG_FNUMBER:\n        // Simplest way of expressing aperture, so I trust it the most.\n        // (overwrite previously computd value if there is one)\n        m_ExifInfo->ApertureFNumber = (float)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_APERTURE:\n      case TAG_MAXAPERTURE:\n        // More relevant info always comes earlier, so only use this field if we don't\n        // have appropriate aperture information yet.\n        if (m_ExifInfo->ApertureFNumber == 0)\n        {\n          m_ExifInfo->ApertureFNumber = (float)exp(ConvertAnyFormat(ValuePtr, Format)*log(2.0)*0.5);\n        }\n      break;\n\n      case TAG_FOCALLENGTH:\n        // Nice digital cameras actually save the focal length as a function\n        // of how far they are zoomed in.\n        m_ExifInfo->FocalLength = (float)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_SUBJECT_DISTANCE:\n        // Inidcates the distacne the autofocus camera is focused to.\n        // Tends to be less accurate as distance increases.\n        {\n          float distance = (float)ConvertAnyFormat(ValuePtr, Format);\n          m_ExifInfo->Distance = distance;\n        }\n      break;\n\n      case TAG_EXPOSURETIME:\n        {\n        // Simplest way of expressing exposure time, so I trust it most.\n        // (overwrite previously computd value if there is one)\n        float expTime = (float)ConvertAnyFormat(ValuePtr, Format);\n        if (expTime)\n          m_ExifInfo->ExposureTime = expTime;\n        }\n      break;\n\n      case TAG_SHUTTERSPEED:\n        // More complicated way of expressing exposure time, so only use\n        // this value if we don't already have it from somewhere else.\n        if (m_ExifInfo->ExposureTime == 0)\n        {\n          m_ExifInfo->ExposureTime = (float)(1/exp(ConvertAnyFormat(ValuePtr, Format)*log(2.0)));\n        }\n      break;\n\n      case TAG_FLASH:\n        m_ExifInfo->FlashUsed = (int)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_ORIENTATION:\n        m_ExifInfo->Orientation = (int)ConvertAnyFormat(ValuePtr, Format);\n        if (m_ExifInfo->Orientation < 0 || m_ExifInfo->Orientation > 8)\n        {\n          ErrNonfatal(\"Undefined rotation value %d\", m_ExifInfo->Orientation, 0);\n          m_ExifInfo->Orientation = 0;\n        }\n      break;\n\n      case TAG_EXIF_IMAGELENGTH:\n      case TAG_EXIF_IMAGEWIDTH:\n        // Use largest of height and width to deal with images that have been\n        // rotated to portrait format.\n        {\n          int a = (int)ConvertAnyFormat(ValuePtr, Format);\n          if (m_ExifImageWidth < a) m_ExifImageWidth = a;\n        }\n      break;\n\n      case TAG_FOCALPLANEUNITS:\n        switch((int)ConvertAnyFormat(ValuePtr, Format))\n        {\n          // According to the information I was using, 2 means meters.\n          // But looking at the Cannon powershot's files, inches is the only\n          // sensible value.\n          case 1: m_FocalPlaneUnits = 25.4; break;  // inch\n          case 2: m_FocalPlaneUnits = 25.4; break;\n          case 3: m_FocalPlaneUnits = 10;   break;  // centimeter\n          case 4: m_FocalPlaneUnits = 1;    break;  // millimeter\n          case 5: m_FocalPlaneUnits = .001; break;  // micrometer\n        }\n      break;\n\n      case TAG_EXPOSURE_BIAS:\n        m_ExifInfo->ExposureBias = (float)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_WHITEBALANCE:\n        m_ExifInfo->Whitebalance = (int)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_LIGHT_SOURCE:\n        //Quercus: 17-1-2004 Added LightSource, some cams return this, whitebalance or both\n        m_ExifInfo->LightSource = (int)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_METERING_MODE:\n        m_ExifInfo->MeteringMode = (int)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_EXPOSURE_PROGRAM:\n        m_ExifInfo->ExposureProgram = (int)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_EXPOSURE_INDEX:\n        if (m_ExifInfo->ISOequivalent == 0)\n        {\n          // Exposure index and ISO equivalent are often used interchangeably,\n          // so we will do the same.\n          // http://photography.about.com/library/glossary/bldef_ei.htm\n          m_ExifInfo->ISOequivalent = (int)ConvertAnyFormat(ValuePtr, Format);\n        }\n      break;\n\n      case TAG_ISO_EQUIVALENT:\n        m_ExifInfo->ISOequivalent = (int)ConvertAnyFormat(ValuePtr, Format);\n        if (m_ExifInfo->ISOequivalent < 50)\n          m_ExifInfo->ISOequivalent *= 200;          // Fixes strange encoding on some older digicams.\n      break;\n\n      case TAG_EXPOSURE_MODE:\n        m_ExifInfo->ExposureMode = (int)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_DIGITALZOOMRATIO:\n        m_ExifInfo->DigitalZoomRatio = (float)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_EXIF_OFFSET:\n      case TAG_INTEROP_OFFSET:\n      {\n        const unsigned char* const SubdirStart = OffsetBase + (unsigned)Get32(ValuePtr, m_MotorolaOrder);\n        if (SubdirStart < OffsetBase || SubdirStart > OffsetBase+ExifLength)\n        {\n          ErrNonfatal(\"Illegal exif or interop ofset directory link\",0,0);\n        }\n        else\n        {\n          ProcessDir(SubdirStart, OffsetBase, ExifLength, NestingLevel+1);\n        }\n        continue;\n      }\n      break;\n\n      case TAG_GPSINFO:\n      {\n        const unsigned char* const SubdirStart = OffsetBase + (unsigned)Get32(ValuePtr, m_MotorolaOrder);\n        if (SubdirStart < OffsetBase || SubdirStart > OffsetBase+ExifLength)\n        {\n          ErrNonfatal(\"Illegal GPS directory link\",0,0);\n        }\n        else\n        {\n          ProcessGpsInfo(SubdirStart, ByteCount, OffsetBase, ExifLength);\n        }\n        continue;\n      }\n      break;\n\n      case TAG_FOCALLENGTH_35MM:\n        // The focal length equivalent 35 mm is a 2.2 tag (defined as of April 2002)\n        // if its present, use it to compute equivalent focal length instead of\n        // computing it from sensor geometry and actual focal length.\n        m_ExifInfo->FocalLength35mmEquiv = (unsigned)ConvertAnyFormat(ValuePtr, Format);\n      break;\n    }\n  }\n\n\n  // In addition to linking to subdirectories via exif tags,\n  // there's also a potential link to another directory at the end of each\n  // directory.  this has got to be the result of a committee!\n  unsigned Offset;\n\n  if (DIR_ENTRY_ADDR(DirStart, NumDirEntries) + 4 <= OffsetBase+ExifLength)\n  {\n    Offset = (unsigned)Get32(DirStart+2+12*NumDirEntries, m_MotorolaOrder);\n    if (Offset)\n    {\n      const unsigned char* const SubdirStart = OffsetBase + Offset;\n      if (SubdirStart > OffsetBase+ExifLength || SubdirStart < OffsetBase)\n      {\n        if (SubdirStart > OffsetBase && SubdirStart < OffsetBase+ExifLength+20)\n        {\n          // Jhead 1.3 or earlier would crop the whole directory!\n          // As Jhead produces this form of format incorrectness,\n          // I'll just let it pass silently\n        }\n        else\n        {\n          ErrNonfatal(\"Illegal subdirectory link\",0,0);\n        }\n      }\n      else\n      {\n        if (SubdirStart <= OffsetBase+ExifLength)\n        {\n          ProcessDir(SubdirStart, OffsetBase, ExifLength, NestingLevel+1);\n        }\n      }\n      if (Offset > m_LargestExifOffset)\n      {\n        m_LargestExifOffset = Offset;\n      }\n    }\n  }\n  else\n  {\n    // The exif header ends before the last next directory pointer.\n  }\n\n  if (m_ExifInfo->ThumbnailOffset)\n  {\n    m_ExifInfo->ThumbnailAtEnd = false;\n\n    if (m_ExifInfo->ThumbnailOffset <= ExifLength)\n    {\n      if (m_ExifInfo->ThumbnailSize > ExifLength - m_ExifInfo->ThumbnailOffset)\n      {\n        // If thumbnail extends past exif header, only save the part that\n        // actually exists.  Canon's EOS viewer utility will do this - the\n        // thumbnail extracts ok with this hack.\n        m_ExifInfo->ThumbnailSize = ExifLength - m_ExifInfo->ThumbnailOffset;\n      }\n    }\n  }\n}\n\n\n//--------------------------------------------------------------------------\n// Process a EXIF marker\n// Describes all the drivel that most digital cameras include...\n//--------------------------------------------------------------------------\nbool CExifParse::Process (const unsigned char* const ExifSection, const unsigned short length, ExifInfo_t *info)\n{\n  m_ExifInfo = info;\n  // EXIF signature: \"Exif\\0\\0\"\n  // Check EXIF signatures\n  const char ExifHeader[]     = \"Exif\\0\\0\";\n  const char ExifAlignment0[] = \"II\";\n  const char ExifAlignment1[] = \"MM\";\n  const char ExifExtra        = 0x2a;\n\n  const char* pos = (const char*)(ExifSection + sizeof(short));   // position data pointer after length field\n\n  if (memcmp(pos, ExifHeader,6))\n  {\n    printf(\"ExifParse: incorrect Exif header\");\n    return false;\n  }\n  pos += 6;\n\n  if (memcmp(pos, ExifAlignment0, strlen(ExifAlignment0)) == 0)\n  {\n    m_MotorolaOrder = false;\n  }\n  else if (memcmp(pos, ExifAlignment1, strlen(ExifAlignment1)) == 0)\n  {\n    m_MotorolaOrder = true;\n  }\n  else\n  {\n    printf(\"ExifParse: invalid Exif alignment marker\");\n    return false;\n  }\n  pos += strlen(ExifAlignment0);\n\n  // Check the next value for correctness.\n  if (Get16((const void*)(pos), m_MotorolaOrder) != ExifExtra)\n  {\n    printf(\"ExifParse: invalid Exif start (1)\");\n    return false;\n  }\n  pos += sizeof(short);\n\n  unsigned long FirstOffset = (unsigned)Get32((const void*)pos, m_MotorolaOrder);\n  if (FirstOffset < 8 || FirstOffset > 16)\n  {\n    // Usually set to 8, but other values valid too.\n//  CLog::Log(LOGERROR, \"ExifParse: suspicious offset of first IFD value\");\n  }\n\n\n\n  // First directory starts 16 bytes in.  All offset are relative to 8 bytes in.\n  ProcessDir(ExifSection+8+FirstOffset, ExifSection+8, length-8, 0);\n\n  m_ExifInfo->ThumbnailAtEnd = m_ExifInfo->ThumbnailOffset >= m_LargestExifOffset;\n\n  // Compute the CCD width, in millimeters.\n  if (m_FocalPlaneXRes != 0)\n  {\n    // Note: With some cameras, its not possible to compute this correctly because\n    // they don't adjust the indicated focal plane resolution units when using less\n    // than maximum resolution, so the CCDWidth value comes out too small.  Nothing\n    // that Jhead can do about it - its a camera problem.\n    m_ExifInfo->CCDWidth = (float)(m_ExifImageWidth * m_FocalPlaneUnits / m_FocalPlaneXRes);\n  }\n\n  if (m_ExifInfo->FocalLength)\n  {\n    if (m_ExifInfo->FocalLength35mmEquiv == 0)\n    {\n      // Compute 35 mm equivalent focal length based on sensor geometry if we haven't\n      // already got it explicitly from a tag.\n      if (m_ExifInfo->CCDWidth != 0.0f)\n      {\n        m_ExifInfo->FocalLength35mmEquiv =\n            (int)(m_ExifInfo->FocalLength / m_ExifInfo->CCDWidth * 36 + 0.5f);\n      }\n    }\n  }\n  return true;\n}\n\n\n\n//--------------------------------------------------------------------------\n// GPS Lat/Long extraction helper function\n//--------------------------------------------------------------------------\nvoid CExifParse::GetLatLong(\n        const unsigned int Format,\n        const unsigned char* ValuePtr,\n        const int ComponentSize,\n        char *latLongString)\n{\n  if (Format != FMT_URATIONAL)\n  {\n    ErrNonfatal(\"Illegal number format %d for GPS Lat/Long\", Format, 0);\n  }\n  else\n  {\n    double Values[3];\n    for (unsigned a=0; a<3 ;a++)\n    {\n      Values[a] = ConvertAnyFormat(ValuePtr+a*ComponentSize, Format);\n    }\n    if (Values[0] < 0 || Values[0] > 180 || Values[1] < 0 || Values[1] >= 60 || Values[2] < 0 || Values[2] >= 60)\n    {\n      // Ignore invalid values (DMS format expected)\n      ErrNonfatal(\"Invalid Lat/Long value\", 0, 0);\n      latLongString[0] = 0;\n    }\n    else\n    {\n      char latLong[30];\n      sprintf(latLong, \"%3.0fd %2.0f' %5.2f\\\"\", Values[0], Values[1], Values[2]);\n      strcat(latLongString, latLong);\n    }\n  }\n}\n\n//--------------------------------------------------------------------------\n// Process GPS info directory\n//--------------------------------------------------------------------------\nvoid CExifParse::ProcessGpsInfo(\n                    const unsigned char* const DirStart,\n                    int ByteCountUnused,\n                    const unsigned char* const OffsetBase,\n                    unsigned ExifLength)\n{\n  int NumDirEntries = Get16(DirStart, m_MotorolaOrder);\n\n  for (int de=0;de<NumDirEntries;de++)\n  {\n    const unsigned char* DirEntry = DIR_ENTRY_ADDR(DirStart, de);\n\n    unsigned Tag        = Get16(DirEntry, m_MotorolaOrder);\n    unsigned Format     = Get16(DirEntry+2, m_MotorolaOrder);\n    unsigned Components = (unsigned)Get32(DirEntry+4, m_MotorolaOrder);\n    if (Format == 0 || Format > NUM_FORMATS)\n    {\n      ErrNonfatal(\"Illegal number format %d for tag %04x\", Format, Tag);\n      continue;\n    }\n\n    unsigned ComponentSize = BytesPerFormat[Format - 1];\n    unsigned ByteCount = Components * ComponentSize;\n\n    const unsigned char* ValuePtr;\n\n    if (ByteCount > 4)\n    {\n      unsigned OffsetVal = (unsigned)Get32(DirEntry+8, m_MotorolaOrder);\n      // If its bigger than 4 bytes, the dir entry contains an offset.\n      if (OffsetVal+ByteCount > ExifLength)\n      {\n        // Bogus pointer offset and / or bytecount value\n        ErrNonfatal(\"Illegal value pointer for tag %04x\", Tag,0);\n        continue;\n      }\n      ValuePtr = OffsetBase+OffsetVal;\n    }\n    else\n    {\n      // 4 bytes or less and value is in the dir entry itself\n      ValuePtr = DirEntry+8;\n    }\n\n    switch(Tag)\n    {\n      case TAG_GPS_LAT_REF:\n        m_ExifInfo->GpsLat[0] = ValuePtr[0];\n        m_ExifInfo->GpsLat[1] = 0;\n      break;\n\n      case TAG_GPS_LONG_REF:\n        m_ExifInfo->GpsLong[0] = ValuePtr[0];\n        m_ExifInfo->GpsLong[1] = 0;\n      break;\n\n      case TAG_GPS_LAT:\n        GetLatLong(Format, ValuePtr, ComponentSize, m_ExifInfo->GpsLat);\n      break;\n      case TAG_GPS_LONG:\n        GetLatLong(Format, ValuePtr, ComponentSize, m_ExifInfo->GpsLong);\n      break;\n\n      case TAG_GPS_ALT_REF:\n        if (ValuePtr[0] != 0)\n          m_ExifInfo->GpsAlt[0] = '-';\n        m_ExifInfo->GpsAlt[1] = 0;\n      break;\n\n      case TAG_GPS_ALT:\n        {\n          char temp[18];\n          sprintf(temp, \"%.2fm\", static_cast<double>(ConvertAnyFormat(ValuePtr, Format)));\n          strcat(m_ExifInfo->GpsAlt, temp);\n        }\n      break;\n    }\n  }\n}\n\n"], "fixing_code": ["/*\n *  Copyright (C) 2005-2018 Team Kodi\n *  This file is part of Kodi - https://kodi.tv\n *\n *  SPDX-License-Identifier: GPL-2.0-or-later\n *  See LICENSES/README.md for more information.\n */\n\n//--------------------------------------------------------------------------\n// Program to pull the EXIF information out of various types of digital\n// images and present it in a reasonably consistent way\n//\n// Original code pulled from 'jhead' by Matthias Wandel (http://www.sentex.net/~mwandel/) - jhead\n// Adapted for XBMC by DD.\n//--------------------------------------------------------------------------\n\n// Note: Jhead supports TAG_MAKER_NOTE exif field,\n//       but that is omitted for now - to make porting easier and addition smaller\n\n#include \"ExifParse.h\"\n\n#ifdef TARGET_WINDOWS\n#include <windows.h>\n#else\n#include <memory.h>\n#include <cstring>\n#endif\n\n#include <math.h>\n#include <stdio.h>\n\n#ifndef min\n#define min(a,b) (a)>(b)?(b):(a)\n#endif\n#ifndef max\n#define max(a,b) (a)<(b)?(b):(a)\n#endif\n\n\n// Prototypes for exif utility functions.\nstatic void ErrNonfatal(const char* const msg, int a1, int a2);\n\n#define DIR_ENTRY_ADDR(Start, Entry) ((Start)+2+12*(Entry))\n\n\n//--------------------------------------------------------------------------\n// Describes tag values\n#define TAG_DESCRIPTION        0x010E\n#define TAG_MAKE               0x010F\n#define TAG_MODEL              0x0110\n#define TAG_ORIENTATION        0x0112\n#define TAG_X_RESOLUTION       0x011A           // Not processed. Format rational64u (see http://search.cpan.org/src/EXIFTOOL/Image-ExifTool-6.76/html/TagNames/EXIF.html)\n#define TAG_Y_RESOLUTION       0x011B           // Not processed. Format rational64u\n#define TAG_RESOLUTION_UNIT    0x0128           // Not processed. Format int16u. Values: 1-none; 2-inches; 3-cm\n#define TAG_SOFTWARE           0x0131\n#define TAG_DATETIME           0x0132\n#define TAG_THUMBNAIL_OFFSET   0x0201\n#define TAG_THUMBNAIL_LENGTH   0x0202\n#define TAG_Y_CB_CR_POS        0x0213           // Not processed. Format int16u. Values: 1-Centered; 2-Co-sited\n#define TAG_EXPOSURETIME       0x829A\n#define TAG_FNUMBER            0x829D\n#define TAG_EXIF_OFFSET        0x8769\n#define TAG_EXPOSURE_PROGRAM   0x8822\n#define TAG_GPSINFO            0x8825\n#define TAG_ISO_EQUIVALENT     0x8827\n#define TAG_EXIF_VERSION       0x9000           // Not processed.\n#define TAG_COMPONENT_CFG      0x9101           // Not processed.\n#define TAG_DATETIME_ORIGINAL  0x9003\n#define TAG_DATETIME_DIGITIZED 0x9004\n#define TAG_SHUTTERSPEED       0x9201\n#define TAG_APERTURE           0x9202\n#define TAG_EXPOSURE_BIAS      0x9204\n#define TAG_MAXAPERTURE        0x9205\n#define TAG_SUBJECT_DISTANCE   0x9206\n#define TAG_METERING_MODE      0x9207\n#define TAG_LIGHT_SOURCE       0x9208\n#define TAG_FLASH              0x9209\n#define TAG_FOCALLENGTH        0x920A\n#define TAG_MAKER_NOTE         0x927C           // Not processed yet. Maybe in the future.\n#define TAG_USERCOMMENT        0x9286\n#define TAG_XP_COMMENT         0x9c9c\n#define TAG_FLASHPIX_VERSION   0xA000           // Not processed.\n#define TAG_COLOUR_SPACE       0xA001           // Not processed. Format int16u. Values: 1-RGB; 2-Adobe RGB 65535-Uncalibrated\n#define TAG_EXIF_IMAGEWIDTH    0xa002\n#define TAG_EXIF_IMAGELENGTH   0xa003\n#define TAG_INTEROP_OFFSET     0xa005\n#define TAG_FOCALPLANEXRES     0xa20E\n#define TAG_FOCALPLANEUNITS    0xa210\n#define TAG_EXPOSURE_INDEX     0xa215\n#define TAG_EXPOSURE_MODE      0xa402\n#define TAG_WHITEBALANCE       0xa403\n#define TAG_DIGITALZOOMRATIO   0xA404\n#define TAG_FOCALLENGTH_35MM   0xa405\n\n#define TAG_GPS_LAT_REF        1\n#define TAG_GPS_LAT            2\n#define TAG_GPS_LONG_REF       3\n#define TAG_GPS_LONG           4\n#define TAG_GPS_ALT_REF        5\n#define TAG_GPS_ALT            6\n\n//--------------------------------------------------------------------------\n// Exif format descriptor stuff\nnamespace\n{\nconstexpr auto FMT_BYTE = 1;\nconstexpr auto FMT_USHORT = 2;\nconstexpr auto FMT_ULONG = 3;\nconstexpr auto FMT_URATIONAL = 4;\nconstexpr auto FMT_SBYTE = 5;\nconstexpr auto FMT_SSHORT = 6;\nconstexpr auto FMT_SLONG = 7;\nconstexpr auto FMT_SRATIONAL = 8;\nconstexpr auto FMT_SINGLE = 9;\nconstexpr auto FMT_DOUBLE = 10;\n// NOTE: Remember to change NUM_FORMATS if you define a new format\nconstexpr auto NUM_FORMATS = 10;\n\nconst unsigned int BytesPerFormat[NUM_FORMATS] = {1, 2, 4, 8, 1, 2, 4, 8, 4, 8};\n} // namespace\n\n//--------------------------------------------------------------------------\n// Internationalisation string IDs. The enum order must match that in the\n// language file (e.g. 'language/resource.language.en_gb/strings.po', and EXIF_PARSE_STRING_ID_BASE\n// must match the ID of the first Exif string in that file.\n#define EXIF_PARSE_STRING_ID_BASE       21800\nenum {\n// Distance\n  ExifStrDistanceInfinite = EXIF_PARSE_STRING_ID_BASE,\n// Whitebalance et.al.\n  ExifStrManual,\n  ExifStrAuto,\n// Flash modes\n  ExifStrYes,\n  ExifStrNo,\n  ExifStrFlashNoStrobe,\n  ExifStrFlashStrobe,\n  ExifStrFlashManual,\n  ExifStrFlashManualNoReturn,\n  ExifStrFlashManualReturn,\n  ExifStrFlashAuto,\n  ExifStrFlashAutoNoReturn,\n  ExifStrFlashAutoReturn,\n  ExifStrFlashRedEye,\n  ExifStrFlashRedEyeNoReturn,\n  ExifStrFlashRedEyeReturn,\n  ExifStrFlashManualRedEye,\n  ExifStrFlashManualRedEyeNoReturn,\n  ExifStrFlashManualRedEyeReturn,\n  ExifStrFlashAutoRedEye,\n  ExifStrFlashAutoRedEyeNoReturn,\n  ExifStrFlashAutoRedEyeReturn,\n// Light sources\n  ExifStrDaylight,\n  ExifStrFluorescent,\n  ExifStrIncandescent,\n  ExifStrFlash,\n  ExifStrFineWeather,\n  ExifStrShade,\n// Metering Mode\n  ExifStrMeteringCenter,\n  ExifStrMeteringSpot,\n  ExifStrMeteringMatrix,\n// Exposure Program\n  ExifStrExposureProgram,\n  ExifStrExposureAperture,\n  ExifStrExposureShutter,\n  ExifStrExposureCreative,\n  ExifStrExposureAction,\n  ExifStrExposurePortrait,\n  ExifStrExposureLandscape,\n// Exposure mode\n  ExifStrExposureModeAuto,\n// ISO equivalent\n  ExifStrIsoEquivalent,\n// GPS latitude, longitude, altitude\n  ExifStrGpsLatitude,\n  ExifStrGpsLongitude,\n  ExifStrGpsAltitude,\n};\n\n\n\n\n//--------------------------------------------------------------------------\n// Report non fatal errors.  Now that microsoft.net modifies exif headers,\n// there's corrupted ones, and there could be more in the future.\n//--------------------------------------------------------------------------\nstatic void ErrNonfatal(const char* const msg, int a1, int a2)\n{\n  printf(\"ExifParse - Nonfatal Error : %s %d %d\", msg, a1, a2);\n}\n\n//--------------------------------------------------------------------------\n// Convert a 16 bit unsigned value from file's native byte order\n//--------------------------------------------------------------------------\nint CExifParse::Get16(const void* const Short, const bool motorolaOrder)\n{\n    if (motorolaOrder) {\n        return (((const unsigned char *)Short)[0] << 8) | ((const unsigned char *)Short)[1];\n    } else {\n        return (((const unsigned char *)Short)[1] << 8) | ((const unsigned char *)Short)[0];\n    }\n}\n\n//--------------------------------------------------------------------------\n// Convert a 32 bit signed value from file's native byte order\n//--------------------------------------------------------------------------\nint CExifParse::Get32(const void* const Long, const bool motorolaOrder)\n{\n    if (motorolaOrder) {\n        return  (((const char *)Long)[0] << 24) | (((const unsigned char *)Long)[1] << 16)\n          | (((const unsigned char *)Long)[2] << 8 ) | (((const unsigned char *)Long)[3] << 0 );\n    } else {\n        return  (((const char *)Long)[3] << 24) | (((const unsigned char *)Long)[2] << 16)\n          | (((const unsigned char *)Long)[1] << 8 ) | (((const unsigned char *)Long)[0] << 0 );\n    }\n}\n\n//--------------------------------------------------------------------------\n// It appears that CStdString constructor replaces \"\\n\" with \"\\r\\n\" which results\n// in \"\\r\\r\\n\" if there already is \"\\r\\n\", which in turn results in corrupted\n// display. So this is an attempt to undo effects of a smart constructor. Also,\n// replaces all nonprintable characters with \".\"\n//--------------------------------------------------------------------------\n/*void CExifParse::FixComment(CStdString& comment)\n{\n  comment.Replace(\"\\r\\r\\n\", \"\\r\\n\");\n  for (unsigned int i=0; i<comment.length(); i++)\n  {\n    if ((comment[i] < 32) && (comment[i] != '\\n') && (comment[i] != '\\t') && (comment[i] != '\\r'))\n    {\n      comment[i] = '.';\n    }\n  }\n}*/\n\n//--------------------------------------------------------------------------\n// Evaluate number, be it int, rational, or float from directory.\n//--------------------------------------------------------------------------\ndouble CExifParse::ConvertAnyFormat(const void* const ValuePtr, int Format)\n{\n  double Value;\n  Value = 0;\n\n  switch(Format)\n  {\n    case FMT_SBYTE:     Value = *(const   signed char*)ValuePtr;          break;\n    case FMT_BYTE:      Value = *(const unsigned char*)ValuePtr;          break;\n\n    case FMT_USHORT:    Value = Get16(ValuePtr, m_MotorolaOrder);   break;\n    case FMT_ULONG:     Value = (unsigned)Get32(ValuePtr, m_MotorolaOrder);   break;\n\n    case FMT_URATIONAL:\n    case FMT_SRATIONAL:\n    {\n      int Num,Den;\n      Num = Get32(ValuePtr, m_MotorolaOrder);\n      Den = Get32(4+(const char *)ValuePtr, m_MotorolaOrder);\n\n      if (Den == 0)    Value = 0;\n      else             Value = (double)Num/Den;\n    }\n    break;\n\n    case FMT_SSHORT:    Value = (signed short)Get16(ValuePtr, m_MotorolaOrder);    break;\n    case FMT_SLONG:     Value = Get32(ValuePtr, m_MotorolaOrder);                  break;\n\n    // Not sure if this is correct (never seen float used in Exif format)\n    case FMT_SINGLE:    Value = (double)*(const float*)ValuePtr;          break;\n    case FMT_DOUBLE:    Value = *(const double*)ValuePtr;                 break;\n\n    default:\n      ErrNonfatal(\"Illegal format code %d\",Format,0);\n  }\n  return Value;\n}\n\n//--------------------------------------------------------------------------\n// Exif date tag is stored as a fixed format string \"YYYY:MM:DD HH:MM:SS\".\n// If date is not set, then the string is filled with blanks and colons:\n// \"    :  :     :  :  \". We want this string localised.\n//--------------------------------------------------------------------------\n/*void CExifParse::LocaliseDate (void)\n{\n    if (m_ExifInfo[SLIDESHOW_EXIF_DATE_TIME][0] != ' ')\n    {\n        int year  = atoi(m_ExifInfo[SLIDESHOW_EXIF_DATE_TIME].substr(0, 4).c_str());\n        int month = atoi(m_ExifInfo[SLIDESHOW_EXIF_DATE_TIME].substr(5, 2).c_str());\n        int day   = atoi(m_ExifInfo[SLIDESHOW_EXIF_DATE_TIME].substr(8, 2).c_str());\n        int hour  = atoi(m_ExifInfo[SLIDESHOW_EXIF_DATE_TIME].substr(11,2).c_str());\n        int min   = atoi(m_ExifInfo[SLIDESHOW_EXIF_DATE_TIME].substr(14,2).c_str());\n        int sec   = atoi(m_ExifInfo[SLIDESHOW_EXIF_DATE_TIME].substr(17,2).c_str());\n        CDateTime date(year, month, day, hour, min, sec);\n        m_ExifInfo[SLIDESHOW_EXIF_DATE_TIME] = date.GetAsLocalizedDateTime();\n    }\n}*/\n\n\n//--------------------------------------------------------------------------\n// Convert exposure time into a human readable format\n//--------------------------------------------------------------------------\n/*void CExifParse::GetExposureTime(const float exposureTime, CStdString& outStr)\n{\n  if (exposureTime)\n  {\n    if (exposureTime < 0.010)   outStr.Format(\"%6.4fs \", exposureTime);\n    else                        outStr.Format(\"%5.3fs \", exposureTime);\n    if (exposureTime <= 0.5)    outStr.Format(\"%s (1/%d)\", outStr, (int)(0.5 + 1/exposureTime));\n  }\n}*/\n\n//--------------------------------------------------------------------------\n// Process one of the nested EXIF directories.\n//--------------------------------------------------------------------------\nvoid CExifParse::ProcessDir(const unsigned char* const DirStart,\n                            const unsigned char* const OffsetBase,\n                            const unsigned ExifLength,\n                            int NestingLevel)\n{\n  if (NestingLevel > 4)\n  {\n    ErrNonfatal(\"Maximum directory nesting exceeded (corrupt exif header)\", 0,0);\n    return;\n  }\n\n  char IndentString[25];\n  memset(IndentString, ' ', 25);\n  IndentString[NestingLevel * 4] = '\\0';\n\n\n  int NumDirEntries = Get16((const void*)DirStart, m_MotorolaOrder);\n\n  const unsigned char* const DirEnd = DIR_ENTRY_ADDR(DirStart, NumDirEntries);\n  if (DirEnd+4 > (OffsetBase+ExifLength))\n  {\n    if (DirEnd+2 == OffsetBase+ExifLength || DirEnd == OffsetBase+ExifLength)\n    {\n      // Version 1.3 of jhead would truncate a bit too much.\n      // This also caught later on as well.\n    }\n    else\n    {\n      ErrNonfatal(\"Illegally sized directory\", 0,0);\n      return;\n    }\n  }\n\n  for (int de=0;de<NumDirEntries;de++)\n  {\n    int Tag, Format, Components;\n    unsigned char* ValuePtr;\n    int ByteCount;\n    const unsigned char* const DirEntry = DIR_ENTRY_ADDR(DirStart, de);\n\n    Tag = Get16(DirEntry, m_MotorolaOrder);\n    Format = Get16(DirEntry+2, m_MotorolaOrder);\n    Components = Get32(DirEntry+4, m_MotorolaOrder);\n\n    if (Format <= 0 || Format > NUM_FORMATS)\n    {\n      ErrNonfatal(\"Illegal number format %d for tag %04x\", Format, Tag);\n      continue;\n    }\n\n    if ((unsigned)Components > 0x10000)\n    {\n      ErrNonfatal(\"Illegal number of components %d for tag %04x\", Components, Tag);\n      continue;\n    }\n\n    ByteCount = Components * BytesPerFormat[Format - 1];\n\n    if (ByteCount > 4)\n    {\n      unsigned OffsetVal;\n      OffsetVal = (unsigned)Get32(DirEntry+8, m_MotorolaOrder);\n      // If its bigger than 4 bytes, the dir entry contains an offset.\n      if (OffsetVal+ByteCount > ExifLength)\n      {\n        // Bogus pointer offset and / or bytecount value\n        ErrNonfatal(\"Illegal value pointer for tag %04x\", Tag,0);\n        continue;\n      }\n      ValuePtr = (unsigned char*)(const_cast<unsigned char*>(OffsetBase)+OffsetVal);\n\n      if (OffsetVal > m_LargestExifOffset)\n      {\n        m_LargestExifOffset = OffsetVal;\n      }\n\n    }\n    else {\n      // 4 bytes or less and value is in the dir entry itself\n      ValuePtr = (unsigned char*)(const_cast<unsigned char*>(DirEntry)+8);\n    }\n\n\n    // Extract useful components of tag\n    switch(Tag)\n    {\n      case TAG_DESCRIPTION:\n      {\n        int length = max(ByteCount, 0);\n        length = min(length, MAX_COMMENT);\n        strncpy(m_ExifInfo->Description, (char *)ValuePtr, length);\n        m_ExifInfo->Description[length] = '\\0';\n        break;\n      }\n      case TAG_MAKE:\n      {\n        int space = sizeof(m_ExifInfo->CameraMake);\n        if (space > 0)\n        {\n          strncpy(m_ExifInfo->CameraMake, (char *)ValuePtr, space - 1);\n          m_ExifInfo->CameraMake[space - 1] = '\\0';\n        }\n        break;\n      }\n      case TAG_MODEL:\n      {\n        int space = sizeof(m_ExifInfo->CameraModel);\n        if (space > 0)\n        {\n          strncpy(m_ExifInfo->CameraModel, (char *)ValuePtr, space - 1);\n          m_ExifInfo->CameraModel[space - 1] = '\\0';\n        }\n        break;\n      }\n//      case TAG_SOFTWARE:          strncpy(m_ExifInfo->Software, ValuePtr, 5);    break;\n      case TAG_FOCALPLANEXRES:    m_FocalPlaneXRes  = ConvertAnyFormat(ValuePtr, Format);               break;\n      case TAG_THUMBNAIL_OFFSET:  m_ExifInfo->ThumbnailOffset = (unsigned)ConvertAnyFormat(ValuePtr, Format);     break;\n      case TAG_THUMBNAIL_LENGTH:  m_ExifInfo->ThumbnailSize   = (unsigned)ConvertAnyFormat(ValuePtr, Format);     break;\n\n      case TAG_MAKER_NOTE:\n        continue;\n      break;\n\n      case TAG_DATETIME_ORIGINAL:\n      {\n\n        int space = sizeof(m_ExifInfo->DateTime);\n        if (space > 0)\n        {\n          strncpy(m_ExifInfo->DateTime, (char *)ValuePtr, space - 1);\n          m_ExifInfo->DateTime[space - 1] = '\\0';\n          // If we get a DATETIME_ORIGINAL, we use that one.\n          m_DateFound = true;\n        }\n        break;\n      }\n      case TAG_DATETIME_DIGITIZED:\n      case TAG_DATETIME:\n      {\n        if (!m_DateFound)\n        {\n          // If we don't already have a DATETIME_ORIGINAL, use whatever\n          // time fields we may have.\n          int space = sizeof(m_ExifInfo->DateTime);\n          if (space > 0)\n          {\n            strncpy(m_ExifInfo->DateTime, (char *)ValuePtr, space - 1);\n            m_ExifInfo->DateTime[space - 1] = '\\0';\n          }\n        }\n        break;\n      }\n      case TAG_USERCOMMENT:\n      {\n        // The UserComment allows comments without the charset limitations of ImageDescription.\n        // Therefore the UserComment field is prefixed by a CharacterCode field (8 Byte):\n        //  - ASCII:         'ASCII\\0\\0\\0'\n        //  - Unicode:       'UNICODE\\0'\n        //  - JIS X208-1990: 'JIS\\0\\0\\0\\0\\0'\n        //  - Unknown:       '\\0\\0\\0\\0\\0\\0\\0\\0' (application specific)\n\n        m_ExifInfo->CommentsCharset = EXIF_COMMENT_CHARSET_UNKNOWN;\n\n        const int EXIF_COMMENT_CHARSET_LENGTH = 8;\n        if (ByteCount >= EXIF_COMMENT_CHARSET_LENGTH)\n        {\n          // As some implementations use spaces instead of \\0 for the padding,\n          // we're not so strict and check only the prefix.\n          if (memcmp(ValuePtr, \"ASCII\", 5) == 0)\n            m_ExifInfo->CommentsCharset = EXIF_COMMENT_CHARSET_ASCII;\n          else if (memcmp(ValuePtr, \"UNICODE\", 7) == 0)\n            m_ExifInfo->CommentsCharset = EXIF_COMMENT_CHARSET_UNICODE;\n          else if (memcmp(ValuePtr, \"JIS\", 3) == 0)\n            m_ExifInfo->CommentsCharset = EXIF_COMMENT_CHARSET_JIS;\n\n          int length = ByteCount - EXIF_COMMENT_CHARSET_LENGTH;\n          length = min(length, MAX_COMMENT);\n          memcpy(m_ExifInfo->Comments, ValuePtr + EXIF_COMMENT_CHARSET_LENGTH, length);\n          m_ExifInfo->Comments[length] = '\\0';\n//          FixComment(comment);                          // Ensure comment is printable\n        }\n      }\n      break;\n\n      case TAG_XP_COMMENT:\n      {\n        // The XP user comment field is always unicode (UCS-2) encoded\n        m_ExifInfo->XPCommentsCharset = EXIF_COMMENT_CHARSET_UNICODE;\n        size_t length = min(ByteCount, MAX_COMMENT);\n        memcpy(m_ExifInfo->XPComment, ValuePtr, length);\n        m_ExifInfo->XPComment[length] = '\\0';\n      }\n      break;\n\n      case TAG_FNUMBER:\n        // Simplest way of expressing aperture, so I trust it the most.\n        // (overwrite previously computd value if there is one)\n        m_ExifInfo->ApertureFNumber = (float)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_APERTURE:\n      case TAG_MAXAPERTURE:\n        // More relevant info always comes earlier, so only use this field if we don't\n        // have appropriate aperture information yet.\n        if (m_ExifInfo->ApertureFNumber == 0)\n        {\n          m_ExifInfo->ApertureFNumber = (float)exp(ConvertAnyFormat(ValuePtr, Format)*log(2.0)*0.5);\n        }\n      break;\n\n      case TAG_FOCALLENGTH:\n        // Nice digital cameras actually save the focal length as a function\n        // of how far they are zoomed in.\n        m_ExifInfo->FocalLength = (float)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_SUBJECT_DISTANCE:\n        // Inidcates the distacne the autofocus camera is focused to.\n        // Tends to be less accurate as distance increases.\n        {\n          float distance = (float)ConvertAnyFormat(ValuePtr, Format);\n          m_ExifInfo->Distance = distance;\n        }\n      break;\n\n      case TAG_EXPOSURETIME:\n        {\n        // Simplest way of expressing exposure time, so I trust it most.\n        // (overwrite previously computd value if there is one)\n        float expTime = (float)ConvertAnyFormat(ValuePtr, Format);\n        if (expTime)\n          m_ExifInfo->ExposureTime = expTime;\n        }\n      break;\n\n      case TAG_SHUTTERSPEED:\n        // More complicated way of expressing exposure time, so only use\n        // this value if we don't already have it from somewhere else.\n        if (m_ExifInfo->ExposureTime == 0)\n        {\n          m_ExifInfo->ExposureTime = (float)(1/exp(ConvertAnyFormat(ValuePtr, Format)*log(2.0)));\n        }\n      break;\n\n      case TAG_FLASH:\n        m_ExifInfo->FlashUsed = (int)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_ORIENTATION:\n        m_ExifInfo->Orientation = (int)ConvertAnyFormat(ValuePtr, Format);\n        if (m_ExifInfo->Orientation < 0 || m_ExifInfo->Orientation > 8)\n        {\n          ErrNonfatal(\"Undefined rotation value %d\", m_ExifInfo->Orientation, 0);\n          m_ExifInfo->Orientation = 0;\n        }\n      break;\n\n      case TAG_EXIF_IMAGELENGTH:\n      case TAG_EXIF_IMAGEWIDTH:\n        // Use largest of height and width to deal with images that have been\n        // rotated to portrait format.\n        {\n          int a = (int)ConvertAnyFormat(ValuePtr, Format);\n          if (m_ExifImageWidth < a) m_ExifImageWidth = a;\n        }\n      break;\n\n      case TAG_FOCALPLANEUNITS:\n        switch((int)ConvertAnyFormat(ValuePtr, Format))\n        {\n          // According to the information I was using, 2 means meters.\n          // But looking at the Cannon powershot's files, inches is the only\n          // sensible value.\n          case 1: m_FocalPlaneUnits = 25.4; break;  // inch\n          case 2: m_FocalPlaneUnits = 25.4; break;\n          case 3: m_FocalPlaneUnits = 10;   break;  // centimeter\n          case 4: m_FocalPlaneUnits = 1;    break;  // millimeter\n          case 5: m_FocalPlaneUnits = .001; break;  // micrometer\n        }\n      break;\n\n      case TAG_EXPOSURE_BIAS:\n        m_ExifInfo->ExposureBias = (float)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_WHITEBALANCE:\n        m_ExifInfo->Whitebalance = (int)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_LIGHT_SOURCE:\n        //Quercus: 17-1-2004 Added LightSource, some cams return this, whitebalance or both\n        m_ExifInfo->LightSource = (int)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_METERING_MODE:\n        m_ExifInfo->MeteringMode = (int)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_EXPOSURE_PROGRAM:\n        m_ExifInfo->ExposureProgram = (int)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_EXPOSURE_INDEX:\n        if (m_ExifInfo->ISOequivalent == 0)\n        {\n          // Exposure index and ISO equivalent are often used interchangeably,\n          // so we will do the same.\n          // http://photography.about.com/library/glossary/bldef_ei.htm\n          m_ExifInfo->ISOequivalent = (int)ConvertAnyFormat(ValuePtr, Format);\n        }\n      break;\n\n      case TAG_ISO_EQUIVALENT:\n        m_ExifInfo->ISOequivalent = (int)ConvertAnyFormat(ValuePtr, Format);\n        if (m_ExifInfo->ISOequivalent < 50)\n          m_ExifInfo->ISOequivalent *= 200;          // Fixes strange encoding on some older digicams.\n      break;\n\n      case TAG_EXPOSURE_MODE:\n        m_ExifInfo->ExposureMode = (int)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_DIGITALZOOMRATIO:\n        m_ExifInfo->DigitalZoomRatio = (float)ConvertAnyFormat(ValuePtr, Format);\n      break;\n\n      case TAG_EXIF_OFFSET:\n      case TAG_INTEROP_OFFSET:\n      {\n        const unsigned char* const SubdirStart = OffsetBase + (unsigned)Get32(ValuePtr, m_MotorolaOrder);\n        if (SubdirStart < OffsetBase || SubdirStart > OffsetBase+ExifLength)\n        {\n          ErrNonfatal(\"Illegal exif or interop ofset directory link\",0,0);\n        }\n        else\n        {\n          ProcessDir(SubdirStart, OffsetBase, ExifLength, NestingLevel+1);\n        }\n        continue;\n      }\n      break;\n\n      case TAG_GPSINFO:\n      {\n        const unsigned char* const SubdirStart = OffsetBase + (unsigned)Get32(ValuePtr, m_MotorolaOrder);\n        if (SubdirStart < OffsetBase || SubdirStart > OffsetBase+ExifLength)\n        {\n          ErrNonfatal(\"Illegal GPS directory link\",0,0);\n        }\n        else\n        {\n          ProcessGpsInfo(SubdirStart, ByteCount, OffsetBase, ExifLength);\n        }\n        continue;\n      }\n      break;\n\n      case TAG_FOCALLENGTH_35MM:\n        // The focal length equivalent 35 mm is a 2.2 tag (defined as of April 2002)\n        // if its present, use it to compute equivalent focal length instead of\n        // computing it from sensor geometry and actual focal length.\n        m_ExifInfo->FocalLength35mmEquiv = (unsigned)ConvertAnyFormat(ValuePtr, Format);\n      break;\n    }\n  }\n\n\n  // In addition to linking to subdirectories via exif tags,\n  // there's also a potential link to another directory at the end of each\n  // directory.  this has got to be the result of a committee!\n  unsigned Offset;\n\n  if (DIR_ENTRY_ADDR(DirStart, NumDirEntries) + 4 <= OffsetBase+ExifLength)\n  {\n    Offset = (unsigned)Get32(DirStart+2+12*NumDirEntries, m_MotorolaOrder);\n    if (Offset)\n    {\n      const unsigned char* const SubdirStart = OffsetBase + Offset;\n      if (SubdirStart > OffsetBase+ExifLength || SubdirStart < OffsetBase)\n      {\n        if (SubdirStart > OffsetBase && SubdirStart < OffsetBase+ExifLength+20)\n        {\n          // Jhead 1.3 or earlier would crop the whole directory!\n          // As Jhead produces this form of format incorrectness,\n          // I'll just let it pass silently\n        }\n        else\n        {\n          ErrNonfatal(\"Illegal subdirectory link\",0,0);\n        }\n      }\n      else\n      {\n        if (SubdirStart <= OffsetBase+ExifLength)\n        {\n          ProcessDir(SubdirStart, OffsetBase, ExifLength, NestingLevel+1);\n        }\n      }\n      if (Offset > m_LargestExifOffset)\n      {\n        m_LargestExifOffset = Offset;\n      }\n    }\n  }\n  else\n  {\n    // The exif header ends before the last next directory pointer.\n  }\n\n  if (m_ExifInfo->ThumbnailOffset)\n  {\n    m_ExifInfo->ThumbnailAtEnd = false;\n\n    if (m_ExifInfo->ThumbnailOffset <= ExifLength)\n    {\n      if (m_ExifInfo->ThumbnailSize > ExifLength - m_ExifInfo->ThumbnailOffset)\n      {\n        // If thumbnail extends past exif header, only save the part that\n        // actually exists.  Canon's EOS viewer utility will do this - the\n        // thumbnail extracts ok with this hack.\n        m_ExifInfo->ThumbnailSize = ExifLength - m_ExifInfo->ThumbnailOffset;\n      }\n    }\n  }\n}\n\n\n//--------------------------------------------------------------------------\n// Process a EXIF marker\n// Describes all the drivel that most digital cameras include...\n//--------------------------------------------------------------------------\nbool CExifParse::Process (const unsigned char* const ExifSection, const unsigned short length, ExifInfo_t *info)\n{\n  m_ExifInfo = info;\n  // EXIF signature: \"Exif\\0\\0\"\n  // Check EXIF signatures\n  const char ExifHeader[]     = \"Exif\\0\\0\";\n  const char ExifAlignment0[] = \"II\";\n  const char ExifAlignment1[] = \"MM\";\n  const char ExifExtra        = 0x2a;\n\n  const char* pos = (const char*)(ExifSection + sizeof(short));   // position data pointer after length field\n\n  if (memcmp(pos, ExifHeader,6))\n  {\n    printf(\"ExifParse: incorrect Exif header\");\n    return false;\n  }\n  pos += 6;\n\n  if (memcmp(pos, ExifAlignment0, strlen(ExifAlignment0)) == 0)\n  {\n    m_MotorolaOrder = false;\n  }\n  else if (memcmp(pos, ExifAlignment1, strlen(ExifAlignment1)) == 0)\n  {\n    m_MotorolaOrder = true;\n  }\n  else\n  {\n    printf(\"ExifParse: invalid Exif alignment marker\");\n    return false;\n  }\n  pos += strlen(ExifAlignment0);\n\n  // Check the next value for correctness.\n  if (Get16((const void*)(pos), m_MotorolaOrder) != ExifExtra)\n  {\n    printf(\"ExifParse: invalid Exif start (1)\");\n    return false;\n  }\n  pos += sizeof(short);\n\n  unsigned long FirstOffset = (unsigned)Get32((const void*)pos, m_MotorolaOrder);\n  if (FirstOffset < 8 || FirstOffset > 16)\n  {\n    // Usually set to 8, but other values valid too.\n//  CLog::Log(LOGERROR, \"ExifParse: suspicious offset of first IFD value\");\n  }\n\n\n\n  // First directory starts 16 bytes in.  All offset are relative to 8 bytes in.\n  ProcessDir(ExifSection+8+FirstOffset, ExifSection+8, length-8, 0);\n\n  m_ExifInfo->ThumbnailAtEnd = m_ExifInfo->ThumbnailOffset >= m_LargestExifOffset;\n\n  // Compute the CCD width, in millimeters.\n  if (m_FocalPlaneXRes != 0)\n  {\n    // Note: With some cameras, its not possible to compute this correctly because\n    // they don't adjust the indicated focal plane resolution units when using less\n    // than maximum resolution, so the CCDWidth value comes out too small.  Nothing\n    // that Jhead can do about it - its a camera problem.\n    m_ExifInfo->CCDWidth = (float)(m_ExifImageWidth * m_FocalPlaneUnits / m_FocalPlaneXRes);\n  }\n\n  if (m_ExifInfo->FocalLength)\n  {\n    if (m_ExifInfo->FocalLength35mmEquiv == 0)\n    {\n      // Compute 35 mm equivalent focal length based on sensor geometry if we haven't\n      // already got it explicitly from a tag.\n      if (m_ExifInfo->CCDWidth != 0.0f)\n      {\n        m_ExifInfo->FocalLength35mmEquiv =\n            (int)(m_ExifInfo->FocalLength / m_ExifInfo->CCDWidth * 36 + 0.5f);\n      }\n    }\n  }\n  return true;\n}\n\n\n\n//--------------------------------------------------------------------------\n// GPS Lat/Long extraction helper function\n//--------------------------------------------------------------------------\nvoid CExifParse::GetLatLong(\n        const unsigned int Format,\n        const unsigned char* ValuePtr,\n        const int ComponentSize,\n        char *latLongString)\n{\n  if (Format != FMT_URATIONAL)\n  {\n    ErrNonfatal(\"Illegal number format %d for GPS Lat/Long\", Format, 0);\n  }\n  else\n  {\n    double Values[3];\n    for (unsigned a=0; a<3 ;a++)\n    {\n      Values[a] = ConvertAnyFormat(ValuePtr+a*ComponentSize, Format);\n    }\n    if (Values[0] < 0 || Values[0] > 180 || Values[1] < 0 || Values[1] >= 60 || Values[2] < 0 || Values[2] >= 60)\n    {\n      // Ignore invalid values (DMS format expected)\n      ErrNonfatal(\"Invalid Lat/Long value\", 0, 0);\n      latLongString[0] = 0;\n    }\n    else\n    {\n      char latLong[30];\n      sprintf(latLong, \"%3.0fd %2.0f' %5.2f\\\"\", Values[0], Values[1], Values[2]);\n      strcat(latLongString, latLong);\n    }\n  }\n}\n\n//--------------------------------------------------------------------------\n// Process GPS info directory\n//--------------------------------------------------------------------------\nvoid CExifParse::ProcessGpsInfo(\n                    const unsigned char* const DirStart,\n                    int ByteCountUnused,\n                    const unsigned char* const OffsetBase,\n                    unsigned ExifLength)\n{\n  int NumDirEntries = Get16(DirStart, m_MotorolaOrder);\n\n  for (int de=0;de<NumDirEntries;de++)\n  {\n    const unsigned char* DirEntry = DIR_ENTRY_ADDR(DirStart, de);\n\n    // Fix from aosp 34a2564d3268a5ca1472c5076675782fbaf724d6\n    if (DirEntry + 12 > OffsetBase + ExifLength){\n      ErrNonfatal(\"GPS info directory goes past end of exif\", 0, 0);\n      return;\n    }\n\n    unsigned Tag        = Get16(DirEntry, m_MotorolaOrder);\n    unsigned Format     = Get16(DirEntry+2, m_MotorolaOrder);\n    unsigned Components = (unsigned)Get32(DirEntry+4, m_MotorolaOrder);\n    if (Format == 0 || Format > NUM_FORMATS)\n    {\n      ErrNonfatal(\"Illegal number format %d for tag %04x\", Format, Tag);\n      continue;\n    }\n\n    unsigned ComponentSize = BytesPerFormat[Format - 1];\n    unsigned ByteCount = Components * ComponentSize;\n\n    const unsigned char* ValuePtr;\n\n    if (ByteCount > 4)\n    {\n      unsigned OffsetVal = (unsigned)Get32(DirEntry+8, m_MotorolaOrder);\n      // If its bigger than 4 bytes, the dir entry contains an offset.\n      if (OffsetVal+ByteCount > ExifLength)\n      {\n        // Bogus pointer offset and / or bytecount value\n        ErrNonfatal(\"Illegal value pointer for tag %04x\", Tag,0);\n        continue;\n      }\n      ValuePtr = OffsetBase+OffsetVal;\n    }\n    else\n    {\n      // 4 bytes or less and value is in the dir entry itself\n      ValuePtr = DirEntry+8;\n    }\n\n    switch(Tag)\n    {\n      case TAG_GPS_LAT_REF:\n        m_ExifInfo->GpsLat[0] = ValuePtr[0];\n        m_ExifInfo->GpsLat[1] = 0;\n      break;\n\n      case TAG_GPS_LONG_REF:\n        m_ExifInfo->GpsLong[0] = ValuePtr[0];\n        m_ExifInfo->GpsLong[1] = 0;\n      break;\n\n      case TAG_GPS_LAT:\n        GetLatLong(Format, ValuePtr, ComponentSize, m_ExifInfo->GpsLat);\n      break;\n      case TAG_GPS_LONG:\n        GetLatLong(Format, ValuePtr, ComponentSize, m_ExifInfo->GpsLong);\n      break;\n\n      case TAG_GPS_ALT_REF:\n        if (ValuePtr[0] != 0)\n          m_ExifInfo->GpsAlt[0] = '-';\n        m_ExifInfo->GpsAlt[1] = 0;\n      break;\n\n      case TAG_GPS_ALT:\n        {\n          char temp[18];\n          sprintf(temp, \"%.2fm\", static_cast<double>(ConvertAnyFormat(ValuePtr, Format)));\n          strcat(m_ExifInfo->GpsAlt, temp);\n        }\n      break;\n    }\n  }\n}\n\n"], "filenames": ["xbmc/pictures/ExifParse.cpp"], "buggy_code_start_loc": [880], "buggy_code_end_loc": [880], "fixing_code_start_loc": [881], "fixing_code_end_loc": [887], "type": "CWE-787", "message": "A heap buffer overflow vulnerability in Kodi Home Theater Software up to 19.5 allows attackers to cause a denial of service due to an improper length of the value passed to the offset argument.", "other": {"cve": {"id": "CVE-2023-23082", "sourceIdentifier": "cve@mitre.org", "published": "2023-02-03T22:15:12.277", "lastModified": "2023-02-12T04:53:50.410", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A heap buffer overflow vulnerability in Kodi Home Theater Software up to 19.5 allows attackers to cause a denial of service due to an improper length of the value passed to the offset argument."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:P/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 4.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:kodi:kodi:*:*:*:*:*:*:*:*", "versionEndIncluding": "19.5", "matchCriteriaId": "AEE0AAF6-FF9A-4120-8A0A-27505D73EDB7"}]}]}], "references": [{"url": "https://github.com/fritsch/xbmc/commit/367cc80d66b0310b460f587fea44274b442951f1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/fritsch/xbmc/commit/54df944584fc9fecd4cd5d69c2289f0934de305b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/xbmc/xbmc/commit/8c2aafb6d4987833803e037c923aaf83f9ff41e1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/xbmc/xbmc/issues/22377", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/xbmc/xbmc/pull/22380", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/fritsch/xbmc/commit/367cc80d66b0310b460f587fea44274b442951f1"}}