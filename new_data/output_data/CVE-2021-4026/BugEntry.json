{"buggy_code": ["<?php\n\nnamespace BookStack\\Actions;\n\nuse BookStack\\Auth\\Permissions\\PermissionService;\nuse BookStack\\Auth\\User;\nuse BookStack\\Entities\\Models\\Book;\nuse BookStack\\Entities\\Models\\Chapter;\nuse BookStack\\Entities\\Models\\Entity;\nuse BookStack\\Entities\\Models\\Page;\nuse BookStack\\Interfaces\\Loggable;\nuse Illuminate\\Database\\Eloquent\\Builder;\nuse Illuminate\\Database\\Eloquent\\Relations\\Relation;\nuse Illuminate\\Support\\Facades\\Log;\n\nclass ActivityService\n{\n    protected $activity;\n    protected $permissionService;\n\n    public function __construct(Activity $activity, PermissionService $permissionService)\n    {\n        $this->activity = $activity;\n        $this->permissionService = $permissionService;\n    }\n\n    /**\n     * Add activity data to database for an entity.\n     */\n    public function addForEntity(Entity $entity, string $type)\n    {\n        $activity = $this->newActivityForUser($type);\n        $entity->activity()->save($activity);\n        $this->setNotification($type);\n    }\n\n    /**\n     * Add a generic activity event to the database.\n     *\n     * @param string|Loggable $detail\n     */\n    public function add(string $type, $detail = '')\n    {\n        if ($detail instanceof Loggable) {\n            $detail = $detail->logDescriptor();\n        }\n\n        $activity = $this->newActivityForUser($type);\n        $activity->detail = $detail;\n        $activity->save();\n        $this->setNotification($type);\n    }\n\n    /**\n     * Get a new activity instance for the current user.\n     */\n    protected function newActivityForUser(string $type): Activity\n    {\n        $ip = request()->ip() ?? '';\n\n        return $this->activity->newInstance()->forceFill([\n            'type'     => strtolower($type),\n            'user_id'  => user()->id,\n            'ip'       => config('app.env') === 'demo' ? '127.0.0.1' : $ip,\n        ]);\n    }\n\n    /**\n     * Removes the entity attachment from each of its activities\n     * and instead uses the 'extra' field with the entities name.\n     * Used when an entity is deleted.\n     */\n    public function removeEntity(Entity $entity)\n    {\n        $entity->activity()->update([\n            'detail'       => $entity->name,\n            'entity_id'    => null,\n            'entity_type'  => null,\n        ]);\n    }\n\n    /**\n     * Gets the latest activity.\n     */\n    public function latest(int $count = 20, int $page = 0): array\n    {\n        $activityList = $this->permissionService\n            ->filterRestrictedEntityRelations($this->activity->newQuery(), 'activities', 'entity_id', 'entity_type')\n            ->orderBy('created_at', 'desc')\n            ->with(['user', 'entity'])\n            ->skip($count * $page)\n            ->take($count)\n            ->get();\n\n        return $this->filterSimilar($activityList);\n    }\n\n    /**\n     * Gets the latest activity for an entity, Filtering out similar\n     * items to prevent a message activity list.\n     */\n    public function entityActivity(Entity $entity, int $count = 20, int $page = 1): array\n    {\n        /** @var array<string, int[]> $queryIds */\n        $queryIds = [$entity->getMorphClass() => [$entity->id]];\n\n        if ($entity instanceof Book) {\n            $queryIds[(new Chapter())->getMorphClass()] = $entity->chapters()->scopes('visible')->pluck('id');\n        }\n        if ($entity instanceof Book || $entity instanceof Chapter) {\n            $queryIds[(new Page())->getMorphClass()] = $entity->pages()->scopes('visible')->pluck('id');\n        }\n\n        $query = $this->activity->newQuery();\n        $query->where(function (Builder $query) use ($queryIds) {\n            foreach ($queryIds as $morphClass => $idArr) {\n                $query->orWhere(function (Builder $innerQuery) use ($morphClass, $idArr) {\n                    $innerQuery->where('entity_type', '=', $morphClass)\n                        ->whereIn('entity_id', $idArr);\n                });\n            }\n        });\n\n        $activity = $query->orderBy('created_at', 'desc')\n            ->with(['entity' => function (Relation $query) {\n                $query->withTrashed();\n            }, 'user.avatar'])\n            ->skip($count * ($page - 1))\n            ->take($count)\n            ->get();\n\n        return $this->filterSimilar($activity);\n    }\n\n    /**\n     * Get latest activity for a user, Filtering out similar items.\n     */\n    public function userActivity(User $user, int $count = 20, int $page = 0): array\n    {\n        $activityList = $this->permissionService\n            ->filterRestrictedEntityRelations($this->activity->newQuery(), 'activities', 'entity_id', 'entity_type')\n            ->orderBy('created_at', 'desc')\n            ->where('user_id', '=', $user->id)\n            ->skip($count * $page)\n            ->take($count)\n            ->get();\n\n        return $this->filterSimilar($activityList);\n    }\n\n    /**\n     * Filters out similar activity.\n     *\n     * @param Activity[] $activities\n     *\n     * @return array\n     */\n    protected function filterSimilar(iterable $activities): array\n    {\n        $newActivity = [];\n        $previousItem = null;\n\n        foreach ($activities as $activityItem) {\n            if (!$previousItem || !$activityItem->isSimilarTo($previousItem)) {\n                $newActivity[] = $activityItem;\n            }\n\n            $previousItem = $activityItem;\n        }\n\n        return $newActivity;\n    }\n\n    /**\n     * Flashes a notification message to the session if an appropriate message is available.\n     */\n    protected function setNotification(string $type)\n    {\n        $notificationTextKey = 'activities.' . $type . '_notification';\n        if (trans()->has($notificationTextKey)) {\n            $message = trans($notificationTextKey);\n            session()->flash('success', $message);\n        }\n    }\n\n    /**\n     * Log out a failed login attempt, Providing the given username\n     * as part of the message if the '%u' string is used.\n     */\n    public function logFailedLogin(string $username)\n    {\n        $message = config('logging.failed_login.message');\n        if (!$message) {\n            return;\n        }\n\n        $message = str_replace('%u', $username, $message);\n        $channel = config('logging.failed_login.channel');\n        Log::channel($channel)->warning($message);\n    }\n}\n", "<?php\n\nnamespace BookStack\\Auth\\Permissions;\n\nuse BookStack\\Auth\\Role;\nuse BookStack\\Auth\\User;\nuse BookStack\\Entities\\Models\\Book;\nuse BookStack\\Entities\\Models\\BookChild;\nuse BookStack\\Entities\\Models\\Bookshelf;\nuse BookStack\\Entities\\Models\\Chapter;\nuse BookStack\\Entities\\Models\\Entity;\nuse BookStack\\Entities\\Models\\Page;\nuse BookStack\\Model;\nuse BookStack\\Traits\\HasCreatorAndUpdater;\nuse BookStack\\Traits\\HasOwner;\nuse Illuminate\\Database\\Connection;\nuse Illuminate\\Database\\Eloquent\\Builder;\nuse Illuminate\\Database\\Eloquent\\Collection as EloquentCollection;\nuse Illuminate\\Database\\Query\\Builder as QueryBuilder;\nuse Throwable;\n\nclass PermissionService\n{\n    /**\n     * @var ?array\n     */\n    protected $userRoles = null;\n\n    /**\n     * @var ?User\n     */\n    protected $currentUserModel = null;\n\n    /**\n     * @var Connection\n     */\n    protected $db;\n\n    /**\n     * @var array\n     */\n    protected $entityCache;\n\n    /**\n     * PermissionService constructor.\n     */\n    public function __construct(Connection $db)\n    {\n        $this->db = $db;\n    }\n\n    /**\n     * Set the database connection.\n     */\n    public function setConnection(Connection $connection)\n    {\n        $this->db = $connection;\n    }\n\n    /**\n     * Prepare the local entity cache and ensure it's empty.\n     *\n     * @param Entity[] $entities\n     */\n    protected function readyEntityCache(array $entities = [])\n    {\n        $this->entityCache = [];\n\n        foreach ($entities as $entity) {\n            $class = get_class($entity);\n            if (!isset($this->entityCache[$class])) {\n                $this->entityCache[$class] = collect();\n            }\n            $this->entityCache[$class]->put($entity->id, $entity);\n        }\n    }\n\n    /**\n     * Get a book via ID, Checks local cache.\n     */\n    protected function getBook(int $bookId): ?Book\n    {\n        if (isset($this->entityCache[Book::class]) && $this->entityCache[Book::class]->has($bookId)) {\n            return $this->entityCache[Book::class]->get($bookId);\n        }\n\n        return Book::query()->withTrashed()->find($bookId);\n    }\n\n    /**\n     * Get a chapter via ID, Checks local cache.\n     */\n    protected function getChapter(int $chapterId): ?Chapter\n    {\n        if (isset($this->entityCache[Chapter::class]) && $this->entityCache[Chapter::class]->has($chapterId)) {\n            return $this->entityCache[Chapter::class]->get($chapterId);\n        }\n\n        return Chapter::query()\n            ->withTrashed()\n            ->find($chapterId);\n    }\n\n    /**\n     * Get the roles for the current logged in user.\n     */\n    protected function getCurrentUserRoles(): array\n    {\n        if (!is_null($this->userRoles)) {\n            return $this->userRoles;\n        }\n\n        if (auth()->guest()) {\n            $this->userRoles = [Role::getSystemRole('public')->id];\n        } else {\n            $this->userRoles = $this->currentUser()->roles->pluck('id')->values()->all();\n        }\n\n        return $this->userRoles;\n    }\n\n    /**\n     * Re-generate all entity permission from scratch.\n     */\n    public function buildJointPermissions()\n    {\n        JointPermission::query()->truncate();\n        $this->readyEntityCache();\n\n        // Get all roles (Should be the most limited dimension)\n        $roles = Role::query()->with('permissions')->get()->all();\n\n        // Chunk through all books\n        $this->bookFetchQuery()->chunk(5, function (EloquentCollection $books) use ($roles) {\n            $this->buildJointPermissionsForBooks($books, $roles);\n        });\n\n        // Chunk through all bookshelves\n        Bookshelf::query()->withTrashed()->select(['id', 'restricted', 'owned_by'])\n            ->chunk(50, function (EloquentCollection $shelves) use ($roles) {\n                $this->buildJointPermissionsForShelves($shelves, $roles);\n            });\n    }\n\n    /**\n     * Get a query for fetching a book with it's children.\n     */\n    protected function bookFetchQuery(): Builder\n    {\n        return Book::query()->withTrashed()\n            ->select(['id', 'restricted', 'owned_by'])->with([\n                'chapters' => function ($query) {\n                    $query->withTrashed()->select(['id', 'restricted', 'owned_by', 'book_id']);\n                },\n                'pages' => function ($query) {\n                    $query->withTrashed()->select(['id', 'restricted', 'owned_by', 'book_id', 'chapter_id']);\n                },\n            ]);\n    }\n\n    /**\n     * Build joint permissions for the given shelf and role combinations.\n     *\n     * @throws Throwable\n     */\n    protected function buildJointPermissionsForShelves(EloquentCollection $shelves, array $roles, bool $deleteOld = false)\n    {\n        if ($deleteOld) {\n            $this->deleteManyJointPermissionsForEntities($shelves->all());\n        }\n        $this->createManyJointPermissions($shelves->all(), $roles);\n    }\n\n    /**\n     * Build joint permissions for the given book and role combinations.\n     *\n     * @throws Throwable\n     */\n    protected function buildJointPermissionsForBooks(EloquentCollection $books, array $roles, bool $deleteOld = false)\n    {\n        $entities = clone $books;\n\n        /** @var Book $book */\n        foreach ($books->all() as $book) {\n            foreach ($book->getRelation('chapters') as $chapter) {\n                $entities->push($chapter);\n            }\n            foreach ($book->getRelation('pages') as $page) {\n                $entities->push($page);\n            }\n        }\n\n        if ($deleteOld) {\n            $this->deleteManyJointPermissionsForEntities($entities->all());\n        }\n        $this->createManyJointPermissions($entities->all(), $roles);\n    }\n\n    /**\n     * Rebuild the entity jointPermissions for a particular entity.\n     *\n     * @throws Throwable\n     */\n    public function buildJointPermissionsForEntity(Entity $entity)\n    {\n        $entities = [$entity];\n        if ($entity instanceof Book) {\n            $books = $this->bookFetchQuery()->where('id', '=', $entity->id)->get();\n            $this->buildJointPermissionsForBooks($books, Role::query()->get()->all(), true);\n\n            return;\n        }\n\n        /** @var BookChild $entity */\n        if ($entity->book) {\n            $entities[] = $entity->book;\n        }\n\n        if ($entity instanceof Page && $entity->chapter_id) {\n            $entities[] = $entity->chapter;\n        }\n\n        if ($entity instanceof Chapter) {\n            foreach ($entity->pages as $page) {\n                $entities[] = $page;\n            }\n        }\n\n        $this->buildJointPermissionsForEntities($entities);\n    }\n\n    /**\n     * Rebuild the entity jointPermissions for a collection of entities.\n     *\n     * @throws Throwable\n     */\n    public function buildJointPermissionsForEntities(array $entities)\n    {\n        $roles = Role::query()->get()->values()->all();\n        $this->deleteManyJointPermissionsForEntities($entities);\n        $this->createManyJointPermissions($entities, $roles);\n    }\n\n    /**\n     * Build the entity jointPermissions for a particular role.\n     */\n    public function buildJointPermissionForRole(Role $role)\n    {\n        $roles = [$role];\n        $this->deleteManyJointPermissionsForRoles($roles);\n\n        // Chunk through all books\n        $this->bookFetchQuery()->chunk(20, function ($books) use ($roles) {\n            $this->buildJointPermissionsForBooks($books, $roles);\n        });\n\n        // Chunk through all bookshelves\n        Bookshelf::query()->select(['id', 'restricted', 'owned_by'])\n            ->chunk(50, function ($shelves) use ($roles) {\n                $this->buildJointPermissionsForShelves($shelves, $roles);\n            });\n    }\n\n    /**\n     * Delete the entity jointPermissions attached to a particular role.\n     */\n    public function deleteJointPermissionsForRole(Role $role)\n    {\n        $this->deleteManyJointPermissionsForRoles([$role]);\n    }\n\n    /**\n     * Delete all of the entity jointPermissions for a list of entities.\n     *\n     * @param Role[] $roles\n     */\n    protected function deleteManyJointPermissionsForRoles($roles)\n    {\n        $roleIds = array_map(function ($role) {\n            return $role->id;\n        }, $roles);\n        JointPermission::query()->whereIn('role_id', $roleIds)->delete();\n    }\n\n    /**\n     * Delete the entity jointPermissions for a particular entity.\n     *\n     * @param Entity $entity\n     *\n     * @throws Throwable\n     */\n    public function deleteJointPermissionsForEntity(Entity $entity)\n    {\n        $this->deleteManyJointPermissionsForEntities([$entity]);\n    }\n\n    /**\n     * Delete all of the entity jointPermissions for a list of entities.\n     *\n     * @param Entity[] $entities\n     *\n     * @throws Throwable\n     */\n    protected function deleteManyJointPermissionsForEntities(array $entities)\n    {\n        if (count($entities) === 0) {\n            return;\n        }\n\n        $this->db->transaction(function () use ($entities) {\n            foreach (array_chunk($entities, 1000) as $entityChunk) {\n                $query = $this->db->table('joint_permissions');\n                foreach ($entityChunk as $entity) {\n                    $query->orWhere(function (QueryBuilder $query) use ($entity) {\n                        $query->where('entity_id', '=', $entity->id)\n                            ->where('entity_type', '=', $entity->getMorphClass());\n                    });\n                }\n                $query->delete();\n            }\n        });\n    }\n\n    /**\n     * Create & Save entity jointPermissions for many entities and roles.\n     *\n     * @param Entity[] $entities\n     * @param Role[]   $roles\n     *\n     * @throws Throwable\n     */\n    protected function createManyJointPermissions(array $entities, array $roles)\n    {\n        $this->readyEntityCache($entities);\n        $jointPermissions = [];\n\n        // Fetch Entity Permissions and create a mapping of entity restricted statuses\n        $entityRestrictedMap = [];\n        $permissionFetch = EntityPermission::query();\n        foreach ($entities as $entity) {\n            $entityRestrictedMap[$entity->getMorphClass() . ':' . $entity->id] = boolval($entity->getRawAttribute('restricted'));\n            $permissionFetch->orWhere(function ($query) use ($entity) {\n                $query->where('restrictable_id', '=', $entity->id)->where('restrictable_type', '=', $entity->getMorphClass());\n            });\n        }\n        $permissions = $permissionFetch->get();\n\n        // Create a mapping of explicit entity permissions\n        $permissionMap = [];\n        foreach ($permissions as $permission) {\n            $key = $permission->restrictable_type . ':' . $permission->restrictable_id . ':' . $permission->role_id . ':' . $permission->action;\n            $isRestricted = $entityRestrictedMap[$permission->restrictable_type . ':' . $permission->restrictable_id];\n            $permissionMap[$key] = $isRestricted;\n        }\n\n        // Create a mapping of role permissions\n        $rolePermissionMap = [];\n        foreach ($roles as $role) {\n            foreach ($role->permissions as $permission) {\n                $rolePermissionMap[$role->getRawAttribute('id') . ':' . $permission->getRawAttribute('name')] = true;\n            }\n        }\n\n        // Create Joint Permission Data\n        foreach ($entities as $entity) {\n            foreach ($roles as $role) {\n                foreach ($this->getActions($entity) as $action) {\n                    $jointPermissions[] = $this->createJointPermissionData($entity, $role, $action, $permissionMap, $rolePermissionMap);\n                }\n            }\n        }\n\n        $this->db->transaction(function () use ($jointPermissions) {\n            foreach (array_chunk($jointPermissions, 1000) as $jointPermissionChunk) {\n                $this->db->table('joint_permissions')->insert($jointPermissionChunk);\n            }\n        });\n    }\n\n    /**\n     * Get the actions related to an entity.\n     */\n    protected function getActions(Entity $entity): array\n    {\n        $baseActions = ['view', 'update', 'delete'];\n        if ($entity instanceof Chapter || $entity instanceof Book) {\n            $baseActions[] = 'page-create';\n        }\n        if ($entity instanceof Book) {\n            $baseActions[] = 'chapter-create';\n        }\n\n        return $baseActions;\n    }\n\n    /**\n     * Create entity permission data for an entity and role\n     * for a particular action.\n     */\n    protected function createJointPermissionData(Entity $entity, Role $role, string $action, array $permissionMap, array $rolePermissionMap): array\n    {\n        $permissionPrefix = (strpos($action, '-') === false ? ($entity->getType() . '-') : '') . $action;\n        $roleHasPermission = isset($rolePermissionMap[$role->getRawAttribute('id') . ':' . $permissionPrefix . '-all']);\n        $roleHasPermissionOwn = isset($rolePermissionMap[$role->getRawAttribute('id') . ':' . $permissionPrefix . '-own']);\n        $explodedAction = explode('-', $action);\n        $restrictionAction = end($explodedAction);\n\n        if ($role->system_name === 'admin') {\n            return $this->createJointPermissionDataArray($entity, $role, $action, true, true);\n        }\n\n        if ($entity->restricted) {\n            $hasAccess = $this->mapHasActiveRestriction($permissionMap, $entity, $role, $restrictionAction);\n\n            return $this->createJointPermissionDataArray($entity, $role, $action, $hasAccess, $hasAccess);\n        }\n\n        if ($entity instanceof Book || $entity instanceof Bookshelf) {\n            return $this->createJointPermissionDataArray($entity, $role, $action, $roleHasPermission, $roleHasPermissionOwn);\n        }\n\n        // For chapters and pages, Check if explicit permissions are set on the Book.\n        $book = $this->getBook($entity->book_id);\n        $hasExplicitAccessToParents = $this->mapHasActiveRestriction($permissionMap, $book, $role, $restrictionAction);\n        $hasPermissiveAccessToParents = !$book->restricted;\n\n        // For pages with a chapter, Check if explicit permissions are set on the Chapter\n        if ($entity instanceof Page && intval($entity->chapter_id) !== 0) {\n            $chapter = $this->getChapter($entity->chapter_id);\n            $hasPermissiveAccessToParents = $hasPermissiveAccessToParents && !$chapter->restricted;\n            if ($chapter->restricted) {\n                $hasExplicitAccessToParents = $this->mapHasActiveRestriction($permissionMap, $chapter, $role, $restrictionAction);\n            }\n        }\n\n        return $this->createJointPermissionDataArray(\n            $entity,\n            $role,\n            $action,\n            ($hasExplicitAccessToParents || ($roleHasPermission && $hasPermissiveAccessToParents)),\n            ($hasExplicitAccessToParents || ($roleHasPermissionOwn && $hasPermissiveAccessToParents))\n        );\n    }\n\n    /**\n     * Check for an active restriction in an entity map.\n     */\n    protected function mapHasActiveRestriction(array $entityMap, Entity $entity, Role $role, string $action): bool\n    {\n        $key = $entity->getMorphClass() . ':' . $entity->getRawAttribute('id') . ':' . $role->getRawAttribute('id') . ':' . $action;\n\n        return $entityMap[$key] ?? false;\n    }\n\n    /**\n     * Create an array of data with the information of an entity jointPermissions.\n     * Used to build data for bulk insertion.\n     */\n    protected function createJointPermissionDataArray(Entity $entity, Role $role, string $action, bool $permissionAll, bool $permissionOwn): array\n    {\n        return [\n            'role_id'            => $role->getRawAttribute('id'),\n            'entity_id'          => $entity->getRawAttribute('id'),\n            'entity_type'        => $entity->getMorphClass(),\n            'action'             => $action,\n            'has_permission'     => $permissionAll,\n            'has_permission_own' => $permissionOwn,\n            'owned_by'           => $entity->getRawAttribute('owned_by'),\n        ];\n    }\n\n    /**\n     * Checks if an entity has a restriction set upon it.\n     *\n     * @param HasCreatorAndUpdater|HasOwner $ownable\n     */\n    public function checkOwnableUserAccess(Model $ownable, string $permission): bool\n    {\n        $explodedPermission = explode('-', $permission);\n\n        $baseQuery = $ownable->newQuery()->where('id', '=', $ownable->id);\n        $action = end($explodedPermission);\n        $user = $this->currentUser();\n\n        $nonJointPermissions = ['restrictions', 'image', 'attachment', 'comment'];\n\n        // Handle non entity specific jointPermissions\n        if (in_array($explodedPermission[0], $nonJointPermissions)) {\n            $allPermission = $user && $user->can($permission . '-all');\n            $ownPermission = $user && $user->can($permission . '-own');\n            $ownerField = ($ownable instanceof Entity) ? 'owned_by' : 'created_by';\n            $isOwner = $user && $user->id === $ownable->$ownerField;\n\n            return $allPermission || ($isOwner && $ownPermission);\n        }\n\n        // Handle abnormal create jointPermissions\n        if ($action === 'create') {\n            $action = $permission;\n        }\n\n        $hasAccess = $this->entityRestrictionQuery($baseQuery, $action)->count() > 0;\n        $this->clean();\n\n        return $hasAccess;\n    }\n\n    /**\n     * Checks if a user has the given permission for any items in the system.\n     * Can be passed an entity instance to filter on a specific type.\n     */\n    public function checkUserHasPermissionOnAnything(string $permission, ?string $entityClass = null): bool\n    {\n        $userRoleIds = $this->currentUser()->roles()->select('id')->pluck('id')->toArray();\n        $userId = $this->currentUser()->id;\n\n        $permissionQuery = JointPermission::query()\n            ->where('action', '=', $permission)\n            ->whereIn('role_id', $userRoleIds)\n            ->where(function (Builder $query) use ($userId) {\n                $this->addJointHasPermissionCheck($query, $userId);\n            });\n\n        if (!is_null($entityClass)) {\n            $entityInstance = app($entityClass);\n            $permissionQuery = $permissionQuery->where('entity_type', '=', $entityInstance->getMorphClass());\n        }\n\n        $hasPermission = $permissionQuery->count() > 0;\n        $this->clean();\n\n        return $hasPermission;\n    }\n\n    /**\n     * The general query filter to remove all entities\n     * that the current user does not have access to.\n     */\n    protected function entityRestrictionQuery(Builder $query, string $action): Builder\n    {\n        $q = $query->where(function ($parentQuery) use ($action) {\n            $parentQuery->whereHas('jointPermissions', function ($permissionQuery) use ($action) {\n                $permissionQuery->whereIn('role_id', $this->getCurrentUserRoles())\n                    ->where('action', '=', $action)\n                    ->where(function (Builder $query) {\n                        $this->addJointHasPermissionCheck($query, $this->currentUser()->id);\n                    });\n            });\n        });\n\n        $this->clean();\n\n        return $q;\n    }\n\n    /**\n     * Limited the given entity query so that the query will only\n     * return items that the user has permission for the given ability.\n     */\n    public function restrictEntityQuery(Builder $query, string $ability = 'view'): Builder\n    {\n        $this->clean();\n\n        return $query->where(function (Builder $parentQuery) use ($ability) {\n            $parentQuery->whereHas('jointPermissions', function (Builder $permissionQuery) use ($ability) {\n                $permissionQuery->whereIn('role_id', $this->getCurrentUserRoles())\n                    ->where('action', '=', $ability)\n                    ->where(function (Builder $query) {\n                        $this->addJointHasPermissionCheck($query, $this->currentUser()->id);\n                    });\n            });\n        });\n    }\n\n    /**\n     * Extend the given page query to ensure draft items are not visible\n     * unless created by the given user.\n     */\n    public function enforceDraftVisibilityOnQuery(Builder $query): Builder\n    {\n        return $query->where(function (Builder $query) {\n            $query->where('draft', '=', false)\n                ->orWhere(function (Builder $query) {\n                    $query->where('draft', '=', true)\n                        ->where('owned_by', '=', $this->currentUser()->id);\n                });\n        });\n    }\n\n    /**\n     * Add restrictions for a generic entity.\n     */\n    public function enforceEntityRestrictions(Entity $entity, Builder $query, string $action = 'view'): Builder\n    {\n        if ($entity instanceof Page) {\n            // Prevent drafts being visible to others.\n            $this->enforceDraftVisibilityOnQuery($query);\n        }\n\n        return $this->entityRestrictionQuery($query, $action);\n    }\n\n    /**\n     * Filter items that have entities set as a polymorphic relation.\n     *\n     * @param Builder|QueryBuilder $query\n     */\n    public function filterRestrictedEntityRelations($query, string $tableName, string $entityIdColumn, string $entityTypeColumn, string $action = 'view')\n    {\n        $tableDetails = ['tableName' => $tableName, 'entityIdColumn' => $entityIdColumn, 'entityTypeColumn' => $entityTypeColumn];\n\n        $q = $query->where(function ($query) use ($tableDetails, $action) {\n            $query->whereExists(function ($permissionQuery) use (&$tableDetails, $action) {\n                /** @var Builder $permissionQuery */\n                $permissionQuery->select(['role_id'])->from('joint_permissions')\n                    ->whereColumn('joint_permissions.entity_id', '=', $tableDetails['tableName'] . '.' . $tableDetails['entityIdColumn'])\n                    ->whereColumn('joint_permissions.entity_type', '=', $tableDetails['tableName'] . '.' . $tableDetails['entityTypeColumn'])\n                    ->where('action', '=', $action)\n                    ->whereIn('role_id', $this->getCurrentUserRoles())\n                    ->where(function (QueryBuilder $query) {\n                        $this->addJointHasPermissionCheck($query, $this->currentUser()->id);\n                    });\n            });\n        });\n\n        $this->clean();\n\n        return $q;\n    }\n\n    /**\n     * Add conditions to a query to filter the selection to related entities\n     * where view permissions are granted.\n     */\n    public function filterRelatedEntity(string $entityClass, Builder $query, string $tableName, string $entityIdColumn): Builder\n    {\n        $tableDetails = ['tableName' => $tableName, 'entityIdColumn' => $entityIdColumn];\n        $morphClass = app($entityClass)->getMorphClass();\n\n        $q = $query->where(function ($query) use ($tableDetails, $morphClass) {\n            $query->where(function ($query) use (&$tableDetails, $morphClass) {\n                $query->whereExists(function ($permissionQuery) use (&$tableDetails, $morphClass) {\n                    /** @var Builder $permissionQuery */\n                    $permissionQuery->select('id')->from('joint_permissions')\n                        ->whereColumn('joint_permissions.entity_id', '=', $tableDetails['tableName'] . '.' . $tableDetails['entityIdColumn'])\n                        ->where('entity_type', '=', $morphClass)\n                        ->where('action', '=', 'view')\n                        ->whereIn('role_id', $this->getCurrentUserRoles())\n                        ->where(function (QueryBuilder $query) {\n                            $this->addJointHasPermissionCheck($query, $this->currentUser()->id);\n                        });\n                });\n            })->orWhere($tableDetails['entityIdColumn'], '=', 0);\n        });\n\n        $this->clean();\n\n        return $q;\n    }\n\n    /**\n     * Add the query for checking the given user id has permission\n     * within the join_permissions table.\n     *\n     * @param QueryBuilder|Builder $query\n     */\n    protected function addJointHasPermissionCheck($query, int $userIdToCheck)\n    {\n        $query->where('has_permission', '=', true)->orWhere(function ($query) use ($userIdToCheck) {\n            $query->where('has_permission_own', '=', true)\n                ->where('owned_by', '=', $userIdToCheck);\n        });\n    }\n\n    /**\n     * Get the current user.\n     */\n    private function currentUser(): User\n    {\n        if (is_null($this->currentUserModel)) {\n            $this->currentUserModel = user();\n        }\n\n        return $this->currentUserModel;\n    }\n\n    /**\n     * Clean the cached user elements.\n     */\n    private function clean(): void\n    {\n        $this->currentUserModel = null;\n        $this->userRoles = null;\n    }\n}\n", "<?php\n\nnamespace BookStack\\Exceptions;\n\nuse Exception;\nuse Illuminate\\Auth\\AuthenticationException;\nuse Illuminate\\Foundation\\Exceptions\\Handler as ExceptionHandler;\nuse Illuminate\\Http\\JsonResponse;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Validation\\ValidationException;\nuse Symfony\\Component\\HttpKernel\\Exception\\HttpException;\nuse Throwable;\n\nclass Handler extends ExceptionHandler\n{\n    /**\n     * A list of the exception types that are not reported.\n     *\n     * @var array\n     */\n    protected $dontReport = [\n        NotFoundException::class,\n    ];\n\n    /**\n     * A list of the inputs that are never flashed for validation exceptions.\n     *\n     * @var array\n     */\n    protected $dontFlash = [\n        'current_password',\n        'password',\n        'password_confirmation',\n    ];\n\n    /**\n     * Report or log an exception.\n     *\n     * @param \\Throwable $exception\n     *\n     * @throws \\Throwable\n     *\n     * @return void\n     */\n    public function report(Throwable $exception)\n    {\n        parent::report($exception);\n    }\n\n    /**\n     * Render an exception into an HTTP response.\n     *\n     * @param \\Illuminate\\Http\\Request $request\n     * @param Exception                $e\n     *\n     * @return \\Illuminate\\Http\\Response\n     */\n    public function render($request, Throwable $e)\n    {\n        if ($this->isApiRequest($request)) {\n            return $this->renderApiException($e);\n        }\n\n        return parent::render($request, $e);\n    }\n\n    /**\n     * Check if the given request is an API request.\n     */\n    protected function isApiRequest(Request $request): bool\n    {\n        return strpos($request->path(), 'api/') === 0;\n    }\n\n    /**\n     * Render an exception when the API is in use.\n     */\n    protected function renderApiException(Exception $e): JsonResponse\n    {\n        $code = $e->getCode() === 0 ? 500 : $e->getCode();\n        $headers = [];\n        if ($e instanceof HttpException) {\n            $code = $e->getStatusCode();\n            $headers = $e->getHeaders();\n        }\n\n        $responseData = [\n            'error' => [\n                'message' => $e->getMessage(),\n            ],\n        ];\n\n        if ($e instanceof ValidationException) {\n            $responseData['error']['validation'] = $e->errors();\n            $code = $e->status;\n        }\n\n        $responseData['error']['code'] = $code;\n\n        return new JsonResponse($responseData, $code, $headers);\n    }\n\n    /**\n     * Convert an authentication exception into an unauthenticated response.\n     *\n     * @param \\Illuminate\\Http\\Request                 $request\n     * @param \\Illuminate\\Auth\\AuthenticationException $exception\n     *\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function unauthenticated($request, AuthenticationException $exception)\n    {\n        if ($request->expectsJson()) {\n            return response()->json(['error' => 'Unauthenticated.'], 401);\n        }\n\n        return redirect()->guest('login');\n    }\n\n    /**\n     * Convert a validation exception into a JSON response.\n     *\n     * @param \\Illuminate\\Http\\Request                   $request\n     * @param \\Illuminate\\Validation\\ValidationException $exception\n     *\n     * @return \\Illuminate\\Http\\JsonResponse\n     */\n    protected function invalidJson($request, ValidationException $exception)\n    {\n        return response()->json($exception->errors(), $exception->status);\n    }\n}\n", "<?php\n\nnamespace Tests\\Api;\n\nuse BookStack\\Entities\\Models\\Page;\nuse BookStack\\Uploads\\Attachment;\nuse Illuminate\\Http\\UploadedFile;\nuse Tests\\TestCase;\n\nclass AttachmentsApiTest extends TestCase\n{\n    use TestsApi;\n\n    protected $baseEndpoint = '/api/attachments';\n\n    public function test_index_endpoint_returns_expected_book()\n    {\n        $this->actingAsApiEditor();\n        $page = Page::query()->first();\n        $attachment = $this->createAttachmentForPage($page, [\n            'name'     => 'My test attachment',\n            'external' => true,\n        ]);\n\n        $resp = $this->getJson($this->baseEndpoint . '?count=1&sort=+id');\n        $resp->assertJson(['data' => [\n            [\n                'id'          => $attachment->id,\n                'name'        => 'My test attachment',\n                'uploaded_to' => $page->id,\n                'external'    => true,\n            ],\n        ]]);\n    }\n\n    public function test_attachments_listing_based_upon_page_visibility()\n    {\n        $this->actingAsApiEditor();\n        /** @var Page $page */\n        $page = Page::query()->first();\n        $attachment = $this->createAttachmentForPage($page, [\n            'name'     => 'My test attachment',\n            'external' => true,\n        ]);\n\n        $resp = $this->getJson($this->baseEndpoint . '?count=1&sort=+id');\n        $resp->assertJson(['data' => [\n            [\n                'id' => $attachment->id,\n            ],\n        ]]);\n\n        $page->restricted = true;\n        $page->save();\n        $this->regenEntityPermissions($page);\n\n        $resp = $this->getJson($this->baseEndpoint . '?count=1&sort=+id');\n        $resp->assertJsonMissing(['data' => [\n            [\n                'id' => $attachment->id,\n            ],\n        ]]);\n    }\n\n    public function test_create_endpoint_for_link_attachment()\n    {\n        $this->actingAsApiAdmin();\n        /** @var Page $page */\n        $page = Page::query()->first();\n\n        $details = [\n            'name'        => 'My attachment',\n            'uploaded_to' => $page->id,\n            'link'        => 'https://cats.example.com',\n        ];\n\n        $resp = $this->postJson($this->baseEndpoint, $details);\n        $resp->assertStatus(200);\n        /** @var Attachment $newItem */\n        $newItem = Attachment::query()->orderByDesc('id')->where('name', '=', $details['name'])->first();\n        $resp->assertJson(['id' => $newItem->id, 'external' => true, 'name' => $details['name'], 'uploaded_to' => $page->id]);\n    }\n\n    public function test_create_endpoint_for_upload_attachment()\n    {\n        $this->actingAsApiAdmin();\n        /** @var Page $page */\n        $page = Page::query()->first();\n        $file = $this->getTestFile('textfile.txt');\n\n        $details = [\n            'name'        => 'My attachment',\n            'uploaded_to' => $page->id,\n        ];\n\n        $resp = $this->call('POST', $this->baseEndpoint, $details, [], ['file' => $file]);\n        $resp->assertStatus(200);\n        /** @var Attachment $newItem */\n        $newItem = Attachment::query()->orderByDesc('id')->where('name', '=', $details['name'])->first();\n        $resp->assertJson(['id' => $newItem->id, 'external' => false, 'extension' => 'txt', 'name' => $details['name'], 'uploaded_to' => $page->id]);\n        $this->assertTrue(file_exists(storage_path($newItem->path)));\n        unlink(storage_path($newItem->path));\n    }\n\n    public function test_name_needed_to_create()\n    {\n        $this->actingAsApiAdmin();\n        /** @var Page $page */\n        $page = Page::query()->first();\n\n        $details = [\n            'uploaded_to' => $page->id,\n            'link'        => 'https://example.com',\n        ];\n\n        $resp = $this->postJson($this->baseEndpoint, $details);\n        $resp->assertStatus(422);\n        $resp->assertJson([\n            'error' => [\n                'message'    => 'The given data was invalid.',\n                'validation' => [\n                    'name' => ['The name field is required.'],\n                ],\n                'code' => 422,\n            ],\n        ]);\n    }\n\n    public function test_link_or_file_needed_to_create()\n    {\n        $this->actingAsApiAdmin();\n        /** @var Page $page */\n        $page = Page::query()->first();\n\n        $details = [\n            'name'        => 'my attachment',\n            'uploaded_to' => $page->id,\n        ];\n\n        $resp = $this->postJson($this->baseEndpoint, $details);\n        $resp->assertStatus(422);\n        $resp->assertJson([\n            'error' => [\n                'message'    => 'The given data was invalid.',\n                'validation' => [\n                    'file' => ['The file field is required when link is not present.'],\n                    'link' => ['The link field is required when file is not present.'],\n                ],\n                'code' => 422,\n            ],\n        ]);\n    }\n\n    public function test_read_endpoint_for_link_attachment()\n    {\n        $this->actingAsApiAdmin();\n        /** @var Page $page */\n        $page = Page::query()->first();\n\n        $attachment = $this->createAttachmentForPage($page, [\n            'name'  => 'my attachment',\n            'path'  => 'https://example.com',\n            'order' => 1,\n        ]);\n\n        $resp = $this->getJson(\"{$this->baseEndpoint}/{$attachment->id}\");\n\n        $resp->assertStatus(200);\n        $resp->assertJson([\n            'id'          => $attachment->id,\n            'content'     => 'https://example.com',\n            'external'    => true,\n            'uploaded_to' => $page->id,\n            'order'       => 1,\n            'created_by'  => [\n                'name' => $attachment->createdBy->name,\n            ],\n            'updated_by' => [\n                'name' => $attachment->createdBy->name,\n            ],\n            'links' => [\n                'html'     => \"<a target=\\\"_blank\\\" href=\\\"http://localhost/attachments/{$attachment->id}\\\">my attachment</a>\",\n                'markdown' => \"[my attachment](http://localhost/attachments/{$attachment->id})\",\n            ],\n        ]);\n    }\n\n    public function test_read_endpoint_for_file_attachment()\n    {\n        $this->actingAsApiAdmin();\n        /** @var Page $page */\n        $page = Page::query()->first();\n        $file = $this->getTestFile('textfile.txt');\n\n        $details = [\n            'name'        => 'My file attachment',\n            'uploaded_to' => $page->id,\n        ];\n        $this->call('POST', $this->baseEndpoint, $details, [], ['file' => $file]);\n        /** @var Attachment $attachment */\n        $attachment = Attachment::query()->orderByDesc('id')->where('name', '=', $details['name'])->firstOrFail();\n\n        $resp = $this->getJson(\"{$this->baseEndpoint}/{$attachment->id}\");\n\n        $resp->assertStatus(200);\n        $resp->assertJson([\n            'id'          => $attachment->id,\n            'content'     => base64_encode(file_get_contents(storage_path($attachment->path))),\n            'external'    => false,\n            'uploaded_to' => $page->id,\n            'order'       => 1,\n            'created_by'  => [\n                'name' => $attachment->createdBy->name,\n            ],\n            'updated_by' => [\n                'name' => $attachment->updatedBy->name,\n            ],\n            'links' => [\n                'html'     => \"<a target=\\\"_blank\\\" href=\\\"http://localhost/attachments/{$attachment->id}\\\">My file attachment</a>\",\n                'markdown' => \"[My file attachment](http://localhost/attachments/{$attachment->id})\",\n            ],\n        ]);\n\n        unlink(storage_path($attachment->path));\n    }\n\n    public function test_update_endpoint()\n    {\n        $this->actingAsApiAdmin();\n        /** @var Page $page */\n        $page = Page::query()->first();\n        $attachment = $this->createAttachmentForPage($page);\n\n        $details = [\n            'name' => 'My updated API attachment',\n        ];\n\n        $resp = $this->putJson(\"{$this->baseEndpoint}/{$attachment->id}\", $details);\n        $attachment->refresh();\n\n        $resp->assertStatus(200);\n        $resp->assertJson(['id' => $attachment->id, 'name' => 'My updated API attachment']);\n    }\n\n    public function test_update_link_attachment_to_file()\n    {\n        $this->actingAsApiAdmin();\n        /** @var Page $page */\n        $page = Page::query()->first();\n        $attachment = $this->createAttachmentForPage($page);\n        $file = $this->getTestFile('textfile.txt');\n\n        $resp = $this->call('PUT', \"{$this->baseEndpoint}/{$attachment->id}\", ['name' => 'My updated file'], [], ['file' => $file]);\n        $resp->assertStatus(200);\n\n        $attachment->refresh();\n        $this->assertFalse($attachment->external);\n        $this->assertEquals('txt', $attachment->extension);\n        $this->assertStringStartsWith('uploads/files/', $attachment->path);\n        $this->assertFileExists(storage_path($attachment->path));\n\n        unlink(storage_path($attachment->path));\n    }\n\n    public function test_update_file_attachment_to_link()\n    {\n        $this->actingAsApiAdmin();\n        /** @var Page $page */\n        $page = Page::query()->first();\n        $file = $this->getTestFile('textfile.txt');\n        $this->call('POST', $this->baseEndpoint, ['name' => 'My file attachment', 'uploaded_to' => $page->id], [], ['file' => $file]);\n        /** @var Attachment $attachment */\n        $attachment = Attachment::query()->where('name', '=', 'My file attachment')->firstOrFail();\n\n        $filePath = storage_path($attachment->path);\n        $this->assertFileExists($filePath);\n\n        $details = [\n            'name' => 'My updated API attachment',\n            'link' => 'https://cats.example.com',\n        ];\n\n        $resp = $this->putJson(\"{$this->baseEndpoint}/{$attachment->id}\", $details);\n        $resp->assertStatus(200);\n        $attachment->refresh();\n\n        $this->assertFileDoesNotExist($filePath);\n        $this->assertTrue($attachment->external);\n        $this->assertEquals('https://cats.example.com', $attachment->path);\n        $this->assertEquals('', $attachment->extension);\n    }\n\n    public function test_delete_endpoint()\n    {\n        $this->actingAsApiAdmin();\n        /** @var Page $page */\n        $page = Page::query()->first();\n        $attachment = $this->createAttachmentForPage($page);\n\n        $resp = $this->deleteJson(\"{$this->baseEndpoint}/{$attachment->id}\");\n\n        $resp->assertStatus(204);\n        $this->assertDatabaseMissing('attachments', ['id' => $attachment->id]);\n    }\n\n    protected function createAttachmentForPage(Page $page, $attributes = []): Attachment\n    {\n        $admin = $this->getAdmin();\n        /** @var Attachment $attachment */\n        $attachment = $page->attachments()->forceCreate(array_merge([\n            'uploaded_to' => $page->id,\n            'name'        => 'test attachment',\n            'external'    => true,\n            'order'       => 1,\n            'created_by'  => $admin->id,\n            'updated_by'  => $admin->id,\n            'path'        => 'https://attachment.example.com',\n        ], $attributes));\n\n        return $attachment;\n    }\n\n    /**\n     * Get a test file that can be uploaded.\n     */\n    protected function getTestFile(string $fileName): UploadedFile\n    {\n        return new UploadedFile(base_path('tests/test-data/test-file.txt'), $fileName, 'text/plain', null, true);\n    }\n}\n"], "fixing_code": ["<?php\n\nnamespace BookStack\\Actions;\n\nuse BookStack\\Auth\\Permissions\\PermissionService;\nuse BookStack\\Auth\\User;\nuse BookStack\\Entities\\Models\\Book;\nuse BookStack\\Entities\\Models\\Chapter;\nuse BookStack\\Entities\\Models\\Entity;\nuse BookStack\\Entities\\Models\\Page;\nuse BookStack\\Interfaces\\Loggable;\nuse Illuminate\\Database\\Eloquent\\Builder;\nuse Illuminate\\Database\\Eloquent\\Relations\\Relation;\nuse Illuminate\\Support\\Facades\\Log;\n\nclass ActivityService\n{\n    protected $activity;\n    protected $permissionService;\n\n    public function __construct(Activity $activity, PermissionService $permissionService)\n    {\n        $this->activity = $activity;\n        $this->permissionService = $permissionService;\n    }\n\n    /**\n     * Add activity data to database for an entity.\n     */\n    public function addForEntity(Entity $entity, string $type)\n    {\n        $activity = $this->newActivityForUser($type);\n        $entity->activity()->save($activity);\n        $this->setNotification($type);\n    }\n\n    /**\n     * Add a generic activity event to the database.\n     *\n     * @param string|Loggable $detail\n     */\n    public function add(string $type, $detail = '')\n    {\n        if ($detail instanceof Loggable) {\n            $detail = $detail->logDescriptor();\n        }\n\n        $activity = $this->newActivityForUser($type);\n        $activity->detail = $detail;\n        $activity->save();\n        $this->setNotification($type);\n    }\n\n    /**\n     * Get a new activity instance for the current user.\n     */\n    protected function newActivityForUser(string $type): Activity\n    {\n        $ip = request()->ip() ?? '';\n\n        return $this->activity->newInstance()->forceFill([\n            'type'     => strtolower($type),\n            'user_id'  => user()->id,\n            'ip'       => config('app.env') === 'demo' ? '127.0.0.1' : $ip,\n        ]);\n    }\n\n    /**\n     * Removes the entity attachment from each of its activities\n     * and instead uses the 'extra' field with the entities name.\n     * Used when an entity is deleted.\n     */\n    public function removeEntity(Entity $entity)\n    {\n        $entity->activity()->update([\n            'detail'       => $entity->name,\n            'entity_id'    => null,\n            'entity_type'  => null,\n        ]);\n    }\n\n    /**\n     * Gets the latest activity.\n     */\n    public function latest(int $count = 20, int $page = 0): array\n    {\n        $activityList = $this->permissionService\n            ->filterRestrictedEntityRelations($this->activity->newQuery(), 'activities', 'entity_id', 'entity_type')\n            ->orderBy('created_at', 'desc')\n            ->with(['user', 'entity'])\n            ->skip($count * $page)\n            ->take($count)\n            ->get();\n\n        return $this->filterSimilar($activityList);\n    }\n\n    /**\n     * Gets the latest activity for an entity, Filtering out similar\n     * items to prevent a message activity list.\n     */\n    public function entityActivity(Entity $entity, int $count = 20, int $page = 1): array\n    {\n        /** @var array<string, int[]> $queryIds */\n        $queryIds = [$entity->getMorphClass() => [$entity->id]];\n\n        if ($entity instanceof Book) {\n            $queryIds[(new Chapter())->getMorphClass()] = $entity->chapters()->scopes('visible')->pluck('id');\n        }\n        if ($entity instanceof Book || $entity instanceof Chapter) {\n            $queryIds[(new Page())->getMorphClass()] = $entity->pages()->scopes('visible')->pluck('id');\n        }\n\n        $query = $this->activity->newQuery();\n        $query->where(function (Builder $query) use ($queryIds) {\n            foreach ($queryIds as $morphClass => $idArr) {\n                $query->orWhere(function (Builder $innerQuery) use ($morphClass, $idArr) {\n                    $innerQuery->where('entity_type', '=', $morphClass)\n                        ->whereIn('entity_id', $idArr);\n                });\n            }\n        });\n\n        $activity = $query->orderBy('created_at', 'desc')\n            ->with(['entity' => function (Relation $query) {\n                $query->withTrashed();\n            }, 'user.avatar'])\n            ->skip($count * ($page - 1))\n            ->take($count)\n            ->get();\n\n        return $this->filterSimilar($activity);\n    }\n\n    /**\n     * Get the latest activity for a user, Filtering out similar items.\n     */\n    public function userActivity(User $user, int $count = 20, int $page = 0): array\n    {\n        $activityList = $this->permissionService\n            ->filterRestrictedEntityRelations($this->activity->newQuery(), 'activities', 'entity_id', 'entity_type')\n            ->orderBy('created_at', 'desc')\n            ->where('user_id', '=', $user->id)\n            ->skip($count * $page)\n            ->take($count)\n            ->get();\n\n        return $this->filterSimilar($activityList);\n    }\n\n    /**\n     * Filters out similar activity.\n     *\n     * @param Activity[] $activities\n     *\n     * @return array\n     */\n    protected function filterSimilar(iterable $activities): array\n    {\n        $newActivity = [];\n        $previousItem = null;\n\n        foreach ($activities as $activityItem) {\n            if (!$previousItem || !$activityItem->isSimilarTo($previousItem)) {\n                $newActivity[] = $activityItem;\n            }\n\n            $previousItem = $activityItem;\n        }\n\n        return $newActivity;\n    }\n\n    /**\n     * Flashes a notification message to the session if an appropriate message is available.\n     */\n    protected function setNotification(string $type)\n    {\n        $notificationTextKey = 'activities.' . $type . '_notification';\n        if (trans()->has($notificationTextKey)) {\n            $message = trans($notificationTextKey);\n            session()->flash('success', $message);\n        }\n    }\n\n    /**\n     * Log out a failed login attempt, Providing the given username\n     * as part of the message if the '%u' string is used.\n     */\n    public function logFailedLogin(string $username)\n    {\n        $message = config('logging.failed_login.message');\n        if (!$message) {\n            return;\n        }\n\n        $message = str_replace('%u', $username, $message);\n        $channel = config('logging.failed_login.channel');\n        Log::channel($channel)->warning($message);\n    }\n}\n", "<?php\n\nnamespace BookStack\\Auth\\Permissions;\n\nuse BookStack\\Auth\\Role;\nuse BookStack\\Auth\\User;\nuse BookStack\\Entities\\Models\\Book;\nuse BookStack\\Entities\\Models\\BookChild;\nuse BookStack\\Entities\\Models\\Bookshelf;\nuse BookStack\\Entities\\Models\\Chapter;\nuse BookStack\\Entities\\Models\\Entity;\nuse BookStack\\Entities\\Models\\Page;\nuse BookStack\\Model;\nuse BookStack\\Traits\\HasCreatorAndUpdater;\nuse BookStack\\Traits\\HasOwner;\nuse Illuminate\\Database\\Connection;\nuse Illuminate\\Database\\Eloquent\\Builder;\nuse Illuminate\\Database\\Eloquent\\Collection as EloquentCollection;\nuse Illuminate\\Database\\Query\\Builder as QueryBuilder;\nuse Throwable;\n\nclass PermissionService\n{\n    /**\n     * @var ?array\n     */\n    protected $userRoles = null;\n\n    /**\n     * @var ?User\n     */\n    protected $currentUserModel = null;\n\n    /**\n     * @var Connection\n     */\n    protected $db;\n\n    /**\n     * @var array\n     */\n    protected $entityCache;\n\n    /**\n     * PermissionService constructor.\n     */\n    public function __construct(Connection $db)\n    {\n        $this->db = $db;\n    }\n\n    /**\n     * Set the database connection.\n     */\n    public function setConnection(Connection $connection)\n    {\n        $this->db = $connection;\n    }\n\n    /**\n     * Prepare the local entity cache and ensure it's empty.\n     *\n     * @param Entity[] $entities\n     */\n    protected function readyEntityCache(array $entities = [])\n    {\n        $this->entityCache = [];\n\n        foreach ($entities as $entity) {\n            $class = get_class($entity);\n            if (!isset($this->entityCache[$class])) {\n                $this->entityCache[$class] = collect();\n            }\n            $this->entityCache[$class]->put($entity->id, $entity);\n        }\n    }\n\n    /**\n     * Get a book via ID, Checks local cache.\n     */\n    protected function getBook(int $bookId): ?Book\n    {\n        if (isset($this->entityCache[Book::class]) && $this->entityCache[Book::class]->has($bookId)) {\n            return $this->entityCache[Book::class]->get($bookId);\n        }\n\n        return Book::query()->withTrashed()->find($bookId);\n    }\n\n    /**\n     * Get a chapter via ID, Checks local cache.\n     */\n    protected function getChapter(int $chapterId): ?Chapter\n    {\n        if (isset($this->entityCache[Chapter::class]) && $this->entityCache[Chapter::class]->has($chapterId)) {\n            return $this->entityCache[Chapter::class]->get($chapterId);\n        }\n\n        return Chapter::query()\n            ->withTrashed()\n            ->find($chapterId);\n    }\n\n    /**\n     * Get the roles for the current logged in user.\n     */\n    protected function getCurrentUserRoles(): array\n    {\n        if (!is_null($this->userRoles)) {\n            return $this->userRoles;\n        }\n\n        if (auth()->guest()) {\n            $this->userRoles = [Role::getSystemRole('public')->id];\n        } else {\n            $this->userRoles = $this->currentUser()->roles->pluck('id')->values()->all();\n        }\n\n        return $this->userRoles;\n    }\n\n    /**\n     * Re-generate all entity permission from scratch.\n     */\n    public function buildJointPermissions()\n    {\n        JointPermission::query()->truncate();\n        $this->readyEntityCache();\n\n        // Get all roles (Should be the most limited dimension)\n        $roles = Role::query()->with('permissions')->get()->all();\n\n        // Chunk through all books\n        $this->bookFetchQuery()->chunk(5, function (EloquentCollection $books) use ($roles) {\n            $this->buildJointPermissionsForBooks($books, $roles);\n        });\n\n        // Chunk through all bookshelves\n        Bookshelf::query()->withTrashed()->select(['id', 'restricted', 'owned_by'])\n            ->chunk(50, function (EloquentCollection $shelves) use ($roles) {\n                $this->buildJointPermissionsForShelves($shelves, $roles);\n            });\n    }\n\n    /**\n     * Get a query for fetching a book with it's children.\n     */\n    protected function bookFetchQuery(): Builder\n    {\n        return Book::query()->withTrashed()\n            ->select(['id', 'restricted', 'owned_by'])->with([\n                'chapters' => function ($query) {\n                    $query->withTrashed()->select(['id', 'restricted', 'owned_by', 'book_id']);\n                },\n                'pages' => function ($query) {\n                    $query->withTrashed()->select(['id', 'restricted', 'owned_by', 'book_id', 'chapter_id']);\n                },\n            ]);\n    }\n\n    /**\n     * Build joint permissions for the given shelf and role combinations.\n     *\n     * @throws Throwable\n     */\n    protected function buildJointPermissionsForShelves(EloquentCollection $shelves, array $roles, bool $deleteOld = false)\n    {\n        if ($deleteOld) {\n            $this->deleteManyJointPermissionsForEntities($shelves->all());\n        }\n        $this->createManyJointPermissions($shelves->all(), $roles);\n    }\n\n    /**\n     * Build joint permissions for the given book and role combinations.\n     *\n     * @throws Throwable\n     */\n    protected function buildJointPermissionsForBooks(EloquentCollection $books, array $roles, bool $deleteOld = false)\n    {\n        $entities = clone $books;\n\n        /** @var Book $book */\n        foreach ($books->all() as $book) {\n            foreach ($book->getRelation('chapters') as $chapter) {\n                $entities->push($chapter);\n            }\n            foreach ($book->getRelation('pages') as $page) {\n                $entities->push($page);\n            }\n        }\n\n        if ($deleteOld) {\n            $this->deleteManyJointPermissionsForEntities($entities->all());\n        }\n        $this->createManyJointPermissions($entities->all(), $roles);\n    }\n\n    /**\n     * Rebuild the entity jointPermissions for a particular entity.\n     *\n     * @throws Throwable\n     */\n    public function buildJointPermissionsForEntity(Entity $entity)\n    {\n        $entities = [$entity];\n        if ($entity instanceof Book) {\n            $books = $this->bookFetchQuery()->where('id', '=', $entity->id)->get();\n            $this->buildJointPermissionsForBooks($books, Role::query()->get()->all(), true);\n\n            return;\n        }\n\n        /** @var BookChild $entity */\n        if ($entity->book) {\n            $entities[] = $entity->book;\n        }\n\n        if ($entity instanceof Page && $entity->chapter_id) {\n            $entities[] = $entity->chapter;\n        }\n\n        if ($entity instanceof Chapter) {\n            foreach ($entity->pages as $page) {\n                $entities[] = $page;\n            }\n        }\n\n        $this->buildJointPermissionsForEntities($entities);\n    }\n\n    /**\n     * Rebuild the entity jointPermissions for a collection of entities.\n     *\n     * @throws Throwable\n     */\n    public function buildJointPermissionsForEntities(array $entities)\n    {\n        $roles = Role::query()->get()->values()->all();\n        $this->deleteManyJointPermissionsForEntities($entities);\n        $this->createManyJointPermissions($entities, $roles);\n    }\n\n    /**\n     * Build the entity jointPermissions for a particular role.\n     */\n    public function buildJointPermissionForRole(Role $role)\n    {\n        $roles = [$role];\n        $this->deleteManyJointPermissionsForRoles($roles);\n\n        // Chunk through all books\n        $this->bookFetchQuery()->chunk(20, function ($books) use ($roles) {\n            $this->buildJointPermissionsForBooks($books, $roles);\n        });\n\n        // Chunk through all bookshelves\n        Bookshelf::query()->select(['id', 'restricted', 'owned_by'])\n            ->chunk(50, function ($shelves) use ($roles) {\n                $this->buildJointPermissionsForShelves($shelves, $roles);\n            });\n    }\n\n    /**\n     * Delete the entity jointPermissions attached to a particular role.\n     */\n    public function deleteJointPermissionsForRole(Role $role)\n    {\n        $this->deleteManyJointPermissionsForRoles([$role]);\n    }\n\n    /**\n     * Delete all of the entity jointPermissions for a list of entities.\n     *\n     * @param Role[] $roles\n     */\n    protected function deleteManyJointPermissionsForRoles($roles)\n    {\n        $roleIds = array_map(function ($role) {\n            return $role->id;\n        }, $roles);\n        JointPermission::query()->whereIn('role_id', $roleIds)->delete();\n    }\n\n    /**\n     * Delete the entity jointPermissions for a particular entity.\n     *\n     * @param Entity $entity\n     *\n     * @throws Throwable\n     */\n    public function deleteJointPermissionsForEntity(Entity $entity)\n    {\n        $this->deleteManyJointPermissionsForEntities([$entity]);\n    }\n\n    /**\n     * Delete all of the entity jointPermissions for a list of entities.\n     *\n     * @param Entity[] $entities\n     *\n     * @throws Throwable\n     */\n    protected function deleteManyJointPermissionsForEntities(array $entities)\n    {\n        if (count($entities) === 0) {\n            return;\n        }\n\n        $this->db->transaction(function () use ($entities) {\n            foreach (array_chunk($entities, 1000) as $entityChunk) {\n                $query = $this->db->table('joint_permissions');\n                foreach ($entityChunk as $entity) {\n                    $query->orWhere(function (QueryBuilder $query) use ($entity) {\n                        $query->where('entity_id', '=', $entity->id)\n                            ->where('entity_type', '=', $entity->getMorphClass());\n                    });\n                }\n                $query->delete();\n            }\n        });\n    }\n\n    /**\n     * Create & Save entity jointPermissions for many entities and roles.\n     *\n     * @param Entity[] $entities\n     * @param Role[]   $roles\n     *\n     * @throws Throwable\n     */\n    protected function createManyJointPermissions(array $entities, array $roles)\n    {\n        $this->readyEntityCache($entities);\n        $jointPermissions = [];\n\n        // Fetch Entity Permissions and create a mapping of entity restricted statuses\n        $entityRestrictedMap = [];\n        $permissionFetch = EntityPermission::query();\n        foreach ($entities as $entity) {\n            $entityRestrictedMap[$entity->getMorphClass() . ':' . $entity->id] = boolval($entity->getRawAttribute('restricted'));\n            $permissionFetch->orWhere(function ($query) use ($entity) {\n                $query->where('restrictable_id', '=', $entity->id)->where('restrictable_type', '=', $entity->getMorphClass());\n            });\n        }\n        $permissions = $permissionFetch->get();\n\n        // Create a mapping of explicit entity permissions\n        $permissionMap = [];\n        foreach ($permissions as $permission) {\n            $key = $permission->restrictable_type . ':' . $permission->restrictable_id . ':' . $permission->role_id . ':' . $permission->action;\n            $isRestricted = $entityRestrictedMap[$permission->restrictable_type . ':' . $permission->restrictable_id];\n            $permissionMap[$key] = $isRestricted;\n        }\n\n        // Create a mapping of role permissions\n        $rolePermissionMap = [];\n        foreach ($roles as $role) {\n            foreach ($role->permissions as $permission) {\n                $rolePermissionMap[$role->getRawAttribute('id') . ':' . $permission->getRawAttribute('name')] = true;\n            }\n        }\n\n        // Create Joint Permission Data\n        foreach ($entities as $entity) {\n            foreach ($roles as $role) {\n                foreach ($this->getActions($entity) as $action) {\n                    $jointPermissions[] = $this->createJointPermissionData($entity, $role, $action, $permissionMap, $rolePermissionMap);\n                }\n            }\n        }\n\n        $this->db->transaction(function () use ($jointPermissions) {\n            foreach (array_chunk($jointPermissions, 1000) as $jointPermissionChunk) {\n                $this->db->table('joint_permissions')->insert($jointPermissionChunk);\n            }\n        });\n    }\n\n    /**\n     * Get the actions related to an entity.\n     */\n    protected function getActions(Entity $entity): array\n    {\n        $baseActions = ['view', 'update', 'delete'];\n        if ($entity instanceof Chapter || $entity instanceof Book) {\n            $baseActions[] = 'page-create';\n        }\n        if ($entity instanceof Book) {\n            $baseActions[] = 'chapter-create';\n        }\n\n        return $baseActions;\n    }\n\n    /**\n     * Create entity permission data for an entity and role\n     * for a particular action.\n     */\n    protected function createJointPermissionData(Entity $entity, Role $role, string $action, array $permissionMap, array $rolePermissionMap): array\n    {\n        $permissionPrefix = (strpos($action, '-') === false ? ($entity->getType() . '-') : '') . $action;\n        $roleHasPermission = isset($rolePermissionMap[$role->getRawAttribute('id') . ':' . $permissionPrefix . '-all']);\n        $roleHasPermissionOwn = isset($rolePermissionMap[$role->getRawAttribute('id') . ':' . $permissionPrefix . '-own']);\n        $explodedAction = explode('-', $action);\n        $restrictionAction = end($explodedAction);\n\n        if ($role->system_name === 'admin') {\n            return $this->createJointPermissionDataArray($entity, $role, $action, true, true);\n        }\n\n        if ($entity->restricted) {\n            $hasAccess = $this->mapHasActiveRestriction($permissionMap, $entity, $role, $restrictionAction);\n\n            return $this->createJointPermissionDataArray($entity, $role, $action, $hasAccess, $hasAccess);\n        }\n\n        if ($entity instanceof Book || $entity instanceof Bookshelf) {\n            return $this->createJointPermissionDataArray($entity, $role, $action, $roleHasPermission, $roleHasPermissionOwn);\n        }\n\n        // For chapters and pages, Check if explicit permissions are set on the Book.\n        $book = $this->getBook($entity->book_id);\n        $hasExplicitAccessToParents = $this->mapHasActiveRestriction($permissionMap, $book, $role, $restrictionAction);\n        $hasPermissiveAccessToParents = !$book->restricted;\n\n        // For pages with a chapter, Check if explicit permissions are set on the Chapter\n        if ($entity instanceof Page && intval($entity->chapter_id) !== 0) {\n            $chapter = $this->getChapter($entity->chapter_id);\n            $hasPermissiveAccessToParents = $hasPermissiveAccessToParents && !$chapter->restricted;\n            if ($chapter->restricted) {\n                $hasExplicitAccessToParents = $this->mapHasActiveRestriction($permissionMap, $chapter, $role, $restrictionAction);\n            }\n        }\n\n        return $this->createJointPermissionDataArray(\n            $entity,\n            $role,\n            $action,\n            ($hasExplicitAccessToParents || ($roleHasPermission && $hasPermissiveAccessToParents)),\n            ($hasExplicitAccessToParents || ($roleHasPermissionOwn && $hasPermissiveAccessToParents))\n        );\n    }\n\n    /**\n     * Check for an active restriction in an entity map.\n     */\n    protected function mapHasActiveRestriction(array $entityMap, Entity $entity, Role $role, string $action): bool\n    {\n        $key = $entity->getMorphClass() . ':' . $entity->getRawAttribute('id') . ':' . $role->getRawAttribute('id') . ':' . $action;\n\n        return $entityMap[$key] ?? false;\n    }\n\n    /**\n     * Create an array of data with the information of an entity jointPermissions.\n     * Used to build data for bulk insertion.\n     */\n    protected function createJointPermissionDataArray(Entity $entity, Role $role, string $action, bool $permissionAll, bool $permissionOwn): array\n    {\n        return [\n            'role_id'            => $role->getRawAttribute('id'),\n            'entity_id'          => $entity->getRawAttribute('id'),\n            'entity_type'        => $entity->getMorphClass(),\n            'action'             => $action,\n            'has_permission'     => $permissionAll,\n            'has_permission_own' => $permissionOwn,\n            'owned_by'           => $entity->getRawAttribute('owned_by'),\n        ];\n    }\n\n    /**\n     * Checks if an entity has a restriction set upon it.\n     *\n     * @param HasCreatorAndUpdater|HasOwner $ownable\n     */\n    public function checkOwnableUserAccess(Model $ownable, string $permission): bool\n    {\n        $explodedPermission = explode('-', $permission);\n\n        $baseQuery = $ownable->newQuery()->where('id', '=', $ownable->id);\n        $action = end($explodedPermission);\n        $user = $this->currentUser();\n\n        $nonJointPermissions = ['restrictions', 'image', 'attachment', 'comment'];\n\n        // Handle non entity specific jointPermissions\n        if (in_array($explodedPermission[0], $nonJointPermissions)) {\n            $allPermission = $user && $user->can($permission . '-all');\n            $ownPermission = $user && $user->can($permission . '-own');\n            $ownerField = ($ownable instanceof Entity) ? 'owned_by' : 'created_by';\n            $isOwner = $user && $user->id === $ownable->$ownerField;\n\n            return $allPermission || ($isOwner && $ownPermission);\n        }\n\n        // Handle abnormal create jointPermissions\n        if ($action === 'create') {\n            $action = $permission;\n        }\n\n        $hasAccess = $this->entityRestrictionQuery($baseQuery, $action)->count() > 0;\n        $this->clean();\n\n        return $hasAccess;\n    }\n\n    /**\n     * Checks if a user has the given permission for any items in the system.\n     * Can be passed an entity instance to filter on a specific type.\n     */\n    public function checkUserHasPermissionOnAnything(string $permission, ?string $entityClass = null): bool\n    {\n        $userRoleIds = $this->currentUser()->roles()->select('id')->pluck('id')->toArray();\n        $userId = $this->currentUser()->id;\n\n        $permissionQuery = JointPermission::query()\n            ->where('action', '=', $permission)\n            ->whereIn('role_id', $userRoleIds)\n            ->where(function (Builder $query) use ($userId) {\n                $this->addJointHasPermissionCheck($query, $userId);\n            });\n\n        if (!is_null($entityClass)) {\n            $entityInstance = app($entityClass);\n            $permissionQuery = $permissionQuery->where('entity_type', '=', $entityInstance->getMorphClass());\n        }\n\n        $hasPermission = $permissionQuery->count() > 0;\n        $this->clean();\n\n        return $hasPermission;\n    }\n\n    /**\n     * The general query filter to remove all entities\n     * that the current user does not have access to.\n     */\n    protected function entityRestrictionQuery(Builder $query, string $action): Builder\n    {\n        $q = $query->where(function ($parentQuery) use ($action) {\n            $parentQuery->whereHas('jointPermissions', function ($permissionQuery) use ($action) {\n                $permissionQuery->whereIn('role_id', $this->getCurrentUserRoles())\n                    ->where('action', '=', $action)\n                    ->where(function (Builder $query) {\n                        $this->addJointHasPermissionCheck($query, $this->currentUser()->id);\n                    });\n            });\n        });\n\n        $this->clean();\n\n        return $q;\n    }\n\n    /**\n     * Limited the given entity query so that the query will only\n     * return items that the user has permission for the given ability.\n     */\n    public function restrictEntityQuery(Builder $query, string $ability = 'view'): Builder\n    {\n        $this->clean();\n\n        return $query->where(function (Builder $parentQuery) use ($ability) {\n            $parentQuery->whereHas('jointPermissions', function (Builder $permissionQuery) use ($ability) {\n                $permissionQuery->whereIn('role_id', $this->getCurrentUserRoles())\n                    ->where('action', '=', $ability)\n                    ->where(function (Builder $query) {\n                        $this->addJointHasPermissionCheck($query, $this->currentUser()->id);\n                    });\n            });\n        });\n    }\n\n    /**\n     * Extend the given page query to ensure draft items are not visible\n     * unless created by the given user.\n     */\n    public function enforceDraftVisibilityOnQuery(Builder $query): Builder\n    {\n        return $query->where(function (Builder $query) {\n            $query->where('draft', '=', false)\n                ->orWhere(function (Builder $query) {\n                    $query->where('draft', '=', true)\n                        ->where('owned_by', '=', $this->currentUser()->id);\n                });\n        });\n    }\n\n    /**\n     * Add restrictions for a generic entity.\n     */\n    public function enforceEntityRestrictions(Entity $entity, Builder $query, string $action = 'view'): Builder\n    {\n        if ($entity instanceof Page) {\n            // Prevent drafts being visible to others.\n            $this->enforceDraftVisibilityOnQuery($query);\n        }\n\n        return $this->entityRestrictionQuery($query, $action);\n    }\n\n    /**\n     * Filter items that have entities set as a polymorphic relation.\n     * For simplicity, this will not return results attached to draft pages.\n     * Draft pages should never really have related items though.\n     *\n     * @param Builder|QueryBuilder $query\n     */\n    public function filterRestrictedEntityRelations($query, string $tableName, string $entityIdColumn, string $entityTypeColumn, string $action = 'view')\n    {\n        $tableDetails = ['tableName' => $tableName, 'entityIdColumn' => $entityIdColumn, 'entityTypeColumn' => $entityTypeColumn];\n        $pageMorphClass = (new Page())->getMorphClass();\n\n        $q = $query->whereExists(function ($permissionQuery) use (&$tableDetails, $action) {\n            /** @var Builder $permissionQuery */\n            $permissionQuery->select(['role_id'])->from('joint_permissions')\n                ->whereColumn('joint_permissions.entity_id', '=', $tableDetails['tableName'] . '.' . $tableDetails['entityIdColumn'])\n                ->whereColumn('joint_permissions.entity_type', '=', $tableDetails['tableName'] . '.' . $tableDetails['entityTypeColumn'])\n                ->where('joint_permissions.action', '=', $action)\n                ->whereIn('joint_permissions.role_id', $this->getCurrentUserRoles())\n                ->where(function (QueryBuilder $query) {\n                    $this->addJointHasPermissionCheck($query, $this->currentUser()->id);\n                });\n        })->where(function ($query) use ($tableDetails, $pageMorphClass) {\n            /** @var Builder $query */\n            $query->where($tableDetails['entityTypeColumn'], '!=', $pageMorphClass)\n                ->orWhereExists(function(QueryBuilder $query) use ($tableDetails, $pageMorphClass) {\n                    $query->select('id')->from('pages')\n                        ->whereColumn('pages.id', '=', $tableDetails['tableName'] . '.' . $tableDetails['entityIdColumn'])\n                        ->where($tableDetails['tableName'] . '.' . $tableDetails['entityTypeColumn'], '=', $pageMorphClass)\n                        ->where('pages.draft', '=', false);\n                });\n        });\n\n        $this->clean();\n\n        return $q;\n    }\n\n    /**\n     * Add conditions to a query to filter the selection to related entities\n     * where view permissions are granted.\n     */\n    public function filterRelatedEntity(string $entityClass, Builder $query, string $tableName, string $entityIdColumn): Builder\n    {\n        $fullEntityIdColumn = $tableName . '.' . $entityIdColumn;\n        $instance = new $entityClass;\n        $morphClass = $instance->getMorphClass();\n\n        $existsQuery = function($permissionQuery) use ($fullEntityIdColumn, $morphClass) {\n            /** @var Builder $permissionQuery */\n            $permissionQuery->select('joint_permissions.role_id')->from('joint_permissions')\n                ->whereColumn('joint_permissions.entity_id', '=', $fullEntityIdColumn)\n                ->where('joint_permissions.entity_type', '=', $morphClass)\n                ->where('joint_permissions.action', '=', 'view')\n                ->whereIn('joint_permissions.role_id', $this->getCurrentUserRoles())\n                ->where(function (QueryBuilder $query) {\n                    $this->addJointHasPermissionCheck($query, $this->currentUser()->id);\n                });\n        };\n\n        $q = $query->where(function ($query) use ($existsQuery, $fullEntityIdColumn) {\n            $query->whereExists($existsQuery)\n                ->orWhere($fullEntityIdColumn, '=', 0);\n        });\n\n        if ($instance instanceof Page) {\n            // Prevent visibility of non-owned draft pages\n            $q->whereExists(function(QueryBuilder $query) use ($fullEntityIdColumn) {\n                $query->select('id')->from('pages')\n                    ->whereColumn('pages.id', '=', $fullEntityIdColumn)\n                    ->where(function (QueryBuilder $query) {\n                        $query->where('pages.draft', '=', false)\n                            ->orWhere('pages.owned_by', '=', $this->currentUser()->id);\n                    });\n            });\n        }\n\n        $this->clean();\n\n        return $q;\n    }\n\n    /**\n     * Add the query for checking the given user id has permission\n     * within the join_permissions table.\n     *\n     * @param QueryBuilder|Builder $query\n     */\n    protected function addJointHasPermissionCheck($query, int $userIdToCheck)\n    {\n        $query->where('joint_permissions.has_permission', '=', true)->orWhere(function ($query) use ($userIdToCheck) {\n            $query->where('joint_permissions.has_permission_own', '=', true)\n                ->where('joint_permissions.owned_by', '=', $userIdToCheck);\n        });\n    }\n\n    /**\n     * Get the current user.\n     */\n    private function currentUser(): User\n    {\n        if (is_null($this->currentUserModel)) {\n            $this->currentUserModel = user();\n        }\n\n        return $this->currentUserModel;\n    }\n\n    /**\n     * Clean the cached user elements.\n     */\n    private function clean(): void\n    {\n        $this->currentUserModel = null;\n        $this->userRoles = null;\n    }\n}\n", "<?php\n\nnamespace BookStack\\Exceptions;\n\nuse Exception;\nuse Illuminate\\Auth\\AuthenticationException;\nuse Illuminate\\Database\\Eloquent\\ModelNotFoundException;\nuse Illuminate\\Foundation\\Exceptions\\Handler as ExceptionHandler;\nuse Illuminate\\Http\\JsonResponse;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Validation\\ValidationException;\nuse Symfony\\Component\\HttpKernel\\Exception\\HttpException;\nuse Throwable;\n\nclass Handler extends ExceptionHandler\n{\n    /**\n     * A list of the exception types that are not reported.\n     *\n     * @var array\n     */\n    protected $dontReport = [\n        NotFoundException::class,\n    ];\n\n    /**\n     * A list of the inputs that are never flashed for validation exceptions.\n     *\n     * @var array\n     */\n    protected $dontFlash = [\n        'current_password',\n        'password',\n        'password_confirmation',\n    ];\n\n    /**\n     * Report or log an exception.\n     *\n     * @param \\Throwable $exception\n     *\n     * @throws \\Throwable\n     *\n     * @return void\n     */\n    public function report(Throwable $exception)\n    {\n        parent::report($exception);\n    }\n\n    /**\n     * Render an exception into an HTTP response.\n     *\n     * @param \\Illuminate\\Http\\Request $request\n     * @param Exception                $e\n     *\n     * @return \\Illuminate\\Http\\Response\n     */\n    public function render($request, Throwable $e)\n    {\n        if ($this->isApiRequest($request)) {\n            return $this->renderApiException($e);\n        }\n\n        return parent::render($request, $e);\n    }\n\n    /**\n     * Check if the given request is an API request.\n     */\n    protected function isApiRequest(Request $request): bool\n    {\n        return strpos($request->path(), 'api/') === 0;\n    }\n\n    /**\n     * Render an exception when the API is in use.\n     */\n    protected function renderApiException(Throwable $e): JsonResponse\n    {\n        $code = 500;\n        $headers = [];\n\n        if ($e instanceof HttpException) {\n            $code = $e->getStatusCode();\n            $headers = $e->getHeaders();\n        }\n\n        if ($e instanceof ModelNotFoundException) {\n            $code = 404;\n        }\n\n        $responseData = [\n            'error' => [\n                'message' => $e->getMessage(),\n            ],\n        ];\n\n        if ($e instanceof ValidationException) {\n            $responseData['error']['validation'] = $e->errors();\n            $code = $e->status;\n        }\n\n        $responseData['error']['code'] = $code;\n\n        return new JsonResponse($responseData, $code, $headers);\n    }\n\n    /**\n     * Convert an authentication exception into an unauthenticated response.\n     *\n     * @param \\Illuminate\\Http\\Request                 $request\n     * @param \\Illuminate\\Auth\\AuthenticationException $exception\n     *\n     * @return \\Illuminate\\Http\\Response\n     */\n    protected function unauthenticated($request, AuthenticationException $exception)\n    {\n        if ($request->expectsJson()) {\n            return response()->json(['error' => 'Unauthenticated.'], 401);\n        }\n\n        return redirect()->guest('login');\n    }\n\n    /**\n     * Convert a validation exception into a JSON response.\n     *\n     * @param \\Illuminate\\Http\\Request                   $request\n     * @param \\Illuminate\\Validation\\ValidationException $exception\n     *\n     * @return \\Illuminate\\Http\\JsonResponse\n     */\n    protected function invalidJson($request, ValidationException $exception)\n    {\n        return response()->json($exception->errors(), $exception->status);\n    }\n}\n", "<?php\n\nnamespace Tests\\Api;\n\nuse BookStack\\Entities\\Models\\Page;\nuse BookStack\\Uploads\\Attachment;\nuse Illuminate\\Http\\UploadedFile;\nuse Tests\\TestCase;\n\nclass AttachmentsApiTest extends TestCase\n{\n    use TestsApi;\n\n    protected $baseEndpoint = '/api/attachments';\n\n    public function test_index_endpoint_returns_expected_book()\n    {\n        $this->actingAsApiEditor();\n        $page = Page::query()->first();\n        $attachment = $this->createAttachmentForPage($page, [\n            'name'     => 'My test attachment',\n            'external' => true,\n        ]);\n\n        $resp = $this->getJson($this->baseEndpoint . '?count=1&sort=+id');\n        $resp->assertJson(['data' => [\n            [\n                'id'          => $attachment->id,\n                'name'        => 'My test attachment',\n                'uploaded_to' => $page->id,\n                'external'    => true,\n            ],\n        ]]);\n    }\n\n    public function test_attachments_listing_based_upon_page_visibility()\n    {\n        $this->actingAsApiEditor();\n        /** @var Page $page */\n        $page = Page::query()->first();\n        $attachment = $this->createAttachmentForPage($page, [\n            'name'     => 'My test attachment',\n            'external' => true,\n        ]);\n\n        $resp = $this->getJson($this->baseEndpoint . '?count=1&sort=+id');\n        $resp->assertJson(['data' => [\n            [\n                'id' => $attachment->id,\n            ],\n        ]]);\n\n        $page->restricted = true;\n        $page->save();\n        $this->regenEntityPermissions($page);\n\n        $resp = $this->getJson($this->baseEndpoint . '?count=1&sort=+id');\n        $resp->assertJsonMissing(['data' => [\n            [\n                'id' => $attachment->id,\n            ],\n        ]]);\n    }\n\n    public function test_create_endpoint_for_link_attachment()\n    {\n        $this->actingAsApiAdmin();\n        /** @var Page $page */\n        $page = Page::query()->first();\n\n        $details = [\n            'name'        => 'My attachment',\n            'uploaded_to' => $page->id,\n            'link'        => 'https://cats.example.com',\n        ];\n\n        $resp = $this->postJson($this->baseEndpoint, $details);\n        $resp->assertStatus(200);\n        /** @var Attachment $newItem */\n        $newItem = Attachment::query()->orderByDesc('id')->where('name', '=', $details['name'])->first();\n        $resp->assertJson(['id' => $newItem->id, 'external' => true, 'name' => $details['name'], 'uploaded_to' => $page->id]);\n    }\n\n    public function test_create_endpoint_for_upload_attachment()\n    {\n        $this->actingAsApiAdmin();\n        /** @var Page $page */\n        $page = Page::query()->first();\n        $file = $this->getTestFile('textfile.txt');\n\n        $details = [\n            'name'        => 'My attachment',\n            'uploaded_to' => $page->id,\n        ];\n\n        $resp = $this->call('POST', $this->baseEndpoint, $details, [], ['file' => $file]);\n        $resp->assertStatus(200);\n        /** @var Attachment $newItem */\n        $newItem = Attachment::query()->orderByDesc('id')->where('name', '=', $details['name'])->first();\n        $resp->assertJson(['id' => $newItem->id, 'external' => false, 'extension' => 'txt', 'name' => $details['name'], 'uploaded_to' => $page->id]);\n        $this->assertTrue(file_exists(storage_path($newItem->path)));\n        unlink(storage_path($newItem->path));\n    }\n\n    public function test_name_needed_to_create()\n    {\n        $this->actingAsApiAdmin();\n        /** @var Page $page */\n        $page = Page::query()->first();\n\n        $details = [\n            'uploaded_to' => $page->id,\n            'link'        => 'https://example.com',\n        ];\n\n        $resp = $this->postJson($this->baseEndpoint, $details);\n        $resp->assertStatus(422);\n        $resp->assertJson([\n            'error' => [\n                'message'    => 'The given data was invalid.',\n                'validation' => [\n                    'name' => ['The name field is required.'],\n                ],\n                'code' => 422,\n            ],\n        ]);\n    }\n\n    public function test_link_or_file_needed_to_create()\n    {\n        $this->actingAsApiAdmin();\n        /** @var Page $page */\n        $page = Page::query()->first();\n\n        $details = [\n            'name'        => 'my attachment',\n            'uploaded_to' => $page->id,\n        ];\n\n        $resp = $this->postJson($this->baseEndpoint, $details);\n        $resp->assertStatus(422);\n        $resp->assertJson([\n            'error' => [\n                'message'    => 'The given data was invalid.',\n                'validation' => [\n                    'file' => ['The file field is required when link is not present.'],\n                    'link' => ['The link field is required when file is not present.'],\n                ],\n                'code' => 422,\n            ],\n        ]);\n    }\n\n    public function test_read_endpoint_for_link_attachment()\n    {\n        $this->actingAsApiAdmin();\n        /** @var Page $page */\n        $page = Page::query()->first();\n\n        $attachment = $this->createAttachmentForPage($page, [\n            'name'  => 'my attachment',\n            'path'  => 'https://example.com',\n            'order' => 1,\n        ]);\n\n        $resp = $this->getJson(\"{$this->baseEndpoint}/{$attachment->id}\");\n\n        $resp->assertStatus(200);\n        $resp->assertJson([\n            'id'          => $attachment->id,\n            'content'     => 'https://example.com',\n            'external'    => true,\n            'uploaded_to' => $page->id,\n            'order'       => 1,\n            'created_by'  => [\n                'name' => $attachment->createdBy->name,\n            ],\n            'updated_by' => [\n                'name' => $attachment->createdBy->name,\n            ],\n            'links' => [\n                'html'     => \"<a target=\\\"_blank\\\" href=\\\"http://localhost/attachments/{$attachment->id}\\\">my attachment</a>\",\n                'markdown' => \"[my attachment](http://localhost/attachments/{$attachment->id})\",\n            ],\n        ]);\n    }\n\n    public function test_read_endpoint_for_file_attachment()\n    {\n        $this->actingAsApiAdmin();\n        /** @var Page $page */\n        $page = Page::query()->first();\n        $file = $this->getTestFile('textfile.txt');\n\n        $details = [\n            'name'        => 'My file attachment',\n            'uploaded_to' => $page->id,\n        ];\n        $this->call('POST', $this->baseEndpoint, $details, [], ['file' => $file]);\n        /** @var Attachment $attachment */\n        $attachment = Attachment::query()->orderByDesc('id')->where('name', '=', $details['name'])->firstOrFail();\n\n        $resp = $this->getJson(\"{$this->baseEndpoint}/{$attachment->id}\");\n\n        $resp->assertStatus(200);\n        $resp->assertJson([\n            'id'          => $attachment->id,\n            'content'     => base64_encode(file_get_contents(storage_path($attachment->path))),\n            'external'    => false,\n            'uploaded_to' => $page->id,\n            'order'       => 1,\n            'created_by'  => [\n                'name' => $attachment->createdBy->name,\n            ],\n            'updated_by' => [\n                'name' => $attachment->updatedBy->name,\n            ],\n            'links' => [\n                'html'     => \"<a target=\\\"_blank\\\" href=\\\"http://localhost/attachments/{$attachment->id}\\\">My file attachment</a>\",\n                'markdown' => \"[My file attachment](http://localhost/attachments/{$attachment->id})\",\n            ],\n        ]);\n\n        unlink(storage_path($attachment->path));\n    }\n\n    public function test_attachment_not_visible_on_other_users_draft()\n    {\n        $this->actingAsApiAdmin();\n        $editor = $this->getEditor();\n\n        /** @var Page $page */\n        $page = Page::query()->first();\n        $page->draft = true;\n        $page->owned_by = $editor;\n        $page->save();\n        $this->regenEntityPermissions($page);\n\n        $attachment = $this->createAttachmentForPage($page, [\n            'name'  => 'my attachment',\n            'path'  => 'https://example.com',\n            'order' => 1,\n        ]);\n\n        $resp = $this->getJson(\"{$this->baseEndpoint}/{$attachment->id}\");\n\n        $resp->assertStatus(404);\n    }\n\n    public function test_update_endpoint()\n    {\n        $this->actingAsApiAdmin();\n        /** @var Page $page */\n        $page = Page::query()->first();\n        $attachment = $this->createAttachmentForPage($page);\n\n        $details = [\n            'name' => 'My updated API attachment',\n        ];\n\n        $resp = $this->putJson(\"{$this->baseEndpoint}/{$attachment->id}\", $details);\n        $attachment->refresh();\n\n        $resp->assertStatus(200);\n        $resp->assertJson(['id' => $attachment->id, 'name' => 'My updated API attachment']);\n    }\n\n    public function test_update_link_attachment_to_file()\n    {\n        $this->actingAsApiAdmin();\n        /** @var Page $page */\n        $page = Page::query()->first();\n        $attachment = $this->createAttachmentForPage($page);\n        $file = $this->getTestFile('textfile.txt');\n\n        $resp = $this->call('PUT', \"{$this->baseEndpoint}/{$attachment->id}\", ['name' => 'My updated file'], [], ['file' => $file]);\n        $resp->assertStatus(200);\n\n        $attachment->refresh();\n        $this->assertFalse($attachment->external);\n        $this->assertEquals('txt', $attachment->extension);\n        $this->assertStringStartsWith('uploads/files/', $attachment->path);\n        $this->assertFileExists(storage_path($attachment->path));\n\n        unlink(storage_path($attachment->path));\n    }\n\n    public function test_update_file_attachment_to_link()\n    {\n        $this->actingAsApiAdmin();\n        /** @var Page $page */\n        $page = Page::query()->first();\n        $file = $this->getTestFile('textfile.txt');\n        $this->call('POST', $this->baseEndpoint, ['name' => 'My file attachment', 'uploaded_to' => $page->id], [], ['file' => $file]);\n        /** @var Attachment $attachment */\n        $attachment = Attachment::query()->where('name', '=', 'My file attachment')->firstOrFail();\n\n        $filePath = storage_path($attachment->path);\n        $this->assertFileExists($filePath);\n\n        $details = [\n            'name' => 'My updated API attachment',\n            'link' => 'https://cats.example.com',\n        ];\n\n        $resp = $this->putJson(\"{$this->baseEndpoint}/{$attachment->id}\", $details);\n        $resp->assertStatus(200);\n        $attachment->refresh();\n\n        $this->assertFileDoesNotExist($filePath);\n        $this->assertTrue($attachment->external);\n        $this->assertEquals('https://cats.example.com', $attachment->path);\n        $this->assertEquals('', $attachment->extension);\n    }\n\n    public function test_delete_endpoint()\n    {\n        $this->actingAsApiAdmin();\n        /** @var Page $page */\n        $page = Page::query()->first();\n        $attachment = $this->createAttachmentForPage($page);\n\n        $resp = $this->deleteJson(\"{$this->baseEndpoint}/{$attachment->id}\");\n\n        $resp->assertStatus(204);\n        $this->assertDatabaseMissing('attachments', ['id' => $attachment->id]);\n    }\n\n    protected function createAttachmentForPage(Page $page, $attributes = []): Attachment\n    {\n        $admin = $this->getAdmin();\n        /** @var Attachment $attachment */\n        $attachment = $page->attachments()->forceCreate(array_merge([\n            'uploaded_to' => $page->id,\n            'name'        => 'test attachment',\n            'external'    => true,\n            'order'       => 1,\n            'created_by'  => $admin->id,\n            'updated_by'  => $admin->id,\n            'path'        => 'https://attachment.example.com',\n        ], $attributes));\n\n        return $attachment;\n    }\n\n    /**\n     * Get a test file that can be uploaded.\n     */\n    protected function getTestFile(string $fileName): UploadedFile\n    {\n        return new UploadedFile(base_path('tests/test-data/test-file.txt'), $fileName, 'text/plain', null, true);\n    }\n}\n"], "filenames": ["app/Actions/ActivityService.php", "app/Auth/Permissions/PermissionService.php", "app/Exceptions/Handler.php", "tests/Api/AttachmentsApiTest.php"], "buggy_code_start_loc": [136, 604, 6, 226], "buggy_code_end_loc": [137, 672, 84, 226], "fixing_code_start_loc": [136, 605, 7, 227], "fixing_code_end_loc": [137, 696, 91, 250], "type": "CWE-863", "message": "bookstack is vulnerable to Improper Access Control", "other": {"cve": {"id": "CVE-2021-4026", "sourceIdentifier": "security@huntr.dev", "published": "2021-11-30T20:15:07.690", "lastModified": "2022-08-09T14:43:13.363", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "bookstack is vulnerable to Improper Access Control"}, {"lang": "es", "value": "bookstack es vulnerable  a un Control de Acceso Inapropiado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-284"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:bookstackapp:bookstack:*:*:*:*:*:*:*:*", "versionEndExcluding": "21.11.2", "matchCriteriaId": "F20610CF-F2B6-47E2-975A-394784440D3D"}]}]}], "references": [{"url": "https://github.com/bookstackapp/bookstack/commit/b4fa82e3298a15443ca40bff205b7a16a1031d92", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/c6dfa80d-43e6-4b49-95af-cc031bb66b1d", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/bookstackapp/bookstack/commit/b4fa82e3298a15443ca40bff205b7a16a1031d92"}}