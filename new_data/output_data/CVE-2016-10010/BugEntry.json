{"buggy_code": ["/* $OpenBSD: serverloop.c,v 1.188 2016/11/30 03:00:05 djm Exp $ */\n/*\n * Author: Tatu Ylonen <ylo@cs.hut.fi>\n * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland\n *                    All rights reserved\n * Server main loop for handling the interactive session.\n *\n * As far as I am concerned, the code I have written for this software\n * can be used freely for any purpose.  Any derived versions of this\n * software must be clearly marked as such, and if the derived work is\n * incompatible with the protocol description in the RFC file, it must be\n * called by a name other than \"ssh\" or \"Secure Shell\".\n *\n * SSH2 support by Markus Friedl.\n * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include <sys/queue.h>\n\n#include <netinet/in.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <string.h>\n#include <termios.h>\n#include <unistd.h>\n#include <stdarg.h>\n\n#include \"xmalloc.h\"\n#include \"packet.h\"\n#include \"buffer.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"servconf.h\"\n#include \"canohost.h\"\n#include \"sshpty.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssh2.h\"\n#include \"key.h\"\n#include \"cipher.h\"\n#include \"kex.h\"\n#include \"hostfile.h\"\n#include \"auth.h\"\n#include \"session.h\"\n#include \"dispatch.h\"\n#include \"auth-options.h\"\n#include \"serverloop.h\"\n#include \"ssherr.h\"\n\nextern ServerOptions options;\n\n/* XXX */\nextern Authctxt *the_authctxt;\nextern int use_privsep;\n\nstatic int no_more_sessions = 0; /* Disallow further sessions. */\n\n/*\n * This SIGCHLD kludge is used to detect when the child exits.  The server\n * will exit after that, as soon as forwarded connections have terminated.\n */\n\nstatic volatile sig_atomic_t child_terminated = 0;\t/* The child has terminated. */\n\n/* Cleanup on signals (!use_privsep case only) */\nstatic volatile sig_atomic_t received_sigterm = 0;\n\n/* prototypes */\nstatic void server_init_dispatch(void);\n\n/*\n * we write to this pipe if a SIGCHLD is caught in order to avoid\n * the race between select() and child_terminated\n */\nstatic int notify_pipe[2];\nstatic void\nnotify_setup(void)\n{\n\tif (pipe(notify_pipe) < 0) {\n\t\terror(\"pipe(notify_pipe) failed %s\", strerror(errno));\n\t} else if ((fcntl(notify_pipe[0], F_SETFD, FD_CLOEXEC) == -1) ||\n\t    (fcntl(notify_pipe[1], F_SETFD, FD_CLOEXEC) == -1)) {\n\t\terror(\"fcntl(notify_pipe, F_SETFD) failed %s\", strerror(errno));\n\t\tclose(notify_pipe[0]);\n\t\tclose(notify_pipe[1]);\n\t} else {\n\t\tset_nonblock(notify_pipe[0]);\n\t\tset_nonblock(notify_pipe[1]);\n\t\treturn;\n\t}\n\tnotify_pipe[0] = -1;\t/* read end */\n\tnotify_pipe[1] = -1;\t/* write end */\n}\nstatic void\nnotify_parent(void)\n{\n\tif (notify_pipe[1] != -1)\n\t\t(void)write(notify_pipe[1], \"\", 1);\n}\nstatic void\nnotify_prepare(fd_set *readset)\n{\n\tif (notify_pipe[0] != -1)\n\t\tFD_SET(notify_pipe[0], readset);\n}\nstatic void\nnotify_done(fd_set *readset)\n{\n\tchar c;\n\n\tif (notify_pipe[0] != -1 && FD_ISSET(notify_pipe[0], readset))\n\t\twhile (read(notify_pipe[0], &c, 1) != -1)\n\t\t\tdebug2(\"notify_done: reading\");\n}\n\n/*ARGSUSED*/\nstatic void\nsigchld_handler(int sig)\n{\n\tint save_errno = errno;\n\tchild_terminated = 1;\n\tsignal(SIGCHLD, sigchld_handler);\n\tnotify_parent();\n\terrno = save_errno;\n}\n\n/*ARGSUSED*/\nstatic void\nsigterm_handler(int sig)\n{\n\treceived_sigterm = sig;\n}\n\nstatic void\nclient_alive_check(void)\n{\n\tint channel_id;\n\n\t/* timeout, check to see how many we have had */\n\tif (packet_inc_alive_timeouts() > options.client_alive_count_max) {\n\t\tlogit(\"Timeout, client not responding.\");\n\t\tcleanup_exit(255);\n\t}\n\n\t/*\n\t * send a bogus global/channel request with \"wantreply\",\n\t * we should get back a failure\n\t */\n\tif ((channel_id = channel_find_open()) == -1) {\n\t\tpacket_start(SSH2_MSG_GLOBAL_REQUEST);\n\t\tpacket_put_cstring(\"keepalive@openssh.com\");\n\t\tpacket_put_char(1);\t/* boolean: want reply */\n\t} else {\n\t\tchannel_request_start(channel_id, \"keepalive@openssh.com\", 1);\n\t}\n\tpacket_send();\n}\n\n/*\n * Sleep in select() until we can do something.  This will initialize the\n * select masks.  Upon return, the masks will indicate which descriptors\n * have data or can accept data.  Optionally, a maximum time can be specified\n * for the duration of the wait (0 = infinite).\n */\nstatic void\nwait_until_can_do_something(int connection_in, int connection_out,\n    fd_set **readsetp, fd_set **writesetp, int *maxfdp,\n    u_int *nallocp, u_int64_t max_time_ms)\n{\n\tstruct timeval tv, *tvp;\n\tint ret;\n\ttime_t minwait_secs = 0;\n\tint client_alive_scheduled = 0;\n\n\t/* Allocate and update select() masks for channel descriptors. */\n\tchannel_prepare_select(readsetp, writesetp, maxfdp, nallocp,\n\t    &minwait_secs, 0);\n\n\t/* XXX need proper deadline system for rekey/client alive */\n\tif (minwait_secs != 0)\n\t\tmax_time_ms = MINIMUM(max_time_ms, (u_int)minwait_secs * 1000);\n\n\t/*\n\t * if using client_alive, set the max timeout accordingly,\n\t * and indicate that this particular timeout was for client\n\t * alive by setting the client_alive_scheduled flag.\n\t *\n\t * this could be randomized somewhat to make traffic\n\t * analysis more difficult, but we're not doing it yet.\n\t */\n\tif (options.client_alive_interval) {\n\t\tuint64_t keepalive_ms =\n\t\t    (uint64_t)options.client_alive_interval * 1000;\n\n\t\tclient_alive_scheduled = 1;\n\t\tif (max_time_ms == 0 || max_time_ms > keepalive_ms)\n\t\t\tmax_time_ms = keepalive_ms;\n\t}\n\n#if 0\n\t/* wrong: bad condition XXX */\n\tif (channel_not_very_much_buffered_data())\n#endif\n\tFD_SET(connection_in, *readsetp);\n\tnotify_prepare(*readsetp);\n\n\t/*\n\t * If we have buffered packet data going to the client, mark that\n\t * descriptor.\n\t */\n\tif (packet_have_data_to_write())\n\t\tFD_SET(connection_out, *writesetp);\n\n\t/*\n\t * If child has terminated and there is enough buffer space to read\n\t * from it, then read as much as is available and exit.\n\t */\n\tif (child_terminated && packet_not_very_much_data_to_write())\n\t\tif (max_time_ms == 0 || client_alive_scheduled)\n\t\t\tmax_time_ms = 100;\n\n\tif (max_time_ms == 0)\n\t\ttvp = NULL;\n\telse {\n\t\ttv.tv_sec = max_time_ms / 1000;\n\t\ttv.tv_usec = 1000 * (max_time_ms % 1000);\n\t\ttvp = &tv;\n\t}\n\n\t/* Wait for something to happen, or the timeout to expire. */\n\tret = select((*maxfdp)+1, *readsetp, *writesetp, NULL, tvp);\n\n\tif (ret == -1) {\n\t\tmemset(*readsetp, 0, *nallocp);\n\t\tmemset(*writesetp, 0, *nallocp);\n\t\tif (errno != EINTR)\n\t\t\terror(\"select: %.100s\", strerror(errno));\n\t} else if (ret == 0 && client_alive_scheduled)\n\t\tclient_alive_check();\n\n\tnotify_done(*readsetp);\n}\n\n/*\n * Processes input from the client and the program.  Input data is stored\n * in buffers and processed later.\n */\nstatic int\nprocess_input(fd_set *readset, int connection_in)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tint len;\n\tchar buf[16384];\n\n\t/* Read and buffer any input data from the client. */\n\tif (FD_ISSET(connection_in, readset)) {\n\t\tlen = read(connection_in, buf, sizeof(buf));\n\t\tif (len == 0) {\n\t\t\tverbose(\"Connection closed by %.100s port %d\",\n\t\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n\t\t\treturn -1;\n\t\t} else if (len < 0) {\n\t\t\tif (errno != EINTR && errno != EAGAIN) {\n\t\t\t\tverbose(\"Read error from remote host \"\n\t\t\t\t    \"%.100s port %d: %.100s\",\n\t\t\t\t    ssh_remote_ipaddr(ssh),\n\t\t\t\t    ssh_remote_port(ssh), strerror(errno));\n\t\t\t\tcleanup_exit(255);\n\t\t\t}\n\t\t} else {\n\t\t\t/* Buffer any received data. */\n\t\t\tpacket_process_incoming(buf, len);\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * Sends data from internal buffers to client program stdin.\n */\nstatic void\nprocess_output(fd_set *writeset, int connection_out)\n{\n\t/* Send any buffered packet data to the client. */\n\tif (FD_ISSET(connection_out, writeset))\n\t\tpacket_write_poll();\n}\n\nstatic void\nprocess_buffered_input_packets(void)\n{\n\tdispatch_run(DISPATCH_NONBLOCK, NULL, active_state);\n}\n\nstatic void\ncollect_children(void)\n{\n\tpid_t pid;\n\tsigset_t oset, nset;\n\tint status;\n\n\t/* block SIGCHLD while we check for dead children */\n\tsigemptyset(&nset);\n\tsigaddset(&nset, SIGCHLD);\n\tsigprocmask(SIG_BLOCK, &nset, &oset);\n\tif (child_terminated) {\n\t\tdebug(\"Received SIGCHLD.\");\n\t\twhile ((pid = waitpid(-1, &status, WNOHANG)) > 0 ||\n\t\t    (pid < 0 && errno == EINTR))\n\t\t\tif (pid > 0)\n\t\t\t\tsession_close_by_pid(pid, status);\n\t\tchild_terminated = 0;\n\t}\n\tsigprocmask(SIG_SETMASK, &oset, NULL);\n}\n\nvoid\nserver_loop2(Authctxt *authctxt)\n{\n\tfd_set *readset = NULL, *writeset = NULL;\n\tint max_fd;\n\tu_int nalloc = 0, connection_in, connection_out;\n\tu_int64_t rekey_timeout_ms = 0;\n\n\tdebug(\"Entering interactive session for SSH2.\");\n\n\tsignal(SIGCHLD, sigchld_handler);\n\tchild_terminated = 0;\n\tconnection_in = packet_get_connection_in();\n\tconnection_out = packet_get_connection_out();\n\n\tif (!use_privsep) {\n\t\tsignal(SIGTERM, sigterm_handler);\n\t\tsignal(SIGINT, sigterm_handler);\n\t\tsignal(SIGQUIT, sigterm_handler);\n\t}\n\n\tnotify_setup();\n\n\tmax_fd = MAXIMUM(connection_in, connection_out);\n\tmax_fd = MAXIMUM(max_fd, notify_pipe[0]);\n\n\tserver_init_dispatch();\n\n\tfor (;;) {\n\t\tprocess_buffered_input_packets();\n\n\t\tif (!ssh_packet_is_rekeying(active_state) &&\n\t\t    packet_not_very_much_data_to_write())\n\t\t\tchannel_output_poll();\n\t\tif (options.rekey_interval > 0 &&\n\t\t    !ssh_packet_is_rekeying(active_state))\n\t\t\trekey_timeout_ms = packet_get_rekey_timeout() * 1000;\n\t\telse\n\t\t\trekey_timeout_ms = 0;\n\n\t\twait_until_can_do_something(connection_in, connection_out,\n\t\t    &readset, &writeset, &max_fd, &nalloc, rekey_timeout_ms);\n\n\t\tif (received_sigterm) {\n\t\t\tlogit(\"Exiting on signal %d\", (int)received_sigterm);\n\t\t\t/* Clean up sessions, utmp, etc. */\n\t\t\tcleanup_exit(255);\n\t\t}\n\n\t\tcollect_children();\n\t\tif (!ssh_packet_is_rekeying(active_state))\n\t\t\tchannel_after_select(readset, writeset);\n\t\tif (process_input(readset, connection_in) < 0)\n\t\t\tbreak;\n\t\tprocess_output(writeset, connection_out);\n\t}\n\tcollect_children();\n\n\tfree(readset);\n\tfree(writeset);\n\n\t/* free all channels, no more reads and writes */\n\tchannel_free_all();\n\n\t/* free remaining sessions, e.g. remove wtmp entries */\n\tsession_destroy_all(NULL);\n}\n\nstatic int\nserver_input_keep_alive(int type, u_int32_t seq, void *ctxt)\n{\n\tdebug(\"Got %d/%u for keepalive\", type, seq);\n\t/*\n\t * reset timeout, since we got a sane answer from the client.\n\t * even if this was generated by something other than\n\t * the bogus CHANNEL_REQUEST we send for keepalives.\n\t */\n\tpacket_set_alive_timeouts(0);\n\treturn 0;\n}\n\nstatic Channel *\nserver_request_direct_tcpip(void)\n{\n\tChannel *c = NULL;\n\tchar *target, *originator;\n\tu_short target_port, originator_port;\n\n\ttarget = packet_get_string(NULL);\n\ttarget_port = packet_get_int();\n\toriginator = packet_get_string(NULL);\n\toriginator_port = packet_get_int();\n\tpacket_check_eom();\n\n\tdebug(\"server_request_direct_tcpip: originator %s port %d, target %s \"\n\t    \"port %d\", originator, originator_port, target, target_port);\n\n\t/* XXX fine grained permissions */\n\tif ((options.allow_tcp_forwarding & FORWARD_LOCAL) != 0 &&\n\t    !no_port_forwarding_flag && !options.disable_forwarding) {\n\t\tc = channel_connect_to_port(target, target_port,\n\t\t    \"direct-tcpip\", \"direct-tcpip\");\n\t} else {\n\t\tlogit(\"refused local port forward: \"\n\t\t    \"originator %s port %d, target %s port %d\",\n\t\t    originator, originator_port, target, target_port);\n\t}\n\n\tfree(originator);\n\tfree(target);\n\n\treturn c;\n}\n\nstatic Channel *\nserver_request_direct_streamlocal(void)\n{\n\tChannel *c = NULL;\n\tchar *target, *originator;\n\tu_short originator_port;\n\n\ttarget = packet_get_string(NULL);\n\toriginator = packet_get_string(NULL);\n\toriginator_port = packet_get_int();\n\tpacket_check_eom();\n\n\tdebug(\"server_request_direct_streamlocal: originator %s port %d, target %s\",\n\t    originator, originator_port, target);\n\n\t/* XXX fine grained permissions */\n\tif ((options.allow_streamlocal_forwarding & FORWARD_LOCAL) != 0 &&\n\t    !no_port_forwarding_flag && !options.disable_forwarding) {\n\t\tc = channel_connect_to_path(target,\n\t\t    \"direct-streamlocal@openssh.com\", \"direct-streamlocal\");\n\t} else {\n\t\tlogit(\"refused streamlocal port forward: \"\n\t\t    \"originator %s port %d, target %s\",\n\t\t    originator, originator_port, target);\n\t}\n\n\tfree(originator);\n\tfree(target);\n\n\treturn c;\n}\n\nstatic Channel *\nserver_request_tun(void)\n{\n\tChannel *c = NULL;\n\tint mode, tun;\n\tint sock;\n\n\tmode = packet_get_int();\n\tswitch (mode) {\n\tcase SSH_TUNMODE_POINTOPOINT:\n\tcase SSH_TUNMODE_ETHERNET:\n\t\tbreak;\n\tdefault:\n\t\tpacket_send_debug(\"Unsupported tunnel device mode.\");\n\t\treturn NULL;\n\t}\n\tif ((options.permit_tun & mode) == 0) {\n\t\tpacket_send_debug(\"Server has rejected tunnel device \"\n\t\t    \"forwarding\");\n\t\treturn NULL;\n\t}\n\n\ttun = packet_get_int();\n\tif (forced_tun_device != -1) {\n\t\tif (tun != SSH_TUNID_ANY && forced_tun_device != tun)\n\t\t\tgoto done;\n\t\ttun = forced_tun_device;\n\t}\n\tsock = tun_open(tun, mode);\n\tif (sock < 0)\n\t\tgoto done;\n\tc = channel_new(\"tun\", SSH_CHANNEL_OPEN, sock, sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, \"tun\", 1);\n\tc->datagram = 1;\n\n done:\n\tif (c == NULL)\n\t\tpacket_send_debug(\"Failed to open the tunnel device.\");\n\treturn c;\n}\n\nstatic Channel *\nserver_request_session(void)\n{\n\tChannel *c;\n\n\tdebug(\"input_session_request\");\n\tpacket_check_eom();\n\n\tif (no_more_sessions) {\n\t\tpacket_disconnect(\"Possible attack: attempt to open a session \"\n\t\t    \"after additional sessions disabled\");\n\t}\n\n\t/*\n\t * A server session has no fd to read or write until a\n\t * CHANNEL_REQUEST for a shell is made, so we set the type to\n\t * SSH_CHANNEL_LARVAL.  Additionally, a callback for handling all\n\t * CHANNEL_REQUEST messages is registered.\n\t */\n\tc = channel_new(\"session\", SSH_CHANNEL_LARVAL,\n\t    -1, -1, -1, /*window size*/0, CHAN_SES_PACKET_DEFAULT,\n\t    0, \"server-session\", 1);\n\tif (session_open(the_authctxt, c->self) != 1) {\n\t\tdebug(\"session open failed, free channel %d\", c->self);\n\t\tchannel_free(c);\n\t\treturn NULL;\n\t}\n\tchannel_register_cleanup(c->self, session_close_by_channel, 0);\n\treturn c;\n}\n\nstatic int\nserver_input_channel_open(int type, u_int32_t seq, void *ctxt)\n{\n\tChannel *c = NULL;\n\tchar *ctype;\n\tint rchan;\n\tu_int rmaxpack, rwindow, len;\n\n\tctype = packet_get_string(&len);\n\trchan = packet_get_int();\n\trwindow = packet_get_int();\n\trmaxpack = packet_get_int();\n\n\tdebug(\"server_input_channel_open: ctype %s rchan %d win %d max %d\",\n\t    ctype, rchan, rwindow, rmaxpack);\n\n\tif (strcmp(ctype, \"session\") == 0) {\n\t\tc = server_request_session();\n\t} else if (strcmp(ctype, \"direct-tcpip\") == 0) {\n\t\tc = server_request_direct_tcpip();\n\t} else if (strcmp(ctype, \"direct-streamlocal@openssh.com\") == 0) {\n\t\tc = server_request_direct_streamlocal();\n\t} else if (strcmp(ctype, \"tun@openssh.com\") == 0) {\n\t\tc = server_request_tun();\n\t}\n\tif (c != NULL) {\n\t\tdebug(\"server_input_channel_open: confirm %s\", ctype);\n\t\tc->remote_id = rchan;\n\t\tc->remote_window = rwindow;\n\t\tc->remote_maxpacket = rmaxpack;\n\t\tif (c->type != SSH_CHANNEL_CONNECTING) {\n\t\t\tpacket_start(SSH2_MSG_CHANNEL_OPEN_CONFIRMATION);\n\t\t\tpacket_put_int(c->remote_id);\n\t\t\tpacket_put_int(c->self);\n\t\t\tpacket_put_int(c->local_window);\n\t\t\tpacket_put_int(c->local_maxpacket);\n\t\t\tpacket_send();\n\t\t}\n\t} else {\n\t\tdebug(\"server_input_channel_open: failure %s\", ctype);\n\t\tpacket_start(SSH2_MSG_CHANNEL_OPEN_FAILURE);\n\t\tpacket_put_int(rchan);\n\t\tpacket_put_int(SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED);\n\t\tif (!(datafellows & SSH_BUG_OPENFAILURE)) {\n\t\t\tpacket_put_cstring(\"open failed\");\n\t\t\tpacket_put_cstring(\"\");\n\t\t}\n\t\tpacket_send();\n\t}\n\tfree(ctype);\n\treturn 0;\n}\n\nstatic int\nserver_input_hostkeys_prove(struct sshbuf **respp)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tstruct sshbuf *resp = NULL;\n\tstruct sshbuf *sigbuf = NULL;\n\tstruct sshkey *key = NULL, *key_pub = NULL, *key_prv = NULL;\n\tint r, ndx, success = 0;\n\tconst u_char *blob;\n\tu_char *sig = 0;\n\tsize_t blen, slen;\n\n\tif ((resp = sshbuf_new()) == NULL || (sigbuf = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\n\twhile (ssh_packet_remaining(ssh) > 0) {\n\t\tsshkey_free(key);\n\t\tkey = NULL;\n\t\tif ((r = sshpkt_get_string_direct(ssh, &blob, &blen)) != 0 ||\n\t\t    (r = sshkey_from_blob(blob, blen, &key)) != 0) {\n\t\t\terror(\"%s: couldn't parse key: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * Better check that this is actually one of our hostkeys\n\t\t * before attempting to sign anything with it.\n\t\t */\n\t\tif ((ndx = ssh->kex->host_key_index(key, 1, ssh)) == -1) {\n\t\t\terror(\"%s: unknown host %s key\",\n\t\t\t    __func__, sshkey_type(key));\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * XXX refactor: make kex->sign just use an index rather\n\t\t * than passing in public and private keys\n\t\t */\n\t\tif ((key_prv = get_hostkey_by_index(ndx)) == NULL &&\n\t\t    (key_pub = get_hostkey_public_by_index(ndx, ssh)) == NULL) {\n\t\t\terror(\"%s: can't retrieve hostkey %d\", __func__, ndx);\n\t\t\tgoto out;\n\t\t}\n\t\tsshbuf_reset(sigbuf);\n\t\tfree(sig);\n\t\tsig = NULL;\n\t\tif ((r = sshbuf_put_cstring(sigbuf,\n\t\t    \"hostkeys-prove-00@openssh.com\")) != 0 ||\n\t\t    (r = sshbuf_put_string(sigbuf,\n\t\t    ssh->kex->session_id, ssh->kex->session_id_len)) != 0 ||\n\t\t    (r = sshkey_puts(key, sigbuf)) != 0 ||\n\t\t    (r = ssh->kex->sign(key_prv, key_pub, &sig, &slen,\n\t\t    sshbuf_ptr(sigbuf), sshbuf_len(sigbuf), NULL, 0)) != 0 ||\n\t\t    (r = sshbuf_put_string(resp, sig, slen)) != 0) {\n\t\t\terror(\"%s: couldn't prepare signature: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* Success */\n\t*respp = resp;\n\tresp = NULL; /* don't free it */\n\tsuccess = 1;\n out:\n\tfree(sig);\n\tsshbuf_free(resp);\n\tsshbuf_free(sigbuf);\n\tsshkey_free(key);\n\treturn success;\n}\n\nstatic int\nserver_input_global_request(int type, u_int32_t seq, void *ctxt)\n{\n\tchar *rtype;\n\tint want_reply;\n\tint r, success = 0, allocated_listen_port = 0;\n\tstruct sshbuf *resp = NULL;\n\n\trtype = packet_get_string(NULL);\n\twant_reply = packet_get_char();\n\tdebug(\"server_input_global_request: rtype %s want_reply %d\", rtype, want_reply);\n\n\t/* -R style forwarding */\n\tif (strcmp(rtype, \"tcpip-forward\") == 0) {\n\t\tstruct passwd *pw;\n\t\tstruct Forward fwd;\n\n\t\tpw = the_authctxt->pw;\n\t\tif (pw == NULL || !the_authctxt->valid)\n\t\t\tfatal(\"server_input_global_request: no/invalid user\");\n\t\tmemset(&fwd, 0, sizeof(fwd));\n\t\tfwd.listen_host = packet_get_string(NULL);\n\t\tfwd.listen_port = (u_short)packet_get_int();\n\t\tdebug(\"server_input_global_request: tcpip-forward listen %s port %d\",\n\t\t    fwd.listen_host, fwd.listen_port);\n\n\t\t/* check permissions */\n\t\tif ((options.allow_tcp_forwarding & FORWARD_REMOTE) == 0 ||\n\t\t    no_port_forwarding_flag || options.disable_forwarding ||\n\t\t    (!want_reply && fwd.listen_port == 0) ||\n\t\t    (fwd.listen_port != 0 &&\n\t\t     !bind_permitted(fwd.listen_port, pw->pw_uid))) {\n\t\t\tsuccess = 0;\n\t\t\tpacket_send_debug(\"Server has disabled port forwarding.\");\n\t\t} else {\n\t\t\t/* Start listening on the port */\n\t\t\tsuccess = channel_setup_remote_fwd_listener(&fwd,\n\t\t\t    &allocated_listen_port, &options.fwd_opts);\n\t\t}\n\t\tfree(fwd.listen_host);\n\t\tif ((resp = sshbuf_new()) == NULL)\n\t\t\tfatal(\"%s: sshbuf_new\", __func__);\n\t\tif (allocated_listen_port != 0 &&\n\t\t    (r = sshbuf_put_u32(resp, allocated_listen_port)) != 0)\n\t\t\tfatal(\"%s: sshbuf_put_u32: %s\", __func__, ssh_err(r));\n\t} else if (strcmp(rtype, \"cancel-tcpip-forward\") == 0) {\n\t\tstruct Forward fwd;\n\n\t\tmemset(&fwd, 0, sizeof(fwd));\n\t\tfwd.listen_host = packet_get_string(NULL);\n\t\tfwd.listen_port = (u_short)packet_get_int();\n\t\tdebug(\"%s: cancel-tcpip-forward addr %s port %d\", __func__,\n\t\t    fwd.listen_host, fwd.listen_port);\n\n\t\tsuccess = channel_cancel_rport_listener(&fwd);\n\t\tfree(fwd.listen_host);\n\t} else if (strcmp(rtype, \"streamlocal-forward@openssh.com\") == 0) {\n\t\tstruct Forward fwd;\n\n\t\tmemset(&fwd, 0, sizeof(fwd));\n\t\tfwd.listen_path = packet_get_string(NULL);\n\t\tdebug(\"server_input_global_request: streamlocal-forward listen path %s\",\n\t\t    fwd.listen_path);\n\n\t\t/* check permissions */\n\t\tif ((options.allow_streamlocal_forwarding & FORWARD_REMOTE) == 0\n\t\t    || no_port_forwarding_flag || options.disable_forwarding) {\n\t\t\tsuccess = 0;\n\t\t\tpacket_send_debug(\"Server has disabled port forwarding.\");\n\t\t} else {\n\t\t\t/* Start listening on the socket */\n\t\t\tsuccess = channel_setup_remote_fwd_listener(\n\t\t\t    &fwd, NULL, &options.fwd_opts);\n\t\t}\n\t\tfree(fwd.listen_path);\n\t} else if (strcmp(rtype, \"cancel-streamlocal-forward@openssh.com\") == 0) {\n\t\tstruct Forward fwd;\n\n\t\tmemset(&fwd, 0, sizeof(fwd));\n\t\tfwd.listen_path = packet_get_string(NULL);\n\t\tdebug(\"%s: cancel-streamlocal-forward path %s\", __func__,\n\t\t    fwd.listen_path);\n\n\t\tsuccess = channel_cancel_rport_listener(&fwd);\n\t\tfree(fwd.listen_path);\n\t} else if (strcmp(rtype, \"no-more-sessions@openssh.com\") == 0) {\n\t\tno_more_sessions = 1;\n\t\tsuccess = 1;\n\t} else if (strcmp(rtype, \"hostkeys-prove-00@openssh.com\") == 0) {\n\t\tsuccess = server_input_hostkeys_prove(&resp);\n\t}\n\tif (want_reply) {\n\t\tpacket_start(success ?\n\t\t    SSH2_MSG_REQUEST_SUCCESS : SSH2_MSG_REQUEST_FAILURE);\n\t\tif (success && resp != NULL)\n\t\t\tssh_packet_put_raw(active_state, sshbuf_ptr(resp),\n\t\t\t    sshbuf_len(resp));\n\t\tpacket_send();\n\t\tpacket_write_wait();\n\t}\n\tfree(rtype);\n\tsshbuf_free(resp);\n\treturn 0;\n}\n\nstatic int\nserver_input_channel_req(int type, u_int32_t seq, void *ctxt)\n{\n\tChannel *c;\n\tint id, reply, success = 0;\n\tchar *rtype;\n\n\tid = packet_get_int();\n\trtype = packet_get_string(NULL);\n\treply = packet_get_char();\n\n\tdebug(\"server_input_channel_req: channel %d request %s reply %d\",\n\t    id, rtype, reply);\n\n\tif ((c = channel_lookup(id)) == NULL)\n\t\tpacket_disconnect(\"server_input_channel_req: \"\n\t\t    \"unknown channel %d\", id);\n\tif (!strcmp(rtype, \"eow@openssh.com\")) {\n\t\tpacket_check_eom();\n\t\tchan_rcvd_eow(c);\n\t} else if ((c->type == SSH_CHANNEL_LARVAL ||\n\t    c->type == SSH_CHANNEL_OPEN) && strcmp(c->ctype, \"session\") == 0)\n\t\tsuccess = session_input_channel_req(c, rtype);\n\tif (reply && !(c->flags & CHAN_CLOSE_SENT)) {\n\t\tpacket_start(success ?\n\t\t    SSH2_MSG_CHANNEL_SUCCESS : SSH2_MSG_CHANNEL_FAILURE);\n\t\tpacket_put_int(c->remote_id);\n\t\tpacket_send();\n\t}\n\tfree(rtype);\n\treturn 0;\n}\n\nstatic void\nserver_init_dispatch(void)\n{\n\tdebug(\"server_init_dispatch\");\n\tdispatch_init(&dispatch_protocol_error);\n\tdispatch_set(SSH2_MSG_CHANNEL_CLOSE, &channel_input_oclose);\n\tdispatch_set(SSH2_MSG_CHANNEL_DATA, &channel_input_data);\n\tdispatch_set(SSH2_MSG_CHANNEL_EOF, &channel_input_ieof);\n\tdispatch_set(SSH2_MSG_CHANNEL_EXTENDED_DATA, &channel_input_extended_data);\n\tdispatch_set(SSH2_MSG_CHANNEL_OPEN, &server_input_channel_open);\n\tdispatch_set(SSH2_MSG_CHANNEL_OPEN_CONFIRMATION, &channel_input_open_confirmation);\n\tdispatch_set(SSH2_MSG_CHANNEL_OPEN_FAILURE, &channel_input_open_failure);\n\tdispatch_set(SSH2_MSG_CHANNEL_REQUEST, &server_input_channel_req);\n\tdispatch_set(SSH2_MSG_CHANNEL_WINDOW_ADJUST, &channel_input_window_adjust);\n\tdispatch_set(SSH2_MSG_GLOBAL_REQUEST, &server_input_global_request);\n\t/* client_alive */\n\tdispatch_set(SSH2_MSG_CHANNEL_SUCCESS, &server_input_keep_alive);\n\tdispatch_set(SSH2_MSG_CHANNEL_FAILURE, &server_input_keep_alive);\n\tdispatch_set(SSH2_MSG_REQUEST_SUCCESS, &server_input_keep_alive);\n\tdispatch_set(SSH2_MSG_REQUEST_FAILURE, &server_input_keep_alive);\n\t/* rekeying */\n\tdispatch_set(SSH2_MSG_KEXINIT, &kex_input_kexinit);\n}\n"], "fixing_code": ["/* $OpenBSD: serverloop.c,v 1.189 2016/12/14 00:36:34 djm Exp $ */\n/*\n * Author: Tatu Ylonen <ylo@cs.hut.fi>\n * Copyright (c) 1995 Tatu Ylonen <ylo@cs.hut.fi>, Espoo, Finland\n *                    All rights reserved\n * Server main loop for handling the interactive session.\n *\n * As far as I am concerned, the code I have written for this software\n * can be used freely for any purpose.  Any derived versions of this\n * software must be clearly marked as such, and if the derived work is\n * incompatible with the protocol description in the RFC file, it must be\n * called by a name other than \"ssh\" or \"Secure Shell\".\n *\n * SSH2 support by Markus Friedl.\n * Copyright (c) 2000, 2001 Markus Friedl.  All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/socket.h>\n#include <sys/time.h>\n#include <sys/queue.h>\n\n#include <netinet/in.h>\n\n#include <errno.h>\n#include <fcntl.h>\n#include <pwd.h>\n#include <signal.h>\n#include <string.h>\n#include <termios.h>\n#include <unistd.h>\n#include <stdarg.h>\n\n#include \"xmalloc.h\"\n#include \"packet.h\"\n#include \"buffer.h\"\n#include \"log.h\"\n#include \"misc.h\"\n#include \"servconf.h\"\n#include \"canohost.h\"\n#include \"sshpty.h\"\n#include \"channels.h\"\n#include \"compat.h\"\n#include \"ssh2.h\"\n#include \"key.h\"\n#include \"cipher.h\"\n#include \"kex.h\"\n#include \"hostfile.h\"\n#include \"auth.h\"\n#include \"session.h\"\n#include \"dispatch.h\"\n#include \"auth-options.h\"\n#include \"serverloop.h\"\n#include \"ssherr.h\"\n\nextern ServerOptions options;\n\n/* XXX */\nextern Authctxt *the_authctxt;\nextern int use_privsep;\n\nstatic int no_more_sessions = 0; /* Disallow further sessions. */\n\n/*\n * This SIGCHLD kludge is used to detect when the child exits.  The server\n * will exit after that, as soon as forwarded connections have terminated.\n */\n\nstatic volatile sig_atomic_t child_terminated = 0;\t/* The child has terminated. */\n\n/* Cleanup on signals (!use_privsep case only) */\nstatic volatile sig_atomic_t received_sigterm = 0;\n\n/* prototypes */\nstatic void server_init_dispatch(void);\n\n/*\n * we write to this pipe if a SIGCHLD is caught in order to avoid\n * the race between select() and child_terminated\n */\nstatic int notify_pipe[2];\nstatic void\nnotify_setup(void)\n{\n\tif (pipe(notify_pipe) < 0) {\n\t\terror(\"pipe(notify_pipe) failed %s\", strerror(errno));\n\t} else if ((fcntl(notify_pipe[0], F_SETFD, FD_CLOEXEC) == -1) ||\n\t    (fcntl(notify_pipe[1], F_SETFD, FD_CLOEXEC) == -1)) {\n\t\terror(\"fcntl(notify_pipe, F_SETFD) failed %s\", strerror(errno));\n\t\tclose(notify_pipe[0]);\n\t\tclose(notify_pipe[1]);\n\t} else {\n\t\tset_nonblock(notify_pipe[0]);\n\t\tset_nonblock(notify_pipe[1]);\n\t\treturn;\n\t}\n\tnotify_pipe[0] = -1;\t/* read end */\n\tnotify_pipe[1] = -1;\t/* write end */\n}\nstatic void\nnotify_parent(void)\n{\n\tif (notify_pipe[1] != -1)\n\t\t(void)write(notify_pipe[1], \"\", 1);\n}\nstatic void\nnotify_prepare(fd_set *readset)\n{\n\tif (notify_pipe[0] != -1)\n\t\tFD_SET(notify_pipe[0], readset);\n}\nstatic void\nnotify_done(fd_set *readset)\n{\n\tchar c;\n\n\tif (notify_pipe[0] != -1 && FD_ISSET(notify_pipe[0], readset))\n\t\twhile (read(notify_pipe[0], &c, 1) != -1)\n\t\t\tdebug2(\"notify_done: reading\");\n}\n\n/*ARGSUSED*/\nstatic void\nsigchld_handler(int sig)\n{\n\tint save_errno = errno;\n\tchild_terminated = 1;\n\tsignal(SIGCHLD, sigchld_handler);\n\tnotify_parent();\n\terrno = save_errno;\n}\n\n/*ARGSUSED*/\nstatic void\nsigterm_handler(int sig)\n{\n\treceived_sigterm = sig;\n}\n\nstatic void\nclient_alive_check(void)\n{\n\tint channel_id;\n\n\t/* timeout, check to see how many we have had */\n\tif (packet_inc_alive_timeouts() > options.client_alive_count_max) {\n\t\tlogit(\"Timeout, client not responding.\");\n\t\tcleanup_exit(255);\n\t}\n\n\t/*\n\t * send a bogus global/channel request with \"wantreply\",\n\t * we should get back a failure\n\t */\n\tif ((channel_id = channel_find_open()) == -1) {\n\t\tpacket_start(SSH2_MSG_GLOBAL_REQUEST);\n\t\tpacket_put_cstring(\"keepalive@openssh.com\");\n\t\tpacket_put_char(1);\t/* boolean: want reply */\n\t} else {\n\t\tchannel_request_start(channel_id, \"keepalive@openssh.com\", 1);\n\t}\n\tpacket_send();\n}\n\n/*\n * Sleep in select() until we can do something.  This will initialize the\n * select masks.  Upon return, the masks will indicate which descriptors\n * have data or can accept data.  Optionally, a maximum time can be specified\n * for the duration of the wait (0 = infinite).\n */\nstatic void\nwait_until_can_do_something(int connection_in, int connection_out,\n    fd_set **readsetp, fd_set **writesetp, int *maxfdp,\n    u_int *nallocp, u_int64_t max_time_ms)\n{\n\tstruct timeval tv, *tvp;\n\tint ret;\n\ttime_t minwait_secs = 0;\n\tint client_alive_scheduled = 0;\n\n\t/* Allocate and update select() masks for channel descriptors. */\n\tchannel_prepare_select(readsetp, writesetp, maxfdp, nallocp,\n\t    &minwait_secs, 0);\n\n\t/* XXX need proper deadline system for rekey/client alive */\n\tif (minwait_secs != 0)\n\t\tmax_time_ms = MINIMUM(max_time_ms, (u_int)minwait_secs * 1000);\n\n\t/*\n\t * if using client_alive, set the max timeout accordingly,\n\t * and indicate that this particular timeout was for client\n\t * alive by setting the client_alive_scheduled flag.\n\t *\n\t * this could be randomized somewhat to make traffic\n\t * analysis more difficult, but we're not doing it yet.\n\t */\n\tif (options.client_alive_interval) {\n\t\tuint64_t keepalive_ms =\n\t\t    (uint64_t)options.client_alive_interval * 1000;\n\n\t\tclient_alive_scheduled = 1;\n\t\tif (max_time_ms == 0 || max_time_ms > keepalive_ms)\n\t\t\tmax_time_ms = keepalive_ms;\n\t}\n\n#if 0\n\t/* wrong: bad condition XXX */\n\tif (channel_not_very_much_buffered_data())\n#endif\n\tFD_SET(connection_in, *readsetp);\n\tnotify_prepare(*readsetp);\n\n\t/*\n\t * If we have buffered packet data going to the client, mark that\n\t * descriptor.\n\t */\n\tif (packet_have_data_to_write())\n\t\tFD_SET(connection_out, *writesetp);\n\n\t/*\n\t * If child has terminated and there is enough buffer space to read\n\t * from it, then read as much as is available and exit.\n\t */\n\tif (child_terminated && packet_not_very_much_data_to_write())\n\t\tif (max_time_ms == 0 || client_alive_scheduled)\n\t\t\tmax_time_ms = 100;\n\n\tif (max_time_ms == 0)\n\t\ttvp = NULL;\n\telse {\n\t\ttv.tv_sec = max_time_ms / 1000;\n\t\ttv.tv_usec = 1000 * (max_time_ms % 1000);\n\t\ttvp = &tv;\n\t}\n\n\t/* Wait for something to happen, or the timeout to expire. */\n\tret = select((*maxfdp)+1, *readsetp, *writesetp, NULL, tvp);\n\n\tif (ret == -1) {\n\t\tmemset(*readsetp, 0, *nallocp);\n\t\tmemset(*writesetp, 0, *nallocp);\n\t\tif (errno != EINTR)\n\t\t\terror(\"select: %.100s\", strerror(errno));\n\t} else if (ret == 0 && client_alive_scheduled)\n\t\tclient_alive_check();\n\n\tnotify_done(*readsetp);\n}\n\n/*\n * Processes input from the client and the program.  Input data is stored\n * in buffers and processed later.\n */\nstatic int\nprocess_input(fd_set *readset, int connection_in)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tint len;\n\tchar buf[16384];\n\n\t/* Read and buffer any input data from the client. */\n\tif (FD_ISSET(connection_in, readset)) {\n\t\tlen = read(connection_in, buf, sizeof(buf));\n\t\tif (len == 0) {\n\t\t\tverbose(\"Connection closed by %.100s port %d\",\n\t\t\t    ssh_remote_ipaddr(ssh), ssh_remote_port(ssh));\n\t\t\treturn -1;\n\t\t} else if (len < 0) {\n\t\t\tif (errno != EINTR && errno != EAGAIN) {\n\t\t\t\tverbose(\"Read error from remote host \"\n\t\t\t\t    \"%.100s port %d: %.100s\",\n\t\t\t\t    ssh_remote_ipaddr(ssh),\n\t\t\t\t    ssh_remote_port(ssh), strerror(errno));\n\t\t\t\tcleanup_exit(255);\n\t\t\t}\n\t\t} else {\n\t\t\t/* Buffer any received data. */\n\t\t\tpacket_process_incoming(buf, len);\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * Sends data from internal buffers to client program stdin.\n */\nstatic void\nprocess_output(fd_set *writeset, int connection_out)\n{\n\t/* Send any buffered packet data to the client. */\n\tif (FD_ISSET(connection_out, writeset))\n\t\tpacket_write_poll();\n}\n\nstatic void\nprocess_buffered_input_packets(void)\n{\n\tdispatch_run(DISPATCH_NONBLOCK, NULL, active_state);\n}\n\nstatic void\ncollect_children(void)\n{\n\tpid_t pid;\n\tsigset_t oset, nset;\n\tint status;\n\n\t/* block SIGCHLD while we check for dead children */\n\tsigemptyset(&nset);\n\tsigaddset(&nset, SIGCHLD);\n\tsigprocmask(SIG_BLOCK, &nset, &oset);\n\tif (child_terminated) {\n\t\tdebug(\"Received SIGCHLD.\");\n\t\twhile ((pid = waitpid(-1, &status, WNOHANG)) > 0 ||\n\t\t    (pid < 0 && errno == EINTR))\n\t\t\tif (pid > 0)\n\t\t\t\tsession_close_by_pid(pid, status);\n\t\tchild_terminated = 0;\n\t}\n\tsigprocmask(SIG_SETMASK, &oset, NULL);\n}\n\nvoid\nserver_loop2(Authctxt *authctxt)\n{\n\tfd_set *readset = NULL, *writeset = NULL;\n\tint max_fd;\n\tu_int nalloc = 0, connection_in, connection_out;\n\tu_int64_t rekey_timeout_ms = 0;\n\n\tdebug(\"Entering interactive session for SSH2.\");\n\n\tsignal(SIGCHLD, sigchld_handler);\n\tchild_terminated = 0;\n\tconnection_in = packet_get_connection_in();\n\tconnection_out = packet_get_connection_out();\n\n\tif (!use_privsep) {\n\t\tsignal(SIGTERM, sigterm_handler);\n\t\tsignal(SIGINT, sigterm_handler);\n\t\tsignal(SIGQUIT, sigterm_handler);\n\t}\n\n\tnotify_setup();\n\n\tmax_fd = MAXIMUM(connection_in, connection_out);\n\tmax_fd = MAXIMUM(max_fd, notify_pipe[0]);\n\n\tserver_init_dispatch();\n\n\tfor (;;) {\n\t\tprocess_buffered_input_packets();\n\n\t\tif (!ssh_packet_is_rekeying(active_state) &&\n\t\t    packet_not_very_much_data_to_write())\n\t\t\tchannel_output_poll();\n\t\tif (options.rekey_interval > 0 &&\n\t\t    !ssh_packet_is_rekeying(active_state))\n\t\t\trekey_timeout_ms = packet_get_rekey_timeout() * 1000;\n\t\telse\n\t\t\trekey_timeout_ms = 0;\n\n\t\twait_until_can_do_something(connection_in, connection_out,\n\t\t    &readset, &writeset, &max_fd, &nalloc, rekey_timeout_ms);\n\n\t\tif (received_sigterm) {\n\t\t\tlogit(\"Exiting on signal %d\", (int)received_sigterm);\n\t\t\t/* Clean up sessions, utmp, etc. */\n\t\t\tcleanup_exit(255);\n\t\t}\n\n\t\tcollect_children();\n\t\tif (!ssh_packet_is_rekeying(active_state))\n\t\t\tchannel_after_select(readset, writeset);\n\t\tif (process_input(readset, connection_in) < 0)\n\t\t\tbreak;\n\t\tprocess_output(writeset, connection_out);\n\t}\n\tcollect_children();\n\n\tfree(readset);\n\tfree(writeset);\n\n\t/* free all channels, no more reads and writes */\n\tchannel_free_all();\n\n\t/* free remaining sessions, e.g. remove wtmp entries */\n\tsession_destroy_all(NULL);\n}\n\nstatic int\nserver_input_keep_alive(int type, u_int32_t seq, void *ctxt)\n{\n\tdebug(\"Got %d/%u for keepalive\", type, seq);\n\t/*\n\t * reset timeout, since we got a sane answer from the client.\n\t * even if this was generated by something other than\n\t * the bogus CHANNEL_REQUEST we send for keepalives.\n\t */\n\tpacket_set_alive_timeouts(0);\n\treturn 0;\n}\n\nstatic Channel *\nserver_request_direct_tcpip(void)\n{\n\tChannel *c = NULL;\n\tchar *target, *originator;\n\tu_short target_port, originator_port;\n\n\ttarget = packet_get_string(NULL);\n\ttarget_port = packet_get_int();\n\toriginator = packet_get_string(NULL);\n\toriginator_port = packet_get_int();\n\tpacket_check_eom();\n\n\tdebug(\"server_request_direct_tcpip: originator %s port %d, target %s \"\n\t    \"port %d\", originator, originator_port, target, target_port);\n\n\t/* XXX fine grained permissions */\n\tif ((options.allow_tcp_forwarding & FORWARD_LOCAL) != 0 &&\n\t    !no_port_forwarding_flag && !options.disable_forwarding) {\n\t\tc = channel_connect_to_port(target, target_port,\n\t\t    \"direct-tcpip\", \"direct-tcpip\");\n\t} else {\n\t\tlogit(\"refused local port forward: \"\n\t\t    \"originator %s port %d, target %s port %d\",\n\t\t    originator, originator_port, target, target_port);\n\t}\n\n\tfree(originator);\n\tfree(target);\n\n\treturn c;\n}\n\nstatic Channel *\nserver_request_direct_streamlocal(void)\n{\n\tChannel *c = NULL;\n\tchar *target, *originator;\n\tu_short originator_port;\n\n\ttarget = packet_get_string(NULL);\n\toriginator = packet_get_string(NULL);\n\toriginator_port = packet_get_int();\n\tpacket_check_eom();\n\n\tdebug(\"server_request_direct_streamlocal: originator %s port %d, target %s\",\n\t    originator, originator_port, target);\n\n\t/* XXX fine grained permissions */\n\tif ((options.allow_streamlocal_forwarding & FORWARD_LOCAL) != 0 &&\n\t    !no_port_forwarding_flag && !options.disable_forwarding &&\n\t    use_privsep) {\n\t\tc = channel_connect_to_path(target,\n\t\t    \"direct-streamlocal@openssh.com\", \"direct-streamlocal\");\n\t} else {\n\t\tlogit(\"refused streamlocal port forward: \"\n\t\t    \"originator %s port %d, target %s\",\n\t\t    originator, originator_port, target);\n\t}\n\n\tfree(originator);\n\tfree(target);\n\n\treturn c;\n}\n\nstatic Channel *\nserver_request_tun(void)\n{\n\tChannel *c = NULL;\n\tint mode, tun;\n\tint sock;\n\n\tmode = packet_get_int();\n\tswitch (mode) {\n\tcase SSH_TUNMODE_POINTOPOINT:\n\tcase SSH_TUNMODE_ETHERNET:\n\t\tbreak;\n\tdefault:\n\t\tpacket_send_debug(\"Unsupported tunnel device mode.\");\n\t\treturn NULL;\n\t}\n\tif ((options.permit_tun & mode) == 0) {\n\t\tpacket_send_debug(\"Server has rejected tunnel device \"\n\t\t    \"forwarding\");\n\t\treturn NULL;\n\t}\n\n\ttun = packet_get_int();\n\tif (forced_tun_device != -1) {\n\t\tif (tun != SSH_TUNID_ANY && forced_tun_device != tun)\n\t\t\tgoto done;\n\t\ttun = forced_tun_device;\n\t}\n\tsock = tun_open(tun, mode);\n\tif (sock < 0)\n\t\tgoto done;\n\tc = channel_new(\"tun\", SSH_CHANNEL_OPEN, sock, sock, -1,\n\t    CHAN_TCP_WINDOW_DEFAULT, CHAN_TCP_PACKET_DEFAULT, 0, \"tun\", 1);\n\tc->datagram = 1;\n\n done:\n\tif (c == NULL)\n\t\tpacket_send_debug(\"Failed to open the tunnel device.\");\n\treturn c;\n}\n\nstatic Channel *\nserver_request_session(void)\n{\n\tChannel *c;\n\n\tdebug(\"input_session_request\");\n\tpacket_check_eom();\n\n\tif (no_more_sessions) {\n\t\tpacket_disconnect(\"Possible attack: attempt to open a session \"\n\t\t    \"after additional sessions disabled\");\n\t}\n\n\t/*\n\t * A server session has no fd to read or write until a\n\t * CHANNEL_REQUEST for a shell is made, so we set the type to\n\t * SSH_CHANNEL_LARVAL.  Additionally, a callback for handling all\n\t * CHANNEL_REQUEST messages is registered.\n\t */\n\tc = channel_new(\"session\", SSH_CHANNEL_LARVAL,\n\t    -1, -1, -1, /*window size*/0, CHAN_SES_PACKET_DEFAULT,\n\t    0, \"server-session\", 1);\n\tif (session_open(the_authctxt, c->self) != 1) {\n\t\tdebug(\"session open failed, free channel %d\", c->self);\n\t\tchannel_free(c);\n\t\treturn NULL;\n\t}\n\tchannel_register_cleanup(c->self, session_close_by_channel, 0);\n\treturn c;\n}\n\nstatic int\nserver_input_channel_open(int type, u_int32_t seq, void *ctxt)\n{\n\tChannel *c = NULL;\n\tchar *ctype;\n\tint rchan;\n\tu_int rmaxpack, rwindow, len;\n\n\tctype = packet_get_string(&len);\n\trchan = packet_get_int();\n\trwindow = packet_get_int();\n\trmaxpack = packet_get_int();\n\n\tdebug(\"server_input_channel_open: ctype %s rchan %d win %d max %d\",\n\t    ctype, rchan, rwindow, rmaxpack);\n\n\tif (strcmp(ctype, \"session\") == 0) {\n\t\tc = server_request_session();\n\t} else if (strcmp(ctype, \"direct-tcpip\") == 0) {\n\t\tc = server_request_direct_tcpip();\n\t} else if (strcmp(ctype, \"direct-streamlocal@openssh.com\") == 0) {\n\t\tc = server_request_direct_streamlocal();\n\t} else if (strcmp(ctype, \"tun@openssh.com\") == 0) {\n\t\tc = server_request_tun();\n\t}\n\tif (c != NULL) {\n\t\tdebug(\"server_input_channel_open: confirm %s\", ctype);\n\t\tc->remote_id = rchan;\n\t\tc->remote_window = rwindow;\n\t\tc->remote_maxpacket = rmaxpack;\n\t\tif (c->type != SSH_CHANNEL_CONNECTING) {\n\t\t\tpacket_start(SSH2_MSG_CHANNEL_OPEN_CONFIRMATION);\n\t\t\tpacket_put_int(c->remote_id);\n\t\t\tpacket_put_int(c->self);\n\t\t\tpacket_put_int(c->local_window);\n\t\t\tpacket_put_int(c->local_maxpacket);\n\t\t\tpacket_send();\n\t\t}\n\t} else {\n\t\tdebug(\"server_input_channel_open: failure %s\", ctype);\n\t\tpacket_start(SSH2_MSG_CHANNEL_OPEN_FAILURE);\n\t\tpacket_put_int(rchan);\n\t\tpacket_put_int(SSH2_OPEN_ADMINISTRATIVELY_PROHIBITED);\n\t\tif (!(datafellows & SSH_BUG_OPENFAILURE)) {\n\t\t\tpacket_put_cstring(\"open failed\");\n\t\t\tpacket_put_cstring(\"\");\n\t\t}\n\t\tpacket_send();\n\t}\n\tfree(ctype);\n\treturn 0;\n}\n\nstatic int\nserver_input_hostkeys_prove(struct sshbuf **respp)\n{\n\tstruct ssh *ssh = active_state; /* XXX */\n\tstruct sshbuf *resp = NULL;\n\tstruct sshbuf *sigbuf = NULL;\n\tstruct sshkey *key = NULL, *key_pub = NULL, *key_prv = NULL;\n\tint r, ndx, success = 0;\n\tconst u_char *blob;\n\tu_char *sig = 0;\n\tsize_t blen, slen;\n\n\tif ((resp = sshbuf_new()) == NULL || (sigbuf = sshbuf_new()) == NULL)\n\t\tfatal(\"%s: sshbuf_new\", __func__);\n\n\twhile (ssh_packet_remaining(ssh) > 0) {\n\t\tsshkey_free(key);\n\t\tkey = NULL;\n\t\tif ((r = sshpkt_get_string_direct(ssh, &blob, &blen)) != 0 ||\n\t\t    (r = sshkey_from_blob(blob, blen, &key)) != 0) {\n\t\t\terror(\"%s: couldn't parse key: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * Better check that this is actually one of our hostkeys\n\t\t * before attempting to sign anything with it.\n\t\t */\n\t\tif ((ndx = ssh->kex->host_key_index(key, 1, ssh)) == -1) {\n\t\t\terror(\"%s: unknown host %s key\",\n\t\t\t    __func__, sshkey_type(key));\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * XXX refactor: make kex->sign just use an index rather\n\t\t * than passing in public and private keys\n\t\t */\n\t\tif ((key_prv = get_hostkey_by_index(ndx)) == NULL &&\n\t\t    (key_pub = get_hostkey_public_by_index(ndx, ssh)) == NULL) {\n\t\t\terror(\"%s: can't retrieve hostkey %d\", __func__, ndx);\n\t\t\tgoto out;\n\t\t}\n\t\tsshbuf_reset(sigbuf);\n\t\tfree(sig);\n\t\tsig = NULL;\n\t\tif ((r = sshbuf_put_cstring(sigbuf,\n\t\t    \"hostkeys-prove-00@openssh.com\")) != 0 ||\n\t\t    (r = sshbuf_put_string(sigbuf,\n\t\t    ssh->kex->session_id, ssh->kex->session_id_len)) != 0 ||\n\t\t    (r = sshkey_puts(key, sigbuf)) != 0 ||\n\t\t    (r = ssh->kex->sign(key_prv, key_pub, &sig, &slen,\n\t\t    sshbuf_ptr(sigbuf), sshbuf_len(sigbuf), NULL, 0)) != 0 ||\n\t\t    (r = sshbuf_put_string(resp, sig, slen)) != 0) {\n\t\t\terror(\"%s: couldn't prepare signature: %s\",\n\t\t\t    __func__, ssh_err(r));\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* Success */\n\t*respp = resp;\n\tresp = NULL; /* don't free it */\n\tsuccess = 1;\n out:\n\tfree(sig);\n\tsshbuf_free(resp);\n\tsshbuf_free(sigbuf);\n\tsshkey_free(key);\n\treturn success;\n}\n\nstatic int\nserver_input_global_request(int type, u_int32_t seq, void *ctxt)\n{\n\tchar *rtype;\n\tint want_reply;\n\tint r, success = 0, allocated_listen_port = 0;\n\tstruct sshbuf *resp = NULL;\n\n\trtype = packet_get_string(NULL);\n\twant_reply = packet_get_char();\n\tdebug(\"server_input_global_request: rtype %s want_reply %d\", rtype, want_reply);\n\n\t/* -R style forwarding */\n\tif (strcmp(rtype, \"tcpip-forward\") == 0) {\n\t\tstruct passwd *pw;\n\t\tstruct Forward fwd;\n\n\t\tpw = the_authctxt->pw;\n\t\tif (pw == NULL || !the_authctxt->valid)\n\t\t\tfatal(\"server_input_global_request: no/invalid user\");\n\t\tmemset(&fwd, 0, sizeof(fwd));\n\t\tfwd.listen_host = packet_get_string(NULL);\n\t\tfwd.listen_port = (u_short)packet_get_int();\n\t\tdebug(\"server_input_global_request: tcpip-forward listen %s port %d\",\n\t\t    fwd.listen_host, fwd.listen_port);\n\n\t\t/* check permissions */\n\t\tif ((options.allow_tcp_forwarding & FORWARD_REMOTE) == 0 ||\n\t\t    no_port_forwarding_flag || options.disable_forwarding ||\n\t\t    (!want_reply && fwd.listen_port == 0) ||\n\t\t    (fwd.listen_port != 0 &&\n\t\t     !bind_permitted(fwd.listen_port, pw->pw_uid))) {\n\t\t\tsuccess = 0;\n\t\t\tpacket_send_debug(\"Server has disabled port forwarding.\");\n\t\t} else {\n\t\t\t/* Start listening on the port */\n\t\t\tsuccess = channel_setup_remote_fwd_listener(&fwd,\n\t\t\t    &allocated_listen_port, &options.fwd_opts);\n\t\t}\n\t\tfree(fwd.listen_host);\n\t\tif ((resp = sshbuf_new()) == NULL)\n\t\t\tfatal(\"%s: sshbuf_new\", __func__);\n\t\tif (allocated_listen_port != 0 &&\n\t\t    (r = sshbuf_put_u32(resp, allocated_listen_port)) != 0)\n\t\t\tfatal(\"%s: sshbuf_put_u32: %s\", __func__, ssh_err(r));\n\t} else if (strcmp(rtype, \"cancel-tcpip-forward\") == 0) {\n\t\tstruct Forward fwd;\n\n\t\tmemset(&fwd, 0, sizeof(fwd));\n\t\tfwd.listen_host = packet_get_string(NULL);\n\t\tfwd.listen_port = (u_short)packet_get_int();\n\t\tdebug(\"%s: cancel-tcpip-forward addr %s port %d\", __func__,\n\t\t    fwd.listen_host, fwd.listen_port);\n\n\t\tsuccess = channel_cancel_rport_listener(&fwd);\n\t\tfree(fwd.listen_host);\n\t} else if (strcmp(rtype, \"streamlocal-forward@openssh.com\") == 0) {\n\t\tstruct Forward fwd;\n\n\t\tmemset(&fwd, 0, sizeof(fwd));\n\t\tfwd.listen_path = packet_get_string(NULL);\n\t\tdebug(\"server_input_global_request: streamlocal-forward listen path %s\",\n\t\t    fwd.listen_path);\n\n\t\t/* check permissions */\n\t\tif ((options.allow_streamlocal_forwarding & FORWARD_REMOTE) == 0\n\t\t    || no_port_forwarding_flag || options.disable_forwarding ||\n\t\t    !use_privsep) {\n\t\t\tsuccess = 0;\n\t\t\tpacket_send_debug(\"Server has disabled port forwarding.\");\n\t\t} else {\n\t\t\t/* Start listening on the socket */\n\t\t\tsuccess = channel_setup_remote_fwd_listener(\n\t\t\t    &fwd, NULL, &options.fwd_opts);\n\t\t}\n\t\tfree(fwd.listen_path);\n\t} else if (strcmp(rtype, \"cancel-streamlocal-forward@openssh.com\") == 0) {\n\t\tstruct Forward fwd;\n\n\t\tmemset(&fwd, 0, sizeof(fwd));\n\t\tfwd.listen_path = packet_get_string(NULL);\n\t\tdebug(\"%s: cancel-streamlocal-forward path %s\", __func__,\n\t\t    fwd.listen_path);\n\n\t\tsuccess = channel_cancel_rport_listener(&fwd);\n\t\tfree(fwd.listen_path);\n\t} else if (strcmp(rtype, \"no-more-sessions@openssh.com\") == 0) {\n\t\tno_more_sessions = 1;\n\t\tsuccess = 1;\n\t} else if (strcmp(rtype, \"hostkeys-prove-00@openssh.com\") == 0) {\n\t\tsuccess = server_input_hostkeys_prove(&resp);\n\t}\n\tif (want_reply) {\n\t\tpacket_start(success ?\n\t\t    SSH2_MSG_REQUEST_SUCCESS : SSH2_MSG_REQUEST_FAILURE);\n\t\tif (success && resp != NULL)\n\t\t\tssh_packet_put_raw(active_state, sshbuf_ptr(resp),\n\t\t\t    sshbuf_len(resp));\n\t\tpacket_send();\n\t\tpacket_write_wait();\n\t}\n\tfree(rtype);\n\tsshbuf_free(resp);\n\treturn 0;\n}\n\nstatic int\nserver_input_channel_req(int type, u_int32_t seq, void *ctxt)\n{\n\tChannel *c;\n\tint id, reply, success = 0;\n\tchar *rtype;\n\n\tid = packet_get_int();\n\trtype = packet_get_string(NULL);\n\treply = packet_get_char();\n\n\tdebug(\"server_input_channel_req: channel %d request %s reply %d\",\n\t    id, rtype, reply);\n\n\tif ((c = channel_lookup(id)) == NULL)\n\t\tpacket_disconnect(\"server_input_channel_req: \"\n\t\t    \"unknown channel %d\", id);\n\tif (!strcmp(rtype, \"eow@openssh.com\")) {\n\t\tpacket_check_eom();\n\t\tchan_rcvd_eow(c);\n\t} else if ((c->type == SSH_CHANNEL_LARVAL ||\n\t    c->type == SSH_CHANNEL_OPEN) && strcmp(c->ctype, \"session\") == 0)\n\t\tsuccess = session_input_channel_req(c, rtype);\n\tif (reply && !(c->flags & CHAN_CLOSE_SENT)) {\n\t\tpacket_start(success ?\n\t\t    SSH2_MSG_CHANNEL_SUCCESS : SSH2_MSG_CHANNEL_FAILURE);\n\t\tpacket_put_int(c->remote_id);\n\t\tpacket_send();\n\t}\n\tfree(rtype);\n\treturn 0;\n}\n\nstatic void\nserver_init_dispatch(void)\n{\n\tdebug(\"server_init_dispatch\");\n\tdispatch_init(&dispatch_protocol_error);\n\tdispatch_set(SSH2_MSG_CHANNEL_CLOSE, &channel_input_oclose);\n\tdispatch_set(SSH2_MSG_CHANNEL_DATA, &channel_input_data);\n\tdispatch_set(SSH2_MSG_CHANNEL_EOF, &channel_input_ieof);\n\tdispatch_set(SSH2_MSG_CHANNEL_EXTENDED_DATA, &channel_input_extended_data);\n\tdispatch_set(SSH2_MSG_CHANNEL_OPEN, &server_input_channel_open);\n\tdispatch_set(SSH2_MSG_CHANNEL_OPEN_CONFIRMATION, &channel_input_open_confirmation);\n\tdispatch_set(SSH2_MSG_CHANNEL_OPEN_FAILURE, &channel_input_open_failure);\n\tdispatch_set(SSH2_MSG_CHANNEL_REQUEST, &server_input_channel_req);\n\tdispatch_set(SSH2_MSG_CHANNEL_WINDOW_ADJUST, &channel_input_window_adjust);\n\tdispatch_set(SSH2_MSG_GLOBAL_REQUEST, &server_input_global_request);\n\t/* client_alive */\n\tdispatch_set(SSH2_MSG_CHANNEL_SUCCESS, &server_input_keep_alive);\n\tdispatch_set(SSH2_MSG_CHANNEL_FAILURE, &server_input_keep_alive);\n\tdispatch_set(SSH2_MSG_REQUEST_SUCCESS, &server_input_keep_alive);\n\tdispatch_set(SSH2_MSG_REQUEST_FAILURE, &server_input_keep_alive);\n\t/* rekeying */\n\tdispatch_set(SSH2_MSG_KEXINIT, &kex_input_kexinit);\n}\n"], "filenames": ["usr.bin/ssh/serverloop.c"], "buggy_code_start_loc": [1], "buggy_code_end_loc": [752], "fixing_code_start_loc": [1], "fixing_code_end_loc": [754], "type": "CWE-264", "message": "sshd in OpenSSH before 7.4, when privilege separation is not used, creates forwarded Unix-domain sockets as root, which might allow local users to gain privileges via unspecified vectors, related to serverloop.c.", "other": {"cve": {"id": "CVE-2016-10010", "sourceIdentifier": "cve@mitre.org", "published": "2017-01-05T02:59:03.087", "lastModified": "2022-12-13T12:15:19.997", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "sshd in OpenSSH before 7.4, when privilege separation is not used, creates forwarded Unix-domain sockets as root, which might allow local users to gain privileges via unspecified vectors, related to serverloop.c."}, {"lang": "es", "value": "sshd en OpenSSH en versiones anteriores a 7.4, cuando no se utiliza la separaci\u00f3n de privilegios, crea Unix-domain sockets reenviados como root, lo que podr\u00eda permitir a usuarios locales obtener privilegios a trav\u00e9s de vectores no especificados, relacionado con serverloop.c."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-264"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openbsd:openssh:*:*:*:*:*:*:*:*", "versionEndIncluding": "7.3", "matchCriteriaId": "B5D52975-3CB0-4BF7-975F-66EF9BF42A06"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/140262/OpenSSH-Local-Privilege-Escalation.html", "source": "cve@mitre.org"}, {"url": "http://www.openwall.com/lists/oss-security/2016/12/19/2", "source": "cve@mitre.org", "tags": ["Mailing List", "Release Notes"]}, {"url": "http://www.securityfocus.com/bid/94972", "source": "cve@mitre.org"}, {"url": "http://www.securitytracker.com/id/1037490", "source": "cve@mitre.org"}, {"url": "http://www.slackware.com/security/viewer.php?l=slackware-security&y=2016&m=slackware-security.647637", "source": "cve@mitre.org"}, {"url": "https://bugs.chromium.org/p/project-zero/issues/detail?id=1010", "source": "cve@mitre.org"}, {"url": "https://cert-portal.siemens.com/productcert/pdf/ssa-412672.pdf", "source": "cve@mitre.org"}, {"url": "https://github.com/openbsd/src/commit/c76fac666ea038753294f2ac94d310f8adece9ce", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://security.FreeBSD.org/advisories/FreeBSD-SA-17:01.openssh.asc", "source": "cve@mitre.org"}, {"url": "https://security.netapp.com/advisory/ntap-20171130-0002/", "source": "cve@mitre.org"}, {"url": "https://support.hpe.com/hpsc/doc/public/display?docLocale=en_US&docId=emr_na-hpesbux03818en_us", "source": "cve@mitre.org"}, {"url": "https://www.exploit-db.com/exploits/40962/", "source": "cve@mitre.org"}, {"url": "https://www.openssh.com/txt/release-7.4", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/openbsd/src/commit/c76fac666ea038753294f2ac94d310f8adece9ce"}}