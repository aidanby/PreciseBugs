{"buggy_code": ["# Based on local.py (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>\n# (c) 2013, Maykel Moya <mmoya@speedyrails.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport distutils.spawn\nimport traceback\nimport os\nimport shutil\nimport subprocess\nfrom ansible import errors\nfrom ansible import utils\nfrom ansible.callbacks import vvv\nimport ansible.constants as C\n\nclass Connection(object):\n    ''' Local chroot based connections '''\n\n    def __init__(self, runner, host, port, *args, **kwargs):\n        self.chroot = host\n        self.has_pipelining = False\n        self.become_methods_supported=C.BECOME_METHODS\n\n        if os.geteuid() != 0:\n            raise errors.AnsibleError(\"chroot connection requires running as root\")\n\n        # we're running as root on the local system so do some\n        # trivial checks for ensuring 'host' is actually a chroot'able dir\n        if not os.path.isdir(self.chroot):\n            raise errors.AnsibleError(\"%s is not a directory\" % self.chroot)\n\n        chrootsh = os.path.join(self.chroot, 'bin/sh')\n        if not utils.is_executable(chrootsh):\n            raise errors.AnsibleError(\"%s does not look like a chrootable dir (/bin/sh missing)\" % self.chroot)\n\n        self.chroot_cmd = distutils.spawn.find_executable('chroot')\n        if not self.chroot_cmd:\n            raise errors.AnsibleError(\"chroot command not found in PATH\")\n\n        self.runner = runner\n        self.host = host\n        # port is unused, since this is local\n        self.port = port\n\n    def connect(self, port=None):\n        ''' connect to the chroot; nothing to do here '''\n\n        vvv(\"THIS IS A LOCAL CHROOT DIR\", host=self.chroot)\n\n        return self\n\n    def exec_command(self, cmd, tmp_path, become_user=None, sudoable=False, executable='/bin/sh', in_data=None):\n        ''' run a command on the chroot '''\n\n        if sudoable and self.runner.become and self.runner.become_method not in self.become_methods_supported:\n            raise errors.AnsibleError(\"Internal Error: this module does not support running commands via %s\" % self.runner.become_method)\n\n        if in_data:\n            raise errors.AnsibleError(\"Internal Error: this module does not support optimized module pipelining\")\n\n        # We enter chroot as root so we ignore privlege escalation?\n\n        if executable:\n            local_cmd = [self.chroot_cmd, self.chroot, executable, '-c', cmd]\n        else:\n            local_cmd = '%s \"%s\" %s' % (self.chroot_cmd, self.chroot, cmd)\n\n        vvv(\"EXEC %s\" % (local_cmd), host=self.chroot)\n        p = subprocess.Popen(local_cmd, shell=isinstance(local_cmd, basestring),\n                             cwd=self.runner.basedir,\n                             stdin=subprocess.PIPE,\n                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n\n        stdout, stderr = p.communicate()\n        return (p.returncode, '', stdout, stderr)\n\n    def put_file(self, in_path, out_path):\n        ''' transfer a file from local to chroot '''\n\n        if not out_path.startswith(os.path.sep):\n            out_path = os.path.join(os.path.sep, out_path)\n        normpath = os.path.normpath(out_path)\n        out_path = os.path.join(self.chroot, normpath[1:])\n\n        vvv(\"PUT %s TO %s\" % (in_path, out_path), host=self.chroot)\n        if not os.path.exists(in_path):\n            raise errors.AnsibleFileNotFound(\"file or module does not exist: %s\" % in_path)\n        try:\n            shutil.copyfile(in_path, out_path)\n        except shutil.Error:\n            traceback.print_exc()\n            raise errors.AnsibleError(\"failed to copy: %s and %s are the same\" % (in_path, out_path))\n        except IOError:\n            traceback.print_exc()\n            raise errors.AnsibleError(\"failed to transfer file to %s\" % out_path)\n\n    def fetch_file(self, in_path, out_path):\n        ''' fetch a file from chroot to local '''\n\n        if not in_path.startswith(os.path.sep):\n            in_path = os.path.join(os.path.sep, in_path)\n        normpath = os.path.normpath(in_path)\n        in_path = os.path.join(self.chroot, normpath[1:])\n\n        vvv(\"FETCH %s TO %s\" % (in_path, out_path), host=self.chroot)\n        if not os.path.exists(in_path):\n            raise errors.AnsibleFileNotFound(\"file or module does not exist: %s\" % in_path)\n        try:\n            shutil.copyfile(in_path, out_path)\n        except shutil.Error:\n            traceback.print_exc()\n            raise errors.AnsibleError(\"failed to copy: %s and %s are the same\" % (in_path, out_path))\n        except IOError:\n            traceback.print_exc()\n            raise errors.AnsibleError(\"failed to transfer file to %s\" % out_path)\n\n    def close(self):\n        ''' terminate the connection; nothing to do here '''\n        pass\n"], "fixing_code": ["# Based on local.py (c) 2012, Michael DeHaan <michael.dehaan@gmail.com>\n# (c) 2013, Maykel Moya <mmoya@speedyrails.com>\n# (c) 2015, Toshio Kuratomi <tkuratomi@ansible.com>\n#\n# This file is part of Ansible\n#\n# Ansible is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# Ansible is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.\nfrom __future__ import (absolute_import, division, print_function)\n__metaclass__ = type\n\nimport distutils.spawn\nimport traceback\nimport os\nimport subprocess\nfrom ansible import errors\nfrom ansible import utils\nfrom ansible.callbacks import vvv\nimport ansible.constants as C\n\nBUFSIZE = 65536\n\nclass Connection(object):\n    ''' Local chroot based connections '''\n\n    def __init__(self, runner, host, port, *args, **kwargs):\n        self.chroot = host\n        self.has_pipelining = False\n        self.become_methods_supported=C.BECOME_METHODS\n\n        if os.geteuid() != 0:\n            raise errors.AnsibleError(\"chroot connection requires running as root\")\n\n        # we're running as root on the local system so do some\n        # trivial checks for ensuring 'host' is actually a chroot'able dir\n        if not os.path.isdir(self.chroot):\n            raise errors.AnsibleError(\"%s is not a directory\" % self.chroot)\n\n        chrootsh = os.path.join(self.chroot, 'bin/sh')\n        if not utils.is_executable(chrootsh):\n            raise errors.AnsibleError(\"%s does not look like a chrootable dir (/bin/sh missing)\" % self.chroot)\n\n        self.chroot_cmd = distutils.spawn.find_executable('chroot')\n        if not self.chroot_cmd:\n            raise errors.AnsibleError(\"chroot command not found in PATH\")\n\n        self.runner = runner\n        self.host = host\n        # port is unused, since this is local\n        self.port = port\n\n    def connect(self, port=None):\n        ''' connect to the chroot; nothing to do here '''\n\n        vvv(\"THIS IS A LOCAL CHROOT DIR\", host=self.chroot)\n\n        return self\n\n    def _generate_cmd(self, executable, cmd):\n        if executable:\n            local_cmd = [self.chroot_cmd, self.chroot, executable, '-c', cmd]\n        else:\n            local_cmd = '%s \"%s\" %s' % (self.chroot_cmd, self.chroot, cmd)\n        return local_cmd\n\n    def _buffered_exec_command(self, cmd, tmp_path, become_user=None, sudoable=False, executable='/bin/sh', in_data=None, stdin=subprocess.PIPE):\n        ''' run a command on the chroot.  This is only needed for implementing\n        put_file() get_file() so that we don't have to read the whole file\n        into memory.\n\n        compared to exec_command() it looses some niceties like being able to\n        return the process's exit code immediately.\n        '''\n\n        if sudoable and self.runner.become and self.runner.become_method not in self.become_methods_supported:\n            raise errors.AnsibleError(\"Internal Error: this module does not support running commands via %s\" % self.runner.become_method)\n\n        if in_data:\n            raise errors.AnsibleError(\"Internal Error: this module does not support optimized module pipelining\")\n\n        # We enter chroot as root so we ignore privlege escalation?\n        local_cmd = self._generate_cmd(executable, cmd)\n\n        vvv(\"EXEC %s\" % (local_cmd), host=self.chroot)\n        p = subprocess.Popen(local_cmd, shell=isinstance(local_cmd, basestring),\n                             cwd=self.runner.basedir,\n                             stdin=stdin,\n                             stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n\n        return p\n\n    def exec_command(self, cmd, tmp_path, become_user=None, sudoable=False, executable='/bin/sh', in_data=None):\n        ''' run a command on the chroot '''\n\n        p = self._buffered_exec_command(cmd, tmp_path, become_user, sudoable, executable, in_data)\n\n        stdout, stderr = p.communicate()\n        return (p.returncode, '', stdout, stderr)\n\n    def put_file(self, in_path, out_path):\n        ''' transfer a file from local to chroot '''\n\n        vvv(\"PUT %s TO %s\" % (in_path, out_path), host=self.chroot)\n\n        try:\n            with open(in_path, 'rb') as in_file:\n                try:\n                    p = self._buffered_exec_command('dd of=%s' % out_path, None, stdin=in_file)\n                except OSError:\n                    raise errors.AnsibleError(\"chroot connection requires dd command in the chroot\")\n                try:\n                    stdout, stderr = p.communicate()\n                except:\n                    traceback.print_exc()\n                    raise errors.AnsibleError(\"failed to transfer file %s to %s\" % (in_path, out_path))\n                if p.returncode != 0:\n                    raise errors.AnsibleError(\"failed to transfer file %s to %s:\\n%s\\n%s\" % (in_path, out_path, stdout, stderr))\n        except IOError:\n            raise errors.AnsibleError(\"file or module does not exist at: %s\" % in_path)\n\n    def fetch_file(self, in_path, out_path):\n        ''' fetch a file from chroot to local '''\n\n        vvv(\"FETCH %s TO %s\" % (in_path, out_path), host=self.chroot)\n\n        try:\n            p = self._buffered_exec_command('dd if=%s bs=%s' % (in_path, BUFSIZE), None)\n        except OSError:\n            raise errors.AnsibleError(\"chroot connection requires dd command in the jail\")\n\n        with open(out_path, 'wb+') as out_file:\n            try:\n                for chunk in p.stdout.read(BUFSIZE):\n                    out_file.write(chunk)\n            except:\n                traceback.print_exc()\n                raise errors.AnsibleError(\"failed to transfer file %s to %s\" % (in_path, out_path))\n            stdout, stderr = p.communicate()\n            if p.returncode != 0:\n                raise errors.AnsibleError(\"failed to transfer file %s to %s:\\n%s\\n%s\" % (in_path, out_path, stdout, stderr))\n\n    def close(self):\n        ''' terminate the connection; nothing to do here '''\n        pass\n"], "filenames": ["lib/ansible/plugins/connections/chroot.py"], "buggy_code_start_loc": [2], "buggy_code_end_loc": [131], "fixing_code_start_loc": [3], "fixing_code_end_loc": [151], "type": "CWE-59", "message": "The chroot, jail, and zone connection plugins in ansible before 1.9.2 allow local users to escape a restricted environment via a symlink attack.", "other": {"cve": {"id": "CVE-2015-6240", "sourceIdentifier": "cve@mitre.org", "published": "2017-06-07T20:29:00.287", "lastModified": "2019-09-16T15:15:10.180", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The chroot, jail, and zone connection plugins in ansible before 1.9.2 allow local users to escape a restricted environment via a symlink attack."}, {"lang": "es", "value": "Los plugins chroot, jail, y zone connection en Ansible anterior a versi\u00f3n 1.9.2 permiten a los usuarios locales escapar de un entorno restringido por medio de un ataque de enlace simb\u00f3lico (symlink)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-59"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:ansible:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.9.1", "matchCriteriaId": "2698313F-3368-4111-A105-FB88E9C474FD"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2015/08/17/10", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1243468", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/ansible/ansible/commit/952166f48eb0f5797b75b160fd156bbe1e8fc647", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/ansible/ansible/commit/ca2f2c4ebd7b5e097eab0a710f79c1f63badf95b", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/09/msg00016.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/ansible/ansible/commit/952166f48eb0f5797b75b160fd156bbe1e8fc647"}}