{"buggy_code": ["#\n# Copyright (C) 2006-2010 Red Hat, Inc.\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n#\n\nimport gettext\ntranslation=gettext.translation('setroubleshoot-plugins', fallback=True)\n_=translation.gettext\n\nfrom setroubleshoot.util import *\nfrom setroubleshoot.Plugin import Plugin\n\nimport commands\nimport sys\n\ndef is_execstack(path):\n    if path[0] != \"/\":\n        return False\n\n    x = commands.getoutput(\"execstack -q %s\" % path).split()\n    return ( x[0]  == \"X\" )\n\ndef find_execstack(exe, pid):\n    execstacklist = []\n    for path in commands.getoutput(\"ldd %s\" % exe).split():\n        if is_execstack(path) and path not in execstacklist:\n                execstacklist.append(path)\n    try:\n        fd = open(\"/proc/%s/maps\" % pid , \"r\")\n        for rec in fd.readlines():\n            for path in rec.split():\n                if is_execstack(path) and path not in execstacklist:\n                    execstacklist.append(path)\n    except IOError:\n        pass\n\n    return execstacklist\n\nclass plugin(Plugin):\n    summary =_('''\n    SELinux is preventing $SOURCE_PATH from making the program stack executable.\n    ''')\n\n    problem_description = _('''\n    The $SOURCE application attempted to make its stack\n    executable.  This is a potential security problem.  This should\n    never ever be necessary. Stack memory is not executable on most\n    OSes these days and this will not change. Executable stack memory\n    is one of the biggest security problems. An execstack error might\n    in fact be most likely raised by malicious code. Applications are\n    sometimes coded incorrectly and request this permission.  The\n    <a href=\"http://people.redhat.com/drepper/selinux-mem.html\">SELinux Memory Protection Tests</a>\n    web page explains how to remove this requirement.  If $SOURCE does not\n    work and you need it to work, you can configure SELinux\n    temporarily to allow this access until the application is fixed. Please\nfile a bug report.\n    ''')\n\n    fix_description = _('''\n    Sometimes a library is accidentally marked with the execstack flag,\n    if you find a library with this flag you can clear it with the\n    execstack -c LIBRARY_PATH.  Then retry your application.  If the\n    app continues to not work, you can turn the flag back on with\n    execstack -s LIBRARY_PATH.\n    ''')\n\n    fix_cmd = \"\"\n\n    if_text = _(\"you do not think $SOURCE_PATH should need to map stack memory that is both writable and executable.\")\n    then_text = _(\"you need to report a bug. \\nThis is a potentially dangerous access.\")\n    do_text = _(\"Contact your security administrator and report this issue.\")\n\n    def get_if_text(self, avc, args):\n        try:\n            path = args[0]\n            if not path:\n                return self.if_text\n\n            return _(\"you believe that \\n%s\\nshould not require execstack\") % path\n        except:\n            return self.if_text\n\n    def get_then_text(self, avc, args):\n        try:\n            path = args[0]\n            if not path:\n                return self.then_text\n            return _(\"you should clear the execstack flag and see if $SOURCE_PATH works correctly.\\nReport this as a bug on %s.\\nYou can clear the exestack flag by executing:\") % path\n        except:\n            return self.then_text\n\n    def get_do_text(self, avc, args):\n        try:\n            path = args[0]\n            if not path:\n                return self.do_text\n\n            return _(\"execstack -c %s\") % path\n        except:\n            return self.do_text\n\n    def __init__(self):\n        Plugin.__init__(self,__name__)\n\n    def analyze(self, avc):\n        if (avc.matches_source_types(['unconfined_t', 'staff_t', 'user_t', 'guest_t', 'xguest_t']) and\n           avc.has_any_access_in(['execstack'])):\n            reports = []\n            for i in find_execstack(avc.spath, avc.pid):\n                reports.append(self.report((i,avc)))\n\n            if len(reports) > 0:\n                return reports\n\n            return self.report((None,None))\n        else:\n            return None\n", "#! /usr/bin/python\nimport commands\nimport sys\n\ndef is_execstack(path):\n    if path[0] != \"/\":\n        return False\n\n    x = commands.getoutput(\"execstack -q %s\" %   path).split()\n    return ( x[0]  == \"X\" )\n\ndef find_execstack(exe, pid):\n    execstacklist = []\n    for path in commands.getoutput(\"ldd %s\" %   sys.argv[1]).split():\n        if is_execstack(path) and path not in execstacklist:\n                execstacklist.append(path)\n    try:\n        fd = open(\"/proc/%s/maps\" % pid , \"r\")\n        for rec in fd.readlines():\n            for path in rec.split():\n                if is_execstack(path) and path not in execstacklist:\n                    execstacklist.append(path)\n    except IOError:\n        pass\n\n    return execstacklist\n\npid=-1\ntry:\n    pid\t= sys.argv[2]\nexcept:\n    pass\n\ntry:\n\tpath=sys.argv[1]\n\tfor i in find_execstack(path, pid):\n\t    print \"execstack -c   %s\" %  i\nexcept:\n\tprint \"Usage:  %s  executable [ pid ]\" % sys.argv[0]\n\n\n\n"], "fixing_code": ["#\n# Copyright (C) 2006-2010 Red Hat, Inc.\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n#\n\nimport gettext\ntranslation=gettext.translation('setroubleshoot-plugins', fallback=True)\n_=translation.gettext\n\nfrom setroubleshoot.util import *\nfrom setroubleshoot.Plugin import Plugin\n\nimport subprocess\nimport sys\n\ndef is_execstack(path):\n    if path[0] != \"/\":\n        return False\n\n    x = subprocess.check_output([\"execstack\",  \"-q\", path], universal_newlines=True).split()\n    return ( x[0] == \"X\" )\n\ndef find_execstack(exe, pid):\n    execstacklist = []\n    for path in subprocess.check_output([\"ldd\", exe], universal_newlines=True).split():\n        if is_execstack(path) and path not in execstacklist:\n                execstacklist.append(path)\n    try:\n        fd = open(\"/proc/%s/maps\" % pid , \"r\")\n        for rec in fd.readlines():\n            for path in rec.split():\n                if is_execstack(path) and path not in execstacklist:\n                    execstacklist.append(path)\n    except IOError:\n        pass\n\n    return execstacklist\n\nclass plugin(Plugin):\n    summary =_('''\n    SELinux is preventing $SOURCE_PATH from making the program stack executable.\n    ''')\n\n    problem_description = _('''\n    The $SOURCE application attempted to make its stack\n    executable.  This is a potential security problem.  This should\n    never ever be necessary. Stack memory is not executable on most\n    OSes these days and this will not change. Executable stack memory\n    is one of the biggest security problems. An execstack error might\n    in fact be most likely raised by malicious code. Applications are\n    sometimes coded incorrectly and request this permission.  The\n    <a href=\"http://people.redhat.com/drepper/selinux-mem.html\">SELinux Memory Protection Tests</a>\n    web page explains how to remove this requirement.  If $SOURCE does not\n    work and you need it to work, you can configure SELinux\n    temporarily to allow this access until the application is fixed. Please\nfile a bug report.\n    ''')\n\n    fix_description = _('''\n    Sometimes a library is accidentally marked with the execstack flag,\n    if you find a library with this flag you can clear it with the\n    execstack -c LIBRARY_PATH.  Then retry your application.  If the\n    app continues to not work, you can turn the flag back on with\n    execstack -s LIBRARY_PATH.\n    ''')\n\n    fix_cmd = \"\"\n\n    if_text = _(\"you do not think $SOURCE_PATH should need to map stack memory that is both writable and executable.\")\n    then_text = _(\"you need to report a bug. \\nThis is a potentially dangerous access.\")\n    do_text = _(\"Contact your security administrator and report this issue.\")\n\n    def get_if_text(self, avc, args):\n        try:\n            path = args[0]\n            if not path:\n                return self.if_text\n\n            return _(\"you believe that \\n%s\\nshould not require execstack\") % path\n        except:\n            return self.if_text\n\n    def get_then_text(self, avc, args):\n        try:\n            path = args[0]\n            if not path:\n                return self.then_text\n            return _(\"you should clear the execstack flag and see if $SOURCE_PATH works correctly.\\nReport this as a bug on %s.\\nYou can clear the exestack flag by executing:\") % path\n        except:\n            return self.then_text\n\n    def get_do_text(self, avc, args):\n        try:\n            path = args[0]\n            if not path:\n                return self.do_text\n\n            return _(\"execstack -c %s\") % path\n        except:\n            return self.do_text\n\n    def __init__(self):\n        Plugin.__init__(self,__name__)\n\n    def analyze(self, avc):\n        if (avc.matches_source_types(['unconfined_t', 'staff_t', 'user_t', 'guest_t', 'xguest_t']) and\n           avc.has_any_access_in(['execstack'])):\n            reports = []\n            for i in find_execstack(avc.spath, avc.pid):\n                reports.append(self.report((i,avc)))\n\n            if len(reports) > 0:\n                return reports\n\n            return self.report((None,None))\n        else:\n            return None\n", "#! /usr/bin/python\nimport subprocess\nimport sys\n\ndef is_execstack(path):\n    if path[0] != \"/\":\n        return False\n\n    x = subprocess.check_output([\"execstack\",  \"-q\", path], universal_newlines=True).split()\n    return ( x[0]  == \"X\" )\n\ndef find_execstack(exe, pid):\n    execstacklist = []\n    for path in subprocess.check_output([\"ldd\", sys.argv[1]], universal_newlines=True).split():\n        if is_execstack(path) and path not in execstacklist:\n                execstacklist.append(path)\n    try:\n        fd = open(\"/proc/%s/maps\" % pid , \"r\")\n        for rec in fd.readlines():\n            for path in rec.split():\n                if is_execstack(path) and path not in execstacklist:\n                    execstacklist.append(path)\n    except IOError:\n        pass\n\n    return execstacklist\n\npid=-1\ntry:\n    pid\t= sys.argv[2]\nexcept:\n    pass\n\ntry:\n\tpath=sys.argv[1]\n\tfor i in find_execstack(path, pid):\n\t    print \"execstack -c   %s\" %  i\nexcept:\n\tprint \"Usage:  %s  executable [ pid ]\" % sys.argv[0]\n\n\n\n"], "filenames": ["plugins/src/allow_execstack.py", "plugins/src/findexecstack"], "buggy_code_start_loc": [26, 2], "buggy_code_end_loc": [39, 15], "fixing_code_start_loc": [26, 2], "fixing_code_end_loc": [39, 15], "type": "CWE-77", "message": "The allow_execstack plugin for setroubleshoot allows local users to execute arbitrary commands by triggering an execstack SELinux denial with a crafted filename, related to the commands.getoutput function.", "other": {"cve": {"id": "CVE-2016-4446", "sourceIdentifier": "secalert@redhat.com", "published": "2017-04-11T18:59:00.290", "lastModified": "2017-04-17T13:29:18.297", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The allow_execstack plugin for setroubleshoot allows local users to execute arbitrary commands by triggering an execstack SELinux denial with a crafted filename, related to the commands.getoutput function."}, {"lang": "es", "value": "El complemento allow_execstack para setroubleshoot permite a los usuarios locales ejecutar comandos arbitrarios al activar una denegaci\u00f3n SELinux de execstack con un nombre de archivo manipulado, relacionado con la funci\u00f3n commands.getoutput."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 6.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-77"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:setroubleshoot_project:setroubleshoot:*:*:*:*:*:*:*:*", "versionEndIncluding": "-", "matchCriteriaId": "81FFD870-6377-4CE9-89C0-07EA99635370"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "33C068A4-3780-4EAB-A937-6082DF847564"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_hpc_node:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "3C84489B-B08C-4854-8A12-D01B6E45CF79"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "825ECE2D-E232-46E0-A047-074B34DB1E97"}]}]}], "references": [{"url": "http://seclists.org/oss-sec/2016/q2/575", "source": "secalert@redhat.com", "tags": ["Exploit", "Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/91427", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1036144", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2016:1293", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1339250", "source": "secalert@redhat.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/fedora-selinux/setroubleshoot/commit/eaccf4c0d20a27d3df5ff6de8c9dcc80f6f40718", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://rhn.redhat.com/errata/RHSA-2016-1267.html", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/fedora-selinux/setroubleshoot/commit/eaccf4c0d20a27d3df5ff6de8c9dcc80f6f40718"}}