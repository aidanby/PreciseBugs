{"buggy_code": ["package smokescreen\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"strings\"\n\t\"syscall\"\n\t\"time\"\n\n\tproxyproto \"github.com/armon/go-proxyproto\"\n\t\"github.com/rs/xid\"\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/stripe/goproxy\"\n\t\"github.com/stripe/smokescreen/internal/einhorn\"\n\tacl \"github.com/stripe/smokescreen/pkg/smokescreen/acl/v1\"\n\t\"github.com/stripe/smokescreen/pkg/smokescreen/conntrack\"\n)\n\nconst (\n\tipAllowDefault ipType = iota\n\tipAllowUserConfigured\n\tipDenyNotGlobalUnicast\n\tipDenyPrivateRange\n\tipDenyUserConfigured\n\n\tdenyMsgTmpl = \"Egress proxying is denied to host '%s': %s.\"\n\n\thttpProxy    = \"http\"\n\tconnectProxy = \"connect\"\n)\n\nconst (\n\tLogFieldID               = \"id\"\n\tLogFieldOutLocalAddr     = \"outbound_local_addr\"\n\tLogFieldOutRemoteAddr    = \"outbound_remote_addr\"\n\tLogFieldInRemoteAddr     = \"inbound_remote_addr\"\n\tLogFieldProxyType        = \"proxy_type\"\n\tLogFieldRequestedHost    = \"requested_host\"\n\tLogFieldStartTime        = \"start_time\"\n\tLogFieldTraceID          = \"trace_id\"\n\tLogFieldInRemoteX509CN   = \"inbound_remote_x509_cn\"\n\tLogFieldInRemoteX509OU   = \"inbound_remote_x509_ou\"\n\tLogFieldRole             = \"role\"\n\tLogFieldProject          = \"project\"\n\tLogFieldContentLength    = \"content_length\"\n\tLogFieldDecisionReason   = \"decision_reason\"\n\tLogFieldEnforceWouldDeny = \"enforce_would_deny\"\n\tLogFieldAllow            = \"allow\"\n\tLogFieldError            = \"error\"\n\tCanonicalProxyDecision   = \"CANONICAL-PROXY-DECISION\"\n\tLogFieldConnEstablishMS  = \"conn_establish_time_ms\"\n\tLogFieldDNSLookupTime    = \"dns_lookup_time_ms\"\n)\n\ntype ipType int\n\ntype aclDecision struct {\n\treason, role, project, outboundHost string\n\tresolvedAddr                        *net.TCPAddr\n\tallow                               bool\n\tenforceWouldDeny                    bool\n}\n\ntype smokescreenContext struct {\n\tcfg           *Config\n\tstart         time.Time\n\tdecision      *aclDecision\n\tproxyType     string\n\tlogger        *logrus.Entry\n\trequestedHost string\n\n\t// Time spent resolving the requested hostname\n\tlookupTime time.Duration\n}\n\n// ExitStatus is used to log Smokescreen's connection status at shutdown time\ntype ExitStatus int\n\nconst (\n\tClosed ExitStatus = iota\n\tIdle\n\tTimeout\n)\n\nfunc (e ExitStatus) String() string {\n\tswitch e {\n\tcase Closed:\n\t\treturn \"All connections closed\"\n\tcase Idle:\n\t\treturn \"All connections idle\"\n\tcase Timeout:\n\t\treturn \"Timed out waiting for connections to become idle\"\n\tdefault:\n\t\treturn \"Unknown exit status\"\n\t}\n}\n\ntype denyError struct {\n\terror\n}\n\nfunc (t ipType) IsAllowed() bool {\n\treturn t == ipAllowDefault || t == ipAllowUserConfigured\n}\n\nfunc (t ipType) String() string {\n\tswitch t {\n\tcase ipAllowDefault:\n\t\treturn \"Allow: Default\"\n\tcase ipAllowUserConfigured:\n\t\treturn \"Allow: User Configured\"\n\tcase ipDenyNotGlobalUnicast:\n\t\treturn \"Deny: Not Global Unicast\"\n\tcase ipDenyPrivateRange:\n\t\treturn \"Deny: Private Range\"\n\tcase ipDenyUserConfigured:\n\t\treturn \"Deny: User Configured\"\n\tdefault:\n\t\tpanic(fmt.Errorf(\"unknown ip type %d\", t))\n\t}\n}\n\nfunc (t ipType) statsdString() string {\n\tswitch t {\n\tcase ipAllowDefault:\n\t\treturn \"resolver.allow.default\"\n\tcase ipAllowUserConfigured:\n\t\treturn \"resolver.allow.user_configured\"\n\tcase ipDenyNotGlobalUnicast:\n\t\treturn \"resolver.deny.not_global_unicast\"\n\tcase ipDenyPrivateRange:\n\t\treturn \"resolver.deny.private_range\"\n\tcase ipDenyUserConfigured:\n\t\treturn \"resolver.deny.user_configured\"\n\tdefault:\n\t\tpanic(fmt.Errorf(\"unknown ip type %d\", t))\n\t}\n}\n\nconst errorHeader = \"X-Smokescreen-Error\"\nconst roleHeader = \"X-Smokescreen-Role\"\nconst traceHeader = \"X-Smokescreen-Trace-ID\"\n\nfunc addrIsInRuleRange(ranges []RuleRange, addr *net.TCPAddr) bool {\n\tfor _, rng := range ranges {\n\t\t// If the range specifies a port and the port doesn't match,\n\t\t// then this range doesn't match\n\t\tif rng.Port != 0 && addr.Port != rng.Port {\n\t\t\tcontinue\n\t\t}\n\n\t\tif rng.Net.Contains(addr.IP) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc classifyAddr(config *Config, addr *net.TCPAddr) ipType {\n\tif !addr.IP.IsGlobalUnicast() || addr.IP.IsLoopback() {\n\t\tif addrIsInRuleRange(config.AllowRanges, addr) {\n\t\t\treturn ipAllowUserConfigured\n\t\t} else {\n\t\t\treturn ipDenyNotGlobalUnicast\n\t\t}\n\t}\n\n\tif addrIsInRuleRange(config.AllowRanges, addr) {\n\t\treturn ipAllowUserConfigured\n\t} else if addrIsInRuleRange(config.DenyRanges, addr) {\n\t\treturn ipDenyUserConfigured\n\t} else if addrIsInRuleRange(PrivateRuleRanges, addr) && !config.UnsafeAllowPrivateRanges {\n\t\treturn ipDenyPrivateRange\n\t} else {\n\t\treturn ipAllowDefault\n\t}\n}\n\nfunc resolveTCPAddr(config *Config, network, addr string) (*net.TCPAddr, error) {\n\tif network != \"tcp\" {\n\t\treturn nil, fmt.Errorf(\"unknown network type %q\", network)\n\t}\n\thost, port, err := net.SplitHostPort(addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tctx := context.Background()\n\tresolvedPort, err := config.Resolver.LookupPort(ctx, network, port)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tips, err := config.Resolver.LookupIP(ctx, config.Network, host)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(ips) < 1 {\n\t\treturn nil, fmt.Errorf(\"no IPs resolved\")\n\t}\n\n\treturn &net.TCPAddr{\n\t\tIP:   ips[0],\n\t\tPort: resolvedPort,\n\t}, nil\n}\n\nfunc safeResolve(config *Config, network, addr string) (*net.TCPAddr, string, error) {\n\tconfig.MetricsClient.Incr(\"resolver.attempts_total\", 1)\n\tresolved, err := resolveTCPAddr(config, network, addr)\n\tif err != nil {\n\t\tconfig.MetricsClient.Incr(\"resolver.errors_total\", 1)\n\t\treturn nil, \"\", err\n\t}\n\n\tclassification := classifyAddr(config, resolved)\n\tconfig.MetricsClient.Incr(classification.statsdString(), 1)\n\n\tif classification.IsAllowed() {\n\t\treturn resolved, classification.String(), nil\n\t}\n\treturn nil, \"destination address was denied by rule, see error\", denyError{fmt.Errorf(\"The destination address (%s) was denied by rule '%s'\", resolved.IP, classification)}\n}\n\nfunc proxyContext(ctx context.Context) (*goproxy.ProxyCtx, bool) {\n\tpctx, ok := ctx.Value(goproxy.ProxyContextKey).(*goproxy.ProxyCtx)\n\treturn pctx, ok\n}\n\nfunc dialContext(ctx context.Context, network, addr string) (net.Conn, error) {\n\tpctx, ok := proxyContext(ctx)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"dialContext missing required *goproxy.ProxyCtx\")\n\t}\n\n\tsctx, ok := pctx.UserData.(*smokescreenContext)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"dialContext missing required *smokescreenContext\")\n\t}\n\td := sctx.decision\n\n\t// If an address hasn't been resolved, does not match the original outboundHost,\n\t// or is not tcp we must re-resolve it before establishing the connection.\n\tif d.resolvedAddr == nil || d.outboundHost != addr || network != \"tcp\" {\n\t\tvar err error\n\t\td.resolvedAddr, d.reason, err = safeResolve(sctx.cfg, network, addr)\n\t\tif err != nil {\n\t\t\tif _, ok := err.(denyError); ok {\n\t\t\t\tsctx.cfg.Log.WithFields(\n\t\t\t\t\tlogrus.Fields{\n\t\t\t\t\t\t\"address\": addr,\n\t\t\t\t\t\t\"error\":   err,\n\t\t\t\t\t}).Error(\"unexpected illegal address in dialer\")\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tvar conn net.Conn\n\tvar err error\n\n\tstart := time.Now()\n\tif sctx.cfg.ProxyDialTimeout == nil {\n\t\tconn, err = net.DialTimeout(network, d.resolvedAddr.String(), sctx.cfg.ConnectTimeout)\n\t} else {\n\t\tconn, err = sctx.cfg.ProxyDialTimeout(ctx, network, d.resolvedAddr.String(), sctx.cfg.ConnectTimeout)\n\t}\n\tconnTime := time.Since(start)\n\n\tfields := logrus.Fields{\n\t\tLogFieldConnEstablishMS: connTime.Milliseconds(),\n\t}\n\n\tif sctx.cfg.TimeConnect {\n\t\tdomainTag := fmt.Sprintf(\"domain:%s\", sctx.requestedHost)\n\t\tsctx.cfg.MetricsClient.TimingWithTags(\"cn.atpt.connect.time\", connTime, 1, []string{domainTag})\n\t}\n\n\tif err != nil {\n\t\tsctx.cfg.MetricsClient.IncrWithTags(\"cn.atpt.total\", []string{\"success:false\"}, 1)\n\t\treturn nil, err\n\t}\n\tsctx.cfg.MetricsClient.IncrWithTags(\"cn.atpt.total\", []string{\"success:true\"}, 1)\n\n\tif conn != nil {\n\t\tfields := logrus.Fields{}\n\n\t\tif addr := conn.LocalAddr(); addr != nil {\n\t\t\tfields[LogFieldOutLocalAddr] = addr.String()\n\t\t}\n\n\t\tif addr := conn.RemoteAddr(); addr != nil {\n\t\t\tfields[LogFieldOutRemoteAddr] = addr.String()\n\t\t}\n\n\t}\n\tsctx.logger = sctx.logger.WithFields(fields)\n\n\t// Only wrap CONNECT conns with an InstrumentedConn. Connections used for traditional HTTP proxy\n\t// requests are pooled and reused by net.Transport.\n\tif sctx.proxyType == connectProxy {\n\t\tic := sctx.cfg.ConnTracker.NewInstrumentedConnWithTimeout(conn, sctx.cfg.IdleTimeout, sctx.logger, d.role, d.outboundHost, sctx.proxyType)\n\t\tpctx.ConnErrorHandler = ic.Error\n\t\tconn = ic\n\t} else {\n\t\tconn = NewTimeoutConn(conn, sctx.cfg.IdleTimeout)\n\t}\n\n\treturn conn, nil\n}\n\n// HTTPErrorHandler allows returning a custom error response when smokescreen\n// fails to connect to the proxy target.\nfunc HTTPErrorHandler(w io.WriteCloser, pctx *goproxy.ProxyCtx, err error) {\n\tsctx := pctx.UserData.(*smokescreenContext)\n\tresp := rejectResponse(pctx, err)\n\n\tif err := resp.Write(w); err != nil {\n\t\tsctx.logger.Errorf(\"Failed to write HTTP error response: %s\", err)\n\t}\n\n\tif err := w.Close(); err != nil {\n\t\tsctx.logger.Errorf(\"Failed to close proxy client connection: %s\", err)\n\t}\n}\n\nfunc rejectResponse(pctx *goproxy.ProxyCtx, err error) *http.Response {\n\tsctx := pctx.UserData.(*smokescreenContext)\n\n\tvar msg, status string\n\tvar code int\n\n\tif e, ok := err.(net.Error); ok {\n\t\t// net.Dial timeout\n\t\tif e.Timeout() {\n\t\t\tstatus = \"Gateway timeout\"\n\t\t\tcode = http.StatusGatewayTimeout\n\t\t\tmsg = \"Timed out connecting to remote host: \" + e.Error()\n\t\t} else {\n\t\t\tstatus = \"Bad gateway\"\n\t\t\tcode = http.StatusBadGateway\n\t\t\tmsg = \"Failed to connect to remote host: \" + e.Error()\n\t\t}\n\t} else if e, ok := err.(denyError); ok {\n\t\tstatus = \"Request rejected by proxy\"\n\t\tcode = http.StatusProxyAuthRequired\n\t\tmsg = fmt.Sprintf(denyMsgTmpl, pctx.Req.Host, e.Error())\n\t} else {\n\t\tstatus = \"Internal server error\"\n\t\tcode = http.StatusInternalServerError\n\t\tmsg = \"An unexpected error occurred: \" + err.Error()\n\t\tsctx.logger.WithField(\"error\", err.Error()).Warn(\"rejectResponse called with unexpected error\")\n\t}\n\n\t// Do not double log deny errors, they are logged in a previous call to logProxy.\n\tif _, ok := err.(denyError); !ok {\n\t\tsctx.logger.Error(msg)\n\t}\n\n\tif sctx.cfg.AdditionalErrorMessageOnDeny != \"\" {\n\t\tmsg = fmt.Sprintf(\"%s\\n\\n%s\\n\", msg, sctx.cfg.AdditionalErrorMessageOnDeny)\n\t}\n\n\tresp := goproxy.NewResponse(pctx.Req, goproxy.ContentTypeText, code, msg+\"\\n\")\n\tresp.Status = status\n\tresp.ProtoMajor = pctx.Req.ProtoMajor\n\tresp.ProtoMinor = pctx.Req.ProtoMinor\n\tresp.Header.Set(errorHeader, msg)\n\tif sctx.cfg.RejectResponseHandler != nil {\n\t\tsctx.cfg.RejectResponseHandler(resp)\n\t}\n\treturn resp\n}\n\nfunc configureTransport(tr *http.Transport, cfg *Config) {\n\tif cfg.TransportMaxIdleConns != 0 {\n\t\ttr.MaxIdleConns = cfg.TransportMaxIdleConns\n\t}\n\n\tif cfg.TransportMaxIdleConnsPerHost != 0 {\n\t\ttr.MaxIdleConnsPerHost = cfg.TransportMaxIdleConns\n\t}\n\n\tif cfg.IdleTimeout != 0 {\n\t\ttr.IdleConnTimeout = cfg.IdleTimeout\n\t}\n}\n\nfunc newContext(cfg *Config, proxyType string, req *http.Request) *smokescreenContext {\n\tstart := time.Now()\n\n\tlogger := cfg.Log.WithFields(logrus.Fields{\n\t\tLogFieldID:            xid.New().String(),\n\t\tLogFieldInRemoteAddr:  req.RemoteAddr,\n\t\tLogFieldProxyType:     proxyType,\n\t\tLogFieldRequestedHost: req.Host,\n\t\tLogFieldStartTime:     start.UTC(),\n\t\tLogFieldTraceID:       req.Header.Get(traceHeader),\n\t})\n\n\treturn &smokescreenContext{\n\t\tcfg:           cfg,\n\t\tlogger:        logger,\n\t\tproxyType:     proxyType,\n\t\tstart:         start,\n\t\trequestedHost: req.Host,\n\t}\n}\n\nfunc BuildProxy(config *Config) *goproxy.ProxyHttpServer {\n\tproxy := goproxy.NewProxyHttpServer()\n\tproxy.Verbose = false\n\tconfigureTransport(proxy.Tr, config)\n\n\t// dialContext will be invoked for both CONNECT and traditional proxy requests\n\tproxy.Tr.DialContext = dialContext\n\n\t// Use a custom goproxy.RoundTripperFunc to ensure that the correct context is attached to the request.\n\t// This is only used for non-CONNECT HTTP proxy requests. For connect requests, goproxy automatically\n\t// attaches goproxy.ProxyCtx prior to calling dialContext.\n\trtFn := goproxy.RoundTripperFunc(func(req *http.Request, pctx *goproxy.ProxyCtx) (*http.Response, error) {\n\t\tctx := context.WithValue(req.Context(), goproxy.ProxyContextKey, pctx)\n\t\treturn proxy.Tr.RoundTrip(req.WithContext(ctx))\n\t})\n\n\t// Associate a timeout with the CONNECT proxy client connection\n\tif config.IdleTimeout != 0 {\n\t\tproxy.ConnectClientConnHandler = func(conn net.Conn) net.Conn {\n\t\t\treturn NewTimeoutConn(conn, config.IdleTimeout)\n\t\t}\n\t}\n\n\t// Handle traditional HTTP proxy\n\tproxy.OnRequest().DoFunc(func(req *http.Request, pctx *goproxy.ProxyCtx) (*http.Request, *http.Response) {\n\n\t\t// We are intentionally *not* setting pctx.HTTPErrorHandler because with traditional HTTP\n\t\t// proxy requests we are able to specify the request during the call to OnResponse().\n\t\tsctx := newContext(config, httpProxy, req)\n\n\t\t// Attach smokescreenContext to goproxy.ProxyCtx\n\t\tpctx.UserData = sctx\n\n\t\t// Delete Smokescreen specific headers before goproxy forwards the request\n\t\tdefer func() {\n\t\t\treq.Header.Del(roleHeader)\n\t\t\treq.Header.Del(traceHeader)\n\t\t}()\n\n\t\t// Set this on every request as every request mints a new goproxy.ProxyCtx\n\t\tpctx.RoundTripper = rtFn\n\n\t\t// Build an address parsable by net.ResolveTCPAddr\n\t\tremoteHost := req.Host\n\t\tif strings.LastIndex(remoteHost, \":\") <= strings.LastIndex(remoteHost, \"]\") {\n\t\t\tswitch req.URL.Scheme {\n\t\t\tcase \"http\":\n\t\t\t\tremoteHost = net.JoinHostPort(remoteHost, \"80\")\n\t\t\tcase \"https\":\n\t\t\t\tremoteHost = net.JoinHostPort(remoteHost, \"443\")\n\t\t\tdefault:\n\t\t\t\tremoteHost = net.JoinHostPort(remoteHost, \"0\")\n\t\t\t}\n\t\t}\n\n\t\tsctx.logger.WithField(\"url\", req.RequestURI).Debug(\"received HTTP proxy request\")\n\n\t\tsctx.decision, sctx.lookupTime, pctx.Error = checkIfRequestShouldBeProxied(config, req, remoteHost)\n\n\t\t// Returning any kind of response in this handler is goproxy's way of short circuiting\n\t\t// the request. The original request will never be sent, and goproxy will invoke our\n\t\t// response filter attached via the OnResponse() handler.\n\t\tif pctx.Error != nil {\n\t\t\treturn req, rejectResponse(pctx, pctx.Error)\n\t\t}\n\t\tif !sctx.decision.allow {\n\t\t\treturn req, rejectResponse(pctx, denyError{errors.New(sctx.decision.reason)})\n\t\t}\n\n\t\t// Proceed with proxying the request\n\t\treturn req, nil\n\t})\n\n\t// Handle CONNECT proxy to TLS & other TCP protocols destination\n\tproxy.OnRequest().HandleConnectFunc(func(host string, pctx *goproxy.ProxyCtx) (*goproxy.ConnectAction, string) {\n\t\tpctx.UserData = newContext(config, connectProxy, pctx.Req)\n\t\tpctx.HTTPErrorHandler = HTTPErrorHandler\n\n\t\t// Defer logging the proxy event here because logProxy relies\n\t\t// on state set in handleConnect\n\t\tdefer logProxy(config, pctx)\n\t\tdefer pctx.Req.Header.Del(traceHeader)\n\n\t\terr := handleConnect(config, pctx)\n\t\tif err != nil {\n\t\t\tpctx.Resp = rejectResponse(pctx, err)\n\t\t\treturn goproxy.RejectConnect, \"\"\n\t\t}\n\t\treturn goproxy.OkConnect, host\n\t})\n\n\t// Strangely, goproxy can invoke this same function twice for a single HTTP request.\n\t//\n\t// If a proxy request is rejected due to an ACL denial, the response passed to this\n\t// function was created by Smokescreen's call to rejectResponse() in the OnRequest()\n\t// handler. This only happens once. This is also the behavior for an allowed request\n\t// which is completed successfully.\n\t//\n\t// If a proxy request is allowed, but the RoundTripper returns an error fulfulling\n\t// the HTTP request, goproxy will invoke this OnResponse() filter twice. First this\n\t// function will be called with a nil response, and as a result this function will\n\t// return a response to send back to the proxy client using rejectResponse(). This\n\t// function will be called again with the previously returned response, which will\n\t// simply trigger the logHTTP function and return.\n\tproxy.OnResponse().DoFunc(func(resp *http.Response, pctx *goproxy.ProxyCtx) *http.Response {\n\t\tsctx := pctx.UserData.(*smokescreenContext)\n\n\t\tif resp != nil && resp.Header.Get(errorHeader) != \"\" {\n\t\t\tif pctx.Error == nil && sctx.decision.allow {\n\t\t\t\tresp.Header.Del(errorHeader)\n\t\t\t}\n\t\t}\n\n\t\tif resp == nil && pctx.Error != nil {\n\t\t\treturn rejectResponse(pctx, pctx.Error)\n\t\t}\n\n\t\t// In case of an error, this function is called a second time to filter the\n\t\t// response we generate so this logger will be called once.\n\t\tlogProxy(config, pctx)\n\t\treturn resp\n\t})\n\treturn proxy\n}\n\nfunc logProxy(config *Config, pctx *goproxy.ProxyCtx) {\n\tsctx := pctx.UserData.(*smokescreenContext)\n\n\tfields := logrus.Fields{}\n\n\t// attempt to retrieve information about the host originating the proxy request\n\tif pctx.Req.TLS != nil && len(pctx.Req.TLS.PeerCertificates) > 0 {\n\t\tfields[LogFieldInRemoteX509CN] = pctx.Req.TLS.PeerCertificates[0].Subject.CommonName\n\t\tvar ouEntries = pctx.Req.TLS.PeerCertificates[0].Subject.OrganizationalUnit\n\t\tif len(ouEntries) > 0 {\n\t\t\tfields[LogFieldInRemoteX509OU] = ouEntries[0]\n\t\t}\n\t}\n\n\tdecision := sctx.decision\n\tif sctx.decision != nil {\n\t\tfields[LogFieldRole] = decision.role\n\t\tfields[LogFieldProject] = decision.project\n\t}\n\n\t// add the above fields to all future log messages sent using this smokescreen context's logger\n\tsctx.logger = sctx.logger.WithFields(fields)\n\n\t// start a new set of fields used only in this log message\n\tfields = logrus.Fields{}\n\n\t// If a lookup takes less than 1ms it will be rounded down to zero. This can separated from\n\t// actual failures where the default zero value will also have the error field set.\n\tfields[LogFieldDNSLookupTime] = sctx.lookupTime.Milliseconds()\n\n\tif pctx.Resp != nil {\n\t\tfields[LogFieldContentLength] = pctx.Resp.ContentLength\n\t}\n\n\tif sctx.decision != nil {\n\t\tfields[LogFieldDecisionReason] = decision.reason\n\t\tfields[LogFieldEnforceWouldDeny] = decision.enforceWouldDeny\n\t\tfields[LogFieldAllow] = decision.allow\n\t}\n\n\terr := pctx.Error\n\tif err != nil {\n\t\tfields[LogFieldError] = err.Error()\n\t}\n\n\tentry := sctx.logger.WithFields(fields)\n\tvar logMethod func(...interface{})\n\tif _, ok := err.(denyError); !ok && err != nil {\n\t\tlogMethod = entry.Error\n\t} else if decision != nil && decision.allow {\n\t\tlogMethod = entry.Info\n\t} else {\n\t\tlogMethod = entry.Warn\n\t}\n\tlogMethod(CanonicalProxyDecision)\n}\n\nfunc handleConnect(config *Config, pctx *goproxy.ProxyCtx) error {\n\tsctx := pctx.UserData.(*smokescreenContext)\n\n\t// Check if requesting role is allowed to talk to remote\n\tsctx.decision, sctx.lookupTime, pctx.Error = checkIfRequestShouldBeProxied(config, pctx.Req, pctx.Req.Host)\n\tif pctx.Error != nil {\n\t\treturn pctx.Error\n\t}\n\tif !sctx.decision.allow {\n\t\treturn denyError{errors.New(sctx.decision.reason)}\n\t}\n\n\treturn nil\n}\n\nfunc findListener(ip string, defaultPort uint16) (net.Listener, error) {\n\tif einhorn.IsWorker() {\n\t\tlistener, err := einhorn.GetListener(0)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn &einhornListener{Listener: listener}, err\n\t} else {\n\t\treturn net.Listen(\"tcp\", fmt.Sprintf(\"%s:%d\", ip, defaultPort))\n\t}\n}\n\nfunc StartWithConfig(config *Config, quit <-chan interface{}) {\n\tconfig.Log.Println(\"starting\")\n\tproxy := BuildProxy(config)\n\tlistener := config.Listener\n\tvar err error\n\n\tif listener == nil {\n\t\tlistener, err = findListener(config.Ip, config.Port)\n\t\tif err != nil {\n\t\t\tconfig.Log.Fatal(\"can't find listener\", err)\n\t\t}\n\t}\n\n\tif config.SupportProxyProtocol {\n\t\tlistener = &proxyproto.Listener{Listener: listener}\n\t}\n\n\tvar handler http.Handler = proxy\n\n\tif config.Healthcheck != nil {\n\t\thandler = &HealthcheckMiddleware{\n\t\t\tProxy:       handler,\n\t\t\tHealthcheck: config.Healthcheck,\n\t\t}\n\t}\n\n\t// TLS support\n\tif config.TlsConfig != nil {\n\t\tlistener = tls.NewListener(listener, config.TlsConfig)\n\t}\n\n\t// Setup connection tracking\n\tconfig.ConnTracker = conntrack.NewTracker(config.IdleTimeout, config.MetricsClient.StatsdClient, config.Log, config.ShuttingDown)\n\n\tserver := http.Server{\n\t\tHandler: handler,\n\t}\n\n\t// This sets an IdleTimeout on _all_ client connections. CONNECT requests\n\t// hijacked by goproxy inherit the deadline set here. The deadlines are\n\t// reset by the proxy.ConnectClientConnHandler, which wraps the hijacked\n\t// connection in a TimeoutConn which bumps the deadline for every read/write.\n\tif config.IdleTimeout != 0 {\n\t\tserver.IdleTimeout = config.IdleTimeout\n\t}\n\n\tconfig.MetricsClient.started.Store(true)\n\tconfig.ShuttingDown.Store(false)\n\trunServer(config, &server, listener, quit)\n}\n\nfunc runServer(config *Config, server *http.Server, listener net.Listener, quit <-chan interface{}) {\n\t// Runs the server and shuts it down when it receives a signal.\n\t//\n\t// Why aren't we using goji's graceful shutdown library? Great question!\n\t//\n\t// There are several things we might want to do when shutting down gracefully:\n\t// 1. close the listening socket (so that we don't accept *new* connections)\n\t// 2. close *existing* keepalive connections once they become idle\n\t//\n\t// goproxy hijacks the socket and interferes with goji's ability to do the\n\t// latter.  We instead pass InstrumentedConn objects, which wrap net.Conn,\n\t// into goproxy.  ConnTracker keeps a reference to these, which allows us to\n\t// know exactly how long to wait until the connection has become idle, and\n\t// then Close it.\n\n\tif len(config.StatsSocketDir) > 0 {\n\t\tconfig.StatsServer = StartStatsServer(config)\n\t}\n\n\tgraceful := true\n\tkill := make(chan os.Signal, 1)\n\tsignal.Notify(kill, syscall.SIGUSR2, syscall.SIGTERM, syscall.SIGHUP)\n\tgo func() {\n\t\tselect {\n\t\tcase <-kill:\n\t\t\tconfig.Log.Print(\"quitting gracefully\")\n\n\t\tcase <-quit:\n\t\t\tconfig.Log.Print(\"quitting now\")\n\t\t\tgraceful = false\n\t\t}\n\t\tconfig.ShuttingDown.Store(true)\n\n\t\t// Shutdown() will block until all connections are closed unless we\n\t\t// provide it with a cancellation context.\n\t\ttimeout := config.ExitTimeout\n\t\tif !graceful {\n\t\t\ttimeout = 10 * time.Second\n\t\t}\n\n\t\tctx, cancel := context.WithTimeout(context.Background(), timeout)\n\t\tdefer cancel()\n\n\t\terr := server.Shutdown(ctx)\n\t\tif err != nil {\n\t\t\tconfig.Log.Errorf(\"error shutting down http server: %v\", err)\n\t\t}\n\t}()\n\n\tif err := server.Serve(listener); err != http.ErrServerClosed {\n\t\tconfig.Log.Errorf(\"http serve error: %v\", err)\n\t}\n\n\tif graceful {\n\t\t// Wait for all connections to close or become idle before\n\t\t// continuing in an attempt to shutdown gracefully.\n\t\texit := make(chan ExitStatus, 1)\n\n\t\t// This subroutine blocks until all connections close.\n\t\tgo func() {\n\t\t\tconfig.Log.Print(\"Waiting for all connections to close...\")\n\t\t\tconfig.ConnTracker.Wg.Wait()\n\t\t\tconfig.Log.Print(\"All connections are closed. Continuing with shutdown...\")\n\t\t\texit <- Closed\n\t\t}()\n\n\t\t// Always wait for a maximum of config.ExitTimeout\n\t\ttime.AfterFunc(config.ExitTimeout, func() {\n\t\t\tconfig.Log.Printf(\"ExitTimeout %v reached - timing out\", config.ExitTimeout)\n\t\t\texit <- Timeout\n\t\t})\n\n\t\t// Sometimes, connections don't close and remain in the idle state. This subroutine\n\t\t// waits until all open connections are idle before sending the exit signal.\n\t\tgo func() {\n\t\t\tconfig.Log.Print(\"Waiting for all connections to become idle...\")\n\t\t\tbeginTs := time.Now()\n\n\t\t\t// If idleTimeout is set to 0, fall back to using the exit timeout to avoid\n\t\t\t// immediately closing active connections.\n\t\t\tidleTimeout := config.IdleTimeout\n\t\t\tif idleTimeout == 0 {\n\t\t\t\tidleTimeout = config.ExitTimeout\n\t\t\t}\n\n\t\t\tfor {\n\t\t\t\tcheckAgainIn := config.ConnTracker.MaybeIdleIn(idleTimeout)\n\t\t\t\tif checkAgainIn > 0 {\n\t\t\t\t\tif time.Since(beginTs) > config.ExitTimeout {\n\t\t\t\t\t\tconfig.Log.Print(fmt.Sprintf(\"Timed out at %v while waiting for all open connections to become idle.\", config.ExitTimeout))\n\t\t\t\t\t\texit <- Timeout\n\t\t\t\t\t\tbreak\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconfig.Log.Print(fmt.Sprintf(\"There are still active connections. Waiting %v before checking again.\", checkAgainIn))\n\t\t\t\t\t\ttime.Sleep(checkAgainIn)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconfig.Log.Print(\"All connections are idle. Continuing with shutdown...\")\n\t\t\t\t\texit <- Idle\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\t// Wait for the exit signal.\n\t\treason := <-exit\n\t\tconfig.Log.Print(fmt.Sprintf(\"%s: closing all remaining connections.\", reason.String()))\n\t}\n\n\t// Close all open (and idle) connections to send their metrics to log.\n\tconfig.ConnTracker.Range(func(k, v interface{}) bool {\n\t\tk.(*conntrack.InstrumentedConn).Close()\n\t\treturn true\n\t})\n\n\tif config.StatsServer != nil {\n\t\tconfig.StatsServer.Shutdown()\n\t}\n}\n\n// Extract the client's ACL role from the HTTP request, using the configured\n// RoleFromRequest function.  Returns the role, or an error if the role cannot\n// be determined (including no RoleFromRequest configured), unless\n// AllowMissingRole is configured, in which case an empty role and no error is\n// returned.\nfunc getRole(config *Config, req *http.Request) (string, error) {\n\tvar role string\n\tvar err error\n\n\tif config.RoleFromRequest != nil {\n\t\trole, err = config.RoleFromRequest(req)\n\t} else {\n\t\terr = MissingRoleError(\"RoleFromRequest is not configured\")\n\t}\n\n\tswitch {\n\tcase err == nil:\n\t\treturn role, nil\n\tcase IsMissingRoleError(err) && config.AllowMissingRole:\n\t\treturn \"\", nil\n\tdefault:\n\t\tconfig.Log.WithFields(logrus.Fields{\n\t\t\t\"error\":              err,\n\t\t\t\"is_missing_role\":    IsMissingRoleError(err),\n\t\t\t\"allow_missing_role\": config.AllowMissingRole,\n\t\t}).Error(\"Unable to get role for request\")\n\t\treturn \"\", err\n\t}\n}\n\nfunc checkIfRequestShouldBeProxied(config *Config, req *http.Request, outboundHost string) (*aclDecision, time.Duration, error) {\n\tdecision := checkACLsForRequest(config, req, outboundHost)\n\n\tvar lookupTime time.Duration\n\tif decision.allow {\n\t\tstart := time.Now()\n\t\tresolved, reason, err := safeResolve(config, \"tcp\", outboundHost)\n\t\tlookupTime = time.Since(start)\n\t\tif err != nil {\n\t\t\tif _, ok := err.(denyError); !ok {\n\t\t\t\treturn decision, lookupTime, err\n\t\t\t}\n\t\t\tdecision.reason = fmt.Sprintf(\"%s. %s\", err.Error(), reason)\n\t\t\tdecision.allow = false\n\t\t\tdecision.enforceWouldDeny = true\n\t\t} else {\n\t\t\tdecision.resolvedAddr = resolved\n\t\t}\n\t}\n\n\treturn decision, lookupTime, nil\n}\n\nfunc checkACLsForRequest(config *Config, req *http.Request, outboundHost string) *aclDecision {\n\tdecision := &aclDecision{\n\t\toutboundHost: outboundHost,\n\t}\n\n\tif config.EgressACL == nil {\n\t\tdecision.allow = true\n\t\tdecision.reason = \"Egress ACL is not configured\"\n\t\treturn decision\n\t}\n\n\trole, roleErr := getRole(config, req)\n\tif roleErr != nil {\n\t\tconfig.MetricsClient.Incr(\"acl.role_not_determined\", 1)\n\t\tdecision.reason = \"Client role cannot be determined\"\n\t\treturn decision\n\t}\n\n\tdecision.role = role\n\n\tsubmatch := hostExtractRE.FindStringSubmatch(outboundHost)\n\tdestination := submatch[1]\n\n\taclDecision, err := config.EgressACL.Decide(role, destination)\n\tdecision.project = aclDecision.Project\n\tdecision.reason = aclDecision.Reason\n\tif err != nil {\n\t\tconfig.Log.WithFields(logrus.Fields{\n\t\t\t\"error\": err,\n\t\t\t\"role\":  role,\n\t\t}).Warn(\"EgressAcl.Decide returned an error.\")\n\n\t\tconfig.MetricsClient.Incr(\"acl.decide_error\", 1)\n\t\treturn decision\n\t}\n\n\ttags := []string{\n\t\tfmt.Sprintf(\"role:%s\", decision.role),\n\t\tfmt.Sprintf(\"def_rule:%t\", aclDecision.Default),\n\t\tfmt.Sprintf(\"project:%s\", aclDecision.Project),\n\t}\n\n\tswitch aclDecision.Result {\n\tcase acl.Deny:\n\t\tdecision.enforceWouldDeny = true\n\t\tconfig.MetricsClient.IncrWithTags(\"acl.deny\", tags, 1)\n\n\tcase acl.AllowAndReport:\n\t\tdecision.enforceWouldDeny = true\n\t\tconfig.MetricsClient.IncrWithTags(\"acl.report\", tags, 1)\n\t\tdecision.allow = true\n\n\tcase acl.Allow:\n\t\t// Well, everything is going as expected.\n\t\tdecision.allow = true\n\t\tdecision.enforceWouldDeny = false\n\t\tconfig.MetricsClient.IncrWithTags(\"acl.allow\", tags, 1)\n\tdefault:\n\t\tconfig.Log.WithFields(logrus.Fields{\n\t\t\t\"role\":        role,\n\t\t\t\"destination\": destination,\n\t\t\t\"action\":      aclDecision.Result.String(),\n\t\t}).Warn(\"Unknown ACL action\")\n\t\tdecision.reason = \"Internal error\"\n\t\tconfig.MetricsClient.IncrWithTags(\"acl.unknown_error\", tags, 1)\n\t}\n\n\treturn decision\n}\n", "// +build !nounit\n\npackage smokescreen\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/DataDog/datadog-go/statsd\"\n\t\"github.com/sirupsen/logrus\"\n\tlogrustest \"github.com/sirupsen/logrus/hooks/test\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"github.com/stripe/smokescreen/pkg/smokescreen/conntrack\"\n)\n\nvar allowRanges = []string{\n\t\"8.8.9.0/24\",\n\t\"10.0.1.0/24\",\n\t\"172.16.1.0/24\",\n\t\"192.168.1.0/24\",\n\t\"127.0.1.0/24\",\n}\nvar allowAddresses = []string{\n\t\"10.0.0.1:321\",\n}\nvar denyRanges = []string{\n\t\"1.1.1.1/32\",\n}\nvar denyAddresses = []string{\n\t\"8.8.8.8:321\",\n}\n\ntype testCase struct {\n\tip       string\n\tport     int\n\texpected ipType\n}\n\nfunc TestClassifyAddr(t *testing.T) {\n\ta := assert.New(t)\n\n\tconf := NewConfig()\n\ta.NoError(conf.SetDenyRanges(denyRanges))\n\ta.NoError(conf.SetDenyAddresses(denyAddresses))\n\ta.NoError(conf.SetAllowRanges(allowRanges))\n\ta.NoError(conf.SetAllowAddresses(allowAddresses))\n\tconf.ConnectTimeout = 10 * time.Second\n\tconf.ExitTimeout = 10 * time.Second\n\tconf.AdditionalErrorMessageOnDeny = \"Proxy denied\"\n\n\ttestIPs := []testCase{\n\t\ttestCase{\"8.8.8.8\", 1, ipAllowDefault},\n\t\ttestCase{\"8.8.9.8\", 1, ipAllowUserConfigured},\n\n\t\t// Specific blocked networks\n\t\ttestCase{\"10.0.0.1\", 1, ipDenyPrivateRange},\n\t\ttestCase{\"10.0.0.1\", 321, ipAllowUserConfigured},\n\t\ttestCase{\"10.0.1.1\", 1, ipAllowUserConfigured},\n\t\ttestCase{\"172.16.0.1\", 1, ipDenyPrivateRange},\n\t\ttestCase{\"172.16.1.1\", 1, ipAllowUserConfigured},\n\t\ttestCase{\"192.168.0.1\", 1, ipDenyPrivateRange},\n\t\ttestCase{\"192.168.1.1\", 1, ipAllowUserConfigured},\n\t\ttestCase{\"8.8.8.8\", 321, ipDenyUserConfigured},\n\t\ttestCase{\"1.1.1.1\", 1, ipDenyUserConfigured},\n\n\t\t// localhost\n\t\ttestCase{\"127.0.0.1\", 1, ipDenyNotGlobalUnicast},\n\t\ttestCase{\"127.255.255.255\", 1, ipDenyNotGlobalUnicast},\n\t\ttestCase{\"::1\", 1, ipDenyNotGlobalUnicast},\n\t\ttestCase{\"127.0.1.1\", 1, ipAllowUserConfigured},\n\n\t\t// ec2 metadata endpoint\n\t\ttestCase{\"169.254.169.254\", 1, ipDenyNotGlobalUnicast},\n\n\t\t// Broadcast addresses\n\t\ttestCase{\"255.255.255.255\", 1, ipDenyNotGlobalUnicast},\n\t\ttestCase{\"ff02:0:0:0:0:0:0:2\", 1, ipDenyNotGlobalUnicast},\n\t}\n\n\tfor _, test := range testIPs {\n\t\tlocalIP := net.ParseIP(test.ip)\n\t\tif localIP == nil {\n\t\t\tt.Errorf(\"Could not parse IP from string: %s\", test.ip)\n\t\t\tcontinue\n\t\t}\n\t\tlocalAddr := net.TCPAddr{\n\t\t\tIP:   localIP,\n\t\t\tPort: test.port,\n\t\t}\n\n\t\tgot := classifyAddr(conf, &localAddr)\n\t\tif got != test.expected {\n\t\t\tt.Errorf(\"Misclassified IP (%s): should be %s, but is instead %s.\", localIP, test.expected, got)\n\t\t}\n\t}\n}\n\nfunc TestUnsafeAllowPrivateRanges (t *testing.T) {\n\ta := assert.New(t)\n\n\tconf := NewConfig()\n\ta.NoError(conf.SetDenyRanges([]string {\"192.168.0.0/24\", \"10.0.0.0/8\"}))\n\tconf.ConnectTimeout = 10 * time.Second\n\tconf.ExitTimeout = 10 * time.Second\n\tconf.AdditionalErrorMessageOnDeny = \"Proxy denied\"\n\n\tconf.UnsafeAllowPrivateRanges = true\n\n\ttestIPs := []testCase{\n\t\ttestCase{\"8.8.8.8\", 1, ipAllowDefault},\n\n\t\t// Specific blocked networks\n\t\ttestCase{\"10.0.0.1\", 1, ipDenyUserConfigured},\n\t\ttestCase{\"10.0.0.1\", 321, ipDenyUserConfigured},\n\t\ttestCase{\"10.0.1.1\", 1, ipDenyUserConfigured},\n\t\ttestCase{\"172.16.0.1\", 1, ipAllowDefault},\n\t\ttestCase{\"172.16.1.1\", 1, ipAllowDefault},\n\t\ttestCase{\"192.168.0.1\", 1, ipDenyUserConfigured},\n\t\ttestCase{\"192.168.1.1\", 1, ipAllowDefault},\n\n\t\t// localhost\n\t\ttestCase{\"127.0.0.1\", 1, ipDenyNotGlobalUnicast},\n\t\ttestCase{\"127.255.255.255\", 1, ipDenyNotGlobalUnicast},\n\t\ttestCase{\"::1\", 1, ipDenyNotGlobalUnicast},\n\n\t\t// ec2 metadata endpoint\n\t\ttestCase{\"169.254.169.254\", 1, ipDenyNotGlobalUnicast},\n\n\t\t// Broadcast addresses\n\t\ttestCase{\"255.255.255.255\", 1, ipDenyNotGlobalUnicast},\n\t\ttestCase{\"ff02:0:0:0:0:0:0:2\", 1, ipDenyNotGlobalUnicast},\n\t}\n\n\tfor _, test := range testIPs {\n\t\tlocalIP := net.ParseIP(test.ip)\n\t\tif localIP == nil {\n\t\t\tt.Errorf(\"Could not parse IP from string: %s\", test.ip)\n\t\t\tcontinue\n\t\t}\n\t\tlocalAddr := net.TCPAddr{\n\t\t\tIP:   localIP,\n\t\t\tPort: test.port,\n\t\t}\n\n\t\tgot := classifyAddr(conf, &localAddr)\n\t\tif got != test.expected {\n\t\t\tt.Errorf(\"Misclassified IP (%s): should be %s, but is instead %s.\", localIP, test.expected, got)\n\t\t}\n\t}\n\n\n}\n\n// TestClearsErrors tests that we are correctly preserving/removing the X-Smokescreen-Error header.\n// This header is used to provide more granular errors to proxy clients, and signals that\n// there was an issue connecting to the proxy target.\nfunc TestClearsErrorHeader(t *testing.T) {\n\tr := require.New(t)\n\n\t// For HTTP requests, Smokescreen should ensure successful requests do not include\n\t// X-Smokescreen-Error, even if they are set by the upstream host.\n\tt.Run(\"Clears error header set by upstream\", func(t *testing.T) {\n\t\tlog.SetFlags(log.LstdFlags | log.Lshortfile)\n\n\t\tcfg, err := testConfig(\"test-trusted-srv\")\n\t\tr.NoError(err)\n\n\t\tproxySrv := proxyServer(cfg)\n\t\tr.NoError(err)\n\t\tdefer proxySrv.Close()\n\n\t\t// Create a http.Client that uses our proxy\n\t\tclient, err := proxyClient(proxySrv.URL)\n\t\tr.NoError(err)\n\n\t\t// Talk \"through\" the proxy to our malicious upstream that sets the\n\t\t// error header.\n\t\tresp, err := client.Get(\"http://httpbin.org/response-headers?X-Smokescreen-Error=foobar&X-Smokescreen-Test=yes\")\n\t\tr.NoError(err)\n\n\t\t// Should succeed\n\t\tif resp.StatusCode != 200 {\n\t\t\tt.Errorf(\"response had bad status: expected 200, got %d\", resp.StatusCode)\n\t\t}\n\n\t\t// Verify the error header is not set.\n\t\tif h := resp.Header.Get(errorHeader); h != \"\" {\n\t\t\tt.Errorf(\"proxy did not strip %q header: %q\", errorHeader, h)\n\t\t}\n\n\t\t// Verify we did get the other header, to confirm we're talking to the right thing\n\t\tif h := resp.Header.Get(\"X-Smokescreen-Test\"); h != \"yes\" {\n\t\t\tt.Errorf(\"did not get expected header X-Smokescreen-Test: expected \\\"yes\\\", got %q\", h)\n\t\t}\n\t})\n\n\t// Test that the the error header is preserved when a connection is allowed by the ACL,\n\t// but the connection fails to be established.\n\tt.Run(\"Doesn't clear errors for allowed connections\", func(t *testing.T) {\n\t\tcfg, err := testConfig(\"test-local-srv\")\n\t\tr.NoError(err)\n\n\t\t// Immediately time out to simulate net.Dial timeouts\n\t\tcfg.ConnectTimeout = -1\n\n\t\tproxySrv := proxyServer(cfg)\n\t\tr.NoError(err)\n\t\tdefer proxySrv.Close()\n\n\t\t// Create a http.Client that uses our proxy\n\t\tclient, err := proxyClient(proxySrv.URL)\n\t\tr.NoError(err)\n\n\t\tresp, err := client.Get(\"http://127.0.0.1\")\n\t\tr.NoError(err)\n\n\t\t// Verify the error header is still set\n\t\th := resp.Header.Get(errorHeader)\n\t\tif h == \"\" {\n\t\t\tt.Errorf(\"proxy stripped %q header: %q\", errorHeader, h)\n\t\t}\n\t})\n}\n\nfunc TestConsistentHostHeader(t *testing.T) {\n\tr := require.New(t)\n\ta := assert.New(t)\n\n\thostCh := make(chan string)\n\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"OK\"))\n\t\thostCh <- r.Host\n\t}))\n\tdefer ts.Close()\n\n\t// Custom proxy config for the \"remote\" httptest.NewServer\n\tconf := NewConfig()\n\tconf.ConnTracker = conntrack.NewTracker(conf.IdleTimeout, &statsd.NoOpClient{}, conf.Log, atomic.Value{})\n\terr := conf.SetAllowAddresses([]string{\"127.0.0.1\"})\n\tr.NoError(err)\n\n\tproxy := BuildProxy(conf)\n\tproxySrv := httptest.NewServer(proxy)\n\n\tclient, err := proxyClient(proxySrv.URL)\n\tr.NoError(err)\n\n\treq, err := http.NewRequest(\"GET\", ts.URL, nil)\n\tr.NoError(err)\n\n\texpectedHostHeader := req.Host\n\tgo client.Do(req)\n\n\tselect {\n\tcase receivedHostHeader := <-hostCh:\n\t\ta.Equal(expectedHostHeader, receivedHostHeader)\n\tcase <-time.After(3 * time.Second):\n\t\tt.Fatal(\"timed out waiting for client request\")\n\t}\n}\n\nfunc TestClearsTraceIDHeader(t *testing.T) {\n\tr := require.New(t)\n\ta := assert.New(t)\n\n\theaderCh := make(chan string)\n\trespCh := make(chan bool)\n\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"OK\"))\n\t\theaderCh <- r.Header.Get(\"X-Smokescreen-Trace-ID\")\n\t}))\n\tdefer ts.Close()\n\n\t// Custom proxy config for the \"remote\" httptest.NewServer\n\tvar logHook logrustest.Hook\n\tconf := NewConfig()\n\tconf.Log.AddHook(&logHook)\n\tconf.ConnTracker = conntrack.NewTracker(conf.IdleTimeout, &statsd.NoOpClient{}, conf.Log, atomic.Value{})\n\terr := conf.SetAllowAddresses([]string{\"127.0.0.1\"})\n\tr.NoError(err)\n\n\tproxy := BuildProxy(conf)\n\tproxySrv := httptest.NewServer(proxy)\n\n\tclient, err := proxyClient(proxySrv.URL)\n\tr.NoError(err)\n\n\treq, err := http.NewRequest(\"GET\", ts.URL, nil)\n\tr.NoError(err)\n\treq.Header.Set(\"X-Smokescreen-Trace-ID\", \"6c4aa514e3da13ef\")\n\n\tgo func() {\n\t\tclient.Do(req)\n\t\trespCh <- true\n\t}()\n\n\tselect {\n\tcase receivedTraceIDCh := <-headerCh:\n\t\ta.Empty(receivedTraceIDCh)\n\tcase <-time.After(3 * time.Second):\n\t\tt.Fatal(\"timed out waiting for client request\")\n\t}\n\n\tselect {\n\tcase <-respCh:\n\t\tentry := findCanonicalProxyDecision(logHook.AllEntries())\n\t\tr.NotNil(entry)\n\t\ta.NotEmpty(entry.Data[\"trace_id\"])\n\tcase <-time.After(3 * time.Second):\n\t\tt.Fatal(\"timed out waiting for server response\")\n\t}\n\n}\n\nfunc TestShuttingDownValue(t *testing.T) {\n\ta := assert.New(t)\n\n\tconf := NewConfig()\n\tconf.Port = 39381\n\n\tquit := make(chan interface{})\n\tgo StartWithConfig(conf, quit)\n\n\t// These sleeps are not ideal, but there is a race with checking the\n\t// ShuttingDown value from these tests. The server has to bootstrap\n\t// itself with an initial value before it returns false, and has to\n\t// set the value to true after we send on the quit channel.\n\ttime.Sleep(500 * time.Millisecond)\n\ta.Equal(false, conf.ShuttingDown.Load())\n\n\tquit <- true\n\n\ttime.Sleep(500 * time.Millisecond)\n\ta.Equal(true, conf.ShuttingDown.Load())\n\n}\n\nfunc TestHealthcheck(t *testing.T) {\n\tr := require.New(t)\n\ta := assert.New(t)\n\n\thealthcheckCh := make(chan string)\n\n\ttestHealthcheck := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"OK\"))\n\t\thealthcheckCh <- \"OK\"\n\t})\n\n\tconf := NewConfig()\n\n\t// We set this here so that we can deterministically test the Healthcheck\n\t// handler. Otherwise we would have to call StartWithConfig() in a goroutine,\n\t// which creates a race between the test and the listener accepting\n\t// connections.\n\thandler := HealthcheckMiddleware{\n\t\tProxy:       BuildProxy(conf),\n\t\tHealthcheck: testHealthcheck,\n\t}\n\n\tserver := httptest.NewServer(handler)\n\n\terrChan := make(chan error, 1)\n\tgo func() {\n\t\tselect {\n\t\tcase healthy := <-healthcheckCh:\n\t\t\tif healthy != \"OK\" {\n\t\t\t\terrChan <- fmt.Errorf(\"healthcheck not OK: %s\", healthy)\n\t\t\t}\n\t\tcase <-time.After(5 * time.Second):\n\t\t\terrChan <- errors.New(\"timed out waiting for client request\")\n\t\t}\n\t\tclose(errChan)\n\t}()\n\n\tresp, err := http.Get(fmt.Sprintf(\"%s/healthcheck\", server.URL))\n\tr.NoError(err)\n\ta.Equal(http.StatusOK, resp.StatusCode)\n\n\tr.NoError(<-errChan)\n}\n\nvar invalidHostCases = []struct {\n\tscheme    string\n\texpectErr bool\n\tproxyType string\n}{\n\t{\"http\", false, \"http\"},\n\t{\"https\", true, \"connect\"},\n}\n\nfunc TestInvalidHost(t *testing.T) {\n\tfor _, testCase := range invalidHostCases {\n\t\tt.Run(testCase.scheme, func(t *testing.T) {\n\t\t\ta := assert.New(t)\n\t\t\tr := require.New(t)\n\n\t\t\tcfg, err := testConfig(\"test-trusted-srv\")\n\t\t\trequire.NoError(t, err)\n\t\t\tlogHook := proxyLogHook(cfg)\n\n\t\t\tproxySrv := proxyServer(cfg)\n\t\t\tdefer proxySrv.Close()\n\n\t\t\t// Create a http.Client that uses our proxy\n\t\t\tclient, err := proxyClient(proxySrv.URL)\n\t\t\tr.NoError(err)\n\n\t\t\tresp, err := client.Get(fmt.Sprintf(\"%s://notarealhost.test\", testCase.scheme))\n\t\t\tif testCase.expectErr {\n\t\t\t\tr.Contains(err.Error(), \"Bad gateway\")\n\t\t\t} else {\n\t\t\t\tr.NoError(err)\n\t\t\t\tr.Equal(http.StatusBadGateway, resp.StatusCode)\n\t\t\t}\n\n\t\t\tentry := findCanonicalProxyDecision(logHook.AllEntries())\n\t\t\tr.NotNil(entry)\n\n\t\t\tif a.Contains(entry.Data, \"allow\") {\n\t\t\t\ta.Equal(true, entry.Data[\"allow\"])\n\t\t\t}\n\t\t\tif a.Contains(entry.Data, \"error\") {\n\t\t\t\ta.Contains(entry.Data[\"error\"], \"no such host\")\n\t\t\t}\n\t\t\tif a.Contains(entry.Data, \"proxy_type\") {\n\t\t\t\ta.Contains(entry.Data[\"proxy_type\"], testCase.proxyType)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestErrorHeader(t *testing.T) {\n\ta := assert.New(t)\n\tr := require.New(t)\n\n\tcfg, err := testConfig(\"test-trusted-srv\")\n\trequire.NoError(t, err)\n\tlogHook := proxyLogHook(cfg)\n\n\tproxySrv := proxyServer(cfg)\n\tdefer proxySrv.Close()\n\n\t// Create a http.Client that uses our proxy\n\tclient, err := proxyClient(proxySrv.URL)\n\tr.NoError(err)\n\n\tresp, err := client.Get(\"http://example.com\")\n\tr.NoError(err)\n\tr.Equal(http.StatusProxyAuthRequired, resp.StatusCode)\n\tr.NotEmpty(resp.Header.Get(\"X-Smokescreen-Error\"))\n\n\tentry := findCanonicalProxyDecision(logHook.AllEntries())\n\tr.NotNil(entry)\n\n\tif a.Contains(entry.Data, \"allow\") {\n\t\ta.Equal(false, entry.Data[\"allow\"])\n\t}\n}\n\n// TestProxyProtocols ensures that both traditional HTTP and CONNECT proxy\n// requests Emit the correct CANONICAL-PROXY-DECISION log\nfunc TestProxyProtocols(t *testing.T) {\n\ta := assert.New(t)\n\tr := require.New(t)\n\tt.Run(\"HTTP proxy\", func(t *testing.T) {\n\t\tcfg, err := testConfig(\"test-local-srv\")\n\t\tr.NoError(err)\n\t\terr = cfg.SetAllowAddresses([]string{\"127.0.0.1\"})\n\t\tr.NoError(err)\n\n\t\tclientCh := make(chan bool)\n\t\th := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.Write([]byte(\"OK\"))\n\t\t})\n\n\t\tl, err := net.Listen(\"tcp\", \"localhost:0\")\n\t\tr.NoError(err)\n\t\tcfg.Listener = l\n\n\t\tlogHook := proxyLogHook(cfg)\n\t\tproxy := proxyServer(cfg)\n\t\tremote := httptest.NewServer(h)\n\t\tclient, err := proxyClient(proxy.URL)\n\t\tr.NoError(err)\n\n\t\treq, err := http.NewRequest(\"GET\", remote.URL, nil)\n\t\tr.NoError(err)\n\n\t\tgo func() {\n\t\t\tclient.Do(req)\n\t\t\tclientCh <- true\n\t\t}()\n\n\t\t<-clientCh\n\t\tentry := findCanonicalProxyDecision(logHook.AllEntries())\n\t\tr.NotNil(entry)\n\n\t\tr.Contains(entry.Data, \"proxy_type\")\n\t\tr.Equal(\"http\", entry.Data[\"proxy_type\"])\n\t})\n\n\tt.Run(\"CONNECT proxy\", func(t *testing.T) {\n\t\tcfg, err := testConfig(\"test-local-srv\")\n\t\tr.NoError(err)\n\t\terr = cfg.SetAllowAddresses([]string{\"127.0.0.1\"})\n\t\tr.NoError(err)\n\n\t\tclientCh := make(chan bool)\n\t\tserverCh := make(chan bool)\n\t\th := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tserverCh <- true\n\t\t\t<-serverCh\n\t\t\tw.Write([]byte(\"OK\"))\n\t\t})\n\n\t\tlogHook := proxyLogHook(cfg)\n\t\tl, err := net.Listen(\"tcp\", \"localhost:0\")\n\t\tr.NoError(err)\n\t\tcfg.Listener = l\n\n\t\tproxy := proxyServer(cfg)\n\t\tremote := httptest.NewTLSServer(h)\n\t\tclient, err := proxyClient(proxy.URL)\n\t\tr.NoError(err)\n\n\t\treq, err := http.NewRequest(\"GET\", remote.URL, nil)\n\t\tr.NoError(err)\n\n\t\tgo func() {\n\t\t\tclient.Do(req)\n\t\t\tclientCh <- true\n\t\t}()\n\n\t\t<-serverCh\n\t\tcount := 0\n\t\tcfg.ConnTracker.Range(func(k, v interface{}) bool {\n\t\t\tcount++\n\t\t\treturn true\n\t\t})\n\t\ta.Equal(1, count, \"connTracker should contain one tracked connection\")\n\n\t\tserverCh <- true\n\t\t<-clientCh\n\n\t\tentry := findCanonicalProxyDecision(logHook.AllEntries())\n\t\tr.NotNil(entry)\n\t\tr.Contains(entry.Data, \"proxy_type\")\n\t\tr.Equal(\"connect\", entry.Data[\"proxy_type\"])\n\t})\n}\n\nfunc TestProxyTimeouts(t *testing.T) {\n\tr := require.New(t)\n\n\th := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\ttime.Sleep(time.Second)\n\t\tw.Write([]byte(\"OK\"))\n\t})\n\n\tt.Run(\"HTTP proxy timeouts\", func(t *testing.T) {\n\t\tcfg, err := testConfig(\"test-local-srv\")\n\t\tr.NoError(err)\n\t\terr = cfg.SetAllowAddresses([]string{\"127.0.0.1\"})\n\t\tr.NoError(err)\n\n\t\tlogHook := proxyLogHook(cfg)\n\t\tcfg.IdleTimeout = 100 * time.Millisecond\n\n\t\tl, err := net.Listen(\"tcp\", \"localhost:0\")\n\t\tr.NoError(err)\n\t\tcfg.Listener = l\n\n\t\tproxy := proxyServer(cfg)\n\t\tremote := httptest.NewServer(h)\n\t\tclient, err := proxyClient(proxy.URL)\n\t\tr.NoError(err)\n\n\t\treq, err := http.NewRequest(\"GET\", remote.URL, nil)\n\t\tr.NoError(err)\n\n\t\tresp, _ := client.Do(req)\n\t\tr.Equal(http.StatusGatewayTimeout, resp.StatusCode)\n\t\tr.NotEqual(\"\", resp.Header.Get(errorHeader))\n\n\t\tentry := findCanonicalProxyDecision(logHook.AllEntries())\n\t\tr.NotNil(entry)\n\n\t\tr.Equal(\"http\", entry.Data[\"proxy_type\"])\n\t\tr.Contains(entry.Data[\"error\"], \"i/o timeout\")\n\t})\n\n\t// This isn't quite correct, as there is some nondeterministic behavior with the way\n\t// CONNECT timeout errors are surfaced back to Smokescreen from Goproxy. We check\n\t// for an EOF returned from HTTP client to indicate a connection interruption\n\t// which in our case represents the timeout.\n\t//\n\t// To correctly hook into this, we'd need to pass a logger from Smokescreen to Goproxy\n\t// which we have hooks into. This would be able to verify the timeout as errors from\n\t// each end of the connection pair are logged by Goproxy.\n\tt.Run(\"CONNECT proxy timeouts\", func(t *testing.T) {\n\t\tcfg, err := testConfig(\"test-local-srv\")\n\t\tr.NoError(err)\n\t\terr = cfg.SetAllowAddresses([]string{\"127.0.0.1\"})\n\t\tr.NoError(err)\n\n\t\tlogHook := proxyLogHook(cfg)\n\t\tcfg.IdleTimeout = 100 * time.Millisecond\n\n\t\tl, err := net.Listen(\"tcp\", \"localhost:0\")\n\t\tr.NoError(err)\n\t\tcfg.Listener = l\n\n\t\tproxy := proxyServer(cfg)\n\t\tremote := httptest.NewTLSServer(h)\n\t\tclient, err := proxyClient(proxy.URL)\n\t\tr.NoError(err)\n\n\t\treq, err := http.NewRequest(\"GET\", remote.URL, nil)\n\t\tr.NoError(err)\n\n\t\tresp, err := client.Do(req)\n\t\tr.Nil(resp)\n\t\tr.Error(err)\n\t\tr.Contains(err.Error(), \"EOF\")\n\n\t\tcfg.ConnTracker.Wg.Wait()\n\n\t\tentry := findCanonicalProxyClose(logHook.AllEntries())\n\t\tr.NotNil(entry)\n\t})\n\n\tt.Run(\"CONNECT proxy dial timeouts\", func(t *testing.T) {\n\t\tcfg, err := testConfig(\"test-local-srv\")\n\t\tr.NoError(err)\n\t\terr = cfg.SetAllowAddresses([]string{\"127.0.0.1\"})\n\t\tr.NoError(err)\n\n\t\tcfg.ConnectTimeout = -1\n\n\t\tl, err := net.Listen(\"tcp\", \"localhost:0\")\n\t\tr.NoError(err)\n\t\tcfg.Listener = l\n\n\t\tproxy := proxyServer(cfg)\n\t\tremote := httptest.NewTLSServer(h)\n\t\tclient, err := proxyClient(proxy.URL)\n\t\tr.NoError(err)\n\n\t\treq, err := http.NewRequest(\"GET\", remote.URL, nil)\n\t\tr.NoError(err)\n\n\t\t// Go swallows the response as the CONNECT tunnel was never established\n\t\tresp, err := client.Do(req)\n\t\tr.Nil(resp)\n\t\tr.Error(err)\n\t\tr.Contains(err.Error(), \"Gateway timeout\")\n\t})\n\n\tt.Run(\"HTTP proxy dial timeouts\", func(t *testing.T) {\n\t\tcfg, err := testConfig(\"test-local-srv\")\n\t\tr.NoError(err)\n\t\terr = cfg.SetAllowAddresses([]string{\"127.0.0.1\"})\n\t\tr.NoError(err)\n\n\t\tcfg.ConnectTimeout = -1\n\n\t\tl, err := net.Listen(\"tcp\", \"localhost:0\")\n\t\tr.NoError(err)\n\t\tcfg.Listener = l\n\n\t\tproxy := proxyServer(cfg)\n\t\tremote := httptest.NewServer(h)\n\t\tclient, err := proxyClient(proxy.URL)\n\t\tr.NoError(err)\n\n\t\treq, err := http.NewRequest(\"GET\", remote.URL, nil)\n\t\tr.NoError(err)\n\n\t\tresp, _ := client.Do(req)\n\t\tr.Equal(http.StatusGatewayTimeout, resp.StatusCode)\n\t\tr.NotEqual(\"\", resp.Header.Get(errorHeader))\n\t})\n}\n\n// TestProxyHalfClosed tests that the proxy and proxy client correctly\n// closes all connections if the proxy target attempts to half-close\n// the TCP connection.\nfunc TestProxyHalfClosed(t *testing.T) {\n\tr := require.New(t)\n\n\th := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\thj, ok := w.(http.Hijacker)\n\t\tif !ok {\n\t\t\tt.Error(\"couldn't hijack conn\")\n\t\t}\n\t\tconn, bufrw, err := hj.Hijack()\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\n\t\ttlsConn, ok := conn.(*tls.Conn)\n\t\tif !ok {\n\t\t\tt.Error(\"conn did not unwrap to tls.Conn\")\n\t\t}\n\n\t\t// Send a response\n\t\tif _, err := io.WriteString(bufrw, \"HTTP/1.1 200 TCP is great!\\r\\n\\r\\n\"); err != nil {\n\t\t\tt.Errorf(\"Error responding to client: %s\", err)\n\t\t}\n\t\tbufrw.Flush()\n\t\ttlsConn.CloseWrite()\n\t})\n\n\tcfg, err := testConfig(\"test-local-srv\")\n\tr.NoError(err)\n\terr = cfg.SetAllowAddresses([]string{\"127.0.0.1\"})\n\tr.NoError(err)\n\n\tlogHook := proxyLogHook(cfg)\n\n\tl, err := net.Listen(\"tcp\", \"localhost:0\")\n\tr.NoError(err)\n\tcfg.Listener = l\n\n\tproxy := proxyServer(cfg)\n\tremote := httptest.NewTLSServer(h)\n\tclient, err := proxyClient(proxy.URL)\n\tr.NoError(err)\n\n\treq, err := http.NewRequest(\"GET\", remote.URL, nil)\n\tr.NoError(err)\n\n\tresp, err := client.Do(req)\n\tr.NoError(err)\n\tresp.Body.Close()\n\tr.Equal(http.StatusOK, resp.StatusCode)\n\n\tcfg.ConnTracker.Wg.Wait()\n\n\tentry := findCanonicalProxyClose(logHook.AllEntries())\n\tr.NotNil(entry)\n}\n\nfunc TestCustomDialTimeout(t *testing.T) {\n\tr := require.New(t)\n\n\th := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\ttime.Sleep(time.Second)\n\t\tw.Write([]byte(\"OK\\n\"))\n\t})\n\n\tt.Run(\"CONNECT proxy custom dial timeouts\", func(t *testing.T) {\n\t\tvar custom = false\n\t\tcfg, err := testConfig(\"test-local-srv\")\n\t\tr.NoError(err)\n\t\terr = cfg.SetAllowAddresses([]string{\"127.0.0.1\"})\n\t\tr.NoError(err)\n\n\t\tcfg.ConnectTimeout = -1\n\n\t\tl, err := net.Listen(\"tcp\", \"localhost:0\")\n\t\tr.NoError(err)\n\t\tcfg.Listener = l\n\t\tcfg.ProxyDialTimeout = func(ctx context.Context, network, address string, timeout time.Duration) (net.Conn, error) {\n\t\t\tcustom = true\n\t\t\treturn net.DialTimeout(network, address, timeout)\n\t\t}\n\n\t\tproxy := proxyServer(cfg)\n\t\tremote := httptest.NewTLSServer(h)\n\t\tclient, err := proxyClient(proxy.URL)\n\t\tr.NoError(err)\n\n\t\treq, err := http.NewRequest(\"GET\", remote.URL, nil)\n\t\tr.NoError(err)\n\n\t\t// Go swallows the response as the CONNECT tunnel was never established\n\t\tresp, err := client.Do(req)\n\t\tr.Nil(resp)\n\t\tr.Error(err)\n\t\tr.Contains(err.Error(), \"Gateway timeout\")\n\t\tr.Equal(custom, true)\n\t})\n\n\tt.Run(\"HTTP proxy custom dial timeouts\", func(t *testing.T) {\n\t\tvar custom = false\n\t\tcfg, err := testConfig(\"test-local-srv\")\n\t\tr.NoError(err)\n\t\terr = cfg.SetAllowAddresses([]string{\"127.0.0.1\"})\n\t\tr.NoError(err)\n\n\t\tcfg.ConnectTimeout = -1\n\n\t\tl, err := net.Listen(\"tcp\", \"localhost:0\")\n\t\tr.NoError(err)\n\t\tcfg.Listener = l\n\n\t\tcfg.ProxyDialTimeout = func(ctx context.Context, network, address string, timeout time.Duration) (net.Conn, error) {\n\t\t\tcustom = true\n\t\t\treturn net.DialTimeout(network, address, timeout)\n\t\t}\n\n\t\tproxy := proxyServer(cfg)\n\t\tremote := httptest.NewServer(h)\n\t\tclient, err := proxyClient(proxy.URL)\n\t\tr.NoError(err)\n\n\t\treq, err := http.NewRequest(\"GET\", remote.URL, nil)\n\t\tr.NoError(err)\n\n\t\tresp, _ := client.Do(req)\n\t\tr.Equal(http.StatusGatewayTimeout, resp.StatusCode)\n\t\tr.NotEqual(\"\", resp.Header.Get(errorHeader))\n\n\t\tr.Equal(custom, true)\n\t})\n}\n\n// Test that Smokescreen calls the custom reject response handler (if defined in the Config struct)\n// after every denied request\nfunc TestRejectResponseHandler(t *testing.T) {\n\tr := require.New(t)\n\ttestHeader := \"TestRejectResponseHandlerHeader\"\n\tt.Run(\"Testing custom reject response handler\", func(t *testing.T) {\n\t\tcfg, err := testConfig(\"test-local-srv\")\n\n\t\t// set a custom RejectResponseHandler that will set a header on every reject response\n\t\tcfg.RejectResponseHandler = func(resp *http.Response) {\n\t\t\tresp.Header.Set(testHeader, \"This header is added by the RejectResponseHandler\")\n\t\t}\n\t\tr.NoError(err)\n\n\t\tproxySrv := proxyServer(cfg)\n\t\tr.NoError(err)\n\t\tdefer proxySrv.Close()\n\n\t\t// Create a http.Client that uses our proxy\n\t\tclient, err := proxyClient(proxySrv.URL)\n\t\tr.NoError(err)\n\n\t\t// Send a request that should be blocked\n\t\tresp, err := client.Get(\"http://127.0.0.1\")\n\t\tr.NoError(err)\n\n\t\t// The RejectResponseHandler should set our custom header\n\t\th := resp.Header.Get(testHeader)\n\t\tif h == \"\" {\n\t\t\tt.Errorf(\"Expecting header %s to be set by RejectResponseHandler\", testHeader)\n\t\t}\n\t\t// Send a request that should be allowed\n\t\tresp, err = client.Get(\"http://example.com\")\n\t\tr.NoError(err)\n\n\t\t// The header set by our custom reject response handler should not be set\n\t\th = resp.Header.Get(testHeader)\n\t\tif h != \"\" {\n\t\t\tt.Errorf(\"Expecting header %s to not be set by RejectResponseHandler\", testHeader)\n\t\t}\n\t})\n}\n\nfunc findCanonicalProxyDecision(logs []*logrus.Entry) *logrus.Entry {\n\tfor _, entry := range logs {\n\t\tif entry.Message == CanonicalProxyDecision {\n\t\t\treturn entry\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc findCanonicalProxyClose(logs []*logrus.Entry) *logrus.Entry {\n\tfor _, entry := range logs {\n\t\tif entry.Message == conntrack.CanonicalProxyConnClose {\n\t\t\treturn entry\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc testConfig(role string) (*Config, error) {\n\tconf := NewConfig()\n\n\tif err := conf.SetAllowRanges(allowRanges); err != nil {\n\t\treturn nil, err\n\t}\n\tconf.ConnectTimeout = 10 * time.Second\n\tconf.ExitTimeout = 10 * time.Second\n\tconf.AdditionalErrorMessageOnDeny = \"Proxy denied\"\n\tconf.Resolver = &net.Resolver{}\n\tconf.SetupEgressAcl(\"testdata/acl.yaml\")\n\tconf.RoleFromRequest = func(req *http.Request) (string, error) {\n\t\treturn role, nil\n\t}\n\n\tmc := NewNoOpMetricsClient()\n\tconf.ConnTracker = conntrack.NewTracker(conf.IdleTimeout, mc.StatsdClient, conf.Log, atomic.Value{})\n\tconf.MetricsClient = mc\n\treturn conf, nil\n}\n\nfunc proxyLogHook(conf *Config) *logrustest.Hook {\n\tvar testHook logrustest.Hook\n\tconf.Log.AddHook(&testHook)\n\treturn &testHook\n}\n\nfunc proxyServer(conf *Config) *httptest.Server {\n\tproxy := BuildProxy(conf)\n\treturn httptest.NewServer(proxy)\n}\n\nfunc proxyClient(proxy string) (*http.Client, error) {\n\tproxyUrl, err := url.Parse(proxy)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tProxy:                 http.ProxyURL(proxyUrl),\n\t\t\tTLSHandshakeTimeout:   10 * time.Second,\n\t\t\tExpectContinueTimeout: 1 * time.Second,\n\t\t\tTLSClientConfig:       &tls.Config{InsecureSkipVerify: true},\n\t\t},\n\t}, nil\n}\n", "---\n    version: v1\n    services:\n      - name: test-trusted-srv\n        project: security\n        action: enforce\n        allowed_domains:\n          - notarealhost.test\n          - httpbin.org\n      - name: test-local-srv\n        project: security\n        action: open\n        allowed_domains:\n          - 127.0.0.1\n"], "fixing_code": ["package smokescreen\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"strings\"\n\t\"syscall\"\n\t\"time\"\n\n\tproxyproto \"github.com/armon/go-proxyproto\"\n\t\"github.com/rs/xid\"\n\t\"github.com/sirupsen/logrus\"\n\t\"github.com/stripe/goproxy\"\n\t\"github.com/stripe/smokescreen/internal/einhorn\"\n\tacl \"github.com/stripe/smokescreen/pkg/smokescreen/acl/v1\"\n\t\"github.com/stripe/smokescreen/pkg/smokescreen/conntrack\"\n)\n\nconst (\n\tipAllowDefault ipType = iota\n\tipAllowUserConfigured\n\tipDenyNotGlobalUnicast\n\tipDenyPrivateRange\n\tipDenyUserConfigured\n\n\tdenyMsgTmpl = \"Egress proxying is denied to host '%s': %s.\"\n\n\thttpProxy    = \"http\"\n\tconnectProxy = \"connect\"\n)\n\nconst (\n\tLogFieldID               = \"id\"\n\tLogFieldOutLocalAddr     = \"outbound_local_addr\"\n\tLogFieldOutRemoteAddr    = \"outbound_remote_addr\"\n\tLogFieldInRemoteAddr     = \"inbound_remote_addr\"\n\tLogFieldProxyType        = \"proxy_type\"\n\tLogFieldRequestedHost    = \"requested_host\"\n\tLogFieldStartTime        = \"start_time\"\n\tLogFieldTraceID          = \"trace_id\"\n\tLogFieldInRemoteX509CN   = \"inbound_remote_x509_cn\"\n\tLogFieldInRemoteX509OU   = \"inbound_remote_x509_ou\"\n\tLogFieldRole             = \"role\"\n\tLogFieldProject          = \"project\"\n\tLogFieldContentLength    = \"content_length\"\n\tLogFieldDecisionReason   = \"decision_reason\"\n\tLogFieldEnforceWouldDeny = \"enforce_would_deny\"\n\tLogFieldAllow            = \"allow\"\n\tLogFieldError            = \"error\"\n\tCanonicalProxyDecision   = \"CANONICAL-PROXY-DECISION\"\n\tLogFieldConnEstablishMS  = \"conn_establish_time_ms\"\n\tLogFieldDNSLookupTime    = \"dns_lookup_time_ms\"\n)\n\ntype ipType int\n\ntype aclDecision struct {\n\treason, role, project, outboundHost string\n\tresolvedAddr                        *net.TCPAddr\n\tallow                               bool\n\tenforceWouldDeny                    bool\n}\n\ntype smokescreenContext struct {\n\tcfg           *Config\n\tstart         time.Time\n\tdecision      *aclDecision\n\tproxyType     string\n\tlogger        *logrus.Entry\n\trequestedHost string\n\n\t// Time spent resolving the requested hostname\n\tlookupTime time.Duration\n}\n\n// ExitStatus is used to log Smokescreen's connection status at shutdown time\ntype ExitStatus int\n\nconst (\n\tClosed ExitStatus = iota\n\tIdle\n\tTimeout\n)\n\nfunc (e ExitStatus) String() string {\n\tswitch e {\n\tcase Closed:\n\t\treturn \"All connections closed\"\n\tcase Idle:\n\t\treturn \"All connections idle\"\n\tcase Timeout:\n\t\treturn \"Timed out waiting for connections to become idle\"\n\tdefault:\n\t\treturn \"Unknown exit status\"\n\t}\n}\n\ntype denyError struct {\n\terror\n}\n\nfunc (t ipType) IsAllowed() bool {\n\treturn t == ipAllowDefault || t == ipAllowUserConfigured\n}\n\nfunc (t ipType) String() string {\n\tswitch t {\n\tcase ipAllowDefault:\n\t\treturn \"Allow: Default\"\n\tcase ipAllowUserConfigured:\n\t\treturn \"Allow: User Configured\"\n\tcase ipDenyNotGlobalUnicast:\n\t\treturn \"Deny: Not Global Unicast\"\n\tcase ipDenyPrivateRange:\n\t\treturn \"Deny: Private Range\"\n\tcase ipDenyUserConfigured:\n\t\treturn \"Deny: User Configured\"\n\tdefault:\n\t\tpanic(fmt.Errorf(\"unknown ip type %d\", t))\n\t}\n}\n\nfunc (t ipType) statsdString() string {\n\tswitch t {\n\tcase ipAllowDefault:\n\t\treturn \"resolver.allow.default\"\n\tcase ipAllowUserConfigured:\n\t\treturn \"resolver.allow.user_configured\"\n\tcase ipDenyNotGlobalUnicast:\n\t\treturn \"resolver.deny.not_global_unicast\"\n\tcase ipDenyPrivateRange:\n\t\treturn \"resolver.deny.private_range\"\n\tcase ipDenyUserConfigured:\n\t\treturn \"resolver.deny.user_configured\"\n\tdefault:\n\t\tpanic(fmt.Errorf(\"unknown ip type %d\", t))\n\t}\n}\n\nconst errorHeader = \"X-Smokescreen-Error\"\nconst roleHeader = \"X-Smokescreen-Role\"\nconst traceHeader = \"X-Smokescreen-Trace-ID\"\n\nfunc addrIsInRuleRange(ranges []RuleRange, addr *net.TCPAddr) bool {\n\tfor _, rng := range ranges {\n\t\t// If the range specifies a port and the port doesn't match,\n\t\t// then this range doesn't match\n\t\tif rng.Port != 0 && addr.Port != rng.Port {\n\t\t\tcontinue\n\t\t}\n\n\t\tif rng.Net.Contains(addr.IP) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc classifyAddr(config *Config, addr *net.TCPAddr) ipType {\n\tif !addr.IP.IsGlobalUnicast() || addr.IP.IsLoopback() {\n\t\tif addrIsInRuleRange(config.AllowRanges, addr) {\n\t\t\treturn ipAllowUserConfigured\n\t\t} else {\n\t\t\treturn ipDenyNotGlobalUnicast\n\t\t}\n\t}\n\n\tif addrIsInRuleRange(config.AllowRanges, addr) {\n\t\treturn ipAllowUserConfigured\n\t} else if addrIsInRuleRange(config.DenyRanges, addr) {\n\t\treturn ipDenyUserConfigured\n\t} else if addrIsInRuleRange(PrivateRuleRanges, addr) && !config.UnsafeAllowPrivateRanges {\n\t\treturn ipDenyPrivateRange\n\t} else {\n\t\treturn ipAllowDefault\n\t}\n}\n\nfunc resolveTCPAddr(config *Config, network, addr string) (*net.TCPAddr, error) {\n\tif network != \"tcp\" {\n\t\treturn nil, fmt.Errorf(\"unknown network type %q\", network)\n\t}\n\thost, port, err := net.SplitHostPort(addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tctx := context.Background()\n\tresolvedPort, err := config.Resolver.LookupPort(ctx, network, port)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tips, err := config.Resolver.LookupIP(ctx, config.Network, host)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(ips) < 1 {\n\t\treturn nil, fmt.Errorf(\"no IPs resolved\")\n\t}\n\n\treturn &net.TCPAddr{\n\t\tIP:   ips[0],\n\t\tPort: resolvedPort,\n\t}, nil\n}\n\nfunc safeResolve(config *Config, network, addr string) (*net.TCPAddr, string, error) {\n\tconfig.MetricsClient.Incr(\"resolver.attempts_total\", 1)\n\tresolved, err := resolveTCPAddr(config, network, addr)\n\tif err != nil {\n\t\tconfig.MetricsClient.Incr(\"resolver.errors_total\", 1)\n\t\treturn nil, \"\", err\n\t}\n\n\tclassification := classifyAddr(config, resolved)\n\tconfig.MetricsClient.Incr(classification.statsdString(), 1)\n\n\tif classification.IsAllowed() {\n\t\treturn resolved, classification.String(), nil\n\t}\n\treturn nil, \"destination address was denied by rule, see error\", denyError{fmt.Errorf(\"The destination address (%s) was denied by rule '%s'\", resolved.IP, classification)}\n}\n\nfunc proxyContext(ctx context.Context) (*goproxy.ProxyCtx, bool) {\n\tpctx, ok := ctx.Value(goproxy.ProxyContextKey).(*goproxy.ProxyCtx)\n\treturn pctx, ok\n}\n\nfunc dialContext(ctx context.Context, network, addr string) (net.Conn, error) {\n\tpctx, ok := proxyContext(ctx)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"dialContext missing required *goproxy.ProxyCtx\")\n\t}\n\n\tsctx, ok := pctx.UserData.(*smokescreenContext)\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"dialContext missing required *smokescreenContext\")\n\t}\n\td := sctx.decision\n\n\t// If an address hasn't been resolved, does not match the original outboundHost,\n\t// or is not tcp we must re-resolve it before establishing the connection.\n\tif d.resolvedAddr == nil || d.outboundHost != addr || network != \"tcp\" {\n\t\tvar err error\n\t\td.resolvedAddr, d.reason, err = safeResolve(sctx.cfg, network, addr)\n\t\tif err != nil {\n\t\t\tif _, ok := err.(denyError); ok {\n\t\t\t\tsctx.cfg.Log.WithFields(\n\t\t\t\t\tlogrus.Fields{\n\t\t\t\t\t\t\"address\": addr,\n\t\t\t\t\t\t\"error\":   err,\n\t\t\t\t\t}).Error(\"unexpected illegal address in dialer\")\n\t\t\t}\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tvar conn net.Conn\n\tvar err error\n\n\tstart := time.Now()\n\tif sctx.cfg.ProxyDialTimeout == nil {\n\t\tconn, err = net.DialTimeout(network, d.resolvedAddr.String(), sctx.cfg.ConnectTimeout)\n\t} else {\n\t\tconn, err = sctx.cfg.ProxyDialTimeout(ctx, network, d.resolvedAddr.String(), sctx.cfg.ConnectTimeout)\n\t}\n\tconnTime := time.Since(start)\n\n\tfields := logrus.Fields{\n\t\tLogFieldConnEstablishMS: connTime.Milliseconds(),\n\t}\n\n\tif sctx.cfg.TimeConnect {\n\t\tdomainTag := fmt.Sprintf(\"domain:%s\", sctx.requestedHost)\n\t\tsctx.cfg.MetricsClient.TimingWithTags(\"cn.atpt.connect.time\", connTime, 1, []string{domainTag})\n\t}\n\n\tif err != nil {\n\t\tsctx.cfg.MetricsClient.IncrWithTags(\"cn.atpt.total\", []string{\"success:false\"}, 1)\n\t\treturn nil, err\n\t}\n\tsctx.cfg.MetricsClient.IncrWithTags(\"cn.atpt.total\", []string{\"success:true\"}, 1)\n\n\tif conn != nil {\n\t\tfields := logrus.Fields{}\n\n\t\tif addr := conn.LocalAddr(); addr != nil {\n\t\t\tfields[LogFieldOutLocalAddr] = addr.String()\n\t\t}\n\n\t\tif addr := conn.RemoteAddr(); addr != nil {\n\t\t\tfields[LogFieldOutRemoteAddr] = addr.String()\n\t\t}\n\n\t}\n\tsctx.logger = sctx.logger.WithFields(fields)\n\n\t// Only wrap CONNECT conns with an InstrumentedConn. Connections used for traditional HTTP proxy\n\t// requests are pooled and reused by net.Transport.\n\tif sctx.proxyType == connectProxy {\n\t\tic := sctx.cfg.ConnTracker.NewInstrumentedConnWithTimeout(conn, sctx.cfg.IdleTimeout, sctx.logger, d.role, d.outboundHost, sctx.proxyType)\n\t\tpctx.ConnErrorHandler = ic.Error\n\t\tconn = ic\n\t} else {\n\t\tconn = NewTimeoutConn(conn, sctx.cfg.IdleTimeout)\n\t}\n\n\treturn conn, nil\n}\n\n// HTTPErrorHandler allows returning a custom error response when smokescreen\n// fails to connect to the proxy target.\nfunc HTTPErrorHandler(w io.WriteCloser, pctx *goproxy.ProxyCtx, err error) {\n\tsctx := pctx.UserData.(*smokescreenContext)\n\tresp := rejectResponse(pctx, err)\n\n\tif err := resp.Write(w); err != nil {\n\t\tsctx.logger.Errorf(\"Failed to write HTTP error response: %s\", err)\n\t}\n\n\tif err := w.Close(); err != nil {\n\t\tsctx.logger.Errorf(\"Failed to close proxy client connection: %s\", err)\n\t}\n}\n\nfunc rejectResponse(pctx *goproxy.ProxyCtx, err error) *http.Response {\n\tsctx := pctx.UserData.(*smokescreenContext)\n\n\tvar msg, status string\n\tvar code int\n\n\tif e, ok := err.(net.Error); ok {\n\t\t// net.Dial timeout\n\t\tif e.Timeout() {\n\t\t\tstatus = \"Gateway timeout\"\n\t\t\tcode = http.StatusGatewayTimeout\n\t\t\tmsg = \"Timed out connecting to remote host: \" + e.Error()\n\t\t} else {\n\t\t\tstatus = \"Bad gateway\"\n\t\t\tcode = http.StatusBadGateway\n\t\t\tmsg = \"Failed to connect to remote host: \" + e.Error()\n\t\t}\n\t} else if e, ok := err.(denyError); ok {\n\t\tstatus = \"Request rejected by proxy\"\n\t\tcode = http.StatusProxyAuthRequired\n\t\tmsg = fmt.Sprintf(denyMsgTmpl, pctx.Req.Host, e.Error())\n\t} else {\n\t\tstatus = \"Internal server error\"\n\t\tcode = http.StatusInternalServerError\n\t\tmsg = \"An unexpected error occurred: \" + err.Error()\n\t\tsctx.logger.WithField(\"error\", err.Error()).Warn(\"rejectResponse called with unexpected error\")\n\t}\n\n\t// Do not double log deny errors, they are logged in a previous call to logProxy.\n\tif _, ok := err.(denyError); !ok {\n\t\tsctx.logger.Error(msg)\n\t}\n\n\tif sctx.cfg.AdditionalErrorMessageOnDeny != \"\" {\n\t\tmsg = fmt.Sprintf(\"%s\\n\\n%s\\n\", msg, sctx.cfg.AdditionalErrorMessageOnDeny)\n\t}\n\n\tresp := goproxy.NewResponse(pctx.Req, goproxy.ContentTypeText, code, msg+\"\\n\")\n\tresp.Status = status\n\tresp.ProtoMajor = pctx.Req.ProtoMajor\n\tresp.ProtoMinor = pctx.Req.ProtoMinor\n\tresp.Header.Set(errorHeader, msg)\n\tif sctx.cfg.RejectResponseHandler != nil {\n\t\tsctx.cfg.RejectResponseHandler(resp)\n\t}\n\treturn resp\n}\n\nfunc configureTransport(tr *http.Transport, cfg *Config) {\n\tif cfg.TransportMaxIdleConns != 0 {\n\t\ttr.MaxIdleConns = cfg.TransportMaxIdleConns\n\t}\n\n\tif cfg.TransportMaxIdleConnsPerHost != 0 {\n\t\ttr.MaxIdleConnsPerHost = cfg.TransportMaxIdleConns\n\t}\n\n\tif cfg.IdleTimeout != 0 {\n\t\ttr.IdleConnTimeout = cfg.IdleTimeout\n\t}\n}\n\nfunc newContext(cfg *Config, proxyType string, req *http.Request) *smokescreenContext {\n\tstart := time.Now()\n\n\tlogger := cfg.Log.WithFields(logrus.Fields{\n\t\tLogFieldID:            xid.New().String(),\n\t\tLogFieldInRemoteAddr:  req.RemoteAddr,\n\t\tLogFieldProxyType:     proxyType,\n\t\tLogFieldRequestedHost: req.Host,\n\t\tLogFieldStartTime:     start.UTC(),\n\t\tLogFieldTraceID:       req.Header.Get(traceHeader),\n\t})\n\n\treturn &smokescreenContext{\n\t\tcfg:           cfg,\n\t\tlogger:        logger,\n\t\tproxyType:     proxyType,\n\t\tstart:         start,\n\t\trequestedHost: req.Host,\n\t}\n}\n\nfunc BuildProxy(config *Config) *goproxy.ProxyHttpServer {\n\tproxy := goproxy.NewProxyHttpServer()\n\tproxy.Verbose = false\n\tconfigureTransport(proxy.Tr, config)\n\n\t// dialContext will be invoked for both CONNECT and traditional proxy requests\n\tproxy.Tr.DialContext = dialContext\n\n\t// Use a custom goproxy.RoundTripperFunc to ensure that the correct context is attached to the request.\n\t// This is only used for non-CONNECT HTTP proxy requests. For connect requests, goproxy automatically\n\t// attaches goproxy.ProxyCtx prior to calling dialContext.\n\trtFn := goproxy.RoundTripperFunc(func(req *http.Request, pctx *goproxy.ProxyCtx) (*http.Response, error) {\n\t\tctx := context.WithValue(req.Context(), goproxy.ProxyContextKey, pctx)\n\t\treturn proxy.Tr.RoundTrip(req.WithContext(ctx))\n\t})\n\n\t// Associate a timeout with the CONNECT proxy client connection\n\tif config.IdleTimeout != 0 {\n\t\tproxy.ConnectClientConnHandler = func(conn net.Conn) net.Conn {\n\t\t\treturn NewTimeoutConn(conn, config.IdleTimeout)\n\t\t}\n\t}\n\n\t// Handle traditional HTTP proxy\n\tproxy.OnRequest().DoFunc(func(req *http.Request, pctx *goproxy.ProxyCtx) (*http.Request, *http.Response) {\n\n\t\t// We are intentionally *not* setting pctx.HTTPErrorHandler because with traditional HTTP\n\t\t// proxy requests we are able to specify the request during the call to OnResponse().\n\t\tsctx := newContext(config, httpProxy, req)\n\n\t\t// Attach smokescreenContext to goproxy.ProxyCtx\n\t\tpctx.UserData = sctx\n\n\t\t// Delete Smokescreen specific headers before goproxy forwards the request\n\t\tdefer func() {\n\t\t\treq.Header.Del(roleHeader)\n\t\t\treq.Header.Del(traceHeader)\n\t\t}()\n\n\t\t// Set this on every request as every request mints a new goproxy.ProxyCtx\n\t\tpctx.RoundTripper = rtFn\n\n\t\t// Build an address parsable by net.ResolveTCPAddr\n\t\tremoteHost := req.URL.Hostname()\n\t\tif strings.LastIndex(remoteHost, \":\") <= strings.LastIndex(remoteHost, \"]\") {\n\t\t\tswitch req.URL.Scheme {\n\t\t\tcase \"http\":\n\t\t\t\tremoteHost = net.JoinHostPort(remoteHost, \"80\")\n\t\t\tcase \"https\":\n\t\t\t\tremoteHost = net.JoinHostPort(remoteHost, \"443\")\n\t\t\tdefault:\n\t\t\t\tremoteHost = net.JoinHostPort(remoteHost, \"0\")\n\t\t\t}\n\t\t}\n\n\t\tsctx.logger.WithField(\"url\", req.RequestURI).Debug(\"received HTTP proxy request\")\n\n\t\tsctx.decision, sctx.lookupTime, pctx.Error = checkIfRequestShouldBeProxied(config, req, remoteHost)\n\n\t\t// Returning any kind of response in this handler is goproxy's way of short circuiting\n\t\t// the request. The original request will never be sent, and goproxy will invoke our\n\t\t// response filter attached via the OnResponse() handler.\n\t\tif pctx.Error != nil {\n\t\t\treturn req, rejectResponse(pctx, pctx.Error)\n\t\t}\n\t\tif !sctx.decision.allow {\n\t\t\treturn req, rejectResponse(pctx, denyError{errors.New(sctx.decision.reason)})\n\t\t}\n\n\t\t// Proceed with proxying the request\n\t\treturn req, nil\n\t})\n\n\t// Handle CONNECT proxy to TLS & other TCP protocols destination\n\tproxy.OnRequest().HandleConnectFunc(func(host string, pctx *goproxy.ProxyCtx) (*goproxy.ConnectAction, string) {\n\t\tpctx.UserData = newContext(config, connectProxy, pctx.Req)\n\t\tpctx.HTTPErrorHandler = HTTPErrorHandler\n\n\t\t// Defer logging the proxy event here because logProxy relies\n\t\t// on state set in handleConnect\n\t\tdefer logProxy(config, pctx)\n\t\tdefer pctx.Req.Header.Del(traceHeader)\n\n\t\terr := handleConnect(config, pctx)\n\t\tif err != nil {\n\t\t\tpctx.Resp = rejectResponse(pctx, err)\n\t\t\treturn goproxy.RejectConnect, \"\"\n\t\t}\n\t\treturn goproxy.OkConnect, host\n\t})\n\n\t// Strangely, goproxy can invoke this same function twice for a single HTTP request.\n\t//\n\t// If a proxy request is rejected due to an ACL denial, the response passed to this\n\t// function was created by Smokescreen's call to rejectResponse() in the OnRequest()\n\t// handler. This only happens once. This is also the behavior for an allowed request\n\t// which is completed successfully.\n\t//\n\t// If a proxy request is allowed, but the RoundTripper returns an error fulfulling\n\t// the HTTP request, goproxy will invoke this OnResponse() filter twice. First this\n\t// function will be called with a nil response, and as a result this function will\n\t// return a response to send back to the proxy client using rejectResponse(). This\n\t// function will be called again with the previously returned response, which will\n\t// simply trigger the logHTTP function and return.\n\tproxy.OnResponse().DoFunc(func(resp *http.Response, pctx *goproxy.ProxyCtx) *http.Response {\n\t\tsctx := pctx.UserData.(*smokescreenContext)\n\n\t\tif resp != nil && resp.Header.Get(errorHeader) != \"\" {\n\t\t\tif pctx.Error == nil && sctx.decision.allow {\n\t\t\t\tresp.Header.Del(errorHeader)\n\t\t\t}\n\t\t}\n\n\t\tif resp == nil && pctx.Error != nil {\n\t\t\treturn rejectResponse(pctx, pctx.Error)\n\t\t}\n\n\t\t// In case of an error, this function is called a second time to filter the\n\t\t// response we generate so this logger will be called once.\n\t\tlogProxy(config, pctx)\n\t\treturn resp\n\t})\n\treturn proxy\n}\n\nfunc logProxy(config *Config, pctx *goproxy.ProxyCtx) {\n\tsctx := pctx.UserData.(*smokescreenContext)\n\n\tfields := logrus.Fields{}\n\n\t// attempt to retrieve information about the host originating the proxy request\n\tif pctx.Req.TLS != nil && len(pctx.Req.TLS.PeerCertificates) > 0 {\n\t\tfields[LogFieldInRemoteX509CN] = pctx.Req.TLS.PeerCertificates[0].Subject.CommonName\n\t\tvar ouEntries = pctx.Req.TLS.PeerCertificates[0].Subject.OrganizationalUnit\n\t\tif len(ouEntries) > 0 {\n\t\t\tfields[LogFieldInRemoteX509OU] = ouEntries[0]\n\t\t}\n\t}\n\n\tdecision := sctx.decision\n\tif sctx.decision != nil {\n\t\tfields[LogFieldRole] = decision.role\n\t\tfields[LogFieldProject] = decision.project\n\t}\n\n\t// add the above fields to all future log messages sent using this smokescreen context's logger\n\tsctx.logger = sctx.logger.WithFields(fields)\n\n\t// start a new set of fields used only in this log message\n\tfields = logrus.Fields{}\n\n\t// If a lookup takes less than 1ms it will be rounded down to zero. This can separated from\n\t// actual failures where the default zero value will also have the error field set.\n\tfields[LogFieldDNSLookupTime] = sctx.lookupTime.Milliseconds()\n\n\tif pctx.Resp != nil {\n\t\tfields[LogFieldContentLength] = pctx.Resp.ContentLength\n\t}\n\n\tif sctx.decision != nil {\n\t\tfields[LogFieldDecisionReason] = decision.reason\n\t\tfields[LogFieldEnforceWouldDeny] = decision.enforceWouldDeny\n\t\tfields[LogFieldAllow] = decision.allow\n\t}\n\n\terr := pctx.Error\n\tif err != nil {\n\t\tfields[LogFieldError] = err.Error()\n\t}\n\n\tentry := sctx.logger.WithFields(fields)\n\tvar logMethod func(...interface{})\n\tif _, ok := err.(denyError); !ok && err != nil {\n\t\tlogMethod = entry.Error\n\t} else if decision != nil && decision.allow {\n\t\tlogMethod = entry.Info\n\t} else {\n\t\tlogMethod = entry.Warn\n\t}\n\tlogMethod(CanonicalProxyDecision)\n}\n\nfunc handleConnect(config *Config, pctx *goproxy.ProxyCtx) error {\n\tsctx := pctx.UserData.(*smokescreenContext)\n\n\t// Check if requesting role is allowed to talk to remote\n\tsctx.decision, sctx.lookupTime, pctx.Error = checkIfRequestShouldBeProxied(config, pctx.Req, pctx.Req.URL.Hostname())\n\tif pctx.Error != nil {\n\t\treturn pctx.Error\n\t}\n\tif !sctx.decision.allow {\n\t\treturn denyError{errors.New(sctx.decision.reason)}\n\t}\n\n\treturn nil\n}\n\nfunc findListener(ip string, defaultPort uint16) (net.Listener, error) {\n\tif einhorn.IsWorker() {\n\t\tlistener, err := einhorn.GetListener(0)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn &einhornListener{Listener: listener}, err\n\t} else {\n\t\treturn net.Listen(\"tcp\", fmt.Sprintf(\"%s:%d\", ip, defaultPort))\n\t}\n}\n\nfunc StartWithConfig(config *Config, quit <-chan interface{}) {\n\tconfig.Log.Println(\"starting\")\n\tproxy := BuildProxy(config)\n\tlistener := config.Listener\n\tvar err error\n\n\tif listener == nil {\n\t\tlistener, err = findListener(config.Ip, config.Port)\n\t\tif err != nil {\n\t\t\tconfig.Log.Fatal(\"can't find listener\", err)\n\t\t}\n\t}\n\n\tif config.SupportProxyProtocol {\n\t\tlistener = &proxyproto.Listener{Listener: listener}\n\t}\n\n\tvar handler http.Handler = proxy\n\n\tif config.Healthcheck != nil {\n\t\thandler = &HealthcheckMiddleware{\n\t\t\tProxy:       handler,\n\t\t\tHealthcheck: config.Healthcheck,\n\t\t}\n\t}\n\n\t// TLS support\n\tif config.TlsConfig != nil {\n\t\tlistener = tls.NewListener(listener, config.TlsConfig)\n\t}\n\n\t// Setup connection tracking\n\tconfig.ConnTracker = conntrack.NewTracker(config.IdleTimeout, config.MetricsClient.StatsdClient, config.Log, config.ShuttingDown)\n\n\tserver := http.Server{\n\t\tHandler: handler,\n\t}\n\n\t// This sets an IdleTimeout on _all_ client connections. CONNECT requests\n\t// hijacked by goproxy inherit the deadline set here. The deadlines are\n\t// reset by the proxy.ConnectClientConnHandler, which wraps the hijacked\n\t// connection in a TimeoutConn which bumps the deadline for every read/write.\n\tif config.IdleTimeout != 0 {\n\t\tserver.IdleTimeout = config.IdleTimeout\n\t}\n\n\tconfig.MetricsClient.started.Store(true)\n\tconfig.ShuttingDown.Store(false)\n\trunServer(config, &server, listener, quit)\n}\n\nfunc runServer(config *Config, server *http.Server, listener net.Listener, quit <-chan interface{}) {\n\t// Runs the server and shuts it down when it receives a signal.\n\t//\n\t// Why aren't we using goji's graceful shutdown library? Great question!\n\t//\n\t// There are several things we might want to do when shutting down gracefully:\n\t// 1. close the listening socket (so that we don't accept *new* connections)\n\t// 2. close *existing* keepalive connections once they become idle\n\t//\n\t// goproxy hijacks the socket and interferes with goji's ability to do the\n\t// latter.  We instead pass InstrumentedConn objects, which wrap net.Conn,\n\t// into goproxy.  ConnTracker keeps a reference to these, which allows us to\n\t// know exactly how long to wait until the connection has become idle, and\n\t// then Close it.\n\n\tif len(config.StatsSocketDir) > 0 {\n\t\tconfig.StatsServer = StartStatsServer(config)\n\t}\n\n\tgraceful := true\n\tkill := make(chan os.Signal, 1)\n\tsignal.Notify(kill, syscall.SIGUSR2, syscall.SIGTERM, syscall.SIGHUP)\n\tgo func() {\n\t\tselect {\n\t\tcase <-kill:\n\t\t\tconfig.Log.Print(\"quitting gracefully\")\n\n\t\tcase <-quit:\n\t\t\tconfig.Log.Print(\"quitting now\")\n\t\t\tgraceful = false\n\t\t}\n\t\tconfig.ShuttingDown.Store(true)\n\n\t\t// Shutdown() will block until all connections are closed unless we\n\t\t// provide it with a cancellation context.\n\t\ttimeout := config.ExitTimeout\n\t\tif !graceful {\n\t\t\ttimeout = 10 * time.Second\n\t\t}\n\n\t\tctx, cancel := context.WithTimeout(context.Background(), timeout)\n\t\tdefer cancel()\n\n\t\terr := server.Shutdown(ctx)\n\t\tif err != nil {\n\t\t\tconfig.Log.Errorf(\"error shutting down http server: %v\", err)\n\t\t}\n\t}()\n\n\tif err := server.Serve(listener); err != http.ErrServerClosed {\n\t\tconfig.Log.Errorf(\"http serve error: %v\", err)\n\t}\n\n\tif graceful {\n\t\t// Wait for all connections to close or become idle before\n\t\t// continuing in an attempt to shutdown gracefully.\n\t\texit := make(chan ExitStatus, 1)\n\n\t\t// This subroutine blocks until all connections close.\n\t\tgo func() {\n\t\t\tconfig.Log.Print(\"Waiting for all connections to close...\")\n\t\t\tconfig.ConnTracker.Wg.Wait()\n\t\t\tconfig.Log.Print(\"All connections are closed. Continuing with shutdown...\")\n\t\t\texit <- Closed\n\t\t}()\n\n\t\t// Always wait for a maximum of config.ExitTimeout\n\t\ttime.AfterFunc(config.ExitTimeout, func() {\n\t\t\tconfig.Log.Printf(\"ExitTimeout %v reached - timing out\", config.ExitTimeout)\n\t\t\texit <- Timeout\n\t\t})\n\n\t\t// Sometimes, connections don't close and remain in the idle state. This subroutine\n\t\t// waits until all open connections are idle before sending the exit signal.\n\t\tgo func() {\n\t\t\tconfig.Log.Print(\"Waiting for all connections to become idle...\")\n\t\t\tbeginTs := time.Now()\n\n\t\t\t// If idleTimeout is set to 0, fall back to using the exit timeout to avoid\n\t\t\t// immediately closing active connections.\n\t\t\tidleTimeout := config.IdleTimeout\n\t\t\tif idleTimeout == 0 {\n\t\t\t\tidleTimeout = config.ExitTimeout\n\t\t\t}\n\n\t\t\tfor {\n\t\t\t\tcheckAgainIn := config.ConnTracker.MaybeIdleIn(idleTimeout)\n\t\t\t\tif checkAgainIn > 0 {\n\t\t\t\t\tif time.Since(beginTs) > config.ExitTimeout {\n\t\t\t\t\t\tconfig.Log.Print(fmt.Sprintf(\"Timed out at %v while waiting for all open connections to become idle.\", config.ExitTimeout))\n\t\t\t\t\t\texit <- Timeout\n\t\t\t\t\t\tbreak\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconfig.Log.Print(fmt.Sprintf(\"There are still active connections. Waiting %v before checking again.\", checkAgainIn))\n\t\t\t\t\t\ttime.Sleep(checkAgainIn)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconfig.Log.Print(\"All connections are idle. Continuing with shutdown...\")\n\t\t\t\t\texit <- Idle\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\t// Wait for the exit signal.\n\t\treason := <-exit\n\t\tconfig.Log.Print(fmt.Sprintf(\"%s: closing all remaining connections.\", reason.String()))\n\t}\n\n\t// Close all open (and idle) connections to send their metrics to log.\n\tconfig.ConnTracker.Range(func(k, v interface{}) bool {\n\t\tk.(*conntrack.InstrumentedConn).Close()\n\t\treturn true\n\t})\n\n\tif config.StatsServer != nil {\n\t\tconfig.StatsServer.Shutdown()\n\t}\n}\n\n// Extract the client's ACL role from the HTTP request, using the configured\n// RoleFromRequest function.  Returns the role, or an error if the role cannot\n// be determined (including no RoleFromRequest configured), unless\n// AllowMissingRole is configured, in which case an empty role and no error is\n// returned.\nfunc getRole(config *Config, req *http.Request) (string, error) {\n\tvar role string\n\tvar err error\n\n\tif config.RoleFromRequest != nil {\n\t\trole, err = config.RoleFromRequest(req)\n\t} else {\n\t\terr = MissingRoleError(\"RoleFromRequest is not configured\")\n\t}\n\n\tswitch {\n\tcase err == nil:\n\t\treturn role, nil\n\tcase IsMissingRoleError(err) && config.AllowMissingRole:\n\t\treturn \"\", nil\n\tdefault:\n\t\tconfig.Log.WithFields(logrus.Fields{\n\t\t\t\"error\":              err,\n\t\t\t\"is_missing_role\":    IsMissingRoleError(err),\n\t\t\t\"allow_missing_role\": config.AllowMissingRole,\n\t\t}).Error(\"Unable to get role for request\")\n\t\treturn \"\", err\n\t}\n}\n\nfunc checkIfRequestShouldBeProxied(config *Config, req *http.Request, outboundHost string) (*aclDecision, time.Duration, error) {\n\tdecision := checkACLsForRequest(config, req, outboundHost)\n\n\tvar lookupTime time.Duration\n\tif decision.allow {\n\t\tstart := time.Now()\n\t\tresolved, reason, err := safeResolve(config, \"tcp\", outboundHost)\n\t\tlookupTime = time.Since(start)\n\t\tif err != nil {\n\t\t\tif _, ok := err.(denyError); !ok {\n\t\t\t\treturn decision, lookupTime, err\n\t\t\t}\n\t\t\tdecision.reason = fmt.Sprintf(\"%s. %s\", err.Error(), reason)\n\t\t\tdecision.allow = false\n\t\t\tdecision.enforceWouldDeny = true\n\t\t} else {\n\t\t\tdecision.resolvedAddr = resolved\n\t\t}\n\t}\n\n\treturn decision, lookupTime, nil\n}\n\nfunc checkACLsForRequest(config *Config, req *http.Request, outboundHost string) *aclDecision {\n\tdecision := &aclDecision{\n\t\toutboundHost: outboundHost,\n\t}\n\n\tif config.EgressACL == nil {\n\t\tdecision.allow = true\n\t\tdecision.reason = \"Egress ACL is not configured\"\n\t\treturn decision\n\t}\n\n\trole, roleErr := getRole(config, req)\n\tif roleErr != nil {\n\t\tconfig.MetricsClient.Incr(\"acl.role_not_determined\", 1)\n\t\tdecision.reason = \"Client role cannot be determined\"\n\t\treturn decision\n\t}\n\n\tdecision.role = role\n\n\tsubmatch := hostExtractRE.FindStringSubmatch(outboundHost)\n\tdestination := submatch[1]\n\n\taclDecision, err := config.EgressACL.Decide(role, destination)\n\tdecision.project = aclDecision.Project\n\tdecision.reason = aclDecision.Reason\n\tif err != nil {\n\t\tconfig.Log.WithFields(logrus.Fields{\n\t\t\t\"error\": err,\n\t\t\t\"role\":  role,\n\t\t}).Warn(\"EgressAcl.Decide returned an error.\")\n\n\t\tconfig.MetricsClient.Incr(\"acl.decide_error\", 1)\n\t\treturn decision\n\t}\n\n\ttags := []string{\n\t\tfmt.Sprintf(\"role:%s\", decision.role),\n\t\tfmt.Sprintf(\"def_rule:%t\", aclDecision.Default),\n\t\tfmt.Sprintf(\"project:%s\", aclDecision.Project),\n\t}\n\n\tswitch aclDecision.Result {\n\tcase acl.Deny:\n\t\tdecision.enforceWouldDeny = true\n\t\tconfig.MetricsClient.IncrWithTags(\"acl.deny\", tags, 1)\n\n\tcase acl.AllowAndReport:\n\t\tdecision.enforceWouldDeny = true\n\t\tconfig.MetricsClient.IncrWithTags(\"acl.report\", tags, 1)\n\t\tdecision.allow = true\n\n\tcase acl.Allow:\n\t\t// Well, everything is going as expected.\n\t\tdecision.allow = true\n\t\tdecision.enforceWouldDeny = false\n\t\tconfig.MetricsClient.IncrWithTags(\"acl.allow\", tags, 1)\n\tdefault:\n\t\tconfig.Log.WithFields(logrus.Fields{\n\t\t\t\"role\":        role,\n\t\t\t\"destination\": destination,\n\t\t\t\"action\":      aclDecision.Result.String(),\n\t\t}).Warn(\"Unknown ACL action\")\n\t\tdecision.reason = \"Internal error\"\n\t\tconfig.MetricsClient.IncrWithTags(\"acl.unknown_error\", tags, 1)\n\t}\n\n\treturn decision\n}\n", "// +build !nounit\n\npackage smokescreen\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/DataDog/datadog-go/statsd\"\n\t\"github.com/sirupsen/logrus\"\n\tlogrustest \"github.com/sirupsen/logrus/hooks/test\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"github.com/stripe/smokescreen/pkg/smokescreen/conntrack\"\n)\n\nvar allowRanges = []string{\n\t\"8.8.9.0/24\",\n\t\"10.0.1.0/24\",\n\t\"172.16.1.0/24\",\n\t\"192.168.1.0/24\",\n\t\"127.0.1.0/24\",\n}\nvar allowAddresses = []string{\n\t\"10.0.0.1:321\",\n}\nvar denyRanges = []string{\n\t\"1.1.1.1/32\",\n}\nvar denyAddresses = []string{\n\t\"8.8.8.8:321\",\n}\n\ntype testCase struct {\n\tip       string\n\tport     int\n\texpected ipType\n}\n\nfunc TestClassifyAddr(t *testing.T) {\n\ta := assert.New(t)\n\n\tconf := NewConfig()\n\ta.NoError(conf.SetDenyRanges(denyRanges))\n\ta.NoError(conf.SetDenyAddresses(denyAddresses))\n\ta.NoError(conf.SetAllowRanges(allowRanges))\n\ta.NoError(conf.SetAllowAddresses(allowAddresses))\n\tconf.ConnectTimeout = 10 * time.Second\n\tconf.ExitTimeout = 10 * time.Second\n\tconf.AdditionalErrorMessageOnDeny = \"Proxy denied\"\n\n\ttestIPs := []testCase{\n\t\ttestCase{\"8.8.8.8\", 1, ipAllowDefault},\n\t\ttestCase{\"8.8.9.8\", 1, ipAllowUserConfigured},\n\n\t\t// Specific blocked networks\n\t\ttestCase{\"10.0.0.1\", 1, ipDenyPrivateRange},\n\t\ttestCase{\"10.0.0.1\", 321, ipAllowUserConfigured},\n\t\ttestCase{\"10.0.1.1\", 1, ipAllowUserConfigured},\n\t\ttestCase{\"172.16.0.1\", 1, ipDenyPrivateRange},\n\t\ttestCase{\"172.16.1.1\", 1, ipAllowUserConfigured},\n\t\ttestCase{\"192.168.0.1\", 1, ipDenyPrivateRange},\n\t\ttestCase{\"192.168.1.1\", 1, ipAllowUserConfigured},\n\t\ttestCase{\"8.8.8.8\", 321, ipDenyUserConfigured},\n\t\ttestCase{\"1.1.1.1\", 1, ipDenyUserConfigured},\n\n\t\t// localhost\n\t\ttestCase{\"127.0.0.1\", 1, ipDenyNotGlobalUnicast},\n\t\ttestCase{\"127.255.255.255\", 1, ipDenyNotGlobalUnicast},\n\t\ttestCase{\"::1\", 1, ipDenyNotGlobalUnicast},\n\t\ttestCase{\"127.0.1.1\", 1, ipAllowUserConfigured},\n\n\t\t// ec2 metadata endpoint\n\t\ttestCase{\"169.254.169.254\", 1, ipDenyNotGlobalUnicast},\n\n\t\t// Broadcast addresses\n\t\ttestCase{\"255.255.255.255\", 1, ipDenyNotGlobalUnicast},\n\t\ttestCase{\"ff02:0:0:0:0:0:0:2\", 1, ipDenyNotGlobalUnicast},\n\t}\n\n\tfor _, test := range testIPs {\n\t\tlocalIP := net.ParseIP(test.ip)\n\t\tif localIP == nil {\n\t\t\tt.Errorf(\"Could not parse IP from string: %s\", test.ip)\n\t\t\tcontinue\n\t\t}\n\t\tlocalAddr := net.TCPAddr{\n\t\t\tIP:   localIP,\n\t\t\tPort: test.port,\n\t\t}\n\n\t\tgot := classifyAddr(conf, &localAddr)\n\t\tif got != test.expected {\n\t\t\tt.Errorf(\"Misclassified IP (%s): should be %s, but is instead %s.\", localIP, test.expected, got)\n\t\t}\n\t}\n}\n\nfunc TestUnsafeAllowPrivateRanges(t *testing.T) {\n\ta := assert.New(t)\n\n\tconf := NewConfig()\n\ta.NoError(conf.SetDenyRanges([]string{\"192.168.0.0/24\", \"10.0.0.0/8\"}))\n\tconf.ConnectTimeout = 10 * time.Second\n\tconf.ExitTimeout = 10 * time.Second\n\tconf.AdditionalErrorMessageOnDeny = \"Proxy denied\"\n\n\tconf.UnsafeAllowPrivateRanges = true\n\n\ttestIPs := []testCase{\n\t\ttestCase{\"8.8.8.8\", 1, ipAllowDefault},\n\n\t\t// Specific blocked networks\n\t\ttestCase{\"10.0.0.1\", 1, ipDenyUserConfigured},\n\t\ttestCase{\"10.0.0.1\", 321, ipDenyUserConfigured},\n\t\ttestCase{\"10.0.1.1\", 1, ipDenyUserConfigured},\n\t\ttestCase{\"172.16.0.1\", 1, ipAllowDefault},\n\t\ttestCase{\"172.16.1.1\", 1, ipAllowDefault},\n\t\ttestCase{\"192.168.0.1\", 1, ipDenyUserConfigured},\n\t\ttestCase{\"192.168.1.1\", 1, ipAllowDefault},\n\n\t\t// localhost\n\t\ttestCase{\"127.0.0.1\", 1, ipDenyNotGlobalUnicast},\n\t\ttestCase{\"127.255.255.255\", 1, ipDenyNotGlobalUnicast},\n\t\ttestCase{\"::1\", 1, ipDenyNotGlobalUnicast},\n\n\t\t// ec2 metadata endpoint\n\t\ttestCase{\"169.254.169.254\", 1, ipDenyNotGlobalUnicast},\n\n\t\t// Broadcast addresses\n\t\ttestCase{\"255.255.255.255\", 1, ipDenyNotGlobalUnicast},\n\t\ttestCase{\"ff02:0:0:0:0:0:0:2\", 1, ipDenyNotGlobalUnicast},\n\t}\n\n\tfor _, test := range testIPs {\n\t\tlocalIP := net.ParseIP(test.ip)\n\t\tif localIP == nil {\n\t\t\tt.Errorf(\"Could not parse IP from string: %s\", test.ip)\n\t\t\tcontinue\n\t\t}\n\t\tlocalAddr := net.TCPAddr{\n\t\t\tIP:   localIP,\n\t\t\tPort: test.port,\n\t\t}\n\n\t\tgot := classifyAddr(conf, &localAddr)\n\t\tif got != test.expected {\n\t\t\tt.Errorf(\"Misclassified IP (%s): should be %s, but is instead %s.\", localIP, test.expected, got)\n\t\t}\n\t}\n\n}\n\n// TestClearsErrors tests that we are correctly preserving/removing the X-Smokescreen-Error header.\n// This header is used to provide more granular errors to proxy clients, and signals that\n// there was an issue connecting to the proxy target.\nfunc TestClearsErrorHeader(t *testing.T) {\n\tr := require.New(t)\n\n\t// For HTTP requests, Smokescreen should ensure successful requests do not include\n\t// X-Smokescreen-Error, even if they are set by the upstream host.\n\tt.Run(\"Clears error header set by upstream\", func(t *testing.T) {\n\t\tlog.SetFlags(log.LstdFlags | log.Lshortfile)\n\n\t\tcfg, err := testConfig(\"test-trusted-srv\")\n\t\tr.NoError(err)\n\n\t\tproxySrv := proxyServer(cfg)\n\t\tr.NoError(err)\n\t\tdefer proxySrv.Close()\n\n\t\t// Create a http.Client that uses our proxy\n\t\tclient, err := proxyClient(proxySrv.URL)\n\t\tr.NoError(err)\n\n\t\t// Talk \"through\" the proxy to our malicious upstream that sets the\n\t\t// error header.\n\t\tresp, err := client.Get(\"http://httpbin.org/response-headers?X-Smokescreen-Error=foobar&X-Smokescreen-Test=yes\")\n\t\tr.NoError(err)\n\n\t\t// Should succeed\n\t\tif resp.StatusCode != 200 {\n\t\t\tt.Errorf(\"response had bad status: expected 200, got %d\", resp.StatusCode)\n\t\t}\n\n\t\t// Verify the error header is not set.\n\t\tif h := resp.Header.Get(errorHeader); h != \"\" {\n\t\t\tt.Errorf(\"proxy did not strip %q header: %q\", errorHeader, h)\n\t\t}\n\n\t\t// Verify we did get the other header, to confirm we're talking to the right thing\n\t\tif h := resp.Header.Get(\"X-Smokescreen-Test\"); h != \"yes\" {\n\t\t\tt.Errorf(\"did not get expected header X-Smokescreen-Test: expected \\\"yes\\\", got %q\", h)\n\t\t}\n\t})\n\n\t// Test that the the error header is preserved when a connection is allowed by the ACL,\n\t// but the connection fails to be established.\n\tt.Run(\"Doesn't clear errors for allowed connections\", func(t *testing.T) {\n\t\tcfg, err := testConfig(\"test-local-srv\")\n\t\tr.NoError(err)\n\n\t\t// Immediately time out to simulate net.Dial timeouts\n\t\tcfg.ConnectTimeout = -1\n\n\t\tproxySrv := proxyServer(cfg)\n\t\tr.NoError(err)\n\t\tdefer proxySrv.Close()\n\n\t\t// Create a http.Client that uses our proxy\n\t\tclient, err := proxyClient(proxySrv.URL)\n\t\tr.NoError(err)\n\n\t\tresp, err := client.Get(\"http://127.0.0.1\")\n\t\tr.NoError(err)\n\n\t\t// Verify the error header is still set\n\t\th := resp.Header.Get(errorHeader)\n\t\tif h == \"\" {\n\t\t\tt.Errorf(\"proxy stripped %q header: %q\", errorHeader, h)\n\t\t}\n\t})\n}\n\nfunc TestConsistentHostHeader(t *testing.T) {\n\tr := require.New(t)\n\ta := assert.New(t)\n\n\thostCh := make(chan string)\n\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"OK\"))\n\t\thostCh <- r.Host\n\t}))\n\tdefer ts.Close()\n\n\t// Custom proxy config for the \"remote\" httptest.NewServer\n\tconf := NewConfig()\n\tconf.ConnTracker = conntrack.NewTracker(conf.IdleTimeout, &statsd.NoOpClient{}, conf.Log, atomic.Value{})\n\terr := conf.SetAllowAddresses([]string{\"127.0.0.1\"})\n\tr.NoError(err)\n\n\tproxy := BuildProxy(conf)\n\tproxySrv := httptest.NewServer(proxy)\n\n\tclient, err := proxyClient(proxySrv.URL)\n\tr.NoError(err)\n\n\treq, err := http.NewRequest(\"GET\", ts.URL, nil)\n\tr.NoError(err)\n\n\texpectedHostHeader := req.Host\n\tgo client.Do(req)\n\n\tselect {\n\tcase receivedHostHeader := <-hostCh:\n\t\ta.Equal(expectedHostHeader, receivedHostHeader)\n\tcase <-time.After(3 * time.Second):\n\t\tt.Fatal(\"timed out waiting for client request\")\n\t}\n}\n\nfunc TestClearsTraceIDHeader(t *testing.T) {\n\tr := require.New(t)\n\ta := assert.New(t)\n\n\theaderCh := make(chan string)\n\trespCh := make(chan bool)\n\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"OK\"))\n\t\theaderCh <- r.Header.Get(\"X-Smokescreen-Trace-ID\")\n\t}))\n\tdefer ts.Close()\n\n\t// Custom proxy config for the \"remote\" httptest.NewServer\n\tvar logHook logrustest.Hook\n\tconf := NewConfig()\n\tconf.Log.AddHook(&logHook)\n\tconf.ConnTracker = conntrack.NewTracker(conf.IdleTimeout, &statsd.NoOpClient{}, conf.Log, atomic.Value{})\n\terr := conf.SetAllowAddresses([]string{\"127.0.0.1\"})\n\tr.NoError(err)\n\n\tproxy := BuildProxy(conf)\n\tproxySrv := httptest.NewServer(proxy)\n\n\tclient, err := proxyClient(proxySrv.URL)\n\tr.NoError(err)\n\n\treq, err := http.NewRequest(\"GET\", ts.URL, nil)\n\tr.NoError(err)\n\treq.Header.Set(\"X-Smokescreen-Trace-ID\", \"6c4aa514e3da13ef\")\n\n\tgo func() {\n\t\tclient.Do(req)\n\t\trespCh <- true\n\t}()\n\n\tselect {\n\tcase receivedTraceIDCh := <-headerCh:\n\t\ta.Empty(receivedTraceIDCh)\n\tcase <-time.After(3 * time.Second):\n\t\tt.Fatal(\"timed out waiting for client request\")\n\t}\n\n\tselect {\n\tcase <-respCh:\n\t\tentry := findCanonicalProxyDecision(logHook.AllEntries())\n\t\tr.NotNil(entry)\n\t\ta.NotEmpty(entry.Data[\"trace_id\"])\n\tcase <-time.After(3 * time.Second):\n\t\tt.Fatal(\"timed out waiting for server response\")\n\t}\n\n}\n\nfunc TestShuttingDownValue(t *testing.T) {\n\ta := assert.New(t)\n\n\tconf := NewConfig()\n\tconf.Port = 39381\n\n\tquit := make(chan interface{})\n\tgo StartWithConfig(conf, quit)\n\n\t// These sleeps are not ideal, but there is a race with checking the\n\t// ShuttingDown value from these tests. The server has to bootstrap\n\t// itself with an initial value before it returns false, and has to\n\t// set the value to true after we send on the quit channel.\n\ttime.Sleep(500 * time.Millisecond)\n\ta.Equal(false, conf.ShuttingDown.Load())\n\n\tquit <- true\n\n\ttime.Sleep(500 * time.Millisecond)\n\ta.Equal(true, conf.ShuttingDown.Load())\n\n}\n\nfunc TestHealthcheck(t *testing.T) {\n\tr := require.New(t)\n\ta := assert.New(t)\n\n\thealthcheckCh := make(chan string)\n\n\ttestHealthcheck := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Write([]byte(\"OK\"))\n\t\thealthcheckCh <- \"OK\"\n\t})\n\n\tconf := NewConfig()\n\n\t// We set this here so that we can deterministically test the Healthcheck\n\t// handler. Otherwise we would have to call StartWithConfig() in a goroutine,\n\t// which creates a race between the test and the listener accepting\n\t// connections.\n\thandler := HealthcheckMiddleware{\n\t\tProxy:       BuildProxy(conf),\n\t\tHealthcheck: testHealthcheck,\n\t}\n\n\tserver := httptest.NewServer(handler)\n\n\terrChan := make(chan error, 1)\n\tgo func() {\n\t\tselect {\n\t\tcase healthy := <-healthcheckCh:\n\t\t\tif healthy != \"OK\" {\n\t\t\t\terrChan <- fmt.Errorf(\"healthcheck not OK: %s\", healthy)\n\t\t\t}\n\t\tcase <-time.After(5 * time.Second):\n\t\t\terrChan <- errors.New(\"timed out waiting for client request\")\n\t\t}\n\t\tclose(errChan)\n\t}()\n\n\tresp, err := http.Get(fmt.Sprintf(\"%s/healthcheck\", server.URL))\n\tr.NoError(err)\n\ta.Equal(http.StatusOK, resp.StatusCode)\n\n\tr.NoError(<-errChan)\n}\n\nvar invalidHostCases = []struct {\n\tscheme    string\n\texpectErr bool\n\tproxyType string\n}{\n\t{\"http\", false, \"http\"},\n\t{\"https\", true, \"connect\"},\n}\n\nfunc TestInvalidHost(t *testing.T) {\n\tfor _, testCase := range invalidHostCases {\n\t\tt.Run(testCase.scheme, func(t *testing.T) {\n\t\t\ta := assert.New(t)\n\t\t\tr := require.New(t)\n\n\t\t\tcfg, err := testConfig(\"test-trusted-srv\")\n\t\t\trequire.NoError(t, err)\n\t\t\tlogHook := proxyLogHook(cfg)\n\n\t\t\tproxySrv := proxyServer(cfg)\n\t\t\tdefer proxySrv.Close()\n\n\t\t\t// Create a http.Client that uses our proxy\n\t\t\tclient, err := proxyClient(proxySrv.URL)\n\t\t\tr.NoError(err)\n\n\t\t\tresp, err := client.Get(fmt.Sprintf(\"%s://notarealhost.test\", testCase.scheme))\n\t\t\tif testCase.expectErr {\n\t\t\t\tr.Contains(err.Error(), \"Bad gateway\")\n\t\t\t} else {\n\t\t\t\tr.NoError(err)\n\t\t\t\tr.Equal(http.StatusBadGateway, resp.StatusCode)\n\t\t\t}\n\n\t\t\tentry := findCanonicalProxyDecision(logHook.AllEntries())\n\t\t\tr.NotNil(entry)\n\n\t\t\tif a.Contains(entry.Data, \"allow\") {\n\t\t\t\ta.Equal(true, entry.Data[\"allow\"])\n\t\t\t}\n\t\t\tif a.Contains(entry.Data, \"error\") {\n\t\t\t\ta.Contains(entry.Data[\"error\"], \"no such host\")\n\t\t\t}\n\t\t\tif a.Contains(entry.Data, \"proxy_type\") {\n\t\t\t\ta.Contains(entry.Data[\"proxy_type\"], testCase.proxyType)\n\t\t\t}\n\t\t})\n\t}\n}\n\nvar hostSquareBracketsCases = []struct {\n\tscheme    string\n\tproxyType string\n}{\n\t{\"http\", \"http\"},\n\t{\"https\", \"connect\"},\n}\n\nfunc TestHostSquareBrackets(t *testing.T) {\n\tfor _, testCase := range hostSquareBracketsCases {\n\t\tt.Run(testCase.scheme, func(t *testing.T) {\n\t\t\ta := assert.New(t)\n\t\t\tr := require.New(t)\n\n\t\t\tcfg, err := testConfig(\"test-open-srv\")\n\t\t\trequire.NoError(t, err)\n\t\t\tlogHook := proxyLogHook(cfg)\n\n\t\t\tproxySrv := proxyServer(cfg)\n\t\t\tdefer proxySrv.Close()\n\n\t\t\t// Create a http.Client that uses our proxy\n\t\t\tclient, err := proxyClient(proxySrv.URL)\n\t\t\tr.NoError(err)\n\n\t\t\tresp, err := client.Get(fmt.Sprintf(\"%s://[stripe.com]\", testCase.scheme))\n\t\t\tif err != nil {\n\t\t\t\tr.Contains(err.Error(), \"Request rejected by proxy\")\n\t\t\t} else {\n\t\t\t\tr.Equal(http.StatusProxyAuthRequired, resp.StatusCode)\n\t\t\t}\n\n\t\t\tentry := findCanonicalProxyDecision(logHook.AllEntries())\n\t\t\tr.NotNil(entry)\n\n\t\t\tif a.Contains(entry.Data, \"allow\") {\n\t\t\t\ta.Equal(false, entry.Data[\"allow\"])\n\t\t\t\ta.Equal(\"host matched rule in global deny list\", entry.Data[\"decision_reason\"])\n\t\t\t}\n\t\t\tif a.Contains(entry.Data, \"proxy_type\") {\n\t\t\t\ta.Contains(entry.Data[\"proxy_type\"], testCase.proxyType)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestErrorHeader(t *testing.T) {\n\ta := assert.New(t)\n\tr := require.New(t)\n\n\tcfg, err := testConfig(\"test-trusted-srv\")\n\trequire.NoError(t, err)\n\tlogHook := proxyLogHook(cfg)\n\n\tproxySrv := proxyServer(cfg)\n\tdefer proxySrv.Close()\n\n\t// Create a http.Client that uses our proxy\n\tclient, err := proxyClient(proxySrv.URL)\n\tr.NoError(err)\n\n\tresp, err := client.Get(\"http://example.com\")\n\tr.NoError(err)\n\tr.Equal(http.StatusProxyAuthRequired, resp.StatusCode)\n\tr.NotEmpty(resp.Header.Get(\"X-Smokescreen-Error\"))\n\n\tentry := findCanonicalProxyDecision(logHook.AllEntries())\n\tr.NotNil(entry)\n\n\tif a.Contains(entry.Data, \"allow\") {\n\t\ta.Equal(false, entry.Data[\"allow\"])\n\t}\n}\n\n// TestProxyProtocols ensures that both traditional HTTP and CONNECT proxy\n// requests Emit the correct CANONICAL-PROXY-DECISION log\nfunc TestProxyProtocols(t *testing.T) {\n\ta := assert.New(t)\n\tr := require.New(t)\n\tt.Run(\"HTTP proxy\", func(t *testing.T) {\n\t\tcfg, err := testConfig(\"test-local-srv\")\n\t\tr.NoError(err)\n\t\terr = cfg.SetAllowAddresses([]string{\"127.0.0.1\"})\n\t\tr.NoError(err)\n\n\t\tclientCh := make(chan bool)\n\t\th := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tw.Write([]byte(\"OK\"))\n\t\t})\n\n\t\tl, err := net.Listen(\"tcp\", \"localhost:0\")\n\t\tr.NoError(err)\n\t\tcfg.Listener = l\n\n\t\tlogHook := proxyLogHook(cfg)\n\t\tproxy := proxyServer(cfg)\n\t\tremote := httptest.NewServer(h)\n\t\tclient, err := proxyClient(proxy.URL)\n\t\tr.NoError(err)\n\n\t\treq, err := http.NewRequest(\"GET\", remote.URL, nil)\n\t\tr.NoError(err)\n\n\t\tgo func() {\n\t\t\tclient.Do(req)\n\t\t\tclientCh <- true\n\t\t}()\n\n\t\t<-clientCh\n\t\tentry := findCanonicalProxyDecision(logHook.AllEntries())\n\t\tr.NotNil(entry)\n\n\t\tr.Contains(entry.Data, \"proxy_type\")\n\t\tr.Equal(\"http\", entry.Data[\"proxy_type\"])\n\t})\n\n\tt.Run(\"CONNECT proxy\", func(t *testing.T) {\n\t\tcfg, err := testConfig(\"test-local-srv\")\n\t\tr.NoError(err)\n\t\terr = cfg.SetAllowAddresses([]string{\"127.0.0.1\"})\n\t\tr.NoError(err)\n\n\t\tclientCh := make(chan bool)\n\t\tserverCh := make(chan bool)\n\t\th := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\tserverCh <- true\n\t\t\t<-serverCh\n\t\t\tw.Write([]byte(\"OK\"))\n\t\t})\n\n\t\tlogHook := proxyLogHook(cfg)\n\t\tl, err := net.Listen(\"tcp\", \"localhost:0\")\n\t\tr.NoError(err)\n\t\tcfg.Listener = l\n\n\t\tproxy := proxyServer(cfg)\n\t\tremote := httptest.NewTLSServer(h)\n\t\tclient, err := proxyClient(proxy.URL)\n\t\tr.NoError(err)\n\n\t\treq, err := http.NewRequest(\"GET\", remote.URL, nil)\n\t\tr.NoError(err)\n\n\t\tgo func() {\n\t\t\tclient.Do(req)\n\t\t\tclientCh <- true\n\t\t}()\n\n\t\t<-serverCh\n\t\tcount := 0\n\t\tcfg.ConnTracker.Range(func(k, v interface{}) bool {\n\t\t\tcount++\n\t\t\treturn true\n\t\t})\n\t\ta.Equal(1, count, \"connTracker should contain one tracked connection\")\n\n\t\tserverCh <- true\n\t\t<-clientCh\n\n\t\tentry := findCanonicalProxyDecision(logHook.AllEntries())\n\t\tr.NotNil(entry)\n\t\tr.Contains(entry.Data, \"proxy_type\")\n\t\tr.Equal(\"connect\", entry.Data[\"proxy_type\"])\n\t})\n}\n\nfunc TestProxyTimeouts(t *testing.T) {\n\tr := require.New(t)\n\n\th := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\ttime.Sleep(time.Second)\n\t\tw.Write([]byte(\"OK\"))\n\t})\n\n\tt.Run(\"HTTP proxy timeouts\", func(t *testing.T) {\n\t\tcfg, err := testConfig(\"test-local-srv\")\n\t\tr.NoError(err)\n\t\terr = cfg.SetAllowAddresses([]string{\"127.0.0.1\"})\n\t\tr.NoError(err)\n\n\t\tlogHook := proxyLogHook(cfg)\n\t\tcfg.IdleTimeout = 100 * time.Millisecond\n\n\t\tl, err := net.Listen(\"tcp\", \"localhost:0\")\n\t\tr.NoError(err)\n\t\tcfg.Listener = l\n\n\t\tproxy := proxyServer(cfg)\n\t\tremote := httptest.NewServer(h)\n\t\tclient, err := proxyClient(proxy.URL)\n\t\tr.NoError(err)\n\n\t\treq, err := http.NewRequest(\"GET\", remote.URL, nil)\n\t\tr.NoError(err)\n\n\t\tresp, _ := client.Do(req)\n\t\tr.Equal(http.StatusGatewayTimeout, resp.StatusCode)\n\t\tr.NotEqual(\"\", resp.Header.Get(errorHeader))\n\n\t\tentry := findCanonicalProxyDecision(logHook.AllEntries())\n\t\tr.NotNil(entry)\n\n\t\tr.Equal(\"http\", entry.Data[\"proxy_type\"])\n\t\tr.Contains(entry.Data[\"error\"], \"i/o timeout\")\n\t})\n\n\t// This isn't quite correct, as there is some nondeterministic behavior with the way\n\t// CONNECT timeout errors are surfaced back to Smokescreen from Goproxy. We check\n\t// for an EOF returned from HTTP client to indicate a connection interruption\n\t// which in our case represents the timeout.\n\t//\n\t// To correctly hook into this, we'd need to pass a logger from Smokescreen to Goproxy\n\t// which we have hooks into. This would be able to verify the timeout as errors from\n\t// each end of the connection pair are logged by Goproxy.\n\tt.Run(\"CONNECT proxy timeouts\", func(t *testing.T) {\n\t\tcfg, err := testConfig(\"test-local-srv\")\n\t\tr.NoError(err)\n\t\terr = cfg.SetAllowAddresses([]string{\"127.0.0.1\"})\n\t\tr.NoError(err)\n\n\t\tlogHook := proxyLogHook(cfg)\n\t\tcfg.IdleTimeout = 100 * time.Millisecond\n\n\t\tl, err := net.Listen(\"tcp\", \"localhost:0\")\n\t\tr.NoError(err)\n\t\tcfg.Listener = l\n\n\t\tproxy := proxyServer(cfg)\n\t\tremote := httptest.NewTLSServer(h)\n\t\tclient, err := proxyClient(proxy.URL)\n\t\tr.NoError(err)\n\n\t\treq, err := http.NewRequest(\"GET\", remote.URL, nil)\n\t\tr.NoError(err)\n\n\t\tresp, err := client.Do(req)\n\t\tr.Nil(resp)\n\t\tr.Error(err)\n\t\tr.Contains(err.Error(), \"EOF\")\n\n\t\tcfg.ConnTracker.Wg.Wait()\n\n\t\tentry := findCanonicalProxyClose(logHook.AllEntries())\n\t\tr.NotNil(entry)\n\t})\n\n\tt.Run(\"CONNECT proxy dial timeouts\", func(t *testing.T) {\n\t\tcfg, err := testConfig(\"test-local-srv\")\n\t\tr.NoError(err)\n\t\terr = cfg.SetAllowAddresses([]string{\"127.0.0.1\"})\n\t\tr.NoError(err)\n\n\t\tcfg.ConnectTimeout = -1\n\n\t\tl, err := net.Listen(\"tcp\", \"localhost:0\")\n\t\tr.NoError(err)\n\t\tcfg.Listener = l\n\n\t\tproxy := proxyServer(cfg)\n\t\tremote := httptest.NewTLSServer(h)\n\t\tclient, err := proxyClient(proxy.URL)\n\t\tr.NoError(err)\n\n\t\treq, err := http.NewRequest(\"GET\", remote.URL, nil)\n\t\tr.NoError(err)\n\n\t\t// Go swallows the response as the CONNECT tunnel was never established\n\t\tresp, err := client.Do(req)\n\t\tr.Nil(resp)\n\t\tr.Error(err)\n\t\tr.Contains(err.Error(), \"Gateway timeout\")\n\t})\n\n\tt.Run(\"HTTP proxy dial timeouts\", func(t *testing.T) {\n\t\tcfg, err := testConfig(\"test-local-srv\")\n\t\tr.NoError(err)\n\t\terr = cfg.SetAllowAddresses([]string{\"127.0.0.1\"})\n\t\tr.NoError(err)\n\n\t\tcfg.ConnectTimeout = -1\n\n\t\tl, err := net.Listen(\"tcp\", \"localhost:0\")\n\t\tr.NoError(err)\n\t\tcfg.Listener = l\n\n\t\tproxy := proxyServer(cfg)\n\t\tremote := httptest.NewServer(h)\n\t\tclient, err := proxyClient(proxy.URL)\n\t\tr.NoError(err)\n\n\t\treq, err := http.NewRequest(\"GET\", remote.URL, nil)\n\t\tr.NoError(err)\n\n\t\tresp, _ := client.Do(req)\n\t\tr.Equal(http.StatusGatewayTimeout, resp.StatusCode)\n\t\tr.NotEqual(\"\", resp.Header.Get(errorHeader))\n\t})\n}\n\n// TestProxyHalfClosed tests that the proxy and proxy client correctly\n// closes all connections if the proxy target attempts to half-close\n// the TCP connection.\nfunc TestProxyHalfClosed(t *testing.T) {\n\tr := require.New(t)\n\n\th := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\thj, ok := w.(http.Hijacker)\n\t\tif !ok {\n\t\t\tt.Error(\"couldn't hijack conn\")\n\t\t}\n\t\tconn, bufrw, err := hj.Hijack()\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\n\t\ttlsConn, ok := conn.(*tls.Conn)\n\t\tif !ok {\n\t\t\tt.Error(\"conn did not unwrap to tls.Conn\")\n\t\t}\n\n\t\t// Send a response\n\t\tif _, err := io.WriteString(bufrw, \"HTTP/1.1 200 TCP is great!\\r\\n\\r\\n\"); err != nil {\n\t\t\tt.Errorf(\"Error responding to client: %s\", err)\n\t\t}\n\t\tbufrw.Flush()\n\t\ttlsConn.CloseWrite()\n\t})\n\n\tcfg, err := testConfig(\"test-local-srv\")\n\tr.NoError(err)\n\terr = cfg.SetAllowAddresses([]string{\"127.0.0.1\"})\n\tr.NoError(err)\n\n\tlogHook := proxyLogHook(cfg)\n\n\tl, err := net.Listen(\"tcp\", \"localhost:0\")\n\tr.NoError(err)\n\tcfg.Listener = l\n\n\tproxy := proxyServer(cfg)\n\tremote := httptest.NewTLSServer(h)\n\tclient, err := proxyClient(proxy.URL)\n\tr.NoError(err)\n\n\treq, err := http.NewRequest(\"GET\", remote.URL, nil)\n\tr.NoError(err)\n\n\tresp, err := client.Do(req)\n\tr.NoError(err)\n\tresp.Body.Close()\n\tr.Equal(http.StatusOK, resp.StatusCode)\n\n\tcfg.ConnTracker.Wg.Wait()\n\n\tentry := findCanonicalProxyClose(logHook.AllEntries())\n\tr.NotNil(entry)\n}\n\nfunc TestCustomDialTimeout(t *testing.T) {\n\tr := require.New(t)\n\n\th := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\ttime.Sleep(time.Second)\n\t\tw.Write([]byte(\"OK\\n\"))\n\t})\n\n\tt.Run(\"CONNECT proxy custom dial timeouts\", func(t *testing.T) {\n\t\tvar custom = false\n\t\tcfg, err := testConfig(\"test-local-srv\")\n\t\tr.NoError(err)\n\t\terr = cfg.SetAllowAddresses([]string{\"127.0.0.1\"})\n\t\tr.NoError(err)\n\n\t\tcfg.ConnectTimeout = -1\n\n\t\tl, err := net.Listen(\"tcp\", \"localhost:0\")\n\t\tr.NoError(err)\n\t\tcfg.Listener = l\n\t\tcfg.ProxyDialTimeout = func(ctx context.Context, network, address string, timeout time.Duration) (net.Conn, error) {\n\t\t\tcustom = true\n\t\t\treturn net.DialTimeout(network, address, timeout)\n\t\t}\n\n\t\tproxy := proxyServer(cfg)\n\t\tremote := httptest.NewTLSServer(h)\n\t\tclient, err := proxyClient(proxy.URL)\n\t\tr.NoError(err)\n\n\t\treq, err := http.NewRequest(\"GET\", remote.URL, nil)\n\t\tr.NoError(err)\n\n\t\t// Go swallows the response as the CONNECT tunnel was never established\n\t\tresp, err := client.Do(req)\n\t\tr.Nil(resp)\n\t\tr.Error(err)\n\t\tr.Contains(err.Error(), \"Gateway timeout\")\n\t\tr.Equal(custom, true)\n\t})\n\n\tt.Run(\"HTTP proxy custom dial timeouts\", func(t *testing.T) {\n\t\tvar custom = false\n\t\tcfg, err := testConfig(\"test-local-srv\")\n\t\tr.NoError(err)\n\t\terr = cfg.SetAllowAddresses([]string{\"127.0.0.1\"})\n\t\tr.NoError(err)\n\n\t\tcfg.ConnectTimeout = -1\n\n\t\tl, err := net.Listen(\"tcp\", \"localhost:0\")\n\t\tr.NoError(err)\n\t\tcfg.Listener = l\n\n\t\tcfg.ProxyDialTimeout = func(ctx context.Context, network, address string, timeout time.Duration) (net.Conn, error) {\n\t\t\tcustom = true\n\t\t\treturn net.DialTimeout(network, address, timeout)\n\t\t}\n\n\t\tproxy := proxyServer(cfg)\n\t\tremote := httptest.NewServer(h)\n\t\tclient, err := proxyClient(proxy.URL)\n\t\tr.NoError(err)\n\n\t\treq, err := http.NewRequest(\"GET\", remote.URL, nil)\n\t\tr.NoError(err)\n\n\t\tresp, _ := client.Do(req)\n\t\tr.Equal(http.StatusGatewayTimeout, resp.StatusCode)\n\t\tr.NotEqual(\"\", resp.Header.Get(errorHeader))\n\n\t\tr.Equal(custom, true)\n\t})\n}\n\n// Test that Smokescreen calls the custom reject response handler (if defined in the Config struct)\n// after every denied request\nfunc TestRejectResponseHandler(t *testing.T) {\n\tr := require.New(t)\n\ttestHeader := \"TestRejectResponseHandlerHeader\"\n\tt.Run(\"Testing custom reject response handler\", func(t *testing.T) {\n\t\tcfg, err := testConfig(\"test-local-srv\")\n\n\t\t// set a custom RejectResponseHandler that will set a header on every reject response\n\t\tcfg.RejectResponseHandler = func(resp *http.Response) {\n\t\t\tresp.Header.Set(testHeader, \"This header is added by the RejectResponseHandler\")\n\t\t}\n\t\tr.NoError(err)\n\n\t\tproxySrv := proxyServer(cfg)\n\t\tr.NoError(err)\n\t\tdefer proxySrv.Close()\n\n\t\t// Create a http.Client that uses our proxy\n\t\tclient, err := proxyClient(proxySrv.URL)\n\t\tr.NoError(err)\n\n\t\t// Send a request that should be blocked\n\t\tresp, err := client.Get(\"http://127.0.0.1\")\n\t\tr.NoError(err)\n\n\t\t// The RejectResponseHandler should set our custom header\n\t\th := resp.Header.Get(testHeader)\n\t\tif h == \"\" {\n\t\t\tt.Errorf(\"Expecting header %s to be set by RejectResponseHandler\", testHeader)\n\t\t}\n\t\t// Send a request that should be allowed\n\t\tresp, err = client.Get(\"http://example.com\")\n\t\tr.NoError(err)\n\n\t\t// The header set by our custom reject response handler should not be set\n\t\th = resp.Header.Get(testHeader)\n\t\tif h != \"\" {\n\t\t\tt.Errorf(\"Expecting header %s to not be set by RejectResponseHandler\", testHeader)\n\t\t}\n\t})\n}\n\nfunc findCanonicalProxyDecision(logs []*logrus.Entry) *logrus.Entry {\n\tfor _, entry := range logs {\n\t\tif entry.Message == CanonicalProxyDecision {\n\t\t\treturn entry\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc findCanonicalProxyClose(logs []*logrus.Entry) *logrus.Entry {\n\tfor _, entry := range logs {\n\t\tif entry.Message == conntrack.CanonicalProxyConnClose {\n\t\t\treturn entry\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc testConfig(role string) (*Config, error) {\n\tconf := NewConfig()\n\n\tif err := conf.SetAllowRanges(allowRanges); err != nil {\n\t\treturn nil, err\n\t}\n\tconf.ConnectTimeout = 10 * time.Second\n\tconf.ExitTimeout = 10 * time.Second\n\tconf.AdditionalErrorMessageOnDeny = \"Proxy denied\"\n\tconf.Resolver = &net.Resolver{}\n\tconf.SetupEgressAcl(\"testdata/acl.yaml\")\n\tconf.RoleFromRequest = func(req *http.Request) (string, error) {\n\t\treturn role, nil\n\t}\n\n\tmc := NewNoOpMetricsClient()\n\tconf.ConnTracker = conntrack.NewTracker(conf.IdleTimeout, mc.StatsdClient, conf.Log, atomic.Value{})\n\tconf.MetricsClient = mc\n\treturn conf, nil\n}\n\nfunc proxyLogHook(conf *Config) *logrustest.Hook {\n\tvar testHook logrustest.Hook\n\tconf.Log.AddHook(&testHook)\n\treturn &testHook\n}\n\nfunc proxyServer(conf *Config) *httptest.Server {\n\tproxy := BuildProxy(conf)\n\treturn httptest.NewServer(proxy)\n}\n\nfunc proxyClient(proxy string) (*http.Client, error) {\n\tproxyUrl, err := url.Parse(proxy)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tProxy:                 http.ProxyURL(proxyUrl),\n\t\t\tTLSHandshakeTimeout:   10 * time.Second,\n\t\t\tExpectContinueTimeout: 1 * time.Second,\n\t\t\tTLSClientConfig:       &tls.Config{InsecureSkipVerify: true},\n\t\t},\n\t}, nil\n}\n", "---\nversion: v1\nservices:\n  - name: test-trusted-srv\n    project: security\n    action: enforce\n    allowed_domains:\n      - notarealhost.test\n      - httpbin.org\n  - name: test-local-srv\n    project: security\n    action: open\n    allowed_domains:\n      - 127.0.0.1\n  - name: test-open-srv\n    project: security\n    action: open\n\nglobal_deny_list:\n  - stripe.com\n"], "filenames": ["pkg/smokescreen/smokescreen.go", "pkg/smokescreen/smokescreen_test.go", "pkg/smokescreen/testdata/acl.yaml"], "buggy_code_start_loc": [460, 110, 2], "buggy_code_end_loc": [604, 445, 15], "fixing_code_start_loc": [460, 110, 2], "fixing_code_end_loc": [604, 491, 21], "type": "CWE-918", "message": "Smokescreen is an HTTP proxy. The primary use case for Smokescreen is to prevent server-side request forgery (SSRF) attacks in which external attackers leverage the behavior of applications to connect to or scan internal infrastructure. Smokescreen also offers an option to deny access to additional (e.g., external) URLs by way of a deny list. There was an issue in Smokescreen that made it possible to bypass the deny list feature by surrounding the hostname with square brackets (e.g. `[example.com]`). This only impacted the HTTP proxy functionality of Smokescreen. HTTPS requests were not impacted. Smokescreen version 0.0.4 contains a patch for this issue.", "other": {"cve": {"id": "CVE-2022-29188", "sourceIdentifier": "security-advisories@github.com", "published": "2022-05-21T00:15:11.323", "lastModified": "2022-06-07T21:23:46.777", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Smokescreen is an HTTP proxy. The primary use case for Smokescreen is to prevent server-side request forgery (SSRF) attacks in which external attackers leverage the behavior of applications to connect to or scan internal infrastructure. Smokescreen also offers an option to deny access to additional (e.g., external) URLs by way of a deny list. There was an issue in Smokescreen that made it possible to bypass the deny list feature by surrounding the hostname with square brackets (e.g. `[example.com]`). This only impacted the HTTP proxy functionality of Smokescreen. HTTPS requests were not impacted. Smokescreen version 0.0.4 contains a patch for this issue."}, {"lang": "es", "value": "Smokescreen es un proxy HTTP. El principal caso de uso de Smokescreen es evitar los ataques de tipo server-side request forgery (SSRF) en los que atacantes externos aprovechan el comportamiento de las aplicaciones para conectarse o explorar la infraestructura interna. Smokescreen tambi\u00e9n ofrece una opci\u00f3n para denegar el acceso a URLs adicionales (por ejemplo, externas) mediante una lista de denegaci\u00f3n. Se presentaba un problema en Smokescreen que permit\u00eda omitir la funci\u00f3n de lista de denegaci\u00f3n rodeando el nombre de host con corchetes (por ejemplo, \"[ejemplo.com]\"). Esto s\u00f3lo afectaba a la funcionalidad de proxy HTTP de Smokescreen. Las peticiones HTTPS no est\u00e1n afectadas. Smokescreen versi\u00f3n 0.0.4 contiene un parche para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 6.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:stripe:smokescreen:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.0.4", "matchCriteriaId": "94FC7F9A-90E2-4C5A-AF7E-0946DCC695A5"}]}]}], "references": [{"url": "https://github.com/stripe/smokescreen/commit/dea7b3c89df000f4072ff9866d61d78e30df6a36", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/stripe/smokescreen/security/advisories/GHSA-qwrf-gfpj-qvj6", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/stripe/smokescreen/commit/dea7b3c89df000f4072ff9866d61d78e30df6a36"}}