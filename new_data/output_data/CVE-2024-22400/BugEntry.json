{"buggy_code": ["<?php\n/**\n * @copyright Copyright (c) 2016 Lukas Reschke <lukas@statuscode.ch>\n * @copyright Copyright (c) 2018 Jean-Baptiste Pin <jibet.pin@gmail.com>\n *\n * @license GNU AGPL version 3 or any later version\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\nnamespace OCA\\User_SAML\\Controller;\n\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse OC\\Core\\Controller\\ClientFlowLoginController;\nuse OC\\Core\\Controller\\ClientFlowLoginV2Controller;\nuse OC\\Security\\CSRF\\CsrfTokenManager;\nuse OCA\\User_SAML\\Exceptions\\NoUserFoundException;\nuse OCA\\User_SAML\\Exceptions\\UserFilterViolationException;\nuse OCA\\User_SAML\\Helper\\TXmlHelper;\nuse OCA\\User_SAML\\SAMLSettings;\nuse OCA\\User_SAML\\UserBackend;\nuse OCA\\User_SAML\\UserData;\nuse OCA\\User_SAML\\UserResolver;\nuse OCP\\AppFramework\\Controller;\nuse OCP\\AppFramework\\Http;\nuse OCP\\IConfig;\nuse OCP\\IL10N;\nuse OCP\\IRequest;\nuse OCP\\ISession;\nuse OCP\\IURLGenerator;\nuse OCP\\IUserSession;\nuse OCP\\Security\\ICrypto;\nuse OCP\\Server;\nuse OneLogin\\Saml2\\Auth;\nuse OneLogin\\Saml2\\Error;\nuse OneLogin\\Saml2\\Settings;\nuse OneLogin\\Saml2\\ValidationError;\nuse Psr\\Log\\LoggerInterface;\n\nclass SAMLController extends Controller {\n\tuse TXmlHelper;\n\n\t/** @var ISession */\n\tprivate $session;\n\t/** @var IUserSession */\n\tprivate $userSession;\n\t/** @var SAMLSettings */\n\tprivate $samlSettings;\n\t/** @var UserBackend */\n\tprivate $userBackend;\n\t/** @var IConfig */\n\tprivate $config;\n\t/** @var IURLGenerator */\n\tprivate $urlGenerator;\n\t/** @var LoggerInterface */\n\tprivate $logger;\n\t/** @var IL10N */\n\tprivate $l;\n\t/** @var UserResolver */\n\tprivate $userResolver;\n\t/** @var UserData */\n\tprivate $userData;\n\t/**\n\t * @var ICrypto\n\t */\n\tprivate $crypto;\n\n\tpublic function __construct(\n\t\tstring $appName,\n\t\tIRequest $request,\n\t\tISession $session,\n\t\tIUserSession $userSession,\n\t\tSAMLSettings $samlSettings,\n\t\tUserBackend $userBackend,\n\t\tIConfig $config,\n\t\tIURLGenerator $urlGenerator,\n\t\tLoggerInterface $logger,\n\t\tIL10N $l,\n\t\tUserResolver $userResolver,\n\t\tUserData $userData,\n\t\tICrypto $crypto\n\t) {\n\t\tparent::__construct($appName, $request);\n\t\t$this->session = $session;\n\t\t$this->userSession = $userSession;\n\t\t$this->samlSettings = $samlSettings;\n\t\t$this->userBackend = $userBackend;\n\t\t$this->config = $config;\n\t\t$this->urlGenerator = $urlGenerator;\n\t\t$this->logger = $logger;\n\t\t$this->l = $l;\n\t\t$this->userResolver = $userResolver;\n\t\t$this->userData = $userData;\n\t\t$this->crypto = $crypto;\n\t}\n\n\t/**\n\t * @throws NoUserFoundException\n\t * @throws UserFilterViolationException\n\t */\n\tprivate function autoprovisionIfPossible(): void {\n\t\t$auth = $this->userData->getAttributes();\n\n\t\tif (!$this->userData->hasUidMappingAttribute()) {\n\t\t\tthrow new NoUserFoundException('IDP parameter for the UID not found. Possible parameters are: ' . json_encode(array_keys($auth)));\n\t\t}\n\n\t\t$this->assertGroupMemberships();\n\n\t\tif ($this->userData->getOriginalUid() === '') {\n\t\t\t$this->logger->error('Uid is not a valid uid please check your attribute mapping', ['app' => $this->appName]);\n\t\t\tthrow new \\InvalidArgumentException('No valid uid given, please check your attribute mapping.');\n\t\t}\n\t\t$uid = $this->userData->getEffectiveUid();\n\t\t$userExists = $uid !== '';\n\n\t\t// if this server acts as a global scale master and the user is not\n\t\t// a local admin of the server we just create the user and continue\n\t\t// no need to update additional attributes\n\t\t$isGsEnabled = $this->config->getSystemValue('gs.enabled', false);\n\t\t$isGsMaster = $this->config->getSystemValue('gss.mode', 'slave') === 'master';\n\t\t$isGsMasterAdmin = in_array($uid, $this->config->getSystemValue('gss.master.admin', []));\n\t\tif ($isGsEnabled && $isGsMaster && !$isGsMasterAdmin) {\n\t\t\t$this->userBackend->createUserIfNotExists($this->userData->getOriginalUid());\n\t\t\treturn;\n\t\t}\n\t\t$autoProvisioningAllowed = $this->userBackend->autoprovisionAllowed();\n\t\tif ($userExists) {\n\t\t\tif ($autoProvisioningAllowed) {\n\t\t\t\t$this->userBackend->updateAttributes($uid, $auth);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t$uid = $this->userData->getOriginalUid();\n\t\t$uid = $this->userData->testEncodedObjectGUID($uid);\n\t\tif (!$userExists && !$autoProvisioningAllowed) {\n\t\t\tthrow new NoUserFoundException('Auto provisioning not allowed and user ' . $uid . ' does not exist');\n\t\t} elseif (!$userExists && $autoProvisioningAllowed) {\n\t\t\t$this->userBackend->createUserIfNotExists($uid, $auth);\n\t\t\t$this->userBackend->updateAttributes($uid, $auth);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/**\n\t * @throws UserFilterViolationException\n\t */\n\tprotected function assertGroupMemberships(): void {\n\t\tif (!$this->userBackend->autoprovisionAllowed()) {\n\t\t\t// return early, when users are provided by a different backend\n\t\t\t// - mappings are not available/configurable in that case\n\t\t\t// - control is solely based on presence and enabled-state of the user\n\t\t\treturn;\n\t\t}\n\n\t\t$groups = $this->userData->getGroups();\n\t\t$settings = $this->samlSettings->get($this->session->get('user_saml.Idp') ?? 1);\n\n\t\t$rejectGroupsString = $settings['saml-user-filter-reject_groups'] ?? '';\n\t\t$rejectGroups = array_map('trim', explode(',', $rejectGroupsString));\n\n\t\tif (!empty(array_intersect($groups, $rejectGroups))) {\n\t\t\tthrow new UserFilterViolationException('User is member of a rejection group.');\n\t\t}\n\n\t\t$requireGroupsString = trim($settings['saml-user-filter-require_groups'] ?? '');\n\t\t$requireGroups = array_map('trim', explode(',', $requireGroupsString));\n\t\tif (!empty($requireGroupsString) && empty(array_intersect($groups, $requireGroups))) {\n\t\t\tthrow new UserFilterViolationException('User is not member of a required group.');\n\t\t}\n\t}\n\n\t/**\n\t * @PublicPage\n\t * @UseSession\n\t * @OnlyUnauthenticatedUsers\n\t * @NoCSRFRequired\n\t *\n\t * @throws \\Exception\n\t */\n\tpublic function login(int $idp = 1): Http\\RedirectResponse {\n\t\t$type = $this->config->getAppValue($this->appName, 'type');\n\t\tswitch ($type) {\n\t\t\tcase 'saml':\n\t\t\t\t$auth = new Auth($this->samlSettings->getOneLoginSettingsArray($idp));\n\t\t\t\t$returnUrl = $this->request->getParam('originalUrl', $this->urlGenerator->linkToRouteAbsolute('user_saml.SAML.login'));\n\t\t\t\t$ssoUrl = $auth->login($returnUrl, [], false, false, true);\n\t\t\t\t$response = new Http\\RedirectResponse($ssoUrl);\n\n\t\t\t\t// Small hack to make user_saml work with the loginflows\n\t\t\t\t$flowData = [];\n\n\t\t\t\tif ($this->session->get(ClientFlowLoginController::STATE_NAME) !== null) {\n\t\t\t\t\t$flowData['cf1'] = $this->session->get(ClientFlowLoginController::STATE_NAME);\n\t\t\t\t} elseif ($this->session->get(ClientFlowLoginV2Controller::TOKEN_NAME) !== null) {\n\t\t\t\t\t$flowData['cf2'] = [\n\t\t\t\t\t\t'token' => $this->session->get(ClientFlowLoginV2Controller::TOKEN_NAME),\n\t\t\t\t\t\t'state' => $this->session->get(ClientFlowLoginV2Controller::STATE_NAME),\n\t\t\t\t\t];\n\t\t\t\t}\n\n\t\t\t\t// Pack data as JSON so we can properly extract it later\n\t\t\t\t$data = json_encode([\n\t\t\t\t\t'AuthNRequestID' => $auth->getLastRequestID(),\n\t\t\t\t\t'OriginalUrl' => $this->request->getParam('originalUrl', ''),\n\t\t\t\t\t'Idp' => $idp,\n\t\t\t\t\t'flow' => $flowData,\n\t\t\t\t]);\n\n\t\t\t\t// Encrypt it\n\t\t\t\t$data = $this->crypto->encrypt($data);\n\n\t\t\t\t// And base64 encode it\n\t\t\t\t$data = base64_encode($data);\n\n\t\t\t\t$response->addCookie('saml_data', $data, null, 'None');\n\t\t\t\tbreak;\n\t\t\tcase 'environment-variable':\n\t\t\t\t$ssoUrl = $this->request->getParam('originalUrl', '');\n\t\t\t\tif (empty($ssoUrl)) {\n\t\t\t\t\t$ssoUrl = $this->urlGenerator->getAbsoluteURL('/');\n\t\t\t\t}\n\t\t\t\t$this->session->set('user_saml.samlUserData', $_SERVER);\n\t\t\t\ttry {\n\t\t\t\t\t$this->userData->setAttributes($this->session->get('user_saml.samlUserData'));\n\t\t\t\t\t$this->autoprovisionIfPossible();\n\t\t\t\t\t$user = $this->userResolver->findExistingUser($this->userBackend->getCurrentUserId());\n\t\t\t\t\t$user->updateLastLoginTimestamp();\n\t\t\t\t} catch (NoUserFoundException $e) {\n\t\t\t\t\tif ($e->getMessage()) {\n\t\t\t\t\t\t$this->logger->warning('Error while trying to login using sso environment variable: ' . $e->getMessage(), ['app' => 'user_saml']);\n\t\t\t\t\t}\n\t\t\t\t\t$ssoUrl = $this->urlGenerator->linkToRouteAbsolute('user_saml.SAML.notProvisioned');\n\t\t\t\t} catch (UserFilterViolationException $e) {\n\t\t\t\t\t$this->logger->info(\n\t\t\t\t\t\t'SAML filter constraints not met: {msg}',\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\t'app' => 'user_saml',\n\t\t\t\t\t\t\t'msg' => $e->getMessage(),\n\t\t\t\t\t\t]\n\t\t\t\t\t);\n\t\t\t\t\t$ssoUrl = $this->urlGenerator->linkToRouteAbsolute('user_saml.SAML.notPermitted');\n\t\t\t\t}\n\t\t\t\t$response = new Http\\RedirectResponse($ssoUrl);\n\t\t\t\tif (isset($e)) {\n\t\t\t\t\t$this->session->clear();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new \\Exception(\n\t\t\t\t\tsprintf(\n\t\t\t\t\t\t'Type of \"%s\" is not supported for user_saml',\n\t\t\t\t\t\t$type\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t}\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * @PublicPage\n\t * @NoCSRFRequired\n\t * @throws Error\n\t */\n\tpublic function getMetadata(int $idp = 1): Http\\DataDownloadResponse {\n\t\t$settings = new Settings($this->samlSettings->getOneLoginSettingsArray($idp));\n\t\t$metadata = $settings->getSPMetadata();\n\t\t$errors = $this->callWithXmlEntityLoader(function () use ($settings, $metadata) {\n\t\t\treturn $settings->validateMetadata($metadata);\n\t\t});\n\t\tif (empty($errors)) {\n\t\t\treturn new Http\\DataDownloadResponse($metadata, 'metadata.xml', 'text/xml');\n\t\t} else {\n\t\t\tthrow new Error(\n\t\t\t\t'Invalid SP metadata: '.implode(', ', $errors),\n\t\t\t\tError::METADATA_SP_INVALID\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @PublicPage\n\t * @NoCSRFRequired\n\t * @UseSession\n\t * @OnlyUnauthenticatedUsers\n\t * @NoSameSiteCookieRequired\n\t *\n\t * @return Http\\RedirectResponse\n\t * @throws Error\n\t * @throws ValidationError\n\t */\n\tpublic function assertionConsumerService(): Http\\RedirectResponse {\n\t\t// Fetch and decrypt the cookie\n\t\t$cookie = $this->request->getCookie('saml_data');\n\t\tif ($cookie === null) {\n\t\t\t$this->logger->debug('Cookie was not present', ['app' => 'user_saml']);\n\t\t\treturn new Http\\RedirectResponse($this->urlGenerator->getAbsoluteURL('/'));\n\t\t}\n\n\t\t// Base64 decode\n\t\t$cookie = base64_decode($cookie);\n\n\t\t// Decrypt and deserialize\n\t\ttry {\n\t\t\t$cookie = $this->crypto->decrypt($cookie);\n\t\t} catch (\\Exception) {\n\t\t\t$this->logger->debug('Could not decrypt SAML cookie', ['app' => 'user_saml']);\n\t\t\treturn new Http\\RedirectResponse($this->urlGenerator->getAbsoluteURL('/'));\n\t\t}\n\t\t$data = json_decode($cookie, true);\n\n\t\tif (isset($data['flow'])) {\n\t\t\tif (isset($data['flow']['cf1'])) {\n\t\t\t\t$this->session->set(ClientFlowLoginController::STATE_NAME, $data['flow']['cf1']);\n\t\t\t} elseif (isset($data['flow']['cf2'])) {\n\t\t\t\t$this->session->set(ClientFlowLoginV2Controller::TOKEN_NAME, $data['flow']['cf2']['token']);\n\t\t\t\t$this->session->set(ClientFlowLoginV2Controller::STATE_NAME, $data['flow']['cf2']['state']);\n\t\t\t}\n\t\t}\n\n\t\t$AuthNRequestID = $data['AuthNRequestID'];\n\t\t$idp = $data['Idp'];\n\t\t// need to keep the IdP config ID during session lifetime (SAMLSettings::getPrefix)\n\t\t$this->session->set('user_saml.Idp', $idp);\n\t\tif (is_null($AuthNRequestID) || $AuthNRequestID === '' || is_null($idp)) {\n\t\t\t$this->logger->debug('Invalid auth payload', ['app' => 'user_saml']);\n\t\t\treturn new Http\\RedirectResponse($this->urlGenerator->getAbsoluteURL('/'));\n\t\t}\n\n\t\t$auth = new Auth($this->samlSettings->getOneLoginSettingsArray($idp));\n\t\t// validator (called with processResponse()) needs an XML entity loader\n\t\t$this->callWithXmlEntityLoader(function () use ($auth, $AuthNRequestID): void {\n\t\t\t$auth->processResponse($AuthNRequestID);\n\t\t});\n\n\t\t$this->logger->debug('Attributes send by the IDP: ' . json_encode($auth->getAttributes()));\n\n\t\t$errors = $auth->getErrors();\n\n\t\tif (!empty($errors)) {\n\t\t\tforeach ($errors as $error) {\n\t\t\t\t$this->logger->error($error, ['app' => $this->appName]);\n\t\t\t}\n\t\t\t$this->logger->error($auth->getLastErrorReason(), ['app' => $this->appName]);\n\t\t}\n\n\t\tif (!$auth->isAuthenticated()) {\n\t\t\t$this->logger->info('Auth failed', ['app' => $this->appName]);\n\t\t\t$response = new Http\\RedirectResponse($this->urlGenerator->linkToRouteAbsolute('user_saml.SAML.notProvisioned'));\n\t\t\t$response->invalidateCookie('saml_data');\n\t\t\treturn $response;\n\t\t}\n\n\t\t// Check whether the user actually exists, if not redirect to an error page\n\t\t// explaining the issue.\n\t\ttry {\n\t\t\t$this->userData->setAttributes($auth->getAttributes());\n\t\t\t$this->autoprovisionIfPossible();\n\t\t} catch (NoUserFoundException $e) {\n\t\t\t$this->logger->error($e->getMessage(), ['app' => $this->appName]);\n\t\t\t$response = new Http\\RedirectResponse($this->urlGenerator->linkToRouteAbsolute('user_saml.SAML.notProvisioned'));\n\t\t\t$response->invalidateCookie('saml_data');\n\t\t\treturn $response;\n\t\t} catch (UserFilterViolationException $e) {\n\t\t\t$this->logger->error($e->getMessage(), ['app' => $this->appName]);\n\t\t\t$response = new Http\\RedirectResponse($this->urlGenerator->linkToRouteAbsolute('user_saml.SAML.notPermitted'));\n\t\t\t$response->invalidateCookie('saml_data');\n\t\t\treturn $response;\n\t\t}\n\n\t\t$this->session->set('user_saml.samlUserData', $auth->getAttributes());\n\t\t$this->session->set('user_saml.samlNameId', $auth->getNameId());\n\t\t$this->session->set('user_saml.samlNameIdFormat', $auth->getNameIdFormat());\n\t\t$this->session->set('user_saml.samlNameIdNameQualifier', $auth->getNameIdNameQualifier());\n\t\t$this->session->set('user_saml.samlNameIdSPNameQualifier', $auth->getNameIdSPNameQualifier());\n\t\t$this->session->set('user_saml.samlSessionIndex', $auth->getSessionIndex());\n\t\t$this->session->set('user_saml.samlSessionExpiration', $auth->getSessionExpiration());\n\t\ttry {\n\t\t\t$user = $this->userResolver->findExistingUser($this->userBackend->getCurrentUserId());\n\t\t\t$firstLogin = $user->updateLastLoginTimestamp();\n\t\t\tif ($firstLogin) {\n\t\t\t\t$this->userBackend->initializeHomeDir($user->getUID());\n\t\t\t}\n\t\t} catch (NoUserFoundException) {\n\t\t\tthrow new \\InvalidArgumentException('User \"' . $this->userBackend->getCurrentUserId() . '\" is not valid');\n\t\t} catch (\\Exception $e) {\n\t\t\t$this->logger->critical($e->getMessage(), ['exception' => $e, 'app' => $this->appName]);\n\t\t\t$response = new Http\\RedirectResponse($this->urlGenerator->linkToRouteAbsolute('user_saml.SAML.notProvisioned'));\n\t\t\t$response->invalidateCookie('saml_data');\n\t\t\treturn $response;\n\t\t}\n\n\t\t$originalUrl = $data['RelayState'] ?? $data['OriginalUrl'];\n\t\tif ($originalUrl !== null && $originalUrl !== '') {\n\t\t\t$response = new Http\\RedirectResponse($originalUrl);\n\t\t} else {\n\t\t\t$response = new Http\\RedirectResponse($this->urlGenerator->getAbsoluteURL('/'));\n\t\t}\n\t\t// The Nextcloud desktop client expects a cookie with the key of \"_shibsession\"\n\t\t// to be there.\n\t\tif ($this->request->isUserAgent(['/^.*(mirall|csyncoC)\\/.*$/'])) {\n\t\t\t$response->addCookie('_shibsession_', 'authenticated');\n\t\t}\n\n\t\t$response->invalidateCookie('saml_data');\n\t\treturn $response;\n\t}\n\n\t/**\n\t * @PublicPage\n\t * @NoAdminRequired\n\t * @NoCSRFRequired\n\t * @UseSession\n\t * @throws Error\n\t */\n\tpublic function singleLogoutService(): Http\\RedirectResponse {\n\t\t$isFromGS = ($this->config->getSystemValue('gs.enabled', false) &&\n\t\t\t\t\t $this->config->getSystemValue('gss.mode', '') === 'master');\n\n\t\t// Some IDPs send the SLO request via POST, but OneLogin php-saml only handles GET.\n\t\t// To hack around this issue we copy the request from _POST to _GET.\n\t\tif (!empty($_POST['SAMLRequest'])) {\n\t\t\t$_GET['SAMLRequest'] = $_POST['SAMLRequest'];\n\t\t}\n\n\t\t$isFromIDP = !$isFromGS && !empty($_GET['SAMLRequest']);\n\t\t$idp = null;\n\t\tif ($isFromIDP) {\n\t\t\t// requests comes from the IDP so let it manage the logout\n\t\t\t// (or raise Error if request is invalid)\n\t\t\t$pass = true ;\n\t\t} elseif ($isFromGS) {\n\t\t\t// Request is from master GlobalScale\n\t\t\t$jwt = $this->request->getParam('jwt', '');\n\n\t\t\ttry {\n\t\t\t\t$key = $this->config->getSystemValue('gss.jwt.key', '');\n\t\t\t\t$decoded = (array)JWT::decode($jwt, new Key($key, 'HS256'));\n\n\t\t\t\t$idp = $decoded['idp'] ?? null;\n\t\t\t\t$pass = true;\n\t\t\t} catch (\\Exception) {\n\t\t\t}\n\t\t} else {\n\t\t\t// standard request : need read CRSF check\n\t\t\t$pass = $this->request->passesCSRFCheck();\n\t\t}\n\n\t\tif ($pass) {\n\t\t\t$idp = ($idp !== null) ? (int)$idp : $this->session->get('user_saml.Idp');\n\t\t\t$stay = true; // $auth will return the redirect URL but won't perform the redirect himself\n\t\t\tif ($isFromIDP) {\n\t\t\t\t[$targetUrl, $auth] = $this->tryProcessSLOResponse($idp);\n\t\t\t\tif ($auth !== null) {\n\t\t\t\t\t$errors = $auth->getErrors();\n\t\t\t\t\tif (!empty($errors)) {\n\t\t\t\t\t\tforeach ($errors as $error) {\n\t\t\t\t\t\t\t$this->logger->error($error, ['app' => $this->appName]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$this->logger->error($auth->getLastErrorReason(), ['app' => $this->appName]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$this->logger->error('Error while handling SLO request: missing session data, and request is not satisfied by any configuration');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If request is not from IDP, we send the logout request to the IDP\n\t\t\t\t$auth = new Auth($this->samlSettings->getOneLoginSettingsArray($idp ?? 1));\n\t\t\t\t$nameId = $this->session->get('user_saml.samlNameId');\n\t\t\t\t$nameIdFormat = $this->session->get('user_saml.samlNameIdFormat');\n\t\t\t\t$nameIdNameQualifier = $this->session->get('user_saml.samlNameIdNameQualifier');\n\t\t\t\t$nameIdSPNameQualifier = $this->session->get('user_saml.samlNameIdSPNameQualifier');\n\t\t\t\t$sessionIndex = $this->session->get('user_saml.samlSessionIndex');\n\t\t\t\ttry {\n\t\t\t\t\t$targetUrl = $auth->logout(null, [], $nameId, $sessionIndex, $stay, $nameIdFormat, $nameIdNameQualifier, $nameIdSPNameQualifier);\n\t\t\t\t} catch (Error $e) {\n\t\t\t\t\t$this->logger->warning($e->getMessage(), ['exception' => $e, 'app' => $this->appName]);\n\t\t\t\t\t$this->userSession->logout();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!empty($targetUrl) && !$auth->getLastErrorReason()) {\n\t\t\t\t$this->userSession->logout();\n\t\t\t}\n\t\t}\n\t\tif (empty($targetUrl)) {\n\t\t\t$targetUrl = $this->urlGenerator->getAbsoluteURL('/');\n\t\t}\n\n\t\treturn new Http\\RedirectResponse($targetUrl);\n\t}\n\n\t/**\n\t * @returns [?string, ?Auth]\n\t */\n\tprivate function tryProcessSLOResponse(?int $idp): array {\n\t\t$idps = ($idp !== null) ? [$idp] : array_keys($this->samlSettings->getListOfIdps());\n\t\tforeach ($idps as $idp) {\n\t\t\ttry {\n\t\t\t\t$auth = new Auth($this->samlSettings->getOneLoginSettingsArray($idp));\n\t\t\t\t// validator (called with processSLO()) needs an XML entity loader\n\t\t\t\t$targetUrl = $this->callWithXmlEntityLoader(function () use ($auth, $idp): string {\n\t\t\t\t\treturn $auth->processSLO(\n\t\t\t\t\t\ttrue, // do not let processSLO to delete the entire session. Let userSession->logout do the job\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t$this->samlSettings->usesSloWebServerDecode($idp),\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t\tif ($auth->getLastErrorReason() === null) {\n\t\t\t\t\treturn [$targetUrl, $auth];\n\t\t\t\t}\n\t\t\t} catch (Error) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\treturn [null, null];\n\t}\n\n\t/**\n\t * @PublicPage\n\t * @NoCSRFRequired\n\t * @OnlyUnauthenticatedUsers\n\t */\n\tpublic function notProvisioned(): Http\\TemplateResponse {\n\t\treturn new Http\\TemplateResponse($this->appName, 'notProvisioned', [], 'guest');\n\t}\n\n\t/**\n\t * @PublicPage\n\t * @NoCSRFRequired\n\t * @OnlyUnauthenticatedUsers\n\t */\n\tpublic function notPermitted(): Http\\TemplateResponse {\n\t\treturn new Http\\TemplateResponse($this->appName, 'notPermitted', [], 'guest');\n\t}\n\n\t/**\n\t * @PublicPage\n\t * @NoCSRFRequired\n\t * @OnlyUnauthenticatedUsers\n\t */\n\tpublic function genericError(string $message): Http\\TemplateResponse {\n\t\tif (empty($message)) {\n\t\t\t$message = $this->l->t('Unknown error, please check the log file for more details.');\n\t\t}\n\t\treturn new Http\\TemplateResponse($this->appName, 'error', ['message' => $message], 'guest');\n\t}\n\n\t/**\n\t * @PublicPage\n\t * @NoCSRFRequired\n\t * @OnlyUnauthenticatedUsers\n\t */\n\tpublic function selectUserBackEnd(string $redirectUrl): Http\\TemplateResponse {\n\t\t$attributes = ['loginUrls' => []];\n\n\t\tif ($this->samlSettings->allowMultipleUserBackEnds()) {\n\t\t\t$displayName = $this->l->t('Direct log in');\n\n\t\t\t$customDisplayName = $this->config->getAppValue('user_saml', 'directLoginName', '');\n\t\t\tif ($customDisplayName !== '') {\n\t\t\t\t$displayName = $customDisplayName;\n\t\t\t}\n\n\t\t\t$attributes['loginUrls']['directLogin'] = [\n\t\t\t\t'url' => $this->getDirectLoginUrl($redirectUrl),\n\t\t\t\t'display-name' => $displayName,\n\t\t\t];\n\t\t}\n\n\t\t$attributes['loginUrls']['ssoLogin'] = $this->getIdps($redirectUrl);\n\n\t\t$attributes['useCombobox'] = count($attributes['loginUrls']['ssoLogin']) > 4;\n\n\n\t\treturn new Http\\TemplateResponse($this->appName, 'selectUserBackEnd', $attributes, 'guest');\n\t}\n\n\t/**\n\t * get the IdPs showed at the login page\n\t */\n\tprivate function getIdps(string $redirectUrl): array {\n\t\t$result = [];\n\t\t$idps = $this->samlSettings->getListOfIdps();\n\t\tforeach ($idps as $idpId => $displayName) {\n\t\t\t$result[] = [\n\t\t\t\t'url' => $this->getSSOUrl($redirectUrl, (string)$idpId),\n\t\t\t\t'display-name' => $this->getSSODisplayName($displayName),\n\t\t\t];\n\t\t}\n\n\t\treturn $result;\n\t}\n\n\tprivate function getSSOUrl(string $redirectUrl, string $idp): string {\n\t\t$originalUrl = '';\n\t\tif (!empty($redirectUrl)) {\n\t\t\t$originalUrl = $this->urlGenerator->getAbsoluteURL($redirectUrl);\n\t\t}\n\n\t\t/** @var CsrfTokenManager $csrfTokenManager */\n\t\t$csrfTokenManager = Server::get(CsrfTokenManager::class);\n\t\t$csrfToken = $csrfTokenManager->getToken();\n\t\t$ssoUrl = $this->urlGenerator->linkToRouteAbsolute(\n\t\t\t'user_saml.SAML.login',\n\t\t\t[\n\t\t\t\t'requesttoken' => $csrfToken->getEncryptedValue(),\n\t\t\t\t'originalUrl' => $originalUrl,\n\t\t\t\t'idp' => $idp\n\t\t\t]\n\t\t);\n\n\t\treturn $ssoUrl;\n\t}\n\n\t/**\n\t * return the display name of the SSO identity provider\n\t */\n\tprotected function getSSODisplayName(?string $displayName): string {\n\t\tif (empty($displayName)) {\n\t\t\t$displayName = $this->l->t('SSO & SAML log in');\n\t\t}\n\n\t\treturn $displayName;\n\t}\n\n\t/**\n\t * get Nextcloud login URL\n\t */\n\tprivate function getDirectLoginUrl(string $redirectUrl): string {\n\t\t$directUrl = $this->urlGenerator->linkToRouteAbsolute('core.login.tryLogin', [\n\t\t\t'direct' => '1',\n\t\t\t'redirect_url' => $redirectUrl,\n\t\t]);\n\t\treturn $directUrl;\n\t}\n\n\t/**\n\t * @PublicPage\n\t * @NoCSRFRequired\n\t */\n\tpublic function base(): Http\\TemplateResponse {\n\t\t$message = $this->l->t('This page should not be visited directly.');\n\t\treturn new Http\\TemplateResponse($this->appName, 'error', ['message' => $message], 'guest');\n\t}\n}\n", "<?php\n/**\n * @copyright Copyright (c) 2016 Lukas Reschke <lukas@statuscode.ch>\n *\n * @license GNU AGPL version 3 or any later version\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\nnamespace OCA\\User_SAML\\Tests\\Controller;\n\nuse Exception;\nuse OCA\\User_SAML\\Controller\\SAMLController;\nuse OCA\\User_SAML\\Exceptions\\NoUserFoundException;\nuse OCA\\User_SAML\\Exceptions\\UserFilterViolationException;\nuse OCA\\User_SAML\\SAMLSettings;\nuse OCA\\User_SAML\\UserBackend;\nuse OCA\\User_SAML\\UserData;\nuse OCA\\User_SAML\\UserResolver;\nuse OCP\\AppFramework\\Http\\RedirectResponse;\nuse OCP\\AppFramework\\Http\\TemplateResponse;\nuse OCP\\IConfig;\nuse OCP\\IL10N;\nuse OCP\\IRequest;\nuse OCP\\ISession;\nuse OCP\\IURLGenerator;\nuse OCP\\IUser;\nuse OCP\\IUserSession;\nuse OCP\\Security\\ICrypto;\nuse PHPUnit\\Framework\\MockObject\\MockObject;\nuse Psr\\Log\\LoggerInterface;\nuse Test\\TestCase;\n\nclass SAMLControllerTest extends TestCase {\n\t/** @var UserResolver|\\PHPUnit\\Framework\\MockObject\\MockObject */\n\tprotected $userResolver;\n\t/** @var UserData|\\PHPUnit\\Framework\\MockObject\\MockObject */\n\tprivate $userData;\n\t/** @var IRequest|\\PHPUnit_Framework_MockObject_MockObject */\n\tprivate $request;\n\t/** @var ISession|\\PHPUnit_Framework_MockObject_MockObject */\n\tprivate $session;\n\t/** @var IUserSession|\\PHPUnit_Framework_MockObject_MockObject */\n\tprivate $userSession;\n\t/** @var SAMLSettings|\\PHPUnit_Framework_MockObject_MockObject*/\n\tprivate $samlSettings;\n\t/** @var UserBackend|\\PHPUnit_Framework_MockObject_MockObject */\n\tprivate $userBackend;\n\t/** @var IConfig|\\PHPUnit_Framework_MockObject_MockObject */\n\tprivate $config;\n\t/** @var IURLGenerator|\\PHPUnit_Framework_MockObject_MockObject */\n\tprivate $urlGenerator;\n\t/** @var LoggerInterface|\\PHPUnit_Framework_MockObject_MockObject */\n\tprivate $logger;\n\t/** @var IL10N|\\PHPUnit_Framework_MockObject_MockObject */\n\tprivate $l;\n\t/** @var ICrypto|MockObject */\n\tprivate $crypto;\n\t/** @var SAMLController */\n\tprivate $samlController;\n\n\tprotected function setUp(): void {\n\t\tparent::setUp();\n\n\t\t$this->request = $this->createMock(IRequest::class);\n\t\t$this->session = $this->createMock(ISession::class);\n\t\t$this->userSession = $this->createMock(IUserSession::class);\n\t\t$this->samlSettings = $this->createMock(SAMLSettings::class);\n\t\t$this->userBackend = $this->createMock(UserBackend::class);\n\t\t$this->config = $this->createMock(IConfig::class);\n\t\t$this->urlGenerator = $this->createMock(IURLGenerator::class);\n\t\t$this->logger = $this->createMock(LoggerInterface::class);\n\t\t$this->l = $this->createMock(IL10N::class);\n\t\t$this->userResolver = $this->createMock(UserResolver::class);\n\t\t$this->userData = $this->createMock(UserData::class);\n\t\t$this->crypto = $this->createMock(ICrypto::class);\n\n\t\t$this->l->expects($this->any())->method('t')->willReturnCallback(\n\t\t\tfunction ($param) {\n\t\t\t\treturn $param;\n\t\t\t}\n\t\t);\n\n\t\t$this->config->expects($this->any())->method('getSystemValue')\n\t\t\t->willReturnCallback(function ($key, $default) {\n\t\t\t\treturn $default;\n\t\t\t});\n\n\t\t$this->samlController = new SAMLController(\n\t\t\t'user_saml',\n\t\t\t$this->request,\n\t\t\t$this->session,\n\t\t\t$this->userSession,\n\t\t\t$this->samlSettings,\n\t\t\t$this->userBackend,\n\t\t\t$this->config,\n\t\t\t$this->urlGenerator,\n\t\t\t$this->logger,\n\t\t\t$this->l,\n\t\t\t$this->userResolver,\n\t\t\t$this->userData,\n\t\t\t$this->crypto\n\t\t);\n\t}\n\n\tpublic function testLoginWithInvalidAppValue() {\n\t\t$this->config\n\t\t\t->expects($this->once())\n\t\t\t->method('getAppValue')\n\t\t\t->with('user_saml', 'type')\n\t\t\t->willReturn('UnknownValue');\n\n\t\t$this->expectException(Exception::class);\n\t\t$this->expectExceptionMessage('Type of \"UnknownValue\" is not supported for user_saml');\n\n\t\t$this->samlController->login(1);\n\t}\n\n\tpublic function samlUserDataProvider() {\n\t\t$userNotExisting = 0;\n\t\t$userExisting = 1;\n\t\t$userLazyExisting = 2;\n\n\t\t$apDisabled = 0;\n\t\t$apEnabled = 1;\n\t\t$apEnabledUnsuccessful = 2;\n\n\t\treturn  [\n\t\t\t[ # 0 - Not existing uid in settings array\n\t\t\t\t[\n\t\t\t\t\t'foo' => 'bar',\n\t\t\t\t\t'bar' => 'foo',\n\t\t\t\t],\n\t\t\t\t'https://nextcloud.com/notProvisioned/',\n\t\t\t\t$userNotExisting,\n\t\t\t\t$apDisabled\n\t\t\t],\n\t\t\t[ # 1 - existing user\n\t\t\t\t[\n\t\t\t\t\t'foo' => 'bar',\n\t\t\t\t\t'bar' => 'foo',\n\t\t\t\t\t'uid' => 'MyUid',\n\t\t\t\t],\n\t\t\t\t'https://nextcloud.com/absolute/',\n\t\t\t\t$userExisting,\n\t\t\t\t$apDisabled\n\t\t\t],\n\t\t\t[ # 2 - existing user and uid attribute in array\n\t\t\t\t[\n\t\t\t\t\t'foo' => 'bar',\n\t\t\t\t\t'bar' => 'foo',\n\t\t\t\t\t'uid' => ['MyUid'],\n\t\t\t\t],\n\t\t\t\t'https://nextcloud.com/absolute/',\n\t\t\t\t$userExisting,\n\t\t\t\t$apDisabled\n\t\t\t],\n\t\t\t[ # 3 - Not existing user with provisioning\n\t\t\t\t[\n\t\t\t\t\t'foo' => 'bar',\n\t\t\t\t\t'bar' => 'foo',\n\t\t\t\t\t'uid' => 'MyUid',\n\t\t\t\t],\n\t\t\t\t'https://nextcloud.com/absolute/',\n\t\t\t\t$userNotExisting,\n\t\t\t\t$apEnabled\n\t\t\t],\n\t\t\t[ # 4 - Not existing user with malfunctioning backend\n\t\t\t\t[\n\t\t\t\t\t'foo' => 'bar',\n\t\t\t\t\t'bar' => 'foo',\n\t\t\t\t\t'uid' => 'MyUid',\n\t\t\t\t],\n\t\t\t\t'https://nextcloud.com/notProvisioned/',\n\t\t\t\t$userNotExisting,\n\t\t\t\t$apEnabledUnsuccessful\n\t\t\t],\n\t\t\t[ # 5 - Not existing user without provisioning\n\t\t\t\t[\n\t\t\t\t\t'foo' => 'bar',\n\t\t\t\t\t'bar' => 'foo',\n\t\t\t\t\t'uid' => 'MyUid',\n\t\t\t\t],\n\t\t\t\t'https://nextcloud.com/notProvisioned/',\n\t\t\t\t$userNotExisting,\n\t\t\t\t$apDisabled\n\t\t\t],\n\t\t\t[ # 6 - Not yet mapped user without provisioning\n\t\t\t\t[\n\t\t\t\t\t'foo' => 'bar',\n\t\t\t\t\t'bar' => 'foo',\n\t\t\t\t\t'uid' => 'MyUid',\n\t\t\t\t],\n\t\t\t\t'https://nextcloud.com/absolute/',\n\t\t\t\t$userLazyExisting,\n\t\t\t\t$apDisabled\n\t\t\t],\n\t\t];\n\t}\n\n\t/**\n\t * @dataProvider samlUserDataProvider\n\t */\n\tpublic function testLoginWithEnvVariable(array $samlUserData, string $redirect, int $userState, int $autoProvision) {\n\t\t$this->config->expects($this->any())\n\t\t\t->method('getAppValue')\n\t\t\t->willReturnCallback(function (string $app, string $key) {\n\t\t\t\tif ($app === 'user_saml') {\n\t\t\t\t\tif ($key === 'type') {\n\t\t\t\t\t\treturn 'environment-variable';\n\t\t\t\t\t}\n\t\t\t\t\tif ($key === 'general-uid_mapping') {\n\t\t\t\t\t\treturn 'uid';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t});\n\n\t\t$this->session\n\t\t\t->expects($this->any())\n\t\t\t->method('get')\n\t\t\t->willReturnCallback(function (string $key) use ($samlUserData) {\n\t\t\t\tswitch ($key) {\n\t\t\t\t\tcase 'user_saml.samlUserData':\n\t\t\t\t\t\treturn $samlUserData;\n\t\t\t\t\tcase 'user_saml.Idp':\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t});\n\n\t\t$this->userData\n\t\t\t->expects($this->once())\n\t\t\t->method('setAttributes')\n\t\t\t->with($samlUserData);\n\t\t$this->userData\n\t\t\t->expects($this->any())\n\t\t\t->method('getAttributes')\n\t\t\t->willReturn($samlUserData);\n\t\t$this->userData\n\t\t\t->expects($this->any())\n\t\t\t->method('hasUidMappingAttribute')\n\t\t\t->willReturn(isset($samlUserData['uid']));\n\t\t$this->userData\n\t\t\t->expects(isset($samlUserData['uid']) ? $this->any() : $this->never())\n\t\t\t->method('getOriginalUid')\n\t\t\t->willReturn('MyUid');\n\t\t$this->userData\n\t\t\t->expects($this->any())\n\t\t\t->method('testEncodedObjectGUID')\n\t\t\t->willReturnCallback(function ($uid) {\n\t\t\t\treturn $uid;\n\t\t\t});\n\t\t$this->userData\n\t\t\t->expects($this->any())\n\t\t\t->method('getEffectiveUid')\n\t\t\t->willReturn($userState > 0 ? 'MyUid' : '');\n\n\t\tif (strpos($redirect, 'notProvisioned') !== false) {\n\t\t\t$this->urlGenerator\n\t\t\t\t->expects($this->once())\n\t\t\t\t->method('linkToRouteAbsolute')\n\t\t\t\t->with('user_saml.SAML.notProvisioned')\n\t\t\t\t->willReturn($redirect);\n\t\t} else {\n\t\t\t$this->urlGenerator\n\t\t\t\t->expects($this->once())\n\t\t\t\t->method('getAbsoluteURL')\n\t\t\t\t->willReturn($redirect);\n\t\t}\n\n\t\t$this->userResolver\n\t\t\t->expects($this->any())\n\t\t\t->method('userExists')\n\t\t\t->with('MyUid')\n\t\t\t->willReturn($userState === 1);\n\n\t\tif (isset($samlUserData['uid']) && !($userState === 0 && $autoProvision === 0)) {\n\t\t\t/** @var IUser|MockObject $user */\n\t\t\t$user = $this->createMock(IUser::class);\n\t\t\t$im = $this->userResolver\n\t\t\t\t->expects($this->once())\n\t\t\t\t->method('findExistingUser')\n\t\t\t\t->with('MyUid');\n\t\t\tif ($autoProvision < 2) {\n\t\t\t\t$im->willReturn($user);\n\t\t\t} else {\n\t\t\t\t$im->willThrowException(new NoUserFoundException());\n\t\t\t}\n\n\t\t\t$user\n\t\t\t\t->expects($this->exactly((int)($autoProvision < 2)))\n\t\t\t\t->method('updateLastLoginTimestamp');\n\n\t\t\tif ($userState === 0) {\n\t\t\t\t$this->userResolver\n\t\t\t\t\t->expects($this->any())\n\t\t\t\t\t->method('findExistingUserId')\n\t\t\t\t\t->with('MyUid', true)\n\t\t\t\t\t->willThrowException(new NoUserFoundException());\n\t\t\t} elseif ($userState === 2) {\n\t\t\t\t$this->userResolver\n\t\t\t\t\t->expects($this->any())\n\t\t\t\t\t->method('findExistingUserId')\n\t\t\t\t\t->with('MyUid', true)\n\t\t\t\t\t->willReturn('MyUid');\n\t\t\t}\n\t\t}\n\t\t$this->userBackend\n\t\t\t->expects($this->any())\n\t\t\t->method('getCurrentUserId')\n\t\t\t->willReturn(isset($samlUserData['uid']) ? 'MyUid' : '');\n\t\t$this->userBackend\n\t\t\t->expects($this->any())\n\t\t\t->method('autoprovisionAllowed')\n\t\t\t->willReturn($autoProvision > 0);\n\t\t$this->userBackend\n\t\t\t->expects($this->exactly(min(1, $autoProvision)))\n\t\t\t->method('createUserIfNotExists')\n\t\t\t->with('MyUid');\n\n\t\t$expected = new RedirectResponse($redirect);\n\t\t$result = $this->samlController->login(1);\n\t\t$this->assertEquals($expected, $result);\n\t}\n\n\tpublic function testNotPermitted() {\n\t\t$expected = new TemplateResponse('user_saml', 'notPermitted', [], 'guest');\n\t\t$this->assertEquals($expected, $this->samlController->notPermitted());\n\t}\n\n\tpublic function testNotProvisioned() {\n\t\t$expected = new TemplateResponse('user_saml', 'notProvisioned', [], 'guest');\n\t\t$this->assertEquals($expected, $this->samlController->notProvisioned());\n\t}\n\n\t/**\n\t * @dataProvider dataTestGenericError\n\t *\n\t * @param string $messageSend\n\t * @param string $messageExpected\n\t */\n\tpublic function testGenericError($messageSend, $messageExpected) {\n\t\t$expected = new TemplateResponse('user_saml', 'error', ['message' => $messageExpected], 'guest');\n\t\t$this->assertEquals($expected, $this->samlController->genericError($messageSend));\n\t}\n\n\tpublic function dataTestGenericError() {\n\t\treturn [\n\t\t\t['messageSend' => '', 'messageExpected' => 'Unknown error, please check the log file for more details.'],\n\t\t\t['messageSend' => 'test message', 'messageExpected' => 'test message'],\n\t\t];\n\t}\n\n\t/**\n\t * @dataProvider dataTestGetSSODisplayName\n\t *\n\t * @param string $configuredDisplayName\n\t * @param string $expected\n\t */\n\tpublic function testGetSSODisplayName($configuredDisplayName, $expected) {\n\t\t$result = $this->invokePrivate($this->samlController, 'getSSODisplayName', [$configuredDisplayName]);\n\n\t\t$this->assertSame($expected, $result);\n\t}\n\n\tpublic function dataTestGetSSODisplayName() {\n\t\treturn [\n\t\t\t['My identity provider', 'My identity provider'],\n\t\t\t['', 'SSO & SAML log in']\n\t\t];\n\t}\n\n\tpublic function userFilterDataProvider(): array {\n\t\treturn [\n\t\t\t[ // 0 - test rejection by membership\n\t\t\t\t'Group C',\n\t\t\t\t'Group A, Group B',\n\t\t\t\ttrue,\n\t\t\t\t'User is member of a rejection group.',\n\t\t\t],\n\t\t\t[ // 1 - test rejection by required membership\n\t\t\t\t'Group D',\n\t\t\t\t'Group B',\n\t\t\t\ttrue,\n\t\t\t\t'User is not member of a required group.',\n\t\t\t],\n\t\t\t[ // 2 - test satisfy all requirements\n\t\t\t\t'Group D',\n\t\t\t\t'Group A',\n\t\t\t\tfalse,\n\t\t\t],\n\t\t\t[ // 3 - test no filtering\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tfalse,\n\t\t\t],\n\t\t];\n\t}\n\n\t/**\n\t * @dataProvider userFilterDataProvider\n\t */\n\tpublic function testUserFilter(?string $rejectGroups, ?string $requireGroups, bool $isException, string $message = ''): void {\n\t\t$this->userData->expects($this->any())\n\t\t\t->method('getGroups')\n\t\t\t->willReturn(['Group A', 'Group C']);\n\n\t\t$this->session->expects($this->any())\n\t\t\t->method('get')\n\t\t\t->with('user_saml.Idp')\n\t\t\t->willReturn(1);\n\n\t\t$settings = [];\n\t\tif ($rejectGroups !== null && $requireGroups !== null) {\n\t\t\t$settings = [\n\t\t\t\t'saml-user-filter-reject_groups' => $rejectGroups,\n\t\t\t\t'saml-user-filter-require_groups' => $requireGroups,\n\t\t\t];\n\t\t}\n\t\t$this->samlSettings->expects($this->any())\n\t\t\t->method('get')\n\t\t\t->with(1)\n\t\t\t->willReturn($settings);\n\n\t\t$this->userBackend->expects($this->any())\n\t\t\t->method('autoprovisionAllowed')\n\t\t\t->willReturn(true);\n\n\t\tif ($isException) {\n\t\t\t$this->expectException(UserFilterViolationException::class);\n\t\t\t$this->expectExceptionMessage($message);\n\t\t} else {\n\t\t\t// Nothing to assert other than no exception being thrown\n\t\t\t$this->assertTrue(true);\n\t\t}\n\n\t\t$this->invokePrivate($this->samlController, 'assertGroupMemberships');\n\t}\n\n\tpublic function testUserFilterNotApplicable(): void {\n\t\t$this->userData->expects($this->never())\n\t\t\t->method('getGroups');\n\n\t\t$this->session->expects($this->never())\n\t\t\t->method('get');\n\n\t\t$this->userBackend->expects($this->any())\n\t\t\t->method('autoprovisionAllowed')\n\t\t\t->willReturn(false);\n\n\t\t$this->invokePrivate($this->samlController, 'assertGroupMemberships');\n\t}\n}\n"], "fixing_code": ["<?php\n/**\n * @copyright Copyright (c) 2016 Lukas Reschke <lukas@statuscode.ch>\n * @copyright Copyright (c) 2018 Jean-Baptiste Pin <jibet.pin@gmail.com>\n *\n * @license GNU AGPL version 3 or any later version\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\nnamespace OCA\\User_SAML\\Controller;\n\nuse Firebase\\JWT\\JWT;\nuse Firebase\\JWT\\Key;\nuse OC\\Core\\Controller\\ClientFlowLoginController;\nuse OC\\Core\\Controller\\ClientFlowLoginV2Controller;\nuse OC\\Security\\CSRF\\CsrfTokenManager;\nuse OCA\\User_SAML\\Exceptions\\NoUserFoundException;\nuse OCA\\User_SAML\\Exceptions\\UserFilterViolationException;\nuse OCA\\User_SAML\\Helper\\TXmlHelper;\nuse OCA\\User_SAML\\SAMLSettings;\nuse OCA\\User_SAML\\UserBackend;\nuse OCA\\User_SAML\\UserData;\nuse OCA\\User_SAML\\UserResolver;\nuse OCP\\AppFramework\\Controller;\nuse OCP\\AppFramework\\Http;\nuse OCP\\IConfig;\nuse OCP\\IL10N;\nuse OCP\\IRequest;\nuse OCP\\ISession;\nuse OCP\\IURLGenerator;\nuse OCP\\IUserSession;\nuse OCP\\Security\\ICrypto;\nuse OCP\\Security\\ITrustedDomainHelper;\nuse OCP\\Server;\nuse OneLogin\\Saml2\\Auth;\nuse OneLogin\\Saml2\\Error;\nuse OneLogin\\Saml2\\Settings;\nuse OneLogin\\Saml2\\ValidationError;\nuse Psr\\Log\\LoggerInterface;\n\nclass SAMLController extends Controller {\n\tuse TXmlHelper;\n\n\t/** @var ISession */\n\tprivate $session;\n\t/** @var IUserSession */\n\tprivate $userSession;\n\t/** @var SAMLSettings */\n\tprivate $samlSettings;\n\t/** @var UserBackend */\n\tprivate $userBackend;\n\t/** @var IConfig */\n\tprivate $config;\n\t/** @var IURLGenerator */\n\tprivate $urlGenerator;\n\t/** @var LoggerInterface */\n\tprivate $logger;\n\t/** @var IL10N */\n\tprivate $l;\n\t/** @var UserResolver */\n\tprivate $userResolver;\n\t/** @var UserData */\n\tprivate $userData;\n\t/**\n\t * @var ICrypto\n\t */\n\tprivate $crypto;\n\tprivate ITrustedDomainHelper $trustedDomainHelper;\n\n\tpublic function __construct(\n\t\tstring $appName,\n\t\tIRequest $request,\n\t\tISession $session,\n\t\tIUserSession $userSession,\n\t\tSAMLSettings $samlSettings,\n\t\tUserBackend $userBackend,\n\t\tIConfig $config,\n\t\tIURLGenerator $urlGenerator,\n\t\tLoggerInterface $logger,\n\t\tIL10N $l,\n\t\tUserResolver $userResolver,\n\t\tUserData $userData,\n\t\tICrypto $crypto,\n\t\tITrustedDomainHelper $trustedDomainHelper\n\t) {\n\t\tparent::__construct($appName, $request);\n\t\t$this->session = $session;\n\t\t$this->userSession = $userSession;\n\t\t$this->samlSettings = $samlSettings;\n\t\t$this->userBackend = $userBackend;\n\t\t$this->config = $config;\n\t\t$this->urlGenerator = $urlGenerator;\n\t\t$this->logger = $logger;\n\t\t$this->l = $l;\n\t\t$this->userResolver = $userResolver;\n\t\t$this->userData = $userData;\n\t\t$this->crypto = $crypto;\n\t\t$this->trustedDomainHelper = $trustedDomainHelper;\n\t}\n\n\t/**\n\t * @throws NoUserFoundException\n\t * @throws UserFilterViolationException\n\t */\n\tprivate function autoprovisionIfPossible(): void {\n\t\t$auth = $this->userData->getAttributes();\n\n\t\tif (!$this->userData->hasUidMappingAttribute()) {\n\t\t\tthrow new NoUserFoundException('IDP parameter for the UID not found. Possible parameters are: ' . json_encode(array_keys($auth)));\n\t\t}\n\n\t\t$this->assertGroupMemberships();\n\n\t\tif ($this->userData->getOriginalUid() === '') {\n\t\t\t$this->logger->error('Uid is not a valid uid please check your attribute mapping', ['app' => $this->appName]);\n\t\t\tthrow new \\InvalidArgumentException('No valid uid given, please check your attribute mapping.');\n\t\t}\n\t\t$uid = $this->userData->getEffectiveUid();\n\t\t$userExists = $uid !== '';\n\n\t\t// if this server acts as a global scale master and the user is not\n\t\t// a local admin of the server we just create the user and continue\n\t\t// no need to update additional attributes\n\t\t$isGsEnabled = $this->config->getSystemValue('gs.enabled', false);\n\t\t$isGsMaster = $this->config->getSystemValue('gss.mode', 'slave') === 'master';\n\t\t$isGsMasterAdmin = in_array($uid, $this->config->getSystemValue('gss.master.admin', []));\n\t\tif ($isGsEnabled && $isGsMaster && !$isGsMasterAdmin) {\n\t\t\t$this->userBackend->createUserIfNotExists($this->userData->getOriginalUid());\n\t\t\treturn;\n\t\t}\n\t\t$autoProvisioningAllowed = $this->userBackend->autoprovisionAllowed();\n\t\tif ($userExists) {\n\t\t\tif ($autoProvisioningAllowed) {\n\t\t\t\t$this->userBackend->updateAttributes($uid, $auth);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t$uid = $this->userData->getOriginalUid();\n\t\t$uid = $this->userData->testEncodedObjectGUID($uid);\n\t\tif (!$userExists && !$autoProvisioningAllowed) {\n\t\t\tthrow new NoUserFoundException('Auto provisioning not allowed and user ' . $uid . ' does not exist');\n\t\t} elseif (!$userExists && $autoProvisioningAllowed) {\n\t\t\t$this->userBackend->createUserIfNotExists($uid, $auth);\n\t\t\t$this->userBackend->updateAttributes($uid, $auth);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/**\n\t * @throws UserFilterViolationException\n\t */\n\tprotected function assertGroupMemberships(): void {\n\t\tif (!$this->userBackend->autoprovisionAllowed()) {\n\t\t\t// return early, when users are provided by a different backend\n\t\t\t// - mappings are not available/configurable in that case\n\t\t\t// - control is solely based on presence and enabled-state of the user\n\t\t\treturn;\n\t\t}\n\n\t\t$groups = $this->userData->getGroups();\n\t\t$settings = $this->samlSettings->get($this->session->get('user_saml.Idp') ?? 1);\n\n\t\t$rejectGroupsString = $settings['saml-user-filter-reject_groups'] ?? '';\n\t\t$rejectGroups = array_map('trim', explode(',', $rejectGroupsString));\n\n\t\tif (!empty(array_intersect($groups, $rejectGroups))) {\n\t\t\tthrow new UserFilterViolationException('User is member of a rejection group.');\n\t\t}\n\n\t\t$requireGroupsString = trim($settings['saml-user-filter-require_groups'] ?? '');\n\t\t$requireGroups = array_map('trim', explode(',', $requireGroupsString));\n\t\tif (!empty($requireGroupsString) && empty(array_intersect($groups, $requireGroups))) {\n\t\t\tthrow new UserFilterViolationException('User is not member of a required group.');\n\t\t}\n\t}\n\n\t/**\n\t * @PublicPage\n\t * @UseSession\n\t * @OnlyUnauthenticatedUsers\n\t * @NoCSRFRequired\n\t *\n\t * @throws \\Exception\n\t */\n\tpublic function login(int $idp = 1): Http\\RedirectResponse {\n\t\t$originalUrl = (string)$this->request->getParam('originalUrl', '');\n\t\tif (!$this->trustedDomainHelper->isTrustedUrl($originalUrl)) {\n\t\t\t$originalUrl = '';\n\t\t}\n\n\t\t$type = $this->config->getAppValue($this->appName, 'type');\n\t\tswitch ($type) {\n\t\t\tcase 'saml':\n\t\t\t\t$auth = new Auth($this->samlSettings->getOneLoginSettingsArray($idp));\n\n\t\t\t\t$returnUrl = $originalUrl ?: $this->urlGenerator->linkToRouteAbsolute('user_saml.SAML.login');\n\t\t\t\t$ssoUrl = $auth->login($returnUrl, [], false, false, true);\n\t\t\t\t$response = new Http\\RedirectResponse($ssoUrl);\n\n\t\t\t\t// Small hack to make user_saml work with the loginflows\n\t\t\t\t$flowData = [];\n\n\t\t\t\tif ($this->session->get(ClientFlowLoginController::STATE_NAME) !== null) {\n\t\t\t\t\t$flowData['cf1'] = $this->session->get(ClientFlowLoginController::STATE_NAME);\n\t\t\t\t} elseif ($this->session->get(ClientFlowLoginV2Controller::TOKEN_NAME) !== null) {\n\t\t\t\t\t$flowData['cf2'] = [\n\t\t\t\t\t\t'token' => $this->session->get(ClientFlowLoginV2Controller::TOKEN_NAME),\n\t\t\t\t\t\t'state' => $this->session->get(ClientFlowLoginV2Controller::STATE_NAME),\n\t\t\t\t\t];\n\t\t\t\t}\n\n\t\t\t\t// Pack data as JSON so we can properly extract it later\n\t\t\t\t$data = json_encode([\n\t\t\t\t\t'AuthNRequestID' => $auth->getLastRequestID(),\n\t\t\t\t\t'OriginalUrl' => $originalUrl,\n\t\t\t\t\t'Idp' => $idp,\n\t\t\t\t\t'flow' => $flowData,\n\t\t\t\t]);\n\n\t\t\t\t// Encrypt it\n\t\t\t\t$data = $this->crypto->encrypt($data);\n\n\t\t\t\t// And base64 encode it\n\t\t\t\t$data = base64_encode($data);\n\n\t\t\t\t$response->addCookie('saml_data', $data, null, 'None');\n\t\t\t\tbreak;\n\t\t\tcase 'environment-variable':\n\t\t\t\t$ssoUrl = $originalUrl;\n\t\t\t\tif (empty($ssoUrl)) {\n\t\t\t\t\t$ssoUrl = $this->urlGenerator->getAbsoluteURL('/');\n\t\t\t\t}\n\t\t\t\t$this->session->set('user_saml.samlUserData', $_SERVER);\n\t\t\t\ttry {\n\t\t\t\t\t$this->userData->setAttributes($this->session->get('user_saml.samlUserData'));\n\t\t\t\t\t$this->autoprovisionIfPossible();\n\t\t\t\t\t$user = $this->userResolver->findExistingUser($this->userBackend->getCurrentUserId());\n\t\t\t\t\t$user->updateLastLoginTimestamp();\n\t\t\t\t} catch (NoUserFoundException $e) {\n\t\t\t\t\tif ($e->getMessage()) {\n\t\t\t\t\t\t$this->logger->warning('Error while trying to login using sso environment variable: ' . $e->getMessage(), ['app' => 'user_saml']);\n\t\t\t\t\t}\n\t\t\t\t\t$ssoUrl = $this->urlGenerator->linkToRouteAbsolute('user_saml.SAML.notProvisioned');\n\t\t\t\t} catch (UserFilterViolationException $e) {\n\t\t\t\t\t$this->logger->info(\n\t\t\t\t\t\t'SAML filter constraints not met: {msg}',\n\t\t\t\t\t\t[\n\t\t\t\t\t\t\t'app' => 'user_saml',\n\t\t\t\t\t\t\t'msg' => $e->getMessage(),\n\t\t\t\t\t\t]\n\t\t\t\t\t);\n\t\t\t\t\t$ssoUrl = $this->urlGenerator->linkToRouteAbsolute('user_saml.SAML.notPermitted');\n\t\t\t\t}\n\t\t\t\t$response = new Http\\RedirectResponse($ssoUrl);\n\t\t\t\tif (isset($e)) {\n\t\t\t\t\t$this->session->clear();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new \\Exception(\n\t\t\t\t\tsprintf(\n\t\t\t\t\t\t'Type of \"%s\" is not supported for user_saml',\n\t\t\t\t\t\t$type\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t}\n\n\t\treturn $response;\n\t}\n\n\t/**\n\t * @PublicPage\n\t * @NoCSRFRequired\n\t * @throws Error\n\t */\n\tpublic function getMetadata(int $idp = 1): Http\\DataDownloadResponse {\n\t\t$settings = new Settings($this->samlSettings->getOneLoginSettingsArray($idp));\n\t\t$metadata = $settings->getSPMetadata();\n\t\t$errors = $this->callWithXmlEntityLoader(function () use ($settings, $metadata) {\n\t\t\treturn $settings->validateMetadata($metadata);\n\t\t});\n\t\tif (empty($errors)) {\n\t\t\treturn new Http\\DataDownloadResponse($metadata, 'metadata.xml', 'text/xml');\n\t\t} else {\n\t\t\tthrow new Error(\n\t\t\t\t'Invalid SP metadata: '.implode(', ', $errors),\n\t\t\t\tError::METADATA_SP_INVALID\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @PublicPage\n\t * @NoCSRFRequired\n\t * @UseSession\n\t * @OnlyUnauthenticatedUsers\n\t * @NoSameSiteCookieRequired\n\t *\n\t * @return Http\\RedirectResponse\n\t * @throws Error\n\t * @throws ValidationError\n\t */\n\tpublic function assertionConsumerService(): Http\\RedirectResponse {\n\t\t// Fetch and decrypt the cookie\n\t\t$cookie = $this->request->getCookie('saml_data');\n\t\tif ($cookie === null) {\n\t\t\t$this->logger->debug('Cookie was not present', ['app' => 'user_saml']);\n\t\t\treturn new Http\\RedirectResponse($this->urlGenerator->getAbsoluteURL('/'));\n\t\t}\n\n\t\t// Base64 decode\n\t\t$cookie = base64_decode($cookie);\n\n\t\t// Decrypt and deserialize\n\t\ttry {\n\t\t\t$cookie = $this->crypto->decrypt($cookie);\n\t\t} catch (\\Exception) {\n\t\t\t$this->logger->debug('Could not decrypt SAML cookie', ['app' => 'user_saml']);\n\t\t\treturn new Http\\RedirectResponse($this->urlGenerator->getAbsoluteURL('/'));\n\t\t}\n\t\t$data = json_decode($cookie, true);\n\n\t\tif (isset($data['flow'])) {\n\t\t\tif (isset($data['flow']['cf1'])) {\n\t\t\t\t$this->session->set(ClientFlowLoginController::STATE_NAME, $data['flow']['cf1']);\n\t\t\t} elseif (isset($data['flow']['cf2'])) {\n\t\t\t\t$this->session->set(ClientFlowLoginV2Controller::TOKEN_NAME, $data['flow']['cf2']['token']);\n\t\t\t\t$this->session->set(ClientFlowLoginV2Controller::STATE_NAME, $data['flow']['cf2']['state']);\n\t\t\t}\n\t\t}\n\n\t\t$AuthNRequestID = $data['AuthNRequestID'];\n\t\t$idp = $data['Idp'];\n\t\t// need to keep the IdP config ID during session lifetime (SAMLSettings::getPrefix)\n\t\t$this->session->set('user_saml.Idp', $idp);\n\t\tif (is_null($AuthNRequestID) || $AuthNRequestID === '' || is_null($idp)) {\n\t\t\t$this->logger->debug('Invalid auth payload', ['app' => 'user_saml']);\n\t\t\treturn new Http\\RedirectResponse($this->urlGenerator->getAbsoluteURL('/'));\n\t\t}\n\n\t\t$auth = new Auth($this->samlSettings->getOneLoginSettingsArray($idp));\n\t\t// validator (called with processResponse()) needs an XML entity loader\n\t\t$this->callWithXmlEntityLoader(function () use ($auth, $AuthNRequestID): void {\n\t\t\t$auth->processResponse($AuthNRequestID);\n\t\t});\n\n\t\t$this->logger->debug('Attributes send by the IDP: ' . json_encode($auth->getAttributes()));\n\n\t\t$errors = $auth->getErrors();\n\n\t\tif (!empty($errors)) {\n\t\t\tforeach ($errors as $error) {\n\t\t\t\t$this->logger->error($error, ['app' => $this->appName]);\n\t\t\t}\n\t\t\t$this->logger->error($auth->getLastErrorReason(), ['app' => $this->appName]);\n\t\t}\n\n\t\tif (!$auth->isAuthenticated()) {\n\t\t\t$this->logger->info('Auth failed', ['app' => $this->appName]);\n\t\t\t$response = new Http\\RedirectResponse($this->urlGenerator->linkToRouteAbsolute('user_saml.SAML.notProvisioned'));\n\t\t\t$response->invalidateCookie('saml_data');\n\t\t\treturn $response;\n\t\t}\n\n\t\t// Check whether the user actually exists, if not redirect to an error page\n\t\t// explaining the issue.\n\t\ttry {\n\t\t\t$this->userData->setAttributes($auth->getAttributes());\n\t\t\t$this->autoprovisionIfPossible();\n\t\t} catch (NoUserFoundException $e) {\n\t\t\t$this->logger->error($e->getMessage(), ['app' => $this->appName]);\n\t\t\t$response = new Http\\RedirectResponse($this->urlGenerator->linkToRouteAbsolute('user_saml.SAML.notProvisioned'));\n\t\t\t$response->invalidateCookie('saml_data');\n\t\t\treturn $response;\n\t\t} catch (UserFilterViolationException $e) {\n\t\t\t$this->logger->error($e->getMessage(), ['app' => $this->appName]);\n\t\t\t$response = new Http\\RedirectResponse($this->urlGenerator->linkToRouteAbsolute('user_saml.SAML.notPermitted'));\n\t\t\t$response->invalidateCookie('saml_data');\n\t\t\treturn $response;\n\t\t}\n\n\t\t$this->session->set('user_saml.samlUserData', $auth->getAttributes());\n\t\t$this->session->set('user_saml.samlNameId', $auth->getNameId());\n\t\t$this->session->set('user_saml.samlNameIdFormat', $auth->getNameIdFormat());\n\t\t$this->session->set('user_saml.samlNameIdNameQualifier', $auth->getNameIdNameQualifier());\n\t\t$this->session->set('user_saml.samlNameIdSPNameQualifier', $auth->getNameIdSPNameQualifier());\n\t\t$this->session->set('user_saml.samlSessionIndex', $auth->getSessionIndex());\n\t\t$this->session->set('user_saml.samlSessionExpiration', $auth->getSessionExpiration());\n\t\ttry {\n\t\t\t$user = $this->userResolver->findExistingUser($this->userBackend->getCurrentUserId());\n\t\t\t$firstLogin = $user->updateLastLoginTimestamp();\n\t\t\tif ($firstLogin) {\n\t\t\t\t$this->userBackend->initializeHomeDir($user->getUID());\n\t\t\t}\n\t\t} catch (NoUserFoundException) {\n\t\t\tthrow new \\InvalidArgumentException('User \"' . $this->userBackend->getCurrentUserId() . '\" is not valid');\n\t\t} catch (\\Exception $e) {\n\t\t\t$this->logger->critical($e->getMessage(), ['exception' => $e, 'app' => $this->appName]);\n\t\t\t$response = new Http\\RedirectResponse($this->urlGenerator->linkToRouteAbsolute('user_saml.SAML.notProvisioned'));\n\t\t\t$response->invalidateCookie('saml_data');\n\t\t\treturn $response;\n\t\t}\n\n\t\t$originalUrl = $data['RelayState'] ?? $data['OriginalUrl'];\n\t\tif ($originalUrl !== null && $originalUrl !== '') {\n\t\t\t$response = new Http\\RedirectResponse($originalUrl);\n\t\t} else {\n\t\t\t$response = new Http\\RedirectResponse($this->urlGenerator->getAbsoluteURL('/'));\n\t\t}\n\t\t// The Nextcloud desktop client expects a cookie with the key of \"_shibsession\"\n\t\t// to be there.\n\t\tif ($this->request->isUserAgent(['/^.*(mirall|csyncoC)\\/.*$/'])) {\n\t\t\t$response->addCookie('_shibsession_', 'authenticated');\n\t\t}\n\n\t\t$response->invalidateCookie('saml_data');\n\t\treturn $response;\n\t}\n\n\t/**\n\t * @PublicPage\n\t * @NoAdminRequired\n\t * @NoCSRFRequired\n\t * @UseSession\n\t * @throws Error\n\t */\n\tpublic function singleLogoutService(): Http\\RedirectResponse {\n\t\t$isFromGS = ($this->config->getSystemValue('gs.enabled', false) &&\n\t\t\t\t\t $this->config->getSystemValue('gss.mode', '') === 'master');\n\n\t\t// Some IDPs send the SLO request via POST, but OneLogin php-saml only handles GET.\n\t\t// To hack around this issue we copy the request from _POST to _GET.\n\t\tif (!empty($_POST['SAMLRequest'])) {\n\t\t\t$_GET['SAMLRequest'] = $_POST['SAMLRequest'];\n\t\t}\n\n\t\t$isFromIDP = !$isFromGS && !empty($_GET['SAMLRequest']);\n\t\t$idp = null;\n\t\tif ($isFromIDP) {\n\t\t\t// requests comes from the IDP so let it manage the logout\n\t\t\t// (or raise Error if request is invalid)\n\t\t\t$pass = true ;\n\t\t} elseif ($isFromGS) {\n\t\t\t// Request is from master GlobalScale\n\t\t\t$jwt = $this->request->getParam('jwt', '');\n\n\t\t\ttry {\n\t\t\t\t$key = $this->config->getSystemValue('gss.jwt.key', '');\n\t\t\t\t$decoded = (array)JWT::decode($jwt, new Key($key, 'HS256'));\n\n\t\t\t\t$idp = $decoded['idp'] ?? null;\n\t\t\t\t$pass = true;\n\t\t\t} catch (\\Exception) {\n\t\t\t}\n\t\t} else {\n\t\t\t// standard request : need read CRSF check\n\t\t\t$pass = $this->request->passesCSRFCheck();\n\t\t}\n\n\t\tif ($pass) {\n\t\t\t$idp = ($idp !== null) ? (int)$idp : $this->session->get('user_saml.Idp');\n\t\t\t$stay = true; // $auth will return the redirect URL but won't perform the redirect himself\n\t\t\tif ($isFromIDP) {\n\t\t\t\t[$targetUrl, $auth] = $this->tryProcessSLOResponse($idp);\n\t\t\t\tif ($auth !== null) {\n\t\t\t\t\t$errors = $auth->getErrors();\n\t\t\t\t\tif (!empty($errors)) {\n\t\t\t\t\t\tforeach ($errors as $error) {\n\t\t\t\t\t\t\t$this->logger->error($error, ['app' => $this->appName]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t$this->logger->error($auth->getLastErrorReason(), ['app' => $this->appName]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t$this->logger->error('Error while handling SLO request: missing session data, and request is not satisfied by any configuration');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If request is not from IDP, we send the logout request to the IDP\n\t\t\t\t$auth = new Auth($this->samlSettings->getOneLoginSettingsArray($idp ?? 1));\n\t\t\t\t$nameId = $this->session->get('user_saml.samlNameId');\n\t\t\t\t$nameIdFormat = $this->session->get('user_saml.samlNameIdFormat');\n\t\t\t\t$nameIdNameQualifier = $this->session->get('user_saml.samlNameIdNameQualifier');\n\t\t\t\t$nameIdSPNameQualifier = $this->session->get('user_saml.samlNameIdSPNameQualifier');\n\t\t\t\t$sessionIndex = $this->session->get('user_saml.samlSessionIndex');\n\t\t\t\ttry {\n\t\t\t\t\t$targetUrl = $auth->logout(null, [], $nameId, $sessionIndex, $stay, $nameIdFormat, $nameIdNameQualifier, $nameIdSPNameQualifier);\n\t\t\t\t} catch (Error $e) {\n\t\t\t\t\t$this->logger->warning($e->getMessage(), ['exception' => $e, 'app' => $this->appName]);\n\t\t\t\t\t$this->userSession->logout();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!empty($targetUrl) && !$auth->getLastErrorReason()) {\n\t\t\t\t$this->userSession->logout();\n\t\t\t}\n\t\t}\n\t\tif (empty($targetUrl)) {\n\t\t\t$targetUrl = $this->urlGenerator->getAbsoluteURL('/');\n\t\t}\n\n\t\treturn new Http\\RedirectResponse($targetUrl);\n\t}\n\n\t/**\n\t * @returns [?string, ?Auth]\n\t */\n\tprivate function tryProcessSLOResponse(?int $idp): array {\n\t\t$idps = ($idp !== null) ? [$idp] : array_keys($this->samlSettings->getListOfIdps());\n\t\tforeach ($idps as $idp) {\n\t\t\ttry {\n\t\t\t\t$auth = new Auth($this->samlSettings->getOneLoginSettingsArray($idp));\n\t\t\t\t// validator (called with processSLO()) needs an XML entity loader\n\t\t\t\t$targetUrl = $this->callWithXmlEntityLoader(function () use ($auth, $idp): string {\n\t\t\t\t\treturn $auth->processSLO(\n\t\t\t\t\t\ttrue, // do not let processSLO to delete the entire session. Let userSession->logout do the job\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t$this->samlSettings->usesSloWebServerDecode($idp),\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t\tif ($auth->getLastErrorReason() === null) {\n\t\t\t\t\treturn [$targetUrl, $auth];\n\t\t\t\t}\n\t\t\t} catch (Error) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\treturn [null, null];\n\t}\n\n\t/**\n\t * @PublicPage\n\t * @NoCSRFRequired\n\t * @OnlyUnauthenticatedUsers\n\t */\n\tpublic function notProvisioned(): Http\\TemplateResponse {\n\t\treturn new Http\\TemplateResponse($this->appName, 'notProvisioned', [], 'guest');\n\t}\n\n\t/**\n\t * @PublicPage\n\t * @NoCSRFRequired\n\t * @OnlyUnauthenticatedUsers\n\t */\n\tpublic function notPermitted(): Http\\TemplateResponse {\n\t\treturn new Http\\TemplateResponse($this->appName, 'notPermitted', [], 'guest');\n\t}\n\n\t/**\n\t * @PublicPage\n\t * @NoCSRFRequired\n\t * @OnlyUnauthenticatedUsers\n\t */\n\tpublic function genericError(string $message): Http\\TemplateResponse {\n\t\tif (empty($message)) {\n\t\t\t$message = $this->l->t('Unknown error, please check the log file for more details.');\n\t\t}\n\t\treturn new Http\\TemplateResponse($this->appName, 'error', ['message' => $message], 'guest');\n\t}\n\n\t/**\n\t * @PublicPage\n\t * @NoCSRFRequired\n\t * @OnlyUnauthenticatedUsers\n\t */\n\tpublic function selectUserBackEnd(string $redirectUrl): Http\\TemplateResponse {\n\t\t$attributes = ['loginUrls' => []];\n\n\t\tif ($this->samlSettings->allowMultipleUserBackEnds()) {\n\t\t\t$displayName = $this->l->t('Direct log in');\n\n\t\t\t$customDisplayName = $this->config->getAppValue('user_saml', 'directLoginName', '');\n\t\t\tif ($customDisplayName !== '') {\n\t\t\t\t$displayName = $customDisplayName;\n\t\t\t}\n\n\t\t\t$attributes['loginUrls']['directLogin'] = [\n\t\t\t\t'url' => $this->getDirectLoginUrl($redirectUrl),\n\t\t\t\t'display-name' => $displayName,\n\t\t\t];\n\t\t}\n\n\t\t$attributes['loginUrls']['ssoLogin'] = $this->getIdps($redirectUrl);\n\n\t\t$attributes['useCombobox'] = count($attributes['loginUrls']['ssoLogin']) > 4;\n\n\n\t\treturn new Http\\TemplateResponse($this->appName, 'selectUserBackEnd', $attributes, 'guest');\n\t}\n\n\t/**\n\t * get the IdPs showed at the login page\n\t */\n\tprivate function getIdps(string $redirectUrl): array {\n\t\t$result = [];\n\t\t$idps = $this->samlSettings->getListOfIdps();\n\t\tforeach ($idps as $idpId => $displayName) {\n\t\t\t$result[] = [\n\t\t\t\t'url' => $this->getSSOUrl($redirectUrl, (string)$idpId),\n\t\t\t\t'display-name' => $this->getSSODisplayName($displayName),\n\t\t\t];\n\t\t}\n\n\t\treturn $result;\n\t}\n\n\tprivate function getSSOUrl(string $redirectUrl, string $idp): string {\n\t\t$originalUrl = '';\n\t\tif (!empty($redirectUrl)) {\n\t\t\t$originalUrl = $this->urlGenerator->getAbsoluteURL($redirectUrl);\n\t\t}\n\n\t\t/** @var CsrfTokenManager $csrfTokenManager */\n\t\t$csrfTokenManager = Server::get(CsrfTokenManager::class);\n\t\t$csrfToken = $csrfTokenManager->getToken();\n\t\t$ssoUrl = $this->urlGenerator->linkToRouteAbsolute(\n\t\t\t'user_saml.SAML.login',\n\t\t\t[\n\t\t\t\t'requesttoken' => $csrfToken->getEncryptedValue(),\n\t\t\t\t'originalUrl' => $originalUrl,\n\t\t\t\t'idp' => $idp\n\t\t\t]\n\t\t);\n\n\t\treturn $ssoUrl;\n\t}\n\n\t/**\n\t * return the display name of the SSO identity provider\n\t */\n\tprotected function getSSODisplayName(?string $displayName): string {\n\t\tif (empty($displayName)) {\n\t\t\t$displayName = $this->l->t('SSO & SAML log in');\n\t\t}\n\n\t\treturn $displayName;\n\t}\n\n\t/**\n\t * get Nextcloud login URL\n\t */\n\tprivate function getDirectLoginUrl(string $redirectUrl): string {\n\t\t$directUrl = $this->urlGenerator->linkToRouteAbsolute('core.login.tryLogin', [\n\t\t\t'direct' => '1',\n\t\t\t'redirect_url' => $redirectUrl,\n\t\t]);\n\t\treturn $directUrl;\n\t}\n\n\t/**\n\t * @PublicPage\n\t * @NoCSRFRequired\n\t */\n\tpublic function base(): Http\\TemplateResponse {\n\t\t$message = $this->l->t('This page should not be visited directly.');\n\t\treturn new Http\\TemplateResponse($this->appName, 'error', ['message' => $message], 'guest');\n\t}\n}\n", "<?php\n/**\n * @copyright Copyright (c) 2016 Lukas Reschke <lukas@statuscode.ch>\n *\n * @license GNU AGPL version 3 or any later version\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\n\nnamespace OCA\\User_SAML\\Tests\\Controller;\n\nuse Exception;\nuse OCA\\User_SAML\\Controller\\SAMLController;\nuse OCA\\User_SAML\\Exceptions\\NoUserFoundException;\nuse OCA\\User_SAML\\Exceptions\\UserFilterViolationException;\nuse OCA\\User_SAML\\SAMLSettings;\nuse OCA\\User_SAML\\UserBackend;\nuse OCA\\User_SAML\\UserData;\nuse OCA\\User_SAML\\UserResolver;\nuse OCP\\AppFramework\\Http\\RedirectResponse;\nuse OCP\\AppFramework\\Http\\TemplateResponse;\nuse OCP\\IConfig;\nuse OCP\\IL10N;\nuse OCP\\IRequest;\nuse OCP\\ISession;\nuse OCP\\IURLGenerator;\nuse OCP\\IUser;\nuse OCP\\IUserSession;\nuse OCP\\Security\\ICrypto;\nuse OCP\\Security\\ITrustedDomainHelper;\nuse PHPUnit\\Framework\\MockObject\\MockObject;\nuse Psr\\Log\\LoggerInterface;\nuse Test\\TestCase;\n\nclass SAMLControllerTest extends TestCase {\n\t/** @var UserResolver|\\PHPUnit\\Framework\\MockObject\\MockObject */\n\tprotected $userResolver;\n\t/** @var UserData|\\PHPUnit\\Framework\\MockObject\\MockObject */\n\tprivate $userData;\n\t/** @var IRequest|\\PHPUnit_Framework_MockObject_MockObject */\n\tprivate $request;\n\t/** @var ISession|\\PHPUnit_Framework_MockObject_MockObject */\n\tprivate $session;\n\t/** @var IUserSession|\\PHPUnit_Framework_MockObject_MockObject */\n\tprivate $userSession;\n\t/** @var SAMLSettings|\\PHPUnit_Framework_MockObject_MockObject*/\n\tprivate $samlSettings;\n\t/** @var UserBackend|\\PHPUnit_Framework_MockObject_MockObject */\n\tprivate $userBackend;\n\t/** @var IConfig|\\PHPUnit_Framework_MockObject_MockObject */\n\tprivate $config;\n\t/** @var IURLGenerator|\\PHPUnit_Framework_MockObject_MockObject */\n\tprivate $urlGenerator;\n\t/** @var LoggerInterface|\\PHPUnit_Framework_MockObject_MockObject */\n\tprivate $logger;\n\t/** @var IL10N|\\PHPUnit_Framework_MockObject_MockObject */\n\tprivate $l;\n\t/** @var ICrypto|MockObject */\n\tprivate $crypto;\n\t/** @var SAMLController */\n\tprivate $samlController;\n\tprivate ITrustedDomainHelper|MockObject $trustedDomainController;\n\n\tprotected function setUp(): void {\n\t\tparent::setUp();\n\n\t\t$this->request = $this->createMock(IRequest::class);\n\t\t$this->session = $this->createMock(ISession::class);\n\t\t$this->userSession = $this->createMock(IUserSession::class);\n\t\t$this->samlSettings = $this->createMock(SAMLSettings::class);\n\t\t$this->userBackend = $this->createMock(UserBackend::class);\n\t\t$this->config = $this->createMock(IConfig::class);\n\t\t$this->urlGenerator = $this->createMock(IURLGenerator::class);\n\t\t$this->logger = $this->createMock(LoggerInterface::class);\n\t\t$this->l = $this->createMock(IL10N::class);\n\t\t$this->userResolver = $this->createMock(UserResolver::class);\n\t\t$this->userData = $this->createMock(UserData::class);\n\t\t$this->crypto = $this->createMock(ICrypto::class);\n\t\t$this->trustedDomainController = $this->createMock(ITrustedDomainHelper::class);\n\n\t\t$this->l->expects($this->any())->method('t')->willReturnCallback(\n\t\t\tfunction ($param) {\n\t\t\t\treturn $param;\n\t\t\t}\n\t\t);\n\n\t\t$this->config->expects($this->any())->method('getSystemValue')\n\t\t\t->willReturnCallback(function ($key, $default) {\n\t\t\t\treturn $default;\n\t\t\t});\n\n\t\t$this->samlController = new SAMLController(\n\t\t\t'user_saml',\n\t\t\t$this->request,\n\t\t\t$this->session,\n\t\t\t$this->userSession,\n\t\t\t$this->samlSettings,\n\t\t\t$this->userBackend,\n\t\t\t$this->config,\n\t\t\t$this->urlGenerator,\n\t\t\t$this->logger,\n\t\t\t$this->l,\n\t\t\t$this->userResolver,\n\t\t\t$this->userData,\n\t\t\t$this->crypto,\n\t\t\t$this->trustedDomainController\n\t\t);\n\t}\n\n\tpublic function testLoginWithInvalidAppValue() {\n\t\t$this->config\n\t\t\t->expects($this->once())\n\t\t\t->method('getAppValue')\n\t\t\t->with('user_saml', 'type')\n\t\t\t->willReturn('UnknownValue');\n\n\t\t$this->expectException(Exception::class);\n\t\t$this->expectExceptionMessage('Type of \"UnknownValue\" is not supported for user_saml');\n\n\t\t$this->samlController->login(1);\n\t}\n\n\tpublic function samlUserDataProvider() {\n\t\t$userNotExisting = 0;\n\t\t$userExisting = 1;\n\t\t$userLazyExisting = 2;\n\n\t\t$apDisabled = 0;\n\t\t$apEnabled = 1;\n\t\t$apEnabledUnsuccessful = 2;\n\n\t\treturn  [\n\t\t\t[ # 0 - Not existing uid in settings array\n\t\t\t\t[\n\t\t\t\t\t'foo' => 'bar',\n\t\t\t\t\t'bar' => 'foo',\n\t\t\t\t],\n\t\t\t\t'https://nextcloud.com/notProvisioned/',\n\t\t\t\t$userNotExisting,\n\t\t\t\t$apDisabled\n\t\t\t],\n\t\t\t[ # 1 - existing user\n\t\t\t\t[\n\t\t\t\t\t'foo' => 'bar',\n\t\t\t\t\t'bar' => 'foo',\n\t\t\t\t\t'uid' => 'MyUid',\n\t\t\t\t],\n\t\t\t\t'https://nextcloud.com/absolute/',\n\t\t\t\t$userExisting,\n\t\t\t\t$apDisabled\n\t\t\t],\n\t\t\t[ # 2 - existing user and uid attribute in array\n\t\t\t\t[\n\t\t\t\t\t'foo' => 'bar',\n\t\t\t\t\t'bar' => 'foo',\n\t\t\t\t\t'uid' => ['MyUid'],\n\t\t\t\t],\n\t\t\t\t'https://nextcloud.com/absolute/',\n\t\t\t\t$userExisting,\n\t\t\t\t$apDisabled\n\t\t\t],\n\t\t\t[ # 3 - Not existing user with provisioning\n\t\t\t\t[\n\t\t\t\t\t'foo' => 'bar',\n\t\t\t\t\t'bar' => 'foo',\n\t\t\t\t\t'uid' => 'MyUid',\n\t\t\t\t],\n\t\t\t\t'https://nextcloud.com/absolute/',\n\t\t\t\t$userNotExisting,\n\t\t\t\t$apEnabled\n\t\t\t],\n\t\t\t[ # 4 - Not existing user with malfunctioning backend\n\t\t\t\t[\n\t\t\t\t\t'foo' => 'bar',\n\t\t\t\t\t'bar' => 'foo',\n\t\t\t\t\t'uid' => 'MyUid',\n\t\t\t\t],\n\t\t\t\t'https://nextcloud.com/notProvisioned/',\n\t\t\t\t$userNotExisting,\n\t\t\t\t$apEnabledUnsuccessful\n\t\t\t],\n\t\t\t[ # 5 - Not existing user without provisioning\n\t\t\t\t[\n\t\t\t\t\t'foo' => 'bar',\n\t\t\t\t\t'bar' => 'foo',\n\t\t\t\t\t'uid' => 'MyUid',\n\t\t\t\t],\n\t\t\t\t'https://nextcloud.com/notProvisioned/',\n\t\t\t\t$userNotExisting,\n\t\t\t\t$apDisabled\n\t\t\t],\n\t\t\t[ # 6 - Not yet mapped user without provisioning\n\t\t\t\t[\n\t\t\t\t\t'foo' => 'bar',\n\t\t\t\t\t'bar' => 'foo',\n\t\t\t\t\t'uid' => 'MyUid',\n\t\t\t\t],\n\t\t\t\t'https://nextcloud.com/absolute/',\n\t\t\t\t$userLazyExisting,\n\t\t\t\t$apDisabled\n\t\t\t],\n\t\t];\n\t}\n\n\t/**\n\t * @dataProvider samlUserDataProvider\n\t */\n\tpublic function testLoginWithEnvVariable(array $samlUserData, string $redirect, int $userState, int $autoProvision) {\n\t\t$this->config->expects($this->any())\n\t\t\t->method('getAppValue')\n\t\t\t->willReturnCallback(function (string $app, string $key) {\n\t\t\t\tif ($app === 'user_saml') {\n\t\t\t\t\tif ($key === 'type') {\n\t\t\t\t\t\treturn 'environment-variable';\n\t\t\t\t\t}\n\t\t\t\t\tif ($key === 'general-uid_mapping') {\n\t\t\t\t\t\treturn 'uid';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t});\n\n\t\t$this->session\n\t\t\t->expects($this->any())\n\t\t\t->method('get')\n\t\t\t->willReturnCallback(function (string $key) use ($samlUserData) {\n\t\t\t\tswitch ($key) {\n\t\t\t\t\tcase 'user_saml.samlUserData':\n\t\t\t\t\t\treturn $samlUserData;\n\t\t\t\t\tcase 'user_saml.Idp':\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t});\n\n\t\t$this->userData\n\t\t\t->expects($this->once())\n\t\t\t->method('setAttributes')\n\t\t\t->with($samlUserData);\n\t\t$this->userData\n\t\t\t->expects($this->any())\n\t\t\t->method('getAttributes')\n\t\t\t->willReturn($samlUserData);\n\t\t$this->userData\n\t\t\t->expects($this->any())\n\t\t\t->method('hasUidMappingAttribute')\n\t\t\t->willReturn(isset($samlUserData['uid']));\n\t\t$this->userData\n\t\t\t->expects(isset($samlUserData['uid']) ? $this->any() : $this->never())\n\t\t\t->method('getOriginalUid')\n\t\t\t->willReturn('MyUid');\n\t\t$this->userData\n\t\t\t->expects($this->any())\n\t\t\t->method('testEncodedObjectGUID')\n\t\t\t->willReturnCallback(function ($uid) {\n\t\t\t\treturn $uid;\n\t\t\t});\n\t\t$this->userData\n\t\t\t->expects($this->any())\n\t\t\t->method('getEffectiveUid')\n\t\t\t->willReturn($userState > 0 ? 'MyUid' : '');\n\n\t\tif (strpos($redirect, 'notProvisioned') !== false) {\n\t\t\t$this->urlGenerator\n\t\t\t\t->expects($this->once())\n\t\t\t\t->method('linkToRouteAbsolute')\n\t\t\t\t->with('user_saml.SAML.notProvisioned')\n\t\t\t\t->willReturn($redirect);\n\t\t} else {\n\t\t\t$this->urlGenerator\n\t\t\t\t->expects($this->once())\n\t\t\t\t->method('getAbsoluteURL')\n\t\t\t\t->willReturn($redirect);\n\t\t}\n\n\t\t$this->userResolver\n\t\t\t->expects($this->any())\n\t\t\t->method('userExists')\n\t\t\t->with('MyUid')\n\t\t\t->willReturn($userState === 1);\n\n\t\tif (isset($samlUserData['uid']) && !($userState === 0 && $autoProvision === 0)) {\n\t\t\t/** @var IUser|MockObject $user */\n\t\t\t$user = $this->createMock(IUser::class);\n\t\t\t$im = $this->userResolver\n\t\t\t\t->expects($this->once())\n\t\t\t\t->method('findExistingUser')\n\t\t\t\t->with('MyUid');\n\t\t\tif ($autoProvision < 2) {\n\t\t\t\t$im->willReturn($user);\n\t\t\t} else {\n\t\t\t\t$im->willThrowException(new NoUserFoundException());\n\t\t\t}\n\n\t\t\t$user\n\t\t\t\t->expects($this->exactly((int)($autoProvision < 2)))\n\t\t\t\t->method('updateLastLoginTimestamp');\n\n\t\t\tif ($userState === 0) {\n\t\t\t\t$this->userResolver\n\t\t\t\t\t->expects($this->any())\n\t\t\t\t\t->method('findExistingUserId')\n\t\t\t\t\t->with('MyUid', true)\n\t\t\t\t\t->willThrowException(new NoUserFoundException());\n\t\t\t} elseif ($userState === 2) {\n\t\t\t\t$this->userResolver\n\t\t\t\t\t->expects($this->any())\n\t\t\t\t\t->method('findExistingUserId')\n\t\t\t\t\t->with('MyUid', true)\n\t\t\t\t\t->willReturn('MyUid');\n\t\t\t}\n\t\t}\n\t\t$this->userBackend\n\t\t\t->expects($this->any())\n\t\t\t->method('getCurrentUserId')\n\t\t\t->willReturn(isset($samlUserData['uid']) ? 'MyUid' : '');\n\t\t$this->userBackend\n\t\t\t->expects($this->any())\n\t\t\t->method('autoprovisionAllowed')\n\t\t\t->willReturn($autoProvision > 0);\n\t\t$this->userBackend\n\t\t\t->expects($this->exactly(min(1, $autoProvision)))\n\t\t\t->method('createUserIfNotExists')\n\t\t\t->with('MyUid');\n\n\t\t$expected = new RedirectResponse($redirect);\n\t\t$result = $this->samlController->login(1);\n\t\t$this->assertEquals($expected, $result);\n\t}\n\n\tpublic function testNotPermitted() {\n\t\t$expected = new TemplateResponse('user_saml', 'notPermitted', [], 'guest');\n\t\t$this->assertEquals($expected, $this->samlController->notPermitted());\n\t}\n\n\tpublic function testNotProvisioned() {\n\t\t$expected = new TemplateResponse('user_saml', 'notProvisioned', [], 'guest');\n\t\t$this->assertEquals($expected, $this->samlController->notProvisioned());\n\t}\n\n\t/**\n\t * @dataProvider dataTestGenericError\n\t *\n\t * @param string $messageSend\n\t * @param string $messageExpected\n\t */\n\tpublic function testGenericError($messageSend, $messageExpected) {\n\t\t$expected = new TemplateResponse('user_saml', 'error', ['message' => $messageExpected], 'guest');\n\t\t$this->assertEquals($expected, $this->samlController->genericError($messageSend));\n\t}\n\n\tpublic function dataTestGenericError() {\n\t\treturn [\n\t\t\t['messageSend' => '', 'messageExpected' => 'Unknown error, please check the log file for more details.'],\n\t\t\t['messageSend' => 'test message', 'messageExpected' => 'test message'],\n\t\t];\n\t}\n\n\t/**\n\t * @dataProvider dataTestGetSSODisplayName\n\t *\n\t * @param string $configuredDisplayName\n\t * @param string $expected\n\t */\n\tpublic function testGetSSODisplayName($configuredDisplayName, $expected) {\n\t\t$result = $this->invokePrivate($this->samlController, 'getSSODisplayName', [$configuredDisplayName]);\n\n\t\t$this->assertSame($expected, $result);\n\t}\n\n\tpublic function dataTestGetSSODisplayName() {\n\t\treturn [\n\t\t\t['My identity provider', 'My identity provider'],\n\t\t\t['', 'SSO & SAML log in']\n\t\t];\n\t}\n\n\tpublic function userFilterDataProvider(): array {\n\t\treturn [\n\t\t\t[ // 0 - test rejection by membership\n\t\t\t\t'Group C',\n\t\t\t\t'Group A, Group B',\n\t\t\t\ttrue,\n\t\t\t\t'User is member of a rejection group.',\n\t\t\t],\n\t\t\t[ // 1 - test rejection by required membership\n\t\t\t\t'Group D',\n\t\t\t\t'Group B',\n\t\t\t\ttrue,\n\t\t\t\t'User is not member of a required group.',\n\t\t\t],\n\t\t\t[ // 2 - test satisfy all requirements\n\t\t\t\t'Group D',\n\t\t\t\t'Group A',\n\t\t\t\tfalse,\n\t\t\t],\n\t\t\t[ // 3 - test no filtering\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tfalse,\n\t\t\t],\n\t\t];\n\t}\n\n\t/**\n\t * @dataProvider userFilterDataProvider\n\t */\n\tpublic function testUserFilter(?string $rejectGroups, ?string $requireGroups, bool $isException, string $message = ''): void {\n\t\t$this->userData->expects($this->any())\n\t\t\t->method('getGroups')\n\t\t\t->willReturn(['Group A', 'Group C']);\n\n\t\t$this->session->expects($this->any())\n\t\t\t->method('get')\n\t\t\t->with('user_saml.Idp')\n\t\t\t->willReturn(1);\n\n\t\t$settings = [];\n\t\tif ($rejectGroups !== null && $requireGroups !== null) {\n\t\t\t$settings = [\n\t\t\t\t'saml-user-filter-reject_groups' => $rejectGroups,\n\t\t\t\t'saml-user-filter-require_groups' => $requireGroups,\n\t\t\t];\n\t\t}\n\t\t$this->samlSettings->expects($this->any())\n\t\t\t->method('get')\n\t\t\t->with(1)\n\t\t\t->willReturn($settings);\n\n\t\t$this->userBackend->expects($this->any())\n\t\t\t->method('autoprovisionAllowed')\n\t\t\t->willReturn(true);\n\n\t\tif ($isException) {\n\t\t\t$this->expectException(UserFilterViolationException::class);\n\t\t\t$this->expectExceptionMessage($message);\n\t\t} else {\n\t\t\t// Nothing to assert other than no exception being thrown\n\t\t\t$this->assertTrue(true);\n\t\t}\n\n\t\t$this->invokePrivate($this->samlController, 'assertGroupMemberships');\n\t}\n\n\tpublic function testUserFilterNotApplicable(): void {\n\t\t$this->userData->expects($this->never())\n\t\t\t->method('getGroups');\n\n\t\t$this->session->expects($this->never())\n\t\t\t->method('get');\n\n\t\t$this->userBackend->expects($this->any())\n\t\t\t->method('autoprovisionAllowed')\n\t\t\t->willReturn(false);\n\n\t\t$this->invokePrivate($this->samlController, 'assertGroupMemberships');\n\t}\n}\n"], "filenames": ["lib/Controller/SAMLController.php", "tests/unit/Controller/SAMLControllerTest.php"], "buggy_code_start_loc": [45, 41], "buggy_code_end_loc": [233, 115], "fixing_code_start_loc": [46, 42], "fixing_code_end_loc": [243, 119], "type": "CWE-601", "message": "Nextcloud User Saml is an app for authenticating Nextcloud users using SAML. In affected versions users can be given a link to the Nextcloud server and end up on a uncontrolled thirdparty server. It is recommended that the User Saml app is upgraded to version 5.1.5, 5.2.5, or 6.0.1. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2024-22400", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-18T20:15:08.360", "lastModified": "2024-01-26T20:55:37.543", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Nextcloud User Saml is an app for authenticating Nextcloud users using SAML. In affected versions users can be given a link to the Nextcloud server and end up on a uncontrolled thirdparty server. It is recommended that the User Saml app is upgraded to version 5.1.5, 5.2.5, or 6.0.1. There are no known workarounds for this issue."}, {"lang": "es", "value": "Nextcloud User Saml es una aplicaci\u00f3n para autenticar a los usuarios de Nextcloud mediante SAML. En las versiones afectadas, a los usuarios se les puede proporcionar un enlace al servidor de Nextcloud y terminar en un servidor de terceros no controlado. Se recomienda actualizar la aplicaci\u00f3n User Saml a la versi\u00f3n 5.1.5, 5.2.5 o 6.0.1. No se conocen workarounds para este problema."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.1, "baseSeverity": "LOW"}, "exploitabilityScore": 1.6, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-601"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nextcloud:sso_\\&_saml_authentication:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.0.0", "versionEndExcluding": "5.1.5", "matchCriteriaId": "68724AAA-D837-4365-88F2-835D518A1805"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nextcloud:sso_\\&_saml_authentication:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.2.0", "versionEndExcluding": "5.2.5", "matchCriteriaId": "8F52CDDE-DE98-4150-B3A1-1FB15C6A0F19"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nextcloud:sso_\\&_saml_authentication:6.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "85B7A2B1-195F-4C8C-8521-E6C140A79B7A"}]}]}], "references": [{"url": "https://github.com/nextcloud/security-advisories/security/advisories/GHSA-622q-xhfr-xmv7", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://github.com/nextcloud/user_saml/commit/b184304a476deeba36e92b70562d5de7c2f85f8a", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/nextcloud/user_saml/pull/788", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://hackerone.com/reports/2263044", "source": "security-advisories@github.com", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/nextcloud/user_saml/commit/b184304a476deeba36e92b70562d5de7c2f85f8a"}}