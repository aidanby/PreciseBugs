{"buggy_code": ["/*\n   RFCOMM implementation for Linux Bluetooth stack (BlueZ).\n   Copyright (C) 2002 Maxim Krasnyansky <maxk@qualcomm.com>\n   Copyright (C) 2002 Marcel Holtmann <marcel@holtmann.org>\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License version 2 as\n   published by the Free Software Foundation;\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.\n   IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY\n   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES\n   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS,\n   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS\n   SOFTWARE IS DISCLAIMED.\n*/\n\n/*\n * RFCOMM sockets.\n */\n\n#include <linux/export.h>\n#include <linux/debugfs.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <net/bluetooth/l2cap.h>\n#include <net/bluetooth/rfcomm.h>\n\nstatic const struct proto_ops rfcomm_sock_ops;\n\nstatic struct bt_sock_list rfcomm_sk_list = {\n\t.lock = __RW_LOCK_UNLOCKED(rfcomm_sk_list.lock)\n};\n\nstatic void rfcomm_sock_close(struct sock *sk);\nstatic void rfcomm_sock_kill(struct sock *sk);\n\n/* ---- DLC callbacks ----\n *\n * called under rfcomm_dlc_lock()\n */\nstatic void rfcomm_sk_data_ready(struct rfcomm_dlc *d, struct sk_buff *skb)\n{\n\tstruct sock *sk = d->owner;\n\tif (!sk)\n\t\treturn;\n\n\tatomic_add(skb->len, &sk->sk_rmem_alloc);\n\tskb_queue_tail(&sk->sk_receive_queue, skb);\n\tsk->sk_data_ready(sk);\n\n\tif (atomic_read(&sk->sk_rmem_alloc) >= sk->sk_rcvbuf)\n\t\trfcomm_dlc_throttle(d);\n}\n\nstatic void rfcomm_sk_state_change(struct rfcomm_dlc *d, int err)\n{\n\tstruct sock *sk = d->owner, *parent;\n\tunsigned long flags;\n\n\tif (!sk)\n\t\treturn;\n\n\tBT_DBG(\"dlc %p state %ld err %d\", d, d->state, err);\n\n\tlocal_irq_save(flags);\n\tbh_lock_sock(sk);\n\n\tif (err)\n\t\tsk->sk_err = err;\n\n\tsk->sk_state = d->state;\n\n\tparent = bt_sk(sk)->parent;\n\tif (parent) {\n\t\tif (d->state == BT_CLOSED) {\n\t\t\tsock_set_flag(sk, SOCK_ZAPPED);\n\t\t\tbt_accept_unlink(sk);\n\t\t}\n\t\tparent->sk_data_ready(parent);\n\t} else {\n\t\tif (d->state == BT_CONNECTED)\n\t\t\trfcomm_session_getaddr(d->session,\n\t\t\t\t\t       &rfcomm_pi(sk)->src, NULL);\n\t\tsk->sk_state_change(sk);\n\t}\n\n\tbh_unlock_sock(sk);\n\tlocal_irq_restore(flags);\n\n\tif (parent && sock_flag(sk, SOCK_ZAPPED)) {\n\t\t/* We have to drop DLC lock here, otherwise\n\t\t * rfcomm_sock_destruct() will dead lock. */\n\t\trfcomm_dlc_unlock(d);\n\t\trfcomm_sock_kill(sk);\n\t\trfcomm_dlc_lock(d);\n\t}\n}\n\n/* ---- Socket functions ---- */\nstatic struct sock *__rfcomm_get_listen_sock_by_addr(u8 channel, bdaddr_t *src)\n{\n\tstruct sock *sk = NULL;\n\n\tsk_for_each(sk, &rfcomm_sk_list.head) {\n\t\tif (rfcomm_pi(sk)->channel != channel)\n\t\t\tcontinue;\n\n\t\tif (bacmp(&rfcomm_pi(sk)->src, src))\n\t\t\tcontinue;\n\n\t\tif (sk->sk_state == BT_BOUND || sk->sk_state == BT_LISTEN)\n\t\t\tbreak;\n\t}\n\n\treturn sk ? sk : NULL;\n}\n\n/* Find socket with channel and source bdaddr.\n * Returns closest match.\n */\nstatic struct sock *rfcomm_get_sock_by_channel(int state, u8 channel, bdaddr_t *src)\n{\n\tstruct sock *sk = NULL, *sk1 = NULL;\n\n\tread_lock(&rfcomm_sk_list.lock);\n\n\tsk_for_each(sk, &rfcomm_sk_list.head) {\n\t\tif (state && sk->sk_state != state)\n\t\t\tcontinue;\n\n\t\tif (rfcomm_pi(sk)->channel == channel) {\n\t\t\t/* Exact match. */\n\t\t\tif (!bacmp(&rfcomm_pi(sk)->src, src))\n\t\t\t\tbreak;\n\n\t\t\t/* Closest match */\n\t\t\tif (!bacmp(&rfcomm_pi(sk)->src, BDADDR_ANY))\n\t\t\t\tsk1 = sk;\n\t\t}\n\t}\n\n\tread_unlock(&rfcomm_sk_list.lock);\n\n\treturn sk ? sk : sk1;\n}\n\nstatic void rfcomm_sock_destruct(struct sock *sk)\n{\n\tstruct rfcomm_dlc *d = rfcomm_pi(sk)->dlc;\n\n\tBT_DBG(\"sk %p dlc %p\", sk, d);\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tskb_queue_purge(&sk->sk_write_queue);\n\n\trfcomm_dlc_lock(d);\n\trfcomm_pi(sk)->dlc = NULL;\n\n\t/* Detach DLC if it's owned by this socket */\n\tif (d->owner == sk)\n\t\td->owner = NULL;\n\trfcomm_dlc_unlock(d);\n\n\trfcomm_dlc_put(d);\n}\n\nstatic void rfcomm_sock_cleanup_listen(struct sock *parent)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"parent %p\", parent);\n\n\t/* Close not yet accepted dlcs */\n\twhile ((sk = bt_accept_dequeue(parent, NULL))) {\n\t\trfcomm_sock_close(sk);\n\t\trfcomm_sock_kill(sk);\n\t}\n\n\tparent->sk_state  = BT_CLOSED;\n\tsock_set_flag(parent, SOCK_ZAPPED);\n}\n\n/* Kill socket (only if zapped and orphan)\n * Must be called on unlocked socket.\n */\nstatic void rfcomm_sock_kill(struct sock *sk)\n{\n\tif (!sock_flag(sk, SOCK_ZAPPED) || sk->sk_socket)\n\t\treturn;\n\n\tBT_DBG(\"sk %p state %d refcnt %d\", sk, sk->sk_state, atomic_read(&sk->sk_refcnt));\n\n\t/* Kill poor orphan */\n\tbt_sock_unlink(&rfcomm_sk_list, sk);\n\tsock_set_flag(sk, SOCK_DEAD);\n\tsock_put(sk);\n}\n\nstatic void __rfcomm_sock_close(struct sock *sk)\n{\n\tstruct rfcomm_dlc *d = rfcomm_pi(sk)->dlc;\n\n\tBT_DBG(\"sk %p state %d socket %p\", sk, sk->sk_state, sk->sk_socket);\n\n\tswitch (sk->sk_state) {\n\tcase BT_LISTEN:\n\t\trfcomm_sock_cleanup_listen(sk);\n\t\tbreak;\n\n\tcase BT_CONNECT:\n\tcase BT_CONNECT2:\n\tcase BT_CONFIG:\n\tcase BT_CONNECTED:\n\t\trfcomm_dlc_close(d, 0);\n\n\tdefault:\n\t\tsock_set_flag(sk, SOCK_ZAPPED);\n\t\tbreak;\n\t}\n}\n\n/* Close socket.\n * Must be called on unlocked socket.\n */\nstatic void rfcomm_sock_close(struct sock *sk)\n{\n\tlock_sock(sk);\n\t__rfcomm_sock_close(sk);\n\trelease_sock(sk);\n}\n\nstatic void rfcomm_sock_init(struct sock *sk, struct sock *parent)\n{\n\tstruct rfcomm_pinfo *pi = rfcomm_pi(sk);\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (parent) {\n\t\tsk->sk_type = parent->sk_type;\n\t\tpi->dlc->defer_setup = test_bit(BT_SK_DEFER_SETUP,\n\t\t\t\t\t\t&bt_sk(parent)->flags);\n\n\t\tpi->sec_level = rfcomm_pi(parent)->sec_level;\n\t\tpi->role_switch = rfcomm_pi(parent)->role_switch;\n\n\t\tsecurity_sk_clone(parent, sk);\n\t} else {\n\t\tpi->dlc->defer_setup = 0;\n\n\t\tpi->sec_level = BT_SECURITY_LOW;\n\t\tpi->role_switch = 0;\n\t}\n\n\tpi->dlc->sec_level = pi->sec_level;\n\tpi->dlc->role_switch = pi->role_switch;\n}\n\nstatic struct proto rfcomm_proto = {\n\t.name\t\t= \"RFCOMM\",\n\t.owner\t\t= THIS_MODULE,\n\t.obj_size\t= sizeof(struct rfcomm_pinfo)\n};\n\nstatic struct sock *rfcomm_sock_alloc(struct net *net, struct socket *sock, int proto, gfp_t prio, int kern)\n{\n\tstruct rfcomm_dlc *d;\n\tstruct sock *sk;\n\n\tsk = sk_alloc(net, PF_BLUETOOTH, prio, &rfcomm_proto, kern);\n\tif (!sk)\n\t\treturn NULL;\n\n\tsock_init_data(sock, sk);\n\tINIT_LIST_HEAD(&bt_sk(sk)->accept_q);\n\n\td = rfcomm_dlc_alloc(prio);\n\tif (!d) {\n\t\tsk_free(sk);\n\t\treturn NULL;\n\t}\n\n\td->data_ready   = rfcomm_sk_data_ready;\n\td->state_change = rfcomm_sk_state_change;\n\n\trfcomm_pi(sk)->dlc = d;\n\td->owner = sk;\n\n\tsk->sk_destruct = rfcomm_sock_destruct;\n\tsk->sk_sndtimeo = RFCOMM_CONN_TIMEOUT;\n\n\tsk->sk_sndbuf = RFCOMM_MAX_CREDITS * RFCOMM_DEFAULT_MTU * 10;\n\tsk->sk_rcvbuf = RFCOMM_MAX_CREDITS * RFCOMM_DEFAULT_MTU * 10;\n\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\n\tsk->sk_protocol = proto;\n\tsk->sk_state    = BT_OPEN;\n\n\tbt_sock_link(&rfcomm_sk_list, sk);\n\n\tBT_DBG(\"sk %p\", sk);\n\treturn sk;\n}\n\nstatic int rfcomm_sock_create(struct net *net, struct socket *sock,\n\t\t\t      int protocol, int kern)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"sock %p\", sock);\n\n\tsock->state = SS_UNCONNECTED;\n\n\tif (sock->type != SOCK_STREAM && sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tsock->ops = &rfcomm_sock_ops;\n\n\tsk = rfcomm_sock_alloc(net, sock, protocol, GFP_ATOMIC, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\trfcomm_sock_init(sk, NULL);\n\treturn 0;\n}\n\nstatic int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)\n{\n\tstruct sockaddr_rc *sa = (struct sockaddr_rc *) addr;\n\tstruct sock *sk = sock->sk;\n\tint chan = sa->rc_channel;\n\tint err = 0;\n\n\tBT_DBG(\"sk %p %pMR\", sk, &sa->rc_bdaddr);\n\n\tif (!addr || addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (sk->sk_type != SOCK_STREAM) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\twrite_lock(&rfcomm_sk_list.lock);\n\n\tif (chan && __rfcomm_get_listen_sock_by_addr(chan, &sa->rc_bdaddr)) {\n\t\terr = -EADDRINUSE;\n\t} else {\n\t\t/* Save source address */\n\t\tbacpy(&rfcomm_pi(sk)->src, &sa->rc_bdaddr);\n\t\trfcomm_pi(sk)->channel = chan;\n\t\tsk->sk_state = BT_BOUND;\n\t}\n\n\twrite_unlock(&rfcomm_sk_list.lock);\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int rfcomm_sock_connect(struct socket *sock, struct sockaddr *addr, int alen, int flags)\n{\n\tstruct sockaddr_rc *sa = (struct sockaddr_rc *) addr;\n\tstruct sock *sk = sock->sk;\n\tstruct rfcomm_dlc *d = rfcomm_pi(sk)->dlc;\n\tint err = 0;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (alen < sizeof(struct sockaddr_rc) ||\n\t    addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_OPEN && sk->sk_state != BT_BOUND) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (sk->sk_type != SOCK_STREAM) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tsk->sk_state = BT_CONNECT;\n\tbacpy(&rfcomm_pi(sk)->dst, &sa->rc_bdaddr);\n\trfcomm_pi(sk)->channel = sa->rc_channel;\n\n\td->sec_level = rfcomm_pi(sk)->sec_level;\n\td->role_switch = rfcomm_pi(sk)->role_switch;\n\n\terr = rfcomm_dlc_open(d, &rfcomm_pi(sk)->src, &sa->rc_bdaddr,\n\t\t\t      sa->rc_channel);\n\tif (!err)\n\t\terr = bt_sock_wait_state(sk, BT_CONNECTED,\n\t\t\t\tsock_sndtimeo(sk, flags & O_NONBLOCK));\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int rfcomm_sock_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sk %p backlog %d\", sk, backlog);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_BOUND) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (sk->sk_type != SOCK_STREAM) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (!rfcomm_pi(sk)->channel) {\n\t\tbdaddr_t *src = &rfcomm_pi(sk)->src;\n\t\tu8 channel;\n\n\t\terr = -EINVAL;\n\n\t\twrite_lock(&rfcomm_sk_list.lock);\n\n\t\tfor (channel = 1; channel < 31; channel++)\n\t\t\tif (!__rfcomm_get_listen_sock_by_addr(channel, src)) {\n\t\t\t\trfcomm_pi(sk)->channel = channel;\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\twrite_unlock(&rfcomm_sk_list.lock);\n\n\t\tif (err < 0)\n\t\t\tgoto done;\n\t}\n\n\tsk->sk_max_ack_backlog = backlog;\n\tsk->sk_ack_backlog = 0;\n\tsk->sk_state = BT_LISTEN;\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int rfcomm_sock_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tstruct sock *sk = sock->sk, *nsk;\n\tlong timeo;\n\tint err = 0;\n\n\tlock_sock_nested(sk, SINGLE_DEPTH_NESTING);\n\n\tif (sk->sk_type != SOCK_STREAM) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\ttimeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);\n\n\tBT_DBG(\"sk %p timeo %ld\", sk, timeo);\n\n\t/* Wait for an incoming connection. (wake-one). */\n\tadd_wait_queue_exclusive(sk_sleep(sk), &wait);\n\twhile (1) {\n\t\tif (sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EBADFD;\n\t\t\tbreak;\n\t\t}\n\n\t\tnsk = bt_accept_dequeue(sk, newsock);\n\t\tif (nsk)\n\t\t\tbreak;\n\n\t\tif (!timeo) {\n\t\t\terr = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\terr = sock_intr_errno(timeo);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_sock(sk);\n\n\t\ttimeo = wait_woken(&wait, TASK_INTERRUPTIBLE, timeo);\n\n\t\tlock_sock_nested(sk, SINGLE_DEPTH_NESTING);\n\t}\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\n\tif (err)\n\t\tgoto done;\n\n\tnewsock->state = SS_CONNECTED;\n\n\tBT_DBG(\"new socket %p\", nsk);\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int rfcomm_sock_getname(struct socket *sock, struct sockaddr *addr, int *len, int peer)\n{\n\tstruct sockaddr_rc *sa = (struct sockaddr_rc *) addr;\n\tstruct sock *sk = sock->sk;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (peer && sk->sk_state != BT_CONNECTED &&\n\t    sk->sk_state != BT_CONNECT && sk->sk_state != BT_CONNECT2)\n\t\treturn -ENOTCONN;\n\n\tmemset(sa, 0, sizeof(*sa));\n\tsa->rc_family  = AF_BLUETOOTH;\n\tsa->rc_channel = rfcomm_pi(sk)->channel;\n\tif (peer)\n\t\tbacpy(&sa->rc_bdaddr, &rfcomm_pi(sk)->dst);\n\telse\n\t\tbacpy(&sa->rc_bdaddr, &rfcomm_pi(sk)->src);\n\n\t*len = sizeof(struct sockaddr_rc);\n\treturn 0;\n}\n\nstatic int rfcomm_sock_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t       size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rfcomm_dlc *d = rfcomm_pi(sk)->dlc;\n\tstruct sk_buff *skb;\n\tint sent;\n\n\tif (test_bit(RFCOMM_DEFER_SETUP, &d->flags))\n\t\treturn -ENOTCONN;\n\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (sk->sk_shutdown & SEND_SHUTDOWN)\n\t\treturn -EPIPE;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tlock_sock(sk);\n\n\tsent = bt_sock_wait_ready(sk, msg->msg_flags);\n\tif (sent)\n\t\tgoto done;\n\n\twhile (len) {\n\t\tsize_t size = min_t(size_t, len, d->mtu);\n\t\tint err;\n\n\t\tskb = sock_alloc_send_skb(sk, size + RFCOMM_SKB_RESERVE,\n\t\t\t\tmsg->msg_flags & MSG_DONTWAIT, &err);\n\t\tif (!skb) {\n\t\t\tif (sent == 0)\n\t\t\t\tsent = err;\n\t\t\tbreak;\n\t\t}\n\t\tskb_reserve(skb, RFCOMM_SKB_HEAD_RESERVE);\n\n\t\terr = memcpy_from_msg(skb_put(skb, size), msg, size);\n\t\tif (err) {\n\t\t\tkfree_skb(skb);\n\t\t\tif (sent == 0)\n\t\t\t\tsent = err;\n\t\t\tbreak;\n\t\t}\n\n\t\tskb->priority = sk->sk_priority;\n\n\t\terr = rfcomm_dlc_send(d, skb);\n\t\tif (err < 0) {\n\t\t\tkfree_skb(skb);\n\t\t\tif (sent == 0)\n\t\t\t\tsent = err;\n\t\t\tbreak;\n\t\t}\n\n\t\tsent += size;\n\t\tlen  -= size;\n\t}\n\ndone:\n\trelease_sock(sk);\n\n\treturn sent;\n}\n\nstatic int rfcomm_sock_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t       size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rfcomm_dlc *d = rfcomm_pi(sk)->dlc;\n\tint len;\n\n\tif (test_and_clear_bit(RFCOMM_DEFER_SETUP, &d->flags)) {\n\t\trfcomm_dlc_accept(d);\n\t\treturn 0;\n\t}\n\n\tlen = bt_sock_stream_recvmsg(sock, msg, size, flags);\n\n\tlock_sock(sk);\n\tif (!(flags & MSG_PEEK) && len > 0)\n\t\tatomic_sub(len, &sk->sk_rmem_alloc);\n\n\tif (atomic_read(&sk->sk_rmem_alloc) <= (sk->sk_rcvbuf >> 2))\n\t\trfcomm_dlc_unthrottle(rfcomm_pi(sk)->dlc);\n\trelease_sock(sk);\n\n\treturn len;\n}\n\nstatic int rfcomm_sock_setsockopt_old(struct socket *sock, int optname, char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\tu32 opt;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase RFCOMM_LM:\n\t\tif (get_user(opt, (u32 __user *) optval)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt & RFCOMM_LM_FIPS) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt & RFCOMM_LM_AUTH)\n\t\t\trfcomm_pi(sk)->sec_level = BT_SECURITY_LOW;\n\t\tif (opt & RFCOMM_LM_ENCRYPT)\n\t\t\trfcomm_pi(sk)->sec_level = BT_SECURITY_MEDIUM;\n\t\tif (opt & RFCOMM_LM_SECURE)\n\t\t\trfcomm_pi(sk)->sec_level = BT_SECURITY_HIGH;\n\n\t\trfcomm_pi(sk)->role_switch = (opt & RFCOMM_LM_MASTER);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int rfcomm_sock_setsockopt(struct socket *sock, int level, int optname, char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct bt_security sec;\n\tint err = 0;\n\tsize_t len;\n\tu32 opt;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (level == SOL_RFCOMM)\n\t\treturn rfcomm_sock_setsockopt_old(sock, optname, optval, optlen);\n\n\tif (level != SOL_BLUETOOTH)\n\t\treturn -ENOPROTOOPT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase BT_SECURITY:\n\t\tif (sk->sk_type != SOCK_STREAM) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tsec.level = BT_SECURITY_LOW;\n\n\t\tlen = min_t(unsigned int, sizeof(sec), optlen);\n\t\tif (copy_from_user((char *) &sec, optval, len)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sec.level > BT_SECURITY_HIGH) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\trfcomm_pi(sk)->sec_level = sec.level;\n\t\tbreak;\n\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (get_user(opt, (u32 __user *) optval)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt)\n\t\t\tset_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n\t\telse\n\t\t\tclear_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int rfcomm_sock_getsockopt_old(struct socket *sock, int optname, char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sock *l2cap_sk;\n\tstruct l2cap_conn *conn;\n\tstruct rfcomm_conninfo cinfo;\n\tint len, err = 0;\n\tu32 opt;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase RFCOMM_LM:\n\t\tswitch (rfcomm_pi(sk)->sec_level) {\n\t\tcase BT_SECURITY_LOW:\n\t\t\topt = RFCOMM_LM_AUTH;\n\t\t\tbreak;\n\t\tcase BT_SECURITY_MEDIUM:\n\t\t\topt = RFCOMM_LM_AUTH | RFCOMM_LM_ENCRYPT;\n\t\t\tbreak;\n\t\tcase BT_SECURITY_HIGH:\n\t\t\topt = RFCOMM_LM_AUTH | RFCOMM_LM_ENCRYPT |\n\t\t\t      RFCOMM_LM_SECURE;\n\t\t\tbreak;\n\t\tcase BT_SECURITY_FIPS:\n\t\t\topt = RFCOMM_LM_AUTH | RFCOMM_LM_ENCRYPT |\n\t\t\t      RFCOMM_LM_SECURE | RFCOMM_LM_FIPS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\topt = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rfcomm_pi(sk)->role_switch)\n\t\t\topt |= RFCOMM_LM_MASTER;\n\n\t\tif (put_user(opt, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase RFCOMM_CONNINFO:\n\t\tif (sk->sk_state != BT_CONNECTED &&\n\t\t\t\t\t!rfcomm_pi(sk)->dlc->defer_setup) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\n\t\tl2cap_sk = rfcomm_pi(sk)->dlc->session->sock->sk;\n\t\tconn = l2cap_pi(l2cap_sk)->chan->conn;\n\n\t\tmemset(&cinfo, 0, sizeof(cinfo));\n\t\tcinfo.hci_handle = conn->hcon->handle;\n\t\tmemcpy(cinfo.dev_class, conn->hcon->dev_class, 3);\n\n\t\tlen = min_t(unsigned int, len, sizeof(cinfo));\n\t\tif (copy_to_user(optval, (char *) &cinfo, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int rfcomm_sock_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct bt_security sec;\n\tint len, err = 0;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (level == SOL_RFCOMM)\n\t\treturn rfcomm_sock_getsockopt_old(sock, optname, optval, optlen);\n\n\tif (level != SOL_BLUETOOTH)\n\t\treturn -ENOPROTOOPT;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase BT_SECURITY:\n\t\tif (sk->sk_type != SOCK_STREAM) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tsec.level = rfcomm_pi(sk)->sec_level;\n\t\tsec.key_size = 0;\n\n\t\tlen = min_t(unsigned int, len, sizeof(sec));\n\t\tif (copy_to_user(optval, (char *) &sec, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (put_user(test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags),\n\t\t\t     (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int rfcomm_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tstruct sock *sk __maybe_unused = sock->sk;\n\tint err;\n\n\tBT_DBG(\"sk %p cmd %x arg %lx\", sk, cmd, arg);\n\n\terr = bt_sock_ioctl(sock, cmd, arg);\n\n\tif (err == -ENOIOCTLCMD) {\n#ifdef CONFIG_BT_RFCOMM_TTY\n\t\tlock_sock(sk);\n\t\terr = rfcomm_dev_ioctl(sk, cmd, (void __user *) arg);\n\t\trelease_sock(sk);\n#else\n\t\terr = -EOPNOTSUPP;\n#endif\n\t}\n\n\treturn err;\n}\n\nstatic int rfcomm_sock_shutdown(struct socket *sock, int how)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (!sk)\n\t\treturn 0;\n\n\tlock_sock(sk);\n\tif (!sk->sk_shutdown) {\n\t\tsk->sk_shutdown = SHUTDOWN_MASK;\n\t\t__rfcomm_sock_close(sk);\n\n\t\tif (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime &&\n\t\t    !(current->flags & PF_EXITING))\n\t\t\terr = bt_sock_wait_state(sk, BT_CLOSED, sk->sk_lingertime);\n\t}\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int rfcomm_sock_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tint err;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (!sk)\n\t\treturn 0;\n\n\terr = rfcomm_sock_shutdown(sock, 2);\n\n\tsock_orphan(sk);\n\trfcomm_sock_kill(sk);\n\treturn err;\n}\n\n/* ---- RFCOMM core layer callbacks ----\n *\n * called under rfcomm_lock()\n */\nint rfcomm_connect_ind(struct rfcomm_session *s, u8 channel, struct rfcomm_dlc **d)\n{\n\tstruct sock *sk, *parent;\n\tbdaddr_t src, dst;\n\tint result = 0;\n\n\tBT_DBG(\"session %p channel %d\", s, channel);\n\n\trfcomm_session_getaddr(s, &src, &dst);\n\n\t/* Check if we have socket listening on channel */\n\tparent = rfcomm_get_sock_by_channel(BT_LISTEN, channel, &src);\n\tif (!parent)\n\t\treturn 0;\n\n\tbh_lock_sock(parent);\n\n\t/* Check for backlog size */\n\tif (sk_acceptq_is_full(parent)) {\n\t\tBT_DBG(\"backlog full %d\", parent->sk_ack_backlog);\n\t\tgoto done;\n\t}\n\n\tsk = rfcomm_sock_alloc(sock_net(parent), NULL, BTPROTO_RFCOMM, GFP_ATOMIC, 0);\n\tif (!sk)\n\t\tgoto done;\n\n\tbt_sock_reclassify_lock(sk, BTPROTO_RFCOMM);\n\n\trfcomm_sock_init(sk, parent);\n\tbacpy(&rfcomm_pi(sk)->src, &src);\n\tbacpy(&rfcomm_pi(sk)->dst, &dst);\n\trfcomm_pi(sk)->channel = channel;\n\n\tsk->sk_state = BT_CONFIG;\n\tbt_accept_enqueue(parent, sk);\n\n\t/* Accept connection and return socket DLC */\n\t*d = rfcomm_pi(sk)->dlc;\n\tresult = 1;\n\ndone:\n\tbh_unlock_sock(parent);\n\n\tif (test_bit(BT_SK_DEFER_SETUP, &bt_sk(parent)->flags))\n\t\tparent->sk_state_change(parent);\n\n\treturn result;\n}\n\nstatic int rfcomm_sock_debugfs_show(struct seq_file *f, void *p)\n{\n\tstruct sock *sk;\n\n\tread_lock(&rfcomm_sk_list.lock);\n\n\tsk_for_each(sk, &rfcomm_sk_list.head) {\n\t\tseq_printf(f, \"%pMR %pMR %d %d\\n\",\n\t\t\t   &rfcomm_pi(sk)->src, &rfcomm_pi(sk)->dst,\n\t\t\t   sk->sk_state, rfcomm_pi(sk)->channel);\n\t}\n\n\tread_unlock(&rfcomm_sk_list.lock);\n\n\treturn 0;\n}\n\nstatic int rfcomm_sock_debugfs_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, rfcomm_sock_debugfs_show, inode->i_private);\n}\n\nstatic const struct file_operations rfcomm_sock_debugfs_fops = {\n\t.open\t\t= rfcomm_sock_debugfs_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nstatic struct dentry *rfcomm_sock_debugfs;\n\nstatic const struct proto_ops rfcomm_sock_ops = {\n\t.family\t\t= PF_BLUETOOTH,\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= rfcomm_sock_release,\n\t.bind\t\t= rfcomm_sock_bind,\n\t.connect\t= rfcomm_sock_connect,\n\t.listen\t\t= rfcomm_sock_listen,\n\t.accept\t\t= rfcomm_sock_accept,\n\t.getname\t= rfcomm_sock_getname,\n\t.sendmsg\t= rfcomm_sock_sendmsg,\n\t.recvmsg\t= rfcomm_sock_recvmsg,\n\t.shutdown\t= rfcomm_sock_shutdown,\n\t.setsockopt\t= rfcomm_sock_setsockopt,\n\t.getsockopt\t= rfcomm_sock_getsockopt,\n\t.ioctl\t\t= rfcomm_sock_ioctl,\n\t.poll\t\t= bt_sock_poll,\n\t.socketpair\t= sock_no_socketpair,\n\t.mmap\t\t= sock_no_mmap\n};\n\nstatic const struct net_proto_family rfcomm_sock_family_ops = {\n\t.family\t\t= PF_BLUETOOTH,\n\t.owner\t\t= THIS_MODULE,\n\t.create\t\t= rfcomm_sock_create\n};\n\nint __init rfcomm_init_sockets(void)\n{\n\tint err;\n\n\tBUILD_BUG_ON(sizeof(struct sockaddr_rc) > sizeof(struct sockaddr));\n\n\terr = proto_register(&rfcomm_proto, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = bt_sock_register(BTPROTO_RFCOMM, &rfcomm_sock_family_ops);\n\tif (err < 0) {\n\t\tBT_ERR(\"RFCOMM socket layer registration failed\");\n\t\tgoto error;\n\t}\n\n\terr = bt_procfs_init(&init_net, \"rfcomm\", &rfcomm_sk_list, NULL);\n\tif (err < 0) {\n\t\tBT_ERR(\"Failed to create RFCOMM proc file\");\n\t\tbt_sock_unregister(BTPROTO_RFCOMM);\n\t\tgoto error;\n\t}\n\n\tBT_INFO(\"RFCOMM socket layer initialized\");\n\n\tif (IS_ERR_OR_NULL(bt_debugfs))\n\t\treturn 0;\n\n\trfcomm_sock_debugfs = debugfs_create_file(\"rfcomm\", 0444,\n\t\t\t\t\t\t  bt_debugfs, NULL,\n\t\t\t\t\t\t  &rfcomm_sock_debugfs_fops);\n\n\treturn 0;\n\nerror:\n\tproto_unregister(&rfcomm_proto);\n\treturn err;\n}\n\nvoid __exit rfcomm_cleanup_sockets(void)\n{\n\tbt_procfs_cleanup(&init_net, \"rfcomm\");\n\n\tdebugfs_remove(rfcomm_sock_debugfs);\n\n\tbt_sock_unregister(BTPROTO_RFCOMM);\n\n\tproto_unregister(&rfcomm_proto);\n}\n"], "fixing_code": ["/*\n   RFCOMM implementation for Linux Bluetooth stack (BlueZ).\n   Copyright (C) 2002 Maxim Krasnyansky <maxk@qualcomm.com>\n   Copyright (C) 2002 Marcel Holtmann <marcel@holtmann.org>\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License version 2 as\n   published by the Free Software Foundation;\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.\n   IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY\n   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES\n   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS,\n   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS\n   SOFTWARE IS DISCLAIMED.\n*/\n\n/*\n * RFCOMM sockets.\n */\n\n#include <linux/export.h>\n#include <linux/debugfs.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <net/bluetooth/l2cap.h>\n#include <net/bluetooth/rfcomm.h>\n\nstatic const struct proto_ops rfcomm_sock_ops;\n\nstatic struct bt_sock_list rfcomm_sk_list = {\n\t.lock = __RW_LOCK_UNLOCKED(rfcomm_sk_list.lock)\n};\n\nstatic void rfcomm_sock_close(struct sock *sk);\nstatic void rfcomm_sock_kill(struct sock *sk);\n\n/* ---- DLC callbacks ----\n *\n * called under rfcomm_dlc_lock()\n */\nstatic void rfcomm_sk_data_ready(struct rfcomm_dlc *d, struct sk_buff *skb)\n{\n\tstruct sock *sk = d->owner;\n\tif (!sk)\n\t\treturn;\n\n\tatomic_add(skb->len, &sk->sk_rmem_alloc);\n\tskb_queue_tail(&sk->sk_receive_queue, skb);\n\tsk->sk_data_ready(sk);\n\n\tif (atomic_read(&sk->sk_rmem_alloc) >= sk->sk_rcvbuf)\n\t\trfcomm_dlc_throttle(d);\n}\n\nstatic void rfcomm_sk_state_change(struct rfcomm_dlc *d, int err)\n{\n\tstruct sock *sk = d->owner, *parent;\n\tunsigned long flags;\n\n\tif (!sk)\n\t\treturn;\n\n\tBT_DBG(\"dlc %p state %ld err %d\", d, d->state, err);\n\n\tlocal_irq_save(flags);\n\tbh_lock_sock(sk);\n\n\tif (err)\n\t\tsk->sk_err = err;\n\n\tsk->sk_state = d->state;\n\n\tparent = bt_sk(sk)->parent;\n\tif (parent) {\n\t\tif (d->state == BT_CLOSED) {\n\t\t\tsock_set_flag(sk, SOCK_ZAPPED);\n\t\t\tbt_accept_unlink(sk);\n\t\t}\n\t\tparent->sk_data_ready(parent);\n\t} else {\n\t\tif (d->state == BT_CONNECTED)\n\t\t\trfcomm_session_getaddr(d->session,\n\t\t\t\t\t       &rfcomm_pi(sk)->src, NULL);\n\t\tsk->sk_state_change(sk);\n\t}\n\n\tbh_unlock_sock(sk);\n\tlocal_irq_restore(flags);\n\n\tif (parent && sock_flag(sk, SOCK_ZAPPED)) {\n\t\t/* We have to drop DLC lock here, otherwise\n\t\t * rfcomm_sock_destruct() will dead lock. */\n\t\trfcomm_dlc_unlock(d);\n\t\trfcomm_sock_kill(sk);\n\t\trfcomm_dlc_lock(d);\n\t}\n}\n\n/* ---- Socket functions ---- */\nstatic struct sock *__rfcomm_get_listen_sock_by_addr(u8 channel, bdaddr_t *src)\n{\n\tstruct sock *sk = NULL;\n\n\tsk_for_each(sk, &rfcomm_sk_list.head) {\n\t\tif (rfcomm_pi(sk)->channel != channel)\n\t\t\tcontinue;\n\n\t\tif (bacmp(&rfcomm_pi(sk)->src, src))\n\t\t\tcontinue;\n\n\t\tif (sk->sk_state == BT_BOUND || sk->sk_state == BT_LISTEN)\n\t\t\tbreak;\n\t}\n\n\treturn sk ? sk : NULL;\n}\n\n/* Find socket with channel and source bdaddr.\n * Returns closest match.\n */\nstatic struct sock *rfcomm_get_sock_by_channel(int state, u8 channel, bdaddr_t *src)\n{\n\tstruct sock *sk = NULL, *sk1 = NULL;\n\n\tread_lock(&rfcomm_sk_list.lock);\n\n\tsk_for_each(sk, &rfcomm_sk_list.head) {\n\t\tif (state && sk->sk_state != state)\n\t\t\tcontinue;\n\n\t\tif (rfcomm_pi(sk)->channel == channel) {\n\t\t\t/* Exact match. */\n\t\t\tif (!bacmp(&rfcomm_pi(sk)->src, src))\n\t\t\t\tbreak;\n\n\t\t\t/* Closest match */\n\t\t\tif (!bacmp(&rfcomm_pi(sk)->src, BDADDR_ANY))\n\t\t\t\tsk1 = sk;\n\t\t}\n\t}\n\n\tread_unlock(&rfcomm_sk_list.lock);\n\n\treturn sk ? sk : sk1;\n}\n\nstatic void rfcomm_sock_destruct(struct sock *sk)\n{\n\tstruct rfcomm_dlc *d = rfcomm_pi(sk)->dlc;\n\n\tBT_DBG(\"sk %p dlc %p\", sk, d);\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tskb_queue_purge(&sk->sk_write_queue);\n\n\trfcomm_dlc_lock(d);\n\trfcomm_pi(sk)->dlc = NULL;\n\n\t/* Detach DLC if it's owned by this socket */\n\tif (d->owner == sk)\n\t\td->owner = NULL;\n\trfcomm_dlc_unlock(d);\n\n\trfcomm_dlc_put(d);\n}\n\nstatic void rfcomm_sock_cleanup_listen(struct sock *parent)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"parent %p\", parent);\n\n\t/* Close not yet accepted dlcs */\n\twhile ((sk = bt_accept_dequeue(parent, NULL))) {\n\t\trfcomm_sock_close(sk);\n\t\trfcomm_sock_kill(sk);\n\t}\n\n\tparent->sk_state  = BT_CLOSED;\n\tsock_set_flag(parent, SOCK_ZAPPED);\n}\n\n/* Kill socket (only if zapped and orphan)\n * Must be called on unlocked socket.\n */\nstatic void rfcomm_sock_kill(struct sock *sk)\n{\n\tif (!sock_flag(sk, SOCK_ZAPPED) || sk->sk_socket)\n\t\treturn;\n\n\tBT_DBG(\"sk %p state %d refcnt %d\", sk, sk->sk_state, atomic_read(&sk->sk_refcnt));\n\n\t/* Kill poor orphan */\n\tbt_sock_unlink(&rfcomm_sk_list, sk);\n\tsock_set_flag(sk, SOCK_DEAD);\n\tsock_put(sk);\n}\n\nstatic void __rfcomm_sock_close(struct sock *sk)\n{\n\tstruct rfcomm_dlc *d = rfcomm_pi(sk)->dlc;\n\n\tBT_DBG(\"sk %p state %d socket %p\", sk, sk->sk_state, sk->sk_socket);\n\n\tswitch (sk->sk_state) {\n\tcase BT_LISTEN:\n\t\trfcomm_sock_cleanup_listen(sk);\n\t\tbreak;\n\n\tcase BT_CONNECT:\n\tcase BT_CONNECT2:\n\tcase BT_CONFIG:\n\tcase BT_CONNECTED:\n\t\trfcomm_dlc_close(d, 0);\n\n\tdefault:\n\t\tsock_set_flag(sk, SOCK_ZAPPED);\n\t\tbreak;\n\t}\n}\n\n/* Close socket.\n * Must be called on unlocked socket.\n */\nstatic void rfcomm_sock_close(struct sock *sk)\n{\n\tlock_sock(sk);\n\t__rfcomm_sock_close(sk);\n\trelease_sock(sk);\n}\n\nstatic void rfcomm_sock_init(struct sock *sk, struct sock *parent)\n{\n\tstruct rfcomm_pinfo *pi = rfcomm_pi(sk);\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (parent) {\n\t\tsk->sk_type = parent->sk_type;\n\t\tpi->dlc->defer_setup = test_bit(BT_SK_DEFER_SETUP,\n\t\t\t\t\t\t&bt_sk(parent)->flags);\n\n\t\tpi->sec_level = rfcomm_pi(parent)->sec_level;\n\t\tpi->role_switch = rfcomm_pi(parent)->role_switch;\n\n\t\tsecurity_sk_clone(parent, sk);\n\t} else {\n\t\tpi->dlc->defer_setup = 0;\n\n\t\tpi->sec_level = BT_SECURITY_LOW;\n\t\tpi->role_switch = 0;\n\t}\n\n\tpi->dlc->sec_level = pi->sec_level;\n\tpi->dlc->role_switch = pi->role_switch;\n}\n\nstatic struct proto rfcomm_proto = {\n\t.name\t\t= \"RFCOMM\",\n\t.owner\t\t= THIS_MODULE,\n\t.obj_size\t= sizeof(struct rfcomm_pinfo)\n};\n\nstatic struct sock *rfcomm_sock_alloc(struct net *net, struct socket *sock, int proto, gfp_t prio, int kern)\n{\n\tstruct rfcomm_dlc *d;\n\tstruct sock *sk;\n\n\tsk = sk_alloc(net, PF_BLUETOOTH, prio, &rfcomm_proto, kern);\n\tif (!sk)\n\t\treturn NULL;\n\n\tsock_init_data(sock, sk);\n\tINIT_LIST_HEAD(&bt_sk(sk)->accept_q);\n\n\td = rfcomm_dlc_alloc(prio);\n\tif (!d) {\n\t\tsk_free(sk);\n\t\treturn NULL;\n\t}\n\n\td->data_ready   = rfcomm_sk_data_ready;\n\td->state_change = rfcomm_sk_state_change;\n\n\trfcomm_pi(sk)->dlc = d;\n\td->owner = sk;\n\n\tsk->sk_destruct = rfcomm_sock_destruct;\n\tsk->sk_sndtimeo = RFCOMM_CONN_TIMEOUT;\n\n\tsk->sk_sndbuf = RFCOMM_MAX_CREDITS * RFCOMM_DEFAULT_MTU * 10;\n\tsk->sk_rcvbuf = RFCOMM_MAX_CREDITS * RFCOMM_DEFAULT_MTU * 10;\n\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\n\tsk->sk_protocol = proto;\n\tsk->sk_state    = BT_OPEN;\n\n\tbt_sock_link(&rfcomm_sk_list, sk);\n\n\tBT_DBG(\"sk %p\", sk);\n\treturn sk;\n}\n\nstatic int rfcomm_sock_create(struct net *net, struct socket *sock,\n\t\t\t      int protocol, int kern)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"sock %p\", sock);\n\n\tsock->state = SS_UNCONNECTED;\n\n\tif (sock->type != SOCK_STREAM && sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tsock->ops = &rfcomm_sock_ops;\n\n\tsk = rfcomm_sock_alloc(net, sock, protocol, GFP_ATOMIC, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\trfcomm_sock_init(sk, NULL);\n\treturn 0;\n}\n\nstatic int rfcomm_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)\n{\n\tstruct sockaddr_rc sa;\n\tstruct sock *sk = sock->sk;\n\tint len, err = 0;\n\n\tif (!addr || addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tmemset(&sa, 0, sizeof(sa));\n\tlen = min_t(unsigned int, sizeof(sa), addr_len);\n\tmemcpy(&sa, addr, len);\n\n\tBT_DBG(\"sk %p %pMR\", sk, &sa.rc_bdaddr);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_OPEN) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (sk->sk_type != SOCK_STREAM) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\twrite_lock(&rfcomm_sk_list.lock);\n\n\tif (sa.rc_channel &&\n\t    __rfcomm_get_listen_sock_by_addr(sa.rc_channel, &sa.rc_bdaddr)) {\n\t\terr = -EADDRINUSE;\n\t} else {\n\t\t/* Save source address */\n\t\tbacpy(&rfcomm_pi(sk)->src, &sa.rc_bdaddr);\n\t\trfcomm_pi(sk)->channel = sa.rc_channel;\n\t\tsk->sk_state = BT_BOUND;\n\t}\n\n\twrite_unlock(&rfcomm_sk_list.lock);\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int rfcomm_sock_connect(struct socket *sock, struct sockaddr *addr, int alen, int flags)\n{\n\tstruct sockaddr_rc *sa = (struct sockaddr_rc *) addr;\n\tstruct sock *sk = sock->sk;\n\tstruct rfcomm_dlc *d = rfcomm_pi(sk)->dlc;\n\tint err = 0;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (alen < sizeof(struct sockaddr_rc) ||\n\t    addr->sa_family != AF_BLUETOOTH)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_OPEN && sk->sk_state != BT_BOUND) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (sk->sk_type != SOCK_STREAM) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tsk->sk_state = BT_CONNECT;\n\tbacpy(&rfcomm_pi(sk)->dst, &sa->rc_bdaddr);\n\trfcomm_pi(sk)->channel = sa->rc_channel;\n\n\td->sec_level = rfcomm_pi(sk)->sec_level;\n\td->role_switch = rfcomm_pi(sk)->role_switch;\n\n\terr = rfcomm_dlc_open(d, &rfcomm_pi(sk)->src, &sa->rc_bdaddr,\n\t\t\t      sa->rc_channel);\n\tif (!err)\n\t\terr = bt_sock_wait_state(sk, BT_CONNECTED,\n\t\t\t\tsock_sndtimeo(sk, flags & O_NONBLOCK));\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int rfcomm_sock_listen(struct socket *sock, int backlog)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sk %p backlog %d\", sk, backlog);\n\n\tlock_sock(sk);\n\n\tif (sk->sk_state != BT_BOUND) {\n\t\terr = -EBADFD;\n\t\tgoto done;\n\t}\n\n\tif (sk->sk_type != SOCK_STREAM) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (!rfcomm_pi(sk)->channel) {\n\t\tbdaddr_t *src = &rfcomm_pi(sk)->src;\n\t\tu8 channel;\n\n\t\terr = -EINVAL;\n\n\t\twrite_lock(&rfcomm_sk_list.lock);\n\n\t\tfor (channel = 1; channel < 31; channel++)\n\t\t\tif (!__rfcomm_get_listen_sock_by_addr(channel, src)) {\n\t\t\t\trfcomm_pi(sk)->channel = channel;\n\t\t\t\terr = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\twrite_unlock(&rfcomm_sk_list.lock);\n\n\t\tif (err < 0)\n\t\t\tgoto done;\n\t}\n\n\tsk->sk_max_ack_backlog = backlog;\n\tsk->sk_ack_backlog = 0;\n\tsk->sk_state = BT_LISTEN;\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int rfcomm_sock_accept(struct socket *sock, struct socket *newsock, int flags)\n{\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tstruct sock *sk = sock->sk, *nsk;\n\tlong timeo;\n\tint err = 0;\n\n\tlock_sock_nested(sk, SINGLE_DEPTH_NESTING);\n\n\tif (sk->sk_type != SOCK_STREAM) {\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\n\ttimeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);\n\n\tBT_DBG(\"sk %p timeo %ld\", sk, timeo);\n\n\t/* Wait for an incoming connection. (wake-one). */\n\tadd_wait_queue_exclusive(sk_sleep(sk), &wait);\n\twhile (1) {\n\t\tif (sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EBADFD;\n\t\t\tbreak;\n\t\t}\n\n\t\tnsk = bt_accept_dequeue(sk, newsock);\n\t\tif (nsk)\n\t\t\tbreak;\n\n\t\tif (!timeo) {\n\t\t\terr = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (signal_pending(current)) {\n\t\t\terr = sock_intr_errno(timeo);\n\t\t\tbreak;\n\t\t}\n\n\t\trelease_sock(sk);\n\n\t\ttimeo = wait_woken(&wait, TASK_INTERRUPTIBLE, timeo);\n\n\t\tlock_sock_nested(sk, SINGLE_DEPTH_NESTING);\n\t}\n\tremove_wait_queue(sk_sleep(sk), &wait);\n\n\tif (err)\n\t\tgoto done;\n\n\tnewsock->state = SS_CONNECTED;\n\n\tBT_DBG(\"new socket %p\", nsk);\n\ndone:\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int rfcomm_sock_getname(struct socket *sock, struct sockaddr *addr, int *len, int peer)\n{\n\tstruct sockaddr_rc *sa = (struct sockaddr_rc *) addr;\n\tstruct sock *sk = sock->sk;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (peer && sk->sk_state != BT_CONNECTED &&\n\t    sk->sk_state != BT_CONNECT && sk->sk_state != BT_CONNECT2)\n\t\treturn -ENOTCONN;\n\n\tmemset(sa, 0, sizeof(*sa));\n\tsa->rc_family  = AF_BLUETOOTH;\n\tsa->rc_channel = rfcomm_pi(sk)->channel;\n\tif (peer)\n\t\tbacpy(&sa->rc_bdaddr, &rfcomm_pi(sk)->dst);\n\telse\n\t\tbacpy(&sa->rc_bdaddr, &rfcomm_pi(sk)->src);\n\n\t*len = sizeof(struct sockaddr_rc);\n\treturn 0;\n}\n\nstatic int rfcomm_sock_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t       size_t len)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rfcomm_dlc *d = rfcomm_pi(sk)->dlc;\n\tstruct sk_buff *skb;\n\tint sent;\n\n\tif (test_bit(RFCOMM_DEFER_SETUP, &d->flags))\n\t\treturn -ENOTCONN;\n\n\tif (msg->msg_flags & MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (sk->sk_shutdown & SEND_SHUTDOWN)\n\t\treturn -EPIPE;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tlock_sock(sk);\n\n\tsent = bt_sock_wait_ready(sk, msg->msg_flags);\n\tif (sent)\n\t\tgoto done;\n\n\twhile (len) {\n\t\tsize_t size = min_t(size_t, len, d->mtu);\n\t\tint err;\n\n\t\tskb = sock_alloc_send_skb(sk, size + RFCOMM_SKB_RESERVE,\n\t\t\t\tmsg->msg_flags & MSG_DONTWAIT, &err);\n\t\tif (!skb) {\n\t\t\tif (sent == 0)\n\t\t\t\tsent = err;\n\t\t\tbreak;\n\t\t}\n\t\tskb_reserve(skb, RFCOMM_SKB_HEAD_RESERVE);\n\n\t\terr = memcpy_from_msg(skb_put(skb, size), msg, size);\n\t\tif (err) {\n\t\t\tkfree_skb(skb);\n\t\t\tif (sent == 0)\n\t\t\t\tsent = err;\n\t\t\tbreak;\n\t\t}\n\n\t\tskb->priority = sk->sk_priority;\n\n\t\terr = rfcomm_dlc_send(d, skb);\n\t\tif (err < 0) {\n\t\t\tkfree_skb(skb);\n\t\t\tif (sent == 0)\n\t\t\t\tsent = err;\n\t\t\tbreak;\n\t\t}\n\n\t\tsent += size;\n\t\tlen  -= size;\n\t}\n\ndone:\n\trelease_sock(sk);\n\n\treturn sent;\n}\n\nstatic int rfcomm_sock_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t       size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rfcomm_dlc *d = rfcomm_pi(sk)->dlc;\n\tint len;\n\n\tif (test_and_clear_bit(RFCOMM_DEFER_SETUP, &d->flags)) {\n\t\trfcomm_dlc_accept(d);\n\t\treturn 0;\n\t}\n\n\tlen = bt_sock_stream_recvmsg(sock, msg, size, flags);\n\n\tlock_sock(sk);\n\tif (!(flags & MSG_PEEK) && len > 0)\n\t\tatomic_sub(len, &sk->sk_rmem_alloc);\n\n\tif (atomic_read(&sk->sk_rmem_alloc) <= (sk->sk_rcvbuf >> 2))\n\t\trfcomm_dlc_unthrottle(rfcomm_pi(sk)->dlc);\n\trelease_sock(sk);\n\n\treturn len;\n}\n\nstatic int rfcomm_sock_setsockopt_old(struct socket *sock, int optname, char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\tu32 opt;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase RFCOMM_LM:\n\t\tif (get_user(opt, (u32 __user *) optval)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt & RFCOMM_LM_FIPS) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt & RFCOMM_LM_AUTH)\n\t\t\trfcomm_pi(sk)->sec_level = BT_SECURITY_LOW;\n\t\tif (opt & RFCOMM_LM_ENCRYPT)\n\t\t\trfcomm_pi(sk)->sec_level = BT_SECURITY_MEDIUM;\n\t\tif (opt & RFCOMM_LM_SECURE)\n\t\t\trfcomm_pi(sk)->sec_level = BT_SECURITY_HIGH;\n\n\t\trfcomm_pi(sk)->role_switch = (opt & RFCOMM_LM_MASTER);\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int rfcomm_sock_setsockopt(struct socket *sock, int level, int optname, char __user *optval, unsigned int optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct bt_security sec;\n\tint err = 0;\n\tsize_t len;\n\tu32 opt;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (level == SOL_RFCOMM)\n\t\treturn rfcomm_sock_setsockopt_old(sock, optname, optval, optlen);\n\n\tif (level != SOL_BLUETOOTH)\n\t\treturn -ENOPROTOOPT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase BT_SECURITY:\n\t\tif (sk->sk_type != SOCK_STREAM) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tsec.level = BT_SECURITY_LOW;\n\n\t\tlen = min_t(unsigned int, sizeof(sec), optlen);\n\t\tif (copy_from_user((char *) &sec, optval, len)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (sec.level > BT_SECURITY_HIGH) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\trfcomm_pi(sk)->sec_level = sec.level;\n\t\tbreak;\n\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (get_user(opt, (u32 __user *) optval)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (opt)\n\t\t\tset_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n\t\telse\n\t\t\tclear_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags);\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int rfcomm_sock_getsockopt_old(struct socket *sock, int optname, char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sock *l2cap_sk;\n\tstruct l2cap_conn *conn;\n\tstruct rfcomm_conninfo cinfo;\n\tint len, err = 0;\n\tu32 opt;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase RFCOMM_LM:\n\t\tswitch (rfcomm_pi(sk)->sec_level) {\n\t\tcase BT_SECURITY_LOW:\n\t\t\topt = RFCOMM_LM_AUTH;\n\t\t\tbreak;\n\t\tcase BT_SECURITY_MEDIUM:\n\t\t\topt = RFCOMM_LM_AUTH | RFCOMM_LM_ENCRYPT;\n\t\t\tbreak;\n\t\tcase BT_SECURITY_HIGH:\n\t\t\topt = RFCOMM_LM_AUTH | RFCOMM_LM_ENCRYPT |\n\t\t\t      RFCOMM_LM_SECURE;\n\t\t\tbreak;\n\t\tcase BT_SECURITY_FIPS:\n\t\t\topt = RFCOMM_LM_AUTH | RFCOMM_LM_ENCRYPT |\n\t\t\t      RFCOMM_LM_SECURE | RFCOMM_LM_FIPS;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\topt = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rfcomm_pi(sk)->role_switch)\n\t\t\topt |= RFCOMM_LM_MASTER;\n\n\t\tif (put_user(opt, (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase RFCOMM_CONNINFO:\n\t\tif (sk->sk_state != BT_CONNECTED &&\n\t\t\t\t\t!rfcomm_pi(sk)->dlc->defer_setup) {\n\t\t\terr = -ENOTCONN;\n\t\t\tbreak;\n\t\t}\n\n\t\tl2cap_sk = rfcomm_pi(sk)->dlc->session->sock->sk;\n\t\tconn = l2cap_pi(l2cap_sk)->chan->conn;\n\n\t\tmemset(&cinfo, 0, sizeof(cinfo));\n\t\tcinfo.hci_handle = conn->hcon->handle;\n\t\tmemcpy(cinfo.dev_class, conn->hcon->dev_class, 3);\n\n\t\tlen = min_t(unsigned int, len, sizeof(cinfo));\n\t\tif (copy_to_user(optval, (char *) &cinfo, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int rfcomm_sock_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct bt_security sec;\n\tint len, err = 0;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (level == SOL_RFCOMM)\n\t\treturn rfcomm_sock_getsockopt_old(sock, optname, optval, optlen);\n\n\tif (level != SOL_BLUETOOTH)\n\t\treturn -ENOPROTOOPT;\n\n\tif (get_user(len, optlen))\n\t\treturn -EFAULT;\n\n\tlock_sock(sk);\n\n\tswitch (optname) {\n\tcase BT_SECURITY:\n\t\tif (sk->sk_type != SOCK_STREAM) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tsec.level = rfcomm_pi(sk)->sec_level;\n\t\tsec.key_size = 0;\n\n\t\tlen = min_t(unsigned int, len, sizeof(sec));\n\t\tif (copy_to_user(optval, (char *) &sec, len))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tcase BT_DEFER_SETUP:\n\t\tif (sk->sk_state != BT_BOUND && sk->sk_state != BT_LISTEN) {\n\t\t\terr = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (put_user(test_bit(BT_SK_DEFER_SETUP, &bt_sk(sk)->flags),\n\t\t\t     (u32 __user *) optval))\n\t\t\terr = -EFAULT;\n\n\t\tbreak;\n\n\tdefault:\n\t\terr = -ENOPROTOOPT;\n\t\tbreak;\n\t}\n\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int rfcomm_sock_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n\tstruct sock *sk __maybe_unused = sock->sk;\n\tint err;\n\n\tBT_DBG(\"sk %p cmd %x arg %lx\", sk, cmd, arg);\n\n\terr = bt_sock_ioctl(sock, cmd, arg);\n\n\tif (err == -ENOIOCTLCMD) {\n#ifdef CONFIG_BT_RFCOMM_TTY\n\t\tlock_sock(sk);\n\t\terr = rfcomm_dev_ioctl(sk, cmd, (void __user *) arg);\n\t\trelease_sock(sk);\n#else\n\t\terr = -EOPNOTSUPP;\n#endif\n\t}\n\n\treturn err;\n}\n\nstatic int rfcomm_sock_shutdown(struct socket *sock, int how)\n{\n\tstruct sock *sk = sock->sk;\n\tint err = 0;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (!sk)\n\t\treturn 0;\n\n\tlock_sock(sk);\n\tif (!sk->sk_shutdown) {\n\t\tsk->sk_shutdown = SHUTDOWN_MASK;\n\t\t__rfcomm_sock_close(sk);\n\n\t\tif (sock_flag(sk, SOCK_LINGER) && sk->sk_lingertime &&\n\t\t    !(current->flags & PF_EXITING))\n\t\t\terr = bt_sock_wait_state(sk, BT_CLOSED, sk->sk_lingertime);\n\t}\n\trelease_sock(sk);\n\treturn err;\n}\n\nstatic int rfcomm_sock_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tint err;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (!sk)\n\t\treturn 0;\n\n\terr = rfcomm_sock_shutdown(sock, 2);\n\n\tsock_orphan(sk);\n\trfcomm_sock_kill(sk);\n\treturn err;\n}\n\n/* ---- RFCOMM core layer callbacks ----\n *\n * called under rfcomm_lock()\n */\nint rfcomm_connect_ind(struct rfcomm_session *s, u8 channel, struct rfcomm_dlc **d)\n{\n\tstruct sock *sk, *parent;\n\tbdaddr_t src, dst;\n\tint result = 0;\n\n\tBT_DBG(\"session %p channel %d\", s, channel);\n\n\trfcomm_session_getaddr(s, &src, &dst);\n\n\t/* Check if we have socket listening on channel */\n\tparent = rfcomm_get_sock_by_channel(BT_LISTEN, channel, &src);\n\tif (!parent)\n\t\treturn 0;\n\n\tbh_lock_sock(parent);\n\n\t/* Check for backlog size */\n\tif (sk_acceptq_is_full(parent)) {\n\t\tBT_DBG(\"backlog full %d\", parent->sk_ack_backlog);\n\t\tgoto done;\n\t}\n\n\tsk = rfcomm_sock_alloc(sock_net(parent), NULL, BTPROTO_RFCOMM, GFP_ATOMIC, 0);\n\tif (!sk)\n\t\tgoto done;\n\n\tbt_sock_reclassify_lock(sk, BTPROTO_RFCOMM);\n\n\trfcomm_sock_init(sk, parent);\n\tbacpy(&rfcomm_pi(sk)->src, &src);\n\tbacpy(&rfcomm_pi(sk)->dst, &dst);\n\trfcomm_pi(sk)->channel = channel;\n\n\tsk->sk_state = BT_CONFIG;\n\tbt_accept_enqueue(parent, sk);\n\n\t/* Accept connection and return socket DLC */\n\t*d = rfcomm_pi(sk)->dlc;\n\tresult = 1;\n\ndone:\n\tbh_unlock_sock(parent);\n\n\tif (test_bit(BT_SK_DEFER_SETUP, &bt_sk(parent)->flags))\n\t\tparent->sk_state_change(parent);\n\n\treturn result;\n}\n\nstatic int rfcomm_sock_debugfs_show(struct seq_file *f, void *p)\n{\n\tstruct sock *sk;\n\n\tread_lock(&rfcomm_sk_list.lock);\n\n\tsk_for_each(sk, &rfcomm_sk_list.head) {\n\t\tseq_printf(f, \"%pMR %pMR %d %d\\n\",\n\t\t\t   &rfcomm_pi(sk)->src, &rfcomm_pi(sk)->dst,\n\t\t\t   sk->sk_state, rfcomm_pi(sk)->channel);\n\t}\n\n\tread_unlock(&rfcomm_sk_list.lock);\n\n\treturn 0;\n}\n\nstatic int rfcomm_sock_debugfs_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, rfcomm_sock_debugfs_show, inode->i_private);\n}\n\nstatic const struct file_operations rfcomm_sock_debugfs_fops = {\n\t.open\t\t= rfcomm_sock_debugfs_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nstatic struct dentry *rfcomm_sock_debugfs;\n\nstatic const struct proto_ops rfcomm_sock_ops = {\n\t.family\t\t= PF_BLUETOOTH,\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= rfcomm_sock_release,\n\t.bind\t\t= rfcomm_sock_bind,\n\t.connect\t= rfcomm_sock_connect,\n\t.listen\t\t= rfcomm_sock_listen,\n\t.accept\t\t= rfcomm_sock_accept,\n\t.getname\t= rfcomm_sock_getname,\n\t.sendmsg\t= rfcomm_sock_sendmsg,\n\t.recvmsg\t= rfcomm_sock_recvmsg,\n\t.shutdown\t= rfcomm_sock_shutdown,\n\t.setsockopt\t= rfcomm_sock_setsockopt,\n\t.getsockopt\t= rfcomm_sock_getsockopt,\n\t.ioctl\t\t= rfcomm_sock_ioctl,\n\t.poll\t\t= bt_sock_poll,\n\t.socketpair\t= sock_no_socketpair,\n\t.mmap\t\t= sock_no_mmap\n};\n\nstatic const struct net_proto_family rfcomm_sock_family_ops = {\n\t.family\t\t= PF_BLUETOOTH,\n\t.owner\t\t= THIS_MODULE,\n\t.create\t\t= rfcomm_sock_create\n};\n\nint __init rfcomm_init_sockets(void)\n{\n\tint err;\n\n\tBUILD_BUG_ON(sizeof(struct sockaddr_rc) > sizeof(struct sockaddr));\n\n\terr = proto_register(&rfcomm_proto, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = bt_sock_register(BTPROTO_RFCOMM, &rfcomm_sock_family_ops);\n\tif (err < 0) {\n\t\tBT_ERR(\"RFCOMM socket layer registration failed\");\n\t\tgoto error;\n\t}\n\n\terr = bt_procfs_init(&init_net, \"rfcomm\", &rfcomm_sk_list, NULL);\n\tif (err < 0) {\n\t\tBT_ERR(\"Failed to create RFCOMM proc file\");\n\t\tbt_sock_unregister(BTPROTO_RFCOMM);\n\t\tgoto error;\n\t}\n\n\tBT_INFO(\"RFCOMM socket layer initialized\");\n\n\tif (IS_ERR_OR_NULL(bt_debugfs))\n\t\treturn 0;\n\n\trfcomm_sock_debugfs = debugfs_create_file(\"rfcomm\", 0444,\n\t\t\t\t\t\t  bt_debugfs, NULL,\n\t\t\t\t\t\t  &rfcomm_sock_debugfs_fops);\n\n\treturn 0;\n\nerror:\n\tproto_unregister(&rfcomm_proto);\n\treturn err;\n}\n\nvoid __exit rfcomm_cleanup_sockets(void)\n{\n\tbt_procfs_cleanup(&init_net, \"rfcomm\");\n\n\tdebugfs_remove(rfcomm_sock_debugfs);\n\n\tbt_sock_unregister(BTPROTO_RFCOMM);\n\n\tproto_unregister(&rfcomm_proto);\n}\n"], "filenames": ["net/bluetooth/rfcomm/sock.c"], "buggy_code_start_loc": [337], "buggy_code_end_loc": [367], "fixing_code_start_loc": [337], "fixing_code_end_loc": [371], "type": "CWE-476", "message": "The rfcomm_sock_bind function in net/bluetooth/rfcomm/sock.c in the Linux kernel before 4.2 allows local users to obtain sensitive information or cause a denial of service (NULL pointer dereference) via vectors involving a bind system call on a Bluetooth RFCOMM socket.", "other": {"cve": {"id": "CVE-2015-8956", "sourceIdentifier": "security@android.com", "published": "2016-10-10T10:59:04.260", "lastModified": "2018-01-05T02:30:25.180", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The rfcomm_sock_bind function in net/bluetooth/rfcomm/sock.c in the Linux kernel before 4.2 allows local users to obtain sensitive information or cause a denial of service (NULL pointer dereference) via vectors involving a bind system call on a Bluetooth RFCOMM socket."}, {"lang": "es", "value": "La funci\u00f3n rfcomm_sock_bind en net/bluetooth/rfcomm/sock.c en el kernel de Linux en versiones anteriores a 4.2 permite a usuarios locales obtener informaci\u00f3n sensible o provocar una denegaci\u00f3n de servicio (referencia a puntero NULL) a trav\u00e9s de vectores relacionados con una llamada de sistema enlazada en un enchufe Bluetooth RFCOMM."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 3.6}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.1.33", "matchCriteriaId": "8CDEF683-A93B-4134-B220-E7BA44172B34"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:google:android:*:*:*:*:*:*:*:*", "versionEndIncluding": "7.0", "matchCriteriaId": "595E33EF-6B21-425B-929C-6B883FA50081"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=951b6a0717db97ce420547222647bcc40bf1eacd", "source": "security@android.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-2574.html", "source": "security@android.com"}, {"url": "http://rhn.redhat.com/errata/RHSA-2016-2584.html", "source": "security@android.com"}, {"url": "http://source.android.com/security/bulletin/2016-10-01.html", "source": "security@android.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/93326", "source": "security@android.com"}, {"url": "https://github.com/torvalds/linux/commit/951b6a0717db97ce420547222647bcc40bf1eacd", "source": "security@android.com", "tags": ["Issue Tracking", "Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/951b6a0717db97ce420547222647bcc40bf1eacd"}}